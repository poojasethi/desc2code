#include<bits/stdc++.h> using namespace std; int main() {     int t,m,n,num,i;     scanf("%d",&t);     while(t--)     {         scanf("%d%d",&n,&m);         vector<int> v(n);         for(i=0;i<n;i++)         {             scanf("%d",&(v[i]));         }         sort(v.begin(),v.end());         printf("%d\n",v[n-m]);     }     return 0; } 
#include <iostream>  using namespace std;  int main() {     int t;     long long int l,b;     cin>>t;     while(t--)     {         cin>>l>>b;         cout<<l*b<<"\n";     }     return 0; } 
#include <iostream>  using namespace std;  int main() {     char str[100000];     cin>>str;     long long int q;     cin>>q;     for(long long int p=0;p<q;++p)     {char ch;     long long int i,j,k,ctr=0;     cin>>i>>j>>ch;     for(k=i-1;k<=j-1;++k)     {         if(str[k]==ch)         ++ctr;     }     cout<<ctr<<"\n";}     return 0; } 
#include <iostream>  using namespace std;  int main() {     int t;     cin>>t;     while(t--)     {         long long int n;         cin>>n;         long long int ar[n],i;         for(i=0;i<n;++i)         {             cin>>ar[i];         }         long long int large =ar[0];         long long int small = ar[0];         for(i=0;i<n;++i)         {             if(ar[i]>large)             large=ar[i];             if(ar[i]<small)             small=ar[i];         }         cout<<large-small<<"\n";      }     return 0; } 
//From codeforces blog //just wanted to see the memory it consumes #include <map> #include <iostream> using namespace std;  #define long long long const long M = 1000000007; // modulo map<long, long> F;  long f(long n) { 	if (F.count(n)) return F[n]; 	long k=n/2; 	if (n%2==0) { // n=2*k 		return F[n] = (f(k)*f(k) + f(k-1)*f(k-1)) % M; 	} else { // n=2*k+1 		return F[n] = (f(k)*f(k+1) + f(k-1)*f(k)) % M; 	} }  main(){ 	long n; 	F[0]=F[1]=1; 	int t; 	cin>>t; 	while (t--) 	{ 		cin>>n; 		cout << (n==0 ? 0 : f(n-1)) << endl; 	} }
#include<iostream> #include<stdio.h> using namespace std; long long gcd(long long a,long long b) { 	if(b==0) 	 return(a); 	 else 	 return(gcd(b,a%b)); }   int main() { 	ios_base::sync_with_stdio(false); 	int t; 	cin>>t; 	while(t--) 	{ 		long long n; 		cin>>n; 		long long count=0; 		for(long long i=1;i<=n-2;i++) 		{  		   if(i%2!=0)  			count=count+i;  		 		} 		printf("%lld\n",count); 	} 	return 0; } 
//PPOW, Setter's solution #include<iostream> int powers[13][4006]={0}; int main() { 	int a,n,i,j,k=0,r,b,o,sum,t; 	//FILE *f1=freopen("in2.txt","r",stdin); 	//FILE *f2=freopen("out2.txt","w",stdout); 	r=0; 	//po[0]=1; 	for(o=2;o<=9;o++) 	{ 		k=0; 		r=0; 		int po[4004]={0}; 		po[0]=1; 		 	  for(i=1;i<=4000;i++) 	  { 		for(j=0;j<=k;j++) 		{ 		 po[j]=po[j]*o+r; 		 r=po[j]/10; 		 po[j]=po[j]%10; 		 //sum=0; 		  		 if(r!=0&&j==k) 		 k++; 		} 		sum=0; 		for(int l=0;l<=k;l++) 	     sum+=po[l]; 	     powers[o][i]=sum; 		 	  } 	 // printf("k=%d\n",k);     }     for(i=0;i<=4000;i++)     powers[1][i]=1;     for(i=1;i<=9;i++)     powers[i][0]=1; 	 //	printf("computed\n"); 	scanf("%d",&t); 	for(i=1;i<=t;i++) 	{ 		scanf("%d%d",&a,&b); 		printf("Case %d: %d\n",i,powers[a][b]); 	}	 //	fclose(f1); //	fclose(f2); 	return 0; } 
#include<stdio.h> #include<math.h> using namespace std;  int main() {     int t;     scanf("%d",&t);      while(t--)     {         double a,b,c;         scanf("%lf%lf%lf",&a,&b,&c);          double s = (a+b+c)/2;         double k = sqrt(s*(s-a)*(s-b)*(s-c));         double r = a*b*c/(4*k);          printf("%.2lf\n",r);     } } 
#include <stdio.h>  int main () { 	int T, num; 	scanf("%d",&T); 	while (T--) 	{ 		scanf("%d",&num); 		if (num==2 || num%4==1) 			printf("YES\n"); 		else 			printf("NO\n"); 	} 	return 0; }	 		 		 	
    #include<stdio.h>     #include<string.h>     #include<math.h>     #include<ctype.h>     #include<stdlib.h>     #include<iostream>     #include<algorithm>     #include<vector>     #include<map>     #include<set>     #include<queue>     #include<stack>     #include<sstream>     using namespace std;     #define INF 2000000000     #define INFLL (1LL<<62)     #define SS ({int x;scanf("%d", &x);x;})     #define SSL ({LL x;scanf("%lld", &x);x;})     #define rep(i,n) for(int i=0;i<(n);i++)     #define rept(i,m,n) for(int i=(m);i<(n);i++)     #define ull unsigned long long     #define lint long long     #define MX 10000001           typedef struct     {     lint x,y;     }pt;           bool cmp(pt a,pt b)     {     if(a.y!=b.y)     return a.y<b.y;     return a.x<b.x;     }           int main()     {     int i,j,k,l,n,m,t;     t=SS;     while(t--)     {     n=SS;     pt pts[n+1];     for(i=0;i<n;++i)     {     l=SS;     m=SS;     pts[i].x=l-1;     pts[i].y=m;     }     sort(pts,pts+n,cmp);     vector<lint> ysorted(n);     rep(i,n)     ysorted[i]=pts[i].y;     // rep(i,n)     // {     // printf("%lld ",ysorted[i]);     // cout<<pts[i].x<<" "<<pts[i].y<<endl;     // }           lint dp[n+1];     rep(i,n+1)     dp[i]=-111111111;     dp[0]=pts[0].y-pts[0].x;     rept(i,1,n)     {     int mx=pts[i].x;     vector<lint>::iterator up=upper_bound(ysorted.begin(),ysorted.begin()+i,mx);     int upindex=int(up-ysorted.begin());     if(pts[upindex].y>pts[i].x)     upindex--;     lint prevbest=0;     if(upindex!=-1)     {     prevbest=dp[upindex];     // printf("%d curr x = %lld prev y = %lld dp[prev] = %lld \n",i,pts[i].x,pts[upindex].y,dp[upindex]);     }     dp[i]=max(dp[i-1],prevbest+pts[i].y-pts[i].x);     }     printf("%lld\n",dp[n-1]);     }     return 0;     }   
#include<vector> #include<iostream> #include<stdio.h> using namespace std; int t; int n,e; int P[10005],R[10005]; int map[10005]; void MAKE_SET(int x){     P[x]=x;     R[x]=0; } void LINK(int x,int y){     P[y]=x; } int FIND_SET(int x){     if(x!=P[x]) P[x]=FIND_SET(P[x]);     return P[x]; } void UNION(int x,int y){     LINK(FIND_SET(x),FIND_SET(y)); } int main(){     int a,b;     scanf("%d",&t);     while(t--){         scanf("%d%d",&n,&e);         for(int i=1;i<=n;i+=1) MAKE_SET(i),map[i]=0;         for(int i=0;i<e;i++){             scanf("%d%d",&a,&b);             a++;b++;             if(FIND_SET(a)!=FIND_SET(b)) UNION(a,b);         }         for(int i=1;i<=n;i+=1){             map[FIND_SET(i)]++;         }         int c=0;int d=0;         for(int i=1;i<=n;i+=1)             if(map[i]==0) continue;             else if(map[i]==1){                 d++;             }             else             {             c+=(map[i]*(map[i]-1)/2);             }         c+=(d*(d-1)/2);         printf("%d\n",c);     }     return 0; }
 #include <iostream> #include <fstream> #include <string> #include <math.h> #include <set> #include <vector> #include <map> #include <queue> #include <stdio.h> #include <stack> #include <algorithm> #define y1 aasdfasdfasdf #define yn askfhwqriuperikldjk #define INF 1000000000 #define eps 1e-7 #define M_PI 3.141592653589793 //#define mx 1000000000000ll //#define bs 1000000000000007ll //#define szz 400 //#define pb push_back using namespace std; long tests; long long s[310000],ss[310000],c[310000],d[310000],h[310000];int n; int main(){ //freopen("C:/aver.txt","r",stdin); //freopen("C:/output.txt","w",stdout); scanf("%d",&tests); long long bs=1000000000000007ll; for (int i=2;i<=10000;i++) for (int j=i*i;j<=210000;j+=i) {s[j]=1; } s[4]=0;  for (int i=2;i<=210000;i++) {if (s[i]==0)ss[i]=ss[i-1]; else ss[i]=ss[i-1]+1;}  for (int i=0;i<=210000;i++)s[i]=0;  c[0]=1; h[0]=s[0]=d[0]=0; for (int i=1;i<=212000;i++) {c[i]=d[i-1];  d[i]=h[i-1];  s[i]=s[i-1]+h[i-1]+d[i-1];  h[i]=c[i-1]+s[i-1]+d[i-1];  while (s[i]>=bs)s[i]-=bs;  while (d[i]>=bs)d[i]-=bs;  while (h[i]>=bs)h[i]-=bs;  while (c[i]>=bs)c[i]-=bs; } int m; for (;tests;--tests) {     scanf("%d%d",&n,&m); //    scanf("%d",&m);    // printf("%d ",ss[n]);//cout<<ss[n-1]<<" ";       printf("%Ld %Ld %Ld %Ld %Ld\n",ss[n],c[m],h[m],s[m],d[m]); //    printf("%I64d ",h[m]); //    printf("%I64d ",s[m]);  //   printf("%I64d\n",d[m]);     //cout<<c[m]<<" "<<h[m]<<" "<<s[m]<<" "<<d[m]<<endl; } //cin.get();cin.get(); return 0;}   
#include <iostream> #include <cstdio> #include <vector> #include <map> #include <cmath> #include <algorithm>     using namespace std; #define ll long long int    /******** testing ********** map<int,int> mp; vector<int> vi; int pre[7]; int tot; void dfs( int sum , int i , int n ) { 	if( i >= n ) { 		int tsum = 0;for( int i = 0;i  < n; i++ ) tsum += pre[i]; 		if( !mp[tsum] ) { vi.push_back(tsum);mp[sum] = 1;for(int i = 0; i < 5; i++ ) cout << pre[i] << " ";cout << "\n"; }  		return; 	} 	pre[i] = sum-1; 	dfs( sum-1 , i+1 , n ); 	pre[i] = sum+1; 	dfs( sum+1 , i+1 , n ); } int main() { 	mp.clear() , vi.clear();pre[0] = 0; 	int n , x; cin >> n >> x; 	dfs( 0  , 1 , n ); 	int sz = vi.size();; 	sort( vi.begin() , vi.end() ); 	for( int i = 0; i < sz; i++ ) cout << vi[i] << "*x\n";	 	return 0; } ********** done *************/     /*** Main code********/ int  main() {   	int Q;scanf("%d" , &Q); 	while( Q-- ) { 		int t , s , n;		 		scanf("%d %d %d" ,&t , &s , &n ); 		printf("%d %d %d " , t , s , n ); 		if( !t ) {	 			if( s == 0 ) { 				ll range = ( (ll)(n)*(ll)(n-1) )/2ll; 				if( range%2 ) cout << 0 << "\n"; 				else cout << 100000000 << "\n"; 				continue; 			} 			if( s < 0 ) s *= -1;   			int ST = sqrt(s) , cnt = 0 ; 			ll range = ( (ll)(n)*(ll)(n-1) )/2ll; 			   			if( range%2 == 0 ) { 	 				for( int i = 1; i <= ST; i++ ) {		 					if( s%i == 0  ) { 						int val = s/i;if( val%2 == 0 && (val>=0 && val <= range ) ) cnt++;  						    val = i;  if( val%2 == 0 && (val>=0 && val <= range ) ) cnt++;  					} 				} 				if( ST*ST == s ) if( ST%2 == 0 && (ST>=0) && (ST<=range) ) cnt--; 			} 			else { 				for( int i = 1; i <= ST; i++ ) {  					if( s%i == 0  ) { 						int val = s/i;if( (val%2) && ( val>0 && val <= range) ) cnt++; 						    val = i;  if( (val%2) && ( val>0 && val <= range) ) cnt++; 					}                         	}                         	if( ST*ST == s ) if( (ST%2) && (ST>0) && (ST<=range) ) cnt--; 			} 			printf("%d\n" , cnt ); 		} 		else if( t == 1 ){		 			int smx = 100000001; 			int ts = s; 			if( s == 0 ) {                                 smx = min( smx , 1 );                          } 			else { 				int ts = s;                    		if( s < 0 ) s *= -1;                          	 	int ST = sqrt(s); 				ll range =( (ll)(n)*(ll)(n-1) )/2ll;   		 		       		if( range%2 == 0  ) {                                 	for( int i = 1; i <= ST; i++ ) {                                        	 	if( s%i == 0  ) {                                                 	int val = s/i;if( val%2 == 0 && (val>=0 && val <= range) ) smx = min(smx , i);                                                     	val = i;if( val%2 == 0 && (val>=0 && val <= range) ) smx = min(smx , s/i);                                         	}                                 	}                         	}                         	else {                                 	for( int i = 1; i <= ST; i++ ) {                                         	if( s%i == 0  ) {                                                 	int val = s/i;if( (val%2) && ( val>0 && val <= range) ) smx = min(smx , i);                                                     	val = i;  if( (val%2) && ( val>0 && val <= range) ) smx = min(smx , s/i); 						}                                 	}                         	} 			}		 				 			ll S = (ll)ts/(ll)smx; 			S += ((ll)(n)*(ll)(n-1))/2ll; 			S /= 2ll;	 			printf("0");ll last = 0; 			for( int i = n-1; i>= 1; i-- ) {			 				if( i <= S ) S -= i , last += smx; else last -= smx;  				printf(" %lld" , last ); 			} 			printf("\n"); 		} 	} 	return 0; } /******* done ***********/  
/* programmed by dipjal */ #include<bits/stdc++.h> #include<iostream> using namespace std; #define ll long long int #include<cmath> #define SIZE 1000001 #define gc() getchar_unlocked() #define pc(x) putchar_unlocked(x) /*static inline int fastio() {     int x=0;     char c=gc();     while(c<'0'||c>'9')     {         c=gc();     }     while(c>='0'&&c<='9')     {         x=(x<<1)+(x<<3)+c-'0';         c=gc();     }     return x; }  static inline void fastWrite(int x) {    char s[25];   int i=0;   do   {       s[i++]=x%10+'0';       x/=10;   }while(x);   --i;   while(i>=0)   {       pc(s[i--]);   }   pc('\n');  } */    int arr[SIZE]; int main() {     ios_base::sync_with_stdio(false);     cin.tie(0);     //int T;    int T;    ll N;    ll K;    cin>>T;    while(T--)    {        cin>>N>>K;        ll tot=(K*(K+1))/2;        if(N>tot)        {            cout<<"-1"<<endl;            continue;        }        if(N==tot)        {            cout<<"0"<<endl;            continue;        }        if(N<=K)        {            cout<<K-1<<endl;            continue;        }        ll curr=((K*(K+1))-2*N)*4+1;        //curr=8*curr+1;        double res=(double)(sqrt(curr));        res=(res-1)/2;        res=(floor)(res);        cout<<res<<endl;    }     return 0; } 
#include<bits/stdc++.h> #define N 11000 #define pb push_back #define ll long long int #define mod 100000 #define MOD 1000000007 using namespace std; int a[N],ind[N]; int c[N]; ll s[4*N]; int tt=1; int visited[N]; vector<int> v[N]; int dfs(int node){ 	a[tt++]=node; 	visited[node]=1; 	int f=0; 	for(int i=0; i<v[node].size(); i++){ 		if(!visited[v[node][i]]){ 			dfs(v[node][i]); 			f=1; 		} 	} 	visited[node]=0; 	if(!f) return c[node]=1; 	c[node]++; 	for(int i=0; i<v[node].size(); i++){ 		c[node]+=c[v[node][i]]; 	} 	return c[node]; } void fib(ll n, ll&x, ll&y){     if(n==1){         x = y = 1;         return ;     }     if(n&1){         fib(n-1, y, x);         y=(y+x)%mod;     } 	else{         ll a, b;         fib(n>>1, a, b);         y = (a*a+b*b)%mod;         x = (a*b + a*(b-a+mod))%mod;     } } void make(int l, int r, int node){ 	if(l==r){ 		s[node]=1; 		return;	 	}  	int mid=l+r; mid/=2; 	make(l,mid,2*node); make(mid+1,r,1+ 2*node); 	s[node]=(s[2*node]%MOD+s[1+ 2*node]%MOD)%MOD; } int sum(int l,int r,int start,int end,int node){     if(start>r||end<l) return 0;     if(start>=l&&end<=r) return s[node]%MOD;     int mid=start + end;     mid>>=1;     return (sum(l,r,start,mid,2*node)%MOD+sum(l,r,mid+1,end,2*node+1)%MOD)%MOD; } void update(int l, int r, int node, ll val, int i){     if(l>i||i>r) return;     s[node]+=val;     s[node]%=MOD;     if(l!=r){         int mid=l+r;         mid>>=1;         update(l,mid,2*node,val,i);         update(mid+1,r,2*node+1,val,i);     } } int main(){ 	//freopen("in.txt","r",stdin); 	memset(visited,0,sizeof visited); 	int n,q; cin>>n>>q; 	for(int i=1; i<n; i++){ 		int x,y; cin>>x>>y; 		v[x].pb(y); v[y].pb(x); 	}	 	dfs(1); 	for(int i=1; i<=n; i++) c[i]--; 	for(int i=1; i<=n; i++){ 		ind[a[i]]=i; 	} 	make(1,n,1); 	while(q--){ 		int type; cin>>type; 		if(!type){ 			ll m; int v; cin>>v>>m; 			if(m&1) continue; 			ll x=m; 			m/=2; 			if(!m) m=1; 			ll val=0, lol=0; 			fib(m,lol,val); 			int pt=ind[v]; 			val*=x; 			val%=MOD; 			update(1,n,1,val,pt); 		} 		else{ 			int pt; cin>>pt; 			int x=ind[pt]; 			//cout<<x<<" "<<x+c[pt]<<endl; 			cout<<sum(x,x+c[pt],1,n,1)%MOD<<endl; 		} 		 	} }
/* programmed by dipjal */ #include<bits/stdc++.h> #include<iostream> using namespace std; #define ll long long int #include<cmath> #define SIZE 1000001 #define gc() getchar_unlocked() #define pc(x) putchar_unlocked(x) /*static inline int fastio() {     int x=0;     char c=gc();     while(c<'0'||c>'9')     {         c=gc();     }     while(c>='0'&&c<='9')     {         x=(x<<1)+(x<<3)+c-'0';         c=gc();     }     return x; }  static inline void fastWrite(int x) {    char s[25];   int i=0;   do   {       s[i++]=x%10+'0';       x/=10;   }while(x);   --i;   while(i>=0)   {       pc(s[i--]);   }   pc('\n');  } */    int arr[SIZE]; int main() {     ios_base::sync_with_stdio(false);     cin.tie(0);     //int T;    int T;    int N;    int X;    cin>>T;    while(T--)    {     cin>>N;     vector<int> v;     for(int i=0;i<N;i++)     {         cin>>X;         v.push_back(X>0?-1:1);     }     for(int i=0;i<v.size();++i)         cout<<v[i]<<" ";     cout<<endl;    }    return 0; } 
/* programmed by dipjal */ #include<bits/stdc++.h> #include<iostream> using namespace std; #define ll long long int #define SIZE 1000001 #define gc() getchar_unlocked() #define pc(x) putchar_unlocked(x) /*static inline int fastio() {     int x=0;     char c=gc();     while(c<'0'||c>'9')     {         c=gc();     }     while(c>='0'&&c<='9')     {         x=(x<<1)+(x<<3)+c-'0';         c=gc();     }     return x; }   static inline void fastWrite(int x) {     char s[25];   int i=0;   do   {       s[i++]=x%10+'0';       x/=10;   }while(x);   --i;   while(i>=0)   {       pc(s[i--]);   }   pc('\n');   } */         int main() {     ios_base::sync_with_stdio(false);     cin.tie(0);     //int T;     string s;     cin>>s;     int d=s[s.size()-1]-'0';     if(d&1)         cout<<"NO"<<endl;     else         cout<<"YES"<<endl;     return 0; }
/*      SHUBHAM RAI-IIIT Hyderabad   */ #include<bits/stdc++.h> using namespace std; #define FOR(i,a,b) for(i=a;i<b;i++) #define REP(i,a) for(i=0;i<a;i++) #define LLD long long int #define MOD 1000000007 #define si(n) scanf("%d",&n); #define si2(n,m) scanf("%d%d",&n,&m); #define sl(n) scanf("%lld",&n); #define TR(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++) #define F first #define S second #define pb push_back #define mp make_pair typedef pair<int,int> PII; #define TRACE  #ifdef TRACE #define trace1(x)                cerr << #x << ": " << x << endl; #define trace2(x, y)             cerr << #x << ": " << x << " | " << #y << ": " << y << endl; #define trace3(x, y, z)          cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl; #define trace4(a, b, c, d)       cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << endl; #define trace5(a, b, c, d, e)    cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << endl; #define trace6(a, b, c, d, e, f) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << " | " << #f << ": " << f << endl;  #else  #define trace1(x) #define trace2(x, y) #define trace3(x, y, z) #define trace4(a, b, c, d) #define trace5(a, b, c, d, e) #define trace6(a, b, c, d, e, f)  #endif  vector<pair<PII,PII> >queries; LLD ans=0; int BIT[100002],k; void update(int index,int val) { 	while(index<100001) 	{ 		BIT[index]+=val; 		index+=index&-index; 	} } int read(int index) { 	int sum=0; 	while(index>0) 	{ 		sum+=BIT[index]; 		index-=index&-index; 	} 	return sum; } void add(int x) { 	int r1=read(min(100000,x+k)); 	int r2=read(max(0,x-k-1)); 	ans+=r1-r2; 	update(x,1); } void remove(int x) { 	update(x,-1); 	int r1=read(min(100000,x+k)); 	int r2=read(max(0,x-k-1)); 	ans-=r1-r2; } LLD fans[100002],a[100002]; int main() { 	int n,q,i,j,sz; 	cin>>n>>q>>k; 	REP(i,n) 		sl(a[i]); 	sz=sqrt(q); 	REP(i,q) 	{ 		int l,r; 		si2(l,r); 		l--,r--; 		queries.pb(mp(mp(l/sz,r),mp(l,i))); 	} 	sort(queries.begin(),queries.end()); 	int cl=0,cr=1; 	REP(i,q) 	{ 		int l=queries[i].S.F,r=queries[i].F.S; 		while(cl>=l) 		{ 			add(a[cl--]); 		} 		while(cr<=r) 		{ 			add(a[cr++]); 		} 		while(cl<l-1) 		{ 			remove(a[++cl]); 		} 		while(cr>r+1) 		{ 			remove(a[--cr]); 		} 		fans[queries[i].S.S]=ans; 	} 	REP(i,q) 		printf("%lld\n",fans[i]); 	return 0; } 
#include<bits/stdc++.h> using namespace std;   const int N=555; int cnt[N];   int main() {     int test;     scanf("%d", &test);     while(test--) {         int n, m;         scanf("%d %d", &m, &n);         for(int i=0;i<n;i++) {             int num;             scanf("%d", &num);             cnt[num]++;         }         sort(cnt, cnt+m, greater<int>());         int req=(n+2)/2, sum=0, ans=0;         for(int i=0;i<m;i++) {             sum+=cnt[i];             ans++;             if(sum>=req) break;         }         printf("%d\n", ans);         memset(cnt, 0, sizeof(cnt));     } }
#include <iostream> #include <fstream> #include <cstdio> #include <climits> #include <vector> #include <map> #include <list> #include <deque> #include <stack> #include <set> #include <string> #include <cstring> #include <algorithm> #include <bitset> #include <cmath>  using namespace std;  #define ll long long #define vt vector  void func(map<ll,vector<ll> >& primes,ll x,ll ind) { 	for(ll i=2;i*i<=x;i++) 	{ 		if(x%i==0) 		{ 			primes[i].push_back(ind); 			while(x%i==0) 				x/=i; 		} 	} 	if(x>1) 		primes[x].push_back(ind); }  int main() { 	ll t,n,tmp,q; 	scanf("%lld",&t); 	while(t--) 	{ 		scanf("%lld",&n); 		map<ll,vector<ll> > primes; 		vector<ll> vals(n); 		for(ll i=0;i<n;i++) 		{ 			scanf("%lld",&tmp); 			func(primes,tmp,i); 		} 		scanf("%lld",&q); 		ll x; 		while(q--) 		{ 			scanf("%lld",&x); 			ll prev=-1,ans=0,maxans=0; 			for(ll i=0;i<primes[x].size();i++) 			{ 				if(prev==-1) 				{ 					prev = primes[x][i]; 					ans=1; 				} 				else 				{ 					if(prev+1==primes[x][i]) 					{ 						prev = primes[x][i]; 						ans++; 					} 					else 					{ 						prev=-1; 						ans=0; 					} 				} 				if(maxans<ans) 					maxans=ans; 			} 			printf("%lld\n",maxans); 		} 	} 	system("pause"); 	return 0; }
#include <cstring> #include <iostream> #include <stdio.h> #include <cstdlib> #include <cctype> #include <algorithm> #include <map> #include <vector> #include <list> #include <set> #include <queue> #include <deque> #include <stack> #include <bits/stdc++.h> #include <string> #include <cmath> using namespace std;  #define pb push_back #define mp make_pair #define mod 1000000007 #define ll long long #define ff first #define ss second #define inf  1e9 #define infll 1e18 #define pr(x) printf("%d\n",x) #define prs(x) printf("%d ",x) #define sc(x) scanf("%d",&x) #define trc(x) cout << #x << " = " << x << endl #define fr(i,a,n) for(i=a;i<n;i++) #define fd(i,a,n) for(i=n;i>a;i--) #define fiv(v) for(i=0;i<v.size();i++) #define fill(a,v) memset(a,v,sizeof(a)) #define all(a) a.begin(),a.end() #define iter(c,it) for(typeof((c).begin()) it= (c).begin(); it != (c).end(); it++)  typedef pair<int,int> pi; typedef vector<int> vi;  char s[101]; int dp[102][2][102],n; int sol(char s[],int i,int last,int con,int p,int q) {     if(i==n)return 0;     int &res=dp[i][last][con];     if(res!=-1)return res;     res=0;     if(last==0)     {         if(con<p)         res=max(res,(s[i]=='W')+sol(s,i+1,0,con+1,p,q));         res=max(res,(s[i]!='W')+sol(s,i+1,1,1,p,q));     }     else     {         if(con<q)         res=max(res,(s[i]!='W')+sol(s,i+1,1,con+1,p,q));         res=max(res,(s[i]=='W')+sol(s,i+1,0,1,p,q));     }     return res; } int main() {     int i,j,k,l,m,t,c=0,ans;     #ifndef ONLINE_JUDGE    // freopen("in.txt","r",stdin);     #endif     sc(t);      while(t--)     {       int p,q;       sc(p);sc(q);       scanf("%s",s);       fill(dp,-1);       n=strlen(s);       j=sol(s,0,0,0,p,q);       pr(j);     }     return 0; } 
#include<iostream> #include<cstdio> #include<algorithm> #include<cmath> #include<vector> #include<climits> #include<cstring>  using namespace std;  #define ll double  struct point {        ll x;        ll y; }p[100003],upper[100003],lower[100003],hull[100003];    void print(point a) {      cout<<"("<<a.x<<","<<a.y<<")"; }  bool isLeft(point a,point b,point c) {      return ((a.x-b.x)*(b.y-c.y) - (b.x-c.x)*(a.y-b.y))>0; }  bool comp(point a,point b) {      if(a.x != b.x)      return a.x < b.x;            return a.y < b.y; }  ll dist(point a,point b) {    return (a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y); } void convexHull(int n) {      int i,j,k;      j = 0;      k = 0;            for(i=0;i<n;i++)      {         while(k>=2 && !isLeft(hull[k-2],hull[k-1],p[i]))         k--;                  hull[k++] = p[i];      }            for(i=n-2,j=k+1;i>=0;i--)      {         while(k>=j && !isLeft(hull[k-2],hull[k-1],p[i]))         k--;                  hull[k++] = p[i];      }            double ans = 0.0;            for(i=1;i<k;i++)      {         ans += sqrt(dist(hull[i],hull[i-1]));      }            printf("%0.2lf\n",ans); }    int main() {     int t;     int n,i;          scanf("%d",&t);          while(t--)     {               scanf("%d",&n);                    memset(hull,0,sizeof(0));               for(i=0;i<n;i++)               {                    scanf("%lf%lf",&p[i].x,&p[i].y);               }                    sort(p,p+n,comp);               convexHull(n);               //system("pause");     }         return 0; } 
#include<iostream> #include<cmath>  using namespace std;  int main() {     int t;     long n,count,root,i,flag,imd;     cin>>t;     while(t--)    {        cin>>n;        count=0;        root=sqrt(n);        for(i=1;i<=root;i++)       {          if(n%i==0)         {            flag=0;            imd=i;            while(imd!=0)           {               if(imd%10==3 || imd%10==5 || imd%10==6)              flag=1;               imd=imd/10;            }            if(flag==1) count++;            flag=0;            imd=n/i;            while(imd!=0)           {               if(imd%10==3 || imd%10==5 || imd%10==6)              flag=1;               imd=imd/10;            }            if(flag==1) count++;          }// end of if statement        }// end of for loop       cout<<count<<endl;     }     return 0;  }           
#include <stdio.h> #include <math.h> #include <cstdio> #include <vector> #include<memory.h> #include <iostream> #include <stdlib.h> #include <algorithm> #include <string.h> #include <vector> #include <climits> using namespace std; int main() { 	 int t; 	 scanf("%d\n",&t); 	  	 while(t--) 	{ 		int n; 		cin >> n; 		int a[n]; 		 for(int i=0;i<n;i++) 		   cin >> a[i]; 	  	  int sum1=0; 	  int sum=0; 	  int c=0; 	 int max=INT_MIN; 	  for(int i=0;i<n;i++) 	   { 	   	bool fi=true; 	   	sum1=sum1+a[i]; 	    	   	if(a[i]>=0) 	   	{ 	   	  sum=sum+a[i]; 	    	   	 if(sum>=sum1) 	   	   sum1=sum; 	   } 	   else 	   { 	     sum=0; 	     	     if(a[i]>=sum1) 	      { 	   	   sum1=a[i]; 	   	   	     fi=false; 	   }  	   } 	    	 if(max<sum1) 	  { 	  	max=sum1; 	  	 	  } 	   }	    	 printf("%d\n",max);	 	} }	   
#include <iostream> #include <cstdio> #include <cstring> #include <algorithm>  using namespace std;  long long skill[52],num[52]; int n,g; long long dp[52][102][102];  long long f(int idx, int add, int exp) {     if ( idx == n-1 ) return (num[idx]+add)*skill[idx];     long long &ans = dp[idx][add][exp];     if ( ans != -1 ) return ans;     ans = 0;     int upgrades = min((long long)g-exp, num[idx]+add);     for ( int i = 0; i <= upgrades; i++ ) {         ans = max(ans, skill[idx]*(num[idx]+add-i) + f(idx+1,i,exp+i));     }     return ans;      }  int main() {     int t,i;     cin >> t;     while ( t-- ) {           cin >> n;           for ( i = 0; i < n; i++ ) cin >> num[i];           for ( i = 0; i < n; i++ ) cin >> skill[i];           cin >> g;           memset(dp, -1, sizeof(dp));           long long ans = f(0,0,0);           cout << ans << endl;     }     return 0; } 
#include<iostream> #define LL long long int #define M 1000000007  using namespace std; int main() {     int t;     LL n,*v,large_ind,large=-1,rest_incre,m,k,*incre,tot_incre;     cin>>t;     while(t--)     {         tot_incre=rest_incre=0;         large=-1;         cin>>n>>m>>k;         v=new LL [n];         incre=new LL[n];         for(LL i=0;i<n;i++)         {             cin>>v[i];             incre[i]=((m-v[i])/k)+1;             if(large<incre[i])                 {                     large_ind=i;                     large=incre[i];                 }          //   cout<<large<<" "<<incre[i]<<endl;              tot_incre+=incre[i];         }         rest_incre=tot_incre-large;     //cout<<tot_incre<<"  "<<rest_incre<<"  "<<large<<endl;         LL temp=((large-(rest_incre%2))/2)%M;         cout<<temp+1<<"\n";     } } 
#include<iostream> using namespace std; int main() {     long long int sum,k,t,x=1,n,i;     cin>>t;     while(x<=t)     {                cin>>n;                if(n==1)                {                        cout<<0<<endl;                }                else                {                if(n%2==0)                {                          sum=1;                          k=-1;                }                else                {                    sum=-1;                    k=1;                }                for(i=n;i>=3;i--)                {                                 sum=sum +(k*(i));                                 k*=-i;                }                cout<<sum<<endl;                }                x++;     }     return(0); } 
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <climits> #include <cctype> #include <cassert>  using namespace std;  #define ulli        unsigned long long int #define lli         long long int #define clr(x)      memset(x,0) #define set(x)      memset(x,1) #define memset(x,i) memset(x,i,sizeof(x)) #define Sd(x)       scanf("%d",&x); #define Sf(x)       scanf("%f",&x); #define Sc(x)       scanf("%c",&x); #define Ss(x)       scanf("%s",x); #define Sulli(x)    scanf("%llu",&x) #define F(i,a,n)    for(int i=a;i<n;i++) #define FD(i,a,n)   for(int i=a;i>=n;i--) #define Nl          printf("\n");  //-----RELEVANT CODE-----  int a[100002]; void sieve() {     int j;     F(i,1,100001)         a[i]=1;     F(i,2,100001)     {         if(a[i]==1)         {             for(j=2;(j*i)<100001;j++)                 a[i*j]*=i;             a[i]*=i;         }     } } int main() {     //freopen("inp.txt","r",stdin);     sieve();     int t,n,k,c,i;     Sd(t);     pair<int,int>e;     vector< pair<int,int> > v;     F(i,1,100001)         v.push_back(make_pair(a[i],i));     sort(v.begin(),v.end());     int s=v.size();     while(t--)     {         c=0;         scanf("%d %d",&n,&k);         for(i=0;i<s;i++)         {             if(v[i].second<=n)                 c++;             if(c==k)                 break;         }         printf("%d\n",v[i].second);     }     return 0; } 
#include<iostream> #include<algorithm> #include<cmath> using namespace std;  bool isPrime(long long n){ 	long long i=2; 	if(n==1){ 		return false; 	}else if(n==2){ 		return true; 	}else{ 		while(i <= (long long)(sqrt(n)+1)){ 			if( n%i == 0){ 				return false; 			} 			i++; 		} 	} 	return true; }  int main(){ 	long long t,n,m,i; 	cin>>t; 	while(t--){ 		cin>>n; 		cin>>m; 		for(i=n;i<=m;i++){ 			if(isPrime(i)){ 				cout<<i<<endl; 			} 		} 		cout<<endl; 	} 	return 0; }
#include<iostream> using namespace std; long long int non_fib(long long int n) {    int fib[100001];    fib[0] = 0;    fib[1] = 1;    fib[2] = 1;    int i = 3;    long long int  cnt = 0,l;    while(1){     fib[i] = fib[i-1]+fib[i-2];     long long int d;     d = fib[i]-fib[i-1]-1;      l = cnt;     cnt+=d;     long long int ans;     if(cnt>=n){     ans = fib[i-1]+(n-l);     return ans;    }    i++;    } } int main() {     long long int t,n;     cin>>t;     while(t--){         cin>>n;         long long int k= non_fib(n);         cout<<k<<endl;     }     return 0; } 
#include<bits/stdc++.h> #define pb push_back #define mp make_pair #define se second #define fi first   using namespace std; typedef long long ll; typedef pair < int, int > pii; typedef pair < int , pii > tuple; typedef vector < int > vi; const int MAX = 1e4+5; const int INF = 1e9+9;  int main(){ 	 	int t; 	cin >> t; 	int a; 	ll ans; 	 	while( t-- ){ 		cin >> a; 		ans = a*a*4 - 3*a; 		cout << ans << endl; 	}	 	 	 	 	return 0; } 
#include <stdio.h>  int main() {     int T,N,z,A,B,res;     for (scanf("%u",&T);T>0;T--) {         int bits[]={0,0};         scanf("%u %u %u",&N,&A,&B);         for (res=(1<<N)-1;N>0;N--) {             bits[0]+=A%2;A>>=1;             bits[1]+=1-B%2;B>>=1;         }         z=bits[0]>bits[1]?bits[0]-bits[1]:bits[1]-bits[0];         for (;z>0;z--)             res=res-(1<<(z-1));         printf("%u\n",res);     } } 
#include<iostream> #include<stack> #include<string> using namespace std; int main() {     int t,i;     string s;     cin>>t;     while(t--)     {               cin>>s;               string exp;               stack<char>st;               for(i=0;i<s.size();i++)               {                                      if(s[i]=='(')                                      {                                                   st.push(s[i]);                                      }                                      else if(s[i]==')')                                      {                                                   while(st.top()!='(')                                                   {                                                                       exp+=st.top();                                                                       st.pop();                                                   }                                                   st.pop();                                      }                                      else if (s[i]>=97 && s[i]<=122)                                      {                                                   exp+=s[i];                                      }                                      else if(s[i]=='+' || s[i]=='-' || s[i]=='*' || s[i]=='/' || s[i]=='^')                                      {                                                   st.push(s[i]);                                      }               }               cout<<exp;               cout<<"\n";     } } 
// Sieve of Eratosthenes ..... #include<iostream> #include<vector> #include<cmath> using namespace std; int main() {          long long int n1,i,k;int temp=0;     long long int n,sum=0;     cin>>n;     if(n<2)cout<<temp;     vector<bool>a(n+1,1);          // initial assumption : all are prime ...     a[0]=0;     a[1]=0;     n1=(int)sqrt(n);     for(i=2;i<=n1;i++)     {                       for(k=i;k<=n/i;k++)                       {                                          a[i*k]=0;                       }     }     for(i=2;i<n+1;i++)     if(a[i]==1)sum+=i;     cout<<sum;   }        
#include<bits/stdc++.h> #include<iostream> #include<algorithm> using namespace std; #define pc(x) putchar_unlocked(x) #define gc() getchar_unlocked() typedef long long int ll;    //const ll mod = 1e9+7; const ll SIZE = 1e5+1; const ll MAXSIZE = 1e7+1; ll X;  #include <stdio.h> #include<stdbool.h> #define gc getchar_unlocked #define pc putchar_unlocked #define lli long long int int arr[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};   inline lli modmul(lli a,lli b,lli mod)//O(1) for (a*b)%mod { 	a%=mod;b%=mod;//long long int 8bytes 	long double res=a;//long double 16bytes 	res*=b; 	lli c=(lli)(res/mod); 	a*=b;//overflow wrap round. 	a-=c*mod; 	a%=mod; 	if(a<0)a+=mod; 	return a; } inline lli fastexpo(lli a,lli b,lli mod) {	lli result=1; 	while(b) 	{ 		if(b&1)result=modmul(result,a,mod); 		a=modmul(a,a,mod); 		b>>=1; 	} 	return result; } inline bool MillerRabinTest(lli p,int iteration) {	int i,d=0,j; 	if(p<2)return false; 	if(p!=2 && !(p&1))return false;//if p is even 	for(i=0;i<25;i++) 		if(p==arr[i])return true; 		else if(p%arr[i]==0)return false; 	lli s=p-1; //factor p-1 into 2^d*s where s is odd 	while(!(s&1)) 		s/=2,d++; 	for(i=0;i<iteration;i++) 	{	//Fermat's Little theorem a^p-1=1(mod p) 		lli a=rand()%(p-1)+1,temp=s;//check if a is witness or a strong liar 		lli mod=fastexpo(a,temp,p); 		if(mod==1 || mod==p-1) continue; 		int flag=0; 		//keep taking square roots of a^nÃ¢ï¿½ï¿½1, we will get either 1 or Ã¢ï¿½ï¿½1. If we get Ã¢ï¿½ï¿½1 then the second equality holds and it is done 		for(j=1;j<d;j++) 		{ 			mod=modmul(mod,mod,p); 			if(mod==1)return false; 			if(mod==p-1) 			{	flag=1; 				break; 			} 		} 		if(flag)continue; 		return false; 	} 	return true; }     bool prime(ll X) {     if(X==2||X==3||X==5||X==7||X==11)     return 1;     if(X==1||!(X%2)||!(X%3)||!(X%5)||!(X%7)||!(X%11))         return 0;     if(!(!((X-1)%6)||!((X+1)%6)))         return 0;     for(int i=13;i<=(int)(sqrt(X));i+=2)     {          if(!(X%i))             return 0;     }     return 1; } int main() {     ios_base::sync_with_stdio(false);     cin.tie(0);     int tt;     scanf("%d",&tt);     while(tt--)     {         scanf("%lld",&X);         if(MillerRabinTest(X,3))             printf("PRIME\n");         else             printf("COMPOSITE\n");     }     return 0; } 
#include <iostream> using namespace std; long long mux(long long a,long long b) { 	long long ans=1; 	while(b) 	{ 		if(b%2) 		ans=(ans*a)%1000000007; 		a=(a*a)%1000000007; 		b/=2; 	} 	return ans%1000000007; } int main() { 	// your code goes here 	int a[10]={4,25,168,1229,9592,78498,664579,5761455,50847534,455052511}; 	int t; 	cin>>t; 	while(t--) 	{long long n,k,p,ans; 	cin>>n>>k; 	p=(n-k)/2; 	if((n-k)%2) 		ans=(((9*mux(10,p))%1000000007)*a[k-1])%1000000007; 	else 		ans=(((9*mux(10,p-1))%1000000007)*a[k-1])%1000000007; 	cout<<ans%1000000007<<endl;} 	return 0; }
#include <iostream> #include <string> #include <cstring> #include <cmath> #include <vector> #include <cstdio> #include <limits> #include <limits.h> using namespace std;   /** get number by coordinate */ inline long long getNumber(long long x, long long y) { if (x == 0 && y == 0) return 0; long long xL = (x > 0 ? (x << 1) : (-x) * 2 + 1); long long yL = (y > 0 ? (y << 1) : (-y) * 2 + 1);   long long L = max(xL, yL); long long low = -(L - 1) / 2; long long high = L / 2;   long long ans = (L - 1) * (L - 1) - 1; if ((L & 1) == 0) { if (x == high) return ans + (y - low + 1); else return ans + (high - x + L); } else { if (x == low) return ans + (high - y + 1); else return ans + (x - low + L); } }   class PrimeJudger { public: const static int bits = 19, mask = (1<<bits) - 1; static unsigned long long mul(unsigned long long x, unsigned long long y, unsigned long long M) { if (x <= UINT_MAX && y <= UINT_MAX) return x * y % M; unsigned long long rslt = y * (x & mask) % M; while (x >>= bits) rslt = (rslt + (y = (y << bits) % M) * (x & mask)) % M; return rslt; }   static int mtest(unsigned long long n, unsigned long long a) { unsigned long long s, t, nmin1 = n - 1; int r; for (s = nmin1, r = 0; !(s & 1); s >>= 1, r++) ; for(t = a; s >>= 1; ) { a = mul(a, a, n); if (s & 1) t = mul(t, a, n); } if (t == 1 || t == nmin1) return 1; while (--r) if ((t = mul(t, t, n)) == nmin1) return 1; return 0; }   static bool isPrime(unsigned long long n) { if(n<29) return n==2 || n==3 || n==5 || n==7 || n==11 || n==13 || n==17 || n==19 || n==23; if(!(n&1 && n%3 && n%5 && n%7 && n%11 && n%13 && n%17 && n%19 && n%23)) return 0; return mtest(n, 2) && mtest(n, 1215) && (n==17431 || mtest(n, 34862) && (n==3281359 || mtest(n, 574237825))); } };   void deal() { int x, y; scanf("%d%d", &x, &y);   long long nowNum = getNumber(x, y); if (PrimeJudger::isPrime(nowNum)) { printf("0\n"); return; }   long long k = 0; long long nx, ny; while (true) { k++; for (long long i = -k; i <= k; ++i) { long long absi = i; if (absi < 0) absi = -absi; nx = x + i; ny = y + (k - absi); if (PrimeJudger::isPrime(getNumber(nx, ny))) { printf("%lld\n", k); return; }   nx = x + i; ny = y - (k - absi); if (PrimeJudger::isPrime(getNumber(nx, ny))) { printf("%lld\n", k); return; } } } }   int main() { int T; scanf("%d", &T); while (T--) deal();   return 0; }
#include<bits/stdc++.h> using namespace std; int main() { 	long int t,n,i,count,sum,j; 	cin>>t; 	while(t--) 	{ 		sum=0; 		cin>>n; 		count=(n*(n-1))/2; 		n+=count; 		int visit[n+5]; 		for(i=0;i<=n;i++) 		{ 			visit[i]=0; 		} 		visit[1]=1; 		for(i=2;i*2<=n;i++) 		{ 			visit[i*2]=1; 		} 		 		for(i=3;i<=sqrt(n)+1;i+=2) 		{ 				for(j=i*i;j<=n;j+=i*2) 				{ 					visit[j]=1; 				} 		} 		for(i=count+1;i<=n;i++) 		{ 			if(visit[i]==0) 			{ 				sum+=i; 			} 		} 			 		cout<<sum<<endl; 	} } 
#include<iostream> using namespace std;  int main() {     long long int a,b;     cin>>a>>b;     while(a!=0 && b!=0)     {         int carry=0;         int carrier=0;         while(a>0 && b>0)         {          int rem1=a%10;         int rem2=b%10;         if(rem1+rem2+carrier>=10)         carry++;         carrier=(rem1+rem2+carrier)/10;         a=a/10;         b=b/10;         }         if(carry==0)         cout<<"No carry operation."<<endl;         else if(carry==1)         cout<<"1 carry operation."<<endl;         else         cout<<carry<<" carry operations."<<endl;         cin>>a>>b;     }     return 0; }
//https://www.codechef.com/CDCK2015/problems/PRMRL/  #include <iostream> #include <cstdio>  using namespace std;  int multiply(int x, int res[], int res_size) {    int carry = 0;   for(int i=0; i<res_size; i++) {     int prod = res[i] * x + carry;     res[i] = prod % 10;     carry = prod / 10;   }    while(carry) {     res[res_size] = carry % 10;     carry = carry / 10;     res_size++;   }   return res_size; }   void primorial(int n) { 	int prime[26]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};  	int res[500]; 	res[0] = 1; 	int res_size = 1;  	for(int x=0; x<25 && prime[x]<=n; x++) 		res_size = multiply(prime[x], res, res_size);  	for(int i=res_size-1; i>=0; i--) 		cout << res[i]; 	cout << endl; }  int main() { 	int t; 	cin >> t; 	while(t--) { 		int n; 		cin >> n; 		primorial(n);	 	} 	return 0; } 
#include <cstdio>       int main() {          	double p=0, q=0;           	scanf("%lf %lf\n", &p, &q);       	while(p>0 && q>0)     	{       		double h=0, v=0, d=0;           		if(q<p)     		{     			h=q;     			q=p;     			p=h;     		}      		h=0;     		h=q*p*(p-1);     		v=p*q*(q-1);     		d=2*((p-1)*p*((2*p)-1)/3)+2*(p*(p-1))+2*((q-p-1)*p*(p-1));      		printf("%.0lf\n", (h+d+v));     		scanf("%lf %lf\n", &p, &q);     }            return 0; } 
#include<iostream>   using namespace std; int main() {  char a[] = {'s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','g','h'};  char b[] = {'i','j','k','l','m','n','o','p','q','r'};  char s[1001];  int t;  scanf("%d\n",&t);    while(t--)  {          gets(s);//fgets(s, 1000, stdin);     char *p = s;            while(*p != '\0'){                                     if(*p >= 97 &&  *p <= 122)               {          	        *p = a[*p - 97];               }               else if(*p >= '0' && *p <= '9')               {                     *p = b[*p-'0'];               }                                          p++;                   }     printf("%s\n",s);       }      	  //getch();  return 0; } 
#include <cstdio> #include <iostream> using namespace std; int main(int argc, char const *argv[]) { 	int t; 	scanf("%d",&t); 	while(t--){ 		int n,x,y; 		scanf("%d%d%d",&n,&x,&y); 		cout<<n*720/(x+y)<<"\n"; 	} 	return 0; }
#include<bits/stdc++.h> using namespace std;   const int N=1234567; int composite[N];   void prepare() {     composite[0]=1;     composite[1]=1;     for(int i=2;i*i<=N;i++) {         if(!composite[i]) {             for(int j=2*i;j<N;j+=i) {                 composite[j]=1;             }         }     } }   bool is_palindrome(int n) {     int rev=0, cur=n;     while(n) {         rev=rev*10+n%10;         n/=10;     }     return (rev==cur)?true:false; }     int main() {     int n;     prepare();     scanf("%d", &n);     for(int i=n;i<N;i++) {         if(!composite[i] && is_palindrome(i)) {             printf("%d", i);             break;         }     } }
#include<iostream> using namespace std; #include<math.h>   int reverse(int sum) { int r=0; while(sum>0) { r=(r*10)+(sum%10); sum=sum/10; } return r; }   bool ispalindrome(int num) { if(num == reverse(num))  return true; else return false; }   bool prime(int N) { int i; for(i=2;i<=N/2;i++)   if(N%i == 0)     return false;   return true; }   int main() { int N; cin>>N; if(N%2 == 0)  N++; while(true)  {    if(ispalindrome(N) && prime(N))     break;    else     N+=2;  } cout<<N<<"\n"; return 0; }
#include <iostream> #include <vector> #include <string> #include <sstream> #include <algorithm> #include <stack> #include <queue> #include <map> #include <string.h>  using namespace std;  int memo[111][111];  vector<int> data;  int func(int leftIdx, int rightIdx) {    // base case    if (rightIdx - leftIdx < 2) {       return 0;    }    if (memo[leftIdx][rightIdx] != -1) return memo[leftIdx][rightIdx];    int res = 1<<30;    for (int i = leftIdx+1; i < rightIdx; i++) {       // split on prisoner index i       int calc = (data[i] - data[leftIdx] - 1) + (data[rightIdx] - data[i] - 1);       calc = calc + func(leftIdx, i) + func(i, rightIdx);       res = min(res,calc);    }    return memo[leftIdx][rightIdx] = res; }  int main() {    int N;    cin >> N;    for (int t = 0; t < N; t++) {       int P, Q; cin >> P >> Q;       vector<int> pris;       for (int i = 0; i < Q; i++) {          int val; cin >> val; pris.push_back(val);       }       // add explicit barriers to the ends of the prisons       pris.push_back(0);       pris.push_back(P+1);       // ensure that the prisoner indexes are strictly increasing       sort(pris.begin(),pris.end());       data = pris;       memset(memo,-1,sizeof(memo));       int best = func(0, data.size()-1);       //cout << "Case #" << t+1 << ": " << best << "\n";       cout<< best<<"\n";    }    return 0; } 
#include <vector> #include <list> #include <map> #include <set> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <string.h> #include <queue>  using namespace std;  #define rep(i,a,b) for(typeof(a) i=(a);i<(b);i++) #define ll long long int #define ii pair<int,int> #define CLEAR(x,val) memset(x,val,sizeof(x)) #define SZ(v) (v).size() #define pb push_back  vector<double> vx; vector<double> vy;  int cross( int p , int i , int n ) { 	double x1 = vx[i]-vx[p]; 	double x2 = vx[n]-vx[p]; 	double y1 = vy[i]-vy[p]; 	double y2 = vy[n]-vy[p]; 		 	if( (x1*y2-y1*x2) >= 0 ) return 1; 	else return -1; } double convexHull( int N ) { 	int p = 0;double ret = 0.0; 	rep( i , 0 , N  ) { 		if( vx[i] < vx[p] ) p = i; 		else if( (vx[i]==vx[p]) && (vy[i]>vy[p]) ) p = i; 	} 	int start = p; 	do { 		int n = -1; 		for( int i = 0; i < N; i++ ) { 			 			if( i == p ) continue; 					 			if( n == -1 ) n = i; 			 			int cros = cross( p , i , n ); 			 			if( cros < 0 ) {	 				n = i; 			} 		} 		ret += sqrt( (vx[n]-vx[p])*(vx[n]-vx[p])+(vy[n]-vy[p])*(vy[n]-vy[p]) );  //		cout << vx[p] << " " << vy[p] << "\n"; 		p = n; 	}while(start!=p); 	 	return ret; }  int main() {   	vx.clear();vy.clear();		  	int N;scanf("%d",&N); 	rep( i , 0 , N ) { 		double x ,  y; 		scanf("%lf %lf" , &x , &y ); 		vx.push_back( x );vx.push_back( x+2.0 );vx.push_back(x);vx.push_back(x+2.0);		 		vy.push_back( y );vy.push_back(y);vy.push_back( y+2.0 );vy.push_back(y+2.0); 	} 	int newn = vx.size(); 	printf( "%0.6lf\n" , convexHull( newn ) ); 	return 0; }
#include<bits/stdc++.h> #define LL long long using namespace std; pair<LL,LL>pa[30010]; int bs(LL x, int n) {     int start=0, end=n-1, mid= (start+end)>>1;     while(end-start>=2)     {         if(pa[mid].first<=x)         {             start=mid;         }         else end=mid-1;          mid= (start+end)>>1;     }     while(1)     {         if(pa[end].first<x) return end; end--;     }  } main() {     int t,i,j,N;     scanf("%d",&t);     while(t--)     {         scanf("%d",&N);         for(i=0;i<N;i++)         {             scanf("%lld",&pa[i].second);  //starting                scanf("%lld",&pa[i].first); // finishing time         }         pa[N].first= pa[N].second= - 1000000000000LL; // append it at the beginning so that the if a number less than x is not found it returns 0         N++;         sort(pa,pa+N);                  // now calculate P[j];         LL dp[N+10];         int P[N+10];         P[0]=0;         for(j=1;j<N;j++)         {             P[j]= bs(pa[j].second,j);         }         dp[0]=0;         for(i=1;i<N;i++)         {             dp[i]= max(dp[i-1], dp[P[i]]+ pa[i].first- pa[i].second+1);         }         printf("%lld\n",dp[N-1]);     }    return 0; }
#include<iostream> #include<cstdio>  using namespace std; typedef long long int ll;   ll fun(ll a,ll b){ 	if(a>b) 		return a; 	else 		return b; 	}   ll gcd(ll a,ll b){ 	if(b==0) 		return a; 	else 		return gcd(b,a%b); 	}    int main(){ 	int t; 	long long int a,b; 		scanf("%d",&t); 	while(t--){ 		cin>>a>>b; 		long long int c=gcd(a,b); 		if(a==b) 			cout<<0<<endl; 		else{ 			cout<<fun(a,b)/c-2<<endl; 			} 		} return 0; }  		 
#include <stdio.h> #include <iostream> #include <cmath> using namespace std; #define mod 1000000007 #define ll long long int ll fp(ll a,ll n) {     if(n==0) return 1;     if(n==1) return a;          ll half=fp(a,n/2);     if(n%2==0)         return (half*half)%mod;     else return (a*((half*half)%mod))%mod; } int main() { 	ll t,i,j,k; 	scanf("%lld",&t); 	while(t--) 	{ 		ll n; 		scanf("%lld",&n); 		ll divbythree=n/3; 		ll modulothree=n%3; 		if(n<=4) 			printf("%lld\n",n); 		else 		{ 			if(modulothree==0) 			{ 				printf("%lld\n",fp(3,divbythree)%mod); 			} 			else if(modulothree==1) 			{ 				printf("%lld\n",(fp(3,divbythree-1)*4)%mod); 			} 			else 			{ 				printf("%lld\n",(fp(3,divbythree)*2)%mod); 			} 		} 	} 	return 0; }
#include <bits/stdc++.h> using namespace std;  int memo[2][505][505], A[505][505]; int t, n, m;   int cost(int x, int y, int turn){ 	if(x >= n || y>=m)	memo[turn][x][y] = -INT_MAX; 	if(memo[turn][x][y]!=INT_MAX)	return memo[turn][x][y]; 	memo[turn][x][y] = A[x][y]; 	if(turn==0)	memo[turn][x][y] -= max(cost(x+1, y, 1), cost(x, y+1, 1)); 	else if(turn==1)	memo[turn][x][y] -= max(cost(x+1, y, 0), cost(x, y+1, 0)); 	//cout<<x<<" "<<y<<" "<<turn<<"-->"<<memo[turn][x][y]<<endl; 	return memo[turn][x][y]; }  int main(){  	//cin>>t; 	scanf("%d", &t);  	while(t--){ 		for(int i=0;i<505;i++){ 			for(int j=0;j<505;j++)	memo[0][i][j] = memo[1][i][j] = INT_MAX; 		} 		scanf("%d %d", &n, &m);  		for(int i=0;i<n;i++){ 			for(int j=0;j<m;j++)	scanf("%d", &A[i][j]); 		} 	 		memo[(n+m)%2][n-1][m-1] = A[n-1][m-1];  		cout<<cost(0, 0, 0)<<endl;	 	}  	//system("pause"); 	return 0; }
#include<iostream> using namespace std; int main() {  ios::sync_with_stdio(0);  long long int n,m;  int t;  cin>>t;  while(t--)  {   cin>>n>>m;   if (m>(n/2)) cout<<n/2-(n-m)<<endl;   else cout<<(n/2)+m<<endl;  }  return 0; } 
/*Author :rednivrug15 */ #include<bits/stdc++.h> #define pb push_back #define mp make_pair #define rep(i,n) for(int i=0; i<n ; i++) using namespace std;   #define REP(i,n) for (int i = 1; i <= n; i++) #define ll long long const int mod=1000000007;   long long gcd(long long a,long long b) {     return b==0?a:gcd(b,a%b); }   long long int lcm(long long int a, long long int b) {   return (a/gcd(a,b))*b; }   long long extended_euclid(long long int a, long long int b,long long int &x,long long int &y) {   long long int xx = y = 0;   long long int yy = x = 1;   while (b) {     long long int q = a/b;     long long int t = b; b = a%b; a = t;     t = xx; xx = x-q*xx; x = t;     t = yy; yy = y-q*yy; y = t;   }   return a; }   int tree[400001]; int n;   void update(int node,int i,int j,int x) {     if(i>x || j<x)         return;     if(i==x && j==x)     {         tree[node]=1;         return;     }     update(2*node,i,(i+j)/2,x);     update(2*node+1,(i+j)/2+1,j,x);     tree[node]=tree[2*node]&tree[2*node+1]; }   int query(int node,int i,int j,int x) {     if(j<x)         return -1;     if(tree[node]==1)         return -1;     if(i==j)         return i;     int leftchild=query(2*node,i,(i+j)/2,x);     //printf("%d %d\n",leftchild,node);     if(leftchild!=-1)         return leftchild;     return query(2*node+1,(i+j)/2+1,j,x); }     int main() {     int t;     cin>>t;       while(t--)     {        memset(tree,0,sizeof tree);        cin>>n;          if(n==0)        {            printf("0\n");            continue;        }          if(n==1)        {            printf("0 1\n");            continue;        }          int N=n;        if(n%2==1)         n=n-1;          int ans[N];          ans[0]=(n/2);        ans[n-1]=(n/2)+1;          update(1,1,n,n/2);        update(1,1,n,(n/2)+1);          long long sum=0;        int flag=0,last=ans[0];          for(int i=1,j=n-2; i<=j; i++,j--)        {            int put,diff;            if(flag==0)            {                put=query(1,1,n,last);                diff=ans[i-1]-put;                last=put;            }            else            {                put=query(1,1,n,1);                diff=ans[i-1]-put;            }            update(1,1,n,put);              ans[i]=put;            ans[j]=ans[j+1]+diff;              update(1,1,n,ans[i]);            update(1,1,n,ans[j]);            flag^=1;        }          if(N%2==1)        {            ans[N-1]=ans[n-1];            ans[n-1]=N;        }          for(int i=1; i<N; i++)         sum+=abs(ans[i]-ans[i-1]);           printf("%lld ",sum);          for(int i=0; i<N; i++)           printf("%d ",ans[i]);         printf("\n");     }       return 0; }
#include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <cstdlib> using namespace std; typedef long long ll; const int INF = 0x3f3f3f3f; const int N = 1e5 + 10; struct Node { 	int id; 	ll v; 	Node() {} 	Node(int _id, ll _v) { 		this->id = _id; 		this->v = _v; 	} }st[N]; ll a[N], left[N], right[N]; int main() { 	int T, n; 	scanf("%d", &T); 	while(T--) { 		scanf("%d", &n); 		for(int i = 1; i <= n; i++) 			scanf("%lld", &a[i]); 		int top = 0; 		st[0] = Node(0, 0); 		for(int i = 1; i <= n; i++) { 			while(top && st[top].v > a[i]) 				top--; 			left[i] = st[top].id; 			st[++top] = Node(i, a[i]); 		} 		st[0].id = n+1; 		top = 0; 		for(int i = n; i >= 1; i--) { 			while(top && st[top].v >= a[i]) 				top--; 			right[i] = st[top].id; 			st[++top] = Node(i, a[i]); 		} 		ll ans = 0; 		for(int i = 1; i <= n; i++) { 			ans += (ll)(right[i]-i) * (i-left[i]) * (a[i]); 		} 		printf("%lld\n", ans); 	} 	return 0; }
#include <cstdio> #include <cmath>  using namespace std;  double find_p(double x) {     double temp;     x--;     if(x<2) return -1;     temp = (x + sqrt(x*x-4))/2;     return 1/(temp+1); }  int main() {     double p,x;long int t;     scanf("%ld",&t);     while(t--)     {         scanf("%lf",&x);         p=find_p(x);         if(p==-1) printf("-1\n");         else         printf("%0.8lf\n",p);     }     return 0; } 
#include<bits/stdc++.h> #include<iostream> const long long int MAXN=1e5+1; using namespace std; #define ll long long int #define ans(N) (4*N*N-3*N)  bool prime(int x) {     if(x==2||x==3||x==5||x==7)     {         return 1;     }     if(x==1||x%2==0||x%3==0||x%5==0||x%7==0)     {         return 0;     }     int to=(x%2)?x/3:x/2;     for(int i=2;i<=to;i++)     {         if(!(x%i))             return 0;     }     return 1; }   int main() {      ios_base::sync_with_stdio(false);     cin.tie(0);     int T;     int N;     int tmp;     int arr[4];     cin>>T;     while(T--)     {     cin>>N;     tmp=N-6;     while(!prime(tmp))     {         tmp--;     }     arr[3]=tmp;     N-=arr[3];     tmp=N-4;     while(!prime(tmp))     {         tmp--;     }     arr[2]=tmp;     N-=arr[2];     tmp=N-2;     while(!prime(tmp))     {         tmp--;     }     arr[1]=tmp;     N-=arr[1];     arr[0]=N;     for(int i=0;i<4;i++)         cout<<arr[i]<<" ";     cout<<endl;     }     return 0; } 
#include<stdio.h> #include<iostream> #include<string> using namespace std;  /*int scan() {     int n=0;     char ch=getc_unlocked(stdin);     while (ch<'0'||ch>'9')     {         ch=getc_unlocked(stdin);     }     while (ch>='0'&&ch<='9')     {         n=n*10+ch-'0';         ch=getc_unlocked(stdin);     }      return n; }*/ int main() {    int n,q,i,j;    cin>>n;    long long int a[n+1];    for(int k=1;k<=n;k++)         cin>>a[k];    for(int k=2;k<=n;k++)        a[k]+=a[k-1];         cin>>q;         while(q--)     {        cin>>i>>j;      if(i==1)      cout<<a[j]<<endl;      else      cout<<a[j]-a[i-1]<<endl;     }          return 0; } 
//Abhishek Paliwal #include<iostream> #include<stdio.h> #include<stdlib.h> #include<math.h> #include<malloc.h> #include<string.h> #include<algorithm> #include<vector> #include<queue> #include<utility> #include<climits> #include<map>  #define FOR(i,s,n) for(i=s;i<n;i++) #define FORD(i,s,n) for(i=s;i>n;i--) #define LL long long #define M 1000000007  using namespace std; bool check(LL p,LL k) { 	LL x=0,y=p; 	while(k--) 	{ 		x<<=1; 		x+=(p&1); 		p>>=1; 	} 	if(x==y) 		return false; 	return true; }  LL pow(LL x,LL n) { 	LL ans=1; 	while(n) 	{ 		if((n&1)==1) 		{ 			ans*=x; 			ans%=M; 		} 		x*=x; 		x%=M; 		n>>=1; 	} 	return ans; }  int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		bool a[10000]={0}; 		bool b[10000]={0};  		LL ans[2000][410]={{0}};   		LL n,k; 		scanf("%lld%lld",&n,&k); 		if(n<k) 		{ 			printf("%lld\n",pow(2,n)); 			continue; 		} 		LL h=1<<k; 		LL hc=~h; 		LL i,j; 		for(i=0;i<h;i++) 		{ 			a[i]=check(i,k); 			if(a[i]) 				ans[i][k-1]=1; 		} 		for(i=0;i<(h<<1);i++) 			b[i]=check(i,k+1); 		for(i=k;i<n;i++) 		{ 			for(j=0;j<h;j++) 			{ 				if(a[j] && ans[j][i-1]) 				{ 					LL x=(j<<1); 					LL y=x+1; 					if(b[x] && a[ hc&x ]) 					{ 						x=hc&x; 						ans[x][i]+=ans[j][i-1]; 						ans[x][i]%=M; 					} 					if(b[y] && a[ hc&y ]) 					{ 						y=hc&y; 						ans[y][i]+=ans[j][i-1]; 						ans[y][i]%=M; 					} 				} 			} 		} 		LL s=0; 		for(i=0;i<h;i++) 		{ 			s+=ans[i][n-1]; 			s%=M; 		} 		printf("%lld\n",s); 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { //char  str[100]; string str; int n,x,i,count,n1; cin>>n; cin.ignore(); while(n--) {     getline(cin,str);     //x=strlen(str);     x=str.length();     count=0;     for(i=0;i<x;i+=6)     {         if(str[i]==str[i+4]&&str[i+1]==str[i+3]||            (str[i]==str[i+3]&&str[i+1]==str[i+4])||            (str[i]==str[i+1]&&str[i+3]==str[i+4]))             count++;     }     cout<<count<<endl; } return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { int n,i,x,t; char str[100],str1[100]; fflush(stdin); cin>>t; t++; while(t--) {     gets(str);     x=strlen(str);     for(i=0;i<x;i++)     {         if(islower(str[i]))         {             if(str[i]>'m')             {                 str1[i]=(char)(96+((int)str[i]+13)%122);             }             else             {                 str1[i]=(char)(str[i]+13);             }         }         else if(isupper(str[i]))         {             if(str[i]>'M')             {                 str1[i]=(char)(64+((int)str[i]+13)%90);             }             else             {                 str1[i]=(char)(str[i]+13);             }         }         else if(isdigit(str[i]))         {             if(str[i]>'4')             {                 str1[i]=str[i]-5;             }             else             {                 str1[i]=str[i]+5;             }         }         else if(str[i]==' ')         {             str1[i]=' ';         }     }     str1[i]='\0';     cout<<str1<<endl; } return 0; } 
#include<bits/stdc++.h> using namespace std; int main() {   int n,i,x,j,sum; char str[100000]; cin>>n; for(i=0;i<n;i++) {      cin>>str;     x=strlen(str);     sum=0;     for(j=0;j<x;j++)     {         sum+=(str[j]-'A'+1);     }     cout<<sum<<endl;  } return 0; } 
/*God is greater than any problem that u have and u have to not worry because when u pray and then worry, the worry nullify your prayer He is right here, right now !! */   #include <bits/stdc++.h> using namespace std; #define bitcnt __builtin_popcount #define ln length() #define rep(i, n) for(int i = 0; i < n; i++) #define rrep(i, n) for(int i = n - 1; i >= 0; i--) #define all(a)  a.begin(),a.end() #define LL long long #define limit 1000006 #define sl(n) scanf("%lld", &n) #define s(n)  scanf("%d", &n) #define pl(n) printf("%lld", n) #define pi(n)  printf("%d", n) #define pb push_back #define pn printf("\n") #define mod 1000000007 typedef vector<LL> row; typedef vector<row> matrix;   void print(LL *arr, LL n) { 	rep(i, n) cout << arr[i] << " "; 	cout << endl; }   LL n; vector<LL>v; LL se;   #define pii pair<LL, LL> map<pii, LL>m; LL rec(LL pos, LL pro) { 	if(pos == -1) { 		return (pro == 1); 	} 	if(m.find(make_pair(pos, pro)) != m.end()) { 		return m[make_pair(pos, pro)]; 	} 	LL ans = 0; 	ans += rec(pos - 1, pro); 	if(pro % v[pos] == 0) { 		ans += rec(pos - 1, pro / v[pos]); 	} 	if(ans >= mod) { 		ans %= mod; 	} 	return m[make_pair(pos, pro)] = ans;	 }   void solve() { 	m.clear(); 	v.clear(); 	scanf("%lld\n", &n); 	string str; 	getline(cin, str); 	int size = str.size();	 	LL tid = 0, j = 0; 	while(j < size) { 		if(str[j] == ' ') { 			v.pb(tid); 				tid = 0; 			} 		else { 			if(str[j] == '\n') { 				break; 			} 			tid = (tid * 10) + (str[j] - '0'); 		} 		j++; 	} 	v.pb(tid); 	se = (LL)v.size(); 	LL ans = rec(se - 1, n); 	if(n == 1) { 		ans -= 1; 		pl(ans); pn; 	} 	else { 		pl(ans); pn; 	} }   int main() { 	int t; 	scanf("%d", &t); 	while(t--) { 		solve(); 	} 	return 0; }
#include <iostream>                           using namespace std;                      int main() { int a[1500],x,y=0,flag=0,t ; for(int i=1;i<400;i++) {if((180*i)%(i+2)==0) {y++; a[y]=180*i/(i+2); /*cout<<y<<"\t"<<a[i]<<"\n";*/}} cin>>t; while(t--) {flag=0; cin>>x;  for(int i=1;i<=22;i++) {if(x==a[i]) {flag=1;  cout<<"YES\n";}  } if(flag==0) cout<<"NO\n"; }                         return 0; } 
#include<iostream> using namespace std; int a[110]; int main() {     int t,n,c,i;     cin>>t;     while(t--)     {         cin>>n;c=0;         for(i=1;i<=n;i++)         cin>>a[i];         for(i=n;i>=2;i--)         {             if(a[i]>a[i-1])             c++;             else             break;         }         c++;         c=n-c;         cout<<c<<endl;     } } 
#include<stdio.h> int sum(int n);int arr[100];void reset();int s[100]; int main() { int t,n,p;scanf("%d",&t); for(int i=0;i<t;++i) {reset();scanf("%d",&n);  //sum=0; for(int j=0;j<n;++j) {scanf("%d",&arr[j]); } for(int  k=0;k<n-1;++k) {if(arr[k]<arr[k+1]) {s[k+1]+=s[k];      } else if(arr[k]>arr[k+1]) {p=k;while((s[p+1]>=s[p])&&(arr[p]>arr[p+1])) {s[p]++;p--; } } //else if(arr[k]==arr[k+1])s[k+1]=1;}  } printf("%d\n",sum(n)); //  reset(); }   return 0; } int sum(int n) {int sum=0;for(int i=0;i<n;++i) { {//printf("*%d ",s[i]); sum+=s[i];}  } return sum;  }  void reset() {   for(int i=0;i<100;++i) s[i]=1;  }
#include <cstdio> #include <iostream>  using namespace std;  #define for_inc(i,a,b,c) for(i = a; i < b; i+= c) #define inp_d(x) scanf("%d",&x) #define inp_c(x) scanf("%c",&x) #define inp_str(x) scanf("%s",x) #define out_d(x) printf("%d\n",x) #define MAX 1000000  int tree[3*MAX][4]; int lazy[3*MAX]; char str[MAX];  void assign(int arr[],int val){ 	int i; 	for_inc(i,0,4,1) arr[i] = 0; 	if (val == 4) arr[0] = 1; 	else arr[3] = 1; }  void p(int a[]){ 	int i; 	for_inc(i,0,4,1) 		cout << a[i] << " "; 	cout << endl; } void merge(int a[],int a1[],int a2[]){ 	//cout << "merging \n"; 	//p(a1),p(a2); 	//cout << "found\n"; 	a[0] = a1[0] + a2[0]; 	a[3] = a1[3] + a2[3]; 	a[1] = max(a1[0]+a2[1],max(a1[1]+a2[3],a1[0]+a2[3])); 	a[2] = max(a1[2]+a2[0],max(a1[3]+a2[2],a1[3]+a2[0])); 	 	//p(a); }   void invert(int a[]){ 	swap(a[0],a[3]); 	swap(a[1],a[2]); }  void print(int a[],int i,int j){ 	cout << "range is " << i << " " << j  << " array is " << endl; 	int x; 	for_inc(x,0,4,1)  		cout << a[x] << " "; 	cout << endl; }  void build(int n,int i,int j){ 	if (i == j){ 		assign(tree[n],str[i]-48); 		//print(tree[n],i,j); 		return; 	}	 	int mid = (i+j) >> 1, lt = n << 1 , rt = lt | 1; 	build(lt,i,mid); 	build(rt,mid+1,j); 	merge(tree[n],tree[lt],tree[rt]); 	//print(tree[n],i,j); }  void update(int n,int i,int j,int a,int b){ 	int mid = (i+j) >> 1, lt = n << 1, rt = lt | 1; 	if (lazy[n]){ 		if (lazy[n] & 1) {  			invert(tree[n]); 			if (i != j) lazy[lt] += 1, lazy[rt] += 1; 		} 		lazy[n] = 0; 	} 	if (i > b || j < a) return; 	if (i >= a && j <= b){ 		invert(tree[n]); 		if (i != j) lazy[lt] += 1, lazy[rt] += 1; 		return; 	} 	update(lt,i,mid,a,b); 	update(rt,mid+1,j,a,b); 	 	merge(tree[n],tree[lt],tree[rt]);  } int main() { 	int n,m,i,j; 	inp_d(n),inp_d(m); 	 	for_inc(i,0,n,1) { 		lazy[i] = 0; 		for_inc(j,0,4,1) tree[i][j] = 0; 	} 	 	inp_str(str); 	build(1,0,n-1); 	 	char str1[10]; 	while(m--){ 		inp_str(str1); 		if (str1[0] == 'c') 			out_d(max(tree[1][0],max(tree[1][1],tree[1][3]))); 		else { 			int a,b; 			inp_d(a),inp_d(b); 			update(1,0,n-1,a-1,b-1); 		} 	} 	return 0; }
#include <bits/stdc++.h> using namespace std; #define PB push_back int k; struct node {     int odd_sum , even_sum,odd_count,even_count;     vector<char> lazy ;     void split(node &a , node &b)     {         for(int i=0;i<lazy.size();i++)         {             if(lazy[i] == 'E')             {                 a.even_sum += a.odd_sum + a.odd_count;                 a.odd_sum = 0;                 a.even_count += a.odd_count;                 a.odd_count = 0;                 b.even_sum += b.odd_sum + b.odd_count;                 b.odd_sum = 0;                 b.even_count += b.odd_count;                 b.odd_count = 0;                 a.lazy.PB('E');                 b.lazy.PB('E');             }             else if(lazy[i] == 'O')             {                 a.odd_sum += a.even_sum + a.even_count;                 a.even_sum = 0;                 a.odd_count += a.even_count;                 a.even_count = 0;                 b.odd_sum += b.even_sum + b.even_count;                 b.even_sum = 0;                 b.odd_count += b.even_count;                 b.even_count = 0;                 a.lazy.PB('O');                 b.lazy.PB('O');             }             else if(lazy[i] == 'I')             {                 int temp;                 // left child                 temp = a.even_sum;                 a.even_sum = a.odd_sum + a.odd_count;                 a.odd_sum = temp  + a.even_count;                 temp = a.odd_count;                 a.odd_count = a.even_count;                 a.even_count = temp;                  // right child                 temp = b.even_sum;                 b.even_sum = b.odd_sum + b.odd_count;                 b.odd_sum = temp  + b.even_count;                 temp = b.odd_count;                 b.odd_count = b.even_count;                 b.even_count = temp;                 a.lazy.PB('I');                 b.lazy.PB('I');             }         }         lazy.clear();     }     void point_update(char check)     {         if(check == 'E')         {             even_sum += odd_sum + odd_count;             odd_sum = 0;             even_count += odd_count;             odd_count = 0;             lazy.PB('E');         }         else if(check == 'O')         {             odd_sum += even_sum + even_count;             even_sum = 0;             odd_count += even_count;             even_count = 0;             lazy.PB('O');         }         else if(check == 'I')         {             int temp = even_sum;             even_sum = odd_sum + odd_count;             odd_sum = temp + even_count;             temp = even_count;             even_count = odd_count;             odd_count = temp;             lazy.PB('I');         }     }     void merge(node a , node b)     {         even_sum = a.even_sum + b.even_sum;         even_count = a.even_count + b.even_count;         odd_sum = a.odd_sum + b.odd_sum;         odd_count = a.odd_count + b.odd_count;     }     node()     {         odd_sum = 0;         even_sum = 0;         odd_count = 0;         even_count = 0;     } }tree[2*(1<<20)]; void set_v(node &temp,int val) {     if(val&1)     {         temp.odd_sum += val;         temp.odd_count +=1;     }     else     {         temp.even_sum += val;         temp.even_count +=1;     } } void create(int pos) {     pos>>=1;     while(pos!=0)     {         tree[pos].merge(tree[pos*2],tree[pos*2 + 1]);         pos>>=1;     } } void range_update(int root,int left_most ,int right_most , int l,int r,char val) {     if(l <= left_most && r >= right_most){         tree[root].point_update(val);         return ;     }     int l_child = (root<<1) , r_child = l_child + 1 , mid = (left_most + right_most)>>1;     tree[root].split(tree[l_child],tree[r_child]);     if(l <= mid)         range_update(l_child , left_most , mid , l , r , val);     if(r > mid)         range_update(r_child , mid+1 , right_most , l , r , val);     tree[root].merge(tree[l_child] , tree[r_child]); } node range_query(int root , int left_most , int right_most , int l ,int r) {     if( l <= left_most && r >= right_most )         return tree[root];     int l_child = (root<<1) , r_child = l_child + 1 , mid = (left_most + right_most )>>1 ;      tree[root].split(tree[l_child],tree[r_child]);      node l_node = node() , r_node = node();      if(l <= mid)         l_node = range_query(l_child , left_most , mid , l , r);     if(r > mid)         r_node = range_query(r_child , mid + 1 , right_most, l , r);      tree[root].merge(tree[l_child] , tree[r_child]);      node temp = node();     temp.merge(l_node,r_node);      return temp; } int main() {     int n,temp,l,r;     scanf("%d",&n);     k = ceil(log(n)/log(2));     int pos = (1<<k);     for(int i=0;i<n;i++){         scanf("%d",&temp);         set_v(tree[pos+i],temp);         create(pos+i);     }     int m;     char c;     scanf("%d",&m);     while(m--)     {         scanf(" %c%d%d",&c,&l,&r);         if(c=='M'){             node hold;             hold = range_query(1,1,pos,l,r);             cout<<hold.even_sum + hold.odd_sum<<endl;         }         else{             range_update(1,1,pos,l,r,c);         }     }     return 0; }
#include <iostream> #include<cmath> using namespace std;  int main() { 	// your code goes here 	int t; 	cin>>t; 	while(t--){ 		long long int n; 		cin>>n; 		int m=(int)sqrt(n); 		int msquare=m*m; 		if(msquare==n) 			cout<<2*m-1<<"\n"; 		else{ 			int count=2*m-1; 			int k=(m+1)*(m+1); 			int x=(k-msquare-1)/2; 			if(n<=msquare+x) 				count++; 			else 				count=count+2; 			cout<<count<<"\n"; 		} 	} 	return 0; }
#include<cstdio> long long int dp[110][110]; long long int f(int n, int k) {         if(dp[n][k] != -1)                 return dp[n][k];          if(k == 1)         {                 dp[n][k] = 1;                 return 1;         }          int i;         long long int v=0;          for(i=0; i<=n && n-i >= k-1; i++)                 v = (v + f(n-i, k-1))%761238923;          dp[n][k] = v;         return dp[n][k]; }  int main() {         int i, j, n;         while(1)         {                 scanf("%d", &n);                  if(n == 0)                         return 0;                 for(i=0; i<=n; i++)                         for(j=0; j<=n; j++)                                 dp[i][j] = -1;                 printf("%lld\n", f(n, n));         } } 
#define _CRT_SECURE_NO_WARNINGS   #include <vector> #include <list> #include <map> #include <set> #include <deque> #include <queue> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <complex> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <climits> #include <cassert> #include <cctype> #include <string> #include <cstring> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime>   using namespace std;   #define SZ(x) (int)(x).size() #define FOR(i, seq, n) for(int i = (seq); i < (n); ++i) #define FORD(i, seq, n) for(int i = (seq); i >= (n); --i) #define REP(i, n) for(int i = 0; i < (n); ++i) #define REPD(i, n) for(int i = (n) - 1; i >= 0; --i) #define ALL(x) (x).begin(), (x).end() #define SQR(x) (x)*(x) typedef unsigned long long u64; typedef signed long long i64; typedef pair<int, int> pii; #define X first #define Y second   const int iters = 30; int n, px[301], py[301];   double eval(double x, double y) { 	double ret = 0; 	REP (i, n) ret = max(ret, (x - px[i]) * (x - px[i]) + (y - py[i]) * (y - py[i])); 	return ret; }   double get(double y) { 	double lo = 0, hi = 1000; 	REP (i, iters) { 		double nl = (2 * lo + hi) / 3; 		double nh = (lo + 2 * hi) / 3; 		if (eval(nl, y) > eval(nh, y)) 			lo = nl; 		else 			hi = nh; 	} 	return eval((lo + hi) / 2, y); }   int main() { 	scanf("%d", &n); 	REP (i, n) scanf("%d%d", &px[i], &py[i]); 	double lo = 0, hi = 1000; 	REP (i, iters) { 		double nl = (2 * lo + hi) / 3; 		double nh = (lo + 2 * hi) / 3; 		if (get(nl) > get(nh)) 			lo = nl; 		else 			hi = nh; 	} 	double r = sqrt(get((lo + hi) / 2)); 	printf("%.2lf\n", 2 * r); 	return 0; }  
#include <iostream> #include <stdio.h> #include <string.h> using namespace std;  int cam[210]; int N; char linea[210]; int maxi=0;  void leer(){     cin >> N;      gets(linea);     gets(linea);     for(int i=1; i<=N; i++){         gets(linea);         int l=strlen(linea);          if(l>maxi){             maxi=l;         }          for(int i=0; i<l; i++){              if(linea[i]=='/'){                 cam[i]=1;             }else if(linea[i]==92){                 cam[i]=3;             }else if(linea[i]=='_'){                 cam[i]=2;             }         }     }  }  int main() {     leer();      int pas=cam[0];     int ult=0;      cout << "Total Walk Distance = " << maxi << endl;      for(int i=0; i<=maxi; i++){         if(cam[i]==pas){             ult++;         }else{             if(pas==1){                 cout << "Up ";             }else if(pas==2){                  cout << "Walk ";             }else if(pas==3){                 cout << "Down ";             }              cout << ult << " steps"<<endl;             ult=1;             pas=cam[i];          }     }     return 0; } 
// Game Theory- Based on game of Nim  #include<stdio.h>  int main() {	int t,n,r,x; 	scanf("%d",&t); 	while ( t-- > 0) 	{	r=0; 		scanf("%d",&n); 		for ( int i=1; i<=n; i++ ) 		{	scanf("%d",&x); 			for ( int j=1; j<=x; j++) 				r=r^i; 		} 		printf(r!=0 ? "Tom Wins\n" : "Hanks Wins\n"); 	} 	return 0; } 			 		  
#include <stdio.h> #include <string.h> #define SET(p) memset(p, -1, sizeof(p)) #define READ freopen("input.cpp", "r", stdin); #define WRITE(f) freopen(f, "w", stdout) #define getcx getchar_unlocked #define MX 100  using namespace std;  inline int fi (){//fast input function     register int c = getcx();     int x = 0;     int neg = 0;     for(;((c<48 || c>57) && c != '-');c = getcx());     if(c=='-') {neg=1;c=getcx();}     for(;c>47 && c<58;c = getcx()) {x = (x<<1) + (x<<3) + c - 48;}     if(neg) x=-x;     return x; }   template< class T > T _max(T a, T b) { return (!(a < b) ? a : b); }  const int N =1e5; int n; int t[2*N];  void build() {     for (int i = n - 1; i > 0; i--)         t[i] = t[2 * i] ^ t[2 * i + 1]; }   void modify(int p,int value){ 	for (t[p+=n]=value; p > 1 ; p>>=1) 		t[p>>1] = *(t+p) ^ *(t+(p^1)); }  int query(int l,int r){ 	int res = 0; 	for (l+=n,r+=n; l<r;l>>=1,r>>=1) 	{ 		if (l&1) 		{ 			res = res ^ t[l] ; 			l++; 		} 		if (r&1) 		{ 			r--; 			res = res ^ t[r]; 		} 	} 	return res;  }    int main() { 	// READ 	int q,code,pos; 	char d,c;  	scanf("%d\n",&n);  	for (int i = 0; i < n; ++i)     { 		scanf("%c",&d);         t[i + n] = 1 << (d - 'a');     }  	build();  	scanf("%d",&q);  	for (int i = 0; i < q; ++i) 	{ 		scanf("%d",&code);  		if (code==1) 		{ 			scanf("%d %c\n",&pos,&c); 			modify(pos-1,1 << (c - 'a')); 		} 		else 		{ 			int l,r;  			scanf("%d %d",&l,&r);  			int sol = query(l - 1, r); 			// printf("%d\n",sol);              if (__builtin_popcount(sol) > 1)                 printf("NO\n");             else                 printf("YES\n"); 		} 	}  	return 0; } 
#include<iostream> #include<algorithm> typedef long long ll; using namespace std;  string str[] = {"0000","0001","0010","0011","0100","0101","0110","0111","1000","1001","1010","1011","1100","1101","1110","1111"};  int TODEX(char ch){     if(ch>='0' && ch<='9')         return ch-'0';     return ch-'A'+10; }  string adding(string s1, string s2){     int carry = 0;     string ans = "";     for(int i=s1.length()-1;i>=0;i--){         int tmp = (s1[i]-'0')+(s2[i]-'0')+carry;         //cout << tmp << endl;         carry = tmp/2;         tmp = tmp%2;         char ch = tmp+'0';         ans += ch;     }     reverse(ans.begin(),ans.end());     return ans; }  int main(){     int n;     cin >> n;     string s;     cin >> s;     string s1 = "", s2 = "";     for(int i=0;i<n;i++){         int tmp = TODEX(s[i]);         s1 += str[tmp][0];         s1 += str[tmp][1];         s2 += str[tmp][2];         s2 += str[tmp][3];     }     string ans = adding(s1,s2);   //  cout << s1 << " " << s2 << endl;     cout << ans << endl;     return 0; }
#include<cstdio> #include<iostream> #include<algorithm> const int mod=1000003; using namespace std; int R,C,M,a[1010][1010],b[1010][1010];  int getchar_unlocked()  {return getchar();} inline void fastRead_int(int &x) { 	register int ch = getchar_unlocked(); 	x = 0; 	for(; ((ch<48 || ch>57) && ch != '-'); ch = getchar_unlocked()); 	for(; ch>47 && ch<58 ; ch = getchar_unlocked()) { 		x = (x<<1) + (x<<3) + ch- 48; 	} }  int get(int x,int y){ 	int sum=0; 	if(x>1) sum+=b[x-1][y]; 	if(y>1) sum+=b[x][y-1]; 	if(y>1 and x>1) sum+=b[x-1][y-1]; 	return sum%mod; }  int main(){ 	int t,i,j,k,xx,yy; 	scanf("%d",&t); 	while(t--){ 		scanf("%d",&R); scanf("%d",&C); scanf("%d",&M); 		for(i=1;i<=R;i++) for(j=1;j<=C;j++){ a[i][j]=0; b[i][j]=0; } 		for(i=0;i<M;i++){ 			scanf("%d",&xx); scanf("%d",&yy); 			a[xx][yy]=1; 		} 		//for(i=1;i<=R;i++) {for(j=1;j<=C;j++){ cout<< a[i][j]<<","<<b[i][j]<<"\t"; } cout<<endl; } 		b[1][1]=1; 		for(int su=3;su<=R+C;su++){ 			for(j=1,i=su-j;i>0;i--,j++){ 				if(i>R or j>C) continue; 				if(a[i][j]==1) b[i][j]=0; 				else { b[i][j]=get(i,j); } 			} 		} 		printf("%d\n",b[R][C]);  	} 	return 0; } 
#include<iostream> using namespace std;   int main() { int t; cin>>t; while(t--) { int n=0,q=0; cin>>n>>q; int arr[n][n]; for(int i=0;i<n;i++) { for(int j=0;j<n;j++) cin>>arr[i][j]; } while(q--) { int search=0; cin>>search; int i=0; for(i=0;i<n;i++) { for(int j=0;j<n;j++) { if(arr[i][j]==search) { cout<<i+1<<" "<<j+1<<endl; i=n+1;break; } } } if(i==n) cout<<"-1"<<endl; } cout<<endl; } return 0; }
 #include <bits/stdc++.h> using namespace std; #define MOD 1000000007 #define pii pair<int, int> #define pll pair<long long, long long> #define vi  vector<int> #define pb  push_back #define mp  make_pair #define ALL(x) x.begin(),x.end() #define M(a,x) memset(a,x,sizeof(a)) #define sci(x) scanf("%d",&x); #define scl(x) scanf("%lld",&x); #define scs(x) scanf("%s",x); #define print(x) printf("%d",x); #define nl printf("\n") #define printl(x) printf("%lld",x) #define F(i,a,n) for(int i=a;i<n;i++) #define INF 100000000000000000LL #define LL long long #define fr first #define se second int a[105]; int fib[50]; int dp[10005];  int grundy(int n) {     if(n==0) { 	return 0;     }     if(dp[n]!=-1) { 	return dp[n];     }     int mex[60]={0};     F(i,0,20) { 	if(fib[i]<=n) { 	    mex[grundy(n-fib[i])]=1; 	}     }     int cnt=0;     while(mex[cnt]) cnt++;     return dp[n]=cnt; } int ans[10005][2];  int solve(int n,int win) {     if(n==0) return 0;     if(ans[n][win]!=-1) { 	return ans[n][win];     }     int ret;     if(win) { 	ret = MOD; 	F(i,0,20) { 	    if(fib[i]<=n) { 		int nx = n-fib[i]; 		if(grundy(nx)==0) ret = min(ret,1+solve(nx,1-win)); 	    } 	}     }     else { 	ret = 0; 	F(i,0,20) { 	    if(fib[i]<=n) { 		int nx = n-fib[i]; 		ret=max(ret,1+solve(nx,1-win)); 	    } 	}     }     return ans[n][win]=ret; } vector<pii> v;  int main() {     M(dp,-1);     M(ans,-1);     fib[0]=1;     fib[1]=1;     for(int i=2;i<=20;i++) { 	fib[i]=fib[i-1]+fib[i-2];     }     int t;sci(t);     while(t--) { 	v.clear(); 	int n;sci(n); 	F(i,0,n) { 	    sci(a[i]); 	    int x=grundy(a[i]); 	    x=min(x,1); 	    v.pb(mp(solve(a[i],x),1-x)); 	} 	sort(v.begin(),v.end()); 	if(v[0].se==0) { 	    printf("Alice %d\n",v[0].fr); 	} 	else { 	    printf("Bob %d\n",v[0].fr); 	}     }     return 0; } 
#include <bits/stdc++.h> #define _ ios_base::sync_with_stdio(false);cin.tie(0); using namespace std; #define pb push_back #define pob pop_back #define pf push_front #define pof pop_front #define mp make_pair #define all(a) a.begin(),a.end() #define bitcnt(x) __builtin_popcountll(x) #define MOD 1000000007 #define total 5000005 #define Me 1000000000001 #define NIL 0 #define MAXN 100005 #define EPS 1e-5 #define INF (1<<28) #define pi 3.141593 typedef unsigned long long int uint64; typedef long long int int64;  int main(){ 	int t,sec; 	string A; 	cin>>t; 	while(t--) 	{ 		cin>>A; 		int h=(A[0]-'0')*10 + (A[1]-'0'); 		int m=(A[2]-'0')*10 + (A[3]-'0'); 		int s; 		cin>>s; 		int m1=m+(s/60),m2=m+(s/60); 		if(s%60) 			m1++; 		int h1=h,h2=h; 		if(m1>=60) 		{ 			h1+=(m1/60); 			h1%=24; 			m1%=60; 		} 		if(m2>=60) 		{ 			h2+=(m2/60); 			h2%=24; 			m2%=60; 		} 		pair <int,int> t1(h1,m1), t2(h2,m2); 		pair <int,int> ft=max(t1,t2); 		if(ft.first>=10) 			cout<<ft.first; 		else 			cout<<"0"<<ft.first; 		if(ft.second>=10) 			cout<<ft.second<<"\n"; 		else 			cout<<"0"<<ft.second<<"\n"; 	} 	return 0; }
#include <bits/stdc++.h> #define _ ios_base::sync_with_stdio(false);cin.tie(0); using namespace std; #define pb push_back #define pob pop_back #define pf push_front #define pof pop_front #define mp make_pair #define all(a) a.begin(),a.end() #define bitcnt(x) __builtin_popcountll(x) #define MOD 1000000007 #define total 5000005 #define Me 1000000000001 #define NIL 0 #define MAXN 100005 #define EPS 1e-5 #define INF (1<<28) #define pi 3.141593 typedef unsigned long long int uint64; typedef long long int int64; int n,c,sum; int a[111]; bool used[111]; int dp[101][10001]; bool go(int idx,int cur){ 	if(cur>c){ 		dp[idx][cur]=0; 		return false; 	} 	if(cur<=c){ 		int tmp=sum-cur; 		if(tmp<=c){ 			dp[idx][cur]=1; 			return true; 		} 	} 	if(idx==n){ 		dp[idx][cur]=0; 		return false; 	} 	 	if(dp[idx][cur]!=-1){ 		if(dp[idx][cur]==1) 		return true; 		return false; 	} 	used[idx]=true; 	bool ret=go(idx+1,cur+a[idx]); 	if(ret){ 		dp[idx][cur]=ret; 		return ret; 	} 	used[idx]=false; 	ret=go(idx+1,cur); 	dp[idx][cur]=ret; 	return ret; }  int main(){ 	int t,i; 	cin>>t; 	while(t--){ 		memset(dp,-1,sizeof(dp)); 		cin>>n>>c; 		sum=0; 		 		for(i=0;i<n;i++){ 		cin>>a[i]; 		sum+=a[i];} 		 		sort(a,a+n); 		 		memset(used,false,sizeof(used)); 		if(go(0,0)){ 			printf("YES\n"); 			for(i=0;i<n;i++){ 				if(used[i]) 				printf("%d ",a[i]); 			} 			printf("\n"); 			for(i=0;i<n;i++){ 				if(!used[i]) 				printf("%d ",a[i]); 			} 			printf("\n"); 		} 		else{ 			printf("NO\n"); 		} 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; # define mod 100000000 struct job {     long long start;     long long finish; }; job a[1000001]; long long dp[1000001]; bool cmp(job s1,job s2) {     return (s1.finish<s2.finish); } int bi(int low,int high,long long va) {     while(low<=high)     {         int mid=(low+high)/2;         if(a[mid].finish<va)         {             if(a[mid+1].finish<va)                 low=mid+1;             else                 return mid;         }         else             high=mid-1;     }     return -1; } void cal(long long n) {     dp[0]=1;     int i,l,j;     for(i=1;i<n;i++)     {         //dp[i]=0;         int l=bi(0,i,a[i].start);         dp[i]=1;         if(l!=-1)             {                 //cout<<2;                 long long ma=INT_MIN;                 for(j=0;j<=l;j++)                 {                     if(dp[j]>ma)                     ma=dp[j];                 }                 dp[i]=dp[i]+ma;             }     }    // cout<<dp[n-1];   //  dp[n-1]=(dp[n-1]+mod)%mod;    // int k=log(dp[n-1]);    // cout<<k;   /* long long f=dp[n-1];    int co=0;    while(f>0)    {        f=f/10;        co++;    }     for(i=0;i<8-co;i++)         cout<<0;     cout<<dp[n-1]<<"\n";*/     //cout<<1;     cout<<*max_element(dp,dp+n)<<"\n"; } int main() {     long long n,i,j,k,t;     cin>>t;     while(t--)     {         cin>>n;             for(i=0;i<n;i++)             {                 cin>>a[i].start;                 cin>>a[i].finish;             }             sort(a,a+n,cmp);             cal(n);     } }  
#include<bits/stdc++.h> using namespace std;  #define FORI(i,b,e) for(int i=b; i<=e; i++) #define FORD(i,b,e) for(int i=b; i>=e; i--) #define FILL(a, v) memset(a, v, sizeof(a)) #define FOREACH(it,c) for(__typeof((c).begin()) it=((c).begin());it!=(c).end();++it) #define mp make_pair #define mod 1000000007 #define INF 1000000001 #define sz 100001  typedef long long LL; typedef vector<int> VI; typedef vector<LL> VLL; typedef pair<int, int> PII; typedef map<int, int> MII; typedef set<int> SI;  //**************************************** <global variable> ********************************* int tree[4*sz+1]; int arr[sz+1], n; //******************************************* <main code> ************************************ void update(int node, int a, int b, int i, int j, int val) {     if(a>b || a>j || b<i)         return ;     if(a==b)     {         arr[a]+=val;         tree[node]=arr[a];         return ;     }     update(2*node, a, (a+b)/2, i, j, val);     update(2*node+1, 1+(a+b)/2, b, i, j, val);     tree[node]=tree[2*node]+tree[2*node+1]; } int query(int node, int a, int b, int i, int j) {     if(a>b || a>j || b<i)         return 0;     if(a>=i && b<=j)     {         return tree[node];     }     int left=query(2*node, a, (a+b)/2, i, j);     int right=query(2*node+1, 1+(a+b)/2, b, i, j);     return (left+right); } void solve() {     int q;     scanf("%d", &q);     if(q==0)     {         int x, y, val;         scanf("%d %d %d", &x, &y, &val);         update(1, 0, n-1, x-1, y-1, val);     }     else     {         int x, y;         scanf("%d %d", &x, &y);         int ans=query(1, 0, n-1, x-1, y-1);         printf("%d\n", ans);     } }  int main() {     int tc=1;     scanf("%d", &tc);     while(tc--)     {         int c;         scanf("%d %d", &n, &c);         while(c--)         {             solve();         }     } }   
#include<iostream> #include<algorithm> #include<string.h> using namespace std; int main() {     char s[100];     int flag=0,count=1,countalpha=1;     cin>>s;     sort(s,s+strlen(s));     //cout<<s<<endl;     if(strlen(s)==1)     {         cout<<"YES";         return 0;     }     int i=1;     while(s[i]!='\0')     {          if(s[i]==s[i-1])         {             count++;         }         else         {             if(flag==1 && count%2==1)             {                 cout<<"NO";                 return 0;             }             if(count%2==1)                 flag=1;             countalpha++;             count=1;         }         i++;     }     if(countalpha==1)     {         cout<<"YES";         return 0;     }     cout<<"YES"; } 
#include<bits/stdc++.h> #define pb push_back #define mp make_pair using namespace std; inline int scan(){     char c = getchar_unlocked();     int x = 0;     while(c<'0'||c>'9'){         c=getchar_unlocked();     }     while(c>='0'&&c<='9'){         x=(x<<1)+(x<<3)+c-'0';         c=getchar_unlocked();     }     return x; } const int N = 100001; const int SQN = 350; int freq[SQN][N]={0}; long long val[SQN]={0}; int start[SQN]; int finish[SQN]; int n,sqn,m; int timer=0; int treestart[N]; int treeend[N]; int rev[N]; list<int> v[N]; int level[N]={0}; int lookup[N]; long long sum[N]={0}; void dfs(int node,int parent){     level[node]=level[parent]+1;     treestart[node]=++timer;     rev[timer]=node;     for(list<int>::iterator it = v[node].begin();it!=v[node].end();++it){         if(*it!=parent)             dfs(*it,node);     }     treeend[node]=timer; } int main(){     n=scan(),m=scan();     for(int i=1;i<n;++i){         int a=scan(),b=scan();         v[a].pb(b);         v[b].pb(a);     }     dfs(1,0);     int sqn = sqrt(n);     int cur=1;     for(int i=1;i<=n;){         int j=i;         start[cur]=i;         while(j<i+sqn&&j<=n){             freq[cur][level[rev[j]]]++;             j++;             lookup[j-1]=cur;         }         i=j;         finish[cur]=j-1;         ++cur;     }     while(m--){         int type=scan();         if(type==1){             int levl = scan();             long long vall = scan();             for(int i=1;i<cur;++i){                 val[i]+=1LL*freq[i][levl+1]*vall;             }             sum[levl+1]+=vall;         }         else{             int node = scan();             int x=lookup[treestart[node]];             int y=lookup[treeend[node]];             long long res=0;             for(int i=x;i<=y;++i){                 if(start[i]>=treestart[node]&&finish[i]<=treeend[node]){                     res+=val[i];                 }                 else if(start[i]<treestart[node]){                     for(int j=treestart[node];j<=min(treeend[node],finish[i]);++j){                         res+=sum[level[rev[j]]];                     }                 }                 else{                     for(int j= max(start[i],treestart[node]);j<=treeend[node];++j){                         res+=sum[level[rev[j]]];                     }                 }             }             printf("%lld\n",res);         }     } }
#include<iostream> #include<string> using namespace std; int main() {     string s;     getline(cin,s);     char r;     cin>>r;     int c=0;     for(int i=0;i<s.size();i++)         if(s[i]==r)         c++;         cout<<c<<endl;         return 0; } 
#include<iostream> using namespace std; int main() {     int n; cin>>n;     for(int i=1;i<=n;i++)     {         for(int j=1;j<=n-i;j++)         cout<<" ";         for(int j=i;j>=1;j--)         cout<<j;         for(int j=2;j<=i;j++)         cout<<j;         cout<<endl;     }     int k=1;           for(int i=(n-1);i>=1;i--)           {               for(int j=1;j<=k;j++)                cout<<" ";               for(int j=i;j>=1;j--)                cout<<j;               for(int j=2;j<=i;j++)                cout<<j;               cout<<endl;               k++;           }     return 0; }
#include<cstdio> #include<cmath> //#include<conio.h> #include<iostream> using namespace std; int main() {     int n;     cin>>n;     cout<<cos(n*3.14/180);     //getch(); } 
// The question seems to be misleading // Given that N x M squres, and a Queen travels along these squares // However, from the sample answers travelling on the edges of matrix were expected  #include <iostream> using namespace std;  int R, C; int paths; void CountMatrixPaths(int i = 0, int j = 0) {     if( i == R && j == C ) {         ++paths;         return;     }      if( i > R || j > C )         return;      CountMatrixPaths(i+1, j); // right     CountMatrixPaths(i, j+1); // down }  int main() {     int tests;     cin >> tests;      for(int i = 0; i < tests; i++) {         cin >> C;         cin >> R;         CountMatrixPaths();         cout << paths << endl;         paths = 0;     }      return 0; } 
#include<stdio.h> using namespace std; int main() { 	int x,i,j,k,t,n,a[25],b[20],c=0; 	scanf("%d",&t); 	for(x=0;x<t;x++) 	{ 		scanf("%d",&n); 		for(i=0;i<n;i++) 			scanf("%d",&b[i]); 		for(i=0;i<n-2;i++) 		      for(j=i+1;j<n-1;j++)                          		for(k=j+1;k<n;k++) 			         if((b[i]+b[j]>b[k])&&(b[i]+b[k]>b[j])&&(b[j]+b[k]>b[i])) 				   c++;	 		a[x]=c; 		c=0; 	} 	for(i=0;i<t;i++) 		printf("%d\n",a[i]); }
#include<iostream> #include<stdio.h> using namespace std;  int main()  {      int t;      scanf("%d",&t);      while(t--)      {          int x1,x2,x3,x4,y1,y2,y3,y4;          scanf("%d %d %d %d",&y1,&y2,&y3,&y4);          x2=y1+y4-y3;          x3=y2-y1-y4;          x4=y1-(x2+x3);          x1=x4-x2-y3;          printf("%d %d %d %d\n",x1,x2,x3,x4);      }      return(0);  } 
#include <bits/stdc++.h> using namespace std; typedef long long int ll; #define sl(l) scanf("%lld",&l)   struct point { 	ll x,y; }v[100001];         int main() { 	ll t; 	sl(t); 	while(t--) 	{ 		ll a=0,n; 			sl(n); 			for(ll i=0;i<n;i++)sl(v[i].x); 			for(ll i=0;i<n;i++)sl(v[i].y); 			for(ll i=0;i<n;i++)	 			{ 					a+=(v[i].x*v[(i+1)%n].y); 					a-=(v[(i+1)%n].x*v[i].y); 			}  		a = abs(a); 		 		printf("%.1lf\n",(float)(a)/2);   	} 	return 0; } 
#include <bits/stdc++.h>  using namespace std;  int A[102]; int B[102]; int vis[102];  int main() {     int t;     cin >> t;     while ( t-- ) {         int n;         cin >> n;         for ( int i = 0; i < n; i++ ) {             cin >> A[i];             vis[i] = 0;         }         for ( int i = 0; i < n; i++ ) cin >> B[i];         sort(A, A+n);         sort(B, B+n);         int ans = 0;         for ( int i = 0; i < n; i++ ) {             for ( int j = n-1; j >= 0; j-- ) {                 if ( vis[j] ) continue;                 if ( A[i] > B[j] ) {                     vis[j] = 1;                     ans++;                     break;                 }             }         }         cout << ans << endl;     }     return 0; } 
#include<iostream> #include<stdio.h> #include<algorithm> #include<stdlib.h> using namespace std;  struct jobs{ int start_t; int finish_t; }; int compare(jobs a,jobs b) {     return (a.finish_t < b.finish_t); }    int main() {     int t,n,count,latest_finish;     cin>>t;     while(t--)     {         count=1;         cin>>n;         jobs a[n];         for(int i=0;i<n;i++)             cin>>a[i].start_t;         for(int i=0;i<n;i++)             cin>>a[i].finish_t;         sort(a,a+n,compare);   /*      for(int i=0;i<n;i++)         {             cout<<a[i].start_t<<" "<<a[i].finish_t<<endl;         } */        latest_finish = a[0].finish_t;         for(int i=1;i<n;i++)         {             if(a[i].start_t >= latest_finish)             {                 count++;                 latest_finish = a[i].finish_t;             }         }         cout<<count<<endl;     }     return 0; }
#include<bits/stdc++.h> using namespace std; int main(){ 	int n,k; cin>>n>>k; 	int a[n+1]; 	int lol=0; 	for(int i=1; i<=n; i++){ 		cin>>a[i]; 		 	}  	int ll=INT_MIN; 	int sum=0,val=0,ans=INT_MIN; 	for(int i=1; i<=n; i++){ 		if(i<k) sum+=a[i]; 		else if(i==k){ 			sum+=a[i]; 			ll=sum; 			val=sum; 			ans=sum;	 		} 		else{ 			sum=sum+a[i]-a[i-k]; 			val=max(sum,val+a[i]); 			ans=max(ans,val);	 		}		 	} 	cout<<ans<<endl; }
    #include<bits/stdc++.h>           using namespace std;           #define ll long long int     #define T ll t; cin>>t ; while(t--)     #define fin freopen("i1.txt","r",stdin)     #define fout freopen("o1.txt","w",stdout)     #define fastio ios_base::sync_with_stdio(false); cin.tie(0)     #define pf(n) cout<<n<<endl;     #define pb(x) push_back(x)           int main(){               T {             string s;             ll a,b;                   cin>>s>>a>>b;                   ll no=0;             ll cnt=0;             ll pre;             ll n=s.length();             no=s[0]-'0';             if(no>b){                 cout<<"-1"<<endl;                 continue;             }                   for(ll i=1;i<n;i++){                 pre=no;                 no=10*no + (s[i]-'0');                       if(no<b) {                     continue;                 }                 else if(no>b) {                     if(pre>=a && pre<=b){                         cnt++;                         no=s[i]-'0';                     }else {                         cnt=-1;                         break;                     }                 }             }                   cout<<cnt<<endl;               }               return 0;     }      
#include <iostream> #include <cstdio> #include <string.h> using namespace std;  int main() {     short int flag[100000]={0},count=-1;     int n,co[100000][2],a,b,countx,county,bigx,bigy,x,y;     char s[6];     scanf("%d",&n);     while(n--)     {         cin>>s;         scanf("%d%d",&a,&b);         if(strcmp(s,"add")==0)         {             count+=1;             co[count][0]=a;             co[count][1]=b;             flag[count]=1;         }         if(strcmp(s,"erase")==0)         {             for(int i=0;i<count+1;i++)             {                 if(co[i][0]==a&&co[i][1]==b){                 flag[i]=0;                 break;}             }         }         if(strcmp(s,"get")==0)         {int i=0;         int t=0;         x=0,y=0;         countx=0,county=0;         bigx=1000000000,bigy=1000000000;             while(i<count+1)             {                 if(co[i][0]>a&&co[i][0]<bigx&&flag[i]==1){                     bigx=co[i][0];                     y=co[i][1];                     t=1;}                 i+=1;             }if(t==1)             countx+=1;             while(i<count+1)             {                 if(co[i][0]>a&&co[i][0]==bigx&&flag[i]==1)                 countx+=1;             }              if(countx>1||countx==0)             {int i=0;                 while(i<count+1)             {                 if(co[i][1]>b&&co[i][1]<bigy&&flag[i]==1){                     bigy=co[i][1];                     x=co[i][0];}                 i+=1;             }if(i<count+1)             county+=1;             }             if(countx==0&&county==0)             printf("-1\n");             else if(countx==1)             printf("%d %d\n",bigx,y);             else             printf("%d %d\n",x,bigy);         }     }     return 0; } 
#include <iostream> using namespace std;  int n;  int main() { 	// your code goes here 	 	cin >> n; 	 	int p = n; 	int count = 0; 	while(p>0){ 		int q = p%2; 		p /= 2; 		if(q==1) 			count++; 	} 	 	int r = 1<<count;  	r = n+1-r; 	cout << r << endl; 	 	return 0; }
#include<iostream> #include<cmath> #include<set> #include<vector> #include<list> #include<map> #include<algorithm> #include <iomanip>     using namespace std; #define FOR(i,a,b) for(int i=a;i<b;i++)     #ifndef ONLINE_JUDGE #include <time.h> #endif   int main(){   #ifndef ONLINE_JUDGE 	freopen("input.txt","r",stdin); 	clock_t start = clock(); #endif     	//0-North,-1 East,2-South,3West 	int T; 	scanf("%d\n",&T); 	FOR(tT,0,T){ 		int D=0; 		int Y=0,X=0,Z; 		char C; 		scanf("%d",&Y); 		scanf("%c",&C);   		while(1){ 			scanf("%c",&C);		 			if(C=='L' || C=='R'){ 				char cj=getchar(); 				if(cj!=' ')break; 				scanf("%d",&Z);   				if(C=='R')D=(D+1)%4; 				else D=(D+4-1)%4; 				switch(D){ 				case 0:Y+=Z;break; 				case 1:X+=Z;break; 				case 2:Y-=Z;break; 				case 3:X-=Z;break; 				}   			}else break; 			scanf("%c",&C); 			if(C!=' ')break; 		} 		double t=sqrt((double)(X*X+Y*Y));   		char s[200]; 		sprintf(s,"%.3f",t); 		int j=0; 		for(j=0;s[j]!='.';j++)cout<<s[j]; 		cout<<'.'<<s[j+1];   		if(Y>0)printf("N");else if(Y<0)printf("S"); 		if(X>0)printf("E");else if(X<0)printf("W"); 		printf("\n"); 	}     #ifndef ONLINE_JUDGE	 	printf("Time elapsed: %f\n", ((double)clock() - start) / CLOCKS_PER_SEC); #endif 	return 0; } 
#include<stdio.h> int main() {     int test_cases,n,a,b;     scanf("%d",&test_cases);     long long int ans;     for(int i=0;i<test_cases;i++)     {         ans=0;         scanf("%d%d%d",&n,&a,&b);         for(int j=1;j<n;j++)         {             for(int m=((a*(j-1))/b)+1;m<=((a*j)/b);m++)                 ans=ans+m*(((n-j+1)*(n-j))/2);         }         printf("%lld\n",ans);     } } 
 #include<iostream> using namespace std; int main() {     int t,i;     cin>>t;     while(t--)     {               long long a,n1,c1,n2,c2,n,t1,t2,v,k,flag=0;               long double d,e;               cin>>a;               cin>>c1;               cin>>n1;               cin>>c2;               cin>>n2;               d=(long double)n1/c1;               e=(long double)n2/c2;               if(d>e)               {                      n=a/n1;                      for(i=n;i>0;i--)                      {                      k=i*n1;                      t1=i;                      v=a-k;                      t2=v/n2;                      if(v%n2==0)                      {                                 flag=1;                                 break;                      }                      }               }               else               {                      n=a/n2;                      for(i=n;i>0;i--)                      {                      k=i*n2;                      t2=i;                      v=a-k;                      t1=v/n1;                      if(v%n1==0)                      {                                 flag=1;                                 break;                      }                      }               }               if(flag==1)               cout<<t1<<" "<<t2<<" "<<t1*c1 + t2*c2<<endl;               else               cout<<"0 0 0\n";     }     return 0; } 
#include<iostream> using namespace std; long int n=0,m=0;    int chek(int dig) {     if(dig==0) 	return 1;     else if(m%dig==0)     	return 1;     else return 0; }       int main() {     cin >> n;     m=n;     int check=0,digit=0;     while(n!=0)     { 	    digit=n%10; 	    check=chek(digit); 	    if(check==0) 	    {     		cout << "Invalid\n";     		break;     	    }     	    n=n/10;     }     if(check)     	cout << "Valid\n";     return 0; } 
#include<iostream> #include<cstdlib> #include<cmath> using namespace std;  int main(void) { 	int N, M, n;  	N = M;  	while (scanf("%d", &n) != EOF) 	{ 		N=n%100; 		M=n/100;  		int temp1 = sqrt(N); 		temp1 = sqrt(temp1);  		int temp2 = sqrt(M); 		temp2 = sqrt(temp2);  		temp1 = temp1 * temp1; 		temp1 = temp1 * temp1;  		temp2 = temp2 * temp2; 		temp2 = temp2 * temp2;  		if (temp1 == N || temp2 == M) 		{ 			printf("1\n"); 		} 		else 		{ 			printf("-1\n"); 		} 	}  	return 0; }
#include <stdio.h> #include <iostream> #define ll unsigned long long int ll det(ll); bool fin(ll); using std::cout; int main(){     ll T=0;     bool ans=false;     ll N=0;          scanf("%lld",&T);          while(T--)     {       scanf("%lld",&N);       ans = fin(det(N));       if(ans)         cout << "1\n";       else         cout << "-1\n";     }            return 0;    // system("pause"); }  ll det(ll a){    ll count = 0;    for(int i=2;i<=a/2;i++)     if(a%i==0)// && (a%i)%2!=0)       count++;     return count; }  bool fin(ll x){     if(x%2 != 0 && x>4)       return true;     else       return false; }      
#include<stdio.h> int main() {  long n;  scanf("%ld",&n);  if(n<=100000&&n>=1)  {   int t=n,sum=0;   int j=n/1;   sum-=n;   for(int i=1;i<j;i++)   {    if(n%i==0)    {     sum+=i+n/i;     j=n/i;    }   }   if(sum==t)    printf("1\n");   else     printf("-1\n");  } } 
#include<iostream> using namespace std;  int main() {  int l,u,*ans;  cin>>l>>u;  if(l<=10000&&l>=1&&u<=10000&&u>=1)  {   ans=new int[u-l+2];   int k=0;   for(int i=l;i<=u;i++)   {    int t=i;    int sum=0;    while(t!=0)    {     sum+=t%10; 	t/=10;    }    if(i%sum==0)    {     ans[k]=i; 	k++;    }   }   int max=0,fl=1;   for(int i=0;i<k-1;i++)   {    if((ans[i]+1)==ans[i+1])     fl++;    else if(fl>max)    {     max=fl; 	fl=1;    }    else     {     fl=1;    }   }   if(fl>=max)    max=fl;   cout<<max<<endl;  } } 
#include <stdio.h> #define MOD 1000000007 #define LL long long  LL Pow(int n) { 	if(n <= 0) return 1; 	LL x = Pow(n/2) % MOD; 	LL k = (long long) (x*x)%MOD; 	if(n%2) k = (2*k)%MOD; 	return k%MOD; } int main() { 	int t,n; 	scanf("%d",&t); 	while(t--) { 		scanf("%d",&n); 		printf("%lld\n",Pow(n)); 	} 	return 0; }
//Author : pakhandi // using namespace std;  #include<iostream> #include<cstdio> #include<cstdlib> #include<algorithm> #include<cmath> #include<cstring>  #define wl(n) while(n--) #define fl(i,a,b) for(i=a; i<b; i++) #define rev(i,a,b) for(i=a; i>=b; i--) #define print(n) printf("%d\n", n) #define scan(n) scanf("%d", &n) #define MOD 1000000007 #define ll long long int  char str1[505], operations[505];  int main() { 	int i, j, cases; 	int a, b, len1, count; 	long long int ans; 	while(1) 	{ 		scanf("%s", str1); 		if(str1[0]=='0' && str1[1]=='\0') 			break; 		len1=strlen(str1); 		count=0; 		fl(i,0,len1) 		{ 			if(str1[i]=='+' || str1[i]=='-' || str1[i]=='*' || str1[i]=='/') 			{ 				operations[count++]=str1[i]; 			} 		} 		//count++; 		scanf("%lld", &ans); 		ans=ans*1LL; 		fl(i,0,count) 		{ 			scan(a); 			if(operations[i]=='+') 				ans=(ans+a)*1LL; 			else if(operations[i]=='-') 				ans=(ans-a)*1LL; 			else if(operations[i]=='*') 				ans=(ans*a)*1LL; 			else 				ans=(ans/a)*1LL; 			 			ans=(ans%MOD)*1LL; 		} 		print(ans); 	} 	return 0; } 
//header files  #include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<map> #include<cmath> #include<cstring> using namespace std;  //end of header files   //definitions  #define MOD 1000000007 #define llu long long unsigned #define lld long long #define ld long #define BSIZE 20  //end of definitions   //fast input  int scan_d()    {int ip=getc(stdin),ret=0;for(;ip<'0'||ip>'9';ip=getc(stdin));for(;ip>='0'&&ip<='9';ip=getc(stdin))ret=ret*10+ip-'0';return ret;} long scan_ld()    {long ip=getc(stdin),ret=0;for(;ip<'0'||ip>'9';ip=getc(stdin));for(;ip>='0'&&ip<='9';ip=getc(stdin))ret=ret*10+ip-'0';return ret;} long long scan_lld()    {long long ip=getc(stdin),ret=0;for(;ip<'0'||ip>'9';ip=getc(stdin));for(;ip>='0'&&ip<='9';ip=getc(stdin))ret=ret*10+ip-'0';return ret;} long long unsigned scan_llu()    {long long unsigned ip=getc(stdin),ret=0;for(;ip<'0'||ip>'9';ip=getc(stdin));for(;ip>='0'&&ip<='9';ip=getc(stdin))ret=ret*10+ip-'0';return ret;}  //end of fast input   //fast output   void print_d(int n){char op[BSIZE];int pt=BSIZE-1;while(true){op[pt--]='0'+(n%10);n=n/10;if(n==0)break;}while(pt<BSIZE-1)putchar(op[++pt]);} void println_d(int n){char op[BSIZE];int pt=BSIZE-1;while(true){op[pt--]='0'+(n%10);n=n/10;if(n==0)break;}while(pt<BSIZE-1)putchar(op[++pt]);putchar('\n');} void print_ld(long int n){char op[BSIZE];int pt=BSIZE-1;while(true){op[pt--]='0'+(n%10);n=n/10;if(n==0)break;}while(pt<BSIZE-1)putchar(op[++pt]);} void println_ld(long int n){char op[BSIZE];int pt=BSIZE-1;while(true){op[pt--]='0'+(n%10);n=n/10;if(n==0)break;}while(pt<BSIZE-1)putchar(op[++pt]);putchar('\n');} void print_lld(long long int n){char op[BSIZE];int pt=BSIZE-1;while(true){op[pt--]='0'+(n%10);n=n/10;if(n==0)break;}while(pt<BSIZE-1)putchar(op[++pt]);} void println_lld(long long int n){char op[BSIZE];int pt=BSIZE-1;while(true){op[pt--]='0'+(n%10);n=n/10;if(n==0)break;}while(pt<BSIZE-1)putchar(op[++pt]);putchar('\n');} void print_llu(long long unsigned n){char op[BSIZE];int pt=BSIZE-1;while(true){op[pt--]='0'+(n%10);n=n/10;if(n==0)break;}while(pt<BSIZE-1)putchar(op[++pt]);} void println_llu(long long unsigned n){char op[BSIZE];int pt=BSIZE-1;while(true){op[pt--]='0'+(n%10);n=n/10;if(n==0)break;}while(pt<BSIZE-1)putchar(op[++pt]);putchar('\n');}  //end of fast output   //extra functions  //end of extra fnctions   //main  int main() {     int t;     while(scanf("%d",&t)==1)         printf("%d\n",t-1);     return 0; }  //end of main
#include <iostream> #include<cstdio> #include<string.h> #include<ctype.h> using namespace std;  int main() {           int n;    cin>>n;    int k=1;    while(n--)    {      //char str[200];      string str;      for(int i=0;i<14;i++)      getchar();        cin>>str;        int sum=0;        for(int i=0;i<str.length();i++)        sum=sum*10+((int)str[i]-'0');        if(sum>200)        cout<<k<<endl;                                //cout<<str;                             k++;        }         return 0; } 
#include<iostream> #include<math.h> #include<vector> using namespace std;  int * sort(int * A,int size,int level) { 	int i,j,temp,indices[10],count[10],div=pow(10,level); 	for(i=0;i<10;i++) 	{ 		count[i]=0; 		indices[i]=0; 	} 	for(i=0;i<size;i++) 	{ 		count[(A[i]/div)%10]++; 	} 	int **Ax=new int *[10]; 	for(i=0;i<10;i++) 	{ 		Ax[i]=new int[count[i]]; 	} 	for(i=0;i<size;i++) 	{ 		temp=(A[i]/div)%10; 		Ax[temp][indices[temp]]=A[i]; 		indices[temp]++; 	} 	if(level!=0) 	for(i=0;i<10;i++) 	{ 		if(count[i]>1) 		Ax[i]=sort(Ax[i],count[i],level-1); 	} 	temp=0; 	for(i=0;i<10;i++)//ascending 	{ 		for(j=0;j<count[i];j++) 		{ 			A[temp+j]=Ax[i][j]; 		} 		temp+=count[i]; 		delete Ax[i]; 	} 	delete Ax; 	return A;	 }  int main() { 	int i,n,*A; 	cin>>n; 	A=new int[n]; 	for(i=0;i<n;i++)cin>>A[i]; 	A= sort(A,n,9); 	 	for(i=0;i<n;i++)cout<<A[i]<<" "; 	return 0; 	 } 
#include <bits/stdc++.h>  using namespace std;  #define FOR(i,a,b) 	for(int i=(a);i<(b);i++) #define SZ(x) 		((int)(x).size()) #define FORV(i,x)	FOR(i,0,SZ(x)) #define FORD(i,a,b) for(int i=(a);i>=(b);i--) #define MP 			make_pair #define PB 			push_back #define ALL(x) 		x.begin(),x.end() #define ULL 		unsigned long long #define LL 			long long #define mset(x,v) 	memset(x,v,sizeof x) #define F 			first #define S 			second #define si(n) 		scanf("%d",&n) #define sc(n) 		scanf("%c",&n) #define sll(n) 		scanf("%lld",&n) #define sf(n) 		scanf("%f",&n) #define ss(n) 		scanf("%s",n) #define INF (1<<30)+(1<<29)  int n,h[100010],rmq[20][100010]; LL ans=-INF;  int F(int i,int j) { 	int k=log2(j-i+1); 	if(h[rmq[k][i]] < h[rmq[k][j-(1<<k)+1]]) { 		ans=max(ans,(LL)((j-i+1)*h[rmq[k][i]])); 		return rmq[k][i]; 	} 	else 	{ 		ans=max(ans,(LL)((j-i+1)*h[rmq[k][j-(1<<k)+1]])); 		return rmq[k][j-(1<<k)+1]; 	} }  void solve(int i,int j) { 	int q=F(i,j); 	if(i<j) 	{ 		solve(i,q-1); 		solve(q+1,j); 	} }  int main() { 	si(n); 	FOR(i,0,n)  	{ 	 	si(h[i]);  		rmq[0][i]=i; 	} 	for(int i=1;(1<<i)<=n;i++) 	{ 		for(int j=0;j+(1<<i)-1<n;j++) 		{ 			if(h[rmq[i-1][j]]<=h[rmq[i-1][j+(1<<(i-1))]]) 				rmq[i][j]=rmq[i-1][j]; 			else rmq[i][j]=rmq[i-1][j+(1<<(i-1))]; 		} 	} 	solve(0,n-1); 	cout<<ans<<endl; 	return 0; } 
#include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<cmath> #include<vector> using namespace std; int main() {   std:ios_base::sync_with_stdio(false);   int t,n,m,x,y,i,j,ans;   cin>>t;   while(t--)   { ans=0;   	cin>>n>>m;   	int a[n+1];   	for(i=1;i<=n;i++)      cin>>a[i]; 	for(i=0;i<m;i++)   	{   	  	cin>>x>>y;   	  	if(a[x]<a[y])   	  	ans+=a[x];   	  	else   	  	ans+=a[y];   	}   	cout<<ans<<"\n";   }   return 0; }
#include <bits/stdc++.h> #define lli long long int #define M 1000000007  using namespace std;  void swap(int *a, int *b) {     int t = *a;     *a = *b;     *b = t; }  void f(lli A[], int n) {     lli mx = A[n - 1], d = -1;     for (int i = n - 2; i >= 0; i--) {         if (A[i] > mx) {             mx = A[i];         } else {             if (mx - A[i] > d) {                 d = mx - A[i];             }         }     }     cout << d << endl; }  int main() {     int t, n;     lli A[100005];      cin >> t;      while (t--) {         cin >> n;         for (int i = 0; i < n; i++) {             cin >> A[i];         }         f(A, n);     }      return 0; } 
#include<bits/stdc++.h> using namespace std; int main() {     int n,m,p,q;     cin>>n>>m;     int a[n+2];     for(int i=0;i<n+2;i++)         a[i]=0;     for(int i=0;i<m;i++)     {         cin>>p>>q;         a[p]++;         a[q+1]--;     }     for(int i=1;i<=n;i++)         a[i]=a[i]+a[i-1];     sort(a+1,a+n+1);       cout<<a[(n/2)+1]<<endl; } 
#include<bits/stdc++.h> using namespace std; int main() { 	ios::sync_with_stdio(false); 	long int t,l,i,ctr,k; 	char s[100001]; 	char s1[100001]; 	scanf("%ld",&t); 	while(t--) 	{         scanf("%s",s);         l=strlen(s);         for(i=0;i<l;)         {             if(s[i]>='0' && s[i]<='9')             {                 ctr=int(s[i])-'0';                 k=0;                 while(s[++i]>='A' && s[i]<='Z')                     s1[k++]=s[i];                 s1[k]='\0';                 while(ctr--)                     printf("%s",s1);             }             else                 i++;         }         printf("\n"); 	} 	return 0; } 
#include <bits/stdc++.h> using namespace std; #define pb push_back #define mp make_pair #define ft first #define sd second #define mem(a, v) memset(a, v, sizeof(a)) #include<stdio.h> #ifndef ONLINE_JUDGE #define get getchar #else #define get getchar_unlocked #endif typedef long long ll; typedef vector<ll> VI; typedef pair<ll, ll> PII; typedef vector<VI> matrix; const ll mod = 1000000007LL;   matrix adj1(1000010), adj2(1000010); bool visited[1000010]; int ans[1000010]; int sz; stack<int> S; inline int f() { 	int n=0,s=1; 	char p=get(); 	if(p=='-') 		s=-1; 	while((p<'0' || p>'9') && p!=EOF && p!='-') 		p=get(); 	if(p=='-') 		s=-1,p=get(); 	while(p>='0' && p<='9' ) 	{ 		n=(n<<3)+(n<<1)+(p-'0'); 		p=get(); 	} 	return (n*s); } void dfs1(int u) {     visited[u] = true;     for(int i=0; i<adj1[u].size(); i++){         int nxt = adj1[u][i];         if(!visited[nxt])             dfs1(nxt);     }     S.push(u); }   void dfs2(int u) {     visited[u] = true;     ans[u] = 1;     sz++;     for(int i=0; i<adj2[u].size(); i++){         int nxt = adj2[u][i];         if(!visited[nxt])             dfs2(nxt);     } }   int main() {     int n, m,t;     //cin>>t;     t=f();     while(t--)     {     //cin>>n;     n=f();     for(int i=0;i<n;i++)     {     	adj1[i].clear();     	adj2[i].clear();     	visited[i]=0;     }     for(int i=0; i<n; i++){         int x, y;         //cin>>x;         x=f();         if(x!=-1)         {         adj1[i].pb(x);         adj2[x].pb(i);         }     }     for(int i=0; i<n; i++){         if(!visited[i]){             dfs1(i);         }     }     mem(visited, false);     int ans=-1;     while(!S.empty()){         int nxt = S.top();         S.pop();         if(!visited[nxt]){             sz = 0;             dfs2(nxt);             ans=max(ans,sz);            /* if(sz == 1){                 ans[nxt] = 0;             } */         }     }    /* for(int i=1; i<=n; i++){         cout<<ans[i]<<" ";     } */     if(ans==1)     cout<<-1<<endl;     else 	cout<<ans<<endl;     }     return 0; } 
#include <bits/stdc++.h> using namespace std; // assuming lowercase input at all times int findcost(char a) { 	return (a-96); }  int solve_req(string s, int len) { 	if(len != 0) {   		cout << findcost(s[len]) << endl; 		//return  findcost(s[len]) + solve(s,len--); 	}	 	return 0; }  int solve_iter(string s,int len) { 	int answer=0; 	for (int i = 0; i < len; i++)  	{ 		answer +=findcost(s[i]); 	}  	return answer; }  int main(int argc, char const *argv[]) { 	long long int tc; 	cin>>tc; 	while(tc--) { 		string s; 		cin>>s; 		cout << solve_iter(s,s.length()) << endl; 	}  	return 0; } 
#include <bits/stdc++.h> #define MAX 1000000007 #define pb push_back #define mp make_pair #define FOR(n) for(i=0;i<n;i++) #define rep(i,n) for(i=0;i<n;i++) #define reps(i,a,b) for(i=a;i<=b;i++) #define swap(a,b) T=a,a=b,b=T #define ll long long int #define que queue<int> #define s(t) scanf("%lld",&t) #define p(t) printf("%lld\n",t) void print(ll n)     {ll i=10;char output_buffer[11];output_buffer[10]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<11);} using namespace std;  #define gc getchar_unlocked inline ll scan() { 	ll t=0,neg=0; 	char c; 	c=gc(); 	while((c<'0' || c>'9')&& c!='-') 		c=gc(); 	if(c=='-') {neg=1;c=gc();} 	while(c>='0' && c<='9') 	{ 		t=(t<<3)+(t<<1)+c-'0'; 		c=gc(); 	} 	if(neg) t=-t; 	return(t); }   ll a[100005],ans,W,n; void func(ll i,ll sum) {     if(sum>W || i>n)         return ;     if(W-sum>=0 && W-sum<ans)         ans=W-sum;     func(i+1,sum+a[i]);     func(i+1,sum); } int main() { 	ll i,j,l,m,t,T,f,p,cnt,par,ele,w; 	char x; 	t=scan(); 	while(t--) 	{ 		ans=MAX; 		n=scan();W=scan(); 		FOR(n) a[i]=scan(); 		func(0,0); 		print(ans); 	} 	return 0; }
#include <bits/stdc++.h> #define lli long long int #define M 1000000007  using namespace std;  void swap(int *a, int *b) {     int t = *a;     *a = *b;     *b = t; }  void f(lli A[], int n) {     lli mx = A[n - 1], d = INT_MIN;      for (int i = n - 2; i >= 0; i--) {         if (mx - A[i] > d) {             d = mx - A[i];         }         if (A[i] > mx) {             mx = A[i];         }     }     cout << d << endl; }  int main() {     int t, n;     lli A[100005];     char s[1005][101], str[101];      scanf("%d", &t);      while (t--) {         scanf("%d", &n);          for (int i = 0; i < n; i++) {             scanf("%s", s[i]);         }         scanf("%s", str);         int flag = 0;          for (int i = 0; i < n; i++) {             if (strcmp(str, s[i]) == 0) {                 cout << "yes\n";                 flag = 1;                 break;             }         }         if (!flag) {             cout << "no\n";         }     }      return 0; } 
#include<bits/stdc++.h> using namespace std; int deepayan(int n,int k,int m) {     if(n==1) return 0;     return ((deepayan(n-1,k,m+1)+m*k)%n); } int main() {     int n,t,k;     scanf("%d",&t);     while(t--){     scanf("%d",&n);     scanf("%d",&k);     printf("%d\n",(deepayan(n,k,1)+1));}     return 0; } 
#include<iostream> using namespace std; int main() {     int T;     cin>>T;     long long int rectangle,square;     long long int row,col;     for(int i=0;i<T;i++)     {         cin>>row>>col;         rectangle=(row+1)*row*col*(col+1)/4;         square=0;         while(row&&col)         {              square+=row*col;             row--;             col--;         }         rectangle-=square;         cout<<rectangle<<endl;      } } 
#include <iostream> #include <algorithm> #include <string> #include <cstring> #include <cctype> #include <map> #include <vector>   #ifdef AZN #include "DebugTools.cpp" #endif   using namespace std;   int main() {     #ifdef AZN     freopen("input.txt", "r", stdin);     freopen("output.txt", "w", stdout);     freopen("stderr.txt", "w", stderr);     #endif     typedef long long ll;     ios::sync_with_stdio(false);     static int N, M, x1[111000], y1[111000], x2[111000], y2[111000], dp[555][555];;     memset(dp,0,sizeof(dp));     cin >> N >> M;     for (int i = 0; i < N; i++)         cin >> x1[i] >> y1[i] >> x2[i] >> y2[i];     for (int i = 0,x,y; i < M; i++) {         cin >> x >> y;         dp[x][y]++;     }     for (int x = 1; x <= 500; x++)         for (int y = 1; y <= 500; y++)             dp[x][y] += dp[x-1][y] + dp[x][y-1] - dp[x-1][y-1];     int res = 0;     for (int i = 0; i < N; i++)         res = max(res, dp[x2[i]][y2[i]] - dp[x1[i]-1][y2[i]] - dp[x2[i]][y1[i] - 1] + dp[x1[i]-1][y1[i]-1]);     cout << res << endl;     return 0; } 
#include<iostream> #include<math.h> #include<stdio.h> //#include<conio.h> using namespace std; int main() {     int t,a,b;     scanf("%d",&t);     while(t--)     {               scanf("%d %d",&a,&b);               int num=a,base1=0,base2=0;               while(num>0)               {                           if((num%10)>base1)                                base1=num%10;                           num/=10;                           }               //printf("%d\t",base1);               num=b;               while(num>0)               {                           if((num%10)>base2)                                base2=num%10;                           num/=10;                           }               //printf("%d\n",base2);               int i=0,num1=0,num2=0;               num=a;               while(num)               {                         num1+=(num%10)*pow(base1+1,i);                         num/=10;                         i++;                         }               num=b;               i=0;               while(num)               {                         num2+=(num%10)*pow(base2+1,i);                         num/=10;                         i++;                         }               long int ans=num1+num2;               printf("%ld\n",ans);               }  //   getch();     return 0;     } 
#include<stdio.h> #include<vector> using namespace std;  int main() { 	int n; 	while(scanf("%d",&n)!=EOF) 	{ 		vector<int> a(n),b(n),c(n); 		vector<vector<vector<int> > > solution(n,vector<vector<int> >(2,vector<int>(2))); 		for(int i=0;i<n;i++) 			scanf("%d %d %d",&a[i],&b[i],&c[i]); 		 		solution[n-1][true][false]=0; 		solution[n-1][true][true]=b[n-1]; 		solution[n-1][false][true]=a[n-1]; 		solution[n-1][false][false]=0; 		for(int i=n-2;i>=0;i--) 		{ 			solution[i][true][true]  =max(b[i]+solution[i+1][true][false],c[i]+solution[i+1][true][true]); 			solution[i][true][false] =max(solution[i+1][false][true],solution[i+1][false][false]); 			solution[i][false][true] =max(a[i]+solution[i+1][true][false],b[i]+solution[i+1][true][true]); 			solution[i][false][false]=max(solution[i+1][false][true],solution[i+1][false][false]); 		} 		printf("%d\n",max(solution[0][false][true],solution[0][false][false])); 	} }
/*  * #LCA //<O(nlogn),O(logn)> topcoder  * http://www.codechef.com/problems/REN2013C  */ #include<bits/stdc++.h> using namespace std; #define MAX_S 100005 typedef long long int LL; int n; vector<int >v[MAX_S]; LL dis[MAX_S];//dis int L[MAX_S],T[MAX_S],P[MAX_S];// level , tree, P for lca void dfs(int a,int nr){//a is index, l is level, d is distance     if(L[a] < nr) P[a] =0;     else if(L[a]%nr ==0)         P[a] = T[a];     else         P[a] = P[T[a]];     for(int i=0;i<v[a].size();i++)         dfs(v[a][i],nr); } int LCA(int x,int y){     while(P[x]!=P[y])         if(L[x] > L[y])             x = P[x];         else             y = P[y];      while(x!=y)          if(L[x]>L[y])              x = T[x];          else              y = T[y];      return x; } int main(){     int a,b,t,m;     while(1){         cin >> n;         if(!n)             break;         for(int i=0;i<n;i++){             v[i].clear();             L[i]=dis[i]=0;         }         int maxL=0;         for(int i=1;i<n;i++){             scanf("%d%d",&a,&b);             v[a].push_back(i);             T[i] = a;             L[i] = L[a]+1;             dis[i] = dis[a]+b;         }         dfs(0,sqrt(n));         scanf("%d",&m);         scanf("%d%d",&a,&b);         t = LCA(a,b);         printf("%lld",dis[a] + dis[b] - 2*dis[t]) ;         while(--m){             scanf("%d%d",&a,&b);             t = LCA(a,b);             printf(" %lld",dis[a] + dis[b] - 2*dis[t]) ;         }         printf("\n");     } } 
     #include <iostream>     #include<algorithm>     using namespace std;     int main() {     int t,n;     long long a[100009];     scanf("%d",&t);     if(t<0)     return 0;     while(t--)     {bool flag=true;     scanf("%d",&n);     if(n<=0)     continue;     for(int i=0;i<n;i++)     scanf("%lld",&a[i]);     sort(a,a+n);     long long s=0;     for(int i=0;i<n;i++)     {     if(a[i]<=s+1)     s=s+a[i];     else     {flag=false;break;}     }     if(n==1)     {cout<<"YES\n";continue;}     if(flag)     cout<<"YES\n";     else     cout<<"NO\n";     }     return 0;     } 
#include <cstdio> #include <cmath> const int maxn = 1005; const int dx[] = {-1, 0, 1, 0}; const int dy[] = {0, 1, 0, -1}; const double eps = 0.001; struct punct {     double x, y; }; int n; punct a[maxn]; double x, y; double dist(double x, double y) {     double ret = 0;     for ( int i = 1; i <= n; ++i )     {         double dx1 = a[i].x - x;         double dy1 = a[i].y - y;          ret += sqrt(dx1*dx1 + dy1*dy1);     }     return ret; } void read() { } void algo() {     double d = dist(x, y);     double step = 100.0;     int done = 0;     while ( step > eps )     {         done = 0;         for ( int i = 0; i < 4; ++i )         {             double nx = (double)x + step*dx[i];             double ny = (double)y + step*dy[i];             double t = dist(nx, ny);             if ( t < d )             {                 d = t;                 x = nx;                 y = ny;                 done = 1;                 break;             }         }         if ( !done )             step /= 2;     } }  int main() {     scanf("%d",&n);     for ( int i = 1; i <= n; ++i )     {         scanf("%lf %lf", &a[i].x, &a[i].y);         x += a[i].x;         y += a[i].y;     }     x /= n;     y /= n;     algo();     printf("%.2lf\n",dist(x,y));     return 0; } 
#include<iostream> using namespace std; #define llu long long int llu a[3],i,nb,ns,nc,pb,ps,pc,r,nh,ch,c; string s; int main() {     cin>>a[0]>>a[1]>>a[2];     cin>>nb>>ns>>nc;     cin>>pb>>ps>>pc;     cin>>r;     ch=pb*a[0]+ps*a[1]+pc*a[2];     llu ans=0;     for(i=0;i<=100;i++)     {         llu p=0;         p+=((a[0]*i<nb)?0:a[0]*i-nb)*pb;         p+=((a[1]*i<ns)?0:a[1]*i-ns)*ps;         p+=((a[2]*i<nc)?0:a[2]*i-nc)*pc;         if(r>=p)ans=max(ans,i+(r-p)/ch);     }     cout<<ans<<endl; }
    #include<bits/stdc++.h>     using namespace std;      int main()     {     int z,i,n;     scanf("%d",&n);      int p[n+2][2];      p[0][0]=p[0][1]=0;      for(i=1;i<=n;i++)     {scanf("%d %d",&p[i][0],&p[i][1]);}      scanf("%d %d",&p[n+1][0],&p[n+1][1]);     long  long int val[n+2],visited[n+2];       val[0]=0;visited[0]=1;      for(i=1;i<(n+2);i++)      {val[i]=(p[i][0]-p[0][0])*(p[i][0]-p[0][0])+(p[i][1]-p[0][1])*(p[i][1]-p[0][1]);       visited[i]=-1;}          int numvisited=1,mini,minv;         while(numvisited<=(n+2))         {minv=100000000;              for(i=0;i<(n+2);i++)             {                 if(visited[i]==-1)                 {if(val[i]<minv)                     {minv=val[i];mini=i;}                 }             }     visited[mini]=1;         for(i=0;i<(n+2);i++)         {             if(visited[i]==-1 && i!=mini)             {                 val[i]=min(val[i],val[mini]+(p[i][0]-p[mini][0])*(p[i][0]-p[mini][0])+(p[i][1]-p[mini][1])*(p[i][1]-p[mini][1]));             }         }         numvisited++;         }          cout<<val[n+1];      return 0;     } 
#include <iostream> #include <cstring> #include <cmath> #include <cstdio>  #include <algorithm> #define eps 0.000001  using namespace std;  double a[100]; double dp[1<<20];  bool poss(int i, int j, int k) {     //cout << 1 << endl;     if(a[i]+a[j] < a[k]) return false;     if(a[i]+a[k] < a[j]) return false;     if(a[k]+a[j] < a[i]) return false;     return true; }  double calarea(int i, int j, int k) {     double s = (double)(a[i]+a[j]+a[k])/2.0;     double v1, v2, v3;     v1 = s-(double)a[i];     v2 = s-(double)a[j];     v3 = s-(double)a[k];     s = s * v1 * v2 * v3;     return (double)sqrt(s); }  int main() {     int n;     ios_base::sync_with_stdio(false);     cin >> n;     memset(dp, 0, sizeof(dp));      for(int i = 0; i < n; i++) {         cin >> a[i];     }     //sort(a, a+n);     double val;     cin >> val;     dp[0] = 0;     for(int i = 0; i < (1<<n); i++) {         for(int j = 0; j < n; j++) {             for(int k = j+1; k < n; k++) {                 for(int l = k+1; l < n; l++) {                     if(j == k || k == l || l == j) continue;                     if((i&(1<<j)) && (i&(1<<k)) && (i&(1<<l))) {                            // cout << endl;                         if(poss(j, k, l)) dp[i] = max(dp[i], calarea(j, k, l) + dp[i^(1<<j)^(1<<k)^(1<<l)]);                     }                 }             }         }     }      bool flag = 0;     double maxval = 0.0;     for(int i = 0; i < (1<<n); i++) {         if(fabs(val-dp[i]) < eps) {             flag = 1;         }         maxval = max(maxval, dp[i]);     }      //cout << maxval << endl;     if(!flag) {         cout << "AREA NOT POSSIBLE" << endl;     }     else if(fabs(val-maxval) > eps) {         cout << "BOB WINS" << endl;         printf("%.6f\n", maxval);     }     else {         cout << "DRAW" << endl;     } } 
#include <bits/stdc++.h> #define _ ios_base::sync_with_stdio(false);cin.tie(0); using namespace std; #define pb push_back #define pob pop_back #define pf push_front #define pof pop_front #define mp make_pair #define all(a) a.begin(),a.end() #define bitcnt(x) __builtin_popcountll(x)  #define MOD 5000000007 #define total 100005 #define M 1000000007 typedef unsigned long long int uint64; typedef long long int int64; //vector<int>v[1005]; inline void fast(int &x) {     register int c = getchar_unlocked();     x = 0;     int neg = 0;     for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked());     if(c=='-') {         neg = 1;         c = getchar_unlocked();     }     for(; c>47 && c<58 ; c = getchar_unlocked()) {         x = (x<<1) + (x<<3) + c - 48;     }     if(neg)         x = -x; }  struct node{ 	int val; 	node(){ 		val=0; 	} 	void merge(node &l,node &r){ 		val=l.val+r.val; 	} }; node tree[4*total]; int h; void upd(int root,int lft,int rht,int id1,int id2){ 	if(id1<=lft&&id2>=rht&&tree[root].val==0) 	return ; 	if(id1<=lft&&id2>=rht&&root>=h&&root<=2*h){ 		tree[root].val=tree[root].val/2; 		return ; 	} 	if(root>2*h) 	return ; 	int mid=(lft+rht)/2; 	if(id1<mid) 	upd(2*root,lft,mid,id1,id2); 	if(id2>mid) 	upd(2*root+1,mid,rht,id1,id2); 	tree[root].merge(tree[2*root],tree[2*root+1]);	 } node query(int root,int lft,int rht,int id1,int id2){ 	if(id1<=lft&&id2>=rht) 	return tree[root]; 	int mid=(lft+rht)/2; 	node l,r,n; 	if(id1<mid) 	l=query(2*root,lft,mid,id1,id2); 	if(id2>mid) 	r=query(2*root+1,mid,rht,id1,id2); 	n.merge(l,r); 	return n; } int main(){ 	int n,i,j; 	//cin>>n; 	fast(n); 	h=ceil(log2(n)); 	h=1<<h; 	for(i=0;i<n;i++){ 		//cin>>j; 		fast(j); 		tree[i+h].val=j; 	} 	for(i=h-1;i>=1;i--) 	tree[i].merge(tree[2*i],tree[2*i+1]); 	int q,ch,l,r; 	//cin>>q; 	fast(q); 	while(q--){ 		//cin>>ch>>l>>r; 		fast(ch); 		fast(l); 		fast(r); 		l--; 		r--; 		if(ch==1) 		upd(1,h,2*h,l+h,r+h+1); 		else{ 			node x=query(1,h,2*h,l+h,r+h+1); 			printf("%d\n",x.val); 		} 		//for(i=1;i<=n+h;i++) 		//cout<<tree[i].val<<" "; 		//cout<<endl; 	} 	return 0; }
#include<iostream> using namespace std; int main() { 	long long int x,y,t,diff; 	long long int res; 	cin>>t; 	while(t--) 	{ 		//res=diff=0; 		cin>>x>>y; 		diff=y-x+1; 		res=(diff*(diff-1))/2; 		cout<<res<<endl; 	} 	return 0; }
//Uva 10340 #include <cstdio> #include <cstring> // #include <cmath> #define f(x,y,z) for(int x = (y),__ = (z);x < __;++x) #define g(x,y,z) for(int x = (y),__ = (z);x <= __;++x) #define fd(x,y,z) for(int x = (y),__ = (z);x > __;--x) #define gd(x,y,z) for(int x = (y),__ = (z);x >= __;--x) #define MAX 3024 int a,b,id = 0,d,m,tee,k = 0; int div[MAX],mod[MAX]; bool vis[MAX]; int main(){ 	while (scanf("%d%d",&a,&b) != EOF){ 		if (k++)puts(""); 		id = 0; 		memset(vis,0,sizeof vis); 		d = a / b;m = a % b; 		div[id] = d;mod[id++] = m; 		while(!vis[m] && m){ 			vis[m] = 1; 			m *= 10; 			d = m / b; 			m = m % b; 			div[id] = d; 			mod[id++] = m; 		} 		if (!m){ 			printf("%d/%d = %d.",a,b,div[0]); 			f(i,1,id)printf("%d",div[i]); 			puts("(0)"); 			puts("   1 = number of digits in repeating cycle"); 		}else { 			printf("%d/%d = %d.",a,b,div[0]); 			tee = 0; 			while (mod[tee] != m)++tee; 			// puts(""); 			// printf("%d```\n",tee); 			// f(i,0,id)printf("~~~%d~~~\n",mod[id]); 			if (tee != 1)f(i,1,tee)printf("%d",div[i]); 			else if (mod[1] == m)printf("%d",div[1]); 			printf("("); 			if (id - tee > 50){ 				f(i,tee + 1,tee + 51)printf("%d",div[i]); 				puts("...)"); 			}else { 				f(i,tee + 1,id)printf("%d",div[i]); 				puts(")"); 			} 			printf("   %d = number of digits in repeating cycle\n",id - tee - 1); 		} 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; #define gc getchar_unlocked  main() { 	int T,j,i; 	char c; 	scanf("%d",&T); 	gc(); 	while(T--) { 		int b[26]={0}; 		c=gc(); 		while(c!=10) { 			if((c>='A' && c<='Z') || (c>='a' && c<='z')) 				b[tolower(c)-97]++; 			c=gc(); 		} 		int max=0; 		for(i=0;i<26;i++) 			if(b[i]>=b[max]) 				max=i; 		printf("%c\n",max+97); 	} } 
#include<iostream> using namespace std;  class Matrix { 	public: 		int rows; 		int cols; 		long long** m; 		Matrix(int rows, int cols) { 			this->rows = rows; 			this->cols = cols; 			m = new long long*[rows]; 			for(int i=0;i<rows;i++){ 				m[i] = new long long[cols]; 			} 		} };  Matrix matrixMultiplicationUtil(Matrix a, Matrix b, int dimension, int M) { 	Matrix c(dimension, dimension); 	for(int i=0; i<dimension; i++) { 		for(int j=0; j < dimension; j++ ) { 			c.m[i][j] = 0; 			//cout << "Hello " << endl; 			for(int k=0;k<dimension; k++) { 				c.m[i][j] = c.m[i][j] + a.m[i][k]*b.m[k][j];   			} 			c.m[i][j] = c.m[i][j]%M; 		} 	} 	//cout << c.m[0][0] <<  " " << c.m[0][1] << " " << c.m[1][0] << " " << c.m[1][1] << endl; 	return c; }  Matrix matrixMultiplication(Matrix a, int dimension, int N, int M) { 	if(N == 1) { 		return a; 	} 	//cout << "Hello" << endl; 	Matrix c = matrixMultiplication(a, dimension, N/2, M); 	//cout << c.m[0][0] <<  " " << c.m[0][1] << " " << c.m[1][0] << " " << c.m[1][1] << endl; 	c = matrixMultiplicationUtil(c, c, dimension, M); 	if(N%2 == 1) { 		c = matrixMultiplicationUtil(c, a, dimension, M); 	} 	return c; }  int main() { 	 	int T; 	cin >> T; 	int dimension = 2; 	for(int t=0; t<T; t++) { 		long long N,M; 		cin >> N >> M; 		Matrix result(2,2); 		Matrix unityMatrix(2,2); 		unityMatrix.m[0][0] = unityMatrix.m[0][1] = unityMatrix.m[1][0] = 1; 		unityMatrix.m[1][1] = 0; 		long long num, denom; 		if(N==1) { 			cout << "1/1" << endl; 		} 		else { 			result = matrixMultiplication(unityMatrix, dimension, 2*(N-1), M); 			num = result.m[1][0] + result.m[1][1]; 			denom = result.m[0][0] + result.m[0][1]; 			cout << num%M << "/" << denom%M << endl; 		} 	} 	return 0; }  /* int gcd(int m, int n)     	// function definition {                         	// block begin    int  r;                	// declaration of remainder     while (n != 0) {       	// not equal       r = m % n;          	// modulus operator       m = n;              	// assignment       n = r;    }                      	// end while loop    return m;              	// exit gcd with value m }  void populateResistance(int N, long long& num, long long& denom) { 	long long prevNum = num, prevDenom = denom; 	for(int i = 1; i < N; i++) { 		cout << "i = " << i << endl; 		num = prevNum + prevDenom; 		denom = prevDenom + num; 		long long gc = gcd(num, denom); 		num = num/gc; 		denom = denom/gc; 		cout << " Num = " << num << " Denom = " << denom << " GCD = " << gc << endl; 		prevNum = num; 		prevDenom = denom; 	} } */
#include <iostream> #include <sstream> #include <cstdio> #include <cstring> #include <cstdlib> #include <cmath> #include <memory> #include <cctype> #include <string> #include <vector> #include <list> #include <queue> #include <deque> #include <stack> #include <map> #include <set> #include <algorithm> using namespace std; #define FOR(i,a,b) for(int (i) = (a); (i) <= (b); ++(i)) #define RFOR(i,a,b) for(int (i) = (a); (i) >= (b); --(i)) #define INITIALIZE(a,b) memset((a),b,sizeof(a)) #define INF 1000000000 #define pi 2*acos(0.0) #define SQR(a) (a)*(a) #define MP make_pair #define MAX 100001 #define MODV 1000000007 #define mod(a,mb) if(a >= mb) a = a - mb; #define modx(a) mod(a,MODV)  typedef unsigned long long UInt; typedef long long Int;  int read_int(){ int x; scanf("%d", &x); return x;} Int read_Int(){ Int x; scanf("%lld", &x); return x;}  void compPrime(int *primeArr,int n){} void compPhi(int *phiArr, int n){} void compFact(int *factArr, int n){} void compPow(int *powArr, int x, int n) {   int i;     powArr[0] = 1;     FOR(i,1,n){powArr[i] = powArr[i-1]*x;mod(powArr[i],MODV);} }  int CountBit(int n) {   unsigned int c; // c accumulates the total bits set in v    for (c = 0; n; c++)     n = n >>1; // clear the least significant bit set   return c; }  int main() {   int test,i,j, sum;   int *A, *B;   int N, K;   int max;   int cBIT;    scanf("%d",&test);    while(test--)   {         N = read_int();         K = read_int();         max = -1;         A = new int[N+1];         B = new int[3*N+1];         FOR(i,1,N)         {              A[i] = read_Int();              B[i] = B[i+N] = B[i+2*N] = A[i];              if(A[i] > max) max = A[i];         }      //   A[0] = A[N];          cBIT = CountBit(max);          int lstZeroBit = -1;         int bit;         while(cBIT>=1)         {             lstZeroBit = -1;              FOR(i,1,N)             {                 bit = (B[i] & ( 1u << (cBIT-1))) >> (cBIT-1);                 if(bit==0)  lstZeroBit = i;             }              FOR(i,1,N) //// Left Scan             {                 bit = (B[i+N] & ( 1u << (cBIT-1))) >> (cBIT-1);                  if( lstZeroBit!= -1 && (i + N - lstZeroBit) <= K)                 {                     A[i] &= ~(1u << (cBIT - 1) ) ;                 }                  if(bit==0) lstZeroBit = N + i;              }              lstZeroBit = -1;              for(i=3*N; i>2*N;i--)             {                 bit = (B[i] & ( 1u << (cBIT-1))) >> (cBIT-1);                 if(bit==0)lstZeroBit = i;             }              for(i=N;i>0;i--)  //// Right Scan             {                 bit = (B[i+N] & ( 1u << (cBIT-1))) >> (cBIT-1);                   if(lstZeroBit != -1 && (lstZeroBit - (N + i))<= K)                 {                     A[i] &= ~(1u << (cBIT -1)) ;                 }                   if(bit==0)                 {                     lstZeroBit = N+i;                 }              }             cBIT--;         }          printf("%d",A[1]);         FOR(i,2,N)printf(" %d",A[i]);         printf("\n");   	// your code goes here   }   } 
#include <stdio.h> const int max = 500;  int a[max + 18], b[max + 18]; int x, y, z;  int main() { scanf("%d", &z);     while (z--)     {     scanf("%d%d", &x, &y);     for (int i = 1; i <= x; ++i) scanf("%d", a + i);     for (int m = 1; y; m <<= 1, y >>= 1) 	if (y & 1) 	{ 	    for (int j = 1; j <= x; ++j) b[j] = a[j]; 	    for (int l = ((-m % x + x) % x) + 1, r = (m % x) + 1, j = 1; j <= x; ++j) 	    { 		a[j] ^= b[l++] ^ b[r++]; 		if (l > x) l = 1; 		if (r > x) r = 1; 	    } 	}     for (int i = 1; i <= x; ++i) printf("%d ", a[i]);     printf("\n");     }     return 0; } 
// written by lonerdude(dvdreddy) // all rights reserved //the template by dvdreddy #include <vector> #include <queue> #include <deque> #include <map> #include <iostream> #include <cstring> #include <string> #include <math.h> #include <cstdio> #include <cstdlib> #include <algorithm>  using namespace std;  #define s(x) scanf("%d",&x) #define sll(x) scanf("%lld",&x) #define sf(x) scanf("%lf",&x) #define ss(x) scanf("%s",&x)  #define f(i,a,b) for(int i=a;i<b;i++) #define fr(i,n)  f(i,0,n)  typedef long long ll;  ll mod = 1000000007;  ll fast_exp(ll x, ll p){   ll res = 1;   x %= mod;   while (p){     if (p & 1){       res = res * x;       res %= mod;     }     x = x * x;     x %= mod;     p >>= 1;   }   return res; }  ll fact[101]; ll inv_fact[101];  ll fact_prepro(){   fact[0] = 1;   inv_fact[0] = 1;   f (i, 1, 101){     fact[i] = fact[i - 1] * (ll) i;     fact[i] %= mod;     inv_fact[i] = fast_exp(fact[i], mod - 2);   } }  ll dp[101][101];  ll a[2][101];  int main(){   fact_prepro();      fr (i, 101){     a[0][i] = 0;   }   a[0][0] = 1;    int cur = 1;    f (i, 2, 101){     for (int j = 0; j < 101 ; j += i){       for (int k = 0; k < 101 - j; k++){ 	a[cur][k + j] += (((a[cur ^ 1][k] * fast_exp(inv_fact[i] * fact[i - 1],(ll) (j / i))) % mod) * inv_fact[j / i]) % mod; 	a[cur][k + j] %= mod;       }     }     for (int j = 0; j < 101; j++){       dp[j][i] = (a[cur][j] * fact[j]) % mod;     }     cur = cur ^ 1;     fr (j, 101){       a[cur][j] = 0;     }   }        int t;   s(t);   while (t--){     int n, k;     s(n); s(k);     printf("%lld\n", dp[n][k]);   }   return 0; } 
    #include<bits/stdc++.h>     using namespace std;     int main()     {         int T;         cin>>T;         for(;T;--T)         {             int N , x , val = 0 ;             cin>>N;             for(int i=1;i<=N;++i){                 cin>>x;                 val+=(x-(x%i))/i%2;             }             val=val%2;             if(!val)cout<<"BOB\n";             else cout<<"ALICE\n";         }         return 0;     } 
#include<cstdio> #include<iostream>  using namespace std;  long long int arr[40]; long long int power[40];  int main() {     long long int i,t,num;     power[0]=1;     for(i=1;i<=30;i++)     power[i]=power[i-1]*2;     arr[0]=0;     for(i=1;i<=30;i++)     {     arr[i]=((arr[i-1])%8388608+((power[i-1]*(i+1)*i)/2)%8388608)%8388608; }  cin>>t; while(t--) {         cin>>num;         if(num<=30)         printf("%lld\n",arr[num]);         else         printf("8388607\n"); } return 0; } 
#include<bits/stdc++.h> using namespace std;  const int N=12345; int boom[N]; // boom[i]=0 means i is prime.  vector<int> p; // prime no. storage.  void prepare() {     p.push_back(2);     for(int i=3;i*i<N;i+=2) {         if(!boom[i]) {             for(int j=i*i;j<N;j+=(2*i)) {                 boom[j]=1;             }         }     }     for(int i=3;i<N;i+=2) {         if(!boom[i]) p.push_back(i);     } }  long long _pow(long long a, int n) {     long long res=1;     while(n) {         if(n & 1) res=(res*a);         a=(a*a);         n>>=1;     }     return res; }  int main() {     prepare();     int test;     scanf("%d", &test);     while(test--) {         long long ans=1, n;         scanf("%lld", &n);         if(n<=3) {             puts("0");         } else {             long long nn=n;             for(int i=0;p[i]*p[i]<=nn;i++) {                 int ctr=0;                 while(n%p[i]==0) {                     ctr++;                     n/=p[i];                 }                 long long prod=(_pow((long long)p[i], ctr+1)-1)/(p[i]-1);                 ans=(ans*prod);             }             if(n>1) {                 ans=(ans*(n+1));             }             ans=(ans-1-nn);             printf("%lld\n", ans);         }     } } 
#include<bits/stdc++.h> #define pii pair<int,int> #define Min(a,b) ((a<b) ? a:b) #define Max(a,b) ((a > b) ? a:b) #define Swap(a,b) (a=b+a-(b=a)) #define sn(n) scanf("%d",&n) #define schr(n) scanf("%c",&n) #define ss(n) scanf("%s",n) #define p(n) printf("%d",n) #define el putchar("\n"); #define sp putchar('') #define Fill(a,val) memset(a,val,sizeof(a)) #define pb push_back #define INFN 123456789 #define ll long long #define si short int #define vi vector<int> #define vvi vector<vvi> #define ITER(i,a) for( typeof(a.begin()) i=a.begin();i!=a.end();i++) #define _I int #define _D double #define _L long long  using namespace std; int gcd(int a,int b){ 	return (!b) ? a:gcd(b,a%b); }  char arr[10002]; _I ac,bc;  void func(){ 	_I i,j,len = strlen(arr); 	char n; 	_I tot_c = 0; 	_I min_c = 0; 	char rep_char; 	if(ac < bc) { 		min_c = ac; 		rep_char = 'a'; 	} 	else{ 		min_c = bc; 		rep_char = 'b'; 	} 	_I cnt = 0; 	for(i=0;i < len/2;i++){  		if(arr[i] == '/' && arr[len-i-1] == '/'){ 			tot_c += (2*min_c); 		} 		else if((arr[i] == 'a' && arr[len-i-1] == '/') || (arr[i] == '/' && arr[len-i-1] == 'a')){ 			tot_c += ac; 		} 		else if((arr[i] == 'b' && arr[len-i-1] == '/') || (arr[i] == '/' && arr[len-i-1] == 'b') ){ 			tot_c += bc; 		} 		else if(arr[i] != arr[len-i-1]){ 			cnt = 1; 			break; 		} 	} 	if(cnt){ 		cout << "-1" << endl; 	} 	else{ 		cout << tot_c << endl; 	} }  char N[10021] = {0}; void func1(){ 	if(N[0] & 1) { 		cout << "ODD" << endl; 	} 	else{ 		cout << "EVEN" << endl; 	} 	 }  _I main(){ 	_I t; 	cin >> t; 	_L n; 	for(_I test = 0;test < t;test++){ 		cin >> N; 		func1(); 	} 	return 0; 	 }
#include <stdio.h> #include <string.h> #include <iostream>  using namespace std;  int dig_sum(long long int a) {     long long int sum=0;     while(a)     {         sum+=a%10;         a=a/10;     }     while(sum>9)     sum=dig_sum(sum);     return sum; }  int main() {     long long int c=0;     cin>>c;     while(c!=0)     {         long long int temp=0;         while(c)         {             int a=c%10;             if(a==2 || a==3 || a==5 || a==7)             temp+=a;             c=c/10;         }         cout<<dig_sum(temp)<<endl;         cin>>c;     }     return 0; }
#include<bits/stdc++.h> using namespace std; #define fast ios_base::sync_with_stdio(0);cin.tie(0) int main() { //	fast; 	int n,a,b,c,t1,t2,p[3],u=0; 	cin>>n; 	while(n) 	{ 	//	cout<<"dw"; 		u=0; 		while(n) 		{ 			p[u]=n%10; 			n=n/10; 			u++; 		} 		c=p[0]; 		b=p[1]; 		a=p[2]; 	//	cin>>b>>c; 		t1=a*b; 		t2=b*c; 	//	cout<<"vikas"; 		int di1=0,di2=0; 		int te1,te2; 		te1=t1; 		te2=t2; 		while(te1) 		{ 			di1++; 			te1=te1/10; 		} 			while(te2) 		{ 			di2++; 			te2=te2/10; 		} 	//	di1=log10(t1)+1; 	//	cout<<"di "<<di1; 		if(di1==1) 		cout<<"0"<<t1; 		else 		cout<<t1; 	//	di2=log10(t2)+1; 		if(di2==1) 		cout<<"0"<<t2; 		else 		cout<<t2; 		int sum=t1+t2; 		int di=0; 		while(sum) 		{ 			di++; 			cout<<sum%10; 			sum=sum/10; 		} 		if(di==1) 		cout<<"0"; 		cout<<"\n"; 		cin>>n; 	if(n==0) 	break; 	} }
#include <iostream>  using namespace std;  main() { short int a[1200]={0, 5, 11, 16, 22, 27, 33, 38, 44, 49, 55, 60, 66, 71, 77, 82, 88, 93, 99, 104, 110, 115, 121, 126, 132, 137, 143, 148, 154, 159, 165, 170, 176, 181, 187, 192, 198, 203, 209, 214, 220, 225, 231, 236, 242, 247, 253, 258, 264, 269, 275, 280, 286, 291, 297, 302, 308, 313, 319, 324, 30, 24, 19, 13, 8, 2, 3, 8, 14, 19, 25, 30, 36, 41, 47, 52, 58, 63, 69, 74, 80, 85, 91, 96, 102, 107, 113, 118, 124, 129, 135, 140, 146, 151, 157, 162, 168, 173, 179, 184, 30, 24, 19, 13, 8, 2, 3, 8, 14, 19, 25, 30, 36, 41, 47, 52, 58, 63, 69, 74, 80, 85, 91, 96, 102, 107, 113, 118, 124, 129, 135, 140, 146, 151, 157, 162, 168, 173, 179, 184, 190, 195, 201, 206, 212, 217, 223, 228, 234, 239, 245, 250, 256, 261, 267, 272, 278, 283, 289, 294, 60, 54, 49, 43, 38, 32, 27, 21, 16, 10, 5, 0, 6, 11, 17, 22, 28, 33, 39, 44, 50, 55, 61, 66, 72, 77, 83, 88, 94, 99, 105, 110, 116, 121, 127, 132, 138, 143, 149, 154, 60, 54, 49, 43, 38, 32, 27, 21, 16, 10, 5, 0, 6, 11, 17, 22, 28, 33, 39, 44, 50, 55, 61, 66, 72, 77, 83, 88, 94, 99, 105, 110, 116, 121, 127, 132, 138, 143, 149, 154, 160, 165, 171, 176, 182, 187, 193, 198, 204, 209, 215, 220, 226, 231, 237, 242, 248, 253, 259, 264, 90, 84, 79, 73, 68, 62, 57, 51, 46, 40, 35, 29, 24, 18, 13, 7, 2, 3, 9, 14, 20, 25, 31, 36, 42, 47, 53, 58, 64, 69, 75, 80, 86, 91, 97, 102, 108, 113, 119, 124, 90, 84, 79, 73, 68, 62, 57, 51, 46, 40, 35, 29, 24, 18, 13, 7, 2, 3, 9, 14, 20, 25, 31, 36, 42, 47, 53, 58, 64, 69, 75, 80, 86, 91, 97, 102, 108, 113, 119, 124, 130, 135, 141, 146, 152, 157, 163, 168, 174, 179, 185, 190, 196, 201, 207, 212, 218, 223, 229, 234, 120, 114, 109, 103, 98, 92, 87, 81, 76, 70, 65, 59, 54, 48, 43, 37, 32, 26, 21, 15, 10, 4, 1, 6, 12, 17, 23, 28, 34, 39, 45, 50, 56, 61, 67, 72, 78, 83, 89, 94, 120, 114, 109, 103, 98, 92, 87, 81, 76, 70, 65, 59, 54, 48, 43, 37, 32, 26, 21, 15, 10, 4, 1, 6, 12, 17, 23, 28, 34, 39, 45, 50, 56, 61, 67, 72, 78, 83, 89, 94, 100, 105, 111, 116, 122, 127, 133, 138, 144, 149, 155, 160, 166, 171, 177, 182, 188, 193, 199, 204, 150, 144, 139, 133, 128, 122, 117, 111, 106, 100, 95, 89, 84, 78, 73, 67, 62, 56, 51, 45, 40, 34, 29, 23, 18, 12, 7, 1, 4, 9, 15, 20, 26, 31, 37, 42, 48, 53, 59, 64, 150, 144, 139, 133, 128, 122, 117, 111, 106, 100, 95, 89, 84, 78, 73, 67, 62, 56, 51, 45, 40, 34, 29, 23, 18, 12, 7, 1, 4, 9, 15, 20, 26, 31, 37, 42, 48, 53, 59, 64, 70, 75, 81, 86, 92, 97, 103, 108, 114, 119, 125, 130, 136, 141, 147, 152, 158, 163, 169, 174, 180, 174, 169, 163, 158, 152, 147, 141, 136, 130, 125, 119, 114, 108, 103, 97, 92, 86, 81, 75, 70, 64, 59, 53, 48, 42, 37, 31, 26, 20, 15, 9, 4, 1, 7, 12, 18, 23, 29, 34, 180, 174, 169, 163, 158, 152, 147, 141, 136, 130, 125, 119, 114, 108, 103, 97, 92, 86, 81, 75, 70, 64, 59, 53, 48, 42, 37, 31, 26, 20, 15, 9, 4, 1, 7, 12, 18, 23, 29, 34, 40, 45, 51, 56, 62, 67, 73, 78, 84, 89, 95, 100, 106, 111, 117, 122, 128, 133, 139, 144, 210, 204, 199, 193, 188, 182, 177, 171, 166, 160, 155, 149, 144, 138, 133, 127, 122, 116, 111, 105, 100, 94, 89, 83, 78, 72, 67, 61, 56, 50, 45, 39, 34, 28, 23, 17, 12, 6, 1, 4, 210, 204, 199, 193, 188, 182, 177, 171, 166, 160, 155, 149, 144, 138, 133, 127, 122, 116, 111, 105, 100, 94, 89, 83, 78, 72, 67, 61, 56, 50, 45, 39, 34, 28, 23, 17, 12, 6, 1, 4, 10, 15, 21, 26, 32, 37, 43, 48, 54, 59, 65, 70, 76, 81, 87, 92, 98, 103, 109, 114, 240, 234, 229, 223, 218, 212, 207, 201, 196, 190, 185, 179, 174, 168, 163, 157, 152, 146, 141, 135, 130, 124, 119, 113, 108, 102, 97, 91, 86, 80, 75, 69, 64, 58, 53, 47, 42, 36, 31, 25, 240, 234, 229, 223, 218, 212, 207, 201, 196, 190, 185, 179, 174, 168, 163, 157, 152, 146, 141, 135, 130, 124, 119, 113, 108, 102, 97, 91, 86, 80, 75, 69, 64, 58, 53, 47, 42, 36, 31, 25, 20, 14, 9, 3, 2, 7, 13, 18, 24, 29, 35, 40, 46, 51, 57, 62, 68, 73, 79, 84, 270, 264, 259, 253, 248, 242, 237, 231, 226, 220, 215, 209, 204, 198, 193, 187, 182, 176, 171, 165, 160, 154, 149, 143, 138, 132, 127, 121, 116, 110, 105, 99, 94, 88, 83, 77, 72, 66, 61, 55, 270, 264, 259, 253, 248, 242, 237, 231, 226, 220, 215, 209, 204, 198, 193, 187, 182, 176, 171, 165, 160, 154, 149, 143, 138, 132, 127, 121, 116, 110, 105, 99, 94, 88, 83, 77, 72, 66, 61, 55, 50, 44, 39, 33, 28, 22, 17, 11, 6, 0, 5, 10, 16, 21, 27, 32, 38, 43, 49, 54, 300, 294, 289, 283, 278, 272, 267, 261, 256, 250, 245, 239, 234, 228, 223, 217, 212, 206, 201, 195, 190, 184, 179, 173, 168, 162, 157, 151, 146, 140, 135, 129, 124, 118, 113, 107, 102, 96, 91, 85, 300, 294, 289, 283, 278, 272, 267, 261, 256, 250, 245, 239, 234, 228, 223, 217, 212, 206, 201, 195, 190, 184, 179, 173, 168, 162, 157, 151, 146, 140, 135, 129, 124, 118, 113, 107, 102, 96, 91, 85, 80, 74, 69, 63, 58, 52, 47, 41, 36, 30, 25, 19, 14, 8, 3, 2, 8, 13, 19, 24, 330, 324, 319, 313, 308, 302, 297, 291, 286, 280, 275, 269, 264, 258, 253, 247, 242, 236, 231, 225, 220, 214, 209, 203, 198, 192, 187, 181, 176, 170, 165, 159, 154, 148, 143, 137, 132, 126, 121, 115, 330, 324, 319, 313, 308, 302, 297, 291, 286, 280, 275, 269, 264, 258, 253, 247, 242, 236, 231, 225, 220, 214, 209, 203, 198, 192, 187, 181, 176, 170, 165, 159, 154, 148, 143, 137, 132, 126, 121, 115, 110, 104, 99, 93, 88, 82, 77, 71, 66, 60, 55, 49, 44, 38, 33, 27, 22, 16, 11, 5, 0, 5, 11, 16, 22, 27, 33, 38, 44, 49, 55, 60, 66, 71, 77, 82, 88, 93, 99, 104, 110, 115, 121, 126, 132, 137, 143, 148, 154, 159, 165, 170, 176, 181, 187, 192, 198, 203, 209, 214}; int fall, n;  for(cin >> fall; fall--;) 	{ 	cin >> n; 	cout << a[n%1200] << endl; 	}  return 0; } 
#include <iostream> #include <string.h>  main() { int fall, t, erg; char str[110];  for(std::cin >> fall >> str; fall--; std::cin >> str) 	{ 	for(erg=t=0; t++<strlen(str); erg=(erg+t*str[t])%strlen(str)); 	std::cout << erg << std::endl; 	}  return 0;  } 
#include <iostream> #include <string.h>  using namespace std;  main() { int fall; char name[1000], passwort[1000];  cin >> fall; while(fall--) 	{ 	cin >> name >> passwort; 	for(int t=0; t<strlen(name); t++) 		cout << (char)(name[t]+passwort[t%strlen(passwort)]-130); 	cout << endl; 	} return 0; } 
    #include <iostream>     #include <string.h>           main()     {     int fall, t;     char wert[]={0,1,2,3,0,1,0,1,2,3,0,1,0,1,2,3,0,1,2,3,4,5,6,7,0,1}, str[100];           for(std::cin>>fall>>str;fall--;std::cout<<(int)wert[str[0]-'a']<<std::endl,std::cin>>str)     for(t=1; t<strlen(str); t++)     if(str[t]>str[0])     str[0]=str[t];     return 0;     } 
#include <iostream>  main() { long a[]={180, 716, 1607, 2848, 4438, 6372, 8649, 11264, 14216, 17500, 21115, 25056, 29322, 33908, 38813, 44032, 49564, 55404, 61551, 68000, 74750, 81796, 89137, 96768, 104688, 112892, 121379, 130144, 139186, 148500, 158085, 167936, 178052, 188428, 199063, 209952, 221094, 232484, 244121, 256000, 268120, 280476, 293067, 305888, 318938, 332212, 345709, 359424, 373356, 387500, 401855, 416416, 431182, 446148, 461313, 476672, 492224, 507964, 523891, 540000, 556290, 572756, 589397, 606208, 623188, 640332, 657639, 675104, 692726, 710500, 728425, 746496, 764712, 783068, 801563, 820192, 838954, 857844, 876861, 896000, 915260, 934636, 954127, 973728, 993438, 1013252, 1033169, 1053184, 1073296, 1093500, 1113795, 1134176, 1154642, 1175188, 1195813, 1216512, 1237284, 1258124, 1279031, 1300000, 1321030, 1342116, 1363257, 1384448, 1405688, 1426972, 1448299, 1469664, 1491066, 1512500, 1533965, 1555456, 1576972, 1598508, 1620063, 1641632, 1663214, 1684804, 1706401, 1728000, 1749600, 1771196, 1792787, 1814368, 1835938, 1857492, 1879029, 1900544, 1922036, 1943500, 1964935, 1986336, 2007702, 2029028, 2050313, 2071552, 2092744, 2113884, 2134971, 2156000, 2176970, 2197876, 2218717, 2239488, 2260188, 2280812, 2301359, 2321824, 2342206, 2362500, 2382705, 2402816, 2422832, 2442748, 2462563, 2482272, 2501874, 2521364, 2540741, 2560000, 2579140, 2598156, 2617047, 2635808, 2654438, 2672932, 2691289, 2709504, 2727576, 2745500, 2763275, 2780896, 2798362, 2815668, 2832813, 2849792, 2866604, 2883244, 2899711, 2916000, 2932110, 2948036, 2963777, 2979328, 2994688, 3009852, 3024819, 3039584, 3054146, 3068500, 3082645, 3096576, 3110292, 3123788, 3137063, 3150112, 3162934, 3175524, 3187881, 3200000, 3211880, 3223516, 3234907, 3246048, 3256938, 3267572, 3277949, 3288064, 3297916, 3307500, 3316815, 3325856, 3334622, 3343108, 3351313, 3359232, 3366864, 3374204, 3381251, 3388000, 3394450, 3400596, 3406437, 3411968, 3417188, 3422092, 3426679, 3430944, 3434886, 3438500, 3441785, 3444736, 3447352, 3449628, 3451563, 3453152, 3454394, 3455284, 3455821, 3456000, 3455820, 3455276, 3454367, 3453088, 3451438, 3449412, 3447009, 3444224, 3441056, 3437500, 3433555, 3429216, 3424482, 3419348, 3413813, 3407872, 3401524, 3394764, 3387591, 3380000, 3371990, 3363556, 3354697, 3345408, 3335688, 3325532, 3314939, 3303904, 3292426, 3280500, 3268125, 3255296, 3242012, 3228268, 3214063, 3199392, 3184254, 3168644, 3152561, 3136000, 3118960, 3101436, 3083427, 3064928, 3045938, 3026452, 3006469, 2985984, 2964996, 2943500, 2921495, 2898976, 2875942, 2852388, 2828313, 2803712, 2778584, 2752924, 2726731, 2700000, 2672730, 2644916, 2616557, 2587648, 2558188, 2528172, 2497599, 2466464, 2434766, 2402500, 2369665, 2336256, 2302272, 2267708, 2232563, 2196832, 2160514, 2123604, 2086101, 2048000, 2009300, 1969996, 1930087, 1889568, 1848438, 1806692, 1764329, 1721344, 1677736, 1633500, 1588635, 1543136, 1497002, 1450228, 1402813, 1354752, 1306044, 1256684, 1206671, 1156000, 1104670, 1052676, 1000017, 946688, 892688, 838012, 782659, 726624, 669906, 612500, 554405, 495616, 436132, 375948, 315063, 253472, 191174, 128164, 64441, 23328000}; int fall, n;  for(std::cin >> fall >> n; fall--; std::cout << a[--n%360] << std::endl, std::cin >> n); return 0; } 
    #include<bits/stdc++.h>     using namespace std;     int main()     {     int n,t;     scanf("%d",&t);     while(t--)     {     scanf("%d",&n);     if(n%2)     {     printf("%d\n",n+2);     }     else     printf("%d\n",n+1);     }     return 0;     } 
#include <bits/stdc++.h> using namespace std;   int main(){ 	int t; 	cin>>t; 	while(t--){ 		int n; 		cin>>n; 		int ar[n]; 		for(int i=0; i<n; i++){ 			cin>>ar[i];  		} 		int max =0; 		for(int i=0; i<n-1; i++){ 			for(int j=i+1; j<n; j++){ 				if(ar[j]-ar[i] > max) max = ar[j]-ar[i]; 				}} 		cout<<max<<endl; 	} 	return 0; 	}
#include<iostream> #include<cstring> using namespace std; int main() { 	int test; cin>>test; while(test--){    char a[25],temp='1';    cin>>a;    	for(int i=(strlen(a)-1);i>=0;i--)    {        if(a[i]=='1' && temp=='0') {a[i]='1'; temp='0';}        if(a[i]=='0' && temp=='1') {a[i]='1'; temp='0'; }        if(a[i]=='0' && temp=='0') {a[i]='0'; temp='0'; }        if(a[i]=='1' && temp=='1') {a[i]='0'; temp='1';}    }    if(temp=='1')cout<<'1'; 	cout<<a<<endl; }    return 0;          }
#include<iostream> using namespace std;  int main() { int t; cin>>t; while(t--) { long long int dashes=0; long long int x; cin>>x; while(x) { int r=x%10; switch(r) { case 1:dashes+=4;break; case 2:;case 3:;case 5:dashes+=10;break; case 4:dashes+=8;break; case 6:;case 0:; case 9:dashes+=18;break; case 7:dashes+=9;break; case 8:dashes+=21;break; } x=x/10; } cout<<dashes<<endl; } return 0; }
#include <iostream> #include <algorithm> #include <vector> #include <string> #include <functional>  #include <math.h>  using namespace std;   int main(){     int t;     cin>>t;     for(int i=0;i<t;i++){         int m;         cin>>m;                  vector<int> numbers;         for(int j=0;j<m;j++){             int n ;             cin>>n;             numbers.push_back(n);         }                  if(m % 2 == 0)             cout<<-1<<endl;         else{              sort(numbers.begin(),numbers.end());              cout<<numbers[numbers.size()/2]<<endl;             }     } }
#include<stdio.h> #include<string.h> #define p printf("%c", a[i]); int main(){ 	int t, l, i; scanf("%d", &t); char a[60]; 	while(t-- && scanf("%s", a)){ 		l = strlen(a); 		for(i = l / 2 - 1; i >= 0; i--)	p 		for(i = l - 1; i >= l / 2; i--)	p 		printf("\n"); 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		int n,i,j,w[10000],t[10000],to[10000],max=0; 		cin>>n; 		for(i=0;i<n;i++) 		cin>>w[i]; 		for(i=0;i<n;i++) 		cin>>t[i]; 		for(i=0;i<n;i++) 		to[i]=3*w[i]+t[i]; 		for(i=0;i<n;i++) 		{ 			if(to[i]>max) 			max=to[i]; 		} 		cout<<max<<endl; 	} 	return 0; }
#include<stdio.h> int main(){     int t,n;     scanf("%d",&t);     while(t--){         scanf("%d",&n);         printf("%d\n",(((n/2)/2)*((n/2)-((n/2)/2))));     } } 
#include<iostream> using namespace std; int main() {   int n,T;   int l,r,b,t,a3;   int v1,v2,v3,v4;   int x1[22],x2[22],y1[22],y2[22];   cin>>T;   while(T--)   {     cin>>n;     for(int i=0;i<n;i++)     {       cin>>v1>>v2>>v3>>v4;       x1[i]=v1<v3?v1:v3;       y1[i]=v2<v4?v2:v4;       x2[i]=v1>v3?v1:v3;       y2[i]=v2>v4?v2:v4;     }     l=x1[0];     for(int i=0;i<n;i++)     {       if(x1[i]>l) 	l=x1[i];     }     r=x2[0];     for(int i=0;i<n;i++)     {       if(x2[i]<r) 	r=x2[i];     }     b=y1[0];     for(int i=0;i<n;i++)     {       if(y1[i]>b) 	b=y1[i];     }     t=y2[0];     for(int i=0;i<n;i++)     {       if(y2[i]<t) 	t=y2[i];     }       a3=(l-r)*(b-t);       if(a3<0) 	a3=-a3;      // cout<<"l,r,b,t="<<l<<" "<<r<<" "<<b<<" "<<t<<endl;     if(l<r&&b<t)       cout<<a3<<endl;     else      cout<<0<<endl;   }   return 0; }
#include <iostream> #include <algorithm> using namespace std;   int main() {     int t; cin>>t;     while(t--)     {         int n; cin>>n;         int group[n];         for(int i=0;i<n;i++)         cin>>group[i];           for(int i=0;i<n;i++)         {             int c=group[i];             bool print=true;             for(int j=i+1;j<n;j++)             {                 if(group[j]==c)                 {print=false;break;}             }             if(print==true)             cout<<c<<endl;         }     }     return 0; }
#include<iostream> #include<cstring> using namespace std; int main() {     int t,total,a[4],sol[40005],j,i;     cin>>t;     while(t--)     {         memset(a,0,sizeof(a));         memset(sol,0,sizeof(sol));         cin>>total>>a[0]>>a[1]>>a[2]>>a[3];         sol[0]=1;         for(i=0;i<4;i++)         {             for(j=total;j>=0;j--)             {                 if(sol[j]==1)                 {                     sol[j+a[i]]=1;                 }             }         }         if(sol[total]==1)             cout<<"YES"<<endl;         else             cout<<"NO"<<endl;     } } 
#include <stdio.h> #include <stdlib.h>  #include<iostream>  using namespace std; /* Following function is needed for library function qsort(). Refer    http://www.cplusplus.com/reference/clibrary/cstdlib/qsort/ */ int comp(const void* a, const void* b) {  return *(int*)a > *(int*)b ; }   // Function to count all possible triangles with arr[] elements int findNumberOfTriangles(int arr[], int n) {     // Sort the array elements in non-decreasing order     qsort(arr, n, sizeof( arr[0] ), comp);       // Initialize count of triangles     int count = 0;       // Fix the first element.  We need to run till n-3 as the other two elements are     // selected from arr[i+1...n-1]     for (int i = 0; i < n-2; ++i)     {         // Initialize index of the rightmost third element         int k = i+2;           // Fix the second element         for (int j = i+1; j < n; ++j)         {             // Find the rightmost element which is smaller than the sum             // of two fixed elements             // The important thing to note here is, we use the previous             // value of k. If value of arr[i] + arr[j-1] was greater than arr[k],             // then arr[i] + arr[j] must be greater than k, because the             // array is sorted.             while (k < n && arr[i] + arr[j] > arr[k])                ++k;               // Total number of possible triangles that can be formed             // with the two fixed elements is k - j - 1.  The two fixed             // elements are arr[i] and arr[j].  All elements between arr[j+1]             // to arr[k-1] can form a triangle with arr[i] and arr[j].             // One is subtracted from k because k is incremented one extra             // in above while loop.             // k will always be greater than j. If j becomes equal to k, then             // above loop will increment k, because arr[k] + arr[i] is always             // greater than arr[k]             count += k - j - 1;         }     }       return count; }   // Driver program to test above functionarr[j+1] int main() { int t;  cin>>t; while(t--){  int n,i; cin>>n; int a[n]; for(i=0;i<n;i++) cin>>a[i]; cout<<findNumberOfTriangles(a,n)<<endl;  }     return 0; }
#include <stdio.h> #include <cmath> #include <algorithm>  #define INF 30000  struct point { 	int x; 	int y; };  int comp(const void *a,const void *b){ 	point ap = *(point*)a; 	point bp = *(point*)b;  	double sa,sb;  	if(ap.x>0) sa = (double)ap.y/ap.x; 	else if(ap.x==0)sa = INF; 	else sa = 2*INF + (double)ap.y/ap.x;  	if(bp.x>0) sb = (double)bp.y/bp.x; 	else if(bp.x==0)sb = INF; 	else sb = 2*INF + (double)bp.y/bp.x;  	return sa < sb ? 1 : 0; }  int main(){ 	int T; 	scanf("%d",&T);  	while(T--){ 		int N; 		scanf("%d",&N);  		point pts[N]; 		for(int i=0;i<N;i++) scanf("%d",&pts[i].x);  		int miny=0; 		for(int i=0;i<N;i++){ 			scanf("%d",&pts[i].y); 			if(pts[i].y<pts[miny].y) miny=i; 		}  		for(int i=0;i<N;i++){ 			if(i!=miny){ 				pts[i].x -= pts[miny].x; 				pts[i].y -= pts[miny].y; 			} 		}  		pts[miny].x = pts[0].x; 		pts[miny].y = pts[0].y; 		pts[0].x =0; 		pts[0].y=0;  		qsort(pts+1,N-1,sizeof(point),comp);  		double area=0,a=sqrt(pts[1].x*pts[1].x+pts[1].y*pts[1].y),b,c,s; 		for(int i=1;i<N-1;i++){ 			b = sqrt((pts[i].x-pts[i+1].x)*(pts[i].x-pts[i+1].x) + (pts[i].y-pts[i+1].y)*(pts[i].y-pts[i+1].y)); 			c = sqrt(pts[i+1].x*pts[i+1].x + pts[i+1].y*pts[i+1].y); 			s = (a+b+c)/2;  			area += sqrt(s*(s-a)*(s-b)*(s-c)); 			a=c; 		}  		printf("%.1lf\n",area); 	} } 
#define inam aaaaa(e,n,i,g,m,a) #define aaaaa(p,l,i,n,t,h) t##h##i##l #define kill aaaaaaa(s,t,u,p,i,d) #define aaaaaaa(c,a,s,i,n,o) i##s##a##c #define bug aaaaaaaa(c,h,a,r,i,t,y) #define aaaaaaaa(m,u,n,g,e,r,i) m##u##n##g #define aaaaaa ({bug a[]={aaa(52),aaa(49),aaa(44),aaa(44),aaa(4C),aaa(45),aaa(0)};kill(a);}) #define aaa(y) 0x##y inam(){aaaaaa;}
#include<iostream> #include<string> using namespace std; int main() {     int t;     cin>>t;     for(int i=0;i<t;i++)     {         string s;         cin>>s;         int j=0,c=0;         while(s.size()>0&&j<s.size()-1)         {             if(s[j+1]==s[j])             {             s.erase(j+1,1);             c++;             }             else                 j++;         }         cout<<c<<endl;     } } 
 #include <iostream> #include<stdio.h> #include<stdlib.h> using namespace std; int a[1000]; int findmin(int size) {     int i,min=99999;     for(i=0;i<size;i++)     {         if(a[i]==-1 || a[i]==0)             continue;         if(a[i]<min)             min=a[i];     }     return min; } bool check(int size) {     int i;     for(i=0;i<size;i++)     {         if(a[i]>0)             return true;     }     return false; } int sub(int size,int min) {     int i,count=0;     for(i=0;i<size;i++)     {         if(a[i]<=0)             continue;         else         {             count++;             a[i] = a[i]-min;         }     }     return count; } int main() {     int n,i,min,gol=0;     int operation=0;     scanf("%d",&n);     for(i=0;i<n;i++)         scanf("%d",&a[i]);     while(check(n))     {         if(gol==3)             break;         min = findmin(n);         operation = sub(n,min);         printf("%d\n",operation);     }      return 0; } 
#include<bits/stdc++.h> #include<algorithm> #include<vector> #include<queue> //int dx[]={1,1,0,-1,-1,-1,0,1};int dy[]={0,1,1,1,0,-1,-1,-1};//8 direction //int dx[]={2,1,-1,-2,-2,-1,1,2};int dy[]={1,2,2,1,-1,-2,-2,-1};//Knight Direction //int dx[]={0,1,0,-1};int dy[]={1,0,-1,0}; //4 direction #define REP(i,n) for(int i=0;i<n;i++) #define REPU(i,a,b) for(int i=a;i<b;i++) #define sll(n) scanf("%lld",&n) #define si(n) scanf("%d",&n) #define pi(n) printf("%d",n) #define sl(n) scanf("%ld",&n) #define pin(n) printf("%d\n",n) #define MP make_pair #define PB push_back typedef long long LL; using namespace std; string d,s; int main() {     int t;     si(t);     while(t--)     {         cin>>d>>s;         int ct=INT_MAX;         if(s.size()==d.size())         {             REP(i,s.size())             ct+=(s[i]!=d[i]);             cout<<ct<<endl; continue;         }         if(d.size()>s.size()) swap(s,d);         for(int i=0;i<(s.size()-d.size());i++)         {                 int c=0;             for(int j=0;j<d.size();j++)             {                 if(d[j]!=s[i+j]) c++;             }             ct=min(ct,c);         }         cout<<ct<<endl;     } 	return 0; } 
#include<iostream> #include<stdio.h> #include<vector> #include<algorithm>  using namespace std;  int bubbleSort(int arr[], int n) {       bool swapped = true;       int j = 0;       int count=0;       int tmp;       while (swapped) {             swapped = false;             j++;             for (int i = 0; i < n - j; i++) {                   if (arr[i] > arr[i + 1]) {                         tmp = arr[i];                         arr[i] = arr[i + 1];                         arr[i + 1] = tmp;                         count++;                         swapped = true;                   }             }       }             return count;       } int main () {     int T,N,t,arr[100002],steps,temp;     scanf("%d", &T);     vector<int>box1,box2;     vector<int>::iterator pos;     while(T--)     {         box1.clear();box2.clear();         scanf("%d", &N);         for(int i=0; i<N;i++)         {             scanf("%d", &t);             box1.push_back(t);         }         for(int i=0; i<N;i++)         {             scanf("%d", &t);             box2.push_back(t);         }          for(int i=0;i<N;i++)         {             pos=find(box1.begin(),box1.end(),box2[i]);             temp=distance(box1.begin(),pos);             arr[temp]=i+1;         }        steps=bubbleSort(arr,N);        printf("%d\n",steps);     } } 
#include<bits/stdc++.h> using namespace std; #define ll long long ll n,sum; ll x; int main() { 	int n; 	sum = 0; 	cin>>n; 	for(int i=0;i<n;++i) 		{ 			cin>>x; 			sum += x; 		} 	printf("%.6lf\n",(4*sum)/(double)n); 	return 0; }
/*===============*\ |  ID: TMANDZU    | |    LANG: C++    | \*===============*/ //Tornike Mandzulashvili //#pragma comment(linker,"/STACK:256000000") #include <time.h> #include <stdio.h> #include <stdlib.h> #include <algorithm> #include <stack> #include <math.h> #include <vector> #include <string> #include <map> #include <queue> #include <iostream> #include <set>  #define EPS 0.000000001 #define Pi 3.1415926535897932384626433832795028841971 #define hash1 1000003 #define hash2 1000033 #define md 1000000007 #define INF 1000000000 #define mp make_pair #define pb push_back #define S size() #define MX(aa,bb) (aa>bb?aa:bb) #define MN(aa,bb) (aa<bb?aa:bb) #define fi first #define se second #define PI pair < int,int > #define REP(i,a,n) for(i=a;i<n;i++) #define sc scanf #define pt printf #define big long long #define VI vector <int>  using namespace std;  const int NMAX=100005;  struct node {     int X,Y,YY,check,ind; };  bool cmp(node P,node Q) {     return P.X<Q.X; }  struct Tree {     int l,r,sum,num,look; };  int ans[NMAX]; Tree g[8*NMAX]; int N,raod,len,i,j,xx1,xx2,yy1,yy2; node A[4*NMAX]; int ord[NMAX*4]; map <int,int> M;  void build(int a,int b,int u) {     g[u]=(Tree){a,b,0,0,0};     if (a==b) return;     int mid=(a+b)>>1;     build(a,mid,2*u);     build(mid+1,b,2*u+1); }  void decrease(int pos,int u) {     int left=g[u].l;     int right=g[u].r;      if (pos<left || pos>right) return;     if (left==right)     {         g[u].sum=0;         return;     }     decrease(pos,2*u);     decrease(pos,2*u+1);     g[u].sum=g[2*u].sum+g[2*u+1].sum; }  int getsum(int a,int b,int u) {     int left=g[u].l;     int right=g[u].r;      if (a>b) return 0;     if (a>right || left>b) return 0;     if (a<=left && right<=b) return g[u].sum;      return getsum(a,b,2*u)+getsum(a,b,2*u+1); }  void update(int pos,int number,int which,int u) {      int left=g[u].l;      int right=g[u].r;       if (left>pos || pos>right) return;      if (left==right)      {          g[u].sum=1;          g[u].num=number;          g[u].look=which;          return;      }      update(pos,number,which,2*u);      update(pos,number,which,2*u+1);      g[u].sum=g[2*u].sum+g[2*u+1].sum; }   void go(int pos,int u) {     int left=g[u].l;     int right=g[u].r;      if (left>pos || right<pos) return;      if (left==right)     {         if (g[u].look==1)         ans[A[i].ind]=ans[g[u].num]; else         ans[A[i].ind]=g[u].num;         return;     }      if (g[2*u+1].l<=pos && getsum(g[2*u+1].l,pos,1)>0)     go(pos,2*u+1); else     if (g[2*u].r<=pos)     go(g[2*u].r,2*u); else     go(pos,2*u); }  main() {   //  freopen("text.in","r",stdin);   freopen("text.out","w",stdout);      scanf("%d",&N);     for (i=0;i<N;i++)     {         scanf("%d %d %d %d",&xx1,&yy1,&xx2,&yy2);         A[len++]=(node){xx1,yy1,yy2,1,i};         A[len++]=(node){xx2,yy1,yy2,0,i};         if (!M[yy1])         {             ord[raod++]=yy1;             M[yy1]=1;         }         if (!M[yy2])         {             ord[raod++]=yy2;             M[yy2]=1;         }     }      sort(A,A+len,cmp);      sort(ord,ord+raod);      for (i=0;i<raod;i++)     M[ord[i]]=i+1;      build(1,raod,1);      for (i=0;i<len;i++){         A[i].Y=M[A[i].Y];         A[i].YY=M[A[i].YY];     }      for (i=0;i<len;i++)     if (!A[i].check)     {         decrease(A[i].Y,1);         decrease(A[i].YY,1);     }else     {    //     cout<<1<<"-"<<A[i].Y-1<<"="<<getsum(1,A[i].Y-1,1)<<endl;          if (getsum(1,A[i].Y-1,1)==0)         {     //         cout<<"upd "<<A[i].Y<<" "<<A[i].YY<<endl;               update(A[i].Y,A[i].ind,0,1);              update(A[i].YY,A[i].ind,1,1);               ans[A[i].ind]=-1;               continue;         }          //count the ans          go(A[i].Y-1,1);      //    cout<<"upd "<<A[i].Y<<" "<<A[i].YY<<endl;          update(A[i].Y,A[i].ind,0,1);         update(A[i].YY,A[i].ind,1,1);     }      for (i=0;i<N;i++)     printf("%d\n",ans[i]); } 
#include <cassert> #include <cctype> #include <climits> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <iostream> #include <sstream> #include <iomanip> #include <string> #include <vector> #include <list> #include <set> #include <map> #include <stack> #include <queue> #include <algorithm> #include <iterator> #include <utility> #include <functional> using namespace std;  #define MP(x, y) make_pair(x, y) #define SET(p) memset(p, -1, sizeof(p)) #define CLR(p) memset(p, 0, sizeof(p)) #define MEM(p, v) memset(p, v, sizeof(p)) #define CPY(d, s) memcpy(d, s, sizeof(s)) #define SZ(c) (int)c.size() #define PB(x) push_back(x) #define ff first #define ss second #define ll long long #define ld long double #define mod 1000000007 #define inf 1061109567LL #define pii pair< int, int > #define pll pair< ll, ll > #define psi pair< string, int > #define BLOCK 250 #define gc getchar_unlocked inline void sc(int &x) {     register int c = gc();     x = 0;     for(;(c<48 || c>57);c = gc());     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} } #define N 100001 #define maxval 1000001 struct node { 	int L, R, i; }q[N]; int a[N]; int answer; vector <int> cnt[1000001]; int l[1000001]; int r[1000001]; int ans[N]; int s[N+1]; int bit[8*1000000]; inline bool cmp(node x, node y) { 	if(x.L/BLOCK != y.L/BLOCK) { 		return x.L/BLOCK < y.L/BLOCK; 	} 	return x.R < y.R; } inline void update(int i,int lt,int rt,int idx,int val){ 	if(lt==rt){ 		bit[i] = val; 		//cout<<lt<<endl; 		return; 	} 	if(idx<=(lt+rt)/2)update(2*i,lt,(lt+rt)/2,idx,val); 	else update(2*i+1,1+(lt+rt)/2,rt,idx,val); 	bit[i] = max(bit[i*2],bit[2*i+1]); }  inline void add(int val,int f) { 	if(f){ 		r[val]++; 		if(l[val]==-1) 			l[val]++; 	} 	else{ 		l[val]--; 	} 	//cout<<val<<" "<<l[val]<<" "<<r[val]<<" "<<cnt[val][r[val]]-cnt[val][l[val]]<<endl; 	update(1,0,maxval,val,cnt[val][r[val]] - cnt[val][l[val]]); }  inline void remove(int val,int f) { 	if(l[val]>r[val]) 		return ; 	if(!f){ 		l[val]++; 	} 	else{ 		r[val]--; 	} 	if(l[val]>r[val]) 		return ; 	//cout<<"asdf "<<val<<" "<<l[val]<<" "<<r[val]<<" "<<cnt[val][r[val]]<<" "<<cnt[val][l[val]]<<endl; 	update(1,0,maxval,val,cnt[val][r[val]] - cnt[val][l[val]]); }  int main() { 	int n,m,k; 	sc(n);sc(m);sc(k); 	for(int i=0; i<n; i++) 		sc(a[i]); 	s[0]=0; 	cnt[s[0]].PB(0); 	for(int i=1;i<=n;i++){ 		s[i]=(a[i-1]+s[i-1])%k; 		cnt[s[i]].PB(i); 		//cout<<s[i]<<" "; 	} 	//cout<<endl; 	for(int i=0;i<maxval;i++){ 		l[i]=r[i]=-1; 	} 	//l[N]=r[N]=0;  	for(int i=0; i<m; i++) { 		scanf("%d%d", &q[i].L, &q[i].R); 		q[i].L--;// q[i].R--; 		q[i].i = i; 	}  	sort(q, q + m, cmp);  	int currentL = 0, currentR = 0; 	for(int i=0; i<m; i++) { 		int L = q[i].L, R = q[i].R; 		while(currentR <= R) { 			add(s[currentR],1); 			currentR++; 		} 		while(currentR > R+1) { 			remove(s[currentR-1],1); 			currentR--; 		} 		while(currentL > L) { 			add(s[currentL-1],0); 			currentL--; 		} 		while(currentL < L) { 			remove(s[currentL],0); 			//cout<<s[currentL]<<endl; 			currentL++; 		} 		ans[q[i].i] = bit[1]; 		//cout<<bit[1]<<endl; 	}  	for(int i=0; i<m; i++) 		printf("%d\n", ans[i]); } 
#include <cstdio> #include <cstring> #include <algorithm> #define MAX 100000 using namespace std;   long long ans[MAX+1][2]; long long arr[MAX+1];  long long cc(int level,int upto,int limit){          long long sum=0;     for(int i=level;i<(level+upto);i++)     {         if(i>limit)             break;         sum+=arr[i];     }     //printf("%lld %d %d \n",sum,level,upto);     return sum; }  long long f(int level,int type,int limit){          if (level>limit) {         return 0;     }      if (ans[level][type]!=-1)         return ans[level][type];          if (type) {         ans[level][type] = max( cc(level,1,limit)+f(level+1,1-type,limit), max(cc(level,2,limit)+f(level+2,1-type,limit), cc(level,3,limit)+f(level+3,1-type,limit) ));     } else {         ans[level][type] = min( f(level+1,1-type,limit), min(f(level+2,1-type,limit), f(level+3,1-type,limit) ));     }     //printf("%d %d %lld\n",level,type,ans[level][type]);     return ans[level][type]; }  int main() {   int t,n;   scanf("%d",&t);   while(t--){     scanf("%d",&n);     for(int i=0;i<n;i++)     {         arr[i]=0;         ans[i][0]=ans[i][1]=-1;         //printf("%lld %lld\n",ans[i][0],ans[i][1]);     }     for(int i=0;i<n;i++)     {         scanf("%lld",&arr[i]);     }     printf("%lld\n",f(0,1,n-1));   }   return 0; } 
#include<bits/stdc++.h> using namespace std ; int main () {     int cnt = 0 , beg , m = -100000;     string s ;     getline(cin , s);     int i = 0 ;     int len = s.size();     for ( i = 0 ; i < len ; i++ ) {         //cout << i << endl;         if ( s[i] == '(' ) {             cnt++ ;             if ( cnt > m ) {                 m = cnt ;                 beg = i+1 ;             }         }         else if ( s[i] == ')' ) {             cnt--;         }     }     for ( int j = beg ; j < len ; j++ ) {         if ( s[j] == ')' )             break ;         cout << s[j] ;     }     cout << endl;     return 0 ; } 
#include <bits/stdc++.h> using namespace std;  int a[100001]; vector <int> even; vector <int> odd;  int main(){     int t;     cin >> t;     while(t--){         int n;         even.clear();         odd.clear();         cin >> n;         string s;         cin >> s;         long long sum = 0;         for(int i = 0; i < n; i++){             cin >> a[i];             if(a[i]%2 == 0){                 even.push_back(a[i]);             }else{                 odd.push_back(a[i]);             }             sum += a[i];         }         int ans = 0;         sort(even.begin(),even.end());         sort(odd.begin(),odd.end());         if(s == "Happy"){             if(odd.size() == 0) cout << "Sad" << endl;             else{                 if(odd.size()%2 == 0){                     cout << sum-odd[0] << endl;                 }else{                     cout << sum << endl;                 }             }         }else{             if(even.size() == 0 && odd.size() == 1) cout << "Sad" << endl;             else{                 if(odd.size()%2 == 0){                     cout << sum << endl;                 }else{                     cout << sum-odd[0] << endl;                 }             }         }     } } 
#include<bits/stdc++.h> using namespace std; #define ll long long int #define lf long double #define pb push_back #define mp make_pair #define mod 1000000007 #define inf INT_MAX #define linf LONG_LONG_MAX #define ppi pair<int,int> #define ppl pair<int,int> #define F   first #define S   second #define s(n)                        scanf("%d",&n) #define sc(n)                       scanf("%c",&n) #define sl(n)                       scanf("%lld",&n) #define sf(n)                       scanf("%lf",&n) #define ss(n)                       scanf("%s",n) int block; int M[317][100001]; ll L[10010]; int A[100010]; int n; int query(int a,int b,int val) { 	int count=0,j; 	int i=a; 	j=i/block; 	while((i)%block!=0&&i<=b) 	{ 		if((A[i]+L[j])%n==val) 			count++; 		i++; 	} 	j=i/block; 	while((i+block)<=b) 	{             count=count+M[j][(val-L[j]+n)%n]; 		i=i+block; 		j++; 	} 	j=i/block; 	while(i<=b) 	{ 		if((A[i]+L[j])%n==val) 			count++; 		i++; 	} 	return count; } void update(int a,int b,int val) { 	int i=a,j; 	map<int,int>::iterator it; 	j=i/block; 	while((i)%block!=0&&i<=b) 	{ 		M[j][A[i]]=M[j][A[i]]-1; 		M[j][(A[i]+val)%n]++; 		A[i]=(A[i]+val)%n; 		i++; 	} 	j=i/block; 	while((i+block)<=b) 	{ 	//    cout<<"updating"<<endl; 	    L[j]+=val; 	    L[j]%=n; 	    i=i+block; 	    j++; 	} 	j=i/block; 	while(i<=b) 	{ 	    M[j][A[i]]=M[j][A[i]]-1; 		M[j][(A[i]+val)%n]++; 		A[i]=(A[i]+val)%n; 		i++; 	} 	//for(i=0;i<n;i++)    //     cout<<A[i]<<" "; } int main() { 	int t,i,j,ans,q,a,b,c,val,x; 	scanf("%d %d",&n,&q); 	block=(int)sqrt((double)n); 	for(i=0;i<n;i++) 	{ 		scanf("%d",&A[i]); 		j=i/block; 		M[j][A[i]]++; 	} 	while(q>0) 	{ 		q--; 		scanf("%d %d %d %d",&c,&a,&b,&x); 		if(c==1) 		{ 			update(a,b,x); 		} 		else 		{ 			ans=query(a,b,x); 			printf("%d\n",ans); 		} 	} } 
#include<bits/stdc++.h> #define s(t) scanf("%d",&t); using namespace std;  int main() {     #ifndef ONLINE_JUDGE     freopen("ip.txt", "r", stdin);     freopen("op.txt", "w", stdout); #endif      priority_queue<int,vector<int> > m,M;      int n,add,cnt=0,tmp,t,x;     s(n);      while(n--)     {         s(t);          if(t==1)         {             s(add);             cnt++;              if(m.size()==0 || -m.top()<=add)                 m.push(-add);             else                 M.push(add);               if(m.size() == 1)              {                 x = -m.top();                 m.pop();                 M.push(x);              }              while(m.size()<(cnt/3))             {                 tmp=M.top();                 M.pop();                 m.push(-tmp);             }              while(m.size()>(cnt/3))             {                 tmp=m.top();                 m.pop();                 M.push(-tmp);             }         }         else         {             if((cnt/3)==0)                 printf("No reviews yet\n");             else                 printf("%d\n",-m.top());         }     }      return 0; } 
#include<iostream> #include<algorithm> #include<vector> #include<map> #include<set> using namespace std; int gcd(int n, int m) { 	while(m>0) { 		int temp = m; 		m = n%m; 		n = temp; 	} 	return n; } int main() { 	int t, n, m; 	cin >> t; 	while(t--) { 		cin >> n >> m; 		if(m < n) 			n = n+ m - (m=n); 		int gcdv = gcd(m-1, n-1); 		cout << gcdv + 1 << endl; 	} 	return 0; }  
#include<iostream> #include<cstdlib> #include<algorithm> #include<stdio.h> #include<vector> #include<map> #define ll long long #define pb push_back using namespace std ;  int z[1000002]; void Z_algo(string s) {   int n=s.length();   int L = 0, R = 0;   z[0]=n;   for (int i = 1; i < n; i++)    {     if (i > R)     {     L = R = i;     while (R < n && s[R-L] == s[R]) R++;     z[i] = R-L; R--;     }     else     {     int k = i-L;     if (z[k] < R-i+1) z[i] = z[k];     else     {       L = i;       while (R < n && s[R-L] == s[R]) R++;       z[i] = R-L; R--;     }     }    } }      int main(){       string s1;     int t,i;            cin>>s1;       Z_algo(s1);       int maxm = 0;       for(i=1;i<s1.length();++i)          maxm = max(maxm,z[i]);                   if(maxm==0)           cout<<"NO\n";         else{         	int fir ;         	int occ  = 0;;         	for(i=1;i<s1.length();++i)         	   if(z[i]==maxm)         	     {         	     	occ++;         	     	if(occ==1)         	     		fir = i;         	     }         	 if(occ==1)         	    cout<<"NO\n";         	 else{         	 	cout<<"YES\n";         	 	  cout<<fir<<endl;         	 }         }                   return 0; } 
#include<stdio.h>  using namespace std; int main() { 	int I,J,k,i=0,j=0; 	long long c,t,n,ans=0; 	scanf("%lld\n",&t); 	scanf("%lld\n",&n); 	bool f1[200],f2[200]; 	c=t; 	while(c){ 		f1[i++]=(c%2); 		c=c/2; 	} 	c=n; 	while(c){ 		f2[j++]=(c%2); 		c=c/2; 	} 	scanf("%d",&I); 	scanf("%d",&J); 	for(k=I;k<=J;k++){ 		f1[k]=f2[k-I]; 	} 	for(k=i-1;k>=0;k--){ 		ans=(ans*2)+(f1[k]?1:0); 	} 	printf("%llu\n",ans); 	return 0; }   
#include <bits/stdc++.h>  #define mod 1000000007 using namespace std; typedef long long int lli; lli fact[100000]; int n; void func() {     int i,res=1;     fact[0]=1;     for(i=1;i<100000;i++)     {         res=((lli)res*i)%mod;         fact[i]=res;             } }  vector<int> vec[100000]; int dp[100000][20],parent[100000],level[100000],nodes[100000]; bool visit[100000];  void func2() {     int i,j;     memset(dp,-1,sizeof(dp));     for(i=0;i<n;i++)         dp[i][0]=parent[i];         for(j=1;((1<<j)<n);j++)     for(i=0;i<n;i++)     {         if(dp[i][j-1]!=-1)         {             dp[i][j]=dp[dp[i][j-1]][j-1];         }     } }  int LCA(int x, int y) {     int i;     if(level[x]<level[y])         swap(x,y);     for(i=int(log2(double(level[x])));i>=0;i--)     {         if((level[x]-(1<<i))>=level[y])         {             x=dp[x][i];         }     }     if(x==y) return x;     for(i=int(log2(double(level[x])));i>=0;i--)     {         if(dp[x][i]!=-1 && dp[x][i]!=dp[y][i])         {             x=dp[x][i];y=dp[y][i];         }     }     return parent[x]; }  void func3() {     nodes[0]=0;     queue<int> Q;     Q.push(0);     vector<int>::iterator it;     while(!Q.empty())     {         int top=Q.front();         Q.pop();         for(it=vec[top].begin();it!=vec[top].end();it++)         {             if(nodes[*it]==-1)             {                 int i=*it;                 if(fact[i]%3==0) nodes[i]=nodes[parent[i]]+1;                 else nodes[i]=nodes[parent[i]];                 Q.push(*it);             }         }     } }  void bfs() {     queue<int> Q;     Q.push(0);     visit[0]=true;     parent[0]=-1;     level[0]=0;     vector<int>:: iterator it;     while(!Q.empty())     {         int top=Q.front();         Q.pop();         for(it=vec[top].begin();it!=vec[top].end();it++)         {             if(visit[*it]==false)             {                 parent[*it]=top;visit[*it]=true;level[*it]=level[top]+1;Q.push(*it);             }         }     } }  int main() {     std::ios::sync_with_stdio(0);     int q,i,j,a,b,x,y;     func();     cin>>n;     for(i=0;i<n-1;i++)     {         cin>>x>>y;         vec[x].push_back(y);         vec[y].push_back(x);     }     memset(visit,false,sizeof(visit));     memset(parent,-1,sizeof(parent));     memset(level,-1,sizeof(level));     memset(nodes,-1,sizeof(nodes));     bfs();     func2();     func3();     cin>>q;     for(i=0;i<q;i++)     {         cin>>a>>b;         int lca=LCA(a,b);         int ans=nodes[a]+nodes[b]-2*nodes[lca]+1*(fact[lca]%3==0);         cout<<ans<<endl;     } } 
#include <iostream> #include <cstdio> #include <cstdlib> #include <cstring> #include <cmath> #include <algorithm> #include <vector> #include <list> #include <queue> #include <stack> #include <map> #include <ctime> #include <utility> #include <climits> #include <cfloat> #include <cassert>  using namespace std; #define readint(n) scanf("%d",&n); #define readll(n) scanf("%lld",&n); #define readchar(n) scanf("%c",&n); #define readf(n) scanf("%f",&n); #define readd(n) scanf("%lf",&n); #define readstr(s) scanf("%s",&s); #define init(mem) memset(mem,0,sizeof(mem)); int pabs(int n){return (n>0?n:-n);} int hcf(int a,int b){if(b==0){return a;} else{return hcf(b,a%b);}}  #define db  int main(){     priority_queue<string> pq;     int n;     readint(n);     int* mem=new int[n];     int* mem1=new int[n];     string str;     for(int i=0;i<n;i++){         cin>>str;         mem[i]=26*(str[0]-'A')+str[1]-'A';         mem1[i]=mem[i];     }     sort(mem1,mem1+n);     int m,l;     readint(m);     for(int i=0;i<m;i++){         readint(l);         if(mem[l]==mem1[l]){             printf("NO\n");         }         else{             printf("YES\n");         }     }     return 0; } 
//{ #include<iostream> #include<cmath> #include<algorithm> #include<limits> #include<vector> #include<bitset> #include<cstdlib> #include<cstdio> #include<cstring> #include<time.h> #include<map> using namespace std; #define MOD 1000000007LL #define LL long long #define ULL unsigned long long #define LD long double #define MAX(a,b) ((a)>(b)?(a):(b)) #define MIN(a,b) ((a)<(b)?(a):(b)) #define ABS(x)   ((x)<0?-(x):(x)) #define si(n) scanf("%d",&n) #define sf(n) scanf("%f",&n) #define sl(n) scanf("%ld",&n) #define sll(n) scanf("%lld",&n) #define slu(n) scanf("%llu",&n) #define sd(n) scanf("%lf",&n) #define ss(n) scanf("%s",n) #define pnl printf("\n") #define REP(i,n) for(int i=0;i<(n);i++) #define FOR(i,a,b) for(int i=(a);i<(b);i++) #define FORR(i,n,e) for(int i=(n);i>=(e);i--) #define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d)) #define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d)) //#undef mydebug #ifdef mydebug #define DB(x) cout<<#x<<"="<<(x)<<"\n" #define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n" #define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n" #else #define DB(x) #define DB2(x,y) #define DB3(x,y,z) #endif #define FILL(a,b) memset(a,b,sizeof(a)) const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; //template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;} void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;} ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} //} void precompute(){} void refresh(){} #define size 101 int arr[size]; void doThis(){     int len;     int count = 10000;     si(len);     REP(i,len){         si(arr[i]);     }      FOR(i,0,len){         int temp = 0;         FOR(j,0,len){             if(arr[j]!=arr[i]+j-i){                 temp++;             }         }         if(temp<count){             count=temp;         }     }  printf("%d\n",count); }  int main(){ #ifdef amy freopen("C:\\amy\\input.txt","r",stdin);freopen("C:\\amy\\output.txt","w",stdout);freopen("C:\\amy\\log.txt", "w", stderr); #endif precompute(); int t=1; scanf("%d",&t); while(t--){doThis();} #ifdef amy fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC)); #endif return 0; } 
#include<cstdio>  long table[605]={0,6,10,14,15,21,22,26,33,34,35,38,39,46,51,55,57,58,62,65,69,74,77,82,85,86,87,91,93,94,95,111,115,119,123,129,133,141,143,145,155,159,161,185,187,203,205,209,215,217,221,235,247,253,259,265,287,299,301,319,323,329,341,371,377,391,403,407,437,451,473,481,493,517,527,533,551,559,583,589,611,629,649,667,671,689,697,703,713,731,767,779,793,799,817,851,893,899,901,943,989,1003,1007,1037,1073,1081,1121,1139,1147,1159,1189,1219,1247,1271,1273,1333,1357,1363,1403,1457,1517,1537,1541,1591,1633,1643,1679,1711,1739,1763,1769,1829,1891,1927,1943,1961,2021,2059,2077,2117,2173,2183,2201,2257,2263,2279,2291,2419,2449,2479,2491,2501,2537,2623,2627,2701,2747,2773,2867,2881,2911,2923,2993,3053,3071,3127,3139,3149,3233,3239,3337,3397,3403,3431,3551,3569,3599,3649,3713,3763,3827,3869,3901,3953,4087,4183,4187,4189,4307,4331,4399,4453,4559,4661,4717,4757,4819,4891,4897,5063,5141,5183,5251,5293,5353,5429,5459,5561,5609,5723,5767,5893,5917,5959,5963,6059,6077,6161,6283,6313,6319,6431,6497,6499,6527,6557,6649,6767,6887,6901,7031,7081,7169,7171,7303,7313,7373,7387,7519,7571,7597,7663,7739,7811,7957,7979,8023,8051,8137,8249,8383,8453,8549,8611,8633,8881,8927,8989,9047,9167,9379,9523,9701,9797,9991,10033,10057,10379,10403,10541,10573,10807,10873,10961,11009,11021,11227,11303,11413,11639,11659,11663,12091,12193,12317,12319,12371,12707,12827,13081,13231,13289,13483,13493,13589,13837,13843,14017,14039,14111,14279,14317,14351,14659,14803,14873,14933,15049,15151,15251,15347,15481,15553,15707,15943,16157,16241,16459,16637,16799,16837,17063,17113,17399,17653,17741,17947,18209,18419,18923,19043,19177,19519,19781,19939,20413,20567,20687,20701,20711,20989,21209,21353,21509,21823,21877,21971,22331,22499,22657,22663,22879,23213,23393,23449,23701,23707,23711,24047,24287,24523,24613,24797,24881,24883,25159,25217,25591,25777,26123,26219,26671,26969,27029,27161,27221,27331,28103,28199,28417,28459,28757,28841,28891,29143,29177,29353,29503,29651,29747,29893,29987,30049,30227,30301,30929,30967,31133,31243,31313,31459,31897,32111,32231,32399,32437,32899,33043,33233,33389,34081,34189,34393,34427,34547,34571,34933,35237,35263,35621,35657,36019,36503,36863,37627,37769,38009,38021,38191,38407,38579,39203,39917,40301,40363,40633,40723,40991,41087,41449,41567,41989,42593,43039,43357,43739,43811,43931,44197,44377,44503,44719,44969,45113,45173,45571,45649,45901,46031,46127,46367,46513,47053,47083,47477,47561,47897,47959,48319,49163,50429,50621,50851,51067,51959,51983,52891,52961,53297,53357,53743,54227,54253,54707,54731,55189,55687,55973,56153,56977,57311,57479,57599,58339,58483,58649,58853,59701,59881,59987,59989,60227,60433,60491,61063,61279,61423,61517,61601,61937,62059,62677,62857,62879,63143,63383,63433,64291,64507,64541,64769,64829,65311,65473,65939,66013,66203,66757,67159,67519,67591,67637,67721,68021,68203,69133,69527,69647,70531,70747,71033,71189,71273,72217,72731,72851,72899,73543,73903,74429,74513,75067,75301,75589,76127,76151,76693,77059,77837,78391,78817,78899,79403,79523,80741,81161,81793,82319,82333,82583,82919,83197,83659,84197,84281,84823,85039,85273,85907,86147,86267,86701,86881,87391,87809,87953,88013,88579,89077,89711,89951,91123,91709,92881,93011,93673,95477,96091,96983,97319,97343,98587,98741,99221,100001}; long t,a,b,i,j,k,l; int main() {     scanf("%ld",&t);     for(i=0;i<t;i++)     {                    scanf("%ld %ld",&a,&b);                    k=l=0;                    for(j=0;j<605;j++)                                      if(table[j]<a);                                                     //k++;                                      else                                                    break;                    k=j-1;                    for(j=0;j<605;j++)                                      if(table[j]<=b);                                                     //l++;                                      else                                                    break;                    l=j;                    //if(k!=l)                    printf("%ld\n",(l-k-1));                    /*else                    {                         if(k==l && (table[k-1]==a || table[k-1]==b))                         printf("%ld\n",1);                         else if(k==l && !(table[k-1]==a || table[k-1]==b))                         printf("%ld\n",0);                    }*/                                        /*for(k=0;table[k]<a && k<605;k++);                    for(l=0;table[k]<=b && k<605;l++);                    k--;                    printf("%ld\n",(l-k-1));*/     } } 
#include <bits/stdc++.h> #define ll long long #define sz 100005 using namespace std;  int d[sz],calc[sz],pre[sz]; // d stores the distance from origin // pre stores consecutive distances i.e pre[1]=1 and pre[i]= d[i]-d[i-1]; i>1 // using a 1 based indexing // calc stores the needed subsequence int lps[sz];  // using KMP algorithm  void computelps(int n)	//n is length of array calc == pattern array { 	int i=2,j=1; 	lps[1]=1; 	while(i<=n) 	{ 		if(calc[i]==calc[j]) 		{ 			lps[i]=j+1; 			i++; 			j++; 		} 		else 		{ 			if(j!=1) 			{ 				j=lps[j-1]; 			} 			else 			{ 				lps[i]=1; 				i++; 			} 		} 	} }  void search(int n,int m,int &ans) // n== length of d / text and m== length of calc/pattern { 	int i=1,j=1; 	while(i<=n) 	{ 		//cout<<i<<" "<<j<<"\n"; 		if(pre[i]==calc[j]) 		{ 			i++; 			j++; 		} 		 		if(j==m+1) 		{ 			ans++; // match found 			j=lps[j-1]; 		} 		else if( pre[i]!=calc[j] && i<=n) 		{ 			if(j>1) 			{ 				j=lps[j-1]; 			} 			else 			{ 				i++; 			} 		} 	} }  void printa(int *a,int n) { 	for(int i=1;i<=n;i++) 	{ 		cout<<a[i]<<" "; 	} 	cout<<"\n"; } int main() {     #ifndef ONLINE_JUDGE     freopen("input.txt","r",stdin);     #endif     int t;     scanf("%d",&t);     d[0]=0;     while(t--)     {         int n,k,ans=0;         scanf("%d %d",&n,&k);         for(int i=1;i<=n;i++)         {             scanf("%d ",&d[i]); 			if(i!=1) 			{ 				pre[i]=d[i]-d[i-1]; 			} 			else 			{ 				pre[i]=0; 			}         }         for(int i=1;i<=k;i++)         {             scanf ("%d ",&calc[i]); 		}								// only input 		 		computelps(k); 		//printa(calc,k); 		//printa(lps,k);         search(n,k,ans); 		cout<<ans<<"\n";     }     return 0; } 
    /*     * @problem: xx     */     #include <iostream>     #include <algorithm>     #include <utility>     #include <cstring>     #include <string.h>     #include <queue>     #include <set>     #include <map>     #include <math.h>     #include <stdio.h>     #include <vector>     #include <functional>     #include <bitset>     #include <iomanip>     #define ll long long     #define pi acos(-1.0)     #define pb push_back     #define MS0(ar) memset(ar,0,sizeof ar)     #define MS1(ar) memset(ar,-1,sizeof ar)     #define ff first     #define ss second     #define pii pair<int,int>     #define pll pair<ll,ll>     #define ind(a) scanf("%d",&a)     #define inf(a) scanf("%lf",&a)     #define inl(a) scanf("%lld",&a)     #define ins(a) scanf("%s",a)     #define pd(a) printf("%d\n",a)     #define pl(a) printf("%lld\n",a);     #define bitcnt(x) __builtin_popcountll(x)     #define mod 1000000007     const int MAX = 1e5 + 10;     using namespace std;     int n;     int arr[MAX];     bool dp[501][250001];     int findMin(int arr[], int n)     {     	int sum = 0;     	for (int i = 0; i < n; i++)     		sum += arr[i];     	for (int i = 0; i <= n; i++)     		dp[i][0] = true;     	for (int i = 1; i <= sum; i++)     		dp[0][i] = false;     	for (int i = 1; i <= n; i++)     	{     		for (int j = 1; j <= sum; j++)     		{     			dp[i][j] = dp[i - 1][j];     			if (arr[i - 1] <= j)     				dp[i][j] |= dp[i - 1][j - arr[i - 1]];     		}     	}     	int diff = mod;     	for (int j = sum / 2; j >= 0; j--)     	{     		if (dp[n][j] == true)     		{     			diff = sum - 2 * j;     			break;     		}     	}     	return diff;     }     int main()     {           	ios_base::sync_with_stdio(0);     	cin.tie(0);     #ifndef ONLINE_JUDGE     	freopen("../input.txt", "r", stdin);     	//freopen("../output.txt","w",stdout);     #endif     	int t, mov;     	char ch;     	cin >> t;     	vector<int>ver;     	vector<int>hor;     	while (t--)     	{     		ver.clear();     		hor.clear();     		hor.pb(0);     		ver.pb(0);     		cin >> n;     		cin >> mov;     		ver.pb(mov);     		for (int i = 0; i < n; i++)     		{     			cin >> ch >>mov;     			if (i % 2)     				ver.pb(mov);     			else     				hor.pb(mov);     		}     		// cin >> mov;     		// ver.pb(mov);     		n = ver.size();     		for (int i = 1; i <= n; i++)     			arr[i] = ver[i];     		int x = findMin(arr, ver.size());     		n = hor.size();     		for (int i = 1; i <= n; i++)     			arr[i] = hor[i];     		x += findMin(arr, hor.size());     		if(n<3)     			cout<<"NO"<<endl;     		else     		cout << x << endl;     	}     	return 0;     } 
#include <stdio.h> #include <stdlib.h> long long int arr[100000];    long long int  _mergeSort(long long int arr[], long long int temp[], long long int left, long long int right); long long int merge(long long int arr[], long long int temp[], long long int left, long long int mid, long long int right);    /* This function sorts the input array and returns the    number of inversions in the array */ long long int mergeSort(long long int arr[], long long int array_size) {     long long int *temp = (long long int *)malloc(sizeof(long long int)*array_size);     return _mergeSort(arr, temp, 0, array_size - 1); }    /* An auxiliary recursive function that sorts the input array and   returns the number of inversions in the array. */ long long int _mergeSort(long long int arr[], long long int temp[], long long int left, long long int right) {   long long int mid, inv_count = 0;   if (right > left)   {     /* Divide the array into two parts and call _mergeSortAndCountInv()        for each of the parts */     mid = (right + left)/2;        /* Inversion count will be sum of inversions in left-part, right-part       and number of inversions in merging */     inv_count  = _mergeSort(arr, temp, left, mid);     inv_count += _mergeSort(arr, temp, mid+1, right);        /*Merge the two parts*/     inv_count += merge(arr, temp, left, mid+1, right);   }   return inv_count; }    /* This funt merges two sorted arrays and returns inversion count in    the arrays.*/ long long int merge(long long int arr[], long long int temp[], long long int left, long long int mid, long long int right) {   long long int i, j, k;   long long int inv_count = 0;      i = left; /* i is index for left subarray*/   j = mid;  /* i is index for right subarray*/   k = left; /* i is index for resultant merged subarray*/   while ((i <= mid - 1) && (j <= right))   {     if (arr[i] <= arr[j])     {       temp[k++] = arr[i++];     }     else     {       temp[k++] = arr[j++];         /*this is tricky -- see above explanation/diagram for merge()*/       inv_count = inv_count + (mid - i);     }   }      /* Copy the remaining elements of left subarray    (if there are any) to temp*/   while (i <= mid - 1)     temp[k++] = arr[i++];      /* Copy the remaining elements of right subarray    (if there are any) to temp*/   while (j <= right)     temp[k++] = arr[j++];      /*Copy back the merged elements to original array*/   for (i=left; i <= right; i++)     arr[i] = temp[i];      return inv_count; }  main() {       long long int t;       scanf("%lld",&t);       while(t--)       {                 long long int n;                 scanf("%lld",&n);                 long long int i;                 for(i=0;i<n;i++)                 scanf("%d",&arr[i]);                 printf("%lld.00\n",mergeSort(arr,n));       } } 
#include <vector> #include <list> #include <map> #include <set> #include <deque> #include <queue> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <cctype> #include <string> #include <cstring> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <string.h> using namespace std; #define ll long long #define gc getchar_unlocked  int read_int() {   char c = gc();   int ret = 0, sign = 1;   while((c<'0' || c>'9') && c!='-') c = gc();   if(c=='-') {     sign = -1;     c = gc();   }   while(c>='0' && c<='9') {     ret = 10 * ret + c - 48;     c = gc();   }   if(sign<0) ret = -ret;   return ret; }  ll dp[500][500]; ll grid[500][500];  int main() {   int m=read_int(), n = read_int(), q = read_int();   for(int i=0; i<m; i++) {     for(int j=0; j<n; j++) {       grid[i][j] = read_int();     }   }   for(int i=0; i<m; i++) {     for(int j=0; j<n; j++) {       dp[i][j] = -1e15;     }   }   dp[0][0] = grid[0][0];   for(int i=0; i<m; i++) {     for(int j=0; j<n; j++) {       int upto = min(i,j) ? min(i,j) : max(i,j);       for(int d=1; d<=upto; d++) { 	if((i%d==0 || i==0) && (j%d==0 || j==0)) { 	  if(i>0) dp[i][j] = max(dp[i][j],dp[i-d][j]+grid[i][j]); 	  if(j>0) dp[i][j] = max(dp[i][j],dp[i][j-d]+grid[i][j]); 	  if(i>0 && j>0) dp[i][j] = max(dp[i][j],dp[i-d][j-d]+grid[i][j]); 	}       }     }   }   while(q-->0) {     int r = read_int(), c= read_int();     printf("%lld\n",dp[r][c]);   }   return 0; } 
#include<iostream>   using namespace std;     int a[52][52]; int v[52],gb; int ans[52],fire;   int solve(int term,int ans[],int index) { int i,j; if(term == fire) { gb++; for(i=0;i<index;i++) printf("%d ",ans[i]); printf("\n"); return 0; } for(i=0;i<52;i++) { if(a[term][i]==1 && v[i]==0 && i!=term) { v[i] = 1; ans[index] = i; solve(i,ans,index+1); v[i] = 0; } } return 0; }   int main() { int t,i,j,k,l,m,n,x,y,count=1,ans[52]; scanf("%d",&t); while(t--) { gb=0; for(i=0;i<52;i++) { v[i]=0; for(j=0;j<52;j++) { a[i][j]=0; } } scanf("%d",&fire); while(1) { scanf("%d %d",&x,&y); if(x==y&&y==0) break; a[x][y]=1; a[y][x]=1; } printf("CASE %d:\n",count++); v[1] = 1; ans[0] = 1; solve(1,ans,1); printf("There are %d routes from the firestation to streetcorner %d.\n",gb,fire); } return 0; }
#include <iostream> #include <stdio.h> #include <string.h> using namespace std; void xstrupr(char *p) { 	int i; 	for(i=0;i<strlen(p);i++) 	if(*(p+i)>96 && *(p+i)<123) *(p+i)-=32; } int main() { 	char **p,q[10000],r[10000],s[10000]; 	int t,i=1,j,k,n,l; 	cin>>t; 	while(t--) 	{ 		cin>>n; 		cin.ignore(); 		p=new char*[n]; 		for(j=0;j<n;j++) 		{ 			*(p+j)=new char[10000]; 			gets(*(p+j)); 		} 		gets(q); 		cout<<"Data Set "<<i++<<":\n"; 		for(j=0;j<n;j++) 		{ 			l=0; 			strcpy(r,p[j]); 			xstrupr(r); 			strcpy(s,q); 			xstrupr(s); 			for(k=0;*(r+k)!='\0';k++) 			{ 				if(*(s+l)==*(r+k)) l++; 				if(l==strlen(s)) break; 			} 			if(l==strlen(q)) cout<<*(p+j)<<endl; 		} 	} 	return 0; }
#include <list> #include <set> #include <map> #include <ctime> #include <stack> #include <string> #include <vector> #include <cstdio> #include <cmath> #include <queue> #include <deque> #include <bitset> #include <cstdlib> #include <cctype> #include <cstring> #include <iterator> #include <cassert> #include <fstream> #include <numeric> #include <iomanip> #include <complex> #include <sstream> #include <iostream> #include <algorithm> using namespace std;   #define For(i,n) for( int i=0; i < n; i++) #define FOR(i,a,b) for( __typeof(b) i=(a); i<=(b); i++) #define ALL(c)  c.begin() , c.end() #define LL long long #define int64 LL #define Set(t,v) memset((t), (v), sizeof(t))  typedef vector < int > VI; typedef pair< int , int > PII; typedef pair < LL , LL > PLL; #define fr first #define se second #define pi M_PI #define rad(x) (x)*acos(-1)/180.0 #define EPS 1e-6 #define INF 10000*10000 stringstream ss; #define two(x) ( 1LL<<x ) #define sq(x) ( (x)*(x) ) LL mod = 1000000007LL;  /**************************Code****************************/  int a[64][64], h[64], n, iter[64]; int dp[2510][55], mx; int pre[2510][55][55]; int mymap[10010]; map < int , int > mp;  int f( int x , int cur ) { 	if( x == mx ) 		return 0; 	if( dp[x][cur] != -1 ) 		return dp[x][cur]; 	int ret = 100000; 	for( int l = 0 ; l < n ; l ++ ) 		ret = min( ret , pre[x][cur][l] + f( x+1 , l ) ); 	return dp[x][cur] = ret; }  int main() { 	int t, cc = 0; 	cin >> t; 	while( t -- ) 	{ 		memset( a , 0 , sizeof a ); 		memset( h , 0 , sizeof h ); 		memset( pre , 0 , sizeof pre ); 		memset( iter , 0 , sizeof iter ); 		mp.clear(); 		cin >> n; 		for( int i = 0 ; i < n ; i ++ ) 		{ 			cin >> h[i]; 			for( int j = 0 ; j < h[i] ; j ++ ) 			{ 				cin >> a[i][j]; 				mp[ a[i][j] ] ++; 			} 			int tmp = h[i]; 			h[i] = 0; 			for( int j = 0 ; j < tmp ; j ++ ) 				if( !j || a[i][j] != a[i][j-1] ) 					a[i][ h[i] ++ ] = a[i][j]; 		} 		int cnt = 0; 		for( map < int , int > :: iterator it = mp.begin() ; it != mp.end() ; it ++ ) 			mymap[ it->fr ] = cnt ++; 		for( int i = 0 ; i < n ; i ++ ) 			for( int j = 0 ; j < h[i] ; j ++ ) 				a[i][j] = mymap[ a[i][j] ]; 		for( int k = 0 ; k < cnt ; k ++ ) 		{ 			for( int i = 0 ; i < n ; i ++ ) 				while( iter[i]+1 < h[i] && a[i][ iter[i]+1 ] <= k ) 					iter[i] ++; 			for( int i = 0 ; i < n ; i ++ ) 				for( int j = 0 ; j < n ; j ++ ) 				{ 					int flag = 0; 					for( int l = 0 ; l < n ; l ++ ) 						if( iter[l] < h[l] && a[l][ iter[l] ] == k ) 						{ 							if( l != j ) 								pre[k][i][j] ++, flag = 1; 							if( l != j && iter[l] < h[l]-1 ) 								pre[k][i][j] ++; 						} 					if( i != j && k ) 					{ 						if( iter[i] < h[i] && a[i][ iter[i] ] != k ) 						{ 							pre[k][i][j] ++; 							if( iter[i] < h[i]-1 ) 								pre[k][i][j] ++; 						} 					} 					if( i == j && k && flag ) 						pre[k][i][j] += 2; 				} 		} 		mx = cnt; 		memset( dp , -1 , sizeof dp ); 		int ans = f( 0 , 0 ); 		cout << "Case " << ++ cc << ": " << ans << endl; 	} 	return 0; } 
#include <list> #include <set> #include <map> #include <ctime> #include <stack> #include <string> #include <vector> #include <cstdio> #include <cmath> #include <queue> #include <deque> #include <bitset> #include <cstdlib> #include <cctype> #include <cstring> #include <iterator> #include <cassert> #include <fstream> #include <numeric> #include <iomanip> #include <complex> #include <sstream> #include <iostream> #include <algorithm> using namespace std;   #define For(i,n) for( int i=0; i < n; i++) #define FOR(i,a,b) for( __typeof(b) i=(a); i<=(b); i++) #define ALL(c)  c.begin() , c.end() #define LL long long #define int64 LL #define Set(t,v) memset((t), (v), sizeof(t))  typedef vector < int > VI; typedef pair< int , int > PII; typedef pair < LL , LL > PLL; #define fr first #define se second #define pi M_PI #define rad(x) (x)*acos(-1)/180.0 #define EPS 1e-6 #define INF 10000*10000 stringstream ss; #define two(x) ( 1LL<<x ) #define sq(x) ( (x)*(x) ) LL mod = 1000000007LL;  /**************************Code****************************/  char mat[5][5];  void ok( int x , int y , int &ans ) { 	int now = ( mat[x][y] == 'A' ? 1 : 2 ); 	if( x+2 < 5 && mat[x][y] == mat[x+1][y] && mat[x][y] == mat[x+2][y] ) 		ans |= now; 	if( y+2 < 5 && mat[x][y] == mat[x][y+1] && mat[x][y] == mat[x][y+2] ) 		ans |= now; 	if( x+2 < 5 && y+2 < 5 && mat[x][y] == mat[x+1][y+1] && mat[x][y] == mat[x+2][y+2] ) 		ans |= now; 	if( x-2 >= 0 && y+2 < 5 && mat[x][y] == mat[x-1][y+1] && mat[x][y] == mat[x-2][y+2] ) 		ans |= now; }  int main() { 	int k; 	cin >> k; 	while( k -- ) 	{ 		int ans = 0; 		for( int i = 0 ; i < 5 ; i ++ ) 			for( int j = 0 ; j < 5 ; j ++ ) 				cin >> mat[i][j]; 		for( int i = 0 ; i < 5 ; i ++ ) 			for( int j = 0 ; j < 5 ; j ++ ) 				ok( i , j , ans ); 		if( !ans || ans == 3 ) 			cout << "draw" << endl; 		else if( ans == 1 ) 			cout << "A wins" << endl; 		else 			cout << "B wins" << endl; 	} 	return 0; } 
#include <list> #include <set> #include <map> #include <ctime> #include <stack> #include <string> #include <vector> #include <cstdio> #include <cmath> #include <queue> #include <deque> #include <bitset> #include <cstdlib> #include <cctype> #include <cstring> #include <iterator> #include <cassert> #include <fstream> #include <numeric> #include <iomanip> #include <complex> #include <sstream> #include <iostream> #include <algorithm> using namespace std;   #define For(i,n) for( int i=0; i < n; i++) #define FOR(i,a,b) for( __typeof(b) i=(a); i<=(b); i++) #define ALL(c)  c.begin() , c.end() #define LL long long #define int64 LL #define Set(t,v) memset((t), (v), sizeof(t))  typedef vector < int > VI; typedef pair< int , int > PII; typedef pair < LL , LL > PLL; #define fr first #define se second #define pi M_PI #define rad(x) (x)*acos(-1)/180.0 #define EPS 1e-6 #define INF 10000*10000 stringstream ss; #define two(x) ( 1LL<<x ) #define sq(x) ( (x)*(x) ) LL mod = 1000000007LL;  /**************************Code****************************/   int main() { 	int t, n, x, y; 	cin >> t; 	while( t -- ) 	{ 		cin >> n; 		int cnt[4] = {0}; 		for( int i = 0 ; i < n ; i ++ ) 		{ 			cin >> x >> y; 			double r = sqrt( x*x + y*y ); 			if( r + EPS <= 60. ) 				cnt[0] ++; 			else if( r + EPS <= 120. ) 				cnt[1] ++; 			else if( r + EPS <= 180. ) 				cnt[2] ++; 			else if( r + EPS <= 200. ) 				cnt[3] ++; 		} 		cout << cnt[0] << " " << cnt[1] << " " << cnt[2] << " " << cnt[3] << endl; 	} 	return 0; } 
#include<iostream> #include<stdio.h> using namespace std;  int main(){  	int T; 	cin>>T; 	bool visited[1007] = {false}; 	while(T--){ 		int N; 		cin>>N; 		if(visited[N%1007]==false){ 			visited[N%1007]=true; 			cout<<N%1007<<endl; 		} 	} 	return 0;  } 
#include<stdio.h> main() {       int t;       scanf("%d",&t);       while(t--)       {                 int n;                 scanf("%d",&n);                 int arr[n],i;                 for(i=0;i<n;i++)                 scanf("%d",&arr[i]);                 int max_ind=0;                 int max_val=arr[0];                 for(i=1;i<n;i++)                 {                                 if(arr[i]>max_val)                                 {                                                   max_val=arr[i];                                                   max_ind=i;                                 }                 }                 printf("%d\n",max_ind+1);       } }                                         
#include<stdio.h> int main() {     int n,m;     scanf("%d%d",&n,&m);     int index[m];     for(int i=0;i<m;i++)     {         index[i]=i+1;     }     for(int i=0;i<m;i++)     {         if(i!=(m-1))             printf("%d ",index[i]);         else             printf("%d\n",index[i]);     }      for(int i=1;i<=m;i++)     {         if((index[m-i]+1)>(n-i+1))         {             if(i==m)                 break;         }         else         {             index[m-i]+=1;             for(int j=i-1;j>=1;j--)             {                 index[m-j]=index[m-j-1]+1;             }             for(int j=0;j<m;j++)             {                 if(j!=(m-1))                     printf("%d ",index[j]);                 else                     printf("%d\n",index[j]);             }             i=0;         }     } } 
#include <iostream> #include <cstring> using namespace std;   int main() {     long long int t;     cin>>t;     while(t--)     {         long long n;         cin>>n;           signed long long d[n][3];         memset(d,0,sizeof(d));         for (long long i = 0; i<n; i++)         {             cin>>d[i][0]>>d[i][1]>>d[i][2];         }         if (n>1)         {             for (long long i = n-2; i>=0; i--)             {                 d[i][0] =d[i][0] + min(d[i+1][1],d[i+1][2]);                 d[i][1] =d[i][1] + min(d[i+1][0],d[i+1][2]);                 d[i][2] =d[i][2] + min(d[i+1][0],d[i+1][1]);             }         }         long long ans = d[0][0];         ans = min(ans,d[0][1]);         ans = min(ans,d[0][2]);         cout<<ans<<endl;     }       return 0; }
#include <bits/stdc++.h> using namespace std;  int main() { 	int t; 	cin >>t; 	while(t--){ 	    string num; 	    int k,l,i,r=0; 	    cin >>num; 	    cin >>k; 	    l=num.size(); 	     	    for(i=0;i<l;i++){ 	        r=r*10+(num[i]-48); 	        if(r<k) 	            continue; 	        r=r%k;     	    } 	    if(r==0) 	        cout <<"YES\n"; 	    else 	        cout <<"NO\n"; 	} 	return 0; } 
/*Author :rednivrug15 */ #pragma comment(linker,"/STACK:5677216") #include <bits/stdc++.h> #define pb push_back #define mp make_pair #define rep(i,n) for(int i=0; i<n ; i++) using namespace std; #define mod (int)((1e9)+7) #define REP(i,n) for (int i = 1; i <= n; i++)  long long power(long long a,long long b) {     long long ret=1;     while(b)     {         if(b%2==1)             ret=(ret*a)%mod;         a=(a*a)%mod;         b/=2;     }     return ret; } long long gcd(long long a,long long b) {     return b==0?a:gcd(b,a%b); }  #define N 500 double ans[N]={50.000000,57.735027,62.996052,66.874030,69.882712,72.302003,74.299714,75.983569,77.426368,78.679344,79.779740,80.755366,81.627464,82.412575,83.123790,83.771625,84.364637,84.909862,85.413150,85.879407,86.312781,86.716807,87.094517,87.448527,87.781110,88.094247,88.389679,88.668937,88.933377,89.184205,89.422493,89.649204,89.865201,90.071259,90.268082,90.456304,90.636504,90.809206,90.974890,91.133994,91.286920,91.434037,91.575684,91.712174,91.843796,91.970817,92.093485,92.212030,92.326664,92.437586,92.544982,92.649024,92.749873,92.847681,92.942588,93.034728,93.124224,93.211193,93.295746,93.377986,93.458010,93.535911,93.611774,93.685683,93.757715,93.827944,93.896439,93.963266,94.028487,94.092163,94.154350,94.215101,94.274467,94.332498,94.389239,94.444735,94.499028,94.552158,94.604164,94.655082,94.704948,94.753794,94.801653,94.848557,94.894533,94.939612,94.983818,95.027180,95.069721,95.111465,95.152437,95.192656,95.232146,95.270926,95.309016,95.346435,95.383202,95.419333,95.454846,95.489757,95.524081,95.557835,95.591032,95.623688,95.655814,95.687426,95.718534,95.749153,95.779293,95.808966,95.838184,95.866957,95.895296,95.923210,95.950710,95.977805,96.004504,96.030816,96.056750,96.082314,96.107517,96.132366,96.156869,96.181033,96.204865,96.228373,96.251564,96.274444,96.297019,96.319296,96.341280,96.362978,96.384396,96.405539,96.426412,96.447021,96.467371,96.487467,96.507314,96.526917,96.546280,96.565407,96.584304,96.602975,96.621423,96.639653,96.657668,96.675474,96.693073,96.710468,96.727665,96.744666,96.761475,96.778095,96.794529,96.810780,96.826853,96.842749,96.858471,96.874024,96.889408,96.904629,96.919687,96.934585,96.949327,96.963915,96.978351,96.992638,97.006777,97.020773,97.034626,97.048338,97.061913,97.075353,97.088658,97.101832,97.114877,97.127793,97.140584,97.153252,97.165797,97.178222,97.190529,97.202719,97.214794,97.226756,97.238607,97.250347,97.261979,97.273504,97.284924,97.296240,97.307453,97.318565,97.329578,97.340493,97.351310,97.362032,97.372660,97.383195,97.393638,97.403991,97.414255,97.424430,97.434518,97.444521,97.454439,97.464274,97.474026,97.483696,97.493287,97.502798,97.512230,97.521586,97.530865,97.540069,97.549198,97.558254,97.567237,97.576148,97.584989,97.593760,97.602462,97.611095,97.619661,97.628161,97.636594,97.644963,97.653267,97.661508,97.669686,97.677802,97.685857,97.693851,97.701786,97.709661,97.717478,97.725237,97.732939,97.740584,97.748173,97.755707,97.763187,97.770612,97.777985,97.785304,97.792571,97.799786,97.806951,97.814064,97.821128,97.828142,97.835108,97.842025,97.848894,97.855716,97.862491,97.869220,97.875902,97.882540,97.889132,97.895680,97.902184,97.908645,97.915062,97.921437,97.927769,97.934060,97.940310,97.946518,97.952686,97.958814,97.964903,97.970951,97.976962,97.982933,97.988866,97.994762,98.000620,98.006441,98.012226,98.017974,98.023686,98.029363,98.035004,98.040611,98.046182,98.051720,98.057223,98.062693,98.068130,98.073534,98.078905,98.084243,98.089550,98.094824,98.100067,98.105279,98.110460,98.115611,98.120731,98.125821,98.130881,98.135912,98.140913,98.145885,98.150829,98.155744,98.160631,98.165490,98.170321,98.175124,98.179901,98.184650,98.189373,98.194069,98.198738,98.203382,98.208000,98.212592,98.217158,98.221700,98.226216,98.230708,98.235175,98.239618,98.244036,98.248431,98.252802,98.257149,98.261473,98.265773,98.270051,98.274306,98.278538,98.282748,98.286936,98.291102,98.295245,98.299367,98.303468,98.307547,98.311605,98.315642,98.319658,98.323653,98.327628,98.331583,98.335517,98.339432,98.343326,98.347201,98.351056,98.354892,98.358708,98.362506,98.366284,98.370044,98.373785,98.377507,98.381211,98.384897,98.388565,98.392214,98.395846,98.399460,98.403057,98.406636,98.410198,98.413742,98.417270,98.420780,98.424274,98.427751,98.431212,98.434656,98.438084,98.441496,98.444891,98.448271,98.451635,98.454983,98.458315,98.461632,98.464933,98.468220,98.471491,98.474747,98.477988,98.481214,98.484425,98.487622,98.490804,98.493972,98.497126,98.500265,98.503390,98.506501,98.509598,98.512681,98.515751,98.518806,98.521849,98.524877,98.527893,98.530895,98.533884,98.536860,98.539822,98.542772,98.545709,98.548634,98.551545,98.554444,98.557330,98.560205,98.563066,98.565916,98.568753,98.571578,98.574391,98.577192,98.579982,98.582759,98.585525,98.588279,98.591022,98.593753,98.596473,98.599181,98.601878,98.604564,98.607239,98.609903,98.612556,98.615198,98.617829,98.620449,98.623059,98.625658,98.628246,98.630824,98.633391,98.635949,98.638495,98.641032,98.643558,98.646074,98.648581,98.651077,98.653563,98.656039,98.658506,98.660963,98.663410,98.665847,98.668275,98.670694,98.673103,98.675502,98.677893,98.680273,98.682645,98.685008,98.687361,98.689705,98.692041,98.694367,98.696684,98.698993,98.701293,98.703584,98.705866,98.708140,98.710405,98.712661,98.714909,98.717149,98.719380,98.721603,98.723817,98.726024,98.728222,98.730411,98.732593,98.734767,98.736933,98.739090,98.741240,98.743382,98.745516,98.747642,98.749760,98.751871,98.753974,98.756070,98.758158,98.760238,98.762311,98.764376};  int main() {     int T;     cin >> T;      while( T--)     {         int n;         cin >> n;         printf("%.6lf\n",ans[n-1]);     }     return 0; }  //62.876998 //66.743663 
#include <assert.h> #include <memory.h> #include <algorithm> #include <cmath> #include <cstdio> #include <iomanip> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <string> #include <vector>  using namespace std;  #define pb push_back #define INF 1011111111 #define FOR(i, a, b) for (int _n(b), i(a); i < _n; i++) #define rep(i, n) FOR(i, 0, n) #define CL(a, v) memset((a), (v), sizeof(a)) #define mp make_pair #define X first #define Y second #define all(c) (c).begin(), (c).end() #define SORT(c) sort(all(c))  typedef long long ll; typedef vector<int> VI; typedef pair<int, int> pii;  /*** TEMPLATE CODE ENDS HERE */  struct Point {   int x, y;   double p;   Point() {     x = y = 0;     p = 0.0;   }   Point(int xx, int yy, int pp) {     x = xx;     y = yy;     p = pp / 100.0;   } };  bool operator<(Point a, Point b) { return a.x * b.y < b.x * a.y; }  Point tab[1000007];  int main() { #ifdef LOCAL_HOST   freopen("input.txt", "r", stdin); // freopen("output.txt","w",stdout); #endif    int n;   scanf("%d", &n);   rep(i, n) {     int p1, p2, p3;     scanf("%d%d%d", &p1, &p2, &p3);     tab[i] = Point(p1, p2, p3);   }    sort(tab, tab + n);    double area = 0;   double ox = 0, oy = 0;   rep(i, n) {     area += tab[i].p * (ox * tab[i].y - oy * tab[i].x);     ox += tab[i].p * tab[i].x;     oy += tab[i].p * tab[i].y;   }    printf("%.9lf\n", -area);  #ifdef LOCAL_HOST   printf("TIME: %.3lf\n", double(clock()) / CLOCKS_PER_SEC); #endif    return 0; } 
#include <assert.h> #include <memory.h> #include <algorithm> #include <cmath> #include <cstdio> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <string> #include <vector>  using namespace std;  #define pb push_back #define INF 1011111111 #define FOR(i, a, b) for (int _n(b), i(a); i < _n; i++) #define rep(i, n) FOR(i, 0, n) #define CL(a, v) memset((a), (v), sizeof(a)) #define mp make_pair #define X first #define Y second #define all(c) (c).begin(), (c).end() #define SORT(c) sort(all(c))  typedef long long ll; typedef vector<int> VI; typedef pair<int, int> pii;  /*** TEMPLATE CODE ENDS HERE */  int g[2000][64]; int not_used[64];  void solve() {   int n;   cin >> n;   rep(i, n) {     rep(x, 64) g[i][x] = 0;     rep(j, n) {       int x;       cin >> x;       if (x) {         g[i][j >> 5] |= 1 << (j & 31);       }     }   }   int best_range = numeric_limits<int>::max();   int best_city = -1;   rep(i, n) {     queue<int> q;     vector<int> dist(n, std::numeric_limits<int>::max());     rep(x, 64) not_used[x] = -1;     q.push(i);     not_used[i >> 5] ^= 1 << (i & 31);     dist[i] = 0;     while (!q.empty()) {       int u = q.front();       q.pop();       int du = dist[u];       rep(x, 64) {         int interesting = not_used[x] & g[u][x];         if (interesting) {           rep(y, 32) {             if ((interesting >> y) & 1) {               int v = (x << 5) + y;               dist[v] = du + 1;               q.push(v);             }           }           not_used[x] ^= interesting;         }       }     }     int max_dist = *std::max_element(all(dist));     if (max_dist < best_range) {       best_range = max_dist;       best_city = i;     }   }   if (best_city == -1) {     cout << -1 << endl;   } else {     cout << best_range << ' ' << best_city + 1 << endl;   } }  void run() {   int t;   cin >> t;   while (t--) {     solve();   } }  int main() { #ifdef LOCAL_HOST   freopen("input.txt", "r", stdin); // freopen("output.txt","w",stdout); #endif    ios_base::sync_with_stdio(false);   cin.tie(nullptr);   run();   cout.flush();  #ifdef LOCAL_HOST   printf("TIME: %.3lf\n", double(clock()) / CLOCKS_PER_SEC); #endif    return 0; } 
#include <bits/stdc++.h> using namespace std;  #define ms(s, n) memset(s, n, sizeof(s)) #define FOR(i, a, b) for (int i = (a); i < (b); i++) #define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--) #define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++) #define sz(a) int((a).size()) #define all(a) (a).begin(), (a).end() #define uni(a) (a).erase(unique(all(a)), (a).end()) #define pb push_back #define pf push_front #define mp make_pair #define fi first #define se second #define prec(n) fixed<<setprecision(n) #define bit(n, i) ((n) & (1LL << (i))) #define bitcount(n) __builtin_popcount(n) typedef long long ll; typedef unsigned long long ull; typedef long double ld; typedef pair<int, int> pi; typedef vector<int> vi; typedef vector<pi> vii; #define EPS 1e-9 const int MOD = (int) 1e9 + 7; const int INF = (int) 1e9; const ll LINF = (ll) 1e18; const ld PI = 2 * acos((ld) 0); ll gcd(ll a, ll b) {ll r; while (b != 0) {r = a % b; a = b; b = r;} return a;} ll lcm(ll a, ll b) {return a / gcd(a, b) * b;} ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;} void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;} void addmod(ll& a, ll val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}  const int maxn = 2010; int n; int a[maxn]; int b[maxn]; int x[maxn]; int c[maxn]; int sum[maxn][maxn]; int r[maxn]; int pw[maxn][maxn]; int rp[maxn][maxn];  void solve() { 	cin>>n; 	FOR(i, 1, n + 1) cin>>a[i]; 	FOR(i, 1, n + 1) { 		x[i] = MOD - i; 		pw[i][0] = 1; rp[i][0] = 1; rp[i][1] = fpow(x[i], MOD - 2); 		FOR(j, 1, n + 1) { 			pw[i][j] = (ll) pw[i][j - 1] * x[i] % MOD; 			rp[i][j] = (ll) rp[i][j - 1] * rp[i][1] % MOD; 		} 	} 	c[0] = MOD - 1; c[1] = 1; 	FOR(i, 2, n + 1) { 		FORd(j, n + 1, 0) { 			c[j] = (ll) c[j] * x[i] % MOD; 			if (j) addmod(c[j], c[j - 1]); 		} 	} 	reverse(c, c + n + 1); 	FOR(i, 1, n + 1) { 		FOR(j, 0, n + 1) { 			if (j) sum[i][j] = sum[i][j - 1]; 			int d = (ll) rp[i][j] * c[j] % MOD; 			if (!(j & 1)) addmod(sum[i][j], d); 			else addmod(sum[i][j], MOD - d); 		} 	} 	FOR(i, 1, n + 1) { 		FOR(j, 1, n + 1) { 			int d = (ll) pw[i][j] * sum[i][j - 1] % MOD; 			if (!(j & 1)) d = MOD - d; 			r[j] = (c[j] - d + MOD) % MOD; 		} 		reverse(r, r + n); 		r[n - 1] = 1; 		int C = 1; 		FOR(j, 1, n + 1) if (i != j) { 			C = (ll) C * (i - j + MOD) % MOD; 		} 		int tot = 0; 		FOR(j, 1, n + 1) addmod(tot, (ll) r[j - 1] * a[j] % MOD); 		b[i] = (ll) tot * fpow(C, MOD - 2) % MOD; 	} 	FOR(i, 0, n) { 		int res = 0; 		FORd(j, n + 1, 0) { 			res = ((ll) res * i + b[j]) % MOD; 		} 		cout<<res<<" "; 	} }  int main() { 	ios_base::sync_with_stdio(0); cin.tie(0); #ifdef _LOCAL_ 	freopen("in.txt", "r", stdin); //freopen("out.txt", "w", stdout); #endif 	solve(); #ifdef _LOCAL_ 	//printf("\nTime elapsed: %dms", 1000 * clock() / CLOCKS_PER_SEC); #endif 	return 0; } 
#include <bits/stdc++.h> using namespace std;   typedef long long LL;   #define PII       pair<LL,LL> #define all(c)    c.begin(),c.end() #define sz(c)     (int)c.size() #define clr(c)    c.clear() #define pb        push_back #define mp        make_pair #define cin(x)	scanf("%d" , &x) #define MOD		1000000007 #define EPS       1E-10  LL BigMod(LL a,LL b,LL mod) {       if(!b) return 1;       LL x = BigMod(a,b/2,mod);       x = (x*x)%mod;       if(b&1) return (x*a)%mod;       else return x; }  LL modinv(LL a,LL mod = MOD) {       return BigMod(a,mod-2,mod); }   int main() { 	LL n,k,m; 	cin >> n >> k >> m; 	if(n == 1 || k == 1) 		cout << m << endl; 	else if(k == 2) 	{ 		LL ans = 2 * n - 1; 		ans *= m; 		ans %= MOD; 		cout << ans << endl; 	} 	else if(k == 3) 	{ 		LL ans = 1LL * n * n + 1LL * (n - 1) * (n - 1); 		ans %= MOD; 		ans = (ans * m) % MOD; 		cout << ans << endl; 	} 	else if(k==4) 	{ 		n -= 1; 		LL ans = (n*(n+1)) % MOD; 		ans = (ans * (4*n + 2)) % MOD; 		ans = (ans * modinv(3 , MOD)) % MOD; 		ans += (2*n+1); 		ans %= MOD; 		ans = (ans * m) % MOD; 		cout << ans << endl; 	} 	else 	{ 		n -= 1; 		LL f = (n*n+n) % MOD; 		LL ans = (2 * f * f) % MOD; 		ans = (ans + 2 * f) % MOD; 		ans = (ans * modinv(3)) % MOD; 		ans = (ans + 2 * f + 1) % MOD; 		ans = (ans * m) % MOD; 		cout << ans << endl;  	} 	return 0; }
#include<bits/stdc++.h> #include <ext/pb_ds/assoc_container.hpp> #include <ext/pb_ds/tree_policy.hpp>  using namespace __gnu_pbds; using namespace std; #define SF(x)	scanf("%d", &x) #define PF(x)	printf("%d", x) #define psp     printf(" ") #define pnl     printf("\n") #define pie     cout<<" # "<<endl #define charint(c) ((c)-'0') #define pii pair< int, int > #define pb(x) push_back(x) #define test int t; scanf("%d",&t);while(t--) #define forall(i,a,b) for(int i=(a);i<=(b);++i) #define NFOR(i,a,b) for(int i=(a);i>=(b);--i) #define boost ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0) #define gcd(a,b)   __gcd(a,b) #define bss binary_search #define ersort(x)       (sort((x).rbegin(), (x).rend())) #define rev(v)      (reverse(v.begin(),v.end())) #define vmax(v)     (*max_element(v.begin(),v.end())) #define vmin(v)     (*min_element(v.begin(),v.end())) #define MAX		100050 #define INF		1e9 #define mod     1000000007 #define fi first #define se second inline bool isPowerOfTwo(int x){ return (x != 0 && (x&(x - 1)) == 0); } typedef long long 		ll; typedef unsigned long long	ull; typedef tree<int, null_type, less<int>, rb_tree_tag,tree_order_statistics_node_update> ordered_set; inline int add(int a,int b, int m=mod){a+=b;if(a>=m)a-=m;return a;} inline int mul(int a,int b, int m=mod){return (int)(((ll)a*(ll)b)%m);} ll expo(ll base,ll pow){     ll ans = 1;     while(pow!=0){         if(pow&1==1){             ans = ans*base;             ans = ans%mod;         }         base *= base;         base%=mod;         pow/=2;     }     return ans; } ll inv(ll x){     return expo(x,mod-2); } int expFactor(int n, int p) {     int x = p;     int exponent = 0;     while ((n/x) > 0)     {         exponent += n/x;         x *= p;     }     return exponent; } inline int countsetbit(int n) {     unsigned int count = 0;     while (n)     {       n &= (n-1) ;       count++;     }     return count; } inline int abs(int x){ 	if(x<0) 	return -x; 	return x; } ll _sieve_size;  bitset<10000010> bs;  vector <int> primes;  void sieve(ll upperbound) {  	_sieve_size = upperbound + 1;  	bs.set(); 	bs[0] = bs[1] = 0; 	for (ll i = 2; i <= _sieve_size; i++)  	if (bs[i]) { 		for (ll j = i * i; j <= _sieve_size; j += i)  			bs[j] = 0; 		primes.push_back((int)i);  	}  }  bool isPrime(ll N) { if (N <= _sieve_size) return bs[N];  for (int i = 0; i < (int)primes.size(); i++) if (N % primes[i] == 0) return false; return true; } int n,m,val[MAX],wt[MAX];long double cv[MAX]; bool ck(long double mi){ 	forall(i,0,n-1){ 		cv[i]=val[i]-mi*wt[i]; 	} 	sort(cv,cv+n,greater<long double>()); 	long double tp=0; 	forall(i,0,m-1){ 		tp+=cv[i]; 	} 	return (tp>=0); } int main(){ 	test{ 		cin>>n>>m; 		forall(i,0,n-1) 		cin>>val[i]>>wt[i]; 		long double lw=0,he=2e5,mi; 		while(he-lw>(1e-8)){ 			mi=(lw+he)/2.0; 			if(ck(mi)){ 				lw=mi; 			} 			else 			{ 				he=mi; 			} 		} 		double as=(he+lw)/2.0; 		printf("%.8lf\n",as); 	} } 
#include<bits/stdc++.h>  using namespace std; typedef long long ll; int ar[17]; ll dp[34000][1107]; int DV, K; int n = 0;  int c = 1; ll  f(int idx, int bmsk, int modulo) {  	if (idx == n) { 		if (modulo == K) 			return 1; 		else 			return 0; 	} 	if (dp[bmsk][modulo] != -1) 		return dp[bmsk][modulo];  	ll ans = 0; 	int xyar[10] = {0};  	for (int i = 0; i < n; i++) { 		if ( (bmsk & (1 << i)) == 0) { 			if (xyar[ar[i]] == 0)  			{ 				//cout <<ar[i]<<"^^"<<endl; 				//ll x = (modulo * 10 + ar[i]) % DV;  				ans += f ( idx+1, bmsk | (1 << i), (modulo * 10 + ar[i])%DV); 				xyar[ar[i]] = 1; 			} 		} 	}  	dp[bmsk][modulo] = ans; 	return ans;  } int main() { 	memset(dp, -1LL, sizeof(dp)); 	ll  num; 	cin >> num >> DV >> K; 	 	if (num == 0) { 		if (K > 0) cout <<"0\n"; 		else cout <<"1\n"; 		return 0; 	} 	while (num > 0) { 		ar[n] = num % 10; 		num /= 10; 		n++; 	} 	cout <<f(0,0,0)<<endl; 	return 0; }  
#include <bits/stdc++.h> using namespace std; typedef long long LL; const int MAXN = 100000 + 10, K = 17, M = 1e9 + 7;  vector<int> G[MAXN]; int dep[MAXN], f[MAXN][K + 1]; int st[MAXN], ed[MAXN], loc[MAXN << 1]; int n, m, P, dfn;  void dfs(int x, int par = -1) {   loc[st[x] = dfn++] = x;   for (int i = 1; i <= K; ++i) f[x][i] = f[f[x][i - 1]][i - 1];   for (auto &y: G[x]) if (y != par) {     dep[y] = dep[f[y][0] = x] + 1;     dfs(y, x);   }   loc[ed[x] = dfn++] = x; } int lca(int x, int y) {   if (x == y) return x;   if (dep[x] < dep[y]) swap(x, y);   for (int i = K; ~i; --i) {     if (dep[f[x][i]] >= dep[y]) x = f[x][i];   }   if (x == y) return x;   for (int i = K; ~i; --i) {     if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];   }   return f[x][0]; }  int val[MAXN], inv[MAXN], vis[MAXN], sum; int cnt[MAXN], mul[MAXN], ans[MAXN]; void deal(int x) {   int c = val[x]; vis[x] ^= 1;   sum += M - mul[c]; if (sum >= M) sum -= M;   if (!vis[x]) {     mul[c] = 1ll * mul[c] * inv[c] % M;     if (--cnt[c] == 0) mul[c] = 0;   }   else {     if (++cnt[c] == 1) mul[c] = 1;     mul[c] = 1ll * mul[c] * c % M;   }   sum += mul[c]; if (sum >= M) sum -= M; }  struct Node {   int l, r, z, id;   bool operator < (const Node &rhs) {     return l / P == rhs.l / P ? r < rhs.r : l / P < rhs.l / P;   } } Q[MAXN];  int main() {   scanf("%d", &n);   for (int i = 1; i <= n; ++i) scanf("%d", val + i);   for (int i = 1; i < n; ++i) {     int u, v; scanf("%d%d", &u, &v);     G[u].push_back(v);     G[v].push_back(u);   }   dfs(dep[1] = 1);   P = sqrt(n * 2);   scanf("%d", &m);   for (int i = 0; i < m; ++i) {     int x, y; scanf("%d%d", &x, &y);     if (st[x] > st[y]) swap(x, y);     int z = lca(x, y); Q[i].id = i;     if (z == x) Q[i].l = st[x], Q[i].r = st[y];     else Q[i].l = ed[x], Q[i].r = st[y], Q[i].z = z;   }   sort(Q, Q + m);   inv[1] = 1; sum = 0;   for (int i = 2; i < MAXN; ++i) {     inv[i] = LL(M - inv[M % i]) * (M / i) % M;   }   for (int i = 0, l = 0, r = -1; i < m; ++i) {     if (r < Q[i].r) {       for (++r; r <= Q[i].r; ++r) deal(loc[r]);       --r;     }     for (; r > Q[i].r; --r) deal(loc[r]);     for (; l < Q[i].l; ++l) deal(loc[l]);     if (l > Q[i].l) {       for (--l; l >= Q[i].l; --l) deal(loc[l]);       ++l;     }     if (Q[i].z) deal(Q[i].z);     ans[Q[i].id] = sum;     if (Q[i].z) deal(Q[i].z);   }   for (int i = 0; i < m; ++ i) printf("%d\n", ans[i]);   return 0; } 
/*Author :rednivrug15 */ #pragma comment(linker,"/STACK:5677216") #include <bits/stdc++.h> #define pb push_back #define mp make_pair #define rep(i,n) for(int i=0; i<n ; i++) using namespace std; #define mod (int)((1e9)+7) #define REP(i,n) for (int i = 1; i <= n; i++)   long long power(long long a,long long b) {     long long ret=1;     while(b)     {         if(b%2==1)             ret=(ret*a)%mod;         a=(a*a)%mod;         b/=2;     }     return ret; } long long gcd(long long a,long long b) {     return b==0?a:gcd(b,a%b); }     int main() {     int t;     scanf("%d",&t);       while(t--)     {         long long L;         int n;         scanf("%d %lld",&n,&L);           vector < pair < long long, int > > coins(n);         for( int i=0; i<n; i++ )         {             scanf("%lld",&coins[i].first);             coins[i].second=i;         }           sort(coins.begin(),coins.end());           if( coins[0].first!=1 )         {             printf("-1\n");             continue;         }           vector < long long > ans(n,0);         bool flag=false;         long long sum=0;           for( int i=0; i<n; ++i )         {             if( sum>=coins[i].first)             {                 flag=true;                 break;             }             sum += coins[i].first;             ans[coins[i].second]++;               long long remaining;               if( i!=n-1 )                 remaining=coins[i+1].first-sum-1;             else                 remaining=L-sum;               if( remaining>0 )             {                 ans[coins[i].second] += (remaining+coins[i].first-1)/coins[i].first;                 sum += ((remaining+coins[i].first-1)/coins[i].first)*coins[i].first;             }         }           if( flag==true || sum>L)         {             puts("-1");             continue;         }           for( int i=0; i<n; i++)             printf("%lld ",ans[i]);         puts("");     }     return 0; }
#include<bits/stdc++.h> using namespace std;  int main() {    int N,K ;    cin >> N >> K ;    int A[1001] ;    for(int i=0 ; i<N ; i++){ 	   cin >> A[i] ;    }    sort(A,A+N) ;    cout << A[K-1] ; }  
#include <bits/stdc++.h> using namespace std;  int main(){     int t;     cin >> t;     while(t--){         int n;         map < pair<int,int>, int> a;         cin >> n;         for(int i = 0; i < n; i++){             int x,y;             cin >> x >> y;             a[make_pair(x,y)]++;         }         int ans = 0;         for(int i = 0; i < 100; i++){             for(int j = 0; j < 100; j++){                 ans = max(ans,a[make_pair(i,j)]);             }         }         cout << ans << endl;     } } 
#include<cstdio> #include<iostream> using namespace std; int main() {     int t;     long long int n,b,d,p[100],q[100],y,i;     scanf("%d",&t);     while(t--)     {         scanf("%lld %lld %lld",&n,&b,&d);          for(i=0;i<d;i++)         {             scanf("%lld %lld",&p[i],&q[i]);           }         for(i=d-1;i>=0;i--)         {              if(b>=p[i])                b+=q[i]-p[i]+1;          }         if(b<=n)             printf("%lld\n",b);         else             printf("-1\n");      }  } 
#include<bits/stdc++.h> using namespace std; long long fac[10135]; long long Pow(long long b,long long p) {     if(p==0)         return 1;     long long temp=Pow(b,p/2);     temp*=temp;     temp%=1000000007;     if(p%2)temp*=b;     temp%=1000000007;     return temp; } int main() {     long long i,j,k,T,n,a,b;     scanf("%lld",&T);     fac[0]=1;     for(i=1;i<=10005;i++)     {         fac[i]=fac[i-1]*i;         fac[i]%=1000000007;     }     while(T--)     {         scanf("%lld %lld",&n,&k);         if(n<k)         {             printf("-1\n");         }         else         {             a=fac[n-1];             b=fac[k-1]*fac[n-k];             b%=1000000007;             printf("%lld\n",(a*Pow(b,1000000005))%1000000007);         }     } }
#include<iostream> #include<cstdio> #include<cmath> #include<vector> #include<map> #include<set> #include<algorithm> #include<list> #include<cstring> #include<stack> #include<queue> using namespace std; #define ll long long #define vi vector<int> #define vii vector<vi > #define pp pair<int,int> #define pb push_back #define mp make_pair #define ppl pair<ll,ll> #define vl vector<ll> #define vll vector<vl > #define vb vector<bool> #define llu unsigned ll #define all(c) c.begin(),c.end() #define mod 1000000007 #define sc scanf #define pf printf ll power(ll a,ll b) { 	if(!b) 		return 1; 	if(b==1) 		return a; 	ll temp=power(a,b/2); 	temp=(temp*temp); 	if(b&1) 		temp=(temp*a); 	return temp; } int euler( int n) { 	int res, i; 	res = n; 	for( i=2;i*i<=n;i++ ) 	{ 		if( n%i == 0 ) 		{ 			res -= (res/i); 			while( n%i == 0 ) 			{ 				n /= i; 			} 		} 	} 	if( n ^1) 	{ 		res -= (res/n); 	} 	return res; } int main() { 	ios_base::sync_with_stdio(false); 	int i, t, n, ans, num1, num2,val; 	cin >> t; 	while( t--) 	{ 		cin >> n; 		ans = euler(n); 		cout << ans << "\n"; 	} 	//cin >> n;     return 0; } 
#include<bits/stdc++.h> #define s(n) scanf("%d",&n) #define sl(n) scanf("%lld",&n) #define p(n) printf("%d\n",n) #define mod 1000000007 #define ll long long #define pb push_back #define mp make_pair #define N 100011 #define ma 1e9 using namespace std;  struct node {  int id; }n1,n2;  vector<pair<int,int> >v[1002]; int red[1002]; ll ans[1002]; int vis[1002]; int n,m,i,j,des,cst,t,src;  bool operator<(const struct node &a,const struct node &b) {  return ans[a.id]>ans[b.id]; }  void djistra(int sr) {      for(i=1;i<=n;++i)ans[i]=-1;     memset(vis,0,sizeof(vis));     priority_queue<node>pq;     ans[sr]=0;     vis[sr]=1;     n1.id=sr;     pq.push(n1);      while(!pq.empty())     {         n2=pq.top();         pq.pop();          for(i=0;i<v[n2.id].size();++i)         {             int did=v[n2.id][i].first;             ll css=v[n2.id][i].second;              if(red[did]<css)             css-=red[did];             css+=ans[n2.id];              if(vis[did]==0)             {                 n1.id=did;                 vis[did]=1;                 ans[did]=css;                 pq.push(n1);             }             else if(css<ans[did])             {                 n1.id=did;                 ans[did]=css;                  pq.push(n1);             }           }     } }  int main() {        cin>>t;       while(t--)      {         for(i=1;i<=1000;++i)         v[i].clear();          cin >> n >> m;         for(i=0;i<m;++i)         {             cin>>src>>des>>cst;             v[src].pb(mp(des,cst));         }          for( i=1; i<=n ; ++i)         cin >> red[i];          int ss,dd;         cin >> ss >> dd;          djistra(ss);         if(ans[dd]!=-1)         cout<<ans[dd]*10<<endl;         else         cout<<ans[dd]<<endl;      }     return 0; } 
#include <iostream> #include <stdio.h> #include <math.h> #include <string.h> #include <stdlib.h> using namespace std ; struct data {     int point ;     bool f; }; long long func(int base , int exp) {     long long ans = 1 ;     for(int i=0;i<exp;i++){         ans*=base ;     }     return ans ; } int main() {     int t ; cin >> t ;     while(t--){         struct data d[256];         for(int i=0;i<256;i++){                 d[i].point = -1;                 d[i].f=false;         }         string str ; cin >> str ;         int counter=0;         for(int i=0;i<str.size();i++){                 if(d[int(str[i])].f == false){                     d[int(str[i])].f = true ;                     counter++;                 }         }         if(counter==1){counter++;}         d[int(str[0])].point = 1 ;         int curr=0;         for(int i=1;i<str.size();i++){             if(d[int(str[i])].point == -1){                 d[int(str[i])].point = curr ;                 curr++ ;                 if(curr==1){curr++;}             }         }         long long answer=0;         for(int i=str.size()-1;i>=0;i--){                 answer+=(d[int(str[i])].point)*func(counter,str.size()-1-i);         }         cout << answer << endl ;     }     return  0 ;  } 
#include<bits/stdc++.h> using namespace std; //long long int marks[INT_MAX]; int main() {    long long int n,i,top1=1,top2=1,mark,top,small;     scanf("%lld",&n);     scanf("%lld%lld",&top1,&top2);     for(i=2;i<n;i++)     {         scanf("%lld",&mark);         if(mark>=top1)         {             if(top1>=top2)             {                 top2=top1;             }             top1=mark;         }         else if(mark>=top2)         {             top2=mark;         }      }     top=top1>top2?top1:top2;     small=top1<top2?top1:top2;     cout<<top<<" "<<small<<"\n";  return 0; } 
#include<stdio.h> #define mod 1000000009 void scanlong(unsigned long long &x){     char c = getchar_unlocked();     x = 0;     while(c<'0'||c>'9'){         c=getchar_unlocked();     }     while(c>='0'&&c<='9'){         x= (x<<1)+ (x<<3) + c - '0';         c=getchar_unlocked();     } } void scanint(int &x){     char c = getchar_unlocked();     x = 0;     while(c<'0'||c>'9'){         c=getchar_unlocked();     }     while(c>='0'&&c<='9'){         x= (x<<1)+ (x<<3) + c - '0';         c=getchar_unlocked();     } } unsigned long long a[3][3]={{0,0,1},{1,0,1},{0,1,0}}; void power(unsigned long long b){     unsigned long long c[3][3];     for(int i=0;i<3;i++){         for(int j=0;j<3;j++){             c[i][j]=0;         }         c[i][i]=1;     }     while(b){         if(b&1){             unsigned long long temp[3][3]={0};             for(int i=0;i<3;i++){                 for(int j=0;j<3;j++){                     for(int k=0;k<3;k++){                         temp[i][j]+=(a[i][k]*c[k][j])%mod;                         temp[i][j]%=mod;                     }                 }             }             for(int i=0;i<3;i++)                 for(int j=0;j<3;j++)                     c[i][j]=temp[i][j];            }         unsigned long long temp[3][3]={0};         for(int i=0;i<3;i++){             for(int j=0;j<3;j++){                 for(int k=0;k<3;k++){                     temp[i][j]+=(a[i][k]*a[k][j])%mod;                     temp[i][j]%=mod;                 }             }         }         for(int i=0;i<3;i++){             for(int j=0;j<3;j++){                 a[i][j]=temp[i][j];             }         }             b>>=1;     }     for(int i=0;i<3;i++)         for(int j=0;j<3;j++)             a[i][j] =c[i][j]; } int main(){     int t;     scanint(t);     int f[5]={0,0,1,1,1};     while(t--){         a[0][0]=0;         a[0][1]=0;         a[0][2]=1;         a[1][0]=1;         a[1][1]=0;         a[1][2]=1;         a[2][0]=0;         a[2][1]=1;         a[2][2]=0;         unsigned long long n;         scanlong(n);         if(n<5){             printf("%d\n",f[n]);         }         else{             unsigned long long c[3][3]={{0,0,1},{0,1,1},{1,1,1}};             power(n-4);             unsigned long long ans = (c[2][0] * a[0][2])%mod;             ans+=(c[2][1] * a[1][2])%mod;             ans%=mod;             ans+=(c[2][2]*a[2][2])%mod;             printf("%llu\n",ans%mod);         }     } }
#include <bits/stdc++.h> using namespace std; #define ll long long int  #define mod (ll)(1e9 + 7) ll a[100001]; ll tree[500000][2];  struct tag {     int a1,a2; }; void build(ll node , ll start , ll end){    if( start > end )   return;   if( start == end ){     if( start & 1 )     tree[node][1] = a[start];     else     tree[node][0] = a[start];   }   else {       ll mid = (start + end)/2;     build(2*node,start,mid);     build(2*node+1,mid+1 , end);     tree[node][1] = max(tree[2*node][1],tree[2*node+1][1]);     tree[node][0] = max(tree[2*node][0],tree[2*node+1][0]);   } } void update(ll node , ll start ,ll  end , ll ind , ll val){  if(start>end || ind< start || ind > end )  return ;  if(start==end){      if(start & 1){          tree[node][1] = val;      }      else      tree[node][0] = val;  }  else{      ll mid = (start + end)/2;      update(2*node , start , mid , ind , val);      update(2*node+1 , mid+1 , end , ind , val);      tree[node][0] = max(tree[2*node][0]  , tree[2*node+1][0]);      tree[node][1] = max(tree[2*node][1]  , tree[2*node+1][1]);  } }   tag  query(ll node,ll start , ll end , ll L ,ll R){    tag ans;      if( start > end || L > end || R < start ) {      ans.a1=ans.a2=0;     return ans;     }     if(  start >= L && end <= R ) {       ans.a1=tree[node][0];       ans.a2=tree[node][1];      return ans;      }      else {       tag p = query(2*node,start,(start+end)/2,L,R);       tag q = query(2*node+1,(start+end)/2+1,end,L,R);       ans.a1=max(p.a1,q.a1);       ans.a2=max(p.a2,q.a2);       return ans;   }  } int main() { 	int n,q; 	cin >> n >> q; 	for(int i=1;i<=n;i++) { 	  cin  >> a[i]; 	  } 	 build(1,1,n);  	 while(q--) { 	   int ch,x,y; 	   cin >> ch >> x >> y; 	   if(ch == 1)  	     update(1,1,n,x,y); 	   else { 	    tag res = query(1,1,n,x,y); 	     cout << res.a1+res.a2 << endl; 	     } 	    } 	return 0; }
#include <bits/stdc++.h>  #define INF_MAX 2147483647 #define INF_MIN -2147483647 #define INF_LL 9223372036854775807LL #define INF 1000000000 #define EPS 1e-8 #define LL long long #define mod 1000000007 #define pb push_back #define mp make_pair #define f first #define s second #define setzero(a) memset(a,0,sizeof(a)) #define setdp(a) memset(a,-1,sizeof(a)) #define bits(a) __builtin_popcount(a)  using namespace std;  int a[100005], b[100005];  vector<int> tree[400005]; vector<long long> suma[400005]; vector<long long> sumb[400005];  int cmp(int x, int y) { 	if (a[x] == 0 && b[x] == 0) 		return 1; 	if (a[y] == 0 && b[y] == 0) 		return 0; 	return (a[x] * 1ll * b[y] < a[y] * 1ll * b[x]); }  void build(int i, int l, int r) { 	if (l > r) 		return; 	if (l == r) 	{ 		tree[i] = vector<int>(); 		tree[i].push_back(l); 		suma[i].push_back(a[l]); 		sumb[i].push_back(b[l]); 		return; 	} 	build(i*2 + 1, l, (l+r) / 2); 	build(i * 2 + 2, (l+r) / 2 + 1, r); 	tree[i] = vector<int> (); 	int all = tree[i*2 + 1].size(); 	all += tree[i*2 + 2].size(); 	int f, s; 	f = s = 0; 	for (int j = 0; j < all; j++){ 		if (f == tree[i*2 + 1].size()) 	    { 	    	tree[i].push_back(tree[i*2 + 2][s++]); 	    } 	    else if (s == tree[i*2 + 2].size()) 	    { 	    	tree[i].push_back(tree[i*2 + 1][f++]); 	    } 	    else if (cmp(tree[i*2 + 1][f],tree[i*2 + 2][s])) 	    { 	    	tree[i].push_back(tree[i*2 + 1][f++]); 	    } 	    else 	    { 	    	tree[i].push_back(tree[i*2 + 2][s++]); 	    } 	    suma[i].push_back(a[tree[i][j]]); 	    sumb[i].push_back(b[tree[i][j]]); 	    if (j) 	    { 	      suma[i][j] += suma[i][j-1]; 	      sumb[i][j] += sumb[i][j-1]; 	    } 	} }  LL query(int i, int l, int r, int x, int y, int c, int d) { 	if (l > r) 		return 0;   if(l >= x && r <= y)   {     int L = 0, R = tree[i].size() - 1;     if(a[tree[i][R]] * 1ll * c <= d * 1ll * b[tree[i][R]])       return 0;     while(R > L)     {       int mid = L + (R - L) / 2;       if(a[tree[i][mid]] * 1ll * c > d * 1ll * b[tree[i][mid]])         R = mid;       else L = mid + 1;     }     return (suma[i][tree[i].size() - 1] - (R == 0 ? 0 : suma[i][R-1])) * 1LL * c - (sumb[i][tree[i].size() - 1] - (R == 0 ? 0 : sumb[i][R-1])) * 1LL * d;   }   if(l > y || r < x)     return 0;   return query(i*2 + 1, l, (l + r) / 2, x, y, c, d) + query(i*2 + 2, (l + r) / 2 + 1, r, x, y, c, d); }  int main() {   int t, n, l, r, x, y, q;   scanf("%d", &n);   for(int i=0;i<n;i++)   {   	scanf("%d", &a[i]); //  	a[i] = 1000000;   }        for(int i=0;i<n;i++)   {   	scanf("%d", &b[i]); //  	b[i] = 1000000;   }        build(0, 0, n - 1);   scanf("%d", &q);   while(q--)   {     scanf("%d %d %d %d", &l, &r, &x, &y);     l--, r--;     printf("%lld\n", query(0, 0, n - 1, l, r, x, y));     fflush(stdout);   }   return 0; } 
/*  *  p.cpp  *  Created on: Aug 1, 2016  *  Author: Tarun Anand  *  Copyright (c) 2016 Tarun Anand. All rights reserved.  */ #include<bits/stdc++.h> #include<sstream> using namespace std; #define mod 1000000007 #define all(v) v.begin(),v.end() #define loop(i,a,b) for(i=a;i<b;i++) #define revloop(i,a,b) for(i=a;i>=b;i--) #define stloop(it,v) for(it=v.begin();it!=v.end();++it) #define ii pair<int,int> #define MP make_pair #define pb push_back #define ll long long int #define fill(v,d) memset(v,d,sizeof(v)) #define c 100000 int main() {  std::ios::sync_with_stdio(false);    cin.tie(0);    ll t,i,n;    cin>>t;    while(t--)    { cin>>n;      cout<<2*n-1<<endl;    }    return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { 	int t,n,i,num,a,b; 	cin>>t; 	while(t--) 	{ 		a=2; 		b=3; 		scanf("%d",&n); 		for(i=3;i<=n;i++) 		{ 			num=b+2*a; 			a=b; 			b=num; 		} 		if(n==1)	num=a; 		else if(n==2)	num=b; 		printf("%d\n",num); 	} 	return 0; }
/*                                      _____  _____   ____    ____   _____                    __    ____  _____                                     |      |     | |    \  |      |       |\    /| |     | |   \ |     |                                     |      |     | |     | |___   |____   | \  / | |     | | __/ |___  |____                                     |      |     | |     | |           |  |  \/  | |     | |  \  |          |                                     |_____ |_____| |____/  |____  _____|  |      | |_____| |   \ |     _____| */ #include<bits/stdc++.h> using namespace std; #define pn() printf("\n") #define s(x) scanf("%lld",&x) #define p(x) printf("%lld\n",x) #define sc(x) scanf("%c",&x) #define pc(x) printf("%c",x) #define sf(x) scanf("%f",&x) #define pf(x) printf("%f\n",x) #define sd(x) scanf("%lf",&x) #define pd(x) printf("%.7lf\n",x) #define sld(x) scanf("%Lf",&x) #define pld(x) printf("%.9Lf\n",x) #define loop(i,n) for(i=0;i<n;i++) #define loop(i,n) for(i=1;i<=n;i++) #define dloop(i,a,b) for(i=a;i<=b;i++) #define rloop(i,a,b) for(i=n;i>=k;i--) #define M 1000000007 #define ll long long #define pi  3.1415926535 #define exp  2.7182818284 int main() {     ll t,n,ans,ansf;     s(t);     while(t--)     {         s(n);         if(n<6)             printf("FIGHT\n");         else{         ans=(((((n-5)%M*(n-4)%M)%M*(n-3)%M)%M*(n-2)%M)%M*(n-1)%M)%M;         ansf=((ans)*808333339)%M;         printf("%lld\n",ansf);}     }     return 0; } 
/*	Template by 	Ashwin Kumar 	IIT Delhi */ #include<algorithm> #include<iostream> #include<cassert> #include<cmath> #include<cstdio> #include<cstdlib> #include<cstring> #include<sstream> #include<string> #include<ctime> #include<deque> #include<map> #include<queue> #include<set> #include<stack> #include<vector>	 using namespace std;  typedef pair<int, int> pii; typedef long long LL; #define MOD 1000000007 #define INF 1000000000  double ans[10000]; int timr[10000]; int maxv[10000]; int A, D;  double getTime(int i) { 	double t = (double)maxv[i]/A; 	double d = 0.5*t*t*A; 	if (d >= D) 		return sqrt((2.0*D)/A); 	else 		return (t+(D-d)/maxv[i]); }  //Returns 1 if magnets i-1 and i collide int checkCollision(int i) { 	if (timr[i]+getTime(i) > ans[i-1]) 		return 0;					 	return 1; }  int main() { 	int T; 	scanf("%d", &T); 	for (int t = 0; t < T; t++) { 		int N; 		scanf("%d %d %d", &N, &A, &D); 		for (int i = 0; i < N; i++) 			scanf("%d %d", &timr[i], &maxv[i]); 		ans[0] = timr[0]+getTime(0); 		for (int i = 1; i < N; i++) { 			if (checkCollision(i)) 				ans[i] = ans[i-1]; 			else 				ans[i] = timr[i]+getTime(i); 		} 		for (int i = 0; i < N; i++) 			printf("%.8lf\n", ans[i]); 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; int main() {     int i,t,n,c=0,l,flag,val;     char *s;     s=(char*)malloc(10000000*sizeof(char));     scanf("%d",&t);     map<char,int>::iterator it;     while(t--)     {         flag=1;         l=0;         cin>>s;         n=strlen(s);         map<char,int> m;         for(i=0;i<n;i++)             m[s[i]]++;         for(it=m.begin();it!=m.end();it++)         {             val=it->second;             if(val%2)                 l++;             if(l>1)             {                 flag=0;                 break;             }         }         if(flag)         {             if(l==1)             {                 if(n%2)                     c++;             }             else             {                 c++;             }         }     }     printf("%d",c); } 
#include <iostream> #include <sstream> #include <cstdio> #include <climits> #include <cstdlib> #include <algorithm> #include <cmath> #include <cstring> #include <string> #include <deque> #include <bitset> #include <map> #include <set> #include <stack> #include <list> #include <vector> #include <queue>  #define FORN(i,a,b) for (int i = (a); i <= (b); i++) #define FOR(i,a,b) for (int i = (a); i < (b); i++) #define SI ({int x; scanf("%d%*c", &x); x;}) #define SL ({long long int x; scanf("%lld%*c", &x); x;}) #define PN(x) ({printf("%d\n", x);}) #define PLN(x) ({printf("%lld\n", x);}) #define PS(x) ({printf("%d ", x);}) #define PLS(x) ({printf("%lld ", x);}) #define NL ({printf("\n");}) #define printarr(i, x, y) ({for(int i=0;i<y;i++){ printf("%d ", x[i]);} printf("\n");}) #define inputarr(i, x, y) ({for(int i=0;i<y;i++){ scanf("%d", &x[i]);}}) #define LL long long #define PI 3.14285714286 #define U unsigned #define MP(a,b) make_pair(a,b) #define pb(a) push_back(a) #define INF 0x3f3f3f3f #define gc getchar_unlocked #define UPPER(s) transform(s.begin(),s.end(),s.begin(),std::ptr_fun<int, int>(std::toupper)); #define LOWER(s) transform(s.begin(),s.end(),s.begin(),std::ptr_fun<int, int>(std::tolower)); #define COUNT(a,val) count(a.begin(),a.end(),val)  void scanint(int &x) {     register int c = gc();     x = 0;     for(;(c<48 || c>57);c = gc());     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} }  inline int gcd(int a, int b) { while(b) b^=a^=b^=a%=b; return a; }  using namespace std; LL p1[302][302], p2[302][302]; /*long long int powmod(LL int a,LL int b,LL int c){     long long x=1,y=a;     while(b > 0){         if(b%2 == 1){             x=(x*y)%c;         }         y = (y*y)%c; // squaring the base         b /= 2;     }     return x%c; }*/ LL MOD; LL powmod(LL N,LL P) { 	if(P==0) 		return 1; 	LL Res = powmod(N,P/2); 	if(P&1) 		return (((Res*Res)%MOD)*N)%MOD; 	else 		return (Res*Res)%MOD; } int main() { 	int test; 	scanf("%d", &test); 	while(test--) 	{ 		LL rows, cols,a1,a2,b1,b2,m; 		scanf("%lld%lld", &rows, &cols); 		scanf("%lld%lld%lld%lld%lld", &a1, &a2, &b1, &b2, &m); 		LL rowmax[302], colmax[302]; 		memset(rowmax, 0, sizeof(rowmax)); 		memset(colmax, 0, sizeof(colmax)); 		MOD = m; 		FOR(i,0,rows) 		{ 			FOR(j,0,cols) 			{	 				p1[i][j]= powmod(a1*(i+1) + a2*(j+1), m-2); 				p2[i][j]= powmod(b2*(i+1) + b1*(j+1), m-2); 				rowmax[i] =max(rowmax[i], p2[i][j]); 			} 		} 		FOR(i,0,cols) 		{ 			FOR(j,0,rows) 			{ 				colmax[i] = max(colmax[i], p1[j][i]); 			} 		} 		bool tog=0; 		int nashrow, nashcol=-1; 		FOR(i,0,rows) 		{ 			FOR(j,0,cols) 			{ 				if(p1[i][j] == colmax[j] && p2[i][j]== rowmax[i]) 				{ 					tog=1; 					nashrow = i; nashcol = j; break; 				} 			} 			if(tog) 				break; 		} 		if(nashcol!=-1) 			printf("%d %d\n", nashrow+1, nashcol+1); 		else printf("-1\n"); 	} 	return 0; } 
/*	Template by 	Ashwin Kumar 	IIT Delhi */ #include<algorithm> #include<iostream> #include<cassert> #include<cmath> #include<cstdio> #include<cstdlib> #include<cstring> #include<sstream> #include<string> #include<ctime> #include<deque> #include<map> #include<queue> #include<set> #include<stack> #include<vector>	 using namespace std;  typedef pair<int, int> pii; typedef long long LL; #define MOD 1000000003 #define INF 1000000000 #define MAX 10000000000000000LL  int N; vector<int> arr[18]; LL dp[18][262144];  LL runDP(int i, int match) { 	if (i == N) 		return 1; 	if (dp[i][match] != -1) 		return dp[i][match]; 	LL &ans = dp[i][match]; 	ans = 0; 	for (int j = 0; j < arr[i].size(); j++) { 		int k = arr[i][j]; 		int pos = (1<<k); 		if ((match&pos) == 0) 			ans = (ans+runDP(i+1, match^pos))%MOD;  	} 	return ans; }  int main() { 	int T; 	scanf("%d", &T); 	for (int t = 0; t < T; t++) { 		int M, x, y; 		scanf("%d %d", &N, &M); 		for (int i = 0; i < N; i++) 			arr[i].clear(); 		for (int i = 0; i < M; i++) { 			scanf("%d %d", &x, &y); 			arr[x].push_back(y-N); 		} 		memset(dp, -1, sizeof dp); 		printf("%d\n", runDP(0, 0)); 	} 	return 0; } 
#include<iostream> #include<cassert> #include<cstdlib> #include<cstring> #include<utility> #include<sstream> #include<algorithm> #include<cstdio> #include<vector> #include<string> #include<cctype> #include<queue> #include<deque> #include<stack> #include<cmath> #include<ctime> #include<list> #include<map> #include<set> #define pi (acos(-1.0)) #define Abs(a) (((a)<0) ? (-(a)) :(a) ) #define rep(i,n) for((i)=0;(i)<(n);(i)++) #define Rep(i,n) for(int i=0;i<(n);i++) #define Rrep(i,n) for(int i=n-1;i>=0;i--) #define rrep(i,n) for((i)=(n)-1;(i)>=0;(i)--) #define Pii pair<int,int> #define PB push_back #define Size(x) ((int)(x.size())) #define MIN(a,b) ((a)<(b) ? (a):(b)) #define MAX(a,b) ((a)>(b) ? (a):(b)) using namespace std; typedef long long mint; typedef unsigned long long umint; char a[5001],b[5001]; int d[2][2][5005][5005]; int main() {     //freopen("in.txt","r",stdin);     int t,T,sa,sb,k,mx,ka,kb;     int i,j;     scanf("%d",&T);     for(t=1; t<=T; t++)     {         scanf("%d%d%d",&sa,&sb,&k);         scanf("%s%s",a,b);         if(k>min(sa,sb))         {             puts("-1");             continue;         }         rep(ka,2)         rep(kb,2)         for(i=0; i<=sa; i++)             for(j=0; j<=sb; j++)             {                 if(ka*k>i||kb*k>j)                 {                     d[ka][kb][i][j]=-1;                     continue;                 }                 else                     d[ka][kb][i][j]=0;                 if(i==0||j==0)                     continue;                 if(a[i-1]==b[j-1])                 {                     //cout<<"oria "<<d[ka][kb][i-1][j-1]<<endl;                     d[ka][kb][i][j]=MAX(d[ka][kb][i][j],(d[ka][kb][i-1][j-1]+1));                 }                 d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[ka][kb][i][j-1]);                 d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[ka][kb][i-1][j]);                 if(ka)                 {                     d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[0][kb][i-k][j]);                 }                 if(kb)                 {                     d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[ka][0][i][j-k]);                 }                 if(ka&&kb)                 {                     d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[0][0][i-k][j-k]);                 }                 //cout<<ka<<" "<<kb<<" "<<i<<" "<<j<<" "<<d[ka][kb][i][j]<<endl;             }         //cout<<d[1][1][sa][sb]<<endl;         printf("%d\n",MAX(0,d[1][1][sa][sb]));     }     return 0; }   
 #include<bits/stdc++.h> #define all(x) x.begin(), x.end() #define pb(x) push_back(x) #define cout2(x, y) cout << x << " " << y << endl #define N 302 #define M 100002 #define MOD 1000000007  using namespace std;  int memo[2][N][M]; long long f[N];  int main(){  	int tc; 	scanf("%d", &tc); 	 	for(int i = 1; i < M; i++)memo[0][1][i] = memo[1][1][i] = 1; 	 	for(int i = 2; i < N; i++){ 		for(int j = 1; j < M; j++){ 		 			//no he quitado 			if(j >= i)memo[0][i][j] = memo[1][i][j - i]; 			if(memo[0][i][j] >= MOD)memo[0][i][j] -= MOD; 			 			//ya he quitado 			memo[1][i][j] = memo[0][i - 1][j]; 			if(j >= i)memo[1][i][j] += memo[1][i][j - i]; 			if(memo[1][i][j] >= MOD)memo[1][i][j] -= MOD; 			 		} 	} 	 	f[0] = 1; 	for(int i = 1; i < N; i++)f[i] = (f[i - 1] * i)%MOD; 	 	while(tc--){ 		 		int n, m; 		scanf("%d%d", &n, &m); 		printf("%lld\n", (f[n] * memo[0][n][m])%MOD); 	 	} } 
#include<stdio.h> #include<string.h> typedef int ll; int main() { 	ll n,q,i,t,a,b,k; 	char at[27]="abcdefghijklmnopqrstuvwxyz"; 	ll pos[200]; 	for(i=0;i<26;i++) 	pos[at[i]]=i+1; 	scanf("%d",&t); 	char ar[5006]; 	ll cum[5005]; 	while(t--) 	{ 		memset(cum,0,sizeof(cum)); 	scanf("%d%d",&n,&q); 	scanf("%s",ar); 	while(q--) 	{ 		scanf("%d%d%d",&a,&b,&k); 		a--; 		b--; 		cum[a]=cum[a]+k; 		cum[b+1]=cum[b+1]-k; }    for(i=1;i<n;i++)    cum[i]=cum[i]+cum[i-1];    for(i=0;i<n;i++)    {    	if(cum[i]>=0)    	ar[i]=(at[(pos[ar[i]]+cum[i]-1)%26]);    	else    	{    		cum[i]=(cum[i]%26)+26;    		 	ar[i]=(at[((pos[ar[i]]+cum[i]-1))%26]); 	   } } 	for(i=0;i<n;i++) 	printf("%c",ar[i]); 	printf("\n"); } return 0; } 
#include <iostream> #include <algorithm> #include <cstdio> #include <cstdlib> #include <vector> #include <cstring> #include <string> #include <cmath> #include <ctime> #include <utility> #include <map> #include <set> #include <queue> #include <stack> #include <sstream> #define FOR(a,b,c) for (int a=b,_c=c;a<=_c;a++) #define FORD(a,b,c) for (int a=b;a>=c;a--) #define REP(i,a) for(int i=0,_a=(a); i<_a; ++i) #define REPD(i,a) for(int i=(a)-1; i>=0; --i) #define pb push_back #define mp make_pair #define fi first #define se second #define sz(a) int(a.size()) #define reset(a,b) memset(a,b,sizeof(a)) #define oo 1000000000000000007ll  using namespace std;  typedef long long ll; typedef pair<int, int> pii; typedef pair<ll, int > plli;  const int maxn = 100007;   int main() { 	//freopen("test.txt","r",stdin);  	int qr;  	cin >> qr;  	for (int i1 = 0; i1 < qr; ++i1) { 		set<plli> myset; 		vector<pii> a[maxn]; 		vector<int> list; 		bool free1[maxn]; 		int n, m, t, trace[maxn]; 		ll d[maxn];  		scanf("%d%d%d", &n, &m, &t); 		int u, v, w; 		REP(i, m) { 			scanf("%d%d%d", &u, &v, &w); 			a[u].pb(pii(v, w)); 			a[v].pb(pii(u, w)); 		}  		for (int i2 = 0; i2 < t; ++i2) { 			int rr; 			cin >> rr; 			reset(free1, 1); 			d[1] = 0; 			FOR(i, 2, n) d[i] = oo; 			myset.insert(pii(0, 1)); 			while (!myset.empty()) { 				u = myset.begin()->se; myset.erase(myset.begin()); 				free1[u] = 0; 				REP(i, sz(a[u])) { 					v = a[u][i].fi; w = a[u][i].se; 					if (free1[v] && d[v]>d[u] + w) { 						if (d[v] != oo) myset.erase(myset.find(plli(d[v], v))); 						d[v] = d[u] + w; 						trace[v] = u; 						myset.insert(plli(d[v], v)); 					} 				} 			}  			if (d[rr] == oo) printf("-1\n"); 			else { 				cout << d[rr] << endl; 			} 		} 	}  	 	//getch(); 	return 0; }
#pragma comment(linker, "/STACK:102400000,102400000") #include <iostream> #include <stdio.h> #include <algorithm> #include <string.h> #include <vector> #include <map> #include <queue> #include <set> #include <cmath> #include <fstream> #include <assert.h> #include <complex> using namespace std; #define vi vector<int> #define pii pair<int,int> #define pb push_back #define mp make_pair #define all(x) x.begin(),x.end() #define inf 1000000007 #define mod 1000000007 #define x first #define y second #define pi acos(-1.0) #define DBG(x) cerr<<(#x)<<"="<<x<<"\n"; #define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++) #define ull unsigned long long #define ll long long #define N 100010  struct node; node *null,*root; struct node{     node *left,*right;     int id,sz,rng,sum;     void init(int x=0){         id=x;if(x)sz=sum=1;else sz=sum=0;         left=right=null;         rng=rand();     }     void upd(){         sum=right->sum+left->sum+(id!=0);     } }t[N<<2]; int sz=0; node* newnode(int x=0){     sz++;     node *e=&t[sz];     e->init(x);     return e; } pii a[N]; node* merge(node* a,node* b){     if(a==null)return b;     if(b==null)return a;     if(a->rng>=b->rng){         a->right=merge(a->right,b);         a->upd();         return a;     }     b->left=merge(a,b->left);     b->upd();     return b; } void split(node *rt,node* &a,node* &b,int k){     if(k==0){         a=null;b=rt;return;     }     if(rt->sum==k){         a=rt,b=null;return;     }     if(rt->left->sum>=k){         //b=newnode();         b=rt;         split(rt->left,a,b->left,k);         b->upd();     }     else{         //a=newnode();         a=rt;         split(rt->right,a->right,b,k-rt->left->sum-rt->sz);         a->upd();     } } int p[N],n1=0,vis[N],b[N];vi q[N]; pii ti[N]; void query(node *rt){     if(rt==null)return;     query(rt->left);     if(rt->sz)p[n1++]=rt->id-1;     query(rt->right); } ll ex_gcd(ll a,ll b,double &x,double &y){     if(b==0){         x=1;y=0;return a;     }     double x1,y1;     ll d=ex_gcd(b,a%b,x1,y1);     x=y1;     y=(x1-a/b*x);     return d; } ll solve(vector<pii>&v){     int n=v.size(),i;     ll a=1,n1=0;     for(i=0;i<n;i++){         ll b=v[i].x,n2=v[i].y,c=n2-n1;         //if(c<0)swap(a,b),swap(n1,n2),c=-c;         double x1,y1;         ll d=ex_gcd(a,b,x1,y1);         //assert(c%d==0);         x1*=(c/d);         assert(x1<=1e18&&x1>=-1e18);         ll x=((ll)x1)%(b/d);         if(x<0)x+=b/d;         ll y=(c-a*x)/b;         ll m,g=a/d*b;         if(y<=0)m=(a*x+n1)%g;         else{             ll a1=a/d;             ll k=(y+a1-1)/a1;             y%=a1;             if(y>0)y-=a1;             m=(-y*b+n2)%g;         }         a=a/d*b;         m%=a;         if(m<0)m+=a;         n1=m;     }     return n1; } int main() {     //freopen("2.txt","w",stdout);     int T,i,j,k,ca=0,n,m;     scanf("%d%d%d",&n,&m,&T);     for(i=0;i<m;i++)scanf("%d%d",&a[i].x,&a[i].y);     null=&t[0];null->init();     root=null;     for(i=1;i<=n;i++){         node *e=newnode(i);         root=merge(root,e);     }     //DBG(root->sum)     for(i=0;i<m;i++){         int l=a[i].x,r=a[i].y;         node *a,*b,*d;         split(root,a,b,l-1);         //DBG(a->sum)         //DBG(b->sum)         split(b,b,d,r-l+1);         //DBG(b->sum)         //DBG(d->sum)         root=merge(b,a);         //DBG(root->sum)         root=merge(root,d);         //DBG(root->sum)     }     query(root);     //for(i=0;i<n;i++)printf("%d ",p[i]);     //puts("");     n1=0;     for(i=0;i<n;i++)if(!vis[i]){         j=i;         while(!vis[j]){             q[n1].pb(j),vis[j]=1;j=p[j];         }         for(j=0;j<q[n1].size();j++)ti[q[n1][j]]=mp(n1,j);         n1++;     }     //DBG(n1)     if(T){         ll K;cin>>K;         for(i=0;i<n;i++){             j=ti[i].x;int x=ti[i].y;             k=q[j].size();             printf("%d ",q[j][(x+K)%k]+1);         }     }     else{         vector<pii>ans;         for(i=0;i<n;i++)scanf("%d",&j),j--,b[i]=j;         for(i=0;i<n1;i++){             j=q[i][0];             k=q[i].size();             int x=b[j],y=ti[x].x;             //if(i!=y)while(1);             y=ti[x].y;             //DBG(y)             ans.pb(mp(k,y));         }         sort(all(ans));         ans.erase(unique(all(ans)),ans.end());         ll res=solve(ans);         printf("%lld\n",res);     }          return 0; }
#include<iostream> #include<cstdio>  using namespace std;  int N;  void solve() {     scanf("%d", &N);     float res = N;     int i=2;     int n= N;     while(N>1 && i<=n)     {         if((N%i)== 0)         {             while((N%i) == 0)             {                 N/= i;             }             res*=(1-(1.0/i));         }         i++;     }     int ans = res;     printf("%d\n", ans); }  int main() {     #ifndef ONLINE_JUDGE     //freopen("input.txt","r",stdin);    // freopen("output.txt","w",stdout);     #endif     int t;     scanf("%d", &t);      while(t--)     {         solve();     } } 
#include<bits/stdc++.h> using namespace std; bool prime[1000001]; void primearrayformation(){ 	int i,p; 	prime[1]=false; 	 for (p=2;p*p<=1000000;p++)     {         if (prime[p] == true)         {             for (i=p*2;i<=1000000;i+=p)                 prime[i]=false;         }     } } int main(){ 	 	int n,i; 	scanf("%d",&n); 	int a[n]; 	for(i=0;i<1000001;i++){ 		prime[i]=true; 	} 	primearrayformation(); 	for(i=0;i<n;i++) 	scanf("%d",&a[i]); 	int q; 	scanf("%d",&q); 	while(q--){ 	    int l,r,count=0; 	    scanf("%d%d",&l,&r); 	    for(i=0;i<n;i++){ 	    	if(a[i]>=l&&a[i]<=r&&prime[a[i]]==true) 	    	count++; 	    } 	    printf("%d\n",count); 	} }
#include <bits/stdc++.h> using namespace std;  int a[100001];  int main(){     int t;     cin >> t;     while(t--){         string s;         cin >> s;         for(int i = 0; i <= 26; i++) a[i] = 0;         for(int i = 0; i < s.length(); i++) a[s[i]- 'a']++;         int ans  = INT_MAX;         for(int i = 0; i <= 26; i++){             int pt = 0;             for(int j = 0; j <= 26; j++){                 pt += (i-j)*a[j];             }             pt = abs(pt);             ans = min(ans,pt);         }         cout << ans << endl;     } } 
#include<bits/stdc++.h> using namespace std;  const int N=123; int a[N], f[N];  int main() {     int test;     scanf("%d", &test);     while(test--) {         int n;         scanf("%d", &n);         for(int i=1;i<=n;i++) {             scanf("%d", &a[i]);         }         f[0]=0;         for(int i=1;i<=n;i++) {             f[i]=-1e9;             for(int j=1;j<=i;j++) {                 f[i]=max(f[i], f[i-j]+a[j]);             }         }         printf("%d\n", f[n]);     } } 
//Aayush Agarwal  #include<bits/stdc++.h> using namespace std;  #define fOr(i,n) for(int i=0;i<n;i++) #define For(i,n) for(int i=1;i<=n;i++) #define ss(a) scanf("%s",a) #define si(a) scanf("%d",&a) #define sl(a) scanf("%lld",&a) #define pi(a) printf("%d ",a) #define pl(a) printf("%lld ",a) #define ps(a) printf("%s ",a) #define nl    printf("\n") #define ll long long int #define ull unsigned long long int #define MOD 1000000009 #define INF 2000000000 #define two(X) (1<<(X)) #define twoL(X) (((int64)(1))<<(X)) #define contain(S,X) (((S)&two(X))!=0) #define containL(S,X) (((S)&twoL(X))!=0) #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min() const double eps=1e-9; const double PI=2*acos(0.0); #define pb(a) push_back(a) #define mp(a,b) make_pair(a,b)  const int N=100005;  int prime[N]; vector<ll>v;vector<ll>v2;ll ans=1; ll power(ll a,int b) {   ll x=1,y=a;   while(b)   {     if(b%2)     x=(x*y)%MOD;     y=(y*y)%MOD;     b/=2;   }   return x; }  void pre() {    memset(prime,0,sizeof(prime));   for(int i=2;i*i<N;i++)   {      if(prime[i]==0)     for(int j=i*i;j<N;j+=i)     {       prime[j]=1;     }   }   for(int i=2;i<N;i++)   {     if(prime[i]==0)     {       ans=(ans*i)%MOD;       v.pb(i);       v2.pb(ans);     }   } }   int main() {    pre();   int t;   //t=1;   si(t);   while(t--)   {     ll a,b;     sl(a);     sl(b);ans=1;     int up=upper_bound(v.begin(),v.end(),b)-v.begin();     int low=lower_bound(v.begin(),v.end(),a)-v.begin();     up--;     low--;     if(up>=0 && low>=0)     ans=v2[up]*power(v2[low],MOD-2);     else if ( up>=0 )     ans=v2[up];     ans%=MOD;     pl(ans);     nl;   } }
//Aayush Agarwal  #include<bits/stdc++.h> using namespace std;  #define fOr(i,n) for(int i=0;i<n;i++) #define For(i,n) for(int i=1;i<=n;i++) #define ss(a) scanf("%s",a) #define si(a) scanf("%d",&a) #define sl(a) scanf("%lld",&a) #define pi(a) printf("%d ",a) #define pl(a) printf("%lld ",a) #define ps(a) printf("%s ",a) #define nl    printf("\n") #define ll long long int #define ull unsigned long long int #define MOD 1000000007 #define INF 2000000000 #define two(X) (1<<(X)) #define twoL(X) (((int64)(1))<<(X)) #define contain(S,X) (((S)&two(X))!=0) #define containL(S,X) (((S)&twoL(X))!=0) #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min() const double eps=1e-9; const double PI=2*acos(0.0); #define pb(a) push_back(a) #define mp(a,b) make_pair(a,b)  const int N=1e6+10; const ll L=2000000000000000000LL; ll dp[N],dp2[N],sum[N],sum2[N]; int cnt=1,cnt2=1;  void pre() {    dp[0]=1;sum[0]=1;   dp2[0]=0;sum2[0]=0;   for(ll i=3;i<=1000000;i+=2)   {     if((L-(i*i*i))>=dp[cnt-1])     {       dp[cnt]=dp[cnt-1]+(i*i*i);       sum[cnt]=sum[cnt-1]+i;       cnt++;     }     else     break;   }   for(ll i=2;i<=1000000;i+=2)   {     if((L-(i*i*i))>=dp2[cnt2-1])     {       dp2[cnt2]=dp2[cnt2-1]+(i*i*i);       sum2[cnt2]=sum2[cnt2-1]+i;       cnt2++;     }     else      break;   } }  int main() {      pre();   /*for(int i=0;i<10;i++)   {     pl(dp[i]);   }   nl;   for(int i=0;i<10;i++)   {     pl(sum[i]);   }   nl;   for(int i=0;i<10;i++)   {     pl(dp2[i]);   }   nl;   for(int i=0;i<10;i++)   {     pl(sum2[i]);   }   nl;*/   int t;   si(t);   while(t--)   {     ll n,ans;     sl(n);     ll pos=lower_bound(dp,dp+cnt,n)-dp;     ll pos2=lower_bound(dp2,dp2+cnt2,n)-dp2;     if(dp[pos]==n)     {       ans=sum[pos];     }     else if(dp2[pos2]==n)     {       ans=sum2[pos2];     }     printf("%lld",ans);nl;   } }
 #include <bits/stdc++.h>   #define II pair<int,int> #define ll long long int #define ull unsigned long long int #define inp(a) scanf("%d",&a) #define out(a) printf("%d\n",a) #define inpll(a) scanf("%lld",&a) #define outll(a) printf("%lld\n",a)     #define PQI priority_queue<int> #define PQLL priority_queue<long long int> #define VP vector<pair<int,int> >   #define VI vector<int> #define VLL vector<long long int> #define getcx getchar_unlocked #define sz(a) (int)a.size() #define mod 1000000009 #define mp make_pair #define X first #define Y second #define pb push_back #define rep(i,a,b) for(i=a;i<b;i++) #define all(a) a.begin(),a.end() #define N 150000 #define pf(x) printf("%d\n",x) #define sf(x) scanf("%d",&x)     using namespace std;   ll power(ll p,ll q,ll m){ ll aaa=1; while(q){ if(q&1) aaa=(aaa*p)%m; p=(p*p)%m; q/=2; } return aaa; }   ll gcd(ll p,ll q){ if(q==0) return p; else return(gcd(q,p%q)); }   bool cmprr(const pair<char,ll>& p,const pair<char,ll> &q){ return p.Y<q.Y; }   /*bool comp(const node &x,const node &y){ return x.a<y.a; }*/       int i,j,k,n,t,a[N],pppp[N],val[20];   int main(){ inp(t); int smm; while(t--){ inp(n); pppp[0]=0; rep(i,1,n+1) inp(a[i]); rep(i,1,11) inp(val[i]); smm=a[1]; pppp[1]=val[a[1]]; rep(i,2,n+1){ smm+=a[i]; int p,mamamia=INT_MAX,idx=i-1,to=smm-a[i]; for(;(smm-to)<=10&&(i-idx)<=3;idx--){ //cout<<idx<<" "<<smm-to<<'\n'; p=(smm-to); mamamia=min(mamamia,pppp[idx]+val[p]); to-=a[idx]; } //cout<<mamamia<<'\n'; pppp[i]=mamamia; } cout<<pppp[n]; cout<<'\n'; } return 0; }
// Dynamic Programming implementation of edit distance #include<bits/stdc++.h> using namespace std; // Change these strings to test the program #define STRING_X "SUNDAY" #define STRING_Y "SATURDAY"   #define SENTINEL (-1) #define EDIT_COST (1)   inline int min(int a, int b) {    return a < b ? a : b; }   // Returns Minimum among a, b, c int Minimum(int a, int b, int c) {     return min(min(a, b), c); }   // Strings of size m and n are passed. // Construct the Table for X[0...m, m+1], Y[0...n, n+1] int solve(string X,string Y) {     // Cost of alignment     int cost = 0;     int leftCell, topCell, cornerCell;       int m = X.size()+1;     int n = Y.size()+1;       // T[m][n]     int *T = (int *)malloc(m * n * sizeof(int));       // Initialize table     for(int i = 0; i < m; i++)         for(int j = 0; j < n; j++)             *(T + i * n + j) = SENTINEL;       // Set up base cases     // T[i][0] = i     for(int i = 0; i < m; i++)         *(T + i * n) = i;       // T[0][j] = j     for(int j = 0; j < n; j++)         *(T + j) = j;       // Build the T in top-down fashion     for(int i = 1; i < m; i++)     {         for(int j = 1; j < n; j++)         {             // T[i][j-1]             leftCell = *(T + i*n + j-1);             leftCell += EDIT_COST; // deletion               // T[i-1][j]             topCell = *(T + (i-1)*n + j);             topCell += EDIT_COST; // insertion               // Top-left (corner) cell             // T[i-1][j-1]             cornerCell = *(T + (i-1)*n + (j-1) );               // edit[(i-1), (j-1)] = 0 if X[i] == Y[j], 1 otherwise             cornerCell += (X[i-1] != Y[j-1]); // may be replace               // Minimum cost of current cell             // Fill in the next cell T[i][j]             *(T + (i)*n + (j)) = Minimum(leftCell, topCell, cornerCell);         }     }       // Cost is in the cell T[m][n]     cost = *(T + m*n - 1);     free(T);     return cost; }   // Recursive implementation int EditDistanceRecursion( char *X, char *Y, int m, int n ) {     // Base cases     if( m == 0 && n == 0 )         return 0;       if( m == 0 )         return n;       if( n == 0 )         return m;       // Recurse     int left = EditDistanceRecursion(X, Y, m-1, n) + 1;     int right = EditDistanceRecursion(X, Y, m, n-1) + 1;     int corner = EditDistanceRecursion(X, Y, m-1, n-1) + (X[m-1] != Y[n-1]);       return Minimum(left, right, corner); }   int main() {   	 int t; cin>>t; while(t--) { 	string x; 	cin>>x; if(solve(x,"zero")==1) cout<<0<<endl; else if(solve(x,"one")==1) cout<<1<<endl; else if(solve(x,"two")==1) cout<<2<<endl; else if(solve(x,"three")==1) cout<<3<<endl; else if(solve(x,"four")==1) cout<<4<<endl; else if(solve(x,"five")==1) cout<<5<<endl; else if(solve(x,"six")==1) cout<<6<<endl; else if(solve(x,"seven")==1) cout<<7<<endl; else if(solve(x,"eight")==1) cout<<8<<endl; else if(solve(x,"nine")==1) cout<<9<<endl; }           return 0; } 
#include<cstdio> #include<cstdlib> #include<iostream> #include<algorithm> #include<queue> #include<cstring> #include<string> using namespace std;  int main() { 	int t; 	scanf("%d",&t); 	while(t--) { 		 long long int n; 		 long long int k,x; 		long long int ans=0; 		long  long int *a; 		scanf("%lld %lld",&n,&k); 		a=(long long int*)malloc((n+1)*sizeof(long long int)); 		for( long long int i=0;i<n;i++) { 			scanf("%lld",&a[i]); 		} 		sort(a,a+n); 		long long int i,s[n+1]; 		long long int j=1,l,diff,p=0; 		for(i=0;i<n;i++) 			s[i]=a[i]*((float)(a[i]+1)/(float)2); 		p=0; 		for(i=n-1;i>=0;i--) 		{ 			if(i>0) 				diff=a[i]-a[i-1]; 			else 				diff = a[i]; 			if(p+(diff*j)<=k) 			{ 				if(i>0) 					ans+=j*(s[i]-s[i-1]); 				else  					ans+= j*s[i]; 				p+=(diff*j); 				j++; 			} 			else 			{ 				for(l=a[i];l>0;l--) 				{ 					if(p+j<=k) 					{ 						ans+=(l*j); 						p+=j; 					} 					else 					{ 						ans+=(l*(k-p)); 						break; 					} 				} 				break; 			} 		} 		printf("%lld\n",ans); 	} 	return 0; } 			 			 	 
#include<bits/stdc++.h> using namespace std; char str[1000005]; int main() {     long int r1,r2,t,a[130],n,j,k,i,inc,dec;     cin>>t;     while(t--)     {         for(i=0;i<130;i++)             a[i]=0;         //scanf("%s",str);         cin>>str;         for(i=0;str[i]!='\0';i++)         {             a[str[i]]++;         }         inc=0;dec=0;         sort(a,a+130);         for(i=0;a[i]==0;i++)         {         }         for(;i<130;i++)         {             if(a[i]!=a[129])             {                 inc=inc+a[129]-a[i];             }         }         for(i=0;a[i]==0;i++)          {}          for(j=129;j>i;j--)         {             if(a[i]!=a[j])             {                 dec=dec+a[j]-a[i];             }         }         if(inc==0 || dec==0)             cout<<"SAFE\n";         else if(inc==1)         {             cout<<"INCREMENT\n";         }         else if(dec==1)         {             cout<<"DECREMENT\n";         }         else         {             cout<<"NOT POSSIBLE\n";         }     }     return 0; } 
#include <bits/stdc++.h> #define ll long long using namespace std; int a[1000010]; int main() { 	ios_base::sync_with_stdio(false); 	cin.tie(NULL); 	ll int test; 	cin>>test; 	while(test--) 	{ 		int n,k;//n s3ized string & k transformations done on it 		cin>>n>>k; 		string s,r="";//r is the resultant string 		cin>>s; 		int i,t,l=s.length(); 		for(i=0;i<k;i++) 		a[i]=0; 		int prev=0,j=0,x=n,bit,start=0; 		for(i=(l-1);x>0;i--) 		{ 			a[j]=prev^(s.at(i)-'0'); 			prev=prev^bit^a[j]^a[(j+1)%k]; 			 			r=char(a[j]+'0')+r; 			x--; 			j=(j+1)%k; 		} 		cout<<r<<endl; 	} 	return 0; } 
#include<iostream> #include<algorithm> using namespace std; int main() {     int t;     long long a[1000001],n,k;     scanf("%d",&t);     while(t--)     {     	long long i=0,cnt=1;     	scanf("%lld%lld",&n,&k);     	while(i<n)     	{     		scanf("%lld",&a[i]);     	    i++;     	}     	i=0;     	sort(a,a+n);     	while(i<n-1)     	{     	    if(a[i+1]-a[i]<=k)     	    {     	        cnt++;     	    }             i++;     	}   		printf("%lld\n",cnt); 	}     return 0; }
#include<cstdio> using namespace std; int main() {     int n;     long long cnt=0;     char c='a';     scanf("%d",&n);     getchar();     while(n--)     {         c=getchar();         if(c=='.')             cnt++;     }     printf("%lld\n",cnt); } 
#include<cstdio> #include<iostream> #include<cstring> using namespace std; int main() { 	int t; 	scanf("%d",&t); 	getchar(); 	while(t--)     {         char s='a';         int cnt=0;         while(1)         {             s=getchar();             if(s=='\n'||s==EOF)                 break;             if(s==' ')             {                 printf("%d",cnt);                 cnt=0;             }             else                 cnt++;         }         printf("%d\n",cnt);     } } 
#include<cstdio> using namespace std; int main() {     int t;     scanf("%d",&t);     while(t--)     {         long long n,sum;         scanf("%lld",&n);         sum=n*(n+1)/2;         printf("%lld\n",sum);     } } 
#include<cstdio> using namespace std;  int main() {     char c='a';     long long inc=0,calc=0;     while(1)     {         inc+=100;         c=getchar();         if(c=='\n'||c==EOF)             break;         if(c=='H'||c=='h')             calc+=inc;         else             calc-=inc;     }     printf("%lld\n",calc);  } 
#include<iostream> using namespace std; long long n; string s[13]={" ","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz","*"," ","#"}; string x; int main() {     cin>>n;     while(n--)     {         cin>>x;         int l=x.size();         int c=0;         for(int i=0;i<l;i++)         {             int y=x[i]-'0';               if(x[i]=='*')             {                 y=10;             }             else if(x[i]=='0')             {                 y=11;             }             else if(x[i]=='#')             {                 y=12;             }              if(x[i]!=x[i+1] && (y>1 && y<10))            {                cout<<s[y-1][c];                c=0;            }               if(y==1 || y==10 || y==11 || y==12)             {                 cout<<s[y-1][0];                 c=0;             }           if(x[i]==x[i+1] && (y>1 && y<10))            {               c++;            }                 }         cout<<endl;     } }  
#include<bits/stdc++.h> using namespace std; long long int n,m,t,a,b,v; int main() { cin>>t;  while(t--) { scanf("%lld%lld%lld",&a,&b,&m); v=b-a; if(v%m==0)         printf("%lld\n",v/m); else         printf("%lld\n",v/m+1);      }  return 0; } 
#include <bits/stdc++.h>   using namespace std;   #define MAXN 111 #define MOD 1000000007 #define LL long long int   LL dp[MAXN][MAXN] = {0}; LL n, m, p, i, j;   inline void Solve(){ cin>>n>>m>>p; memset(dp, 0, sizeof dp); dp[0][0] = 1; for(int i=0;i<p;i++) { for(int j=0;j <= n;j++) { if(j>=m) { dp[i+1][j] += dp[i][j] * (j - m); dp[i + 1][j] %= MOD; dp[i+1][j+1] += dp[i][j] * (n - j); dp[i + 1][j + 1] %= MOD; } else{ dp[i+1][j+1] += dp[i][j] * (n - j); dp[i + 1][j + 1] %= MOD; } } } cout<<dp[p][n]<<endl; }   int main() { int t; cin>>t; while(t--){ Solve(); } return 0; }
#include <bits/stdc++.h> using namespace std; #define MAX 1123456 typedef pair<int,int> pii; int arr[MAX],N; int LIS[MAX],ct; void print(){     for(int i = 0; i < N; ++i)         cout << arr[i] << " ";     cout << endl; }  void read(){     cin >> N;     for(int i = 0; i < N; ++i)         cin >> arr[i], arr[i] -= i; }  void solve(){     for(int i = 0; i < N; ++i){         if (arr[i] <= 0) continue;         if (ct == 0 || LIS[ct-1] <= arr[i])             LIS[ct++] = arr[i];         else if (LIS[0] > arr[i])             LIS[0] = arr[i];         else {             int id = lower_bound(LIS,LIS+ct,arr[i]) - LIS;             LIS[id] = arr[i];         }     }     cout << N-ct << endl; }  int main() {     ios_base::sync_with_stdio(0);     read();     solve();     return 0; } 
#include<cstdio> #define S scanf("%d",&t) main(){int t;S;while(~S)printf("%d\n",!(t&t-1));}
#include<bits/stdc++.h>  using namespace std; typedef long long int ll;  const double error = 1.0/120; vector<string>times[365];   int main() { 	cin.sync_with_stdio(0); 	cin.tie(0); 	cout << fixed << setprecision(10); 	int mx =10000000; 	vector<int> minD(mx+47,0); 	for(int i =2; i <= mx; i++) if(minD[i] == 0) 		for(int j =1; j <= mx/i; j++) minD[i*j] =i; 	int T; 	scanf(" %d",&T); 	while(T--)  	{ 		int N; 		long long ans =1; 		scanf(" %d",&N); 		while(N > 1) { 			int p =minD[N], ppw =1; 			while(N%p == 0) { 				ppw *=p; 				N /=p;} 			ans *=1LL*ppw*ppw-(1LL*ppw*ppw-1)/(p+1);} 		printf("%lld\n",ans); 	} 	return 0; } 
#include <bits/stdc++.h>  //#define mod 1000000007 using namespace std; typedef long long int lli;  int func(int n,int i, int j,int x, int y, int sum, int diag) {     //cout<<i<<" "<<j<<endl;     if(i==x && j==y) return sum;     if(i==1 && j==1)          if(n%2==1)return func(n,i,j+1,x,y,sum+1,diag+1);         else return func(n,i+1,j+1,x,y,sum+1,diag+1);      if(i==n && j==n)          if(n%2==0) return func(n,i-1,j,x,y,sum+1,diag+1);         else return func(n,i-1,j-1,x,y,sum+1,diag+1);     if(i==n && j==1) return func(n,i-1,j,x,y,sum+1,diag+1);     if(i==1)         if(n%2==0)         {             if((i+j)%2==1) return func(n,i,j+1,x,y,sum+1,diag+1);             else return func(n,i+1,j+1,x,y,sum+1,diag+1);          }         else         {             if((i+j)%2==1) return func(n,i+1,j+1,x,y,sum+1,diag+1);             else return func(n,i,j+1,x,y,sum+1,diag+1);         }     if(i==n)          if(n%2==0)         {             if((i+j)%2==0) return func(n,i,j+1,x,y,sum+1,diag+1);             else return func(n,i-1,j-1,x,y,sum+1,diag+1);         }         else         {             if((i+j)%2==1) return func(n,i,j+1,x,y,sum+1,diag+1);             else return func(n,i-1,j-1,x,y,sum+1,diag+1);         }     if(j==1)         if(n%2==0)         {             if((i+j)%2==0) return func(n,i+1,j+1,x,y,sum+1,diag+1);             else return func(n,i-1,j,x,y,sum+1,diag+1);         }         else         {             if((i+j)%2==1) return func(n,i+1,j+1,x,y,sum+1,diag+1);             else return func(n,i-1,j,x,y,sum+1,diag+1);         }     if(j==n)         if(n%2==0)         {             if((i+j)%2==1) return func(n,i-1,j-1,x,y,sum+1,diag+1);             else return func(n,i-1,j,x,y,sum+1,diag+1);         }         else         {             if((i+j)%2==0) return func(n,i-1,j-1,x,y,sum+1,diag+1);             else return func(n,i-1,j,x,y,sum+1,diag+1);         }     if(n%2==1)     {         if((i+j)%2==1) return func(n,i+1,j+1,x,y,sum+1,diag+1);         else return func(n,i-1,j-1,x,y,sum+1,diag+1);     }     else     {         if((i+j)%2==0) return func(n,i+1,j+1,x,y,sum+1,diag+1);         else return func(n,i-1,j-1,x,y,sum+1,diag+1);     } }  int main() {     int t,n,x,y;     cin>>t;     while(t--)     {         scanf("%d%d%d",&n,&x,&y);         printf("%d\n",func(n,n,1,x,y,1,1));     } }
#include <algorithm> #include <bitset> #include <cctype> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <fstream> #include <iostream> #include <list> #include <map> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <utility> #include <vector> #include <assert.h>  #define stream istringstream #define rep(i,n) for(int i=0; i<(int)n; i++) #define repv(i,n) for(int i=n-1; i>=0; i--) #define repl(i,n) for(int i=1; i<=(int)n; i++) #define replv(i,n) for(int i=n; i>=1; i--) #define FOR(i,a,b) for(int i=(int)a;i<=(int)b;i++) #define foreach(i,n) for(__typeof((n).begin())i =(n).begin();i!=(n).end();i++) #define sz(x) (int)x.size() #define inf (1061109567) #define pb(x) push_back(x) #define ppb pop_back #define all(x) x.begin(),x.end() #define mem(x,y) memset(x,y,sizeof(x)); #define eps 1e-9 #define rev reverse #define pii pair<int,int> #define pll pair<i64,i64> #define pmp make_pair #define sdi(x) scanf("%d",&x) #define sdii(x,y) scanf("%d%d",&x,&y) #define sds(x) scanf("%s",x) #define pfi(x) printf("%d\n",x); #define uu first #define vv second using namespace std; template<class T> inline T sqr(T x){return x*x;} template<class T> inline T lcm(T a,T b) {if(a<0)return lcm(-a,b);if(b<0)return lcm(a,-b);return a*(b/__gcd(a,b));} template<class T> T power(T N,T P){ return (P==0)?  1: N*power(N,P-1); } template<class T> string itoa(T a){if(!a) return "0";string ret;for(T i=a; i>0; i=i/10) ret.pb((i%10)+48);reverse(all(ret));return ret;} typedef  long long i64; typedef unsigned long long ui64; double log(double N,double B){  return (log10l(N))/(log10l(B)); } vector< string > token( string a, string b ) {const char *q = a.c_str();while( count( b.begin(), b.end(), *q ) ) q++;vector< string > 	oot;while( *q ) {const char *e = q;while( *e && !count( b.begin(), b.end(), *e ) ) e++;oot.push_back( string( q, e ) );q = e;while( count( b.begin(), 	b.end(), *q ) ) q++;}return oot; } //bool operator < ( const node& p ) const {      return w < p.w;   } #define on(n,pos) (n | (1<<pos)) #define off(n,pos)  n & ~(1<<pos) #define isOn(n,pos) (bool)(n & (1<<pos)) string toBin(int n){ string s; repv(i,10)s+=(isOn(n,i)+'0');return s;} bool eq(long double a,long double b){return fabs(a-b)<eps;} #define READ(f) freopen(f, "r", stdin) #define WRITE(f) freopen(f, "w", stdout) #define pks printf("Case %d: ",++ks);         #define size 26      i64 mat[size][size], tmp[size][size], res[size][size];     i64 MOD;     int n;     void init(int _n, i64 _MOD)      { 		n = _n; 		MOD = _MOD; 		 		mem(mat, 0); 		mem(tmp, 0); 		mem(res, 0);     }      void mul(i64 r[][size], i64 a[][size], i64 b[][size])      { 		rep(i, n) rep(j, n)  		{ 			i64 val = 0; 			rep(t, n)  			{ 				val += 1LL * a[i][t] * b[t][j]; 				if(val>=MOD)val%=MOD; 			} 			tmp[i][j] = val; 			 		} 		memcpy(r, tmp, n * size * sizeof(tmp[0][0]));     }     void mPow(i64 r[][size], i64 a[][size], int p) { 	if (p < 0) 	    return; 	mem(r, 0); 	rep(i, n) r[i][i] = 1; 	while (p > 0) { 	    if (p & 1) 		mul(r, r, a); 	    mul(a, a, a); 	    p >>= 1; 	}     }     void pow(int p) { 		mPow(res, mat, p); 		memcpy(mat, res, n * size * sizeof(tmp[0][0]));     } 	    struct duo { 	int pre,sign; 	duo(int a,int b){ 		pre=a; 		sign=b; 	} 	duo(){} }T[550]; int ulta[52][52];  int main() { 	//READ("in"); 	//WRITE("out"); 	 	 	 	 		int dim=0; 		for(int pre=0;pre<=9;pre++) 		{ 			int sign=1; 			T[dim]=duo(pre,sign); 			ulta[pre][sign]=dim; 			dim++; 		} 		for(int pre=0;pre<=9;pre++) 		{ 			int sign=0; 			T[dim]=duo(pre,sign); 			ulta[pre][sign]=dim; 			dim++; 		} 		 		 		 	int sav[]={285,276,259,235,205,170,131,89,45,0,0,36,72,107,140,170,196,217,232,240}; 	 	int t; 	sdi(t); 	while(t--) 	{ 		int len; 		sdi(len); 		int mod; 		sdi(mod); 		init(23,mod); 		 		dim=20; 		 		for(int pre=0;pre<=9;pre++) 		{ 			int sign=1; 			int row=ulta[pre][sign]; 			for(int i=pre+1;i<=9;i++) 			{ 				int col=ulta[i][!sign]; 				mat[row][col]=1; 			} 		} 		 		 		for(int pre=0;pre<=9;pre++) 		{ 			int sign=0; 			int row=ulta[pre][sign]; 			for(int i=pre-1;i>=0;i--) 			{ 				int col=ulta[i][!sign]; 				mat[row][col]=1; 			} 			 		} 		 		int krow=dim++; 		 		int col1=ulta[0][1]; 		int col2=ulta[9][0]; 		mat[krow][col1]=1; 		mat[krow][col2]=1; 		 		int grow=dim++; 		int gprev=dim++; 		 		mat[grow][grow]=1; 		mat[grow][krow]=1; 		mat[gprev][grow]=1; 				 		pow(len-1); 		i64 ans=0; 		ans=0; 		 		for(int col=0;col<dim;col++) 		{ 			i64 cval=mat[grow][col],barval; 			if(col<20)barval=sav[col]; 			 			else if(col==20) barval=81; 			else if(col==21) barval=10; 			else if(col==22) barval=0; 			 			ans+=cval*barval; 			if(ans>=mod) 			ans%=mod; 		} 		printf("%lld\n",ans); 	} 	 	return 0; } 
#include <stdio.h> #include <iostream> using namespace std;  int main() {     int n, q, l, r, a, ans;     scanf ("%d%d", &n, &q);     int v[n];     scanf ("%d", &v[0]);     for (int i = 1; i < n; ++i) {         scanf ("%d", &a);         v[i] = v[i-1]+a;     }      while (q--) {         scanf ("%d%d", &l, &r);         --r; --l;         if(l==0 and r == n-1) ans = 0;         else if (l == 0) ans = v[n-1] - v[r];         else if (r == n-1) ans = v[l-1];         else ans = v[n-1]- v[r] + v[l-1];         printf("%d\n", ans);      } } 
#include <cstdio> #include <vector> #include <map> #include <string> #include <iostream> using namespace std; map<string,int> mp; map<int,string> mp1; vector<int> vec[100005]; bool visited[100005]; int dfs(int cur){ int ans=0; visited[cur]=true; for(int i=0;i<vec[cur].size();i++){     if(!visited[vec[cur][i]])         ans+=dfs(vec[cur][i]); } return ans+1; } int main(){ int k,v=0; string str,str1,str2,name; cin>>str; if(mp.find(str)==mp.end()){ mp[str]=v++; mp1[v-1]=str; visited[v-1]=true; } cin>>k; for(int i=0;i<k;i++){     cin>>str1>>str2;     if(mp.find(str1)==mp.end()){         mp[str1]=v++;         mp1[v-1]=str1;     }     if(mp.find(str2)==mp.end()){       mp[str2]=v++;       mp1[v-1]=str2;     }     vec[mp[str1]].push_back(mp[str2]);     vec[mp[str2]].push_back(mp[str1]); } int ans=0; for(int i=0;i<vec[0].size();i++){   if(visited[vec[0][i]]){      if(name>mp1[vec[0][i]])         name=mp1[vec[0][i]];   }   else{    int value=dfs(vec[0][i]);    if(value>ans){     ans=value;     name=mp1[vec[0][i]];    }   } } cout<<name<<endl<<ans<<endl; return 0; } 
#include<stdio.h> #include <cstdio> #include <cmath> #include <algorithm> using namespace std; #define n 1000001 #define llu long long unsigned int llu fac[n+1]={},eul[n+1]; int main() {     llu i,j;     eul[1] = 1;     for(i=2;i<=n;i++)     { 	if(fac[i]==0) 	{ 	    fac[i] = i; 	    eul[i] = i*(i-1) + 1; 	    if(i<=sqrt(n))  		for(j=i*i;j<=n;j+=i)  		    fac[j]=i; 	} 	else 	{ 	    llu lalit = i,kundu = 0; 	    while(lalit%fac[i]==0) 	    { 		lalit /= fac[i]; 		++kundu; 	    } 	    eul[i] = 1; 	    for(j=0;j<2*kundu+1;++j)  		eul[i] *= fac[i]; 	    eul[i]++; 	    eul[i]/=(fac[i]+1); 	    eul[i] *= eul[lalit]; 	}     }     llu t;     scanf("%llu",&t);     while(t--)     { 	llu x; 	scanf("%llu",&x); 	llu ans; 	if((x&1)==0) 	    ans=(llu)(x>>1 )* (llu)(eul[x]+1); 	else 	    ans=(llu)(x)  * (llu)((eul[x]+1)/2); 	printf("%llu\n",ans);     }     return 0; } 
#include<iostream> #include<stdio.h> using namespace std;  long long Arr[200002];  int main() {     long long t,count,mincount,n;     long long temp,min,max;     cin>>t;     while(t--)     {         scanf("%lld",&n);         scanf("%lld",&Arr[1]);         Arr[0] = 0;         mincount=1;                  if (Arr[1] < 0)         min = Arr[1];         else if(Arr[1] == 0)         {mincount =2;min = 0;}         else         min = 0;                  max = Arr[1];         count =1;                  for(int i=2;i<=n;i++)         {             scanf("%lld",&temp);             Arr[i] = Arr[i-1] + temp;                          if (Arr[i] - min == max)             count += mincount;             else if (Arr[i] - min > max)             { max = Arr[i] - min; count = mincount;}                          if (Arr[i] < min)             {min = Arr[i]; mincount = 1; }             else if (Arr[i] == min)             {mincount++;}         }                  printf("%lld %lld\n",max,count);     }     return 0; }        
/* Name- Aayush Agarwal    Language -C++    */ #include <cstdio> #include <iostream> #include <cmath> #include <cstring> #include <cstdlib> #include <ctime> #include <climits> #include <set> #include <map> #include <vector> #include <queue> #include <list> #include <deque> #include <stack> #include <iterator> #include <cassert> #include <cctype> #include <string> #include <sstream> #include <fstream> #include <functional> #include <numeric> #include <utility> #include <algorithm> #define fOr(i,n) for(int i=0;i<n;i++) #define For(i,n) for(int i=1;i<=n;i++) #define ss(a) scanf("%s",a) #define si(a) scanf("%d",&a) #define sl(a) scanf("%lld",&a) #define pi(a) printf("%d ",a) #define pl(a) printf("%lld ",a) #define ps(a) printf("%s ",a) #define nl    printf("\n"); #define ll  long long int #define mod 1000000007 using namespace std;  const double eps=1e-9; const double PI=2*acos(0.0);  #define VI vector<int> #define VS vector<string> #define VL vector<long long int> #define VVI vector<VI> #define PII pair<int,int> #define PLL pair<ll,ll> #define PSS pair<string,string> #define PSI pair<string,int> #define VPII vector<PII> #define VPLL vector<PLL> #define VPSS vector<PSS> #define VPSI vector<PSI> #define pb(a) push_back(a) #define mp(a,b) make_pair(a,b) #define min(a,b) ((a<b)?a:b) #define max(a,b) ((a>b)?a:b) #define sqr(x) ((x)*(x))  ll f,sum=0; vector<int>maxheap; vector<int>minheap; void inp(int *a) {  register char c=0;  while (c<33) c=getchar_unlocked();  *a=0;  while (c>33)  {      *a=*a*10+c-'0';      c=getchar_unlocked();  } } int main() {          clock_t start,end;      int t;int a,b,c,n;ll ans=0;int pu; //	si(t); 	//start=clock(); 	inp(&t); 	while(t--) 	{ 		sum=0; 		inp(&a); 		inp(&b); 		inp(&c); 		inp(&n); 	//	a=1;b=1;c=1;n=200000; 		ans=0; 		f=1;int l2,l1; 		minheap.pb(f);ans=0; 		for(int i=2;i<=n;i++) 		{     		      		     l1=maxheap.size(); 			l2=minheap.size(); 		     if((l1+l2)%2) 		     { 		     	if(l1>l2) 		     	ans=maxheap[0]; 		     	else 		     	ans=minheap[0]; 		     } 		     else 		     { 		     	ans=maxheap[0]; 		     } 		     ll k=(a*ans); 		      		     ll k2=(b*(ll)i); 		      		     f=k+k2+c; 			//f=((a*ans)%mod + ((b*i)%mod) + (c%mod)); 			if(f>=mod) 			f%=mod; 			pu=f; 		     if(pu>ans) 		     { 		     	minheap.pb(pu); 		     	push_heap(minheap.begin(),minheap.end(),greater<ll>()); 		     } 		     else 		     { 		     	maxheap.pb(pu); 		     	push_heap(maxheap.begin(),maxheap.end()); 		     } 		      l1=maxheap.size(); 			l2=minheap.size(); 			if((l1-l2)>=2) 			{ 				int d=maxheap[0]; 				pop_heap(maxheap.begin(),maxheap.end()); 				maxheap.pop_back(); 				minheap.pb(d); 				push_heap(minheap.begin(),minheap.end(),greater<ll>()); 				 			} 			else if((l2-l1)>=2) 			{ 				int d=minheap[0]; 				pop_heap(minheap.begin(),minheap.end(),greater<ll>()); 				minheap.pop_back(); 				maxheap.pb(d); 				push_heap(maxheap.begin(),maxheap.end()); 				 			} 			sum=(sum+f);	 			 		} 		sum++; 		pl(sum); 		nl; 		maxheap.clear(); 		minheap.clear(); 			 	} 	//end=clock(); 	//print111f("%0.2f\n",(end-start)/(CLOCKS_PER_SEC*1.0)); 	 }
#include<stdio.h> int main() {     long long int n,m;     int t;     scanf("%d",&t);     while(t--)     {         scanf("%lld %lld",&n,&m);         if(n%2==0&&m%2==0)         {             if(n>m)                 printf("U\n");             else if(m>=n)                     printf("L\n");         }         else if(n%2!=0&&m%2!=0)         {             if(n>m)                 printf("D\n");             else if(m>=n)                 printf("R\n");         }         else         {             if(n%2==0&&m%2!=0)                 {                     if(n>m)                         printf("D\n");                     else                         printf("L\n");                 }             if(n%2!=0&&m%2==0)                 {                     if(n<m)                         printf("R\n");                     else                         printf("U\n");                 }         }     }     return 0; }
#include<iostream> #include<cstdio> #include<vector> #include<algorithm> #include<cstring> using namespace std;  const int N = 10000000; bool isPrime[N+1]; int count1[N+1];  void sieve() {                    memset(isPrime,1,sizeof(isPrime));     isPrime[0] = false;     isPrime[1] = false;     //cout<<"Hello"<<endl;     for(int i = 2; i * i <= N; ++i) {          if(isPrime[i] == true) {              // Mark all the multiples of i as composite numbers              for(int j = i * i; j <= N ;j += i)                  isPrime[j] = false;         }     }     int curr = 0;     for(int i=2;i<N;i++)     {        if(isPrime[i])          curr++;        count1[i]=curr;     }  } int main() {     sieve();    int t;    scanf("%d",&t);    while(t--)    { 	   int n;            scanf("%d",&n);            int val = count1[n]-count1[n/2];            printf("%d\n",val);    } }
#include <bits/stdc++.h> using namespace std; typedef long long int ll; int a,b,c; const int mod = 100003; ll dp[105][105][105]; ll solve(int pos,int taken,int lft){  if(pos == c){ 	if(lft==0) return 1; 	return 0;  }  if(dp[pos][taken][lft] != -1) return dp[pos][taken][lft];  ll res = 0;  if(lft>0) res = (lft*solve(pos+1,taken+1,lft-1))%mod;  if(taken>b) res = (res+((taken-b)*solve(pos+1,taken,lft))%mod)%mod;  dp[pos][taken][lft] = res;  return res; } int main(){  cin >> a >> b >> c;  memset(dp,-1,sizeof dp);  ll ans = solve(0,0,a);  cout << ans << endl;  return 0; } 
# include "stdio.h"  int main() { 	int t, n;  	scanf("%d", &t);  	while(t--) 	{ 		scanf("%d", &n);  		if( n==0 or n==1) 			printf("NO\n"); 		else 			printf("YES\n"); 	} 	return 0; }
/* * @problem: SONAFOR */ #include <iostream> #include <algorithm> #include <utility> #include <cstring> #include <string.h> #include <set> #include <map> #include <math.h> #include <stdio.h> #include <vector> #include <functional> #include <bitset> #include <iomanip> #define ll long long #define pi acos(-1.0) #define MS0(ar) memset(ar,0,sizeof ar) #define MS1(ar) memset(ar,-1,sizeof ar) #define ff first #define ss second #define pii pair<int,int> #define pll pair<ll,ll> #define ind(a) scanf("%d",&a) #define inf(a) scanf("%lf",&a) #define inl(a) scanf("%lld",&a) #define ins(a) scanf("%s",a) #define pd(a) printf("%d\n",a) #define pl(a) printf("%lld\n",a); #define bitcnt(x) __builtin_popcountll(x) using namespace std; const int MAX = 1e5 + 10; int parent[MAX], r[MAX]; int find(int x) { 	if (x != parent[x]) 		parent[x] = find(parent[x]); 	return parent[x]; } // void Union(int a, int b) // {  // 	int  u = find(a); // 	int v = find(b); // 	if (u != v) { // 		if (r[u] == r[v]) { // 			parent[v] = u; // 			r[u]++; // 		} else if (r[u] < r[v]) { // 			parent[u] = v; // 		} else { // 			parent[v] = u; // 		} // 	} // } int main() {  	ios_base::sync_with_stdio(0); 	cin.tie(0); #ifndef ONLINE_JUDGE 	freopen("../input.txt", "r", stdin); 	//freopen("../output.txt","w",stdout); #endif 	int n, m, a, b, c, i; 	cin >> n >> m; 	int flag = 0; 	for (int i = 1; i <= n; ++i) 		parent[i] = i; 	for ( i = 0; i < m; ++i) 	{ 		cin >> a >> b >> c; 		int pa = find(a); 		int pb = find(b); 		if (pa != pb) 		{ 			parent[pa] = parent[pb]; 		} 		else 		{ 			break; 		} 	} 	if (i < m) 		cout << i + 1 << endl; 	else 		cout << "-1" << endl; 	return 0; }
#include <cstdio> using namespace std; int pp[40100],i,j,x,T,n,k,ans,tot,pr[400],ct[400],cnt; bool p[40100]; int phi(int x) {     int ans=x;     for (i=0;i<tot && pp[i]*pp[i]<=x;i++) if (x%pp[i]==0) {         ans=ans/pp[i]*(pp[i]-1);         while (x%pp[i]==0) x/=pp[i];     }     if (x!=1) ans=ans/x*(x-1);     return ans; } int power(int a,int x) { 	long long s=a,ans=1; 	for (int i=0;x>>i;i++) { 		if ((x>>i)&1) ans=ans*s%(n+1); 		s=s*s%(n+1); 	} 	return ans; } void dfs(int dep,int res,int cur) {     if (res>=ans) return;     if (dep==cnt) {if (res!=1 && cur==1) ans=res;return;}     for (int i=0;i<=ct[dep];i++) {         dfs(dep+1,res,cur);         res=res*pr[dep];         cur=power(cur,pr[dep]);     } } int main() {     for (i=2;i<=40000;i++) if (!p[i]) {         pp[tot++]=i;         for (j=i;j<=40000;j+=i) p[j]=1;     }     for (scanf("%d",&T);T;T--) {         scanf("%d%d",&n,&k);         x=phi(n+1);ans=x;         for (cnt=j=0;j<tot && pp[j]*pp[j]<=x;j++) if (x%pp[j]==0) {             pr[cnt]=pp[j];ct[cnt]=0;             while (x%pp[j]==0) x/=pp[j],ct[cnt]++;             cnt++;         }         if (x!=1) pr[cnt]=x,ct[cnt]=1,cnt++;         dfs(0,1,k);         printf("%d\n",ans);     } } 
#include <iostream> #include <algorithm> #include <functional> #include <vector> #include <limits.h> #include <stdio.h> #include <string> #include <map> #include <sstream> using namespace std; int n, t; int a[200500]; int aux[200500]; int inv = 0; void merge(int l, int m, int r) { 	for (int i = l; i <= r; i++) 		aux[i] = a[i]; 	int lb = l, rb = r, mb = m; 	for (int i = lb; i <= rb; i++) { 		if (m + 1 > rb) { 			a[i] = aux[l]; 			//printf("%d and %d in %d inv +\n", l, m + 1, i); 			l++; 			continue; 		} 		if (l > mb) { 			a[i] = aux[m + 1]; 			//printf("%d and %d in %d \n", l, m + 1, i); 			m++; 			continue; 		} 		if (aux[l] > aux[m + 1]) { 			//printf("%d and %d in %d inv +\n", l, m + 1, i); 			inv += mb - l + 1; 			a[i] = aux[m + 1]; 			m++; 		} else { 			a[i] = aux[l]; 			//printf("%d and %d in %d\n", l, m + 1, i); 			l++; 		} 	}  } void msort(int l, int r) { 	if (l >= r) 		return; 	int m = l + (r - l) / 2; 	msort(l, m); 	msort(m + 1, r); 	merge(l, m, r); } void solve() { 	inv = 0; 	for (int i = 0 ; i < 200000 ; i++) { 		a[i] = 0; 		aux[i] = 0; 	} 	scanf("%d", &n); 	for (int i = 1; i <= n; i++) 		scanf("%d", &a[i]); 	msort(1, n); 	printf("%d\n", inv); }  int main() { 	scanf("%d", &t); 	for (int times = 1; times <= t; times++) 		solve(); 	return 0; } 
#include<stdio.h> #include<iostream> #include<math.h> using namespace std; int main() {     int t,n,m;     cin>>t;     while(t--)     {         cin>>n>>m;         printf("%.2f\n",(pow(2,n+1)-pow(2,m+1)));     }      return 0; } 
#include<iostream> #include<string> #include<algorithm> #include<vector> #include<stdio.h> #include<stdlib.h> #include<math.h> using namespace std; #define mod 1000000007 #define size 200001  long long n, i, j, sum; vector<long long> pos(size); vector<long long> pi(size);  int main() { 	int t; 	cin>>t; 	while(t--){ 		cin>>n; 		for(i=0; i<n; ++i){ 			cin>>pos[i]; 		} 		for(i=0; i<n; ++i){ 			cin>>pi[i]; 		} 		sum=0; 		for(i=0; i< n-1; ++i){ 			for(j=i+1; j<n; ++j){ 				if(pi[i]>pi[j]) 					sum = (sum + pi[i]*abs(pos[i]-pos[j]))%mod; 				else 					sum = (sum + pi[j]*abs(pos[i]-pos[j]))%mod; 			} 		} 		cout<<sum<<endl; 	} 	return 0; }
// AUTHOR : Dipjal Chhetri // Institution : Jaypee Institute of Information Technology  #include<bits/stdc++.h> #include<algorithm> #include<stack> #include<queue> #include<string.h> #define pb push_back #define mp make_pair #define all(c) c.begin(),c.end() #define sz(c) c.size() #define rep(i,n) for(int i = 0;i<n;i++) #define range(i,a,b) for(int i = a;i<=b;i++) //#define tr(it,c) for(typeof(c.begin()) it = c.begin();it!= c.end();++it) #define setbits(x) __builtin_popcount(x) #define gcd(x,y) __gcd(x,y) //#define x first //#define y second #define author dipjal using namespace std; typedef long long int ll; typedef vector<int> vii; typedef pair<int,int> pii; typedef vector<int> vi; typedef vector<pii> vpii; typedef map<int,int> mii; const int SIZE = 4e5+5; const ll mod = 1e9+7; const ll epf = -1e5+9; const ll inf = 0x7fffffff; int type; int root,cnt; char c; //bool vis[SIZE]; string cur; //vector<pair<int,char> > graph[SIZE]; int N,M; //int arr[SIZE]; //int dp[SIZE]; int u,v,d; //#define gc() getchar_unlocked() //#define pc(x) putchar_unlocked(x)  /*inline int scan(){      int x = 0LL;      char c = gc();      while(c<'0'||c>'9') c= gc();      while(c>='0'&&c<='9'){             x = (x<<1)+(x<<3)+c-'0';      c= gc();      }      return x;  }  inline void WRITE_FAST(ll ANSWER){      char STORAGE[25];      int varLen = 0;      do{             STORAGE[varLen++]=(char)(ANSWER%10+'0');      ANSWER/=10;      }while(ANSWER);      --varLen;      while(varLen>=0) pc(STORAGE[varLen--]);      pc('\n');  } */ bool comp(const pair<int,int>& p1,const pair<int,int>& p2){     if(p1.first!=p2.first)         return p1.first<p2.first;     return p1.second<p2.second; }  int HV[12][12][12][12];  int n;  int solve(int a,int b,int x){  if(a+x>n||b+x>n) return 0;  for(int i = b;i<b+x;i++)     if(!HV[a][i][a][i+1]||!HV[a+x][i][a+x][i+1]) return 0;   for(int i = a;i<a+x;i++)     if(!HV[i][b][i+1][b]||!HV[i][b+x][i+1][b+x]) return 0;  return 1;  }  const int MAXN = 1e6+5;  ll dp[MAXN];  void setpre(){      dp[0]=0;      dp[1]=1;      range(i,2,(int)(MAXN)) dp[i]=(i&1)?dp[(i>>1)]+1:dp[i>>1];  }  int main(){      ios_base::sync_with_stdio(false);      cin.tie(0);      int tt;      int m,u,v;      setpre();      cin >> u >> v;      ll maxi = 0LL;      range(i,u,v){          maxi = max(maxi, dp[i]);      }      cout << maxi << endl;      return 0;  } 
// AUTHOR : Dipjal Chhetri // Institution : Jaypee Institute of Information Technology  #include<bits/stdc++.h> #include<algorithm> #include<stack> #include<queue> #include<string.h> #define pb push_back #define mp make_pair #define all(c) c.begin(),c.end() #define sz(c) c.size() #define rep(i,n) for(int i = 0;i<n;i++) #define range(i,a,b) for(int i = a;i<=b;i++) //#define tr(it,c) for(typeof(c.begin()) it = c.begin();it!= c.end();++it) #define setbits(x) __builtin_popcount(x) #define gcd(x,y) __gcd(x,y) //#define x first //#define y second #define author dipjal using namespace std; typedef long long int ll; typedef vector<int> vii; typedef pair<int,int> pii; typedef vector<int> vi; typedef vector<pii> vpii; typedef map<int,int> mii; const int SIZE = 4e5+5; const ll mod = 1e9+7; const ll epf = -1e5+9; const ll inf = 0x7fffffff; int type; int root,cnt; char c; //bool vis[SIZE]; string cur; //vector<pair<int,char> > graph[SIZE]; int N,M; //int arr[SIZE]; //int dp[SIZE]; int u,v,d; //#define gc() getchar_unlocked() //#define pc(x) putchar_unlocked(x)  /*inline int scan(){      int x = 0LL;      char c = gc();      while(c<'0'||c>'9') c= gc();      while(c>='0'&&c<='9'){             x = (x<<1)+(x<<3)+c-'0';      c= gc();      }      return x;  }  inline void WRITE_FAST(ll ANSWER){      char STORAGE[25];      int varLen = 0;      do{             STORAGE[varLen++]=(char)(ANSWER%10+'0');      ANSWER/=10;      }while(ANSWER);      --varLen;      while(varLen>=0) pc(STORAGE[varLen--]);      pc('\n');  } */ bool comp(const pair<int,int>& p1,const pair<int,int>& p2){     if(p1.first!=p2.first)         return p1.first<p2.first;     return p1.second<p2.second; }   const int MAXN = 105;  int dp[MAXN][MAXN];  void setdp(){      rep(i,101)      rep(j,101){          if(i==j) dp[i][j]=0;      else dp[i][j] = 1000;  }  }   void dijkstra(){      range(i,1,100){          range(j,1,100){              range(k,1,100)              dp[j][k] = min(dp[j][k],dp[j][i]+dp[i][k]);          }      }  }    int main(){      ios_base::sync_with_stdio(false);      cin.tie(0);      int tt;      int k,n,m,u,v;      setdp();      cin >> k;      cin >> n >> m;      rep(i,101){          rep(j,k)          dp[i][i+j+1]=1;      }      while(n--){      cin >> u >> v;      dp[u][v] = 1;      }      while(m--){             cin>> u >> v;      dp[u][v] = 1;      }      dijkstra();      cout << dp [1][100] << endl;  return 0;  } 
// AUTHOR : Dipjal Chhetri // Institution : Jaypee Institute of Information Technology  #include<bits/stdc++.h> #include<algorithm> #include<stack> #include<queue> #include<string.h> #define pb push_back #define mp make_pair #define all(c) c.begin(),c.end() #define sz(c) c.size() #define rep(i,n) for(int i = 0;i<n;i++) #define range(i,a,b) for(int i = a;i<=b;i++) //#define tr(it,c) for(typeof(c.begin()) it = c.begin();it!= c.end();++it) #define setbits(x) __builtin_popcount(x) #define gcd(x,y) __gcd(x,y) //#define x first //#define y second #define author dipjal using namespace std; typedef long long int ll; typedef vector<int> vii; typedef pair<int,int> pii; typedef vector<int> vi; typedef vector<pii> vpii; typedef map<int,int> mii; const int SIZE = 4e5+5; const ll mod = 1e9+7; const ll epf = -1e5+9; const ll inf = 0x7fffffff; int type; int root,cnt; char c; //bool vis[SIZE]; string cur; //vector<pair<int,char> > graph[SIZE]; int N,M; //int arr[SIZE]; //int dp[SIZE]; int u,v,d; //#define gc() getchar_unlocked() //#define pc(x) putchar_unlocked(x)  /*inline int scan(){      int x = 0LL;      char c = gc();      while(c<'0'||c>'9') c= gc();      while(c>='0'&&c<='9'){             x = (x<<1)+(x<<3)+c-'0';      c= gc();      }      return x;  }  inline void WRITE_FAST(ll ANSWER){      char STORAGE[25];      int varLen = 0;      do{             STORAGE[varLen++]=(char)(ANSWER%10+'0');      ANSWER/=10;      }while(ANSWER);      --varLen;      while(varLen>=0) pc(STORAGE[varLen--]);      pc('\n');  } */ bool comp(const pair<int,int>& p1,const pair<int,int>& p2){     if(p1.first!=p2.first)         return p1.first<p2.first;     return p1.second<p2.second; }   const int MAXN = 26;  long long int dp[MAXN][MAXN];  int a[MAXN];  void setdp(int n,int m){      rep(i,26) dp[0][i] = 0,dp[i][0] = 1;      range(i,1,n){          range(j,1,m){              dp[i][j] = dp[i-1][j];              range(k,1,min(j,a[i-1])){                     dp[i][j]+=dp[i-1][j-k];              }          }      }     // cout<<dp[1][1]<<" "<<dp[1][2]<<" "<<dp[1][3]<<endl;  }   int main(){      ios_base::sync_with_stdio(false);      cin.tie(0);      int tt;      int k,n,m,u,v;      cin>>n>>m;      rep(i,n) cin>>a[i];      setdp(n,m);      cout << dp[n][m] << endl;      return 0;  } 
// AUTHOR : Dipjal Chhetri // Institution : Jaypee Institute of Information Technology  #include<bits/stdc++.h> #include<algorithm> #include<stack> #include<queue> #include<string.h> #define pb push_back #define mp make_pair #define all(c) c.begin(),c.end() #define sz(c) c.size() #define rep(i,n) for(int i = 0;i<n;i++) #define range(i,a,b) for(int i = a;i<=b;i++) //#define tr(it,c) for(typeof(c.begin()) it = c.begin();it!= c.end();++it) #define setbits(x) __builtin_popcount(x) #define gcd(x,y) __gcd(x,y) //#define x first //#define y second #define author dipjal using namespace std; typedef long long int ll; typedef vector<int> vii; typedef pair<int,int> pii; typedef vector<int> vi; typedef vector<pii> vpii; typedef map<int,int> mii; const int SIZE = 4e5+5; const ll mod = 1e9+7; const ll epf = -1e5+9; const ll inf = 0x7fffffff; int type; int root,cnt; char c; //bool vis[SIZE]; string cur; //vector<pair<int,char> > graph[SIZE]; int N,M; //int arr[SIZE]; //int dp[SIZE]; int u,v,d; //#define gc() getchar_unlocked() //#define pc(x) putchar_unlocked(x)  /*inline int scan(){      int x = 0LL;      char c = gc();      while(c<'0'||c>'9') c= gc();      while(c>='0'&&c<='9'){             x = (x<<1)+(x<<3)+c-'0';      c= gc();      }      return x;  }  inline void WRITE_FAST(ll ANSWER){      char STORAGE[25];      int varLen = 0;      do{             STORAGE[varLen++]=(char)(ANSWER%10+'0');      ANSWER/=10;      }while(ANSWER);      --varLen;      while(varLen>=0) pc(STORAGE[varLen--]);      pc('\n');  } */ bool comp(const pair<int,int>& p1,const pair<int,int>& p2){     if(p1.first!=p2.first)         return p1.first<p2.first;     return p1.second<p2.second; }  int HV[12][12][12][12];  int n;  int solve(int a,int b,int x){  if(a+x>n||b+x>n) return 0;  for(int i = b;i<b+x;i++)     if(!HV[a][i][a][i+1]||!HV[a+x][i][a+x][i+1]) return 0;   for(int i = a;i<a+x;i++)     if(!HV[i][b][i+1][b]||!HV[i][b+x][i+1][b+x]) return 0;  return 1;  }   int main(){      ios_base::sync_with_stdio(false);      cin.tie(0);      int tt;      int m,u,v;      cin>>tt;      while(tt--){         cin>>n;         cin>>m;         memset(HV,0,sizeof HV);         string s;         while(m--){             cin>>s;             cin>>u>>v;             if(s[0]=='H') ++HV[u][v][u][v+1],++HV[u][v+1][u][v];             else ++HV[u][v][u+1][v],++HV[u+1][v][u][v];         }         ll cnt = 0LL;         range(i,1,n){         range(j,1,n){             range(k,1,n)             cnt+=solve(i,j,k);         }         }      cout<<cnt<<endl;      }      return 0;  } 
#include<iostream> using namespace std; void merges(int arr[],int l,int m,int r) {  int i=0;int j=0;int k=l;  int n1=m-l+1;  int n2=r-m;  int a[n1];  int b[n2];  for(int x=0;x<n1;x++)         a[x]=arr[l+x];  for(int x=0;x<n2;x++)     b[x]=arr[m+1+x];  while(i<n1&&j<n2)  {      if(a[i]<=b[j])      {         arr[k]=a[i];         i++;         }         else{             arr[k]=b[j];             j++;         }         k++;  }  while(i<n1){     arr[k]=a[i];     i++;     k++;  }  while(j<n2){     arr[k]=b[j];     j++;     k++;  } } void mergesort(int l,int r,int arr[]) {  if(l<r)  {      int m=l+(r-l)/2;      mergesort(l,m,arr);      mergesort(m+1,r,arr);      merges(arr,l,m,r);  } } void print(int arr[],int n) {     for(int i=0;i<n;i++)         cout<<arr[i]<<endl;     cout<<endl; } int main() {     int n;     cin>>n;     int a[n];     for(int i=0;i<n;i++)         cin>>a[i];     mergesort(0,n-1,a);     print(a,n); } 
#include<cstdio> #include<algorithm> using namespace std; int main() { int n; scanf("%d",&n); int a[n]; for(int i=0;i<n;i++) scanf("%d",&a[i]); sort(a,a+n); for(int i=0;i<n;i++) printf("%d\n",a[i]); }
#include <iostream> #include<stdio.h> #include<string.h> using namespace std;  int main() {      int t;      unsigned long long int sum=0,m,n;     cin>>t;     while(t>=1)     {         cin>>m>>n;         sum=(m*n);         cout<<sum<<"\n";         t--;     }      return 0; } 
#include<bits/stdc++.h> using namespace std; int main() {  ios_base::sync_with_stdio(false);  cin.tie(NULL);  cout.tie(NULL);  long long int n,a;  float sum;  char x,temp,y;  long long int ctr1=0,ctr2=0,ctr3=0,i;  cin>>n;  sum=0;  for(i=0;i<n;i++)  {   cin>>x>>temp>>y;   if(x=='1')   {    if(y=='2')    {     ctr2++;    }    else    {     ctr1++;    }   }   else   {    ctr3++;   }  }  a=ctr2%2;  if(ctr1>=ctr3)  {   ctr1=ctr1-ctr3;  }  else  {   ctr1=0;  }  if((a==1)&&(ctr1>=1))  {   ctr1=ctr1-2;  }  sum=ceil((float)ctr1/(float)4)+ceil(float(ctr2)/float(2))+ctr3+1;  cout<<sum;  return 0; }  
#include<iostream> #include<cstdio> #include<cstring>  using namespace std;  int main() {     char str[100100];          while(cin>>str)     {           int count=1,l;           l=strlen(str);           for(int i=0;i<l;i++)           {                   if(str[i]==str[i+1])                         count++;                   else if(count>3)                   {                        cout<<count<<"!"<<str[i];                        count=1;                   }                   else                   {                       while(count--)                            cout<<str[i];                       count=1;                   }           }           cout<<endl;     }     return 0; }
#include <bits/stdc++.h> using namespace std; int main()  { 	int n,t; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d",&n); 		if(n<8) 		{ 			if(n==6) 				printf("NO"); 			else 				printf("RIDICULOUS"); 		} 		else if(n==18 || n==12) 			printf("NO"); 		else if(n==10) 			printf("RIDICULOUS"); 		else 		{ 			if(n%8==0 || n%8==2 || n%8==4 || n%8==6) 				printf("YES"); 			else if(n%6==0) 				printf("NO"); 			else 				printf("RIDICULOUS"); 		} 		if(t!=0) 			printf("\n"); 	} 	return 0; }
#include<iostream> #include<vector> #include<climits> #include<algorithm> using namespace std; long long int arr[200001]; long long int arr1[200001]; vector<long int> vec; void power() {   if(vec.empty()){long long int s = 1;     while(s<=200001)         {vec.push_back(s);s=s*2;}     } } int main() {     long long int n;ios::sync_with_stdio(false);     power();         cin>>n;         for(long long int k=0;k<n;k++)             cin>>arr[k];           arr1[0]=0;          for(long long int i=1;i<n;i++)         {             long long int s = 0;long long int m = LONG_MAX;             //cout<<i-vec[s]<<' '<<arr[i-vec[s]]<<' '<<arr1[i-vec[s]]<<' '<<arr[i]-arr[i-vec[s]]+arr1[i-vec[s]]<<endl;             while((i-vec[s])>=0&&s<vec.size())             {                 //cout<<s<<' ';//<endl;                 m = min(m,abs(arr[i]-arr[i-vec[s]])+arr1[i-vec[s]]);                 //cout<<arr[i]-arr[i-vec[s]]+arr1[i-vec[s]]<<' '<<m<<endl;                 s++;             }             //cout<<endl;             arr1[i]=m;         }         /*for(int j=0;j<n;j++)             cout<<arr1[j]<<' ';         cout<<endl;         */cout<<arr1[n-1]<<endl;  } 
#include<iostream> using namespace std;  void spiral(int a[][101],int n,int m) {     int i=0,j=0,f1=0,f2=1,flag=0,f5=0;     int s1=0,e1=m-1,s2=1,e2=n-1,s3=m-1,e3=0,s4=n-2,e4=1;      int count=n*m;     while(1)     {         if(flag==0)         {         if(f1==0)         {             for(j=s1;j<=e1;j++)             {                 cout<<a[s1][j]<<" ";                    count--;         if(count==0)             {                 f5=1;                 break;             }             }             if(f5)                 break;             s1++;             e1--;             f1=1;         }         else         {             for(i=s2;i<e2;i++)             {                 cout<<a[i][m-1]<<" ";                    count--;         if(count==0)             {                 f5=1;                 break;             }             }             if(f5)                 break;             m--;             s2++;             e2--;             f1=0;          }         flag=!f1;         }         else         {             if(f2==1)         {             for(j=s3;j>=e3;j--)             {                 cout<<a[n-1][j]<<" ";                     count--;         if(count==0)             {                 f5=1;                 break;             }             }             if(f5)                 break;             n--;             s3--;             e3++;             f2=0;         }         else         {          for(i=s4;i>=e4;i--)             {                 cout<<a[i][e4-1]<<" ";                 count--;         if(count==0)             {                 f5=1;                 break;             }             }             if(f5)                 break;             s4--;             e4++;             f2=1;          }         flag=!f2;         }      }  }   int main() {     int a[101][101];     int n,m,i,j,t;     cin>>t;     while(t--)     {     cin>>n;     cin>>m;     for(i=0;i<n;i++)     {         for(j=0;j<m;j++)         {             cin>>a[i][j];         }     }     spiral(a,n,m);     cout<<"\n";     }          return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { long long int t; cin>>t; map<string,int> mp; map<string,int>::iterator it; int max=-10000; string newname; while(t--) { long long int s; string name; cin>>name; cin>>s;  it=mp.find(name); if(it==mp.end()) { mp.insert(pair<string,int> (name,s)); if(s>max) {     max=s;     newname=name; } } else {     it->second+=s;     if(it->second>max)     {         newname=it->first;     max=it->second;     } }  } cout<<newname<<endl; return 0; }
#include <bits/stdc++.h> using namespace std; #define gc getchar #define pc putchar #define mod 1000000007 typedef long long int lli; void inline scanint(int &x) {     register int c = gc();     x = 0;     for(;(c<48 || c>57);c = gc());     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} } void scanint(int &x, int &y){scanint(x);scanint(y);} void scanint(int &x, int &y, int &z){scanint(x);scanint(y);scanint(z);} void scanlli(lli &x){scanf("%lld",&x);} void scanlli(lli &x,lli &y){scanlli(x);scanlli(y);} void scanlli(lli &x, lli &y, lli &z){scanlli(x,y);scanlli(z);} void writeint(int x){ printf("%d",x);} void writelli(lli x){printf("%lld",x);} void space(){printf(" ");} void line(){printf("\n");} lli dp[51][11],sum[51]; int main() {     int t,m,n,i,j;          /*for(i=1;i<=10;i++)     {         for(j=0;j<=10;j++)             cout<<dp[i][j]<<" ";         cout<<endl;     }*/     scanint(t);     lli ans;          while(t--)     {         scanint(m,n);         ans=0LL;         memset(dp,0,sizeof(dp));         memset(sum,0,sizeof(sum));         if(n==1)              if(m==1) ans=1;             else ans=2;         if(m==1)         {             cout<<"0"<<endl;continue;         }         dp[1][0]=1LL;         dp[1][1]=1LL;         sum[1]=2LL;         for(i=2;i<=n;i++)         for(j=0;j<m && j<=i;j++)         {             if(j==0) dp[i][j]=sum[i-1];             else dp[i][j]=dp[i-1][j-1];                         sum[i]=(sum[i]+dp[i][j]);             if(i==n) ans=(ans+dp[i][j]);         }         cout<<ans<<endl;     } }
#include<iostream> #include<cstring> using namespace std;  int main() {     string s;     cin>>s;      int criteria = 0;      int l = s.length();      if(l >= 5)     criteria++;     //cout<<"Criteria :"<<criteria<<endl;      int small[26]={0};     int caps[26]={0};     int dig[10]={0};      for(int i=0; i<l; i++)     {         if(s[i] >=48 && s[i] <= 57)         dig[int(s[i])-48]++;         else if(s[i] >= 65 && s[i] <= 90)         caps[int(s[i])-65]++;         else if(s[i] >= 97 && s[i] <= 122)         small[int(s[i])-97]++;     }      for(int i=0; i<10; i++)     if(dig[i] >= 1)     {         //cout<<"First digit: "<<char(i+48)<<endl;         criteria++;         //cout<<"Criteria :"<<criteria<<endl;         break;     }      for(int i=0; i<26; i++)     if(small[i] >= 1)     {        // cout<<"First small: "<<char(i+97)<<endl;         criteria++;        // cout<<"Criteria :"<<criteria<<endl;         break;     }      for(int i=0; i<26; i++)     if(caps[i] >= 1)     {        //cout<<"First caps: "<<char(i+65)<<endl;         criteria++;         //cout<<"Criteria :"<<criteria<<endl;         break;     }      //cout<<"Criteria :"<<criteria<<endl;      if(criteria==4)     cout<<"YES"<<endl;     else     cout<<"NO"<<endl; } 
#include <bits/stdc++.h> using namespace std; int main() { 	int t,i,j,k,l,m,n,o; 	cin>>t; 	for(i=0;i<t;i++) 	{ 		cin>>j; 		o=0; 		cin>>m; 		o+=m; 		n=m; 		k=m; 		for(l=1;l<j;l++) 		{ 			cin>>m; 			o+=m; 			n^=m; 			if(m<k) 				k=m; 		} 		if(n!=0) 			cout<<"NO"<<endl; 		else 			cout<<o-k<<endl; 	} 	return 0; }
#include <bits/stdc++.h> using namespace std; typedef long long int lli; char dp[130][100011]; //vector<int> vec; int fact[200]; int func(int i,int j) {      if(j==0) return 1;     if(i<0||j<0) return 0;     if(dp[i][j]!=-1) return dp[i][j];     dp[i][j]=func(i-1,j);     if(fact[i]<=j) dp[i][j]=dp[i][j] || func(i-1,j-fact[i]);     return dp[i][j]; }  int main () {     int t,n,i;     //ifstream in;     //in.open("test.txt");     //t=100000;     //vector<int> vec;     int x;     /*for(i=0;i<204;i++)     {         in>>x;         vec.push_back(x);     }     cout<<vec.back();*/     cin>>t;         //int cnt,temp=0;     int sum;     n=0;     int k=0;     while(t--)     {         scanf("%d",&n);         sum=0;         //vec.clear();         k=0;         for(i=1;i<n;i++)         {             if(n%i==0)              {                 fact[k]=i;                 k++;                 sum+=i;             }         }         if(sum<=n) printf("OK\n");         else         {             memset(dp,-1,sizeof(dp));             int ans=func(k-1,n);             if(ans==1) printf("OK\n");             else printf("SPOOKY\n");         }     } }
/** author -- Ayush Sharma  **/  #include<iostream> #include<cstdio> #include<cstring> #include<cassert> #define FOR(i,a,b) for(int i=a; i< b;i++) #define min(a,b,c) (a<b?(a<c?a:c):(b<c?b:c)) #define max(a,b) (a>b?a:b) #define MAX 32623 #define infi 1000 typedef long long LL; using namespace std; int main(){     int T;scanf("%d",&T);     int arr[MAX];     int j=1;     FOR(i,0,MAX){         arr[i]=(j*j) + i;         j+=2;     }     while(T--){         int N;scanf("%d",&N);         if(N==0)printf("0\n");         else{             printf("%d\n",arr[N-1]);         }     }     return 0; } 
#include <iostream> using namespace std;  int main() {     char c[100000];     char s[10];     char ch;     int n,t,i,j,a[26],temp,q,k;     cin>>t;          for(j=1;j<=t;j++){         cin>>n;         cin>>q;         cin>>c;                  for(i=0;i<26;i++)           a[i]=0;                    for(i=0;c[i]!='\0';i++){             temp=c[i];             a[temp-97]++;         }                  for(i=1;i<=q;i++){             cin>>ch;             cin>>s;             temp=ch;             switch(s[0]){                 case 'e': if(a[temp-97]%2==0)                             cout<<"yes"<<"\n";                           else cout<<"no"<<"\n";                           break;                 case 'o': if(a[temp-97]%2!=0)                             cout<<"yes"<<"\n";                           else cout<<"no"<<"\n";                           break;             }         }     } 	// your code goes here 	return 0; }  
#include <iostream> #include <cstring> using namespace std;  int main() { ios_base::sync_with_stdio(false); int T; cin>>T; while(T--) { char string1[17],string2[17]; cin>>string1; cin>>string2; int l=strlen(string2),counter=0; if(strcmp(string1,string2)==0) {     cout<<"YES\n";     counter=31; } while(counter<(l-1)) { for(int i=l; i>0; i--) { string2[i]=string2[i-1]; } string2[0]=string2[l]; string2[l]='\0'; if(strcmp(string1,string2)==0) { cout<<"YES"<<"\n"; counter=30; } counter++; } if(counter!=31) { cout<<"NO"<<"\n"; }  } } 
#include <bits/stdc++.h> using namespace std; const int MAXN = 100005; vector <int> G[MAXN]; int depth[MAXN],mind[MAXN],par[MAXN]; long long int sz[MAXN]; bool vis[MAXN]; int parent(int pos) { 	if(par[pos] != pos) 		par[pos] = parent(par[pos]); 	return par[pos]; } void dfs(int pos, int prev) { 	depth[pos] = 1+depth[prev]; 	mind[pos] = depth[pos]; 	vis[pos] = true; 	for (int i = 0; i < G[pos].size(); ++i) 	{ 		int v = G[pos][i]; 		if(v == prev) 			continue; 		if(vis[v]) 			mind[pos] = min(mind[pos],depth[v]); 		else 		{ 			dfs(v,pos); 			if(mind[v] <= depth[pos]) // not bridge 			{ 				int pu = parent(pos), pv = parent(v); 				par[pv] = pu; 			} 			mind[pos] = min(mind[pos],mind[v]); 		} 	} } int main() { 	int n,m; 	scanf("%d %d", &n, &m); 	for (int i = 0; i < m; ++i) 	{ 		int u,v; 		scanf("%d %d", &u, &v); 		G[u].push_back(v); 		G[v].push_back(u); 	} 	for (int i = 1; i <= n; ++i) 		par[i] = i; 	for (int i = 1; i <= n; ++i) 		if(!vis[i]) 			dfs(i,0); 	for (int i = 1; i <= n; ++i) 		sz[parent(i)]++; 	long long int ans = 0; 	for (int i = 1; i <= n; ++i) 		ans+=(sz[i]*(sz[i]-1))/2ll; 	printf("%lld", ans); 	return 0; } 
#include<bits/stdc++.h> using namespace std;   #define ll long long int #define mp make_pair #define pb push_back #define s(n) scanf("%d",&n); #define sl(n) scanf("%lld",&n); #define p(n) printf("%d\n",n) #define pl(n) printf("%lld\n",n)  int a[111111];  class node{   	public: 	  	bool ap;  	int d;  	int l;  	int r;  	int size;  		node(){}  		node(int x){  			ap=1;  			d=0;  			l=r=x;  			size=1;  		}  };    class tree{  	node tt[4*100000+15];  	public:  		tree(){};  		void build(int s,int e,int idx );  		node init(int x);  		node combine(node x,node y);  		void update(int s,int e,int idx, int id,int x);  		node query(int s,int e,int idx,int i,int j);  };    node tree:: init(int x){  	node t(x);  	return t;  }  node tree:: combine(node x,node y){  	node t;  	if(x.size==1&&y.size==1){  		t.ap=1;  		t.d=y.l-x.r;  	}  	else if(x.size==1&&y.size!=1){  		t.ap=(y.l==x.r+y.d);  		t.d=t.ap?y.d:0;  	}  	else if(x.size!=1&&y.size==1){  		t.ap=(y.l==x.r+x.d);  		t.d=t.ap?x.d:0;  	}  	else{  		t.ap=x.ap&&y.ap&&(y.l==x.r+x.d&&x.d==y.d);  		t.d=t.ap?x.d:0;  	}  	t.l=x.l;  	t.r=y.r;  	t.size=x.size+y.size;  	return t;  } void tree:: build(int s,int e,int idx){ 	if(s==e){ 		tt[idx]=init(a[s]); 		return ; 	} 	int m=(s+e)>>1; 	int l=(idx<<1)+1; 	int r=l+1; 	build(s,m,l); 	build(m+1,e,r); 	tt[idx]=combine(tt[l],tt[r]); } void  tree:: update(int s,int e,int idx,int id,int x) {     if(s>e||id>e||id<s)return;     if(s==e&&s==id)     {         tt[idx]=init(x);         return;     }     int m=(s+e)>>1; 	int  l=(idx<<1)+1; 	int r=l+1;     update(s,m,l,id,x);     update(m+1,e,r,id,x);     tt[idx]=combine(tt[l],tt[r]); } node tree:: query(int s,int e,int idx,int i,int j){ 	if(s>=i&&e<=j) 		return tt[idx]; 	int m=(s+e)>>1; 	int l=(idx<<1)+1; 	int r=l+1; 	if(m<i) 		return query(m+1,e,r,i,j); 	if(m>=j) 		return query(s,m,l,i,j); 	return combine(query(s,m,l,i,j),query(m+1,e,r,i,j)); }     int main(){ 	tree t; 	int n; 	cin>>n; 	int i,j; 	for(i=0;i<n;i++) 		cin>>a[i]; 	t.build(0,n-1,0); 	int q; 	cin>>q; 	while(q--){ 		int ty; 		int i,j; 		cin>>ty>>i>>j; 		if(ty){ 			node tt=t.query(0,n-1,0,i-1,j-1); 			cout<<tt.ap<<endl; 		} 		else{ 			i--; 			a[i]=j; 			t.update(0,n-1,0,i-1,j); 		} 	} } 
/*-->>Light Cavalry<<--*/  //Imp header files #include <iostream> #include <cstdio> #include <cstdlib> #include <cstring> #include <cmath> #include <algorithm> #include <set> #include <vector> #include <stack> #include <queue> #include <sstream> #include <map> #include <list> #include <deque> #include <bitset> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iomanip> #include <sstream> #include <ctime> #include <cassert> #include <climits> using namespace std;  //defined I/O #define si(n) scanf("%d",&n) #define sli(n) scanf("%ld",&n) #define slli(n) scanf("%lld",&n) #define sf(n) scanf("%lf",&n) #define GetLine(n) getline(cin,n); #define ss(n) scanf("%s",n) #define pi(n) printf("%d",n) #define pli(n) printf("%ld",n) #define plli(n) printf("%lld",n) #define pf(n) printf("%lf",n) #define ps(n) printf("%s",n) #define newLine printf("\n") #define space printf(" ") #define SWAP(a,b,t) t=a,a=b,b=t #define Loop(i,a,n) for(__typeof(n) i(a); i<n; i++) #define ULL unsigned long long int #define LL long long int   #define MOD 1000000007 //Imp functions int gcd(int a, int b){if(b == 0)return a;else return gcd(b,a % b);}  #define get getchar_unlocked inline int scan() { 	int n=0,s=1; 	char p=get(); 	if(p=='-') s=-1; 	while((p<'0'||p>'9')&&p!=EOF&&p!='-') p=get(); 	if(p=='-') s=-1,p=get(); 	while(p>='0'&&p<='9') { n = (n<< 3) + (n<< 1) + (p - '0'); p=get(); } 	return n*s; }    int main() { 	 	int n; 	n=scan(); 	int v=1; 	while(n!=0) 	{ 		int a[n],b[n]; 		int check[1001]; 		memset(check,0,sizeof(check)); 		map<int ,int > mp; 		Loop(i,0,n) 		{ 			a[i]=scan(); 			b[i]=a[i]; 			 			 		} 		sort(b,b+n); 		 		Loop(i,0,n) 		{ 			mp.insert ( std::pair<int,int>(b[i],i)); 		} 		 		int mi=b[0]; 		int ans=0; 		for(int i=0;i<n;i++) 		{ 			int pos,count=0,temp=0,temp1=0; 			 			if(a[i]!=b[i] && check[b[i]]==0) 			{ 				check[b[i]]=1; 				int num=a[i]; 				//temp+=num; 				check[num]=1; 				while(num!=b[i]) 				{ 					//cout<<temp<<endl; 					count++; 					temp+=num; 					pos=mp[num]; 					num=a[pos]; 					check[num]=1; 					//cout<<count<<" "<<num<<endl; 				} 				temp+=(count)*b[i]; 				//cout<<temp<<endl; 				 				if(mi!=b[i]) 				{ 					temp1=temp-(count*b[i]); 					temp1+=2*(mi+b[i]); 					temp1+=count*mi; 					 					 				} 				if(temp1>0) 				ans+=min(temp,temp1); 				else 				ans+=temp; 				 			} 			else 			continue; 			 			 			 			 		} 		 		cout<<"Case "<<v++<<": "<<ans<<endl; 		 		 		 		 		 		 		 		 		n=scan(); 	} 	 	return 0; }      
/*  	C++ Template 	Gaurav Babbar */  #include<bits/stdc++.h> #define MOD 1000000007 #define MAX 100005 #define mp make_pair #define pb push_back #define gc getchar #define pc putchar #define ll long long #define llu unsigned long long #define fill(a, val) memset(a, val, sizeof(a))  ll ABS(ll a){if(a>0) return a; else return (-1*a);} int gcd(int a,int b){if (b==0) return a;else return gcd(b,a%b);} llu power(llu b,llu exp,llu m) {llu ans=1; b%=m; while(exp){if(exp&1) ans=(ans*b)%m; exp>>=1; b=(b*b)%m; } return ans; } using namespace std;  #define DisplayDebuggingInfo 0 #define debug(args...) {dbg,args; if(DisplayDebuggingInfo) cerr<<endl;} struct debugger {       template<typename T> debugger& operator,(const T& v)       {           if(DisplayDebuggingInfo)           {               cerr<< v <<" ";               return *this;           }       } }dbg;  inline void inp(llu &n) {   n = 0;   int ch = gc();   int sign = 1;   while(ch < '0' || ch > '9') {     if (ch == '-') sign = -1;     ch = gc();   }   while(ch >= '0' && ch <= '9')     n = (n<<3) + (n<<1) + ch - '0', ch = gc();   n = n*sign; }  inline void outp(llu a) {   char snum[25];   int i=0;   do   {     snum[i++]=a%10+48;     a=a/10;   } while(a!=0);   i=i-1;   while(i>=0)     pc(snum[i--]);   pc('\n'); }  /* Main Code sarts here */  void reset() { }  llu n,p;  void input() {     inp(n);inp(p); }  void preprocess() { }  llu mulmod(llu a,llu b,llu c) {     llu x = 0,y=a%c;     while(b > 0)     {         if(b&1) x = (x+y)%c;         y = (y<<1)%c;         b=b>>1;     }     return x; }  llu mod_inv(llu a) {     return power(a,p-2,p); }  void solve() {     if(n>=p)     {         cout<<"0\n";         return;     }     else     {         llu temp = p-1,prod=1;         while(temp!=n)         {             prod = mulmod(prod,temp,p);             temp--;         }         llu ans = mulmod(p-1,mod_inv(prod),p);         cout<<(ans%p)<<endl;     } }  int main() {    llu t;    inp(t);    while(t--)    { 	   reset(); 	   input(); 	   preprocess(); 	   solve();    }    return 0; } 
/*      SHUBHAM RAI-IIIT Hyderabad   */ #include<bits/stdc++.h> using namespace std; #define FOR(i,a,b) for(i=a;i<b;i++) #define REP(i,a) for(i=0;i<a;i++) #define LLD long long int #define MOD 1000000007 #define si(n) scanf("%d",&n); #define si2(n,m) scanf("%d%d",&n,&m); #define sl(n) scanf("%lld",&n); #define TR(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++) #define F first #define S second #define pb push_back #define mp make_pair typedef pair<int,int> PII; #define TRACE  #ifdef TRACE #define trace1(x)                cerr << #x << ": " << x << endl; #define trace2(x, y)             cerr << #x << ": " << x << " | " << #y << ": " << y << endl; #define trace3(x, y, z)          cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl; #define trace4(a, b, c, d)       cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << endl; #define trace5(a, b, c, d, e)    cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << endl; #define trace6(a, b, c, d, e, f) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << " | " << #f << ": " << f << endl;  #else  #define trace1(x) #define trace2(x, y) #define trace3(x, y, z) #define trace4(a, b, c, d) #define trace5(a, b, c, d, e) #define trace6(a, b, c, d, e, f)  #endif   int main() { 	int t; 	si(t); 	while(t--) 	{ 		int i,j,n,S; 		vector<int> ans; 		si2(n,S); 		for(i=1;i<S;i++) 		{ 			int type1=S/i+1,cnt1=1; 			int type2=S/i+1,cnt2=S%i; 			int type3=S/i,cnt3=i-cnt2-1; 			int tot=0; 			if(type1>2) 				tot=(type1-2)/2 + (type1&1); 			//trace6(type1,cnt1,type2,cnt2,type3,cnt3); 			tot+=(type2/2 + (type2&1))*cnt2 + (type3/2 + (type3&1))*cnt3; 			if(tot<n) 				ans.pb(i); 		} 		ans.pb(S); 		cout<<ans.size()<<endl; 		REP(i,ans.size()) 			cout<<ans[i]<<" "; 		cout<<endl; 	} 	return 0; } 
#include <bits/stdc++.h> using namespace std;  string A;  int main(){      int t, d;     cin>>t;     while(t--){         bool toggle = false;         cin>>A;         cin>>d;         A = " " + A;         for(int i = d; i < A.length(); i++){             toggle = !toggle;             cout<<A[i];         }         if(toggle)  for(int i = d - 1; i >= 1; i--) cout<<A[i];         else for(int i = 1; i <= d - 1; i++)    cout<<A[i];         cout<<endl;     }      return 0; }
#include<bits/stdc++.h>  using namespace std;  int main() {     int n;              cin>>n;         if(n%2==0)             cout<<(n/2 + 1)*(n/2 +1)<<endl;         else             cout<<((n+1)/2)*((n+3)/2)<<endl;         return 0;      }
/*    Ashutosh Singla <ashu1461@gmail.com> Algorithm: #tags: date: Sat Oct 19 23:47:28 IST 2013  */  #include<stdio.h> #include<stdlib.h> #include<string.h> #include<math.h> #include<iostream> #include<vector> #include<map> #include<set> #include<stack> #include<queue> #include<algorithm>  using namespace std; typedef vector<int> vi;  typedef pair<int,int> ii; typedef long long LL; #define FL(a) memset(a, 0, sizeof a); #define fill(a,v,N) memset(a, v, sizeof(a[0])*N) #define sz(a) int((a).size())  #define pb push_back  #define si(n) scanf("%d",&n) #define sin(n) scanf("%d\n",&n) // for scanning strings .. #define sill(n) scanf("%lld",&n) #define pi(n) printf("%d\n",n); #define pill(n) printf("%lld\n",n); #define pis(n) printf("%d ",n);  #define all(c) (c).begin(),(c).end() #define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) #define present(c,x) ((c).find(x) != (c).end())  // map and set find ..  #define cpresent(c,x) (find(all(c),x) != (c).end())  // stl find .. #define FREP(b) for(int i=0;i<b;i++) #define FREPr(b) for(int i=b-1;i>=0;i--) #define REP(a,b,c) for(int a=b;a<c;a++) #define REPr(a,b,c) for(int a=b;a>b;a--) #define mp(a,b) make_pair(a,b); typedef pair<int, int> ii; #define MAX_S 100007 /*    struct data{    };    bool operator < (const data &a1, const data &a2){    }  */ double dp[2508][1300]; double recursion(int T, int k){     if(k > T/2 || k < 0 || T<0) return -1.00;      if(k == T/2) return k;     if(dp[T][k]!=-1.00) return dp[T][k];      double P1 = (double)(k)/(double)(T-k);     double P2 = (double)(1.0-P1)*(1.0/(double)(T-k-1.0));     double P3 = (double)k*P2;     double P4 = (double)(1.0-P1)*(double)(1.0-1.0/(T-k-1.0)-(1.0)*k/(T-k-1.0));     //    printf("here for t .. %d %d %lf %lf %lf %lf\n",T,k,P1,P2,P3,P4)..      dp[T][k] = P1*(1.0 + recursion(T-2, k-1))+ // case: any known card         P2*(1.0 + recursion(T-2, k))+ // case: both new + both matching         P3*(2.0 + recursion(T-2, k))+   // case: one new + prev known card         P4*(1.0 + recursion(T, k+2));   // case : none of the above //    printf("%lf\n", P4);     return dp[T][k]; } int main() {     int a,b;     FREP(2508){         REP(j,0,1300){ dp[i][j] = -1.00;         }     }     dp[0][0] = 0;     while(scanf("%d %d",&a, &b)!=EOF){         printf("%.4lf\n", recursion(a*b, 0));     }     return 0; }  
/* Pranet Verma */ /* Yeh mera template hai. Apna khud banao =_= */ #include <bits/stdc++.h> using namespace std; #define infinity (1000000007) #define ll long long #define ull unsigned long long #define pii pair<int,int> #define ppi pair<pii,int> #define ppp pair<pii,pii> #define pip pair<int,pii> #define pb push_back #define mp make_pair #define s(n) scanf("%d",&n) #define s2(n,m) scanf("%d%d",&n,&m) #define s3(n,m,l) scanf("%d%d%d",&n,&m,&l) #define rep(i,n) for(int i=0;i<n;++i) ll pwr(ll a,ll b,ll mod) {a%=mod;if(a<0)a+=mod;ll ans=1; while(b) {if(b&1) ans=(ans*a)%mod; a=(a*a)%mod; b/=2; } return ans; } ll pwr(ll a,ll b) {ll ans=1; while(b) {if(b&1) ans*=a; a*=a; b/=2; } return ans; } ll gcd(ll a,ll b) {while(b) {ll temp=a; a=b; b=temp%b; } return a; } ll lcm(ll a,ll b) {return (a/gcd(a,b))*b; } ll modularInverse(ll a,ll m) {/*reminder: make sure m is prime*/ assert(false); return pwr(a,m-2,m); } const int mod=1000000007;  int n,N,base; int b[1000000]; int cnt=0; int a[100001]; int idx[100001]; int val[100001]; int RM[1000001]; int f(int x) {   int ret=lower_bound(b,b+cnt,x)-b;   RM[ret]=x;   return ret; }  struct Node {   int maxF;   int maxFIdx;   ll sum;   int cnt;   Node()   {          sum=0;     cnt=0;     maxF=0;     maxFIdx=-1;   }  };  Node tree[1000001]; Node identity;    Node merge(const Node &l,const Node &r) {   Node n;   n.sum=l.sum+r.sum;    n.maxF=max(l.maxF,r.maxF);    if(n.maxF==r.maxF)     n.maxFIdx=r.maxFIdx;   else     n.maxFIdx=l.maxFIdx;    n.cnt=l.cnt+r.cnt;   return n; } void mergeUp(int i) {   while(i)   {     int p=(i-1)/2;     if(i&1)       tree[p]=merge(tree[i],tree[i+1]);     else       tree[p]=merge(tree[i-1],tree[i]);     i=p;   } } void addPoint(int x) {   tree[base+x].cnt++;   tree[base+x].sum+=RM[x];    tree[base+x].maxF=tree[base+x].cnt;   tree[base+x].maxFIdx=RM[x];    mergeUp(base+x); }  void removePoint(int x) {   tree[base+x].cnt--;   tree[base+x].sum-=RM[x];   tree[base+x].maxF=tree[base+x].cnt;   if(tree[base+x].cnt==0)     {       assert(tree[base+x].maxFIdx!=-1);       tree[base+x].maxFIdx=-1;       assert(tree[base+x].sum==0);     }   assert(tree[base+x].cnt>=0);   assert(tree[base+x].sum>=0);   mergeUp(base+x); }  int queryKthSmallest(int i,int l,int r,int k) {   // cout<<i<<" "<<l<<" "<<r<<" "<<k<<endl;   if(tree[i].cnt<k)     assert(0);   if(l==r)   {     return RM[l];   }   int m=(l+r)/2;   /* see if left has answer */   if(tree[2*i+1].cnt>=k)     return queryKthSmallest(2*i+1,l,m,k);   return queryKthSmallest(2*i+2,m+1,r,k-tree[2*i+1].cnt); } int main() {    std::ios::sync_with_stdio(false);      int q;   cin>>n>>q;      for(int i=0;i<n;++i)     {       cin>>a[i];       b[cnt++]=a[i];     }   for(int i=0;i<q;++i)   {     cin>>idx[i]>>val[i];     b[cnt++]=val[i];   }      sort(b,b+cnt);   N=ceil(log2(cnt));   base=(1<<N)-1;    for(int i=0;i<n;++i)   {     addPoint(f(a[i]));   }      for(int i=0;i<q;++i)   {     int u=idx[i];     removePoint(f(a[u]));     a[u]=val[i];     addPoint(f(a[u]));      double mean=double(tree[0].sum)/n;     // cout<<mean<<endl     // int median=-1;     int median=queryKthSmallest(0,0,base,1+n/2);     int mode=tree[0].maxFIdx;     assert(mode!=-1);     cout<<setprecision(7)<<fixed<<mean<<" "<<median<<" "<<mode<<"\n";   }   }
#include<iostream> #include<stdio.h>  using namespace std ; int main() { 	int i=0 ; 	while(1){	int N ; 		int a[100],move=0,sum=0 ; 		 		//scanf("%d",&x) ; 		scanf("%d",&N); 		if(N==0) 		break ; 		for(int j=0 ;j<N ;j++) 		a[j]=0 ; 		for(int j=0 ; j<N ; j++) 		 { 		 scanf("%d",&a[j]) ; 		 sum+=a[j];  		 } 		 sum=sum/N ; 		 for(int j=0 ; j<N ; j++) 		 { 		 if(a[j]>(sum)) 		 move+=a[j]-sum; 		 else 		 move+=sum-a[j] ;	 		 } 		 i++ ; 		 printf("Set #%d\n",i) ; 		 printf("The minimum number of moves is %d.\n\n",move/2) ; 	} 	 return 0 ; 	 } 
#include<bits/stdc++.h> using namespace std; #define llt unsigned int int main() { 	unsigned int x; 	cin>>x; 	llt even_bits = x & 0xAAAAAAAA;  	llt odd_bits = x & 0x55555555;   	even_bits >>= 1;  	odd_bits <<= 1;   	 cout<<(even_bits | odd_bits)<<endl;  	return 0; } 
#include <bits/stdc++.h>  using namespace std;  int main() {      int t;     scanf("%d",&t);      while (t--) {         int n,m;         scanf("%d%d",&n,&m);         int mini = min(n,m);         if (mini&1)             printf("Rohan\n");         else             printf("Kshitij\n");     }       return 0; } 
#include<bits/stdc++.h> using namespace std; #define pb push_back #define mp make_pair #define sz(_v) (int)(_v).size() #define all(_v) (_v).begin(),(_v).end() #define pii pair<int,int> typedef long long ll; const int INF = 1000000000; const ll MOD = 1e9 + 7;  const int MAXN = 100010;  ll multiply(ll a,ll b,ll c) { 	if(b == 0) return 0; 	long long ret = multiply(a, b >> 1, c); 		ret = (ret + ret) % c; 		if (b & 1) { 			ret = (ret + a) % c; 		}     return ret; }  vector < int > ans; int solve(int n) { 	int cnt = 0; 	for (int i = 2; i * i <= n; i ++) { 		if(n % i) continue; 		while (n % i == 0) n /= i; 		cnt ++; 	} 	if(n > 1) cnt ++; 	return cnt; }  int main() { 	int t; cin >> t; 	for (int i = 30; i <= 5000; i ++) { 		if(solve(i) >= 3) ans.pb(i); 	} 	 	while (t --) { 		int n; cin >> n; 		assert(n >= 1 and n <= 1000); 		cout << ans[n - 1] << '\n'; 	} 	return 0; } 
#include<bits/stdc++.h>  using namespace std;  int val[20],a[20][20],d[20],fin;  void dfs(int r, int n, int ans, int mask){           int i;           mask|=1<<r;            ans+=d[r];           for(i=1;i<=n;i++){                 if(a[r][i]==1){                      if((mask&(1<<i))==0)                      dfs(i,n,ans,mask);                  }           }         fin=max(ans,fin);  }  int main(){             int t;           cin>>t;           while(t--){                   memset(a,0,sizeof(a));                   memset(d,0,sizeof(d));                   fin=0;                   memset(val,0,sizeof(val));                   int n,i,j,op=-1;                   cin>>n;                   for(i=1;i<=n;i++)                     cin>>d[i];                   for(i=1;i<=n;i++)                     for(j=1;j<=n;j++)                       cin>>a[i][j];                   for(i=1;i<=n;i++){                          dfs(i,n,0,0);                    }                    cout<<fin<<endl;            }   } 
#include <bits/stdc++.h> using namespace std; #define ll long long int int main() {ios_base::sync_with_stdio(false);   long int n,l[10000],k,i,j,a,ans;   cin>>n;   while(n!=0)   {for(i=0;i<n;i++)   cin>>l[i];   ans=0;   sort(l,l+n);   for(i=0;i<n-2;i++)  { for(j=i+1;j<n-1;j++)   {k=l[i]+l[j];  for(a=j+1;a<n;a++)       if(k<l[a])         {ans=ans+n-a;             break;         }  }}         cout<<ans<<"\n";          cin>>n;                     }         	// your code goes here 	return 0; } 
#include<iostream> using namespace std; int main() {     long int t;     cin>>t;     for(int i=0;i<t;i++)     {         long long int n;         cin>>n;         long long int q=n/26;         //cout<<q<<endl;         int r=n%26;         r=r+96;          if(r>96)             cout<<q+1<<endl;             else                 cout<<q<<endl;      }     return 0; } 
/* TEEPA HAIN  DEKH RAHA HUN KUCH CHEEZE ----------------------------------------------------------------------------- Author :            ---------------------------------------------------------     UTKAR$H $AXENA  ---------------------------------------------------------     IIT INDORE      --------------------------------------------------------- ----------------------------------------------------------------------------- */ #include<bits/stdc++.h> #include<iostream> using namespace std; #define fre 	freopen("0.in","r",stdin),freopen("0.out","w",stdout) #define MOD 1000000007 #define lld signed long long int #define scanll(x) scanf("%lld",&x) #define printll(x) printf("%lld\n",x) #define boost ios_base::sync_with_stdio(0) //vector<int> g[2*100000+5];int par[2*100000+5]; #define MX 600000+5 lld F[MX]; lld G[MX]; lld A[MX];  lld sF[MX][21]; bool flag_sF[MX][21]; lld sG[MX][21]; bool flag_sG[MX][21];  lld rec1(int mask,int i){ 	if(i==-1){ 		return G[mask]; 	} 	if(flag_sF[mask][i]) 		return sF[mask][i];  	flag_sF[mask][i] = 1; 	sF[mask][i] = rec1(mask,i-1); 	if(mask&(1<<i)){ 		sF[mask][i] = (sF[mask][i] + rec1(mask^(1<<i),i-1))%MOD; 	} 	return sF[mask][i]; } lld rec2(int mask,int i){ 	if(i==-1){ 		return (F[mask]*F[mask])%MOD; 	} 	if(flag_sG[mask][i]) 		return sG[mask][i];  	flag_sG[mask][i] = 1; 	sG[mask][i] = rec2(mask,i-1); 	if(mask&(1<<i)){ 		sG[mask][i] = (sG[mask][i] + rec2(mask^(1<<i),i-1))%MOD; 	} 	return sG[mask][i]; } int main() { 	//fre; 	int N; 	cin>>N; 	assert(N<=600000); 	for(int i=0;i<N;++i){ 		scanll(A[i]); 		assert(1<=A[i] and A[i]<=1000000000); 	} 	for(int i=0;i<N;++i){ 		F[i] = (A[i]*A[i] + rec1(i,20)*rec1(i,20)) % MOD; 		G[i] = (rec2(i,20)) % MOD; 		for(int j=0;j<=20;++j){ 			flag_sF[i][j] = 0; 		} 		for(int j=0;j<=20;++j){ 			flag_sG[i][j] = 0; 		}  		rec1(i, 20); 		G[i] = (rec2(i,20)) % MOD; 		 	} 	lld ans = 0; 	for(int i=0;i<N;++i){ 		ans = (ans+((i*F[i])%MOD)*G[i])%MOD; 	} 	printll(ans); }
#include<iostream>  using namespace std;  string del(string s,char del) { int i; for(i=0;i<s.size();i++) if(s[i]==del) s[i]='$';  return s; }   int check(string s,char k) { int i; int sum=0; for(i=0;i<s.size();i++) if(s[i]==k) sum++;  return sum; }  string rev(string s,int pos) { char ch; int l=pos-1; int y; if(pos%2==0) y=pos/2 ; else y=pos/2;  //cout<<"I am y "<<y<<endl; for(int i=0;i<y;i++) { ch=s[i]; s[i]=s[l]; s[l]=ch;  l--; }  return s; }     int main() {   string s; cin>>s;  int k; cin>>k; char a,b; while(k--) {  cin>>a>>b;  if(a=='S') s[0]=b;  if(a=='D') s=del(s,b);  if(a=='R') s=rev(s,(int)(b-48));   //cout<<s<<endl; } cin>>b; int ans=check(s,b); if(ans%2==0) cout<<"YES\n"; else cout<<"NO\n";    return 0; }   
#include<bits/stdc++.h> using namespace std; inline int scan(){     char c = getchar_unlocked();     int x = 0;     while(c<'0'||c>'9'){         c=getchar_unlocked();     }     while(c>='0'&&c<='9'){         x=(x<<1)+(x<<3)+c-'0';         c=getchar_unlocked();     }     return x; } #define author rajat1603 #define pb push_back #define mp make_pair char arr[1000001]; char pat[1000001]={NULL}; int N; inline void computeLPSArray(int M, int *lps){     int len = 0;     int i;     lps[0] = 0;     i = 1;     while(i<M){         if(pat[i]==pat[len]){             len++;             lps[i] = len;             i++;         }            else{                 if(len){                     len = lps[len-1];                 }             else{                 lps[i++] = 0;             }         }     } } inline int kmp(int k){//Taken from GEEKSFORGEEKS     int coun=0;     int M = strlen(pat);     int *lps = (int *)malloc(sizeof(int)*M);     int j  = 0;     computeLPSArray( M, lps);     int i = 0;     while (i < N){         if (pat[j] == arr[i]){             j++;             i++;         }         if (j == M){             coun++;             if(coun>=k){                 return coun;             }             j = lps[j-1];         }         else if (i<N&&pat[j]!=arr[i]){             if (j)                 j = lps[j-1];             else                 i++;         }     }     free(lps);     return coun; } inline bool comp(int sz,int k){     for(int i=0;i<sz;i++){         pat[i]=arr[i];     }     pat[sz]='\0';     int temp = kmp(k);     return temp>=k; } inline int binary(int n,int k){     int l=1;     int r=n;     while(l<=r){         int mid = (l+r)>>1;         bool temp = comp(mid,k);         if(!temp){             r=mid-1;         }         else{             l=mid+1;         }     }     return r; } int main(){     int n=scan();     scanf("%s",arr);     int k=scan();     N=n;     int x=binary(n,k);     printf("%d\n",x);     arr[x]='\0';     printf("%s",arr); }  
#include <stdio.h> #include <string.h> #include<iostream> #include<algorithm> #include<math.h> using namespace std; int rowNbr[] = {-1, -1, -1, 0, 0, 1, 1, 1}; int colNbr[] = {-1, 0, 1, -1, 1, -1, 0, 1}; int ROW,COL; char M[105][105]; bool visited[105][105]; int isSafe(int row, int col ,int befrow,int befcol) { return ((row >= 0) && (row < ROW) && (col >= 0) && (col < COL) && ((int)M[row][col]==(int)M[befrow][befcol]+1 ) && !visited[row][col]); } int DFS(int row, int col) { int k3=0; visited[row][col] = true; for (int k=0;k<8;k++) if (isSafe(row + rowNbr[k], col + colNbr[k],row,col) ) k3=max(k3,DFS(row + rowNbr[k], col + colNbr[k])+1); return k3; } int func(char c) { int ans=0; memset(visited, 0, sizeof(visited)); for (int i = 0; i < ROW; ++i) for (int j = 0; j < COL; ++j) if (M[i][j]==c && !visited[i][j]) { ans=max(ans,DFS(i, j)+1); } return ans; } int main() { cin>>ROW>>COL; int i,j; for(i=0;i<ROW;i++) for(j=0;j<COL;j++) cin>>M[i][j]; int t;char ch; int ans2; cin>>t; while(t--) { cin>>ch; ans2=func(ch); if(ans2!=0) printf("Strong %d\n",ans2); else printf("Weak\n"); } return 0; } 
#include <bits/stdc++.h> #define f(i,x,y) for (int i = x; i < y; i++) #define fd(i,x,y) for(int i = x; i>= y; i--) #define FOR(it,A) for(typeof A.begin() it = A.begin(); it!=A.end(); it++) #define all(v) (v).begin(), (v).end() #define rall(v) (v).rbegin(), (v).rend() #define vint vector<int> #define ll long long #define clr(A,x) memset(A, x, sizeof A) #define pb push_back #define pii pair<int,int> #define fst first #define snd second #define ones(x) __builtin_popcount(x) #define cua(x) (x)*(x) #define eps (1e-9) #define oo (1<<30) #define debug(x) cout <<#x << " = " << x << endl #define adebug(x,n) cout <<#x<<endl; f(_i,0,n)cout<<x[_i]<<char(_i+1==n?10:32) #define mdebug(x,m,n) cout <<#x<<endl; f(i,0,m)f(j,0,n)cout<<x[i][j]<<char(j+1==n?10:32) #define N 1005 using namespace std; template<class T> inline void mini(T &a,T b){if(b<a) a=b;} template<class T> inline void maxi(T &a,T b){if(b>a) a=b;}  bool comp (int i, int j); struct suff_arr { 	int n, t; 	int *r, *p, *h; 	suff_arr() {}  	inline int val(int i){ return p[i+t]; }  	void solve(char *s) { 		n = strlen(s); 		r = new int[n+1]; 		p = new int[n+1]; 		h = new int[n+1]; 		int bc[256]; 		f(i,0,256) bc[i] = 0; 		f(i,0,n) ++bc[s[i]]; 		f(i,1,256) bc[i] += bc[i-1]; 		f(i,0,n) r[--bc[s[i]]] = i; 		f(i,0,n) p[i] = bc[s[i]]; 		int pals = 0; 		f(i,0,n) if (p[i] == 0) pals++; 		reverse(r, r + pals); 		f(i,0,pals) p[r[i]] = i; 		p[n] = -1; 		for(t = 1; t<n; t*=2){ 			for(int i = 0, j = 1; j < n; i = j++){ 				while (j<n && p[r[i]] == p[r[j]]) j++; 				if (j-i==1) continue; 				int *ini = r+i, *fin = r+j; 				sort (ini, fin, comp); 				int pri = val(*ini), num = i, pk; 				for(; ini < fin; p[*ini++] = num){ 					if ( (pk=val(*ini)) == pri || (i<=pri && pk<j)){} 					else pri = pk, num = ini-r; 				} 			} 		} 	} 	void lcp(char *s){ 		int tam = 0, i,j; 		for(i = 0; i<n; i++)if (p[i]){ 			j = r[p[i]-1]; 			while (s[i+tam]==s[j+tam]) tam++; 			h[p[i]] = tam; 			if (tam) tam--; 		} 	} } sa;  bool comp(int i, int j) {  	return sa.val(i) < sa.val(j); }  struct stripe { 	int n; 	vector<int> s; 	stripe() {} 	stripe(int n): n(n) { 		int off = 1; 		for (; off < n; off<<=1); 		s = vector<int>(off*2, oo); 	} 	inline int fun(int a, int b) { 		return min(a, b); 	} 	inline void funing(int &a, int b) { a = b; }  	inline int get(int a, int b) { return get(a, b, 0, 0, n); } 	inline int get(int a, int b, int x, int le, int ri) { 		if (b <= le || ri <= a) return oo; 		if (a <= le && ri <= b) return s[x]; 		int me = (le + ri) / 2, L = x + x + 1, R = L + 1; 		return fun(get(a, b, L, le, me), get(a, b, R, me, ri)); 	} 	inline void update(int a, int val) { update(a, val, 0, 0, n); } 	inline void update(int a, int val, int x, int le, int ri) { 		if (le + 1 == ri) funing(s[x], val); 		else { 			int me = (le + ri) / 2, L = x + x + 1, R = L + 1; 			if (a < me) update(a, val, L, le, me); 			else update(a, val, R, me, ri); 			s[x] = fun(s[L], s[R]); 		} 	}  	void impr() { 		f(i,0,n) cout << get(i,i+1) << char(i+1 == n? 10 : 32); 		f(i,0,s.size()) cout << s[i] << char(i+1 == s.size()? 10 : 32); 	} } st;   char word[N][N]; char s[N*N]; int n,m, tc; int tabla[N]; int where[N*N];  int main(){ 	cin >> tc; 	while (tc--) { 		cin >> n >> m; 		f(i,0,n) scanf("%s", word[i]); 		s[0] = 0; 		f(i,0,n) { 			strcat(s, word[i]); 			strcat(s, "$"); 		} 		sa.solve(s);  		stripe st(n); 		int ind = 0; 		f(i,0,n) { 			st.update(i, sa.p[ind]); 			tabla[i] = sa.p[ind]; 			int from = ind; 			ind += strlen(word[i]) + 1; 			f(ii, from, ind) where[ii] = i; 		}  		int q; cin >> q; 		while (q--) { 			int x, u, v; 			scanf("%d", &x); 			if (x) { 				scanf("%d", &u); 				ind = sa.r[tabla[u]]; 				if (s[ind] != '$') { 					st.update(u, sa.p[ind+1]); 					tabla[u] = sa.p[ind+1]; 				} 			} else { 				scanf("%d%d", &u, &v);  				int minp = st.get(u,v+1); 				printf("%d\n", minp < 0 ? n + minp : where[sa.r[minp]]); 			} 		} 	} }  
import sys  t=int(input()) while t>0: 	A=list(raw_input()) 	B=list(raw_input()) 	C=list(set(B)) 	D=[] 	F=[] 	Arr=[] 	for i in xrange(len(C)): 		D.append(A.count(C[i])) 		F.append(B.count(C[i])) 		Arr.append(D[i]/F[i]) 	print min(Arr) 	t=t-1
#include<iostream> using namespace std;  struct trie{ 	struct trie *child[2]; 	int count[2]; 	trie():count(),child(){} };  void insert(trie *root,int n){ 	trie *ptr=root; 	for(int i=20;i>=0;i--){ 		int p=(n>>i)&1; 		 		 		if(ptr->child[p]==NULL) 			ptr->child[p]=new trie(); 		ptr->count[p]++; 		ptr=ptr->child[p]; 		 	} 			 }  int query(trie *root,int x,int k,int level){ 	if(level==-1 || root==NULL) 		return 0; 	int p=(x>>level)&1; 	int q=(k>>level)&1;  	if(p==0 && q==0) 		return query(root->child[0],x,k,level-1); 	else if(p==0 && q==1) 		return root->count[0]+query(root->child[1],x,k,level-1); 	else if(p==1 && q==0) 		return	query(root->child[1],x,k,level-1); 	else if(p==1 && q==1) 		return root->count[1]+query(root->child[0],x,k,level-1);  }  int main(){ 	int t,n,k,a; 	cin>>t;  	while(t--){ 		cin>>n>>k; 		int x=0; 		long long count=0;  		trie *root=new trie; 		insert(root,0); 		for(int i=0;i<n;i++){ 			cin>>a; 			x^=a; 			count+=(long long)query(root,x,k,20); 			insert(root,x);  		}  		cout<<count<<endl; 	}  	return 0; } 
#include<cstdio> #include<algorithm>  using namespace std;  int T, m, n, matrica[105][105], dimenzija;  int main() {     scanf("%d", &T);     while(T--) {         scanf("%d %d", &m, &n);         for(int i=1; i<=m; i++)             for(int j=1; j<=n; j++) {                 scanf("%d", &matrica[i][j]);                 matrica[i][j]+=matrica[i][j-1]+matrica[i-1][j]-matrica[i-1][j-1];             }         for(int i=1; i<=m; i++)             for(int j=1; j<=m; j++) {                 for(int k=dimenzija+1; k<=min(i, j); k++)                     if(matrica[i][j]-matrica[i-k][j]-matrica[i][j-k]+matrica[i-k][j-k]==k*k)                         dimenzija=k;                     else break;             }         printf("%d\n", dimenzija);         dimenzija=0;     }     return 0; } 
#include <bits/stdc++.h> #define ll long long int #define MAX 100001 #define EPS 1e-9 #define MOD 1000000007 #define INF 1e9 #define pn() printf("\n") #define vint vector <int> #define vpint vector <pair<int,int> > #define pb push_back #define mp make_pair #define ft first #define sd second #define gc() getchar_unlocked() #define ms(x,v) memset(x,v,sizeof x) #define pr_arr(i,x,size) for(i=0;i<size;i++) cout<<x[i]<<" " #define ff(i,a,b) for(i=a;i<=b;i++) #define fb(i,a,b) for(i=a;i>=b;i--) #define gprint(i) cout<<"Case #"<<i<<": " using namespace std;  template<class T> void scanint(T &x) {     register T c = gc();     x = 0;     T neg = 0;     for(;((c<48 || c>57) && c != '-');c = gc());     if(c=='-') {neg=1;c=gc();}     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}     if(neg) x=-x; }  template<class T> T modulus(T x,int m=MOD) {     return (((x%m)+m)%m); }  inline bool lt(double a, double b) {     return a + EPS < b; } inline bool gt(double a, double b) {     return a > b + EPS; } inline bool eq(double a, double b) {     return fabs(a - b) < EPS; }  ll power(ll base,ll p) {     if(p==0)         return 1;     ll temp=1;     while(p>1)     {         if(p%2!=0)             temp=(1LL*(base*temp)%MOD);         base=(1LL*(base*base)%MOD);         p/=2;     }     ll ans=(1LL*(base*temp)%MOD);     return ans; }  int main() {     ios::sync_with_stdio(false);     int t;     cin>>t;     while(t--)     {     	int n;     	cin>>n;     	int i;     	int arr[n+1];     	ff(i,1,n)     	{     		cin>>arr[i];     	}     	vint pos;     	ff(i,2,n)     	{     		if(arr[i]<arr[i-1])     		{     			pos.pb(i-1);     		}     	}     	if(!pos.empty())     	{     		vint :: iterator it1,it2;     		it1=pos.begin();     		it2=pos.end();     		it2--;     		int mini=INT_MAX,maxi=0,min_pos=1,max_pos=n;     		ff(i,*it1,(*it2)+1)     		{     			mini=min(mini,arr[i]);     			maxi=max(maxi,arr[i]);     		}     		sort(arr+1,arr+n+1);     		ff(i,1,n)     		{     			if(arr[i]==maxi)     				max_pos=i;     			if(arr[i]==mini)     				min_pos=i;     		}     		cout<<min(min_pos,*it1)<<","<<max(max_pos,(*it2)+1)<<endl;      	}      }     return 0; }
#include<bits/stdc++.h> using namespace std; # define l long int int main() { 	string s("1"); 	s.resize(5911116); 	l j=0; 	l t; 	string k; 	l n; 	for(l i=1;i<=1000000;i++) 	{ 		if(i/10==0) {s.at(j)=i+'0'; j++;} 		else if(i/100==0){ 			s.at(j)=i/10 +'0'; 			j++; 			s.at(j)=i%10+'0'; 			j++; 		} 		else if(i/1000==0) 		{ 			s.at(j)=i/100+'0'; 			j++; 			s.at(j)=(i%100)/10+'0'; 			j++; 			s.at(j)=(i%10)+'0'; 			j++; 		} 		else if(i/10000==0) 		{ 			s.at(j)=i/1000+'0'; 			j++; 			s.at(j)=(i%1000)/100+'0'; 			j++; 			s.at(j)=(i%100)/10+'0'; 			j++; 			s.at(j)=(i%10)+'0'; 			j++; 		} 		else if(i/100000==0) 		{ 			s.at(j)=i/10000+'0'; 			j++; 			s.at(j)=(i%10000)/1000+'0'; 			j++; 			s.at(j)=(i%1000)/100+'0'; 			j++; 			s.at(j)=(i%100)/10+'0'; 			j++; 			s.at(j)=(i%10)+'0'; 			j++;	 		} 		else if(i/1000000==0) 		{ 			s.at(j)=i/100000+'0'; 			j++; 			s.at(j)=(i%100000)/10000+'0'; 			j++; 			s.at(j)=(i%10000)/1000+'0'; 			j++; 			s.at(j)=(i%1000)/100+'0'; 			j++; 			s.at(j)=(i%100)/10+'0'; 			j++; 			s.at(j)=(i%10)+'0'; 			j++;	 		} 		else if(i==1000000) 		{ 			s.at(j)=1+'0'; j++; 			for(int r=0;r<6;r++) 			{ 				s.at(j+r)=0+'0'; 			} 		} 	} 	//cout<<s<<"\n"; 	cin>>t; 	while(t--){ 		cin>>n>>k; 		//int len=strlen(n); 		l r; 		//cout<<len<<"\n"; 		/*switch(len) 		{ 			case 1: r=atoll(n); break; 			case 2: r=(atoll(n)-5)*2 +1; break; 			case 3: r=(atoll(n)-37)*3 +3; break; 			case 4: r=(atoll(n)-278)*4 +5; break; 			case 5: r=(atoll(n)-2222)*5 +4; break; 			case 6: r=(atoll(n)-14815)*6 +5; break; 			case 7: r=5911116; 		}*/ 		if(n/10==0) r=n; 		else if(n/100==0) r=(n-5)*2+1; 		else if(n/1000==0) r=(n-37)*3 +3; 		else if(n/10000==0) r=(n-278)*4 +5; 		else if(n/100000==0) r=(n-2222)*5+4; 		else if(n/1000000==0) r=(n-18519)*6+9; 		else r=5911116; 		string a=s.substr(0,r); 		//cout<<a<<"\n"; 		//cout<<r<<"\n"; 		l pos=-1; 		l cnt=-1; 		do{ 			cnt++; 			pos=a.find(k,pos+1); 			//cout<<pos<<"\n"; 		}while(pos!=string::npos); 		cout<<cnt<<"\n"; 	} 	return 0; }
#include <bits/stdc++.h> using namespace std;  int main() { 	// your code goes here 	int n,t; 	cin>>t; 	while(t--){ 		cin>>n; 		cout<<n<<"/"<<n-1<<endl; 		 	} 	return 0; }
#include<iostream> using namespace std;  int main() { int t; cin>>t;  while(t--) {     long long  int n;    cin>>n;    long long int sum=0;     if(n>=10)      for(long long int i=10;i<=n;i+=10)      {          sum+=i;      }      cout<<sum<<endl;   }      return 0; } 
#include <bits/stdc++.h> using namespace std; #define gc getchar #define pc putchar #define mod 1000000007 typedef long long int lli; void inline scanint(int &x) {     register int c = gc();     x = 0;     for(;(c<48 || c>57);c = gc());     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} } void scanint(int &x, int &y){scanint(x);scanint(y);} void scanint(int &x, int &y, int &z){scanint(x);scanint(y);scanint(z);} void scanlli(lli &x){scanf("%lld",&x);} void scanlli(lli &x,lli &y){scanlli(x);scanlli(y);} void scanlli(lli &x, lli &y, lli &z){scanlli(x,y);scanlli(z);} void writeint(int x){ printf("%d",x);} void writelli(lli x){printf("%lld",x);} void space(){printf(" ");} void line(){printf("\n");} lli a[50];  int main() {     int n,i,j;     vector<lli> left,right;     lli S;     scanint(n);     scanlli(S);     for(i=0;i<n;i++)         scanlli(a[i]);     lli sum;     for(i=0;i<(1<<(n/2));i++)     {         sum=0;         for(j=0;j<(n/2);j++)         {             if(i&(1<<j))                 sum+=(a[j]);         }         left.push_back(sum);         //cout<<sum<<" ";     }     //cout<<endl;     int x;     vector<lli>:: iterator low,high;     if(n%2==0) x=n/2;     else x=n/2+1;     for(i=0;i<(1<<x);i++)     {         sum=0;         for(j=0;j<x;j++)             if(i&(1<<j))                 sum+=a[j+n/2];         right.push_back(sum);         //cout<<sum<<" ";     }     //cout<<endl;     sort(right.begin(),right.end());     lli ans=0;     for(i=0;i<(1<<(n/2));i++)     {         low=lower_bound(right.begin(),right.end(),S-left[i]);         high=upper_bound(right.begin(),right.end(),S-left[i]);         ans+=(high-right.begin())-(low-right.begin());     }     printf("%lld\n",ans); }
#include<bits/stdc++.h> using namespace std; int test,n,a,b,h,t,i,j,l,a1,b1,d[1001],m[1001][1001],q[1001]; int main() {      cin>>test;     while(test--)     {         cin>>n>>a>>b;         for(i=1;i<=n;i++)         {             for(j=1;j<=n;j++)             {                 m[i][j]=0;             }         }          for(i=1;i<=n;i++)         {             d[i]=-1;         }          for(i=1;i<=n-1;i++)         {             cin>>a1>>b1;             m[a1][b1]=1;             m[b1][a1]=1;         }         t=1;         h=1;         d[a]=0;         q[h]=a;         while(t>=h)         {             for(i=1;i<=n;i++)             {                 if((m[q[h]][i]==1)&&(d[i]==-1))                 {                      d[i]=d[q[h]]+1;                     q[t+1]=i;                     t++;                 }             }             h++;         }         cout<<d[b]<<endl;     } } 
#include<bits/stdc++.h> using namespace std; int a[100000]; int dp[10010][20]; int solve(int x,int n) {     if(x==0)         return 0;     if(n==0&&x)         return INT_MAX;     if(dp[x][n]!=-1)         return dp[x][n];     if(a[n-1]>x)         return dp[x][n]=solve(x,n-1);     return dp[x][n]=min(solve(x,n-1),1+solve(x-a[n-1],n)); } int main() {     int t;     cin>>t;     while(t--)     {         int n,q;         cin>>n;         for(int i=0;i<n;i++)             cin>>a[i];         cin>>q;         while(q--)         {             int x;             cin>>x;             memset(dp,-1,sizeof dp);             cout<<solve(x,n)<<endl;         }     }     return 0; } 
#include <iostream>  using namespace std;  bool matrix[1001][1001]; int arr[1001][1001];  inline int ones(int x1,int y1, int x2, int y2) {   int ctr=arr[x2][y2]-arr[x1][y2]-arr[x2][y1]+arr[x1][y1];   return ctr; }  void ones(int n) {   for(int x=1;x<=n;++x)   {    for( int y=1;y<=n;++y)    {     arr[x][y]=arr[x-1][y]+arr[x][y-1]-arr[x-1][y-1];     if( matrix[x][y] ) arr[x][y]+=1;    }   } }  int main() {      int t,n,h,w,area,temp,m;      cin>>t;      while(t--)      {         cin>>n;          for(int i=0;i<=n; ++i)         {           arr[0][i]=0;           arr[i][0]=0;         }          for(int i=1;i<=n;++i)         for(int j=1;j<=n;++j)         cin>>matrix[i][j];          ones(n);         area=arr[n][n];         h=1;         m=-1;          if(area==1 || area==0) { cout<< 0 <<endl; continue; }         while(h<=n)         {           if(area%h==0)           {            w=area/h;            if(w<=n)            for( int i=1; i<=n-h+1; ++i )            for( int j=1; j<=n-w+1; ++j )            {              temp=ones(i-1,j-1,i+h-1,j+w-1);              if(temp>m) m=temp;            }           }           h++;         }         if(m<0) cout<<m<<endl;         else         cout<<area-m<<endl;      }      return 0; } 
#include<iostream> #include<cstring> using namespace std;  int func(char *a,int l) { int dp0[l+1],dp1[l+1]; fill(dp0,dp0+l+1,0); fill(dp1,dp1+l+1,0); if(a[0]=='0') { dp0[0]=1; dp1[0]=0; } else { dp1[0]=1; dp0[0]=0; } int ans=0; for(int i=1;a[i]!='\0';i++) { if(a[i]=='1') { dp0[i]=dp0[i-1]-1; dp1[i]=dp1[i-1]+1; } else { dp0[i]=dp0[i-1]+1; dp1[i]=dp1[i-1]; } dp0[i]=max(dp0[i],0); } for(int i=0;i<l;i++) ans=max(ans,dp0[i]); if(dp1[l-1]==l) return l-1; return ans+dp1[l-1]; }  int main() { ios_base::sync_with_stdio(false); int t; cin>>t; while(t--) { char a[100005]; cin>>a; int l=strlen(a); cout<<func(a,l)<<endl; } return 0; } 
#include<stdio.h>   int main(){ int t; scanf("%d",&t); while(t--){     long long int x;     long long int n;     scanf("%lld %lld",&n,&x);     long long int count=0;     long long int i;     long long int a[n],max=0;     for(i=0;i<n;i++){         scanf("%lld",&a[i]);         a[i]=a[i]-x;     }          for(i=0;i<n;i++){         count=count+a[i];         if(max<count){                 max=count;             }         if(count<0){count=0;}     }     if(max<count){         max=count;     }     printf("%lld\n",max);   } return 0; }
#include<bits/stdc++.h> using namespace std; int st[400005]; int lazy[400005]; int a[100005];   void construct(int node, int i, int j) { 	if(i == j) 	{ 		st[node] = a[i]; 		return; 	} 	int mid = (i+j)/2; 	construct(node*2, i, mid); 	construct(node*2+1,mid+1,j); 	st[node] = st[node*2]+st[node*2+1]; 	return; }      void update(int node, int i, int j, int x, int y, int v) { 	if(i>j || i>y || j<x) 	return; 	if(lazy[node]!=-1) 	{ 		st[node]=(j-i+1)*lazy[node]; 		if(i!=j) 		{ 			lazy[node*2]=lazy[node]; 			lazy[node*2+1]=lazy[node]; 		} 		lazy[node]=-1; 	} 	if(i>=x && j<=y) 	{ 		st[node]=(j-i+1)*v; 		lazy[node]=-1; 		if(i!=j) 		{ 			lazy[node*2]=v; 			lazy[node*2+1]=v; 		} 		return; 	} 	update(node*2,i,(i+j)/2,x,y,v); 	update(node*2+1,(i+j)/2+1,j,x,y,v); 	st[node]=st[node*2]+st[node*2+1];  }   int query(int node, int i, int j, int x, int y) { 	if(i>j || i>y || j<x) 	return INT_MIN; 	if(lazy[node]!=-1) 	{ 		st[node]=(j-i+1)*lazy[node]; 		if(i!=j) 		{ 			lazy[node*2]=lazy[node]; 			lazy[node*2+1]=lazy[node]; 		} 		lazy[node]=-1; 	} 	if(i>=x && j<=y) 	return st[node]; 	int l=query(node*2,i,(i+j)/2,x,y); 	int r=query(node*2+1,(i+j)/2+1,j,x,y); 	return l+r; }   int main() { 	   	int t; 	cin >> t; 	while(t--) 	{ 		string s; 		cin >> s; 		memset(lazy,-1,sizeof(lazy)); 		for(int i = 0;i < s.size();i++) 		{ 			if(s[i] == 'X') 				a[i+1] = 1; 			else a[i+1] = 0; 		} 		int n = s.size(); 		construct(1, 1, n); 		int k; 		cin >> k; 		int aq,l,r; 		while(k--) 		{ 			cin >> aq >> l >> r; 			if(aq == 1) 			{ 				update(1, 1, n, l, r, 1); 			} 			else 			{ 				update(1, 1, n, l, r, 0); 			} 		} 		for(int i = 1;i <= n;i++) 			a[i] = query(1, 1, n, i, i); 		int pre[n+1], suf[n+1]; 		pre[0] = 0; 		pre[1] = a[1]; 		suf[n] = a[n]; 		for(int i = 2;i <= n;i++) 		{ 			pre[i] = pre[i-1] + a[i]; 			suf[n-i+1] = suf[n-i+2] + a[n-i+1]; 		} 		int ans = min(pre[n], n-pre[n]); 		for(int i = 1;i < n;i++) 		{ 			ans = min(ans, i-pre[i]+suf[i+1]); 		} 		cout << ans << endl; 	}   	return 0; }
#include<bits/stdc++.h> using namespace std; #define MOD 1000000007 #define ll long long int map<ll,ll> m; ll root(ll x) { if(m.find(x)==m.end())   return m[x]=x;   else if(m[x]!=x)   m[x]=root(m[x]);   return m[x]; }; int main() { ll n,k,i,a,b,u,z,ans=1;   cin>>n>>k;      for(i=0;i<k;i++)   { cin>>a>>b;     u=root(a);     z=root(b);      	if(u!=z)      m[u]=z;           //cout<<root(a)<<" "<<root(b)<<"\n";    }   vector<ll> v(n+1,0),f(n+1,1);      for(i=1;i<=n;i++)   u=root(i);      for(i=1;i<=n;i++)   f[i]=(i*f[i-1])%MOD;      map<ll,ll>::iterator it;   for(it=m.begin();it!=m.end();it++)   { //cout<<it->first<<"  "<<it->second<<"\n";     ++v[it->second];	   }      for(i=0;i<=n;i++)   { //cout<<i<<" "<<v[i]<<" "<<f[v[i]]     ans=(ans*f[v[i]])%MOD;   }      cout<<ans;   return 0;	 }
#include <cstdio> #include <iostream> #include <algorithm> #include <cmath> #include <cstring> using namespace std; #define p(x) cout<<#x<<":"<<x<<"\n"  int cs,d,m,y,d2,m2,y2,x; int M[]={0,31,28,31,30,31,30,31,31,30,31,30,31};  bool lt(int y1,int m1,int d1,int y2,int m2,int d2) {   if(y1<y2)     return 1;   if(y1>y2)     return 0;   if(m1<m2)     return 1;   if(m1>m2)     return 0;   return d1<d2; } void next(int &y,int &m,int &d) {   bool f=0;    if(!(y%400) || (!(y%4) && y%100))     f=1;   if(f) 	M[2]++;   if(d==M[m])   {     d=1; 	if(m==12) 	{ 	  m=1; 	  y++; 	} 	else 	  m++;   }   else     d++;   if(f)     M[2]--; } int f(int y1,int m1,int d1,int y2,int m2,int d2) {   int s=0,i;    for(i=0;i<=7;i++)   {     if(lt(y1,m1,d1,y2,m2,d2)) 	{ 	  s--; 	  next(y1,m1,d1); 	} 	else if(lt(y2,m2,d2,y1,m1,d1)) 	{ 	  s++; 	  next(y2,m2,d2); 	} 	else 	  return s;   }   return 8; } int main() {   scanf("%d",&cs);   while(cs--)   {     scanf("%d/%d/%d %d/%d",&m2,&d2,&y2,&m,&d); 	for(y=y2-1;y<=y2+1;y++) 	{ 	  x=f(y,m,d,y2,m2,d2); 	  if(x!=8) 	  { 	    if(x) 		{ 		  printf("%d/%d/%d IS %d DAY",m,d,y,abs(x)); 		  if(abs(x)>1) 		    printf("S"); 		  if(x>0) 		    printf(" AFTER\n"); 		  else 		    printf(" PRIOR\n"); 		} 		else 		  printf("SAME DAY\n"); 	    break; 	  } 	} 	if(y>y2+1) 	  printf("OUT OF RANGE\n");   }   return 0; } 
#include <iostream> #include <stdio.h> #include <string> #include <vector>  using namespace std;  string Binary( int n ) {          string s = "";      while( n > 0 ) {                      if( ( n % 2 ) == 0 )             s = '0' + s;         else             s = '1' + s;          n /= 2;     }      return s; }  int check42( string s ) {          int f = 0, ct = 0, v, n; 	n = s.length(); 	v = s.find("101010", f );      while( ( v >= 0 )  && ( v < n ) ) {                      ct++;         f = v + 6; 		v = s.find("101010", f );     }      return ct; } int main() {          int t = 1, i, n, sum, val;     vector<string> A( 1025 );      for( i = 1;i <= 1024;i++ )         A[ i ] = Binary( i );      while( t <= 10 ) {                      scanf("%d", &n );         sum = 0;          for( i = 0;i <= n;i++ ) {                              val = check42( A[ i ] );             sum += val;         }          printf("%d\n", sum );         t++;      }      return 0; } 
#include<stdio.h> #include<stdio.h> #include<string.h> #include<math.h> #include<stdlib.h> #include<ctype.h> #include<vector> #include<algorithm> #include<map> #include<string> #include<queue> #include<stack> using namespace std;  #define maxm 1000 #define inf (1<<29) #define ii long long int  #define pii pair<int,ii> #define mp  make_pair #define uu first #define vv second   ii mini(ii a,ii b){     if(a<b) return a;     return b; } ii maxi(ii a,ii b){     if(a>b) return a;     return b; }  int B,P; ii ans; ii C[maxm],T[maxm],trip[maxm],rem[maxm]; queue<pii>q[maxm];   void cal(int ind,ii t,int now);  int main(){      int i,j,k,l,test,t=1;      //freopen("in.txt","r",stdin);     //freopen("out1.txt","w",stdout);      while(scanf("%d %d",&B,&P)==2){          if(!B && !P) break;          B=-B;          memset(trip,0,sizeof(trip));         memset(rem,0,sizeof(rem));          ans=0;         for(i=1;i<=B;i++){             scanf("%d %d",&C[i],&T[i]);             while(!q[i].empty()) q[i].pop();         }          if(!P){             puts("0");             continue;         }          cal(1,0,P);          //printf("%d %d %d\n",rem[1],ans,trip[1]);         for(i=1;i<=B;i++){             while(rem[i]){                 cal(i,trip[i],0);                 //printf("ind= %d %d %d %d\n",i,rem[i],ans,trip[i]);             }         }          printf("%lld\n",ans);      }      return 0; }   void cal(int ind,ii t,int now){      //printf("id = %d t= %d now= %d trip[id]=%d rem[id]=%d\n",ind,t,now,trip[ind],rem[ind]);      if(ind>B){         ans=maxi(ans,t);         return ;     }      if(!rem[ind]){         trip[ind]=maxi(trip[ind],t);     }      int i;      for(i=1;i<=now;i++) q[ind].push(mp(1,t));     rem[ind]=q[ind].size();      int val=0;       if(t<trip[ind]) return ;      while(!q[ind].empty()){         pii v=q[ind].front();         if(v.vv<=trip[ind]){ val++; q[ind].pop(); }         else break;         if(val>=C[ind]) break;     }     rem[ind]=q[ind].size();     if(val){         cal(ind+1,trip[ind]+T[ind],val);         trip[ind]+=T[ind];     } 	else{ 		if(q[ind].empty()) return ; 		pii v=q[ind].front(); 		trip[ind]=v.vv; 		val=0; 		while(!q[ind].empty()){ 			pii v=q[ind].front(); 			if(v.vv<=trip[ind]){ val++; q[ind].pop(); } 			else break; 			if(val>=C[ind]) break; 		} 		rem[ind]=q[ind].size(); 		cal(ind+1,trip[ind]+T[ind],val); 		trip[ind]+=T[ind]; 	}  } 
#include<iostream> #include<cstdio> #include<cmath> #include<string> #include<vector> #include<stack> #include<algorithm> #include<sstream> #include<cstdlib> #include<cstring> #include<map> using namespace std;  #define si(n) scanf("%d",&n) #define pb push_back char A[1000]; char B[27]; char g[10]; int main() {     int t;     si(t);     while(t--)     {         gets(g);         gets(A);         scanf("%s",B);         for(int i=0;i<strlen(A);i++)         {           if(A[i]==' ')           continue;           A[i]= B[(A[i]-'A')];         }         printf("%s\n",A);     }     return 0; } 
#include<iostream> #include<cstring> using namespace std; void fn(char*a,char temp,int &top) {                     if(temp==' ')                      {                                 a[top++]='%';                                 a[top++]='2';                                 a[top++]='0';                      }                      else if(temp=='!')                      {                                 a[top++]='%';                                 a[top++]='2';                                 a[top++]='1';                      }                      else if(temp=='$')                      {                                 a[top++]='%';                                 a[top++]='2';                                 a[top++]='4';                      }                      else if(temp=='%')                      {                                 a[top++]='%';                                 a[top++]='2';                                 a[top++]='5';                      }                      else if(temp=='(')                      {                                 a[top++]='%';                                 a[top++]='2';                                 a[top++]='8';                      }                      else if(temp==')')                      {                                 a[top++]='%';                                 a[top++]='2';                                 a[top++]='9';                      }                      else if(temp=='*')                      {                                 a[top++]='%';                                 a[top++]='2';                                 a[top++]='a';                      }                      else                      a[top++]=temp; } int main() {     char a[300];     int top=0;     char temp=getchar();     while(temp!='#')     {                     while(temp!='\n' && temp!='#')                     {                              fn(a,temp,top);                              temp=getchar();                              //cout<<"whatr"<<endl;                     }                     //cout<<"voila"<<endl;                     for(int i=0;i<top;i++)                     printf("%c", a[i]);                     cout<<endl;                     temp=getchar();                     top=0;     }     return 0; }                                                                                                                                         
#include<iostream> #include<cstdio> #include<cstring>  using namespace std;  int m,n,arr[1010][1010]; int dp[1010][1010];  int dx[] = {1,-1,0,0,1,-1,-1,1}; int dy[] = {0,0,1,-1,1,-1,1,-1};  bool chk(int x,int y) {     if(x < 0 || x >= m) return 0;     if(y < 0 || y >= n) return 0;     return 1; }  int recur(int x,int y) {     if(arr[x][y] < 0) return -1e9;     if(x == m-1 && y == n-1) {         int ret = arr[x][y];         return ret;     }     if(dp[x][y] != -1) return dp[x][y];     int ret1 = arr[x][y];     for(int i=0;i<8;i++) {         if(chk(x+dx[i],y+dy[i])) {             if(arr[x+dx[i]][y+dy[i]] < 0) ret1 += arr[x+dx[i]][y+dy[i]];         }     }     if(x == 0 && y == 0) ret1 = 0;     if(y == n-1) return dp[x][y] = ret1 + recur(x+1,y);     else if(x == m-1) return dp[x][y] = ret1 + recur(x,y+1);     else return dp[x][y] = ret1 + max(recur(x+1,y),recur(x,y+1)); }  int main() {     scanf("%d,%d",&m,&n);     for(int i=0;i<m;i++) {         for(int j=0;j<n-1;j++) {             scanf("%d,",&arr[i][j]);         }         cin >> arr[i][n-1];     }     memset(dp,-1,sizeof(dp));     cout << recur(0,0); } 
#include<iostream>  using namespace std; int pow(int a,int b) { long long int c=1;        while(b>0){            if (b%2==1) c= (c * a);  a= (a * a);  b= b/2;      }              //   cout<<"ccc : "<<c<<endl;     return c;     }  int main(){     int t,n,k,p;        scanf("%d",&t);     for(int i=0;i<t;i++)     {             scanf("%d%d",&n,&k);             if(n==1)             {                     printf("%d",k-1);                     }                     else{             if(n%2==0)             {             p=pow(10,n/2-1);             p=p+k-1;             printf("\n%d",p);             while(p!=0){                         printf("%d",p%10);                         p=p/10;                         }              }             else{             p=pow(10,n/2);             p=p+k-1;             k=p/10;               printf("\n%d",p);              while(k!=0){                         printf("%d",k%10);                         k=k/10;                         }                  }                  }             }            // system("pause");             return 0;     } 
#include<iostream> #include<cstdio> #include<cmath> #include<string> #include<cstring> #include<vector> #include<bitset> #include<map> #include<set> #include<climits> #include<algorithm> #include<utility> #include<cstdlib> #include<cctype> #include<queue> #include<sstream> #include <stack> #include <list> #include <numeric> #define INT_MAX 2147483647 #define INT_MIN -2147483647 //2^31-1 #define pi acos(-1.0) #define N 1000000 #define LL unsigned long long #define read(x) scanf("%d",&x) #define write(x) printf("%d\n",x) #define assign(x,n) x=(int*)calloc(n,4) #define max(a,b) (a>b?a:b) #define min(a,b) (a<b?a:b) #define SWAP(a,b) a= a^b, b=a^b, a=a^b typedef  long long int ull; using namespace std;  bool algo( pair <int,int> i, pair <int,int> j){      if(i.first==j.first)return i.second<j.second;//this case will never come      else return i.first<j.first;                }    int main() { //freopen("in.txt","r",stdin);freopen("out.txt","w",stdout); int t; scanf("%d",&t);  while(t--){            vector< pair <int,int> > v;            int n,i,a,b,j,c=0;            scanf("%d",&n);                        for(i=0;i<n;i++){                             scanf("%d %d",&a,&b);                             v.push_back(make_pair(a,b));                             }                                         sort(v.begin(),v.end(),algo);                                             //for(i=0;i<n;i++)printf("%d %d\n",v[i].first,v[i].second);                                for(i=0;i<n;i++){                               for(j=i+1;j<n;j++){                                                 if(v[j].second<v[i].second)c++;                                                                                                   }                                                             }                       printf("%d\n",c);            }       //system("pause"); return 0; } 
#include<iostream> #include<cstdio> #include<cmath> #include<string> #include<cstring> #include<vector> #include<bitset> #include<map> #include<set> #include<climits> #include<algorithm> #include<utility> #include<cstdlib> #include<cctype> #include<queue> #include<sstream> #define read(x) scanf("%d",&x) #define write(x) printf("%d\n",x) #define assign(x,n) x=(int*)calloc(n,4) #define rep(i,n) for(i=1;i<=n;++i) typedef  long long int ull; using namespace std; typedef  pair<int,int> pr;  int main() {  int t,n,k; read(t); char *s[2]={"ON","OFF"}; while(t--) {           cin>>n>>k;           k+=1;           cout<<s[!!(k%(1<<(n)))]<<endl; }            //freopen("in.txt","r",stdin);freopen("out.txt","w",stdout);  return 0; } 
// codechef_codes.cpp : Defines the entry point for the console application. //  #include <iostream> #include <vector> #include <algorithm> #include <string> #include <cstring> #include <cstdio> #include <cassert> #include <cmath> #include <time.h> #include <cstdlib>  #define boost ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0) #define max(a,b) ((a)>(b)?a:b) #define min(a,b) ((a)<(b)?a:b) #define min_3(a,b,c) (min((a),min((b),(c)))) #define INF 1000000007  using namespace std;  int a[107];  int main() { 	boost; 	int tc,l,co,cou; 	string str; 	cin >> tc; 	while (tc--) { 		cou = 0; 		cin >> str; 		int ans = 0 , c1 =0; 		for (int i = 0; i < str.length(); i++) { 			if(str[i] == 'N')	a[i] = c1++; 			else 				a[i] = c1; 		} 		for (int i = 0; i < str.length(); i++) { 			if(str[i] == 'O')	ans = min(ans+1,a[i]); 		} 		cout << ans << endl; 	} 	 }
#include<bits/stdc++.h> using namespace std; #define ll long long int ll dp[100010]; ll A[100010]; int main() { 	int t,n,i; 	scanf("%d",&t); 	while(t>0) 	{ 		t--; 		scanf("%d",&n); 		for(i=0;i<n;i++) 		{ 			scanf("%lld",&A[i]); 		} 		if(n>=3){ 		dp[0]=A[0]; 		dp[1]=A[0]+A[1]; 		dp[2]=max(max(A[0]+A[1],A[2]+A[1]),A[2]+A[0]); 		for(i=3;i<n;i++) 		{ 			dp[i]=max(A[i]+A[i-1]+dp[i-3],A[i]+dp[i-2]); 			dp[i]=max(dp[i],dp[i-1]); 		} 		printf("%lld\n",dp[n-1]); 		} 		else 		{ 			if(n==1) 				printf("%lld\n",A[0]); 			else 				printf("%lld\n",A[0]+A[1]); 		} 	} } 
#include<bits/stdc++.h> using namespace std; #define ll long long  typedef pair<ll, ll>pll; int dp[100005][20]; vector<int> vec[100005]; int n, k; int dp1[100005][20]; void dfs(int node, int parent) {     dp[node][0] = 1;     for (int i = 0; i < vec[node].size(); i++)     {         int child_node = vec[node][i];         if (child_node != parent)         {             dfs(child_node, node);             for (int j = 1; j <= k; j++)             {                 dp[node][j] += dp[child_node][j - 1];             }         }       } } void solve(int node, int parent) {     if (parent != 0)     {         dp1[node][0] = 1;         dp1[node][1] = dp[node][1] + 1;         for (int i = 2; i <= k; i++)         {             if (dp1[parent][i - 1] != 0)                 dp1[node][i] = dp[node][i] + (dp1[parent][i - 1] - dp[node][i - 2]);         }     }     for (int i = 0; i < vec[node].size(); i++)     {         int child_node = vec[node][i];         if (child_node != parent)         {             solve(child_node, node);         }     } } int main() { 	scanf("%d",&n);     k = 15;     for (int i = 0; i < n - 1; i++)     {         int a, b;         scanf("%d%d",&a,&b);         vec[a].push_back(b);         vec[b].push_back(a);     }     dfs(1, 0);     for (int i = 0; i <= k  ; i++)     {         dp1[1][i] = dp[1][i];     }     solve(1, 0);     int q;     scanf("%d",&q);     for (int i = 0, node, xx; i < q; i++)     {         scanf("%d%d",&node,&xx);         ll ans = 0;         for (int j = 0; j <= xx; j++)         {             ans += dp1[node][j];         }         cout << ans << endl;     }     return 0; } 
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <limits> #include <string> #include <cassert>  using namespace std; typedef long long LL; typedef pair<int,int> pii;  #define forup(i,a,b) for(int i=a; i<b; ++i) #define fordn(i,a,b) for(int i=a; i>b; --i) #define rep(i,a) for(int i=0; i<a; ++i)  #define dforup(i,a,b) for(i=a; i<b; ++i) #define dfordn(i,a,b) for(i=a; i>b; --i) #define drep(i,a) for(i=0; i<a; ++i)  #define slenn(s,n) for(n=0; s[n]!='\0'; ++n)  #define gi(x) scanf("%d",&x) #define gl(x) cin>>x #define gd(x) scanf("%lf",&x) #define gs(x) scanf("%s",x)  #define pis(x) printf("%d ",x) #define pin(x) printf("%d\n",x) #define pls(x) cout<<x<<" " #define pln(x) cout<<x<<"\n" #define pds(x) printf("%.12f ",x) #define pdn(x) printf("%.12f\n",x) #define pnl() printf("\n")  #define fs first #define sc second  #define pb push_back  const int inv=1000000000; const int minv=-inv;  const int max_n=500010;  int n,k; char str[max_n+5]; int P[max_n], nP; int S[max_n], nS;  pii Q[max_n]; int nQ;  bool possible(int a) { 	int right=-1; 	for(int p=0; p<a; ++p) 		right=max(right,P[p]); 	nQ=0; 	for(int p=a; p<nP; ++p) 	{ 		// S[p-a] maps to P[p] 		int s=p-a;  		right=max(right,P[p]); 		right=max(right,S[s]);  		if(S[s]>P[p]) 			Q[nQ++]=pii(P[p],S[s]); 	}  	if(nQ==0) return (right+1<=k);  	int best=right+1+(right-Q[0].fs); 	int toadd=0; 	for(int i=0; i<nQ; ++i) 	{ 		if(i==0) toadd+=2*(Q[i].sc-Q[i].fs); 		else toadd+=2*(Q[i].sc-max(Q[i-1].sc,Q[i].fs));  		if(i+1<nQ) best=min(best,right+1+toadd+(right-Q[i+1].fs)); 		else best=min(best,right+1+toadd); 	}  	return (best<=k); }  int main() { 	gi(n); gi(k); 	gs(str);  	nP=0; nS=0; 	rep(i,n) 	{ 		if(str[i]=='H') 			P[nP++]=i; 		else if(str[i]=='S') 			S[nS++]=i; 	}  	if(not possible(nP)) 		pin(-1); 	else 	{ 		int l=max(nP-nS,0)-1, r=nP; 		while(l+1<r) //(l,r] 		{ 			int mid=(l+r)/2; 			if(possible(mid)) r=mid; 			else l=mid; 		} 		pin(r); 	} 	 	return 0; } 
#include<iostream> #include<cstdlib> #include<string> #include<list> #include <vector> #include <queue> #include <math.h> #include <algorithm> #include <map> using namespace std;    int main() { 	int dist[50010]; 	int cum[50010]; 	for (int i = 0; i < 50000; i++) { 		dist[i] = 0; 	} 	int n, val; 	int left = 0; 	int right = 0; 	int leftc = 0; 	int rightc = 0; 	scanf("%d", &n); 	for (int i = 0; i < n; i++) { 		scanf("%d", &val); 		val--; 		int num = (i - val + n) % n; 		dist[num]++;  		if (num <= n/2) {left += num; leftc++;} 		else {right += n - num; rightc++;} 	} 	//cum[0] = dist[0]; 	for (int i = 0; i < n; i++) { 		//cum[i] = cum[i-1] + dist[i]; 		//printf("%d\n", dist[i]); 	} 	int mid = n/2; 	int start = 0; 	int min = left + right; 	//printf("%d %d\n", left, right); 	for (int i = 0; i < n; i++) { 		int a = (start - 1 + n) % n; 		leftc -= dist[mid]; 		left -= dist[mid] * (n/2); 		left += leftc; 		leftc += dist[a];  		right -= dist[a]; 		rightc -= dist[a]; 		right -= rightc; 		rightc += dist[mid]; 		right += dist[mid] * (n - (n / 2) - 1);  		if (left + right < min) {min = left + right;} 		mid = (mid - 1 + n) % n; 		start = (start - 1 + n) % n; 		//printf("%d %d \n", left , right); 		 	} 	printf("%d\n", min); 	return 0; } 
/* Author : Pranav BITS PILANI Hyderabad Campus */ #include <vector> #include <list> #include <map> #include <set> #include <queue> #include <stack> #include <algorithm> #include <iostream> #include <cstdio> #include <cmath> #include <cstdlib> #include <cctype> #include <cstring> using namespace std;  #define sz(a) int((a).size()) #define pb push_back #define all(c) (c).begin(),(c).end() #define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) #define present(c,x) ((c).find(x) != (c).end()) #define cpresent(c,x) (find(all(c),x) != (c).end()) #define fr(i,n) for(i=0; i<n; i++) #define mod 1000000007 #define f first #define s second #define mp(x,y) make_pair(x,y) typedef pair <int, int> paint; typedef long long ll; int main() { 	int t,n,i,j,x,y; 	ll s=0;j=-1;     cin>>n; 	map<int,int> M; 	for(i=0;i<n;i++){ 		cin>>x; 		M[x]++; 		while(M[x]==2){ 			M[x]=0; 			x++; 			M[x]++; 		} 	}     tr(M,it){ 		x=(*it).f;         y=(*it).s; 		if(y==1) 			{s+=x-j-1;j=x;} 	}     cout<<s<<endl; }
#include <iostream> #include <sstream> #include <cstdio> #include <cstdlib> #include <algorithm> #include <cmath> #include <cstring> #include <string> #include <map> #include <set> #include <stack> #include <vector> #include <queue>  using namespace std;  #define SI ({int x;scanf("%d",&x);x;}) #define MP make_pair #define PB push_back #define all(x) (x).begin(), (x).end() #define rall(x) (x).rbegin(), (x).rend() #define getSize(x) ((int) (x).size())  const int INF = (1000000007); typedef pair<int,int> PII; typedef long long LL;  int N, M, K, X; vector<int> pos[100001]; int main(int argc, char** argv) {      N = SI, M = SI, K = SI;      for(int i = 0; i < N; ++i)      { 	  X = SI; 	  pos[X].PB(i - getSize(pos[X]));      }       int res = 1;      for(int i = 1; i <= M; ++i) 	  for(int j = 0; j < getSize(pos[i]); ++j) 	       res = max(res, j - int(lower_bound(all(pos[i]), pos[i][j] - K) - pos[i].begin()) + 1);      printf("%d\n", res);      return 0; }  
#include<cstdio> #include<cstring> #include<cmath> #include<cstdlib> #include<cstdio> #include<ctime> #include<cctype> #include<cassert> #include<climits> #include<cerrno> #include<cfloat> #include<ciso646> #include<clocale> #include<csetjmp> #include<csignal> #include<cstdarg> #include<cstddef> #include<cstdio> #include<cstdlib> #include<cstring> #include<ctime> #include<cwchar> #include<cwctype>  //containers #include<vector> #include<list> #include<map> #include<queue> #include<deque> #include<set> #include<complex> #include<string> #include<stack> #include<bitset> #include<istream> #include<valarray>  //IOs #include<iostream> #include<sstream> #include<iomanip> #include<fstream> #include<exception> #include<ios> #include<iosfwd> #include<ostream> #include<iterator> #include<stdexcept> #include<streambuf>   //algorithm & miscellaneous #include<algorithm> #include<functional> #include<numeric> #include<utility> #include<limits> #include<locale> #include<memory> #include<new>  #define ll long long #define ull unsigned long long #define ld long double #define mp make_pair #define pb push_back #define inf (ll)1e18 #define iinf (int)1e9 #define triple(a,b,c) make_pair(a,make_pair(b,c)) #define two(a,b) make_pair(a,b) #define fi first #define se second #define pii pair<int,int> #define pll pair<long long,long long> #define psi pair<string,int> #define pis pair<int,string> #define pss pair<string,string> //#define vi vector<int> #define vl vector<long long> #define vs vector<string> #define vc vector<char> #define vpii vector<pii> #define GI ({int t;scanf("%d",&t);t;}) #define GD ({double t;scanf("%lf",&t);t;}) #define GF ({float t;scanf("%f",&t);t;}) #define GL ({long long t;scanf("%lld",&t);t;}) #define GLD ({long double t;scanf("%Lf",&t);t;}) #define clear(c,v) memset(c,v,sizeof(c)) #define SET(c) memset(c,-1,sizeof(c))  int dx[] = {-1,0,0,1,-1,-1,1,1}; int dy[] = {0,-1,1,0,-1,1,-1,1}; const double eps = 1e-9;  const int MAXN = 100010, MAXE = 300010;  using namespace std;  double dp[100001], p[100001]; int vis[100001],n;  int main() {             n = GI;              for(int i=0;i<n;i++)                     p[i] = GD;              double sum = 0.0, tot = 0.0;              for(int i=0;i<n;i++)             {                     tot += sum*p[i] + sum*p[i] + p[i];                     sum = sum*p[i] + p[i];             }              printf("%.6lf\n",tot);              return 0; } 
#include<iostream> #include<cstdio> #include<algorithm>   using namespace std;   int input() { 	int n=0,sign=1; 	int ch; 	ch=getchar_unlocked(); 	while(ch<'0' || ch>'9') { 		if(ch=='-') 			sign=-1; 		ch=getchar_unlocked(); 	} 	while(ch>='0' && ch<='9') { 		n=(n<<3)+(n<<1)+ch-'0'; 		ch=getchar_unlocked(); 	} 	return n*sign; }   int main(){ 	int n,i,min=1000000001,cnt=0; 	n=input(); 	int a[n],b[n],tmp[n]; 	*a=0; 	*(b+n-1)=0; 	for(i=0;i<n;i++) 		*(tmp+i)=input(); 	if(*tmp>=0) { 		cnt++; 		*tmp=-1; 	} 	if(*(tmp+n-1)<=0) { 		cnt++; 		*(tmp+n-1)=1; 	} 	for(i=1;i<n;i++) { 		if(*(tmp+i)>=0) 			*(a+i)=*(a+i-1)+1; 		else 			*(a+i)=*(a+i-1); 	} 	for(i=n-2;i>=0;i--) { 		if(*(tmp+i)<=0) 			*(b+i)=*(b+i+1)+1; 		else 			*(b+i)=*(b+i+1); 	} 	for(i=1;i<n-1;i++) 		if(*(a+i)+*(b+i)<min) 			min=*(a+i)+*(b+i); 	if(n>2) 		cnt+=min-1; 	printf("%d\n",cnt); 	return 0; } 
#include<cstdio> #include<cstring> #include<cmath> #include<cstdlib> #include<cstdio> #include<ctime> #include<cctype> #include<cassert> #include<climits> #include<cerrno> #include<cfloat> #include<ciso646> #include<clocale> #include<csetjmp> #include<csignal> #include<cstdarg> #include<cstddef> #include<cstdio> #include<cstdlib> #include<cstring> #include<ctime> #include<cwchar> #include<cwctype>  //containers #include<vector> #include<list> #include<map> #include<queue> #include<deque> #include<set> #include<complex> #include<string> #include<stack> #include<bitset> #include<istream> #include<valarray>  //IOs #include<iostream> #include<sstream> #include<iomanip> #include<fstream> #include<exception> #include<ios> #include<iosfwd> #include<ostream> #include<iterator> #include<stdexcept> #include<streambuf>   //algorithm & miscellaneous #include<algorithm> #include<functional> #include<numeric> #include<utility> #include<limits> #include<locale> #include<memory> #include<new>  #define ll long long #define ull unsigned long long #define ld long double #define mp make_pair #define pb push_back #define inf (ll)1e18 #define iinf (int)1e9 #define triple(a,b,c) make_pair(a,make_pair(b,c)) #define two(a,b) make_pair(a,b) #define fi first #define se second #define pii pair<int,int> #define pll pair<long long,long long> #define psi pair<string,int> #define pis pair<int,string> #define pss pair<string,string> //#define vi vector<int> #define vl vector<long long> #define vs vector<string> #define vc vector<char> #define vpii vector<pii> #define GI ({int t;scanf("%d",&t);t;}) #define GD ({double t;scanf("%lf",&t);t;}) #define GF ({float t;scanf("%f",&t);t;}) #define GL ({long long t;scanf("%lld",&t);t;}) #define GLD ({long double t;scanf("%Lf",&t);t;}) //#define clear(c,v) memset(c,v,sizeof(c)) #define SET(c) memset(c,-1,sizeof(c))  int dx[] = {-1,0,0,1,-1,-1,1,1}; int dy[] = {0,-1,1,0,-1,1,-1,1}; const double eps = 1e-9;  const int MAXN = 100010, MAXE = 300010;  const ll mod = (ll)1e9 + 9; using namespace std;  int cnt = 0,scnt = 0,n,k;  vector<int> seq;  void doit(int pos,vector<int> &seq) {         if(pos == n)         {                 int fg = 0;                  for(int i=0;i<n;i++)                         for(int j=i;j<n;j++)                 {                             int sum = 0;                              for(int q=i;q<=j;q++)                                         sum ^= seq[q];                              if(sum == 0)fg = 1;                 }                  cnt += !fg;                 return ;         }          for(int i=0;i<=((1<<k)-1);i++)         {                 vector<int> tseq = seq;                 tseq.pb(i);                 doit(pos+1,tseq);         } } int main() {         /*for(n=1;n<=10;n++)         {                 for(k=1;k<=4;k++)                 {                              cnt = 0;                             seq.clear();                             doit(0,seq);                              cout<<n<<" "<<k<<" "<<cnt<<"\n";                 }         }*/          n = GI;          k = GI;          ll ans = 1,pow2 = 1;          for(int i=0;i<k;i++)                 pow2 = (pow2 * 2LL)%mod;          for(int i=0;i<n;i++)                 ans = ((ans%mod) * (pow2 - i - 1 + mod)%mod)%mod;          printf("%lld\n",ans);          return 0; } 
#include<stdio.h> #include<iostream> #include<string.h> #include<vector> #include<set> #include<string> using namespace std;  #define sz(z) z.size() #define pb push_back  char temp[20000][1024]; int main(){ int o; cin>>o; for(int T=1;T<=o;T++){ int n,q; cin>>n>>q; getchar(); gets(temp[0]); int k=(1<<n); set<string> st; int co=0; for(int i=1;i<k;i++){ for(int j=1;j<n-1;j++)temp[i][j-1]=temp[i-1][j]; if(temp[i-1][0]=='+')temp[i][n-1]='-'; if(temp[i-1][0]=='-')temp[i][n-1]='+'; if(temp[i-1][0]=='+'){ if(temp[i-1][n-1]=='+')temp[i][n-2]='-'; if(temp[i-1][n-1]=='-')temp[i][n-2]='+'; } else temp[i][n-2]=temp[i-1][n-1]; temp[i][n]=0; string te=string(temp[i]); if(!st.count(te))st.insert(te); else break; co++; } if(co!=0)k=co; printf("Experiment #%d:\n",T); for(int i=0;i<q;i++){ int t; cin>>t; if(n==1 && t>0){ temp[t%k][0]='+'; } t=t%k; printf("%s\n",temp[t]); } } return 0; } 
#include <cstdio> #include <algorithm> #include <vector> #include <queue> #include <iostream>  enum type { NOTHING, BASE, PIPUL };  struct cell { 	short x, y; 	int altitude; 	type T; 	bool visited; };  cell Cells[50][50] = {{{0,0,0,NOTHING,false}}}; std::vector<int> altitudes;  class compareCells { 	bool reverse; public: 	compareCells(const bool& revparam = true) 	{ reverse = revparam; } 	bool operator() (const cell *A, const cell *B) const { 		if (reverse) return A->altitude > B->altitude; 		else return A->altitude < B->altitude; 	} };  std::priority_queue<cell*, std::vector<cell*>, compareCells> toVisit;  int K_count = 0; int K_visited = 0;  void resetVisited(int m, int base_x, int base_y) { 	for (int i = 0; i < m; i++) 		for (int j = 0; j < m; j++) 			Cells[i][j].visited = false; 	K_visited = 0; 	//	if (!toVisit.empty()) 		//printf("Warning! toVisit heap should be empty a the end of min run.\n"); 	toVisit.push(&Cells[base_x][base_y]); }  unsigned SAFE(int x, int max, int min) { 	return ((x > max) ? max : ((x < min ) ? min : x)); }  bool DFS(cell *C, int max, int min, int K, int m) { 	//	if (C != &Cells[C->x][C->y]) 		//printf("All HELL!\n"); 	//printf("DFS reached [%d, %d] with alt %d, visited %d\n", C->x, C->y, C->altitude, C->visited); 	C->visited = true; 	if (C->T == PIPUL) { 		//printf("K visited! %d\n", K_visited + 1); 		K_visited += 1; 	} 	if (K_visited == K) { 		//printf("All K found!\n"); 		return true; 	} 	if (C->altitude < min) { 		//printf("This cell is not viable\n"); 		return false; 	} 	else if (C->altitude >= min && C->altitude > max) { 		//printf("This cell may be visited in the future.\n"); 		toVisit.push(C); 		return false; 	}		 	for (int i = -1; i < 2; i++) 		for (int j = -1; j < 2; j++) { 			int s_x = SAFE(C->x + i, m-1, 0); 			int s_y = SAFE(C->y + j, m-1, 0); 			if (s_x == C->x && s_y == C->y) 				continue; 			//printf("Considering neighbour [%d, %d] with alt %d\n", s_x, s_y, Cells[s_x][s_y].altitude); 			if (Cells[s_x][s_y].visited) { 				//printf("Already visited, continuing...\n"); 				continue; 			} 			else if (Cells[s_x][s_y].altitude >= min) { 				if (Cells[s_x][s_y].altitude <= max) { 					//printf("Exploring possible DFS\n"); 					if (DFS(&Cells[s_x][s_y], max, min, K, m)) 						return true; 				} 				else { 					//printf("Pushing [%d, %d] onto stack\n", s_x, s_y); 					Cells[s_x][s_y].visited = true; 					toVisit.push(&Cells[s_x][s_y]); 				} 			} 			else { 				Cells[s_x][s_y].visited = true; 				//printf("Cell is not min viable, continuing!\n"); 			} 		} 	return false; }  int main() { 	int m; 	scanf("%d", &m); 	char row[50]; 	for (int i = 0; i < m; i++) { 		scanf("%s", row); 		for (int j = 0; j < m; j++) { 			Cells[j][i].x = j; 			Cells[j][i].y = i;			 			if (row[j] == 'P') 				Cells[j][i].T = BASE; 			else if (row[j] == 'K') { 				Cells[j][i].T = PIPUL; 				K_count++; 			} 		} 	} 	//	printf("m is %d, and K_count is %d\n", m, K_count); 	int base_alt = 0; 	int min_alt = 999999; 	int max_alt = 0; 	int base_x, base_y; 	for (int i = 0; i < m; i++) 		for (int j = 0; j < m; j++) { 			scanf("%d", &(Cells[j][i].altitude)); 			if (Cells[j][i].T == BASE) { 				base_alt = Cells[j][i].altitude; 				base_x = j; 				base_y = i; 			} 			if (Cells[j][i].altitude < min_alt && Cells[j][i].T == PIPUL) 				min_alt = Cells[j][i].altitude; 			if (Cells[j][i].altitude > max_alt && Cells[j][i].T == PIPUL) 				max_alt = Cells[j][i].altitude; 			altitudes.push_back(Cells[j][i].altitude); 		} 	//printf("Before normalization, max alt %d min alt %d base alt %d\n", max_alt, min_alt, base_alt); 	max_alt -= base_alt; 	min_alt -= base_alt; 	for (int i = 0; i < m; i++) 		for (int j = 0; j < m; j++) { 			Cells[i][j].altitude -= base_alt; 			altitudes[j + m * i] -= base_alt; 		} 	base_alt = 0; 	//printf("Max alt is %d, min alt is %d \n", max_alt, min_alt); 	std::sort(altitudes.begin(), altitudes.end()); 	altitudes.erase(std::unique(altitudes.begin(), altitudes.end()), altitudes.end()); 	// printf("Alts are: \n"); 	// for (int i = 0; i < altitudes.size(); i++) 	// 	printf("%d ", altitudes[i]); 	//printf("\n"); 	std::vector<int>::iterator min = std::find(altitudes.begin(), altitudes.end(), min_alt);  	toVisit.push(&Cells[base_x][base_y]); 	int ans = 999999; 	for (; min >= altitudes.begin(); min--) { 		for ( std::vector<int>::iterator max = 			      std::find(altitudes.begin(), altitudes.end(), max_alt); 		      max != altitudes.end(); max++) { 			if (*max - *min >= ans) 				continue; 			//printf("Considering max as %d and min as %d\n", *max, *min); 			while (!toVisit.empty() && toVisit.top()->altitude <= *max) { 				//printf("Visiting top of stack\n"); 				if (DFS(toVisit.top(), *max, *min, K_count, m)) 					if (*max - *min < ans) { 						//printf("New answer found from max %d and min %d\n", *max, *min); 						ans = *max - *min; 						while (!toVisit.empty()) toVisit.pop(); 						break; 					} 				toVisit.pop(); 			} 		} 		resetVisited(m, base_x, base_y); 	} 	printf("%d\n", ans); 	return 0; } 
#include<cstdio> #include<cstring> #include<cmath> #include<cstdlib> #include<cstdio> #include<ctime> #include<cctype> #include<cassert> #include<climits> #include<cerrno> #include<cfloat> #include<ciso646> #include<clocale> #include<csetjmp> #include<csignal> #include<cstdarg> #include<cstddef> #include<cstdio> #include<cstdlib> #include<cstring> #include<ctime> #include<cwchar> #include<cwctype>  //containers #include<vector> #include<list> #include<map> #include<queue> #include<deque> #include<set> #include<complex> #include<string> #include<stack> #include<bitset> #include<istream> #include<valarray>  //IOs #include<iostream> #include<sstream> #include<iomanip> #include<fstream> #include<exception> #include<ios> #include<iosfwd> #include<ostream> #include<iterator> #include<stdexcept> #include<streambuf>   //algorithm & miscellaneous #include<algorithm> #include<functional> #include<numeric> #include<utility> #include<limits> #include<locale> #include<memory> #include<new>  #define ll long long #define ull unsigned long long #define ld long double #define mp make_pair #define pb push_back #define inf (ll)1e18 #define iinf (int)1e9 #define triple(a,b,c) make_pair(a,make_pair(b,c)) #define two(a,b) make_pair(a,b) #define fi first #define se second #define pii pair<int,int> #define pll pair<long long,long long> #define psi pair<string,int> #define pis pair<int,string> #define pss pair<string,string> #define vi vector<int> #define vl vector<long long> #define vs vector<string> #define vc vector<char> #define vpii vector<pii> #define GI ({int t;scanf("%d",&t);t;}) #define GD ({double t;scanf("%lf",&t);t;}) #define GF ({float t;scanf("%f",&t);t;}) #define GL ({long long t;scanf("%lld",&t);t;}) #define GLD ({long double t;scanf("%Lf",&t);t;})   int dx[] = {-1,0,0,1,-1,-1,1,1}; int dy[] = {0,-1,1,0,-1,1,-1,1}; const double eps = 1e-9;  using namespace std;  const ll mod = (ll)1e9;  vector< pair<ll, pii> > e; int parent[1000001],rank[1000001],sets[1000001],ns; ll sum[1000001];  void init(int n) {               ns = n;                for(int i=0;i<n;i++)               {                       parent[i] = i;                       rank[i] = 0;                       sets[i] = 1;               }               return ; }  int find_set(int i) {                  if(parent[i]==i)                                  return i;                   return parent[i]=find_set(parent[i]); }  void union_set(int x,int y) {                    int p1=find_set(x);                    int p2=find_set(y);                     if(p1==p2)return ;                     if(rank[p1]==rank[p2])                                         rank[p1]+=1;                    else if(rank[p1]<rank[p2])                         swap(p1,p2);                     parent[p2]=p1;                     sets[p1]+=sets[p2];                     ns-=1;  }  int main() {           int n = GI, m = GI;            e.clear();            init(n);            for(int i=0;i<m;i++)           {                   int u = GI, v = GI;                   ll w = GL;                   u--,v--;                   e.pb(mp(w,mp(u,v)));           }            sort(e.begin(),e.end());            ll ans = 0;            if(m > 0)           sum[0] = e[0].fi;            for(int i=1;i<m;i++)                   sum[i] = sum[i-1] + e[i].fi;            for(int i=m-1;i>=0;i--)           {                   int x = find_set(e[i].se.fi), y = find_set(e[i].se.se);                   if(x != y)                   {                        ll tmp = (ll)(sets[x]%mod);                        tmp = (tmp%mod)*(ll)(sets[y]%mod);                        tmp = (tmp%mod)*(sum[i]%mod);                        ans = (ans%mod  + tmp%mod)%mod;                        union_set(x,y);                   }                   //cout<<ans<<" ";           }            printf("%lld\n",ans);            scanf("\n");           return 0; }   
#include <bits/stdc++.h> using namespace std; int main(){     int x;     cin>>x;     while(x--){     int a,b;     cin>>a;     int arr[100000];     for(int i=0;i<a;i++){         cin>>arr[i];     }     if(a==1){      cout<<arr[0]<<endl;        }     else {     b=arr[0];     for(int j=1;j<a;j++){         b=__gcd(b,arr[j]);     }     cout<<b<<endl;     }     }      return 0; }  
#include<iostream> #include<vector> using namespace std; #define N 100005 int S[N],E[N]; int t=0; vector <int> gr[N]; void dfs(int v,int p) {   S[v]=t;   t++;   int x;   for(x=0;x<gr[v].size();x++)   {     if(gr[v][x]!=p)     {       dfs(gr[v][x],v);     }   }   E[v]=t;   t++; }  int main() {  int t,a,b,c,d,f;  cin>>a;    for(b=0;b<(a-1);b++)  {   cin>>c>>d;   gr[c].push_back(d);  }  dfs(1,0);   cin>>d;  for(b=0;b<d;b++)  {   int p,q;    cin>>p>>q;   if(S[p] < S[q] && E[p] > E[q])   {     cout<<p<<" taught "<<q<<endl;    continue;   }   if(S[q] < S[p] && E[q] > E[p])   {     cout<<q<<" taught "<<p<<endl;     continue;   }  cout<<"No idea"<<endl;  }  return 0; }
#include <stdio.h> #include <vector> #define MX_N 1010  using namespace std;  vector<int> arr[MX_N]; int team[MX_N]; int t,n,error;  void dfs(int i,int T) { 	if(team[i]) { 		if(team[i] != T) error = 1; 		return; 	} 	team[i] = T; 	for(int j=0;j<arr[i].size();j++) { 		dfs(arr[i][j],-T); 	} } int main() { 	int i,j; 	scanf("%d",&t); 	while(t--) { 		scanf("%d",&n); 		for(i=1;i<=n;i++) { 			team[i] = 0; 			while(!arr[i].empty()) arr[i].pop_back(); 		} 		for(i=1;i<=n;i++) { 			int x,y; 			scanf("%d",&x); 			while(x--) { 				scanf("%d",&y); 				arr[i].push_back(y); 				arr[y].push_back(i); 			} 		} 		error = 0; 		for(i=1;i<=n;i++) { 			if(!team[i]) { 				dfs(i,1); 			} 		} 		if(error) { 			printf("-1"); 		}else { 			for(i=1;i<=n;i++) { 				if(team[i] == 1) 					printf("L"); 				else 					printf("R"); 			} 		} 		printf("\n"); 	} 	return 0; }
#include <iostream> #include <string.h>   using namespace std;    bool wayofsort(int x,int y)  {  	return x>y;  }     int main() { 	long long int t; 	cin>>t; 	while(t--) 	{ 		string a,b; 		cin>>a>>b; 		int n=a.length(); 		int m=b.length(); 		if(m==n) 		{ 		 		for(int i=0;i<n-1;i++) 		{ 			for(int j=0;j<n-i-1;j++) 			{ 				if(int(a[j])>int(a[j+1])) 				{ 					swap(a[j],a[j+1]); 				} 			} 		} 		 		for(int i=0;i<m-1;i++) 		{ 			for(int j=0;j<m-i-1;j++) 			{ 				if(int(b[j])>int(b[j+1])) 				{ 					swap(b[j],b[j+1]); 				} 			} 		} 		int flag=0; 		 		 		for(int k=0;k<n;k++) 		{ 			if(a[k]!=b[k]) 			{ 				flag=1; 				break; 			} 		} 		if(flag==1) 		cout<<"NO"<<endl; 		else if(flag==0) 		cout<<"YES"<<endl; 	} 	else if(m!=n) 	cout<<"NO"<<endl; 	} 	return 0; } 
#include <iostream> using namespace std; #include<stdio.h>  int dp[1002][1002];   int main() { 	int t,m,n,k; 	scanf("%d", &t); 	while(t--) 	{ 		scanf("%d %d %d", &m, &n, &k); 		m++; 		n++; 		dp[0][1] = 1; 		for(int i = 1; i <= m; i++) 			for(int j = 1; j <= n; j++) 				dp[i][j] = (dp[i][j-1] + dp[i-1][j])%k; 		/* 		for(int i = 1; i <= m; i++) 		{ 			for(int j = 1; j <= n; j++) 			cout<<dp[i][j]<<" "; 			cout<<"\n"; 		} 		*/		 		printf("%d\n", dp[m][n]); 	} } 
#include<iostream> #include<cstdio> using namespace std; int main() { int tc; cin>>tc; while(tc--) { int a,b,c; cin>>a>>b>>c; long int p=a+b; int cas=c%p; if(cas<a) cout<<"Aman\n"; else cout<<"Anish\n"; } }
#include<bits/stdc++.h>  using namespace std;  main(){      int t,n,p1,p2;      scanf("%d",&t);      while(t--){          scanf("%d",&n);          if(n==1){             printf("4\n"); continue;         }          p1=6*n*(n-1)*n;         p2=4*n*n*n;          printf("%d \n",p1+p2);     }   } 
#include<iostream> using namespace std; int main() {     long long int t,n,a,b,c,i,j,k,ctr;     cin>>t;     while(t--)     {               cin>>n>>a>>b>>c;               ctr=0;               for(i=0;i<=a;i++)               {                                for(j=0;j<=b;j++)                                {                                                 k=n-(i+j);                                                 if(k>=0)                                                 {                                                         if(k>=c)                                                         {                                                                 ctr=ctr+c+1;                                                         }                                                         else                                                         {                                                                 ctr=ctr+k+1;                                                         }                                                 }                                }               }               cout<<ctr<<"\n";     } }                                                                                                                                                                                                                                                                                                                                                
#include <cstdio>  int main () {     int testcases;     scanf("%d", &testcases);      int K;     int remainder, multiples;     while (testcases--) {        scanf("%d", &K);        remainder = K % 25;        multiples = K / 25;         if (remainder) {            while (remainder >=0){                printf("%c", remainder+'a');                remainder--;            }        }         while (multiples--) {            printf("zyxwvutsrqponmlkjihgfedcba");        }                 printf("\n");      }     return 0; } 
#include <iostream> #include <cstdio> #include <cstring> #include <cstdlib> #include <algorithm> #include <cmath> #include <climits>  using namespace std;  const int limit = 100000; int *primes = (int*)malloc(limit*sizeof(int));  int cal_prime() { 	int *isPrime = (int*)malloc(limit*sizeof(int)); 	for(int i = 3; i <= limit; i += 2) 	{ 		isPrime[i] = 1; 	} 	const int end = (int)sqrt(limit); 	for (int i = 3; i <= end; i += 2) 	{ 		if(isPrime[i]) 		{ 			for (int composite = 3; i*composite <= limit; composite += 2) 			isPrime[i*composite] = 0; 		} 	}   	int i, j; 	for ( i = 1, j = 3; j <= limit; j += 2 ) 	{ 		if ( isPrime[j] ) 		{ 			primes[i] = j; 			i++; 		} 	} 	primes[0] = 2; 	return i-1; }  int main() { 	int i, j, k, l, ind, t, m; 	long long ans, n; 	 	for(i=0; i<100000; i++) 		primes[i] = INT_MAX; 	 	ind = cal_prime(); 	 	scanf("%d", &t); 	while(t--) 	{ 		scanf("%lld %d", &n, &k); 		ans = 0; 		if(k == 0) 		{ 			ans += (n*(n-1))/2; 			printf("%lld\n", ans); 			continue; 		} 		else 		{ 			j = 0; 			i = k-1; 			while(primes[i] <= n) 			{ 				m = n - primes[i] + 1; 				if(j == 0) 					ans += m; 				else 					ans += m*(primes[j] - primes[j-1]); 				 				i++, j++; 			} 			//ans += (n - primes[i] + 1)*(primes[j] - primes[j-1]); 			printf("%lld\n", ans); 		} 	} 	return 0; }
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <string.h> #include <cstring> #define oo (int)1e9 #define fill( a , v ) memset( a , v , sizeof (a) ) #define bits( x ) __builtin_popcount( x ) #define gcd( a , b ) __gcd( a, b ) #define lcm( a , b ) (a/gcd( a, b ) ) * b #define add push_back #define s(n) scanf( "%d" , &n ) const int mxn = 10000 + 10; typedef long long ll;  using namespace std; int dx[]={0,0,1,-1}; int dy[]={1,-1,0,0};  int dp[16][1<<16][2]; short vis[16][1<<16][2]; int id; int mat[4][4]; int a[4][4];  int solve( int prev , int mask , int turn ) { 	if( !mask )return 0; 	 	int &d = dp[prev][mask][turn]; 	short &v = vis[prev][mask][turn]; 	 	if( v == id )return d; 	v = id; 	 	if( turn ) d = oo; 	else d = -oo; 	 	if( turn ) 	{ 		int x = prev / 4; 		int y = prev % 4; 		 		bool neighbour = 0; 		for(int i=0;i<4;i++) 		{ 			int nx = x + dx[i]; 			int ny = y + dy[i]; 			 			if( nx >= 0 && ny >= 0 && nx < 4 && ny < 4 ) 			{ 				int mm = mat[nx][ny]; 				 				if( mask & mm ) 				{ 					neighbour = 1; 					d = min( d , -a[nx][ny] + solve( nx * 4 + ny , mask ^ mm , !turn ) ); 				} 			} 		} 		 		if( !neighbour ) 		{ 			for(int i=0;i<16;i++) 			 if( mask & 1<<i ) 			 d = min( d , -a[i/4][i%4] + solve( i , mask ^ 1<<i , !turn )  ); 		} 	} 	else 	{ 		int x = prev / 4; 		int y = prev % 4; 		 		bool neighbour = 0; 		for(int i=0;i<4;i++) 		{ 			int nx = x + dx[i]; 			int ny = y + dy[i]; 			 			if( nx >= 0 && ny >= 0 && nx < 4 && ny < 4 ) 			{ 				int mm = mat[nx][ny]; 				 				if( mask & mm ) 				{ 					neighbour = 1; 					d = max( d , a[nx][ny] + solve( nx * 4 + ny , mask ^ mm , !turn ) ); 				} 			} 		} 		 		if( !neighbour ) 		{ 			for(int i=0;i<16;i++) 			 if( mask & 1<<i ) 			 d = max( d , a[i/4][i%4] + solve( i , mask ^ 1<<i , !turn )  ); 		}		 	} 	 	return d; }  int main() { 	for(int i=0,c=1;i<4;i++) 	 for(int j=0;j<4;j++,c<<=1) 	  mat[i][j] = c; 	   	   	int runs; 	s( runs ); 	 	while( runs-- ) 	{ 		++id; 		for(int i=0;i<4;i++) 		 for(int j=0;j<4;j++) 		  s( a[i][j] ); 		   		int soln = -oo; 		int mm = (1<<16)-1; 		 		for(int i=0;i<16;i++) 		 soln = max( soln , a[i/4][i%4] + solve( i , mm ^ 1<<i , 1 )  ); 		  		 printf( "%d\n" , soln ); 	} } 
#include <iostream> using namespace std;  const long long mod=1000000007;  int main() {   long long tests;   cin>>tests;   for(int te=0;te<tests;te++)     {   long long input;   cin>>input;   long long ans=1;   for(long long i=0;i<input-1;)     {       if(i<input-100000001) 	{ 	  //8 	  ans*=494499948; 	  ans%=mod; 	  i+=100000000; 	}       else if(i<input-10000001) 	{ 	  ans*=255718402; 	  ans%=mod; 	  i+=10000000; 	}       else if(i<input-1000001) 	{ 	  ans*=235042059; 	  ans%=mod; 	  i+=1000000; 	}       else if(i<input-100001) 	{ 	  ans*=607723520; 	  ans%=mod; 	  i+=100000; 	}       else if(i<input-10001) 	{ 	  ans*=905611805; 	  ans%=mod; 	  i+=10000; 	}       else if(i<input-1001) 	{ 	  ans*=688423210; 	  ans%=mod; 	  i+=1000; 	}       else if(i<input-101) 	{ 	  ans*=976371285; 	  ans%=mod; 	  i+=100; 	}       else if(i<input-51) 	{ 	  ans*=898961331; 	  ans%=mod; 	  i+=50; 	}       else if(i<input-11) 	{ 	  ans*=1024; 	  ans%=mod; 	  i+=10; 	}       else 	{ 	ans*=2; 	ans%=mod; 	i++; 	}     }   cout<<ans<<endl;     }   return 0; }  int main1() {   long long x=1;   for(int i=0;i<100000000;i++)     {     x*=2;     x%=mod;     }   cout<<x<<endl;   return 0; } 
#include<bits/stdc++.h> #define ll long long #define fi first #define se second ll mpow(ll a, ll n,ll mod) {ll ret=1;ll b=a;while(n) {if(n&1)     ret=(ret*b)%mod;b=(b*b)%mod;n>>=1;} return (ll)ret; } using namespace std; #define sd(x) scanf("%d",&x) #define pd(x) printf("%d",x) #define sl(x) scanf("%lld",&x) #define pl(x) printf("%lld",x) #define mem(x,a) memset(x,a,sizeof(x)) #define pii pair<int,int> #define mp make_pair #define pb push_back #define all(v) v.begin(),v.end() #define N (int)(1e5+255) int BIT[N],n,q,pos1[N],pos2[N];//where,who pii a[N]; void update(int x,int val){     for(;x<n+50;x+=(x&-x)){         BIT[x]+=val;     } } int query(int x){     int sum=0;     for(;x;x-=(x&-x)){         sum+=BIT[x];     }     return sum; } int lowerBound(int val){     int lo=1,hi=n;     if(query(hi)<val)         return n+1;     while(lo<hi){         int mid=(lo+hi)>>1;         if(query(mid)>=val){             hi=mid;         }         else{             lo=mid+1;         }     }     return lo; } void solve(){     sd(n);sd(q);     for(int i=1;i<=n;i++){         sd(a[i].fi);         a[i].se=i;     }     sort(a+1,a+n+1);     for(int i=1;i<=n;i++){         pos1[a[i].se]=i;         pos2[i]=a[i].se;     }     a[0].fi=0;     for(int i=1;i<=n;i++){         update(i,a[i].fi-a[i-1].fi);     }     for(int i=1;i<=q;i++){         int t;         sd(t);         if(t==3){             int y;             sd(y);             int x=lowerBound(y);             update(x,-1);         }         if(t==2){             int y;             sd(y);             int x=lowerBound(y);             pd(n+1-x);             printf("\n");         }         if(t==1){             int x;             sd(x);             int sz=query(pos1[x]);             int lastSz=pos2[lowerBound(sz+1)-1];             swap(pos1[x],pos1[lastSz]);             pos2[pos1[x]]=x;             pos2[pos1[lastSz]]=lastSz;             update(pos1[x],1);             update(pos1[x]+1,-1);         }     } } int main(){    //freopen("C-large-practice.IN","r",stdin);    //freopen("out.txt","w",stdout);    int t=1;    //sd(t);    for(int i=1;i<=t;i++){        //printf("Case #%d:\n",i);        solve();    }    return 0; } 
#include<iostream> #include <stdio.h> using namespace std; int main() {     int t; cin>>t;     while(t--)     {         int size=0; cin>>size;         int s=0,c=0,sg=0,cg=0;         char tt; cin.get(tt);         for(int i=0;i<size;i++)         {             char d; cin>>d;             if(d=='S')             s++;             else             c++;                          if(s==4)             {                 s=0;c=0;                 sg++;             }             else if(c==4)             {                 s=0;c=0;                 cg++;             }             else continue;         }         cout<<sg<<"-"<<cg;         if(s>0 || c>0)         {             if(s==3)             s=40;             else             s=s*15;                          if(c==3)             c=40;             else c=c*15;                          cout<<","<<s<<"-"<<c<<endl;         }         cout<<endl;     }     return 0; }
#pragma comment(linker, "/STACK:102400000,102400000") #include <iostream> #include <stdio.h> #include <algorithm> #include <string.h> #include <vector> #include <map> #include <queue> #include <set> #include <cmath> #include <fstream> #include <assert.h> #include <bitset> using namespace std; #define vi vector<int> #define pii pair<int,int> #define pb push_back #define mp make_pair #define all(x) x.begin(),x.end() #define inf 1000000007 #define mod 1000000007 #define x first #define y second #define pi acos(-1.0) #define DBG(x) cerr<<(#x)<<"="<<x<<"\n"; #define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++) #define ull unsigned long long #define ll long long #define N 100010  double p,p3[65],c[65][65],dp[10][65],p2[65],q[65]; int main() {     //freopen("1.txt","w",stdout);     int T,i,j,k,ca=0,m,n;     c[0][0]=1;     for(i=1;i<=64;i++){         c[i][0]=1;         for(j=1;j<=i;j++)c[i][j]=c[i-1][j-1]+c[i-1][j];     }     p2[0]=1;     for(i=1;i<=64;i++)p2[i]=p2[i-1]*2;     scanf("%d",&T);     while(T--){         scanf("%d%d%lf",&m,&n,&p);         if(m==0){             printf("%lf\n",1.);continue;         }         int t=n+m;         int h=0;         while(1<<h<t)h++;         p3[0]=1;q[0]=1;         for(i=1;i<=t;i++)p3[i]=p3[i-1]*p,q[i]=q[i-1]*(1-p);         memset(dp,0,sizeof(dp));         dp[0][0]=1;         //DBG(h)         for(i=0;i<h;i++){             int r=i==0?0:(1<<i);             if(r>m)r=m;             int z=(1<<i+1),y;             for(y=0;y<=r;y++)if(dp[i][y]){                 int x=(1<<i)-y;                 if(x==0||x>n)continue;                    for(k=x;k<=z-y&&k<=n;k++){                     j=z-k;                     if(j>m)continue;                     //double tot=c[1<<i+1][j];                     for(int k3=0;k3<=x;k3++){                         int k1=x-k3;                         if(2*k1+k3>k)continue;                         int j3=k-(2*k1+k3);                         if(j3>y)continue;                         int j1=y-j3;                         if(2*j1+j3+k3!=j)continue;                         dp[i+1][j]+=dp[i][y]*c[x][k3]*c[y][j3]*p3[k3]*q[j3]*p2[j3+k3];                     }                 }             }         }         printf("%.9lf\n",dp[h][m]/c[t][m]);     }     return 0; }
#include <iostream> #include <cstdio> #include <string>   int main() { 	int testcases,flag,two,five; 	unsigned long long num,unit; 	char c; 	 	std::cin>>testcases; 	for(int j=0;j<testcases;j++) 	{ 		unit=1; 		two=five=0; 		do 		{ 			std::cin>>num; 			if(num==0) 			{ 				unit=0; 				break; 			} 			while(num%2==0) 			{ 				num/=2; 				two++; 			} 			while(num%5==0) 			{ 				num/=5; 				five++; 			} 			unit=(unit*num)%10; 		}while((c=getchar())!='\n'); 		if(five>two) 			unit=5; 		else if(two>five) 			unit=(unit*2*(two-five))%10; 			 		if(unit) 			std::cout<<unit<<std::endl; 		else 			std::cout<<"Robot hanged.\n";  	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; int subsetsum(int arr[],int n,int k) { int L[k+1][n+1]; for(int i=0;i<=n;i++) L[0][i]=1; for(int i=1;i<=k;i++) L[i][0]=0; for(int i=0;i<=k;i++) { for(int j=1;j<=n;j++) { L[i][j]=L[i][j-1]; if(i>=arr[j-1]) { L[i][j]=(L[i][j] || L[i-arr[j-1]][j-1]); } } } return L[k][n]; } int main() { ios_base::sync_with_stdio(false); int t; cin>>t; while(t--) { int n,k; cin>>n>>k; int arr[n]; for(int i=0;i<n;i++) cin>>arr[i]; cout<<subsetsum(arr,n,k)<<endl; } return 0; }  
#include <iostream> #include <iomanip> #include <fstream> #include <sstream> #include <cstring> #include <string> #include <cstdio> #include <cmath> #include <cstdlib> #include <algorithm> #include <bitset> #include <vector> #include <stack> #include <list> #include <utility> #include <queue> #include <set> #include <map> using namespace std;  typedef long long ll; typedef pair<int, int> PII; typedef vector<int> VI; typedef vector<PII> VP; typedef vector<string> VS;  #define FOR(i,a,b) for(i=(a);i<(b);i++) #define FORE(it,x) for(typeof(x.begin()) it=x.begin();it!=x.end();it++) #define ALL(x) x.begin(),x.end() #define CLR(x, v) memset((x),v,sizeof (x)) #define gcd(a, b) __gcd(a, b) #define PB push_back  #define MP make_pair #define INF 2000000007  int toInt(string s){ istringstream sin(s); int t; sin>>t; return t; } template<class T> string toString(T x){ ostringstream sout; sout<<x; return sout.str(); } template<class T> void chmin(T &t, T f) { if (t > f) t = f; } template<class T> void chmax(T &t, T f) { if (t < f) t = f; } #define MOD 1009 int inv[1010]; int c[110][110]; int a[110]; int main() { 	int n,m; 	scanf("%d%d",&n,&m); 	m%=MOD; 	int i,j; 	inv[1] = 1; 	FOR(i,2,MOD) inv[i] = inv[MOD%i]*(MOD-MOD/i)%MOD; 	c[0][0] = 1; 	FOR(i,1,n+2) { 		c[i][0] = c[i][i] = 1; 		FOR(j,1,i) c[i][j] = (c[i-1][j] + c[i-1][j-1]) % MOD; 	} 	for(i=n;i>=0;i--) { 		scanf("%d",a+i); 		a[i]%=MOD; 	} 	int sum[110]; 	sum[0] = m; 	int ans = (m + 1) * a[0] % MOD; 	int p = (m+1)%MOD; 	FOR(i,1,n+1) { 		p = p * (m+1) % MOD; 		int t = p - 1; 		if(t < 0) t += MOD; 		FOR(j,0,i) { 			t -= (sum[j] * c[i+1][j]) % MOD; 			if(t < 0) t += MOD; 		} 		sum[i] = t * inv[i+1] % MOD; 		ans += sum[i] * a[i] % MOD; 		ans %= MOD; 	} 	printf("%d\n", (int)(ans%MOD)); 	return 0; } 
// written by lonerdude(dvdreddy) // all rights reserved //the template by dvdreddy #include <vector> #include <queue> #include <deque> #include <map> #include <iostream> #include <cstring> #include <string> #include <math.h> #include <cstdio> #include <cstdlib> #include <algorithm>  using namespace std;  #define s(x) scanf("%d",&x) #define sll(x) scanf("%lld",&x) #define sf(x) scanf("%lf",&x) #define ss(x) scanf("%s",&x)  #define f(i,a,b) for(int i=a;i<b;i++) #define fr(i,n)  f(i,0,n)  typedef long long ll;  int maxs = 10000000;  ll mod = 10000;  int res[10000005]; ll dp[102000];  void init(){     res[0] = 1;   dp[0] = 1;   int cur_max = 1;   ll x, ax;   int lenx;   int cnt = 0;   ll* temp;   f (i, 1, maxs + 1){     x = ((ll) ((i % mod) + 1)) * ((ll) ((i % mod) + 1));     ax  = (x % mod);     temp = lower_bound(dp, dp + cur_max, ax);     int lenx = temp - dp;     if (lenx ==  cur_max){       cur_max++;       *temp = ax;       if (cur_max == 1044){ 	f (j, i, maxs + 1){ 	  res[j] = cur_max; 	} 	break;       }     } else if (*temp > ax){       *temp = ax;     }     res[i] = cur_max;   } }  int main(){   int n; int k;   int t;   init();   s(t);   while (t--){     s(n); s(k);     if (res[n - 1] < k){       cout << "0" << endl;     } else {       cout << "1" << endl;     }   } } 
#include <vector> #include <queue> #include <deque> #include <set> #include <iostream> #include <cstring> #include <string> #include <cmath> #include <cstdio> #include <cstdlib> #include <algorithm>   using namespace std; inline void superFastRead (int *a) {     char c = 0;     while(c<33)     c = fgetc(stdin);     *a = 0;     while(c>33)     { 		*a = *a*10 + c - '0'; 		c = fgetc(stdin);     } }   #define sfr(x) superFastRead(&x) #define s(x) scanf("%d",&x) #define sll(x) scanf("%lld",&x) #define sf(x) scanf("%lf",&x) #define ss(x) scanf("%s",&x) #define f(i,a,b) for(int i=a;i<b;i++) #define fr(i,n)  f(i,0,n)   typedef long long ll;   ll w[100010];   int main(){ 	ll n, m, add = 0, res = 0; 	sll(n); sll(m); 	w[0] = 5; 	f(i, 1, n) sll(w[i]); 	multiset<ll> S; 	fr(i, m) S.insert(0); 	queue<ll> Q; 	fr(i, m) Q.push(0); 	fr(i, n){ 		add += w[i]; 		ll y = *S.rbegin() - w[i]; 		res += add + y; 		Q.push(y); 		 		ll x = Q.front(); 		Q.pop(); 		S.erase(S.find(x)); 		S.insert(y); 	} 	res += add + *S.rbegin(); 	cout<<res<<endl; 	return 0; } 
#include<stdio.h> #define inf 1000000  int* sum; int* late; int count;  inline int MaxOf(int a, int b) {     return (a>=b)?a:b; }  void Initialize(int index, int a, int b) {     if(a > b) return;     sum[index] = 0;     late[index] = -inf;     if(a < b)     {         int mid = a + (b-a)/2;         Initialize(2*index,a,mid);         Initialize(2*index+1,mid+1,b);     } }  void Initiate(int size) {     count = 1;     int temp = size;     while(temp)     {         temp >>= 1;         count++;     }     count = 1<<count;     sum = new int[count];     late = new int[count];     Initialize(1,0,size-1); }  void UpdateSum(int index, int a, int b, int x, int v) {     if(a > b || x < a || x > b) return;     if(a == b)     {         sum[index] = v;         return;     }     int mid = a + (b-a)/2;     UpdateSum(2*index,a,mid,x,v);     UpdateSum(2*index+1,mid+1,b,x,v);     sum[index] = sum[2*index] + sum[2*index+1]; }  void UpdateLate(int index, int a, int b, int x, int v) {     if(a > b || x < a || x > b) return;     if(a == b)     {         if(late[index] < v) late[index] = v;         return;     }     int mid = a + (b-a)/2;     UpdateLate(2*index,a,mid,x,v);     UpdateLate(2*index+1,mid+1,b,x,v);     late[index] = MaxOf(late[2*index],sum[2*index]+late[2*index+1]); }  int Query() {     return late[1]; }  int partition(int A[], int B[], int Hash[], int start, int end) {     int i = start;     int j = end+1;     int temp;      while(true)     {         while(A[++i] < A[start]) if(i == end) break;         while(A[--j] > A[start]) {}         if(j<=i) break;          temp = A[i];         A[i] = A[j];         A[j] = temp;         temp = B[i];         B[i] = B[j];         B[j] = temp;         temp = Hash[i];         Hash[i] = Hash[j];         Hash[j] = temp;     }      temp = A[start];     A[start] = A[j];     A[j] = temp;     temp = B[start];     B[start] = B[j];     B[j] = temp;     temp = Hash[start];     Hash[start] = Hash[j];     Hash[j] = temp;      return j; }  void quickSort(int A[], int B[], int Hash[], int start, int end) {     if(start >= end) return;     int split = partition(A,B,Hash,start,end);     quickSort(A,B,Hash,start,split-1);     quickSort(A,B,Hash,split+1,end); }  void qSort(int A[], int B[], int Hash[], int size) {     quickSort(A,B,Hash,0,size-1); }  int main() {     //freopen("TF05.in","r",stdin);     int T,temp;     int* D;     int* M;     int* Hash;     int* Inverse;     scanf("%d",&T);     D = new int[T];     M = new int[T];     Hash = new int[T];     Inverse = new int[T];     for(int i=0; i<T; ++i)     {         scanf("%d%d",&D[i],&M[i]);         Hash[i] = i;     }     qSort(D,M,Hash,T);     for(int i=0; i<T; ++i) Inverse[Hash[i]] = i;     Initiate(T);     for(int i=0; i<T; ++i)     {         temp = Inverse[i];         UpdateSum(1,0,T-1,temp,M[temp]);         UpdateLate(1,0,T-1,temp,M[temp]-D[temp]);         printf("%d\n",MaxOf(Query(),0));     }     delete[] D,M,Hash,Inverse,sum,late; 	return 0; } 
#include	<iostream>  using std::cin; using std::cout; using std::endl;  #include	<cstring>   #define		Chars		22 #define		base		1000000000  int main(){ 	int cases, i, j; 	char ch; 	char string[] = "welcome to conscientia"; 	long int *cal1 = new long int[Chars]; 	long int *cal2 = new long int[Chars]; 	cin >> cases; 	cin.get(); 	for(i = 0; i < cases; ++i){ 		memset(cal1, 0, sizeof(int) * Chars); 		memset(cal2, 0, sizeof(int) * Chars); 		while((ch = cin.get()) != '\n'){ 			for(j = 0; j < Chars; ++j){ 				if(ch == string[j]){ 					if(j == 0) 						cal2[j] =  (cal1[j] + 1) % base; 					else 						cal2[j] = (cal1[j] + cal1[j - 1]) % base; 				} else { 					cal2[j] = cal1[j]; 					if(cal2[j] == 0) 						break; 				} 			} 			memcpy(cal1, cal2, sizeof(int) * Chars); 			memset(cal2, 0, sizeof(int) * Chars);			 		} 		cout << cal1[Chars - 1] << endl; 	} 	return 0;	 }
#include<stdio.h> #include<math.h> #define MAX_PRIME 3402  int prime[MAX_PRIME]; bool chkPrime[1000002]={true,true};  inline void initPrimes() {        const int lim = 31627;        int currPos=1,primeCount=0;        do {            while(chkPrime[currPos]) currPos++;            prime[primeCount++]=currPos;            int temp=currPos;            while((temp+=currPos)<=lim)                chkPrime[temp]=true; 		   currPos++;        } while(currPos<=MAX_PRIME); 	   while(currPos<=lim){ 	       if(!chkPrime[currPos]) 			  prime[primeCount++]=currPos;  		   currPos++; 	   } } int main() { 	initPrimes();     int testCases; 	scanf("%d",&testCases);     while(testCases--){        int a,b,i,j; 	   scanf("%d%d",&a,&b);  	   for(i=b-a;i>=0;i--) 	       chkPrime[i]=true; 	   if(a==1) 	      chkPrime[0]=false; 	   int lim = (int)sqrt((double)b); 	   for(i=0;prime[i]<=lim;i++){ 		   j=a-a%prime[i]; 		   if(j<a) 			   j+=prime[i]; 		   while(j<=b){ 		       if(j!=prime[i]) 				   chkPrime[j-a]=false; 		       j+=prime[i]; 		   } 	   } 	   int count=0; 	   for(i=2;i<=b-a;i++) 	       if(chkPrime[i-2]&&chkPrime[i]) 			   count++;        printf("%d\n",count);     } 	return 0; } 
#include<bits/stdc++.h> #define pb(x) push_back(x) #define mp(i,j) make_pair(i,j) #define ll long long  int lolol; #define S(x) lolol=scanf("%l64d", &x) #define s(x) lolol=scanf("%d", &x) #define getchar_unlocked getchar using namespace std; inline int scan(){     char c = getchar_unlocked();     int x = 0;     while(c<'0'||c>'9'){         c=getchar_unlocked();     }     while(c>='0'&&c<='9'){         x=(x<<1)+(x<<3)+c-'0';         c=getchar_unlocked();     }     return x; } int main(){     ll n,m;     n=scan(); m=scan();     vector<pair<ll,ll> > a[n+1];     while(m--){         ll x,y,z;         x=scan(); y=scan(); z=scan();         a[x].pb(mp(y,2*z));         a[y].pb(mp(x,2*z));     }     vector<ll> pol;     ll k; k=scan();     for(int i=0; i<k; i++){         ll x; x=scan();         pol.pb(x);     }     ll p;      p=scan();     vector<ll> boost;     for(int i=0; i<p; i++){         ll x; x=scan();         boost.pb(x);     }     ll st,en; st=scan(); en=scan();     ll dist[n+1]; memset(dist,-1,sizeof dist);     priority_queue<pair<ll,ll> > q;     q.push(mp(0,en));     dist[en]=0;     while(!q.empty()){         ll node=q.top().second;         q.pop();         ll sz=a[node].size();         for(int i=0; i<sz; i++){             ll nbr=a[node][i].first;             ll wt=a[node][i].second;             if(dist[nbr]==-1 || dist[nbr]>dist[node]+wt){                 dist[nbr]=dist[node]+wt;                 q.push(mp(-dist[nbr],nbr));             }         }     }     ll dist_thief=dist[st];     if(dist_thief==-1){         cout<<-1;         return 0;     }     for(int i=0; i<k; i++){         if(dist[pol[i]]>=0){             if(dist[pol[i]]<=dist[st]){                 cout<<-1<<endl;                 return 0;             }         }     }     for(int i=0; i<p; i++){         if(dist[boost[i]]>=0){             a[boost[i]].pb(mp(en,dist[boost[i]]/2));             a[en].pb(mp(boost[i],dist[boost[i]]/2));         }     }     memset(dist,-1,sizeof(dist));     dist[en]=0;     q.push(mp(0,en));     while(!q.empty()){         ll node=q.top().second;         q.pop();         ll sz=a[node].size();         for(int i=0; i<sz; i++){             ll nbr=a[node][i].first;             ll wt=a[node][i].second;             if(dist[nbr]==-1 || dist[nbr]>dist[node]+wt){                 dist[nbr]=dist[node]+wt;                 q.push(mp(-dist[nbr],nbr));             }         }     }     for(int i=0; i<k; i++){         if(dist[pol[i]]<=(dist_thief)){             cout<<-1;             return 0;         }     }     cout<<(dist_thief/2);      }
#include<iostream> using namespace std; int main() {     int n,i;     while(scanf("%d",&n)!=EOF)     {     int a[n];     long long sum=0;     for(i=0;i<n;i++)     {     cin>>a[i];sum+=a[i];     }i--;    while(i>=0)    { cout<<a[i]<<" ";    i--;    }       printf("\n");      printf("%lld",sum);    } }
#include<iostream> #include<cstdlib>    int n; bool polje[8][8];   bool moguce_postaviti(int red, int kolona) {     int i = red, j = kolona;      	for(i=red;i>=0;i--)         if(polje[kolona][i]) return false;          for(i=kolona;i>=0;i--)         if(polje[i][red]) return false;     i = red;     while(--i >= 0 && --j >= 0)         if(polje[j][i]) return false;     i = red;     j = kolona;     while(++i < n && --j >= 0)         if(polje[j][i]) return false;     return true; }  void ispitaj(int x, int y) {     int i, j;     if(moguce_postaviti(x,y)) {         polje[y][x] = 1;         if(y < n-1)             for(i = 0; i < n; ++i)                 ispitaj(i, y + 1);         else             for(j = 0; j < n; printf(j == n-1 ? "\n\n" : "\n"), ++j)                 for(i = 0; i < n; printf(polje[j][i] ? "Q\t" : "-\t"), ++i);         polje[y][x] = 0;     } }   int main() {     int x;     while(scanf("%d", &n) > 0)         if(n < 4)             if(n == 1)                 printf("Q\n\n");             else                 printf("Not Possible\n");         else             for(x = 0; x < n; ++x)                 ispitaj(x, 0);     return 0; } 
#include<iostream> #include<vector> using namespace std; #include<algorithm> int main() {     int t;     cin>>t;     for(int i=0;i<t;i++)     {          int n;         cin>>n;         string s[n];char c[n];int l[n];         for(int j=0;j<n;j++)         {             //string s,int l;             cin>>s[j]>>c[j];             if(c[j]=='+')                 l[j]=1;             else                 l[j]=-1;         }         for(int j=0;j<n-1;j++)         {             for(int k=j+1;k<n;k++)             {                 if(s[j]==s[k])                     l[j]=0;             }         }         int sum=0;         for(int j=0;j<n;j++)         {             sum=sum+l[j];         }         cout<<sum<<endl;     }     return 0; } 
#include<bits/stdc++.h> using namespace std; long long int mod= 1000000007; #define LL long long int void multiply(LL F[2][2], LL M[2][2]) {   LL x =  ((F[0][0]*M[0][0])%mod + (F[0][1]*M[1][0])%mod)%mod;   LL y =  ((F[0][0]*M[0][1])%mod + (F[0][1]*M[1][1])%mod)%mod;   LL z =  ((F[1][0]*M[0][0])%mod + (F[1][1]*M[1][0])%mod)%mod;   LL w =  ((F[1][0]*M[0][1])%mod + (F[1][1]*M[1][1])%mod)%mod;    F[0][0] = x;   F[0][1] = y;   F[1][0] = z;   F[1][1] = w; } /* Optimized version of power() in method 4 */ void power(long long int F[2][2], long long int n) {   if( n == 0 || n == 1)       return;   LL M[2][2] = {{1,1},{1,0}};    power(F, n/2);   multiply(F, F);    if (n%2 != 0)      multiply(F, M); } /* function that returns nth Fibonacci number */ long long int fib(long long int n) {   long long int F[2][2] = {{1,1},{1,0}};   if (n == 0)     return 0;   power(F, n);   return F[0][0]; }  main() {     int t;     long long int n;     scanf("%d",&t);     while(t--)     {             scanf("%lld",&n);             printf("%lld\n",fib(n)%mod);     }     return 0; } 
#include<bits/stdc++.h> using namespace std; long long int mod= 1000000007; #define LL long long int void multiply(LL F[2][2], LL M[2][2]) {   LL x =  ((F[0][0]*M[0][0])%mod + (F[0][1]*M[1][0])%mod)%mod;   LL y =  ((F[0][0]*M[0][1])%mod + (F[0][1]*M[1][1])%mod)%mod;   LL z =  ((F[1][0]*M[0][0])%mod + (F[1][1]*M[1][0])%mod)%mod;   LL w =  ((F[1][0]*M[0][1])%mod + (F[1][1]*M[1][1])%mod)%mod;    F[0][0] = x;   F[0][1] = y;   F[1][0] = z;   F[1][1] = w; } /* Optimized version of power() in method 4 */ void power(long long int F[2][2], long long int n) {   if( n == 0 || n == 1)       return;   LL M[2][2] = {{1,1},{1,0}};    power(F, n/2);   multiply(F, F);    if (n%2 != 0)      multiply(F, M); } /* function that returns nth Fibonacci number */ long long int fib(long long int n) {   long long int F[2][2] = {{1,1},{1,0}};   if (n == 0)     return 0;   power(F, n);   return F[0][0]; }  main() {     int t;     long long int n;     scanf("%d",&t);     while(t--)     {             scanf("%lld",&n);             printf("%lld\n",fib(n)%mod);     }     return 0; } 
#include<iostream> using namespace std; int main() {	std::ios::sync_with_stdio(false); 	int n,pow=1; 	cin>>n; 	if(n==0) 	pow=1; 	else 	pow<<=n; 	cout<<pow<<"\n"; 	return 0;  }
#include <bits/stdc++.h>  using namespace std; int n; int prev[100001],dist[100001],child[100001],visited[100001],height[100001]; vector<int> lvl[100001],a[100001],v; void bfs(int i) { 	int node; 	queue <int> q; 	q.push(i);     dist[i]=1;     prev[i]=i; 	while(!q.empty()) 	{ 		int j=q.front(); 		q.pop(); 		if (j!=1)             dist[j]=dist[prev[j]]+1;  		visited[j]=1; 		for(int i=0;i<a[j].size();i++) 			if(visited[a[j][i]]==0) 			{ 				q.push(a[j][i]); 				prev[a[j][i]]=j; 			} 	} }  int bfs1(int i) {     visited[i]=1;     for(int j=0;j<a[i].size();j++)     {         if(visited[a[i][j]]==0)         {             child[i]+=bfs1(a[i][j]);         }   	} 	child[i]++; 	return child[i];  }  int bfs2(int i) {     visited[i]=1;     int h=0;     for(int j=0;j<a[i].size();j++)     {         if(visited[a[i][j]]==0)         {             h=max(h,bfs2(a[i][j]));         }         height[i]=h; 	} 	height[i]++; 	//cout<<i<<" "<<height[i]<<endl; 	return height[i];  } int dp[100001]; int solve(int i) {     int ans =pow(10,9);     if(i>=v[v.size()-1])         return 0;     int h= upper_bound(v.begin(),v.end(),i)-v.begin(); 	if(dp[v[h]]!=-1) 		return dp[v[h]];     for(int j=0;j<lvl[v[h]].size();j++)         ans=min(ans,child[lvl[v[h]][j]]+solve(v[h]+height[lvl[v[h]][j]]-1));          dp[v[h]]=ans;     return ans; }   int main() {     int t;     scanf("%d",&t);     while(t--)     {         int n;          scanf("%d",&n);          		for(int i=1;i<=n;i++)         {             dp[i]=-1;             height[i]=0;             visited[i]=0;             child[i]=0;             prev[i]=0;             dist[i]=0;             a[i].clear();             lvl[i].clear();                      }         v.clear();         int a1,b1;         for(int i=0;i<n-1;i++)         {             scanf("%d %d",&a1,&b1);             a[a1].push_back(b1);             a[b1].push_back(a1);         }                    int h;         scanf("%d",&h);         int k;         for(int i=0;i<h;i++)         {             scanf("%d",&k);             v.push_back(k);         }         bfs(1);         for(int i=1;i<=n;i++)         {             visited[i]=0;         }         bfs1(1);         for(int i=1;i<=n;i++)         {             visited[i]=0;         }         bfs2(1);         sort(v.begin(),v.end());          for(int i=1;i<=n;i++)         {             lvl[dist[i]].push_back(i);         }                printf("%d\n",solve(0));        }      return 0; }
#include <vector> #include <list> #include <map> #include <set> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <string.h> using namespace std;  #define MAX 35 long long int catalan[MAX];  void calculate_catalan_numbers() //1->1,2->1,3->2,4->5,5->14 {     catalan[0]=1;     int n=MAX;     for(int i=1;i<n;i++)     {         catalan[i]=0;                      for(int j=1;j<=i;j++)             {                 catalan[i]+=catalan[j-1]*catalan[i-j];             }     }  } int main()  {         calculate_catalan_numbers();         int t;         scanf("%d",&t);          while(t--)         {             char s[MAX];             scanf("%s",s);                          int len=strlen(s);              printf("%d\n",catalan[len-1]);         }   		return 0; }
#include "iostream" #include "vector" #include "climits" #define int long long using namespace std; struct _ { _() { cin.sync_with_stdio(0), cin.tie(0); } } _;  struct segtree { 	int n; 	vector <int> array, tree; 	segtree(vector <int> &a) 	{ 		array=a, n=a.size(); 		tree.resize(4*n+1); 		build(1, 0, n-1); 	} 	void build(int node, int left, int right) 	{ 		if (left==right) 		{ 			tree[node]=array[left]; 			return; 		} 		build(2*node, left, (left+right)/2); 		build(2*node+1, (left+right)/2+1, right); 		tree[node]=min(tree[2*node], tree[2*node+1]); 	} 	int query(int node, int left, int right, int qleft, int qright) 	{ 		if (left>qright or right<qleft) return INT_MAX; 		else if (left>=qleft and right<=qright) return tree[node]; 		else return min( query(2*node, left, (left+right)/2, qleft, qright), query(2*node+1, (left+right)/2+1, right, qleft, qright) ); 	} };  signed main() { 	int n, q; cin >> n >> q; 	vector <int> a(n); 	for (int i=0; i<n; i++) cin >> a[i]; 	segtree s(a); 	while(q--) { 	int i, j; cin >> i >> j; 	cout << s.query(1, 0, n-1, i-1, j-1) << '\n'; }}
/* * TOFFEES from Codechef * Author: Omkar Prabhu(omkar7.p@gmail.com) */ //Coded on 28 April 2015 #include <iostream> #include <algorithm> using namespace std;  int main() {     int t;     long long a,i,j,n,max,min;     cin>>t;     while(t--)     {         cin>>n;        cin>>a;        min=max=a;        for(i=1;i<n;i++)         {          cin>>a;          if(a<min){ min=a; }          else if(a>max){ max=a; }         }                 if(max-min>=2) cout<<"BAD"<<endl;        else cout<<"GOOD"<<endl;                           } 	return 0; }       
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <deque> #include <cmath> #include <cstdlib> #include <ctime> #include <string.h> #include <cstring> #define oo (int)1e9 #define fill( a , v ) memset( a , v , sizeof (a) ) #define bits( x ) __builtin_popcount( x ) #define gcd( a , b ) __gcd( a, b ) #define lcm( a , b ) (a/gcd( a, b ) ) * b #define s(n)scanf( "%d" , &n ) #define add push_back #include<cassert> const int mxn = 100000 + 10; const int mod = 4242; typedef long long ll; #define pii pair<int,int> using namespace std; const int offset = 625;  int R[mxn],J[mxn];  int main() {      int runs,n,k,t,tmp;     s( runs );     while( runs-- )     {        s(n);s(k);        for(int i=1;i<=n;i++)R[i] = 1,J[i] = 0;                s(t);        while( t-- )        {           s(tmp);           R[tmp] = 0;        }                s(t);        while( t-- )        {           s(tmp);           J[tmp] = 1;        }                for(int i=1;i<=n;i++)        {           R[i] += R[i-1];           J[i] += J[i-1];        }                int miss = oo;        int mxspend = -1;        int soln = -1;        for(int i=1;i+k-1<=n;i++)               {           int spendtime = R[i+k-1] - R[i-1];           int misstime = J[i+k-1] - J[i-1];                      if( spendtime > mxspend )           {               mxspend = spendtime;               miss = misstime;               soln = i;           }           else if( spendtime == mxspend )           {                if( misstime < miss )                {                    miss = misstime;                    soln = i;                }           }        }        printf( "%d\n" , soln );             }     //system( "pause" ); } 
#include<bits/stdc++.h> using namespace std; int main() { 	int test; 	std::ios::sync_with_stdio(false); 	cin>>test; 	while(test--) 	{ 		int num; 		cin>>num; 		num=num-1; 		long long ans=pow(2,num); 		ans=ans%1000; 		cout<<ans<<endl; 	} }
#include <bits/stdc++.h> #define lli long long  using namespace std;  lli A[2002]; lli mn[2002]; lli mx[2002];  int main() {     int t,n;     lli m;     cin >> t;     while ( t-- ) {         cin >> n >> m;         lli ans = m;         for ( int i = 1; i <= n; i++ ) {             cin >> A[i];             if ( i == 1 ) mn[i] = A[i];             else mn[i] = min(mn[i-1], A[i]);         }         for ( int i = n; i >= 1; i-- ) {             if ( i == n ) mx[i] = A[i];             else mx[i] = max(mx[i+1], A[i]);         }         for ( int i = 1; i <= n-1; i++ ) {             lli buy = m/mn[i];             lli val = m%mn[i] + buy*mx[i];             ans = max(ans, val);         }         cout << ans << endl;     }     return 0; } 
#include<iostream> using namespace std; int main() {	std::ios_base::sync_with_stdio(false); 	long long int t,a,c,sum; 	cin>>t; 	while(t--) 	{sum=0; 	cin>>a; 	while(a!=1) 	{ 		 		c=a%2; 		if(c==1) 		sum++; 		a=a/2; 	} 	cout<<sum+1<<"\n";} }
#include <stdio.h> #include <algorithm> using std::max; int main(){        int T,A,B;                scanf("%d", &T);                while(T--)        {           A = B = 0;           scanf("%d%d",&A,&B);           printf("%d %d\n",max(A,B),A+B);        }                return 0;        //system("pause");        }                       
#include<iostream> using namespace std;  int main(){     int n;     cin>>n;     while(n--){                int num;                cin>>num;                int z=0,o=0,t=0;                long long temp;                for(int i=0;i<num;i++){                        cin>>temp;                        temp=temp%3;                        if(temp==0){                                    z++;                                    }                        else if(temp==1){                             o++;                             }                        else{                             t++;                             }                        }                int result=0;                result+=(o*(o-1)*(o-2))/6;                result+=(t*(t-1)*(t-2))/6;                result+=(o*t);                result+=(z*o*t);                result+=(z*(z-1))/2;                result+=(z*(z-1)*(z-2))/6;                cout<<result<<endl;                }     } 
#include<bits/stdc++.h> using namespace std; #define ll long long int ll dp[5001][5001],w[5001],b[5001]; int n,m; ll maxm(ll a,ll b) {       return (a>b)?a:b; } inline void solve() {       for(int i=0;i<=n;i++)             dp[i][0]=0;       for(int j=0;j<=m;j++)             dp[0][j]=0;       for(int i=1;i<=n;i++)       {             for(int j=1;j<=m;j++)             {                   if(j>=w[i])                   dp[i][j]=maxm(dp[i-1][j],dp[i-1][j-w[i]]+b[i]);                   else                         dp[i][j]=dp[i-1][j];             }       } } int main() {       scanf("%d %d",&m,&n);       for(int i=1;i<=n;i++)       {             cin>>w[i]>>b[i];       }       solve();       printf("%lld\n",dp[n][m]);       return 0; } 
/* Divanshu Garg */ #include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <climits> #include <cctype> #include <cassert>  using namespace std;  #define ull unsigned long long #define ill long long int #define pii pair<int,int> #define piii pair< int,pii > #define pb(x) push_back(x) #define F(i,a,n) for(i=(a);i<(n);++i) #define FD(i,a,n) for(i=(a);i>=(n);--i) #define FE(it,x) for(it=x.begin();it!=x.end();++it) #define V(x) vector<x> #define S(x) scanf("%d",&x) #define Sl(x) scanf("%lld",&x) #define M(x,i) memset(x,i,sizeof(x)) #define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl #define fr first #define se second  int k; int grundy[1005];  int f(int n) {     if ( n < k ) return 0; 	if ( n == k ) return 1;     if ( grundy[n] != -1 ) return grundy[n];     int i;     set<int> mex;     F(i,1,(n-k+1)) {         int temp = f(i)^f(n-k-i);         mex.insert(temp);     }     set<int>::iterator it;     int ans = 0;     FE(it,mex) {if (*it !=ans) break;ans++;} 	grundy[n] = ans;     return ans; }  int main() {     M(grundy,-1);     int t,i,n;     cin >> t >> k;     F(i,0,t) {         cin >> n;         cout << (f(n)>0?"Brainy":"Clumsy") << endl;     }     return 0; }
#include<iostream> #include<cstdlib> #include<cstring> using namespace std;  typedef struct nd { 	int n; 	int d; } M;  M foo(char dec[], int num) { 	int a[num + 1], b[10]; 	int L = strlen(dec); 	long long i = L - 1, temp = 0; 	int f = num - 1;  	while (1) 	{ 		a[f--] = dec[i] - '0'; 		i--; 		temp++; 		if (temp == num) 			break; 	} 	// printf("%d %d",a[0], a[1]); 	i = 0; 	while (dec[i] != '.') 		i++; 	i++; 	temp = 0; 	while (dec[i] != '\0') 	{ 		b[temp] = dec[i] - '0'; 		i++; 		temp++; 	} 	temp = temp - num;  	double add = 0, v; 	int k = 0; 	i = 10;  	for (int j = 0; j < temp; j++) 	{ 		v = (double)1 / i; 		v *= b[j]; 		add += v; 		i = i * 10; 	}  	for (int j = 0; j < 6 * num; j++) 	{ 		v = (double)1 / i; 		v *= a[k]; 		add += v; 		i = i * 10; 		k++; 		if (k == num) 			k = 0; 	}  	if (num > 2) 	{ 		temp = 1000 - num; 	} 	else 	{ 		if (num == 0) 			temp = 1000; 		else if (num == 1) 			temp = 1000 - 100; 		else if (num == 2) 			temp = 1000 - 10; 	}  	add = add * temp;  	M T; 	T.d = temp; 	T.n = (int)(add + 0.5);  	return T; }  int gcd(int a, int b) { 	if (b == 0) 		return a;  	gcd(b, a % b); }  int main(void) { 	int num; 	char dec[100]; 	M ND; 	int cases = 1;  	while (1) 	{ 		scanf("%d", &num);  		if (num == -1) 		{ 			break; 		}  		scanf("%s", dec);  		ND = foo(dec, num);  		int c = gcd(ND.n, ND.d);  		int N, D; 		N = ND.n / c; 		D = ND.d / c;  		printf("Case %d: %d/%d\n", cases, N, D);  		cases++;  	}  	return 0; }
// Name:- Kunal Sheth   //header files   #include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<map> #include<cmath> #include<cstring> using namespace std;   //end of header files     //definitions   #define MOD 1000000007 #define llu long long unsigned #define lld long long #define ld long   //end of definitions     //fast input   int scan_d()    {int ip=getchar_unlocked(),ret=0,flag=1;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;} ld scan_ld()    {int ip=getchar_unlocked(),flag=1;ld ret=0;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;} lld scan_lld()    {int ip=getchar_unlocked(),flag=1;lld ret=0;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;} llu scan_llu()    {int ip=getchar_unlocked();llu ret=0;for(;ip<'0'||ip>'9';ip=getchar_unlocked());for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return ret;}   //end of fast input   //fast output   //no line break void print_d(int n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=10;char output_buffer[10];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<10);} void print_ld(ld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=11;char output_buffer[11];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<11);} void print_lld(lld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<21);} void print_llu(llu n)     {int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<21);}   //new line void println_d(int n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=10;char output_buffer[11];output_buffer[10]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<11);} void println_ld(ld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=11;char output_buffer[12];output_buffer[11]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<12);} void println_lld(lld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<22);} void println_llu(llu n)     {int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<22);}   //special char char sp; void printsp_d(int n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=10;char output_buffer[11];output_buffer[10]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<11);} void printsp_ld(ld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=11;char output_buffer[12];output_buffer[11]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<12);} void printsp_lld(lld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<22);} void printsp_llu(llu n)     {int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<22);}   //end of fast output     //extra functions   //end of extra fnctions     //main   int main() {     int t=scan_d();     while(t--)     {         llu n=scan_llu(),m=scan_llu();         println_d(log2(max(n,m)));     }     return 0; }   //end of main   
#include<algorithm> #include<iostream> #include<vector> using namespace std; vector<int> arr[20001]; vector<bool> visited(20001,0); vector<int> a,b; void dfs(int p){ int i; visited[p]=1; for(i=0;i<arr[p].size();i++){ if(visited[arr[p][i]]==0){ dfs(arr[p][i]); } } } int main(void){ int n,m,i,temp1,temp2; int cost; cin>> n>>m; for(i=0;i<m;i++){ cin>>temp1>>temp2; arr[temp1].push_back(temp2); arr[temp2].push_back(temp1); }  for(i=0;i<n;i++){ if(visited[i]==0){ if(i!=0){ a.push_back(i-1); b.push_back(i); } dfs(i); } } cost=a.size(); cout << cost << " " << cost << endl; for(i=0;i<a.size();i++){ cout << a[i] << " " << b[i] <<endl; } return 0; }
// Name:- Kunal Sheth   //header files   #include <iostream> #include <cstdio> #include <algorithm> #include <vector> #include <map> #include <cmath> #include <cstring> #include <queue> using namespace std;   //end of header files     //definitions   #define MOD 1000000007 #define llu long long unsigned #define lld long long #define ld long   //end of definitions     //fast input   int scan_d()    {int ip=getchar_unlocked(),ret=0,flag=1;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;} ld scan_ld()    {int ip=getchar_unlocked(),flag=1;ld ret=0;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;} lld scan_lld()    {int ip=getchar_unlocked(),flag=1;lld ret=0;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;} llu scan_llu()    {int ip=getchar_unlocked();llu ret=0;for(;ip<'0'||ip>'9';ip=getchar_unlocked());for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return ret;}   //end of fast input   //fast output   //no line break void print_d(int n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=10;char output_buffer[10];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<10);} void print_ld(ld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=11;char output_buffer[11];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<11);} void print_lld(lld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<21);} void print_llu(llu n)     {int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<21);}   //new line void println_d(int n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=10;char output_buffer[11];output_buffer[10]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<11);} void println_ld(ld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=11;char output_buffer[12];output_buffer[11]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<12);} void println_lld(lld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<22);} void println_llu(llu n)     {int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<22);}   //special char char sp; void printsp_d(int n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=10;char output_buffer[11];output_buffer[10]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<11);} void printsp_ld(ld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=11;char output_buffer[12];output_buffer[11]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<12);} void printsp_lld(lld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<22);} void printsp_llu(llu n)     {int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<22);}   //end of fast output   int V; int rGraph[1000][1000],graph[1000][1000];   //extra functions   bool bfs(int s, int t, int parent[]) {     bool visited[V];     for(int i=0;i<V;i++)         visited[i]=0;     queue <int> q;     q.push(s);     visited[s] = true;     parent[s] = -1;     while (!q.empty())     {         int u = q.front();         q.pop();         for (int v=0; v<V; v++)         {             if (visited[v]==false && rGraph[u][v] > 0)             {                 q.push(v);                 parent[v] = u;                 visited[v] = true;             }         }     }     return (visited[t]==true); }   int fordFulkerson(int s, int t) {     int u, v;     int parent[V];     int max_flow = 0;     while (bfs(s, t, parent))     {         int path_flow = 100000000;         for (v=t; v!=s; v=parent[v])         {             u = parent[v];             path_flow = min(path_flow, rGraph[u][v]);         }         for (v=t; v != s; v=parent[v])         {             u = parent[v];             rGraph[u][v] -= path_flow;             rGraph[v][u] += path_flow;         }         max_flow += path_flow;     }     return max_flow; }   //end of extra fnctions     //main   int main() {     //freopen("in3.txt","r",stdin);     //freopen("out3.txt","w",stdout);     //int t;     //cin>>t;     //while(t--)     //{     	V=scan_d();         int n=scan_d();         for(int i=0;i<V;i++)             for(int j=0;j<V;j++)                 rGraph[i][j]=graph[i][j]=0;         while(n--)         {             int x=scan_d(),y=scan_d(),fl=scan_d();             rGraph[x][y]=graph[x][y]=fl;         }         println_d(fordFulkerson(0,V-1));     //} }   //end of main   
// Name:- Kunal Sheth     //header files   #include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<map> #include<cmath> #include<cstring> using namespace std;   //end of header files     //definitions   #define MOD 1000000007 #define llu long long unsigned #define lld long long #define ld long   //end of definitions     //fast input   int scan_d()    {int ip=getchar_unlocked(),ret=0,flag=1;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;} ld scan_ld()    {int ip=getchar_unlocked(),flag=1;ld ret=0;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;} lld scan_lld()    {int ip=getchar_unlocked(),flag=1;lld ret=0;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;} llu scan_llu()    {int ip=getchar_unlocked();llu ret=0;for(;ip<'0'||ip>'9';ip=getchar_unlocked());for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return ret;}   //end of fast input   //fast output   //no line break void print_d(int n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=10;char output_buffer[10];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<10);} void print_ld(ld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=11;char output_buffer[11];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<11);} void print_lld(lld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<21);} void print_llu(llu n)     {int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<21);}   //new line void println_d(int n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=10;char output_buffer[11];output_buffer[10]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<11);} void println_ld(ld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=11;char output_buffer[12];output_buffer[11]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<12);} void println_lld(lld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<22);} void println_llu(llu n)     {int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<22);}   //special char char sp; void printsp_d(int n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=10;char output_buffer[11];output_buffer[10]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<11);} void printsp_ld(ld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=11;char output_buffer[12];output_buffer[11]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<12);} void printsp_lld(lld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<22);} void printsp_llu(llu n)     {int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<22);}   //end of fast output     //extra functions   lld mpow(lld a,lld b) { 	if(!b) 		return 1; 	else if(b==1) 		return a; 	lld temp=mpow(a,b/2); 	if(b&1) 		return (((temp*temp)%MOD)*a)%MOD; 	return (temp*temp)%MOD; }   //end of extra fnctions     //main   int main() { //    freopen("in1.txt","r",stdin); //    freopen("out1.txt","w",stdout);     int t=scan_d();     while(t--)     {         lld a=0,b=0;         int temp=getchar_unlocked();         while(temp<'0'||temp>'9')         	temp=getchar_unlocked();         while(temp>='0'&&temp<='9')         {         	a=(a*10+(temp-'0'))%MOD;         	temp=getchar_unlocked();         }         temp=getchar_unlocked();         bool flag=0;         while(temp<'0'||temp>'9')         	temp=getchar_unlocked();         while(temp>='0'&&temp<='9')         {         	if(b>0)         		flag=1;         	b=(b*10+(temp-'0'))%(MOD-1);         	temp=getchar_unlocked();         }         if(b>0)                 flag=1;         if(flag)         	println_lld(mpow(a,b));         else         	println_lld(a);     }     return 0; }   //end of main   
#include <bits/stdc++.h> using namespace std;  int sq(int n){return n*n;}  int gt_max(int &a, int &b, int &c){     int sd=0;     if(a>b&&a>c){}     else{         if(b>c){            sd=b;            b=a;            a=sd;         }else{             sd=c;             c=a;             a=sd;         }     } }  int main(){     int n;     cin >> n;     int t;     cin >> t;     while(t--){         int x1,y1,x2,y2,x3,y3;         cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;         int a = sq(x1-x2)+sq(y2-y1);         int b = sq(x2-x3)+sq(y2-y3);         int c = sq(x1-x3)+sq(y1-y3);         if(a==b || a==c || b==c){             if(n==1) cout << "Isosceles triangle" << endl;             else{                 gt_max(a,b,c);                 if(a>b+c) cout << "Isosceles obtuse triangle" << endl;                 else if(a<b+c) cout << "Isosceles acute triangle" << endl;                 else{                     cout << "Isosceles right triangle" << endl;                 }             }         }else{             if(n==1) cout << "Scalene triangle" << endl;             else{                 gt_max(a,b,c);                 if(a>b+c) cout << "Scalene obtuse triangle" << endl;                 else if(a<b+c) cout << "Scalene acute triangle" << endl;                 else{                     cout << "Scalene right triangle" << endl;                 }             }         }     } } 
#include <bits/stdc++.h> #define mod 1000000007 using namespace std; typedef long long int lli; int a[104][104]; lli total[104][104],path[104][104];  lli modpow(lli a, lli b) { 	lli res=1; 	while(b>0) 	{ 		if(b%2==1) res=(res*a)%mod; 		a=(a*a)%mod; 		b=b/2; 	} 	return res; }  int main() { 	std::ios::sync_with_stdio(false); 	int n,i,j; 	cin>>n; 	for(i=1;i<=n;i++) 		for(j=1;j<=i;j++) 			cin>>a[i][j]; 	for(j=1;j<=n;j++) 	{ 		path[n][j]=1; 		total[n][j]=a[n][j]; 	} 	for(i=n-1;i>=1;i--) 		for(j=1;j<=i;j++) 		{ 			total[i][j]=(a[i][j]+max(total[i+1][j],total[i+1][j+1]))%mod; 		} 	for(i=n-1;i>=1;i--) 		for(j=1;j<=i;j++) 		{ 			if(total[i][j]==total[i+1][j]+a[i][j]) 				path[i][j]=path[i+1][j]; 			else path[i][j]=(modpow(2,(lli)(n-i-1))+path[i+1][j+1])%mod; 		} 	cout<<path[1][1]<<endl;	 } 
#include <cstdio> #include <cstdlib> #include <algorithm> #include <queue> #include <cmath> #include <cstring> #include <iostream> #include <stack> #include <map> #include <vector> #include <utility> #include <set>  #define MOD (1000000007) #define MAXINT 1e9 #define EPS (1e-9) #define mp   make_pair #define pb   push_back #define fi   first #define se   second #define pii  pair<int,int>  #define pll  pair<long long,long long>   using namespace std; typedef long long int ll;  int a[1003];  int main() { 	int test,ans,i,j,k,n,m; 	cin>>test; 	while(test--) 	{ 		cin>>n>>m; 		ans=0; 		for(i=1;i<=n;i++)	cin>>a[i]; 		sort(a+1,a+n+1); 		vector<pii> v; 		v.pb(mp(0,0)); 		for(i=1;i<=n;i++) 		{ 			j=i+1; 			while(j<=n && a[j]==a[i])	j++; 			v.pb(mp(a[i],j-i)); 			i=j-1; 		} 		n=(int)v.size(); 		//cout<<n<<endl; 		for(i=1;i<n;i++) 		{ 			k=n-1; 			if(v[i].se>=2)	j=i; 			else			j=i+1; 			for(;j<n;j++) 			{ 				while(k>=1 && v[i].fi+v[j].fi+v[k].fi>m)	k--; 				if(k<j)	break; 				ans+=k-j; 				if(i==j && v[i].se>=3)	ans++; 				else if(i!=j && v[j].se>=2)		ans++; 				//cout<<ans<<endl; 			} 		} 		cout<<ans<<endl; 	} 	return 0; }
#include <algorithm> #include <bitset> #include <cmath> #include <ctime> #include <cstdio> #include <cstdlib> #include <cstring> #include <deque> #include <fstream> #include <functional> #include <iostream> #include <map> #include <set> #include <sstream> #include <stack> #include <queue> #include <utility> #include <vector> #define mod 1000000007 using namespace std;  long long up[20010][22],down[20010][22]; int n,k,T; vector<int> adj[20010]; int pre[20010]; long long c[22][22],sum[22];  void calc_down(int u) {     for (int i = 0; i < adj[u].size(); i++)     {         int v = adj[u][i];         if (pre[u] == v) continue;         pre[v] = u;  calc_down(v);     }          for (int i = 0; i <= k; i++) down[u][i] = 1;     for (int i = 0; i < adj[u].size(); i++)     {         int v = adj[u][i];         if (pre[u] == v) continue;         for (int j = 0; j <= k; j++)           for (int t = 0; t <= j; t++) down[u][j] = (down[u][j] + c[j][t] * down[v][t]) % mod;     } }  void calc_up(int u) { //    cout << "iter to: " << u << endl;         for (int i = 0; i <= k; i++) sum[i] = 1;     for (int i = 0; i < adj[u].size(); i++)     {         int v = adj[u][i];         if (pre[u] == v) continue;         for (int j = 0; j <= k; j++)           for (int t = 0; t <= j; t++) sum[j] = (sum[j] + c[j][t] * down[v][t]) % mod;     } /*    cout << "without root" << endl;     for (int j = 0; j <= k; j++) cout << sum[j] << ' ';     cout << endl;*/              for (int j = 0; j <= k; j++) sum[j] = (sum[j] + up[u][j]) % mod;        /*    cout << "with root" << endl;     for (int j = 0; j <= k; j++) cout << sum[j] << ' ';     cout << endl;*/            for (int i = 0; i < adj[u].size(); i++)     {         int v = adj[u][i];         if (pre[u] == v) continue;         for (int j = 0; j <= k; j++)           for (int t = 0; t <= j; t++) sum[j] = (sum[j] - c[j][t] * down[v][t]) % mod; /*        cout << "processed: " << v << endl;         for (int j = 0; j <= k; j++) cout << sum[j] << ' ';         cout << endl;*/         for (int j = 0; j <= k; j++)           for (int t = 0; t <= j; t++) up[v][j] = (up[v][j] + c[j][t] * sum[t]) % mod;         for (int j = 0; j <= k; j++)           for (int t = 0; t <= j; t++) sum[j] = (sum[j] + c[j][t] * down[v][t]) % mod;               } //    cout << endl;     for (int i = 0; i < adj[u].size(); i++)     {         int v = adj[u][i];         if (pre[u] == v) continue;         calc_up(v);     } }  int main() { //    freopen("treesum.in","r",stdin); //    freopen("treesum.ou","w",stdout);     scanf("%d", &T);     memset(c,0,sizeof(c));     c[0][0] = 1;     for (int i = 1; i <= 20; i++)       for (int j = 0; j <= i; j++)       {             c[i][j] = c[i - 1][j];             if (j) c[i][j] = (c[i][j] + c[i - 1][j - 1]) % mod;                     }                      while (T--)     {         scanf("%d %d", &n, &k);         for (int i = 0; i < n; i++) adj[i].clear();         for (int i = 0; i < n - 1; i++)         {             int u,v;  scanf("%d %d", &u, &v);             adj[u].push_back(v);             adj[v].push_back(u);         }         for (int i = 0; i < n; i++) pre[i] = -1;         calc_down(0);         for (int i = 0; i < n; i++)           for (int j = 0; j <= k; j++) up[i][j] = 0;         calc_up(0);         for (int i = 0; i < n; i++)         {             long long ans = (up[i][k] + down[i][k]) % mod;             printf("%lld\n", (ans + mod) % mod);         }         printf("\n");     }                           } 
#include <bits/stdc++.h> #define MOD 1000000007LL #define ll long long   using namespace std;   const int MAXN1 = 50000; const int MAXN2 = 50000; const int MAXM = 150000;   int n1, n2, edges, last[MAXN1], prev[MAXM], head[MAXM]; int matching[MAXN2], dist[MAXN1], Q[MAXN1]; bool used[MAXN1], vis[MAXN1];   void init(int _n1, int _n2) {     n1 = _n1;     n2 = _n2;     edges = 0;     fill(last, last + n1, -1); }   void addEdge(int u, int v) {     head[edges] = v;     prev[edges] = last[u];     last[u] = edges++; }   void bfs() {     fill(dist, dist + n1, -1);     int sizeQ = 0;     for (int u = 0; u < n1; ++u) {         if (!used[u]) {             Q[sizeQ++] = u;             dist[u] = 0;         }     }     for (int i = 0; i < sizeQ; i++) {         int u1 = Q[i];         for (int e = last[u1]; e >= 0; e = prev[e]) {             int u2 = matching[head[e]];             if (u2 >= 0 && dist[u2] < 0) {                 dist[u2] = dist[u1] + 1;                 Q[sizeQ++] = u2;             }         }     } }   bool dfs(int u1) {     vis[u1] = true;     for (int e = last[u1]; e >= 0; e = prev[e]) {         int v = head[e];         int u2 = matching[v];         if (u2 < 0 || !vis[u2] && dist[u2] == dist[u1] + 1 && dfs(u2)) {             matching[v] = u1;             used[u1] = true;             return true;         }     }     return false; }   int maxMatching() {     fill(used, used + n1, false);     fill(matching, matching + n2, -1);     for (int res = 0;;) {         bfs();         fill(vis, vis + n1, false);         int f = 0;         for (int u = 0; u < n1; ++u)             if (!used[u] && dfs(u))                 ++f;         if (!f)             return res;         res += f;     } }   int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		int n, skill; 		scanf("%d",&n); 		vector<pair<int,int> > v; 		map<string,int> mp; 		map<int,int> mp2; 		string s; 		int cntr = 0, cntr2 = 0; 		while(n--) 		{ 			cin >> s >> skill; 			if(!mp.count(s)) 				mp[s] = cntr++; 			if(!mp2.count(skill)) 				mp2[skill] = cntr2++; 			v.push_back(make_pair(mp[s],mp2[skill])); 		} 		init(cntr,cntr2); 		for(int i=0;i<v.size();++i) 			addEdge(v[i].first,v[i].second); 		printf("%d\n",maxMatching());	 	} } 
#include<bits/stdc++.h> #define pb(x) push_back(x) #define all(x) x.begin(), x.end() #define cout2(x, y) cout << x << " " << y <<  endl #define N 100005  using namespace std;  long long tree[2][3 * N], A1[N], A2[N], A3[N], B[3 * N], aux[N];  int add = 1e9, mod = 10000; map<int, int>mapa[10000];  void update(int x, int id, long long val){ 	 	for(int i = x; i < 3 * N; i += i&-i)tree[id][i] += val;	 }  long long query(int x, int id){ 	 	long long ans = 0; 	for(int i = x; i > 0; i -= i&-i)ans += tree[id][i]; 	return ans;	 }  int main(){  	int tc = 0; 	scanf("%d", &tc); 	 	while(tc--){ 		 		for(int i = 0; i < mod; i++)mapa[i].clear(); 		memset(tree, 0, sizeof tree); 		 		int P, Q, R, top = 0; 		 		scanf("%d", &P); 		for(int i = 0; i < P; i++)scanf("%lld", &A1[i]), B[top++] = A1[i] += add; 		 		scanf("%d", &Q); 		for(int i = 0; i < Q; i++)scanf("%lld", &A2[i]), B[top++] = A2[i] += add; 		 		scanf("%d", &R); 		for(int i = 0; i < R; i++)scanf("%lld", &A3[i]), B[top++] = A3[i] += add; 		 		sort(B, B + top); 		int id = 1; 		 		for(int i = 0; i < top; i++) 			if(mapa[B[i]%mod].find(B[i]) == mapa[B[i]%mod].end()) 				mapa[B[i]%mod][B[i]] = id++; 		 		for(int i = 0; i < P; i++)A1[i] = mapa[A1[i]%mod][A1[i]]; 		for(int i = 0; i < Q; i++)A2[i] = mapa[A2[i]%mod][A2[i]]; 		for(int i = 0; i < R; i++)A3[i] = mapa[A3[i]%mod][A3[i]]; 		 		for(int i = 0; i < Q; i++){ 			 			if(i < P)update(A1[i], 0, 1); 			aux[i] = query(A2[i], 0); 		} 		 		long long ans = 0; 		for(int i = 0; i < R; i++){ 			 			if(i < Q)update(A2[i], 1, aux[i]); 			ans  += query(A3[i], 1); 		} 		 		printf("%lld\n", ans); 	} }  
#include<iostream> #include<cstdio> #include<algorithm> using namespace std; int main() { 	int t,n,arr[1000],i,ct,sum1,cnt1,sum2,cnt2,j; 	for(scanf("%d",&t);t--;) 	{ 		for(scanf("%d",&n),i=0;i<n;i++) {scanf("%d",&arr[i]);} 		scanf("%d",&ct); 		sort(arr,arr+n); 		 		sum1=arr[0];sum2=arr[n-1]; 		if(sum1<=ct)i=1,cnt1=1;else i=0,cnt1=0; 		if(sum2<=ct)j=n-2,cnt2=1;else j=n-1,cnt2=0; 		while((sum1<ct || sum2<ct) && i<=j) 		{ 			if(sum1<sum2) {sum1+=arr[i]; if(sum1<=ct) cnt1++,i++;} 			else {sum2+=arr[j];if(sum2<=ct) cnt2++,j--;}  		} 		printf("%d %d\n",cnt2,cnt1); 	} }
#include <iostream> #include <sstream> #include <fstream> #include <string> #include <vector> #include <deque> #include <stack> #include <queue> #include <set> #include <map> #include <algorithm> #include <functional> #include <utility> #include <cmath> #include <cstdlib> #include <ctime> #include <cstdio> #include <cstring> //#include <conio.h>  using namespace std;  #define X first #define Y second #define mp make_pair #define pb push_back #define sqr(a) ((a)*(a)) #define FR(i,n) for (int i = 0; i < (n); i++) #define DN(i,a) for(int i = (a)-1; i >= 0; i--) #define FOR(i,a,b) for (int i = (a); i <= (b); i++) #define DOWN(i,a,b) for(int i = (a); i >= (b); i--) #define FORV(i,a) for(typeof(a.begin()) i = a.begin(); i != a.end(); i++) #define Set(a,c) memset(a, c, sizeof(a)) #define oo 1000000000 #define MAXN 100005 #define mod 1000000007 typedef pair<int, int> PII; typedef vector<int> VI;  int y,n,t,i; long long pi; int main () { scanf("%d",&t); while(t--) {   scanf("%lld %d",&pi,&y);   y-=2000;   for(i=1;i<=y;i++)     pi=(pi%mod*pi)%mod;   printf("%lld\n",pi);  }   return 0; } 
#include <iostream>  using namespace std;  long int check(int m, int n)  {     long int arr[m][n];          for (int i = 0; i < m; i++) {         for (int j = 0; j < n; j++) {                  cin >> arr[i][j];         }     }          long int a[m], b[n];     long int x, y;     int k = 0, l = 0;          for (int i = 0; i < m; i++) {         x = arr[i][0];         for (int j = 0; j < n; j++) {             if (arr[i][j] > x) {                x = arr[i][j];             }         }        // cout << "\n x = " << x;         a[k] = x;         k++;     }      for (int i = 0; i < n; i++) {         y = arr[i][0];         for (int j = 0; j < m; j++) {             if (arr[j][i] < y) {                y = arr[j][i];             }         }      //   cout << "\ny = " << y;         b[l] = y;         l++;     }              long int res = -1;          for (int i = 0; i < k; i++) {         for (int j = 0; j < l; j++) {             if(a[i] == b[j]) {                     res = a[i];             }         }     }          return res;      } int main() {     int x;     int m;     int n,j = 0;          cin >> x;           long a[x];          for (int i = 0; i < x; i++) {         cin >> m >> n;         a[j] = check(m, n);         j++;     }     cout << endl;     for (int i = 0; i < j; i++) {         cout << a[i] << endl;     }          return 0; }
//http://www.codechef.com/TCSN2012/problems/TSX05  #include<stdio.h> int main() {     int t,n,x,y,c,i;     scanf("%d%d",&t,&n);     while(t--)     {               scanf("%d%d",&x,&y);               c=0;               int a[1000];               while(x!=1||y!=1)               {                                if(x==y)                                {  a[c]=x;c++; x/=2;y/=2;}                                else if(x>y)                                { x/=2;}                                else                                y/=2;               }               a[c]=1;c++;               for(i=c-1;i>=0;i--)               printf("%d ",a[i]);               printf("\n");     }     return 0; }           
#include<bits/stdc++.h> using namespace std; #define ll long long int ll a[100005],n,c; inline bool solve(ll m) {       ll cnt=0;       ll id=a[0];       for(int i=1;i<n;i++)       {             if((a[i]-id)>=m)             {                   cnt++;                   id=a[i];             }       }       if(cnt>=c)             return true;       return false; } int main() {       int t;       scanf("%d",&t);       while(t--)       {            // int n,c;            scanf("%lld%lld",&n,&c);             c--;             for(int i=0;i<n;i++)             {                   scanf("%lld",&a[i]);             }             sort(a,a+n);             ll l=0,h=a[n-1];             while(l<=h)             {                   ll m=(l+h)>>1;                   if(solve(m))                         l=m+1;                   else                         h=m-1;              }             l--;             cout<<l<<endl;       }       return 0; } 
/*  	C++ Template 	Gaurav Babbar */  #include<bits/stdc++.h> #define MOD 1000000007 #define MAX 1000005 #define mp make_pair #define pb push_back #define gc getchar #define pc putchar #define ll long long #define llu unsigned long long #define fill(a, val) memset(a, val, sizeof(a))  ll ABS(ll a){if(a>0) return a; else return (-1*a);} int gcd(int a,int b){if (b==0) return a;else return gcd(b,a%b);} llu power(llu b,llu exp,llu m) {llu ans=1; b%=m; while(exp){if(exp&1) ans=(ans*b)%m; exp>>=1; b=(b*b)%m; } return ans; } using namespace std;  #define DisplayDebuggingInfo 0 #define debug(args...) {dbg,args; if(DisplayDebuggingInfo) cerr<<endl;} struct debugger {       template<typename T> debugger& operator,(const T& v)       {           if(DisplayDebuggingInfo)           {               cerr<< v <<" ";               return *this;           }       } }dbg;  inline void inp(ll &n) {   n = 0;   int ch = gc();   int sign = 1;   while(ch < '0' || ch > '9') {     if (ch == '-') sign = -1;     ch = gc();   }   while(ch >= '0' && ch <= '9')     n = (n<<3) + (n<<1) + ch - '0', ch = gc();   n = n*sign; }  inline void outp(ll a) {   char snum[25];   int i=0;   do   {     snum[i++]=a%10+48;     a=a/10;   } while(a!=0);   i=i-1;   while(i>=0)     pc(snum[i--]);   pc('\n'); }  /* Main Code sarts here */  ll n,q,arr[MAX]; struct node {     ll first,second; }tree[MAX<<2];  void reset() { }  void input() {     inp(n);inp(q);     for(ll i=1;i<=n;++i)     {         inp(arr[i]);     } }  void initialize(int node,int b,int e) {     if (b == e)     {//debug(node,b,e);           if(arr[b]%2==0)           {               tree[node].first = arr[b];               tree[node].second = 1;           }           else           {               tree[node].first = LONG_LONG_MAX;               tree[node].second = 0;           }     }     else     {           int mid = (b+e)>>1;           initialize(2*node, b, mid);           initialize(2*node+1, mid+1, e);           if (tree[2 * node].first < tree[2 * node + 1].first)            {                tree[node].first = tree[2 * node].first;                tree[node].second = tree[2 * node].second;            }           else if (tree[2 * node].first > tree[2 * node + 1].first)           {               tree[node].first = tree[2 * node+1].first;               tree[node].second = tree[2 * node+1].second;           }           else           {               tree[node].first = tree[2 * node].first;               tree[node].second = tree[2 * node].second + tree[2 * node+1].second ;           }     } }  pair<ll,ll> segQuery(int node,int b,int e,int i,int j) {     pair<ll,ll> p1, p2;        if (i > e || j < b)           return mp(LONG_LONG_MAX,0);        if (b >= i && e <= j)           return mp(tree[node].first,tree[node].second);        int mid = (b+e)>>1;       p1 = segQuery(2*node, b,mid, i, j);       p2 = segQuery(2*node+1,mid+1, e, i, j);        if (p1.first == -1)           return p2;       if (p2.first == -1)           return p1;       if (p1.first < p2.first)           return p1;       if(p1.first==p2.first)       {           p1.second = p1.second+p2.second;           return p1;       }       return p2; }  void update(int node, int b, int e, int i, int j, int value) {             if(b > e || b > j || e < i) return;             if(b==e)             {                 if(value%2==0)                 {                   tree[node].first = value;                   tree[node].second = 1;                 }                   else                   {                       tree[node].first = LONG_LONG_MAX;                       tree[node].second = 0;                   }                 return;             }             int mid = (b+e)>>1;             update(node*2, b, mid , i, j, value);             update(1+node*2, mid+1, e, i, j, value);             if (tree[2 * node].first < tree[2 * node + 1].first)            {                tree[node].first = tree[2 * node].first;                tree[node].second = tree[2 * node].second;            }           else if (tree[2 * node].first > tree[2 * node + 1].first)           {               tree[node].first = tree[2 * node+1].first;               tree[node].second = tree[2 * node+1].second;           }           else           {               tree[node].first = tree[2 * node].first;               tree[node].second = tree[2 * node].second + tree[2 * node+1].second ;           } }  void preprocess() {     initialize(1,1,n); }  void solve() {     //for(int i=1;i<=2*n+2;++i){debug(i,tree[i].first,tree[i].second)}     for(int i=1;i<=q;++i)     {         ll x;inp(x);         if(x==1)//query         {             ll l,r;             inp(l);inp(r);             pair<ll,ll> ans = segQuery(1,1,n,l,r);             if(ans.first==LONG_LONG_MAX)                 cout<<"-1 ";             else                 cout<<ans.first<<" ";             outp(ans.second);         }         else if(x==2)         {             ll l,value;             inp(l);inp(value);             arr[l]=value;             update(1,1,n,l,l,value);         }         //for(int i=1;i<=2*n+2;++i){debug(i,tree[i].first,tree[i].second)}     } }  int main() {    ll t=1;    //inp(t);    while(t--)    { 	   reset(); 	   input(); 	   preprocess(); 	   solve();    }    return 0; } 
#include<iostream> using namespace std; int main() { 	long long int arr[10][15],diff[10]; 	long long int t,x,y,min,mini; 	cin>>t; 	long long int i,j; 	while(t--){ 		for(i=0;i<10;i++){ 			for(j=0;j<15;j++){ 				cin>>arr[i][j]; 				if(j==0){ 					x=arr[i][0]; 					y=arr[i][0]; 				} 				if(arr[i][j]>x) 					x=arr[i][j]; 				if(arr[i][j]<y) 					y=arr[i][j];		 			} 			diff[i]=x-y; 			if(i==0){ 				min=diff[i]; 				mini=i; 			} 			if(diff[i]<=min){ 				mini=i; 				min=diff[i]; 			} 		} 		cout<<(mini+1)<<" "<<min<<endl; 	} 	return 0; }
#include <bits/stdc++.h> #define ll long long #define MOD 1000000007 #define INF 0x3f3f3f3f  using namespace std;  int st[500005],a[100005],ans[100005],zero_time[100005]; pair<int,int> p[100005];  int get_mid(int u,int v) {     return u+(v-u)/2; }  void build_tree(int ss,int se,int ci) {     if(ss==se)     {         st[ci]=zero_time[ss];         return;     }     int mid=get_mid(ss,se);     build_tree(ss,mid,2*ci);     build_tree(mid+1,se,2*ci+1);     st[ci]=max(st[2*ci],st[2*ci+1]); }  int query(int ss,int se,int qs,int qe,int ci) {     if(ss>=qs&&se<=qe)         return st[ci];     if(ss>qe||se<qs)         return 0;     int mid=get_mid(ss,se);     return max(query(ss,mid,qs,qe,2*ci),query(mid+1,se,qs,qe,2*ci+1)); }  int main() {     int n,m;     scanf("%d%d",&n,&m);     for(int i=1;i<=n;i++)         scanf("%d",&a[i]);     for(int i=0;i<m;i++)     {         scanf("%d%d",&p[i].first,&p[i].second);     }     int q;     memset(zero_time,0x3f,sizeof(zero_time));     scanf("%d",&q);     for(int i=1;i<=q;i++)     {         int x;         scanf("%d",&x);         if(a[x]){             a[x]--;             if(!a[x])                 zero_time[x]=i;         }     }     build_tree(1,n,1);     for(int i=0;i<m;i++)     {         int seg_zero_time=query(1,n,p[i].first,p[i].second,1);         if(seg_zero_time!=INF)         {             ans[seg_zero_time]++;         }     }     for(int i=1;i<=q;i++)         ans[i]+=ans[i-1];     for(int i=1;i<=q;i++)         printf("%d\n",ans[i]);      return 0;  } 
#include<iostream> using namespace std;  int main() { 	int t; 	long long int f,m; 	cin>>t; 	while(t>0) 	{ 		cin>>f>>m; 		 		if((m%f==0)) 		cout<<"CORRECT\n"; 		 		else 		cout<<"WRONG\n"; 		 		t--; 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std;  typedef pair<int,int> II; typedef vector< II > VII; typedef vector<int> VI; typedef vector< VI > VVI; typedef long long int ll;  #define PB push_back #define MP make_pair #define F first #define S second #define SZ(a) (int)(a.size()) #define ALL(a) a.begin(),a.end() #define SET(a,b) memset(a,b,sizeof(a))  #define si(n) scanf("%d",&n) #define dout(n) printf("%d\n",n) #define sll(n) scanf("%lld",&n) #define lldout(n) printf("%lld\n",n) #define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)  #define TRACE  #ifdef TRACE #define trace(...) __f(#__VA_ARGS__,__VA_ARGS__) /*template <typename Arg1> void __f(const char * name, Arg1&& arg1){     cerr << name << " : " << arg1 << std::endl; } template <typename Arg1, typename... Args> void __f(const char* names, Arg1&& arg1, Args&&... args){     const char* comma = strchr(names + 1,',');cerr.write(names,comma - names) << " : " << arg1<<" | ";__f(comma+1,args...); }*/ #else #define trace(...) #endif int max(int p,int q) {     return (p>q)?p:q; } int min(int p,int q) {     return (p<q)?p:q; }  void pno() {     cout << "No\n"; }  void pyes() {     cout << "Yes\n"; }  int main() {     ll t,r,c,m,j,k,r2,c2,flag,sum;     sll(t);     while(t--)     {         flag=0;         sll(r);         sll(c);         sll(m);         sll(j);         sll(k);         sum=r*c;         if(sum==m+j+k)         {             if(m%r==0)             {                 r2=r;                 c2=c-m/r;                 if(r2!=0 && c2!=0   && flag==0)                 {                     if(j%r2==0 || k%r2==0 || j%c2==0 || k%c2==0)                     {                         pyes();                         flag=1;                     }                 }             }             if(m%c==0)             {                 r2=c;                 c2=r-m/c;                 if(r2!=0 && c2!=0   && flag==0)                 {                     if(j%r2==0 || k%r2==0 || j%c2==0 || k%c2==0)                     {                         pyes();                         flag=1;                     }                 }             }             if(k%r==0)             {                 r2=r;                 c2=c-k/r;                 if(r2!=0 && c2!=0   && flag==0)                 {                     if(j%r2==0 || m%r2==0 || j%c2==0 || m%c2==0)                     {                         pyes();                         flag=1;                     }                 }             }             if(k%c==0)             {                 r2=c;                 c2=r-k/c;                 if(r2!=0 && c2!=0   && flag==0)                 {                     if(j%r2==0 || m%r2==0 || j%c2==0 || m%c2==0 )                     {                         pyes();                         flag=1;                     }                 }             }             if(j%r==0)             {                 r2=r;                 c2=c-j/r;                 if(r2!=0 && c2!=0  && flag==0)                 {                     if(m%r2==0 || k%r2==0 || m%c2==0 || k%c2==0 )                     {                         pyes();                         flag=1;                     }                 }             }             if(j%c==0)             {                 r2=c;                 c2=r-j/c;                 if(r2!=0 && c2!=0   && flag==0)                 {                     if(m%r2==0 || k%r2==0 || m%c2==0 || k%c2==0)                     {                         pyes();                         flag=1;                     }                 }             }             if(flag==0)             {                 pno();             }         }         else         {             pno();         }     }     return 0; }  
#include <bits/stdc++.h> #define rf freopen("inp.in", "r", stdin) using namespace std;  const int MAX = 100005; vector < int > edgeList[MAX]; vector < int > bridgeTree[MAX];  int A[MAX], B[MAX], V[MAX]; int N, M, Q; pair < int, int > DP[MAX]; int D[MAX], L[MAX], cur = 0;  bool isBridge[MAX];  void dfs(int u, int p){ 	D[u] = L[u] = ++cur; 	V[u] = 1; 	for(int i = 0 ; i < edgeList[u].size() ; i++){ 		int v = A[edgeList[u][i]] + B[edgeList[u][i]] - u; 		if(v == p) continue; 		if(V[v] == 0){ 			dfs(v, u); 			L[u] = min(L[u], L[v]); 			if(L[v] > D[u]) isBridge[edgeList[u][i]] = true; 		} 		else L[u] = min(L[u], D[v]); 	} }  int dfs2(int u, int p){ 	int x = 1; 	V[u] = 1; 	for(int i = 0 ; i < bridgeTree[u].size() ; i++){ 		int v = bridgeTree[u][i]; 		if(v == p) continue; 		x += dfs2(v, u); 	} 	return x; }  long long choose(int x){ 	long long res = ( (x)*1LL*(x-1) ) / 2; 	return res; }  int main(){ 		 	scanf("%d %d %d\n", &N, &M, &Q); 	for(int i = 1 ; i <= M ; i++){ 		scanf("%d %d\n", &A[i], &B[i]); 		edgeList[A[i]].push_back(i); 		edgeList[B[i]].push_back(i); 	}  	for(int i = 1 ; i <= N ; i++){ 		if(V[i] == 0) 			dfs(i, -1); 	}  	for(int i = 1 ; i <= M ; i++){ 		if(isBridge[i]){ 			bridgeTree[A[i]].push_back(B[i]); 			bridgeTree[B[i]].push_back(A[i]); 		} 	}  	for(int i = 1 ; i <= N ; i++) V[i] = 0; 	 	long long K = 0; 	for(int i = 1 ; i <= N ; i++){ 		if(V[i] == 0) K += choose(dfs2(i, -1)); 	}  	if(K >= Q){ 		printf("-1\n"); 		return 0; 	}  	++K;  	DP[0].first = DP[0].second = 0; 	DP[1].first = 2, DP[1].second = 1; 	 	for(int i = 2; i <= K ; i++){ 		DP[i].first = 1e9; 		for(int j = 2 ; ; j++){ 			long long p = choose(j); 			if(i >= p && (DP[i - p].first + j < DP[i].first) ){ 				DP[i].first  = DP[i - p].first  + j; 				DP[i].second = DP[i - p].second + 1; 			} 			if(i < p) break; 		} 	}  	int res = DP[K].first += (DP[K].second == 2); 	printf("%d\n",res); }
#include <bits/stdc++.h> #define ll long long int #define MAX 100001 #define EPS 1e-9 #define MOD 1000000007 #define INF 1e9 #define pn() printf("\n") #define vint vector <int> #define vpint vector <pair<int,int> > #define pb push_back #define mp make_pair #define ft first #define sd second #define gc() getchar_unlocked() #define ms(x,v) memset(x,v,sizeof x) #define pr_arr(i,x,size) for(i=0;i<size;i++) cout<<x[i]<<" " #define ff(i,a,b) for(i=a;i<=b;i++) #define fb(i,a,b) for(i=a;i>=b;i--) #define gprint(i) cout<<"Case #"<<i<<": " using namespace std;  int main() {     ios::sync_with_stdio(false);     int n,i,j;     cin>>n;     int arr[n+1];     ff(i,0,n-1)     {     	cin>>arr[i];     }     ll mini=LONG_MAX;     ff(i,1,(1<<n)-1)     {     	ll ans=1;     	ff(j,0,n-1)     	{     		if(i & 1<<j)     		{     			ans*=(1LL*arr[j]);     		}     	}     	mini=min(ans,mini);     }     cout<<mini<<endl;     return 0; }
#include<cstdio> #include<vector> #include<algorithm> using namespace std; int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		int n; 		scanf("%d",&n); 		vector<int> arr1(n); 		vector<int> arr2(n); 		int ans=0; 		int i; 		for(i=0;i<n;i++) 			scanf("%d",&arr1[i]); 		for(i=0;i<n;i++) 			scanf("%d",&arr2[i]); 		sort(arr1.begin(),arr1.end()); 		sort(arr2.begin(),arr2.end()); 		for(i=0;i<n;i++) 			ans += arr1[i]*arr2[i]; 		printf("%d\n",ans); 	} 	return 0; } 
#include <bits/stdc++.h> #define ll long long int #define s(a) scanf("%lld", &a); #define pb push_back #define mp make_pair #define f first #define sc second #define inf 10e16  using namespace std;  ll cnt[1000001]; vector<ll>v[1000001]; vector<ll>u[1000001]; vector<ll>num; ll a[100001];  ll pow1[1000001]; ll pow2[1000001];  ll mod1 = 999999937; ll mod2 = 999999929;  void sieve() {     int i,j;     for(i=2;i<=1000000;i++) {         cnt[i]++;         for(j=i;j<=1000000;j=j+i) {             cnt[j]++;         }     }     cnt[1]=1;     for(i=2;i<=1000000;i++) {         if(v[i].size()!=0) {             continue;         }         for(j=i;j<=1000000;j+=i) {             v[j].pb(i);         }     } }  ll power_count(ll x,ll y) {     ll ans=0;     while(x%y==0) {         x/=y;         ans++;     }     return ans; }  void compute_powers() {     pow2[0]=1;     pow1[0]=1;     for(int i=1;i<=1000000;i++) {         pow1[i]=pow1[i-1]*31;         if(pow1[i]>mod1) pow1[i]%=mod1;         pow2[i]=pow2[i-1]*37;         if(pow2[i]>mod2) pow2[i]%=mod2;     } }  int main() {     //freopen("inp.txt","r",stdin);     sieve();     compute_powers();     map<pair<ll,ll>,ll>mark;     map<pair<ll,ll>,ll>present;     bitset<1000001>b;     ll t,n,i,j,k,l,w,ww,x,y,z;     s(t);     while(t--) {         num.clear();         mark.clear();         present.clear();         s(n);         for(i=1;i<=n;i++) {             s(x);             if(cnt[x]%2==1) {                 x = sqrt(x);             }             else {                 w = cnt[x]/2;                 if(w%2==0) {                     x = 1;                 }             }             a[i]=x;             if(x!=1 && b[x]==0) num.pb(x);             b[x]=1;         }         for(i=0;i<num.size();i++) {             w = num[i];             for(j=0;j<v[w].size();j++) {                 ww = power_count(w,v[w][j]);                 if(ww%2==1) u[w].pb(v[w][j]);             }         }         mark[mp(0,0)]=1;         ll ans=0;         ll mask = 0;         ll mask1 = 0;         for(i=1;i<=n;i++) {             if(a[i]==1) {                 ans = ans + mark[mp(mask,mask1)];                 mark[mp(mask,mask1)]++;             }             else {                 for(j=0;j<u[a[i]].size();j++) {                     ll kk = u[a[i]][j];                     ll kk1 = pow2[kk];                     kk = pow1[kk];                     if(present[mp(kk,kk1)]==1) {                         present[mp(kk,kk1)]=0;                         mask = mask - kk;                         mask1 = mask1 - kk1;                         if(mask<0) mask+=mod1;                         if(mask1<0) mask1+=mod2;                     }                     else {                         present[mp(kk,kk1)]=1;                         mask=mask+kk;                         mask1=mask1+kk1;                         if(mask1>mod2) mask1-=mod2;                         if(mask>mod1) mask-=mod1;                     }                 }                 ans=ans+mark[mp(mask,mask1)];                 mark[mp(mask,mask1)]++;             }             //cout<<mask<<endl;         }         cout<<ans<<endl;     }     return 0; } 
#include<bits/stdc++.h> using namespace std;  int main(){ int t; scanf("%d",&t); while(t--){  deque<int> q; int n,x; scanf("%d",&n); for(int i=0;i<n;i++) scanf("%d",&x),q.push_back(x); x=0; int f=0,g=0; long long suml=0,sumr=0; 	while(!q.empty()){ 		if(suml<=sumr) 		suml+=q.front()+1,q.pop_front(); 		else sumr+=q.back()+1,q.pop_back(); 		 	 	} 	cout<<max(sumr,suml)+1<<endl; } return 0; }
#include <bits/stdc++.h> #define ll long long #define mod 1000000007 using namespace std; ll int dp[110][110]={0}; int main() { 	ios_base::sync_with_stdio(false); 	cin.tie(NULL); 	ll int i,j; 	for(i=0;i<110;i++) 	{ 		for(j=0;j<=i;j++) 		{ 			if(i==0 && j==0) 			dp[i][j]=1; 			else if(j==0) 			dp[i][j]=1; 			else if(i==j) 			dp[i][j]=1; 			else 			{ 				dp[i][j]=(dp[i-1][j-1] +dp[i-1][j])%mod; 			} 		} 	} 	//~ cout<<"Here "<<endl; 	//~ while(1) 	//~ { 		//~ cin>>i>>j; 		//~ cout<<dp[i][j]<<endl; 	//~ } 	ll int test; 	cin>>test; 	while(test--) 	{ 		string s; 		ll int a[5]; 		for(i=0;i<5;i++) 		cin>>a[i]; 		ll int h[5]; 		memset(h,0,sizeof(h)); 		cin>>s; 		ll int ans,l=s.length(); 		for(i=0;i<l;i++) 		{ 			if(s.at(i)=='a') 			h[0]++; 			else if(s.at(i)=='e') 			h[1]++; 			else if(s.at(i)=='i') 			h[2]++; 			else if(s.at(i)=='o') 			h[3]++; 			else if(s.at(i)=='u') 			h[4]++; 		} 		ans=1; 		for(i=0;i<5;i++) 		{ 			if(h[i]!=0) 			ans= (ans * dp[a[i]-1][h[i]-1])%mod; 		} 		cout<<ans<<endl; 	} 	return 0; } 
// DP // Dearrangment Question  #include<cstdio> #define ll long long  #define mod 1000000007 ll dp[10000000];  void precomp() { 	ll i; 	dp[1]=0; 	dp[2]=1; 	for(i=3; i< 100001; i++) 	{ 		dp[i] = ((i-1)%mod*(dp[i-1]%mod + dp[i-2]%mod))%mod; 	} }  using namespace std; int main(int argc, char const *argv[]) { 	ll t,n; 	precomp(); 	scanf("%lld",&t); 	while(t--) 	{ 		scanf("%lld",&n); 		printf("%lld\n", dp[n]); 	} 	return 0; }
#include <cstdio> #include <algorithm> #include <climits>   using namespace std;   int A[100001];   int main() {   int T; scanf("%d", &T);     while(T--) {     int N, Q1, Q2, Q3, Q4; scanf("%d %d %d %d %d", &N, &Q1, &Q2, &Q3, &Q4);       for(int i = 1; i <= N; i++) {       scanf("%d", &A[i]);     }       bool pos = false;     for(int i = 1; i <= N; i++) {       if(A[i] != Q1 && A[i] != Q2 && A[i] != Q3 && A[i] != Q4) pos = true;     }        if(pos) {       long long curr = 0;       long long ans = LLONG_MIN/2;       int i = 1;       while(i <= N) {         if(A[i] == Q1 || A[i] == Q2 || A[i] == Q3 || A[i] == Q4) {           curr = 0;           i++;           continue;         }         curr = max((long long)A[i], curr + A[i]);         ans = max(ans, curr);         i++;       }       printf("%lld\n", ans);     }     else printf("0\n");   } }  
#include <bits/stdc++.h> using namespace std;  const int N = 1e6 + 5;  long long bit[N]; long long a[N]; long long ans[N]; long long b[N]; long long cnt[N] , val[N] , mnt[N]; int mtp[N]; int n; void update(int idx , int val) {     while(idx <= n){         bit[idx] += val;         idx += idx & -idx;     } }  long long query(int idx) {     long long ret = 0;     while(idx){         ret += bit[idx];         idx -= idx & -idx;     }     return ret; } void make(){     memset(mtp , 0 , sizeof mtp);     int temp[n + 1];     for(int i = 0; i < n; ++i) temp[i] = a[i];     sort(temp , temp + n);     for(int i = 0; i < n; ++i){         int idx = lower_bound(temp , temp + n , a[i]) - temp;         a[i] = idx + 1 + mtp[idx + 1];         ++mtp[idx + 1];     } } int main() {     int tt;     scanf("%d" , &tt);     while(tt--){       scanf("%d" , &n);       memset(bit , 0 , sizeof bit);       memset(cnt , 0 , sizeof cnt);       memset(ans , 0 , sizeof ans);       memset(mnt , 0 , sizeof mnt);       memset(mtp , 0 , sizeof mtp);       for(int i = 0; i < n; ++i) scanf("%d" , a + i);       for(int i = 0; i < n; ++i) b[i] = a[i];       for(int i = 0; i < n; ++i){         ++mtp[a[i]];       }       for(int i = 1; i < N; ++i) ans[i] = ans[i - 1] + mtp[i - 1];       make();       for(int i = n - 1 ; i >= 0; --i){         val[i] = ans[b[i]] - query(a[i] - 1);         update(a[i] , 1);       }       for(int i = 0; i < n; ++i){         printf("%d " , val[i]);       }       printf("\n");     }     return 0; } 
#include <stdio.h> #include<bits/stdc++.h> using namespace std; #include <algorithm> using namespace std; typedef long long ll; #define N 1100   int c[N][N]; ll ans[N][N], ans1[N][N];  int n,m; int main() {     cin>>n>>m;     for(int i = 1; i <= n; i ++) for(int j = 1; j <= m; j ++) cin>>c[i][j];    // for(int i = 1; i <= n; i ++) ans[i][0] = 0;    // for(int i = 1; i <= m; i ++) ans[1][i] = ans[1][i - 1] + c[1][i];     for(int i = 1; i <= n; i ++)  		for(int j = 1; j <= m; j ++)         ans[i][j] = max(ans[i - 1][j], ans[i][j - 1]) + c[i][j];     // for(int i = m; i; i --) ans1[1][i] = ans1[1][i + 1] + c[1][i];     for(int i = 1; i <= n; i ++)  	for(int j = m; j; j --)  	ans1[i][j] = max(ans1[i][j + 1], ans1[i - 1][j]) + c[i][j];     ll mx = 0;     for(int i = 1; i <= m - 1; i ++) mx = max(mx, ans[n][i] + ans1[n][i + 1]);     printf("%lld\n", mx);     return 0; }  
#include<stdio.h> int main() { int t,i; scanf("%d",&t); for(i=1;i<=t;i++) { long long int x,y,z,t,a,b,gcd; scanf("%lld%lld",&x,&y); a=x; b=y; while(b!=0){ t=b; b=a%b; a=t; } gcd=a; z=x*y/gcd; printf("%lld\n%lld\n",gcd,z); } } 
#include <iostream> #include <string> using namespace std;  bool find(string S1, string S2) { 	for(int i = 0; i < S2.size(); i++) { 		if (S1[i] != S2[i]) 			return false; 	} 	return true; }  int main() { 	int N, Q; 	long long int priority[1000]; 	string name[1000], query; 	cin >> N; 	for(int i = 0; i < N; i++) { 		cin >> name[i] >> priority[i]; 	} 	cin >> Q; 	for(int i = 0; i < Q; i++) { 		long long int max = -1000000001; 		int pos = -1; 		cin >> query; 		for(int j = 0; j < N; j++) { 			if(find(name[j], query)) { 				if(priority[j] > max) { 					max = priority[j]; 					pos = j; 				} 			} 		} 		if(pos != -1) 			cout << name[pos] << endl; 		else 			cout << "NO" << endl; 	} 	return 0; }
    #include<bits/stdc++.h>     using namespace std;     string s[100005];     int possible[26];     int win[100005];     int main()     {     	int t,n,k;     	scanf("%d",&t);     	while(t--)     	{     		scanf("%d%d",&n,&k);     		for(int i=0;i<n;i++)     		{     			cin>>s[i];     			win[i]=0;     		}     		for(int i=0;i<26;i++)     		possible[i]=999999;     		for(int i=n-1;i>=0;i--)     		{     			int p=s[i][s[i].size()-1]-'a';     			if(possible[p]>i+k)     			win[i]=1;     			if(win[i])     			possible[s[i][0]-'a']=i;     		}     		int flag=0;     		for(int i=0;i<k;i++)     		if(win[i])     		flag=1;     		if(flag==1)     		printf("Alex\n");     		else     		printf("Bob\n");     	}     } 
#include<stdio.h> #include<iostream> #include<queue> #include<algorithm> typedef long long ll; ll dist[31][31];  int ch; //char getchar_unlocked(){ return getchar(); } inline void Read( int &n )//fast input function { n=0; ch=getchar_unlocked(); while( ch < '0' || ch > '9' )ch=getchar_unlocked(); while( ch >= '0' && ch <= '9' ) n = (n<<3)+(n<<1) + ch-'0', ch=getchar_unlocked(); }  int main(){ 	int t,i,j,k,p=31; 	for(i=0;i<p;i++)dist[0][i]=1; 	for(i=1;i<p;i++)dist[i][i-1]=0; 	for(i=1;i<p;i++){ 		for(j=i;j<p;j++){ 			dist[i][j]=dist[i-1][j]+dist[i][j-1]; 		} 	} 	Read(t); 	while(t--){ 		Read(p); 		if(p==0)printf("0\n"); 		else printf("%lld\n",2*dist[p][p]); 		 	} 	return 0; } 
#include<iostream> #include<cstring> using namespace std;  long long int func(int beg,int last) { if(last-beg==1||last-beg==0) return 1; return func(beg,last-1)*2*(2*(last-beg)-1)/((last-beg)+1); } int main() { ios_base::sync_with_stdio(false); int t; cin>>t; while(t--) { char a[100]; cin>>a; cout<<func(0,strlen(a)-1)<<endl; } } 
#include<iostream> #include<cstdio> #include<algorithm> #include<cstring> #include<cstdlib> #include<cctype> #include<cmath> #include<vector> #include<iterator> using namespace std;  inline int scan() {     int p=0;     char c;     c=getchar_unlocked();     while(c<'0' || c>'9')         c=getchar_unlocked();     while(c>='0' && c<='9'){         p=(p<<3)+(p<<1)+c-'0';         c=getchar_unlocked();     }     return p; }  int xcount, ocount;  void display(char **a) { 	cout<<"Tic Tac Toe"<<endl; 	for(int i=0; i<4; i++) { 		for(int j=0; j<4; j++) { 			cout<<a[i][j]; 			if(a[i][j]=='X') 				xcount++; 			else if(a[i][j]=='O') 				ocount++;			 		} 		cout<<endl; 	} 	cout<<xcount<<" "<<ocount<<endl; }  bool hasWon(char c, char **a) { 	int count = 0; 	int diagflag= 1; 	 	//Check diagonals 	 	if(a[0][0] == c || a[0][0] == 'T') { 		for(int i=0; i<3; i++) { 			if(a[i+1][i+1] != c && a[i+1][i+1] != 'T') { 				diagflag = 0; 				break; 			} 		}  	}  	else diagflag = 0;  	 	if(diagflag) {  		//cout<<"win through right diagonal"<<endl;  		return true;	 	}  	if(a[0][3] == c || a[0][3] == 'T') {  		diagflag = 1;  		for(int i=2; i>=0; i--) {  			if(a[3-i][i] != c && a[3-i][i] != 'T') {  				diagflag = 0;  				break;  			}  		}  	}  	else diagflag = 0;  	if(diagflag) {  		//cout<<"win through left diagonal"<<endl;  		return true;  	} 	//Check rows 	 	for(int i=0; i<4; i++) { 		count = 0; 		if(a[i][0] == c || a[i][0] == 'T') { 			for(int j=1; j<4; j++) { 				if(a[i][j] == c || a[i][j] == 'T') 					++count;		 				else break; 			} 			if(count == 3) { 				//cout<<"win through "<<i<<"th row"<<endl; 				return true; 			} 		}		 	} 	 	//Check columns 	 	for(int i=0; i<4; i++) { 		count = 0; 		if(a[0][i] == c || a[0][i] == 'T') { 			for(int j=1; j<4; j++) { 				if(a[j][i] == c || a[j][i] == 'T') 					++count; 				else break; 			 			} 			if(count == 3) { 				//cout<<"win through "<<i<<"th column"<<endl; 				return true; 			} 		}		 	} 	 	return false; }  bool isDraw(char **a) { 	for(int i=0; i<4; i++) 		for(int j=0; j<4; j++) 			if(a[i][j] == '.') 				return false; 	 	return true; 	 }  int main() { 	int test; 	test = scan(); 	for(int t=0; t<test; t++) {	 		bool wonx, wono, draw, incomplete; 		wonx = wono = draw = incomplete = false; 		char **a = (char **)malloc(4*sizeof(char*)); 		for(int i=0; i<4; i++) 			a[i] = (char*)malloc(4*sizeof(char)); 		xcount = ocount = 0; 		for(int i=0; i<4; i++) { 			for(int j=0; j<4; j++) { 				cin>>a[i][j]; 				if(a[i][j] == 'X') 					++xcount; 				else if(a[i][j] == 'O') 					++ocount;				 			} 		} 		//display(a); 		if(xcount>ocount) 			wonx = hasWon('X', a); 		else if(xcount==ocount) 			wono = hasWon('O', a); 		 		 		//cout<<wonx<<" "<<wono<<endl; 		if(!wonx && !wono) { 			draw = isDraw(a); 		} 		 		if(!draw && !wonx && !wono) 			incomplete = true; 		 		if(wonx) 			cout<<"Case #"<<t+1<<": "<<"X won"<<endl;	 		else if(wono) 			cout<<"Case #"<<t+1<<": "<<"O won"<<endl; 		else if(incomplete) 			cout<<"Case #"<<t+1<<": "<<"Game not completed"<<endl; 		else if(draw) 			cout<<"Case #"<<t+1<<": "<<"Draw"<<endl; 	} 	return 0; }
#include<stdio.h> #include<math.h> typedef long long ll; ll pow(ll n,ll p) {     ll temp;     if(p==0)         return 1;     temp=pow(n,p/2);     if(p%2==0)         return temp*temp;     else         return n*temp*temp; } int main() {     ll t,n,p,ans,k,ans1;     scanf("%lld",&t);     while(t--)     {         scanf("%lld%lld",&n,&p);         k=ll(log2(n));         ans=(2*(n-pow(2,k))+1);         ans1=ans+p-1;         if(ans1>n)             ans1=ans1-n;         printf("%lld\n",ans1);     }     return 0; } 
#include<bits/stdc++.h> #define ll long long #define maxe 2147483647 #define INF 1e16 #define si(x) scanf("%d",&x) #define sl(x) scanf("%ld",&x) #define sll(x) scanf("%lld",&x) #define ss(x) scanf("%s",x) #define pi(x) printf("%d\n",x) #define pl(x) printf("%ld\n",x) #define pll(x) printf("%lld\n",x) #define ps(x) printf("%s\n",x) #define iter(i,a,b) for(int i=a; i<b; i++) #define ited(i,a,b) for(int i=a;i>b;i--) #define mp make_pair  #define pb push_back  #define max(a,b) a>b?a:b #define min(a,b) a<b?a:b //#define pop pop_back  #define mod 1000000007 using namespace std; int main() { 	int t; 	si(t); 	while(t--) 	{ 		int n,x; 		si(n); 		ll an=1; 		iter(i,0,n) 		{ 			si(x); 			an=(an*x)%mod; 		} 		pll(an); 	} 	return 0; }
#pragma comment(linker, "/STACK:102400000,102400000") #include <iostream> #include <stdio.h> #include <algorithm> #include <string.h> #include <vector> #include <map> #include <queue> #include <set> #include <cmath> #include <fstream> #include <assert.h> #include <complex> using namespace std; #define vi vector<int> #define pii pair<int,int> #define pb push_back #define mp make_pair #define all(x) x.begin(),x.end() #define inf 1000000007 #define mod 1000000007 #define x first #define y second #define pi acos(-1.0) #define DBG(x) cerr<<(#x)<<"="<<x<<"\n"; #define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++) #define ull unsigned long long #define ll long long #define N 100010   vi g[N];double d[28],d1[28],dp[2][28][28],c[30][30]; int sz[28],rt; void dfs(int u,int fa){     sz[u]=0;     for(int i=0;i<g[u].size();i++){         int j=g[u][i];         if(j==fa)continue;         dfs(j,u);     }     memset(d,0,sizeof(d));     double p=1,q=0;     for(int i=0;i<g[u].size();i++){         int j=g[u][i];         if(j==fa)continue;         memset(d1,0,sizeof(d1));         q=0;         for(int x=0;x<sz[j];x++){             int y=sz[j]-1-x;             if(dp[0][j][x]){                 if(p){                     q+=p*dp[0][j][x]*c[sz[u]+sz[j]][sz[j]];                 }                 for(int k=0;k<sz[u];k++)if(d[k]){                     int z=sz[u]-1-k;                     for(int r=0;r<=sz[j];r++)                     d1[k+r]+=d[k]*dp[0][j][x]*c[r+k][k]*c[sz[j]-r+z][z];                 }             }             if(dp[1][j][x]){                 if(p){                     for(int r=0;r<=sz[u];r++)                         d1[x+r]+=p*dp[1][j][x]*c[r+x][x]*c[sz[u]-r+y][y];                 }                 for(int k=0;k<sz[u];k++)if(d[k]){                     int z=sz[u]-k-1;                     for(int r=0;r<=k;r++)                     d1[r+x]+=d[k]*dp[1][j][x]*c[r+x][x]*c[sz[u]-r+y][y];                     for(int r=0;r<=x;r++)                     d1[r+k]+=d[k]*dp[1][j][x]*c[r+k][k]*c[sz[j]-r+z][z];                 }             }         }         sz[u]+=sz[j];p=q;         memcpy(d,d1,sizeof(d));       }     for(int i=0;i<=sz[u];i++){         dp[1][u][i]=p;         dp[0][u][i]=0;     }     for(int i=0;i<sz[u];i++){         if(d[i]){             for(int j=0;j<=i;j++)dp[1][u][j]+=d[i];             for(int j=i+1;j<=sz[u];j++)dp[0][u][j]+=d[i];         }     }     sz[u]++; } bool w[28][28]; int main() {     //freopen("1.txt","w",stdout);     int T,i,j,k,ca=0,m,n;     c[0][0]=1;     for(i=1;i<=27;i++){         c[i][0]=1;         for(j=1;j<=i;j++)c[i][j]=c[i-1][j-1]+c[i-1][j];     }     scanf("%d",&T);     while(T--){         scanf("%d",&n);         double tot=1;         //memset(w,0,sizeof(w));         for(i=0;i<n;i++)g[i].clear(),tot=tot*(i+1);         for(i=1;i<n;i++){             scanf("%d%d",&j,&k);j--,k--;             g[j].pb(k);g[k].pb(j);             w[j][k]=w[k][j]=1;         }         double ans=0;         for(i=0;i<n;i++){             rt=i;             dfs(i,i);             //DBG(i)             double sum=0;             for(j=0;j<n;j++)             //cerr<<j<<" "<<dp[1][i][j]<<",",             sum+=dp[1][i][j];             ans+=sum/tot;             //DBG(sum)         }         printf("%.9lf\n",ans);         /*         ans=0;         int p[n+1];         for(i=0;i<n;i++)p[i]=i;         do{             vi v;             for(i=0;i<n;i++){                 int ok=1;                 for(j=0;j<v.size();j++){                     k=v[j];                     if(w[p[i]][k]){ok=0;break;}                 }                 if(ok)v.pb(p[i]);             }             ans+=v.size()/tot;         }while(next_permutation(p,p+n));         printf("ans=%.9lf\n",ans);         */     }     return 0; }
#include<bits/stdc++.h> using namespace std; typedef long long ll; int main() { 	std::ios_base::sync_with_stdio(false); 	ll t,n; 	cin>>t; 	while(t--) 	{ 		cin>>n; 		if(n==1) 		{ 			cout<<"1"<<endl; 		} 		else 		{ 			cout<<"0"<<endl; 		} 	} }
#include<iostream> #include<string.h> using namespace std; int main() {     int t; cin>>t;     char a; cin.get(a);     while(t--)     {     char c[1000];     int count=1;     cin.getline(c,1000);     for(int i=0;i<strlen(c);i++)     {         if(c[i]==' ')         count++;     }     cout<<count<<endl;     }     return 0; }
#include<string.h> #include<stdio.h> int main() { char str[10001]; int wow[10001]={0}; int l,j,test; long long wowp=1; scanf("%d",&test); while(test--) { scanf("%s",&str); l=strlen(str);   for(j=0;j<l;j++) { if(str[j]=='a')   { wow[1]++;   }   else if(str[j]=='A')   { wow[1]+=2;   }   if(str[j]=='e')   {wow[2]++;   }   else if(str[j]=='E')   {wow[2]+=2;   }   if(str[j]=='i')   {wow[3]++;   }   else if(str[j]=='I')   {wow[3]+=2;   }   if(str[j]=='o')   {wow[4]++;   }   else if(str[j]=='O')   {wow[4]+=2;   }   if(str[j]=='u')   {wow[5]++;   }   else if(str[j]=='U')   {wow[5]+=2;   } } for(j=0;j<6;j++) { if(wow[j]!=0)   { wowp=wowp*wow[j];   } } printf("%lld\n",wowp); for(j=0;j<6;j++) { wow[j]=0; } wowp=1;  } return 0; }
#include <bits/stdc++.h> using namespace std; int T,N; int A[100005]; int main() { 	cin>>T; 	while(T--) 	{ 		scanf("%d",&N); 		for(int i=0; i<N; i++)scanf("%d",&A[i]); 		sort(A,A+N); 		int flag=0; 		int curr=0; 		int ans=0; int cnt=0; 		for(int i=0; i<N ; i++) 		{ 			int tmp=A[i]-curr; 			if(tmp<=0){ 				flag=1; 				break; 			} 			curr++; 			ans++; 			cnt++; 			if(cnt==6) 			{ 				cnt=0; 				curr++; 			} 		} 		if(flag==1)cout<<"Goodbye Rick"<<"\n"<<ans<<"\n"; 		else cout<<"Rick now go and save Carl and Judas"<<"\n"; 	} 	return 0; }
#include<stdio.h> #include<iostream> #include<algorithm> #include<queue> #include<vector> #include<stack> #include<bitset> #include<limits.h> #include<utility> #include<string.h> #include<math.h> using namespace std; #define pii pair< int , int >  int rev_sort(int i,int j) {     return (i>j); } const int mod=10000003; long long int mat[][5]={{0,1,1,2,2},                         {1,0,0,0,0},                         {0,1,0,0,0},                         {0,0,0,1,1},                         {0,0,0,0,1}                         },ans[5][5],temp[5][5],p[5][5];  void mmul(long long int a[5][5],long long int b[5][5]) {     long long int tat=0;     for(int i=0;i<5;++i)     {         for(int j=0;j<5;++j)         {             tat=0;             for(int k=0;k<5;++k)                  {                     tat=(tat+a[i][k]*b[k][j])%mod;                  }                  p[i][j]=tat;         }     }     for(int i=0;i<5;++i)     {         for(int j=0;j<5;++j)         {             a[i][j]=p[i][j];         }     }  }  void pow(int n) {     for(int i=0;i<5;++i)     {         for(int j=0;j<5;++j)         {             temp[i][j]=mat[i][j];             ans[i][j]=0;         }     }     for(int i=0;i<5;++i)     {         ans[i][i]=1;     }      while(n)     {         if(n&1)         {             mmul(ans,temp);         }         n>>=1;         mmul(temp,temp);     } }  int main() {     int t;     scanf("%d",&t);     while(t--)     {         int n;         scanf("%d",&n);         if(n==0)         {             printf("0\n");             continue;         }         if(n==1)         {             printf("1\n");             continue;         }         if(n==2)         {             printf("1\n");             continue;         }         pow(n-2);         long long int q=(ans[0][0]+ans[0][1]+2*ans[0][3]+ans[0][4])%mod;         printf("%lld\n",q);     }       return 0; } 
#include <iostream> #include <vector> #include <list> #include <map> #include <set> #include <queue> #include <stack> #include <string> #include <cstring> #include <cmath> #include <climits> #include <algorithm> #include <cstdio> using namespace std;  typedef unsigned long long ULL; typedef long long LL;  #define REP(i,n)      FOR(i,0,n) #define FOR(i,a,b)    for(int i = a; i < b; i++) #define ROF(i,a,b)    for(int i=a;i>b;i--) #define GI 		      ({int t;scanf("%d",&t);t;}) #define GL 		      ({LL t;scanf("%lld",&t);t;}) #define GD 		      ({double t;scanf("%lf",&t);t;}) #define pb 	          push_back #define mp 	          make_pair #define MOD 	      1000000007 #define INF	          (int)1e9 #define EPS	          1e-9 #define TR(a,it)      for (typeof((a).begin()) it = (a).begin(); it != (a).end(); ++it)  int arr[505][505], dp[505][505]; int main() { 	//freopen("input.txt", "r", stdin); 	//freopen("output.txt", "w", stdout);  	int T, t = 0, n, a, b; 	scanf("%d", &T); 	while (T--) { 		scanf("%d %d %d", &n, &a, &b);  		for (int i=0; i<n; i++)             for (int j=0; j<2*n-1; j++) {                 arr[i][j] = INT_MAX;                 dp[i][j] = INT_MAX;             }          for (int i=0; i<n; i++)             for (int j=n-i-1; j<n+i; j++)                 scanf("%d", &arr[i][j]);          /*         printf("printing arr\n");         for (int i=0; i<n; i++) {             for (int j=n-i-1; j<n+i; j++)                 printf("%10d ", arr[i][j]);             printf("\n");         }         printf("\n");         */          for (int j=0; j<2*n+1; j++)             dp[0][j] = arr[0][j];          for (int i=1; i<n; i++) {             for (int j=n-i-1; j<n+i; j++) {                 int mini = INT_MAX;                 for (int k=j-b; k<=j+a; k++)                     if (k>=n-i && k<n+i-1)                         mini = min(mini, dp[i-1][k]);                  if (mini == INT_MAX)                     dp[i][j] = INT_MAX;                 else                     dp[i][j] = mini + arr[i][j];             }         }           /*          printf("Printing DP\n");          for (int i=0; i<n; i++) {             for (int j=0, k=0; k<2*n-1; k++, j++)                 printf("%10d ", dp[i][j]);             printf("\n");          }          */          int mini = INT_MAX;         for (int j=0; j<2*n-1; j++)             mini = min(mini, dp[n-1][j]);         printf("%d\n", mini); 	} 	return 0; } 
#include <bits/stdc++.h> using namespace std; int dp[109][109]={0}; int lcs(char *a,char *b,int n,int m) { 	if(dp[n][m]) 	return dp[n][m]; 	if(n==0 || m==0) 		return 0; 	if(a[n-1]==b[m-1]) 		dp[n][m]=1+lcs(a,b,n-1,m-1); 	else 		dp[n][m]=max(lcs(a,b,n-1,m),lcs(a,b,n,m-1)); 	return dp[n][m]; } int main() { 	// your code goes here 	int t,i,j; 	scanf("%d",&t); 	char a[109],b[109]; 	while(t--) 	{ 	 	scanf("%s%s",a,b); 	 	int k1=strlen(a); 	 	int k2=strlen(b); 	 	char temp[109]; 	 	temp[k2]='\0'; 	 	for(i=k2-1;i>=0;i--) 	 		temp[k2-1-i]=b[i]; 	 for(i=0;i<109;i++) 	 	for(j=0;j<109;j++) 	 	dp[i][j]=0; 	 	int x1=lcs(a,b,k1,k2); 	 	for(i=0;i<109;i++) 	 	for(j=0;j<109;j++) 	 	dp[i][j]=0; 	 	int x2= lcs(a,temp,k1,k2); 	 	if(x1==k2 &&x2==k2) 	 		printf("%d",3); 	 	else if(x1==k2) 	 		printf("%d",1); 	 	else if(x2==k2) 	 	printf("%d",2); 	 	else 	 	printf("0"); 	 	printf("\n"); 	} 	return 0; }
#include<iostream> #include<cstdio> #include<cstring> using namespace std; int alpha[26]; int index_rec[26]; //end of declaration inline int scan_d(){int ip=getchar_unlocked(),ret=0,flag=1;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;} inline void println_d(int n){if(n<0){n=-n;putchar_unlocked('-');}int i=10;char output_buffer[11];output_buffer[10]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<11);} inline void ip() {     string str="";     int i,k,cur_ctr,ctr_max,temp1;     int temp=getchar_unlocked();     while(temp<'a'||temp>'z')         temp=getchar_unlocked();     memset(alpha,0,sizeof(alpha));     memset(index_rec,-1,sizeof(index_rec));     k=0; cur_ctr=ctr_max=0;     while(temp>='a'&&temp<='z')     {         str+=(char)temp;         if(alpha[str[k]-97]==0)         {             alpha[str[k]-97]++;            index_rec[str[k]-97]=k;            cur_ctr++;         }         else         {            if(cur_ctr>ctr_max) ctr_max=cur_ctr;            cur_ctr=k-index_rec[str[k]-97];            temp1=index_rec[str[k]-97];            memset(index_rec,-1,sizeof(index_rec));            memset(alpha,0,sizeof(alpha));            for(i=temp1+1;i<=k;i++)            {                index_rec[str[i]-97]=i;                alpha[str[i]-97]++;            }         }         temp=getchar_unlocked();         k++;     }     if(cur_ctr>ctr_max) println_d(cur_ctr);     else println_d(ctr_max); }   int main() {     int T; 	T=scan_d(); 	while(T--) 	{ 	  ip(); 	} }
#include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<cmath> using namespace std; int main() {   std:ios_base::sync_with_stdio(false);   int t,n,i,tmp,mx=-1,id;   cin>>t;   while(t--)   { mx=-1;    cin>>n;   id=1;   for(i=0;i<n;i++)   {   	cin>>tmp;   	if(tmp>mx)   	{   		mx=tmp;   		id=i+1;   	}   }   cout<<id<<"\n";	   }   return 0; } 
//#include<bits/stdc++.h> #include <iostream> #include <cstdio> #include <vector> #include <map> #include <queue> #include <stack> #include <cstring> #include <algorithm> #include <cstdlib> #include <cmath> #include <set> using namespace std; #define w(t) while(t--) #define S(x) scanf("%d",&x) #define SLL(x) scanf("%lld",&x) #define P(x) printf("%d\n",x) #define fl(i , a, b) for(i = (int)a; i<(int)b; i++) #define mem(a , value) memset(a , value , sizeof(a)) #define tr(c, itr) for(itr = (c).begin(); itr != (c).end(); itr++) #define MOD 1000000007 #define MAX 1000000010 #define ll long long #define all(v) v.begin(),v.end() #define mp make_pair #define pb push_back #define f first #define s second typedef pair<int,int> pp; int a[300]; int ans[102];  std::vector<int> buckets[65]; int getlen(int x) { 	int r=0; 	while(x) 	{ 		x=x/2; 		r++; 	} 	return r;  } int main() { 	//std::ios_base::sync_with_stdio(false); 	int n ,i, j ; 	int k ;  	S(n); S(k);  	fl(i,0,n) S(a[i]);  	fl(i,0,n) 	{ 		int len = getlen(a[i]);  		buckets[len].pb(a[i]);  	} 	int cnt = 0 ;  	for(i = 30; i >0; i--) 	{ 		if(buckets[i].size() > 0 ) 		{ 			ans[cnt++] = buckets[i][0];  			for(j = 1 ; j < (int)buckets[i].size() ; j++) 			{ 				int tmp = buckets[i][0] ^ buckets[i][j]; 				int len = getlen(tmp); 				buckets[len].pb(tmp);  			} 		} 	} 	int final = k ;  	for(i =0 ;i < cnt ; i++) 	{ 		if(final > (final ^ ans[i])) 			final = final ^ ans[i];  	}  	if(final == 0 ) printf("Yes\n"); 	else printf("No\n"); 	return 0;  }
#include<bits/stdc++.h> using namespace std; typedef long long ll; int main() {     int cases;     cin>>cases;     while(cases--){     ll n;     cin>>n;     ll i = (n/4)*4;     ll ans = 0;     for(;i<=n;i++)     {         ans = ans^i;     }     cout<<ans<<endl;     }     return 0; } 
#include<iostream> #include<cstdio> #include<cstring> using namespace std; int main() { 	char str[200]; 	int i,g,j; 	cin.getline(str,sizeof(str)); 	g=strlen(str); 	for(i=0;i<=g-3;i++) 	{ 		if((int)str[i]==32&&(int)str[i+1]==32) 		{ 			for(j=i;j<=g-3;j++) 			{ 				str[j+1]=str[j+2]; 			} 			i--; 			g--; 		} 	} 	for(i=0;i<g;++i) 		cout<<str[i]; 	cout<<endl; 	return 0; }
#include <iostream> #include <cmath> using namespace std;  int main() { 	int N,Nc,K,a,op=1; 	cin>>N>>K; 	Nc=N--; 	cin>>a; 	while(N--) 	{ 	    int b; 	    cin>>b; 	    if(abs(a-b)<=K) 	        op++; 	    else 	    { 	        cout<<op<<endl; 	        return 0; 	    } 	    a=b; 	} 	cout<<Nc<<endl; 	return 0; } 
#include <bits/stdc++.h> using namespace std; int main() { 	// your code goes here 	int t;   	// cout<<"enter the test cases"; 	cin>>t;  	for (int m=0;m<t;m++) 	{ 		int num; 		cin>>num; 		int sum = 0; 		for (int i=1;num/pow(5,i)>=1;i++) 		{ 			int m = 1; 			while(m <= num/pow(5,i)) 			{ 				sum += pow(5,i)*m; 				m++; 			} 		} 		cout<<sum<<"\n";     } 	return 0; }  
#include<iostream> //#include<conio.h> #include<math.h> using namespace std; int main() {     long long int t,z=1,x,y,u,n,f;     cin>>t;     while(z<=t)     {                cin>>n;                u=(sqrt(1+8*n)-1)/2;                if(u%2==1)                {                          x=u;                          y=1;                          if(u*(u+1)/2==n)                          {                                          cout<<"("<<y<<","<<x<<")"<<endl;                          }                          else                          {                              x++;                              f=n-u*(u+1)/2-1;                              x-=f;                              y+=f;                              cout<<"("<<y<<","<<x<<")"<<endl;                          }                }                else                {                          x=1;                          y=u;                          if(u*(u+1)/2==n)                          {                                          cout<<"("<<y<<","<<x<<")"<<endl;                          }                          else                          {                              y++;                              f=n-u*(u+1)/2-1;                              x+=f;                              y-=f;                              cout<<"("<<y<<","<<x<<")"<<endl;                          }                }                z++;     }     //getch();     return(0); }                                                                                                                          
#include <stdio.h> #include <stdlib.h> #include <iostream> #include <string.h> #include <algorithm> #include <math.h> #include <vector> #include <queue> #include <set> #include <stack> #include <map> #define INF_MAX 2147483647 #define INF_MIN -2147483647 #define INF_LL 9223372036854775807LL #define INF 2000000000 #define PI acos(-1.0) #define inf INT_MAX #define llu unsigned long long int #define all(v) v.begin(),v.end() #define pb push_back #define mp make_pair #define F first #define S second #define si(n) scanf("%d",&n) #define slli(n) scanf("%lld",&n); #define ss(n) scanf("%s",n); using namespace std; typedef long long int LL; int A[1000010] , B[1000010] , C[1000010]; std::map< pair<int , int> , LL > mpp; int main() { string ip; cin >> ip; // memset(A , 0 , sizeof(A)); // memset(B , 0 , sizeof(B)); // memset(C , 0 , sizeof(C)); A[0] = 0; B[0] = 0; C[0] = 0; int len = ip.length(); ip = "*" + ip; for(int i=1;i<=len;i++){ 	A[i] = A[i-1]; 	B[i] = B[i-1]; 	C[i] = C[i-1]; 	if(ip[i]=='A') 		A[i]++; 	if(ip[i]=='B') 		B[i]++; 	if(ip[i]=='C') 		C[i]++; } LL ans = 0; mpp[mp(0 , 0)] = 1; for(int i=1;i<=len;i++) { 	if(mpp.find(mp(A[i] - B[i] , A[i] - C[i]))!=mpp.end()) 	{ 			ans = ans  + mpp[mp(A[i] - B[i] , A[i] - C[i])] ; 			mpp[mp(A[i] - B[i] , A[i] - C[i])]++; 	} 		else 			mpp[mp(A[i] - B[i] , A[i] - C[i])] = 1; } printf("%lld\n", ans);  return 0; }  //A[i] - A[j] = B[i] - B[j] = C[i] - C[j] //A[i] - B[i] = A[j] - B[j] //A[i] - C[i] = A[j] - C[j]     
#include <iostream> #include <cstdio> #include <cstring> #include <stack> #include <vector> #include <queue> #include <algorithm> using namespace std; struct point { 	int dis,v,next; }e[20010]; int cnt,head[110]; void addedge(int u,int v,int dis) { 	e[cnt].v = v; 	e[cnt].dis = dis; 	e[cnt].next = head[u]; 	head[u] = cnt ++; } int dis[110],visit[110]; queue<int> q; int c[110]; int spfa(int n,int r) { 	memset(c,0,sizeof(c)); 	while(!q.empty()) q.pop(); 	for(int i = 1; i <= n; i ++) { 		dis[i] = r; 		q.push(i); 		visit[i] = 1; 	} 	while(!q.empty()) { 		int u = q.front(); 		q.pop(); 		visit[u] = 0; 		for(int i = head[u]; i != -1; i = e[i].next)  			if(dis[e[i].v] < dis[u] + e[i].dis) { 				dis[e[i].v] = dis[u] + e[i].dis; 				if(!visit[e[i].v]) { 					c[e[i].v] ++; 					if(c[e[i].v] > n) return 0; 					visit[e[i].v] ++; 					q.push(e[i].v); 				} 			} 	} 	int sum = 0; 	for(int i = 1; i <= n; i ++) 		sum += dis[i]; 	printf("%d\n",sum); 	for(int i = 1; i <= n; i ++) { 		printf("%d",dis[i]); 		if(i == n) printf("\n"); 		else printf(" "); 	} 	return 1; } int main() { 	int n,m,r,t,x,y,z; 	scanf("%d",&t); 	while(t--) { 		scanf("%d%d%d",&n,&m,&r); 		memset(head,-1,sizeof(head)); 		cnt = 0; 		while(m --) { 			scanf("%d%d%d",&x,&y,&z); 			addedge(y,x,z); 		} 		if(!spfa(n,r)) printf("Inconsistent analysis.\n"); 	} 	return 0; } 
#include<iostream> #include<stdio.h> using namespace std; int gcd(int a,int b) { 	if(a<b) 	{ 		int temp=a; 		a=b; 		b=temp; 	} 	while(a%b!=0) 	{ 		int r=a%b; 		a=b; 		b=r; 	} 	return b; }   int main() { 	int t; 	cin>>t; 	while(t>0) 	{ 		t--; 		int num[100000]; 		int den[100000]; 		int n; 		cin>>n; 		for(int i=0;i<n;i++) 		{ 			scanf("%d/%d",&num[i],&den[i]); 		} 		int a[100000]; 		int b[100000]; 		a[n-1]=num[n-1]; 		b[n-1]=den[n-1]; 		int r[100000]; 		r[n-1]=n; 		for(int i=n-2;i>=0;i--) 		{ 			int j=i+1; 			a[i]=num[i]; 			b[i]=den[i]; 			while(j<n && 1.0*a[i]/b[i]<1.0*(a[i]+a[j])/(b[i]+b[j])) 			{ 				a[i]=a[i]+a[j]; 				b[i]=b[i]+b[j]; 				j=r[j]; 			} 			r[i]=j; 		} 		for(int i=0;i<n;i++) 		{ 			int g=gcd(a[i],b[i]); 			a[i]/=g; 			b[i]/=g; 			printf("%d/%d\n",a[i],b[i]); 		} 		cout<<"\n"; 	} 	return 0; }  
#include<iostream> #include<cstring> #include<cstdio> #define inf 1000000 using namespace std;  int dp[1005][1005][3][3]; string s[1005];  bool ispalin(int i,int c1,int c2) { c2=s[i].size()-c2-1; while(c1<c2) { if(s[i][c1]!=s[i][c2]) return false; c1++; c2--; } return true; }  int func(int i,int j,int c1,int c2) { if(i>j) return ((c1==0&&c2==0)?0:inf); if(i==j) { if(c1>s[j].size()-c2-1) return inf; if(ispalin(i,c1,c2)) return 0; return (c1==0&&c2==0?1:inf); } if(dp[i][j][c1][c2]!=-1) return dp[i][j][c1][c2]; int ans=inf; if(s[i][c1]==s[j][s[j].size()-c2-1]) { if(c1+1<s[i].size()&&c2+1<s[j].size()) ans=min(ans,func(i,j,c1+1,c2+1)); else if(c1+1<s[i].size()) ans=min(ans,func(i,j-1,c1+1,0)); else if(c2+1<s[j].size()) ans=min(ans,func(i+1,j,0,c2+1)); else ans=min(ans,func(i+1,j-1,0,0)); } if(c1==0) ans=min(ans,1+func(i+1,j,0,c2)); if(c2==0) ans=min(ans,1+func(i,j-1,c1,0)); return (dp[i][j][c1][c2]=ans); }  int main() { ios_base::sync_with_stdio(false); int t; cin>>t; while(t--) { memset(dp,-1,sizeof(dp)); int n; cin>>n; for(int i=0;i<n;i++) cin>>s[i]; cout<<func(0,n-1,0,0)<<endl; } return 0; } 
#include<bits/stdc++.h> using namespace std; #define rep(i,a,b) for(int i=(int)a;i<=(int)b;i++) #define rip(i,a,b) for(int i=(int)a;i>=(int)b;i--) #define ll long long #define MOD 1000000007 #define N 1000005 #define PI acos(-1) #define MAX 1000010 int arr[N]; int main() {     ll t, n, i, e, o;     cin >> t;     while(t--)     {         memset(arr,0,sizeof arr);         cin >> n >> e >> o;         if(e + o != n*(n+1)/2)         {             cout << -1 << "\n";             continue;         }         if(o == 0)         {             for(i = 0; i < n; i++)                 cout << 2 << " ";             cout << "\n";             continue;         }         for(i = 0; i < n; i++)         {             ll tem = n + i * (n-i-1);             if(o == tem)             {                 arr[i] = 1;                 break;             }         }         if(i < n)         {             for(i = 0; i < n; i++)             {                 if(arr[i])                     cout << 1 << " ";                 else                     cout << 2 << " ";             }         }         else             cout << -1;         cout << "\n";     }     return 0; }
// #include<abhi.944>  #include<bits/stdc++.h> using namespace std;  typedef long long int ll;  #ifndef ONLINE_JUDGE 	#define TRACE #endif  const long double PI=3.1415926535897932384626; const ll MAX=1000000000+7; const int INF = 0x3f3f3f3f;  #define ps printf(" ") #define pn printf("\n") #define sc(n) scanf("%d",&n) #define pf(n) printf("%d",n) #define forall(it, x) for(__typeof((x).begin()) it=(x).begin();it!=(x).end();it++) #define sz size() #define ff first #define ss second #define pb push_back //pop_back #define mp make_pair #define fill(a,val) memset(a,val,sizeof(a)) //#define pii pair <int ,int>  #ifdef TRACE     #define trace(x)            cerr<<__FUNCTION__<<":"<<__LINE__<<": ERROR---->"<<x<<endl;     #define trace1(x)           cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<endl;     #define trace2(x,y)         cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<" | "#y" = "<<y<<endl;     #define trace3(x,y,z)       cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<" | "#y" = "<<y<<" | "#z" = "<<z<<endl;     #define trace4(a,b,c,d)     cerr<<__FUNCTION__<<":"<<__LINE__<<": "#a" = "<<a<<" | "#b" = "<<b<<" | "#c" = "<<c<<" | "#d" = "<<d<<endl; #else     #define trace(x)     #define trace1(x)     #define trace2(x,y)     #define trace3(x,y,z)     #define trace4(a,b,c,d) #endif  #define N 100005  inline ll add(ll a,ll b,ll mod){ll c=(ll)((ll)(a)+(ll)(b));while(c>=mod){c-=mod;};while(c<0){c+=mod;};return c;} inline ll sub(ll a,ll b,ll mod){return add(a,mod-b,mod);} inline ll mul(ll a,ll b,ll mod){ll c=(ll)((ll)(a)*(ll)(b));c%=mod;while(c<0){c+=mod;};return c;} inline ll mod_pow(ll a,ll n,ll b){ll res=1;while(n){if(n&1) {res=mul(res,a,b);}a=mul(a,a,b);n>>=1;}return add(res,0,b);} inline ll mod_div(ll a,ll b,ll mod){ll ans=mul(a,mod_pow(b,mod-2,mod),mod);return ans;} inline ll power(ll a, ll p){ll ret=1;while(p){if(p&1) {ret=(ret*a);}a=(a*a);p>>=1;}return ret;}  int main(int argc, char const *argv[]) {     int t;     sc(t);     while(t--) {         int n;         sc(n);          int multiples[N+3];         fill(multiples,0);         int a[n+3];         for(int i=0;i<n;i++) { sc(a[i]); multiples[a[i]]++;}          // now we need to find no of subsets with gcd = (i=1 to N)         ll subsets[N+3];         fill(subsets,0);         for(int i=N;i>=1;i--) {             int j = i;             ll sum = 0;             ll tot = 0;             while(j <= N) {                 tot += multiples[j];                 sum = add(sum,subsets[j],MAX-1);                 j += i;             }             subsets[i] = sub(mod_pow(2,tot,MAX-1),sum,MAX-1)-1;         }         // now we need to find the answer          ll ans = 1;         for(int i=1;i<=N;i++) {             ans = mul(ans , mod_pow(i, subsets[i], MAX) , MAX);         }         cout << ans << endl;     }         return 0; }
// #include<abhi.944>  #include<bits/stdc++.h> using namespace std;  typedef long long int ll;  #ifndef ONLINE_JUDGE 	#define TRACE #endif  const long double PI=3.1415926535897932384626; const ll MAX=1000000000+7; const int INF = 0x3f3f3f3f;  #define ps printf(" ") #define pn printf("\n") #define sc(n) scanf("%d",&n) #define pf(n) printf("%d",n) #define forall(it, x) for(__typeof((x).begin()) it=(x).begin();it!=(x).end();it++) #define sz size() #define ff first #define ss second #define pb push_back //pop_back #define mp make_pair #define fill(a,val) memset(a,val,sizeof(a)) //#define pii pair <int ,int>  #ifdef TRACE     #define trace(x)            cerr<<__FUNCTION__<<":"<<__LINE__<<": ERROR---->"<<x<<endl;     #define trace1(x)           cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<endl;     #define trace2(x,y)         cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<" | "#y" = "<<y<<endl;     #define trace3(x,y,z)       cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<" | "#y" = "<<y<<" | "#z" = "<<z<<endl;     #define trace4(a,b,c,d)     cerr<<__FUNCTION__<<":"<<__LINE__<<": "#a" = "<<a<<" | "#b" = "<<b<<" | "#c" = "<<c<<" | "#d" = "<<d<<endl; #else     #define trace(x)     #define trace1(x)     #define trace2(x,y)     #define trace3(x,y,z)     #define trace4(a,b,c,d) #endif  int main(int argc, char const *argv[]) {     int t;     sc(t);      while(t--) {         int n,k;         sc(n); sc(k);          int a[n+3];         for(int i=1;i<=n;i++) {             a[i]=i;         }          if((n/2) < k) {             cout << "-1" << endl;             continue;         }          for(int i=1;i<=n-k;i++) {             if(abs(a[i]-i) < k || i+2*k > n) {                 swap(a[i],a[i+k]);             }             if(i==n-k) {                 sort(a+i+1,a+n+1);             }         }          for(int i=1;i<=n;i++) {             pf(a[i]); ps;         }pn;     }      return 0; }
#include <algorithm> #include <functional> #include <vector> #include <cmath> #include <cstdio> #include <cstring>   #define MOD_PRIME 10007   using namespace std;   int fact[MOD_PRIME]; int invfact[MOD_PRIME];   int addmod(int x, int y) { 	int sum = x + y; 	if (sum >= MOD_PRIME) 		sum -= MOD_PRIME; 	return sum; }   int submod(int x, int y) { 	int diff = x - y; 	if (diff < 0) 		diff += MOD_PRIME; 	return diff; }   int mulmod(int x, int y) { 	long long result = x; 	result = (result * y) % MOD_PRIME; 	return (int) result; }   int invmod(int x) { 	int result[2][2] = { { 1, 0}, { 0, 1 } }; 	int base[2][2] = { { 0, 1}, { 1, 0 } }; 	int tmp[2][2];   	int y = x % MOD_PRIME; 	x = MOD_PRIME; 	while (y > 0) { 		int q = x / y; 		int r = x % y; 		base[1][1] = -q; 		memset(tmp, 0, sizeof(tmp)); 		for (int i = 0; i < 2; i++) 			for (int j = 0; j < 2; j++) { 				tmp[i][j] = 0; 				for (int k = 0; k < 2; k++) 					tmp[i][j] += result[i][k] * base[k][j]; 			} 		memcpy(result, tmp, sizeof(result)); 		x = y; 		y = r; 	} 	int inv = result[1][0]; 	if (inv < 0) 		inv += MOD_PRIME; 	return inv; }   void build_fact() { 	fact[0] = 1; 	for (int i = 1; i < MOD_PRIME; i++) 		fact[i] = mulmod(fact[i - 1], i);   	for (int i = 0; i < MOD_PRIME; i++) 		invfact[i] = invmod(fact[i]); }   int combmod(long long n, long long m) { 	int result = 1; 	while (n > 0 && m > 0) { 		int up = (int) (n % MOD_PRIME); 		int down = (int) (m % MOD_PRIME);   		if (up < down) { 			result = 0; 			break; 		}   		int term = fact[up]; 		term = mulmod(term, invfact[down]); 		term = mulmod(term, invfact[up - down]); 		result = mulmod(result, term);   		n /= MOD_PRIME; 		m /= MOD_PRIME; 	} 	return result; }   int lossmod(long long n, long long m) { 	if (n > m) 		return 0;   	int result = combmod(n + m, n); 	result = submod(result, combmod(n + m, n - 1)); 	return result; }   int solve_problem() { 	long long r, c, n;   	if (scanf("%lld %lld %lld", &r, &c, &n) != 3) 		return 1;   	int total = combmod(r + n - 1, n); 	total = mulmod(total, combmod(c + n - 1, n)); 	int loser = lossmod(n, r); 	loser = mulmod(loser, lossmod(n, c));   	printf("%d\n", submod(total, loser));   	return 0; }   int main(int argc, char *argv[]) { 	const char *filenames[] = { 		"", 		"", 	}; 	int num_tests;   	for (int i = 1; i < argc && i <= 2; i++) 		filenames[i - 1] = argv[i];   	if (strlen(filenames[0]) > 0 && freopen(filenames[0], "rt", stdin) == NULL) { 		fprintf(stderr, "Could not reopen stdin\n"); 		return 1; 	} 	if (strlen(filenames[1]) > 0 && freopen(filenames[1], "wt", stdout) == NULL) { 		fprintf(stderr, "Could not reopen stdout\n"); 		return 1; 	}   	build_fact();   	if (scanf("%d", &num_tests) != 1) 		return 1; 	for (int i = 0; i < num_tests; i++) 		solve_problem();   	return 0; }
/* CPP Tempelate  * @author Devashish Tyagi  */  #include <algorithm> #include <iostream> #include <map> #include <queue> #include <set> #include <sstream> #include <fstream> #include <stack> #include <string> #include <vector> #include <list> #include <bitset> #include <cctype> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring>  #define sf(a) scanf("%d",&a) #define ssf(a,b) scanf("%d %d",&a,&b) #define pf(a) printf("%d\n",a) #define foreach(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) #define pi pair<int,int> #define vi vector<int> #define all(v) v.begin(),v.end()  #define PB push_back #define MP make_pair #define sz(a) (int)(a).size()  #define FOR(i,a,b) for(int (i) = (a); (i) < (b); ++(i))   #define RFOR(i,a,b) for(int (i) = (a)-1; (i) >= (b); --(i))   #define CLEAR(a) memset((a),0,sizeof(a))  #define INF 1000000000 #define MOD 1000000009 #define PI 3.1415926535897932  using namespace std; typedef long long LL;  class BIT { private: 	vector<LL> tree; 	int N; public: 	BIT(int n): tree(n), N(n) {}  	void update(int index, int v) { 		while(index < N) { 			tree[index] += v; 			tree[index] %= MOD; 			index += (index & -index); 		} 	}  	LL read(int index) { 		LL sum = 0; 		while(index > 0) { 			sum += tree[index]; 			sum %= MOD; 			index -= (index & -index); 		} 		return sum; 	}  	LL readRange(int l, int r) { 		if (l == 1) 			return read(r) % MOD; 		else 			return (read(r) - read(l-1) + MOD)%MOD; 	} };  int main() { 	int t; 	cin>>t; 	while(t--) { 		int n, m; 		cin>>n>>m; 		int a[n]; 		FOR(i, 0, n) 			cin>>a[i];  		int MAXN = (1<<m); 		int limit = (1<<(m-1)); 		BIT bit(MAXN+1); 		bit.update(1, 1); 		int prefix = 0; 		LL ans = 0;  		FOR(i, 0, n) { 			prefix += a[i]; 			prefix %= MAXN; 			ans = 0; 			if (prefix >= limit -1 ) { 				ans += bit.readRange(prefix - limit + 1 + 1, prefix + 1); 				ans %= MOD; 			} 			else { 				ans += bit.readRange(0 + 1, prefix + 1); 				//cout<<ans<<" "<<prefix<<endl; 				ans %= MOD; 				ans += bit.readRange(limit + prefix + 1 + 1, MAXN - 1 + 1); 				ans %= MOD; 			} 			bit.update(prefix + 1, ans); 		} 		cout<<ans<<endl; 	} 	return 0; }
#include <algorithm> #include <functional> #include <vector> #include <cmath> #include <cstdio> #include <cstring>  #define MAX_N 100000 #define MAX_VALUE 1000000000 #define MOD_PRIME 1000000009 #define NUM_BITS 31 #define pow2ll(n) (1LL << (n))  using namespace std;  int v[MAX_N]; int dp[NUM_BITS][NUM_BITS][2];  int get_lower_exp(int n) { 	int k = -1; 	while (n > 0) { 		k++; 		n >>= 1; 	} 	return k; }  int addmod(int x, int y) { 	int sum = x + y; 	if (sum >= MOD_PRIME) 		sum -= MOD_PRIME; 	return sum; }  int submod(int x, int y) { 	int diff = x - y; 	if (diff < 0) 		diff += MOD_PRIME; 	return diff; }  int mulmod(int x, int y) { 	long long result = x; 	result = (result * y) % MOD_PRIME; 	return (int) result; }  int invmod(int x) { 	int result[2][2] = { { 1, 0}, { 0, 1 } }; 	int base[2][2] = { { 0, 1}, { 1, 0 } }; 	int tmp[2][2];  	int y = x % MOD_PRIME; 	x = MOD_PRIME; 	while (y > 0) { 		int q = x / y; 		int r = x % y; 		base[1][1] = -q; 		memset(tmp, 0, sizeof(tmp)); 		for (int i = 0; i < 2; i++) 			for (int j = 0; j < 2; j++) { 				tmp[i][j] = 0; 				for (int k = 0; k < 2; k++) 					tmp[i][j] += result[i][k] * base[k][j]; 			} 		memcpy(result, tmp, sizeof(result)); 		x = y; 		y = r; 	} 	int inv = result[1][0]; 	if (inv < 0) 		inv += MOD_PRIME; 	return inv; }  int solve_problem() { 	int n;  	if (scanf("%d", &n) != 1) 		return 1;  	for (int i = 0; i < n; i++) 		if (scanf("%d", &v[i]) != 1) 			return 1;  	sort(v, v + n, greater<int>()); 	int result = 0; 	while (v[0] > 0) { 		int nb = get_lower_exp(v[0]); 		int p2nb = 1 << nb; 		int j = 1; 		for (; j < n && nb == get_lower_exp(v[j]); j++) { }  		int parity = j & 1; 		int x[] = { 1, 0 }; 		for (int k = 0; k < j; k++) { 			int a = addmod(mulmod(x[0], p2nb), mulmod(x[1], (v[k] - p2nb + 1))); 			int b = addmod(mulmod(x[1], p2nb), mulmod(x[0], (v[k] - p2nb + 1))); 			x[0] = a; 			x[1] = b; 		}  		int y = x[parity]; 		int z = 1; 		for (int k = 0; k < j; k++) 			z = mulmod(z, v[k] - p2nb + 1); 		y = submod(y, z); 		y = mulmod(y, invmod(p2nb)); 		for (int k = j; k < n; k++) 			y = mulmod(y, v[k] + 1); 		result = addmod(result, y);  		for (int k = 0; k < j; k++) 			v[k] -= p2nb; 		sort(v, v + n, greater<int>()); 	} 	result = addmod(result, 1);  	printf("%d\n", result);  	return 0; }  int main() { 	int num_tests;  	if (scanf("%d", &num_tests) != 1) 		return 1; 	for (int i = 0; i < num_tests; i++) 		solve_problem();  	return 0; } 
#include<bits/stdc++.h> using namespace std; int adj[1005][1005]; int queue1[2005]; int state[2005]; int ans[1005]; int status[2005]; #define initial 1 #define waiting 2 #define visited 3 int front=-1; int rear=-1; int n; int ones=0; int zeroes=0; int cnt; void insert_queue(int vertex) {     if(front==-1)     front=0;     rear=rear+1;     queue1[rear]=vertex; } int isEmpty_queue() {     if(front==-1||front>rear)     return 1;     else     return 0; } int delete_queue() {     int del_item;     del_item=queue1[front];     front=front+1;     return del_item; } int BFS(int v) {     int i;     insert_queue(v);     state[v]=waiting;     while(!isEmpty_queue())     {         v=delete_queue();         status[v] = cnt;         state[v]=visited;         for(i=0;i<n;i++)         {             if(adj[v][i]==1&&state[i]==initial)             {                 insert_queue(i);                 state[i]=waiting;                 ans[i]=1-ans[v];             }             else if(adj[v][i]==1&&state[i]!=initial)             {                 if(ans[i]!=(1-ans[v]))                 {                     printf("-1\n");                     return 0;                 }             }         }     }     return 1; } int main() {     int t, on, zer;     pair<int,int>e[2005];     scanf("%d",&t);     while(t--)     {         cnt = 1;         front=-1;         rear=-1;         scanf("%d",&n);         memset(status, 0, sizeof(status));         int a[n][n];         int i,j;         for(i=0;i<n;i++)         {             for(j=0;j<n;j++)             {                 scanf("%d",&a[i][j]);             }         }         int co=0;         int freq[2005];         memset(freq, 0, sizeof(freq));         for(i=0;i<n;i++)         {             if(a[i][i]==1)             {                 co=1;                 break;             }         }         if(co==1)         printf("-1\n");         else         {             zeroes=0;             ones=0;             memset(adj,0,sizeof(adj));             memset(ans,-1,sizeof(ans));             for(i=0;i<n;i++)             {                 for(j=i+1;j<n;j++)                 {                     if(a[i][j]==1)                     {                         freq[i]++;                         freq[j]++;                         adj[i][j]=1;                         adj[j][i]=1;                     }                 }             }             for(i=0;i<n;i++)                 state[i]=initial;             for(i=0;i<n;i++)             {                 e[i]=make_pair(freq[i],i);             }             //sort(e,e+n);             //printf("freq\n");             //for(i=0;i<n;i++)             //{             //	printf("%d %d\n",e[i].first,e[i].second);             //}               for(i=0;i<n;i++)             {                 int f=e[i].second;                 if(e[i].first!=0)                 {                     if(state[f]==initial)                     {                         if(zeroes>=ones)                         {                             ans[f]=1;                             //ones++;                         }                         else                         {                             ans[f]=0;                             //zeroes++;                         }                         int c=BFS(f);                         if(c==0)                         goto labe;                         on = zer = 0;                         for (int j = 0; j < n; j++) {                             if (status[j] == cnt) {                                 on += (ans[j] == 1);                                 zer += (ans[j] == 0);                             }                         }                         if (zeroes > ones) {                             if (zer > on) {                                 for (int j = 0; j < n; j++) {                                     if (status[j] == cnt)                                         ans[j] = 1-ans[j];                                 }                                 ones += zer;                                 zeroes += on;                             }                             else {                                 ones += on;                                 zeroes += zer;                             }                         }                         else {                             if (zer < on) {                                 for (int j = 0; j < n; j++) {                                     if (status[j] == cnt)                                         ans[j] = 1-ans[j];                                 }                                 ones += zer;                                 zeroes += on;                             }                             else {                                 ones += on;                                 zeroes += zer;                             }                         }                         cnt++;                     }                 }             }             /*for(i=0;i<n;i++)             printf("%d ",ans[i]);             printf("\n");*/             /*for(i=0;i<n;i++)             {                 if(ans[i]==0)                 {                     zeroes++;                 }                 else if(ans[i]==1)                 ones++;             }*/             for(i=0;i<n;i++)             {                 if(state[i]==initial)                 {                       if(zeroes>=ones)                     {                         ans[i]=1;                         ones++;                         state[i]=visited;                     }                     else                     {                         ans[i]=0;                         zeroes++;                         state[i]=visited;                     }                 }             }             int x[n][n];             for(i=0;i<n;i++)             {                 for(j=0;j<n;j++)                 {                     x[i][j]=ans[i]^ans[j];                 }             }             for(i=0;i<n;i++)             {                 for(j=0;j<n;j++)                 {                     int d=1-a[i][j];                     if(d==0&&x[i][j]==0)                     {                         printf("-1\n");                         goto labe;                     }                 }             }             for(i=0;i<n;i++)             printf("%d ",ans[i]);             printf("\n");         labe:             ;         }     }     return 0; } 
#include <iostream> #include <math.h> using namespace std; int main() { 	long long n; 	cin>>n; 	long long a[100005]; 	long long b[35]={0}; 	for(long long i=0;i<n;i++) 	{ 		cin>>a[i]; 		long long x=a[i]; 		long long index=0; 		while(x!=0) 		{ 			if(x%2!=0) 			{ 				b[index]++; 			} 			index++; 			x/=2; 		} 	} 	long long ans=0; 	for(long long i=0;i<35;i++) 	{ 		ans+=(pow(2,i)*b[i]*(b[i]-1))/2; 	} 	cout<<ans; 	return 0; }
#include<iostream> #include<stdio.h> #include<set> using namespace std; #define M 200000  struct node {     int a; }temp; typedef struct node node; node seg[4*M];  int inf=1e9+2; int combine(node a,node b) {     int tr=min(a.a, b.a);     return tr; }  void create_seg(node* a,int idx,int s,int e) {     if(s==e)     {         seg[idx]=a[e];         return;     }     int m=(s+e)/2;     create_seg(a,2*idx,s,m);     create_seg(a,2*idx+1,m+1,e);     seg[idx].a=combine(seg[idx*2],seg[idx*2+1]); }  int seg_query(int idx,int s,int e,int l,int r) {     if(s>r || l>e)     {       return inf;     }     if(s>=l && e<=r)       {         return seg[idx].a;       }      int m=(s+e)/2,an;      an=seg_query(idx*2,s,m,l,r);      an=min(an,seg_query(idx*2+1,m+1,e,l,r));      //cout<<an<<endl;      return an; }  void seg_point(int idx,int s,int e,int l,int k) {     //cout<<idx<<endl;     if(s>l || l>e)     {       return;     }     if(s==e )       {         seg[idx].a-=k;         return;       }       int m=(s+e)/2;      seg_point(idx*2,s,m,l,k);      seg_point(idx*2+1,m+1,e,l,k);      seg[idx].a=min(seg[idx*2].a,seg[idx*2+1].a); }  set<int> bits[32];  void inse(int i,int id) {     int j=0;     while(i)     {         if(i&1)             bits[j].insert(id);         i=i>>1;         j++;     } }  void update(int l,int r,int k,int n) {     int i,j=0,m;     i=k;     m=1;     set<int>::iterator tem,tem1;     while(j<31)     {        // cout<<i<<" "<<j<<" "<<l<<" "<<r<<endl;         if(!(i&1))         {             //cout<<j<<" "<<m<<"df\n";             tem=bits[j].lower_bound(l);             tem1=tem;             while(tem!=bits[j].end() && *tem<=r)             {                 //cout<<*tem<<endl;                 seg_point(1,1,n,*tem,m);                 //cout<<*tem<<" "<<m<<endl;                 tem++;             }             bits[j].erase(tem1,tem);         }         i=i>>1;         m=m<<1;         j++;     } }  int main() {     int t,i,j,l,r,x,k,m;     int n,q,te;     node a[M];     scanf("%d %d",&n,&q);     for(i=1;i<=n;i++)     {         scanf("%d",&(a[i].a));         inse(a[i].a,i);     }     create_seg(a,1,1,n);     while(q--)     {         cin>>x>>l>>r;         if(x)         {             cin>>k;             update(l,r,k,n);         }         else         {             te=seg_query(1,1,n,l,r);             cout<<te<<endl;         }     }     return 0; }  
#include<stdio.h> #include<stdlib.h> #include<assert.h> #include<ctype.h> #include<string.h> #include<math.h> #include<string> #include<deque> #include<iostream> #include<set> #include<map> #include<vector> #include<algorithm> #include<bitset> #include<stack> #include<queue> #include<sstream>  #define MODM 1000000007 #define MAXM 2147483647 #define MAXML 9223372036854775807LL #define Pi 3.14159265358979323846264338327950288419716939937510582 #define EPS 1e-7  #define ff first #define ss second #define pb push_back #define pf push_front #define ppb pop_back #define ppf pop_front #define mp make_pair #define L(x) x.length() #define B(x) x.begin() #define E(x) x.end() #define F(x) x.front() #define SZ(x) x.size() #define CLR(x) x.clear() #define SORT(x) sort(x.begin(),x.end()) #define REV(x) reverse(x.begin(),x.end()) #define FOR(i,x,y) for(int i=x;i<y;i++) #define S(x) scanf("%d",&x) #define SL(x) scanf("%lld",&x) #define FILL(x,y) memset(x,y,sizeof(x)) #define IT iterator  using namespace std; typedef long long int lli; typedef unsigned long long int llu; typedef pair<int,int> P; typedef vector<int> VI; typedef vector< VI > VVI; typedef vector< P > VP; typedef vector< VP > VVP; typedef vector<string> VS; typedef vector< VS> VVS; typedef map<int,int> MAP;  lli gcd(lli a,lli b){if(a==0)return(b);else return(gcd(b%a,a));}  lli fastpow(lli a,lli n,lli temp){if(n==0) return(1);if(n==1)return((a*temp)%MODM); if(n&1)temp=(temp*a)%MODM;return(fastpow((a*a)%MODM,n/2,temp));}  int scan() {  int t=0,m=1;char c;c=getchar();while((c<'0' || c>'9') and c!='-') c=getchar();if(c=='-')c=getchar(),m=-1;  while(c>='0' && c<='9') t=(t<<3)+(t<<1)+c-'0',c=getchar(); return(t*m); } long double x[5005],y[5005],r[5005]; long double theta,slope,cdist,alpha,beta,angle,prevang,finans,ansang,a,b,c,w,h; int n; map<long double,int>point; map<long double,int>::IT it;  long double sqr(long double a) {return(a*a);}  long double dist(long double x1,long double x2,long double y1,long double y2) { 	return(sqr(x1-x2)+sqr(y1-y2)); } void init() { 	scanf("%Lf%Lf%d",&w,&h,&n); 	for(int i=0;i<n;i++) 	scanf("%Lf%Lf%Lf",&x[i],&y[i],&r[i]); } void linepoints(int i) { 	long double temp,x1,x2,y1,y2; 	if(sqr(r[i])>sqr(x[i])) 	{ 		temp=sqrt(sqr(r[i])-sqr(x[i])); 		y1=y[i]+temp; 		y2=y[i]-temp; 		alpha=atan2l(y1-y[i],-x[i]); 		if(alpha<0) alpha+=2*Pi; 		beta=atan2l(y2-y[i],-x[i]); 		if(beta<0) beta+=2*Pi; 		if(alpha>beta) 		{ 			point[0.0]+=1,point[beta]-=1; 			point[alpha]+=1,point[2*Pi]-=1; 		} 		else 		point[alpha]+=1,point[beta]-=1; 	} 	if(sqr(r[i])>sqr(w-x[i])) 	{ 		temp=sqrt(sqr(r[i])-sqr(w-x[i])); 		y1=y[i]+temp; 		y2=y[i]-temp; 		beta=atan2l(y1-y[i],w-x[i]); 		alpha=atan2l(y2-y[i],w-x[i]); 		if(alpha<0) alpha+=2*Pi; 		if(beta<0) beta+=2*Pi; 		if(alpha>beta) 		{ 			point[0.0]+=1,point[beta]-=1; 			point[alpha]+=1,point[2*Pi]-=1; 		} 		else 		point[alpha]+=1,point[beta]-=1; 	} 	if(sqr(r[i])>sqr(y[i])) 	{ 		temp=sqrt(sqr(r[i])-sqr(y[i])); 		x1=x[i]-temp; 		x2=x[i]+temp; 		alpha=atan2l(-y[i],x1-x[i]); 		beta=atan2l(-y[i],x2-x[i]); 		if(alpha<0) alpha+=2*Pi; 		if(beta<0) beta+=2*Pi; 		if(alpha>beta) 		{ 			point[0.0]+=1,point[beta]-=1; 			point[alpha]+=1,point[2*Pi]-=1; 		} 		else 		point[alpha]+=1,point[beta]-=1; 	} 	if(sqr(r[i])>sqr(h-y[i])) 	{ 		 		temp=sqrt(sqr(r[i])-sqr(h-y[i])); 		x1=x[i]+temp; 		x2=x[i]-temp; 		alpha=atan2l(h-y[i],x1-x[i]); 		beta=atan2l(h-y[i],x2-x[i]); 		if(alpha<0) alpha+=2*Pi; 		if(beta<0) beta+=2*Pi; 		if(alpha>beta) 		{ 			point[0.0]+=1,point[beta]-=1; 			point[alpha]+=1,point[2*Pi]-=1; 		} 		else 		point[alpha]+=1,point[beta]-=1; 	} } void solve() { 	finans=0; 	bool inside; 	int temp,val; 	for(int i=0;i<n;i++) 		{	 			//printf("circle %lf %lf\n",x[i],y[i]); 			if(x[i]>w and (r[i]<=(x[i]-w))) 			continue; 			if(y[i]>h and (r[i]<=(y[i]-h))) 			continue; 			  			inside=false; 			CLR(point); 			for(int j=0;j<n;j++) 			if(i!=j) 			{ 				if(sqr(r[j]-r[i])>=dist(x[i],x[j],y[i],y[j]) and r[i]<r[j]) 				{inside=true;break;} 			} 			if(inside) 			continue; 			 			for(int j=0;j<n;j++) 			if(i!=j) 			{ 				cdist=dist(x[i],x[j],y[i],y[j]); 				if(cdist>=sqr(r[i]+r[j]) or cdist<=sqr(r[i]-r[j])) 				continue; 				a=r[i],b=sqrtl(cdist),c=r[j]; 				theta=acos((sqr(a)+sqr(b)-sqr(c))/(2*a*b)); 				slope=atan2l(y[j]-y[i],x[j]-x[i]); 				if(slope<0) slope+=2*Pi; 				 				beta=slope+theta; 				if(beta>2*Pi) 				beta-=2*Pi; 				 				alpha=slope-theta; 				if(alpha<0) 				alpha+=2*Pi; 				 				if(alpha>beta) 				{ 					point[0.0]+=1,point[beta]-=1; 					point[alpha]+=1,point[2*Pi]-=1; 				} 				else 				{ 				point[alpha]+=1; 				point[beta]-=1; 				} 			} 			point[0.0]+=0,point[2*Pi]+=0; 			 			linepoints(i); 			 			ansang=prevang=0,temp=0; 			for(it=B(point);it!=E(point);it++) 			{ 				angle=it->ff,val=it->ss; 				//printf("%Lf %d\n",(angle*180)/Pi,val); 				if(temp==0 and angle>0) 				ansang+=(angle-prevang); 				temp+=val; 				prevang=angle; 			} 		finans+=(ansang*r[i]); 	} 		printf("%.7Lf\n",finans); } int main() { 	int t; 	S(t); 	while(t--) 	{ 		init(); 		solve(); 	} 	return(0); }
 #include <bits/stdc++.h> using namespace std; typedef long long int ll; typedef vector<int> vi; typedef pair<int,int> pii; typedef stack<int> si; #define Pi 3.14159 double e = 1e-8; int INF = 1e9; int a[100001]; ll mp = 1000000009; map<ll,ll> w; map<ll,ll> u; ll k3(ll n) {     if(w[n]!=0)         return w[n];     if(n==1)         return w[n]=1;     if(n<=3)         return w[n]=2;     ll res = (k3(n/2) + k3((n/2)-1))%mp;     return w[n]=res; } ll k4(ll n) {     if(u[n]!=0)         return u[n];     if(n<=1)         return u[n]=1;     if(n<=3)         return u[n]=2;       if(n%2==0)     {         ll res = (k4(n/2)+k4(n/2 -1)+k4(n/2-2))%mp;         return u[n]=res;     }     else     {         ll res = (k4(n/2)+k4(n/2-1))%mp;         return u[n]=res;     } } int main() {     int test;     cin>>test;     for(int z=1;z<=test;z++)     {         ll k,n;         cin>>k>>n;         if(k==3)             cout<<k3(n)<<endl;         else cout<<k4(n)<<endl;     } }
#include<bits/stdc++.h> using namespace std; #define ll long long #define mod 1000000007LL #define mp make_pair #define f first #define s second #define pb push_back multiset<int>s; vector< pair<int,int> >v; int main() {     int n,t,i,j,k,m;     ll ans,ans1;     scanf("%d",&t);     while(t--)     {         scanf("%d %d",&n,&m);         for(i=0; i<n; i++)         {             scanf("%d %d",&j,&k);             v.pb(mp(j,k));             s.insert(k);         }         if(m==n)             m--;         ans=0LL;         sort(v.begin(),v.end());         for(i=0;i<m;i++)             s.erase(s.find(v[i].s));         for(i=m-1;i>=-1;i--)         {             j=*(s.begin());             ans1=(ll)v[i+1].f*(ll)j;             //printf("%d %d%lld\n",j,v[i+1].f,ans1);             if(ans1>ans)                 ans=ans1;             if(i!=-1)             s.insert(v[i].s);             s.erase(s.begin());         }         printf("%lld\n",ans);         v.clear();         s.clear();     }     return 0; } 
#include<bits/stdc++.h> using namespace std; #define ll long long ll dp[20][2][2][2]; int whichDigit; vector<int> v; int sz=0; ll fun(int idx, int tight, int hasCome, int actualDigitStarted) {         ll res = dp[idx][tight][hasCome][actualDigitStarted];         if (res != -1)             return res;          if (idx == sz) {             if (actualDigitStarted > 0 && hasCome > 0)                 res = 1;             else                 res = 0;         } else {             res = 0;             for (int i = 0; i < 10; i++) {                 if (tight > 0 && i > v[idx])                     continue;                  int newId = idx + 1;                 int newTight = 0;                 if (tight == 1) {                     if (i == v[idx])                         newTight = 1;                 }                 int newActualDigitStarted = 0;                 if (actualDigitStarted > 0) {                     newActualDigitStarted = 1;                 } else {                     if (i != 0)                         newActualDigitStarted = 1;                 }                 int newHasCome = 0;                 if (newActualDigitStarted > 0 && i==whichDigit) {                     newHasCome = 1;                 }                 if (hasCome > 0) {                     newHasCome = 1;                 }                  res += fun(newId, newTight, newHasCome, newActualDigitStarted);             }         }          dp[idx][tight][hasCome][actualDigitStarted]=res;         return res;     } int main() {     ll t,n,temp; 	cin>>t; 	while(t--) 	{ 		cin>>n; 		temp=n; 		v.clear(); 		while(temp) 		{ 			v.push_back(temp%10); 			temp/=10; 		} 	 reverse(v.begin(),v.end()); 	 sz=v.size(); 	      ll den = n*10;      ll num=0 ;     //for(int i=0;i<sz;i++)     //cout<<v[i]<<" ";      	 for(int i=0;i<10;i++) 	 { 	 	 for (int i = 0; i < 20; i++)                 for (int j = 0; j < 2; j++)                     for (int k = 0; k < 2; k++)                         for (int l = 0; l < 2; l++)                             dp[i][j][k][l] = -1;  		whichDigit=i;  		  		num+=fun(0,1,0,0);  		//cout<<"hii  "<<num<<endl;;  		  	}  	//cout<<"x=="<<num<<"y=="<<den<<endl; 	long long x = num, y = den;     while (x > 0 && y > 0)       if (x > y) x %= y;       else y %= x;     num /= x + y;     den /= x + y;     printf("%lld/%lld\n", num, den); 	} 	 }
/*       Note that MCMF routine is taken from http://shygypsy.com/tools/mcmf4.cpp. */  #include <bits/stdc++.h>  using namespace std;  // the maximum number of vertices + 1 #define NN 410  // adjacency matrix (fill this up) int cap[NN][NN];  // cost per unit of flow matrix (fill this up) int cost[NN][NN];  // flow network and adjacency list int fnet[NN][NN], adj[NN][NN], deg[NN];  // Dijkstra's predecessor, depth and priority queue int par[NN], d[NN], q[NN], inq[NN], qs;  // Labelling function int pi[NN];  #define CLR(a, x) memset( a, x, sizeof( a ) ) #define Inf (INT_MAX/2) #define BUBL { \     t = q[i]; q[i] = q[j]; q[j] = t; \     t = inq[q[i]]; inq[q[i]] = inq[q[j]]; inq[q[j]] = t; }  // Dijkstra's using non-negative edge weights (cost + potential) #define Pot(u,v) (d[u] + pi[u] - pi[v]) bool dijkstra( int n, int s, int t ) {     CLR( d, 0x3F );     CLR( par, -1 );     CLR( inq, -1 );     //for( int i = 0; i < n; i++ ) d[i] = Inf, par[i] = -1;     d[s] = qs = 0;     inq[q[qs++] = s] = 0;     par[s] = n;      while( qs )      {         // get the minimum from q and bubble down         int u = q[0]; inq[u] = -1;         q[0] = q[--qs];         if( qs ) inq[q[0]] = 0;         for( int i = 0, j = 2*i + 1, t; j < qs; i = j, j = 2*i + 1 )         {             if( j + 1 < qs && d[q[j + 1]] < d[q[j]] ) j++;             if( d[q[j]] >= d[q[i]] ) break;             BUBL;         }                  // relax edge (u,i) or (i,u) for all i;         for( int k = 0, v = adj[u][k]; k < deg[u]; v = adj[u][++k] )         {             // try undoing edge v->u                   if( fnet[v][u] && d[v] > Pot(u,v) - cost[v][u] )                  d[v] = Pot(u,v) - cost[v][par[v] = u];                      // try using edge u->v             if( fnet[u][v] < cap[u][v] && d[v] > Pot(u,v) + cost[u][v] )                  d[v] = Pot(u,v) + cost[par[v] = u][v];                              if( par[v] == u )             {                 // bubble up or decrease key                 if( inq[v] < 0 ) { inq[q[qs] = v] = qs; qs++; }                 for( int i = inq[v], j = ( i - 1 )/2, t;                      d[q[i]] < d[q[j]]; i = j, j = ( i - 1 )/2 )                      BUBL;             }         }     }        for( int i = 0; i < n; i++ ) if( pi[i] < Inf ) pi[i] += d[i];        return par[t] >= 0; } #undef Pot  int mcmf4( int n, int s, int t, int &fcost ) {     // build the adjacency list     CLR( deg, 0 );     for( int i = 0; i < n; i++ )     for( int j = 0; j < n; j++ )          if( cap[i][j] || cap[j][i] ) adj[i][deg[i]++] = j;              CLR( fnet, 0 );     CLR( pi, 0 );     int flow = fcost = 0;          // repeatedly, find a cheapest path from s to t     while( dijkstra( n, s, t ) )      {         // get the bottleneck capacity         int bot = INT_MAX;         for( int v = t, u = par[v]; v != s; u = par[v = u] ) {             int t = fnet[v][u] ? fnet[v][u] : ( cap[u][v] - fnet[u][v] );                               if (t < bot) bot = t;                         }         // update the flow network         for( int v = t, u = par[v]; v != s; u = par[v = u] )             if( fnet[v][u] ) { fnet[v][u] -= bot; fcost -= bot * cost[v][u]; }             else { fnet[u][v] += bot; fcost += bot * cost[u][v]; }              flow += bot;     }        return flow; }   void AddEdge(int from, int to, int _cap, int _cost) {       cap[from][to] = _cap;       cost[from][to] = _cost; }  int n; vector<vector<int> > g(100005); int child[100005]; int value[100005];  void dfs(int from, int par = -1) {       int cnt = 0;       for (int i = 0; i < g[from].size(); i++) {             int to = g[from][i];             if (to != par) {                   dfs(to, from);                   cnt ++;             }       }        child[from] = cnt; }  int main() {       ios::sync_with_stdio(false);       cin.tie(NULL);                    cin >> n;        for (int i = 0; i < n; i++)             cin >> value[i];        for (int i = 0; i + 1 < n; i++) {             int from, to;             cin >> from >> to;             from --, to --;             g[from].push_back(to);             g[to].push_back(from);       }                          dfs(0);        int query;       cin >> query;        while (query --) {             memset(cap, 0, sizeof(cap));              int m, x, y;             cin >> m >> x >> y;              vector<int> v (m);             for (int i = 0; i < m; i++) {                   cin >> v[i];             }              // 1 + m             vector<pair<int, int> > lessX, greatX;             for (int i = 0; i < n; i++) {                   if (child[i] < x) lessX.push_back(make_pair(value[i], child[i]));                   else greatX.push_back(make_pair(value[i], child[i]));             }              int sz1 = min((int) lessX.size(), m);             int sz2 = min((int) greatX.size(), 1);              sort(lessX.begin(), lessX.end());             sort(greatX.begin(), greatX.end());              // total 1 + m + m + m + sz1 + sz2 + 1             int total = 1 + m + m + m + sz1 + sz2 + 1;              int source = 0, sink = total - 1;              for (int i = 0; i < m; i++) {                   AddEdge(source, i + 1, 1, 0);             }              // necessary to insert to take care of the order of query.             for (int i = 0; i < m; i++)                   for (int j = 0; j < i; j++) {                         AddEdge(1 + i, 1 + m + j, 1, v[i] * v[j]);                         AddEdge(1 + i, 1 + m + m + j, 1, v[i] * v[j]);                   }              for (int i = 0; i < m; i++)                   for (int j = 0; j < sz1; j++) {                         AddEdge(1 + i, 1 + m + m + m + j, 1, v[i] * lessX[j].first);                   }              for (int i = 0; i < m; i++)                   for (int j = 0; j < sz2; j++) {                         AddEdge(1 + i, 1 + m + m + m + sz1 + j, 1, v[i] * greatX[j].first);                   }              // add edges to sink node.             // type 1             for (int i = 0; i < m; i++) {                   AddEdge(1 + m + i, sink, x, 0);             }              // type 2             for (int i = 0; i < m; i++) {                   AddEdge(1 + m + m + i, sink, m, y);             }              // type 3             for (int i = 0; i < sz1; i++) {                   AddEdge(1 + m + m + m + i, sink, x - lessX[i].second, 0);             }              // type 4             for (int i = 0; i < sz2; i++) {                   AddEdge(1 + m + m + m + sz1 + i, sink, m, y);             }                                                                    int fcost = 0;             int flow = mcmf4(total, source, sink, fcost);             assert(flow == m);              cout << fcost << endl;       }       return 0; }
//Functions and optimisations used from Anudeep2011's submission of Lucky9 from DEC12 //Here is the link for reference : http://www.codechef.com/viewplaintext/1527371   /* Come on Code on!!!!     Did not declare large arrays due to time limit */  #include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <cstring> #include <queue> #include <ctime> #include <cassert> #include <climits> #include <limits> using namespace std;  typedef vector <int> vi; typedef pair< int ,int > ii;  #define S(a) scanf("%d",&(a)) #define P(a) printf("%d",(a)) #define PS printf(" ") #define NL printf("\n") #define SL(a) scanf("%lld",&(a)) #define PL(a) printf("%lld",(a)) #define LL long long int #define FOR(I,A,B) for(int I= (A); I<(B); ++I) #define all(c) c.begin(), c.end() #define stop system("pause") #define pb push_back #define mp make_pair #define tr(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) #define INDEX(arr,ind)			(lower_bound(all(arr),ind)-arr.begin())   #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min()   const LL MOD=1000000009,MAXN=100005,M = 101;  LL expmod(LL a,LL b,LL MOD){ 	LL x=1,y=a; 	while(b>0) 	{ 		if(b&1) x=(x*y)%MOD; 		y=(y*y)%MOD; 		b>>=1; 	} 	return x; } 	 LL inv(LL n) { 	return expmod(n,MOD-2,MOD); } 	 LL fact[MAXN],ifact[MAXN],imod[MAXN],two_powers[MAXN];  LL store[M][M],ncr[M][M];	  int arr[MAXN]; int hash[M];	// for buckets  int main() { 	//precomputation to prevent TLE 	fact[0]=fact[1]=1; 	FOR(i,2,MAXN) 		fact[i]=((long long)i*fact[i-1])%MOD; 		 	 	 	two_powers[0]=1;two_powers[1]=2; 	FOR(i,2,MAXN) 	   two_powers[i]=(two_powers[i-1]*2)%MOD; 	     ifact[0]=ifact[1]=imod[0]=imod[1]=1;  	FOR(i,2,MAXN){  		imod[i] = (imod[MOD % ((LL)i)] * ((MOD/(LL)i)*(-1)))%MOD + MOD; 		ifact[i] = (ifact[i-1]*imod[i])%MOD;     } 	//precomputation ends     int t;     S(t); 	     while(t--){ 		int N,q; 		S(N);S(q); 		         FOR(i,0,N) 			S(arr[i]); 		         while(q--){ 			             int m; 			S(m); 			             memset(hash,0,sizeof(hash));        //can be reduced to <=m (not full) 			FOR(i,0,N)		//creating the buckets 				hash[(arr[i]%m + m)%m]++; 				 			memset(store,0,sizeof(store));		// may not be required if TLE 			memset(ncr,0,sizeof(ncr)); 			             int start = hash[0]; 			store[0][0] = two_powers[start]; 			             FOR(i,1,m){ 				int val = hash[i]; 				FOR(j,0,val+1){ 					int k = j%m; 					if(k<0) 					   k+= m; 					ncr[i][k] +=  ((ifact[j]*ifact[val-j]%MOD)*(fact[val]%MOD))%MOD; 					if(ncr[i][k]>=MOD) 						ncr[i][k] -= MOD; 				} 				/* 				FOR(j,0,m){                     cout<<ncr[i][j]<<" ";                 }                 */                  				FOR(j,0,m){ 					LL res=0; 					int faltu = j; 					FOR(k,0,m){ 						LL FALTU = store[faltu][i-1] * ncr[i][k]%MOD; 						faltu -= i; 						if(faltu<0) 							faltu+=m; 						res += FALTU; 						if(res>=MOD) 							res -= MOD; 					} 					store[j][i] = res; 				} 				 			} 			/* 			FOR(i,0,m){                 FOR(j,0,m){                     cout<<dp[i][j]<<" ";                 }             }             */ 			PL(store[0][m-1]); 			NL; 		} 	}	 	return 0; } 
#include<cstdio> #include<iostream> #include<vector> #include<algorithm> #include<cmath> #include<climits>  using namespace::std;  typedef vector<int> VI; typedef pair<int,int> PII; typedef vector<PII> VPII; const int maxN = 100000;  int getMid(int s, int e) {  return (e + s)/2;  }  inline int initMaxTree(VPII &a, int ss, int se, VI &tree, int si) {     if (ss == se) {         tree[si] = a[ss].second; return tree[si];     }     int mid = getMid(ss, se);     tree[si] =  max(initMaxTree(a, ss, mid, tree, si*2+1),                     initMaxTree(a, mid+1, se, tree, si*2+2));     return tree[si]; }  void buildMaxTree(VPII &a, VI &tree) {     int n = a.size();     //printf("\na.size() while building: %d\n",n);     int x = (int)(ceil(log2(n)));     int max_size = 2*(int)pow(2, x) - 1;     tree.resize(max_size);     initMaxTree(a, 0, n-1, tree, 0); }  int findMax(VI& tree, int ss, int se, int qs, int qe, int index) {     if (qs <= ss && qe >= se) return tree[index];     if (se < qs || ss > qe) return INT_MIN;      int mid = getMid(ss, se);     return max(findMax(tree, ss, mid, qs, qe, 2*index+1),                findMax(tree, mid+1, se, qs, qe, 2*index+2)); }  int findMax(VPII &a, VI &tree, int L, int R) {     L = lower_bound(a.begin(), a.end(), PII(L, 0)) - a.begin();     R = upper_bound(a.begin(), a.end(), PII(R, maxN+1)) - a.begin() - 1;     //printf("\nL and R after converting: %d %d\n",L,R);     if(L <= R) return findMax(tree, 0, a.size()-1, L, R, 0);     else return 0; } int main() {     #ifndef ONLINE_JUDGE         freopen("in.txt","r",stdin);     #endif     VI isPrime(maxN+1,1);     vector<VI> primes(maxN+1);     for(int p=2; p<=maxN; p++) if(isPrime[p])         for(int n=p; n<=maxN; n+=p) {             if(n>p) isPrime[n] = 0;             primes[n].push_back(p);         }      int n,m;     scanf("%d%d",&n,&m);     vector<VI> indexes(maxN+1);     vector<VPII> primeDivs(maxN+1);     for(int i=0; i<n; i++) {         int a;         scanf("%d",&a);         indexes[a].push_back(i);         for(int j=0; j<primes[a].size(); j++)             primeDivs[primes[a][j]].push_back(PII(i,a));     }      vector<VI> maxTree(maxN+1);     for(int p=2; p<=maxN; p++) {         if(primeDivs[p].empty()) continue;         buildMaxTree(primeDivs[p],maxTree[p]);         //printf("%d :\n",p);         //for(int i=0; i<maxTree[p].size(); i++)             //printf("%d ",maxTree[p][i]);         //printf("\n");     }      while(m--) {         int g,L,R;         scanf("%d%d%d",&g,&L,&R);         L--; R--;         int maxA = 0;         for(int i=0; i<primes[g].size(); i++) {             int p = primes[g][i];             //printf("\n%d prime for which findMax called:\n sizeofTREE: %d\n",p,maxTree[p].size());             int curMax = findMax(primeDivs[p],maxTree[p],L,R);             maxA = max(maxA,curMax);         }         if(!maxA) printf("-1 -1\n");         else {             int cnt = upper_bound(indexes[maxA].begin(),indexes[maxA].end(),R) -                 lower_bound(indexes[maxA].begin(),indexes[maxA].end(),L);             printf("%d %d\n",maxA,cnt);         }     }     return 0; } 
#include <bits/stdc++.h> using namespace std; #define ll long long // ************************************************ // ************************************************* #include<stdio.h> #ifndef ONLINE_JUDGE #define get getchar #else #define get getchar_unlocked #endif inline ll f1() { 	ll n=0,s=1; 	char p=get(); 	if(p=='-') 		s=-1; 	while((p<'0' || p>'9') && p!=EOF && p!='-') 		p=get(); 	if(p=='-') 		s=-1,p=get(); 	while(p>='0' && p<='9' ) 	{ 		n=(n<<3)+(n<<1)+(p-'0'); 		p=get(); 	} 	return (n*s); } ll n; multiset< ll > s, s1,s2,f; map<ll,ll> mp; multiset< ll >::iterator it,ot; void solve() { 	int x; 	ll y;     n=f1();     s.clear();     f.clear();     mp.clear();     for ( int i = 0; i < ( 1 << n ); i++ )  	{ 	x=f1(); 	mp[x]++; 	s.insert(x) ; 	} 	     y=*s.begin();     s.erase(y);     mp[y]--;     for(int p=0;p<mp[y];p++)     s.insert(y);          s1.clear();     s2.clear();     int k=1;    for(ot=s.begin();ot!=s.end();ot++)     {     	if(!mp[*ot])     	continue;         int delta = *( ot);         f.insert(delta);        	s2=s1;        	s2.insert(delta);         y=delta; 	    mp[y]--;	         	for(it=s1.begin();it!=s1.end();it++)         	{ 	        	s2.insert(delta+ *it); 	        	y=delta+ *it; 			    mp[y]--; 	        } 	        k++; 	        s1.clear(); 	        s1=s2; 	        s2.clear();     }  for(it=f.begin();it!=f.end();it++) 	{     cout<<*it<<" ";     }     cout<<endl; }  int main () {     int t;     cin>>t;;     for ( int i = 0; i < t; i++ )  	solve();     return 0; } /* 1 2 0 1 1 2 */
#include<bits/stdc++.h> using namespace std; #define sd(x) scanf("%d",&x) #define slld(x) scanf("%lld",&x) #define ss(x) scanf("%s",x) #define ll long long #define mod 1000000007 #define bitcount    __builtin_popcountll #define pb push_back int a[1003],b[1003][1003]; int main() {     //freopen("in.txt","r",stdin);     //freopen("out.txt","w",stdout);     int t,n,i,j,k;     sd(t);     while(t--)     {     	sd(n);     	for(i=1;i<=n;i++)     		sd(a[i]);     	for(i=0;i<=n;i++)     	{     		for(j=0;j<=n;j++)     			b[i][j]=0;     	}     	for(i=1;i<=n;i++)     		b[1][i]=1;     	for(i=2;i<=n;i++)     	{     		b[i][1]=b[i-1][n];     		for(j=2;j<=a[i];j++)     		{     			b[i][j]=b[i-1][n]-b[i-1][j-2];     			if(b[i][j]<0)     				b[i][j]+=mod;     		}     		for(j=2;j<=n;j++)     		{     			b[i][j]+=b[i][j-1];     			if(b[i][j]>=mod)     				b[i][j]-=mod;     		}     	}     	printf("%d\n",b[n][n]);     }     return 0; }
#include<bits/stdc++.h>  #define xx first #define yy second #define LL long long #define inf 100000000 #define pb push_back #define all(v) v.begin(),v.end() #define pi acos(-1) #define clr(a,b) memset(a,b,sizeof a) #define bclr(a) memset(a,false,sizeof a) #define pii pair<int,int> #define MOD 1000000007 #define MP make_pair #define MX 100000000 using namespace std;  LL pre[555]; int sz,ar[555]; map<LL,int>mp; vector<LL>V,tmp; void rec(LL val){    if(val==1) return;    for(int i=1;i<=mp[val];i++) printf(".");    val/=pre[mp[val]];    if(val>1) printf("#");    rec(val); }  int main() {     int test;     pre[1]=1ll,pre[2]=1ll;     for(int i=3;;i++) {         pre[i]=pre[i-1]+pre[i-2];         sz=i;         if(pre[i]>MX) break;     }     V.pb(0);     V.pb(1);     tmp.pb(1);     mp[1]=1;     while(1){         int szz=tmp.size();         if(szz==0) break;         vector<LL>vv;         vv.clear();         for(int i=0; i<szz; i++){             for(int j=3; j<=sz; j++) {                 LL now=tmp[i]*pre[j];                 if(now>MX) break;                 if(mp[now]);                 else{                     mp[now]=j;                     V.pb(now);                     vv.pb(now);                 }             }         }         tmp.clear();         tmp=vv;     }     sort(all(V));     scanf("%d",&test);     for(int kase=1; kase<=test; kase++){         int n;         LL l,r;         cin>>l>>r>>n;         if(l==0ll && n==1) puts("0 #");         else{             int aa=lower_bound(all(V),l)-V.begin();             int bb=lower_bound(all(V),r)-V.begin();             if(bb>V.size()) bb=V.size()-1;             if(V[bb]>r) bb--;             if(bb-aa+1<n) printf("-1\n");             else{                 LL val=V[aa+n-1];                 cout<<val<<" ";                 if(val==1) puts(".");                 else{                   rec(val);                   cout<<endl;                 }                 memset(ar,0,sizeof ar);             }         }     }     return 0; } 
#include<cstdio> #include<cstdlib> #include<iostream> #include<vector> #include<cmath> using namespace std; vector<int> ap; vector<int> gp; vector<int> a; vector<int> temp;  int process(double num){ 	if(ceil(num)*1.0-num==0 && ceil(num)<=a[a.size()-1]) 		return ceil(num); 	else 		return -1; }  void printing(){ 	int i; 	int l=ap.size(); 	for(i=0;i<l;i++) 		printf("%d ",ap[i]); 	printf("\n"); 	l=gp.size(); 	for(i=0;i<l;i++) 		printf("%d ",gp[i]); 	printf("\n"); 	ap.clear(); 	gp.clear(); 	temp.clear(); }  bool checkForGP(int n){ //	printf("checked for gp()\n"); 	int next,first,second,l,temp_count,i; 	int sp,sq; 	bool done=false; 	l=temp.size(); 	if(temp.size()==0){ 		gp.push_back(ap[0]); 		gp.push_back(ap[1]); 		printing(); 		done=true; 	}  	else if (temp.size()==1){ 		if(a[temp[0]]>ap[0]){ 			gp.push_back(ap[0]); 			gp.push_back(a[temp[0]]); 		} 		else{ 			gp.push_back(a[temp[0]]); 			gp.push_back(ap[0]); 		} 		printing(); 		done=true; 	}  	else if(temp.size()==2){ 		gp.push_back(a[temp[0]]); 		gp.push_back(a[temp[1]]); 		printing(); 		done=true; 	} 	else{ 		first=temp[0]; 		l=temp.size(); 		second=first+1; 		while(!done && second<=temp[1]){ 			gp.push_back(a[first]); 			gp.push_back(a[second]); 			sp=a[second]; 			sq=a[first]; 			next=process((double)(a[second]*1.0*sp/sq)); 			if(second==temp[1]) temp_count=2; 			else temp_count=1;  			for(i=second+1;i<n;i++){ 				if(next==-1) 					break; 				if(temp_count==l) 					break; 				if(i==temp[temp_count] && a[i]==next){ 					gp.push_back(next); 					next=process((double)(next*1.0*sp/sq)); 					temp_count++; 				} 				else if(i==temp[temp_count] && next!=a[i]) 					break; 				else if(a[i]==next){ 					gp.push_back(next); 					next=process((double)(next*1.0*sp/sq)); 				} 			} 			if(temp_count==l){ 				printing(); 				done=true; 			} 			gp.clear(); 			second++; 		} 	} 	temp.clear(); 	ap.clear(); 	gp.clear(); 	return done; }  bool checkForAP(int n){ //	printf("checked for ap()\n"); 	int next,first,i,second,l,d,temp_count; 	bool done=false; 	l=temp.size(); 	if(temp.size()==0){ 		ap.push_back(gp[0]); 		ap.push_back(gp[1]); 		printing(); 		done=true; 	}  	else if(temp.size()==1){ 		if(a[temp[0]]>gp[0]){ 			ap.push_back(gp[0]); 			ap.push_back(a[temp[0]]); 		} 		else{ 			ap.push_back(a[temp[0]]); 			ap.push_back(gp[0]); 		} 		printing(); 		done=true; 	}  	else if(temp.size()==2){ 		ap.push_back(a[temp[0]]); 		ap.push_back(a[temp[1]]); 		printing(); 		done=true; 	}  	else{ 		first=temp[0]; 		second=first+1; 		while(!done && second<=temp[1]){ 	//		printf("yes first=%d second = %d \n",first,second); 			ap.push_back(a[first]); 			ap.push_back(a[second]); 			d= a[second]-a[first]; 			next=a[second]+d; 			if(second==temp[1]) temp_count=2; 			else temp_count=1; 			for(i=second+1;i<n;i++){ 	//			printf(" i = %d\n",i); 				if(next>a[a.size()-1]) 					break; 				if(temp_count==l) 					break; 				else if(next==a[i] && i==temp[temp_count]){ 					temp_count++; 					ap.push_back(next); 					next+=d; 				} 				else if(i==temp[temp_count] && next!=a[i]) 					break; 				else if (a[i]==next){ 					ap.push_back(next); 					next+=d; 				} 			} 			if(temp_count==l){ 				done=true; 				printing(); 			} 			ap.clear(); 			second++; 		} 	} 	ap.clear(); 	gp.clear(); 	temp.clear(); 	return done; }    int main(){ 	int test; 	int n,i,num,d,next,sp,sq; 	scanf("%d",&test); 	while(test--){ 		a.clear(); 		ap.clear(); 		gp.clear(); 		temp.clear(); 		scanf("%d",&n); 		for(i=0;i<n;i++){ 			scanf("%d",&num); 			a.push_back(num); 		} 		/******************let first two terms make an AP************/  		ap.push_back(a[0]); 		ap.push_back(a[1]); 		d=a[1]-a[0]; 		next=a[1]+d; 		for(i=2;i<n;i++){ 			if(next==a[i]){ 				ap.push_back(next); 				next+=d; 			} 			else 				temp.push_back(i); 		}  		if(checkForGP(n))continue;  		/***************let first and third term be in an AP**********/ 		ap.push_back(a[0]); 		ap.push_back(a[2]); 		d=a[2]-a[0]; 		next=a[2]+d; 		temp.push_back(1); 		for(i=3;i<n;i++){ 			if(next==a[i]){ 				ap.push_back(next); 				next+=d; 			} 			else 				temp.push_back(i); 		} 		if(checkForGP(n))continue; 		/*********let second and third term form an AP******************/   		ap.push_back(a[1]); 		ap.push_back(a[2]); 		d=a[2]-a[1]; 		next=a[2]+d; 		temp.push_back(0); 		for(i=3;i<n;i++){ 			if(next==a[i]){ 				ap.push_back(next); 				next+=d; 			} 			else 				temp.push_back(i); 		} 		 		if(checkForGP(n))continue;  		/**********let first two term be in GP ***************/ 		gp.push_back(a[0]); 		gp.push_back(a[1]); 		sp=a[1]; 		sq=a[0]; 		next=process((double)(a[1]*1.0*sp/sq));  		for(i=2;i<n;i++){ 			if(next==a[i]){ 				gp.push_back(next); 				next=process((double)(next*1.0*sp/sq)); 			} 			else 				temp.push_back(i); 		}  		if(checkForAP(n))continue; 		 		/*********let second and third term be in GP**********/ 		gp.push_back(a[1]); 		gp.push_back(a[2]); 		temp.push_back(0);  		sp=a[2]; 		sq=a[1]; 		next=process((double)(a[2]*1.0*sp/sq)); 		for(i=3;i<n;i++){ 			if(next==a[i]){ 				gp.push_back(next); 				next=process((double)(next*1.0*sp/sq)); 			} 			else 				temp.push_back(i); 		} 		 		if(checkForAP(n))continue;  		/********let first and third be in GP*************/ 		gp.push_back(a[0]); 		gp.push_back(a[2]); 		temp.push_back(1);  		sp=a[2]; 		sq=a[0]; 		next=process((double)(a[2]*1.0*sp/sq)); 		for(i=3;i<n;i++){ 			if(next==a[i]){ 				gp.push_back(next); 				next=process((double)(next*1.0*sp/sq)); 			} 			else 				temp.push_back(i); 		} 		if(checkForAP(n))continue; 	} 	return 0; } 
/*  	C++ Template 	Gaurav Babbar */  #include<bits/stdc++.h> #define MOD 1000000007 #define MAX 100005 #define mp make_pair #define pb push_back #define gc getchar #define pc putchar #define ll long long #define llu unsigned long long  ll ABS(ll a){if(a>0) return a; else return (-1*a);} int gcd(int a,int b){if (b==0) return a;else return gcd(b,a%b);} llu power(llu b,llu exp,llu m) {llu ans=1; b%=m; while(exp){if(exp&1) ans=(ans*b)%m; exp>>=1; b=(b*b)%m; } return ans; }  using namespace std;  #define DisplayDebuggingInfo 0 #define debug(args...) {dbg,args; if(DisplayDebuggingInfo) cerr<<endl;} struct debugger {       template<typename T> debugger& operator,(const T& v)       {           if(DisplayDebuggingInfo)           {               cerr<< v <<" ";               return *this;           }       } }dbg;  inline void inp(ll &n) {   n = 0;   int ch = gc();   int sign = 1;   while(ch < '0' || ch > '9') {     if (ch == '-') sign = -1;     ch = gc();   }   while(ch >= '0' && ch <= '9')     n = (n<<3) + (n<<1) + ch - '0', ch = gc();   n = n*sign; }  inline void outp(ll a) {   char snum[25];   int i=0;   do   {     snum[i++]=a%10+48;     a=a/10;   } while(a!=0);   i=i-1;   while(i>=0)     pc(snum[i--]);   pc(' '); }  /* Main Code sarts here */  ll L,R,k,n; ll longestAP,temp,x;  void reset() { }  void input() {     inp(L);inp(R);inp(k);inp(n); }  void preprocess() {     longestAP = 1 + (R-L)/k;     x = longestAP-1;     temp = R - x*k; }  ll sum(ll a) {     // to calculate total sum pass a = L1     //to calculate sum from length2 to end pass L2     // count is summation 1 + floor[ R - (li + (longestAP-1)*k)]     ll ans = 0 ;     if(temp<a) return 0;     ll q = (temp-a)/x;     ll r = (temp-a)%x;     ans = q*(q-1)/2*x + (r+1)*q + (temp - a + 1);     return ans; }  ll getCeil(ll n) {     ll low = 1;     ll high = temp - L + 1;     while(low<=high)     {         ll mid = low + (high-low)/2;         ll upperSum = sum(L) - sum(L+mid);         if(n==upperSum) return mid;         if(n>upperSum)         {             low = mid+1;         }         else         {             high = mid - 1;         }     }     return low; }  void solve() {     ll totalSum = sum(L);     if(n>totalSum)     {         cout<<longestAP<<" 0 0\n";         return;     }     debug(totalSum);     ll sequenceNo = getCeil(n);     ll lengthSeq = sum(L+sequenceNo-1) - sum(L+sequenceNo);     n -= (sum(L) - sum(L+sequenceNo-1));     debug(sequenceNo,lengthSeq,n);     cout<<longestAP<<" "<<(L+sequenceNo-1)<<" "<<(L+sequenceNo-1 + k+n-1)<<endl; }  int main() { //   freopen("input.txt","r",stdin); //   freopen("output.txt","w",stdout);    ll t;    inp(t);    while(t--)    { 	   reset();        input();        preprocess(); 	   solve();    }    return 0; } 
#include<cstdio> #include<algorithm> using namespace std; int main() { 	int T,n,k,num[100],count[2],i; 	scanf("%d",&T); 	while(T--) 	{ 		count[0]=count[1]=0; 		scanf("%d %d",&n,&k); 		for(i=0;i<n;i++) 			scanf("%d",&num[i]); 		sort(num,num+n); 		if((num[1]-num[0])%(k+1)==0) 			count[1]=count[0]=1; 		i=1; 		if(i<n-1) 		{ 			do 			{ 				i++; 				if((num[i]-num[0])%(k+1)==0) 					count[0]++; 				if((num[i]-num[1])%(k+1)==0) 					count[1]++; 			} 			while(((i-count[0])<2 || (i-count[1])<2)&& (i<(n-1))); 		} 		if(count[0]>=n-2 || count[1]>=n-2) 			printf("YES\n"); 		else 			printf("NO\n"); 	} 	return 0; } 
#include<bits/stdc++.h> #define ll long long #define pr pair<ll,ll> #define mp make_pair using namespace std; vector<pair<pr,ll> > v; ll t,b,c,d; ll sum=0,p,q,r,i; ll binsear(ll l,ll r); ll bsearch(ll val) {     bool ctr=0;     ll j=0;     for(i=0;i<v.size();i++)     {     	//printf("val  = %lld\n",val);         if(v[i].second==-1)             val-=v[i].first.second;         else         {             if(val>=v[i].first.second)                 val+=v[i].second;         }         if(val<=0){//printf("break\n");         	ctr=1;break;}     }     if(ctr==0)     	return true;     else     	return false; } ll binsear(ll l,ll r) { 	ll mid,ans=r;     while(l<=r)     {     	mid=(l+r)/2;     	if(bsearch(mid))     	{     		//printf("%lld   yes\n",mid);     		ans=min(ans,mid);r=mid-1;     	}     	else     	{     	//printf("%lld  ashu\n",mid);     	l=mid+1;}     }     return ans; }  int main() {     scanf("%lld",&t);     while(t--)     {     	v.clear();     	sum=0;         scanf("%lld%lld",&d,&b);         for(i=0;i<b;i++)         {             scanf("%lld%lld",&p,&q);             sum+=q;             v.push_back(mp(mp(p,q),-1));         }         scanf("%lld",&c);         if(c==0){             printf("%lld\n",sum+1);continue;}         for(i=1;i<=c;i++)         {             scanf("%lld%lld%lld",&p,&q,&r);             v.push_back(mp(mp(p,q),r));         }         sort(v.begin(),v.end());         printf("%lld\n",binsear(1,sum+1));     }     return 0; } 
#include<iostream> using namespace std ; #define MAXN 1002 int dx[] = {-1,-1,-1,0,0,1,1,1} ; int dy[] = {-1,0,1,-1,1,-1,0,1} ;   int n,x,y,monsters[MAXN*MAXN][2] ; int start[2],finish[2] ; int nearest_monster[MAXN][MAXN],distances[MAXN][MAXN] ;   int q[2100002] ; void bfs1() {  int i,j,k,p = 0 ;    for(i=0;i<x;i++)   for(j=0;j<y;j++)    nearest_monster[i][j] = -1 ;  for(i=0;i<n;i++)  {   nearest_monster[monsters[i][0]][monsters[i][1]] = 0 ;   q[p++] = monsters[i][0] ;   q[p++] = monsters[i][1] ;  }  for(k=0;k<p;k+=2)  {   int cur_x = q[k],cur_y = q[k+1] ;   for(i=0;i<8;i++)   {    int nx = cur_x + dx[i],ny = cur_y + dy[i] ;    if(nx < 0 || ny < 0 || nx >= x || ny >= y || nearest_monster[nx][ny] != -1) continue ;    nearest_monster[nx][ny] = nearest_monster[cur_x][cur_y] + 1 ;    q[p++] = nx ; q[p++] = ny ;   }  } }   int bfs2(int upper) {  int i,j,k,p = 0 ;    for(i=0;i<x;i++)   for(j=0;j<y;j++)    distances[i][j] = -1 ;    if(nearest_monster[start[0]][start[1]] < upper) return -1 ;  distances[start[0]][start[1]] = 0 ;  q[p++] = start[0] ; q[p++] = start[1] ;  for(k=0;k<p;k+=2)  {   int cur_x = q[k] ;   int cur_y = q[k+1] ;      if(cur_x == finish[0] && cur_y == finish[1]) return distances[cur_x][cur_y] ;      for(i=0;i<8;i++)   {    int nx = cur_x + dx[i],ny = cur_y + dy[i] ;    if(nx < 0 || ny < 0 || nx >= x || ny >= y || nearest_monster[nx][ny] < upper) continue ;    if(distances[nx][ny] != -1) continue ;    distances[nx][ny] = distances[cur_x][cur_y] + 1 ;    q[p++] = nx ; q[p++] = ny ;   }  }  return -1 ; }     char buff[MAXN] ; main() {  int i,j,k ;    scanf("%d%d",&x,&y) ;  for(i=0;i<x;i++)  {   scanf("%s",buff) ;   for(j=0;j<y;j++)    if(buff[j] == '@')     start[0] = i,start[1] = j ;    else if(buff[j] == '$')     finish[0] = i,finish[1] = j ;    else if(buff[j] == 'D')    {     monsters[n][0] = i ;     monsters[n++][1] = j ;    }  }  bfs1() ;  int low = -1,high = 10000 ;  while(low + 1 < high)  {   int mid = low + (high - low)/2 ;   if(bfs2(mid) != -1) low = mid ;   else high = mid ;  }  printf("%d\n",low) ; }
/**  * ID: ping128  * LANG: C++  */  #include <stdio.h> #include <iostream> #include <sstream> #include <stdlib.h> #include <string> #include <vector> #include <set> #include <queue> #include <stack> #include <list> #include <math.h> #include <algorithm> #include <map> #include <string.h>  using namespace std;  typedef long long LL; typedef pair<int,int>PII; typedef pair<PII,int>PII2;  LL y, x1, x2; vector<LL> factors;  class Solve {  	LL cal(LL a) 	{ 		LL count = 0; 		int k = factors.size(); 		for(int i = 1; i < ( 1 << k ); i++ ) 		{ 			int sign = 1; 			int div = 1; 			for(int j = 0; j < k; j++ ) 			{ 				if(i & (1 << j)) 				{ 					sign *= -1; 					div *= factors[j]; 				} 			} 			 			count += sign * (a / div); 		} 		return a + count; 	} 	public: 	void main2(){  		cin >> y >> x1 >> x2; 		y = abs(y); 		factors.clear();  		if(y == 1) 		{ 			cout << x2 - x1 + 1 << endl; 		} 		else 		{ 			for(LL i = 2; i * i <= y; i++ ) 			{ 				if(y % i == 0) 				{ 					factors.push_back(i); 					while(y % i == 0) 					{ 						y /= i; 					} 				} 			} 			if(y > 1) 			{ 				factors.push_back(y); 			}  			if(x1 < 0 && x2 < 0) 			{ 				x1 *= -1; 				x2 *= -1; 				swap(x1, x2); 			}  			if(x1 < 0) 			{ 				cout << cal(abs(x1)) + cal(abs(x2)) << endl; 			} 			else 			{ 				cout << cal(x2) - cal(max(x1 - 1, 0LL)) << endl; 			} 		} 		 	} };  int main(){ 	 	// freopen(".in", "r", stdin); 	// freopen(".out", "w", stdout); 	 	int Test; 	scanf("%d",&Test); 	for(int t=1;t<=Test;t++){ 		Solve ___test; 		___test.main2(); 	} 	 return 0; } 
#include<iostream> #include<deque> using namespace std; int main(){ 	int n,k,a[1000][1000],i,j; 	cin>>n>>k; 	for(i=0;i<n;i++) 		for(j=0;j<n;j++) 			cin>>a[i][j];  	for(i=0;i<n;i++) 	{ 		deque<int> q; 		for(j=0;j<k-1;j++) 		{ 		while(!q.empty() && q.back()>a[i][j]) 			q.pop_back(); 		q.push_back(a[i][j]); 		} 		for(j=k-1;j<n;j++) 		{ 			while(!q.empty() && q.back()>a[i][j]) 				q.pop_back(); 			q.push_back(a[i][j]); 			int temp=a[i][j-k+1]; 			a[i][j-k+1]=q.front(); 			if(temp==q.front()) 				q.pop_front(); 		} 	}  	for(i=0;i<n;i++) 	{ 		deque<int> q; 		for(j=0;j<k-1;j++) 		{ 		while(!q.empty() && q.back()>a[j][i]) 			q.pop_back(); 		q.push_back(a[j][i]); 		} 		for(j=k-1;j<n;j++) 		{ 			while(!q.empty() && q.back()>a[j][i]) 				q.pop_back(); 			q.push_back(a[j][i]); 			int temp=a[j-k+1][i]; 			a[j-k+1][i]=q.front(); 			if(temp==q.front()) 				q.pop_front(); 		} 	}  	for(i=0;i<n-k+1;i++) 	{ 		for(j=0;j<n-k+1;j++) 			cout<<a[i][j]<<" "; 		cout<<"\n"; 	} 	return 0; }
#include <stdio.h> #include <string.h>   const char INPUT = 'I'; const char QUERY = 'Q';   const int QALL = -1;   const char NG = '-'; const char PT = '.';   const char SPC = ' ';   const char M = 'M'; const char F = 'F';   int us[11][4][11][21][6][2][91];   int fb(int prod, int size, int prov, int city, int reg, int mf, int sa, int ea) { int* tus; tus = us[prod][size][prov][city][reg][mf]; if (ea == 0) return tus[sa];   int u = 0; for (int a = sa; a <= ea; ++a) u += tus[a]; return u; }   void fc(int prod, int size, int prov, int city, int reg, int mf, int age, int unts) { us[0][0][0][0][0][mf][age] += unts;   us[0][0][prov][city][reg][mf][age] += unts; if (reg != 0) us[0][0][prov][city][0][mf][age] += unts; if (city != 0) us[0][0][prov][0][0][mf][age] += unts;   us[prod][size][0][0][0][mf][age] += unts; if (size != 0) us[prod][0][0][0][0][mf][age] += unts;   if (size != 0) { us[prod][0][prov][city][reg][mf][age] += unts; if (reg != 0) us[prod][0][prov][city][0][mf][age] += unts; if (city != 0) us[prod][0][prov][0][0][mf][age] += unts; }   if (reg != 0) us[prod][size][prov][city][0][mf][age] += unts; if (city != 0) us[prod][size][prov][0][0][mf][age] += unts; }   void fa() { int s = 0; scanf("%d", &s); char iq, mfc; while (s--) { int prod = -1, size = -1, prov = -1, city = -1, reg = -1, mf = 0; scanf("\n%c", &iq); scanf(" %2d.%1d", &prod, &size); prod++; size++; scanf(" %2d.%2d.%1d", &prov, &city, &reg); prov++; city++; reg++; scanf(" %c", &mfc);   mf = (mfc == M ? 0 : 1);   if (iq == INPUT) { int age = 0, unts = 0; scanf(" %d %d", &age, &unts); us[prod][size][prov][city][reg][mf][age] += unts; fc(prod, size, prov, city, reg, mf, age, unts); } else { int sa = 0, ea = 0; scanf(" %2d-%2d", &sa, &ea);   int u = fb(prod, size, prov, city, reg, mf, sa, ea); printf("%d\n", u); } } }   int main() { fa(); return 0; }
/* CPP Tempelate  * @author Devashish Tyagi  */  #include <algorithm> #include <cctype> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <iostream> #include <map> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #include <list> #include <bitset>  #define sf(a) scanf("%d",&a) #define ssf(a,b) scanf("%d %d",&a,&b) #define pf(a) printf("%d\n",a) #define tr(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) #define pi pair<int,int> #define vi vector<int> #define all(v) v.begin(),v.end()  #define PB push_back #define MP make_pair #define sz(a) (int)(a).size()  #define FOR(i,a,b) for(int (i) = (a); (i) < (b); ++(i))   #define RFOR(i,a,b) for(int (i) = (a)-1; (i) >= (b); --(i))   #define CLEAR(a) memset((a),0,sizeof(a))  #define INF 1000000000 #define MAXN 20001 #define PI 2*acos(0.0)  using namespace std; typedef long long ll;  string convertInt(int number) {    stringstream ss;//create a stringstream    ss << number;//add number to the stream    return ss.str();//return a string with the contents of the stream }  int convertString(string s){     int num;     stringstream sstr(s); // create a stringstream     sstr>>num; // push the stream into the num     return num; }  int modulo (int m, int n) { return m >= 0 ? m % n : ( n - abs ( m%n ) ) % n; }  int graph[2][MAXN]; int color[MAXN];  void dfs(int n, int c){     if (n == -1 || color[n] != -1) return;          color[n] = c;     int next = (c+1)%2;     dfs(graph[0][n], next);     dfs(graph[1][n], next);          return; }  int main(void){     int t;     sf(t);     while(t--){ 	int n; 	vector<int> perm[2]; 	sf(n); 	 	for(int i=0; i<n; i++){ 	    int x; 	    sf(x); 	    perm[0].PB(x); 	    graph[0][i] = -1; 	} 	for(int i=0; i<n; i++){ 	    int x; 	    sf(x); 	    perm[1].PB(x); 	    graph[1][i] = -1; 	} 	 	for(int i=0; i+1<n; i=i+2){ 	    graph[0][perm[0][i]]=perm[0][i+1]; 	    graph[0][perm[0][i+1]]=perm[0][i]; 	    graph[1][perm[1][i]]=perm[1][i+1]; 	    graph[1][perm[1][i+1]]=perm[1][i]; 	} 	 	// BFS coloring 	/* 	queue< pair<int,char> > Q; 	for(int i=0;i<n; i++){ 	    if (color[i] == 'a'){ 		Q.push(MP(i,'A')); 		color[i] = 'A'; 		while(!Q.empty()){ 		    int v = Q.front().first; 		    char c = Q.front().second; 		    Q.pop(); 		    char next = c == 'A'?'B':'A'; 		    for(int j=0; j<graph[i].size(); j++){ 			int to = graph[i][j]; 			if (color[to] == 'a'){ 			    color[to] = next; 			    Q.push(MP(to,next)); 			}  		    } 		} 	    } 	}*/ 	 	//DFS coloring 	memset(color, -1, sizeof color); 	for(int i=0; i<n; i++){ 	    if (color[i] == -1) 		dfs(i, 0); 	} 	 	for(int i=0; i<n; i++){ 	    if (color[i] == 0) 		printf("%c",'A'); 	    else 		printf("%c",'B'); 	} 	printf("\n");     }     return 0; }  
#include <iostream> #include <cstdio> #include <cstring> #include <algorithm> using namespace std; const int N = 2300010; int pri[N],fac[N]; long long f[N];  void prime() { 	memset(pri,-1,sizeof(pri)); 	for(int i = 2; i < N; i ++) { 		if(pri[i] == -1) { 			pri[i] = i; 			if(i >= 4000) continue; 			for(int j = i * i; j < N; j += i) 				pri[j] = i; 		} 	} }  int cal(int n) { 	int ans = 1,tmp = n; 	while(pri[n] != -1) { 		int x = n,cnt = 1; 		while(n % pri[x] == 0) n /= pri[x],cnt ++; 		ans = fac[n] * cnt; 		break; 	} 	return fac[tmp] = ans; } int main() { 	fac[1] = 1; 	fac[2] = 2; 	prime(); 	long long mod = 500009; 	f[2] = 1; 	int d[2010]; 	memset(d,0,sizeof(d)); 	d[2] = 1; 	for(int i = 3; i < N; i ++) { 		int x= cal(i); 		d[x] ++; 		f[i] = f[i - 1] * d[x] % mod; 	} 	int n,t; 	scanf("%d",&t); 	while(t --) { 		scanf("%d",&n); 		if(n >= N || f[n] == 0) printf("%lld\n",mod - 1); 		else printf("%lld\n",f[n] - 1); 	} 	return 0; } 	 
#include <iostream> #include <cstdio> #include <cstring> #include <set> using namespace std; set<int> st; int main() { 	st.clear(); 	set<int>::iterator it; 	int n,mod,m,x; 	int sum = 0; 	scanf("%d%d%d",&n,&m,&mod); 	int ans = mod; 	st.insert(0); 	for(int i = 1; i <= n; i ++) { 	       scanf("%d",&x); 	       sum = (sum + x) % mod; 		       it = st.upper_bound(sum - m); 		       if(it != st.begin() && sum >= m) { 			       it --; 			       if((*it) <= sum - m) ans = min(ans,sum - (*it)); 		       } 		       it = st.upper_bound(sum + mod - m); 		       if(it != st.begin() && sum < m) { 			       it --; 			       if((*it) > sum && sum - (*it) + mod >= m) 			       		ans = min(ans,sum - (*it) + mod); 		       }  	       st.insert(sum); 	} 	printf("%d\n",ans); 	return 0; } 
#include<bits/stdc++.h>  using namespace std;  #define F first #define S second #define MP make_pair #define PB push_back #define MAXN 102 #define MAXN2 202 #define LL long long int  LL INF; LL com[MAXN2][MAXN2]; int r, c, i; LL g, x; vector<LL> ans;  inline void solve(){     scanf("%d", &r);     scanf("%d", &c);     scanf("%lld", &g);     if(c < 3){         if(g > 100000){             exit(1);         }     }     if(c == 1){         if(g >= MAXN){             exit(1);         }     }     ans.clear();     for(i = c; i >= 0; i--){         if(g == 0){             break;         }         for(r = i; r < MAXN; r++){             if(g < com[r][i]){                 break;             }         }         g -= com[r - 1][i];         ans.PB(com[r - 1][i]);     }     if(g != 0){         exit(1);     }     printf("%d\n", ans.size());     for(i = 0; i < ans.size(); i++){         printf("%lld", ans[i]);         printf((i == ans.size() - 1 ? "\n" : " "));     } }  inline void pre(){     int i, j;     com[0][0] = 1;     INF = 100000;     INF *= 100000;     INF *= 100000;     for(i = 1; i < MAXN2; i++){         com[i][0] = 1;         com[i][i] = 1;         for(j = 1; j < i; j++){             com[i][j] = com[i - 1][j - 1] + com[i - 1][j];             if(com[i][j] >= INF){                 com[i][j] = INF;             }         }     } }  int main(){     pre();     int t = 1;     cin>>t;     for(int i = 0; i < t; i++){         solve();     }     return 0; } 
#include <cstdio> #include <cmath> #include <cstring> #include <iostream> #include <algorithm> #include <vector> #include <string> #include <map> #include <queue> #include <set> #include <cassert>  using namespace std;  #define _ ios_base::sync_with_stdio(0);cin.tie(0); #define S(x) 			scanf("%d",&x) #define SS(x,y)         scanf("%d%d",&x,&y) #define all(c) 			(c).begin(),(c).end()  #define sz(c) 			int((c).size()) #define pb 				push_back #define present(c,x) 	((c).find(x) != (c).end())  #define rep(i,x,y) 		for(int i = x; i <= y; i++) #define REV(i,x,y) 		for(int i = x; i >= y; i--) #define foreach(c,itr)	for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++) #define FILL(a,v) 		memset(a,v,sizeof(a)) #define DB(x)			cerr<<#x<<" = "<<x<<endl #define debugarr(A,a,b) cerr<<#A<<" : ";rep(i,a,b) cerr<<A[i]<<" ";cerr<<endl; //#define R(x) 			((rand()%x) + 1)  typedef long long int LL; typedef vector<int> vi;  typedef vector<vi> vvi;  typedef pair<int,int> ii; typedef vector<ii> vii;  /* ------------------------Main Code----------------------- */ const int MAX = 100001;  vi ls, rs; bool check(int x, int y, int n) { 	int tr = x, tmp = y; 	REV(i,sz(rs)-1,0){ 		int l = tmp<<1, r = l | 1; 		if(rs[i] == l){ 			tr <<= 1;  		}else{ 			tr <<= 1; 			tr |= 1; 		} 		tmp = rs[i]; 		if(tr > n) return false; 	}	 	tmp = y; tr = x; 	REV(i,sz(ls)-1,0){ 		int l = tmp<<1, r = l | 1; 		if(ls[i] == l){ 			tr <<= 1;  		}else{ 			tr <<= 1; 			tr |= 1; 		} 		tmp = ls[i]; 		if(tr > n) return false; 	} 	return true; }  int BS(int n, int v) { 	int lo = 1, hi = n; 	while(lo < hi){ 		int mid = lo + ((hi-lo+1)>>1); 		if(check(mid,v,n)) lo = mid; 		else hi = mid - 1; 	} 	return lo; }  int lca(int l, int r) { 	while(l != r){ 		if(l > r) l >>= 1; 		else r >>= 1; 	} 	return l; }  int main() { 	int q; 	S(q); 	while(q--){ 		int n, l, r; 		S(n); SS(l,r); 		int parent = lca(l,r); 		int tl = l, tr = r; 		ls.clear(); rs.clear(); 		while(tl != parent){ 			ls.pb(tl); 			tl >>= 1; 		} 		while(tr != parent){ 			rs.pb(tr); 			tr >>= 1; 		} 		printf("%d\n",BS(n,parent)); 	} 	return 0; }
#include <stdlib.h> #include <iostream>  #define IND(x,y) ((x)*m_M+(y)) #define GIND(x,y,z) (((x)*m_M+(y))*8+(z))  using namespace std;  struct IndexParam { 	int ind; 	int length; };  class PoolSolver { private: 	char m_N; 	char m_M; 	char* m_Islands; 	 	char m_SX , m_SY; 	char m_FX , m_FY;    	char m_NextSteps[16];  	char m_CurrentX; 	char m_CurrentY;     	int* m_Results;  	IndexParam* m_IndexParams;  	int m_NumIndexParams;  	int* m_NodeIndex;   public: 	  	PoolSolver(char n , char m , char* islands , char sx , char sy , char fx , char fy) 	{ 		 		//{-2,0 , -1,0 , 1,0 , 2,0 , 0,-2 , 0,-1 , 0,1 , 0,2}; 		m_NextSteps[0] = -2; 		m_NextSteps[1] = 0; 		m_NextSteps[2] = -1; 		m_NextSteps[3] = -0; 		m_NextSteps[4] = 1; 		m_NextSteps[5] = 0; 		m_NextSteps[6] = 2; 		m_NextSteps[7] = 0; 		m_NextSteps[8] = 0; 		m_NextSteps[9] = -2; 		m_NextSteps[10] = 0; 		m_NextSteps[11] = -1; 		m_NextSteps[12] = 0; 		m_NextSteps[13] = 1; 		m_NextSteps[14] = 0; 		m_NextSteps[15] = 2;    		m_N = n; 		m_M = m; 		m_SX = sx; 		m_SY = sy; 		m_FX = fx; 		m_FY = fy;  		m_Islands = new char[m_N * m_M];  		for(char i = 0 ; i < m_N * m_M ; i++) 			m_Islands[i] = islands[i];    	}     	unsigned int Solve() 	{    		int NumNonZeroNodes = 0;  		int num_states = 1;  		  		for(int x = 0 ; x < m_N ; x++) 			for(int y = 0 ; y < m_M ; y++) 			{  				num_states = num_states * (this->m_Islands[IND(x,y)] + 1);  				if(this->m_Islands[IND(x,y)] != 0) 					NumNonZeroNodes++;  				 			}  			m_NodeIndex = new int[m_N * m_M];  		int index_index = 0; 		 		m_NumIndexParams = NumNonZeroNodes + 1; 		m_IndexParams = new IndexParam[m_NumIndexParams];  		for(int x = 0 ; x < m_N ; x++) 			for(int y = 0 ; y < m_M ; y++) 			{  				if(this->m_Islands[IND(x,y)] != 0) 				{ 					m_IndexParams[index_index].ind = IND(x,y); 					 					if(index_index != 0) 						m_IndexParams[index_index-1].length = this->m_Islands[IND(x,y)] + 1;  					m_NodeIndex[IND(x,y)] = index_index;  					index_index++; 				}  				 			}  		m_IndexParams[index_index-1].length = NumNonZeroNodes;   		num_states = num_states * NumNonZeroNodes;  		m_Results = new int[num_states];  		for(int i = 0 ; i < num_states ; i++) 			m_Results[i] = -1;  		m_CurrentX = m_SX; 		m_CurrentY = m_SY;  		 		unsigned int result = SolveSUB();   		delete[] m_Results; 		 		delete[] m_IndexParams;  		delete[] m_NodeIndex; 		return result; 	}  	int GetIndex() 	{ 		int res =  m_Islands[ this->m_IndexParams[0].ind]; 		int i = 1; 		for(; i < m_NumIndexParams - 1 ; i++) 		{ 			int len = this->m_IndexParams[i-1].length; 			int v = m_Islands[ this->m_IndexParams[i].ind];  			res = res * len + v; 		}  		res = res * this->m_IndexParams[i-1].length  + m_NodeIndex[IND(m_CurrentX , m_CurrentY)];  		return res; 	} 	   	bool IsSolved() 	{ 		if(m_CurrentX != m_FX) 			return false; 		if(m_CurrentY != m_FY) 			return false;  		for(int x = 0 ; x < m_N ; x++) 		{ 			for(int y = 0 ; y < m_M ; y++) 			{ 				if(x == m_FX && y == m_FY) 				{ 					if(m_Islands[IND(x,y)] != 1) 						return false; 				} 				else 				{ 					if(m_Islands[IND(x,y)] != 0) 						return false; 				}  			}  		}  		return true; 	}  	unsigned int SolveSUB() 	{ 		int index = GetIndex();  		if(m_Results[index] != -1) 			return m_Results[index];  		unsigned int possible_paths = 0;  		for(int i = 0 ; i < 8 ; i++) 		{ 			char new_x = m_CurrentX + m_NextSteps[2 * i]; 			char new_y = m_CurrentY + m_NextSteps[2 * i + 1];  			if(new_x < 0 || new_x >= m_N) 				continue; 			if(new_y < 0 || new_y >= m_M) 				continue;  			 			char* dest_island = &(m_Islands[IND(new_x,new_y)]); 			  			if((*dest_island) == 0) 				continue;  			char ind = IND(m_CurrentX,m_CurrentY);  			char* src_island = &(m_Islands[ind]);  			//jump    			(*src_island)--; 			 			 	  			  			char prevX = m_CurrentX; 			char prevY = m_CurrentY;  			m_CurrentX = new_x; 			m_CurrentY = new_y;     			if(IsSolved()) 			{ 				possible_paths++;   			} 			else 			{  					possible_paths+= SolveSUB(); 					  			}   			m_CurrentX = prevX; 			m_CurrentY = prevY;  			//undo jump 			(*src_island)++; 			 			   		}  		 		m_Results[index] = possible_paths;  		return possible_paths; 	}  	  };   int main() {  	int i_num_cases;  	char num_cases;  	cin>>i_num_cases;  	 	num_cases = i_num_cases;  	for(int i = 0 ; i < num_cases ; i++) 	{  		char N; 		char M;  		int iN; 		int iM;  		cin>>iN; 		cin>>iM;  		N = iN; 		M = iM;  		int isx , isy , ifx , ify;  		char sx , sy , fx , fy;  		cin>>isx; 		cin>>isy; 		cin>>ifx; 		cin>>ify;  		sx = isx; 		sy = isy; 		fx = ifx; 		fy = ify;   		sx--; 		sy--; 		fx--; 		fy--;  		char* islands = new char[N * M];  		for(int j = 0 ; j < N * M ; j++) 		{ 			int island; 			cin>>island;  			islands[j] = island; 		}  		PoolSolver solver(N , M , islands , sx , sy , fx ,fy);   		unsigned int total_ways = solver.Solve();   		delete[] islands;  		cout<<total_ways<<endl; 	}  	  	return 0; }
#include <cstdio> #include <cstring> #include <cmath> #include <algorithm> #include <iostream> using namespace std; const int N = 100; int t[N][N], rank[N][N], ship[N], f[N], h[N], p[N]; bool cmp (const int &i, const int &j) {return ship[i] < ship[j];} int main() {     int i, j, n, hid;     while (scanf ("%d", &n) == 1)     {         for (i = 0; i < n; i ++)         {             for (j = 0; j < n; j ++)             {                 scanf ("%d", ship + j);                 t[i][j] = ship[j];                 rank[i][j] = j;             }             sort (rank[i], rank[i] + n, cmp);         }         memset (f, -1, sizeof f);         memset (h, -1, sizeof h);         memset (p, 0, sizeof p);         int cnt = 0;         while (cnt < n)         {             for (i = 0; i < n; i ++)             while (f[i] < 0)             {                 hid = rank[i][p[i] ++];                 if (h[hid] < 0) h[f[i] = hid] = i, cnt ++;                 else if (t[i][hid] > t[h[hid]][hid])                 {f[h[hid]] = -1; h[f[i] = hid] = i;}             }         }         for (i = 0; i < n; i ++) printf ("%d ", f[i] + 1);         puts ("");     }     return 0; } 
#include<iostream> #include<cstdio> #include<cstring> #include<map> using namespace std;   long long cnt; map<long long,long long>hash; long long c[1000000]; void ins(long long x,long long y) {  hash[x]=cnt;  c[cnt]=y;  cnt++; }    int main() {     bool a[50][50],b[50][50];     int i,j,k,p1[6],p2[6],n,m,sx,sy,q,cross,x,f,row[50],col[50];     long long t,ans,temp,ab,cd,pre,ii,period,start;     char d1[]="ULURDL",d2[]="DRRDLU";     scanf("%d %d %d",&n,&m,&q);     scanf("%d %d",&sx,&sy);     for(i=0;i<6;i++)     scanf("%d %d",p1+i,p2+i);          cnt=0;          memset(a,0,sizeof a);     a[sx][sy]=1;          ans=0LL;f=1;     for(i=1;i<=n;i++)     for(j=1;j<=m;j++)     {ans=(ans<<1)|a[i][j];}     ins(ans,1LL);          while(1)     {               memset(row,0,sizeof row);               memset(col,0,sizeof col);                                     for(i=1;i<=n;i++)               for(j=1;j<=m;j++)               {b[i][j]=a[i][j];row[i]+=b[i][j];col[j]+=b[i][j];}                              for(i=1;i<=n;i++)               for(j=1;j<=m;j++)               if(a[i][j])               {                          /*for(k=cross=0;k<=n;k++)                          cross+=a[k][j];                                                    for(k=0;k<=m;k++)                          cross+=a[i][k];                          */                          cross=row[i]+col[j]-1;                          //cross-=1;                                                    x=cross%6;                                                    switch(d1[x])                          {                                       case 'U':for(k=i-p1[x];k>=0;k-=p1[x])                                                b[k][j]=!b[k][j];                                                break;                                       case 'D':for(k=i+p1[x];k<=n;k+=p1[x])                                                b[k][j]=!b[k][j];                                                break;                                       case 'L':for(k=j-p1[x];k>=0;k-=p1[x])                                                b[i][k]=!b[i][k];                                                break;                                       case 'R':for(k=j+p1[x];k<=m;k+=p1[x])                                                b[i][k]=!b[i][k];                                                break;                          }                                                                              switch(d2[x])                          {                                       case 'U':for(k=i-p2[x];k>=0;k-=p2[x])                                                b[k][j]=!b[k][j];                                                break;                                       case 'D':for(k=i+p2[x];k<=n;k+=p2[x])                                                b[k][j]=!b[k][j];                                                break;                                       case 'L':for(k=j-p2[x];k>=0;k-=p2[x])                                                b[i][k]=!b[i][k];                                                break;                                       case 'R':for(k=j+p2[x];k<=m;k+=p2[x])                                                b[i][k]=!b[i][k];                                                break;                          }               }          ans=0LL;f=0;     for(i=1;i<=n;i++)     for(j=1;j<=m;j++)     {a[i][j]=b[i][j];ans=(ans<<1)|a[i][j];f+=a[i][j];}          if(hash[ans]==0LL)     {ins(ans,(long long)f);}     else {break;}     }          ab=hash[ans];     period=cnt-ab;     start=ab;     temp=0LL;     for(ii=start;ii<cnt;ii++)     {temp+=c[ii];c[ii]=temp;}          pre=0LL;     for(ii=0;ii<start;ii++)     {     pre+=c[ii];     c[ii]=pre;     } //printf("%lld %lld\n",start,period);     while(q--)     {               scanf("%lld",&t);               ans=0LL;               if(t<start)               {ans=c[t];}                              else               {                  ab=(t-start+1LL)/period;                  cd=temp*ab;                  ans=cd+pre;                                    ab=start-1LL+(t-start+1LL)%period;                  if(ab>=start)                  ans+=c[ab];               }               printf("%lld\n",ans);               }      //    system("pause");     return 0; } 
/* CPP Tempelate  * @author Devashish Tyagi  */  #include <algorithm> #include <cctype> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <iostream> #include <map> #include <queue> #include <set> #include <sstream> #include <stack> #include <string> #include <vector> #include <list> #include <bitset>  #define sf(a) scanf("%d",&a) #define ssf(a,b) scanf("%d %d",&a,&b) #define pf(a) printf("%d\n",a) #define tr(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) #define pi pair<int,int> #define vi vector<int> #define all(v) v.begin(),v.end()  #define PB push_back #define MP make_pair #define sz(a) (int)(a).size()  #define FOR(i,a,b) for(int (i) = (a); (i) < (b); ++(i))   #define RFOR(i,a,b) for(int (i) = (a)-1; (i) >= (b); --(i))   #define CLEAR(a) memset((a),0,sizeof(a))  #define INF 1000000000 #define PI 2*acos(0.0) #define LOGSZ 18 #define MAXN 250005  using namespace std; typedef long long ll;  int tree[(1<<LOGSZ)+1]; int N = (1<<LOGSZ); vector< pair<int,int> > querypts; char opt[MAXN]; int a[MAXN], b[MAXN], mapvalue[MAXN], defence[MAXN];  // add v to value at x void update(int x, int v) {   while(x <= N) {     tree[x] += v;     x += (x & -x);   } }  // get cumulative sum up to and including x int get(int x) {   int res = 0;   while(x) {     res += tree[x];     x -= (x & -x);   }   return res; }  int getleft(int x){     int id = (int)(lower_bound(querypts.begin(),querypts.end(),make_pair(x,0)) - querypts.begin());     return mapvalue[querypts[id].second]; }  int getright(int x){     int id = (int)(upper_bound(querypts.begin(),querypts.end(),make_pair(x,999999)) - querypts.begin())-1;     return mapvalue[querypts[id].second]; }  int main(void){     int n,m;     scanf("%d %d",&n,&m);          CLEAR(tree);          // Get queries     int q = 0;     int p = 0;     querypts.push_back(make_pair(-1,q++));     querypts.push_back(make_pair(2000000000,q++));     for(int i=0; i<m; i++){ 	char cmd[4]; 	scanf("%s",cmd); 	opt[i] = cmd[0]; 	if (opt[i] == 'B'){ 	    sf(a[i]); 	    querypts.push_back(make_pair(a[i],q)); 	    b[i] = q++; 	} 	else{ 	    sf(a[i]); sf(b[i]); 	    if (opt[i] == 'P') 		defence[p++] = i; 	}     }          // Discretize the space     sort(querypts.begin(), querypts.end());     int id = 0;     for(int i=0; i<q; i++){ 	if (i != 0 && querypts[i-1].first != querypts[i].first) 	    id++; 	mapvalue[querypts[i].second] = id;     }          // Process the queries and answer them     for(int i=0; i<m; i++){ 	if (opt[i] == 'B'){ 	    printf("%d\n",get(mapvalue[b[i]])); 	} 	else if (opt[i] == 'P'){ 	    int left = getleft(a[i]); 	    int right = getright(b[i]); 	    update(left, 1); 	    update(right+1, -1); 	} 	else{ 	    int index = defence[a[i]-1]; 	    int l1 = getleft(a[index]); 	    int r1 = getright(b[index]); 	    int l2 = getleft(a[index]+b[i]); 	    int r2 = getright(b[index]+b[i]); 	    update(l1,-1); 	    update(l2,1); 	    update(r1+1,1); 	    update(r2+1,-1); 	    a[index] += b[i]; 	    b[index] += b[i]; 	}     }          return 0; }  
#include<iostream> #include<stdio.h> #include<assert.h> #include<string.h> #include<time.h> #include<stdlib.h> #include<math.h> #include<string> #include<sstream> #include<map> #include<set> #include<queue> #include<stack> #include<vector> #include<algorithm> #pragma comment(linker, "/STACK:16777216") #define pb push_back #define ppb pop_back #define mp make_pair #define all(x) (x).begin(),(x).end() #define sz(x) (int)(x).size() #define LL long long #define bit __builtin_popcountll #define sqr(x) (x) * (x) using namespace std; typedef pair<int, int> pii; const double eps = 1e-9; const double pi = acos(-1.0); LL a[2222][2222]; int main() { 	//#ifndef ONLINE_JUDGE 	//freopen("input.txt","r",stdin); 	//freopen("output.txt","w",stdout); 	//#endif 	int w,h,d,n,x,y,z; 	scanf("%d%d%d%d",&w,&h,&d,&n); 	for(int i = 0; i < n; i++) 	{ 		scanf("%d%d%d",&x,&y,&z); 		int dx = x + h - y; 		int dy = x + y; 		a[dx][dy] = a[dx][dy] + z; 	} 	for(int i = 0; i <= w + h; i++) 		for(int j = 0; j <= w + h; j++) 		{ 			if (i > 0) a[i][j] += a[i - 1][j]; 			if (j > 0) a[i][j] += a[i][j - 1]; 			if (i > 0 && j > 0) a[i][j] -= a[i - 1][j - 1]; 		} 	LL ans = (LL)1e18; 	for(int i = d; i <= w - d; i++) 		for(int j = d; j <= h - d; j++) 		{ 			int x = i + h - j; 			int y = i + j; 			LL cur = a[x + d][y + d]; 			if (y - d - 1 >= 0) cur -= a[x + d][y - d - 1]; 			if (x - d - 1 >= 0) cur -= a[x - d - 1][y + d]; 			if (y - d - 1 >= 0 && x - d - 1 >= 0) cur += a[x - d - 1][y - d - 1]; 			if (cur < ans) ans = cur; 		} 	cout<<ans<<endl; 	return 0; } 
#include<stdio.h> #include<stdlib.h>   inline int inp( ) { int n=0; int ch=getchar_unlocked(); while(!(ch >= '0' && ch <= '9') )ch=getchar_unlocked(); while( ch >= '0' && ch <= '9' ) n = (n<<3)+(n<<1) + ch-'0', ch=getchar_unlocked(); return n; }         int ain[1001][1001];     int aout[1001][1001];     int xop[1001][1001];     int r[1001],c[1001];   int main() {     int test;     int n;     int i,j;     int row_count,col_count;     scanf("%d",&test);     while(test--)     {         row_count=col_count=0;         n=inp();         for(i=0;i<n;i++)             for(j=0;j<n;j++)                 ain[i][j]=inp();         for(i=0;i<n;i++)             for(j=0;j<n;j++)                 {                     aout[i][j]=inp();                     xop[i][j]=ain[i][j]^aout[i][j];                 }         for(i=0;i<n;i++)             r[i]=c[i]=0;         if(xop[0][0])         {             for(i=0;i<n;i++)             {                 if(xop[i][0]==1)                     {                         r[i]=1;                         row_count++;                     }             }             for(j=0;j<n;j++)             {                 if(xop[0][j]==0)                 {                     c[j]=1;                     col_count++;                 }             }         }         else         {             for(i=0;i<n;i++)             {                 if(xop[i][0]==1)                     {                         r[i]=1;                         row_count++;                     }             }             for(j=0;j<n;j++)             {                 if(xop[0][j]==1)                 {                     c[j]=1;                     col_count++;                 }             }           }         int temp=row_count+col_count;         if(temp>=n)         {             for(i=0;i<n;i++)             {                 r[i]=r[i]^1;                 c[i]=c[i]^1;             }             row_count=n-row_count;             col_count=n-col_count;         }         for(i=0;i<n;i++)         {             for(j=0;j<n;j++)             {                 if(r[i]^c[j])                     ain[i][j]^=1;             }         }         int flag=0;         for(i=0;i<n;i++)         {             for(j=0;j<n;j++)             {                 if(ain[i][j]!=aout[i][j])                 {                     flag=1;                     break;                 }             }         }         if(!flag)         {             if(!(row_count||col_count))                 printf("0\n");             else{             printf("%d\n",row_count);             for(i=0;i<n;i++)                 if(r[i])                     printf("%d\n",i);             printf("%d\n",col_count);             for(i=0;i<n;i++)                 if(c[i])                     printf("%d\n",i);}         }         else             printf("-1\n");         }     return 0; }
#include <cstdio> #include <cstdlib> #include <cstring> #include <cmath> #include <cassert> #include <iostream> #include <sstream> #include <string> #include <vector> #include <queue> #include <set> #include <map> #include <utility> #include <numeric> #include <algorithm> #include <bitset> #include <complex>   using namespace std;   typedef unsigned uint; typedef long long Int; typedef vector<int> vint; typedef pair<int,int> pint; #define mp make_pair   template<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << " "; cout << endl; } template<class T> void chmin(T &t, T f) { if (t > f) t = f; } template<class T> void chmax(T &t, T f) { if (t < f) t = f; } int in() { int x; scanf("%d", &x); return x; }   const Int INF = 1001001001001001001LL;   int N, M, K; Int A[50010];   int cnt[110]; Int dp[110][110];   int main() { int i; int u; int x, y; for (int TC = in(); TC--; ) { N = in(); M = in(); K = in(); for (i = 0; i < N; ++i) { A[i] = in(); } sort(A, A + N); Int ASum = accumulate(A, A + M, 0LL); int lim = K * 2; memset(dp, 0x3f, sizeof(dp)); dp[0][(int)(ASum % K)] = ASum; // minus memset(cnt, 0, K << 2); for (i = M; i--; ) { u = (int)((-A[i] % K + K) % K); if (++cnt[u] <= lim) { for (x = lim - 1; x >= 0; --x) for (y = 0; y < K; ++y) { chmin(dp[x + 1][(y + u) % K], dp[x][y] - A[i]); } } } // plus memset(cnt, 0, K << 2); for (i = M; i < N; ++i) { u = (int)((+A[i] % K + K) % K); if (++cnt[u] <= lim) { for (x = 1; x <= lim; ++x) for (y = 0; y < K; ++y) { chmin(dp[x - 1][(y + u) % K], dp[x][y] + A[i]); } } } Int ans = dp[0][0]; if (ans >= INF) ans = -1; printf("%lld\n", ans); } return 0; }
    #include <iostream>           #include <stdio.h>           using namespace std;                       long long scache[200][200];           long long mod;           long long strl(int n, int k)           {           if (scache[n][k]!=-1)           return scache[n][k];           if (n==0 && k==0)           return 1;           if (n==0 || k==0)           return 0;           scache[n][k]=strl(n - 1, k - 1)+k* strl(n - 1, k);           scache[n][k]%=mod;           return scache[n][k];           }           void init()           {           for (int i = 0; i < 120; ++i)           {           for (int j = 0; j < 120; ++j)           {           scache[i][j]=-1;           }           }           }           long long gcd(long long x, long long y)           {           if (y==0)           return x;           return gcd(y, x%y);           }           long long sumfalling(long long n, int k)           {           n++;           k++;                       long long ans=1;           long long div=k;           for (int i = 0; i < k; ++i)           {           long long x=n-i;           long long y=gcd(x, div);           x/=y;           div/=y;           ans*=x;           ans%=mod;           }           //if(div!=1)           //printf("\n\n>>>>>>>>>>>%lld>>>>>>>>\n",div);           return ans;           }                       long long sum(long long n, int k)           {           long long ans=0;           for (int i = 0; i <= k; ++i)           {           ans+=strl(k, i)*sumfalling(n, i);           ans%=mod;           }           return ans;           }                       int main()           {           /*init();           mod=10000000;     for (int i = 0; i < 5; ++i)           {           for (int j = 0; j < 5; ++j)           {           printf("%d %d %lld\n",i,j,strl(i,j));     }           }*/           int t;           scanf("%d", &t);           while (t--)           {           long long n;           int k;           scanf("%lld%d%lld", &n, &k, &mod);           init();           long long ans=sum(n, k);           printf("%lld\n", ans);           }           return 0;           } 
#include<iostream> #include<cstdio> #include<cstring> #include<string> #include<cstdlib> #include<vector> #include<map> #include<set> #include<queue> #include<stack> #include<cmath> #include<cctype> #include<algorithm> using namespace std; #define pb push_back #define mp make_pair #define cin(n) scanf("%d",&n) #define gc getchar_unlocked typedef vector<long long> VI; long long fcin(){register long long c = gc();long long x = 0;for(;(c<48 || c>57);c = gc());for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}return x;}  #define P (long long)531169 // return a % b (positive value) long long mod(long long a, long long b) {   return ((a%b)+b)%b; }  // computes gcd(a,b) long long gcd(long long a, long long b) {   long long tmp;   while(b){a%=b; tmp=a; a=b; b=tmp;}   return a; }  // computes lcm(a,b) long long lcm(long long a, long long b) {   return a/gcd(a,b)*b; }  // returns d = gcd(a,b); finds x,y such that d = ax + by long long extended_euclid(long long a, long long b, long long &x, long long &y) {     long long xx = y = 0;   long long yy = x = 1;   while (b) {     long long q = a/b;     long long t = b; b = a%b; a = t;     t = xx; xx = x-q*xx; x = t;     t = yy; yy = y-q*yy; y = t;   }   return a; }  // finds all solutions to ax = b (mod n) VI modular_linear_equation_solver(long long a, long long b, long long n) {   long long x, y;   VI solutions;   long long d = extended_euclid(a, n, x, y);   if (!(b%d)) {     x = mod (x*(b/d), n);     for (long long i = 0; i < d; i++)       solutions.push_back(mod(x + i*(n/d), n));   }   return solutions; }  // computes b such that ab = 1 (mod n), returns -1 on failure long long mod_inverse(long long a, long long n) {   long long x, y;   long long d = extended_euclid(a, n, x, y);   if (d > 1) return -1;   return mod(x,n); }  long long inv(long long n){ 	return mod_inverse(n,P);  }  long long fact[P]={1};   long long func(long long a,long long b){ 	long long x = (a+b) / P ; 	long long y = a /P ;  	long long z = b /P ;  	if(x>y+z)return 0 ; 	long long ans = 1 ;  	ans *= fact[a+b-P*x]; 	ans = mod(ans,P); 	ans *= inv(fact[a-P*y]); 	ans = mod(ans,P); 	ans *= inv(fact[b-P*z]); 	ans = mod(ans,P); 	ans *= fact[x]; 	ans = mod(ans,P); 	ans *= inv(fact[y]); 	ans = mod(ans,P); 	ans *= inv(fact[z]); 	ans = mod(ans,P); 	return ans;  } typedef pair<long long,long long> PI;  map<PI,long long> MAP;  long long f(long long a,long long b){ 	if(MAP.find(mp(a,b)) != MAP.end())return MAP[mp(a,b)];  	long long ans = 0;  	ans += func(a,b);  	long long d = gcd(a,b);  	if(d==1)return MAP[mp(a,b)] = ans; 	for(long long i=1 ; i*i <= d; i++){ 		if(d%i)continue;  		ans -= i==1?0:f(a/i,b/i); 		ans -= i*i==d?0:f(a*i/d,b*i/d);  	} 	ans = mod(ans,P);  	return MAP[mp(a,b)] = ans;  } int main(){ 	long long temp = 1; 	for(long long i=1;i<P;i++){ 		temp = (temp * i) %P;  		fact[i] = temp;  	} 	long long tests=fcin(); 	long long a,b; 	while(tests--){ 		a=fcin(); 		b=fcin();  		cout<<f(a,b)<<endl; 	} 	return 0; }
# include <stdio.h> # include <bitset> # define maxNM 1500 char arr[maxNM+1][maxNM+1]; int cumXor[maxNM+1][maxNM+1]; std::bitset<maxNM+1> bits[maxNM+1]; int main() { 	long long int ans=0,y,x; 	int N,M; 	scanf("%d%d",&N,&M); 	for(int i=0;i<N;i++) 		scanf("%s",arr+i); 	for(int i=1;i<=N;i++) 		for(int j=1;j<=M;j++) 			cumXor[i][j]=cumXor[i-1][j-1]^cumXor[i-1][j]^cumXor[i][j-1]^(arr[i-1][j-1]-'0'); 	for(int i=0;i<=N;i++) 		for(int j=0;j<=M;j++) 			bits[i][j]=cumXor[i][j]; 	for(int i=0;i<N;i++) 		for(int j=i+1;j<=N;j++) 		{ 			x=(bits[i]^bits[j]).count(); 			y=M+1-x; 			ans+=(x*(x-1)+y*(y-1))/2; 		} 	printf("%lld\n",ans); 	return 0; }
#include<cstdio> #include<iostream> #include<cstring> #include<vector> #include<memory.h> #include<cstdlib> #include<cmath> #include<cassert> #include<memory.h> #include<algorithm> #include<queue> #include<utility> #include<map> #include<bitset> #include<stack> using namespace std;  typedef vector<int> VI; typedef long long LL; typedef unsigned long long uLL; typedef pair<int, int> PII; typedef vector<PII> VPII; #define pb push_back #define fi first #define se second #define mp make_pair #pragma comment(linker, "/STACK:266777216")  const int inf=1000000000; const LL INF=LL(inf)*inf; const double eps=1e-9; const double PI=2*acos(0.0);  //Constants #define NN 500005 #define offset 250000 //This means -2499 will be 1 and 0 will be 2500 and 2499 will be 4999  //Declarations stack<int>S; VI adj[NN]; VI surplus, deficit, choc, caramel; //If choc > caramel => surplus else deficit int N;  //For BFS queue<int>Q; int dist[NN]; int visited[NN];  int min(int a, int b){return a<b?a:b;}  void build() {     int idx, new_idx;     while(!S.empty())     {         S.pop();     }     S.push(0);     while(!S.empty())     {         idx = S.top();         S.pop();         if(adj[idx+offset].size() == 0) //means new vertex in our graph         {             if(idx >= 0) //only go through deficit list             {                 for(int i=0; i<deficit.size(); i++)                 {                     new_idx = idx + deficit[i];                     adj[idx+offset].pb(new_idx + offset);                     S.push(new_idx);                 }             }             if(idx <= 0)             {                 for(int i=0; i<surplus.size(); i++)                 {                      new_idx = idx + surplus[i];                     adj[idx+offset].pb(new_idx+offset);                     S.push(new_idx);                 }             }         }     } }  int bfs() {     fill(visited, visited+NN, 0);     fill(dist, dist+NN, inf);     while(!Q.empty())     {         Q.pop();     }     Q.push(0 + offset);     dist[0+ offset] = 0;     int u,v;     while(!Q.empty())     {         u = Q.front();         Q.pop();         if(visited[u] == 1)         {             continue;         }         visited[u] = 1;         for(int i=0; i<adj[u].size(); i++)             {                 v = adj[u][i];                 dist[v] =  min(dist[v], dist[u] + 1);                 if(v == 0 + offset)                 {                     dist[v] = dist[u] + 1;                     return(dist[v]);                 }                 if( visited[v] == 0)                 {                     Q.push(v);                 }              }     } }  void solve2() {     //To build a graph (index - offset) denotes the difference...we start from zero and must reach zero again     //If diff>0 means surplus we add candies only from deficit list and vice versa     //Thus we can bound the indices tp -min(-2499) to +max(2499)     int ans;     build();     ans = bfs();     printf("%d\n", ans); } void solve() {     //Initializations     surplus.clear();     deficit.clear();     choc.clear();     caramel.clear();     for(int i=0; i<NN; i++)     {         adj[i].clear();     }      //Taking in input     int x, y, dx, dy;      scanf("%d", &N);     for(int i=0; i<N; i++)     {         scanf("%d%d", &x, &y);         choc.pb(x);         caramel.pb(y);     }     scanf("%d%d", &dx, &dy);      //Compute surplus/deficit for each candy     int diff;     for(int i=0; i<N; i++)     {         diff = dy*choc[i]- dx*caramel[i];         assert(diff!=0);         if(diff>0)         {             surplus.pb(diff);         }         else         {             deficit.pb(diff);         }     }     if(surplus.size() == 0 || deficit.size() == 0)     {         printf("%d\n", -1);     }     else     {         solve2();     } }  int main() {     #ifndef ONLINE_JUDGE     freopen("input.txt","r",stdin);     freopen("output.txt","w",stdout);     #endif     solve(); } 
#include<iostream> #include<cstring> #include<string> #include<cstdio> #include<fstream> #include<cstdlib> #include<vector> #include<algorithm> #include<stack> #include<set> #include<map> #include<math.h> #include<ctime> #define LL long long #define ULL unsigned long long #define L long #define VCTP vector<pair<LL,LL> > #define PII pair<LL,LL> #define PDD pair<double,double> #define F first #define S second #define FOR(i,lb,ub) for(i=lb;i<=ub;i++) #define RFOR(i,ub,lb) for(i=ub;i>=lb;i--) #define FORS(it,v) for(it=v.begin();it!=v.end();it++) #define st_clk double st=clock(); #define end_clk double en=clock(); #define show_time cout<<"\tTIME="<<(en-st)/CLOCKS_PER_SEC<<endl; #define sc8(n) scanf("%c",&n) #define sc16(n) scanf("%d",&n) #define sc32(n) scanf("%ld",&n) #define sc64(n) scanf("%lld",&n) #define scst(n) scanf("%s",n) #define f_in(st) freopen(st,"r",stdin); #define f_out(st) freopen(st,"w",stdout); LL gcd(LL a, LL b) { return b?gcd(b,a%b):a; } using namespace std;  template <class T> inline void r_f(T &p) {          char c;          while ((c=getchar_unlocked()) < 48 || c > 57);          p=c-48;          while ((c=getchar_unlocked()) >= 48 && c <= 57) p=p*10+c-48; }   class htree {       public:              LL a[55];              int maxv;       htree(){memset(a,0,sizeof(a));}       void update(LL id,LL val)       {        while (id<=maxv)        {            a[id]+=val;            id+=(id & -id);        }       }       LL read(LL id)       {          LL sum=0;          while (id>0)          {                sum+=a[id];                id-=(id & -id);          }          return sum;       } }; class vtree {       public:              LL a[55];              int maxv;       vtree(){memset(a,0,sizeof(a));}       void update(LL id,LL val)       {        while (id<=maxv)        {            a[id]+=val;            id+=(id & -id);        }       }       LL read(LL id)       {          LL sum=0;          while (id>0)          {                sum+=a[id];                id-=(id & -id);          }          return sum;       } };               LL tab[50][50][50][50],taba[50][50][50][50]; LL mat[55][55],Rsum[55][55],Csum[55][55]; LL aalice,aa,bb; int n,m; LL bob(int,int,int,int); LL alice(int sr,int er,int sc,int ec) {aa++;              LL s1=0,s2=0,s3=0,s4=0,i;             /* FOR(i,sc,ec)//top row            {                          s1+=mat[sr][i];//top                          s2+=mat[er][i];//bottom            }            FOR(i,sr,er)            {                          s3+=mat[i][sc];//left                          s4+=mat[i][ec];//right            }*/            /*s1=h[sr+1].read(ec+1)-h[sr+1].read(sc);            s2=h[er+1].read(ec+1)-h[er+1].read(sc);            s3=v[sc+1].read(er+1)-v[sc+1].read(sr);            s4=v[ec+1].read(er+1)-v[ec+1].read(sr);*/            s1=Rsum[sr+1][ec+1]-Rsum[sr+1][sc];            s2=Rsum[er+1][ec+1]-Rsum[er+1][sc];            s3=Csum[sc+1][er+1]-Csum[sc+1][sr];            s4=Csum[ec+1][er+1]-Csum[ec+1][sr];              LL ar[4];ar[0]=s1;ar[1]=s2;ar[2]=s3;ar[3]=s4;              sort(ar,ar+4);             // aalice+=ar[0];              if (ar[0]==s1)              {                 if (sr+1<=n && sr+1<=er)                    return bob(sr+1,er,sc,ec);                 else return 0;              }              else if (ar[0]==s2)              {                   if (er-1>=0 && er-1>=sr)                    return bob(sr,er-1,sc,ec);                   else return 0;              }              else if (ar[0]==s3)              {                 if (sc+1<=m && sc+1<=ec)                    return bob(sr,er,sc+1,ec);                 else return 0;              }              else              {                  if (ec-1>=0 && ec-1>=sc)                    return bob(sr,er,sc,ec-1);                   else return 0;              } } LL bob(int sr,int er,int sc,int ec) {bb++;            int i;            if (tab[sr][er][sc][ec]!=-1)               return tab[sr][er][sc][ec];                           LL s1=0,s2=0,s3=0,s4=0,f1,f2,f3,f4,sum;            /*FOR(i,sc,ec)//top row            {                          s1+=mat[sr][i];//top                          s2+=mat[er][i];//bottom            }            FOR(i,sr,er)            {                          s3+=mat[i][sc];//left                          s4+=mat[i][ec];//right            }*/            /*s1=h[sr+1].read(ec+1)-h[sr+1].read(sc);            s2=h[er+1].read(ec+1)-h[er+1].read(sc);            s3=v[sc+1].read(er+1)-v[sc+1].read(sr);            s4=v[ec+1].read(er+1)-v[ec+1].read(sr);*/            s1=Rsum[sr+1][ec+1]-Rsum[sr+1][sc];            s2=Rsum[er+1][ec+1]-Rsum[er+1][sc];            s3=Csum[sc+1][er+1]-Csum[sc+1][sr];            s4=Csum[ec+1][er+1]-Csum[ec+1][sr];            f1=s1;f2=s2;f3=s3;f4=s4;            if (sr==er)            {               tab[sr][er][sc][ec]=s1;            }            else if (sc==ec)            {                 tab[sr][er][sc][ec]=s3;            }            else            {               if (sr+1<=n && sr+1<=er)               {                  if (taba[sr+1][er][sc][ec]==-1)                     taba[sr+1][er][sc][ec]=alice(sr+1,er,sc,ec);                  f1+=taba[sr+1][er][sc][ec];//+h[sr+1].read(ec+1)-h[sr+1].read(sc);               }               if (er-1>=0 && er-1>=sr)               {                  if (taba[sr][er-1][sc][ec]==-1)                     taba[sr][er-1][sc][ec]=alice(sr,er-1,sc,ec);                  f2+=taba[sr][er-1][sc][ec];//+h[er+1].read(ec+1)-h[er+1].read(sc);               }               if (sc+1<=m && sc+1<=ec)               {                  if (taba[sr][er][sc+1][ec]==-1)                     taba[sr][er][sc+1][ec]=alice(sr,er,sc+1,ec);                  f3+=taba[sr][er][sc+1][ec];//+v[sc+1].read(er+1)-v[sc+1].read(sr);               }               if (ec-1>=0 && ec-1>=sc)               {                  if (taba[sr][er][sc][ec-1]==-1)                     taba[sr][er][sc][ec-1]=alice(sr,er,sc,ec-1);                  f4+=taba[sr][er][sc][ec-1];//+v[ec+1].read(er+1)-v[ec+1].read(sr);               }               LL mx=max(max(max(f1,f2),f3),f4);               tab[sr][er][sc][ec]=mx;           }           //cout<<"\t"<<mx<<"\t"<<sr<<" "<<er<<" "<<sc<<" "<<ec<<endl;           return tab[sr][er][sc][ec]; } int main() {      #ifndef ONLINE_JUDGE      f_in("in.txt");      f_out("out2.txt");      #endif      LL t,i,k,j;      //cout<<sizeof(tab)/(1024*1024)<<endl;      //cin>>t;//st_clk      r_f(t);      while (t--)      {aa=bb=0;st_clk            memset(tab,-1,sizeof(tab));            memset(taba,-1,sizeof(taba));            memset(Rsum,0,sizeof(Rsum));            memset(Csum,0,sizeof(Csum));            //cout<<tab[1][2][3][4]<<endl;            aalice=0;            cin>>n>>m;            //htree h[55];            //vtree v[55];            LL x;            FOR(i,1,n)            FOR(j,1,m){ //cin>>mat[i][j];            r_f(mat[i][j]);            aalice+=mat[i][j];           /* h[i].maxv=m;            h[i].update(j,x);            v[j].maxv=n;            v[j].update(i,x);*/            }            FOR(i,1,n) 			FOR(j,1,m) 			Rsum[i][j]=Rsum[i][j-1]+mat[i][j];  		FOR(i,1,m) 			FOR(j,1,n) 			Csum[i][j]=Csum[i][j-1]+mat[j][i];            //FOR(i,1,n) cout<<Csum[i][3]<<endl;            LL ans=alice(0,n-1,0,m-1);            if (2*ans==aalice)               cout<<2*ans<<endl;            else                cout<<max(ans,aalice-ans)<<endl;            //cout<<"\t"<<aa<<" "<<bb<<endl;            //end_clk            //show_time      }  //system("pause"); return 0; } 
#include <vector> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <algorithm> #include <utility> #include <numeric> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cstring> #include <cmath> #include <cstdlib> #include <ctime> #include <cassert>  using namespace std;  #define F first #define S second #define PB push_back #define MP make_pair  const double PI = acos(-1.0); const double EPS = 1e-9; const int INF = 2123123123; const int MOD = 1e9+7;  typedef long long ll; typedef pair<int,int> pii;  #define ALL(c) (c).begin(), (c).end() #define SZ(a) (int)(a).size() #define RESET(a,x) memset(a,x,sizeof(a)) #define FORIT(it,v) for(__typeof(v.begin()) it = v.begin(); it != v.end(); ++it)   inline void OPEN(const string &s) { 	freopen((s + ".in").c_str(), "r", stdin); 	freopen((s + ".out").c_str(), "w", stdout); }  #define MAXR 20 #define MAXC 20  int t,r,c; int monster[MAXR+5][MAXC+5], vis[MAXR+5][MAXC+5][MAXR+5][MAXC+5], memo[MAXR+5][MAXC+5][MAXR+5][MAXC+5]; char a[MAXR+5][MAXC+5];  int grundy(int r1, int c1, int r2, int c2) {     set<int> s;     if (r1 < 0 || c1 < 0) return 0;     if (r1 > r2 || c1 > c2) return 0;     if (vis[r1][c1][r2][c2]) return memo[r1][c1][r2][c2];     for (int rr = r1; rr <= r2; rr++) {         for (int cc = c1; cc <= c2; cc++) {             if (monster[rr][cc])                 s.insert(grundy(r1,c1,rr-1,cc-1) ^ grundy(rr+1,c1,r2,cc-1) ^ grundy(r1,cc+1,rr-1,c2) ^ grundy(rr+1,cc+1,r2,c2));         }     }     int ret = 0;     while (s.find(ret)!=s.end()) ++ret;     vis[r1][c1][r2][c2] = 1;     memo[r1][c1][r2][c2] = ret;     return ret; }   int main() {     scanf("%d", &t);     while (t--) {         RESET(vis,0);         RESET(monster,0);         char s[MAXC+5];                           scanf("%d %d", &r, &c);         for (int i = 0; i < r; i++) {             scanf("%s", s);             for (int j = 0; j < c; j++) a[i][j] = s[j];         }         for (int i = 0; i < r; i++) {             for (int j = 0; j < c; j++) {                 if (a[i][j] == '#') continue;                 int l,ri,t,b;                 int ii = i, jj = j;                 l = ri = t = b = 0;                 while (i-1 >= 0 && a[i-1][j] == '^' ) { --i; ++t; }                 i = ii;                 while (j-1 >= 0 && a[i][j-1] == '^') { --j; ++l; }                 j = jj;                 while (i+1 < r && a[i+1][j] == '^') { ++i; ++b; }                 i = ii;                 while (j+1 < c && a[i][j+1] == '^') { ++j; ++ri; }                 j = jj;                 if (min(l,min(ri,min(t,b))) >= 2) monster[i][j] = 1;                 else monster[i][j] = 0;             }         }         if (grundy(0,0,r-1,c-1)) puts("Asuna");         else puts("Kirito");     }          return 0; } 
#include <bits/stdc++.h> #define MAXN 2010 using namespace std;  bool visited[MAXN]; int arr[MAXN][2]; int mp[MAXN]; int dp[MAXN][MAXN]; int main() {     for(int i=2;i<MAXN;++i)     {         dp[i][i-1]=i-2;         for(int j=i;j<MAXN;++j)         {             dp[i][j]=max(dp[i][j-(i-1)]+i-2,dp[i][j-i]+i-1);         }     }     int n,t;     scanf("%d",&t);     while(t--)     {         scanf("%d",&n);         memset(visited,0,sizeof(visited));         for(int i=0;i<n;++i) scanf("%d",&arr[i][0]);         for(int i=0;i<n;++i) scanf("%d",&arr[i][1]);         for(int i=0;i<n;++i)         {             mp[arr[i][0]]=arr[i][1];         }         int ans=0;         vector<int> cycles;         for(int i=1;i<=n;++i)         {             if(visited[i]) continue;             visited[i]=1;             int j=i,l=1;             while(mp[j]!=i)             {                 j=mp[j];                 visited[j]=1;                 l++;             }             if(l==1) ans++;             else cycles.push_back(l);         }         sort(cycles.begin(),cycles.end());          for(int i=2;i<=n;++i)         {             int cur=0;             for(int j=0;j<cycles.size();++j)             {                 cur+=dp[i][cycles[j]];             }             ans=max(ans,cur);         }         printf("%d\n",ans);     } } 
#include <cstdio> #include <algorithm>  #define long long long #define M 20000 #define INF 2000000000 #define H 100100  using namespace std;  long p[M],pc=1,k[M],s=0,n; long u[H];  void pre(void){     p[0]=0;     for (long i=2; i<H; ++i)     if (u[i]==0){         p[pc]=i;         for (long j=i; j<H; j+=i)         u[j]=pc;         pc++;     } }  long bin(long x){     return (long) (upper_bound(p,p+pc,x)-p-1); }  void read(void){     scanf("%lld",&n);     for (long i=0; i<=pc; ++i)     k[i]=0;      s=0;      for (long i=0,x; i<n; ++i){         scanf("%lld",&x);         scanf("%lld",&k[bin(x)]);     }     if (k[1]==0)     k[1]=1; }  void pref(long x, long h){     for (long i; x>1;){         i=u[x];         x/=p[i];         k[i]+=h;     } }  void calc(void){     for (long i=pc; i>1; --i)     if (k[i])     pref(p[i]-1,k[i]);     s=k[1]; }  int main() {     long t;     pre();     scanf("%lld",&t);     while (t--){         read();         calc();         printf("%lld\n",s);     }     return 0; } 
#include <stdio.h> #include <string.h> #include <stdlib.h> #include <iostream> #include <algorithm> #include <string> #include <vector> #include <map> #include <set> #include <queue> #include <stack>  using namespace std;  #define MAXN 210 #define MAXM 200100 #define INF 10000000  int m, k, n;  int trans[MAXN][MAXN]; int dp[MAXM][MAXN]; int in[MAXM];  void init() { 	for (int i = 1; i <= m; ++i) 	{ 		for (int j = 1; j <= m; ++j) 		{ 			for (int k = 1; k <= m; ++k) 			{ 				if(trans[j][i] && trans[i][k]) 					trans[j][k] = 1; 			} 		} 	} }  int main() { 	int T; 	int a, b; 	//freopen("in.txt", "r", stdin); 	scanf("%d", &T); 	//printf("%d\n", T); 	while(T--) 	{ 		scanf("%d%d%d", &m, &k, &n); 		memset(trans, 0, sizeof(trans)); 		for (int i = 1; i <= m; ++i) 		{ 			trans[i][i] = 1; 		} 		for (int i = 0; i < k; ++i) 		{ 			scanf("%d%d", &a, &b); 			trans[a][b] = 1; 			trans[b][a] = 1; 		} 		for (int i = 1; i <= n; ++i) 		{ 			scanf("%d", &in[i]); 		} 		init();  		/*memset(dp, 0, sizeof(dp));  		for (int i = 1; i <= n; ++i) 		{ 			dp[i][0] = INF; 			for (int j = 1; j <= m; ++j) 			{ 				dp[i][j] = dp[i][j - 1]; 				if(trans[in[i]][j]) 					dp[i][j] = min(dp[i][j], dp[i - 1][j] + (in[i] == j ? 0 : 1)); 			} 		}*/  		for (int i = 1; i <= m; ++i) 		{ 			dp[0][i] = INF; 		} 		dp[0][1] = 0;  		for (int i = 1; i <= n; ++i) 		{ 			int y = INF; 			for (int j = 1; j <= m; ++j) 			{ 				y = min(y, dp[i - 1][j]); 				//printf("%d %d %d\n", i, j, y); 				if(trans[in[i]][j]) 					dp[i][j] = y + (in[i] != j); 				else 					dp[i][j] = INF; 			} 		}  		int res = INF; 		for (int i = 1; i <= m; ++i) 		{ 			res = min(dp[n][i], res); 		} 		if(res >= INF) 			res = -1;  		printf("%d\n", res); 		continue;   		if(dp[n][m] >= INF) 			dp[n][m] = -1;  		/*for (int i = 1; i <= n; ++i) 		{ 			for (int j = 1; j <= m; ++j) 			{ 				printf("%d ", dp[i][j]); 			} 			printf("\n"); 		}*/  		printf("%d\n", dp[n][m]); 	} 	return 0; }
#include<iostream> #include<cstdio> #include<algorithm> #include<cstring> #include<vector> using namespace std;  #define LL long long #define MOD 1000000007LL #define VLL vector<LL> #define VVLL vector<VLL>  int a; LL b; VVLL M; bool c[100],d[100];  bool poss(int i,int j) {     for(int k=0;k<a;k++){         c[k] = ((i & (1<<k)) != 0);         d[k] = ((j & (1<<k)) != 0);     }     for(int k=0;k<a-1;k++){         if(c[k]==c[k+1] && c[k]==d[k] && c[k]==d[k+1]) return false;     }     return true; }  void preprocess() {     M.resize(1<<a);     for(int i=0;i<M.size();i++) M[i].resize(1<<a, 0);     for(int i=0;i<(1<<a);i++){         for(int j=0;j<(1<<a);j++){             M[i][j]=poss(j,i);         }     } }  VVLL prod(VVLL& X, VVLL& Y) {     VVLL ret(1<<a, VLL(1<<a, 0LL));     for(int i=0;i<(1<<a);i++){         for(int j=0;j<(1<<a);j++){             for(int k=0;k<(1<<a);k++){                 ret[i][j] += X[i][k] * Y[k][j];                 ret[i][j] %= MOD;             }         }     }     return ret; }  VVLL power_mod() {     VVLL ret(1<<a, VLL(1<<a, 0));     for(int i=0;i<(1<<a);i++) ret[i][i]=1LL;     VVLL inter=M;     LL e=b-1;     while(e){         if(e & 1){             ret = prod(ret, inter);         }         inter = prod(inter, inter);         e = e>>1;     }     return ret; }  int main() {     cin>>a>>b;     preprocess();     VVLL temp=power_mod();     LL ans=0;     for(int i=0;i<(1<<a);i++){         for(int j=0;j<(1<<a);j++){             ans += temp[i][j];             ans %= MOD;         }     }     cout<<ans<<"\n";     return 0; } 
//This is getting accepted! // Fibonaci tree #include<bits/stdc++.h>  using namespace std;  #define FI first #define SE second #define pb push_back #define mp make_pair #define ll long long #define sz(a) ((int)(a).size()) #define __builtin_popcount __builtin_popcounll  typedef pair<int, int> pii; typedef pair<double, double> pdd; typedef pair<int, pii> ppi;  const double PI = acos(0) * 2; const double EPS = 1e-8; const ll MOD = 1e9 + 7; const int MAXN = 1e5 + 5; const int oo = 1e9; const double foo = 1e30;  template<class T> int getbit(T s, int i) { return (s >> i) & 1; } template<class T> T onbit(T s, int i) { return s | (T(1) << i); } template<class T> T offbit(T s, int i) { return s & (~(T(1) << i)); } template<class T> int cntbit(T s) { return __builtin_popcounll(s);}  const int k = 330;  int time1 = 0, n, m; int values[100100], pos[100100], ty[100100], L[100100], tin[100100], tout[100100], value[100100], parent[100100]; ll f[200100], b[100100], c[100100], a[100100]; vector<int> adj[100100], v;  void DFS(int u, int lv) { //	cout << u << endl; 	L[u] = lv; 	time1++; 	v.pb(u); 	tin[u] = time1; 	for (int i=0; i<sz(adj[u]); i++) { 		int v = adj[u][i]; 		DFS(v, lv + 1); 	} 	time1++; //	v.pb(u); 	tout[u] = time1; }  int main() { #ifndef ONLINE_JUDGE     freopen("inp.txt", "r", stdin);     freopen("out.txt", "w", stdout); #endif  	f[1] = 1; f[2] = 1; 	for (int i=3; i<=200001; i++) f[i] = (f[i-1] + f[i-2]) % MOD; //	ll stest = 0; //	for (int i=2; i<=332; i+=2) (stest += f[i]) %= MOD; //	cout << stest << endl; 	scanf("%d%d", &n, &m); 	for (int i=2; i<=n; i++) { 		int x; 		scanf("%d", &x); 		adj[x].pb(i); 		parent[i] = x; 	} 	DFS(1, 1); //	for (int i=0; i<sz(v); i++) cout << v[i] << " "; //	cout << endl; 	char type; 	int tc = 0; 	for (int i=1; i<=m; i++) { 		scanf("\n%c", &type); //		cout << i << " " << type << endl; 		if (type == 'U') scanf("%d%d", &pos[i], &value[i]), ty[i] = 0; 		else scanf("%d", &pos[i]), ty[i] = 1; 		if (i % k == 0 || i == m) { // cache full 			fill_n(b, n + 1, 0); 			fill_n(c, n + 1, 0); 			for (int j = k * tc + 1; j<=i; j++) { 				if (ty[j] == 1) { // here //					if (j % 2 != 1) cout << j << endl; 					int x = tin[pos[j]]; 					ll ret = a[pos[j]]; 					for (int t=k * tc + 1; t<=j; t++) if (ty[t] == 0) { 						if (tin[pos[t]] <= x && tout[pos[t]] >= x) { 							(ret += f[value[t] + L[pos[j]] - L[pos[t]]]) %= MOD; 						} 					} 					printf("%lld\n", ret); 				} 				else { 					(b[pos[j]] += f[value[j]]) %= MOD; 					(c[pos[j]] += f[value[j] - 1]) %= MOD; 				} 			} 			tc++; 			// update 			for (int j=0; j<sz(v); j++) { 				int u = v[j]; 				int pu = parent[u]; 				(a[u] += b[pu] + c[pu] + b[u]) %= MOD; 				(b[u] = b[u] + b[pu] + c[pu]) %= MOD; 				(c[u] = b[pu] + c[u]) %= MOD; 			} 		} 	}  } 
#include <stdio.h> #include <iostream> #include <algorithm> using namespace std;   const int MAXN = 5000 + 10;   int Tn, n, k, a[MAXN], seg_or[MAXN][MAXN], p[MAXN][MAXN]; long long dp[MAXN][MAXN];   int main () {     ios_base::sync_with_stdio(false);     cin >> Tn;     while (Tn--) {         cin >> n >> k;         for(int i = 1; i <= n; i++)             cin >> a[i];         for(int i = 1; i <= n; i++) {             seg_or[i][i] = a[i];             for(int j = i + 1; j <= n; j++)                 seg_or[i][j] = seg_or[i][j - 1] | a[j];         }         for(int i = 0; i <= n; i++) {             for(int j = 0; j <= k; j++)                 dp[j][i] = 0;             p[0][i] = 1;         }         for(int j = 0; j <= k; j++)             p[j][n + 1] = n;         for(int i = 1; i <= k; i++) {             for(int j = n; j >= 1; j--) {                 for(int t = max(1, p[i - 1][j]); t <= p[i][j + 1]; t++)                     if (dp[i - 1][t - 1] + seg_or[t][j] >= dp[i][j]) {                         dp[i][j] = dp[i - 1][t - 1] + seg_or[t][j];                         p[i][j] = t;                     }             }         }         cout << dp[k][n] << endl;     }     return 0; }
#include <iostream> #include <cstdio> #include <memory.h> #include <cstdlib>   using namespace std;   int n, x, ret = 0; int f[1000005]; int all[1000005];   int main() {     int ans = 0;     for (int i = 1; i <= 1000000; ++i) {         f[i] = i;     }     for (int i = 2; i <= 1000; ++i) {         if (f[i] != i) continue;         int j = i + i;         while (j <= 1000000) {             f[j] = i;             j += i;         }     }     // number of tests     int tests;     scanf("%d", &tests);     while (tests--) { 	// all[x] - means maximal degree of prime divisor x, in some number that are given in array         memset(all, 0, sizeof(all)); 	// number of elements         scanf("%d", &n);         ans = 0;         for (int i = 0; i < n; ++i) {             scanf("%d", &x); 	    // partition on prime divisors             while (x > 1) {                 int d = f[x];                 int cnt = 0;                 while (x % d == 0) {                     x /= d;                     cnt++;                 }                 if (all[d] < cnt) {                     ans += cnt - all[d];                     all[d] = cnt;                 }             }         } 	// ans = sum of all[x] for every x         printf("%d\n", ans);     }     return 0; }
           #include<bits/stdc++.h>         #include<cstdio>         #include<algorithm>         #include<iostream>         #include<cstring>         #include<string>         #include<stack>         #include<queue>         #include<cmath>         #include<limits>         #include<set>         #include<vector>         #include<map>         #include<list>          using namespace std;          #define lli long long int         #define F(i,a,b) for(int i=a ; i<b; i++)         #define ll long long         #define pii pair<int,int>         #define pip pair<int,pii>         #define pb push_back         #define ff first         #define ss second         #define fill(a,b) memset(a,b,sizeof(a));         #define MOD 1000000007           int main()         {             int n;             const int N=100000+7;             scanf("%d",&n);             int arr[N];             set<int> myset[6];              F(i,0,n)             {                 scanf("%d",&arr[i]);                 if(arr[i]%2==0)myset[2].insert(i);                 if(arr[i]%3==0)myset[3].insert(i);                 if(arr[i]%5==0)myset[5].insert(i);             }                int m;             int type,l,r,p,d;             scanf("%d",&m);             F(i,0,m)             {                 scanf("%d",&type);                 if(type==1)                 {                     scanf("%d%d%d",&l,&r,&p);                     set<int> :: iterator a=lower_bound(myset[p].begin(),myset[p].end(),l-1);                     vector <int> del;                     for(set<int>::iterator it=a;it!=myset[p].end();++it)                     {                         if(*it>r-1) break;                          arr[*it]/=p;                         if(arr[*it]%p)//not divisible by p anymore this index has to be deleted from the p set                             del.pb(*it);                     }                     for(vector<int>::iterator it=del.begin();it!=del.end();it++)                         myset[p].erase(*it);                 }                 else//update query                 {                     //change l th value to d. so delete l th value if present in any of the sets                     scanf("%d%d",&l,&d);                     l--;                     if(arr[l]%2==0)myset[2].erase(l);                     if(arr[l]%3==0)myset[3].erase(l);                     if(arr[l]%5==0)myset[5].erase(l);                      //include them in the sets                     if(d%2==0)myset[2].insert(l);                     if(d%3==0)myset[3].insert(l);                     if(d%5==0)myset[5].insert(l);                      arr[l]=d;                 }             }              F(i,0,n)             cout<<arr[i]<<" ";              return 0;         }      
#include <iostream> #include <algorithm> #include <ctime> #include <utility> #include <stdlib.h> #include <string.h> using namespace std;  #define MOD 1000000000 #define MAX 400000 int n,q;  struct TreapNode {  	int key,priority,count; 	TreapNode *left, *right;  };  TreapNode* arrayT[MAX];  // A utility function to print tree void inorder(TreapNode* root) {      if (root)     {        inorder(root->left);         cout << "key: "<< root->key << " | priority: "             << root->priority <<" | count "<< root->count;         if (root->left)             cout << " | left child: " << root->left->key;         if (root->right)             cout << " | right child: " << root->right->key;         cout << endl;         inorder(root->right);     } }   void update(TreapNode* s) {	  	if(!s) 		return;  	int lc,rc;  	if(s->left==NULL)lc=0; 	else lc = s->left->count;  	if(s->right==NULL)rc=0; 	else rc = s->right->count;  	s->count = 1+rc+lc;  }  TreapNode* rr(TreapNode* y) { 	TreapNode* x = y->left;  	TreapNode* xr = x->right;  	x->right = y; 	y->left = xr;  	update(y); 	update(x);  	return x;  }  TreapNode* lr(TreapNode* x) { 	TreapNode* y = x->right; 	TreapNode* yl = y->left;   	y->left = x; 	x->right = yl;  	update(x); 	update(y);  	return y;  }  TreapNode* Node(int key) { 	TreapNode* temp = new TreapNode; 	temp->key = key; 	int prior = 0;     for(int i = 0; i < 10; i++)         prior = (10LL * prior + rand() % 10) % MOD;  	temp->priority = prior; 	temp->right = NULL; 	temp->left = NULL; 	temp->count = 1;  	return temp;  }  TreapNode* search(TreapNode* root,int key) { 	if(root==NULL||root->key==key) 		return root;  	if(root->key < key) 		return search(root->right,key);  	if(root->key > key) 		return search(root->left,key);  	return root;  }  TreapNode* insert(TreapNode* root,TreapNode* add) {  	if(!root) 		return add;    	if(add->key <= root->key) 	{	 		root->left = insert(root->left,add);  		update(root->left); 		update(root);  		if(root->left->priority > root->priority) 			root = rr(root);  	} 	else 	{ 		root->right = insert(root->right,add);  		update(root->right); 		update(root);  		if(root->right->priority > root->priority) 			root = lr(root); 	}  	//cout<<"Key :"<<root->key<<endl;  	return root;  }  pair<TreapNode*,TreapNode*> split(TreapNode* t, int key) {  	TreapNode* temp = Node(key); 	temp->priority = MOD+1;  	TreapNode* root = insert(t,temp);  	 	return make_pair(root->left,root->right);  }  TreapNode* add(TreapNode* l,TreapNode* r) {  	if(r) 	{	 		TreapNode *newadd = new TreapNode; 		newadd->priority = r->priority; 		newadd->key =  r->key; 		newadd->left=NULL; 		newadd->right=NULL; 		newadd->count=1;  		l = insert(l,newadd);  		/* 		cout<<"insert\n"; 		inorder(l); 		cout<<"end insert\n"; 		*/  		l = add(l,r->left);  		l = add(l,r->right);  		//cout<<"Key S :"<<l->key<<endl;  		return l;  	} 	 	return l;  }  TreapNode* unionS(TreapNode* l,TreapNode* r) {  	if(l==NULL) 		return r; 	if(r==NULL) 		return l;  	if(l->count < r->count) 		swap(l,r);  	l = add(l,r);  	//cout<<"after Union :"<<l->key<<endl;  	/* 	cout<<"Changes add\n"; 	inorder(l); 	cout<<"Visible now\n"; 	*/  	return l;  }   TreapNode* unionT(TreapNode* l,TreapNode* r) { 	if(l==NULL) 		return r; 	if(r==NULL) 		return l;  	if(l->priority < r->priority) 		swap(l,r);  	pair<TreapNode*,TreapNode*> eq;  	eq = split(r,l->key);  	TreapNode* node = Node(l->key); 	node->left = unionT(l->left,eq.first); 	node->right = unionT(l->right,eq.second); 	update(node->left); 	update(node->right); 	update(node);  	return node;  }   TreapNode* getkth(TreapNode* root,int num) { 	int lc; 	if(root->left==NULL)lc=0; 	else lc = root->left->count;  	if(lc+1==num)return root;  	if(num< lc+1) 		return getkth(root->left,num); 	else if(num > lc+1) 		return getkth(root->right,num-(lc+1));  	return root;  }  int main() { 	srand(time(NULL));       scanf("%d%d",&n,&q);      int unioncount=n+1;      for(int i=1;i<=n;i++)     {     	arrayT[i]=Node(i);     }      for(int i=0;i<q;i++)     {      	char get[10];      	scanf("%s",get);      	int k1,k2;    		 	     	scanf("%d%d",&k1,&k2);     		if(strcmp(get,"UNION")==0)    		{    			arrayT[unioncount]=unionS(arrayT[k1],arrayT[k2]);    			//inorder(arrayT[unioncount]);    			unioncount++;     		}    		else    		{    			printf("%d\n",getkth(arrayT[k1],k2)->key);    		}      }   }
#include <bits/stdc++.h> using namespace std;   int visited[6667]; long long int dist[6667]; int a[6667][5]; int n,d;   #define MOD 747474747   long long int getdist(int p,int q) { 	long long int k = 0; 	for(int i=0;i<d;i++) {long long int kk = (a[p][i]-a[q][i]); k += kk*kk;}//*(a[p][i]-a[q][i]); 	return k; }   long long int prim() { 	for(int i=0;i<n;i++)visited[i]=0;   	visited[0] = 1; 	for(int i=1;i<n;i++)dist[i] = getdist(0,i);   	long long int ans = 1; 	//int vis = n-1; 	 	while(1) 	{ 		int nextv = -1; long long int nextd = 0; 		for(int i=0;i<n;i++) 		{ 			if(!visited[i] && nextd  < dist[i]){nextv = i; nextd = dist[i];}  		}   		if(nextd == 0) break;   		ans = (ans*(nextd%MOD))%MOD; 		if(ans==0) 		break; 		visited[nextv] = 1;   		for(int i=0;i<n;i++) 		{ 			if(!visited[i]) 			{ 	 				long long int k = getdist(i,nextv);  				if(k>dist[i]) dist[i] = k; 			} 		} 	}    	return ans; }   int main() { 	int t; 	scanf("%d",&t);   	while(t--) 	{ 		scanf("%d %d",&n,&d);   		for(int i=0;i<n;i++) 		for(int j=0;j<d;j++) 			scanf("%d",&a[i][j]);   		//memset(visited,0,sizeof(visited));   		//for(int i=0;i<n;i++)dist[i] = make_pair(-1,-1);   		printf("%lld\n",prim()); 	} } 
#include<iostream> int min(int a,int b) {     return a<b?a:b; } main() {       int t,n,m,i,j,k,d,map[101][101],cost[101][101],dp[101][101],mini;       scanf("%d",&t);       while(t--)       {             mini=1000000;                 scanf("%d%d%d",&d,&n,&m);             for(i=1;i<=m;i++)             for(j=1;j<=n;j++)             {scanf("%d",&map[i][j]);dp[i][j]=1000000;}             for(i=1;i<=m;i++)             for(j=1;j<=m;j++)             scanf("%d",&cost[i][j]);             for(k=1;k<=m;k++)             for(i=1;i<=m;i++)             for(j=1;j<=m;j++)             cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);             for(i=1;i<=m;i++)             dp[i][1]=map[i][1];             for(j=2;j<=n;j++)             for(i=1;i<=m;i++)             for(k=1;k<=m;k++)             dp[i][j]=min(dp[i][j],dp[k][j-1]+cost[k][i]+map[i][j]);             for(i=1;i<=m;i++)             if(dp[i][n]<mini)             mini=dp[i][n];             mini=d-mini;             if(mini<0)             printf("-1\n");             else             printf("%d\n",mini);       }       //system("pause"); }                                           
#include<stdio.h> #include<iostream> #include<math.h> #include<algorithm> using namespace std; int a[100][45];  #define g getchar_unlocked()   int scan()//fast input output { int t=0; char c; c=g; while(c<'0' || c>'9') c=g; while(c>='0' && c<='9') { t=(t<<3)+(t<<1)+c-'0'; c=g; }//end fast input output return(t); }  int main() { 	int i,j,tc,k,n,size[100],parity; 	long long v,sum; 	scanf("%d",&tc); 	while(tc--) 	{ 		k=scan(); 		//scanf("%d",&k); 		for(i=0;i<k;i++) 		{ 			n=scan(); 			//scanf("%d",&n); 			size[i]=n; 			for(j=0;j<n;j++) 			a[i][j]=scan();//scanf("%d",&a[i][j]); 			sort(a[i],a[i]+n); 		} 		sum=0; 		for(i=0;i<k;i++) 		{ 			v=1LL<<45; 			j=0; 			parity=a[i][j]&1; 			//printf("%d %d %d\n",j,parity,size[i]); 			while(j<size[i] && ((a[i][j]&1)==parity)) 			{ 				j++; 			if(parity) 			sum-=v; 			else 			sum+=v; 			} 			v/=2; 				for(;j<size[i];j++) 				{ 					if(a[i][j]&1) 					sum-=v; 					else 					sum+=v; 					v/=2; 				}	 		} 		if(sum==0) 		printf("DON'T PLAY\n"); 		else if(sum>0) 		printf("EVEN\n"); 		else 		printf("ODD\n"); 	} 	return 0; }
/*     Nimesh Ghelani (nims11) */ #include <bits/stdc++.h> #define in_T int t;for(scanf("%d",&t);t--;) #define in_I(a) scanf("%d",&a) #define in_F(a) scanf("%lf",&a) #define in_L(a) scanf("%lld",&a) #define in_S(a) scanf("%s",a) #define newline printf("\n") #define BE(a) a.begin(), a.end()  using namespace std; struct edge{     long long l1, l2;int  v1, v2; }; struct evt{     int type; // 0 -> fw edge, 1 -> bw edge     int edge_idx; }; vector<evt> events; vector<edge> E; map<pair<long long, int>, int> cache; const int mod = 1000000007; int POW(long long r, long long n) {     int ans = 1;     while(n>0)     {         if(n&1)             ans = (ans*r)%mod;         n >>= 1;         r = (r*r)%mod;     }     return ans; } bool cmpevt(const evt &a, const evt &b){     long long l1 = (a.type == 0?E[a.edge_idx].l1:E[a.edge_idx].l2);     int v1 = (a.type == 0?E[a.edge_idx].v1:E[a.edge_idx].v2);     long long l2 = (b.type == 0?E[b.edge_idx].l1:E[b.edge_idx].l2);     int v2 = (b.type == 0?E[b.edge_idx].v1:E[b.edge_idx].v2);     if(l1 != l2)         return l1 < l2;     if(v1 != v2)         return v1 < v2;     return a.type > b.type; } int main() {     long long n, m, k;     in_L(n);     in_L(m);     in_L(k);     long long e0, e1, e2, e3;     edge e;     evt ee;      for(int i = 0;i<k;i++){         in_L(e0);in_L(e1);in_L(e2);in_L(e3);         e.l1 = e0, e.l2 = e2, e.v1 = e1, e.v2 = e3;         E.push_back(e);         ee.type = 0;         ee.edge_idx = E.size()-1;         events.push_back(ee);         ee.type = 1;         events.push_back(ee);     }     e.l1 = n+1, e.l2 = n+1, e.v1 = 0, e.v2 = 0;     E.push_back(e);     ee.type = 0;     ee.edge_idx = E.size()-1;     events.push_back(ee);     sort(events.begin(), events.end(), cmpevt);     int curWays = 1;     int tmpCache = 0;     long long curM = 0;     int curPrevWays = 1;     for(int i = 0;i<events.size();i++){         evt &e = events[i];         int type = e.type;         long long l = (type == 0?E[e.edge_idx].l1:E[e.edge_idx].l2);         int v = (type == 0?E[e.edge_idx].v1:E[e.edge_idx].v2);         long long l2 = (type == 1?E[e.edge_idx].l1:E[e.edge_idx].l2);         int v2 = (type == 1?E[e.edge_idx].v1:E[e.edge_idx].v2);         if(curM < l){             curWays = (curWays + tmpCache)%mod;             tmpCache = 0;             curWays %= mod;             curPrevWays = (curWays*1LL*POW(m, l-curM-(l==n+1?2:1)))%mod;             curWays = (curWays*1LL*POW(m, l-curM-(l==n+1?1:0)))%mod;             curM = l;         }         if(type == 0 && !cache.count(make_pair(l, v))){             cache[make_pair(l, v)] = curPrevWays;         }else if(type == 1){             if(!cache.count(make_pair(l, v)))                 cache[make_pair(l, v)] = curPrevWays;             int tmpInc = cache[make_pair(l2, v2)];             // cout<<tmpInc<<endl;             cache[make_pair(l, v)] += tmpInc;             cache[make_pair(l, v)] %= mod;             tmpCache += tmpInc;             tmpCache %= mod;         }         // cout<<curM<<" "<<curWays<<endl;     }     if(tmpCache)         curWays = (curWays + tmpCache)%mod;     printf("%d\n", curWays); }
// Alfonso2 Peterssen (mukel) #include <iostream> #include <cstdio> #include <sstream>  #include <algorithm> #include <vector> #include <deque> #include <queue> #include <stack> #include <set> #include <map>  #include <cstdlib> #include <cstring> #include <cmath> #include <cassert>  using namespace std;  typedef long long int64;  #define endl '\n' #define SZ(c) ((int)((c).size())) #define REP(i, n) for (int i = 0; i < (int)(n); ++i) #define FOR(i, b, e) for (int i = (int)(b); i <= (int)(e); ++i) #define ALL(c) (c).begin(), (c).end()  struct fastCin { 	char cur; 	inline char nextChar() { return cur = getc_unlocked(stdin); } 	inline char peekChar() { return cur; } 	inline operator bool() { return (peekChar() != 0); } 	inline static bool isBlank(char c) { return (c < '0' && c); } 	inline bool skipBlanks() { while (isBlank(nextChar())); return peekChar() != 0; } 	fastCin() { cur = 0; } 	char tmp[1 << 8]; 	inline fastCin& operator >> (int & n) { 		if (skipBlanks()) { 			int sign = +1; 			if (peekChar() == '-') { 				sign = -1; 				n = nextChar() - '0'; 			} 			else 				n = peekChar() - '0'; 			while (!isBlank(nextChar())) { 				n *= 10; 				n += peekChar() - '0'; 			} 			n *= sign; 		} 		return *this; 	} 	inline fastCin& operator >> (int64 & n) { 		if (skipBlanks()) { 			int sign = +1; 			if (peekChar() == '-') { 				sign = -1; 				n = nextChar() - '0'; 			} 			else 				n = peekChar() - '0'; 			while (!isBlank(nextChar())) { 				n *= 10; 				n += peekChar() - '0'; 			} 			n *= sign; 		} 		return *this; 	} 	#define cin cin2 } cin2;  const int64 	MAXN = 2 * 3114LL * 3114 * 3114 * 3114 * 3114;  vector< int64 > powerNums;  int64 squareRoot(int64 n) { 	int64 r = sqrt(n); 	//while (r * r < n) ++r; 	//while (r * r > n) --r; 	return r; }  bool isPowerNum(int64 n) { 	if (n < 4) return false; 	int64 sq = squareRoot(n); 	return sq * sq == n || binary_search(ALL(powerNums), n); }  int64 getPowerNumsLessThan(int64 n) { 	if (n < 4) return 0;  	int64 sq = squareRoot(n);  	int64 r = lower_bound(ALL(powerNums), n) - powerNums.begin();  	r += sq - 1; 	if (sq * sq == n) 		--r;  	return r; }  int64 getNonPowerIndex(int64 n) { 	assert( !isPowerNum(n) ); 	return n - getPowerNumsLessThan(n) + 1; }  int simulate(int64 n) { 	int64 nIndex = getNonPowerIndex(n);  	//cout << "nIndex = " << nIndex << endl;  	int64 pos = 2;  	int steps = 0;  	int64 lo, hi;  	while (1) 	{ 		steps++;  		if (pos == nIndex) 			return steps;  		if (pos < nIndex) 			pos *= 2; 		else 		{ 			lo = pos / 2; 			hi = pos; 			break; 		} 	}  	while (lo + 1 < hi) 	{ 		int64 mid = (lo + hi) / 2;  		steps++;  		if (mid == nIndex) 			return steps;  		if (mid < nIndex) 			lo = mid; 		else 			hi = mid; 	}  	return steps + 1; }  void calcNonSquarePowerNums() { 	powerNums.reserve(1 << 20);  	for (int64 a = 2, f; (f = a * a * a) <= MAXN; ++a) 	{ 		int64 limit = MAXN / a + 1; 		for (;;) { 			int64 sq = squareRoot(f);  			if (sq * sq != f) 				powerNums.push_back(f);  			if (f >= limit) 				break; 			f *= a; 		} 	}  	sort(ALL(powerNums)); 	powerNums.erase(unique(ALL(powerNums)), powerNums.end());  	//cout << SZ(powerNums) << endl; }  int main() { 	calcNonSquarePowerNums();  	int T; 	for (cin >> T; T--;) 	{ 		int64 P; cin >> P; 		if (isPowerNum(P)) 			cout << getPowerNumsLessThan(P) + 1 << endl; 		else 			cout << simulate(P) << endl; 	}  	return 0; } 
#include<bits/stdc++.h> using namespace std; #define ll long long int x[1003]; int y[1003]; int main() { 	int t,n,a,b;     cin>>t;     while(t--)     {         cin>>n;         for(int i=0;i<n;i++)            cin>>x[i]>>y[i];         sort(x,x+n);         sort(y,y+n);         if(n%2==0)         {         a = x[n/2] - x[(n-1)/2] + 1;         b =  y[n/2] - y[(n-1)/2] + 1;         }         else         {         a=1;         b=1;         }         ll ans = 1ll*a*b;         cout<<ans<<endl;     } } 
#include<iostream> #include<stdio.h> #include<stdlib.h> #include<algorithm> #include<map> #include<vector> #include<math.h>  using namespace std;   typedef struct node_{ 	int left_lvalue; 	int left_svalue; 	int right_lvalue; 	int right_svalue; }node;  typedef struct input_{ 	int query; 	int pos; 	int idx; }input;  int in() {     char c;     while(c=getchar(),(c<'0'||c>'9')&&(c!='b')&&(c!='-'));     bool flag=(c=='-');     if(flag) c=getchar();     int x=0;     while(c>='0'&&c<='9') {         x=x*10+c-48;         c=getchar();     }     return flag?-x:x; }   void insert_element(int t[],int ele,int l,int r,int idx) { 	t[idx]++; 	if(l==r) 	return; 	else 	{ 		int mid=(l+r)/2; 		if(ele<=mid) 		insert_element(t,ele,l,mid,2*idx+1); 		else 		insert_element(t,ele,mid+1,r,2*idx+2); 	} }  int getS( int *t, int ele,int l, int r,int idx) { 	if(l==r ) 	return 0; 	int mid=(l+r)/2; 	if(ele<=mid) 	return getS(t,ele,l,mid,2*idx+1); 	else 	return t[2*idx+1]+getS(t,ele,mid+1,r,2*idx+2); }  int getL(int *t, int ele,int l, int r,int idx) { 	if(l==r) 	return 0; 	int mid=(l+r)/2; 	if(ele<=mid) 	return t[2*idx+2]+getL(t,ele,l,mid,2*idx+1); 	else 	return getL(t,ele,mid+1,r,2*idx+2); } int getcount(int c) { 	float temp=log(c); 	float t=log(2); 	temp=temp/t; 	int ans=(int)temp; 	if(ans==temp) 	return pow(2,ans); 	else 	return pow(2,ans+1); }  int ar[200001]; int arr[200001]; node query_answer [200001][2]; node self_answer [200001]; int leftTree[801000]={0}; int rightTree[801001]={0};  int main() {  	int n,m,i,j,a,b; 	cin >> n >> m; 	long long int total_inversion_count=0; 	map<int ,int > hash_map; 	 	for(i=0;i<n;i++) 	{ 	arr[i]=in(); 	ar[i]=arr[i]; 	} 	 	sort(arr,arr+n); 	hash_map.insert(pair<int,int>(arr[0],1)); 	int last_val=arr[0]; 	int count=1; 	for(i=1;i<n;i++) 	{ 		if(arr[i]!=last_val) 		{ 		hash_map.insert(pair<int,int>(arr[i],++count)); 		last_val=arr[i]; 		} 	} 	int new_size=count; 	 	for(i=0;i<n;i++) 	{ 	ar[i]=hash_map.find(ar[i])->second;  	} 	 	 	 	 	vector <input> connection[n+1]; 	int query [m][2]; 	for(i=0;i<m;i++) 	{ 		a=in(); 		b=in(); 		query[i][0]=a; 		query[i][1]=b; 		input A,B; 		A.idx=a; 		A.query=i; 		A.pos=0; 		B.idx=b; 		B.pos=1; 		B.query=i; 		connection[a].push_back(B); 		connection[b].push_back(A); 		 	} 	 	  	int new_count=getcount(count); 	//cout << "count" << count << endl; 	//cout << "new_count=" << new_count << endl; 	 	for(i=1;i<=n;i++) 	{ 		int size=connection[i].size(); 		for(j=0;j<size;j++) 		{ 			int q=connection[i][j].query; 			int p=connection[i][j].pos; 			int pos=connection[i][j].idx-1; 			query_answer[q][p].left_svalue=getS(leftTree,ar[pos],1,new_count,0); 			query_answer[q][p].left_lvalue=getL(leftTree,ar[pos],1,new_count,0); 			  		} 		self_answer[i].left_lvalue=getL(leftTree,ar[i-1],1,new_count,0); 		self_answer[i].left_svalue=getS(leftTree,ar[i-1],1,new_count,0); 		//cout << self_answer[i].left_lvalue << endl;  		//cout << "t[0]=" << leftTree[0] << endl; 		total_inversion_count+=self_answer[i].left_lvalue; 		 		insert_element(leftTree,ar[i-1],1,new_count,0); 	} 	 	//cout << "total " << total_inversion_count; 	 	 	 	for(i=n;i>0;--i) 	{ 		int size=connection[i].size(); 		for(j=0;j<size;j++) 		{ 			int q=connection[i][j].query; 			int p=connection[i][j].pos; 			int pos=connection[i][j].idx-1; 			query_answer[q][p].right_svalue=getS(rightTree,ar[pos],1,new_count,0); 			query_answer[q][p].right_lvalue=getL(rightTree,ar[pos],1,new_count,0);	 			 		} 		self_answer[i].right_lvalue=getL(rightTree,ar[i-1],1,new_count,0); 		self_answer[i].right_svalue=getS(rightTree,ar[i-1],1,new_count,0); 		insert_element(rightTree,ar[i-1],1,new_count,0); 	} 	 	 	for(i=0;i<m;i++) 	{ 		int index_a=query[i][0]; 		int index_b=query[i][1]; 		int value_a=ar[index_a-1]; 		int value_b=ar[index_b-1]; 		long long int answer=total_inversion_count; 		int a_indexa_r_big=self_answer[index_a].right_lvalue; 		int a_indexb_r_big=query_answer[i][0].right_lvalue; 		int a_indexa_r_small=self_answer[index_a].right_svalue; 		int a_indexb_r_small=query_answer[i][0].right_svalue; 		int b_indexb_l_small=self_answer[index_b].left_svalue; 		int b_indexa_l_small=query_answer[i][1].left_svalue; 		int b_indexb_l_big=self_answer[index_b].left_lvalue; 		int b_indexa_l_big=query_answer[i][1].left_lvalue; 		 		 		 		answer=answer+(a_indexa_r_big-a_indexb_r_big); 		answer=answer+(b_indexb_l_small-b_indexa_l_small); 		answer-=(a_indexa_r_small-a_indexb_r_small); 		answer-=(b_indexb_l_big-b_indexa_l_big); 		  		 		if(value_a>value_b) 		answer++; 		else if(value_b>value_a) 		answer--; 		printf("%lld\n",answer);  	} 	 	return 0; }
//Amit Kumar Gupta               #include<bits/stdc++.h> using namespace std; typedef long long LL; typedef pair<int,int> II; #define REP(i,i1,n) for(int i=i1;i<n;i++) #define REPB(i,i1,n) for(int i=i1;i>=n;i--) #define PB push_back #define MP make_pair #define ALL(c) (c).begin(),(c).end() #define F first #define S second #define SZ(a) (LL)a.size() #define EPS 1e-12 #define MOD 1000000007 #define TR1(x) cerr<<#x<<" : "<<x<<endl #define TR2(x,y) cerr<<#x<<" : "<<x<<" | "<<#y<<" : "<<y<<endl #define FAST_IO ios_base::sync_with_stdio(false);cin.tie(NULL) #define SI(c) scanf("%d",&c) #define SII(c,d) scanf("%d%d",&c,&d) #define SLL(c) scanf("%lld",&c) #define PIN(c) printf("%d\n",c) #define PLLN(c) printf("%lld\n",c) #define N 100010 #define INIT1(array,ST,END,val) for(int i=ST;i<END;i++)array[i]=val #define INIT2(array,nn,mm,val) for(int i=0;i<nn;i++)for(j=0;j<mm;j++)array[i][j]=val //------------------------------------------------------MAIN CODE STARTS HERE--------------------------------------- vector<pair<int,int> > g[N]; vector<int> h[N]; vector<int> v[N]; map<pair<int,int>,int> mp; int time1,low[N],dis[N],bridge[2*N+10],vis[N],comp_no,n,m,par[N]; queue<int> q[N]; void dfs(int z) { 	vis[z]=1; 	time1++; 	low[z]=time1; 	dis[z]=time1; 	REP(i,0,g[z].size()) { 		if(!vis[g[z][i].F]) { 			par[g[z][i].F]=z; 			dfs(g[z][i].F); 			low[z]=min(low[z],low[g[z][i].F]); 			if(low[g[z][i].F]>dis[z]&&mp[MP(z,g[z][i].F)]==1) 				bridge[g[z][i].S]=1; 		} 		else if(g[z][i].F!=par[z]) 			low[z]=min(dis[g[z][i].F],low[z]); 	} } void dfs1(int z) { 	vis[z]=1; 	int curr_comp=comp_no; 	q[curr_comp].push(z); 	while(!q[curr_comp].empty()) { 		int ver=q[curr_comp].front(); 		v[curr_comp].PB(ver); 		q[curr_comp].pop(); 		for(int i=0;i<g[ver].size();i++) { 			int edge_no=g[ver][i].S; 			if(vis[g[ver][i].F]) 				continue; 			if(bridge[edge_no]) { 				comp_no++; 				h[curr_comp].PB(comp_no); 				h[comp_no].PB(curr_comp); 				dfs1(g[ver][i].F); 			} 			else { 				q[curr_comp].push(g[ver][i].F); 				vis[g[ver][i].F]=1; 			} 		} 	} } int main() { 	SI(n);SI(m); 	REP(i,0,m) { 		int x,y; 		SI(x);SI(y);         mp[MP(x,y)]++;         mp[MP(y,x)]++; 		g[x].PB(MP(y,i)); 		g[y].PB(MP(x,i)); 	} 	par[1]=-1;     int fl2=-1;     REP(i,1,n+1) {         if(!vis[i]) 	        dfs(i),fl2++;     } 	INIT1(vis,0,n+1,0); 	dfs1(1);     int fl=0;     REP(i,0,comp_no+1) {         if(h[i].size()>2)             fl=1;     }     if(fl==0&&fl2==0)         printf("YES\n");     else         printf("NO\n");     return 0; } 
#include <bits/stdc++.h>  #define fi first #define se second #define pb push_back #define mp make_pair #define pii pair<int,int> #define pll pair<ll,ll> #define MOD 1000000007 #define ll long long int #define MAXINT 1000000000001ll #define SET(x,y) memset(x,y,sizeof(x));  using namespace std;  ll DP[11][2][1<<16]; int sc[1<<16],ge[11][1<<16]; string s;  int inline score(int mask) { 	if(sc[mask]!=-1)	return sc[mask]; 	int ans,i,j,n=0; 	for(i=0;i<=15;i++) 		if(mask&(1<<i)) 			for(j=i+1;j<=15;j++) 				if(mask&(1<<j)) 					n|=(1<<(i^j)); 	ans=0; 	for(i=0;i<=15;i++)	if(n&(1<<i))	ans+=i; 	return sc[mask]=ans; }  int simple(string s) { 	int i,x=0,mask=1,l=s.size(); 	for(i=l-1;i>=0;i--) { 		x=x^(s[i]-'0'); 		mask|=(1<<x); 	} 	return score(mask); }  int inline getIt(int n,int m) { 	if(ge[n][m]!=-1)	return ge[n][m]; 	int ans = 1,i; 	for(i=1;i<=15;i++) 		if(m&(1<<i)) 			ans |= (1<<(i^n)); 	return ge[n][m]=ans; }  ll inline workOut(int p,int m,int f) { 	ll &ans = DP[p][f][m]; 	if(ans!=-1)	return ans; 	if(p==s.size()) { 		if(m==1)	return ans = 1; 		else		return ans = 0; 	} 	int i,x,li,y; 	if(f==0)	li=s[p]-'0'; 	else		li=9; 	ans = 0; 	for(i=0;i<=li;i++) { 		if((m&(1<<i)) == 0 )	continue; 		x = getIt(i,m); 		y = x|(1<<i); 		if(f || i<li)	ans = (ans + workOut(p+1,x,1) + ((x!=y)?workOut(p+1,y,1):0)); 		else		ans = (ans + workOut(p+1,x,0) + ((x!=y)?workOut(p+1,y,0):0)); 	} 	return ans%=MOD; }  ll work(string s1) { 	ll i,ans=0,c,j; 	SET(DP,-1); 	s=s1; 	for(i=1;i<(1<<16);i+=2)	{ 		c=0; 		for(j=1;j<16;j++)	if(i&(1<<j))	c++; 		if(c<=s1.size()) { 			workOut(0,i,0); 			ans = (ans + (DP[0][0][i] * score(i))); 		} 	} 	return ans%MOD; }  void solve(void) { 	string s1,s2; 	ll ans; 	cin>>s1>>s2; 	ans = (work(s2) + MOD - work(s1) + simple(s1))%MOD; 	cout<<ans<<endl; }  int main() { 	int i,t; 	SET(ge,-1);SET(sc,-1); 	for(t=0;t<(1<<16);t++)	{ 		score(t); 		for(i=0;i<=9;i++) 			getIt(i,t); 	} 	cin>>t; 	while(t--)	solve(); 	return 0; } 
 #include <vector> #include <iostream> #include <algorithm> #include <cstdio> #include <cstdlib> #include <ctime> #include <cmath> #include <memory.h> #include <string> #include <set> #include <map> #include <complex> #include <bitset>  using namespace std;  int m[53][53][2];  int ver(char c) { 	if (c>='a'&&c<='z') return c-'a'; 	return c-'A'+26; }  int main() { //	freopen("input.txt","r",stdin); //	freopen("output.txt","w",stdout); 	int T; 	scanf("%d",&T); 	while(T--) { 		int n,e; 		char a,b; 		cin >> n; 		bitset<3000> A[55]; 		memset(m,0,sizeof(m)); 		for(int i=0;i<n;++i) { 			cin >> a >> b; 			m[ver(a)][ver(b)][0]++; 			m[ver(b)][ver(a)][0]++; 		} 		cin >> e; 		for(int i=0;i<e;++i) { 			cin >> a >> b; 			m[ver(a)][ver(b)][1]++; 			m[ver(b)][ver(a)][1]++; 		} 		for(int i=0;i<52;++i) 			for(int j=0;j<52;++j) { 				m[i][j][0]%=2; 				m[i][j][1]=m[i][j][1]>0; 			} 		for(int i=0;i<52;++i) { 			int s=0; 			for(int j=0;j<52;++j) { 				s+=m[i][j][0]; 				if (i!=j&&m[i][j][1]) A[i][min(i,j)*52+max(i,j)]=1; 			} 			A[i][2999]=s&1; 		} 		bool sol=true; 		int last=0; 		for(int i = 0; i < 52&&last<2999; ++i,++last) { 			int k = i; while(k < 52 && !A[k][last]) ++k; 			if (k == 52) { --i; continue; } 			swap(A[k], A[i]); 			for(int j = i + 1; j < 52; ++j) 				if (A[j][last]) A[j] ^= A[i]; 		} 		for(int i=0;i<52;++i) { 			bool ze=true; 			for(int j=0;j<2999;++j) 				if (A[i][j]) ze=false; 			if (ze&&A[i][2999]) sol=0; 		} 		if (sol) puts("YES"); 		else puts("NO"); 	} 	return 0; } 
#include <iostream> #include <cmath> #include <algorithm> #include <vector> #include <set> #include <map> #include <cstdlib> #include <cstdio> #include <iomanip> #include <string>  using namespace std;  #define lli long long int  double triarea(pair<int,int> a,pair<int,int> b,pair<int,int> c){ 	return abs((a.first*b.second+b.first*c.second+c.first*a.second-a.first*c.second-b.first*a.second -c.first*b.second)/2.0); } inline lli cross(pair<int,int> a,pair<int,int> b){ 	if((double)a.second/a.first > (double)b.second/b.first) 		return 1; 	return -1; } int main() { 	ios::sync_with_stdio(false); 	int n,m; 	cin>>n>>m; 	vector<pair<int,int> > red(n+1),black(m+1); 	for(int i=1;i<=n;i++){ 		cin>>red[i].first>>red[i].second; 		red[i].first+=1e4+1; 		red[i].second+=1e4+1; 	} 	for(int i=1;i<=m;i++){ 		cin>>black[i].first>>black[i].second; 		black[i].first+=1e4+1; 		black[i].second+=1e4+1; 	} 	int arr[n+1][n+1],count; 	double a1,a2,a3,tl,x; 	for(int i=1;i<=n;i++){ 		for(int j=1;j<=n;j++){ 			count=0; 			tl=triarea(make_pair(0,0),red[i],red[j]); 			//cout<<tl; 			for(int k=1;k<=m;k++){ 				a1=triarea(make_pair(0,0),red[j],black[k]); 				a2=triarea(red[j],black[k],red[i]); 				a3=triarea(make_pair(0,0),red[i],black[k]); 				a1=a1+a2+a3; 				if(tl==a1){ 					count++; 				} 			} 			arr[i][j]=count; 			//cout<<count; 		} 		//cout<<"\n"; 	} 	int q; 	cin>>q; 	while(q--){ 		int k,ans=0; 		cin>>k; 		lli poly[k]; 		for(int i=0;i<k;i++){ 			cin>>poly[i]; 		} 		for(int i=0;i<k;i++){ 			lli a = poly[i], b = poly[(i+1)%k]; 			if(cross(red[a],red[b]) > 0) 				ans += arr[a][b]; 			else 				ans -= arr[a][b]; 		}	 		cout<<ans<<"\n"; 	} 	//cout<<"\n"<<triarea(make_pair(1,2),make_pair(4,3),make_pair(2,5)); 	return 0; }
#include<bits/stdc++.h> //#define DEBUG //#ifdef DEBUG //code to debug //#endif //#undef DEBUG using namespace std;  const int mod=1e9+7,maxn=16,ln=18; #define F(i,p,n) for(int i=p;i<n;i++) #define I(i,p,q) for(int i=p;i>=q;i--) #define Ss(x) scanf("%s",x) #define S(x) scanf("%d",&x) //#define getcx getchar_unlocked #define getcx getchar /*inline void S(int& n) {     n=0; int ch = getcx(); int sign = 1;     while(ch < '0' || ch > '9') { if(ch == '-') sign=-1; ch = getcx(); }     while(ch >= '0' && ch <= '9') { n = (n << 3) + (n << 1) + ch - '0', ch = getcx(); }     n = n * sign; }*/ #define Ps(x) printf("%d  ",x) #define P(x) printf("%d\n",x) typedef long long int LL; #define Debug(x) cout << #x << "=" << x << endl #define Debugarr(x,n) cout<<"array "<<#x<<":"<<endl; F(i,0,n) cout<<i<<". "<<x[i]<<endl; cout<<endl #define Debugarr2(x,m,n) cout<<"array "<<#x<<":"<<endl; F(i,0,m) {F(j,0,n) cout<<x[i][j]<<" "; cout<<endl;} cout<<endl #define pii pair<long long int,long long int> #define chk(x,n) (x[n>>5]&(1<<(n&31))) //unsigned int #define set(x,n) (x[n>>5]|=(1<<(n&31)))//32 bit const int inf= int(1e9),shift=30,etf=mod-1;  int a[20]; int m,n; int dp[1<<maxn],comp[1<<maxn];  vector<pii> submask;  int temp[1<<maxn],cnt;  void _clear() {     F(i,0,1<<maxn)     {         dp[i]=-1;     }     dp[0]=0;     submask.clear(); }  void disjoint(int num) {     cnt=0;     int mask=1<<(n-1);     temp[cnt++]=0;     if(!(mask&num))     {         temp[cnt++]=1;     }      mask>>=1;      int ab[1<<maxn];      while(mask)     {         int pcnt=0;         F(i,0,cnt)         {             ab[pcnt++]=temp[i]<<1;         }          if(!(mask&num))         {             F(i,0,cnt)             {                 ab[pcnt++]=(temp[i]<<1)+1;             }         }          F(i,0,pcnt)         temp[i]=ab[i];          cnt=pcnt;          mask>>=1;     }      //Debugarr(temp,cnt); }  void _solve() {      //int prev=0,cur=1;      //Debugarr(dp,1<<n);      F(i,0,m)     {         int num=submask[i].second;         //dp[cur][num]=max(dp[cur][num],a[comp[num]]);         disjoint(num);         F(j,0,cnt)         {             if(dp[temp[j]]!=-1)                 dp[temp[j]|num]=max(dp[temp[j]|num],dp[temp[j]]+a[comp[temp[j]]+comp[num]]);         }         //Debugarr(dp,1<<n);     }      int tot=0,mx=0;     F(i,1,n+1)     tot+=a[i];      F(i,0,1<<n)     {         mx=max(dp[i],mx);     }      P(tot-mx); }  void pre() {     F(i,0,1<<maxn)     {         int sz=0,num=i;         while(num)         {             if(num&1)                 sz++;             num>>=1;         }         comp[i]=sz;     } }  int main() {     pre();     int t;     S(t);     while(t--)     {         _clear();         S(n);         F(i,1,n+1)         {             S(a[i]);             a[i]*=-1;         }          sort(a+1,a+n+1);          F(i,1,n+1)             a[i]*=-1;            S(m);          F(i,0,m)         {             int sz,sub=0;             S(sz);             F(j,0,sz)             {                 int item;                 S(item);                 item--;                 sub|=(1<<item);             }             submask.push_back(pii (sz,sub));         }          sort(submask.begin(),submask.end());          /*Debugarr(a,n+1);          F(i,0,m)         {             Ps(submask[i].first),P(submask[i].second);         }*/          _solve();       }     return 0; } 
#include<stdio.h>  int t; unsigned long long int n,a[2][2],b[2][2],c[2][2],rem=1000000007,fib[12],ans1,ans2,tmp1,tmp2,t1,t2,t11,t22,modinv; unsigned long long int bigrem=rem;  inline void initialize(unsigned long long int a1[2][2]) { a1[0][0]=1; a1[0][1]=1; a1[1][0]=1; a1[1][1]=0; }  inline long long int divmod(long long int x) { if(x==1) return 5; long long int div=divmod(x/2); if(x%2==0) return (div*div)%rem; return (((5*div)%rem)*div)%rem; }  inline void mat_mul() { for(int i=0;i<2;i++) { for(int j=0;j<2;j++) { c[i][j]=0; for(int k=0;k<2;k++) { c[i][j]=(c[i][j]+(b[i][k]*b[k][j])%rem)%rem; } } } for(int i=0;i<2;i++) { for(int j=0;j<2;j++) { b[i][j]=c[i][j]; } } }  inline void mat_mul2() { for(int i=0;i<2;i++) { for(int j=0;j<2;j++) { c[i][j]=0; for(int k=0;k<2;k++) { c[i][j]=(c[i][j]+(b[i][k]*a[k][j])%rem)%rem; } } } for(int i=0;i<2;i++) { for(int j=0;j<2;j++) { b[i][j]=c[i][j]; } } } inline void mat_pow(unsigned long long int x) { if(x==1) {initialize(b);return;} if(x%2==0) { mat_pow(x/2); mat_mul(); } else { mat_pow(x/2); mat_mul(); mat_mul2(); } }  int main() { initialize(a); modinv=divmod(rem-2); scanf("%d",&t); for(int i=0;i<t;i++) { scanf("%lld",&n); if(n==1) {printf("0\n");continue;} if(n==2) {printf("5\n");continue;} mat_pow(n-2); fib[1]=(b[0][0]+b[0][1])%rem; fib[0]=(b[1][0]+b[1][1])%rem; for(int i=2;i<=5;i++) { fib[i]=(fib[i-1]+fib[i-2])%rem; }  ans1=(n+3)%(bigrem); t1=(fib[5]+(2*fib[4])%(bigrem))%(bigrem); //printf("%lld\n",ans1*t1); ans1=(ans1*t1)%(bigrem); t1=(2*fib[4])%(bigrem); ans1=(ans1+t1)%(bigrem);  //if(ans1%5!=0) //printf("dsdf\n"); //ans1/=5; ans1=(ans1*modinv)%rem; //ans1%=rem; //ans1=((((((n+3)%(bigrem))*((fib[5]+(2*fib[4])%(bigrem))%(bigrem))%(bigrem))+(2*fib[4])%(bigrem))%(bigrem))/5)%rem; //ans1=(((n+3)*(fib[5]+2*fib[4])+2*fib[4])/5)%rem; t1=(3*fib[1])%rem; t11=(2*fib[2])%rem; t1=(t1+t11)%rem; t11=(fib[3]+fib[4])%rem; t1=(t1+t11)%rem; ans1=(rem+ans1-t1)%rem; //ans1=(rem+ans1-((3*fib[1])%rem+((2*fib[2])%rem+(fib[3]+fib[4])%rem)%rem)%rem)%rem;  ans2=(n+2)%(bigrem); t2=(fib[4]+(2*fib[3])%(bigrem))%(bigrem); //printf("%lld\n",ans2*t2); ans2=(ans2*t2)%(bigrem); t2=(2*fib[3])%(bigrem); ans2=(ans2+t2)%(bigrem);   //if(ans2%5!=0) //printf("dsdf\n"); //ans2/=5; ans2=(ans2*modinv)%rem; //ans2%=rem; //ans2=((((((n+2)%(bigrem))*((fib[4]+(2*fib[3])%(bigrem))%(bigrem))%(bigrem))+(2*fib[3])%(bigrem))%(bigrem))/5)%rem; //ans2=(((n+2)*(fib[4]+2*fib[3])+2*fib[3])/5)%rem; t2=(3*fib[0])%rem; t22=(2*fib[1])%rem; t2=(t2+t22)%rem; t22=(fib[2]+fib[3])%rem; t2=(t2+t22)%rem; ans2=(rem+ans2-t2)%rem; //ans2=(rem+ans2-((3*fib[0])%rem+((2*fib[1])%rem+(fib[2]+fib[3])%rem)%rem)%rem)%rem; printf("%lld\n",(ans1+ans2)%rem); } return 0; }
#include<iostream> #include<cstdio> #include<cmath> #include<cstring> #include<cstdlib> #include<iomanip> #include <limits> #include<set> typedef std::numeric_limits< double > dbl; using namespace std; double **mul(double **a,double **b); double **pw(double **a,long long b,double **p) { int i;     if(b==0) return p; double **c; c=pw(a,b/2,p); if(b&1) return mul(mul(c,c),a); else return mul(c,c); } double **mul(double *a[26],double *b[26]) { int i,j,k; double **c; c=(double **)malloc(26*sizeof(double *)); for(i=0;i<26;i++) c[i]=(double *)malloc(26*sizeof(double)); for(i=0;i<26;i++) { for(j=0;j<26;j++) { c[i][j]=0;     for(k=0;k<26;k++) { c[i][j]+=(a[i][k]*b[k][j]);     } } } return c; } int main() { int i,j,t,n; long long k; cin>>t; while(t--) { char str[4]; cin>>n; cin>>k; cin>>str; double **matrix; matrix=(double **)malloc(26*sizeof(double *)); for(i=0;i<26;i++) matrix[i]=(double *)malloc(26*sizeof(double)); double **p; p=(double **)malloc(26*sizeof(double *)); for(i=0;i<26;i++) p[i]=(double *)malloc(26*sizeof(double)); for(i=0;i<26;i++) { for(j=0;j<26;j++) cin>>matrix[i][j]; } double **ans; ans=(double **)malloc(26*sizeof(double *)); for(i=0;i<26;i++) ans[i]=(double *)malloc(26*sizeof(double)); for(i=0;i<26;i++) { for(j=0;j<26;j++) { if(i==j) p[i][j]=1.0; else p[i][j]=0.0; }//cout<<endl; } ans=pw(matrix,k,p); /*for(i=0;i<26;i++) { for(j=0;j<26;j++) cout<<ans[i][j]<<" "; cout<<endl; }*/ double answer=0.0; set<string>s1; while(n--) { char temp[4]; double tem=1.0000000000000; scanf("%s\n",temp); if(strlen(temp)!=strlen(str)) continue; if(s1.find(temp)!=s1.end()) continue; s1.insert(temp); for(i=0;i<strlen(str);i++) { tem=tem*ans[str[i]-'a'][temp[i]-'a']; } answer+=tem; } printf("%0.12f\n",answer); } return 0; }  
#include<cstdio>   #include<iostream>   using namespace std; typedef long long ll; const int num = 1000000007;  int main(){ 	int D,K,K1,i,j,k,l,m,t,x,y,tt,mm; 	scanf("%d%d", &D, &K); 	if ((K%3) != 0) {cout<<0; return 0;} 	K=K/3;  	int ans1[D+1][D+1][D+1][D+1][27];  	//separation is linear b/w 0 and 19  	for (i=0; i<=D; i++) for (j=0; j<=D; j++) for (m=0; m<20; m++) for (k=0; k<=D; k++) for (l=0; l<=D; l++)	//till 20 		ans1[i][j][k][l][m]=0; 	for (i=0; i<=D; i++) for (j=0; j<=D; j++) for (m=0; m<20; m++) for (k=0; k<=D; k++) for (l=0; l<=D; l++)	//till 20 		if (m==0 && i==k && j==l) ans1[i][j][k][l][m]=1; 		else { 			if (m>0 && k<D) ans1[i][j][k][l][m] = (ans1[i][j][k][l][m] + ans1[i][j][k+1][l][m-1]) % num; 			if (k>0 && l<D) ans1[i][j][k][l][m] = (ans1[i][j][k][l][m] + ans1[i][j][k-1][l+1][m]) % num; 			if (l>0) 		ans1[i][j][k][l][m] = (ans1[i][j][k][l][m] + ans1[i][j][k][l-1][m]) % num; 		}  	if (K<20) {cout<<ans1[0][0][0][0][K]; return 0;}  	int ans2[D+1][D+1];	//answer(no. of ways) for ending position=0,0. 	for (i=0; i<=D; i++) for (j=0; j<=D; j++) 		ans2[i][j] = ans1[i][j][0][0][15];  	K-=15; 	K1 = K % 16; 	if (K1 < 4) K1=K1 + 16;	//4 <= K1 <= 19, K1 is remainder either from 16 or 32. 	int start[D+1][D+1]; 	for (i=0; i<=D; i++) for (j=0; j<=D; j++) 		start[i][j] = ans1[0][0][i][j][K1 - 1]; 	K=K - K1;					//now K is multiple of 16.  	//separation is in power of 2, b/w 2^4-1 and 2^30-1 	for (i=0; i<=D; i++) for (j=0; j<=D; j++) for (k=0; k<=D; k++) for (l=0; l<=D; l++) 		ans1[i][j][k][l][0] = ans1[i][j][k][l][15];	//now m=0 is separation 15, m=1 is separation 31, and so on.. 	for (m=1; m<27; m++) for (i=0; i<=D; i++) for (j=0; j<=D; j++) for (k=0; k<=D; k++) for (l=0; l<=D; l++) 		ans1[i][j][k][l][m]=0; 	for (m=1; m<27; m++) for (i=0; i<=D; i++) for (j=0; j<=D; j++) for (k=0; k<=D; k++) for (l=0; l<=D; l++) 		for (x=1; x<=D; x++) for (y=0; y<=D; y++){ 			tt = ll( ans1[i][j][x][y][m-1] ) * ll( ans1[x-1][y][k][l][m-1] ) % num; 			tt += ans1[i][j][k][l][m]; 			ans1[i][j][k][l][m] = tt % num; 			}  	int temp[D+1][D+1];  	for (m=26; m>=0; m--){ 		mm=m+4; 		t=1<<mm;	//t = 2^mm 		if (t<=K){ 			for (i=0; i<=D; i++) for (j=0; j<=D; j++) 				{temp[i][j]=ans2[i][j]; ans2[i][j]=0;}  			for (i=0; i<=D; i++) for (j=0; j<=D; j++) for (x=1; x<=D; x++) for (y=0; y<=D; y++){ 				tt = ll( ans1[i][j][x][y][m] ) * ll( temp[x-1][y] ) % num; 				tt += ans2[i][j]; 				ans2[i][j] = tt % num; 			} 			K-=t; 		} 	}  	int ans = 0; 	for (x=1; x<=D; x++) for (y=0; y<=D; y++){ 		tt = ll( start[x][y] ) * ll( ans2[x-1][y] ) % num; 		tt += ans; 		ans = tt % num; 	}  	cout<<ans; 	return 0; } 
 #include <bits/stdc++.h> #include <stack> using namespace std; #define mod 1000000007 // Prints smaller elements on left side of every element void printPrevSmaller(int arr[], int n) {     // Create an empty stack     stack<int> S;     long long ans=1;     // Traverse all array elements     for (int i=n-1; i>=0; i--)     {         // Keep removing top element from S while the top         // element is greater than or equal to arr[i]         while (!S.empty() && arr[S.top()] >= arr[i])             S.pop();           // If all elements in S were greater than arr[i]         if (!S.empty())             ans=(ans*(S.top()-i+1))%mod;         S.push(i);     }     cout<<ans<<endl; }   /* Driver program to test insertion sort */ int arr[1000005]; int main() {         int i,j,k,n;     cin>>n>>k;     for(i=0;i<n;i++)     cin>>arr[i];     printPrevSmaller(arr, n);     return 0; }
#include<stdio.h> long long int minel(long long int a,long long int b,long long int c) {     long long int temp=a;      if(temp>b)     temp=b;      if(temp>c)     temp=c;      return temp; } long long int maxel(long long int a,long long int b,long long int c) {     long long int temp=a;      if(temp<b)     temp=b;      if(temp<c)     temp=c;      return temp; } int main() {     int t,n,i,j,k;     long long int arr[15];      scanf("%d",&t);      while(t--)     {         scanf("%d",&n);          for(int i=0;i<n;i++)         {             scanf("%lld",&arr[i]);         }          long long int dpmax[15]={0};         long long int dpmin[15]={0};          dpmin[0]=arr[0];         dpmax[0]=arr[0];          for(int i=1;i<n;i++)         {             if(arr[i]>=0)             {                 dpmin[i]=minel(dpmin[i-1]-arr[i],dpmin[i-1]*arr[i],dpmin[i-1]+arr[i]);                 dpmax[i]=maxel(dpmax[i-1]-arr[i],dpmax[i-1]*arr[i],dpmax[i-1]+arr[i]);             }              else             {                 dpmin[i]=minel(dpmin[i-1]-arr[i],dpmax[i-1]*arr[i],dpmin[i-1]+arr[i]);                 dpmax[i]=maxel(dpmax[i-1]-arr[i],dpmin[i-1]*arr[i],dpmax[i-1]+arr[i]);             }         }          printf("%lld\n",dpmin[n-1]);     }     return 0; } 
#include <iostream> #include <cstdio> #include <cstring> using namespace std;  int min(int a, int b){ 	return (a<b)?a:b; }  bool checkPalindrome(char *s, int start, int end){ 	for(int i=start,j = end ; i<=(start+end)/2; i++,j--){ 		if(s[i]!= s[j]) return false; 	} 	return true; }  int main(){ 	int te; 	scanf("%d",&te); 	while(te--){ 		int n; 		scanf("%d",&n); 		char s[n]; 		scanf("%s",s); 		int a[n]; 		a[0] = 1; 		for(int i=1; i<n; i++) 		{ 			a[i] = a[i-1]+1; //not the part of any palindrome; 			for(int j = 1; j<i; j++){ 				if(checkPalindrome(s, j, i)){ 					a[i] = min(a[i], 1+a[j-1]); 					//break; 				} 			} 			if(checkPalindrome(s, 0, i)) a[i] = 1; 		} 		printf("%d\n", a[n-1]); 	} 	return 0; } 
#include <stdio.h> #include <algorithm> #include <iostream> #include <vector> #include <set> #include <time.h> #include <map> #include <math.h> #include <string> #include <sstream> #include <assert.h> #include <queue> #include <string.h> #include <deque>   using namespace std; typedef long long ll; template<typename T> int size(T&a) {return (int)a.size(); } template<typename T> T sqr(T a) {return a * a; }   #define REP(i, a, b) for(int i = (a); i < (b); ++i) #define REPD(i, a, b) for(int i = (b) - 1; i >= a; --i) #define _(a, b) memset(a, b, sizeof(a)) #define vi vector<int>  #define pii pair<int, int> #define all(a) a.begin(), a.end() #define pb push_back #define mp make_pair #define fs first #define sc second typedef double ld; const int MAXN = 1002; ld cnk[MAXN][MAXN]; int a[MAXN]; int p[MAXN]; int main() { #ifdef air 	freopen("input.txt", "r", stdin); 	freopen("output.txt", "w", stdout); #endif  	REP(i, 0, MAXN) REP(j, 0, MAXN) cnk[i][j] = 0; 	REP(i, 0, MAXN) { 		cnk[i][i] = cnk[i][0] = 1; 		for(int j = 1; j < i; ++j) 			cnk[i][j] = cnk[i - 1][j] + cnk[i - 1][j - 1]; 	} 	int test; 	scanf("%d", &test); 	REP(t, 0, test) { 		int n,  k; 		scanf("%d%d", &n, &k); 		REP(i, 0, n) scanf("%d", &a[i]); 		REP(i, 0, k) scanf("%d", &p[i]); 		sort(a, a + n); 		sort(p, p + k); 		ld ex = 0; 		REP(i, 0, n) { 			ld sum = 0; 			int lf = max(0, - n + i + k); 			int rg = min(k - 1, i); 			REP(j, lf, rg + 1)  sum += p[j] * cnk[i][j] * cnk[n - i - 1][k - j - 1]; 			ex += sum * a[i]; 		} 		ex /= cnk[n][k] * 100; 		printf("%.3lf\n", ex); 	}  	 #ifdef air 	printf("\n\n%.3lf", 1.0 * clock() / CLOCKS_PER_SEC); #endif }
#include <stdio.h> #include <algorithm> using namespace std; #define ll long long #define LIM 100111  int I[LIM];  int main() {     for (int j = 0; j < LIM; j++) I[j] = -1;      int n, k;     scanf("%d%d", &n, &k);      ll total = n*(n+1LL) >> 1;     int pi = 0, pj = 1;     #define add_pair(ci,cj) do {\         total += pi * (pj - (cj));\         pi = ci;\         pj = (cj);\     } while (0)      int l = 0;     for (int j = 1; j <= n; j++) {         int a;         scanf("%d", &a);         if (a == k) {             l = j;         } else if (a > k) {             int i = max(I[a], l);             if (pi < i) {                 add_pair(i, j);             }              a -= k;             for (int v = 1; v * v <= a; v++) {                 if (a % v == 0) I[v] = I[a / v] = j;             }         }     }      add_pair(n, n+1);      printf("%lld\n", total); }
 #include<bits/stdc++.h>  typedef int LL; using namespace std; const int M = 1000000007; const int N = 100001; const int K = 400;  LL arr[K][N];  LL sz(LL n) { stringstream ss; ss << n;  string s=ss.str();  return s.size(); }  char ch(LL n,LL k) {  stringstream ss; ss << n; string s=ss.str();  //cout<<n<<' '<<s.size()<<' '<<k<<endl;  if(k < s.size()) 	return s[k]; else 	return 'a'; }   int main() { LL t,n,i,j,a,b,c,m;   cin>>n;  vector <LL> v(n),s(n);  for(i=0;i<n;i++) 	{scanf("%d",&v[i]); 	s[i]=sz(v[i]); 	}		  for(j=1;j<=sqrt(n);j++) 	for(i=0;i<n;i++)	 	  		arr[j][i] = (i>=j ? arr[j][i-j] : 0 ) + s[i] ;	  /* for(i=0;i<4;i++) 	cout<<s[i]<<' '; 		cout<<endl;  for(i=0;i<4;i++) 		cout<<arr[1][i]<<' '; 			cout<<endl; */ cin>>m;  for(i=0;i<m;i++) 	  	{ 	  	scanf("%d%d%d",&a,&b,&c); 	  	c--;a--;   		if(b>sqrt(n))   			{                          for(j=a;j<n;j+=b)                     	if(c>=s[j])	              	   c-=s[j];	              	else              		break;               	//cout<<j<<endl;               if(j<n && ch(v[j],c) != 'a')		 				cout<<ch(v[j],c)<<endl; 			else 				cout<<"So sad"<<endl;                            }           else                	{  			 LL h = (n-1-a)/b;  			 LL l = 0 ;   			 while(l<h)  			 	{  			 	 LL m = (l+h) >> 1;   			 	 LL tmp=c-10;  			 	   			 	 if (((a+(m-1)*b>=0 ? arr[b][a+(m-1)*b] : 0 ) -(a>b ? arr[b][a-b] : 0)) >= tmp )	  			 	 		h = m ;	  			 	 else	  			 	 		l = m + 1; 				}   			c -= ((a+(l-1)*b >= 0 ? arr[b][a+(l-1)*b] : 0 )-(a>=b ? arr[b][a-b] : 0)) ;    			for(j=a+l*b;j<n;j+=b)                     	if(c>=s[j])	              	   c-=s[j];	              	else              		break;    			//cout<<l<<' '<<v[j]<<' '<<c<<' '<<arr[b][a+(l-1)*b]<<endl;  			if( j<n && ch(v[j],c) != 'a' )		 				cout<<ch(v[j],c)<<endl; 			else 				cout<<"So sad"<<endl;           	}    	  	}	     } 
#include<iostream> #include<stdlib.h> using namespace std; #define lld long long int  int main() { 	lld tc,i,n,ans,curr_min,curr_max,h; 	 	cin>>tc; 	 	while(tc--) 	{ 		cin>>n; 		 		ans=0,curr_min=-1,curr_max=0; 		 		for(i=0; i<n; i++) 		{ 			cin>>h; 			 			if(curr_min==-1||curr_min>h) 			  curr_min=h; 			 			if(h>curr_max) 			  curr_max=h; 			else 			{ 				ans+=curr_max-h; 				curr_max=h; 			}   		} 		 		ans+=curr_max-curr_min; 		 		cout<<ans<<endl; 	} return 0;	 }
//Template by @sai krishna #include <map> #include <set> #include <queue> #include <cmath> #include <stack> #include <vector> #include <cstdio> #include <bitset> #include <sstream> #include <cassert> #include <cstring> #include <utility> #include <iterator> #include <iostream> #include <algorithm> #include <functional> using namespace std; #define rep(i,a,n) for(int i=a;i<n;i++) #define srt(x) sort(x.begin(),x.end()) #define clear(x,val) memset(x,val,sizeof x) #define rl(x) scanf("%lld",&x) #define ri(x) scanf("%d",&x) #define gc getchar_unlocked #define pi2 pair<pii,int> #define pii pair<int,int> #define MOD 1000000007 #define LL long long #define MAX 100000001 #define ss second #define INF 1<<32 #define ff first int main() { 	int t; 	ri(t); 	while(t--) 	{ 		int n; 		long long k,mx=-1; 		ri(n),rl(k); 		LL c[n],wt[n]; 		for(int i=0;i<n;i++) 		{ 			cin>>c[i]>>wt[i]; 		} 		for(int i=0;i<(1<<n);i++) 		{ 			long long sum1=0,sum2=0; 			for(int j=0;j<n;j++) 			{ 				if(i&(1<<j)) 				{ 					sum1+=c[j]; 					sum2+=wt[j]; 				}  			} 			if(sum1<=k) 				mx=max(mx,sum2); 		} 		cout<<mx<<endl; 	} 	return 0; } 
#include <cmath> #include <cstdio> #include <vector> #include <iostream> #include <algorithm> #include <set> using namespace std; int main() {     int n, a[100005];     cin>>n;     set<int> s;     set<int>::iterator it;     for(int i = 0;i < n; i++){     	cin>>a[i];     	if(s.insert(a[i]).second)     	{         //s.insert(a[i]);         it = s.find(a[i]);        // it++;         if(it != s.begin())             s.erase(--it);     	}     }     //for(it=s.begin();it!=s.end();it++)     //cout<<(*it)<<"\n";}     cout<<s.size()<<endl;     return 0; }
#include<iostream> #include<vector> #include<string.h> #include<stdio.h> #include<climits> #include<map> #include<math.h> #include<algorithm> #define LL long long #define P(N) printf("%d\n",N); #define S(N) scanf("%d",&N); #define SL(N) scanf("%lld",&N); #define pb push_back #define mod 1000000007 #define mp make_pair using namespace std;  LL conn_comp=0,nodes=0; LL expmod(LL a,LL b) { 	LL x=1,y=a; 	while(b>0) 	{ 		if(b&1) x=(x*y)%mod; 		y=(y*y)%mod; 		b>>=1; 	} 	return (x)%mod; }  void dfs(int x,int visited[],vector<int> adj[]) { 	nodes++;     visited[x]=1;     int siz=adj[x].size();     for(int i=0;i<siz;i++)     {         if(visited[adj[x][i]]==0)             dfs(adj[x][i],visited,adj);     } }    main() {                   int t=1;       while(t--)       {           int n,m,x,y;           LL ans=0;           S(n);           S(m); 	 	vector<int> adj[n+2]; 		int visited[n+2];           for(int i=0;i<m;i++)           {               S(x);S(y);               adj[x].pb(y+1);adj[y+1].pb(x);           } LL power=0;           memset(visited,0,sizeof(visited));           for(int i= 1;i<=n;i++)           {           	nodes=0;               if(visited[i]==0)               {               	 conn_comp++;                   dfs(i,visited,adj);               }              if(nodes!=0) 			power+=(nodes-1);           }           cout<<expmod(2,power);       } return 0; }
#include<bits/stdc++.h>  using namespace std;  #define in(a,x,y) (a>=x && a<=y) #define out(a,x,y) (!in(a,x,y)) #define sz(a) ((int)a.size()) #define repv(i,a) for(int i=0;i<sz(a);i++) #define revv(i,a) for(int i=sz(a)-1;i>=0;i--) #define rep(i,a,b) for(int i=a;i<=b;i++) #define rev(i,a,b) for(int i=a;i>=b;i--) #define all(a) a.begin(),a.end() #define pb push_back  #define AND(a,b) ((a) & (b)) #define OR(a,b) ((a)|(b)) #define XOR(a,b) ((a) ^ (b)) #define xx first #define yy second #define mp make_pair #define sqr(x) ((x)*(x)) #define sqrt(x) sqrt(1.0*(x))  #define LB(a,x) (lower_bound(all(a),x)-a.begin()) //  first element in the range [first,last) which does not compare less than val. #define UB(a,x) (upper_bound(all(a),x)-a.begin()) //  first element in the range [first,last) which compares greater than val. #define forit(it, s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it++) #define left nokol_left #define right nokol_right #define countbit(x) __builtin_popcountll((ll)x)3 #define PQ priority_queue #define FAST ios_base::sync_with_stdio(0);cin.tie(0); #define Unique(store) store.resize(unique(store.begin(),store.end())-store.begin()) #define READ(f) freopen(f, "r", stdin) #define WRITE(f) freopen(f, "w", stdout)  typedef long long ll; typedef unsigned int uint; typedef unsigned long long ull; typedef pair<int,int> pii; typedef pair<long long,long long> pll; typedef vector<int> vi; typedef vector<long long> vll;  template<class T>T __sqr(const T x){return x*x;} template< class T, class X > inline T __pow(T a,X y) {T z=1; rep(i,1,y){z*=a;} return z; } template< class T > inline T gcd(T a,T b) {a=abs(a);b=abs(b); if(!b) return a; return __gcd(b,a%b);} template< class T > inline T lcm(T a,T b) {a=abs(a);b=abs(b); return (a/__gcd(a,b))*b;} inline bool ispow2(int x){return (x!=0 && (x&(x-1))==0);} template<class T>void UpdateMin(T &x,T y){  if(y<x){x=y;}} template<class T>void UpdateMax(T &x,T y){if(x<y){x=y;}} template<class T,class X, class Y > inline T bigmod(T n,X m,Y mod){ull ret=1, a = n%mod ; while(m){ if(m&1)ret=(ret*a)%mod; m>>=1; a=(a*a)%mod; }ret%=mod;return (T)ret;} template<class T, class Y > inline T modinv(T n,Y mod) {return bigmod(n,mod-2,mod);}  template<class T,class X> int getbit(T s,X i) { return (s >> i) & 1; } template<class T,class X> T onbit(T s, X i) { return s | (T(1) << i); } template<class T,class X> T offbit(T s, X i) { return s & (~(T(1) << i)); } template<class T> inline void read(T &n){char c;for (c = getchar(); !(c >= '0' && c <= '9'); c = getchar()); n = c - '0';for (c = getchar(); c >= '0' && c <= '9'; c = getchar()) n = n * 10 + c - '0';}  void extended_euclid(ll a,ll b,ll &x,ll &y){ if(!b){ x = 1 , y = 0  ;  return ;} ll xx,yy; extended_euclid(b,a%b,xx,yy); x = yy; y = xx - (a/b)*yy; } pair<ll, pair<ll, ll> > extendedEuclid(ll a, ll b) { ll x = 1, y = 0; ll xLast = 0, yLast = 1; ll q, r, m, n; while(a != 0) {q = b / a; r = b % a; m = xLast - q * x; n = yLast - q * y; xLast = x, yLast = y; x = m, y = n; b = a, a = r; } return make_pair(b, make_pair(xLast, yLast)); }  const ll mod[]  ={0,1000000007,1000000009,1000000021,1000000033,1000000097,1000000093,1000000097,1000000103}; const ll base[] ={0,1000003,1000033,1000037,1000039,1000081,1000099,1000117,1000121};  #define pi acos(-1.0) #define eps  1e-12 #define MX   (lmt+20) #define inf  1000000000 #define MOD  1000000007LL //---------->0123456789123465789 #define lmt  100000  ll a[MX] , dp[MX][50];;// dp[MX][];  ll func(ll pos,ll step){      rep(i,1,step){         pos = (pos * 2  - 1);     }     return pos; }  ll three[MX];  void precal(){      three[0] = 1;     rep(i,1,30){         three[i] = (three[i-1] * 3 - 1  + MOD) % MOD;     } }  ll direct(ll sv,ll ev,ll step){      ll ret = (sv + ev) * three[step];     ret %= MOD;     return ret; }  ll n , m ,x , y ;  ll calc(ll p, ll m){      if(p==0) return 0;     if(p==1) return a[1];      ll ret = 0;     rep(i,1,p){         if(i==1 || p==i){             ret += three[m] * a[i];         }         else{             ret += (2*three[m]*a[i] - a[i]);         }         ret %= MOD;     }     return ret; } ll solve(ll pos,ll s,ll e,ll range,ll step){  //cout<<"st "<<step<<endl;;  //    cout<<"sdf "<<pos<<endl;  //getchar();     if(range==0) return 0;     if(step==0){  //    cout<<"ps "<<pos<<" "<<range<<endl;         if(pos==range) return s;         if(pos+1==range) return (s + e)%MOD;          return 0;     }       ll np = pos*2 - 1;     ll mp = func(np + 1 , step-1);     ll ret  = 0 ;     if(mp<=range){         ret += solve(np+1,(s + e)%MOD , e , range , step - 1) +         direct(s , (s + e)%MOD , step-1) - (s + e)%MOD;     }     else{          ret += solve(np , s , (s + e)%MOD , range , step - 1);  //    cout<<"kutta "<<np+1<<" "<<range<<" "<<step<<endl; //    getchar(); //    getchar();      }     ret %= MOD;     return ret; }  int main() {     precal();      int ts;     scanf("%d",&ts);     while(ts--){         scanf("%lld%lld%lld%lld",&n,&m,&x,&y);         rep(i,1,n) scanf("%lld",a+i);          ll st = -1 ,ed = -1;         ll ans =  0 ;         rep(i,1,n){             ll f = func(i , m);             if(f>=y){                 ed = i;                 ans += calc(i-1,m);                 break;             }         }          rev(i,n,1){             ll f = func(i , m);             if(f <= x){                 st = i;                 ans -= calc(i,m);                 break;             }         }          ll ff = func(ed , m);         if(ff==y) ans = ans - calc(ed-1,m) + calc(ed , m);         else {             ans -= a[ed-1];             ans += solve(ed-1,a[ed-1],a[ed],y,m);         }          ll ss = func(st , m);          if(ss==x) ans += a[st];         else {             ans += a[st];             ans -= solve(st,a[st],a[st+1],x-1,m);         }           ans = (ans%MOD + MOD)%MOD;         cout<<ans<<endl;     }      return 0; } 
#include<iostream> #include<cmath> #include<cstdio> #include<cstdlib>  using namespace std;  #define gc getchar_unlocked int read_int() {   char c = gc();   while(c<'0' || c>'9') c = gc();   int ret = 0;   while(c>='0' && c<='9') {     ret = 10 * ret + c - 48;     c = gc();   }   return ret; }  struct trie{ 	trie *left,*right; 	//trie():left(NULL),right(NULL){}; };  inline trie * getnode(){ 	trie *temp=(trie*)malloc(sizeof(trie)); 	temp->left=temp->right=NULL; 	return temp; }  void insert(trie *root,int n,int index){ 	trie * ptr=root;	 	for(int i=index;i>=0;i--){ 		int p=(n>>i)&1; 		if(p){ 			if(ptr->right==NULL) 				ptr->right=getnode();	 			ptr=ptr->right; 		} 		else{ 			if(ptr->left==NULL) 				ptr->left=getnode();	 			ptr=ptr->left; 		} 	} }   void remove(trie *root,int n,int index){ 	if(root==NULL || index==-1) 		return; 	int p=(n>>index)&1; 	 	if(p){ 		remove(root->right,n,index-1); 		if(root->right->left==NULL && root->right->right==NULL){ 			free(root->right); 			root->right=NULL; 		} 	} 	else{ 		remove(root->left,n,index-1); 		if(root->left->left==NULL && root->left->right==NULL){ 			free(root->left); 			root->left=NULL; 		} 	} 	 		 }  int query(trie * root,int x,int index){ 	if(root==NULL || index==-1) 		return 0;  	int p=(x>>index)&1;  	if(p){ 		if(root->left!=NULL) 			return (1<<index)|query(root->left,x,index-1); 		else 			return query(root->right,x,index-1); 	} 	else{ 		if(root->right!=NULL) 			return (1<<index)|query(root->right,x,index-1); 		else 			return query(root->left,x,index-1); 	} }	 			 int query_iterative(trie *root,int x,int index){  	trie * ptr=root; 	int ans=0; 	for(int i=index;i>=0;i--){ 		int p=(x>>i)&1; 		if(p){ 			if(ptr->left!=NULL){ 				ans|=(1<<i); 				ptr=ptr->left; 			} 			else 				ptr=ptr->right; 		}  		else{ 			if(ptr->right!=NULL){ 				ans|=(1<<i); 				ptr=ptr->right; 			} 			else 				ptr=ptr->left; 		} 	} 	return ans; }   int main(){ 	int t,n; 	cin>>t; 	while(t--){ 		n=read_int(); 		int a[n]; 		int maxnum=0; 		trie * root=getnode();  		for(int i=0;i<n;i++){ 			a[i]=read_int(); 			maxnum=max(maxnum,a[i]); 		}  		int maxlevel=ceil(log2(maxnum)); 		//int maxlevel=30;  	//	for(int i=0;i<n;i++) 	//		insert(root,a[i],maxlevel);  		int ans=0; 		insert(root,a[0],maxlevel); 		for(int i=1;i<n;i++){ 			for(int j=i+1;j<n;j++){ 				ans=max(ans,query_iterative(root,a[i]^a[j],maxlevel)); 			} 			insert(root,a[i],maxlevel); 		} 		cout<<ans<<endl;  	} 	return 0; } 		  
#include<stdio.h> #include<stdlib.h> #include<math.h> #include<string.h> #define REP(i,a,b) for(i=a;i<b;i++) #define rep(i,n) REP(i,0,n)  #define M 103  int VA, VB, SA, SB, MA; double dp[6][211][211], sum[6][211][211];  int main(){   int i,j,k;   double a, b, c;   double per;    scanf("%d%d%d%d%d", &VA, &VB, &SA, &SB, &MA);    per = 1.0 / (SA+1) / (SB+1);    a = 0; b = 1;   while(b-a > 1e-6){     c = (a+b)/2;      rep(k,MA+1){       rep(i,211) sum[k][0][i] = sum[k][i][0] = 0;       REP(i,-M,VA+1) REP(j,-M,VB+1){         sum[k][M+i+1][M+j+1] = sum[k][M+i][M+j+1] + sum[k][M+i+1][M+j] - sum[k][M+i][M+j];                  if(i <= 0 && j <= 0){           dp[k][M+i][M+j] = c;         } else if(i <= 0){           dp[k][M+i][M+j] = 0;         } else if(j <= 0){           dp[k][M+i][M+j] = 1;         } else {           dp[k][M+i][M+j] = sum[k][M+i+1][M+j+1] - sum[k][M+i-SB][M+j+1] - sum[k][M+i+1][M+j-SA] + sum[k][M+i-SB][M+j-SA];           dp[k][M+i][M+j] *= per / (1 - per);         }          if(k && dp[k][M+i][M+j] < dp[k-1][M+(i+1)/2][M+(j+1)/2]) dp[k][M+i][M+j] = dp[k-1][M+(i+1)/2][M+(j+1)/2];         sum[k][M+i+1][M+j+1] += dp[k][M+i][M+j];       }     }      if(c < dp[MA][M+VA][M+VB]) a = c; else b = c;   }    printf("%.10f\n",(a+b)/2);    return 0; }
#include<stdio.h> #include<stdlib.h> #include<math.h> #include<string.h> #define REP(i,a,b) for(i=a;i<b;i++) #define rep(i,n) REP(i,0,n)   #define ll long long #define MOD 1000000009 #define MAX 210   void extended_euclid(ll x,ll y,ll *c,ll *a,ll *b){   ll a0,a1,a2,b0,b1,b2,r0,r1,r2,q;   r0=x; r1=y; a0=1; a1=0; b0=0; b1=1;   while(r1>0){     q=r0/r1; r2=r0%r1; a2=a0-q*a1; b2=b0-q*b1;     r0=r1; r1=r2; a0=a1; a1=a2; b0=b1; b1=b2;   }   *c=r0; *a=a0; *b=b0; }   ll get_inv(ll n, ll p){   ll a,b,c;   extended_euclid(n,p,&c,&a,&b);   if(a<p) a+=p;   return a%p; }   ll pw(ll a,ll b, ll md){   ll r;   if(!b) return 1;   r = pw(a,b/2,md);   r = (r*r)%md;   if(b%2) r = (r*a)%md;   return r; }     ll fact[MAX], fact_inv[MAX]; ll inv[MAX];   ll P(int a, int b){   if(b < 0 || b > a) return 0;   return (fact[a] * fact_inv[a-b])%MOD; }   int main(){   int i, j;   int N, M, K;   int T;   ll f[MAX], ff[MAX], res;   ll C[MAX][MAX];     REP(i,1,MAX) inv[i] = get_inv(i, MOD);      fact[0] = fact_inv[0] = 1;   REP(i,1,MAX) fact[i] = (fact[i-1] * i)%MOD;   REP(i,1,MAX) fact_inv[i] = (fact_inv[i-1] * inv[i])%MOD;     rep(i,MAX) C[0][i] = 0;   rep(i,MAX) C[i][0] = 1;   REP(i,1,MAX) REP(j,1,MAX) C[i][j] = (C[i-1][j-1] + C[i-1][j])%MOD;     scanf("%d",&T);   while(T--){     scanf("%d%d%d",&N,&M,&K);       REP(i,1,N+1){       if(K < M) ff[i] = (P(i, K) * pw(i-K, M-K, MOD))%MOD;       else      ff[i] = P(i, M);       REP(j,1,i) ff[i] = (ff[i] - ff[j]*C[i][j]) % MOD;       if(ff[i] < 0) ff[i] += MOD;       f[i] = (ff[i] * fact_inv[i])%MOD;     }       res = 0;     REP(i,1,N+1) res += f[i];     res %= MOD;     printf("%d\n",(int)res);   }     return 0; }  
#include <algorithm> #include <cmath> #include <cstdio>   using namespace std;   template <class T> inline void upd_min(T &lhs, T rhs) {if(lhs>rhs)lhs=rhs;} template <class T> inline void upd_max(T &lhs, T rhs) {if(lhs<rhs)lhs=rhs;}   int side(int x1, int y1, int x2, int y2) {   int tmp = x1 * -y2 + y1 * x2; return tmp < 0 ? -1 : !!tmp;   }   int T; int N, K; int x[16], y[16];   double w[1 << 13]; double dp[7][1 << 13];   void solve() {   scanf("%d", &T); while (T--) { scanf("%d%d", &N, &K); for (int i = 0; i < N; ++i) { scanf("%d%d", x + i, y + i); } if (N <= K << 1) { printf("%.16lf\n", 0.0); continue; } w[0] = 0.0; for (int i = 1; i < 1 << N; ++i) { w[i] = 200.0; } for (int i = 0; i < N; ++i) { w[1 << i] = 0.0; for (int j = i + 1; j < N; ++j) { w[1 << i | 1 << j] = 0.0; double den = hypot(x[j] - x[i], y[j] - y[i]); for (int k = 0; k < N; ++k) { if (i == k || i == j) continue; double _w = ((x[k] - x[i]) * -(y[j] - y[i]) + (y[k] - y[i]) * (x[j] - x[i])) / den; int cover = 0; for (int l = 0; l < N; ++l) { int foo = side(x[k] - x[i], y[k] - y[i], x[j] - x[i], y[j] - y[i]); int bar = side(x[l] - x[i], y[l] - y[i], x[j] - x[i], y[j] - y[i]); int baz = side(x[l] - x[k], y[l] - y[k], x[j] - x[i], y[j] - y[i]); if (foo && foo * bar >= 0 && foo * baz <= 0 || bar == 0 || baz == 0) { cover |= 1 << l; } } upd_min(w[cover], abs(_w)); } } } for (int i = (1 << N) - 1; i; --i) { for (int j = 1; j <= i; j <<= 1) { if (i & j) upd_min(w[i ^ j], w[i]); } } for (int i = 0; i <= K; ++i) { dp[i][0] = 0.0; for (int j = 1; j < 1 << N; ++j) { dp[i][j] = 200.0; } } for (int i = 1; i <= K; ++i) { int msb = -1; for (int j = 1; j < 1 << N; ++j) { if ((j & -j) == j) ++msb; for (int k = j ^ 1 << msb; ; k = k - 1 & j) { upd_min(dp[i][j], max(dp[i - 1][k], w[j ^ k])); if (!k) break; } } } printf("%.16lf\n", dp[K][(1 << N) - 1] / 2.0); }   }   int main() {   solve();   return 0;   }
#include<iostream> #include<stdio.h> #include<assert.h> #include<string.h> #include<time.h> #include<stdlib.h> #include<math.h> #include<string> #include<sstream> #include<map> #include<set> #include<queue> #include<stack> #include<vector> #include<algorithm> #pragma comment(linker, "/STACK:16777216") #define pb push_back #define ppb pop_back #define mp make_pair #define all(x) (x).begin(),(x).end() #define sz(x) (int)(x).size() #define LL long long #define bit __builtin_popcountll #define sqr(x) (x) * (x) using namespace std; typedef pair<int, int> pii; const double eps = 1e-9; const double pi = acos(-1.0); const int maxn = (int)1e5 + 10; char s[maxn]; int cnt[10],id[] = {0,0,0,3,0,5,0,0,8,0}; int D(int d3, int d5, int d8, int L) { 	int res = L; 	int d0 = L - d3 - d5 - d8; 	if (d3 <= d5 + d0 && d5 + d0 <= d8) return d0; 	int a3,a5,a8; 	a3 = d3; a5 = (L - d3) / 2; a8 = (L - d3 + 1) / 2; 	if (a3 <= a5 && a5 <= a8) res = min(res,max(a3 - d3,0) + max(a5 - d5,0) + max(a8 - d8,0)); 	a3 = (L - d8) / 2; a5 = (L - d8 + 1) / 2; a8 = d8; 	if (a3 <= a5 && a5 <= a8) res = min(res,max(a3 - d3,0) + max(a5 - d5,0) + max(a8 - d8,0)); 	a3 = L / 3; a5 = (L + 1) / 3; a8 = (L + 2) / 3; 	res = min(res,max(a3 - d3,0) + max(a5 - d5,0) + max(a8 - d8,0)); 	return res; } bool exist(int n3, int n5, int n8, int k, int L, int x) { 	return D(n3,n5,n8,L) - (L - k) <= x && x <= D(n3,n5,n8,L); } void solve() { 	int x; scanf("%d%s",&x,&s); 	int L = strlen(s); 	for (int i = 0; i < L; i++) { 		s[i] -= '0'; 	} 	memset(cnt,0,sizeof(cnt)); 	for (int i = 0; i < L; i++) { 		cnt[id[s[i]]]++; 	} 	if (exist(cnt[3],cnt[5],cnt[8],L,L,x)) { 		for (int i = 0; i < L; i++) { 			s[i] += '0'; 		} 		printf("%s\n",s); 		return; 	} 	for (int i = L - 1; i >= 0; i--) { 		cnt[id[s[i]]]--; 		for (int j = s[i] - 1; j >= (i == 0 && L > 1 ? 1 : 0); j--) { 			cnt[id[j]]++; 			if (exist(cnt[3],cnt[5],cnt[8],i + 1,L,x)) { 				s[i] = j; 				for (int k = i + 1; k < L; k++) { 					for (int r = 9; r >= 0; r--) { 						cnt[id[r]]++; 						if (exist(cnt[3],cnt[5],cnt[8],k + 1,L,x)) { 							s[k] = r; 							break; 						} 						cnt[id[r]]--; 					} 				} 				for (int i = 0; i < L; i++) { 					s[i] += '0'; 				} 				printf("%s\n",s); 				return; 			} 			cnt[id[j]]--; 		} 	} 	if (L == 1 || !exist(0,0,0,0,L - 1,x)) { 		printf("-1\n"); 		return; 	} 	memset(cnt,0,sizeof(cnt)); 	for (int i = 0; i < L - 1; i++) { 		for (int j = 9; j >= 0; j--) { 			cnt[id[j]]++; 			if (exist(cnt[3],cnt[5],cnt[8],i + 1,L - 1,x)) { 				printf("%d",j); 				break; 			} 			cnt[id[j]]--; 		} 	} 	puts(""); } int main() { 	#ifndef ONLINE_JUDGE 	//freopen("input.txt","r",stdin); 	//freopen("output.txt","w",stdout); 	#endif 	int T; cin >> T;	 	while(T--) { 		solve(); 	} 	return 0; } 
#include<iostream> #include<stdio.h> #include<assert.h> #include<string.h> #include<time.h> #include<stdlib.h> #include<math.h> #include<string> #include<sstream> #include<map> #include<set> #include<queue> #include<stack> #include<vector> #include<algorithm> #pragma comment(linker, "/STACK:16777216") #define pb push_back #define ppb pop_back #define mp make_pair #define all(x) (x).begin(),(x).end() #define sz(x) (int)(x).size() #define LL long long #define bit __builtin_popcountll #define sqr(x) (x) * (x) using namespace std; typedef pair<int, int> pii; const double eps = 1e-9; const double pi = acos(-1.0); int p[36],order[36]; bool cmp(int i, int j) { 	return p[i] < p[j]; } void solve() { 	int n,k; cin >> n >> k; 	for (int i = 0; i < n; i++) { 		cin >> p[i]; 		order[i] = i; 	} 	sort(order,order + n,cmp); 	vector<int> bestWho; 	double best = -1.0; 	for (int i = 0; i <= k; i++) { 		vector<int> who; 		for (int j = 0; j < i; j++) { 			who.pb(order[j]); 		} 		for (int j = n - k + i; j < n; j++) { 			who.pb(order[j]); 		} 		double mAll = 1.0,mOne = 0.0; 		for (int j = 0; j < k; j++) { 			double nAll = mAll * p[who[j]] / 100.0; 			double nOne = mAll * (100 - p[who[j]]) / 100.0 + mOne * p[who[j]] / 100.0; 			mAll = nAll; 			mOne = nOne; 		} 		if (best < mOne) { 			best = mOne; 			bestWho = who; 		} 	} 	for (int i = 0; i < k; i++) { 		cout << bestWho[i] + 1 << " "; 	} 	cout << endl; } int main() { 	#ifndef ONLINE_JUDGE 	freopen("input.txt","r",stdin); 	freopen("output.txt","w",stdout); 	#endif 	int T; cin >> T; 	while(T--) { 		solve(); 	} 	return 0; } 
 #include<bits/stdc++.h>  using namespace std;  #define si(x) scanf("%d",&x) #define pri(x) printf("%d",x) #define sll(x) scanf("%lld",&x) #define pll(x) printf("%lld",x) #define sstr(s) scanf("%s",s) #define pstr(s) printf("%s",s) #define nl printf("\n") #define ll long long int #define pb push_back #define mp make_pair  char a[1005][1005]; int n,m,DP[1005][1005]; int DP1[1005][1005],f[1005];  void func() {     for(int i=0;i<n;++i) { 	DP[i][0] = DP[i][m-1] = 0;     }     for(int j=0;j<m;++j) { 	DP[0][j] = DP[n-1][j] = 0;     }     for(int i=1;i<n-1;++i) { 	for(int j=1;j<m-1;++j) { 	    if(a[i][j] == 'W') { 		if(a[i-1][j]=='B' && a[i][j-1]=='B' && a[i+1][j]=='B' && a[i][j+1]=='B') { 		    DP[i][j] = 1; 		} 		else { 		    DP[i][j] = 0; 		} 	    } 	    else { 		DP[i][j] = 0; 	    } 	}     }     DP1[0][0] = DP[0][0];     for(int j=1;j<m;++j) { 	DP1[0][j] = DP[0][j] + DP1[0][j-1];     }     for(int i=1;i<n;++i) { 	f[0] = DP[i][0]; 	DP1[i][0] = f[0]+DP1[i-1][0]; 	for(int j=1;j<m;++j) { 	    f[j] = f[j-1]+DP[i][j]; 	    DP1[i][j] = f[j]+DP1[i-1][j]; 	}     } }  int sum(int i1, int j1, int i2, int j2) {     if(i1>i2 || j1>j2 || i1>n-1 || i1<0 || j1>m-1 || j1<0 || i2<0 || j2<0 || i2>n-1 || j2>m-1) { 	return 0;     }     return DP1[i2][j2]-DP1[i2][j1-1]-DP1[i1-1][j2]+DP1[i1][j1]; }  int main() {     int t; si(t);     while(t--) { 	si(n); si(m); 	for(int i=0;i<n;++i) { 	    sstr(a[i]); 	} 	func(); /*	for(int i=0;i<n;++i) { 	    for(int j=0;j<m;++j) { 		cout<<DP[i][j]<<" "; 	    } 	    nl; 	} 	for(int i=0;i<n;++i) { 	    for(int j=0;j<m;++j) { 		cout<<DP1[i][j]<<" "; 	    } 	    nl; 	}*/ 	int mn = 1000000007; 	for(int i=1;i<n-1;++i) { 	    for(int j=1;j<m-1;++j) { 		int mx = -1; 		mx = max(mx,sum(0,0,i-2,j-2)); 		mx = max(mx,sum(0,j+2,i-2,m-1)); 		mx = max(mx,sum(i+2,0,n-1,j-2)); 		mx = max(mx,sum(i+2,j+2,n-1,m-1)); 		mn = min(mn,mx); 		if(mn==0) { 		    break; 		} 	    } 	    if(mn==0) { 		break; 	    } 	} 	if(mn==0) { 	    pstr("YES\n"); 	} 	else { 	    pstr("NO\n"); 	}     }     return 0; } 
#include <iostream> #include <queue> #include <cstdio> #include <cstring> #include <map> #include <vector> #include <list> #include <sstream> #include <cmath> #include <ctime> #include <algorithm>   using namespace std;   #define sz(a) ((int)a.size()) #define cl clear() #define pb push_back #define mp make_pair #define X first #define Y second #define all(a) a.begin(), a.end() #define sqr(a) ((a) * (a)) #define PI 3.1415926535897932384626433832795   typedef long long ll; typedef unsigned long long ull; typedef pair <int, int> pii; typedef pair <double, double> pdd; #define inf 1000000007 #define N 100010 int md=10; int c[351][351][130],m[130]; bool less1(int a[],int b[]) { 	if(a[0]!=b[0])return a[0]<b[0]; 	for(int i=a[0];i>=1;i--) 	if(a[i]!=b[i])return a[i]<b[i]; 	return 0; } void sum(int a[],int b[],int c[]) { 	int x=0,i; 	memset(c,0,sizeof(c)); 	c[0]=max(a[0],b[0]); 	for(i=1;i<=c[0];i++) 	{ 		x+=a[i]+b[i]; 		c[i]=x%md;x/=md; 	} 	while(x>0) 	{ 		c[0]++; 		c[c[0]]=x%md,x/=md; 	} } void sub(int a[],int b[]) { 	int i; 	for(i=1;i<=a[0];i++) 	{ 		if(a[i]<b[i])a[i+1]-=1,a[i]+=md; 		a[i]-=b[i]; 	} 	while(a[0]>1&&a[a[0]]==0)a[0]--; } char s[N]; int main() {     int t,i,j,k,T,n; 	c[0][0][0]=1,c[0][0][1]=1; 	for(i=1;i<=350;i++) 	{ 		c[i][0][0]=c[i][0][1]=c[i][i][0]=c[i][i][1]=1; 		for(j=1;j<i;j++) 		sum(c[i-1][j-1],c[i-1][j],c[i][j]); 	} 	scanf("%d",&T); 	while(T--) 	{ 		scanf("%d%d%s",&n,&k,s); 		int len=strlen(s); 		m[0]=len; 		for(i=1;i<=len;i++)m[i]=s[len-i]-'0'; 		if(less1(c[n][k],m)) 		{ 			puts("-1");continue; 		} 		for(i=n;i>=1;i--) 		{ 			if(less1(c[i-1][k],m)) 			{ 			    printf("1");sub(m,c[i-1][k]),k-=1; 			} 			else printf("0"); 		} 		puts(""); 	}     return 0; }
#pragma warning(disable:4786) #include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<set> #include<map> #include<functional> #include<string> #include<cstring> #include<cstdlib> #include<queue> #include<utility> #include<fstream> #include<sstream> #include<cmath> #include<stack> #include<assert.h> using namespace std;  #define MEM(a, b) memset(a, (b), sizeof(a)) #define CLR(a) memset(a, 0, sizeof(a)) #define MAX(a, b) ((a) > (b) ? (a) : (b)) #define MIN(a, b) ((a) < (b) ? (a) : (b)) #define ABS(X) ( (X) > 0 ? (X) : ( -(X) ) ) #define S(X) ( (X) * (X) ) #define SZ(V) (int )V.size() #define FORN(i, n) for(i = 0; i < n; i++) #define FORAB(i, a, b) for(i = a; i <= b; i++) #define ALL(V) V.begin(), V.end()  typedef pair<int,int> PII; typedef pair<double, double> PDD; typedef vector<int> VI; #define LL long long int LL MOD = 1000000007; LL BIGMOD(LL a,LL b,LL mod) { 	LL ans=1%mod; 	while(b) 	{ 		if(b&1) 		ans=(ans*a)%mod; 		a=(a*a)%mod; 		b/=2; 	} 	return ans%mod; }  int main() { 	int T; 	LL cnt[50]; 	int upper, d, m, n; 	int now, i, j, k; 	LL ans;  	scanf("%d", &T); 	while(T--) 	{ 		scanf("%d %d %d %d", &upper, &d, &m, &n); 		CLR(cnt); 		 		FORN(i, n) 		{ 			now = BIGMOD(i, d, n);  			if(i <= upper) 				cnt[now] += (upper - i)/n + 1; 		} 		ans = 0; 		FORN(i, n) 			FORN(j, n) 				FORN(k, n) 				{ 					if( (i + j + k)%n == m%n ) 					{ 						ans += (cnt[i]*((cnt[j]*cnt[k])%MOD))%MOD; 						ans %= MOD; 					} 				}  	      cout<<ans<<endl; 	} } 
#include<bits/stdc++.h> using namespace std; #define MOD 1000000007 #define IND 800001 long long fact[IND],inv_fact[IND]; long long power(long long num,long long x) {     if(!x)return 1;     long long res=1;     while(x)     {         if(x&1)res=(res*num)%MOD;         num=(num*num)%MOD;         x/=2;     }     return res; } long long ways(int a,int b) {     return ( ( ( (fact[a]*inv_fact[a-b]) %MOD) * inv_fact[b])%MOD); } int main() {     int t,a,b,n,m,i,j;     long long res;     fact[0]=inv_fact[0]=1;     for(i=1;i<=IND;++i)     {         fact[i]=(fact[i-1]*i)%MOD;         inv_fact[i]=power(fact[i],MOD-2);     }       scanf("%d",&t);     while(t--)     {res=0;         scanf("%d%d%d%d",&n,&m,&a,&b);         for(i=0;i<=n-a;++i)         {res=(res+(ways(i+b-1,b-1)*ways(n-i+m-b,m-b))%MOD)%MOD;             //printf("%lld ",res);         }             printf("%lld\n",res);     } } 
#include <bits/stdc++.h> #define maxm 20001 #define maxn 5001 #define mp make_pair  using namespace std; typedef pair<int,int> II; typedef pair<int,II> III;  int n, m1, m2; III a[maxm], b[maxm]; int lt[maxn];  void read_in() {     scanf("%d%d%d",&n,&m1,&m2);     for(int i=1;i<=m1;i++) {         int u, v, w; scanf("%d%d%d",&u,&v,&w);         ++u; ++v;         a[i]=mp(w,mp(u,v));     }     for(int i=1;i<=m2;i++) {         int u, v, w; scanf("%d%d%d",&u,&v,&w);         ++u; ++v;         b[i]=mp(w,mp(u,v));     } }  int tim(int u) {     if (u==lt[u]) return u;     lt[u]=tim(lt[u]);     return lt[u]; }  void solve() {     for(int i=1;i<=n;i++) lt[i]=i;     long long ans=0, ans1=0;     int slt=n;     sort(b+1,b+m2+1);     for(int i=m2;i>=1;i--) {         int u=b[i].second.first, v=b[i].second.second;         u=tim(u); v=tim(v);         if (u!=v) {             ans+=b[i].first;             lt[u]=v;             slt--;         }     }     ans1=ans;     sort(a+1,a+m1+1);     for(int i=1;i<=m1;i++) {         int u=a[i].second.first, v=a[i].second.second;         u=tim(u); v=tim(v);         if (u!=v) {             ans+=a[i].first;             lt[u]=v;             slt--;         }     }     if (slt>1) printf("Impossible\n"); else printf("%lld %lld\n",ans1,ans); }  int main() {     #ifndef ONLINE_JUDGE     freopen("inp.txt","r",stdin);     freopen("out.txt","w",stdout);     #endif // ONLINE_JUDGE     int T; scanf("%d",&T);     while (T--) {         read_in();         solve();     } } 
#include <cstdio> #include <cmath> #include <iostream> #include <set> #include <algorithm> #include <vector> #include <map> #include <cassert> #include <string> #include <cstring> #include <queue>   using namespace std;   #define rep(i,a,b) for(int i = a; i < b; i++) #define S(x) scanf("%d",&x) #define S2(x,y) scanf("%d%d",&x,&y) #define P(x) printf("%d\n",x) #define all(v) v.begin(),v.end() #define FF first #define SS second   typedef long long int LL; typedef pair<int, int > pii; typedef vector<int > vi;   const LL INF = 1000000000000LL; const int N = 5005;   LL dp[N][N]; int A[N]; LL sum1[N]; int Q[N];     int main() {   int t;   S(t);   while(t--) {     int n,k,d,m;     scanf("%d%d%d%d",&n,&k,&d,&m);     rep(i,1,n+1) {       S(A[i]);       sum1[i] = sum1[i-1] + A[i];     }       rep(i,1,n+1) dp[0][i] = dp[0][i-1] + A[i];     // dp[0][0] = -INF;       rep(i,1,k+1) {       LL c1 = 0, c2 = 0;       int l = 0, r = 0;       dp[i][0] = -INF;       rep(j,1,n+1) {         while(r && r >= l && dp[i-1][Q[r]-1] + (sum1[j] - sum1[Q[r]]) * m <= dp[i-1][j-1]) {           r--;         }         Q[++r] = j;         if(!l) l = r;         if(Q[l] == j-d) {           l++;         }         if(j < i) {           dp[i][j] = -INF;         } else if(j == i) {           dp[i][j] = 0;         } else {           if(j-d >= 1) {             c1 = max(c1 + A[j], dp[i-1][j-d-1] + (sum1[j] - sum1[j-d]) * m);           }           c2 = dp[i-1][Q[l]-1] + (sum1[j] - sum1[Q[l]]) * m;           dp[i][j] = max(c1, c2);           dp[i][j] = max(dp[i][j], dp[i][j-1]);         }         // printf("%d %d %lld\n",i,j,dp[i][j]);       }     }       printf("%lld\n",dp[k][n]);   }   return 0; } 
//Amit Gupta               #include<bits/stdc++.h> using namespace std; typedef long long LL; typedef pair<int,int> II; #define REP(i,i1,n) for(int i=i1;i<n;i++) #define REPB(i,i1,n) for(int i=i1;i>=n;i--) #define PB push_back #define MP make_pair #define ALL(c) (c).begin(),(c).end() #define F first #define S second #define SZ(a) (LL)a.size() #define EPS 1e-12 #define MOD 1000000007 #define TR1(x) cerr<<#x<<" : "<<x<<endl #define TR2(x,y) cerr<<#x<<" : "<<x<<" | "<<#y<<" : "<<y<<endl #define FAST_IO ios_base::sync_with_stdio(false);cin.tie(NULL) #define SI(c) scanf("%d",&c) #define SII(c,d) scanf("%d%d",&c,&d) #define SLL(c) scanf("%lld",&c) #define PIN(c) printf("%d\n",c) #define PLLN(c) printf("%lld\n",c) #define N 200010 #define endl '\n' #define FILL(ar,vl) for(int i=0;i<N;i++)ar[i]=vl #define FILL2(ar,vl) for(int i=0;i<N;i++)for(j=0;j<N;j++)ar[i][j]=vl //--------------------------MAIN CODE STARTS HERE---------------- LL dp[100][600]; int main() {	     int t;     SI(t);     while(t--) {         memset(dp,0,sizeof(dp));         LL c,s;LL k;         SLL(c);SLL(s);SLL(k);         REP(i,0,s+1) {             if(i<c)                 dp[0][i]=1,dp[1][i]=1;         }         int pos=1;         REP(i,2,100) {             REP(j,0,s+1) {                 REP(j1,0,min(1LL*(j+1),c)) {                     dp[i][j]+=dp[i-1][j-j1];                     if(dp[i][j]>1e+18)                         dp[i][j]=1e+18;                 }             }             if(dp[i][s]>=k) {                 pos=i;                 break;             }         }         LL vl=1;LL ans=0;         REP(i,1,pos)             vl*=c;         REPB(l,pos,2) {             LL id=0;             while(id<c&&dp[l-1][s-id]<k)                 k-=dp[l-1][s-id],id++;             s-=id;             ans+=vl*id;             vl/=c;         }         PLLN(ans+s);     }     return 0; } 
#include<iostream> #include<map> #include<cstdio> #include<algorithm> using namespace std; map<long long int, long long int>m; long long int f(long long int n){     if ( n == 0)    return 0;     if ( m[n] > 0 ) return m[n];     else {           long long int c=max(n,(f(n/2)+f(n/3)+f(n/4)));         m[n]=c;         return m[n];     } } int main(){     long long int n;     while (scanf("%lld",&n)>0)         printf("%lld\n",f(n));     return 0; }
#include <stdio.h>  const int md = (int)(1e9+7);  int ans, t, n, m, i; int f[1111111],s[1111111];  int main() {   scanf("%d",&t);   while (t--) {     scanf("%d %d",&n,&m);     for (i=1;i<=m+1;i++) f[i] = 1, s[i] = i;     for (i=m+2;i<=n;i++) {       f[i] = (s[i-1]-s[i-m-1]+md) % md;       s[i] = (s[i-1]+f[i]) % md;     }     ans = 0;     for (i=1;i<=m;i++) ans = (ans+(long long)f[n-m+i]*i) % md;     for (i=1;i<=m;i++) ans = (long long)ans*i % md;     printf("%d\n",ans);   }   return 0; }
#include <stdio.h> #include <iostream> typedef long long ll; using namespace std; const int mod=3046201,Siz=2900001; int n,q;ll mem[Siz];   ll inv[]={1,1,1523101,2538501,2919276,3020816,2534270,2973068,1894734,210526,1239533,1774249,2940205,2335078,1472306,910474,1199230,1324861,2950571,2239536,721217,1049744,324643,543889,2941938,1579854,2169672,418825,2082023,2382705,1602524,1427398};     int app,y,sta; ll ac; ll ftry(int m){ 	return mem[m]; }  long long Temp,Ans; int fp(int X, int Y) {     if(!Y) return 1;     Temp = fp(X,Y/2);     Ans = (Temp*Temp)%mod;     if(!(Y&1)) return Ans;     else return (X*Ans)%mod; }   char buf[21];int ix; //int putchar_unlocked(char ch) { return putchar(ch);  } inline void writeL(ll x) {      ix = 20;      buf[20] = '\n';      do       {         buf[--ix] = (x % 10) + '0';         x/= 10;      }while(x);      do      {         putchar_unlocked(buf[ix]);      } while (buf[ix++] != '\n'); }   //int getchar_unlocked()  {return getchar();} inline void Read(int &x) { 	register int c= getchar_unlocked(); 	x = 0; 	for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked()); 	for(; c>47 && c<58 ; c = getchar_unlocked()) { 		x = (x<<1) + (x<<3) + c - 48; 	} }   inline bool Readc() { 	register int c= getchar_unlocked(); 	for(; ( c<97 || c>123 ); c = getchar_unlocked()); 	return c=='c'; }   int arr[500009];     void  update(int node,int low,int high,int ix,int upd) { if(low==ix && high==ix) { arr[node]=upd; return; }   int left,mid,right; left=node<<1; right=left+1; mid=(low+high)/2; if(ix<=mid) update(left,low,mid,ix,upd); else if(ix>mid) update(right,mid+1,high,ix,upd); else { update(left,low,mid,ix,mid); update(right,mid+1,high,mid+1,ix); }   arr[node]=arr[left]+arr[right];   }   int query(int node,int low,int high,int i,int j){ 	 if(low==i && high==j) { return arr[node]; } int left,right,mid; left=node<<1; right=left+1; mid=(low+high)/2; if(j<=mid) return query(left,low,mid,i,j); else if(i>mid) return query(right,mid+1,high,i,j); else return query(left,low,mid,i,mid)+query(right,mid+1,high,mid+1,j); }     int main(){ 	int i,j,k,ii,sum,kk,bal;ll combi,ans;bool bo; 	mem[0]=1; 	for(i=1;i<Siz;i++) mem[i]=((ll)i*mem[i-1])%mod; 	Read(n); 	for(i=0;i<n;i++){ Read(kk); update(1,0,n-1,i,kk);	} 	//for(i=0;i<n;i++) cout << a[i] << endl; 	Read(q); 	//cout<<q<<endl; 	for(i=0;i<q;i++){ 		bo=Readc(); 		Read(j); 		Read(k);j--;k--; 		if(bo){ 			update(1,0,n-1,j,k+1); 		} 		else{ 			ans=1; 			sum=query(1,0,n-1,j,k); 			//cout <<"ans:"<<ans<<endl; 			bal=sum/(k-j+1); 			kk=sum%(k-j+1);		//cout<<"k="<<k<<",j="<<j<<",kk="<<kk<<endl; 			combi=(ftry(k-j+1)*fp((int)ftry(kk),3046199)%mod)*fp((int)ftry(k-j+1-kk),3046199)%mod; 			ans=(ftry(sum)*combi)%mod;						//cout<<"ans=" <<ans<< endl; 			ans=(ans*fp((int)inv[bal+1],kk))%mod;			//cout<<"ans=" <<fp(int(inv[bal]),k-j+1-kk)<< endl; 			ans=(ans*fp((int)inv[bal],k-j+1-kk))%mod;		 			//cout<<"combi:"<< combi<<endl;		cout <<"ans:"<<ans<<endl; 			writeL(ans); 		} 	} 	return 0; } 
#include <assert.h> #include <ctype.h> #include <float.h> #include <math.h> #include <stdio.h> #include <string> #include <stdlib.h> #include <time.h> #include <algorithm> #include <numeric> #include <functional> #include <utility> #include <vector> #include <list> #include <set> #include <map> #include <queue> #include <stack> #include <sstream> #include <iostream> #include <memory.h>  using namespace std;  #define rep(i,n) for(int i=0;i<(n);++i) #define clr(a,b) memset(a,b,sizeof(a)); #define all(c) (c).begin(), (c).end() #define inf 1000000000  typedef long long ll; typedef pair<int, int> pii; typedef vector<string> vs; typedef vector<int> vi;  template<class T> inline T gcd(T a,T b)//NOTES:gcd( {if(a<0)return gcd(-a,b);if(b<0)return gcd(a,-b);return (b==0)?a:gcd(b,a%b);} template<class T> struct Fraction{T a,b;Fraction(T a=0,T b=1);string toString();};//NOTES:Fraction template<class T> Fraction<T>::Fraction(T a,T b){T d=gcd(a,b);a/=d;b/=d;if (b<0) a=-a,b=-b;this->a=a;this->b=b;} template<class T> Fraction<T> operator+(Fraction<T> p,Fraction<T> q) { 	T g = gcd(p.b, q.b); 	return Fraction<T>(p.a*(q.b/g)+q.a*(p.b/g),(p.b/g)*q.b); }  int main(int argc, char* argv[]) { #ifndef ONLINE_JUDGE 	freopen("test.in", "r", stdin); #endif  #if 0 	printf("1\n");  	{ 		int N = 50000; 		printf("%d\n", N);  		rep(i, N) 		{ 			printf("%d %d\n", rand()% 2000000 - 1000000, rand() % 41 - 20); 		} 	} 	return 0; #endif  	int T; 	scanf("%d", &T);  	for (int nTest = 1; nTest <= T; nTest++) 	{ 		int N; 		scanf("%d", &N); 		vector<vector<int> > ball(41);  		for (int i = 0; i < N; i++) 		{ 			int x, dx; 			scanf("%d %d", &x, &dx);  			ball[dx + 20].push_back(x); 		}  		for (int i = 0; i < ball.size(); i++) 			sort(ball[i].begin(), ball[i].end());  		long long Sa = 0; 		Fraction<long long> ans(0, 1);  		for (int dx1 = -20; dx1 <= 20; dx1++) 		{ 			for (int dx2 = -20; dx2 < dx1; dx2++) 			{ 				vector<int>& xi = ball[dx1 + 20]; 				vector<int>& xj = ball[dx2 + 20];  				if (xi.size() == 0 || xj.size() == 0) 					continue;  				vector<long long> s (xj.size() + 1); 				for (int i = 0; i < xj.size(); i++) 					s[i + 1] = s[i] + xj[i];  				int dx = (dx1 - dx2); 				long long cur = 0;  				if (dx > 0) 				{ 					int j = 0;  					for (int i = 0; i < xi.size(); i++) 					{ 						while (j < xj.size() && xj[j] < xi[i]) 							j++;  						if (j == xj.size()) 							break;  						long long total = xj.size() - j; 						cur -= xi[i] * total; 						cur += s.back() - s[j]; 					} 				} 				Sa += cur / dx; 				cur %= dx;  				ans = ans + Fraction<long long>(cur, dx);  				Sa += ans.a / ans.b; 				ans.a %= ans.b; 			} 		}  		long long p = ans.a; 		long long q = ans.b;  		if (p == 0) 		{ 			cout << Sa; 		} 		else 		{ 			if (Sa) 			{ 				cout << Sa << " "; 			} 			if (p != 0) 			{ 				cout << p << '/' << q; 			} 		} 		cout << endl;   	}   	return 0; }  
#include <iostream> #include <cstdio> #include <algorithm> #define ll long long using namespace std;   ll t,n,u,ans; ll arr[1005]; ll pairsum[1000005];  ll method(ll ar[],ll k){ 	ll sum = 0; 	 	for(ll i=0;i<k;i++){ 		ll temp = i*ar[i] - (k-1-i)*ar[i]; 		sum += temp; 	} 	return sum; 	 }  int main() { 	 	scanf("%lld",&t); 	 	while(t--){ 	 		scanf("%lld",&n); 		 		for(ll i=0;i<n;i++) 			scanf("%lld",arr+i); 		 		sort(arr,arr+n); 		u = 0; 		for(ll i=0;i<n;i++){ 			for(ll j=i+1;j<n;j++){ 				pairsum[u] = arr[i]+arr[j]; 				u++; 			} 		} 		 		sort(pairsum,pairsum+u); 		 		ans = method(pairsum,u)-(n-2)*method(arr, n); 		printf("%lld\n",ans*2); 		 	} 	 	return 0; }
//Amit Gupta               #include<bits/stdc++.h> using namespace std; typedef long long LL; typedef pair<int,int> II; #define REP(i,i1,n) for(int i=i1;i<n;i++) #define REPB(i,i1,n) for(int i=i1;i>=n;i--) #define PB push_back #define MP make_pair #define ALL(c) (c).begin(),(c).end() #define F first #define S second #define SZ(a) (LL)a.size() #define EPS 1e-12 #define MOD 1000000007 #define TR1(x) cerr<<#x<<" : "<<x<<endl #define TR2(x,y) cerr<<#x<<" : "<<x<<" | "<<#y<<" : "<<y<<endl #define FAST_IO ios_base::sync_with_stdio(false);cin.tie(NULL) #define SI(c) scanf("%d",&c) #define SII(c,d) scanf("%d%d",&c,&d) #define SLL(c) scanf("%lld",&c) #define PIN(c) printf("%d\n",c) #define PLLN(c) printf("%lld\n",c) #define N 200010 #define endl '\n' #define FILL(ar,vl) for(int i=0;i<N;i++)ar[i]=vl #define FILL2(ar,vl) for(int i=0;i<N;i++)for(j=0;j<N;j++)ar[i][j]=vl //--------------------------MAIN CODE STARTS HERE---------------- LL powmod(LL a,LL b) {     if(b==0)return 1;     LL x=powmod(a,b/2);     LL y=(x*x)%MOD;     if(b%2)         return (a*y)%MOD;     return y%MOD; } int main() {     int t;     cin>>t;     while(t--) {         LL n,k;         cin>>n>>k;         LL ans=0;         ans=(k*(k-1))%MOD;         LL vl=((k-1)*(k-1))%MOD;         vl=(vl-(k-2)+MOD)%MOD;         ans=(ans*powmod(vl,n-1))%MOD;         cout<<ans<<endl;     } return 0; } 
#include <iostream> #include <cstdio> using namespace std;  #include <bitset> #include <algorithm> #include <iomanip> #include <cmath> #include <cstring>  # define FR(i, n)           for( int i = 0; i<=n; i++) # define FRm(i, m, n)     for( int i = m; i <=n; i++) # define FRrev(i, n)         for( int i = n; i >= 0; i-- ) # define FRrevm(i,n,m)         for( int i = n; i >= m; i-- )  # define PF       printf # define PFS PF(" ") # define PFd(x)   printf("%d" , x ) # define PFdS(x)   printf("%d " , x ) # define PFdN(x)  printf("%d\n" , x ) # define PFN	  printf("\n") # define SF    scanf # define SFd(x) scanf("%d",&x) # define SFd2(x,y) scanf("%d%d",&x,&y)  #define nmax 1002  int inp[nmax]; int t,n,m,c1,c2;  int bSearch(int key , int len , int arr[]) { 	int left,right,mid; 	 	left=0; right=len-1;  	while(left<=right) 	{ 		mid=(left+right)/2; 		if(inp[mid]==key) return mid; 		 		if(key<arr[mid]) right=mid-1; 		else left=mid+1; 		 	} 	return -1; 	 }   int bSearch( int key , int len ) { 	return bSearch(key , len , inp); }   int solveBinary(int low, int high, int p1 , int p2) { 	int next,cur,mid,start=p1; 	int c1=inp[p1]; 	int c2=inp[p2]; 	 	while( (1+low)<high ) 	{ 			mid=(low+high)/2; 			cur=start; 			 			FRm(i,1,m+1)  			{ 				next=cur; 				while( inp[next]<c2 && inp[next+1]<=(inp[cur]+mid)  ) 				{ 					next++; 				} 				cur=next; 			} 			 			if(inp[cur]<c2)   				low=mid; 			else   // if u can't get all m values for current mid, then the mid required is less than the current mid 				high=mid; 	} 	 	return high; 	 }         int main() { 	 	int ans,count,p1,p2,left,right; 	 	SFd(t); 	 	while(t--) 	{		 		 		SFd2(n,m); 		SFd2(c1,c2); 		 		int qq=max(c1,c2),ww=min(c1,c2); 		c1=ww; c2=qq; 		 		FR(i,n-1)SFd(inp[i]); 		inp[n++]=c1; inp[n++]=c2; 		sort(inp,inp+n); 		 		int total=n; 		p1=bSearch(min(c1,c2),total); 		p2=bSearch(max(c1,c2),total); 		 		int check=(p2-p1-1); 		 		if(check<=m) 		{ 			ans=inp[p1+1]-inp[p1]; 			FRm(i,p1,p2-1)ans=max(ans,inp[i+1]-inp[i]); 			 			left=p1-1; 			right=p2+1; 			count=check+2; 			 			while(count<m) 			{ 				if( ( right>=(total) ) || (left>=0 && (inp[left+1]-inp[left])<(inp[right]-inp[right-1]) )  ) 				{ 					ans=max( ans , inp[left+1]-inp[left] ); 					left--; 				} 				else 				{ 					ans=max( ans , (inp[right]-inp[right-1]) ); 					right++; 				} 				count++; 			} 			 		} 		else 		{ 			//ans=0; 			ans=solveBinary(0 , abs(c1-c2) , p1 , p2); 		} 		 		cout<<ans<<endl; 		 	} 	 	return 0; } 
#pragma comment(linker, "/STACK:256000000") #include <queue> #include <stack> #include <cstdio> #include <cstring> #include <iostream> #include <algorithm> #include <string> #include <cmath> #include <iomanip> #include <ctime> #include <vector> #include <set> #include <map> #include <cassert> using namespace std;  #ifdef shindo const bool DEBUG = 1; #else const bool DEBUG = 0; #endif  #define MAXN 111  double dp[2][MAXN][MAXN]; double c[MAXN][MAXN]; int a[MAXN]; int sum;  int main() { #ifdef shindo   freopen("input.txt", "r", stdin);   freopen("output.txt", "w", stdout); #endif    c[0][0] = 0;   for(int i = 1; i < MAXN; i++) {     for(int j = i; j < MAXN; j++) {       if(i == 1) c[i][j] = j;       else if(i == j) c[i][j] = 1;       else c[i][j] = c[i][j - 1] + c[i - 1][j - 1];     }   }   int t;    for(scanf("%d", &t); t--;) {     int n; scanf("%d", &n);     sum = 0;     for(int i = 0; i < n; i++) {       scanf("%d", &a[i]);       sum += a[i];     }     sort(a, a + n);     memset(dp, 0, sizeof dp);     int turn = 0;     double ret = 0;     dp[0][0][0] = 1;     for(int cnt = 0; cnt < n; cnt++) {       double add = 0;       for(int s = 0; s < sum; s++) { 	for(int last = 0; last < n; last++) { 	  dp[turn ^ 1][s + a[last]][last + 1] += dp[turn][s][last]; 	  dp[turn][s][last + 1] += dp[turn][s][last]; 	} 	if(cnt && s && dp[turn][s][n]) { 	  add += dp[turn][s][n] * fabs(2 * s - sum) / (double)(n - 1); 	}       }       if(cnt) { 	add /= c[cnt][n]; 	ret += add;       }       memset(dp[turn], 0, sizeof dp[turn]);       turn ^= 1;     }     printf("%.6lf\n", ret);   } }   
// #include<abhi.944>  #include<bits/stdc++.h> using namespace std;  typedef long long int ll; typedef double ld;  #ifndef ONLINE_JUDGE 	#define TRACE #endif  const long double PI=3.1415926535897932384626; const ll MAX=1000000000+7; const int INF = 0x3f3f3f3f;  #define ps printf(" ") #define pn printf("\n") #define sc(n) scanf("%d",&n) #define pf(n) printf("%lld",n) #define forall(it, x) for(__typeof((x).begin()) it=(x).begin();it!=(x).end();it++) #define sz size() #define ff first #define ss second #define pb push_back //pop_back #define mp make_pair #define fill(a,val) memset(a,val,sizeof(a)) //#define pii pair <int ,int>  inline ll div_(ld A,ld B,bool ud){if(B){ld ret=(ld)(A)/(ld)(B);if(ud)return ceil(ret);return floor(ret);}return INF;} inline ll mul_(ll A,ll B){ll ret = (ll)((ll)(A)*(ll)(B));return ret;} inline ll sub_(ll A,ll B){ll ret = (ll)((ll)(A)-(ll)(B));return ret;} inline ll add_(ll A,ll B){ll ret = (ll)((ll)(A)+(ll)(B));return ret;} inline ll power_(ll A, ll p){ll ret=1;while(p){if(p&1) {ret=(ret*A);}A=(A*A);p>>=1;}return ret;}  #ifdef TRACE     #define trace(x)            cerr<<__FUNCTION__<<":"<<__LINE__<<": ERROR---->"<<x<<endl;     #define trace1(x)           cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<endl;     #define trace2(x,y)         cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<" | "#y" = "<<y<<endl;     #define trace3(x,y,z)       cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<" | "#y" = "<<y<<" | "#z" = "<<z<<endl;     #define trace4(a,b,c,d)     cerr<<__FUNCTION__<<":"<<__LINE__<<": "#a" = "<<a<<" | "#b" = "<<b<<" | "#c" = "<<c<<" | "#d" = "<<d<<endl; #else     #define trace(x)     #define trace1(x)     #define trace2(x,y)     #define trace3(x,y,z)     #define trace4(a,b,c,d) #endif  #define N 1000006  int a[N+1]; int multipliers[N+1]; ll subsets[N+1];  ll nc(ll A) {     ll by = mul_(A,mul_(A-1,A-2));     by = div_(by,6,0);     return by; }  int main(int argc, char const *argv[]) {     int n;     sc(n);      int max1 = -1;     for(int i=0;i<n;i++) {         sc(a[i]);         multipliers[a[i]]++;         if(max1 < a[i]) max1 = a[i];     }      for(int i=max1;i>=1;i--) {         int j = i;         ll tot = multipliers[j];         j += i;         ll sum = 0;         while(j <= max1) {             sum = add_(sum,subsets[j]);             tot = add_(tot,multipliers[j]);             j += i;         }         subsets[i] = sub_(nc(tot) ,sum);     }      pf(subsets[1]); pn;     return 0; }
#include <iostream> #include <cstring> #include <cstdio> #include <cmath>  using namespace std;  char s[50];  #define f(i, j, k) for(i = j; i < k; i++)  long long int value(char s[], int max, int j, int k) {     int f, i;     long long c = 0;     if (max > 9) f = 1;     else f = 0;     int p = 0;     int num;     for (i = k; i >= j; i--) {         if (s[i] >= 48 && s[i] <= 57) num = s[i] - 48;         else num = s[i] - 87;         c += pow(max, p)*num;         p++;     }     return c; }  int main() {     int t;     scanf("%d", &t);     char c[2];     gets(c);     int ctr = 0;     while (t--) {         gets(s);         int i,len = strlen(s);         int eq, pl;         f(i, 0, len) {             if (s[i] == '=') {eq = i; break;}             if(s[i] == '+') pl = i;         }         int max = 0;         f(i, 0, pl) {             if (s[i] > max) max = s[i];         }         f(i, pl + 1, eq) {             if (s[i] > max) max = s[i];         }         f(i, eq + 1, len) {             if (s[i] > max) max = s[i];         }         if (max >= 48 && max <= 57) max = max - 48;         else max = max - 87;         max = max + 1;         long long a, b, c;         for (i = max; i <= 16; i++) {         a = value(s, i, 0, pl - 1);         b = value(s, i, pl + 1, eq - 1);         c = value(s, i, eq + 1, len - 1);         if (a + b == c) { ctr++; break;}         }     }     printf("%d\n", ctr);     return 0; }  
// -*- C++ -*- // File: a.cpp // Copyright (C) 2013 #include <algorithm> #include <string> #include <vector> #include <queue> #include <iostream> #include <cmath> #include <sstream> #include <map> #include <set> #include <numeric> #include <memory.h> #include <cstdio> #include <assert.h>  using namespace std;  #define pb push_back #define INF 1011111111 #define FOR(i,a,b) for (int _n(b), i(a); i < _n; i++) #define rep(i,n) FOR(i,0,n) #define CL(a,v) memset((a),(v),sizeof(a)) #define mp make_pair #define X first #define Y second #define all(c) (c).begin(), (c).end() #define SORT(c) sort(all(c))  typedef long long ll; typedef vector<int> VI; typedef pair<int,int> pii;  /*** TEMPLATE CODE ENDS HERE */  int N,n,MASK; int e[36][36]; int a[18]; int dp[1<<18];  int match(int mask) {     if(mask == MASK) return 0;     int &ans = dp[mask];     if(ans != -1) return ans;     ans = INF;          rep(i,n) {         if(mask & (1<<i)) continue;         FOR(j,i+1,n) {             if(mask & (1<<j)) continue;                          ans = min(ans, match(mask|(1<<i)|(1<<j)) + e[a[i]][a[j]]);         }         break;     }     return ans; }   int find_matching(int n) {     CL(dp,-1);     return match(0); }  void solve() {     int m;     cin >> n >> m;     N = 2*n;     MASK = (1<<n)-1;          rep(i,N) rep(j,N) e[i][j] = i==j ? 0 : INF;          rep(i,m) {         int x,y,c;         cin >> x >> y >> c;         e[x][y] = e[y][x] = c;     }          rep(k,N) rep(i,N) rep(j,N) e[i][j] = min(e[i][j], e[i][k] + e[k][j]);          rep(i,N) a[i] = 2*i;     int ans = find_matching(n);          rep(i,N) a[i] = 2*i+1;     ans = min(ans, find_matching(n));          cout << ans << endl; }  int main() { #ifdef LOCAL_HOST     freopen("input.txt","r",stdin);     //freopen("output.txt","w",stdout); #endif      ios_base::sync_with_stdio(false);          int T;     cin >> T;          while(T--) solve();  #ifdef LOCAL_HOST     printf("TIME: %.3lf\n",double(clock())/CLOCKS_PER_SEC); #endif      return 0; } 
 /* Author : Vamsi Kavala */ #include <iostream> #include <cstdio> #include <cstring> #include <cstdlib> #include <cctype> #include <algorithm> #include <map> #include <vector> #include <list> #include <set> #include <queue> #include <deque> #include <stack> #include <string> #include <cmath> #include <cassert> using namespace std;  #define FOR(i,a,b) for(int i=a;i<b;i++) #define FORD(i,a,b) for(int i=a;i>=b;i--) #define REP(i,n) FOR(i,0,n) #define PB push_back #define ITER(i,a) for( typeof(a.begin()) i=a.begin();i!=a.end();i++)	 #define mod 1000000007 #define MAXN 1000010 #define MP make_pair #define INF mod  typedef pair<int,int>   PI; typedef vector<int> VI; typedef long long int LL;  vector<vector<LL> > dp,cost,disc;  int main(){  	int t,n,m; 	scanf("%d",&t); 	assert(t<=100); 	while(t--) 	{ 		scanf("%d%d",&n,&m); 		assert(t<=10000);  		dp.clear(); 		cost.clear(); 		disc.clear(); 		 		dp.resize(n); 		cost.resize(n); 		disc.resize(n);  		REP(i,n) 		{ 			dp[i].resize(m); 			cost[i].resize(m); 			disc[i].resize(m); 		} 		REP(i,n) 			REP(j,m) 				scanf("%lld",&cost[i][j]);	//cost of ith item in jth store 		REP(i,n) 			REP(j,m) 				scanf("%lld",&disc[i][j]);	//discount got after purchasing ith item in jth store  		//dp[i][j] -- minimum amount spent till ith item if you bought the ith item in jth shop 		LL prev=(LL)INF*INF,prev2; 		REP(i,m) 		{ 			dp[0][i]=cost[0][i]; 			prev=min(prev,dp[0][i]); 		}  		FOR(i,1,n) 		{ 			prev2=(LL)INF*INF; 			REP(j,m) 			{ 				LL d=max(0LL,cost[i][j]-disc[i-1][j]); 				dp[i][j]=dp[i-1][j]+d; 				dp[i][j]=min(dp[i-1][j]+d,prev+cost[i][j]); 				prev2=min(prev2,dp[i][j]); 			} 			prev=prev2; 		}  		LL ans=(LL)INF*INF; 		REP(i,m) 			ans=min(ans,dp[n-1][i]); 		printf("%lld\n",ans); 	} 	return 0; } 
#include <cmath> #include <cstdio> #include <utility> #include <algorithm> using namespace std; int t,n,m,i,j,k,x,y; pair <double, double> a[55],b[55]; double f[55][2],xx,yy,dd,d,z,e,r,res,eps=1e-8; bool q; int main() {   scanf("%d",&t);   while (t--) {     scanf("%d",&n); res=0;     for (i=0; i<n; i++) scanf("%lf%lf",&b[i].first,&b[i].second);     for (x=0; x<n; x++) for (y=0; y<n; y++) if (x!=y) {       z=atan2(b[y].second-b[x].second,b[y].first-b[x].first);       dd=sqrt((b[y].second-b[x].second)*(b[y].second-b[x].second)+(b[y].first-b[x].first)*(b[y].first-b[x].first));       for (i=m=0; i<n; i++) if (i!=x && i!=y) {         d=sqrt((b[i].second-b[x].second)*(b[i].second-b[x].second)+(b[i].first-b[x].first)*(b[i].first-b[x].first));         e=atan2(b[i].second-b[x].second,b[i].first-b[x].first);         xx=d*cos(e-z);         yy=d*sin(e-z);         if (xx>eps && xx<dd-eps && yy>eps) a[m++]=make_pair(xx,yy);       }       sort(a,a+m);        for (i=0; i<m; i++) {               q=true;         for (k=0; k<m; k++) if (k!=i) {           if (a[k].first>a[i].first+eps) break;           if (a[i].first*(a[k].second-a[i].second)-(a[k].first-a[i].first)*a[i].second<-eps) { q=false; break; }         }         f[i][1]=-1e9;         if (q) f[i][0]=a[i].first*a[i].second; else f[i][0]=-1e9;       }       for (i=0; i<m; i++) for (j=i+1; j<m; j++) if (a[j].first>a[i].first+eps) {         q=true;         for (k=i+1; k<m; k++) if (k!=j) {           if (a[k].first>a[j].first+eps) break;           if ((a[j].first-a[i].first)*(a[k].second-a[j].second)-(a[k].first-a[j].first)*(a[j].second-a[i].second)<-eps) { q=false; break; }         }         if (q) {           if (a[j].second>a[i].second+eps) f[j][0]=max(f[j][0],f[i][1]+(a[j].first-a[i].first)*(a[j].second+a[i].second));            else if (a[j].second<a[i].second-eps) f[j][1]=max(f[j][1],f[i][0]+(a[j].first-a[i].first)*(a[j].second+a[i].second));         }       }       for (r=i=0; i<m; i++) {         q=true;         for (k=i+1; k<m; k++) if ((dd-a[i].first)*a[k].second-(a[k].first-dd)*(-a[i].second)<-eps) { q=false; break; }         if (q) r=max(r,f[i][0]+a[i].second*(dd-a[i].first));       }       if (r>res) res=r;     }     printf("%.1lf\n",res*0.5);   }   return 0; }
 #include<bits/stdc++.h>  typedef long long LL; using namespace std; const int M = 1000000007;  int main() { LL n,i,m; cin>>n>>m;  LL id,at,va,pr;  map <pair<LL,LL>,pair<LL,LL> > mp;   for(i=0;i<n;i++) { cin>>id>>at>>va>>pr;  if(mp[make_pair(id,at)].second <= pr) 		mp[make_pair(id,at)] = make_pair(va,pr);  }   for(i=0;i<m;i++) { cin>>id>>at; cout<<mp[make_pair(id,at)].first<<endl; }  } 
#include<bits/stdc++.h> using namespace std; #define ll long long   int tree[50000 * 5 + 1]; ll last_time[50003]={0},last_distance[50003]={0},last_speed[50003]={0},leaf_number[50003];   void build(int p,int l,int r) {     if(l>r) return;     if(l==r) {tree[p]=l;leaf_number[l]=p;return;}     int mid=(l+r)/2;     build(p*2,l,mid);     build(p*2+1,mid+1,r);     tree[p]=tree[p*2]; }   class event { public:     ll time,node,challenger;     event(ll _time,ll _node,ll _challenger)     {         time=_time;         node=_node;         challenger=_challenger;     }     void perform(); };   class compareEventByTime { public:     bool operator () (const event &a, const event &b) {return a.time > b.time;} };   priority_queue< event, vector<event> , compareEventByTime > Q;   void event::perform() {     //cout<<challenger<<" challenging "<<tree[node]<<" "<<last_distance[23]<<endl;     int opponent = tree[node];     last_distance[challenger] += (time - last_time[challenger]) * last_speed[challenger];     last_time[challenger]=time;     last_distance[opponent] += (time - last_time[opponent]) * last_speed[opponent];     last_time[opponent]=time;     if(last_distance[challenger] >= last_distance[opponent])     {         tree[node] = challenger;         if(node == 1) return;         opponent = tree[node/2];         last_distance[opponent] += (time - last_time[opponent]) * last_speed[opponent];         last_time[opponent] = time;         if(last_speed[challenger] > last_speed[opponent])         {             ll numerator=time * (last_speed[challenger] - last_speed[opponent]) + last_distance[opponent] - last_distance[challenger];             ll denominator = (last_speed[challenger] - last_speed[opponent]);             ll newtime = numerator / denominator;             while((last_distance[challenger]+(newtime-time)*last_speed[challenger]) < (last_distance[opponent]+(newtime-time)*last_speed[opponent])) newtime++;             event e(newtime,node/2,challenger);             Q.push(e);         }     }     else if(last_speed[challenger] > last_speed[opponent])     {         ll numerator=time * (last_speed[challenger] - last_speed[opponent]) + last_distance[opponent] - last_distance[challenger];         ll denominator = (last_speed[challenger] - last_speed[opponent]);         ll newtime = numerator / denominator;         while((last_distance[challenger]+(newtime-time)*last_speed[challenger]) < (last_distance[opponent]+(newtime-time)*last_speed[opponent])) newtime++;         event e(newtime,node,challenger);         Q.push(e);     } }   void query1() {     //input     ll time,cyclist,newspeed;     cin>>time>>cyclist>>newspeed;       //flush the event queue !!!     while(!Q.empty() && Q.top().time <= time)     {         event e=Q.top();         e.perform();         Q.pop();     }       int node=leaf_number[cyclist];     while(tree[node]==cyclist && node!=1) node/=2;     if(tree[node]==cyclist)     {         last_distance[cyclist] += (time-last_time[cyclist]) * last_speed[cyclist];         last_time[cyclist]=time;         last_speed[cyclist]=newspeed;         return;     }     int opponent = tree[node];     last_distance[cyclist] += (time-last_time[cyclist]) * last_speed[cyclist];     last_time[cyclist]=time;     last_speed[cyclist]=newspeed;     last_distance[opponent] += (time-last_time[opponent]) * last_speed[opponent];     last_time[opponent]=time;     int challenger = cyclist;     if(last_speed[challenger] > last_speed[opponent])     {         ll numerator=time * (last_speed[challenger] - last_speed[opponent]) + last_distance[opponent] - last_distance[challenger];         ll denominator = (last_speed[challenger] - last_speed[opponent]);         ll newtime = numerator / denominator;         while((last_distance[challenger]+(newtime-time)*last_speed[challenger]) < (last_distance[opponent]+(newtime-time)*last_speed[opponent])) newtime++;         event e(newtime,node,challenger);         Q.push(e);     } }   void query2() {     ll time;     cin>>time;       //flushing     while(!Q.empty() && Q.top().time <= time)     {         event e=Q.top();         e.perform();         Q.pop();     }       int winner = tree[1];     last_distance[winner] += (time - last_time[winner]) * last_speed[winner];     last_time[winner] = time;     cout<<last_distance[winner]<<endl; }   int main() {     ios_base::sync_with_stdio(false);     cin.tie(0);   // freopen("input.c","r",stdin);      // freopen("1.out.c","w",stdout);     int n,q;     cin>>n>>q;     build(1,1,n);     while(q--)     {         int type;         cin>>type;         if(type==1) query1();         else query2();     } }  
#include <stdio.h> #include <stdlib.h> #include <math.h>  #define MIN(X,Y) ((X) < (Y) ? (X) : (Y)) #define MAX(X,Y) ((X) > (Y) ? (X) : (Y))  const double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286; const double _2_pi_plus_2 = 8.283185307179586476925286766559;  int main(){         int t;         scanf("%d",&t);         double w, h, max, A, R, temp, xc, xr, x, alfa;          while (t > 0) {             scanf("%lf %lf",&w ,&h);  			if (w < h) { 				temp = w; 				w = h; 				h = temp; 			}  			R = MIN(h / (2 * pi), w / 3); 			A = w - 2 * R; 			max = R * R * A;  			A = h; 			R = MIN(h / 4, w / _2_pi_plus_2); 			max = MAX(max, R * R * A);  			R = MIN(h / (2 * pi), w / _2_pi_plus_2); 			max = MAX(max, R * R * A);   			xc = w - h * (pi + 1); 			xr = sqrt(h * h + w * w); 			if (abs(xc) <= abs(xr)) { 				alfa = atan(w / h); 				x = alfa + asin(xc / xr); 				if (x >= 0 && x <= pi / 2) { 					R = h / 2 / (1 + cos(x)); 					max = MAX(max, R * R * A); 				} 			}  			R = MIN(h / 2, w / (4 + 2 * pi)); 			max = MAX(max, R * R * A);  			R = MIN(w / (2 * pi), h / 3); 			A = h - 2 * R; 			max = MAX(R * R * A, max);  			A = w; 			R = MIN(w / (2 * pi), h / _2_pi_plus_2); 			max = MAX(max, R * R * A);  			A = w; 			R = MIN(w / 4, h / _2_pi_plus_2); 			max = MAX(max, R * R * A);  			R = MIN(w / 2, h / (4 + 2 * pi)); 			max = MAX(max, R * R * A);  			A = w; 			 			xc = h - w * (pi + 1); 			xr = sqrt(h * h + w * w); 			if (abs(xc) <= abs(xr)) { 			alfa = atan(h / w); 			x = alfa + asin(xc / xr); 				if (x >= 0 && x <= pi / 2) { 					R = w / 2 / (1 + cos(x)); 					max = MAX(max, R * R * A); 				} 			}              printf("%.15lf\n",pi * max);             t--;         }         return 0;     } 
#include<bits/stdc++.h> using namespace std;  int binary_search(int list[],int r,int num){ 	int l=0; 	while(r-l>1){ 		int m=(l+r)/2; 		if(list[m]>num) 		r=m; 		else 		l=m; 	} 	return r; }  int LongestIncreasingSubsequence(long long int a[],int s,int n){ 	int *list=new int[n]; 	memset(list,0,sizeof(list[0])*n);  	list[0]=a[s]; 	int len=1; 	for(int i=s+1;i<n+s;i++){ 		if(a[i]<list[0]) 		list[0]=a[i]; 		 		else if (a[i]>list[len-1]) 		list[len++]=a[i]; 		 		else 		list[binary_search(list,len-1,a[i])]=a[i]; 	} 	return len; }   int main(){     int t;     cin>>t;     while(t--){ 	 	int n; 	cin>>n; 	long long int a[2*n]; 	for(int i=0;i<n;i++) 	{ 	cin>>a[i]; 	a[n+i]=a[i];       //copying same array two times in an array so that each elemnt has access to next n-1 numbers     }     int max=0;     int answer; 	for(int i=0;i<n;i++){	     answer=LongestIncreasingSubsequence(a,i,n);     if(answer>max)     max=answer;	    } 	cout<<max<<endl;  } 	return 0; }
/* codedevloper */ #include<iostream> #include<string.h> #include<map> #include<assert.h> #define MOD (30041975) #define MAXN (2002) 	using namespace std; 	int E[MAXN][MAXN]; 	int A[MAXN][MAXN]; 		void calcE() 	{ 				int i,j; 				for(i=0;i<MAXN;i++) 			{	 				E[0][i]=0; 				E[1][i]=0; 				E[i][0]=0; 			}		 				E[2][1]=2; 				for(i=3;i<MAXN;i++) 				for(j=1;j<i;j++) 					{ 						E[i][j]=((long long)j*E[i-1][j])%MOD+(2*E[i-1][j-1])%MOD; 						E[i][j]%=MOD; 							if(j>=2) 						E[i][j]+=((long long)(i-j)*E[i-1][j-2])%MOD; 						E[i][j]%=MOD; 					}		 	}	 		long long fact(int N) 			{ 				int res=1; 				int i; 				for(i=1;i<=N;i++) 				res=((long long)res*i)%MOD; return res; 	} 		void calcA() 				{ 					int i,j; 					for(i=3;i<MAXN;i++) 					A[i][0]=(fact(i))%MOD;	 					for(i=3;i<MAXN;i++) 					A[i][1]=(fact(i)-2+MOD)%MOD; 					for(i=3;i<MAXN;i++) 					for(j=2;i-j>=2;j++) 					A[i][j]=(A[i][j-1]-E[i][j]+MOD)%MOD; 				}	 int main() 	{ 		memset(E,0,sizeof(E)); 		memset(A,0,sizeof(A)); 			calcE(); 			calcA(); int i,j; 	for(i=0;i<MAXN;i++) 	for(j=0;j<MAXN;j++) 		if(A[i][j]<0) 		cout<<"FLAG"<<endl; 			for(i=0;i<MAXN;i++) 			for(j=0;j<MAXN;j++) 				if(E[i][j]<0) 				cout<<"FLAG"<<endl; int T; 	cin>>T; 	while(T--) { 	int N,K; 	cin>>N>>K; 	cout<<A[N][K]<<endl; } return 0; } /* codedevloper */
#include <iostream> #include <stdio.h> #include <string.h> #include <stdlib.h> #include <math.h> using namespace std;  int min(int a,int b,int c) {         if(a<b && a<c)                 return a;         if(b<c)                 return b;         else                 return c; }  char key[26]; char key1[26]; int cost[32][32]={0};  int dist(char s1[], char s2[]) {         int maxcost=(int)abs(strlen(s1)-strlen(s2));         if(maxcost>2)                 return 5;         for(int i=0;i<strlen(s1);++i)                 cost[i][0]=i;         for(int j=0;j<strlen(s2);++j)                 cost[0][j]=j;         for(int i=0;i<strlen(s1);++i)         {       int beg=0;//i-5;                 if(beg<0)                         beg=0;                 int end=strlen(s2);//i+5;                 if(end>strlen(s2))                         end=strlen(s2);                 int minv=332;                 for(int j=beg;j<end;++j)                 {       int c=0;                         if(s1[i]!=s2[j])                                 c=2;                         if(key[s1[i]-97]==s2[j] || key1[s1[i]-97]==s2[j])                                 c=1;                         int b=cost[i][j+1]+1;                         int a=cost[i+1][j]+1;                         //int b=j+1==end?5:cost[i][j+1]+1;                         //int a=j==beg?5:cost[i+1][j]+1;                         cost[i+1][j+1]=min(cost[i][j]+c,b,a);                         if(minv>cost[i+1][j+1])  minv=cost[i+1][j+1];                         //printf("%d ",cost[i+1][j+1]);                 } //              printf("\n");                 if(minv>3)                         return 5;         }         return cost[strlen(s1)][strlen(s2)];  }  int main() {         strcpy(key," vxswdfguhjknbio earycqzt ");         strcpy(key1,"snvfrghjokl  mp wtdyibecux");          int regdom,testdom;         scanf("%d %d",&regdom,&testdom);         char domains[regdom][31],testing[testdom][31];         int ans[testdom];         float ans2[testdom];         for(int i=0;i<regdom;++i)                 scanf("%s",domains[i]);         for(int i=0;i<testdom;++i)         {                 scanf("%s",testing[i]);                 ans[i]=31;                 ans2[i]=0;         }         for(int b=0;b<testdom;++b)         {                 for(int a=0;a<regdom;a++)                 {       int final=dist(domains[a],testing[b]);                         ans[b]=ans[b]<final?ans[b]:final;                         ans2[b]=final<3?ans2[b]+1:ans2[b];                         if(ans[b]==0)                                 break;                 } //              printf("Cost %s is %d\n",testing[b],ans[b]);                 if(ans[b]==0)                         printf("-1\n");                 else if(ans[b]>2)                         printf("0\n");                 else                         printf("%d\n",(3-ans[b])*25+(int)floor(log10(ans2[b])));         }         return 0; } 
#include <algorithm> #include <iostream> #include <sstream> #include <memory> #include <vector> #include <string> #include <bitset> #include <queue> #include <stack> #include <list> #include <set> #include <map> #include <climits> #include <cstring> #include <cstdio> #include <cmath> #include <ctime> #define FILL(a, v) (memset(a, v, sizeof(a))) #define foreach(i, Type, v) for(Type::iterator i=v.begin(); i!=v.end(); i++) using namespace std; typedef long long llong; typedef pair<int, int> Item;  const int Maxn = 100005+10; const int INF = 0x7f7f7f7f; const int MOD = 1000000009; const double eps = 1e-10; const double pi = acos(-1.0);  inline void AddMod(int &x, int det) { x += det; if( x >= MOD ) x -= MOD; } inline int CompareTo(double a, double b) { return (a>b+eps) ? 1 : ((a+eps<b)?-1:0); } template<typename T> int sz(const T &a) { return a.size(); } template<typename T> T str2num(string s) { istringstream i(s); T x; i>>x; return x; } template<typename T> string x2str(T x) { ostringstream o; o<<x; return o.str(); }  struct bignum { 	int x[4000],n; 	bignum(){n=0;memset(x,0,sizeof(x));} 	bignum(int a) 	{ 		n=0; 		memset(x,0,sizeof(x)); 		while(a>0)x[n++]=a%10,a/=10; 	} 	bignum operator +(const bignum&a)const 	{ 		bignum c=*this;int i,r; 		for(i=0,r=0;i<max(a.n,c.n)||r>0;i++) 		{ 			c.x[i]+=(i<a.n?a.x[i]:0)+r; 			r=c.x[i]>=10; 			if(r) 			{ 				r=c.x[i]/10;c.x[i]%=10; 			}	 		} 		c.n=i; 		return c; 	} 	bignum operator *(const bignum&a)const 	{ 		bignum c; 		memset(c.x,0,sizeof(c.x)); 		for(int i=0;i<a.n;i++) 		for(int j=0;j<n;j++) 		{ 			c.x[i+j]+=a.x[i]*x[j]; 		} 		c.n=a.n+n-1; 		c.trim(); 		return c; 	} 	void operator =(const bignum&a) 	{ 		n=a.n; 		for(int i=0;i<n;i++)x[i]=a.x[i]; 	} 	void operator=(int a) 	{ 		n=0; 		memset(x,0,sizeof(x)); 		while(a)x[n++]=a%10,a/=10; 	} 	bignum operator /(int v)const 	{ 		bignum c=*this; 		for(int i=n-1,r=0;i>=0;i--) 		{ 			int z=c.x[i]+r*10; 			r=z%v;c.x[i]=z/v; 		} 		c.trim(); 		return c; 	} 	void trim() 	{ 		int i,c; 		for(i=0,c=0;i<n||c;i++) 		{ 			x[i]+=c; 			c=x[i]>=10; 			if(c)c=x[i]/10,x[i]%=10; 		} 		n=i; 		while(n&&x[n-1]==0)n--; 	} 	void print() 	{ 		for(int i=n-1;i>=0;i--)printf("%d",x[i]); 		puts(""); 	} };     typedef unsigned long long ullong; int n; string str;  const int seed1=59, seed2=13799, MOD1=1299709, MOD2=1000000009; int h1[Maxn], b1[Maxn]; ullong h2[Maxn], b2[Maxn]; int hash_head[MOD1], hash_next[Maxn], hash_index; ullong hash_body[Maxn];  void hash_init() {     hash_index = 0;     FILL(hash_head, -1);     h1[0] = h2[0] = 0;     for(int i=0; i<n; i++)     {     	h1[i+1] = (h1[i]*seed1+str[i]-'a'+1)%MOD1;     	h2[i+1] = (h2[i]*seed2+str[i]-'a'+1)%MOD2;     }     b1[0] = b2[0] = 1;     for(int i=1; i<Maxn; i++)     {         b1[i] = b1[i-1]*seed1%MOD1;         b2[i] = b2[i-1]*seed2%MOD2;     } } bool insert(int t1, ullong t2) {     int p = hash_head[t1];     while( p != -1 )     {         if( hash_body[p] == t2 )             return false;         p = hash_next[p];     }     hash_body[hash_index] = t2;     hash_next[hash_index] = hash_head[t1];     hash_head[t1] = hash_index++;     return true; }  int num[2*Maxn], rad[2*Maxn]; void Manacher() { 	num[0] = -1;     int len = 1;     for(int i=0; i<n; i++)     {         num[len++] = str[i]-'a'+1;         num[len++] = 0;     }     num[len-1] = -2;  	FILL(rad, 0);     for(int i=1,j=0; i<len; )     {         while( num[i-j-1] == num[i+j+1] )             j++;         rad[i] = j;         int k = 1;         while( k<=j && rad[i-k]!=rad[i]-k )         {         	rad[i+k] = min(rad[i-k], rad[i]-k);         	k++;         }         i += k;         j = max(j-k, 0);     } }  int solve(int len) {     int ret = 0;     for(int i=1; i<len-1; i++)     {         int s, e;         if( num[i] > 0 )         {             s = (i+1)/2 - rad[i]/2;             e = (i+1)/2 + rad[i]/2;         }         else         {             s = i/2 - (rad[i]+1)/2 + 1;             e = i/2 + (rad[i]+1)/2;         }         while( s <= e )         {             int t1 = (h1[e] - 1LL*h1[s-1]*b1[e-s+1]%MOD1 + MOD1)%MOD1;             ullong t2 = (h2[e] - h2[s-1]*b2[e-s+1]%MOD2 + MOD2)%MOD2;             if (insert(t1, t2) == false)                 break;             else             {                 ret++; s++; e--;             }         }     }     return ret; }  bignum power[610]; int polya(int c, int len) { 	power[0] = 1; 	for(int i=1; i<=len; i++) 		power[i] = power[i-1]*bignum(c);  	bignum ans1=0, ans2=0; 	for(int i=1; i<=len; i++) 		ans1 = ans1+power[__gcd(len, i)]; 	if( len&1 ) 		ans2 = power[(len+1)/2]*bignum(len); 	else 		ans2 = (power[len/2]+power[len/2+1])*bignum(len/2); 	bignum ans = (ans1+ans2); 	ans = (ans1+ans2)/(2*len); 	ans.print(); 	return 0; } int main() { 	int N; 	ios::sync_with_stdio(0);  	cin>>str>>N; 	n = sz(str);  	hash_init(); 	Manacher(); 	int cnt = solve(2*n+1); 	if( polya(cnt, N) > 0 ) 		return 1;      return 0; }
#include <iostream> #include<stdio.h> #include<cmath> #include<string> #include<vector> #include<algorithm> #include <stdlib.h> #include <time.h> #define ll long long #define MOD 1000000007 using namespace std;  string S; ll K;  vector<string> goodStrings[51];  bool isAPSatisfied(string s,ll right) { 	if(right <= 1) 		return true;     ll maxD = (right)/2;     for(ll d=1; d<=maxD; d++)     {         ll i = right;         if((i-d-d >= 0))         {             ll j = i - d;             ll k = j - d;             if(s[i] == s[j] && s[j] == s[k])                 return false;         }     }     return true; }    void valid(ll *count,string s) {     /*ll h = 0;     for(ll i=0,l=s.length(); i<l; i++)     {         if(s[i] != S[i])         {             h++;             if(h > K)                 return;         }     }*/      if(isAPSatisfied(s,s.length()-1))     {         *count = (*count) + 1;         if(*count >= MOD)             *count = (*count)%MOD;     } }  void permuteAndCount(ll *count,string s,ll left,ll right,ll a, ll h) {     if(left != 0)     {     	if(S[left-1] != s[left-1])     		h++;     	if(h > K)     		return;         if(!isAPSatisfied(s,left-1))             return;     }      if(left == right)     {     	ll temp;         if(1 <= a)         {             s[left] = 'a';             if(S[left] != 'a')             	temp = 1;             else temp = 0;             if(h + temp <= K)             	valid(count,s);         }         if(2 <= a)         {             s[left] = 'b';             if(S[left] != 'b')             	temp = 1;             else temp = 0;             if(h + temp <= K)             	valid(count,s);          }         if(3 <= a)         {             s[left] = 'c';             if(S[left] != 'c')             	temp = 1;             else temp = 0;             if(h + temp <= K)             	valid(count,s);         }     }     else     {         string tempS = s;         if(1 <= a)         {             tempS[left] = 'a';             permuteAndCount(count,tempS,left+1,right,a,h);         }         if(2 <= a)         {             tempS[left] = 'b';             permuteAndCount(count,tempS,left+1,right,a,h);         }         if(3 <= a)         {             tempS[left] = 'c';             permuteAndCount(count,tempS,left+1,right,a,h);         }     } }  void findGoodStrings(string s,ll left,ll right,ll a) {     if(left != 0)     {         if(!isAPSatisfied(s,left-1))             return;         goodStrings[left].push_back(s.substr(0,left));     }      if(left == right)     {     	ll temp;         if(1 <= a)         {             s[left] = 'a';             if(S[left] != 'a')             	temp = 1;             else temp = 0;             if(isAPSatisfied(s,left))             	goodStrings[left+1].push_back(s);         }         if(2 <= a)         {             s[left] = 'b';             if(S[left] != 'b')             	temp = 1;             else temp = 0;             if(isAPSatisfied(s,left))             	goodStrings[left+1].push_back(s);          }         if(3 <= a)         {             s[left] = 'c';             if(S[left] != 'c')             	temp = 1;             else temp = 0;             if(isAPSatisfied(s,left))             	goodStrings[left+1].push_back(s);         }     }     else     {         string tempS = s;         if(1 <= a)         {             tempS[left] = 'a';             findGoodStrings(tempS,left+1,right,a);         }         if(2 <= a)         {             tempS[left] = 'b';             findGoodStrings(tempS,left+1,right,a);         }         if(3 <= a)         {             tempS[left] = 'c';             findGoodStrings(tempS,left+1,right,a);         }     } }   bool isPossibleAtAll(ll a) {     ll h = 0;     string temp = "";     char c[3] = {'a','b','c'};     for(ll i=0,l=S.length(); i<l; i++)     {         bool check = true;         for(int j=0; j<a; j++)             if(S[i] == c[j])         {             check = false;             break;         }         if(check)         {             h++;             if(h > K)                 return false;         }     }     return true; }  bool hammingCheck(string s1,string s2) {     ll h = 0;     for(ll i=0,l=s1.length(); i<l; i++)     {         if(s1[i] != s2[i])             h++;         if(h>K)             return false;     }     return true; }  int main() {     ll t;     scanf("%lld",&t);     findGoodStrings("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",0,49,3);     string w = "abc";     while(t--)     {         ll a,k;         scanf("%lld %lld",&a,&K);         string s;//= "abcbcbcadfcbdfgbcdfebcdbabcbdbfbcbdsabccbbccabcvdc";         cin>>s;          ll count = 0;         S = s;         //count = 0;         if(isPossibleAtAll(a))         {             if(a != 3)             {                 permuteAndCount(&count,s,0,s.length()-1,a,0);                 printf("%lld\n",count);             }             else             {                 ll sLen = s.length();                  for(ll i=0,l=goodStrings[sLen].size(); i<l; i++)                 {                     if(hammingCheck(goodStrings[sLen][i],S))                     {                         count = count + 1;                         if(count >= MOD)                             count = count%MOD;                     }                  }                 printf("%lld\n",count);             }         }       }     return 0; } 
/*      Harsh Vardhan :)  */  #include<iostream> #include<cstdio> #include<algorithm> #include<cmath> #include<vector> #include<set> #include<map> #include<iomanip> #include<cstring> #include<queue> #include<stack> #include<limits>  using namespace std;  #define MAX 111111 #define gi(n) scanf("%d",&n) #define gl(n) scanf("%lld",&n) #define pi(n) printf("%d\n",n) #define pl(n) printf("%lld\n",n) #define all(c) c.begin(), c.end() #define M_PI 3.14159265358979323846 #define tr(v, it) for(typeof(v.begin()) it = v.begin(); it != v.end(); it++) #define mp make_pair #define F first #define S second   typedef long long LL; const int mod=1000000007;   LL fac[27]; LL inv[27];   LL powerMod(LL b, LL p, int d) { 	LL l=1; 	while(p) 	{ 		if(p & 1) l=l*b%d; 		b=b*b%d; 		p>>=1; 	} 	return l; }   int main() { 	int h, i, t; 	fac[0]=inv[1]=1; 	for(i=1;i<27;i++) 	{ 		fac[i]=fac[i-1]*i%mod; 	} 	inv[1]=1; 	for(i=2;i<27;i++) 	{ 		inv[i]=inv[mod%i]*(mod - mod/i)%mod; 	} 	scanf("%d", &t); 	for(h=0;h<t;h++) 	{ 		LL ans=0, n, k; 		gl(n);gl(k); 		if(k>1) 		{ 			LL n0=powerMod(k,n,mod); 			LL n1=n0*k%mod; 			LL d1=inv[k-1]; 			LL d2=d1*d1%mod; 			LL T=k*(n0-1)%mod*d1%mod; 			LL s2=((n*n1%mod*d1%mod)-(T*d1%mod))%mod; 			LL s5=(s2*T+s2)%mod; 			LL s6=((n1*T%mod*d2%mod)+(n*n%mod*n1%mod*d1%mod)-(4*n*n1%mod*d2%mod)+(T*(3*d2+d1)%mod))%mod; 			LL s7=T*T%mod; 			ans=((s7*T%mod)-s5*6+s6*3+s7*3+T*2)%mod; 			if(ans<0) ans+=mod; 		} 		pl(ans); 	} 	return 0; }
#include <cstdio> #include <cstring> #include <algorithm> #include <vector> #include <string> #include <cmath> #include <cctype> #include <queue> #include <stack> #include <map> #include <set> #include <iostream> #include <ctime> #include <cassert> #include <sstream>  using namespace std;  #define INF 0x3f3f3f3f #define ll long long #define SZ(x) (int)((x).size()) #define MAXN 300  int n; map<string,int> mymap; vector<int> filhos[MAXN]; int mano[MAXN][MAXN]; int adj[MAXN][MAXN];  int main() {     int m,t = 1;     cin.sync_with_stdio(false);     cin>>n>>m;     memset(adj,INF,sizeof(adj));     while (m--)     {         string A,is,F,of,B;         cin>>A>>is>>F>>of>>B;         int u,v;         if (!mymap[A]) mymap[A] = t++;         if (!mymap[B]) mymap[B] = t++;         u = mymap[A];         v = mymap[B];         if (F == "father") filhos[u].push_back(v), adj[u][v] = adj[v][u] = 1;         if (F == "mother") filhos[u].push_back(v), adj[u][v] = adj[v][u] = 1;         if (F == "sister" || F == "brother") mano[u][v] = mano[v][u] = adj[u][v] = adj[v][u] = 1;         if (F == "son") filhos[v].push_back(u), adj[u][v] = adj[v][u] = 1;         if (F == "daughter") filhos[v].push_back(u), adj[u][v] = adj[v][u] = 1;     }        while (true)     {         bool changed = false;         for (int i=1; i<t; i++)         {             for (int j=0; j<int(filhos[i].size()); j++)             {                 int v = filhos[i][j];                 for (int k=1; k<t; k++)                     if (mano[v][k] && adj[i][k] > 1)                     {                         adj[i][k] = adj[k][i] = 1;                         filhos[i].push_back(k);                         changed = true;                     }             }              for (int j=0; j<int(filhos[i].size()); j++)                 for (int k=j+1; k<int(filhos[i].size()); k++)                 {                     int u = filhos[i][j], v = filhos[i][k];                     if (adj[u][v] > 1)                     {                         adj[u][v] = adj[v][u] = 1;                         mano[u][v] = mano[v][u] = 1;                         changed = true;                     }                 }              for (int j=1; j<t; j++)                 if (mano[i][j])                 {                     for (int k=1; k<t; k++)                         if (mano[j][k] && !mano[i][k] && k != i)                         {                             mano[i][k] = mano[k][i] = 1;                             adj[i][k] = adj[k][i] = 1;                             changed = true;                         }                 }         }         if (!changed) break;     }      for (int k=1; k<t; k++)         for (int i=1; i<t; i++)             for (int j=1; j<t; j++)                 adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j]);      int Q;     cin>>Q;     while (Q--)     {         string x,y;         cin>>x>>y;         int ans = adj[mymap[x]][mymap[y]];         if (ans == INF) ans = -1;         printf("%d\n",ans);     }      return 0; } 
#include <bits/stdc++.h>  using namespace std;  vector<int> integers,primes,powers_of_2;  void make_primes() { 	for(int i=2;i<10005;i++) 	{ 		if(integers[i]==1)continue; 		for(int j=2*i;j<10005;j+=i) 		{ 			integers[j]=1; 		} 	} 	for(int i=2;i<10005;i++) 	{ 		if(integers[i]==0)primes.push_back(i); 	} }  int main() { 	integers.resize(10005); 	make_primes(); 	int t,n; 	cin>>t; 	for(int i=0;i<t;i++) 	{ 		cin>>n; 		bool isprime=true; 		for(int j=0;j<primes.size()&&primes[j]<n;j++) 		{ 			if(n%primes[j]==0){isprime=false;break;} 		} 		 		if((isprime&&n!=2&&n!=17))cout<<"Tom"<<endl; 		else if(n==2||n==17) cout<<"Mike"<<endl; 		else if(n!=16&&n!=34&&n!=289&&!isprime)cout<<"Mike"<<endl; 		else cout<<"Tom"<<endl; 	} }
#include<bits/stdc++.h> using namespace std; long long mod=1000000007; int a[1003],visit[1003],opp[1003]; // op opposite  struct node { 	int p,q,val; }arr[1000006];  struct myfun { 	bool operator() (node a,node b) 	{ 		return a.val>b.val; 	} }; int power(int a,int n) { 	if(n==1) 	return a; 	 	long long ans=power(a,n/2); 	ans=(ans*ans)%mod; 	if(n%2) 	ans=(ans*a)%mod; 	return ans; } int f(int i) { 	if(i==a[i]) 	return a[i]; 	 	a[i]=f(a[i]); 	return a[i]; } void union1(int i,int j) { 	f(i); 	f(j); 	int mx=max(a[i],a[j]); 	int mn=min(a[i],a[j]); 	a[mx]=a[mn]; } void init(int m) { 	for(int i=0;i<=m;++i) 	{a[i]=i;visit[i]=0;} } int main() { 	 	int t,id[1003],i,k,j,m; 	cin>>t; 	while(t--) 	{ 		cin>>m; 		init(m); 		for(i=0;i<m;++i) 		cin>>id[i]; 		 		k=0; 		for(i=0;i<m;++i) 		for(j=i+1;j<m;++j) 		{ 			arr[k].p=i; 			arr[k].q=j; 			arr[k].val=min(power(id[i],id[j]),power(id[j],id[i])); 			k++; 		} 		 		sort(arr,arr+k,myfun()); 		 		node x; 		for(i=0;i<k;++i) 		{ 			x=arr[i]; 			int p=x.p,q=x.q; 			 			if(visit[p]==0 && visit[q]==0) 			{ 				visit[p]=1; 				opp[p]=q; 				visit[q]=1; 				opp[q]=p; 			} 			else 			if(visit[p]==1 && visit[q]==0) 			{ 				union1(q,opp[p]); 				visit[q]=1; 				opp[q]=p; 			} 			else  			if(visit[q]==1 && visit[p]==0) 			{ 				union1(p,opp[q]); 				visit[p]=1; 				opp[p]=q; 			} 			else 			{ 				if(f(p)==f(q)) 				{ 					cout<<x.val<<'\n'; 					break; 				} 				//**********************error may be 				union1(p,opp[q]); 				union1(q,opp[p]); 			} 			 			 		} 		 			 	} 	//min(power(a,b),power(b,a)); }
#pragma warning(disable:4786) #include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<set> #include<map> #include<functional> #include<string> #include<cstring> #include<cstdlib> #include<queue> #include<utility> #include<fstream> #include<sstream> #include<cmath> #include<stack> #include<cstdio> #include <ctime> #include<cassert>   using namespace std;   #define MEM(a,b) memset(a,(b),sizeof(a)) #define MAX(a,b) ((a) > (b) ? (a) : (b)) #define MIN(a,b)  ((a) < (b) ? (a) : (b)) #define istr(S) istringstream sin(S) #define MP make_pair #define pb push_back #define inf 1000000000 #define maxn 1000000   typedef long long  LL; //typedef __int64 LL; typedef pair<int,int> pi; typedef vector<int> vi; typedef vector<string> vs; typedef vector<double> vd;       int main() { 	int i,j,k,tests,cs=0,n,m; 	   	//freopen("D:\\divpair.in","r",stdin); 	//freopen("D:\\divpair2.out","w",stdout);   	scanf("%d",&tests); 	assert(1<=tests && tests<=100000);   	while(tests--) 	{ 		scanf("%d%d",&n,&m);         /*  int count=0;         for(i=1;i<=n;i++)         {         	for(j=i+1;j<=n;j++)         	{ 	        	if((i+j)%m==0) 	        	{ 	        	cout<<i<<" "<<j<<endl; 	        	count++; 	        	} 	        }         }          cout<<"count= "<<count<<endl; */ 		LL x=n/m,y=n%m; 		LL ans=0;         if(m%2)         {         	ans += (x*x*(m-1))/2;         	ans += (x*(x-1))/2;         } 		else 		{ 			 			ans = (x*x); 			ans=((m-1)/2)*ans;         	ans += (x*(x-1)); 		} 		ans+=x*y; 		if(y>m/2) ans+= y-m/2;   		printf("%lld\n",ans); 	} 	return 0; }  
/**  * January 2013 Long Challenge at Codechef  *  * Problem:     DIVPRO - Dividing Products  * Author:      Anton Lunyov (Tester and Editorialist)  * Complexity:  O(L^5 * B + T * log(L^4)), where B = 10  * Timing:      1.02 out of 3.00 (0.54 with #define FAST)  *  * Description:  * See editorial :)  */  // uncomment to speed up the solution almost twice //#define FAST  #include <cstdio> #include <cstring> // need memset from here #include <algorithm> // need sort and lower_bound from here #include <vector> // use vectors to save dp-values using namespace std;  const int maxL = 36; const int maxL1 = (maxL+1)/2; const int N2 = 3*maxL1; const int N3 = 2*maxL1; const int N5 = maxL1; const int N7 = maxL1; // N2, N3, N5, N7 are used to access dp[L][n2][n3][n5][n7] // from the editorial as dp[p][N2+n2][N3+n3][N5+n5][N7+n7]  // the main dp array unsigned dp[2][2 * N2 + 1][2 * N3 + 1][2 * N5 + 1][2 * N7 + 1];  // d = 2^g2[d] * 3^g3[d] * 5^g5[d] * 7^g7[d] // digits are 0  1  2  3  4  5  6  7  8  9 int g2[10] = {0, 0, 1, 0, 2, 0, 1, 0, 3, 0}; int g3[10] = {0, 0, 0, 1, 0, 0, 1, 0, 0, 2}; int g5[10] = {0, 0, 0, 0, 0, 1, 0, 0, 0, 0}; int g7[10] = {0, 0, 0, 0, 0, 0, 0, 1, 0, 0};  int main() {  	// Vres[L][i] is the pair (V, dp_val) 	// where dp_val is the answer for the problem with input (L, V) 	vector<pair<long long, unsigned> > Vres[maxL + 1];  	// pw9[n] is 9^n modulo 2^32 	unsigned pw9[maxL + 1] = {1};  	// pw10[n] is 10^n modulo 2^32 	unsigned pw10[maxL + 1] = {1};  	// loop over L to compute results for V = 0 	for(int L=1;L<=maxL;L++) 	{ 		// calculation of pw9[L] and p10[L] from the previous values 		pw9[L] = 9 * pw9[L - 1]; 		pw10[L] = 10 * pw10[L - 1];  		// calculating answer for the problem in the case V = 0 		// see editorial for details 		int X = (L - 1) /2; 		unsigned res0 = pw9[L - X] * (pw10[X] - pw9[X]);  		// saving this result in Vres[L] 		Vres[L].push_back(make_pair(0LL, res0)); 	}  	// precalculation of powers of 2, 3, 5, 7 to restore V by (n2, n3, n5, n7) 	// in O(1) time while saving dp-values  	// pw2[n] is 2^n 	long long pw2[N2 + 1] = {1}; 	for(int n = 1; n <= N2; ++n) { 		pw2[n] = 2 * pw2[n - 1]; 	}  	// pw3[n] is 3^n 	long long pw3[N3 + 1] = {1}; 	for(int n = 1; n <= N3; ++n) { 		pw3[n] = 3 * pw3[n - 1]; 	}  	// pw5[n] is 5^n 	long long pw5[N5 + 1] = {1}; 	for(int n = 1; n <= N5; ++n) { 		pw5[n] = 5 * pw5[n - 1]; 	}  	// pw7[n] is 7^n 	long long pw7[N7 + 1] = {1}; 	for(int n = 1; n <= N7; ++n) { 		pw7[n] = 7 * pw7[n - 1]; 	}  	// p is the variable that control current layer of DP 	int p = 0;  	// init of dp[0][][][][] 	// at first set all to zero 	memset(dp[p], 0, sizeof dp[p]); 	// and then assign 1 to dp[0][0][0][0][0] from editorial 	// which is dp[p][N2][N3][N5][N7] according to comments above 	dp[p][N2][N3][N5][N7] = 1;  	// the main loop over L to calculate dp-values 	for (int L = 1; L <= maxL; ++L) 	{ 		// we flip p to change the layer in dp array 		// where we will save the dp for the current value of L 		p = !p;  		// we will iterate over dp[L-1][][][][] from editorial 		// hence L1 and L2 are calculated for L-1 		int L1 = L / 2; 		int L2 = (L - 1) - L1; 		// for L = 0 we need adjust L2 since it appears to be -1 		if (L == 0) { 			L2 = 0; 		}  		// init of dp[L][][][][] which is dp[p][][][][] by setting all to zero 		memset(dp[p], 0, sizeof dp[p]);  		// loop over arrays (n2, n3, n5, n7) as described in the editorial 		for (int n2 = -3 * L2; n2 <= 3 * L1; ++n2) { 			for (int n3 = - 2 * L2; n3 <= 2 * L1; ++n3) { 				for (int n5 = -L2; n5 <= L1; ++n5) { 					for (int n7 = -L2; n7 <= L1; ++n7) { 						// the value of dp[L-1][n2][n3][n5][n7] 						unsigned cnt = dp[!p][N2 + n2][N3 + n3][N5 + n5][N7 + n7]; 						// we don't need to process zero value 						// it is important optimization 						if (cnt > 0) { #ifndef FAST 							// loop over digits 							for (int d = 1; d <= 9; ++d) { 								// and using the formula from editorial 								dp[p][N2 - n2 + g2[d]][N3 - n3 + g3[d]][N5 - n5 + g5[d]][N7 - n7 + g7[d]] += cnt; 							} #else  							// note that writing the following quite ugly copy-pasted code 							// instead of this elegant loop speeds up the program twice: 							dp[p][N2-n2]  [N3-n3]  [N5-n5]  [N7-n7]  += cnt; // digit 1 							dp[p][N2-n2+1][N3-n3]  [N5-n5]  [N7-n7]  += cnt; // digit 2 							dp[p][N2-n2]  [N3-n3+1][N5-n5]  [N7-n7]  += cnt; // digit 3 							dp[p][N2-n2+2][N3-n3]  [N5-n5]  [N7-n7]  += cnt; // digit 4 							dp[p][N2-n2]  [N3-n3]  [N5-n5+1][N7-n7]  += cnt; // digit 5 							dp[p][N2-n2+1][N3-n3+1][N5-n5]  [N7-n7]  += cnt; // digit 6 							dp[p][N2-n2]  [N3-n3]  [N5-n5]  [N7-n7+1]+= cnt; // digit 7 							dp[p][N2-n2+3][N3-n3]  [N5-n5]  [N7-n7]  += cnt; // digit 8 							dp[p][N2-n2]  [N3-n3+2][N5-n5]  [N7-n7]  += cnt; // digit 9 #endif 						} 					} 				} 			} 		}  		// we recalc L1 for the L instead of L-1 		// we don't need L2 below 		L1 = (L + 1)/2;  		// loop over dp[L][][][][][] by arrays (n2, n3, n5, n7) 		// with non-negative elements to save non-zero dp-values to Vres[L] 		for (int n2 = 0; n2 <= 3 * L1; ++n2) { 			for (int n3 = 0; n3 <= 2 * L1; ++n3) { 				for (int n5 = 0; n5 <= L1; ++n5) { 					for (int n7 = 0; n7 <= L1; ++n7) {  						// the value of dp[L][n2][n3][n5][n7] 						unsigned cnt = dp[p][N2 + n2][N3 + n3][N5 + n5][N7 + n7];  						// we are interested only in positive dp-values 						if (cnt > 0) {  							// we calc V as 2^n2 * 3^n3 * 5^n5 * n^n7 							// using precalculated arrays of powers 							long long V = pw2[n2] * pw3[n3] * pw5[n5] * pw7[n7];  							// finally we add pair (V, cnt) to Vres[L] 							Vres[L].push_back(make_pair(V, cnt)); 						} 					} 				} 			} 		} 	}  	// sorting Vres[L] for each L to apply binary search further 	for (int L = 0; L <= maxL; ++L) { 		sort(Vres[L].begin(), Vres[L].end()); 	}  	// input number of tests 	int T; 	scanf("%d", &T); // we use scanf for faster input  	// loop over tests 	for (int t = 0; t < T; ++t) {  		// input numbers L and V 		int L; 		long long V; 		scanf("%d%lld", &L, &V);  		// finding the position of the first element in Vres[L] having Vres[L].first >= V 		// the complexity is O(log Vres[L].size()) since lower_bound behaves like binary search 		int pos = lower_bound(Vres[L].begin(), Vres[L].end(), make_pair(V, 0U)) - Vres[L].begin();  		unsigned ans = 0;  		// recognizing whether for the pair (L, V) we have non-zero answer 		if (pos < Vres[L].size() && Vres[L][pos].first == V) { 			// Vres[L][pos].second is the result for pair (L, V) 			ans = Vres[L][pos].second; 		}  		// output the result, note specifier %u here 		printf("%u\n", ans); 	} 	return 0; }
#include <iostream> #include <math.h> #include <cstdio> #include <algorithm> #include <memory.h> #define ll long long using namespace std; ll sum[100001],a[100001],ind[100001]; bool used[100001]; int main() {     ll n,t,test;     cin >> test;     for(ll p = 1 ;p <= test ;p++)     {         cin >> n;         memset(ind,0,sizeof(ind));         memset(used,0,sizeof(used));         ind[0] = 0;         used[0] = 1;         for(ll i = 1 ;i <= n ;i++)         {             cin >> a[i];             sum[i] = (sum[i-1] + a[i] % n) % n;         }         for(ll i = 1 ;i <= n ;i++)         {             if(used[sum[i]] == 1)             {                 cout << i - ind[sum[i]] << endl;                 for(ll j = ind[sum[i]]+1 ;j <= i ;j++)                   cout << j << " ";                 cout << endl;                 break;             }             ind[sum[i]] = i;             used[sum[i]] = 1;         }     }     return 0; } 
#include<stdio.h> int BIT1[100010]; int query(int indx) { 	int count=0; 	while(indx>0) 	{ 		count+=BIT1[indx]; 		indx-=(indx&-indx); 	} 	return count; }  void update(int indx,int val,int n) { 	while(indx<=n) 	{ 		BIT1[indx]+=val; 		indx+=(indx&-indx); 	} } int main() { 	int i,n,q,max=-100; 	int array[100010]; 	scanf("%d %d",&n,&q); 	for(i=0;i<n;i++) 	{ 		scanf("%d",&array[i]); 		if(max<array[i]) 		max=array[i]; 	} //	build(array,0,n-1,0); 	int count=0,c; 	for(i=0;i<=max;i++) 	BIT1[i]=0; 	int ii=0; 	for(i=n-1;i>=0;i--) 	{ 	//	for(ii=0;ii<=max;ii++) 	 //    printf("%d ",BIT1[ii]); 	//printf("\n"); 		c=query(array[i]-1); 		//printf("for %d return %d\n",i,c); 		count+=(c%2); 		count=count%2; 		update(array[i],1,max); 	} 	//printf("invsn %d\n",count); 	int intr,u,v; 	for(i=1;i<=q;i++) 	{ 		scanf("%d %d",&u,&v); 		count=!count; 		printf("%d\n",count); 	} }
#include <iostream> using namespace std; int A,B,C,P; int ans1, ans2;   //return x such that a*x+b*y = 1 for some integer y int extendedGCD(int a, int b) {   int x = 0, y = 1;    int lastx = 1, lasty = 0;   while(b != 0)     {       int q = a/b;       int temp = b; b = a % b; a = temp;       temp = x; x = lastx - q*x; lastx = temp;       temp = y; y = lasty-q*y; lasty = temp;     }   return lastx; }   //Calculate b^s mod p int powermodulo(int b, int s, int p) {   if(s == 1) return b%p;   if(s == 0) return 1;   int tr = int((long long)b*b % p);   if(s % 2 == 0) return powermodulo(tr, s/2,p);   return ((long long)b*powermodulo(tr,(s-1)/2,p))%p; }     //solves x*x == a (mod p) int solvequadratic(int a, int p) {   if(a > p) a = a%p;   while(a < 0) a = a+p;   if(a == 0)     return 0;   if(powermodulo(a,(p-1)/2,p) != 1)       return -1;     int n = 0, k = p-1;   while(k % 2 == 0)        k/=2, n++;   int q = 2;   while(powermodulo(q,(p-1)/2,p) != (p-1))     q++;   int t = powermodulo(a,(k+1)/2,p);   int r = powermodulo(a,k,p);   while(true)     {       int s = 1;       int i = 0;       while(powermodulo(r,s,p) != 1) 	i+=1, s*=2;       if(i == 0)  	  return t;        int e = 1<<(n-i-1);       int u = powermodulo(q, k*e,p);       t = ((long long)t*u)%p;       r = ((long long)r*u*u)%p;     } }   //solves ax == b (mod p) int solvelinear(int  a, int  b, int p) {   if(a > p) a = a%p;   while(a < 0) a = a+p;     if(b > p) b = b%p;   while(b < 0) b = b+p;      if(b == 0) return 0;   int x = extendedGCD(a,p);   if(x > p) x = x%p;   while(x < 0) x+=p;   return int(((long long)b*x)%p); }     void solve() {   ans1 = -1, ans2 = -1;   if(B == C && C == 0)     {       ans1 = 0; return;     }   else if(P == 2)     {       if(C == 0) ans1 = 0;       if((A + B + C)%P == 0) ans2 = 1;       return;     }   else if(C == 0)     {       ans1 = 0;       ans2 = solvelinear(A,P-B,P);       return;     }   else if(B == 0)     {       int y = solvequadratic(((long long)A*(P-C))%P,P);       if(y == -1) return;       ans1 = solvelinear(A,y,P);       if(y == 0) return;       ans2 = solvelinear(A,P-y,P);       return;     }   else     {       int y = solvequadratic(((long long)B*B-4LL*A*C)%P,P);       if(y == -1) return;       ans1 = solvelinear(int(2LL*A),y-B,P);       if(y == 0) return;       ans2 = solvelinear(int(2LL*A),P-y-B,P);       return;     }        }   int main() {   int T;   scanf("%d",&T);   for(int t = 1; t <= T; ++t)     {       scanf("%d%d%d%d", &A,&B,&C,&P);       solve();       if(ans1 == -1 && ans2 == -1) printf("0\n");       else if(ans1 >= 0 && ans2 == -1) printf("1 %d\n", ans1);       else if(ans2 >= 0 && ans1 == -1) printf("1 %d\n", ans2);       else if(ans1 < ans2) printf("2 %d %d\n", ans1,ans2);       else if(ans1 == ans2) printf("1 %d\n", ans1);       else printf("2 %d %d\n", ans2, ans1);     } }
/* 	Author: chnlich */  #include<cstdio> #include<cstdlib> #include<cstring> #include<ctime> #include<cmath> #include<cctype> #include<climits> #include<iostream> #include<fstream> #include<sstream> #include<algorithm> #include<numeric> #include<functional> #include<map> #include<set> #include<vector> #include<queue> #include<stack> #include<bitset> #include<string> #include<list> #include<deque> #include<utility>  using namespace std;  typedef long long llint; typedef pair<int,int> ipair; typedef vector<int> vi; #define pb push_back #define mp make_pair #define fi first #define se second #define debug(x) cerr<<#x<<'='<<x<<endl;  const int MAXN=131072;  void read(int &k) { 	char x=getchar(); k=0; 	while(x<'0'||x>'9') x=getchar(); 	while(x>='0'&&x<='9') { k=k*10-48+x; x=getchar(); } }  map<llint,int> cost; int n,m,p,q,c[8],len; llint A,B,G,now,a,st[8]; string s;  llint mul(llint a,llint b,llint B) { 	llint ret=0; 	for(;b;b>>=1,a=(a<<1)%B) 		if (b&1) ret=(ret+a)%B; 	return ret; }  llint powe(llint a,llint b,llint B) { 	llint ret=1%B; 	for(;b;b>>=1,a=mul(a,a,B)) 		if (b&1) ret=mul(ret,a,B); 	return ret; }  void fenjie(int k) { 	memset(c,0,sizeof c); 	len=0; 	while(k) 	{ 		c[++len]=k%10; 		k/=10; 	} }  int main() { 	cin>>n>>A>>B>>G; 	if (n==1) 	{ 		cout<<G<<endl; 		return 0; 	} 	m=n>>1; 	p=powe(10,m,10000000); 	q=powe(10,n-m,10000000); 	st[0]=1; 	for(int i=1;i<=6;i++) st[i]=mul(st[i-1],A,B); 	for(int i=q-1;i>=0;i--) 	{ 		//if (i%10000==0)cerr<<i<<endl; 		fenjie(i); 		now=0; 		for(int j=1;j<=n-m;j++) now=(now+c[j]*st[j-1])%B; 		cost[now]=i; 	} 	a=powe(A,n-m,B); 	for(int i=0;i<p;i++) 	{ 		//if (i%10000==0) cerr<<i<<endl; 		fenjie(i); 		now=0; 		for(int j=1;j<=m;j++) now=(now+c[j]*st[j-1])%B; 		now=(G-mul(now,a,B)+B)%B; 		if (cost.find(now)!=cost.end()) 		{ 			for(int j=m;j;j--) s+=c[j]+48; 			fenjie(cost[now]); 			for(int j=n-m;j;j--) s+=c[j]+48; 			cout<<s<<endl; 			return 0; 		} 	} 	 	return 0; } 
#include <cstdio> #include <cstring>   #include <vector> #include <queue> #include <algorithm> #include <map>   using namespace std;   #define FOREACH(it,c) for(typeof((c).begin()) it=(c).begin();it!=(c).end();++it)   struct Event { int id; char gender, type; Event(int _id, char _gender, char _type) : id(_id), gender(_gender), type(_type) {} };   int B, G, L; int BS[200], BT[200]; int GS[200], GT[200]; bool likes[2][200][200];   class BipartiteMatchingHK { const int static INF = 98765432; size_t Lsz, Rsz; vector<int> dist; bool _bfs(); bool _dfs(int v); vector< vector<int> > adj; public: const int static NIL_VERTEX = 0; vector<bool> active;   // output: warning: vertex indices start with 1, not 0 vector<int> match;   BipartiteMatchingHK(size_t _Lsz, size_t _Rsz) : Lsz(_Lsz), Rsz(_Rsz), adj(Lsz+1), active(_Lsz+_Rsz+1) {}   void add_edge(int u, int v);   int process(); };   inline void BipartiteMatchingHK::add_edge(int u, int v) { adj[u + 1].push_back(v + Lsz + 1); }   int BipartiteMatchingHK::process() { match = vector<int>(Lsz+Rsz+1, +NIL_VERTEX); int nmatches = 0; dist = vector<int>(Lsz+1, +INF); active[NIL_VERTEX] = true; while (_bfs()) { for (int u = 1; u <= Lsz; ++u) if (active[u] && match[u] == NIL_VERTEX && _dfs(u)) ++nmatches; } return nmatches; }   bool BipartiteMatchingHK::_dfs(int u) { if (!active[u]) return false; if (u == NIL_VERTEX) return true; for (int j = 0; j < adj[u].size(); ++j) { int v = adj[u][j]; if (!active[v]) continue; if ( dist[ match[v] ] == dist[u]+1 && _dfs( match[v] ) ) { match[v] = u; match[u] = v; return true; } } dist[u] = INF; return false; }   bool BipartiteMatchingHK::_bfs() { queue<int> q; for (int u = 1; u <= Lsz; ++u) { if (active[u] && match[u] == NIL_VERTEX) { dist[u] = 0; q.push(u); } else dist[u] = INF; } dist[NIL_VERTEX] = INF; while (!q.empty()) { int u = q.front(); q.pop(); if (u == NIL_VERTEX) continue; for (int j = 0; j < adj[u].size(); ++j) { int v = adj[u][j]; if (!active[v] || !active[ match[v] ]) continue; if (dist[ match[v] ] >= INF) { dist[ match[v] ] = dist[u] + 1; q.push(match[v]); } } } return dist[NIL_VERTEX] < INF; }     int main(int argc, char* argv[]) { int TC; scanf("%d", &TC); for (int tc = 1; tc <= TC; ++tc) { scanf("%d %d %d", &B, &G, &L); for (int i = 0; i < B; ++i) memset(likes[0][i], 0, sizeof(int)*(G+1)); for (int j = 0; j < G; ++j) memset(likes[1][j], 0, sizeof(int)*(B+1)); map< int, vector<Event> > events; for (int i = 0; i < B; ++i) { int N; scanf("%d %d %d", BS+i, BT+i, &N); events[BS[i]].push_back( Event(i, 'B', 'E') ); events[BT[i]].push_back( Event(i, 'B', 'X') ); while (N-- > 0) { int v; scanf("%d", &v); likes[0][i][v] = true; } } for (int j = 0; j < G; ++j) { int N; scanf("%d %d %d", GS+j, GT+j, &N); events[GS[j]].push_back( Event(j, 'G', 'E') ); events[GT[j]].push_back( Event(j, 'G', 'X') ); while (N-- > 0) { int v; scanf("%d", &v); likes[1][j][v] = true; } } BipartiteMatchingHK bpm(B, G); for (int i = 0; i < B; ++i) { for (int j = 0; j < G; ++j) if (likes[0][i][j] && likes[1][j][i]) bpm.add_edge(i, j); } vector<int> res(min(B, G)+1, 0); int prev_time = 0; int prev_couples = 0; FOREACH(it, events) { const vector<Event>& v = it->second; for (int k = 0; k < v.size(); ++k) { if (v[k].gender == 'B') bpm.active[ v[k].id+1 ] = v[k].type == 'E'; else bpm.active[ v[k].id+B+1 ] = v[k].type == 'E'; }   int cur_couples = bpm.process();   /* fprintf(stderr, "T: %d\n", it->first); for (int i = 0; i < B; ++i) fprintf(stderr, "%c ", bpm.activeL[i+1] ? '1' : '0'); fprintf(stderr,"\n"); for (int j = 0; j < G; ++j) fprintf(stderr, "%c ", bpm.activeR[j] ? '1' : '0'); fprintf(stderr, "\ncouples: %d\n\n", cur_couples); */   res[ prev_couples ] += it->first - prev_time; prev_couples = cur_couples; prev_time = it->first; } res[ prev_couples ] += L - prev_time; for (int m = 0; m < res.size(); ++m) { if (m > 0) putchar(' '); printf("%d", res[m]); } putchar('\n'); } return 0; } 
#include <stdio.h> #include <iostream> #include <stack> #include<stdlib.h> #include<string.h> #include<algorithm> #include<vector> #include<set> #include<map> #include <iomanip> #include <locale> #include <sstream> using namespace std; #define pb push_back #define ll long long int n,max_arr[2148578][15],m,que[200005][4]; int tree_sz,height[1800000],res; int modu[100],tmp_arr[400005],rng_arr[1600005],rng_len=0; char *tmp=(char*)malloc(6);    inline int max(int x, int y) { return (((y-x)>>(31))&(x^y))^y; } int qq[14];   int dt(int x, int rt) { 	int xx=x, l=0; 	while (xx>0) xx/=10, l++; 	xx=x; 	for (int i=l-1; i>=0; i--) qq[i]=xx%10, xx/=10; 	int res=0; 	for (int i=rt; i<rt+l; i++) 		res=res*10 + qq[i%l]; 	return res; }   void fill_max_arr(int idx) { 	int i,j,len; 	int k; 	string s; 	max_arr[idx][14]=1; 	for(i=0;i<12;i++) 		max_arr[idx][i]=0; 	int p=(idx-tree_sz+1)<<1; 	for(j=rng_arr[p];j<=rng_arr[p+1];j++) 	{ 		k=height[j+1]; 		i=0; 		while(i<12) 		{ 			max_arr[idx][i]=max(max_arr[idx][i],dt(k,i)); 			i++; 		} 	} }     inline void	add_value(int idx,int val) { 	max_arr[idx][12]=modu[max_arr[idx][12]+val]; 	max_arr[idx][13]=modu[max_arr[idx][13]+val]; }     inline void update_from_child(int i) { 	int p,q,r; 	p=max_arr[i][12];     q=max_arr[2*i+1][12];     r=max_arr[2*i+2][12];     for(int j=0;j<12;j++)          max_arr[i][modu[p+j]]=max(max_arr[(i<<1)+1][modu[q+j]],max_arr[(i<<1)+2][modu[r+j]]); }     inline void update_childs(int i) { 	if(i<tree_sz-1 && max_arr[i][13])     {         add_value((i<<1)+1,max_arr[i][13]);         add_value((i<<1)+2,max_arr[i][13]);         max_arr[i][13]=0;     } }    void fill_tree(int i) {     if(max_arr[i][14])         return;     if(i>=tree_sz-1)     {         fill_max_arr(i);         return;     } 	update_childs(i);     fill_tree(2*i+1);     fill_tree(2*i+2);     max_arr[i][14]=1; 	update_from_child(i); }    void insert(int i,int x,int y,int a,int b,int rot) { 	update_childs(i);     if(x>=a && y<=b) 	{ 		add_value(i,rot); 		return; 	} 	if(x<y && !(y<a || x>b))     {         insert((i<<1)+1,x,(x+y)/2,a,b,rot);         insert((i<<1)+2,(x+y)/2+1,y,a,b,rot); 		if(max_arr[i][14]) 			update_from_child(i);     }            }     void get_height(int i,int x,int y,int a,int b) { 	update_childs(i); 	if(x>=a && y<=b)     { 		if(max_arr[i][14]==0) 			fill_tree(i); 		int j=max_arr[i][12]; 		res=max(res,max_arr[i][j]); 		return; 	}      if(x<y && !(y<a || x>b))     {         get_height((i<<1)+1,x,(x+y)/2,a,b);         get_height((i<<1)+2,(x+y)/2+1,y,a,b); 	//	if(max_arr[i][14]) 	//		update_from_child(i);     } }     void process_queries() { 	int i,j,k,st,ed; 	for(i=0;i<m;i++) 	{ 		que[i][1]=lower_bound(rng_arr,rng_arr+rng_len,que[i][1])-rng_arr; 		que[i][2]=lower_bound(rng_arr,rng_arr+rng_len,que[i][2])-rng_arr; 		que[i][1]>>=1;que[i][2]>>=1; 	} 	for(i=0;i<m;i++) 	{ 		if(que[i][0]) 		{ 			res=0; 			get_height(0,1,tree_sz,que[i][1]+1,que[i][2]+1); 			cout<<res<<"\n"; 		} 		else 		{ 			if(que[i][3]) 				insert(0,1,tree_sz,que[i][1]+1,que[i][2]+1,que[i][3]); 		} 	} }     void display() { 	int i,j; 	cout<<endl; 	cout<<m<<" "<<tree_sz<<endl; 	for(j=0;j<9;j++,cout<<endl) 	for(i=0;i<14;i++) 		cout<<max_arr[j][i]<<" "; 	cout<<endl;	 }    void process_ranges() { 	int i,j,k,sz; 	for(i=0;i<m;i++) 		tmp_arr[i<<1]=que[i][1],tmp_arr[(i<<1)+1]=que[i][2]; 	m<<=1; 	sort(tmp_arr,tmp_arr+m); 	for(i=1,sz=1;i<m;i++) 		if(tmp_arr[i]!=tmp_arr[sz-1]) 			tmp_arr[sz++]=tmp_arr[i]; 	m>>=1; 	tmp_arr[sz]=n; 	for(rng_len=0,i=0;i<sz;i++) 	{ 		rng_arr[rng_len]=rng_arr[rng_len+1]=tmp_arr[i];  		rng_len+=2; 		if(tmp_arr[i]+1<tmp_arr[i+1]) 		{ 			rng_arr[rng_len]=tmp_arr[i]+1; 			rng_arr[rng_len+1]=tmp_arr[i+1]-1; 			rng_len+=2;	 		} 	} }   int main() {     std::ios_base::sync_with_stdio(false); 	int i,j,k; 	for(i=0;i<100;i++) 		modu[i]=i%12; 	cin>>n; 	for(i=1;i<=n;i++) 		cin>>height[i]; 	cin>>m;	 	for(i=0;i<m;i++) 	{ 		cin>>que[i][0]>>que[i][1]>>que[i][2]; 		if(que[i][0]==0) 		{ 			cin>>que[i][3]; 			que[i][3]=modu[que[i][3]]; 		} 	} 	process_ranges(); 	for(tree_sz=1;tree_sz<(rng_len>>1);tree_sz<<=1); 	for(i=0,tree_sz<<=1;i<tree_sz;i++) 		max_arr[i][12]=max_arr[i][13]=max_arr[i][14]=0; 	tree_sz>>=1; 	process_queries(); 	return 0; } 
#include<stdio.h> #include<map>  using namespace std;  map <long long, long long> assoc;  long long prime_factors(long long n)    {     if(assoc[n] != 0)   {         return assoc[n];     }     long long i, j;   long long ans = 0;     for (i = 2; i * i <= n; i++)    {         for (j = 0; n % i == 0; n /= i) {             j++;         }         if (j > 0)  {               ans++;             if(assoc[i] == 0) assoc[i] = 1;         }      }     if (n > 1)  ans++;     return ans; }              main()  {     int T;     scanf("%d", &T);     while(T--)  {         long long a, b, c, i, j;         long long ans = 0;         scanf("%lld%lld%lld", &a, &b, &c);         if(a == 0)  {             if(c == 0)  {                 if(b != 0)  {                     ans = -1;   goto end;                 }                 else    {                     ans = 0;    goto end;                 }             }             else    {                 for(i = b + c; i >= b + 1; i--)   {                     if(c % (i - b) == 0)    {                         ans += (long long)1 << prime_factors(c / (i - b));                     }                 }                 goto end;             }         }         else    {                                  for(i = a; i >= b + 1; i--) {                 if(a % i == 0)  {                     long long x = a / i + c;                     long long y = i - b;                     if(x % y == 0)  {                         ans += (long long)1 << prime_factors(x / y);                     }                 }             }             end : {}             printf("%lld\n", ans);         }     }     return 0; }       
#include <cstdio> #include <iostream> #include <algorithm> #include <cstring> #include <string> #include <vector> #include <set> #include <map> #include <utility> #include <math.h> #include <cstdlib> #include <memory.h> #include <queue> #include <assert.h>  #define pb push_back #define LL long long #define uLL unsigned long long #define mp make_pair #define pii pair <int,int> #define sz(A) ((int)(A).size()) #define y1 qwertyuiopasdfghjklzxcvbnm #define y0 ehfoiuvhefroerferjhfjkehfjke  const double EPS = 1e-9; const double PI = acos(-1.0); const int MAXN = 2 * (int) 1e5 + 10; const int MOD = (int) 1e9 + 7;  using namespace std;  int mul(int a, int b) {   if  (a < 0) a += MOD;   if  (b < 0) b += MOD;   LL M = 1LL * a * b;   M %= (LL)MOD;   return (int)M; }  int mpow(int a, int p) {   int res = 1;   while (p > 0) {     if  (p & 1) res = mul(res, a);     a = mul(a, a);     p /= 2;   }   return res; }  int add(int a, int b) {   if  (a < 0) a += MOD;   if  (b < 0) b += MOD;   a += b;   if  (a > MOD) a -= MOD;   return a; }  int cnt[MAXN];  int cnt_divs(int l, int r, int d) {   l = (l + d - 1) / d;   r = r / d;   if  (l > r) return 0;   return r - l + 1; }  int main() {   int T; scanf("%d", &T);   while (T--) {     memset(cnt, 0, sizeof cnt);      int k; int a[5], b[5];     scanf("%d", &k);     for (int i = 0; i < k; i++)       scanf("%d%d", &a[i], &b[i]);      for (int d = 1; d < MAXN; d++) {       cnt[d] = 1;       for (int i = 0; i < k; i++)         cnt[d] = mul(cnt[d], cnt_divs(a[i], b[i], d));     }      int P = 0;     for (int d = MAXN - 1; d >= 1; d--) {       int res = cnt[d];       for (int j = d + d; j < MAXN; j += d)         res = add(res, - cnt[j]);              cnt[d] = res;       P = add(P, mul(d, res));     }      int Q = 1;     for (int i = 0; i < k; i++)       Q = mul(Q, b[i] - a[i] + 1);      printf("%d\n", mul(-P, mpow(Q, MOD-2)));   }    return 0; } 
#include <iostream> #include <cstdio> #include <algorithm> #include <string.h> using namespace std; #define ll long long char s[1000010]; ll a[1000010]; ll cnt,k; int main() {     #ifdef LOCAL     freopen("data","r",stdin);     #endif     ll n;     while(~scanf("%lld",&n)){         while(n--){         //memset(s,0,sizeof s);         scanf("%s",s+1);         ll len=strlen(s+1);         ll ans=len;         for(ll i=1;i<=len;i++){             for(ll p=2;p*i<=len;p++){                 cnt=1;                 k=p*i;                 a[cnt++]=i;                 while(k<=len){                     a[cnt++]=k;                  ll r=1,l=cnt-1;                 ll f=1;                 while(r<l){                     if(s[a[r]]!=s[a[l]] ) {f=0;break;}                     r++;                     l--;                 }                 if(f) {             //for(int i=1;i<cnt;i++)             //    printf("%d ",a[i]);             //   printf("\n");                     ans++;                 }                      k=k*p;                 }             }         }         cout<<ans<<endl;         }     }     return 0; } 
#include <iostream> #include <string> #include <algorithm> #include <cstdio> #include <cmath> #include <vector>  using namespace std; //sg[i] - Sprague-Grundy's number for a group of i stones. We can calculate it in a  //standard way because there are only 6 numbers that n^n does not exceed 10^5. int main(){     int tc;     scanf("%d", &tc);         int sg[100333];     sg[0] = 0;     int deg[123];     int i, j;     for (i = 1; i <= 7; i++){         deg[i] = 1;         for (j = 1; j <= i; j++)             deg[i] = deg[i] * i;         }     int o = 0;     int used[1000]={};     for (i = 1; i <= 100000; i++){         o++;         for (j = 1; deg[j] <= i; j++){             used[sg[i- deg[j]]] = o;         }         for (j = 0; j <= 1 << 30; j++)             if (used[j] != o) {sg[i] = j; break;}     }     while (tc--){         int n;           scanf("%d", &n);         int ans = 0;         for (i = 1; i <= n; i++){             int x;             scanf("%d", &x);             ans ^= sg[x];         }                   if (ans) printf("Little Chef\n");         else printf("Head Chef\n");     } }
#include <iostream> #include <algorithm> #include<string.h> #include <list> #include<queue> #include<vector> #include <cmath> #define mp make_pair using namespace std; #define pii pair<int,int> #define x first #define y second #define inf 100000000 #define N 100005 #define ll long long #define mod 7051954 int a,b,n,l,dp[1001][501],next[501]; char s[501]; int solve(int a,int k) {  if(abs(b-a)>n-k||a<0||a>l)return 0;  int &ret=dp[a][k];  if(ret!=-1)return ret;  ret=0;  if(a==b)ret+=1;  if(k!=n)  {   ret=(ret+solve(s[k]=='+'?a+1:a-1,k+1))%mod;   if(next[k]!=n)   ret=(ret+solve(s[k]=='+'?a-1:a+1,next[k]+1))%mod;  }  return ret; } int main() {   int T,i,j,k;   //freopen("in.txt","r",stdin);   scanf("%d",&T);   while(T--)   {    scanf("%d%d%d%d%s",&n,&l,&a,&b,s);    if(b>n)    {     a-=(b-n);l-=(b-n);b-=(b-n);    }    if(l>b+n)l=b+n;    int nextplus=n,nextminus=n;    for(int i=n-1;i>=0;i--)    if(s[i]=='+')next[i]=nextminus,nextplus=i;    else next[i]=nextplus,nextminus=i;    memset(dp,-1,sizeof(dp));    printf("%d\n",solve(a,0));   }   return 0; }
/* codedevloper */ #include<iostream> #include<vector> #include<map> #include<queue> #include<sstream> #include<set> #include<fstream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath> #define oo (int)13e7 #define s(n) scanf("%d",&n) #define sl(n) scanf("%lld",&n) #define sf(n) scanf("%lf",&n) #define fill(a,v) memset(a, v, sizeof a) #define For(i,s,e) for(int i=s; i < e; i++) #define ull unsigned long long #define ll long long #define bitcount __builtin_popcount #define all(x) x.begin(), x.end() #define pb( z ) push_back( z ) using namespace std;   int p; char ax[12][12]; bool vis[12][12];  int getMask( int x, int y ) { 	int ret = 0; 	if( x-1 < 0 ) ret |= 1; 	if( y-1 < 0 ) ret |= 2; 	if( x+1 >= 8 ) ret |= 4;  	if( y+1 >= 8 ) ret |= 8;  	return ret; }  void flood( int x, int y, int& mask ) { 	mask |= getMask( x, y ); 	vis[x][y] = 1; 	for(int dx=-1; dx < 2; dx++) 	for(int dy=-1; dy < 2; dy++) 	if( abs(dx)+abs(dy) == 1 ) 	{ 		int nx = dx + x, ny = dy + y; 		if( nx < 0 || ny < 0 || nx >= 8 || ny >= 8 || !ax[nx][ny] || vis[nx][ny] ) 			continue; 		flood( nx, ny, mask ); 	} } const int mod = 21945; void addMod( int &to, int what ) { 	to = ( to + what ) % mod; }  void copy( int src[16][16], int dest[16][16] ) { 	for(int i=0; i < 16; ++i) 	for(int j=0; j < 16; ++j) 		dest[i][j] = src[i][j]; } int magic[16][16]; int res[16][16], a[16][16], tmp[16][16];  void mult( int a[16][16], int b[16][16], int c[16][16] ) { 	for(int i=0; i <16; ++i) 	for(int j=0; j < 16; j++) 	{ 		tmp[i][j] = 0; 		for(int k=0; k < 16; k++) 			tmp[i][j] = ( a[i][k] * b[k][j] + tmp[i][j] ) % mod; 	} 	for(int i=0; i <16; ++i) 	for(int j=0; j < 16; j++) 		c[i][j] = tmp[i][j]; } int main() { 	fill( magic, 0 ); 	 	magic[0][0] = 4; 	 	magic[2][1] = 2; 	magic[4][1] = 2; 	 	magic[2][2] = 2; 	magic[8][2] = 2; 	 	magic[3][3] = 1; 	magic[6][3] = 1; 	magic[12][3] = 1; 	magic[9][3] = 1; 	 	magic[0][4] = 2;  	 	magic[5][5] = 2; 	 	magic[2][6] = 1; 	magic[8][6] = 1; 	 	magic[7][7] = 1; 	magic[13][7] = 1; 	 	magic[0][8] = 2; 	 	magic[1][9] = 1; 	magic[4][9] = 1; 	 	magic[10][10] = 2; 	 	magic[11][11] = 1; 	magic[14][11] = 1; 	 	magic[0][12] = 1; 	 	magic[5][13] = 1; 	 	magic[10][14] = 1; 	 	magic[15][15] = 1; 	 	 	 	int runs; 	s( runs ); 	 	while( runs-- ) 	{ 		s( p ); 		fill( vis, 0 ); 		for(int i=0; i < 8; i++) 		{ 			scanf("%s", ax[i] ); 			for(int j=0; j < 8; j++) 			{ 				assert( ax[i][j] == '0' || ax[i][j] == '1' );  				ax[i][j] -= '0'; 			} 		} 		 		int ans = 0; 		assert( p >= 3 ); 		p -= 3; 		fill( a, 0 ); 		copy( magic, a ); 		fill( res, 0 ); fill( tmp, 0 ); 		for(int i=0; i < 16; ++i) 			res[i][i] = 1; 		while( p > 0 ) 		{ 			if( p % 2 ) 				mult( res, a, res ); 			mult( a, a, a ); 			p /= 2; 		} 		 		for(int i=0; i < 8; ++i) 		for(int j=0; j < 8; ++j) 		if( !vis[i][j] && ax[i][j]) 		{ 			int mask = 0; 			flood( i, j, mask ); 			 			int sum = 0; 			for(int k=0; k < 16; k++) 			{ 				assert( res[k][mask] >= 0 ); 				addMod( sum , res[ k ][ mask ] ); 			} 			addMod( ans, sum ); 		} 		printf("%d\n", ans ); 		 	} } /* codedevloper */
#include <iostream> using namespace std; long long vals[20], a[4], mod=1000000; int Q; pair<long long,long long> coeff[4]; long long solve(long long cons[4], int upto) {     //printf("Cons this size: ");     //for (int i=0; i<Q-upto; i++) printf("%I64d ",cons[i]);     //printf("\n");     if (upto==Q) return 0;         //printf("Coeff multiplier is %I64d\n",coeff[upto].second);       long long next[4];     int numnew = Q-upto-1;     for (int i=0; i<numnew; i++) {         next[i] = ((cons[i+1]-(coeff[upto].second*cons[i])%mod)%mod+mod)%mod;     }     long long ret = solve(next,upto+1);     ret = (ret + (coeff[upto].second*cons[Q-upto-1])%mod)%mod;     return ret; } int main() {     int P;scanf("%d %d",&P,&Q);     for (int i=0; i<P; i++) {scanf("%lld",&a[i]);a[i] = (a[i]+mod)%mod;}     for (int i=0; i<Q; i++) {scanf("%lld",&coeff[i].first);coeff[i].first = (coeff[i].first+mod)%mod;}     for (int i=0; i<Q; i++) {scanf("%lld",&coeff[i].second);coeff[i].second = (coeff[i].second+mod)%mod;}     for (int i=0; i<10; i++) {scanf("%lld",&vals[i]);vals[i] = (vals[i]+mod)%mod;}          for (int x=0; x<10; x++) {         // find last Q constants of the equations         //printf("Cons: ");         long long cons[4];         for (int i=0; i<Q; i++) {             cons[Q-1-i] = vals[9+x-i];             for (int j=0; j<P; j++) cons[Q-1-i] = ((cons[Q-1-i]-a[j]*vals[8+x-i-j])%mod+mod)%mod;             //printf("%I64d ",cons[i]);         }         //printf("\n");         long long nextcoeff = solve(cons,0);         //printf("Retcon: %I64d\n",nextcoeff);         long long ans = nextcoeff;         for (int j=0; j<P; j++) ans = (ans+a[j]*vals[x+9-j])%mod;         vals[x+10]=ans;         printf("%lld ",ans);     }     printf("\n"); } /* 4a + 3b + 2c + d = A 8a + 9b + 8c + 5d = B 16a + 27b + 32c + 25d = C 32a + 81b + 128c + 125d = D 64a + 243b + 512c + 625d = E   3b + 4c + 3d = B-2A 9b + 16c + 15d = C-2B 27b + 64c + 75d = D-2C 81b + 256c + 375d = E-2D   (e-2d)-3(d-2c)   */
#include <stdio.h>   long long gcd(long long x, long long y) { long long c; if (x<0) x=-x; while(y) { c=y; y=x%y; x=c; } return x; }       long long mnozi(long long a, long long b, long long n) { long long ukupno;   ukupno=0; while(b) { if (b&1) { ukupno+=a; if (ukupno>=n) ukupno-=n; } b>>=1; a<<=1; if (a>=n) a-=n; }       return ukupno; }   long long pot(long long a, long long n, long long m) { long long s,t;   s=a; t=1;   while(n) { if (n&1) t=mnozi(t,s,m);   s=mnozi(s,s,m);   n>>=1; }   return t;   }     long long fakt(long long n, int a) { long long x,y,d;   d=1; for(x=2,y=2;d==1;) { x=mnozi(x,x,n)+a; if (x>=n) x-=n; y=mnozi(y,y,n)+a; y=mnozi(y,y,n)+a;   if (y>=n) y-=n;   d=gcd(x-y,n); } return d; }       int prost1(long long n, long long a) { long long nn=n-1,temp; int r;   if (n==2) return 1; if ((n&1)==0) return 0;     for(nn=n-1,r=0;nn&1;nn>>=1,r++);   temp=pot(a,nn,n);   if (temp==1 || temp==n-1) return 1;     while(r--) { temp=mnozi(temp,temp,n); if (temp==n-1) return 1;   if (temp==1) return 0; } return 0; }     int prost(long long n) { long long i; for(i=2;i<20 && i<n;i++) if (!prost1(n,i)) return 0; return 1; }     long long mali(long long n) { int i,zbroj; zbroj=0;   if (n==1) return 1;   for(i=2;i*i<n;i++) if (n%i==0) while(n%i==0) { zbroj+=i; n/=i; } if (n>1) zbroj+=n; return zbroj; }       #define GR 2   long long suma(long long n) { long long temp; int a;   if (n==1) return 1;   if (prost(n)) return n;     for(a=1;a<10 && a<n;a++) { if (a==2 || a==0) continue;   temp=fakt(n,a);   if (temp<n) return suma(temp)+suma(n/temp); } return n; }     int main (int argc, char *argv[]) { long long n; int i; char niz[30];   //printf("%lld\n",suma(9999990370000567));   while(scanf("%lld",&n)==1) { if (n==1) { printf("1\n"); continue; }   //fprintf(stderr,"%lld ",n); printf("%lld\n",suma(n)); }     return 0; } 
#include<iostream> using namespace std; int main() { 	int n,t,S[1000],T[1000],esc,task[1000]; 	cin>>t; 	while(t--) 	{	esc=0; 		cin>>n; 		for(int i=0;i<n;i++) 			cin>>S[i]; 		for(int i=0;i<n;i++){ 			task[i]=i+1; 			cin>>T[i]; 		} 		for(int i=0;i<n;i++) 		{ 			if(S[i]==T[i]) 			{ 				for(int j=0;j<n;j++) 				{ 					if(S[i]!=T[j] && T[i]!=S[j]) 					{ 						swap(T[i],T[j]); 						swap(task[i],task[j]); 						break; 					} 				} 			} 		} 		for(int i=0;i<n;i++) 		{ 			if(S[i]==T[i]) 				esc++; 		} 		cout<<esc<<endl; 		for(int i=0;i<n;i++) 			cout<<task[i]<<" "; 		cout<<"\n"; 	} 	return 0; } 
#include<stdio.h>  int r,c,x,me,p,q,m,cur,tmp,t; int a[2015][2015],f[2015][2015],st[2015],ed[2015],g1[2015],g2[2015]; bool sign;  inline int f_max2(int w,int q) { if(w>=q) return w; return q; }  inline int f_max3(int q,int w,int e) { if(w>=e) { if(w>=q) return w; return q; } else { if(e>=q) return e; return q; } }  int main() { scanf("%d",&t); for(int i=0;i<t;i++) { scanf("%d",&r); scanf("%d",&c); scanf("%d",&me); if(me==1) { for(int i=1;i<=r;i++) { for(int j=1;j<=c;j++) { scanf("%d",&a[i][j]); } } } else { scanf("%d",&x); scanf("%d",&p); scanf("%d",&q); scanf("%d",&m); cur=x; for(int i=1;i<=r;i++) { for(int j=1;j<=c;j++) { cur=((cur*p)+q)%m; a[i][j]=x-cur; } } } for(int i=1;i<=c;i++) { f[0][i]=0; } for(int i=1;i<=r;i++) { st[1]=0; for(int j=2;j<=c;j++) { tmp=st[j-1]+a[i][j-1]; if(tmp<=0) tmp=0; st[j]=tmp; } ed[c]=0; for(int j=c-1;j>=1;j--) { tmp=ed[j+1]+a[i][j+1]; if(tmp<=0) tmp=0; ed[j]=tmp; } g1[1]=f[i-1][1]+a[i][1]; for(int j=2;j<=c;j++) { g1[j]=f_max2(f[i-1][j]+a[i][j]+st[j],g1[j-1]+a[i][j]); } g2[c]=f[i-1][c]+a[i][c]; for(int j=c-1;j>=1;j--) { g2[j]=f_max2(f[i-1][j]+a[i][j]+ed[j],g2[j+1]+a[i][j]); } for(int j=1;j<=c;j++) { if(j==1 || j==c) f[i][j]=a[i][j]+f[i-1][j]+st[j]+ed[j]; else f[i][j]=a[i][j]+f_max3(f[i-1][j]+st[j]+ed[j],g1[j-1]+ed[j],g2[j+1]+st[j]); //printf("%d ",f[i][j]); } //printf("\n"); } tmp=f[r][1]; for(int i=2;i<=c;i++) { if(f[r][i]>tmp) tmp=f[r][i]; } printf("%d\n",tmp); } return 0; }
#include <iostream> #include <cstdio> #include <cstdlib> #include <cstring> #include <cmath> #include <cassert> #include <algorithm>  //DS #include <string> #include <vector> #include <stack> #include <queue> #include <set> #include <map>  #define LL          long long int #define UL          unsigned long long int #define REP(i,n)    for(int i = 0; i < (n); i++) #define FOR(i,a,b,k)for(int i = (a); i < (b); i+=k) #define MAXS 1200 #define FAIL -1 #define MAXP 62  using namespace std;  UL ct[MAXS][20]; UL L,R,K; int N, noOfStates,length; char pattern[MAXP][20]; int len[MAXP]; int g[MAXS][10]; int q[MAXS][2]; char str[20];  int ni(){     int v;     scanf("%d", &v);     return v; }  void itoa(UL x){     length = 0;     do{         str[length] = '0' + x%10;         x = x/10;         length++;     }while(x);     int i = 0, j = length-1;     while(i < j){         char c = str[i];str[i] = str[j];str[j] = c;         i++,j--;     }     str[length] = 0; }  UL total(int i){     UL ret = 1LL;     REP(j,i){         ret*=10LL;     }     return ret; }  void preprocess(){     memset(g,FAIL,sizeof(g));     noOfStates = 2;     REP(i,N){         int curr = 0, val;         REP(j,len[i]-1){             val = (pattern[i][j] - '0');             if(g[curr][val] != FAIL){                 curr = g[curr][val];             }             else{                 curr = g[curr][val] = noOfStates++;             }         }         val = (pattern[i][len[i]-1] - '0');         g[curr][val] = 1;     }      REP(i,10){         g[1][i] = 1;     }      int end = 0; 	REP(i,10){         if(g[0][i] == FAIL){             g[0][i] = 0;         }         else{             q[end][0] = g[0][i];             q[end][1] = 0;             end++;         } 	} 	REP(i,end){ 		REP(j,10){             if(g[q[i][0]][j] == FAIL || g[q[i][1]][j] == 1){                 g[q[i][0]][j] = g[q[i][1]][j];             }             else if(g[q[i][0]][j] != 1) {                 q[end][0] = g[q[i][0]][j];                 q[end][1] = g[q[i][1]][j];                 end++;             } 		} 	}      ct[1][0] = 1;     FOR(i,1,19,1){         REP(j,MAXS){             ct[j][i] = 0;             FOR(k,0,10,1){                 int n = g[j][k];                 ct[j][i] += ct[n][i-1];             }         }     } }  UL get(char* s){     UL ret = 0;     int i = 0;     while(s[i]){         ret = ret*10 + (s[i]- '0');         i++;     }     return ret; }  UL Count(UL x){     if(!x) return 0;     UL ret = 0;     itoa(x);      int curr = 0;     REP(i,length){         int lim = str[i]-'0';         REP(j,lim){             int state = g[curr][j];             ret += ct[state][length-1-i];         }         curr = g[curr][lim];     }     if(curr == 1) ret++;     return ret; }  void solve(){     UL tot = Count(R) - Count(L-1);     if(tot < K){         printf("no such number\n");         return;     }     UL mid;     while(L < R){         mid = (L+R)/2;         UL cnt = Count(mid)-Count(L-1);         //assert(cnt >= 0);         if(cnt >= K){             R = mid;         }         else if(cnt < K){             L = mid+1;             K -= cnt;         }     }     printf("%llu\n",R); }  int main(){     scanf("%llu %llu %llu %d", &L, &R, &K, &N);     REP(i,N){         scanf("%s", &pattern[i]);         len[i] = strlen(pattern[i]);     }     preprocess();     //cout << Count(3707914491133LL)<<endl;     solve();     return 0; } 
#include <iostream> #include <stdio.h> #include <algorithm> #include <string.h> #include <stdlib.h> #include <iterator> #include <sstream> #include <numeric> #include <fstream> #include <numeric> #include <vector> #include <cctype> #include <math.h> #include <deque> #include <queue> #include <stack> #include <iomanip> #include <set> #include <map> //#include <windows.h> using namespace std;  #define FRE(i,a,b)  for(i = a; i <= b; i++) #define FRL(i,a,b)  for(i = a; i < b; i++) #define mem(t, v)   memset ((t) , v, sizeof(t)) #define sqr(x)      (x)*(x) #define all(x)      x.begin(),x.end() #define un(x)       x.erase(unique(all(x)), x.end()) #define sf(n)       scanf("%d", &n) #define sff(a,b)    scanf("%d %d", &a, &b) #define sfff(a,b,c) scanf("%d %d %d", &a, &b, &c) #define D(x)        cout<<#x " = "<<(x)<<endl #define pf          printf #define VI          vector <int> #define pii         pair <int, int> #define pll         pair <LL, LL> #define pb          push_back #define mp          make_pair #define pi          acos(-1.00) #define DBG         pf("Hi\n") #define sz          size() #define ins         insert #define fi          first #define se          second #define xx          first #define yy          second #define inf         (1<<29) #define MOD         1000000007 #define eps         1e-9 #define MAX         1000000  typedef long long int LL; typedef double db;  //int dx[] = {+0,+1,+0,-1}; //int dy[] = {+1,+0,-1,+0}; //int dx[] = {-1,-1,-1,+0,+0,+1,+1,+1}; //int dy[] = {-1,+0,+1,-1,+1,-1,+0,+1}; //bool check(int n, int pos) {return (bool) (n & (1<<pos));} //int on(int n, int pos) {return n | (1<<pos); } //int off(int n, int pos) {return n & ~(1<<pos); }  bool sts[MAX+10];  vector<LL>prm, P, abg; vector<int>cnt, C, ext; map<LL, int> MP;  LL ip(LL a, LL p) {     if(!p) return 1;     if(a >= MOD) a%=MOD;     if(p&1) return (a*ip(a,p-1))%MOD;     LL ret = ip(a,p/2);     return (ret*ret)%MOD; }  inline bool ps(LL val) {     LL s = sqrt(val);     return (sqr(s) == val); }  int main() {     //freopen("c:\\Users\\User\\Desktop\\in.txt", "r", stdin);     //freopen("c:\\Users\\User\\Desktop\\out.txt", "w", stdout);     //ios_base::sync_with_stdio(0); cin.tie(0);      int i, j, k, t, cs, s = sqrt(MAX), n, p;     LL v, ret, nw, g;     bool fnd;      sts[0] = sts[1] = 1;     FRE(i,2,MAX)         if(!sts[i])         {             P.pb(i);             C.pb(0);              if(i > s) continue;             for(j = i*i; j <= MAX;j += i)                 sts[j] = true;         }      sf(t);     FRE(cs,1,t)     {         prm = P;         cnt = C;         ret = 1;          sf(n);         FRE(i,1,n)         {             scanf("%lld", &v);             ret = (ret * (v%MOD)) % MOD;             FRL(j,0,prm.sz)             {                 if(v%prm[j]) continue;                 while(v%prm[j] == 0) cnt[j]++, v/=prm[j];             }              if(v == 1) continue;             if(ps(v))             {                 v = sqrt(v);                 MP[v]+=2;             }             else abg.pb(v), ext.pb(1);         }          FRL(i,0,abg.sz)             FRL(j,i+1,abg.sz)             {                 if(abg[i] == abg[j])                 {                     ext[i] += ext[j];                     ext[j] = 0;                     continue;                 }                  g = __gcd(abg[i], abg[j]);                 if(g == 1) continue;                 MP[g]+= ext[i] + ext[j];                 MP[abg[i]/g] += ext[i];                 MP[abg[j]/g] += ext[j];                  ext[i] = ext[j] = 0;             }          map<LL,int>::iterator it;          fnd = true;         while(fnd)         {             fnd = false;             for(it = MP.begin(); it!= MP.end(); it++)             {                 nw = it->fi;                 FRL(i,0,abg.sz)                     if(!ext[i]) continue;                     else                     {                         v = abg[i];                         if(v%nw) continue;                         v = v/nw;                         MP[nw] += ext[i];                         MP[v] += ext[i];                         fnd = true;                         ext[i] = 0;                     }             }         }          FRL(i,0,abg.sz)             if(ext[i] && ext[i]%3)                 ret = (ret * ip((abg[i]%MOD), 3-ext[i]%3))%MOD;           for(it = MP.begin(); it != MP.end(); it++)         {             nw = it->fi;             nw %= MOD;             p = it->se;             if(p%3)ret = (ret * ip(nw, 3-p%3))%MOD;         }          FRL(i,0,prm.sz)             if(cnt[i] && cnt[i]%3)             {                 cnt[i] %= 3;                 ret = (ret*ip(prm[i], 3-cnt[i]))%MOD;             }          pf("%lld\n", ret);         ext.clear();         MP.clear();         abg.clear();     }     return 0; } 
//NEEDS SPRAGUE GRUNDY THEOREM. /*Useful info __builtin_popcount(n) counts number of active bits. __builtin_popcountl(n) for long and ll for long long  to_string(n): Converts a number from int to string*/  //My shortcuts #include<bits/stdc++.h> #define ll long long int #define ull unsigned long long int #define sf(n) scanf("%d",&n); #define sf2(a,b) scanf("%d %d",&a,&b); #define sf3(a,b,c) scanf("%d %d %d",&a,&b,&c); #define sf4(a,b,c,d) scanf("%d %d %d %d",&a,&b,&c,&d); #define sfl(n) scanf("%lld",&n); #define sful(n) scanf("%llu",&n); #define pf(n) printf("%d",n); #define pfl(n) printf("%lld",n); #define pful(n) printf("%llu",n); #define ps printf(" "); #define pn printf("\n"); #define put(a) printf("%s",a); #define cut(n,val) memset(n,val,sizeof(n)); #define pub push_back() #define ln size() #define ff first #define ss second #define mpr make_pair() #define bpop(n) __builtin_popcount(n) #define fo(in,out) for(int i=in;i<out;i++) #define st(n) to_string(n) //Works only in c++11 const long long int mod=1e9+7; using namespace std; //FAST IO-> //Advisable to use scanf and printf since it passes most time limits. /*inline void read(ll &a) {   register int c;   a = 0;   do c = getchar_unlocked(); while (c < '0');   do{     a = (a << 1) + (a << 3) + c - '0';     c = getchar_unlocked();   } while (c >= '0'); } inline void print(ll a) {   int s[25], t = -1;   do   {     s[++t] = a % 10 + '0';     a /= 10;   } while (a > 0);   while (t >= 0)putchar_unlocked(s[t--]);   putchar_unlocked('\n'); } inline ll readstr(char s[]) {   register ll i = 0, c;   do c = getchar_unlocked(); while (c < '0' || c > '9');   do{     s[i++] = c;     c = getchar_unlocked();   } while (c >= '0' && c <= '9');   s[i] = '\0';   return i; }*/ //Functions-> int grund[12]={0,1,2,2,3,3,0,0,0,0,0,0}; int grundy(ll n) { 	if(n<12) 		return grund[n]; 	else 		return grundy(n/12); } //Driver Program-> int main() { 	int t; 	sf(t); 	while(t--) 	{ 		int n; 		sf(n); 		 		ll a[105]; 		for(int i=0;i<n;i++) 			sfl(a[i]); 		 		ll ans=0;	  		for(int i=0;i<n;i++) 			ans^=grundy(a[i]); 			 		if(ans==0) 			printf("Derek\n"); 		else 			printf("Henry\n"); 	} 	return 0; }  
//	SEGMENT TREE TO SUM INTERVALS USING LAZY PROPOGATION #include<stdio.h> #include<iostream> #include<algorithm> #include<map> #include<set> #include<stack> #include<queue> #include<string> #include<limits.h> #include<math.h>   #define MAX(a,b) ((a) > (b) ? a : b) #define MIN(a,b) ((a) < (b) ? a : b) #define IT(a,it) for(auto it=a.begin(); it != a.end(); it++) #define REV_IT(a,it) for(auto it=a.rbegin(); it != a.rend(); it++) #define MAXX 100005   using namespace std;   typedef pair <int, int> pi_i;   int N, Q, arr[MAXX]; int *ST, *lazy;   //query with lazy propogation int queryLazy(int node, int start, int end, int L, int R){ 	if(L > end || R < start) return 0; 	if(lazy[node] == 1){	//i.e update curr node if lazy has been set previously 		ST[node] = (end-start+1) - ST[node]; 		if(start != end){	//i.e if no leaf then mark children 			lazy[node<<1] = 1-lazy[node<<1]; 			lazy[(node<<1)+1] = 1-lazy[(node<<1)+1]; 		} 		lazy[node] = 0; 	} 	if(start >= L && end <= R) return ST[node]; 	int x = queryLazy(node<<1, start, (start+end)>>1, L, R); 	int y = queryLazy((node<<1)+1, ((start+end)>>1)+1, end, L, R); return x+y; }   //normal query int query(int node, int start, int end, int L, int R){ 	if(L > end || R < start) return 0; 	if(start >= L && end <= R) return ST[node]; 	int x = query(node<<1, start, (start+end)>>1, L, R); 	int y = query((node<<1)+1, ((start+end)>>1)+1, end, L, R); return x+y; }   void update(int node, int start, int end, int L, int R){ 	if(lazy[node] == 1){	//i.e update curr node if lazy has been set previously 		ST[node] = (end-start+1) - ST[node]; 		if(start != end){	//i.e if no leaf then mark children 			lazy[node<<1] = 1-lazy[node<<1]; 			lazy[(node<<1)+1] = 1-lazy[(node<<1)+1]; 		} 		lazy[node] = 0; 	} 	 	if(L > end || R < start) return; 	if(start >= L && end <= R){	//segment inside range hence update 		ST[node] = (end-start+1) - ST[node]; 		if(start != end){	//i.e if no leaf then mark children 			lazy[node<<1] = 1-lazy[node<<1]; 			lazy[(node<<1)+1] = 1-lazy[(node<<1)+1]; 		} 		return; 	} 	 	update(node<<1, start, (start+end)>>1, L, R); 	update((node<<1)+1, ((start+end)>>1)+1, end, L, R); 	 	ST[node] = ST[node<<1] + ST[(node<<1)+1]; }   void build(int node, int start, int end){ 	if(start == end) ST[node] = arr[start]; 	else{ 		build(node<<1, start, (start+end)>>1); 		build((node<<1)+1, ((start+end)>>1)+1, end); 		ST[node] = ST[node<<1] + ST[(node<<1)+1]; 	} }   void initSegTree(){ 	int ht = ceil(log2(N)), i; 	int size = (2*pow(2, ht)) + 5; 	ST = new int[size]; 	lazy = new int[size]; 	for(i=0;i<size;i++) ST[i] = 0, lazy[i] = 0; }   int main(){ 	int i, A, B, op; 	scanf("%d %d",&N, &Q); 	initSegTree(); 	for(i=0;i<Q;i++){ 		scanf("%d %d %d", &op, &A, &B); 		if(op == 0){ 			update(1, 0, N-1, A, B); 		}else{ 			printf("%d\n",queryLazy(1, 0, N-1, A, B)); 		} 	} return 0; }  
//#include<bits/stdc++.h> #include <iostream> #include <cstdio> #include <vector> #include <map> #include <queue> #include <stack> #include <cstring> #include <algorithm> #include <cstdlib> #include <cmath> #include <set> using namespace std; #define w(t) while(t--) #define S(x) scanf("%d",&x) #define SLL(x) scanf("%lld",&x) #define P(x) printf("%d\n",x) #define fl(i , a, b) for(i = (int)a; i<(int)b; i++) #define mem(a , value) memset(a , value , sizeof(a)) #define tr(c, itr) for(itr = (c).begin(); itr != (c).end(); itr++) #define MOD 1000000007 #define MAX 1000000010 #define ll long long #define all(v) v.begin(),v.end() #define mp make_pair #define pb push_back #define f first #define s second typedef pair<int,int> pp; #define N 1002 int n , m , W , KK, R , x,  y ,c1,c2, walls[N][N][4] , src , dst , g[N][N];  std::vector<pair <pp , pp > > cost ,ac;  std::map<pair <pp , pp >, int> m1; int par[N*N] , vis[N*N] , pa; std::vector<int> v[N]; int dx[] = {1,-1,0,0}; int dy[] = {0,0,1,-1};  queue <int> q;  int bfs() {     for(int i = 0; i<=502; i++)     {         par[i] = -1; vis[i] =0;      }     q.push(src);     vis[src] =1;      par[src] = -1;      while(!q.empty())     {         int el = q.front();         q.pop();         for (int i = 0; i < (int)v[el].size(); ++i)         {             int nx = v[el][i];             if(!vis[nx] && g[el][nx]>0)             {                 q.push(nx);                 vis[nx] = 1;                 par[nx] = el;              }         }     }     return (vis[dst] == 1);  } int update() {     int ans = MAX;      int u = dst;      while(par[u]!=-1)     {         ans = min(ans, g[par[u]][u]);          u = par[u];       }     u = dst;     while(par[u]!=-1)     {         g[par[u]][u]-= ans;         g[u][par[u]]+=ans;          u = par[u];     }     return ans;  } ll flow() {     ll ans=0 ;      while(bfs())     {         ans+=update();     }     return ans;  }  int find(int x) {     if(x==par[x]) return x;     return (par[x] = find(par[x]));  } void join(int x , int y , int x1 , int y1) {     int p1 = find( (x-1)*m + y ); int p2 = find( (x1-1)*m + y1 );      if(p1!=p2)         par[p2] = p1; } int valid(int i , int j ) {     if(i>=1 && i<=n && j>=1 && j<=m) return 1;     return 0;  } void solve() {     int i , j , k ;     int cnt = 1;     for(int i =1 ;i<=1000002; i++)     {         par[i] = cnt;          cnt++; vis[i] = 0 ;      }     // made union of all the coordinates      fl(i,1,n+1)     {         fl(j,1,m+1)         {             fl(k,0,4)             {                 int nx = dx[k] +i ;int ny = dy[k] + j;                 if(valid(nx, ny))                 {                     if(walls[i][j][k] == 0 )                         join(i , j , nx , ny);                  }             }         }     }     // cout << endl << endl;      /*fl(i,1,n+1)     {         fl(j,1,m+1){             cout <<find( (i-1)*m + j ) << " ";          }         cout << endl;     }*/     // give  parents an id with id starting equal to 1;      mem(vis,0);     cnt =1;     fl(i,1,n+1)     {         fl(j,1,m+1)         {             pa = find( (i-1)*m + j );             if(vis[pa] == 0){                 vis[pa] = cnt;                  cnt++;             }         }     }     /*cout << endl << endl ;     fl(i,1,n+1)     {         fl(j,1,m+1)         {             cout << vis[find( (i-1)*m + j )] << " " ;         }         cout << endl;     }*/     // make flow graph      fl(i,0,ac.size())     {         x = ac[i].f.f; y = ac[i].f.s; int p1 = find( (x-1)*m + y );           x = ac[i].s.f; y = ac[i].s.s; int p2 = find( (x-1)*m + y );          p1 = vis[p1]; p2 = vis[p2];          if(p1 > p2 ) swap(p1,p2);         // yahan galat aa raha hai.         /* if(p1 == p2)         {             while(1){              }         }*/         if(p1!=p2)         g[p1][p2] += (KK);         g[p2][p1] += (KK);     }        // cout << " yes 1 " << endl;      fl(i,1,501)     {         fl(j,i+1,501)         {             // if(g[i][i] >0 )cout << "DEBUG " << endl;              if(g[i][j] > 0 ){                 // cout << i << " " <<j <<" " << g[i][j] <<" "<< g[j][i]<<  endl ;                 v[i].pb(j);                 v[j].pb(i);             }         }     }     fl(i,0,R)     {         x = cost[i].f.f ; y = cost[i].f.s;          int p1 = find( (x-1)*m + y );         p1 = vis[p1];          v[src].pb(p1);          v[p1].pb(dst) ;         g[src][p1]+= cost[i].s.f;          g[p1][dst] += cost[i].s.s;      } } int main() {     //std::ios_base::sync_with_stdio(false);     int i, x1 , y1 , x2 , y2;     cin >> n >> m >> W >> KK >> R;     fl(i,0,W)     {         cin >> x1 >> y1 >> x2 >> y2 ;         pp t1 = mp(x1 , y1) ; pp t2 = mp(x2,y2);         if(t1 > t2) swap(t1,t2);         if(m1.find(mp(t1, t2)) == m1.end())         {             m1[mp(t1,t2)] = 1;             ac.pb(mp( mp(x1,y1) , mp(x2,y2) )); // walls between these coordinates .         }         if(x1==x2)         {             if(y1 > y2) swap(y2,y1);             walls[x1][y1][2] = 1; // to the right              walls[x2][y2][3] = 1; // left          }         else if(y1 == y2)         {                if(x1 < x2) swap(x1,x2);             walls[x1][y1][1] = 1; // top             walls[x2][y2][0] = 1; // bottom          }     }      // cout << "edges end " << endl;      src = 0; dst = 502;      fl(i,0,R)     {         cin >> x >> y >> c1 >> c2;          cost.pb(mp( mp(x,y) , mp(c1,c2) ));      }     solve();     printf("%lld\n", flow());     return 0; } /* // wa on this test CASE: Correct:248 Received:221 3 3 9 10 6  1 1 1 2  1 2 1 3  1 2 2 2  1 3 2 3  2 2 2 3  2 3 3 3  3 1 3 2 3 2 2 2  3 2 3 3  1 1 4 6  1 2 6 5  1 3 4 4 2 3 7 5  3 2 1 1  3 3 2 1   1 1 45 65  1 2 61 50  1 3 45 47 2 3 72 51  3 2 12 19  3 3 21 16   1 1 4 6  1 2 6 5  1 3 4 4 2 3 7 5  3 2 1 1  3 3 2 1   */
#include<map> #include<cstdio> #include<vector> #include<algorithm>   #define rep(i,n) for(int i=0;i<(n);i++)   using namespace std;   typedef long long ll;   const int INF=1<<29;   struct vertex{ 	int id,h; // å¡�ã�®ç�ªå�·, é��æ�° 	bool operator<(const vertex &v)const{ return id!=v.id ? id<v.id : h<v.h; } };   struct edge{ 	vertex u,v; 	int cost; };   // a + (a+1) + (a+2) + (a+n-1) ll sum(ll a,ll n){ return a*n+n*(n-1)/2; }   // h1 é��ã�¾ã�§ã�®æ��ç�­è·�é�¢ã�� d1, h2 é��ã�¾ã�§ã�®æ��ç�­è·�é�¢ã�� d2 ã�®ã�¨ã��ã�® // h1, h1+1, ..., h2 é��ã�¾ã�§ã�®æ��ç�­è·�é�¢ã�®å�� ll calc(int h1,ll d1,int h2,ll d2){ 	if(d1>d2) swap(d1,d2); 	ll a=sum(d1,d2-d1); 	h1+=d2-d1; 	d1=d2; 	return a+sum(d1,(h2-h1+1)/2)+sum(d2,(h2-h1+2)/2); }   int main(){ 	int nb,nf,m; scanf("%d%d%d",&nb,&nf,&m); 	vector<edge> E; 	rep(i,m){ 		int id1,h1,id2,h2,cost; 		scanf("%d%d%d%d%d",&id1,&h1,&cost,&id2,&h2); id1--; h1--; id2--; h2--; 		E.push_back((edge){(vertex){id1,h1},(vertex){id2,h2},cost}); 	} 	rep(i,nb-1){ 		// é�£ã��å��ã��å¡�ã�®ä¸�é��ã�©ã��ã��ã��ã�¤ã�ªã�� 		E.push_back((edge){(vertex){i,0},(vertex){i+1,0},1}); 	} 	m=E.size();   	// é��è¦�ã�ªé �ç�¹ã�®ã�¿ã��ã�¿ã�� 	vector<int> V[100]; 	rep(i,m){ 		vertex u=E[i].u,v=E[i].v; 		V[u.id].push_back(u.h); 		V[v.id].push_back(v.h); 	} 	// é �ç�¹é��å��ã��ã��é��è¤�ã��é�¤ã��ã�¦ã��ã��ã�¨ã�®ã��ã��ã�«ã�½ã�¼ã�� 	int n=0; 	rep(i,nb){ 		sort(V[i].begin(),V[i].end()); 		V[i].erase(unique(V[i].begin(),V[i].end()),V[i].end()); 		n+=V[i].size(); 	}   	map<vertex,int> f; // é �ç�¹ -> é �ç�¹ç�ªå�· 	rep(i,nb) rep(j,V[i].size()) { 		vertex v={i,V[i][j]}; 		if(f.count(v)==0) f.insert(make_pair(v,f.size())); 	}   	// Warshall-Floyd 	static int wf[300][300]; 	rep(u,n) rep(v,n) wf[u][v]=(u==v?0:INF); 	rep(i,m){ 		vertex u=E[i].u,v=E[i].v; 		wf[f[u]][f[v]]=wf[f[v]][f[u]]=E[i].cost; 	} 	rep(i,nb) rep(j,(int)V[i].size()-1) { 		vertex u={i,V[i][j]},v={i,V[i][j+1]}; // å��ã��å¡�ã�®é�£ã��å��ã��é��ã�©ã��ã��ã��ã�¤ã�ªã�� 		wf[f[u]][f[v]]=wf[f[v]][f[u]]=V[i][j+1]-V[i][j]; 	} 	rep(w,n) rep(u,n) rep(v,n) wf[u][v]=min(wf[u][v],wf[u][w]+wf[w][v]);   	// query 	int nq; scanf("%d",&nq); 	while(nq--){ 		int id,h; scanf("%d%d",&id,&h); id--; h--;   		// u ã�«è¿�ã��é��è¦�ã�ª 2 é �ç�¹ 		int u1,u2,h1,h2; 		rep(j,V[id].size()){ 			if(V[id][j]>h) break; 			h1=V[id][j]; 			u1=f[(vertex){id,h1}]; 		} 		rep(j,V[id].size()){ 			h2=V[id][j]; 			u2=f[(vertex){id,h2}]; 			if(V[id][j]>=h) break; 		}   		int d[300]; // d[v] := ã�¯ã�¨ã�ªé �ç�¹ u ã��ã��é��è¦�ã�ªé �ç�¹ v ã�¸ã�®æ��ç�­è·�é�¢ 		rep(v,n) d[v]=min(abs(h1-h)+wf[u1][v],abs(h2-h)+wf[u2][v]);   		ll ans=0; 		rep(i,nb) if(i!=id) { // å¡� i ã�®è·�é�¢ã�®å�� 			rep(j,(int)V[i].size()-1){ 				int v1=f[(vertex){i,V[i][j]}]; 				int v2=f[(vertex){i,V[i][j+1]}]; 				ans+=calc(V[i][j],d[v1],V[i][j+1],d[v2])-d[v2]; // é��è¦�ã�ª 2 é �ç�¹é�� 			}   			int v=f[(vertex){i,V[i].back()}]; 			ans+=sum(d[v],nf-V[i].back()); // ä¸�ç�ªé«�ã��é��è¦�ã�ªé �ç�¹ã��ã��å¡�ã�®ã�¦ã�£ã�ºã��ã�¾ã�§ 		} 		printf("%lld\n",ans); 	}   	return 0; }
    #include <stdio.h>     #include <iostream>     #include <vector>     #include <string>     #include <algorithm>     #include <cmath>     #include <set>     #include <map>     #include <memory.h>     #include <map>     using namespace std;     #define all(a) a.begin(), a.end()     #define mp make_pair     #define pb push_back     typedef long long li;     typedef double ld;     #define FILE "change me!"     void solve();     bool f=true;     //int timer=0;     int main ()     {     #ifdef _DEBUG     freopen ("in.txt", "r", stdin);     freopen ("out.txt", "w", stdout);     #else     //freopen ("in.txt", "r", stdin);     //freopen ("out.txt", "w", stdout);     //freopen (FILE ".in", "r", stdin);     //freopen (FILE ".out", "w", stdout);     #endif     int z=1;     //ios_base::sync_with_stdio(false);     cin>>z;     while (z--)     solve();     return 0;     }           void do_exception()     {     int hhh=1, aaa=0;     cout<<(hhh/aaa);     }           #define int li           int n;     int m;     pair <int, int> cur[2];           typedef vector <int> vi;           vector <int> sum (vi q, vi w)     {     if (q.size()>w.size())     swap (q, w);     vi res(w.size()+1);     for (int i=0; i<q.size(); i++)     {     res[i]+=q[i]+w[i];     res[i+1]+=res[i]/10;     res[i]%=10;     }     for (int i=q.size(); i<w.size(); i++)     {     res[i]+=w[i];     res[i+1]+=res[i]/10;     res[i]%=10;     }     if (res.size()==0)     return res;     if ( res[res.size()-1]==0 )     res.pop_back();     return res;     }           vi mul (vi q, int w)     {     vi res;     if (!w)     return res;     int s=0;     for (int i=0; i<q.size(); i++)     {     s+=q[i]*w;     res.push_back(s%10);     s/=10;     }     while (s)     {     res.push_back(s%10);     s/=10;     }     return res;     }           int dom=0;     int step=1;           void print (vector <int> ans)     {     reverse (all(ans));     for (int i=0; i<(int)ans.size()-dom; i++)     cout<<ans[i];     cout<<'.';     for (int i=(int)ans.size()-dom; i<ans.size(); i++)     cout<<ans[i];     for (int i=dom; i<9; i++)     cout<<"0";     cout<<endl;     }           bool cmp (vi q, vi w)     {     if (q.size()<w.size())     return true;     if (q.size()>w.size())     return false;     for (int i=(int)q.size()-1; i>=0; i--)     {     if (q[i]<w[i])     return true;     if (q[i]>w[i])     return false;     }     return false;     }           void solve()     {     cin>>n;     string q;     cin>>q;     step=1;     vector <int> now;     dom=0;     for (int i=0; i<q.size(); i++)     {     if (q[i]=='.')     dom=q.size()-1-i;     else     now.push_back(q[i]-'0');     }     for (int i=0; i<dom; i++)     step*=10;     int ww=0;     for (int i=0; i<now.size(); i++)     ww=ww*10+now[i];     ww--;     ww/=step;           reverse (all(now));     //cout<<dom<<' '<<step<<endl;           cin>>m;     for (int i=0; i<m; i++)     cin>>cur[i].first>>cur[i].second;     bool flag=false;     if (m==2 && (cur[0].first==cur[1].first || cur[0].first==cur[1].second || cur[0].second==cur[1].first || cur[0].second==cur[1].second))     flag=true;     if (n==1)     {     printf("0.000000000\n");     return;     }                 if ( ww<=1 )     {     int F=n; F*=(n-1); F/=2; F-=m;     vector <int> ans=now;     ans=mul(ans, F);     int M=n; M*=n-1;     vi res;     while (M)     res.push_back(M%10), M/=10;     res=mul(res, step);     ans=sum( ans, res );     print (ans);     return;     }     if (m<2 || flag)     {     int F=n-1; F-=m;     vector <int> ans=now;     ans=mul(ans, F);     int M=n-1; M*=n-1; M*=2;     vi res;     while (M)     res.push_back(M%10), M/=10;     res=mul(res, step);     ans=sum(ans, res);     print(ans);     return;     }           int F=n-2;     vector <int> ans=now;     ans=mul(ans, F);     int M=2*n; M*=n-2;     vi res;     while (M)     res.push_back(M%10), M/=10;     res=mul(res, step);     ans=sum(ans, res);           //print(ans);           F=n-3;     vector <int> ans1=now;     ans1=mul(ans1, F);     M=2*n+2; M*=n-2;     vi res1;     while (M)     res1.push_back(M%10), M/=10;     res1=mul(res1, step);     ans1=sum(ans1, res1);           if ( cmp (ans1, ans) )     ans=ans1;           print(ans);     } 
#include<bits/stdc++.h>  #define s(a) scanf("%d",&a) #define ss(a) scanf("%s",a)  #define MP           make_pair #define PB           push_back #define REP(i, n)    for(int i = 0; i < n; i++) #define INC(i, a, b) for(int i = a; i <= b; i++) #define DEC(i, a, b) for(int i = a; i >= b; i--) #define CLEAR(a)     memset(a, 0, sizeof a)  using namespace std;  typedef long long          LL; typedef unsigned long long ULL; typedef vector<int>        VI; typedef pair<int, int>     II; typedef vector<II>         VII;  int m; int size; int tree[3000006]; void build(int n) {       size = 1;       while(size<n)             size = size<<1;       REP(i,n)             tree[i+size] = i+1;       DEC(i,size-1,1)             tree[i] = (tree[2*i]*1LL*tree[2*i+1])%m;  } int query(int l,int r) {     int ans = 1;       for(l=l+size,r=r+size;l<r;l>>=1,r>>=1)     {             if(l&1) ans = (ans*1LL*tree[l++])%m;             if(r&1) ans = (ans*1LL*tree[--r])%m;     }     return ans; } int modexp(int a,int b,int m) {       if(b==0)return 1%m;       if(b==1)return a%m;       int temp = modexp(a,b/2,m);       temp = (temp*1LL*temp)%m;       if(b&1)temp = (temp*1LL*a)%m;       return temp; } int dp1[1000006]; int dp2[1000006]; int main() {       int t;       s(t);       while(t--)       {             int n,q,Q;             s(n);s(m);s(q);             dp1[1] = 1;             INC(i,2,n)             {                   int temp = modexp(i,i-1,m);                   dp1[i] = (dp1[i-1]*1LL*temp)%m;             }             dp2[n] = n;             DEC(i,n-1,1)             {                   int temp = modexp(i,n-i+1,m);                   dp2[i] = (dp2[i+1]*1LL*temp)%m;             }             build(n);             while(q--)             {                   s(Q);                   Q = min(Q,n-Q);                   int t1 = dp1[Q];                   int t2 = dp2[n-Q+1];                   int t3;                   if(Q!=n-Q)                         t3 = query(Q+1-1,n-Q);                   else t3 = 1;                   t3 = modexp(t3,Q,m);                   //printf("t1 = %d, t2 = %d, t3 = %d\n",t1,t2,t3);                   t3 = (t3*1LL*t2)%m;                   t3 = (t3*1LL*t1)%m;                   printf("%d\n",t3);             }       }       return 0; } 
#include<iostream> #include<cstdio> #include<cmath> #include<string> #include<cstring> #include<vector> #include<bitset> #include<map> #include<set> #include<climits> #include<algorithm> #include<utility> #include<cstdlib> #include<cctype> #include<queue> #include<sstream> #include<cassert> using namespace std;    int val[1000001]={0}; int mem[32][100001]={{0}}; int tree[32][524289]={{0}}; int rangesz[33]={0};  vector < pair <int,int>  > range[32]; vector < pair <int,int>  >::iterator it1,it2;   bool compare(const pair<int,int> &left,const pair<int,int>  &right) {     return left.first<right.first; }   int query(int node, int l, int r, int r1, int r2,int id )  {  if( r < r1 || l > r2 ) return -1;  if( l >= r1 && r <= r2 ) return tree[id][ node ];  int mid = ( l + r )>>1,q1,a1,a2;  q1 =(node<<1) + 1;  a1 = query( q1, l, mid , r1, r2,id);  a2 = query( q1+1, mid + 1, r, r1, r2,id);  if(a1 == -1) return a2;  else if(a2 == -1) return a1;  else return min(a1,a2); }   int make(int node,int l, int r ,int id) {  if(l==r)   {   tree[id][node]=range[id][l].second;   return 0 ;  }  int mid = (l+r)>>1,q1=(node<<1) + 1;  make(q1,l,mid,id) ;  make( q1+1,mid + 1,r ,id);  tree[id][ node]=min(tree[id][ q1],tree[id][q1+1]);  return 1; }   int findmin(int l,int r,int j) {     pair <int,int> ll=make_pair(l,0);     pair <int,int> rr=make_pair(r,0);          it1=lower_bound(range[j].begin(),range[j].end(),ll,compare);     it2=upper_bound(range[j].begin(),range[j].end(),rr,compare);     int pos1=(int) (it1-range[j].begin());     int pos2=(int) (it2-range[j].begin());     l=pos1;     r=pos2-1;     return query(0,0,rangesz[j]-1,l,r,j);      } int main() { //freopen("in.txt","r",stdin); int n,i,j,q,l,r; scanf("%d",&n); long long int ans;   for(i=0;i<n;i++) {    scanf("%d",&val[i]);        if(i)    for(j=0;j< (32);j++)    mem[j][i]=mem[j][i-1];         for(j=0;j<(32);j++)    if ( (1ll<<j) >val[i])     { 	    mem[j-1][i]+=val[i]; 		rangesz[j-1]++; 		range[j-1].push_back(make_pair(i,val[i]));         break;     } }   for(j=0;j< (32) ;j++) if(rangesz[j]) make(0,0,rangesz[j]-1,j);  scanf("%d",&q); while(q--) {     scanf("%d%d",&l,&r);     l-=1;     r-=1;     ans=0;     for(j=0;j< (32);j++)     {         int rem=mem[j][r];         if(l)rem-=mem[j][l-1];                  if(ans >=( (1ll <<(j+1))-1))         ans+=rem;         else if(rem && findmin(l,r,j)<=ans+1)ans+=rem;         else break;     }     printf("%lld\n",ans+1);  }      } 
//https://www.topcoder.com/community/data-science/data-science-tutorials/range-minimum-query-and-lowest-common-ancestor/#Sparse_Table_(ST)_algorithm //sparse tree for RMQ o(1) time to find min/max in a range and o(nlogn) to update #include <iostream> #include<bits/stdc++.h> #include <cstdio> #include <cmath> using namespace std;      int pow2[17];   int st[17][100100];   int arr[100100]; int getl[100001];   void makest(int n) {     int k=getl[n];     for(int i=0;i<n;i++)         st[0][i]=arr[i];     for(int i=1;i<=k;i++)     {             for(int j=0;j+pow2[i]-1<n;j++)         {             st[i][j]=max(st[i-1][j],st[i-1][j+pow2[i-1]]);         }       } }   int query(int i,int j) {     int k=getl[j-i+1];     return max(st[k][i],st[k][j-pow2[k]+1]); }               int main(){     int n,m,x,y;     scanf("%d",&n);       for(int i=0;i<n;i++)         scanf("%d",&arr[i]);         pow2[0]=1;         for(int i=1;i<17;i++)     {         pow2[i]=2*pow2[i-1];       }         for(int i=1;i<=n;i++)         getl[i]=(int)log2(i);     makest(n);     scanf("%d%d%d",&m,&x,&y);     long long ans=0;       ans+=(x<y?query(x,y):query(y,x));     for(int i=2;i<=m;i++)     {         x+=7;         while(x>=n-1)             x-=(n-1);             y+=11;         while(y>=n)             y-=n;         ans+=(x<y?query(x,y):query(y,x));     }     printf("%lld\n",ans);       }    
#include <algorithm> #include <iostream> #include <sstream> #include <cassert> #include <cstring> #include <cstdlib> #include <cstdio> #include <string> #include <vector> #include <bitset> #include <queue> #include <stack> #include <cmath> #include <deque> #include <ctime> #include <list> #include <set> #include <map> #include <iomanip> //zlb//  using namespace std;  typedef long long     LL; typedef unsigned long long     uLL; typedef pair<LL,LL> pii;  double PI  = acos(-1); double EPS = 1e-7; LL INF    = 1000000000; LL MOD    = 1000000007; LL MAXINT = 2147483647; LL INFLL   = 1000000000000000000LL; LL MAXLL   = 9223372036854775807LL;  #define fi            first #define se            second #define mp            make_pair #define pb            push_back #define SIZE(a)       (int)a.size() #define MIN(a, b)     (a) = min((a), (b)) #define MAX(a, b)     (a) = max((a), (b)) #define input(in)     freopen(in,"r",stdin) #define output(out)   freopen(out,"w",stdout) #define RESET(a, b)   memset(a,b,sizeof(a)) #define FOR(a, b, c)  for (int (a)=(b); (a)<=(c); (a)++) #define FORD(a, b, c) for (int (a)=(b); (a)>=(c); (a)--) #define FORIT(a, b)   for (__typeof((b).begin()) a=(b).begin(); a!=(b).end(); a++)  LL mx[8] = {-1,1,0,0,-1,-1,1,1}; LL my[8] = {0,0,-1,1,-1,1,-1,1};  // ------------ //   #define getcx getchar   inline void inp( int &n )   {     n=0;     int ch=getcx();int sign=1;     while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )             n = (n<<3)+(n<<1) + ch-'0', ch=getcx();     n=n*sign;   }     struct seg { 	int s,d,sum; };  int x[100005]; int expp[3][100005]; seg lol[3][400005]; int n,q,R; int p[3];  inline int pwr(int id,int num,int ex) { 	if (ex == 0) return 1; 	else if (ex%2==0) 	{ 		int tmp = pwr(id,num,ex/2); 		return ((LL)tmp*tmp)%(LL)p[id]; 	} 	else 	{ 		return ((LL)num*pwr(id,num,ex-1))%(LL)p[id]; 	} }  int tmp2[3]; int tmp3[3]; bool yoy[3];  inline int val(int id,int k,int l,int r) { 	int n = (r-l+1); 	if (!yoy[id]) 	{ 		LL s1 = n; 		LL s2 = ((2*lol[id][k].s)+((LL)(n-1)*lol[id][k].d)); 		if (s1&1) s2/=2; 		else s1 /=2;  		return (((LL)s1*(s2%(LL)p[id]))+(LL)lol[id][k].sum)%(LL)p[id]; 	} 	else 	{ 		int s1 = (((((((LL)lol[id][k].s+(((LL)(n-1)*(LL)lol[id][k].d)%p[id]))*(LL)expp[id][n])%p[id])-(LL)lol[id][k].s))*(LL)tmp2[id])%p[id]-((((LL)lol[id][k].d*(LL)R)%p[id]*((LL)(expp[id][n-1]-1+p[id])))%p[id]*(LL)tmp3[id])%p[id]; 		s1 %= p[id]; 		if (s1 < 0) s1 += p[id]; 		return ((LL)lol[id][k].sum+s1)%p[id]; 	} }    inline void build(int k=1,int l=1,int r=n) { 	lol[1][k].sum = lol[1][k].s = lol[1][k].d = 0; 	lol[2][k].sum = lol[2][k].s = lol[2][k].d = 0; 	if (l == r) 	{ 		lol[1][k].sum = x[l]%p[1]; 		lol[2][k].sum = x[l]%p[2]; 		return; 	} 	int m = (l+r)/2; 	build(2*k,l,m); 	build(2*k+1,m+1,r); 	lol[1][k].sum = (val(1,2*k,l,m)+val(1,2*k+1,m+1,r))%p[1]; 	lol[2][k].sum = (val(2,2*k,l,m)+val(2,2*k+1,m+1,r))%p[2]; }  inline void pass(int id,int k,int l,int r) { 	int m = (l+r)/2; 	lol[id][2*k].s = (lol[id][2*k].s+lol[id][k].s); 	if (lol[id][2*k].s >= p[id]) lol[id][2*k].s -= p[id]; 	lol[id][2*k].d = (lol[id][2*k].d+lol[id][k].d)%p[id]; 	if (lol[id][2*k].d >= p[id]) lol[id][2*k].d -= p[id];  	int dif = m+1-l; 	lol[id][2*k+1].s += ((LL)expp[id][dif]*(lol[id][k].s+(dif*(LL)lol[id][k].d)%p[id])%p[id])%p[id]; 	lol[id][2*k+1].d += ((LL)expp[id][dif]*(LL)lol[id][k].d)%p[id]; 	if (lol[id][2*k+1].s >= p[id]) lol[id][2*k+1].s -= p[id]; 	if (lol[id][2*k+1].d >= p[id]) lol[id][2*k+1].d -= p[id];   	lol[id][k].s = lol[id][k].d = 0; }  inline void update(int s,int d,int x,int y,int id,int k=1,int l=1,int r=n) { 	//cout << "UPDATE " << s << " " << d << " " << x << " " << y << " " << k << " " << l << " " << r << endl; 	if (l > y || r < x) return; 	if (x <= l && r <= y) 	{ 		lol[id][k].s = (lol[id][k].s+s); 		if (lol[id][k].s >= p[id]) lol[id][k].s -= p[id]; 		lol[id][k].d = (lol[id][k].d+d); 		if (lol[id][k].d >= p[id]) lol[id][k].d -= p[id]; 		return; 	} 	int m = (l+r)/2; 	pass(id,k,l,r); 	if (x <= m) 	{ 		update(s,d,x,min(y,m),id,2*k,l,m); 	} 	if (y >= m+1) 	{ 		if (x <= m)  		{ 			int dif = m+1-x; 			s = ((LL)expp[id][dif]*(s+(((LL)dif*d)%p[id])))%p[id]; 			d = ((LL)expp[id][dif]*(LL)d)%p[id]; 			update(s,d,max(m+1,x),y,id,2*k+1,m+1,r); 		} 		else update(s,d,max(m+1,x),y,id,2*k+1,m+1,r); 	} 	lol[id][k].sum = (val(id,2*k,l,m)+val(id,2*k+1,m+1,r))%p[id]; }  inline int query(int x,int y,int id,int k=1,int l=1,int r=n) { 	if (l > y || r < x) return 0; 	if (x <= l && r <= y) 	{ 		return val(id,k,l,r); 	} 	int m = (l+r)/2; 	pass(id,k,l,r); 	int res = (query(x,y,id,2*k,l,m)+query(x,y,id,2*k+1,m+1,r))%p[id]; 	lol[id][k].sum = (val(id,2*k,l,m)+val(id,2*k+1,m+1,r))%p[id]; 	return res; }  int main() { 	int T; 	scanf("%d",&T); 	FOR(tc,1,T) 	{ 		//scanf("%d%d%d%d%d",&n,&q,&R,&p[1],&p[2]); 		inp(n); 		inp(q); 		inp(R); 		inp(p[1]); 		inp(p[2]); 		expp[1][0] = 1; 		expp[2][0] = 1; 		tmp2[1] = pwr(1,R-1,p[1]-2); 		tmp2[2] = pwr(2,R-1,p[2]-2); 		tmp3[2] = ((LL)tmp2[2]*tmp2[2])%p[2]; 		tmp3[1] = ((LL)tmp2[1]*tmp2[1])%p[1]; 		 		yoy[1] = (R-1)%p[1]; 		yoy[2] = (R-1)%p[2]; 		FOR(a,1,n) 		{ 			//scanf("%d",&x[a]); 			inp(x[a]); 			expp[1][a] = ((LL)expp[1][a-1]*R)%(LL)p[1]; 			expp[2][a] = ((LL)expp[2][a-1]*R)%(LL)p[2]; 		} 		build(); 		while(q--) 		{ 			int t,s,d,x,y,g; 			inp(t); 			//scanf("%d",&t); 			if (t == 0) 			{ 				//scanf("%d %d %d %d",&s,&d,&x,&y); 				inp(s); 				inp(d); 				inp(x); 				inp(y); 				update(s%p[1],d%p[1],x,y,1); 				update(s%p[2],d%p[2],x,y,2); 			} 			else if (t == 1) 			{ 				//scanf("%d %d",&x,&g); 				inp(x); 				inp(g); 				int t1 = query(x,x,1); 				int t2 = query(x,x,2); 				int tmp = pwr(2,t2,g); 				update((p[1]-t1+tmp)%p[1],0,x,x,1); 				update((p[2]-t2+tmp)%p[2],0,x,x,2); 			} 			else 			{ 				//scanf("%d %d",&x,&y); 				inp(x); 				inp(y); 				printf("%d\n",(query(x,y,1)+p[1])%p[1]); 			} 		}  	} } 
#include<bits/stdc++.h> using namespace std;  typedef pair<int,int> II; typedef vector< II > VII; typedef vector<int> VI; typedef vector< VI > VVI; typedef long long int ll;  #define PB push_back #define MP make_pair #define F first #define S second #define SZ(a) (int)(a.size()) #define ALL(a) a.begin(),a.end() #define SET(a,b) memset(a,b,sizeof(a))  #define si(n) scanf("%d",&n) #define dout(n) printf("%d\n",n) #define sll(n) scanf("%lld",&n) #define lldout(n) printf("%lld\n",n) #define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)  #define TRACE  #ifdef TRACE #define trace(...) __f(#__VA_ARGS__,__VA_ARGS__) /*template <typename Arg1> void __f(const char * name, Arg1&& arg1){     cerr << name << " : " << arg1 << std::endl; } template <typename Arg1, typename... Args> void __f(const char* names, Arg1&& arg1, Args&&... args){     const char* comma = strchr(names + 1,',');cerr.write(names,comma - names) << " : " << arg1<<" | ";__f(comma+1,args...); }*/ #else #define trace(...) #endif ll max(ll p,ll q) {     return (p>q)?p:q; } ll min(ll p,ll q) {     return (p<q)?p:q; }  ll x;  ll findpow(ll num,ll p) {     if(p==1)     {         return num;     }     if(p%2==0)     {         ll temp=findpow(num,p/2);         return temp*temp;     }     else if(p%2==1)     {         ll temp=findpow(num,(p-1)/2);         return temp*temp*num;     } }  ll bs(ll st,ll end,ll p) {     ll mid=st+(end-st+1)/2,ans=1,i;     ans=findpow(mid,p);     //cout << st << " " << end << " " << mid << " " << ans << endl;     if(st==end)     {         return mid;     }     if(ans==x)     {         return mid;     }     else if(ans>x)     {         return bs(st,mid-1,p);     }     else if(ans<x)     {         return bs(mid,end,p);     } }  ll findroot(ll num,ll p) {     double tmp=pow(num,1.0/p);     ll low=tmp;     ll up=tmp+0.5;     if(low==up)     {         return low;     }     else if(pow(up,p)<=x)     {         return up;     }     else     {         return low;     } }  ll sum[10005],a[10005],ans1[15005]; int main() {     ll t,mod=1e9+7,i,ans,n,temp1,q,temp,j;     sll(t); //    lldout(mod);     while(t--)     {         sll(n);         sll(q);         sum[0]=0;         for(i=1;i<=n;i++)         {             sll(a[i]);             sum[i]=(sum[i-1]+a[i]);             if(sum[i]<=0)             {                 sum[i]=(sum[i]+1000000000*mod)%mod;             }             else if(sum[i]>=mod)             {                 sum[i]=sum[i]%mod;             }         }         for(j=0;j<q;j++)         {             sll(x);             ans=(x%mod*(a[1]+mod)%mod)%mod;             temp1=x;             for(i=2;i<=n;i++)             {               //  lldout(ans);                 temp=findroot(x,i);                 temp1=temp;                 ans=( ans + (temp%mod*(a[i]+mod)%mod)%mod + mod)%mod;                 if(temp==1)                 {                     ans=(ans+( sum[n] - sum[i] )%mod + mod)%mod;                     break;                 }             }             ans=ans%mod;             ans1[j]=ans;             cout << ans << " ";         }         cout << endl;     }     return 0; }  
#include <iostream>   #include <set>   #include <vector>   #include<stdio.h>   using namespace std;   int grid[500][500];   int ans[500][500];   char input[50000000];   int numcharsin;   int inpos = 0;   int getint() {   while (input[inpos]<'0' || input[inpos]>'9') inpos++;   int ret = 0;   while (inpos<numcharsin && input[inpos]>='0' && input[inpos]<='9') ret = 10*ret+input[inpos++]-'0';   return ret;   }   int row[500][1000];   int rowlen[500];   int col[500][1000];   int collen[500];   int brute[500][500];   int N,M;       int main() {   cin.read(input,50000000);   numcharsin = cin.gcount();   int T = getint(); while (T--) {   M=getint();   N=getint();   for (int i=0; i<M; i++)   for (int j=0; j<N; j++) grid[i][j]=getint();     memset(row,-1,500*1000*sizeof(int));   memset(col,-1,500*1000*sizeof(int));   memset(rowlen,0,500*sizeof(int));   memset(collen,0,500*sizeof(int));       int ret = 0;   for (int i=M-1; i>=0; i--)   for (int j=N-1; j>=0; j--) {   int low = 0, high = rowlen[i]+1;     while (high-low>1) {   int mid = (high+low)/2;   if (grid[i][row[i][mid]]>=grid[i][j]) {   low = mid;   } else {   high = mid;   }   }     int low2 = 0, high2 = collen[j]+1;   while (high2-low2>1) {   int mid = (high2+low2)/2;   if (grid[col[j][mid]][j]<=grid[i][j]) {   low2 = mid;   } else {   high2 = mid;   }   }     ans[i][j] = 1 + max(low,low2);   // printf("Setting ans[%d][%d] = 1 + max(%d,%d) = %d\n",i,j,low,low2,ans[i][j]);   ret>?=ans[i][j];   for (int k=ans[i][j]; k>=low && k>0; k--) {   if (row[i][k]!=-1 && grid[i][row[i][k]]>=grid[i][j]) break;   // printf("row[%d][%d] = %d\n",i,k,j);   row[i][k]=j;   }   for (int k=ans[i][j]; k>=low2 && k>0; k--) {   if (col[j][k]!=-1 && grid[col[j][k]][j]<=grid[i][j]) break;   // printf("col[%d][%d] = %d\n",j,k,i);   col[j][k]=i;   }       rowlen[i]>?=ans[i][j];   collen[j]>?=ans[i][j];   }   printf("%d\n",ret);         }   }
#include<cstdio> #define MXN 10007  int T,n,SG,a[MXN],b[MXN];  int main() { 	for (scanf("%d",&T);T--;){ 		scanf("%d",&n);SG=0; 		for (int i=1;i<=n;++i) scanf("%d",a+i); 		for (int i=1;i<=n;++i) b[i]=a[n-i+1]-a[n-i]-1; 		for (int i=1;i<=n;i+=2) SG^=b[i]; 		if (!SG) puts("Johnny wins"); 		else{ 			puts("Mary wins"); 			for (int i=n;i>0;--i) if (i&1){ 				int d=SG^b[i]; 				if (d<b[i]) {printf("Move %d to %d\n",a[n-i+1],a[n-i]+d+1);break;} 				if (i!=n && b[i]<d && d<=b[i]+b[i+1]) {printf("Move %d to %d\n",a[n-i],a[n-i]-d+b[i]);break;} 			} 		} 		putchar('\n'); 	} 	return 0; } 
#include<iostream> #include<stdio.h> #include<stdlib.h> #include<algorithm> #include<sstream> #include<string> #include<string.h> #include<deque> #include<vector> #include<stack> #include<queue> #include<math.h> #include<map> #include<set>  using namespace std;  typedef long long LL; typedef pair<int,int> pii;  double PI = acos(-1); double EPS = 1e-7; int INF = 1000000000; int MAXINT = 2147483647; LL INFLL = 1000000000000000000LL; LL MAXLL = 9223372036854775807LL;  #define fi first #define se second #define mp make_pair #define pb push_back  #define SIZE(a) (int)a.size() #define ALL(a) a.begin(),a.end() #define RESET(a,b) memset(a,b,sizeof(a)) #define FOR(a,b,c) for (int (a)=(b); (a)<=(c); (a)++) #define FORD(a,b,c) for (int (a)=(b); (a)>=(c); (a)--) #define FORIT(a,b) for (__typeof((b).begin()) a=(b).begin(); a!=(b).end(); (a)++) #define PAUSE system("pause")  #define input(in) freopen(in,"r",stdin) #define output(out) freopen(out,"w",stdout)  pii M[8] = {mp(0,1),mp(1,0),mp(-1,0),mp(0,-1),mp(-1,1),mp(-1,-1),mp(1,-1),mp(1,1)};  /*\   \ \   \*/  pii lol[205]; int use[205];  int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		int n,x; 		scanf("%d%d",&n,&x); 		FOR(a,1,n) 		{ 			scanf("%d%d",&lol[a].fi,&lol[a].se); 			use[a] = 0; 		} 		sort(lol+1,lol+n+1); 		int ans = 0; 		FOR(a,1,n) 		{ 			int sum = 0; 			FOR(b,1,a) 			{ 				if (lol[b].se >= lol[a].fi && !use[b]) sum++; 			} 			if (sum >= x) 			{ 				int best = a; 				FOR(b,1,a) 				{ 					if (lol[b].se >= lol[a].fi && !use[b]) 					{ 						if (lol[best].se < lol[b].se) best = b; 					} 				} 				use[best] = 1; 				ans++; 			} 		} 		printf("%d\n",ans); 	} }
#include<iostream> #include<stdio.h> #include<assert.h> #include<string.h> #include<time.h> #include<stdlib.h> #include<math.h> #include<string> #include<sstream> #include<map> #include<set> #include<queue> #include<stack> #include<vector> #include<algorithm> #pragma comment(linker, "/STACK:16777216") #define pb push_back #define ppb pop_back #define mp make_pair #define all(x) (x).begin(),(x).end() #define sz(x) (int)(x).size() #define LL long long #define bit __builtin_popcountll #define sqr(x) (x) * (x) using namespace std; typedef pair<int, int> pii; const double eps = 1e-9; const double pi = acos(-1.0); const LL mod = (LL)1e9 + 7; LL binpow(LL a, LL b) { 	LL res = 1; 	while(b > 0) { 		if (b & 1) { 			res = res * a % mod; 		} 		a = a * a % mod; 		b >>= 1; 	} 	return res; } int main() { 	#ifndef ONLINE_JUDGE 	freopen("input.txt","r",stdin); 	freopen("output.txt","w",stdout); 	#endif 	LL n,m; 	int T; cin >> T; 	while(T--) { 		scanf("%lld%lld",&n,&m); 		int odd = 0; 		if (n % 2 == 1) { 			n--; 			odd = 1; 		} 		if (m % 2 == 1) { 			m--; 			odd = 1; 		} 		n %= mod - 1; 		m %= mod - 1; 		printf("%lld\n",binpow(2,(n * m + odd) % (mod - 1))); 	} 	return 0; } 
#include <iostream> #include <cstdio> #include <vector> #include <queue> using namespace std; const int N = 5000+5; bool gr[N][N]; struct coord {    int x, y; }; int T, n, m, k; vector< int > graph[N]; vector< int > g[N]; int top, st[N]; int go[N];  int mark[N]; void dfsT(int v, int ty) {    mark[v] = ty;    for(unsigned int j = 0; j < g[v].size(); ++ j)    {       int to = g[v][j];       if(mark[to]==0)       {          dfsT(to, 2-ty+1);       }    } } void twopart(int q) {    for(int i = 1; i <= q; ++ i)    {       mark[i] = 0;    }    for(int i = 1; i <= q; ++ i)    {       if(mark[i]==0)       {          dfsT(i, 1);       }    } }  int rtop, re[N];  vector< coord > res[N]; bool used[N][N]; queue< coord > qu;  int sta[N], fin[N]; int siz;  int main() {   // freopen("input.txt", "r", stdin);    scanf("%d", &T);    for(int te = 1; te <= T; ++ te)    {       scanf("%d%d", &n, &m);        for(int i = 1; i <= m; ++ i)       {          int s, f;          scanf("%d%d", &s, &f);          graph[s].push_back(f);          graph[f].push_back(s);           gr[s][f] = 1;          gr[f][s] = 1;       }       rtop = 0;       for(int i = 1; i <= n; ++ i)       {          if(graph[i].size() >= 3)          {             for(int j = 1; j <= n; ++ j)             go[j] = 0;              top = 0;             for(unsigned int j = 0; j < graph[i].size(); ++ j)             {                int v = graph[i][j];                ++ top;                 st[ top ] = v;                go[v] = top;                g[ top ].clear();             }              for(int u = 1; u <= top; ++ u)             {                for(int v = u+1; v <= top; ++ v)                {                   if(gr[ st[u] ][ st[v] ]==0)                   {                      g[ u ].push_back(v);                      g[ v ].push_back( u );                   }                }             }             //g is bipartite             twopart(top);             int q1 = 0, q2 = 0;             for(int u = 1; u <= top; ++ u)             {                if(mark[ u ]==1)                ++ q1;                else                ++ q2;             }             if(q1 >= 3 || q2 >= 3)             {                if(q1 < 3)                {                   swap(q1, q2);                   for(int v = 1; v <= top; ++ v)                   {                      mark[v] = 2-mark[v]+1;                   }                }                //q1 >= 3                for(int sh = 1; sh <= top; ++ sh)                {                   int sz = 0;                   int v = st[ sh ];                   if(mark[sh]==2)                   {                      for(unsigned int j = 0; j < graph[v].size(); ++ j)                      {                         if(go[ graph[v][j] ]!=0 && mark[ go[ graph[v][j] ] ]==1)                         ++ sz;                      }                      if(sz >= 2)                      {                         mark[ sh ] = 1;                      }                   }                }                rtop = 0;                ++ rtop;                re[ rtop ] = i;                for(int v = 1; v <= top; ++ v)                {                   if(mark[v]==1)                   {                      ++ rtop;                      re[rtop] = st[v];                   }                }                goto x;             }             else             continue;             //x*x+y*y >= 2*x*y x*x+y*y+2*x*y <= 2*(x*x+y*y) <= O(m)          }       }       x:       for(int i = 1; i <= n; ++ i)       mark[i] = 0;       top = 1;       for(int i = 1; i <= rtop; ++ i)       {          coord c;          ++ top;          c.x = top;          c.y = re[i];          qu.push(c);           mark[ c.y ] = 1;           sta[ c.y ] = 1;          fin[ c.y ] = top;           res[1].push_back(c);       }       while(!qu.empty())       {          coord c;          c = qu.front();          qu.pop();          for(unsigned int j = 0; j < graph[c.y].size(); ++ j)          {             int u = graph[ c.y ][j];             if(mark[u]==0)             {                bool stug = 0;                for(unsigned int e = 0; e < graph[ u ].size(); ++ e)                {                   int to = graph[u][e];                   if(mark[to]!=0)                   {                      if(sta[to]==c.x || fin[to]==c.x)                      continue;                       stug = 1;                      coord d;                      d.x = fin[to];                      d.y = u;                      mark[ u ] = 1;                      sta[u] = c.x;                      fin[u] = d.x;                      res[ c.x ].push_back(d);                      break;                   }                }                if(stug==0)                {                   coord d;                   ++ top;                   d.x = top;                   d.y = u;                   qu.push(d);                    mark[ d.y ] = 1;                    sta[ d.y ] = c.x;                   fin[ d.y ] = top;                    res[c.x].push_back(d);                }             }          }       }       printf("%d\n", top);       for(int i = 1; i <= n; ++ i)       printf("%d %d\n", sta[i], fin[i]);       //clear gr       for(int i = 1; i <= n; ++ i)       {          for(unsigned int j = 0; j < graph[i].size(); ++ j)          {             gr[i][ graph[i][j] ] = 0;             gr[ graph[i][j] ][ i ] = 0;          }       }       for(int i = 1;i <= n; ++ i)       {          graph[i].clear();          res[i].clear();       }    }    return 0; } 
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <limits> #include <string> #include <cassert>  using namespace std; typedef long long LL; typedef pair<int,int> pii;  #define forup(i,a,b) for(int i=a; i<b; ++i) #define fordn(i,a,b) for(int i=a; i>b; --i) #define rep(i,a) for(int i=0; i<a; ++i)  #define dforup(i,a,b) for(i=a; i<b; ++i) #define dfordn(i,a,b) for(i=a; i>b; --i) #define drep(i,a) for(i=0; i<a; ++i)  #define slenn(s,n) for(n=0; s[n]!=13 and s[n]!=0; ++n);s[n]=0  #define gi(x) scanf("%d",&x) #define gl(x) cin>>x #define gd(x) scanf("%lf",&x) #define gs(x) scanf("%s",x)  #define pis(x) printf("%d ",x) #define pin(x) printf("%d\n",x) #define pls(x) cout<<x<<" " #define pln(x) cout<<x<<"\n" #define pds(x) printf("%.12f ",x) #define pdn(x) printf("%.12f\n",x) #define pnl() printf("\n")  #define fs first #define sc second  #define pb push_back  const int inv=1000000000; const int minv=-inv;  const int max_n=50010; const int max_q=50010; const int max_logn=16; const int chunk=225;  int T; int n,q; char s[max_n+5];  // Suffix Arrays Codechunk  int logn,pown;  int p[max_logn+1][max_n];  struct Lel { 	int pr; 	int se; 	int ix; }; struct less_Lel : public binary_function<Lel,Lel,bool> { 	bool operator () (const Lel &a, const Lel &b) { return ( (a.pr<b.pr) or ( (a.pr==b.pr) and (a.se<b.se) ) ); } }; Lel L[max_n];  int findlcp(int x, int y, int k, int p2k) { 	if(k==-1) 		return 0; 	if(x>=n or y>=n) 		return 0; 	  	if(p[k][x]==p[k][y]) 		return p2k+findlcp(x+p2k,y+p2k,k-1,p2k/2); 	else 		return findlcp(x,y,k-1,p2k/2); }  int perm[max_n]; int iperm[max_n];  int findlcp(int x, int y) { 	if(x==-1 or x==n or y==-1 or y==n) 		return 0; 	return findlcp(iperm[x],iperm[y],logn,pown); }  void f() { 	logn=0; pown=1; 	while(pown<n) 	{ 		pown*=2; 		logn+=1; 	} 	 	for(int i=0; i<n; ++i) 	{ 		L[i].pr=s[i]-'a'; 		L[i].se=0; 		L[i].ix=i; 	} 	sort(L, L+n, less_Lel()); 	 	int ct=0; 	p[0][L[0].ix]=0; 	for(int i=1; i<n; ++i) 	{ 		if( not (L[i].pr==L[i-1].pr and L[i].se==L[i-1].se) ) 			++ct; 		p[0][L[i].ix]=ct; 	} 	 	int powc=1; 	for(int k=1; k<=logn; ++k) 	{ 		for(int i=0; i<n; ++i) 		{ 			L[i].pr=p[k-1][i]; 			if(i+powc<n) 				L[i].se=p[k-1][i+powc]; 			else 				L[i].se=-1; 			L[i].ix=i; 		} 		sort(L, L+n, less_Lel()); 		 		ct=0; 		p[k][L[0].ix]=0; 		for(int i=1; i<n; ++i) 		{ 			if( not (L[i].pr==L[i-1].pr and L[i].se==L[i-1].se) ) 				++ct; 			p[k][L[i].ix]=ct; 		} 		 		powc*=2; 	} }  // End of Codechunk  struct query { 	int ql,qr,ix; 	query(){} 	query(int ql_, int qr_, int ix_) { ql=ql_; qr=qr_; ix=ix_; } }; struct less_query : public binary_function <query,query,bool> { 	bool operator() (const query &a, const query &b) { return (pii(a.qr,a.ql)<pii(b.qr,b.ql)); } }; vector<query> Q[chunk+5];  int l,r,sub; set<int> S; set<int>::iterator it;  int tot[max_n]; int ptot[max_n+1]; int res[max_q];  int change(int x) { 	//cerr<<"change @ "<<x<<"\n"; 	it=S.upper_bound(x); int nxt=(*it); 	--it; int prv=(*it);  	int ret=0; 	ret+=findlcp(prv,x); 	ret+=findlcp(x,nxt); 	ret-=findlcp(prv,nxt); 	return ret; }  void add(int x) { 	//cerr<<"add @ "<<x<<"\n"; 	sub+=change(perm[x]); 	S.insert(perm[x]); } void del(int x) { 	//err<<"del @ "<<x<<"\n"; 	S.erase(S.find(perm[x])); 	sub-=change(perm[x]);	 }  void incl() { 	if(l<=r) del(l); 	++l; } void decl() { 	--l; 	if(l<=r) add(l); } void incr() { 	++r; 	if(l<=r) add(r); } void decr() { 	if(l<=r) del(r); 	--r; }  int main() { 	gi(T);  	rep(z,T) 	{ 		gs(s); slenn(s,n);  		f();  		/*cout<<logn<<" "<<pown<<"\n"; 		rep(i,n) 			cout<<i<<": "<<p[logn][i]<<"\n";*/  		rep(i,n) 		{ 			perm[i]=p[logn][i]; 			iperm[perm[i]]=i; 		}  		//cerr<<"Here 1\n";  		gi(q); 		for(int i=0; i<=(n-1)/chunk; ++i) 			Q[i].resize(0); 		rep(i,q) 		{ 			int cl,cr; 			gi(cl); gi(cr); 			--cl; --cr;  			Q[cl/chunk].pb(query(cl,cr,i)); 		} 		for(int i=0; i<=(n-1)/chunk; ++i) 			sort(Q[i].begin(),Q[i].end(),less_query());  		//cerr<<"Here 2\n";  		ptot[0]=0; 		rep(i,n) 		{ 			tot[i]=n-i; 			ptot[i+1]=ptot[i]+tot[i]; 		}  		//cerr<<"Here 3\n";  		//l=0; r=0; sub=0; 		//S.clear(); S.insert(-1); S.insert(n); S.insert(perm[0]); 		for(int i=0; i<=(n-1)/chunk; ++i) 		{ 			if(Q[i].size()==0) continue;  			l=Q[i][0].ql; r=Q[i][0].ql; sub=0; 			S.clear(); S.insert(-1); S.insert(n); S.insert(perm[l]); 			rep(j,Q[i].size()) 			{ 				query cq=Q[i][j];  				while(l<cq.ql) incl(); 				while(l>cq.ql) decl();  				while(r<cq.qr) incr(); 				//while(r>cq.qr) decr();  				int cres=(ptot[r+1]-ptot[l]-sub); 				res[cq.ix]=cres; 			} 		}  		//cerr<<"Here 4\n";  		rep(i,q) 			pin(res[i]); 	}  	return 0; }
#include <iostream>   using namespace std;   long long GCD(long long a,long long b){     if(b == 0)         return a;     else         return GCD(b,a%b); }   int main(){     int t;     long long a, b, c, d, gcd, diff, result;     cin >> t;     for(int i = 0; i < t; i++){         cin >> a >> b >> c >> d;         diff = (a > b)?(a - b):(b - a);         gcd = GCD(c, d);         result = diff % gcd;         cout << ((result < (gcd - result))?result:(gcd - result)) << "\n";     }     return 0; }  
/* Money Changing Problem / Frobenius Numbers: Computing the Frobenius number in time O(k a1) Sebastian Böcker Zsuzsanna Lipták  In the classical Money Changing Problem (MCP), we are given coins of k different values a1 < a2 < · · · < ak with gcd(a1, . . . , ak) = 1. We want to know what change n = summation( aixi ) we can generate from these coins for non-negative integers xi, assuming that we have an infinite supply of coins. Then, there exists an integer g(a1, . . . , ak) called the Frobenius number of a1, . . . , ak, such that g(a1, . . . , ak) does not allow a decomposition of the above type, but all integers n > g(a1, . . . , ak) do. for k = 2 we have g(a1, a2) = a1a2 − a1 − a2. It is NP-Hard Probem.  For integers a, b, let a mod b denote the unique integer in 0, . . . , b − 1 such that (a mod b) == a mod b holds. Let a1 < · · · < ak with gcd(a1, . . . , ak) = 1 be an instance of the Money Changing Problem. We denote by np the smallest integer with np == p mod a1 ( NOTE: on doing p%a1 we make x1=0 as it eliminates the sum in n produces by quantity a1*x1. For e.g. let a1=3 a2= 2 and n= 13 ( 3*3 + 2*2) now on doping 13%3 = 4 (3*0 + 2*2). this implies that all the contribution made by a1 has been nullified and hence x1 = 0 now. The same aruement holds true for all ai's ) that can be decomposed into a non-negative integer combination of a1, . . . , ak. The np are well-defined: If n has a decomposition, so has n + a1 ( x1-> x1+1 ), and n  == n + a1 mod a1. Clearly, summation( ai*xi ) = np implies x1 = 0 because otherwise, np − a1 (this would mean that np was not the samllest number ) has a decomposition, too. If the np are known, then we can test in constant time whether some number n can be decomposed: Set p = n mod a1, then n can be decomposed if and only if n >= np. Given the values np for p = 0, . . . , a1 − 1 we can compute the Frobenius number g(a1, . . . , ak) and the number of omitted values ! that cannot be decomposed using a1, . . . , ak.  */  /* np=  smallest integer with np == p mod a1 that can be decomposed into a non-negative integer combination of a1, . . . , ak.  Round Robin Algorithm for frobenius numbers  initialize n0 = 0 and np = -1 for p = 1, . . . , a1 − 1 2 for i = 2, . . . , k do 3 	d = gcd(a1, ai); 4 	for r = 0, . . . , d − 1 do 5 		Find n = min{nq : q = r, r + d, r + 2d, . . . , r + (a1 − d)}; 6 		If n < -1 then repeat a1/d times 7			n = n + ai; 			p = n mod a1; 8 			n = min{n, np}; n =  np; 9 		done; 10	done; 11 done. */  #include <cstdio> #include <algorithm> using namespace std;  #define FOR(i,a,b) for(int i=a;i<b;i++) #define FORD(i,a,b) for(int i=a;i>=b;i--) #define wile(n) while(n--> 0 ) #define REP(i,n) FOR(i,0,n) typedef long long int LL; #define INF 1000000000000000000LL  inline long long int FAST_IO() {	long long int x=0; 	char ch; 	while ((ch=getchar_unlocked()) < 48 || ch > 57); 	x = ch-48; 	while ((ch=getchar_unlocked()) >= 48 && ch <= 57) 		x=x*10+ch-48; 	return x; }  LL np[100010];  LL gcd(LL a,LL b) {	return (b==0) ? a : gcd((LL)b,(LL)a%b);		}  int main() {	LL t, gc, p, q, a1, c1, b1, x, maxm, n,a[100],d,y,no,yes; 	t= FAST_IO(); 	wile(t) 	{	n=FAST_IO(); 		REP(i,n) 			a[i]=FAST_IO(); 		q= FAST_IO(); 		a1= FAST_IO(); 		b1= FAST_IO(); 		c1= FAST_IO(); 		sort(a,a+n); 		REP(i,a[0]) 			np[i]=INF; 		np[0]=0; 		gc=gcd(a[0],a[1]); 		FOR(i,2,n) 			gc=gcd(gc,a[i]); 		FOR(i,1,n) 		{	d=gcd(a[0],a[i]); 			for(LL j=0;j<d;j++) 			{	x=INF; 				for(LL k=j;k<=j+a[0]-d;k+=d) 					x=min(x,np[k]); 				if(x<INF) 				{	REP(ii,a[0]/d) 					{	x+=a[i]; 						p=x%a[0]; 						x=min(x,np[p]); 						np[p]=x; 					} 				} 			} 		} 		maxm=-INF; 		REP(i,a[0]) 			maxm=max(maxm,np[i]); 		if(gc==1) 			printf("%lld\n",maxm-a[0]); 		else 			printf("%lld\n",-1LL); 		no=0,yes=0; 		FOR(i,1,q+1) 		{	LL num=(a1*i+b1)%c1; 			LL p=num%a[0]; 			if(np[p]>num) 				no++; 			else 				yes++; 		} 		printf("%lld %lld\n",no,yes); 	} 	return 0; }
    #include <iostream>     #include <sstream>     #include <string>     #include <vector>     #include <stack>     #include <queue>     #include <set>     #include <map>     #include <algorithm>     #include <cstdio>     #include <cstdlib>     #include <cstring>     #include <cctype>     #include <cmath>     #include <cassert>     #include <climits>     using namespace std;           #define all(c) (c).begin(), (c).end()     #define iter(c) __typeof((c).begin())     #define cpresent(c, e) (find(all(c), (e)) != (c).end())     #define rep(i, n) for (int i = 0; i < (int)(n); i++)     #define tr(c, i) for (iter(c) i = (c).begin(); i != (c).end(); ++i)     #define pb(e) push_back(e)     #define mp(a, b) make_pair(a, b)           int pop_pre[1 << 20];           void init_pop(int n) { // n bits     for (int b = 1; b < 1 << n; ++b) {     pop_pre[b] = pop_pre[b & (b - 1)] + 1;     }     }           inline int pop(int b) {     return pop_pre[b];     }           int N, M;     int adj[20];           int ine[1 << 18], sub[1 << 18], prv[1 << 18];           int main() {     init_pop(18);           int T;     scanf("%d", &T);           rep (ca, T) {     scanf("%d%d", &N, &M);           memset(adj, 0, sizeof(adj));     rep (i, M) {     int a, b;     scanf("%d%d", &a, &b);     --a;     --b;     adj[a] |= 1 << b;     adj[b] |= 1 << a;     }     int all = (1 << N) - 1;           ine[0] = 0;     rep (b, 1 << N) if (b) {     int v = __builtin_ctz(b);     ine[b] = ine[b ^ (1 << v)] + pop(adj[v] & b);     }           int n2 = N / 2;     int n4 = (n2 + 1) / 2;     rep (b, 1 << N) if (pop(b) == n2) {     sub[b] = -1;     // printf(" b=%d\n", b);     for (int tb = b; tb; tb = (tb - 1) & b) if (pop(tb) == n4) {     int t = ine[tb] + ine[b ^ tb];     // printf(" t=%d\n", t);     if (t > sub[b]) {     sub[b] = t;     prv[b] = tb;     // printf(" %d: %d\n", b, t);     }     }     }           int ans = -1, see = 0;     rep (b, 1 << N) if (pop(b) == n2) {     int t = sub[b] + sub[b ^ all];     if (t > ans) {     ans = t;     see = b;     }     }           int x[20], y[20];     rep (i, N) {     int b = 1 << i;     int q = see & b ? (prv[see] & b ? 2 : 3) : (prv[all ^ see] & b ? 0 : 1);     x[i] = (i + 1) * (q & 1 ? -1 : 1);     y[i] = (i + 1) * (q & 2 ? -1 : 1);     }           if (ca) puts("");     printf("%d\n", M - ans);     rep (i, N) printf("%d %d\n", x[i], y[i]);     }           return 0;     } 
#ifdef _WIN32 #  define LL "%I64d" #else #  define LL "%Ld" #endif  #include <iostream> #include <cstdio> #include <cstdlib> #include <cmath> #include <cstring> #include <ctime> #include <vector> #include <deque> #include <set> #include <map> #include <queue> #include <stack> #include <bitset> #include <string> #include <algorithm> #include <complex> #include <utility> using namespace std; #define null NULL #define mp make_pair #define pb(a) push_back(a) #define sz(a) ((int)(a).size()) #define all(a) a.begin() , a.end() #define fi first #define se second #define relaxMin(a , b) (a) = min((a),(b)) #define relaxMax(a , b) (a) = max((a),(b)) #define SQR(a) ((a)*(a)) typedef vector<int> vi; typedef pair<int,int> pii; typedef long long ll; #define MOD 1000000007LL void add_to(ll& w , ll how){   w += how;   if(w >= MOD)    w -= MOD; } ll fact[2010]; // helpers ll line_dp[2010][2010]; ll cyc_dp[2010][2010]; ll eval_line(int len , int cnt){   if(cnt == 0)return 1;   if(len <= 0)return 0;   if(line_dp[len][cnt] != -1)    return line_dp[len][cnt];   ll& DP = line_dp[len][cnt];   DP = 0;   add_to(DP , eval_line(len-2 , cnt-1));   add_to(DP , eval_line(len-1 , cnt));   return DP; } ll eval_cyc(int len , int cnt){   if(cnt == 0)return 1;   if(len < cnt || len <= 0)return 0;   ll& DP = cyc_dp[len][cnt];   DP = 0;   add_to(DP , eval_line(len-3 , cnt-1));   add_to(DP , eval_line(len-1 , cnt));   return DP; } // solution int N; vi cyc_sz; vector<ll> m_cnt; void init(){   m_cnt.resize(N+1);   fill(all(m_cnt) , 0);   m_cnt[0] = 1;   for(int i=0;i<sz(cyc_sz);++i){    int cur = cyc_sz[i];    for(int i=N;i>=0;--i){     int up = min(i , cur);     for(int take=1;take<=up;++take)      add_to(m_cnt[i] , (eval_cyc(cur , take)*m_cnt[i-take])%MOD);                         }                                } } vi go[2010]; vector<char> used; void dfs(int vr){   ++cyc_sz.back();   used[vr] = true;   for(int i=0;i<sz(go[vr]);++i)    if(!used[go[vr][i]])     dfs(go[vr][i]); } void doit(){   scanf("%d" , &N);   cyc_sz.clear();   for(int i=0;i<2*N;++i)    go[i].clear();   used.resize(2*N);   fill(all(used) , false);   vi r1(N) , r2(N);   for(int i=0;i<N;++i){    scanf("%d" , &r1[i]);    //r1[i] = 1 + i;    go[i].pb(N + r1[i]-1);    go[N + r1[i] - 1].pb(i);                       }   for(int i=0;i<N;++i){    scanf("%d" , &r2[i]);    //r2[i] = 1 + (i+1)%N;    go[i].pb(N + r2[i]-1);    go[N + r2[i] - 1].pb(i);                       }   for(int i=0;i<2*N;++i)    if(!used[i])     cyc_sz.pb(0),     dfs(i);   init();   ll ans = 0;   for(int i=0;i<=N;++i){    ll koef = fact[N-i];    koef *= m_cnt[i];    if(i&1)ans = (ans - koef)%MOD;    else ans = (ans + koef)%MOD;                        }   printf("%d\n" , (int)((ans + MOD)%MOD)); } int main(){   fact[0] = 1;   for(int i=1;i<1010;++i)    fact[i] = (i*fact[i-1])%MOD;   memset(line_dp , -1 , sizeof line_dp);   memset(cyc_dp , -1 , sizeof cyc_dp);   int Q;   scanf("%d" , &Q);   while(Q-- > 0)    doit();   return 0; } 
#include <algorithm> #include <iostream> #include <cassert> #include <cstdio> #include <cstring>  #define NMAX 310 #define MOD (int)((1e9)+7)  using namespace std;  struct bigint{ 	char dig[NMAX]; 	int n;  	bigint(){ 		memset(dig,0,sizeof(dig)); 		n = 0; 	}  	bool operator<(const bigint &rhs)const{ 		int i; 		for(i = max(n-1,rhs.n-1); i >= 0; --i){ 			if(dig[i] < rhs.dig[i]) return 1; 		} 		return 0; 	}  	bigint& operator++(){ 		int i; 		for(i = 0; i < n; ++i){ 			++dig[i]; 			if(dig[i] < 10) return *this; 			dig[i]=0; 		}  		++dig[n++]; 		return *this; 	}  	bigint& operator--(){ 		assert(n); 		int i;  		for(i = 0; i < n-1; ++i){ 			--dig[i]; 			if(dig[i] >= 0) return *this; 			dig[i] = 9; 		}  		--dig[n-1]; 		while(n && !dig[n-1])--n;  		return *this; 	}  	inline int empty(){ 		return !n; 	}  	void set_from_str(char *str, int len){ 		int i; 		assert(str[0]^'0'); 		for(i = len-1; i >= 0; --i){ 			dig[len-i-1] = str[i]-'0'; 		}  		n = max(n,len); 		while(n > len) dig[--n] = 0; 	}  	void set_inf(){ 		n = 301; 		dig[n-1] = 1; 	} };    char str[NMAX]; int N;  bigint sol_num; int sol_val;   int dg_sum[NMAX]; int pow10[NMAX];  bigint num,tmp;  inline int add(int a, int b){ 	int c = a+b; 	if(c >= MOD) c-= MOD; 	if(c < 0) c += MOD; 	return c; }  inline int mul(int a, int b){ 	return (1LL*a*b)%MOD; }   int get_pos(bigint &num){ 	int i,pos,n;  	n = num.n; 	pos = add( dg_sum[n-1] , mul(mul(pow10[n-1],num.dig[n-1]-1),n) );  	for(i = num.n-2; i >=0 ;--i){ 		pos = add( pos, mul(mul(pow10[i],num.dig[i]),n)); 	}  	return pos; }  int check_range(int s, int e){ 	if(str[s]=='0') return 0; 	num.set_from_str(str+s,e-s+1);  	tmp = num;  	int i,k;  	for(i = s-1; i >= 0;){ 		--tmp; 		if(tmp.empty()) return 0; 		for(k = 0; k < tmp.n && i >= 0; ++k, --i){ 			if((str[i]-'0')^tmp.dig[k]) return 0; 		} 	}  	tmp = num;  	for(i = e+1; i < N;){ 		++tmp; 		for(k = tmp.n-1; k >= 0 && i < N; --k, ++i){ 			if((str[i]-'0')^tmp.dig[k]) return 0; 		} 	}  	int pos = get_pos(num);  	return add(pos,1-s); }   void init(){ 	int i;  	pow10[0] = 1; 	for(i = 1; i < NMAX; ++i){ 		pow10[i] = mul(pow10[i-1],10); 		dg_sum[i] = add(dg_sum[i-1], mul(mul(pow10[i-1],9),i)); 	} }  int main(){ 	int t,i,j,tmp;  	init();  	scanf("%d",&t);  	while(t--){  		scanf("%s",str); 		N = strlen(str); 		sol_num.set_inf(); 		sol_val = -1;  		for(i =0 ; i < N; ++i){ 			for(j = i; j < N; ++j){ 				tmp = check_range(i,j); 				if(!tmp) continue; 				if(num < sol_num) sol_num = num, sol_val = tmp; 			} 		}  		printf("%d\n",sol_val); 	}  	return 0; } 
//Author: Aman Choudhary #include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <cmath> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <climits> #include <map> #include <cassert> #define mod  1000000007 #define PHI 1000000006 #define ull unsigned long long #define ill long long int #define pii pair<int,int> #define pb(x) push_back(x) #define F(i,a,n) for(i=(a);i<(n);++i) #define FD(i,a,n) for(i=(a);i>=(n);--i) #define FE(it,x) for(it=x.begin();it!=x.end();++it) #define V(x) vector<x> #define S(x) scanf("%d",&x) #define S1(x) scanf("%llu",&x) #define dholu -9999999999999LL #define MAX 2200 using namespace std; int n,m,k; struct node {     int value;     int index; }; typedef struct node node; vector <struct node> cost; vector < vector <int> > s; int ind[10009]; int position[10009]; int ax[10009]; vector < set <int> > ss; vector <int> answer;  void print (vector <int> &s) {     int i,n=s.size();     F (i, 0, n) {         ax[i] = s[i];         //printf ("%d ", s[i]);     }     sort (ax, ax+n);     F (i, 0, n) {         printf ("%d ", ax[i]);     }     printf ("\n"); } bool operator<(struct node a, struct node b) {     if (a.value != b.value) {         return a.value>b.value;     }     return a.index<b.index; }  void dfs (int index, int flag) {     if (k == 0) {         return;     }     if (index == n) {         return;     }     if (flag == -1) {         answer.push_back (ind[index]);         dfs (index+1, 0);         if (k != 0) {             print (answer);             k--;         } else {             return;         }         answer.pop_back();         dfs (index+1, -1);         return;     }      int i;     bool ok = true;     F (i, 0, answer.size()) {         int xx = ind[index];         if (ss[xx].find (answer[i]) == ss[xx].end()) {             ok = false;             break;         }     }      if (ok) {         answer.push_back (ind[index]);         dfs (index+1, 0);         if (k != 0) {             print (answer);             k--;         } else {             return;         }         answer.pop_back ();     }     dfs (index+1, 0); }  int main() {    // freopen ("input.txt", "r", stdin);     int tt;     S (tt);      while (tt--) {         S (n);  S (m);  S (k);         int i;         cost.clear();       cost.resize (n);         F (i, 0, n) {             S (cost[i].value);             cost[i].index = i;         }          s.clear();          s.resize (n);         ss.clear();         ss.resize (n);          sort (cost.begin(), cost.end());          F (i, 0, cost.size()) {             position[cost[i].index] = i;             ind[i] = cost[i].index;         }          while (m--) {             int x,y;             S (x);  S (y);             if (position[x] > position[y]) {                 swap (x, y);             }             s[x].pb (y);             ss[y].insert (x);         }          F (i, 0, s.size()) {             sort (s[i].begin(), s[i].end());         }          answer.clear();         dfs (0, -1);         printf ("\n");     }       return 0; } 
#include<stdio.h> #include<string.h> #include<iostream> #include<algorithm> #include<map> using namespace std; typedef long long lld; #define maxn 2010 #define inf 0x7fffffff struct Edge { 	int v,next,s; }edge[1000010]; int head[maxn]; int pos; void insert(int x,int y,int s) { 	edge[pos].v=y; 	edge[pos].s=s; 	edge[pos].next=head[x]; 	head[x]=pos++; } int n,m; int dis[maxn]; int queue[maxn]; int rear,front; bool vis[maxn]; int ddd[maxn]; void spfa(int src) { 	rear=front=0; 	queue[front++]=src; 	for(int i=1;i<=n;i++) 		dis[i]=inf; 	dis[src]=0; 	memset(vis,false,sizeof(vis)); 	vis[src]=true; 	while(rear != front) 	{ 		int now=queue[rear++]; 		if(rear == maxn) 			rear=0; 		vis[now]=false; 		for(int i=head[now];i;i=edge[i].next) 		{ 			int v=edge[i].v; 			if(dis[now]+edge[i].s < dis[v]) 			{ 				dis[v]=dis[now]+edge[i].s; 				if(!vis[v]) 				{ 					vis[v]=true; 					queue[front++]=v; 					if(front == maxn) 						front=0; 				} 			} 		} 	} } void dfs(int now,int rt) { 	vis[now]=true; 	int mark=inf; 	for(int i=head[now];i;i=edge[i].next) 		if(!vis[edge[i].v]) 			mark=min(mark,edge[i].s); 	for(int i=head[now];i;i=edge[i].next) 		if(edge[i].s == mark) 		{ 			int v=edge[i].v; 			if(vis[v]) 				continue; 			if(ddd[now]+edge[i].s < ddd[v]) 			{ 				ddd[v]=ddd[now]+edge[i].s; 				dfs(v,rt); 			} 		} 	vis[now]=false; } int main() { 	scanf("%d %d",&n,&m); 	memset(head,0,sizeof(head)); 	pos=1; 	while(m--) 	{ 		int x,y,s; 		scanf("%d %d %d",&x,&y,&s); 		insert(x,y,s); 	} 	int ans=0; 	for(int i=1;i<=n;i++) 	{ 		spfa(i); 		for(int j=1;j<=n;j++) 			ddd[j]=inf; 		memset(vis,false,sizeof(vis)); 		ddd[i]=0; 		dfs(i,i); 		for(int j=1;j<=n;j++) 			if(dis[j] == ddd[j]) 				ans++; 	} 	printf("%d\n",ans); 	return 0; } 
#include <iostream> #include <algorithm> #include <vector> #include <string> #include <cstring> #include <sstream> #include <cstdlib> #include <bitset> #include <map> //#include <conio.h>  #define FOR(a, b) for (int i = a; i < b; i++) #define ALL(a) (a.begin(), a.end()) #define SORT(a) sort(ALL(a)) #define SORT_ARR(a, b) sort (a, b) using namespace std; int wt[100000], st[100000]; double d[100000];  void distToPoint(double s, int n) {     FOR(0, n) {         d[i] = (double)st[i] - s * (double)wt[i];     } }  bool possibleSpeed (double s, int n) {     distToPoint(s, n);     SORT_ARR(d, d + n);     FOR (0, n/2 + 1) {         if (d[i] + d[n - i - 1] < 0)             return false;     }     return true; }  int main() {     int n, i, j;     scanf("%d", &n);     for (i = 0; i < n; i++) {         scanf("%d %d", wt + i, st + i);         wt[i] += 10;     }      double high = (100.0 + 100.0) / (60.0 + 60.0);     double low = (50.0 + 50.0) / (110.0 + 110.0);      double mid = 0;     while (1e-8 <= high - low) {         mid = (low + high) / 2.0;         if (possibleSpeed(mid, n) == true) {             low = mid;         }         else {             high = mid;         }     }     printf("%.6lf", mid); //    getch();     return 0; } 
#include <cstdio>  using namespace std;  typedef unsigned long long ll; ll mod; ll pows[64];  int sz;  ll f(ll a, ll n, char cmd) { // calculates a^n ; a + a^2 + ... + a^n           if(n == 0) return 0;           if(n == 1) return a;            sz = 0;           while(n) pows[sz++] = n, n >>= 1;                       ll s, st;           s = st = a;                      for(int i=sz-1; i>0; i--) {                       s = (1 + st) * s % mod;                       st = st * st % mod;                       if(pows[i - 1] & 1) st = st * a % mod, s = (s + st) % mod;                        }                      if(cmd == 'p') return st;           return s;           }  ll n, t;  ll g(ll a, bool fl) {         if(t < !fl) return 0;                   ll ret, x;                    ret = f(a, a, 'p'),          x = f(a, mod, 'p'),          ret = ret * (1 + f(x, t - !fl, 's')) % mod;                    return ret;          }  ll cur, ans;      void solve() {      scanf("%llu%llu", &n, &mod);            t = n / mod,      n %= mod,      ans = 0;            for(int i=1; i<mod; i++)      cur = g(ll(i), i <= n),      ans = (ans + cur) % mod;            printf("%llu\n", ans);      }  int main() {     int t;     scanf("%d", &t);          while(t--) solve();         return 0;     }  
#include <cstdio> #include<iostream> #include <cstring> #include <queue> #include <algorithm> #include <limits> using namespace std; #define N 50010 int a[N],t[N<<2],w[210],c[210],s,n; void build(int p,int l,int r) { 	if(l==r) 	{ 		if(l<=n-1)t[p]=a[l]; 		else t[p]=0;return; 	} 	int m=(l+r)>>1; 	build(p<<1,l,m);build(p<<1|1,m+1,r); 	t[p]=t[p<<1]+t[p<<1|1]; } void update(int p,int l,int r,int x,int v) { 	t[p]+=v; 	if(l==r)return; 	int m=(l+r)>>1; 	if(x<=m)update(p<<1,l,m,x,v); 	else update(p<<1|1,m+1,r,x,v); } int qw; int query(int p,int l,int r,int s) { 	if(l==r) 	{ 		qw=l;return 0; 	} 	int m=(l+r)>>1; 	if(s>=t[p<<1])return t[p<<1]+query(p<<1|1,m+1,r,s-t[p<<1]); 	else return query(p<<1,l,m,s); } int main() { 	int T,i,j,k,m,l,M,ca=0; 	scanf("%d",&T); 	while(T--) 	{ 		printf("Case #%d:\n",++ca); 		scanf("%d%d",&M,&n);M++; 		for(i=0;i<n;i++) 		scanf("%d",&a[i]),a[i]++; 		s=1; 		while(s<=n)s*=2; 		build(1,0,s-1); 		memset(w,-1,sizeof(w)); 		w[0]=0;c[0]=0; 		int mu=0; 		while(1) 		{ 			char st; 			scanf(" %c",&st); 			if(st=='E')break; 			if(st=='I') 			{ 				scanf("%d",&k);k--; 				bool f=0; 				for(l=1;l<210;l++) 				{ 					if(w[l]<0||w[l]>=mu)f=1; 					if(f) 					{ 						c[l]=query(1,0,s-1,c[l-1]+M); 						//printf("%d\n",qw); 						w[l]=qw; 						mu=w[l-1]+1; 					} 					if(w[l]<0||w[l]>k) 					{ 						printf("%d\n",l);break; 					} 				} 			} 			else 			{ 				scanf("%d%d",&i,&j);i--,j++; 				update(1,0,s-1,i,j-a[i]); 				a[i]=j; 				mu=min(mu,i); 			} 		} 		puts(""); 	} }
#include<bits/stdc++.h> //#define DEBUG //#ifdef DEBUG //code to debug //#endif //#undef DEBUG using namespace std;  const int mod=(int)1e9+7,maxn=350,ln=17; #define F(i,p,n) for(int i=p;i<n;i++) #define I(i,p,q) for(int i=p;i>=q;i--) #define Ss(x) scanf("%s",x) #define S(x) scanf("%d",&x) #define Sl(x) scanf("%lld",&x) //#define getcx getchar_unlocked #define getcx getchar /*inline void S(int& n) {     n=0; int ch = getcx(); int sign = 1;     while(ch < '0' || ch > '9') { if(ch == '-') sign=-1; ch = getcx(); }     while(ch >= '0' && ch <= '9') { n = (n << 3) + (n << 1) + ch - '0', ch = getcx(); }     n = n * sign; }*/ #define Ps(x) printf("%d  ",x) #define P(x) printf("%d\n",x) typedef long long int LL; #define modulo(x,y,z) (x+y)<0?x+y+z:((x+y>=z)?x+y-z:x+y) #define Debug(x) cout << #x << "=" << x << endl #define Debugarr(x,n) cout<<"array "<<#x<<":"<<endl; F(ij,0,n) cout<<ij<<". "<<x[ij]<<endl; cout<<endl #define Debugarr2(x,m,n) cout<<"array "<<#x<<":"<<endl; F(ij,0,m) {F(jk,0,n) cout<<x[ij][jk]<<" "; cout<<endl;} cout<<endl #define pii pair<LL,int> #define Fi first #define Se second #define chk(x,n) (x[n>>5]&(1<<(n&31))) //unsigned int #define set(x,n) (x[n>>5]|=(1<<(n&31)))//32 bit const int shift=30,etf=mod-1;  const LL inf=(LL)1e18+1;  const double PI=(double)3.141592653589793238,EPSILON=1e-10;  int mat[maxn][maxn],dplr[maxn][maxn],dprl[maxn][maxn],dpud[maxn][maxn],dpdu[maxn][maxn];  int cnt[3000005]; LL grain[3000005];  int n,m,mx;  void calculate() {     int sum;     F(i,1,n+1)     {         F(j,1,m+1)         {             dplr[i][j]=mat[i][j]+dplr[i-1][j];         }     }     F(i,1,n+1)     {         F(j,1,m+1)         {             sum=dplr[i][j]-dplr[i-1][j];             F(k,2,min(i+1,m-j+2))             {                 sum+=dplr[i][j+k-1]-dplr[i-k][j+k-1];                 cnt[sum]++;                 //mx=max(mx,sum);                 //printf("sum=%d\n",sum);             }             sum=dplr[i][j]-dplr[i-1][j];             F(k,1,min(m-j+1,min(i,n-i+1)))             {                 sum+=dplr[i+k][j+k]-dplr[i-k-1][j+k];                 cnt[sum]++;                 //mx=max(mx,sum);                 //printf("sum=%d\n",sum);             }         }     }      F(i,1,n+1)     {         F(j,1,m+1)         {             dprl[i][j]=mat[i][j]+dprl[i-1][j];         }     }     F(i,1,n+1)     {         F(j,1,m+1)         {             sum=dprl[i][j]-dprl[i-1][j];             F(k,2,min(n-i+2,j+1))             {                 sum+=dprl[i+k-1][j-k+1]-dprl[i-1][j-k+1];                 cnt[sum]++;                 //mx=max(mx,sum);                 //printf("sum=%d\n",sum);             }             sum=dprl[i][j]-dprl[i-1][j];             F(k,1,min(j,min(i,n-i+1)))             {                 sum+=dprl[i+k][j-k]-dprl[i-k-1][j-k];                 cnt[sum]++;                 //mx=max(mx,sum);                 //printf("sum=%d\n",sum);             }         }     }      F(i,1,n+1)     {         F(j,1,m+1)         {             dpud[i][j]=mat[i][j]+dpud[i][j-1];         }     }     F(i,1,n+1)     {         F(j,1,m+1)         {             sum=dpud[i][j]-dpud[i][j-1];             F(k,2,min(n-i+2,m-j+2))             {                 sum+=dpud[i+k-1][j+k-1]-dpud[i+k-1][j-1];                 cnt[sum]++;                 //mx=max(mx,sum);                 //printf("sum=%d\n",sum);             }             sum=dpud[i][j]-dpud[i][j-1];             F(k,1,min(n-i+1,min(j,m-j+1)))             {                 sum+=dpud[i+k][j+k]-dpud[i+k][j-k-1];                 cnt[sum]++;                 //mx=max(mx,sum);                 //printf("sum=%d\n",sum);             }         }     }      F(i,1,n+1)     {         F(j,1,m+1)         {             dpdu[i][j]=mat[i][j]+dpdu[i][j-1];         }     }     F(i,1,n+1)     {         F(j,1,m+1)         {             //printf("i=%d j=%d:\n",i,j);              //printf("normal down to up:\n");             sum=dpdu[i][j]-dpdu[i][j-1];             F(k,2,min(i+1,j+1))             {                 sum+=dpdu[i-k+1][j]-dpdu[i-k+1][j-k];                 cnt[sum]++;                 //mx=max(mx,sum);                 //printf("sum=%d\n",sum);             }             //printf("down to up:\n");             sum=dpdu[i][j]-dpdu[i][j-1];             F(k,1,min(i,min(j,m-j+1)))             {                 sum+=dpdu[i-k][j+k]-dpdu[i-k][j-k-1];                 cnt[sum]++;                 //mx=max(mx,sum);                 //printf("sum=%d\n",sum);             }         }     } }  int bs(LL g) {     int p=0,q=mx,ans;     while(p!=q)     {         int mid=(p+q)/2;         if(grain[mid]<=g)         {             p=mid+1;         }         else         {             q=mid;         }     }     g-=grain[p-1];     ans=cnt[p-1]+g/p;     return ans; }  int main() {     int q;     cin>>n>>m>>q;     //m=n=335;     F(i,1,n+1)     {         F(j,1,m+1)         {             S(mat[i][j]);             mx+=mat[i][j];             //mat[i][j]=50;         }     }      calculate();      //Debugarr(cnt,7);     cnt[0]=0;      F(i,1,mx+1)     {         grain[i]=grain[i-1]+(LL)cnt[i]*i;         cnt[i]+=cnt[i-1];     }      while(q--)     {         LL g;         Sl(g);         if(g>=grain[mx])         {             P(cnt[mx]);         }         else         {             P(bs(g));         }     }      return 0; } 
#include <iostream> #include <set> #include <vector> #include <cstring> #define ll long long int using namespace std; vector<string> generate(vector<string> v) { 	vector<string> n; 	for(int i=0;i<v.size();i++) 	{ 		n.push_back("0"+ v[i]); 	} 	for(int i=v.size()-1 ; i>=0 ; i--) 	{ 		n.push_back("1"+ v[i]); 	} 	return n; }  int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		ll n,d,x;  		string temp; 		cin>>n>>d; 		for(int i=0;i<n;i++){cin>>x;(x==-1)?temp.push_back('0'):temp.push_back('1');} 		if(d<4){cout<<-2<<endl;continue;} 		vector<string> v; 		v.push_back("0");v.push_back("1"); 		for(int i=1;i<n ;i++) 		{ 			v=generate(v); 		} 		int startIndex; 		for(int i=0;i<v.size();i++) 		{ 			if(v[i].compare(temp)==0) 			{ 				startIndex= i; 			} 		} 		for(int i=startIndex; i<v.size();i++) 		{ 			for(int j=0;j<v[i].length();j++) 			{ 				int val = (v[i][j]=='0')?-1:1; 				cout<<val<<" "; 			} 			cout<<endl; 		} 		for(int i=0; i<startIndex;i++) 		{ 			for(int j=0;j<v[i].length();j++) 			{ 				int val = (v[i][j]=='0')?-1:1; 				cout<<val<<" "; 			} 			cout<<endl; 		} 	} 	return 0; }
/* 	Algorithm: 	Date: */ #include <iostream> #include <stdio.h> #include <stdlib.h> #include <math.h> #include <time.h> #include <string.h> #include <string> #include <queue> #include <deque> #include <stack> #include <set> #include <map> #include <algorithm> using namespace std;  typedef long long LL; typedef double DB;  #define PII pair<int,int> #define FI first #define SE second #define PB push_back #define MP make_pair  #define INF 0x7f7f7f7f #define MAXN 100005 #define mo 19101995  inline char _getchar() {     char ch;     for (ch = getchar(); ch <= 32; ch = getchar());     return ch; }  template <class T> inline void read(T&x) {     bool f = false; char ch;     for (ch = getchar(); ch <= 32; ch = getchar());     if (ch == '-') f = true, ch = getchar();     for (x = 0; ch > 32; ch = getchar()) x = x * 10 + ch - '0';     if (f) x = -x; }  template <class T> inline void read(T&x, T&y) {     read(x);     read(y); }  template <class T> inline void read(T&x, T&y, T&z) {     read(x);     read(y);     read(z); }  template <class T> inline void write(T x) {     if (x < 0) putchar('-'), x = -x;     if (x < 10)         putchar(x + '0');     else         write(x / 10), putchar(x % 10 + '0'); }  template <class T> inline void write_(T x) {     write(x);     putchar(' '); }  template <class T> inline void writeln(T x) {     write(x);     puts(""); }  template <class T> inline void writeln(T x, T y) {     write_(x);     writeln(y); }  template <class T> inline void writeln(T x, T y, T z) { 	write_(x);     write_(y);     writeln(z); }  //----------------I/O Template-------------------   int n, m; struct edge{ 	int loc, next; }e[MAXN << 1]; int h[MAXN], tot; void addedge(int x, int y) { 	e[tot].loc = y; e[tot].next = h[x]; h[x] = tot ++; 	e[tot].loc = x; e[tot].next = h[y]; h[y] = tot ++; }  LL dp[MAXN][30];//s[MAXN][30]; LL sl[MAXN], sr[MAXN]; vector <int> child; int chsize;   void dfs(int u, int fa) { 	for (int i = h[u]; ~i; i = e[i].next) 		if (e[i].loc != fa) 			dfs(e[i].loc, u); 	child.clear(); 	for (int i = h[u]; ~i; i = e[i].next) 		if (e[i].loc != fa) 			child.push_back(e[i].loc); 	chsize = child.size(); 	if (chsize == 0) 	{ 		for (int i = 0; i <= m; i ++) dp[u][i] = 1; 	} 	else { 		for (int j = 0; j <= m; j ++) 		{ 			sl[0] = 1; 			for (int i = 1; i <= chsize; i ++) sl[i] = sl[i - 1] * dp[child[i - 1]][j - 1] % mo; 			sr[chsize + 1] = 1; 			for (int i = chsize; i >= 1; i --) sr[i] = sr[i + 1] * dp[child[i - 1]][j - 1] % mo; 			for (int i = 1; i <= chsize; i ++) 				dp[u][j] = (dp[u][j] + sl[i - 1] * sr[i + 1] % mo * dp[child[i - 1]][j]) % mo;  		} 	} 	//s[u][0] = dp[u][0]; 	//for (int i = 1; i <= m; i ++) s[u][i] = s[u][i - 1] + dp[u][i]; }  int main() { #ifndef ONLINE_JUDGE 	freopen("input.txt","r",stdin);freopen("output.txt","w",stdout); #endif 	read(n); m = log2(n); 	memset(h, 255, sizeof(h)); 	for (int i = 1; i < n; i ++) 	{ 		int x, y;read(x, y); 		addedge(x, y); 	} 	dfs(1, 0); 	writeln(dp[1][m]); 	return 0; } 
#include <cstdio> #include <cstring> #include <climits> #include <cassert>  #define NAME_LENGTH 11 #define NUM_OF_ROOMS 500 #define TRIB 14000  int hash(const char *s, int mod) {     int i, h = 0;     for (i = 0; s[i]; i++)         h = (h*33 + (s[i] - (s[i] >= 'a' ? 'a' : 'A') + 1))%mod;      return h; }  inline int ts(int day, int hour, int min) {     return (day*24 + hour)*60 + min; }  int main() {     int nr, nv, cur_hour, cur_min, stay_for_hour, mr,         cur_ts, cur_day, min_probes, t, h, last_ts,         i, j, r, min_leave_at, acc;     char s[NAME_LENGTH];     int leave_at[NUM_OF_ROOMS], probes[NUM_OF_ROOMS];     int trib[TRIB] = {-1, 0, 1};      scanf("%d", &t);     while (t--)     {         scanf("%d %d", &nv, &nr);         for (i = 0; i < nr; i++)         {             leave_at[i] = 0;             probes[i] = -1;         }         cur_day = 0;         last_ts = -1;         acc = 0;          /*          * precompute the table 'probes'          */         j = 3;         for (i = r = 0; i < nr && j < TRIB - 1; i++)         {             while (probes[r] != -1 && j < TRIB - 1)             {                 j++;                 trib[j] = (trib[j-1] + trib[j-2] + trib[j-3]) % nr;                 r = (r + trib[j]) % nr;             }             if (j < TRIB - 1)             {                 probes[r] = j - 3;                 j++;                 trib[j] = (trib[j-1] + trib[j-2] + trib[j-3]) % nr;                 r = (r + trib[j]) % nr;             }         }          while (nv--)         {             scanf("%d %d %d %s", &cur_hour, &cur_min, &stay_for_hour, s);             cur_ts = ts(cur_day, cur_hour, cur_min);             if (last_ts > cur_ts)             {                 cur_ts += 24*60;                 ++cur_day;             }             last_ts = cur_ts;              h = (hash(s, nr) + acc) % nr;              min_probes = min_leave_at = INT_MAX;              for (r = 0; r < nr; r++)             {                 if (probes[(r + nr - h)%nr] >= 0) //r'th room is reachable from h                 {                     if (leave_at[r] <= cur_ts) //room is empty                     {                         assert(min_probes != probes[(r + nr - h)%nr]);                         if (min_probes > probes[(r + nr - h)%nr])                         {                             min_probes = probes[(r + nr - h)%nr];                             mr = r;                         }                     }                     else if (min_probes == INT_MAX)                     {                         if (leave_at[r] < min_leave_at)                             min_leave_at = leave_at[r];                     }                 }             }             if (min_probes == INT_MAX)             {                 printf("-%d\n", min_leave_at - cur_ts);                 acc = (acc + min_leave_at - cur_ts)%nr;             }             else             {                 leave_at[mr] = cur_ts + (stay_for_hour*60);                 printf("%d\n", min_probes);                 acc = (acc + min_probes)%nr;             }         }     }     return 0; }
/* author:jxy lang:C/C++ university:China,Xidian University **If you need to reprint,please indicate the source** */ #include <iostream> #include <cstdio> #include <cstdlib> #include <cstring> #define Maxn 314160 using namespace std; inline void inp( int &n )//fast input function { 	n=0; 	int ch=getchar(),sign=1; 	while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getchar();} 	while( ch >= '0' && ch <= '9' )  		n=(n<<3)+(n<<1)+ ch-'0', ch=getchar(); 	n=n*sign; 	return; } char s[100]; int k=0; inline void out(int &a) {     if(a==0){putchar('0');return;}     while(a)         s[k++]=a%10+'0',a/=10;     while(k)         putchar(s[--k]);     return; } int R[Maxn];//房间客人 int room[Maxn],start[Maxn]; int n,m; int main() {     int T,i;     scanf("%d",&T);     while(T--)     {         inp(n);inp(m);         memset(R,0,n*sizeof(R[0]));         int time,inc,now=0,ll=n-1;         for(i=1;i<=m;i++)         {             inp(time);             inp(inc);             start[i]=time;             if(n!=now)//没住满，依次安排             {                 room[i]=now-inc;                 R[now++]=i;             }             else//已住满，赶走之前的人             {                 if(inc==n){room[i]=0;continue;}//没房间                 room[i]=ll-inc;                 start[R[ll]]=time-start[R[ll]];                 R[ll]=i;             }         }         ++time;         for(i=0;i<n;i++)             start[R[i]]=time-start[R[i]];         for(i=1;i<=m;i++)         {             out(room[i]);             putchar(' ');             out(start[i]);             putchar('\n');         }     } } 
#include <cstdio> #include <iostream> #include <vector>  using namespace std;  #define maxn 200000  int head[maxn], x, n, sz[maxn], q, v, par[maxn], p[maxn], pos[maxn], h[maxn], a[maxn], last, tt, val; vector <int> vec[maxn], g[maxn]; vector <pair <int, int> > t[maxn];  void dfs(int v, int p = 0) { 	sz[v] = 1; 	if (!p) 		h[v] = 0; 	else		 		h[v] = h[p] + 1;  	for (int i = 0; i < g[v].size(); ++i) 	{ 		int to = g[v][i];  		if (to != p) 		{ 			dfs(to, v); 			sz[v] += sz[to]; 		}			 	} }  void calc(int v, int path, int pp = 0) { 	par[v] = pp; 	vec[path].push_back(v); 	pos[v] = vec[path].size(); 	p[v] = path; 	if (pos[v] == 1) 		head[path] = v;  	for (int i = 0; i < g[v].size(); ++i) 	{ 		int to = g[v][i];  		if (to != pp) 		{ 			if (2 * sz[to] >= sz[v]) 				calc(to, path, v); 			else 				calc(to, ++last, v); 		} 	} }  void recalc(int b, int v) { 	if (t[b][v + v].first == t[b][v + v + 1].first) 	{ 		t[b][v].first = t[b][v + v].first; 		t[b][v].second = t[b][v + v].second + t[b][v + v + 1].second; 	} 	else 	{ 		if (t[b][v + v].first > t[b][v + v + 1].first) 			t[b][v] = t[b][v + v]; 		else 			t[b][v] = t[b][v + v + 1]; 	} }  void build(int b, int tl, int tr, int v) { 	if (tl == tr) 	{ 		t[b][v].first = a[vec[b][tl - 1]] - h[vec[b][tl - 1]]; 		t[b][v].second = 1; 	}		 	else 	{ 		int td = (tl + tr) >> 1;  		build(b, tl, td, v + v); 		build(b, td + 1, tr, v + v + 1);  		recalc(b, v); 	} }  void update(int b, int tl, int tr, int v, int pos, int val) { 	if (tl == tr) 	{ 		t[b][v].first = val - h[vec[b][tl - 1]]; 		t[b][v].second = 1; 	} 	else 	{ 		int td = (tl + tr) >> 1;  		if (pos <= td) 			update(b, tl, td, v + v, pos, val); 		else 			update(b, td + 1, tr, v + v + 1, pos, val);  		recalc(b, v);			 	} }  pair <int, int> get(int b, int tl, int tr, int v, int l, int r) { 	if (l > r) 		return make_pair(-int(1e9), 0);  	if (tl == l && tr == r) 		return t[b][v];  	int td = (tl + tr) >> 1;  	pair <int, int> lf = get(b, tl, td, v + v, l, min(r, td)); 	pair <int, int> rg = get(b, td + 1, tr, v + v + 1, max(l, td + 1), r);  	if (lf.first == rg.first) 		return make_pair(lf.first, lf.second + rg.second);  	if (lf.first > rg.first) 		return lf; 	return rg;		 }  int main() { //	freopen("in", "r", stdin);  	scanf("%d%d", &n, &q);  	for (int i = 1; i <= n; ++i) 		scanf("%d", &a[i]);  	for (int i = 2; i <= n; ++i) 	{ 		scanf("%d", &x); 		g[x].push_back(i); 	}  	dfs(1); 	calc(1, ++last);  	for (int i = 1; i <= last; ++i) 	{ 		t[i].resize(4 * vec[i].size()); 		build(i, 1, vec[i].size(), 1); 	}  	while (q--) 	{ 		scanf("%d%d", &tt, &v);  		if (tt == 0) 		{ 			scanf("%d", &val); 			update(p[v], 1, vec[p[v]].size(), 1, pos[v], val); 		} 		else 		{ 			int cur_path = p[v], curmx = -int(1e9), anscnt = 0, c = h[v]; 			while (v) 			{ 				pair <int, int> mx = get(cur_path, 1, vec[cur_path].size(), 1, 1, pos[v]);  				if (mx.first > curmx) 				{ 					curmx = mx.first; 					anscnt = mx.second; 				} 				else 					if (mx.first == curmx) 						anscnt += mx.second;  				v = par[head[cur_path]]; 				cur_path = p[v]; 			}  			printf("%d %d\n", curmx + c, anscnt); 		} 	} } 
#include <cstdio> #include <iostream> #include <algorithm> #include <cstring> #include <vector> #include <set> #include <map> #include <cmath> #include <list> #include <ctime> #include <sstream> #include <queue> #include <stack> #include <bitset> using namespace std; typedef vector<int> VI; typedef pair<int,int> PII; typedef long long LL; #define FOR(x, b, e) for(int x=b; x<=(e); ++x) #define FORD(x, b, e) for(int x=b; x>=(e); --x) #define REP(x, n) for(int x=0; x<(n); ++x) #define VAR(v,n) typeof(n) v=(n) #define ALL(c) c.begin(),c.end() #define SIZE(x) (int)x.size() #define FOREACH(i,c) for(VAR(i,(c).begin());i!=(c).end();++i) #define PB push_back #define ST first #define ND second #define mp(x,y) make_pair(x,y) #define DEBUG 1 #define debug(x) {if (DEBUG)cerr <<#x <<" = " <<x <<endl; } #define debugv(x) {if (DEBUG) {cerr <<#x <<" = "; FOREACH(it, (x)) cerr <<*it <<", "; cout <<endl; }} typedef short int sint;  const int N = 101010; const LL mod = 1000000007; VI za[N]; int deg[N]; LL F[N][2]; LL pom[N][2]; bool done[N]; int n;  void testcase() { 	scanf("%d", &n); 	FOR(i, 1, n) { 		int c; 		scanf("%d", &c); 		++deg[c]; 		za[i].PB(c); 		F[i][0] = F[i][1] = 1; 	} 	queue<int> Q; 	FOR(i, 1, n) { 		if (deg[i] == 0) { 			Q.push(i); 			done[i] = true; 		} 	} 	while (!Q.empty()) { 		int front = Q.front(); Q.pop(); 		FOREACH(p, za[front]) { 			if (!done[*p]) { 				--deg[*p]; 				F[*p][1] = (F[front][0] * F[*p][1]) % mod; 				F[*p][0] = ((F[front][1] + F[front][0]) * F[*p][0]) % mod; 				if (deg[*p] == 0) { 					Q.push(*p); 					done[*p] = true; 				} 			} 		} 	} 	LL res = 1; 	// pozostaly nam cykle 	FOR(i, 1, n) if (!done[i]) { 		// jakis cykl 		VI zbior; 		zbior.PB(i); 		done[i] = true; 		int curr = za[i][0]; 		while (curr != i) { 			zbior.PB(curr); 			done[curr] = true; 			curr = za[curr][0]; 		} 		//debugv(zbior); 		//printf("biore start\n"); 		LL temp = 0; 		pom[i][0] = 0; pom[i][1] = F[i][1]; 		FOR(q, 1, SIZE(zbior)-1) { 			curr = zbior[q]; 			pom[curr][0] = ((pom[zbior[q-1]][0] + pom[zbior[q-1]][1]) * F[curr][0] ) % mod; 			if (q < SIZE(zbior)-1)pom[curr][1] = ((pom[zbior[q-1]][0]) * F[curr][1] ) % mod; 			else pom[curr][1] = 0; 			//printf("%d[0] = %lld, %d[1] = %lld\n", curr, pom[curr][0], curr, pom[curr][1]); 		} 		temp = ( (pom[zbior.back()][0] + pom[zbior.back()][1])) % mod; 		//printf("nie biore\n"); 		pom[i][0] = F[i][0]; pom[i][1] = 0; 		FOR(q, 1, SIZE(zbior)-1) { 			curr = zbior[q]; 			pom[curr][0] = ((pom[zbior[q-1]][0] + pom[zbior[q-1]][1]) * F[curr][0] ) % mod; 			pom[curr][1] = ((pom[zbior[q-1]][0]) * F[curr][1] ) % mod; 			//printf("%d[0] = %lld, %d[1] = %lld\n", curr, pom[curr][0], curr, pom[curr][1]); 		} 		temp = (temp + (pom[zbior.back()][0] + pom[zbior.back()][1])) % mod; 		res = (res * temp) % mod; 	} 	FOR(i, 1, n) if (SIZE(za[i]) == 0) res = (res * (F[i][0] + F[i][1])) % mod; 	printf("%lld\n", res); 	FOR(i, 1, n) { 		za[i].clear(); 		done[i] = false; 		deg[i] = 0; 	} }  int main(){ 	int t; 	scanf("%d", &t); 	while (t--) { 		testcase(); 	} }
/*   * File:   SudokuX  *  * Problem code :    J1  *  * Result :    Not_Submitted_Yet  *  * Created on May 10, 2012  */  #include <iostream> #include <stdio.h> #include <string> #include <vector> #include <algorithm> #include <memory.h> #include <cstdlib>  using namespace std;  bool c[9][9]; bool r[9][9]; bool s[9][9]; bool l[9][2];  int T[9][9];  inline void setNumber(int n, int i, int j, int v, bool b) {     s[n][v] = r[n][i] = c[n][j] = b;     if (j == i) l[n][0] = b;     if (i + j == 8) l[n][1] = b; }  inline void setNumber2(int n, int i, int j, int v, bool b) {     s[n][v] = r[n][i] = c[n][j] = b; }  bool Try(int j, int n) {      if (c[n - 1][j]) {         if (j == 8 && n == 9)             return true;         return (j != 8 ? Try(j + 1, n) : Try(0, n + 1));     }     bool Finish = false;     for (int i = 0; i < 9 && !Finish; i++) {         Finish = false;         int v = i / 3 + 3 * (j / 3);         if (s[n - 1][v]) {             i += 2;             continue;         }         if (!T[i][j] && !r[n - 1][i] && !c[n - 1][j]                 && (j == i ? !l[n - 1][0] : true) && (j + i == 8 ? !l[n - 1][1] : true)) {             T[i][j] = n;             setNumber(n - 1, i, j, v, true);             if (j == 8 && n == 9)                 return true;             Finish = (j != 8 ? Try(j + 1, n) : Try(0, n + 1));             if (!Finish) {                 T[i][j] = 0;                 setNumber(n - 1, i, j, v, false);             } else return true;         }     }     return Finish; }  bool fillRestDiagonal(int j, int n) {     if (c[n - 1][j]) {         if (j == 8 && n == 9)             return true;         return (j != 8 ? fillRestDiagonal(j + 1, n) : fillRestDiagonal(0, n + 1));     }     bool Finish = false;     for (int i = 0; i < 9 && !Finish; i++) {         Finish = false;         int v = i / 3 + 3 * (j / 3);         if (s[n - 1][v]) {             i += 2;             continue;         }         if (!T[i][j] && !r[n - 1][i] && !c[n - 1][j]) {             T[i][j] = n;             setNumber(n - 1, i, j, v, true);             if (j == 8 && n == 9)                 return true;             Finish = (j != 8 ? fillRestDiagonal(j + 1, n) : fillRestDiagonal(0, n + 1));             if (!Finish) {                 T[i][j] = 0;                 setNumber(n - 1, i, j, v, false);             } else return true;         }     }     return Finish; }  bool fillRest(int i, int j) {     if (i == 9)         return true;     if (j == 9)         return fillRest(i + 1, 0);     if (T[i][j])         return fillRest(i, j + 1);     int v = i / 3 + 3 * (j / 3);     bool Finish = false;     for (int n = 1; n <= 9 && !Finish; n++) {         if (!s[n - 1][v] && !r[n - 1][i] && !c[n - 1][j]) {             T[i][j] = n;             setNumber2(n - 1, i, j, v, true);             Finish = fillRest(i, j + 1);             if (!Finish) {                 T[i][j] = 0;                 setNumber2(n - 1, i, j, v, false);             } else return true;         }     }     return Finish; }  bool fillSecondDiagonal(int j) {     if (j == 9) {         return fillRest(0, 0);         return fillRestDiagonal(0, 1);     }     int i = 8 - j;     if (T[i][j])         return fillSecondDiagonal(j + 1);     int v = (i / 3) + 3 * (j / 3);     bool Finish = false;     for (int n = 1; n <= 9 && !Finish; n++) {         if (!l[n - 1][1] && !r[n - 1][i] && !c[n - 1][j] && !s[n - 1][v]                 && (j == 4 ? !l[n - 1][0] : true)) {             T[i][j] = n;             setNumber(n - 1, i, j, v, true);             Finish = fillSecondDiagonal(j + 1);             if (!Finish) {                 T[i][j] = 0;                 setNumber(n - 1, i, j, v, false);             } else return true;         }     }     return Finish; }  bool fillFirstDiagonal(int j) {     if (j == 9) {         return fillSecondDiagonal(0);     }     if (T[j][j])         return fillFirstDiagonal(j + 1);     int v = (j / 3) << 2;     bool Finish = false;     for (int n = 1; n <= 9 && !Finish; n++) {         if (!l[n - 1][0] && !r[n - 1][j] && !c[n - 1][j] && !s[n - 1][v]                 && (j == 4 ? !l[n - 1][1] : true)) {             T[j][j] = n;             setNumber(n - 1, j, j, v, true);             Finish = fillFirstDiagonal(j + 1);             if (!Finish) {                 T[j][j] = 0;                 setNumber(n - 1, j, j, v, false);             } else return true;         }     }     return Finish; }  int main() {     int tc, n;     cin >> tc;     while (tc--) {         memset(T, 0, sizeof (T));         memset(r, 0, sizeof (r));         memset(c, 0, sizeof (c));         memset(s, 0, sizeof (s));         memset(l, 0, sizeof (l));          char s[11];         for (int i = 0; i < 9; i++) {             cin >> s;             for (int j = 0; j < 9; j++) {                 if (s[j] != '.') {                     n = s[j] - '0';                     int v = i / 3 + 3 * (j / 3);                     T[i][j] = n;                     setNumber(n - 1, i, j, v, true);                 }             }         }         fillFirstDiagonal(0);          for (int i = 0; i < 9; i++, printf("\n"))             for (int j = 0; j < 9; j++)                 printf("%c", (char) (T[i][j] + '0'));          printf("\n");     }      return 0; } 
#include<iostream> #include<string> using namespace std; #define REP(i,b) for(int i=0;i<b;i++) #define ll long long int ll L[1005][1005]; ll D[1005][1005]; #define mod 23102009 int main() { string A,B; int t; char X[1005],Y[1005]; cin>>t; while(t--) { cin>>A>>B; //cin>>B; int m=A.size();int n=B.size(); REP(i,m) X[i+1]=A[i]; REP(j,n) Y[j+1]=B[j];  REP(i,m+1) L[i][0]=0; REP(j,n+1) L[0][j]=0; for(int i=1;i<=m;i++) { for(int j=1;j<=n;j++) { if(X[i]==Y[j]) L[i][j]=L[i-1][j-1]+1; else L[i][j]=max(L[i-1][j],L[i][j-1]);  } }  REP(j,n+1) { REP(i,m+1) { if(i==0 || j==0) D[i][j]=1; else { D[i][j]=0; if(X[i]==Y[j])  D[i][j]=D[i-1][j-1]; // Number of distinct LCS of D[i][j] is same as the no of distinct LCS from [i-1,j-1] else  { if(L[i-1][j]>=L[i][j-1])  D[i][j]=(D[i][j]+D[i-1][j])%mod;   if(L[i][j-1]>=L[i-1][j])  D[i][j]=(D[i][j]+D[i][j-1])%mod;   if(L[i-1][j-1]==L[i][j]) D[i][j]=(D[i][j]-D[i-1][j-1])%mod; //if(D[i][j]<0) //D[i][j]+=23102009;// We have added twice,so subtract once  } } } } cout<<L[m][n]<<" "<<(D[m][n]+mod)%mod<<endl; } }
#include<stdio.h> #define getcx getchar_unlocked int t,n,k; int x,y; int b[500][500]; //int c[500]; int d[500];     //int e[500]; int ro,co; int x1;  inline void inp( int &u )   {     /*u=0;     int ch=getcx();//int sign=1;    // while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )             u = (u<<3)+(u<<1) + ch-'0', ch=getcx();    // n=n*sign;*/        scanf("%d",&u);   }  bool can_attack(int r,int c) {        for(int i=c-1;i>=0;i--)       {           if(b[r][i]==-1)           break;           if(b[r][i]==1)           return true;       }              ro=r-1;       co=c-1;       while(ro>=0 && co>=0)       {            if(b[ro][co]==-1)            break;            if(b[ro][co]==1)            return true;            ro--;            co--;       }    //   printf("%d\n",att);       ro=r+1;       co=c-1;       while(ro<n && co>=0)       {            if(b[ro][co]==-1)            break;            if(b[ro][co]==1)            return true;            ro++;            co--;       }       return false; }  bool f(int c) {      //printf("%d\n",r);      for(int i=0;i<n;i++)      {                           if(b[i][c]==-1)              continue;             // printf("%d %d\n",r,i);              if(!can_attack(i,c))              {           //   printf("in %d %d\n",r,i);                   b[i][c]=1;                   d[c]=i;                   //c[i]=1;                   if(c==n-1)                   return true;                   if(f(c+1))                   return true;                   b[i][c]=0;                   d[c]=0;                  //c[i]=0;              }      }      return false; }  int main() {     inp(t);     for(int i=0;i<t;i++)     {             inp(n);             inp(k);             for(int i=0;i<n;i++)             {                    // c[i]=0;                          for(int j=0;j<n;j++)                     {                             b[i][j]=0;                     }             }             for(int i=0;i<k;i++)             {                    // scanf("%d%d",&x,&y);                    inp(x);                    inp(y);                     b[x-1][y-1]=-1;                    // e[y-1]=1;             }            // if(!f(0))            // printf("-1\n");            f(0);             for(int i=0;i<n-1;i++)             {                     printf("%d ",1+d[i]);             }             printf("%d\n",1+d[n-1]);                          }     //scanf("%d",&n);     return 0; } 
#include<bits/stdc++.h> using namespace std;  typedef pair<int,int> II; typedef vector< II > VII; typedef vector<int> VI; typedef vector< VI > VVI; typedef long long int ll;  #define PB push_back #define MP make_pair #define F first #define S second #define SZ(a) (int)(a.size()) #define ALL(a) a.begin(),a.end() #define SET(a,b) memset(a,b,sizeof(a))  #define si(n) scanf("%d",&n) #define dout(n) printf("%d\n",n) #define sll(n) scanf("%lld",&n) #define lldout(n) printf("%lld\n",n) #define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)  #define TRACE  #ifdef TRACE #define trace(...) __f(#__VA_ARGS__,__VA_ARGS__) /*template <typename Arg1> void __f(const char * name, Arg1&& arg1){     cerr << name << " : " << arg1 << std::endl; } template <typename Arg1, typename... Args> void __f(const char* names, Arg1&& arg1, Args&&... args){     const char* comma = strchr(names + 1,',');cerr.write(names,comma - names) << " : " << arg1<<" | ";__f(comma+1,args...); }*/ #else #define trace(...) #endif int max(int p,int q) {     return (p>q)?p:q; } int min(int p,int q) {     return (p<q)?p:q; }  int find(char str) {     if(str-'a'<0)     {         return str-'A';     }     else     {         return str-'a'+26;     } }  int par[505][2505]; int rank[505][2505]; int vol[505][2506];  int find_set(II cur) {     if(par[cur.F][cur.S]==cur.F*10000+cur.S)     {         return cur.F*10000+cur.S;     }     return par[cur.F][cur.S]=find_set(MP(par[cur.F][cur.S]/10000,par[cur.F][cur.S]%10000)); }  void find_union(int f1,int f2,int s1,int s2) {     int tmp11=find_set(MP(f1,f2));     int tmp12=find_set(MP(s1,s2));     II tmp1;     II tmp2;     tmp1=MP(tmp11/10000,tmp11%10000);     tmp2=MP(tmp12/10000,tmp12%10000);     int rt1,rt2;     if(tmp1.F!=tmp2.F || tmp1.S!=tmp2.S)     {         rt1=rank[tmp1.F][tmp1.S];         rt2=rank[tmp2.F][tmp2.S];         if(rt1>rt2)         {             par[tmp2.F][tmp2.S]=tmp1.F*10000+tmp1.S;         }         else if(rt1<rt2)         {             par[tmp1.F][tmp1.S]=tmp2.F*10000+tmp2.S;         }         else if(rt1==rt2)         {             par[tmp1.F][tmp1.S]=tmp2.F*10000+tmp2.S;             rank[tmp2.F][tmp2.S]++;         }         vol[tmp1.F][tmp1.S]=vol[tmp1.F][tmp1.S]+vol[tmp2.F][tmp2.S];         vol[tmp2.F][tmp2.S]=vol[tmp1.F][tmp1.S];     } }  void change(II cur,int t) {     int tmp1=find_set(cur);     II tmp=MP(tmp1/10000,tmp1%10000);     vol[tmp.F][tmp.S]=vol[tmp.F][tmp.S]+t; }  int light(II cur1,II cur2) {     int cur11=find_set(cur1);     int cur12=find_set(cur2);     cur1=MP(cur11/10000,cur11%10000);     cur2=MP(cur12/10000,cur12%10000);     if((vol[cur1.F][cur1.S]>0 && vol[cur2.F][cur2.S]==0) || (vol[cur2.F][cur2.S]>0 && vol[cur1.F][cur1.S]==0))     {         return 1;     }     else     {         return 0;     } }  int main() {     int n,f1,f2,s1,s2,r,c,ans,i,j;     char str[108];     si(n);     si(r);     si(c);     for(i=0;i<r;i++)     {         for(j=1;j<=c;j++)         {             par[i][j]=i*10000+j;         }     }     while(n--)     {         scanf("%s",str);         if(str[0]=='W')         {             f2=find(str[2])+find(str[1])*52;             f1=find(str[4])+find(str[3])*52;             f1=(f1-1)/5;             s2=find(str[6])+find(str[5])*52;             s1=find(str[8])+find(str[7])*52;             s1=(s1-1)/5;            // printf("%d %d %d %d\n",f1,f2,s1,s2);             find_union(f1,f2,s1,s2);         }         else if(str[0]=='V')         {             f2=find(str[2])+find(str[1])*52;             f1=find(str[4])+find(str[3])*52;             f1=(f1-1)/5;            // printf("%d %d\n",f1,f2);             change(MP(f1,f2),1);         }         else if(str[0]=='R')         {             f2=find(str[2])+find(str[1])*52;             f1=find(str[4])+find(str[3])*52;             f1=(f1-1)/5;            // printf("%d %d\n",f1,f2);             change(MP(f1,f2),-1);         }         else if(str[0]=='L')         {             f2=find(str[2])+find(str[1])*52;             f1=find(str[4])+find(str[3])*52;             f1=(f1-1)/5;             s2=find(str[6])+find(str[5])*52;             s1=find(str[8])+find(str[7])*52;             s1=(s1-1)/5;          //   printf("%d %d %d %d\n",f1,f2,s1,s2);             ans=light(MP(f1,f2),MP(s1,s2));             if(ans==1)             {                 printf("ON\n");             }             else             {                  printf("OFF\n");             }         }     }     return 0; }  
/* author : Mukesh Kumar Yadav    Problem:      */ #include<algorithm> #include<iostream> #include<cstring> #include<cstdlib> #include<climits> #include<fstream> #include<cctype> #include <bitset> #include<cstdio> #include<string> #include<vector> #include<queue> #include<stack> #include<cmath> #include<map> #include<set> using namespace std;   #define df(i,a,b) for(typeof(b) i=a;i>=b;i--) #define f(i,a,b) for(typeof(b) i=a;i<=b;i++) #define fill(x,a) memset(x,a,sizeof(x)) #define Clear(x) memset(x,0,sizeof(x)) #define inf 2147000000 #define pb push_back #define mp make_pair #define Y second #define X first   const double pi     =   acos(-1.0); const double eps    =   1e-8;   typedef unsigned long long int ull; typedef long long int ll; typedef vector<string> VS; typedef pair<int,int> ii; typedef vector<int> VI; #define mod 1000000007   int N; ll V,P[101],Q[101],A[2],B[2],C[2],M[2],L[101];   ll ppower(ll a, ll b){ 	if(b==1) return a%mod; 	if(b==0) return 1; 	if(a==0 || a==1) return a; 	ll c = ppower(a,b/2)%mod; 	if(b%2) return (((c*c)%mod)*a)%mod; 	else return ((c*c)%mod);  }   int main() {   //	freopen("input.txt","r",stdin); 	int t; 	scanf("%d", &t); 	while(t--){ 		scanf("%lld %d",&V, &N); 			scanf("%lld %lld",&P[0] , &P[1]); 			scanf("%lld %lld",&A[0] , &B[0]) ; 		 	scanf("%lld %lld",&C[0] , &M[0]); 			 			 			scanf("%lld %lld",&Q[0] , &Q[1]); 			scanf("%lld %lld",&A[1] , &B[1]) ; 		 	scanf("%lld %lld",&C[1] , &M[1]); 		 	 		for(int i=2; i<N; i++){ 			P[i]=((((A[0]*A[0])%M[0])*P[i-1])%M[0]+(B[0]*P[i-2])%M[0]+C[0])%(M[0]); 			Q[i]=((((A[1]*A[1])%M[1])*Q[i-1])%M[1]+(B[1]*Q[i-2])%M[1]+C[1])%(M[1]); 		} 		ll ans = 1; 		bool flag = false; 		ll LD=1; 		for(int i=0; i<N; i++){ 			L[i] = (P[i]*M[1]+Q[i]+1); 			LD *= ((L[i]-1)%(mod-1)); 			LD %= (mod-1); 			if(L[i] == 1) { 				flag = true; 				break; 			} 		} 		 		if(!flag) 		{ 		if((V%mod) == 0 && LD == 0) 		{ 			cout << "0" << endl; 			continue; 			 		} 		ans = ppower(V%mod, LD);	 		} 		else 		{ 			ans = 1; 		}	 		printf("%lld\n",ans); 	} 	   	return 0; } 
#include <iostream> #include <iomanip> #include <vector> #include <algorithm> #include <cmath> #include <cstring> #include <numeric> #include <map> #include <cassert> #include <queue> #include <sstream> #include <set> using namespace std;  //BEGIN_CODETEMPLATE //END_CODETEMPLATE  char maze[105][105]; bool visited[105][105][105];  struct State { 	int i; 	int j; 	int sum; };  int main() { 	int t; 	cin >> t;  	while(t--) 	{ 		int M; 		int N;  		cin >> M >> N;  		memset(visited, false, sizeof(visited));  		State init; 		init.sum = 0;  		for(int i=0 ; i<=M ; i++) 			for(int j=0 ; j<=N ; j++) 			{ 				cin >> maze[i][j]; 				 				if(maze[i][j] == '*') 				{ 					init.i = i; 					init.j = j; 				} 			}  		int X; 		cin >> X;  		queue<State> Q; 		int cnt = 0;  		Q.push(init); 		visited[init.i][init.j][0] = true;  		bool found = false;  		while(Q.size()) 		{ 			int oldsize = Q.size();  			while(oldsize--) 			{ 				State &f = Q.front();  				if(f.sum == X) 				{ 					cout << cnt << endl; 					found = true; 					goto out; 				}  				if(f.sum < X) 				{ 					State next;  					for(int di=-1 ; di<=1 ; di++) 						for(int dj=-1 ; dj<=1 ; dj++) 							if((di!=0 && dj==0) || (di==0 && dj!=0)) 							{ 								int ni = f.i + di; 								int nj = f.j + dj;  								if(ni>=0 && ni<=M && nj>=0 && nj<=N) 								{ 									char c = maze[ni][nj];  									if(c == '#') continue;  									next.i = ni; 									next.j = nj; 									next.sum = f.sum;  									if(c >= '0' && c <= '9') 										next.sum += c - '0';  									if(!visited[next.i][next.j][next.sum]) 									{ 										Q.push(next); 										visited[next.i][next.j][next.sum] = true; 									} 								} 							} 				}  				Q.pop(); 			}  			cnt++; 		}  out: 		if(!found) cout << -1 << endl; 	}  	return 0; }
#include <cstdio> #include <cstring> #include <algorithm> #include <iostream> #include <climits> #include <numeric> #include <vector> #include <cmath> using namespace std; #define ll long long #define mp make_pair #define pb push_back #define fi first #define se second #define rep(i,n) for(int i=0;i<n;i++) #define all(a)  a.begin(),a.end() #define ESP (1e-9) #define BUFSIZE (10000) char inputbuffer[BUFSIZE]; char *ioptr=inputbuffer+BUFSIZE,*ioend=inputbuffer+BUFSIZE; int input_eof=0; #define getchar() ({if (ioptr >= ioend) init_input(); *ioptr++;}) #define eof() (ioptr>=ioend && input_eof) #define eoln() ({if(ioptr >= ioend) init_input(); *ioptr == '\n';}) void init_input(){ 	if (input_eof) return; 	int existing = BUFSIZE - (ioend - inputbuffer); 	memcpy(inputbuffer, ioend, existing); 	int wanted = ioend - inputbuffer; 	int count=fread(inputbuffer + existing, 1, wanted, stdin); 	if (count < wanted)input_eof = 1; 	ioend = inputbuffer + BUFSIZE - (wanted - count); 	while (*--ioend > ' '); 	ioend++; 	ioptr=inputbuffer; } inline void non_whitespace(){ 	for(;;){ 		if(ioptr>=ioend)init_input(); 		if(*ioptr>' ')return; 		ioptr++; 	} } inline int getint(){ 	non_whitespace(); 	int neg=0; 	if(*ioptr=='-'){ 		ioptr++; 		neg=1; 	} 	int n=0; 	while(*ioptr>' ') 		n=(n<<3)+(n<<1)+*ioptr++-'0'; 	ioptr++; 	if(neg) 		n=-n; 	return n; } #define N 100010 #define inf 1000000007 pair<int,pair<int,int> >q[N]; pair<int,int>s[N]; vector<int>inv[N]; int sz[N],ans[N],tr[N],v[N],n; void update(int x,int v) {  while(x<=n)  {   tr[x]+=v;x+=x&-x;  } } int query(int x) {  int ans=0;  while(x>0)  {   ans+=tr[x];x-=x&-x;  }  return ans; } int main() { 	//freopen("in.txt","r",stdin); 	int T,i,j,m,l,k,x,y,K,r; 	while(~scanf("%d%d",&n,&K)) 	{K++; 	 memset(tr,0,sizeof(tr)); 	 for(i=0;i<n;i++) 	 { 	  j=getint(); 	  s[i]=mp(j,i+1); 	 } 	 sort(s,s+n);k=0; 	 for(i=0;i<n;i++) 	 { 	  if(i&&s[i].fi!=s[i-1].fi)k++; 	  v[s[i].se]=k; 	 } 	 r=getint(); 	 for(i=0;i<r;i++) 	 { 	  x=getint(),y=getint(); 	  q[i]=mp(y+1,mp(x+1,i)); 	 } 	 sort(q,q+r);int tot=0;j=0; 	 for(i=1;i<=n;i++) 	 { 	  	k=v[i]; 	  	int p=sz[k]; 	  	if(p>=K)update(inv[k][p-K],-1); 	  	inv[k].pb(i); 	  	p=++sz[k]; 	  	if(p==K)tot++; 	  	if(p>=K)update(inv[k][p-K],1); 	  	while(j<r&&q[j].fi==i) 	  	ans[q[j].se.se]=tot-query(q[j++].se.fi-1); 	 } 	 for(i=0;i<r;i++) 	 printf("%d\n",ans[i]); 	} 	return 0; } 
#include <bits/stdc++.h> using namespace std; vector<pair<int,int> >qu; int n; int kn[8][2]={1,2,1,-2,-1,2,-1,-2,2,1,-2,1,2,-1,-2,-1}; int brd[1001][1001]; int is_safe(int x,int y){   int m=qu.size();   for(int i=0;i<m;i++){     int dx=x-qu[i].first,dy=y-qu[i].second;     if(abs( dx)==abs(dy) )       return 0;   }   return 1; }  int is_forked(int x,int y){   int fork=0;     for(int j=0;j<8;j++){       int xx=x+kn[j][0],yy=y+kn[j][1];       if(xx>=0 && xx<n && yy>=0 && yy<n && brd[xx][yy]) 	fork++;     }   if(fork>=2)     return 1;   else     return 0; }   int main(){   int t;   scanf("%d",&t);   while(t--){     int m;     int r[1001]={0};     int c[1001]={0};     qu.clear();     scanf("%d%d",&n,&m);     memset(brd,0,sizeof(brd));     int x,y;     for(int i=0;i<m;i++){       scanf("%d%d",&x,&y);       x--,y--;       brd[x][y]=1;       r[x]=1;       c[y]=1;       qu.push_back(make_pair(x,y));     }     int ans=0;     for(int i=0;i<n;i++)       for(int j=0;j<n;j++) 	if(r[i]==0 && c[j]==0 && is_safe(i,j) && is_forked(i,j)) 	  ans++;     printf("%d\n",ans);   } }  
//Template  //By Anudeep :) //Includes #include <vector>  #include <queue> #include <map>  #include <set> #include <utility> //Pair #include <algorithm> #include <sstream> // istringstream>> ostring stream<< #include <iostream>  #include <iomanip>  //setbase - cout << setbase (16); cout << 100 << endl; Prints 64 //setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77 //setprecision - cout << setprecision (4) << f << endl; Prints x.xxxx #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <limits> using namespace std;  //M lazy ;) typedef long long ll; typedef vector <int> vi; typedef pair< int ,int > pii; typedef istringstream iss; typedef ostringstream oss; #define pb push_back #define mp make_pair #define ff first #define ss second #define sz size() #define ln length() #define rep(i,n) for(int i=0;i<n;i++) #define fu(i,a,n) for(int i=a;i<=n;i++) #define fd(i,n,a) for(int i=n;i>=a;i--) #define all(a)  a.begin(),a.end() #define ESP (1e-9)  #define gi(n) scanf("%d",&n) #define gl(n) cin >> n #define pi(n) printf("%d",n) #define pl(n) cout << n #define ps printf(" ") #define pn printf("\n") #define dg(n,s); printf("%s %d",s,n) #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min()  #define MOD 1000000007  int dp[35][34][1<<7]; int main() {     int t;     scanf("%d", &t);     while(t--) {         int N, K, B;         scanf("%d%d%d", &N, &K, &B);         N++;         memset(dp, 0, sizeof dp);         for(int i=0; i<=32; i++)                         for(int k=0; k<(1<<K); k++) {                             for(int mask=0; mask<(1<<K); mask++) {                                 bool valid = true;                                 int cb = __builtin_popcount(mask)&1;                                 int nk = k;                                 for(int j=0; j<K-1; j++) {                                     //validate j with j+1                                     if((k >> j) & 1) continue;                                     if(((mask>>j)&1) > ((mask>>(j+1))&1)) { valid = false; break; }                                     if(((mask>>j)&1) < ((mask>>(j+1))&1)) { nk += (1<<j); }                                 }                                 if(((k >> (K-1)) & 1) == 0) {                                     if(((mask>>(K-1))&1) > ((N>>(i-1))&1)) { valid = false; }                                     if(((mask>>(K-1))&1) < ((N>>(i-1))&1)) { nk += (1<<(K-1)); }                                 }                                 if(valid) {                                     for(int b=0; b<=30; b++) {                                         if(i == 0) {                                                 dp[i][b][k] = 0;                                                 dp[i][B][(1<<K)-1] = 1;                                                 continue;                                         }                                         dp[i][b][k] += dp[i-1][b+cb][nk];                                         if(dp[i][b][k] >= MOD) dp[i][b][k] -= MOD;                                     }                                 }                             }                         }         printf("%d\n", dp[32][0][0]);     } }
#include <cstdio> #include <cstring> #include <cstdlib> #include <cassert> #include <map> #include <vector> using namespace std;  const int maxn = 1000;  vector<int> adj[maxn]; int mark[maxn], stamp, match[maxn];  // Hungray, find augment path inline bool augment(int x) {     for (int i = 0; i < adj[x].size(); ++ i) {         int y = adj[x][i];         if (mark[y] == stamp) {             continue;         }         mark[y] = stamp;         if (match[y] == -1 || augment(match[y])) {             match[y] = x;             return true;         }     }     return false; }  int main() {     int T;     for (scanf("%d", &T); T --;) {         int n;         scanf("%d", &n);         assert(1 <= n <= maxn);         map<int, int> hashX, hashY;         for (int i = 0; i < n; ++ i) {             int x, y;             scanf("%d%d", &x, &y);             if (!hashX.count(x)) {                 int newid = hashX.size();                 adj[newid].clear();                 hashX[x] = newid;             }             x = hashX[x];             if (!hashY.count(y)) {                 int newid = hashY.size();                 hashY[y] = newid;             }             y = hashY[y];             adj[x].push_back(y);         }         memset(mark, -1, sizeof(mark));         memset(match, -1, sizeof(match));         stamp = 0;         int maxMatch = 0;         for (int i = 0; i < hashX.size(); ++ i) {             ++ stamp;             if (augment(i)) {                 ++ maxMatch;             }         }         printf("%d\n", maxMatch);     }     return 0; } 
#include <iostream> #include <cstring>  using namespace std;  const int MAXN = 35;  bool seen[MAXN][MAXN]; char g[MAXN][MAXN]; int r, c, match[MAXN][MAXN]; int dc[] = {-2, -1, 1, 2, 2, 1, -1, -2}, dr[] = {1, 2, 2, 1, -1, -2, -2, -1};  bool valid(int i, int j) {   return 0 <= i && 0 <= j && i < r && j < c && g[i][j] != '#'; }  bool dfs(int i, int j) {   if (seen[i][j]) return false;   seen[i][j] = true;   for (int k = 0; k < 8; ++k) {     int ni = i+dr[k], nj = j+dc[k];     if (!valid(ni,nj)) continue;     if (match[ni][nj] == -1 || dfs(match[ni][nj]/c, match[ni][nj]%c)) {       match[ni][nj] = i*c+j;       match[i][j] = ni*c+nj;       return true;     }   }   return false; }  bool augment() {   memset(seen, false, sizeof(seen));   for (int i = 0; i < r; ++i)     for (int j = 0; j < c; ++j)       if (((i+j)&1) && valid(i,j) && match[i][j] == -1 && dfs(i,j)) 	return true;   return false; }  int main() {   int t;   cin >> t;   while (t--) {     cin >> r >> c;     int b = 0;     for (int i = 0; i < r; ++i) {       cin >> g[i];       for (int j = 0; j < c; ++j) 	if (g[i][j] == '#') ++b;     }     memset(match, -1, sizeof(match));     int tot = 0;     while (augment()) ++tot; 	     cout << r*c-b-tot << endl;   } }
//coded using editorial #include <stdio.h> #include <stdlib.h> #include <iostream> #include <string.h> #include <algorithm> #include <math.h> #include <vector> #include <queue> #include <set> #include <stack> #include <map> #define INF_MAX 2147483647 #define INF_MIN -2147483647 #define INF_LL 9223372036854775807LL #define INF 2000000000 #define PI acos(-1.0) #define inf INT_MAX #define llu unsigned long long int #define all(v) v.begin(),v.end() #define pb push_back #define mp make_pair #define F first #define S second #define si(n) scanf("%d",&n) #define slli(n) scanf("%lld",&n); #define ss(n) scanf("%s",n); using namespace std; typedef long long int LL;   std::vector<int > adjList[100010];  int a[100010] , b[100010] , max_depth , D , RD , LCA_D_RD , S , min_depth; int N , u , v , Q , M , flag = 0 , test; int nr , T[100010] , P[100010] , L[100010] ,  st[100010] , en[100010]; int offset = 0; int counter = 1;  //T is the direct ancestor //P is the ancestor of that block of size square root N //L is the level int dp[100010][32];   void init() { 	for(int i=0;i<N+4;i++) 		adjList[i].clear(); 	L[1] = 1; 	nr = sqrt(N); 	counter = 1; 	offset = 0; 	min_depth = 1000000; 	max_depth = 0; }   void dfs(int curr_node, int parent)   {       int k;              st[curr_node] = counter++;         if(L[curr_node] < nr)           P[curr_node] = 1;       else{           if(!(L[curr_node] % nr))               P[curr_node] = T[curr_node];           else               P[curr_node] = P[T[curr_node]];       }          std::vector< int >::iterator it = adjList[curr_node].begin();       while(it!=adjList[curr_node].end())       {       		if((*it)!=parent)       		{       			L[(*it)] = L[curr_node] + 1;       			T[(*it)] = curr_node;       			dfs((*it) , curr_node);       		}       		it++;       }        en[curr_node] = counter++;   }   void process3() {       int i, j;      //we initialize every element in P with -1       for(i=0; i<=N + 4 ; i++)           for (j=0;(1<<j)<=N + 4; j++)               dp[i][j] = -1;      //the first ancestor of every node i is T[i]       for (i = 1; i <= N; i++)           dp[i][0] = T[i];      //bottom up dynamic programing       for (j = 1; (1 << j) <= N; j++)          for (i = 1; i <= N; i++)              if (dp[i][j - 1] != -1)                  dp[i][j] = dp[dp[i][j - 1]][j - 1]; }    int query(int p, int q) {       int tmp, lg , i;      //if p is situated on a higher level than q then we swap them       if (L[p] < L[q])       {           tmp = p;           p = q;           q = tmp;         }   //we compute the value of [log(L[p)]       for (lg = 1; (1<<lg) <= L[p];)       	 lg++;       lg--;      //we find the ancestor of node p situated on the same level   //with q using the values in P       for (i = lg; i >= 0; i--){           if(L[p] - (1 << i) >= L[q])               p = dp[p][i];          }        if (p == q)           return p;      //we compute LCA(p, q) using the values in P       for (i = lg; i >= 0; i--)       {           if (dp[p][i] != -1 && dp[p][i] != dp[q][i])           {               	p = dp[p][i];           		q = dp[q][i];           }       }           return T[p]; }    int LCA(int x, int y)   {   //as long as the node in the next section of    //x and y is not one common ancestor   //we get the node situated on the smaller    //lever closer       while (P[x] != P[y])           if (L[x] > L[y])              x = P[x];           else               y = P[y];               //now they are in the same section, so we trivially compute the LCA       while (x != y)           if (L[x] > L[y])              x = T[x];           else              y = T[y];       return x;   }     int main() { si(test); while(test--) { si(N); init(); for(int i=1;i<=N-1;i++) { 	si(u);si(v); 	adjList[u].pb(v); 	adjList[v].pb(u); } nr = sqrt(N); L[1] = 1; dfs(1 , -1); si(Q); while(Q--) { 	si(M); 	max_depth = 0; 	min_depth = 1000000; 	flag = 0; 	for(int i=1;i<=M;i++) 	{ 		si(a[i]); 		if(L[a[i]] < min_depth){ 			min_depth = L[a[i]]; 					S = a[i]; 		} 		if(L[a[i]] > max_depth){ 			max_depth = L[a[i]]; 					D = a[i]; 		} 	} 	//remove all the nodes which are in the path from the root to D 	offset = 0; 	for(int i=1;i<=M;i++){ 		if((st[a[i]] <= st[D]) && (en[a[i]] >= en[D])) 			continue; 		else 			b[offset++] = a[i]; 	} 	max_depth = 0; 	for(int i=0;i<offset;i++) 	{ 		if(L[b[i]] > max_depth) 		{ 			max_depth = L[b[i]]; 				RD = b[i]; 		} 	}  	if(offset ==  0) 	{ 		printf("Yes\n"); 		continue; 	}  	flag = 0; 	for(int i=0;(i<offset) && (flag==0);i++) 	{  		if(st[b[i]] <= st[RD] && en[b[i]] >= en[RD])  			continue;  		else  			flag = 1; 	}   	if(flag==1) 	{ 		printf("No\n"); 		continue; 	} 	else 	{ 		LCA_D_RD = LCA(D , RD); 		if(st[LCA_D_RD]<=st[S] && en[LCA_D_RD]>=en[S]) 			printf("Yes\n"); 		else 			printf("No\n"); 	} } } return 0; } 
#include<bits/stdc++.h> using namespace std;  typedef pair<int,int> II; typedef vector< II > VII; typedef vector<int> VI; typedef vector< VI > VVI; typedef long long int ll;  #define PB push_back #define MP make_pair #define F first #define S second #define SZ(a) (int)(a.size()) #define ALL(a) a.begin(),a.end() #define SET(a,b) memset(a,b,sizeof(a))  #define si(n) scanf("%d",&n) #define dout(n) printf("%d\n",n) #define sll(n) scanf("%lld",&n) #define lldout(n) printf("%lld\n",n) #define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)  #define TRACE  #ifdef TRACE #define trace(...) __f(#__VA_ARGS__,__VA_ARGS__) /*template <typename Arg1> void __f(const char * name, Arg1&& arg1){     cerr << name << " : " << arg1 << std::endl; } template <typename Arg1, typename... Args> void __f(const char* names, Arg1&& arg1, Args&&... args){     const char* comma = strchr(names + 1,',');cerr.write(names,comma - names) << " : " << arg1<<" | ";__f(comma+1,args...); }*/ #else #define trace(...) #endif int max(int p,int q) {     return (p>q)?p:q; } int min(int p,int q) {     return (p<q)?p:q; }  bool cmpfunc(ll i,ll j) {     return i>j; }  ll ans[100005],count1[100005],count2[100005],w[100005],c[100005]; int main() {     vector<ll> c1,c2;     ll n,i,total1,total2,j,m;     sll(n);     for(i=0;i<n;i++)     {         sll(w[i]);         sll(c[i]);     }     for(i=0;i<n;i++)     {          if(w[i]==1)         {             c1.PB(c[i]);         }         else         {             c2.PB(c[i]);         }     }     if(SZ(c1))     {         sort(ALL(c1),cmpfunc);     }     if(SZ(c2))     {         sort(ALL(c2),cmpfunc);     }     total1=SZ(c1);     total2=SZ(c2);     if(total1==0)     {         c1.PB(0);         c1.PB(0);     }     else if(total1==1)     {         c1.PB(0);     }     if(total2==0)     {         c2.PB(0);     }  /*   for(i=0;i<SZ(c1);i++)     {         cout << c1[i] << " ";     }     cout << endl;     for(i=0;i<SZ(c2);i++)     {         cout << c2[i] << " ";     }     cout << endl;*/     i=0;     j=0;     ans[1]=c1[0];     count1[1]=1;     count2[1]=0;     if(c1[0]+c1[1]>c2[0])     {         ans[2]=c1[0]+c1[1];         count1[2]=2;         count2[2]=0;     }     else     {         ans[2]=c2[0];         count1[2]=0;         count2[2]=1;     }     m=total1+2*total2;     //printf("%lld %lld\n",total1,total2);     for(i=3;i<=m;i++)     {       //  printf("%lld %lld %lld %lld %lld\n",i,total1,count1[i-1],total2,count2[i-2]);         if(total1>count1[i-1] && total2>count2[i-2])         {             if(ans[i-2]+c2[count2[i-2]]>=ans[i-1]+c1[count1[i-1]])             {                 ans[i]=ans[i-2]+c2[count2[i-2]];                 count2[i]=count2[i-2]+1;                 count1[i]=count1[i-2];             }             else             {                 ans[i]=ans[i-1]+c1[count1[i-1]];                 count1[i]=count1[i-1]+1;                 count2[i]=count2[i-1];             }         }         else if(total1>count1[i-1])         {             ans[i]=ans[i-1]+c1[count1[i-1]];             count1[i]=count1[i-1]+1;             count2[i]=count2[i-1];         }         else if(total2>count2[i-2])         {             if(ans[i-1]<ans[i-2]+c2[count2[i-2]])             {                 ans[i]=ans[i-2]+c2[count2[i-2]];                 count2[i]=count2[i-2]+1;                 count1[i]=count1[i-2];             }             else             {                 ans[i]=ans[i-1];                 count2[i]=count2[i-1];                 count1[i]=count1[i-1];             }         }        /* if(i%2==1)         {             ans[i]=ans[i-1]+c1[count1[i-1]];         }         else         {             if(total1>count1[i-2]+1 && total2>count2[i-2])             {                 if(ans[i-2]+c1[count1[i-2]]+c1[count1[i-2]+1] > ans[i-2]+c2[count2[i-2]])                 {                     ans[i]=ans[i-2]+c1[count1[i-2]]+c1[count1[i-2]+1];                     count1[i]=count1[i-2]+2;                     count2[i]=count2[i-2];                 }                 else                 {                     ans[i]=ans[i-2]+c2[count2[i-2]];                     count1[i]=count1[i-2];                     count2[i]=count2[i-2]+1;                 }             }             else if(total1>count1[i-2]+1)             {                 ans[i]=ans[i-2]+c1[count1[i-2]]+c1[count1[i-2]+1];                 count1[i]=count1[i-2]+2;                 count2[i]=count2[i-2];             }             else if(total2>count2[i-2])             {                 ans[i]=ans[i-2]+c2[count2[i-2]];                 count1[i]=count1[i-2];                 count2[i]=count2[i-2]+1;             }         }*/     }     for(i=1;i<=m;i++)     {         cout << ans[i] << " ";     }     cout << endl;     return 0; }  
#include <stdio.h> #include <algorithm> #include <vector> #include <stack>   /* given any string of left and right parens, after removing all matching left    and right parens, what remains is a string consisting of some number of     left parans followed by some number of right parens */ struct ReducedStr1 {   int left_count;   int right_count;   ReducedStr1(char paren = 0) :      left_count((paren == '(') ? 1 : 0),     right_count((paren == ')') ? 1 : 0)   {}  };   ReducedStr1 operator+(ReducedStr1 a, ReducedStr1 b) {   ReducedStr1 ret;   int cancelled = std::min(a.left_count, b.right_count);   ret.left_count = a.left_count + b.left_count - cancelled;   ret.right_count = a.right_count + b.right_count - cancelled;   return ret; }    struct ReducedStr {   ReducedStr1 forward, reverse;   ReducedStr(char paren = 0) : forward(paren), reverse(paren) {} };   ReducedStr operator+(ReducedStr a, ReducedStr b) {   ReducedStr ret;   ret.forward = a.forward + b.forward;   ret.reverse = b.reverse + a.reverse;   return ret; }   struct Node;   struct AncestorInfo {   Node* n;   ReducedStr str; // path string to n (not including paren at n)   AncestorInfo(Node* n, ReducedStr str) : n(n), str(str) {} };   struct Node {   char paren;  // ')' or '('   std::vector<AncestorInfo> anc; // anc[i] is 2^i hops toward the root   std::vector<Node*> adj; // list of adjacent nodes   int level;   Node() : paren(0) {}   Node* find_ancestor_at_level(int level, ReducedStr& str)   {     if (this->level <= level) return this;     int i;     for (i=0;i<anc.size();i++)       if (anc[i].n->level <= level) break;     if (i != anc.size() && anc[i].n->level == level) {       str = str + anc[i].str;       return anc[i].n;     }     str = str + anc[i-1].str;     return anc[i-1].n->find_ancestor_at_level(level, str);   } };   Node* find_common_ancestor(Node* u, Node* v, ReducedStr& s, ReducedStr& t) {   if (u == v) return u;   int i;   for (i=0;i<u->anc.size();i++)     if (u->anc[i].n == v->anc[i].n) break;   if (i==0) {     s = s + u->anc[0].str;     t = t + v->anc[0].str;     return u->anc[i].n;   }   s = s + u->anc[i-1].str;   t = t + v->anc[i-1].str;   return find_common_ancestor(u->anc[i-1].n, v->anc[i-1].n, s, t); }   int is_balanced(Node *u, Node* v) {   ReducedStr s, t;   if (u->level > v->level)     u = u->find_ancestor_at_level(v->level, s);   else if (v->level > u->level)     v = v->find_ancestor_at_level(u->level, t);     Node* w = find_common_ancestor(u,v,s,t);     ReducedStr1 path = s.forward + w->paren + t.reverse;   return (!path.left_count && !path.right_count); }   void make_tree(Node* root) {   std::stack<Node*> st;   st.push(root);   root->level = 0;   while (!st.empty()) {     Node* u = st.top();     st.pop();     for (int j=0;j<u->adj.size();j++) {       Node* v = u->adj[j];       if (v == root || !v->anc.empty()) continue;       v->anc.push_back(AncestorInfo(u, ReducedStr(v->paren)));       Node* w = u;       for (int k=1;k <= w->anc.size();k++) {         Node* x = w->anc[k-1].n;         v->anc.push_back(           AncestorInfo(x, v->anc[k-1].str + w->anc[k-1].str));         w = x;       }       v->level = u->level + 1;       st.push(v);     }   } }   int main() {   int T;     scanf("%d\n", &T);   for (int i=0;i<T;i++) {     int N, Q;     scanf("%d %d\n", &N, &Q);     std::vector<Node> tree(N);     for (int j=0;j<(N-1);j++) {       int u, v;       scanf("%d %d\n", &u, &v);       --u; --v;       tree[u].adj.push_back(&tree[v]);       tree[v].adj.push_back(&tree[u]);     }     for (int j=0;j<N;j++) {       char c;       scanf(j == (N-1) ? "%c\n" : "%c ", &c);       tree[j].paren = c;     }     make_tree(&tree[0]);     for (int j=0;j<Q;j++) {       int u, v;       scanf("%d %d\n", &u, &v);       --u; --v;       printf("%s\n", is_balanced(&tree[u], &tree[v]) ? "Yes" : "No");     }   }    return 0; }  
#include <map> #include <set> #include <list> #include <cmath> #include <ctime> #include <deque> #include <queue> #include <stack> #include <string> #include <bitset> #include <cstdio> #include <limits> #include <vector> #include <cstring> #include <cstdlib> #include <sstream> #include <iostream> #include <algorithm> using namespace std;  #define MOD 1000000007 #define ll long long #define REP(i,a) for(i=0;i<a;i++) #define FOR(i,a,b) for(i=a;i<b;i++) #define VE vector<int> #define SZ size() #define PB push_back  //inline ll NFIBO(ll a){ll phi=(1+sqrt(5))/2; ll x=floor(pow(phi,a)/sqrt(5)+1/2); return x;} //inline void FFIBO(unsigned ll n,unsigned ll ans[]){unsigned ll a,b,c,d;if(n == 0){ans[0] = 0;ans[1] = 1;return;}FFIBO((n/2),ans);a = ans[0];b = ans[1];c = 2*b - a;if(c < 0)c += MOD;c = (a * c) % MOD;d = (a*a + b*b) % MOD;if(n%2 == 0){ans[0] = c;ans[1] = d;}else{ans[0] = d;ans[1] = c+d;}}   int main() {     int t;     cin>>t;     cin.ignore(254,'\n');     while(t--)     {          string s,t;         const char *a,*b;         cin>>s;         cin>>t;         s.assign(s.begin(), unique(s.begin(),s.end()));         t.assign(t.begin(), unique(t.begin(), t.end()));         a = s.c_str();         b = t.c_str();         if(strcmp(a,b)==0)         cout<<"Yes\n";         else         cout<<"No\n";      } } 
#include <bits/stdc++.h> #define forn(i, a, n) for (int i = a; i < n; ++i) #define forr(i, a, n) for (int i = (n) - 1; i >= a; --i) #define pb push_back #define pf push_front #define lag long long  using namespace std; const int M = 1e9 + 7; const int N = 1e5 + 7;  int t, n, p[N], e[N], pr[N], size; bool is[N]; lag fact[N] = {1}; lag mp(lag b, lag e, lag m) { 	lag a = 1; 	b %= m; 	while (e) { 		if (e & 1) a = a * b % m; 		e >>= 1; 		b = b * b % m; 	} 	return a; } lag inv(lag x) { 	return mp(x, M - 2, M); } lag choose(int n, int k) { 	return fact[n] * inv(fact[k]) % M * inv(fact[n-k]) % M; } int get(int n, int p) { 	int k = 0; 	while (n / p > 0) { 		k += n / p; 		n /= p; 	} 	return k; } lag choosem(int n, int k) { 	// modulo (M - 1) 	lag a = 1; 	forn (i, 0, size) { 		if (pr[i] > n) 			break; 		int e = get(n, pr[i]) - get(k, pr[i]) - get(n - k, pr[i]); 		a = a * mp(pr[i], e, M-1) % (M-1); 	} 	return a; } int main() { 	forn (i, 1, N) 		fact[i] = fact[i-1] * i % M; 	forn (i, 2, N) 		is[i] = true; 	for (int i = 2; i*i < N; ++i) 		if (is[i]) 			for (int j = i*i; j < N; j += i) 				is[j] = false; 	forn (i, 2, N) 		if (is[i]) 			pr[size++] = i; 	scanf("%d", &t); 	while (t--) { 		scanf("%d", &n); 		lag P = 1; 		forn (i, 0, n) { 			scanf("%d%d", p+i, e+i); 			P = P * e[i] % M; 		} 		if (n == 1) { 			printf("1 %lld\n", (P + 1) % M); 			continue; 		} 		lag antichains = choose(n, n / 2); 		lag same; 		if (n & 1) { 			same = mp(P, choosem(n - 1, n/2 - 1), M) + mp(P, choosem(n - 1, (n + 1) / 2 - 1), M); 		} else { 			same = mp(P, choosem(n - 1, n/2 - 1), M); 		} 		printf("%lld %lld\n", (antichains%M+M)%M, (same%M+M)%M); 	} }
import java.util.*; import java.lang.*; import java.io.*;  class JALEBI { 	static int min; 	static char best[]; 	public static void main (String[] args) throws java.lang.Exception 	{ 		Reader re = new Reader(System.in); 		int T = re.nextInt(); 		while(T-->0){ 			int K = re.nextInt(); 			String A[] = new String[K]; 			for(int i=0; i<K; i++) 				A[i] = re.next(); 			char s[] = new char[16]; 			min = 17; 			best = new char[16]; 			work(s, A, 0); 			String out = new String(best); 			System.out.println(out); 		} 	} 	 	static void work(char s[], String A[], int i){ 		if(hasAll(s, A, i)){ 			if(i<min){ 				System.arraycopy(s, 0, best, 0, 16); 				min = i; 			} 			return; 		} 		if(i>15) 			return; 		s[i] = 'B'; 		work(s, A, i+1); 		s[i] = 'G'; 		work(s, A, i+1); 		s[i] = 0; 	} 	 	static boolean hasAll(char s[], String A[], int max){ 		for(String s1 : A){ 			if(s1.length()>max) 				return false; 			int j = 0; 			for(int i=0; i<max; i++) 				if(s[i]==s1.charAt(j)){ 					j++; 					if(j>=s1.length()) 						break; 				} 			if(j<s1.length()) 				return false; 		} 		return true; 	} }  class Reader{     BufferedReader br;     StringTokenizer st;     Reader(InputStream in) throws Exception{         br = new BufferedReader(new InputStreamReader(in));         st = new StringTokenizer("");     }       String next() throws Exception{         while(!st.hasMoreTokens())             st = new StringTokenizer(br.readLine());         return st.nextToken();     }       int nextInt() throws Exception{         return Integer.parseInt(next());     } }
#include<bits/stdc++.h>  using namespace std;  #define in(a,x,y) (a>=x && a<=y) #define out(a,x,y) (!in(a,x,y)) #define sz(a) ((int)a.size()) #define repv(i,a) for(int i=0;i<sz(a);i++) #define revv(i,a) for(int i=sz(a)-1;i>=0;i--) #define rep(i,a,b) for(int i=a;i<=b;i++) #define rev(i,a,b) for(int i=a;i>=b;i--) #define all(a) a.begin(),a.end() #define pb push_back  #define AND(a,b) ((a) & (b)) #define OR(a,b) ((a)|(b)) #define XOR(a,b) ((a) ^ (b)) #define xx first #define yy second #define mp make_pair #define sqr(x) ((x)*(x)) #define sqrt(x) sqrt(1.0*(x))  #define LB(a,x) (lower_bound(all(a),x)-a.begin()) //  first element in the range [first,last) which does not compare less than val. #define UB(a,x) (upper_bound(all(a),x)-a.begin()) //  first element in the range [first,last) which compares greater than val. #define forit(it, s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it++) #define left nokol_left #define right nokol_right #define countbit(x) __builtin_popcountll((ll)x) #define PQ priority_queue #define FAST ios_base::sync_with_stdio(0);cin.tie(0); #define Unique(store) store.resize(unique(store.begin(),store.end())-store.begin()) #define READ(f) freopen(f, "r", stdin) #define WRITE(f) freopen(f, "w", stdout)  typedef long long ll; typedef unsigned int uint; typedef unsigned long long ull; typedef pair<int,int> pii; typedef pair<long long,long long> pll; typedef vector<int> vi; typedef vector<long long> vll;  template<class T>T __sqr(const T x){return x*x;} template< class T, class X > inline T __pow(T a,X y) {T z=1; rep(i,1,y){z*=a;} return z; } template< class T > inline T gcd(T a,T b) {a=abs(a);b=abs(b); if(!b) return a; return __gcd(b,a%b);} template< class T > inline T lcm(T a,T b) {a=abs(a);b=abs(b); return (a/__gcd(a,b))*b;} inline bool ispow2(int x){return (x!=0 && (x&(x-1))==0);} template<class T>void UpdateMin(T &x,T y){  if(y<x){x=y;}} template<class T>void UpdateMax(T &x,T y){if(x<y){x=y;}} template<class T,class X, class Y > inline T bigmod(T n,X m,Y mod){ull ret=1, a = n%mod ; while(m){ if(m&1)ret=(ret*a)%mod; m>>=1; a=(a*a)%mod; }ret%=mod;return (T)ret;} template<class T, class Y > inline T modinv(T n,Y mod) {return bigmod(n,mod-2,mod);}  template<class T,class X> int getbit(T s,X i) { return (s >> i) & 1; } template<class T,class X> T onbit(T s, X i) { return s | (T(1) << i); } template<class T,class X> T offbit(T s, X i) { return s & (~(T(1) << i)); } template<class T> inline void read(T &n){char c;for (c = getchar(); !(c >= '0' && c <= '9'); c = getchar()); n = c - '0';for (c = getchar(); c >= '0' && c <= '9'; c = getchar()) n = n * 10 + c - '0';}  void extended_euclid(ll a,ll b,ll &x,ll &y){ if(!b){ x = 1 , y = 0  ;  return ;} ll xx,yy; extended_euclid(b,a%b,xx,yy); x = yy; y = xx - (a/b)*yy; } pair<ll, pair<ll, ll> > extendedEuclid(ll a, ll b) { ll x = 1, y = 0; ll xLast = 0, yLast = 1; ll q, r, m, n; while(a != 0) {q = b / a; r = b % a; m = xLast - q * x; n = yLast - q * y; xLast = x, yLast = y; x = m, y = n; b = a, a = r; } return make_pair(b, make_pair(xLast, yLast)); }  const ll mod[]  ={0,1000000007,1000000009,1000000021,1000000033,1000000097,1000000093,1000000097,1000000103}; const ll base[] ={0,1000003,1000033,1000037,1000039,1000081,1000099,1000117,1000121};  #define pi acos(-1.0) #define eps  1e-12 #define MX   (lmt+20) #define inf  800000000000000000LL #define MOD  100000007LL //---------->0123456789123465789 #define lmt  200000  typedef pair<long long , long long > point;  //typedef pair<LL, LL> point;  ll cw(const point &a, const point &b, const point &c) {     return (b.first - a.first) * (c.second - a.second) - (b.second - a.second) * (c.first - a.first); }  vector<point> convexHull(vector<point> p) {     int n = p.size();     if (n <= 1)         return p;     sort(p.begin(), p.end());     int cnt = 0;     vector<point> q(n * 2);     for (int i = 0; i < n; q[cnt++] = p[i++])         for (; cnt >= 2 && cw(q[cnt - 2], q[cnt - 1], p[i]) >= 0; --cnt)             ;     for (int i = n - 2, t = cnt; i >= 0; q[cnt++] = p[i--])         for (; cnt > t && cw(q[cnt - 2], q[cnt - 1], p[i]) >= 0; --cnt)             ;     q.resize(cnt - 1 - (q[0] == q[1]));     return q; }  ll area(point &a,point &b,point &c){      return abs( a.xx*(b.yy - c.yy) + a.yy*(c.xx - b.xx) + 1*(b.xx*c.yy - b.yy*c.xx) ); }  inline ll dist(point &a,point &b){     return abs( ( a.xx-b.xx ) * ( a.xx-b.xx ) + ( a.yy - b.yy )*( a.yy - b.yy )); }  int main() {     ll ts , n;     scanf("%lld",&ts);     while(ts--){         scanf("%lld",&n);         vector<point>p;         ll x, y;         rep(i,1,n) {             scanf("%lld%lld",&x,&y);             p.pb( mp(x, y) );         }         vector<point> hull = convexHull(p); //        if(hull.size()==n) puts("-1"); //        else{             set< point > s;             repv(i,hull) s.insert( hull[i] );               vector<point>tot;             repv(i,p) if( s.find( p[i] )==s.end() ) tot.pb( p[i] );             vector<point> gt = convexHull(tot);              if(gt.size()==0){                 cout<<-1<<endl;                 continue;             }              ll mn = abs( cw(hull[0],hull[1],gt[0]) ) , id = 0;             repv(i,gt){                 ll d = abs( cw(hull[0],hull[1],gt[i]) ) ;                 if(d < mn){                     mn = d;                     id = i;                 }             }              ll res = mn;             for(int i = 1; i < hull.size(); i++){                 ll v = abs(cw(hull[i], hull[(i+1)%hull.size()], gt[id]));                 while(1){                     id = (id + 1) % gt.size();                     if(abs(cw(hull[i], hull[(i+1)%hull.size()], gt[id])) < v){                         v = abs(cw(hull[i], hull[(i+1)%hull.size()], gt[id]));                     } else {                         id = (id - 1 + gt.size()) % gt.size();                         break;                     }                 }                  if(v < res) res = v;             }             ll ans = 0;             repv(i,hull){ //                if(i<=1) continue;                 ans +=  hull[i].xx * hull[(i+1) % hull.size()].yy - hull[i].yy * hull[(i+1) % hull.size()].xx;             }             ans = abs(ans);             ans -= res;             printf("%lld\n",ans); //            cout<<ans<<endl; //        }     }      return 0; } 
#include <iostream> #include <algorithm> #include <cstdio> #include <cstdlib> #include <vector> #include <cstring> #include <string> #include <cmath> #include <ctime> #include <utility> #include <map> #include <set> #include <queue> #include <stack> #include <sstream> #define FOR(a,b,c) for (int a=b;a<=c;a++) #define FORD(a,b,c) for (int a=b;a>=c;a--) #define REP(i,a) for(int i=0,_a=(a); i<_a; ++i) #define REPD(i,a) for(int i=(a)-1; i>=0; --i) #define tr(c,i) for(typeof((c).begin() i = (c).begin(); i != (c).end(); i++) #define pb push_back #define mp make_pair #define fi first #define se second #define sz(a) int(a.size()) #define all(a) a.begin(),a.end() #define reset(a,b) memset(a,b,sizeof(a)) #define oo 1000000007  using namespace std;  typedef long long ll; typedef pair<int, int> pii; typedef pair<pii,int> iii;  #define maxn 50007  int n,k; map<int,int> mymap; set<pii> set1; set<int> v;  void solve(){     scanf("%d%d",&n,&k);     mymap.clear();     int t;     FOR(i,1,n){         scanf("%d",&t);         if(mymap.find(t)!=mymap.end()) mymap[t]++; else mymap[t]=1;     }     set1.clear();     for(map<int,int>::iterator it=mymap.begin(); it!=mymap.end(); it++){         if(it->se>n/k){printf("-1\n"); return;}         set1.insert(pii(it->se,it->fi));     }     FORD(i,n/k,1){         v.clear();         for(set<pii>::reverse_iterator it=set1.rbegin(); it!=set1.rend() && it->fi >= i; it++) v.insert(it->se);         for(map<int,int>::iterator it=mymap.begin(); it!=mymap.end() && sz(v)<k; it++) if(v.find(it->fi)==v.end()) v.insert(it->fi);         for(set<int>::iterator it=v.begin(); it!=v.end(); it++){             printf("%d ",*it);             t=mymap[*it];             set1.erase(set1.find(pii(t,*it)));             mymap[*it]--;             if(t>1) set1.insert(pii(t-1,*it)); else mymap.erase(*it);         }     }     printf("\n"); }     //#include <conio.h> int main(){     //freopen("test.txt","r",stdin);     int T;     scanf("%d",&T);     REP(i,T)      solve();     //getch();     return 0; } 
#include<bits/stdc++.h> using namespace std; typedef long long ll; ll n,d,dp[1<<16],inf=1E18; ll get(vector<ll>&a) { 	int l=a.size(); 	ll res=0; 	for(int i=0;i<l;i++) 	res=res*d+(a[i]); 	return res; } ll cost(vector<ll>&a) { 	int l=a.size(); 	ll x=0,s=0; 	for(int i=0;i<l;i++) 	{ 		s+=a[i]; 		x^=a[i]; 	} 	return s*x; } ll recur(vector<ll>&a) { 	ll x=get(a); 	if(dp[x]!=-1) 	return dp[x]; 	if(x==0) 	{ 		dp[x]=0; 		return 0; 	} 	ll c=cost(a),k=inf; 	vector<ll>b=a; 	dp[x]=inf; 	for(ll i=0;i<n;i++) 	{ 		//cout<<a[i]<<endl; 		if(a[i]>0) 		{ 			b[i]--; 			k=min(k,recur(b)); 			b[i]++; 		} 	} 	//cout<<x<<" "<<k<<' '<<c<<endl; 	dp[x]=c+k; 	return dp[x]; } void solve() { 	scanf("%lld%lld",&n,&d); 	vector<ll> a; 	for(ll i=0;i<n;i++) 	a.push_back(d-1); 	memset(dp,-1,sizeof(dp)); 	printf("%lld\n",recur(a)); } int main() { 	ll t; 	scanf("%lld",&t); 	while(t--) 	solve(); 	return 0; }
#include<bits/stdc++.h> using namespace std; #define ll long long ll  MOD; ll  mult(ll  A, ll  B) { 	if ( B == 0 ) return 0; 	ll  u = mult(A, B/2); 	ll  res; 	if ( B%2 == 0 ) 		res = u + u; 	else 		res = u + u + A; 	return (res%MOD); }  char s[10001]; void solve() { 	scanf("%lld %s",&MOD,s); 	int l = strlen(s); 	ll ans = 1; 	for (int i=0; i<l; i++) 	{ 		ll F = 0; 		int j = i; 		while ( s[j] >= '0' && s[j] <= '9' ) 		{ 			//F = mult(F, 10); 			F=(1ull*F*10)%MOD; 			F =(F + s[j]-'0')%MOD; 			j++; 		} 		j+=2; 		ll NF = 1; 		while ( s[j] >= '0' && s[j] <= '9' ) 		{ 			ll WNF = 1; 			for (int k=1; k<=10; k++) 				WNF = mult(NF, WNF); 			NF = WNF; 			for (int k=1; k <= s[j]-'0'; k++) 				NF = mult(NF, F); 			j++; 		} 		ans = mult(ans, NF); 		i = j; 	} 	printf("%lld\n",ans); } int main() { 	int test; 	cin>>test; 	while ( test-- ) solve(); 	return 0; } 
#include <iostream> #include <algorithm> #include <cstdio> #include <vector> #include <cstring> #include <string> #include <cmath> #include <utility> #include <map> #include <set> #include <queue> #include <stack> #include <sstream> #define fr(a,b,c) for (int a=b;a<=c;a++) #define frr(a,b,c) for (int a=b;a>=c;a--) #define rep(a,b) for (int a=0;a<b;a++) #define repp(a,b) for (int a=b-1;a>=0;a--) #define pb push_back #define mp make_pair #define fi first #define se second #define sz(a) int(a.size()) #define all(a) a.begin(),a.end() #define pii pair<int,int> #define oo 1000111222 #define maxN 1 #define base 100000 #define digit 5 using namespace std;  int n;  struct bignum { 	int a[5000],l; 	 	void load(int x) 	{ 		for (int i=0;i<5000;i++) a[i]=0; 		a[l=1]=x; 	} 	 	void mul(int x) 	{ 		int mem=0; 		for (int i=1;i<=l;i++) 		{ 			a[i]=a[i]*x+mem; 			mem=a[i]/base; 			a[i]%=base; 		} 		if (mem) a[++l]=mem; 	} 	 	void divide(int x) 	{ 		int mem=0; 		for (int i=l;i;i--) 		{ 			int t=a[i]+mem*base; 			a[i]=t/x; 			mem=t%x; 		} 		while (l>1 && !a[l]) l--; 	} 	 	void read() 	{ 		load(0); 		string s; 		cin >> s; 		l=(sz(s)+digit-1)/digit; 		reverse(s.begin(),s.end()); 		fr(i,1,l) 			frr(j,i*digit-1,(i-1)*digit) 				if (j<sz(s)) 					a[i]=a[i]*10+s[j]-'0'; 	} 	 	int cmp(bignum t) 	{ 		if (t.l!=l) return l<t.l?-1:1; 		frr(i,l,1) 			if (a[i]!=t.a[i]) 				return a[i]<t.a[i]?-1:1; 		return 0; 	} } num[4000];   int main() { 	int maxn; 	 	for (int n=1;;n+=2) 	{ 		int N=n/2+1; 		if (n==1) num[1].load(2); 		else 		{ 			num[n]=num[n-1]; 			num[n].mul(2*N-1); 			num[n].divide(N); 		} 		 		num[n+1]=num[n]; 		num[n+1].mul(2); 		 		if (num[n+1].l>200) 		{ 			maxn=n+1; break; 		} 	} 	 	int test; 	cin >> test; 	while (test--) 	{ 		bignum t; 		t.read(); 		int ok=0,low=1,high=maxn; 		 		while (low<=high) 		{ 			int mid=(low+high)/2; 			int x=num[mid].cmp(t); 			if (!x) 			{ 				ok=1; break; 			} 			if (x<0) low=mid+1; 			else high=mid-1; 		} 		 		puts(ok?"YES":"NO"); 	} } 
#include<iostream> #include<cstdio> #include<set> #include<stack> #define ROF(a,b,c) for(int a=b;a>=c;--a) #include<vector> #include<algorithm> #define FOR(a,b,c) for(int a=b;a<=c;++a) #include<cstring> #include<bitset> #include<cmath> #include<iomanip> #include<queue> #define debug cerr<<"OK"; #define f cin #define g cout #define mp make_pair #define pb push_back #define ll long long #define mod 1000000007 #define inf (1<<30) #define DIM 1000100 #define shit 2000000000000000000LL #define cl first #define le second #define nmic 110 #define N 25 #define SM 210 #define Q 15100 #define eps 1.e-8 using namespace std; //int dx[]={0,0,0,1,-1}; //int dy[]={0,1,-1,0,0}; void swa(pair<ll,ll> &a,pair<ll,ll> &b) { 	pair<ll,ll> aux; 	aux=a; 	a=b; 	b=aux; } pair<ll,ll> v[N]; int viz[N],n,l1,l2,color,k,S,T,adaos; double R[N][SM],sol,D[N][N][N]; double fac[N]; void rucsac(); int main () {     #ifndef ONLINE_JUDGE     freopen("a.in","r",stdin);     freopen("a.out","w",stdout);     #endif 	 	f>>T; 	fac[0]=1; 	FOR(i,1,20) 	fac[i]=fac[i-1]*i; 	while(T--) 	{ 		f>>n>>k; 		S=0; 		sol=0; 		memset(viz,0,sizeof(viz)); 		FOR(i,1,n) 		{ 			f>>v[i].le>>v[i].cl; 			if(v[i].le>k) 				sol=sol+v[i].le-k; 			S+=v[i].le; 		} 		sort(v+1,v+n+1); 		FOR(i,1,n-1) 		{ 			if(v[i].cl==v[i+1].cl) 			{ 				color=v[i].cl; 				l1=v[i].le; 				l2=v[i+1].le; 				rucsac(); 			} 		} 		g<<fixed<<setprecision(9)<<sol<<"\n"; 	} 	return 0; } void rucsac() { 	memset(R,0,sizeof(R)); 	R[0][0]=1; 	FOR(bloc,1,n) 	{ 	if(v[bloc].cl==color) 		continue; 	ROF(nrbl,n,1) 	{ 		ROF(len,k-v[bloc].le,0) 		R[nrbl][len+v[bloc].le]+=R[nrbl-1][len]; 	} 	} 	FOR(nrbl,0,n) 	FOR(len,0,k-1) 	{ 		if(!R[nrbl][len]) 			continue; 		ll nrm=0; 		adaos=l1+len; 		FOR(j,1,l2) 		if(j+adaos-k>=1&&j+adaos-k<=l1) 			nrm++; 		nrm<<=1; 		if(!nrm) 			continue; 		sol=sol+fac[nrbl]*fac[n-nrbl-2]*R[nrbl][len]*nrm*(n-nrbl-1)/fac[n]; 	} } 
#include <iostream> #include <string> #include <sstream> #include <stdio.h> #include <vector> #include <algorithm> #include <list> #include <map> #include <set> #include <fstream> #include <iomanip>  using namespace std;  double ex = 0; int d; int c[50002] = {0}; vector<int> v(50001); vector<int> pr(50001);  void merge(int p, int r) {     // calculation     int mid = (p+r)/2;     c[mid] = 0;     c[mid+1] = pr[mid+1];     for (int ii = mid+2; ii <= r; ii++) c[ii] = c[ii-1] + pr[ii];     vector<int>::iterator itlow,itlow1,itlow2;      for (int ii = p; ii <= mid; ii++)     {         itlow = lower_bound(v.begin()+mid+1,v.begin()+r+1,v[ii]-d);          if (itlow != (v.begin()+r+1))         {             ex = ex + int(itlow - (v.begin()+mid+1));         }         else         {             ex = ex + (r - mid);             continue;         }          itlow1 = lower_bound(v.begin()+mid+1,v.begin()+r+1,v[ii]);          if (itlow1 != (v.begin()+r+1))         {             if (distance(itlow,itlow1) > 0)             {                 int q = c[(int(itlow1-(v.begin()+mid+1)))-1+mid+1] - c[(int(itlow-(v.begin()+mid+1)))-1+mid+1];                 double z = (1 - ((double)(pr[ii]))/100)*((double)q)/100;                 int qq = (int)(itlow1-itlow);                 ex = ex + (double)qq - z;             }         }         else         {             // calculation 2             int q = c[r] - c[int(itlow-(v.begin()+mid+1))-1+mid+1];             double z = (1 - ((double)(pr[ii]))/100)*((double)q)/100;             int qq = ((int)(v.begin()+r-itlow))+1;             ex = ex + (double)qq - z;             continue;         }          itlow2 = lower_bound(v.begin()+mid+1,v.begin()+r+1,v[ii]+d);          if (itlow2 != (v.begin()+r+1))         {             if (distance(itlow1,itlow2) > 0)             {                 int q = c[int(itlow2-(v.begin()+mid+1))-1+mid+1] - c[int(itlow1-(v.begin()+mid+1))-1+mid+1];                 int qq = int(itlow2-itlow1);                 double z = (double)qq - ((double)q)/100;                 ex = ex + (((double)(pr[ii]))/100)*z;             }         }         else         {             int q = c[r] - c[int(itlow1-(v.begin()+mid+1))-1+mid+1];             int qq = int(v.begin()+r-itlow1)+1;             double z = (double)qq - ((double)q)/100;             ex = ex + (((double)(pr[ii]))/100)*z;             continue;         }     }      // normal merge     vector<int> temp(r-p+2),temp1(r-p+2);     int i1 = 0,i2 = p, i3 = mid+1;     while (i2 <= mid && i3 <= r)         if (v[i2] < v[i3])         {             temp[i1] = v[i2];             temp1[i1] = pr[i2];             i1++; i2++;         }         else         {             temp[i1] = v[i3];             temp1[i1] = pr[i3];             i1++; i3++;         }      while (i2 <= mid)     {         temp[i1] = v[i2];         temp1[i1] = pr[i2];         i1++; i2++;     }      while (i3 <= r)     {         temp[i1] = v[i3];         temp1[i1] = pr[i3];         i1++; i3++;     }      for (int iii = p; iii <= r; iii++)     {         v[iii] = temp[iii-p];         pr[iii] = temp1[iii-p];     } } void merge_sort(int p,int r) {     if (p < r)     {         int mid = (p + r)/2;         merge_sort(p, mid);         merge_sort(mid + 1, r);         merge(p,r);     } } int main() {     int tt,n,x;     cin>>tt;     for (int i = 1; i <= tt ; i++)     {         cin>>n>>d;         ex = 0;         v.clear();         for (int j = 0; j < n; j++)         {             cin>>x;             v[j] = x;         }         pr.clear();         for (int j = 0 ; j < n ; j++)         {             cin>>x;             pr[j] = x;         }         //for (int ii = 0 ; ii< n ; ii++) cout<<v[ii]<<" "<<pr[ii]<<endl;         merge_sort(0,n-1);         cout<<fixed;         cout<<setprecision(4);         cout<<ex<<endl;         //for (int ii = 0 ; ii< n ; ii++) cout<<v[ii]<<" "<<pr[ii]<<endl;     } 	return 0; } 
#include<bits/stdc++.h>  #define LL long long #define inf 1000000 #define pb push_back #define vsort(v) sort(v.begin(),v.end()) #define pi acos(-1) #define clr(a,b) memset(a,b,sizeof a) #define bclr(a) memset(a,false,sizeof a) #define MOD 1000000007ll #define MP make_pair #define MX 100000  using namespace std; int indx,cnt[205]; LL dp[205][205],memo[205][205]; LL update(int n,int m){     if(memo[n][m]!=-1) return memo[n][m];     LL ret=1ll;     for(int i=m+1;i<m+n;i++) ret=(ret*(LL)i)%MOD;     return memo[n][m]=ret%MOD; }  LL solve(int id,int sz,int rem){     if(rem<0) return 0ll;     if(id<0) return 1ll;     LL &ret=dp[id][rem];     if(ret!=-1) return ret;     ret=0ll;     LL get=update(cnt[id],sz);     LL decrease=(get*cnt[id])%MOD,no_change=(get*sz)%MOD;     LL ret1=(decrease*solve(id-1,sz+cnt[id],rem-1))%MOD;     LL ret2=(no_change*solve(id-1,sz+cnt[id],rem))%MOD;     ret=(ret1+ret2)%MOD;     if(ret<0) ret+=MOD;     return ret; }  int ar[205]; int main(){     ios_base::sync_with_stdio(0);     cin.tie();     int test;     scanf("%d",&test);     for(int kase=1;kase<=test;kase++){         int n,k;         scanf("%d %d",&n,&k);         for(int i=0;i<n;i++) scanf("%d",&ar[i]);         sort(ar,ar+n);         indx=0;         cnt[indx]++;         for(int i=1;i<n;i++){             if(ar[i]>ar[i-1]) indx++;             cnt[indx]++;         }         memset(dp,-1,sizeof dp);         memset(memo,-1,sizeof memo);         LL get=solve(indx,0,k);         printf("%lld\n",get%MOD);         memset(cnt,0,sizeof cnt);     }     return 0; } /* 1 10 5 1 1 2 2 3 3 4 4 5 5 */ 
//Author : pakhandi // using namespace std;  #include<bits/stdc++.h>  #define wl(n) while(n--) #define fl(i,a,b) for(i=a; i<b; i++) #define rev(i,a,b) for(i=a; i>=b; i--)  #define si(n) scanf("%d", &n) #define sll(l) scanf("%lld",&l) #define ss(s) scanf("%s", s) #define sc(c) scanf("%c", &c) #define sd(f) scanf("%lf", &f)  #define pi(n) printf("%d\n", n) #define pll(l) printf("%lld\n", l) #define ps(s) printf("%s\n", s) #define pc(c) printf("%c\n", c) #define pd(f) printf("%lf\n", f)  #define debug(x) cout<<"\n#("<<x<<")#\n" #define nline printf("\n")  #define mem(a,i) memset(a,i,sizeof(a))  #define MOD 1000000007 #define ll long long int #define u64 unsigned long long int  #define mclr(strn) strn.clear() #define ignr cin.ignore() #define PB push_back #define SZ size #define MP make_pair #define fi first #define sec second  int objects, turns, colors; std::vector<pair<int,int> > range;  double dp[51][51][102];  double rec(int turn, int ind, int color) { 	if(turn == turns) 	{ 		return color; 	}  	double &ret = dp[turn][ind][color]; 	if(ret >= 0) 		return ret;  	ret = 0.0;  	int i, j;  	int l = range[turn].first, r = range[turn].second;  	if(ind >= l && ind <= r) 	{ 		fl(i,0,colors) 		{ 			ret += rec(turn + 1, ind, (color * i) % colors) * 0.5 * ( 1 / (colors * 1.0) ); 		}  		ret += rec(turn + 1, ind, color) * 0.5; 	} 	else 	{ 		ret += rec(turn + 1, ind, color); 	}  	return ret; }  int main() { 	int i, j, k;  	int cases;  	si(cases);  	wl(cases) 	{  		fl(i,0,51) 			fl(j,0,51) 				fl(k,0,102) 					dp[i][j][k] = -1.0;  		range.clear();  		si(objects);	si(colors);	si(turns);  		fl(i,0,turns) 		{ 			int l, r; 			si(l);	si(r); 			l--;	r--; 			range.PB(MP(l,r)); 		}  		double ans = 0.0;  		fl(i,0,objects) 		{ 			ans += rec(0,i,1); 		}  		printf("%.10lf\n", ans);  	}   	return 0; } /* 	Powered by Buggy Plugin */ 
#include <iostream> #include <cstring> #include <cstdio> #include <cmath> #include <algorithm>  using namespace std;  const int maxn = 200000;  int T,n,m,a[maxn],b[maxn],c[maxn],d[maxn]; double ans;   int getsum(int k) {     if (k == 0) return 0;     int x = 0;     while (k) {           x += c[k];           k -= k&-k;     }     return x; }  void insert(int k) {      while (k <= maxn/2) {            c[k]++;            k += k&-k;      } }  int main() {     #ifndef ONLINE_JUDGE     freopen("1.in","r",stdin);     freopen("1.out","w",stdout);     #endif     scanf("%d",&T);     for (int kase = 1;kase <= T; kase++) {         scanf("%d%d",&n,&m); memset(c,0,sizeof(c)); ans = 0;         for (int i = 1;i <= n; i++) scanf("%d",&a[i]);         for (int i = 1;i <= m; i++) scanf("%d",&b[i]);         for (int i = 1;i <= n; i++) {              ans += (getsum(maxn/2)-getsum(a[i]));              insert(a[i]);             }         sort(b+1,b+m+1); d[1] = 0;         for (int i = 2;i <= m; i++) {              if (b[i] == b[i-1]) d[i] = d[i-1];              else d[i] = i-1;              ans += d[i]/2.0;         }         memset(c,0,sizeof(c));         for (int i = 1;i <= m; i++) insert(b[i]);         for (int i = 1;i <= n; i++) {             int w1 = getsum(a[i]-1),w2 = getsum(maxn/2)-getsum(a[i]);             ans += i*1.0/(n+1)*w2+(n+1-i)*1.0/(n+1)*w1;         }         printf("%.9lf\n",ans);     }     return 0; } 
//aL > ai < aj > ak < aR. #include <stdio.h> #include <stdlib.h> #include <iostream> #include <string.h> #include <algorithm> #include <math.h> #include <vector> #include <queue> #include <set> #include <stack> #include <map> #define INF_MAX 2147483647 #define INF_MIN -2147483647 #define INF_LL 9223372036854775807LL #define INF 2000000000 #define PI acos(-1.0) #define inf INT_MAX #define llu unsigned long long int #define all(v) v.begin(),v.end() #define pb push_back // #define mp make_pair #define F first #define S second #define si(n) scanf("%d",&n) #define slli(n) scanf("%lld",&n); #define ss(n) scanf("%s",n); using namespace std; typedef long long int LL;  void update(int *bit , int index , int val){ 	while(index < 10000){ 		bit[index]+=val; 		index+=(index)&(-index); 	} }  int query(int *bit , int index){ 	int ret = 0; 	while(index>0){ 		ret = ret + bit[index]; 		index-=(index)&(-index); 	} 	return ret; }  int A[10000]; int tree[4][20000]; int ans[2010][2010];  std::vector<int > allvalues; std::map<int , int > mp;  int main() { int N , Q , len , counter = 1; si(N);si(Q); for(int i=1;i<=N;i++) { 	si(A[i]); 	allvalues.pb(A[i]); } sort(allvalues.begin() , allvalues.end()); len = allvalues.size(); mp[allvalues[0]] = counter++; for(int i=1;i<len;i++){ 	if(allvalues[i]!=allvalues[i-1]) 		mp[allvalues[i]] = counter++; }  for(int i=1;i<=N;i++) 	A[i] = mp[A[i]];    memset(tree , 0 , sizeof(tree));  for(int i=1;i<=N;i++) { 	memset(tree , 0 , sizeof(tree)); 	for(int j=i+1;j<=N;j++) 	{ 	 	if(A[j] < A[i]) 		update(tree[0] , A[j] , 1); 	update(tree[1] , A[j] , query(tree[0] , A[j]-1)); 	 		//aL > ai < aj > ak  	update(tree[2] , A[j] , query(tree[1] , 10000) - query(tree[1] , A[j])); 	//aL > ai < aj  	//aL > ai 	 	//updating A[i] 	// update(tree[0] , A[i] , 1); 	// cout << i << "#$#" << query(tree[3] , A[i]-1) << endl; 	ans[i][j] =  query(tree[2] , A[j]-1); 	//aL > ai < aj > ak < aR. 	// ans = ans + query(tree[3] , A[i]-1); 	} }  int L , R;  while(Q--) { 	si(L);si(R); 	printf("%d\n", ans[L][R]); }   // printf("%d\n", ans);  return 0; }       
#include <stdio.h> #include <algorithm> #include <math.h> #include <vector>  using namespace std; #define eps 1e-7 #define all(v) (v).begin(), (v).end() const double Pi = acos(-1.0);  inline int cmp(double x, double y = 0, double tol = eps) { 	return (x <= y + tol) ? (x + tol < y) ? -1 : 0 : 1; }  struct point { 	double x, y, z; 	point(double x = 0, double y = 0): x(x), y(y) {} 	point operator +(point q) { return point(x + q.x, y + q.y); } 	point operator -(point q) { return point(x - q.x, y - q.y); } 	point operator *(double t) { return point(x * t, y * t); } 	point operator /(double t) { return point(x / t, y / t); } 	double operator *(point q) { return x * q.x + y * q.y; } //produto escalar 	double operator %(point q) { return x * q.y - y * q.x; } //produto cruzado 	double polar() { return ((y > -eps) ? atan2(y,x) : 2*Pi + atan2(y,x)); } //nao trocar comparacao por cmp(y)>=0 	double mod() { return sqrt(x * x + y * y); }  	int cmp(point q) const { 		if (int t = ::cmp(x, q.x)) return t; 		return ::cmp(y, q.y); 	} 	bool operator ==(point q) const { return cmp(q) == 0; } 	bool operator !=(point q) const { return cmp(q) != 0; } 	bool operator < (point q) const { return cmp(q) < 0; } 	static point pivot; }; int n; double r, l; point p[51000]; struct no { 	double a, b; 	bool operator<(const no &e) const { 		return a < e.a-eps; 	} }; no q[51000]; int top;  bool possivel(double h) { 	top = 0; 	double d; 	for (int i = 0; i < n; i++) if (cmp(h, p[i].y) < 0) { 		d = tan(p[i].z) * (p[i].y-h); 		//printf("r=%lf   l=%lf  d=%lf\n", r, l, d);   		if (!(cmp(p[i].x+d, r) <  0 || cmp(p[i].x-d, l) > 0)) { 			q[top].a = p[i].x-d; 			q[top].b = p[i].x+d; 			top++; 		} 	} 	//printf("top=%d\n", top); 	sort(q, q+top); 	if (top==0 || cmp(q[0].a, r) > 0) return false; 	double fim = q[0].b; 	for (int i = 1; i < top; i++) { 		if (cmp(fim, q[i].b) >= 0) continue; 		if (cmp(fim, q[i].a) < 0) return false; 		 		fim = q[i].b; 	} 	return cmp(fim, l) >= 0; }  double busca(double ini, double fim) { 	double mid; 	for (int i = 0; i < 50; i++) { 		mid = 0.5*(ini+fim); 		if (possivel(mid)) ini = mid; 		else fim = mid; 	} 	return ini; }  int main() { 	double maxx=-1; 	scanf("%d %lf %lf", &n, &r, &l); 	for (int i = 0; i < n; i++) { 		scanf("%lf %lf %lf", &p[i].x, &p[i].y, &p[i].z); 		p[i].z = Pi*p[i].z / 180; 		if (cmp(maxx, p[i].y) < 0) maxx = p[i].y; 	} 	//printf("%d\n",	possivel(3.4)); 	printf("%.8lf\n", busca(0, maxx)); 	return 0; } 
#include <cstdio> #include <cmath>  int main() {     //freopen("input.txt","r",stdin);     int t,d,flag=0;     double A,P,Q;     int a,p,q;     unsigned long long N,D;     scanf("%d",&t);     while(t--)     {         scanf("%lf%lf%lf%d",&A,&P,&Q,&d);         a=(int)(A*100+0.5);         p=(int)(P*100+0.5);         q=(int)(Q*100+0.5);         N = (p*a*(100-a)+100*a*q);         D = 100 * (100-a)*(100-a);         d++;         flag=0;         while(d--)         {             printf("%llu",N/D);             if(flag==0)                 printf("."),flag=1;             N=N%D;             N=N*10;         }         printf("\n");     } } 
#include<cstdio> #include<cstring> int i,j,T,N,x,Ans; int f[505],g[255]; int main() { 	for(i=0;i<=250;++i) 	{ 		memset(f,0,sizeof(f)); 		for(j=1;j<=(i-2);++j) f[g[j]^g[i-j]]=f[g[j]^g[i-j-1]]=1; 		if(i>1) f[g[i-1]^g[1]]=1; 		for(g[i]=0;f[g[i]];++g[i]); 	} 	for(scanf("%d",&T);T--;) 	{ 		scanf("%d",&N),Ans=0; 		for(i=0;i<N;++i) scanf("%d",&x),Ans^=g[x]; 		if(Ans) printf("Alice\n"); 		else printf("Bob\n");     } 	return 0; } 
#include<bits/stdc++.h> #include<iostream> #define ll int #define ll1 long long #define maxn 100009 #define inf 1000000009 using namespace std; vector<ll> primes; ll mod=1000000007; ll primepro[maxn+7],primeinv[maxn+9],c[1000009],d[1000009]; //inline int getchar_unlocked() { return getchar(); } ll scan() {     register int n = 0, ch = getchar_unlocked();     while (ch < '0' || ch > '9')         ch = getchar_unlocked();     while (ch >= '0' && ch <= '9') {         n = (n << 3) + (n << 1) + ch - '0';         ch = getchar_unlocked();     }     return n; } void markMultiples(bool arr[], int a, int n) { 	int num = 2 * a; 	while (num <= n) { 		arr[num - 1] = 1; 		num += a; 	} } void SieveOfEratosthenes(int n) { 	if (n >= 2) { 		bool arr[n]; 		memset(arr, 0, sizeof(arr)); 		for (int i = 1; i < n; ++i) { 			if (arr[i] == 0) { 				primes.push_back(i + 1); 				markMultiples(arr, i + 1, n); 			} 		} 	} } int powmod(int base, int exponent) { 	ll x = 1, y = base; 	while (exponent > 0) { 		if (exponent % 2 == 1) { 			x = (x * (ll1)y)%mod; 		} 		y = (y * (ll1)y)%mod; 		exponent/=2; 	} 	return x; } int modularMultiplicativeInverse(int a) { 	return powmod(a, mod - 2); } ll get(ll n,ll k) { 	if(n==k) 	return k; 	ll tmp,high,low,i,j,l,ct,ct1,temp,ans,a,b; 	i=0; 	ans=1; 	ll lowchk; 	while(primes[i]*primes[i]<=k) 	{ 		ll num=primes[i]; 		temp=1; 		//lowchk=num; 		while(num<=k) 		{ 			a=(n-1)/num; 			++a; 			b=k/num; 			if(a<=b) 			{ 				temp=num; 				num=num*primes[i]; 			} 			else 			break; 		} 		//cout<<temp<<endl; 		if(temp!=1) 		ans=(ans*(ll1)temp)%mod; 		++i; 	} 	//printf("%d\n",ans); 	 ll highchk; 	 highchk=inf; 	ll div=1; 	lowchk=sqrt(k); 	while(lowchk+1<highchk) 	{ 		low=(n-1)/div; 		++low; 		high=k/div; 		if(high>=highchk) 		{ 			high=highchk-1; 		} 		if(low<=lowchk) 		{ 			low=lowchk+1; 			highchk=-199; 		} 		if(low<=high) 		{ 			temp=((ll1)primepro[high]*(ll1)primeinv[low-1])%mod; 			ans=(ans*(ll1)temp)%mod; 		} 		highchk=min(highchk,low); 		div=max(div+1,k/highchk); 		//cout<<ans<<endl; 	} 	return ans; } int main() { 	 	ll j,t,n,ans,prev,tmp,temp,a,b,m,k; 	/*for(i=1; i<16; i++) 	{ 		printf("%d\n",get(i,15)); 	}*/ 	int NN = 100005; 	SieveOfEratosthenes(NN); 	ll lastprod = 2; 	primepro[0] = 1; 	primeinv[0] = primepro[1]=primeinv[1]=1; 	primepro[2] = 2; 	primeinv[2] = modularMultiplicativeInverse(2); //	cout<<primeinv[2]<<endl; 	int x = 0; 	for (int i = 1; i < primes.size(); i++) { 		lastprod = (lastprod * (ll1)primes[i])%mod; 		if(primes[i] < 100005){ 			primepro[primes[i]] = lastprod; 			if(lastprod == 1) 				primeinv[primes[i]] = 1; 			else 				primeinv[primes[i]] = modularMultiplicativeInverse(lastprod); 		} 	} 	for(int i =1; i <100005; i++){ 		if(primepro[i] == 0){ 			primepro[i] = primepro[i-1]; 			primeinv[i] = primeinv[i-1]; 		} 	} 	//cout<<primeinv[2]<<endl; 	t=scan(); 	n=scan(); 	k=scan(); 	a=scan(); 	b=scan(); 	m=scan(); 	ans=get(n-k+1,n); 	ll i;    // getting the answer 	for(i=0; i<t-1; i++) 	{ 		c[i]=scan(); 	} 	for(i=0; i<t-1; i++) 	{ 		d[i]=scan(); 	} 	ll thl; 	for(i=0; i<t-1; i++) 	{ 		printf("%d\n",ans); 		thl=(a*(ll1)ans)%m; 		n=1+(thl+(ll1)c[i])%m; 		thl=(b*(ll1)ans)%n; 		k=1+(thl+(ll1)d[i])%n;  		ans=get(n-k+1,n); 	} 		printf("%d\n",ans); 	return 0; }
#include<bits/stdc++.h> using namespace std;  typedef pair<int,int> II; typedef vector< II > VII; typedef vector<int> VI; typedef vector< VI > VVI; typedef long long int ll;  #define PB push_back #define MP make_pair #define F first #define S second #define SZ(a) (int)(a.size()) #define ALL(a) a.begin(),a.end() #define SET(a,b) memset(a,b,sizeof(a))  #define si(n) scanf("%d",&n) #define dout(n) printf("%d\n",n) #define sll(n) scanf("%lld",&n) #define lldout(n) printf("%lld\n",n) #define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)  #define TRACE  #ifdef TRACE #define trace(...) __f(#__VA_ARGS__,__VA_ARGS__) /*template <typename Arg1> void __f(const char * name, Arg1&& arg1){     cerr << name << " : " << arg1 << std::endl; } template <typename Arg1, typename... Args> void __f(const char* names, Arg1&& arg1, Args&&... args){     const char* comma = strchr(names + 1,',');cerr.write(names,comma - names) << " : " << arg1<<" | ";__f(comma+1,args...); }*/ #else #define trace(...) #endif ll max(ll p,ll q) {     return (p>q)?p:q; } ll min(ll p,ll q) {     return (p<q)?p:q; }  vector<ll> b;  ll merge(ll left,ll mid,ll right) {     ll val,i,j,k,n1=mid-left+1,n2=right-mid;     ll l[n1+2],r[n1+2];     for(i=0;i<n1;i++)     {         l[i]=b[left+i];     }     for(i=0;i<n2;i++)     {         r[i]=b[mid+1+i];     }     val=0;     i=0;j=0;k=left;     while(i<n1 && j<n2)     {         if(l[i]<=r[j])         {             b[k++]=l[i++];         }         else         {             //cout << i << " " << mid << " " << left << endl << endl;             b[k++]=r[j++];             val+=mid-i-left+1;         }     }     while(i<n1)     {         b[k++]=l[i++];     }     while(j<n2)     {         b[k++]=r[j++];     }     return val; }  ll mergesort(ll l,ll r) {     ll val=0;     if(l<r)     {         ll m=(l+r)/2;         val=mergesort(l,m);       //  cout << l << " " << r << " " << val << endl;         val+=mergesort(m+1,r);     //    cout << l << " " << r << " " << val << endl;         val+=merge(l,m,r);         //cout << l << " " << r << " " << val << endl;         return val;     }     return val; }  int main() {     vector< pair< ll, ll > > a;     ll n,i,ans,temp1,temp2;     sll(n);     for(i=0;i<n;i++)     {         sll(temp1);         sll(temp2);         a.PB(MP(temp1,temp2));     }     //cout << "888\n";     sort(ALL(a));     for(i=0;i<n;i++)     {         b.PB(a[i].S);         //cout << b[i] << " ";     }     //cout << endl;     ans=mergesort(0,n-1);     /*for(i=0;i<n;i++)     {         //b.PB(a[i].S);         cout << b[i] << " ";     }     cout << endl;*/     lldout(ans);     return 0; } 
#include <cstdio> #include <queue>   #define maxN 200000 #define maxM 300000   using namespace std;   int n,m,k;   int elso[maxN]; int kov[maxM*2]; int hova[maxM*2]; int y[maxM];   bool eler[maxN]; bool eler2[maxN];   int x[maxN];   /* void bejar(int kezd) {     if(kezd > n) throw 101;     eler[kezd] = 1;     for(int i=elso[kezd]; i>=0; i=kov[i]) {         if(!eler[hova[i]]) bejar(hova[i]);     } }   bool beir(int kezd, int sz) {     if(kezd > n) throw 101;     x[kezd] = sz;     eler2[kezd] = 1;     for(int i=elso[kezd]; i>=0; i=kov[i]) {         if(eler2[hova[i]]) {             if((x[kezd] ^ x[hova[i]]) != y[i%maxM]) return 0;         } else {             if(!beir(hova[i],(x[kezd] ^ y[i%maxM]))) return 0;         }     }     return 1; }*/   queue<int> jarsor; queue<pair<int,int> > irsor;   int main() {     scanf("%d%d%d",&n,&m,&k);       for(int i=0; i<n; i++) {         elso[i] = -1;     }       for(int i=0; i<m; i++) {         scanf("%d%d%d",&hova[i],&hova[i+maxM],&y[i]);         hova[i]--; hova[i+maxM]--;         kov[i] = elso[hova[i+maxM]];         elso[hova[i+maxM]] = i;         kov[i+maxM] = elso[hova[i]];         elso[hova[i]] = i+maxM;     }       int resz = 0;     for(int i=0; i<n; i++) {         if(!eler[i]) {             resz++;             jarsor.push(i);             while(!jarsor.empty()) {                 int kezd = jarsor.front();                 jarsor.pop();                 eler[kezd] = 1;                 for(int i=elso[kezd]; i>=0; i=kov[i]) {                     if(!eler[hova[i]]) jarsor.push(hova[i]);                 }               }             //bejar(i);         }     }         for(int i=0; i<n; i++) {         if(!eler2[i]) {             if(--resz) {                 irsor.push(make_pair(i,0));                 while(!irsor.empty()) {                     int kezd = irsor.front().first;                     int sz = irsor.front().second;                     irsor.pop();                     x[kezd] = sz;                     eler2[kezd] = 1;                     for(int i=elso[kezd]; i>=0; i=kov[i]) {                         if(eler2[hova[i]]) {                             if((x[kezd] ^ x[hova[i]]) != y[i%maxM]) {                                 printf("-1\n");                                 return 0;                             }                         } else {                             irsor.push(make_pair(hova[i],(x[kezd] ^ y[i%maxM])));                         }                     }                 }                 /*if(!beir(i,0)) {                     printf("-1\n");                     return 0;                 }*/             } else {                 irsor.push(make_pair(i,k-1));                 /*if(!beir(i,k-1)) {                     printf("-1\n");                     return 0;                 }*/             }             while(!irsor.empty()) {                 int kezd = irsor.front().first;                 int sz = irsor.front().second;                 irsor.pop();                 x[kezd] = sz;                 eler2[kezd] = 1;                 for(int i=elso[kezd]; i>=0; i=kov[i]) {                     if(eler2[hova[i]]) {                         if((x[kezd] ^ x[hova[i]]) != y[i%maxM]) {                             printf("-1\n");                             return 0;                         }                     } else {                         irsor.push(make_pair(hova[i],(x[kezd] ^ y[i%maxM])));                     }                 }             }         }     }       for(int i=0; i<n; i++) {         printf("%d ",x[i]);     }     printf("\n");       return 0; }
#include <vector> #include <list> #include <map> #include <set> #include <deque> #include <queue> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <cctype> #include <string> #include <cstring> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #define eps 1e-9 #define FOR(x, s, e) for(int x = (s); x < (e); ++x) #define FORc(x, s, e, c) for(int x = (s); x < (e) && (c); ++x) #define STEP(x, s, e, d) for(int x = (s); x < (e); x+=(d)) #define ROF(x, s, e) for(int x = (s); x >= (e); --x) #define ROFc(x, s, e, c) for(int x = (s); x >= (e) && (c); --x) #define vb vector<bool> #define vi vector<int> #define vii vector<pair<int, int> > #define vs vector<string> #define pb push_back #define mp make_pair #define ALL(X) X.begin(), X.end() #define LL long long #define pii pair<int, int> #define x first #define y second #define gcd(x, y) __gcd((x), (y)) #define countbit(x) __builtin_popcount(x)  using namespace std;  map<string, int> D;  vs P[51];  void clear(string s){     int L = s.length();     string t;     ROF(i, L-1, 0){         t += s[i];         int q = --D[t];         if (!q) D.erase(t);     } }  void add(string s){     int L = s.length();     string t;     ROF(i, L-1, 0){         t += s[i];         D[t]++;     } }  void precal(string s){     int L = s.length();     string t[2] = {"4", "7"};     FOR(i, 0, 2){         string q = s + t[i];         add(q);         if (D.size() <= 50){             P[(int)D.size()].pb(q);             precal(q);         }         clear(q);     } }  struct cmp{     bool operator()(const string &A, const string &B)const{         return A.length() < B.length();     } };  int main(int argc, char **argv){     precal("");     FOR(i, 1, 51) sort(ALL(P[i]), cmp());     int T;     scanf("%d", &T);     FOR(ca, 0, T){         int N, K;         scanf("%d%d", &N, &K);         char line[100];         scanf("%s", line);         int res = 0;         FOR(k, 1, K+1)             FORc(i, 0, P[k].size(), P[k][i].length() <= N)                 if (P[k][i].length() == N){                     bool ok = 1;                     FORc(j, 0, N, ok)                         ok = (line[j] == '?') || (line[j] == P[k][i][j]);                     res += ok;                 }         printf("%d\n", res);     }     return 0; } 
#include<bits/stdc++.h>  #define gc getchar_unlocked #define pc putchar_unlocked  using namespace std;   typedef vector<int> vi; int sol[1001][1001];  inline int inp() {     int n = 0, c = gc(), f = 1;     while(c != '-' && (c < '0' || c > '9')) c = gc();         if(c == '-')         {             f = -1;             c = gc();         }     while(c >= '0' && c <= '9')         n = (n<<3) + (n<<1) + c - '0', c = gc();     return n * f; }  void op(int n) { 	if(n<0) 	{  n=-n; 	   pc('-'); 	} 	int i=10;char output_buffer[11]; 	output_buffer[10]='\n'; 	do{output_buffer[--i]=(n%10)+'0';n/=10;} 	while(n); 	do{pc(output_buffer[i]);}     while(++i<10); }   inline void dfs(vector<vi>&adj,vector<int>&path,bool visited[],int current) {     visited[current]=true;     path.push_back(current);     vi temp=adj[current];     for(vi::iterator p=temp.begin();p!=temp.end();p++)     {         if(!visited[*p])             dfs(adj,path,visited,*p);     } }  inline void build(vi&path,int m,int no) {     int i,j,k,l,n;     n=path.size();     no+=n*m-1;     l=0;     k=path[l];     for(i=m-1;i>=0;i--)     {         for(j=0;j<=n-1;j++)         {             sol[k][i]=no;             no--;             if(j==n-1)                 continue;             l++;             if(l==path.size())                 l=0;             k=path[l];         }     } }  inline void special(vector<int>&path,int no) {     int i,j,k;     i=path[0];     j=path[1];     k=path[2];     no--;     sol[i][0]=no+3;     sol[i][1]=no+5;     sol[i][2]=no+6;     sol[i][3]=no+12;     sol[j][0]=no+2;     sol[j][1]=no+4;     sol[j][2]=no+9;     sol[j][3]=no+11;     sol[k][0]=no+1;     sol[k][1]=no+7;     sol[k][2]=no+8;     sol[k][3]=no+10; } int main() {     int i,j,k,l,tc,n,m;     tc = inp();     while(tc--)     {         n = inp(); m = inp();         int arr[n];         for(i=0;i<=n-1;i++)             arr[i] = inp();         if(m==1||m==2)            { pc('N'); pc('o'); pc(' '); pc('S'); pc('o'); pc('l'); pc('u'); pc('t');              pc('i'); pc('o'); pc('n'); pc('\n');            }         else         {             vector<vi>adj;             adj.clear();             vi *temp;             for(i=0;i<=n-1;i++)             {                 temp=new vi;                 adj.push_back(*temp);             }             for(i=0;i<=n-1;i++)             {                 adj[i].push_back(arr[i]);                 adj[arr[i]].push_back(i);             }             bool visited[n];             for(i=0;i<=n-1;i++)                 visited[i]=false;             vector<int>path;             int flag=0;             int no=0;             for(i=0;i<=n-1;i++)             {                 if(!visited[i])                 {                     path.clear();                     dfs(adj,path,visited,i);                     if(path.size()==1||path.size()==2)                     {                         flag=1;                         break;                     }                     else if(m==4&&path.size()==3)                         special(path,no+1);                     else                         build(path,m,no+1);                     no+=path.size()*m;                 }             }            if(flag==1)            { pc('N'); pc('o'); pc(' '); pc('S'); pc('o'); pc('l'); pc('u'); pc('t');              pc('i'); pc('o'); pc('n'); pc('\n');            }             else             {                 for(i=0;i<=n-1;i++)                 {                     for(j=0;j<=m-2;j++)                     {                        op(sol[i][j]);                        pc(' ');                     }                     op(sol[i][m-1]);                     pc('\n');                 }             }         }     }     return 0; } 
#include <iostream> #include <cstdio> #include <cstring> #include <algorithm> using namespace std;  long long dp[55][515]; char s[55][20]; int n;  int get_state(int y,int m,int state) { 	if(strlen(s[y]) > m) return -1; 	int new_state = 0; 	for(int i = 0; i < strlen(s[y]); i ++) { 		int p = state & (1 << i); 		if(p == 0 && s[y][i] > '4') return -1; 		if(p && s[y][i] > '7') return -1; 		if((state & (1 << i)) && s[y][i] == '7') new_state |= (1 << i); 	        if(!(state & (1 << i)) && s[y][i] == '4') new_state |= (1 << i);	 	} 	return new_state; }  long long solve(int m,int state) { 	for(int i = 0; i <= n; i ++) 		for(int j = 0; j < (1 << m); j ++) 			dp[i][j] = 0; 	dp[0][0] = 1; 	for(int i = 0; i < n; i ++) { 		for(int j = 0; j < (1 << m); j ++) 			dp[i + 1][j] += dp[i][j]; 		int new_state = get_state(i + 1,m,state); 		if(new_state == -1) continue; 		for(int j = 0; j < (1 << m); j ++) 			dp[i + 1][j | new_state] += dp[i][j]; 	} 	return dp[n][(1 << m) - 1]; }  int main() { 	int t; 	scanf("%d",&t); 	while(t --) { 		scanf("%d",&n); 		for(int i = 1; i <= n; i ++) { 			scanf("%s",s[i]); 			reverse(s[i],s[i] + strlen(s[i])); 		} 		long long ans = 0; 		for(int i = 1; i < 10; i ++) { 		       for(int j = 0; j < (1 << i); j ++) { 			       ans += solve(i,j); 		       } 		} 		cout << ans << endl; 	} 	return 0; }  
    #include <iostream>     #include <stdio.h>     using namespace std;           class LuckyNumber     {     long iCj[11][11];     long fTable[11][11];     inline int getLCnt(int n){     int in=0;if(n>=4) in++;if(n>=7) in++;     return in;     }     inline long getF(int r,int i){     return iCj[r][i]<<((r<<1)+r-(i<<1));     }     void calculateFTable(){     int lcnt;     lcnt=getLCnt(m[1]);     fTable[1][0]=m[1]-lcnt+1;fTable[1][1]=lcnt;     for(int d=2;d<=length;d++){     lcnt=getLCnt(m[d]-1);     fTable[d][0]=(m[d]-lcnt)*getF(d-1,0)+((m[d]==4||m[d]==7)?0:fTable[d-1][0]);     for(int f=1;f<d;f++){     fTable[d][f]=(m[d]-lcnt)*getF(d-1,f)+lcnt*getF(d-1,f-1)+((m[d]==4||m[d]==7)?fTable[d-1][f-1]:fTable[d-1][f]);     }     fTable[d][d]=lcnt*getF(d-1,d-1)+((m[d]==4||m[d]==7)?fTable[d-1][d-1]:0);     }     fTable[length][0]--;     }     public:     short length;     short tmp[12],*m;     LuckyNumber(){     //initialize iCj     iCj[1][0]=iCj[1][1]=1;     for(int i=2;i<=10;i++)     {     iCj[i][0]=iCj[i][i]=1;     for(int j=1;j<=i/2;j++){     iCj[i][j]=iCj[i][i-j]=iCj[i][j-1]*(i-j+1)/j;     }     }     }     inline void getM()     {     int i=11;     while(((tmp[i]=getchar())<'0' || tmp[i]>'9') && tmp[i]!=EOF);     length=0;     do{     tmp[i]-='0';     length++;i--;     }while((tmp[i]=getchar())>='0' && tmp[i]<='9');     m=&tmp[i];     calculateFTable();     return;     }     long getCount(int len,int fval,bool respectMax=true){     return respectMax ? fTable[len][fval] : getF(len,fval);     }     long getCount(int fval){     return fTable[length][fval];     }     void printTable(){     cout<<"\n=========F Table======m=";     for(int i=length; i>0;i--)cout<<m[i];     cout<<endl;     for(int i=1;i<=length;i++){     cout<<endl<<"d"<<i<<"::";     for(int j=0;j<=i;j++)cout<<"F("<<j<<")="<<fTable[i][j]<<" ";     }     }     };           class LuckyArray     {     public:     LuckyNumber ln;     long long CF[51][11],k;     int C[50];     int n;     inline void calculateCFTable(){     for(int i=0;i<=ln.length;i++)CF[n][i]=1;     for(int i=n-1;i>=1;i--){     for(int j=0;j<=ln.length;j++){     if(C[i]){     if(CF[i+1][j]==-1)CF[i][j]=-1;     else CF[i][j]=CF[i+1][j]*ln.getCount(j);     }     else{     CF[i][j]=0;     for(int k=0;k<=ln.length;k++){     if(k==j) continue;     if(CF[i+1][k]==-1){CF[i][j]=-1;break;}     else CF[i][j]+=CF[i+1][k]*ln.getCount(k);     }     }     if(CF[i][j]>k)CF[i][j]=-1;     }     }     }     void printCFTable(){     cout<<"\n=========CCCF Table======c=";     for(int i=1; i<n;i++)cout<<C[i];     cout<<endl;     for(int i=1;i<=n;i++){     cout<<endl<<"n="<<i<<"::";     for(int j=0;j<=ln.length;j++)cout<<"CF("<<j<<")="<<CF[i][j]<<" ";     }     cout<< endl;     }     void getSequece(){     calculateCFTable();     //check here for impossibility     //printCFTable();     int count=0;     for(int i=0;i<=ln.length;i++){     if(CF[1][i]==-1){count=-1;break;}     count+=ln.getCount(i)*CF[1][i];     if(count>k)break;     }     if(count!=-1 && count<k){printf("-1\n");return;}     getRth(1,-1);     printf("\n");     }     void getRth(int r,int prevFval){     if(r>n) return;     int end;     bool respMax=true,iterComplete,gotZerosOnly=true;     long tmp;     short currResult[11];     long long count,curr,cnt1,cnt2,lucky_cnt;     lucky_cnt=0;     //printf("\n============%dth Number=============\n",r);     for(int p=ln.length;p>=1;p--){     end=respMax ? ln.m[p]-1 : 9;     count=0;iterComplete=false;cnt2=cnt1=-2;     for(int i=((p==1&&gotZerosOnly)? 1: 0);i<=end;i++){     if(i==0){     curr=countSequences(r,p-1,lucky_cnt,false,prevFval,gotZerosOnly);     }     else if(i==4 || i==7){     if(cnt2<-1)cnt2=countSequences(r,p-1,lucky_cnt+1,false,prevFval,false);     curr=cnt2;     }else{     if(cnt1<-1)cnt1=countSequences(r,p-1,lucky_cnt,false,prevFval,false);//for except 4,7;     curr=cnt1;     }     if(curr==-1 || count+curr >= k){     k-=count;     respMax=false;     currResult[p]=i;     if(i==4 || i==7)lucky_cnt+=1;     if(gotZerosOnly && currResult[p]!=0)gotZerosOnly=false;     iterComplete=true;     break;     }else count+=curr;     }     if(!iterComplete){     k-=count;     currResult[p]=ln.m[p];     if(gotZerosOnly && currResult[p]!=0)gotZerosOnly=false;     if(ln.m[p]==4 || ln.m[p]==7)lucky_cnt+=1;     }     //printContext(currResult,p,curr);     }     end=ln.length;     for(end=ln.length;currResult[end]==0;end--);     while(end>0){printf("%d",currResult[end]);end--;}     printf(" ");     getRth(r+1,lucky_cnt);     }     void printContext(short currResult[],int p,long long curr)     {     for(int end=ln.length;end>=p;end--){printf("%d",currResult[end]);}     for(int i=p-1;i>=1;i--){     printf("-");     }     printf("(k=%lld,curr=%lld)\n",k,curr);     }     inline long long countSequences(int r,int p,int lcnt,bool respMax,int prevFval,bool gotZerosOnly){     if(p==0){     if(r==1 || (C[r-1] && prevFval==lcnt) || (!C[r-1] && prevFval!=lcnt)) return CF[r][lcnt];     else return 0;     }     long long count=0;     int excl=-1,st,end;     if(r==1){st=0;end=p;}     else if(C[r-1]){     st=end=prevFval-lcnt;     if(st<0 || st>p)return 0;     }     else{st=0;end=p;excl=prevFval-lcnt;}     for(int i=st;i<=end;i++){     if(i==excl)continue;     if(CF[r][i+lcnt]==-1)return -1;     count+=ln.getCount(p,i,respMax)*CF[r][i+lcnt];     if(gotZerosOnly && (i==0))count-=CF[r][i+lcnt];     if(count>k)return -1;     }     return count;     }     };                 int main(){     LuckyArray la;     int T;     scanf("%d",&T);     for(int i=0;i<T;i++){     scanf("%d",&la.n);     la.ln.getM();     //la.ln.printTable();     scanf("%lld",&la.k);     for(int i=1;i<=la.n-1;i++)scanf("%d",&la.C[i]);     la.getSequece();     }     } 
/**  * June 2012 Codechef Long Contest  *  * Problem:     LUCKY8  * Author:      Anton Lunyov (Tester)  * Complexity:  O(T * log(R))  * Timing:      0.05 out of 2  */  #include <iostream> using namespace std;  typedef long long LL;  const int maxN = 19;  // returns the maximal value of F4(x) * F7(x) // if x has n4 fours and n7 sevens in prefix // has free suffix of length n int F(int n4,int n7,int n) { 	int k = (n7 + n - n4) / 2; 	if (0 <= k && k <= n) { 		return (n4 + k) * (n7 + n - k); 	} 	return max((n4 + n) * n7, n4 * (n7 + n)); }  // returns the maximal value of F4(x) * F7(x) // if x has n4 fours and n7 sevens in prefix // has free suffix of length n with additional // assumption that first digit of this suffix // must be from L to R inclusive int F(int L, int R, int n4, int n7, int n) { 	if (L > R) { 		return 0; 	} 	int ans = F(n4, n7, n); 	if (L <= 4 && 4 <= R) { 		ans = max(ans, F(n4 + 1, n7, n)); 	} 	if (L <= 7 && 7 <= R) { 		ans = max(ans, F(n4, n7 + 1, n)); 	} 	return ans; }  int main() { 	int T; 	cin >> T; 	for (int t=0;t<T;t++) { 		long long L, R; 		cin >> L >> R;  		int aL[maxN] = {0}; 		int nL = 0; 		while (L > 0) { 			aL[nL++] = L % 10; 			L /= 10; 		}  		int aR[maxN]={0}; 		int nR=0; 		while (R > 0) { 			aR[nR++] = R % 10; 			R /= 10; 		}  		int n = max(nL, nR);  		int n4 = 0, n7 = 0; 		int i, j; 		for (i = n - 1; i >= 0 && aL[i] == aR[i]; --i) { 			n4 += (aL[i] == 4); 			n7 += (aL[i] == 7); 		}  		int ans=0; 		if (i < 0) { 			ans = n4 * n7; 		} else { 			ans = max(ans, F(aL[i] + 1, aR[i] - 1, n4, n7, i));  			int c4 = n4; 			int c7 = n7; 			int j = i; 			while (true) { 				c4 += (aL[j] == 4); 				c7 += (aL[j] == 7); 				if (--j < 0) { 					break; 				} 				ans = max(ans, F(aL[j] + 1, 9, c4, c7, j)); 			} 			ans = max(ans, c4 * c7);  			c4 = n4; 			c7 = n7; 			j = i; 			while (true) { 				c4 += (aR[j] == 4); 				c7 += (aR[j] == 7); 				if (--j < 0) { 					break; 				} 				ans = max(ans, F(0, aR[j] - 1, c4, c7, j)); 			} 			ans = max(ans, c4 * c7); 		} 		cout << ans << endl; 	} 	return 0; }  
#include<iostream> #include<string> #include<cstdio> using namespace std;  #define MAX 5001 #define MOD 1000000007  int dp[MAX][MAX];  void compute() {     dp[1][1]=1;     for(int i=1;i<MAX;i++) dp[0][i]=dp[i][0]=1;      for(int i=1;i<MAX;i++)     {         for(int j=1;j<MAX;j++)         {             if(i==1 && j==1) continue;              dp[i][j]=(dp[i-1][j]+dp[i][j-1])%MOD;         }     } }  int main() {     compute();     int t;     scanf("%d",&t);     while(t--)     {         string str;         cin>>str;         int fCount=0,sCount=0;         for(int i=0;i<str.size();i++)         {             if(str[i]=='4')                 fCount++;             else                 sCount++;         }         printf("%d\n",dp[fCount][sCount]);     }     return 0; } 
#include <bits/stdc++.h> using namespace std; int n; int tot; #define N 10000 string s[N]; #define M 401000 int mn[M], son[M][2], len[N]; int root[N]; vector<int> fou[N], foq[N], sev[N], seq[N];  void push_up(int id) {     int l = son[id][0];     int r = son[id][1];     mn[id] = max(mn[l], mn[r]);     return ; }  int build(int id, int st, int en) {     ++tot;     int x = tot;     if(st == en) {         mn[tot] = fou[id][st] + sev[id][st + 1];         return tot;     }     int mid = (st + en) >> 1;     int y = build(id, st, mid);     int z = build(id, mid + 1, en);     son[x][0] = y;     son[x][1] = z;     push_up(x);     return x; }  int calc(int l, int r, int st, int en, int id) {     if(l > en || r < st) return 0;     if(l <= st && en <= r) return mn[id];     int mid = (st + en) >> 1;     int x = calc(l, r, st, mid, son[id][0]);     int y = calc(l, r, mid + 1, en, son[id][1]);     return max(x, y); }  bool can(int num, int num1, int gas) {     int va = 0;     for(int i = 1; i <= n; i ++) {         if(!num) {             if(num1 <= sev[i][len[i] - 1]) continue;             if(num1 > seq[i][len[i] - 1]) return false;             va += num1 - sev[i][len[i] - 1];             if(va > gas) return false;             continue;         }         if(!num1) {             if(num <= fou[i][len[i] - 1]) continue;             if(num > foq[i][len[i] - 1]) return false;             va += num - fou[i][len[i] - 1];             if(va > gas) return false;             continue;         }         if(num1 > seq[i][len[i] - 1]) return false;         if(num > foq[i][len[i] - 1]) return false;         int st = lower_bound(foq[i].begin(), foq[i].end(), num) - foq[i].begin();         int en = lower_bound(fou[i].begin(), fou[i].end(), num) - fou[i].begin();         int st1 = lower_bound(sev[i].begin(), sev[i].end(), num1) - sev[i].begin();         int en1 = lower_bound(seq[i].begin(), seq[i].end(), num1) - seq[i].begin();         st1 = len[i] - 1 - st1;         en1 = len[i] - 1 - en1;         st1 --;         en1 --;          if(st1 >= en) continue;         if(st > en1) return false;         st = max(st, st1);         en = min(en, en1);         va += num + num1 - calc(st, en, 0, len[i] - 1, root[i]);         if(va > gas) return false;     }     return true; }  int main() {     //freopen("3.in", "r", stdin);     int k;     tot = 0;     scanf("%d%d", &n, &k);     for(int i = 1; i <= n; i ++) {         cin >> s[i];         len[i] = s[i].length();     }     int mn = 0;     for(int i = 1; i <= n; i ++) {         if(mn == 0) mn = len[i];         else if(mn > len[i]) mn = len[i];     }     for(int i = 1; i <= n; i ++) {         fou[i].resize(len[i]);         sev[i].resize(len[i]);         foq[i].resize(len[i]);         seq[i].resize(len[i]);         for(int j = 0; j < len[i]; j ++) {             int x = 0;             int y = 0;             if(j) x = fou[i][j - 1], y = foq[i][j - 1];             fou[i][j] = x + (s[i][j] == '4');             foq[i][j] = y + (s[i][j] == '4');             foq[i][j] += (s[i][j] == '?');         }         for(int j = len[i] - 1; j >= 0; j --) {             int x = 0, y = 0;             if(j < len[i] - 1) x = sev[i][j + 1], y = seq[i][j + 1];             sev[i][j] = x + (s[i][j] == '7');             seq[i][j] = y + (s[i][j] == '7');             seq[i][j] += (s[i][j] == '?');         }         root[i] = build(i, 0, len[i] - 1);         reverse(sev[i].begin(), sev[i].end());         reverse(seq[i].begin(), seq[i].end());     }     int gas = mn;     long long ans = 0;     for(int i = 0; i <= mn; i ++) {         int x = min(gas, mn - i);         while(x >= 0 && !can(i, x, k)) x --;         //printf("%d %d\n", i, x);         ans += x + 1;         gas = x;     }     cout << ans - 1<< endl;     return 0; } 
#include <iostream> #include <cstdio> #include <algorithm> #include <vector> #include <cstring> #include <ctime> #include <cstdlib> #include <cmath> using namespace std; #define pb push_back #define x first #define y second #define mp make_pair #define troloy y1 typedef unsigned long long ll; typedef pair <int, int> pii;   char s[100005]; int a[100005], p[100005]; int solve() {   int n, c4 = 0, c7 = 0;   scanf("%s", s);   n = strlen(s);   for (int i = 0; i < n; i++)     if (s[i] == '4')     {       c4++;       a[i] = 1;     } else     {       a[i] = -1;       c7++;     }   p[n] = 0;   int sm = 0, mn = 0;   for (int i = n - 1; i >= 0; i--)   {     sm += a[i];     p[i] = max(p[i + 1], sm - mn);     mn = min(mn, sm);   }    int bal = 0, ret = max(c4, c7);   for (int i = -1; i < n; i++)   {     ret = max(ret, p[i + 1] + bal + c7);     bal += a[i + 1];   }   return ret; } int main() {   int t;   cin >> t;   for (int i = 0; i < t; i++)     cout << solve() << endl;   return 0; } 
#include <cstdio> #include <iostream> #include <cstring> #include <string> #include <algorithm> using namespace std; #define MX 142  int score[MX], s[MX], n; int toplay[MX][MX], tp[MX][MX];  int canWin(int ct) { 	int i,j,k,a,b; 	for(i=0;i<n;i++) 		if(tp[ct][i]) 		{ 			s[ct]++; 			tp[ct][i]=tp[i][ct]=0; 		}  	for(i=0;i<n;i++) 	{ 		if(i==ct) continue; 		if(s[i]>s[ct]) return 0; 		for(j=0;j<n;j++) 		{ 			if(tp[i][j]==1 && s[i]==s[ct] && s[j]==s[ct]) return 0; 		} 	} 	return 1; }   int main() { 	int t,i,j,k; char in[502],*tok; 	for(scanf("%d",&t);t--;) 	{ 		scanf("%d ",&n); 		 		for(i=0;i<n;i++)  		{ 			score[i]=0; 			for(j=0;j<n;j++) 				toplay[i][j]=0; 		} 		 		for(i=0;i<n;i++) 		{ 			gets(in); 			tok = strtok(in," "); 			for(j=0;j<n;j++) 			{ 				if(*tok=='2') toplay[i][j]=1; 				else if(*tok=='1') score[i]++; 				tok = strtok(NULL," ");				 			}				 		} 		   		for(k=0;k<n;k++) 		{ 			for(i=0;i<n;i++) for(j=0,s[i]=score[i];j<n;j++)  				tp[i][j]=toplay[i][j]; 			in[k] = '0'+canWin(k); 		} 		in[n]='\0'; 		puts(in); 	} 	return 0; } 
#include <cstdio> #include <algorithm> #pragma comment(linker,"/STACK:16777216") #define inf 1000000000 using namespace std; const int sz=500000; char A[702][702]; int dp[702][702]; int V[sz][5]; int nm[sz],nmi; int matchedL[sz],matchedR[sz]; int dist[sz],N1,N2; int visited[sz],visit[sz],vs; int Q[sz<<1];  /*inline bool canaugment(){     int v,nv,s=0,e=0;     nmi=0;      fill(dist,dist+(N1+1),inf);      for(int i=1;i<=N1;i++)         if(!matchedL[i]){dist[i]=0;Q[e++]=i;nm[nmi++]=i;}      dist[0]=inf;      while(s-e){         v=Q[s++];         for(int* ptr=V[v];nv=(*ptr);ptr++){             if(dist[matchedR[nv]]==inf){                 dist[matchedR[nv]]=dist[v]+1;                 Q[e++]=matchedR[nv];             }         }     }     return dist[0]!=inf; }*/  bool dfs(int v){     visited[v]=1;     visit[vs++]=v;     if(v){         int nv;          for(int* ptr=V[v];nv=(*ptr);ptr++){             if((!visited[matchedR[nv]])&&dfs(matchedR[nv])){                 matchedL[v]=nv;                 matchedR[nv]=v;                 return true;             }         }         return false;     }     return true; }  int main() {      int Dx[]={-2,-2,2,2};     int Dy[]={-2,2,-2,2};     int M,N;      scanf("%d%d",&M,&N);      int i,j,k;      while(M&&N){         for(i=0;i<M;i++)scanf("%s",A[i]);          for(i=0;i<M;i++){             fill(dp[i],dp[i]+N,0);             for(j=0;j<N;j++){                 if(A[i][j]=='F'){                     int pr=0,r,c;                      for(k=0;k<4;k++){                         r=i+Dx[k],c=j+Dy[k];                         if(r>=0&&r<M&&c>=0&&c<N&&A[r][c]=='G'&&A[i+Dx[k]/2][j+Dy[k]/2]!='P'){pr=1;break;}                     }                     dp[i][j]=1-pr;                 }             }         }          int ans=0;         for(int dx=0;dx<2;dx++)             for(int dy=0;dy<2;dy++){                  N1=N2=0;                  for(i=dx;i<M;i+=4)for(j=dy;j<N;j+=2)if(dp[i][j]){dp[i][j]=++N1;}                 for(i=dx+2;i<M;i+=4)for(j=dy;j<N;j+=2)if(dp[i][j]){dp[i][j]=++N2;}                  fill(matchedL,matchedL+(N1+1),0);                 fill(matchedR,matchedR+(N2+1),0);                  for(i=dx;i<M;i+=4){                      for(j=dy;j<N;j+=2){                         if(dp[i][j]){                             int ci=0,idx=dp[i][j];                             for(k=0;k<4;k++){                                 int r=i+Dx[k],c=j+Dy[k];                                   if(r>=0&&r<M&&c>=0&&c<N&&dp[r][c]&&A[i+Dx[k]/2][j+Dy[k]/2]!='P'){                                     V[idx][ci++]=dp[r][c];                                 }                              }                             V[idx][ci]=0;                         }                     }                 }                  int cur=0;                  for(i=1;i<=N1;i++){                     for(j=0;V[i][j];j++)                         if(!matchedR[V[i][j]]){                             matchedL[i]=V[i][j];                             matchedR[V[i][j]]=i;                             cur++;                             break;                         }                 }                  for(i=1;i<=N1;i++)                     if(!matchedL[i]){                         vs=0;                         if(dfs(i))cur++;                         for(int j=0;j<vs;j++)visited[visit[j]]=0;                     }                  cur=N1+N2-cur;                 ans+=cur;             }         printf("%d\n",ans);          scanf("%d%d",&M,&N);     }      return 0; } 
    #include<bits/stdc++.h>     using namespace std;     typedef long long int ll;     typedef vector<ll> vll;     typedef pair<ll,ll> pll;     #define MOD 1000000007     #define pb push_back     #define endl '\n'     #define f first     #define s second     #define forn(i,n) for(int i = 0; i < int(n); i++)     int ans[100], binrep[100];     int ndig(int k)     {     	int c = 0;     	while(k)     	{     		k/=2;     		c++;     	}     	return c;     }     int main()     {     	ios_base::sync_with_stdio(false);     	int t;     	cin >> t;     	while(t--)     	{     		int k, n = 0;     		cin >> k;     		int la = ndig(k), fi = 0, curr = 1;     		int temp = la - 1;     		cout << (3*la - 1) << endl;     		while(k)     		{     			binrep[temp--] = k%2;     			k/=2;     		}     		temp = la;     		for(int i = 0; i < temp; i++)     		{     			if(i == temp-1)     			{     				if(binrep[i] == 1)	     				{     					ans[fi++] = curr++;     					ans[la++] = curr;     				}     				else     				{     					ans[la++] = curr++;     					ans[fi++] = curr;     				}     			}     			else if(binrep[i]%2)     			{     				ans[fi++] = curr++;     				ans[la++] = curr + 1;     				ans[la++] = curr;     				curr += 2;     			}     			else     			{     				ans[fi++] = curr + 2;     				ans[la++] = curr + 1;     				ans[la++] = curr;     				curr += 3;     			}     		}     		for(int i = 0; i < la; i++) cout << ans[i] << " ";	     		cout << endl;     	}     	return 0;     }       
/*      SHUBHAM RAI-IIIT Hyderabad   */ #include<bits/stdc++.h> using namespace std; #define FOR(i,a,b) for(i=a;i<b;i++) #define REP(i,a) for(i=0;i<a;i++) #define LLD long long int #define MOD 225898512559LL #define MOD1 1000000009LL #define si(n) scanf("%d",&n); #define si2(n,m) scanf("%d%d",&n,&m); #define sl(n) scanf("%lld",&n); #define TR(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++) #define F first #define S second #define pb push_back #define mp make_pair typedef pair<int,int> PII; #define TRACE  #ifdef TRACE #define trace1(x)                cerr << #x << ": " << x << endl; #define trace2(x, y)             cerr << #x << ": " << x << " | " << #y << ": " << y << endl; #define trace3(x, y, z)          cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl; #define trace4(a, b, c, d)       cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << endl; #define trace5(a, b, c, d, e)    cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << endl; #define trace6(a, b, c, d, e, f) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << " | " << #f << ": " << f << endl;  #else  #define trace1(x) #define trace2(x, y) #define trace3(x, y, z) #define trace4(a, b, c, d) #define trace5(a, b, c, d, e) #define trace6(a, b, c, d, e, f)  #endif LLD power1[100002],power2[100002]; int main() { 	int t; 	power1[0]=power2[0]=1; 	for(t=1;t<=100001;t++) 	{ 		power1[t]=(power1[t-1]*26)%MOD; 		power2[t]=(power2[t-1]*26)%MOD1; 	} 	si(t); 	while(t--) 	{ 		LLD f[100005],f1[100005],r[100005],r1[100005]; 		string s; 		cin>>s; 		int n=s.size(),i,j; 		f[0]=f1[0]=0; 		FOR(i,1,n+1) 		{ 			f[i]=(f[i-1]+(s[i-1]-'a'+1)*power1[n-i])%MOD; 			f1[i]=(f1[i-1]+(s[i-1]-'a'+1)*power2[n-i])%MOD1; 	//		trace3(i,f[i],f1[i]); 		} 		r[n]=r1[n]=0; 		for(i=n-1;i>=0;i--) 		{ 			r[i]=(r[i+1]+(s[i]-'a'+1)*power1[i])%MOD; 			r1[i]=(r1[i+1]+(s[i]-'a'+1)*power2[i])%MOD1; 	//		trace3(i,r[i],r1[i]); 		} 		int ans=0; 		for(i=0;i<=n;i++) 		{ 			for(j=0;j<26;j++) 			{ 				LLD for1=f[n]+25*f[i]+j*power1[n-i]; 	//			trace3(i,j,for1); 				LLD bac1=r[0]+25*r[i]+j*power1[i]; 				LLD for2=f1[n]+25*f1[i]+j*power2[n-i]; 				LLD bac2=r1[0]+25*r1[i]+j*power2[i]; 				for1%=MOD,bac1%=MOD; 				for2%=MOD1,bac2%=MOD1; 				if(for1==bac1 && for2==bac2) 				{ 					ans++; 					break; 				} 			} 		} 		cout<<ans<<endl; 	} 	return 0; }	 
#include<iostream> #include<stdio.h> #include<limits.h> #include<algorithm> #include<vector> #include<string.h> #include<math.h> #include<set> #include<map> #include<string> #include<queue> #include<deque> #include<bitset> #include<assert.h> #define ones(A) memset(A,-1,sizeof(A)) #define zeros(A) memset(A,0,sizeof(A)) #define SZ size #define mii map<int,int> #define mli map<long long int,int> #define mil map<int,long long int> #define mll map<long long int,long long int> #define msi map<string,int> #define mis map<int,string> #define si(x) scanf("%d",&x) #define s2i(x,y) scanf("%d%d",&x,&y) #define sll(x) scanf("%lld",&x) #define s2ll(x,y) scanf("%lld%lld",&x,&y) #define pi(x) printf("%d\n",x) #define pll(x) printf("%lld\n",x) #define ss(s) scanf("%s",&s) #define ps(s) printf("%s\n",s) #define FOR(i,n) for(int i=0;i<n;i++) #define FOR2(i,start,end,inc) for(int i=start;i<=end;i+=inc) #define DEC(i,start,end,inc) for(int i=start;i>=end;i-=inc) #define vi vector<int> #define ub upper_bound #define lb lower_bound #define bs binary_search #define vll vector<long long int> #define pb push_back #define mp make_pair #define pii pair<int,int> #define MOD 1000000007 #define B begin #define E end typedef long long int ll; typedef unsigned long long int ull; using namespace std; ll lazy[5000005]; ll st[5000005]; ll query_range(ll ind,ll start,ll end,ll l,ll r){ 	if(r<start || l>end){ 		return 0; 	} 	if(lazy[ind]!=0){ 		st[ind]+=lazy[ind]*(end-start+1); 		int mid=(start+end)/2; 		lazy[2*ind]+=lazy[ind]; 		lazy[2*ind+1]+=lazy[ind]; 		lazy[ind]=0; 	} 	if(l<=start && r>=end){ 		return st[ind]; 	} 	int mid=(start+end)/2; 	return query_range(2*ind,start,mid,l,r)+query_range(2*ind+1,mid+1,end,l,r); }  void update_sum(ll ind,ll start,ll end,ll l,ll r,ll v){ 	if(lazy[ind]!=0){ 		st[ind]+=lazy[ind]*(end-start+1); 		lazy[2*ind]+=lazy[ind]; 		lazy[2*ind+1]+=lazy[ind]; 		lazy[ind]=0; 	} 	 	if(r<start || l>end)return; 	if(l<=start && r>=end){ 		st[ind]+=v*(end-start+1); 		if(start!=end){ 			lazy[2*ind]+=v; 			lazy[2*ind+1]+=v; 		} 		return; 	} 	int mid=(start+end)/2; 	update_sum(2*ind,start,mid,l,r,v); 	update_sum(2*ind+1,mid+1,end,l,r,v); 	st[ind]=st[2*ind]+st[2*ind+1]; } set<pair<int,int> > freq[250005]; set<pii >::iterator it; int main(){ 	int n,q; 	s2i(n,q); 	FOR(i,q){ 		int type,l,r,x; 		si(type); 		if(!type){ 			s2i(l,r); 			si(x); 			it=freq[x].lower_bound(mp(l+1,0)); 			if(it!=freq[x].begin()){ 				--it; 				if(it->second>=l)l=it->first; 			} 			while(1){ 				it=freq[x].lower_bound(mp(l,0)); 				if(it==freq[x].E())break; 				if(it->first<=r){ 					r=max(r,it->second); 					freq[x].erase(it); 					update_sum(1,1,n,it->first,it->second,-1); 				} 				else break; 			} 			update_sum(1,1,n,l,r,1);	 			freq[x].insert(mp(l,r)); 		} 		else{ 			int no; 			si(no); 			pi(query_range(1,1,n,no,no)); 		} 	} 	return 0; }
// #include<abhi.944>  #include<bits/stdc++.h> using namespace std;  typedef long long int ll;  #ifndef ONLINE_JUDGE 	#define TRACE #endif  const long double PI=3.1415926535897932384626; const ll MAX=1000000000+7; const int INF = 0x3f3f3f3f;  #define ps printf(" ") #define pn printf("\n") #define sc(n) scanf("%d",&n) #define pf(n) printf("%d",n) #define forall(it, x) for(__typeof((x).begin()) it=(x).begin();it!=(x).end();it++) #define sz size() #define ff first #define ss second #define pb push_back //pop_back #define mp make_pair #define fill(a,val) memset(a,val,sizeof(a)) //#define pii pair <int ,int>  #ifdef TRACE     #define trace(x)            cerr<<__FUNCTION__<<":"<<__LINE__<<": ERROR---->"<<x<<endl;     #define trace1(x)           cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<endl;     #define trace2(x,y)         cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<" | "#y" = "<<y<<endl;     #define trace3(x,y,z)       cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<" | "#y" = "<<y<<" | "#z" = "<<z<<endl;     #define trace4(a,b,c,d)     cerr<<__FUNCTION__<<":"<<__LINE__<<": "#a" = "<<a<<" | "#b" = "<<b<<" | "#c" = "<<c<<" | "#d" = "<<d<<endl; #else     #define trace(x)     #define trace1(x)     #define trace2(x,y)     #define trace3(x,y,z)     #define trace4(a,b,c,d) #endif  ll nCr(int n,int r) {     int i=0;     ll result=1;     if(r > n/2)     {         r = n-r;     }      for (i = 0; i < r; i++)     {         result *= (n-i);         result /= (i+1);     }     return result; }  int main(int argc, char const *argv[]) {     int t;     sc(t);     while(t--) {         int n,k;         sc(n); sc(k);          cout << nCr(n-1,k-1) << endl;     }     return 0; }
#include<bits/stdc++.h> #include <iostream> #include<algorithm> #include<cstdio> using namespace std; #define LL long long LL firstK(LL n,LL k); LL lastK(LL n,LL k); LL mod ; int main() { 	int t; 	cin>>t; 	LL n,k; 	while(t--) 	{ 	 cin>>n>>k; 	  mod = 1 ; 	  for(int i=0;i<k-1;i++) 	    mod*=10 ; 	  printf("%lld ",firstK(n,k)); 	  if(k==1) 	   printf("%01lld\n",lastK(n,k)); 	  else if(k==2) 	   printf("%02lld\n",lastK(n,k)) ; 	  else if(k==3) 	   printf("%03lld\n",lastK(n,k)) ; 	   else if(k==4) 	    printf("%04lld\n",lastK(n,k)); 	    else if(k==5) 	     printf("%05lld\n",lastK(n,k)) ; 	    else if(k==6) 	     printf("%06lld\n",lastK(n,k)); 	     else if(k==7) 	      printf("%07lld\n",lastK(n,k)); 	    else if(k==8) 	     printf("%08lld\n",lastK(n,k)); 	     else if(k==9) 	      printf("%09lld\n",lastK(n,k)) ; 	} 	return 0; } LL firstK(LL n,LL k) {    long double intpart;    //First k digits of n^n = 10^(x-floor(x)+k-1) .... where x = n*log10(n)       return (LL) floorl( powl(10.0,modfl( ((long double)n * log10l((long double)n)) , &intpart ) + k - 1 ) );      } LL lastK(LL n,LL k) {     LL powk = 1 ;     for(int i=0;i<k;i++)      powk*=10 ;     LL ans = 1;     LL tmp = n%powk ;     while(n)     {         if(n&1)          ans = (ans*tmp)%powk ;         tmp =(tmp*tmp)%powk ;          n = n>>1 ;              }     return ans%powk ; }  
#include<bits/stdc++.h>  using namespace std;  long long n, ar[2001][2001], m;  int main() { 	cin >> n >> m; 	for (int i = 1; i <= n; i++) 	{ 		string s; 		cin >> s; 		for (int j = 0; j < m; j++) 			ar[i][j + 1] = s[j] - 48;	 	} 	 	for (int i = 1; i <= n; i++) 	{ 		for (int j = 1; j <= m; j++) 		{ 			if (ar[i][j] == 1) 			{ 				ar[i][j] = min(ar[i - 1][j], ar[i - 1][j - 1]) + 1; 			} 		} 	} 	long long ans = 0; 	for (int i = 1; i <= n; i++) 	{ 		for (int j = 1; j <= m; j++) 		{ 			ans += ar[i][j]; 		} 	} 	cout << ans; 	return 0; }
#include <stdlib.h> #include <stdio.h> #include <string> #include <math.h> #include <fstream> #include <iostream> #include <vector> #include <deque> #include <map> #include <cstdlib> #include <complex> using namespace std;  //2012 August Long Contest, MAXGAME Game count codechef.com //Disable warning messages C4996. #pragma warning(disable:4996)  #define INPUT_FROM 0 #if INPUT_FROM #define fromc from #else #define fromc cin #endif  typedef complex<double> base;  const long long nmax=10000;  //long long fr(vector<long long>&, long long); vector<long long> extended_euclid(long long, long long); int find_v(vector<long long>&, long long);  deque<long long> add(deque<long long>&, deque<long long>&, long long); deque<long long> mul(deque<long long>&, long long, long long); deque<long long> mul(deque<long long>, deque<long long>, long long); deque<long long> min(deque<long long>&, deque<long long>&, long long); deque<long long> div(deque<long long>&, long long, long long);  int main(int argc, char **argv) { 	//ifstream from; 	const long long q0=1012201, q1=98794607;//437110372083 	const long long p0=43, p1=1103, p2=2083, p3=1012201; 	long long test, cases, n, m, mt, res, rt, i, j, k, kt, t, ax; 	long long x0, x1, x2, y0, y1, k2, z, p, q; 	//char ch; 	//string sres[2]={"YES", "NO"}; 	//string s, st, sr; 	//double dt;  	//if(INPUT_FROM) from.open("test.txt"); 	//freopen("input.txt","r",stdin); 	//freopen("output.txt","w",stdout);  	static vector<long long> vk1(nmax+1), vk2(nmax+1); 	static vector<long long> vr(nmax+3), vr0(nmax+3), vr1(nmax+3), vr2(nmax+3), vr3(nmax+3); 	vector<long long> v3(3); 	//vector<long long> vr; 	//vector<int> v; 	//deque<long long> dq; 	//map<long long, long long> mi; 	//map<long long, long long::iterator it; 	//typedef map<string, long long>::const_iterator CI;  	/*static long long v1_43[232]={1,3,7,19,8,12,6,32,0,9,25,1,5,37,11,34,6,22,35,17,39,35,14, 		8,13,37,21,7,39,11,35,31,0,3,1,37,12,22,30,29,14,1,1,1,3,7,19,8,12,6,32,0,9,25,1, 		5,37,11,34,6,22,35,17,39,35,14,8,13,37,21,7,39,11,35,31,0,3,1,37,12,22,30,29,14,1, 		3,3,9,21,14,24,36,18,10,0,27,32,3,15,25,33,16,18,23,19,8,31,19,42,24,39,25,20,21, 		31,33,19,7,0,9,3,25,36,23,4,1,42,3,7,7,21,6,4,13,41,42,9,0,20,3,7,35,1,34,23,42, 		25,30,33,15,30,12,13,5,1,18,6,15,34,30,2,0,21,7,1,41,25,38,31,12,7,19,19,14,4,17, 		23,13,28,6,0,42,2,19,9,15,37,1,28,31,20,22,10,20,8,23,32,15,12,4,10,37,20,30,0,14, 		19,15,13,31,11,35,8,19,8,8,24,13,23,21,10,5,41,0,29,28,8,40,38,2,14,5}; 	static long long v1_1103[9]={1,3,7,19,51,141,393,4,933}; 	static long long v1_2083[4]={1,3,7,19};*/  	static long long v2_43[127]={42,40,33,8,3,11,4,15,28,29,13,14,34,39,39,6,41,40,20,35, 		22,42,41,37,23,16,6,22,8,30,13,15,26,28,25,35,35,12,39,37,40,27,1,40,37,25,26,5, 		18,23,24,4,39,2,35,41,32,19,19,36,31,25,34,38,3,33,23,26,15,31,17,5,37,42,1,21,2, 		22,35,6,6,34,3,26,13,12,10,8,16,5,31,1,38,39,22,18,25,9,7,34,15,21,21,33,32,5,24, 		42,35,3,6,18,17,38,25,20,19,39,4,41,8,2,11,24,24,7,12}; 	//long long a43_0=20, a43_1=923, n43_2=21, n43_3=1; 	static long long v2_1103[9]={1102,1100,1093,1068,977,641,490,183,1059}; 	//long long a1103=550; 	static long long v2_2083[4]={2082,2080,2073,2048}; 	//long long a2083=1040;  	q=p0*p1*p2*p3;//100000000000007  	find_v(vk1, p0); 	find_v(vr, p1);  	rt=extended_euclid(p0, p1)[1]; 	k=(rt<0)?(p1+rt):rt; 	for(i=0;i<=nmax;i++){ 		z=(vr[i]-vk1[i])%p1; 		rt=((z*k)%p1)*p0+vk1[i]; 		while(rt<0) rt+=p0*p1; 		vk1[i]=rt%(p0*p1); 	}  	find_v(vr, p2); 	v3=extended_euclid(p0*p1, p2); 	rt=v3[1]; 	k=(rt<0)?(p2+rt):rt; 	for(i=0;i<=nmax;i++){ 		z=(vr[i]-vk1[i])%p2; 		rt=((z*k)%p2)*p0*p1+vk1[i]; 		while(rt<0) rt+=p0*p1*p2; 		vk1[i]=rt%(p0*p1*p2); 	}  	find_v(vr, p3); 	rt=extended_euclid(p0*p1*p2, p3)[1]; 	k=(rt<0)?(p3+rt):rt; 	for(i=0;i<=nmax;i++){ 		z=(vr[i]-vk1[i])%p3; 		rt=((z*k)%p3)*p0*p1*p2+vk1[i]; 		while(rt<0) rt+=q; 		rt%=q; 		//vk1[i]=rt; 		vk1[i]=(rt==0)?(q-1):(rt-1); 	}  	////////// 	p=p0; ax=-1; vk2[0]=rt=t=1; kt=0; 	for(i=1;i<=nmax;i++){ 		if(ax>0){ 			rt=0; 			ax--; 		}else if(ax==0){ 			rt=v2_43[kt++]; 			ax--; 		}else{ 			if(t%p==0){//(2*i-1) 				if((kt+1)%((p+1)>>1)==0) ax=(p+1)*((p-1)>>1)-1; 				else ax=((p-1)>>1)-1; 				rt=0; 				ax--; 			}else{ 				k=extended_euclid(i+1, p)[1]; 				k=(k<0)?(p+k):k; 				rt=(2*t*rt)%p; 				rt=(k*rt)%p; 			} 		} 		vk2[i]=rt; 		t+=2; 	}  	p=p1; ax=-1; vr1[0]=1; rt=t=1; kt=0; 	for(i=1;i<=nmax;i++){ 		if(ax>0){ 			rt=0; 			ax--; 		}else if(ax==0){ 			rt=v2_1103[kt++]; 			ax--; 		}else{ 			if(t%p==0){//(2*i-1) 				ax=((p-1)>>1)-1; 				rt=0; 				ax--; 			}else{ 				k=extended_euclid(i+1, p)[1]; 				k=(k<0)?(p+k):k; 				rt=(2*t*rt)%p; 				rt=(k*rt)%p; 			} 		} 		vr1[i]=rt; 		t+=2; 	}  	p=p2; ax=-1; vr2[0]=1; rt=t=1; kt=0; 	for(i=1;i<=nmax;i++){ 		if(ax>0){ 			rt=0; 			ax--; 		}else if(ax==0){ 			rt=v2_2083[kt++]; 			ax--; 		}else{ 			if(t%p==0){//(2*i-1) 				ax=((p-1)>>1)-1; 				rt=0; 				ax--; 			}else{ 				k=extended_euclid(i+1, p)[1]; 				k=(k<0)?(p+k):k; 				rt=(2*t*rt)%p; 				rt=(k*rt)%p; 			} 		} 		vr2[i]=rt; 		t+=2; 	}  	p=p3; vr3[0]=1; rt=t=1; 	for(i=1;i<=nmax;i++){ 		k=extended_euclid(i+1, p)[1]; 		k=(k<0)?(p+k):k; 		rt=(2*t*rt)%p; 		rt=(k*rt)%p;  		vr3[i]=rt; 		t+=2; 	}  	//////////////// 	rt=extended_euclid(p0, p1)[1]; 	k=(rt<0)?(p1+rt):rt; 	for(i=0;i<=nmax;i++){ 		z=(vr1[i]-vk2[i])%p1; 		rt=((z*k)%p1)*p0+vk2[i]; 		while(rt<0) rt+=p0*p1; 		vk2[i]=rt%(p0*p1); 	}  	rt=extended_euclid(p0*p1, p2)[1]; 	k=(rt<0)?(p2+rt):rt; 	for(i=0;i<=nmax;i++){ 		z=(vr2[i]-vk2[i])%p2; 		rt=((z*k)%p2)*p0*p1+vk2[i]; 		while(rt<0) rt+=p0*p1*p2; 		vk2[i]=rt%(p0*p1*p2); 	}  	rt=extended_euclid(p0*p1*p2, p3)[1]; 	k=(rt<0)?(p3+rt):rt; 	for(i=0;i<=nmax;i++){ 		z=(vr3[i]-vk2[i])%p3; 		rt=((z*k)%p3)*p0*p1*p2+vk2[i]; 		while(rt<0) rt+=q; 		rt%=q; 		//vk2[i]=rt; 		vk2[i]=(rt==0)?(q-1):(rt-1); 	}  	scanf("%lld\n", &cases); 	for(test=1;test<=cases;test++){ 		scanf("%lld %lld", &n, &k);  		if(k>=2) printf("%lld\n", vk2[n]); 		else if(k==1) printf("%lld\n", vk1[n]); 		else printf("0\n"); 		//printf("%lld\n", ax); 	}  	return 0; }  int find_v(vector<long long>& v, long long p){ 	long long i, rt, x0, x1, x2, kt, k2; 	vector<long long> vr(nmax+3);  	x0=x1=vr[0]=vr[1]=1; 	kt=1; 	for(i=1;i<=nmax+1;i++){ 		rt=extended_euclid(i+1, p)[1]; 		rt=(rt<0)?(p+rt):rt; 		x2=((2*i+1)*x1+3*i*x0); 		if((i+1)%p==0){ 			x2=vr[kt++]; 			//if(vr[kt]!=x2) cout<<i<<" error/n"; 		}else x2=(x2*rt)%p; 		vr[i+1]=x2; 		x0=x1; 		x1=x2; 	}  	rt=extended_euclid(2, p)[1]; 	rt=(rt<0)?(p+rt):rt; 	k2=rt;  	for(i=0;i<=nmax;i++){ 		rt=3*vr[i]+2*vr[i+1]+(p-vr[i+2]); 		rt=rt%p; 		rt=(rt*k2)%p; 		v[i]=rt; 	}  	return 0; }   vector<long long> extended_euclid(long long a, long long b){ 	long long r, r0, x, x0, y, y0, q; 	vector<long long> v(3);  	v[0]=r=a; 	v[1]=x=1; 	v[2]=y=0; 	r0=b; 	x0=0; 	y0=1; 	while(r0!=0){ 		q=r/r0;  		v[0]=r0;  		v[1]=x0;  		v[2]=y0;  		r0=r-q*r0;  		x0=x-q*x0;  		y0=y-q*y0;  		r=v[0];  		x=v[1];  		y=v[2];  		//(r,x,y,r0,x0,y0)=(r0,x0,y0,r-qr0,x-qx0,y-qy0)  	}  	return v;  } 
#include<bits/stdc++.h> using namespace std; #include<stdio.h> #ifndef ONLINE_JUDGE #define get getchar #else #define get getchar_unlocked #endif inline int f() { 	int n=0,s=1; 	char p=get(); 	if(p=='-') 		s=-1; 	while((p<'0' || p>'9') && p!=EOF && p!='-') 		p=get(); 	if(p=='-') 		s=-1,p=get(); 	while(p>='0' && p<='9' ) 	{ 		n=(n<<3)+(n<<1)+(p-'0'); 		p=get(); 	} 	return (n*s); } #define INF 500000 const int xx=500005; int rs0[xx],rs1[xx],cs0[xx],cs1[xx],rs0ts[xx],rs1ts[xx],cs0ts[xx],cs1ts[xx]; inline void update(int bit[xx],int idx,int val){ 	while(idx <= INF){ 		bit[idx]+=val; 		idx += idx & -idx; 	} //	cout<<"in\n"; 	return; } inline int query(int bit[xx],int idx){ 	int res = 0; 	while(idx){ 		res += bit[idx]; 		idx -= idx & -idx; 	} 	return res; } int main() {   	int i,j,k,n,m,q,T0,ones,zeros; 	n=f(); 	q=f(); 	j=0;  	for (int times=1;times<=q;++times){ 		char op[10]; 		scanf("%s",op); 		int x,y,res=0; 		if (!strcmp(op,"RowQuery")) 			{ 			//scanf("%d",&x); 			x=f(); 				if (rs0ts[x] >= rs1ts[x]) 				 { 				    T0 = rs0ts[x]; 				    ones = query(cs1,INF) - query(cs1,T0); 				    //cout<<n-ones<<endl; 				    printf("%d\n",n-ones); 				 } 				else  				 { 				    T0 = rs1ts[x]; 				    zeros = query(cs0,INF) - query(cs0,T0); 				    //cout<<zeros<<endl; 				     printf("%d\n",zeros); 				 } 	    	} 		else if (!strcmp(op,"ColQuery")) 		   { 			//scanf("%d",&x); 				x=f(); 				if (cs0ts[x] >= cs1ts[x]) 				 { 				    T0 = cs0ts[x]; 				     				    //if(T0<= 2*n) 				    //ones = query(rs1,INF) - query(rs1,2*n); 				    //else 				    ones = query(rs1,INF) - query(rs1,T0); 				    //cout<<n-ones<<endl; 				    printf("%d\n",n-ones); 				 } 				else  				 { 				    T0 = cs1ts[x]; 				    zeros = query(rs0,INF) - query(rs0,T0); 				    //cout<<zeros<<endl; 				    printf("%d\n",zeros); 				 } 	    	} 	    	 		else if (!strcmp(op,"RowSet")) 			{ 		//scanf("%d%d",&x,&y); 			x=f(); 			y=f(); 			if(y==0) 			{    			    if(rs0ts[x]!=0 || rs1ts[x]!=0) 				if(rs0ts[x]>rs1ts[x]) 				update(rs0,rs0ts[x],-1); 				else 				update(rs1,rs1ts[x],-1); 				 				update(rs0,times,1); 				rs0ts[x]=times; 			} 			else 			{ 			   if(rs0ts[x]!=0 || rs1ts[x]!=0) 			   if(rs1ts[x]>rs0ts[x]) 				update(rs1,rs1ts[x],-1); 				else 				update(rs0,rs0ts[x],-1); 				 				update(rs1,times,1); 				rs1ts[x]=times; 			} 	 	} 		else if (!strcmp(op,"ColSet")) 		{ 		//scanf("%d%d",&x,&y); 		x=f(); 		y=f(); 		//cout<<x<<" "<<y<<endl; 			if(y==0) 			{ 				if(cs0ts[x]!=0 || cs1ts[x]!=0) 				if(cs0ts[x]>cs1ts[x]) 				update(cs0,cs0ts[x],-1); 				else 				update(cs1,cs1ts[x],-1); 				 				update(cs0,times,1); 				cs0ts[x]=times; 			} 			else 			{ 			   if(cs0ts[x]!=0 || cs1ts[x]!=0) 			   if(cs1ts[x]>cs0ts[x]) 				  update(cs1,cs1ts[x],-1); 			   else 				  update(cs0,cs0ts[x],-1); 			 			  				update(cs1,times,1); 				cs1ts[x]=times; 			} 	} 	} 	return 0; }
#include<bits/stdc++.h>  #define fr first #define se second using namespace std;  pair<long long,long long> p[1000005]; long long  segtree1mx[1000005+1]; long long segtree2mx[1000005+1]; long long segtree1mn[1000005+1]; long long segtree2mn[1000005+1]; int n; inline void show() {  for(int i=0;i<n;i++) {         cout<<p[i].fr+p[i].se<<" ";         //cout<<segtree1mx[i]<<" " ;     }         cout<<endl;      for(int i=0;i<2*n;i++) {         //cout<<p[i].fr+p[i].se<<" ";         cout<<segtree1mx[i]<<" " ;     }          cout<<endl;     for(int i=0;i<n;i++) {         cout<<p[i].fr-p[i].se<<" ";         //cout<<segtree1mx[i]<<" " ;     }         cout<<endl;     for(int i=0;i<2*n;i++) {         cout<<segtree2mx[i]<<" " ;     }         cout<<endl;         for(int i=0;i<n;i++) {         cout<<p[i].fr+p[i].se<<" ";         //cout<<segtree1mx[i]<<" " ;     }cout<<endl;     for(int i=0;i<2*n;i++) {         cout<<segtree1mn[i]<<" " ;     }     cout<<endl;      for(int i=0;i<n;i++) {         cout<<p[i].fr-p[i].se<<" ";         //cout<<segtree1mx[i]<<" " ;     }         cout<<endl;     for(int i=0;i<2*n;i++) {         cout<<segtree2mn[i]<<" " ;     }     cout<<endl; } inline void build(int node,int rs,int re) {      if(rs>re) 	return ;     if(rs==re) { 	segtree1mx[node]=p[rs].fr+p[rs].se; 	segtree1mn[node]=p[rs].fr+p[rs].se; 	segtree2mx[node]=p[rs].fr-p[rs].se;         segtree2mn[node]=p[rs].fr-p[rs].se; 	return ;     }     build(2*node,rs,(rs+re)/2);     build(2*node+1,(rs+re)/2+1,re);     segtree1mx[node]=max(segtree1mx[2*node],segtree1mx[2*node+1]);     segtree1mn[node]=min(segtree1mn[2*node],segtree1mn[2*node+1]);     segtree2mx[node]=max(segtree2mx[2*node],segtree2mx[2*node+1]);     segtree2mn[node]=min(segtree2mn[2*node],segtree2mn[2*node+1]); } inline long long querymx1(int node,int rs,int re,int qs,int qe) {      if(qs<=rs && re<=qe) { 	return segtree1mx[node];     }     if(re<qs || rs>qe) { 	return INT_MIN;     }     long long temp1,temp2;     temp1=querymx1(2*node,rs,(rs+re)/2,qs,qe);     temp2=querymx1(2*node+1,(rs+re)/2+1,re,qs,qe);     return max(temp1,temp2); } inline long long querymx2(int node,int rs,int re,int qs,int qe) {      if(qs<=rs && re<=qe) {         return segtree2mx[node];     }     if(re<qs || rs>qe) {         return INT_MIN;     }     long long  temp1,temp2;     temp1=querymx2(2*node,rs,(rs+re)/2,qs,qe);     temp2=querymx2(2*node+1,(rs+re)/2+1,re,qs,qe);     return max(temp1,temp2); } inline long long  querymn1(int node,int rs,int re,int qs,int qe) {      if(qs<=rs && re<=qe) {         return segtree1mn[node];     }     if(re<qs || rs>qe) {         return INT_MAX;     }     long long temp1,temp2;     temp1=querymn1(2*node,rs,(rs+re)/2,qs,qe);     temp2=querymn1(2*node+1,(rs+re)/2+1,re,qs,qe);     return min(temp1,temp2); } inline long long querymn2(int node,int rs,int re,int qs,int qe) {     if(qs<=rs && re<=qe) {         return segtree2mn[node];     }     if(re<qs || rs>qe) {         return INT_MAX;     }     long long temp1,temp2;     temp1=querymn2(2*node,rs,(rs+re)/2,qs,qe);     temp2=querymn2(2*node+1,(rs+re)/2+1,re,qs,qe);     return min(temp1,temp2); } inline void update(int node,int rs,int re,int idx){     if(rs==re) { 	segtree1mx[node]=p[rs].fr+p[rs].se;         segtree1mn[node]=p[rs].fr+p[rs].se;         segtree2mx[node]=p[rs].fr-p[rs].se;         segtree2mn[node]=p[rs].fr-p[rs].se;         return ;     }     int mid=(rs+re)/2;     if(idx<=mid) { 	update(2*node,rs,mid,idx);     }     else { 	update(2*node+1,mid+1,re,idx);     }     segtree1mx[node]=max(segtree1mx[2*node],segtree1mx[2*node+1]);     segtree1mn[node]=min(segtree1mn[2*node],segtree1mn[2*node+1]);     segtree2mx[node]=max(segtree2mx[2*node],segtree2mx[2*node+1]);     segtree2mn[node]=min(segtree2mn[2*node],segtree2mn[2*node+1]); } int main() {     scanf("%d",&n);     for(int i=0;i<n;i++) { 	scanf("%lld%lld",&p[i].fr,&p[i].se);     }     build(1,0,n-1); 	//show();     int q;scanf("%d",&q);     char cs[2];     while(q--) { 	scanf("%s",cs); 	if(cs[0]=='U') { 	    int x,y,z; 	    scanf("%d%d%d",&x,&y,&z); 	    p[x].fr=y;p[x].se=z; 	    update(1,0,n-1,x); 	} 	else { 	    int l,r;scanf("%d%d",&l,&r); 	    long long ans1,ans2,ans3,ans4; 	    //show(); 	   // cout<<querymx1(1,0,n-1,l,r)<<endl; 	   // cout<<querymn1(1,0,n-1,l,r)<<endl; 	   // cout<<querymx2(1,0,n-1,l,r)<<endl; 	   // cout<<querymn2(1,0,n-1,l,r)<<endl; 	    ans1=(querymx1(1,0,n-1,l,r)-querymn1(1,0,n-1,l,r)); 	    ans2=(querymx2(1,0,n-1,l,r)-querymn2(1,0,n-1,l,r)); 	//ans3=(querymx1(1,0,n-1,l,r)-querymn2(1,0,n-1,l,r));         //ans4=(querymx2(1,0,n-1,l,r)-querymn1(1,0,n-1,l,r)); 	    printf("%lld\n",max(ans1,ans2)); 	}     } } 
#define INPUT	"meanmedi.in" #define OUTPUT	"meanmedi.out"   #define MULTI_CASE   // f{{{    #include <stdint.h> #include <algorithm> #include <bitset> #include <cmath> #include <cassert> #include <cctype> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <deque> #include <functional> #include <iomanip> #include <iostream> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <utility> #include <vector> #include <limits>   #define ITER_VECTOR(v, var) \ 	for (typeof((v).begin()) var = (v).begin(); var != (v).end(); var ++)   #define ITER_VECTOR_IDX(v, var) \ 	for (typeof((v).size()) var = 0; var < (v).size(); var ++)   using namespace std;   // f}}}   namespace Solve { 	const int SEQLEN_MAX = 65, 		  VAL_MAX = 1205, 		  SUM_MAX = SEQLEN_MAX * VAL_MAX, 		  INF = 1 << 30, 		  KNAPSACK_NODE_MEMSIZE = SEQLEN_MAX * SUM_MAX * 2;   	struct Knapsack 	{ 		struct Seg 		{ 			int low, high; 		}; 		struct Node 		{ 			int *val_begin, *val_end; 		}; 		Node cap[SEQLEN_MAX]; 		void work(const int *seq, int seqlen, int nchosen); 	}; 	Knapsack npsk_front, npsk_end; 	int knapsack_mem[KNAPSACK_NODE_MEMSIZE], knapsack_mem_size;   	int calc_min_diff(int len_front, int len_end, int tgt);   	double work(int *seq, int seqlen, int nchosen); 	void solve(FILE *fin, FILE *fout); }   void Solve::solve(FILE *fin, FILE *fout) { 	static int seq[SEQLEN_MAX]; 	int seqlen, nch, ncase = 1; #ifdef MULTI_CASE 	fscanf(fin, "%d", &ncase); #endif 	while (ncase --) 	{ 		knapsack_mem_size = 0; 		fscanf(fin, "%d%d", &seqlen, &nch); 		for (int i = 0; i < seqlen; i ++) 			fscanf(fin, "%d", &seq[i]); 		fprintf(fout, "%.3lf\n", work(seq, seqlen, nch)); 	} }   double Solve::work(int *seq, int seqlen, int nchosen) { 	if (nchosen == 1) 		return 0; 	sort(seq, seq + seqlen); 	if (nchosen == 2) 	{ 		int ans = INF; 		for (int i = 1; i < seqlen; i ++) 			ans = min(ans, seq[i] - seq[i - 1]); 		return ans * 0.5; 	} 	int len0 = (nchosen + 1) / 2 - 1, 		len1 = nchosen - 1 - len0; 	npsk_front.work(seq, seqlen - len1, len0); 	static int seq_rev[SEQLEN_MAX]; 	reverse_copy(seq, seq + seqlen, seq_rev); 	npsk_end.work(seq_rev, seqlen - len0, len1); 	int ans = INF; 	for (int i = len0; i + len1 + 1<= seqlen; i ++) 		ans = min(ans, calc_min_diff(i, seqlen - 1 - i, seq[i] * (nchosen - 1))); 	return double(ans) / nchosen; }   int Solve::calc_min_diff(int len_front, int len_end, int tgt) { 	int *i = npsk_front.cap[len_front - 1].val_begin, 		*i_end = npsk_front.cap[len_front - 1].val_end, 		*j = npsk_end.cap[len_end - 1].val_end - 1, 		*j_begin = npsk_end.cap[len_end - 1].val_begin, 		*j_end = j + 1; 	if (i == i_end || j_begin == j_end) 		return INF; 	int ans = INF; 	while (i != i_end) 	{ 		while (j >= j_begin && *i + *j > tgt) 			j --; 		if (j >= j_begin) 			ans = min(ans, tgt - (*i + *j)); 		j ++; 		if (j < j_end) 			ans = min(ans, *i + *j - tgt); 		else j --; 		i ++; 	} 	return ans; }   void Solve::Knapsack::work(const int *seq, int seqlen, int nchosen) { 	typedef uint32_t Mask_t; 	assert(nchosen <= 30); 	struct Dp_node 	{ 		int sum; 		Mask_t mask; 		// mask[i]: whether the sum can be achieved by choosing i numbers 	}; 	Mask_t mask_valid_sum = (1 << (nchosen + 1)) - 1; 	static Dp_node f[2][SUM_MAX]; 	int nf[2]; 	nf[0] = 1; 	f[0][0].sum = 0; 	f[0][0].mask = 1; 	for (int cur = 0, i = 0; i < seqlen; i ++) 	{ 		assert(seq[i] >= 0); 		int prev = cur; 		cur ^= 1; 		int nfp = nf[prev], seq_i = seq[i]; 		Dp_node *p1 = f[prev], *p2 = p1, 				*p2_end = p2 + nfp, 				*pt = f[cur]; 		p1[nfp].sum = SUM_MAX + 1; 		cap[i].val_begin = knapsack_mem + knapsack_mem_size; 		while (p2 != p2_end) 		{ 			int s = min(p1->sum, p2->sum + seq_i); 			pt->sum = s; 			Mask_t m = 0; 			if (p1->sum == s) 				m |= (p1 ++)->mask; 			if (p2->sum + seq_i == s) 				m |= (p2 ++)->mask << 1; 			pt->mask = m; 			if (!(m & mask_valid_sum)) 				continue; 			if ((m >> nchosen) & 1) 				knapsack_mem[knapsack_mem_size ++] = s; 			pt ++; 		} 		cap[i].val_end = knapsack_mem + knapsack_mem_size; 		nf[cur] = pt - f[cur]; 	} }   // f{{{ main int main() { #if defined(INPUT) && defined(OUTPUT) && !defined(STDIO) && !defined(ONLINE_JUDGE) 	FILE *fin = fopen(INPUT, "r"), 		 *fout = fopen(OUTPUT, "w"); 	Solve::solve(fin, fout); 	fclose(fin); 	fclose(fout); #else 	Solve::solve(stdin, stdout); #endif } // f}}} // vim: filetype=cpp foldmethod=marker foldmarker=f{{{,f}}}  
#include <iostream>    #include <sstream>    #include <cstdio>    #include <cstdlib>    #include <cmath>    #include <memory.h>    #include <cctype>    #include <string>    #include <vector>    #include <list>    #include <queue>    #include <deque>    #include <stack>    #include <map>    #include <set>    #include <algorithm>    using namespace std;       #define FOR(i,a,b) for(int (i) = (a); (i) < (b); ++(i))   #define RFOR(i,a,b) for(int (i) = (a)-1; (i) >= (b); --(i))   #define CLEAR(a) memset((a),0,sizeof(a))   #define INF 1000000000   #define PB push_back   #define ALL(c) (c).begin(), (c).end()   #define pi 2*acos(0.0)   #define SQR(a) (a)*(a)   #define MP make_pair       typedef unsigned long long Int;     int n, T; int A[64]; map<int, int> R;   int F(int mask) { 	int c0 = 0, c1 = 0; 	FOR (i,0,n) 		if (mask & (1 << i)) 			c1++; 		else 			c0++;   	if (c0 == 0) 		return 0; 	if (c1 >= c0) 		return 1; 	   	if (R.find(mask) != R.end()) 		return R[mask]; 	 	int res = INF;   	FOR (i,0,n) 	{ 		c0 = 0, c1 = 0; 		int go = mask; 		int to = -1;   		FOR (j,i,n) 		{ 			if ((mask & (1 << j)) != 0) 				c1++; 			else 			{ 				go += (1 << j); 				c0++; 			}   			if (c1 >= c0 && go != mask) 				to = go; 		} 		if (to != -1) 			res = min(res, F(to)+1); 	} 	R[mask] = res; 	return res; }   int main() { 	cin >> T; 	FOR (t,0,T) 	{ 		R.clear();   		cin >> n; 		int MAX = 0; 		FOR (i,0,n) 		{ 			cin >> A[i]; 			//A[i] = rand() % 10 + 1; 			MAX = max(MAX, A[i]); 		}   		int mask = 0; 		FOR (i,0,n) 			if (A[i] == MAX) 				mask += (1 << i);   		cout << F(mask) << endl; 	}   	return 0; }    
#include <iostream> #include <algorithm> #include<string.h> #include <list> #include<queue> #include<vector> #include <cmath> #define mp make_pair using namespace std; #define pii pair<int,int> #define x first #define y second #define inf 100000000 #define N 35 int ok[51][101][22],f1[51][101][22],a[51],b[51]; double f[51][101][22]; int main() {   int i,j,k,l,m,n,c;double v;   //freopen("in.txt","r",stdin);   while(~scanf("%d%d%d",&l,&n,&m))   {   	if(n==0&&m==0&&l==0)break;   	double mx=inf;int tt,ss;    for(i=0;i<n;i++)    {scanf("%d%d",&a[i],&b[i]);    if(mx>a[i])mx=a[i];    }    if(mx*l>m){printf("0.0\n");continue;}    mx=0;    for(i=0;i<n;i++)    for(j=0;j<=m;j++)    for(k=0;k<=l;k++)f[i][j][k]=f1[i][j][k]=0;    memset(ok,0,sizeof(ok));    for(i=0;i<n;i++)ok[i][m][0]=1;      for(c=m;c>=0;c--)for(k=0;k<l;k++)    for(i=0;i<n;i++)        for(j=0;j<n;j++)    if(ok[i][c][k]&&c>=a[j])    {    	v=b[j];     if(i==j)     { 	 if(k)v/=2;      if(k>1&&f1[i][c][k]==i)v=0;     }     if(f[j][c-a[j]][k+1]<f[i][c][k]+v)     {      f[j][c-a[j]][k+1]=f[i][c][k]+v;      if(k)f1[j][c-a[j]][k+1]=i;      ok[j][c-a[j]][k+1]=1; 	} 	if(k+1==l&&ok[j][c-a[j]][k+1]) 	if(mx<f[j][c-a[j]][k+1]) 	{mx=f[j][c-a[j]][k+1];ss=j;tt=c-a[j];}    }    printf("%.1lf\n",mx);    if(mx)    {    while(l)    {     printf("%d ",ss+1);     j=a[ss];     ss=f1[ss][tt][l--];tt+=j;    }    puts("");    }   }   return 0; }    
#include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<set> #include<map> #include<limits.h> #include<functional> #include<string> #include<cstring> #include<stack> using namespace std; #define GETCHAR getchar_unlocked int maxRECT_WITH_HEIGHT[1001][1001]; int data_matrix[1001][1001]; int histogram[1001][1001]; int answer[1001][1001]; int check[1001][1001]; int n,m,k; inline int input() { int flag=1; int n = 0; char c; while (1) { c=GETCHAR(); if(c>='0'&&c<='9') {n = n * 10 + c - '0';flag=0;} else if(flag!=1) break; } return n; } void maxRect(int hist[], int nn,int rw) {     stack<int> s;     int TOPPER;     int maximum=0;     int area_topper;     int i = 1;     while (i <= nn)     {         if(maximum<hist[i])maximum=hist[i];         if (s.empty()|| hist[s.top()] <= hist[i])             s.push(i++);         else         {             TOPPER = s.top();             s.pop();             area_topper = hist[TOPPER] * (s.empty() ? i-1 : i - s.top() - 1);             if (maxRECT_WITH_HEIGHT[rw][hist[TOPPER]] < area_topper)                 maxRECT_WITH_HEIGHT[rw][hist[TOPPER]]= area_topper;         }     }     while (s.empty() == false)     {         TOPPER = s.top();         s.pop();         area_topper = hist[TOPPER] * (s.empty() ? i -1: i - s.top() - 1);             if (maxRECT_WITH_HEIGHT[rw][hist[TOPPER]] < area_topper)                 maxRECT_WITH_HEIGHT[rw][hist[TOPPER]]= area_topper;     }     //still many heights are nt filled     for(int i=maximum-1;i>=1;--i)if(maxRECT_WITH_HEIGHT[rw][i+1]/(i+1) > maxRECT_WITH_HEIGHT[rw][i]/(i))maxRECT_WITH_HEIGHT[rw][i]=i*(maxRECT_WITH_HEIGHT[rw][i+1]/(i+1));     //for(int i=maximum-1;i>=1;--i)if(maxRECT_WITH_HEIGHT[rw][i]==0)maxRECT_WITH_HEIGHT[rw][i]=i*(maxRECT_WITH_HEIGHT[rw][i+1]/(i+1)); } void initilize() {     for(int i=0;i<1000;++i)     {         for(int j=0;j<1000;++j)         {             answer[i][j]=check[i][j]=histogram[i][j]=maxRECT_WITH_HEIGHT[i][j]=0;             data_matrix[i][j]=1;     	   }     } }  int dynamic(int i,int j) {    if(check[i][j]==1)return answer[i][j];     answer[i][j]=max(max(dynamic(i-1,j),dynamic(i,j+1)),maxRECT_WITH_HEIGHT[i][i-j+1]);     check[i][j]=1;     return answer[i][j]; } int main() {   //freopen("input.txt","r",stdin);     int a,b;          scanf("%d%d%d",&n,&m,&k);     for(int i=0;i<=n;i++)         for(int j=0;j<=m;j++)         data_matrix[i][j] = 1;      for(int i=1;i<=k;++i)     {         scanf("%d%d",&a,&b);         data_matrix[a][b]=0;     }     //printf("hha\n");     for(int i=1;i<=n;++i)         for(int j=1;j<=m;++j)         if(data_matrix[i][j]==1)         histogram[i][j]=histogram[i-1][j]+1;        for(int i=1;i<=n;++i)     {         maxRect(histogram[i],m,i);     }     for(int i=1;i<=n;++i)     {     	check[i][i]=1;     	answer[i][i]=maxRECT_WITH_HEIGHT[i][1];     }      dynamic(n,1);      int qno;qno = input();     while(qno--)     {       scanf("%d%d",&a,&b);         printf("%d\n",answer[b][a]);     }     return 0; } 
#include<stdio.h> long long int arr[1000005],brr[1000005]; void merge(long long int b[],int start,int mid ,int end) {     int lctr=start,rctr=mid,k=0;     for(k=start;lctr<mid&&rctr<end;k++)     {         if(b[lctr]<b[rctr])         {             brr[k]=b[lctr];             lctr++;         }          else         {             brr[k]=b[rctr];             rctr++;         }     }     while(lctr<mid)     {         brr[k]=b[lctr];         lctr++;         k++;     }      while(rctr<end)     {         brr[k]=b[rctr];         rctr++;         k++;     }      for(int i=start;i<end;i++)     {         b[i]=brr[i];     } } void mergesort(long long int ar[],int start, int end) {     int size=end-start;      if(size==1)     return;      int mid=size/2;      //printf("Sizesssss %d %d %d\n",start,mid,end);     //getchar();     mergesort(ar,start,start+mid);     mergesort(ar,start+mid,end);     merge(ar,start,start+mid,end); } int main() {     int n,i,k,j;     long long int x;      scanf("%d %lld",&n,&x);      for(int i=0;i<n;i++)     {         scanf("%lld",&arr[i]);     }      mergesort(arr,0,n);      int fpack=n,spack=0;     long long int ctr=0;      for(int i=0;i<n;i++)     {         if(ctr+(arr[i]+1)/2>x)         break;          else         {             ctr=ctr+(arr[i]+1)/2;             fpack--;         }     }      for(int i=0;i<n;i++)     {         if(ctr+arr[i]/2>x)         break;          else         {             ctr=ctr+arr[i]/2;             spack++;         }     }      printf("%d %d\n",fpack,spack);      return 0; } 
#include <bits/stdc++.h> using namespace std;  #define DEBUG(x) 	cerr << #x << " = " << x << endl; #define INPUT		freopen("Data.inp", "r", stdin); #define OUTPUT		freopen("Data.out", "w", stdout);  typedef long long LL; typedef pair<int, int> II;  const int N = (int) 2e5 + 10; const int C = 30; int n, q, st[N * 5]; char S[N];  bool CompareSuffix(int x, int y) { 	for (int i = 0; i < C; ++i) { 		if (S[x + i] < S[y + i]) return true; 		if (S[x + i] > S[y + i]) return false; 	} 	return false; }  void Build(int k, int l, int r) { 	if (l == r) { st[k] = l; return; } 	int m = (l + r) >> 1; 	Build(k << 1 | 0, l, m); 	Build(k << 1 | 1, m + 1, r); 	if (CompareSuffix(st[k << 1], st[k << 1 | 1]))  		st[k] = st[k << 1];  	else  		st[k] = st[k << 1 | 1]; }  void Update(int k, int l, int r, int i, int j) { 	if (l >= r || l > j || r < i) return; 	int m = (l + r) >> 1; 	Update(k << 1, l, m, i, j); 	Update(k << 1 | 1, m + 1, r, i, j); 	if (CompareSuffix(st[k << 1], st[k << 1 | 1]))  		st[k] = st[k << 1];  	else  		st[k] = st[k << 1 | 1];	 }  int Query(int k, int l, int r, int i, int j) { 	if (i == l && j == r) return st[k]; 	int m = (l + r) >> 1; 	if (j <= m) return Query(k << 1, l, m, i, j); 	if (i  > m) return Query(k << 1 | 1, m + 1, r, i, j); 	int x = Query(k << 1, l, m, i, m); 	int y = Query(k << 1 | 1, m + 1, r, m + 1, j); 	if (CompareSuffix(x, y)) return x; 	return y; }  char CharAt(int l, int r, int x, int p) { 	if (x + p - 1 <= r) return S[x + p - 1]; 	return S[x + p - 1 - r + l - 1]; }  bool CompareCycle(int l, int r, int x, int y) { 	for (int i = 1; i <= min(C, r - l + 1); ++i) { 		if (CharAt(l, r, x, i) < CharAt(l, r, y, i)) return true; 		if (CharAt(l, r, x, i) > CharAt(l, r, y, i)) return false; 	} 	return false; }  int main() { 	scanf("%s", S + 1); n = strlen(S + 1); 	for (int i = 1; i <= C; ++i) S[i + n] = '@'; 	scanf("%d", &q); Build(1, 1, n); 	while (q--) { 		int k; scanf("%d", &k); 		if (k == 0) { 			int i; char T[10]; scanf("%d%s", &i, T); 			S[i] = T[0]; 			Update(1, 1, n, max(1, i - C + 1), i); 		} 		else { 			int l, r, p; scanf("%d%d%d", &l, &r, &p); 			int x = Query(1, 1, n, l, max(l, r - C)); 			for (int i = max(l, r - C + 1); i <= r; ++i) 				if (CompareCycle(l, r, i, x)) x = i; 			printf("%c\n", CharAt(l, r, x, p)); 		} 	} 	return 0; }
#include<bits/stdc++.h>  #define rep(i,n) for(int i=0;i<(int)n;i++) #define all(c) (c).begin(),(c).end() #define mp make_pair #define pb push_back #define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++) #define dbg(x) cerr<<__LINE__<<": "<<#x<<" = "<<(x)<<endl  using namespace std;  typedef long long ll; typedef vector<int> vi; typedef pair<int,int> pi; const int inf = (int)1e9; const double INF = 1e12, EPS = 1e-9;  #define F first #define S second  const int N = 250000; const int M = 500;  int child[N*16*10][2], value[N*16*10], trie_sz = 1; inline int node(){ 	assert(trie_sz + 1 < N*16*10); 	return trie_sz++; }  int n, q, a[N]; int root[M], sum[M]; pi mn[M];  inline void add(int &r, int v, int x, int pos = 15){ 	if(!r) r = node(); 	value[r] += x; 	if(pos < 0) return; 	 	add(child[r][v >> pos & 1], v, x, pos - 1); } inline pi get(int r, int s, int ans = 0, int pos = 15){ 	if(pos < 0) return mp(ans, value[r]); 	rep(ii, 2){ 		int i = ii ^ (s >> pos & 1); 		if(child[r][i] && value[child[r][i]]) return get(child[r][i], s, ans * 2 + ii, pos - 1); 	} 	assert(0); }  int main(){ 	 	scanf("%d%d", &n, &q); 	rep(i, n) scanf("%d", a + i); 	 	rep(i, M) mn[i] = mp(inf, 0); 	rep(i, n){ 		add(root[i / M], a[i], 1); 		if(mn[i / M].F > a[i]) mn[i / M] = mp(a[i], 0); 		if(mn[i / M].F == a[i]) mn[i / M].S++; 	} 	//rep(i, n) cerr<<mn[i/M].F<<" "<<mn[i/M].S<<" : "<<i<<endl; 	 	while(q--){ 		int type, l, r, x; 		scanf("%d%d%d", &type, &l, &r); 		l--; 		 		if(type == 1){ 			pi ans = mp(inf, 0); 			while(l % M && l < r){ 				if(ans.F > (a[l] ^ sum[l / M])) ans = mp(a[l] ^ sum[l / M], 0); 				if(ans.F == (a[l] ^ sum[l / M])) ans.S++; 				l++; 			} 			while(r % M && l < r){ 				r--; 				if(ans.F > (a[r] ^ sum[r / M])) ans = mp(a[r] ^ sum[r / M], 0); 				if(ans.F == (a[r] ^ sum[r / M])) ans.S++; 			} 			l /= M; r /= M; 			while(l < r){ 				if(ans.F > mn[l].F) ans = mp(mn[l].F, 0); 				if(ans.F == mn[l].F) ans.S += mn[l].S; 				l++; 			} 			 			printf("%d %d\n", ans.F, ans.S); 		} 		else{ 			scanf("%d", &x); 			while(l % M && l < r){ 				add(root[l / M], a[l], -1); a[l] ^= x; 				add(root[l / M], a[l], 1); 				l++; 				 				if(l % M == 0) mn[l / M - 1] = get(root[l / M - 1], sum[l / M - 1]); 			} 			while(r % M && l < r){ 				r--; 				add(root[r / M], a[r], -1); a[r] ^= x; 				add(root[r / M], a[r], 1); 				 				if(r % M == 0) mn[r / M] = get(root[r / M], sum[r / M]); 			} 			l /= M; r /= M; 			while(l < r){ 				sum[l] ^= x; 				mn[l] = get(root[l], sum[l]); 				l++; 			} 		} 	} 	 	return 0; }
#include<iostream> using namespace std;  int flag = 1;  int min(int a,int b) { 	if(a<b) 		return a; 	flag = 2; 	return b;	 }  int main() { 	int n,i,j,k,min,save,q; 	long long int temp; 	while(cin>>n) 	{	 		int arr[n],bt[n][n+1]; 		long long int dp[n][n+1]; 		for(i=0;i<n;i++) 			cin>>arr[i]; 		if(n==1) 		{ 			cout<<"0"<<endl; 			continue; 		} 		if(n==2) 		{ 			cout<<arr[0]*arr[1]<<endl; 			continue; 		} 		for(i=0;i<n;i++) 		{ 			dp[i][i] = 0; 			bt[i][i] = arr[i]; 		} 		for(i=n-2;i>=0;i--)	 		{ 			for(j=i+1;j<n;j++) 			{ 				min = dp[i][i]+dp[i+1][j]+(bt[i][i]*bt[i+1][j]); 				save  = i; 				q = 2; 				for(k=i+1;k<j;k++) 				{ 					temp = dp[i][k]+dp[i+q][j]+(bt[i][k]*bt[i+q][j]); 					q++; 					if(temp<min)					 					{ 						min = temp; 						save = k; 					} 				} 				dp[i][j] = min; 				bt[i][j] = (bt[i][save]+bt[save+1][j])%100; 				//cout<<dp[i][j]<<" "<<bt[i][j]<<" "; 			} 			//cout<<endl; 		} 		cout<<dp[0][n-1]<<endl; 	} 	return 0;	 }
#include <stdio.h> #include <vector>  using namespace std; typedef pair<int,int>par; #define pb push_back #define s second #define f first #define mp make_pair const int maxn = 5e5;  int n,q;  vector<int>grafo[maxn]; int abitime[maxn],abid[maxn]; int position[maxn],health[maxn];  vector<par>poison[maxn]; vector<par>queries[maxn]; int salida[maxn]; bool mk[maxn];  int my_stack[maxn];  int ini[maxn],tmp[maxn],cnt[maxn],idx;  void updatedeath(int pos) { 	if(pos == 0)return ;  	while(pos <= q) 	{ 		abid[pos]++; 		pos += (pos&(-pos)); 	} }  void updatetime(int pos, int v) { 	if(pos == 0)return ;  	while(pos <= q) 	{ 		abitime[pos] += v; 		pos += (pos&(-pos)); 	} }  int querydeath(int pos) { 	int res = 0; 	while(pos) 	{ 		res += abid[pos]; 		pos -= (pos&(-pos)); 	} 	return res; }  int querytime(int pos) { 	int res = 0; 	while(pos) 	{ 		res += abitime[pos]; 		pos -= (pos&(-pos)); 	} 	return res; }  int timeofdeath(int chef) { 	if(querytime(q) < health[chef])return 2000000000; 	int a = 1; 	int b = q ;  	while(b - a > 1) 	{ 		int m = (b + a) >> 1; 		if(health[chef] <= querytime(m)) 			b = m; 		else 			a = m + 1; 	} 	return b; }  void dfs(int v) { 	position[idx++] = v; 	ini[v] = idx - 1;  	for(int i = 0; i < grafo[v].size(); i++) 		dfs(grafo[v][i]); }  void process() { 	dfs(0); 	for (int i = n;i >= 0;i--) 	{ 		cnt[i] = 0; 		for (int j = grafo[i].size() - 1;j >= 0;j--) 		{ 			cnt[i] += cnt[grafo[i][j]] + 1; 		} 	}  	for(int i = 1; i <= n; i++) 		tmp[i] = health[i];  	for(int i = 1; i <= n; i++) 		health[ini[i]] = tmp[i]; }  void ProcessData() { 	int cur_pos,i,j,node,top; 	// DFS START 	top = 0; 	my_stack[top] = 0; 	cur_pos = 0;  	while(top >= 0) 	{ 		node = my_stack[top]; 		top--; 		position[node] = cur_pos; 		cur_pos++;  		for (i = grafo[node].size() - 1;i >= 0;i--) 		{ 			my_stack[++top] = grafo[node][i]; 		} 	} 	// DFS END 	for (i = n;i >= 0;i--) 	{ 		cnt[i] = 0; 		for (j = grafo[i].size() - 1;j >= 0;j--) 		{ 			cnt[i] += cnt[grafo[i][j]] + 1; 		} 	}  	for(i = 1;i <= n;i++) 	{ 		tmp[i] = health[i]; 	} 	for(i = 1;i <= n;i++) 	{ 		health[position[i]] = tmp[i]; 	}  	return; }  int main() { 	scanf("%d", &n);  	int p,v,t; 	for(int i = 1; i <= n; i++) 	{ 		scanf("%d %d",&health[i],&p); 		grafo[p].pb(i); 	}  	scanf("%d", &q);  	process(); 	//ProcessData(); 	for(int i = 1; i <= q; i++) 	{ 		scanf("%d", &t); 		if(t== 1) 		{ 			scanf("%d %d",&p,&v); 			poison[ini[p] + 1].pb(mp(i,v)); 			poison[ini[p] + cnt[p] + 1].pb(mp(i,-v)); 		} 		else 		{ 			scanf("%d", &p); 			queries[ini[p]].pb(mp(i,1)); 			queries[ini[p] + cnt[p]].pb(mp(i,2)); 			salida[i] = cnt[p]; 			mk[i] = 1; 		} 	}  	for(int i = 1; i <= n; i++) 	{ 		for(int j =  poison[i].size() - 1; j >= 0; j--) 		{ 			updatetime(poison[i][j].f,poison[i][j].s); 		}  		updatedeath(timeofdeath(i)); 		for(int j = 0; j < queries[i].size(); j++) 		{ 			if(queries[i][j].second == 1) 				salida[queries[i][j].f] += querydeath(queries[i][j].f); 			else 				salida[queries[i][j].f] -= querydeath(queries[i][j].f); 		} 	}  	for(int i = 1; i <= q; i++) 	{ 		if(mk[i]) 			printf("%d\n",salida[i]); 	} 	return 0; }
#include <iostream> #include <cstdio> #include <cstring> #include <algorithm> using namespace std; #define N 100010 #define M 1000000007 #define ll long long #define uint unsigned #define ull unsigned long long int n,masks[30],v[30],g[30][30],e[33]; void dfs(int u) {  n++;e[n-1]=u;v[u]=0;  for(int i=1;i<=g[u][0];i++)  if(v[g[u][i]])dfs(g[u][i]); } int best,end; void res(int mask,int cur,int k) {  if(cur>=best)return;  if(mask==end){best=cur;return;}  if(cur+1>=best)return;  if(k>=n)return;  res(mask|masks[k],cur+1,k+1);  res(mask,cur,k+1); } int solve() {  if(n<=3)return 1;  end=(1<<n)-1;int inv[30];  for(int i=0;i<n;i++)inv[e[i]]=i;  best=(n+1)/2;  for(int i=0;i<n;i++)  {   masks[i]=1<<i;   for(int j=1;j<=g[e[i]][0];j++)   masks[i]|=1<<inv[g[e[i]][j]];  }   res(0,0,0);   return best; } int main() {    // freopen("in.txt","r",stdin); 	int T,i,j,k,c,m; 	scanf("%d",&T); 	while(T--) 	{ 	 scanf("%d",&m); 	 memset(v,0,sizeof(v)); 	 memset(g,0,sizeof(g)); 	 for(i=0;i<m;i++) 	 { 	  char a,b; 	  cin>>a>>b;a-='A',b-='A'; 	  v[a]=1,v[b]=1; 	  g[a][++g[a][0]]=b; 	  g[b][++g[b][0]]=a; 	 } 	 int tot=0; 	 for(i=0;i<30;i++) 	 { 	  if(v[i]) 	  { 	  	n=0; 	  	dfs(i); 	  	tot+=solve(); 	  } 	 } 	 printf("%d\n",tot*100); 	} 	return 0; } 
#include <stdio.h> #include <string.h>   int childrenCount, bedCount, caseCount;   struct Grid {    char c[100];    char b[100];    char bc[100][100]; };   void ClearCell(struct Grid * pG, int const b, int const c) {    int ii;      pG->bc[b][c] = 0;    pG->b[b] = 0;    pG->c[c] = 0;      for (ii = 0; ii < bedCount; ++ii)    {       if (pG->bc[ii][c])       {          pG->bc[ii][c] = 0;          --(pG->b[ii]);       }    }      for (ii = 0; ii < childrenCount; ++ii)    {       if (pG->bc[b][ii])       {          pG->bc[b][ii] = 0;          --(pG->c[ii]);       }    } }   int CalcMaxHappy(struct Grid const * const pG) {    int maxHappy, ii;    int cCount = 0;    int bCount = 0;      for (ii = 0; ii < bedCount; ++ii)    {       if (pG->b[ii])       {          ++bCount;       }    }      for (ii = 0; ii < childrenCount; ++ii)    {       if (pG->c[ii])       {          ++cCount;       }    }       maxHappy = (bCount <= cCount) ? bCount : cCount;     return maxHappy; }   int GetTheOnes (struct Grid * pG) {    int ii, jj, kk;    bool goAgain;    int happy = 0;      do    {       goAgain = false;         for (ii = 0; ii < bedCount; ++ii)       {          if (pG->b[ii] == 1)          {             goAgain = true;             ++happy;               for (jj = 0; jj < childrenCount && !(pG->bc[ii][jj]); ++jj);             pG->c[jj] = 0; 			             for (kk = 0; kk < bedCount; ++kk)             {                if (pG->bc[kk][jj])                {                   pG->bc[kk][jj] = 0;                   --(pG->b[kk]);                }             }          }       }         for (ii = 0; ii < childrenCount; ++ii)       {          if (pG->c[ii] == 1)          {             goAgain = true;             ++happy;               for (jj = 0; jj < bedCount && !(pG->bc[jj][ii]); ++jj);             pG->b[jj] = 0; 			             for (kk = 0; kk < childrenCount; ++kk)             {                if (pG->bc[jj][kk])                {                   pG->bc[jj][kk] = 0;                   --(pG->c[kk]);                }             }          }       }    } while (goAgain);      return happy; }   int Tree (struct Grid g, int const b, int const c) {    int t, ii, jj, maxHappy, happy;    int level = 0;      if (c >= 0 && b >= 0)    {       ClearCell(&g, b, c);       level = 1;    }      level += GetTheOnes(&g);    happy = level;      maxHappy = CalcMaxHappy(&g);      if (maxHappy == 0)    {       return happy;    }      maxHappy += level;      for (ii = 0; ii < bedCount; ++ii)    {       for (jj = 0; jj < childrenCount; ++jj)       {          if (g.bc[ii][jj])          {             t = Tree(g, ii, jj) + level;             if (t > happy)             {                happy = t;                  if (maxHappy == happy)                {                   return happy;                }             }          }       }    }      return happy; }     int main() {    int tcCount, ii;    struct Grid g;    scanf("%d", &tcCount);      for (ii = 0; ii < tcCount; ++ii)    {       scanf("%d %d", &childrenCount, &bedCount);       if (childrenCount > 100 || bedCount > 100) return -1;          memset(&g, 0, sizeof(struct Grid));         while (1)       {          int c, b;            scanf("%d %d", &c, &b);            if (c == 0 && b == 0) break;          //if (c == 0 || b == 0) return -1;          //if (c > childrenCount || b > bedCount) return -2;          --b;          --c;            g.bc[b][c] = 1;          ++(g.c[c]);          ++(g.b[b]);       }         printf("%d\n", Tree(g, -1, -1));    }      return 0; }
#include<bits/stdc++.h> using namespace std;   #define MEM(a,N,b) fill(a,(a+N),b) #define FORN(i, n) for(i = 0; i < n; i++) #define FORAB(i, a, b) for(i = a; i <= b; i++) #define FORR(i,n) for(i=n-1;i>=0;--i) #define elif else if #define mp make_pair #define pb push_back #define ff first #define ss second #define all(x) (x).begin(),(x).end() #define rall(x) (x).rbegin(),(x).rend() #define sll(x) scanf("%lld",&x) #define sl(x)  scanf("%ld",&x) #define sd(x)  scanf("%d",&x) #define pi(x)  printf("%d",x) #define pl(x)  printf("%ld",x) #define pll(x) printf("%lld",x) #define nl     printf("\n") #define sp     printf(" ") typedef pair<int,int> PII; typedef pair<double, double> PDD; typedef pair<int,long> PIL; typedef pair<long,int> PLI; typedef pair<int,long long> PILL; typedef pair<long long,int> PLLI; typedef pair<long,long> PLL; typedef pair<long long,long long> PLLLL; typedef pair<double,PIL> PDPIL; typedef vector<int> VI; typedef vector<long> VL; typedef vector<double> VD; typedef vector<long double> VLD; typedef vector<long long> VLL; typedef vector<VI> VVI; typedef vector<VL> VVL; typedef vector<VLL> VVLL; typedef vector<PII > VPII; typedef vector<PLL > VPLL; typedef vector<PIL> VPIL; typedef vector<PLI > VPLI; typedef vector<PILL> VPILL; typedef vector<PLLI> VPLLI; typedef vector<PLLLL> VPLLLL; typedef vector<VPLL> VVPLL; typedef vector<PDPIL> VPDPIL; #define ll long long #define l long #define MIN(a,b) ((a) < (b) ? (a) : (b)) #define MAX(a,b) ((a) > (b) ? (a) : (b)) #define ABS(x)   ((x) < 0 ? (-1)*(x) : (x)) #define Pi 3.1415926535897 #define MOD 1000000007 #define coolreshab ios::sync_with_stdio(false);//cin.tie(NULL)   /*freopen("test.txt","r",stdin);   freopen("out.txt","w",stdout);*/  ll fast_exp(ll a, ll b,ll mod) {     ll x=1,y=a;     while(b > 0)     {         if(b%2 == 1)         {             if(x>=mod) x%=mod;             x=(x*y);             if(x>=mod) x%=mod;         }         if(y>=mod) y%=mod;         y = (y*y);         if(y>=mod) y%=mod;          b /= 2;     }     return x; }  ll modcheck(ll n,ll mod) { 	while(n<0) 		n+=mod; 	if(n>=mod) 		n%=mod; 	return n; } ll modinverse(ll N,ll mod)  {      return fast_exp(N,mod-2,mod);  }   VPLLI arr; VLL neg; main()  { l T,N,K,i,np1,pp1,np2,pp2;    int flag1,flag2;    //coolreshab;   /*freopen("test.txt","r",stdin);   freopen("out.txt","w",stdout);*/    sl(T);    ll ans,x,inv;    while(T--)        {   ans=1;           x=0;           np1=pp1=np2=pp2=-1;           sl(N);           sl(K);           arr.resize(N);           FORN(i,N)           {               sll(arr[i].ff);               if(arr[i].ff<0)                 {                     arr[i].ss=0;                     neg.pb(arr[i].ff);                 }//0= negative               else                 arr[i].ss=1;//1=+              arr[i].ff=ABS(arr[i].ff);              //cout<<arr[i].ss<<endl;            }           sort(rall(arr));           sort(rall(neg));           pp1=np1=-1;           ans=1;           x=0;           FORN(i,K)           {               ans*=arr[i].ff;               if(ans>=MOD)                 ans%=MOD;               if(arr[i].ss==0)                 {                     np1=i;                     ++x;                 }               else                 pp1=i;           }          // cout<<ans<<endl;           flag1=flag2=0;           np2=pp2=-1;           if(x%2!=0)           {               for(;i<N;++i)               {                   if(flag1 and flag2)                     break;                   if(arr[i].ss==0 and flag1==0)                     {                         np2=i;                         flag1=1;                     }                   elif(arr[i].ss==1 and flag2==0)                   {                       pp2=i;                       flag2=1;                   }               }               if(np1!=-1 and pp2!=-1 and pp1!=-1 and np2!=-1)               {                   if(arr[np1].ff *1LL * arr[np2].ff < arr[pp1].ff * 1LL * arr[pp2].ff)                   {                       inv=modinverse(arr[np1].ff,MOD);                       ans= (ans * inv)%MOD;                       ans= (ans * arr[pp2].ff)%MOD;                   }                   else                   {                       inv=modinverse(arr[pp1].ff,MOD);                       ans= (ans * inv)%MOD;                       ans= (ans * arr[np2].ff)%MOD;                   }               }              elif((np1!=-1 and pp2!=-1 ) or (pp1!=-1 and np2!=-1))              {                  if(np1!=-1 and pp2!=-1)                  {                       inv=modinverse(arr[np1].ff,MOD);                       ans= (ans * inv)%MOD;                       ans= (ans * arr[pp2].ff)%MOD;                  }                  else                  {                      inv=modinverse(arr[pp1].ff,MOD);                      ans= (ans * inv)%MOD;                      ans= (ans * arr[np2].ff)%MOD;                  }              }              else              {                  if(K!=N)                   {                      ans=1;                      FORN(i,K)                      {                          ans*=neg[i];                          ans%=MOD;                          ans=modcheck(ans,MOD);                      }                   }                   else                   {                       ans=(ans%MOD * -1%MOD)%MOD;                       ans=modcheck(ans,MOD);                   }              }             }            pll(ans);           nl;           arr.clear();           neg.clear();         }  } 
#include <iostream>   #include <sstream>   #include <cstdio>   #include <cstdlib>   #include <cmath>   #include <memory.h>   #include <cctype>   #include <string>   #include <vector>   #include <list>   #include <queue>   #include <deque>   #include <stack>   #include <map>   #include <set>   #include <algorithm>   using namespace std;     #define FOR(i,a,b) for(int (i) = (a); (i) < (b); ++(i))  #define RFOR(i,a,b) for(int (i) = (a)-1; (i) >= (b); --(i))  #define CLEAR(a) memset((a),0,sizeof(a))  #define INF 1000000000  #define PB push_back  #define ALL(c) (c).begin(), (c).end()  #define pi 2*acos(0.0)  #define SQR(a) (a)*(a)  #define MP make_pair  #define MOD 1000000007    typedef long long Int;  typedef unsigned long long UInt;   int t; Int n; Int DP[1000];   int main() { 		cin >> t; 		FOR (tt,0,t) 		{ 				CLEAR(DP); 				cin >> n; 				n++; 				vector <Int> P; 				for (Int i = 1; i*i <= n; i++) 						if (n % i == 0) 						{ 								P.PB(i); 								if (i*i != n) 										P.PB(n/i); 						} 				sort(ALL(P)); 				DP[0] = 1; 				FOR (i,1,P.size()) 				{ 						DP[i] = 0; 						FOR (j,0,i) 								if (P[i] % P[j] == 0) 										DP[i] += DP[j]; 				} 				cout << DP[P.size()-1] << endl;   		} 		return 0; }    
#include<bits/stdc++.h> #define PB push_back using namespace std;  const double PI = 2.00*acos(0.0);  typedef complex<double> base; vector<base> omega; long long FFT_N,mod=99991;  void init_fft(int n) {      int i;      FFT_N=n;      omega.resize(FFT_N);      double angle=2*PI/FFT_N;       for(i=0; i<n; i++)      {           omega[i]=base( cos(i*angle), sin(i*angle) );      } }  void fft(vector<base>&a) {       int n=a.size();       if(n==1)  return;       int half=n/2;       vector<base>even(half),odd(half);        int i,j;       for(i=0,j=0; i<n; i+=2,j++)       {           even[j]=a[i];           odd[j]=a[i+1];       }        fft(even),fft(odd);        int fact=FFT_N/n;       for(i=0; i<half; i++)       {            base t=odd[i]*omega[i*fact];            a[i]=even[i]+t;            a[i+half]=even[i]-t;       } }  void multiply(const vector<long long>&a, const vector<long long>&b, vector<long long>&c) {     vector<base>fa(a.begin(),a.end()), fb(b.begin(),b.end());     int n=1;     while(n<2*max(a.size(),b.size()))  n<<=1;      fa.resize(n),fb.resize(n);     init_fft(n);     fft(fa),fft(fb);      int i;      //pointwise multiplication     for(i=0; i<n; i++)     {          fa[i]=conj(fa[i]*fb[i]);//conjugation is needed for interpolation     }      fft(fa);     c.resize(n);      //interpolation     for(i=0; i<n; i++)     {         c[i]=(long long)(fa[i].real()/n+0.5);         c[i]%=mod;     } }  long long pwr(long long base,long long pwr) {     long long res=1LL;     while(pwr>0)     {         if(pwr%2){             res=(res*base);             if(res>=mod)  res%=mod;         }         base*=base;         if(base>=mod)  base%=mod;         pwr/=2;     }     return res; }  int main() {      int n,i,j,l,p,k;      long long x,ya,yb,inv;      inv=22019LL;      vector<long long>a,b,c;      vector< vector<long long> >Pa[20];      vector< vector<long long> >Pb[20];       for(i=0; i<20; i++)  Pa[i].clear(),Pb[i].clear();       scanf("%d%d",&n,&k);       for(i=0; i<n; i++)      {          a.clear();          b.clear();          a.PB(1);          b.PB(1);           scanf("%lld",&x);          ya=pwr(55048,x);          yb=pwr(44944,x);           a.PB(ya);          b.PB(yb);           Pa[0].PB(a);          Pb[0].PB(b);      }       p=0;l=n;      while(l>1)      {          p++;          for(i=0; i<l/2; i++)          {              a.clear();              Pa[p].PB(a);              multiply(Pa[p-1][2*i],Pa[p-1][2*i+1],Pa[p][i]);               b.clear();              Pb[p].PB(b);              multiply(Pb[p-1][2*i],Pb[p-1][2*i+1],Pb[p][i]);          }          if(l%2)          {              Pa[p].PB(Pa[p-1][l-1]);              Pb[p].PB(Pb[p-1][l-1]);          }           l=Pa[p].size();      }        long long ans=(Pa[p][0][k]-Pb[p][0][k]+mod)%mod;      ans=(ans*inv)%mod;      cout<<ans<<endl;       return 0; } 
#define _USE_MATH_DEFINES #define _CRT_SECURE_NO_DEPRECATE #include <iostream> #include <cstdio> #include <cstdlib> #include <vector> #include <sstream> #include <string> #include <map> #include <set> #include <algorithm> #include <iomanip> #include <functional> #include <bitset> #include <cassert> #include <cmath> #include <ctime> #include <queue> #include <list> #include <memory.h> #include <complex> #include <numeric> using namespace std; #pragma comment(linker, "/STACK:256000000") #define mp make_pair #define pb push_back #define all(C) (C).begin(), (C).end() #define sz(C) (int)(C).size() #define PRIME 1103 #define PRIME1 31415 #define INF ((1ll << 30) - 1) #define MOD 1000000009 #define FAIL ++*(int*)0 #define EPS 1e-8 #define IT 10000 template<class T> T sqr(T a) {return a * a;} typedef long long int64; typedef unsigned long long uint64; typedef pair<int, int> pii; typedef pair<int64, int64> pi64; typedef pair<int, pii> piii; typedef vector<int> vi; typedef vector<int64> vi64; typedef vector<vi64> vvi64; typedef vector<pi64> vpi64; typedef vector<vpi64 > vvpi64; typedef vector<pii> vpii; typedef vector<vector<int> > vvi; typedef vector<vvi> vvvi; typedef vector<vector<pair<int, int > > > vvpii; typedef vector<vector<vector<pair<int, int > > > > vvvpii; typedef complex<double> cd; //------------------------------------------------------------  struct Point {     int64 x, y;     Point() {}     Point(int64 x, int64 y)         : x(x), y(y) {}      bool operator == (const Point &t) const     {         return x == t.x && y == t.y;     }      int64 dist(const Point &p) const     {         return abs(x - p.x) + abs(y - p.y);     }      bool operator < (const Point &t) const     {         return x == t.x ? y < t.y : x < t.x;     } };  bool comp1(const Point &l, const Point &r) {     Point t(0, 0);     return l.dist(t) < r.dist(t); }  bool comp2(const Point &l, const Point &r) {     Point t(1ll << 31, 0);     return l.dist(t) < r.dist(t); }  bool comp3(const Point &l, const Point &r) {     Point t(0, 1ll << 31);     return l.dist(t) < r.dist(t); }  bool comp4(const Point &l, const Point &r) {     Point t(1ll << 31, 1ll << 31);     return l.dist(t) < r.dist(t); }  set<Point, bool(*)(const Point&l, const Point&r)> s1(comp1); set<Point, bool(*)(const Point&l, const Point&r)> s2(comp2); set<Point, bool(*)(const Point&l, const Point&r)> s3(comp3); set<Point, bool(*)(const Point&l, const Point&r)> s4(comp4);  void add(Point p) {     s1.insert(p);     s2.insert(p);     s3.insert(p);     s4.insert(p); }  void remove(Point p) {     s1.erase(p);     s2.erase(p);     s3.erase(p);     s4.erase(p); }  int64 getAns(Point p) {     int64 res = 0;      if(!s1.empty())     {         Point t = *s1.begin();         res = max(res, t.dist(p));     }      if(!s2.empty())     {         Point t = *s2.begin();         res = max(res, t.dist(p));     }     if(!s3.empty())     {         Point t = *s3.begin();         res = max(res, t.dist(p));     }     if(!s4.empty())     {         Point t = *s4.begin();         res = max(res, t.dist(p));     }     return res; }  int main() { #ifdef __APPLE__     freopen("input.txt", "r", stdin);     freopen("output.txt", "w", stdout); #endif     int q;     scanf("%d\n", &q);      int64 ans = 0;     vector<Point> points;      for(int i = 0; i < q; ++i)     {         char cmd;         scanf("%c ", &cmd);          if(cmd == '+')         {             Point p;             scanf("%lld %lld\n", &p.x, &p.y);             p.x ^= ans;             p.y ^= ans;             points.pb(p);             add(p);         }         else if(cmd == '-')         {             int n;             scanf("%d\n", &n);             n ^= ans;             --n;             remove(points[n]);         }         else         {             Point p;             scanf("%lld %lld\n", &p.x, &p.y);             p.x ^= ans;             p.y ^= ans;              ans = getAns(p);             printf("%lld\n", ans);         }     }     return 0; }           
//longest common prefix between two consecutive suffixes #include<iostream> #include<algorithm> #include<cmath> #include<climits> #define MOD 1000000009 using namespace std;  struct suffix{ 	int rank[2];	//rank of current suffix and suffix that starts after k steps   	int index;		//original index of suffix };  struct cmp{ 	bool operator()(const suffix a,const suffix b){ 		return a.rank[0]<b.rank[0]||((a.rank[0]==b.rank[0])&&(a.rank[1]<b.rank[1])); 	} }; 	 long long mod_exponent(long long base,long long exp){     long long res=1;     while(exp){         if(exp%2)             res=(res*base)%MOD;         base=(base*base)%MOD; //      res=(res*res)%MOD;         exp/=2;     }     return res%MOD; }   int sortIndex[25][1000001]; void build_suffix(int str[],int suffixarr[],int n){ 	suffix suffixes[n];//stores 3 tuples for every suffix  	for(int i=0;i<n;i++){ 		sortIndex[0][i]=str[i]; 		suffixes[i].index=i; 	} 	 	for(int k=1,stp=1;k<n;k*=2,stp++){ 		for(int i=0;i<n;i++){ 			suffixes[i].rank[0]=sortIndex[stp-1][suffixes[i].index]; 			suffixes[i].rank[1]=(((suffixes[i].index + k) < n)?(sortIndex[stp-1][suffixes[i].index+k]):INT_MIN); 		} 		 		  		sort(suffixes,suffixes+n,cmp());    		sortIndex[stp][suffixes[0].index]=0;  		for(int i=1;i<n;i++){ 			sortIndex[stp][suffixes[i].index]=((suffixes[i].rank[0]==suffixes[i-1].rank[0]) && (suffixes[i].rank[1]==suffixes[i-1].rank[1]))?sortIndex[stp][suffixes[i-1].index]:sortIndex[stp][suffixes[i-1].index]+1; 	  		}  	}  	for(int i=0;i<n;i++){ 		suffixarr[i]=suffixes[i].index; 	} 	  }  int lcpf(int x,int y,int n){ 	 	int ans=0; 	for(int k=(int)ceil(log2(n));k>=0 && x<n && y<n;k--){ 		 		//cout<<x<<y<<endl; 		//cout<<sortIndex[k][x]<<sortIndex[k][y]<<endl; 		 		if(sortIndex[k][x]==sortIndex[k][y]){ 			int n=mod_exponent(2,k); 			ans=(ans+n)%MOD; 			x+=n; 			y+=n; 		} 	} 	return ans; }  void build_lcp_array(int str[],int lcp[],int n){ 	lcp[0]=0; 	int suffixArr[n]; 	build_suffix(str,suffixArr,n);  	for(int i=1;i<n;i++){ 		lcp[i]=lcpf(suffixArr[i],suffixArr[i-1],n); 		 	} }   int count_substring(int str[],int n){ 	int lcp[n]; 	build_lcp_array(str,lcp,n); 	int ans=(((long long)n*(n+1))/2)%MOD;  	for(int i=0;i<n;i++) 		ans=(ans-lcp[i]+MOD)%MOD; 	 	return ans; } 		  int main(){ 	int t,n,a,b; 	cin>>t; 	while(t--){ 		cin>>n; 		cin>>a; 		int diff[n]; 		for(int i=1;i<n;i++){ 			cin>>b; 			diff[i-1]=b-a; 			a=b; 		} 	cout<<count_substring(diff,n-1)<<endl; 	}      return 0; }   
#include<iostream> #include<cstdio> #include<cstdlib> #include<cstring> #include<cmath> #include<climits> #include<sstream>  #include<algorithm> #include<string> #include<vector> #include<set> #include<map> #include<utility> #include<stack> #include<queue> #include<deque> #include<list> #include<bitset>  using namespace std;  typedef vector<int> vi;  typedef vector<vi> vvi;  typedef vector<string> vs;  typedef pair<int,int> pii; typedef long long int lld; typedef long double Lf; typedef unsigned long long int llu;  #define sz(a)                        int((a).size())  #define pb                           push_back  #define mp                           make_pair #define F                            first #define S                            second #define present(c,x)                 ((c).find(x) != (c).end())  #define cpresent(c,x)                (find(all(c),x) != (c).end()) #define tr(c,i)                      for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) #define rtr(c,i)                      for(typeof((c).rbegin()) i = (c).rbegin(); i != (c).rend(); i++) #define all(c)                       (c).begin(),(c).end() #define si(n)                        inp(n) #define sl(n)                        scanf("%lld",&n) #define sf(n)                        scanf("%f",&n) #define sd(n)                        scanf("%lf",&n) #define ss(n)                        scanf("%s",n) #define sii(n,m)		     inp(n);inp(m) #define siii(n,m,r)		     inp(n);inp(m);inp(r)  #define abs(x)                       ((x)<0?-(x):(x)) #define fill(a,v)                    memset((a),(v),sizeof (a)) #define INF                          INT_MAX #define LINF                         (long long)1e18 #define EPS                          1e-9 #define MODBY 1000000009 #define MAX       #define getcx getchar_unlocked   inline void inp( int &n ) { n=0; int ch=getcx();int sign=1; while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}   while( ch >= '0' && ch <= '9' ) n = (n<<3)+(n<<1) + ch-'0', ch=getcx(); n=n*sign; }  const int mx = 1001000;  int base = 0;  int prev[8*mx]; long long int dp[mx]; int a[mx]; int b[mx]; int main() { 	int t,n,xx; 	si(t); 	while(t--) 	{ 		si(n); 		dp[base+0]=1; 		for(int i=0;i<n;i++) 			si(a[i]); 		for(int i=0;i<n-1;i++) 		{ 			b[i] = a[i+1]-a[i] + 4000010; 			prev[b[i]]=-1; 		} 		prev[b[0]]=0; 		for(int i=1;i<n-1;i++) 		{ 			if(prev[b[i]]==-1) 			{ 				dp[base+i]=((dp[base+i-1]<<1)+1+MODBY)%MODBY; 				prev[b[i]]=i; 				continue; 			} 			if(prev[b[i]]==0) 				dp[base+i]=(dp[base+i-1]<<1); 			else 				dp[base+i]=(dp[base+i-1]<<1)-dp[prev[b[i]]+base-1]; 			dp[base+i]=(dp[base+i]+MODBY)%MODBY; 			prev[b[i]]=i; 		} 		printf("%lld\n",dp[base+n-2]); 		base+=n; 	} 	return 0; }       
#include <cstdio> #include <algorithm> #include <vector> #include <cassert> #include <iostream>  using namespace std;  #define NMAX 20010 #define MOD 1000000007  vector<int> primes; vector<int> occ; vector<int> max_occ;  int comp[10010];  int A[NMAX]; int N;  void seive(){ 	int i,n,j;  	n = 10002;  	comp[0] = comp[1] = 1; 	for(i = 2; i*i <= n; ++i){ 		if(comp[i]) continue; 		for(j = i*i; j <= n; j+=i){ 			comp[j] = 1; 		} 	}  	for(i = 0; i <= n; ++i){ 		if(comp[i]) continue; 		primes.push_back(i); 		occ.push_back(0); 		max_occ.push_back(0); 	} }    int init(){ 	int i,k,oc;  	long long sol = 1; 	vector<int> left;  	for(i = 0; i < primes.size(); ++i) occ[i] = max_occ[i] = 0;  	sol = 1;  	for(k = 0; k < N; ++k){ 		i = 0; 		while(A[k] > 1 && i < (int)primes.size()){  			oc = 0; 			while(! (A[k]%primes[i]) ){ 				A[k] /= primes[i]; 				++oc; 			}  			occ[i] += oc; 			max_occ[i] = max(max_occ[i],oc); 			++i; 		}  		if(A[k] > 1) left.push_back(A[k]); 	}   	for(i = 0; i < primes.size(); ++i){ 		if(!occ[i]) continue; 		if(occ[i]%2 == 0 && max_occ[i]*2 <= occ[i]) continue; 		if(occ[i]%2) oc = 1; 		else oc = (max_occ[i]*2)-occ[i];  		while(oc--){ 			sol*= (long long)primes[i]; 			sol%=MOD; 		}  	}  	sort(left.begin(),left.end());   	for(i = 0; i < left.size(); ++i){ 		if(i+1 < left.size() && left[i] == left[i+1]){ 			++i; 			continue; 		} 		sol *= (long long)left[i]; 		sol %= MOD; 	}  	return sol; }    int main(){ 	int i,t;  	seive();  	scanf("%d",&t);  	while(t--){ 		scanf("%d",&N);  		for(i = 0; i < N; ++i){ 			scanf("%d",&A[i]); 		}  		printf("%d\n",init()); 	}  	return 0; } 
using namespace std;  #include <iostream> #include <cstdio> #include <cstdlib> #include <algorithm> #include <cmath> #include <cstring> #include <iterator> #include <sstream> #include <fstream> #include <cassert> #include <climits> #include <cstdlib> #include <string> #include <vector> #include <queue> #include <deque> #include <stack> #include <map> #include <set> #include <bitset> #include <stdio.h> #include <math.h> #include <list>  long long addmod(long long a, long long b, long long c){ 	a = a%c; 	b = b%c; 	long long sum = a-c+b; 	return sum<0 ? (sum+c):sum; }  long long timemod(long long x, long long y, long long m){ 	x %= m;   	y %= m;   	long long a = x < y ? x : y; // min   	long long b = x < y ? y : x; // max   	long long product = 0;  	for (; a != 0; a >>= 1, b = addmod(b,b,m) )     	if (a&1) product = addmod(product,b,m);  	return product; }  int main(){ 	// cout << sizeof(int) <<"\n"; 	// cout << sizeof(long long) << "\n"; 	// cout << sizeof(unsigned long long) << "\n"; 	// cout << timemod(4,5,5); 	int t,n; 	long long temp,a,b,c; 	string s; 	scanf("%d",&t); 	while(t--){ 		scanf("%d",&n); 		vector<long long> l; 		for (int i = 0; i < n; ++i) 		{ 			scanf("%lld",&temp); 			l.push_back(temp); 		} 		scanf("%lld %lld %lld",&a,&b,&c); 		cin >> s; 		int rev=0; 		long long mult=1,add=0,element; 		for (int i = 0; i < n; ++i) 		{ 			if (s[i]=='R') 			{ 				rev++; 			} 			else if (s[i]=='A') 			{ 				add = addmod(add,a,c); 			} 			else { 				mult = timemod(mult,b,c); 				add = timemod(add,b,c); 			} 			if (rev%2==0) 			{ 				element = l[0]; 				l.erase(l.begin()); 			} 			else { 				element = l[l.size()-1]; 				l.erase(l.end()-1); 			} 			long long temp = timemod(element, mult, c); 			temp = addmod(temp, add, c); 			if (i!=(n-1)) 			{ 				printf("%lld ", temp); 			} 			else printf("%lld\n",temp); 		} 	} 	return 0; }
#include<bits/stdc++.h> using namespace std;  #define ft first #define sd second #define mp make_pair  int n; pair< pair<int,int>,int > st[501000]; // no of 0, no of 1, flag =1,2  void rot(int l,int r,pair< pair<int,int>,int > &node){     int temp=node.ft.ft;     node.ft.ft=(r-l+1) - node.ft.sd - node.ft.ft;     node.ft.sd=temp;      node.sd=(node.sd+1)%3; }  void shift(int l,int r,int idx){      int mid = l + (r-l)/2;      if(st[idx].sd==1){         rot(l,mid,st[(idx<<1)+1]);         rot(mid+1,r,st[(idx<<1)+2]);     }else if(st[idx].sd==2){         rot(l,mid,st[(idx<<1)+1]);         rot(mid+1,r,st[(idx<<1)+2]);         rot(l,mid,st[(idx<<1)+1]);         rot(mid+1,r,st[(idx<<1)+2]);     }     st[idx].sd=0; }  void update(int idx,int l,int r,int ql,int qr){     if(l>r || ql>qr)         return;     if(r<ql || qr<l)         return;     if(ql<=l && r<=qr){         rot(l,r,st[idx]);         return;     }     // cout<<l<<" "<<r<<" : "<<ql<<" "<<qr<<endl;      shift(l,r,idx);     int mid= l + (r-l)/2;      update((idx<<1)+1,l,mid,ql,qr);     update((idx<<1)+2,mid+1,r,ql,qr);      st[idx].ft.ft=st[(idx<<1)+1].ft.ft + st[(idx<<1)+2].ft.ft;     st[idx].ft.sd=st[(idx<<1)+1].ft.sd + st[(idx<<1)+2].ft.sd;     st[idx].sd=0; }  int query(int idx,int l,int r,int ql,int qr){     if(l>r || ql>qr)         return 0;     if(r<ql || qr<l)         return 0;     if(ql<=l && r<=qr)         return st[idx].ft.ft;     shift(l,r,idx);     int mid=l + (r-l)/2;     return query((idx<<1)+1,l,mid,ql,qr)+query((idx<<1)+2,mid+1,r,ql,qr); }  void build(int idx,int l,int r){     if(l>r)         return;     if(l==r){         st[idx].ft.ft=1;         st[idx].ft.sd=0;         st[idx].sd=0;         return;     }     int mid= l + (r-l)/2;     build((idx<<1)+1,l,mid);     build((idx<<1)+2,mid+1,r);      st[idx].ft.ft=st[(idx<<1)+1].ft.ft + st[(idx<<1)+2].ft.ft;     st[idx].ft.sd=st[(idx<<1)+1].ft.sd + st[(idx<<1)+2].ft.sd;     st[idx].sd=0; }  int main(){     int i,j,k;     int x,y,z,t,q;      scanf("%d%d",&n,&q);      build(0,0,n-1);      for(i=0;i<q;i++){         scanf("%d%d%d",&t,&x,&y);          if(t==0){ // add 1             update(0,0,n-1,x,y);         }else if(t==1){ // query 1             printf("%d\n",query(0,0,n-1,x,y));         }        /*  for(j=0;j<n;j++)             cout<<query(0,0,n-1,j,j)<<" ";         cout<<endl;*/     }     return 0; }                
//#pragma comment(linker, "/STACK:102400000,102400000") #include <iostream> #include <algorithm> #include <stdio.h> #include <vector> #include <map> #include <string.h> #include <cmath> #include <assert.h> #include <iomanip> using namespace std; #define vi vector<int> #define pii pair<int,int> #define pb push_back #define mp make_pair #define all(x) x.begin(),x.end() #define inf 1000000007 #define mod 1000000007 #define x first #define y second #define pi acos(-1.0) #define DBG(x) cerr<<(#x)<<"="<<x<<"\n"; //#define debug(...) fprintf(stderr,__VA_ARGS__) #define debug(...) #define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++) #define ull unsigned long long #define ll long long #define N 100005  template <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;} template <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}  inline void add(int &a,int b){a+=b;if(a>=mod)a-=mod;} /* vi g[N]; int cnt,st[N],ed[N],d[N]; void dfs(int u,int h=0){     st[u]=++cnt;d[u]=h;     for(int i=0;i<g[u].size();i++){         int j=g[u][i];         dfs(j,h+1);     }     ed[u]=cnt; } int t[N<<2],c[N<<2],f[N],h[N<<2]; typedef int arr[2][2]; arr w[N]; void mul(const arr&a,const arr&b,arr &c){     memset(c,0,sizeof(c));     for(int i=0;i<2;i++)         for(int j=0;j<2;j++)             for(int k=0;k<2;k++){                 add(c[i][j],1LL*a[i][k]*b[k][j]%mod);             } } void func(int &a,int &b,int n){     if(n==0)return;     int x,y;     y=(1LL*w[n][0][0]*a+1LL*w[n][0][1]*b)%mod;     x=(1LL*w[n][1][0]*a+1LL*w[n][1][1]*b)%mod;     a=x,b=y; } void cal(int p,int v,int w,int l){     if(h[p]==-1){         h[p]=l;         c[p]=v,t[p]=w;         return;     }     if(h[p]<=l){         func(c[p],t[p],l-h[p]);         add(c[p],v),add(t[p],w);         h[p]=l;     }     else{         func(v,w,h[p]-l);         add(c[p],v),add(t[p],w);     } } void down(int p){     if(h[p]!=-1){         cal(p<<1,c[p],t[p],h[p]);         cal(p<<1|1,c[p],t[p],h[p]);         h[p]=-1;     } } void upd(int p,int l,int r,int x,int y,int v,int w,int h){     if(l>=x&&r<=y){         cal(p,v,w,h);return;     }     int m=(l+r)>>1;     down(p);     if(x<=m)upd(p<<1,l,m,x,y,v,w,h);     if(y>m)upd(p<<1|1,m+1,r,x,y,v,w,h); } int query(int p,int l,int r,int x,int d){     if(l==r){         if(h[p]==-1)return 0;         int a=c[p],b=t[p];         func(a,b,d-h[p]);         return b;     }     int m=(l+r)>>1;     down(p);     if(x<=m)return query(p<<1,l,m,x,d);     return query(p<<1|1,m+1,r,x,d); } int main(){     //cout<<fixed<<setprecision(5);     int T,i,j,k,ca=0,n,m;     f[1]=f[2]=1;     for(i=3;i<N;i++){         f[i]=(f[i-2]+f[i-1])%mod;     }     for(i=0;i<2;i++)w[0][i][i]=1;     arr a;     a[0][0]=a[0][1]=a[1][0]=1,a[1][1]=0;     for(i=1;i<N;i++)mul(w[i-1],a,w[i]);     scanf("%d%d",&n,&m);     for(i=1;i<n;i++){         scanf("%d",&j),j--;         g[j].pb(i);     }     cnt=0;     dfs(0);     memset(h,-1,sizeof(h));     while(m--){         char s[2];         scanf("%s%d",s,&i);i--;         if(s[0]=='U'){             scanf("%d",&j);             upd(1,1,n,st[i],ed[i],f[j-1],f[j],d[i]);         }         else{             printf("%d\n",query(1,1,n,st[i],d[i]));         }     }     return 0; } //*/  int a[11],b[11][2],q[11][2],c[11][2]; int main(){     int T,i,j,k,n,m;     scanf("%d",&T);     while(T--){         scanf("%d",&n);         for(i=0;i<n;i++){             scanf("%d",&m);             for(j=0;j<m;j++){                 scanf("%d",&k);                 a[j+1]=a[j]+k;             }             map<int,int>g;             c[i][0]=c[i][1]=0;             for(j=1;j<=m;j++)                 for(k=j;k<=m;k++){                     g[a[k]-a[j-1]]++;                     if(a[k]-a[j-1]==0)c[i][0]++;                     else c[i][1]++;                  }             map<int,int>::iterator it=g.end();it--;             b[i][0]=it->x,q[i][0]=it->y;             it=g.begin();             b[i][1]=it->x,q[i][1]=it->y;             if(b[i][0]==b[i][1])q[i][1]=0;         }         ll mx=-1LL<<60;int ans=0;         for(i=0;i<1<<n;i++){             ll s=1,s1=1;             for(j=0;j<n;j++)if(i>>j&1){                 s=s*b[j][0];s1=s1*q[j][0]%mod;             }             else{                 s=s*b[j][1];s1=s1*q[j][1]%mod;             }             {                 if(mx<s)mx=s,ans=s1;                 else if(mx==s)add(ans,(int)s1);             }         }         if(mx!=0)cout<<mx<<" "<<ans<<"\n";         else{             ans=1;int res=1;             for(i=0;i<n;i++){                 res=1LL*res*c[i][1]%mod;                 ans=1LL*ans*(c[i][1]+c[i][0])%mod;             }             ans-=res;             if(ans<0)ans+=mod;             printf("0 %d\n",ans);         }     }     return 0; } 
#include <iostream> #include <cstring> #include <string> #include <stdio.h> #include <algorithm> #include <vector> #include <map> #include <set> #include <cmath> #include <queue> using namespace std; #define N 505 #define ll unsigned long long  int t; int n,l,k; string S[N]; int cost[N][N]; int fail[N]; void overlap(int a,int b){ 	string A = S[a]; 	string B = S[b]; 	string pat = B + "#" + A; 	fail[0] = -1; 	int i = 0,j = -1; 	int m = pat.length(); 	while(i < m){ 		while(j >= 0 && pat[i] != pat[j]) 			j = fail[j]; 		i++;j++; 		fail[i] = j; 	} 	if(j == l) 		j = fail[j]; 	cost[a][b] = l - j; } int D[N][N]; int nex[N][N];  int main(){ 	scanf("%d",&t); 	while(t--){ 		vector<int> RA,RB; 		scanf("%d%d%d",&n,&l,&k); 		for(int i = 0;i<n;i++) 			cin>>S[i]; 		S[n] = ""; 		for(int i = 0;i<n;i++){ 			cost[n][i] = S[i].length(); 			for(int j = 0;j<n;j++){ 				overlap(i,j); 				//printf("%d ",cost[i][j]); 			} 			//printf("\n"); 		}  		for(int rem = 0 ;rem < k;rem++) 			for(int last = 0;last<n;last++){ 				if(rem == 0){ 					D[last][rem] = 0; 					continue; 				} 				int mi = 1<<29; 				for(int i = 0 ;i<n;i++){ 					int part = cost[last][i] + D[i][rem - 1]; 					if( part < mi){ 						mi = part; 						nex[last][rem] = i; 					} 				} 				D[last][rem] = mi; 			}  		int mi = 1<<29; 		for(int i = 0 ;i<n;i++){ 			int part = cost[n][i] + D[i][k - 1]; 			if( part < mi){ 				mi = part; 				nex[n][k] = i; 				D[n][k] = mi; 			} 		} 		int res = D[n][k]; 		printf("%d\n",res); 		int last = n; 		int pos = 0; 		string st  = ""; 		for(int i = k;i>=1;i--){ 			int ne = nex[last][i]; 			int rr = cost[last][ne]; 			RA.push_back(ne); 			pos += rr; 			RB.push_back(pos - l); 			string imp = S[ne].substr(l - rr); 			st += imp; 			last = ne; 		} 		cout<<st<<endl; 		for(int i = 0;i<k;i++) 			printf("%d %d\n",RA[i],RB[i]); 		printf("\n"); 	} 	return 0; } /* 123 1 3 4 aba  */ 
#pragma comment(linker,"/STACK:64000000") #define _CRT_SECURE_NO_WARNINGS #include <stdio.h> #include <iostream> #include <vector> #include <string> #include <algorithm> #include <map> #include <set> #include <sstream> #include <cmath> #include <ctime> #include <memory.h>  #define WR printf #define RE scanf #define PB push_back #define SE second #define FI first #define MP make_pair  #define FOR(i,Be,En) for(int (i)=(Be);(i)<=(En);++(i)) #define DFOR(i,Be,En) for(int (i)=(Be);(i)>=(En);--(i)) #define SZ(a) (int)((a).size()) #define FA(i,v) FOR(i,0,SZ(v)-1) #define RFA(i,v) DFOR(i,SZ(v)-1,0) #define CLR(a) memset(a,0,sizeof(a))  #define LL  long long #define VI  vector<int> #define PAR pair<int ,int>   using namespace std; void __never(int a){printf("\nOPS %d", a);} void __die(int a){printf("%d",(a*a)/(a+a));} #define ass(s) {if (!(s)) {__never(__LINE__);cout.flush();cerr.flush();__die(0);}}    const int INF = 1e9; int n, q; PAR rou[32];   PAR r[32][32]; int cc[32];  int graf[32][32]; int id[32][32];  int deg[32];   bool used[32]; int d[32]; int par[32]; int dist(PAR a, PAR b) { 	return (a.FI - b.FI)*(a.FI - b.FI) + (a.SE - b.SE)*(a.SE - b.SE); } void Calc(int v) { 	FOR(i,1,n) if (i != v) { 		int res = INF; 		int rid = -1; 		FOR(j,1,cc[v]) { 			int d = dist(r[v][j], rou[i]); 			if (d < res) { 				res = d; 				rid = j; 			} 		} 		graf[v][i] = res; 		id[v][i] = rid; 	} } void init() { 	freopen("input.txt","r",stdin); 	freopen("output.txt","w",stdout); } void sol(){	 	CLR(r); 	CLR(cc); 	cin >> n >> q; 	int x, y; 	PAR xy; 	FOR(i,1,n) { 		cin >> rou[i].FI >> rou[i].SE >> deg[i]; 	} 	FOR(i,1,n) Calc(i); 	int curm = 0.; 	FOR(Q,1,q) { 		cin >> x >> y; 		xy = MP(x,y); 		FOR(i,1,n) graf[0][i] = dist(xy, rou[i]); 		//dei 		FOR(i,0,n) { 			used[i] = false; 			d[i] = INF; 		} 		d[0] = 0; 		 		while (true) { 			int ind = -1; 			FOR(i,0,n) if (!used[i] && (ind == -1 || d[ind] > d[i])) ind = i; 			if (ind == -1) break; 			used[ind] = true; 			FOR(i,0,n) if (!used[i]){ 				int nd = max(d[ind], graf[ind][i]); 				if (d[i] > nd) { 					d[i] = nd; 					par[i] = ind; 				} 			} 		} 		// !dei 		int ind = -1; 		FOR(i,1,n) if (cc[i] < deg[i]) { 			if (ind == -1 || d[ind] > d[i]) ind = i; 		} 		ass(ind > 0); 		VI path; 		int cur = ind; 		int it = 0; 		while (cur) { 			path.PB(cur); 			cur = par[cur]; 			ass(++it < 1000); 		} 		path.PB(0); 		ass(SZ(path) > 1); 		reverse(path.begin(), path.end()); 		DFOR(i,SZ(path)-2,1) { 			int a = path[i]; 			int b = path[i+1]; 			r[b][++cc[b]] = r[a][id[a][b]]; 			swap(r[a][id[a][b]], r[a][cc[a]]); 			cc[a]--; 		} 		r[path[1]][++cc[path[1]]] = xy; 		 		FA(i,path) if (i) Calc(path[i]); 		curm = max(curm, d[ind]); 		WR("%.3lf\n",sqrt(1.*curm)); 	} 	WR("\n"); 	 } int main() { 	//init(); 	int T; 	cin >> T; 	FOR(t,1,T){ 		sol(); 	} 	return 0; }
/* ID: abhishe38 PROG: LANG: C++ */  //Data Structure includes #include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<string>   //Other Includes #include<iostream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath>  #define PB push_back #define MP make_pair #define MAXIMUM 18446744073709551615ULL #define MAX 1000009 #define MOD 1000000007  using namespace std;  typedef long long int LL; typedef unsigned long long int ULL; typedef unsigned int UI; typedef pair<int,int> PII; typedef vector<int> VI; typedef vector< pair<int,int> > VPI;  VI Fact; int dp[1010][1010];  void pre() {     Fact.PB(1);     LL tmp;     for (int i=1; i<MAX; i++)     {         tmp = Fact[i-1];         tmp *= i;         tmp %= MOD;         Fact.PB(tmp);     }      for (int i=0; i<1010; i++)     {         for (int j=0; j<1010; j++)         dp[i][j] = 0;     }      for (int i=1; i<1010; i++)     {         dp[i][1] = 1;     }      for (int i=2; i<=1001; i++)     {         for (int j=2; j<=i; j++)         {             dp[i][j] += (((1LL*(j))*dp[i-1][j])%MOD);             dp[i][j] += dp[i-1][j-1];             if (dp[i][j]>MOD) dp[i+1][j+1] -= MOD;         }     }   }  int powmod(LL a, LL b) {    LL x=1,y=a;    while (b>0)    {        if (b&1)        x = (x*y)%MOD;         y = (y*y)%MOD;        b >>= 1;    }    return x; }  int inverse_mod(LL a) {     return powmod(a,MOD-2); }  LL Perm(int m, int k) {     return ((1LL*Fact[m])*inverse_mod(Fact[m-k]))%MOD; }  LL solve(int n, int m, int k) {     k = min(m,k);     LL res = 0;     for (int j=1; j<=k; j++)     {             res += (1LL*Perm(m,j))*dp[n][j];             if (res>MOD) res %= MOD;     }  return res; }  int main() {     pre(); //    for (int i=0; i<10; i++) //    { //        for (int j=0; j<10; j++) //        cout<<"dp["<<i<<"]"<<"["<<j<<"]: "<<dp[i][j]<<"\n"; //        cout<<"\n"; //    }     int t,n,m,k;     scanf("%d",&t);     LL ans;     while (t--)     {         scanf("%d%d%d",&n,&m,&k);         ans = solve(n,m,k);         printf("%lld\n",(ans%MOD));     }    //system("pause");    return 0; } 
#include <vector> #include <list> #include <map> #include <set> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <string> #include <queue> #include <cassert> #define rep(i,a,n) for(int i=a;i<n;i++) #define in(n) scanf("%d",&n) #define inl(n) scanf("%lld",&n) #define out(n) printf("%d ",n) #define outln(n) printf("%d\n",n) #define outl(n) printf("%lld ",n) #define outlln(n) printf("%lld\n",n) #define LL long long  #define pb push_back #define f first #define s second   using namespace std;   int a[10]; long long int n; double x,y,s; double g[10][4];     void ne(double tmp[], double& xx, double& yy, double tt) {     xx = tmp[0] + tmp[2]*tt;     yy = tmp[1] + tmp[3]*tt; }   double re(double tmp[], double xx, double yy, double tt) {     double py = tmp[1], px = tmp[0], vx = tmp[2], vy = tmp[3];     px = px + vx * tt, py = py + vy * tt;     double aa = s*s - vy*vy - vx*vx;     double bb = -2*((py - yy)*vy + (px-xx)*vx);     double cc = -1*(py-yy)*(py-yy) + -1LL*(px-xx)*(px-xx);     double aax;     double sol1 = -bb + (aax = sqrt(bb*bb - 4 * aa * cc));     double sol2 = -bb - aax;     if(sol2 > 0.0)         return sol2/(2*aa);     return sol1/(2*aa); }   int main() {     int nt, kase = 1;     while(1) {         double ix, iy;         rep(i,0,10)a[i] = i;         double mint = 1000000000000000000LL;         if(inl(n)==EOF)break;         if(n==0LL)break;         rep(i,0,n) {             rep(tt,0,4)scanf("%lf",&g[i][tt]);         }         scanf("%lf%lf%lf",&x,&y,&s);         ix = x, iy = y;         do {             x = ix, y = iy;             double cur = 0;             for(int i=0;i<n;i++) {                 double xx = re(g[a[i]], x, y, cur/3600LL);                 double tt = xx*3600LL + 3600LL;                 cur += tt;                 ne(g[a[i]], x, y, cur/3600LL);             }             double back = (x - ix)*(x-ix) + (y-iy)*(y-iy);             back = sqrt(back);             back /= s;             back = back * 3600LL;             mint = min(mint, cur + back);         }         while(next_permutation(a,a+n));         long long miint = ceil(mint);         long long hrs = miint / 3600LL;         miint = miint % 3600LL;         long long mins = miint / 60LL;         miint = miint % 60LL;         printf("%d %lld %lld %lld\n",kase++, hrs, mins, miint);     }     return 0; } 
#include<cstdio> #include<iostream> #include<algorithm> #include<cstdlib> #include<cstring> #include<queue>   using namespace std;   int main(){ 	int T; 	cin >> T; 	long long int waiting[1000000]; 	while(T--){ 		long long int p, q, m, n, k; 		scanf("%lld%lld%lld%lld%lld",&p,&q,&m,&n,&k); 		long long int alreadyTook = 0; 		long long int readyToLand = p; 		long long int alreadyLanded = 0; 		long long int initial = 0; 		long long int final = -1; 		long long int waitingCount = 0; 		long long int readyToFly = q; 		queue <long long int> temp; 		for (long long int i=1;i<k+2;i++){ 			if(! temp.empty()){	 			if(temp.front()+n <= i){ 				temp.pop(); 				readyToFly++; 			} 			} 			if(readyToLand){ 				readyToLand--; 				alreadyLanded++; 				//insert 				temp.push(i); 				//final++; 				//waiting[final] = n; 			} 			else if(readyToFly){ 				readyToFly--; 				alreadyTook++; 			} 			if ((i)%m == 0 ){ 				readyToLand++; 			} 		//cout <<  alreadyTook << " " << readyToLand << " " << waitingCount << " " << readyToFly << endl; 		} 		//printf("%lld %lld %lld %lld\n", alreadyLanded, alreadyTook, readyToLand,    		cout << alreadyLanded << " " << alreadyTook << " " << readyToLand << " " << readyToFly+temp.size() << endl; 	} 	return 0; }
#include<iostream> #include<cstring> #include<vector> using namespace std; int gcd(int a,int b) {     if(b==0) return a;     return gcd(b,a%b); } int arr[10][10]={{55,	60,	4	,25	,18,	10,	12,	8,	11,	50},{60,	45,	75,	23,	27,	20,	24,	7,	33,	12},{4,	75,	78,	32,	36,	30,	36,	6,	12,	65},{25,	23,	32,	15,	45,	40,	48,	5,	14,	23},{18,	27,	36,	45,	54,	50,	60,	4,	15,	12},{10,	20	,30,	40,	50,	60,	72,	3,	32,	34},{12,	24	,36,	48,	60,	72,	84,	2,	23,	34},{8	,7	,6	,5	,4	,3	,2	,1	,34	,123},{11	,33	,12	,14	,15	,32	,23	,34	,65	,48},{50	,12	,65	,23	,12	,34	,34	,123	,48	,71}}; int mx; void func(int A[],int B[],int ele,int sum) {      /*cout<<ele<<" "<<sum<<"\n";      system("pause");"*/      if(ele==9 && A[ele]==2)      {                 if(sum>mx)                           mx=sum;                 return;      }      while(!(B[ele]==1 && A[ele]<2))      {                        if(ele>=10)                        {                                   if(sum>mx)                                             mx=sum;                                   return;                        }                        ele++;      }      A[ele]++;      for(int i=ele;i<10;i++)      {              if(B[i]==1 && A[i]<2)              {                         A[i]++;                         func(A,B,ele,sum+arr[ele][i]);                         A[i]--;              }      }      A[ele]--;      return; }              int main() {     int t;     cin>>t;     while(t--)     {               mx=0;               int A[10],B[10];               for(int i=0;i<10;i++)                       cin>>A[i];               for(int i=0;i<10;i++)               {                       cin>>B[i];                       if(A[i]==0) B[i]=0;               }               memset(A,0,sizeof(A));               int tmp=0;               for(int i=0;i<10;i++)               {                       if(B[i]==1)                                  tmp=1;               }               if(tmp!=0)               {                         int ele=-1;                         for(int i=0;i<10;i++)                         {                                 if(B[i]==1 && A[i]<2)                                 {                                            ele=i;                                            break;                                 }                         }                         A[ele]++;                         for(int i=0;i<10;i++)                         {                                 if(B[i]==1 && A[i]<2)                                 {                                            A[i]++;                                            func(A,B,ele,arr[ele][i]);                                            A[i]--;                                 }                         }               }               cout<<mx<<"\n";     }     return 0; }                                                                          
#include<bits/stdc++.h> using namespace std; int main(){   int T, N, M, i,j,k,a,b,aa,bb,c;   int mn[51], mx[51];   mn[0] = mx[0] = 0;     for(i=1;i<=30;i++){     k = i / 2;     mn[i] = mn[k] + mn[i-k-1] + i+1;     mx[i] = mx[i-1] + mx[0] + i+1;   }   cin>>T;   while(T--){   	cin>>N>>M;     if(M < mn[N])       puts("-1");     else if(M <= mx[N]) puts("0");     else                printf("%d\n",M-mx[N]);   } }
 #include <cmath> #include <iostream> #include <algorithm> #include <cstring> #include <stack> #include <map> #include <set> #include <queue> using namespace std;   int d1[100005]; int d2[100005]; char s[100005];   struct item{ 	int l, x; 	bool open; 	bool operator<(const item &sec) const { 		return l != sec.l ? l < sec.l : x != sec.x ? x < sec.x : open > sec.open; 	} } arr[100005];       int v[100005];   int main(){ 	int T; 	scanf("%d", &T); 	for (int I=0; I<T; I++){ 		scanf("%s", s); 		int l = 0, r = -1, n = strlen(s); 		for (int i=0; i<n; i++){ 			int k = (i > r ? 0 : min(d1[l+r-i], r-i))+1; 			while (i+k < n && i-k >=0 && s[i+k] == s[i-k]) { 				++k; 			} 			d1[i] = --k; 			if (i+k > r) { 				l = i-k; 				r = i+k; 			} 		} 		l = 0; 		r = -1; 		for (int i=0; i<n; i++){ 			int k = (i > r ? 0 : min(d2[l+r-i+1], r-i+1))+1; 			while (i+k-1 < n && i-k >=0 && s[i+k-1] == s[i-k]) { 				++k; 			} 			d2[i] = --k; 			if (i+k-1 > r) { 				l = i-k; 				r = i+k-1; 			} 		}   		{ 			int bg = -1, en = n+1; 			priority_queue<int> SS; 			for (int i=0; i<n; i++){ 				arr[i].l = 2*d1[i] + 3; 				arr[i].x = i; 				arr[i].open = true; 			} 			sort(arr, arr+n); 			l = 0;   			for (int i=1; i<=n; i += 2) { 				while (l < n && arr[l].l <= i){ 					SS.push(-arr[l].x); 					l++; 				} 				while (!SS.empty()){ 					int v = -SS.top(); 					if (2*min(v+1, n-v) + 1 <= i){ 						SS.pop(); 					} else { 						break; 					} 				} 				if (SS.empty()){ 					v[i] = 0; 				} else { 					v[i] = -SS.top() - (i >> 1) + 1; 				} 			} 		} 		// Odd are ready. 		{ 			priority_queue<int> SS; 			for (int i=0; i<n; i++){ 				arr[i].l = d2[i]+1; 				arr[i].x = i; 				arr[i].open = true; 			} 			sort(arr, arr+n); 			l = 0; 			for (int i=2; i<=n; i += 2) { 				while (l < n && arr[l].l <= (i >> 1)){ 					SS.push(-arr[l].x); 					l++; 				} 				while (!SS.empty()){ 					int v = -SS.top(); 					if (min(v+1, n-v+1) <= i/2){ 						SS.pop(); 					} else { 						break; 					} 				} 				if (SS.empty()){ 					v[i] = 0; 				} else { 					v[i] = -SS.top() - (i >> 1) + 1; 				} 			} 		}   		unsigned long long ret = 0; 		for (int i=1; i<=n; i++){ 			ret = ret * 100007 + v[i]; 		} 		cout << ret << "\n"; 	} 	return 0; }
#include <stdio.h>  #define REAL double #define REAL_READ_FORMAT "%lf" #define REAL_PRINT_FORMAT "%.6lf"  int main() { //	freopen("x.txt", "r", stdin); 	int T, N, P, M, B; 	REAL R1, R2, R3, R4, ans = 0.0, cans, A1, A2, A3, A4, A5, cans2; 	scanf("%d %d %d %d %d", &T, &N, &P, &M, &B); 	scanf(REAL_READ_FORMAT" "REAL_READ_FORMAT" "REAL_READ_FORMAT" "REAL_READ_FORMAT" ", &R1, &R2, &R3, &R4); 	for (int t = 1; t <= T; t++) { 		N = (((long long) N * (long long) P) % M) + B; 		if (N == 1) cans = R1; 		else if (N == 2) cans = R2; 		else if (N == 3) cans = R3; 		else if (N == 4) cans = R4; 		else { 			A1 = -1.0 / R1; 			A2 = 1.0 / R2; 			A3 = 1.0 / R3; 			A4 = 1.0 / R4; 			REAL C1 = A4 - A3 - 7 * (A1 + A2); 			REAL C2 = A3 - 9 * (A1 + A2) - 3 * C1; 			cans = 1.0 / ((A1 + A2) * (long long) N * (long long) N + C1 * N + C2); 			/* 			cans2 = 0.0; 			for (int i = 5; i <= N; i++) { 				cans2 = 2 * (A1 + A2 + A4) - A3; 				A3 = A4; 				A4 = cans2; 			} 			cans2 = 1.0 / cans2; 			fprintf(stderr, "N=%d: %lf %lf\n", N, cans, cans2); 			*/ 		} 		ans += cans; 	} 	printf(REAL_PRINT_FORMAT"\n", ans); 	return 0; }
#include <iostream> #include <cstdio> #include <cstring> #include <cstdlib> #include <cctype> #include <algorithm> #include <map> #include <vector> #include <list> #include <set> #include <queue> #include <deque> #include <stack> #include <string> #include <cmath> #include <cassert>  #define FOR(i,a,b) for(int i=a;i<b;i++) #define FORD(i,a,b) for(int i=a;i>=b;i--) #define REP(i,n) FOR(i,0,n) #define PB push_back #define ITER(i,a) for( typeof(a.begin()) i=a.begin();i!=a.end();i++)	 #define mod 1000000007 #define MAXN 1000010 #define MP make_pair #define INF mod typedef long long int LL; using namespace std;  char prime[1000000] = {0}; int P[100000],k; int a[11];  void sieve(){     P[k++] = 2;      for(int i=3;i*i<1000000;i+=2){         if(!prime[i]){             P[k++] = i;             for(int j=i*i;j<1000000;j+=i+i)                 prime[j] = 1;         }     }     for(int j=1001;j<1000001;j+=2){         if(!prime[j])             prime[j] = 1;     } }  int main() {     sieve();     int T,N;     scanf("%d", &T);     map<int, int> m;          while(T--){         scanf("%d", &N);         REP(i,N){             scanf("%d", &a[i]);         }         m.clear();          REP(i,N){             REP(j,k){                 while(a[i]>1 && a[i]%P[j]==0){                     a[i]/=P[j];                     if(m.find(P[j])!=m.end()){                         m[P[j]]++;                     }                     else{                         m.insert(MP(P[j], 1));                     }                 }             }             if(a[i]!=1){                 if(m.find(a[i])!=m.end()){                     m[a[i]]++;                 }                 else{                     m.insert(MP(a[i],1));                 }             }         }         map<int,int>::iterator it;         LL ans=1;         for(it=m.begin();it!=m.end();it++){             ans*=((*it).second+1LL);         }         printf("%lld\n", ans);     }     return 0; } 
    #include<iostream>     #include<string>     #include<vector>     #include<map>     #include<queue>     #include<deque>     #include<set>     #include<stack>     #include<sstream>     #include<fstream>     #include<algorithm>     #include<cstdlib>     #include<cstdio>     #include<cstring>     #define CLRM(x) memset(x,-1,sizeof(x))     #define CLR(x) memset(x,0,sizeof(x))     #define ALL(x) x.begin(),x.end()     #define PB push_back     #define MP make_pair     #define VI vector<int>     #define VVI vector<vector<int> >     #define PII pair<int,int>     #define SZ(x) (int)x.size()     #define LL long long     #define MIN(a,b) (a)<(b)?(a):(b)     #define MAX(a,b) (a)>(b)?(a):(b)     #define LMAX 1000000000000000000LL     #define IMAX 100000000     using namespace std;     #include<complex>     complex<double> a[10][10];     double N=8.0;     int n=8;     int sn;     int pw;     int off;     #define PI 3.1415926535     #define eps 1e-9     #define VCD vector<complex<double> >     #define CD complex<double>     CD twiddle[1005555];     int reversed[1005555];     VCD getVCD(char *t,int off)     {     string s(t);     int i,j,k;     while(SZ(s)%off!=0)     {     s="0"+s;     }     VCD ret;     for(i=0;i<SZ(s);i+=off)     {     int val=0;     for(j=i;j-i<off;j++)     {     val*=10;     val+=(s[j]-'0');     }     ret.PB(CD(val,0));     }     return ret;     }     VCD extend(VCD _v,int n)     {     VCD v=_v;     while(SZ(v)!=n)     {     v.PB(CD(0,0));     }     return v;     }     void Vdisp(VCD &v)     {     int i,j,k;     for(i=0;i<SZ(v);i++)     {     cout<<(fabs(v[i].real())<eps?0:v[i].real())<<" , "<<(fabs(v[i].imag())<eps?0:v[i].imag())<<"\t";     }     cout<<endl;     }     void disp(VCD &v)     {     int i,j,k;     for(i=0;i<SZ(v);i++)     {     cout<<(fabs(v[i].real())<eps?0:v[i].real())<<" ";     }     cout<<endl;     }     CD gettwid(int _N,int _n,int _k)     {     int tn=_n;     int t=_N;     while(t<N)     {     t<<=1;     tn<<=1;     }     return twiddle[tn];     }     CD twid(int _N,int _n,int _k)     {     return CD(cos(2*PI*_n*_k/_N),-sin(2*PI*_n*_k/_N));     }     VCD FT(VCD &v)     {     int i,j,k;     VCD prev=v;     VCD now=VCD(SZ(v),CD(0,0));     int nn=n;     for(i=n;i!=1;i>>=1)     {     for(j=0;j<SZ(now);j+=i)     {     int c=0;     for(k=j;k<j+i/2;k++,c++)     {     now[k]=prev[k]+prev[k+i/2];     now[k+i/2]=(prev[k]-prev[k+i/2])*gettwid(i,c,1);     }     }     prev=now;     }     return now;     }     int rev(int t,int szn)     {     int tp=1<<(szn-1);     int i,j,k;     j=t;     int ret=0;     for(i=0;i<szn;i++)     {     if(j&1)     ret|=tp;     tp>>=1;     j>>=1;     }     return ret;     }     VCD bitrev(VCD v)     {     int i,j,k;     VCD ret=VCD(SZ(v),CD(0,0));     for(i=0;i<SZ(v);i++)     {     ret[reversed[i]]=v[i];     }     return ret;     }     VCD mult(VCD &v1,VCD &v2)     {     VCD ret;     int i,j,k;     for(i=0;i<SZ(v1);i++)     {     ret.PB(v1[i]*v2[i]);     }     return ret;     }     VCD IFT(VCD &v)     {     int i,j,k;     VCD prev=v;     VCD now=VCD(SZ(v),CD(0,0));     int nn=n;     for(i=n;i!=1;i>>=1)     {     for(j=0;j<SZ(now);j+=i)     {     int c=0;     for(k=j;k<j+i/2;k++,c++)     {     now[k]=prev[k]+prev[k+i/2];     now[k+i/2]=(prev[k]-prev[k+i/2])*conj(gettwid(i,c,1));     }     }     prev=now;     }     for(i=0;i<SZ(now);i++)     {     now[i]/=N;     }     return now;     }     string getans(VCD &v)     {     int i,j,k;     string s;     int carry=0;     for(i=SZ(v)-1;i>=0;i--)     {     int t1=carry+v[i].real()+0.5;     int t=t1;     int x=t%pw;     for(j=0;j<off;j++)     {     s.PB((x%10)+'0');     x/=10;     }     carry=t/pw;     }     while(carry!=0)     {     s.PB((carry%10)+'0');     carry/=10;     }     while(s[SZ(s)-1]=='0')     s.resize(SZ(s)-1);     reverse(ALL(s));     return s;     }     char buf[601000];     char s1[301000];     char s2[301000];     char s3[301000];     int sl1, sl2;     void add1(char*s, int& c)     {     //cout<<s<<" "<<c<<endl;     int t=c-1;     while(t>=0 && s[t]=='9')     {     s[t]='0';     t--;     }     if(t<0)     {     s[c]='0';     s[0]='1';     c++;     }     else     {     s[t]++;     }     }     void div2(char*s, int& c)     {     int car = 0;     int cur = 0;     int i, j, k;     s3[c]='\0';     for(i = 0; i < c; i++)     {     int t = s[cur]-'0';     t = car*10+t;     s3[cur]=(t/2)+'0';     car = (t%2);     cur++;     }     strcpy(s, s3);     }     void process()     {     int cur=0;     int i, j, k;     while(buf[cur]!='\0')     {     s1[sl1++]=buf[cur];     s2[sl2++]=buf[cur];     cur++;     }     s1[sl1]='\0';     s2[sl2]='\0';     add1(s1,sl1);     if((s1[sl1-1]-'0')%2==0)     {     //cout<<s1<<endl;     div2(s1,sl1);     }     else     {     //cout<<s2<<endl;     div2(s2,sl2);     }     }     int main()     {     int tes;     scanf("%d",&tes);     getchar();     int prev=-1;     while(tes--)     {     int i,j,k;     //string s1,s2;     gets(buf);     int flag=0;     int cur=0;     sl1=0,sl2=0;     //cout<<buf<<endl;     process();     /*while(buf[cur]!='\0')     {     if(buf[cur]==' ')     {     flag=1;     cur++;     continue;     }     if(flag==0)     {     s1[sl1++]=(buf[cur]);     }     else     {     s2[sl2++]=(buf[cur]);     }     cur++;     }*/     s1[sl1]='\0';     s2[sl2]='\0';     //cout<<s1<<" "<<s2<<endl;     int z1=0;     while(s1[sl1-1]=='0' && sl1>0)     {     s1[sl1-1]='\0';     sl1--;     z1++;     }     while(s2[sl2-1]=='0' && sl2>0)     {     s2[sl2-1]='\0';     sl2--;     z1++;     }     if(sl1==0 || sl2==0)     {     cout<<0<<endl;     continue;     }     off=min(3,min(sl1,sl2));     pw=1;     for(i=0;i<off;i++)     pw*=10;     VCD v1=getVCD(s1,off);     VCD v2=getVCD(s2,off);     int t=SZ(v1)+SZ(v2)-1;     n=1;     sn=0;     while(n<=t)     {     sn++;     n<<=1;     }     N=n;     if(n!=prev)     for(i=0;i<=n/2;i++)     {     twiddle[i]=twid(n,i,1);     }     if(n!=prev)     for(i=0;i<n;i++)     {     reversed[i]=rev(i,sn);     }     v1=extend(v1,n);     v2=extend(v2,n);     VCD ft1=FT(v1);     VCD ft2=FT(v2);     ft1=bitrev(ft1);     ft2=bitrev(ft2);     VCD fmul=mult(ft1,ft2);     VCD ans=IFT(fmul);     ans=bitrev(ans);     ans.resize(t);     string ret=getans(ans);     ret+=string(z1,'0');     printf("%s\n",ret.c_str());     prev=n;     }     }  
//Template by @sai krishna #include <map> #include <set> #include <queue> #include <cmath> #include <stack> #include <vector> #include <cstdio> #include <bitset> #include <sstream> #include <cassert> #include <cstring> #include <utility> #include <iterator> #include <iostream> #include <algorithm> #include <functional> using namespace std; #define rep(i,a,n) for(int i=a;i<n;i++) #define srt(x) sort(x.begin(),x.end()) #define clear(x,val) memset(x,val,sizeof x) #define rl(x) scanf("%lld",&x) #define ri(x) scanf("%d",&x) #define gc getchar_unlocked #define pi2 pair<pii,int> #define pii pair<int,int> #define MOD 1000000007 #define LL long long #define MAX 100000001 #define ss second #define INF 1<<32 #define ff first LL fact[2000004],inv_fact[1000004]; void factorial() { 	inv_fact[0]=fact[0]=inv_fact[1]=1; 	for(int i=1;i<=2000050;i++) 	{ 		fact[i]=(fact[i-1]*i)%MOD; 	} 	for(int i=2;i<=1000000;i++) 		inv_fact[i]=(MOD - (MOD/i) * inv_fact[MOD%i] % MOD) % MOD; } LL nCr(LL n,LL r) { 	return (((fact[n]*inv_fact[n-r])%MOD) * inv_fact[r])%MOD; } LL Inverse(LL a,LL b) { 	LL x=1,y=a; 	while(b) 	{ 		if(b&1) 		x*=y; 		if(x>MOD)x%=MOD; 		y*=y; 		if(y>MOD)y%=MOD; 		b>>=1; 	} 	return x; } int main() { 	int t; 	ri(t); 	factorial(); 	while(t--) 	{ 		LL n,k; 		rl(n),rl(k); 		long long ans=(2LL*(fact[n+k+1]*Inverse(fact[n-1],MOD-2))%MOD * (Inverse(fact[k+2],MOD-2))%MOD -n+MOD)%MOD; 		cout<<ans<<endl; 	} 	return 0; }  
#include <algorithm> #include <iostream> #include <cstring> #include <cstdio> using namespace std;   pair< long long, int > R[32769]; long long result, a[20], x; int r[65], sign;   unsigned long long func( unsigned long long x ){ 	x = (x & 0x5555555555555555ULL) + ((x >> 1) & 0x5555555555555555ULL); 	x = (x & 0x3333333333333333ULL) + ((x >> 2) & 0x3333333333333333ULL); 	x = (x & 0x0f0f0f0f0f0f0f0fULL) + ((x >> 4) & 0x0f0f0f0f0f0f0f0fULL); 	x = (x & 0x00ff00ff00ff00ffULL) + ((x >> 8) & 0x00ff00ff00ff00ffULL); 	x = (x & 0x0000ffff0000ffffULL) + ((x >> 16) & 0x0000ffff0000ffffULL); 	x = (x & 0x00000000ffffffffULL) + ((x >> 32) & 0x00000000ffffffffULL); 	return x; }   main(){ 	int i, j, t; 	int n, m; 	scanf ( "%d", &t ); 	while( t -- ){ 		scanf ( "%d", &n ); 		result = 0; 		for ( i = 0; i < n; i ++ ) 			scanf ( "%lld", a + i ); 		memset ( r, 0, sizeof ( r ) ); 		R[0] = make_pair( ( 1LL << 60 ) - 1, -1 ); 		for ( i = 0; i < n; i ++ ){ 			m = ( 1 << i ); 			for ( j = 0; j < m; j ++ ){ 				R[ m + j ].first = ( R[j].first & a[i] ); 				R[ m + j ].second = - R[j].second * 2; 				r[ func( R[ m + j ].first ) ] += - R[j].second; 			} 		} 		result = 0; 		for ( i = 0; i <= 60; i ++ ){ 			r[ i + 1 ] += r[i] / 2; 			r[i] %= 2; 			if ( r[i] == -1 ){ 				r[i] = 1; 				r[ i + 1 ] --; 			} 			if ( r[i] ) 			result |= 1LL << i; 		} 		printf( "%lld\n", result ); 	} 	 	return 0; }
#include <cstdio> #include <cmath> #include <cstring> #include <cstdlib> #include <ctime> #include <iostream> #include <fstream> #include <sstream> #include <algorithm> #include <string> #include <vector> #include <set> #include <map> #include <list> #include <complex> #pragma comment(linker, "/STACK:266777216") using namespace std;   #define assert(f) { if(!(f)) { fprintf(stderr,"Assertion failed: "); fprintf(stderr,#f); fprintf(stderr,"\n"); exit(1); } }   typedef long long LL; typedef unsigned long long ULL; typedef vector<int> VI; typedef vector<VI> VVI; typedef pair<int,int> PII; typedef vector<PII> VPII; typedef vector<double> VD; typedef pair<double,double> PDD;   const int inf=1000000000; const LL INF=LL(inf)*inf; const double eps=1e-9; const double PI=2*acos(0.0); #define bit(n) (1<<(n)) #define bit64(n) ((LL(1))<<(n)) #define pb push_back #define sz size() #define mp make_pair #define cl clear() #define all(a) (a).begin(),(a).end() #define fill(ar,val) memset((ar),(val),sizeof (ar)) #define MIN(a,b) {if((a)>(b)) (a)=(b);} #define MAX(a,b) {if((a)<(b)) (a)=(b);} #define sqr(x) ((x)*(x)) #define X first #define Y second   //clock_t start=clock(); //fprintf(stderr,"time=%.3lfsec\n",0.001*(clock()-start));   #define MOD 1000000007   #define N 101010 int cnt[N]; PII a[N];   int fct[N]; int inv[N]; int invfct[N];   int powmod(int a,int n) { int p=1; for(;n;) { if(n%2) p=LL(p)*a%MOD; if(n/=2) a=LL(a)*a%MOD; } return p; }   int main() { #ifndef ONLINE_JUDGE freopen("4.in","r",stdin); #endif int n,i; scanf("%d",&n); for(i=0;i<n;i++) { int x; scanf("%d",&x); cnt[x]++; } int len=0; for(i=1;i<N;i++) if(cnt[i]) a[len++]=mp(i,cnt[i]); fct[0]=fct[1]=1; inv[1]=1; invfct[0]=invfct[1]=1; for(i=2;i<N;i++) { fct[i]=LL(i)*fct[i-1]%MOD; inv[i]=LL(MOD-inv[MOD%i])*(MOD/i)%MOD; invfct[i]=LL(inv[i])*invfct[i-1]%MOD; } map<int,int> save; int q; for(scanf("%d",&q);q--;) { int s; scanf("%d",&s); s=min(s,100000); int ans=0; if(save.count(s)) ans=save[s]; else { int sum=0; int tot=1; int half=1; int odd=0; for(i=0;i<len;i++) { int cur=(a[i].X+s-1)/s; sum+=cur*a[i].Y; if(cur%2) odd+=a[i].Y; if(odd>1) half=0; else half=LL(half)*powmod(invfct[cur/2],a[i].Y)%MOD; tot=LL(tot)*powmod(invfct[cur],a[i].Y)%MOD; } tot=LL(tot)*fct[sum]%MOD; if(half) half=LL(half)*fct[sum/2]%MOD; ans=LL(tot+half)*inv[2]%MOD; save[s]=ans; } printf("%d\n",ans); } return 0; }
#include <cmath> #include <climits> #include <queue> #include <vector> #include <map> #include <cstdlib> #include <fstream> #include <iomanip>    #include <iostream>   #include <sstream>  // istringstream buffer(myString); #include <stack> #include <algorithm> #include <cstring> #include <cassert> #include <bits/stdc++.h> using namespace std; #define bit(x,i) (x&(1<<i))  //select the bit of position i of x #define lowbit(x) ((x)&((x)^((x)-1))) //get the lowest bit of x #define hBit(msb,n) asm("bsrl %1,%0" : "=r"(msb) : "r"(n)) //get the highest bit of x, maybe the fastest #define max(a,b) (a<b?b:a) #define abs(x) (x<0?(-x):x) // big bug here if "-x" is not surrounded by "()" #define IN(i,l,r) (l<i&&i<r) //the next for are for checking bound #define LINR(i,l,r) (l<=i&&i<=r) #define LIN(i,l,r) (l<=i&&i<r) #define INR(i,l,r) (l<i&&i<=r) #define F(i,L,R) for (int i = L; i < R; i++) //next four are for "for loops" #define FE(i,L,R) for (int i = L; i <= R; i++) #define FF(i,L,R) for (int i = L; i > R; i--) #define FFE(i,L,R) for (int i = L; i >= R; i--) #define getI(a) scanf("%d", &a) //next three are handy ways to get ints, it's also force you to use '&' sign #define getII(a,b) scanf("%d%d", &a, &b) #define getIII(a,b,c) scanf("%d%d%d", &a, &b, &c) #define wez(n) int (n); scanf("%d",&(n)); //handy if the input is right after the definition of a variable #define wez2(n,m) int (n),(m); scanf("%d %d",&(n),&(m)) #define wez3(n,m,k) int (n),(m),(k); scanf("%d %d %d",&(n),&(m),&(k)) #define TESTS wez(testow)while(testow--) //for multilple cases problems #define whileZ int T; getI(T); while(T--) // the same as above #define getS(x) scanf("%s", x) //get a char* string #define clr(a,x) memset(a,x,sizeof(a)) //set elements of array to some value #define char2Int(c) (c-'0') #define lastEle(vec) vec[vec.size()-1]  #define SZ(x) ((int)((x).size())) #define REMAX(a,b) (a)=max((a),(b)) // set a to the maximum of a and b #define REMIN(a,b) (a)=min((a),(b)); #define FOREACH(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++) // traverse an STL data structure #define ALL(c) (c).begin(),(c).end() //handy for function like "sort()" #define PRESENT(c,x) ((c).find(x) != (c).end())  #define CPRESENT(c,x) (find(ALL(c),x) != (c).end())  #define ll long long //data types used often, but you don't want to type them time by time #define ull unsigned long long #define ui unsigned int #define us unsigned short #define IOS ios_base::sync_with_stdio(0); //to synchronize the input of cin and scanf #define INF 1001001001 #define PI 3.1415926535897932384626 //for map, pair #define mp make_pair #define fi first #define se second // for debug inline void pisz(int n) { printf("%d\n",n); } #define DBG(vari) cerr<<#vari<<" = "<<(vari)<<endl; #define printA(a,L,R) FE(i,L,R) cout << a[i] << (i==R?'\n':' ') #define printV(a) printA(a,0,a.size()-1) #define MAXN 10000 //for vectors #define pb push_back typedef int elem_t; typedef vector<int> vi;  typedef vector<vi> vvi;  typedef pair<int,int> ii;  // directions const int fx[4][2] = {{0,1}, {0,-1}, {1,0}, {-1,0}}; const int fxx[8][2] = {{0,1}, {0,-1}, {1,0}, {-1,0}, {1,1}, {1,-1}, {-1,1}, {-1,-1}}; template<typename T,typename TT> ostream& operator<<(ostream &s,pair<T,TT> t) {return s<<"("<<t.first<<","<<t.second<<")";} template<typename T> ostream& operator<<(ostream &s,vector<T> t){F(i,0,SZ(t))s<<t[i]<<" ";return s; }   int main () { 	TESTS { 		vector<ii> v; 		int n,i,j,k; 		scanf("%d",&n); 		for (i=0 ; i < n ; i++) { 			int a,b; 			scanf("%d%d",&a,&b); 			v.pb(mp(a,b)); 		} 		sort(v.begin(),v.end()); 		//int ans=1; 		stack<ii> s; 		s.push(v[0]); 		for (i=1 ; i < n ; i++) { 			int l = v[i].first, r= v[i].second; 			ii x = s.top(); 			if (l > x.second) 				s.push(v[i]); 			else { 				s.pop(); 				int a = max(l,x.first); 				int b = min(r,x.second); 				s.push(mp(a,b)); 			} 		} 		printf("%d\n",s.size()); 	} 	return 0; }
//Coder: Balajiganapathi //#define TRACE #define DEBUG  #include <algorithm> #include <bitset> #include <deque> #include <cassert> #include <cctype> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <functional> #include <iomanip> #include <iostream> #include <list> #include <map> #include <numeric> #include <queue> #include <set> #include <sstream> #include <stack> #include <utility> #include <vector>  using namespace std;  typedef long long ll; typedef vector<int> vi; typedef pair<int,int> pi; typedef vector<string> vs;  // Basic macros #define st          first #define se          second #define all(x)      (x).begin(), (x).end() #define ini(a, v)   memset(a, v, sizeof(a)) #define re(i,s,n)  	for(int i=s;i<(n);++i) #define rep(i,s,n)  for(int i=s;i<=(n);++i) #define fr(i,n)     re(i,0,n) #define repv(i,f,t) for(int i = f; i >= t; --i) #define rev(i,f,t)  repv(i,f - 1,t) #define frv(i,n)    rev(i,n,0) #define pu          push_back #define mp          make_pair #define sz(x)       (int)(x.size())  const int oo = 2000000009; const double eps = 1e-9;  #ifdef TRACE     #define trace1(x)                cerr << #x << ": " << x << endl;     #define trace2(x, y)             cerr << #x << ": " << x << " | " << #y << ": " << y << endl;     #define trace3(x, y, z)          cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl;     #define trace4(a, b, c, d)       cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << endl;     #define trace5(a, b, c, d, e)    cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << endl;     #define trace6(a, b, c, d, e, f) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << " | " << #f << ": " << f << endl;  #else      #define trace1(x)     #define trace2(x, y)     #define trace3(x, y, z)     #define trace4(a, b, c, d)     #define trace5(a, b, c, d, e)     #define trace6(a, b, c, d, e, f)  #endif  const int mx = 202; struct Order {     public:     int s, x, d, p; } orders[mx], orders2[mx];  struct Range {     public:     int s, e;     Range(int _s, int _e) {         s = _s; e = _e;     } };  bool byP(Order o1, Order o2) {     return o1.p > o2.p; }  bool byD(Order o1, Order o2) {     return o1.d < o2.d; }  int n;  int main() {     int t;     scanf("%d", &t);     while(t--) {         scanf("%d", &n);         fr(i, n) scanf("%d %d %d %d", &orders[i].s, &orders[i].x, &orders[i].d, &orders[i].p);         fr(i, n) orders[i].d--;         sort(orders, orders + n, byP);         fr(i, n) orders2[i] = orders[i];          map<pi, int> scnt;          fr(i, n) {             scnt[mp(orders[i].s, 1)] += 1;             scnt[mp(orders[i].d, 0)] += 1;         }          int prev = 0, cur = 0;         vector<pi> v;         for(map<pi, int>::iterator it = scnt.begin(); it != scnt.end(); ++it) {             trace4(cur, it->st.st, it->st.se, it->se);              if(cur > 0) {                 if(it->st.se == 1) {                     cur += it->se;                     v.pu(mp(prev + 1, it->st.st - 1));                     prev = v.back().se;                 } else {                     cur -= it->se;                     v.pu(mp(prev + 1, it->st.st));                     prev = v.back().se;                 }             } else {                 prev = it->st.st - 1;                 cur += it->se;             }         }         fr(i, sz(v)) trace3(i, v[i].st, v[i].se);          ll ans = 0, cur_tot = 0, tot, diff;         fr(i, n) {             cur_tot += orders[i].x;             priority_queue<pi, vector<pi>, greater<pi> > q;             tot = 0;              fr(k, sz(v)) {                 int rem = v[k].se - v[k].st + 1;                 int lo = v[k].st;                  rep(l, 0, i) if(orders[l].s == v[k].st) q.push(mp(orders[l].d, orders[l].x));                  while(rem > 0 && !q.empty()) {                     pi p = q.top(); q.pop();                     if(p.st < lo) continue;                     trace6(i, k, lo, rem, p.st, p.se);                     assert(v[k].se - lo + 1 == rem);                     int x = min(p.se, v[k].se - lo + 1);                     lo += x;                     rem -= x;                     p.se -= x;                     tot += x;                     if(p.se > 0) q.push(p);                 }             }              diff = cur_tot - tot;             trace3(i, cur_tot, tot);             assert(diff <= orders[i].x);             orders[i].x -= diff;             cur_tot -= diff;             ans += diff * orders[i].p;          }         printf("%lld\n", ans);              }               	return 0; } 
#include<cstdio> #include<cstring> #include<cstdlib> #include<cmath> #include<iostream> #include<vector> #include<ctime> #include<string> #include<algorithm> #define rep(i,j,k) for (i=j;i<=k;i++) #define reps(i,j,k) for (i=j;i>=k;i--) #define pb push_back #define mp make_pair #define mem(a,b) memset(a,b,sizeof(a)) #define inf 0x7fffffff #define maxn 210000 #define fi first #define se second #define mod 1000000007 using namespace std; typedef long long LL; struct node { 	int lcol,rcol,lnum,rnum,ans,num; }tree[maxn*4]; int T,n,K,a[maxn],q; void update(int now) { 	tree[now].lcol=tree[now*2].lcol;tree[now].rcol=tree[now*2+1].rcol; 	tree[now].num=tree[now*2].num+tree[now*2+1].num; 	if (tree[now*2].lcol==tree[now*2].rcol&&tree[now*2].rcol==tree[now*2+1].lcol&&tree[now*2].num==tree[now*2].lnum) 	tree[now].lnum=tree[now*2].lnum+tree[now*2+1].lnum; 	else tree[now].lnum=tree[now*2].lnum; 	if (tree[now*2+1].lcol==tree[now*2+1].rcol&&tree[now*2+1].lcol==tree[now*2].rcol&&tree[now*2+1].num==tree[now*2+1].rnum) 	tree[now].rnum=tree[now*2+1].rnum+tree[now*2].rnum; 	else tree[now].rnum=tree[now*2+1].rnum; 	tree[now].ans=tree[now*2].ans+tree[now*2+1].ans; 	if (tree[now*2].rcol==tree[now*2+1].lcol&&tree[now*2].rnum+tree[now*2+1].lnum>=K&&K!=1) 	{ 		int ll=tree[now*2].rnum+1-K+1;if (ll<=0)ll=1; 		int rr=tree[now*2].rnum+tree[now*2+1].lnum-K+1;if(rr>tree[now*2].rnum)rr=tree[now*2].rnum; 		tree[now].ans+=(rr-ll+1); 	} } void bt(int now,int l,int r) { 	if (l==r) 	{ 		tree[now].lcol=tree[now].rcol=a[l]; 		tree[now].lnum=tree[now].rnum=1;tree[now].num=1; 		if (K==1)tree[now].ans=1;else tree[now].ans=0; 		return; 	} 	int mid=(l+r)/2; 	bt(now*2,l,mid); 	bt(now*2+1,mid+1,r); 	update(now); } void modify(int now,int l,int r,int pos,int val) { 	if (l==r) 	{ 		tree[now].lcol=tree[now].rcol=val; 		tree[now].lnum=tree[now].rnum=1; 		if (K==1)tree[now].ans=1;else tree[now].ans=0; 		return; 	} 	int mid=(l+r)/2; 	if (pos<=mid) modify(now*2,l,mid,pos,val); 	else modify(now*2+1,mid+1,r,pos,val); 	update(now); } int main() { 	int i,j,k; 	//freopen("in.txt","r",stdin);freopen("out.txt","w",stdout); 	scanf("%d",&T); 	while(T--) 	{ 		scanf("%d%d",&n,&K); 		rep(i,1,n)scanf("%d",&a[i]); 		bt(1,1,n); 		scanf("%d",&q); 		rep(i,1,q) 		{ 			int x,y; 			scanf("%d%d",&x,&y); 			modify(1,1,n,x,y); 			printf("%d\n",tree[1].ans); 		} 	} 	return 0; } 
#include<iostream> #include<vector> #include<algorithm>  using namespace std;  vector<pair<long long int,pair<long long int,long long int> > > amoodi; vector<pair<long long int,pair<long long int,long long int> > > ofoghi;  pair<long long int,long long int> sort(pair<long long int,long long int> a) {     return make_pair(min(a.first,a.second),max(a.first,a.second)); }  bool have_intersect(pair<long long int,long long int> a,pair<long long int,long long int> b) {     a = sort(a);     b = sort(b);          long long int x = max(a.first,b.first);     long long int y = min(a.second,b.second);          return x <= y; }     pair<long long int,long long int> get_union(pair<long long int,long long int> a,pair<long long int,long long int> b) {     a = sort(a);     b = sort(b);          long long int x = min(a.first,b.first);     long long int y = max(a.second,b.second);          return make_pair(x,y); }     pair<long long int,long long int> get_intersect(pair<long long int,long long int> a,pair<long long int,long long int> b) {     a = sort(a);     b = sort(b);          long long int x = max(a.first,b.first);     long long int y = min(a.second,b.second);          return make_pair(x,y); }      vector<pair<long long int,long long int> > do_union(vector<pair<long long int,long long int> > v) {     vector<pair<long long int,long long int> > res;     for (long long int i=0;i<v.size();i++)     {         bool found = false;         for (long long int j=i+1;j<v.size() && !found;j++)         {             if (have_intersect(v[i],v[j]))             {                 v[j] = get_union(v[i],v[j]);                 found = true;              }         }         if (!found)             res.push_back(v[i]);     }          return res; }  long long int get_length(vector<pair<long long int,long long int> > v) {     long long int res = 0;     for (long long int i=0;i<v.size();i++)         res += abs(v[i].second - v[i].first) + 1;      return res; }  void print(vector<pair<long long int,long long int> > v) {     for (int i=0;i<v.size();i++)         cout<<"( "<<v[i].first<<", "<<v[i].second<<" ) ,";     cout<<endl;     return; }  int main() {     vector<pair<long long int,long long int> > v;      amoodi.push_back(make_pair(0,make_pair(0,0)));     ofoghi.push_back(make_pair(0,make_pair(0,0)));     long long int x = 0,y = 0;     long long int nx,ny;     long long int n,d;     char c;     cin>>n;     for (long long int i=0;i<n;i++)     {         cin>>c>>d;          if (c == 'R' || c == 'L')         {             v.clear();             nx = x + (c == 'R' ? 1 : -1) * d;             ny = y;                         for (long long int j=0;j<ofoghi.size();j++)                 if (ofoghi[j].first == y && have_intersect(ofoghi[j].second,make_pair(x,nx)))                     v.push_back(get_intersect(make_pair(x,nx),ofoghi[j].second));             for (long long int j=0;j<amoodi.size();j++)                 if (have_intersect(amoodi[j].second,make_pair(y,y)) && have_intersect(make_pair(amoodi[j].first,amoodi[j].first),make_pair(x,nx)))                     v.push_back(make_pair(amoodi[j].first,amoodi[j].first));             v = do_union(v);                          cout<<abs(nx-x)+1-get_length(v)<<endl;             ofoghi.push_back(make_pair(y,make_pair(x,nx)));         }           else         {             v.clear();             nx = x;             ny = y + (c == 'U' ? 1 : -1) * d;                         for (long long int j=0;j<amoodi.size();j++)                 if (amoodi[j].first == x && have_intersect(make_pair(y,ny),amoodi[j].second))                     v.push_back(get_intersect(make_pair(y,ny),amoodi[j].second));             for (long long int j=0;j<ofoghi.size();j++)                 if (have_intersect(ofoghi[j].second,make_pair(x,x)) && have_intersect(make_pair(ofoghi[j].first,ofoghi[j].first),make_pair(y,ny)) )                     v.push_back(make_pair(ofoghi[j].first,ofoghi[j].first));             v = do_union(v);             cout<<abs(ny-y)+1-get_length(v)<<endl;             amoodi.push_back(make_pair(x,make_pair(y,ny)));         }          x = nx;         y = ny;      }     return 0; }
#include<bits/stdc++.h>  using namespace std;  const int MAXN = 100100;  int ans, n, m, k, i, x, y, z, v, to, cs; bool a[MAXN]; vector<pair<int, int> > g[MAXN]; int d[MAXN], vis[MAXN]; priority_queue< pair<int, int>, vector< pair<int, int> >, greater< pair<int, int> > >s;  int main()  {         scanf("%d%d%d", &n, &m, &k);     for (int i = 1; i <= k; i++)      {         scanf("%d", &x);         a[x] = 1;     }     for (int i = 1; i <= m; i++)      {         scanf("%d%d%d", &x, &y, &z);         g[x].push_back(make_pair(y, z));         g[y].push_back(make_pair(x, z));     }      ans = 111111115;     for (int i = 1; i <= n; i++)     {         if (!a[i])             continue;                  for (int j = 1; j <= n; j++)              d[j] = 111111111, vis[j] = 0;         d[i] = 0;         int cnt_special = 0;                  while(s.empty() == false)             s.pop();                      s.push(make_pair(0, i));          while (s.empty()!=true)         {             v = s.top().second;             s.pop();                          if(vis[v] == 1)                 continue;             vis[v] = 1;             cnt_special += a[v];              if(d[v] > ans)                 break;              if(a[v]!=false and cnt_special == 2)             {                 ans = min(ans, d[v]);                 break;             }                          for (int i = 0; i < g[v].size(); i++)             {                 to = g[v][i].first;                 cs = g[v][i].second;                 if (d[v] + cs < d[to])                 {                     d[to] = d[v] + cs;                     s.push(make_pair(d[to], to));                 }             }         }     }     printf("%d\n", ans);     return 0; }
#include<bits/stdc++.h> using namespace std;   int all_nine(string str) { 	for(int i=0;i<str.length();i++) 	{ 		if(str[i]!='9') 			return 0; 	} 	return 1; }   int main() {int t;  cin>>t;  while(t--){ 	string str; 	cin>>str; 	int i,j,num; 	char ans[str.length()+3]; 	int n=str.length(); 	if(all_nine(str)) 	{ 		ans[0]='1'; 		for(i=0;i<n;i++) 		{ 			ans[i+1]='0'; 		} 		ans[n]='1'; 		ans[n+1]='\0'; 		cout<<ans<<endl; 	} 	else 	{ 		i=n/2; 		j=i;   		if(n%2==0) 		i=i-1;   		while(i>=0 && str[i]==str[j]) 		{	 			i--; 			j++; 		}   		if(i<0 || str[i]<str[j]) 		{ 			i=n/2; 			j=i; 			if(n%2==0) 				i=i-1; 		int carry=1; 		while(i>=0) 		{ 			num=((str[i]-'0')+carry); 			carry=num/10; 			str[i]=(num%10)+'0'; 			str[j]=str[i]; 			i--; 			j++; 		} 		} 		else 		{ 			while(i>=0) 				{ 					str[j]=str[i]; 					i--; 					j++; 				} 		} 		cout<<str<<endl; 	}  } 	return 0; }
#include<cstdio> #include<cstring> #include<algorithm> #define N 1000001 #define LL long long using namespace std;  char s[N]; int tr[2*N+1], r[2*N+1], sm[2*N+1], mod[2*N+1][3];  int main() { 	scanf("%s", s); 	int n = strlen(s); 	 	for(int i=0;i<n;++i) 		tr[2*i] = 0, tr[2*i+1] = s[i]-'0'; 	tr[2*n] = 0;  	int ce = 0;  	for(int i=1;i<=2*n;++i) 	{ 		if( i<=ce+r[ce] ) 		{ 			int mr = ce+r[ce]-i; 			r[i] = min(mr, r[ce-r[ce]+mr]); 		} 		while(++r[i], 0<=i-r[i] && i+r[i]<=2*n && tr[i+r[i]]==tr[i-r[i]]); 		--r[i]; 		if(i+r[i] > ce+r[ce]) ce = i; 	} 	 	for(int i=1;i<=2*n;++i) 	{ 		sm[i] += sm[i-1]+tr[i]; 		sm[i] %=3; 		if(tr[i]) ++mod[i][sm[i]]; 		for(int j=0;j<3;++j) 			mod[i][j] += mod[i-1][j]; 	}  	LL ans = 0;  	for(int i=1;i<=2*n;++i) 	{ 		if(i%2) ans += tr[i]%3 == 0; 		int nd = (sm[i]+ (2*(3-tr[i]%3))%3)%3; 		ans += mod[i+r[i]][nd]-mod[i][nd]; 	} 	printf("%lld\n", ans); 	return 0; } 
#include<iostream> #include<cstring> #include<numeric> #include<cassert> using namespace std;  struct Node { 	Node * child[2], * parent; 	int value, size, c[10]; 	bool reverse;  	Node() { 		size = 0; 		reverse = false; 		memset(c, 0, sizeof c); 	} };  Node * root, * nil;  void initTree() { 	root = nil = new Node(); 	nil->child[0] = nil->child[1] = nil->parent = nil; }  void update(Node * x) { 	if(x == nil) return; 	x->size = x->child[0]->size + x->child[1]->size + 1; 	for(int i = 0; i < 10; ++i) 		x->c[i] = x->child[0]->c[i] + x->child[1]->c[i]; 	++x->c[x->value]; }  void pushDown(Node * x) { 	if(x == nil) return; 	if(x->reverse) { 		swap(x->child[0], x->child[1]); 		x->reverse ^= true; 		x->child[0]->reverse ^= true; 		x->child[1]->reverse ^= true; 	} }  void setLink(Node * x, Node * y, int d) { 	x->child[d] = y; 	y->parent = x; }  int getDir(Node * x, Node * y) { 	return x->child[0] == y ? 0 : 1; }  void rotate(Node * x, int d) { 	Node * y = x->child[d], * z = x->parent; 	setLink(x, y->child[d ^ 1], d); 	setLink(y, x, d ^ 1); 	setLink(z, y, getDir(z, x)); 	update(x); update(y); }  void splay(Node * x) { 	while(x->parent != nil) { 		Node * y = x->parent; 		Node * z = y->parent; 		int dy = getDir(y, x), dz = getDir(z, y); 		if(z == nil) rotate(y, dy); 		else if(dy == dz) rotate(z, dz), rotate(y, dy); 		else rotate(y, dy), rotate(z, dz); 	} }  Node * nodeAt(Node * x, int pos) { 	while(pushDown(x), x->child[0]->size != pos) { 		if(pos < x->child[0]->size) x = x->child[0]; 		else pos -= x->child[0]->size + 1, x = x->child[1]; 	} 	return splay(x), x; }  Node * join(Node * x, Node * y) { 	if(x == nil) return y; 	x = nodeAt(x, x->size - 1); 	setLink(x, y, 1); 	return update(x), x; }  void split(Node * x, int left, Node * &t1, Node * &t2) { 	if(left == 0) t1 = nil, t2 = x; 	else { 		t1 = nodeAt(x, left - 1); 		t2 = t1->child[1]; 		t1->child[1] = t2->parent = nil; 		update(t1); 	} }  const int N = 1e5, MOD = 1e9 + 7; int n, q, factorial[N + 1], invertFactorial[N + 1]; string s;  void enter() { 	cin >> n >> q >> s; }  Node * buildTree(int l, int r) { 	if(l == r) return nil; 	int mid = (l + r) >> 1; 	Node * res = new Node(); 	res->value = s[mid] - 'a'; 	res->parent = nil; 	setLink(res, buildTree(l, mid), 0); 	setLink(res, buildTree(mid + 1, r), 1); 	return update(res), res; }  int calcResult(const int c[10]) { 	int countOdd = 0; 	for(int i = 0; i < 10; ++i) countOdd += c[i] & 1; 	if(countOdd > 1) return 0; 	int res = factorial[accumulate(c, c + 10, 0) >> 1]; 	for(int i = 0; i < 10; ++i) 		res = 1LL * res * invertFactorial[c[i] >> 1] % MOD; 	return res; }  void solve() { 	for(int i = 0; i < q; ++i) { 		int type, l, r; cin >> type >> l >> r; --l; 		Node * t1, * t2, * t3; 		split(root, r, t1, t3); 		split(t1, l, t1, t2); 		if(type == 1) t2->reverse ^= true; 		else cout << calcResult(t2->c) << '\n'; 		root = join(join(t1, t2), t3); 		assert(root->size == n); 	} }  int power(int a, int n) { 	int res = 1; 	for(; n > 0; n >>= 1) { 		if((n & 1) != 0) res = 1LL * res * a % MOD; 		a = 1LL * a * a % MOD; 	} 	return res; }  void init() { 	factorial[0] = 1; 	for(int i = 1; i <= n; ++i) 		factorial[i] = 1LL * factorial[i - 1] * i % MOD; 	for(int i = 0; i < n; ++i) 		invertFactorial[i] = power(factorial[i], MOD - 2); }  int main() { 	ios::sync_with_stdio(false); 	enter(); 	init(); 	initTree(); 	root = buildTree(0, n); 	solve(); 	return 0; } 
#include<bits/stdc++.h> #define bug(x) cerr << #x << " = " << x << endl; using namespace std;  typedef long long ll; typedef pair<int,int> pii;  const int MAX = 100005; const int oo = 1 << 29;  char s[MAX]; int p[MAX]; int n; pii pos[MAX]; ll tree[MAX];  void update(int a) { 	for( ;a <= n; a += a & -a) 		tree[a] ++; }  ll read(int a) { 	ll ret = 0; 	for( ;a > 0; a -= a & -a) 		ret += tree[a]; 	return ret; }  void manacher(int * ans, int r) { 	for (int i = 0, j = 0, k; i < n; i += k, j = max(j - k, 0)) 	{ 		while (i - j >= 0 && i + j + r < n && s[i - j] == s[i + j + r]) 			j++; 		ans[i] = j; 		for (k = 1; k < j && ans[i - k] != j - k; k++) 			ans[i + k] = min(ans[i - k], j - k); 	} }  ll solve() { 	n = strlen(s);  	memset(tree, 0, (n + 1) * sizeof(ll) ); 	memset(p, 0, (n + 1) * sizeof (int));  	manacher(p, 1);  	for( int i = 0; i < n; ++ i) 		pos[i] = pii(2 * i - p[i], i);  	sort(pos, pos + n);  	ll ret = 0; 	for( int i = 0, j = 0; i < n; ++ i) 	{ 		while( j < n && pos[j].first <= 2 * i) 		{ 			update(pos[j].second + 1); 			++ j; 		} 		ret += read(i + p[i] + 1) - read(i + 1); 	}  	return ret; } int main() { 	int runs; 	scanf("%d", &runs);  	while (runs--) 	{ 		scanf("%s", s); 		printf("%lld\n", solve()); 	}  	return 0; }  
#include <stdio.h> #include <vector> using namespace std;  int n;  typedef struct { 	int a; int b; int c; } oper;  vector<vector<oper> > comp;  void solve(int k) { 	vector<oper> par; 	for (int i=k;i+k<=n;i+=2*k) { 		par.push_back((oper){i,i+k,i+k}); 	} 	comp.push_back(par); 	if (4*k<=n) solve(2*k); 	if (3*k<=n) { 		par.clear(); 		for (int i=3*k;i<=n;i+=2*k) { 			par.push_back((oper){i-k,i,i}); 		} 		comp.push_back(par); 	} }  int main() { 	scanf("%d",&n);     solve(1);     printf("%d\n",comp.size());     int total=0;     for (int i=0;i<comp.size();i++) {     	printf("%d",comp[i].size());     	for (int j=0;j<comp[i].size();j++) {     		printf(" %d+%d=%d",comp[i][j].a,comp[i][j].b,comp[i][j].c);     	}     	total+=comp[i].size();     	printf("\n");     }     return 0; }
#include <bits/stdc++.h>   using namespace std;   typedef long long ll; typedef pair<ll,ll> pll; typedef map<ll,ll> mll; typedef vector<ll,ll> vll; typedef set<ll> sll; typedef stack<ll> stll; typedef stack< pair<ll,ll> > stpll; typedef map<ll,pair<ll,ll> > mllpll; typedef vector< pair<ll,ll> > vpll; #define mk make_pair  #define pb push_back #define X first  #define Y second  #define tr(c,it) for(typeof((c).begin()) it = (c).begin(); it != (c).end(); it++) #define rep(x,n)   for((x)=0;(x)<(n);(x)++) #define mod 1000000007 const double eps=1e-15; const double Max=1e+18;   inline void normal(ll& a) {     a %= mod;     (a < 0) && (a += mod); }   inline ll mul(ll a, ll b) {     a %= mod, b %= mod;     normal(a), normal(b);     return (a * b) % mod; }   inline ll add(ll a, ll b) {     a %= mod, b %= mod;     normal(a), normal(b);     return (a + b) % mod; }   inline ll sub(ll a, ll b) {     a %= mod, b %= mod;     normal(a), normal(b);     a -= b;     normal(a);     return a; }     int parent[100010],xval[100010]; int rnk[100010],cnt=0;   pair<int,int> find(int x) { 	// cout<<x<<" "<<"--x "<<" "<<xval[x]<<endl; 	if(parent[x] == x) return mk(x,0); 	pair<int,int> p=find(parent[x]); 	xval[x]=(xval[x]+p.Y)%2; 	parent[x]=p.X; 	// cout<<x<<" -- "<<xval[x]<<" "<<parent[x]<<endl; 	return mk(parent[x],xval[x]); }   bool merge(int a, int b, int c) {     pair<int,int> p1 = find(a), p2 = find(b);     // cout<<a<<" "<<b<<" "<<p1.X<<" "<<p2.X<<" "<<p1.Y<<" "<<p2.Y<<endl;     if(p1.X == p2.X)         {     	if((p1.Y+p2.Y)%2 == c) return true;     	else return false;     }     cnt++;     if(rnk[p2.X] > rnk[p1.X])   swap(p1.X,p2.X);     parent[p2.X] = p1.X;     xval[p2.X] = (xval[a]+xval[b]+c)%2;     if(rnk[p1.X] == rnk[p2.X])    rnk[p1.X]++;     return true; }   void init() { 	cnt=0; 	memset(rnk,0,sizeof(rnk)); 	memset(xval,0,sizeof(xval)); 	for(int i=0;i<100010;i++) parent[i]=i;   }   ll Pow(ll a,ll b,ll n) { 	ll res=1; 	while (b) 	{ 	    if (b % 2) { res = (res * a) % n; }   	    a = (a * a) % n; 	    b /= 2; 	}   	return res; }   int main() { 	ios::sync_with_stdio(false);     // freopen("input.txt","r",stdin);     // freopen("output.txt","w",stdout); 	int t; 	cin>>t; 	while(t--) 	{ 		init(); 		int q,n; 		cin>>n>>q; 		int i,x,y,z; 		for(i=1;i<n;i++) 		{ 			cin>>x>>y; 		} 		bool flag=true; 		for(i=0;i<q;i++) 		{ 			cin>>x>>y>>z; 			flag = flag&merge(x,y,z); 		} 		if(!flag) cout<<0<<endl; 		else 		{ 			ll ans=Pow(2,n-1-cnt,mod); 			cout<<ans<<endl; 		} 	}   	return 0; } 
#include<cstdio> #include<cstdlib> #include<cstring> #include<iostream> #include<iomanip> #include<utility> #include<map> #include<cmath> #include<vector> #include<queue> #include<string> #include<algorithm> #include<fstream>   using namespace std;   #define mod 1000000007   double val=0.0; long long int  coeff[20]; int D; long long int B[1000]; long long int C[1000]; long long int Matrix[1000]; long long int A[1000]; long long int Z[1000];   long long int power(long long int r,long long int p) {         long long int toret=1;         while(p>0)         {                 if(p%2 != 0)                 {                   toret = (toret*r)%mod;                 }                 r = (r*r)%mod;                 p =p/2;         }         return toret; }   long long int calc(int r) {         long long int ans = 0;         for(int i=0;i<=D;i++)         {                 ans = (ans+(coeff[i]*power(r,i))%mod)%mod;         }         return ans; }   long long int  polpar(int N,int M ,long long int X,long long int  Matrix[1000]) {           for(int i=0;i<=N;i++)         {                         C[i] = Matrix[i];                         B[i]=0;                         A[i] = 0;         }         A[0]=1;                                                       while(M > 0 )         {                 if(M % 2 != 0)                 {                                 for(int j=0;j<=N;j++)                                 {                                         for(int k=j,l=0;k>=0;k--,l++)                                         {                                                 B[j]=(B[j]+ (A[l]*C[k])%mod)%mod;                                                                                          }                                      //    printf("B[%d]=%d\n",j,B[j]);                                 }                         for(int i=0;i<=N;i++)                         {                                 A[i]=B[i];                                 B[i]=0;                         }                 }                                 for(int j=0;j<=N;j++)                                 {                                         for(int k=j,l=0;k>=0;k--,l++)                                         {                                                 B[j]=(B[j]+ (C[l]*C[k])%mod)%mod;                                          }                                       //  printf("B[%d]=%d\n",j,B[j]);                                 }                         for(int i=0;i<=N;i++)                         {                                 C[i]=B[i];                                 B[i]=0;                         }                 M/=2;         }         long long int toret = 0;         for(int i=0;i<=N;i++)         {                // cout<<i<<" "<<A[i]<<" "<<Z[i]<<endl;                 toret = (toret + (A[i]*Z[i])%mod)%mod;         }           return toret; }  int main() {         int t;         long long int N,M;         long long int X;         cin >>  t;         while(t--)         {                 val = 0.0;                 scanf("%lld%lld%lld%d",&M,&N,&X,&D);                 for(int i=0;i<=D;i++)                         scanf("%lld",&coeff[i]);                 for(int i=0;i<=N; i++)                 {                         long long int topass = (i*X)%mod;                         Matrix[i] = calc(topass);                         Z[N-i] = Matrix[i];                 }                                                    long long int mainans = polpar(N,M-1,X,Matrix);                 printf("%lld\n",mainans);                 memset(Matrix,0,sizeof(Matrix));         }         return 0; }   
#include<bits/stdc++.h> using namespace std;   #define sd(mark) scanf("%d",&mark) #define slld(mark) scanf("%lld",&mark) #define clr(mark) memset(mark,0,sizeof(mark)) #define F first #define S second #define MP make_pair #define PB push_back #define pii pair<int,int> #define ll long long vector<int> v[1000]; int len[1000]; char s[100010],t[100010]; char temp[100010]; int lps[100010];  void computeLPSArray(char *pat, int M, int *lps); void KMPSearch(char *pat, char *txt,int pos,int M) {     int N = strlen(txt);       int j  = 0;  // index for pat[]       computeLPSArray(pat, M, lps);       int i = 0;  // index for txt[]     while (i < N)     {       if (pat[j] == txt[i])       {         j++;         i++;       }         if (j == M)       {         v[pos].PB(i-j);         j = lps[j-1];       }         else if (i < N && pat[j] != txt[i])       {         if (j != 0)          j = lps[j-1];         else          i = i+1;       }     } }   void computeLPSArray(char *pat, int M, int *lps) {     int len = 0;     int i;       lps[0] = 0;      i = 1;            while (i < M)     {        if (pat[i] == pat[len])        {          len++;          lps[i] = len;          i++;        }        else        {          if (len != 0)          {            len = lps[len-1];             }          else          {            lps[i] = 0;            i++;          }        }     } } int main() { 	int tn,ls,lt,i,j; 	sd(tn); 	while(tn--) 	{ 		int cnt=0; 		for(i=0;i<1000;++i) 			v[i].clear(); 		scanf("%s",&s); 		scanf("%s",&t); 		ls=strlen(s); 		lt=strlen(t); 		int c=0; 		for(i=0;i<ls;++i) 		{ 			if(s[i]=='*') 			{ 				if(c) 				{ 					temp[c]='\0'; 					len[cnt]=c; 					KMPSearch(temp,t,cnt,c); 					cnt++; 				} 				c=0; 			} 			else 				temp[c++]=s[i]; 		} 		if(c) 		{ 			temp[c]='\0'; 			len[cnt]=c; 			KMPSearch(temp,t,cnt,c); 			cnt++; 		} 		c=0; 		//cout<<cnt<<'\n'; 		if(cnt==0) 		{ 			for(i=0;i<lt;++i) 				printf("%d ",i+1); 			printf("\n"); 			continue; 		} 		for(i=0;i<lt;++i) 		{ 			int st=i; 			bool f=0; 			for(j=0;j<cnt;++j) 			{ 				int val=lower_bound(v[j].begin(),v[j].end(),st)-v[j].begin(); 				if(val==v[j].size()) 				{ 					f=1; 					break; 				} 				st=v[j][val]+len[j]; 			} 			if(f) 				st=-1; 			printf("%d ",st); 		} 		printf("\n"); 	} }
#include<stdio.h> #include<stdlib.h> #include<math.h> #include<assert.h> #define REP(i,a,b) for(i=a;i<b;i++) #define rep(i,n) REP(i,0,n)   #define ll long long #define INF 1000000001 int dp[2][11][100][100][100]; /* digits, sum, now_sum, now_prod */ int dpsum[11];   int solve(int fg, int dig, int sum, int now_sum, int prod){   int i, res=0;     if(now_sum > sum) return 0;      if(dp[fg][dig][sum][now_sum][prod]>=0) return dp[fg][dig][sum][now_sum][prod];   if(dig*9 + now_sum < sum) return dp[fg][dig][sum][now_sum][prod] = 0;   if(dig==0){     if(sum == now_sum && prod == 0) res++;     return dp[fg][dig][sum][now_sum][prod] = res;   }     REP(i,fg,10){     res += solve(0, dig-1, sum, now_sum+i, (prod*i)%sum);     if(res >= INF){ res = INF; break; }   }     return dp[fg][dig][sum][now_sum][prod] = res; }   int main(){   int i,j,k,l,N;   int sum, d, all;   ll prod;   char res[100];     rep(d,2) rep(i,11) rep(j,100) rep(k,100) rep(l,100) dp[d][i][j][k][l] = -1;     rep(i,11){     dpsum[i] = 0;     REP(k,1,100){       dpsum[i] += solve(1, i, k, 0, 1%k);       if(dpsum[i] >= INF){ dpsum[i] = INF; break; }     }   }     for(;;){     assert( scanf("%d",&N) == 1 );     if(!N)break;     assert( 1 <= N && N <= 1000000000 );     N--;       d = 0;     for(;;){       d++;       all = dpsum[d];       if(all <= N) N -= all; else break;     }       sum = 0; prod = 1;     rep(i,d){       rep(j,10){         if(i==0 && j==0) continue;         all = 0;         REP(k,1,100){           all += solve(0, d-i-1, k, sum+j, (prod*j)%k);           if(all >= INF){ all = INF; break; }         }         if(N >= all){ N -= all; continue; }         res[i] = '0'+j;         sum += j, prod *= j;         break;       }     }     res[d] = '\0';     puts(res);   }     return 0; }
#include <iostream> #include <string.h> #include <vector> using namespace std;   typedef long long LL; typedef vector<int> VI;   VI conv(int base,const string &a) { VI num(base,0); int L=a.length(); for(int i=0;i<L;i++) num[a[i]-'0']++; return num; }   int build(const VI &num,VI &p) { int base=num.size(); p.resize(base); int res=1; for(int d=0;d<base;d++) { p[d]=res; res*=num[d]+1; } return res; }   const int maxN = 2 * 1296 * 1296;   int tst_cnt=0; int bfs[maxN]; char vis[maxN]; LL dp[maxN];   LL solve(int base,string a,string b,string c) { if(a.length()<b.length()) swap(a,b); int La=a.length(); VI numa=conv(base,a),pa; int tota=build(numa,pa);   int Lb=b.length(); VI numb=conv(base,b),pb; int totb=build(numb,pb);   int L=c.length(); if(L<La) { c=string(La-L,'0')+c; L=La; } if(L>La+1) return 0;   int V=2*tota*totb; int end=V-2; int beg=0; if(L==La+1) { if(c[0]!='1') return 0; beg=1; c=c.substr(1); L--; }   int len=0; tst_cnt++; bfs[len++]=end; vis[end]=tst_cnt; dp[end]=1; for(int k=0;k<len;k++) { int v=bfs[k]; if(v==beg) break; int maska=v/2/totb; int maskb=v/2%totb; int d,i=0; for(d=0;d<base;d++) i+=maska/pa[d]%(numa[d]+1); d=v%2; if(i==0) continue; int x,y,D; int tmp=c[i-1]-'0'-d; for(x=0;x<base;x++) if(maska/pa[x]%(numa[x]+1)>0) { y=(tmp+base-x)%base; D=(x+y-tmp)/base;   int maskby=maskb; if(L-i>=Lb) { if(y || maskb) continue; } else { if(maskb/pb[y]%(numb[y]+1)>0) maskby-=pb[y]; else continue; }   int u=2*(totb*(maska-pa[x])+maskby)+D; if(vis[u]<tst_cnt) { bfs[len++]=u; dp[u]=0; vis[u]=tst_cnt; } dp[u]+=dp[v]; } } if(vis[beg]<tst_cnt) return 0; return dp[beg]; }   int main() { int TST; cin >> TST; for(int tst=0;tst<TST;tst++) { int base; string a,b,c; cin >> base >> a >> b >> c; LL res=solve(base,a,b,c); cout << res << endl; } return 0; }
#include <iostream> #include <string.h> #include <vector> using namespace std;  const int MAXN = 100000, MOD = 1000000007;  int t[MAXN + 10];  void add(int v, int d) { 	for (; v <= MAXN; v += (v & (-v))) 		t[v] += d; }  int sum(int r) { 	int ans = 0; 	for (; r > 0; r -= (r & (-r))) 		ans += t[r]; 	return ans; }  int sum(int l, int r) { 	return sum(r) - sum(l - 1); }  int index(vector <int> p, int mod) { 	int n = p.size(); 	memset(t, 0, sizeof t); 	for (int i = 1; i <= n; ++i) 		add(i, 1); 	int fact[MAXN + 10]; 	fact[0] = 1 % mod; 	for (int i = 1; i <= n; ++i) 		fact[i] = fact[i - 1]*1ll*i % mod; 	int ans = 0; 	for (int i = 0; i < n; ++i) 	{ 		int id = sum(p[i] - 1); 		ans = (ans + id*1ll*fact[n - 1 - i]) % mod; 		add(p[i], -1); 	} 	return ans; }  int parity(vector <int> p) { 	int n = p.size(); 	memset(t, 0, sizeof t); 	int ans = 0; 	for (int i = n - 1; i >= 0; --i) 	{ 		int smaller = sum(p[i] - 1); 		ans = (ans + smaller) % 2; 		add(p[i], 1); 	} 	return ans; }  int main() { 	cin.sync_with_stdio(false); 	int CASE; 	cin >> CASE; 	while (CASE--) 	{ 		int n, k; 		vector <int> p, q; 		cin >> n >> k; 		p.resize(n); 		q.resize(n); 		for (int i = 0; i < n; ++i) 			cin >> p[i]; 		for (int i = 0; i < n; ++i) 			cin >> q[i]; 		if (k == n) 		{ 			int start = -1; 			for (int i = 0; i < n; ++i) 			{ 				if (q[i] == p[0]) 				{ 					start = i; 					break; 				} 			} 			bool good = true; 			for (int i = 0; i < n; ++i) 			{ 				if (p[i] != q[(i + start) % n]) 				{ 					good = false; 					break; 				} 			} 			if (good) 				cout << q[0] << endl; 			else 				cout << -1 << endl; 		} 		else if (k % 2 == 0) 		{ 			int id = index(q, MOD); 			cout << (id + 1) % MOD << endl; 		} 		else 		{ 			if (parity(p) == parity(q)) 			{ 				int id = index(q, MOD); 				if (index(q, 2) == 1) 					id = (id + MOD - 1) % MOD; 				id = id*500000004ll % MOD; 				cout << (id + 1) % MOD << endl; 			} 			else 			{ 				cout << -1 << endl; 			} 		} 	} 	return 0; }
#include<stdio.h>  int x,t,n,a[1001][3],ans[1001],prev[1001],b[1001][3],tmp,max1,prv,final_max1,final_node,cnt,tm,ind1,ind2,ind; bool sign;  inline void merge(int lo,int hi) { ind1=lo; ind2=1+(lo+hi)/2; ind=lo; while(ind1<=(lo+hi)/2 && ind2<=hi) { if(a[ind1][0]<=a[ind2][0]) {b[ind][0]=a[ind1][0];b[ind][1]=a[ind1][1];b[ind][2]=a[ind1][2];ind++;ind1++;} else {b[ind][0]=a[ind2][0];b[ind][1]=a[ind2][1];b[ind][2]=a[ind2][2];ind++;ind2++;} } while(ind1<=(lo+hi)/2) { b[ind][0]=a[ind1][0];b[ind][1]=a[ind1][1];b[ind][2]=a[ind1][2];ind++;ind1++; } while(ind2<=hi) { b[ind][0]=a[ind2][0];b[ind][1]=a[ind2][1];b[ind][2]=a[ind2][2];ind++;ind2++; } for(int i=lo;i<=hi;i++) { a[i][0]=b[i][0]; a[i][1]=b[i][1]; a[i][2]=b[i][2]; } }  void m_sort(int lo,int hi) { if(lo==hi) return; m_sort(lo,(lo+hi)/2); m_sort(1+(lo+hi)/2,hi); merge(lo,hi); }  inline void inp(int &u) { /*u=0; sign=false; x=getchar_unlocked(); if(x=='-') {sign=true;x=getchar_unlocked();} while(x>='0' && x<='9') { u=(u<<3)+(u<<1)+(x-'0'); x=getchar_unlocked(); } if(sign) u*=(-1);*/ scanf("%d",&u); }  inline int abs(int ab) { if(ab<0) return ab*(-1); return ab; }  inline int mst(int i,int j) { return (abs(a[i][2]-a[j][2])+abs(a[i][1]-a[j][1])); }  int main() { inp(t); for(int i=0;i<t;i++) { inp(n); a[0][0]=0; a[0][1]=0; a[0][2]=0; for(int i=1;i<=n;i++) { inp(a[i][1]); inp(a[i][2]); inp(a[i][0]); } m_sort(1,n); ans[0]=0; prev[0]=-1; final_max1=-1; final_node=0; for(int i=1;i<=n;i++) { max1=-1; prv=-1; for(int j=0;j<i;j++) { if(a[j][0]+mst(i,j)>a[i][0] || ans[j]==-1) continue; tmp=1+ans[j]; if(tmp>max1) {max1=tmp;prv=j;} } ans[i]=max1; prev[i]=prv; if(final_max1<ans[i]) {final_max1=ans[i];final_node=i;} else if(final_max1==ans[i] && a[i][0]<a[final_node][0]) {final_max1=ans[i];final_node=i;} } tmp=final_node; cnt=0; while(1) { if(tmp==0) break; cnt++; tmp=prev[tmp]; } if(cnt==0) printf("No Photos\n"); else printf("%d %d\n",cnt,a[final_node][0]); } return 0; }
    #include <stdio.h>     #include <math.h>     #include <string>     #include <vector>     #include <algorithm>     #include <string.h>           #define PB push_back     #define LL long long     #define SZ(x) int(x.size())     #define ALL(x) x.begin(),x.end()     #define FOR(a,b) for(int a=0;a<b;a++)     #define CLR(a,b) memset(a,b,sizeof(a))           using namespace std;           #define infile "a.in"     #define outfile "a.out"           #define maxn 11     #define maxlen 11000     #define P 7774777           typedef LL h_type;           int n;     char s[maxn][maxlen];     h_type h[maxn][maxlen];     h_type ppow[maxlen];     int len[maxn];           inline h_type calc(int i, int j1, int j2)     {     if (j1 == 0)     return h[i][j2];     return h[i][j2] - h[i][j1-1] * ppow[j2-j1+1];     }           bool check(int q)     {     vector<h_type> v;           for (int i = 0; i < n; i++)     {     vector<pair<h_type, int> > u;     for (int j = 0; j + q <= len[i]; j++)     u.PB(make_pair(calc(i, j, j+q-1), j));     sort(u.begin(), u.end());     int k = u.size();     for (int j = 0; j < k; j++)     {     int l = j;     while (l+1 < k && u[l].first == u[l+1].first) l++;     if (u[j].second + q <= u[l].second)     v.PB(u[j].first);     j = l;     }     }           sort(v.begin(), v.end());     int vs = v.size();     int cnt = 0;     for (int i = 0; i < vs; i++)     {     if (i > 0 && v[i] == v[i-1])     cnt++;     else     cnt = 1;     if (cnt == n)     return true;     }     return false;     }           void solvecase()     {     scanf("%d", &n);     for (int i = 0; i < n; i++)     {     scanf("%s", s[i]);     len[i] = strlen(s[i]);     }           for (int i = 0; i < n; i++)     {     h_type t = 0;     for (int j = 0; j < len[i]; j++)     {     t = t * P + s[i][j];     h[i][j] = t;     }     }     ppow[0] = 1;     for (int i = 1; i < maxlen; i++)     ppow[i] = ppow[i-1] * P;           int r = len[0] / 2;     for (int i = 1; i < n; i++)     r = min(r, len[i] / 2);     r++;     int l = 0;           while (l+1 < r)     {     int m = (l+r)/2;     if (check(m))     l = m;     else     r = m;     }           printf("%d\n", l);     }           void solve() {     int t;     scanf("%d", &t);     for (int i = 0; i < t; i++) solvecase();     }           int main() {     //freopen(infile, "rt", stdin);     //freopen(outfile, "wt", stdout);     solve();     return 0;     } 
#include<stdio.h> int arr[10005],brr[10005]; void merge(int b[],int start,int mid ,int end) {     int lctr=start,rctr=mid,k=0;     for(k=start;lctr<mid&&rctr<end;k++)     {         if(b[lctr]<b[rctr])         {             brr[k]=b[lctr];             lctr++;         }          else         {             brr[k]=b[rctr];             rctr++;         }     }     while(lctr<mid)     {         brr[k]=b[lctr];         lctr++;         k++;     }      while(rctr<end)     {         brr[k]=b[rctr];         rctr++;         k++;     }      for(int i=start;i<end;i++)     {         b[i]=brr[i];     } } void mergesort(int ar[],int start, int end) {     int size=end-start;      if(size==1)     return;      int mid=size/2;      //printf("Sizesssss %d %d %d\n",start,mid,end);     //getchar();     mergesort(ar,start,start+mid);     mergesort(ar,start+mid,end);     merge(ar,start,start+mid,end); } int main() {     int t,n,i,j,k,f;      scanf("%d",&t);      while(t--)     {         scanf("%d %d",&n,&f);          for(int i=0;i<n;i++)         {             scanf("%d",&arr[i]);         }          for(int i=0;i<n;i++)         {             while(arr[i]%f==0)             {                 arr[i]=arr[i]/f;             }         }          mergesort(arr,0,n);          int ctr=0,temp=1;         for(int i=1;i<n;i++)         {             if(arr[i]!=arr[i-1])             {                 ctr=ctr+(temp*(temp-1))/2;                 temp=1;             }              else             temp++;              if(i==n-1)             {                 ctr=ctr+(temp*(temp-1))/2;                 temp=1;             }         }          printf("%d\n",ctr);     }     return 0; } 
 /* C++ template */  #include <iostream> #include <cstdlib> #include <cstdio> #include <cmath> #include <vector> #include <map> #include <stack> #include <queue> #include <cstring> #include <string> #include <algorithm>  using namespace std;  #define FOR(a,b,c) for(int a=(int)(b);a<=(int)(c);a++) #define ll long long #define ull unsigned long long  #define MAX(a,b) ((a>b)?(a):(b)) #define MIN(a,b) ((a>b)?(b):(a)) #define SWAP(a,b) {int t=a;a=b;b=t;} #define sz(x) (sizeof(x))  /* Main code starts here */  ll n,q,pos[550],dir[550],T,p,c,ans,collisionTime,rem[550];  int input() { 	cin>>n; 	FOR(i,0,n-1) cin>>pos[i]; 	FOR(i,0,n-1) cin>>dir[i]; 	cin>>q; 	return 0; }  int input2() { 	cin>>p>>T; 	return 0; }  int solve() { 	ll i; 	memset(rem,0,sz(rem)); 	c=0; 	 	while(1) 	{ 		collisionTime=T+1; 		for(i=p; i>=0 && i<n; i+=(dir[p]?+1:-1)) 		{ 			if(rem[i]) continue; 			rem[i]=1; 			if(dir[p]==dir[i]) continue; 			collisionTime=(abs(pos[i]-pos[p])-1)/2+1; 			break; 		} 		if(collisionTime>T) break; 		c++; 		p=i; 	} 	 	ans=pos[p] + (dir[p]?+1:-1)*T; 	 	return 0; }  int main() { 	int test; 	cin>>test; 	while(test--) 	{ 		input(); 		while(q--) 		{ 			input2(); 			solve(); 			cout<<ans<<" "<<c<<endl; 		} 	} 	return 0; }  
// C++ program to count minimum number of steps // required to measure d litres water using jugs // of m litres and n litres capacity. #include <bits/stdc++.h> using namespace std;   // Utility function to return GCD of 'a' // and 'b'. int gcd(int a, int b) {     if (b==0)        return a;     return gcd(b, a%b); }   /* fromCap -- Capacity of jug from which               water is poured    toCap   -- Capacity of jug to which               water is poured    d       -- Amount to be measured */ int pour(int fromCap, int toCap, int d) {     // Initialize current amount of water     // in source and destination jugs     int from = fromCap;     int to = 0;       // Initialize count of steps required     int step = 1; // Needed to fill "from" Jug       // Break the loop when either of the two     // jugs has d litre water     while (from != d && to != d)     {         // Find the maximum amount that can be         // poured         int temp = min(from, toCap - to);           // Pour "temp" litres from "from" to "to"         to   += temp;         from -= temp;           // Increment count of steps         step++;           if (from == d || to == d)             break;           // If first jug becomes empty, fill it         if (from == 0)         {             from = fromCap;             step++;         }           // If second jug becomes full, empty it         if (to == toCap)         {             to = 0;             step++;         }     }     return step; }   // Returns count of minimum steps needed to // measure d litre int minSteps(int m, int n, int d) {     // To make sure that m is smaller than n     if (m > n)         swap(m, n);       // For d > n we cant measure the water     // using the jugs     if (d > n)         return -1;       // If gcd of n and m does not divide d     // then solution is not possible     if ((d % gcd(n,m)) != 0)         return -1;       // Return minimum two cases:     // a) Water of n litre jug is poured into     //    m litre jug     // b) Vice versa of "a"     return min(pour(n,m,d),   // n to m                pour(m,n,d));  // m to n }   // Driver code to test above int main() {     int t,n ,m,d;  cin>>t;  while(t--)  {  	cin>>n>>m>>d;  	cout<<minSteps(m, n, d)<<endl;  }  }
#include <iostream> #include <cstdio> #include <cstdlib> #include <cmath> #include <queue> #include <algorithm> #include <vector> #include <cstring> #include <stack> #include <cctype> #include <utility> #include <map> #include <string> #include <climits> #include <set> #include <string> #include <sstream> #include <utility> #include <ctime> #include <cassert> #include <fstream> using namespace std; typedef long long LL; typedef vector<int> VI; typedef pair<int, int> II; typedef vector<long long> VLL; typedef vector<bool> VB;  #define SZ(A) ((int)A.size()) #define LEN(A) ((int)A.length()) #define MS(A) memset(A, 0, sizeof(A)) #define MSV(A,a) memset(A, a, sizeof(A)) #define MAX(a,b) ((a >= b) ? (a) : (b)) #define MIN(a,b) ((a >= b) ? (b) : (a)) #define ABS(a) (((a) > 0) ? (a) : (-a)) #define MP make_pair #define X first #define Y second #define PB push_back #define FOUND(A, x) (A.find(x) != A.end()) #define getcx getchar_unlocked #define INF 0x3f3f3f3f #define INFL (LL(1e18)) #define EPS 1e-12  #define chkbit(s, b) (s & (1<<b)) #define setbit(s, b) (s |= (1<<b)) #define clrbit(s, b) (s &= ~(1<<b)) #define rep(i, a, n) for(i = a; i < n; i++) #define rev(i, a, n) for(i = a; i > n; i--) #define FORALL(itr, c) for(itr = (c).begin(); itr != (c).end(); itr++) #define ALL(A) A.begin(), A.end() #define LLA(A) A.rbegin(), A.rend() inline void inp( int &n ) {  	n=0;    int ch=getcx();int sign=1;    	while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}  	while(  ch >= '0' && ch <= '9' )     	n = (n<<3)+(n<<1) + ch-'0', ch=getcx(); 	n=n*sign; }   	 inline void inp1( LL &n ) {  	n=0;    LL ch=getcx();LL sign=1;    	while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}  	while(  ch >= '0' && ch <= '9' )     	n = (n<<3)+(n<<1) + ch-'0', ch=getcx(); 	n=n*sign; }   	   int inv(int a, int b) { 	int q, ps=1, s=0, pt=0, t=1, r,m=a;  	while(a%b != 0) 	{ 		q = a/b; r = a-q*b;  		int tmps=s, tmpt=t; 		s = ps-q*s, t = pt-q*t; 		ps = tmps, pt = tmpt;  		a=b; b=r; 	} 	return (t+m)%m; }   LL power(LL base,LL e,int mod) { 	LL ans=1; 	while(e) 	{ 		if(e&1) 		ans=(ans*base)%mod; 		base=(base*base)%mod; 		e>>=1; 	} 	return ans; }   vector<int> v; vector<int> pd; LL d[20][100005],a[100005]; int p[100005]; LL fir[]={0,1,4,108,27648,86400000}; int main() { 	int i,j,k,n,m,t,c,x,y,r,q; 	LL ans,den,nume,pp; 	for(i=2;i*i<100005;i++) 	{ 		if(!p[i]) 		{ 			for(j=i*i;j<100005;j+=i) 			p[j]=1; 		} 	} 	for(i=2;i<100005;i++) 	if(!p[i])v.PB(i);  //primes till 100005 pushed 	 	inp(t); 	while(t--) 	{ 		pd.clear(); 		inp(n);inp(m);inp(q); 		if(n<=5) 		{ 			rep(i,0,q) 			{ 				scanf("%d",&r); 				printf("%lld\n",(fir[n]/(fir[n-r]*fir[r]))%m); 			} 			continue; 		} 		c=m; 		rep(i,0,v.size()) 		{ 			y=0; 			//if(c%v[i]==0)pd.PB(v[i]); 			while(c%v[i]==0){y++;c/=v[i];} 			if(y)pd.PB(v[i]); 			if(c==1)break; 		} 		if(c>1)pd.PB(c); 		rep(i,0,pd.size())d[i][1]=0; 		a[1]=1; 		rep(i,2,n+1) 		{ 			x=i; 			rep(j,0,pd.size()) 			{ 				y=0; 				while(x%pd[j]==0){y++;x/=pd[j];} 				d[j][i]=d[j][i-1]+(y*i); 			} 			a[i]=(a[i-1]*power(x,i,m))%m; 		} 		rep(i,0,q) 		{ 			inp(r); 			nume=a[n]; 			den=(a[n-r]*a[r])%m; 			pp=1; 			rep(j,0,pd.size()) 			{ 				LL xx=d[j][n]-d[j][n-r]-d[j][r]; 				pp=(pp*power(pd[j],xx,m))%m; 			} 			nume=(nume*pp)%m; 			ans=(nume*inv(m,den))%m; 			printf("%lld\n",ans); 		} 	} 	return 0; } 
#include<bits/stdc++.h>  using namespace std;  #define in(a,x,y) (a>=x && a<=y) #define out(a,x,y) (!in(a,x,y)) #define sz(a) ((int)a.size()) #define repv(i,a) for(int i=0;i<sz(a);i++) #define revv(i,a) for(int i=sz(a)-1;i>=0;i--) #define rep(i,a,b) for(int i=a;i<=b;i++) #define rev(i,a,b) for(int i=a;i>=b;i--) #define all(a) a.begin(),a.end() #define pb push_back  #define AND(a,b) ((a) & (b)) #define OR(a,b) ((a)|(b)) #define XOR(a,b) ((a) ^ (b)) #define xx first #define yy second #define mp make_pair #define sqr(x) ((x)*(x)) #define sqrt(x) sqrt(1.0*(x))  #define LB(a,x) (lower_bound(all(a),x)-a.begin()) //  first element in the range [first,last) which does not compare less than val. #define UB(a,x) (upper_bound(all(a),x)-a.begin()) //  first element in the range [first,last) which compares greater than val. #define forit(it, s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it++) #define left nokol_left #define right nokol_right #define countbit(x) __builtin_popcountll((ll)x) #define PQ priority_queue #define FAST ios_base::sync_with_stdio(0);cin.tie(0); #define Unique(store) store.resize(unique(store.begin(),store.end())-store.begin()) #define READ(f) freopen(f, "r", stdin) #define WRITE(f) freopen(f, "w", stdout)  typedef long long ll; typedef unsigned int uint; typedef unsigned long long ull; typedef pair<int,int> pii; typedef pair<long long,long long> pll; typedef vector<int> vi; typedef vector<long long> vll;  template<class T>T __sqr(const T x){return x*x;} template< class T, class X > inline T __pow(T a,X y) {T z=1; rep(i,1,y){z*=a;} return z; } template< class T > inline T gcd(T a,T b) {a=abs(a);b=abs(b); if(!b) return a; return __gcd(b,a%b);} template< class T > inline T lcm(T a,T b) {a=abs(a);b=abs(b); return (a/__gcd(a,b))*b;} inline bool ispow2(int x){return (x!=0 && (x&(x-1))==0);} template<class T>void UpdateMin(T &x,T y){  if(y<x){x=y;}} template<class T>void UpdateMax(T &x,T y){if(x<y){x=y;}} template<class T,class X, class Y > inline T bigmod(T n,X m,Y mod){ull ret=1, a = n%mod ; while(m){ if(m&1)ret=(ret*a)%mod; m>>=1; a=(a*a)%mod; }ret%=mod;return (T)ret;} template<class T, class Y > inline T modinv(T n,Y mod) {return bigmod(n,mod-2,mod);}  template<class T,class X> int getbit(T s,X i) { return (s >> i) & 1; } template<class T,class X> T onbit(T s, X i) { return s | (T(1) << i); } template<class T,class X> T offbit(T s, X i) { return s & (~(T(1) << i)); } template<class T> inline void read(T &n){char c;for (c = getchar(); !(c >= '0' && c <= '9'); c = getchar()); n = c - '0';for (c = getchar(); c >= '0' && c <= '9'; c = getchar()) n = n * 10 + c - '0';}  void extended_euclid(ll a,ll b,ll &x,ll &y){ if(!b){ x = 1 , y = 0  ;  return ;} ll xx,yy; extended_euclid(b,a%b,xx,yy); x = yy; y = xx - (a/b)*yy; } pair<ll, pair<ll, ll> > extendedEuclid(ll a, ll b) { ll x = 1, y = 0; ll xLast = 0, yLast = 1; ll q, r, m, n; while(a != 0) {q = b / a; r = b % a; m = xLast - q * x; n = yLast - q * y; xLast = x, yLast = y; x = m, y = n; b = a, a = r; } return make_pair(b, make_pair(xLast, yLast)); }  const ll mod[]  ={0,1000000007,1000000009,1000000021,1000000033,1000000097,1000000093,1000000097,1000000103}; const ll base[] ={0,1000003,1000033,1000037,1000039,1000081,1000099,1000117,1000121};  int kk = 1; #define CASE cout<<"Case #"<<kk++<<": "; #define pi acos(-1.0) #define eps  1e-12 #define MX   (lmt + 20 ) #define inf  1000000000 #define MOD  1000000007LL //---------->0123456789123465789 #define lmt  1000000  string a[MX];  char T[MX];  int p = 0; inline void preProcess(string &s) {    T[0] = '^';   p = 0;   repv(i,s){     T[++p] = '#';     T[++p] = s[i];   }    T[++p] = '#';   T[++p] = '$';   T[++p] = '\0';    return ; }  int calc[MX]; int maxLen = 0;  void longestPalindrome(string &s) {   preProcess(s);   int n = p; //  puts(T);     int *P = new int[n];   int C = 0, R = 0;   for (int i = 1; i < n-1; i++) {     int i_mirror = 2*C-i;      P[i] = (R > i) ? min(R-i, P[i_mirror]) : 0;     while (T[i + 1 + P[i]] == T[i - 1 - P[i]])       P[i]++;      if (i + P[i] > R) {       C = i;       R = i + P[i];     }   }    // Find the maximum element in P.   maxLen = 0;   int centerIndex = 0;   for (int i = 1; i < n-1; i++) { //    cout<<P[i]<<" ";     calc[i] = P[i];     if (P[i] > maxLen) {       maxLen = P[i];       centerIndex = i;     }   }   delete[] P;   return  ; //s.substr((centerIndex - 1 - maxLen)/2, maxLen); }  int nxt[MX][26]; int end[MX*26] , pos[MX*26];  int main() { //    string ss = "SUMAN"; //    longestPalindrome(ss);      ios_base::sync_with_stdio(0); cin.tie(0);     int ts , n;     cin>>ts;     while(ts--){         cin>>n;         int rt =1 , next = 1;         memset(nxt , -1 , sizeof nxt);         memset(end, 0 , sizeof end);         memset(pos , 0 , sizeof pos);         rep(i,1,n){             cin>>a[i];             longestPalindrome(a[i]);             int st = rt;             repv(j,a[i]){                 int v = a[i][j] - 'a';                 if( nxt[st][v]==-1 ){                     nxt[st][v] = ++next;                 }                 st = nxt[st][v];                 int baki  = a[i].size() - j - 1;                  if( calc[ (j+1)*2 + baki + 1 ] == baki && baki ){                     pos[ st ]++;                 }             }             end[st]++;         }          ll ans = 0 ;         rep(i,1,n){             reverse(all(a[i]));             longestPalindrome(a[i]);             if(maxLen==a[i].size()) ans--;  //            cout<<"A "<<ans<<endl; //            int              int st = rt;             bool fnd = true;             repv(j,a[i]){                 int v = a[i][j] - 'a';                 if( nxt[st][v]==-1 ){                     fnd = false;                     break;                 }                 st = nxt[st][v];                  if(end[st]){                      int baki  = a[i].size() - j - 1;                     if( calc[(j+1)*2 + baki+1] == baki){ //                    cout<<"asdf"<<endl;                         ans += end[st];                     }                 }             }              if(fnd){                 ans += pos[st];             }         }         cout<<ans<<endl;     }      return 0; }  /* 2 bbaaaa aabb */ 
#include <stdio.h> #include<string.h> #define MAX 5000001 #define MOD 1000000007   #define GETCHAR getchar_unlocked #define PUTCHAR putchar_unlocked     int readInt() { int n = 0; char c; while ((c = GETCHAR()) != '\n') { n = n * 10 + c - '0'; } return n; }   void writeInt(int x) { int i = 10; char buf[11];   buf[10] = '\n'; while (x) { buf[--i] = x % 10 + '0'; x /= 10; }   do { PUTCHAR(buf[i]); } while (buf[i++] != '\n'); }   int isprime[MAX/32+1]; #define isSet(n) isprime[n>>5]&(1<<(n&31)) #define unset(n) isprime[n>>5] &= ~(1<<(n&31)) int answer[MAX];   int count=1; void sieve() { int i,j; memset(isprime,-1,sizeof(isprime)); unset(0); unset(1); unset(4);   for(i=6;i<MAX;i+=6) { unset(i); unset(i+2); unset(i+3); unset(i+4); } for(i=5;i*i<=MAX;i+=2) if(isSet(i)) { for(j=i*i;j<=MAX;j+=i) unset(j); } answer[1]=1; for(i=2;i<MAX;i++) { if(isSet(i)) count++; answer[i]=(int)(((long long)answer[i-1]*count)%MOD); } }       int main() { sieve(); int t,n; t=readInt(); // scanf("%d",&t); while(t--) { n=readInt(); // scanf("%d",&n); writeInt((int)answer[n]); //printf("%d\n",answer[n]); }   return 0; } 
#include <iostream> #include <cstdio> #include <string> #include <stack> #include <cmath> #define ll long long using namespace std;   string ch; ll t,n; ll arr[2000005]; ll tree[2000005]; ll num[2000005]; ll BIT[2000005];   void update(ll node, ll start, ll end, ll idx, ll val) {     if(start == end)     {     	         arr[idx] = val;         tree[node] = val;         //cout << node<<"sx"<<tree[node]<<endl;     }     else     {         ll mid = (start + end) / 2;         if(start <= idx and idx <= mid)         {             // If idx is in the left child, recurse on the left child             update(2*node, start, mid, idx, val);         }         else         {             // if idx is in the right child, recurse on the right child             update(2*node+1, mid+1, end, idx, val);         }         // Internal node will have the sum of both of its children                  ll k1 = tree[2*node];         ll k2 = tree[2*node+1];         tree[node] = k1>k2 ? k1 : k2;     } }     ll query(ll node, ll start, ll end, ll l, ll r) { 	if(node>4*n) 		cout <<"dca"<<node<<endl; 		 	//cout << node<<" "<<start<<" "<<end<<" "<<l<<" "<<r<<endl;     if(r < start || end < l)     {         // range represented by a node is completely outside the given range         return -1;     }     if(l <= start && end <= r)     {         // range represented by a node is completely inside the given range         return tree[node];     }     // range represented by a node is partially inside and partially outside the given range     ll mid = (start + end) / 2;     ll p1 = query(2*node, start, mid, l, r);     ll p2 = query(2*node+1, mid+1, end, l, r);     //cout << p1<<" " << p2<<" " << node<<"="<<start<<" "<<end<<"="<<l<<" "<<r<<endl;     return p1>p2 ? p1 : p2; }   void update(ll x, ll val) {       for(; x <= n; x += x&-x)         BIT[x] += val; } ll query(ll x) {      ll sum = 0;      for(; x > 0; x -= x&-x)         sum += BIT[x];      return sum; }   int main() { 	// your code goes here 	 	scanf("%lld",&t); 	 	while(t--){ 		 		stack<ll> mystack; 		scanf("%lld",&n); 		 		cin >> ch; 		//n = ch.length(); 		for(ll i=0;i<n;i++){ 			num[i+1] = ch.at(i)-'0'; 		} 	 		 		for(ll i=0;i<=4*n+3;i++){ 			tree[i] = -1; 			BIT[i] = 0; 			arr[i] = -1; 		} 		 		for(ll i=1;i<=n;i++){ 			if(num[i]==4) 				mystack.push(i); 			else if(!mystack.empty()){ 				ll indx = mystack.top(); 				mystack.pop(); 				ll mincnt = query(1,1,n,indx,i);  				if(mincnt==-1){ 				 					update(1,1,n,indx,1); 					update(1,1,n,i,1); 				} else { 				 					update(1,1,n,indx,mincnt+1); 					update(1,1,n,i,mincnt+1); 				} 			}  		} 		 		ll ans = 0; 		for(ll i=1;i<=n;i++){ 	 			if(arr[i]==-1) 				continue; 			update(arr[i]+1,1); 			ll temp = query(arr[i]); 			temp = i-temp; 			if(num[i]==4) 				ans += temp; 		 		}  		printf("%lld\n",ans); 		 	} 	 	return 0; } 
#include<bits/stdc++.h> using namespace std; typedef long long int lli; #define ff first #define ss second #define mp make_pair #define ph push_back #define mod 1000000007 #define debug 0 /* error check */ /* 1->varible range over flow  2-> typecasting 3-> set  operation overflow */ int main()  {  	  	 int t;  	  cin>>t;  	  while(t--)  	   {  	   	 int n;  	   	  cin>>n;  	   	   int has1[33];  	   	   int has0[33];  	   	   for(int i=0;i<=32;i++)  	   	    {  	   	    	 has0[i]=1;  	   	    	   	   	    	 has1[i]=0; 			} 			// cout<<has0[0]<<endl; 			 			lli xr=0; 			lli ans=0; 			for(int i=0;i<n;i++) 			 { 			 	 			 	 lli num; 			 	  scanf("%lld",&num); 			 	  num=num ^xr; 			 	  xr=num; 			 	 // cout<<" add "<<num<<endl; 			 	   			 	  for(int j=30;j>=0;j--) 			 	    { 			 	    	int f1=0,f0=0; 			 	    	  if(num &(1<<j)) 			 	    	    { 			 	    	    	// cout<<" bit on "<<j<<" has0[j]"<<has0[j]<<endl; 			 	    	   	   if(has0[j]) 			 	    	   	    { 			 //	    	   	    	cout<<" bit off"<<has0[j]<<endl; 			 	    	   	    	 ans+=has0[j]*lli(1<<j); 								} 								 			 	    	   	  f1=1; 							} 							else 							{ 								 if(has1[j]) 								  { 								  	 ans=ans+(has1[j]*lli(1<<j)); 								  } 								  f0=1; 							} 							 						//	cout<<f1<<" "<<f0<<endl; 							if(f1) has1[j]++; 							if(f0) has0[j]++; 							 			 	   	 					} 				/*	for(int i=2;i>=0;i--) cout<<has0[i]<<" "; 					cout<<endl; 					for(int i=2;i>=0;i--) cout<<has1[i]<<" "; 					cout<<endl;*/ 					 			 } 			cout<<ans<<endl; 		}  	  }
#include <iostream> #include <cstdio> using namespace std;  #include <bitset> #include <algorithm> #include <iomanip> #include <cmath> #include <cstring>  # define FR(i, n)           for( int i = 0; i<=n; i++) # define FRm(i, m, n)     for( int i = m; i <=n; i++) # define FRrev(i, n)         for( int i = n; i >= 0; i-- ) # define FRrevm(i,n,m)         for( int i = n; i >= m; i-- )  # define PF       printf # define PFS PF(" ") # define PFd(x)   printf("%d" , x ) # define PFdS(x)   printf("%d " , x ) # define PFdN(x)  printf("%d\n" , x ) # define PFN	  printf("\n") # define SF    scanf # define SFd(x) scanf("%d",&x) # define SFd2(x,y) scanf("%d%d",&x,&y) # define SFll(x) scanf("%lld",&x) # define SFllc(x) cin>>x  #define LL long long #define inarrd(arr,n) for(int i=0;i<n;i++)SFd(arr[i]); #define outarrdS(arr,n) for(int i=0;i<n;i++){PFd(arr[i]);PF(" ");}PFN; #define outarrN(arr,n) for(int i=0;i<n;i++){PFd(arr[i]);PFN;} #define nmax 10000  int bSearch(int key , int len , int arr[]) { 	int left,right,mid;  	left=0; right=len-1; 	while(left<=right) 	{ 		mid=(left+right)/2; 		if(arr[mid]==key) return mid;  		if(key<arr[mid]) right=mid-1; 		else left=mid+1;  	} 	return -1; } int solveBinary(int inp[] , int p1 , int p2 , int m , int low=0, int high=100000000 ) { 	// p1=starting index 	// p2=last index 	// m=values b/w p1 and p2 required. so including p1 and p2, total of m+2 values to be choosen 	// low,high--> initial low and high values  	int next,cur,mid,start=p1; 	int c2=inp[p2];  	while( (1+low)<high ) 	{ 			mid=(low+high)/2; 			cur=start;  			FRm(i,1,m+1) 			{ 				next=cur; 				while( inp[next]<c2 && inp[next+1]<=(inp[cur]+mid)  ) 				{ 					next++; 				} 				cur=next; 			} 			if(inp[cur]<c2) 				low=mid; 			else   // if u can't get all m values for current mid, then the mid required is less than the current mid 				high=mid; 	} 	return high; }  struct node { 	int x,y; }; class Compare { public:     bool operator()(node a, node b)     {        	if(a.x>b.x)return true; 		if(a.x<b.x)return false; 		return (a.y<b.y);     }     //priority_queue< node,vector<node>,Compare > pq;  // priority if not swapped     //node arr[]={ {1,2},{3,4},{2,3} };  sort(arr,arr+n,Compare()); // b,a system };  int chef[nmax],other[nmax];  int t,n;    int solve() { 	 	int low=0,high=1000000,mid,ans=1000000,chefasstsum; bool flag; 	 	while(low<=high) 	{ 		mid=(low+high)/2; 		 		chefasstsum=0; flag=false; 		FR(i,n-1) 		{ 			if(other[i]<=mid)continue; 			 			if(chef[i]>mid){ flag=true; break; } 			chefasstsum+=chef[i]; 			if(chefasstsum > (2*mid)){flag=true; break;} 			 		} 		 		if(!flag){ ans=min(ans,mid);  high=mid-1; } 		else 		{ 			low=mid+1; 		} 		 	} 	 	return ans; 	 }  void input() { 	SFd(t); 	 	 	while(t--) 	{ 		SFd(n); 		 		FR(i,n-1)SFd2(other[i],chef[i]); 		 		PFdN(solve()); 	} 	 }  int main() { 	input(); 	return 0; } 
#include <iostream> #include<math.h> using namespace std; void primegenrator(int a,int* ar) { 	int m=0; 	for(int i=2;i<=sqrt(a);i++) 	{ 		bool x=0; 		for(int j=2;j<=i/2;j++) 		{ 			if(i%j==0) 			{ 			x=1; 			break;} 		} 		if(x==0) ar[m++]=i; 	} }   int main()  { 	std::ios::sync_with_stdio(false); 	int ar[10000]={0}; 	unsigned long long int p=1100000000; 	primegenrator(p,ar); 	int t; 	cin>>t; 	while(t--) 	{ 	  unsigned long long int h,l; 	  cin>>l>>h; 	  if(l%2==0) 	  { 	  	if(l==2) 	  	cout<<"2"<<endl; 	  	for(int i=l+1;i<=h;i+=2) 	  	{ 	  		bool x=1; 	  		for(int j=0; sqrt(i)>=ar[j];j++) 	  		{ 	  			if(i%ar[j]==0) 	  			{ 	  				x=0; 	  				break; 	  			} 	  		} 	  		if(x) cout<<i<<endl;	 	  	} 	  	 	  } 	   	  else 	  { 	  	for(int i=l;i<=h;i+=2) 	  	{ 	  		bool xx=1; 	  		for(int j=0;sqrt(i)>=ar[j];j++) 	  		{ 	  			if(i%ar[j]==0) 	  			{ 	  				xx=0; 	  				break; 	  			} 	  			 	  			 	  		} 	  		if(xx && i!=1) cout<<i<<endl; 	  		if(i==1) cout<<2<<endl; 	  		 	  	} 	  } 	cout<<endl;	 	} 	return 0; }
#include<stdio.h> int valid[10]={0}; int validator(int value) {  while(value)  {   if(valid[value%10]==0)    return 0;   value/=10;  }  return 1; } int main() {  int n,i,temp,n1,n2,pp1,pp2,product,ans=0,a;  scanf("%d",&n);  for(i=0;i<n;i++)  {   scanf("%d",&temp);   valid[temp]=1;  }  for(n1=111;n1<999;n1++)  {   if(validator(n1))   {    for(n2=11;n2<99;n2++)    {     if(validator(n2))     {      pp1=n1*(n2%10);      pp2=n1*(n2/10);      product=n1*n2;      if((pp1<=999)&&(pp2<=999)&&(product<=9999))      {       if(validator(pp1)&&validator(pp2)&&validator(product))        ans++;          }     }             }   }      }   printf("%d",ans);   return 0; } 
#include <cstdio> #include <algorithm> #include <vector> #include <iostream> #include <string> #include <string.h> #include <cmath> #include <set> #include <map> #include <bitset> #include <iomanip> #include <cstdlib>  #define X first #define Y second  typedef long long ll;  using namespace std;  const int MAXN = 1000100; bool waspl[MAXN + MAXN], wasmn[MAXN + MAXN]; int n, k;  int myabs(int x) {     if (x < 0) x = -x;     return x; }  int cntpl(int sum) {     return n - myabs(n + 1 - sum); }  int cntmn(int dif) {     return n - myabs(dif); }  int sumodd[MAXN + MAXN], sumeven[MAXN + MAXN];    void solve() {     memset(waspl, 0, sizeof(waspl) );     memset(wasmn, 0, sizeof(wasmn) );      memset(sumeven, 0, sizeof(sumeven) );     memset(sumodd, 0, sizeof(sumodd) );      scanf("%d%d", &n, &k);     for (int i = 0; i < k; i++) {         int xx, yy;         scanf("%d%d", &xx, &yy);         waspl[xx + yy] = 1;         wasmn[xx - yy + MAXN] = 1;     }      long long ans = 0;     for (int i = 2; i <= n + n; i++) {         if (waspl[i]) {             ans += cntpl(i);         }     }      for (int i = -n + 1; i <= n - 1; i++) {         if (wasmn[i + MAXN]) {             ans += cntmn(i);         }     }     for (int i = 2; i <= n + n; i++) {         if (i % 2 == 1) {             sumodd[i] = sumodd[i - 2] + waspl[i];         }         else {             sumeven[i] = sumeven[i - 2] + waspl[i];         }     }      for (int i = -n + 1; i < n; i++) {         if (!wasmn[i + MAXN] ) {             continue;         }          int minpl = 2 + myabs(i), maxpl = n + n - myabs(i);          if (minpl % 2 == 0) {             ans -= sumeven[maxpl] - sumeven[minpl - 2];         }         else {             ans -= sumodd[maxpl] - sumodd[minpl - 2];         }     }     cout<<(ll)n*n - ans<<endl; }  int main() {     int test = 1;     scanf("%d", &test);     while (test--) {         solve();     }     return 0; }
#include<iostream> #include<sstream> #include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<bitset> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath> using namespace std;  #define pb								push_back #define s(n)								scanf("%d",&n) #define sl(n) 								scanf("%lld",&n) #define sf(n) 								scanf("%lf",&n) #define fill(a,v) 							memset(a, v, sizeof a) #define INF								(int)1e9 #define EPS								1e-9  typedef long long LL; typedef pair<int, int > PII;  int testCases, testNum; // here follow the sovle, input & main int C,V; struct clause { 	int a, b, c; 	clause(int x = 0, int y = 0, int z = 0) 	{ 		a = x; b = y, c = z; 	} };  clause all[3005]; int adj [3005][10]; int matchR[3005], matchL[3005]; bool chosen[3005], seen[3005];  bool bpm(int v) { 	if(seen[v] ) return false; 	seen[v] = true; 	for(int i = 0; i < 3; i++) 	{ 		int u = adj[v][i]; 		if( matchR[u] < 0 || bpm(matchR[u]) ) 		{ 			matchL[v] = u; 			matchR[u] = v; 			return true; 		} 	} 	return false; }  void solve()  { 	fill( matchL, -1); 	fill( matchR, -1); 	for(int i = 0; i < C; i++) 	{ 		fill( seen, false); 		bpm(i) ; 	} 	fill( chosen, false); 	for(int i = 0; i < C; i++) 	{ 		int x = matchL[i]; 		if( all[i].a ==x || all[i].b == x || all[i].c == x ) 			chosen[x] = true; 	} 	for(int i = 1; i <= V; i++) 		if( chosen[i] ) 			printf("T"); 		else 			printf("F"); 	printf("\n");	 } int main() { 	int T; s(T); 	while(T--) 	{ 		s(C); s(V); 		for(int i = 0; i < C; i++) 		{ 			int a, b, c; 			s(a); s(b); s(c); 			all[i] = clause(a,b, c); 			adj[i][0] = abs(a), adj[i][1] = abs(b), adj[i][2] = abs(c); 		} 		solve(); 	} }
#include <bits/stdc++.h> #define For(i,a,b)	for(int i=(a),_b =(b);i<=_b;++i) #define bug(x) cout<<"bug says:"<<x<<'\n' #define line cout<<'\n' #define loop(a,x)	for(int x=0;x<(int)a.size();++x)cout<<(a)[x]<<' '; #define nenezsnp cout<<"I LOVE NENZSNP"<<'\n' using namespace std; int n,m,k , S; const int M = 100001; const int sq = sqrt(M); int a[M] , LEFT[M] , ans[320][M]; vector<vector<int> > pos; int f(int le,int r){ 	int ans = 0; 	int num = le/S; 	for(int i=le;i<=min ((num+1)*S,n);++i){ 		if (i > r) break; 		int value = upper_bound(pos[a[i]].begin() , pos[a[i]].end(), r) - pos[a[i]].begin(); 		ans = max (ans , pos[a[i]][value-1] - i); 	} 	return ans; } int main(){ 	ios_base::sync_with_stdio(false); 	scanf("%d %d %d",&n , &m,&k);pos.assign (m+1 , vector<int>() ); 	For(i,1,n)	{scanf("%d",&a[i]) ; pos[a[i]].push_back(i); } 	 S = sqrt(n); 	for(int i=0;i*S+1<=n;++i){ 		int L = i*S + 1; 		memset (LEFT ,0,sizeof(LEFT)); 		for(int j=L ; j <=n ;++j){ 			if (LEFT[a[j]] == 0)	LEFT[a[j]] = j; 			ans[i][j] = max (ans[i][j-1] , j - LEFT[a[j]]);		 		} 	} 	For(i,1,n) pos[a[i]].push_back(n+1);  	while (k--){ 		int l,r;	scanf("%d %d",&l,&r); 		printf("%d\n", max (ans[l/S+1][r] , f(l,r)) ); 	} }
#include<stdio.h> #include<assert.h> #define REP(i,a,b) for(i=a;i<b;i++) #define rep(i,n) REP(i,0,n)  #define ll long long  int int_read(void){   int res, c;   for(;;){     c = getchar() - '0';     if(0<=c && c<=9){ res = c; break; }   }   for(;;){     c = getchar() - '0';     if(0<=c && c<=9){ res = res*10 + c; continue; }     break;   }   return res; }  ll ll_read(void){   ll res; int c;   for(;;){     c = getchar() - '0';     if(0<=c && c<=9){ res = c; break; }   }   for(;;){     c = getchar() - '0';     if(0<=c && c<=9){ res = res*10 + c; continue; }     break;   }   return res; }  int main(){   int Q, T; ll N, K;   int i, j;   ll p[15];   int np[15], kp[15];   int ps, nd, res;    N = ll_read();   Q = int_read(); /*  assert( scanf("%lld%d",&N,&Q)==2 );*/   assert( 1LL<=N && N<=1000000000000LL );   assert( 1<=Q && Q<=500000 );    ps = 0;   j = 0; while(N%2==0) j++, N/=2;   if(j) p[ps] = 2, np[ps] = j, ps++;    for(i=3;i*(ll)i<=N;i+=2){     j = 0;     while(N%i==0) j++, N/=i;     if(j) p[ps] = i, np[ps] = j, ps++;   }   if(N>1) p[ps] = N, np[ps] = 1, ps++;    nd = 1;   rep(i,ps) nd *= np[i]+1;    while(Q--){ /*    assert( scanf("%d%lld",&T,&K)==2 );*/     T = int_read();     K = ll_read();     assert( 1<=T && T<=3 );     assert( 1LL<=K && K<=1000000000000LL );      rep(i,ps){       kp[i] = 0;       while(kp[i] < np[i] && K>=p[i] && K%p[i]==0) kp[i]++, K/=p[i];     }      if(T==1){       res = 1;       rep(i,ps) res *= kp[i]+1;       printf("%d\n",res);       continue;     }      res = 0;     if(K==1){       res = 1;       rep(i,ps){         j = np[i] - kp[i];         if(j<0){ res=0; break; }         res *= j+1;       }     }     if(T==3) res = nd - res;      printf("%d\n",res);   }    return 0; }
/*  	Practice for Segment Tree */  #include <iostream> #include <string.h>  #define MAX 400005 typedef long long ll; using namespace std;  int n,q; ll count1[MAX][3]={0}; ll count2[MAX][3]={0}; ll sumt[MAX]={0}; ll arr[MAX]={0}; ll seg[MAX][3]={0};  void merge(int index) { 	//cout<<"Index "<<index<<endl;  	for(int i=0;i<3;i++) 	{	count1[index][i]=count1[2*index][i]+count1[2*index+1][(i-sumt[2*index]+3)%3]; 		count2[index][i]=count2[2*index+1][i]+count2[2*index][(i-sumt[2*index+1]+3)%3]; 		seg[index][i] = seg[2*index][i] + seg[2*index+1][i]; 	} 	for(int i=0;i<3;i++) 	{	for(int k=0;k<3;k++) 		{	seg[index][i] += count2[2*index][k]*count1[2*index+1][(i-k+3)%3]; 		} 		//cout<<seg[index][i]<<" "<<i<<endl; 	}   	sumt[index]=(sumt[2*index]+sumt[2*index+1])%3; } void nodeupdate(int index,int val) {	for(int i=0;i<3;i++) 	{	count1[index][i]=0;count2[index][i]=0;seg[index][i]=0; 	} 	sumt[index]=0; 	count1[index][val%3]++; 	count2[index][val%3]++; 	sumt[index]=val%3; 	seg[index][val%3]++; }  int construct(int ss, int se, int index) {	if(ss==se) 	{	count1[index][arr[ss]%3]++; 		count2[index][arr[ss]%3]++; 		sumt[index]=arr[ss]%3; 		seg[index][arr[ss]%3]++; 		return 0; 	} 	//cout<<ss<<" SS "<<" SE "<<se<<endl;   	int mid = (ss+se)/2; 	construct(ss,mid,2*index); 	construct(mid+1,se,2*index+1); 	merge(index); 	return 0; } void update(int ss,int se,int index,int val,int loc) {	if(loc < ss || loc > se || ss > se)return ;  	if(ss==se) 	{	nodeupdate(index,val); 		return; 	} 	int mid=(ss+se)/2; 	update(ss,mid,2*index,val,loc); 	update(mid+1,se,2*index+1,val,loc); 	merge(index); } struct Node{ 	ll seg; 	ll cou1[3]; 	ll cou2[3]; 	ll sumt; 	Node() 	{	sumt=0;seg=0; 		for(int i=0;i<3;i++) 		{	cou1[i]=0;cou2[i]=0; 		} 	} };  Node query(int ss,int se,int index,int qs,int qe) {	 	//cout<<"Index "<<index<<qs<<qe<<endl; 	Node ans; 	if(ss > se || ss > qe || qs > se ) 	{	ans.seg=0; 		for(int i=0;i<3;i++) 		{	ans.cou1[i]=0;ans.cou2[i]=0; 		} 		ans.sumt=0; 		return ans;  	} 	if( ss >= qs && se <= qe) 	{	ans.seg = seg[index][0]; 		for(int i=0;i<3;i++) 		{	ans.cou1[i]=count1[index][i]; 			ans.cou2[i]=count2[index][i]; 		} 		ans.sumt = sumt[index]; 		return ans; 	} 	Node ans1,ans2;  	int mid=(ss+se)/2; 	ans1 =query(ss,mid,2*index,qs,qe); 	ans2 =query(mid+1,se,2*index+1,qs,qe); 	 	ans.seg = ans1.seg+ans2.seg; 	ans.sumt = (ans1.sumt+ans2.sumt)%3; 	for(int i=0;i<3;i++)ans.seg += ans1.cou2[i]*ans2.cou1[(3-i)%3];  	for(int i=0;i<3;i++) 	{	ans.cou1[i]=ans1.cou1[i]+(ans2.cou1[(i-ans1.sumt+3)%3]); 		ans.cou2[i]=ans2.cou2[i]+(ans1.cou2[(i-ans2.sumt+3)%3]); 	} 	return ans; }  int main() { 	scanf("%d%d",&n,&q); 	char buf[MAX]; 	scanf("%s",buf); 	for(int i=0;i<n;i++) 	{ 		arr[i]=buf[i]-'0'; 	} 	construct(0,n-1,1); 	 	while(q-->0) 	{ 		int k1,k2,k3; 		scanf("%d%d%d",&k1,&k2,&k3); 		k2--; 		if(k1==1) 		{ 			arr[k2]=k3; 			update(0,n-1,1,k3,k2); 		} 		else if(k1==2) 		{ 			k3--; 			printf("%lld\n",query(0,n-1,1,k2,k3).seg); 		} 	} 	 }     
  // AUTHOR : Dipjal Chhetri // Institution : Jaypee Institute of Information Technology       #include <bits/stdc++.h> using namespace std; const int SIZE = 4e5+5; typedef long long int ll;         ll scan(){     ll x=0LL;     register char c = getchar_unlocked();     while(c<'0'||c>'9')         c=getchar_unlocked();       while(c>='0'&&c<='9'){             x=(x<<1)+(x<<3)+c-'0';             c=getchar_unlocked();     }     return x; }   void Output(ll x){     char digits[21];     int varlen=0;     do{             digits[varlen++]=x%10+'0';             x/=10;     }while(x);     --varlen;     while(varlen>=0) putchar_unlocked(digits[varlen--]);     putchar_unlocked('\n'); }                         struct trie {     ll val;     struct trie *left;     struct trie *right; }; struct trie *root; int maxsize = 20; struct trie *initialise(){     struct trie *node;     node = new trie();     node->val = -1;     node->left = NULL;     node->right = NULL;     return node; }; void insert(ll n){     struct trie *node;     node = root;     int i;       for(i = maxsize - 1; i >= 0; i--) {         if(n&(1 << i)) {             if(node->right == NULL) {                 node->right = initialise();             }             node = node->right;         }         else {             if(node->left == NULL) {                 node->left = initialise();             }             node = node->left;         }     }     node->val = n; } long long int query(long long int n) {     int i;     struct trie *node;     node = root;       for(i = maxsize - 1; i >= 0; i--) {         if(n & (1 << i)) {             if(node->left != NULL) {                 node = node->left;             }             else {                 node = node->right;             }         }         else {             if(node->right != NULL) {                 node = node->right;             }             else {                 node = node->left;             }         }     }       return node->val; }     ll n,x,ans,arr[SIZE],dp[SIZE],dp2[SIZE];     void deltree(struct trie *root){       if(root){             deltree(root->left);             deltree(root->right); } free(root); }            void solve1(){       int i;     root = initialise();       n = scan();     for(i = 0; i < n; i++)       arr[i] = scan();               insert(0);         x = 0;       for(i = 0; i < n; i++) {           x=x^arr[i];         if(i>0)         dp[i]=max(dp[i-1],x);         else             dp[i]=x;         insert(x);         dp[i]=max(dp[i-1],max(dp[i],query(x)^x));       }     deltree(root);     root = initialise();     insert(0);     x=0;     for(i=n-1;i>=0;i--){         x=x^arr[i];         if(i<n-1)         dp2[i]=max(dp2[i+1],x);         else             dp2[i]=x;         insert(x);         dp2[i]=max(dp2[i+1],max(dp2[i],query(x)^x));     }     ans=0LL;     for(int i=0;i<n-1;i++)     {         ans=max(ans,dp[i]+dp2[i+1]);     }        Output(ans);   return ;   }         int main(){ solve1(); return 0; }  
#include <stdio.h> #include <stdlib.h> #include <iostream> #include <string.h> #include <algorithm> #include <math.h> #include <vector> #include <queue> #include <set> #include <stack> #include <map> #define INF_MAX 2147483647 #define INF_MIN -2147483647 #define INF_LL 9223372036854775807LL #define INF 2000000000 #define PI acos(-1.0) #define inf INT_MAX #define llu unsigned long long int #define all(v) v.begin(),v.end() #define pb push_back #define mp make_pair #define F first #define S second #define si(n) scanf("%d",&n) #define slli(n) scanf("%lld",&n); #define ss(n) scanf("%s",n); using namespace std; typedef long long int LL;  pair<LL , LL > ppp[5040]; int N , K; LL dp[5008][5008]; //dp[i][j] choose a subset of j castles from the first i castles  LL lmax(LL a , LL b){ 	if(a>b) 		return a; 	return b; }  LL func(int i , int j) {		 	if(i<j) 		return INF_MIN; 	if(dp[i][j]!=-1) 		return dp[i][j];	 	LL R1 , R2; 	R1 = func(i-1 , j);//choose j not to be in 	R2 = func(i-1 , j-1) + ppp[i].second + ((j - 1)*ppp[i].first*1LL);//choose j to be in 	dp[i][j] = lmax(R1 , R2); 	return dp[i][j]; }     int main() { int test; si(test); while(test--) { si(N); memset(dp , -1 , sizeof(dp)); dp[0][0] = 0; for(int i=1;i<=N;i++){ 	dp[i][0] = 0; 	cin >> ppp[i].second; } for(int i=1;i<=N;i++) 	cin >> ppp[i].first; sort(ppp+1 , ppp + N + 1); reverse(ppp+1 , ppp + N + 1); // for(int i=1;i<=N;i++) 	// cout << ppp[i].first << "$" << ppp[i].second << endl; for(int i=1;i<=N;i++) 	cout << func(N , i) << " "; cout << endl; } return 0; } 
#include <algorithm> #include <cstdio> #include <vector> #include <cstring> #include <map>  using namespace std;  #define MOD 10000007 #define BASE 26 #define MAX 100010 #define LL long long  char type[MAX]; LL h=1; map<int,int>dictionary; void preprocess(int L) { 	LL local_base=BASE; 	for(int i=0;i<MAX;i++) type[i]=' ';   } int is_found(int len) { 	dictionary.clear(); 	LL hash_value=0,pow=1; 	int max_occurence=1; 	for(int i=0;i<len;i++) 	{ 		hash_value = hash_value * BASE + type[i] - 'a'; 		pow *= BASE; 		if(pow >= MOD) pow %= MOD; 		if(hash_value >= MOD) hash_value %= MOD; 	} 	dictionary[hash_value]++; 	for(int i=len ; type[i] != ' ' ; i++) 	{ 		hash_value = (hash_value * BASE + type[i]-'a')-(type[i-len]-'a')*pow; 		while(hash_value < 0) hash_value += MOD; 		if(hash_value > MOD) hash_value %= MOD; 		dictionary[hash_value]++; 		if(max_occurence < dictionary[hash_value]) max_occurence = dictionary[hash_value]; 	} 	return max_occurence; } int main() { 	int L,H,len,no_of_chars; 	while(scanf("%d%d",&L,&H)) 	{ 		if(L==0 && H==0) break; 		preprocess(L); 		scanf("%s",type); 		len=strlen(type); 		for(int i=0;type[i] != ' ';i++) no_of_chars++; 		if(no_of_chars < L)  		{ 			printf("0 0\n"); 			continue; 		} 		if(no_of_chars < H) H=no_of_chars; 		int occurence=is_found(L); 		int low = L; 		int high = H; 		int answer = -1; 		while(low <= high) 		{ 			int mid = (low + high) >> 1; 			if(is_found(mid) == occurence) 			{ 				answer = mid; 				low = mid + 1; 			}		 			else high = mid - 1; 		} 		printf("%d %d\n",occurence,answer); 	} 	return 0; } 
#include <iostream> #include <algorithm> #include<string.h> #include <list> #include<queue> #include<vector> #include <cmath> #define mp make_pair using namespace std; #define pii pair<int,int> #define x first #define y second #define inf 100000000 #define N 35 int n,c,d,out,sabil[N],child[N],g[N][N],s[N],dp[N][N][N]; void root(int u,int fa) {  	for(int i=1;i<=n;i++)  	if(g[u][i]&&i!=fa)  	{  	 sabil[i]=child[u];  	 child[u]=i;  	 root(i,u); 	} } int DP(int node,int pa,int c,int d) {  if(node==0)  {   if(c&&d)return max(0,s[pa]);   else return 0;  }  int &ret=dp[node][c][d];  if(ret!=-1)return ret;  ret=DP(sabil[node],pa,c,d);  for(int i=1;i<=c;i++)  for(int j=0;j<d;j++)  ret=max(ret,DP(child[node],node,i,j)+DP(sabil[node],pa,c-i,d-1-j));  return ret; } void trace(int node,int pa,int c,int d) {  if(node==0)  {   if(c&&d&&s[pa]>=0)   {printf("build %d\n",pa);out++;}  }  else  {   int ret=DP(node,pa,c,d);   if(ret==DP(sabil[node],pa,c,d))   {trace(sabil[node],pa,c,d);return;}   for(int i=1;i<=c;i++)   for(int j=0;j<d;j++)   if(ret==DP(child[node],node,i,j)+DP(sabil[node],pa,c-i,d-1-j))   {   	out++;   	printf("transfer %d %d %d\n", pa,node,i);   	trace(child[node],node,i,j);   	trace(sabil[node],pa,c-i,d-1-j);   	return;   }  } } int main() {   //freopen("in.txt","r",stdin);   int i,u,v;   while(~scanf("%d%d%d",&n,&c,&d))   {    for(i=1;i<=n;i++)scanf("%d",&s[i]);    memset(g,0,sizeof(g));    for(i=1;i<n;i++)    {     scanf("%d%d",&u,&v);     g[u][v]=g[v][u]=1;    }    memset(child,0,sizeof(child));    root(1,0);    memset(dp,-1,sizeof(dp));    printf("%d\n",DP(child[1],1,c,d));    out=0;    trace(child[1],1,c,d);    for(;out<d;out++)printf("nothing\n");   }   return 0; } 
    #include <vector>     #include <list>     #include <map>     #include <set>     #include <deque>     #include <stack>     #include <bitset>     #include <algorithm>     #include <functional>     #include <numeric>     #include <utility>     #include <sstream>     #include <iostream>     #include <iomanip>     #include <cstdio>     #include <cmath>     #include <cstdlib>     #include <ctime>     #include <string.h>     #include <queue>     #define LEN 512           #define ii pair<int,int>     #define mp make_pair           using namespace std;     int n,m,d;     int w[LEN][LEN];     bool visited[LEN][LEN];           int solve(int a, int b){     priority_queue< pair<int,ii > , vector<pair<int , ii> > , greater<pair<int , ii> > > Q;     Q.push(mp(w[a][b] , mp(a,b)));     visited[a][b]=true;     while(!Q.empty()){     pair<int, ii > p = Q.top();Q.pop();     int r = p.second.first , c = p.second.second , tmp = p.first;     if(r<=d && c<=d){     return tmp;     }     else{     int lr = max( 0 , r-d ) , lc = max( 0 , c - d ) , mr = min( n , (r+d+1) ) , mc = min(m,c+d+1) ;     for( int i=lr ; i<=r; i++ ) for( int j=lc ; j<=c ; j++ ) {     if( (!visited[i][j]) ){     Q.push(mp(tmp+w[i][j] , mp( i , j )));     visited[i][j] = true;     }     else break;     }     for(int i=r ;i<mr;i++) for( int j = lc ; j <= c ;j++) {     if( ((i)*(i)+(j)*(j)) < (r*r+c*c) && !visited[i][j] ){     Q.push(mp(tmp+w[i][j] , mp( i , j )));     visited[i][j] = true;     }     else break;     }     for( int j=c;j<mc;j++) for( int i = lr ; i <= r ;i++ ) {     if( ((i)*(i)+(j)*(j)) < (r*r+c*c) && !visited[i][j]){     Q.push(mp(tmp+w[i][j] , mp( i , j )));     visited[i][j] = true;     }     else break;     }     }           }     return -1;     }                 int main(){     int test,r,c;     scanf("%d",&test);     while(test--){     scanf("%d%d%d%d%d",&n,&m,&d,&r,&c);     for(int i=0;i<n;i++)     for(int j=0;j<m;j++)     scanf("%d",&w[i][j]);     for(int i=0;i<n;i++) for(int j=0;j<m;j++) visited[i][j]=false;     printf("%d\n",solve(r,c));     }     return 0;     } 
#include<iostream> #include<stdio.h> #include<assert.h> #include<string.h> #include<time.h> #include<stdlib.h> #include<math.h> #include<string> #include<sstream> #include<map> #include<set> #include<queue> #include<stack> #include<vector> #include<algorithm> #pragma comment(linker, "/STACK:16777216") #define pb push_back #define ppb pop_back #define mp make_pair #define all(x) (x).begin(),(x).end() #define sz(x) (int)(x).size() #define LL long long #define bit __builtin_popcountll #define sqr(x) (x) * (x) using namespace std; typedef pair<int, int> pii; const double eps = 1e-9; const double pi = acos(-1.0); const int maxn = (int)1e5 + 10; int n; LL cnt1[maxn],cnt2[maxn]; char a[maxn],b[maxn]; void calc() { 	memset(cnt1,0,sizeof(cnt1)); 	memset(cnt2,0,sizeof(cnt2)); 	for(int i = 0; i < n; i++) 	{ 		if (a[i] == '1') 			cnt1[i]++; 		if (b[i] == '1') 			cnt2[i]++; 	} 	for(int i = 1; i < n; i++) 	{ 		cnt1[i] += cnt1[i - 1]; 		cnt2[i] += cnt2[i - 1]; 	} 	reverse(cnt1,cnt1 + n); 	reverse(cnt2,cnt2 + n); 	for(int i = 0; i < n; i++) 	{ 		cnt1[i + 1] += cnt1[i] / 2; 		cnt1[i] = cnt1[i] % 2; 		cnt2[i + 1] += cnt2[i] / 2; 		cnt2[i] = cnt2[i] % 2; 	} 	int v = 0; 	for(int i = 0; i <= n; i++) 	{ 		cnt2[i] = cnt2[i] - cnt1[i] - v; 		if (cnt2[i] < 0) 		{ 			cnt2[i] += 2; 			v = 1; 		} else v = 0; 	} 	for(int i = n; i >= 0; i--) 	{ 		if (cnt2[i] == 0) continue; 		for(int j = i; j >= 0; j--) 			putchar(char('0' + cnt2[j])); 		putchar('\n'); 		break; 	} } int main() { 	#ifndef ONLINE_JUDGE 	//freopen("input.txt","r",stdin); 	//freopen("output.txt","w",stdout); 	#endif 	int T; 	scanf("%d",&T); 	while(T--) 	{ 		scanf("%d%s%s",&n,&a,&b); 		calc(); 	} 	return 0; } 
#include<cstdio> #include<iostream> #include<algorithm> #include<set> #include<vector> #include<cstdlib> #include<cstring> #include<cmath>  using namespace std; int n,m,w; long long x[250],y[250]; long long mdis[250][250]; vector<pair<long long,int> > disk; vector<long long> r; //int fin[250][250][250]; long long dist(int i,int j){   long long dx=x[i]-x[j];   long long dy=y[i]-y[j];   return (dx*dx+dy*dy); } int dijkstra(){   int dis[250][250];   for(int i=0;i<250;i++)     for(int j=0;j<250;j++)       dis[i][j]=2000000000;   set<pair<int,pair<int,int> > > Q;   int smallest[250];   for(int i=0;i<n;i++)     smallest[i]=m;   int mn=-1;   for(int i=0;i<n;i++){     //    int ind=(int)(lower_bound(r.begin(),r.end(),y[i])-r.begin());     for(int j=smallest[i]-1;j>=0;j--){       if(y[i]<=r[j]){         dis[i][j]=disk[j].second;         Q.insert(make_pair(dis[i][j],make_pair(i,j)));         smallest[i]=j;       }     }   }   while(!Q.empty()){     pair<int,pair<int,int> > top = *Q.begin();     Q.erase(Q.begin());     int i=top.second.first, j=top.second.second;     int d=top.first;     if(y[i]+r[j]>=w){       if(mn==-1)         mn=d;       mn=min(d,mn);       break;     }     for(int k=0;k<n;k++){       if(k!=i){         for(int l=smallest[k]-1;l>=0;l--){           if(mdis[i][k] <= r[j]*r[j]+2*r[j]*r[l]+r[l]*r[l]){             int cost=disk[l].second;             if(dis[k][l]>dis[i][j]+cost){               if(dis[k][l]!=2000000000)                 Q.erase(Q.find(make_pair(dis[k][l],make_pair(k,l))));               dis[k][l]=dis[i][j]+cost;               Q.insert(make_pair(dis[k][l],make_pair(k,l))); 		smallest[k]=l;             }                        } 		else 			break;         }       }     }   }   return mn; } int main(){   int t;   scanf("%d",&t);   while(t--){     disk.clear();     r.clear();     //memset(fin,-1,sizeof fin);     scanf("%d%d%d",&n,&m,&w);     for(int i=0;i<n;i++) scanf("%lld%lld",&x[i],&y[i]);     for(int i=0;i<n;i++)       for(int j=0;j<n;j++)         mdis[i][j]=dist(i,j);     vector<pair<long long, int> >disk1;     for(int i=0;i<m;i++){       long long a;       int b;       scanf("%lld%d",&a,&b); //      r.push_back(a);       disk1.push_back(make_pair(a,b));     }     sort(disk1.begin(),disk1.end());          disk.push_back(disk1[0]);     for(int i=1;i<m;i++){         while(!disk.empty() && disk1[i].second <= disk.back().second){             disk.pop_back();         }         disk.push_back(disk1[i]);     } m=disk.size();     for(int i=0;i<disk.size();i++)         r.push_back(disk[i].first);     sort(r.begin(),r.end());     /*      for(int i=0;i<n;i++){                 for(int j=0;j<m;j++){                 for(int  k=0;k<n;k++){                 fin[i][j][k]=(int)(lower_bound(r.begin(),r.end(),dist(i,k)-r[j])-r.begin());                 }                 }                 }*/     int ans=dijkstra();     if(ans==-1)       cout<<"impossible\n";     else       cout<<ans<<endl;   }   //f954ccafcb   return 0; }
#include<bits/stdc++.h>  using namespace std; #include<stdio.h> #ifndef ONLINE_JUDGE #define get getchar #else #define get getchar_unlocked #endif inline int f() { 	int n=0,s=1; 	char p=get(); 	if(p=='-') 		s=-1; 	while((p<'0' || p>'9') && p!=EOF && p!='-') 		p=get(); 	if(p=='-') 		s=-1,p=get(); 	while(p>='0' && p<='9' ) 	{ 		n=(n<<3)+(n<<1)+(p-'0'); 		p=get(); 	} 	return (n*s); }  int k,n,l,c,z,i,j; char str[500005]; int rotate(int d) 	{ 	i=d; 	if(i==0) 	return 0;   	if(str[d-1]!=str[l-1]) 	return 1;   	for(k=i,j=0;k<l;k++,j++) 	if(!(str[k]==str[j])) 	 return 1; 	  if(i!=0) 	   for(k=0;k<=d-1;k++,j++) 		if(!(str[k]==str[j])) 		return 1; 	return 0; 	}   int main() { int t,m,p,v; scanf("%d",&t);   while(t--) {  scanf("%s%d%d",str,&m,&p); l=strlen(str); c=1; z=1; v=(0-m)%l; if(v<0) v=(l+v)%l;  while(rotate(v)) 	{ 	c++; 	if(z%2==1) 	{ 	v=(v-p)%l; 	if(v<0)     v=(l+v)%l; 	z++; 	} 	else 	{ 	v=(v-m)%l; 	if(v<0)     v=(l+v)%l;     z++; 	} 	} 	printf("%d\n",c); 	}  } 
#include <iostream> #include <cstdio> #include <climits> #include <algorithm> #include <queue> #include <cstring> #include <cmath> #include <vector> #include <list> #include <stack> #include <bitset> #include <string> #include <stack> #include <set> #include <map> #include <deque> #include <ctime>  #define ALL(i,n)    for(i = 0; i < (n); i++) #define FOR(i,a,b)  for(i = (a); i < (b); i++) #define SET(p)      memset(p,-1,sizeof(p)) #define CLR(p)      memset(p,0,sizeof(p)) #define S(n)	    scanf("%d",&n) #define P(n)	    printf("%d\n",n) #define Sl(n)	    scanf("%lld",&n) #define Pl(n)	    printf("%lld\n",n) #define Sf(n)       scanf("%lf",&n) #define Ss(n)       scanf("%s",n) #define LL long long #define ULL unsigned long long #define pb push_back #define mod 1000000007 using namespace std;  LL sum1[6000005], sum0[6000005], cnt1[6000005]; bool upd[6000005]; char str[1000005]; int n;  long long int power(long long int a,long long int b,long long int m) {     long long int result=1;     while(b>0)     {         if(b&1)             result=(result*a)%m;         b=b>>1;         a=(a*a)%m;     }     return result; }  void build(int p,int b,int e) {     int i,c;     if(b>e)         return;     if(b==e)     {         if(b==n)         {             sum1[p]=0;             sum0[p]=0;             cnt1[p]=str[b]-'0';         }         else if(str[b]=='1')         {             sum1[p]=power(2,n-b-1,mod);             sum0[p]=0;             cnt1[p]=1;         }         else         {             sum1[p]=0;             sum0[p]=power(2,n-b-1,mod);             cnt1[p]=0;         }         return;     }      c=p*2;     build(c,b,(b+e)/2);     build(c+1,(b+e)/2+1,e);     sum1[p] = (sum1[c] + sum1[c+1])%mod;     sum0[p] = (sum0[c] + sum0[c+1])%mod;     cnt1[p] = cnt1[c] + cnt1[c+1]; }  void lazy_update(int p,int b,int e,int l,int r) {     int c=2*p,i;     if (b>e || b>r || e<l )     {         if(upd[p]==true)         {             swap(sum1[p],sum0[p]);             cnt1[p]=(e-b+1)-cnt1[p];             if(b<e)             {                 upd[c]^=upd[p];                 upd[c+1]^=upd[p];             }             upd[p]=false;         }         return;     }      if(b==e)     {         upd[p]^=true;         if(upd[p]==true)         {             swap(sum1[p],sum0[p]);             cnt1[p]=(e-b+1)-cnt1[p];             upd[p]=false;         }         return;     }      if (l <= b && r >= e)     {         upd[p]^=true;         if(upd[p]==true)         {             swap(sum1[p],sum0[p]);             cnt1[p]=(e-b+1)-cnt1[p];             upd[c]^=upd[p];             upd[c+1]^=upd[p];             upd[p]=false;         }         return;     }      upd[c]^=upd[p];     upd[c+1]^=upd[p];     lazy_update(c,b,(b+e)/2,l,r);     lazy_update(c+1,(b+e)/2+1,e,l,r);      sum1[p] = (sum1[c] + sum1[c+1])%mod;     sum0[p] = (sum0[c] + sum0[c+1])%mod;     cnt1[p] = cnt1[c] + cnt1[c+1];     upd[p]=0; }  int find_last(int p,int b,int e,int up) {     if(b==e)     {         up=up^upd[p];         if(up)             return 1-cnt1[p];         else             return cnt1[p];     }      return find_last(p*2+1,(b+e)/2+1,e,up^upd[p]); }  int main() {     int t,m,i,j,k,l,r;      scanf("%s",str+1);     n=strlen(str+1);      build(1,1,n);     LL ans=sum1[1];     if(!(cnt1[1]&1))         ans++;     Pl(ans);      S(m);     for(i=1;i<=m;i++)     {         S(l); S(r);         lazy_update(1,1,n,l,r);         ans=sum1[1];         if(!(cnt1[1]&1))             ans++;         if((cnt1[1]&1) && find_last(1,1,n,false))         {             k=find_last(1,1,n,false);             ans++;         }         Pl(ans%mod);     }      return 0; } 
#define _CRT_SECURE_NO_WARNINGS #pragma comment(linker, "/STACK:128777216")  #include <cstdio> #include <cmath> #include <cstring> #include <ctime> #include <algorithm> #include <vector> #include <queue> #include <string> #include <map> #include <set> #include <iostream> #include <functional> #include <numeric> #include <sstream> #include <exception> #include <cassert>  typedef long long i64; typedef unsigned int u32; const int null = 0; using namespace std;  typedef vector<int> VI; typedef vector<int>::iterator VII;  #define all(a) a.begin(),a.end()  template<class T> int size(const T &a) { 	return int(a.size()); } template<class T> T abs(const T &a) { 	return (a < 0 ? -a : a); } template<class T> T sqr(const T &a) { 	return a * a; } const double pi = acos(-1.0);  const int mod = int(1e9 + 7.1);  inline int msum(int a, int b) { 	return (a + b < mod ? a + b : a + b - mod); } inline int mdiff(int a, int b) { 	return (a < b ? a - b + mod : a - b); } inline void madd(int &a, int b) { 	a = msum(a, b); }  struct Set { 	u32 a[47];  	void add(int i) { 		a[i >> 5] |= (1UL << (i & 31)); 	}  	bool has(int j) { 		return a[j >> 5] & (1UL << (j & 31)); 	} 	void operator |= (const Set &b) { 		for (int i = 0; i < 47; i++) { 			a[i] |= b.a[i]; 		} 	}  } a[2000];  char s[2000][2000]; bool was[2000];  void dfs(int i) { 	was[i] = true; 	for (int j = 0; s[i][j]; j++) { 		if (s[i][j] == '1') { 			if (!was[j]) { 				dfs(j); 			} 			a[i] |= a[j]; 		} 	} }  int main() { #ifdef pperm 	freopen("input.txt", "r", stdin); 	//freopen("input.txt", "w", stdout); 	//freopen("output.txt", "w", stdout); #endif 	int T = 1; 	//scanf("%d", &T); 	for (int iTest = 1; iTest <= T; iTest++) { 		int n; 		scanf("%d", &n); 		int m = 0; 		for (int i = 0; i < n; i++) { 			a[i].add(i); 			scanf("%s", s[i]); 			for (int j = 0; j < n; j++) { 				if (s[i][j] == '1') { 					m++; 				} 			} 		} 		for (int i = 0; i < n; i++) { 			if (!was[i]) { 				dfs(i); 			} 		} 		int res = n * (n - 1) / 2 - m; 		printf("%d\n", res); 		for (int i = 0; i < n; i++) { 			for (int j = 0; j < n; j++) { 				if (i != j && !a[j].has(i) && s[i][j] != '1') { 					printf("%d %d\n", i + 1, j + 1); 					a[i] |= a[j]; 				} 			} 			for (int j = 0; j < n; j++) { 				if (a[j].has(i)) { 					a[j] |= a[i]; 				} 			} 		} 	} #ifdef pperm 	fprintf(stderr, "\n%.3lf\n", clock() / double(CLOCKS_PER_SEC)); #endif 	return 0; }
#include<cstdio> #include<vector> #include<string> #include<iostream>   using namespace std;     int main() {     int m;     scanf("%d",&m);     string s;     vector<vector<int> >frnd(m,vector<int>(m));     vector<int>graph[m];     for(int i=0;i<m;i++)     {         cin>>s;         for(int j=0;j<s.size();j++)         {             if(s[j]=='1')             {                 frnd[i][j]=1;                 frnd[j][i]=1;                 graph[i].push_back(j);                 graph[j].push_back(i);             }         }     }     int count=0;     vector<vector<int> >mark(m,vector<int>(m));     for(int i=0;i<m;i++)     {         for(int j=0;j<m;j++)         {             if(frnd[i][j]==0 && mark[i][j]==0 && i!=j)             {                 for(int k=0;k<graph[i].size();k++ )                 {                     if(frnd[j][graph[i][k]]==1 )                     {                         //mark[i][j]=1;                         count++;                         break;                     }                 }             }         }     }     printf("%d\n",count);     return 0; }
#include <bits/stdc++.h> using namespace std; #define REP(a, b, c) for(int a = b; a < c; a++) #define asd(x)              cout<<__LINE__<<" :: "<<#x<< ": "<<x<<endl; #define asdf(x, y)          cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<endl; typedef pair<int,int> ii; typedef long long LL; const int MAX = 1e5 + 5, LIM = 333;  struct query{     int l, r, x, y, id;     void scan(int id){         scanf("%d %d %d %d", &l, &r, &x, &y);         this->id = id;     } } q;  LL org[MAX], wanabe[MAX], ans[MAX], arr[MAX], arr1[MAX], arr2[MAX]; vector<query> store;  void calc(int id){     LL cur = org[id];     REP(i, 0, store.size()){         if(store[i].l <= id and store[i].r >= id){             cur += (LL)store[i].x + ((LL)id - store[i].l) * store[i].y ;         }         if(cur >= wanabe[id]) { ans[id] = store[i].id; return; }     } }  int main(){      int n, m;     cin >> n;     memset(ans, -1, sizeof ans);     REP(i, 1, n+1) scanf("%lld", org + i);     REP(i, 1, n+1) scanf("%lld", wanabe + i);     REP(i, 1, n+1) if(org[i] >= wanabe[i]) ans[i] = 0;      cin >> m;     REP(lol, 0, m){         q.scan(lol+1);         store.push_back(q);         if(store.size() == LIM or lol == m-1){                          REP(i, 0, store.size()){                 LL x = store[i].x, y = store[i].y;                 arr[store[i].l] += x;                 arr[store[i].r + 1] -= x;                 arr1[store[i].l + 1] += y;                 arr1[store[i].r + 1] -= y;                 arr2[store[i].r + 1] -= y * (store[i].r - store[i].l);             }              REP(i, 1, n+1) {                                  arr1[i] += arr1[i-1];                 arr2[i] += arr2[i-1] + arr1[i];                 arr[i] += arr[i-1];                  if(ans[i] == -1 and org[i] + arr[i] + arr2[i] >= wanabe[i]) {                     calc(i);                 }                 org[i] += arr[i] + arr2[i];             }              store.clear();             memset(arr, 0, sizeof arr);  memset(arr1, 0, sizeof arr1); memset(arr2, 0, sizeof arr2);         }     }          REP(i, 1, n+1) printf("%lld ", ans[i]); puts("");     return 0; } 
#include <stdio.h> #include <stdlib.h> #include <iostream> #include <string.h> #include <algorithm> #include <math.h> #include <vector> #include <queue> #include <set> #include <stack> #include <map> #define INF_MAX 2147483647 #define INF_MIN -2147483647 #define INF_LL 9223372036854775807LL #define INF 2000000000 #define PI acos(-1.0) #define inf INT_MAX #define llu unsigned long long int #define all(v) v.begin(),v.end() #define pb push_back #define mp make_pair #define F first #define S second #define si(n) scanf("%d",&n) #define slli(n) scanf("%lld",&n); #define ss(n) scanf("%s",n); using namespace std; typedef long long int LL; double dp[3004][3004]; //dp[i][j] = the probability to have j different elements in the list, such as length of the list is i. double ans = 0.0; int main(){ int N , test; si(test); while(test--) { 	si(N); 	ans = 0.0; 	for(int i=1;i<=N;i++) 		ans = ans + ((double)1.0)/(i); 	ans = ans * N * 1.0; 	printf("%.7lf\n", ans); } /* cin >> N; dp[0][0] = 1.0000; for(int i=0;i<=N;i++){ 	for(int j=0;j<=N;j++){ 		dp[i+1][j] = dp[i][j]*((double)j/(double)N); 		dp[i+1][j+1] = dp[i][j]*((double)(N-j)/(double)N); 	} } ans = 0.0; // for(int i=1;i<=N;i++) 	// ans = ans + (dp[i][N]*i*1.0);  for(int i=1;i<=N;i++){ 	for(int j=1;j<=N;j++) 		printf("%.7lf ", dp[i][j]); printf("\n"); } */   return 0; }         
#include <iostream> #include <cstring> #include <algorithm>  using namespace std;  #define BITCOUNT(mask) ( __builtin_popcount((mask)) )  int N, M; int adj[20];  int ALL;  /* int DP[1<<20];  int solve() {    const int MAXMASK = (1<<N)-1;    memset(DP, 0x3f, sizeof(DP));    DP[0] = 0;    for (int mask = 1; mask <= MAXMASK; ++mask) {       for (int i = 0; i < N; ++i) {          if (mask & (1<<i)) continue;          int num_seen = BITCOUNT(mask & adj[i]);          int num_yet_seen = BITCOUNT( (MAXMASK ^ mask) & adj[i] );          int cost = - num_yet_seen * (N - 1 - i) +                     num_seen * (N - 1 - i);          DP[mask | (1<<i)] = min(DP[mask | (1<<i)], DP[mask] + cost);       }    }    return DP[MAXMASK]; } */  bool cached[1<<20]; int memo[1<<20]; int go(int mask) {    if (mask == (1<<N)-1) return 0;    if (cached[mask]) return memo[mask];    int res = 1000000000;    int dist_to_end = (N - 1) - BITCOUNT(mask);    for (int i = 0; i < N; ++i) {       if (mask & (1<<i)) continue;       int num_seen = BITCOUNT(mask & adj[i]);       int num_yet_seen = BITCOUNT( (ALL ^ mask) & adj[i] );       int cost = num_yet_seen * dist_to_end -                      num_seen * dist_to_end;       int cur = go(mask | (1<<i)) + cost; /*       if (mask == 5)          cerr << i << ": " << cur << ' ' << cost << ' '               << num_seen << ' ' << num_yet_seen << endl; */       res = min(res, cur);    }    cached[mask] = true;    return memo[mask] = res; }  int solve() {    memset(cached, 0, sizeof(cached));    return go(0); }   int solve_bf() {    int best = 1000000000;    int P[20];    for (int i = 0; i < N; ++i) P[i] = i;    do {       int cur = 0;       for (int i = 0; i < N; ++i) {          int u = P[i];          for (int j = 0; j < i; ++j) {             int v = P[j];             if (adj[u] & (1<<v))                cur += i-j;          }       }       best = min(best, cur);    } while (next_permutation(P, P+N));    return best; }  int main(int argc, char* argv[]) {    ios_base::sync_with_stdio(false);     cin.tie(NULL);     cin >> N >> M;    for (int m = 0; m < M; ++m) {       int u, v;       cin >> u >> v;       --u, --v;       adj[u] |= 1<<v;       adj[v] |= 1<<u;    }    ALL = (1<<N)-1;     cout << solve() << "\n"; // cout << solve_bf() << "\n";     return 0; } 
// -*- C++ -*- // File: a.cpp // Copyright (C) 2013 #include <algorithm> #include <string> #include <vector> #include <queue> #include <iostream> #include <cmath> #include <sstream> #include <map> #include <set> #include <numeric> #include <memory.h> #include <cstdio> #include <assert.h>  using namespace std;  #define pb push_back #define INF 1011111111 #define FOR(i,a,b) for (int _n(b), i(a); i < _n; i++) #define rep(i,n) FOR(i,0,n) #define CL(a,v) memset((a),(v),sizeof(a)) #define mp make_pair #define X first #define Y second #define all(c) (c).begin(), (c).end() #define SORT(c) sort(all(c))  typedef long long ll; typedef vector<int> VI; typedef pair<int,int> pii;  /*** TEMPLATE CODE ENDS HERE */  const int maxn = 1<<18; const int logn = 18;  int timer_1, timer_2; VI g[maxn]; int P[maxn][logn]; int t_in[maxn], t_out[maxn]; int depth[maxn]; int diametr[maxn]; int query[maxn];  void dfs(int at, int from) { 	P[at][0] = from;	 	FOR(i,1,logn) P[at][i] = P[ P[at][i-1] ][i-1]; 	t_in[at] = timer_1++; 	rep(i,g[at].size()) dfs(g[at][i], at); 	t_out[at] = timer_2++; }  bool is_ancestor(int a, int b) {  // if i is ancestor of j 	return t_in[a] <= t_in[b] && t_out[a] >= t_out[b]; }  int lca(int a, int b) { 	if(is_ancestor(a,b)) return a; 	if(is_ancestor(b,a)) return b; 	for(int i = logn-1; i>=0; --i) if(!is_ancestor(P[a][i],b)) a = P[a][i]; 	return P[a][0]; }  int main() { #ifdef LOCAL_HOST     freopen("input.txt","r",stdin);     //freopen("output.txt","w",stdout); #endif      ios_base::sync_with_stdio(false); 	 	int T; 	cin >> T; 	 	while(T--) { 		 		int n; 		cin >> n; 		 		rep(i,n) g[i].clear(); 		 		FOR(i,1,n) { 			int t; 			cin >> t; 			t--; 			g[t].pb(i); 			query[i] = t; 		} 		 		timer_1 = timer_2 = 0; 		dfs(0,0); 		 		depth[0] = 0; 		diametr[0] = 0; 		 		int cur = 0, ans = 0; 		 		FOR(it,1,n) { 			 			const int v = query[it];			 			depth[it] = depth[v] + 1; 			 			if(depth[cur]==depth[v]) { 				diametr[it] = diametr[cur] + 1; 				cur = it; 				ans = max(ans, max(diametr[it], depth[it])); 			} 			else { 				int u = lca(it, cur); 				diametr[cur] = max(diametr[cur], depth[cur] + depth[it] - 2*depth[u]); 				ans = max(ans, diametr[cur]); 				ans = max(ans, depth[it]); 				ans = max(ans, depth[cur]); 			} 			cout << ans << endl; 		} 		 	}  #ifdef LOCAL_HOST     printf("TIME: %.3lf\n",double(clock())/CLOCKS_PER_SEC); #endif      return 0; } 
/* Jai Gupta */ #include <iostream> #include <cstdio> #include <vector> #include <stack> #include <queue> #include <string> #include <cstring> #include <map> #include <cstdlib> #include <algorithm> #include <list> #include <deque> #include <bitset> #include <cmath> #include <functional> #include <set>  using namespace std;  #define INT_MAX 2147483647 #define INT_MIN -2147483648 #define uint unsigned int #define MAX(a,b)   (((a)>(b))?(a):(b)) #define MIN(a,b)   (((a)<(b))?(a):(b)) #define CMAX(a,b)  if((a)<(b)) a=b #define CMIN(a,b)  if((a)>(b)) a=b #define FOR(i,a,b)   for(i=a; i<b; i++) #define REVI(i,a,b)  for(int i= a ; i >= b ; --i) #define LET(x,a)     __typeof(a) x(a) #define IFOR(i,a,b)  for(LET(i,a);i!=(b);++i) #define EACH(it,v)   IFOR(it,v.begin(),v.end()) #define SWAP(a,b,t)  t=a,a=b,b=t #define REP(i,n)     for(int i=0; i<n; i++) #define ll           long long int #define ull          unsigned long long int #define gint(t)      scanf("%d", &t); #define pint(t)      printf("%d\n", t); #define pb           push_back  #ifdef JAI_ARENA #define debug(args...) {dbg,args; cerr<<endl;} #define dline cerr<<endl #else #define debug(args...) {}; #endif  typedef pair<int, int>  pii; typedef vector<int>     vi; typedef vector<vi>      vii; typedef vector<pii>     vpii;  struct debugger {     template<typename T> debugger& operator , (const T& v) 	{ 	    cerr<<v<<" "; 	    return *this; 	} } dbg;   #define BUF 4096 char ibuf[BUF]; int ipt = BUF;   int readInt() {     while (ipt < BUF && ibuf[ipt] < '0') ipt++;     if (ipt == BUF) { 	fread(ibuf, 1, BUF, stdin); 	ipt = 0; 	while (ipt < BUF && ibuf[ipt] < '0') ipt++;     }     int n = 0;     while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');     if (ipt == BUF) { 	fread(ibuf, 1, BUF, stdin); 	ipt = 0; 	while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');     }     return n; }   /* memset(start*, byteVal, numBytes);  *  memcpy(dst*, src*, numBytes);  */  vpii e[65540]; char col[65540]; vector<ll> dis; int n; char bfs(int start) {     dis.resize(n);     queue<int> tr;     tr.push(start);     col[start] = 1;     dis[start] = 0;     while(!tr.empty())     { 	int a = tr.front(), d = dis[a]+1; 	IFOR(i,0,e[a].size()) 	{ 	    if(col[e[a][i].first] == 0) 	    { 		dis[e[a][i].first] = dis[a]+e[a][i].second; 		debug("setting dis of ", e[a][i].first, "to", dis[e[a][i].first]); 		tr.push(e[a][i].first); 		col[e[a][i].first] = 1; 	    } 	    else if(dis[e[a][i].first] != dis[a] + e[a][i].second) { 		debug(i, a, e[a][i].first, "failed", dis[e[a][i].first], dis[a], e[a][i].second); 		return 0; 	    } 	} 	tr.pop();     }     return 1; } int main() {     gint(n);     n++;     memset(col, 0, n*sizeof(char));     int m; gint(m);     REP(mi, m)     { 	int s; gint(s); 	int t; gint(t); 	int w; gint(w); 	pii a(t, w); 	pii b(s-1, -w); 	e[s-1].pb(a); 	e[t].pb(b);     }     REP(ni, n)     { 	if(col[ni] == 0) 	if( !bfs(ni)) 	{ 	    printf("-1\n"); return 0; 	}     }     printf("%lld", dis[1]-dis[0]);     IFOR(ni, 2, n)     { 	printf(" %lld", dis[ni] - dis[ni-1]);     }     printf("\n");     return 0; } 
#include <iostream> #include <vector> #include <cstdio> using namespace std; struct seg {     int left,right,val; }; seg findval[100005]; int a[100005]; vector<int> v[100005]; int find(int pos){     if(findval[pos].val == pos) return pos;     else return find(findval[pos].val); } int main(){     int n, m, x, y, q;     scanf("%d%d", &n, &m);     for(int i = 0; i < n; i++)findval[i].left = findval[i].right = findval[i].val = i;     for(int i = 0; i < n; i++) scanf("%d", &a[i]);     for(int i = 0; i < m; i++) scanf("%d%d", &x, &y),x--,y--,v[x].push_back(y);     scanf("%d", &q);     int ans = 0;     while(q--) {         int p;         scanf("%d", &p),--p;         p += ans;         if(!a[p]) {             cout << ans << endl;             continue;         }else a[p]--;         if(!a[p]) {             int flag1 = 0, flag2 = 0;             if(p+1 < n && !a[p+1])flag2++;             if(p-1 >= 0 && !a[p-1])flag1++;             if(flag1 && flag2) {                 int set1, set2;                 set1 = find(p-1);                 set2 = find(p+1);                 findval[set1].right = findval[set2].right;                 findval[set2].val = set1;                 findval[p].val = set1;             }             else if(flag1) {                 int set1 = find(p-1);                 findval[p].val = set1;                 findval[set1].right = p;             }             else if(flag2) {                 int set1 = find(p+1);                 findval[p].val = set1;                 findval[set1].left = p;             }             int set1 = findval[p].val;             int start = findval[set1].left;             while(start <= p) {                 for(int i = 0; i < v[start].size(); i++) {                     if(p <= v[start][i] && v[start][i] <= findval[set1].right)ans++;                 }                 start++;             }         }         printf("%d\n", ans);     } } 
#include <cstdio> #include <cstring> #include <cmath> #include <algorithm>  using namespace std;  double prob[101][4951], sum[101][4952], sum2[101][4952];  int main() {   prob[0][0] = 1;    for (int i = 1; i <= 100; ++i) {     for (int j = (i - 1) * (i - 2) / 2; j >= 0; --j)       for (int k = 0; k < i; ++k) prob[i][j + k] += prob[i - 1][j] / i;   }    for (int i = 1; i <= 100; ++i) {     sum[i][0] = sum2[i][0] = 0;      for (int j = 0; j <= i * (i - 1) / 2; ++j) {       sum[i][j + 1] = sum[i][j] + prob[i][j];       sum2[i][j + 1] = sum2[i][j] + prob[i][j] * j;     }   }    int T, n, a[100];   long long k;   double dp[10000];    scanf("%d", &T);    while (T--) {     scanf("%d %lld", &n, &k);      for (int i = 0; i < n; ++i) scanf("%d", &a[i]);      int inv = 0;      for (int i = 0; i < n; ++i)       for (int j = i + 1; j < n; ++j)         if (a[i] > a[j]) ++inv;      if (k >= inv)       printf("0\n");     else if (k == 0)       printf("%d\n", inv);     else {       int m = n * (n - 1) / 2;        dp[0] = m / 2.0;        for (int i = 1; i < k; ++i) {         dp[i] = 0;          int r = (int)(i + floor(dp[i - 1]));          if (r >= i + 1)           dp[i] += sum2[n][r + 1] - sum2[n][i + 1] -                    i * (sum[n][r + 1] - sum[n][i + 1]);          if (r + 1 <= m) dp[i] += dp[i - 1] * (sum[n][m + 1] - sum[n][r + 1]);       }        printf("%.7f\n", min(dp[k - 1], (double)inv - k));     }   }    return 0; }
#include <iostream> #include <string.h> #include <algorithm> #include <fstream> #include <map> #include <vector> #include <queue> #include <stack> #include <utility> #include <string> #include <iomanip> #include <cstring> #include <cmath>  #define vint vector<int>::iterator #define vintp vector<pair<int,int> >::iterator #define inf 1000000010 #define ll long long #define maxn 501 #define mod  1000000007  using namespace std;  ifstream fin("C.in"); ofstream fout("C.out");  int n,k,m,t,d; int a[100001]; int RMQ[20][100001];  int MAX (int i, int j) {     int l = log2 (j-i+1);      return max (RMQ[l][i],RMQ[l][j-(1<<l)+1]); }  int main() {     cin>>n;      for (int i=1; i<=n; ++i)     {         cin>>a[i];     }      for (int i=1; i<n; ++i)     {         RMQ[0][i] = a[i+1] - a[i];     }      for (int j=1; (1<<j)<=n; ++j)     {         for (int i=1; i+(1<<j)-1 <= n; ++i)         {             RMQ[j][i] = max (RMQ[j-1][i],RMQ[j-1][i+(1<<(j-1))]);         }     }      cin>>m;      for (int i=1; i<=m; ++i)     {         cin>>t>>d;          int lo = 0, hi = n+1;          while (hi - lo > 1)         {             int mid = (lo + hi)/2;              if (a[mid] <= t)                 lo = mid;             else hi = mid;         }          int poz = lo;          lo = 0, hi = poz;          while (hi - lo > 1)         {             int mid = (lo + hi)/2;              if (MAX(mid,poz-1) <= d)                 hi = mid;             else lo = mid;         }          cout<<hi<<"\n";     } } 
#include<bits/stdc++.h> using namespace std; #define sd(x) scanf("%d",&x) #define slld(x) scanf("%lld",&x) #define ss(x) scanf("%s",x) #define ll long long #define mod 1000000007 #define bitcount    __builtin_popcountll #define pb push_back int a[10000007]; int p(int x,int y) { 	if(y==0) 		return 1; 	if(y==1) 		return x; 	int z=p(x,y/2); 	return (1ll*((1ll*z*z)%mod)*p(x,y%2))%mod; } int main() {     //freopen("in.txt","r",stdin);     //freopen("out.txt","w",stdout);     int t,n,m,l,r,i,j,k,x;     sd(t);     while(t--)     {     	sd(n);     	sd(m);     	sd(l);     	sd(r);     	for(i=m;i>=l;i--)     	{     		k=0;     		for(j=2*i;j<=m;j+=i)     		{     			k+=a[j];     			if(k>=mod)     				k-=mod;     		}     		if(i!=m&& m/i == m/(i+1))     			a[i]=x;     		else     		{     			a[i]=p(m/i,n);     			x=a[i];     		}     		a[i]-=k;     		if(a[i]<0)     			a[i]+=mod;     	}     	k=0;     	for(i=l;i<=r;i++)     	{     		k+=a[i];     		if(k>=mod)     			k-=mod;     	}     	printf("%d\n",k);     }     return 0; }
#include <bits/stdc++.h> using namespace std; #define gc getchar_unlocked #define rep(i,n) for(i=0;i<n;i++) #define ll long long #define FOR(i,k,n) for(i=k;i<n;i++)  const int mod = 1000000007;  void read(int &x) {     register int c = gc();     x = 0;     for(;(c<48 || c>57);c = gc());     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} }  void read(long long &x) {     register int c = gc();     x = 0;     for(;(c<48 || c>57);c = gc());     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} }  int powMod(int base, int extra_primesp) {   base %= mod;   int result = 1;   while (extra_primesp > 0) {     if (extra_primesp & 1) result = ((ll)result * base) % mod;     base = ((ll)base * base) % mod;     extra_primesp >>= 1;   }   return result; } int posi[114], decompose[114]; int primes[26]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101}; int factor( int n){ 	int i; 	int total = 0; 	while(n%2 == 0){ 		n = n>>1; 		total |= 1<<posi[2]; 	} 	i = 3; 	while(i*i<=n){ 		while (n%i==0){ 			n /= i; 			total |= 1<<posi[i]; 		} 		i += 2; 		 	} 	if (n > 2){ 		total |= 1<<posi[n]; 	}	 	return total; 	 } long long factorial[100003]; long long comb(int n, int k){ 	if (k>n) 		return 0; 	long long total = factorial[n]; 	 	total *= powMod(factorial[n-k], mod-2); 	total %= mod; 	total *= powMod(factorial[k], mod-2); 	total %= mod; 	return total; }  void pre(){          int i, j;     factorial[0]=factorial[1]=1;     int n = 1e5+3;     FOR(i,2,n)     	factorial[i] = (factorial[i-1]*i)%mod;  	 } long long dp[26][3*(1<<15)+3], total[26];  int main(){ 	int t; 	pre(); 	read(t); 	int i,n, m,j,k,allones; 	rep(i, 113) 		posi[i]=-1; 	rep(i, 25){ 		posi[primes[i]] = i; 	} 	FOR(i, 1, 100+1) 			decompose[i] = factor(i); 	while(t--) 	{ 		read(n); read(m); 		int lower_limit = 0, extra_primes = 0; 		while(primes[lower_limit]<=m)lower_limit++; 		int pri_avail = lower_limit; 		if (lower_limit>15){ 			extra_primes = lower_limit-15; 			lower_limit = 15; 		} 		int N = min(n, lower_limit); 		for(i=0;i<26;i++) 			total[i]=0; 		rep(i,26) 			rep(j,(1<<15)+1) 				dp[i][j]=0; 		allones = (1<<lower_limit)-1; 		 		FOR(j,0,1<<lower_limit) 			dp[0][j] = 1; 		FOR(i, 1, N+1){ 		FOR(j, 2, m+1){ 			int can = j; 			if(posi[can] != -1 && j>=50) 				continue; 			FOR(k, 0, allones+1){ 				if ( (k&decompose[can]) ==0){ 					dp[i][k|decompose[can]] += dp[i-1][k];	 					if (dp[i][k|decompose[can]] >= mod) 						dp[i][k|decompose[can]] -= mod; 				} 			} 		} 		} 		 		 		int xx; 		xx = 1; 		 		while(xx<=pri_avail){ 			 			j = 0; 		 			while(j<=xx) 			{ 				long long x = comb(extra_primes, j); 				x *= dp[xx-j][allones]; 				x %= mod; 				x *= comb(xx, j); 				x %= mod; 				x *= factorial[j]; 				x %= mod; 				total[xx] += x; 				if (total[xx] >= mod) 					total[xx] -= mod; 				j++; 			} 			xx++; 		} 		long long result = 1;	 		FOR(i, max(0,n-pri_avail), n){ 			result += (total[min(pri_avail,n-i)]*comb(n,i))%mod; 			if (result >= mod) 				result -= mod; 		} 		cout<<result<<endl; 	} 	 	return 0; }    
#include <iostream> #include <algorithm> #include <cstring> #include <cstdio>  using namespace std;  int n; int p[101]; int dp[101][101]; double mem[101][101];  int gcd(int a, int b) {         if(!a || !b) return max(a, b);         return __gcd(a, b); }  int solve1(int pos, int g) {     if(dp[pos][g] != -1) return dp[pos][g];     int res = 0;      for(int i = pos; i < n; i++) {         int x = gcd(p[i], g);         if(x == 1) continue;         swap(p[pos], p[i]);         if(!solve1(pos+1, x)) res = 1;         swap(p[pos], p[i]);     }     return dp[pos][g] = res; }  double solve2(int pos, int g) {     if(mem[pos][g] > -0.5) return mem[pos][g];     double res = 0;      for(int i = pos; i < n; i++) {         int x = gcd(p[i], g);         if(x == 1) continue;         swap(p[pos], p[i]);         res += (1.0 - solve2(pos+1, x))/(n-pos);         swap(p[pos], p[i]);     }     return mem[pos][g] = res; }  int main() {     int t;      cin >> t;      while(t--) {         cin >> n;         memset(dp, -1, sizeof(dp));         memset(mem, -1, sizeof(mem));         for(int i = 0; i < n; i++) {             cin >> p[i];         }          printf("%d %.4f\n", solve1(0,0), solve2(0,0));     } } 
