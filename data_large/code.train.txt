#include <bits/stdc++.h> using namespace std;  int main() { 	// your code goes here 	long long int t,i,k; 	cin>>t; 	while(t--) 	{ 	   string x,y; 	    	   cin>>x>>y; 	   k=x.length(); 	   for(i=0;i<k;i++) 	   { 	       if(x[i]==y[i]) 	       { 	           if(x[i]=='W') 	           cout<<"B"; 	           else 	           cout<<"W"; 	       } 	       else 	       cout<<"B"; 	   } 	   cout<<endl; 	    	    	     	} 	 	return 0; } 
#include <iostream> using namespace std;  int main() { 	std::ios_base::sync_with_stdio(false); 	int t,n,opt[100001],i,j; 	long long int a[100001]; 	cin>>t; 	while(t--) 	{ 		cin>>n; 		for(i=0;i<n;i++) 		{ 			cin>>a[i]; 			opt[i]=1; 		} 		for(i=n-2;i>=0;i--) 		{ 			if((a[i]*a[i+1])<0) 				opt[i]=opt[i+1]+1; 				 		/*	else 			{	 				for(j=i+2;j<n;j++) 						if((a[i]<0&&a[j]>0)||(a[i]>0&&a[j]<0)) 							opt[i]=opt[j]+1; 			}*/ 		} 		for(i=0;i<n;i++) 			cout<<opt[i]<<" "; 		cout<<endl; 	} 	return 0; }
#include<iostream> using namespace std; int main(){ 	 	long numOfSoldiers; 	cin>>numOfSoldiers; 	 	long array[numOfSoldiers]; 	 	for(long i=0; i< numOfSoldiers; i++){ 		cin>>array[i]; 	} 	 	long odd = 0, even =0; 	for(long i=0; i< numOfSoldiers; i++){ 		if(array[i]%2){ 			++odd; 		}else{ 			++even; 		} 	} 	 	if(even > odd){ 		cout<<"READY FOR BATTLE"<<endl; 	}else{ 		cout<<"NOT READY"<<endl; 	} 	 	return 0; }
#include<bits/stdc++.h> using namespace std; int main() {     int t;     scanf("%d",&t);     while(t--)     {         char a[100000];         scanf("%s",a);         int b=0,l,i;         int mb=0;         l=strlen(a);         for(i=0;i<l;i++)         {             if(a[i]=='(')                 b++;             else                 b--;             if(b>mb)                 mb=b;         }         for(i=0;i<mb;i++)             cout<<'(';         for(i=0;i<mb;i++)             cout<<')';         cout<<endl;      }     return 0; } 
#include <iostream>  using namespace std;   int main() { int t; cin>>t; while(t--){         int n;     cin>>n;     long a[100]; for(int i=0;i<n;i++){     cin  >> a[i]; }  int cnt = 0; for (int x=0;x<n;x++){         int sum= 0; long prdt= 1; for (int i=x;i<n;i++){      sum+=a[i];      prdt*=a[i];      if(sum==prdt) {             cnt++;     } }   }cout<< cnt<<endl; } }
#include<stdio.h> int main() { 	int T,n,n1,i,j; 	scanf("%d",&T); 	while(T--) 	{ 		scanf("%d",&n); 		int a[n]; 		for(i=0;i<n;i++) 			scanf("%d",&a[i]); 		scanf("%d",&n1); 		int b[n1]; 		for(i=0;i<n1;i++) 			scanf("%d",&b[i]); 		for(i=0,j=0;i<n && j<n1;i++) 		{ 			if(a[i]==b[j]) 			{ 			   // i=-1; 			    j++; 			} 		} 		if(j==n1) 			printf("Yes\n"); 		else 			printf("No\n");     } 	return 0; }
#include<bits/stdc++.h> using namespace std; int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 	    char a[102],b[102]; 	    int min=0,max=0; 	    scanf("%s%s",a,b); 	    int len=strlen(a); 	    for(int i=0;i<len;i++) { 	       if (a[i]=='?' || b[i]=='?') { 	           max++; 	       } else if(a[i]!=b[i]) { 	           min++; 	           max++; 	       } 	    } 	    printf("%d %d\n",min,max); 	} 	return 0; } 
#include <stdio.h> int returnMax (int a, int b){ 	if (a>=b) return a; 		else return b; } int main() { 	int t; 	int p[100]; 	char c; 	scanf("%d\n",&t); 	while (t--) 	{ 		p['a']=0; p['b']=0; 		while ((c=getchar())!='\n') p[c]++; 		printf("%d\n", p['a']+p['b']-returnMax(p['a'],p['b'])); 	} 	return (0); }  
#include <iostream> using namespace std;   int main() {     int t,a,b;     cin>>t;     while(t--)     {         cin>>a>>b;         if(a<b)             cout<<"<";         else if(a>b)             cout<<">";         else             cout<<"=";         cout<<endl;     }     return 0; }
#include<iostream> #include<string> using namespace std; int main() {     string s;     cin>>s;     int c,ch,che,chef;     c=ch=che=chef=0;     for(int i=0;i<s.size();i++)     {         if(s[i]=='C')             c++;         else if(s[i]=='H')         {             if(c>0)              {                  c--;                  ch++;              }             }         else if(s[i]=='E')         {             if(ch>0){                 ch--;             che++;}         }         else if(s[i]=='F')         {             if(che>0){                 che--;             chef++;}         }       }     cout<<chef<<endl;     return 0; }
#include <bits/stdc++.h> using namespace std;  #define ii pair<double, long long>  const long long maxn = 1e6; double _min[maxn]; priority_queue<ii, vector<ii > > pq; long long dp[maxn]; long long mod = 1e9 + 7;  int main() {   ios::sync_with_stdio(0);   cin.tie(0);      long long n, k; cin >> n >> k;   long long x; cin >> x;   dp[0] = x;   pq.push(ii(-log(x), 0));   for (long long i = 1; i < n; ++i) {     while (pq.top().second < i - k) pq.pop();     cin >> x;     ii p = pq.top();     pq.push(ii(p.first - log(x), i));     dp[i] = (dp[p.second] * x) % mod;   }   cout << dp[n - 1] << endl;    return 0; }
#include<iostream> #include<math.h> using namespace std; int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		int p,i,j,x,c=0; 		cin>>p; 		int d; 		for(i=11;i>=0;i--) 		{ 			x=pow(2,i); 		 d=p/x; 		 if(d>0) 		 { 		 	c=c+d; 		 	p=p%x; 		 } 		  		} 	cout<<c<<endl; 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; int main() {     int t;     scanf("%d",&t);     while(t--)     {         int n,r,g,b,i;         r=0,g=0,b=0;         cin>>n;         char a[100001];         scanf("%s",a);         for(i=0;i<n;i++)         {             if(a[i]=='R')             {                 r++;             }             else if(a[i]=='B')             {                 b++;             }             else             {                 g++;             }         }         int ma=0;         int tot=r+b+g;         if(b>=r && b>=g)             ma=b;         if(r>=b && r>=g)             ma=r;         if(g>=r && g>=b)             ma=g;         cout<<tot-ma<<endl;     }     return 0; } 
#include <iostream>  using namespace std;  bool close(int dx, int dy, int r) {   return dx*dx + dy*dy <= r*r; }  int main() {   int t, x[3], y[3], r, a, b, c, d, e, f;   cin >> t;   while (t--) {     cin >> r >> a >> b >> c >> d >> e >> f;     int num = 0;     if (close(a-c,b-d,r)) ++num;     if (close(a-e,b-f,r)) ++num;     if (close(c-e,d-f,r)) ++num;     if (num > 1) cout << "yes" << endl;     else cout << "no" << endl;   } } 
#include<bits/stdc++.h> using namespace std; int main() {     int t,i;     scanf("%d",&t);     int p[30];     int to=1;     for(i=0;i<30;i++)     {         p[i]=to;         to*=2;     }     while(t--)     {         int A,B;         cin>>A>>B;         int ib;         int ia;         int ans=0;         int f=0;         for(i=0;i<30;i++)         {             if(p[i]==B)                 ib=i;         }         for(i=0;i<30;i++)         {             if(p[i]==A)             {                 ia=i;                 f=1;                 break;             }         }         while(f==0)         {             A/=2;             ans++;             for(i=0;i<30;i++)             {                 if(p[i]==A)                 {                     ia=i;                     f=1;                     break;                 }             }         }         ans+=abs(ib-ia);         cout<<ans<<endl;     }     return 0; } 
//brute #include<bits/stdc++.h> using namespace std; int main() {     int t;     scanf("%d",&t);     while(t--)     {         int a[10]={0};         int m,x,y,i;         cin>>m>>x>>y;         for(i=0;i<m;i++)         {             cin>>a[i];         }         sort(a,a+m);         int r=x*y;         int coun=0;         if(a[0]>r+1)             coun=a[0]-r-1;         for(i=1;i<m;i++)         {             if(a[i]-a[i-1]>(2*r)+1)                 coun+=a[i]-a[i-1]-2*r-1;         }         if(100-r>a[m-1])             coun+=100-r-a[m-1];         cout<<coun<<endl;     }     return 0; } 
#include<bits/stdc++.h> using namespace std;  int main() {         long long int i,j,test,x,y; 	long long int n,m,k,arr; 	long long int count;     cin>>test; 	while(test--) 	 { 	   count = 0; 	   cin >> n; 	   cin>>k; 	   for(i = 0 ; i < n ; i++) 	      { 		    cin>>arr;  	 	      	x = arr % k; 	       if(arr < k) 	       count+=k-arr; 		else	 		count = count + min(x , k-x );	 	     } 	      	     cout<<count << endl; 	 }	 	 	 	return 0; }
#include<stdio.h> long long int sum[10005]={0},brr[10005]; void merge(long long int b[],int start,int mid ,int end) {     int lctr=start,rctr=mid,k=0;     for(k=start;lctr<mid&&rctr<end;k++)     {         if(b[lctr]<b[rctr])         {             brr[k]=b[lctr];             lctr++;         }          else         {             brr[k]=b[rctr];             rctr++;         }     }     while(lctr<mid)     {         brr[k]=b[lctr];         lctr++;         k++;     }      while(rctr<end)     {         brr[k]=b[rctr];         rctr++;         k++;     }      for(int i=start;i<end;i++)     {         b[i]=brr[i];     } } void mergesort(long long int ar[],int start, int end) {     int size=end-start;      if(size==1)     return;      int mid=size/2;      //printf("Sizesssss %d %d %d\n",start,mid,end);     //getchar();     mergesort(ar,start,start+mid);     mergesort(ar,start+mid,end);     merge(ar,start,start+mid,end); } int main() {     int t,n,k,e;     long long int m;      scanf("%d",&t);      while(t--)     {         scanf("%d %d %d %lld",&n,&k,&e,&m);         long long int c;          for(int i=0;i<n;i++)         {             if(i!=n-1)             {                 for(int j=0;j<e;j++)                 {                     scanf("%lld",&c);                     sum[i]=sum[i]+c;                 }             }              else             {                 for(int j=0;j<e-1;j++)                 {                     scanf("%lld",&c);                     sum[i]=sum[i]+c;                 }             }         }          mergesort(sum,0,n-1);          /*for(int i=0;i<n;i++)         {             printf("%lld ",sum[i]);         }         printf("\n");          printf("%lld %lld\n",sum[n-k-1],sum[n-1]);*/          long long int temp=sum[n-k-1]-sum[n-1]+1;          if(temp<=m)         {             if(temp>=0)             printf("%lld\n",temp);              else             printf("0\n");         }          else         {             printf("Impossible\n");         }          for(int i=0;i<n;i++)         {             sum[i]=0;         }     }     return 0; } 
#include <iostream> using namespace std;  int main() { 	// your code goes here 	int t; 	cin>>t; 	for(int i=0;i<t;i++){ 	    int j,count=0; 	    cin>>j; 	    while(j/5>=1){ 	        count += j/5; 	        j=j/5; 	    } 	    cout<<count<<endl; 	} 	return 0; }
#include<iostream> using namespace std; void factorial(int n){ 	int i,size=1,carry=0,j,temp; 	int arr[200]; 	arr[0]=1; 	if(n==1){ 		printf("1\n"); 		return; 	} 	for(i=2;i<=n;i++){ 		for(j=0;j<size;j++){ 			temp=arr[j]*i+carry; 			arr[j]=temp%10; 			carry=temp/10; 		} 		while(carry!=0){ 			arr[j++]=carry%10; 			carry=carry/10; 		} 		size=j;	 	} 	for(i=size-1;i>=0;i--){ 		printf("%d",arr[i]); 	} 	printf("\n"); } int main() { 	int i ,j, n; 	cin>>n; 	int num; 	for(i=0;i<n;i++) 	{ 		cin>>num; 		factorial(num); 	}  return 0; } 
#include<iostream> using namespace std; int main() { int t; cin>>t; long int a,b; while(t--) { cin>>a; cin>>b; a=a+b; cout<<a<<"\n"; } return 0; }
#include<iostream> #include<math.h> using namespace std;  int main() { 	// your code goes here 	int T; 	 	cin>>T; 	 	while(T--){ 	    int A,B; 	    cin>>A>>B; 	    cout<<A%B<<endl; 	} 	return 0; } 
#include<iostream> using namespace std; int main(){ int t,n,f,l; cin>>t; while(t--){     cin>>n;     f=n%10;     for(int i=0;n>0;i++){         l=n%10;         n=n/10;     }     cout<<f+l<<endl; } } 
#include<iostream> using namespace std; int main(){ 	int t,n,ans; 	int A[6]={100,50,10,5,2,1}; 	cin>>t; 	while(t--){ 		cin>>n; 		ans=0; 		for(int i=0;i<6;i++){ 			if(n==0) 				break; 			if(n/A[i] > 0){ 				ans=ans+n/A[i]; 				n=n%A[i]; 			} 		} 		cout<<ans<<endl; 	} 	return 0; } 
#include <bits/stdc++.h> long long int t, n, i, sum; using namespace std;  int main() { 	scanf("%lld",&t); 	while(t--) { 		scanf("%lld",&n); 		sum = 0; 		while(n > 0) { 			sum += n%10; 			n = n/10; 		} 		printf("%lld\n",sum); 	} 	return 0; }  
#include<iostream> #include<cmath> using namespace std; int main() { 	int t; 	cin>>t; 	while(t--) 	{ 	 	int n,ans=0; 	cin>>n; 	while(n!=0) 	{ 		ans=ans*10 + n%10; 		n/=10; 	} 	cout<<ans<<endl; 	 	} 	return 0; }
#include <iostream>  using namespace std;  int main (void) {     int t;      // stores the number of test cases     cin >> t;     int temp[t];     for (int i = 0 ; i < t ; i ++ )     {         cin >> temp[i];     }      for (int i = 0 ; i < t ; i ++)     {         if (temp[i] < 10 )             cout << "What an obedient servant you are!" << endl;         else             cout << -1 << endl;     } } 
#include<iostream> #include<stdio.h> using namespace std; int main() { 	long int q,p;     double value; 	int t; 	cin>>t; 	while(t--) 	{ 		cout<<endl; 		cin>>q>>p; 		value=p*q; 		if(q>=1000) 		value*=0.9; 		printf("%.6lf",value); 	} 	return 0; } 
  #include<bits/stdc++.h> using namespace std;  int main(void){ 	 	int t; 	char c; 	cin>>t; 	while(t--){ 		cin>>c;	 		if(c>=97 && c<=122) c-=32; 		switch(c){ 			 			case 'B':cout<<"BattleShip"<<endl;break; 			case 'C':cout<<"Cruiser"<<endl;break; 			case 'D':cout<<"Destroyer"<<endl;break; 			case 'F':cout<<"Frigate"<<endl;break; 		} 	} 	return 0; } 
#include<iostream> using namespace std; int main() { 	int t; 	long salary; 	float gsalary,hra,da; 	cin>>t; 	while(t--) 	{ 		cout<<endl; 		cin>>salary; 		if(salary<1500) 		{ 		hra=float(salary)*0.1; 		da=float(salary)*0.9; 		} 		else 		{ 		hra=500.0; 		da=float(salary)*0.98; 		}; 		gsalary=salary+da+hra; 		cout<<gsalary; 	} 	return 0; }
 #include<bits/stdc++.h> using namespace std;  int main(void){ 	 	int t,a,b,c; 	cin>>t; 	while(t--){ 		cin>>a>>b>>c; 		if( (a>=1&&a<=180)&&(b>=1&&b<=180)&&(c>=1&&c<=180) ){ 			a =a+b+c; 			if( a==180) 				cout<<"YES"<<endl; 			else 				cout<<"NO"<<endl; 		}	 		else 			cout<<"NO"<<endl; 	} } 
#include<iostream> #include<cstdio> #include<cstring> #include<vector>  using namespace std;  int main() {     int t;     float h,s,c;     scanf("%d",&t);     while(t--)     {         scanf("%f %f %f",&h,&c,&s);         if(h>50 && c<0.7 && s>5600)             printf("10\n");         else if(h>50 && c<0.7)             printf("9\n");         else if(c<0.7 && s>5600)             printf("8\n");         else if(h>50 && s>5600)             printf("7\n");         else if(h>50||c<0.7||s>5600)             printf("6\n");         else             printf("5\n");      }     return 0; } 
#include <iostream> using namespace std;  int main() {     int t;     cin>>t;     while(t--)     {         int y;         cin>>y;         int d;         d=((y-1900)%7);         for(int i=1900;i<y;i++)         {             if((i%4==0 && i%100!=0) ||(i%400 ==0))                 d++;         }         int f=0;         d=d%7;         switch (d)         {         case 0:         cout<<"monday\n";break;         case 1:         cout<<"tuesday\n";break;         case 2:         cout<<"wednesday\n";break;         case 3:         cout<<"thursday\n";break;         case 4:         cout<<"friday\n";break;         case 5:         cout<<"saturday\n";break;         case 6:         cout<<"sunday\n";break;         }     }     return 0; } 
#include <bits/stdc++.h> using namespace std;  int main () {     int tc;     cin >> tc;     while (tc--) {         int a, b;         cin >> a >> b;         cout << __gcd(a,b) << " " << (a*b)/__gcd(a,b) << endl;     }     return 0; } 
#include<iostream> using namespace std;   int main(){       int numbers;       cin>>numbers;       int i=0;       while(i<numbers){            cout<<endl;            int num1;            cin>>num1;            int max=num1;            cout<<" ";            int num2;            cin>>num2;            if(num2>max){                max=num2;}            cout<<" ";            int num3;            cin>>num3;            if(num3>max){                max=num3;}                        if(max==num1){                  if(num2>num3){                      cout<<num2<<endl;}                  else{                       cout<<num3<<endl;}}                                   else if(max==num2){                 if(num1>num3){                       cout<<num1<<endl;}                 else{                       cout<<num3<<endl;}}                                 else{                  if(num1>num2){                       cout<<num1<<endl;}                  else{                        cout<<num2<<endl;}}                                      i=i+1;} }                            
#include<iostream> using namespace std; void factorial(int n){ 	int i,size=1,carry=0,j,temp; 	int arr[200]; 	arr[0]=1; 	if(n==1){ 		printf("1\n"); 		return; 	} 	for(i=2;i<=n;i++){ 		for(j=0;j<size;j++){ 			temp=arr[j]*i+carry; 			arr[j]=temp%10; 			carry=temp/10; 		} 		while(carry!=0){ 			arr[j++]=carry%10; 			carry=carry/10; 		} 		size=j;	 	} 	for(i=size-1;i>=0;i--){ 		printf("%d",arr[i]); 	} 	printf("\n"); } int main() { 	int i ,j, n; 	cin>>n; 	int num; 	for(i=0;i<n;i++) 	{ 		cin>>num; 		factorial(num); 	}  return 0; }
#include<bits/stdc++.h> using namespace std; int main() {     int t,i,j,l;     scanf("%d",&t);     while(t--)     {         char a[100][6];         int b[100]={0};         char c[6];         int ls;         int n,k;         cin>>n>>k;         for(i=0;i<n;i++)         {             scanf("%s",a[i]);         }         for(i=0;i<k;i++)         {             cin>>ls;             for(j=0;j<ls;j++)             {                 scanf("%s",c);                 for(l=0;l<n;l++)                 {                     if(strcmp(a[l],c)==0)                         b[l]=1;                 }             }         }         /*for(i=0;i<n;i++)         {             printf("%s %d\n",a[i],b[i]);         }*/         for(i=0;i<n;i++)         {             if(b[i]==1)                 cout<<"YES ";             else                 cout<<"NO ";         }         cout<<endl;     }     return 0; } 
#include<bits/stdc++.h>  using namespace std;  int main() { 	int test, i,j,num,n,m,k,flag; 	int arr[500]; 	 	cin>>test; 	while(test--) 	{ 		flag = 0; 		cin>>n; 		cin>>m; 		cin>>k; 		 		for(i = 0 ; i < k ; i++) 		   { 		   	   if(n < m && k > 0) 		   	     { 		   	        n++; 				 	 				 } 		   	    if(m < n && k > 0) 		   	    { 	                 m++; 						   	    	     			 }     			      			if(m == n) 				  { 				     break;   				  }  		   	   		   	  		   } 		    		   cout << abs(m-n)<<endl;  		 	} 	 	 }
#include <iostream> #include <cstdio> #include <math.h>  int main() {   int t, n;   scanf("%d", &t);    for (int i = 0; i < t; ++i) {     scanf("%d", &n);      printf("%d\n", int(sqrt(n)));   }    return 0; } 
#include<iostream> #include<cstdio> #include<cstring> #include<vector> #include<cmath>  using namespace std;  int main() {     int t,rem;     long long int n,k;     scanf("%d",&t);     while(t--)     {         int maxi=0;         scanf("%lld %lld",&n,&k);         while(k>=1)         {             rem=n%k;             if(maxi==0)               maxi=rem;             else               maxi=max(maxi,rem);         k--;         }         printf("%d\n",maxi);     }     return 0; } 
#include<iostream> #include<cstdio> #include<cstring> #include<cmath>  using namespace std;  int main() {     int t,n;     char str[1000];     scanf("%d",&t);     while(t--)     {         int count=0,curr=0;         scanf("%d",&n);         scanf("%s",&str);         for(int i=0;i<strlen(str);i++)         {             if(str[i]=='I')                 count++;             else if(str[i]=='Y')                curr++;         }         if(count>0)             printf("INDIAN\n");         else if(curr>0)             printf("NOT INDIAN\n");         else             printf("NOT SURE\n");      }     return 0; } 
#include <iostream> #include <iomanip>   using namespace std;   int main(){ 	int x; 	double y; 	cin>>x>>y; 	if(x%5==0 && (float)x+0.5<=y){ 		y = y-(float)x-0.50; 	} 	cout<< setprecision(2) << fixed <<y<<endl; } 
#include<iostream> using namespace std;  int main(){ 	int n,k,y,t=0; 	cin>>n>>k; 	 	for(int i=0;i<n;i++){ 		cin>>y; 		if(y%k==0){ 			t++; 			} 			} 	cout<<t; 	return 0; }
#include<iostream> using namespace std; int main() { 	ios::sync_with_stdio(false); 	int t; 	cin>>t; 	while(t--) 	{ 		int n; 		cin>>n; 		int a[n],b[n],i,m,l=0; 		for(i=0;i<n;i++)	cin>>a[i]; 		for(i=0;i<n;i++)	cin>>b[i]; 		if(a[0]>=b[0])	l++; 		for(i=1;i<n;i++) 		{ 			m=a[i]-a[i-1]; 			if(m>=b[i])	l++; 		} 		cout<<l<<endl; 	} 	return 0; }
/* coder: Anh Tuan Nguyen */ #include <bits/stdc++.h> using namespace std;  int main() { #ifdef gsdt     freopen("input.txt","r",stdin); #endif // gsdt      int nT;     cin>>nT;     for(int q=1; q<=nT; q++)     {         int n, money=0;         string origin ;         cin>>n;         cin>>origin ;         for(int j=0; j<n; j++)         {             string prize;             cin>>prize;              if(prize=="CONTEST_WON")             {                 int c;                 cin>>c;                 money+=max(0,20-c)+300;             }             if(prize=="TOP_CONTRIBUTOR") money+=300;             if(prize=="BUG_FOUND")             {                 int c; cin>>c;                 money+=c;             }             if(prize=="CONTEST_HOSTED") money+=50;         }         if(origin=="INDIAN") cout<<money/200;         else cout<<money/400;         cout<<endl;     }      return 0; } 
#include<iostream> #include<cstdio> #include<cstring> #include<vector> #include<cmath>  using namespace std;  int main() {     int t;     char arr[26];     char str[50];     scanf("%d",&t);     while(t--)     {         scanf("%s",&str);         int n=strlen(str);          memset(arr,0,sizeof(arr));          for(int i=0;i<n;i++)         {                if(str[i]=='a')                arr[0]++;                if(str[i]=='b')                arr[1]++;                if(str[i]=='c')                arr[2]++;                if(str[i]=='d')                arr[3]++;                if(str[i]=='e')                arr[4]++;                if(str[i]=='f')                arr[5]++;                if(str[i]=='g')                arr[6]++;                if(str[i]=='h')                arr[7]++;                if(str[i]=='i')                arr[8]++;                if(str[i]=='j')                arr[9]++;                if(str[i]=='k')                arr[10]++;                if(str[i]=='l')                arr[11]++;                if(str[i]=='m')                arr[12]++;                if(str[i]=='n')                arr[13]++;                if(str[i]=='o')                arr[14]++;                if(str[i]=='p')                arr[15]++;                if(str[i]=='q')                arr[16]++;                if(str[i]=='r')                arr[17]++;                if(str[i]=='s')                arr[18]++;                if(str[i]=='t')                arr[19]++;                if(str[i]=='u')                arr[20]++;                if(str[i]=='v')                arr[21]++;                if(str[i]=='w')                arr[22]++;                if(str[i]=='x')                arr[23]++;                if(str[i]=='y')                arr[24]++;                if(str[i]=='z')                arr[25]++;         }         int check=0;         for(int j=0;j<26;j++)         {             if(n-arr[j]==arr[j])             {               printf("YES\n");               check=1;               break;             }         }         if(check==0)         {           printf("NO\n");         }     }     return 0; } 
#include<iostream> #include<cstring> using namespace std; int a[10]; int main() { 	int t,n,m; 	string s; 	cin>>t; 	while(t--) 	{ 		 		cin>>n>>m; 		for(int i=0;i<10;i++) 		{ 			a[i]=0; 		} 		 		for(int i=0;i<n;i++) 		{ 			cin>>s; 			for(int j=0;j<m;j++) 			{ 				if(s[j]=='1') 				{ 					a[j]++; 				} 			} 			 		} 		int ans=0; 		for(int i=0;i<m;i++) 		{ 			if(a[i]>1) 			{ 				ans+=(a[i]*(a[i]-1))/2; 			} 		} 		cout<<ans<<endl; 		 	} 	 	 	return 0; }
#include<stdio.h> int main() {     int n,i,count;     char ch;     scanf("%d",&n);     scanf("%c",&ch);     i=0;     while(i<n)     {         count = 0;          while(scanf("%c",&ch)!=EOF)         {             if(ch==10)             {                 break;             }             else             {                    if(ch=='4')                 {                     count++;                 }             }         }         printf("%d\n",count);         i++;     }     return(0); }                          
#include <bits/stdc++.h> using namespace std; int main(){ 	int t,n,x; 	scanf("%d", &t); 	while(t--){ 		int ans=0; 		scanf("%d", &n); 		while(n--){ 			scanf("%d", &x); 			ans = ans ^ x; 		} 		printf("%d\n", ans ); 	} }
#include<bits/stdc++.h> using namespace std; typedef unsigned long long ll; int main() {     ll t;     cin>>t;     while(t--)     {         ll n;         cin>>n;         ll a[n];         for(ll i=1;i<=n;i++)         {             cin>>a[i];         }         sort(a+1,a+n+1);         ll ans=a[1]*(n-1);         cout<<ans<<endl;     } } 
#include<bits/stdc++.h> using namespace std; int rate(int r[],int n) {     int maxx=0,index;     for(int i=1;i<=n;i++)     {         if(r[i]>maxx){            maxx=r[i];            index=i;}     }     return index; } int main() {   int t,i;   cin>>t;   while(t--)   {       int n;       cin>>n;       int l[n],r[n];       for(i=1;i<=n;i++)         cin>>l[i];       for(i=1;i<=n;i++)         cin>>r[i];         int maxx=0,index,m,x=0;         for(i=1;i<=n;i++)         {             m=l[i]*r[i];             if(m>=maxx){                    if(m==maxx)                    {                     index=rate(r,i);                     continue;                    }                 maxx=m; index=i;             }         }         cout<<index<<endl;   }   return 0; } 
#include<bits/stdc++.h> using namespace std; int main() {     int t;     scanf("%d",&t);     while(t--)     {         int a[2][250000];         int n;         int f,i,j,k,l;         cin>>n;         for(i=0;i<n;i++)         {             for(j=0;j<n;j++)             {                 cin>>f;                 a[0][f-1]=j;                 a[1][f-1]=i;             }         }         k=0;         for(i=0;i<(n*n)-1;i++)         {             k+=abs(a[0][i]-a[0][i+1])+abs(a[1][i]-a[1][i+1]);         }         cout<<k<<endl;     }     return 0; } 
#include<iostream>  using namespace std;  int main(){ 	int t,i; 	cin>>t; 	 	long int a[t]; 	 	/*input*/ 	 	for(i=0;i<t;i++){ 		cin>>a[i]; 	} 	 	/*Judgement */ 	long j; 	for(i=0;i<t;i++){ 		j = (a[i]/2)+1; 		cout<<j<<endl; 	} 	 	return 0; }
#include<iostream> #include<algorithm> using namespace std;  int main() { 	int t,r,c,x,s,j,i; 	cin>>t; 	while(t--) 	{ 		cin>>r>>c; 		if(r>c) 			swap(r,c); 		//cout<<r<<c<<endl; 		s=c-1; 		x=(2*(r))+1; 		for(j=2;j<=r;j++) 		for(i=1;i<=c;i++) 		{ 			if(i!=1) 				s++; 			s++; 		} 		cout<<s<<endl; 	} }
#include <bits/stdc++.h> using namespace std;  string s;  string transform() {   stack<string> op;   stack<char> opp;   for (int i = 0; i < s.length(); ++i) {     if (s[i] == ')') {       string a = op.top();       op.pop();        string b = op.top();       op.pop();       b += a + opp.top();       opp.pop();       op.push(b);     }      else if (s[i] >= 'a' && s[i] <= 'z') op.push(s.substr(i, 1));     else if (s[i] != '(') opp.push(s[i]);   }   return op.top(); }  int main() {   ios::sync_with_stdio(0);   cin.tie(0);    int t; cin >> t;   while (t--) {     cin >> s;     cout << transform() << endl;   }     return 0; }
#include <iostream> using namespace std;  int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		int n,num; 		int rev =0; 		cin>>n; 		num =n; 		while(n != 0) 		{         	int rem = n%10;         	rev = rev*10 + rem;         	n/=10;     	}     	if(num==rev)     	{     		cout<<"wins"<<endl;     	}     	else     	{     		cout<<"losses"<<endl;     	}  	} 	return 0; } 
#include<iostream> using namespace std; #include<stdio.h> #include <stdlib.h> char buf[600000]; long int a[100000],t; int check() { long int i;     for(i=1;i<t;i++)     if(a[a[i]]!=i)           break;  if(i==t)    return 1;    else    return 0; } void fastio() {    long int i=1,j=0,n=0;   fgets(buf,600000,stdin);   while(buf[j]&&buf[j+1]!='\0')   {       if(buf[j]!=' ')          n=n*10+(buf[j]-48);     else        {            a[i++]=n;            n=0;        }        j++;   }   a[0]=0;   a[i]=n; }  int main() {     char ch;     cin>>t;     while(t!=0)    {     ch=getchar();     fastio();     if(check())     printf("ambiguous\n");     else     printf("not ambiguous\n");     cin>>t;    }     return 0; } 
  #include<bits/stdc++.h> using namespace std;  bool prime( int x ){ 	 		if(x<2)                        return false;                 for( int i=2; i<=sqrt(x); i++ ){                         if((x%i) == 0)                                 return false;                 }                 return true;  }  int main(void){ 	 	int t,x; 	cin>>t; 	while(t--){ 		cin>>x; 		if(prime(x)) 			cout<<"yes"<<endl; 		else 			cout<<"no"<<endl; 	} } 
//CODECHEF PROBLEM: RECIPE //AUTHOR: Diksha Modi (diksham1)  #include <bits/stdc++.h>  using namespace std;  int main() { 	int t; 	cin>>t; 	int hcf,size; 	int arr[51],i = 0; 	while(t--) 	{ 		cin>>size; 		cin>>arr[0]; 		cin>>arr[1]; 		hcf = __gcd(arr[0],arr[1]); 		i = 2; 		while(i<size) 		{ 			cin>>arr[i]; 			hcf = __gcd(hcf,arr[i-1]); 			i++; 		} 		for(i = 0; i<size; i++) 			cout<<(arr[i]/hcf)<<' '; 		cout<<'\n'; 	} 	return 0; } 
#include <iostream> using namespace std; #define ll long long  int main() {   ll t;     cin>>t;     while(t--)     {   ll a,b,i,k;         cin>>a>>b;         if(a<b)             k=a;         else             k=b;         for(i=k;i>=1;--i)             if(a%i==0 && b%i==0)                 break;         cout<<(a*b)/(i*i)<<"\n";              }     return 0; } 
#include <iostream> #define mod 1000000007 using namespace std;     int main() { 	long int t,n; 	long long int a,b,c,d,k; 	cin>>t; 	while(t--){ 	    k=0; 	    cin>>n; 	    cin>>a; 	    a=(2*a)%mod; 	    c=2; 	    for(long int i=0;i<n;i++){ 	        cin>>b; 	        k=(k*2+a*b)%mod; 	        a=(a+b*c)%mod; 	        c=(c*2)%mod; 	    } 	    cout<<k<<endl; 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; int min(int a,int b) {     return (a<b)?a:b; } int dist(int ax,int ay, int bx, int by) {     return min((abs(bx-ax)),(abs(by-ay))); } int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 	    int n,x,y,ans=0; 	    scanf("%d",&n); 	    for(int i=1;i<=n;i++) { 	        scanf("%d %d",&x,&y); 	        ans=ans^i; 	    } 	    printf("%d\n",ans); 	} 	return 0; } 
#include <iostream> #include <stdio.h> #include <math.h> #include <algorithm> using namespace std; int main() {     int t;     scanf("%i",&t);     while(t--)     {         int n,k,a[10000];         float c=0;         scanf("%i%i",&n,&k);         for(int i=0;i<n;i++)             scanf("%i",&a[i]);         sort(a,a+n);         //for(int i=0;i<n;i++)            // printf("%i ",a[i]);         for(int i=k;i<(n-k);i++)         {             c+=(float)a[i];         }         c=c/(n-2*k);         printf("%f\n",c);     } 	return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { int t,n,i; scanf("%d",&t); while(t--) { scanf("%d",&n); int a[n]; for(i=0;i<n;i++) scanf("%d",&a[i]); sort(a,a+n); printf("%d\n",a[0]+a[1]); } return 0; } 
#include <iostream> #include<cmath> using namespace std; int main() {     double a,b,t;     cin>>t;     for(int i=0;i<t;i++)     {         cin>>a>>b;         cout<<sqrt(pow(b,2)-pow(a,2))<<" "<<hypot(a,b)<<endl;     }     return 0; }
#include <iostream> using namespace std; int palindrome (int n) { int b=n; int a=n; int v=1; int c=0; while(b>0) { b=b/10; c++; } int d[c]; c=0; while(n>0) { c++; d[c]=n%10; n=n/10; } for(int i=1;i<=c/2;i++) { if(d[i]!=d[c-i+1]) {v=0; i=c;} } return v; } int main() { int a[100000]; for(int i=2;i<=100000;i++) { a[1]=1; if(palindrome(i)) a[i]=a[i-1]+i; else a[i]=a[i-1]; } int t; cin>>t; for(int i=0;i<t;i++) { int l,r,k; cin>>l>>r; k=a[r]-a[l-1]; cout<<k<<endl; } 	return 0; }
#include<stdio.h> /*gcc C,Turbo C*/ int main() { long int a; scanf("%ld",&a); printf("%ld",a); return 0; }
#include<bits/stdc++.h> using namespace std; int main() { 	int T,n,A[1001],i,j,k,a=1,count=0; 	 	cin>>T; 	while(T--) 	{ 		cin>>n; 		a=1; 		count=0; 		int op=0; 		int x[1001]={0}; 		for(i=0;i<n;i++) 		{ 			cin>>A[i]; 			x[A[i]]++; 		} 		 		for(i=1000;i>0 && count<2;i--)		 		{ 			if(x[i]>3 && op==0) 			{ 				a*=i*i; 				count=2; 			} 			else if(x[i]>1) 			{ 				a*=i; 				count++; 				op=1; 			} 		} 		if(count==2) 		cout<<a<<endl; 		else 		cout<<"-1\n"; 	} 	return 0; }
#include<bits/stdc++.h> using namespace std;  int main() { 	long long int i,j,k,m,n,t; 	string a,b; 	cin>>t; 	while(t--) 	{ 		cin>>a; 		cin>>b; 		 		int f=a.length(); 		int g=b.length(); 		int count1[27]={0}; 		for(i=0;i<f;i++) 		{ 			count1[a[i]-'a']=1; 		} 		for(i=0;i<g;i++) 		{ 			if(count1[b[i]-'a']==1) 			{ 				cout<<"Yes"<<endl; 				break; 			} 			else 			{ 				if(i==g-1) 				{ 					cout<<"No"<<endl; 					break; 				} 			} 		} 		 		 		 	} 	 	 	 	 	 	 	 	 	 	return 0; }
#include <iostream> #include <algorithm>  using namespace std;  int tn, current_element, previous_element, max_good_suffix, n;  int main(int argc, const char * argv[]) {     ios_base::sync_with_stdio(false);     cin >> tn;     while (tn--) {         long long answer = 0;         cin >> n;         for(int i = 0; i < n; i++) {             cin >> current_element;             if (i == 0)                 max_good_suffix = 1;             else                 if (current_element >= previous_element)                     ++max_good_suffix;                 else                     max_good_suffix = 1;             answer += max_good_suffix;             previous_element = current_element;         }         cout << answer << endl;     }     return 0; }
#include <iostream> using namespace std;  const int maxn = 110; int ar[maxn][maxn];  int main() { 	int t; cin >> t; 	while (t--) { 	    int n; cin >> n;         for (int i = 1; i <= n; ++i)             for (int j = 1; j <= i; ++j)                 cin >> ar[i][j];         for (int i = n - 1; i >= 1; --i) {             for (int j = 1; j <= i; ++j) {                 ar[i][j] += max(ar[i + 1][j], ar[i + 1][j + 1]);             }         }         cout << ar[1][1] << endl; 	} 	return 0; } 
#include <iostream>  using namespace std;  int main() { 	int n;  	while(true) { 		cin>>n; 		if(n==42) break; 		cout<<n<<"\n"; 	}  	return 0; } 
#include<iostream> #include<stdlib.h> using namespace std; long int i,n,p1,p2,val,w1,x,y; int main() { 	x=0,y=0; 	cin>>n; 	long int max=0; 	for(i=0;i<n;i++) 	{ 		cin>>p1>>p2; 		x=x+p1; 		y=y+p2; 		val=abs(x-y); 		if(val>max) 		{ 			max=val; 			if(x>y) 				w1=1; 			else 				w1=2; 		} 	} 	cout<<w1<<" "<<max; }
#include <iostream>  using namespace std;  int main() {     int t;     long unsigned n,i;     cin>>t;     while(t)     {         i=1;         cin>>n;         while(i*(i+1)<=2*n)             i++;         cout<<i-1<<endl;         t--;     }     return 0; }
#include<bits/stdc++.h> using namespace std;  typedef long long int ll;  void solve() { 	ll N; 	cin>>N; 	N/=2; 	cout<<(N*(N-1))/2<<endl; }  int main() { 	int T; 	scanf("%d",&T); 	while(T--){ 		solve(); 	} 	return 0; } 
#include<iostream>  #include<stdio.h>  #include<stdlib.h>  #include<algorithm>  using namespace std;  int main()  {  	long int t;  	cin>>t;  	int a[t];  	for(long int i=0;i<t;i++)  	{  		cin>>a[i];  	}  	sort(a,a+t);  	for(long int i=0;i<t;i++)  	cout<<a[i]<<endl;  	return 0;  }     
#include <stdio.h> #include <string.h> #include <stdlib.h> #include <math.h>   int f(char *s,char *s1) { 	int i,flag=1; 	for(i=0;s[i]!='\0';i++) 	{ 		if(((s[i]==s1[i])&&(s[i]>='a' && s1[i]<='z')) || ((s[i]!=s1[i])&&(s[i]=='?'||s1[i]=='?'))||((s[i]==s1[i])&&(s[i]=='?'))) 		{ 		    flag = 1; 		} 		else 		{ 		    flag = 0; 		    break; 		} 	} 	if(flag) 		printf("Yes\n"); 	else         	printf("No\n");		 }   int main() { 	char s[100],a[100]; 	int t,c;   	scanf("%d",&t); 	while(t--) 	{ 		scanf("%s",&s); 		scanf("%s",&a); 		f(s,a); 	} 	 	return 0; } 
# include<iostream> using namespace std; int main() { 	int t,m,k,n,i,c,d; 	cin>>t; 	while(t--) 	{ 		cin>>n>>m>>k; 		int a[102]={0},x; 		while(m--) 		{ 			cin>>x; 			a[x]++; 		} 		while(k--) 		{ 			cin>>x; 			a[x]++; 		} 		c=0; 		d=0; 		for(i=0;i<=n;i++) 		{ 			if(a[i]==2) 				c++; 			else if(a[i]==1) 				d++; 		} 		cout<<c<<" "<<n-(c+d)<<endl; 	} 	return 0; }
#include<cstdio> #ifndef ONLINE_JUDGE #define gc getchar #endif   #include<iostream>   using namespace std;   int main(){     int T;     scanf("%d",&T); 	//T=readInt();    while(T--){       int N;        scanf("%d",&N);       //N=readInt();       char Q[N+1];       char C[N+1];       scanf("%s",Q);       scanf("%s",C);       int W[N+1];       for(int i=0;i<=N;++i){         scanf("%d",&W[i]); 			//W[i]=readInt();       }       int max=0;       for(int i=0;i<N;++i){         if(C[i]==Q[i]){           max++;         }       }       int max_W=0;       if(max!=N) 		for(int i=0;i<=max;++i){           if(max_W<W[i]){             max_W=W[i];           }         }         else           max_W=W[N];           printf("%d\n",max_W);         } }  
#include <iostream>  main() { int a[65], b[65], fall, t, i, j, k;  std::cin >> fall; while(fall--) 	{ 	for(t=1; t<=64; std::cin >> a[t++]); 	for(i=k=1, b[0]=i, j=a[1]; i<64; i=i+j, j=a[i], b[k++]=i); 	for(t=0; t<k-1; std::cout << b[t++] << " "); 	std::cout << "64" << std::endl; 	} return 0; } 
#include <iostream> #include <string.h>  using namespace std;  main() { int fall, a[110], b[510], c[510], f, bb, i, k, j, n, h; char s[510];  a['Z']=1; a['U']=9; a['T']=7; a['Q']=3; a['E']=5;  for(cin >> fall; fall--;) 	{ 	cin >> s; 	n=strlen(s); 	f=bb=i=k=0;  	while((!(s[i]>='0' && s[i]<='9'))&&i<n) 		f+=a[s[i++]];  	c[k]=s[i++]-48; 	h=1;  	while(i<n) 		{ 		while((!(s[i]>='0' && s[i]<='9'))&&i<n) 			bb+=a[s[i++]]; 		b[k++]=f-bb; 		h=0; 		 		if(s[i]!='\0') 			{ 			c[k]=s[i++]-48; 			h=1; 			f=bb; 			bb=0; 			} 		}  	if(h) 		b[k++]=f;  	for(i=0; i<k-1; i++) 		for(j=i+1; j<k; j++) 			if(b[i]>=b[j]) 				{ 				f=b[i]; 				b[i]=b[j]; 				b[j]=f; 				f=c[i]; 				c[i]=c[j]; 				c[j]=f; 				}  	for(i=0; i<k; i++) 		cout << c[i]; 	cout << endl;  	}  return 0; } 
#include <iostream>   int main() { int fall, a[10][10], c=64, b[100], i, j, d[10], k, j1, i1, x, y, e[100];  for(i=0; i<8; i++) 	{ 	for(j=0; j<8; a[i][j++]=c--); 	for(j=7, i++; j>=0; a[i][j--]=c--); 	}  for(std::cin >> fall; fall--; std::cout << std::endl) 	{ 	for(i=0; i<=65; b[i]=e[i]=0, i++); 	for(i=0; i<8; std::cin >> d[i], e[d[i++]]=1);  	for(k=0; k<8;) 		{ 		for(i=0; i<8; i++) 			{ 			for(j=0; j<8 && a[i][j]!=d[k]; j++); 			if(j<8) 				break; 			}  		for(i1=i-1, x=14; i1>=0; y=a[i1][j], b[y]+=x*(e[y]!=1), x-=2, i1--); 		for(i1=i+1, x=14; i1<8; y=a[i1][j], b[y]+=x*(e[y]!=1), x-=2, i1++); 		for(j1=j-1, x=14; j1>=0; y=a[i][j1], b[a[i][j1]]+=x*(e[y]!=1), x-=2, j1--); 		for(j1=j+1, x=14; j1<8; y=a[i][j1], b[a[i][j1]]+=x*(e[y]!=1), x-=2, j1++); 		for(x=7, i1=i-1, j1=j-1; i1>=0 && j1>=0; y=a[i1][j1], b[a[i1][j1]]+=x*(e[y]!=1), x--, i1--, j1--); 		for(x=7, i1=i-1, j1=j+1; i1>=0 && j1<8; y=a[i1][j1], b[a[i1][j1]]+=x*(e[y]!=1), x--, i1--, j1++); 		for(x=7, i1=i+1, j1=j-1; i1<8 && j1>=0; y=a[i1][j1], b[a[i1][j1]]+=x*(e[y]!=1), x--, i1++, j1--); 		for(x=7, i1=i+1, j1=j+1; i1<8 && j1<8; y=a[i1][j1], b[a[i1][j1]]+=x*(e[y]!=1), x--, i1++, j1++); 		k++; 		}  	for(i=-(x=-1); i<=64; i++) 		if((b[i]>x)||(x==-1)) 			x=b[i];  	for(i=1; i<=64; i++) 		if(b[i]==x) 			std::cout << i << " "; 	}  return 0; } 
#include <cstdio> #include <vector> using namespace std; // 0110100110010110 // 0 - 0 // 1 - 1 // 01 - 0 // 10 - 2 // 010 - 3 // 101 - 2 // 0101 - 10 // 1010 - 2   int p[4][2] = { {0,1}, {0,2}, {3,2}, {10,2} };   vector<vector<int> > s; int code; bool insert(int i, int val) {     s[i].push_back(val);     int t = s[i].size();     if(i<s.size()-1)     {         if((t+(code>>i))&1)             return insert(i+1,val);         return (val==s[i+1].back());     }     if(t>1 && s[i][t-1]==s[i][t-2])     {         s.push_back(vector<int>());         if(t%2==0)             code |= 1<<i;         for(int j=0;j<t-1;j+=2)             if(insert(i+1, s[i][j] == (t&1)))                 return true;         return insert(i+1,val);     }     return false; } void tst() {     int n;     scanf("%d",&n);     s.clear();     code = 0;     bool wrong = false;     s.push_back(vector<int>());     for(int it=0;it<n;it++)     {         int x;         scanf("%d",&x);         if(wrong)         {             printf("-1 ");             continue;         }                  wrong = insert(0, x);           if(s.back().size()>4)             wrong = true;           if(wrong)         {             printf("-1 ");         }         else         {             printf("%d ",code + (p[s.back().size()-1][s.back()[0]]<<(s.size()-1)));         }     }     puts(""); }   int main() {     int t;     scanf("%d",&t);     for(;t--;)         tst(); }  
#include<bits/stdc++.h> using namespace std;  const int N=123; int a[N][N], c[N], r[N];  int main() {     int n, m;     scanf("%d %d", &n, &m);     for(int i=0;i<n;i++) {         for(int j=0;j<m;j++) {             scanf("%d", &a[i][j]);             if(a[i][j]) {                 r[i]=1;                 c[j]=1;             }         }     }     bool ok=true;     for(int i=0;i<n;i++) {         for(int j=0;j<m;j++) {             if(r[i] && c[j] && a[i][j]==0) {                 ok=false;                 break;             }         }         if(ok) break;     }     puts(ok?"YES":"NO"); } 
#include<cstdio> #include<math.h> using namespace std; int prime(long long n) {  long long i;  for(i=2;i<=sqrt(n);i++)   if(n%i==0)   return 1;  return 0; } int main() { long long T,a,b,i;  scanf("%lld",&T); while(T--) {  scanf("%lld %lld",&a,&b);  for(i=b;i>=a;i--)   if(prime(i))   {printf("%lld\n",i);i=0;}  if(i==a-1)printf("-1\n"); } return 0; }
#include<stdio.h> #include<iostream> using namespace std; #include<vector> #include<queue> vector < vector<int> > v; void process(int x1,int y1,int r,int c){     int xx,yy;     queue<int> qx;     queue<int> qy;     qx.push(x1);qy.push(y1);     while(!qx.empty()){         xx=qx.front();yy=qy.front();         qx.pop();qy.pop();         v[xx][yy]++;         if(v[xx][yy]>3){             v[xx][yy]=0;             if(yy>=1){qx.push(xx);qy.push(yy-1);}             if(yy<=c-2){qx.push(xx);qy.push(yy+1);}             if(xx>=1){qx.push(xx-1);qy.push(yy);}             if(xx<=r-2){qx.push(xx+1);qy.push(yy);}         }     } } int main(){     int t,r,c,aa,i,j,q;     cin>>t;     while(t--){         cin>>r>>c;         v.resize(r);         for(i=0;i<r;i++)             v[i].resize(c);         for(i=0;i<r;i++){             for(j=0;j<c;j++){                 cin>>aa;                 v[i][j]=aa;             }         }         cin>>q;         int x1,y1;         while(q--){             cin>>x1>>y1;             process(x1,y1,r,c);         }         for(i=0;i<r;i++){             for(j=0;j<c;j++){                 cout<<v[i][j]<<" ";             }             cout<<endl;         }     }     return 0; } 
#include <vector> #include <list> #include <map> #include <set> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <string.h> #include <string> #include <queue> #include <iterator>   using namespace std;   #define F(i,start,n) for(int i=start;i<n;i++) #define sz(a) int((a).size())  #define P_B push_back #define mp make_pair  #define all(c) (c).begin(),(c).end()  #define trav(c,i) for( typeof((c).begin()) i = (c).begin() ; i != (c).end() ; i++ )  #define present(c,x) ((c).find(x) != (c).end())  #define cpresent(c,x) (find(all(c),x) != (c).end())   template<class T>string ToString(T t){stringstream s;s<<t;return s.str();} template<class T>void ToOther(T& t,string a){stringstream s(a);s>>t;}   int R,C,W;  char GRID[20][20][20]; int coinsL[20][20][20]; int states[20][20][20][1<<12]; bool visited[20][20][20][1<<12]; int dr[] = {1,-1,0,0}; int dc[] = {0,0,1,-1};     bool isWorldsafe(int w) { 	return w>=0 && w<W; }   bool isBound(int w,int x,int y) { 	return isWorldsafe(w) && x>=0 && x<R && y>=0 && y<C; }    int search(int ws,int SX,int SY,int TC) {   	queue<pair< int,pair< int,pair< int,int > > > > Q; 	 	Q.push(mp(ws,mp(SX,mp(SY,0)))); 	 	while( !Q.empty() ) { 		 		int world = Q.front().first; 		int x = Q.front().second.first; 		int y = Q.front().second.second.first; 		int coins = Q.front().second.second.second; 		Q.pop(); 		 		if( GRID[world][x][y] == 'M' ) { 			 			if( ((1<<(TC))-1) == coins ) { 				 				return states[world][x][y][coins]; 			 			} 		 			continue; 		 		} 			 		if( !isBound(world,x,y) || GRID[world][x][y]=='#' || visited[world][x][y][coins] ) { 			continue; 		} 		 		int newWorld = world , xx , yy , newCoins = coins; 		 		visited[world][x][y][coins] = true; 		 		if( GRID[world][x][y] == 'U' ) { 	 			newWorld = world-1; 			 			if( isWorldsafe(newWorld) && GRID[newWorld][x][y]!='#' ) { 			 					Q.push(mp(newWorld,mp(x,mp(y,newCoins)))); 					states[newWorld][x][y][newCoins] = states[world][x][y][coins]; 			 			} 	 			continue; 	 		} 		 		if( GRID[world][x][y] == 'D' ) { 		 			newWorld = world+1; 		 			if( isWorldsafe(newWorld) && GRID[newWorld][x][y]!='#' ) { 		 					Q.push(mp(newWorld,mp(x,mp(y,newCoins)))); 					states[newWorld][x][y][newCoins] = states[world][x][y][coins]; 	 			} 	 			continue; 	 		} 		 		if( GRID[world][x][y] == 'C' ) {	 		 			newCoins = ((coins)|(1<<(coinsL[world][x][y]-1))); 			 		} 		 		for(int i=0;i<4;i++) { 		 			xx = x+dr[i]; 			yy = y+dc[i]; 			 			if( isBound(newWorld,xx,yy) ) { 			 				Q.push(mp(newWorld,mp(xx,mp(yy,newCoins)))); 				states[newWorld][xx][yy][newCoins] = states[world][x][y][coins]+1; 			 			} 		 		} 	 	}   return -1; }   int main( int argc , char** argv ) { 	 	cin >> R >> C >> W ; 	  	while(R>0 && C>0 && W>0) { 		 		memset(states,0,sizeof(states)); 		memset(visited,false,sizeof(visited)); 		memset(coinsL,0,sizeof(coinsL)); 	 		for(int i=0;i<W;i++) {	 			for(int j=0;j<R;j++) { 				scanf("%s",GRID[i][j]); 			} 		} 	 		int count = 0,pos=1; 		int ws,SX,SY; 	 		for(int i=0;i<W;i++) { 			for(int j=0;j<R;j++) { 				for(int k=0;k<C;k++) { 					if(GRID[i][j][k]=='C') { 						count++; 						coinsL[i][j][k] = pos; 						pos++; 					} 					if(GRID[i][j][k]=='S') { 						ws = i; 						SX = j; 						SY = k; 					} 				} 			} 		} 	 		 		int res = search(ws,SX,SY,count); 	 		if( res != -1 )  			printf("Mario saved the princess in %d steps\n",res); 		else 	 			printf("Mario failed to save princess\n");					 	 	 		cin >> R >> C >> W ; 				 	} 	 return 0;   }  
#include <iostream> #include <cmath> #include <stdio.h>  #define MOD 1000000007 typedef long long ll; typedef long long unsigned ull; typedef long double ld; typedef unsigned short us; typedef unsigned int uint; typedef unsigned char uchar;  using namespace std;  void multiply(long long int F[4][4],long long int M[4][4]);  void power(long long int F[4][4],long long int n);  long long int fib(long long int n) {   long long int F[4][4] = {{4,1,0,1},{0,3,2,0},{0,1,0,0},{0,0,0,1}};   if (n == 0)     return 1;   else if(n==1)     return 7;   else if(n==2)     return 35;  // else if(n==3)  //   return 159;   power(F, n-1);   return (F[0][0]+F[0][1]+F[0][2]+F[0][3]*2)%MOD; }  /* Optimized version of power() in method 4 */ void power(long long int F[4][4],long long int n) {   if( n == 0 || n == 1)       return;   long long int M[4][4] = {{4,1,0,1},{0,3,2,0},{0,1,0,0},{0,0,0,1}};    power(F, n/2);   multiply(F, F);    if (n%2 != 0)      multiply(F, M); }  void multiply(long long int F[4][4],long long int M[4][4]) {     int i,j;     long long c[4][4];     for(i=0;i<4;i++){         for(j=0;j<4;j++){             c[i][j]=0;             for(int k=0;k<4;k++){                 c[i][j]=(c[i][j]+(F[i][k]*M[k][j])%MOD)%MOD;             }         }     }     for(i=0;i<4;i++){         for(j=0;j<4;j++){             F[i][j]=c[i][j];         }     } }  long long modpow(long long base, long long exp,long long modulus) {   base %= modulus;   long long result = 1;   while (exp > 0) {     if (exp & 1) result = (result * base) % modulus;     base = (base * base) % modulus;     exp >>= 1;   }   return result; }  uint inp() {   uint n;   int c;   while( (c = getchar()) < '0') {     ;   }   n = c - '0';   while( (c = getchar()) >= '0')     n = n * 10 + (c - '0');   return n; }  void pt(uint n) {   uchar stack[30];   int top = 0;   if(n == 0) {     putchar('0');   } else {     while(n > 0) {       stack[top++] = n % 10 + '0';       n /= 10;     }     while(top > 0) {       putchar(stack[--top]);     }   }   putchar('\n'); } long long a[10000005]; /* Driver program to test above function */ int main() {   long long n,m,ans;   int i,t,z;   t=inp();   while(t--){     n=inp();     if(n==0)         printf("1\n");     else if(n==1)         printf("7\n");     else if(n==2)         printf("35\n");     if(n>2){         ans=(fib(n+1))%MOD;         z=ans;         pt(z);     }   }   return 0; } 
#include<iostream> #include<vector> using namespace std; int main() { 	long long int t,n,num,a; 	cin>>t; 	while(t--) 	{ 		cin>>n; 		vector<int> ss; 		num=1; 		while(n) 		{ 			ss.push_back(n%2); 			n=n/2; 			 		} 		 	    num=1; 	    a=0; 	    for(int i=0;i<ss.size();i++) 	    { 	    	if((i+1)%2) 	    	a=a+num*ss[i]; 	    	num=num*2; 	    	 	    } 		cout<<a<<endl; 	} }
#include<vector> #include<cstring> #include<algorithm> #include<stdio.h> #include<climits> #include<set> #include<fstream> #include<cmath> #include<bitset> #include<map> #include<stack> #include<fstream> #include<iostream> #include<queue> #define test(t) while(t--) #define s(n) scanf("%d",&n) #define sl(n) scanf("%lld",&n)  #define p(n) printf("%lld\n",n) #define rep(i,a,n) for(i=a;i<=n;i++) #define vi vector<int> #define vii vector< vector<int> > #define vpii vector< pair<int,int> > #define mii map<int,int> #define pb push_back #define inf 1000000000LL #define mp make_pair  #define N 100014 //#define inf 100000000 #define ll  long long using namespace std;  ll mod =1000000007; double eps = 1e-9; ll powmod(ll a,ll b) {    ll res = 1;    while(b>0)    {      if(b&1)         res = (res*a)%mod;         a=(a*a)%mod;         b/=2;    }    return res; } ll minverse(ll a) {   if(a==0)     return 1LL;   else    return powmod(a,mod-2); }  pair<double,double>po[2001]; int n; double calc(double vv) {   double ans = 0.0;   for(int i=0;i<n;++i)     ans=  ans + sqrt((po[i].first-vv)*(po[i].first-vv)+(po[i].second-vv)*(po[i].second-vv));   return ans; } int main() {    int t,i,j;   double ans ;   cin>>t;   while(t--)   {     s(n);       for(i=0;i<n;++i)         scanf("%lf%lf",&po[i].first,&po[i].second);     double lo = -10000.0;     double hi = 10000.0;     int ct = 0;     while(hi-lo>eps)     {         ct ++;        double v1 = lo + (hi-lo)/3.0;        double v2 = lo + 2*(hi-lo)/3.0;        double t1 = calc(v1);        double t2 = calc(v2);         if(t1-t2>=0.0)             lo = v1;         else             hi = v2;     }     //cout<<ct<<endl;     printf("%0.6lf %0.6lf\n",lo,lo);   } return 0; } 
#include <iostream> #include<map> using namespace std; long long fact(long long n) { 	long long f=1; 	for(int i=2;i<=n;i++) 		f*=i; 	return f; } 	 int main() { 	// your code goes here 	long long t; 	cin>>t; 	while(t--) 	{ 		string s; 		cin>>s; 		long long c=0; 		int h[27]={0}; 		for(int i=0;i<s.length();i++) 			h[s[i]-'a']+=1; 		for(int i=0;i<26;i++) 		{ 			if(h[i]&1) 				c+=1; 		} 		if(c>1) 			cout<<"-1\n"; 		else 		{ 			long long ct=1; 			long long ans=fact(s.length()/2); 			for(int i=0;i<26;i++) 			{ 				if(h[i]>1) 					ans/=(long long)fact(h[i]/2); 				 			} 			cout<<ans<<endl; 		 		} 	} 	return 0; }
#include<bits/stdc++.h> #include<algorithm> #include<vector> #include<queue> //int dx[]={1,1,0,-1,-1,-1,0,1};int dy[]={0,1,1,1,0,-1,-1,-1};//8 direction //int dx[]={2,1,-1,-2,-2,-1,1,2};int dy[]={1,2,2,1,-1,-2,-2,-1};//Knight Direction int dx[]={0,1,0,-1};int dy[]={1,0,-1,0}; //4 direction #define REP(i,n) for(int i=0;i<n;i++) #define REPU(i,a,b) for(int i=a;i<b;i++) #define sll(n) scanf("%lld",&n) #define si(n) scanf("%d",&n) #define pi(n) printf("%d",n) #define sl(n) scanf("%ld",&n) #define pin(n) printf("%d\n",n) #define MP make_pair #define PB push_back #define all(a) a.begin(),a.end() #define F first #define S second #define SET(a,b) memset(a,b,sizeof (a)) typedef long long LL; #define PII pair<int,int> using namespace std; int n,m; char a[505][505]; int vis[505][505]; LL dfs(int x,int y) {     LL ans=1;     vis[x][y]=1;     for(int i=0;i<4;i++)     {         int xx=x+dx[i];         int yy=y+dy[i];         if(xx>=0 && xx<n && yy>=0 && yy<m && a[xx][yy]=='*' && vis[xx][yy]==0)         {             ans=max(ans,dfs(xx,yy)+1);         }     }     vis[x][y]=0;     return ans; } int main() {     si(n); si(m);     REP(i,n) cin>>a[i];     LL ans=0;     for(int i=0;i<n;i++)     {         for(int j=0;j<m;j++)         {             if(a[i][j]=='*')             {                 ans=max(ans,dfs(i,j));             }         }     }     cout<<ans<<endl;     return 0; } 
#include <iostream> using namespace std;  int main() { 	int t,x,y,n,i; 	cin>>t; 	while(t--) 	{int a[100]={0},b[100]={0}; 	cin>>n; 	for(i=0;i<n;i++) 	{cin>>x>>y;a[x]++;b[y]++;}x=y=0; 	for(i=0;i<100;i++) 	{ 	if(a[i])x++; 	if(b[i])y++; 	} 	if(x>y) 	cout<<y<<endl; 	else cout<<x<<endl; 	} 	return 0; }
#include <iostream> using namespace std;  int main() { 	// your code goes here 	int t; 	cin>>t; 	while(t--) 	{ 		long long s,w,q,p,t; 		cin>>s>>w>>q>>p>>t; 		if((s+w+q+p)<=t) 			cout<<"YES\n"; 		else 			cout<<"NO\n"; 	} 	return 0; }
#include <bits/stdc++.h>  using namespace std;  #define FOR(i,a,b) 	for(int i=(a);i<(b);i++) #define SZ(x) 		((int)(x).size()) #define FORV(i,x)	FOR(i,0,SZ(x)) #define FORD(i,a,b) for(int i=(a);i>=(b);i--) #define MP 			make_pair #define PB 			push_back #define ALL(x) 		x.begin(),x.end() #define ULL 		unsigned long long #define LL 			long long #define mset(x,v) 	memset(x,v,sizeof x) #define F 			first #define S 			second #define si(n) 		scanf("%d",&n) #define sc(n) 		scanf("%c",&n) #define sll(n) 		scanf("%lli",&n) #define sf(n) 		scanf("%f",&n) #define ss(n) 		scanf("%s",n) #define MOD         1000000007  pair<int,int> pos[250010];  int main() { 	int t,p,x,a; 	si(t); 	while(t--) 	{ 		cin>>p>>x; 		FOR(i,0,p) 		FOR(j,0,p) 		{ 			si(a); 			pos[a]=MP(i,j);	 		} 		int l=1,r=p*p; 		bool f=1; 		while(l<r) 		{ 			x-=(abs(pos[l].F-pos[r].F)+abs(pos[l].S-pos[r].S)); 			if(f) l++; else r--; 			f=!f; 		} 		if(x>=0)  printf("ALIVE\n"); else printf("DEAD\n"); 	} 	return 0; } 
#include <bits/stdc++.h>  using namespace std;  int main() {     int t,sha,ank,i,len;     string s;     cin>>t;     while(t--)     {         int alp[26]={0};         sha=0;         ank=0;         cin>>s;         len=s.length();         for(i=0;i<len;i++)             alp[s[i]-97]++;         for(i=0;i<len;i++)         {             if(alp[s[i]-97]==1)             {                 sha=s[i];                 break;             }         }         for(i=len-1;i>=0;i--)         {             if(alp[s[i]-97]==1)             {                 ank=s[i];                 break;             }         }         if(sha>ank)             cout<<"SHANKY"<<endl;         else             if(sha<ank)                 cout<<"ANKU"<<endl;         else             cout<<"PANDEY"<<endl;      }     return 0; } 
#include<iostream> using namespace std; int main() { 	int t; 	cin>>t; 	for(int i=0;i<t;i++) 	{ 		int n; 		cin>>n; 		if(n>0) 		{ 			cout<<n<<endl; 		} 		else  		cout<<n*(-1)<<endl; 	} } 
#include<iostream> #include<cstring> using namespace std; int main() { 	int t; 	string s; 	cin>>t; 	for(int k=1;k<=t;k++) 	{ 		cin>>s; 		int l=s.length(); 		char temp=s[l-1]; 		int end=l-1; 		int ans=0; 		int beg; 		for(int i=end-1;i>=0;i--) 		{ 			if(s[i]==temp) 			{ 				beg=i; 				while(s[beg]==s[end]) 				{ 					beg--; 					end--; 				} 				if(beg==-1) 				ans=max(ans,l-1-end); 				end=l-1; 			} 		} 		if(ans==0) 		cout<<"Case "<<k<<": -1"<<endl; 		else 		cout<<"Case "<<k<<": "<<ans<<endl; 		 	} }
#include<bits/stdc++.h> using namespace std;   int main() {     int t;     scanf("%d",&t);     while(t--)     {         int n;         scanf("%d",&n);         int a[n];         int c[n+1];         for(int i=0;i<n;i++)             scanf("%d",&a[i]);         if(n==1 || n==2)         {             printf("%d\n",n);             continue;         }         c[0]=c[1]=c[n]=0;         int maxx=-1;         c[1]=2;         for(int i = 2;i<n;i++)         {             if(a[i]==a[i-1]+a[i-2])                 c[i]=max(c[i-1]+1,3);             else                 c[i]=2;                 maxx=max(maxx,c[i]);         }           printf("%d\n",maxx);     } }  
#include<iostream> #include<algorithm> #include<stack> #include<string> #include<queue> #include<stdlib.h> #include<vector> #include<cmath> #define pb push_back #define big long long #define FOR(i,a,b) for(i=a;i<=b;i++) #define RFOR(i,a,b) for(i=a;i>=b;i--) #define vi vector<int> #define vb vector<big> using namespace std; int main() { 	big l,t,n,i,j,k,temp,c,count; 	vb v; 	cin>>t; 	while(t-->0)     {         count=0;         cin>>n>>k;         FOR(i,0,n-1)         {             cin>>temp;             if(temp>=k) count++;         }         cout<<count<<endl;     }      	return 0; }
#include<bits/stdc++.h> using namespace std; #define fs first #define sc second #define p 1000000007 #define pb push_back #define mp make_pair typedef long long Int; typedef pair<Int,Int> pii; typedef vector<Int> vi; typedef vector<pii> vii;  //segment trees struct node {     Int val;     Int left;     Int right; }; struct node Tree[400000]; struct node Tree2[400000]; void merge(Int a) {     Tree[a].val=Tree[2*a].val+Tree[2*a+1].val;     Tree[a].left=Tree[2*a].left;     Tree[a].right=Tree[2*a+1].right; }  void update(Int curr,Int i,Int v)  {      if (Tree[curr].left==Tree[curr].right&&Tree[curr].left==i)         Tree[curr].val+=v;      else if (Tree[curr].left<=i&&Tree[curr].right>=i)      {          Tree[curr].val+=v;          update(2*curr,i,v);          update(2*curr+1,i,v);      }  } void buildtree(Int curr,Int L,Int R) {     if (L>R)         return;     else if (L==R)     {         Tree[curr].val=0;         Tree[curr].left=L;         Tree[curr].right=R;     }     else     {         Int mid=L+(R-L)/2;//to avoid overflow         buildtree(2*curr,L,mid);         buildtree(2*curr+1,mid+1,R);         merge(curr);     } } Int query(Int curr,Int L,Int R) {     if (Tree[curr].left>=L&&Tree[curr].right<=R)         return Tree[curr].val;     else if (Tree[curr].right<L||Tree[curr].left>R)         return 0;     else         return query(2*curr,L,R)+query(2*curr+1,L,R); } //second tree void merge2(Int a) {     Tree2[a].val=Tree2[2*a].val+Tree2[2*a+1].val;     Tree2[a].left=Tree2[2*a].left;     Tree2[a].right=Tree2[2*a+1].right; }  void update2(Int curr,Int i,Int v)  {      if (Tree2[curr].left==Tree2[curr].right&&Tree2[curr].left==i)         Tree2[curr].val+=v;      else if (Tree2[curr].left<=i&&Tree2[curr].right>=i)      {          Tree2[curr].val+=v;          update2(2*curr,i,v);          update2(2*curr+1,i,v);      }  } void buildtree2(Int curr,Int L,Int R) {     if (L>R)         return;     else if (L==R)     {         Tree2[curr].val=0;         Tree2[curr].left=L;         Tree2[curr].right=R;     }     else     {         Int mid=L+(R-L)/2;//to avoid overflow         buildtree2(2*curr,L,mid);         buildtree2(2*curr+1,mid+1,R);         merge2(curr);     } } Int query2(Int curr,Int L,Int R) {     if (Tree2[curr].left>=L&&Tree2[curr].right<=R)         return Tree2[curr].val;     else if (Tree2[curr].right<L||Tree2[curr].left>R)         return 0;     else         return query2(2*curr,L,R)+query2(2*curr+1,L,R); } //ends here  vi G[100005]; Int tim; Int in[100005]; Int out[100005]; Int level[100005]; pii Query[100005]; void initialise() {     for (Int i=0;i<100004;++i)     {         tim=-1;         G[i].clear();     }     buildtree(1,0,100003);     buildtree2(1,0,100003);     update2(1,0,1); } void dfs(Int src) {     in[src]=++tim;     for (Int i=0;i<G[src].size();++i)     {         level[G[src][i]]=level[src]+1;         dfs(G[src][i]);     }     out[src]=tim; } int main() {     Int T;     cin>>T;     while (T--)     {         initialise();         Int M,type,V,N=0;         cin>>M;         for (Int i=0;i<M;++i)         {             cin>>Query[i].fs>>Query[i].sc;             if (Query[i].fs==0)             {                 ++N;                 G[Query[i].sc].pb(N);             }         }         level[0]=0;         dfs(0);         Int temp=0;         for (Int i=0;i<M;++i)         {             if (Query[i].fs==0)             {                 ++temp;                 if (level[temp]%2==1)                     update(1,in[temp],1);                 else                     update2(1,in[temp],1);             }             else             {                 Int u=query(1,in[Query[i].sc],out[Query[i].sc]);//number of ones                 Int v=query2(1,in[Query[i].sc],out[Query[i].sc]);//number of zeroes                 u=u*(u-1)/2;                 v=v*(v-1)/2;                 cout<<u+v<<"\n";             }         }     }     return 0; } 
#define pb push_back #define max(a,b) a>b?a:b #define min(a,b) a<b?a:b #define ll long long #include <iostream> #include<bits/stdc++.h> using namespace std; int q,i,m,l,j,ans=0,k; char s[20010]; int dp[20010][510]; int main() { 	cin>>s; 	scanf("%d",&q); int	le=strlen(s); 	for(k=1;k<=q;k++) 	{ 		ans=0; 		scanf("%d%d",&m,&l); 		memset(dp,0,sizeof(dp)); 		for(i=1;i<=le;i++) 		{ 			dp[i][(s[i-1]-'0')%m]=1; 		} 		for(i=2;i<=le;i++) 		{ 			for(j=0;j<m;j++) 			{ 				dp[i][(j*10+(s[i-1]-'0'))%m]+=dp[i-1][j]; 			} 		} 		for(i=1;i<=le;i++) 		{ 			ans+=dp[i][l]; 		} 		printf("%d\n",ans); 	} 	// your code goes here 	return 0; }
#include<bits/stdc++.h> #define ll long long #define pb push_back #define mp make_pair #define MOD 1000000007 #define pii pair<int,int> #define sc scanf #define pf printf #define MAX 105 using namespace std;  struct cmp {     bool operator()(pii a ,pii b){         return a.second > b.second;     } };  ll modpow(ll base, ll exp, ll mod)  {   base %= mod;   ll result = 1;   while (exp > 0) {     if (exp & 1) result = (result * base) % mod;     base = (base * base) % mod;     exp >>= 1;   }   return result; }  ll num[MAX][MAX],fo[MAX][MAX],rev[MAX][MAX];  int main() { 	ios::sync_with_stdio(0); 	cin.tie(0); 	//freopen("C:/Users/HP/Desktop/codejam/1A_large_input.txt","r",stdin);//redirects standard input 	//freopen("C:/Users/HP/Desktop/codejam/1A_large_output.txt","w",stdout);//redirects standard output 	int t,n,m; 	cin>>t; 	while(t--) 	{ 		cin>>n>>m; 		for(int i=1; i<=n; i++) 		{ 			for(int j=1; j<=m; j++) 			{ 				cin>>num[i][j]; 			} 		} 		for(int i=0; i<=n; i++) 		{ 			num[i][0]=0; 			num[i][m+1]=0; 		} 		for(int i=0; i<=m+1; i++) 		{ 			num[0][i]=0; 		} 		for(int i=0; i<=n; i++) 		{ 			fo[i][0]=num[i][0]; 			rev[i][m]=num[i][m]; 			fo[i][1]=num[i][1]; 			rev[i][m+1]=num[i][m+1]; 		} 		for(int i=0; i<=m+1; i++) 		{ 			fo[0][i]=num[0][i]; 			rev[0][i]=num[0][i]; 		} 		for(int i=1; i<=n; i++) 		{ 			for(int j=1; j<=m; j++) 			{ 				fo[i][j]=fo[i-1][j-1]+num[i][j]; 			} 		} 		for(int i=1; i<=n; i++) 		{ 			for(int j=m; j>0; j--) 			{ 				rev[i][j]=rev[i-1][j+1]+num[i][j]; 			} 		} 		 		/*cout<<endl; 		for(int i=0; i<=n; i++) 		{ 			for(int j=0; j<=m+1; j++) 			{ 				cout<<" "<<fo[i][j]; 			} 			cout<<endl; 		} 		cout<<endl; 		for(int i=0; i<=n; i++) 		{ 			for(int j=0; j<=m+1; j++) 			{ 				cout<<" "<<rev[i][j]; 			} 			cout<<endl; 		} 		cout<<endl;*/ 		 		int len=-1+min(n,m); 		ll ans=-(ll)100*MOD,p; 		for(int i=1; i<=n; i++) 		{ 			for(int j=1; j<=m; j++) 			{ 				for(int k=1; k<=len; k++) 				{ 					if(i+k<=n && j+k<=m) { 						p=fo[i+k][j+k]+rev[i+k][j]-fo[i-1][j-1]-rev[i-1][j+k+1]; 						if(!(k&1)) { 							p-=num[i+k/2][j+k/2]; 						} 						ans=max(ans,p); 						//cout<<" "<<i<<" "<<j<<" "<<k<<" "<<p<<" "<<ans<<endl; 					} 				} 			}	 		} 		cout<<ans<<endl; 	} 	 	return 0; }
#include <vector> #include <list> #include <map> #include <set> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <memory.h> #include <cstring> using namespace std; long long len[20000]; long long dig[20000]; long long mod=1000000007; map<long long,long> dp; long long powmod(long long x, long long n) { 	long long nn=n; 	if(x==10 && dp[nn]!=0) 	return dp[nn];     long long w=1,p=x;     while (n) {         if (n%2) w=(w%mod*p%mod)%mod;         p=(p%mod*p%mod)%mod;         n/=2;     }     if(x==10)     dp[nn]=w;     return w%mod;     } long long getagp(long long n) { 	if(n<=0) 		return 0;   	n--; 	long long x=(9*( ( (n%mod+1)*powmod(10,n+1) )%mod-1+mod))%mod - (10*(powmod(10,n)-1+mod)%mod)%mod + mod; 	x=x%mod; 	x=(x*powmod(81,mod-2))%mod; 	x=(x*10)%mod; 	return x; } long long getgp(long long n) { 	if(n<0) 		return 0; 	long long x=(powmod(10,n+1)-1+mod)%mod; 	x=(x*powmod(9,mod-2))%mod; 	return x; } long long getagp1(long long n) { 	if(n<0) 		return 0; 	n++; 	long long a=n; 	long long r=10; 	long long x=( (((powmod(10,n)-n%mod+mod)%mod)*9)%mod + ((powmod(10,n-1)-1+mod)%mod*10)%mod )%mod; 	x=(x*powmod(81,mod-2))%mod; 	return x;  } int main() { 	//cout<<getagp1(0)<<endl; 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		long long m; 		scanf("%lld",&m); 		long long tot=0; 		for(int i=0;i<m;i++) 		{ 			scanf("%lld %lld",&len[i],&dig[i]); 			tot=tot+len[i]; 		} 		long long ctot=tot; 		long long ans=0; 		for(int i=0;i<m;i++) 		{   			long long x=((((getagp(tot-1)-getagp(tot-len[i]-1)+mod)%mod*45)%mod)*dig[i])%mod; 			x=(x*powmod(10,mod-2))%mod; 			long long y=(getgp(tot-1)-getgp(tot-len[i]-1)+mod)%mod; 			y=((y*dig[i])%mod*(dig[i]-1))%mod; 			y=(y*powmod(2,mod-2))%mod; 			ans=((ans+x)%mod+y)%mod; 			//cout<<x<<endl; 			tot=tot-len[i]; 		//	cout<<ans<<endl; 		} 		long long arr[m]; 		tot=0; 		 		///ans=0; 		for(int i=m-1;i>=0;i--) 		{ 			if(i==m-1) 			{ 				arr[i]=(dig[i]*getgp(len[i]-1))%mod; 				//cout<<len[i]-2<<endl; 				tot=tot+len[i]; 				//cout<<getagp1(5)<<endl; 				ans=(ans+ (((((getagp1(len[i]-2)*powmod(10,tot-len[i]))%mod*dig[i])%mod + len[i])%mod )%mod*dig[i])%mod)%mod; 				//cout<<ans<<endl; 				 			} 			else 			{	 				tot=tot+len[i]; 				//cout<<"-----"<<((getagp1(len[i]-2)*powmod(10,tot-len[i]))%mod*dig[i])<<endl; 				ans=(ans+ (((((getagp1(len[i]-2)*powmod(10,tot-len[i]))%mod*dig[i])%mod + (len[i]%mod*(arr[i+1]+1)%mod)%mod)%mod )%mod*dig[i])%mod)%mod; 				arr[i]=(arr[i+1]+(((dig[i]*getgp(len[i]-1))%mod)*(powmod(10,tot-len[i] )))%mod)%mod; 				//cout<<getgp(4)<<endl; 			} 			//cout<<ans<<endl; 			//cout<<arr[i]<<endl;   		} 		//cout<<ans<<endl;  		printf("%lld\n",ans); 	} 	 	return 0;   } 
#include <bits/stdc++.h>  using namespace std;  typedef long long ll; typedef pair <int,int> pii; typedef vector <int> vi;  #define rep(i, n) for(int i = 0; i < (n); ++i) #define forn(i, a, b) for(int i = (a); i < (b); ++i) #define ford(i, a, b) for(int i = (a); i >= (b); --i) #define fore(i, a, b) forn(i, a, b + 1)  #define pb push_back #define mp make_pair #define ff first #define ss second #define all(c) c.begin(), c.end() #define mset(a, v) memset(a, v, sizeof(a)) #define sz(a) ((int)a.size())  #define gi(x) scanf("%d", &x) #define pis(x) printf("%d ", x) #define pin(x) printf("%d\n", x) #define pnl printf("\n") #define dbn cerr << "\n" #define dbg(x) cerr << #x << " : " << (x) << " " #define dbs(x) cerr << (x) << " "  #define foreach(c, it) for(__typeof(c.begin()) it = c.begin(); it != c.end(); ++it)  const int MAX_N = 100100;  vi a[MAX_N]; vector <pii> toRemove[MAX_N]; pii toInsert[MAX_N], ans[MAX_N]; int cnt[MAX_N];  int main() {     int T; gi(T);     rep(z, T) {         int n, m;         gi(n), gi(m);         rep(i, n) a[i].clear(), toRemove[i].clear(), toInsert[i] = mp(n, 0);         rep(i, m + 1) cnt[i] = 0;          rep(i, n) {             int x; gi(x);             rep(j, x) {                 int id; gi(id);                 a[i].pb(id);             }         }         int ptr = n - 1, numTypes = 0;         for(int i = n - 1; i >= 0; --i) {             while(ptr >= 0 and numTypes < m) {                 rep(j, sz(a[ptr])) {                     cnt[a[ptr][j]]++;                     if(cnt[a[ptr][j]] == 1) ++numTypes;                 }                 --ptr;             }             if(numTypes == m) {                 toRemove[ptr + 1].pb(mp(i - ptr, ptr + 1));                 toInsert[i] = mp(i - ptr, ptr + 1);             }              rep(j, sz(a[i])) {                 cnt[a[i][j]]--;                 assert(cnt[a[i][j]] >= 0);                 if(cnt[a[i][j]] == 0) --numTypes;             }         }          set <pii> possible;          for(int i = n - 1; i >= 0; --i) {             possible.insert(toInsert[i]);             ans[i] = *possible.begin();             if(i < n - 1) ans[i] = min(ans[i], mp(ans[i + 1].ff + 1, ans[i + 1].ss - 1));              foreach(toRemove[i], it) possible.erase(*it);         }         rep(i, n) pis(ans[i].ss + 1), pin(ans[i].ss + ans[i].ff);     }     return 0; }
// codechef_codes.cpp : Defines the entry point for the console application.  #include <iostream> #include <vector> #include <algorithm> #include <string> #include <cstring> #include <cstdio> #include <cassert> #include <cmath> #include <time.h> #include <cstdlib> #include <deque>  using namespace std;  typedef long long ll; typedef unsigned long long ull; typedef vector<int> vi; typedef vector<ll> vll; typedef vector<vector<int> > vvi; typedef pair<int, int> ii; typedef vector<pair<int, int> > vii; typedef vector<vector<pair<int, int> > > vvii;  #define boost ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0) #define max(a,b) ((a)>(b)?a:b) #define min(a,b) ((a)<(b)?a:b) #define min_3(a,b,c) (min((a),min((b),(c)))) #define INF 1000000007 #define pb push_back  #define PB pop_back #define pf push_front #define PF pop_front #define MP make_pair #define all(x) (x).begin(), (x).end() #define nall(x) (x).rbegin(), (x).rend() #define tr(x,it) for(auto it = (x).begin();it!=(x).end();++it) #define ntr(x,it) for(auto it = (x).rbegin();it!=(x).rend();++it) #define mset(a,b) memset(a,b,sizeof(a)) #define ia(a,n) FOR(i,0,n-1)cin>>a[i] #define ia1(a,n) FOR(i,1,n)cin>>a[i] #define fpresent(c,x) ((c).find(x) != (c).end())  // set,map #define present(c,x) (find(all(c),x) != (c).end())  //vector #define F first #define S second #define FOR(i,a,b) for(int i=a;i<=b;++i) #define NFOR(i,a,b) for(int i=a;i>=b;--i) #define rep(i,n) FOR(i,0,n-1) #define TCASE int __T;cin>>__T;FOR(Tc,1,__T) inline int add(int a, int b, int m = INF) { a += b;if (a >= m)a -= m;return a; } inline int mul(int a, int b, int m = INF) { return (int)(((ll)a*(ll)b) % m); } inline int norm(int x, int m = INF) { if (x >= m)x %= m;if (x<0)x += m;return x; } inline int neg(int x, int m = INF) { x = -x;return norm(x); }   /// debug ////// #define pr(x,n) {rep(i,n)cout<<x[i]<<" ";cout<<endl;} #define pr1(x,n) {FOR(i,1,n)cout<<x[i]<<" ";cout<<endl;} #define DB(x)              cout<<__LINE__<<" :: "<<#x<< ": "<<x<<endl; #define DB2(x, y)          cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<endl; #define DB3(x, y, z)       cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<" | "<<#z<<": "<<z<<endl;   int main() { 	boost; 	ll tc,N,a,M,num,count = 0; 	cin >> tc; 	while (tc--) { 		cin >> N >> a >> M ; 		cout << (((a-1)+M)%N)+1 << endl; 	} }
// codechef_codes.cpp : Defines the entry point for the console application. //  #include <iostream> #include <vector> #include <algorithm> #include <string> #include <cstring> #include <cstdio> #include <cassert> #include <cmath> #include <time.h> #include <cstdlib>  #define boost ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0) #define max(a,b) ((a)>(b)?a:b) #define min(a,b) ((a)<(b)?a:b) #define min_3(a,b,c) (min((a),min((b),(c)))) #define INF 1000000007  using namespace std;  int a[107]; int arr[27][27];  int main() { 	boost; 	int tc,l,co,cou,flag; 	string str1,str2,str; 	cin >> tc; 	while (tc--) { 		flag = 1; 		for (int i = 0; i < 26; i++) { 			for(int j = 0 ; j < 26 ; j++) 				arr[i][j] = 0; 				}	 				cin>>str1>>str2; 				if (str1.length() != str2.length()) { 					cout << "NO"<<endl; 					continue; 				} 				cin >> l; 				for(int i = 0 ; i < l; i++){ 					cin >> str; 					arr[str[0]-'a'][str[3]-'a'] = 1; 					} 				for (int k = 0; k < 26; k++) { 					for (int i = 0; i < 26; i++) { 						for(int j = 0; j < 26 ; j++) 							arr[i][j] = arr[i][j] | (arr[i][k]&arr[k][j]); 					} 				} 				for (int i = 0; i < str1.length(); i++) { 					if (str1[i] != str2[i]) { 						if(arr[str1[i] - 'a'][str2[i] - 'a'] != 0) 							flag = 1; 						else { 							flag = 0; 							break; 						} 					} 				} 				if(flag) 					cout << "YES"<<endl; 				else 					cout << "NO"<<endl; 	} }
#include <bits/stdc++.h> using namespace std; #define pb push_back #define ll long long #define mp make_pair #define F first #define S second #define pii pair<int,int> #define ll long long #define mod 1000000007 #define maxn 2000005 #define vi vector<int> #define fr freopen("input.in","r",stdin) #define fw freopen("output.out","w",stdout)  set<int> avail; vector<int> pref; int ans[100005]; int test,n,p,curr;  int main(){      //fr; fw;      scanf("%d",&test);      while(test--){          avail.clear();         pref.clear();          scanf("%d",&n);                  for(int i = 1; i <= (5*n-2); i++){             avail.insert(i);         }                  for(int i = 1; i <= n; i++){             scanf("%d",&p);             pref.pb(p);         }         set<int>::iterator it;         for(int i = n-1; i > -1; i--){             curr = pref[i];             it = avail.lower_bound(curr);             if(it != avail.end()){                 ans[i+1] = *it;                 curr = *it;             }             else{                 ans[i+1] = *avail.begin();                 curr = ans[i+1];             }             avail.erase(curr);             avail.erase(curr+1);             avail.erase(curr+2);             avail.erase(curr-1);             avail.erase(curr-2);         }         for(int i = 1; i <= n; i++){             printf("%d ",ans[i]);         }         printf("\n");     }     return 0; }
#include <bits/stdc++.h> using namespace std;   #define INF 1000000007   typedef long long ll; typedef unsigned long long ull; typedef vector<int> vi; typedef vector<ll> vll; typedef vector<vector<int> > vvi; typedef pair<int,int> ii; typedef vector<pair<int,int> > vii; typedef vector<vector<pair<int,int> > > vvii;   #define all(x) x.begin(), x.end() #define tr(x,it) for(auto it = x.begin();it!=x.end();++it) #define ntr(x,it) for(auto it = x.rbegin();it!=x.rend();++it) #define sz(a) int((a).size())  #define pb push_back  #define PB pop_back #define pf push_front #define PF pop_front #define MP make_pair #define clr clear #define rz resize   #define ia(a,n) FOR(i,0,n-1)cin>>a[i] #define ia1(a,n) FOR(i,1,n)cin>>a[i] #define fpresent(c,x) ((c).find(x) != (c).end())  // set,map #define present(c,x) (find(all(c),x) != (c).end())  //vector #define F first #define S second #define FOR(i,a,b) for(int i=a;i<=b;++i) #define NFOR(i,a,b) for(int i=a;i>=b;--i) #define rep(i,n) FOR(i,0,n-1) #define TCASE int __T;cin>>__T;FOR(Tc,1,__T) inline int add(int a,int b, int m=INF){a+=b;if(a>=m)a-=m;return a;} inline int mul(int a,int b, int m=INF){return (int)(((ll)a*(ll)b)%m);}   ll expo(int base, int exp, int MOD=INF) {     ll res=1;     while(exp>0) {        if(exp&1) res=(res*(ll)base)%MOD;        base=((ll)base*base)%MOD;        exp=exp>>1;     }     return (int) res; } int fac[200001]; int ifac[200001]; inline int C(int n, int r) { 	int ans=1; 	ans=mul(ans,fac[n]); 	ans=mul(ans,ifac[r]); 	ans=mul(ans,ifac[n-r]); 	return ans; } int main() {     ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);          fac[0]=1;     FOR(i,1,200000)fac[i]=mul(fac[i-1],i);     FOR(i,0,200000)ifac[i]=expo(fac[i],INF-2);     TCASE     {     	int n,k;     	cin>>n>>k;     	if(n==1){cout<<"-1\n";continue;}     	int kr=sqrt(k);     	int ans=0;     	ans=add(ans,C(kr+n-1,n));     //	cout<<ans<<" ";     	int krr=kr;     	//if(kr*kr==k)kr--;     	FOR(i,1,kr)     	{     		int no=k/(i)-k/(i+1);     		if(k/i <= krr)continue;     		ans=add(ans,mul(no,C(i+n-2,n-1)));     	}     	cout<<ans<<"\n";     }      	return 0; }  
#include <iostream> using namespace std;  int main() { 	 	int t; 	cin>>t; 	while(t--){ 	    int n,q; 	    long long int a,b,c,d; 	    cin>>a>>b; 	    cin>>q; 	    bool ans=true; 	    while(q--){ 	        cin>>c>>d; 	        if((c>a&&c<b)||(d>a&&d<b)) 	            ans=false; 	       else if(c<=a&&d>=b) 	            ans=false; 	    } 	    if(ans)  cout<<"YES"<<endl; 	       else cout<<"NO"<<endl; 	} 	return 0; } 
#include<iostream> #include<cstdio> #include<cassert> #include<cmath> #include<vector> #include<set> #include<map> #include<string> #include<algorithm> #define vvl vector<vector<long long> > #define vvi vector<vector<long long> > long long mod=10000007; using namespace std; long long temp[2][2];  void MatrixMult(long long A[][2], long long B[][2]) { 	for(int i = 0; i < 2; i++) 		for(int j = 0; j < 2; j++) 		{ 			temp[i][j] = 0; 			for(int k = 0; k < 2; k++) 				temp[i][j] =(temp[i][j] + (A[i][k] * B[k][j]) % mod) % mod; 		} 	for(int i = 0; i < 2; i++) 		for(int j = 0; j < 2; j++) 			A[i][j] = temp[i][j]; }  long long FindFibonacci(long long n) { 	if (n == 0) 		return 0; 	if (n == 1) 		return 1; 	n--; 	long long ans[2][2]; 	long long res[2][2];  	res[0][0] = res[1][1] = 1; 	res[0][1] = res[1][0] = 0; 	ans[0][0] = ans[0][1] = ans[1][0] = 1; 	ans[1][1] = 0; 	while(n) 	{ 		if(n & 1) 			MatrixMult(res, ans); 		MatrixMult(ans, ans); 		n >>= 1; 	} 	return (res[0][0] + res[0][1]) % mod; }  void mat_mult(vector<vector<long long> > a,vector<vector<long long> > b, vector<vector<long long> > &c) { 	assert (a.size()!=0); 	assert (b.size()!=0); 	assert (a[0].size()==b.size()); 	c.resize(a.size()); 	for (int i=0;i<c.size();++i)c[i].resize (b[0].size()); 	for (int i=0;i<a.size();++i){ 		for (int k=0;k<b[0].size();++k){ 			c[i][k] = 0; 			for (int j=0;j<a[i].size();++j) { 				c[i][k] = ( c[i][k] + ( a[i][j] * b[j][k] ) % mod ) % mod; 			} 		} 	} } vector<vector< vvl > > pre(11,vector< vvl > (65)); int rev(int a,int b,int c) { 	int ans=(a<<2)+(b<<1)+c; 	return ans; } void eye (vvl &a, int dim){ 	a.resize (dim); 	for (int i=0;i<dim;++i){a[i].resize(dim);a[i][i]=1;} } void trans(vvl a,vvl &b) { 	int q=a.size(),w=a[0].size(); 	b.resize(w); 	for(int i=0;i<w;++i) 	{ 		b[i].resize(q); 		for(int j=0;j<q;++j) 		{ 			b[i][j]=a[j][i]; 		} 	} } void init(int k) { 	vvl mat(4*k,vector<long long> (4*k,0)); 	int size=4*k; 	for(int i=0;i<size;++i) 	{ 		int a,b,c; 		c=i&1; 		b=(i>>1)&1; 		a=i>>2; 		mat[i][rev((a+1)%k,b,0)]++; 		if(c==0) 		{ 			mat[i][rev(a,b,1)]++;	 		}	 		mat[i][rev(a,1,0)]++; 	} 	pre[k][1]=mat; } void doit() { 	long long n,k; 	scanf("%lld%lld",&n,&k); 	if(k==0) 	{	 		printf("%lld\n",FindFibonacci(n+1)); 	} 	else 	{ 		vvl ans; 		eye(ans,4*k); 		int i=1; 		while(n) 		{ 			vvl p=pre[k][i]; 			if(n%2==1)mat_mult(ans,p,ans); 			i++; 			n/=2; 		} 		long long v=ans[0][2]+ans[0][3]; 		v%=mod; 		printf("%lld\n",v); 	} } int main() { 	for(int i=1;i<=10;++i)init(i); 	for(int i=1;i<=10;++i) 	{ 		for(int j=2;j<=64;++j) 		{ 			vvl p=pre[i][j-1]; 			mat_mult(pre[i][j-1],p,pre[i][j]); 		} 	} 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		doit(); 	} 	return 0; } 
#include <bits/stdc++.h> using namespace std; int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		string s;         cin>>s;         int p,q;         cin>>p>>q;         int len = s.size();         sort(s.begin(),s.end());         while(q--)         {         	int n;         	cin>>n;         	if(n<=len*p)         	{         		int print= (n-1)/p;         		cout<<s[print]<<endl;         	}         	else cout<<-1<<endl;          } 	} 	return 0; }
#include <bits/stdc++.h> #define N 500005 using namespace std; typedef long long int lli; typedef struct{ 	lli maxm, sum; 	bool inc, dec; 	lli left; 	lli right; }seg;  seg st[N]; lli a[N];  void build(int ss, int se, int si){ 	if(ss > se) return; 	if(ss == se){ 		st[si].maxm = a[ss]; 		st[si].sum = a[ss]; 		st[si].inc = 1; 		st[si].dec = 1; 		return; 	} 	int mid = (ss + se) / 2; 	build(ss, mid, 2*si); 	build(mid+1, se, 2*si+1); 	st[si].maxm = max(st[2*si].maxm, st[2*si+1].maxm); 	st[si].sum = st[2*si].sum + st[2*si+1].sum; 	st[si].inc = (st[2*si].inc && st[2*si+1].inc && a[mid] <= a[mid+1]); 	st[si].dec = (st[2*si].dec && st[2*si+1].dec && a[mid] >= a[mid+1]); }  void update(int ss, int se, int si, int index){ 	if(ss > se) return; 	if(ss > index || se < index) return; 	if(ss == se && ss == index){ 		st[si].maxm = a[index]; 		st[si].sum = a[index]; 		st[si].inc = true; 		st[si].dec = true; 		return; 	} 	int mid = (ss + se) / 2; 	update(ss, mid, 2*si, index); 	update(mid+1, se, 2*si+1, index); 	st[si].maxm = max(st[2*si].maxm, st[2*si+1].maxm); 	st[si].sum = st[2*si].sum + st[2*si+1].sum; 	st[si].inc = (st[2*si].inc && st[2*si+1].inc && a[mid] <= a[mid+1]); 	st[si].dec = (st[2*si].dec && st[2*si+1].dec && a[mid] >= a[mid+1]); }  lli getmax(int qs, int qe, int ss, int se, int si){ 	if(qe < ss || qs > se || ss > se) return 0; 	if(qs <= ss && se <= qe) return st[si].maxm; 	int mid = (ss + se) / 2; 	return max(getmax(qs, qe, ss, mid, 2*si), getmax(qs, qe, mid+1, se, 2*si+1)); }  lli getsum(int qs, int qe, int ss, int se, int si){ 	if(qe < ss || qs > se || ss > se) return 0; 	if(qs <= ss && se <= qe) return st[si].sum; 	int mid = (ss + se) / 2; 	return getsum(qs, qe, ss, mid, 2*si) + getsum(qs, qe, mid+1, se, 2*si+1); }  bool getinc(int qs, int qe, int ss, int se, int si){ 	if(qe < ss || qs > se || ss > se) return 1; 	if(qs <= ss && se <= qe) return st[si].inc; 	int mid = (ss + se) / 2; 	lli x = getinc(qs, qe, ss, mid, 2*si); 	lli y = getinc(qs, qe, mid+1, se, 2*si+1); 	if(qs <= mid && mid+1 <= qe) 		return (x && y && a[mid] <= a[mid+1]); 	else 		return (x && y); } lli getdec(int qs, int qe, int ss, int se, int si){ 	if(qe < ss || qs > se || ss > se) return 1; 	if(qs <= ss && se <= qe) return st[si].dec; 	int mid = (ss + se) / 2; 	lli x = getdec(qs, qe, ss, mid, 2*si); 	lli y = getdec(qs, qe, mid+1, se, 2*si+1); 	if(qs <= mid && mid+1 <= qe) 		return (x && y && a[mid] >= a[mid+1]); 	else 		return (x && y); } int main() { 	int n, m, index, qs, qe, qtype; 	char c; 	lli newval; 	scanf("%d%d", &n, &m); 	for(int i = 0 ; i < n;  i++) 		scanf("%lld", &a[i]); 	build(0, n-1, 1); 	for(int i = 0 ; i < m ; i++){ 		c = getchar(); 		scanf("%c", &c); 		if(c == 'U'){ 			scanf("%d%lld", &index, &newval); 			index--; 			a[index] = newval; 			update(0, n-1, 1, index); 		} 		else{ 			scanf("%d%d", &qs, &qe); 			qs--; 			qe--; 			switch(c){ 				case 'M': printf("%lld\n", getmax(qs, qe, 0, n-1, 1)); 						break; 				case 'S': printf("%lld\n", getsum(qs, qe, 0, n-1, 1)); 						break; 				case 'I': printf("%d\n", getinc(qs, qe, 0, n-1, 1)); 						break; 				case 'D': printf("%d\n", getdec(qs, qe, 0, n-1, 1)); 						break; 			} 		} 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; # define d double  # define l long int struct Point{ 	d x; 	d y; }; int compareX(const void* a, const void* b) {     Point *p1 = (Point *)a,  *p2 = (Point *)b;     return (p1->x - p2->x); } // Needed to sort array of points according to Y coordinate int compareY(const void* a, const void* b) {     Point *p1 = (Point *)a,   *p2 = (Point *)b;     return (p1->y - p2->y); } d dist(Point p1, Point p2) {     return sqrt( (p1.x - p2.x)*(p1.x - p2.x) +                  (p1.y - p2.y)*(p1.y - p2.y)                ); } d stripmin(Point strip[],l size, d sum) { 	d mini = sum;   	qsort(strip, size, sizeof(Point), compareY);  	for(l i=0;i<size;i++) 	{ 		for(l j=i+1;j<size&&(strip[j].y-strip[i].y)<(mini/2);j++) 		{ 			for(l k=j+1;k<size&&(strip[k].y-strip[i].y)<(mini/2);k++) 			{ 				d di=(dist(strip[i],strip[j])+dist(strip[k],strip[j])+dist(strip[i],strip[k])); 				if(di<mini) mini=di; 			} 		} 	} 	return mini; } /*d bruteforce(Point P[],int n) { 	d mini = FLT_MAX;     for (int i = 0; i < n; i++)         for (int j = i+1; j < n; j++)         	for(int k=j+1;k<n;k++)             	{d di=(dist(P[i],P[j])+dist(P[k],P[j])+dist(P[i],P[k])); //cout<<i<<j<<k<<" "<<di<<"\n";             		if(mini>di) mini=di;}     return mini; }*/ d minsum(Point P[],l n) { 	if(n<3) 	{ 		return DBL_MAX; 	} 	l mid=n/2; 	Point midpt=P[mid]; 	d lf=minsum(P,mid); 	d rt=minsum(P+mid,n-mid); 	d sum=min(lf,rt); 	//cout<<sum<<"\n"; 	Point strip[n]; 	l j = 0;     for (l i = 0; i < n; i++)         if (abs(P[i].x - midpt.x) < (sum/2))             strip[j] = P[i], j++;     d middle=stripmin(strip,j,sum);     //cout<<min(middle,sum)<<"\n";     return min(middle,sum); } int main() { 	int t; 	cin>>t; 	int h=t; 	l n; 	Point P[100005]; 	while(t--){ 		cin>>n; 		for(l i=0;i<n;i++) 		{ 			cin>>P[i].x>>P[i].y; 		} 		    qsort(P, n, sizeof(Point), compareX); 		cout<<"Case "<<h-t<<": "<<setprecision(10)<<minsum(P, n)<<"\n"; 	} }
#include<bits/stdc++.h> #define ll long long #define SIZE 100009  using namespace std;  inline int LSOne(int n){         // Returns least Significant 1's place 	return n&(-n); }  class FenwickTree{ 	vector<ll> ft;                                                      // Fenwick tree usable from 1 to n 	public: 	FenwickTree(int n){               		ft.assign(n+1,0); 	} 	ll rsq(int b){                                                      //Returns the cumulative freq from index 1 to n 		ll sum =0;  		for(; b >0; b = b-LSOne(b)){                                      //O(logn) 			sum += ft[b]; 		} 		return sum; 	} 	ll rsq(int a, int b){                                              // Returns The cumulative freq from index a to b 		return rsq(b) - (a == 1? 0 : rsq(a-1)); 	} 	void adjust(int idx,int a){                                        // Adjusts the Array's idxth element, increments by a 		for(; idx < (int)ft.size();idx += LSOne(idx))                   // O(logn) 			ft[idx] +=a; 	} 	void rupd(int idx1,int idx2, int b){                              // Range updates Fenwick tree 		adjust(idx1, b); //		cout<<"in"<<endl; 		adjust(idx2+1, -1*b); 	} 	ll pointq(int idx1){                                              // Point Query fenwick tree 		return rsq(idx1); 	} };   int main(){ 	ios::sync_with_stdio(false); 	int T,H; 	cin>>T;                                                                    // Test cases and hold 	H = T;  	while(T--){ 		ll ans =0;                                                            // ans holds no of inversions 		int A[SIZE], n,k; 		set<int> A1;                                                          // set to check if there r any repeated Ai's 		cin>>n>>k; 		for(int i=0; i< n; i++){ 			cin>>A[i]; 			A1.insert(A[i]); 		} 		FenwickTree t(n+3);  		for(int i =0; i< n; i++){                                        // Function to find no of invs 			ans+= t.pointq(A[i]); 			t.rupd(1,A[i]-1,1); 		}  		cout<<"Case "<<H-T<<": "; 		if(ans>k){                                                       // If invs are more then ans is ans-k 			cout<<ans-k<<endl; 		} 		else{                                                           // If k is more-> more swaps even aftr sortd 			if(A1.size() != n)cout<<0<<endl;                             // 2 identical elements can b swappd again nd again 			else 			if((k-ans)%2)cout<<1<<endl;                                  // check parity 			else cout<<0<<endl; 		} 	} 	return 0; }  
#include<bits/stdc++.h> #define SIZE 2000009 #define ll long long  using namespace std;  inline bool compare(int a,int b, vector<int> &A){ 	return A[a]+a >= A[b] +b; }   class SegmentTree{                                                           // Point update Range Query Std SEg Tree 	vector<int> st, A; 	int n; 	int left(int p){return p<<1;} 	int right(int p){return (p<<1) +1;} 	int rmq(int p, int L,int R, int i,int j){ 		if(R<i || L>j) return -1; 		if(L>i && R<j) return st[p]; 		if(L==R) return st[p]; 		int p1 = rmq(left(p), L  , (L+R)/2,i, j ); 		int p2 = rmq(right(p), (L+R)/2 +1, R, i, j); 		if(p1 == -1) 			return p2; 		if(p2 == -1) 			return p1; 		return compare(p1,p2,A) ? p1: p2; 	} 	void build_st(int p , int L, int R){ 		if(L == R) {st[p] = L;return;}  		build_st(left(p), L  , (L+R)/2); 		build_st(right(p), (L+R)/2+1, R); 		int p1 = st[left(p)] , p2 = st[right(p)]; 		st[p] = (compare(p1,p2,A) ? p1 : p2 ); 	}  	public:  	SegmentTree(vector<int> &hol){ 		st.assign(4*hol.size(),0); 		A = hol; 		n = hol.size() ; 		build_st(1,0,n-1); 	} 	int rmq(int i, int j){ 		return rmq(1, 0, n-1, i, j); 	} };    void zalgor(string &s, vector<int> &z){ 	int L = 0, R = 0; 	int n = s.length(); 	for (int i = 1; i < n; i++) { 		if (i > R) { 			L = R = i; 			while (R < n && s[R-L] == s[R]) R++; 			z[i] = R-L; R--; 		} else { 			int k = i-L; 			if (z[k] < R-i+1) z[i] = z[k]; 			else { 				L = i; 				while (R < n && s[R-L] == s[R]) R++; 				z[i] = R-L; R--; 			} 		} 	} }  int main(){ //	char A[SIZE],B[SIZE],A1[SIZE],B1[SIZE];  	ios::sync_with_stdio(false); 	int T, q;    string A,B,A1,B1; //   int ans=0,fa[SIZE] = {0},fb[SIZE] ={0}, n;// = A1.length();  	cin>>T; 	for(int q =1; q<=T; q++){ 	//string A,B,A1,B1; 	cin>>A;  	cin>>B;  	A1 = B+A; 	B1 = A+B;  	int ans=0, n = A1.length(); 	vector<int> fa(n+5,0), fb(n+5,0); 	ans =0; n = A1.length(); 	zalgor(A1,fa); 	zalgor(B1,fb); 	n = n/2;  	for(int i =0; i< n; i++){ 		fa[i] = fa[i +n]; 	} //	cout<<endl; 	 	for(int i =0; i< n; i++){ 		fb[i] = fb[i + n]; 	} //	cout<<endl; 	cout<<"Case "<<q<<": ";  	vector<int> k(fa.begin(), fa.begin()+n); 	SegmentTree t (k); 	int h = A.length(); //	cout<<t.rmq(h,n)<<endl;; 	for(int i =0; i< n; i++){ 		if(t.rmq(0,fb[i]) !=-1) 		ans = max(ans,( fa[t.rmq(0,fb[i])] + t.rmq(0,fb[i]) >=i ?i + t.rmq(0,fb[i]):0 )); 	} 	cout<<ans<<endl; 	} 	return 0; }   
#include <bits/stdc++.h>  using namespace std; #define INF 1010000000 #define EPS 1E-12 #define MP make_pair #define MT make_tuple #define ST first #define ND second #define REP(i, n) for(int i = 0; i < (n); ++i) #define REPD(i, n) for(int i = (n) - 1; i >= 0; --i) #define FOR(i, a, n) for(int i = (a); i <= (n); ++i) #define FORD(i, a, n) for(int i = (a); i >= (n); --i) #define DD(x, args...) { vector<string> _v = _split(#args, ','); _err(x, _v.begin(), args); } #define D(args...) DD(", ", args) #define DE(args...) DD("\n", args) #define D2(a, args...) { cerr << a << ": "; D(args); } #define DD2(x, a, args...) { cerr << a << ": "; DD(x, args); } #define E cerr << endl; #define OUT(...) ostream& operator<<(ostream& ost, const __VA_ARGS__& _cnt) { return _out(ost, ALL(_cnt)); } #define SZ(x) ((int)(x).size()) #define PB push_back #define EB emplace_back #define ALL(x) x.begin(), x.end() #define endl '\n'  typedef long long LL; typedef pair<int, int> PII; typedef pair<LL, LL> PLL; typedef pair<double, double> PDD;  template<class c1> ostream &_out(ostream &ost, c1 a, c1 b);  template<class... Types> ostream& operator<<(ostream& out, const tuple<Types...>& value); template<class T1, class T2> ostream& operator<<(ostream& ost, const pair<T1, T2>& _cnt);  template<class T1> OUT(vector<T1>); template<class T1> OUT(deque<T1>); template<class T1> OUT(list<T1>); template<class T1, class T2> OUT(set<T1, T2>); template<class T1, class T2> OUT(multiset<T1, T2>); template<class T1, class T2, class T3> OUT(map<T1, T2, T3>); template<class T1, class T2, class T3> OUT(multimap<T1, T2, T3>);  template<class T1, class T2>  ostream& operator<<(ostream& ost, const pair<T1, T2>& _cnt) 	{ return ost << '(' << _cnt.ST << ", " << _cnt.ND << ')'; }  template<class T1> ostream& _out(ostream& ost, T1 a, T1 b) 	{ ost << '{'; if(a != b) { ost << *a; while(++a != b) ost << ", " << *a; } return ost << '}'; }  template<class Type, unsigned N, unsigned Last> struct tuple_printer { 	static void print(ostream& out, const Type& value)  	{ out << get<N>(value) << ", "; tuple_printer<Type, N + 1, Last>::print(out, value); } }; template<class Type, unsigned N> struct tuple_printer<Type, N, N> { 	static void print(ostream& out, const Type& value)  		{ out << get<N>(value); } }; template<class... Types> ostream& operator<<(ostream& out, const tuple<Types...>& value)  	{ out << '('; tuple_printer<tuple<Types...>, 0, sizeof...(Types) - 1>::print(out, value); out << ')'; return out; }  vector<string> _split(const string& s, char c) { 	int br = 0; 	vector<string> v(1); 	REP(i, SZ(s)) { 		if(s[i] == '[' || s[i] == '(' || s[i] == '{'/* || s[i] == '<'*/) br++; 		else if(s[i] == ']' || s[i] == ')' || s[i] == '}'/* || s[i] == '>'*/) br--; 		if(s[i] == c && br == 0) v.PB(""); 		else v.back().PB(s[i]);   }   return v; }  template<class T1> void _err(string del, vector<string>::iterator it, T1 a) {  	bool wb = (*it)[0] == ' ', we = (*it).back() == ' '; 	cerr << it -> substr(wb, SZ(*it) - wb - we) << " = " << a << endl;  	(void)del; } template<class T1, class... Args> void _err(string del, vector<string>::iterator it, T1 a, Args... args) {  	bool wb = (*it)[0] == ' ', we = (*it).back() == ' '; 	cerr << it -> substr(wb, SZ(*it) - wb - we) << " = " << a << del;  	_err(del, ++it, args...);  }  template<class T>  T maxx(const T& a)  	{ return a; } template<class T, class... Args>  T maxx(const T& a, Args... args)  	{ return max(a, maxx(args...)); } template<class T>  T minn(const T& a)  	{ return a; } template<class T, class... Args>  T minn(const T& a, Args... args)  	{ return min(a, minn(args...)); }  /////////////////////////////////////////////////////////////////////  vector<vector<int> > v; vector<vector<tuple<int, int, int> > > seg; int power; vector<vector<int> > jump; vector<int> dep; vector<PII> inter; vector<int> T; int N;  int prep(int a, int pp, int cur = 0) { 	jump[a][0] = pp; 	FOR(i, 1, power) 		jump[a][i] = jump[jump[a][i - 1]][i - 1]; 	 	inter[a].ST = cur; 	for(auto& i : v[a]) { 		if(i == pp) 			continue; 		dep[i] = dep[a] + 1; 		cur = prep(i, a, cur + 1); 	} 	inter[a].ND = cur; 	 	return cur; }  int LCA(int a, int b) { 	if(dep[a] < dep[b]) 		swap(a, b); 	 	int sub = dep[a] - dep[b]; 	int len = 0; 	while(sub > 0) { 		if(sub % 2 == 1) 			a = jump[a][len]; 		len++; 		sub /= 2; 	} 	 	if(a != b) { 		len = power; 		while(len >= 0) { 			if(jump[a][len] != jump[b][len]) { 				a = jump[a][len]; 				b = jump[b][len]; 			} 			len--; 		} 		a = b = jump[a][0]; 	} 	 	return a; }  int get(int a) { 	int res = 0; 	a += N; 	while(a != 0) { 		res += T[a]; 		a /= 2; 	} 	return res; }  void add(int a, int b, int val) { 	a += N; 	b += N; 	 	T[a] += val; 	if(a != b) 		T[b] += val; 	while(a + 1 < b) { 		if(a % 2 == 0) 			T[a + 1] += val; 		if(b % 2 == 1) 			T[b - 1] += val; 		a /= 2; 		b /= 2; 	} }  int solve(int a, int pp = -1) { 	int res = 0; 	for(auto& i : v[a]) { 		if(i == pp) 			continue; 		res += solve(i, a); 	} 	int tres = res; 	 	for(auto& i : seg[a]) { 		int bg, en, cost; 		tie(bg, en, cost) = i; 		res = max(res, cost + get(inter[bg].ST) + get(inter[en].ST) + tres); 	} 	 	add(inter[a].ST, inter[a].ND, tres - res); 	 	return res; }  int main() { 	ios::sync_with_stdio(0); 	cin.tie(0); 	 	int ts; 	cin >> ts; 	 	FOR(zz, 1, ts) { 		int n; 		cin >> n; 		power = sizeof(n) * 8 - __builtin_clz(n - 1); 		v.clear(); 			v.resize(n + 1); 		seg.clear(); 		seg.resize(n + 1); 		jump.clear(); 		jump.resize(n + 1, vector<int>(power + 1)); 		dep.clear(); 		dep.resize(n + 1); 		inter.clear(); 	inter.resize(n + 1); 		T.clear();			T.resize(1 << (power + 1)); 		N = 1 << power; 		 		REP(i, n - 1) { 			int a, b; 			cin >> a >> b; 			v[a].EB(b); 			v[b].EB(a); 		} 		 		prep(1, 1); 		 		int q; 		cin >> q; 		 		REP(i, q) { 			int a, b, c; 			cin >> a >> b >> c; 			seg[LCA(a, b)].EB(a, b, c); 		} 		 		cout << "Case " << zz << ": " << solve(1) << endl; 	} 	 	return 0; } /* 2 7 1 2 1 3 2 4 2 5 3 6 3 7 3 4 7 10 2 5 6 6 7 5 9 1 5  1 2  1 3  2 7  3 4  3 8  8 9  8 6 5 5 1 4 7 3 8 3 4 3 1 8 11 6 9 4 */ 
#include<bits/stdc++.h> #include<stdio.h> //#include<algorithm> using namespace std; //tuhinkundu #define MOD 1000000007 #define ll         long long #define s(n)                        scanf("%d",&n) #define sc(n)                       scanf("%c",&n) #define sll(n)                       scanf("%lld",&n) #define sf(n)                       scanf("%lf",&n) #define sstr(n)                       scanf("%s",&n) #define p(n)	printf("%d\n",n) #define pll(n)	printf("%lld\n",n) #define pc(n)	printf("%c\n",n) #define pstr(n)	printf("%s\n",n) #define pbl   printf(" ") #define pnew printf("\n") int main() { 	int t; 	s(t); 	int num=1; 	while(t--) 	{ 		int n; 		s(n); 		int arr[n]; 		for(int i=0;i<n;i++) 		s(arr[i]); 		sort(arr,arr+n,greater<int>()); 		/*for(int i=0;i<n;i++) 		printf("%d ",arr[i]); 		pnew;*/ 		printf("Case %d: %d\n",num++,arr[0]+arr[1]+arr[2]); 	} 	return 0; }
#include<iostream> #include<stdio.h> #include<stdlib.h> #include<string> #include<string.h> #include<vector> #include<map> #include<algorithm> #include<limits.h> #include<set>   using namespace std; #define lli long long int #define ulli unsigned long long int #define in(t) scanf("%d",&t) #define inl(t) scanf("%ld",&t) #define inll(t) scanf("%lld",&t) #define inlu(t) scanf("%llu",&t) #define MOD 1000000007 //int flaga[1001],flagb[1001];//a[101],b[101];//num[1001]; int main() {     int t,i,n,ca,cb,num,c,d;     in(t);     //t=in();     while(t--)     {     ca=cb=c=d=num=0;     //int flaga[1001]={0};     //int flagb[1001]={0};     //memset(flaga,0,sizeof(flaga));     //memset(flagb,0,sizeof(flagb));     map<int,int>flaga;     map<int,int>flagb;     in(n);     int a[n+1],b[n+1];     //n=in();     for(i=0;i<n;i++)     {     in(a[i]);     flaga[a[i]]=1;     }     for(i=0;i<n;i++)     {     in(b[i]);     flagb[b[i]]=1;     }     while(1)     {     in(num);     if(num>0)     {     if(flaga[num]==1)     {     flaga[num]=-1;     ca++;     }     if(flagb[num]==1)     {     flagb[num]=-1;     cb++;     }     }     else     {     break;     }     }     for(i=0;i<ca;i++)     {     if(flaga[a[i]]==-1)     c++;     }     for(i=0;i<cb;i++)     {     if(flagb[b[i]]==-1)     d++;     }     if(c==n && d==n)     printf("MIKE HARVEY\n");     else if(c==n)     printf("MIKE\n");     else if(d==n)     printf("HARVEY\n");     else     printf("0\n");     }     return 0; }
#include<bits/stdc++.h> #define pb push_back #define mp make_pair #define iter(container,it) typeof(container.begin()) it #define all(x) x.begin(),x.end() #define fastin std::ios::sync_with_stdio(false);cin.tie(NULL) #define cout_precision(x) cout<<std::fixed<<setprecision(x) using namespace std; #ifndef ONLINE_JUDGE #include <debug.h> #endif #define SET(p) memset(p,-1,sizeof(p)) #define CLR(p) memset(p,0,sizeof(p)) #define S(n) scanf("%d",&n) #define P(n) printf("%d\n",n) pair<int,int> knapsack(const vector<int>& weights,const vector<int>& values,const int& weight) {     /*..........................................................     ..... weights[] and values[] should be 1-indexed !!!!! .....     ..........................................................*/      int size=(int)weights.size(),i,j;     vector<vector<int> > dp_value(2,vector<int> (weight+1,0));     vector<vector<int> > dp_weight=dp_value;     vector<int> chosen_ones;     for(i=1; i<size; i++)     {         for(j=0; j<=weight; j++)         {             dp_value[i&1][j]=dp_value[(i-1)&1][j];             dp_weight[i&1][j]=dp_weight[(i-1)&1][j];             if(weights[i]<=j)             {                 if(dp_value[(i-1)&1][j-weights[i]]+values[i]>dp_value[(i-1)&1][j])                 {                     dp_value[i&1][j]=dp_value[(i-1)&1][j-weights[i]]+values[i];                     dp_weight[i&1][j]=dp_weight[(i-1)&1][j-weights[i]]+weights[i];                     chosen_ones.pb(i);                 }                 else if(dp_value[(i-1)&1][j-weights[i]]+values[i]==dp_value[(i-1)&1][j])                 {                     if(dp_weight[(i-1)&1][j-weights[i]]+weights[i]<dp_weight[(i-1)&1][j])                     {                         dp_weight[i&1][j]=dp_weight[(i-1)&1][j-weights[i]]+weights[i];                         chosen_ones.pb(i);                     }                 }             }         }         dp_value[(i+1)&1]=dp_value[i&1];         dp_weight[(i+1)&1]=dp_weight[i&1];     }      return mp(dp_weight[(size-1)&1][weight],dp_value[(size-1)&1][weight]); } int main() {     int weight,n,i;     fastin;     while(1)     {         cin>>weight>>n;         if(weight==0&&n==0)             break;         vector<int> weights(n+1,0),values(n+1,0);         for(i=1;i<=n;i++)         {             cin>>weights[i]>>values[i];         }         pair<int,int> ans=knapsack(weights,values,weight);         cout<<ans.first<<" "<<ans.second<<"\n";     } } 
#include<stdio.h> #include<stdlib.h> #include<math.h> #include<iostream> #define MOD 10000007 #define getcx getchar using namespace std;  /*unsigned long long int power(int x, int y) { 	 	if(y==0) return 1; 	if(y%2==0) 	 return power(x,y/2)*power(x,y/2)%MOD; 	else 	 return x*power(x,y/2)*power(x,y/2)%MOD; }*/  unsigned long long int power(int x, unsigned int y) {     unsigned long long int temp;     if( y == 0)         return 1;     temp = power(x, y/2);     if (y%2 == 0)         return temp*temp%MOD;     else         return x*temp*temp%MOD; } /*unsigned long long int f(int n) { 	if(n==1) 	return 1; 	if(n==2) 	return 5; 	return(f(n-1)+2*f(n-2));  }*/ int main() { 	int T,i; 	scanf("%ld",&T); unsigned long long int res; 	 int N = 0; 	for(i=0;i<T;i++) 	{ 		scanf("%d",&N); 		res = power(2,N); 	//	res = f(N); 		if(N%2==0) 		{ 			res = (res + 1)%MOD; 		} 		else 		{ 			res = (res - 1)%MOD; 		} 	//	res=res%MOD; 		cout<<res<<endl; 	} 	return 0; }
#include <bits/stdc++.h> using namespace std; typedef long long int ll; #define F(i,a,b) for(int i = (int)(a); i <= (int)(b); i++) #define RF(i,a,b) for(int i = (int)(a); i >= (int)(b); i--) #define pb push_back #define mp make_pair #define gc getchar_unlocked  int read_int(){     register int x = 0, c = gc();     int sign = 1;     while(c!='-' && (c<48 || c>57) ) c = gc();     if(c=='-')         sign = -1, c = gc();     while(c>=48 && c<=57)         x = (x<<1) + (x<<3) + c - 48, c = gc();     return sign*x; } int main() {     #ifndef ONLINE_JUDGE         freopen("input.txt","r",stdin);         freopen("output.txt","w",stdout);     #endif     int T;     int N;     T = read_int();     int cupCakes[100005];     cupCakes[0] = cupCakes[1] = 0;     cupCakes[2] = cupCakes[3] = 2;     cupCakes[4] = 3;     F(i,5,100000)     {         if(i%3 == 0) cupCakes[i] = cupCakes[i/3] + 2;         else cupCakes[i] = cupCakes[i/3 + 1] + 2;     }     while(T--)     {         N = read_int();         printf("%d\n",cupCakes[N]);     }     return 0; }  
#include <bits/stdc++.h> using namespace std; long long int mod=1000000007; inline vector<vector<long long int > > mat_mul(vector<vector<long long int > > &A,vector<vector<long long int > > &B) { 	int n=A.size(); 	vector<vector<long long int > > ans(n,vector<long long int >(n,0)); 	for(int i=0;i<n;i++) 	{ 		for(int j=0;j<n;j++) 		{ 			for(int k=0;k<n;k++) 			{ 				ans[i][j]=(ans[i][j]+A[i][k]*B[k][j])%mod; 			} 		} 	} 	return ans; } inline vector<vector<long long int> > mat_power(vector<vector<long long int> > &A,long long int b) { 	if(b==1) 	{ 		return A; 	} 	vector<vector<long long int > > ans=mat_power(A,b/2); 	ans=mat_mul(ans,ans); 	if(b%2) 	{ 		ans=mat_mul(ans,A); 	} 	return ans; } int main() { 	ios_base::sync_with_stdio(false); 	int t; 	cin>>t; 	while(t--) 	{ 		int h; 		long long int d; 		cin>>h>>d; 			vector < vector <long long int> > A(h+1,vector <long long int> (h+1,0)); for (int i = 0; i <= h; ++i) { int l1=max(i-1,0); int l2=i+1; A[i][l1]=1; if(l2 < h) A[i][l2]=1; } 		if(d==0) 		{ 			cout<<"0\n"; 			continue; 		} 		vector<vector<long long int> > ans=mat_power(A,d); 		cout<<ans[h][0]<<"\n"; 	} }
#include <bits/stdc++.h> using namespace std;  int main(){ 	string daftar[50001]; 	long N; 	long T; 	//string dummy; 	bool ada; 	long i; 	long sum; 	cin>>T; 	while (T--){ 		cin>>N; 		sum = 0;          //printf("%ld%ld\n", T,N);         //scanf("\n"); 		for (i=0; i<N; i++){ 			cin>>daftar[i]; 		}          //printf("Ypo\n"); 		sort(daftar, daftar+N);          /*for (i=0; i<N; i++){             cout<<daftar[i]<<endl;         }*/         //printf("DIA\n"); 		sum = 0; 		for (i=0; i<N; i++){ 			if (i==0){                 //cout<<"Pertama"<<endl; 				ada = true; 				sum++; 			}else{ 				if (daftar[i] == daftar[i-1]){                     //cout<<"YES"<<endl; 					if (ada){ 						ada = false; 						sum--; 					}else{ 						ada = true; 						sum++; 					} 				}else{ 				    //cout<<"YO"<<endl; 					ada = true; 					sum++; 				} 			} 		} 		printf("%ld\n", sum); 	} 	return 0; } 
/*_______SHREY MANIK______*/ #include <iostream> #include <string> #include <climits> #include <cstdio> #include <cstdlib> #include <cmath> #include <vector> #include <algorithm> #include <utility> #include <queue> #include <stack> #include <map> #include <set> #include <cstring> #include <iomanip> #include<list> #define ff first #define ss second #define MOD 1000000007 #define LL long long #define SET(a) memset(a,-1,sizeof(a)) #define CLEAR(a) memset(a,0,sizeof(a)) #define mp(a,b) make_pair(a,b) #define pb(a) push_back(a) using namespace std; template<class T>T gcd(T a,T b){return (b==0)?a:gcd(b,a%b);} template<class T>T lcm(T a,T b){return (a*b)/gcd(a,b);} int n,a[100005],b,t,hash[100005],k,N; vector<int>v,ar; vector<int>::iterator up; int main() {   cin>>t;   while(t--)   {   cin>>n>>k;   CLEAR(hash);   for(int i=0;i<k;i++){   cin>>a[i];   hash[a[i]]=i+1;    }   for(int i=0;i<k;i++)   {     cin>>b;     if(hash[b]!=0)     ar.pb(hash[b]);   }   N=ar.size();   if(N==0)   {   	printf("0\n");   	return 0;   }      v.pb(ar[0]);   for(int i=1;i<N;i++)   {   	up=upper_bound(v.begin(),v.end(),ar[i]);   //	if(up!=v.begin()&&(*(up-1))==a[i])                        uncomment these lines to get longest monotonic increasing subsequence   //	continue;   	if(up==v.end())   	v.pb(ar[i]);   	else   	*up=ar[i];   }   cout<<v.size()<<"\n";   v.clear();   ar.clear();   }   return 0; }  
#include <bits/stdc++.h> using namespace std;  int check(string str){     if(str.length() < 2) return 0;     else{         for(int i = 0; i < str.length(); i++){             if(!isupper(str[i]))return 0;         }     }     return 1; }  int main(){     string s;     getline(cin,s);     string str = "";     int ans = 0;     for(int i = 0; i  < s.length(); i++){         if(s[i]!=' ' && s[i]!= ',' && s[i]!= '.'){             str+=s[i];         }else{             ans+=check(str);             //cout << ans << endl;             str = "";         }     }     ans+=check(str);     cout << ans << endl; } 
#include <iostream> #include <vector> #include <string> #include <algorithm>  using namespace std;    int main() {     int t,n,i;          string temp;     cin>>t;     while(t>0){     	vector<string> str;         cin>>n;         for(i=0;i<n;i++){             cin>>temp;             str.push_back(temp);         }         sort(str.begin(),str.end());         for(i=0;i<n;i++){             cout<<str.at(i)<<'\n';         }         t--;     }     return 0; } 
#include<iostream> #include<stdio.h> #include<string.h> int main() {     int t,d,l,i,t1,t2;     char b[1000],g[1000];     scanf("%d",&t);     while(t--)     { d=0;     scanf("%s",b);     l=strlen(b);         g[d++]=b[0];       for(i=0;i<l-1;i++)         {if((b[i]=='0' && b[i+1]=='1')||(b[i]=='1' && b[i+1]=='0'))         g[d++]='1';         else             g[d++]='0';         }         for(i=0;i<d;i++)             printf("%c",g[i]);         printf("\n");     }   }
#include<iostream> #include<stdlib.h> #include<math.h> using namespace std; long long int mul(long long int a,long long int b,long long int mod) { 	long long int x=0,y=a%mod; 	while(b>0) 	{ 		if(b&1) 		x=(x+y)%mod; 		y=(y*2)%mod; 		b=b/2; 	} 	return x; } long long int power(long long int a,long long int b,long long int mod) { 	long long int ans=1; 	while(b>0) 	{ 		if(b&1) 		ans=mul(a,ans,mod); 		a=mul(a,a,mod); 		b=b/2; 	} 	return ans; } bool isPrime(long long int n,int it) { 	if(n<2) 	return false; 	if(n==2||n==3) 	return true; 	if(n%2==0) 	return false; 	long long int d=n-1; 	long long int i,j,x,a,freq=0; 	while(!(d&1)) 	{ 		d=d/2; 		freq++; 	} 	for(i=0;i<it;i++) 	{ 		a=rand()%(n-1)+1; 		x=power(a,d,n); 		if(x==1||x==(n-1)) 		continue; 		int flag=0; 		for(j=0;j<freq;j++) 		{ 		   x=mul(x,x,n); 		   if(x==1) 		   return false; 		   if(x==n-1) 		   { 		   	flag=1; 		   	break; 		   } 		} 		if(flag) 		continue; 		return false; 		 	} 	return true; 	 } int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		long long int n; 		cin>>n; 		if(isPrime(n,3)) 		cout<<"YEAH\n"; 		else 		{ 			int count=0; 			cout<<"NAA\n"; 			for(long long int i=n+1;count<10;i++) 			{ 				if(isPrime(i,3)) 				{ 				   cout<<i<<" "; 				   count++;	 				} 			} 			cout<<"\n"; 		} 	} }
#include <string.h> #include <stdio.h>  char Data[200]; int  InputLen; unsigned int  Results[200][5][3][3]; int Min(int a , int b) { 	return (a>b) ?  b :  a; } int Max(int a , int b) { 	return (a>b) ?  a :  b; }  unsigned int ProblemResult(int n,int current,int min ,int max ) { 	if (max - min  > 2 ) 		return 0; 	if (n == InputLen ) 		return 1; 	unsigned int  Result; 	if ( Results[n][current+2][min+2][max] != 0) 		return  Results[n][current+2][min+2][max] -1; 	if (Data[n] == '0' || Data[n] == '1') //fixed 	{ 		int i ; 		if  (Data[n] == '0') 			i = -1 ; 		else 			i = 1 ; 		Result = ProblemResult(n+1 , current + i , Min(min , current+i) , Max(max , current+i)); 	} 	else 		Result = ProblemResult(n+1 , current+1 , min , Max(max , current+1)) + ProblemResult(n+1 , current-1 ,Min(min , current-1) , max); 	Results[n][current+2][min+2][max] = Result+1; 	return Result; } int main() { 	int n ; 	scanf("%d",&n); 	for (int k = 0 ; k < n ; k++) 	{ 		scanf("%s",Data); 		memset(Results,0,sizeof(Results)); 		InputLen = strlen(Data); 		if (Data[strlen(Data)-1] == '\r'||Data[strlen(Data)-1] == '\n') 			InputLen--; 		printf("%d\n",ProblemResult(0,0,0,0)); 	} 	return 0; }  
#include <iostream>  main() { int fall, n; long a[]={2, 30, 604, 12168, 238848, 4569624, 85553528, 73583616, 24904904, 97232692, 58525800, 73415260, 87907304, 87175024, 17068080, 29574080, 35998808, 58680468, 10097320, 95291688, 6752496, 98146764, 75194272, 64554280, 65034568, 80660584, 96008208, 25487848, 65320240, 82282080, 93398112, 16584320, 97542776, 18165460, 96826664, 44380488, 74063792, 7860936, 26738800, 11276624, 29457408, 92904792, 36560944, 3574516, 8666232, 78777144, 34284736, 3221008, 8849160, 85794952, 91029520, 41412320, 21764480, 75388872, 27074816, 10247536, 14616624, 88798416, 89729824, 3174032, 40552160, 32397760, 1402304, 69862144, 12091320, 2958420, 17509928, 85293320, 14505264, 27693160, 37143920, 48070160, 11938240, 7066680, 81144560, 98633760, 50534208, 85903440, 49242976, 92684960, 30500640, 37740888, 47018160, 89281424, 78118368, 95103812, 97747408, 68715288, 52347304, 84905296, 50980192, 59999736, 64757776, 21369968, 72617088, 12353056, 65533064, 14947912, 32118800, 47720128, 80991936, 6159904, 72947232, 25478400, 63800928, 79276016, 57409504, 15469912, 34163600, 97134928, 35031296, 85671264, 94214192, 58108560, 85778208, 34398336, 70509184, 1978192, 59253760, 65810528, 74445536, 15815584, 87505472, 22138400, 56863168, 16544384, 11988608, 60645888, 7329080, 4750420, 54600232, 83425160, 97741616, 879656, 29496176, 89322896, 83851584, 61464568, 34610544, 47578368, 91962496, 70071952, 61768544, 56676128, 62543840, 1942840, 40505200, 81810000, 23554400, 30727200, 46423392, 43100800, 24217824, 60631088, 87665248, 56266624, 19280128, 47746976, 67298240, 25205824, 32568928, 92228952, 965296, 34550160, 31941344, 83431248, 20698272, 10897056, 80624960, 22625104, 13682848, 13404612, 29275096, 34049000, 13297824, 66539248, 52492552, 9940976, 81555680, 95352464, 95810848, 47325592, 97376, 48527760, 86930864, 3507488, 71417792, 17887536, 97495200, 78489824, 68996608, 71766592, 39174536, 83992520, 44624144, 60828928, 11213632, 77021056, 14141600, 34515264, 39369248, 37930032, 73153376, 64200080, 30809184, 3195968, 16165952, 98557696, 78559264, 13991792, 34516960, 78196960, 55351104, 2076600, 34573280, 94933840, 64952240, 70994592, 28612544, 8617232, 75266784, 27368096, 14624768, 7774400, 37215792, 81042704, 71652896, 66618048, 69614080, 14190592, 88450624, 43060096, 31381568, 4927200, 63142592, 99468144, 50235296, 28185888, 46804480, 84658112, 70951904, 40653856, 30170688, 32839680, 85121792, 41222304, 58200576, 35190208, 12708800, 83890752, 16725120, 64397120, 92826240, 42856192, 82533376, 26338816,  73983544, 63989076, 58369832, 26084488, 15236144, 35967656, 11453040, 15808400, 80726592, 30968184, 72609136, 43353152, 49134848, 64980496, 34392672, 11649568,  41740384, 81360120, 43046896, 79254736, 86206304, 48349312, 15594208, 32353472, 55873440, 41968560, 91325536, 62239680, 85532544, 10128928, 11945152, 60412736, 91062560, 1010744, 23131248, 39688272, 97051744, 93740816, 91549472, 19438624, 86664256, 56033168, 63216160, 42450992, 81179680, 39341120, 7595200, 42730752, 99314976, 49600176, 49141344, 19896416, 86415424, 64271232, 85280960, 68357760, 86602304, 70331744, 96515520, 28709120, 41270528, 8279360, 58089344, 24585600, 63237600, 67688280, 99956400, 48507280, 44357600, 48446800, 33088928, 39477920, 76823616, 58769040}; for(std::cin >> fall >> n; fall--; std::cout << a[n-1] << std::endl, std::cin >> n); return 0; } 
#include<bits/stdc++.h> using namespace std;   #define sd(mark) scanf("%d",&mark) #define ss(mark) scanf("%s",&mark) #define sl(mark) scanf("%lld",&mark) #define clr(mark) memset(mark,0,sizeof(mark)) #define F first #define S second #define MP make_pair #define PB push_back #define ll long long int main() { 	ll t,n,e,i,a; 	sl(t); 	while(t--) 	{ 		sl(n); 		sl(e); 		for(i=0;i<e;++i) 		{ 			sl(a);sl(a); 		} 		ll ans=(n/2)*(n/2+n%2)-e; 		printf("%lld\n",ans); 	} }
// Name:- Kunal Sheth  // Problem:- MERGING RIVERS  // Link:- http://www.codechef.com/problems/AI04  // Site:- CodeChef    //header files  #include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<map> #include<cmath> #include<cstring> using namespace std;  //end of header files   //definitions  #define MOD 1000000007 #define llu long long unsigned #define lld long long #define ld long  //end of definitions   //fast input  int scan_d()    {int ip=getchar_unlocked(),ret=0,flag=1;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;} ld scan_ld()    {int ip=getchar_unlocked(),flag=1;ld ret=0;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;} lld scan_lld()    {int ip=getchar_unlocked(),flag=1;lld ret=0;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;} llu scan_llu()    {int ip=getchar_unlocked();llu ret=0;for(;ip<'0'||ip>'9';ip=getchar_unlocked());for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return ret;}  //end of fast input  //fast output  //no line break void print_d(int n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=10;char output_buffer[10];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<10);} void print_ld(ld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=11;char output_buffer[11];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<11);} void print_lld(lld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<21);} void print_llu(llu n)     {int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<21);}  //new line void println_d(int n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=10;char output_buffer[11];output_buffer[10]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<11);} void println_ld(ld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=11;char output_buffer[12];output_buffer[11]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<12);} void println_lld(lld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<22);} void println_llu(llu n)     {int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<22);}  //special char char sp; void printsp_d(int n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=10;char output_buffer[11];output_buffer[10]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<11);} void printsp_ld(ld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=11;char output_buffer[12];output_buffer[11]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<12);} void printsp_lld(lld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<22);} void printsp_llu(llu n)     {int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<22);}  //end of fast output   //extra functions  //end of extra fnctions   //main  int main() { 	int i=0;     while(true)     {     	i++;         int n=scan_d();         if(!n)         	break;         while(true)         {         	int temp=n,s=0;         	while(temp)         	{         		s+=temp%10;         		temp/=10;         	}         	n+=s;         	if(n%10==1||n%10==3||n%10==9)         		break;         }         printf("Case #%d\n",i);         printf("first meets river %d at %d\n\n",n%10,n);     }     return 0; }  //end of main
#include<algorithm> #include<iostream> #include<cstdio> #include<vector> #include<fstream> #include<iomanip> #include<bitset> #include<deque> #include<queue> #include<string> #include<map> #include<cstring> #include<sstream> #include<cmath> using namespace std;  #define gc getchar_unlocked   void scanint(int &x) { register int c = gc(); x = 0; for(;(c<48 || c>57);c = gc()); for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} }  #define N 1000001 vector<long long>dp;  int main() {     int i,n,t,x,y;     scanint(t);     while(t--)     {         scanint(x);         scanint(y);         if(x==y&&!(x&1))         {             cout<<(4)*(x/2)<<"\n";          }         else if(x==y&&(x&1))         {             cout<<1+(4*((x-1)/2))<<"\n";         }          else if(y==x-2&&!(x&1)&&!(y&1))         {             cout<<2+2*y<<"\n";         }         else if(y==x-2&&(x&1)&&(y&1))         {              cout<<3+4*((y-1)/2)<<"\n";         }         else         cout<<"No Number\n";         }     return 0; } 
#include <stdio.h> typedef long long int tep;    tep fastInput() {     tep val = 0;     char c = getchar_unlocked();     while (c < '0' || c > '9') c = getchar_unlocked();     while (c >= '0' && c <= '9')       {          val = (val<<1) + (val<<3) + (c-'0');         c = getchar_unlocked();     }     return val; }     int main() {     tep t,m,n,str,i;     t=fastInput();     while(t--)     {         n=fastInput();         m=fastInput();         str=1;                  if(m<=n)          printf("0\n");         else         {             for(i=n ; i>=2 ; i-- )             {                                  str*=i;                                  str=str%m;                                               }                                       printf("%lld\n",str);         }                                                 }          return 0;           } 
#include<stdlib.h> #include<stdio.h> #include<string.h>  #include<iostream> #include<algorithm> using namespace std;  int main() { 	long long int arr[102][102],brr[102][102],i,j,n,m,t,k,MAX,sum; 	 		scanf("%lld",&t); while(t--) {	 	 	for(i=0;i<102;i++) 	{ 		 		for(j=0;j<102;j++) 		{ 			arr[i][j]=0; 			brr[i][j]=0; 			}  		}   	MAX=0; 		scanf("%lld",&n); 			scanf("%lld",&m); 	for(i=0;i<n;i++) 	{ 		for(j=0;j<m;j++) 		scanf("%lld",&arr[i][j]);  	} 	 	for(i=m-1;i>=0;i--) 	brr[n-1][i]=arr[n-1][i]; 	 	/*for(i=n-2;i>=0;i--) 	brr[i][n-1]=arr[i][n-1];*/  	for(i=n-2;i>0;i--) 	{ 		for(j=m-1;j>=0;j--) 		{ 			if(j==0) 			brr[i][j]=arr[i][j]+max(brr[i+1][j+1],brr[i+1][j]); 			else if(j==m-1) 			brr[i][j]=arr[i][j]+max(brr[i+1][j-1],brr[i+1][j]); 			else 			brr[i][j]=arr[i][j]+max(max(brr[i+1][j+1],brr[i+1][j]),brr[i+1][j-1]);	 		} 	 	}	 	 	MAX=arr[0][0]+max(brr[1][1],brr[1][0]); 	 	for(i=1;i<m-1;i++) 	{ 		sum=arr[0][i]+max(brr[1][i-1],max(brr[1][i],brr[1][i+1])); 		if(sum>MAX) 		MAX=sum; 		} 		 	sum=arr[0][m-1]+max(brr[1][m-1],brr[1][m-2]); 	 		if(sum>MAX) 		MAX=sum; 	 	 	printf("%lld\n",MAX); } }  
#include <iostream> #include <string.h> #include <stdio.h> using namespace std;  void prt(long long int n) { 	if(n>0) 	{ 		n--; 		prt(n/26);  		cout<<char((n%26)+65); 	} }  int main() {     int a;     long long int r;     cin>>a;     while(a!=0)     {     cin>>r;        prt(r);        cout<<endl; a--;     }return 0; } 
#include<stdlib.h> #include<stdio.h> #include<string.h>  #include<iostream> #include<algorithm> using namespace std;  char arr[105][105]; long long int n,m;  int fun(long long index,long long i,long long j) { 	 	if(i>=n||j>=m||i<0||j<0) 	return 0; 	if(arr[i][j]!='C') 	return 0; 	 	arr[i][j]='1'; 	fun(index,i+1,j); 	fun(index,i,j+1); 	fun(index,i-1,j); 	fun(index,i,j-1); 	return 1;	 }     int main() { 	long long int i,j,index,t,ans; 	 	scanf("%lld",&t); 	while(t--) 	{ 		index=0; 		scanf("%lld %lld",&n,&m); 		for(i=0;i<n;i++) 		scanf("%s",arr[i]); 		 		for(i=0;i<n;i++) 		{ 			for(j=0;j<m;j++) 			{ 				if(fun(index,i,j)) 				index++;				 				}   		} 	//cout<<index;	 	ans=1; 	for(i=1;i<=index;i++) 	ans=(2*ans)%1000000007; 	 	printf("%lld\n",ans-1); 	 	}    }  
#include <iostream> #include <string.h> using namespace std; int main() {     int a,i,ct,k,j;     cin>>a;     while(a!=0)     {         ct=0;         string str;         string sub;         cin>>str;         cin>>sub;         for(i=0;i<str.length();i++)         {             if(str[i]==sub[0])             {                 k=i;j=0;                 while(j<sub.length())             {                 if(str[k]!=sub[j])                 goto l1;                k++;j++;             }ct++;             }               l1:;         } cout<<ct<<endl;         a--;     }return 0; }
#include <iostream> #include <string.h> #include<algorithm>  using namespace std; long long int getSum(long long int n) {     long long int sum;     /*Single line that calculates sum*/     for(sum=0; n > 0; sum+=n%10,n/=10);     return sum; } int main() {     int a;     long long int ct;     cin>>a;     while(a!=0)     {         cin>>ct;         l1:if(ct<=24)         cout<<ct<<endl;         else         {ct=getSum(ct);goto l1;}  a--;      }return 0; } 
#include <iostream>  using namespace std;  int main() { int A[10010], C[10010], fall, n, x, i, max, j, max2;  for(cin >> fall; fall--;) 	{ 	for(cin >> n, i=0; i<n; i++) 		cin >> A[i]; 	for(max=i=0; i<n; i++, max=0) 		for(j=0; j<=i; j++, C[i]=max+1) 			if(A[i]>A[j] && C[j]>max) 				max=C[j];  	for(max=i=0; i<n; i++) 		if(C[i]>max) 			max=C[i];  	for(max2=0, i=n-1; i>=0; i--, max2=0) 		for(j=n-1; j>=i; j--, C[i]=max2+1) 			if(A[i]>A[j] && C[j]>max2) 				max2=C[j];  	for(max2=i=0; i<n; i++) 		if(C[i]>max2) 			max2=C[i];  	if(max>max2) 		cout << max << endl; 	else 		cout << max2 << endl; 	} return 0; } 
//============================================================================ // Name        : practise.cpp // Author      :  // Version     : // Copyright   : Your copyright notice // Description : Hello World in C++, Ansi-style //============================================================================  #include <iostream> #include<algorithm> using namespace std;  int arr[100001];   int main() { 	int tc,number_rods,market_price,cutting_cost; 	int i,j,k; 	int cost,maxcost; 	int len; 	int key; 	int num_pieces,cuts,tempmaxcost;  	cin>>tc;  	while(tc--) 	{ 		cin>>number_rods>>market_price>>cutting_cost;  		cost=0;  		maxcost=0;  		for(i=0;i<number_rods;i++) 			cin>>arr[i];  		sort(arr,arr+number_rods);  		for(len=1;len<=arr[number_rods-1];len++) 		{ 			tempmaxcost=0;  			for(i=0;i<number_rods;i++) 			{ 				cost = 0;  				if(arr[i]>=len) 				{ 					num_pieces = arr[i]/len;  					if(arr[i]%len==0) 					{ 						cuts = (arr[i]/len) - 1; 						cost = (arr[i]*market_price) - (cuts*cutting_cost); 					} 					else 					{ 						cuts=(arr[i]/len); 						cost = (num_pieces*len*market_price) - (cuts*cutting_cost); 					}    					if(cost>0) 						tempmaxcost += cost; 				} 			}    			if(tempmaxcost>maxcost) 			{ 				maxcost = tempmaxcost; 			} 		}  		cout<<maxcost<<endl;  	}  	return 0; } 
// House #include <iostream> #include <cstring> #include <cstdio>  using namespace std;  int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		string str; 		int hno; 		cin >> str; 		cin >> hno; 		int a[10001]; 		a[0] = 0; 		a[1] = 1; 		int i = 0; 		bool flag = false; 		while(i < (int)str.size()) 		{ 			a[i + 2] = (str[i] - 48) - (a[i + 1] + a[i]); 			if(!(a[i + 2] == 0 || a[i + 2] == 1)) 			{ 				flag = true; 				break;				 			} 			i++; 		} 		if(flag) 			printf("NONE\n"); 		else 			printf("%d\n", a[hno + 1]); 	} 	 	return 0; } 
#include<iostream> using namespace std; int main() {     int n,test;     scanf("%d",&test);     while(test--)     {     scanf("%d",&n);     char arr[500]="1";     int temp=0,j=0,x=0,i,y;     for(j=1;j<=n;j++)     {         temp=0;         for(i=0;i<=x;i++)         {             arr[i]=arr[i]-48;             y=arr[i]*2+temp;             arr[i]=y%10+48;             temp=y/10;         }         while(temp>0)         {             x++;             arr[x]=temp%10+48;             temp=temp/10;         }         }     int sum=0;     for(i=x;i>=0;i--)     {         sum=sum+(arr[i]-48);     }      cout<<sum<<endl;     sum=0;      }           return 0; } 
#include<stdio.h> int arr[2000][20000],pos[2000]; void pre() { arr[0][0]=1; pos[0]=1; int t,n,rem,num,mul,i,sum,j; for(j=1;j<2000;j++){ sum=0; pos[j]=0; rem=0; for(i=0;i<pos[j-1];i++) { mul=(arr[j-1][i]<<1)+rem; arr[j][i]=mul%10; rem=mul/10; } pos[j]=pos[j-1]; while(rem!=0) { arr[j][pos[j]]=rem%10; rem=rem/10; pos[j]++; } } }   int main() { pre(); int t,n,i; scanf("%d",&t); while(t--) { scanf("%d",&n); for(i=pos[n-2]-1;i>=1;i--) printf("%d",arr[n-2][i]); printf("%d",arr[n-2][0]+1); printf("\n"); } //system("pause"); return 0; }
#include<stdio.h> void factnew(int); int main(void) { int num,fact; long int ans; scanf("%d",&num); while(num-- > 0)     {     scanf("%d",&fact);     factnew(fact);     } return 0; }   void factnew(int fact) { int num,ans[1000],i,temp,x,index,zero; index=1; ans[0]=1; temp=0; x=0; num=1; zero=0; while(num<=fact)     {         for(i=0;i<index;i++)             {             x=ans[i]*num+temp;             ans[i]=x%1000;             temp=x/1000;             }         while(temp>0)             {i=index;             ans[i]=temp%1000;             temp=temp/1000;             index++;             }         num++;     } for(i=index;i>0;i--)     {     if(ans[i-1]<100&&i!=index)     {     printf("%d",zero);     if(ans[i-1]<10)     printf("%d",zero);     }     printf("%d",ans[i-1]);     } printf("\n"); } 
#include<iostream>  using namespace std;  int num132[32],num3num2[65535];  long long mat[35],count3;  long long num1,num3;  char str[65583];  #define gc getchar_unlocked  void scanint(int &x) {     register int c = gc();     x = 0;     int neg = 0;     for(;((c<48 || c>57) && c != '-');c = gc());     if(c=='-') {neg=1;c=gc();}     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}     if(neg) x=-x; }  void preprocess() { 	mat[0]=1; mat[1]=2; 	for(int i=2;i<=35;i++) 		mat[i]=2*mat[i-1]; }  void find() { 	int i; 	num1 = 0; num3 = 0; 	for(i=0;i<32;i++) 		num1+=(mat[31-i]*num132[i]); 	for(i=0;i<count3;i++) 		num3+=(mat[count3-1-i]*num3num2[i]); }  int main() { 	int t,i,len; 	int temp[50]; 	int res; 	scanint(t); 	preprocess(); 	while(t--) 	{ 		scanf("%s",&str); 		for(i=0;i<=31;i++) 			num132[i] = ((str[i]=='1')?0:1); 		for(i=48,count3=0;str[i]!='\0';i++,count3++) 			num3num2[i-48] = ((str[i]=='1')?0:1); 		find(); 		res = num3%num1; 		len=-1; 		i=0; 		while(res>0) 		{ 			len++; 			temp[i]=res%2; 			res/=2; 			i++; 		} 		for(i=0;i<=len && i<32;i++) 			printf("%d",(temp[len-i]>0?0:1)); 		printf("\n"); 	} 	return 0; } 
#include <stdio.h> main() { char a[100][200]={ "1", "1", "3", "15", "105", "945", "10395", "135135", "2027025", "34459425", "654729075", "13749310575", "316234143225", "7905853580625", "213458046676875", "6190283353629375", "191898783962510625", "6332659870762850625", "221643095476699771875", "8200794532637891559375", "319830986772877770815625", "13113070457687988603440625", "563862029680583509947946875", "25373791335626257947657609375", "1192568192774434123539907640625", "58435841445947272053455474390625", "2980227913743310874726229193921875", "157952079428395476360490147277859375", "8687364368561751199826958100282265625", "495179769008019818390136611716089140625", "29215606371473169285018060091249259296875", "1782151988659863326386101665566204817109375", "112275575285571389562324404930670903477890625", "7297912393562140321551086320493608726062890625", "488960130368663401543922783473071784646213671875", "33738248995437774706530672059641953140588743359375", "2395415678676082004163677716234578672981800778515625", "174865344543353986303948473285124243127671456831640625", "13114900840751548972796135496384318234575359262373046875", "1009847364737869270905302433221592504062302663202724609375", "79777941814291672401518892224505807820921910393015244140625", "6462013286957625464523030270184970433494674741834234775390625", "536347102817482913555411512425352545980058003572241486357421875", "45589503739486047652209978556154966408304930303640526340380859375", "3966286825335286145742268134385482077522528936416725791613134765625", "352999527454840466971061863960307904899505075341088595453568994140625", "32122956998390482494366629620388019345854961856039062186274778466796875", "2987435000850314871976096554696085799164511452611632783323554397412109375", "283806325080779912837729172696128150920628587998105114415737667754150390625", "27529213532835651545259729751524430639300973035816196098326553772152587890625", "2725392139750729502980713245400918633290796330545803413734328823443106201171875", "275264606114823679801052037785492781962370429385126144787167211167753726318359375", "28352254429826839019508359891905756542124154226667992913078222750278633810791015625", "2976986715131818097048377788650104436923036193800139255873213388779256550133056640625", "318537578519104536384176423385561174750764872736614900378433832599380450864237060546875", "34720596058582394465875230149026168047833371128291024141249287753332469144201839599609375", "3853986162502645785712150546541904653309504195240303679678670940619904075006404195556640625", "435500436362798973785473011759235225823973974062154315803689816290049160475723674097900390625", "50082550181721881985329396352312050969757007017147746317424328873355653454708222521258544921875", "5859658371261460192283539373220509963461569821006286319138646478182611454200862034987249755859375", "697299346180113762881741185413240685651926808699748071977498930903730763049902582163482720947265625", "84373220887793765308690683435002122963883143852669516709277370639351422329038212441781409234619140625", "10377906169198633132968954062505261124557626693878350555241116588640224946471700130339113335858154296875", "1297238271149829141621119257813157640569703336734793819405139573580028118308962516292389166982269287109375", "164749260436028300985882145742271020352352323765318815064452725844663571025238239569133424206748199462890625", "21252654596247650827178796800752961625453449765726127143314401633961600662255732904418211722670517730712890625", "2784097752108442258360422380898637972934401919310122655774186614048969686755501010478785735669837822723388671875", "370285001030422820361936176659518850400275455268246313217966819668512968338481634393678502844088430422210693359375", "49988475139107080748861383849035044804037186461213252284425520655249250725695020643146597883951938106998443603515625", "6848421094057670062594009587317801138153094545186215562966296329769147349420217828111083910101415520658786773681640625", "951930532074016138700567332637174358203280141780883963252315189837911481569410278107440663504096757371571361541748046875", "134222205022436275556779993901841584506662499991104638818576441767145518901286849213149133554077642789391561977386474609375", "19193775318208387404619539127963346584452737498727963351056431172701809202884019437480326098233102918882993362766265869140625", "2783097421140216173669833173554685254745646937315554685903182520041762334418182818434647284243799923238034037601108551025390625", "409115320907611777529465476512538732447610099785386538827767830446139063159472874309893150783838588715991003527362957000732421875", "60958182815234154851890356000368271134693904868022594285337406736474720410761458272174079466791949718682659525577080593109130859375" };   int fall, n; for(scanf("%d",&fall); fall--&&scanf("%d",&n); puts(a[n])); return 0; }
#include<iostream> #include<stdio.h> #include<vector> #include<math.h> #include<algorithm>   #define MP make_pair   using namespace std;     typedef pair<int,pair<long long int,int > > PII; typedef long long LL;   vector<int>primes;     vector<PII>input;   void initialize_prime(int max) {      vector<bool>v(max); for  (int i=2;i<max;i++) v[i]=true; for (int i=3; i<=int(sqrt(max)); i+=2)       if (v[i])          for (int j=i*i; j<max; j+=i*2)             v[j] = false; primes.push_back(2); for (int i=3;i<max;i+=2)     if (v[i]) primes.push_back(i); }   void dosums(int max) { int comp=0; long long int sum=0; for (int i=0;i<primes.size();i++) { if (primes[i]>=input[comp].first) { input[comp].second.first=sum; comp++; if (comp==(input.size())) break; for (int j=comp;j<max;j++) { if (input[j].first<primes[i]) { comp++; input[j].second.first=sum; } else  break;         }  } sum+=primes[i]; } return; }   void Output() { LL *a; a=new LL[input.size()]; for (int i=0;i<input.size();i++)  a[input[i].second.second]=input[i].second.first; for (int i=0;i<input.size();i++) printf("%lld\n",a[i]);      return; }     int main () { int t; scanf("%d",&t); for (int i=0;i<t;i++) { int getin;     scanf("%d",&getin); input.push_back(MP(getin,MP(0,i))); } sort(input.begin(),input.end()); initialize_prime(input[input.size()-1].first+100); dosums(input[input.size()-1].first); Output(); return 0; }
#include <iostream> #include <bitset>   std::bitset<1003000> r1; std::bitset<1003000> r2; std::bitset<1003000> r3;   static int next(int n) {   	int sum = n; 	while (n) { 		sum += n % 10; 		n /= 10; 	} 	return sum; }   static void init_series() {   	for (int n = 1; n <= 1003000; n = next(n)) { 		r1[n] = true; 	} 	for (int n = 3; n <= 1003000; n = next(n)) { 		r2[n] = true; 	} 	for (int n = 9; n <= 1003000; n = next(n)) { 		r3[n] = true; 	} }   int main() {   	std::ios_base::sync_with_stdio(false); 	std::cin.tie(0);   	init_series();   	int cases = 0; 	std::cin >> cases;   	while (cases--) {   		int n; 		std::cin >> n;   		while (true) { 			if (r1[n]) { 				std::cout << "1 " << n << '\n'; 				break; 			} 			if (r2[n]) { 				std::cout << "3 " << n << '\n'; 				break; 			} 			if (r3[n]) { 				std::cout << "9 " << n << '\n'; 				break; 			} 			n = next(n); 		} 	}   	std::cout.flush();   	return 0; } 
#include<algorithm> #include<cstdio> #include<iostream> using namespace std;   #define isPowerOfTwo(x)((x&(x-1))==0)   int main(){     int test;         for(scanf("%d",&test);test>0;test--){                 int n;                 scanf("%d",&n);                 if(isPowerOfTwo(n)) printf("No\n");                 else printf("Yes\n");         }         return 0; }
#include<iostream> #include<cstdio> #include<algorithm> #include<cmath> #include<vector> #include<string> #include<map> #include<set> #include<stack> #include<queue> #include<deque> #include<cstring>  using namespace std;  int bit[1<<18]; vector<int> a(100001); vector<int> b(100001); vector<int> rank(100002);  void update(int idx) {           while(idx<1<<18)      {                      bit[idx]++;                      idx+=(idx&-idx);      }  }  int query(int idx) {      int total=0;      while(idx>0)      {                  total+=bit[idx];                  idx-=(idx&-idx);      }      return total; }  int scan() { int t=0; char c;         c=getchar_unlocked();         while(c<'0' || c>'9')         c=getchar_unlocked();         while(c>='0' && c<='9')         {                 t=(t<<3)+(t<<1)+c-'0';                 c=getchar_unlocked();         }         return(t); }   int main() {     int t;     t=scan();//scanf("%d", &t);     while(t--)     {         int n;         n=scan();//scanf("%d", &n);         memset(bit, 0, sizeof(bit));         for(int i=0;i<n;i++)             a[i]=scan();         for(int i=0;i<n;i++)             b[i]=scan();         for(int i=0;i<n;i++)             rank[b[i]]=i+1;         for(int i=0;i<n;i++)             a[i]=rank[a[i]];         long long ans=0;         for(int i=n-1;i>=0;i--)         {             ans+=query(a[i]);             update(a[i]);         }         printf("%lld\n", ans);     }     return 0; } 
 #include<iostream> #include<cstdio> #include<memory.h> #include<cstdlib> #include<algorithm> #include<cmath> #include<string> #include<map> #include<cstring> #include<vector> #include<queue> #include<stack> #include<assert.h> #include<set> #include<deque> #include<climits> #include<utility>  using namespace std;  #define lc(i) (i<<1) #define rc(i) ((i<<1)+1) #define iscan(n) scanf("%d",&n) #define llscan(n) scanf("%lld",&n) #define cscan(n) scanf("%c",&n) #define sscan(n) scanf("%s",n) #define FOR(i,a,b) for(i=a;i<b;++i) #define MP make_pair #define PB push_back #define LL long long #define _MAX 10000 #define FILL(a,x) memset(a,x,sizeof a) #define REP(i,n) for(i=0;i<n;++i)  int MOD; int C[27][27];  int nCr(int n, int r) { 	if(n < r) 	{ 		return 0; 	} 	if(r > n - r) 		r = n-r; 	if(r == 0) 		return 1; 	if(C[n][r] != -1) 		return C[n][r]; 	C[n][r] = (nCr(n-1,r-1) + nCr(n-1,r)) % MOD; 	return C[n][r]; }  int a[26]; int n,m; int bnd; int dp[(1<<16)][26][26];  int solve(int msk, int rem, int id) { 	if(rem == 0) return 1; 	if(rem > n-id) return 0; 	if(dp[msk][rem][id] != -1) 		return dp[msk][rem][id]; 	int ret = 0; 	for(int i=0;i<=bnd;++i) 	{ 		if(!(msk & (1<<i)) && (a[i] & (1<<id))) 			ret += solve(msk|(1<<i),rem-1,id+1); 	} 	ret += solve(msk,rem,id+1); 	return dp[msk][rem][id] = ret%MOD; }  int F[26];  int fact(int nn) { 	if(F[nn] != -1) 		return F[nn]; 	return F[nn] = (fact(nn-1) * nn)%MOD; }  int main() { 	MOD = 10007; 	FILL(C,-1); 	FILL(a,0); 	FILL(dp,-1); 	FILL(F,-1); 	F[0] = 1; 	F[1] = 1; 	int k; 	iscan(n); 	iscan(m); 	iscan(k); 	int i,j; 	REP(i,n) 	{ 		REP(j,m) 		{ 			int b; 			iscan(b); 			if(b) 			{ 				a[j] |= (1<<i); 			} 		} 	} 	sort(a,a+m); //	REP(i,m)cout<<a[i]<<endl; 	int full = 0; 	i = m-1; 	while(i>=0 && full < 10 && a[i] == (1<<n)-1) 	{ 		--i; 		++full; 	} 	bnd = i; //	cout<<bnd<<" "<<full<<endl; 	int ans = 0,tmp; 	for(i=0;i<=full && i <= k;++i) 	{ 		tmp = solve(0,k-i,0); 	//	printf("solve(%d,%d,%d) = %d\n",0,k-i,0,tmp); 		tmp = (tmp * ((nCr(n-k+i,i) * nCr(full,i)) % MOD)) % MOD; 		tmp = (tmp*fact(i)) % MOD; 		ans += tmp; 	} 	printf("%d\n",ans % MOD); 	 	return 0; } 
/* Success is a matter of hanging on, when others have let go. Its not who you are, that holds you back, its who you think you are not. The future belongs to those, who believe in the beauty of their dreams. */ //{ /* theCodeGame */ #include<iostream> #include<cmath> #include<algorithm> #include<climits> #include<vector> #include<queue> #include<bitset> #include<cstdlib> #include<cstdio> #include<cstring> #include<ctime> #include<map> using namespace std; #define MOD 1000000007LL #define LL long long #define ULL unsigned long long #define LD long double #define MAX(a,b) ((a)>(b)?(a):(b)) #define MIN(a,b) ((a)<(b)?(a):(b)) #define ABS(x)   ((x)<0?-(x):(x)) #define SQR(x) ((x)*(x)) #define CUBE(x) ((x)*(x)*(x)) #define si(n) scanf("%d",&n) #define si2(n,m) scanf("%d %d",&n,&m) #define sf(n) scanf("%f",&n) #define sl(n) scanf("%ld",&n) #define sll(n) scanf("%lld",&n) #define slu(n) scanf("%llu",&n) #define sd(n) scanf("%lf",&n) #define ss(n) scanf("%s",n) #define pnl printf("\n") #define REP(i,n) for(int i=0;i<(n);i++) #define FOR(i,a,b) for(int i=(a);i<(b);i++) #define FORR(i,n,e) for(int i=(n);i>=(e);i--) #define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d)) #define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d)) //#undef mydebug #ifdef mydebug #define DB(x) cout<<#x<<"="<<(x)<<"\n" #define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n" #define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n" #define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n" #define pnld pnl; #else #define DB(x) #define DB2(x,y) #define DB3(x,y,z) #define DB4(x,y,z,a) #define pnld #endif #define FILL(a,b) memset(a,b,sizeof(a)) const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; //template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;} void DBG_ARR(const int A[],int S,int N){cout<<"[";FOR(i,S,N){cout<<A[i]<<" ";}cout<<"]\n";} void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;} ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} //} void precompute(){} void doThis(){     int n;     si(n);     		if(n%2 || n&(n-1)) 			cout<<"BMEENA\n"; 		else 			cout<<"BKUL\n"; }  int main(){ #ifdef amy freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr); #endif precompute(); int t=1; scanf("%d",&t); while(t--){doThis();} #ifdef amy fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC)); #endif return 0; } 
#include <iostream>  int main() {     int n;     long long sum;      std::cin>>n;     sum=n;     for(int i=2;i<=n;i++)         sum+=(n/i)*i;     std::cout<<sum<<"\n";     return 0; } 
#include<cstdio> #include<iostream> #include<vector> #include<map> #include<set> #include<stack> #include<queue> #include<algorithm> #include<cmath> #include<string> #include<cstdlib> #include<climits> #include<cstring> using namespace std;  #define CLR(a,x) memset(a,x,sizeof(a)) #define PB push_back #define INF 1000000000 #define MOD 1000000007 #define MP make_pair #define tr(container , it) for(typeof(container.begin()) it=container.begin() ; it!=container.end() ; it++) #define FOR(i,a,b) for(i=a;i<b;i++) #define REP(i,a) FOR(i,0,a) #define LL long long #define VI vector < int > #define PII pair < int , int >   void precompute(void) { } LL d[1024]; vector < vector < PII > > edge; int n,x,y,m,k; int dis[1024]; set < pair < int , int > > S; bool pos(LL mid) {   int u,v,cdis,ndis;   S.clear();   S.insert(MP(0,x));   if(d[x] > mid)return false;   fill(dis, dis+n, INF);   dis[x] = 0;   PII top;   while(!S.empty()) {     top = *(S.begin());     S.erase(S.begin());     u = top.second;     cdis = dis[u];     if(u == y) {       return cdis<=k;     }     int sz = edge[u].size();     for(int i=0;i<sz;i++) {       v = edge[u][i].first;       ndis = cdis + edge[u][i].second;       if(d[v] > mid)         continue;       if(dis[v] > ndis) {         S.erase(MP(dis[v],v));         dis[v] = ndis;         S.insert(MP(dis[v],v));       }     }   }   return false; }    int main() { 	int t,u,v,c; 	precompute(); 	 	while(scanf("%d",&t)!=EOF) { 		while(t--) { 		  scanf("%d%d",&n,&k);       for(int i=0;i<n;i++) {         scanf("%lld",&d[i]);       }       scanf("%d%d%d",&m,&x,&y);       x--;y--;       edge.clear();       edge.resize(n);       for(int i=0;i<m;i++) {         scanf("%d%d%d",&u,&v,&c);         u--;v--;         edge[u].PB(MP(v,c));         edge[v].PB(MP(u,c));       }       LL ans = -1,low,high,mid;       low = 0;       high = 1000000000000000LL;       while(low<=high) {         mid = (low + high)/2;         if(pos(mid)) {           ans = mid;           high = mid-1;         } else {           low = mid+1;         }       }       cout<<ans<<endl;     }     break; 	} 	return 0; } 
/*  *Kartik Singal @ ka4tik  */ #include<bits/stdc++.h> using namespace std; #define s(n) scanf("%d",&n); #define db(x) cerr << #x << ": " << x << endl; #define db2(x, y) cerr << #x << ": " << x << " | " << #y << ": " << y << endl; #define db3(x, y, z) cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl; #define db4(a, b, c, d) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << endl; #define db5(a, b, c, d, e) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << endl; #define db6(a, b, c, d, e, f) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << " | " << #f << ": " << f << endl; #define MAXN 11111 vector<int> pos; int dp[11000]; bool done[11000]; int turn=0; int fibg(int n,int m) {     //for(int i=0;i<=n;i++)     //done[i]=0;     pos.clear();     pos.push_back(1);     pos.push_back(m);      while(pos.back()<n)         pos.push_back(pos[pos.size()-1]+pos[pos.size()-2]);      dp[0]=0;     vector<int> v(100,0);      for(int i=1;i<=n;i++)     {         turn++;         //for(int j=0;j<30;j++) v[j]=0;         for(int j=0;pos[j]<=i;j++)         {             v[dp[i-pos[j]]]=turn;         }         for(int j=0;j<v.size();j++)         {             if(v[j]!=turn)             {                 dp[i]=j;                 break;             }         }     }     return dp[n];   }  int main() {     //freopen("in","r",stdin);      int N,test;s(test);     while(test--)     {         int ans=0;         s(N);         for(int i=0;i<N;i++)         {             int n,m;             s(n);s(m);             int a=fibg(n,m);             ans^=a;         }         if(ans)             puts("Jack");         else             puts("Angelica");     }      return 0; }  
// Author: Aman Choudhary #include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <cmath> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <climits> #include <map> #include <cassert> #define dholu 10000000 #define mod 100003 #define PHI 1000000006 #define ull unsigned long long #define ill long long int #define pii pair<int,int> #define pb(x) push_back(x) #define F(i,a,n) for(i=(a);i<(n);++i) #define FD(i,a,n) for(i=(a);i>=(n);--i) #define FE(it,x) for(it=x.begin();it!=x.end();++it) #define V(x) vector<x> #define S(x) scanf("%d",&x) #define S1(x) scanf("%llu",&x) #define MAX 100009 #define LOGMAXN 20 using namespace std;  void input() {    #ifndef ONLINE_JUDGE    freopen("input54.txt","r",stdin);    freopen("output54.txt", "w", stdout);    #endif }  string lower,upper; string sub; int n; int nn; int mask; int length; vector <int> digits; int lps[27]; string s; ill total[22]; ill sum[22]; ill dp[22][22][1LL<<10 +1][2]; ill dd[22][22][1LL<<10 +1][2]; vector <ill> multiply;  void calculate() {    int i,len,n;    len = 0;    lps[0] = 0;    n = sub.size();    i = 1;    while (i < n) {        if (sub[i] == sub[len]) {            lps[i] = len+1;            len++;            i++;            continue;        }        if (len == 0) {            lps[i] = 0;            i++;        } else {            len = lps[len-1];        }    } }  ill get (ill a, ill b, ill c) {    a = a*b;    if (a >= mod) {        a = a%mod;    }    a = a*c;    if (a >= mod) {        a = a%mod;    }    return a; }  ill f (int index, int ii, int mask, int flag) {    ill &result = dp[index][ii][mask][flag];    if (ii == length) {        result = 0;        return 0;    }    if (index == nn) {        if (mask == 0) {            result = 1;            return 1;        }        result = 0;        return 0;    }      if (result != -1) {        return result;    }     result = 0;     int i;    F (i, 0, 10) {        int ff,iii,x = i;        if (index == 0 && x == 0) {            continue;        }        if ((sub[ii]-'0') == x) {            iii = ii+1;        } else {            iii = ii;            while (1) {                if (x == (sub[iii]-'0')) {                    iii++;                    break;                }                if (iii == 0) {                    break;                }                iii = lps[iii-1];            }        }         if (flag == 1) {            ff = 1;        } else {            if (x > (s[index]-'0')) {                continue;            }            if (x == (s[index]-'0')) {                ff = 0;            } else {                ff = 1;            }        }         result = result + f (index+1, iii, mask&(~(1LL<<x)), ff);        if (result >= mod) {            result = result % mod;        }        dd[index][ii][mask][flag] += (get (dp[index+1][iii][mask&(~(1LL<<x))][ff], (ill)x, multiply[index]) + dd[index+1][iii][mask&(~(1LL<<x))][ff])%mod;        if (dd[index][ii][mask][flag] >= mod) {            dd[index][ii][mask][flag] = dd[index][ii][mask][flag]%mod;        }    }    return result; }  void precompute() {    s = "";    int i;     total[0] = sum[0] = 0;     ill xx = 1;    F (i, 1, 19) {        memset (dp, -1, sizeof(dp));        memset (dd, 0, sizeof(dd));        nn = i;        s = s + "9";          multiply.insert (multiply.begin(), xx%mod);         xx = xx*10;         f (0, 0, mask, 0);        total[i] = total[i-1] + dp[0][0][mask][0];        sum[i] = sum[i-1] + dd[0][0][mask][0];        if (total[i] >= mod) {            total[i] = total[i]%mod;        }        if (sum[i] >= mod) {            sum[i] = sum[i]%mod;        }    } }  ill ax,ay;  void calculate (string &ss, int flag) {    memset (dp, -1, sizeof(dp));    memset (dd, 0, sizeof(dd));    int n = ss.size();    s = ss;    nn = n;    ill xx=1;    multiply.clear();    for (ill j = 0; j < n; j++) {        multiply.pb (xx%mod);        xx = xx*10;    }    reverse (multiply.begin(), multiply.end());    f (0, 0, mask, 0);    // cout << s << " --> " << dp[0][0][mask][0] << " aa " << dd[0][0][mask][0] << endl;     if (flag == 0) {        ax = ax + dp[0][0][mask][0];        ay = ay + dd[0][0][mask][0];        ax = ax%mod;        ay = ay%mod;        ax = ax + total[n-1];        ay = ay + sum[n-1];        ax = ax%mod;        ay = ay%mod;    } else {        ax = ax - dp[0][0][mask][0];        ay = ay - dd[0][0][mask][0];        if (ax < 0) {            ax = ax + mod;        }        if (ay < 0) {            ay = ay + mod;        }        ax = ax - total[n-1];        ay = ay - sum[n-1];        if (ax < 0) {            ax = ax + mod;        }        if (ay < 0) {            ay = ay + mod;        }    }    ax = ax%mod;    ay = ay%mod; }  string subtract (string s) {    int i,j,n = s.size(),flag=0;    for (i = n-1; i >= 0; i--) {        if (s[i] == '0') {            s[i] = '9';            for (j = i-1; j >= 0; j--) {                if (s[j] == '0') {                    s[j] = '9';                    continue;                }                s[j]--;                break;            }            break;        }        s[i] = s[i]-1;        break;    }     for (int i = 0; i < s.size(); i++) {        if (s[i] == '0') {            s.erase (s.begin());            i--;            continue;        }        break;    }    return s; }   int main() {    //i/nput();   //== freopen ("output.txt", "w", stdout);    input();    S (n);    digits.resize (n);     int i;    mask = 0;    F (i, 0, n) {        S (digits[i]);        mask = mask | (1LL<<digits[i]);    }     cin >> sub;    length = sub.size();     calculate();    precompute();     int queries;    S (queries);     while (queries--) {         ax = ay = 0;        cin >> lower >> upper;        lower = subtract (lower);        calculate (upper, 0);        calculate (lower, 1);        printf ("%lld %lld\n", ax, ay);    }     return 0; } 
#include <cstdio> #include <algorithm> using namespace std; int main() { 	int t; 	long long a[100005]; 	scanf("%d",&t); 	while(t--){ 		int n; 		int long long sum = 0; 		int long long ans; 		scanf("%d",&n); 		for(int i = 0; i < n; i++){ 			scanf("%lld",&a[i]); 			sum += a[i]; 		} 		long long mini[100005]; 		mini[0] = a[0]; 		ans = mini[0]; 		for(int i = 1; i < n; i++) { 			mini[i] = min(a[i], a[i] + mini[i - 1]); 			if(mini[i] < ans) { 				ans = mini[i]; 			} 		} 		if(ans < 0) { 			ans = sum - 2*ans; // multiplying the min sub-array with -1 and obtaining final max solution 		} 		else { 			ans = sum; 		} 		printf("%lld\n",ans); 	} 	return 0; } 
#include <cstdio> #include <vector> #include <queue> #include <set> #include <stack> #include <algorithm> #include <cstring> using namespace std; typedef pair<int, int> ii; typedef vector<ii> vii; #define TRvii(c, it) \ for (vii::iterator it = (c).begin(); it != (c).end(); it++) const int inf = 1000000000, nil = -1;  class HopcroftMaxBPM { 	// main inputs 	vector< vector<int> > G; 	int n1, n2; 	// used by algorithm 	vector< int > mate; 	vector< int > level;  	bool checkAugmentingPath() { 		queue<int> Q; 		int v; 		bool canAugment = 0; 		fill(level.begin(), level.end(), inf); 		for (int i = 0; i < n1; i++) 			if( mate[i] == nil ) 			{ 				level[i] = 0; 				Q.push(i); 			}  		while ( Q.empty() ==  false ) 		{ 			v = Q.front(); Q.pop(); 			for (int i = 0; i < G[v].size(); i++) 				if ( mate[ G[v][i] ] == nil ) 					canAugment = 1; 				else if (level[ mate[ G[v][i] ] ] == inf) 				{ 					level[ mate[ G[v][i] ] ] = level[ v ] + 1; 					Q.push( mate[ G[v][i] ] ); 				} 		} 		return canAugment; 	}  	bool augment(int v){ 		for (int i = 0; i < G[v].size(); i++ ) 			if( mate[ G[v][i] ] == nil || \ 			    (level[ mate[ G[v][i] ] ] == level[v] + 1 && augment( mate[ G[v][i] ] ) ) ) 			{ 				mate[v] = G[v][i]; 				if ( G[v][i] != nil ) 					mate[ G[v][i] ] = v; 				level[v] = inf; 				return true; 			} 		level[v] = inf; 		return false; 	}  public: 	HopcroftMaxBPM(){} 	HopcroftMaxBPM(vector< vector<int> > _G, int _n1, int _n2) : \ 	   G(_G), n1(_n1), n2(_n2) { 		mate  = vector<int> (n1 + n2); 		level = vector<int> (n1); 	}  	pair<int, vector<int> > getMaxBPM(){ 		int matching = 0; 		fill(mate.begin(), mate.end(), nil); 		while ( checkAugmentingPath() == true ) 		{ 			for(int i = 0; i < n1; i++) 			{ 				if( mate[i] == nil ) 					if( augment(i) == true ) 						matching = matching + 1; 			} 		} 		return make_pair(matching, mate); 	}  };  stack<int> dfs_scc; // additional information for SCC set<int> in_stack; // for dfs_low update check int dfs_low[500] ,dfs_num[500] ,dfsNumberCounter,val[500],con; #define DFS_WHITE 0 vector< vector<int> > g(500); void tarjanSCC(int u) {     dfs_low[u] = dfs_num[u] = dfsNumberCounter++; // dfs_low[u] <= dfs_num[u]     dfs_scc.push(u); in_stack.insert(u); // stores u based on order of visitation     for(int i = 0 ; i < g[u].size(); i++){         int v = g[u][i];         if (dfs_num[v] == DFS_WHITE) // a tree edge             tarjanSCC(v);         if (in_stack.find(v) != in_stack.end()) // condition for update         dfs_low[u] = min(dfs_low[u], dfs_low[v]); // update dfs_low[u]     }     if (dfs_low[u] == dfs_num[u]) { // if this is a root of SCC         //printf("SCC: ");         while (!dfs_scc.empty() && dfs_scc.top() != u) {             val[dfs_scc.top()] = con ;             in_stack.erase(dfs_scc.top());             dfs_scc.pop();         }         val[dfs_scc.top()] = con ;         in_stack.erase(dfs_scc.top());         dfs_scc.pop();         con++;     } }   main(){ 	int t, n; 	pair<int, vector<int> > bpm; 	scanf("%d", &t); 	while (t--){ 		scanf ("%d", &n); 		int k, v; 		for (int i = 0; i < 2*n; i++) g[i].clear(); 		for (int i = 0; i < n; i++) { 			scanf ("%d", &k); 			while (k--) { 				scanf ("%d", &v); 				v--; 				g[v].push_back( n + i ); 			} 		} 		HopcroftMaxBPM h(g, n, n); 		bpm = h.getMaxBPM(); 		if(bpm.first== n ){ 		    //printf("Hello");             int ans = 0;             memset(dfs_low,0,sizeof(dfs_low));             memset(dfs_num,0,sizeof(dfs_num));             memset(val,0,sizeof(val));             while(!dfs_scc.empty()) dfs_scc.pop();             in_stack.clear();             con = 1;             dfsNumberCounter = 1 ;              for(int i=0;i<n;i++)                 g[bpm.second[i]].push_back(i);              for(int i = 0; i < n; i++)                 if(dfs_num[i] == 0) tarjanSCC(i);             //return 0;             for(int u=0; u<n;u++)                 for(int j = 0; j < g[u].size();j++){                     v = g[u][j];                     if( (val[u] == val[v]) && val[u] >= 1) ans++;                 }             printf("1 %d\n",ans); 		}         else             printf("0 0\n"); 	} 	return 0; } 
#include <iostream> #include<cstdio> #define MOD 1000000007 using namespace std; long long int fact(int num) {    if(num==1)      return 1;     return num*fact(num-1);  } int main() {     int t;     scanf("%d",&t);     while(t--)     {        int num,k;        long long int result=1;        scanf("%d %d",&num,&k);        for(int i=1;i<=k;i++)        {          result=result*num;          result=result%MOD;          num--;        }        printf("%lld\n",result);     } 	return 0; }
#include<bits/stdc++.h> using namespace std; #define debug(x) cerr<<#x<<" " <<x<<endl; int main() {     int t,i;     scanf("%d",&t);     while(t--)     { char tomar[20]; // max 15 digits         long long n,k,hue1,hue2,number;         scanf("%lld %lld",&n,&k);         hue1=k;         for(i=1;i<=16;i++)         {             hue1=hue1-9*(pow(10,i-1))*i;             if(hue1<=0)                 break;         }         hue1+=9*pow(10,i-1)*i;          /* try to read through next 4-5 lines to understand the concept*/         /* now i'll try to find the number which contains that digit*/         /*  I know it consists of i digits so this number must be actually has to be greater than 10^(i-1) */         /* what i know now is it is greater than this number and it is hue1 number infront of last i-1 digit number */         /* now we notice something . if a number has i digits then last digit index/i is always greater than other */      /* example 133 [ 1-> index=1 so 1/3=0; 3-> index=2 so 2/3=0  index=3 3/3=1; wait what the fack */      /* so what we do is decrease there value by 1 [0/3=1/3=2/3=andaa] */       number=pow(10,i-1);        hue1--;        number+=hue1/i;        sprintf(tomar,"%lld",number);        printf("%c\n",*(tomar+hue1%i) );      }     return 0; } 
#include<cstdio> #include<vector> using namespace std; vector<int> v[202]; vector<int> vv; int cc; int mod=1000000007; int gcd(int a,int b) { 	if(b==0) return a; 	if(a<b) return gcd(b,a); 	 	return gcd(b,a%b); 	 } void proc(int x) { 	vv.clear(); 	 	for(int i=0;i<cc;i++) 	{ 		for(int j=0;j<v[i].size();j++) 		{ 			if(gcd(x,v[i][j])>1) 			{ 				vv.push_back(i); 				break; 			} 		} 	} } int get_long() { 	int r=vv[0]; 	int sz=v[vv[0]].size(); 	for(int i=1;i<vv.size();i++) 	{ 		if(sz<v[vv[i]].size()) 		{ 			r=vv[i]; 			sz=v[vv[i]].size(); 		} 	} 	 	return r; }  int get_max(int x) { 	int mx=v[x][0]; 	for(int i=1;i<v[x].size();i++) 	if(mx<v[x][i]) mx=v[x][i]; 	 	return mx; } int main() {  	 	int ntc; scanf("%d",&ntc); 	while(ntc--) 	{ 		 		 cc=0; 		int N; scanf("%d",&N); 		for(int i=0;i<202;i++) v[i].clear(); 		for(int i=0;i<N;i++) 		{ 			int t; scanf("%d",&t); 			proc(t); 			if(vv.size()==0)  			{ 				v[cc].push_back(t); 				cc++; 			} 			else 			{ 				 				int l=get_long(); 			//	printf("here %d  %d  %d  %d\n",t,vv.size(),l,vv[1]); 				 				v[l].push_back(t); 				 			//	printf("again  %d  %d  %d\n",vv.size(),vv[0],vv[1]); 				for(int i=0;i<vv.size()  ;i++) 				{ 					 					if(vv[i]==l) continue; 					//printf("hhh %d\n",i); 					int x=vv[i]; 					for(int j=0;j<v[x].size();j++)  					{ 						v[l].push_back(v[x][j]); 					 					} 					v[x].clear(); 					 				} 			} 		//	printf("after step  %d %d\n",v[0].size(),v[1].size()); 			 		} 		 		long long ans=1; 		 	//	printf("Checking %d %d \n",v[0].size(),v[1].size()); 		for(int i=0;i<cc;i++) 		{ 			if(v[i].size()>0) 			{ 				 				int tmp=get_max(i); 			//	printf("there  %d\n",tmp); 				ans=(ans*tmp)%mod; 			} 		} 		printf("%lld\n",ans); 	} 	 } 
#include<bits/stdc++.h> #define pb(x) push_back(x) #define all(x) x.begin(), x.end() #define cout2(x, y) cout << x << " " << y <<  endl   using namespace std;   #define MOD 1000000007 #define SIZE 6   struct Matrix {     long long X[SIZE][SIZE];           Matrix () {}     Matrix (int k)     {         memset(X, 0, sizeof(X));                   for(int i=0; i<SIZE; i++)             X[i][i] = k;     } };   Matrix operator *(Matrix &A, Matrix &B) {     Matrix M;           for(int i=0; i<SIZE; i++)     {         for(int j=0; j<SIZE; j++)         {             long long tmp = 0;             for(int k=0; k<SIZE; k++) 			{                 tmp += (A.X[i][k] * B.X[k][j])%MOD;                 tmp %= MOD;             }                          M.X[i][j] = tmp;         }     }           return M; }   Matrix pow(Matrix x, long long n) {     Matrix P(1);           while(n)     {         if(n & 1) P = P * x;                   n >>= 1;         x = x * x;     }           return P; }    long long F[7];  int main(){  	int tc = 0; 	scanf("%d", &tc); 	 	while(tc--){ 		 		int n; 		scanf("%d", &n); 		 		Matrix M; 		memset(M.X, 0, sizeof M.X); 		 		for(int i = 0; i < 5; i++)scanf("%lld", &M.X[0][i]), M.X[0][i] = (M.X[0][i]%MOD + MOD)%MOD; 		for(int i = 0; i < 4; i++)scanf("%lld", &F[i]), F[i] = (F[i]%MOD + MOD)%MOD; F[4] = 1; 		 		swap(F[4], M.X[0][4]); 		reverse(F, F + 4); 		 		for(int i = 1; i < 4; i++)M.X[i][i - 1] = 1; 		M.X[4][4] = 1; 		 		M = pow(M, n - 4); 		 		long long ans = 0;	 		for(int i = 0; i < 5; i++)ans = (ans + M.X[0][i] * F[i])%MOD;	 		 		printf("%lld\n", ans); 				 	} 	 }   
// waMachine #include <bits/stdc++.h> using namespace std; typedef long long int ll; const int mod = 1e9+7; ll dp[33][33][33][33]; int arr[33][33]; ll E[33][33],F[33][33]; inline ll solve_top(int pos,int l,int r,int d){   return d*(E[pos][r]-E[pos][l-1]); } inline ll solve_bot(int pos,int l,int r,int d){   return d*(E[pos][r]-E[pos][l-1]); } inline ll solve_lft(int pos,int l,int r,int d){  return d*(F[r][pos]-F[l-1][pos]); } inline ll solve_rgt(int pos,int l,int r,int d){  return d*(F[r][pos]-F[l-1][pos]); } ll solve(int rt,int rb,int cl,int cr,int d){   //cout << rt << " " << rb << " " << cl << " " << cr << endl;   if(rt>rb || cl>cr) return 0;   if(dp[rt][rb][cl][cr] != -1) return dp[rt][rb][cl][cr];   ll a = solve_top(rt,cl,cr,d) + solve(rt+1,rb,cl,cr,d+1);   ll b = solve_bot(rb,cl,cr,d) + solve(rt,rb-1,cl,cr,d+1);   ll c = solve_lft(cl,rt,rb,d) + solve(rt,rb,cl+1,cr,d+1);   ll e = solve_rgt(cr,rt,rb,d) + solve(rt,rb,cl,cr-1,d+1);   ll res = max(max(max(a,b),c),e);   dp[rt][rb][cl][cr] = res;   return res; } int main(){   //freopen("qns.txt","r",stdin);   //freopen("ans.txt","w",stdout);   int t,n,m;   scanf("%d",&t);   while(t--){    memset(dp,-1,sizeof dp);    scanf("%d %d",&n,&m);    for(int i=1;i<=n;i++){     for(int j=1;j<=m;j++){       scanf("%d",&arr[i][j]);     }    }    for(int i=1;i<=n;i++){     for(int j=1;j<=m;j++){       E[i][j] = E[i][j-1] + arr[i][j];       F[i][j] = F[i-1][j] + arr[i][j];     }    }    ll ans = solve(1,n,1,m,1);    printf("%lld\n",ans);   }   return 0; }
#include<stdio.h> #include<math.h> long long p[1000010]; inline long long inp( ) { long long n=0; char ch=getchar_unlocked(); while( ch >47 ) n = (n<<3)+(n<<1) + ch-48, ch=getchar_unlocked(); return n; } int main() {     long long i,n,t,j,N=1000009,l;     p[0]=p[1]=1;     l=(long long)sqrt(N);     for(i=2;i<=l;i++)     if(p[i]==0)     for(j=i+i;j<N;j+=i)     p[j]=1;     scanf("%lld",&t);     while(t--)     {        scanf("%lld",&n);         i=(long long)sqrt(n);         if((1LL*i*i)==n&&p[i]==0)         printf("YES\n");         else         printf("NO\n");     }     return 0; } 
#include<iostream> #include<bits/stdc++.h> #include<stdio.h> #include<string>  #define lld long long int #define d int using namespace std;  int main() {     lld t,n,i,j,a[10000];     cin>>t;     while(t--)     {         lld neg=0,pos=0;         cin>>n;         for(i=0; i<n; i++)           {             cin>>a[i];             if(a[i]==-1)                 neg++;             else                 pos++;           }         for(i=0; i<neg; i++)           {              a[i]=(-1);           }         for(j=i; j<n; j++)           {             a[j]=1;           }         for(i=0; i<n; i++)         {             cout<<a[i]<<" ";         }         cout<<"\n";     }     return 0; }  
#include<iostream> #include<vector> #include<string.h> #include<stdio.h> #include<climits> #include<map> #include<math.h> #include<set> #include<algorithm> #define LL long long int #define P(N) printf("%d\n",N); #define S(N) scanf("%d",&N); #define SL(N) scanf("%lld",&N); #define pb push_back #define mp make_pair #define pnl printf("\n"); #define FOR(i,a,b) for (i=a;i<=b;i++) #define mem(a,val) memset(a,val,sizeof(a)) using namespace std; int gcd(int a, int b){ int temp; while(b>0)	{ temp= b; b=a%b; a=temp;}	return a;} vector<LL>vec; int length(LL num) {     if(num==0)return 1;     int cnt=0;     while(num>0)     {         cnt++; num/=10;     }     return cnt; } void precompute() {     int l;     LL maxm= 1000000000000000000LL;     LL next_num;     for(int i=0;i<10;i++)vec.pb(i);     for(int i=0;i<vec.size();i++)     {         l= length(vec[i]);         if(l==1) l++;         for(int j=l;j<=l+2;j++)         {                 next_num= vec[i]*j;                 if(next_num>maxm)break;                 if(length(next_num)==j)                         vec.pb(next_num);         }     }     return; } int main() {        #ifndef ONLINE_JUDGE        //     freopen("C:\\Users\\hp pc\\Desktop\\input.txt", "r", stdin);       #endif       precompute();       int i,j,t;       S(t);       LL X,Y;       int len =vec.size();       while(t--)       {          scanf("%lld %lld",&X,&Y);          int cnt=0;          for(int i=0;i<len;i++)          {              if(vec[i]>=X && vec[i]<=Y)cnt++;          }          P(cnt)       } return 0; } 
#include <iostream> #include <bits/stdc++.h> #include<cmath> #include<cstring> #include<map> #include<cctype> #include<vector> #include<algorithm>                         using namespace std; #define pb push_back #define pob pop_back #define pf push_front #define pof pop_front #define mp make_pair #define f(i,a,b) for(int i=a;i<b;i++) #define Sd(a) scanf("%d",&a); #define Ss(a) scanf("%s",&a);  using namespace std;  int main() { 	int t; 	scanf("%d",&t); 	cin.ignore(); 	t; 	while(t--) 	{ 		string cc; 		 		getline(cin,cc); 		//cout<<cc<<" "; 		//cout<<cc; 		int kk=cc.size(); 		//cout<<kk<<" "; 		for(int i=0;i<kk;i++){ 			if('A'<=cc[i]<'z'){ 				if('A'<=cc[i] && cc[i]<'Z'){cc[i]+=1;cout<<cc[i];} 			else if('a'<=cc[i] && cc[i]<'z'){cout<<++cc[i];} 			else if(cc[i]=='z'){cout<<"a";} 			else if(cc[i]=='Z'){cout<<"A";} 			} 			else{ 				continue; 			} 		} 		 		cout<<"\n"; 	}     return 0; }
    #include <cstdio>     #include <algorithm>     #include <cstdlib>     using namespace std;           #define N 100010           int h[N], parent[N][20], dmax[N], droot[N], diameter[N], radius[N], end[N];     int n, tote, height;           struct edge{     	int t, l, n;     }e[N * 2];           void adde(int u, int v, int l) {     	e[++tote].t = v;     	e[tote].l = l;     	e[tote].n = h[u];     	h[u] = tote;     	return ;     }           void dfs1(int u) {     	for (int i = h[u]; i; i = e[i].n) {     		int v = e[i].t;     		if (v == parent[u][0]) continue;     		parent[v][0] = u;     		dfs1(v);     	}     	return ;     }           void dfs2(int u) {     	int dmax2 = 0;     	dmax[u] = diameter[u] = radius[u] = 0;         end[u] = u;         for (int i = h[u]; i; i = e[i].n) {         	int v = e[i].t, l = e[i].l;         	if (parent[u][0] == v) continue;         	droot[v] = droot[u] + l;             dfs2(v);             if (diameter[v] > diameter[u]) {             	diameter[u] = diameter[v];                 radius[u] = radius[v];	             }             if (dmax[v] + l >= dmax[u]) {             	dmax2 = dmax[u];                 dmax[u] = dmax[v] + l;                 end[u] = end[v];             }             else if (dmax[v] + l > dmax2)                 dmax2 = dmax[v] + l;         if (dmax[u] + dmax2 > diameter[u]) {             diameter[u] = dmax[u] + dmax2;         	int t = height, z = end[u];         	//while (parent[z][0] != 0 && (dmax2 + droot[parent[z][0]] - droot[u]) > (dmax[u] + dmax2) / 2) z = parent[z][0];         	while (t >= 0) {         		if (parent[z][t] != 0 && (dmax2 + droot[parent[z][t]] - droot[u]) > (dmax[u] + dmax2) / 2) z = parent[z][t];	         		t--;         	}         	int l1 = dmax2 + droot[z] - droot[u];         	int l2 = diameter[u] - (droot[parent[z][0]] - droot[u]) - dmax2;             radius[u] = min(l1, l2);         }       }         return ;     }           int main() {     	int test;     	scanf("%d\n", &test);     	for (int t = 1; t <= test; t++) {     	scanf("%d",&n);     	tote = 0;     	for (int i = 1; i <= n; i++) h[i] = parent[i][0] = 0;     	for (int i = 1; i < n; i++) {     		int u, v, l;     		scanf("%d%d%d", &u, &v, &l);     		adde(u, v, l); adde(v, u, l);     	}           	dfs1(1);     	     	for (int i = 1; i <= 17; i++) {     		bool flag = false;     		for (int j = 1; j <= n; j++) {     			parent[j][i] = parent[parent[j][i - 1]][i - 1];     			if (parent[j][i] != 0) flag = true;     		}           		if (!flag) {     			height = i;     			break;     		}     	}           	dfs2(1);     	     	for (int i = 1; i <= n; i++) printf("%d\n", radius[i]);     	     	}     	return 0;     } 
#include <iostream> #include<bits/stdc++.h> using namespace std;  int main() {     int t,n,i,j,m,f;     int arr[1000];     scanf("%d",&t);     while(t--)     {         scanf("%d %d %d",&f,&n,&m);         for(i=0;i<f;i++)         {             scanf("%d",&arr[i]);         }         sort(arr,arr+f);         int mn=arr[0];         arr[f]=m;         for(i=1;i<=f;i++)         {             if(mn>arr[i]-arr[i-1])             {                 mn=arr[i]-arr[i-1];             }         }         printf("%d\n",mn*n);     }     return 0; } 
#include <bits/stdc++.h>  using namespace std;  long long L,R,INF; long long karp[100007]; long long hopcroft[100007]; long long ar[100007],pr[100007],X[10000],XX[10000],Y[10000],YY[10000]; vector<long long> adj[100007];   bool Bfs() {     queue<long long> q;     long long i;     for( i=1;i<=L;i++)     {         if( hopcroft[i] ) karp[i] = INF;         else         {             karp[i] = 0;             q.push( i );         }     }     karp[0] = INF;     while( !q.empty())     {         long long u = q.front();         q.pop();         for( i=0;i<adj[u].size();i++)         {             long long v = adj[u][i];             if( karp[hopcroft[v]] == INF )             {                 karp[hopcroft[v]] = karp[u] + 1;                 q.push( hopcroft[v] );             }         }     }     return karp[0] != INF; } bool Dfs( long long u ) {     if( !u ) return true;     long long i;     for( i=0;i<adj[u].size();i++)     {         long long v = adj[u][i];         if( karp[hopcroft[v]]==karp[u]+1 && Dfs( hopcroft[v] ))         {             hopcroft[u] = v;             hopcroft[v] = u;             return true;         }     }     karp[u] = INF;     return false; }  double dist(long long i,long long j) {     double q,w;     q=X[i]-XX[j];     w=Y[i]-YY[j];     return q*q+w*w; }  int main() {     double low,high,mid;     long long i,j,k,l,cnt,ans,test,q,w,e,r,n,m;      cin>>n>>m;      for(i=1;i<=n;i++)     {         cin>>X[i]>>Y[i];     }      for(i=1;i<=n;i++)     {         cin>>XX[i]>>YY[i];     }      low=0;     high=1e10;      cnt=0;      while(cnt<=200)     {         cnt++;         mid=low+high;         mid/=2;          for(i=0;i<=2*n+5;i++)         {             karp[i]=0;             hopcroft[i]=0;             adj[i].clear();         }          for(i=1;i<=n;i++)         {             for(j=1;j<=n;j++)             {                 if(dist(i,j)>mid*mid)                 {                     adj[i].push_back(j+n);                     adj[j+n].push_back(i);                 }             }         }          L=n;         R=n;          long long Ans = 0;         while( Bfs())         {             for( i=1;i<=L;i++)             {                 if( hopcroft[i] ) continue;                 if( Dfs( i ))                 {                     Ans++;                 }             }         }          if(2*n-Ans>=m) high=mid;         else low=mid;     }      printf("%.10lf\n",mid); } 
#include <bits/stdc++.h>  using namespace std;  #define double long double  long long X[1000009],Y[1000009]; vector<pair<long long,long long> >vec; map<pair<long long,long long> , long long >mymap; long long A,N,M;  long long get(long long n,long long m) {     if(n-A+1<=0 || m-A+1<=0) return 0;     return (n-A+1)*(m-A+1); }  long long check(long long i,long long j) {     if(i+1>N || i<0) return 0;     if(j+1>M || j<0) return 0;     return 1; }  int main() {     long long n,m,a,c,i,x,y,tot,totsq,q,w,e,r,temp;     double now,ans=0,tata,pi=acos(-1.0);      scanf("%lld%lld%lld%lld",&n,&m,&a,&c);     N=n;     M=m;     A=a;      for(i=1;i<=c;i++)     {         scanf("%lld%lld",&X[i],&Y[i]);          mymap[make_pair(X[i],Y[i])]=1;          if(check(X[i],Y[i])) vec.push_back(make_pair(X[i],Y[i]));         if(check(X[i]-1,Y[i])) vec.push_back(make_pair(X[i]-1,Y[i]));         if(check(X[i],Y[i]-1)) vec.push_back(make_pair(X[i],Y[i]-1));         if(check(X[i]-1,Y[i]-1)) vec.push_back(make_pair(X[i]-1,Y[i]-1));     }      tot=vec.size();      totsq=get(n,m);     tata=pi/12.0;     tata+=sqrt(3.0)/8.0;     tata*=2;     //cout<<totsq<<endl;     //cout<<tata<<endl;     //tata*=2;      sort(vec.begin(),vec.end());      for(i=0;i<tot;i++)     {         //cout<<vec[i].first<<" "<<vec[i].second<<endl;         if(i)         {             if(vec[i]==vec[i-1]) continue;         }          //cout<<vec[i].first<<" "<<vec[i].second<<endl;          x=vec[i].first;         y=vec[i].second;         q=mymap[make_pair(x,y)];         w=mymap[make_pair(x,y+1)];         e=mymap[make_pair(x+1,y)];         r=mymap[make_pair(x+1,y+1)];          //cout<<q<<" "<<w<<" "<<e<<" "<<r<<" ";          temp=totsq-get(x,m)-get(y,n)-get(m-y-1,n)-get(n-x-1,m)+get(x,y)+get(m-y-1,x)+get(m-y-1,n-x-1)+get(n-x-1,y);         //cout<<temp<<" ";          if(q+w+e+r>=3) now=temp*1.0;         else if(q+w+e+r>=2)         {             if(q+r>=2 || w+e>=2) now=temp*1.0;             else now=temp*tata;         }         else now=temp*pi/4.0;          ans+=now;         //cout<<now<<" u \n";      }      //cout<<ans<<endl;      //cout<<a*a*totsq<<endl;      ans=ans/(totsq);      cout<<std::setprecision(10)<<fixed<<ans<<endl;  } 
#include <cstdio> #include <cstdlib> #include <cstring> #include <algorithm> #include <vector> using namespace std;  const int N = 5e5 + 10; const int Q = 1e5 + 10;  const int LOG = 20;  #define left LEFt #define right RIGHT #define index INDEX #define copy COPY  vector<int> edge[N]; int n, m; int father[N][LOG], left[N], right[N], dep[N];  void get_dfs_order() { 	vector<pair<int, int> > stack; 	stack.push_back(make_pair(1, 0)); 	father[1][0] = 0; 	 	int index = 0; 	left[1] = ++index; 	dep[1] = 0; 	while (stack.size()) { 		int x = stack.back().first, e = stack.back().second; 		stack.pop_back(); 		if (e == edge[x].size()) { 			right[x] = index; 			continue; 		} 		int y = edge[x][e++]; 		stack.push_back(make_pair(x, e)); 		if (y == father[x][0]) { 			continue; 		} else { 			left[y] = ++index; 			dep[y] = dep[x] + 1; 			stack.push_back(make_pair(y, 0)); 			father[y][0] = x; 		} 	} 	 	for (int i = 0; i + 1 < LOG; i++) { 		for (int j = 1; j <= n; j++) { 			father[j][i + 1] = father[father[j][i]][i]; 		} 	} }  const int POOL = (int)(Q * 0.55 * LOG * LOG * 4);  struct Node { 	int lchild, rchild, sum; 	Node(int lchild, int rchild, int sum) : lchild(lchild), rchild(rchild), sum(sum) { 	} 	Node() {} }pool[POOL]; int used = 0;  int copy;  int build_inner(int l, int r) { 	int x = used++; 	Node& tmp = pool[x]; 	if (l == r) { 		tmp.sum = 0; 		tmp.lchild = tmp.rchild = -1; 	} else { 		int mid = (l + r) >> 1; 		tmp = Node(build_inner(l, mid), build_inner(mid + 1, r), 0); 	} 	return x; }  struct ONode { 	int lchild, rchild, root; 	ONode(int lchild, int rchild, int root) : lchild(lchild), rchild(rchild), root(root) {} 	ONode() {} }Opool[Q * LOG * 4]; int Oused = 0;  int root[Q];  int build_outter(int l, int r) { 	int x = Oused++; 	ONode& tmp = Opool[x]; 	if (l == r) { 		tmp.root = copy; 		tmp.lchild = tmp.rchild = -1; 	} else { 		int mid = (l + r) >> 1; 		tmp = ONode(build_outter(l, mid), build_outter(mid + 1, r), copy); 	} 	return x; }  struct Query { 	int type, u, v, w, k; 	Query() {} }query[Q];  int get_lca(int u, int v) { 	if (dep[u] < dep[v]) { 		swap(u, v); 	} 	for (int i = LOG - 1; i >= 0; i--) { 		if (dep[u] - (1 << i) >= dep[v]) { 			u = father[u][i]; 		} 	} 	if (u == v) { 		return u; 	} 	for (int i = LOG - 1; i >= 0; i--) { 		if (father[u][i] != father[v][i]) { 			u = father[u][i]; 			v = father[v][i]; 		} 	} 	return father[u][0]; }  int insert_inner(int rt, int l, int r, int pos, int delta) { 	int x = used++; 	Node& tmp = pool[x]; 	tmp = pool[rt]; 	 	tmp.sum += delta; 	 	if (l == r) { 		return x; 	} else { 		int mid = (l + r) >> 1; 		if (pos <= mid) { 			tmp.lchild = insert_inner(tmp.lchild, l, mid, pos, delta); 		} else { 			tmp.rchild = insert_inner(tmp.rchild, mid + 1, r, pos, delta); 		} 	} 	return x; }  int insert(int rt, int l, int r, int pos, int w, int delta) { 	int x = Oused++; 	ONode& tmp = Opool[x]; 	tmp = Opool[rt]; 	 	tmp.root = insert_inner(tmp.root, 0, m - 1, w, delta); 	 	if (l == r) { 		return x; 	} 	 	int mid = (l + r) >> 1; 	if (pos <= mid) { 		tmp.lchild = insert(tmp.lchild, l, mid, pos, w, delta); 	} else { 		tmp.rchild = insert(tmp.rchild, mid + 1, r, pos, w, delta); 	} 	return x; }  void get_node(int x, int l, int r, int ql, int qr, vector<int> &ret) { 	if (r < ql || qr < l) { 		return; 	} 	if (ql <= l && r <= qr) { 		ret.push_back(Opool[x].root); 		return ; 	} 	int mid = (l + r) >> 1; 	get_node(Opool[x].lchild, l, mid, ql, qr, ret); 	get_node(Opool[x].rchild, mid + 1, r, ql, qr, ret); }  int solve(int l, int r, int x, int k) { 	static vector<int> rnode, lnode; 	rnode.clear(); get_node(root[r], 1, n, left[x], right[x], rnode); 	lnode.clear(); get_node(root[l - 1], 1, n, left[x], right[x], lnode); 	 	{ 		int tot = 0; 		for (int i = 0; i < rnode.size(); i++) tot += pool[rnode[i]].sum; 		for (int i = 0; i < lnode.size(); i++) tot -= pool[lnode[i]].sum; 		if (tot < k) { 			return -1; 		} 	} 	 	int lv = 0, rv = m - 1; 	while (lv < rv) { 		int lsum = 0, dir = 0; 		for (int i = 0; i < rnode.size(); i++) lsum += pool[pool[rnode[i]].lchild].sum; 		for (int i = 0; i < lnode.size(); i++) lsum -= pool[pool[lnode[i]].lchild].sum; 		int mid = (lv + rv) >> 1; 		if (lsum < k) { 			k -= lsum; 			dir = 1; 			lv = mid + 1; 		} else { 			dir = 0; 			rv = mid; 		} 		 		for (int i = 0; i < rnode.size(); i++) { 			rnode[i] = dir ? pool[rnode[i]].rchild : pool[rnode[i]].lchild; 		} 		for (int i = 0; i < lnode.size(); i++) { 			lnode[i] = dir ? pool[lnode[i]].rchild : pool[lnode[i]].lchild; 		} 	} 	return lv; }  int main() { 	scanf("%d", &n); 	for (int i = 1; i < n; i++) { 		int u, v; 		scanf("%d %d", &u, &v); 		edge[u].push_back(v); 		edge[v].push_back(u); 	} 	 	get_dfs_order(); 	 	vector<int> values; 	 	int q; 	scanf("%d", &q); 	for (int i = 1; i <= q; i++) { 		int type; 		scanf("%d", &type); 		query[i].type = type; 		if (type == 1) { 			int u, v, w; 			scanf("%d %d %d", &u, &v, &w);	 			query[i].u = u; 			query[i].v = v; 			query[i].w = w; 			values.push_back(w); 		} else { 			int x, l, r, k; 			scanf("%d %d %d %d", &x, &l, &r, &k); 			query[i].u = l; 			query[i].v = r; 			query[i].k = k; 			query[i].w = x; 		} 	} 	 	sort(values.begin(), values.end()); 	values.erase(unique(values.begin(), values.end()), values.end()); 	m = values.size(); 	 	copy = build_inner(0, m - 1); 	root[0] = build_outter(1, n); 	 	for (int i = 1; i <= q; i++) { 		if (query[i].type == 1) { 			int u = query[i].u; 			int v = query[i].v; 			int w = query[i].w; 			w = lower_bound(values.begin(), values.end(), w) - values.begin(); 			int lca = get_lca(u, v); 			if (dep[u] > dep[v]) swap(u, v); 			 			root[i] = insert(root[i - 1], 1, n, left[v], w, 1); 			if (u != lca) { 				root[i] = insert(root[i], 1, n, left[u], w, 1); 				root[i] = insert(root[i], 1, n, left[lca], w, -1); 			} 			if (father[lca][0]) root[i] = insert(root[i], 1, n, left[father[lca][0]], w, -1); 		} else { 			int l = query[i].u; 			int r = query[i].v; 			int x = query[i].w; 			int k = query[i].k; 			root[i] = root[i - 1]; 			int ret = solve(l, r, x, k); 			printf("%d\n", ret == -1 ? ret : values[ret]); 		} 	} 	 	return 0; }
#include<bits/stdc++.h> using namespace std;   vector< vector<int> > graph(100005);  pair<int,int> tree[100005]={make_pair(0,0)};  int marked[100005]={0};  void traverse(int index) {	int count=1; 	int max_height=0; 	marked[index]=1; 	for(int i=0;i<graph[index].size();i++) 	{	int child = graph[index][i]; 		if(marked[child]==0) 		{	traverse(child); 			if(tree[child].first>=max_height) 			{	if(max_height==tree[child].first) 				{	count+=tree[child].second;	 				} 				else 				{	count=tree[child].second; 				} 				max_height=tree[child].first; 				 			} 		} 	} 	tree[index]=make_pair(max_height+1,count); 	 }   pair<int,int> number[100005]={make_pair(0,0)};  int checked[100005]={0};  void travelDown(int index, pair<int,int> num) {	checked[index]=1; 	pair<int,int> myHite =  tree[index]; 	if(myHite.first==num.first) 	{	number[index]=make_pair(myHite.first,myHite.second+num.second); 	} 	else if(myHite.first>num.first) 	{	number[index]=make_pair(myHite.first,myHite.second); 	} 	else if(myHite.first<num.first) 	{	number[index]=make_pair(num.first,num.second); 	} 	 	int childhood=0; 	int max1=-2; 	int second=0; 	for(int i=0;i<graph[index].size();i++) 	{	int child = graph[index][i]; 		if(checked[child]==0) 		{ 			if(tree[child].first!=myHite.first-1&&tree[child].first>=max1) 		{	if(max1==tree[child].first) 			{	second+=tree[child].second; 			} 			else 			{	second=tree[child].second; 			} 			max1=tree[child].first; 			 		} 		else if(tree[child].first==myHite.first-1) 		{	childhood++; 		} 		} 	} 	max1++; 	//cout<<index<<" res "<<num.first<<" "<<num.second<<" "<<max1<<" "<<second<<endl; 	for(int i=0;i<graph[index].size();i++) 	{	int child = graph[index][i]; 		if(checked[child]==0) 		{ 			if(tree[child].first!=myHite.first-1) 			{	pair<int,int> down = make_pair(number[index].first+1,number[index].second); 				 //cout<<child<<" "<<down.first<<" 2 "<<down.second<<endl; 				travelDown(child,down); 			} 			else if(tree[child].first==myHite.first-1) 			{	pair<int,int> down; 				if(childhood>1) 				{	 					 if(myHite.first==number[index].first)down = make_pair(number[index].first+1,number[index].second-tree[child].second); 					 else down = make_pair(number[index].first+1,number[index].second); 				//	cout<<child<<" "<<down.first<<" 1 "<<down.second<<endl;	 					travelDown(child,down); 				} 				else 				{ 					{	if(max1+1==num.first+1) 						{	down = make_pair(num.first+1,second+num.second); 						} 						else if(max1+1>num.first+1) 						{	down = make_pair(max1+1,second); 						} 						else if(max1+1<num.first+1) 						{		down = make_pair(num.first+1,num.second); 						} 					} 				//	cout<<child<<" "<<down.first<<" 3 "<<down.second<<endl; 					travelDown(child,down); 				} 		} 	} 	} 	 }  int main() {	 int n; 	scanf("%i",&n); 	 for(int i=0;i<n-1;i++) 	 {	int r1,r2; 	 	scanf("%i%i",&r1,&r2); 	 	graph[r1+1].push_back(r2+1); 	 	graph[r2+1].push_back(r1+1); 	 } 	 traverse(1); 	 	 travelDown(1,make_pair(1,1)); 	  	  	  for(int i=1;i<=n;i++) 	 {	printf("%i ",number[i].second); 	 	 	 } 	 printf("\n");  }   
#include <bits/stdc++.h> using namespace std;  //freopen("in.txt","r",stdin);  FILE-IO  //fclose(stdin);        FILE-IO //srand (time(NULL));       RANDOM NUMBERS  #define sd(a) scanf("%d",&a) #define pd(a) prlong longf("%lld\n",(a)) #define clr(a) memset(a,0,sizeof(a)) #define LL long long #define F first #define S second #define MP make_pair #define PB push_back #define eps 0.00000000001 long double s[100010]; long double d[100010]; int n; long double f(long double x) { 	int i; 	long double minn=1e18; 	long double maxx=-1; 	for(i=0;i<n;++i) 	{ 		long double val=s[i]*x+d[i]; 		minn=min(minn,val); 		maxx=max(maxx,val); 	} 	return (maxx-minn); } long double ternary(long double l,long double r) { 	if(r-l<eps) 		return (l+r)/2; 	long double lt=(2*l+r)/3; 	long double rt=(l+2*r)/3; 	if(f(lt)>f(rt)) 		return ternary(lt,r); 	else 		return ternary(l,rt); } int main() { 	int k,i; 	sd(n); 	sd(k); 	for(i=0;i<n;++i) 	{ 		scanf("%Lf",&s[i]); 		scanf("%Lf",&d[i]); 	} 	cout<<setprecision(6)<<fixed<<f(ternary(0,k))<<endl; }
#include<stdio.h> #include<iostream> #include<vector> #include<string.h> #include<algorithm> #include<deque> #include<map> #include<set> #include<stdlib.h> #include<math.h> #include<queue> #include<stack> #include<functional> using namespace std; #define LL long long #define si(x) scanf("%d",&x) #define sc(x) scanf("%c",&x) #define sl(x) scanf("%I64d",&x) #define all(x) x.begin(),x.end() #define compress(x) {sort(all(x));(x).resize(unique(all(x))-(x).begin());} template<class T> inline void umax(T &a,T b){if(a<b) a = b ;} typedef pair<int, int> ii; typedef pair<LL, LL> PII; typedef pair<ii, int> iii; typedef pair<ii, ii> iiii; #define vl vector<> #define vi vector<int> #define vii vector<ii> #define vvl vector< vl > #define vvi vector< vi > #define vvii vector< vii > #define sz size() #define pb push_back #define F first #define S second #define mem(x,y) memset(x,y,sizeof(x)) #define rep(i,a,b) for(int i=(a);i<(b);i++) #define repv(i,b,a) for(int i=(b);i>=(a);i--) #define mod 1000000007 #define pb push_back #define mp make_pair #define PDD pair<LL, LL> #define LLD long double  const int maxn = 5000 + 2; const int INF  = 1e9 + 7; //const LL INF = 0x0123456789ABCDEFLL; LL modpow(LL base, LL exponent,LL modulus){     if(base==0&&exponent==0)return 0;     LL result = 1;     while (exponent > 0){         if (exponent % 2 == 1)             result = (result * base) % modulus;         exponent = exponent >> 1;         base = (base * base) % modulus;     }     return result; } LL mod1(LL a, LL b) {   return ((a%b)+b)%b; } LL extended_euclid(LL a, LL b, LL &x, LL &y) {     LL xx = y = 0;   LL yy = x = 1;   while (b) {     LL q = a/b;     LL t = b; b = a%b; a = t;     t = xx; xx = x-q*xx; x = t;     t = yy; yy = y-q*yy; y = t;   }   return a; } LL mod_inverse(LL a, LL n) {   LL x, y;   LL d = extended_euclid(a, n, x, y);   if (d > 1) return -1;   return mod1(x,n); }  LL solve(LL a, LL b , LL m){  // returns x such that a^x is congruent to b mod m       LL X = sqrt(m+1) , val , tmp;      map<LL , LL> p1 , idx;      val  = 1;      for(int i=0;i<=X+1;i++){          p1[val] = 1;          idx[val] = i;          val  = (val * a)%m;      }      LL inv  = mod_inverse(modpow(a , X , m) , m);      LL mul =  b;      for(int i=0;i<=X+1;i++){         if(p1[mul] > 0){         if(i >0 || idx[mul] > 0)         return  X * i + idx[mul];         }         mul = (mul * inv)%m;      }      return -1; } inline void solve(void){         int t;         cin >> t;         while(t--){             LL a, c , m , k;             cin >> a >> c >> m >> k;             if(m==1){              }             LL x = solve(a , c , m);             LL d = solve(a , 1 , m);             if(x==-1 || d==-1   ){                 cout <<"0\n";                 continue;             }             LL ret = ( (2 * x)%mod + ((k - 1) * d)%mod)%mod;             ret = (ret * k)%mod;             ret = (ret  * modpow(2 ,mod-2,mod))%mod;             cout << ret <<"\n";         }             } /*void init() {     ios::sync_with_stdio(false);     cin.tie(nullptr); }*/ int main(int argc, const char * argv[]){     //freopen("positive.in","r",stdin);     //freopen("positive.out","w",stdout);    // init();     solve();     return 0; }
/* Author :  ARVIND PANDEY  */ #include <iostream> #include <cstdio> #include <climits> #include <cstring> #include <algorithm> #include <string.h> #include <stdlib.h> #include <cmath> #include <vector> #include <stack> #include <queue> #include <map> #include <set>  using namespace std;  struct _ {     ios_base::Init i;      _() {         cin.sync_with_stdio(0);         cin.tie(0);     } } _;  #define FOR(i,a,b) for(i=a;i<b;i++) #define pb(x) push_back(x) #define ll long long #define mp make_pair  typedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pii> vii; typedef vector<vii> vvii;  ll power(ll a, ll n)//////             O(log n) {     ll ans = 1;     while (n) {         if (n % 2 == 1)             ans *= a;         a *= a;         n /= 2;     }     return ans; }  ll gcd(ll a, ll b)////                 O(log(a+b)) {     if (b==0)         return a;     return gcd(b,a%b); } ////////////////////////////////////////////////////////////////////////////////////CODE BEGINS/////////////////////////////////////////////////////////  int main()  { 	#ifndef ONLINE_JUDGE     freopen("inp.txt","r",stdin);     #endif      int t,i;     cin>>t;     while(t--)     {         int D;         string st,str;         cin>>st>>str>>D;         int ar[30],arr[30];         memset(ar,0,sizeof ar);         memset(arr,0,sizeof arr);         FOR(i,0,st.size())             ar[st[i]-97]++;         FOR(i,0,str.size())             arr[str[i]-97]++;          ll sum = 0;         FOR(i,0,26)         {             sum += abs(ar[i] - arr[i]);         }         if(sum <= D)             cout<<"YES\n";         else             cout<<"NO\n";     }      return 0; }
#include <bits/stdc++.h>  using namespace std;  const int maxn = 100100;  struct node{ 	int pt, cst; 	bool operator<(const node&n) const{ 		if(pt==n.pt) 			return cst<n.cst; 		return (pt<n.pt); 	} };  node arr[maxn]; vector<pair<int, int> >v; int cost[maxn], x[maxn], dp[maxn];  int main() { 	//freopen("input.txt", "r", stdin); 	int t, n, l, d, i, j, k, y, lo, hi, mid, oldk, p, r; 	scanf("%d", &t); 	while(t--){ 		v.clear(); 		scanf("%d%d%d", &n, &l, &d); 		for(i=1; i<=n; i++) 			scanf("%d%d", &arr[i].pt, &arr[i].cst), dp[i] = INT_MAX; 		dp[0] = x[0] = cost[0] = 0; 		sort(arr+1, arr+n+1); 		for(i=1; i<=n; i++){ 			x[i] = arr[i].pt; 			cost[i] = arr[i].cst; 			//cout << x[i] << " " << cost[i] << "\n"; 		} 		x[n+1] = l; 		cost[n+1] = 0; 		bool pos = true; 		for(i=1; i<=n+1; i++){ 			if(x[i]-x[i-1]>d){ 				pos = false; 				break; 			} 		} 		if(!pos){ 			printf("NO\n"); 			continue; 		} 		v.push_back(make_pair(0, 0)); 		for(i=1; i<=n+1; i++){ 			//cout << i << " " << v.size() << " "; 			k = (--lower_bound(v.begin(), v.end(), make_pair(i+1, 0)))->second; 			dp[i] = ((x[i]-x[k])<=d && (x[i]-x[k])>=0)?(dp[k]+cost[k]):INT_MAX; 			/*if(dp[i]==INT_MAX){ 				pos = false; 				break; 			}*/ 			//cout << k << " " << dp[i] << " "; 			for(j=v.size()-1; j>=0; j--){	 				y = v[j].first, oldk = v[j].second; 				p = ((x[y]-x[i])<=d && (x[y]-x[i])>=0)?dp[i]+cost[i]:INT_MAX; 				r = ((x[y]-x[oldk])<=d && (x[y]-x[oldk])>=0)?dp[oldk]+cost[oldk]:INT_MAX; 				//cout << y << " " << oldk << " " << p << " " << r << "\n"; 				if(y>i && (p<r)) 					v.pop_back(); 				else{ 					lo = y+1, hi = n+2; 					while(lo<hi){ 						mid = (lo+hi)>>1; 						p = ((x[mid]-x[i])<=d && (x[mid]-x[i])>=0)?(dp[i]+cost[i]):INT_MAX; 						r = ((x[mid]-x[oldk])<=d && (x[mid]-x[oldk])>=0)?(dp[oldk]+cost[oldk]):INT_MAX; 						if(p<=r) 							hi = mid; 						else 							lo = mid+1; 					} 					//cout << "T " << hi <<"\n"; 					if(hi!=n+2){ 						if((x[hi]-x[i])<=d && (x[hi]>=x[i])) 							v.push_back(make_pair(hi, i)); 					} 					break; 				} 			} 			//for(j=0; j<v.size(); j++) 			//	cout << "En " << v[j].first << " " << v[j].second << "\n"; 			//cout << "\n\n"; 			if(v.size()==0) 				v.push_back(make_pair(0, i)); 		} 		printf("YES %d\n", dp[n+1]); 	} 	return 0; }
#include <iostream> #include <cstdio> #include <vector> #include <string> #include <map> #include <cstring>  using namespace std;  #define si(a) scanf("%d",&a) #define f first #define s second #define MAX 10005  vector<int> graph[MAX]; int dp[MAX][2],hoite_hobe[MAX];  int go(int now,int wh) {     if(graph[now].size()==0){         return hoite_hobe[now]!=wh;     }     int &ret=dp[now][wh];     if(ret!=-1)         return ret;     int tmp1=1,tmp2=0;     int i;     for(i=0;i<graph[now].size();i++){         int to=graph[now][i];         tmp1+=go(to,!wh);         tmp2+=go(to,wh);     }     return ret=min(tmp2,tmp1); }  map<string,int> all[MAX]; char str[1005]; bool vis[MAX];   void solve(void) {     memset(dp, -1, sizeof(dp));     memset(vis, 0, sizeof(vis));     int n,i,j;     si(n);     int cnt=1;     char ss[20];      for(i=0;i<n;i++){         scanf("%s",ss);         scanf("%s",str);         int len=strlen(str);         int pr = -1, prnd = 0;         for(j=0;j<=len;j++)             if(str[j] == '/' || j == len) {                 if(pr != -1) {                     string x(str, pr, j-pr);                     if(all[prnd].find(x) == all[prnd].end()) all[prnd][x] = cnt++;                     int nd = all[prnd][x];                     if(!vis[nd]) {                         graph[prnd].push_back(nd);                         //printf("add: %d to %d\n", prnd, all[x]);                     }                     prnd = nd;                     vis[prnd] = true;                 }                 pr = j+1;             }         hoite_hobe[prnd] = !strcmp(ss, "stage");     } /*     for(map <string, int>::iterator it = all.begin(); it != all.end(); it++) {         printf("%s %d\n", it->f.c_str(), it->s);     } */     printf("%d\n", go(0, 0));     //cout<<endl;     for(i = 0; i < cnt; i++) {         graph[i].clear();         all[i].clear();     } }  int main() {     //freopen("inp.txt", "r", stdin);     int t;     si(t);     while(t--) solve();      return 0; } 
#include <bits/stdc++.h> 	 using namespace std; 	 #ifndef ONLINE_JUDGE 	bool debug = false; #else 	bool debug = true; #endif 	 typedef long long unsigned llu; typedef long long lld; typedef long ld;   //definition   //macros #define vi  	vector < int > #define vld 	vector < ld > #define vlld 	vector < lld > #define vllu 	vector < llu > #define pii 	pair <int, int> #define plld 	pair<lld, lld> #define vpii 	vector< pii > #define vplld 	vector< plld >   #define gc  	getchar_unlocked #define pc  	putchar_unlocked #define rr  	freopen("input.txt", "r", stdin) #define wr  	freopen("output.txt", "w", stdout)   //important constants #define MOD 	1000000007 #define INF  	1LL<<57LL #define MAX 	1000001 #define pi  	M_PI #define ESP 	(1e-9)   //looping #define fr(i,a)         	for(i=0;i<a;i++) #define fe(i,a)         	for(i=0;i<=a;i++) #define fu(i,a,n)       	for(i=a;i<n;i++) #define fue(i,a,n)      	for(i=a;i<=n;i++) #define fd(i,n,a)       	for(i=n;i>a;i--) #define fde(i,n,a)      	for(i=n;i>=a;i--) #define tr(container, it)	for(typeof(container.begin()) it = container.begin(); it != container.end(); it++)   //input output #define sd(n) 		scanf("%d",&n) #define sld(n) 		scanf("%ld",&n) #define slld(n) 	scanf("%lld",&n) #define pfd(n) 		printf("%d",n) #define pfld(n) 	printf("%ld",n) #define pflld(n) 	printf("%lld",n)   //shortcut #define ff      	first #define ss      	second #define clr     	clear() #define pb      	push_back #define mp      	make_pair #define gcd(a,b)	__gcd(a,b) #define sz(a)		((int)(a.size())) #define len(a)		((int)a.length()) #define all(vi)		vi.begin(), vi.end() #define mem(i,n)	memset(i,n,sizeof(i)) #define IOS     	ios_base::sync_with_stdio(false); cin.tie(NULL)   #define imax 	numeric_limits<int>::max() #define imin 	numeric_limits<int>::min() #define ldmax 	numeric_limits<ld>::max() #define ldmin 	numeric_limits<ld>::min() #define lldmax 	numeric_limits<lld>::max() #define lldmin 	numeric_limits<lld>::min() //end of definition   const int dx[]={0,1,0,-1,1,1,-1,-1,0}; const int dy[]={1,0,-1,0,-1,1,1,-1,0};   template<typename X> inline X square(const X& a) { return a * a; }     //fast input   int scan_d()		{bool minus = false;int result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;} ld scan_ld()		{bool minus = false;ld result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;} lld scan_lld()		{bool minus = false;lld result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;} llu scan_llu()		{llu result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}return result;}   //end of fast input   //fast output   //no line break void print_d(int n)     	{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[10];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<10);} void print_ld(ld n)     	{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[11];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} void print_lld(lld n)     	{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);} void print_llu(llu n)     	{int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);}   //new line void println_d(int n)		{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} void println_ld(ld n)		{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);} void println_lld(lld n)		{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} void println_llu(llu n)		{int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);}   //special char char sp; void printsp_d(int n)		{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} void printsp_ld(ld n)		{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);} void printsp_lld(lld n)		{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} void printsp_llu(llu n)		{int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);}   //end of fast output  #define SSTR( x ) static_cast< std::ostringstream & >( \         ( std::ostringstream() << std::dec << x ) ).str()  lld dp[5005][5005],a[5005]; int n;  lld jump(int i,int x) { 	if(dp[i][x]!=-1) 		return dp[i][x]; 	if(i==x) 		return 0; 	if(i<x) 	{ 		dp[i][x]=jump(i,x-1); 		if(a[i]>a[x]) 			dp[i][x]=max(dp[i][x],1+jump(x,i+1)); 	} 	else 	{ 		dp[i][x]=jump(i,x+1); 		if(a[i]>a[x]) 			dp[i][x]=max(dp[i][x],1+jump(x,i-1)); 	} 	return dp[i][x]; }  int main() { 	sp=' '; 	mem(dp,-1); 	int i; 	n=scan_d(); 	fr(i,n) 		a[i]=scan_lld(); 	fr(i,n) 		printsp_lld(max(jump(i,0),jump(i,n-1))); 	return 0; } 
#include <bits/stdc++.h> 	 using namespace std; 	 #ifndef ONLINE_JUDGE 	bool debug = false; #else 	bool debug = true; #endif 	 typedef long long unsigned llu; typedef long long lld; typedef long ld;   //definition   //macros #define vi  	vector < int > #define vld 	vector < ld > #define vlld 	vector < lld > #define vllu 	vector < llu > #define pii 	pair <int, int> #define plld 	pair<lld, lld> #define vpii 	vector< pii > #define vplld 	vector< plld >   #define gc  	getchar_unlocked #define pc  	putchar_unlocked #define rr  	freopen("input.txt", "r", stdin) #define wr  	freopen("output.txt", "w", stdout)   //important constants #define MOD 	1000000007 #define INF  	1LL<<57LL #define MAX 	1000001 #define pi  	M_PI #define ESP 	(1e-9)   //looping #define fr(i,a)         	for(i=0;i<a;i++) #define fe(i,a)         	for(i=0;i<=a;i++) #define fu(i,a,n)       	for(i=a;i<n;i++) #define fue(i,a,n)      	for(i=a;i<=n;i++) #define fd(i,n,a)       	for(i=n;i>a;i--) #define fde(i,n,a)      	for(i=n;i>=a;i--) #define tr(container, it)	for(typeof(container.begin()) it = container.begin(); it != container.end(); it++)   //input output #define sd(n) 		scanf("%d",&n) #define sld(n) 		scanf("%ld",&n) #define slld(n) 	scanf("%lld",&n) #define pfd(n) 		printf("%d",n) #define pfld(n) 	printf("%ld",n) #define pflld(n) 	printf("%lld",n)   //shortcut #define ff      	first #define ss      	second #define clr     	clear() #define pb      	push_back #define mp      	make_pair #define gcd(a,b)	__gcd(a,b) #define sz(a)		((int)(a.size())) #define len(a)		((int)a.length()) #define all(vi)		vi.begin(), vi.end() #define mem(i,n)	memset(i,n,sizeof(i)) #define IOS     	ios_base::sync_with_stdio(false); cin.tie(NULL)   #define imax 	numeric_limits<int>::max() #define imin 	numeric_limits<int>::min() #define ldmax 	numeric_limits<ld>::max() #define ldmin 	numeric_limits<ld>::min() #define lldmax 	numeric_limits<lld>::max() #define lldmin 	numeric_limits<lld>::min() //end of definition   const int dx[]={0,1,0,-1,1,1,-1,-1,0}; const int dy[]={1,0,-1,0,-1,1,1,-1,0};   template<typename X> inline X square(const X& a) { return a * a; }     //fast input   int scan_d()		{bool minus = false;int result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;} ld scan_ld()		{bool minus = false;ld result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;} lld scan_lld()		{bool minus = false;lld result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}if (ch == '-') minus = true; else result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}if (minus) return -result; else return result;} llu scan_llu()		{llu result = 0;char ch;ch = gc();while (true){if (ch == '-') break;if (ch >= '0' && ch <= '9') break;ch = gc();}result = ch-'0'; while (true){ch = gc(); if (ch < '0' || ch > '9') break;result = (result<<3) + (result<<1) + (ch - '0');}return result;}   //end of fast input   //fast output   //no line break void print_d(int n)     	{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[10];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<10);} void print_ld(ld n)     	{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[11];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} void print_lld(lld n)     	{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);} void print_llu(llu n)     	{int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);}   //new line void println_d(int n)		{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} void println_ld(ld n)		{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);} void println_lld(lld n)		{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} void println_llu(llu n)		{int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);}   //special char char sp; void printsp_d(int n)		{if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} void printsp_ld(ld n)		{if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);} void printsp_lld(lld n)		{if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} void printsp_llu(llu n)		{int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);}   //end of fast output  #define SSTR( x ) static_cast< std::ostringstream & >( \         ( std::ostringstream() << std::dec << x ) ).str()  int main() { 	int aa,ab,ba,bb,t,n,i; 	string x,ans; 	t=scan_d(); 	while(t--) 	{ 		ans=""; 		aa=ab=ba=bb=0; 		n=scan_d(); 		while(n--) 		{ 			getline(cin,x); 			if(x=="aa") 				aa++; 			else if(x=="bb") 				bb++; 			else if(x=="ba") 				ba++; 			else 				ab++; 		} 		fr(i,aa/2) 			ans+="aa"; 		ab=min(ab,ba); 		fr(i,ab) 			ans+="ab"; 		fr(i,bb/2) 			ans+="bb"; 		if(aa&1) 			ans+="aa"; 		else if(bb&1) 			ans+="bb"; 		fr(i,bb/2) 			ans+="bb"; 		fr(i,ab) 			ans+="ba"; 		fr(i,aa/2) 			ans+="aa"; 		cout<<ans<<endl; 	} 	return 0; } 
#include<bits/stdc++.h>  #define ll long long int #define ull unsigned long long int #define maxN 1000006 #define MOD 1000000007 #define pb push_back #define mp make_pair  #define INF (((ll)1000000000) * ((ll)1000000000))  using namespace std;  //priority queue is ordered by <dist[v] , edge_weight (u,v) , v > set< pair< ll , pair<ll,ll> > > P; vector<pair<ll,ll> >V[maxN]; vector< pair<ll ,pair<ll,ll> > >E; ll parent[maxN],rank[maxN],vis[maxN]; ll dist[maxN],last_edge[maxN];  ll kruskal(int );  int main() {  cin.sync_with_stdio(0); cin.tie(0);  int T; cin>>T;  while(T--) {  int N,M,i; cin>>N>>M;  for(i=0;i<N;i++) {  vis[i]=0;  last_edge[i]=INF;  dist[i]=INF; }  //always clear vector for(i=0;i<N;i++) {  V[i].clear(); } E.clear();  for(i=0;i<M;i++) {  int x,y,z;  cin>>x>>y>>z;  V[x].pb ( mp(y,z) );	//edge from x to y of weight z  V[y].pb ( mp(x,z) );  E.pb( mp(z , mp(x,y) ) );  E.pb( mp(z , mp(y,x) ) );  }  set< pair< ll , pair<ll,ll> > >::iterator it;  //dist[0]=0 , W(0,0)=0 , u=0 P.insert(mp(0 , mp(0,0) ) ); dist[0]=0; last_edge[0]=0;   while(P.empty()==false) {	//visit all vertices  it=P.begin();  int u=it->second.second;  /*  for(i=0;i<N;i++)  cout<<dist[i]<<" ";  cout<<"\n"; */   P.erase(it);  if(vis[u]==0) 	//vertice is unvisited  for(i=0;i<V[u].size();i++) { 	//adjacency list of u   int v=V[u][i].first;   int w=V[u][i].second;   if(!vis[v] && (dist[u] + w < dist[v] || (dist[u] + w == dist[v] && w < last_edge[v]))) {    dist[v]=dist[u]+w;    last_edge[v]=w;    P.insert( mp(dist[v] , mp(last_edge[v] , v) ) );   }  }     vis[u]=1; }  bool possible=true;  ll dw=0; for(i=0;i<N;i++) if(dist[i]==INF) {  possible=false;  break; } else  dw+=last_edge[i];  ll kw=-1; if(possible) kw= kruskal(N);   if(possible && kw==dw) cout<<"YES\n"; else cout<<"NO\n";  }  return 0; }    int find(int a) { if(parent[a]!=a) parent[a]=find(parent[a]); return parent[a]; }  void Union(int a,int b) {  if(rank[a]<rank[b])	//a has a tree of lesser depth parent[a]=b; else if(rank[a]>rank[b])	//a has a tree of greater depth parent[b]=a; else if(rank[a]==rank[b]) {  parent[a]=b;  rank[b]++; }  }  ll kruskal(int N) {  int i; for(i=0;i<N;i++) {  parent[i]=i;  rank[i]=0;  }  ll mst_weight=0; sort(E.begin() , E.end() );  for(i=0;i<E.size();i++) {  int u=E[i].second.first;  int v=E[i].second.second;  int w=E[i].first;   if(find(u) != find(v) ) {   mst_weight+=w;   Union(find(u),find(v));  } }  return mst_weight; } 
#include <iostream>  using namespace std;  int main() {     int t;     long long int n,m,x,a[100005],num,l,h,ans;     cin>>t;     while(t--)     {         cin>>n>>m>>x;         for(int i=0;i<m;i++) a[i]=0;         for(int i=1;i<=n;i++)         {             cin>>num;             a[num%m]++;         }         for(int i=1;i<m;i++) a[i]+=a[i-1];         ans= a[0]*(a[m-1]-a[x]) ;         for(int i=1;i<m;i++)         {             l=x-i+1;h=m-i-1;             if(l>0)             ans+=( (a[i]-a[i-1])*(a[h]-a[l-1]) ) ;             else             ans+=( (a[i]-a[i-1])*(a[h]+a[m-1]-a[m+l-1] ) ) ;         }         ans=(n*n)-ans;         cout<<ans<<'\n';     }     return 0; } 
#include<iostream> #include<cstring> #include<cstdio> #include<vector> #include<cmath> #include<cstdlib> #include<algorithm>  using namespace std;  int main()  {     int t;     scanf("%d",&t);     while(t--)     {         int n;         scanf("%d",&n);         int arr[n];         int r=0,num;         int count=0;         for(int i=0;i<n;i++)         {             if(i==0)             {                 scanf("%d",&num);                 arr[r++]=num;             }             else             {                 if(count==0)                 {                  scanf("%d",&num);                  for(int j=0;j<r;j++)                   {                     if(arr[j]==num)                     {                       count=1;                       break;                     }                   }                   arr[r++]=num;                  }                 else                   scanf("%d",&num);             }         }         if(count==0)             printf("YES\n");         else             printf("NO\n");     }     return 0; } 
#include<bits/stdc++.h> using namespace std ;  int a , b ; int divi[200005] , prime[100005];  void seive() {      for ( int i = 1 ; i < 100005 ; i++)     {         prime[i]  = 1 ;     }     prime[1] = 0 ;      for ( int i = 2 ; i < 100005 ; i++)     {         if ( prime[i] )         for ( int j = 2 * i ; j < 100005 ; j = j + i )         prime[j] = 0 ;      } }   int main() {     int t , low  ;     cin >> t ;     seive() ;      while(t--)     {      cin >> a >> b ;     for ( int i = 1 ; i <= ( b - a + 1 ) ; i++)     {         divi[i] = 0   ;     }      for ( int i = 1 ; i <= ( sqrt(b) ) ; i++)     {         low = ( a / i ) ;         low = low * i ;         for ( int j = low ; j <= b ; j = j + i )         {             if ( j < a )                 continue ;              if ( i > sqrt(j))                 continue ;              if ( ( i * i ) == j  )             divi[j - a + 1 ]++ ;             else                 divi[j-a+1] += 2 ;          }      }      int ans = 0 ;      for ( int i = 1 ; i <= ( b - a + 1 ) ; i++)     {         if ( prime[ divi[i]])             ans++ ;     }     cout << ans << endl ;      }     return 0 ; } 
#include<iostream> #include<cstdio> #include<vector> #include<algorithm> #include<set> #include<string> #include<map> using namespace std; #define ll long long vector<ll> cnt(1<<16); vector<ll> sum(1<<16); map<char, int> m; ll mod=1000000007; struct node { 	int x; 	ll num; }; bool operator < (node n1,node n2) { 	if(n1.num!=n2.num)return n1.num< n2.num; 	return n1.x<n2.x; } void recurse(int mask=0,int val=15) { 	//cerr<<mask<<endl; 	if(val==0) 	{ 		sum[mask]=cnt[mask]; 		sum[mask|1]=cnt[mask]+cnt[mask|1]; 		sum[mask|1]%=mod; 		return; 	} 	recurse(mask,val-1); 	recurse(mask|(1<<val),val-1); 	for(int i=0;i<(1<<val);++i) 	{ 		sum[(mask|(1<<val))+i]+=sum[mask+i]; 		sum[(mask|(1<<val))+i]%=mod; 	} } ll mpow(ll x,ll p) { 	if(p==0)return 1; 	ll ans=mpow((x*x)%mod,p/2); 	if(p%2==1)ans*=x; 	return ans%mod; } void doit() { 	string s; 	cin>>s; 	int n=s.length(); 	for(int i=0;i<(1<<16);++i)sum[i]=cnt[i]=0; 	vector<vector<node> > first(n,vector<node> (16)); 	for(int i=0;i<n;++i) 	{ 		for(int j=0;j<16;++j) 		{ 			first[i][j].x=j; 			first[i][j].num=n; 		} 	} 	first[n-1][m[s[n-1]]].num=n-1; 	for(int i=n-2;i>=0;i--) 	{ 		for(int j=0;j<16;++j)first[i][j]=first[i+1][j]; 		first[i][m[s[i]]].num=i; 	} 	for(int i=0;i<n;++i) 	{ 		sort(first[i].begin(),first[i].end());	 		int mask=0; 		for(int j=0;j<16;++j) 		{ 			mask|=(1<<first[i][j].x); 			if(j==16)cnt[mask]+=n-first[i][j].num; 			else cnt[mask]+=first[i][j+1].num-first[i][j].num; 			cnt[mask]%=mod; 		} 	} 	ll ans=n; 	ans*=(n+1); 	ans%=mod; 	ans*=mpow(2,mod-2); 	ans%=mod; 	ans*=ans; 	ans%=mod; 	recurse(); 	ll tminus=0; 	for(int i=0;i<(1<<16);++i) 	{ 		ll comp=(1<<16)-1-i; 		tminus+=(cnt[i]*sum[comp])%mod; 		tminus%=mod; 	} 	//tminus*=mpow(2,mod-2); 	//tminus%=mod; 	cout<<(ans+mod-tminus)%mod<<endl; } int main() { 	int t; 	cin>>t; 	for(int i=0;i<=9;++i)m['0'+i]=i; 	for(char i='A';i<='F';i++)m[i]=i-'A'+10; 	while(t--) 	{ 		doit(); 	} 	return 0; } 
#include <bits/stdc++.h> #define ll long long int #define s(a) scanf("%lld",&a) #define pb push_back #define mp make_pair #define f first #define sc second #define inf 10e16 #define sd(a) scanf("%lf",&a)  using namespace std;  ll m,n;  ll check(ll a) {     ll up,down,num,low,high;     up=0;     down=0;     num=a;     while(num>1) {         up++;         num/=2;     }     if(m<=up) return 0;     low=a;     ll count=1;     high=a;     while(1) {         //cout<<"FUVK \n";         count*=2;         low*=2;         high=low+count-1;         if(low>n) break;         down=down+min(n,high)-low+1;     }     if(n-m < down) return 0;     return 1; }  int main() {     ll t,i,j,k,l,w,ww,x,y,z,node,high,low,tot,mid;     //freopen("inp.txt","r",stdin);     //freopen("out2.txt","w",stdout);     s(t);     while(t--) {         tot=0;         node=1;         s(n);s(m);         if(m==1) {cout<<1<<endl;continue;}         //cout<<2421342214<<" "<<check(4)<<endl;         while(1) {             node*=2;             low=node;             high=min(2*low-1,n);             if(low>n) break;             if(check(low)) {                 tot=tot+high-low+1;                 //cout<<tot<<endl;                 continue;             }             if(check(high)==0) continue;             while(low<high) {                 //cout<<low<<" "<<high<<endl;                 mid=(low+high)/2;                 if(check(mid)) high=mid;                 else low=mid+1;             }             //cout<<low<<endl;             tot=tot+2*node-low;             //cout<<tot<<endl;         }         cout<<tot<<endl;     }     return 0; } 
#include<iostream> #include<vector> #define ll long long using namespace std; ll mod=1000000007; /*ll inv(ll x,ll pow=mod-2) { 	if(pow==0)return 1; 	ll ans=inv((x*x)%mod,pow/2); 	if(pow%2==1)ans*=x; 	return ans%mod; } vector<vector<ll> > mdp; ll extra; ll dp(ll n,ll t) { 	if(mdp[n][t]!=-1)return mdp[n][t]; 	ll ans=0;	 	if(t==0) 	{ 		if(n==1)return extra; 		ans+=extra*dp(n-1,0); 		ans%=mod; 		ans+=((n-1)*dp(n-1,1))%mod; 		ans%=mod; 	} 	else if(t==1) 	{ 		if(n==1)return extra; 		ans+=extra*dp(n-1,0); 		ans%=mod; 		ans+=((n-1)*dp(n-1,2))%mod; 		ans%=mod; 	}	 	else 	{ 		if(n==1)return (1+extra)%mod; 		ans+=((1+extra)%mod)*dp(n-1,0); 		ans%=mod; 		ans+=((n-1)*dp(n-1,2))%mod; 		ans%=mod; 	} 	return mdp[n][t]=ans; }*/ void doit() { 	ll n,k; 	cin>>n>>k; 	if(k<n) 	{ 		cout<<"0\n"; 		return ; 	} 	ll extra=k-n; 	extra%=mod; 	ll kcn=1,ans=1; 	for(int i=0;i<n;++i) 	{ 		kcn*=((k-i)%mod); 		kcn%=mod; 		//kcn*=inv(n-i); 		//kcn%=mod; 	} 	/*mdp.resize(n+2); 	for(int i=0;i<n+2;++i) 	{ 		mdp[i].resize(3); 		for(int j=0;j<3;++j) 			mdp[i][j]=-1; 	}*/ 	ll a1,a2,a3,b1,b2,b3; 	a1=extra; 	a2=extra; 	a3=(1+extra); 	for(int i=2;i<=n;++i) 	{ 		b1=0; 		b2=0; 		b3=0; 		 		b1+=extra*a1; 		b1%=mod; 		b1+=((i-1)*a2)%mod; 		b1%=mod;  		b2+=extra*a1; 		b2%=mod; 		b2+=((i-1)*a3)%mod; 		b2%=mod; 	 		b3+=((1+extra)%mod)*a1; 		b3%=mod; 		b3+=((i-1)*a3)%mod; 		b3%=mod; 		 		a1=b1; 		a2=b2; 		a3=b3; 	} 	ans=a1; 	cout<<(kcn*ans)%mod<<endl; } int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		doit(); 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; int N,M; int add(int c, int step) // add step to c and return the new pillar position {     c = c + step;     if(c<=M)return c;      c-=M;     return M + (c%(N-M+1)); }  int main() {     int t;     cin>>t;     while(t--)     {         int S,P,Q;         cin>>N>>M>>S>>P>>Q;         int c1 = 1;         int c2 = 1;         int ans = 0;         for(int i=0; i<S;i++)         {             c1 = add(c1,P);              c2 = add(c2,Q);              ans += (c1==c2);         }         cout<<ans<<endl;;     }     return 0; } 
#include<iostream> #include<cstdio> #include<vector> #include<cstring> #include<queue> #include<map> #include<set> #include<algorithm> #include<stack> #include<cmath> #include<iomanip> #include<cstdlib> #include<sstream> #include<climits> using namespace std; #define f(i,a,b) for(i=a;i<b;i++) #define rep(i,n) f(i,0,n) #define pb push_back #define ss second #define ff first #define vi vector<int> #define vl vector<ll> #define s(n) scanf("%d",&n) #define ll long long #define mp make_pair #define PII pair <int ,int > #define PLL pair<ll,ll> #define inf 1000*1000*1000+5 #define v(a,size,value) vi a(size,value) #define sz(a) a.size() #define all(a) a.begin(),a.end() #define tri pair < int , PII > #define TRI(a,b,c) mp(a,mp(b,c)) #define xx ff #define yy ss.ff #define zz ss.ss #define in(n) n = inp() #define vii vector < PII > #define vll vector< PLL > #define viii vector < tri > #define vs vector<string> #define DREP(a) sort(all(a)); a.erase(unique(all(a)),a.end()); #define INDEX(arr,ind) (lower_bound(all(arr),ind)-arr.begin()) #define ok if(debug) #define trace1(x) ok cerr << #x << ": " << x << endl; #define trace2(x, y) ok cerr << #x << ": " << x << " | " << #y << ": " << y << endl; #define trace3(x, y, z)    ok      cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl; #define trace4(a, b, c, d)  ok cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " \ 								<< #d << ": " << d << endl; #define trace5(a, b, c, d, e) ok cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " \ 									 << #d << ": " << d << " | " << #e << ": " << e << endl; #define trace6(a, b, c, d, e, f) ok cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " \ 									<< #d << ": " << d << " | " << #e << ": " << e << " | " << #f << ": " << f << endl; ll MOD = int(1e9) + 7; #define gc getchar() inline int inp(){register int n=0,s=1,c=gc;if(c=='-')s=-1;while(c<48)c=gc;while(c>47)n=(n<<3)+(n<<1)+c-'0',c = gc;return n*s;} #define pc(x) putchar(x) //_unlocked(x); inline void writeInt (ll n) {ll N = n, rev, count = 0;rev = N; if (N == 0) { pc('0'); pc('\n'); return ;} while ((rev % 10) == 0) { count++; rev /= 10;}rev = 0; while (N != 0) { rev = (rev<<3) + (rev<<1) + N % 10; N /= 10;} while (rev != 0) { pc(rev % 10 + '0'); rev /= 10;}while (count--) pc('0'); } const int N = 100 + 5; int debug = 0; #define ld long double ld x[N] , y[N] , r[N]; ld eps = 1e-14; int n; ld dist(ld x1 , ld y1 , ld x2 , ld y2) { 	return sqrtl( (x1-x2)*(x1-x2) + (y1-y2)*(y1 - y2 ) ); } bool intersect( ld x1 , ld y1 , ld r1 , ld x2 , ld y2 , ld r2 ) { 	trace1(dist(x1,y1,x2,y2)); 	return dist(x1,y1,x2,y2) < r1 + r2 - eps && dist(x1,y1,x2,y2) > abs(r1 - r2) + eps ; } ld convert(ld theta) { 		while ( theta < 0 - eps) 		{ 			theta += 2 * M_PI; 		} 		while ( theta > 2* M_PI + eps) 		{ 			theta -= 2*M_PI; 		} //		assert(theta >= 0 - eps && theta <= 2*M_PI + eps); 		return theta; } ld g(ld a) { 	return a*180/M_PI; } ld getAngle(ld x2, ld y2 , ld r2 , ld x1 , ld y1 , ld r1 , ld & theta1 , ld & theta2 ) { 	trace4(x1,y1,x2,y2); 	ld theta = atan2l(y2 - y1 , x2 - x1); 	ld r1sq = r1*r1  , r2sq = r2*r2 , d = dist(x1,y1,x2,y2); 	ld dsq = d * d; 	trace4(r1sq,r2sq,d,dsq); 	ld temp = (r1sq + dsq - r2sq)/2/r1/d;  	trace1(temp); 	ld alpha = acosl(temp); 	trace2(g(theta) , g(alpha)); 	theta1 = convert(theta + alpha); 	theta2 = convert(theta - alpha); } bool present(ld x1,ld y1, ld x , ld y , ld r) { 	return (x-x1)*(x-x1) + (y-y1)*(y-y1) < r*r - eps; } bool completely( ld x1,ld y1 , ld r1 , ld x2 , ld y2 , ld r2) { 		return dist(x1,y1,x2,y2)  + r1  < r2 + eps; } ld solve(int idx) { 		vector < ld > arcs; 		ld ret = 0; 		int i; 		for(i = idx + 1; i < n; i++ ) 		{ 			trace1(i); 			if(completely(x[idx] , y[idx] ,  r[idx] , x[i] , y[i] , r[i] ) ) 				return 0; 				 			if( ! intersect( x[i] , y[i] , r[i] , x[idx] , y[idx] , r[idx] ) ) 				continue; 			ld theta1  = 0 , theta2 = 0; 			trace1('a'); 			getAngle(x[i] , y[i] , r[i] , x[idx] , y[idx] , r[idx] , theta1 , theta2); 			trace3(i,theta1*180/M_PI,theta2*180/M_PI); 			arcs.pb(theta1); arcs.pb(theta2); 		} 		if(sz(arcs) == 0) 			return M_PI * 2 * r[idx]; 		sort(all(arcs)); 		arcs.pb(arcs[0] + 2*M_PI); 		rep(i,sz(arcs) - 1) 		{ 			ld theta1 = arcs[i] , theta2 = arcs[i+1]; 			ld theta = (theta1 + theta2)/2; 			ld x1 = x[idx] + r[idx] * cosl(theta); 			ld y1 = y[idx] + r[idx] * sinl(theta) ; 			int flag = 0,j; 			f(j,idx+1,n) 			{ 				if(present(x1,y1,x[j],y[j],r[j])) 					flag = 1; 			} 			if(flag == 0) 				ret += r[idx] * (theta2 - theta1); 		} 		return ret; }	  int main() {       ios::sync_with_stdio(false);       int i,j,t;       cin>>t;       while(t--)       { 			cin>>n; 			rep(i,n) 			{ 				cin>>x[i]>>y[i]>>r[i]; 			} 			ld ans = 0; 			rep(i,n) 			{ 				ans += solve(i); 			}		 			cout<<fixed<<setprecision(8)<<ans<<endl; 	  } 	  cin>>i;			 } 
#include <iostream> #include <cstdio> #include <cstring>  using namespace std;  #define si(a) scanf("%d",&a) #define MOD 1000000007  int dp[5005][5005]; int jog[5005];  int mod_mul(long long a,long long b) {     return (a*b)%MOD; }  int mod_plus(int a,int b) {     return (a+b)%MOD; }  int main() {     int i,j;     for(i=1;i<5005;i++){         int sm=1;         for(j=1;j<5005;j++){             dp[j][i]=mod_mul(26,sm);             int ttt=sm;             sm=mod_plus(jog[j],sm);             jog[j]=mod_plus(jog[j],mod_mul(25,ttt));         }     }     for(i=0;i<5005;i++)         for(j=1;j<5005;j++)             dp[i][j]=mod_plus(dp[i][j],dp[i][j-1]);     int t;     si(t);     for(int ca=1;ca<=t;ca++){         int x;         si(x);         int ans=0;         for(i=0;i<=x;i++)             ans=mod_plus(ans,dp[i][x]);         printf("%d\n",ans);     }     return 0; } 
#include<iostream> #include<cstdio> #include<string.h> using namespace std; void sort_array(char array[],int length) { 	int c,d; 	char temp; 	for(c=1;c<length;c++) 	{ 		for(d=c;d>0;d--) 		{ 			if(array[d]<array[d-1]) 			{ 				temp=array[d]; 				array[d]=array[d-1]; 				array[d-1]=temp; 			} 		} 	} } int main() { 	char a[500],b[500]; 	cin>>a; 	cin>>b; 	int l1=strlen(a); 	int l2=strlen(b); 	if(l1!=l2) 	{ 		printf("No\n"); 	} 	else 	{ 		sort_array(a,l1); 		sort_array(b,l2); 		int i,flag = 1; 		for(i=0;i<l1;i++) 		{ 			if(a[i]!=b[i]) 			{ 				flag=0; 				break; 			} 		} 		if(flag==1) 		{ 			printf("Yes\n"); 		} 		else 		{ 			printf("No\n"); 		} 	} 	return 0; }
//techwiz911 #include<bits/stdc++.h> #define pb push_back #define SZ(a) (int)(a.size()) #define all(a) a.begin(),a.end() #define gcd __gcd #define b_c __builtin_popcount #define mp make_pair #define fi(i,a,b) for(int i=a;i<b;i++) #define fd(i,a,b) for(int i=a;i>=b;i--) #define tr(c,it) for(typeof(c).begin() it=(c).begin();it!=(c).end();it++)  #define X first #define Y second #define init(a,b) memset(a,b,sizeof(a)) #define n_p next_permutation #define b_s binary_search #define endl '\n' #define INF INT_MAX #define INFL LLONG_MAX #define sd(n) scanf("%d",&n) #define pd(n) printf("%d\n",n); #define slf(n) scanf("%lf",&n); #define plf(n) printf("%lf",n); #define ss(n) scanf("%s",n) #define ps(n) printf("%s",n); #define sp() printf(" "); #define ln() printf("\n"); #define TC() int t;sd(t);while(t--) #define trace1(x)                cerr <<#x<<": "<<x<<endl; #define trace2(x, y)             cerr <<#x<<": "<<x<<" | "<<#y<<": "<<y<< endl; #define trace3(x, y, z)          cerr <<#x<<": "<<x<<" | "<<#y<<": "<<y<<" | "<<#z<<": "<<z<<endl; #define trace4(a, b, c, d)       cerr <<#a<<": "<<a<<" | "<<#b<<": "<<b<<" | "<<#c<<": "<<c<<" | "<<#d<<": "<<d<<endl; #define trace5(a, b, c, d, e)    cerr <<#a<<": "<<a<<" | "<<#b<<": "<<b<<" | "<<#c<<": "<<c<<" | "<<#d<<": "<<d<<" | "<<#e<<": "<<e<<endl; #define die(s)  cout<<s<<endl; exit(0);  using namespace std;  typedef long long LL; typedef vector<int> VI; typedef vector<LL> VLL; typedef set<int> SI; typedef set<LL> SLL; typedef pair<int,int> PII; typedef pair<LL,LL> PLL;  void FastIO() {ios_base::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);} LL modpow(LL a, LL p, LL mod) {LL ret=1;while(p){if(p&1)ret=(ret*a)%mod;a=(a*a)%mod;p/=2;}return ret;} LL power(LL a, LL p) {LL ret=1;while(p){if(p&1)ret=(ret*a);a=(a*a);p/=2;}return ret;} //Template Ends Here const int MAXN1 = 50011; const int MAXN2 = 50011; const int MAXM = 150011;  int n1,n2,edges,last[MAXN1],prev[MAXM],head[MAXM]; int matching[MAXN2],dist[MAXN1],Q[MAXN1]; bool used[MAXN1],vis[MAXN1];  void initialize(int _n1,int _n2)  {     n1=_n1;     n2=_n2;     edges=0;     fill(last,last+n1,-1); }  void addEdge(int u,int v)  {     head[edges]=v;     prev[edges]=last[u];     last[u]=edges++; }  void bfs()  {     fill(dist,dist+n1,-1);     int sizeQ=0;     fi(u,0,n1)         if(!used[u])          {             Q[sizeQ++]=u;             dist[u]=0;         }     fi(i,0,sizeQ)      {         int u1=Q[i];         for(int e=last[u1];e>=0;e=prev[e])          {             int u2=matching[head[e]];             if(u2>=0&&dist[u2]<0)              {                 dist[u2]=dist[u1]+1;                 Q[sizeQ++]=u2;             }         }     } }  bool dfs(int u1)  {     vis[u1]=true;     for(int e=last[u1];e>=0;e=prev[e])     {         int v=head[e];         int u2=matching[v];         if(u2<0||(!vis[u2]&&dist[u2]==dist[u1]+1&&dfs(u2)))         {             matching[v]=u1;             used[u1]=true;             return true;         }     }     return false; }  int maxMatching()  {     fill(used,used+n1,false);     fill(matching,matching+n2,-1);     for(int res=0;;)      {         bfs();         fill(vis,vis+n1,false);         int f=0;         for(int u=0;u<n1;++u)             if(!used[u]&&dfs(u))                 ++f;         if(!f)             return res;         res+=f;     } }  LL a[111][111]; int main() {     FastIO();       int T;     cin>>T;     while(T--)     {         int n;         cin>>n;         fi(i,0,n)             fi(j,0,n)                 cin>>a[i][j];         LL add=0;         fd(i,63,0)         {             initialize(n,n);             LL cmp=(add|(1LL<<i));             fi(j,0,n)                 fi(k,0,n)                     if((a[j][k]&cmp)==cmp)                         addEdge(j,k);             int ret=maxMatching();             if(ret==n)                 add|=(1LL<<i);         }         cout<<add<<endl;     }     return 0; }  
#include <iostream> #include <algorithm>  using namespace std;  int main() 	{ 		int t; 		cin >> t; 		while(t--) 			{ 				long long A[100001]; 				int n; 				cin >>n; 				for(int i=0;i<n;i++) 					cin >> A[i]; 				sort(A,A+n); 				//for(int i=0;i<n;i++) 				//	cout << A[i] << " "; 				//cout << endl; 				int counter1 = 0,counter2=n-1;  				for(int i=0;i<n;i++) 					{ 						if(i%2==0) 							cout << A[counter1++] << " "; 						else 							cout << A[counter2--] << " "; 					} 				cout << endl; 			} 	} 
#include<bits/stdc++.h> using namespace std; #define SF(x)	scanf("%d", &x) #define PF(x)	printf("%d", x) #define psp     printf(" ") #define pnl     printf("\n") #define charint(c) ((c)-'0') #define pii pair< int, int > #define pb(x) push_back(x) #define test int t; scanf("%d",&t);while(t--) #define forall(a,b) for(long long i=a;i<=b;i++) #define abs(a) ((a)>(0)?(a):(-a)) #define bit(x,i)          (x&(1<<i))  //select the bit of position i of x #define lowbit(x)         ((x)&((x)^((x)-1)))  #define higbit(x)         (1 << ( int) log2(x) ) #define countleadzero(x)  __builtin_ctz(x) //in its binary representation ex. when x=8 answer is 3 #define countsetbits(x)   ____builtin_popcount(x) //count no of setbits #define gcd(a,b)   __gcd(a,b) #define bss binary_search #define esort(x)        (sort((x).begin(), (x).end())) #define ersort(x)       (sort((x).rbegin(), (x).rend())) #define MAX		100050 #define INF		1e9 #define MOD     1000000009 #define fi first #define se second typedef long long 		ll; typedef unsigned long long	ull; long long dp[20][10][10][2][2][2]; vector <int> v; ll func(ll n){ 	v.clear(); 	while(n>0){ 		v.pb(n%10);n/=10; 	} 	int l=v.size(); 	reverse(v.begin(),v.end()); 	if(l<3) 	return 0LL; 	memset(dp,0LL,sizeof(dp)); 	for(int i=1;i<10;i++){ 		for(int j=0;j<10;j++){ 			if(i*10+j<=v[0]*10+v[1]){ 				dp[1][i][j][0][i==j][(i*10+j)==(v[0]*10+v[1])]+=1; 			} 		} 	} 	for(int i=2;i<l;i++){ 		for(int j=0;j<10;j++){ 			for(int k=0;k<10;k++){ 				for(int od=0;od<=1;od++){ 					for(int ev=0;ev<=1;ev++){ 						for(int c=0;c<10;c++){ 							dp[i][k][c][od|(j==c)][ev|(k==c)][0]+=dp[i-1][j][k][od][ev][0]; 							if(c==v[i]){ 								dp[i][k][c][od|(j==c)][ev|(k==c)][1]+=dp[i-1][j][k][od][ev][1]; 							} 							else if(c<v[i]){ 								dp[i][k][c][od|(j==c)][ev|(k==c)][0]+=dp[i-1][j][k][od][ev][1]; 							} 						} 					} 				} 			} 		} 		for(int j=1;j<10;j++){ 			for(int k=0;k<10;k++){ 				dp[i][j][k][0][(j==k)][0] += 1; 			} 		} 	} 	ll res=0LL; 	for(int i=0;i<10;i++){ 		for(int j=0;j<10;j++){ 			res=res+dp[l-1][i][j][1][1][1]+dp[l-1][i][j][1][1][0]; 		} 	} 	return res;	 } int main(){ test{ ll a,b; scanf("%lld %lld",&a,&b); cout<<(func(b)-func(a))<<endl; } }
#include<bits/stdc++.h> using namespace std; int main() { 	int t; 	long n; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%ld",&n); 		int ans=0; 		if(n%2==0) 		{ 			while(n%2==0) 			{ 				n=n/2; 				ans++; 			} 		} 		for(int i=3;i*i<=n&&n>1;i+=2) 		{ 			if(n%i==0) 			{ 				while(n%i==0) 				{ 					ans++; 					n=n/i; 				} 			} 		} 		if(n!=1) 		ans++; 		printf("%d\n",ans); 	} }
#include <iostream> #include <cstdio>  typedef long long ll;  using namespace std;  inline int test() {     ll p, c;     scanf("%lld %lld",&p, &c);     c++;     ll n = p/c;     ll mod = p%c;     if (mod)     {         n++;     }     //if (c>p){printf("1\n"); return 0;}     printf("%lld\n",n);      return 0; }  int main() {     int t;     scanf("%d",&t);     while(t--)     {         test();     }      return 0; } 
#include<stdio.h> #include<set> #include<cmath> #define LL long long using namespace std; set<LL> s; LL power(LL a,LL p){     LL ret=1;     while(p>0){         if(p&1)             ret *= a;         p/=2;         a*=a;     }     return ret; } void pre(){     LL i,j,Max=200000000,k;     Max*=Max;     for(i=3;i<55;i++){         j=2;         while(true){             k=power(j,i);             // printf("%lld\n",k);             if(k>Max)                 break;             s.insert(k);             j++;         }     } } void solve(){  LL n;  scanf("%lld",&n);  if(n<4){     printf("NO\n");     return;  }  if(s.find(n)!=s.end()){     printf("YES\n");     return;  }  LL tmp=sqrt(n),tmp1=tmp*tmp;  if(tmp1==n || tmp1*2==n){     printf("YES\n");     return;  }  else{  printf("NO\n");  return;  } } int main(){     pre();     int t;     scanf("%d",&t);     while(t--){     solve();     } return 0; } 
#include<iostream> #include<stdio.h> using namespace std; int main() { long long t,a; scanf("%lld",&t); while(t--) { long long x,y,q; scanf("%lld%lld%lld",&x,&y,&q); long long l,m,n,d; l=x+y; m=y-x; n=((2*q)/l); printf("%lld\n",n); d=(m/(n-5)); long long  f=x-(2*d); int series=1; while(series<=n) { a=(f+(series-1)*d); printf("%lld ",a); series++; } printf("\n"); } return 0; }
/*  	C++ Template 	Pradeep George Mathias  */   #include <iostream> #include <cstdio> #include <cstring> #include <cmath> #include <cassert> #include <string> #include <vector> #include <algorithm> #include <set> #include <map> #include <stack> #include <queue> #include <cstdlib> using namespace std;  #define s(T) scanf("%d", &T) #define sl(T) scanf("%lld", &T) #define fill(a, val) memset(a, val, sizeof(a)) #define mp make_pair #define pb push_back #define all(x) x.begin(), x.end() #define DREP(x) sort(all(x)); x.erase(unique(all(x)), x.end()) #define INDEX(a, val) (lower_bound(all(a), val) - a.begin())  const int maxn = 100000; const int maxq = 100000;  int totalCases, testNum; int N, Q;  int tin[maxn], tout[maxn]; int sizes[maxn], parent[maxn];  vector <int> children[maxn]; vector <int> adjl[maxn];  int ts;  void preprocess() { 	 }  bool input() { 	s(N); 	s(Q); 	int u, v; 	for(int i = 0; i < N-1; i++) 	{ 		s(u); 		s(v); 		if(!(u != v && u >= 0 && u < N && v >= 0 && v < N)) 			cerr << u << " " << v << " " << N << endl; 		assert(u != v && u >= 0 && u < N && v >= 0 && v < N); 		adjl[u].push_back(v); 		adjl[v].push_back(u); 	} 	return true; }  bool anc(int u, int v) { 	return tin[u] <= tin[v] && tout[u] >= tout[v]; }  void dfs(int u) { 	assert(sizes[u] == 0); 	tin[u] = ts++; 	sizes[u] = 1; 	for(int i = 0; i < adjl[u].size(); i++) 	{ 		int v = adjl[u][i]; 		if(v == parent[u]) 			continue; 		children[u].push_back(v); 		parent[v] = u; 		dfs(v); 		sizes[u] += sizes[v]; 	} 	tout[u] = ts++; }  void solve() { 	fill(sizes, 0); 	ts = 0; 	parent[0] = 0; 	dfs(0); 	assert(sizes[0] == N);	// check if valid tree 	int ans; 	int u, v; 	 	for(int i = 0; i < Q; i++) 	{ 		s(u); 		s(v); 		if(anc(v, u)) 			swap(u, v); 		if(anc(u, v)) 		{ 			int lo = 0, hi = children[u].size(); 			for(int mid = (lo + hi)/2; hi - lo > 1; mid = (lo + hi)/2) 				(tin[ children[u][mid] ] <= tin[v] ? lo : hi) = mid; //SLOWER VERSION: Times out on Star Input //			for(lo = 0; lo < children[u].size(); lo++) //				if(anc(children[u][lo], v)) //					break; 			assert(anc(children[u][lo], v)); 			ans = (N - sizes[children[u][lo]]) + sizes[v]; 		} 		else  			ans = sizes[u] + sizes[v]; 		printf("%d\n", ans); 	} }  int main() { 	preprocess(); 	totalCases = 1; 	for(testNum = 1; testNum <= totalCases; testNum++) 	{ 		if( !input()) 			break; 		solve(); 	} } 
#include <iostream> using namespace std; #include <cstring> int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		char a[10000]; 		cin>>a; 		int sum = 0; 		for(int i=0; a[i]; i++) 			sum += a[i];  		cout<<((char)(sum/strlen(a)))<<endl;  	} 	return 0; }
#include<iostream> #include<stdio.h> #include<algorithm> #include<cstdio> #include<vector> #include<set> #include<map> #include<cstring> #include<algorithm> #include<string> #include<utility> #include<cassert>   using namespace std;   int main() {          int t,n;     scanf("%d",&t);     while(t--)     {               scanf("%d",&n);               int f1=0,f2=1,f3=0,cnt=2;               while(f3<n)               {                         cnt++;                         f3=f1+f2;                         f1=f2;                         f2=f3;               }               cnt--;               //cout<<cnt<<endl;               n%=cnt;               n%=8;               printf("%d\n",n);     }     return 0; }
#include<iostream> #include<stdio.h> using namespace std; int main(){    int t;    scanf("%d",&t);    for(int i=0;i<t;i++){       int n;       scanf("%d",&n);       int a=n;       int sum=0;       while(a>0){         int b=a%10;         sum+=b;          a=a/10;       }         printf("%d\n",(n%sum));     }   return 0; } 
#include <stdio.h> #include <iostream> #include <string.h> #include <algorithm> using namespace std; int main() { 	int t,i,n,m,sum,cnt,x; 	char a[102]; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%s",&a[0]); 		sum=0; 		for(i=0; i<strlen(a); i++) 			sum+=(int)a[i]; 		//printf("%d\n",sum); 		x=1; 		while(x<=sum) 			x=x<<1; 		x=x>>1; 		printf("%d\n",(sum-x)); 	} 	return 0; }
#include <stdio.h> #include <cmath>  int sum(int N) {     int res = 0;     while(N > 0)     {         res += N%10;         N /= 10;     }     return res; }  int main() {     int T;     scanf("%d", &T);     for(int x = 0; x < T; ++x)     {         int elem;         scanf("%d", &elem);         int x = pow(2,sum(elem))*elem;         printf("%d \n", x);     }     return 0; } 
#include<iostream> using namespace std; int main() { 	int i; 	char c; 	cin>>i; 	c=i+97; 	cout<<c; 	return 0; }
#include<iostream> using namespace std; int main() {     int t = 5,Nstud,Rno,off,count,temp,i;     while(t--)     {               int a[121];               scanf("%d%*c%d",&Nstud,&Rno);               //cout << Nstud << " " << Rno << endl;               for(i=1;i<=Nstud;i++)                  a[i] = i;               Rno;               temp = 0;               count = 0;               int z = Nstud;               while(z != 1)               {                    while(count != Rno)                    {                        temp++;                       // cout <<"temp " <<  temp << endl;                        if(temp > Nstud){                        //cout << "greater" << endl;                        temp = temp % Nstud;}                        //cout <<"temp " <<  temp << endl;                        if(a[temp] != -1)                        {                            //cout << "counted" << endl;                            count++;                        }                        //getch();                    }                    count = 0;                    off = a[temp];                    //cout << "off is " << off << endl;                    a[temp] = -1;                    z--;               }               cout << off << endl;     }     //system("pause");     return 0; } 
//Author : pakhandi // using namespace std;  #include<iostream> #include<cstdio> #include<cstdlib> #include<algorithm> #include<cmath> #include<cstring>  #define wl(n) while(n--) #define fl(i,a,b) for(i=a; i<b; i++) #define rev(i,a,b) for(i=a; i>=b; i--) #define scan(n) scanf("%d", &n) #define scans(s) scanf("%s", s) #define scanc(c) scanf("%c", &c) #define scanp(f) scanf("%f", &f) #define scanll(l) scanf("%lld", &l) #define print(n) printf("%d\n", n) #define prints(s) printf("%s\n", s) #define printc(c) printf("%c\n", c) #define printp(f) printf("%f\n", f) #define printll(l) printf("%lld\n", l) #define nline printf("\n") #define mclr(strn) strn.clear() #define ignr cin.ignore() #define MOD 1000000007 #define ll long long int  int mat[3][2][4]=  {   {{10, 15, -25, 1} , {-10, -15, 25, 2}} ,   {{10, 15, -25, 0} , {-10, -20, 30, 1}} ,   {{10, 20, -30, 2} , {-10, -15, 25, 0}} };   int main() {   int i, j, cases, n;   int temp=0, eb=60, ew=100, eg=160, b, w, g, ele;   while(cin>>n)   { 	  eb=60; ew=100; eg=160; temp=0; 	  fl(i,0,n) 	  { 	    scan(ele); 		ele--; 	    eb=eb+mat[temp][ele][0]; 	    ew=ew+mat[temp][ele][1]; 	    eg=eg+mat[temp][ele][2]; 	    temp=mat[temp][ele][3]; 	  } 	  eb/=10; 	  ew/=10; 	  eg/=10; 	  printf("%d %d %d", eb,ew, eg); 	  nline;   }   return 0; } 
#include<iostream> #include<malloc.h> using namespace std; int main() { int a,b,c,q=0,i; while(1){ cin>>a>>b>>c; if(a==0&&b==0&&c==0) break; else  { if(a+c==2*b) {cout<<"AP "<< 2*c-b<<endl;q++;} else if(a*c==b*b) {cout<<"GP "<<(c*c)/b<<endl;q++;} } } return 0; }
#include<stdio.h>  int bit_count(long long int x) {     int bits = 0;     while(x)     {         bits += (x&1);         x = x >> 1;     }     return bits; }  long long int set_bit(long long int x) {     long long int b = 1;     while(b&x)         b = b << 1;     x = x | b;     return x; } void print(long long int x) {      //long long int b = 1 << 30;     //printf("%lld\n",b);     //while(b&x == 0)       //  b = b >> 1;     //printf("%lld",b);     while(x > 0)     {         printf("%d",x%2);         x = x/2;     }     printf("\n"); }  long long int ans(long long int l, long long int r) {     long long int tmp,curr;     tmp = curr = l;     while(tmp <= r)     {         curr = tmp;         tmp = set_bit(tmp);     }     return curr; }  /*int main() {     long long int x;     scanf("%lld",&x);     //printf("%d\n",sizeof(long long int));     print(x);     return 0; }*/  int main() {     long long int n,l,r,o;     scanf("%lld",&n);     while(n--)     {         scanf("%lld%lld",&l,&r);         //scanf("%lld",&l);         o = ans(l,r);         printf("%lld\n",o);         //print(l);         //print(r);         //print(o);     }     return 0; } 
#include<iostream> #include<malloc.h> #include<string.h> using namespace std; int main() { int t,count=0,i; cin>>t; int*ans=(int*)calloc(sizeof(int),t); char*str1=(char*)calloc(sizeof(char),1000); char*str2=(char*)calloc(sizeof(char),1000); for(int q=0;q<t;q++) { cin>>str1; cin>>str2; if(strlen(str1)!=strlen(str2)) ans[q]=-1; else{ for(i=0;i<strlen(str1);i++) if(str1[i]!=str2[i]) count++; ans[q]=count;} count=0; } for(i=0;i<t;i++) cout<<ans[i]<<endl; return 0; }
#include <iostream> #include <string.h>  using namespace std; #define FOR(i, n) for(int i=0;i<n;i++) #define ll long long ll nChoosek( ll n,ll k ) {     if (k > n) return 0;     if (k * 2 > n) k = n-k;     if (k == 0) return 1;      ll result = n;     for( int i = 2; i <= k; ++i ) {         result *= (n-i+1);         result /= i;     }     return result; }  int main(){ long long n; cin>>n; cout<<nChoosek(2*n -1 ,n); } 
#include<bits/stdc++.h> using namespace std; int main() { 	short int n, q, a[1000001]; 	cin>>n>>q; 	for(int i=0; i<n; i++) 		cin>>a[i]; 	while(q--){ 		char str[4]; 		scanf("%s", str); 		int m,n; 		cin>>m>>n; 		int sum=0; 		for(int i=m-1; i<=n-1; i++) 			sum+=a[i]; 		cout<<sum<<"\n"; 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { 	string str="dhapusv"; 	int test; 	std::ios::sync_with_stdio(false); 	cin>>test; 	while(test--) 	{ 		long long num,temp,rem,ind=0; 		string ans=""; 		cin>>num; 		temp=num; 		while(temp) 		{ 			rem=temp%7; 			//cout<<rem; 			ans[ind++]=rem+48; 			temp=temp/7; 		} 		for(int i=ind-1;i>=0;i--) 		cout<<str[ans[i]-49]; 		cout<<endl; 	} }
#include <iostream> #include <string.h> #include <algorithm> using namespace std;  #define ll long long  #define min(x,y) (x<y) ? (x):(y) #define max(x,y) (x>y) ? (x):(y)  int main(int argc, char const *argv[]) { 	ios_base::sync_with_stdio(false); 	int t; 	cin>>t; 	while(t--) 	{ 		ll n,c; 		cin>>n>>c; 		ll mx = (n*(n+1))/2; 		if(n==1) 			cout<<"Yes\n";  		else if(c<mx) 			cout<<"No\n";  		else 		{ 			if(n==2) 				cout<<"Yes\n";  			else if(((2*c)%n) != 0) 				cout<<"No\n";  			else 			{ 				ll rhs = (2*c)/n; 				ll temp1 = rhs - n+1; 				ll temp2 = rhs - 2*n+2;  				if(temp1>0) 				{ 					if(temp1%2==0) 						cout<<"Yes\n"; 					else 					{ 						if(temp2>0) 						{ 							if(temp2%2==0) 								cout<<"Yes\n"; 							else 								cout<<"No\n"; 						} 						else 						{ 							cout<<"No\n"; 						} 					} 				} 				else 				{ 					cout<<"No\n"; 				} 			} 		}  	} 	return 0; }
#include<stdio.h> #include<stdlib.h> long int arr[100010],arr1[100010]; int cmpr(const void *a, const void *b) {     return (*(long int*)a - *(long int *)b);  } int smpr(const void *a, const void *b) {     return (*(long int*)b - *(long int *)a);  } int main() { int t; scanf("%d",&t); while(t--) { long long n,k,i; scanf("%lld %lld",&n,&k); for(i=0;i<n;i++) { scanf("%lld",&arr[i]); } for(i=0;i<n;i++) { scanf("%lld",&arr1[i]); } qsort(arr,n,sizeof(long int),cmpr); qsort(arr1,n,sizeof(long int),smpr); int flag = 0; for(i=0;i<n;i++) {     if(arr[i] + arr1[i] <k)     flag = 1; } if(flag) printf("NO\n"); else printf("YES\n"); } return 0; } 
 /* Author : Vamsi Kavala */ #include <iostream> #include <cstdio> #include <cstring> #include <cstdlib> #include <cctype> #include <algorithm> #include <map> #include <vector> #include <list> #include <set> #include <queue> #include <deque> #include <stack> #include <string> #include <cmath> using namespace std;  #define FOR(i,a,b) for(int i=a;i<b;i++) #define FORD(i,a,b) for(int i=a;i>=b;i--) #define REP(i,n) FOR(i,0,n) #define PB push_back #define ITER(i,a) for( typeof(a.begin()) i=a.begin();i!=a.end();i++)	 #define mod 1000000007 #define MAXN 1000010  typedef pair<int,int>   PI; typedef vector<int> VI; typedef long long int LL;  int prm[10000004]; int modexp(int a,int b,int c){ 	if(b<0)return 0; 	a%=c; 	int cur=1; 	while(b){ 		if((b&1)){ 			cur*=a; 			cur%=c; 		} 		a*=a; 		a%=c; 		b>>=1; 	} 	return cur; } int main(){ 	int i,j,n,t; 	for(i=2;i<=3163;i++){ 		if(prm[i])continue; 		for(j=i*i;j<=10000000;j+=i){ 			prm[j]=1; 		} 	} 	prm[0]=prm[1]=0; 	for(i=2;i<=10000000;i++){ 		prm[i]=1-prm[i]; 		prm[i]+=prm[i-1]; 	} 	while(scanf("%d",&n)!=EOF){ 		printf("%d\n",modexp(2,prm[n]-1,10007)); 	} 	return 0; } 
//Author:Hena Firdaus #include <bits/stdc++.h> using namespace std;  int main() { 	string r; 	int idx,sum,j,k,fidx,t,i; 	cin>>t; 	while(t--) 	{ 	cin>>r; 	int len=r.length(); 	 	vector<int>v; 	 	for(j=0;pow(2,j)<=len;j++) 	{       	idx=pow(2,j);       	sum=0;       	       	for(k=idx+1;k<=len;k++)       	{        		if(k&(1<<j))       		{       			sum+=r[k-1]-'0';       			      		}       	}         //cout<<"idx:"<<idx<<" sum:"<<(sum)<<" org:"<<r[idx-1]-'0'<<endl;       	if((sum%2)!=(r[idx-1]-'0'))       	{       		v.push_back(j);       	} 	}     //for(j=0;j<v.size();j++) 	//	cout<<v[j]<<" "; 	//cout<<endl; 	for(i=1;i<=len;i++) 	{ 		int c=0; 		for(j=0;j<v.size();j++) 		{ 			if(i&(1<<v[j])) 				c++; 		} 		if(c==v.size()) 		{ 			fidx=i; 			break; 		} 	} 	 	string m=""; 	for(i=1;i<=len;i++) 	{ 		if(i&(i-1)) 		{    			if(i==fidx) 				{if(r[i-1]=='0') 					m+='1'; 				else 					m+='0';} 			else 			m+=r[i-1]; 		} 	} 	cout<<m<<endl; 	} 	return 0;  }
//Author : pakhandi // using namespace std;  #include<bits/stdc++.h>  #define wl(n) while(n--) #define fl(i,a,b) for(i=a; i<b; i++) #define rev(i,a,b) for(i=a; i>=b; i--)  #define si(n) scanf("%d", &n) #define sll(l) scanf("%lld",&l) #define ss(s) scanf("%s", s) #define sc(c) scanf("%c", &c) #define sd(f) scanf("%lf", &f)  #define pi(n) printf("%d\n", n) #define pll(l) printf("%lld", l) #define ps(s) printf("%s\n", s) #define pc(c) printf("%c\n", c) #define pd(f) printf("%.20lf\n", f)  #define debug(x) cout<<"\n#("<<x<<")#\n" #define nline printf("\n")  #define mem(a,i) memset(a,i,sizeof(a))  #define MOD 1000000007 #define ll long long int #define u64 unsigned long long int  #define mclr(strn) strn.clear() #define ignr cin.ignore() #define PB push_back #define SZ size #define MP make_pair #define fi first #define sec second  std::vector<int> adj[1000006], A, B; bool vis[1000006]; int cost[1000006]; pair<int,int> sub[1000006]; int parent[1000006]; int totMarbles; int nodes, edges;  pair<int,int> dfs(int node, int par) { 	if(vis[node])	return MP(0,0); 	vis[node] = 1;  	parent[node] = par;  	int i, limit = adj[node].SZ();  	fl(i,0,limit) 	{ 		int v = adj[node][i]; 		pair<int,int> temp = dfs(v,node); 		sub[node].first += temp.first; 		sub[node].second += temp.second; 	}  	sub[node].first++; 	sub[node].second += cost[node];  	return sub[node]; }  int main() { 	int cases; 	int i, j;  	si(cases);  	wl(cases) 	{ 		si(nodes);  		//-------------------------------------- 		 		edges = nodes - 1;  		fl(i,0,nodes) 		{ 			adj[i].clear(); 			cost[i] = 0; 			sub[i].first = sub[i].second = 0; 			vis[i] = 0; 		} 		A.clear(); 		B.clear();  		long double ans = 0.0;  		totMarbles = 0;  		//--------------------------------------  		fl(i,0,edges) 		{ 			int x, y; 			si(x);	si(y);  			adj[x].PB(y); 			adj[y].PB(x); 			A.PB(x);	B.PB(y); 		}  		fl(i,0,nodes) 		{ 			si(cost[i]); 			totMarbles += cost[i]; 		}  		dfs(0,-1);  		//-------------------------------------  		fl(i,0,edges) 		{ 			int na, nb, ma, mb; 			long double pa=1.0, pb=1.0;  			pair<int,int> temp;  			if(parent[A[i]] == B[i]) 			{ 				temp = sub[A[i]]; 			} 			else 			{ 				temp = sub[B[i]]; 				temp.first = nodes - temp.first; 				temp.second = totMarbles - temp.second; 			}  			na = temp.first; 			ma = temp.second;  			nb = nodes - na; 			mb = totMarbles - ma;  			int options = nodes-1;  			long double foroneA = nb/(options*1.0); 			fl(j,0,ma) 				pa *= foroneA;  			long double foroneB = na/(options*1.0); 			fl(j,0,mb) 				pb *= foroneB;  			ans += (pa*pb); 		}  		printf("%.20Lf\n", ans); 		//pd(ans);  	} }
#include<iostream> #define max 1000000 int a[max+1]; using namespace std; int main() { int t,n,i,j,k,x,y,f=0; scanf("%d",&t); while(t--) {           scanf("%d%d",&n,&k);           for(i=1;i<=n;i++)           a[i]=n-i;f=0;           for(i=0;i<k;i++)           {                           scanf("%d%d",&x,&y);                           a[x]--;                           a[y]++;           }           for(i=n;i>=1;i--)           if(a[i]==0)           {                      printf("2 %d\n",i);                      f=1;                      break;           }           if(f==0)           printf("1\n"); } }                                                  
#include<cstdio> int main() { int x; float y; scanf("%d%f",&x,&y);   if(x%5==0&&0.50<y-x) printf("%0.2f",(y-x-0.50)); else printf("%0.2f",y); return(0); }
#include<bits/stdc++.h> using namespace std; int main() {     long long t,n,m,p,q,s,k,i;     while(scanf("%lld",&t)==1)     {         while(t--)         {              scanf("%lld %lld %lld",&n,&k,&m);             i=m;             p=0;             while(m>=n)             {                m/=k;                if(m>=n)                 p++;             }             printf("%lld\n",p);         }     }     return 0; } 
#include <stdio.h> #include <iostream> #include <vector> #include <stack> using namespace std;   void dfs(vector< vector<int> > &vec,int src ,int N,int status[]) { stack <int> s;  status[src] = 2; s.push(src);  while(s.empty() == false) {     int u = s.top();     s.pop();     status[u] = 3;      for (int i=1 ;i<=N;i++){         if (vec[u][i]==1 and status[i]==1)         {             status[i] = 2;             s.push(i);          }     }   }      }     int connected_components(vector< vector<int> > &vec,int N,int status[])   {     int connected_component =0;      for(int i=1;i<=N;i++){          if (status[i] == 1){             connected_component +=1;             dfs(vec,i,N,status);         }     }     return connected_component; }  int main(){  int T,N,M,u,v;  cin >> T ; for(int k=1;k<=T;k++){ cin >> N >> M; vector< vector<int> > vec; int status[N+1],F[N+1];   vec.resize(N+1); for (int i=1;i<=N;i++){     F[i]      = 0;     status[i] = 1;     vec[i].resize(N+1); }  for (int i=1;i<=N;i++){     for(int j=1;j<=N;j++){         vec[i][j]=0;      } }   for (int i=1 ;i<=M;i++){     cin >> u >> v;     vec[u][v] = 1;     vec[v][u] = 1;     F[u] +=1;     F[v]+=1;    }  int check =0; for (int i=1;i<=N;i++){      if (F[i]%2!=0){check=1;break;}  }  if (check == 1){printf("Case %d: No\n",k);}  else{      int cp = connected_components(vec,N,status);         if (cp > 1){printf("Case %d: No\n",k);}      else{         printf("Case %d: Yes\n",k);     }   }     } } 
#include <bits/stdc++.h> using namespace std; int main() { 	int t,f; 	int s; 	cin>>t;  //char c[7]={'E','B','G','D','A','E'};  	for(int i=1;i<=t;i++) 	{ 	    map < string, int > mp; 	mp["E"] = 4; 	mp["B"] = 11; 	mp["G"] = 7; 	mp["D"] = 2; 	mp["A"] = 9; 	string fret[] = {"C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"}; 	string arr[] = {"E", "B", "G", "D", "A", "E"}; 	  scanf("%d %d",&f,&s);         string str=arr[s-1];        int fr=mp[str];        int co=fr+f;        int coo=co%12;         cout<<"Case "<<i<<": "<<fret[coo]<<endl; 	} 	return 0; } 
#include <iostream> #include<bits/stdc++.h> using namespace std;  int main() { 	char arr[350][350]; 	int i,j,c,d,n,t; 	scanf("%d",&t); 	int k=1; 	while(t--) 	{     memset(arr,' ',sizeof(arr)); 	scanf("%d",&n); 	d=n/2; 	c=n+d; 	for(i=0;i<n;i++){ 	for(j=0;j<n;j++){ 	  if(i==0||i==n-1)       {           arr[i][j]='#';       }  	  else if(j==0||j==n-1) 	  {            arr[i][j]='#'; 	  } 	  else{         arr[i][j]=' '; 	  } 	} 	} 	for(i=d;i<c;i++){ 	for(j=d;j<c;j++){ 	  if(i==d||i==c-1)       {           arr[i][j]='#';       }  	  else if(j==d||j==c-1) 	  {  	        arr[i][j]='#'; 	  } 	  else{         if(arr[i][j]!='#')         arr[i][j]=' '; 	  } 	} 	}     cout << "Case " << k << ":" << endl; 	for(i=0;i<c;i++){ 	for(j=0;j<c;j++){ 	  printf("%c",arr[i][j]); 	} 	printf("\n"); 	}     k++; 	} 	return 0; } 
 //BISMILLAHIRRAHMANIRRAHIM /*  manus tar shopner soman boro  all my suceesses are dedicated to my parents  The true test of a man's character is what he does when no one is watching.  Don't let your dreams be dreams.    Author :: Shakil Ahmed .............AUST_CSE27.........  prob   ::  Type   ::  verdict::  */  #include <bits/stdc++.h> #define pb push_back #define mp make_pair  // Macro #define eps 1e-9 #define pi acos(-1.0) #define ff first #define ss second #define re return #define QI queue<int> #define SI stack<int> #define SZ(x) ((int) (x).size()) #define all(x) (x).begin(), (x).end() #define sq(a) ((a)*(a)) #define distance(a,b) (sq(a.x-b.x) + sq(a.y-b.y)) #define iseq(a,b) (fabs(a-b)<eps) #define eq(a,b) iseq(a,b) #define ms(a,b) memset((a),(b),sizeof(a)) #define G() getchar() #define MAX3(a,b,c) max(a,max(b,c)) #define II ( { int a ; read(a) ; a; } ) #define LL ( { Long a ; read(a) ; a; } ) #define DD ({double a; scanf("%lf", &a); a;})  double const EPS=3e-8; using namespace std;  #define FI freopen ("input_B.txt", "r", stdin) #define FO freopen ("output_B.txt", "w", stdout)  typedef long long Long; typedef long long int64; typedef unsigned long long ull; typedef vector<int> vi ; typedef set<int> si; typedef vector<Long>vl; typedef pair<int,int>pii; typedef pair<string,int>psi; typedef pair<Long,Long>pll; typedef pair<double,double>pdd; typedef vector<pii> vpii;  // For loop  #define forab(i, a, b)	for (__typeof (b) i = (a) ; i <= b ; ++i) #define rep(i, n)		forab (i, 0, (n) - 1) #define For(i, n)		forab (i, 1, n) #define rofba(i, a, b)	for (__typeof (b)i = (b) ; i >= a ; --i) #define per(i, n)		rofba (i, 0, (n) - 1) #define rof(i, n)		rofba (i, 1, n) #define forstl(i, s)	for (__typeof ((s).end ()) i = (s).begin (); i != (s).end (); ++i)  template< class T > T gcd(T a, T b) { return (b != 0 ? gcd<T>(b, a%b) : a); } template< class T > T lcm(T a, T b) { return (a / gcd<T>(a, b) * b); } #define __(args...) {dbg,args; cerr<<endl;} struct debugger{template<typename T> debugger& operator , (const T& v){cerr<<v<<"\t"; return *this; }}dbg; #define __1D(a,n) rep(i,n) { if(i) printf(" ") ; cout << a[i] ; } #define __2D(a,r,c,f) forab(i,f,r-!f){forab(j,f,c-!f){if(j!=f)printf(" ");cout<<a[i][j];}cout<<endl;}  template<class A, class B> ostream &operator<<(ostream& o, const pair<A,B>& p){ return o<<"("<<p.ff<<", "<<p.ss<<")";} //Pair print template<class T> ostream& operator<<(ostream& o, const vector<T>& v){ o<<"[";forstl(it,v)o<<*it<<", ";return o<<"]";} //Vector print template<class T> ostream& operator<<(ostream& o, const set<T>& v){ o<<"[";forstl(it,v)o<<*it<<", ";return o<<"]";} //Set print  //Fast Reader template<class T>inline bool read(T &x){int c=getchar();int sgn=1;while(~c&&c<'0'||c>'9'){if(c=='-')sgn=-1;c=getchar();}for(x=0;~c&&'0'<=c&&c<='9';c=getchar())x=x*10+c-'0'; x*=sgn; return ~c;}  //int dx[]={1,0,-1,0};int dy[]={0,1,0,-1}; //4 Direction //int dx[]={1,1,0,-1,-1,-1,0,1};int dy[]={0,1,1,1,0,-1,-1,-1};//8 direction //int dx[]={2,1,-1,-2,-2,-1,1,2};int dy[]={1,2,2,1,-1,-2,-2,-1};//Knight Direction //int dx[]={2,1,-1,-2,-1,1};int dy[]={0,1,1,0,-1,-1}; //Hexagonal Direction  /* **************************************  My code start here ****************************************** */  const int NX = 1e5 + 10 ; char inp[ NX ] , patrn[ NX ] , str[ NX ] ;  int T[ NX ];    int Kmp( ) {     int sz = strlen( patrn );     T[0] = T[1] = 0 ;     int k = 0 ;     for( int i = 2 ; i <= sz ; i++ )     {         //printf(" i :: %d\n" , i );         while( k > 0 && patrn[k] != patrn[i-1] ) k = T[k];         if( patrn[k] == patrn[i-1] ) k++;         T[i] = k ;     }     int ans = 0 ;     int nsz = strlen( inp );     k = 0 ;     for( int i = 0 ; i < nsz ; i++ )     {        // printf("i :: %d\n" , i );         while( k > 0 && patrn[ k ] != inp[i] ) k = T[k];         if( patrn[k] == inp[i] ) k++;         if( k == sz )         {             ans++;             k = T[k];         }     }     return ans ; }   int main() {    // I will always use scanf and printf    // May be i won't be a good programmer but i will be a good human being    //     FI ;      //FO ;      int cs , t = II ;      getchar();     // printf(" t :: %d\n" , t );      for( cs = 1 ; cs <= t ; cs++ )      {          gets( str );           int sz = strlen( str );           int idx = 0 ;          for( int i = 0 ; i < sz ; i++ )          {              if( str[i] == ' ' ) continue ;              inp[idx++] = str[i];          }          inp[idx] = '\0';           scanf("%s\n",patrn);           printf("Case %d: %d\n",cs,Kmp());      }      return 0; }
#include<bits/stdc++.h> using namespace std;  vector<int> adj[1003], idx; #define foreach(it, c) for(typeof(c.begin()) it=c.begin(); it!=c.end();it++) int n, m, ctr[1003], kicked[1003];  bool check() {     for(int i=1;i<=n;i++)     {         if(ctr[i]==1)             idx.push_back(i);     }     if(idx.size()==0)         return false;     else         return true; }  int main() {     int test;     scanf("%d", &test);     while(test--)     {         scanf("%d %d", &n, &m);         for(int i=0;i<m;i++)         {             int u, v;             scanf("%d %d", &u, &v);             ctr[u]++;             ctr[v]++;             adj[u].push_back(v);             adj[v].push_back(u);         }         int ans=0;         while(check())         {             ans++;             foreach(it, idx)             {                 kicked[(*it)]=1;                 ctr[*it]=0;                 foreach(itr, adj[*it])                 {                     if(!kicked[(*itr)])                     {                         ctr[(*itr)]--;                     }                 }                 adj[(*it)].clear();             }             idx.clear();          }         printf("%d\n", ans);         memset(ctr, 0, sizeof(ctr));         memset(kicked, 0, sizeof(kicked));         for(int i=1;i<=n;i++)             adj[i].clear();     } }  
#include<bits/stdc++.h> using namespace std; #define MAX 999999 int par[MAX]; set < int > s; set < int > st; map < string,int> mp; map < int,int> mp2;  #define f(x) (x?x:1) string s1,t2;  int Find(int r) {     if(mp2[r]==r)         return r;     return mp2[r]=Find(mp2[r]); }  void Union(int a,int b) {     int p=Find(a);     int q=Find(b);     if(p!=q)     {         mp2[p]=q;     } }   void makeset(int r) {     mp2[r]=r; }  int main() {       int n;     cin >> n;     int t1=1;     for(int i=1; i<=n; i++)     {         int a,b;         cin >> s1 >> t2;         if(!mp[s1])         {             mp[s1]=t1++;             makeset(mp[s1]);         }         if(!mp[t2])         {             mp[t2]=t1++;             makeset(mp[t2]);         }          if(Find( mp[s1])!=Find(mp[t2]))        {          cout <<  "Found by random" << endl;           Union(mp[s1],mp[t2]);        }        else          cout <<  "Found in friend list" << endl;          // Union(mp[s1],mp[t2]);      }  } 
#include <cstdio> #include <algorithm> using namespace std; int dp[80][80]; char a[80],b[80]; int main(){ int n,m; scanf("%d%d",&n,&m); scanf("%s",a); scanf("%s",b); for(int i=0;i<=n;i++)     dp[i][0]=0; for(int j=0;j<=m;j++)     dp[0][j]=0;     int result=0; for(int i=1;i<=n;i++){     for(int j=1;j<=m;j++){         if(a[i-1]==b[j-1]){             dp[i][j]=dp[i-1][j-1]+1;             result=max(result,dp[i][j]);         }         else             dp[i][j]=0;     } } printf("%d\n",result); return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { 	 		long long int a[100000],b[100000],n,i,j,sum=0; 		scanf("%lld",&n); 		for(i=1;i<=n;i++) 		{ 			scanf("%lld",&j); 			if(i==1) 			{ 				b[i]=j; 				sum=j; 			} 			else 			{ 				b[i]=j*i-sum; 				sum+=b[i]; 			} 			 		} 		for(i=1;i<=n;i++) 		{ 			printf("%lld ",b[i]); 		} 		printf("\n"); 	 	return 0; }
/*itamiyo uketore ,itamiyo sire  */ #include <bits/stdc++.h> #define ff first #define re return #define ss second #define pb push_back #define mpk make_pair #define couts(a) cout<<a<<endl #define pno cout<<"NO"<<endl #define fr(i,a,b) for(ll i=a;i<b;++i) #define cina(a,n) fr(i,0,n)cin>>a[i] #define rf(i,a,b) for(ll  i=a;i>=b;--i) #define pyes cout<<"YES"<<endl #define coutd(a,b) cout<<a<<" "<<b<<endl #define ioS ios_base::sync_with_stdio(0);cin.tie(0); #define coutt(a,b,c)cout<<a<<" "<<b<<" "<<c<<endl; #define coutar(a,n)  fr(i,0,n)cout<<a[i]<<" ";cout<<endl; #define coutq(a,b,c,d)cout<<a<<" "<<b<<" "<<c<<" "<<d<<endl;  using namespace std; typedef long long int ll; typedef long double ld; typedef pair<int,int>pi; typedef long long int ll; typedef vector<int> vi;  const int MAXN = 100005; const ll MOD = 1000000007LL;  ll lcm[3*MAXN], small[3*MAXN]; int arr[MAXN];  struct Node {   int Min,Max,lazy; } sq[4*MAXN];  void sieveprecal()  {    lcm[0] = 0, lcm[1] = 1;    for(int i=2; i<3*MAXN; ++i)     {     if(!small[i])        {             for(int j=i; j<3*MAXN; j+=i) small[j] = i;         }     int p = small[i], j;     for(j=i; j%p==0; j/=p);      if(j == 1) lcm[i] = (lcm[i-1]*(ll)p) % MOD;      else lcm[i] = lcm[i-1];    }  } int ma, mi;  void init(int p, int lo, int hi) {   if(lo == hi) sq[p].Min = sq[p].Max = arr[lo];    else {         int mid = (lo+hi)/2;     init(2*p, lo, mid);     init(2*p+1, mid+1, hi);      sq[p].Min = min(sq[2*p].Min, sq[2*p+1].Min);     sq[p].Max = max(sq[2*p].Max, sq[2*p+1].Max);    } }  void lazyp(int p, int lo, int hi) {   if(sq[p].lazy)     {      sq[2*p].Min += sq[p].lazy, sq[2*p+1].Min += sq[p].lazy;     sq[2*p].Max += sq[p].lazy, sq[2*p+1].Max += sq[p].lazy;     sq[2*p].lazy += sq[p].lazy, sq[2*p+1].lazy += sq[p].lazy;     }    sq[p].lazy = 0; }  void update(int p, int lo, int hi, int i, int j, int key) {   if(lo == i && hi == j) {      sq[p].Min += key;     sq[p].Max += key;     sq[p].lazy += key;      re; }    lazyp(p, lo, hi);    int mid = (lo+hi)/2;    if(j <= mid) update(2*p, lo, mid, i, j, key);   else if(i > mid) update(2*p+1, mid+1, hi, i, j, key);   else     {     update(2*p, lo, mid, i, mid, key);     update(2*p+1, mid+1, hi, mid+1, j, key);     }    sq[p].Min = min(sq[2*p].Min, sq[2*p+1].Min);   sq[p].Max = max(sq[2*p].Max, sq[2*p+1].Max); }  void query(int p, int lo, int hi, int i, int j) {   if(lo == i && hi == j)     {     mi = min(sq[p].Min, mi);     ma = max(sq[p].Max, ma);     re;     }    lazyp(p, lo, hi);   int mid = (lo+hi)/2;    if(j <= mid) query(2*p, lo, mid, i, j);   else if(i > mid) query(2*p+1, mid+1, hi, i, j);   else     {     query(2*p, lo, mid, i, mid);     query(2*p+1, mid+1, hi, mid+1, j);      } }  int main() { ioS;   int n,q;   cin>>n>>q;  cina(arr,n);    sieveprecal();    init(1, 0, n-1);    while(q--) {     int t, i, j, p;     cin>>t>>i>>j;      if(t == 0)     {          cin>>p;          update(1, 0, n-1, i, j, p);     }     else         {        mi =  INT_MAX;       ma = -INT_MAX;       query(1, 0, n-1, i, j);      // coutd(maximum,minimum)       if(t == 1) couts( lcm[ma]);       else couts( lcm[mi]);       }    } } 
#include<stdio.h> #define MOD 1000000007 #define ULL unsigned long long   ULL F(ULL n) {     ULL x[2][2]={{1,1},{1,0}};     ULL res[2][2]={{1,0},{0,1}};     ULL a,b,c,d;     while(n>0)     {         if(n%2==1)         {             a=(res[0][0]*x[0][0])%MOD+(res[0][1]*x[1][0])%MOD;             b=(res[0][0]*x[0][1])%MOD+(res[0][1]*x[1][1])%MOD;             c=(res[1][0]*x[0][0])%MOD+(res[1][1]*x[1][0])%MOD;             d=(res[1][0]*x[0][1])%MOD+(res[1][1]*x[1][1])%MOD;             res[0][0]=a%MOD;             res[0][1]=b%MOD;             res[1][0]=c%MOD;             res[1][1]=d%MOD;         }         a=(x[0][0]*x[0][0])%MOD+(x[0][1]*x[1][0])%MOD;         b=(x[0][0]*x[0][1])%MOD+(x[0][1]*x[1][1])%MOD;         c=(x[1][0]*x[0][0])%MOD+(x[1][1]*x[1][0])%MOD;         d=(x[1][0]*x[0][1])%MOD+(x[1][1]*x[1][1])%MOD;         x[0][0]=a%MOD;         x[0][1]=b%MOD;         x[1][0]=c%MOD;         x[1][1]=d%MOD;         n/=2;     }     return ((res[0][0]%MOD)*(res[0][1]%MOD))%MOD; }   int main() {     int t;     ULL n;     scanf("%d",&t);     while(t--)     {         scanf("%llu",&n);         printf("%llu\n",F(n<<1));     }     return 0; }  
#include<map> #include<set> #include<cmath> #include<ctime> #include<cstdio> #include<cstdlib> #include<cstring> #include<fstream> #include<iostream> #include<algorithm> using namespace std; #define fill(x,y) memset(x,0,y) #define REP(x,y) for(int x=0;x<y;++x) #define max(a,b) ((a)>(b)?(a):(b)) #define min(a,b) ((a)<(b)?(a):(b)) #define lowbit(x) ((x)&-(x)) #define sqr(x) ((x)*(x)) #define cl(x) x.clear() #define INF 1000000000 #define sz(x) x.size() #define pb push_back #define mp make_pair #define oo (~0U>>1) #define eps 1e-8 const int maxn=100003; const int MOD=1000000007; int n,s,a[maxn],F[maxn],G[maxn],*f=F,*g=G; int main() {     int T;     for(scanf("%d",&T);T;--T)     {         scanf("%d%d",&n,&s);         int sa=0,tot=0;         REP(i,n)         {             int l,r;             scanf("%d%d",&l,&r);             if(l<r)sa+=a[tot++]=r-l;             s-=l;         }         if(s<0||sa<s)         {             puts("0");             continue;         }         for(;;)         {             sa=0;             REP(i,tot)             {                  a[i]=min(a[i],s);                  sa+=a[i];             }             if(s>sa-s)s=sa-s;else break;         }         fill(F,4*s+8),fill(G,4*s+8);         f[0]=1;         REP(i,tot-1)         {             int d=a[i]+1;             g[0]=1;             for(int j=1;j<=s;++j)             {                 g[j]=g[j-1]+f[j];                 if(g[j]>=MOD)g[j]-=MOD;                 if(j>=d)g[j]+=MOD-f[j-d];                 if(g[j]>=MOD)g[j]-=MOD;             }             swap(f,g);         }         int d=a[tot-1]+1,ans=0;         REP(i,d)         {             ans+=f[s-i];             if(ans>=MOD)ans-=MOD;         }         printf("%d\n",ans);     }     return EXIT_SUCCESS; } 
#include <iostream> #include <cstdio> #include <cstring> #include <vector> #include <set> #include <utility> using namespace std;  #define N 101 #define FF for(i=0; i<n; i++)for(j=0; j<n; j++)  typedef long long ll; typedef pair<int,int> ii;  int main(){     int t, n, i, j, h, cnt, x, y;     int mark[N][N], dx[4] = {1,-1,0,0}, dy[4] = {0,0,1,-1};     ll k, m, ans, dif, val, d;     ll table[N][N];     set<pair<ll,ii> > live;     scanf("%d",&t);     while (t--) {         scanf("%d %lld %lld", &n, &k, &m);         live.clear();         cnt=0;         memset(mark, 0, sizeof(mark));         FF{             scanf("%lld", &table[i][j]);             m -= table[i][j];             if(table[i][j] >= k)             {                 mark[i][j]=1;                 cnt++;             }         }         FF             if (!mark[i][j]) {                 for(h=0; h<4; h++){                     x = i + dx[h];                     y = j + dy[h];                     if (0 <= x && x < n && 0 <= y && y < n && table[x][y] >= k) break;                 }                 if (h < 4){                     mark[i][j]=1;                     cnt++;                     live.insert(make_pair(-table[i][j], make_pair(i,j)));                 }             };         if (m <= 0)             {             printf("0\n");             continue;             }         if (cnt == 0)             {             printf("Not possible\n");             continue;             }         ans=dif=0;         while(true){             if(live.empty()) {                 ans += (m+cnt-1)/cnt;                 break;             }             pair<ll, ii> p = *live.begin();             val = -p.first + dif;             i = p.second.first;             j = p.second.second;             d = k - val;             if (m <= d*cnt){                 ans += (m+cnt-1)/cnt;                 break;             }             ans += d;             m -= cnt*d;             dif += d;             live.erase(live.begin());             for (h=0; h<4; h++){                 x = i+dx[h];                 y = j+dy[h];                 if(0 <= x && x < n && 0 <= y && y < n && !mark[x][y]){                     mark[x][y]=1;                     cnt++;                     live.insert(make_pair(-table[x][y]+dif, make_pair(x,y)));                 }             }         }         printf("%lld\n",ans);     }     return 0; } 
#include <stdio.h> #include <string.h>  int dp[1<<13][13]; int ar[13][13];  int main(){  	int a,b,c,d,x,z,n,k,m; 	int y,e; 	scanf("%d",&z); 	while(z--){ 	 	scanf("%d %d %d",&n,&m,&k); getchar(); 	for(a=0;a<n;a++){ 		for(b=0;b<m;b++){ 			ar[a][b]=getchar()-'0'; dp[1<<a][b]=ar[a][b]; 		}getchar(); 	}y=0; 	for(a=1;a<(1<<n);a++){ 		d=0; 		for(b=0;b<n;b++){ 			if(a&(1<<b)){ 				x=a; 				x&=~(1<<b); 				e=0; d++; 				for(c=0;c<m;c++){ 					if(ar[b][c]) dp[a][c]=dp[a][c]+e;  					e=e+dp[x][c]; 				} 			} 		} 		if(d==k) for(b=0;b<m;b++) y=y+dp[a][b]; 	} 	printf("%d\n",y); 	for(a=0;a<(1<<n);a++) for(b=0;b<m;b++) dp[a][b]=0; 	} 	return 0; } 
/*	Template by 	Ashwin Kumar 	IIT Delhi */ #include<algorithm> #include<iostream> #include<cassert> #include<cmath> #include<cstdio> #include<cstdlib> #include<cstring> #include<sstream> #include<string> #include<ctime> #include<deque> #include<map> #include<queue> #include<set> #include<stack> #include<vector>	 using namespace std;  typedef pair<int, int> pii; typedef long long LL; #define MOD 1000000007 #define INF 1000000000  vector<int> adj[500]; vector<int> deg; int visited[500];  void dfs(int i) { 	visited[i] = 1; 	deg.push_back(adj[i].size()); 	for (int j = 0; j < adj[i].size(); j++) 		if (!visited[adj[i][j]]) 			dfs(adj[i][j]); }  int main() { 	int T; 	scanf("%d", &T); 	for (int t = 0; t < T; t++) { 		int N, M, u, v; 		scanf("%d %d", &N, &M); 		for (int i = 0; i < N; i++) 			adj[i].clear(); 		for (int i = 0; i < M; i++) { 			scanf("%d %d", &u, &v); 			adj[u-1].push_back(v-1); 			adj[v-1].push_back(u-1); 		} 		memset(visited, 0, sizeof visited); 		int cnt = 0; 		int good = 1; 		for (int i = 0; i < N; i++) { 			if (!visited[i]) { 				deg.clear(); 				dfs(i); 				int n = deg.size(); 				if (n > 1) { 					cnt++; 					sort(deg.begin(), deg.end(), greater<int>()); 					int m = -1;                     for (int j = 1; j <= n; j++)                  		if (deg[j-1] >= j-1)                     		m = j;               		int a = 0, b = 0;               		for (int j = 1; j <= m; j++)              			a += deg[j-1];                		for (int j = m+1; j <= n; j++)               			b += deg[j-1];               		if (a != m*(m-1)+b) {               			good = 0;               			break;               		} 				} 			} 		} 		if (cnt > 2) 			good = 0; 		if (!good) 			printf("NO\n"); 		else 			printf("YES\n"); 	} 	return 0; } 
#include <iostream> #include <algorithm> using namespace std;  int fourst(int d[]) {         if((d[0]+1==d[1] && d[1]+1==d[2] && d[2]+1==d[3]) ||          (d[1]+1==d[2] && d[2]+1==d[3] && d[3]+1==d[4]))         return 1;     return 0; }  int fivest(int d[]) {     if(d[0]+1==d[1] && d[1]+1==d[2] && d[2]+1==d[3] && d[3]+1==d[4])     return 1;     else     return 0; }  int main() {     int t; cin>>t;     while(t--)     {         int dice[5];                 int max[12]={0};         int c1=0,c2=0,c3=0,c4=0,c5=0,c6=0,ce=0,co=0,cf=0,css=0,cls=0,cy=0;         for(int i=0;i<5;i++)         {             cin>>dice[i];             switch(dice[i])             {                 case 1: max[0]++;break;                 case 2: max[1]+=2;break;                 case 3: max[2]+=3;break;                 case 4: max[3]+=4;break;                 case 5: max[4]+=5;break;                 case 6: max[5]+=6;break;             }             if(dice[i]%2==0)             max[6]+=dice[i];             else             max[7]+=dice[i];         }         sort(dice,dice+5);         if(dice[0]==dice[4])         max[8]=40;         else if((dice[0]==dice[1] && dice[2]==dice[4]) || (dice[0]==dice[2] && dice[3]==dice[4]))         max[9]=15;         else if(fivest(dice)==1)         max[10]=30;         else if(fourst(dice)==1)         max[11]=20;         else         ;         sort(max,max+12);         cout<<max[11]<<endl;              }     return 0; }
#include<iostream> #include<stdio.h> #define DIV 1000000  using namespace std;  typedef unsigned long long int Lint;  Lint raise( Lint a, Lint b ) { 	 	Lint d;  	if( b == 0 ) 		return 1; 	else { 		 		if( b & 0x1 ) {  			d = raise( a, ( b - 1 ) / 2 ) % DIV; 			return ( ( a % DIV ) * ( (d * d ) % DIV ) ) % DIV; 		} 		else {  			d = raise( a,  b / 2 ) % DIV; 			return ( d * d ) % DIV; 		} 	} }  int main() { 	 	Lint t, a, b;  	while( 1 ) { 		 		scanf("%llu %llu", &a, &b );  		if( ( a == 0 ) && ( b == 0 ) ) 			break; 		printf("%llu\n", raise( a, b ) );		 	}  	return 0; } 
#include<cstdio> #include<algorithm> #include<iostream> #include<cstdlib> int arr[10]={0,1,6,1,6,5,6,1,6,1}; using namespace std; int main() {    char abhishek[5] ;    int i,n,sum;    while(1)    {       scanf("%s",abhishek) ;       if(abhishek[0]=='#')         break ;       else       {          n=atoi(abhishek) ;          if(n<4)          {            if(n==1)            printf("1\n") ;            if(n==2)            printf("5\n") ;             if(n==3)            printf("4\n") ;                      }                                else           { sum=14 ;            for(i=4;i<=n;i++)            {               sum=sum+arr[i%10];             }            printf("%d\n",sum%10) ;                 }        }                   }  return(0); }  
#include<stdio.h> int main() 	{ 	int a; 	while(scanf("%d\n",&a)!=EOF)	 		{ 		if(a==0||a==1)	printf("%d\n",a); 		else		printf("%d\n",2*a-2); 		} 	return 0; 	} 
#include<iostream> #include<string.h> using namespace std; int n=-1; void makeline() {      for(int i=0;i<2*n+1;i++)         printf("-");      printf("\n"); } int main() {     char a[51][101];     int len[51],i,j;     while(1)     {             cin.getline(a[++n],100);             //scanf("%[^\n]s",a[++n]);             //scanf("\n");             if(strcmp(a[n],"#") == 0)                  break;             len[n] = strlen(a[n]);     }          makeline();     for(i=0;i<36;i++)     {         printf("|");         for(j=0;j<n;j++)         {             if(i < len[j])                printf("%c|",a[j][i]);             else                printf(" |");         }         printf("\n");     }     makeline();         return 0; }
#include<iostream> #include<stdio.h> #include<stack> #include<map> using namespace std; main() { 	stack<char>s; 	map<char,int>m; 	m['+']=1; 	m['-']=2; 	m['*']=3; 	m['/']=4; 	m['^']=5; 	char q, arr[405]; 	string str; 	int t,j,i; 	scanf("%d",&t); 	while(t--) 	{ 		j=0; 	cin>>str; 	 for(i=0;i<str.size();i++) 	 { 	 	if(int(str[i])>95) 	 	arr[j++]=str[i];  		else if(str[i]=='(')  		s.push(str[i]);  		else if(str[i]==')')  		{  while(s.top()!='(') 	 	   { 			arr[j++]=s.top(); 			s.pop(); 	 	   } 	 	   s.pop(); 		 } 	    else if(str[i]=='+'||str[i]=='-'||str[i]=='*'||str[i]=='/'||str[i]=='^'){ 		 	if((s.top()=='(')||(s.empty())) 		 	s.push(str[i]);  			else if(m[str[i]]<m[s.top()])  			arr[j++]=str[i]; 			else 			s.push(str[i]);  			  		} 		  	}  	for(i=0;i<j;i++)  	printf("%c",arr[i]);  	printf("\n"); 	} }
/**  * @link http://www.codechef.com/problems/AXR3P4  * @author Axay  */  #include <stdio.h> #include <iostream> #include <string>  void fun_eval(std::string in){ 	int result, result1; 	char op, op1; 	std::string::iterator it, it_end; 	it = in.begin(); 	it_end = in.end(); 	op = '+'; 	result = 0;  	result1 = 0;  	for(; it != it_end; ++it){ 		switch(*it){ 			case '1': 			case '2': 			case '3': 			case '4': 			case '5': 			case '6': 			case '7': 			case '8': 			case '9': 				result1 *= 10; 				result1 += *it - '0'; 				break; 			case '+': 			case '-': 				if(op == '+') 					result += result1; 				else 					result -= result1; 				op = *it; 				result1 = 0; 		} 	} 	if(op == '+') 		result += result1; 	else 		result -= result1; 	if(!result) 		printf("%s\n", in.c_str()); }  void fun_proc(std::string in, char d, char N){ 	if(d < N){ 		fun_proc(in + '+' + d, d + 1, N); 		fun_proc(in + '-' + d, d + 1, N); 		fun_proc(in + d, d + 1, N); 	} 	else{ 		fun_eval(in + '+' + N); 		fun_eval(in + '-' + N); 		fun_eval(in + N); 	} }  int main(int argc, char* argv[]){ 	char N; 	char ch1 = '1', ch2 = '2';  	do{ 		scanf("%c", &N); 		if(N == '#') 			N -= N; 		else 			fun_proc(std::string() + ch1, ch2, N); 	}while(N); 	return 0; } 
#include<stdio.h> int main() {     int t,i;     scanf("%d",&t);      for(i=1;i<=t;i++)      {          int n,p,x;          scanf("%d%d",&n,&x);          int ar[n];          for(p=0;p<n;p++){         scanf("%d",&ar[p]);          }          int y=0;          for(p=0;p<n;p++){         if(ar[p]>x)               y++;          }          printf("%d\n",y);      } } 
#include <bits/stdc++.h> using namespace std;  #define ll long long #define mod 1000000007 #define si(i) scanf("%lld",&i); #define pi(i) printf("%lld",i); #define rep(i,st,end) for(i=st;i<end;i++)    int main(){          #ifndef ONLINE_JUDGE     	freopen("in","r",stdin);     	freopen("out","w",stdout); 	#endif      	ll n,q; 	si(n); si(q);	 	char s[n+5];     scanf("%s",s+1);     ll arr[256];     memset(arr,0,sizeof(arr));     for(ll i=1;i<=n;i++) arr[s[i]]++;     while(q--){     	ll p;     	si(p);     	if(p==1){     		char c;     		cin>>c;     		printf("%lld\n",arr[c]);     	}else{     		ll x;     		char y;     		si(x);      		cin>>y;     		arr[s[x]]--;     		arr[y]++;     		s[x]=y;     	}     }     return 0; }
#include <bits/stdc++.h> using namespace std;  #define ll long long #define mod 1000000007 #define si(i) scanf("%lld",&i); #define pi(i) printf("%lld",i); #define rep(i,st,end) for(i=st;i<end;i++)   bool comp(pair<ll,ll> a,pair<ll,ll> b){ 	if(a.second < b.second) return true; 	else if(a.second == b.second){ 		if(a.first < b.first) return true; 		else return false; 	} 	else return false; }  int main(){          #ifndef ONLINE_JUDGE     	freopen("in","r",stdin);     	freopen("out","w",stdout); 	#endif      	ll t; 	si(t); 	while(t--){ 		ll n; 		si(n); 		vector< pair<ll,ll> > v; 		for(ll i=0;i<n;i++){ 			ll j,k; 			si(j); si(k); 			v.push_back(make_pair(j,k)); 		} 		sort(v.begin(),v.end(),comp); 		ll cnt=0,prev=0; 		for(ll i=0;i<v.size();i++){ 			if(v[i].first > prev){ 				cnt++; 				prev=v[i].second; 			} 		} 		printf("%lld\n",cnt); 	}     return 0; }
#include <bits/stdc++.h> using namespace std;  #define ll long long #define mod 1000000007 #define si(i) scanf("%lld",&i); #define pi(i) printf("%lld",i); #define rep(i,st,end) for(i=st;i<end;i++)    int main(){          #ifndef ONLINE_JUDGE     	freopen("in","r",stdin);     	freopen("out","w",stdout); 	#endif      	ll t;	 	si(t);     while(t--){     	ll n,m,q;     	si(n); si(m);     	vector<ll> row,column;     	row.push_back(0); row.push_back(n);     	column.push_back(0); column.push_back(m);     	si(q);     	while(q--){     		ll i,j;     		si(i); si(j);     		row.push_back(i);      		column.push_back(j);     	}     	sort(row.begin(),row.end());     	sort(column.begin(),column.end());      	ll mn_row=mod,mx_row=0;       	for(ll i=1;i<row.size();i++){     		if(row[i]==row[i-1]) continue;     		mn_row=min(mn_row,row[i]-row[i-1]);     		mx_row=max(mx_row,row[i]-row[i-1]);     	}      	ll mn_column=mod,mx_column=0;      	for(ll i=1;i<column.size();i++){     		if(column[i]==column[i-1]) continue;     		mn_column=min(mn_column,column[i]-column[i-1]);     		mx_column=max(mx_column,column[i]-column[i-1]);     	}      	printf("%lld %lld\n",mn_row*mn_column,mx_row*mx_column);     }     return 0; }
#include<bits/stdc++.h>  #define MOD 1000000007 #define MODSET(d) if ((d) >= MOD) d %= MOD;  using namespace std;  const int LK = 17;  int gcdArray[LK][100005];  int getGCDQuery(int l, int r) {     if (l == r)     {         return gcdArray[0][l];     }     else     {         int k = log2(r - l);         return __gcd(gcdArray[k][l], gcdArray[k][r - (1 << k) + 1]);     } }  int main() {     #ifdef VSP4     freopen("input.txt", "r", stdin);     freopen("output.txt", "w", stdout);     #endif // VSP4      long long int t, n, k, i, j, first, last, mid, curr, ans;      cin >> n >> k;      for (i = 0; i < n; i++)     {         cin >> gcdArray[0][i];     }      for (j = 1; j < LK; j++)     {         for (i = 0; i < n - (1 << j) + 1; i++)         {             gcdArray[j][i] = __gcd(gcdArray[j-1][i], gcdArray[j-1][i + (1 << (j - 1))]);         }     }      ans = 0;      for (i = 0; i < n; i++)     {         first = i;         last = n-1;         curr = -1; //impossible initially          while (first <= last)         {             mid = (first + last) / 2;              if (getGCDQuery(i, mid) >= k)             {                 curr = mid;                 first = mid + 1;             }             else             {                 last = mid - 1;             }         }          if (curr != -1) //if at all possible gcd >= k         {             ans = max(ans, curr - i + 1);         }      }      cout << ans << "\n";      return 0; } 
#include <string> #include <vector> #include <stack> #include <queue> #include <deque> #include <cstdlib> #include <cstdio> #include <cmath> #include <algorithm> #include <list> #include <map> #include <set> #include <utility> #include <iostream> #include <iomanip> #include <string.h>  using namespace std;  typedef long long ll; #define debug(args...) dbg(),args #define FOR(A,B,C) for(int A=B;A<C;A++) #define PB(A,B) A.push_back(B); #define ALL(A) A.rbegin(),A.rend() #define MEM(A,B) memset(A,B,sizeof(A)) #define MAX(A,B) (A > B) ? A : B #define MIN(A,B) (A < B) ? A : B #define DBGCHECK if (argc > 1) DBG = ((*argv[1] == '0') ? 0 : 1) #define tr(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) #define LIM 100 #define MOD 100000007LL #define INF 1000000000 #define EPS 0.0001 bool DBG; struct dbg { template<typename T> dbg& operator , (const T& v) { if (DBG) cerr << v << " "; return *this; } ~dbg() { if (DBG) cerr << endl; } };  double x[51],y[51],s[51]; int n;  double func(double a,double b){     double ans = 0,time;     FOR(i,0,n){         time = ((a - x[i])*(a - x[i]) + (b - y[i])*(b - y[i]))/(s[i]*s[i]);         ans = MAX(ans,time);         }     return ans; }  double g(double x){     double lowy = -1000000, highy = 1000000,mid1,mid2;     while(fabs((highy - lowy)) > EPS){         mid1 = (2*lowy + highy)/3;         mid2 = (lowy + 2*highy)/3;         if(func(x,mid1) >= func(x,mid2))             lowy = mid1;         else             highy = mid2;     }     //debug("Lowy is : ",lowy);     return func(x, lowy); }  double optimum(){     double lowx = -1000000, highx = 1000000,mid1,mid2;     while(fabs((highx - lowx)) > EPS){         mid1 = (2*lowx + highx)/3;         mid2 = (lowx + 2*highx)/3;         if(g(mid1) >= g(mid2))             lowx = mid1;         else             highx = mid2;     }     debug("Lowx is : ",lowx);     return g(lowx); }  int main (int argc, char *argv[]) {     DBGCHECK;     int t;     cin >> t;     while(t--){         cin >> n;         FOR(i,0,n)             cin >> x[i] >> y[i] >> s[i];         cout << sqrt(optimum()) << endl;         }    } 
#include <bits/stdc++.h> #define _ ios_base::sync_with_stdio(false);cin.tie(0); using namespace std; #define pb push_back #define pob pop_back #define pf push_front #define pof pop_front #define mp make_pair #define all(a) a.begin(),a.end() #define bitcnt(x) __builtin_popcountll(x) #define M 1000000007 #define total 500005 //#define M 1000000007 typedef unsigned long long int uint64; typedef long long int int64; /* inline void fast(int &x) {     register int c = getchar_unlocked();     x = 0;     int neg = 0;     for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked());     if(c=='-') {         neg = 1;         c = getchar_unlocked();     }     for(; c>47 && c<58 ; c = getchar_unlocked()) {         x = (x<<1) + (x<<3) + c - 48;     }     if(neg)         x = -x; } */ vector<int64>key; queue<pair<int64,int64> >q; bool visit[100005]; int main(){ 	int64 j,t,k,c,i,f,val; 	cin>>t; 	while(t--){ 		memset(visit,false,sizeof(visit)); 		cin>>k>>c>>i>>f; 		for(j=0;j<k;j++){ 			cin>>val; 			key.pb(val); 		} 		int64 ans=-1; 		q.push(mp(i,0)); 		pair<int64,int64>tmp; 		while(!q.empty()){ 			tmp=q.front(); 			q.pop(); 			if(tmp.first==f){ 				ans=tmp.second; 				break; 			} 			tmp.first=tmp.first%100000; 			visit[tmp.first]=true; 			for(i=0;i<k;i++){ 				int64 x=(tmp.first*key[i])%100000; 				if(visit[x]==false){ 					visit[x]=true; 					q.push(mp(x,tmp.second+1)); 				}	 			} 		} 		if(ans==-1){ 			cout<<-1<<endl; 		} 		else{ 			cout<<ans*c<<endl; 		} 		q=queue<pair<int64,int64> >(); 		key.clear();	 	} 	return 0; }
// headers #include<iostream> #include<bits/stdc++.h> using namespace std; // container #define ALL(container) container.begin(),container.end() #define  VI  vector<int> #define  PII   pair<int,int> #define tr(container, it) \ for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) // loops #define rep(i,j,k) for(int i=j;i<k;i++) #define scan(x) scanf("%d",&x) #define print(x) printf("%d\n",x) // MAX , MIN // GCD int gcd(int a,int b) {   if(!b)   return a;   return gcd(b,a%b); } int main() {  map<int,int> M1,M2;    int n;  cin>>n;  vector<pair<int,int> > V(n);  int search=(n+1)/2;  int ans=INT_MAX;  for(int i=0;i<n;i++)  { 		int x;int y; 		cin>>x>>y; 		V[i]=make_pair(x,y); 		M1[x]++; 		if(M1[x]>=search) 		{ 		   ans=0; 		}  }  if(ans!=0)  {   for(int i=0;i<n;i++)    { 	 if(V[i].first!=V[i].second) 	 { 			M2[V[i].second]++; 			if((M1[V[i].second]+M2[V[i].second])>=search&&M2[V[i].second]<ans) 			{ 				ans=M2[V[i].second]; 			}  	 }    }    if(ans!=INT_MAX)    { 		cout<<ans<<endl;    }    else    cout<<"Impossible"<<endl;   }   else   { 		cout<<"0"<<endl;   }     return 0; } 
//{ #include<iostream> #include<cmath> #include<algorithm> #include<climits> #include<vector> #include<bitset> #include<cstdlib> #include<cstdio> #include<cstring> #include<ctime> #include<map> using namespace std; #define MOD 1000000007LL #define LL long long #define ULL unsigned long long #define LD long double #define MAX(a,b) ((a)>(b)?(a):(b)) #define MIN(a,b) ((a)<(b)?(a):(b)) #define ABS(x)   ((x)<0?-(x):(x)) #define SQR(x) ((x)*(x)) #define CUBE(x) ((x)*(x)*(x)) #define si(n) scanf("%d",&n) #define si2(n,m) scanf("%d %d",&n,&m) #define sf(n) scanf("%f",&n) #define sl(n) scanf("%ld",&n) #define sll(n) scanf("%lld",&n) #define slu(n) scanf("%llu",&n) #define sd(n) scanf("%lf",&n) #define ss(n) scanf("%s",n) #define pnl printf("\n") #define REP(i,n) for(int i=0;i<(n);i++) #define FOR(i,a,b) for(int i=(a);i<(b);i++) #define FORR(i,n,e) for(int i=(n);i>=(e);i--) #define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d)) #define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d))  //#undef mydebug #ifdef mydebug #define DB(x) cout<<#x<<"="<<(x)<<"\n" #define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n" #define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n" #define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n" #define pnld pnl; #else #define DB(x) #define DB2(x,y) #define DB3(x,y,z) #define DB4(x,y,z,a) #define pnld #endif #define FILL(a,b) memset(a,b,sizeof(a)) const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; //template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;} void DBG_ARR(const int A[],int N){cout<<"[";REP(i,N){cout<<A[i]<<" ";}cout<<"]\n";} void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;} ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} //} #define size 100001 char P[size]={0}; int PRIME[size/2]; int AVG_P[size/2]; void precompute(){     P[0]=0;     P[1]=1;     int numPrimes=0;     FOR(i,2,size){         if(!P[i]){             FORD(j,2*i,size,i){                 P[j]=1;             }             PRIME[numPrimes++]=i;         }     }     int reqPrimes=0;     REP(i,numPrimes-2){//n-3,n-2,n-1         int x = PRIME[i];         int y = PRIME[i+1];         int z = PRIME[i+2];         if(2*y==(x+z)){             AVG_P[reqPrimes++]=y;         }        // DB2(i,PRIME[i]);     }  // REP(i,reqPrimes){   //          DB2(i,AVG_P[i]);    // }  } void doThis(){     int N;     si(N);     printf("%d\n",AVG_P[N-1]); }  int main(){ #ifdef amy freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr); #endif precompute(); int t=1; scanf("%d",&t); while(t--){doThis();} #ifdef amy fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC)); #endif return 0; } 
#include<bits/stdc++.h> #define lc(idx) (2*idx+1) #define rc(idx) (2*idx+2) #define mid(l,r) ((l+r)/2) using namespace std; string s; struct Node{int check[2];}; Node TREE[4*100000+11111];  Node MERGE(int l , int r) {     Node temp;     temp.check[0]=0;     temp.check[1]=0;     int x = TREE[l].check[0];     int y = TREE[r].check[1];     if(x>y)     {         temp.check[0]=  x - y;     }     else     {         temp.check[1] = y - x  ;     }      temp.check[1] +=TREE[l].check[1];     temp.check[0] +=TREE[r].check[0];     return temp;  }  void build(int l , int r ,int idx ) {     if(l==r)     {         TREE[idx].check[s[l]-'(']=1;         TREE[idx].check[!(s[l]-'(')]=0;         return ;     }     build(l,mid(l,r),lc(idx));     build(mid(l,r)+1,r,rc(idx));     TREE[idx]=MERGE(lc(idx),rc(idx)); }  void update(int l , int r  , int idx , int qe, int val) {      if(l>qe || r<qe)         return ;      if(l==r)     {         TREE[idx].check[val]=1;         TREE[idx].check[!val]=0;         return ;     }      update(l,mid(l,r),lc(idx),qe,val);     update(mid(l,r)+1,r,rc(idx),qe,val);     TREE[idx]=MERGE(lc(idx),rc(idx));     return ; }  bool check() { //    cout<<TREE[0].check[0]<<" "<<TREE[0].check[1]<<"\n";      if( TREE[0].check[0] || TREE[0].check[1] )             return 0;     return 1; }  int main() {      ios::sync_with_stdio(0);     cin.tie(0);     cin>>s;      build(0,s.length()-1,0);     int q; //    check();      cin>>q;     for(;q;--q)     {         int l ,r ;         cin>>l>>r;         update(0,s.length()-1,0,l,s[r]-'(');         update(0,s.length()-1,0,r,s[l]-'(');         swap(s[l],s[r]);          if(check())             cout<<"Yes\n";         else             cout<<"No\n";     }       return 0; } 
#include<bits/stdc++.h> #define len(a) strlen(a) #define ll long long #define nl printf("\n") #define mod 1000000007 //#define ip(a) scanf("%I64d",&a) #define f first #define s second #define db printf("debug") #define yes printf("YES\n") #define no printf("NO\n") #define pb(a) push_back(a) #define po(a) pop_back() #define mp(a,b) make_pair(a,b) #define set(a,v) memset(a,v,sizeof(a))  #define sz(v) v.size() #define pcase(i) printf("Case #%d:\n",i) #define gc getchar//_unlocked  using namespace std;   // program to insert n string int trie and search q string if present in trie or not struct trie_node {     trie_node* child[27];     bool leaf; };  struct trie_node* new_node() {     struct trie_node *tmp= NULL;     tmp = (struct trie_node*) malloc(sizeof(trie_node));     if(tmp!=NULL)     {         tmp->leaf = false;         for(int i=1;i<=26;i++)             tmp->child[i] = NULL;     }     else         printf("Memory error\n");      return tmp;  }  void insert(struct trie_node *root, string s) {     struct trie_node *next = root;     int l= s.size(),i;     for(i=0;i<l;i++)     {         int id = s[i]-96;         if(next->child[id]==NULL)         {             next->child[id] = new_node();         }         next = next->child[id];     }     next->leaf = true; }  bool search(struct trie_node *root, string s) {     int i,l;     struct trie_node *next = root;     l = s.size();     for(i=0;i<l;i++)     {         int id= s[i]-96;         next =  next->child[id];     }     for(i=1;i<=26;i++)     {         if(next->child[i]!= NULL)             return true;     }     return false; } int main() {     int n,i,q,b=0;     string s;     cin>>n;     vector<string>v;     struct trie_node *root= new_node();     for(i=0;i<n;i++)     {         cin>>s;         insert(root,s);         v.pb(s);         //cout<<"added\n";     }    /* printf("sorted\n");     sort(v.begin(), v.end());     for(i=0;i<v.size();i++)         cout<<v[i]<<"\n";      cout<<"\nfor each\n";     */     for(i=0;i<v.size();i++)     {         //cout<<v[i]<<"\n";         if(search(root,v[i]))             {                 b=1;                 break;             }     }     if(b)         printf("vulnerable\n");     else        printf("non vulnerable\n");  } 
#include<iostream> #include<cstdio> using namespace std;  void change(int num,int base) { int arr[10000],i=0; while(num>0) { arr[i]=num%base; num=num/base; i++; } i--; for(i;i>=0;i--) printf("%d",arr[i]); }  int main() { int t,num,base; scanf("%d",&t); while(t--) { scanf("%d %d",&num,&base); if(num==0) printf("0"); else change(num,base); printf("\n"); } return 0; }
#include <stdio.h> #include <stdlib.h>  typedef unsigned long long ULL;  ULL gcd(ULL a,ULL b){   ULL c;   while(b>0) c=a%b, a=b, b=c;   return a; }  ULL bin(ULL n,ULL k){ 	if(k>n)return 0;   if(k> n - k )       k = n - k;     ULL p,i,d;   p=1;  for(i=1;i<=k;i++){     d=gcd(p,i);     p/=d;     p*=(n-i+1)/(i/d);   }   return p; }  int main(){   int TST;   scanf("%d",&TST);   while(TST--){     ULL n,k,ans;     scanf("%llu %llu",&n,&k);     ans=bin(n,k);     printf("%llu\n",ans);   }   return 0; } 
#include <stdio.h> #include <stdlib.h>           typedef unsigned long long ULL;           int main(){    ULL TST,n,sto;    scanf("%llu",&TST);     while(TST--){  scanf("%llu",&n);           	      sto= (n*n)-(n-1)*(n-1);                   if((n&(n-1))) printf("Yes\n");                   else  printf("No\n");           }           return 0;         }  
#include<bits/stdc++.h> using namespace std;  int findLength(char str[], int n) {     int ans = 0;       for (int i = 0; i <= n-2; i++)     {          int l = i, r = i + 1;           int lsum = 0, rsum = 0;           while (r < n && l >= 0)         {             lsum += str[l] - '0';             rsum += str[r] - '0';             if (lsum == rsum)                 ans = max(ans, r-l+1);             l--;             r++;         }     }     return ans; }   int main() {     int t;     cin >> t;     while(t--){         char str[1000];         cin >>str;         cout << findLength(str, strlen(str)) <<endl;     }     return 0; } 
#include<iostream> using namespace std; int fact(int n) {     if(n==0)         return 1;     int t=1;     for(int i=n;i>0;i--)     t=t*i;         return t; } int main() { int t; cin>>t; for(int i=0;i<t;i++) { int a[11]; for(int j=0;j<11;j++) cin>>a[j]; int k; cin>>k; for(int j=0;j<k;j++) { int m=0,p=-1; for(int l=j;l<11;l++) { if(a[l]>m){ m=a[l]; p=l; } } int temp=a[j]; a[j]=m; a[p]=temp; } int q=a[k-1]; //cout<<q<<endl; int x=0,y=0; for(int j=0;j<k;j++) {     if(a[j]==q)         x++; } for(int j=0;j<11;j++)     if(a[j]==q)     y++; int c=fact(y); //cout<<"n "<<c<<endl; int v=fact(x); //cout<<" r "<<v<<endl; int u=fact(y-x); cout<<(c/(v*u))<<endl; } return 0; } 
#include <bits/stdc++.h> using namespace std;  typedef long long ll; typedef unsigned long long ull; typedef pair<int,int> pii; typedef map<int,int> mii; typedef vector<int> vi; typedef vector<pii> vpii; typedef vector< vector<int> > vvi; typedef vector< vector<pii> > vvpii;  #define rep(i,n) for(int i=0;i<int(n);i++) #define forup(i,a,b) for(int i=int(a);i<=int(b);i++) #define fordn(i,a,b) for(int i=int(a);i>=int(b);i--) #define fi first #define se second #define all(x) x.begin(),x.end() #define permute(x) next_permutation(all(x)) #define mp make_pair #define pb push_back #define INF 2000000000 // 2 * 10^9 #define MOD 1000000007 // 10^9 + 7 #define debug if(printf("JJ ")) #define trace(x) cout << #x << " = " << x << endl  char adj[1002][1002]; stack<int> S; int t,n; bool visited[1002];  void dfs(int start){     visited[start]=1;     rep(i,n) if(adj[start][i]=='1' && !visited[i]) dfs(i);     S.push(start); }  int main(){     scanf("%d",&t);     while(t--){         scanf("%d",&n);         rep(i,n) scanf("%s",adj[i]);         rep(i,n) visited[i]=0;         rep(i,n) if(!visited[i]) dfs(i);         while(!S.empty())             printf("%d ",S.top()+1),S.pop();         puts("");     } } 
#include<bits/stdc++.h> using namespace std;  typedef long long ll; typedef vector<int> vi; typedef pair<int,int> pii; typedef pair<ll,ll> pll; typedef vector<pii> vpii; typedef unsigned long long llu;  #define author ayushtomar #define debug(x) cerr<<#x<<" "<<x<<endl; #define f first #define s second #define mp make_pair #define pb push_back int A[100+2][100+2][100+2][100+2]; char s1[102],s2[102],s3[102],s4[102]; int main() {      int t,l,m,n,o;     scanf("%d",&t);     while(t--)     {         scanf("%s %s %s %s",s1,s2,s3,s4);         l=strlen(s1);m=strlen(s2);n=strlen(s3);o=strlen(s4);            for(int i=0;i<=l;i++)             for(int j=0;j<=m;j++)               for(int k=0;k<=n;k++)                  for(int z=0;z<=o;z++)                       A[i][j][k][z]=0;          for(int i=1;i<=l;i++)             for(int j=1;j<=m;j++)              for(int k=1;k<=n;k++)                for(int z=1;z<=o;z++)         {             if(s1[i-1]==s2[j-1] && s3[k-1]==s4[z-1]&&s1[i-1]==s3[k-1])                 A[i][j][k][z]=1+A[i-1][j-1][k-1][z-1];             else                 A[i][j][k][z]=max(max(A[i-1][j][k][z],A[i][j-1][k][z]),max(A[i][j][k-1][z],A[i][j][k][z-1]));         }         printf("%d\n",l+m+n+o-4*A[l][m][n][o]);     }     return 0; } 
#include<bits/stdc++.h> void f(int a){ if(a==0||a==1||a==2) printf("1\n"); else printf("%lld\n",(long long int)floor((log(2*acos(-1)*a)/2+a*(log(a)-1))/log(10))+1); } using namespace std; int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		int n; 		cin>>n; 		f(n); 	} } 		 
//Matrix multiplication  #include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<map> #include<set> #include<queue> #include<utility> #include<cstring> #include<cmath> #define LL long long int #define mod 1000000007 #define vi vector<int> #define vvi vector < vi > #define pii pair<int,int> #define all(c) c.begin(),c.end() #define sf(x) scanf("%d",&x); #define sf2(x,y) scanf("%d%d",&x,&y); #define mem(a,val) memset(a,val,sizeof(a)) #define nl printf("\n"); #define pb push_back #define mp make_pair //#define f first //#define s second #define cf I64 using namespace std; LL mat[5][5],temp[5][5],ans[5][5]; LL t3,t2,t1,a,b,c,d; void multiply_matrix(LL n) {	LL i,j,k,val; 	while(n>0) 	{	if(n%2==0) 		{	//mat[][]*mat[][] 			for(i=1;i<=4;i++) 			{	for(j=1;j<=4;j++) 				{	temp[i][j]=0; 					for(k=1;k<=4;k++) 						temp[i][j]=(temp[i][j]%mod+(mat[i][k]%mod*mat[k][j]%mod)%mod)%mod; 				} 			} 			for(i=1;i<=4;i++) 				for(j=1;j<=4;j++) 					mat[i][j]=temp[i][j]%mod; 			n/=2; 		} 		else if(n%2==1) 		{	//ans[][]*mat[][] 			for(i=1;i<=4;i++) 			{	for(j=1;j<=4;j++) 				{	temp[i][j]=0; 					for(k=1;k<=4;k++) 						temp[i][j]=(temp[i][j]%mod+(ans[i][k]*mat[k][j])%mod)%mod; 				} 			} 			for(i=1;i<=4;i++) 				for(j=1;j<=4;j++) 					ans[i][j]=temp[i][j]%mod; 			n--;	 		} 	} 	//Find ans 	val=(ans[1][1]*t3)%mod; 	val=(val+(ans[1][2]*t2)%mod)%mod; 	val=(val+(ans[1][3]*t1)%mod)%mod; 	val=(val+(ans[1][4]*d)%mod)%mod; 	cout<<val<<endl; } int main() {	LL t,i,j,n; 	cin>>t; 	while(t--) 	{	cin>>a>>b>>c>>d; 		cin>>t1>>t2>>t3; 		cin>>n; 		if(n==1)		cout<<t1; 		else if(n==2)	cout<<t2; 		else if(n==3)	cout<<t3; 		else  		{	//Create matrix 			mem(mat,0); 			mem(ans,0); 			mat[1][1]=a;mat[1][2]=b;mat[1][3]=c;mat[1][4]=1; 			mat[2][1]=mat[3][2]=mat[4][4]=1; 			for(i=1;i<=4;i++) ans[i][i]=1; 			multiply_matrix(n-3); 		} 	} 	return 0; } 
/* Sab moh maya hai  _._ _..._ .-',     _.._(`)) '-. `     '  /-._.-'    ',/    )         \            '.   / _    _    |             \  |  a    a    /              |  \   .-.                     ;   '-('' ).-'       ,'       ;      '-;           |      .'         \           \    /         | 7  .__  _.-\   \         | |  |  ``/  /`  /        /,_|  |   /,_/   /           /,_/      '`-' */ #include<bits/stdc++.h> using namespace std; typedef long long ll; typedef vector<int> vi; typedef pair<int,int> pii; typedef pair<ll,ll> pll; typedef vector<pii> vpii; typedef unsigned long long llu;  #define debug(x) cerr<<#x<<" "<<x<<endl; #define f first #define s second #define mp make_pair #define pb push_back #define MAX 2750197+4 #define MOD 1000000007 int degree[200+10]; void make_zero() {     for(int i=0;i<=201;i++)         degree[i]=0; } int main() {     int t,i,n,m;     scanf("%d",&t);     while(t--)     {         scanf("%d %d",&n,&m);         make_zero();         while(m--)         { int a,b;             scanf("%d %d",&a,&b);             degree[a]++;             degree[b]++;         }         for(i=0;i<=201;i++)             if(degree[i]%2)         {             printf("NO\n");             break;         }         if(i==202)             printf("YES\n");     }       return 0; } 
#include<bits/stdc++.h> using namespace std; #define m 1000000007 int main() {     int t;     cin>>t;     while(t--)     {         long long int n,res=1,num;         scanf("%lld",&n);         for(long long int i=0;i<n;i++)         {             scanf("%lld",&num);             res=(((num)%m)*(res))%m;         }         cout<<(res)%m<<endl;     }      return 0;  } 
#include <bits/stdc++.h> #define gc getchar_unlocked #define fo(i,n) for(i=0;i<n;i++) #define Fo(i,k,n) for(i=k;i<n;i++) #define ll long long #define pii pair<int,int> #define vi vector<int> #define pb push_back #define mp make_pair #define mod 1000000007  using namespace std; void sd(int &x) {     register int c = gc();     x = 0;     for(;(c<48 || c>57);c = gc());     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} } void sd(ll &x) {     register int c = gc();     x = 0;     for(;(c<48 || c>57);c = gc());     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} } int Find(int p[],int a) { 	int n=a; 	int k; 	while(p[a]!=a) a=p[a]; 	while(p[n]!=n) k=p[n], p[n]=a, n=k; 	return a; } int conn(int p[],int a,int b) { 	a = Find(p,a); 	b = Find(p,b); 	if(a==b) return 0; 	p[a]=b; 	return 1; } int main() { 	int t; 	sd(t); 	int i,n,c; 	int a,b,Q,s,d; 	while(t--) 	{	 		sd(n); sd(c); 		int p[n]; 		fo(i,n) p[i]=i; 		while(c--) 		{ 			sd(a); sd(b); 			conn(p,a-1,b-1); 		} 		sd(Q); 		while(Q--) 		{ 			sd(s); sd(d); 			if(Find(p,s-1)==Find(p,d-1)) 			printf("Yes\n"); 			else 			printf("No\n"); 		} 	} 	 	return 0; } 
#include<bits/stdc++.h>  using namespace std;  #define si(x) scanf("%d",&x) #define pri(x) printf("%d",x) #define sll(x) scanf("%lld",&x) #define pll(x) printf("%lld",x) #define sstr(s) scanf("%s",s) #define pstr(s) printf("%s",s) #define nl printf("\n") #define ll long long int #define mod 1000000007 ll a[101][101];  void power(int n, int p) {     if(p==1) 	return;     ll id[n][n],temp[n][n];     memset(temp,0,sizeof(temp));     memset(id,0,sizeof(id));     for(int i=0;i<n;++i) 	for(int j=0;j<n;++j) 	    if(i==j) 		id[i][j]=1;     while(p)     { 	if(p&1) 	{ 	    memset(temp,0,sizeof(temp)); 	    for(int i=0;i<n;++i) 	    { 		for(int j=0;j<n;++j) 		{ 		    for(int k=0;k<n;++k) 		    { 			temp[i][j] = (temp[i][j]+(id[i][k]*a[k][j])%mod)%mod; 		    } 		} 	    } 	    for(int i=0;i<n;++i) 		for(int j=0;j<n;++j) 		    id[i][j]=temp[i][j]; 	} 	memset(temp,0,sizeof(temp)); 	for(int i=0;i<n;++i) 	{ 	    for(int j=0;j<n;++j) 	    { 		for(int k=0;k<n;++k) 		{ 		    temp[i][j] = (temp[i][j]+(a[i][k]*a[k][j])%mod)%mod; 		} 	    } 	} 	for(int i=0;i<n;++i) 	    for(int j=0;j<n;++j) 		a[i][j]=temp[i][j]; 	p=p>>1;     }     for(int i=0;i<n;++i) 	for(int j=0;j<n;++j) 	    a[i][j]=id[i][j]; }  int main() {     int t;     si(t);     while(t--)     { 	int e,n; 	si(n); si(e); 	memset(a,0,sizeof(a)); 	int x,y; 	for(int i=0;i<e;++i) 	{ 	    si(x); si(y); 	    a[x][y]++; 	    a[y][x]++; 	} 	int q,l; 	si(q); si(l); 	power(n,l); 	while(q--) 	{ 	    si(x); si(y); 	    pll(a[x][y]%mod); nl; 	}     }     return 0; } 
#include<bits/stdc++.h> using namespace std;  const int N=1234; char s[N];  bool pali(int low, int high) {     int len=high-low+1;     for(int i=0;i<len;i++) {         if(s[i+low]!=s[len-i-1+low]) return false;     }     return true; }  int main() {     int test;     scanf("%d", &test);     while(test--) {         scanf("%s", s);         int len=strlen(s);         int ans=len;         for(int i=0;i<len;i++) {             for(int j=i+1;j<len;j++) {                 if(pali(i, j)) ans++;             }         }         printf("%d\n", ans);     } } 
#include<bits/stdc++.h> using namespace std; vector<int> a[10001]; int n; int visited[10001];   int ways(int x){ 	if(x==n) return 1; 	if(visited[x]==-1){ 		int f=0;         int t=a[x].size(); 		for(int i=0; i<t; i++){ 				f+=ways(a[x][i]);         } 		 		visited[x]=f; 	}     return visited[x]; }   int main(){ 	cin>>n;     memset(visited,-1,sizeof(visited)); 	int x=1,y=1; 	while(x!=0 && y!=0){ 		scanf("%d %d", &x, &y); 		a[x].push_back(y); 	}     int m=ways(1);     printf("%d", m); 	 } 
#include<bits/stdc++.h> using namespace std; string s,s1; int main() { 	long long int t; 	cin>>t; 	while(t--) { 		long long int a[2]={0}; 		s.clear(); 		s1.clear(); 		cin>>s>>s1; 		long long int n = s.size(); 		for(long long int i=0;i<n;i++) { 			if(s[i] !=s1[i]) a[s[i]-'0']++;  		}  		long long int q = min(a[0],a[1]);  		if((!a[0] && s.find('0')==string::npos) || (!a[1] && s.find('1')==string::npos))  cout<<"Unlucky Chef"<<endl;  		else cout<<"Lucky Chef"<<endl<<max(a[0],a[1])<<endl; 	} 	return 0; }  
#include<bits/stdc++.h> using namespace std; int count_bits (int n) {     int c=0,a;     while(n!=0)     {         a = n%2;         if(a==1)             c++;         n = n/2;     }     return c; } int main() {     int i,j,k,l,m,n,tc,ans;     while(cin>>tc)     {         for(l=1;l<=tc;l++)         {             ans=0;             cin>>n;             for(i=1;i<=n;i++)             {                 ans+=count_bits(i);             }             cout<<ans<<endl;         }     }      return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { 	int t,n,i,j,found; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d",&n); 		int a[n][26],b[26]; 		for(i=0;i<n;i++) 		{ 			for(j=0;j<26;j++) 			a[i][j]=0; 		} 		for(j=0;j<26;j++) 			b[j]=0; 		string str[n],str1; 		for(i=0;i<n;i++) 			cin>>str[i]; 		for(i=0;i<n;i++) 		{ 			for(j=0;j<str[i].length();j++) 			a[i][str[i][j]-'a']++; 		} 		cin>>str1; 		for(i=0;i<str1.length();i++) 		b[str1[i]-'a']++; 		/*for(i=0;i<n;i++) 		{ 			for(j=0;j<26;j++) 			printf("%d ",a[i][j]); 			printf("\n"); 		} 		cout<<str1<<endl;*/ 		for(i=0;i<n;i++) 		{ 			found=0; 			for(j=0;j<26;j++) 			{ 				if(b[j]>a[i][j]) 				{ 					found=1; 					break; 				} 			} 			if(found==0) 			cout<<str[i]<<" "; 		} 		printf("\n"); 	} }
#include<bits/stdc++.h> using namespace std;   long long dp1[100],dp2[100],dp[100];     void comp() {     dp1[0]=dp2[0]=dp[0]=0;     dp1[1]=dp2[1]=1;dp[1]=2;     dp1[2]=2;dp2[2]=1;dp[2]=3;     for(int i=3;i<=65;i++) {         dp1[i]=dp1[i-1]+dp2[i-1]; //correct         dp2[i]=dp1[i-1];         dp[i]=dp1[i]+dp2[i];     } } int main() {   comp();   int t;cin>>t;    while(t--) {         int n;cin>>n;cout<<dp[n]<<endl;     } }
#include<iostream> using namespace std; int main() { ios_base::sync_with_stdio(false); int t; cin>>t; while(t--) { long long int a,b; cin>>a>>b; if(b%2!=0) cout<<b-1<<endl; else if(b-1==a) cout<<(a&b)<<endl; else cout<<b-2<<endl; } return 0; } 
#include<bits/stdc++.h> #define mod 1000000007 using namespace std;  inline void scanint(long long int* x) { 	register char c = getchar_unlocked(); 	*x = 0; 	for(; (c<48)||(c>57);c = getchar_unlocked()); 	for(; (c>47)&&(c<58);c = getchar_unlocked()) 		*x = (long long int)((((*x)<<1ll) + ((*x)<<3ll)) + c - 48); } inline void printint(long int n) { 	if(n == 0) 	{ 		putchar_unlocked('0'); 		putchar_unlocked('\n'); 	} 	else 	{ 		char buf[20]; 		buf[19] = '\n'; 		int i = 18; 		while(n) 		{ 			buf[i--] = n % 10 + '0'; 			n /= 10; 		} 		while(buf[i] != '\n') 			putchar_unlocked(buf[++i]); 	} }  long long int a[1000010];  int main(){                      long long int n,i,maxi=LLONG_MIN,j,tmp,e,o,k,ans=0;           scanint(&n);           for(i=0;i<n;i++){                scanint(&a[i]);                maxi=max(maxi,a[i]);           }            j=ceil(log2(maxi));            for(i=0;i<=32;i++){               tmp=(1ll<<i);               e=0;               o=0;               for(k=0;k<n;k++){                   if((a[k]&tmp)!=0)                     o++;                   else e++;               }               ans+=o*e*tmp;           }            cout<<ans<<endl;       } 
#include <bits/stdc++.h> #define _ ios_base::sync_with_stdio(false);cin.tie(0); using namespace std; #define pb push_back #define pob pop_back #define pf push_front #define pof pop_front #define mp make_pair #define all(a) a.begin(),a.end() #define bitcnt(x) __builtin_popcountll(x) #define MOD 1000000000 #define MAXN 500005 typedef unsigned long long int uint64; typedef long long int int64;   int64 dp[51][51][2]; int a[51],n,fin; int64 go(int idx,int pre,int flag){ 	if(idx==n){ 		return 1-flag; 	} 	if(pre!=-1){ 	if(dp[idx][pre][flag]!=-1) 	return dp[idx][pre][flag];} 	// no oper 	int64 ret=0; 	 	for(int x=pre+1;x<=fin;x++){ 		if(x==a[idx]) 		ret+=go(idx+1,x,flag); 		else if(x<a[idx]) 		ret+=go(idx+1,x,0); 		else 		ret+=go(idx+1,x,1); 	} 	dp[idx][pre][flag]=ret; 	return ret; }   int main(){ 	int t,i; 	scanf("%d",&t); 	while(t--){ 		scanf("%d",&n); 		for(i=0;i<n;i++) 		scanf("%d",&a[i]); 		fin=a[n-1]; 		 		for(i=0;i<n;i++){ 			for(int j=0;j<=50;j++){ 				dp[i][j][0]=-1; 				dp[i][j][1]=-1; 			} 		} 		 		cout<<go(0,-1,0)-1<<endl; 	} 	return 0; } 
#include <cstring> #include <cstdio> #include <algorithm>  using namespace std;  const int MAXN = 1e5 + 9, 		  MAXVAL = 3 * MAXN;  typedef long long LL;  int tc,N,t,p,Q; int pos[MAXN]; int tim[MAXN]; int range[MAXN]; LL bit[MAXVAL + 4][11][2];  inline void update(int idx,int T,int val,int state){ 	idx = max(1,idx); 	for(;idx <= MAXVAL;idx += (idx & (-idx))) 		bit[idx][T][state] += val; }  inline LL query(int idx,int T,int state){ 	LL ret = 0LL; 	for(;idx > 0;idx -= (idx & (-idx))) 		ret += bit[idx][T][state]; 	return ret; }  inline void input(){ 	memset(bit,0,sizeof(bit));  	scanf("%d",&N);  	for(int i = 0;i < N;++i){ 	   scanf("%d",&pos[i]); 	   pos[i]++; 	}  	for(int i = 0;i < N;++i) 	   scanf("%d",&tim[i]);  	for(int i = 0;i < N;++i) 	   scanf("%d",&range[i]); }  inline void solve(){ 	for(int i = 0;i < N;++i){ 		update(pos[i],tim[i],1,0); 		update(pos[i] + range[i] + 1,tim[i],-1,0);  		update(pos[i] - range[i],tim[i],1,1); 		update(pos[i] + 1,tim[i],-1,1); 	}  	scanf("%d",&Q); 	while(Q--){ 		scanf("%d %d",&t,&p); 		p++;  		LL ans = 0LL;  		for(int i = 1;i <= 10;++i){ 			int period = t/i; 			int st = period % 2;  			ans = ans + query(p,i,st); 		}  		printf("%lld\n",ans); 	} }  int main (){ 	scanf("%d",&tc);  	while(tc--){ 		input(); 		solve(); 	}  	return 0; }
/*God is greater than any problem that u have and u have to not worry because when u pray and then worry, the worry nullify your prayer He is right here, right now !! */  #include <bits/stdc++.h> using namespace std; #define bitcnt __builtin_popcount #define ln length() #define rep(i, n) for(int i = 0; i < n; i++) #define rrep(i, n) for(int i = n - 1; i >= 0; i--) #define all(a)  a.begin(),a.end() #define LL long long #define limit 1000006 #define sl(n) scanf("%lld", &n) #define s(n)  scanf("%d", &n) #define pl(n) printf("%lld", n) #define pi(n)  printf("%d", n) #define pb push_back #define pn printf("\n") #define mod 1000000007 typedef vector<LL> row; typedef vector<row> matrix;  void print(LL *arr, LL n) { 	rep(i, n) cout << arr[i] << " "; 	cout << endl; }  void solve() { 	char str[10000]; 	scanf("%s", str); 	int count[26]; 	memset(count, 0, sizeof(count)); 	int l = strlen(str); 	for(int i = 0; i < l; i++) { 		count[str[i] - 'a']++; 	} 	int dp[26]; 	memset(dp, 0, sizeof(dp)); 	int parent[26]; 	/*for(int i = 0; i < 26; i++) { 		cout << count[i] << " "; 	} 	cout << endl;*/ 	for(int i = 0; i < 26; i++) { 		parent[i] = i; 	} 	 	for(int i = 0; i < 26; i++) { 		if(count[i] > 0) { 			int maxx = 0; 			int pa = i; 			for(int j = i - 1; j >= 0; j--) { 				if(count[j] > 0 && count[j] <= count[i] && dp[j] >= maxx) { 					maxx = dp[j]; 					pa = j; 				} 			} 			//cout << maxx << " " << pa << endl; 			dp[i] = maxx + 1; 			parent[i] = pa; 		} 	} 	int ans = 0; 	int index = 0; 	for(int i = 0; i < 26; i++) { 		if(ans < dp[i]) { 			ans = dp[i]; 			index = i; 		} 	} /*	cout << endl << ans << " " << index << endl; 	for(int i = 0; i < 26; i++) { 		cout << parent[i] << " "; 	} 	cout << endl;*/ 	int anss[1000], k = 0; 	for(int i = index; i >= 0; i = parent[i]) { 		anss[k++] = i; 		if(i == parent[i]) { 			break; 		} 	} 	for(int i = k - 1; i >= 0; i--) { 		printf("%c", anss[i] + 97); 	} 	pn; }  int main() { 	int t; 	scanf("%d", &t); 	while(t--) { 		solve(); 	} 	return 0; }
#include<stdio.h> #include<algorithm> #define MAX 1009  using namespace std;  inline int mod(int x) {     return x < 0 ? -x : x; }  int min_ops(int *A, int n, int k) {     int i,j,c,ops;     sort(A,A+n);     ops = 1 << 29;     for(i=0;i<n;i=j)     {         for(j=i;j<n && A[j]==A[i];j++);         c = j - i;         if(mod((k - c)) <= ops)             ops = mod(k - c);     }     return ops; }  int main() {     int A[MAX],t,N,K;     scanf("%d",&t);     while(t--)     {         scanf("%d%d",&N,&K);         for(int i=0;i<N;i++)             scanf("%d",&A[i]);         printf("%d\n",min_ops(A,N,K));     }     return 0; } 
#include<iostream> #include<stdio.h> #include<map> #include<algorithm> #include<stack> #include<queue> #include<string.h> #include<string> #include<stdlib.h> #include<math.h> #include<fstream> #include<set> #include<sstream>  using namespace std; typedef long long int ll; typedef unsigned long long ull; ll dp[125][21];  ll ret(ll run,ll ball) { 	 if(ball<=0) 	 { 	    if(run<=0) 		return 1; 		else 		return 0;	 	 }	  	 if(run<=0) 	  return 1; 	if(run>ball*6) 	  return 0; 	 if(dp[run][ball]!=-1) 	 return dp[run][ball]; 	 ll ans = 0; 	  	 ans += ret(run,ball-1); 	 ans += ret(run-1,ball-1); 	 ans += ret(run-4,ball-1); 	 ans += ret(run-6,ball-1); 	 //cout<<ans<<endl; 	 	 dp[run][ball] = ans; 	 return dp[run][ball]; } int main() { 	 	ll tcase,t,n,m,res;     	scanf("%lld",&tcase); 	for(t=1;t<=tcase;t++) 	{ 		 scanf("%lld %lld",&m,&n); 		 memset(dp,-1,sizeof dp); 		 if(n>m*6) 		 res = 0; 		 else 		 res = ret(n,m); 		 printf("%lld\n",res); 	} 	 }
#include <iostream> #include <math.h> using namespace std;  int main() {     int t; cin>>t;     while(t--)     {         int n; cin>>n;         float money=0.0;         for(int i=0;i<n;i++)         money=((money+1)/2) + 1;         int m=floor( (money*1000) +0.5);         money=m/1000.0;         cout<<money<<endl;     }     return 0; } 
//Amit Kumar Gupta               #include<bits/stdc++.h> using namespace std; typedef long long LL; typedef pair<int,int> II; #define REP(i,i1,n) for(int i=i1;i<n;i++) #define REPB(i,i1,n) for(int i=i1;i>=n;i--) #define PB push_back #define MP make_pair #define ALL(c) (c).begin(),(c).end() #define F first #define S second #define SZ(a) (LL)a.size() #define EPS 1e-12 #define MOD 1000000007 #define TR1(x) cerr<<#x<<" : "<<x<<endl #define TR2(x,y) cerr<<#x<<" : "<<x<<" | "<<#y<<" : "<<y<<endl #define FAST_IO ios_base::sync_with_stdio(false);cin.tie(NULL) #define SI(c) scanf("%d",&c) #define SII(c,d) scanf("%d%d",&c,&d) #define SLL(c) scanf("%lld",&c) #define PIN(c) printf("%d\n",c) #define PLLN(c) printf("%lld\n",c) #define N 100010 #define LOGN 21 #define INIT1(array,ST,END,val) for(int i=ST;i<END;i++)array[i]=val #define INIT2(array,nn,mm,val) for(int i=0;i<nn;i++)for(j=0;j<mm;j++)array[i][j]=val //------------------------------------------------------MAIN CODE STARTS HERE--------------------------------------- vector<int> g[N]; int st; LL val[N]; void fact() { 	val[0]=1; 	val[1]=1; 	REP(i,2,N) 	{ 		val[i]=(val[i-1]*i)%MOD; 	} } LL ans; void dfs(int z,int p) { 	REP(i,0,g[z].size()) 	{ 		if(p!=g[z][i]) 		{ 			dfs(g[z][i],z); 		} 	} 	if(p!=-1) 		ans=(ans*val[g[z].size()-1])%MOD; 	else 		ans=(ans*val[g[z].size()])%MOD; }  int main() { 	int t; 	SI(t); 	fact(); 	while(t--) 	{ 		int n; 		SI(n); 		ans=1; 		REP(i,0,n-1) 		{ 			int x,y; 			SII(x,y); 			g[x].PB(y); 			g[y].PB(x); 		} 		SI(st); 		dfs(st,-1); 		PLLN(ans); 		REP(i,0,n+1) 		g[i].clear(); 	} 	return 0; } 
#include<stdio.h> #include<stdlib.h> #include<cstring> #include<iostream> #include<ctype.h> #include<algorithm> #include<vector> #include<string> #include<set> #include<map> #include<stack> #include<queue> #include<cmath> #include<bitset> #include<iomanip> #include<complex> #include<utility>   #define X first #define Y second #define gc getchar_unlocked #define REP(i,n) for(int i=0;i<(n);i++) #define REP_1(i,n) for(int i=1;i<=(n);++i) #define REP_2(i,a,b) for(int i=(a);i<(b);++i) #define REP_3(i,a,b) for(int i=(a);i<=(b);++i) #define REP_4(i,a,b,c) for(int i=(a);i<(b);i+=(c)) #define DOW_0(i,n) for(int i=(n)-1;-1<i;--i) #define DOW_1(i,n) for(int i=(n);0<i;--i) #define DOW_2(i,a,b) for(int i=(b);(a)<i;--i) #define DOW_3(i,a,b) for(int i=(b);(a)<=i;--i) #define FOREACH(a,b) for(typeof((b).begin()) a=(b).begin();a!=(b).end();++a) #define RFOREACH(a,b) for(typeof((b).rbegin()) a=(b).rbegin();a!=(b).rend();++a) #define PB push_back #define PF push_front #define MP make_pair #define IS insert #define ES erase #define IT iterator #define RI reserve_iterator #define PQ priority_queue #define LB lower_bound #define UB upper_bound #define ALL(x) x.begin(),x.end()   #define PI 3.1415926535897932384626433832795 #define EXP 2.7182818284590452353602874713527 #define MOD7 10000007 #define MOD9 1000000009 using namespace std;   typedef long long LL; typedef long double LD; typedef double DB; typedef pair<int,int> PII; typedef vector<int> VI; typedef pair<int,PII> PIII; typedef pair<LD,int> PLDI; typedef vector<PII> VII;   template<class T> T Mul(T x,T y,T P){ T F1=0; while(y) { if(y&1) { F1+=x; if(F1<0||F1>=P)F1-=P; } x<<=1; if(x<0||x>=P)x-=P; y>>=1; } return F1; }   template<class T> T Pow(T x,T y,T P){ T F1=1;x%=P; while(y) { if(y&1) { F1=Mul(F1,x,P); } x=Mul(x,x,P); y>>=1; } return F1; }  template<class T> T Swap(T &x,T &y) { 	int tmp=x; 	x=y; 	y=tmp; }   template<class T> T Gcd(T x,T y){ if(y==0)return x; T z; while(z=x%y){ x=y,y=z; } return y; }  template<class T> T Abs(const T x){ return x<0?-x:x; }  int inline inp() {     register int N = 0, C;     while ((C = gc()) < '0');     do {     N = (N<<3) + (N<<1) + C - '0';     }while ((C = gc()) >= '0');     return N;     } /*------------------------------------------------------------------------------------------------------------------------------------------*/  int val[100005][12]; main() { 	int  i,j,m,x,n,k; 	string str; 	LL sum=0; 	n=inp(); 	m=inp(); 	//getchar(); 	cin>>str; 	val[0][(int)str[0]-'0']++; 	for(i=1;i<n;i++) 	{  	for(j=0;j<10;j++) 	{ 	if(j==str[i]-'0') 	val[i][j]=val[i-1][j]+1; 	else 	val[i][j]=val[i-1][j]; 	} 	} 	/*for(x=2;x<=n;x++) 	{ 		for(i=0;i<=9;i++) 			if(val[x-1][i]>0) 				val[x][i]=val[x-1][i]; 		val[x][a[x]]++; 	}*/ 	/*REP(q,n+1){ 	REP(w,10) 		cout<<val[q][w]<<"  "; 	cout<<endl; 	}*/ 	while(m--) 	{ 		sum=0; 		x=inp(); 		k=str[x-1]-'0'; 		 		for(int i=0;i<10;i++) 		{ 			if(k!=i) 			{ 			if(k-i<0) 			{ 			sum+=val[x-1][i]*(k-i)*(-1);} 			else 			sum+=val[x-1][i]*(k-i); 			} 			}	 		printf("%lld\n",sum); 	} return 0; } 
#include<iostream> #include<cmath> using namespace std; #define LL long long #define I 1000000000 LL diff(LL a,LL b){return (a-b>0)?a-b:b-a;} LL max(LL a,LL b){return (a<b)?a:b;} int main() {  LL T,n,i,j,A[100000],x,ans;  cin>>T;  while(T--)  {   ans=I;x=0;   cin>>n;   for(i=0;i<n;i++)    cin>>A[i];   for(i=A[0];i<=A[n-1];i++)   {    for(j=0;j<n;j++)    {     x+=diff(A[j],i);    }    ans=max(x,ans);x=0;   }   cout<<ans<<endl;  }  return 0; }
#include <iostream> #include <cstdlib> #include <cstring> using namespace std; int main() { 	int n; 	cin>>n; 	int num[10001]; 	memset(num,0,sizeof(num)); 	for(int i=0;i<n;++i) { 		int temp; 		cin>>temp; 		num[temp]++; 	} 	int sum=0; 	for(int i=0;i<10001;++i)  	sum=sum+num[i]/2; 	if(sum==0) 	cout<<"-1"<<endl; 	else 	cout<<sum-1<<endl; 	return 0; }
#include <iostream> #include <string> using namespace std; int main() { 	int t; 	cin>>t; 	for(int i=0;i<t;++i) { 		string s; 		cin>>s; 		int flag=0; 		for(int i=0;i<s.size();++i) { 			if(s[i]=='a' || s[i]=='e' || s[i]=='i' || s[i]=='o' || s[i]=='u') 			flag=1; 		} 		if(flag==1) 		cout<<"Neha wins"<<endl; 		else 		cout<<"Shilpa wins"<<endl; 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; void path(int x, int y, int n,int *P, int &count); void top(int x,int y,int n,  int *P,int &count) { 	if(y-1>=0 && *((P+(y-1)*n)+x)==0) 	{ 	y=y-1; 	path(x,y,n,(int *)P,count);	     } } void down(int x,int y,int n, int *P, int &count) { 	if(y-1<n && *((P+(y+1)*n)+x)==0)     { 	y=y+1; 	path(x,y,n,(int *)P,count);     } } void left(int x,int y,int n, int *P ,int & count) { 	if(x-1>=0 && *((P+y*n)+(x-1))==0	) 	{ 	x=x-1; 	path(x,y,n,(int *)P,count);     } } void right(int x,int y,int n, int *P,int & count) { 	if(x+1<n && *((P+y*n)+(x+1))==0	) 	{ 	x=x+1; 	path(x,y,n,(int *)P,count);    } } void path(int x,int y,int n,int *P,int &count) { 	*((P+y*n)+x)=2; 	if(x==n-1 && y==n-1) 	{ 		count=count+1; 	} 	else 	{ top(x,y,n,(int *)P,count); down(x,y,n,(int *)P,count); left(x,y,n,(int *)P,count); right(x,y,n,(int *)P,count);    }    *((P+y*n)+x)=0; } int main() { 	int n; 	cin>>n;  	int P[n][n]; 	for(int i=0;i<n;i++) 	for(int j=0;j<n;j++) 	cin>>P[i][j]; 	int x=0; 	int y=0; 	int count=0;     path(x,y,n,(int *)P,count); 	cout<<count; 	return 0; }
#include<iostream> #include<algorithm>  using namespace std;  int main() { 	int t,n; cin>>t>>n; 	while(t--) 	{ 		int marks[n]; 		for(int i=0;i<n;i++) 		cin>>marks[i]; 		sort(marks,marks+n); 		cout<<(marks[n-1]-marks[0])<<endl; 	} 	return 0; }
#include <stdio.h>  long long gcd(long long a, long long b) {   if(b == 0) return a;   else return gcd(b, a % b); }  int main() {   int n;   scanf("%d",&n);   long long gcdTillNow;   for(int i = 0; i < n; i++) {     long long x;     scanf("%lld",&x);     if(i == 0) gcdTillNow = x;     else gcdTillNow = gcd(gcdTillNow, x);   }   while(gcdTillNow % 2 == 0) gcdTillNow >>= 1;   printf("%lld\n",gcdTillNow);   return 0; } 
#include<iostream> #include<stdio.h> #include <cstring> #include <vector> #define MOD 1000000007   using namespace std;  typedef long long int lli; lli dp[30][100100]; vector<int> fib;  void init() {   memset(dp,0,sizeof(dp));   fib.push_back(0);   fib.push_back(1);   while(fib[fib.size()-1]<100000) fib.push_back(fib[fib.size()-1]+fib[fib.size()-2]);   //printf("%d\n",fib.size());   for(int i=1;i<fib.size()-1;i++)     {       dp[i][0]=1;       for(int k=2;k<fib.size()-1;k++) 	if(k!=i)       for(int j=fib[k];j<=100000;j++) 	if(dp[i][j-fib[k]]) dp[i][j]=(dp[i][j-fib[k]]+dp[i][j])%MOD;     } }  int main() {   init();      //for(int i=0;i<10;i++) printf("%lld ",dp[3][i]);   int t;   int n,k,ind;    scanf("%d",&t);     while(t--)       { 	scanf("%d%d",&n,&k); 	ind=0; 	for(int i=0;i<fib.size();i++) if(fib[i]==k) ind=i; 	//	printf("%d\n",ind); 	printf("%lld\n",dp[ind][n]);       }   return 0; } 
#include <cstdio> #include <cmath> #include <iostream> #include <set> #include <algorithm> #include <vector> #include <map> #include <cassert> #include <string> #include <cstring>  using namespace std;  #define rep(i,a,b) for(int i = a; i < b; i++) #define S(x) scanf("%d",&x) #define P(x) printf("%d\n",x)  typedef long long int LL; const int MAXN = 10000001;  int prime[MAXN]; int P[MAXN]; vector<int > C[447];  void pre() {  	int rank = 0; 	for(int i = 2; i < MAXN; i++) if(!prime[i]) { 		rank++; 		P[rank] = i; 		if(rank <= 446) C[rank].push_back(0); 		if(rank <= 446) C[rank].push_back(i); 		for(int j = 2*i; j < MAXN; j += i) { 			if(!prime[j]) { 				prime[j] = rank; 				if(rank <= 446) C[rank].push_back(j); 			} 		} 		if(rank <= 446) C[rank].push_back(MAXN); 	}  	rep(i,2,MAXN) { 		if(!prime[i]) prime[i] = 1; 		else prime[i] = 0;  		prime[i] += prime[i-1]; 	} }   int query(int idx, int l, int r) { 	int lo = 0; 	int hi = C[idx].size()-1; 	int y = 0; 	while(lo <= hi) { 		int mi = (lo+hi)>>1; 		if(C[idx][mi] <= r) { 			y  = mi; 			lo = mi+1; 		} else { 			hi = mi-1; 		} 	}  	lo = 0; 	hi = C[idx].size()-1; 	int x = 0; 	while(lo <= hi) { 		int mi = (lo+hi)>>1; 		if(C[idx][mi] >= l) { 			x  = mi; 			hi = mi-1; 		} else { 			lo = mi+1; 		} 	} 	// printf("%d %d %d\n",idx,y,x); 	return y-x+1;  }  int main() { 	int q; 	pre(); 	S(q); 	while(q--) { 		int l,r,k; 		scanf("%d%d%d",&l,&r,&k); 		int num; 		int den = r-l+1; 		if(k > 664579) num = 0; 		else if(k > 446) { 			num = max(prime[r] - prime[max(l-1, P[k])], 0); 		} else { 			num = r-l+1; 			rep(i,1,k+1) num -= query(i,l,r); 			// num = den - num;  		} 		num = den - num; 		int g = __gcd(num, den); 		printf("%d/%d\n",num/g,den/g); 	} 	return 0; }
#include<iostream> #include<algorithm> #include<string> #include<vector> using namespace std; vector<char>v1[26]; vector<char>v2[26][26]; vector<char>v3[26][26][26]; int main() { ios_base::sync_with_stdio(false); int t; cin>>t; while(t--) { string s; cin>>s; string::iterator i; for(int j=0;j<26;j++) v1[j].resize(0); for(int j=0;j<26;j++) for(int k=0;k<26;k++) v2[j][k].resize(0); for(int j=0;j<26;j++) for(int k=0;k<26;k++) for(int y=0;y<26;y++) v3[j][k][y].resize(0); int mark[30]={0},flag=0; for(i=s.begin();i!=s.end();i++) mark[*i-'a']=1; for(int j=0;j<26;j++) { if(!mark[j]) { cout<<(char)('a'+j)<<endl; flag=1; break; } }  if(flag==1) continue;  fill(mark,mark+26,0);  for(i=s.begin();i+1!=s.end();i++) v1[*i-'a'].push_back(*(i+1));  for(int j=0;j<26;j++) { if(flag==1) break; fill(mark,mark+26,0); if(v1[j].size()==0) { cout<<(char)('a'+j)<<"a"<<endl; flag=1; break; } for(vector<char>::iterator it=v1[j].begin();it!=v1[j].end();it++) mark[*it-'a']=1; for(int y=0;y<26;y++) { if(!mark[y]) { flag=1; cout<<(char)('a'+j)<<(char)('a'+y)<<endl; break; } } } if(flag==1) continue; fill(mark,mark+26,0); for(i=s.begin();i+2!=s.end();i++) v2[*i-'a'][*(i+1)-'a'].push_back(*(i+2));  for(int j=0;j<26;j++) { if(flag==1) break; for(int y=0;y<26;y++) { if(flag==1) break; fill(mark,mark+26,0); if(v2[j][y].size()==0) { flag=1; cout<<(char)(j+'a')<<(char)(y+'a')<<"a"<<endl; break; } for(vector<char>::iterator it=v2[j][y].begin();it!=v2[j][y].end();it++) mark[*it-'a']=1; for(int w=0;w<26;w++) if(!mark[w]) { cout<<(char)('a'+j)<<(char)('a'+y)<<(char)('a'+w)<<endl; flag=1; break; } } }  if(flag==1) continue;  for(i=s.begin();i!=s.end();i++) v3[*i-'a'][*(i+1)-'a'][*(i+2)-'a'].push_back(*(i+3));  for(int j=0;j<26;j++) { if(flag==1) break; for(int y=0;y<26;y++) { if(flag==1) break; for(int w=0;w<26;w++) { if(flag==1) break; if(v3[j][y][w].size()==0) { flag=1; cout<<(char)(j+'a')<<(char)(y+'a')<<(char)(w+'a')<<"a"<<endl; break; } fill(mark,mark+26,0); for(vector<char>::iterator it=v3[j][y][w].begin();it!=v3[j][y][w].end();it++) mark[*it-'a']=1; for(int z=0;z<26;z++) if(!mark[z]) { flag=1; cout<<(char)('a'+j)<<(char)('a'+y)<<(char)('a'+w)<<(char)('a'+z)<<endl; break; } } } } } return 0; } 
//Bismillahir Rahmanir Rahmeem  #include<stdio.h> #include<algorithm> #include<iostream> #include<math.h> #include<string.h> #include <stdlib.h> #include<map> #include<queue> #include<stack> #include<utility> #include<stdlib.h> #include<string> #include<set> #include<iomanip> #define INF 1e9 #define lld long long int #define CLR(a) memset(a,0,sizeof(a)) #define RESET(a) memset(a,-1,sizeof(a)) #define act(a) memset(a,1,sizeof(a)) #define setinf(a) memset(a,0b01111111,sizeof(a)); #define FRO freopen("input.txt","r",stdin); #define FROut freopen("output.txt","w",stdout); #define ui unsigned int #define came "came" #define pii pair<int,int> #define plii pair<long long int, int> #define pll pair<long long,long long> #define pic pair<int,char> #define ninf (-1e9)-2 #define inf (1e9)+2 #include<fstream> #include <assert.h> #include <bitset>  #define foreach(x) for(__typeof(x.begin()) it=x.begin(); it!=x.end();it++)  using namespace std; #define pid pair<int,double> #define pdi pair<double,int>  #define PB push_back #define MP make_pair #define pri(x) printf("%d\n",x) #define pi 3.14159265359 #define F first #define S second #define vit vector<int>::iterator  int n,m; char a[55];  lld grid[155]; lld target[155]; lld tw[55];  int main() {     //FRO     tw[0]=1;     int i;     for(i=1;i<55;i++)     {         tw[i]=(tw[i-1]*2);     }     int t;     scanf("%d",&t);     while(t--)     {         CLR(grid);         CLR(target);         int i,j;         scanf("%d %d",&n,&m);         for(i=0;i<n;i++)         {             scanf("%s",a);             for(j=0;j<m;j++)             {                 grid[i]=(grid[i]+(tw[j])*(lld)(a[j]-'0'));             }         }         for(i=0;i<n;i++)         {             scanf("%s",a);             for(j=0;j<m;j++)             {                 target[i]=(target[i]+(tw[j])*(lld)(a[j]-'0'));             }         }         sort(grid,grid+n);         sort(target,target+n);         int res=1e9;         for(i=0;i<n;i++)         {             lld v=grid[i]^target[0];             for(j=0;j<n;j++)             {                 grid[j]^=v;             }             sort(grid,grid+n);             for(j=0;j<n;j++)             {                 if(grid[j]!=target[j])                 {                     break;                 }             }             if(j==n)             {                 res=min(res,__builtin_popcountll(v));             }             for(j=0;j<n;j++)             {                 grid[j]^=v;             }             sort(grid,grid+n);         }         if(res==1e9)         {             res=-1;         }         printf("%d\n",res);     }     return 0; } 
//Bismillahir Rahmanir Rahmeem  #include<stdio.h> #include<algorithm> #include<iostream> #include<math.h> #include<string.h> #include <stdlib.h> #include<map> #include<queue> #include<stack> #include<utility> #include<stdlib.h> #include<string> #include<set> #include<iomanip> #define INF 1e9 #define lld long long int #define CLR(a) memset(a,0,sizeof(a)) #define RESET(a) memset(a,-1,sizeof(a)) #define act(a) memset(a,1,sizeof(a)) #define setinf(a) memset(a,0b01111111,sizeof(a)); #define FRO freopen("input.txt","r",stdin); #define FROut freopen("output.txt","w",stdout); #define ui unsigned int #define came "came" #define pii pair<int,int> #define plii pair<long long int, int> #define pll pair<long long,long long> #define pic pair<int,char> #define ninf (-1e9)-2 #define inf (1e9)+2 #include<fstream> #include <assert.h> #include <bitset>  #define foreach(x) for(__typeof(x.begin()) it=x.begin(); it!=x.end();it++)  using namespace std; #define pid pair<int,double> #define pdi pair<double,int>  #define PB push_back #define MP make_pair #define pri(x) printf("%d\n",x) #define pi 3.14159265359 #define F first #define S second #define vit vector<int>::iterator  int mod=1000000007;  //sieve code start #define N 1000000 bool prime[N]; vector<int> v; int sz;  void sieve() {     int i,j;     int sq=sqrt(N);     memset(prime,1,sizeof(prime));     v.push_back(2);     prime[0]=prime[1]=0;     for(i=4;i<N;i+=2) prime[i]=false;     for(i=3;i<=sq;i+=2)     {         if(prime[i])         {             for(j=i*i;j<N;j+=2*i)             {                 prime[j]=false;             }             v.push_back(i);         }     }     for(;i<N;i+=2)     {         if(prime[i])         {             v.push_back(i);         }     }     sz=v.size(); }  vector<int> factor;  lld pow(lld b,lld p, lld mod) {    lld ret=1;    while(p)    {        if(p%2!=0)        {            ret=(ret*b)%mod;        }        p/=2;        b=(b*b)%mod;    }    return ret; }  int main() {     //FRO     sieve();     int t;     scanf("%d",&t);     while(t--)     {         lld n;         scanf("%lld",&n);         lld x=n;         factor.clear();         int i,j;         for(i=0;i<v.size() && v[i]*v[i]<=n;i++)         {             if(x%v[i]==0)             {                 factor.PB(v[i]);                 while(x%v[i]==0) x/=v[i];             }         }          if(x-1)         {             factor.PB(x);         }          int sz=factor.size();         int mx=1<<sz;          mx=mx-1;         lld ans,res;         n--;         ans=(((n*(n+1))%mod)*(2*n+1))%mod;         ans=(ans*pow(6,mod-2,mod))%mod;         res=0;         for(i=1;i<=mx;i++)         {             lld val=1;             for(j=0;j<factor.size();j++)             {                 if((i & 1<<j))                 {                     val*=factor[j];                 }             }             lld cnt=(n-1)/val;             lld x=cnt;             cnt=(x*(x+1))%mod;             cnt=(cnt*(2*x+1))%mod;             cnt=(cnt*pow(6,mod-2,mod))%mod;             cnt=(cnt*val)%mod;             cnt=(cnt*val)%mod;             if(__builtin_popcount(i)%2)             {                 res=res+cnt;                 res%=mod;             }             else             {                 res=res-cnt;                 res%=mod;                 res=(res+mod)%mod;             }         }         ans-=res;         ans%=mod;         ans=(ans+mod)%mod;         printf("%lld\n",ans);     }     return 0; } 
#include<iostream> using namespace std; long long int dp[111][1111]; #include<bits/stdc++.h> vector<pair<long long int ,long long int > >v; int main()  {  	int n;  	 cin>>n;  	 for(int i=0;i<n;i++)  	  {  	  	long long int a,b;  	  	 cin>>a>>b;  	  	 v.push_back(make_pair(a,b)); 	   } 	     for(int i=0;i<111;i++) 	     for(int j=0;j<1111;j++) dp[i][j]=-1; 	    if(v[0].second!=0) 	     dp[0][v[0].first]=v[0].second; 	     int f=0; 	   for(int i=1;i<n;i++) 	    { 	    	 for(int j=0;j<1111;j++) 	    	  { 	    	  	if(dp[i-1][j]!=-1) 	    	  	 { 	    	  	 	f=1; 	    	  	 	if(dp[i-1][j]>=v[i].second) 	    	  	 	dp[i][j]=max(dp[i-1][j],dp[i][j]); 	    	  	 	dp[i][j+v[i].first]=max(dp[i-1][j]+v[i].second,dp[i][j+v[i].first]); 				   } 				    			  } 			  if(f==0 && v[i].second!=0) dp[i][v[i].first]=v[i].second;   		 }  	//	  for(int i=0;i<100;i++) cout<<dp[i][n-1]; 		 for(int i=0;i<1111;i++) 		  if(dp[n-1][i]!=-1) 		   { 		   	 cout<<i<<endl; 		   	 return 0; 		   } 		    cout<<"0"<<endl; 	   return 0;  }
	#include <cstring> 	#include <vector> 	#include <list> 	#include <map> 	#include <set> 	#include <deque> 	#include <stack> 	#include <bitset> 	#include <algorithm> 	#include <functional> 	#include <numeric> 	#include <utility> 	#include <sstream> 	#include <iostream> 	#include <iomanip> 	#include <cstdio> 	#include <cmath> 	#include <cstdlib> 	#include <ctime> 	#include <memory.h> 	#include <cassert>  	using namespace std;  	const int inf = (int)1e8; 	const int N = 1010;  	const pair <int, int> BAD = make_pair(inf, inf);  	int a[N][N], b[N][N]; 	pair <int, int> upleft[N][N]; 	pair <int, int> downleft[N][N]; 	pair <int, int> upright[N][N]; 	pair <int, int> downright[N][N]; 	pair <int, int> meet_left[N][N]; 	pair <int, int> meet_right[N][N]; 	pair <int, int> meet_up[N][N]; 	pair <int, int> meet_down[N][N];  	inline pair <int, int> add(pair <int, int> x, pair <int, int> y) { 	  return make_pair(x.first + y.first, x.second + y.second); 	}  	int main() { 	  int tt; 	  scanf("%d", &tt); 	  while (tt--) { 	    int h, w; 	    scanf("%d %d", &h, &w); 	    for (int i = 0; i < h; i++) { 	      for (int j = 0; j < w; j++) { 	        scanf("%d", &a[i][j]); 	        b[i][j] = 0; 	      } 	    } 	    int K; 	    scanf("%d", &K); 	    for (int i = 0; i < K; i++) { 	      int x, y; 	      scanf("%d %d", &x, &y); 	      x--; y--; 	      b[x][y]--; 	    } 	    if (a[0][0] == -1 || a[0][w - 1] == -1 || a[h - 1][0] == -1 || a[h - 1][w - 1] == -1) { 	      printf("%d\n", -1); 	      continue; 	    } 	    for (int i = 0; i < h; i++) { 	      for (int j = 0; j < w; j++) { 	        if (a[i][j] == -1) { 	          upleft[i][j] = BAD; 	          continue; 	        } 	        if (i == 0 && j == 0) { 	          upleft[i][j] = make_pair(b[i][j], a[i][j]); 	          continue; 	        } 	        pair <int, int> x = min(i == 0 ? BAD : upleft[i - 1][j], j == 0 ? BAD : upleft[i][j - 1]); 	        upleft[i][j] = make_pair(x.first + b[i][j], x.second + a[i][j]); 	      } 	    } 	    for (int i = h - 1; i >= 0; i--) { 	      for (int j = 0; j < w; j++) { 	        if (a[i][j] == -1) { 	          downleft[i][j] = BAD; 	          continue; 	        } 	        if (i == h - 1 && j == 0) { 	          downleft[i][j] = make_pair(b[i][j], a[i][j]); 	          continue; 	        } 	        pair <int, int> x = min(i == h - 1 ? BAD : downleft[i + 1][j], j == 0 ? BAD : downleft[i][j - 1]); 	        downleft[i][j] = make_pair(x.first + b[i][j], x.second + a[i][j]); 	      } 	    } 	    for (int i = 0; i < h; i++) { 	      for (int j = w - 1; j >= 0; j--) { 	        if (a[i][j] == -1) { 	          upright[i][j] = BAD; 	          continue; 	        } 	        if (i == 0 && j == w - 1) { 	          upright[i][j] = make_pair(b[i][j], a[i][j]); 	          continue; 	        } 	        pair <int, int> x = min(i == 0 ? BAD : upright[i - 1][j], j == w - 1 ? BAD : upright[i][j + 1]); 	        upright[i][j] = make_pair(x.first + b[i][j], x.second + a[i][j]); 	      } 	    } 	    for (int i = h - 1; i >= 0; i--) { 	      for (int j = w - 1; j >= 0; j--) { 	        if (a[i][j] == -1) { 	          downright[i][j] = BAD; 	          continue; 	        } 	        if (i == h - 1 && j == w - 1) { 	          downright[i][j] = make_pair(b[i][j], a[i][j]); 	          continue; 	        } 	        pair <int, int> x = min(i == h - 1 ? BAD : downright[i + 1][j], j == w - 1 ? BAD : downright[i][j + 1]); 	        downright[i][j] = make_pair(x.first + b[i][j], x.second + a[i][j]); 	      } 	    } 	    pair <int, int> ans = BAD; 	    for (int i = 1; i < h - 1; i++) { 	      for (int j = 1; j < w - 1; j++) { 	        if (a[i][j] == -1) { 	          continue; 	        } 	        { 	          pair <int, int> x = add(add(upleft[i][j - 1], downleft[i + 1][j]), add(upright[i - 1][j], downright[i][j + 1])); 	          ans = min(ans, make_pair(x.first + b[i][j], x.second + a[i][j])); 	        } 	        { 	          pair <int, int> x = add(add(upleft[i - 1][j], downleft[i][j - 1]), add(upright[i][j + 1], downright[i + 1][j])); 	          ans = min(ans, make_pair(x.first + b[i][j], x.second + a[i][j])); 	        } 	      } 	    } 	    for (int i = 0; i < h; i++) { 	      for (int j = 0; j < w; j++) { 	        if (a[i][j] == -1) { 	          meet_left[i][j] = BAD; 	          continue; 	        } 	        if (i == 0 && j == 0) { 	          meet_left[i][j] = downleft[i + 1][j]; 	          continue; 	        } 	        if (i == h - 1 && j == 0) { 	          meet_left[i][j] = upleft[i - 1][j]; 	          continue; 	        } 	        meet_left[i][j] = BAD; 	        meet_left[i][j] = min(meet_left[i][j], add(i > 0 ? upleft[i - 1][j] : BAD, i < h - 1 ? downleft[i + 1][j] : BAD)); 	        meet_left[i][j] = min(meet_left[i][j], add(j > 0 ? upleft[i][j - 1] : BAD, i < h - 1 ? downleft[i + 1][j] : BAD)); 	        meet_left[i][j] = min(meet_left[i][j], add(i > 0 ? upleft[i - 1][j] : BAD, j > 0     ? downleft[i][j - 1] : BAD)); 	      } 	    } 	    for (int i = 0; i < h; i++) { 	      for (int j = 0; j < w; j++) { 	        if (a[i][j] == -1) { 	          meet_right[i][j] = BAD; 	          continue; 	        } 	        if (i == 0 && j == w - 1) { 	          meet_right[i][j] = downright[i + 1][j]; 	          continue; 	        } 	        if (i == h - 1 && j == w - 1) { 	          meet_right[i][j] = upright[i - 1][j]; 	          continue; 	        } 	        meet_right[i][j] = BAD; 	        meet_right[i][j] = min(meet_right[i][j], add(i > 0     ? upright[i - 1][j] : BAD, i < h - 1 ? downright[i + 1][j] : BAD)); 	        meet_right[i][j] = min(meet_right[i][j], add(j < w - 1 ? upright[i][j + 1] : BAD, i < h - 1 ? downright[i + 1][j] : BAD)); 	        meet_right[i][j] = min(meet_right[i][j], add(i > 0     ? upright[i - 1][j] : BAD, j < w - 1 ? downright[i][j + 1] : BAD)); 	      } 	    } 	    for (int i = 0; i < h; i++) { 	      pair <int, int> best = BAD; 	      for (int j = 0; j < w; j++) { 	        if (a[i][j] == -1) { 	          best = BAD; 	          continue; 	        } 	        ans = min(ans, add(add(best, meet_right[i][j]), make_pair(b[i][j], a[i][j]))); 	        best = min(best, meet_left[i][j]); 	        best = add(best, make_pair(b[i][j], a[i][j])); 	      } 	    } 	    for (int i = 0; i < h; i++) { 	      for (int j = 0; j < w; j++) { 	        if (a[i][j] == -1) { 	          meet_up[i][j] = BAD; 	          continue; 	        } 	        if (i == 0 && j == 0) { 	          meet_up[i][j] = upright[i][j + 1]; 	          continue; 	        } 	        if (i == 0 && j == w - 1) { 	          meet_up[i][j] = upleft[i][j - 1]; 	          continue; 	        } 	        meet_up[i][j] = BAD; 	        meet_up[i][j] = min(meet_up[i][j], add(j > 0 ? upleft[i][j - 1] : BAD, j < w - 1 ? upright[i][j + 1] : BAD)); 	        meet_up[i][j] = min(meet_up[i][j], add(i > 0 ? upleft[i - 1][j] : BAD, j < w - 1 ? upright[i][j + 1] : BAD)); 	        meet_up[i][j] = min(meet_up[i][j], add(j > 0 ? upleft[i][j - 1] : BAD, i > 0     ? upright[i - 1][j] : BAD)); 	      } 	    } 	    for (int i = 0; i < h; i++) { 	      for (int j = 0; j < w; j++) { 	        if (a[i][j] == -1) { 	          meet_down[i][j] = BAD; 	          continue; 	        } 	        if (i == h - 1 && j == 0) { 	          meet_down[i][j] = downright[i][j + 1]; 	          continue; 	        } 	        if (i == h - 1 && j == w - 1) { 	          meet_down[i][j] = downleft[i][j - 1]; 	          continue; 	        } 	        meet_down[i][j] = BAD; 	        meet_down[i][j] = min(meet_down[i][j], add(j > 0     ? downleft[i][j - 1] : BAD, j < w - 1 ? downright[i][j + 1] : BAD)); 	        meet_down[i][j] = min(meet_down[i][j], add(i < h - 1 ? downleft[i + 1][j] : BAD, j < w - 1 ? downright[i][j + 1] : BAD)); 	        meet_down[i][j] = min(meet_down[i][j], add(j > 0     ? downleft[i][j - 1] : BAD, i < h - 1 ? downright[i + 1][j] : BAD)); 	      } 	    } 	    for (int j = 0; j < w; j++) { 	      pair <int, int> best = BAD; 	      for (int i = 0; i < h; i++) { 	        if (a[i][j] == -1) { 	          best = BAD; 	          continue; 	        } 	        ans = min(ans, add(add(best, meet_down[i][j]), make_pair(b[i][j], a[i][j]))); 	        best = min(best, meet_up[i][j]); 	        best = add(best, make_pair(b[i][j], a[i][j])); 	      } 	    } 	    assert(ans.first >= -K); 	    printf("%d\n", ans.first == -K ? ans.second : -1); 	  } 	  return 0; 	} 
    #include<stdio.h>     long long gcd(long long a,long long b)     { if(b==0)     return a;     return gcd(b,a%b);     }     int main()     { long long t,x1,y1,x2,y2,n1,n2,flag;     scanf("%lld",&t);     while(t--)     { scanf("%lld%lld%lld%lld",&x1,&y1,&x2,&y2);     if(x1<0)     x1=-x1;     if(y1<0)     y1=-y1;     if(x2<0)     x2=-x2;     if(y2<0)     y2=-y2;     n1=gcd(x1,y1);     n2=gcd(x2,y2);     flag=0;     while (n1 > 0 && n1 < n2)     n1 *= 2;     if(n1==n2)     printf("YES\n");     else     printf("NO\n");     }     return 0;     } 
#include <algorithm> #include <iostream> #include <cstring> #include <cstdio> #include <vector> #include <math.h> #include <map> #include <tr1/unordered_map>  using namespace std;  typedef long long ll;  const ll inf = (ll)1e18+1;  struct par{     ll f, s;     par(ll _f, int _s) : f(_f), s(_s){}     par(){};     bool operator <(const par &p)const{         return f < p.f;     } };  std::tr1::unordered_map<ll, int> eq, neq;  int main(){      vector <par> v;     int n, less = 0, Sn = 0;     scanf("%d", &n);     for(int i = 0; i < n; ++i){         int t; ll x;         scanf("%d%lld", &t, &x);         if(t == 1)             v.push_back(par(x, 1));         if(t == 2){             v.push_back(par(x, 2));             ++less;         }         if(t == 3){              v.push_back(par(x, 3));              ++eq[x];         }         if(t == 4){             v.push_back(par(x, 4));             ++neq[x], ++Sn;         }     }      sort(v.begin(), v.end());      int over = 0;     ll val  = 0;     int sol = less + eq[0] + Sn - neq[0] + over, t = 0;     while(t < v[0].f && (eq[t] != 0 && neq[t] != 0))++t;      if(t != v[0].f){         int tmp = less + Sn + over;         if(tmp > sol)             sol = tmp, val = t;     }      v.push_back(par(inf,0));     for(int i = 0; i < v.size(); ++i){        if(v[i].f == inf)break;        int add = 0;        if(v[i].s == 1)++add;        if(v[i].s == 2)--less;         if(v[i].f == v[i+1].f){            int j = i+1;            while(v[j].f == v[i].f){                if(v[i].s == 1)++add;                if(v[i].s == 2)--less;                ++j;            }            i = j-1;         }         int cnt  = less + eq[v[i].f] + Sn - neq[v[i].f] + over;        if(cnt > sol)            sol = cnt, val = v[i].f;         over += add;        ll next = v[i+1].f, x = v[i].f+1;        while(x < next && (eq[x] != 0 && neq[x] != 0)) ++x;         if(x != next){            cnt = less + Sn + over;            if(cnt > sol)               sol = cnt, val = x;        }     }      printf("%d %lld\n", sol, val);     return 0; } 
#include<iostream> #include<algorithm> #include<cstring>  using namespace std;  int main() {     int t;     scanf("%d", &t);     while(t--)     {     long long int c[101][101], a[101][101], b[101][101], maxi[101], total;     int m, n, i, j;     memset(maxi, 0, sizeof(maxi));     scanf("%d %d", &m, &n);     for(i=0;i<m;i++)     {                     for(j=0;j<n;j++)                                     scanf("%lld", &a[i][j]);                     }     for(i=0;i<m;i++)     {                     for(j=0;j<n;j++)                                     scanf("%lld", &b[i][j]);                     }     for(i=0;i<m;i++)     {                     for(j=0;j<n;j++)                                     scanf("%lld", &c[i][j]);                     }     for(i=0;i<m;i++)     {                     for(j=0;j<n;j++)                                     maxi[i]=max(maxi[i], min(a[i][j], b[i][j])*c[i][j]);                     }     total=0;     for(i=0;i<m;i++)                     total+=maxi[i];     printf("%lld\n", total);     }     return 0; } 
    #include <cstdio>     #include <cstring>           struct edge     {     int t, ne;     };           int n, q;     int fed[100020], par[100020], col[100020];     edge ed[200020];           int a[100020], la;     int find( int v )     {     int i;     la = 0;     while ( par[v] != -1 )     {     a[++la] = v;     v = par[v];     }     for ( i = 1; i <= la; i++ )     par[a[i]] = v;     return v;     }           int main()     {     int i, j, k, x, s;     int le = -1;     memset( fed, -1, sizeof( fed ) );     memset( par, -1, sizeof( par ) );     memset( col, -1, sizeof( col ) );     scanf( "%d", &n );     for ( i = 1; i <= n-1; i++ )     {     scanf( "%d %d", &j, &k );     le++;     ed[le].t = k; ed[le].ne = fed[j]; fed[j] = le;           le++;     ed[le].t = j; ed[le].ne = fed[k]; fed[k] = le;     }     scanf( "%d", &q );     for ( i = 1; i <= q; i++ )     {     scanf( "%d %d %d", &x, &j, &k );     if ( x == 1 )     {     col[j] = k;     for ( s = fed[j]; s > -1; s = ed[s].ne )     {     if ( col[ed[s].t] == col[j] )     {     par[find(ed[s].t)] = find( j );     }     }     }     else     {     if ( find( j ) == find( k ) )     printf( "YES\n" );     else printf( "NO\n" );     }     }     return 0;     } 
#pragma comment (linker, "/STACK:1073741824") #define _USE_MATH_DEFINES #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <cassert> #include <fstream> #include <iostream> #include <algorithm> #include <map> #include <set> #include <queue> #include <stack> #include <deque> #include <vector> #include <string> #include <bitset> #include <complex>  using namespace std;  #define SZ(x) (int((x).size())) #define FOR(i, a, b) for(int (i) = (a); (i) <= (b); ++(i)) #define ROF(i, a, b) for(int (i) = (a); (i) >= (b); --(i)) #define REP(i, n) for (int (i) = 0; (i) < (n); ++(i)) #define REPD(i, n) for (int (i) = (n); (i)--; ) #define FE(i, a) for (int (i) = 0; (i) < (int((a).size())); ++(i)) #define MEM(a, val) memset((a), val, sizeof(a)) #define INF 1000000000 #define LLINF 1000000000000000000LL #define PB push_back #define PPB pop_back #define ALL(c) (c).begin(), (c).end() #define SQR(a) ((a)*(a)) #define MP(a,b) make_pair((a), (b)) #define XX first #define YY second  typedef vector<int> vint; typedef vector<long long> vLL; typedef long double dbl; typedef vector<pair<int, int> > vpii; typedef long long LL; typedef pair<int, int> pii;  dbl dp[310];  void solve() {   int n, l;   scanf("%d%d", &n, &l);   MEM(dp, 0);   dp[0] = 1;   REP(i, n) {     REP(j, l + 1) {       dbl p2 = pow((dbl)2.0, j);       dbl prob = dp[j]/p2;       dp[j] += (1.0 - prob);  //      printf("%5.2lf ", (double)dp[j]);     } //    printf("\n");   } //  printf("\n");   dbl sum = 0.0;   REP(j, l + 1) {     sum += dp[j];   }   printf("%.2lf\n", (double)sum); }  int main() { #ifdef    CENADAR_DEBUG   freopen("input.txt", "r", stdin); //  freopen("output.txt", "w", stdout); //  freopen("errput.txt", "w", stderr); #else  // CENADAR_DEBUG //  freopen("input.txt", "r", stdin); //  freopen("output.txt", "w", stdout); #endif // CENADAR_DEBUG    int t;   scanf("%d", &t);   while(t--) solve();    return 0; } 
#include<cstdio>  const int maxn=500+10; const int mod=1000000007;  int inv[maxn]; int C1[maxn][maxn]; int C2[maxn][maxn]; int pow10[maxn]; int ONE[maxn]; int a[10],Q; char s1[maxn],s2[maxn]; int n;  int dalc(int &r1,int &r2,int &ss) { 	r1=r2=1;ss=0; 	int s=0,sum=0; 	for (int i=1;i<10;i++) 	{ 		r1=(long long)r1*C1[s+a[i]][a[i]]%mod; 		r2=(long long)r2*C2[s+a[i]][a[i]]%(mod-1); 		s+=a[i];sum+=i*a[i]; 	} 	ss=(long long)sum*r1%mod*inv[s]%mod*ONE[s]%mod; }  void calc(char s[],int &A,int &B) { 	A=0,B=0; 	for (int i=1,sum=0;i<=n;i++) 	{ 		for (int j=1;j<s[i]-'0';j++) 		{ 			a[j]--; 			int o,oo,ss; 			dalc(o,oo,ss); 			a[j]++; 			int svm=((long long)sum*10+j)%mod; 			B+=((long long)svm*pow10[n-i]%mod*o%mod+ss)%mod; 			if (B>=mod) B-=mod; 			A=(A+oo)%(mod-1); 		} 		a[s[i]-'0']--;sum=((long long)sum*10+s[i]-'0')%mod; 	} 	for (int i=1;i<=n;i++) a[s[i]-'0']++; }  int main() { 	//freopen("input.txt","r",stdin);  	for (int i=1;i<10;i++) {scanf("%d",&a[i]);n+=a[i];} 	for (int i=0;i<=n;i++) 	{ 		C1[i][0]=C2[i][0]=1; 		for (int j=1;j<=i;j++) 		{ 			C1[i][j]=C1[i-1][j]+C1[i-1][j-1]; 			C2[i][j]=C2[i-1][j]+C2[i-1][j-1]; 			if (C1[i][j]>=mod) C1[i][j]-=mod; 			if (C2[i][j]>=mod-1) C2[i][j]-=mod-1; 		} 	} 	inv[1]=1; 	for (int i=2;i<=n;i++) inv[i]=(-(long long)mod/i*inv[mod%i]%mod+mod)%mod; 	pow10[0]=1; 	for (int i=1;i<=n;i++)  		pow10[i]=(long long)pow10[i-1]*10%mod, 		ONE[i]=((long long)ONE[i-1]*10+1)%mod; 	for (scanf("%d",&Q);Q--;) 	{ 		scanf("%s%s",s2+1,s1+1); 		bool ok=0; 		for (int i=1;i<=n;i++) 		if (s1[i]>s2[i]) break;else 		if (s1[i]<s2[i]) {ok=1;break;} 		if (!ok) for(;;);//{printf("0 0\n");continue;for(;;);}  		int b[10],r1=0,r2=0,sum1=0,sum2=0; 		int o1=0,o2=0; 		for (int i=1;i<=n;i++)  			o1=((long long)o1*10+s1[i]-'0')%mod, 			o2=((long long)o2*10+s2[i]-'0')%mod;  		calc(s1,r1,sum1); 		calc(s2,r2,sum2); 		sum2=(sum2-sum1+mod)%mod; 		sum2=(sum2+o2)%mod; 		r2=(r2-r1-1+mod-1)%(mod-1); 		if (r2<0) r2+=mod-1;  		int TWO=1; 		for (int i=2;r2;r2/=2) 		{ 			if (r2&1) TWO=(long long)TWO*i%mod; 			i=(long long)i*i%mod; 		} 		sum2=(long long)sum2*TWO%mod; 		printf("%d %d\n",TWO,sum2); 	} } 		
#include <cstdio> using namespace std; #define R(x) while((ch=getchar())<'0');for (x=ch-'0';(ch=getchar())>='0';) x=x*10+ch-'0'; typedef long long ll; const int mod=1000000007; char ch;int T;long long n,k,mat[10][10],ans[10][10],c[10][10],a[10],Ans[10]; void set(ll* mat,ll a1,ll a2,ll a3,ll a4,ll a5,ll a6,ll a7,ll a8) { 	mat[1]=a1;mat[2]=a2;mat[3]=a3;mat[4]=a4;mat[5]=a5;mat[6]=a6;mat[7]=a7;mat[8]=a8; 	for (int i=1;i<=8;i++) if (mat[i]>=mod) mat[i]%=mod; } void mul(ll a[10][10],ll b[10][10]) { 	for (int i=1;i<=8;i++) for (int j=1;j<=8;j++) { 		c[i][j]=0; 		for (int k=1;k<=8;k++) c[i][j]=(c[i][j]+a[i][k]*b[k][j])%mod; 	} 	for (int i=1;i<=8;i++) for (int j=1;j<=8;j++) a[i][j]=c[i][j]; } void pow(ll a[10][10],ll n) { 	for (int i=1;i<=8;i++) for (int j=1;j<=8;j++) ans[i][j]=(i==j); 	for (int i=0;n>>i;i++) { 		if ((n>>i)&1) mul(ans,a); 		mul(a,a); 	} } int main() { 	R(T);for (;T;T--) { 		R(n);R(k); 		if (n==1) printf("%d\n",k*k); 		if (n==2) printf("%lld\n",k*k*k*k%mod); 		if (n<=2) continue; 		set(mat[1],k-1,(k-1)*(k-2),1,0,0,k-1,0,k-1); 		set(mat[2],k-2,(k-2)*(k-1)+1,0,1,1,k-2,1,k-2); 		set(mat[3],k-1,(k-1)*(3*k-4),0,0,k-1,0,k-1,0); 		set(mat[4],k-2,(k-2)*(k-1)*3+1,0,0,k-2,0,k-2,0); 		set(mat[5],k-1,(k-1)*(k-2),0,0,0,0,0,k-1); 		set(mat[6],k-2,(k-2)*(k-2),0,0,0,0,0,k-2); 		set(mat[7],k-1,(k-1)*(k-2),0,0,0,k-1,0,0); 		set(mat[8],k-2,(k-2)*(k-2),0,0,0,k-2,0,0); 		set(a,k*k*k,k*k*k*(k-1),k,k*(k-1),k*k,k*k*(k-1),k*k,k*k*(k-1)); 		pow(mat,n-2); 		for (int i=1;i<=8;i++) { 			Ans[i]=0; 			for (int j=1;j<=8;j++) Ans[i]=(Ans[i]+a[j]*ans[j][i])%mod; 		} 		printf("%lld\n",(Ans[1]+Ans[2])%mod); 	} } 
#include<stdio.h> //Segment tree with lazy propagation long a[100005]; long v[1000006],sign[1000006],left[1000006],right[1000006],iflag[1000006],dflag[1000006];  int max(int a,int b) { 	if(a>b) 	 	return a; 	 else 	 	return b; }    void init(int node,int b,int e) { 	if(b==e) 	{	v[node]=0; 		sign[node]=1; 		left[node]=a[b]; 		right[node]=a[b]; 		iflag[node]=1; 		dflag[node]=1; 		return; 	} 	 	init(2*node,b,(b+e)/2); 	init(2*node +1 ,(b+e)/2+1,e); 	 	v[node]=0; 	sign[node]=1; 	left[node]=left[2*node]; 	right[node]=right[2*node+1]; 	iflag[node]=(iflag[2*node] && iflag[2*node+1] && right[2*node]<=left[2*node +1]); 	dflag[node]=(dflag[2*node] && dflag[2*node+1] && right[2*node]>=left[2*node +1]); } 	 void update(int node,int b ,int e,int i,int j ,int vaa,int va,int si)	 { 	if(si==-1) 	{ 	int temp; 	temp=iflag[node]; 	iflag[node]=dflag[node]; 	dflag[node]=temp; 	} 	 	v[node]=v[node]*si + va; 	sign[node]=sign[node]*si; 	left[node]=va+ si*left[node]; 	right[node]=va+ si*right[node]; 	  	 	if(i>e || j<b ) 	  return ; 	 	   	if(b>=i && e<=j) 	  { 	  	v[node]=vaa-v[node]; 	  	sign[node]=-1*sign[node]; 	  	 		   		int temp; 		temp=iflag[node]; 	  	iflag[node]=dflag[node]; 	  	dflag[node]=temp; 	  	 	  	left[node]= vaa-left[node]; 	  	right[node]= vaa-right[node]; 	  	return ; 	 } 	  	update(2*node,b,(b+e)/2,i,j,vaa,v[node],sign[node]); 	update(2*node+1,(b+e)/2 +1,e,i,j,vaa,v[node],sign[node]); 	v[node]=0; 	sign[node]=1; 	left[node]=left[2*node]; 	right[node]=right[2*node+1]; 	iflag[node]=(iflag[2*node] && iflag[2*node+1] && right[2*node]<=left[2*node +1]); 	dflag[node]=(dflag[2*node] && dflag[2*node+1] && right[2*node]>=left[2*node +1]); 	  	  	 	 } struct N { int v;   int sign;   int left;   int right;   int iflag;   int dflag;   int flag; }; 	 struct N query(int node,int b,int e,int i,int j,int va,int si) {  	if(si==-1) 	{ 	int temp; 	temp=iflag[node]; 	iflag[node]=dflag[node]; 	dflag[node]=temp; 	} 	 	v[node]=v[node]*si + va; 	sign[node]=sign[node]*si; 	left[node]=va+ si*left[node]; 	right[node]=va+ si*right[node]; 	  	 	if(i>e || j<b ) 	  { struct N C; 	    C.flag=1; 	    return C; 	 } 	 	   	if(b>=i && e<=j) 	  { struct N C; 	  	C.v=v[node]; 	  	C.sign=sign[node]; 	  	 		C.flag=0;   		C.iflag=iflag[node]; 	  	C.dflag=dflag[node]; 	  	 	  	C.left=left[node]; 	  	C.right=right[node]; 	  	return C; 	 } 	  	struct N X,Y,Z; 	X=query(2*node,b,(b+e)/2,i,j,v[node],sign[node]); 	Y=query(2*node+1,(b+e)/2 +1,e,i,j,v[node],sign[node]); 	v[node]=0; 	sign[node]=1; 	left[node]=left[2*node]; 	right[node]=right[2*node+1]; 	iflag[node]=(iflag[2*node] && iflag[2*node+1] && right[2*node]<=left[2*node +1]); 	dflag[node]=(dflag[2*node] && dflag[2*node+1] && right[2*node]>=left[2*node +1]); 	if(X.flag==1) return Y; 	else if(Y.flag==1) return X; 	  	Z.iflag = (X.iflag && Y.iflag && X.right <= Y.left); 				Z.dflag = (X.dflag && Y.dflag && X.right >= Y.left); 				Z.left = X.left; 				Z.right = Y.right; 				Z.v = 0; 				Z.flag=0; 				Z.sign = 1; 				return Z;  	 }  int main() { 	 int n,q,i,va,aa,bb; scanf("%d %d",&n,&q);  for(i=0;i<n;i++) 	scanf("%d",&a[i]);  init(1,0,n-1);  while(q--) { 	scanf("%d %d %d",&va,&aa,&bb); 	if(va!=0) 		update(1,0,n-1,aa,bb,va,0,1); 	else 		{  		struct N u=query(1,0,n-1,aa,bb,va,1); 		  if(u.dflag==1 && u.iflag==1)  		    printf("3\n"); 		  else if(u.dflag==1) 		    printf("2\n"); 		  else if(u.iflag==1) 		    printf("1\n"); 		 else 		    printf("0\n"); 		     		}  } return 0; } 	 	
#include <bits/stdc++.h> using namespace std;  long long a[100001];  int main(){     long long t;     cin >> t;     while(t--){         long long n;         cin >> n;         for(int i = 0; i < n; i++) cin >> a[i];         long long sum = 0;         for(int i = 0; i < n; i++) sum += a[i];         if(sum%n != 0) cout << "No Treat" << endl;         else{             long long x = sum/n;             long long ans = 0;             for(int i = 0; i <n; i++){                 ans+=abs(a[i]-x);             }             if(ans%2 == 0)cout << ans/2 << endl;         }     } } 
#include<iostream> using namespace std; int main() {     int t;     cin>>t;     for(int i=0;i<t;i++)     {         string s;         cin>>s;         int total=0;         while(s.size()!=0)         {             char c=s[0];             for(int j=1;j<s.size();j++)             {                 if(s[j]==c){                     s.erase(j,1);                     //total=total+1;                 break;                 }             }             s.erase(0,1);             total=total+1;         }         cout<<total<<endl;      } } 
//Author : pakhandi   using namespace std;   #include<iostream> #include<string.h> #include<stdio.h> #include<math.h> #include<algorithm> #include<vector> //#include<conio.h> #include<iomanip> #include<ctype.h> #include<time.h>   int main() { 	int cases, nc, n, r, total, max_n, max_total, i, len; 	char arr[10], arr1[5], cn[15], b_car[15]; 	scanf("%d", &cases); 	while(cases--) 	{ 		max_n=0; 		max_total=0; 		scanf("%d", &nc); 		while(nc--) 		{ 			 			scanf("%s", &cn); 			scanf("%s", &arr); 			len=strlen(arr); 			int j=1; 			n=0; 			for(i=len-1; i>=1; i--) 			{ 				int temp=arr[j]-48; 				//cout<<pow(temp,i); 				n=n+(temp*(pow(10,i-1))); 				j++; 			} 			scanf("%s", &arr1); 			len=strlen(arr1); 			if(len==4) 				r=100; 			else 			{ 				r=((int)(arr1[0]-48)*10) + ((int)(arr[1]-48)); 			} 			total=n+((r/100)*n); 			if(total>=max_total) 			{ 				if(n>max_n) 				{ 					max_n=n; 					strcpy(b_car,cn); 					max_total=total; 				} 			} 		} 		printf("%s\n", b_car); 	}  	return 0; }  
	import java.io.BufferedReader; 	import java.io.FileReader; 	import java.io.InputStreamReader; 	import java.util.StringTokenizer; 	import java.util.Arrays; 	    	class TestClass 		{ 		static int INFINITY=1000000; 		int n; 		int[][] adj; 		int[] visited; 		static int w; 	    public static void main(String args[] ) throws Exception { 	        BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 	        new TestClass().solve(br); 	        br.close(); 	  } 	  void solve(BufferedReader br)throws Exception 	  { 	  	int t=Integer.parseInt(br.readLine()); 	  	for(int l=0;l<t;l++) 	  	{  	  		StringTokenizer st=new StringTokenizer(br.readLine()); 	  		n=Integer.parseInt(st.nextToken()); 	  		int k=Integer.parseInt(st.nextToken()); 	  		adj=new int[n+1][n+1];  		 	  		for(int i=0;i<k;i++) 	  		{ 	  			st=new StringTokenizer(br.readLine()); 	  			int x=Integer.parseInt(st.nextToken()); 	  			int y=Integer.parseInt(st.nextToken()); 	  			int cst=Integer.parseInt(st.nextToken()); 	  			adj[x][y]=cst; 	  			adj[y][x]=cst; 	  		}   		int m=Integer.parseInt(br.readLine()); 	  		int ycount=0; 	  		for(int i=0;i<m;i++) 	  		{ 	  			visited=new int[n+1]; 	  			st=new StringTokenizer(br.readLine()); 	  			int s=Integer.parseInt(st.nextToken()); 	  			int d=Integer.parseInt(st.nextToken()); 	  			w=adj[s][d]; 	  			dfs(s); 	  			if(visited[d]!=1) 	  			{ 	  				ycount++; 	  			} 	  			 	  		} 	  		//System.out.println(ycount); 	  		int a=gcd(ycount,m); 	  		 	  		System.out.println((ycount/a)+"/"+(m/a)); 	  		 	  		 	  } 	 } 	 void dfs(int n) 	   { 		 visited[n]=1; 	 	for(int i=0;i<adj[n].length;i++) 	 	{ 	 		if(adj[n][i]!=0&&visited[i]==0&&adj[n][i]<w) 	 		{ 	 			dfs(i);  		} 	 	} 	 } 	 int gcd(int a,int b) 	 { 	 	if(b!=0) 	 	{ 	 		return gcd(b,a%b); 	 	}	 	else 	 	{ 	 		return a; 	 	} 	 } 	} 
#include<bits/stdc++.h> using namespace std; bool c[1000000000]={false}; int main() {     int q,a;     scanf("%d",&q);     long long int n;     for(int i=0;i<q;i++)     {          scanf("%d %lld",&a,&n);          if(a==1)         {              c[n]=true;         }          else if(a==2)         {              if(c[n])                 printf("yes\n");             else                 printf("no\n");         }        }     return 0; } 
#include <iostream> using namespace std;  int main() {     cout<<"Mark Crimson"<<"\n"; } 
#include<iostream> #include<cstdio> #include<iomanip> #include<cmath> #include<vector> #include<map> #include<set> #include<algorithm> #include<list> #include<cstring> #include<stack> #include<queue> #include<sstream> using namespace std; #define ll long long #define vi vector<int> #define vii vector<vi > #define pp pair<int,int> #define pb push_back #define mp make_pair #define ppl pair<ll,ll> #define vl vector<ll> #define vll vector<vl > #define vb vector<bool> #define llu unsigned ll #define all(c) c.begin(),c.end() #define mod 1000000007 #define sc scanf #define pf printf ll power(ll a,ll b) { 	if(!b) 		return 1; 	if(b==1) 		return a; 	ll temp=power(a,b/2); 	temp=(temp*temp); 	if(b&1) 		temp=(temp*a); 	return temp; }   int conn=0;  class graph { 	vi * adj; 	int time; 	public: 		graph( int v) 		{ 			adj = new vi[v]; 			time = 0; 		} 		void add_edge(int u, int v) 		{ 			adj[u].pb( v); 			adj[v].pb( u); 		} 		void dfs(int v,vb& visited) 		{ 			conn++; 			visited[v]=true; 			vi::iterator it; 			for( it=adj[v].begin();it!=adj[v].end();it++ ) 			{ 				if( !visited[*it] ) 				{ 					dfs(*it,visited); 				} 			} 		} 		 }; int main() { 	ios_base::sync_with_stdio(false); 	int i, n, a, b, t; 	ll ans=0; 	char ch; 	t=1; 	while ( t-- ) 	{ 		cin >> n; 		graph g(n); 		vector < pp > v(n-1); 		for( i=0;i<n-1;i++ ) 		{ 			cin >> a >> b; 			a--; 			b--; 			v[i].first=a; 			v[i].second=b; 		} 		vi color(n); 		for( i=0;i<n;i++ ) 		{ 			cin >> ch; 			if(ch=='B') 				color[i]=1; 		} 		for( i=0;i<n-1;i++ ) 		{ 			if((color[v[i].first] ^ color[v[i].second] )) 			{ 				g.add_edge(v[i].first,v[i].second); 			} 			 		} 		vector<bool> visited(n); 		for( i=0;i<n;i++ ) 		{ 			if(!visited[i] ) 			{ 				conn=0; 				g.dfs(i,visited); 				ans =(ans+((ll)(conn)*(ll)(conn+1))/2)%mod; 			} 		} 		cout << ans; 	}     return 0; } 
#include<bits/stdc++.h> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {         int n,sum=0;         cin>>n;         int a[n];         for(int i=0;i<n;i++)             cin>>a[i];         for(int i=1;i<n;i++)         {             if(a[i]>a[i-1])             {                 sum+=a[i]-a[i-1];                 a[i]=a[i-1];             }         }         cout<<sum<<endl;     }     return 0; } 
#include <bits/stdc++.h>  using namespace std;  #define pb push_back #define mp make_pair #define ll long long int #define s(x) scanf("%d", &x) #define sl(x) scanf("%lld", &x) #define mod 1000000007 #define get getchar_unlocked  bool check(string s) {     if (s.size() == 1)         return true;     for (int i = 1; i < s.size(); ++i) {         if ((s[i]-s[i-1]+10)%10 != (s[1]-s[0]+10)%10)             return false;     }     return true; }  string convert(int i) {     string h;     while (i) {         h.pb(i%10+48);         i /= 10;     }     reverse(h.begin(), h.end());     return h; }  int brute(int n) {     int i, ans = 0;     for (i = 1; i <= n; ++i)         ans += check(convert(i));     return ans; }  bool check2(string &s) {     string h;     h.pb(s[0]);     h.pb(s[1]);     int diff = (s[1]-s[0]+10)%10;     for (int i = 2; i < s.size(); ++i) {         h.pb((h[i-1]-48+diff)%10+48);         if (h[i] > s[i])             return false;         else if (s[i] > h[i])             return true;     }     return true; }  int main() {     string s;     cin >> s;     if (s.size() == 1) {         cout << atoi(s.c_str()) << endl;         return 0;     }     int tmp = (s.size()-2)*90+9+(s[0]-49)*10;     tmp += (s[1]-48);     tmp += check2(s);     cout << tmp << endl;     //cout << brute(atoi(s.c_str())) << endl;     return 0; } 
#include <bits/stdc++.h>  #define f(i, a, n) for (ll i = a; i < n; i++) #define fd(i, n, a) for (ll i = n; i >= a; i--) #define rep(i,n) f(i,0,n)  #define mkp make_pair #define pb push_back #define ff first #define ss second #define pll pair <ll, ll> #define pii pair <int, int> #define MOD 1000000007  #define s(x) scanf("%lld", &x); //s(x) is for long long int. #define si(x) scanf("%d", &x);  #define debug true #define ok if(debug) #define trace(x) ok cout << #x << ": " << x << endl; #define trace2(x, y) ok cout << #x << ": " << x << " | " << #y << ": " << y << endl; #define trace3(x, y, z)    ok      cout << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl; #define trace4(a, b, c, d)  ok cout << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " \ 								<< #d << ": " << d << endl; #define trace5(a, b, c, d, e) ok cout << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " \ 									 << #d << ": " << d << " | " << #e << ": " << e << endl; #define trace6(a, b, c, d, e, f) ok cout << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " \ 									<< #d << ": " << d << " | " << #e << ": " << e << " | " << #f << ": " << f << endl;  typedef long long ll; using namespace std; ll a[1005];	 ll power(ll base, ll exp) { 	if (exp == 0) 		return 1LL; 	 	ll x = power(base,(exp/2))%MOD;  	x = (x*x)%MOD;  	if (exp %2) 		x = (x*base) % MOD;  	return x; }  ll gp (ll x, ll t) {  	ll flg = -1;  	if (t % 2) 		flg = -1; 	else 		flg = 1; 	 	ll a = power(x,t); 	ll b  = power(MOD-1, t); 	 	ll c = (a - flg + MOD)%MOD; 	c = (c*x)%MOD; 	 	ll d = power((x+1), MOD-2); 	ll ans = (c * d)%MOD; 	return ans; } int main() { 	#ifndef ONLINE_JUDGE 	freopen("/home/spharish/input.txt", "r", stdin); 	#endif 		 	ios::sync_with_stdio(false); 	ll n; 	cin >> n;  	ll sum = 0; 	rep(i,n) { 		cin>>a[i]; 		sum = (sum + a[i])%MOD; 	}  	ll t,q; 	cin >> t >> q;  	ll ans; 	if (t > 1) 		ans = (sum*gp((n-1), (t-1)))%MOD; 	else 		ans = 0; 	//cout <<ans <<endl; 	int flag; 	if (t%2) 		flag = 1; 	else 		flag = -1; 	while (q--) { 		ll x; 		cin >> x; 		x--; 		if (n == 1) { 			cout<<"0"<<endl; 			continue; 		} 		ll tmp = (ans + (flag*((sum-a[x] + MOD)%MOD) ) + MOD)%MOD; 		cout<<tmp<<endl; 	}  	return 0; }
#include<iostream> using namespace std; #include<vector> #include<stdio.h> int main(){     int n,q,p,i,j,x,y;     vector<int> v(1,0);     scanf("%d%d",&n,&q);     vector<vector<int> > a(101,vector<int> (n+1,0));     for(i=0;i<n;i++){         scanf("%d",&p);         v.push_back(p);     }     for(i=1;i<101;i++){         for(j=1;j<=n;j++){             //int p=v[j-1];             if(i==v[j])                 a[i][j]=a[i][j-1]+1;             else                 a[i][j]=a[i][j-1];         }     }     while(q--){         int c=0;         scanf("%d%d",&x,&y);         for(i=0;i<101;i++){             if(a[i][y]-a[i][x-1]>0){                 c++;             }         }         printf("%d\n",c);     }     return 0; } 
#include <bits/stdc++.h> using namespace std; long long int a[1000005]; int main() { int n; scanf("%d",&n); for(int i=0;i<n;i++) scanf("%lld",&a[i]); int max1=0; int cnt=1; long long int prev=a[0]; long long int maxvalue=0; for(int i=1;i<n;i++) { if(a[i]==prev) cnt++; else { if(prev==maxvalue) max1=max(max1,cnt); else if(prev>maxvalue) { maxvalue=prev; max1=cnt; } cnt=1; prev=a[i]; } } if(prev==maxvalue) max1=max(max1,cnt); else if(prev>maxvalue) { maxvalue=prev; max1=cnt; } cout<<max1; return 0; }
#include <bits/stdc++.h>  using namespace std;  int n;  vector< vector<int> > factors(1000005);  bool isprime[1000005];  void sieve() { 	memset(isprime,1,sizeof(isprime)); 	isprime[0]=isprime[1]=0; 	factors[1].push_back(1); 	for(int i=2;i<n+5;i+=2) factors[i].push_back(2); 	for(int i=3;i<n+5;i+=2) 		if(isprime[i]) 			for(int j=i;j<n+5;j+=i) 			{ 				isprime[j]=0; 				factors[j].push_back(i); 			} }  long long dp[1000005];  int main() { 	ios::sync_with_stdio(false); 	cin>>n; 	sieve(); 	dp[0]=0;dp[1]=1; 	for(int i=2;i<=n;i++) 	{ 		dp[i]=n+5; 		for(int j=0;j<factors[i].size();j++) { 			dp[i]=min(dp[i],1+dp[i-factors[i][j]]); 		} 	} 	cout<<dp[n]<<endl; 	return 0; 	 } 
#include<bits/stdc++.h> #define mod 1000000007 #define ll long long #define big 1000000000000000000 using namespace std;  ll n,q,st[400010],sz; int lazy[400010]; long long pow2[100],a[100010];  ll query(ll in,ll i,ll j,ll l,ll r){ 	if(i>j || j<l || i>r) 		return 0; 	if(lazy[in] != -1){ 		st[in] = (j-i+1)*lazy[in]; 		if(i != j){ 			lazy[2*in+1] = lazy[in]; 			lazy[2*in+2] = lazy[in]; 		} 		lazy[in] = -1; 	} 	if(i>=l && j<=r) 		return st[in]; 	ll mid = (i+j)/2; 	ll temp1 = query(2*in+1,i,mid,l,r); 	ll temp2 = query(2*in+2,mid+1,j,l,r); 	 	return temp1+temp2; } void update(ll in,ll i,ll j,ll l,ll r,bool x){ 	if(lazy[in] != -1){ 		st[in] = (j-i+1)*lazy[in]; 		if(i != j){ 			lazy[2*in+1] = lazy[in]; 			lazy[2*in+2] = lazy[in]; 		} 		lazy[in] = -1; 	} 	if(i>j || j<l || i>r) 		return; 	if(i>=l && j<=r){ 		st[in] = (j-i+1)*x; 		if(i != j){ 			lazy[2*in+1] = x; 			lazy[2*in+2] = x; 		} 		return; 	} 	ll mid = (i+j)/2; 	update(2*in+1,i,mid,l,r,x); 	update(2*in+2,mid+1,j,l,r,x); 	st[in] = st[2*in+1]+st[2*in+2]; } void build(ll in=0,ll i=0,ll j=n-1){ 	if(i>j) 		return; 	lazy[in] = -1; 	if(i == j){ 		if(binary_search(pow2,pow2+sz,a[i])) 			st[in] = 1; 		else 			st[in] = 0; 		return; 	} 	ll mid = (i+j)/2; 	build(2*in+1,i,mid); 	build(2*in+2,mid+1,j); 	st[in] = st[2*in+1]+st[2*in+2]; } int main(){ //	freopen("input.txt","r",stdin); //	ios::sync_with_stdio(0); 	 	ll i,l,r,j; 	int op; 	long long x; 	 	pow2[0] = 1; 	i = 0; 	while((pow2[i]*2)/pow2[i] == 2){ 		i++; 		pow2[i] = pow2[i-1]*2; 	} 	sz = i+1; 	scanf("%lld%lld",&n,&q); 	for(i=0;i<n;i++) 		scanf("%lld",&a[i]); 	build();/* 	for(i=0;i<2*n;i++) 		cout<<st[i]<<" "; 	cout<<"\n";*/ 	 	while(q--){ 		scanf("%d",&op); 		if(op){ 			scanf("%lld%lld",&l,&r); 			printf("%lld\n",query(0,0,n-1,l,r)); 		} 		else{ 			scanf("%lld%lld%lld",&l,&r,&x); 			update(0,0,n-1,l,r,binary_search(pow2,pow2+sz,x)); 		} 	} 	return 0; } 
#include <bits/stdc++.h> using namespace std; double dp[100005]; double fun(int n,double p) { if(n==0) return 0.0; if(n==1) return 2.0; if(n==2) return 2.0; if(dp[n]!=-1.0) return dp[n]; double ans1=0.0; double ans2=0.0; ans1=2.0+p*fun(n-2,p)+(1.0-p)*fun(n-3,p); dp[n]=ans1; return dp[n]; } int main() { int t; int n; double p; scanf("%d",&t); while(t--) { scanf("%d",&n); cin>>p; for(int i=0;i<=n;i++) dp[i]=-1.0; double ans=fun(n,p); printf("%.2f\n",ans); } return 0; }
//evanlimanto  #include <iostream> #include <cstdlib> #include <cstring> #include <sstream> #include <cassert> #include <utility> #include <string> #include <bitset> #include <vector> #include <cstdio> #include <stack> #include <queue> #include <list> #include <set> #include <map> #include <algorithm> #include <cmath> #include <complex>  using namespace std;  typedef unsigned long long        LL; typedef pair<int, int>   pii; typedef pair<int, pii>   piii; typedef vector<int>      vi; typedef vector<pii>      vii;  //Fast Input  inline void inpint( int &n ) {   n=0; register int ch = getchar_unlocked(); int sign = 1;   while(ch < '0' || ch > '9') { if(ch == '-') sign=-1; ch = getchar_unlocked(); }   while(ch >= '0' && ch <= '9') { n = (n << 3) + (n << 1) + ch - '0', ch = getchar_unlocked(); }   n = n * sign; } //End Fast Input  inline string itostr(int a){     char x[100];     sprintf(x,"%d",a); string s = x;     return s; }  inline int strtoi(string a){     char x[100]; int res;     strcpy(x,a.c_str()); sscanf(x,"%d",&res);     return res; }  inline int sqr(int x){return x * x;} inline int cube(int x){return x * x * x;}  const LL LLINF      = 9223372036854775807LL; const LL LLINF17    = 100000000000000000LL; const int INF       = 2147483647; const int INF9      = 1e9; const int MOD       = 1000000007; const double eps    = 1e-7; const double PI     = acos(-1.0);  #define FORIT(a,b)   for (__typeof((b).begin()) (a)=(b).begin(); (a)!=(b).end(); (a)++) #define FOR(a,b,c)   for (int (a)=(b); (a)<(c); (a)++) #define FORN(a,b,c)  for (int (a)=(b); (a)<=(c); (a)++) #define FORD(a,b,c)  for (int (a)=(b); (a)>=(c); (a)--) #define REP(i,n)     FOR(i,0,n) #define REPN(i,n)    FORN(i,1,n) #define REPD(i,n)    FORD(i,n,1)  #define RESET(a,b)   memset(a,b,sizeof(a))  #define SYNC         ios_base::sync_with_stdio(0); #define SIZE(a)      (int)(a.size()) #define MIN(a,b)     (a) = min((a),(b)) #define MAX(a,b)     (a) = max((a),(b)) #define input(in)    freopen(in,"r",stdin) #define output(out)  freopen(out,"w",stdout) #define ALL(a)       a.begin(),a.end() #define RALL(a)      a.rbegin(),a.rend() #define SIZE(a)      (int)(a.size()) #define LEN(a)       (int)(a.length())  #define FIN(x)       freopen(x,"r",stdin) #define FOUT(x)      freopen(x,"w",stdout) #define FCLOSE       {fclose(stdin); fclose(stdout);}  #define fi           first #define se           second #define pb           push_back #define mp           make_pair  int dr[] = {1,0,-1,0,-1,1,1,-1}; int dc[] = {0,-1,0,1,1,1,-1,-1}; int t; LL x; int main(){ 	scanf("%d",&t); 	while(t--){ 		scanf("%lld",&x); 		LL l = 1, r = 1000000000LL, mid; 		while(l <= r){ 			mid = (l + r) / 2; 			LL val = (mid + 5) * (mid - 1); 			//printf("%lld %lld\n",mid,val); 			if(val > x) r = mid - 1; 			else l = mid + 1; 		} 		 		//while((mid + 5) * (mid - 1) > x) mid--; 		if(l == 2) puts("-1"); 		else printf("%lld\n",l-1); 	}  	return 0; }
/* The code has been taken from : http://comeoncodeon.wordpress.com/category/algorithm/ */ #include<iostream> #include <bits/stdc++.h> using namespace std; #include<vector>   /* This function calculates (a^b)%MOD */ long long pow(int a, int b, int MOD) {     long long x=1,y=a;      while(b > 0)     {         if(b%2 == 1)         {             x=(x*y);             if(x>MOD) x%=MOD;         }         y = (y*y);         if(y>MOD) y%=MOD;          b /= 2;     }     return x; }   /*  Modular Multiplicative Inverse     Using Euler's Theorem     a^(phi(m)) = 1 (mod m)     a^(-1) = a^(m-2) (mod m) */ long long InverseEuler(int n, int MOD) {     return pow(n,MOD-2,MOD); }   long long C(int n, int r, int MOD) {     vector<long long> f(n + 1,1);     for (int i=2; i<=n;i++)         f[i]= (f[i-1]*i) % MOD;     return (f[n]*((InverseEuler(f[r], MOD) * InverseEuler(f[n-r], MOD)) % MOD)) % MOD; }   int main() {         int n,p=1000000007,t;     scanf("%d",&t);     while(t--)     {     	scanf("%d",&n);         printf("%lld\n",(C(2*n,n,p)*InverseEuler(n+1,p))%p);     } }
#include <iostream> #include<bits/stdc++.h> using namespace std; int arr[1000005]; int main() {     int n,i,j,c,t,d;     int ans,mx;     scanf("%d",&t);     while(t--)     {         memset(arr,0,sizeof(arr));         mx=0;         scanf("%d",&n);         for(i=0;i<n;i++)         {           scanf("%d",&d);           if(mx<d)           {               mx=d;           }           arr[d]++;         }         int f=1;         for(i=mx;i>0;i--)         {             c=0;             j=i;             while(j<=mx)             {                 c=c+arr[j];                 j+=i;                 if(c>1)                 {                     ans=i;                     f=0;                     break;                 }             }                 if(f==0)                 break;         }         printf("%d\n",ans);      }     return 0; } 
#include<iostream> #include<algorithm> #include<stdio.h> #define GETCHAR getchar_unlocked inline int readInt() { int flag=1; int n = 0; char c; while (1) { c=GETCHAR(); if(c>='0'&&c<='9') {n = n * 10 + c - '0';flag=0;} else if(flag!=1) break; } return n; } using namespace std; int main(){ 	int t; 	t=readInt(); 	while(t--){ 		int n; 		n=readInt(); 		int arr[n]; 		for(int i=0;i<n;i++){ 			arr[i]=readInt(); 		} 		int sumarray[n]; 		sort(arr,arr+n); 		for(int i=0;i<n;i++) 		sumarray[i]=arr[i]; 		 		 		for(int i=1;i<n;i++){ 			 			sumarray[i]+=sumarray[i-1]; 			//cout<<sumarray[i]<<" "; 		} 		 		long long int queries; 		queries=readInt(); 		for(int i=0;i<queries;i++){ 			int req; 			req=readInt(); 			//cout<<"hi"; 			//BINARY SEARCH 			int low=0; 			int high=n-1; 			while(low<high){ 				int mid=(low+high)/2; 				if(sumarray[mid]<req) 				low=mid+1; 				else 				high=mid-1; 			} 			//cout<<low; 			if(sumarray[low]>=req) 			low--; 			printf("%d ",low+1); 		} 		cout<<"\n"; 	} }
#include<iostream> #include<algorithm> #include<stdio.h> #include<vector> #include<cstring> using namespace std; int arr1[100010]; int arr2[100010]; int ans[1000010]; int main(){ 	int t; 	scanf("%d",&t); 	//string tt; 	//getline(cin,tt); 	while(t--){ 		//string a,b; 	    char a[100010]; 	    char b[100010]; 	    scanf("%s %s",a,b); 		//getline(cin,a,' '); 	    //getline(cin,b); 		for(int i=0;i<100010;i++){ 			arr1[i]=0; 			arr2[i]=0; 			ans[i]=0; 		} 		int len1=strlen(a); 		int len2=strlen(b); 		for (int j=len1-1,i=0;j>=0;j--,i++) 			arr1[i]=a[j]-'A'; 			 		for (int j=len2-1,i=0;j>=0;j--,i++) 			arr2[i]=b[j]-'A'; 			 		 		//for(int i=0;i<=a.length()-1;i++) 		//cout<<arr1[i]<<" "; 		//for(int i=0;i<=b.length()-1;i++) 		//cout<<arr2[i]<<" "; 		int takecarry=0; 		int limit=max(len1,len2); 		//cout<<limit<<"\n"; 		for(int i=0;i<=limit;i++){ 			ans[i]=arr1[i]+arr2[i]+takecarry; 			takecarry=ans[i]/26;   			ans[i]%=26; 		} 		//cout<<limit; 		//for(int i=0;i<=limit;i++) 		//cout<<ans[i]<<" "; 		for (int i=limit;i>=0;i--)  		{ 			if (i==limit && ans[i]==0){ 			} 			//continue; 			else 			printf("%c",'A'+ans[i]); 		} 		printf("\n"); 	} }
#include<iostream> #include<stdio.h> #include<string.h> using namespace std;  int check(char str[],int len) { int i,j,k,flag=0;            char temp[10];            for(i=0;i<len;i++)            {                              if(str[i]=='2' || str[i]=='3' || str[i]=='4' || str[i]=='7' || str[i]=='5' )                              {                                       flag=1;                                       return 0;                                       break;                                                                                          }                              }                              if(flag==0)                              { cout<<"YES\n";                                         for(i=len-1;i>=0;i--)                                         {                                                           if(str[i]=='6')                                                           cout<<'9';                                                                                                                      else if(str[i]=='9')                                                           cout<<'6';                                                           else                                                            cout<<str[i];                                         }                                         cout<<"\n";                                         }            return(1);            }   int main() {     int t,len,i,j,k;     char str[100];     cin>>t;     while(t--)     {               scanf("%s",str);              len=strlen(str);               int p=check(str,len);               if(p==0)               cout<<"NO\n";               }      return 0; }
#include<iostream> #include<cstdio> #include<cstdlib> #include<vector> #include<list> #include<map> #include<set> #include<deque> #include<queue> #include<stack> #include<bitset> #include<algorithm> #include<functional> #include<numeric> #include<utility> #include<sstream> #include<iomanip> #include<cmath> #include<cctype> #include<cstring> #include<string> #include<ctime> #include<cassert> using namespace std; //#include<conio.h>  #define TRACE(x) cerr << "TRACE(" #x ")" << endl; #define DEBUG(x) cerr << #x << " = " << x << endl; #define FOR(i,a,b) for(int i=(a);i< (b);i++) #define input(a) scanf("%d",&a) #define CLEAR(a) memset((a),0,sizeof(a)) #define INF 1000000000 #define LL long long #define PI 2*acos(0.0) #define sqr(a) (a)*(a) #define MAX 1000010  LL s[MAX],f[MAX]; int n; inline void party() {     LL count=0;     LL ans=-1;     int i,j;     i=j=0;     while(i<n||j<n)     {        if(s[i]<f[j])        {           count++;           i++;             ans=max(ans,count);                }              else        {            count--;            j++;        }              if(i>=n||j>=n)          break;      }         cout<<ans<<endl; } int main() {     int tc;     input(tc);     while(tc--)     {        input(n);        FOR(i,0,n)         scanf("%lld %lld",&s[i],&f[i]);        sort(s,s+n);        sort(f,f+n);        party();             }     //getch();     return 0; } 
#include<iostream> #include<cstdio> #include<cstdlib> #include<vector> #include<list> #include<map> #include<set> #include<deque> #include<queue> #include<stack> #include<bitset> #include<algorithm> #include<functional> #include<numeric> #include<utility> #include<sstream> #include<iomanip> #include<cmath> #include<cctype> #include<cstring> #include<string> #include<ctime> #include<cassert> using namespace std;   #define TRACE(x) cerr << "TRACE(" #x ")" << endl; #define DEBUG(x) cerr << #x << " = " << x << endl; #define FOR(i,a,b) for(int i=(a);i< (b);i++) #define input(a) scanf("%d",&a) #define CLEAR(a) memset((a),0,sizeof(a)) #define INF 1000000000 #define LL long long #define PI 2*acos(0.0) #define sqr(a) (a)*(a) int dp[55][55];   int main() {   int n,q;   input(n);   input(q);   int a,b,c;   for(int i=0;i<n;i++)    for(int j=0;j<n;j++)    {      if(i !=j)        dp[i][j]=INF;    }   while(scanf("%d%d%d",&a,&b,&c)==3)   {      if(a==-1)       break;      dp[a][b]=c;                                  }    for(int k=0;k<n;k++)     for(int i=0;i<n;i++)      for(int j=0;j<n;j++)       dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);           for(int i=0;i<n;i++)     for(int j=0;j<n;j++)      if(dp[i][j]!=INF && dp[j][i]!=INF)        dp[i][j]=dp[j][i]=0;    for(int k=0;k<n;k++)     for(int i=0;i<n;i++)      for(int j=0;j<n;j++)       dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);    int s,d;    while(q--)    {      input(s);      input(d);      if(dp[s][d]==INF)       printf("Unreachable\n");      else       cout<<dp[s][d]<<endl;            }        return 0; } 
#include<iostream> #include<cstring> #include<cstdio> using namespace std; char str[1001][1001]; bool mat[1001][1001]; int n,m; bool func(int a,int b) {      //cout<<a<<" "<<b<<"\n";     if(str[a][b]=='f')     return true;     if(a<n && (str[a+1][b]=='b' ||str[a+1][b]=='f' ) && mat[a+1][b]==false)     {mat[a][b]=true;bool x=func(a+1,b);if(x){str[a][b]='-';return true;}}     if(a>0 && (str[a-1][b]=='b' || str[a-1][b]=='f')&& mat[a-1][b]==false)     {mat[a][b]=true;bool x=func(a-1,b);if(x){str[a][b]='-';return true;}}     if(b<m && (str[a][b+1]=='b' || str[a][b+1]=='f')&& mat[a][b+1]==false)     {mat[a][b]=true;bool x=func(a,b+1);if(x){str[a][b]='-';return true;}}     if(b>0 && (str[a][b-1]=='b' || str[a][b-1]=='f')&& mat[a][b-1]==false)     {mat[a][b]=true;bool x=func(a,b-1);if(x){str[a][b]='-';return true;}}     return false; } main() {       int t,a,b;         scanf("%d",&t);       for(int i=0;i<t;i++)       {               scanf("%d %d",&n,&m);               for(int j=0;j<n;j++)               for(int k=0;k<m;k++)               mat[j][k]=false;               for(int j=0;j<n;j++)               scanf("%s",&str[j]);               for(int j=0;j<n;j++)               for(int k=0;k<m;k++)               if(str[j][k]=='s')               {a=j;b=k;break;} if(func(a,b)) {               for(int j=0;j<n;j++)               for(int k=0;k<m;k++)               {if(str[j][k]=='-')                str[j][k]='b';                else if(str[j][k]=='w' || str[j][k]=='b')                str[j][k]='-';}                str[a][b]='s';                for(int j=0;j<n;j++)               printf("%s\n",str[j]);                               } else printf("The path doesn't exist.\n");   }                  // system("pause");       }  
#include<stdio.h> //#include<conio.h> #include<string.h> char c[10000002],d[10000002],b[10000002]; int main() {     long long int a[27],r,k,t,i,g;     scanf("%lld",&t);     while(t--)     {               scanf("%s",b);               r=k=0;               for(i=0;i<27;i++)               a[i]=0;               g=strlen(b);               for(i=0;i<g;i++)               {                                       a[b[i]-'A']++;                                       if(a[b[i]-'A']%2!=0)                                       c[k++]=b[i];                                       else                                       d[r++]=b[i];               }               c[k]=d[r]='\0';               if((strcmp(c,d)==0)&&(k+r==g))               printf("%s\n",c);               else               printf("Twins don't exist\n");     }    // getch();     return 0; }     
#include<iostream> #include<cstdio> #include<cstdlib> #include<vector> #include<list> #include<map> #include<set> #include<deque> #include<queue> #include<stack> #include<bitset> #include<algorithm> #include<functional> #include<numeric> #include<utility> #include<sstream> #include<iomanip> #include<cmath> #include<cctype> #include<cstring> #include<string> #include<ctime> #include<cassert> using namespace std; //#include<conio.h>  #define TRACE(x) cerr << "TRACE(" #x ")" << endl; #define DEBUG(x) cerr << #x << " = " << x << endl; #define FOR(i,a,b) for(int i=(a);i< (b);i++) #define input(a) scanf("%d",&a) #define CLEAR(a) memset((a),0,sizeof(a)) #define INF 1000000000 #define LL long long #define PI 2*acos(0.0) #define sqr(a) (a)*(a) #define MAX 10100 char str[MAX]; struct node {    bool data;    node *next[128];    node()    {      memset(this,0,sizeof(node));       } }*start,*p; inline void insert(char *s) {    p=start;    for(;*s && *s!=' ';s++)    {      if(!p->next[*s])        p->next[*s]=new node();      p=p->next[*s];    }     p->data=true;   } inline bool check(char *s) {    p=start;    for(;*s && *s!=' ';s++)    {      if(!p->next[*s])        return false;      p=p->next[*s];                   }        return p->data; } int main() {    start=new node();    gets(str);    int j,i;    j=0;    for(i=0;str[i];i++)    {      if(str[i]==' ')      {        insert(str+j);        j=i+1;                  }      else        str[i]=toupper(str[i]);          }     insert(str+j);    while(gets(str))    {      j=0;      for(i=0;str[i];i++)      {        if(str[i]==' ')        {           if(!check(str+j))             break;           j=i+1;                   }              else          str[i]=toupper(str[i]);      }                   if(str[i]||!check(str+j))        puts("No");      else        puts("Yes");    }    //getch();    return 0; } 
#include <string> #include <vector> #include <stack> #include <queue> #include <deque> #include <cstdlib> #include <cstdio> #include <cmath> #include <algorithm> #include <ctime> #include <list> #include <map> #include <set> #include <bitset> #include <functional> #include <utility> #include <iostream> #include <iomanip> #include <fstream> #include <sstream> #include <string.h>   using namespace std;   typedef long long ll; typedef unsigned long long ull; #define two(X) (1<<(X)) #define twoL(X) (((int64)(1))<<(X)) #define contain(S,X) ((S&two(X))>0) #define containL(S,X) ((S&twoL(X))>0) #define debug(args...) dbg(),args struct ipair { int first; int second; ipair(int x, int y) { first = x; second = y; }}; int countbit(int n) {return (n==0)?0:(1+countbit(n&(n-1)));} int lowbit(int n) {return (n^(n-1))&n;} const double pi=acos(-1.0); const double eps=1e-11; template<class T> T sqr(T x) {return x*x;} template<class T> void checkmin(T &a,T b) {if (b<a) a=b;} template<class T> void checkmax(T &a,T b) {if (b>a) a=b;} #define S(N) scanf("%d", &N) #define SC(N) scanf("%c", &N) #define SL(N) scanf("%lld", &N) #define SF(N) scanf("%lf", &N)  #define SS(N) scanf("%s", N)  #define SIZE(X) ((int)((X).size())) #define LENGTH(X) ((int)((X).length())) #define MP(A,B) *new ipair(A,B) #define FOR(A,B,C) for(int A=B;A<C;A++) #define EFOR(A,B,C) for(int A=B;A<=C;A++) #define RFOR(A,B,C) for(int A=B;A>=C;A--) #define FORL(A,B,C) for(ll A=B;A<C;A++) #define EFORL(A,B,C) for(ll A=B;A<=C;A++) #define RFORL(A,B,C) for(ll A=B;A>=C;A--) #define PB(A,B) A.push_back_back(B); #define SORT(A) sort( A.begin(),A.end() ) #define ALL(A) A.begin(),A.end() #define MEM(A,B) memset(A,B,sizeof(A)) #define SZ(A) int(A.size()) #define MAX(A,B) (A > B) ? A : B #define MIN(A,B) (A < B) ? A : B #define DBGCHECK if (argc > 1) DBG = ((*argv[1] == '0') ? 0 : 1) #define PRN(A, N) if (DBG) { FOR(j, 0, N) cout << setw(2) << A[j] << " " ; cout << endl; } #define PR2N(A, M, N) FOR(i, 0, M) { PRN(A[i], N) } #define PR(A) PRN(A, sizeof(A)/sizeof(A[0])) #define PR2(A) FOR(i, 0, sizeof(A)/sizeof(A[0])) { PR(A[i]) } #define LIM 100 #define MAXLEN 10002 #define INF  99 bool DBG; struct dbg { template<typename T> dbg& operator , (const T& v) { if (DBG) cerr << v << " "; return *this; } ~dbg() { if (DBG) cerr << endl; } };  map<string,int> m; string a[10] = {"0000","0001","0010","0011","0100","0101","0110","0111","1000","1001"}; int code[4]; string s1,s2,s3,s4;  int main (int argc, char *argv[])  { 	DBGCHECK; 	m["black"] = 0; 	m["brown"] = 1; 	m["red"] = 2; 	m["orange"] = 3; 	m["yellow"] = 4; 	m["green"] = 5; 	m["blue"] = 6; 	m["violet"] = 7; 	m["grey"] = 8; 	m["white"] = 9; 	cin >> s1 >> s2 >> s3 >> s4; 	int n1,n2,n3,n4,len=0; 	ll ans = 0; 	code[0] = m[s1];code[1] = m[s2];code[2] = m[s3];code[3] = m[s4]; 	string s; 	RFOR(i,3,0){ 		s = a[code[i]]; 		RFOR(j,s.length()-1,0) 			ans += (s[j] - '0')*(ll)pow(2.0,len++);  	} 	ans *= (ll)pow(10.0,code[3]); 	printf("%lld Guntur",ans); } 
#include <stdio.h> #include <limits.h>   int main() { int a, b, c, d, e, m=INT_MAX; int r[25]; int *p=r-1, *q=r+26; scanf("%d %d %d %d %d",&a,&b,&c,&d,&e);  r[0]=a+b-c*d/e; r[1]=a+b-c/d*e; r[2]=a+b*c-d/e; r[3]=a+b*c/d-e; r[4]=a+b/c-d*e; r[5]=a+b/c*d-e; r[6]=a-b+c*d/e; r[7]=a-b+c/d*e; r[8]=a-b/c+d*e; r[9]=a-b/c*d+e; r[10]=a-b*c+d/e; r[11]=a-b*c/d+e; r[12]=a*b+c-d/e; r[13]=a*b+c/d-e; r[14]=a*b-c/d+e; r[15]=a*b-c+d/e; r[16]=a*b/c+d-e; r[17]=a*b/c-d+e; r[18]=a/b+c-d*e; r[19]=a/b+c*d-e; r[20]=a/b-c+d*e; r[21]=a/b-c*d+e; r[22]=a/b*c+d-e; r[23]=a/b*c-d+e;  for(; ++p<q; m=m>*p&&*p>0?*p:m); printf("%d\n",m);  return 0; }
#include<iostream> #include<string.h>  using namespace std; int cnt[257]; char str[1001]; char str1[1001]; int main() {     int l,l1,i;     scanf("%s",&str);l=strlen(str);     for(i=0;i<l;i++)     {                     cnt[str[i]-97]++; }                     scanf("%s",&str1);l1=strlen(str1);                     for(i=0;i<l1;i++)                                     cnt[str1[i]-97]=0;                                     for(i=0;i<26;i++)                                     {                                                      if(cnt[i]>0)                                                      printf("%c%d",(i+97),cnt[i]);                                                      }                                                     printf("\n");                                                    }
#include <cstdio> #include <iostream> #include <algorithm> #include <cmath> #include <cstring> #include <cassert> using namespace std; #define p(x) cout<<#x<<":"<<x<<"\n"  int x,y,i; char o; double s; char str[100];  int main() {   scanf("%d%c%d",&x,&o,&y);   assert(x>1);   assert(max(x,y)<=100000000);   if(o=='!')   {     assert(y==0);     for(i=2;i<=x;i++)       s+=log10(i);	 	s++;   }   else if(o=='*')   {     assert(y>0);     sprintf(str,"%lld",(long long)x*y);     s=strlen(str);   }   else if(o=='/')   {     assert(y>0); 	if(x/y==0) 	  s=0; 	else 	{ 	  sprintf(str,"%d",x/y);       s=strlen(str); 	}   }   else    {     assert(y>=0); 	s=y*log10(x)+1;   }   printf("%d\n",(int)(s+1e-8));   return 0; }
/* Success is a matter of hanging on, when others have let go. Its not who you are, that holds you back, its who you think you are not. The future belongs to those, who believe in the beauty of their dreams. */ //{ /* theCodeGame */ #include<iostream> #include<cmath> #include<algorithm> #include<climits> #include<vector> #include<queue> #include<bitset> #include<cstdlib> #include<cstdio> #include<cstring> #include<ctime> #include<map> using namespace std; #define MOD 1000000007LL #define LL long long #define ULL unsigned long long #define LD long double #define MAX(a,b) ((a)>(b)?(a):(b)) #define MIN(a,b) ((a)<(b)?(a):(b)) #define ABS(x)   ((x)<0?-(x):(x)) #define SQR(x) ((x)*(x)) #define CUBE(x) ((x)*(x)*(x)) #define si(n) scanf("%d",&n) #define si2(n,m) scanf("%d %d",&n,&m) #define sf(n) scanf("%f",&n) #define sl(n) scanf("%ld",&n) #define sll(n) scanf("%lld",&n) #define slu(n) scanf("%llu",&n) #define sd(n) scanf("%lf",&n) #define ss(n) scanf("%s",n) #define pnl printf("\n") #define REP(i,n) for(int i=0;i<(n);i++) #define FOR(i,a,b) for(int i=(a);i<(b);i++) #define FORR(i,n,e) for(int i=(n);i>=(e);i--) #define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d)) #define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d)) //#undef mydebug #ifdef mydebug #define DB(x) cout<<#x<<"="<<(x)<<"\n" #define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n" #define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n" #define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n" #define pnld pnl; #else #define DB(x) #define DB2(x,y) #define DB3(x,y,z) #define DB4(x,y,z,a) #define pnld #endif #define FILL(a,b) memset(a,b,sizeof(a)) const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; //template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;} void DBG_ARR(const int A[],int S,int N){cout<<"[";FOR(i,S,N){cout<<A[i]<<" ";}cout<<"]\n";} void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;} ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} //} #define size 53 LL dp[size][size]; void precompute(){     FOR(i,0,size){         FOR(j,0,size){             if(!i||!j){                 dp[i][j]=1;             }else{                 dp[i][j]=dp[i-1][j]+dp[i][j-1];             }             //cout<<dp[i][j]<<" ";         }        // pnld;     }  } void doThis(){     int N,M;     si2(N,M);     printf("%lld\n",dp[N][M]); }  int main(){ #ifdef amy freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr); #endif precompute(); int t=1; //scanf("%d",&t); while(t--){doThis();} #ifdef amy fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC)); #endif return 0; } 
#include <cstdio> #include <cstring> #include <string> using namespace std;  int dp[501][1001]; string sol[501][1001]; int vals[26];  char seq[1005]; int N, L;  int numIngredientes;  int main() {     for(int i=0; i<501; i++) dp[i][0]=0;     for(int j=0; j<1001; j++) dp[0][j]=0;          int T;     scanf("%d",&T);          for(int tt=0; tt<T; tt++)      {         scanf("%d",&numIngredientes);         for(int i=0;i<numIngredientes;i++)             scanf("%d",&vals[i]);                  scanf("%s",seq+1);         L=strlen(seq+1);                  for(int i=1; i<=L; i++)             seq[i]-='a';                      scanf("%d",&N);                           for(int i=1; i<=N; i++) {             for(int j=1; j<=L;j++) {                 dp[i][j]=0;                 if(vals[seq[j]]<=i) {                     int op1 = dp[i][j-1];                     int op2 = dp[i-vals[seq[j]]][j-1]+vals[seq[j]];                     if(op1 > op2) {                         dp[i][j]=op1;                         sol[i][j]=sol[i][j-1];                     }                     else if(op2 > op1) {                         dp[i][j]=op2;                         sol[i][j]=sol[i-vals[seq[j]]][j-1] + char(seq[j]+'a');                     }                     else {                         dp[i][j]=op1;                         sol[i][j] = min(sol[i][j-1], sol[i-vals[seq[j]]][j-1] + char(seq[j]+'a'));                     }                 }                 else {                     dp[i][j] = dp[i][j-1];                     sol[i][j]=sol[i][j-1];                 }             }         }         if(dp[N][L]<N) {             printf("IMPOSSIBLE\n");         }          else {             printf("%s\n",sol[N][L].c_str());         }     }  } 
#include<iostream> #include<cmath> #include<algorithm> #define ll unsigned long int using namespace std;   ll L (ll n);   int main() { 	ll p,s,t,q; 	cin>>t; 	for(ll i=0; i<t; i++)     {         cin>>p;         s=p*4;         q=L(s);         if(q==p)             cout<<s<<endl;         else         {             while(q!=p)             {                 s++;                 q=L(s);                 if(q==p)                     cout<<s<<endl;             }         }     }     return 0; }   ll L (ll n) {     float divf=n/5; int p=divf;   while((int)(divf)) {     divf=divf/5;     p=p+divf; }   return p; } 
#include <iostream>   using namespace std;   int main() {     int t;     cin>>t;     while(t)     {     char *copie;     char input[30];     int no;     cin>>input;     for(int i=1;input[i]!='\0';i++)     {         no=i+2;     }     copie=new char[no];     for(int i=0;i<=no;i++)     {         copie[i]=input[i];     }       for(int j=1;j<no;j++)     {           input[j-1]=copie[no-j-1];         input[j]='\0';       }     for(int k=0;k<no-1;k++)     {         input[k]=(char)((((int)input[k]-97)+2)%26+97);     }     cout<<input<<endl;     t--;     }     return 0; } 
#include<iostream> #include<stdio.h> using namespace std; int main() { 	int t,n; 	cin>>n; 	for(int t=0;t<=n;t++) 	{ 		char c[100]; 		gets(c); 	int count,j,z=0; 	char e[100]; 		for(int i=0;c[i]!='\0';i++) 		   { 			 				if(c[i]=='0') 				{ 					e[z]=char(32); 					z++; 				} 				else if(c[i]=='2') 				{ 			     	count=0; 					j=0; 					while(c[i+j]=='2'&&j<3) 					{ 						if(c[i+j]=='#') 						break; 						if(c[i+j]=='2') 						count++; 						j++; 					} 					if(count==1) 					{e[z]='A'; z++;} 					else if(count==2) 					{e[z]='B'; z++;i=i+1;continue;} 					else if(count==3) 					{e[z]='C'; z++;i=i+2;continue;} 					 			    } 				else if(c[i]=='3') 					{ 					count=0; 					j=0; 					while(c[i+j]=='3'&&j<3) 					{ 						if(c[i+j]=='#') 						break; 						if(c[i+j]=='3') 						count++; 						j++; 					}  					if(count==1) 					{e[z]='D'; z++;} 					else if(count==2) 					{e[z]='E'; z++;i=i+1;continue;} 					else if(count==3) 					{e[z]='F'; z++;i=i+2;continue;} 				    } 				else if(c[i]=='4') 				{ 					count=0; 					j=0; 					while(c[i+j]=='4'&&j<3) 					{ 						if(c[i+j]=='#') 						break; 						if(c[i+j]=='4') 						count++; 						j++; 					} 					if(count==1) 					{e[z]='G'; z++;} 					else if(count==2) 					{e[z]='H'; z++;i=i+1;continue;} 					else if(count==3) 					{e[z]='I'; z++;i=i+2;continue;} 			    } 				else if(c[i]=='5') 				{ 					count=0; 					j=0; 					while(c[i+j]=='5'&&j<3) 					{ 						if(c[i+j]=='#') 						break; 						if(c[i+j]=='5') 						count++; 						j++; 					} 					if(count==1) 					{e[z]='J'; z++;} 					else if(count==2) 					{e[z]='K'; z++;i=i+1;continue;} 					else if(count==3) 					{e[z]='L'; z++;i=i+2;continue;} 			    } 				else if(c[i]=='6') 				{ 					count=0; 					j=0; 					while(c[i+j]=='6'&&j<3) 					{ 						if(c[i+j]=='#') 						break; 						if(c[i+j]=='6') 						count++; 						j++; 					} 					if(count==1) 					{e[z]='M'; z++;} 					else if(count==2) 					{e[z]='N'; z++;i=i+1;continue;} 					else if(count==3) 					{e[z]='O'; z++;i=i+2;continue;} 			    } 				else if(c[i]=='7') 				{ 					count=0; 					j=0; 					while(c[i+j]=='7'&&j<4) 					{ 						if(c[i+j]=='#') 						break; 						if(c[i+j]=='7') 						count++; 						j++; 					} 					if(count==1) 					{e[z]='P'; z++;} 					else if(count==2) 					{e[z]='Q'; z++;i=i+1;continue;} 					else if(count==3) 					{e[z]='R'; z++;i=i+2;continue;} 					else 					{e[z]='S'; z++;i=i+3;continue;} 				} 				else if(c[i]=='8') 				{ 					count=0; 					j=0; 					while(c[i+j]=='8'&&j<3) 					{ 					if(c[i+j]=='#') 						break; 						if(c[i+j]=='8') 						count++; 						j++; 					} 					if(count==1) 					{e[z]='T'; z++;} 					else if(count==2) 					{e[z]='U'; z++;i=i+1;continue;} 					else if(count==3) 					{e[z]='V'; z++;i=i+2;continue;} 				} 				else if(c[i]=='9') 				{ 					count=0; 					j=0; 					while(c[i+j]=='9'&&j<4) 					{ 						if(c[i+j]=='#') 						break; 						if(c[i+j]=='9') 						count++; 						j++; 					} 					if(count==1) 					{e[z]='W'; z++;} 					else if(count==2) 					{e[z]='X'; z++;i=i+1;continue;} 					else if(count==3) 					{e[z]='Y'; z++;i=i+2;continue;} 					else 					{e[z]='Z'; z++;i=i+3;continue;} 				} 				else  				e[z]==char(32); 			} 		for(int k=0;k<z;k++) 		cout<<e[k]; 		cout<<endl; 	} 	return 0; } 
//Author : Sharath Chandran //Handle : sharad07   #include<bits/stdc++.h> #define lld long long int #define llu unsigned long long int #define pb(x) push_back(x) #define sz size() #define inp1(x) scanf("%d",&x) #define inp2(x,y) scanf("%d%d",&x,&y) #define inp3(x,y,z) scanf("%d%d%d",&x,&y,&z) #define print(x) printf("%d",x) #define println(x) printf("%d\n",x) #define _for(i,x,y) for(int i=x;i<y;i++) #define pii pair<int,int> #define mp(x,y) make_pair(x,y) #define pq priority_queue<int>  using namespace std; const int maxx=5e3+5; lld mod=1e9+7;   int N,M,a,b,vertex; bool vis[maxx]; stack<int> not_vis;   struct graph {     vector<int> neigh;     void add_edge(int node)     {         neigh.pb(node);     }     void clr()     {         neigh.clear();     } };   int dfs(int node,vector<graph> &G) { 	int count=1; 	vis[node]=1; 	_for(j,0,G[node].neigh.sz)     {         if(!vis[G[node].neigh[j]])         {             count+=dfs(G[node].neigh[j],G);         }     } 	return count; }   inline void Reset(vector<graph> &G) {     _for(i,1,N+1)      {         G[i].clr();         vis[i]=0;     } }   int main() {     int K,minn=1e9;     cin>>N>>M>>K;     vector<graph> G(N+1);     _for(i,0,M)     {         cin>>a>>b;         G[a].add_edge(b);     }          _for(i,1,N+1)      {         memset(vis,0,sizeof(vis));         minn=min(minn,dfs(i,G));     }     cout<<minn*K<<endl;     return 0; } 
#include<iostream> using namespace std;  struct co { 	int x,y; };  int main() { 	int t; 	cin>>t; 	while(t--) 	{ 	    co r1[2],r2[2];	 		cin>>r1[0].x>>r1[0].y>>r1[1].x>>r1[1].y; 		cin>>r2[0].x>>r2[0].y>>r2[1].x>>r2[1].y; 		 		long long area=0; 		area+=(r1[1].x-r1[0].x)*(r1[1].y-r1[0].y); 		area+=(r2[1].x-r2[0].x)*(r2[1].y-r2[0].y); 		 		int x1,y1,x2,y2; 		 		x2=min(r1[1].x,r2[1].x); 		x1=max(r1[0].x,r2[0].x); 		if(x2<=x1) 		{ 			cout<<area<<endl; 		} 		else 		{ 		y2=min(r1[1].y,r2[1].y); 		y1=max(r1[0].y,r2[0].y);	 		if(y2<=y1) 		cout<<area<<endl; 		else 		{ 			area-=(y2-y1)*(x2-x1); 			cout<<area<<endl; 		} 			 		} 		 	}  }
// Author: thecodekaiser #include <bits/stdc++.h>   using namespace std; typedef long long ll; typedef pair<int, int> PII; typedef vector<int, int> vi; typedef vector<vi> vii; #define pb push_back   struct interval { 	int start, end; };   bool compare_interval(interval A, interval B) { 	return (A.start < B.start) ? true:false; }   // This is where I am gonna store merged intervals vector<interval> ARR;   // Procedure : To merge intervals..Learned this from one of my seniors : Aditya Boss(aditya_1234) void mergeIntervals(vector<interval> & vct) {     // Test if the given set has at least one interval     if (vct.size() <= 0)         return;       // Create an empty stack of intervals     stack<interval> s;       // sort the intervals based on start time     sort(vct.begin(), vct.end(), compare_interval);       // push the first interval to stack     s.push(vct[0]);       // Start from the next interval and merge if necessary     for (int i = 1 ; i < vct.size(); i++)     {         // get interval from stack top         interval top = s.top();           // if current interval is not overlapping with stack top,         // push it to the stack         if (top.end < vct[i].start)         {             s.push( vct[i] );         }         // Otherwise update the ending time of top if ending of current         // interval is more         else if (top.end < vct[i].end)         {             top.end = vct[i].end;             s.pop();             s.push(top);         }     }     while(!s.empty())     {         interval t = s.top();         ARR.push_back(t);         s.pop();     }     sort(ARR.begin(), ARR.end(),compare_interval); }  int bs(ll * ptr, ll val, int lo, int hi) { 	int mid; 	while(lo <= hi) 	{ 		mid = lo + ((hi-lo)>>2);  		if(ptr[mid] == val) return mid+1; 		else if(ptr[mid] > val) hi = mid - 1; 		else			lo = mid + 1; 	} 	return hi+1; }  void solve() { 	int N,Q; 	cin >> N >> Q; 	ll ptr[N];	 	for(int i = 0; i < N; i++) 		cin >> ptr[i]; 	 	sort(ptr,ptr+N); 	vector<interval> VCT; 	interval I;  	int x,y; 	for(int i = 0; i < Q; i++) 	{ 		cin >> x >> y; 		I.start = x, I.end = y; 		VCT.pb(I); 	}  	mergeIntervals(VCT); 	ll ans = 0; 	for(int	i = 0; i < ARR.size(); i++) 	{ 		ans += (bs(ptr, ARR[i].end, 0, N-1) - bs(ptr,ARR[i].start-1, 0, N-1)); 	} 	cout << ans << endl;  }  int main() { 	solve(); 	return 0; }
#include<bits/stdc++.h>  using namespace std;   class BIT { public: 	BIT(int n) : N(n)  	{  		f = new int[1 + N];  		vals = new int[1 + N];   		for (int i = 0; i <= N; i++) 			f[i] = vals[i] = 0; 	} 	 	~BIT()  	{  		delete[] f;  		delete[] vals; 	}   	void update_delta(int idx, int delta) 	{ 		idx++;   		vals[idx] += delta;  		while (idx <= N) 		{ 			f[idx] += delta; 			idx += (idx & -idx); 		} 	}   	void update(int idx, int val) 	{ 		idx++;   		int x = val - vals[idx]; 		vals[idx] = val;  	 		while (idx <= N) 		{ 			f[idx] += x; 			idx += (idx & -idx); 		} 	} 	int prefix_sum(int idx) 	{ 		idx++; 	 		int ans = 0; 		while (idx > 0) 		{ 			ans += f[idx]; 			idx -= (idx & -idx); 		}   		return ans; 	} 	int range_sum(int start, int end) 	{ 		if (start == 0) 			return prefix_sum(end);   		return (prefix_sum(end) - prefix_sum(start - 1)); 	}   private: 	int *f;	 	int *vals; 	int N; }; class Underwear { public: 	Underwear(vector<pair<int, int> > &int_set) 	{ 		vector<int> tmpl; 		vector<int> tmpr; 		for (int i = 0; i < int_set.size(); i++) 		{ 			tmpl.push_back(int_set[i].first); 			tmpr.push_back(int_set[i].second); 		}   		std::sort(tmpl.begin(), tmpl.end()); 		std::sort(tmpr.begin(), tmpr.end());   		hsl.resize(4 * tmpl.size()); 		hsr.resize(4 * tmpr.size());   		int nl = 0; 		for (int i = 0; i < tmpl.size(); i++) 		{ 			int x = tmpl[i]; 			if (mpl.find(x) == mpl.end()) 			{ 				hsl[x % hsl.size()].push_back(make_pair(x, nl)); 				mpl[x] = nl++; 			} 		}   		beg = new BIT(nl);   		int nr = 0; 		for (int i = 0; i < tmpr.size(); i++) 		{ 			int x = tmpr[i]; 			if (mpr.find(x) == mpr.end()) 			{ 				hsr[x % hsr.size()].push_back(make_pair(x, nr)); 				mpr[x] = nr++; 			} 		} 		 		end = new BIT(nr); 	}   	~Underwear() 	{ 		delete beg; 		delete end; 	}   	int lookupl(int x) 	{ 		int id = x % hsl.size(); 		for (int i = 0; i < hsl[id].size(); i++) 			if (hsl[id][i].first == x) 				return hsl[id][i].second;   		return -1; 	}   	int lookupr(int x) 	{ 		int id = x % hsr.size(); 		for (int i = 0; i < hsr[id].size(); i++) 			if (hsr[id][i].first == x) 				return hsr[id][i].second;   		return -1; 	} 	void add_interval(int s, int e) 	{ 		int x = lookupl(s);int y = lookupr(e);beg->update_delta(x, 1);end->update_delta(y, 1); 	}   	void delete_interval(int s, int e) 	{ 		int x = lookupl(s);int y = lookupr(e);beg->update_delta(x, -1);end->update_delta(y, -1); 	}   	int count(int s, int e) 	{ 		if (mpl.empty()) 			return 0;   		map<int, int>::iterator it1 = mpl.upper_bound(e); 		if (it1 == mpl.begin())	 			return 0;	   		it1--; 		int ans = beg->prefix_sum(it1->second);   		map<int, int>::iterator it2 = mpr.lower_bound(s); 		if (it2 == mpr.end()) 			return 0;   		if (it2 == mpr.begin()) 			return ans;   		it2--; 		 		ans -= end->prefix_sum(it2->second); 		return ans; 	}   private: 	map<int, int> mpl; 	map<int, int> mpr;   	vector<vector<pair<int, int> > > hsl; 	vector<vector<pair<int, int> > > hsr;   	BIT *beg; 	BIT *end; }; int main() { 	int N,Q; 	cin>>N>>Q; 	vector< pair<int,int> > vall,vin; 	int A[N+143],B[N+143],C1,C2; 	for(int i=0;i<N;i++) 	{        cin>>A[i]>>B[i];        vall.push_back(make_pair(A[i],B[i])); 	} 	for(int i=0;i<Q;i++){ 		cin>>C1>>C2; 		vall.push_back(make_pair(C1,C2)); 		vin.push_back(make_pair(C1,C2)); 	} 	Underwear it(vall); 	for(int i=0;i<N;i++){ 		it.add_interval(A[i],B[i]); 	} 	int count=0; 	for(int i=0;i<Q;i++){ 		int result=it.count(vin[i].first,vin[i].second); 		std::cout<<result<<std::endl; 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; #define getcx getchar #define maxn 1005 #define F(i,p,n) for(i=p;i<n;i++) #define I(i,p,q) for(i=p;i>=q;i--) #define S(x) scanf("%d",&x) #define P(x) printf("%lld\n",x) #define Ps(x) printf("%lld ",x) #define LL long long int #define pii pair<int,int> int mod=1e9+7,n,m,s,sz; LL dp[65000]; void fun1() {     int i,j,k;     LL temp[65000],a[65000]={0};     sz=2*s-1;      F(i,1,s)     {         dp[i]=i;         dp[sz-i+1]=m/i;     }     dp[s]=s;     temp[1]=1;     F(i,2,sz+1)     temp[i]=dp[i]-dp[i-1];     F(i,2,n+1)     {         F(j,1,sz+1)         {             a[j]=(dp[sz+1-j]*temp[j]+a[j-1])%mod;         }         F(j,1,sz+1)         {             dp[j]=a[j];             /*if(dp[j]>=mod)                 dp[j]-=mod;*/         }     } } void fun2() {     int i,j,k;     LL temp[65000],a[65000]={0};     sz=2*s;      F(i,1,s+1)     {         dp[i]=i;         dp[sz-i+1]=m/i;     }     temp[1]=1;     F(i,2,sz+1)     temp[i]=dp[i]-dp[i-1];     F(i,2,n+1)     {         F(j,1,sz+1)         {             a[j]=(dp[sz+1-j]*temp[j]+a[j-1])%mod;         }          F(j,1,sz+1)         {             dp[j]=a[j];             /*if(dp[j]>=mod)                 dp[j]-=mod;*/         }     } } int main() {     int i,j,k;     S(n);     S(m);     s=sqrt(m);      if(s==m/s)         fun1();     else         fun2();     P(dp[sz]);     return 0; } 
#include <iostream> #include <stdio.h>  using namespace std;  int min_element(int arr[]) { 	int min = arr[1]; 	int i; 	for (i = 1; i < 10; i++) { 		if(arr[i]<min) 			min = arr[i]; 	} 	return min; }  void solve(int arr[]) { 	int i; 	for (i = 1; i < 10; i++) { 		if (arr[i] == 0) { 			cout << i << endl; 			return; 		} 	}  	for (i = 1; i < 10; i++) { 		if (arr[i] == 1 && arr[0] == 0) { 			cout << i << "0 "<<endl; 			return; 		} 	} 	int min = min_element(arr); 	for (i = 1; i < 10; i++) { 		if(arr[i] == min) 			break; 	} 	if (arr[0] < arr[i]) { 		cout << "1"; 		for(int m = 0 ; m < arr[0]+1 ; m++) 			cout << "0"; 		cout << endl; 		return; 	} 	int j ; 	for(j = 0 ; j < arr[i] ; j++) 		cout << i ; 	if(arr[0] == 0) 		cout << "0"<<endl; 	else 		cout << i << endl; }  int main() { 	int t,i,j,n; 	int arr[10]; 	cin>>t; 	while (t--) { 		for(i=0;i<10;i++) 			cin>>arr[i]; 		solve(arr); 	} 	return 0; }
    #include <iostream>     #include <cstdio>     #include <algorithm>     #include <string>     #include <vector>     #include <map>     #include <set>           using namespace std;           #define MODULUS 1000000007     /*     long long pow(int a, int b, int MOD)     {     long long x=1,y=a;     while(b > 0)     {     if(b%2 == 1)     {     x=(x*y);     if(x>MOD) x%=MOD;     }     y = (y*y);     if(y>MOD) y%=MOD;     b /= 2;     }     return x;     }           /* Modular Multiplicative Inverse     Using Euler's Theorem     a^(phi(m)) = 1 (mod m)     a^(-1) = a^(m-2) (mod m) */     /*     long long InverseEuler(int n, int MOD)     {     return pow(n,MOD-2,MOD);     }           long long C(int n, int r, int MOD)     {     vector<long long> f(n,1);     for (int i=2; i<=n;i++)     f[i]= (f[i-1]*i) % MOD;     return (f[n]*((InverseEuler(f[r], MOD) * InverseEuler(f[n-r], MOD)) % MOD)) % MOD;     }     */     /*     long long C(int n, int r, int MOD)     {     vector< vector<long long> > C(2,vector<long long> (r+1,0));           for (int i=0; i<=n; i++)     {     for (int k=0; k<=r && k<=i; k++)     if (k==0 || k==i)     C[i&1][k] = 1;     else     C[i&1][k] = (C[(i-1)&1][k-1] + C[(i-1)&1][k])%MOD;     }     return C[n&1][r];     }           long long C(int n, int r)     {     if (r==0) return 1;     else return (C(n-1,r-1) * n / r)%MODULUS;     }     */           int countFact(int n, int p)     {     int k=0;     while (n>0)     {     k+=n/p;     n/=p;     }     return k;     }           /* This function calculates (a^b)%MOD */     long long pow(int a, int b, int MOD)     {     long long x=1,y=a;     while(b > 0)     {     if(b%2 == 1)     {     x=(x*y);     if(x>MOD) x%=MOD;     }     y = (y*y);     if(y>MOD) y%=MOD;     b /= 2;     }     return x;     }           long long C(int n, int r, int MOD)     {     long long res = 1;     vector<bool> isPrime(n,1);     for (int i=2; i<=n; i++)     if (isPrime[i])     {     for (int j=2*i; j<=n; j+=i)     isPrime[j]=0;     int k = countFact(n,i) - countFact(r,i) - countFact(n-r,i);     res = (res * pow(i, k, MOD)) % MOD;     }     return res;     }           int main()     {     int t,i;     // scanf("%d", &t);     // while ( t-- ) {     // cout << C(5,1,MODULUS) << endl;           int n,m,k,x,y;     int min = 0;     scanf("%d %d %d", &n, &m, &k);     for ( i = 0; i < k; ++i ) {     scanf("%d %d", &x, &y);     min += y;     }     int total = n - min;     if ( total < 0 ) {     printf("0\n");     return 0;     }     int C1 = total + m - 1;     int C2 = m - 1;     printf("%lld\n", C(C1,C2,MODULUS));           // }     return 0;     } 
#include <bits/stdc++.h> using namespace std; int main() { 	int T; 	scanf("%d",&T); 	while(T-->0) { 		string a,b; 		cin>>a>>b; 		int lenA = a.length(),lenB = b.length(), diff = lenA-lenB,count=0; 		if(diff<0)  		for(int i=0;i<abs(diff);i++) 		a = '0' + a; 		else for(int i=0;i<diff;i++) 		b = '0' + b; 		for(int i=max(lenA-1,lenB-1);i>=0;i--)  		if(a[i]-'0'+b[i]-'0'>9) { 			count++; 			if(i!=0) 			{ 			a[i-1] = a[i-1] - '0'; 			a[i-1]++; 			a[i-1] = a[i-1] +'0'; 			} 		} 		printf("%d\n",count); 	}	return 0; }
#include<bits/stdc++.h> #define ll long long #define pii pair<ll,ll> using namespace std;  int bit(int a){ 	set<int> digits; 	int ac= a; 	while(a!=0){ 		digits.insert(a%10); 		a = a/10; 	} 	int ans = 0; 	for(set<int> ::iterator it = digits.begin(); it!= digits.end() ; it++){ 		ans += 1<<(*it); 	} 	return ans; }  pair<ll, ll> M[1024];  bool compare(int a, int b){ 	if(M[a].first < M[b].first) 		return true; 	if(M[a].first > M[b]. first) 		return false; 	return M[a].second < M[b].second; }  int main(){  	while(!feof(stdin)){ 		if(feof(stdin))return 0; 		for(int i =0; i< 1024; i++){ 			M[i] = make_pair(0,0); 			} 		int n; 		cin>>n; 		int A[101]; 		for(int i =0; i< n; i++){ 			cin>>A[i]; 			int a = bit(A[i]); 			for(int x =0; x< 1024; x++){ 				if((int)(x&a) == 0){ 					if(M[x|a].first <M[x].first + A[i]){ 						M[x|a].first = M[x].first + A[i]; 						M[x|a].second = M[x].second + 1; 					} 					else if(M[x|a].first == M[x].first + A[i]){ 						 M[x|a].second = max(M[x|a].second, M[x].second + 1); 					} 				} 			} 		} 		if(feof(stdin))return 0;  		int idx= 0; 		for(int i =1; i< 1024; i++){ 			if(compare(idx, i)) 				idx  = i; 		} 		cout<<M[idx].second<<endl; 	} 	return 0; }  
#include<set> #include<climits> #include<algorithm> #include<utility> #include<cstdlib> #include<cctype> #include<queue> #include<sstream> #define read(x) scanf("%d",&x) #define write(x) printf("%d\n",x) #define assign(x,n) x=(int*)calloc(n,4) #define rep(i,n) for(i=1;i<=n;++i) #define max(a,b) ((a)>(b))?(a):(b) typedef  long long int ull;   int  v[1001]={0};     int main() { 	   int t,n,i,j,k;   read(t);   while(t--)   {   	     read(n);       for(i=0;i<n;i++)       {       	read(v[i]);       	//v.push_back(j);       }         int ans=1;     int l[1001]={1,0};     for(i=1;i<n;i++)                {                                for(j=k=0;j<i;j++) 			   if(v[j]<=v[i] && l[j]>k)k=l[j];                l[i]=k+1;                  if(l[i]>ans)ans=l[i];                }          write(ans);       // v.clear(); }   return 0; }
#include <bits/stdc++.h>  #define fi(a,b,c) for(int a=b; a<=c; a++) #define fd(a,b,c) for(int a=b; a>=c; a--) #define fii(a,b,c) for(int a=b; a<c; a++) #define pb push_back #define mp make_pair #define ft first #define sc second #define reset(a,b) memset(a,b, sizeof a)  using namespace std;  typedef long long ll; typedef pair <int, int> pii; typedef unsigned int ui;  const int N = 100; const ll oo = 1000; const ll module = 1009ll;  ll fact[module + 10], inv_fact[module + 10];  ll inv(ll a, ll m) {     ll xa = 1, xm = 0, xr;     ll r, q;     while (m!= 0) {         q = a / m;         xr = xa - xm * q;         xa = xm; xm = xr;         r = a % m;         a = m; m = r;     }     if (xa < 0) xa+= module;     return xa; }  void Init() {     fact[0] = 1;     inv_fact[0] = inv(fact[0], module);     fi(i, 1, module) {         fact[i] = fact[i-1] * i;         fact[i] %= module;         inv_fact[i] = inv(fact[i], module);     } }  ll n, k, nn; int tcase;  ll Lucas(ll m, ll n) {     if (m < n) return 0;     if (n == 0) return 1;     if (m < module && n < module) {         return (((fact[m] * inv_fact[n]) % module ) * inv_fact[m-n]) % module;     }     ll p = module;     ll ans = 1;     while (n || m)  {         ans *= Lucas(m % p, n % p);         ans %= module;         m/= p; n/=p;     }     return ans; }  int main() {     ios::sync_with_stdio(false);   //  freopen("test.in", "r", stdin);   //  freopen("test.out", "w", stdout);     cin >>tcase;     Init();     while (tcase --)     {         cin >> n >> k;         ll kk = Lucas(n, k);         cout <<kk <<endl;     } }  
#include <iostream>           using namespace std;     unsigned long long s[100001];     int ntestcases,n;           int main(){     s[0]=s[1]=s[2]=s[3]=0;     for(int i=4; i<100001; i++){     s[i] = s[i-1]+ (1LL*(i-1)*(i-2)/2-(i-1)/2)/2;     }     scanf("%d",&ntestcases);     while(ntestcases--){     scanf("%d",&n);     cout <<s[n] << endl;     }     return 0;     }  
// another fine solution by misof // #includes {{{ #include <algorithm> #include <numeric>  #include <iostream> #include <sstream> #include <string> #include <vector> #include <queue> #include <set> #include <map> #include <stack>  #include <cstdio> #include <cstdlib> #include <cstring> #include <cctype> #include <cassert>  #include <cmath> #include <complex> using namespace std; // }}}  /////////////////// PRE-WRITTEN CODE FOLLOWS, LOOK DOWN FOR THE SOLUTION ////////////////////////////////  // pre-written code {{{ // }}}  /////////////////// CODE WRITTEN DURING THE COMPETITION FOLLOWS ////////////////////////////////  int N; string S; vector<vector<long long> > best;  long long solve(int zac, int kon) {     long long &res = best[zac][kon];     if (res >= 0) return res;     res = 0;     if (zac == kon) return res = 1;     if (zac+1 == kon) return res = 2;     res = solve(zac,kon-1) + solve(zac+1,kon);     if (S[zac] != S[kon-1]) res -= solve(zac+1,kon-1);     return res; }  int main() {     int T; cin >> T;     while (T--) {         cin >> S;         best.clear();         N = S.size();         best.resize(N+1, vector<long long>(N+1,-1));         cout << solve(0,N)-1 << endl;     } } // vim: fdm=marker:commentstring=\ \"\ %s:nowrap:autoread 
#include<cstdio> #include<algorithm> #include<iostream> using namespace std; double calc(int,int,int,int); int main() { 	int n,a[1000][2],t,m,c,in,i,j; 	double sl[1000]; 	cin>>t; 	while(t--) 	{ 		cin>>n; 		for(i=0;i<n;i++) 			cin>>a[i][0]>>a[i][1];		 		m=-1; 		for(i=0;i<n;i++) 		{ 			in=0; 			for(j=i+1;j<n;j++) 			{ 				sl[in++]=calc(a[i][0],a[j][0],a[i][1],a[j][1]);			 			} 			sort(sl,sl+in); 			c=2; 			for(j=0;j<in;j++) 			{ 				if(sl[j]==sl[j+1]) 				c++; 				else 				c=2; 				m=max(c,m); 			} 		} 		if(n==1) 		printf("1\n"); 		else 		printf("%d\n",m); 	}  	return 0; } double calc(int x1,int x2,int y1,int y2) { 	return (double)(y1-y2)/(x1-x2); } 
#include <iostream> #include<cstring> #include<string> #define nopath 0  using namespace std; int main() 	{ 		int T; 		int N; 		string paths[]={"0","2","8","28","96","328","1120","3824","13056","44576","152192","519616","1774080","6057088","20680192", 						"70606592" , "241065984 " , "823050752", "2810071040","9594182656","32756588544", 						"111837988864","381838778368","1303679135744","4451038986240", 						"15196797673472" ," 51885112721408" , "177146855538688" , 						"604817196711936", "2064975075770368", "7050265909657600", 						"24071113487089664", "82183922129043456" , 						"280593461541994496" ,"958006001909891072", 						"3270837084555575296",  						"11167336334402519040", 						"38127671168498925568", 						"130176012005190664192", 						"444448705683764805632", 						"1517442798724677894144", 						"5180873783531181965312", 						"17688609536675372072960", 						"60392690579639124361216", 						"206193543245205753298944", 						"703988791821544764473344", 						"2403568080795767551295488", 						"8206294739539980676235264", 						"28018042796568387602350080", 						"95659581707193589056929792" 						}; 		cin>>T; 		while(T--) 		{ 				cin>>N; 				if((N%2)==0) 				{ 					cout<<paths[(N/2)-1]<<endl; 				} 					else 					{ 						cout<<nopath<<endl; 					}  		}  		//system("pause"); 		return 0; 	}
#include <stdio.h> #include <string> #include <iostream>  using namespace std; typedef long long LL; const LL base = 10000000000LL; struct BigNumber{ 	LL num[30]; 	int l; }; BigNumber chart[101]; inline BigNumber construct(LL a){ 	BigNumber ret; 	int i=0; 	while(a){ 		ret.num[i] = a%base; 		a /= base; 		i++; 	} 	for(int j=i;j<30;j++){ 		ret.num[j] = 0LL; 	} 	ret.l = i; 	return ret; } inline BigNumber add(BigNumber x,BigNumber y){ 	BigNumber z = construct(0LL); 	int h = x.l > y.l?x.l:y.l; 	LL carry = 0LL; 	for(int i=0;i<h;i++){ 		z.num[i] = x.num[i]+y.num[i]+carry; 		carry = z.num[i]/base; 		z.num[i] %= base; 	} 	if(carry){ 		z.num[h] = 1LL; 		z.l = h+1; 	} 	else 		z.l = h; 	return z;	 }  inline BigNumber add_shift(BigNumber x,BigNumber y,int s){ 	BigNumber z = construct(0LL); 	int h = x.l+s > y.l?x.l+s:y.l; 	LL carry = 0LL; 	for(int i=0;i<s;i++){ 		z.num[i] = y.num[i]; 	} 	for(int i=s;i<h;i++){ 		z.num[i] = x.num[i-s]+y.num[i]+carry; 		carry = z.num[i]/base; 		z.num[i] %= base; 	} 	if(carry){ 		z.num[h] = 1; 		z.l = h+1; 	} 	else 		z.l = h; 	return z;	 }  inline BigNumber product(BigNumber x,LL y){ 	BigNumber a = construct(0LL); 	LL carry = 0; 	int i; 	for(i=0;i<x.l;i++){ 		a.num[i] = y*x.num[i] + carry; 		carry = a.num[i]/base; 		a.num[i] %= base; 	} 	if(carry){ 		a.num[i] = carry; 		a.l = i+1; 	} 	else 		a.l = i; 	return a;	 }  inline BigNumber multiply(BigNumber x,BigNumber y){ 	BigNumber prd = construct(0LL); 	BigNumber inter = construct(0LL); 	inter = product(x,y.num[0]); 	for(int i=1;i<y.l;i++){ 		prd = inter; 		inter = product(x,y.num[i]); 		inter = add_shift(inter,prd,i); 	} 	return inter; } void print_bn(BigNumber bn){ 	int k = bn.l; 	cout << bn.num[k-1]; 	for(int i=k-2;i>=0;i--){ 		LL temp = 1000000000LL; 		while(temp > 1 && !(bn.num[i]/temp)){ 			cout << "0"; 			temp /= 10LL; 		} 		cout << bn.num[i]; 		 	} }  void develop_chart(){ 	chart[1] = construct(2LL); 	for(int n=2;n<=100;n++){ 		chart[n] = product(chart[n-1],LL(2*n-1)); 	} }   int main(){ 	int t; 	develop_chart(); 	//printf("finished"); 	scanf("%d",&t); 	while(t--){ 		int n; 		scanf("%d",&n); 		print_bn(chart[n]); 		printf("\n"); 	}  	 } 
#include<bits/stdc++.h> using namespace std; int a[1000000+1]; int main() {     int t;     cin>>t;     while(t--)     {         int l,r;         cin>>l>>r;              a[0]=0;             a[1]=0;         for(int i=2;i<=r;i++)             a[i]=1;             int m=0;         for(int i=2;i*i<=r;i++)         {             if(a[i])             {                 for(int j=i*i;j<=r;j=j+i)                 {                     a[j]=0;                  }             }          }              for(int i=1;i<=r;i++)             {                 a[i]=(a[i]+a[i-1]);             }             cout<<a[r]-a[l-1]<<endl;          } } 
#include<bits/stdc++.h> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {         int n;         cin>>n;         int a[n];         for(int i=0;i<n;i++)             cin>>a[i];         sort(a,a+n);         int i=0,j=n-1;         bool flag=true;         while(i<=j)         {             if(flag)             {                 cout<<a[j]<<" ";                 j--;                 flag=false;             }             else             {                 cout<<a[i]<<" ";                 i++;                 flag=true;             }         }         cout<<endl;     }     return 0; } 
#include<iostream> #include<stdio.h> //#include<conio.h> using namespace std; int main(){     int k,r,t;     cin>>t;     while(t--)     { 	          long int i=1,j=1,f,t;                //Taking maximum numbers form user     //printf("Enter the number range:");     scanf("%d",&r);     if(r==1)     printf("%lc\n",j+64); else if(r>1) {      // printf("FIBONACCI SERIES: ");     printf("%lc%lc",i+64,j+64); //printing firts two values.      for(k=2;k<r;k++){          f=i+j;          i=j;          j=f;          if(j>26)          j=j%26;          printf("%c",j+64);               }      cout<<endl;   }}      //getch();     return 0; } 
#include <cstdio> #include <cstring> #define LSOne(S) (S & (-S)) using namespace std;  typedef long long ll;  // B1 and B2 are two fenwick trees // Original array entries are assumed to be 0 // and only updates are stored. ll B1[100005], B2[100005];  // Array size int N;  // Point query // Returns value at position b in the array for ft = B1 // Returns value to be subtracted from query(B1, b) * b for ft = B2 ll query(ll* ft, int b)	{ 	ll sum = 0; 	for (; b; b -= LSOne(b)) sum += ft[b]; 	return sum; }  // Range query: Returns the sum of all elements in [1...b] ll query(int b) {     return query(B1, b) * b - query(B2, b); }  // Range query: Returns the sum of all elements in [i...j] ll range_query(int i, int j)    {     return query(j) - query(i - 1); }  // Point update: Adds v to the value at position k in the array // ft is the fenwick tree which represents that array void update(ll* ft, int k, ll v) { 	for (; k <= N; k += LSOne(k)) ft[k] += v; }  // Range update: Adds v to each element in [i...j] void range_update(int i, int j, ll v)	{ 	update(B1, i, v); 	update(B1, j + 1, -v); 	update(B2, i, v * (i - 1)); 	update(B2, j + 1, -v * j); }  int main()  { 	int T, C, p, q, cmd; 	ll v;  	scanf("%d", &T); 	while (T--)	{ 		// C -> No. of operations 		scanf("%d %d", &N, &C); 		memset(B1, 0, (N+1) * sizeof(ll)); 		memset(B2, 0, (N+1) * sizeof(ll)); 		while (C--)	{ 			scanf("%d %d %d", &cmd, &p, &q); 			// cmd is 0 for a range update and 1 for a range query 			if (cmd == 1)   {                 		scanf("%lld", &v);                 		range_update(p, q, v); 			} else                 		printf("%lld\n", range_query(p, q)); 		} 	}      return 0; }
#include <iostream> #include <cstdio> using namespace std;  int n, k; string s;  int compute() {     int cnt=0, ans=0;     int mx_len=0;     for(int i=0; i<n; i++)     {         cnt=0;         for(int j=i; j<n; j++) 		{ 			if(s[i]!=s[j]) 				break;             cnt++;         }         mx_len=max(mx_len, cnt);         ans+=(cnt/k);         if(cnt%k!=0) 			ans++;         i+=cnt-1;     }     if(k>mx_len)         return -1; 	else 		return ans; }  int main() { 	int t; 	scanf("%d", &t); 	while(t--) 	{ 		scanf("%d%d", &n, &k); 		cin>> s; 		int ans=compute(); 		printf("%d\n",ans); 	}  	return 0; } 
#include <iostream> #include <string.h> #include <stdlib.h> #include <stdio.h> #include <cmath> #include <algorithm> #include <vector> #include <stack> #include <queue> #include <list> #include <map> #include <set> #include <iterator> #include <time.h>   #define MAX(a,b) (a>b)?a:b #define MIN(a,b) (a>b)?b:a using namespace std; typedef long long int llint; typedef long int lint; template <typename T_> void fastread(T_ *a) {     char c=0; *a=0;     while(c<33){c=getchar();}     while(c>32){*a=(*a<<3)+(*a<<1)+c-'0'; c=getchar();} }   llint fast_str(char *a) {     llint len=0; char c=0;     while(c<33){c=getchar();}//eat spaces     while(c!='\n'){*a=c; ++len; ++a; c=getchar();}     *a='\0';     return len; }   llint fast_wrd(char *a) {     char c=0; llint len=0;     while(c<33){c=getchar();}     while(c>32){*a=c; ++len; ++a; c=getchar();}     *a='\0';     return len; }     llint exponent_fast(llint x, llint n, llint MOD) {     llint result=1,m,sample=x;     m=n;     while(m>0)     {         while( m%2 == 0)         {             sample = (sample *sample)%MOD;             m/=2;             if(m==0)break;         }         --m;         result = (result * sample)%MOD;     }     return result; }  int visited[100000]; vector<int> verts[100000];  void flush() {     for(llint i=0;i<100000; ++i) {         visited[i] = 0;         verts[i].clear();     } }  void visit(int node) { //indirectly dfs     for(int i=0;i<verts[node].size();++i) {         if(!visited[verts[node].at(i)]) {             visited[verts[node].at(i)]=1;             visit(verts[node].at(i));         }     } }  /*#define fileIO #define debug*/ //problem code: CC, codechef, connected components int main(){     #ifdef fileIO     freopen("in1.txt","r",stdin);     #endif //fileIO     //= = = = = = = = = = = = = = = = = = = =     llint cases,vertices,edges;     fastread(&cases);     while(cases--) {         fastread(&vertices);         fastread(&edges);         llint cc=0;         llint from, to;         while(edges--) {             fastread(&from); fastread(&to);             verts[from].push_back(to);             verts[to].push_back(from);         }          for(llint i=0; i<vertices; ++i) {             if(!visited[i]) { //then visit it and color children                 ++cc;                 visited[i] = 1;                 visit(i);             }         }         cout<<cc<<endl;          flush();     }     //= = = = = = = = = = = = = = = = = = = =     return 0; } 
#include<iostream> using namespace std; int main() {   int t;   cin>>t;   while (t--) {     unsigned long long n;     cin>>n;     unsigned long long x1, y1, x2, y2;     cin>>x1>>y1>>x2>>y2;     //cout << x1 << endl;         unsigned long long d1, d2;     if (x1 < x2) {       d1 = x2 - x1;     } else {       d1 = x1 - x2;     }     if (y1 < y2) {       d2 = y2 - y1;     } else {       d2 = y1 - y2;     }     if (x1 == x2 && y1 == y2) {       printf("0\n");     } else if (d1 % 2 == 0 && d2 % 2 == 1) {       printf("-1\n");     } else if (d1 % 2 == 1 && d2 % 2 == 0) {       printf("-1\n");     } else if (d1 != 0 && d2 != 0 && d1 == d2) {       printf("1\n");     } else {       printf("2\n");     }   }   return 0; } 
//Author : pakhandi //  using namespace std;  #include<iostream> #include<cstdio> #include<cstdlib> #include<algorithm> #include<cmath> #include<cstring>  #define wl while #define fl(i,a,b) for(i=a; i<b; i++)  long long int fbn[1000005];  void calc_fbn() { 	int i; 	fbn[0]=0; 	fbn[1]=1; 	long long int temp; 	fl(i,2,1000005) 	{ 		temp=fbn[i-1]+fbn[i-2]; 		if(temp>1000000007) 			temp%=1000000007; 		fbn[i]=temp; 	} }  int main() { 	calc_fbn(); 	long long int cases, a, b, r, ans; 	scanf("%lld", &cases); 	wl(cases--) 	{ 		scanf("%lld%lld%lld", &a, &b, &r); 		if(r==1) 			printf("%d\n", a); 		else if(r==2) 			printf("%d\n", b); 		else 		{ 			//cout<<fbn[r-2]<<" "<<fbn[r-1]; 			ans=(b*fbn[r-1])+(a*fbn[r-2]); 			printf("%lld\n", ans%1000000007); 		} 		//cout<<">"<<ans<<"<"; 		//printf("%lld\n", ans%1000000007); 	} 	return 0; }
#include<iostream> using namespace std; long long fact(long long i) { 	if(i==0) 	return 1; 	long long res=1; 	while(i!=1) 	{ 		res=res*i; 		i--; 	} 	return res; } long long func(long long n,long long r) { 	if(n<r) 	return 0; 	long long numerator=fact(n); 	long long denomenator=fact(r)*fact(n-r); 	return numerator/denomenator;   } int main() { 	int test; 	cin>>test; 	while(test--) 	{ 		long long z=1000000007; 		long long n,m; 		cin>>n>>m; 		long long ans=func(n,3); 		if(m==0) 		cout<<ans%z<<"\n"; 		else 		{ 			long long a[m]; 			long long sub=0; 			for(long long i=0;i<m;i++) 			{ 				cin>>a[i]; 				sub+=func(a[i],3); 				sub+=func(a[i],2)*(n-a[i]); 			} 			cout<<(ans-sub)%z<<"\n"; 		} 	} 	return 0; }      
#include<bits/stdc++.h> using namespace std; #define ll long long vector<int> v(100000001); int palin(int n) {     int temp,r,rev=0;     temp=n;     while(temp>0)     {         r=temp%10;         rev=(rev*10)+r;         temp/=10;     }     if(rev==n)         return 1;     return 0; } int main() {     map<int,ll> s;     ll val=0,ans;     int i,j,n,m,t;     for(i=2;i<=100000000;i++)     {         if(v[i]==0)         {             if(palin(i))             {                 val+=i;                 s[i]=val;             }             for(j=2*i;j<=100000000;j=j+i)             {                 v[j]=1;             }         }     }     map<int,ll>::iterator it1,it2;     scanf("%d",&t);     while(t--)     {         scanf("%d%d",&n,&m);         ans=0;         it1=s.lower_bound(n);         if(it1==s.end())             ans=0;         else if((it1->first)<=m)         {             it2=s.lower_bound(m);             if((it2==s.end())||((it2->first)!=m))             {                 it2--;             }             ans=(it2->second)-(it1->second)+(it1->first);         }         else             ans=0;         printf("%lld\n",ans);     }     return 0; } 
#include<bits/stdc++.h> using namespace std;  const int N=512345; int a[N], b[N];  int main() {     int test;     scanf("%d", &test);     while(test--) {         int n, m;         scanf("%d %d", &n, &m);         for(int i=0;i<n;i++) {             scanf("%d", &a[i]);         }         for(int j=0;j<m;j++) {             scanf("%d", &b[j]);         }         int i=0, j=0;         while(i<n && j<m) {             if(a[i]>b[j]) {                 printf("%d ", a[i]);                 i++;             } else {                 printf("%d ", b[j]);                 j++;             }         }         while(i<n) {             printf("%d ", a[i]);             i++;         }         while(j<m) {             printf("%d ", b[j]);             j++;         }         putchar('\n');     } } 
#include<stdio.h> #include<iostream> #include<math.h> #include<string.h> using namespace std;   int main() {        int t;       cin>>t;       while(t--)       {          int n,sum=0;        cin>>n;        while(n--)        {         long long int a,d;          cin>>d;          cin>>a;          while(a>=0)          {              sum+=a;              a-=d;          }        }        if(sum%2==1)         cout<<"YES"<<endl;        else         cout<<"NO"<<endl;       }   return 0; }  
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <limits> #include <string> #include <cassert> #include<cstring> using namespace std; #define ll long long int #define MEM(a,b) memset(a,(b),sizeof(a)) #define MAX(a,b) ((a) > (b) ? (a) : (b)) #define MIN(a,b) ((a) < (b) ? (a) : (b))  int main() {     ll A[100];     A[1]=3;     ll power=1;     for(int j=2;j<=25;j++)     {         A[j]=A[j-1]+power*2+1;         power*=2;     }     //for(int i=1;i<=25;i++) cout<<A[i]<<endl;     int t;     cin>>t;     while(t--)     {         ll n;         cin>>n;         bool b=true;         for(int i=1;i<=24 and b;i++)         {             if(n<A[i+1] and n>=A[i])             {                 //cout<<i<<" "<<A[i]<<" "<<A[i+1]<<endl;                 b=false;                 ll temp=A[i];                 bool r=true;                 ll nk=n-temp;                 if(nk%2==1)                 {                     cout<<"NO\n";                     r=false;                 }                 ll pp = A[i]+pow(2,i)-2;                 if(r and n>pp)                 {                     cout<<"NO\n";                     r=false;                 }                 if(r and nk/2<=pow(2,i-1)-1)                 {                     int index=nk/2;                     if(index%2==0) cout<<"LEFT\n";                     else cout<<"RIGHT\n";                 }                 else if(r) cout<<"NO\n";             }         }     } } 
    #include<iostream>     int main()     {        std::cout<<"Welcome2C^3";        return 0;     } 
#include <iostream> #include <math.h> using namespace std; int main(){     int X;     int Y;     int Z;     int Sub = 0;     scanf("%d %d %d", &X, &Y, &Z);     Sub = Y - X;     Sub = ((Z - Y) > Sub) ? (Z - Y) : Sub;     printf("%d\n", Sub - 1);    return 0; } 
/* There's a new magician in dino-town. He can make X or more consecutive coloured playing cubes magically disappear with his wand. He has a large number of coloured playing cubes and he wishes to find the smallest number of cubes he should insert into the sequence so that he can make all of them vanish, keeping in mind that he can insert the cubes anywhere in the sequence, at the beginning, in between or at the end. Input  The first input line contains two integers Z (1 <= Z <= 100), the total number of cubes in the sequence and X (2 <= X <= 5), the minimum number of same coloured consecutive cubes he can make magically disappear. The second line contains Z integers between 1 and 100 (inclusive), representing the colours of the cubes in the sequence, separated by a space. Output  The minimum number of cubes that need to be inserted should be outputted on a single line. Example  Input: 3 7 9 9 9   Output: 4  Input: 5 4 1 1 2 1 1  Output: 3  */   #include<iostream> #include<vector> #include<string.h> #include<stdio.h> #include<list> #include<map> #include<set> #include<queue> #include<stack> #include<fstream> #include<sstream> #include<algorithm> #include<numeric> #include<math.h> #include<limits.h> using namespace std; #define FOR(i,a,b) for(i = (a); i < (b); i++) #define RFOR(i,a,b)for(i = (b); i >= (a); i--) #define FORI(it,x) for(typeof(x.begin()) it=x.begin();it!=x.end();++it) #define PB push_back #define ALL(x) (x).begin(),(x).end() #define CLEAR(x,with) memset(x,with,sizeof(x)) #define SZ(v) (v).size() #define ll long long int #define ii pair<int,int>  int t; int a[102]; int memo[102][103][10];  int f(int i , int j , int n){ 	 	if(i > j) 		return 0; 	 	if(memo[i][j][n] != -1)	 		return memo[i][j][n]; 			 	 	if(i == j) 		return max(0 , t - (n + 1)); 	int x = a[j] , k = j , l , ret1 = -1, ret2 = 1e9 , cnt = 0; 	 	while(k >= i && a[k] == x){ 		k--;  	} 	 	cnt = n + j - k; 	 	ret1 = f(i , k , 0) + max(0 , t - cnt); 	 	 	l = k; 	 	FOR(k , i , l + 1) 		if(a[k] == x){ 	//		cout << "calling ( " << i << k << " " << cnt << ") ("<<k+1 << " " <<l << "0" <<")\n"; 			ret2 = min(ret2 , f(i , k , (cnt>=t)?0:cnt) + f(k + 1 , l , 0));		 		} 	if(ret2 != -1) 		ret1 = min(ret1 , ret2); 	//cout << i << " " << j << " " << n << " gave " << ret1 << "\n"; 	return memo[i][j][n] = ret1;  }   int main()  { //	ios_base::sync_with_stdio(0);	  	CLEAR(memo , -1); 	int n ; 	cin >> n >> t; 	int i; 	FOR(i , 0 , n) 		scanf("%d",&a[i]); 	printf("%d\n" , f(0 , n-1 , 0)); 	  	return 0; } 
#include<stdio.h> #include<algorithm> #define fr(i,n) for(i=0;i<n;i++) using namespace std; #define Fr(i,n) for(i=1;i<=n;i++) int b[300005],c[300005]; int main() {     int t,n,i,j,max,tmp;         max=0; tmp=0;         scanf("%d",&n);         fr(i,n){ scanf("%d",&b[i]); c[i]=b[i]; }        // fr(i,n) l[i]=0;         sort(c,c+n);         i=n-1;             for(j=n-1;j>=0;j--)             {   if(i<0) break;                 if(c[i]==b[j]){ tmp++; i--; }             }             if(tmp>max) max=tmp;                            /*   fr(i,n)         {             fr(j,i)             {   if(b[j]<b[i] && l[i]<1+l[j])                 l[i]=1+l[j];             }             if(l[i]==0) l[i]=1;         }*/    /*     fr(i,n)         {   if(l[i]>max) max=l[i]; }*/         printf("%d\n",n-max);          return 0; }          
//Md. Ahsan Kabir Shohagh #include<bits/stdc++.h> using namespace std; #define sz 100002 #define pb(a) push_back(a) #define ll long long #define ull unsigned long long #define fread freopen("input.txt","r",stdin) #define fwrite freopen("output.txt","w",stdout) #define inf (1<<29) #define mem(abc,z) memset(abc,z,sizeof(abc)) #define PI acos(-1)  int main(){    int n,A[sz],median;      cin>>n;      for(int i=1;i<=n;i++){         cin>>A[i];      }      sort(A+1,A+n+1);      median=n>>1;      if(n&1) median++;      cout<<A[median]<<endl;    return 0; } 
#include<bits/stdc++.h>  using namespace std; int main() {     int t;     scanf("%d",&t);     long long n,ans;     while(t--)     {          scanf("%lld",&n);         ans=(n*log10(exp(1)))+1;         printf("%lld\n",ans);      }     return 0; } 
#include<iostream> using namespace std; int main() { 	long long int number,x,flag=0,o,i,j; 	cin>>number>>o;  	long long int n[number]; 	for(i=0;i<number;i++) 	{ 		cin>>n[i]; 	} 	for(i=0;i<number-1;i++) 	{ 		for(j=i+1;j<number;j++) 		{	 			if(n[i]+n[j]==o) 			{ 				flag=1; 				break; 			} 		} 	} 	if(flag==0) 	{ 		cout<<"No"; 	} 	else 	{ 		cout<<"Yes"; 	} 	return 0; } 
#include <iostream> #include <cstring> using namespace std;   int main() { int M,N,P,i,j,k; int mod=1000000007;  cin>>M>>N>>P; int num_way[M+1][N+1]; memset(num_way,0,sizeof(num_way));     	for(int p=0;p<P;p++) 	{ 		cin>>i>>j; 		num_way[i][j]=-1; 	}    	if(num_way[1][1]==-1) 	{cout<<"0"; 	return 0; 	}  // initialisation of first row ( direction is restricted to only right)  	for(k=1;k<=N;k++) 	{ 	if(num_way[1][k]!=-1) 	num_way[1][k]=1; 	else 	break; 	}	   // initialisation of first column ( direction is restricted to only down)  	for(k=1;k<=M;k++) 	{ 	if(num_way[k][1]!=-1) 	num_way[k][1]=1; 	else 	break; 	}  // start filling matrix num_way to find number of ways from 1,1 to m,n   	for(i=2;i<=M;i++) 	{ 		for(j=2;j<=N;j++) 		{ 			if(num_way[i][j]==-1)   // we dont want to calculate for blocked cells   			continue; 			else 			{ 			if(num_way[i][j-1]!=-1) 			num_way[i][j]=(num_way[i][j]+ num_way[i][j-1]) % mod ; 			 			 			if(num_way[i-1][j]!=-1) 			num_way[i][j]=(num_way[i][j]+num_way[i-1][j]) % mod ;  			} 					 		} 	}  if(num_way[M][N]>=0) cout<<num_way[M][N]; else cout<<"0";  }
#include<iostream> #include<cstdio> #include<cmath> #include<iomanip> #include<vector> #include<map> #include<set> #include<algorithm> #include<list> #include<cstring> #include<stack> #include<queue> using namespace std; #define ll long long #define vi vector<int> #define vii vector<vi > #define pp pair<int,int> #define pb push_back #define mp make_pair #define ppl pair<ll,ll> #define vl vector<ll> #define vll vector<vl > #define vb vector<bool> #define llu unsigned ll #define all(c) c.begin(),c.end() #define mod 1000000007 #define sc scanf #define pf printf ll power(ll a,ll b) { 	if(!b) 		return 1; 	if(b==1) 		return a; 	ll temp=power(a,b/2); 	temp=(temp*temp); 	if(b&1) 		temp=(temp*a); 	return temp; } class graph { 	vi * adj; 	int time; 	public: 		graph( int v) 		{ 			adj = new vi[v]; 			time = 0; 		} 		void add_edge(int u, int v) 		{ 			adj[u].pb( v); 			adj[v].pb( u); 		} };  int find(int i, vi& root) { 	while( i ^ root[i]) 	{ 		i=root[i]; 	} 	return i; }  void uniond(int x, int y, vi& root, vi& rank) { 	if( rank[x] > rank[y]) 		root[y]=x; 	else 		root[x]=y; 	if( rank[x] == rank[y]) 		rank[y]++; } int main() { 	ios_base::sync_with_stdio(false); 	int i, op, n, q, u, v, x, y; 	cin >> n >> q; 	vi root(n), rank(n); 	for( i=0;i<n;i++ ) 	{ 		root[i]=i; 	} 	while(q--) 	{ 		cin >>op >> u >> v; 		u--; 		v--; 		x=find(u, root); 		y=find( v, root); 		if( op==0) 		{ 			if( x^y ) 			{ 				uniond(x, y, root, rank); 			} 		} 		else 		{ 			if( x^y ) 			{ 				cout <<"No\n"; 			} 			else 				cout <<"Yes\n"; 		} 	}     return 0; } 
#include<iostream> using namespace std; #include<stdio.h> #include<string.h>  int isVowel(char a) { 	if(a=='a' || a=='e' || a=='i' || a=='o' || a=='u') 		return 1; 	return 0; }  int main() { 	char a[501]; 	gets(a); 	int l=strlen(a); 	//cout<<l<<endl; 	for(int i=0; i<l-2; i++) 	{ 		if((isVowel(a[i]))) 			a[i+1] = a[i+2] = 0; 	} 	 	for(int i=0; i<l; i++) 		if(a[i]) 			cout<<a[i]; 	//cout<<endl; 	return 0; }
#include<iostream> #include<cstring> using namespace std ; #define ll long long int int dp[2001][2001] ; int main() {     int i,j,k,n,m,p,t ;     cin >> t ;     char a[100001] ;     char b[100001] ;      while(t--) {         cin >> a ;         cin >> b ;         int k1,k2,k3,k4 ;         int l1 = strlen(a) ;         int l2 = strlen(b) ;         memset(dp,0,sizeof(dp)) ;         for(i=0;i<=l2;i++) dp[i][0] = i ;         for(i=0;i<=l1;i++) dp[0][i] = i ;         for(i=1;i<=l2;i++) {             for(j=1;j<=l1;j++) {                 if(b[i-1] == a[j-1]) {                     k1 = dp[i-1][j-1]  ;                 }                 else k1 = dp[i-1][j-1] + 1 ;                 k2 = dp[i-1][j] + 1 ;                 k3 = dp[i][j-1] + 1 ;                 dp[i][j] = k1<k2?(k1<k3?k1:k3):(k2<k3?k2:k3) ;             }         }         cout << dp[l2][l1] << endl ;     }      return 0 ; } 
#include<iostream> #include<climits> #include<stdio.h> using namespace std; #define N 105  int maxi(int a,int b){ 	return a>b?a:b; }  int cal(int mat[][N],int num){ 	int i,j; 	int** sol = new int*[num]; 	for(i = 0; i <num; ++i)     	sol[i] = new int[num];	 	sol[0][0]=mat[0][0];		 	for(i=1;i<num;i++) 		sol[i][0]=sol[i-1][0]+mat[i][0];	 	for(i=1;i<num;i++) 		sol[0][i]=sol[0][i-1]+mat[0][i]; 	for(i=1;i<num;i++){ 		for(j=1;j<num;j++){ 			sol[i][j]=mat[i][j]+maxi(sol[i-1][j],sol[i][j-1]); 		} 	} 	return sol[num-1][num-1];		 }  int main(){ 	int t; 	cin>>t; 	while(t--){ 		int num,i,j,mat[N][N]; 		float res; 		cin>>num; 		 		for(i=0;i<num;i++) 			for(j=0;j<num;j++) 				cin>>mat[i][j]; 		res=cal(mat,num); 		int k=2*num - 3; 		if(res<0) 			cout<<"No funds\n"; 		else 			printf("%f\n",res/k);				 	} 	return 0; }
#include<bits/stdc++.h>  using namespace std; vector<int> v(100001); int main() { 	int i,x,y,c,j,t,n;	 	for(i=2;i<=100000;i++) 	{ 		if(v[i]==0) 		{ 			v[i]=1; 			for(j=2*i;j<=100000;j=j+i) 			{ 				v[j]++; 			} 		} 	} 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d%d%d",&x,&y,&n); 		c=0; 		for(i=x;i<=y;i++) 		{ 		 			if(v[i]==n) 				c++; 		} 		printf("%d\n",c); 	} 	 	return 0; }
#include<bits/stdc++.h> using namespace std; int main() { 	int t,n,i,j,maxm,uu,vv,save; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d",&n); 		vector<int>v[n];   		for(i=1;i<n;i++) 		{ 			scanf("%d%d",&uu,&vv); 			v[uu-1].push_back(vv-1); 			v[vv-1].push_back(uu-1); 		} 		maxm=-1; 		vector<int>:: iterator it1;   			for(i=0;i<n;i++) 			{ 				vector<int>par(n); 				vector<int>len(n); 				vector<int>vis(n); 				stack<int>s; 				s.push(i); 				vis[i]=2; 				len[i]=0; 				par[0]=0; 				while(!s.empty()) 				{ 					int k=s.top(); 					s.pop(); 					if(vis[k]==2||vis[k]==1) 					{ 						int temp=len[par[k]]+1; 						if(temp>maxm) 						{ 							maxm=temp; 						} 					} 					/*else if(vis[k]==1) 					{                         par[k] 					}*/ 					vector<int>:: iterator it; 					if(vis[*(v[k].begin())]==0) 					{ 						vis[*(v[k].begin())]=1; 						par[*(v[k].begin())]=k; 						len[*(v[k].begin())]=len[k]+1; 						s.push(*(v[k].begin())); 					} 					for(it=v[k].begin()+1;it!=v[k].end();it++) 					{ 						if(vis[*it]==0) 						{ 							vis[*it]=2; 							par[*it]=k; 							len[*it]=len[k]+1; 							s.push(*it); 						} 					} 				} 			} 		cout<<maxm<<endl; 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; typedef long long ll; ll arr[100010]; ll bit[30]; vector<ll>v,vv; int main() { 	ll t,i,n,j; 	scanf("%lld",&t); 	ll ans=0; 	while(t--) 	{ 		v.clear(); 		vv.clear(); 		//cin>>n; 		scanf("%lld",&n); 		for(i=0;i<n;i++) 		{ 			scanf("%lld",&arr[i]); 			//cin>>arr[i]; 			v.push_back(arr[i]); 		} 		ans=0; 		map<ll,ll>mm; 		map<ll,ll>::iterator it; 		mm.clear(); 		ll jj=28; 		while(1) 		{ 			mm.clear(); 			vv.clear(); 		 			for(i=0;i<v.size();i++) 			{ 				for(j=jj;j>=0;j--) 				{ 					if(v[i]&(1<<j)) 					{ 						mm[-j]++; 						 					} 				} 			} 			ll kk;ll flag=0; 			for(it=mm.begin();it!=mm.end();it++) 			{ 				if(it->second>=2) 				{ 					flag=1; 					kk=-(it->first); 					break;			 				} 			} 			if(flag==0) 			{ 				break; 			} 			for(i=0;i<v.size();i++) 			{ 				if(v[i]&(1<<kk)) 				{ 					vv.push_back(v[i]); 				} 			} 			v.clear(); 			v=vv; 			jj=kk-1; 			ans+=(1<<kk); 			//cout<<ans<<endl; 		} 		printf("%lld\n",ans); 	} }
#include<iostream> #include<cstring> using namespace std ; int main() {     int i,j,k,n,p ;     char a[100001] ;     char b[100001] ;     cin >> n ;     int a1[26] ;     int a2[26] ;     while(n--) {         memset(a1,0,sizeof(a1)) ;         memset(a2,0,sizeof(a2)) ;          cin >> a >> b ;         int l1,l2 ;         l1 = strlen(a) ;         l2 = strlen(b) ;         if(l1!=l2) {             cout << "NO\n";             continue ;         }         for(i=0;i<l1;i++) a1[a[i]-'a']++ ;         for(i=0;i<l1;i++) a2[b[i]-'a']++ ;         for(i=0;i<26;i++) if(a1[i] != a2[i]) break ;         if(i == 26) cout << "YES\n" ;         else cout << "NO\n" ;     }     return 0 ; } 
#include<iostream> using namespace std; int main() {     int t;     int n,k; char ch; int i;      cin>>t;     while(t--)     {   int c=0,m=0;         cin>>n>>k;         for(i=0;i<n;i++)         {            cin>>ch;     //       cout<<ch;            if(ch=='#')            {                c++;                if(c>m) m=c;            }            else c=0;          }          if(m>=k) cout<<"NO"<<endl;         else cout<<"YES"<<endl;     } return 0; } 
#include<iostream> using namespace std; int convert(float a) {     if(float(a)==int(a))     {         return a;     }     else return int(a)+1; } int main() {     int t;     cin>>t;     int x,y,z,i; float w;     while(t--)     {         cin>>x>>y>>z;         w=(float(x-y)/float(y))*z;          cout<<convert(w)<<endl;     } return 0; } 
//bfs #include<iostream> #include<cstdio> #include<cstring> #include<algorithm> #include<cmath> #include<queue> using namespace std; #define INF 1000000000 #define MP make_pair int dx[]={0,0,-1,1}; int dy[]={-1,1,0,0}; string st[103]; int mark[102][102][4]; int r,c; queue<pair<pair<int,int>,pair<int,int> > > q; bool valid(int x, int y) { 	if(x<0 || x>=r || y<0 || y>=c) 		return false; 	if(st[x][y]!='*') 		return true; 	return false; } int main() {   std:ios_base::sync_with_stdio(false);   cin>>r>>c;   for(int i=0;i<r;i++)	cin>>st[i];      int fi,fj;   for(int i=0;i<r;i++)   {   	for(int j=0;j<c;j++)   	{  	  	for(int k=0;k<4;k++) 		  mark[i][j][k]=INF; 		       		if(st[i][j]=='H')   		{   			for(int k=0;k<4;k++)   				q.push(MP(MP(i,j),MP(0,k)));   		}   		if(st[i][j]=='L')   		{   			fi=i;   		    fj=j;   		}   	}   }   int ans=INF;   while(!q.empty())   {   	int curx=q.front().first.first;   	int cury=q.front().first.second;   	int turns=q.front().second.first;   	int dir=q.front().second.second;   	q.pop();   	for(int d=0;d<4;d++)   	{   		int nx=curx+dx[d];   		int ny=cury+dy[d];   		int off=0;   		if(d!=dir) off++;   		   		if(valid(nx,ny) && mark[nx][ny][d] > turns+off)   		{   			mark[nx][ny][d]=turns+off;   			q.push(MP(MP(nx,ny),MP(turns+off,d)));   		}   	}   }   for(int k=0;k<4;k++)   ans=min(ans,mark[fi][fj][k]);   printf("%d\n",ans);   return 0; }
#include <iostream> #include<stdio.h> using namespace std; int a[1000]; void solve() {     int n,x,ans=-1,cnt=0;     for(int i=0;i<=500;i++) a[i]=0;     scanf("%d",&n);     for(int i=1;i<=n;i++)     {         scanf("%d",&x);         a[x]++;     }     for(int i=500;i>=0;i--)     {         if(a[i]>cnt)         {             cnt=a[i];             ans=i;         }     }     printf("%d %d\n",ans,cnt); } int main() {    int t;    cin >> t;    for(int i=0;i<t;i++) solve();        return 0; } 
#include<bits/stdc++.h> using namespace std; #define ll long long #define lim 1000003 vector<string>v[lim+1]; #define pb push_back int main() {   ll t;   cin>>t;   string s1,s2;   while(t--)   {     cin>>s1>>s2;     std::transform(s1.begin(), s1.end(), s1.begin(), ::tolower);     std::transform(s2.begin(), s2.end(), s2.begin(), ::tolower);     if(s1<s2)     {     cout<<"first"<<endl;     }     else if(s1>s2)       cout<<"second"<<endl;     else if(s1==s2)       cout<<"equal"<<endl;   } }
#include<bits/stdc++.h> using namespace std; #define ll long long #define lim 1000003 vector<string>v[lim+1]; #define pb push_back int main() {   ll t;   cin>>t;   string s1,s2;   double p,q,r,s;   while(t--)   {   cin>>p>>q>>r>>s;   double den=(q*s)-(q-p)*(s-r);   double num=p*s;   printf("%.5lf",num/den);   cout<<endl; } }
// A C++ program to find maximal Bipartite matching. #include <iostream> #include <string.h> using namespace std;   // M is number of applicants and N is number of jobs   // A DFS based recursive function that returns true if a // matching for vertex u is possible int M , N; bool bpm(bool bpGraph[124][124], int u, bool seen[124], int matchR[124]) {     // Try every job one by one     for (int v = 0; v < N; v++)     {         // If applicant u is interested in job v and v is         // not visited         if (bpGraph[u][v] && !seen[v])         {             seen[v] = true; // Mark v as visited               // If job 'v' is not assigned to an applicant OR             // previously assigned applicant for job v (which is matchR[v])              // has an alternate job available.              // Since v is marked as visited in the above line, matchR[v]              // in the following recursive call will not get job 'v' again             if (matchR[v] < 0 || bpm(bpGraph, matchR[v], seen, matchR))             {                 matchR[v] = u;                 return true;             }         }     }     return false; }   // Returns maximum number of matching from M to N int maxBPM(bool bpGraph[124][124]) {     // An array to keep track of the applicants assigned to     // jobs. The value of matchR[i] is the applicant number     // assigned to job i, the value -1 indicates nobody is     // assigned.     int matchR[124];       // Initially all jobs are available     memset(matchR, -1, sizeof(matchR));       int result = 0; // Count of jobs assigned to applicants     for (int u = 0; u < M; u++)     {         // Mark all jobs as not seen for next applicant.         bool seen[124];         memset(seen, 0, sizeof(seen));           // Find if the applicant 'u' can get a job         if (bpm(bpGraph, u, seen, matchR))             result++;     }     return result; }   // Driver program to test above functions int main() {     // Let us create a bpGraph shown in the above example     int u , v , test;     scanf("%d",&test);      while(test--)     {     scanf("%d %d",&M,&N);     bool bpGraph[124][124];      memset(bpGraph , false , sizeof(bpGraph));     scanf("%d",&u);     while(u!=-1)     {         scanf("%d",&v);         bpGraph[u-1][v-1]  = 1;         scanf("%d",&u);     }     cout << maxBPM(bpGraph) << endl;     }     return 0; }
#include<bits/stdc++.h> #define FOR(i,a,n) for(int i=a;i<n;i++) #define si(x) scanf("%d",&x) #define sll(x) scanf("%lld",&x) #define ss(x) scanf("%s",x) #define pi(x) printf("%d\n",x) #define pll(x) printf("%lld\n",x) #define ps(x) printf("%s\n",x) #define all(x) (x).begin(),(x).end() #define M 1000000007 #define ll long long #define mp make_pair #define all(x) x.begin(),x.end() #define pb push_back #define fr first #define se second using namespace std; int main() {     int n;     si(n);     vector<pair<ll,pair<ll,pair<ll,ll> > > > v;     FOR(i,0,n)     {         int x,y;         si(x),si(y);         ll len=y-x+1;         v.pb(mp(len,mp(i,mp(x,y))));     }     sort(v.begin(),v.end());     int m;     si(m);     set<pair<int,int> > s;     FOR(i,0,m)     {         int x;         si(x);         pair<int,int> yo;         yo.fr=x;         yo.se=i;         s.insert(yo);     }     int ans[100045]={};     FOR(i,0,v.size())     {         set<pair<int,int> >::iterator it=s.lower_bound(mp(v[i].se.se.fr,0));         vector<pair<ll,ll> >te;         while(it!=s.end()&&(it->fr)<=v[i].se.se.se)         {             ans[(it->se)]=v[i].se.fr+1;             te.pb(mp(it->fr,it->se));             it++;         }         FOR(i,0,te.size())         {             s.erase(mp(te[i].fr,te[i].se));         }     }     FOR(i,0,m)         if(!ans[i])             puts("-1");         else             cout<<ans[i]<<"\n";     return 0; } 
#include <iostream> #include <stdio.h> #include <string.h> #include <math.h> #include <vector> #include<stack> #include<set> #include<limits.h> #include <queue> #include <map> #include <cstdlib> #include <algorithm> //psyduck #define ll long long #define S(x) scanf("%d",&x) #define Sf(x) scanf("%f",&x) #define Slf(x) scanf("%lf",&x) #define Sl(x) scanf("%lld",&x) #define P(x)  printf("%d\n", x) #define Pf(x)  printf("%f\n", x) #define Plf(x)  printf("%lf\n", x) #define Pl(x)  printf("%lld\n", x) #define mem(x,i) memset(x,i,sizeof(x)) #define pb push_back #define mod 1000000007 #define INF 1000000000000000008LL using namespace std; ll int solve(ll int n); ll int fun(ll int dig); ll int dp[100]; int main() {      mem(dp,-1);     ll int n;     cin >> n;     ll lo = 1;     ll hi = 1000000000000000000LL;   //  int f = 1;   ll int ans;     while(lo < hi){         ll mid = (lo+hi)/2;         ll int ans = solve(mid);         //cout << mid<<" "<<ans<<endl;         if(ans >= n){             hi = mid;         }         else {             lo = mid+1;         }     }    ans = solve(lo);    if(ans == n){     Pl(lo);    }    else{     cout <<"-1"<<endl;    }     //ll int tmp = fun(1);     //cout << ans; } ll int solve(ll int n) {     ll int rev,num,dig,val,len,j,pwr;     char s[20];      sprintf(s,"%lld",n);     len = strlen(s);     dig = len;     ll ans = 0;     for (int i = 0; i < len; i++){         val = s[i]-48;         for(j = 0; j < val; j++){             ans = ans + fun(dig-1);             if(j == 1){                 ll pwr = 1;                 for (int k = 1; k <= (dig-1); k++){                     pwr = pwr*10;                 }                 ans = ans+pwr;             }         }         if(j == 1){             pwr = 0;             for (int k = i+1; k < len; k++){                 pwr = pwr*10+(s[k]-48);             }             ans = ans+pwr+1;         }         dig = dig-1;     }     return ans; } ll int fun(ll int dig) {     ll int ans = 0;     if(dig == 0){         return 0;     }     if(dp[dig] != -1){         return dp[dig];     }     for(int i = 0; i <= 9; i++){         ans = ans + fun(dig-1);         if(i == 1){            ll pwr = 1;             for (int j = 1; j <= (dig-1); j++){                 pwr = pwr*10;             }             ans = ans+pwr;         }     }     return dp[dig] = ans; } 
#include <iostream> using namespace std ;  int main() { 	int t ; 	cin >> t ; 	while(t --) { 		int n , count = 0 ; 		cin >> n ; 		while(n --) { 			int num ; 			cin >> num ; 			if(num % 7 == 0) 				count ++ ; 		} 		cout << count << endl ; 	} 	return 0 ; }
#include <iostream> #include <vector> #include <algorithm> using namespace std ;  int main() { 	int t ; 	cin >> t ; 	while(t --) { 		int a , b ; 		cin >> a >> b ; 		int n = b - a + 1 ; 		vector<int> v ; 		while(n --) { 			int temp ; 			cin >> temp ; 			v.push_back(temp) ; 		} 		sort(v.begin() , v.end()) ; 		vector<int>::iterator i = v.begin() ; 		for( ; i != v.end() ; i ++) { 			if(*v.begin() != a) { 				cout << a << endl ; 				break ; 			} 			if(*(i + 1) - *(i) >= 2) { 				cout << *i + 1 << endl ; 				break ; 			}  		} 		if(*i != b && i == v.end()) 			cout << b  << endl ; 	}			 	return 0 ; }
#include<stdio.h> #include<iostream> using namespace std; int main() { long long t,a,b,c; scanf("%lld",&t); while(t--) { scanf("%lld%lld%lld",&a,&b,&c); if((b-a)==(c-b))   printf("AP %lld\n",c+(b-a)); else    printf("GP %lld\n",c*(c/b)); } return 0; } 
#include <iostream> using namespace std;   int main() { 	ios::sync_with_stdio(0); 	long int t,a,b; 	cin>>t; 	while(t--) 	{ 		cin>>a>>b; 		int r=b%4,m=1; 		if(r) for(int i=0;i<r;i++) m*=a; 		else m=a*a*a*a; 		cout<<m%10<<endl; 	} 	return 0; }
#include <iostream> #include <cstdio> #include <vector> #include <queue> #include <stack> #include <cassert> #include <cstdlib> #include <cmath> #include <utility> #include <algorithm> #include <map> #include <climits> #include <string> #include <cstring> using namespace std;   typedef long long LL; typedef unsigned long long ULL; typedef vector<int> VI; typedef vector<ULL> VULL; typedef vector<LL> VLL;   #define MX 1000001 #define MN 1001 #define SZ 50 #define REP(i, s, e) for(int i = (s); i <= (e); ++i) #define FOR(i, s, n) for(int i = (s); i < (n); ++i) #define FORALL(i, n) for(int i = 0; i < (n); ++i) #define pushb push_back #define MOD 1000000007   int inline scan() {     int N = 0;     char C;     C = getchar_unlocked();     while (C < '0' || C > '9') C = getchar_unlocked();     while (C >= '0' && C <= '9') {         N = (N<<3) + (N<<1) + C - '0';         C = getchar_unlocked();     }     return N; }    int main() { 	int t = scan(); 	while (t--) { 		int n = scan(); 		int a[n], mx[n], mn[n], count = 0; 		FORALL(i, n) cin >> a[i]; 		mx[0] = a[0]; 		mn[n-1] = a[n-1]; 		FOR(i, 1, n) { 			if (a[i] > mx[i-1]) mx[i] = a[i]; 			else mx[i] = mx[i-1]; 		} 		for(int i = n-2; i >= 0; i--) { 			if (a[i] < mn[i+1]) mn[i] = a[i]; 			else mn[i] = mn[i+1]; 		} 		FORALL(i, n) if (mx[i] == a[i] && mn[i] == a[i]) count++; 		printf ("%d\n", count); 	} 	return 0; }  
// never quit #include<bits/stdc++.h> using namespace std;  # define pb push_back # define mp make_pair # define F first # define S second # define ll long long int  # define f(a,b) for(long long int i = a; i < b; i++) # define MOD 1000000009    // done by self ll powmod(ll a, ll b, ll mod) {     ll x=1,y=a;     while(b>0)     {         if(b%2==1)         {             x=(x*y);             if(x>mod) x%=mod;         }         y=y*y;         if(y>mod) y%=mod;         b/=2;     }     return x;  }    ll mmi(ll a,ll mod) {   return  powmod(a,mod-2,mod); }  int main(int argc, char* argv[]) {     ll t,f[200005];     cin>>t;     f[0]=f[1]=1;     f(2,200002) f[i] =(((f[i-1])%MOD)*((i)%MOD))%MOD;      while(t--)     {         ll ans;      ll n,k,i;      cin>>n>>k;     // cout<<f[n]<<f[k]<<endl;     // cout<<f[n]/(f[n-k]*f[k])<<endl;     ll x= f[k];     ll y=f[n-k]; //cout<<mmi(x*y,MOD);          ans =(f[n]*((mmi(f[k], MOD) * mmi(f[n-k], MOD)) % MOD)) % MOD;      //ans = (((f[n])%MOD) * (mmi(x*y,MOD)%MOD) )%MOD;      cout<<ans<<endl; }} 
#include <iostream> #include <string.h>  using namespace std;  char postfix[100],infix[100];  struct node{   char ele;   node *left, *right; };  node *stack[100]; int top = -1; int top1 =-1; char stk[100];  void push(node *x) {   stack[++top] = x; }  node *pop(){   return stack[top--]; }  void push1(char x) {   stk[++top1] = x; }  char pop1(){   return stk[top1--]; }  int prec( char x)  {   if(x=='^')    return 3;   else if ( x=='/' || x=='*')    return 2;   else if (x=='+' || x=='-')    return 1;   else    return 0;  }  void post(char infix[],int length,int j) {   int i = 0;   char x;   int a,b;   while(i<length)     {       x=infix[i];             if(x>='0' && x<='9') 	postfix[j++] = x;      else if(x== '(')       {push1(x);         }            else if(x ==')')       { 	while(!(top1 == -1) && stk[top1]!='(')         { 	  postfix[j++]=stk[top1];          pop1();         }        pop1();           }      else       {         while(!(top1 == -1))           {             a= prec(stk[top1]);             b= prec(x);            if(a>=b)             {              postfix[j++]=stk[top1];              pop1();             }             else             break;           }         push1(x);        }      i = i+1;     }    while(top1 != -1)       {        postfix[j++]=stk[top1];        pop1();       }      }  void crtree(char *postfix, char temp, int i) {   node *m,*n,*o;   if(temp != '\0')     {       if((temp >= '1')&&(temp <= '9')) 	{ 	  m = new node; 	  m -> ele = temp; 	  m -> left = NULL; 	  m -> right = NULL; 	  push(m); 	  i++; 	}       else { 	n= pop(); 	o= pop(); 	m = new node; 	m -> ele = temp; 	m->left = o; 	m->right = n; 	push(m); 	i++;       }       crtree(postfix,postfix[i],i);     } }  void ino(node *t){   if(t != NULL)     {       if(t->left != NULL) 	cout<<"(";       ino(t->left);       cout<<t->ele;       ino(t->right);       if(t->right != NULL) 	cout<<")";     } }  int main(){   // cout<<"Enter the expression: ";   cin>>infix;   int l = strlen(infix);   post(infix,l,0);   // cout<<postfix;   crtree(postfix,postfix[0],0);   ino(stack[0]);   cout<<endl;    return 0; } 
#include <iostream>  using namespace std;  long long int gcd(long long int q,long long int p) {     if(p==0)     return q;     else if (q==0)     return p;     else     if(p>=q)     {         if(p%q==0)         return q;         else return gcd(q,p%q);     }     else if(q>p)     {         if(q%p==0)         return p;         else return gcd(p,q%p);     }  } int main() {     int t;     long long int n;     cin>>t;     while(t--)     {         cin>>n;         long long int a[n];         for(long long int i=0;i<n;++i)         {             cin>>a[i];         }         long long int x = gcd(a[0],a[1]);         for(long long int i=2;i<n;++i)         {             x=gcd(x,a[i]);         }         cout<<x<<"\n";     }     return 0; } 
#include <bits/stdc++.h>  using namespace std;  char op_reverse(char op) {     if(op=='+')          return '-';     else if(op=='-')         return '+';     else if(op=='*')          return '/';     else if(op=='/')          return '*'; }  float calc(long long int num,long long int num2,char op) {     if(op=='+')          return num+num2;     else if(op=='-')         return num-num2;     else if(op=='*')          return num*num2;     else if(op=='/')          return (float)num/num2; }  int isop(char c) {     switch(c)     {         case '+': return 1; break;         case '-' : return 1; break;         case '*' : return 1 ;         case '/' : return 1;          default : return 0;             } }  int main() {     int test;     cin>>test;     string str;      getline(cin,str);     while(test--)     {          getline(cin,str);         int n=str.length();         int op_flag=0;         int equals=0;         char op;         string num(1,str[0]);         string num2,num3;         for(int i=1;i<n;i++)         {         	if(str[i]==' ')         	    continue;             if(equals==0 && str[i]=='=')             {                 equals++;             }             else if(op_flag==0 && isop(str[i]) )             {                 op_flag=1;                 op=str[i];             }             else if(op_flag==0)             {                 num=num+str[i];             }             else if(op_flag==1 && equals==0)             {                 num2=num2+str[i];             }             else                num3=num3+str[i];         }         if(num=="x" || num=="-x")         {             long long int n2=atoi(num2.c_str());             long long int n3=atoi(num3.c_str());          if(num=="x")             printf("%.6f\n",calc(n3,n2,op_reverse(op)));          else             printf("%.6f\n",-calc(n3,n2,op_reverse(op)));         }         else if(num2=="x" || num2=="-x")         {             long long int n=atoi(num.c_str());             long long int n3=atoi(num3.c_str());          if(num2=="x")          {             if(op=='/' || op=='-')                printf("%.6f\n",calc(n,n3,op));                             else                printf("%.6f\n",calc(n3,n,op_reverse(op)));          }          else          {          	    if(op=='/' || op=='-')                printf("%.6f\n",-calc(n,n3,'-'));             else               printf("%.6f\n",-calc(n3,n,op_reverse(op)));           }         }         else         {             long long int n=atoi(num.c_str());             long long int n2=atoi(num2.c_str());          if(num3=="x")             printf("%.6f\n",calc(n,n2,op));           else             printf("%.6f\n",-calc(n,n2,op));         }     }     return 0; } 
    #include<stdio.h>     #include<stack>     #include<map>     #include<vector>     #include<math.h>     using namespace std;     vector <long long int> ve[200];     long long int f[200];     void dfs(long long int u)     {     //dfs function implements dfs algorithm on the graph and find out tree edges ,cross edges and back edges     long long int i,si;     f[u]=1;     si=ve[u].size();     for(i=0;i<si;i++)     {     //finding out tree edges     if(f[ve[u][i]]==0)     {     dfs(ve[u][i]);     }     }     }     long long int df(long long int n)     {     long long int co=0;     long long i,j;     for(i=0;i<n;i++)     {     if(f[i]==0)     {     ++co;     dfs(i);     }     }     return co;     }     int main()     {     long long int t,n,d,st,en,w,c,x[200],y[200],z[200],di,i,j,count;      //freopen("cook.txt","r",stdin);     scanf("%lld",&t);     while(t--)     {     for(i=0;i<=200;i++)     f[i]=0;     for(i=0;i<=200;i++)     ve[i].clear();     scanf("%lld%lld",&n,&d);     for(i=0;i<n;i++)     {     scanf("%lld%lld%lld",&x[i],&y[i],&z[i]);     }     if(n>1)     {     for(i=0;i<n;i++)     {     for(j=i+1;j<n;j++)     {     di=pow(x[j]-x[i],2)+(pow(y[j]-y[i],2))+(pow(z[j]-z[i],2));     if(di<=(1.0*d*d))     {       ve[i].push_back(j);       ve[j].push_back(i);     }     }     }     count=df(n);     }     else     count=1;     printf("%lld\n",count);     }     return 0;     }  
#include <stdio.h> #include <algorithm> using namespace std;   typedef long long LL;   LL a[100]; LL b[100];   int main(int argc, char* argv[]) {     int h, i, j, t, n;     scanf("%d", &t);     for(h=0;h<t;h++)     {         scanf("%d", &n);         for(i=0;i<n;i++)         {             scanf("%lld", &a[i]);         }         sort(a,a+n);         int start=0, cnt=0;         while(1)         {             LL acc=a[start];             bool got_it=false;             int nextstart=0;             for(i=start+1;i<n;i++)             {                 if(a[i]>acc)                 {                     nextstart=i;                     got_it=true;                     break;                 }                 acc+=a[i];             }             b[cnt++]=acc/a[start];             if(got_it==false)             {                 break;             }             start=nextstart;         }         LL ans=1;         for(i=0;i<cnt;i++)         {             ans*=b[i]+1;         }         printf("%lld\n", ans);     }     return 0; }  
#include<bits/stdc++.h> using namespace std; typedef long long ll; typedef vector<int> vi; typedef pair<int,int> pii; typedef pair<ll,ll> pll; typedef vector<pii> vpii; typedef unsigned long long llu;  #define debug(x) cerr<<#x<<" "<<x<<endl; #define f first #define s second #define mp make_pair #define pb push_back int G[25][25]; void do_it_here() { set<int> A;     for(int i=1;i<=21;i++)         G[1][i]=G[i][1]=1;     for(int i=2;i<=21;i++)     {         for(int j=2;j<=21;j++)         {             for(int x=1;x<=i;x++)             {                 for(int y=1;y<=j;y++)                 {                     int h;                     h=G[x-1][y-1]^ G[x-1][j-y] ^G[i-x][y-1] ^G[i-x][j-y];                     A.insert(h);                 }             }             int start=0;             while(1)             {                 if(A.count(start)==0)                 {G[i][j]=start; break;}                 else                     start++;             }             A.clear();             }         }     } int main() {     int t,n,m;     do_it_here();     scanf("%d",&t);     while(t--)     {         scanf("%d %d",&n,&m);         if(G[n][m])             printf("Alice\n");         else             printf("Bob\n");      }     return 0; } 
#include <cstdio> #include <cmath> #include <iostream> #include <algorithm> #include <vector> #include <map> #include <set> #include <stack> #include <queue> #include <utility> //pair #include <cstdlib> #include <cstring> #include <string> #include <climits> #include <unistd.h> #include <sys/types.h> #define MOD 1000000007 #define MAX 102 typedef long long int ll; using namespace std;  int man_list[MAX][MAX],woman_list[MAX][MAX],preference[MAX][MAX],n; int man_hasto_propose[MAX]; int man_engaged_to[MAX],woman_engaged_to[MAX];  void stable_matching() { stack<int> free; int m1,m,w,h=0,c=0,index;    for(int i=1;i<=n;i++)      {        free.push(i);        man_hasto_propose[i]=1;        woman_engaged_to[i]=man_engaged_to[i]=0;      }        while(!free.empty())         {           m=free.top();           index =man_hasto_propose[m];           man_hasto_propose[m]+=1;           w=man_list[m][index];            if(woman_engaged_to[w]==0)            {               woman_engaged_to[w]=m;               man_engaged_to[m]=w;               free.pop();               continue;            }              else              {                m1=woman_engaged_to[w];                if(preference[w][m]>preference[w][m1])                {                  free.pop();                  woman_engaged_to[w]=m;                  man_engaged_to[m]=w;                  free.push(m1);                }              }         }         for(int i=1;i<=n;i++)         {             if(man_list[i][1]==man_engaged_to[i])                 h++;             if(woman_list[man_engaged_to[i]][1]==i)                 c++;         }         printf("%d %d\n",c,h); }  int main() {     int t;     scanf("%d",&t);     while(t--)     {       scanf("%d",&n);       for(int i=1;i<=n;i++)       {           int priority = 200;           for(int j=1;j<=n;j++)           {              scanf("%d",&woman_list[i][j]);              preference[i][woman_list[i][j]]= priority;              priority--;           }       }       for(int i=1;i<=n;i++)           for(int j=1;j<=n;j++)              scanf("%d",&man_list[i][j]);        stable_matching();     }     return 0; } 
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <sstream> #include <climits> #include <cctype> #include <cassert> #include <iterator> #include <complex> //#include<bits/stdc++.h> using namespace std; #define ull unsigned long long #define ll long long int #define pii pair<int,int> #define pb push_back #define mp make_pair #define F(i,a,n) for(int i=(a);i<(n);++i) #define FF(i,a,n) for(i=(a);i<(n);++i) #define REP(i,a,n) for(i=(a);i<=(n);++i) #define V(x) vector<x> #define Sd(x) scanf("%d",&x) #define Sl(x) scanf("%lld",&x) #define M(x,i) memset(x,i,sizeof(x)) #define all(c) c.begin(), c.end() #define present_mapset(c,x) ((c).find(x) != (c).end()) #define cpresent_vector(c,x) (find(all(c),x) != (c).end()) #define repVector(v)  for( typeof(v.begin()) it = v.begin(); it != v.end(); it++ ) #define repSet(s) for( typeof(s.begin()) it = s.begin(); it != s.end(); it++ ) #define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl #define matrix vector< vector<ll> > #define F1 first #define S2 second #define Lf 2*r #define Rg 2*r+1 //vector< vector<int> >Matrix(N, vector<int>(M,0)); #define gc getchar_unlocked #define MAXNN 1000001 #define mod 1000000007 inline void inputfile() { #ifndef ONLINE_JUDGE     freopen("input.in","r",stdin); #endif } inline void cpp_input() {ios_base::sync_with_stdio(false);     cin.tie(NULL);} void scanint(int &x) {     register int c = gc();     x = 0;     int neg = 0;     for(;((c<48 || c>57) && c != '-');c = gc());     if(c=='-') {neg=1;c=gc();}     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}     if(neg) x=-x; } void scanintll(long long int &x) {     register int c = gc();     x = 0;     int neg = 0;     for(;((c<48 || c>57) && c != '-');c = gc());     if(c=='-') {neg=1;c=gc();}     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}     if(neg) x=-x; }   string mass[10] = { "Dhaval", "Shivang", "Bhardwaj", "Rishab", "Maji", "Gaurav", "Dhruv", "Nikhil", "Rohan", "Ketan" }; int arr[10]; #define INF 1000000000 int main() {     //freopen("INPUT.TXT", "r", stdin);     for(int i = 0; i < 10; scanf("%d", &arr[i]), ++i);     for(int q = 0; q < 5; ++ q) {         int mmax = -INF;         string name = "";         int index = -1;         for(int i = 0; i < 10; ++i) {             if(arr[i] > mmax && arr[i] != 0) {                 mmax = arr[i];                 name = mass[i];                 index = i;             }         }         if(index != -1) {             arr[index] = 0;             cout << name << endl;         }         int mmin = INF;         name = "";         index = -1;         for(int i = 0; i < 10; ++i) {             if(arr[i] < mmin && arr[i] != 0) {                 mmin = arr[i];                 name = mass[i];                 index = i;             }         }         if(index != -1) {             arr[index] = 0;             cout << name << endl;         }     }     return 0; }
#include<iostream> #include<cstring> using namespace std;  #define MAX 1000000  typedef long int ll;  ll tree[4*MAX][27]={0}; char str[MAX+1]; int cnt=0;  void build_tree(int start, int end, ll idx) { 	if(start==end) 	{ 	//	cout<<idx<<endl; 		int num= str[start]-97; 		tree[idx][num]++; 		return; 	} 	int mid= (start+end)/2; 	build_tree(start,mid,1+2*idx); 	build_tree(mid+1,end,2+2*idx); //	cout<<idx<<endl; 	for(int i=0;i<26;i++) 	 tree[idx][i]= tree[2*idx+1][i] + tree[2*idx+2][i]; 	  }  int query(int ss, int se, int qs, int qe, ll idx, char ele) { 	if(ss>=qs && se<=qe) 	 { 	 	//cout<<ss<<" "<<se<<" "<<qs<<" "<<qe<<endl; 	 	return tree[idx][ele-97]; 	 } 	  	if(ss>qe || se<qs) 	return 0; 	  	int mid= (ss+se)/2; 	int p= query(ss,mid,qs,qe,1+2*idx,ele)+ query(mid+1,se,qs,qe,2+2*idx,ele); //	cout<<" for segment : "<<ss<<" "<<se<<" "<<p<<endl; 	return p; }  int main() { 	cin>>str; 	int len=strlen(str); 	 	build_tree(0,len-1,0); 	int i,j; 	/* 	for(i=0;i<7;i++) 	{ 		for(j=0;j<26;j++) 		{ 			if(tree[i][j]!=0) 			{ 				//cout<<i<<" : "<<(char)(j+97)<<" "<<tree[i][j]<<endl; 			} 		} 	} 	*/ 	int low, high,que; 	cin>>que; 	while(que--){ 	char k; 	cin>>k>>low>>high; 	low--; 	high--; 	cout<<query(0,len-1,low,high,0,k)<<endl; 	} 	return 0; }
#include<bits/stdc++.h> #define intMAX 1123456789LL #define MAX intMAX * intMAX #define F first #define S second #define mp make_pair #define ll long long #define pb push_back #define pv(v,b,a) v.insert(v.begin()+b,a) #define all(c) c.begin(),c.end() #define sf(a) scanf("%d",&a); #define sl(a) scanf("%lld",&a); #define MAXCR 1000000000 #define mem(arr,a) memset(arr, a, sizeof arr) #define er(vec,a,b) vec.erase(vec.begin() + a, vec.begin() + b+1) #define traverse(a) for() #define pii pair<int ,int> #define mod 1000000007 #define LIM 100 using namespace std; /* list as stack=pop_front();push_front(ELEMENT); list as queue=pop_front();push_back(ELEMENT); to see first element q.front() to see last element q.back() */ //str.find("live");//finds first occurance of string and returns its 0 based indes //string str1=str.substr (a,n);//a=0 based start index,b=length of words//if length not given substring till end is formed //auto bound_=upper_bound (v.begin(), v.end(), 20); //Returns an iterator pointing to the first element in the range [first,last) which compares greater than val. //auto bound_=lower_bound (v.begin(), v.end(), 20);//Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val. //for(???<???>:iterator itr;itr!=???.end();itr++)  int main() { 	ll i,k,idx1,j,idx2,k1,dpmax[105][105],l,dpmin[105][105]; 	string s; 	sl(k1) 	while(k1--) 	{ 		cin>>s; 		ll num[105]={0},sign[105]={0},sum=0; 		idx1=1; 		idx2=1; 		for(i=0;i<s.length();i++) 		{ 			if(s[i]=='*') 			{ 				sign[idx2]=1; 				idx2++; 				num[idx1]=sum; 				idx1++; 				sum=0; 			} 			else if(s[i]=='+') 			{ 				idx2++; 				num[idx1]=sum; 				idx1++; 				sum=0; 			} 			else 			{ 				sum=sum*10+s[i]-48; 			} 		} 		num[idx1]=sum; 		for(i=1;i<=idx1;i++) 		{ 			dpmin[i][i]=num[i]; 			dpmax[i][i]=num[i]; 		} 		for(k=1;k<idx1;k++) 		{ 			for(i=1;i<=idx1-k;i++) 			{ 				j=i+k; 				dpmin[i][j]=MAX; 				dpmax[i][j]=0; 				for(l=i;l<j;l++) 				{ 					if(sign[l]==1) 					{ 						dpmax[i][j]=max(dpmax[i][j],dpmax[i][l]*dpmax[l+1][j]); 						dpmin[i][j]=min(dpmin[i][j],dpmin[i][l]*dpmin[l+1][j]); 					} 					else 					{ 						dpmax[i][j]=max(dpmax[i][j],dpmax[i][l]+dpmax[l+1][j]); 						dpmin[i][j]=min(dpmin[i][j],dpmin[i][l]+dpmin[l+1][j]); 					} 				} 			} 		} 		printf("%lld\n",dpmax[1][idx1]-dpmin[1][idx1]); 	} 	return 0; } /* 4 23*0+4+5+6*6+3 23+3+3+3 23*23+33*4*2*0+4 1+1*0 */
#include <bits/stdc++.h> using namespace std; #define ull unsigned long long #define ll long long int #define pii pair<int,int> #define pb push_back #define mp make_pair #define F(i,a,n) for(int i=(a);i<(n);++i) #define FF(i,a,n) for(i=(a);i<(n);++i) #define REP(i,a,n) for(i=(a);i<=(n);++i) #define V(x) vector<x> #define Sd(x) scanf("%d",&x) #define Sl(x) scanf("%lld",&x) #define M(x,i) memset(x,i,sizeof(x)) #define all(c) c.begin(), c.end() #define present_mapset(c,x) ((c).find(x) != (c).end()) #define cpresent_vector(c,x) (find(all(c),x) != (c).end()) #define repVector(v)  for( typeof(v.begin()) it = v.begin(); it != v.end(); it++ ) #define repSet(s) for( typeof(s.begin()) it = s.begin(); it != s.end(); it++ ) #define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl #define matrix vector< vector<ll> > #define F1 first #define S2 second #define Lf 2*r #define Rg 2*r+1 //vector< vector<int> >Matrix(N, vector<int>(M,0)); #define gc getchar_unlocked #define MAXNN 1000100 #define mod 1000000007  inline void inputfile() { #ifndef ONLINE_JUDGE     freopen("input.in","r",stdin); #endif } inline void cpp_input() {ios_base::sync_with_stdio(false);     cin.tie(NULL);} template <typename T> void scanint(T &x) {     register int c = gc();     x = 0;     int neg = 0;     for(;((c<48 || c>57) && c != '-');c = gc());     if(c=='-') {neg=1;c=gc();}     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}     if(neg) x=-x; } ll dp[MAXNN]; int main() {     inputfile();     cpp_input();     dp[1]=1;     dp[2]=dp[3]=2;     dp[4]=3;     dp[5]=4;     dp[6]=5;     F(i,7,1000001)     {         dp[i]=(dp[i-2]+dp[i-3])%mod;     }     int t;     scanint(t);     while(t--)     {      int n;      scanint(n);      printf("%lld\n",dp[n]);     }     return 0; } 
#include "stdio.h" #include "stdlib.h" #include <vector>  int n,s,f; std::vector<int> *adjl; bool *visited; int temp_max=0;  void dfs(int i) { 	visited[i] = true; 	temp_max += 1; 	for(std::vector<int>::iterator it = adjl[i].begin(); it != adjl[i].end(); it++) 	{ 		if(visited[*it]==false) dfs(*it); 	} 	return; }   int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		int temp1,temp2; 		scanf("%d%d%d",&n,&s,&f); 		adjl = new std::vector<int> [n]; 		visited = new bool [n]; 		for(int index=0;index<f;index++) 		{ 			scanf("%d%d",&temp1,&temp2); 			adjl[temp1-1].push_back(temp2-1); 			adjl[temp2-1].push_back(temp1-1); 		} 		 		for(int index=0;index<n;index++) visited[index] = false; 		temp_max = 0; 		dfs(s-1); 		int result = 0; 		for(int index=0;index<n;index++) 		{ 			if(visited[index]==false) 			{ 				temp_max = 0; 				dfs(index); 				if(temp_max > result) result = temp_max; 			} 		}		 		 		printf("%d\n",result); 	}  	return 0; }
#include <iostream> #include <cstdio> #include <cstring> #include <algorithm>  using namespace std;  int a[102],skill[102],dis[102],N;  int f(int first, int idx) {     if ( idx+dis[idx]+1 >= N ) return 0;     int ans = 0;          for ( int i = idx+dis[idx]+1; i <= N-1; i++ ) {         if ( i+dis[i] > N-1 ) {              int p = i+dis[i]-N;              if ( p >= first ) continue;         }         ans = max(ans, skill[i] + f(first,i));     }     return ans; }  int main() {     int t,i,ans;     cin >> t;     while ( t-- ) {           cin >> N;               for ( i = 0; i < N; i++ ) cin >> skill[i];           for ( i = 0; i < N; i++ ) cin >> dis[i];           ans = 0;           for ( i = 0; i < N; i++ ) {               ans = max(ans, skill[i] + f(i,i));           }           cout << ans << endl;     }     return 0; } 
#include<stdio.h>  typedef unsigned long int L;  int main() {   int t;   L x,i,a,b,c,min;   const L maxn=1000010;   L arr[maxn];      arr[1]=1;   arr[2]=2;   arr[3]=2;      for(i=4;i<=maxn;i++)   {      min=100000000;      if(i%2==0)        min=arr[i/2];      if(i%3==0)        min=min<=arr[i/3]?min:arr[i/3];            min=min<=arr[i-1]?min:arr[i-1];            arr[i]=min+1;   }      scanf("%d",&t);      while(t--)   {     scanf("%lu",&x);          printf("%lu\n",arr[x]);   }      return 0; }
  //#define DEBUG       //comment when you have to disable all debug macros. #define NDEBUG    //comment when all assert statements have to be disabled. #include <iostream> #include <cstring> #include <sstream> #include <cstdlib> #include <cstdio> #include <cmath> #include <vector> #include <set> #include <map> #include <bitset> #include <climits> #include <ctime> #include <algorithm> #include <functional> #include <stack> #include <queue> #include <list> #include <deque> #include <sys/time.h> #include <iomanip> #include <cstdarg> #include <utility> //std::pair #include <cassert> #define tr(c,i) for(typeof(c.begin()) i = (c).begin(); i != (c).end(); i++)  #define present(c,x) ((c).find(x) != (c).end())  #define all(x) x.begin(), x.end() #define pb push_back #define mp make_pair #define log2(x) (log(x)/log(2)) #define ARRAY_SIZE(arr) (1[&arr]-arr)       #define INDEX(arr,elem)        (lower_bound(all(arr),elem)-arr.begin()) #define lld long long int #define MOD 1000000007 #define gcd __gcd #define equals(a,b) (a.compareTo(b)==0)    //for strings only using namespace std;   #ifdef DEBUG #define debug(args...)            {dbg,args; cerr<<endl;} #else #define debug(args...)              // Just strip off all debug tokens #endif  struct debugger { 	template<typename T> debugger& operator , (const T& v) 		{     			cerr<<v<<" ";     			return *this;     		}  }dbg;  /**********************************MAIN CODE***************************************************/  //runs in O(VE^2) time. //might consider using a 1-d array of size V*V for large values of V  vector<vector<lld> > flow, capacity, copy_flow; //vector<vector<bool> > aug_path; lld V; vector<lld> *adj;   void init(lld v) { 	/*aug_path.resize(v+1); 	for(lld i=1;i<=v;i++) 	{ 		aug_path[i].resize(v+1); 		for(lld j=1;j<=v;j++) 			aug_path[i][j]=false; 			}*/ 	adj=new vector<lld>[v+1]; 	V=v; 	flow.resize(V+1); 	capacity.resize(V+1); 	copy_flow.resize(V+1); 	for(lld i=0;i<=V;i++) 		flow[i].resize(V+1), capacity[i].resize(V+1), copy_flow[i].resize(V+1); }  void add_edge(lld u, lld v, lld uv, lld vu=0) { 	capacity[u][v]=uv; 	capacity[v][u]=vu; 	adj[u].push_back(v); 	flow[u][v]=uv; 	flow[v][u]=vu; 	if(vu) adj[v].push_back(u); }  /*if there is an augmentation path, it returns true and modifies the graph(flow matrix) creating residual graph. Operates only on one edge, need to be called several times.  If no augmentation path exists, returns false.*/ bool augmentation(lld source, lld destination)    { 	bool visited[V+1]; 	lld parent[V+1], t; 	memset(visited, false, sizeof(visited)); 	memset(parent, -1, sizeof(parent)); 	queue<lld> state; 	state.push(source); 	visited[source]=true; 	parent[source]=-2; 	while(!state.empty()) 	{ 		t=state.front(); 		state.pop(); 		for(vector<lld>::iterator it=adj[t].begin(); it!=adj[t].end(); it++) 		{ 			if(!visited[*it] && flow[t][*it]) 			{ 				state.push(*it); 				parent[*it]=t; 				visited[*it]=true; 				if(*it==destination) 					goto augmentation_present; 			} 		} 	} 	return false; augmentation_present: 	//firstly calculate the residual capacity 	lld i=destination; 	lld aug=LLONG_MAX; //residual capacity of the given path 	while(parent[i]!=-2) 	{ 		//aug_path[parent[i]][i]=true; 		aug=min(aug,flow[parent[i]][i]); 		i=parent[i]; 	} 	i=destination; 	while(parent[i]!=-2) 	{ 		flow[parent[i]][i]-=aug; 		flow[i][parent[i]]=capacity[parent[i]][i]-flow[parent[i]][i]; 		debug("1:",flow[parent[i]][i],"2:",flow[i][parent[i]], aug); 		i=parent[i]; 	} 	 	return true; }  lld maximum_flow(lld source, lld destination) { 	while(augmentation(source, destination)); 	lld max_flow=0; 	for(vector<lld>::iterator it=adj[source].begin(); it!=adj[source].end(); it++) 	{		max_flow+=flow[*it][source]; debug("yeah!", flow[*it][source]);} 	debug(max_flow); 	return max_flow; }   template<class T> inline void inputInt(T &n ) { 	n=0;  	T ch=getchar_unlocked();   	while( ch < '0' || ch > '9' )       ch=getchar_unlocked();    	while(  ch >= '0' && ch <= '9' )        n = (n<<3)+(n<<1) + ch-'0', ch=getchar_unlocked(); }  int main() { 	lld n,e,u,v,c,i,j,E; 	 	inputInt(n); 	inputInt(e); 	 	init(n); 	E=e; 	while(e--) 	{ 		inputInt(u); 		inputInt(v); 		inputInt(c); 		add_edge(u,v,c); 	} 	lld flow_val=maximum_flow(1,n), count=0; 	copy_flow=flow; 	for(i=1;i<=n;i++) 	{ 		for(vector<lld>::iterator it=adj[i].begin(); it!=adj[i].end();it++) 		{ 			capacity[i][*it]+=1000; 			flow[i][*it]+=1000; 			if(flow_val!=maximum_flow(1,n)) 				count++; 			flow=copy_flow; 			capacity[i][*it]-=1000; 			//flow[i][*it]-=1000; 		} 	} 	 	printf("%lld\n", E-count); 	 } 
#include <bits/stdc++.h> using namespace std;  int main() {     int  t;cin>>t;     while(t--){         int n;cin>>n;         int A[n];         int i,j;         for(i=0;i<n;i++)             scanf("%d",&A[i]);                      int diff[n];         diff[0]=0;         for(i=1;i<n;i++)         diff[i]=A[i]-A[i-1];                  int dp[n];         dp[0]=0;         for(i=0;i<n;i++)         dp[i]=max(dp[i-1]+diff[i],diff[i]);                  int profit=0;         for(i=0;i<n;i++)             if(profit<dp[i])             profit=dp[i];                      cout<<profit<<endl;                 } } 
#include<bits/stdc++.h> using namespace std; typedef long long int ll; int main() { ll t,n,k,n1,val1,i,rem,val2,a[1000],j,temp; cin>>t; while(t--) {     cin>>n>>k;     val1=n*k;     i=0;     n1=n;     rem=0;     while(n1)     {         if(n1%10==k)         {         a[i++]=((n1%10)+k+rem)%10;         rem=((n1%10)+k+rem)/10;         }         else if(n1%10!=k)         {             a[i++]=((n1%10)*k+rem)%10;             rem=((n1%10)*k+rem)/10;         }         n1=n1/10;     }     a[i++]=rem;     val2=0;     for(j=i-1;j>=0;j--)     {         val2=val2*10+a[j];     }     cout<<val1+val2<<endl;  } return 0; } 
#include<iostream> #include<cstdio> #include<cmath> using namespace std; int main() {         long long int last,i,j,k,m,n,t,sum,diff;         scanf("%lld",&t);         for(i=0;i<t;i++)         {                 scanf("%lld%lld",&n,&k);                 if(n-k==0)                         printf("%lld\n",k);                 else                 {                         diff=(n-k)/2;                         last=k+diff*2;                         sum=(diff+1)*(k+last)/2;                         printf("%lld\n",sum);                 }         } } 
#include <bits/stdc++.h> using namespace std; int main() { 	string tn,nn; 	int t,n,q; 	//cin>>t; 	//while(t--) { 		map<string,string> mp; 		cin>>n>>q; 		while(n--) { 			cin>>tn>>nn; 			mp[nn]=tn; 		} 		while(q--) { 			cin>>nn; 			if(mp.find(nn)== mp.end()) 				cout<<"Name not found\n"; 			else 				cout<<mp[nn]<<endl; 		} 	//}  }
#include <iostream> #include <algorithm> #include <vector> #include <cmath>  using namespace std;  struct Point {     long long x, y;     bool operator <(const Point &p) const {         return x < p.x || (x == p.x && y < p.y);     } };  long long cross(const Point &O, const Point &A, const Point &B) {     return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x); }  vector <Point> convex_hull(vector <Point> P) {      int n = P.size(), k = 0;     vector<Point> H(2*n);      sort(P.begin(), P.end());      for(int i = 0; i<n; i++) {         while (k >= 2 && cross(H[k-2], H[k-1], P[i]) <= 0) k--;         H[k++] = P[i];     }      for(int i=n-2, t=k+1; i>=0; i--) {         while (k >= t && cross(H[k-2], H[k-1], P[i]) <= 0) k--;         H[k++] = P[i];     }      H.resize(k-1);     return H; }  long double dist(Point p1, Point p2) { 	return sqrt(1.0*(p1.x - p2.x)*(p1.x - p2.x)+1.0*(p1.y - p2.y)*(p1.y - p2.y)); }  long long abs_(long long a) { 	if(a < 0) return -a; 	return a; }  int main() { 	int T; 	cin >> T; 	while(T--) { 		int n; 		cin >> n; 		long long t1, t2; 		if(n == 1) { 			cin >> t1 >> t2; 			cout << 0 << " " << 0 << endl; 			continue; 		} 		vector <Point> p(n); 		for(int i=0; i<n; i++) { 			cin >> t1 >> t2; 			p[i].x = t1; 			p[i].y = t2; 		} 		vector <Point> convex = convex_hull(p); 		long long A = 0; 		long double P = 0; 		for(int i=0; i<convex.size()-1; i++) { 			P += dist(convex[i], convex[i+1]); 		} 		P += dist(convex[0], convex[convex.size()-1]); 		for(int i=1; i<convex.size()-1; i++) A += abs_(cross(convex[0], convex[i], convex[i+1])); 		A /= 2; 		cout << floor(P) << " " << A << endl; 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; int main() { int t,i;  long long int value,sum ,n;  long long int mod=1000000007 ;  cin>>t;  while(t--)  {      cin>>n;      sum=0;     value=7;  for(i=0;i<n;i++)  {      sum=sum+value;      sum=sum%mod;      value=value*10 +7;      value=value%mod;      }      cout<<sum<<endl;  }     return 0; }
#include <bits/stdc++.h> using namespace std; int main() { 	int t,i; 	cin>>t; 	while(t--) { 		stack<int> ss; 		string exp; 		cin>>exp; 		for(i=0;i<exp.size();i++) { 			if(i==0 && (exp[i]==')'||exp[i]=='}'||exp[i]==']')) { 				cout<<"no\n";break; 			}  		 if(exp[i]==')'||exp[i]=='}'||exp[i]==']') { 		 	char ch=exp[i]; 				if((ch==')'&& ss.top()=='(') || (ch=='}'&& ss.top()=='{')|| (ch==']'&& ss.top()=='['))  					ss.pop(); 				else { 					cout<<"no\n"; break; 				} 			}  			else if(exp[i]=='('||exp[i]=='{'||exp[i]=='[') 				ss.push(exp[i]); 		}  		if(ss.empty() and i!=0) 			cout<<"yes\n"; 	} 	return 0; }
#include <bits/stdc++.h> #include <stdio.h>  using namespace std;  unsigned long long f[25]; char ans[26];  int changer (int n) { 	int i = 25; 	unsigned long long k = f[n]; 	while (k > 0) { 		unsigned long long r = k%10; 		ans[i] = '0' + r; 		i--; 		k = k/10; 	} 	return i+1; }  void precompute () { 	f[1] = 0; 	f[2] = 1; 	for (int i = 3 ; i <= 22 ; i++) 	{ 		f[i] = f[i-1]*(i-1); 		f[i] += f[i-2]*(i-2); 	} }  int main () { 	precompute (); 	int t; 	scanf ("%d",&t); 	while (t--) 	{ 		int k,n,count = 0; 		scanf ("%d %d",&k,&n); 		if (k == 0 && n == 1) { 			printf ("%d\n",1); 			continue; 		} 		else if (k < 10) 		{ 			for (int i = changer (n) ; i <= 25 ; i++) 				if (ans[i] == '0' + k) count++; 		} 		else if (k == 100) 		{ 			for (int i = changer (n) + 2 ; i <= 25 ; i++) { 				if (ans[i] == '0' && ans[i-1] == '0' && ans[i-2] == '1') 					count++; 			} 		} 		else { 			for (int i = changer(n) + 1 ; i <= 25 ; i++) { 				if (ans[i] == '0' + k%10 && ans[i-1] == '0' + (k/10)%10) 					count++; 			} 		} 		printf ("%d\n",count); 	}  	return 0; } 
    # include<bits/stdc++.h>     # define LL long long int           using namespace std;           int main(void)     {     	LL T , N , K;     	for (cin>>T;T--;)     	{     		cin>>N>>K;     		if (K > N-K)     		        K = N-K;     		LL ans = 1LL,num=1LL,den=1LL;     		for (int i=0;i<K;i++)     		{     				ans *= ((N-i));     				ans /= (i+1);     		}     		cout<<ans<<endl;     	}     	return (0);     } 
#include <bits/stdc++.h> using namespace std; int main() {     int i,j,k=0,c,b,f;     string a;     while(1)     {         f=1;         getline(cin,a);         if(a[0]=='/'&&a[1]=='/') break;         j=a.length();         for(c=0;c<j;c++)         {             if(a[c]=='i'&&a[c+1]=='f')             {                 //cout<<"1"<<endl;                 f=0;                 break;             }             if(a[c]=='w'&&a[c+1]=='h'&&a[c+2]=='i'&&a[c+3]=='l'&&a[c+4]=='e')             {                  //cout<<"2"<<endl;                 f=0;                 break;             }             if(a[c]=='f'&&a[c+1]=='o'&&a[c+2]=='r')             {                  //cout<<"3"<<endl;                 f=0;                 break;             }             if(a[c]=='e'&&a[c+1]=='l'&&a[c+2]=='s'&&a[c+3]=='e')             {                  //cout<<"4"<<endl;                 f=0;                 break;             }             if(a[c]=='{')                 {                      //cout<<"5"<<endl;                     f=0;                     break;                 }             if(a[c]=='}')             {                  //cout<<"6"<<endl;                 f=0;                 break;             }             if(a[0]=='#')             {                  //cout<<"7"<<endl;                 f=0;                 break;             }             if(a[c]=='('&&a[c+1]==')')             {                  //cout<<"8"<<endl;                 f=0;                 break;             }             if(a[c]==';')             {                 //cout<<"9"<<endl;                 f=0;                 break;             }             if(a[c]=='('&&a[c+1]!='"')             {                 f=0;                 break;             }         }         if(f==1) k++;     }     printf("%d",k);     return 0; } 
#include <bits/stdc++.h> using namespace std; vector<int> visited(1000,0); vector<int>vec[1000]; int n; int dfs(int s) { 	stack<int> S; 	S.push(s); 	visited[s]=1; 	int no=1; 	while(!S.empty()) { 		s=S.top();S.pop(); 		for(int i=0;i<vec[s].size();i++) { 			if(visited[vec[s][i]]!=1) { 				visited[vec[s][i]]=1; 				S.push(vec[s][i]); no++; 			} 		} 	} 	return no; } int main() { 	int n,x,y,cnt=0; 	cin>>n; 	vector<int> v; 	for(int i=1;i<=n;i++) { 		cin>>x>>y;x--;y--; 		vec[x].push_back(y);vec[y].push_back(x); 	} 	for(int i=0;i<n;i++) {  		if(visited[i]!=1) { 			int no=dfs(i); 			v.push_back(no); 			cnt++; 		} 	} 	cout<<cnt<<endl; 	sort(v.begin(),v.end()); 	for(int i=0;i<v.size();i++) 		cout<<v[i]<<" "; 	cout<<endl; 	 }
#include <bits/stdc++.h> using namespace std; int main() { 	int t,i,temp; 	cin>>t; 	getchar(); 	while(t--) { 		string s; 		getline(cin,s);  		for(i=0;i<s.size();i++) { 			if(s[i]>='a' and s[i]<='z') { 				int k=s[i]-'a'; 				cout<<k*k;				 			} 			if(s[i]==' ') { 				cout<<"$"; 				continue; 			} 			if(s[i+1]>='a'and s[i+1]<='z') 				cout<<"-"; 		} 		cout<<endl; 		}	  		return 0; }
using namespace std; #include<iostream> #include<bits/stdc++.h> #define z 833333  long long int s; int main() {    long int m,n,k,x;    int j,t;    std::ios_base::sync_with_stdio(false); vector<bool> a(5000000/6), b(5000000/6);     for(j=1;j<373;++j)        {            k=6*j;            for(x=k*j-2*j;x<= z ;x+=k-1)                        b[x]=1;            for(x=k*j;x<= z ;x+=k+1)                a[x]=1;            for(x=k*j;x<= z ;x+=k-1)                a[x]=1;             for(x=k*j+2*j;x<= z ;x+=k+1)                b[x]=1;            }    cin>>t;    for(j=0;j<t;++j)    {        cin>>m>>n;        s=0;k=n/6;        for(x=m/6+1;x<=k;++x)         {             if(a[x]==0){                 s+=6*x-1;             }             if(b[x]==0){                 s+=6*x+1;             }         }         if(m<=2)s+=5;         else if (m==3)s+=3;         else if(m%6==0&&b[m/6]==0)s+=m+1;         else if(m%6==1&&b[m/6]==0)s+=m;         if(n==2)s=2;         else if(n==1)s=0;         else if((n%6==0)&&b[n/6]==0)s-=n+1;         else if(n%6==5&&a[n/6+1]==0)s+=n;         cout<<s<<endl;      } }  
#include<bits/stdc++.h> using namespace std; int main() { string  str; int t,c; cin>>t; while(t--) {      c=0; cin>>str; for(int i=0;i<str.size();i++) { if(str[i]=='a' || str[i]=='e' ||str[i]=='i' ||str[i]=='o' ||str[i]=='u' ) c++; else if(str[i]=='A' || str[i]=='E' ||str[i]=='I' ||str[i]=='O' ||str[i]=='U' ) c++; } if(c==0) cout<<"no"<<endl; else cout<<"yes"<<endl; } }  
#include <bits/stdc++.h> #define ll long long int using namespace std;  ll arr[1000005];  int main(){  	int t; 	ll n;  	arr[0] = 0; 	for(ll i=1;i<=1000005;i++)arr[i] = arr[i-1] + (i*i);  	cin>>t;  	while(t--){ 		cin>>n; 		int p = sqrt(n); 		cout<<arr[p]<<endl; 	}  	//system("pause"); 	return 0; }
#include <bits/stdc++.h> #define ll long long using namespace std;  vector<int> V;  int main(){  	int t; 	ll n;  	cin>>t; 	while(t--){ 		V.clear(); 		bool ok = true; 		int factor = 9; 		cin>>n; 		ll orignal = n; 		while(n!=1){ 			if(factor == 1){ 				ok = false; 				break; 			} 			if(n%factor == 0){ 				V.push_back(factor); 				n/=factor; 			} 			else factor --; 		} 		if(ok){ 			sort(V.begin(), V.end()); 			if(orignal==1){ 				cout<<11<<endl;; 				continue; 			} 			if(orignal<10)	cout<<1; 			for(int i=0;i<(int)V.size();i++)	cout<<V[i]; 			cout<<endl; 		} 		else cout<<-1<<endl; 	}  	//system("pause"); 	return 0; }
#include<iostream> #include<string> #include<vector> using namespace std; string removeOcc(string s,string x){    int k=x.size();    int n=s.size();    vector<int> v;    for(int i=0;i<n-k+1;i++){      string t=s.substr(i,k);      if(t==x){        v.push_back(i);      }    }    string ans="";    for(int j=0;j<n;j++){      int poss=1;      for(int i=0;i<v.size();i++){            if(j>=v[i] && j<=v[i]+k-1){              poss=0;              break;            }      }      if(poss) ans.push_back(s[j]);    }    return ans; } int main(){  int t;  cin>>t;  string s,x,tmp;  for(int i=0;i<t;i++){     cin>>s;     cin>>x;     tmp=removeOcc(s,x);     if(tmp.size()==0) cout<<0<<endl;     else cout<<tmp<<endl;  }  return 0; }
#include <iostream> #include <vector> #include <algorithm>  using namespace std; typedef unsigned long long ull;	  int main(){ 	int t; 	cin>>t; 	std::vector<ull> v(1000001); 	ull temp1,temp2,x; 	v[1]=0; 	v[2]=1; 	v[3]=1; 	for (int i = 4; i < 1000001; ++i) 	{ 		v[i]=(v[i-2]+v[i-3])%1000000009; 	} 	while(t--){ 		cin>>x; 		cout<<v[x]<<endl; 	} } 
#include<iostream> #include<cmath> #include<set> #include<vector> #include<list> #include<map> #include<algorithm>   using namespace std; #define FOR(i,a,b) for(int i=a;i<b;i++)     #ifndef ONLINE_JUDGE #include <time.h> #endif   #define SIZE 10 char S[SIZE][SIZE]; int D[SIZE][SIZE];   #define X first #define Y second   int  ccw(pair<double,double> A,pair<double,double> B,pair<double,double> C){ 	return (C.Y-A.Y)*(B.X-A.X) > (B.Y-A.Y)*(C.X-A.X); }   int main(){ #ifndef ONLINE_JUDGE 	freopen("input.txt","r",stdin); 	clock_t start = clock(); #endif   	int T; 	scanf("%d\n",&T); 	FOR(tT,0,T){ 		pair<double,double> B,C,D,E; 		cin>>B.first>>B.second>>C.first>>C.second>>D.first>>D.second>>E.first>>E.second; 		double Den=(B.X-C.X)*(D.Y-E.Y) - (B.Y-C.Y)*(D.X-E.X); 		if(Den==0)printf("no\n"); 		else{   			if( ccw(B,D,E) != ccw(C,D,E) && ccw(B,C,D) != ccw(B,C,E) )printf("yes\n"); 			else printf("no\n"); 		} 	}     #ifndef ONLINE_JUDGE	 	printf("Time elapsed: %f\n", ((double)clock() - start) / CLOCKS_PER_SEC); #endif 	return 0; }  
#include<iostream> #include<cstdio> #include<cmath> using namespace std;  int main(void) { int T; long long int num; long long ans; scanf("%d",&T); while(T--) { scanf("%lld",&num); if(num == 2)  printf("15\n"); else { ans = pow(num,num+1LL); ans = ans -num + 1LL; printf("%lld\n",ans); } } return 0; }
#include<iostream> #include<string> #include<cstdio>   using namespace std;   int main(void) { int T; int res; int len,i; string input; scanf("%d",&T);   while(T--) {   cin>>input;   len = input.length();     for(i=0;i<len;i++)   {       if(input[i] == '1')     {        res = 100  + 10 * (input[i+1]-'0') +  (input[i+2]-'0');        i= i+2;     }     else     {        res = 10 * (input[i]-'0') + (input[i+1]-'0');        i++;     }     printf("%c",(char)res);   }   printf("\n"); } }
#include <iostream> #include <map> #include <iomanip> #include <cstdio> #include <vector> #include <string>   using namespace std;   string func(string s) {                    string s1;                    int t = 0;                    while ( s[t] != '$' ) {                            s1.push_back(s[t]);                            t++;                    }                    return s1; }   float num(string s) {                float n = 0;                int i = 0,j;                while ( s[i] != '$' ) i++;                for ( j = i+1; j < s.size(); j++ ) n = n*10 + s[j]-48;                return n; }   int main() {     string s1,s2,s3;     int i,k,j;     float l;           map <string,string> m;          for ( ;; ) {              cin >> s1;              if ( s1 == "000000" ) break;              cin >> s2;              m[s1] = s2;     }     s2.clear();     for ( ;; ) {              cin >> s1;              if ( s1 == "#" ) break;              scanf("%d", &k);              cout << s1 << " ";              i = 0;                            if ( s1[0] != '0' ) {                         cout << "Local " << s1 << " " << k << " 0.00 0.00" << endl;                         goto p;              }                            while ( m[s3] == "" && i < s1.size() ) {                      s3.push_back(s1[i]);                      i++;              }              if ( m[s3] == "" ) {                         cout << "Unknown " << k << " -1.00" << endl;                         goto p;              }                                       for ( j = i; j < s1.size(); j++ ) s2.push_back(s1[j]);              l = num(m[s3]);              l = (float)(l)/(float)(100);              cout << func(m[s3]) << " " << s2 << " " << k << " ";              cout << fixed << setprecision(2) << l << " " << (float)(l*k) << endl;              p: { }              s3.clear();              s2.clear();     }          return 0; }           
/* This solution is dedicated to Karl-Theodor zu Guttenberg */  #include <algorithm> #include <cassert> #include <cmath> #include <cstdio> #include <vector>  using namespace std;  const double pi=acos(-1);  struct Point { double angle; int type; Point(double a, int b) : angle(a), type(b) {} bool operator<(const Point &b) const { return angle < b.angle; } };  int num[2], accum[3]; vector<Point> v;  bool valid_cut(int i, int j) { for (int k=0; k<2; ++k)         if(accum[k]<num[k]/2||accum[k]>num[k]/2+1||accum[k]==num[k]/2+1&&v[i].type!=k&&v[j].type!=k) return false; return true; }  main() { int caper, pepper, n; while(scanf("%i%i",&caper,&pepper)==2&&(caper>=0||pepper>=0))         {         n=caper+pepper;         v.clear();         num[0]=num[1]=0;         for(int i=0; i<n; ++i)                  {                  double x, y;                  scanf("%lf%lf",&x,&y);                  double ang=atan2(y,x)/pi;                  if(ang<0) ang+=2;                  int type=i<caper;                  ++num[type];                  v.push_back(Point(ang,type));                  v.push_back(Point(fmod(ang+1,2.0),2));                  }         bool possible=v.empty();         if(!possible)                  {                  sort(v.begin(),v.end());                  accum[0]=accum[1]=0;                  for(int j=0; j<=n; ++j)                           ++accum[v[j].type];                  for(int i=0, j=n; !possible; ++i,++j)                           {                           possible=valid_cut(i,j);                           if(i==n-1) break;                           --accum[v[i].type];                           ++accum[v[j+1].type];                           }                  }         puts(possible?"YES":"NO");         } return 0; } 
#include<iostream> using namespace std; int main() { 	long long int c=1,d=1,temp,sum=0,sum2=0,m=1000000007; 	int t,a,b,i; 	cin>>t; 	while(t--) 	{ 		cin>>a>>b; 		for(i=1;i<=b;i++) 		{ 			if(i==1||i==2) 			sum=1; 			else 			{			 				sum=(c%m+d%m)%m; 				c=d; 				d=sum; 			} 			if(i>=a) 			{ 				sum2=sum2+sum; 			} 		} 		sum2=sum2%m; 		cout<<sum2<<"\n"; 		c=1; 		d=1; 		sum=0; 		sum2=0; 	} 	return 0; }
#include<stdio.h> #include<iostream> #include<math.h> #include<algorithm> using namespace std; int main() { long long t,n,i,s; cin>>t; while(t--) {     s=0;     cin>>n;     long long a[n],b[n];     for(i=0;i<n;i++)          cin>>a[i];     for(i=0;i<n;i++)         cin>>b[i];     sort(a,a+n);     sort(b,b+n);     for(i=0;i<n;i++)         s=s+a[i]*b[i];     cout<<s<<endl; } return 0; } 
#include<stdio.h> int main() {     int t,z,n,i,pos,j;     unsigned long long count,max;     scanf("%d",&t);     while(t--)     {         scanf("%d%d",&n,&z);         unsigned long long a[n];          for(i=0;i<n;i++) scanf("%llu",&a[i]);         pos=0;count=a[0];         for(i=1;i<z;i++) count=count^a[i];         max=count;         count=count^a[0];         //printf("%llu \n",count);         for(i=z;i<n;i++)         {             count=count^a[i];             if(count<=max)             {                 max=count;                 pos=i-z+1;             }             //printf("%llu \n",count);             count=count^a[i-z+1];         }         printf("%d\n",pos+1);     }     return 0; } 
#include<bits/stdc++.h> using namespace std;   #define lli long long #define pb push_back #define mod 1000000007 const int limit = 100005; lli st[limit];   void pre(){ 	st[1]=3; 	st[2]=9; 	st[3]=26; 	for(int i=4;i<limit;i++){ 		st[i] = ( (3*st[i-1])-(st[i-3]) )%mod; 	} }   int main(){ 	int t,n; 	pre(); 	scanf("%d",&t); 	while(t--){ 		cin>>n; 		cout<<st[n]<<"\n"; 	} 	 } 
//Coder: Vipin Singh #include<bits/stdc++.h> using namespace std;  #define lli long long #define pb push_back  int arr[]={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47};  void solve(int n,lli l,lli r){ 	vector<int> val; 	for(int i=0;i<15;i++){ 		if(arr[i] <= n) 			val.pb(arr[i]); 	} 	int sz = val.size(); 	int upto = 1<<sz; 	lli ans = 0; 	for(int i=1;i<upto;i++){ 		lli m = 1; 		int len = 0; 		for(int j=0;j<sz;j++){ 			if( i & (1<<j) ){ 				m *= val[j]; 				len++; 			} 		} 		lli t1 = l/m; 		lli t2 = r/m; 		lli tmp = t2-t1; 		if(l%m == 0) 			tmp++; 		if(len&1){ 			ans += tmp; 		} 		else{ 			ans -= tmp; 		} 	} 	cout<<ans<<"\n"; }  int main(){ 	int t,n; 	lli l , r; 	scanf("%d",&t); 	while(t--){ 		cin>>n>>l>>r; 		solve(n,l,r); 	} 	 } 
    #include <bits/stdc++.h>           using namespace std;           int b[100], c[100][9];     int n;     int a[100], sum = 0;     bool flag;     list<int> answer;           void recursion(int index){     if(index == n){     flag = true;     return;     }           int temp, l;     for(int i=0 ; i<b[index] ; i++){     temp = c[index][i];     if(a[temp-1]>0){     a[temp-1]--;     } else {     continue;     }     recursion(index+1);     a[temp-1]++;     l = temp;     if(flag){     break;     }     }     if(flag){     answer.push_back(l);     return;     }     }           int main(){     flag = false;     cin>>n;           for(int i=0 ; i<9 ; i++){     cin>>a[i];     sum += a[i];     }           if(n>sum){     cout<<"It seems MSG"<<endl;     return 0;     }           for(int i=0 ; i<n ; i++){     cin>>b[i];     for(int k=0 ; k<b[i] ; k++){     cin>>c[i][k];     }     sort(c[i], c[i] + b[i]);     }           recursion(0);           if(!flag){     cout<<"It seems MSG"<<endl;     return 0;     }           while(!answer.empty()){     cout<<answer.back()<<" ";     answer.pop_back();     }           return 0;     }  
#include<cstdio> #define MOD 1000000007 using namespace std;  int main() {     int t;     scanf("%d",&t);     while(t--)     {         long long a,b;         scanf("%lld%lld",&a,&b);         long long res=(((a%MOD)*(b%MOD))%MOD-a%MOD-b%MOD)%MOD;         printf("%lld\n",res);     } } 
/* Author : RISHAV GOYAL */  #include <bits/stdc++.h>  using namespace std;  #define LL long long int #define UL unsigned long long int  #define imax INT_MAX #define imin INT_MIN #define LLmax LLONG_MAX #define LLmin LLONG_MIN  #define FOR(i,a,b) for(int i= (int)a; i<= (int)b; i++) #define rep(i,n) for(int i= int(1); i<= (int)n; i++) #define FORd(i,a,b,d) for(int i=(int)a; i<= (int)b; i+=(int)d)  #define pr() printf("Reached here 1...\n"); #define pr1() printf("Reached here 2...\n"); #define gc getchar_unlocked  #define si(a) scanf("%d",&a); #define sl(a) scanf("%lld",&a); #define ss(a) scanf("%s",a); #define sc(a) scanf("%c",&a); #define su(a) scanf("%llu",&a);  #define pi(a) printf("%d\n",a); #define pl(a) printf("%lld\n",a); #define ps(a) printf("%s\n",a); #define pu(a) printf("%llu\n",a);  #define arg(a,N) rep(i,N)si(a[i]);  #define CLR(a) memset(a,0,sizeof(a)); #define SET(a) memset(a,-1,sizeof(a));  #define str strlen #define pb(x) push_back(x) #define mp make_pair #define ii pair<int,int> #define ll pair<LL,LL> #define F first #define S second #define gcd(a,b) __gcd(a,b)  #define mod int(1e9 +7) #define MAX int(1e5 + 10)  #define VI vector<int> #define VL vector<LL> #define VS vector<string> #define VC vector<char>   int gcd ( int a, int b ){int c;while(a!= 0){c=a;a=b%a;b=c;}return b;} LL powmod(LL a,int b,int n){LL rm=1;while (b){if (b % 2) { rm = (rm * a) % n; }a = (a * a) % n;b /= 2;}return rm;}  void sint(int &x) { 	register int c = gc(); 	x = 0; 	for(;(c<48 || c>57);c = gc()); 	for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} }  void sll(LL &x) { 	register LL c = gc(); 	x = 0; 	for(;(c<48 || c>57);c = gc()); 	for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} }  int main() { 	LL n; 	cin >> n; 	LL pw = 1,fac=1; 	for(int i=1;i<=n;++i) pw = (pw * (LL)3)% mod ; 	for(LL i=1;i<=n;++i) fac = (fac  *i) % mod; 	cout << (pw + fac - n + mod) % mod; 	return 0; } 
/* Author : RISHAV GOYAL */  #include <bits/stdc++.h>  using namespace std;  #define LL long long int #define UL unsigned long long int  #define imax INT_MAX #define imin INT_MIN #define LLmax LLONG_MAX #define LLmin LLONG_MIN  #define FOR(i,a,b) for(int i= (int)a; i<= (int)b; i++) #define rep(i,n) for(int i= int(1); i<= (int)n; i++) #define FORd(i,a,b,d) for(int i=(int)a; i<= (int)b; i+=(int)d)  #define pr() printf("Reached here 1...\n"); #define pr1() printf("Reached here 2...\n"); #define gc getchar_unlocked  #define si(a) scanf("%d",&a); #define sl(a) scanf("%lld",&a); #define ss(a) scanf("%s",a); #define sc(a) scanf("%c",&a); #define su(a) scanf("%llu",&a);  #define pi(a) printf("%d\n",a); #define pl(a) printf("%lld\n",a); #define ps(a) printf("%s\n",a); #define pu(a) printf("%llu\n",a);  #define arg(a,N) rep(i,N)si(a[i]);  #define CLR(a) memset(a,0,sizeof(a)); #define SET(a) memset(a,-1,sizeof(a));  #define str strlen #define pb(x) push_back(x) #define mp make_pair #define ii pair<int,int> #define ll pair<LL,LL> #define F first #define S second #define gcd(a,b) __gcd(a,b)  #define mod int(1e9 +7) #define MAX int(1e5 + 10)  #define VI vector<int> #define VL vector<LL> #define VS vector<string> #define VC vector<char>   int gcd ( int a, int b ){int c;while(a!= 0){c=a;a=b%a;b=c;}return b;} LL powmod(LL a,int b,int n){LL rm=1;while (b){if (b % 2) { rm = (rm * a) % n; }a = (a * a) % n;b /= 2;}return rm;}  void sint(int &x) { 	register int c = gc(); 	x = 0; 	for(;(c<48 || c>57);c = gc()); 	for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} }  void sll(LL &x) { 	register LL c = gc(); 	x = 0; 	for(;(c<48 || c>57);c = gc()); 	for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} }  int main() { 	int t,n,a[MAX],k; 	cin >> t; 	while ( t--){ 		cin >> n >> k; 		int mx = 0; 		rep(i,k) {cin >>a[i]; mx = max(mx , a[i]);} 		LL fac = 1; 		for(LL i=1;i<=n;++i){ 			fac = (fac * i) % mx; 		} 		cout<<fac<<endl; 	} 	return 0; } 
/* Author : RISHAV GOYAL */  #include <bits/stdc++.h>  using namespace std;  #define LL long long int #define UL unsigned long long int  #define imax INT_MAX #define imin INT_MIN #define LLmax LLONG_MAX #define LLmin LLONG_MIN  #define FOR(i,a,b) for(int i= (int)a; i<= (int)b; i++) #define rep(i,n) for(int i= int(1); i<= (int)n; i++) #define FORd(i,a,b,d) for(int i=(int)a; i<= (int)b; i+=(int)d)  #define pr() printf("Reached here 1...\n"); #define pr1() printf("Reached here 2...\n"); #define gc getchar_unlocked  #define si(a) scanf("%d",&a); #define sl(a) scanf("%lld",&a); #define ss(a) scanf("%s",a); #define sc(a) scanf("%c",&a); #define su(a) scanf("%llu",&a);  #define pi(a) printf("%d\n",a); #define pl(a) printf("%lld\n",a); #define ps(a) printf("%s\n",a); #define pu(a) printf("%llu\n",a);  #define arg(a,N) rep(i,N)si(a[i]);  #define CLR(a) memset(a,0,sizeof(a)); #define SET(a) memset(a,-1,sizeof(a));  #define str strlen #define pb(x) push_back(x) #define mp make_pair #define ii pair<int,int> #define ll pair<LL,LL> #define F first #define S second #define gcd(a,b) __gcd(a,b)  #define mod int(1e9 +7) #define MAX int(1e5 + 10)  #define VI vector<int> #define VL vector<LL> #define VS vector<string> #define VC vector<char>   int gcd ( int a, int b ){int c;while(a!= 0){c=a;a=b%a;b=c;}return b;} LL powmod(LL a,int b,int n){LL rm=1;while (b){if (b % 2) { rm = (rm * a) % n; }a = (a * a) % n;b /= 2;}return rm;}  void sint(int &x) { 	register int c = gc(); 	x = 0; 	for(;(c<48 || c>57);c = gc()); 	for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} }  void sll(LL &x) { 	register LL c = gc(); 	x = 0; 	for(;(c<48 || c>57);c = gc()); 	for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} }  int main() { 	int t; 	char ch,s[MAX];  	cin >> t; 	 	while(t--){		 		scanf("%c",&ch); 		scanf("%[^\n]",s); 		int n = str(s); 		for(int i=0;i<n;++i) if(s[i]<'0' || s[i]>'9') printf("%c", s[i]); 		printf("\n"); 	} 	return 0; }
/* Author : RISHAV GOYAL */  #include <bits/stdc++.h>  using namespace std;  #define LL long long int #define UL unsigned long long int  #define imax INT_MAX #define imin INT_MIN #define LLmax LLONG_MAX #define LLmin LLONG_MIN  #define FOR(i,a,b) for(int i= (int)a; i<= (int)b; i++) #define rep(i,n) for(int i= int(1); i<= (int)n; i++) #define FORd(i,a,b,d) for(int i=(int)a; i<= (int)b; i+=(int)d)  #define pr() printf("Reached here 1...\n"); #define pr1() printf("Reached here 2...\n"); #define gc getchar_unlocked  #define si(a) scanf("%d",&a); #define sl(a) scanf("%lld",&a); #define ss(a) scanf("%s",a); #define sc(a) scanf("%c",&a); #define su(a) scanf("%llu",&a);  #define pi(a) printf("%d\n",a); #define pl(a) printf("%lld\n",a); #define ps(a) printf("%s\n",a); #define pu(a) printf("%llu\n",a);  #define arg(a,N) rep(i,N)si(a[i]);  #define CLR(a) memset(a,0,sizeof(a)); #define SET(a) memset(a,-1,sizeof(a));  #define str strlen #define pb(x) push_back(x) #define mp make_pair #define ii pair<int,int> #define ll pair<LL,LL> #define F first #define S second #define gcd(a,b) __gcd(a,b)  #define mod int(1e9 +7) #define MAX int(1e5 + 10)  #define VI vector<int> #define VL vector<LL> #define VS vector<string> #define VC vector<char>   int gcd ( int a, int b ){int c;while(a!= 0){c=a;a=b%a;b=c;}return b;} LL powmod(LL a,int b,int n){LL rm=1;while (b){if (b % 2) { rm = (rm * a) % n; }a = (a * a) % n;b /= 2;}return rm;}  void sint(int &x) { 	register int c = gc(); 	x = 0; 	for(;(c<48 || c>57);c = gc()); 	for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} }  void sll(LL &x) { 	register LL c = gc(); 	x = 0; 	for(;(c<48 || c>57);c = gc()); 	for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} }  int main() { 	int k,n,s[MAX]; 	std::map<int,int> Hash; 	cin >> k; 	while(k--){ 		cin >> n; 		int ans = 0; 		rep(i,n) {sint(s[i]); Hash[s[i]]= 1;} 		rep(i,n){ if(Hash[s[i]]){Hash[s[i]] = 0; ans++;} } 		cout<<ans<<endl; 	} 	return 0; } 
    #include<iostream>     using namespace std;           int graph[22][22]={0};     int visit[22]={0};           long int max_path=0;           void find_max(int src, int n,long int dist)     {     	max_path= max(max_path,dist);     	     	if(visit[src])     	 return;     	     	visit[src]=1;     	     	for(int i=1;i<=n;i++)     	{     		if(graph[src][i]!=0 && visit[i]!=1)     		{     			find_max(i,n,dist+graph[src][i]);     		}     	}     }           int main()     {     	int n;     	cin>>n;     	int a,b,d,i,j;     	     	for(i=0;i<=n;i++)     	{     		visit[i]=0;     		for(j=0;j<=n;j++)     		{     			graph[i][j]=0;     		}     	}     	     	long int sum=0;     	     	for(i=1;i<n;i++)     	{     		cin>>a>>b>>d;     		graph[a][b]=d;     		graph[b][a]=d;     		sum+= (2*d);     	}     	     	     	find_max(1,n,0);     	     	cout<<sum-max_path<<endl;     	     	return 0;     } 
#include<iostream> #include<algorithm> using namespace std; int main() { ios_base::sync_with_stdio(false); int t; cin>>t; while(t--) { int n; cin>>n; int a[n]; for(int i=0;i<n;i++) cin>>a[i]; sort(a,a+n); if(a[0]>1) { cout<<"1"<<endl; continue; } long long int ans=a[0]; for(int i=1;i<n;i++) { if(a[i]-1>ans) break; ans=ans+a[i]; } cout<<ans+1<<endl; } return 0; } 
/* Author : RISHAV GOYAL */  #include <bits/stdc++.h>  using namespace std;  #define LL long long int #define UL unsigned long long int  #define imax INT_MAX #define imin INT_MIN #define LLmax LLONG_MAX #define LLmin LLONG_MIN  #define FOR(i,a,b) for(int i= (int)a; i<= (int)b; i++) #define rep(i,n) for(int i= int(1); i<= (int)n; i++) #define FORd(i,a,b,d) for(int i=(int)a; i<= (int)b; i+=(int)d)  #define pr() printf("Reached here 1...\n"); #define pr1() printf("Reached here 2...\n"); #define gc getchar_unlocked  #define si(a) scanf("%d",&a); #define sl(a) scanf("%lld",&a); #define ss(a) scanf("%s",a); #define sc(a) scanf("%c",&a); #define su(a) scanf("%llu",&a);  #define pi(a) printf("%d\n",a); #define pl(a) printf("%lld\n",a); #define ps(a) printf("%s\n",a); #define pu(a) printf("%llu\n",a);  #define arg(a,N) rep(i,N)si(a[i]);  #define CLR(a) memset(a,0,sizeof(a)); #define SET(a) memset(a,-1,sizeof(a));  #define str strlen #define pb(x) push_back(x) #define mp make_pair #define ii pair<int,int> #define ll pair<LL,LL> #define F first #define S second #define gcd(a,b) __gcd(a,b)  #define mod int(1e9 +7) #define MAX int(1e5 + 10)  #define VI vector<int> #define VL vector<LL> #define VS vector<string> #define VC vector<char>   int gcd ( int a, int b ){int c;while(a!= 0){c=a;a=b%a;b=c;}return b;} LL powmod(LL a,int b,int n){LL rm=1;while (b){if (b % 2) { rm = (rm * a) % n; }a = (a * a) % n;b /= 2;}return rm;}  void sint(int &x) { 	register int c = gc(); 	x = 0; 	for(;(c<48 || c>57);c = gc()); 	for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} }  void sll(LL &x) { 	register LL c = gc(); 	x = 0; 	for(;(c<48 || c>57);c = gc()); 	for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} }  int a[MAX]; VI b; LL seg[4 * MAX][2]={0};  void update(int n,int it,int f,int q1,ll add){ 	if(q1 == it){ 		seg[n][0] += add.F; 		seg[n][1] += add.S; 		return ; 	} 	int m =(it+f)/2; 	if(q1>m) update(2*n+1,m+1,f,q1,add); 	else if(q1<=m){ 		update(n*2,it,m,q1,add); 		update(n*2+1,m+1,f,m+1,add); 	} }  ll query(int n,int it,int f,int q){ 	if( it == f){ 		return mp(seg[n][0], seg[n][1]); 	} 	int m =(it+f)/2; 	ll tmp; 	if( q<=m) tmp = query(n*2,it,m,q); 	else tmp = query(n*2+1,m+1,f,q); 	tmp.F += seg[n][0]; 	tmp.S += seg[n][1]; 	return tmp; }  int main() { 	int n; 	cin >> n; 	b.pb(0); 	rep(i,n) {si(a[i]); b.pb(a[i]);} 	reverse(a+1,a+n+1); 	sort(b.begin()+1,b.end()); 	int t = 1; 	for(int i=2;i<=n;++i) if(b[i] != b[i-1]) b[++t] = b[i]; 	b.resize(t+1);  	LL fans = 0; 	int ind; 	for(int i=1;i<=n;++i){ 		ind = lower_bound(b.begin()+1,b.end(),a[i]) - b.begin(); 		ll ans = query(1,1,t,ind); 		fans += ans.S; 		update(1,1,t,ind+1,mp((LL)1,ans.F)); 	} 	cout<<fans<<endl; 	return 0;  } 
#include <iostream> #include <cmath> using namespace std; long long int cal(long long int a,long long int b,char op) { 	switch(op) 	{ 		case '/': 			return floor(double(a)/b); 		case '*': 			return a*b; 		case '+': 			return a+b; 		case '-': 			return a-b; 	} } int main() { 	char *op,c[5] = {'/','*','+','-'}; 	long long int t,*arr,i,j,start,n; 	cin >> t; 	while(t--) 	{ 		cin >> n; 		arr = new long long int[n]; 		op = new char[n-1]; 		for(i=0;i<n;i++) 			cin >> arr[i]; 		start = 0; 		for(i=0;i<n-1;) 		{  			for(j=start;j<start+4;j++) 			{ 				op[i++] = c[j%4]; 			} 			start++; 			start = start%4; 		} 		for(i=1;i<n;i++) 		{ 			arr[i] = cal(arr[i-1],arr[i],op[i-1]); 		} 		cout << arr[i-1] << "\n"; 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; long long arr[1000005];  int main() {     int t,n,q;     cin>>t;     while(t--)     {         cin>>n;         cin>>q;         int i;         double temp;         for(i=0;i<n;i++)         {             scanf("%lf",&temp);             arr[i]=temp*100000000;         }         sort(arr,arr+n);         //for(i=0;i<n;i++)           //  cout<<arr[i]<<" ";         cout<<endl;         while(q--)         {             long long  num;             scanf("%lf",&temp);             num=temp*100000000;             int x=upper_bound(arr,arr+n,num)-arr;             cout<<n-x<<endl;         }     } } 
#include<bits/stdc++.h> using namespace std; #define ll long long ll dp[1000002]; int main() {     int t,i;     cin>>t;     dp[1]=1;     dp[2]=2;     dp[3]=2;     dp[4]=4;     for(i=5;i<=1000000;i++)     {         if(i%2==0)         {             dp[i]=2*dp[i/2];         }         else         {             if(dp[1+i/2]==1)                 dp[i]=i;             else             {                 dp[i]=2*(dp[1+i/2]-1);             }         }     }   //  for(i=1;i<=14;i++)         //cout<<dp[i]<<" ";         int n;         while(t--)         {             cin>>n;             cout<<dp[n]<<endl;         } } 
#include<stdio.h> int min(int a,int b,int c) {     int temp=a;      if(temp>b)     temp=b;      if(temp>c)     temp=c;      return temp; } char arr[1005][1005]; int a[1005][1005]={0},b[1005][1005]={0}; int main() {      int n,m,l,r,k,q,maxm,maxf;     char g;      scanf("%d %d %d",&l,&r,&q);      for(int i=0;i<l;i++)     {         scanf("%s",arr[i]);     }      for(int i=0;i<l;i++)     {         if(arr[0][i]=='M')         {             a[0][i]=1;             b[0][i]=0;         }          else         {             a[0][i]=0;             b[0][i]=1;         }     }      for(int i=0;i<l;i++)     {         if(arr[i][0]=='M')         {             a[i][0]=1;             b[i][0]=0;         }          else         {             a[i][0]=0;             b[i][0]=1;         }     }      maxm=a[0][0];     maxf=b[0][0];      for(int i=1;i<l;i++)     {         for(int j=1;j<r;j++)         {             if(arr[i][j]=='M')             {                 b[i][j]=0;                 a[i][j]=min(a[i][j-1],a[i-1][j],a[i-1][j-1])+1;             }              else             {                 a[i][j]=0;                 b[i][j]=min(b[i][j-1],b[i-1][j],b[i-1][j-1])+1;             }              if(a[i][j]>maxm)             maxm=a[i][j];              if(b[i][j]>maxf)             maxf=b[i][j];         }     }      /*for(int i=0;i<l;i++)     {         for(int j=0;j<r;j++)         {             printf("%d ",a[i][j]);         }         printf("\n");     }      for(int i=0;i<l;i++)     {         for(int j=0;j<r;j++)         {             printf("%d ",b[i][j]);         }         printf("\n");     }*/      for(int i=0;i<q;i++)     {         scanf("%d %c",&k,&g);          if(g=='M')         {             if(k>maxm)             printf("no\n");              else             printf("yes\n");         }          else         {             if(k>maxf)             printf("no\n");              else             printf("yes\n");         }     }     return 0; } 
#include<iostream> #include<stdlib.h> #include<string> using namespace std; void LPSArray(long int lps[],string pat) {     long int len = 0;     lps[0] = 0;     long int i=1;     while(i<pat.length())     {         if(pat[len]==pat[i])         {             len++;             lps[i] = len;             i++;         }         else         {             if(len!=0)                 len = lps[len-1];             else             {                 lps[i] = 0;                 i++;             }         }     } } void KMP(string txt,string pat) {     long int lt = txt.length();     long int lp = pat.length();     long int i=0,j=0;     long int sum=0;     long int *lps = (long int *)malloc(sizeof(long int)*lp);     LPSArray(lps,pat);     while(i<lt)     {         if(txt[i]==pat[j])         {             i++;             j++;         }         if(j==lp)         {             sum++;             j = lps[j-1];         }         else if(i<lt && txt[i]!=pat[j])         {             if(j!=0)                 j = lps[j-1];             else                 i++;         }     }     if(sum==0)         cout<<"-1"<<endl;     else         cout<<sum<<endl; } int main() {     int T;     long int N,M,k;     cin>>T;     while(T--)     {         cin>>N>>M>>k;         string txt,pat;         cin>>txt>>pat;         string p = pat.substr(0,k);         KMP(txt,p);     }     return 0; } 
#include <algorithm> #include <vector> #include <list> #include <queue> using namespace std; #include <stdio.h> #include <memory.h>  typedef pair <int, int> pii; int test, cnt, n[2], taxi[501], people[1001], m, u, v, c, s[501], t[501], minCost[1502][1502]; int edges, last[500], pre[500000], head[500000], matching[1000], dist[500], Q[500]; bool fr[1502], used[500], vis[500]; vector <pii> adj[1502]; queue <int> que;  void spfa(const int& index){ 	int start = (index < cnt ? taxi[index] : index); 	fill(minCost[start] + 1, minCost[start] + 1 + cnt, 1e9); 	memset(fr + 1, false, cnt);  	que.push(start); 	fr[start] = true; 	minCost[start][start] = 0; 	while (!que.empty()){ 		int u = que.front(); 		que.pop(); 		fr[u] = false;  		for (int i = 0; i < adj[u].size(); ++i) 		if (minCost[start][adj[u][i].first] > minCost[start][u] + adj[u][i].second){ 			minCost[start][adj[u][i].first] = minCost[start][u] + adj[u][i].second; 			if (!fr[adj[u][i].first]){ 				fr[adj[u][i].first] = true; 				que.push(adj[u][i].first); 			} 		} 	} }  void addEdge(int u, int v) { 	head[edges] = v; 	pre[edges] = last[u]; 	last[u] = edges++; }  void bfs() { 	fill(dist, dist + n[0], -1); 	int sizeQ = 0; 	for (int u = 0; u < n[0]; ++u) { 		if (!used[u]) { 			Q[sizeQ++] = u; 			dist[u] = 0; 		} 	} 	for (int i = 0; i < sizeQ; i++) { 		int u1 = Q[i]; 		for (int e = last[u1]; e >= 0; e = pre[e]) { 			int u2 = matching[head[e]]; 			if (u2 >= 0 && dist[u2] < 0) { 				dist[u2] = dist[u1] + 1; 				Q[sizeQ++] = u2; 			} 		} 	} }  bool dfs(int u1) { 	vis[u1] = true; 	for (int e = last[u1]; e >= 0; e = pre[e]) { 		int v = head[e]; 		int u2 = matching[v]; 		if (u2 < 0 || !vis[u2] && dist[u2] == dist[u1] + 1 && dfs(u2)) { 			matching[v] = u1; 			used[u1] = true; 			return true; 		} 	} 	return false; }  int maxMatching() { 	fill(used, used + n[0], false); 	fill(matching, matching + n[1], -1); 	for (int res = 0;;) { 		bfs(); 		fill(vis, vis + n[0], false); 		int f = 0; 		for (int u = 0; u < n[0]; ++u) 		if (!used[u] && dfs(u)) 			++f; 		if (!f) 			return res; 		res += f; 	} }  int main(){ 	scanf("%d", &test); 	while (test--){ 		scanf("%d %d %d", n, n + 1, &m); 		cnt = n[0] + n[1] + 1;  		for (int i = 1; i <= n[0]; ++i) 			scanf("%d", taxi + i); 		for (int i = 1; i <= n[1]; ++i) 			scanf("%d", people + i);  		for (int i = 1; i <= cnt; ++i) 			adj[i].clear();  		for (int i = 1; i <= m; ++i){ 			scanf("%d %d %d", &u, &v, &c); 			adj[u].push_back(pii(v, c)); 			adj[v].push_back(pii(u, c)); 		}  		for (int i = 1; i <= n[0]; ++i) 			scanf("%d", s + i); 		for (int i = 1; i <= n[0]; ++i) 			scanf("%d", t + i);  		for (int i = 1; i <= n[0]; ++i) 			spfa(i); 		spfa(cnt);  		edges = 0; 		fill(last, last + n[0], -1); 		for (int i = 1; i <= n[0]; ++i) 		for (int j = 1; j <= n[1]; ++j) 		if (s[i] * t[i] >= minCost[taxi[i]][people[j]] + minCost[cnt][people[j]]) 			addEdge(i - 1, j - 1);  		printf("%d\n", maxMatching()); 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; int main() {     int n,m;     cin>>n>>m;     int i=1,l=0,j=1,k=1;     while(i<=n)     {         if(j==1)         l++;         if(k%m==0)         {             if(j==0)                 j=1;             else                 j=0;         }             k++;             i++;     }     cout<<l; } 
#include <iostream> #include <cmath> #include <cstdio> using namespace std; int main(void) { 	float t, n; 	scanf ("%f", &t); 	for (t; t > 0; --t) 	{ 		scanf ("%f", &n); 		printf ("%.6f\n", (double)sqrt(2) * n); 	} 	return 0; }
#include <cstring> #include<cstdio> #include<vector> #include<stack> #include<map> #include<queue> #include<set> #include<list> #include<iostream> #include<algorithm> #include<cmath> #include<cstring> #include<climits> #include<cstdlib> #define snd(a) scanf("%d",&(a)) #define snlld(a) scanf("%lld",&(a)) #define rep(i,n) for((i)=0;(i)<(n);(i)+=1) #define reps(i,s,n) for((i)=(s);(i)<(n);(i)+=1) #define pb push_back #define pf push_front #define all(a) (a).begin(),(a).end() #define fill(a,v) memset((a),(v),sizeof(a)) #define sz size() #define mp make_pair #define N 100010 #define mod  1000000007 using namespace std; typedef long long ll; typedef unsigned long long ull; template<class T> inline T poww(T b,T p){ll a=1;while(p){if(p&1){a=(a*b);}p>>=1;b=(b*b);}return a;} template<class T>  inline T gcd(T a,T b){ if(b>a)return gcd(b,a);return ((b==0)?a:gcd(b,a%b));} template<class T> inline void scan(vector<T>& a,int n){T b;int i; rep(i,n){cin>>b;a.pb(b);}} #define modd  20071027 #define pii pair<int,int> #define vpii vector<pii > #define vi vector<int> #define vvi vector<vi > #define vl vector<long long> #define fr first #define sd second //ios_base::sync_with_stdio(0); int a[1000060],*l; int CeilIndex(int A[], int l, int r, int key) {     int m;      while( r - l > 1 ) {         m = l + (r - l)/2;         (A[m] >= key ? r : l) = m; // ternary expression returns an l-value     }      return r; } int main(){     l=(int*)malloc(sizeof(int)*1000060);     int i,j,k,m,n,ln,s,e;     snd(n);    rep(i,n)scanf("%d",&a[i]);     l[0]=a[0];     ln=1;     //int*::iterator hi;     reps(i,1,n){         if(a[i]<l[0]){             l[0]=a[i];             continue;         }         else if(a[i]>l[ln-1]){             l[ln++]=a[i];             continue;         }         else{             l[lower_bound(l,l+ln,a[i])-l]=a[i]; //: gave WA            //l[CeilIndex(l,-1,ln-1,a[i])]=a[i];         }      }   //  rep(i,n+1)cout<<l[i]<<" ";cout<<"\n";     cout<<ln<<"\n"; } 
//Template  // By Anudeep :) //Includes #include <vector>  #include <queue> #include <map>  #include <set> #include <utility> //Pair #include <algorithm> #include <sstream> // istringstream>> ostring stream<< #include <iostream>  #include <iomanip>  //setbase - cout << setbase (16); cout << 100 << endl; Prints 64 //setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77 //setprecision - cout << setprecision (4) << f << endl; Prints x.xxxx #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <limits> using namespace std;  //M lazy ;) typedef long long ll; typedef vector <int> vi; typedef pair< int ,int > pii; typedef istringstream iss; typedef ostringstream oss; #define pb push_back #define mp make_pair #define ff first #define ss second #define sz size() #define ln length() #define rep(i,n) for(int i=0;i<n;i++) #define fu(i,a,n) for(int i=a;i<=n;i++) #define fd(i,n,a) for(int i=n;i>=a;i--) #define all(a)  a.begin(),a.end()  #define ESP (1e-9)  #define gi(n) scanf("%d",&n) #define gl(n) cin >> n #define pi(n) printf("%d",n) #define pl(n) cout << n #define ps printf(" ") #define pn printf("\n") #define dg(n,s); printf("%s %d",s,n) #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min()  #define M 1000000007  int poww(int a, int b) { 	ll x=1,y=a; 	while(b) { 		if(b&1) x = x*y % M; 		y = y*y % M; 		b >>= 1; 	} 	return x; } int main() { 	int t; 	gi(t); 	while(t--) { 		int n; 		gi(n); 		if(n==1) { 			printf("1 0\n"); 			continue; 		} 		int a = poww(n-1, n); 		int b = poww(n, n+1); 		a -= 1; 		a += M; 		a %= M; 		b = b-n+1; 		b += M; 		b %= M; 		printf("%d %d\n",b,a); 	} 	return 0; }
#include<iostream> #include<cstdio> using namespace std;  int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		unsigned long long int n; 		scanf("%llu",&n); 		long ans=0; 		while(n>2) 		{ 			ans+=n%2; 			n=(n+1)/2; 		} 		printf("%ld\n",ans); 	} 	return 0; } 
#include<iostream> #include<cstdio> using namespace std; int main() {     long int n,queries;     scanf("%ld",&n);     long int arr[100000]={0};     scanf("%ld",&queries);     while(queries--)     {         char ch[10];         scanf("%s",ch);         if(ch[0]=='U')         {             long int i,amt;             scanf("%ld%ld",&i,&amt);             for(long int j=i;j<=n;j=j+i)                 arr[j]+=amt;         }         else         {             int v;             scanf("%ld",&v);             printf("%ld\n",arr[v]);         }     }     return 0; }
#include<iostream> #include<stdio.h> #include<string.h> using namespace std; int dp[501][501]; int main() {     int t;     cin>>t;     while(t--)     {         char str[501];         scanf("%s",str);         int len=strlen(str);         int maxv=1;         for(int i=0;i<len;i++)             dp[i][i]=1;         for(int i=0;i<len-1;i++)             if(str[i]==str[i+1])             dp[i][i+1]=2,maxv=2;         for(int k=3;k<=len;k++)         {             for(int i=0;i+k<=len;i++)             {                 if(str[i]==str[i+k-1])                     if(dp[i+1][i+k-2])                     dp[i][i+k-1]=dp[i+1][i+k-2]+2,maxv=max(maxv,dp[i][i+k-1]);             }         }         printf("%d\n",maxv-1);         memset(dp,0,sizeof(dp));     } } 
#include<bits/stdc++.h> using namespace std; int main() {     int t;     scanf("%d",&t);     while(t--)     {         long long int n,res=0,x,y,z;         scanf("%lld",&n);         if(n<=2)         {             cout<<n<<"\n";         }         else if(n%6==0)         {              printf("%lld\n",(n-1)*(n-2)*(n-3));         }         else if(n%2!=0)         {             printf("%lld\n",n*(n-1)*(n-2));         }         else         {             printf("%lld\n",n*(n-1)*(n-3));         }     } } 
#include <bits/stdc++.h> using namespace std;  #define MOD 1000000007 #define pii pair<int, int> #define vi  vector<int> #define M(a,x) memset(a,x,sizeof(a)) #define sci(x) scanf("%d",&x); #define scl(x) scanf("%lld",&x); #define scs(x) scanf("%s",x);  typedef long long ll; typedef unsigned long long ull;   int main() {     char s[1000001];     scanf("%s",s);     int n=strlen(s);     int q;cin>>q;     ull  a,b;     while(q--)     {             cin>>a>>b;             a=a%n;b=b%n;             if(s[a-1]==s[b-1])                 printf("Yes\n");             else                 printf("No\n");     }     return 0; } 
/* Written by: Durgesh Kr. Soni    Problem: */  #include<bits/stdc++.h> using namespace std;  //template tools #define pb                   push_back #define ppb                  pop_back #define mp                   make_pair #define ff                   first #define ss                   second #define maxele(_)            *max_element(all(_)) #define minele(_)            *min_element(all(_))  #define INF                  2147483647 #define INFLL                9223372036854775807LL #define INFULL               18446744073709551615ULL #define PI                   acos(-1.0) #define E                    exp(1.0) #define EPS                  1e-12 #define gcd(_1,_2)           __gcd(_1,_2) #define lcm(_1,_2)           ((_1/gcd(_1,_2))*(_2)) #define cnt_1                __builtin_popcountll #define rep(i,a,b)           for(LL i=(a);i<=(b);++i) #define rer(i,b,a)           for(LL i=(b);i>=(a);--i) #define clr(_)               memset(_,false,sizeof(_)) #define feach(c,_)           for(__typeof((c).begin()) _=(c).begin();_!=(c).end();++_) #define all(_)               _.begin(),_.end() #define sz(_)                (LL(_.size())) #define len(_)               (LL(_.length())) #define T()                  LL _;cin>>_;while(_--) #define exist(x,_)           ((_).find(x)!=(_).end())  //traces #define SP                   system("pause") #define nl                   cout<<"\n" #define dbg(vari)            cerr<<#vari<<" = "<<(vari);nl #define dbgv(A,n)            nl;rep(ti,0,n-1) cout<<ti<<" -- > "<<A[ti]<<"\n" #define dbgvp(Z)             nl;rep(ti,0,sz(Z)-1){cout<<ti<<" --> "<<Z[ti].ff<<" "<<Z[ti].ss<<"\n";} #define dbgg(W,n)            nl;rep(ti,1,n){cout<<ti<<" --> ";rep(tj,0,sz(W[ti])-1) cout<<"("<<W[ti][tj].ff<<" , "<<W[ti][tj].ss<<")"<<"  ";cout<<"\n";} #define dbgmp(Z)             nl;foreach(Z,zt) cout<<(zt->ff)<<" --> "<<(zt->ss)<<"\n" #define dks                  cerr<<" ----- I am Here -----\n" #define fout(S,x)            cout<<fixed<<setprecision(x)<<S  //mathematics #define dist(x1,y1,x2,y2)        ((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)) #define area(x1,y1,x2,y2,x3,y3)  (abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))/2.0)) #define lne(x)                   (2.302585*(x)) #define ln(x)                    (LL(log2(double(x)))) #define dig(x)                   (LL(log10(double(x)))+1) #define ceil(a,b)               (LL(ceil(double(a)/double(b)))) #define sin(x)                   (sin((x*PI)/180.0))  typedef long long int LL;     typedef unsigned long long ULL;  typedef long double LD;      typedef pair<int,int>PII; typedef vector<int> VI;       typedef vector<PII> VPII;        typedef set<PII> SPII;       typedef vector<LL> VLL; typedef pair<LL,LL> PLL;      typedef vector<PLL> VPLL;        typedef set<PLL> SPLL;       typedef map<LL,LL> MLL; typedef map<string,LL> MSLL;  typedef map<LL,VLL> MVLL;        typedef map<LL,PLL> MPLL;    typedef vector<string> VS;  #define gc                   getchar//_unlocked #define pc                   putchar//_unlocked #define RG                   100007 bool markP[RG];VLL prime;char buf[23]; inline void sieve(){LL i,j;for(i=2;i*i<=RG;++i)if(!markP[i])for(j=i<<1;j<RG;j+=i)if(!markP[j])markP[j]=1;prime.pb(2);for(i=3;i<RG;i+=2)if(!markP[i])prime.pb(i);} inline void out(LL &x){register int i=22;if(x<0)pc('-'),x=-x;buf[22]='\n';do{buf[--i]=(x%10)+48;x/=10;}while(x);do{pc(buf[i]);}while(buf[i++]!='\n');} inline void inp(LL &x){register int c=gc();x=0;bool neg=0;for(;((c<48||c>57)&&c!='-');c=gc());if(c=='-'){neg=1;c=gc();}for(;c>47&&c<58;c=gc()){x=(x*10)+(c-48);}if(neg)x=-x;} inline bool isEqual(double &a,double &b){(abs(a-b)<EPS)?1:0;} inline bool isPrime(const LL &x){if(x<=3)return(x<=1?0:1);if(!(x&1)|(!(x%3)))return 0;for(LL i=5;i*i<=x;i+=6)if(!(x%i)|(!(x%(i+2))))return 0;return 1;} inline bool isPalin(string &st){LL l=len(st);for(LL i=0;(i<<1)<l;++i)if(st[i]!=st[l-i-1])return 0;return 1;} inline LL modExp(LL a,LL b,LL &mod){LL x=1;while(b){if(b&1){x*=a;if(x>=mod)x%=mod;};b>>=1;a*=a;if(a>=mod)a%=mod;}return x;} inline LL invMod(LL &a,LL &mod){return modExp(a,mod-2,mod);} inline LL pow(LL a,LL b){LL x=1;while(b){if(b&1)x=(x*a);a*=a;b>>=1;}return x;} inline LL digSum(LL n){LL s=0;n=abs(n);while(n){s+=(n%10);n/=10;}return s;} inline LL toNum(string &st){LL num;stringstream ss(st);ss>>num;return num;} inline LL elePos(const vector<LL> &A,const LL &x){LL l=0,h=sz(A)-1,m;while(l<=h){ m=(h+l)>>1;if(x==A[m])return (m+1);(x<A[m])?(h=m-1):(l=m+1);}return -1;} inline bool cmp(const PII &X,const PII &Y) {return (X.ff!=Y.ff)?(X.ff<Y.ff):(X.ss<Y.ss);}  #define MOD                  1000000007 #define MAX                  100007  int main() { 	ios_base::sync_with_stdio(false); 	T() 	{          int m, n, i, j;          cin >> m >> n;          int a[m][n], ans[m][n];          for (i = 0; i < m; i++) {             for (j = 0; j < n; j++)                 cin >> a[i][j];         }          memset(ans, 0, sizeof(ans));          ans[0][0] = 1;         bool flag1,flag2;         for (i = 0; i < m; i++) {             for (j = 0; j < n; j++) {                 if (i + 1 < m && a[i+1][j] > a[i][j])                     ans[i+1][j] = max(ans[i+1][j], ans[i][j]+1);                 if (j + 1 < n && (a[i][j+1] > a[i][j])){                     ans[i][j+1] = max(ans[i][j+1], ans[i][j] + 1);                 }             }         }          int c = 0;         for (i = 0; i < m; i++) {             for (j = 0; j < n; j++)                 c = max(c, ans[i][j]);         }          cout << c << endl;     }      return 0; } 
#include<stdio.h> long long int a[10005],dp[10005],max_so_far; long long int max(long long int x,long long int y) { 	if(x>y) 		return x; 	else 		return y; } int main() { 	#ifndef ONLINE_JUDGE 		freopen("in.txt","r",stdin); 	#endif  	int t,n,k,i; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d %d",&n,&k); 		for(i=0;i<n;i++) 		{ 			scanf("%lld",&a[i]); 			dp[i]=0; 		} 		max_so_far=0; 		for(i=0;i<=k;i++) 		{ 			if(a[i]>max_so_far) 				max_so_far=a[i]; 			dp[i]=max_so_far; 		} 		while(i<n) 		{ 			dp[i]=max(dp[i-k-1]+a[i],dp[i-1]); 			i++; 		} //		for(i=0;i<n;i++) //			printf("%lld ",dp[i]); //		printf("\n"); 		printf("%lld\n",dp[n-1]); 	} 	return 0; }
#include<cstdio> #include<iostream> #include<vector> #include<utility> #include<string.h> #include<algorithm>  #define LL long long int #define s(a) scanf("%d",&a) #define ss(a) scanf("%s",a) #define w(t) while(t--) #define f(i,n) for(i=0;i<n;i++) #define fd(i,n) for(i=n-1;i>=0;i--) #define p(a) printf("%d",a) #define ps(a) printf("%s",a) #define pc(a) printf("%c",a) #define ent printf("\n")  using namespace std;  char s[100];  int main() {     int x,i,f;     while(fgets(s, 100, stdin))     {   f=0;         x=strlen(s);         for(i=0;i<x;)         {                 if(s[i]=='-'&&s[i+1]=='>'&&f==0)                 {                     printf(".");                     i++;                 }                 else if(s[i]=='/'&&s[i+1]=='/')                 {                     f=1;                     printf("%c",s[i]);                 }                 else                     printf("%c",s[i]);                 i++;         }         //ent;     } 	return 0; } 
#include <iostream> using namespace std;  int main() { 	long  long int n; 	cin>>n; 	if(n%2==0) 	printf("2\n"); 	else printf("1\n"); 	return 0; }
#include<stdio.h> #include<string> #include<iostream> using namespace std ;  int alc[26] ; int bob[26] ; int perm[26] ;  int main(){  	int T ; 	string in ;  	string frst , scnd ;  	scanf("%d",&T) ; 	char c = getchar() ; 	cin >> in ;  	int i ; 	int min ;  	int bscr , ascr ; 	while(T--){ 	 		  		for(i=0;i<26;i++){ 		 			bob[i] = 0 ; 			alc[i] = 0 ; 		}  		for(i=0;i<in.length();i++){ 			perm[in[i]-97] = i ; 			 		} 		 		cin >> frst ; 		for(i=0;i<frst.length();i++) 			alc[frst[i]-97]++ ;  		cin >> scnd ; 		for(i=0;i<scnd.length();i++) 			bob[scnd[i]-97]++ ;  		for(i=0;i<26;i++){ 		 			min = bob[i]<alc[i] ? bob[i] : alc[i] ;  			bob[i]-=min ; 			alc[i]-=min ; 		 		} 	  		bscr = 0 ; 		ascr = 0 ;  		for(i=0;i<26;i++){ 		 			if(bob[i]) 				bscr+=perm[i] ; 			if(alc[i]) 				ascr+=perm[i] ; 		 		}  		if(bscr<ascr) 			printf("ALICE\n") ; 		else if(bscr>ascr) 			printf("BOB\n") ; 		else 			printf("TIE\n") ; 	}  }
/*	Jayesh Lahori	    */ #include<cstdio> #include<iostream> #include<algorithm> #include<cstring> #include<vector> #include<stack> #include<queue> #include<map> #include<set>  using namespace std;  /* General Declarations */  #define INF		1000000007 #define LL		long long int #define SI(n)		scanf("%lld",&n); #define SC(c)		scanf("%c",&c); #define SS(s)		scanf("%s",s); #define FOR(x,a,b)	for(LL x=a;x<b;x++) #define REP(i,n)	for(LL i=0;i<n;i++) #define MP		make_pair #define PB		push_back   /* Container's */  #define	VI		vector<LL> #define PLL             pair<LL,LL>  /* A Single Pair  */ #define VP		vector<PLL> /* Vector of Pairs */ #define VS		vector<string> #define VVI		vector<VI> #define VVS		vector<VS>  LL parent[1000010]; LL children[1000010];  LL find(LL x) { 	if(parent[x]==x) 		return x; 	return parent[x]=find(parent[x]); }  int main() { 	LL tc; 	SI(tc);	 	while(tc--) 	{  		LL n,m; 		SI(n); 		SI(m);  		REP(i,n+1) 		{ 			parent[i]=i; 			children[i]=1; 		}  		priority_queue<pair<LL,PLL > > q;   		while(m--) 		{ 			LL x,y,w; 			SI(x); 			SI(y); 			SI(w); 		 			x--; 			y--; /* O based indexing of Vertices */  			q.push(MP(-w,MP(x,y))); /* q take pair of LL and PLL , So First do a MP for PLL then MP for overall pair */ 		}  		LL ans=0; 		LL cnt=0;  		while(!q.empty()) 		{ 			if(cnt==n-1) 				 break;   /* All Vertices are included in MST */  			pair<LL,PLL> dummy=q.top(); 			q.pop();  			LL x=dummy.second.first;  /* 1st of Inner Pair */ 			LL y=dummy.second.second; /* 2nd of Inner Pair */  			LL w=-dummy.first;        /* First of Outer Pair */  			LL c1 = find(x); 			LL c2 = find(y); 			if(c1 != c2) 			{ 				if(children[c1] < children[c2])  					swap(c1, c2); 				children[c1] += children[c2]; 				children[c2]=1; 				parent[c2] = c1; 				ans+=w; 				cnt+=1; 			}  		} 		printf("%lld\n",ans); /* Cost of Spanning Tree */ 	}  	return 0; } 
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <climits> #include <cctype> #include <complex>   using namespace std;   #define ull unsigned long long #define ill long long int #define pii pair<int,int> #define pb(x) push_back(x) #define F(i,a,n) for(i=(a);i<(n);++i) #define FD(i,a,n) for(i=(a);i>=(n);--i) #define FE(it,x) for(it=x.begin();it!=x.end();++it) #define V(x) vector<x> #define S(x) scanf("%d",&x) #define Sl(x) scanf("%I64d",&x) #define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl   const double PI = 4*atan(1); typedef complex<double> base;   vector<base> omega; int FFT_N; void init_fft(int n) {      FFT_N  = n;      omega.resize(n);      double angle = 2 * PI / n;            for(int i = 0; i < n; i++)           omega[i] = base( cos(i * angle), sin(i * angle)); }   void fft (vector<base> & a) {      int n = (int) a.size();      if (n == 1)  return;      int half = n >> 1;            vector<base> even (half),  odd (half);      for (int i=0, j=0; i<n; i+=2, ++j)      {           even[j] = a[i];           odd[j] = a[i+1];      }      fft (even), fft (odd);            for (int i=0, fact = FFT_N/n; i < half; ++i)      {           base twiddle =  odd[i] * omega[i * fact] ;           a[i] =  even[i] + twiddle;           a[i+half] = even[i] - twiddle;      } } void multiply (const vector<long long> & a, const vector<long long> & b, vector<long long> & res) {      vector<base> fa (a.begin(), a.end()),  fb (b.begin(), b.end());      int n = 1;      while (n < 2*max (a.size(), b.size()))  n <<= 1;      fa.resize (n),  fb.resize (n);            init_fft(n);      fft (fa),  fft (fb);      for (size_t i=0; i<n; ++i)           fa[i] = conj( fa[i] * fb[i]);      fft (fa);        res.resize (n);      for (size_t i=0; i<n; ++i)           res[i] = (long long) (fa[i].real() / n + 0.5); }   int main() {     int i,j,t,abcd;     S(t);     while(t--) {         int n1,n2;     	vector<long long> v1,v2,res;     	S(n1); S(n2);     	F(i,0,n1+1) {     		int x;     		S(x);     		v1.pb(x);     	}     	F(i,0,n2+1) {     		int x;     		S(x);     		v2.pb(x);     	}     	multiply(v1,v2,res); 	while ( !res.empty() && *(res.end()-1) == 0 ) res.pop_back();     	int n = res.size();     	printf("%d\n", n-1);     	F(i,0,n) printf("%d ", res[i]);     	printf("\n");     }     return 0; } 
#include<algorithm> #include<iostream> #include<cstdio> #include<vector> #include<fstream> #include<iomanip> #include<bitset> #include<deque> #include<string> #include<map> #include<cstring> #include<sstream> #include<cmath> #include<cassert> using namespace std;  #define MOD 100001 long long ans;  void compute (int f, int l, int d) { 	if (f < 0 || l < 0) 		return; 	assert (f <= l); 	int n = (l-f)/d+1; 	long long sum = ((long long)(f+l)*(long long)n)/2; 	ans = (ans+sum)%MOD; }  int main () { 	int T; 	scanf ("%d", &T); 	for (int t = 0; t < T; t++) 	{ 		int N; 		ans = 0; 		scanf ("%d", &N); 		int start_odd, start_even, end_odd, end_even; 		if (N%2 == 1) 		{ 			start_odd = (N+1)/2; 			end_odd = (N-6*(N/6)+1)/2; 			start_even = (N-3)/2+1; 			end_even = (N-3-6*((N-3)/6))/2+1; 		} 		else 		{ 			start_odd = (N-3+1)/2;  			end_odd = (N-3-6*((N-3)/6)+1)/2; 			start_even = N/2+1; 			end_even = (N-6*(N/6))/2+1; 		} 		compute (end_odd, start_odd, 3); 		compute (end_even, start_even, 3); 		printf ("%lld\n", ans); 	} 	return 0; } 
#include<stdio.h> #include<string.h> int max(int a, int b, int c) { return a>b?(a>c?a:c):(b>c?b:c); } int min(int a, int b, int c) { return a<b?(a<c?a:c):(b<c?b:c); }  int main() { 	char s[100005]; 	int i, t, ans, r, g, b, count; 	scanf("%d",&t); 	//getchar(); 	while(t--) 	{ 		//gets(s); 		scanf("%s",&s); 		r=g=b=0, ans=100005; 		int l=strlen(s); 		for(i=0; s[i]!='\0'; i++) 		{  			if(s[i]=='R') r=i+1; 			else if(s[i]=='G') g=i+1; 			else b=i+1; 			if(r && b && g && (count=max(r,g,b)-min(r,g,b)+1)<ans) ans=count; 		} 		printf("%d\n",ans); 	} 	return 0; }
// AUTHOR : SIKANDER MAHAN // sikander_nsit // PLAGIARISM IS BAD  #include <vector> #include <list> #include <map> #include <set> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include<string.h> #define tr(c,it) for(typeof(c.begin()) it=c.begin();it!=c.end();++it) #define all(c) c.begin(),c.end() #define mod 1000000007 #define itor(c) typeof(c.begin()) #define ll long long #define vi vector<int> #define vs vector<string> #define si set<int> #define msi multiset<int> #define ii pair<int,int> #define sii set<ii> #define vii vector<ii> #define vvi vector<vi> #define pb push_back #define mp make_pair  using namespace std;  long long exponent(long long base,int e) {     long long result=1;     while(e>0)     {         if(e%2)             result=(result*base)%mod;         e=e>>1;         base=(base*base)%mod;     }     return result; }  long long degree(long long a) {     long long k=1000000005;     long long res = 1;     long long cur = a;     while (k)     {         if (k%2)         {             res = (res * cur)%mod;         }         k /= 2;         cur = (cur * cur)%mod;     }     return res; }  int main() {     //ios::sync_with_stdio(false);     //freopen("input.txt","r",stdin);     //freopen("out.txt","w",stdout);     int t=0,i=0,j=0,n=0,k=0,len,x;     ll inv=degree(25LL);     ll temp,num,ans;     cin>>t;     string str;     for(i=0;i<t;++i)     {         cin>>n;         x=n;         cin>>str;         len=str.length();         k=min(len,n);         temp=1;         ans=0;         for(j=0;j<k;++j)         {             temp*=(str[j]-96);             temp%=mod;             ans+=temp;             ans%=mod;         }         temp--;         if(temp<0)             temp+=mod;         temp=(temp*26)%mod;         n=max(0,n-len);         num=exponent(26LL,n)-1;         if(num<0)             num+=mod;         temp=(temp*num)%mod;         temp=(temp*inv)%mod;         ans=(ans+temp)%mod;         if(x>=len)         ans--;         if(ans<0)         ans+=mod;         cout<<ans<<endl;     } 	return 0; } 
#include<bits/stdc++.h> using namespace std; char mat[1010][1010]; bool visited[1010][1010]; int dist[1010][1010]; int x1[4]={0,0,1,-1}; int dy[4]={1,-1,0,0}; int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		int n,m; 		cin>>n>>m; 		for(int i=0;i<n;i++) 		for(int j=0;j<m;j++) 		{ 			visited[i][j]=false; 			dist[i][j]=INT_MAX; 		 		} 		for(int i=0;i<n;i++) 		cin>>mat[i]; 		queue<pair<int,int> > q; 		q.push(make_pair(0,0)); 		dist[0][0]=0; 		visited[0][0]=true; 		while(!q.empty()) 		{ 			int r=q.front().first; 			int c=q.front().second; 			q.pop(); 			visited[r][c]=true; 			for(int i=0;i<4;i++) 			{ 				int x=r+x1[i]; 				int y=c+dy[i]; 				if(x>=0&&x<n&&y>=0&&y<m&&!visited[x][y]&&mat[x][y]!=mat[r][c]) 				{ 					dist[x][y]=dist[r][c]+1; 					visited[x][y]=true; 					q.push(make_pair(x,y)); 				} 			} 		} 		if(visited[n-1][m-1]) 		cout<<dist[n-1][m-1]+1<<"\n"; 		else 		cout<<"-1\n"; 	} 	 }
#include <iostream> #include <vector> #include <cstdio> #include <cmath> #include <vector> using namespace std; #define lli long long int  long long func(long long a, long long b,long long n) {      long long i,t,sum,j,p1=0,p2=0,c;      vector <long long> v;      if ( n%2 == 0  ) {         v.push_back(2);         while ( n%2 == 0 ) n = n/2;      }      t = (long long)(sqrtl(n));      for ( i = 3; i <= t; i += 2 ) {          if ( n%i == 0 ) {             v.push_back(i);             while ( n%i == 0 ) n = n/i;          }          if ( n == 1 ) break;      }      if ( n != 1 ) {         v.push_back(n);      }      t = (long long)(v.size());                 for ( i = 0; i < 1 << t; i++ ) {          sum = 1;          c = 0;          for ( j = 0; j < t; j++ ) {               if ( i & (1<<j) ) {                  c++;                  sum *= v[j];               }          }          if ( c&1 ) {             p1 += a/sum;             p2 += b/sum;          }          else {               if ( sum != 1 ) {                  p1 -= a/sum;                  p2 -= b/sum;               }          }      }      p2 = b - p2;      p1 = a - p1;      return p2-p1; }    int main() {     int t;     cin>>t;     while(t--)     {               int fl=0;               lli n,x,m;               cin>>n>>x>>m;               if(n%x!=0) fl=1;               n=n/x;                   while(m--)               {                         lli l,r;                         cin>>l>>r;                         if(fl==1)                         {                                  cout<<"0\n";                                  continue;                         }                             if(l%x==0) l=l/x;                         else l=(l/x+1);                         r=r/x;                         cout<<func(l-1,r,n)<<"\n";                                       }     }     return 0; }                                                   
// AUTHOR : SIKANDER MAHAN // sikander_nsit // PLAGIARISM IS BAD  #include <vector> #include <list> #include <map> #include <set> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include<string.h> #define tr(c,it) for(typeof(c.begin()) it=c.begin();it!=c.end();++it) #define all(c) c.begin(),c.end() #define mod 1000000007 #define itor(c) typeof(c.begin()) #define ll long long #define vi vector<int> #define si set<int> #define msi multiset<int> #define ii pair<int,int> #define sii set<ii> #define vii vector<ii> #define vvi vector<vi> #define pb push_back #define mp make_pair  using namespace std;  struct node {     vector<int> v;     vector<ll> vs; };  node segtree[400009]; int arr[100002]; vi vec;  void initialise(int b,int e,int ind) {     int ind2=ind*2;     int ind1=ind2+1;     int temp,sz1,sz2,i,j;     if(b==e)     {         segtree[ind].v.pb(arr[b]);     }     else     {         initialise(b,(b+e)/2,ind2);         initialise((b+e)/2+1,e,ind1);         sz1=segtree[ind2].v.size();         sz2=segtree[ind1].v.size();         i=0,j=0;         while(true)         {             if(i==sz1)             {                 while(j<sz2)                 {                     segtree[ind].v.pb(segtree[ind1].v[j]);                     ++j;                 }                 break;             }             else if(j==sz2)             {                 while(i<sz1)                 {                     segtree[ind].v.pb(segtree[ind2].v[i]);                     ++i;                 }                 break;             }             else             {                 if(segtree[ind2].v[i]<=segtree[ind1].v[j])                 {                     segtree[ind].v.pb(segtree[ind2].v[i]);                     ++i;                 }                 else                 {                     segtree[ind].v.pb(segtree[ind1].v[j]);                     ++j;                 }             }         }     }     sz1=segtree[ind].v.size();     segtree[ind].vs.pb(0);     for(temp=0;temp<sz1;++temp)     {         segtree[ind].vs.pb(segtree[ind].vs[temp]+segtree[ind].v[temp]);     } }  void query(int ind,int b,int e,int i,int j) {     if(i>e || j<b)         return;     if(b>=i && e<=j)     {         vec.pb(ind);         return;     }     query(ind*2,b,(b+e)/2,i,j);     query(ind*2+1,(b+e)/2+1,e,i,j); }  int main() {     //ios::sync_with_stdio(false);     //freopen("input.txt","r",stdin);     //freopen("out.txt","w",stdout);     int t,i,j,n,m,l,r,sz,k,num,mx,temp;     ll sum;     int b[100],e[100];     vi vtemp;     int ind[100];     cin>>n;     for(i=0;i<n;++i)     {        cin>>arr[i];     }     initialise(0,n-1,1);     cin>>m;     for(i=0;i<m;++i)     {         vec.clear();         cin>>l>>r>>k;         query(1,0,n-1,l-1,r-1);         sz=vec.size();         sum=0;         for(j=0;j<sz;++j)         {             b[j]=0;             e[j]=min(k,(int)segtree[vec[j]].v.size());         }         while(true)         {             mx=0;             for(j=1;j<sz;++j)             {                 if((e[j]-b[j]) > (e[mx]-b[mx]))                 {                     mx=j;                 }             }             if(e[mx]-b[mx]<2)             {                 break;             }             temp=(e[mx]+b[mx]-1)/2;             num=segtree[vec[mx]].v[temp];             sum=0;             for(j=0;j<sz;++j)             {                 ind[j]=upper_bound(segtree[vec[j]].v.begin()+b[j],segtree[vec[j]].v.begin()+e[j],num)-segtree[vec[j]].v.begin();                 sum+=(ind[j]-b[j]);             }             sum-=(ind[mx]-temp-1);             ind[mx]=temp+1;             if(sum>=k)             {                 for(j=0;j<sz;++j)                 {                     e[j]=ind[j];                 }             }             else             {                 k-=sum;                 for(j=0;j<sz;++j)                 {                     b[j]=ind[j];                 }             }         }         vtemp.clear();         for(j=0;j<sz;++j)         {             if(e[j]-b[j])             {                 vtemp.pb(segtree[vec[j]].v[b[j]]);             }         }         sort(all(vtemp));         sum=0;         for(j=0;j<k;++j)         {             sum+=vtemp[j];         }         for(j=0;j<sz;++j)         {             sum+=segtree[vec[j]].vs[b[j]];         }         cout<<sum%mod<<endl;     }     return 0; } 
 #include <bits/stdc++.h> #define lli long long using namespace std; lli dp[202]; int main() {     int t,n;     lli x,y;     cin >> t;     assert(t<=10);     while ( t-- ) {         cin >> n;         assert(n<=200);         vector < pair<lli,lli> > v;         for ( int i = 0; i < n; i++ ) {             cin >> x >> y;             assert(x<=1000000000);             assert(y<=1000000000);             v.push_back(make_pair(x,y));         }         sort(v.begin(),v.end());         dp[0] = v[0].second;         lli ans = v[0].second;         for ( int i = 1; i < n; i++ ) {             dp[i] = v[i].second;             for ( int j = 0; j < i; j++ ) {                 if ( v[i].second > v[j].second && v[i].first > v[j].first ) dp[i] = max(dp[i], dp[j]+v[i].second);             }             ans = max(ans, dp[i]);         }         cout << ans << endl;     }     return 0; } 
#include<iostream> using namespace std; int main() {          int t; cin>>t;     while(t--)     {         long n; cin>>n;         bool inc=true;         bool dec=true;         if(n/10==0)         cout<<"0"<<endl;         else         {         while(n!=0)         {             int x=n%10;             n=n/10;             int y=n%10;             if(x>=y)             inc=false;             else             dec=false;         }         if(inc==false && dec==false)         cout<<"1"<<endl;         else         cout<<"0"<<endl;     }     }     return 0; }
#include <iostream> using namespace std;  int main() {     int a; cin>>a;     while(a--)     {         long long x,y;         cin>>x>>y;         int a1[10]={0};         while(x!=0)         {             int r=x%10;             a1[r]++;             x=x/10;         }         while(y!=0)         {             int r=y%10;             a1[r]--;             y=y/10;         }         int i=0;         for(i=0;i<10;i++)         {             if(a1[i]>0)             break;         }         if(i==10)         cout<<"1"<<endl;         else cout<<"0"<<endl;     }     return 0; } 
#include <iostream> #include<cstdio> using namespace std; int main() {    int t;    cin>>t;    while(t--)    {        string str;        cin>>str;        int l=str.length();        int i,s=0;        for(i=0;i<l;i++)        {            char ch=str[i];            int x=ch;            s=s+x;        }        s=s/l;        char c=s;        cout<<c<<"\n";    }    return 0; } 
#include <iostream>  using namespace std;  char a[100000000]; int main() {     int test;     cin>>test;     while(test>0)      {         cout<<"\n";          int sum=0,b=0;         cin>>a;         for(int i=0;a[i]!='\0';i++)         {             sum+=a[i]-48;             b=b*10+(a[i]-48);         }         sum=sum<<b;         cout<<sum;         test--;      }     return 0; } 
#include <stdio.h>  int main(void) { 	int t,n,k,i,x,c; 	scanf("%d", &t); 	while (t--){ 		c=0; 		scanf("%d %d", &n, &k); 		for (i=0; i<n; i++){ 			scanf("%d",&x); 			if (x<=0) 				c++; 		} 		if (c>=k){ 			printf("NO\n"); 		} 		else{ 			printf ("YES\n"); 		} 	} 	return 0; } 
#include <stdio.h> #include <math.h> int check(int n){ 	if (n%2==1) 		return 0; 	double m = n; 	double s = sqrt(m); 	if ((int)s!=s){ 		return 0; 	} 	return 1; } int gcd(int a, int b){ 	if (a==0) 		return b; 	if (b==0) 		return a; 	if (a>b) 		return gcd(a%b,b); 	else 		return gcd(a,b%a); } int main(void) { 	int t,n,i,fac,count,temp; 	scanf ("%d", &t); 	while (t--) 	{ 		fac = 0; 		count = 0; 		scanf("%d", &n); 		for (i=1; i*i<=n; i++){ 			if (n%i==0){ 				temp = n/i; 				if (i ==1 || i == temp){ 					//printf ("%d ", i); 					fac++; 					if (check(i)==1) 						count++; 				} 				else{ 					fac+=2; 					//printf ("%d %d ", i, temp); 					if (check(i)==1) 						count++; 					if (check(temp)==1) 						count++; 				} 			} 		} 		if (count==0) 			printf ("0\n"); 		else{ 			int g = gcd(count,fac); 			printf("%d/%d\n",count/g,fac/g); 		} 	} 	return 0; } 
#include <cassert> #include <cctype> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <iostream> #include <sstream> #include <iomanip> #include <string> #include <vector> #include <deque> #include <list> #include <set> #include <map> #include <bitset> #include <stack> #include <queue> #include <algorithm> #include <functional> #include <iterator> #include <numeric> #include <utility> using namespace std;  template< class T > T _abs(T n) { return (n < 0 ? -n : n); } template< class T > T _max(T a, T b) { return (!(a < b) ? a : b); } template< class T > T _min(T a, T b) { return (a < b ? a : b); } template< class T > T sq(T x) { return x * x; } template< class T > T gcd(T a, T b) { return (b != 0 ? gcd<T>(b, a%b) : a); } template< class T > T lcm(T a, T b) { return (a / gcd<T>(a, b) * b); } template< class T > bool inside(T a, T b, T c) { return a<=b && b<=c; } template< class T > void setmax(T &a, T b) { if(a < b) a = b; } template< class T > void setmin(T &a, T b) { if(b < a) a = b; }  #define ALL(c) c.begin(), c.end() #define PB(x) push_back(x) #define UB(s, e, x) upper_bound(s, e, x) #define LB(s, e, x) lower_bound(s, e, x) #define REV(s, e) reverse(s, e); #define SZ(c) c.size() #define SET(p) memset(p, -1, sizeof(p)) #define CLR(p) memset(p, 0, sizeof(p)) #define MEM(p, v) memset(p, v, sizeof(p)) #define CPY(d, s) memcpy(d, s, sizeof(s)) #define ll long long #define ff first #define ss second #define DEBUG if(0)  #define si(x) scanf("%d",&x) #define pi(x) printf("%d\n",x) #define siz 100100 int main() {              ll int n,i,a[siz],q;               cin>>n;               for(i=1;i<=n;i++)               cin>>a[i];               cin>>q;               while(q--)               {                       ll  int l,r,key=-1;                         cin>>l>>r;                         for(i=1;i<=n;i++)                         {                           if(i>=l && i<=r)                           continue;                              if(key==-1)                              key=a[i];                              else                              key=(key*a[i])/__gcd(key,a[i]);                              }                           key%=26;                        //   cout<<key<<"\n";                         char  str[siz];                         scanf("%s",str);                         for(i=0;str[i]!='\0';i++)                         {                         if(str[i]>='a' && str[i]<='z')                         {                         char c=(str[i]-'a'+26-key)%26;                          c+='a';                          cout<<c;                          }                          if(str[i]>='A' && str[i]<='Z')                         {                         char c=(str[i]-'A'+26-key)%26;                          c+='A';                          cout<<c;                          }                                                   }                           printf("\n");//<<"\n";                         }                         return 0;                         }         
#include<iostream> using namespace std;  int findsumofdiv(int n) {     int sum=0;     for(int i=1 ; i<n ; i++)     {         if(n%i==0)             sum+=i;     }     return sum; }  int main() {     int n,n1,temp,temp1;     cin>>n1;     for(int i=0 ; i<n1 ; i++)     {         cin>>n;         temp=findsumofdiv(n);         temp1=findsumofdiv(temp);         if(temp1==n)             cout<<"Yes, amicable with "<<temp<<endl;         else             cout<<"No"<<endl;     }     return 0; } 
/**   * @link http://www.codechef.com/problems/CEXP03   * @author Axay   */  #include <stdio.h>  int main(int argc, char* argv[]){ 	char temp[51], *forw, *backw; 	unsigned T, result;  	scanf("%u", &T); 	while(T--){ 		scanf("%s", &temp); 		forw = temp; 		backw = temp; 		while(*backw != '\0') 			++backw; 		--backw; 		result = 1; 		while((forw <= backw) && result){ 			switch(*forw){ 				case 'A': 				case 'H': 				case 'I': 				case 'M': 				case 'O': 				case 'T': 				case 'U': 				case 'V': 				case 'W': 				case 'X': 				case 'Y': 				case '1': 				case '8': 					if(*forw != *backw) 						result = 0; 					break;  				case 'E': 				case '3': 				case 'J': 				case 'L': 				case 'S': 				case '2': 				case 'Z': 				case '5': 					if(*forw == *backw){ 						if(result <= 2) 							result = 2; 						else 							result = 0; 					} 					else{ 						switch(*forw){ 							case 'E': 								if('3' == *backw) 									result = 3; 								else 									result = 0; 								break; 							case '3': 								if('E' == *backw) 									result = 3; 								else 									result = 0; 								break; 							case 'J': 								if('L' == *backw) 									result = 3; 								else 									result = 0; 								break; 							case 'L': 								if('J' == *backw) 									result = 3; 								else 									result = 0; 								break; 							case 'S': 								if('2' == *backw) 									result = 3; 								else 									result = 0; 								break; 							case '2': 								if('S' == *backw) 									result = 3; 								else 									result = 0; 								break; 							case 'Z': 								if('5' == *backw) 									result = 3; 								else 									result = 0; 								break; 							case '5': 								if('Z' == *backw) 									result = 3; 								else 									result = 0; 								break; 						} 					} 					break; 				default: 					if((*forw == *backw) && (result <= 2)) 						result = 2; 					else 						result = 0; 					break; 			} 			++forw; 			--backw; 		}  		switch(result){ 			case 0: 				printf("%s is not a palindrome.\n", temp); 				break; 			case 1: 				printf("%s is a mirrored palindrome.\n", temp); 				break; 			case 2: 				printf("%s is a regular palindrome.\n", temp); 				break; 			case 3: 				printf("%s is a mirrored string.\n", temp); 				break; 		} 	} 	return 0; } 
#include<stdio.h> #define MAX 1000001 int prime[MAX]={0}; int circularprime[MAX]={0}; int circular_prime(int n){  int k=n;      int num,msb;  int count=0;  num=1;   while(n){            if(n%2==0)    return 0;   n/=10;   num*=10;           count++;  }    num/=10;     while(count--){     msb=k/num;                   k=k-num*(k/num);                    k=k*10+msb;                   //printf("%d ",k);    if(prime[k])    return 0;   }    return 1;    } void generate_circularprime(){ int i; circularprime[2]=1; for(i=3;i<MAX;i++)       if(!prime[i]){            if(circular_prime(i)){                  circularprime[i]=1;       //prime[i]=1;    }           }          } void sieve(){   int i,j;    prime[0]=prime[1]=1;     for(i=2;i<MAX;i++)   {     j=2;                     if(!prime[i]){       while(i*j<MAX){        prime[i*j++]=1;                     }                 }                      }    } //int circular_prime[]={2,3,5,7,11,13,17,37,79,113,197,199,337,1193,3779,11939,19937,193939,199933}; int main(){  int i,n;  sieve();  generate_circularprime();  int count=0;  /*for(i=0;i<MAX;i++){     if(circularprime[i])      printf("%d ",i);     // count++;        //circularprime[i]=count;  } */   int t;  scanf("%d",&t);  while(t--){   //count=0;   scanf("%d",&n);      if(circularprime[n])   printf("Yes\n");   else   printf("No\n");            }    return 0;     } 
//ideal strings #include<iostream> #include<string> using namespace std;  short ideal(char c, string s){     int idx, cnt=0;     for(int i=0;i<s.length();i++){         if(s[i]==c){             idx=i;             break;         }     }     for(int i=idx+1;i<s.length();i++){         if(s[i]==c)cnt++;     }     if(idx==cnt)return true;     return false; }  int main(){     int t;     string s;     bool idl;     cin>>t;     while(t--){         cin>>s;         idl=true;         for(int i=0;i<s.length();i++){             if(!ideal(s[i],s)){idl=false;break;}         }         if(idl)cout<<"Yes"<<endl;         else cout<<"No"<<endl;     }     return 0; }
#include<iostream> #include<string> #include<vector> #include <ctype.h> using namespace std;   string temp;//temp; vector<vector<string> >sentences; vector<string>temp_vector;   int P;   //end of variable initalization void print(vector<vector<string> >text){ 	for(int i=0;i<text.size();i++){ 		char temp=text[i][0][0]; 		char s=toupper(temp); 		text[i][0][0]=s; 		for(int j=0;j<text[i].size();j++){ 			cout<<text[i][j]; 			if(j!=text[i].size()-1){ 				cout<<" "; 			} 		} 		cout<<"."<<endl; 	} }   bool vowel(char a){ 	char vowels[]={'a','e','i','o','u','A','E','I','O','U'}; 	for(int i=0;i<10;i++){ 		if(vowels[i]==a)return true; 	} 	return false; }   void process(vector<string> &text){ 	for(int i=0;i<text.size();i++){ 		string temp; 		string word; 		if(vowel(text[i][0])){ 			word=text[i]; 			word+="way"; 			text[i]=word; 		}else{ 			string word_temp=text[i]; 			word=text[i].substr(1,text[i].size()-1); 			word+=word_temp[0]; 			word+="ay"; 			text[i]=word; 		} 	} }   int main(){ 	cin>>P; 	for(int i=0;i<P;i++){ 		bool endinput=false; 		temp_vector.clear(); 		sentences.push_back(temp_vector); 		while(cin>>temp){ 			if(temp[temp.length()-1]=='.'){ 				temp=temp.substr(0,temp.size()-1); 				endinput=true; 			} 			temp[0]=tolower(temp[0]); 			sentences[i].push_back(temp); 			if(endinput){ 				break;	 			} 		} 	} 	 	for(int i=0;i<P;i++){ 		process(sentences[i]); 	} 	print(sentences); 	 	//cout<<c<<endl; 	return 0; }  
#include <stdio.h>  int t,n;  int main() { 	int i,j; 	scanf("%d",&t); 	while(t--) { 		scanf("%d",&n); 		for(i=n;i>0;i--) { 			int x = 2*n - i*i + i; 			if(x % (2*i) == 0 && x > 0) { 				x /= 2*i; 				for(j=0;j<i;j++) 					printf("%d ",x+j); 				printf("\n"); 				break; 			} 		} 	} 	return 0; }
#include<iostream> using namespace std;   int main(){     long t,n,c,a,b,temp;     bool found;     cin>>t;     for(long p=0;p<t;p++){         found=false;         cin>>c>>n;         long ar[n];         for(long i=0;i<n;i++){             cin>>ar[i];         }         for(long i=0;i<n;i++){             for(long j=i+1;j<n;j++){                 if(ar[i]+ar[j]==c){                     a=i+1;                     b=j+1;                     found=true;                     break;                 }             }             if(found)break;         }         //cout<<"Shop"<<p+1<<": "<<a<<" "<<b<<endl;         cout << "Shop" << p << ": " << a << " " << b << endl;     } }
#include<iostream> #include<cstdio> #include<algorithm> #include<cstring> #include<cstdlib> #include<cctype> #include<cmath> #include<climits> #include<vector> #include<iterator> #include<set> #include<bitset> #include<ctime> #include<iomanip>  #define fr(i,a,b) for(int i=a; i<b; i++) #define s(a) scanf("%d", &a) #define sl(a) scanf("%lld", &a) #define p(a) printf("%d\n", a) #define w(t) while(t--) #define pb push_back #define CLR(a) memset(a, 0, sizeof(a)) #define MAX(a, b) a>b?a:b  using namespace std;  typedef long long int lli; typedef vector<int> VI; typedef vector<string> VS;  const int SIZ = 3006; const int alpha = 26;  int main() { 	char input[SIZ], sorted[SIZ]; 	int testcase, index, sort[alpha], length, count, k, t1, t[SIZ]; 	s(testcase); 	w(testcase) { 		scanf("%s %d", sorted, &index); 		length = strlen(sorted); 		index = length-index; 		k=0; 		for(int i=length-1;i>=0;i--) 			input[k++] = sorted[i]; 		input[k] = '\0'; 		CLR(sort); 		fr(i,0,length) { 			int j = (int)input[i]-'a'; 			sort[j]++; 		} 		count=0; 		fr(i,0,alpha)	 			if(sort[i]>0) 				fr(j,0,sort[i]) { 					sorted[count++] = (char)(i+'a'); 				} 		t1=0; 		fr(i,0,alpha) { 			if(sort[i]>0) { 				k=0; 				fr(j,0,sort[i]) { 					while(k<length) { 						if(input[k]==(char)(i+'a'))		t[t1++]=k; 						k++; 					} 				} 			} 		} 		fr(i,0,length) { 			sorted[i] = input[index]; 			index = t[index]; 		} 		sorted[length] = '\0'; 		printf("%s\n",sorted); 	} 	return 0; }
#include <iostream> #include <string> #include <bits/stdc++.h>  using namespace std;  int dp[3005][3005];  int editDistance(string s1, string s2) { 	int m, n, i, j; 	m = s1.length(); 	n = s2.length();  	for(i = 0; i <= m; i++) { 		for(j = 0; j <= n; j++) { 			if (i == 0) { 				dp[i][j] = j; 			} else if (j == 0) { 				dp[i][j] = 2 * i; 			} else if (s1[i-1] == s2[j-1]) { 				dp[i][j] = dp[i-1][j-1]; 			} else { 				dp[i][j] = min(2 + dp[i-1][j], 1 + dp[i][j-1]); 			} 		} 	}  	// for(i = 0; i <= m; i++) { 	// 	for(j = 0; j <= n; j++) { 	// 		cout<<dp[i][j]<<" "; 	// 	} 	// 	cout<<endl; 	// } 	return dp[m][n]; }  int main() { 	string s1, s2; 	int q, t, p, i; 	char entry; int num; 	scanf("%d", &t); 	while(t--) { 		scanf("%d", &q); 		getchar(); 		s1 = ""; s2 = ""; 		for(i = 0; i < q; i++) { 			scanf("%c", &entry); 			scanf("%d", &num); 			while(num--) { 				s1 += entry; 			} 		} 		scanf("%d", &q); 		getchar(); 		for(i = 0; i < q; i++) { 			scanf("%c", &entry); 			scanf("%d", &num); 			while(num--) { 				s2 += entry; 			} 		} 		// cout<<s1<<s2<<endl; 		cout<<editDistance(s1, s2)<<endl; 	} 	return 0; } 
      #include<stdio.h>       #include<iostream>         #include<stdlib.h>         #include<math.h>         #include<string.h>         #include<algorithm>          using namespace std;           int main()         {             int t;             cin>>t;              while(t--)             {                 string str;                 cin>>str;                 if(next_permutation(str.begin(),str.end()))                 cout<<str<<"\n";                 else cout<<"no answer\n";             }             return 0;         } 
#include <iostream> using namespace std; #define ll long long int main() { 	ll t; 	ll g,n,temp; 	cin>>t; 	while(t--) 	{ 		cin>>g>>n; 			 temp=g+g; 			for(ll i=1;i<n;i++) 		      cout<<temp<<" "; 		      //cout<<" klkl "; 		      cout<<temp+g<<endl; 		 	} }
      #include<stdio.h>       #include<iostream>         #include<stdlib.h>         #include<math.h>         #include<string.h>          using namespace std;           int main()         {             int t;             cin>>t;              while(t--)             {                 long long int l,r,i,j,sum=0,num,count;                 cin>>l>>r;                 for(num = l;num<=r;num++)                 {                     count = 0;                     for(j=2;j<=sqrt(num);j++)                     {                         if(num%j==0)                         {                             count++;                             break;                         }                     }                     if(count==0 && num!= 1)              sum=sum+num;                  }             cout<<sum<<"\n";             }             return 0;         } 
      #include<stdio.h>       #include<iostream>         #include<stdlib.h>         #include<math.h>         #include<string.h>          using namespace std;           int main()         {             int t;             cin>>t;              while(t--)             {                 long long int n,total;                 cin>>n;                 total= ((n)*(n-1))/2;                 cout<<total<<"\n";             }             return 0;         } 
#include <iostream>  using namespace std;  int main() { 	 	ios_base::sync_with_stdio( false );  	int n, i, j, sum1, sum2, v;  	cin >> n; 	int **A = new int*[ n ]; 	for( i = 0;i < n;i++ ) { 		A[ i ] = new int[ n ]; 	}  	for( i = 0;i < n;i++ ) { 		for( j = 0;j < n;j++ ) { 			cin >> A[ i ][ j ]; 		} 	} 	 	sum1 = sum2 = 0; 	for( i = 0;i < n;i++ ) { 		sum1 += A[ i ][ i ]; 		sum2 += A[ i ][ n - i - 1 ]; 	}  	v = sum1 - sum2;  	cout << ( ( v >= 0 ) ? v : -v ) << "\n"; 	 	for( i = 0;i < n;i++ ) { 		delete A[ i ]; 	}  	delete A;  	return 0;  }
#include <iostream> using namespace std;  int main() {    for (int i = 1; i < 101; ++i)    {        if      (i % 3 == 0 && i % 5 == 0) cout << "FizzBuzz";        else if (i % 3 == 0)               cout << "Fizz";        else if (i % 5 == 0)               cout << "Buzz";        else                               cout << i;        cout << endl;    } }
#include <bits/stdc++.h>  using namespace std;  int arr[1005][1005]; int main() {    int a,b,n;    cin>>a>>b>>n;    int s=0,c=0;    while(s<n)    {         s+=a;         c++;         if(s>=n)             break;         s-=b;    }    cout<<c<<endl;     return 0; }
#include <iostream> using namespace std;   void solve() {     string s, t;     cin>>s>>t;       /*      * len stores the length of the prefix of S already found.      * pos stores the current index in T.      */     int len = 0, pos=0;     while(len<s.length() && pos<t.length()) {           /* if the letter at position len matches. */          if(s[len]==t[pos]) {             len++;         }           pos++;     }       cout<<len<<endl; } int main() { 	solve(); 	return 0; }
#include<bits/stdc++.h> #define MOD 1000000007 #define len(a) strlen(a) #define ll long long #define nl printf("\n") #define F first #define S second #define db printf("debug") #define yes printf("YES\n") #define no printf("NO\n") #define pb(a) push_back(a) #define po(a) pop_back() #define mp(a,b) make_pair(a,b) #define set(a,v) memset(a,v,sizeof(a)) #define sz(v) v.size() #define gc getchar//_unlocked #define pcase(i) printf("Case %d:\n",i) using namespace std;  struct Point {     int x, y; };  // A globle point needed for  sorting points with reference // to  the first point Used in compare function of qsort() Point p0;  // A utility function to find next to top in a stack Point nextToTop(stack<Point> &S) {     Point p = S.top();     S.pop();     Point res = S.top();     S.push(p);     return res; }  // A utility function to swap two points int swap(Point &p1, Point &p2) {     Point temp = p1;     p1 = p2;     p2 = temp; }  // A utility function to return square of distance // between p1 and p2 int distSq(Point p1, Point p2) {     return (p1.x - p2.x)*(p1.x - p2.x) +           (p1.y - p2.y)*(p1.y - p2.y); }  // To find orientation of ordered triplet (p, q, r). // The function returns following values // 0 --> p, q and r are colinear // 1 --> Clockwise // 2 --> Counterclockwise int orientation(Point p, Point q, Point r) {     int val = (q.y - p.y) * (r.x - q.x) -               (q.x - p.x) * (r.y - q.y);      if (val == 0) return 0;  // colinear     return (val > 0)? 1: 2; // clock or counterclock wise }  // A function used by library function qsort() to sort an array of // points with respect to the first point int compare(const void *vp1, const void *vp2) {    Point *p1 = (Point *)vp1;    Point *p2 = (Point *)vp2;     // Find orientation    int o = orientation(p0, *p1, *p2);    if (o == 0)      return (distSq(p0, *p2) >= distSq(p0, *p1))? -1 : 1;     return (o == 2)? -1: 1; }  // Prints convex hull of a set of n points. void convexHull(Point points[], int n) {    // Find the bottommost point    int ymin = points[0].y, min = 0;    for (int i = 1; i < n; i++)    {      int y = points[i].y;       // Pick the bottom-most or chose the left      // most point in case of tie      if ((y < ymin) || (ymin == y &&          points[i].x < points[min].x))         ymin = points[i].y, min = i;    }     // Place the bottom-most point at first position    swap(points[0], points[min]);     // Sort n-1 points with respect to the first point.    // A point p1 comes before p2 in sorted ouput if p2    // has larger polar angle (in counterclockwise    // direction) than p1    p0 = points[0];    qsort(&points[1], n-1, sizeof(Point), compare);     // If two or more points make same angle with p0,    // Remove all but the one that is farthest from p0    // Remember that, in above sorting, our criteria was    // to keep the farthest point at the end when more than    // one points have same angle.    int m = 1; // Initialize size of modified array    for (int i=1; i<n; i++)    {        // Keep removing i while angle of i and i+1 is same        // with respect to p0        while (i < n-1 && orientation(p0, points[i],                                     points[i+1]) == 0)           i++;          points[m] = points[i];        m++;  // Update size of modified array    }     // If modified array of points has less than 3 points,    // convex hull is not possible    if (m < 3) return;     // Create an empty stack and push first three points    // to it.    stack<Point> S;    S.push(points[0]);    S.push(points[1]);    S.push(points[2]);     // Process remaining n-3 points    for (int i = 3; i < m; i++)    {       // Keep removing top while the angle formed by       // points next-to-top, top, and points[i] makes       // a non-left turn       while (orientation(nextToTop(S), S.top(), points[i]) != 2)          S.pop();       S.push(points[i]);    }     // Now stack has the output points, print contents of stack Point p1= S.top(),plast; plast=p1; //cout << "(" << p1.x << ", " << p1.y <<")" << endl; int sz= S.size(); S.pop(); double ans=0;     while (!S.empty())    {        Point p2 = S.top();        ans+= sqrt((double)(distSq(p1,p2)));        //cout << "(" << p2.x << ", " << p2.y <<")" << endl;       p1=p2;        S.pop();    }     if(sz>2)     ans+=sqrt((double)distSq(plast,p1));    printf("%.1f\n",ans); }   // Driver program to test above functions int main() {        int n,i;     cin>>n;     Point a[100005];     for(i=0;i<n;i++)         cin>>a[i].x>>a[i].y;      // n = sizeof(a)/sizeof(a[0]);     convexHull(a, n);     return 0; } 
#include<stdio.h> #include<string> #include<iostream> using namespace std ;  int main(){  	string in ; 	while( cin >> in ) 		cout << in << " " ; 	return 0 ; }
#include<stdio.h>  int val(char *str) {     if(str[0]=='J' && str[1]=='a')     return 1;     if(str[0]=='F')     return 2;     if(str[0]=='M' && str[2]=='r')     return 3;     if(str[0]=='A' && str[1]=='p')     return 4;     if(str[0]=='M')     return 5;     if(str[0]=='J' && str[2]=='n')     return 6;     if(str[0]=='J')     return 7;     if(str[0]=='A')     return 8;     if(str[0]=='S')     return 9;     if(str[0]=='O')     return 10;     if(str[0]=='N')     return 11;     if(str[0]=='D')     return 12; }  int luck(int x) {     if(x<10)     return x;     int s=0;     while(x>0)     {               s=s+(x%10);               x=x/10;     }     return luck(s); }           main() {       int a,c;       char b[20];       scanf("%d%s%d",&a,b,&c);       int bb=val(b);       int res=a*bb+c;       printf("%d\n",luck(res)); } 
#include<iostream> using namespace std; int main() {     char c[11];     cin.getline(c,11);     int sum=0;     for(int i=0;i<4;i++)     {         int a1=c[i]-'0';         int a2=c[i+5]-'0';         sum+=a1*a2;     }     cout<<sum<<endl;     return 0; }
#include<stdio.h> using namespace std; int main() { 	int a,b,temp,t,i,j; 	float x=2,*arr,f; 	scanf("%d",&t); 	arr=new float[t]; 	for(i=0;i<t;i++) 	{ 		scanf("%d%d",&a,&b); 		if(a>b) 		{ 			temp=a; 			a=b; 			b=temp; 		} 		f=1/(float)a; 		for(j=a+1;j<=b;j++) 			x+=f; 		arr[i]=b/x; 		x=2; 	} 	for(i=0;i<t;i++) 		printf("%f\n",arr[i]); }		
#include<cstdio> #include<iostream> #include<algorithm> #include<cmath> using namespace std; int n,m,a[13][13];  int main(){ 	a[0][0]=a[1][0]=a[2][0]=a[3][0]=a[4][0]=a[5][0]=a[6][0]=a[7][0]=a[8][0]=a[9][0]=a[10][0]=a[11][0]=a[12][0]=1; 	int t,i,j,k; 	for(i=1;i<=12;i++)for(j=1;j<=i;j++)a[i][j]=a[i-1][j-1]+a[i-1][j]; 	scanf("%d",&t); 	while(t--){ 		scanf("%d",&n);scanf("%d",&m); 		printf("%d\n",a[m+n][m]); 	} 	return 0; } 
#include<stdio.h> #include<math.h> using namespace std; int main() { 	int t,count,n,p=2,m=1,j; 	float f; 	scanf("%d",&t); 	for(int i=0;i<t;i++) 	{ 	scanf("%d",&n); 	m=1,p=2,count=1; 	if(n==0) 		goto l; 	m+=p,p++; 	while(true) 	{	 		f=sqrt(m);	 		for(j=2;j<=f;j++) 		{ 			if(count>n) 				break; 			else if(j==f) 				count++; 			else if(m%j==0) 				count+=2; 		} 		if(j-1==(int)f&&count==n) 		{ 			break; 		} 		count=1;m+=p;p++;	 	} 	l: 	printf("%d\n",m); 	} }
#include<iostream> #include<vector> #include<stdio.h> #include<stdlib.h>  using namespace std;  int HCF( int a, int b ) { 	 	if( ( a % b ) == 0 ) 		return b; 	else 		return HCF( b, ( a % b ) ); }  int LCM( int a, int b ) { 	 	return ( ( a * b ) / HCF ( a, b ) ); }  int calcLCM( vector< pair<int,int> >& A, int N ) { 	 	int i, a, b, g; 	 	a = A[ 0 ].second;   	for( i = 1;i < N;i++ ) { 		 		b = A[ i ].second; 		a = LCM( a, b ); 	}  	return a; }  int calcHCF( vector< pair<int,int> >& A, int N ) { 	 	int i, a, b, g; 	 	a = A[ 0 ].first;   	for( i = 1;i < N;i++ ) { 		 		b = A[ i ].first; 		a = HCF( a, b ); 	}  	return a; }  int main() { 	 	int N, i, num, deno; 	 	scanf("%d", &N );  	vector< pair<int,int> > A( N );  	for( i = 0;i < N;i++ ) 		scanf("%d\n%d", &A[ i ].first, &A[ i ].second );	  	num = calcHCF( A, N ); 	deno = calcLCM( A, N );  	printf("%d/%d\n", num, deno );  	return 0; } 
#include<iostream> using namespace std;  int func(char *a){ 	int i=0; 	while(a[i]!=NULL){ 		i++; 	} 	return i; }  int main(){ 	int t; 	char a[50]; 	cin>>t; 	while(t--){ 		cin>>a; 		cout<<func(a)<<endl; 	} } 
#include<iostream> using namespace std;  int counter(int count,int b) {     int sum=0;     while(count>0)     {         sum+=count/b;         count=count/b;     }     return sum; }  int main() {     int t; cin>>t;     while(t--)     {         int n; cin>>n;         cout<<counter(n,2)<<"\n"<<counter(n,3)<<"\n"<<counter(n,5)<<"\n";     }     return 0; } 
#include<bits/stdc++.h>  #define mod 1000000007 #define f(i,a,b) for(i=a;i<b;i++) #define ff(i,a)  for(i=0;i<a;i++) #define sc scanf #define pr printf #define clr(a) memset(a,0,sizeof(a)) #define ll long long  #define vi vector<int> #define pin(n) printf("%d\n",n) #define pll(n) printf("%lld\n",n) #define sin(n) scanf("%d",&n) #define sll(n) scanf("%lld",&n) #define pins(n) printf("%d ",n) #define plls(n) printf("%lld ",n) #define ss(n) scanf("%s",n) #define nl pr("\n") #define pb push_back #define lb lower_bound #define ub upper_bound #define sl(a) strlen(a)  using namespace std;  inline void sins(int &x) { 	register int c = getchar_unlocked(); 	x = 0; 	int neg = 0; 	for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked()); 	if(c=='-') { 		neg = 1; 		c = getchar_unlocked(); 	} 	for(; c>47 && c<58 ; c = getchar_unlocked()) { 		x = (x<<1) + (x<<3) + c - 48; 	} 	if(neg) 		x = -x; }  int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		int n,i,j,k,l,m,p,x,y; 		sins(n);sins(m);sins(k); 		sins(x); 		p=0; 		ff(i,x) 		{ 			l=max(n,m); 			l=max(l,k); 			if(l>=1) 			{ 				p+=l; 				if(l==n) 					n--; 				else 				{ 					if(l==m) 						m--; 					else 						k--; 				} 			} 		}  		pin(p); 	} 	return 0; }  
#include<bits/stdc++.h>  #define mod 1000000007 #define f(i,a,b) for(i=a;i<b;i++) #define ff(i,a)  for(i=0;i<a;i++) #define sc scanf #define pr printf #define clr(a) memset(a,0,sizeof(a)) #define ll long long  #define vi vector<int> #define pin(n) printf("%d\n",n) #define pll(n) printf("%lld\n",n) #define sin(n) scanf("%d",&n) #define sll(n) scanf("%lld",&n) #define pins(n) printf("%d ",n) #define plls(n) printf("%lld ",n) #define ss(n) scanf("%s",n) #define nl pr("\n") #define pb push_back #define lb lower_bound #define ub upper_bound #define sl(a) strlen(a)  using namespace std;  inline void sins(int &x) { 	register int c = getchar_unlocked(); 	x = 0; 	int neg = 0; 	for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked()); 	if(c=='-') { 		neg = 1; 		c = getchar_unlocked(); 	} 	for(; c>47 && c<58 ; c = getchar_unlocked()) { 		x = (x<<1) + (x<<3) + c - 48; 	} 	if(neg) 		x = -x; }  int n,a[50],b[50];  int find(int id) {  	if(b[id]>=0) 		return b[id]; 	int i,j,k;  	k=0; 	f(i,id+1,n) 	{ 		if(a[i]>a[id]) 		{ 			j=find(i); 			if(j>k) 				k=j; 		} 	} 	b[id]=k+1; 	return k+1; }  int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		int i,j,k,l,m,p,x,y; 		sins(n); 	//	int a[50]; 		ff(i,n) 		{ 			b[i]=-1; 			sins(a[i]); 		}  	//	int b[50]; 		b[n-1]=1;  		pin(find(0));   	} 	return 0; }  
#include "iostream"  using namespace std;  int main() { 	int i, t, w, b; 	i = 0;  	cin >> t; 	while(i++ < t) 	{ 		cin >> w >> b;  		cout << "Case #" << i << ": "; 		if(b & 1) 			cout << "BLACK" << '\n'; 		else 			cout << "WHITE" << '\n'; 	} 	return 0; }
//coder: amansharma26  #include<iostream> #include<stdio.h> #include<string.h>  using namespace std;  int main() { 	long int t,i,j,k,c; 	char b[1000];  	cin>>t; 	cin.getline(b,1000); 	for(int p=1;p<=t;p++) 	{ 		cin.getline(b,1000); 		k=strlen(b); 		b[-1]=' '; 		for(i=k-1;i>=-1;i--) 		{ 			if(b[i]=='\n') 				goto c; 			if(b[i]==' ') 			{ 				for(j=i+1;j<k;j++) 				{ 					cout<<b[j]; 				} 				if(i!=-1) 					cout<<" "; 				k=i; 			} 		} 		c: 		cout<<"\n" ; 	}  	return 0; } 
#include<stdio.h> int main() { 	int t; 	scanf("%d",&t);  	while(t--) 	{ 		int i,n; 		scanf("%d",&n); 		int ans=1; 		for(i=1;i<n;i++) 		{ 			if(i%2==1) 				ans=(ans*3)-1; 			else 				ans=(ans*3)+1; 		}  		printf("%d\n",ans); 	} 	return 0; }
    #include<bits/stdc++.h>     using namespace std;     #define ll long long     bool HasUniquePrime(ll A, ll B) {       if (B == 1) return false;             ll d = __gcd(A, B);       if (d == 1) return true;       return HasUniquePrime(A, B/d);     }     int main()     {       ll t;       cin>>t;       while(t--)       {         ll a,b;         cin>>a>>b;         if(HasUniquePrime(a,b))         cout<<"No"<<"\n";         else         cout<<"Yes"<<"\n";       }       return 0;      } 
#include <cstdio> #include <cstring> #include <algorithm> #include <cmath> #include <cstdlib> using namespace std; typedef long long ll; const ll INF = 10000000000000ll; const int N = 4e5 + 10; ll a[N], b[N]; ll d, step, change; int n; int main() { 	int T; 	scanf("%d", &T); 	while(T--) { 		scanf("%d", &n); 		for(int i = 1; i <= n; i++) 			scanf("%lld", &a[i]); 		for(int i = 1; i <= n; i++) 			scanf("%lld", &b[i]); 		scanf("%lld", &d);  		ll MIN = INF, MINi = 1, time; 		for(int i = 1; i <= n; i++) { 			change = a[i] - b[i]; 			step = d - a[i]; 			if(step < 0) { 				time = d; 			}else { 				int x = step / change + (step % change != 0); 				time = x * (a[i] + b[i]) + (d - x * change); 			} 			if(time < MIN) { 				MIN = time; 				MINi = i; 			} 		} 		printf("%lld\n", MINi); 	} 	return 0; }
#include <iostream> #include <stdio.h> #include <math.h> using namespace std; typedef long long int ll;  void primeFactors(ll n) {          if(n%6==0)         {             cout<<"Misha\n";         }         else cout<<"Chef\n"; } int main() {     ll n,t;     cin>>t;     while(t--)     {         cin>>n;         primeFactors(n);     }     return 0; } 
#include <bits/stdc++.h> #define mod 1000000007 typedef long long int ll; using namespace std;  ll A[1111111];  int main() {     ll t, fact, n, a, i, j, k;     cin >> t;     fact = 1;     A[0] = 0;     A[1] = 1;     for (i = 2; i <= 1000000; i++) {         fact = (((fact * i) + mod) % mod);         A[i] = ((A[i - 1] + fact + mod) % mod);     }      while (t--) {         cin >> a >> n;         cout << (A[n] - A[a-1] + mod) % mod << endl;     }      return 0; } 
#include<bits/stdc++.h>  using namespace std;  // The codes which I use are taken from the book Competitive Programming 3 written by Steven Halim // Shortcuts for "common" data types in contests typedef long long int ll; typedef vector<int> vi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef set<int> si; typedef map<string, int> msi; // To simplify repetitions/loops, Note: define your loop style and stick with it! #define s(i) scanf("%d",&i) #define sl(i) scanf("%ld",&i) #define sll(i) scanf("%lld",&i) #define REP(i, a, b) \ for (int i = int(a); i <= int(b); i++) // a to b, and variable i is local! #define NREP(i,a,b) \ for (int i = int(a); i >= int(b); i--) #define TRvi(c, it) \ for (vi::iterator it = (c).begin(); it != (c).end(); it++) #define TRvii(c, it) \ for (vii::iterator it = (c).begin(); it != (c).end(); it++) #define TRmsi(c, it) \ for (msi::iterator it = (c).begin(); it != (c).end(); it++) #define INF 2000000000 // 2 billion  bool cmp( ii lhs , ii rhs ) {     return( ( double( lhs.first ) / double( lhs.second ) )  - ( double( rhs.first ) / double( rhs.second ) )  > 1e-9 ); }  int main() {     //freopen("input.txt","r",stdin);     //freopen("output.txt","w",stdout);     int t;s(t);     while( t-- )     {         int n , w;s(n);         vector < ii > vals;         scanf("%d",&w);         REP( i , 0  , n - 1 )         {             ii tmp;             scanf("%d%d",&tmp.second ,&tmp.first );             vals.push_back( tmp );         }         sort( vals.begin() , vals.end() , cmp );         double ans = 0;         int i = 0;         while( w > 0 && i < n )         {             int tmp = min( w , vals[i].second );             ans += double( tmp ) * ( double( vals[i].first  ) / double ( vals[i].second ) );             w -= tmp;             i++;         }         printf("%0.6lf\n",ans);     }     return 0; } 
#include <cstdio> #include <cstring>  long long to_base5(long long n) { 	if(n == 0) return 0; 	return (n % 5) + 10 * to_base5(n / 5); }  int main(int argc, char ** argv) { 	int T; 	scanf("%d", &T);  	long long K; 	for(int i = 0; i < T; i++) { 		scanf("%lld", &K); 		printf("%lld\n", 2 * to_base5(K - 1)); 	}  	return 0; } 
#include<stdio.h> long long int fun(long long int a,long long int b) {     long long int i,m=1000000007,arr[65],ans,v,mask,temp=1;     arr[0]=a%m; ans=1;         for(i=1;i<65;i++)         arr[i]=(arr[i-1]*arr[i-1])%m;         for(i=0;i<62;i++)         {             v=b&(temp<<i);             mask=1<<i;             if((v^mask)==0) ans=(ans*arr[i])%m;         }         return ans; } int main() {     long long int i,j,t,n,KK,array[100005],permu[100005],mod=1000000007;      scanf("%lld",&t);      permu[0]=1;permu[1]=1;     for(i=2;i<100005;i++)     {       permu[i]=(permu[i-1]*(i%mod))%mod;     }     for(i=0;i<t;i++)     {         long long int count=0;         scanf("%lld%lld",&n,&KK);         for(j=0;j<n;j++)         {             scanf("%lld",&array[j]);             if(array[j]==0) count=count+1;         }   long long int sum,p,flag,ans,a,b;     if(count==0)     {         if(KK>=n)         {          ans=fun(2,(n-1));         printf("%lld\n",ans);         }         else         {             if(KK%2==0)             {     sum=0;                 for(p=0;p<=KK;p=p+2)                 {                   a=(permu[n-p]*permu[p])%mod;                   b=mod-2;                  ans=fun(a,b);                  flag=(permu[n]*ans)%mod;                  sum=(sum+flag)%mod;                 }               printf("%lld\n",sum);             }              else             {                     sum=0;                 for(p=1;p<=KK;p=p+2)                 {                   a=(permu[n-p]*permu[p])%mod;                   b=mod-2;                  ans=fun(a,b);                flag=(permu[n]*ans)%mod;                sum=(sum+flag)%mod;             }              printf("%lld\n",sum);             }        }     }     else  //-----------------------------------     {        if(KK>=(n-count))         {             if((n-count)==0) printf("1\n");             else{                 ans=fun(2,(n-count));                 printf("%lld\n",ans);                 }         }         else         {                 sum=0;                 for(p=0;p<=KK;p++)                 {                   a=(permu[n-count-p]*permu[p])%mod;                   b=mod-2;                  ans=fun(a,b);                  flag=(permu[n-count]*ans)%mod;                  sum=(sum+flag)%mod;                 }               printf("%lld\n",sum);         }      }   }   }  
#include <iostream> using namespace std; long long int n,k,i,j=0,c=0,a[500002],s=0,ans=0; int main(void){     cin >> n;     for(i=0;i<n;i++){         cin >> a[i];         s+=a[i];     }     for(i=0;i<n-1;i++){         j+=a[i];         if((j*3)==(s*2))             ans+=c;         if(j*3==s)             c++;     }         cout << ans << endl;                                                           return 0; }
#include<bits/stdc++.h> using namespace std; int main() {     int t;     scanf("%d",&t);     while(t--)     {         int n,q,l,r,g,maxx=INT_MIN;        scanf("%d %d",&n,&q);         int c[100001]={0};         for(int i=1;i<=n;i++)         {             scanf("%d %d",&l,&r);             c[l]++;             c[r+1]--;             maxx=max(r,maxx);         }         for(int i=1;i<=maxx;i++)             c[i]=c[i]+c[i-1];         for(int i=0;i<q;i++)         {             scanf("%d",&g);             printf("%d\n",c[g]);         }      } } 
#include <bits/stdc++.h> #define mod 1000000007 #define gc getchar_unlocked #define pc(x) putchar_unlocked(x); using namespace std; typedef long long int lli; void scanint(int &x) {     register int c = gc();     x = 0;     for(;(c<48 || c>57);c = gc());     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} } int main() { 	int t,n,m,a[100005],b[100005],i,l,r,c; 	scanint(t); 	while(t--) 	{ 		scanint(n); 		scanint(m); 		for(i=1;i<=n;i++) 			scanint(a[i]); 		memset(b,0,sizeof(b)); 		for(i=0;i<m;i++) 		{ 			scanint(l); 			scanint(r); 			b[l]++; 			b[r+1]--; 		} 		c=0; 		for(i=1;i<=n;i++) 		{ 			c+=b[i]; 			a[i]+=c; 			printf("%d ",a[i]); 		} 		printf("\n"); 	} }
 #include <bits/stdc++.h> #define N 21   #define cout2(x, y) cout << x << " " << y << endl #define pb(x) push_back(x) #define all(x) x.begin(), x.end() #define INF (1<<30) #define M 1000000007   using namespace std;  long long memo[1<<N]; int a[N][N];   int main() { 	 	int tc = 0; 	scanf("%d", &tc); 	 	while(tc--){ 		 		int n, m; 		scanf("%d%d", &n, &m); 		 		memset(a, 0, sizeof a); 		int u, v; 		 		for(int i = 0; i < m; i++){	 			 			scanf("%d%d", &u, &v); 			u--, v--; 			a[u][v] = 1; 			 		} 		  		memo[0] = 1; 		for(int i = 1; i < (1<<n); i++){ 			 			int bit = __builtin_popcount(i); 			memo[i] = 0; 			 			for(int j = 0; j < n; j++){ 				 				if((i>>j)&1){ 					 					memo[i] = ( memo[i] + (a[n - bit][j] * memo[i - (1<<j)]) % M ) % M; 				} 			} 			 			memo[i] %= M; 			if(memo[i] < 0) memo[i] += M; 		} 		 		printf("%lld\n", memo[(1<<n) - 1]); 	}  	 }
import java.io.IOException; import java.io.InputStream;  public class Main {      public static void main(String[] args) throws IOException {         InputReader reader = new InputReader(System.in);         int T = reader.readInt();         StringBuilder output = new StringBuilder();         for (int t=0; t<T; t++) {             int N = reader.readInt();             String s = reader.readString(N);             long[] C = reader.readLongArray(N);             long[][] dp = new long[N+1][15];             for (int n=1; n<=N; n++) {                 char c = s.charAt(n-1);                 long cost = C[n-1];                 // 0: R                 // 5: GR                 // 6: BR                 // 11: GBR                 // 12: BGR                 if (c == 'R') {                     dp[n][0] = dp[n-1][0];                     dp[n][5] = Math.min(dp[n-1][1],dp[n-1][5]);                     dp[n][6] = Math.min(dp[n-1][2],dp[n-1][6]);                     dp[n][11] = Math.min(dp[n-1][11],Math.min(dp[n-1][8],dp[n-1][1]));                     dp[n][12] = Math.min(dp[n-1][12],Math.min(dp[n-1][4],dp[n-1][2]));                 } else {                     dp[n][0] = dp[n-1][0]+cost;                     dp[n][5] = Math.min(dp[n-1][1],dp[n-1][5])+cost;                     dp[n][6] = Math.min(dp[n-1][2],dp[n-1][6])+cost;                     dp[n][11] = Math.min(dp[n-1][11],Math.min(dp[n-1][8],dp[n-1][1]))+cost;                     dp[n][12] = Math.min(dp[n-1][12],Math.min(dp[n-1][4],dp[n-1][2]))+cost;                 }                 // 1: G                 // 3: RG                 // 4: BG                 // 13: RBG                 // 14: BRG                 if (c == 'G') {                     dp[n][1] = dp[n-1][1];                     dp[n][3] = Math.min(dp[n-1][0],dp[n-1][3]);                     dp[n][4] = Math.min(dp[n-1][2],dp[n-1][4]);                     dp[n][13] = Math.min(dp[n-1][13],Math.min(dp[n-1][7],dp[n-1][0]));                     dp[n][14] = Math.min(dp[n-1][14],Math.min(dp[n-1][6],dp[n-1][2]));                 } else {                     dp[n][1] = dp[n-1][1]+cost;                     dp[n][3] = Math.min(dp[n-1][0],dp[n-1][3])+cost;                     dp[n][4] = Math.min(dp[n-1][2],dp[n-1][4])+cost;                     dp[n][13] = Math.min(dp[n-1][13],Math.min(dp[n-1][7],dp[n-1][0]))+cost;                     dp[n][14] = Math.min(dp[n-1][14],Math.min(dp[n-1][6],dp[n-1][2]))+cost;                 }                 // 2: B                 // 7: RB                 // 8: GB                 // 9: RGB                 // 10: GRB                 if (c == 'B') {                     dp[n][2] = dp[n-1][2];                     dp[n][7] = Math.min(dp[n-1][0],dp[n-1][7]);                     dp[n][8] = Math.min(dp[n-1][1],dp[n-1][8]);                     dp[n][9] = Math.min(dp[n-1][9],Math.min(dp[n-1][3],dp[n-1][0]));                     dp[n][10] = Math.min(dp[n-1][10],Math.min(dp[n-1][5],dp[n-1][1]));                 } else {                     dp[n][2] = dp[n-1][2]+cost;                     dp[n][7] = Math.min(dp[n-1][0],dp[n-1][7])+cost;                     dp[n][8] = Math.min(dp[n-1][1],dp[n-1][8])+cost;                     dp[n][9] = Math.min(dp[n-1][9],Math.min(dp[n-1][3],dp[n-1][0]))+cost;                     dp[n][10] = Math.min(dp[n-1][10],Math.min(dp[n-1][5],dp[n-1][1]))+cost;                 }             }             long min = Long.MAX_VALUE;             for (long value : dp[N]) {                 min = Math.min(min, value);             }             output.append(min).append('\n');         }         System.out.print(output);     }      static final class InputReader {         private final InputStream stream;         private final byte[] buf = new byte[1024];         private int curChar;         private int numChars;          public InputReader(InputStream stream) {             this.stream = stream;         }          private int read() throws IOException {             if (curChar >= numChars) {                 curChar = 0;                 numChars = stream.read(buf);                 if (numChars <= 0) {                     return -1;                 }             }             return buf[curChar++];         }          public final int readInt() throws IOException {             return (int)readLong();         }          public final long readLong() throws IOException {             int c = read();             while (isSpaceChar(c)) {                 c = read();                 if (c == -1) throw new IOException();             }             boolean negative = false;             if (c == '-') {                 negative = true;                 c = read();             }             long res = 0;             do {                 res *= 10;                 res += c - '0';                 c = read();             } while (!isSpaceChar(c));             return negative ? -res : res;         }          public final String readString(int length) throws IOException {             char[] A = new char[length];             int c = read();             while (isSpaceChar(c)) {                 c = read();                 if (c == -1) throw new IOException();             }             A[0] = (char)c;             for (int n=1; n<length; n++) {                 A[n] = (char)read();             }             return new String(A);         }          public final int[] readIntArray(int size) throws IOException {             int[] array = new int[size];             for (int i=0; i<size; i++) {                 array[i] = readInt();             }             return array;         }          public final long[] readLongArray(int size) throws IOException {             long[] array = new long[size];             for (int i=0; i<size; i++) {                 array[i] = readLong();             }             return array;         }          private boolean isSpaceChar(int c) {             return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;         }     }  } 
#include<iostream> #include<cstdlib> #include<algorithm> #include<stdio.h> #include<vector> #include<map> #define ll long long #define pb push_back using namespace std ;  int st[100002],en[100002];  int ispow[100002];  int maxm[100002]; int main(void) {     int n ,i,n1,n2,j;       vector<int>v;     for(i=1;i<=100000;++i){        v.clear();        int num = i;        while(num>0){           if(num&1)              v.push_back(1);           else              v.push_back(0);              num/=2;        }        int ct = 0;        for(j=0;j<v.size();++j)          if(v[j]==1)            ct++;         else            break;           en[i] = ct;           ct = 0;         for(j=v.size()-1;j>=0;--j)           if(v[j]==1)            ct++;         else            break;           st[i] = ct ;         if(st[i]==v.size())           ispow[i]=1;          else            ispow[i]=0;                      maxm[i] = 0;          ct = 0;          for(j=0;j<=v.size()-1;++j){              if(v[j]==1)                 ct++;              else                 ct = 0;               maxm[i] = max(maxm[i],ct);                  }     }               int t,l,r;     cin>>t;     while(t--){          scanf("%d%d",&l,&r);        int ans = 0;        int fsmax = 0 , ssmax = 0,  femax = 0 , semax = 0;        int smax1,smax2,emax1,emax2;        for(i=l;i<=r;++i){                                     if(ispow[i]!=0)              ans +=st[i];           else{              if(st[i]>fsmax){                 fsmax = st[i];                 smax1 = i;              }              else if(st[i]>ssmax){                 ssmax = st[i];                 smax2 = i;              }                if(en[i]>femax){                 femax = en[i];                 emax1 = i;              }              else if(en[i]>semax){                 semax = en[i];                 emax2 = i;              }           }        }       // cout<<fsmax<<" "<<semax<<" "<<ssmax<<" "<<femax<<endl;       // cout<<ans<<endl;        getchar();        if(smax1==smax2)          ans =  ans + max(fsmax+semax,ssmax+femax);        else          ans = ans + fsmax + femax;        for(i=l;i<=r;++i)           ans = max(ans,maxm[i]);        printf("%d\n",ans);     }              return 0; } 
#include <bits/stdc++.h> using namespace std;  int main () { 	int n; 	int v[100013]; 	scanf("%d",&n); 	for (int i=1; i<=n; i++) { 		scanf("%d",&v[i]); 	} 	int q; 	scanf("%d",&q); 	int a, b; 	while (q--) { 		scanf("%d%d",&a,&b); 		bool flag = false; 		int ans = v[a]; 		for (int i=a+1; i<b; i++) { 			if (v[i]>ans) { 				flag = true; 				break; 			} 		} 		if (flag==true) { 			printf("NO\n"); 		} 		else { 			printf("YES\n"); 		} 	} 	return 0; } 
#if defined (_MSC_VER) && (!ONLINE_JUDGE) #pragma comment(linker, "/STACK:16777216") #pragma warning(once: 4309 4244 4005 4018) #define _CRT_SECURE_NO_WARNINGS #define _CRT_SECURE_NO_DEPRECATE #define _CRT_DISABLE_PERFCRIT_LOCKS #define gc _getc_nolock #define pc _putc_nolock #include <utils.h> #include <mymaths.h> #include <bigint.h> #include <InfInt.h> #include <safeint.h> using namespace msl::utilities; // e.g.: 	SafeInt<int> n = INT32_MAX; n += 1; throws exception! #else #define gc getc_unlocked #define pc putc_unlocked #endif  #include <bits/stdc++.h> using namespace std;  typedef unsigned int uint; typedef unsigned long long uint64; typedef long long int64;  static struct IO { 	char tmp[1 << 10];  	// fast input routines - http://ideone.com/fOK6CW 	char cur;  	inline char nextChar ( ) 	{ 		return cur = gc (stdin); 	} 	inline char peekChar ( ) 	{ 		return cur; 	}  	inline operator bool ( ) 	{ 		return 0 != peekChar ( ); 	} 	inline static bool isBlank (char c) 	{ 		return (c < '-' && c); 	} 	inline bool skipBlanks ( ) 	{ 		while (isBlank (nextChar ( ))); return peekChar ( ) != 0; 	}  	inline IO& operator >> (char & c) 	{ 		c = nextChar ( ); return *this; 	}  	inline IO& operator >> (char * buf) 	{ 		if (skipBlanks ( )) { 			if (peekChar ( )) { 				*(buf++) = peekChar ( ); 				while (!isBlank (nextChar ( ))) *(buf++) = peekChar ( ); 			} *(buf++) = 0; 		} return *this; 	}  	inline IO& operator >> (string & s) 	{ 		if (skipBlanks ( )) { 			s.clear ( ); s += peekChar ( ); 			while (!isBlank (nextChar ( ))) s += peekChar ( ); 		} 		return *this; 	}  	inline IO& operator >> (double & d) 	{ 		if ((*this) >> tmp) sscanf (tmp, "%lf", &d); return *this; 	}  #define defineInFor(intType) \ 	inline IO& operator >>(intType & n) { \ 		if (skipBlanks()) { \ 			int sign = +1; \ 			if (peekChar() == '-') { \ 				sign = -1; \ 				n = nextChar() - '0'; \ 			} else \ 				n = peekChar() - '0'; \ 			while (!isBlank(nextChar())) { \ 				n += n + (n << 3) + peekChar() - 48; \ 			} \ 			n *= sign; \ 		} \ 		return *this; \ 	}  	defineInFor (int) 		defineInFor (unsigned int) 		defineInFor (long long) 		defineInFor (unsigned long long)  		// fast output routines 		inline void putChar (char c) 	{ 		pc (c, stdout); 	} 	inline IO& operator << (char c) 	{ 		putChar (c); return *this; 	} 	inline IO& operator << (const char * s) 	{ 		while (*s) putChar (*s++); return *this; 	}  	inline IO& operator << (const string & s) 	{ 		for (int i = 0; i < (int) s.size ( ); ++i) putChar (s[i]); return *this; 	}  	char * toString (double d) 	{ 		sprintf (tmp, "%lf%c", d, '\0'); return tmp; 	} 	inline IO& operator << (double d) 	{ 		return (*this) << toString (d); 	}   #define defineOutFor(intType) \ 	inline char * toString(intType n) { \ 		char * p = (tmp + 30); \ 		if (n) { \ 			bool isNeg = 0; \ 			if (n < 0) isNeg = 1, n = -n; \ 			while (n) \ 				*--p = (n % 10) + '0', n /= 10; \ 			if (isNeg) *--p = '-'; \ 		} else *--p = '0'; \ 		return p; \ 	} \ 	inline IO& operator << (intType n) { return (*this) << toString(n); }  #define defineOutForU(intType) \ 	inline char * toString(intType n) { \ 		char * p = (tmp + 30); \ 		if (n) { \ 			while (n) \ 				*--p = (n % 10) + '0', n /= 10; \ 		} else *--p = '0'; \ 		return p; \ 	} \ 	inline IO& operator << (intType n) { return (*this) << toString(n); }  	defineOutFor (int) 		defineOutFor (long long) 		defineOutForU (unsigned long long)  #define endl ('\n') #define cout __io__ #define cin __io__ } __io__;  class TimeTracker { 	clock_t start, end; public: 	TimeTracker ( ) 	{ 		start = clock ( ); 	} 	~TimeTracker ( ) 	{ 		end = clock ( ); 		fprintf (stderr, "%.3lf s\n", (double) (end - start) / CLOCKS_PER_SEC); 	} }; #ifdef ONLINE_JUDGE // insert here functions from mymath.h, bigint.h, utils.h #endif  //using namespace jj;		// http://www.jjj.de/fxt/#fxtbook				  int main ( ) { 	//cin.sync_with_stdio(0); cin.tie(0); #ifndef ONLINE_JUDGE 	//freopen ("input.txt", "rt", stdin); 	//freopen ("output.txt", "wt", stdout); 	TimeTracker tt; 	// at return, destructor of TimeTracker tt is called, thus it shows elapsed time in stderr #endif 	//cout << jj::gcd (16, 24); 	int t; 	cin >> t; 	while (t--) { 		int n; 		cin >> n; 		int c[101] { }; 		for (int i = 0; i < n; i++) { 			int d; cin >> d; 			c[d]++; 		} 		for (int i = 1; i <= 100; i++) { 			if (c[i] == 1) { 				cout << i << endl; 				break; 			} 		} 	} }
#include<iostream> #include<cstdio> #define SI(x) scanf("%d",&x) using namespace std; int main() {     int t;     SI(t);     while(t-- >0)     {         int n;         SI(n);         bool ok = false;         int nf = n/7;         for(int f=nf;f>=0;f--)         {             int rem = n-(f*7);             if(rem%4==0)             {                 printf("%d\n",f*7);                 ok = true;                 break;             }         }          if(!ok) printf("-1\n");     }      return 0; } 
#include<iostream> #include<algorithm> #include<climits> using namespace std; long long int Dist[1004][1004];  int main() { 	long long int n,m,k; 	cin>>n>>m>>k; 	for (int i = 0; i < 1004; ++i) 	for (int j=0; j <1004; ++j) 	     if(i!=j) 	        Dist[i][j]=INT_MAX;  	while(m--) 	{ 		int x,y,w; 		cin>>x>>y>>w; 		Dist[x-1][y-1]=w; 		Dist[y-1][x-1]=w; 	} 	for(int k=0;k<n;k++){ 		for(int i=0;i<n;i++){ 			for(int j=0;j<n;j++){ 				if((Dist[i][k]+Dist[k][j])<Dist[i][j]){ 					 Dist[i][j]=Dist[i][k]+Dist[k][j]; 					 //cout<<Dist[i][j]<<endl; 					} 				} 			} 			 		} 	 		 	int q; 	cin>>q; 	while(q--) 	{ 		int u,v; 		cin>>u>>v; 		if(Dist[u-1][v-1]<=k)																											 			cout<<"YES"<<endl; 		else 			cout<<"NO"<<endl; 	}  }
#include <bits/stdc++.h> using namespace std;  int a[501][501];  int main(){     int t;     cin >> t;     while(t--){         int n,m;         cin >> n >> m;         for(int i = 1; i <= n; i++){             for(int j = 1; j <= m; j++) cin >> a[i][j];         }         for(int i = 2; i <= n + m; i++){             for(int j = 1; j <= i-1; j++) if(j <= n && i-j <= m)cout << a[j][i-j] << " ";         }         cout << endl;     } } 
#include <bits/stdc++.h>    #ifndef ONLINE_JUDGE     #define gc getchar     #define pc putchar #else     #define gc getchar_unlocked     #define pc putchar_unlocked #endif     using namespace std;     typedef long long ll; typedef vector<int> vi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef set<int> si; typedef map<string, int> msi;   template< class T > T _abs(T n) { return (n < 0 ? -n : n); }   template< class T > T _max(T a, T b) { return (!(a < b) ? a : b); }   template< class T > T _min(T a, T b) { return (a < b ? a : b); }     template< class T > T gcd(T a, T b) { return (b != 0 ? gcd<T>(b, a%b) : a); }   template< class T > T lcm(T a, T b) { return (a / gcd<T>(a, b) * b); }   template< class T > bool inside(T a, T b, T c) { return a<=b && b<=c; }       inline int fr() {     register int c = gc(); 	int x = 0;      for(; (c<48 || c>57); c = gc());     for(; c>47 && c<58 ; c = gc()) {         x = x*10 + c - 48; } return x;} inline void fp(int n){     if (n / 10 != 0)         fp(n / 10);     putchar((n % 10) + '0'); }  inline ll frl() {     register int c = gc(); 	ll x = 0;      for(; (c<48 || c>57); c = gc());     for(; c>47 && c<58 ; c = gc()) {         x = x*10 + c - 48; } return x;} inline void fpl(ll n){     if (n / 10 != 0)         fpl(n / 10);     putchar((n % 10) + '0'); }  #define SWAP(a,b) {a^=b;b^=a;a^=b;} #define MP(x, y) make_pair(x, y) #define SZ(a) int((a).size())      #define SET(p) memset(p, -1, sizeof(p))   #define SETINF(p) memset(p, 127, sizeof(p))   #define CLR(p) memset(p, 0, sizeof(p))     #define CPY(d, s) memcpy(d, s, sizeof(s))     #define PB(x) push_back(x)   #define bitcount      __builtin_popcount #define all(c) (c).begin(),(c).end()  #define present(c,x) ((c).find(x) != (c).end())  #define cpresent(c,x) (find(all(c),x) != (c).end())   #define fi first   #define se second      #define REP(i, a, b) for (int i = int(a); i < int(b); i++) // a to b, and variable i is local! #define REPN(i, a, b) for (int i = int(a); i <= int(b); i++) #define RTR(container, it) for(typeof(container.begin()) it = container.end()-1; it >= container.begin(); --it) #define TR(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); ++it)  #define TRY(i,o) freopen(i,"r",stdin); freopen(o,"w",stdout);  #define sf(n)                       scanf("%lf",&n) #define ss(n)                       scanf("%s",n)  #define INF 0x7f7f7f7f #define SINF 1000000000 //safe inf for floyd warshall  vi g[101]; map<int,int> searching;  void dfs(int v,int len){ 	if(len==2){ 		searching[v]++; 		return; 	} 	for(int i=0;i<g[v].size();++i){ 		dfs(g[v][i],len+1); 	} }  int main() {  	//TRY("in.txt","out.txt"); 	int n=fr(),m,a,b; 	m=fr(); 	while(m--){ 		a=fr();b=fr(); 		g[a].PB(b); 	} 	int ans=0; 	for(int i=1;i<=n;++i){ 		searching.clear(); 		dfs(i,0); 		TR(searching,it){ 			if((*it).fi!=i){ 				ans+=((((*it).se)*((*it).se-1))>>1); 			} 		} 	} 	fp(ans); 	return 0;   }   
#include <bits/stdc++.h> using namespace std;  int n,k; char arr[40][40]; int check(int a,int b) { 	int i,j,xcount=0,ycount=0,d1count=0,d2count=0; 	i=a-1; 	j=b; 	while(i>=0 && arr[i][j]=='X')			//left 	{ 		xcount++; 		i--; 	} 	i=a+1; 	j=b; 	while(i<n && arr[i][j]=='X')			//right 	{ 		xcount++; 		i++; 	} 	if(xcount>=k-1) 		return 1; 	i=a; 	j=b-1; 	while(j>=0 && arr[i][j]=='X')			//up 	{ 		ycount++; 		j--; 	} 	i=a; 	j=b+1; 	while(j<n && arr[i][j]=='X')			//down 	{ 		ycount++; 		j++; 	} 	if(ycount>=k-1) 		return 1; 	i=a-1; 	j=b-1; 	while(j>=0 && i>=0 && arr[i][j]=='X')		//diag1 	{ 		d1count++; 		i--; 		j--; 	} 	i=a+1; 	j=b+1; 	while(j<n && i<n && arr[i][j]=='X')			//diag1 	{ 		d1count++; 		i++; 		j++; 	} 	if(d1count>=k-1) 		return 1; 	i=a-1; 	j=b+1; 	while(j<n && i>=0 && arr[i][j]=='X')		//diag2 	{ 		d2count++; 		i--; 		j++; 	} 	i=a+1; 	j=b-1; 	while(i<n && j>=0 && arr[i][j]=='X')		//diag2 	{ 		d2count++; 		i++; 		j--; 	} 	if(d2count>=k-1) 		return 1;  	return 0; }  int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		int ans=0,i,j; 		cin>>n>>k; 		for(i=0;i<n;i++) 		{ 			for(j=0;j<n;j++) 			{ 				cin>>arr[i][j]; 			} 		} 		for(i=0;i<n && ans==0;i++) 		{ 			for(j=0;j<n && ans==0;j++) 			{ 					if(arr[i][j]=='.') 						ans=check(i,j); 					if(ans==1) 						cout<<"YES"<<endl; 			} 		} 		/*for(i=0;i<n;i++) 		{ 			for(j=0;j<n;j++) 			{ 				cout<<arr[i][j]; 			} 			cout<<endl; 		}*/ 		if(ans==0) 			cout<<"NO"<<endl;  	} }
//Problem Author's solution  #include<cstdio> int main() { 	//FILE *f1=freopen("in7.txt","r",stdin); 	//FILE *f2=freopen("out7.txt","w",stdout); 	long long int t,n,k,ans; 	scanf("%lld",&t); 	while(t--) 	{ 		scanf("%lld%lld",&n,&k); 		ans=n*(n-1)*(n-2)/6-k*(k-1)*(k-2)/6; 		printf("%lld\n",ans); 	} 	//fclose(f1); 	//fclose(f2); 	return 0; } 
#include<iostream> #include<cstdio> #include<cmath> #include<vector> #include<map> #include<set> #include<algorithm> #include<list> #include<cstring> #include<stack> #include<queue> using namespace std; #define ll long long #define vi vector<int> #define vii vector<vi > #define pp pair<int,int> #define pb push_back #define mp make_pair #define ppl pair<ll,ll> #define vl vector<ll> #define vll vector<vl > #define vb vector<bool> #define llu unsigned ll #define all(c) c.begin(),c.end() #define mod 1000000007 #define sc scanf #define pf printf ll power(ll a,ll b,ll m) { 	if(!b) 		return 1; 	if(b==1) 		return a; 	ll temp=power(a, b/2, m); 	temp=(temp*temp)%m; 	if(b&1) 		temp=(temp*a)%m; 	return temp; } class graph { 	vi * adj; 	int time; 	public: 		graph( int v) 		{ 			adj = new vi[v]; 			time = 0; 		} 		void add_edge(int u, int v) 		{ 			adj[u].pb( v); 			adj[v].pb( u); 		} }; int main() { 	ios_base::sync_with_stdio(false); 	int i, t, n, m, ans; 	ll top, bottom; 	cin >> t; 	while( t--) 	{ 	    cin >> n >> m; 	    vi v(n); 	    for( i=0;i<n;i++ ) 	   { 	       cin >> v[i]; 	   } 	   sort(v.begin(), v.end()); 	   top=bottom=0; 	   for( i=0;i<m;i++ ) 	    top += v[i]; 	   for( i=m;i<n;i++ ) 	   { 	       bottom += v[i]; 	   } 	   cout << (bottom-top) << "\n"; 	} }
#include <bits/stdc++.h> using namespace std;  bool is_prime(long n) { 	 	if (n== 1) 	  return false; 	if ( n%2 == 0) 	  return false; 	for (long i =3 ;i<= sqrt(n) ; i+=2) 	   if ( n %i == 0)  	     return false; 	      	return true ; 	 }  int main() { 	// your code goes here 	int t; 	cin>>t; 	while (t--) 	{ 		long long l, b; 		cin>>l>>b;      	if (l== 2 || l== 3 ) 		  l=1;	 		if (b== 2 || b== 3 ) 		  b=1;	 	 		if (is_prime(l)) 		  l--; 		if (is_prime(b)) 		  b--; 		cout<<l*b<<"\n"; 	} 	return 0; }
#include <iostream> #include <vector>  using namespace std;  int main(){ 	int T; 	cin >> T; 	string s; 	int freq[26]; 	int asciia  = (int)'a'; 	while(T--){ 		cin >> s; 		for(int i=0;i<26;i++) 			freq[i] = 0; 		for(int i=0;i<s.length();i++) 			freq[s[i]-asciia]++; 		int max=0; 		int maxc; 		for(int i=25; i>=0;i--){ 			if(freq[i] >= max){ 				max = freq[i]; 				maxc = i; 			} 		} 		for(int i=0;i<s.length();i++){ 			if((int)s[i] == maxc+asciia) 				s[i] = '?'; 		} 		cout << s << endl; 	} 	return 0; }
#include<bits/stdc++.h>  using namespace std;  int main() { 	int t,n,i; 	string ch; 	cin>>t; 	while(t--) 	{ 		cin>>n; 		cin.ignore(10,'\n'); 		getline(cin,ch); 		i=0; 		for(i=0;i<ch.size();i++) 		{ 		 			if(ch[i]==' ' ||ch[i]==','||ch[i]=='?') 				printf("%c",ch[i]); 			else if(ch[i]>='a' && ch[i]<='z' ) 				printf("%c",'a'+(ch[i]-'a'+n)%26); 			else if(ch[i] >='A' && ch[i]<='Z') 				printf("%c",'A'+(ch[i]-'A'+n)%26); 	 		} 		cout<<endl; 	} 	return 0; } 
#include<bits/stdc++.h> #define mod 1000000007 #define ll long long int  using namespace std;  ll n; vector<ll> vec[100100]; ll dp[100100];   ll visit[100100];  ll dfs(ll u) {     visit[u]=1;     ll ans=1;     ll child=0;     for(ll i=0;i<vec[u].size();i++)     {         ll v=vec[u][i];         if(visit[v]==0)         {             ans=(ans*(1+dfs(v)))%mod;             child=1;         }     }       //ans=(ans*fact[child])%mod;     //cout<<ans<<" "<<u<<" "<<child<<endl;     if(child==0) return dp[u]=1;     else return dp[u]=ans;  }  int main() {     //preCal();      //for(ll i=0;i<5;i++) cout<<fact[i]<<endl;      ll test;     scanf("%lld",&test);      while(test--)     {         memset(visit,0,sizeof(visit));         for(int i=0;i<=100000;i++) vec[i].clear();         scanf("%lld",&n);          for(ll i=1;i<n;i++)         {             ll u,v;             scanf("%lld %lld",&u,&v);             vec[u].push_back(v);             vec[v].push_back(u);          }          dfs(1);          ll ans=0;         for(int i=1;i<=n;i++) ans=(ans+dp[i])%mod;          printf("%lld\n",ans);      }        return 0; } 
#include <bits/stdc++.h> using namespace std; #define ll long long int int main() {     int t,i,count;cin>>t;     while(t--)     {ll n,m,a[101];     count=0;     cin>>n>>m;     for(i=0;i<n;i++)     {cin>>a[i];     a[i]=a[i]+m;     if(a[i]%7==0)     count++;              }     cout<<count<<"\n";              } 	// your code goes here 	return 0; } 
#include<bits/stdc++.h> using namespace std;  #define LL long long const int MAXN = 1e5 + 10; const LL MOD = 1e9 + 7;  int main(){     int n,x;     int t;     cin>>t;     while(t--){         cin>>n;         int cnt = -1;         for(int i = 1;i <= n;++i){             cin>>x;             if(x == -1){                 ++cnt;             }         }         cout<<cnt*0.5 + 1<<"\n";     }     return 0; }
#include<bits/stdc++.h> using namespace std; int N ; int arr[109] ; int dp[109][109] ;  int solve(int l ,int r) { 	if(l>r) 	  return 0; 	if(dp[l][r]!=-1) 	  return dp[l][r] ; 	int in1=0,in2=0,in3=0,in4=0; 	for(int i=1;i<l;i++) 	{ 		if(arr[i]>arr[l])  in1++; 		if(arr[i]<arr[l])  in2++; 		if(arr[i]>arr[r])  in3++; 		if(arr[i]<arr[r])  in4++; 	} 	for(int i=r+1;i<=N;i++) 	{ 		if(arr[i]>arr[l])  in1++; 		if(arr[i]<arr[l])  in2++; 		if(arr[i]>arr[r])  in3++; 		if(arr[i]<arr[r])  in4++; 	} 	int temp1 = min(in1,in2) + solve(l+1,r) ; 	int temp2 = min(in3,in4) + solve(l,r-1) ; 	return dp[l][r] = min(temp1,temp2) ; } int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		memset(dp,-1,sizeof(dp)) ; 		scanf("%d",&N) ; 		for(int i =1;i<=N;i++) 		  scanf("%d",&arr[i]) ; 		int ans = solve(1,N) ; 		printf("%d\n",ans) ; 	} }
#include <algorithm> #include <iostream> #include <cassert> #include <cstdio> #include <cstring> #include <cstdlib> #include <cmath>  #define m first #define c second #define NMAX 50010  using namespace std;   int tree[NMAX];  int N;  void init(){ 	int i; 	for(i = 0; i < N; ++i) tree[i] =0; }  void upd(int x){ 	for(;x < N; x+=(x&-x)){ 		tree[x]++; 		if(!x) break; 	} }  int query(int x){ 	int vl = 0; 	for(;x >=0;x-=(x&-x)){ 		vl += tree[x]; 		if(!x) break; 	}  	return vl; }   pair<double,double> lines[NMAX]; pair<int,int> l2[NMAX]; pair<double,int> order[NMAX];  long long K;  const double eps = 1e-9;  int comp(const pair<double,int> &a, const pair<double,int> &b){ 	if(fabs(a.first-b.first) <= eps) return a.second < b.second; 	return a.first < b.first; }  int check(double yy){ 	int i; 	long long ct; 	init();  	for(i =0 ; i < N; ++i) order[i] = make_pair(lines[i].m*yy+lines[i].c,i); 	sort(order,order+N);  	ct =0; 	for(i =0 ; i< N; ++i){ 		ct += query(order[i].second); 		upd(order[i].second); 	}   	return ct >= K; }  int comp2(const pair<int,int> &a, const pair<int,int> &b){ 	if(a.first == b.first) return a.second > b.second; 	return a.first > b.first; }  int comp3(const pair<int,int> &a, const pair<int,int> &b){ 	if(a.first == b.first) return a.second < b.second; 	return a.first > b.first; }  //m,c ints //points below it //all ms are distinct m > 0   const double lim = (2e4); const int iter = 100;  double search(){ 	double low,high,mid;  	low = -lim*lim*3; 	high = lim*lim*3;  	int i;  	for(i = 0; i < iter; ++i){ 		mid = low+(high-low)/2.0; 		if(check(mid)){ 			high = mid; 		}else{ 			low = mid; 		} 	}  	return low; }  int main(){ 	int m,c;  	scanf("%d%lld",&N,&K); 	int i; 	for(i =0; i < N; ++i){ 		scanf("%d%d",&m,&c); 		l2[i] = make_pair(m,-c); 	}  	sort(l2,l2+N); 	for(i = 0; i < N; ++i) if(l2[i].first > 0) break; 	if(i) sort(l2,l2+i,comp3); 	if(i < N) sort(l2+i,l2+N,comp2);   	for(i = 0; i < N; ++i){ 		m = l2[i].first; 		c = l2[i].second; 		lines[i] = make_pair(1.0/m,c*1.0/m); 		if(i) assert(lines[i].m-lines[i-1].m >= -1e-7); 	}  	printf("%.9lf\n",search());  	return 0; } 
#include<iostream> #include<cstdio> #include<vector> #include<algorithm> #include<string> #include<cmath> #include<set> #include<queue> #define ll long long using namespace std; ll mdp[1<<7][1<<7][102]; ll m; void init() { 	for(int i=0;i<(1<<7);++i) 		for(int j=0;j<(1<<7);++j) 			for(int k=0;k<102;++k) 				mdp[i][j][k]=-1; } int w; ll dp(int b,int pos,int h) { 	if(pos==0)return 0; 	if(h==1)return 1; 	if(mdp[b][pos][h]!=-1)return mdp[b][pos][h]; 	int npos=0; 	for(int i=0;i<w;++i) 	{ 		if(!((b>>i)&1)) 		{ 			if((i>0 && ((pos>>(i-1))&1)) || (i<w-1 && ((pos>>(i+1))&1))  || ((pos>>i)&1) ) 			{ 				npos+=(1<<i); 			} 		} 	} 	ll ans=0; 	for(int i=0;i<(1<<w);++i) 	{ 		ans+=dp(i,npos&((1<<w)-1-i),h-1); 	} 	ans%=m; 	return mdp[b][pos][h]=ans; } void doit() { 	int h; 	init(); 	scanf("%d%d%lld",&w,&h,&m); 	ll ans=0; 	for(int i=0;i<(1<<w);++i) 	{ 		if(!(i&1)) 		{ 			ans+=dp(i,1,h); 		} 	} 	ans%=m; 	printf("%lld\n",ans); } int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		doit(); 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; int main() {     int k;     cin>>k;     int a[k];     for(int i=0;i<k;i++)     {         cin>>a[i];     }     int sum;     cin>>sum;     int dp[sum+1];     dp[0]=1;     for(int i=1;i<=sum;i++)         dp[i]=0;     for(int i=0;i<k;i++)     {         for(int j=1;j<=sum;j++)         {             if(j>=a[i])                 dp[j]=dp[j]+dp[j-a[i]];         }     }     cout<<dp[sum]<<endl;     return 0; } 
#include<bits/stdc++.h> using namespace std; #define gc getchar_unlocked  inline int in() { 	char c=gc(); 	while(c<'0' || c>'9') 		c=gc(); 	int num=0; 	while(c>='0' && c<='9') { 		num=10*num+c-48; 		c=gc(); 	} 	return num; }  main() { 	int T,N,u,i,j,k,x,y,M,p; 	int a[10005]={0}; 	T=in(); 	while(T--) { 		N=in(); u=in(); 		for(x=0;x<u;x++) { 			i=in(); j=in(); k=in(); 			for(y=i;y<=j;y++) 				a[y]+=k; 		} 		M=in(); 		while(M--) { 			p=in(); 			printf("%d\n",a[p]); 		} 		for(i=0;i<N;i++) a[i]=0; 	} } 
#include<bits/stdc++.h>  using namespace std;  typedef long long ll; typedef unsigned long long ull; typedef vector<int> vi; typedef vector<ll> vll; typedef vector<vi> vvi; typedef pair<int,int> pii; typedef vector<pii > vii; typedef pair<ll,ll> pll; typedef vector<string> vs;  #define MOD 1000000007 #define pb push_back #define mp make_pair #define X first #define Y second #define MEM(a,b) memset(a,(b),sizeof(a)) #define pr(a) cout<<#a<<" = "<<(a)<<endl #define cin(n) int (n); scanf("%d", &(n)) #define cin2(n,m) int (n),(m); scanf("%d%d",&(n),&(m)) #define sz(a) int((a).size()) #define all(a) a.begin(),a.end() #define loop(x,a,b) for(int (x) = (a);(x)<(b);(x)++) #define rep(x,n)   for(int (x)=0;(x)<(n);(x)++) #define tr(c,it) for(typeof((c).begin()) it = (c).begin(); it != (c).end(); it++) #define prc(a) tr(a, it) cout<<*(it)<<" "; cout<<endl #define pra(a,n) for(int i=0; i<(n); i++) printf("%d ",((a)[i])); printf("\n") #define present(c,x) ((c).find(x) != (c).end()) #define cpresent(c,x) (find(all(c),x) != (c).end()) #define ain(a,n) int ((a)[(n)]); for(int i=0; i<(n); i++) scanf("%d",&((a)[i])) #define vin(a,n) vector<int> (a); (a).resize((n)); for(int i=0; i<(n); i++) scanf("%d",&((a)[i])) #define TEST cin(test);	while(test--) #define FILE  int main() { 	/*#ifdef FILE 	freopen("input.txt","r",stdin); 	freopen("output.txt","w",stdout); 	#endif*/ 	cin(t); 	while(t--) 	{cin2(n,k); 	int s=n/k,r=n%k; 	if(r!=0)         printf("%d\n",(s+1));     else printf("%d\n",s); }} 
#include<cstdio> #include<iostream> #include<algorithm> #define NN 10000005 using namespace std; int c[NN];  inline int max(int a, int b){return a>b?a:b;}  int main() {     int n, K, x, sum, cnt,ans=0;     scanf("%d%d", &n, &K);     for(int i=0; i<n; i++)     {         scanf("%d", &c[i]);     }     sort(c, c+n);     for(int i=0; i<n-1; i++)     {         cnt=0, sum=0;         while(sum<=K && i+cnt<n-1)         {             sum+= (cnt+1)*(c[i+cnt+1]- c[i+cnt]);             //cout<<sum<<" "<<cnt<<" "<<i<<endl;             if(sum<=K)  cnt++;          }         cnt++;         ans = max(ans,cnt);     }     printf("%d\n", ans); }  
#include <bits/stdc++.h> using namespace std;  int main(){     int t;     cin >> t;     while(t--){         int x,y;         cin >> x >> y;         if(x > y){             cout << "Bipin " << x-y << endl;         }else if(y > x){             cout << "Balaji " << y-x << endl;         }else{             cout << "No Winner" << endl;         }     } } 
#include <bits/stdc++.h> using namespace std; int main() {     int t;     std::ios::sync_with_stdio(false);     cin >> t;     while(t--)     {        	long long  n,a[123456],c=0,d;         cin >> n;         for(int i=0;i<n;i++)         {         	cin >> a[i];         }         sort(a,a+n);         while(a[0]!=a[n-1])         {             d=a[n-1]-a[0];             if(d==1)             for(int i=0;i<n-1;i++)             a[i]+=1;             else if(d<5)             for(int i=0;i<n-1;i++)             a[i]+=2;             else if(d>=5)             for(int i=0;i<n-1;i++)             a[i]+=5;             c++;             sort(a,a+n);         }         cout << c << endl;     }  } 
#include<bits/stdc++.h> #define ll long long int #define mp make_pair #define pb push_back #define si(x) scanf("%d",&x) #define pi(x) printf("%d\n",x) #define s(x) scanf("%lld",&x) #define p(x) printf("%lld\n",x)  using namespace std;  ll ar[1002][1002],sum[1002][1002],maxx[1002][1002]; int main(){ ll n,m,i,j,q; s(n);s(m); memset(sum,0,sizeof(sum)); for(i=1;i<=n;i++){         ll val=0;     for(j=1;j<=m;j++){         s(ar[i][j]);         val+=ar[i][j];         sum[i][j]=sum[i-1][j]+val;     } }  s(q); while(q--){     ll a,b;     s(a);s(b);     for(i=1;i<=n;i++){         deque<ll>Q;         for(j=1;j<=b;j++){           while(!Q.empty() && ar[i][j]>=ar[i][Q.back()])  Q.pop_back();           Q.pb(j);         }         for(j=b+1;j<=m;j++){             maxx[i][j-1]=ar[i][Q.front()];             while(!Q.empty() && ar[i][j]>=ar[i][Q.back()]) Q.pop_back();             while(!Q.empty() && Q.front()<=j-b) Q.pop_front();             Q.pb(j);         }         maxx[i][m]=ar[i][Q.front()];     }     ll ans=INT_MAX;     for(i=b;i<=m;i++){         deque<ll>Q;         for(j=1;j<=a;j++){             while(!Q.empty() && maxx[j][i]>=maxx[Q.back()][i]) Q.pop_back();             Q.pb(j);         }         for(j=a+1;j<=n;j++){             ll val=maxx[Q.front()][i];             ll temp=sum[j-1][i]-sum[j-1-a][i]-sum[j-1][i-b]+sum[j-1-a][i-b];             ans=min(ans,val*a*b-temp);             while(!Q.empty() && maxx[j][i]>= maxx[Q.back()][i]) Q.pop_back();             while(!Q.empty() && Q.front()<=j-a) Q.pop_front();             Q.pb(j);         }         ll val=maxx[Q.front()][i];         ll temp=sum[n][i]-sum[n-a][i]-sum[n][i-b]+sum[n-a][i-b];         ans=min(ans,val*a*b-temp);     }     p(ans); } return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { 	int t,n; 	cin>>t; 	 while(t--)      {        cin>>n; 	   string s; 	   cin>>s; 	   int a[n]; 	   a[0]=1; 	   a[1]=2; 	   for(int i=2;i<n;i++) 	   { 	   	a[i] = a[i-1] + a[i-2]; 	   } 	   for(int i=1;i<n;i++) 	   { 			if(s[i-1]>s[i])  			{ 			 swap(s[i-1],s[i]);  			 i++; 			} 		} 		cout<<a[n-1]<<endl; 		cout<<s<<endl;     } }
#include <bits/stdc++.h> using namespace std;  int main() {   int t;   cin>>t;   while(t--) {     int n;     scanf("%d", &n);     int arr[n];     int mx = INT_MIN;     for(int i=0;i<n;i++) {       scanf("%d", &arr[i]);       mx = max(mx, arr[i]);     }     int mn = mx;     mx = 0;     int i = 0, j = n-1;     sort(arr, arr+n);     int ar[n];     int idx = 0;     while(i < n/2) {       ar[idx] = arr[j];       idx++;       ar[idx] = arr[i];       idx++;       i++; j--;     }     if(n&1) {       ar[idx] = arr[i];       idx++;     }     //for(int i=0;i<n;i++) cout<<ar[i]<<" "; cout<<endl;     for(int i=0;i<n;i++) {       if(i == 0) mx += ar[i];       else {         mx += abs(ar[i]-ar[i-1]);       }     }     printf("%d %d\n", mx, mn);   }   return 0; }
/* The idea is to first convert the no to its ternary form    and then replace each digit with some character, divide the     ternary form by 10 and add some carry value and again compute:    1 -> 1   Carry = 0    0 -> 0	Carry = 0    2 -> -	Carry = 1    3 -> 0	Carry = 1 *  Author: thecodekaiser */ #include<iostream> #include<cstdlib> #include<cmath> #include<map> #include<string>  using namespace std;  typedef long long ll;   ll rev_num(ll num) { 	ll n = num; 	ll res = 0; 	while(n>0) 	{ 		int dig = n % 10; 		n /= 10; 		res = res*10 + dig; 	} 	return res; } ll convS(string num) { 	ll res = 0; 	for(int i = 0; i < num.length(); i++) 	{ 		res = res*10 + num[i] - '0'; 		if(num[i] == 0) 			res = res*10; 	} 	return res; }  ll conv(long num) { 	long n = num; 	ll div,rem; 	char ch; 	string res = ""; 	ll send; 	while(true) 	{ 		div = (long)(n/3); 		rem = n % 3; 		ch = rem + '0'; 		res = ch + res; 		if(div < 3) 			break; 		n = div; 	} 	if(div >= 1) 		ch = div + '0',  res = ch + res;  	send = convS(res); 	return send; }  int main() { 	ll p,con; 	bool flag = 0; 	string res = ""; 	scanf("%lld",&p); 	if(p < 0) 	{ 		flag = 1; 		p *= -1; 	} 	con = conv(p); 	//cout<<con<<endl; 	if(con == 0) 		res = "0"; 	while(con > 0) 	{ 		int dig = con % 10; 		if(dig == 0) 		{ 			res = '0' + res; 			con = con/10 + 0; 		} 		else if(dig == 1) 		{ 			res = '|' + res; 			con = con/10 + 0; 		} 		else if(dig == 2) 		{ 			res = '-' + res; 			con = con/10 + 1; 		} 		else if(dig == 3) 		{ 			res = '0' + res; 			con = con/10 + 1; 		} 	} 	if(flag == 1) 	{ 		for(int i = 0; i < res.length(); i++) 			if(res[i] == '|') 				res[i] = '-'; 			else if(res[i] == '-') 				res[i] = '|'; 	} 	cout<<res<<endl; 	return 0; } 	 
/* Here we are just required to find the four basic points    on the coordinate axes and do some math. */ #include<iostream> #include<set> #include<map> #include<vector> #include<queue> #include<stack> #include <iomanip> #include<algorithm> #include<math.h> #include<cstdio> #include<cstring>   using namespace std;   struct Point { 	double x; 	double y; };       double dist(Point A,Point B) { 	double p1,p2,s; 	p1 = pow((B.x-A.x),2); 	p2 = pow((B.y-A.y),2); 	s = p1+p2; 	s = sqrt(s); 	//cout<<s<<endl; 	return s; } void round_double(double & num, int to) { 	long places = 1, whole = *(&num); 	for(int i = 0; i < to; i++) places *= 10; 	num -= whole;              // Subtracts the integer part 	num *= places;			   // .1234  -> 123.4 	num = (long)floor(num); 	num /= places;			   // 123 -> .123 	num += whole;			   // Again add integer part to it }   inline void print(long double n){     n *= 1000;     n = round(n);     n /= 1000;     cout<<n<<endl; } int main() { 	double per;				// To store the perimeter 	Point A,B,C,D,P1,P2,P3,P4; 	// To store various contributions in each quadrant 	double C1,C2,C3,C4;   	scanf("%lf %lf",&A.x,&A.y); 	scanf("%lf %lf",&B.x,&B.y); 	scanf("%lf %lf",&C.x,&C.y); 	scanf("%lf %lf",&D.x,&D.y);   	/* 	printf("%lf %lf",A.x,A.y); 	printf("%lf %lf",B.x,B.y); 	printf("%lf %lf",C.x,C.y); 	printf("%lf %lf",D.x,D.y); 	*/   	P1.x = 0; 	P1.y = (((B.y - A.y)/(B.x - A.x))*(A.x)*(-1) + A.y) ; 	P2.y = 0;	 	P2.x = ((C.x - B.x)/(C.y- B.y))*(B.y)*(-1) + B.x ; 	P3.x = 0;	 	P3.y = ((D.y - C.y)/(D.x - C.x))*(C.x)*(-1) + C.y ; 	P4.y = 0;	 	P4.x = ((A.x - D.x)/(A.y - D.y))*(D.y)*(-1) + D.x ;   	per = dist(A,B) + dist(B,C) + dist(C,D) + dist(D,A);   	//cout<<P1.x<<" "<<P1.y<<endl; 	//cout<<P2.x<<" "<<P2.y<<endl; 	//cout<<P3.x<<" "<<P3.y<<endl; 	//cout<<P4.x<<" "<<P4.y<<endl;   	C1 = dist(A,P1) + dist(A,P4); 	C2 = dist(B,P1) + dist(B,P2); 	C3 = dist(C,P2) + dist(C,P3); 	C4 = dist(D,P3) + dist(D,P4);   	C1 = (C1/per) * 100;   //round_double(C1,3); 	C2 = (C2/per) * 100;   //round_double(C2,3); 	C3 = (C3/per) * 100;   //round_double(C3,3); 	C4 = (C4/per) * 100;   //round_double(C4,3);   	print(C1); 	print(C2); 	print(C3); 	print(C4);   	return 0; }
#include<iostream> #include<stdio.h> #include<vector> #include<set> #include<algorithm> #include<utility> using namespace std;  int main() { 	int t; 	scanf("%d",&t);  	while(t--) 	{ 		int n,m,x,y; 		scanf("%d %d",&n,&m); 		scanf("%d %d",&x,&y); 		string s[n+1]; 		 		for(int i=0;i<n;i++) 			cin >> s[i]; 		int a[n+1][m+1];  		for(int i=0;i<n;i++) 		{ 			int cnt = 0; 			for(int j=0;j<m;j++) 			{ 				if(s[i][j]=='#') 					cnt++; 				else 					cnt = 0; 				a[i][j] = cnt; 			} 		} 		set< pair<int,int> > ans; 		int cnt = 0; 		for(int j=0;j<m;j++) 		{ 			cnt = 0; 			for(int i=0;i<n;i++) 			{ 				//cout << cnt << endl; 				if(a[i][j]>=y) 					cnt++; 				else 					cnt = 0; 				if(cnt==x) 				{ 					pair<int,int> p; 					p = make_pair(i-x+1,j-y+1); 					ans.insert(p); 		//			cout << i-x+1 << " " << j-y+1 << endl; 					cnt--; 				} 			} 			 		} /*		if(x!=y) 		{ 		cnt =0 ; 		for(int j=0;j<m;j++) 		{ 			cnt = 0; 			for(int i=0;i<n;i++) 			{ 		//		cout << cnt << endl; 				if(a[i][j]>=x) 					cnt++; 				else 					cnt = 0; 				if(cnt==y) 				{ 					pair<int,int> p; 					p = make_pair(i-y+1,j-x+1); 					ans.insert(p); 					cnt--; 				} 			} 		} 		} //		sort(ans.begin(),ans.end()); */ 		int size = ans.size(); 		printf("%d\n",size); 		set< pair<int,int> >::iterator it; 		for(it=ans.begin();it!=ans.end();it++) 			printf("%d %d\n",(*it).first,(*it).second); 	} return 0; } 
#include <iostream> #include <map> #include <string>  using namespace std;  int main() { 	int t; 	cin >> t; 	string s; 	map<char,char> m; 	while(t--) 	{ 		cin >> s; 		m.clear(); 		int k = 0; 		for(int i = 0; i < s.size(); i++) 		{ 			if(m[s[i]]) 			{ 				cout << m[s[i]]; 			} else  			{ 				m[s[i]] = 'a' + k; 				k+=1; 				cout << m[s[i]] ; 			} 		} 		cout << endl; 	} } 
#include<iostream> #include<stdio.h> using namespace std;    int main() { int t; double o,r,s,ans; cin>>t; while(t--) { cin>>o>>r>>s; ans=((o*r)+s)/(o+1); printf("%.2f\n",ans);  } return 0; }
#include <bits/stdc++.h> #define ll long long int #define s(a) scanf("%lld",&a) #define f first #define sc second #define pb push_back #define mp make_pair #define VALUETYPE long long int #define inf 10e16 #define EVEN(x) ((x%2)==0) #define ODD(x) ((x%2)==1)  using namespace std;  ll tree[2000001]; ll lft[500001]; ll rgt[500001]; ll a[500001]; vector<pair<ll,ll> >v[500001]; vector<pair<ll,ll> >u[500001];  ll construct(ll l,ll r,ll ind) {     if(l>r) return 0;     if(l==r) {         tree[ind]=0;         return 0;     }     ll mid=(l+r)/2;     tree[ind]=max(construct(l,mid,2*ind),construct(mid+1,r,2*ind+1));     return tree[ind]; }  ll query(ll l,ll r,ll ind,ll x,ll y) {     if(l>r) return 0;     if(x>r || y<l) return 0;     if(x<=l && r<=y) return tree[ind];     ll mid=(l+r)/2;     return max(query(l,mid,2*ind,x,y),query(mid+1,r,2*ind+1,x,y)); }  ll xxx;  void yoman() {     ll ind=xxx;     while(ind>=1) {         tree[ind]=max(tree[2*ind],tree[2*ind+1]);         ind/=2;     } }  void update(ll l,ll r,ll ind,ll x,ll y) //change a[x]=y {     if(l>r) return;     if(l>x || r<x) return;     if(l==r) {         tree[ind]=y;         xxx = ind/2;         return;     }     ll mid=(l+r)/2;     update(l,mid,2*ind,x,y);     update(mid+1,r,2*ind+1,x,y); }  bool cmp(pair<ll,ll>x,pair<ll,ll>y) {     if(x.f < y.f) return true;     else if(x.f == y.f) {         if(x.sc > y.sc) return true;         else return false;     }     else return false; }  int main() {     ll t,n,i,j,k,l,w,ww,x,y,z;     s(n);     for(i=1;i<=n;i++) s(a[i]);     for(i=1;i<=n;i++) {         w = query(1,n,1,1,a[i]-1);         lft[i]=w;         update(1,n,1,a[i],w+1);         yoman();     }     construct(1,n,1);     for(i=n;i>=1;i--) {         w = query(1,n,1,a[i]+1,n);         rgt[i]=w;         update(1,n,1,a[i],w+1);         yoman();     }     for(i=1;i<=n;i++) {         v[lft[i]+1].pb(mp(a[i],lft[i]+rgt[i]+1));     }     for(i=1;i<=n;i++) {         if(v[i].size()>0) sort(v[i].begin(),v[i].end(),cmp);     }     /////////////////////cleaning///////////////////////      for(i=1;i<=n;i++) {         if(v[i].size()==0) continue;         u[i].pb(v[i][0]);         x = v[i][0].f;         y = v[i][0].sc;         for(j=1;j<v[i].size();j++) {             if(x == v[i][j].f || y >= v[i][j].sc) {                 continue;             }             else {                 u[i].pb(v[i][j]);                 x = v[i][j].f;                 y = v[i][j].sc;             }         }     }      ////////////////////cleaning ends///////////////////     /* for(i=1;i<=n;i++) {         cout<<i<<" : ";         for(j=0;j<u[i].size();j++) {             cout<<u[i][j].f<<","<<u[i][j].sc<<"  ";         }         cout<<endl;     }*/      s(t);     while(t--) {         s(x);s(y);         if(u[y].size()==0) {             printf("Not Possible\n");             continue;         }         if(u[y][u[y].size()-1].sc < x) {             printf("Not Possible\n");             continue;         }         ll low = 0;         ll high = u[y].size()-1;         ll mid;         while(low < high) {             mid = (low+high)/2;             if(u[y][mid].sc >= x) {                 high = mid;             }             else {                 low = mid+1;             }         }         printf("%lld\n",u[y][low].f);     }      return 0; } 
#include <cstring> #include <iostream> #include <algorithm> #include <vector> #include <string> using namespace std; vector<string> vec; vector<string>::iterator it; int n; int main() { 	int T; 	string cmd, path; 	scanf("%d", &T); 	while(T--) { 		vec.clear(); 		scanf("%d", &n); 		for(int i = 0; i < n; i++) { 			cin >> cmd; 			if(cmd == "pwd") { 				for(int i = 0; i < vec.size(); i++) { 					printf("/%s", vec[i].c_str()); 				}puts("/"); 			}else { 				cin >> path; 				if(path[0] == '/') { 					vec.clear(); 					path = path.substr(1, path.size()); 				} 				for(int j = 0; j < path.size(); j++) { 					string tmp = ""; 					while(path[j] != '/' && j < path.size()) { 						tmp += path[j]; 						j++; 					} 					if(tmp == ".." && vec.size() > 0) { 						it = vec.end(); 						it--; 						vec.erase(it); 					}else { 						vec.push_back(tmp); 					} 				} 			} 		} 	} 	return 0; } 
#include<bits/stdc++.h>  using namespace std;  #define ll long long int #define ull unsigned long long int #define maxN 1000000 #define maxW 1005 #define MOD 1000000007 #define pb push_back #define mp make_pair #define INF (((ll)1000000000) * ((ll)1000000000)) #define e 2.7182818284590452353602874 #define maxT 100000 #define inf 0x7fffffff #define inff 100000 #define ff first #define ss second  ll fact[maxN+5],A,B,N;  ll fpow(ll a,ll b) { if(b==0)  return 1; else if(b==1)  return a; else if(b%2==0)  return fpow( a*a%MOD , b/2 ); else  return (a*fpow(a*a%MOD, b/2) )%MOD; }  void pre() { fact[0]=1; for(ll i=1;i<=maxN;i++) {  fact[i]=(fact[i-1]*i)%MOD;  } }  bool lucky(ll a) { while(a) { int k=a%10; if(k==A || k==B); else  return false; a/=10; } return true; }  ll inv(ll i) {  return fpow(fact[i],MOD-2); }  ll bcoeff(int a,int b) { return ( ((fact[a]*inv(a-b))%MOD)*inv(b) )%MOD; }  int main() {  cin.sync_with_stdio(0); cin.tie(0);  int T; cin>>T;  pre();  //cout<<"y\n";  while(T--) {  cin>>A>>B>>N;  ll ans=0;  for(ll i=0;i<=N;i++) {   ll sum=A*i+(N-i)*B;   if(lucky(sum))     ans=(ans+bcoeff(N,i) )%MOD;  } cout<<ans<<"\n"; }      return 0; } 
#include<cstdio> #include<iostream> #include<vector> #include<string> #include<algorithm> using namespace std;  int main() {     int t,d,sz;     string n;     scanf("%d",&t);     while(t--)     {         vector<int> ans;         scanf("%d",&d);         cin>>n;         vector<int> que(d);         for(int i=0;i<d;i++)         {             que[i]=int(n[i])-48;         }         for(int i=0;i<d;i++)         {             if(que[i]==2 || que[i]==3 || que[i]==5 || que[i]==7)                 ans.push_back(que[i]);             else if(que[i]==4)             {                 ans.push_back(2);                 ans.push_back(2);                 ans.push_back(3);             }             else if(que[i]==6)             {                 ans.push_back(3);                 ans.push_back(5);             }             else if(que[i]==8)             {                 ans.push_back(2);                 ans.push_back(2);                 ans.push_back(2);                 ans.push_back(7);             }             else if(que[i]==9)             {                 ans.push_back(2);                 ans.push_back(3);                 ans.push_back(3);                 ans.push_back(7);             }         }         sort(ans.rbegin(),ans.rend());         sz=ans.size();         for(int i=0;i<sz;i++)         {             printf("%d",ans[i]);         }         printf("\n");     }     return 0; } 
#include<bits/stdc++.h> #include<algorithm> #include<vector> #include<queue> #define REP(i,n) for(i=0;i<n;i++) #define sll(n) scanf("%lld",&n) #define si(n) scanf("%d",&n) #define pi(n) printf("%d",n) #define sl(n) scanf("%ld",&n) #define pin(n) printf("%d\n",n) #define MP make_pair #define PB push_back typedef long long LL; using namespace std; int main() {     int t;     cin>>t;     long long a[3005];     while(t--)     {         long long  n,m;         cin>>n>>m;         for(int i=0;i<m;i++)             scanf("%lld",&a[i]);         sort(a,a+m);         if(a[m-1]==n || a[0]==1) cout<<"NO\n";         else         {             int f=0;             for(int i=0;i<m;i++)             {                 if(i+2<m && a[i+2]-a[i]==2)                 {                     f=1; break;                 }             }             if(f) cout<<"NO\n";             else cout<<"YES\n";         }     } 	return 0; } 
#include<bits/stdc++.h> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {         int n,d,sum=0;         cin>>n>>d;         int a[n];         for(int i=0;i<n;i++)         {             cin>>a[i];             sum+=a[i];         }         int res=sum+(n-1)*10;         if(res>d)             cout<<"-1"<<endl;         else         {             cout<<(d-sum)/5<<endl;         }      }     return 0; } 
#include<bits/stdc++.h> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {         string n,m;         cin>>n>>m;         sort(n.begin(),n.end());         int i=0;         while(i<n.length()&&n[i]=='0')             i++;         swap(n[0],n[i]);             if(n.compare(m)==0)                 cout<<"AC\n";             else                 cout<<"WA\n";       }     return 0; } 
#include <cstdio>  #include <algorithm> #include <iostream>   using  namespace std;   char gar [1000001]; int pow2 [1000001];   int main () { 	int n, m; 	 	scanf("%d%d", &n, &m); 	scanf("%s", gar); 	 	pow2[0] = 1 ; 	for ( int i = 1 ; i <= n; i++) pow2[i] = (2 * pow2[i - 1])% m; 	 	int ans = 0 , k = n; 	 int nowdx = 0 , mindx = 0 , maxdx = 0 ; 	 for ( int i = 0 ; gar[i]; i++) { 		k--; 		if (gar[i] == 'P' ) { 			 int ndx = nowdx + 1 ; 			 if (max(ndx, maxdx) - mindx == 1 ) ans = (ans + pow2[k / 2 ] + pow2[(k + 1 ) / 2 ] + m - 1 )% m; 			 else  if (max (ndx, maxdx) - mindx == 2 ) ans = (ans + pow2[(k + (mindx + 1 == ndx)) / 2 ])% m; 			nowdx--; 			mindx = min(mindx, nowdx); 		} 		else { 			nowdx ++; 			maxdx = max (maxdx, nowdx); 		} 	} 	 	printf("%d\n" , (ans + 1 )% m); 	 	return 0; } 
//+++++++++++++++++++++++++++++// ////      Karan Aggarwal         // ////       IIIT-Hyderabad        // ////+++++++++++++++++++++++++++++// //// Topic:  #include<stdio.h> #include<utility> #include<stdlib.h> #include<string.h> #include<math.h> #include<iostream> #include<vector> #include<sstream> #include<map> #include<set> #include<stack> #include<queue> #include<algorithm> using namespace std; #define PB push_back #define MP make_pair #define clr(x) x.clear() #define sz(x) ((int)(x).size()) #define F first #define S second #define REP(i,a,b) for(i=a;i<b;i++) #define rep(i,b) for(i=0;i<b;i++) #define rep1(i,b) for(i=1;i<=b;i++) #define mod 1000000007 #define pi(n) printf("%d",n) #define pin(n) printf("%d\n",n) #define piw(n) printf("%d ",n) #define pll(n) printf("%lld",n) #define plln(n) printf("%lld\n",n) #define pllw(n) printf("%lld ",n) #define sll(n) scanf("%lld",&n) #define ss(s) scanf("%s",s) #define ps(s) printf("%s",s) #define psn(s) printf("%s\n",s) #define psw(s) printf("%s ",s) #define si(n) scanf("%d",&n) #define pn printf("\n") #define pw printf(" ") /* inline int ri() {     int n=0;char c;     while(1)     {          c=getchar_unlocked();         if(c=='\n'||c==' '||c==EOF)break;         n=(n<<3) + (n<<1) +c-48;     }     return n; } inline long long rll() {     long long n=0;     char c;     while(1)     {          c=getchar_unlocked();         if(c=='\n'||c==' '||c==EOF)break;         n=(n<<3) + (n<<1) + c - 48;     }     return n; } */ typedef pair<int,int> PII; typedef vector<PII> VPII; typedef vector<int> VI; typedef vector<VI> VVI; typedef long long LL; int isleap(int x) {     if(x%4)return 0;     if(x%100)return 1;     x/=100;     if(x%4)return 0;     return 1; } string months[12]={"JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"}; int days[12]={0,31,28,31,30,31,30,31,31,30,31,30}; int main() {     int y,T,n,m,i,t,j,k,x;     si(t);     T=t;     while(t--)     {         string date;         cin>>date;         //__________________________________________         int day = (date[0]-'0')*10 + (date[1]-'0');         //___________________________________________________         int yr = (date[7]-'0')*1000;         yr += (date[8]-'0')*100;         yr += (date[9]-'0')*10;         yr += (date[10]-'0');         //_____________________________________         string mnth="";         mnth+=date[3];         mnth+=date[4];         mnth+=date[5];         for(i=0;i<12;i++)         {             day+=days[i];             if(mnth==months[i])                 break;         }         //____________________________________         if(i>1)day+=isleap(yr);         //________________________________________________         if(day<=300)             cout<<"Case "<<T-t<<": "<<day<<" Hundreds\n";         if(day>300 && day<=360)                 cout<<"Case "<<T-t<<": "<<day-300<<" Tens\n";         if(day>360)             cout<<"Case "<<T-t<<": "<<day-360<<" Ones\n";     }     return 0; }  
#include <cstdio> #include <cmath> #include <iostream> #include <vector> #include <map> #include <sstream> #include <set> #include <utility> #include <iterator> #include <functional> #include <numeric> #include <string> #include <cstdlib> #include <algorithm> #define debug(x) cerr<<#x<<"="<<(x)<<endl #define ISS istringstream #define SS stringstream  using namespace std;  template<typename T> void printvec(vector<T> a){ 	for(long long i=0;i<a.size();i++) 		cout<<a[i]<<" "; 	cout<<endl; }  // Real Code starts here  vector<string> tokenizer(string str, string delims) { 	vector<string> tokens; 	int pos, pos2; 	pos = str.find_first_not_of(delims, 0);  	while (pos >= 0) 	{ 		pos2 = str.find_first_of(delims, pos); 		if (pos2 < 0) pos2 = str.length(); 		tokens.push_back(str.substr(pos, pos2-pos)); 		pos = str.find_first_not_of(delims, pos2); 	} 	return tokens; }  int main(){ 	map<string,string> my; 	my["8"] = "ate"; 	my["w8"] = "wait"; 	my["gr8"] = "great"; 	my["4"] = "for"; 	my["b4"] = "before"; 	 	int t; 	string line; 	getline(cin,line); 	ISS(line)>>t; 	while(t--){ 		string s; 		getline(cin,s); 		string word = ""; 		string result = ""; 		for(int i=0;i<s.size();i++){ 			if(s[i]==' '){ 				if(word!=""){ 					if(my.count(word)) 						result+= my[word]; 					else	 						result+= word; 				} 				result+= s[i]; 				word=""; 			} 			else 				word+= s[i]; 		} 		if(my.count(word)) 			result+= my[word]; 		else 			result+= word; 		cout<<result<<endl; 	} 	return 0; }
#include<iostream> #include<cmath> using namespace std;  float mini(float x, float y) { return (x < y)? x: y; }  float fun(int h,int m){ 	if(h==12) 		h=0; 	if(m==60) 		m=0; 	float hour=0.5*((h*60)+m);		 	float min=6*m; 	float res=abs(hour-min); 	res=mini(360-res,res); 	return res; }  int main(){ 	int h,m; 	float res; 	cin>>h; 	cin>>m; 	res=fun(h,m); 	cout<<res<<endl; 	return 0; }
#include<cstdio> #include<cstdlib> #include<cstring> #define INF 1000000001 #define min(a,b) (a<b?a:b) #define max(a,b) (a>b?a:b)   int dp[1001][1001]; char a[1001][1001]; int calc(int n,int k) {     int i,j;     for(j=0;j<n;j++) dp[n-1][j]=a[n-1][j]-48;     for(i=n-2;i>=0;i--)     {         for(j=0;j<n;j++)         {             if(!(i&1)) dp[i][j]=min(min((j>0?dp[i+1][j-1]:INF),(j<n-1?dp[i+1][j+1]:INF)),dp[i+1][j])+a[i][j]-48;             else dp[i][j]=max(max((j>0?dp[i+1][j-1]:-1),(j<n-1?dp[i+1][j+1]:-1)),dp[i+1][j])+a[i][j]-48;         }     }     int cnt=0;     for(j=0;j<n;j++) if(dp[0][j]>=k) cnt++;     return cnt; }  int main() {     int t,n,k,i;     scanf("%d",&t);     while(t--)     {         scanf("%d%d",&n,&k);         for(i=0;i<n;i++) scanf("%s",a[i]);         printf("%d\n",calc(n,k));     }     return 0; } 
#include<bits/stdc++.h> #define ll long long int   using namespace std;  int main() {   ios_base::sync_with_stdio(false);   int t;   cin>>t;   while(t--)   {     ll n,m;     cin>>n>>m;     ll val=n+m;     ll s1=abs(val*(val+1))/2;     ll s2=abs(n*(n+1))/2;     ll ans=(s1-2*s2);     cout<<ans<<endl;   }   return 0; }  
#include<iostream> #define mod 1000000007 typedef long long int ll; using namespace std; long long powr(long long base,long long power,long long M) {     if(power==0)        return 1;     if(power==1)     return base;     long long halfn=powr(base,power/2,M);     if(power%2==0)         return ( halfn * halfn ) % M;     else         return ( ( ( halfn * halfn ) % M ) * base ) % M; } int main() {     ll t,n;     cin>>t;     while(t--)     {         cin>>n;         cout<<powr(2,n,mod)<<'\n';     }     return 0; }  
#include<stdio.h> #include<math.h> #define DRT()     int t;scanf("%d",&t);while(t--) #define MIN(a,b)  (a)<(b)?(a):(b) #define MAX(a,b)  (a)>(b)?(a):(b) #define MOD       1000000007 int a[10000001]; int main() {     int i= 0,j=0;     int n,t=0;     for(i=0;i<10000001;i++)         a[i]=1;     a[0] = 0;     a[1] = 0;     for(i=2;i<(10000001);i++) 			{ 				if(a[i]) 				{  					for(j=2*i;j<10000001;j+=i) 					a[j]=0; 				} 			}      scanf("%d",&t);    while(t--)    {        scanf("%d",&n);        if(a[n]==1)         printf("Yes\n");        else         printf("No\n");    }  return 0 ;  }
#include <bits/stdc++.h>  using namespace std;  int main(){ 	int t; 	cin>>t; 	while(t--){ 		int n; 		cin>>n; 		int a[n]; 		for(int i=0;i<n;i++){ 			cin>>a[i]; 		} 		int lmin = 1; 		int lmax = a[0]-1; 		int ans = n; 		for(int i=1;i<n;i++){ 			if(lmin>a[i]-1){ 				ans++; 				lmin = max(1,a[i]-lmax+1); 				lmax = a[i]-1; 			} 			else{ 				int temp = lmin; 				lmin = max(1,a[i]-lmax); 				lmax = a[i]-temp; 			} 		} 		cout<<ans<<endl; 	} 	return 0; }
#include<iostream> #include<stdio.h> #include<string.h> #include<vector> #include<map> #include<set> #include<math.h> #include<limits.h> #include<list> #include<stdlib.h> #include<stack> #include<queue> #include<algorithm> //9940543804 using namespace std;   #define ll long long #define pb push_back #define mk make_pair #define rep(i,n) for(i=0;i<n;i++)   int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		long long int i,j,k,l,a,m,n; 		cin>>a>>m; 		long long int arr[a]; 		vector<pair<long long int,long long int> >v; 		 		for(i=0;i<a;i++) 			cin>>arr[i]; 		cin>>n; 		vector<vector<long long int> >vec(n); 		for(i=0;i<n;i++) 		{ 			ll tt1,tt2; 			cin>>tt1>>tt2; 			v.pb(mk(tt1,tt2)); 		} 		//for(i=0;i<v.size();i++) 		//	cout<<v[i].first<<" "<<v[i].second<<"\n"; 		for(i=0;i<n;i++) 		{ 			for(j=v[i].first;j<=v[i].second;j++) 			{ 				vec[i].pb(arr[j]); 			} 		} 		/*for(i=0;i<vec.size();i++) 		{ 			for(j=0;j<vec[i].size();j++) 				cout<<vec[i][j]<<" "; 			cout<<"\n"; 		}*/ 		long long int ans[5005]; 		for(i=0;i<=5004;i++) 			ans[i]=0; 		for(i=0;i<vec[0].size();i++) 			ans[vec[0][i]]=1; 		for(i=0;i<vec.size()-1;i++) 		{ 			for(j=0;j<vec[i].size();j++) 			{ 				for(k=i+1;k<i+2;k++) 				{ 					for(l=0;l<vec[k].size();l++) 					{ 						if(vec[i][j]+m>=vec[k][l]) 							ans[vec[k][l]]+=ans[vec[i][j]]; 						 					} 				} 			} 		} 		//for(i=0;i<=11;i++) 		//	cout<<ans[i]<<" "; 		//cout<<"\n"; 	 		for(i=0;i<vec[vec.size()-1].size();i++) 				{ 					//cout<<ans[vec[vec.size()-1][i]]<<" "; 					ans[arr[a-1]]+=ans[vec[vec.size()-1][i]]; 				} 		//for(i=0;i<=11;i++) 		//	cout<<ans[i]<<"\n"; 			cout<<ans[arr[a-1]]<<"\n"; 	} 	 	return 0; }
#include <bits/stdc++.h>  using namespace std;  int main(){ 	int t; 	cin>>t; 	while(t--){ 		int n; 		cin>>n; 		if(n==1) 			cout<<0<<endl; 		else{ 			int ans = 1; 			int cnt = 1; 			while(ans<n){ 				ans = ans+cnt; 				cnt++; 			} 				cout<<cnt-1<<endl;		 		} 	}  	return 0; }
#include<bits/stdc++.h> using namespace std; int main(){ int t;  int n,i,val=0,maxm=-1,k; vector<int> v;  scanf("%d",&n); for(i=0;i<n;i++) {scanf("%d",&k); if(i%2==0) val+=k; else val-=k; if(maxm<val){ v.push_back(i+1); maxm=val;} } for(i=0;i<(int)v.size();i++) printf("%d ",v[i]); cout<<endl; if(maxm==val) printf("SUCCESS\n"); else printf("FAIL\n");  return 0; } 
#include<stdio.h> #include<math.h> #include<iostream> using namespace std; int prime(long long n); int main() { 	long long t,n,i,x[10000],y[10000],z[10000]; 	scanf("%lld",&t); 	while(t--){ 		scanf("%lld",&n); 		for(i=0;i<n;i++) 		{ 			scanf("%lld%lld%lld",&x[i],&y[i],&z[i]); 		} 		long long  a=0,b=0,c=0; 		for(i=0;i<n;i++) 		{ 			a=a+x[i]; 			b=b+y[i]; 			c=c+z[i]; 		} 		//printf("%lld\n%lld\n%lld",a,b,c); 		int q=prime(a); 		int w=prime(b); 		int e=prime(c); 		//printf("%d\n%d\n%d",q,w,e); 		if(q==0&&q==w&&q==e) 			printf("YES\n"); 		else 			printf("NO\n"); 	}	 	return 0; } int prime(long long  n) { 	long long i; 	int flag=0; 	if(n==1||n==0) 		flag=1; 	for(i=2;i<=sqrt(n);i++) 	{ 		if(n%i==0) 		{ 			flag=1; 			break; 		} 	} 	return flag; }
#include <iostream> #include<cmath> using namespace std;  int lengthfunction(int number) {           int counter=0;       while(number)      {                     number=number/10;             counter++;       }       return (counter); }  int reverse(int n) { int a[100],final=0; int l=lengthfunction(n);  for(int i=0;i<l;i++) { a[i]=n%10; n=n/10; }   for(int i=0;i<l;i++) { final=final+(a[i]*pow(10,l-i)); }  return final/10; }  int addreverse(int n,int m) { int a[100],i; int c1=0,c2=0,c3=0,c4=0;  c1=reverse(n); c2=reverse(m); c3=c1+c2; c4=reverse(c3);  cout<<c4<<"\n";  }     int main() { 	long int n;int x[10],y[10]; 	cin>>n; 	for(int i=0;i<n;i++) 	{ cin>>x[i]>>y[i]; 	} 	for(int i=0;i<n;i++) 	{ addreverse(x[i],y[i]); 	} 	return 0; }
#include <iostream> #include <string.h>   using namespace std;    bool palindrome(int n)  {  	int k,p=0,m;  	m=n;  	while(m>0) 	 { 	 	k=m%10; 	 	p=p*10+k; 	 	m=m/10; 	 } 	  	 	if(p==n) 	 	return true; 	 	else  	 	return false;  }     int main() { 	long long int t; 	cin>>t; 	while(t--) 	{ 	int n; 	cin>>n; 	 	for(int i=n+1;i<=99999;i++) 	{ 		if(palindrome(i)==true) 		{ 			cout<<i<<endl; 			break; 		} 		else  		continue; 	} 	 	} 	return 0; } 
#include<bits/stdc++.h> #include <string.h>   int main(){      char a[11],b[11];  //   char *a,*b;     int n;     scanf("%d",&n);     while(n--){        // cin >> a >> b;         scanf("%s %s",a,b);            //if(strstr(a,b)!=NULL) printf("1\n");            //else printf("0\n");         printf(strstr(a,b) ? "1\n" : "0\n");      }  return 0; } 
 #include <cstdlib> #include <stdlib.h> #include <iostream> #include <string> using namespace std;   bool is_possible(int r_x,int r_y,int t_x,int t_y) {     bool ans;     if(((r_x*r_y)%(t_x*t_y))==0)     {         ans=true;     }     else          ans=false;     return ans; } int main(void)  {          int testcase;     cin>>testcase;          int room_x[testcase];     int room_y[testcase];     int tile_x[testcase];     int tile_y[testcase];     bool res[testcase];     for(int i=0;i<testcase;i++)     {         cin>>room_x[i];                  cin>>room_y[i];                  cin>>tile_x[i];                   cin>>tile_y[i];     }     for(int j=0;j<testcase;j++)     {         res[j]=is_possible(room_x[j],room_y[j],tile_x[j],tile_y[j]);     }     for(int k=0;k<testcase;k++)     {        string str;         if(res[k]==true)         {             str="yes";             cout<<str<<endl;         }         else if(res[k]==false)         {              str="no";             cout<<str<<endl;         }     }     return 0; }  
#include<cstdio> #include<cstring> #include<cstdlib> #include<algorithm> #include<iostream> using namespace std; int main() {    char s[1005];    int x;    cin>>x;    getchar();    cin.getline(s,1005);    for(int i=0;i<strlen(s);i++)    {      if(s[i]=='W')         x=(x*2)+11;      else      {         if(x%2==0)             x=x/2;         else            x=(x/2)+1;      }    }    cout<<x<<endl;    return 0; } 
#include<iostream> #include<cstdio> #include<cmath> #define MAX 500000 #define mod 1000000007 using namespace std; typedef long long int ll; ll n,i,j,ret,l,m,ans; ll modinv(ll a,ll m) {     ll v=1;     ll d=a;     ll u=(a==1);     ll t=1-u;     if(t==1) {         ll c=m%a;         u=floor(m/a);         while(c!=1 && t==1) {                ll q=floor(d/c);                d=d%c;                v=v+q*u;                t=(d!=1);                if(t==1) {                    q=floor(c/d);                    c=c%d;                    u=u+q*v;                }         }         u=v*(1-t)+t*(m-u);     }     return u; } ll ncr(ll a,ll b) {     ret=1;     for(j=0;j<b;j++)     {         l=modinv(j+1,mod);         m=(a-j)%mod;         m=(m*l)%mod;         ret=(ret*m)%mod;     }     return ret; } int main() {     scanf("%lld",&n);     ans=0;     if(n<13)         printf("0\n");     else     {         for(i=0;i<(n-12+(n%2))/2;i++)         {             ans+=ncr(i+5,5);             ans%=mod;         }         printf("%lld\n",ans);     }     return 0; } 
/* Basic includes*/ #include <iostream> #include <cstdio> #include <cstdlib> #include <cstring> #include <string> #include <algorithm> #include <vector> #include <cctype> #include <climits> #include <map> #include <queue> #include <stack> #include <deque> #include <bitset> #include <set>  using namespace std;  typedef long long ll; typedef unsigned long long ull;  typedef vector<int> vi; typedef pair<int,int> pi; typedef vector<string> vs; typedef vector<pi> vpi;  /*Basic Macros*/ #define fi				first #define se				second #define all(x)			(x).begin(), (x).end() #define ini(a, v)		memset(a, v, sizeof(a)) #define re(i,s,n)		for(int i=s;i<(n);++i) #define rep(i,s,n)	for(int i=s;i<=(n);++i) #define fo(i,n)		re(i,0,n) #define rev(i,n,s)	for(int i=(n)-1;i>=s;--i) #define repv(i,n,s)	for(int i=(n);i>=s;--i) #define fov(i,n)		rev(i,n,0) #define pu				push_back #define mp				make_pair #define si(x)			(int)(x.size()) #define miN(a,b)		( (a) > (b) ? (b) : (a) ) #define maX(a,b)		( (a) > (b) ? (a) : (b) ) #define ABS(a)			( (a) >= 0 ? (a) : (-(a))) #define Swap(a,b)		{ int t = a; a = b; b = t; } #define Get 			getchar_unlocked()  /*Some functions*/ int GCD(int a,int b) { return b == 0 ? a : GCD(b,a%b); }  int getInt() { int a=0,s=1; char c=0; while(c<33) c=Get; if(c=='-') {s=-1; c=Get;} while(c>33) {a=(a<<3)+(a<<1)+c-'0'; c=Get;} return a*s; }  ll getInt64() { ll a=0,s=1; char c=0; while(c<33) c=Get; if(c=='-') {s=-1; c=Get;} while(c>33) {a=(a<<3)+(a<<1)+c-'0'; c=Get;} return a*s; }  int compare(const void *x,const void *y) { int a=*(int*)x,b=*(int*)y; return a<b?-1:1; }  int power(int a,int e) { if(e==0) return 1; int s=power(a,e>>1); s=(ll)(s)*s; return e&1?(ll)(s)*a:s; }  int powerM(int a,int e,int m) { if(e==0) return 1%m; int s=powerM(a,e>>1,m); s=((ll)(s)*s)%m; return e&1?((ll)(s)*a)%m:s; }  bool isFeasible(ll a[],ll dist, ll n, ll k) { 	ll taken = 1; 	ll last = a[0]; 	for(ll i=0;i<n;i++) { 		if(a[i]-last >= dist) { 			taken++; 			last = a[i]; 		} 	} 	return (taken>=k); }  ll solve(ll a[],ll n,ll k) { 	ll low = 0; 	ll high = a[n-1] - a[0] + 1; 	while(high - low > 1) { 		ll mid = low + (high - low)/2; 		if(isFeasible(a,mid,n,k)) 			low = mid; 		else 			high = mid; 	} 	return low; }  int main() { 	ll n,c,i; 	n = getInt64(); 	c = getInt64(); 	ll a[n]; 	for(i=0;i<n;i++) { 		a[i] = getInt64(); 	} 	sort(a,a+n); 	ll ans = solve(a,n,c); 	printf("%lld\n",ans); 	return 0; } 
#include<stdio.h> #include<iostream> #include<stdlib.h> #include<vector> #include<set> #include<math.h> #include<map> #include<algorithm> #include<queue> #include<cstring> #include<stack> using namespace std; #define tr(container,it) \   for(typeof(container.begin()) it=container.begin();it!=container.end();it++) typedef pair<long,long>ii; #define MAX1 6553 #define MAX2 18 struct entry { 	long nr[2]; 	long p; }L[MAX1];  long P[MAX2][MAX1]; long n,stp,cnt; bool cmp(entry a,entry b) { 	return (a.nr[0]==b.nr[0])? (a.nr[1]<b.nr[1]?1:0):(a.nr[0]<b.nr[0]?1:0); } long lcp(long x,long y) { 	long ans=0,i; 	if(x==y) 	return n-x; 	for(i=stp-1;i>=0&&x<n&&y<n; i--) 	{ 		if(P[i][x]==P[i][y]) 		{ 			ans+= 1<<i; 			x+= 1<<i; 			y+= 1<<i; 		} 	} 	return ans; }  int main() {	   //freopen("input.txt","r",stdin);   long t;   cin>>t;   while(t--) {   string str;   cin>>str;   n=str.length();   memset(P,0,sizeof(P));   for(long i=0;i<n;i++)   {   	P[0][i]=str[i];   }      for(stp=1,cnt=1;cnt<n;stp++,cnt*=2)   {   	for(long i=0;i<n;i++)   	{   	   L[i].nr[0]=P[stp-1][i]; 	   L[i].nr[1]= (i+cnt <n)? P[stp-1][i+cnt]:-1; 	   L[i].p=i; 	} 	 	sort(L,L+n,cmp); 	for(long i=0;i<n;i++) 	{ 		P[stp][L[i].p]= (i>0&&L[i].nr[0]==L[i-1].nr[0]&&L[i].nr[1]==L[i-1].nr[1])? P[stp][L[i-1].p]:i; 	}   }      long SUF_ARR[MAX1];   for(long i=0;i<n;i++)   {   	SUF_ARR[i]=L[i].p;   	//cout<<L[i].p<<" ";   }   //cout<<endl;   long ans=0;      ans +=n- SUF_ARR[0];   for(long i=1;i<n;i++)   {   	long kk=lcp(SUF_ARR[i],SUF_ARR[i-1]);   //	cout<<kk<<" ";   	ans +=(n-SUF_ARR[i]-kk);   }   cout<<ans<<endl; }       return 0; }
#include<bits/stdc++.h> using namespace std;  #define ll long long int #define mod 1000000007  void multiply(ll f[2][2],ll m[2][2]){ 	ll x=f[0][0]*m[0][0]+f[0][1]*m[1][0]; 	ll y=f[0][0]*m[0][1]+f[0][1]*m[1][1]; 	ll z=f[1][0]*m[0][0]+f[1][1]*m[1][0]; 	ll w=f[1][0]*m[0][1]+f[1][1]*m[1][1]; 	 	f[0][0]=x%mod; 	f[0][1]=y%mod; 	f[1][0]=z%mod; 	f[1][1]=w%mod; }  void pow(ll f[2][2],ll n){ 	if(n<=1) 		return; 	ll m[][2]= { {2,3}, {1,0}}; 	pow(f,n/2); 	multiply(f,f); 	if(n&1) 		multiply(f,m); }  int main(){ 	int t; 	cin>>t; 	while(t--){ 		ll n; 		cin>>n; 		if(n<=1){ 			cout<<(n==0?2:5)<<endl; 			continue; 		} 		ll f[][2]={ {2,3},{1,0 }}; 		pow(f,n-1); 		 		cout<<(f[0][0]*5+f[0][1]*2)%mod<<endl; 	} }
// CNG #include<iostream> #include<vector> #include<set> #include<map> #include<queue> #include<stack> #include<string> #include<algorithm> #include<functional> #include<iomanip> #include<cstdio> #include<cmath> #include<limits.h> #include<cstring> #include<cstdlib> #include<cfloat> #include<cassert> #define maxm(a,b) a>b?a:b; #define minm(a,b) a<b?a:b; using namespace std; //M lazy ;) typedef long long ll; typedef vector <int> vi; typedef pair< int ,int > pii; typedef istringstream iss; typedef ostringstream oss; typedef map<int,int> mp; #define pb push_back #define mp make_pair #define ff first #define ss second #define sz size() #define ln length() #define rep(i,n) for(int i=0;i<n;i++) #define fu(i,a,n) for(int i=a;i<=n;i++) #define fd(i,n,a) for(int i=n;i>=a;i--) #define all(a)  a.begin(),a.end() #define ESP (1e-9) #define gi(n) scanf("%d",&n) #define gl(n) cin >> n #define pi(n) printf("%d",n) #define pl(n) cout << n #define ps printf(" ") #define pn printf("\n") #define dg(n,s); printf("%s %d",s,n) #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min() #define traverse_map(a,b) for(mp::iterator it=a;it!=b;++it) #define MOD 1000000007 #define MAX 1000001 #define cases() int t; cin>>t; while(t--) // fast input function #define getcx getchar_unlocked // fast input function #ifdef ONLINE_JUDGE  inline void inp( int &n )  {     n=0;     int ch=getcx();int sign=1;     while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )             n = (n<<3)+(n<<1) + ch-'0', ch=getcx();     n=n*sign;   } #else inline void inp(int &n){  cin>>n; } #endif  int main(){  int t;  inp(t);  while(t--){ 		ll a,b;  		cin>>a; 		cin>>b; 		ll ans=a*b-(a+b); 		cout<<ans<<endl;  }  return 0; } 
#include <iostream> using namespace std; int main(){         int n;         cin>>n;         int ct=0;         int k=n;         while(n!=0){         n=n/2;                 ct++;         }         int a[ct];         int i=0;         n=k;         //System.out.println(ct);         while(n!=0){             a[i]=n%2;             n=n/2;             i++;                      }       int ft=0;           for(i=0;i<ct;i++){             if(a[i]==1){                 ft++;             }         }                           cout<<ft;              }            	 	 	 	 	  
#include<bits/stdc++.h> #define ll long long #define MAX 10487577 using namespace std; map<int, long long> dp; long long mod; ll fact[MAX], inv[MAX]; ll bpow(ll a,ll n){     ll res = 1;     while(n){         if(n&1)             res = (res * a) % mod;         a = (a * a) % mod;         n >>= 1;     }     return res; } void pre(){     fact[0] = 1;     for(int i = 1;i <= MAX; ++i)         fact[i] = (fact[i - 1] * i) % mod; } ll C(int n, int r){     ll ans = fact[n];     ans *= bpow(fact[n - r], mod - 2);     ans %= mod;     ans *= bpow(fact[r], mod - 2);     ans %= mod;     return ans;  } void calc(int a){     int x = a / 2;     int l = a - x;     int r = a - l - 1;     if(a % 2)         l -= 1, r += 1;     dp[a] = (((dp[l]*dp[r]) % mod)*C(a - 1, l)) % mod;     if(a % 2 == 0){         dp[a] *= 2;         dp[a] %= mod;     } } int main(){     dp[1] = 1;     dp[2] = 2;     dp[3] = 2;     int n;     cin >> n >> mod;     pre();     for(int i = 3;i <= 20; ++i){         int a = (1 << i) - 1;         calc(a);         calc(a - 1);     }     cout << dp[n] << "\n";     return 0; } 
#include<bits/stdc++.h> using namespace std; vector<int> v(10000000); //set<int> s; vector<int> store(664579); int main() {     int i,j,t,m,n,temp1,res,index=0;     for(i=2;i<=10000000;i++)     {         if(v[i]==0)         {             store[index]=i;             index++;             //s.insert(i);             for(j=2*i;j<=10000000;j+=i)             {                 v[j]=1;             }         }     }     scanf("%d",&t);     while(t--)     {         scanf("%d%d",&m,&n);         //set<int>::iterator it;         int it1,it2;         res=0;         it1=lower_bound(store.begin(),store.end(),m)-store.begin();         it2=lower_bound(store.begin(),store.end(),n)-store.begin();         if(store[it2]>n)             it2--;         res=it2-it1+1;         printf("%d\n",res);     }     return 0; } 
#include<iostream> #include<vector> #include<iterator> #include<stdlib.h> #define MAX 50 #define MOD 1000000007 using namespace std; int main(){    long long int comb[MAX][MAX];       int t,n;    int x,y,u,v;    long long ans;     for(int i=0;i<MAX;i++){   comb[1][i]=1;   comb[i][1]=1;          }   cin>>t;  while(t--){     cin>>x>>y;   cin>>u>>v;       for(int i = 1;i <= x;i++){ 				for(int j = 1;j <= y;j++){ 					if(i == 1 && j == 1)continue; 					if(i == u && j == v){comb[i][j]=0;continue;} 					comb[i][j] = comb[i-1][j] + comb[i][j-1]; 				} 			}   //ans=comb[x-1][y-1]-(comb[u-1][v-1]*comb[x-u][y-v]);   cout<<comb[x][y]<<endl;    }    return 0;     } 
#include<iostream> using namespace std; main() {     int n,t,i,j,ans;     cin>>t;     while(t--)     {         ans=0;         cin>>n;          for(i=1;i<=n-1;i++)         {             for(j=i+1;j<=n;j++)             {                 if((i*j) % (i+j)==0)                 ans++;             }         }         cout<<ans<<endl;     } return 0; } 
#include<iostream> #include<string> #include<utility> #include<algorithm> #include<cstring> #define MOD 1000000 #define MIN(X,Y) ((X>Y)?Y:X)  #define MAX(X,Y) ((X>Y)?X:Y) using namespace std; int dp[101][100001]; int main() {   ios_base::sync_with_stdio(false);    //memset(dp,0,sizeof(int)*101*100001);   dp[0][0]=1;   int i,j,k,N,Q,S,aux,aux_1,aux_2=0,aux_3=0;   cin >> N >> Q;   aux_1=N;   while(aux_1--){     cin >> aux;     aux_2=MIN(aux_2,aux);     aux_3+=aux;     for(i=N-aux_1;i>0;i--){       for(j=aux;j<=aux_3;j++) 	if(dp[i-1][j-aux]) 	  dp[i][j]=1;     }   }   while(Q--){     cin >> S >> k;     if(dp[k][S])       cout << "YES" << '\n';     else       cout << "NO" << '\n';   }   return 0; } 
#include <iostream> #include <cstdio> #include <map> #include <cstring> #include <string> #include <cmath> #include <cassert> #include <cstdlib> #include <vector> #include <utility> #include <algorithm>   #define MOD 1000000007 #define INF 99999999 #define ONLINE_JUDGE #define FOR(i,a,b) for(int i=(a);(i)<(b);i++) #define MAX(a,b) ((a)>(b)?(a):(b)) #define MIN(a,b) ((a)<(b)?(a):(b))   typedef unsigned long long ULL; typedef long long LL;   using namespace std;  int prime[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,101};  int lcm(int n) {     int num[101]={0},j=0,k,index,temp,LCM = 1,i,count;     for (i = 2; i <= n; ++i) 	{ 		temp = i;         j=0; 		while(prime[j] <= i) 		{             count = 0;              while(temp%prime[j]==0)             {             	temp=temp/prime[j];             	count++;             }  			if(num[prime[j]] < count) 				num[prime[j]] = count;  			j++;             temp=i; 		} 	}  //	for (i = 0; i < 11; ++i) //	{ //		printf("%d\n", num[i]); //	}  	i=0; 	while(prime[i] <= n) 	{ 		for (int j = 0; j < num[prime[i]]; ++j) 		{ 			LCM = ((ULL)LCM*prime[i])%MOD; 		}         i++; 	} 	return LCM; }   int main() { 	#ifndef ONLINE_JUDGE 	freopen("input.txt","r",stdin); 	//freopen("output.txt","w",stdout); 	#endif  	int test,num,ans; 	scanf("%d",&test); 	while(test--) 	{ 		scanf("%d",&num);         ans = (lcm(num) + 1)%MOD; 		printf("%d\n",ans); 	}  	return 0; }
#include<bits/stdc++.h> #define pb(x) push_back(x) #define all(x) x.begin(), x.end() #define cout2(x, y) cout << x << " " << y <<  endl #define N 100004  #define MOD 1000000007 using namespace std;  long long fastPow(long long b, long long e){ 	 	if(b == 0)return 0; 	long long ans = 1; 	 	while(e > 0){ 	 		if(e&1)ans = ans * b; 		if(ans >= MOD)ans %= MOD; 		 		b = b * b; 		if(b >= MOD)b %= MOD; 		 		e >>= 1; 	} 	 	return ans; }  int main(){  	int tc = 0; 	scanf("%d", &tc); 	 	while(tc--){ 		 		long long n, k; 		scanf("%lld%lld", &n, &k); 		 		if(n == 1)printf("%lld\n", k); 		else{ 			 			long long ans = 1; 			 			if(n%2 == 1){ 				 				ans = (k * (k - 1))%MOD; n -= 2; 				if(n == 1)ans = (ans * (k - 2))%MOD; 				else{ 					 					long long aux = (k - 1) + (k - 2) * (k - 2); 					aux %= MOD; 					 					ans = (ans * fastPow(aux, n/2))%MOD; 					ans = (ans * (k - 2))%MOD;	 					 				} 			} 			else{ 				 				ans = (k * (k - 1))%MOD; n -= 2; 				long long aux = (k - 1) + (k - 2) * (k - 2); 				 				aux %= MOD; 				ans = (ans * fastPow(aux, n/2))%MOD;	 			} 			 			printf("%lld\n", ans); 		}	 		 	}  }  
#include<iostream> #include<string> #include<vector> using namespace std; int main() { int t; cin>>t; while(t--) { string s; cin>>s; string ::iterator i; vector<int>v[30]; int k=0; for(i=s.begin();i!=s.end();i++) { v[*i-'a'].push_back(k); k++; } long long int even=0,odd=0,ans=0; for(int j=0;j<27;j++) { vector<int>::iterator it; for(it=v[j].begin();it!=v[j].end();it++) { if(*it%2==0) even++; else odd++; } ans=ans+even*(even-1)/2+odd*(odd-1)/2; even=0,odd=0; } cout<<ans+s.size()<<endl; } return 0; } 
/* Author : RISHAV GOYAL */  #include <bits/stdc++.h> using namespace std;  #define LL long long int #define UL unsigned long long int  #define imax INT_MAX #define imin INT_MIN #define LLmax LLONG_MAX #define LLmin LLONG_MIN  #define FOR(i,a,b) for(int i= (int)a; i<= (int)b; i++) #define rep(i,n) for(int i= int(1); i<= (int)n; i++) #define FORd(i,a,b,d) for(int i=(int)a; i<= (int)b; i+=(int)d)  #define pr() printf("Reached here 1...\n"); #define pr1() printf("Reached here 2...\n");  #define CLR(a) memset(a,0,sizeof(a)); #define SET(a) memset(a,-1,sizeof(a));  #define str strlen #define pb(x) push_back(x) #define mp make_pair #define ii pair<int,int> #define ll pair<LL,LL>  #define F first #define S second #define gcd(a,b) __gcd(a,b)  #define mod int(1e9 + 7) #define MAX int(1e5 + 10)  #define si(a) scanf("%d",&a);  #define VI vector<int> #define VL vector<LL> #define VS vector<string> #define VC vector<char>  LL powmod(LL a,int b,int n){LL rm=1;while (b){if (b % 2) { rm = (rm * a) % n; }a = (a * a) % n;b /= 2;}return rm;}   int n,a[MAX],ans,t,tmx,tmn,k;  int main() { 	cin >> t; 	while ( t--){ 	std::multiset<int> mx,mn; 	std::multiset<int>::iterator it;  	ans = 0;  	cin >> n >> k; 	rep(i,n) cin >> a[i];  	int p = 1; 	if(n == 1){ 		cout << 1 << endl; //		continue; 	}  	mx.insert(-a[1]); 	mn.insert(a[1]);  	for(int i = 2 ; i <= n;++i){ 		mx.insert(-a[i]); 		mn.insert(a[i]); 		 		while(1){ 			tmx = - (*mx.begin()); 			tmn = (*mn.begin()); 			if( tmx - tmn <= k) break; 			// remove. 			mx.erase(mx.find(-a[p])); 			mn.erase(mn.find(a[p])); 			p++; 		} 		 		tmx = - (*mx.begin()); 		tmn = (*mn.begin()); 		if(tmx - tmn == k) ans = max( ans , i - p+1); 	} 	cout << ans << endl; }  	return 0; }           
#include<bits/stdc++.h> using namespace std; #define ll long long int  ll a[1000000]; int main() { 	ll x,n,k,i,count=0; 	scanf("%lld%lld",&n,&k); 	for(i=0;i<n;i++) 	{ 		scanf("%lld",&a[i]); 			 	} 	sort(a,a+n);  	for(i=0;i<n;i++) 	{ 		if(a[i]==a[i+1]) 		continue; 		if((a[i]%2==1)&&(a[i]<k)) 		count++; 	} 	printf("%lld",count); 	return 0; }
/* Author : RISHAV GOYAL */   #include <bits/stdc++.h> // sherlock holmes using namespace std;   #define LL long long int #define UL unsigned long long int   #define imax INT_MAX #define imin INT_MIN #define LLmax LLONG_MAX #define LLmin LLONG_MIN   #define FOR(i,a,b) for(int i= (int)a; i<= (int)b; i++) #define rep(i,n) for(int i= int(1); i<= (int)n; i++) #define FORd(i,a,b,d) for(int i=(int)a; i<= (int)b; i+=(int)d)   #define pr() printf("Reached here 1...\n"); #define pr1() printf("Reached here 2...\n");   #define CLR(a) memset(a,0,sizeof(a)); #define SET(a) memset(a,-1,sizeof(a));   #define str strlen #define sz size() #define pb(x) push_back(x) #define mp make_pair #define ii pair<int,int> #define ll pair<LL,LL>   #define F first #define S second #define gcd(a,b) __gcd(a,b)   #define mod int(1e9 + 7) #define MAX int(1e5 + 10)   #define si(a) scanf("%d",&a);   #define VI vector<int> #define VL vector<LL> #define VS vector<string> #define VC vector<char>   LL powmod(LL a,int b,int n){LL rm=1;while (b){if (b % 2) { rm = (rm * a) % n; }a = (a * a) % n;b /= 2;}return rm;}   #define gc getchar_unlocked   void sint(int &x) { 	register int c = gc(); 	x = 0; 	for(;(c<48 || c>57);c = gc()); 	for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} }  vector<int> edge[5010]; int answer = 0; int a[6000], n, K;  void dfs(int v,int p,int mn,int mx,int l){ 	++l; 	mn = min(mn , a[v]); 	mx = max(mx, a[v]); 	if(l>1 && mx-mn>=K){ 		answer++; 	} 	for(int i=0;i<edge[v].sz;++i){ 		int vr = edge[v][i]; 		if( vr != p){ 			dfs(vr,v,mn,mx,l); 		} 	} }  int main() { 	int u,v; 	sint(n); sint(K); 	rep(i,n) sint(a[i]); 	rep(i,n-1){ 		sint(u); sint(v); 		edge[u].pb(v); 		edge[v].pb(u); 	} 	for(int i=1;i<=n;++i){ 		dfs(i,-1,a[i],a[i],0); 	} 	printf("%d\n",answer/2); 	return 0; } 
#include <cmath> #include <cstdio> #include <vector> #include <iostream> #include <algorithm> using namespace std;   typedef unsigned int ui; int main() {     ui n,m,a,b,k,sum=0;     cin>>n>>m;     while(m--)     {         cin>>a>>b>>k;         sum += ((b-a) + 1)*k;      }         cout<<(int)(sum/n)<<endl;          return 0; }
#include<bits/stdc++.h> #include<string.h> using namespace std; int main() { 	int t,i,n,flag; 	scanf("%d",&t); 	char str[101]; 	vector<char> ans(101); 	while(t--) 	{ 		flag=0; 		scanf("%s",&str); 		n=strlen(str); 		for(i=0;i<n;i++) 			ans[i]=str[i]; 		next_permutation(ans.begin(),ans.begin()+n); 		for(i=0;i<n;i++) 		{ 			if(ans[i]!=str[i]) 			{ 				flag++; 				break; 			} 		} 		if(flag==1) 		{ 			for(i=0;i<n;i++) 				printf("%c",ans[i]); 		} 		else 			printf("no answer"); 		printf("\n"); 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; #define ll long long int main() {     vector<ll> fib(88);     set<ll> s;     ll i,t,n;     fib[0]=0;     fib[1]=1;     s.insert(0);     s.insert(1);     for(i=2;i<=87;i++)     {         fib[i]=fib[i-1]+fib[i-2];         s.insert(fib[i]);     }     set<ll>::iterator it;     scanf("%lld",&t);     while(t--)     {         scanf("%lld",&n);         it=s.find(n);         if(it!=s.end())         {             printf("IsFibo\n");         }         else         {             printf("IsNotFibo\n");         }     }     return 0; } 
#include<iostream> using namespace std; int main() { long long int n,l; cin>>n; if(n==1)     cout<<0;  else if(n==0)     cout<<1;  else if(n%2==1)     cout<<4; for(int i=0;i<n/2;i++)     cout<<8;  } 
#include <bits/stdc++.h> #define _ ios_base::sync_with_stdio(false);cin.tie(0); using namespace std; #define pb push_back #define pob pop_back #define pf push_front #define pof pop_front #define mp make_pair #define all(a) a.begin(),a.end() #define bitcnt(x) __builtin_popcountll(x) #define M 1000000007 typedef unsigned long long int uint64; typedef long long int int64;  string s[5]; int main(){ 	int i,j; 	for(i=0;i<4;i++) 	cin>>s[i]; 	int flag=0; 	for(i=0;i<4;i++){ 		for(j=0;j<4;j++){ 			if(i>0&&j>0){ 				if(s[i-1][j]==s[i-1][j-1]&&s[i-1][j]==s[i][j-1]){ 				flag=1; 				break;} 			} 			if(i>0&&j<3){ 				if(s[i-1][j+1]==s[i][j+1]&&s[i-1][j+1]==s[i-1][j]){ 					flag=1; 					break; 				} 			} 			if(i<3&&j>0){ 				if(s[i][j-1]==s[i+1][j-1]&&s[i+1][j]==s[i][j-1]){ 				flag=1; 				break;} 			} 			if(i<3&&j<3){ 				if(s[i][j+1]==s[i+1][j]&&s[i+1][j+1]==s[i][j+1]){ 				flag=1; 				break;} 			}	 		} 		if(flag==1) 		break; 	} 	if(flag==1){ 		cout<<"POSSIBLE"; 	} 	else{ 		cout<<"NOT POSSIBLE"; 	} 	return 0; }
#include <bits/stdc++.h> #define _ ios_base::sync_with_stdio(false);cin.tie(0); using namespace std; #define pb push_back #define pob pop_back #define pf push_front #define pof pop_front #define mp make_pair #define all(a) a.begin(),a.end() #define bitcnt(x) __builtin_popcountll(x) #define M 1000000007 typedef unsigned long long int uint64; typedef long long int int64;  int main(){ 	vector<int>v; 	int n; 	while(cin>>n){ 		v.pb(n); 	} 	sort(all(v)); 	n=v.size(); 	int ans,cnt=558; 	do{ 		int val=0,tmp=0; 		for(int i=0;i<n;i++){ 			val=val*10+v[i]; 		} 		int l=sqrt(val); 		for(int i=1;i<=l;i++){ 			if(val%i==0) 			tmp+=2; 		} 		if(l*l==val) 		tmp--; 		if(tmp<cnt){ 		ans=val;	 		cnt=tmp;} 	}while(next_permutation(all(v))); 	cout<<ans<<endl; 	return 0; }
#include <bits/stdc++.h> #define _ ios_base::sync_with_stdio(false);cin.tie(0); using namespace std; #define pb push_back #define pob pop_back #define pf push_front #define pof pop_front #define mp make_pair #define all(a) a.begin(),a.end() #define bitcnt(x) __builtin_popcountll(x) #define M 1000000007 typedef unsigned long long int uint64; typedef long long int int64;  string s; int ans,n; void go(int idx,int cost,int col){ 	if(cost>=ans) 	return ; 	if(idx==n-1){ 		ans=min(cost,ans); 		return; 	} 	for(int i=idx+1;i<n;i++){ 		if(col==0){ 			if(s[i]=='G') 			go(i,cost+(i-idx)*(i-idx),1); 		} 		if(col==1){ 			if(s[i]=='B') 			go(i,cost+(i-idx)*(i-idx),2); 		} 		if(col==2){ 			if(s[i]=='R') 			go(i,cost+(i-idx)*(i-idx),0); 		} 	} } int main(){ 	int t; 	cin>>t; 	while(t--){ 		cin>>s; 		n=s.length(); 		ans=1e7; 		go(0,0,0); 		if(ans==1e7) 		cout<<-1<<endl; 		else 		cout<<ans<<endl; 	} 	return 0; }
#include <bits/stdc++.h>  using namespace std;  int a[1<<8][1<<8];  int main() {     int n;     int t;     cin >> t;     while (t--) {     cin >> n;     for (int i = 0; i < n; i++) {         string s;         cin >> s;         for (int j = 0; j < n; j++) {             a[i][j] = s[j];             if (s[j] == '-') {                 a[i][j] = (1<<20);                 continue;             }             if (a[i][j] >= 'a' && a[i][j] <= 'z') {                 a[i][j] = a[i][j] - 87;             } else if (a[i][j] >= 'A' && a[i][j] <= 'Z') {                 a[i][j] = a[i][j] - 29;             } else if (a[i][j] >= '0' && a[i][j] <= '9') {                 a[i][j] = a[i][j] - 48;             } else { 		a[i][j] = (1<<20); 	    }         }     }      for (int i = 0; i < n; i++) {         for (int j = 0; j < n; j++) {             for (int k = 0; k < n; k++) {                 if (a[j][i] + a[i][k] < a[j][k]) { 		   if (j != k && a[j][i] != (1<<20) && a[i][k] != (1<<20))                     a[j][k] = a[j][i] + a[i][k];                 }             }         }     }     int mx = 0;     for (int i = 0; i < n; i++) {         for (int j = 0; j < n; j++) {             if (i == j) {                 continue;             }             mx = max(a[i][j], mx);         }     }     if (mx < (1<<20)) {         cout << mx << endl;     } else {         cout << "-1" << endl;     } }     return 0; } 
#include<iostream> #include<cstdio> #include<cmath> #include<cstring> #include<stdlib.h> #include<algorithm> #define getcx getchar_unlocked #ifndef ONLINE_JUDGE     #define getcx getchar #endif #define l long long using namespace std; inline void string(char *str) {     register char c = 0;     register int i = 0;     while (c < 33)         c = getcx();     while (c != '\n') {         str[i] = c;         c = getcx();         i = i + 1;     }     str[i] = '\0'; } inline int inp() {    int n=0;    int ch=getcx();int sign=1;    while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )            n = (n<<3)+(n<<1) + ch-'0', ch=getcx();    return n*sign; } inline long long in() {    long long n=0;    long long ch=getcx();long long sign=1;    while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )            n = (n<<3)+(n<<1) + ch-'0', ch=getcx();    return n*sign; } main() { 	l t,n,a,b,sum; 	t=in(); 	while(t--) 	{ 		n=in(); 		sum=0; 		while(n--) 		{ 			a=in(); 			b=in(); 			sum+=(a*b); 		} 		printf("%lld\n",sum); 	} }
#include <iostream> using namespace std; typedef long long int uint64; uint64 PowMod(uint64 x, uint64 e, uint64 mod) { uint64 res;   if (e == 0) { res = 1%mod; } else if (e == 1) { res = x%mod; } else { res = PowMod(x, e / 2, mod); res = res * res % mod; if (e % 2) res = (res * x )% mod; }   return res; } int main()  { 	long long int t; 	scanf("%lld",&t); 	while(t--) 	{ 	long long int n; 	scanf("%lld",&n); 	printf("%lld\n",(PowMod(2,n,1000000007)+PowMod(3,n,1000000007))%1000000007); 	} 	return 0; }
#include<iostream> #include<cstdio> #include<cmath> #include<cstring> #include<stdlib.h> #include<algorithm> #define getcx getchar_unlocked #ifndef ONLINE_JUDGE     #define getcx getchar #endif #define l long long using namespace std; inline void string(char *str) {     register char c = 0;     register int i = 0;     while (c < 33)         c = getcx();     while (c != '\n') {         str[i] = c;         c = getcx();         i = i + 1;     }     str[i] = '\0'; } inline int inp() {    int n=0;    int ch=getcx();int sign=1;    while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )            n = (n<<3)+(n<<1) + ch-'0', ch=getcx();    return n*sign; } inline long long in() {    long long n=0;    long long ch=getcx();long long sign=1;    while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )            n = (n<<3)+(n<<1) + ch-'0', ch=getcx();    return n*sign; } #define MOD 1000000007 main() { //	freopen("in.txt","r",stdin); 	l t,n,m,b[1001],p[1001],n1,flag; 	char name[1001][101]; 	t=in(); 	while(t--) 	{ 		n=in(); 		m=in(); 		for(l k=0,i=0;k<n;++i,++k) 		{ 			b[i]=in(); 			//string(name[i]); 			scanf("%s",&name[i]); 			p[i]=in(); 			for(l j=0;j<i;++j) 			{ 				flag=strcmp(name[j],name[i]); 				if(flag==0) 				{ 					p[j]+=p[i]; 					--i; 					break; 				} 			} 			n1=i; 		//	cout<<n1<<" "; 		} 		//cout<<n1<<" "; 		l max=0,min=0; 		sort(p,p+n1+1); 		for(l i=0;i<m;++i) 		{ 			min+=p[i]; 			max+=p[n1-i]; 		} 		printf("%lld\n",max-min); 	} }
#include<iostream> #include<cstdio> #include<cmath> #include<cstring> #include<stdlib.h> #include<algorithm> #define getcx getchar_unlocked #ifndef ONLINE_JUDGE     #define getcx getchar #endif #define l long long using namespace std; inline void string(char *str) {     register char c = 0;     register int i = 0;     while (c < 33)         c = getcx();     while (c != '\n') {         str[i] = c;         c = getcx();         i = i + 1;     }     str[i] = '\0'; } inline int inp() {    int n=0;    int ch=getcx();int sign=1;    while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )            n = (n<<3)+(n<<1) + ch-'0', ch=getcx();    return n*sign; } inline long long in() {    long long n=0;    long long ch=getcx();long long sign=1;    while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )            n = (n<<3)+(n<<1) + ch-'0', ch=getcx();    return n*sign; } #define MOD 1000000007 main() { 	l t,n,a[101][101]; 	t=in(); 	while(t--) 	{ 		n=in(); 		for(l i=0;i<n;++i) 		{ 			for(l j=0;j<n;++j) 			{ 				a[i][j]=in(); 				if(i-1>=0&&j-1>=0) 				a[i][j]+=min(a[i-1][j],a[i][j-1]); 				else if(i-1>=0) 				a[i][j]+=a[i-1][j]; 				else 				a[i][j]+=a[i][j-1]; 			} 		} 		printf("%lld\n",a[n-1][n-1]); 	} }
#include<iostream> #include<cstdio> #include<cmath> #include<cstring> #include<stdlib.h> #include<algorithm> #define getcx getchar_unlocked #ifndef ONLINE_JUDGE     #define getcx getchar #endif #define l long long using namespace std; inline void string(char *str) {     register char c = 0;     register int i = 0;     while (c < 33)         c = getcx();     while (c != '\n') {         str[i] = c;         c = getcx();         i = i + 1;     }     str[i] = '\0'; } inline int inp() {    int n=0;    int ch=getcx();int sign=1;    while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )            n = (n<<3)+(n<<1) + ch-'0', ch=getcx();    return n*sign; } inline long long in() {    long long n=0;    long long ch=getcx();long long sign=1;    while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )            n = (n<<3)+(n<<1) + ch-'0', ch=getcx();    return n*sign; } // A utility function to get the middle index from corner indexes. int getMid(int s, int e) {  return s + (e -s)/2;  }  /*  A recursive function to get the sum of values in given range of the array.     The following are parameters for this function.      st    --> Pointer to segment tree     index --> Index of current node in the segment tree. Initially 0 is              passed as root is always at index 0     ss & se  --> Starting and ending indexes of the segment represented by                  current node, i.e., st[index]     qs & qe  --> Starting and ending indexes of query range */ int getSumUtil(int *st, int ss, int se, int qs, int qe, int index) {     // If segment of this node is a part of given range, then return the      // sum of the segment     if (qs <= ss && qe >= se)         return st[index];      // If segment of this node is outside the given range     if (se < qs || ss > qe)         return 0;      // If a part of this segment overlaps with the given range     int mid = getMid(ss, se);     return getSumUtil(st, ss, mid, qs, qe, 2*index+1) +            getSumUtil(st, mid+1, se, qs, qe, 2*index+2); }  /* A recursive function to update the nodes which have the given index in    their range. The following are parameters     st, index, ss and se are same as getSumUtil()     i    --> index of the element to be updated. This index is in input array.    diff --> Value to be added to all nodes which have i in range */ void updateValueUtil(int *st, int ss, int se, int i, int diff, int index) {     // Base Case: If the input index lies outside the range of this segment     if (i < ss || i > se)         return;      // If the input index is in range of this node, then update the value     // of the node and its children     st[index] = st[index] + diff;     if (se != ss)     {         int mid = getMid(ss, se);         updateValueUtil(st, ss, mid, i, diff, 2*index + 1);         updateValueUtil(st, mid+1, se, i, diff, 2*index + 2);     } }  // The function to update a value in input array and segment tree. // It uses updateValueUtil() to update the value in segment tree void updateValue(int arr[], int *st, int n, int i, int new_val) {     // Check for erroneous input index     if (i < 0 || i > n-1)     {         printf("Invalid Input");         return;     }      // Get the difference between new value and old value     int diff = new_val - arr[i];      // Update the value in array     arr[i] = new_val;      // Update the values of nodes in segment tree     updateValueUtil(st, 0, n-1, i, diff, 0); }  // Return sum of elements in range from index qs (quey start) to // qe (query end).  It mainly uses getSumUtil() int getSum(int *st, int n, int qs, int qe) {     // Check for erroneous input values     if (qs < 0 || qe > n-1 || qs > qe)     {         printf("Invalid Input");         return -1;     }      return getSumUtil(st, 0, n-1, qs, qe, 0); }  // A recursive function that constructs Segment Tree for array[ss..se]. // si is index of current node in segment tree st int constructSTUtil(int arr[], int ss, int se, int *st, int si) {     // If there is one element in array, store it in current node of     // segment tree and return     if (ss == se)     {         st[si] = arr[ss];         return arr[ss];     }      // If there are more than one elements, then recur for left and     // right subtrees and store the sum of values in this node     int mid = getMid(ss, se);     st[si] =  constructSTUtil(arr, ss, mid, st, si*2+1) +               constructSTUtil(arr, mid+1, se, st, si*2+2);     return st[si]; }  /* Function to construct segment tree from given array. This function    allocates memory for segment tree and calls constructSTUtil() to    fill the allocated memory */ int *constructST(int arr[], int n) {     // Allocate memory for segment tree     int x = (int)(ceil(log2(n))); //Height of segment tree     int max_size = 2*(int)pow(2, x) - 1; //Maximum size of segment tree     int *st = new int[max_size];      // Fill the allocated memory st     constructSTUtil(arr, 0, n-1, st, 0);      // Return the constructed segment tree     return st; }  // Driver program to test above functions int main() {     int t,arr[100001],task,k,m,d,q,n;     t=in();     //int n = sizeof(arr)/sizeof(arr[0]); 	while(t--) 	{ 		n=inp(); 		q=inp(); 		for(l i=0;i<n;++i) 		arr[i]=in(); 		int *st = constructST(arr, n); 		while(q--) 		{ 			task=in(); 			if(task==1) 			{ 				d=in(); 				printf("%d\n",arr[d]); 				updateValue(arr, st, n, d, 0); 			} 			else if(task==2) 			{ 				k=in(); 				m=in(); 				//cout<<arr[k]<<" "; 				updateValue(arr, st, n, k, arr[k]+m); 			} 			else 			{ 				k=in(); 				m=in(); 				printf("%d\n",getSum(st, n, k, m)); 			} 		}		 	} }           // Print sum of values in array from index 1 to 3     //printf("Sum of values in given range = %d\n", getSum(st, n, 1, 3));      // Update: set arr[1] = 10 and update corresponding segment     // tree nodes           // Find sum after the value is updated    // printf("Updated sum of values in given range = %d\n",                                      
#include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<string> #include<cstring> #include<sstream> #include<cmath> #include<climits> #include<map> #include<set> #include<stack> #include<queue> #include<iterator> using namespace std;   #define s(n) scanf("%d",&n) #define sl(n) scanf("%ld",&n) #define sll(n) scanf("%lld",&n)   #define sstr(str) scanf ("%s", str);    #define p(n) printf("%d ",n) #define pl(n) printf("%ld ",n) #define pll(n) printf("%lld ",n)   #define pf(n) printf("%f\n",n) #define pd(n) printf("%lf\n",n)   #define pnl(n) printf("%d\n",n) #define plnl(n) printf("%ld\n",n) #define pllnl(n) printf("%lld\n",n) #define nl() putchar_unlocked('\n')   #define ll long long #define MAX(a,b) a>b?a:b #define all(c) c.begin(), c.end() #define rall(c) c.rbegin(), c.rend()    // reverse all  #define pb push_back #define tr(c,it) for(typeof(c.begin()) it = c.begin(); it !=c.end(); it++) #define loop(i,a,n) for(int i=a;i<n;i++) typedef vector<int> vi; typedef vector<long long> vll; typedef vector< vector<int> > vvi; typedef vector<string> vstr;   #define sz(a) int((a).size())  #define szar(a) int(sizeof(ar)/sizeof(ar[0])) #define osit ostream_iterator    void pvec(vi v) {   tr(v,it) { p(*it);}   nl(); }   void pvec(vll v) {   tr(v,it) { pll(*it);}   nl(); }   std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems)            {     std::stringstream ss(s);                                            //  aa#bc#d -> aa, b,c,d     std::string item;                                                   //  aa##c#d -> aa, "", c,d     while (std::getline(ss, item, delim)) {                             //  aa#bc#  -> aa, bc, ""         elems.push_back(item);                                          //  #a#b#   -> "", a, b, ""     }     if(s[s.size() - 1] == delim) elems.push_back("");     return elems; }     std::vector<std::string> split(const std::string &s, char delim) {     std::vector<std::string> elems;     split(s, delim, elems);     return elems; }   int get()                  // working even in loops, working excellent {   char c;   while(c=getchar_unlocked(),(c<'0'||c>'9')&&(c!='-'));   bool Flag=(c=='-');   if(Flag)     c=getchar_unlocked();   int X=0;   while(c>='0'&&c<='9')     {       X=X*10+c-48;       c=getchar_unlocked();     }   return Flag?-X:X; }   inline void get(char *str)   {     register char c = 0;     register int i = 0;     while (c < 33)         c = getchar_unlocked();       while (c != '\n') {         str[i] = c;         c = getchar_unlocked();         i = i + 1;     }     str[i] = '\0';   }   void output(int X)        // working even in loops, working excellent {   if(X<0)     {       putchar_unlocked('-');       X=-X;     }   int Len=0,Data[10];   while(X)     {       Data[Len++]=X%10;       X/=10;     }   if(!Len)     Data[Len++]=0;   while(Len--)     putchar_unlocked(Data[Len]+48);     putchar_unlocked(' '); } void output(ll X)        // working even in loops, working excellent {   if(X<0)     {       putchar_unlocked('-');       X=-X;     }   int Len=0,Data[10];   while(X)     {       Data[Len++]=X%10;       X/=10;     }   if(!Len)     Data[Len++]=0;   while(Len--)     putchar_unlocked(Data[Len]+48);     putchar_unlocked(' '); }   template<class T> void p2d(T c, int n,int m) {   nl();   loop(i,0,n)   {     loop(j,0,m)     {       cout << c[i][j] << " ";     }     nl();   } }   int main() {   // DONT USE FAST I/O METHODS when dealing with file input/ouput // get() giving error if using the below file i/o     /*#ifndef ONLINE_JUDGE   freopen("input.txt","r",stdin);   freopen("output.txt","w",stdout);   #endif */   int t=get();   while(t--)   {     int cnt=0;     int n=get();     while(true)     {       //printf("n / 7==%d\n",n%7 );       if(n%7 == 0)       {         n /= 7;         cnt++;       }        else break;      }     //printf("the cnt is %d\n",cnt );     if(cnt==2) printf("YES\n");     else printf("NO\n");   }          return 0; }
#include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<string> #include<cstring> #include<sstream> #include<cmath> #include<climits> #include<map> #include<set> #include<stack> #include<queue> #include<iterator> using namespace std;   #define s(n) scanf("%d",&n) #define sl(n) scanf("%ld",&n) #define sll(n) scanf("%lld",&n)   #define sstr(str) scanf ("%s", str);    #define p(n) printf("%d ",n) #define pl(n) printf("%ld ",n) #define pll(n) printf("%lld ",n)   #define pf(n) printf("%f\n",n) #define pd(n) printf("%lf\n",n)   #define pnl(n) printf("%d\n",n) #define plnl(n) printf("%ld\n",n) #define pllnl(n) printf("%lld\n",n) #define nl() putchar_unlocked('\n')   #define ll long long #define MAX(a,b) a>b?a:b #define all(c) c.begin(), c.end() #define rall(c) c.rbegin(), c.rend()    // reverse all  #define pb push_back #define tr(c,it) for(typeof(c.begin()) it = c.begin(); it !=c.end(); it++) #define loop(i,a,n) for(int i=a;i<n;i++) typedef vector<int> vi; typedef vector<long long> vll; typedef vector< vector<int> > vvi; typedef vector<string> vstr;   #define sz(a) int((a).size())  #define szar(a) int(sizeof(ar)/sizeof(ar[0])) #define osit ostream_iterator    void pvec(vi v) {   tr(v,it) { p(*it);}   nl(); }   void pvec(vll v) {   tr(v,it) { pll(*it);}   nl(); }   std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems)            {     std::stringstream ss(s);                                            //  aa#bc#d -> aa, b,c,d     std::string item;                                                   //  aa##c#d -> aa, "", c,d     while (std::getline(ss, item, delim)) {                             //  aa#bc#  -> aa, bc, ""         elems.push_back(item);                                          //  #a#b#   -> "", a, b, ""     }     if(s[s.size() - 1] == delim) elems.push_back("");     return elems; }     std::vector<std::string> split(const std::string &s, char delim) {     std::vector<std::string> elems;     split(s, delim, elems);     return elems; }   int get()                  // working even in loops, working excellent {   char c;   while(c=getchar_unlocked(),(c<'0'||c>'9')&&(c!='-'));   bool Flag=(c=='-');   if(Flag)     c=getchar_unlocked();   int X=0;   while(c>='0'&&c<='9')     {       X=X*10+c-48;       c=getchar_unlocked();     }   return Flag?-X:X; }   inline void get(char *str)   {     register char c = 0;     register int i = 0;     while (c < 33)         c = getchar_unlocked();       while (c != '\n') {         str[i] = c;         c = getchar_unlocked();         i = i + 1;     }     str[i] = '\0';   }   void output(int X)        // working even in loops, working excellent {   if(X<0)     {       putchar_unlocked('-');       X=-X;     }   int Len=0,Data[10];   while(X)     {       Data[Len++]=X%10;       X/=10;     }   if(!Len)     Data[Len++]=0;   while(Len--)     putchar_unlocked(Data[Len]+48);     putchar_unlocked(' '); } void output(ll X)        // working even in loops, working excellent {   if(X<0)     {       putchar_unlocked('-');       X=-X;     }   int Len=0,Data[10];   while(X)     {       Data[Len++]=X%10;       X/=10;     }   if(!Len)     Data[Len++]=0;   while(Len--)     putchar_unlocked(Data[Len]+48);     putchar_unlocked(' '); }   template<class T> void p2d(T c, int n,int m) {   nl();   loop(i,0,n)   {     loop(j,0,m)     {       cout << c[i][j] << " ";     }     nl();   } }   int main() {   // DONT USE FAST I/O METHODS when dealing with file input/ouput // get() giving error if using the below file i/o     /*#ifndef ONLINE_JUDGE   freopen("input.txt","r",stdin);   freopen("output.txt","w",stdout);   #endif */   int t=get();   while(t--)   {     string s1,s2;     cin >> s1;     cin >> s2;     sort(s1.begin(),s1.end());     sort(all(s2));      if(s1 == s2) printf("YES\n");     else printf("NO\n");    }       return 0; }
//Author : pakhandi //   using namespace std;   #include<iostream> #include<cstdio> #include<cstdlib> #include<algorithm> #include<cmath> #include<cstring>   #define wl while #define fl(i,a,b) for(i=a; i<b; i++)   int main() { 	long long int n, sum=0; 	scanf("%lld", &n); 	printf("%d\n",(n/5)); 	n=n%5; 	printf("%d\n",(n/3)); 	n%=3; 	printf("%d\n",(n/2)); 	n%=2; 	printf("%d\n",(n)); 	return 0; }  
#include<iostream> #include <stdio.h> #include <string.h> using namespace std;  // A utility function to print a substring str[low..high] void printSubStr( char* str, int low, int high ) {if(high==0)printf("None"); else{     for( int i = low; i <= high; ++i )         printf("%c", str[i]);} }   // This function prints the longest palindrome substring of str[]. // It also returns the length of the longest palindrome int longestPalSubstr( char *str ) {     int n = strlen( str ); // get length of input string       // table[i][j] will be false if substring str[i..j] is not palindrome.     // Else table[i][j] will be true     bool table[n][n];     memset( table, 0, sizeof( table ) );       // All substrings of length 1 are palindromes     int maxLength = 1;     for( int i = 0; i < n; ++i )         table[i][i] = true;       // check for sub-string of length 2.     int start = 0;     for( int i = 0; i < n-1; ++i )     {         if( str[i] == str[i+1] )         {             table[i][i+1] = true;             start = i;             maxLength = 2;         }     }       // Check for lengths greater than 2. k is length of substring     for( int k = 3; k <= n; ++k )     {         // Fix the starting index         for( int i = 0; i < n - k + 1 ; ++i )         {             // Get the ending index of substring from starting index i and length k             int j = i + k - 1;               // checking for sub-string from ith index to jth index iff str[i+1]             // to str[j-1] is a palindrome             if( table[i+1][j-1] && str[i] == str[j] )             {                 table[i][j] = true;                   if( k > maxLength )                 {                     start = i;                     maxLength = k;                 }             }         }     }       //printf("Longest palindrome substring is: ");     printSubStr( str, start, start + maxLength - 1 );       return maxLength; // return length of LPS }   // Driver program to test above functions int main() {     char str[100];     cin>>str;     longestPalSubstr( str ) ;     return 0; }
#include<cmath> #include<iostream> #include<cstdio> #include<algorithm> #include<cstring> using namespace std; int main(){ string str[]={"orez", "eno","owt","eerht","ruof","evif","xis","neves","thgie","enin","net", "nevele","evlewt","neetriht", "neetruof","neetfif","neetxis","neetneves","neethgie","neetenin","ytnewt","enoytnewt", "owtytnewt","eerhtytnewt","ruofytnewt","evifytnewt","xisytnewt","nevesytnewt","thgieytnewt", "eninytnewt","ytriht","enoytriht","owtytriht","eerhtytriht","ruofytriht","evifytriht","xisytriht","nevesytriht", "thgieytriht","eninytriht","ytruof","enoytruof","owtytruof","eerhtytruof","ruofytruof","evifytruof","xisytruof", "nevesytruof","thgieytruof","eninytruof","ytfif" }; int n; int arr[10],i=0; int t=5; while(t--){     cin>>n; arr[i++]=n; } string str2[i]; for(int j=0;j<i;j++){ str2[j]=str[arr[j]]; } sort(str2,str2+i); for(int j=0;j<i;j++){ for(int m=0;m<51;m++){ if(str2[j]==str[m]){ cout<<m<<' '; break;} } } return 0; }  
//Author : pakhandi //   using namespace std;   #include<iostream> #include<cstdio> #include<cstdlib> #include<algorithm> #include<cmath> #include<cstring>   #define wl while #define fl(i,a,b) for(i=a; i<b; i++)   int main() { 	int d, m; 	scanf("%d%d", &d, &m); 	int temp=d%6; 	switch(m) 	{ 		case 1 : switch(temp) 				 { 				 	case 1 : printf("1"); 				 	break; 				 	case 2 : printf("2"); 				 	break; 				 	case 3 : printf("3"); 				 	break; 				 	case 4 : printf("4"); 				 	break; 				 	case 5 : printf("5"); 				 	break; 				 	case 0 : printf("6"); 				 	break; 				 } 		break; 		case 2 : switch(temp) 				 { 				 	case 1 : printf("2"); 				 	break; 				 	case 2 : printf("3"); 				 	break; 				 	case 3 : printf("4"); 				 	break; 				 	case 4 : printf("5"); 				 	break; 				 	case 5 : printf("6"); 				 	break; 				 	case 0 : printf("1"); 				 	break; 				 } 		break; 		case 3 : switch(temp) 				 { 				 	case 1 : printf("2"); 				 	break; 				 	case 2 : printf("3"); 				 	break; 				 	case 3 : printf("4"); 				 	break; 				 	case 4 : printf("5"); 				 	break; 				 	case 5 : printf("6"); 				 	break; 				 	case 0 : printf("1"); 				 	break; 				 } 		break; 		case 4 : switch(temp) 				 { 				 	case 1 : printf("1"); 				 	break; 				 	case 2 : printf("2"); 				 	break; 				 	case 3 : printf("3"); 				 	break; 				 	case 4 : printf("4"); 				 	break; 				 	case 5 : printf("5"); 				 	break; 				 	case 0 : printf("6"); 				 	break; 				 } 		break; 		case 5 : switch(temp) 				 { 				 	case 1 : printf("5"); 				 	break; 				 	case 2 : printf("6"); 				 	break; 				 	case 3 : printf("1"); 				 	break; 				 	case 4 : printf("2"); 				 	break; 				 	case 5 : printf("3"); 				 	break; 				 	case 0 : printf("4"); 				 	break; 				 } 		break; 		case 6 : switch(temp) 				 { 				 	case 1 : printf("2"); 				 	break; 				 	case 2 : printf("3"); 				 	break; 				 	case 3 : printf("4"); 				 	break; 				 	case 4 : printf("5"); 				 	break; 				 	case 5 : printf("6"); 				 	break; 				 	case 0 : printf("1"); 				 	break; 				 } 		break; 	} 	return 0; }
#include<bits/stdc++.h>  #define mod 1000000007 #define f(i,a,b) for(i=a;i<b;i++) #define ff(i,a)  for(i=0;i<a;i++) #define sc scanf #define pr printf #define clr(a) memset(a,0,sizeof(a)) #define ll long long  #define vi vector<int> #define pin(n) printf("%d\n",n) #define pll(n) printf("%lld\n",n) #define sin(n) scanf("%d",&n) #define sll(n) scanf("%lld",&n) #define pins(n) printf("%d ",n) #define plls(n) printf("%lld ",n) #define ss(n) scanf("%s",n) #define nl pr("\n")  using namespace std;   int main() { 	int n; 	sin(n); 	int i,j,k; 	for(i=0;i*5<=n;i++) 	for(j=0;j*3<=n;j++) 	for(k=0;k*2<=n;k++) 		if(i*5+j*3+k*2==n) 		{ 			pins(i);pins(j);pin(k); 		}  	return 0; }  
#include <iostream>  using namespace std; int main() { 	unsigned long long t,n,m; 	cin>>t; 	while(t--) 	{ 		cin>>n>>m; 		cout<<(n*(n-1)/2)*(m*(m-1)/2)<<endl; 	} 	return 0; } 
/* Name- Aayush Agarwal    Language -C++    */ #include <cstdio> #include <iostream> #include <cmath> #include <cstring> #include <cstdlib> #include <ctime> #include <climits> #include <set> #include <map> #include <vector> #include <queue> #include <list> #include <deque> #include <stack> #include <iterator> #include <cassert> #include <cctype> #include <string> #include <sstream> #include <fstream> #include <functional> #include <numeric> #include <utility> #include <algorithm> #define fOr(i,n) for(int i=0;i<n;i++) #define For(i,n) for(int i=1;i<=n;i++) #define ss(a) scanf("%s",a) #define si(a) scanf("%d",&a) #define sl(a) scanf("%lld",&a) #define pi(a) printf("%d ",a) #define pl(a) printf("%lld ",a) #define ps(a) printf("%s ",a) #define nl    printf("\n"); #define ll long long int #define ull unsigned long long int #define mod 1000000007 using namespace std;  const double eps=1e-9; const double PI=2*acos(0.0);  #define VI vector<int> #define VS vector<string> #define VL vector<long long int> #define VVI vector<VI> #define PII pair<int,int> #define PLL pair<ll,ll> #define PSS pair<string,string> #define PSI pair<string,int> #define VPII vector<PII> #define VPLL vector<PLL> #define VPSS vector<PSS> #define VPSI vector<PSI> #define pb(a) push_back(a) #define mp(a,b) make_pair(a,b) #define sqr(x) ((x)*(x)) #define min(a,b) ((a<b)?a:b)   ll dp[10005][12];  int  main() {	  	for(int i=0;i<=10;i++) 	{ 		dp[0][i]=1; 	} 	 	for(int i=1;i<=10000;i++) 	{ 		for(int j=1;j<=10;j++) 		{ 			if(i==j) 			dp[i][j]=(1<<i)-1; 			else if(i<j) 			dp[i][j]=(1<<i); 			else 			{ 				dp[i][j]=dp[i-1][j]+dp[i-1][j]-dp[i-j-1][j]+mod; 				if(dp[i][j]>=mod) 				dp[i][j]%=mod; 			} 		} 	} 	int t,n,k; 	si(t); 	while(t--) 	{ 		si(n); 		si(k); 		if(n==1) 		printf("1\n"); 		else 		cout<<dp[n-1][k]<<endl; 		 	} 	 }
#include<iostream> #include<algorithm> #include<cmath> using namespace std; long long int n,i,ct,temp,start,end1; struct sethu {     long long int x;     long long int l; }point[200005]; bool fun(struct sethu s1,struct sethu s2) {     return (s1.x<=s2.x); } int main() {     cin>>n;     for(i=1;i<=2*n;i+=2)     {         cin>>point[i].x>>point[i+1].x;         point[i].l=1;         point[i+1].l=-1;     }     sort(point+1,point+2*n+1,fun);     ct=1;     temp=0;     for(i=1;i<=2*n;i++)     {        if(point[i].l==1)         temp++;     else         temp--;     ct=max(ct,temp);     }     //ct=max(ct,temp);     cout<<ct<<"\n" ; } 
#include<iostream> #include<set> #include<map> #include<vector> #include<queue> #include<stack> #include<algorithm> #include<cstdio> #include<cstring>   #define sd(x) scanf("%d",&x) #define MP make_pair #define PB push_back #define MOD 1000000007 #define M 40000000 #define F first #define S second #define ll long long int #define LL long long int   using namespace std;   #define N 200001   int vis[N], RIGHT[N], arr[N], LEFT[N], b[101][N]; vector<int> adj[N]; int n; inline LL powr(LL i, LL x, LL c){     if(x <= 0){         return 1%c;     }     LL ans = powr(i, x/2, c);     ans*=ans;     if(ans >= c)         ans %= c;     if(x & 1){         ans *= i;     }     if(ans >= c)         ans %= c;     return ans; } inline int count(int pos, int val){     int ans  =0 ;     while(pos > 0){         ans += b[val][pos];         pos -= (pos & -pos);     }     return ans; } inline int update(int pos, int x, int val){     while(pos <= n){         b[x][pos] += val;         pos += pos & -pos;     }     return 0; } inline int range(int l, int r, int x){     int ans = 0;     ans = count(r, x);     ans -= count(l-1, x);     return ans; } int cnt = 0; inline int make(int x){     cnt++;     int i;     LEFT[x] = cnt;     for(i = 0; i < adj[x].size(); i++){         if(vis[adj[x][i]] == 0){             vis[adj[x][i]] = 1;             make(adj[x][i]);         }     }     RIGHT[x] = cnt;     return 0; } int main(){     int  k, i, x, y, z, pos, l, r;     LL c;     cin>>n>>k;     for(i = 1; i <= n; i++){         sd(arr[i]);     }     for(i = 1; i < n; i++ ){         sd(x);         sd(y);         adj[x].PB(y);         adj[y].PB(x);     }     for(i = 1; i <= n; i++){         vis[i] = 0;     }     vis[1] = 1;     make(1);     for(i = 0; i <= 100; i++){         for(int j = 0; j <= n; j++){             b[i][j] = 0;         }     }     //cout<<"Yes";     for(i = 1; i <= n; i++){         update(LEFT[i], arr[i], 1);     }       for(i = 0; i < k; i++){         sd(x);         sd(y);         sd(z);         if(x == 1){             pos = LEFT[y];             update(pos, arr[pos], -1);             update(pos, z, 1);             arr[pos] = z;         }         else{             LL ans = 1;             l = LEFT[y];             r = RIGHT[y];             c = z;             for(int j = 1; j <= 100; j++){                 x = range(l, r, j);                 //cout<<j<<" "<<x<<endl;                 ans *= powr(j, x, c);                 if(ans >= c){                     ans %= c;                 }             }             printf("%lld\n", ans);//<<endl;         }     }     return 0; }  
//Amit Gupta               #include<bits/stdc++.h> using namespace std; typedef long long LL; typedef pair<int,int> II; #define REP(i,i1,n) for(int i=i1;i<n;i++) #define REPB(i,i1,n) for(int i=i1;i>=n;i--) #define PB push_back #define MP make_pair #define ALL(c) (c).begin(),(c).end() #define F first #define S second #define SZ(a) (LL)a.size() #define EPS 1e-12 #define MOD 1000000007 #define TR1(x) cerr<<#x<<" : "<<x<<endl #define TR2(x,y) cerr<<#x<<" : "<<x<<" | "<<#y<<" : "<<y<<endl #define FAST_IO ios_base::sync_with_stdio(false);cin.tie(NULL) #define SI(c) scanf("%d",&c) #define SII(c,d) scanf("%d%d",&c,&d) #define SLL(c) scanf("%lld",&c) #define PIN(c) printf("%d\n",c) #define PLLN(c) printf("%lld\n",c) #define N 100 #define endl '\n' #define FILL(ar,vl) for(int i=0;i<N;i++)ar[i]=vl #define FILL2(ar,vl) for(int i=0;i<N;i++)for(j=0;j<N;j++)ar[i][j]=vl //--------------------------MAIN CODE STARTS HERE---------------- LL powmod(LL a,LL b) {     if(b==0)return 1;     LL x=powmod(a,b/2);     LL y=(x*x)%MOD;     if(b%2)         return (a*y)%MOD;     return y%MOD; } LL fact[N],ifact[N]; void precal() {     fact[0]=1;ifact[0]=1;     REP(i,1,N) {         fact[i]=(fact[i-1]*i*1LL)%MOD;     }     REP(i,1,N) {         ifact[i]=powmod(fact[i],MOD-2);     } } int main() {	     int t;     cin>>t;     while(t--) {         int n,k,x,y;         cin>>n>>k;         REP(i,0,n-1)             cin>>x>>y;         precal();         LL ans=0;         REP(i,0,min(n,k)) {             LL ans1=(fact[n-1]*ifact[i])%MOD;             ans1=(ans1*ifact[n-1-i])%MOD;             ans1=(ans1*fact[k])%MOD;             ans1=(ans1*ifact[i+1])%MOD;             ans1=(ans1*ifact[k-i-1])%MOD;             ans1=(ans1*fact[i+1])%MOD;             ans=(ans+ans1)%MOD;         }         cout<<ans<<endl;     }     return 0; } 
//   9:15 PM #include<iostream> #include<stdio.h> #include <vector> #include <algorithm> #include<math.h> #include<cstring> #include<cstdio> #define in(a) scanf("%d",&a) #define out(a) printf("%d",a) using namespace std;  int arr[100005];  int gcd(int a,int b) { 	if(a==1000000000 )  return b; 	if(b==1000000000)  return a; 	if(a==0)    return b; 	else		return gcd(b%a,a); }  int createsegtree1(int *stree1,int ss,int se,int idx) { 	if(ss==se) 	{ 		stree1[idx]=arr[ss]; 		return stree1[idx]; 	} 	 	int mid=(ss+se)/2; 	 	int x=createsegtree1(stree1,ss,mid,2*idx+1); 	int y=createsegtree1(stree1,mid+1,se,2*idx+2); 	 	stree1[idx]=max( x,y );  	return stree1[idx]; }  int rmaxq(int *stree1,int ss,int se,int q1,int q2,int idx) { 	if(ss>=q1 && se<=q2) 		return stree1[idx]; 	 	if(q1>se || q2<ss) 		return 0; 	 	int mid=(ss+se)/2; 	 	int x=rmaxq(stree1,ss,mid,q1,q2,2*idx+1); 	int y=rmaxq(stree1,mid+1,se,q1,q2,2*idx+2); 	 	return max(x, y) ; 			 	 }  int createsegtree2(int *stree2,int ss,int se,int idx) { 	if(ss==se) 	{ 		stree2[idx]=arr[ss]; 		return stree2[idx]; 	} 	 	int mid=(ss+se)/2; 	 	int x=createsegtree2(stree2,ss,mid,2*idx+1); 	int y=createsegtree2(stree2,mid+1,se,2*idx+2); 	 	stree2[idx]=gcd(x,y);  	return stree2[idx]; }  int rminq(int *stree2,int ss,int se,int q1,int q2,int idx) { 	if(ss>=q1 && se<=q2) 		return stree2[idx]; 	 	if(q1>se || q2<ss) 		return 1000000000; 	 	int mid=(ss+se)/2; 	 	int x=rminq(stree2,ss,mid,q1,q2,2*idx+1); 	int y=rminq(stree2,mid+1,se,q1,q2,2*idx+2); 	 	return gcd(x,y) ; 	 }   int main() { 	int n,q,a,b; 	in(n);   in(q); 	for(int i=0;i<n;i++)   in(arr[i]); 	int x = (int)(ceil(log2(n))); //Height of segment tree     int max_size = 2*(int)pow(2, x) - 1; //Maximum size of segment tree     int *stree1 = new int[max_size]; 	int *stree2 = new int[max_size]; 	memset(stree2,0,sizeof(stree2)); 	createsegtree1(stree1,0,n-1,0); 	createsegtree2(stree2,0,n-1,0); 	 	//for(int i=0;i<10;i++)     cout<<stree2[i]<<"  "; 	while(q--) 	{ 		in(a);   in(b); 		 		out(rmaxq(stree1,0,n-1,a-1,b-1,0));  printf(" "); 		out(rminq(stree2,0,n-1,a-1,b-1,0));  printf("\n"); 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {         long long int n,m,o,c=0;         cin>>n>>m>>o;         long long int a[n];         for(long long int i=0;i<n;i++)         {             cin>>a[i];         }         if(a[0]<o)             cout<<"-1\n";         else         {             for(long long int i=0;i<n;i++)             {                 if(a[i]>=o)                     c++;             }             cout<<min(m,c)<<endl;         }     } } 
#include<iostream> #include<cstdio> #include<cmath> #include<vector> #include<map> #include<set> #include<algorithm> #include<list> #include<cstring> #include<stack> #include<queue> using namespace std; #define ll long long #define vi vector<int> #define vii vector<vi > #define pp pair<int,int> #define pb push_back #define mp make_pair #define ppl pair<ll,ll> #define vl vector<ll> #define vll vector<vl > #define vb vector<bool> #define llu unsigned ll #define all(c) c.begin(),c.end() #define mod 1000000007 #define sc scanf #define pf printf const int maxn = 1e5 + 10;  int lg; int lca[maxn][20]; int ans[maxn], tmp[maxn], level[maxn], mark[maxn]; vi adj[maxn]; ll power(ll a,ll b) { 	if(!b) 		return 1; 	if(b==1) 		return a; 	ll temp=power(a,b/2); 	temp=(temp*temp); 	if(b&1) 		temp=(temp*a); 	return temp; }  void dfs(int v, int par, vb& visited) { 	visited[v] = true; 	lca[v][0] = par; 	level[v] = (par != -1) ? level[par]+1 : 1; 	vi::iterator it; 	for( it=adj[v].begin();it!=adj[v].end();it++ ) 	{ 		if( !visited[*it] ) 			dfs( *it, v, visited); 	} 	 } void construct_lca( int n) { 	vb visited(n+1); 	dfs( 1, -1, visited); 	lg = ceil(log2(n)); 	int i, j; 	for( i=1;i<=lg;i++ ) 	{ 		for( j=1;j<=n;j++ ) 		{ 			if( lca[j][i-1] != -1) 			{ 				lca[j][i] = lca[ lca[j][i-1] ] [i-1]; 			} 		} 	} }  int get_lca( int x, int y) { 	if( level[x] < level[y] ) 		swap( x, y); 	int i; 	for( i=lg;i>=0;i-- ) 	{ 		if( ( lca[x][i] != -1 ) && ( level[ lca[x][i] ] >= level[y] ) ) 			x = lca[x][i]; 	} 	if( x==y ) 		return x; 	for( i=lg;i>=0;i-- ) 	{ 		if( ( lca[x][i] != -1 ) && ( lca[x][i] != lca[y][i] ) ) 		{ 			x = lca[x][i]; 			y = lca[y][i]; 		} 	} 	return lca[x][0]; }  void dfs_final( int v, vb& visited) { 	visited[v] = true; 	vi::iterator it; 	int sum = mark[v]; 	for( it=adj[v].begin();it!=adj[v].end();it++ ) 	{ 		if ( !visited[*it] ) 		{ 			dfs_final( *it, visited); 			ans[v] += ans[*it]; 			ans[v] %= mod; 			sum += tmp[*it]; 			sum %= mod; 		} 	} 	tmp[v] = sum; 	ans[v] += tmp[v]; 	ans[v] %= mod; 	//ut << "v=" << v << " ans[v]="<<ans[v]<<"\n"; } int main() { 	ios_base::sync_with_stdio(false); 	memset( lca, -1, sizeof(lca) ); 	memset( tmp, 0, sizeof(tmp) ); 	memset( ans, 0, sizeof(ans) ); 	memset( mark, 0, sizeof(mark) ); 	int i, u, q, x, y, f, anc, val, n; 	cin >> n >> u >> q; 	for( i=0;i<n-1;i++ ) 	{ 		cin >> x >> y; 		adj[x].pb( y); 		adj[y].pb( x); 	} 	construct_lca( n); 	while( u--) 	{ 		cin >> x >> y >> val; 		anc = get_lca(x, y); 		//cout << anc <<"\n"; 		mark[x] += val; 		mark[y] += val; 		mark[anc] -= val; 		if( lca[anc][0] != -1) 		{ 				mark[ lca[anc][0] ] -= val; 				if( mark[ lca[anc][0] ] < 0 ) 					mark[ lca[anc][0] ] += mod; 				mark[ lca[anc][0] ] %=mod; 		} 		mark[x] %=mod; 		mark[y] %=mod; 		if( mark[ anc] < 0) 		{ 			mark[anc] += mod; 		} 		mark[anc] %=mod; 		 	} 	vb visited(n+1); 	dfs_final( 1, visited); 	while( q--) 	{ 		cin >> x; 		f = ans[x]; 		if( f<0 ) 			f += mod; 		f %= mod; 		cout << f <<"\n"; 	}     return 0; } 
#include <cstdio> #include <memory.h> #define MOD 1000000007 using namespace std; main() {     int n,t,q;     scanf("%d",&t);     while(t--)     { 	scanf("%d %d",&n,&q); 	int dp[n+1][n+1]; 	int arr[n+1]; 	for(int i=1;i<=n;i++) 	    scanf("%d",&arr[i]);   	memset(dp,0,sizeof(dp)); 	dp[1][1]=1; 	dp[0][0]=0; 	for(int i=1;i<=n;i++) 	    dp[i][1]=1; 	for(int i=1;i<=n;i++) 	{ 	    for(int j=1;j<i;j++) 	    { 		if(arr[i]>arr[j]) 		{ 		    for(int x=1;x<=i;x++) 		    { 			if(arr[j]<arr[i]) 			    dp[i][x] = (dp[i][x] + dp[j][x-1])%MOD; 			//printf("%d\n",dp[i][x]); 		    } 		} 	    } 	} 	 	for(int x=1;x<=n;x++) 	{ 	    int tmp = 0; 	    for(int i=1;i<=n;i++) 	    { 		tmp=(tmp+dp[i][x])%MOD; 	    } 	    arr[x]=tmp; 	} 	for(int i=0;i<q;i++) 	{ 	    int tmp; 	    scanf("%d",&tmp); 	    printf("%d\n",arr[tmp]); 	}     }     return 0; } 
#include<bits/stdc++.h> #define mod 1000000007 using namespace std; typedef long long ll; ll power(ll a,ll b) { 	ll ans=1; 	while(b) 	{ 		if(b&1) 		{ 			b-=1; 			ans*=a; 			if(ans>=mod) 			ans%=mod; 		} 		b/=2; 		a*=a; 		if(a>=mod) 		a%=mod; 		 		 	} 	return ans; } int main() { 	ll n; 	cin>>n; 	ll sum1=1; 	ll sum2=1; 	ll sum3=1; 	if(n==0)  	cout<<0<<endl; 	for(ll i=0;i<2*n;i++) 	{ 		if(i<n) 		{ 		 			sum2=sum2*(i+1); 			if(sum2>=mod) 			sum2%=mod; 		} 		sum1=sum1*(i+1); 		if(sum1>=mod) 		sum1%=mod; 		 	} 	sum2*=sum2; 	if(sum2>=mod) 	sum2%=mod; 	sum2*=(n+1); 	if(sum2>=mod) 	sum2%=mod; 	ll ans=sum1*power(sum2,mod-2); 	if(ans>=mod) 	ans%=mod; 	cout<<ans<<endl; 	 }
#include<stdio.h> int main() {     int n;     scanf("%d",&n);     int a[20][20];     int prime[]={2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741};     int p,i,j,b,k;     p=0;     i=0;     j=0;     k=n;     while (k>0){         b=k;         while (b>0){             a[i][j]=prime[p];             p=p+1;             b-=1;             j+=1;}         k-=1;         j-=1;         i+=1;         b=k;         while (b>0) {             a[i][j]=prime[p];             p=p+1;             b-=1;             i+=1; }         b=k;         i-=1;         j-=1;         while (b>0){             a[i][j]=prime[p];             p=p+1;             b-=1;             j-=1; }         k-=1;         b=k;         j+=1;         i-=1;         while (b>0){             a[i][j]=prime[p];             p=p+1;             b-=1;             i-=1; }         i+=1;         j+=1; }     for(i=0;i<n;i++){         for(j=0;j<n;j++)             printf("%d ",a[i][j]);         printf("\n");} return 0; } 
#include<stdio.h> int main() { long int in[10]={2,3,5,13,89,233,1597,28657,514229,433494437}; int n; scanf("%d",&n); printf("%ld\n",in[n-1]); return 0; }
#include<stdio.h> #include<math.h> int main() { int nt; long int n,b,i,sum,r; scanf("%d",&nt); while(nt--) { sum=0; scanf("%ld%ld",&n,&b); i=0; while(n) { r=n%10; sum=sum+(long)pow(b,i++)*r; n/=10; } printf("%c",sum); } return 0; }
#include<bits/stdc++.h> using namespace std;  const int N=123456; char s[N];  int main() {     int test;     scanf("%d", &test);     while(test--) {         scanf("%s", s);         int len=strlen(s);         int ans=0;         for(int i=1;i<len;i++) {             if(s[i]==s[i-1]) {                 ans++;             }         }         printf("%d\n", ans);     } } 
#include <stdio.h> #include <time.h>  int main() {     int i,f=0,n,skey,lkey,t=0;     long int a[1000],prod;      scanf("%d",&skey);     scanf("%d",&lkey);     prod=skey;     scanf("%d",&n);     if(n<=1000)     {         for(i=0;i<n;i++)             scanf("%ld",&a[i]);          if(skey==lkey)             printf("0");         else         {             for(i=0;i<n;i++)             {                 if(a[i]<=100000L && lkey % a[i]==0)                 {                     prod=(a[i]*prod)%100000L;                     t++;                      if(prod==lkey)                     {                         f=1;                         printf("%d",t);                         break;                     }                     else                         f=0;                 }             }         }      }     if(f==0)         printf("-1");  } 
#include<stdio.h> # define MAX 10000 unsigned long long triangle[MAX + 1][MAX + 1];  void makeTriangle()  {     int i, j;       triangle[0][0] = 1;      for(i = 1; i < MAX; i++) 	 {         triangle[i][0] = 1;         for(j = 1; j <= i; j++) 	    {             triangle[i][j] = (triangle[i - 1][j - 1] + triangle[i - 1][j]) %100000;         }     } }  unsigned long long C(int n, int r)  {     return triangle[n][r]; }  int main() {     makeTriangle();     int T;     scanf("%d", &T);     while(T--)     {         int N;         scanf("%d", &N);         int i;         unsigned long long int answer =0;         switch (N)         {         case 1:             printf("1\n");             break;         case 2:             printf("3\n");             break;         default:         {             int limit = N%2==0? (N /2) -1:(N/2);             int n_even =0;             if( N%2 ==0)             {                 n_even = C(N,N/2);             }             for(i=1;i<=limit;i++)             {                 answer +=(2*C(N,i));                 answer %= 100000;             }             printf("%lld\n", (answer+ 1+ n_even) % 100000);             break;         }         }     }     return 0; } 
#include <bits/stdc++.h>  using namespace std;  vector <int> v[26];  int main() { 	string S,P; 	int ans = 1; 	cin >> S >> P; 	 	for ( int i = 0; i < (int)P.size(); i++ ) v[P[i]-'A'].push_back(i); 	 	int idx = -1; 	for ( int i = 0; i < S.size(); i++ ) { 		int val = S[i] - 'A'; 		int sz = (int)v[val].size(); 		int new_idx = upper_bound(v[val].begin(), v[val].end(), idx) - v[val].begin(); 		 		if ( idx == -1 && new_idx == sz  ) { 			ans = -1; 			break; 		} 		else if ( new_idx == sz ) { 			i--; 			idx = -1, ans++; 		} 		else { 			idx = v[val][new_idx]; 	//		cout << "idx is " << idx << endl; 		} 	} 	 	cout << ans << endl; 	return 0; }
#include <cstdio> #include <queue> #include <cstring> #include <memory.h> #include <algorithm> using namespace std; #define M 101 char s[M][M],s1[M][M]; int a[M],st[M],en[M],mid[M],nxt[M],flag[M],vis[M]; queue<int> qq; int main() {     int cas,n,i,j,k,l,ss,tt,fg;     for(scanf("%d",&cas);cas--;) {         scanf("%d",&n);         memset(a,0,sizeof(a));         memset(st,0,sizeof(st));         memset(en,0,sizeof(en));         memset(mid,0,sizeof(mid));         memset(vis,0,sizeof(vis));         memset(nxt,-1,sizeof(nxt));         for(i=0;i<n;i++) {             scanf("%s",s[i]);             strcpy(s1[i],s[i]);             l=strlen(s[i]);             for(k=j=0;j<l;j++) if(!j || s[i][j-1]!=s[i][j]) s[i][k++]=s[i][j];             s[i][k]=0;             for(j=0;j<k;j++) vis[s[i][j]-'a']=1;         }         int no=0;         for(k=0;k<n;k++) {             l=strlen(s[k]);             if(l==1) a[s[k][0]-'a']=1;             else {                 st[s[k][0]-'a']++;                 en[s[k][l-1]-'a']++;                 nxt[s[k][0]-'a']=s[k][l-1]-'a';                 for(i=0;i<l;i++) {                     for(j=i+1;j<l;j++) if(s[k][i]==s[k][j]) break;                     if(j<l) break;                 }                 if(i<l) {no=1;break;}                 for(i=1;i<l-1;i++) mid[s[k][i]-'a']++;             }         }         for(i=0;i<26;i++) {             if(mid[i]) {                 if(mid[i]>1 || a[i] || st[i] || en[i]) {no=1;break;}             }             if(st[i]>1 || en[i]>1) {no=1;break;}         }         if(no) {puts("NOT POSSIBLE");continue;}         for(k=i=0;i<26;i++) if(vis[i]) k++;         if(k==1) {             for(i=0;i<n;i++) printf("%s",s1[i]);             puts("");             continue;         }         for(ss=tt=i=0;i<26;i++){             if(!st[i] && en[i]) tt++;             if(st[i] && !en[i]) ss++;         }         for(i=0;i<26;i++) {             if(!vis[i]) continue;             memset(flag,0,sizeof(flag));             flag[i]=1;             while(!qq.empty()) qq.pop();             qq.push(i);             while(!qq.empty()){                 k=qq.front();qq.pop();                 if(nxt[k]<0) continue;                 k=nxt[k];                 if(flag[k]) {no=1;break;}                 flag[k]=1;                 qq.push(k);             }             if(no) break;         }         if(no) {puts("NOT POSSIBLE");continue;}         if(ss==1 && tt==1) {             for(i=0;i<26;i++) if(a[i] && !st[i] && !en[i]) break;             if(i<26) {puts("MORE THAN ONE");continue;}             for(i=0;i<26;i++) if(st[i] && !en[i]) break;             k=i;             for(;;) {                 for(i=0;i<n;i++) {                     l=strlen(s[i]);                     if(s[i][0]==k+'a' && s[i][l-1]==k+'a') printf("%s",s1[i]);                 }                 for(i=0;i<n;i++) {                     l=strlen(s[i]);                     if(s[i][0]==k+'a' && s[i][l-1]!=k+'a') break;                 }                 if(i==n) break;                 printf("%s",s1[i]);                 k=s[i][strlen(s[i])-1]-'a';             }             puts("");         }         else puts("MORE THAN ONE");     } }
#include <iostream> #include<algorithm> #include<stdio.h> using namespace std;   int main() { 	int t,nop,nor,count=0,pie[100],weight[100],i,k,n; 	scanf("%d",&t); 	while(t--) 	{ 		count=0; 		scanf("%d",&n); 		for(i=0;i<n;i++) 		scanf("%d",&pie[i]); 		for(i=0;i<n;i++) 		scanf("%d",&weight[i]); 		sort(pie,pie+n); 		sort(weight,weight+n); 		for(i=0,k=0;(i<n && k<n);i++,k++) 		if(pie[i]<=weight[k]) 		{ 			count++; 		 		} 		else 		{ 		 		i--; 		} 		 		 		printf("%d\n",count); 	}     	return 0; } 
#include<cstdio> #include<vector> int main() { 	int t,n,i; double curr,best; 	scanf("%d",&t); 	while(t--) 	{ 	scanf("%d",&n); 	std::vector <int> salary; salary.resize(n+1); 	std::vector <double> prob; prob.resize(n+1); 	for(i=0;i<n;i++)scanf("%d",&salary[i]); 	for(i=0;i<n;i++)scanf("%lf",&prob[i]); 	best=0.0; 	for(i=n-1;i>=0;i--) 	{ 	    curr=salary[i]*prob[i]+(1-prob[i])*best; 	    if(curr>best)best=curr; 	} 	printf("%.6lf\n",best); 	} return 0; } 
#include <iostream> #include <cstdio> #include <vector> #include <set> #include <cstring> // #include <multiset>   using namespace std;   #define s(n) scanf("%d", &n)     char in[1000005]; typedef pair<int,int> PII;   int main() {   int T; s(T);   while(T--)   {          scanf("%s", in);     vector<PII> all;     int x = 0, y = 0;     all.push_back(PII(0,0));     int N = strlen(in);          for(int i = 0; i < N; i++)     {       char c = in[i];       int j = i;       while(i + 1 < N && in[j] == in[i+1]) 	i++;       int d = i - j + 1;             switch(c)       { 	case 'E' : x += d; break; 	case 'N' : y += d; break; 	case 'W' : x -= d; break; 	case 'S' : y -= d; break;       }       all.push_back(PII(x,y));     }          long long ans = 0;     for(int i = 0; i < all.size() - 1; i++)     {       int j = (i+1) % N;       int its = ( all[i].first * all[j].second - all[i].second * all[j].first);       ans += its;     }          ans = ans < 0 ? -ans : ans;	     printf("%lld\n", ans/2);   }    } 
#include <iostream> #include <stdio.h> #include <stdlib.h> #include <algorithm>   using namespace std;  typedef long long int LLI;  #define gc getchar_unlocked #define rep(i,n) for (LLI i=(0); i < (n); i++)  struct clas { 	int s,f; } cl[1000000];  inline void superFastRead(int *);    inline void superFastRead (int *a)  { 	char c = 0; 	while(c<33) 		c = fgetc_unlocked(stdin); 	//fread_unlocked(&c, sizeof(char), 1, stdin); 	*a = 0; 	while(c>33)  	{ 		*a = *a*10 + c - '0'; 		//fread_unlocked(&c, sizeof(char), 1, stdin); 		c = fgetc_unlocked(stdin); 	} }  bool operator<(const clas& c1,const clas& c2) { 	return c1.f<c2.f; }  void solve() { 	int c; 	superFastRead(&c); 	int total = 1; 	rep(i,c) 	{ 		superFastRead(&cl[i].s); 		superFastRead(&cl[i].f); 	} 	sort(cl,cl+c); 	int j = 0; 	for(int i=1;i<c;i++) 	{ 		if(cl[i].s>=cl[j].f) 		{ 			total++; 			j = i; 		} 	} 	printf("%d\n",total); }		 	 int main() { 	int T; 	superFastRead(&T); 	while(T>0) 	{ 		solve(); 		T--; 	} } 
                                                                                                           /*Code by fearless_coder*/ #include<bits/stdc++.h> #include<math.h> long long int a[1000000]; using namespace std; int main() { 	long long  int t,k,i,n,s; 	cin>>t; 	while(t--) 	{ 		s=0; 	    cin>>n>>k; 	    for(i=0;i<n;i++) 	   	cin>>a[i];     	sort(a,a+n);     	reverse(a,a+n);     	for(i=0;i<k;i++)     	s=s+a[i];     	cout<<s<<endl;     }     return 0; }
#include <iostream> #include <algorithm> #include <stdio.h> #include <cstring> using namespace std;  long long dp[1<<16][16]; int main() {     int t,n,k;     scanf("%d",&t);     while(t--)     {         scanf("%d %d",&n,&k);         memset(dp,0,sizeof(dp));         for(int i=0;i<n;++i)         {             dp[1<<i][i]=1;         }         int f=(1<<n)-1;         for(int i=1;i<=f;++i)         {             for(int j=0;j<n;++j)             {                 if(i&(1<<(j))){                     for(int x=0;x<n;++x)                     {                         if((i&(1<<x))==0 && abs(x-j)<=k){                             dp[i|(1<<x)][x]+=dp[i][j];                         }                     }                 }             }         }         long long ans=0;         for(int i=0;i<n;++i) ans+=dp[f][i];         printf("%lld\n",ans);     }     return 0; } 
#include<bits/stdc++.h>  using namespace std;  #define in(a,x,y) (a>=x && a<=y) #define out(a,x,y) (!in(a,x,y)) #define sz(a) ((int)a.size()) #define repv(i,a) for(int i=0;i<sz(a);i++) #define revv(i,a) for(int i=sz(a)-1;i>=0;i--) #define rep(i,a,b) for(int i=a;i<=b;i++) #define rev(i,a,b) for(int i=a;i>=b;i--) #define all(a) a.begin(),a.end() #define pb push_back  #define AND(a,b) ((a) & (b)) #define OR(a,b) ((a)|(b)) #define XOR(a,b) ((a) ^ (b)) #define xx first #define yy second #define mp make_pair #define sqr(x) ((x)*(x)) #define sqrt(x) sqrt(1.0*(x))  #define LB(a,x) (lower_bound(all(a),x)-a.begin()) //  first element in the range [first,last) which does not compare less than val. #define UB(a,x) (upper_bound(all(a),x)-a.begin()) //  first element in the range [first,last) which compares greater than val. #define forit(it, s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it++) #define left nokol_left #define right nokol_right #define countbit(x) __builtin_popcountll((ll)x) #define PQ priority_queue #define FAST ios_base::sync_with_stdio(0);cin.tie(0); #define Unique(store) store.resize(unique(store.begin(),store.end())-store.begin()) #define READ(f) freopen(f, "r", stdin) #define WRITE(f) freopen(f, "w", stdout)  typedef long long ll; typedef unsigned int uint; typedef unsigned long long ull; typedef pair<int,int> pii; typedef pair<long long,long long> pll; typedef vector<int> vi; typedef vector<long long> vll;  template<class T>T __sqr(const T x){return x*x;} template< class T, class X > inline T __pow(T a,X y) {T z=1; rep(i,1,y){z*=a;} return z; } template< class T > inline T gcd(T a,T b) {a=abs(a);b=abs(b); if(!b) return a; return __gcd(b,a%b);} template< class T > inline T lcm(T a,T b) {a=abs(a);b=abs(b); return (a/__gcd(a,b))*b;} inline bool ispow2(int x){return (x!=0 && (x&(x-1))==0);} template<class T>void UpdateMin(T &x,T y){  if(y<x){x=y;}} template<class T>void UpdateMax(T &x,T y){if(x<y){x=y;}} template<class T,class X, class Y > inline T bigmod(T n,X m,Y mod){ull ret=1, a = n%mod ; while(m){ if(m&1)ret=(ret*a)%mod; m>>=1; a=(a*a)%mod; }ret%=mod;return (T)ret;} template<class T, class Y > inline T modinv(T n,Y mod) {return bigmod(n,mod-2,mod);}  template<class T,class X> int getbit(T s,X i) { return (s >> i) & 1; } template<class T,class X> T onbit(T s, X i) { return s | (T(1) << i); } template<class T,class X> T offbit(T s, X i) { return s & (~(T(1) << i)); } template<class T> inline void read(T &n){char c;for (c = getchar(); !(c >= '0' && c <= '9'); c = getchar()); n = c - '0';for (c = getchar(); c >= '0' && c <= '9'; c = getchar()) n = n * 10 + c - '0';}  void extended_euclid(ll a,ll b,ll &x,ll &y){ if(!b){ x = 1 , y = 0  ;  return ;} ll xx,yy; extended_euclid(b,a%b,xx,yy); x = yy; y = xx - (a/b)*yy; } pair<ll, pair<ll, ll> > extendedEuclid(ll a, ll b) { ll x = 1, y = 0; ll xLast = 0, yLast = 1; ll q, r, m, n; while(a != 0) {q = b / a; r = b % a; m = xLast - q * x; n = yLast - q * y; xLast = x, yLast = y; x = m, y = n; b = a, a = r; } return make_pair(b, make_pair(xLast, yLast)); }  const ll mod[]  ={0,1000000007,1000000009,1000000021,1000000033,1000000097,1000000093,1000000097,1000000103}; const ll base[] ={0,1000003,1000033,1000037,1000039,1000081,1000099,1000117,1000121};  #define pi acos(-1.0) #define eps  1e-12 #define MX   (100000+20) #define inf  1000000000000000000LL #define MOD  1000000007LL //---------->0123456789123465789 #define lmt  10000  ll a[MX] , mob[MX]; ll sz = 0;  int vis[MX]; void mobius(){     mob[1] = 1;     int cnt = 0;     rep(i,1,lmt){         for(int j=i+i;j<=lmt;j+=i){             mob[j] -= mob[i];         }     } }  bool take[MX]; vector<int>prime , G[MX] , nb[MX];  void sieve(){     prime.pb(2);     for(int i=3;i<=lmt+100;i+=2){         if(!vis[i]){ prime.pb(i);             for(int j=i*3;j<=lmt+100;j+=2*i){                 vis[j] = true;             }         }     } //    cout<<prime.size()<<endl; }  ll n; void calc(){     rep(i,1,n){         if( !take[ a[i] ] ){             ll sv = a[i];             take[ a[i] ] = 1;              ll lm = sqrt(a[i]);  //            cout<<"lm "<<lm<<endl;             for(int j = 0;prime[j]<=lm;j++){                 int cnt =  0;                 while(a[i]%prime[j]==0){                     a[i]/=prime[j];                     cnt = 1;                     lm = sqrt(a[i]);                 }                 if(cnt) nb[ sv ].pb(prime[j]);             }  //            cout<<a[i]<<" ore "<<endl;             if(a[i]!=1) nb[ sv ].pb( a[i] );             a[i] = sv;         }  //        if(a[i]==55) cout<<nb[ 55 ].size()<<" gu"<<endl;          ll s = nb[ a[i] ].size();         ll  hol = (1<<s)-1;         for(int j=0;j<=hol;j++){             ll mul = 1;             rep(k,0,s-1){                 if(j&(1<<k)){                     mul *= nb[ a[i] ][ k ];                 }             }             G[ mul ].pb(i);         }     } }  struct DT{     ll prev , cnt, mx,id;     DT(){}     DT(ll prev,ll cnt,ll mx,ll id):prev(prev),cnt(cnt),mx(mx),id(id){} }stk[MX] ;  ll node[4*MX]; void build(int id,int s,int e){      if(s==e){         node[id] = a[s];         return ;     }     int m = (s + e) / 2;     int lf = 2 * id , rg = lf + 1;      build(lf,s,m);     build(rg,m+1,e);      node[id] = max(node[lf],node[rg]); }  ll query(int id,int s,int e,int st,int ed){      if(st > ed) return 0;     if(s==st && e==ed) return node[id];      int m = (s + e) / 2;     int lf = 2 * id , rg = lf + 1;      ll ret = 0 ;     if(ed<=m) ret = query(lf , s , m , st , ed);     else if(st > m) ret = query(rg , m+1 , e , st , ed);     else{         ll r1 = query(lf , s, m , st ,m);         ll r2 = query(rg , m+1,e ,m+1,ed);         ret = max(r1 , r2);     }     return ret; }  int main() {     sieve();     mobius();      scanf("%lld",&n);     rep(i,1,n) scanf("%lld",a+i); // //    ll brute = 0; //    rep(i,1,n){ //        ll mx = a[i]; //        rep(j,i+1,n){ //            mx = max(mx , a[j]); //            if(__gcd(a[i],a[j])==1){ //                brute+=mx; //            } //        } //    } // ////    cout<<__gcd(a[1],a[2])<<endl; //    cout<<brute<<endl;       build(1,1,n);     calc();     ll ans = 0;     rep(i,1,lmt){         if(mob[i]){             ll tot = 0;             sz =0;  //        if(G[i].size()) {cout<<i<<" == "<<G[i].size()<<endl; }              int lst;             repv(j,G[i])             {                 ll val = a[ G[i][j] ];                 ll nv = query(1,1,n,lst+1,G[i][j]-1);                 lst = G[i][j];                  if(sz){                     swap(nv , val);                     ll cnt = 0;                     while(sz){                         DT top = stk[sz-1];                         if(top.mx<=val){                             sz--;                             tot += cnt*top.cnt*top.mx;                             cnt += top.cnt;                         }                         else break;                     }                      if(cnt){                         DT ob = DT(inf, cnt, val,j);                         stk[sz++] = (ob);                     }                     swap(nv , val);                 }                   // divisible value gular position //                if( val%i==0 ){                 DT ob;                 if(sz==0) {ob = DT(inf,1,val,j); stk[sz++] = ob;continue;}                 else       ob = DT(stk[sz-1].mx,1,val,j);                  ll cnt = 0;                 while(sz){                     DT top = stk[sz-1];                     if(top.mx <= val){                         sz--;                         tot += cnt*top.cnt*top.mx;                         cnt += top.cnt;                     }                     else break;                 }                  tot += cnt*val;                 ob.cnt += cnt;                 stk[sz++] = ob; //                }             }              if(sz){                 DT ob = stk[sz-1];sz--;                  while(sz){                     DT nw = stk[sz-1]; sz--;                     tot += nw.cnt*ob.cnt*nw.mx ;                     nw.cnt += ob.cnt;                     ob = nw;                 }             }             ans += mob[i] * tot; //            cout<<i<<" ==> "<<ans<<endl; //            if(i > 22) break;         }     }     printf("%lld\n",ans);      return 0; }  /* 5 1 2 1 2 1  5 2 1 2 1 2  6 2 2 3 3 6 6  6 3 3 2 6 2 6  5 4 2 2 2 7  4 2 2 3 2  3 1 4 2  5 1 4 2 3 6 */ 
#include<bits/stdc++.h> using namespace std; int main() {     int i,j,k,l,m,n,num[110],tmp[110],c,tc;     while(cin>>tc)     {         for(l=1; l<=tc; l++)         {             cin>>n;             c=0;             for(i=0; i<n; i++)             {                 cin>>num[i];                 tmp[i]=num[i];             }             sort(num,num+n);             for(i=0; i<n; i++)             {                 if(num[i]!=tmp[i])                 {                     for(j=i+1; j<n; j++)                     {                         if(tmp[j]==num[i])                         {                             swap(tmp[i],tmp[j]);                             c++;                             break;                         }                     }                 }             }             printf("Case %d: %d\n",l,c);         }     }      return 0; } 
/* */   //#pragma comment(linker, "/STACK:16777216") #include <fstream> #include <iostream> #include <string> #include <complex> #include <math.h> #include <set> #include <vector> #include <map> #include <queue> #include <stdio.h> #include <stack> #include <algorithm> #include <list> #include <ctime> #include <memory.h> #include <ctime>   #define y0 sdkfaslhagaklsldk #define y1 aasdfasdfasdf #define yn askfhwqriuperikldjk #define j1 assdgsdgasghsf #define tm sdfjahlfasfh #define lr asgasgash  #define eps 1e-9 #define M_PI 3.141592653589793 #define bs 1000000000 #define bsize 512  using namespace std;  int n; string st; vector<int> v1,v2;  int main(){ //freopen("enigmatic.in","r",stdin); //freopen("enigmatic.out","w",stdout); //freopen("F:/in.txt","r",stdin); //freopen("F:/output.txt","w",stdout); ios_base::sync_with_stdio(0); //cin.tie(0)  cin>>n; cin>>st; for (int i=0;i<n;i++) 	v1.push_back(st[i]); for (int i=n;i<n*2;i++) 	v2.push_back(st[i]); sort(v1.begin(),v1.end()); sort(v2.begin(),v2.end()); int er1=0; int er2=0;  for (int i=0;i<v1.size();i++) 	{if (v1[i]<=v2[i]) 		er1=1; 	if (v1[i]>=v2[i]) 		er2=1;} 	 if (er1&&er2)cout<<"NO"<<endl; else cout<<"YES"<<endl;  //cin.get();cin.get(); return 0;} 
#include<stdio.h> #include<algorithm> #include<map> #include<vector>  using namespace std;   map < int, vector<int> > graph; vector <int> adj_list;  void bfs(int *isvisited, int *parent) { 	 	int i, j; 	vector <int> stack; 	int start = 1; 	int end = 100; 	stack.push_back(start); 	isvisited[start] = 1; 	while(stack.size()) { 		stack.erase(stack.begin()); 		for(i=0; i<graph[start].size(); i++) { 			if(isvisited[graph[start][i]] != 1) { 				stack.push_back(graph[start][i]); 				parent[graph[start][i]] = start; 				isvisited[graph[start][i]] = 1; 			} 		} 		start = stack[0]; 		if(start == end) 			break; 	} 	int count = 0; 	int p = 100; 	while(p != 1) { 		p = parent[p]; 		count++; 	}	 	printf("%d\n",count);  }  int main () {  	int t, snake, ladder, a[110], b[110], temp[110], sum; 	char string[200]; 	 	scanf("%d",&t); 	 	while(t--) { 		int isvisited[110] = {0}; 		int parent[110] = {0};   		for(int i=1; i<=100; i++)  			b[i] = i; 			 		for(int i=1; i<=100; i++)  			temp[i] = 1; 					 		snake = 0; 		ladder = 0; 					 		scanf(" %s",string); 		for(int i=0; string[i]; i++) { 			if(string[i] != ',') 					sum = sum*10 + string[i] - '0'; 			else { 				snake = sum; 				sum = 0; 			} 		} 		 		ladder = sum; 		sum =0; 		 		int k = 0; 		for(int j=0; j<snake; j++) { 			scanf(" %s",string); 			sum = 0; 			for(int i=0;string[i];i++) { 				if(string[i] != ',') 					sum = sum*10 + string[i] - '0'; 				else { 					a[k++] = sum; 					sum = 0; 				} 			} 			a[k++] = sum; 			sum = 0; 		} 		 		for(int i=0; i<2*snake; i=i+2) { 			b[a[i]] = a[i+1]; 			temp[a[i]] = -1; 		} 		 		 	    k = 0; 		for(int j=0; j<ladder; j++) { 			scanf(" %s",string); 			sum = 0; 			for(int i=0;string[i];i++) { 				if(string[i] != ',') 					sum = sum*10 + string[i] - '0'; 				else { 					sum = 0; 					a[k++] = sum; 				} 			} 			a[k++] = sum; 			sum = 0; 		} 		for(int i=0; i<2*ladder; i=i+2){ 			b[a[i]] = a[i+1]; 			temp[a[i]] = -1; 		} 	 		for(int i=1; i<100; i++) { 			if(temp[i] != -1) { 				for(int j=1; j<=6; j++) {	 					if(i+j <= 100)		 						graph[i].push_back(b[i+j]); 				} 			} 		} 		 		bfs(isvisited, parent); 		graph.erase(graph.begin(), graph.end()); 		 	} 	return 0; }  
#include <cstdio> #include <iostream> #include <cstring> #include <map> using namespace std; int primes[] = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499}; int lenprimes = sizeof(primes)/4;  string getString(int n) { 	string result = ""; 	for(int i=0;i<lenprimes;i++) 	{ 			int count = 0; 			while(n%primes[i] == 0) 			{ 				n /= primes[i]; 				count++; 			} 			if(count%2 == 0) 				result += '0'; 			else 				result += '1'; 	} 	return result; } string getXOR(string a, string b) { 	string result = ""; 	for(int i=0;i<lenprimes;i++) 		if(a[i] == b[i]) 			result += '0'; 		else 			result += '1'; 	return result; }  int solve(map<int,map<string,int> > dpmap,string* arr, int i, string aim) { 	if(dpmap[i].find(aim) != dpmap[i].end()) 		return dpmap[i][aim]; 	int ans; 	if(aim == arr[i]) 		ans = 1; 	else 		ans = 0;  	if(i == 0) 	{ 		return dpmap[i][aim] = ans; 	} 	return dpmap[i][aim] = ans + solve(dpmap,arr,i-1,aim) + solve(dpmap,arr,i-1,getXOR(aim,arr[i])); }  int iterativesolve(map<int,map<string,int> > dpmap,string* arr, int n, string aim) { 	for(int i=0;i<=n;i++) 	{ 		if(dpmap[i].find(arr[i]) != dpmap[i].end()) 				dpmap[i][arr[i]] += 1; 			else 				dpmap[i][arr[i]] = 1;  		if(i == 0) 			continue;  		for(map<string,int>::iterator it = dpmap[i-1].begin();it!=dpmap[i-1].end();it++) 		{ 			if(dpmap[i].find(it->first) != dpmap[i].end()) 				dpmap[i][it->first] += it->second; 			else 				dpmap[i][it->first] = it->second;  			if(dpmap[i].find(getXOR(it->first,arr[i])) != dpmap[i].end()) 				dpmap[i][getXOR(it->first,arr[i])] += it->second; 			else 				dpmap[i][getXOR(it->first,arr[i])] = it->second; 		} 	} 	return dpmap[n][aim]; }  int main() { 	string* arr; 	int t; 	scanf("%d",&t); 	 	string aim = ""; 	for(int i=0;i<lenprimes;i++) 		aim += '0';  	while(t--) 	{ 		int n; 		map<int,map<string,int> > dpmap; 		scanf("%d",&n); 		arr = new string[n]; 		for(int i=0;i<n;i++) 		{ 			int p; 			scanf("%d",&p); 			arr[i] = getString(p); 		}  		cout<<iterativesolve(dpmap,arr,n-1,aim)<<endl; 	} }
#include <iostream> #include <vector> #include <algorithm> #include <string> #include <cstdio> #include <cassert> #include <cmath>  #define boost ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0) #define max(a,b) ((a)>(b)?a:b)  using namespace std;   int main() { 	boost; 	int tc,R,B,r,b; 	cin >> tc; 	while(tc--){	 		cin >> R >> B >> r >> b; 		r = -r; 		vector<vector<double> > arr(R+1,vector<double>(B+1,0)); 		for(int i = 1 ; i <= R ; i++) 			arr[i][0] = 0; 		for(int i = 1 ; i <= B ; i++) 			arr[0][i] = i*b; 		for (int i = 1; i <= R; i++) { 			for (int j = 1; j <= B; j++) { 				double pr = (double)i /(double)(i+j); 				double pb = (double)j/(double)(i+j); 				arr[i][j] = max(0.0,pr*(r+arr[i-1][j])+pb*(b+arr[i][j-1])); 			} 		} 		printf("%.6f\n",arr[R][B]); 		} }
#include<bits/stdc++.h> using namespace std; int main() {     ios_base::sync_with_stdio(false);     int t,m,a[100][100],i,j,x,k,l,x1,r2; cin>>t; while(t--) {cin>>m;x=0;x1=0;r2=200;l=0; int c[100],r[100],c1[100],r1[100]; for(i=0;i<m;i++) { for(j=0;j<m;j++) { cin>>a[i][j]; if(a[i][j]==1) { c[x]=i; r[x]=j; x++;} if(a[i][j]==3) { c1[x1]=i; r1[x1]=j; x1++;}}} for(i=0;i<x;i++) { for(j=0;j<x1;j++) { k=abs(c[i]-c1[j])+abs(r[j]-r1[j]); if(k<r2) r2=k;} if(r2>l) l=r2;} cout<<l<<"\n";  } }
#include<iostream> #include<cstdio> typedef long long int ll; using namespace std; int main() {     ll t;     cin>>t;     double n,x,y,s;     while(t--)     {         cin>>n;         cin>>x>>y;         s=n+x*n/100+y*n/100;         printf("%.7lf\n",s);     }     return 0; }  
#include<iostream> #include<cmath> typedef long long int ll; using namespace std; int main() {     ll t,n;     cin>>t;     float l,h,m,b;     while(t--)     {        cin>>m>>b;        cin>>l>>h;        n=ceil((m*b+500)/(2*(l+h)));        cout<<n<<'\n';     }     return 0; }  
#include <iostream> #include<string> using namespace std; int main(){     int t;     cin >> t;     while(t--){             string s[22];             int s1[22];             for(int k=0;k<22;k++)                 s1[k]=0;             int n,i=0;             cin>>n;             while(i<n)             {                 cin>>s[i];                 i++;             }             i=1;             while(i<=n)             {                 int j;                 for(j=0;s[i-1][j]!='\0';j++)                 {                     if(s[i-1][j]=='a'||s[i-1][j]=='A')                         s1[i]=s1[i]+1;                     else if(s[i-1][j]=='e'||s[i-1][j]=='E')                         s1[i]=s1[i]+5;                      else if(s[i-1][j]=='i'||s[i-1][j]=='I')                         s1[i]=s1[i]+9;                      else if(s[i-1][j]=='o'||s[i-1][j]=='O')                         s1[i]=s1[i]+15;                      else if(s[i-1][j]=='u'||s[i-1][j]=='U')                         s1[i]=s1[i]+21;                  }                 i++;             }             i=1;             int t;             for(i=1;i<=n;i++)             {                 t=i;                 int j;                 for(j=1;j<=n;j++)                 {                     if(j<t&&s1[t]==s1[j])                         t=j;                     else if(s1[t]<s1[j])                          t=j;                 }                 cout<<s[t-1]<<endl;                 s1[t]=-999;                 //s2[k]=t-1;                 //k++;             }             //for(k=0;k<n;k++)               //  cout<<s[s2[k]]<<endl;      }    	return 0; } 
#include<iostream> using namespace std; int return_stars(int stars[100][100],int px,int py,int qx,int qy) { int sum=0; for(int i=px-1;i<qx;i++) { for(int j=py-1;j<qy;j++) sum=sum+stars[i][j]; } return sum; }  int main() { int a[100][100]; int m,n; cin>>m; cin>>n; for(int i=0;i<m;i++) for(int j=0;j<n;j++) cin>>a[i][j]; int t,px,py,qx,qy; cin>>t; while(t-->0) { cin>>px>>py>>qx>>qy; cout<<return_stars(a,px,py,qx,qy)<<"\n"; } return 0; }
#include <bits/stdc++.h> using namespace std; #define MAXSIZE 10000000 long long int segtree[10000000]; long long int A[MAXSIZE]; void build(int t,int i,int j){ 	if(i==j){ 		segtree[t] = A[i]; 		return; 	} 	int left = t<<1,right=left|1,mid=(i+j)>>1; 	build(left,i,mid); 	build(right,mid+1,j); 	segtree[t] = segtree[left] + segtree[right]; } void update(int t,int i,int j,int k,int x){ 	if(i==j){ 		if(i==k) 			segtree[t] = segtree[t] - x; 		return; 	} 	int left = t<<1,right=left|1,mid=(i+j)>>1; 	if(k<=mid) 		update(left,i,mid,k,x); 	else 		update(right,mid+1,j,k,x); 	segtree[t]= segtree[left] + segtree[right]; }  long long int query(int t,int i,int j,int ri,int rj){ 	if(j<ri || i>rj) 		return 0; 	if(ri<=i && rj>=j) 		return segtree[t]; 	int left = t<<1,right=left|1,mid=(i+j)>>1; 	return query(left,i,mid,ri,rj) + query(right,mid+1,j,ri,rj); }  int main() { 	int N,Q,L,R,l,t; 	scanf("%d",&t); 	while(t--)     { 	scanf("%d%d",&N,&Q); 	for(int i=1;i<=N;i++) 		scanf("%lld",&A[i]); 	build(1,1,N); 	while(Q--){ 			scanf("%d",&L);             if(L == 0)             {                 scanf("%d%d",&l,&R);                 printf("%lld\n",query(1,1,N,l,R));             } 			else             {                 scanf("%d%d",&l,&R);                 update(1,1,N,l,R);             } 	}     } 	return 0; } 
#include<iostream> #include<string.h> #include<cmath> #include<cstdio> using namespace std; long long int arr[1000005],arra[1000005]; int main() {     int t,i,j,val = 0,s = 1,q,n;     memset(arr,0,sizeof arr);     t = sqrt(1000005);     for(i = 2;i <= t;++i)     {         if(arr[i] == 0)         {             for(j = i*i;j <= 1000005;j = j+i)             {                 arr[j] = 1;             }         }     }     for(i = 4;i <= 1000005;i++)     {         if(arr[i] == 0 && arr[i-2] == 0)         {             val = val+s;             arra[i] = val;         }         else         {             arra[i] = val;         }      }     scanf("%d",&q);     while(q--)     {         scanf("%d",&n);         if(n == 1||n==2||n==3)             printf("0\n");         else             printf("%lld\n",arra[n]);     }     return 0; } 
#include<bits/stdc++.h> #define pb(x) push_back(x) #define all(x) x.begin(), x.end() #define cout2(x, y) cout << x << " " << y <<  endl #define N 24 * 60 * 60 + 5  using namespace std;  struct hour{ 	 	int h, m, s; 	hour(){} 	hour(int _h, int _m, int _s){ h = _h; m = _m; s = _s;} 	void next(){ 		 		if(s == 59){ 		 			s = 0; m++; 			if(m == 60)m = 0, h++; 			if(h == 24)h = 0; 		 		} 		else s++; 	} 	 	bool isPalin(){ 		 		string ans = "", rev; 		 		ans += char('0' + h/10); ans += char('0' + h%10); 		ans += char('0' + m/10); ans += char('0' + m%10); 		ans += char('0' + s/10); ans += char('0' + s%10); 		 		rev = ans; 		reverse(all(rev)); 		 		return rev == ans; 	} 	 	void read(){ scanf("%d:%d:%d", &h, &m, &s); } 	int getVal(){ return h * 60 * 60 + 60 * m + s; } 	 };  bool operator == (const hour &h1, const hour &h2){ 	 	return h1.h == h2.h && h1.m == h2.m && h1.s == h2.s;	 }  bool operator <(const hour &h1, const hour &h2){ 	 	if(h1.h != h2.h)return h1.h < h2.h; 	if(h1.m != h2.m)return h1.m < h2.m; 	return h1.s < h2.s; }  int ac[N];  int main(){  	int tc = 0; 	scanf("%d", &tc); 	 	hour s = hour(0, 0, 0); 	int j = 1; 	 	for(hour i = s; j <= 24 * 60 * 60; i.next(), j++) 		ac[j] = ac[j - 1] + i.isPalin();  	int total = ac[j - 1]; 	 	while(tc--){ 		 		hour h1, h2; 		 		h1.read(); 		h2.read(); 		 		int ans = 0, r, l; 		if(h1 < h2 || h1 == h2){ 			 			r = h2.getVal() + 1; 			l = h1.getVal() + 1; 			ans = ac[r] - ac[l - 1]; 			 		} 		else{ 			 			swap(h1, h2); 			r = h2.getVal(); 			l = h1.getVal() + 2; 			ans = total - (ac[r] - ac[l - 1]);	 		}  		printf("%d\n", ans); 		 	} }   
#include<iostream> #include<math.h> using namespace std; int main(){ int t,a;   cin>>t; for(int j=0; j<t; j++){ unsigned long long area, number; area = 0; number=0; cin>>a; for(int i = 1; i<=a; i++){ area+= pow(i,2)*pow(a-i+1,2); } number = (a*(a+1)*(2*a+1))/6; cout<<number%1000000<<" "<<area%1000000<<endl; } return 0; } 
#include<stdio.h> int  main() {     int i,j,a,k,p;    long long int m,n,sum;     scanf("%lld",&n);         for(i=0;i<n;i++)         {             a=1;         j=1,k=0,sum=0;             scanf("%lld",&m);             while(a>=1)             {                 a=m/(5*j);                  sum+=a;                 j=j*5;                k++;             }               printf("%lld\n",sum);         }       return 0; }  
#include<iostream> using namespace std; int main(){ 	int n,m; 	cin>>n>>m; 	int a, b; 	int x[101]={0}; 	for(int i=1; i<=m; i++){ 		cin>>a>>b; 		for(int i=a; i<=b; i++){ 			x[i]++; 		} 	} 	int k=0; 	for(int i=1; i<=n; i++){ 		if(x[i]!=1){ 			cout<<i<<" "<<x[i]; 			k=1; 			break; 		} 	} 	 if(k==0){ 	cout<<"OK"; } } 
#include<iostream> #include<math.h> #include<string.h> using namespace std;     int main(){ 	int b; 	int p=0,k=0; 	 	char x[20],y[20]; 	cin>>b>>x>>y; 	for(int i=0; i<strlen(x); i++){ 		p+=(x[strlen(x)-i-1]-'0')*(pow(b,i)); 	} 	 	for(int i=0; i<strlen(y); i++){ 		k+=(y[strlen(y)-i-1]-'0')*(pow(b,i)); 	} 	 	int l=p*k; 	 	if(l==0){  	cout<<0; 	} 	else{  	char z[10000];  	int i;  	long long  n=0;  	for(i=0;i<10000;i++){   	if(l==1){   	z[i] = l+ '0';   	break;   	}  	z[i] = l%b + '0';  	l/=b; 	 }  	for(i=1;i<=strlen(z);i++){  	n = n*10 + z[strlen(z)-i] - '0' ;  	}  	cout<<n; 	 } }
#include<iostream> #define N 405 using namespace std;   char A[N]; bool arr[N];   int main(){ 	int n,i,j,count=0,r; 	bool changes=true; 	cin>>n; 	cin>>A; 	for(i=0;i<n;i++){ 		if(A[i]=='L'){ 			for(j=i;j>=0;j--){ 				if(arr[j]==true)	break; 				arr[j]=true; 			} 		} 		else if(A[i]=='R'){ 			for(j=i;j<n;j++){ 				if(A[j]=='R')	r=j; 				if(A[j]=='L'){ 					count+=((j-r+1)%2); 					break; 				} 				arr[j]=true; 			} 		} 	} 	for(int i=0;i<n;i++){ 		if(arr[i]==false)	count++; 	} 	cout<<count<<endl; 	return 0; }  
#include<iostream> using namespace std; int main(){ 	int n,m; 	cin>>n>>m; 	int i=0; 	int j=0; 	int l=n; 	while(n>0){ 	i++; 	n--; 	if(i%m==0){ 		n=n+1; 	}   	j++; } cout<<j; }  
#include<bits/stdc++.h> using namespace std; int main() {     int t,n;     scanf("%d",&t);     while(t--)     {         scanf("%d",&n);         if(n%2==0)             cout<<"JACK\n";         else             cout<<"JENNY\n";     }     return 0; } 
#include<iostream> //#include<conio.h> using namespace std; int main() {     int n=1;     //cout<<"Enter the no. of test cases :";     cin>>n;int s[n];     for(int u=1;u<=n;u++)     {int w,o,p=0,count =0;float slope=0,x;     //cout<<"Enter the width (2 to 100):";     cin>>w;x=(w+1);     //cout<<"Enter th no. of obstacles (2 to 20):";     cin>>o;     //cout<<"Enter the co-ordinates of the obstacles as Di,Li,Ri respectively :";     int maxdi=0,posmaxdi=0;int di[o];int li[o];int ri[o];     for(int i=0;i<o;i++)     {             cin>>di[i]>>li[i]>>ri[i];             if(maxdi<=di[i]){maxdi=di[i];posmaxdi=i;}     }     int xd1,xd2;     xd1=li[posmaxdi];xd2=ri[posmaxdi];     for (int i=0;i<=w;i++)     {//cout<<"start("<<i<<",0) ";         for(int j=xd1;j<=xd2;j++)         {               if(j==i){x=i;}//cout<<"infinity case";}         else         {slope=(float)(maxdi)/(j-i);}         //cout<<" target ("<<j<<","<<maxdi<<") slope "<<slope;          for(int k=0;k<o;k++)          {             if(k!=posmaxdi)             {                 if(x!=i)                 {x=(float)di[k]/slope+i;}//cout<<"  "<<x;}                   //cout<<"\n x that comes out "<<x;                 if(x>=li[k]&&x<=ri[k])                 count++;             }             }slope=0;         //cout<<"count"<<count<<"\n";         if(count == (o-1))         {s[u]=1;p=1;break;}         count=0;         }if(count==(o-1))break;     }     if(p==0)     s[u]=0;     }     for(int u=1;u<=n;u++)     {             if(s[u]==1)cout<<"YES\n";             else             cout<<"NO\n";     }     //getch();     return 0; }       
//{ #include<iostream> #include<cmath> #include<algorithm> #include<climits> #include<vector> #include<bitset> #include<cstdlib> #include<cstdio> #include<cstring> #include<ctime> #include<map> using namespace std; #define MOD 1000000007LL #define LL long long #define ULL unsigned long long #define LD long double #define MAX(a,b) ((a)>(b)?(a):(b)) #define MIN(a,b) ((a)<(b)?(a):(b)) #define ABS(x)   ((x)<0?-(x):(x)) #define SQR(x) ((x)*(x)) #define CUBE(x) ((x)*(x)*(x)) #define si(n) scanf("%d",&n) #define si2(n,m) scanf("%d %d",&n,&m) #define sf(n) scanf("%f",&n) #define sl(n) scanf("%ld",&n) #define sll(n) scanf("%lld",&n) #define slu(n) scanf("%llu",&n) #define sd(n) scanf("%lf",&n) #define ss(n) scanf("%s",n) #define pnl printf("\n") #define REP(i,n) for(int i=0;i<(n);i++) #define FOR(i,a,b) for(int i=(a);i<(b);i++) #define FORR(i,n,e) for(int i=(n);i>=(e);i--) #define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d)) #define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d))  //#undef mydebug #ifdef mydebug #define DB(x) cout<<#x<<"="<<(x)<<"\n" #define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n" #define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n" #define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n" #define pnld pnl; #else #define DB(x) #define DB2(x,y) #define DB3(x,y,z) #define DB4(x,y,z,a) #define pnld #endif #define FILL(a,b) memset(a,b,sizeof(a)) const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; //template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;} void DBG_ARR(const int A[],int N){cout<<"[";REP(i,N){cout<<A[i]<<" ";}cout<<"]\n";} void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;} ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} //} void precompute(){} int pos[101]; void doThis(){     int Radius,N;     si2(Radius,N);     while(Radius!=-1&&N!=-1){         REP(i,N){             si(pos[i]);         }         sort(pos,pos+N);         int BombsReq=0;         FORD(i,0,N,0){             int j=i;             while((j+1<N)&&(pos[j+1]-pos[i]<=Radius)){                 j+=1;             }             i=j;             while((j+1<N)&&(pos[j+1]-pos[i]<=Radius)){                 j+=1;             }             BombsReq+=1;             i=j+1;          }         printf("%d\n",BombsReq);         si2(Radius,N);      } }  int main(){ #ifdef amy freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr); #endif precompute(); int t=1; //scanf("%d",&t); while(t--){doThis();} #ifdef amy fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC)); #endif return 0; } 
 #include <cstdlib> #include <iostream> #include <sstream> #include <math.h>  using namespace std; int testcase=0; string foo(int n,int d4,int d3,int d2) {    stringstream ss1,ss2,ss3;    int sum=0;    string str;      for(int d5=9;d5>=0;d5--)         {           for(int d1=9;d1>=0;d1--)             {               sum=(d5*10000)+(d4*1000)+(d3*100)+(d2*10)+d1;               if((sum%n)==0)                 {                   ss1<<d5;                   ss2<<d1;                   ss3<<sum/n;                   str=ss1.str()+" "+ss2.str()+" "+ss3.str();                   return str;                 }              }         }    return "0"; } int main(void) {     cin>>testcase;     int P[testcase][3];     int N[testcase];     for(int i=0;i<testcase;i++)     {       cin>>N[i];     for(int j=0;j<3;j++)     {        cin>>P[i][j];     }     }    for(int i=0;i<testcase;i++)    {    cout<<foo(N[i],P[i][0],P[i][1],P[i][2])<<endl;    }          return 0; }  
//Author : pakhandi //  using namespace std;  #include<iostream> #include<cstdio> #include<cstdlib> #include<algorithm> #include<cmath> #include<cstring>  #define wl while #define fl(i,a,b) for(i=a; i<b; i++)  int main() { 	int cases; 	long long int n,t; 	scanf("%d", &cases); 	while(cases--) 	{ 		scanf("%lld", &n); 		t=n; 		n=(2*n)/3; 		if(t%3!=0) 			n++; 		n=n%1000000007; 		printf("%lld\n", n); 	} 	return 0; } 
#include<iostream> #include<stdio.h> #include<stdlib.h> #include<string> #include<string.h> #include<vector> #include<map> #include<algorithm> #include<math.h> #include<limits.h>  using namespace std; #define lli long long int #define ulli unsigned long long int #define in(t) scanf("%d",&t) #define inl(t) scanf("%ld",&t) #define inll(t) scanf("%lld",&t) #define inlu(t) scanf("%llu",&t) #define MOD 1000000007 int pos[100001],dp[100001]; int main() {     int n,l,i;     char s[10];     in(n);     memset(dp,0,sizeof(dp));     memset(pos,-1,sizeof(pos));     for(i=0;i<n;i++)     {     cin>>s>>l;     if(s[0]=='f')     {     pos[l]=i;     if(i>0)     dp[i]=dp[i-1];     }          else     {     if(pos[l]==-1)     dp[i]=dp[i-1];     else     dp[i]=max(l+dp[pos[l]-1],dp[i-1]);     }     }     printf("%d\n",dp[n-1]);     return 0; } 
#include <bits/stdc++.h> using namespace std; #define FL(a) memset(a, 0, sizeof a); #define pi(a) cout <<  a << endl; #define si(n) scanf("%d",&n) #define pis(n) printf("%d ",n); #define FREP(b) for(int i=0;i<b;i++) #define REP(a,b,c) for(int a=b;a<c;a++) typedef pair<int,int> ii; typedef long long LL; /*    struct data{    };    bool operator < (const data &a1, const data &a2){    }  */ void Print(int num){     cout << bitset<5> (num) << endl; } int bintogray(int num){     return (num >> 1 ) ^ num; } int A[21][21]; LL MOD = 1000000007; LL mod(LL a){     return (a + MOD)%MOD; } LL rowsum[21]; int main() {     int N;     si(N);     FREP(N){         REP(j,0,N){             si(A[i][j]);         }     }     int prev = 0;     LL ans = 0;     for(int i = 1; i < (1 << N); i++){         int mask = bintogray(i);         int len = __builtin_popcount(mask);         len = len%2 ? -1 : 1;         for(int j = 0; j < N; j++){             if((mask & (1 << j)) != (prev & (1 << j))){                 LL temp = 1;                 int factor = (mask & (1 << j)) ? 1 : -1;                 for(int row = 0; row < N; row++){                     rowsum[row] = mod(rowsum[row] + factor*A[row][j]);                     temp = mod(temp*rowsum[row]);                 }                 ans = mod(ans + temp*len);                 break;             }         } prev = mask;     }     if(N%2) ans = -ans;     cout << mod(ans) << endl;     return 0; } 
#include<iostream>  using namespace std;  int main() { 	long long int a,b,r; 	cin >> a; 	 	while(a--){ 		cin >> b; 		r = 2 * b * b; 		cout << r << endl; 	} 	return 0; }
#include<cstdio> #include<algorithm> #include<string> #include<iostream> #include<vector> #include<cstring> #define X first #define Y second using namespace std; //source: geeks for geeks int found[1000010],pos; void computeLPSArray(char *pat, int M, int *lps); void KMPSearch(char *pat, char *txt) {     int M = strlen(pat);     int N = strlen(txt);     int *lps = (int *)malloc(sizeof(int)*M);     int j  = 0;     computeLPSArray(pat, M, lps);     int i = 0;       while(i < N)     {       if(pat[j] == txt[i])       {         j++;         i++;       }         if (j == M)       {         found[i-j+1]++;         j = lps[j-1];       }       else if(pat[j] != txt[i])       {         if(j != 0)          j = lps[j-1];         else          i = i+1;       }     }     free(lps); } void computeLPSArray(char *pat, int M, int *lps) {     int len = 0;     int i;     lps[0] = 0;     i = 1;     while(i < M)     {        if(pat[i] == pat[len])        {          len++;          lps[i] = len;          i++;        }        else        {          if( len != 0 )            len = lps[len-1];          else          {            lps[i] = 0;            i++;          }        }     } } int main() { 	char t[1000010],p[1000010]; 	scanf("%s",t); 	scanf("%s",p); 	int pl=strlen(p); 	int tl=strlen(t); 	KMPSearch(p,t); 	vector< pair<int,int> > v; 	for(int i=1;i<=tl;) 	{ 		int c=0; 		int spos=i; 		if(found[i]>0) 		{ 			int temp=i; 			while(temp<=tl && found[temp]>0) 			{ 				c++; 				found[temp]=-1; 				temp+=pl; 			} 			i=temp-pl+1; 			v.push_back(make_pair(spos,c)); 		} 		else 			i++; 	} 	sort(v.rbegin(),v.rend()); 	if(v.size()==0) 		printf("-1\n"); 	else 	{ 		for(int i=0;i<v.size();i++) 			printf("%d %d\n",v[i].X,v[i].Y); 	} 	return 0; }  
#include <cstdio> #include <vector> #include <algorithm> using namespace std;  const int MaxN = 1e6+1; const int MaxT = 5e7+1;  int N, a[MaxN], total, root[MaxN], pos[MaxN]; int link[MaxT][2], key[MaxT];  void Enter() {     scanf("%d", &N);     for (int i = 1; i <= N; i++)         scanf("%d", &a[i]); }  void UnZip() {     vector <int> zip;     for (int i = 1; i <= N; i++) zip.push_back(a[i]);     sort(zip.begin(), zip.end());     zip.resize(unique(zip.begin(), zip.end()) - zip.begin());     for (int i = 1; i <= N; i++)         a[i] = lower_bound(zip.begin(), zip.end(), a[i]) - zip.begin() + 1; }  int Add(int _key, int _L, int _R) {     total++;     key[total] = _key;     link[total][0] = _L;     link[total][1] = _R;     return total; }  int Modify(int prev, int L, int R, int pos, int val) {     if ( L == R ) return Add(key[prev]+val, 0, 0);     int mid = (L + R) >> 1;     if ( mid < pos )         return Add(key[prev]+val, link[prev][0], Modify(link[prev][1], mid+1, R, pos, val));     else         return Add(key[prev]+val, Modify(link[prev][0], L, mid, pos, val), link[prev][1]); }  int Request(int a, int L, int R, int _L, int _R) {     if ( _L <= L && R <= _R ) return key[a];     int mid = (L + R) >> 1;     if ( mid < _L ) return Request(link[a][1], mid+1, R, _L, _R);     if ( mid > _R - 1 ) return Request(link[a][0], L, mid, _L, _R);     return Request(link[a][0], L, mid, _L, _R) + Request(link[a][1], mid+1, R, _L, _R); }  void Build() {     for (int i = 1; i <= N; i++) {         if (pos[a[i]])             root[i] = Modify(Modify(root[i-1], 1, N, pos[a[i]], -1), 1, N, i, +1);         else             root[i] = Modify(root[i-1], 1, N, i, +1);         pos[a[i]] = i;     } }  void Solve() {     int Q, x, r, k = 0;     scanf("%d", &Q);     while (Q--) {         scanf("%d%d", &x, &r);         k = Request(root[r], 1, N, x+k, r);         printf("%d\n", k);     } }  int main() {     Enter();     UnZip();     Build();     Solve();     return 0; } 
#include <bits/stdc++.h> #define f(i,x,y) for (int i = x; i < y; i++) #define fd(i,x,y) for(int i = x; i>= y; i--) #define FOR(it,A) for(typeof A.begin() it = A.begin(); it!=A.end(); it++) #define all(v) (v).begin(), (v).end() #define rall(v) (v).rbegin(), (v).rend() #define vint vector<int> #define ll long long #define clr(A,x) memset(A, x, sizeof A) #define pb push_back #define pii pair<int,int> #define fst first #define snd second #define ones(x) __builtin_popcount(x) #define cua(x) (x)*(x) #define eps (1e-9) #define oo (1<<30) #define debug(x) cout <<#x << " = " << x << endl #define adebug(x,n) cout <<#x<<endl; f(i,0,n)cout<<x[i]<<char(i+1==n?10:32) #define mdebug(x,m,n) cout <<#x<<endl; f(i,0,m)f(j,0,n)cout<<x[i][j]<<char(j+1==n?10:32) #define N 105 #define ld double using namespace std;  ld C[50][50]; ld pa[50][50], pb[50][50]; ld g12[40+1][40+1]; ld sa[40+1][40+1], sb[40+1][40+1]; ld ta[41][41], tb[41][41]; ld suma1[41], suma2[41];  int main(){ 	f(i,0,50)f(j,0,i+1) { 		ld &res = C[i][j]; 		if (j == 0) { res = 1; continue; } 		res = C[i-1][j] + C[i-1][j-1]; 	}   	int n,k; double a,b; string s; 	int tc; 	cin >> tc; 	while (tc--) { 		cin >> n >> k >> a >> b >> s; 		ld div = 1/C[n][k]; 		a/= 100; 		b/= 100;  		int na = 0, nb = 0; 		f(i,0,n) if (s[i] == 'A') na++; else nb++; 		f(i,0,n+1)f(j,0,n+1) { 			pa[i][j] = 1; 			f(ii,0,i) pa[i][j] *= a; 			f(ii,0,j) pa[i][j] *= 1-a; 			pb[i][j] = div; 			f(ii,0,i) pb[i][j] *= b; 			f(ii,0,j) pb[i][j] *= 1-b; 		}  		ld g[na+1][nb+1]; 		ld num = 0, den = 0; 		g[0][0] = 0; 		int z1 = 0, z2 = 0; 		f(x1,0,na+1) f(x2,0,nb+1) { 			if (x1 == 0 && x2 == 0) continue; 			num = den = 1; 			f(i1,0,x1+1) f(j1,0,i1+1) ta[i1][j1] = C[i1][j1] * pa[j1][i1-j1] * C[x1][i1]; 			f(i2,0,x2+1) f(j2,0,i2+1) tb[i2][j2] = C[i2][j2] * pb[j2][i2-j2] * C[x2][i2]; 			//			f(i1,0,x1+1) f(i2,0,x2+1) { 			//				ld &res = g12[i1][i2]; 			//				res = 0; 			//				f(j1,0,i1+1) f(j2,0,i2+1) { 			//					if (j1 == 0 && j2 == 0) continue; 			//					res += g[x1-j1][x2-j2] * sa[i1][j1] * sb[i2][j2]; 			//				} 			//			}  			for (int k1 = 0, k2 = k; k1 <= k; k1++, k2--) { 				int c1 = min(x1,k1), c2 = min(x2,k2);  				clr(suma1, 0); 				clr(suma2, 0); 				for (int j1 = 0; j1 <= c1; j1++) for (int i1 = j1; i1 <= c1; i1++) suma1[j1] += C[na-x1][k1-i1] * ta[i1][j1]; 				for (int j2 = 0; j2 <= c2; j2++) for (int i2 = j2; i2 <= c2; i2++) suma2[j2] += C[nb-x2][k2-i2] * tb[i2][j2];  				for (int i1 = 0; i1 <= c1; i1++) for (int i2 = 0; i2 <= c2; i2++)  					den -= (C[na-x1][k1-i1] * ta[i1][0]) * (C[nb-x2][k2-i2] * tb[i2][0]); 				for (int j1 = 0; j1 <= c1; j1++) for (int j2 = 0; j2 <= c2; j2++) if (j1 || j2)  					num += (g[x1-j1][x2-j2] * suma1[j1]) * suma2[j2]; 			}  			//			f(k1,0,k+1) f(i1,0,k1+1) if(i1<=x1) f(i2,0,k-k1+1) if (i2 <= x2) { 			//				ld coef = C[x1][i1] * C[na-x1][k1-i1] * C[x2][i2] * C[nb-x2][k-k1-i2] / C[n][k]; 			//				//				if (x1 == na && x2 == nb) cout << "coef = " << coef <<  " " << k1 << " " << i1<<i2 << endl; 			//				num += g12[i1][i2] * coef; 			//				den -= pa[0][i1] * pb[0][i2] * coef; 			//				//				if (x1 == na && x2 == nb) cout << " " << num << " " << den << " " << g12[i1][i2] << " " << i1 << i2 << " " << pa[0][i1] << pb[0][i2]<<endl; 			//			} 			//			if (x1 == na && x2 == nb) cout << num << " " << den << endl; 			g[x1][x2] = num / den; 		}  		//		cout << z1 << " " << z2 << endl; 		//		f(x,1,n+1) { 		//			num = den = 1; 		//			f(i,0,k+1) if(i<=x){ 		//				ld coef = C[x][i] * C[n-x][k-i] / C[n][k]; 		//				f(j,0,i+1) { 		//					if (j == 0) den -= C[i][j] * pow(a, j) * pow(1-a, i-j) * coef; 		//					else num += g[x-j] * C[i][j] * pow(a, j) * pow(1-a, i-j) * coef; 		//				} 		//			} 		//			g[x] = num / den; 		//		}  		printf("%.10f\n", g[na][nb]); 	} 	return 0; }  
// Sharad Gupta  // IIIT - Hyderabad #include<iostream> #include<sstream> #include<cstdio> #include<climits> #include<cstdlib> #include<algorithm> #include<cmath> #include<cstring> #include<string> #include<deque> #include<bitset> #include<map> #include<set> #include<stack> #include<list> #include<vector> #include<queue>  using namespace std;  #define VI vector < int > #define VVI(A,N,M) vector< VI > A( N, VI (M) ) #define LL long long #define LLU unsigned long long #define SI ({int x;scanf("%d",&x);x;}) #define SC ({char x;scanf("%c",&x);x;}) #define PI acos(-1) #define mp make_pair #define pb push_back #define all(x) (x).begin(), (x).end() #define sz(x) ((int) (x).size()) #define SORT(c) sort(ALL(c)) #define FIT(it,v) for (typeof(v.begin()) it = v.begin(); it != v.end(); it++) #define FITD(it,v) for (typeof(v.rbegin()) it = v.rbegin(); it != v.rend(); it++) #define FOR(i,start,end) for(int i=start;i<end;i++) #define IATOV(a) ({vector<int> v(a,a+sizeof(a)/sizeof(int));v;}) #define CATOV(a) ({vector<char> v(a,a+sizeof(a)/sizeof(char));v;}) #define sieve(a) ({int b=ceil(sqrt(a));VI d(a,0);VI e;int f=2;e.pb(2);e.pb(3);for(int x=1;x<b+1;x++){for(int y=1;y<b+1;y++){int n=(4*x*x)+(y*y);if(n<=a&&(n%12==1||n%12==5)){d[n]^=1;}n=(3*x*x)+(y*y);if(n<=a&&n%12==7){d[n]^=1;}n=(3*x*x)-(y*y);if(x>y&&n<=a&&n%12==11){d[n]^=1;}}}for(int r=5;r<b+1;r++){if(d[r]){for(int i=r*r;i<a;i+=(r*r)){d[i]=0;}}}for(int c=5;c<a;c++){if(d[c]){e.pb(c);}}e;}) #define INF 1000000007 #define EPS 1e-9 #define mt(x, y, z) mp(mp(x,y),z) #define present(c,x) ((c).find(x) != (c).end()) #define cpresent(c,x) (find(all(c),x) != (c).end()) #define setbits(x) __builtin_popcount(x) //tell number of 1's in binary form #define GC getchar_unlocked template <class T> string str(T Number){  			string Result; // string which will contain the result  						ostringstream convert; // stream used for the conversion  										convert << Number; // insert the textual representation of 'Number' in the characters in the stream  															Result = convert.str(); 																					return Result; } int StringToNumber ( const string &Text ) { 			istringstream ss(Text); 						int result; 										return ss >> result ? result : 0; } template<class T> inline vector<pair<T,int> > FACTORISE(T n){vector<pair<T,int> >R;for (T i=2;n>1;){if (n%i==0){int C=0;for (;n%i==0;C++,n/=i);R.push_back(make_pair(i,C));}i++;if (i>n/i) i=n;}if (n>1) R.push_back(make_pair(n,1));return R;} template<class T> inline T TOTIENT(T n) {vector<pair<T,int> > R=FACTORISE(n);T r=n;for (int i=0;i<R.size();i++)r=r/R[i].first*(R[i].first-1);return r;} double rnd(float d) //for rounding values { 			return floor(d + 0.49); } template<class T>inline T input(T x){char c=GC();x=0;T s=1;while(c<48||c>57){if(c=='-')s=-1;c=GC();}while(c>=48&&c<=57){x=(x<<3)+(x<<1)+c-48;c=GC();}return x*s;} LL power(LL a, LL b,LL mod){LL ret=1;while(b>0){   if(b&1)ret = (ret*a)%mod;a=(a*a)%mod;b/=2;}   	return ret%mod;} map<int,int> c; int main() { 	int t=input(t); 	while(t--) 	{ 		c.clear(); 		int n=input(n); 		vector<int> a(n),d(n); 		int sum=0; 		FOR(i,0,n){a[i]=input(a[i]);sum+=a[i];} 		if(sum%2!=0) 			cout<<0<<endl; 		else 		{ 			LL ways=0; 			int s=0; 			sum/=2; 			FOR(i,0,n) { 				s += a[i]; 				ways += c[s]; 				c[s+sum]++; 			} 			cout<<ways<<endl; 		}   	} 	return 0; } 
#include <bits/stdc++.h> using namespace std;  int main() { 	int n; 	scanf("%d",&n); 	long long int x,y; 	int i; 	scanf("%lld%lld",&x,&y); 	x=y-x; 	long long int a[n]; 	bool b[x+1]; 	memset(b,0,sizeof(b)); 	for(i=0;i<n;i++) { 		scanf("%lld",&a[i]); 		a[i]-=1; 		if(a[i]<=x) 		b[a[i]]=true; 	} 	/*for(i=1;i<200;i++) { 		printf("%d ",i); 		if(b[i]) printf("1\n"); 		else printf("0\n"); 	}*/ 	for(i=1;i<=x;i++) { 		if(!b[i]) { 		for(int j=0;j<n;j++) { 			if(i-a[j]>0) { 				if(b[i-a[j]]) { 					b[i]=true; 					break; 				} 			} 		} 	} 	} 	/*for(i=1;i<200;i++) { 		printf("%d ",i); 		if(b[i]) printf("1\n"); 		else printf("0\n"); 	}*/ 	if(b[x]) printf("POSSIBLE\n"); 	else printf("IMPOSSIBLE\n"); }
#include<stdio.h>   int main() {int t,n,i; long long int a[101];   long long int m=5;    scanf("%d",&t) ;   a[0]=1;   a[1]=1;   a[2]=3;    while(t--)    {long long int m=5;     scanf("%d",&n);                                        for(i=3;i<=100;i++,m+=2)           {a[i]=(a[i-1]*m)%1000000007;           }                                     printf("%lld\n",a[n]) ;            }  }
# include <bits/stdc++.h>  using namespace std; int main() { int r,ans; scanf("%d",&r); // 2.127089 is constant calculated //by integrating over the circle circumference ans=(int)(r*2.127089); printf("%d\n",ans); return 0; }  
#include<iostream> #include<stdio.h> #include<string> #include<stdlib.h> #include<ctype.h> #include<cmath> #include<algorithm> #include<fstream> #include<vector> #include<map>  using namespace std;  typedef unsigned long long ll;  int nod(ll n) {     int c = 0;     while (n > 0)     {         n /= 10;         c++;     }     return c; }   int sod(ll n) {     int ans = 0;     while( n > 0 )     {         ans += n%10;         n /= 10;     }     return ans; }    int main() {     int t, d;     ll n, min;     cin>>t;     while(t--)     {         cin>>n;         min = n;         d = nod(n);         for(ll i = n - 1; i >= n - ( (9 * d) + (n / pow(10, d - 1)) ); i--)         {             if( (i + sod(i)) == n )                 min = i;         }         if(min == n)             cout<<"NONE";         else             cout<<min;         cout<<endl;     }     return 0; }  
#include<iostream> #include<cstdio>  using namespace std;  int main()  { 	int t; 	int n; 	int i, j, k, max; 	scanf ("%d",&t); 	while(t--) { 		scanf ("%d",&n); 		int a[n][n]; 		for ( i = 0; i < n; i++ ) { 			for ( j = 0; j < n; j++ ) { 				scanf ("%d",&a[i][j] ); 			} 		} 		for ( i = n-2; i >= 0; i-- ) { 			for ( j = 0; j < n; j++ ) { 				max = -32768; 				if ( j == 0 ) { 					if ( a[i+1][j] > a[i+1][j+1] ) 						max = a[i+1][j]; 					else 						max = a[i+1][j+1]; 					a[i][j] = a[i][j] + max; 				} 				else if ( j == n-1 ) { 					if ( a[i+1][j] > a[i+1][j-1] ) 						max = a[i+1][j]; 					else 						max = a[i+1][j-1]; 					a[i][j] = a[i][j] + max; 				} 				else { 					for ( k = j-1; k <= j+1; k++ ) { 						if ( a[i+1][k] > max ) 							max = a[i+1][k]; 					} 					a[i][j] = a[i][j] + max; 				} 			} 		} 		max = -32768; 		for ( i = 0; i < n; i++ ) { 			if ( a[0][i] > max ) 				max = a[0][i]; 		} 		printf ( "%d\n",max); 	} 	return 0; }  
#include <iostream> #include <string> #include <vector> #include <algorithm> #include <cmath>  using namespace std;  bool order(const int &a, const int &b) { 	int temp_a; 	int temp_b; 	int digits_a; 	int digits_b; 	int sum1; 	int sum2;  	digits_a = 0; 	temp_a = a;  	while (temp_a > 0) 	{ 		digits_a++; 		temp_a /= 10; 	}  	digits_b = 0; 	temp_b = b;  	while (temp_b > 0) 	{ 		digits_b++; 		temp_b /= 10; 	}  	sum1 = (int)(a * pow((double)10, digits_b)) + b; 	sum2 = (int)(b * pow((double)10, digits_a)) + a;  	return (sum1 < sum2); }  int main() { 	int t; 	int x; 	int n; 	string s; 	vector<int> v;  	scanf("%d", &t);  	for (int i = 0; i < t; i++) 	{ 		scanf("%d", &x);  		v.clear();  		for (int j = 0; j < x; j++) 		{ 			scanf("%d", &n);  			v.push_back(n); 		}  		sort(v.begin(), v.end(), order);  		for (int j = v.size() - 1; j >= 0; j--) 		{ 			printf("%d", v.at(j)); 		}  		printf("\n"); 	} } 
#include <iostream> #include <cstdio>  int main() {     long long i,m,n,a,maxi;     bool flag = 0;     scanf("%lld %lld",&m,&n);     if(n%2)         maxi = n/2 + 1;     else         maxi = n/2;     for(i=0;i<m;i++)     {         scanf("%lld",&a);         if(a>maxi)             flag = 1;     }     if(flag)         printf("NO\n");     else         printf("YES\n"); } 
#include<cstdio> #include<string> #include<list> #include<iostream> #include<map> using namespace std; char input[81]; char tempArray[17]; bool decrypt(list<string> lst[],char* ptr,map<char,char>& mp,map<char,char>& rev); void empty(){} int main() { 	int test; 	list<string> lst[15]; 	scanf("%d",&test); 	while(test--) 	{ 		for(int i=0;i<15;i++) 			lst[i].clear(); 		int wrdCnt; 		scanf("%d",&wrdCnt); 		string temp; 		cin.get(); 		while(wrdCnt--) 		{ 			getline(cin,temp); 			lst[temp.size()-1].push_front(temp); 		} 		scanf("%[A-Z \t]s",input); 		map<char,char>mp; 		map<char,char>rev; 		char* ptr = input; 		if(!decrypt(lst,ptr,mp,rev)) 		{ 			for(int i=0;input[i];i++) 			{ 				if(input[i]>='A' && input[i] <='Z') 					printf("*"); 				else 					printf("%c",input[i]); 			} 			printf("\n"); 		}  	} } bool decrypt(list<string> lst[],char* ptr,map<char,char>& mp,map<char,char>& rev) { 	if(*ptr){ 	while(*ptr == ' ' | *ptr =='\t') 		ptr++; 	string tempStr; 	tempStr.reserve(20); 	while(*ptr != ' ' && *ptr) 		tempStr+= *(ptr++); 	for(list<string>::iterator itr = lst[tempStr.size()-1].begin();itr != lst[tempStr.size()-1].end();itr++) 	{ 		map<char,char> tmpMap = mp; 		map<char,char> tmpRev = rev; 		for(int j=0;j<tempStr.size();j++) 		{			char tmp; 			if(tmp = tmpMap[tempStr[j]]) 			{ 				if(itr->at(j) != tmp) 					goto d; 			} 			else 			{ 				if(!tmpRev[itr->at(j)]){ 				tmpMap[tempStr[j]] = itr->at(j); 				tmpRev[itr->at(j)] = tempStr[j]; 				} 				else 				{ 					goto d; 				} 			} 		} 		if(decrypt(lst,ptr,tmpMap,tmpRev)) 			return true; 		d: 		continue; 	} 	} 	else 	{ 		for(int i =0;input[i];i++) 		{ 			char tmp; 			if(tmp = mp[input[i]]) 			{ 				printf("%c",tmp); 			} 			else 				printf("%c",input[i]); 		} 		printf("\n"); 		return true; 	} 	return false; } 
#include <cassert> #include <cstdio> #include <cstring> #include <algorithm> #include <iostream>   size_t N; char s[20][32]; size_t ss[20]; // best string size_t bs; char b[20*20+1];   #include <sys/time.h> class time_limit { public: 	time_limit(double dt_limit): _tv0(), _dt_limit(dt_limit) 	{ 		gettimeofday(&_tv0, 0); 	} 	bool operator() () 	{ 		timeval tv1; 		gettimeofday(&tv1, 0); 		double dt=tv1.tv_sec-_tv0.tv_sec+ 1e-6*(tv1.tv_usec-_tv0.tv_usec); 		return dt<_dt_limit; 	}  private: 	timeval _tv0; 	double _dt_limit; };   void rec(size_t n=0, size_t cs=0) { 	// current string 	static char c[20*20+1]; 	static bool used[20]={};  	if(n==0) 	{ 		for(size_t k=0; k<N; ++k) 		{ 			std::copy(s[k], s[k]+ss[k], c); 			used[k]=1; 			rec(1, ss[k]); 			used[k]=0; 		} 	} 	else if(n<N) 	{ 		for(size_t k=0; k<N; ++k) 			if(!used[k]) 			{ 				used[k]=1; 				// s[k] is a substring of c 				if(std::search(c, c+cs, s[k], s[k]+ss[k])!=c+cs) 					rec(n+1, cs); 				for(size_t j= cs<ss[k]?0:cs+1-ss[k]; j<cs; ++j) 					if(std::equal(c+j, c+cs, s[k])) 					{ 						std::copy(s[k]+cs-j, s[k]+ss[k], c+cs); 						rec(n+1, j+ss[k]); 					} 				used[k]=0; 			} 	} 	else 	{ 		if(bs==0 || cs<bs) 		{ 			std::copy(c, c+cs, b); 			bs=cs; 			b[bs]=0; 			//std::cout << bs << " " << b << std::endl; 		} 	} }   int main() { 	size_t T=1; 	//scanf("%zu", &T); 	//assert(1<=T && T<=20); 	/*char c; 	for(size_t i=0; i<2; ++i) 		scanf("%c", &c); 	scanf("%c", &c); 	time_limit go(0.3*(int(c)/10)); 	while(go()); 	std::cout << int(c) << std::endl; 	return 0;*/  	for(size_t t=0;; ++t) 	{ 		N=0; 		scanf("%zu", &N); 		if(N==0) 			break; 		assert(1<=N && N<=20); 		for(size_t n=0; n<N; ++n) 		{ 			scanf("%s", s[n]); 			ss[n]=strlen(s[n]); 			assert(2<=ss[n] && ss[n]<=20); 		} 		bs=0; 		rec(); 		b[bs]=0; 		printf("%s\n", b); 	} 	return 0; }   /*  3\nATGC  */  
#include <iostream> #include <cstdio> #include <map> #include <string>  using namespace std;  int main() {     map<string,int> participant;     int i,n,level=0;     string name;     scanf("%d",&n);     for(i=0;i<n;i++)     {         cin>>name;         if(participant.count(name))             participant[name]++;         else             participant[name] = 1;          if(participant[name]>level)         {             cout<<level+1<<" "<<name<<endl;             level++;         }         //cout<<participant[name]<<endl;     }     //cout<<participant.size()<<endl;     return 0; } 
#include <iostream> #include <math.h> typedef long long ll; int main(){  	long long find_log(long long, long long); 	long long func(ll, ll, ll, ll, long long, long long, long long, ll);  	ll T, E, A, B, C, D ; 	long long X,N,Y;  	std::cin >> T;  	for(long long i = 0; i < T; i++){ 		std::cin >> E >> A >> B >> C >> D >> X >> Y; 		N = find_log(X, Y); 		std::cout << func(A, B, C, D, X, Y, N, E) << std::endl;}  	return 0;}  ll func(ll a, ll b, ll c, ll d, long long x, long long y, long long n, ll e){ 	if(n==1) 		return e; 	 	n /= 2; 	long long f1 = (x-1)/n; 	long long f2 = (y-1)/n;  	if(f1&&f2) 		return d*func(a, b, c, d, x-n, y-n, n, e); 	else if(f1&&!f2) 		return c*func(a, b, c, d, x-n, y, n, e); 	else if(!f1&&!f2) 		return a*func(a, b, c, d, x, y, n, e); 	else  		return b*func(a, b, c, d, x, y-n, n, e);}  long long find_log(long long x, long long y){ 	long long max = x > y ? x : y; 	long long n = 1;  	while(n<max) 		n<<=1;  	return n;}  
#include <iostream> #include <cstdio> #include <cstring>  using namespace std;  #define sz(x) int(x.size()) #define LL long long  const int N = 109; int a[N][N], n, m; int u[N][N], d[N][N], l[N][N], r[N][N]; int main() { //    freopen("in.txt", "r", stdin);     while(~scanf("%d%d", &n, &m))     {         memset(a, 0, sizeof(a));         memset(u, 0, sizeof(a));         memset(d, 0, sizeof(a));         memset(l, 0, sizeof(a));         memset(r, 0, sizeof(a));         for(int i = 1; i <= n; ++ i)         for(int j = 1; j <= m; ++ j) scanf("%d", &a[i][j]);          for(int i = 1; i <= n; ++ i)         {             for(int j = 1; j <= m; ++ j)                 if(a[i][j] == a[i][j - 1]) l[i][j] = l[i][j - 1] + 1;                 else l[i][j] = 1;              for(int j = m; j >= 1; -- j)                 if(a[i][j] == a[i][j + 1]) r[i][j] = r[i][j + 1] + 1;                 else r[i][j] = 1;         }          for(int j = 1; j <= m; ++ j)         {             for(int i = 1; i <= n; ++ i)                 if(a[i][j] == a[i - 1][j]) u[i][j] = u[i - 1][j] + 1;                 else u[i][j] = 1;              for(int i = n; i >= 1; -- i)                 if(a[i][j] == a[i + 1][j]) d[i][j] = d[i + 1][j] + 1;                 else d[i][j] = 1;         }         int o = 0;         for(int i = 1; i <= n; ++ i)         {             for(int j = 1; j <= m; ++ j)             {                 for(int i1 = i; i1 <= n; ++ i1)                 {                     for(int j1 = j; j1 <= m; ++ j1)                     {                         int di = i1 - i + 1, dj = j1 - j + 1;                         if(r[i][j] >= dj &&                            d[i][j] >= di &&                             l[i1][j1] >= dj &&                            u[i1][j1] >= di                            )                            o = max(o, di * dj);                     }                 }             }         }         printf("%d\n", o);     }      return 0; }  
#include <iostream> #include <cstdio>  using namespace std;  int main() {     long long n;     float a,f,curr;     char str[1000010];     scanf("%lld",&n);     scanf("%s",str);     scanf("%f %f",&a,&f);     curr = a;     for(int i=1;i<n;i++)     {         if(str[i] == str[i-1])             curr += a;         else             curr = a;         if(curr>=f)         {             printf("NO\n");             return 0;         }     }     printf("YES\n");     return 0; } 
#include <bits/stdc++.h>  using namespace std;  int main() {     int t,n,a[1005],i,j,s,sum,c,k;     cin>>t;     while(t--)     {          sum=0;         cin>>n;         for(i=0;i<n;i++)             cin>>a[i];         for(i=0;i<n;i++)         {             c=0;             s=0;             if(a[i]>0)             {                 for(j=i+1;j<n;j++)                 {                     if(a[j]>=a[i])                     {                         s=a[i]*(j-i-1);                         s=s-c;                         sum=sum+s;                         c=0;                         for(k=i+1;k<j;k++)                             a[k]=a[i];                         i=j-1;                          break;                     }                     else                     {                         c=c+a[j];                     }                 }               }          }          for(i=n-1;i>=0;i--)         {             c=0;             s=0;             if(a[i]>0)             {                 for(j=i-1;j>=0;j--)                 {                     if(a[j]>=a[i])                     {                         s=a[i]*(i-j-1);                         s=s-c;                         sum=sum+s;                         c=0;                         i=j+1;                         break;                     }                     else                     {                         c=c+a[j];                     }                 }               }          }      cout<<sum<<endl;     }     return 0; } 
#include<iostream> #include<cstdio> #include<vector> #include<map> #include<set> #include<algorithm> #include<list> #include<cstring> using namespace std; #define ll long long #define vi vector<int> #define vii vector<vi > #define pp pair<int,int> #define pb push_back #define mp make_pair #define ppl pair<ll,ll> #define vl vector<ll> #define vll vector<vl > #define llu unsigned ll #define all(c) c.begin(),c.end() #define mod 1000000007 #define sc scanf #define pf printf ll power(ll a,ll b) { 	if(!b) 		return 1; 	if(b==1) 		return a; 	ll temp=power(a,b/2); 	temp=(temp*temp); 	if(b&1) 		temp=(temp*a); 	return temp; }  int main() {     int t,n,i,s,j,ans=0,val;     sc("%d",&t);     while(t--)     { 		ans=0; 		sc("%d",&n); 		vi v(n); 		for(i=0;i<n;i++) 			sc("%d",&(v[i])); 		sc("%d",&(s)); 		sort(all(v)); 		vi::iterator it; 		for(i=0;i<n-2;i++) 		{ 			for(j=i+1;j<n-1;j++) 			{ 				val=v[i]+v[j]; 				if(val>=s) 					break; 				it=lower_bound(v.begin()+j+1,v.end(),s-val); 				it--; 				ans+=(it)-(v.begin()+j); 			} 		} 		pf("%d\n",ans); 	}     //cin>>n;     return 0; } 
#include<iostream> #include<cstdio> using namespace std;  int main() { 	int n,i,j,k; 	long long int m,a[101],max=0,sum; 	scanf("%d",&n); 	scanf("%lld",&m); 	for(i=0;i<n;i++) 	{ 		scanf("%lld",&a[i]); 	} 	 	for(i=0;i<n-2;i++) 	{ 	  for(j=i+1;j<n-1;j++) 	  { 	    for(k=j+1;k<n;k++) 	    { 	       sum=a[i]+a[j]+a[k]; 	       if(sum<=m&&sum>max) 	       { 	        max=sum; 	       } 	    } 	  } 	} 	printf("%lld",max);     //system("pause");     	return 0; } 
#include<iostream> using namespace std; long long int d[7][10001]={0}; bool e[7][10001]={0}; long long int f(int b,int n)               {                   if(e[b][n])                   return d[b][n];                   if(n<=0)                   return 1;                   if(b==0)                   return 1;                   long long int s=1;                   s+=f(b-1,n);                   s+=f(b-1,n);                   s+=f(b-1,n-1);                   s+=f(b-1,n-2);                   s+=f(b-1,n-3);                   s+=f(b-1,n-4);                   s+=f(b-1,n-6);                   s+=f(b,n-1);                   s+=f(b,n-2);                   s+=f(b,n-3);                   s+=f(b,n-5);                   s+=f(b,n-1);                   s+=f(b,n-2);                   s+=f(b,n-5);                   s+=f(b,n-7);                   s%=10000007;                   e[b][n]=1;                   return d[b][n]=s;                   }  int main() {     int t,j=0;     cin>>t;     while(t--)     {               j++;               cout<<"Case "<<j<<": ";               int n;               cin>>n;               int i;               long long int s=0;               s+=f(6,n);               s%=10000007;               cout<<s<<endl;               }               return 0;               } 
#include<bits/stdc++.h> using namespace std; int main(){     int t;     cin>>t;     while(t--){                  int m=0;         for(int i=0; i<4; i++){             for(int j=0; j<4; j++){                 int t;                 cin>>t;                 if(t>0){                     m+=(t/2);                                     }             }         }m--; m--;         cout<<m<<endl;     } }
#include<stdio.h> #include<iostream> #include<math.h> using namespace std; int main() { long long n,x; cin>>n; double h,d,s,t1,t2,y; while(n--) {   cin>>h>>d>>s;   t1=sqrt((2*h)/32);   t2=d/s;   cin>>x;   while(x--)   {       cin>>y;       t2+=y;   }   if(t1>=t2)      cout<<"Y"<<endl;    else       cout<<"N"<<endl; } return 0; } 
#include<bits/stdc++.h> using namespace std; int main(){     int i,t,n,k,s,sum,niv;     cin>>t;     while(t--){         cin>>n>>k;         if(k==1)cout<<n<<endl;         else{             int can[k];             sum=k*(k+1)/2;             niv=0;             s=0;             while(s<n){                 s=s+sum;                 s=s+k*k*niv;                 niv++;             }             niv--;             s=s-sum-k*k*niv;             for(i=0;i<k;i++){                 can[i]=(i+1)*niv+niv*(niv-1)*k/2;                 if(s+k*niv+i+1<=n){                     can[i]+=k*niv+i+1;                     s+=k*niv+i+1;                 }                 else{                     can[i]+=n-s;                     s=n;                 }                 cout<<can[i]<<" ";             }             cout<<endl;         }     } } 
#include<cstdio> #include<algorithm> #include<vector> #include<cstring> #include<iostream> typedef long long ll; using namespace std; #define mod 10000000000283LL  //int getchar_unlocked()  {return getchar();} inline void f(int &x); /*inline void f(int &x) { 	register int c = getchar_unlocked(); 	x = 0; 	for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked()); 	for(; c>47 && c<58 ; c = getchar_unlocked()) { 		x = (x<<1) + (x<<3) + c - 48; 	} }*/  int prime[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163};  ll mulmod(ll a, ll b){     ll x = 0, y=a%mod;     while(b){ 		x = (x + (b%10)*y)%mod;		         y = (y*10)%mod;         b /= 10;     }     return x; }  ll modexponent(ll base, ll exponent) { 	ll result = 1;	 	while (exponent > 0) { 		if ((exponent & 1) == 1) 			result = mulmod(result, base); 		exponent = exponent >> 1; 		base = mulmod(base, base);		 	}	 	 	return result; }  ll phi(ll n){  	ll result=1;  	if(!(n%2)){  		n/=2;  		while(!(n%2)){  			n/=2;  			result*=2;  		}  	}  	for(ll k=3;k*k<=n;k+=2){  		if(!(n%k)){  			n/=k;  			result*=k-1;  			while(!(n%k)){  				n/=k;  				result*=k;  			}  		}  	}  	if(n>1)  		result*=n-1;    	return result;  }  int nc; int phi2(int n){ 	int res=nc=n; 	for(int i=0;prime[i]*prime[i]<=nc && n>1;i++){ 		if(n%prime[i]==0){res/=prime[i]; res*=(prime[i]-1);} 		while(n%prime[i]==0)n/=prime[i]; 	} 	if(n>1){ res*=n-1; res/=n;} 	return res; 	 }  int main(){ 	int t,i,j,k,n; 	f(t); 	while(t--){ 		f(n);f(k); 		ll sum , val1, val2; 		if (n == 1) 			sum = k; 		else { 			ll x, y; 			x=modexponent(n-1, mod - 2); 			if (x < 0) x += mod ; 			val1 = mulmod(phi(n), x); val2 = modexponent(n, k) - 1; 			sum = mulmod(val1, val2);			 		} 		printf("%lld\n", sum); 	} 	return 0; }   #define BUF 4096 char ibuf[BUF]; int ipt = BUF;  inline void f(int &n) { 	while (ipt < BUF && ibuf[ipt] < '0') ipt++; 	if (ipt == BUF) { 		fread(ibuf, 1, BUF, stdin); 		ipt = 0; 		while (ipt < BUF && ibuf[ipt] < '0') ipt++; 	} 	n = 0; 	while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0'); 	if (ipt == BUF) { 		fread(ibuf, 1, BUF, stdin); 		ipt = 0; 		while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0'); 	} } 
#include <iostream> #include <sstream> #include <cstdio> #include <cstdlib> #include <cmath> #include <memory> #include <cctype> #include <cstring> #include <vector> #include <list> #include <queue> #include <deque> #include <stack> #include <map> #include <set> #include <algorithm> #include <utility> using namespace std;  #define MAX 100001  vector<int>queen; vector<int>lose; int a[MAX]={0}; int ans[MAX]={0};  int main (){   a[1] = -1;   lose.push_back(0);   lose.push_back(1);   lose.push_back(9);   ans[0]=1;   ans[1]=1;   ans[9]=1;   int i,j;   for(i=2; i<MAX; i++){ 	if(a[i] == 0){ 	  queen.push_back(i); 	  for(j=2*i; j<MAX; j+=i){ 		a[j]++; 	  } 	} else { 	  if(a[i] == 2){ 		queen.push_back(i); 	  } 	}   }   for(i=10; i<MAX; i++){ 	bool win = false; 	for(j=0; j<lose.size(); j++){ 	  if(a[i-lose[j]] == 0 || a[i-lose[j]] == 2){ 		win = true; 		break; 	  } 	} 	if(!win){ 	  lose.push_back(i); 	  ans[i]=1; 	}   } /*  for(i=0; i<lose.size(); i++) 	printf("%d %d\n",i, lose[i]);*/   int t;   scanf("%d",&t);   while(t--){ 	char name[4]; 	int n; 	scanf("%s%d",name,&n); 	if(ans[n]){ 	  if(name[0] == 'S') 		printf("Pre\n"); 	  else 		printf("Sak\n"); 	} 	else { 	  if(name[0] == 'S') 		printf("Sak\n"); 	  else 		printf("Pre\n"); 	}   }   return 0; } 
#include <algorithm> #include <iostream> #include <cmath> #include <cstdlib> #include <cstring> #include <cstdio> #include <numeric>  #define FOR(A,B,C) for(int A=B;A<C;A++) #define EFOR(A,B,C) for(int A=B;A<=C;A++) #define RFOR(A,B,C) for(int A=B;A>=C;A--) #define MEM(A,B) memset(A,B,sizeof(A)) #define LL long long  using namespace std;  inline void Input(int &N) { 	int ch; 	N=0;  	while((ch<'0'||ch>'9') && ch!=EOF) 		ch=getchar();  	do 		N=(N<<3)+(N<<1)+(ch-'0'); 	while((ch=getchar())>='0' && ch<='9');  	return; }  #define L 1000400 #define UI unsigned int UI prime[L/64];  #define gP(n) (n==2 || ( (n&1) && ( prime[n>>6]&(1<<((n>>1)&31)) ))) #define rP(n) (prime[n>>6]&=~(1<<((n>>1)&31)))  void sieve() { 	MEM(prime,-1);  	UI i; 	UI sqrtN=(UI)sqrt((double)L)+1;  	for(i=3;i<sqrtN;i+=2) 		if(gP(i)){ 			UI i2=i+i; 			for(UI j=i*i;j<L;j+=i2)		rP(j); 		} }  const UI MOD=1000000007; const UI LIM=1000005;  int N,K,P; int prms[78500]; LL invr[78500];  inline LL binExp(LL bs,int exp) { 	LL ans=1; 	for(;exp!=0;exp/=2,bs*=bs,bs%=MOD) 		if(exp&1){ 			ans*=bs; 			ans%=MOD; 		}  	return ans; }  LL SumExcs(int ind) { 	LL N=prms[ind];  	LL sum=(N*(binExp(N,K)-1) +MOD )%MOD; 	sum*=invr[ind]; 	sum%=MOD;  	sum=(sum+MOD-K)%MOD; 	sum*=invr[ind]; 	sum%=MOD;  	return sum; }  int excsvt() { 	LL prd=1; 	for(int a=0;prms[a]<=N;a++){ 		prd*=SumExcs(a); 		prd%=MOD; 	} 	return int(prd); }  int main() { 	sieve();  	P=0; 	prms[P]=2; 	invr[P++]=1;  	for(int chk=3;chk<=LIM;chk+=2) 		if(gP(chk)){ 			prms[P]=chk; 			invr[P++]=binExp(chk-1,MOD-2); 		}  	int T; 	Input(T); 	while(T--){ 		Input(N),Input(K); 		printf("%d\n",excsvt()); 	}  	return 0; } 
/* Success is a matter of hanging on, when others have let go. Its not who you are, that holds you back, its who you think you are not. The future belongs to those, who believe in the beauty of their dreams. */ //{ /* theCodeGame */ #include<iostream> #include<cmath> #include<algorithm> #include<climits> #include<vector> #include<queue> #include<bitset> #include<cstdlib> #include<cstdio> #include<cstring> #include<ctime> #include<map> using namespace std; #define MOD 1000000007LL #define LL long long #define ULL unsigned long long #define LD long double #define MAX(a,b) ((a)>(b)?(a):(b)) #define MIN(a,b) ((a)<(b)?(a):(b)) #define ABS(x)   ((x)<0?-(x):(x)) #define SQR(x) ((x)*(x)) #define CUBE(x) ((x)*(x)*(x)) #define si(n) scanf("%d",&n) #define si2(n,m) scanf("%d %d",&n,&m) #define sf(n) scanf("%f",&n) #define sl(n) scanf("%ld",&n) #define sll(n) scanf("%lld",&n) #define slu(n) scanf("%llu",&n) #define sd(n) scanf("%lf",&n) #define ss(n) scanf("%s",n) #define pnl printf("\n") #define REP(i,n) for(int i=0;i<(n);i++) #define FOR(i,a,b) for(int i=(a);i<(b);i++) #define FORR(i,n,e) for(int i=(n);i>=(e);i--) #define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d)) #define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d)) //#undef mydebug #ifdef mydebug #define DB(x) cout<<#x<<"="<<(x)<<"\n" #define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n" #define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n" #define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n" #define pnld pnl; #else #define DB(x) #define DB2(x,y) #define DB3(x,y,z) #define DB4(x,y,z,a) #define pnld #endif #define FILL(a,b) memset(a,b,sizeof(a)) const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; //template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;} void DBG_ARR(const int A[],int S,int N){cout<<"[";FOR(i,S,N){cout<<A[i]<<" ";}cout<<"]\n";} void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;} ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} //} #define size 111 const int dx[]={-1,0,1,0}; const int dy[]={0,1,0,-1};//no diagonal movements int ANS[size][size];//for answer //for taking the map int M,N,Sx,Sy,Fx,Fy;  void precompute(){} void doThis(){     string map[size];     FILL(ANS,0);     si2(M,N);     si2(Sx,Sy);     si2(Fx,Fy);     REP(i,M){         cin>>map[i];//ss(map[i]);     }     queue<pair<int,int> >q;     q.push(make_pair(Sx,Sy));     ANS[Sx][Sy]=1;    // DB3("pushing..",Sx,Sy);     while(!q.empty()){         int x = q.front().first;         int y = q.front().second;        // DB3("poped..",x,y);         q.pop();         if(x==Fx&&y==Fy){             //DB4(x,Fx,y,Fy);             break;         }         //trying each move using dx,dy         FOR(i,0,4){             int tX=x;             int tY=y;            // DB3("for 1 to 4 direction loop",x,y);             while(1){                 //DB("while loop");                 tX=tX+dx[i];                 tY=tY+dy[i];                 //DB4(dx[i],dy[i],tX,tY);                 if(tX>=0&&tY>=0&&tX<M&&tY<N&&map[tX][tY]=='.'&&ANS[tX][tY]==0){                     ANS[tX][tY]=ANS[x][y]+1;                     //DB4(x,y,ANS[x][y],ANS[tX][tY]);                     //DB3("pushing..",tX,tY);                     q.push(make_pair(tX,tY));                 }else{                     //DB("break out of loop");                     break;                 }             }         }//end for dx dy     }    /* pnld;     REP(i,M){         REP(j,M){             cout<<ANS[i][j]<<" ";         }         pnld;     }     pnld;*/     if(ANS[Fx][Fy]){         printf("%d\n",ANS[Fx][Fy]-1);     }else{         puts("0");     } }  int main(){ #ifdef amy freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr); #endif precompute(); int t=1; scanf("%d",&t); while(t--){doThis();} #ifdef amy fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC)); #endif return 0; } 
#include <algorithm>  #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring>  #include <iostream> #include <iterator>  #include <map>  #include <numeric>  #include <queue>  #include <set> #include <sstream> #include <string>  #include <vector>  using namespace std;  #define ALL(c) (c).begin(), (c).end()  #define CLEAR(x) memset(x,0,sizeof x); #define CLEARA(x) memset(&x,0,sizeof x);  #define FILL(x,v) memset(x,v,sizeof x); #define FILLA(x,v) memset(&x,v,sizeof x); #define FOR(i,a,b) for (int _b=(b), i=(a); i <= _b; i++) #define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)  #define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it)   #define REP(i,n) for (int i=0,_n=(n); i < _n; i++) #define REPD(i,n) for (int i=(n)-1; i >= 0; i--) #define REVERSE(c) reverse(ALL(c))  #define SORT(c) sort(ALL(c))   #define VAR(a,b) __typeof(b) a=(b)   #define UNIQUE(c) SORT(c),(c).resize(unique(ALL(c))-(c).begin())  #define INF 0x7fffffff #define pb push_back #define X first #define Y second #define SZ(c) (int)(c).size() #define MP make_pair  #define MAX_BIT 20  typedef pair<int, int> PII; typedef vector<PII> VPII; typedef vector<int> VI; typedef vector<VI> VVI; typedef long long LL;  struct trie { 	int set; 	struct trie *one, *zero;  };  int main() { 	struct trie *temp,*node; 	int n,q,a,b,max_xor,pow2; 	temp = new trie; 	temp->set = 0; 	temp->zero = NULL; 	temp->one = NULL; 	scanf("%d",&n); 	REP(i,n) 	{ 		scanf("%d",&a); 		pow2 = 1<<MAX_BIT; 		node = temp; 		while(pow2!=1) 		{ 			pow2 = pow2>>1; 			if(pow2 & a) 			{ 				if(node->one==NULL) 				{ 					node->one = new trie; 					node = node->one; 					node->set = 1; 					node->zero = NULL; 					node->one = NULL; 				} 				else 				{ 					node = node->one; 				} 			} 			else 			{ 				if(node->zero==NULL) 				{ 					node->zero = new trie; 					node = node->zero; 					node->set = 0; 					node->zero = NULL; 					node->one = NULL; 				} 				else 				{ 					node = node->zero; 				} 			} 		} 	}		 	scanf("%d",&q);	 	REP(i,q) 	{ 		scanf("%d",&b); 		pow2 = 1<<MAX_BIT; 		max_xor = 0; 		node = temp; 		while(pow2!=1)			 		{ 			pow2 = pow2>>1; 			if(pow2 & b) 			{ 				if(node->zero!=NULL) 				{ 					max_xor+=pow2; 					node = node->zero;					 				} 				else 				{ 					node = node->one; 				} 			} 			else 			{ 				if(node->one!=NULL) 				{ 					max_xor+=pow2; 					node = node->one;					 				} 				else 				{ 					node = node->zero; 				}			 			} 		} 		printf("%d\n",max_xor); 	} 	return 0; } 
#include<iostream> #include<algorithm> #include<string.h> using namespace std; int main() {     int t,i,n,j;     long long int k;     scanf("%d",&t);     while(t--)     {               scanf("%ld",&n);               string ar[n];               string s1,s2;               for(i=0;i<n;i++)               cin>>ar[i];               for(i=0;i<n;i++)               {                               for(j=0;j<n-i-1;j++)                               {                                                    s1=ar[j]+ar[j+1];                                                    s2=ar[j+1]+ar[j];                                                    if(s1>s2)swap(ar[j],ar[j+1]);                               }               }               for(i=n-1;i>=0;i--)               cout<<ar[i];               printf("\n");     }     return 0; }                         
#include<iostream> #include<stdio.h> #include<string.h> #include<vector> #include<algorithm> #include<map> #include<math.h> #include<climits> using namespace std;  int t, n, m, k; long long c, arr[110][1100], temp; long long pre[110][1100], dp[110][1100], lsum[1100], rsum[1100];  long long fun(int row, int left) {     if(left==0)         return 0;     if(((row+1)*m)<left)         return INT_MAX;     if((row==0)&&(left<=m))         return pre[0][left];     if(dp[row][left]==-1)     {         int temp3;         temp3=min(m, left);         temp3=min(temp3, k);         long long temp4=INT_MAX;         for(int i=0; i<=temp3; i++)         {             long long temp5=pre[row][i]+fun(row-1, left-i);             temp4=min(temp4, temp5);         }         dp[row][left]=temp4;     }     return dp[row][left]; }  int main() { 	scanf("%d",&t);     while(t--)     {         c=0;         scanf("%d%d%d",&n,&m,&k);         for(int i=0; i<n; i++)         {             for(int j=0; j<m; j++)             {                 scanf("%lld",&arr[i][j]);             }         }         temp=(m<k)?m:k;         for(int i=0; i<n; i++)         {             lsum[0]=0;             rsum[0]=0;             for(int j=0; j<m; j++)                 lsum[j+1]=arr[i][j]+lsum[j];             for(int j=m-1; j>=0; j--)                 rsum[m-j]=arr[i][j]+rsum[m-j-1];             pre[i][0]=0;             for(int j=1; j<=temp; j++)             {                 long long mini=INT_MAX;                 for(int k=0; k<=j; k++)                 {                     long long temp2=lsum[k]+rsum[j-k];                     if(temp2<mini)                         mini=temp2;                 }                 pre[i][j]=mini;             }         } //        for(int i=0; i<n; i++) //        { //            for(int j=0; j<=m; j++) //                printf("%d  ",pre[i][j]); //            printf("\n"); //        }         int temp6=max(m,k);         for(int i=0; i<=n; i++)             for(int j=0; j<=temp6; j++)                 dp[i][j]=-1;         long long ans=fun(n-1, k); //        for(int i=0; i<n; i++) //        { //            for(int j=0; j<=m; j++) //                printf("%d  ",dp[i][j]); //            printf("\n"); //        }         printf("%lld\n", ans);     } 	return 0; } 
#include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<string> #include<iostream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<sstream> #include<bitset> #include<cstdio> #include<cmath> #include<climits> #include<ctime> #include<string> using namespace std; typedef long long LL; #define ss(n)       scanf("%s",n) #define forr(x, b, e)    for (int x = (b); x <= (e); x++) #define all(c)          (c).begin(), (c).end() #define mp      make_pair #define pb      push_back #define iii     pair<pair<int,int>,int> #define ii     pair<int,int> #define MOD 1000000007 #define ones5 11111 #define ones6 111111 #define ones7 1111111 #define ones8 11111111 #define sz size() #define bit(n) (1<<(n)) #define bit64(n) ((LL(1))<<(n)) #define X first #define Y second #define READ(x) freopen(x,"r",stdin); #define WRITE(x) freopen(x,"w",stdout); #define tr(container , it) for(typeof(container.begin()) it=container.begin() ; it!=container.end() ; it++) #define ii     pair<int,int> template<typename T> T gcd(T a, T b) { return (b == 0) ? abs(a) : gcd(b, a % b); } template<typename T> inline T lcm(T a, T b) { return a / gcd(a, b) * b; } template<typename T> inline T mod(T a, T b) { return (a % b + b) % b; } template<typename T> inline string tostring(const T& x) { ostringstream  os; os << x; return os.str(); } inline int toint(const string& s) { istringstream  is(s); int x; is >> x; return x; } inline double todouble(const string& s) { istringstream  is(s); double x; is >> x; return x; } inline string tobinary( int a) { string s; while( a != 0 ) { s = (char)(a%2+'0') + s; a>>=1; } return s; } int dx[] = {0, 1, 0, -1};int dx2[] = {0, 1, 0, -1,1,-1,1,-1}; int dy[] = {1, 0, -1, 0};int dy2[] = {1, 0, -1, 0,1,-1,-1,1}; long long modexp(int n, int p) {long long r = 1, b = n;while(p > 0) {if(p & 1) { r = r * b; if(r >= MOD) r %= MOD; }p >>= 1;b = b * b; if(b >= MOD) b %= MOD;}return r;} template<class T> inline void s( T &n ) {n=0;T ch=getchar();T sign=1;while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getchar();}while( ch >= '0' && ch <= '9' )n=(n<<3)+(n<<1)+ ch-'0', ch=getchar();n=n*sign;} /*Main Code Begins Now*/ #define MAXN ones7 #define EPS 3.0e-7 int N; int gauss ( vector < vector<int> > a,vector<int> & ans ) { 	int n=a.size(); 	int m=a[0].size()-1; 	vector < int > where ( m, - 1 ) ; 	for ( int col = 0 , row = 0 ; col < m && row < n ; ++ col ) { 		for ( int i = row ; i < n ; ++ i ) 			if ( a [ i ] [ col ] ) { 				swap ( a [ i ] , a [ row ] ) ; 				break ; 			} 		if ( ! a [ row ] [ col ] ) 			continue ; 		where [ col ] = row ;   		for ( int i = 0 ; i < n ; ++ i ) 			if ( i != row && a [ i ] [ col ] ) 			{ 				for(int j=0;j<=m;j++) 				a[i][j]^=a[row][j]; 			} 		++ row ; 	} 	ans. assign ( m, 0 ) ; 	for ( int i = 0 ; i < m ; ++ i ) 		if ( where [ i ] != - 1 ) 			ans [ i ] = a [ where [ i ] ] [ m ] ;  	for ( int i = 0 ; i < n ; ++ i ) { 		int sum = 0 ; 		for ( int j = 0 ; j < m ; ++ j ) 			sum ^= (ans [ j ]*a [ i ] [ j ]) ; 			//cout<<"i "<<i<<" "<<sum<<" "<<a[i][m]<<endl; 		if ( sum!=a[i][m] ) 			return 0 ; 	}   	for ( int i = 0 ; i < m ; ++ i ) 		if ( where [ i ] == - 1 ) 			return INT_MAX ; 	return 1 ; }  vector<int> v[4444]; map<ii,int> m; int Grid[40][40]; int main() { 	#ifndef ONLINE_JUDGE    // READ("input.txt");     //WRITE("output.txt");     #endif 	int a,b,n,M,K; 	int test; 	s(test); 	while(test--){ 	m.clear(); 	for(int i=0;i<4444;i++)v[i].clear();     s(N);s(M);s(K);     int c=0;     for(int i=0;i<K;i++)     {     	s(n);     	//int cmask=0;     	for(int j=0;j<n;j++)     	{     		s(a);s(b);     		///cmask|=(1<<(b*M)+a);     		if(m[ii(a,b)]==0)     		m[ii(a,b)]=++c;     		v[m[ii(a,b)]].push_back(i);     	}     	//cout<<"cmask "<<cmask<<endl;     	//v.push_back(cmask);     }     vector< vector<int>  > aa(c,vector<int>(K+1,0));     //int c=0;       for(int i=0;i<N;i++)     {     	for(int j=0;j<M;j++)     	{     		s(Grid[i][j]);     		     	}     	     }          for(int i=0;i<N;i++)     {     	for(int j=0;j<M;j++)     	{     		if(m[ii(i,j)])     		{     			for(int k=0;k<v[m[ii(i,j)]].size();k++)     			aa[m[ii(i,j)]-1][v[m[ii(i,j)]][k]]=1;     		}     	}     }     int f=1;     for(int i=0;i<N;i++)     {     	for(int j=0;j<M;j++)     	{     		if(Grid[i][j])     		{     			//cout<<m[ii(i,j)]<<endl;     			if(m[ii(i,j)]>=1)     		  aa[m[ii(i,j)]-1][K]=1; 			  else 			  f=0;	     		}     		     	}     }    /* for(int i=0;i<aa.size();i++)     {     	for(int j=0;j<aa[i].size();j++)     	cout<<aa[i][j]<<" ";     	cout<<endl;     }*/     vector<int> ans;     if(f)     f=gauss(aa,ans);     if(f)     printf("Yes\n");     else     printf("No\n"); }      }
#include<cstdio> #include<iostream> #include<cstring> #include<vector> #include<memory.h> #include<cstdlib> #include<cmath> #include<cassert> using namespace std;  int x, y, xb, yb, n, res;  int abs(int x) {     return x>0?x:-x; }  void solve() { res = 0; scanf("%d", &n); scanf("%d%d", &xb, &yb);  for(int i=0; i<n; i++) {     scanf("%d%d", &x, &y);     res+= abs(x-xb) + abs(y-yb); } printf("%d\n", 2*res);  }  int main() {     #ifndef ONLINE_JUDGE     freopen("input.txt","r",stdin);     freopen("output.txt","w",stdout);     #endif      int t;     scanf("%d", &t);     while(t--)     {         solve();     } } 
#include<cstdio> #include<iostream> #include<cstring> #include<vector> #include<memory.h> #include<cstdlib> #include<cmath> #include<cassert> #include<memory.h> #include<algorithm> using namespace std;  typedef long long ll; ll cnt = 0; const ll MOD = 1000000007;  const int MM = 50; const int SS = 99; const int KK = 101;  ll dp[SS][MM][MM][KK]; bool mark[SS][MM][MM][KK];   int dx0[4] = {1, 0, 1, 0}; int dx1[4] = {1, 0, 0, 1};  int N, M, K;  ll build(int steps, int x0, int x1, int k) {    // if(steps == 1 && x0== 0 && x1==0 && k==2)cout<<"hurra"<<endl;     cnt++;     int x3, x4;     ll sum = 0;      if(mark[steps][x0][x1][k] == 1)return dp[steps][x0][x1][k];      if(k>steps+1)return 0;      if(x0 == x1)     {             if(k<2)return 0;             for(int i=0; i<4; i++)             {             x3 = x0-dx0[i];             x4 = x1-dx1[i];             if(x3>=0 && x4>=0 && steps>0)             {                 sum+= build(steps-1, x3, x4, k-1);                 if(sum>=MOD)sum-=MOD;             }             }     }     else     {             if(k<1)return 0;             for(int i=0; i<4; i++)             {             x3 = x0-dx0[i];             x4 = x1-dx1[i];             if(x3>=0 && x4>=0 && steps>0)             {                 sum+= build(steps-1, x3, x4, k);                 if(sum>=MOD)sum-=MOD;             }             }     }     dp[steps][x0][x1][k] = sum;     mark[steps][x0][x1][k] = 1;     return sum;   }  void precompute() {     memset(mark, 0, sizeof(mark));     memset(dp, 0, sizeof(dp));      dp[0][0][0][1] = 1;     mark[0][0][0][1] = 1;      for(int i =0; i<MM; i++)     {         for(int j=0; j<MM; j++)         {             for(int steps = 0; steps<i+50; steps++)             {                 for(int k=0; k<=steps+1; k++)                 {                         build(steps,i,j,k);                       //cout<<i<<" "<<j<<" "<<steps<<" "<<k<<" "<<build(steps,i,j,k)<<endl;                 }              }          }     }   }    void solve() {  scanf("%d%d%d", &N, &M, &K); printf("%lld\n", dp[N+M-2][N-1][N-1][K]);  } void make() {     for(int i=0; i<1000; i++)     {         cout<<"50 50 "<<i%99<<endl;     } }  int main() {     #ifndef ONLINE_JUDGE     freopen("input.txt","r",stdin);     freopen("output.txt","w",stdout);     #endif     //make();     //return 0;     precompute();      int t;     scanf("%d", &t);     while(t--)     {         solve();     } } 
#include <stdio.h> #include <algorithm> using namespace std;   int main() { 	int n,x; 	scanf("%d", &n); 	 	while(n--) 	{ 	    scanf("%d", &x); 	    printf("%0.6f\n", max(x - 100, 0)/20.0 * 0.1); 	} 	return 0; }
#include<iostream> #include<stdio.h> #include<string>  #define lld long long int  using namespace std;   string swap_str(lld len,string str) {     lld x,y,i;     char temp;     if(len%2==1)     {         x=len/2;         y=len/2 + 1;         for(i=0; i<x; i++)         {             temp=str[i];             str[i]=str[y];             str[y]=temp;             y++;         }     }     else     {         x=y=len/2;         for(i=0; i<x; i++)         {             temp=str[i];             str[i]=str[y];             str[y]=temp;             y++;         }     }     return str;     //for(i=0; i<len; i++)     //    cout<<str[i]; }  int main() {     string str;     string chr;     lld num[10000];     lld t,ln,j,i,k;     char p;     cin>>t;     while(t--)     {         cin>>str;         ln=str.length();         str=swap_str(ln,str);         j=0;         k=0;         for(i=0; i<ln ;i++)         {             p=str[i]-96;             num[j]=p%10;             cout<<num[j];             j++;             chr[k]=static_cast<char>(p/10 +1 + 96);             cout<<chr[k];             k++;         }         printf("\n");         /*         res[j]='\0';         for(i=0; res[i]!='\0' ;i++)         {   cout<<res[i];         */     }     return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { 	int t,n,j=1; 	cin>>t; 	while(j<=t) 	{ 		cin>>n; 		int a[n],r=0,f=0,i; 		for(i=0;i<n;i++) 		{ 			cin>>a[i]; 			r+=((a[i]/30)+1)*10; 			f+=((a[i]/60)+1)*15; 		} 		if(f==r) 		{ 			cout<<"Case "<<j<<": Respawn Frag "<<f<<endl; 		} 		else if(f<r) 		{ 			cout<<"Case "<<j<<": Frag "<<f<<endl; 		} 		else{ 		 			cout<<"Case "<<j<<": Respawn "<<r<<endl; 		} 		j++; 	} } 
/*    Author : SKRCODE */  #define DEBUG  #include <vector> #include <list> #include <map> #include <set> #include <deque> #include <queue> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <fstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <cctype> #include <string> #include <cstring> #include <ctime> #include <string.h> #include <cassert> #include <climits>  using namespace std;  const int oo = 2000000009; const double eps = 1e-9; const double pi = 3.14159265358979323846264338327950; #define mod 1000000007  #define debug printf("ERROR DETECTED...!!\n"); #ifdef DEBUG     #define debug1(p)                cerr << #p << ": " << p << endl;     #define debug2(p, q)             cerr << #p << ": " << p << " | " << #q << ": " << q << endl;     #define debug3(p, q, r)          cerr << #p << ": " << p << " | " << #q << ": " << q << " | " << #r << ": " << r << endl;     #define debug4(p, q, r, s)       cerr << #p << ": " << p << " | " << #q << ": " << q << " | " << #r << ": " << r << " | " << #s << ": " << s << endl;     #define debug5(p, q, r, s, t)    cerr << #p << ": " << p << " | " << #q << ": " << q << " | " << #r << ": " << r << " | " << #s << ": " << s << " | " << #t << ": " << t << endl;     #define debug6(p, q, r, s, t, u) cerr << #p << ": " << p << " | " << #q << ": " << q << " | " << #r << ": " << r << " | " << #s << ": " << s << " | " << #t << ": " << t << " | " << #u << ": " << u << endl; #else     #define debug1(p)     #define debug2(p, q)     #define debug3(p, q, r)     #define debug4(p, q, r, s)     #define debug5(p, q, r, s, t)     #define debug6(p, q, r, s, t, u) #endif #define  takeinput() freopen("ip.txt","r",stdin); #define  takeoutput() freopen("op.txt","w",stdout); typedef vector < int > vi; typedef pair < int, int> ii; typedef vector < ii > vii; typedef set < int > si; typedef map < string, int > msi;   #define rep(i, a, b) for (int i = int(a); i <= int(b); i++) #define trvi(c, it) for (vi::iterator it = (c).begin(); it != (c).end(); it++) #define trvii(c, it) for (vii::iterator it = (c).begin(); it != (c).end(); it++) #define trmsi(c, it) for (msi::iterator it = (c).begin(); it != (c).end(); it++) #define pb push_back #define mp make_pair #define lsegtree(N) (int)(2 * pow(2.0, floor((log((double)N) / log(2.0)) + 1)))  typedef long long int64; typedef double float64;  //START  queue<int> q; int main(){     int n;     scanf("%d",&n);     while(n!=0){         for(int i=1;i<=n;i++)q.push(i);         for(int i=1;q.size()!=1;i++){             if(i%2==0){                 q.push(q.front());                 q.pop();             }             else q.pop();         }         printf("%d\n",q.front());         q.pop();         scanf("%d",&n);     }     return 0; } 
#include<iostream> #include<algorithm> #include<cmath> #include<cstdio> #include<string.h> #include<cstdlib> #include<vector> #include<queue>  using namespace std;  int a[1000010];  int main() {         int t,i,j,mi,ho,n,k,p;         float ans;          scanf("%d",&t);         while(t--)         {                 scanf("%d",&n);                 scanf("%d",&k);                 ans=n*1.0*pow(k,1/(float)n);                 //if(n!=1)                 printf("%f\n",ans);                 //if(n==1)                         //printf("%lf\n",k);         }         return 0; }    
#include <iostream> using namespace std;  int main() {     ios_base::sync_with_stdio(false);     int T;     cin>>T;     while(T--)     {         long long int N,num1,num2,num3,counter;         num1=1;         num2=2;         counter=2;         cin>>N;         if(N==1)         {             cout<<1<<"\n";             continue;         }         if(N==2)         {             cout<<2<<"\n";             continue;         }         else         {         while(counter<N)         {             num3=(num1+num2)%1000000007;             num1=num2;             num2=num3;             counter++;         }         cout<<num3<<"\n";         }     }    } 
#include<iostream> main(){ 	int t,i,j,k,l; 	float h,m,a,temp1,temp2; 	scanf("%d",&t); 	while(t--){ 		scanf("%f%f",&h,&m); 		if(h>=24 || m>=60)printf("Invalid Time\n"); 		else{ 		//if(m>30)m=60-m; 		h=h+m/60; 		if(h>=12 && m>=0){h=h-12;} 		 		 		temp1=h*30;//if(temp1>180)temp1=360-temp1; 		temp2=m*6;//if(temp2>180)temp2=360-temp2; 		temp1=temp1-temp2;if(temp1<0)temp1=-temp1;if(temp1>180)temp1=360-temp1; 		 		printf("%0.1f\n",temp1); 	} 	} 	return 0; } 
#include <cstdio> #include <iostream> #include <cstring> #include <algorithm>   #include <map>     using namespace std;   int main(){     map <long long,long long> m;     long long n,i,j,cnt;     cin >> n;     for(i=0; i<n; i++){         cin >> m[i];     }     for(i=0; i<n; i++){         for(j=0; j<n; j++){             if(m[i] == m[j] && i<j)                 return 0;         }     }       cnt = 0;     for(i=0; i<n; i++){             for(j=0; j<n-i-1; j++){                 if(m[j] > m[j+1]){                     int t = m[j];                     m[j] = m[j+1];                     m[j+1] = t;                     cnt++;                 }             }             }               cout << "Number of inversions are " << cnt << "\n";         return 0; }
/*just checking solution by commenting some lines*/  #include <cstdio> #include <vector>  using namespace std;  inline int readInt() { 	int res; 	scanf("%d", &res); 	return res; }  int dist(int x1, int y1, int x2, int y2) { 	return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2); }  int d[100]; vector <pair <int, int> > e[101]; int r[100][201];  void go(int v, int p, int l) { 	fill_n(r[v], l + 1, d[v]); 	for (int i = 0; i < e[v].size(); i++) { 		int nv = e[v][i].first; 		if (nv == p) 			continue; 		int ll = l - e[v][i].second; 		int d = e[v][i].second; 		if (ll < 0) 			continue; 		go(nv, v, ll); 		for (int j = l; j >= d; j--) { 			for (int k = 0; k <= j - d; k++) 				r[v][j] = max(r[v][j], r[v][k] + r[nv][j - d - k]); 		} 	} }  int main() { //	freopen("output.txt", "w", stdout); 	int t = readInt(); 	for (int tt = 1; tt <= t; tt++) { 		int n = readInt(); 		int l = readInt(); 		for (int i = 0; i < n; i++) { 			d[i] = readInt(); 			e[i].clear(); 		} 		for (int i = 0; i < n - 1; i++) { 			int a = readInt(); 			int b = readInt(); 			int c = readInt(); 			e[a].push_back(make_pair(b, c)); 			e[b].push_back(make_pair(a, c)); 		} 		go(0, -1, l / 2); 		int ans = r[0][l / 2]; 		printf("Case #%d: %d\n", tt, ans); 	} //	system("pause");     return 0; }  /* 6 25 5 8 3 3 10 7 0 1 4 3 0 3 2 3 2 5 2 3 4 5 4  4 2 5 -10 5 2 6 1 2 1 2 3 1 2 4 1  */ 
#include <stdio.h> #include <iostream> using namespace std;  void sum(int a, int b) {     //Puts a in array and multiply it b times with itself     int array[2001];     int m = 0;     array[0] = 1;     int aux = a;     int i = 0;     while(a > 0)     {         array[i] = a%10;         a /= 10;         m++;         i++;     }      for(int exp = 1; exp < b; exp++)     {          int temp = 0;         for(int k = 0; k < m; k++)         {             int x = array[k]*aux+temp;             array[k] = x%10;             temp = x/10;             //m++;         }          while(temp > 0)         {             array[m] = temp%10;             temp /= 10;             m++;         }           if(exp == b-1)         {for(int x = m-1; x >= 0; x--)         {             cout << array[x];         }         cout << endl;         int ans = 0;         for(int x = m-1; x >= 0; x--)         {             ans += array[x];         }         cout << ans << endl;}     } }  int main() {     int base, exp;     scanf("%d %d", &base, &exp);     sum(base,exp);     return 0; } 
#include <iostream> #include <vector> #include <queue> #include <string> #include <map> #include <cstdio> #include <cstring> #include <algorithm> #include <cmath>  #include <list>  #define REP(i,n)      FOR(i,0,n) #define FOR(i,a,b)    for(int i = a; i < b; i++) #define ROF(i,a,b)    for(int i=a;i>b;i--) using namespace std; struct sort_pred {     bool operator()(const std::pair<int,int> &left, const std::pair<int,int> &right) {         return left.second < right.second;     } };  int main(){   int count = 0;   while(1){   int c,e;   cin >> c >> e;      if(c == 0)     break;   else count++;   vector < list < pair <int, int> > > adj(c);   vector < pair<int,int> > costs(c);   map <int, bool> visited;      REP(i,e){     int s,d, cost;     cin >> s >> d >> cost;     pair <int, int> k;     k.first = d-1;     k.second = cost;     adj[s-1].push_front(k);     k.first = s-1;     k.second = cost;     adj[d-1].push_front(k);   }   int beg, end, total;   cin >> beg >> end >> total;   short r;       REP(i,c){     costs[i].second = 0;     costs[i].first = i;   }   costs[beg-1].second = total;   priority_queue <pair <int, int>, vector <pair <int, int> >, sort_pred> check;   REP(i,c)     check.push(costs[i]);       // algorithm begins here        while(!check.empty()){     pair<int,int> elem = check.top();     // cout << elem.first << " " << elem.second <<endl;     check.pop();     visited[elem.first] = true;     check = priority_queue <pair <int, int>, vector <pair <int, int> >, sort_pred>();      list <pair<int, int> > ::iterator iter;     for(iter = adj[elem.first].begin(); iter != adj[elem.first].end(); iter++){              int cost_path = (*iter).second;       int dest = (*iter).first;       if(visited[dest]) continue;       int est = min(cost_path, costs[elem.first].second);       costs[dest].second = max(costs[dest].second, est);       check.push(costs[dest]);     }   }      if(beg != end){   int trip = costs[end - 1].second;   //  cout << "Scenario #"<< count << endl;   //  cout << "Minimum Number of Trips = ";   if((total+1) % trip == 0)     cout << (total+1)/trip - 1 << endl;   else     cout << (total+1) / trip  <<endl;   }   else{     //cout << count << endl;     cout << 0 << endl;   }        }   return 0; }                               
#include<iostream> #include<stdio.h> #include<cmath> #include<math.h> using namespace std; int main(){        int n;       while(1){       scanf("%d",&n);       if(n==0)         break;       int k=1;       int one[10]={1,2,3,1,0,1,2,3,1,0};       int five[10]={0,0,0,1,1,1,1,1,0,0};       int x1[10]={1,1,1,1,1,1,1,1,2,2};       int x2[10]={2,2,2,2,2,2,2,2,3,3};       int x3[10]={3,3,3,3,3,3,3,3,4,4};       int x4[10]={1,1,1,1,1,1,1,1,2,0};       int count_1=0,count_5=0,count_10=0,count_50=0,count_100=0;          int j=0;       while(k<=n){            count_1+=one[j%10];             count_5+=five[j%10];              if(k>=9&&k<=10)                 count_10++;          else if(k>10&&k<=40){              if(k>10&&k<=20)              count_10+=x1[j%10];              else if(k>20&&k<=30)                count_10+=x2[j%10];              else if(k>30&&k<40)                count_10+=x3[j%10];              else{                 count_10++;                 count_50++;              }          }         else if(k>40&&k<=50){             count_10+=x4[j%10];              count_50++;         }        else if(k>50&&k<=60){           count_50++;           if(k>=59&&k<=60)             count_10++;        }        else if(k>60&&k<=90){              if(k>60&&k<=70){              count_10+=x1[j%10];              count_50++;              }              else if(k>70&&k<=80){                count_10+=x2[j%10];                count_50++;              }              else if(k>80&&k<90){                count_10+=x3[j%10];                count_50++;              }              else{                 count_10++;                 count_100++;              }        }       else if(k>90&&k<=100){             count_10+=x4[j%10];              count_100++;       }       else{}       k++;       j++;       }       cout<<count_1<<" "<<count_5<<" "<<count_10<<" "<<count_50<<" "<<count_100<<endl;          }  return 0;  } 
/**   * @link http://www.codechef.com/problems/CS07   * @author Axay   */  #include <stdio.h>  class sq{ 	int n; 	int x, y, xlimit, ylimit, xdir, ydir, xy; 	char tex[1001][1001];  public: 	void set(int dim){ 		n = dim; 	}  	int read(){ 		int i = 0; 		while((i <= n) && (scanf("%s", tex[i])) != -1){ 			++i; 		} 		return i - 1; 	}  	void spin(int deg){ 		switch (deg){ 			case 0:	//Normal 				x = 0; 				xlimit = n - 1; 				xdir = 1; 				y = 0; 				ylimit = n - 1; 				ydir = 1; 				xy = 1; 				break; 			case 1:	//Clockwise 				x = n - 1; 				xlimit = 0; 				xdir = -1; 				y = 0; 				ylimit = n - 1; 				ydir = 1; 				xy = 0; 				break; 			case 2:	//Counterclockwise 				x = 0; 				xlimit = n - 1; 				xdir = 1; 				y = n - 1; 				ylimit = 0; 				ydir = -1; 				xy = 0; 				break; 			case 3:	//180 				x = n - 1; 				xlimit = 0; 				xdir = -1; 				y = n - 1; 				ylimit = 0; 				ydir = -1; 				xy = 1; 				break; 		} 	}  	void flip(int dir){ 		switch (dir){ 			case 0:	//Normal 				x = 0; 				xlimit = n - 1; 				xdir = 1; 				y = 0; 				ylimit = n - 1; 				ydir = 1; 				xy = 1; 				break; 			case 1:	//Vertical 				x = n - 1; 				xlimit = 0; 				xdir = -1; 				y = 0; 				ylimit = n - 1; 				ydir = 1; 				xy = 1; 				break; 			case 2:	//Horizontal 				x = 0; 				xlimit = n - 1; 				xdir = 1; 				y = n - 1; 				ylimit = 0; 				ydir = -1; 				xy = 1; 				break; 			case 3:	//Both 				x = n - 1; 				xlimit = 0; 				xdir = -1; 				y = n - 1; 				ylimit = 0; 				ydir = -1; 				xy = 1; 				break; 		} 	}  	void inc(){ 		if(xy){ 			if(x != xlimit) 				x += xdir; 			else{ 				if(xlimit) 					x = 0; 				else 					x = n - 1; 				if(y != ylimit) 					y += ydir; 				else{ 					if(ylimit) 						y = 0; 					else 						y = n - 1; 				} 			} 		} 		else{ 			if(y != ylimit) 				y += ydir; 			else{ 				if(ylimit) 					y = 0; 				else 					y = n - 1; 				if(x != xlimit) 					x += xdir; 				else{ 					if(xlimit) 						x = 0; 					else 						x = n - 1; 				} 			} 		} 	}  	char data(){ 		return tex[y][x]; 	}  };  int main(int argc, char* argv[]){ 	int n, i, j, flip, spin, more, match, count; 	sq original, temp;  	scanf("%d", &n); 	original.set(n); 	temp.set(n);  	more = original.read(); 	count = 1;  	more = temp.read(); 	while(more != -1){ 		match = 0; 		for(flip = 0; flip < 4; ++flip){ 			for(spin = 0; (spin < 4) && !match; ++spin){ 				original.flip(flip); 				temp.spin(spin); 				match = 1; 				for(i = 0; i < n; ++i){ 					for(j = 0; (j < n) && match; ++j){ 						if(original.data() != temp.data()) 							match = 0; 						original.inc(); 						temp.inc(); 					} 				} 			} 		} 		++count; 		if(match) 			printf("Square %d is identical to square 1.\n", count); 		else 			printf("Square %d is distinct from square 1.\n", count); 		more = temp.read(); 	}  	return 0; } 
#include<iostream> #include<cstdio> #include<cstring> using namespace std;  int main() {     int base,num1,num2,cnt=0;     char s1[5],s2[5];      while(true)     {          if(scanf("%d",&base)!=1) 			break;  		scanf("%s",&s1);         cnt=0;          int l=strlen(s1);  		if(l==1) 		{if(s1[0]>='A'&& s1[0]<='Z') 			num1=s1[0]-'A'+10; 		else num1=s1[0]-'0';}  		else { 			num1=(s1[0]-'0')*10+(s1[1]-'0'); 		}  		scanf("%s",&s2); 		l=strlen(s2); 		if(l==1) 		{if(s2[0]>='A'&& s2[0]<='Z') 				num2=s2[0]-'A'+10; 		else num2=s2[0]-'0';} 			else { 				num2=(s2[0]-'0')*10+(s2[1]-'0'); 			}         //cout<<num1<<"\t"<<num2<<endl;        //Now i am atleast assured that my code works perfectly fine till here..pheww:::          int tmp=0,mod=0,q=0,save=num1,flag=0;         while(flag==0)         {             tmp=num1*num2+q;              num1= tmp%base;             q=tmp/base;              cnt++;              if(save==num1 && q==0)             flag=1;          }          printf("%d\n",cnt);      }      return 0; } 
#include<bits/stdc++.h> using namespace std;  #define sc( x ) scanf( "%d" , &x ) #define REP( i , n ) for( int i = 0 ; i < n ; ++i ) #define clr( t , val ) memset( t , val , sizeof( t ) )  #define pb push_back #define all( v ) v.begin() , v.end() #define SZ( v ) ((int)(v).size())  #define mp make_pair #define fi first #define se second  #define N 24 #define EPS (1e-70) #define test puts( "************************test*********************" );  typedef long double ld; typedef long long ll;  ld root2 = sqrt( 2.0 ); bool equals( const ld &x , const ld &y ){ return abs( x - y ) < EPS;} bool Less( const ld &x , const ld &y ){ return EPS < y - x;} ll maxi = 0; ll mini = LLONG_MAX; struct Complex{ 	ll re , im; 	Complex(){ re = im = 0;} 	Complex( ll re , ll im ) : re( re ) , im( im ) { (mini = min( mini , re ) );(maxi = max( maxi , re ) );/*cout <<(maxi = max( maxi , im ) )<< endl;*/ } 	Complex mult(){ return Complex( im << 1LL , re );} 	ld getVal(){ return (ld) re + (ld) im * root2; } 	void impr(){ cout << re << " + " << im << " i " << endl;} }; bool operator == ( const Complex &a , const Complex &b ){ return a.im == b.im && a.re == b.re;} bool operator < ( const Complex &a , const Complex &b ){ 	if( a.re == b.re ) return a.im < b.im; 	return a.re < b.re; } Complex operator - ( const Complex &a , const Complex &b ){ return Complex( a.re - b.re , a.im - b.im );} Complex operator + ( const Complex &a , const Complex &b ){ return Complex( a.re + b.re , a.im + b.im );} struct Point{ 	Complex x , y; 	Point(){} 	Point( Complex x , Complex y ) : x( x ) , y( y ) {} 	Point mult(){ return Point( x.mult() , y.mult() ); } }; Point operator - ( const Point &A , const Point &B ){ return Point( A.x - B.x , A.y - B.y );} Point operator + ( const Point &A , const Point &B ){ return Point( A.x + B.x , A.y + B.y );} bool operator == (const Point &A, const Point &B ){     return A.x == B.x && A.y == B.y; } bool operator < ( const Point &A , const Point &B ){     if( A.x == B.x ) return A.y < B.y ;     return A.x < B.x; }  int limit; Point pt; ld ans; Point dir[ 10 ]; ld x , y; inline ll hash( const pair< Point , int > &p ){ 	ll ans = 0LL; 	ans = ans * 231LL + p.fi.x.im + 110LL; 	ans = ans * 231LL + p.fi.y.im + 110LL; 	ans = ans * 461LL + p.fi.x.re + 210LL; 	ans = ans * 461LL + p.fi.y.re + 210LL; 	ans = ans * 25LL + p.se; 	return ans; } //map< ll , int > DIST; map< pair< Point , int > , int > DIST; void bfs(){ 	queue< pair< Point , int > >Q; 	//map< pair< Point , int > , int > DIST; 	//map< ll , int > DIST; 	Point P; 	int k = 0; 	Q.push( mp( P , k ) ); 	//DIST[ hash( mp( P , k ) ) ] = 0; 	DIST[ ( mp( P , k ) ) ] = 0; 	ans = min( ans , (ld)hypot( P.x.getVal() - x , P.y.getVal() - y ) ); 	while( !Q.empty() ){ 		pair< Point , int > U = Q.front() , V ; Q.pop(); 		P = U.fi; k = U.se; 		ans = min( ans , (ld)hypot( P.x.getVal() - x , P.y.getVal() - y ) ); 		if( DIST[ U ] == limit ) continue; 		//if( DIST[ hash( U ) ] == limit ) continue; 		 		/* 		Point nP = P ; 		int nk = ( k == 7 ? 0 : (k + 1) ); 		V = mp( nP , nk ); 		if( !DIST.count( hash( V ) ) && DIST[ hash( V ) ] < limit ){ 			Q.push( V ); 			DIST[ hash( V ) ] = DIST[ hash( U ) ] + 1; 		} 		nP = P + dir[ k ]; 		nk = k; 		V = mp( nP , nk ); 		if( !DIST.count( hash( V ) ) && DIST[ hash( V ) ] < limit ){ 			Q.push( V ); 			DIST[ hash( V ) ] = DIST[ hash( U ) ] + 1; 		} 		*/ 		 		Point nP = P ; 		int nk = ( k == 7 ? 0 : (k + 1) ); 		V = mp( nP , nk ); 		if( !DIST.count( V )  ){ 			Q.push( V ); 			DIST[ ( V ) ] = DIST[ ( U ) ] + 1; 		} 		nP = P + dir[ k ]; 		nk = k; 		V = mp( nP , nk ); 		if( !DIST.count( ( V ) )  ){ 			Q.push( V ); 			DIST[ ( V ) ] = DIST[ ( U ) ] + 1; 		} 		 	} 	//printf( "%d\n" , SZ( DIST ) ); } int main(){ 	dir[ 0 ] = Point( Complex( 10 , 0 ) , Complex( 0 , 0 ) ); 	dir[ 1 ] = Point( Complex( 0 , 5 ) , Complex( 0 , -5 ) ); 	for( int i = 2 ; i < 8 ; ++i ) dir[ i ] = dir[ i - 1 ].mult() - dir[ i - 2 ]; 	limit = 24; 	bfs(); 	vector< vector< Point > > vec( 25 ); 	for( map< pair< Point , int > , int > :: iterator it = DIST.begin() ; it != DIST.end() ; ++it ){ 		Point P = (it->fi).fi; 		vec[ it->se ].pb( P ); 	} 	for( int i = 1 ; i <= limit ; ++i ) 		REP( j , SZ( vec[ i - 1 ] ) ) vec[ i ].pb( vec[ i - 1 ][ j ] ); 	int cases , pos;  	cin >> cases; 	REP( tc , cases ){ 		cin >> pos >> x >> y; 		ans = 1e100; 		limit = pos; 		//bfs(); 		 		REP( i , SZ( vec[ pos ] ) ){ 			Point P = vec[ pos ][ i ]; 			ans = min( ans , (ld)hypot( P.x.getVal() - x , P.y.getVal() - y ) ); 		} 		 		printf( "%.6f\n" , (double) ans ); 	}  } 
/** author -- Ayush Sharma **/ #include<iostream> #include<cstdio> #include<cstring> #include<vector> #include<cstdlib> #include<cassert> #define FOR(i,a,b) for(int i=a;i<b;i++) #define FORR(i,a,b) for(int i=a;i>b;i--) #define min3(a,b,c) (a<b?(a<c?a:c):(b<c?b:c)) #define max3(a,b,c) (a>b?(a>c?a:c):(b>c?b:c)) #define min(a,b) (a<b?a:b) #define max(a,b) (a>b?a:b) #define MAX 8010 #define infi 100000 typedef long long LL; using namespace std; LL a[15][3],c,d,n; int main() {     int i=1,t;;c=9ll;d=1ll;     for(;i<15;i++)     {a[i][0]+=a[i-1][0]+c*(long long)i;c*=10ll;                   a[i][1]=d;d*=10ll;a[i][2]=d-1ll;                   }      while(scanf("%lld",&n)){   for(i=1;i<15;i++) {if(a[i][0]>n)break;}  if((n-a[i-1][0])%(long long )i==0)printf("%lld\n",a[i-1][2]+(n-a[i-1][0])/(long long)i);        else printf("Impossible!\n");                }      return 0;     } 
#include <cstdio> #include <iostream> #include <cstring> #include <string> #include <algorithm> #include <cmath> #define q 27  using namespace std;       int first[q]; int original[q]; int match[q]; string s;  void input()     {     	for(int i = 0 ; i < 26; ++i)     	{     		original[i] = s[i] - 'A';     		first[i] = 1;     		match[i] = 0;     	}     }       int check()     {     for(int i = 0 ; i < 26; ++i){ 	if( first[i] ){     		int count = 1;     		int j = original[i];     		first[i] = 0;     		while(j != i)     		{     			first[j] = 0;     			j = original[j];     			++count;     		}     		match[count]++;     	}     }     for(int i = 2; i < 27; i += 2)     {     	if( match[i]) {     		if( match[i]%2 ){     			return 0; 		}     	}     }     return 1; }       int main() {     int Test;     cin>>Test;     while(Test--)     {     	cin>>s;     	input();     	if( check() ){     		cout<<"Yes"<<endl; 	}     	else{     		cout<<"No"<<endl; 	}     }     return 0; } 
#include <bits/stdc++.h> using namespace std; typedef long long int ll; #define F(i,a,b) for(int i = (int)(a); i <= (int)(b); i++) #define RF(i,a,b) for(int i = (int)(a); i >= (int)(b); i--)  int main() {     #ifndef ONLINE_JUDGE         freopen("input.txt","r",stdin);         freopen("output.txt","w",stdout);     #endif     char S[105];     int T,N;     ll temp,ans;     scanf("%d",&T);     while(T--)     {         scanf("%s",S);         N = strlen(S);         ans = 0LL;         F(i,0,N-1)         {             if(S[i] >='0' && S[i] <= '9')             {                 temp = 0LL;                 while(S[i] >= '0' && S[i] <= '9')                 {                     temp = temp*10 + S[i] - '0';                     i++;                 }                 ans += temp;             }         }         printf("%lld\n",ans);     }     return 0; }  
#include <bits/stdc++.h> using namespace std; typedef long long int ll; #define F(i,a,b) for(int i = (int)(a); i <= (int)(b); i++) #define RF(i,a,b) for(int i = (int)(a); i >= (int)(b); i--) int main() {     #ifndef ONLINE_JUDGE         freopen("input.txt","r",stdin);         freopen("output.txt","w",stdout);     #endif     int T,N,C,A[26];     char S[205];     scanf("%d",&T);     getchar();     while(T--)     {         scanf("%[^\n]%*c", S);         //printf("%s\n",S);         N = strlen(S);         C = 0;         memset(A,0,sizeof(A));         F(i,0,N-1)         {             if(islower(S[i])) A[S[i]-'a']++;             else if(isupper(S[i])) A[S[i]-'A']++;         }         F(i,0,25) if(A[i]>0) C++;         if(C == 26) printf("TRUE\n");         else printf("FALSE\n");     }     return 0; }  
#include <bits/stdc++.h> using namespace std; typedef long long int ll; #define F(i,a,b) for(int i = (int)(a); i <= (int)(b); i++) #define RF(i,a,b) for(int i = (int)(a); i >= (int)(b); i--)  int main() {     #ifndef ONLINE_JUDGE         freopen("input.txt","r",stdin);         freopen("output.txt","w",stdout);     #endif     int T,C,N,A[26];     char S[105];     scanf("%d",&T);     while(T--)     {         memset(A,0,sizeof(A));         C = 0;         scanf("%s",S);         N = strlen(S);         F(i,0,N-1)         {             if(islower(S[i])) A[S[i]-'a']++;             else A[S[i]-'A']++;         }         F(i,0,25) if(A[i] > 1) C++;         printf("%d\n",C);     }     return 0; }  
#include<stdio.h> #include<string.h> #include<ctype.h> int main() {     int t,k,i,count;     char s[201];     scanf("%d",&t);     while(t--)     {         scanf("%s",s);         k=strlen(s);         count=k-4;         for(i=4;i<=k-5;i++)         {             //if(isupper(s[i])) s[i]=tolower(s[i]);             if(s[i]=='a'||s[i]=='e'||s[i]=='i'||s[i]=='o'||s[i]=='u') count--;         }         printf("%d/%d\n",count,k);     }     return 0; } 
#include<bits/stdc++.h> #define mod 1000000007 using namespace std; typedef long long ll; ll arr[1000010]; ll bum[1000010]; int main() { 	ll t,n,i,a; 	std::ios_base::sync_with_stdio(false); 	cin>>t; 	while(t--) 	{ 		cin>>n; 		 		ll k1=0; 		ll k2=0; 		ll flag=0; 		ll flag1=0; 		ll flag3=0; 		unsigned long long sum=1; 		unsigned long long sum1=1; 		ll count=0; 		for(i=0;i<n;i++) 		{ 			cin>>a; 			 			if(a<0) 			{ 				arr[k1++]=a; 				sum1=(-a)*sum1; 				if(sum1>=mod) 				{ 					sum1%=mod; 				} 				ll flag1=1; 				count+=1; 			} 			if(a==0) 			{ 				flag3=1; 			} 			else if(a>0) 			{ 				sum=sum*a; 				if(sum>=mod) 				{ 					sum%=mod; 				} 				flag=1; 				//brr[k2++]=a; 			} 		} 		if(flag==0 && count==1) 		{ 			if(flag3==0) 			{ 				cout<<(arr[0]+mod)<<endl; 			} 			else 			{ 				cout<<"0"<<endl; 				 				 			} 		} 		else if(flag==0 && count==0) 		{ 			cout<<"0"<<endl; 		} 		else 		{ 		 		unsigned long long ans; 		if(!(k1&1)) 		{ 			ans=(sum1*sum)%mod; 			cout<<ans<<endl; 		} 		else 		{ 			unsigned long long sum2=1; 			sort(arr,arr+k1); 			for(i=0;i<k1-1;i++) 			{ 				sum2=sum2*(-arr[i]); 				if(sum2>=mod) 				{ 					sum2%=mod; 				} 			} 			ans=(sum*sum2)%mod; 			cout<<ans<<endl; 		} 		} 		 	} 	return 0;  	 }
#include<cstdio> #include<iostream> #include<cstring> #include<vector> #include<algorithm> #include<cstdlib> #include<cmath> #define INF 100001 #define REP(i,a,b) for(int i=a;i<b;i++) #define DEP(i,a,b) for(int i=a-1;i>=b;i--) using namespace std; char s[100001],t[1001]; int a[26],b[26]; int main() {  scanf(" %s",s); int m=strlen(s);  int q; scanf("%d",&q);  while(q--)  {   scanf(" %s",t); int n=strlen(t);   memset(a,0,sizeof(a));   memset(b,0,sizeof(b));   REP(i,0,n) b[t[i]-'a']++;   int j=0,i=0,cnt=0,len=INF;   while(i<m)   {    int idx=s[i]-'a';    if(a[idx]<b[idx]) cnt++;    a[idx]++;    if(cnt==n) // match found    {     //adjust j and keep on trying for a shorter length     while(idx=s[j]-'a',a[idx]>b[idx])     {      len=min(len,i-j+1);      a[idx]--;      j++;      }     len=min(len,i-j+1); a[idx]--; j++; cnt--;    }    i++;   }   if(len==INF) printf("-1\n");   else printf("%d\n",len);  }  return 0; }
#include<bits/stdc++.h> using namespace std; int c[2000001]; int main() {     int t;     cin>>t;     while(t--)     {         int n,a,maxx=INT_MIN,ans=1;         cin>>n;          for(int i=1;i<=2000000;i++)             c[i]=0;             bool flag=false;         for(int i=1;i<=n;i++)         {            cin>>a;            c[a]++;            maxx=max(maxx,a);          }         for(int i=maxx;i>=2;i--)         {             int k=0;             for(int j=i;j<=maxx;j+=i)             {                 if(c[j])                 k+=c[j];                 if(k>1)                 {                     ans=i;                     flag=true;                     break;                 }              }             if(flag)             {                 break;             }         }         cout<<ans<<endl;      }     return 0; } 
#include <stdio.h> #include<string.h>  int main(void) { 	int t; 	scanf("%d",&t); 		char a[100005]; 		int c[26]; 	 		 	while(t--){ 		int count=0; 		for(int i=0;i<26;i++){ 		c[i]=0; 		} 		scanf("%s",&a); 	 		 		for(int i=0;i<strlen(a);i++) 			if(c[a[i]-97]==0) 				{ 					c[a[i]-97]++; 					count++; 				} 		if(count%2==0) 			printf("Terrorist\n"); 		else 			printf("Counter Terrorist\n"); 			 		 	} 	 	 	 	return 0; } 
#include <bits/stdc++.h>  using namespace std;  int main() { 	int i, j, k, r, n, cur, st; 	string str; 	cin >> str; 	n = str.size(); 	vector<int> v(n+1, -1); 	r = -1; 	cur = n+1; 	for(i=0; i<n; ){ 		j = i+1; 		while(j<n){ 			if(str[j]!=str[i]) 				break; 			j++; 		} 		r = j-1; 		k = r-i+1; 		if(str[i]=='C'){ 			if((r+1)>n) 				st = cur-k+1; 			else 				st = cur-k; 			for(j=i; j<=r; j++) 				v[j] = st++; 			if((r+1)<=n) 				v[r+1] = st, cur = cur-k-1; 			else 				cur = cur-k; 			i = r+2; 		} 		else{ 			st = cur; 			for(j=i; j<=r; j++) 				v[j] = st--; 			cur = st; 			i = r+1; 		} 	} 	if(v[n]==-1) 		v[n] = cur; 	for(i=0; i<=n; i++) 		printf("%d ", v[i]); 	printf("\n"); 	return 0; }
#include <bits/stdc++.h> using namespace std;  vector<pair<int,int> > edges[100001]; vector<int> v[100001]; long long ans[100001]; int dfs(int i,int p) {     int ret=1;     for(int j=0;j<edges[i].size();++j)     {         if(edges[i][j].first==p){ v[i].push_back(0); continue;}         int num=dfs(edges[i][j].first,i);         v[i].push_back(num);         ans[i]+=ans[edges[i][j].first]+(long long)num*edges[i][j].second;         ret+=num;     }     return ret; } void dfs1(int i,int p,int w,int n,int tot) {     if(p!=-1)          ans[i]+=(ans[p]-ans[i]-(long long)n*w+(long long)(tot-n)*w);     for(int j=0;j<edges[i].size();++j)     {         if(edges[i][j].first==p) continue;         dfs1(edges[i][j].first,i,edges[i][j].second,v[i][j],tot);     } } int main() { 	int t,n,x,y,z; 	scanf("%d",&t); 	while(t--) 	{ 	    scanf("%d",&n); 	    for(int i=1;i<=n;++i){ 	        ans[i]=0; 	        v[i].clear(); 	        edges[i].clear(); 	    } 	    for(int i=1;i<n;++i) 	    { 	        scanf("%d %d %d",&x,&y,&z); 	        edges[x].push_back(make_pair(y,z)); 	        edges[y].push_back(make_pair(x,z)); 	    } 	    dfs(1,-1); 	    dfs1(1,-1,0,n,n); 	    for(int i=1;i<=n;++i) printf("%lld\n",ans[i]); 	} 	return 0; } 
#include "stdio.h" #include "algorithm"  using namespace std; int n, a[100010], bit[100010]; pair <int,int> Unique[100010]; long long k, ans, cnt;  void update(int x, int val) {     for (; x<=n; x+=x&(-x))         bit[x] += val; } long long get(int x) {     long long hsgs = 0;     for (; x; x-=x&(-x))         hsgs += bit[x];     return hsgs; }  main() {     scanf("%d %lld", &n, &k);     for (int i=1; i<=n; i++)         scanf("%d", &Unique[i].first), Unique[i].second = i;      sort(Unique+1, Unique+n+1);     for (int i=1, j=1, d=0; j<=n; i=j)     {         d++;         for (; j<=n; j++)             if (Unique[i].first == Unique[j].first) a[Unique[j].second] = d;                 else break;     }      for (int i=1, j=1; i<=n; i++)     {         cnt += get(n) - get(a[i]);         update(a[i], 1);         while (j < i)         {             int p = get(a[j]-1);             if (cnt-p < k) break;             else cnt -= p, update(a[j++], -1);         }         if (cnt >= k) ans += j;     }      printf("%lld", ans); } 
#include<bits/stdc++.h>  using namespace std;  // Input macros #define s(n) scanf("%d",&n) #define sc(n) scanf("%c",&n) #define sl(n) scanf("%lld",&n) #define sf(n) scanf("%lf",&n) #define ss(n) scanf("%s",n) // Useful macros #define ll long long #define l long #define ull unsigned long long #define fi first #define se second #define mp make_pair #define rep(i,a,b) for(int i=a;i<b;i++) #define irep(i,a,b) for(int i=a;i>b;i--) #define CLR(a) memset((a),0,sizeof(a)) #define INF (int)1e9 #define EPS 1e-9 #define pb push_back #define pc(x) putchar_unlocked(x); #define gc getchar_unlocked  inline ll gcd(ll a, ll b) { 	if (b == 0) 		return a; 	else 		return gcd(b, a % b); } inline ll lcm(ll a, ll b) { 	return (a * b) / gcd(a, b); }  template<class T> inline void scan(T&x) { 	bool fu = 0; 	char c; 	for (c = getchar(); c <= 32; c = getchar()) 		; 	if (c == '-') 		fu = 1, c = getchar(); 	for (x = 0; c > 32; c = getchar()) 		x = x * 10 + c - '0'; 	if (fu) 		x = -x; } ; template<class T> inline void scan(T&x, T&y) { 	scan(x); 	scan(y); } template<class T> inline void scan(T&x, T&y, T&z) { 	scan(x); 	scan(y); 	scan(z); } template<class T> inline void scan(T&x, T&y, T&z, T&q) { 	scan(x); 	scan(y); 	scan(z); 	scan(q); } void write(ll n) { 	ll N = n, rev, count = 0; 	rev = N; 	if (N == 0) { 		pc('0');pc('\n'); 		return; 	} 	while ((rev % 10) == 0) { 		count++; 		rev /= 10; 	} 	rev = 0; 	while (N != 0) { 		rev = (rev << 3) + (rev << 1) + N % 10; 		N /= 10; 	} 	while (rev != 0) { 		pc(rev % 10 + '0'); 		rev /= 10; 	} 	while (count--) 		pc('0'); } void write(l n) { 	l N = n, rev, count = 0; 	rev = N; 	if (N == 0) { 		pc('0');pc('\n'); 		return; 	} 	while ((rev % 10) == 0) { 		count++; 		rev /= 10; 	} 	rev = 0; 	while (N != 0) { 		rev = (rev << 3) + (rev << 1) + N % 10; 		N /= 10; 	} 	while (rev != 0) { 		pc(rev % 10 + '0'); 		rev /= 10; 	} 	while (count--) 		pc('0'); } void write(ull n) { 	ull N = n, rev, count = 0; 	rev = N; 	if (N == 0) { 		pc('0');pc('\n'); 		return; 	} 	while ((rev % 10) == 0) { 		count++; 		rev /= 10; 	} 	rev = 0; 	while (N != 0) { 		rev = (rev << 3) + (rev << 1) + N % 10; 		N /= 10; 	} 	while (rev != 0) { 		pc(rev % 10 + '0'); 		rev /= 10; 	} 	while (count--) 		pc('0'); } void write(int n) { 	int N = n, rev, count = 0; 	rev = N; 	if (N == 0) { 		pc('0');pc('\n'); 		return; 	} 	while ((rev % 10) == 0) { 		count++; 		rev /= 10; 	} 	rev = 0; 	while (N != 0) { 		rev = (rev << 3) + (rev << 1) + N % 10; 		N /= 10; 	} 	while (rev != 0) { 		pc(rev % 10 + '0'); 		rev /= 10; 	} 	while (count--) 		pc('0'); } inline void write(const char c[]) { 	int i; 	for (i = 0; c[i] != '\0'; i++) 		pc(c[i]); }  typedef double lf; typedef pair<int, int> pii; typedef pair<ll, ll> pll; typedef pair<lf, lf> pff; typedef complex<double> CD; const int inf = 0x20202020; const int mod = 1000000007;  ll powmod(ll a, ll b) { 	ll res = 1; 	a %= mod; 	for (; b; b >>= 1) { 		if (b & 1) 			res = res * a % mod; 		a = a * a % mod; 	} 	return res; } ll powmod(ll a, ll b, ll mod) { 	ll res = 1; 	a %= mod; 	for (; b; b >>= 1) { 		if (b & 1) 			res = res * a % mod; 		a = a * a % mod; 	} 	return res; } /************************** main ***********************************/ char str[100001]; int main() { 	//freopen("in","r",stdin); 	//freopen("out","w",stdout); 	int t; 	s(t); 	while (t--) { 		ll pe=0,er=0; 		ss(str); 		rep(i,0,strlen(str)) { 			if(str[i]=='E') er++; 			if(str[i]=='P') pe++; 		} 		cout<<min(er,pe)<<" "<<max(er,pe)-min(er,pe)<<"\n"; 	} 	return 0; } 
#include<iostream> #include<algorithm> #include<vector> #include<queue> using namespace std; typedef long long LL; vector<LL> arr;  LL gcd(LL a, LL b) {     LL x;      while (b!=0)     {         x = b;         b = a%b;         a = x;     }     return a; }  int main() {     //cout<<gcd(14,32);     int t;     long long a,b,I,x,j,k;     cin>>t;     while (t--)     {         arr.clear();         cin>>a>>b>>I;         x=gcd(a,b);         arr.push_back(0);         for (int i=1;i<=(b/x)-1;i++)         {             arr.push_back(a*i);         }         for (int i=1;i<=(a/x)-1;i++)         {             arr.push_back(b*i);         }         sort(arr.begin(),arr.end());         //arr.pop_back();        /* for (int i=0;i<arr.size();i++)         cout<<arr[i]<<endl;*/         k = I%arr.size();         cout<<(a*b/x)*(I/arr.size()) + arr[k]<<endl;      } } 
// FINDING MINIMUM DISTANCE IN UNWEIGHTED GRAPH 0S AND 1S #include<stdio.h> #include<stdlib.h> #define MAX 210 typedef struct{  int key;         }element; element queue[MAX]; int front,rear; int **map,**dis,*visited; void enqueue(int item){        queue[++rear].key=item;      } int dequeue(){  return queue[++front].key;     } int isemptyqueue(){        if(front==rear)   return 1;  return 0;     } void bfs(int i,int n){    dis[i][i]=0;       int temp,j;  enqueue(i);  visited[i]=1;  //printf("her");  while(!isemptyqueue()){    temp=dequeue();                                for(j=0;j<n;j++)    if(!visited[j]&&map[temp][j])    {      dis[i][j]=dis[i][temp]+1;      enqueue(j);      visited[j]=1;                           }                        }     } void caldis(int n){  int i;   //printf("here");  for(i=0;i<n;i++){   front=-1;        rear=-1;       visited=(int*)calloc(n,sizeof(int));   //printf("here");   if(!visited[i])    bfs(i,n);   free(visited);  } } int main(){  int q,n,t,i,j,src,des;      char *str,ch;  scanf("%d",&q);  while(q--){  scanf("%d",&n);  map=(int**)malloc(n*sizeof(int*));  dis=(int**)malloc(n*sizeof(int*));  for(i=0;i<n;i++){   map[i]=(int*)malloc(n*sizeof(int));      dis[i]=(int*)malloc(n*sizeof(int));  }  ch=getchar();  str=(char*)malloc((n+1)*sizeof(char));  for(i=0;i<n;i++){    scanf("%s",str);    for(j=0;j<n;j++){      if(str[j]=='Y')        map[i][j]=1;       else        map[i][j]=0;       dis[i][j]=-1;    }  }     caldis(n);    scanf("%d",&t);      while(t--){     scanf("%d%d",&src,&des);     printf("%d\n",dis[src][des]);            }  }   return 0;    } 
#include<bits/stdc++.h> int rem[100005]; int main() { 	//memset(rem,0,100005); 	int t; 	scanf("%d",&t); 	while(t--) 	{ 	int i; 	long long a,b; 	int p; 	scanf("%lld %lld %d",&a,&b,&p); 	long long cub; 	int count=0,j=1; 	for(i=1,j=1;i<=p-1;i++) 	{ 		cub=1LL*i*i*i; 		if(cub%p==1) 		{ 			//printf("%d\n",i ); 			rem[j]=i; 			//printf("rem%d\n",rem[j] ); 			count++; 			j++; 		} 	} 	//printf("%d\n",count ); 	long long countn=0; 	//if(count>0) 	int mod1=a%p,mod2=b%p; 	j=1; 	a=a-mod1+p; 	while(rem[j]<mod1 && j<=count) 		j++; 	countn=count-j+1; 	j=1; 	//printf("countn=%lld\n",countn ); 	while(rem[j]<=mod2 && j<=count) 		j++; 	//printf(" %d j=%d\n",rem[3],j ); 	countn+=j-1; 	//printf("countn=%lld\n",countn ); 	b=b-mod2; 	//printf("b%lld\n",b ); 	long long num=(b-a)/p; 	countn+=num*count; 	printf("%lld\n",countn ); 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; int main() { 	int t,c=0; 	cin>>t; 	while(t--) 	{ 		int n,i,j; 		cin>>n; 		for(i=0;i*i*i<=n;i++) 		{ 			for(j=0;j*j*j<=n;j++) 			{ 				if((pow(i,3)+pow(j,3))==n){ c++; goto end; 				} 			} 		} 		end: ; 	} 	 	cout<<c<<endl; 	return 0; } 
#include <bits/stdc++.h> using namespace std;  #define DEBUG(x)	cerr << #x << " = " << x << endl; #define INPUT		freopen("Data.inp", "r", stdin); #define OUTPUT		freopen("Data.out", "w", stdout);  typedef long long LL; typedef pair<int, int> II; struct Query { 	int type; 	int u, l, r; };  const int N = 200000 + 10; const int B = 400; const int P = (int) 1e9 + 7;  int n, m, k, ans[N], a[N], s[2][N], pw[N]; string S[N]; Query q[N]; vector<int> Length, H[N], QueryList[N]; map<II, int> pos;  int Block(int i)	{ return (i - 1) / B + 1; 	} int Start(int i)	{ return (i - 1) * B + 1; 	} int End(int i)		{ return i * B;				}  void Add(int i) { 	int x = Block(i); a[i]++; 	s[0][x] = s[0][x] + (a[i] == 1); 	s[1][x] = s[1][x] + 1; }  void Reset(int i) { 	a[i] = 0; 	s[0][Block(i)] = s[1][Block(i)] = 0; }  int Sum(int k, int l, int r) { 	if (Block(l) == Block(r)) { 		int ans = 0; 		for (int i = l; i <= r; ++i) ans += (k == 0) ? (a[i] > 0) : a[i]; 		return ans; 	} 	int x = Block(l) + 1, y = Block(r) - 1; 	int ans = 0; 	for (int i = l; i <= End(x - 1); ++i) 	ans += (k == 0) ? (a[i] > 0) : a[i]; 	for (int i = Start(y + 1); i <= r; ++i)	ans += (k == 0) ? (a[i] > 0) : a[i]; 	for (int i = x; i <= y; ++i) 			ans += s[k][i]; 	return ans; }  void Solve(int p) { 	vector<int> Log; 	for (int z = 0; z < (int) QueryList[p].size(); ++z) { 		int x = QueryList[p][z]; 		if (q[x].type == 0) { 			int u = q[x].u; 			Add(u); Log.push_back(u); 		} 		else ans[x] = Sum(q[x].type - 1, q[x].l, q[x].r); 	} 	for (int i = 0; i < (int) Log.size(); ++i) Reset(Log[i]); }  int HashValue(string S) { 	int ans = 0; 	for (int i = 0; i < (int) S.size(); ++i) ans = (ans * 31ll + S[i] - 'a') % P; 	return ans; }  int HashValue(int k, int l, int r) { 	return (H[k][r] - H[k][l - 1] * (LL) pw[r - l + 1] + (LL) P * P) % P; }  int main() { 	#ifdef LOCAL 		INPUT; 		OUTPUT; 	#else 		ios_base::sync_with_stdio(false); 		cin.tie(0); 	#endif  	cin >> n >> m >> k; 	for (int i = 1; i <= m; ++i) { 		string S; cin >> S; 		reverse(S.begin(), S.end()); 		Length.push_back((int) S.size()); 		pos[II((int) S.size(), HashValue(S))] = i; 	} 	sort(Length.begin(), Length.end()); 	Length.resize(unique(Length.begin(), Length.end()) - Length.begin());  	pw[0] = 1; 	for (int i = 1; i <= 1 << 16; ++i) pw[i] = pw[i - 1] * 31ll % P; 	for (int i = 1; i <= n; ++i) { 		S[i] = " "; 		H[i].push_back(0); 	} 	for (int i = 1; i <= k; ++i) { 		cin >> q[i].type; 		if (q[i].type == 0) { 			int u; string c; cin >> u >> c; q[i].u = u; 			S[u].push_back(c[0]); 			H[u].push_back((H[u].back() * 31ll + c[0] - 'a') % P);  			int curLength = (int) S[u].size() - 1; 			for (int t = 0; t < (int) Length.size(); ++t) { 				int L = Length[t]; if (L > curLength) break; 				II f(L, HashValue(u, curLength - L + 1, curLength)); 				if (pos.count(f)) QueryList[pos[f]].push_back(i); 			} 		} 		else { 			int p; cin >> q[i].l >> q[i].r >> p; 			QueryList[p].push_back(i); 		} 	}  	for (int p = 1; p <= m; ++p) Solve(p); 	for (int i = 1; i <= k; ++i) if (q[i].type) cout << ans[i] << "\n"; 	return 0; }
#include<bits/stdc++.h> using namespace std; #define mod 1000000007 long  long int power( long long int a,long long int b) {     long long int temp;     if(b==0)         return 1;     if(b==1)         return a;     temp=power(a,b/2);     if(b&1)         return ((temp*temp)%mod*a)%mod;         else             return (temp*temp)%mod; } int main() {     long long int n,m,p,q;     cin>>n>>m;     long long int a[n+1];     for(long long int i=1;i<=n;i++)         a[i]=i;     for(long long int i=0;i<m;i++)     {         scanf("%lld %lld",&p,&q);         if(p<q)             a[p]=q;         else             a[q]=p;     }     long long int c=0;     for(long long int i=1;i<=n;i++)     {         if(a[i]==i)         c++;     }    cout<<power(2,n-c)<<endl;     return 0; } 
 #include<bits/stdc++.h> using namespace std; int main() {     int t;     scanf("%d",&t);     while(t--)     {         int n;         scanf("%d",&n);         int temp=n;           if(n<=9)         {             if (n==0)                 cout<<"zero\n";             else if(n==1)                 cout<<"one\n";             else if(n==2)                 cout<<"two\n";             else if(n==3)                 cout<<"three\n";             else if(n==4)                 cout<<"four\n";             else if(n==5)                 cout<<"five\n";             else if(n==6)                 cout<<"six\n";             else if(n==7)                 cout<<"seven\n";             else if(n==8)                 cout<<"eight\n";             else if(n==9)                 cout<<"nine\n";         }        else if(n>=10&&n<=20)         {             if(n==10)                 cout<<"ten\n";             else if(n==11)                 cout<<"eleven\n";             else if(n==12)                 cout<<"twelve\n";             else if(n==13)                 cout<<"thirteen\n";             else if(n==14)                 cout<<"fourteen\n";             else if(n==15)                 cout<<"fifteen\n";             else if(n==16)                 cout<<"sixteen\n";             else if(n==17)                 cout<<"seventeen\n";             else if(n==18)                 cout<<"eighteen\n";             else if(n==19)                 cout<<"nineteen\n";             else if(n==20)                 cout<<"twenty\n";         }          else         {                 temp=temp/10;             if(temp==2)                 cout<<"twenty";             else if(temp==3)                 cout<<"thirty";             else if(temp==4)                 cout<<"forty";             else if(temp==5)                 cout<<"fifty";             else if(temp==6)                 cout<<"sixty";             else if(temp==7)                 cout<<"seventy";             else if(temp==8)                 cout<<"eighty";             else if(temp==9)                 cout<<"ninety";     n=n%10;                if(n==0)                 cout<<"\n";                 if(n==1)                 cout<<"-one\n";             else if(n==2)                 cout<<"-two\n";             else if(n==3)                 cout<<"-three\n";             else if(n==4)                 cout<<"-four\n";             else if(n==5)                 cout<<"-five\n";             else if(n==6)                 cout<<"-six\n";             else if(n==7)                 cout<<"-seven\n";             else if(n==8)                 cout<<"-eight\n";             else if(n==9)                 cout<<"-nine\n";          }      }  } 
#include <iostream> #include <algorithm> #include <vector> #include <cstdio> #include <cstring> #include <string> #include <cctype> using namespace std; char str[100000]; int main () { 	gets(str); 	vector<int> v; 	int num = 0; 	int len = strlen(str); 	int i = 0; 	while (str[i] != '\0') { 		if (isspace(str[i])) { 			v.push_back(num); 			num = 0; 		} 		else { 			num = (num<<3) + (num<<1) + (str[i] - '0'); 		} 		i++; 	} 	if (v.size() < 3) 		return 0; 	sort(v.begin(), v.end()); 	int count = 1, cur = v[0]; 	i = 1; 	while (count != 3) { 		if (i >= v.size()) 			return 0; 		if (v[i] > cur) { 			count++; 			cur = v[i]; 		} 		i++; 	} 	cout<<cur<<endl; 	return 0; }
#include <iostream>  #define SD(a) scanf("%d", &a) #define PD(a) printf("%d ", a)  int main () { 	int seq[10000], cnt = 0, status = 0; 	for (; SD(seq[cnt]) != EOF; ++cnt); 	for (int i = 0; i < cnt; i++) { 		for (int j = 0; j < cnt - 1; ++j) { 			if (seq[j] > seq[j+1]) { 				seq[j] = seq[j] ^ seq[j+1]; 				seq[j+1] = seq[j] ^ seq[j+1]; 				seq[j] = seq[j] ^ seq[j+1]; 				status = 1; 			} 			PD(seq[j]); 		} 		PD(seq[cnt - 1]); 		if (status == 0) 			break; 		status = 0; 		puts(""); 	} 	return 0; }
#include<iostream> using namespace std;  int main() { int a,b,c,d,e,t; while(cin>>e) { 	a = (e/1000)*1000; 	b = ((e/100)%10)*100; 	c = ((e/10)%10)*10; 	d = ((e/1)%10)*1;  	if (a ==1000) 		 cout<<"M"; 	else if (a ==2000) 		 cout<<"MM"; 	else if (a ==3000) 		 cout<<"MMM";  	if (b == 100) 		 cout<<"C"; 	else if (b == 200) 		 cout<<"CC"; 	else if (b == 300) 		 cout<<"CCC"; 	else if (b == 400) 		 cout<<"CD"; 	else if (b ==500) 		 cout<<"D"; 	else if (b == 600) 		 cout<<"DC"; 	else if (b == 700) 		 cout<<"DCC"; 	else if (b ==800) 		 cout<<"DCCC"; 	else if (b == 900) 		 cout<<"CM";   	if (c == 10) 		 cout<<"X"; 	else if (c == 20) 		 cout<<"XX"; 	else if (c == 30) 		 cout<<"XXX"; 	else if (c == 40) 		 cout<<"XL"; 	else if (c ==50) 		 cout<<"L"; 	else if (c == 60) 		 cout<<"LX"; 	else if (c == 70) 		 cout<<"LXX"; 	else if (c ==80) 		 cout<<"LXXX"; 	else if (c == 90) 		 cout<<"XC";  	if (d == 1) 		 cout<<"i"; 	else if (d == 2) 		 cout<<"ii"; 	else if (d == 3) 		 cout<<"iii"; 	else if (d == 4) 		 cout<<"iV"; 	else if (d ==5) 		 cout<<"V"; 	else if (d == 6) 		 cout<<"Vi"; 	else if (d == 7) 		 cout<<"Vii"; 	else if (d ==8) 		 cout<<"Viii"; 	else if (d == 9) 		 cout<<"iX"; 		 cout<<endl; } return 0; } 
//{ #include<iostream> #include<cmath> #include<algorithm> #include<climits> #include<vector> #include<queue> #include<stack> #include<bitset> #include<cstdlib> #include<cstdio> #include<cstring> #include<ctime> #include<map> using namespace std; #define MOD 1000000007LL #define LL long long #define ULL unsigned long long #define MAX(a,b) ((a)>(b)?(a):(b)) #define MIN(a,b) ((a)<(b)?(a):(b)) #define ABS(x)   ((x)<0?-(x):(x)) #define SQR(x) ((x)*(x)) #define CUBE(x) ((x)*(x)*(x)) #define si(n) scanf("%d",&n) #define si2(n,m) scanf("%d %d",&n,&m) #define sll(n) scanf("%lld",&n) #define slu(n) scanf("%llu",&n) #define ss(n) scanf("%s",n) #define pnl printf("\n") #define FORD(i,a,b,d) for(typeof(b) i=(a);i<(b);i+=(d)) #define FOR(i,a,b) for(typeof(b) i=(a);i<(b);i++) #define REP(i,n) for(typeof(n) i=0;i<(n);i++) #define FORR(i,n,e) for(typeof(n) i=(n);i>=(e);i--) #define FORRD(i,n,e,d) for(typeof(n) i=(n);i>=(e);i-=(d)) #define FILL(a,b) memset(a,b,sizeof(a)) //#undef mydebug//DEBUGGING PURPOSE #ifdef mydebug #define debug(args...) {printf("\nLine-->%d  ",__LINE__);printf(#args);printf(" ---> ");dbg,args;printf("\n");} #define DB(x) cout<<#x<<": "<<x<<"\n" #define DB2(x,y) cout<<#x<<": "<<(x)<<"\t"<<#y<<": "<<(y)<<"\n" #define DB3(x,y,z) cout<<#x<<": "<<(x)<<"\t"<<#y<<": "<<(y)<<"\t"<<#z<<": "<<(z)<<"\n" #define DB4(x,y,z,a) cout<<#x<<": "<<(x)<<"\t"<<#y<<": "<<(y)<<"\t"<<#z<<": "<<(z)<<"\t"<<#a<<": "<<(a)<<"\n" #define DBG_ARR(a,b,c) printf(#a);DBG(a,b,c) #define DBG_MAT(a,s,b,c) printf(#a);printf("\n");DBGM(a,s,b,c) #else #define debug(args...) #define DB(x) #define DB2(x,y) #define DB3(x,y,z) #define DB4(x,y,z,a) #define DBG_ARR(a,b,c) #define DBG_MAT(a,s,b,c) #endif template<typename T>void DBG(const T A,int S,int N){cout<<"[";FOR(i,S,N){cout<<"#"<<i<<":"<<A[i]<<" ";}cout<<"]\n";} template<typename T>void DBGM(const T A,int S,int M,int N){FOR(i,S,M){FOR(j,S,N){cout<<A[i][j]<<" ";}printf("\n");}} struct debugger{template<typename T>debugger&operator,(const T&v){cout<<" #"<<v;return *this;}}dbg; const double PIE=acos(-1.0); const double EPS=1e-5; template<typename T>inline T Mod(T N,T M){return (N%M+M)%M;} //template<typename T>void swap(T &x,T &y){T t=x;x=y;y=t;} template<typename T>inline int countbit(T n){return (n==0)?0:(1+countbit(n&(n-1)));} bool isUpperCase(char c){return c>='A'&&c<='Z';} bool isLowerCase(char c){return c>='a'&&c<='z';} bool isLetter(char c){return c>='A'&&c<='Z'||c>='a'&&c<='z';} bool isDigit(char c){return c>='0'&&c<='9';} char toLowerCase(char c){return (isUpperCase(c))?(c+32):c;} char toUpperCase(char c){return (isLowerCase(c))?(c-32):c;} template<typename T> inline T gcd(T a,T b){if(a<0)return gcd(-a,b);if(b<0)return gcd(a,-b);return (b==0)?a:gcd(b,a%b);} template<typename T>T _gcd(T a,T b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} //int dx[]={1,0,-1,0};int dy[]={0,1,0,-1};//4 Direction //int dx[]={1,1,0,-1,-1,-1,0,1};int dy[]={0,1,1,1,0,-1,-1,-1};//8 direction //int dx[]={2,1,-1,-2,-2,-1,1,2};int dy[]={1,2,2,1,-1,-2,-2,-1};//Knight Direction //int dx[]={-1,-1,+0,+1,+1,+0};int dy[]={-1,+1,+2,+1,-1,-2}; //Hexagonal Direction //int month[]={-1,31,28,31,30,31,30,31,31,30,31,30,31}; //Not Leap Year //string monthName[]={"","January","February","March","April","May","June","July","August","September","October","November","December"}; //string dayName[]={"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"}; //}  void precompute(){} char arr[1001]; int N; void permute(char *s,int start,int end){     if(start==end){         printf("%s\n",arr);         return;     }     FOR(i,start,end+1){         swap(*(s+start),*(s+i));         permute(s,start+1,end);         swap(*(s+start),*(s+i));     }  } void doThis(){     ss(arr);     N=strlen(arr);     permute(arr,0,N-1); } int main(){ #ifdef amy freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt","w",stderr); #endif doThis(); #ifdef amy fprintf(stdout,"\nTIME: %.3lf sec\n",(double)clock()/(CLOCKS_PER_SEC)); #endif return 0; } 
#include <iostream> #include <cstdio> #include <string> #include <cstring>  int main () { 	int n, div, res, len, i; 	std::string str; 	std::cin >> str; 	len = str.length(); 	while (len != 0) { 		n = 0; 		i = 0; 		while (i < len) { 			n = (n<<3) + (n<<1) + (str[i++] - '0'); 		} 		res = 0; div = 5; 		while (n / div != 0) { 			res += n / div; 			div *= 5; 		} 		printf("%d\n", res); 		str.clear(); 		std::cin >> str; 		len = str.length(); 	} 	return 0; }
#include <iostream> using namespace std; long long MaxVal(long long n, long long p, long long q);   //Define memoization array const int maxp = 28; const int maxq = 18; long long maxVals[maxp*maxq];     int main(){   	while(true){   		long long n;   		//Get the input 		std::cin >> n;   		if(std::cin.eof()){break;}   		//Initialize the memoization array to negative values 		for(int p=0;p<maxp;p++){ 			for(int q=0;q<maxq;q++){ 				  maxVals[q + p*maxq] = -1; 			} 		}   		//Output the result 		std::cout << MaxVal(n,0,0) << std::endl; 	}    	 	return 0; }   long long MaxVal(long long n, long long p, long long q){ //Recursive algorithm to compute maximum American dollars //from n Bytelandian dollars   	if(n<12) 	{	return n; 	}  	else if(maxVals[q + p*maxq]>=0) 	{	 		//Don't waste time. Use the values that have already been computed 		return maxVals[q + p*maxq];   	}  	else 	{	long long a = n/2; 		long long b = n/3; 		long long c = n/4;   		long long bestAmt = MaxVal(a, p+1, q)  			              + MaxVal(b, p, q+1)  				   	      + MaxVal(c, p+2, q);   		//Store this value so it need not be recomputed 		maxVals[q + p*maxq] = bestAmt;    		return bestAmt; 	} }
#include<stdio.h> #include<iostream> using namespace std; char *a[]={"","pa","re","ci","vo","mk","x","zi","bi","so"}; char s[10001]; int main() { 	int i; 	scanf("%s",&s); 	for(i=0;s[i]!='\0';i++) 	{ 		printf("%s",a[s[i]]); 	} 	return 0; } 
//{ /* theCodeGame */ lesson learnt A mod B is different in case of negative, just take care :P #include<iostream> #include<cmath> #include<algorithm> #include<climits> #include<vector> #include<queue> #include<bitset> #include<cstdlib> #include<cstdio> #include<cstring> #include<ctime> #include<map> using namespace std; #define MOD 1000000007LL #define LL long long #define ULL unsigned long long #define LD long double #define MAX(a,b) ((a)>(b)?(a):(b)) #define MIN(a,b) ((a)<(b)?(a):(b)) #define ABS(x)   ((x)<0?-(x):(x)) #define SQR(x) ((x)*(x)) #define CUBE(x) ((x)*(x)*(x)) #define si(n) scanf("%d",&n) #define si2(n,m) scanf("%d %d",&n,&m) #define sf(n) scanf("%f",&n) #define sl(n) scanf("%ld",&n) #define sll(n) scanf("%lld",&n) #define slu(n) scanf("%llu",&n) #define sd(n) scanf("%lf",&n) #define ss(n) scanf("%s",n) #define pnl printf("\n") #define REP(i,n) for(int i=0;i<(n);i++) #define FOR(i,a,b) for(int i=(a);i<(b);i++) #define FORR(i,n,e) for(int i=(n);i>=(e);i--) #define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d)) #define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d))  //#undef mydebug #ifdef mydebug #define DB(x) cout<<#x<<"="<<(x)<<"\n" #define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n" #define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n" #define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n" #define pnld pnl; #else #define DB(x) #define DB2(x,y) #define DB3(x,y,z) #define DB4(x,y,z,a) #define pnld #endif #define FILL(a,b) memset(a,b,sizeof(a)) const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; //template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;} void DBG_ARR(const int A[],int S,int N){cout<<"[";FOR(i,S,N){cout<<A[i]<<" ";}cout<<"]\n";} void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;} ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} //} #define PMOD 23102009 #define size 1010 char A[size]; char B[size]; int ANS[size][size];//for main LCS int M,N;   void precompute(){} void LCS(){     FOR(i,0,M+1){         FOR(j,0,N+1){             if(i==0||j==0){                 ANS[i][j]=0;             }else{                 if(A[i-1]==B[j-1]){                     ANS[i][j]=1+ANS[i-1][j-1];                 }else{                     ANS[i][j]=MAX(ANS[i][j-1],ANS[i-1][j]);                 }             }         }     }     if(ANS[M][N]<=1){         puts("None");         return;     }     vector<char>LCSs;     int i=M,j=N,count=0;     LCSs.empty();     while(i!=0&&j!=0){         if(A[i-1]==B[j-1]){             LCSs.push_back(A[i-1]);             count++;             i--;             j--;         }else{             if(ANS[i-1][j]>ANS[i][j-1])                 i--;             else                 j--;         }     }    // continue;    FOR(i,0,count){        cout<<LCSs[i];    }    pnl; } void doThis(){     while(ss(A)!=EOF){         FILL(B,'\0');         FILL(ANS,0);         //ss(B);         M=strlen(A);         N=M;         B[M]='\0';         FOR(i,0,M){             B[i]=A[M-i-1];         }        // DB2(A,B);         LCS();     }   }  int main(){ #ifdef amy freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr); #endif precompute(); int t=1; //scanf("%d",&t); while(t--){doThis();} #ifdef amy fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC)); #endif return 0; } 
#include <bits/stdc++.h> using namespace std;   int main(){ 	int n,i; 	string s;  	cin>>n; 	cin>>s; 	string temp;  	for(i=0;i<n;i++){ 		cin>>temp; 		while(s.find(temp)!=string::npos) 			s.erase(s.find(temp),temp.length()); 	} 	 	s.length()>0 ? cout<<s<<endl:cout<<"0\n"; 	return 0; } 
#include <bits/stdc++.h> using namespace std;  //http://www.cplusplus.com/reference/ios/fixed/ //http://stackoverflow.com/questions/6735701/number-of-assignments-necessary-to-find-the-minimum-value-in-an-array  int main(){ 	int t,n,i; 	double ans; 	cin>>t; 	cout.precision(3); 	while(t--){ 		cin>>n; 		for(i=2,ans=1.0;i<=n;i++) 			ans+=1.0/i; 		cout<<fixed<<ans<<endl; 	} 	return 0; } 
#include<bits/stdc++.h> #define gc getchar_unlocked #define pc putchar_unlocked #define pb push_back #define mk make_pair #define MOD 1000000009 #define ll long long int #define mc(B) memset(B,'\0',sizeof B) #define mi(B) memset(B,0,sizeof B) #define MAX 800001 #define rep(i,a,b) for(int i=(int)a;i<(int)b;i++) #define rrep(i,a) for(int i=(int)a;i>=(int)0;i--) #define ab(a) (a<0)?(-1*a):a #define my_size(x) ((char*)(&x+1)-(char*)&x)  using namespace std; inline void rdint(int &n) { n=0; char c=gc(); while(c < '0' or c > '9') c=gc(); while(c>='0' and c<='9') { n=(n<<3)+(n<<1)+c-'0'; c=gc(); }} inline void rdlong(ll &n) { n=0; char c=gc(); while(c < '0' or c > '9') c=gc(); while(c>='0' and c<='9') { n=(n<<3)+(n<<1)+c-'0'; c=gc(); }} inline void print(int a) { char s[20]; int i=0; do { s[i++]=a%10+'0'; a/=10; } while(a); i--; while(i>=0) pc(s[i--]); pc('\n'); } inline void prlong(ll a) { char s[20]; int i=0; do { s[i++]=a%10+'0'; a/=10; } while(a); i--; while(i>=0) pc(s[i--]); pc('\n'); } inline int power(int a, int b) { int x=1, y=a; while(b>0) { if(b&1) x*=y; y*=y; b/=2;} return x; } inline int powerl(ll a, ll b) { ll x=1, y=a; while(b>0) { if(b&1) x*=y; x%=MOD; y*=y; y%=MOD; b/=2;} return x%MOD; } inline int gcd(int a, int b) { if(!b) return a; return gcd(b, a%b); } inline void strrev(char *s) { char t; for(int i=0, j=strlen(s)-1;i<j;i++,j--) t=*(s+i), *(s+i)=*(s+j), *(s+j)=t; } template<typename T> int mysize(T &x) { return ((char*)(&x+1)-(char*)&x); }  const int LIM=1000010; int flag[LIM]; inline void gensieve() { mi(flag); int i,j; flag[0] = flag[1] = 1; for(i=4;i<LIM;i+=2) flag[i]=1;  	for (i = 3;i*i < LIM;i=i+2) if(!flag[i]) for(j=i*i;j<LIM;j=j+2*i) flag[j]=1; } int fact (int num) {     if (num <=1 )         return 1;     else         return num * fact (num-1); }   int find_big (char str[], int start) {     int x = str[start];     int count = 0;     int trav;     for (trav = start + 1; *(str + trav ); trav++)     {         if (str[trav] > x)             count++;     }     return count; }   int find_rank (char str[]) {     int len = strlen (str);     int mul = fact (len);       int trav;     int res = 1;     for (trav = 0; *(str + trav); trav++ )     {         int small = find_big (str, trav);         mul = mul / (len - trav);         res += mul * small;       }     return res;     }   void reverse (char str[]) {     int start = 0;     int end = strlen (str)-1;     while (start <= end)     {         char temp = str[start];         str[start] = str[end];         str[end] = temp;         start++;         end--;     }     printf("%s\n",str);   }   void column  (int num) {     char str[20];     int index = 0;     while (num >0 )     {         int rem = num % 26;         if (rem == 0)         {             str[index++] = 'Z';             num = num /26 -1;         }         else         {             str[index++] = rem-1 + 'A';             num = num /26;         }     }     str[index] = '\0';     reverse (str);   }   int main() {     int t;     scanf("%d",&t);     char *str = (char *)malloc (sizeof(char) * 10);     while (t--)     {         scanf("%s",str);         int res = find_rank (str);         column(res);     }     return 0; }
#include<iostream> using namespace std; int main(){ 	cout<<"NOT YET!"; }
#include<bits/stdc++.h> using namespace std; int main() { 	int t; 	cin>>t; 	int arr[26]; 	char c; 	//C,C#,D,D#,E,F,F#,G,G#,A,B and S 	int arrC[10]={9,10,0,2,4,5,7,11}; 	int arrs[8]={0,0,1,3,0,6,8}; 	while(t--) 	{int ind[3]; 		 		for( int i=0;i<3;i++) 		{ 		cin>>c; 		if(c>='a')ind[i]=arrs[c-'a']; 		else if(c=='S')ind[i]=11; 		else ind[i]=arrC[c-'A']; 	} 	int first,second; 	//cout<<ind[0]<<" "<<ind[1]<<" "<<ind[2]<<endl; 	if(ind[0]>ind[1])first=12+ind[1]-ind[0]; 	else first=ind[1]-ind[0]; 	if(ind[1]>ind[2])second=12+ind[2]-ind[1]; 	else second=ind[2]-ind[1]; 	 	//cout<<first<<" "<<second<<" "<<endl; 	 	if(first==4 )cout<<"Major"<<endl; 	else cout<<"Minor"<<endl; 	 	 		 	} 	 	return 0; }
#include<iostream> using namespace std; int main() { int n; long long h; for(int i=1;i<=n;i++) cin>>h; for(int i=1;i<=n;i++) cin>>h; cout<<"2"<<endl; }
#include<iostream> #include<string> #include<map> #include<algorithm> #include<vector> using namespace std; int main() { 	int t; 	cin>>t; 	 	for(int x=1;x<=t;x++) 	{ 		int n; 		cin>>n; 		map<string,vector<string> > mp; 			map<string,vector<string> > ::iterator it;         string v;         for(int i=0;i<n;i++)         {         	cin>>v;         	int l=v.length();         	string s;         	s+=v[l-3];         	s+=v[l-2];         	s+=v[l-1];         	mp[s].push_back(v);         	 		} 		cout<<"Case : "<<x<<"\n"; 		vector<string> ::iterator tt; 		for(it=mp.begin();it!=mp.end();it++) 		{ 			vector<string> v=it->second; //			for(int i=0;i<v.size();i++) //			{ //				cout<<v[i]<<" "; //			}             sort(v.begin(),v.end()); 			for(tt=v.begin();tt!=v.end();tt++) 			cout<<(*tt)<<" "; 			cout<<"\n"; 		} 		 	//	x++; 	} }
#include<stdio.h> using namespace std; int gcd(int x,int y) { 	if(x==0) 	return y; 	if(y==0) 	return x; 	if(x==y) 	return x; 	else 	return gcd(y,x%y); } int main() { 	int t,a,b,n,x; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d%d%d",&a,&b,&n); 		x=gcd(a,b); 		//printf("x=%d\n",x); 		if((n%x==0)&&(n<=a||n<=b)) 		printf("YES\n"); 		else 		printf("NO\n"); 	} }
#include <iostream> #include<stdio.h> using namespace std;  bool isOpening(char ch) {     return (ch=='(' || ch=='[' || ch=='{'); }  bool isClosing(char ch) {     return (ch==')' || ch==']' || ch=='}'); }  bool check(char ch, char ch1) {     return((ch=='{'&&ch1=='}')||(ch=='['&&ch1==']')||(ch=='('&&ch1==')')); }  int main() {     int t;     cin>>t;     while(t--)     {         int i,j=-1,flag=0;         char s[1001],a[1001]={'\0'};         scanf("%s",s);         for(i=0;s[i]!='\0';i++)         {             if(isOpening(s[i]))             {                 j++;                 a[j]=s[i];             }             else if(isClosing(s[i]))             {                 if(!check(a[j],s[i]))                 {flag=1;                 break;                 }                 else                 {                     a[j]='\0';                     j--;                 }             }         }          if(flag==0 && j==-1)         cout<<"BALANCED"<<endl;          else         cout<<"NOT BALANCED"<<endl;     }     return 0; }
#include<bits/stdc++.h>     using namespace std;     #define vi vector<int>     #define ll long long     #define pb push_back     int vis[100];vi v1[100];     int b1,pi;     void dfs(int x,string s)     {     string s1=s,n="";     int a=x;     vis[x]=-1;     if(x==0)     s+='0';     while(x)     {     n+=char((x%10)+48);     x/=10;     }           for (int i = n.size()-1; i >=0; --i)     {     s+=n[i];     }     x=a;     s+=" ";     //cout<<"at "<<a<<" \ns="<<s<<"\n";     if(x==b1)     {     pi++;     cout<<s<<"\n";     return ;     }     //cout<<v1[1].size();     for (int i = 0; i < v1[x].size(); ++i)     {     //cout<<"**";     //cout<<"x="<<x<<" x1="<<v1[x][i]<<"\n";     if(v1[x][i]!=b1)     if(vis[v1[x][i]]==-1)     continue;     //cout<<"*";     vis[v1[x][i]]++;     dfs(v1[x][i],s);     }     vis[x]=1;     return;     }           int main()     {     int t2;     cin>>t2;     while(t2--)     {     int n,a,b,z,t,t1;     int c;           memset(vis,0,sizeof vis);     vi v[100];           cin>>n>>a>>b>>z>>c;     for (int i = 0; i < c; ++i)     {     scanf("%d%d",&t,&t1);     v[t].pb(t1);     }     for (int i = 0; i < 100; ++i)     {     v1[i]=v[i];     }     /*if(a==b&&b==z)     {           cout<<a<<"\nYES\n";     continue;     }     if(a==b)     {     cout<<a<<"\nNO\n";     continue;     }*/           pi=0;     b1=b;     string s="";     vis[a]++;     dfs(a,s);     memset(vis,0,sizeof vis);     queue<int>q;     if(pi==0)     {           cout<<"NO PATH\n";     continue;     }     q.push(a);     int f=0;     while(!q.empty()&&!f)     {     int x=q.front();     q.pop();     if(x==z)     continue;     for (int i = 0; i < v[x].size(); ++i)     {     if(vis[v[x][i]])     continue;     if(v[x][i]==b)     {     f=1;     break;     }     if(i==z)     continue;     vis[v[x][i]]++;     q.push(v[x][i]);     }     }     if(f==0&&a!=b)     cout<<"YES\n";     else     cout<<"NO\n";           }     return 0;     }  
#include <bits/stdc++.h> #define MOD 1000000007 using namespace std;   pair<long long,long long> BB[2005]; long long ANS[2005],FF[200005],INVF[200005];   long long expoMod(long long b,long long K) {     if(K==0)         return 1;     long long ANS=expoMod(b,K/2);     ANS=(ANS*ANS)%MOD;     if(K%2==0) return ANS;     else{         ANS=(ANS*b)%MOD;         return ANS;     } }   long long compute(long long a,long long b,long long c,long long d) {     long long x = c-a;     long long y = d-b;     long long res = FF[x+y];     res = (res * INVF[x]) % MOD;     res = (res * INVF[y]) % MOD;     res = res % MOD;     return res; }   int main() {     //freopen("inp.in","r",stdin);     long long t,M,N,K,x,y;          FF[0] = 1;          for(long long i = 1 ; i <= 200005 ; i++) FF[i] = (FF[i-1]*i) % MOD;       INVF[200005] = expoMod(FF[200005],MOD-2);     for(long long i = 200004; i >= 0 ; i--) INVF[i] = ( INVF[i+1]*(i+1) ) % MOD;     int T;     cin >> T;     while(T--){     cin >> M >> N >> K;       for(int i = 0 ; i < K ; i++)     {         cin >> x >> y;         BB[i]=make_pair(x,y);     }       BB[K]=make_pair(M,N);     sort(BB,BB+K+1);       for(int i=0;i<=K;i++) ANS[i]=compute(1,1,BB[i].first,BB[i].second);          for(int i=0;i<K;i++)     {         for(int j=i+1;j<K+1;j++)         {             if((BB[j].first<BB[i].first) or (BB[j].second<BB[i].second))                 continue;             ANS[j]=(ANS[j]-(ANS[i]*compute(BB[i].first,BB[i].second,BB[j].first,BB[j].second))%MOD+MOD)%MOD;         }     }       if(ANS[K] < 0) ANS[K]+=MOD;     cout << ANS[K] << "\n";     }     return 0; }  
    //coding dijkstras in my own style #include <iostream> #include <vector> #include <queue> #include <cmath> using namespace std; struct compare {     bool operator()(const pair<double,int>& l, const pair<double,int>& r)     {         return l.first < r.first;     } }; int main() {         //cout<<MAX_INPUT;               int test;     cin>>test;               while(test--)     {         int V;         cin>>V;                  vector<pair<double,int> > adj[10000];         int a,b;         double w;         scanf("%d%d%lf",&a,&b,&w);                  while(a!=-1&&b!=-1&&w!=-1)         {             adj[a].push_back(make_pair(w,b));             adj[b].push_back(make_pair(w,a));                          scanf("%d%d%lf",&a,&b,&w);                                   }                                    double weight[1000]={0};         bool color[10000]={0};//if the node is reached and shortest distance for it is calculated then there is no need to repush anything for it         for(int i=1;i<=V;i++)         {             weight[i]=-1000000000;                                   }                      //start with node a and push all it's vertices in the priority queue...check till the time the priority queue is not empty..if it is still full just go to those nodes which aren't yet colored and color only those nodes where you have reached the minimum way using the priority queue         int source,dest;                  source=1;         dest=V;                      //cin>>source>>dest;         weight[source]=0;         color[source]=true;         priority_queue<pair<double,int>,vector<pair<double, int> >,compare > p1;                  for(int i=0;i<adj[source].size();i++)         {             p1.push(adj[source][i]);                 //  cout<<p1.top().first;                              // p1.top().second+=weight[source];         }                  double min_weight=10000000;         while(!p1.empty())         {             int curr=p1.top().second;                                           //cout<<curr;                 //cout<<"is the node currently"<<endl;             weight[curr]=p1.top().first;                              //cout<<weight[curr]<<endl;                          if(weight[curr]<min_weight)                 min_weight=weight[curr];                                       color[curr]=true;                          if(p1.top().second==dest)                 break;                          p1.pop();                          for(int i=0;i<adj[curr].size();i++)             {                 if(!color[adj[curr][i].second])                 {                                          p1.push(make_pair(adj[curr][i].first, adj[curr][i].second));                                                                                                     }                              }                                                                          }                                        //for(int i=1;i<=3;i++)             //if(weight[dest]!=1000000000)                  if(V!=1)             printf("%lf\n",min_weight);                  else             printf("0\n");                 //cout<<min_weight<<endl;                      //else             //cout<<-1<<endl;             //cout<<weight[dest]<<endl;                  for(int i=0;i<=V;i++)         {             adj[i].clear();                  }                       }           } 
#include<iostream> #include<stdlib.h> #include<algorithm> using namespace std; int main() {     long long unsigned t,m;     string n;     char k;     cin>>t;     while(t--)     {         cin>>n>>k;         m=count(n.begin(),n.end(),k);         cout<<m<<"\n";       }     return 0; } 
#include<iostream> #include<stdio.h> #include<string.h> using namespace std;   int IndexOf(char a[], char c) {     int i=0;     for(i=0;i<strlen(a);i++)     {         if(a[i]==c)         return i;     }     return -1; }   int main() {     char row1[]="qwertyuiop";     char row2[]="asdfghjkl";     char row3[]="zxcvbnm";     bool uppercase=false;     char q[1000];     cin.getline(q,1000);     char ans[1000];         {             int i=0;             for(i=0;i<strlen(q);i++)             {                 uppercase=false;                 char c=q[i];                 if(c==' ' || c=='A' || c=='a' || c=='Q' || c=='q' || c=='Z' || c=='z')                 {                     switch(c)                         {                                 case 'A':c='L';break;                                 case 'a':c='l';break;                                 case 'Q':c='P';break;                                 case 'q':c='p';break;                                 case 'z':c='m';break;                                 case 'Z':c='M';break;                         }                         ans[i]=c;                 }                 else                 {                     if(c-97 < 0)                     {                         c+=32;                         uppercase=true;                     }                     int k1,k2,k3;                     k1=IndexOf(row1,c);                     k2=IndexOf(row2,c);                     k3=IndexOf(row3,c);                                          if(k1>0)                     c=row1[--k1];                     else if(k2>0)                     c=row2[--k2];                     else                     c=row3[--k3];                     if(uppercase==true)                     c-=32;                     ans[i]=c;                 }             }             ans[i]='\0';             cout<<ans<<endl;         }     return 0; }
#include<stdio.h> int main() { int i,j,a[3][3],b[3][3],k=15,m,n; for(m=0;m<3;m++) for(n=0;n<3;n++) { a[m][n]=0; } m=1; n=2; a[m][n]=k; for(i=0;i<3;i++) { 	while(m==n&&m,n<2) 	{ 	m++; 	n++; 	k++; 	a[m][n]=k; 	} 	if(m==2&&n==2) 	n--; 	if(m!=n&&n==2) 	{ 	if(m==0) 	{ 	k++; 	a[m][n]=k; 	n=n-2; 	m++; 	} 	else 	{ 	k++; 	m++; 	n=n-2; 	a[m][n]=k; 	} 	} 	if(m!=n&&n==0) 	{ 	if(m==1) 	{ 	k++; 	a[m][n]=k; 	} 	else 	{ 	m=m-2; 	n++; 	k++; 	a[m][n]=k; 	} 	} 	if(m!=n&&n==1) 	{ 	if(a[m][n]==0) 	{ 	k++; 	a[m][n]=k; 	m=m-2; 	n++; 	} 	else 	{ 	n--; 	k++; 	a[m][n]=k; 	} 	} } b[0][1]=a[1][2]; b[1][0]=a[0][1]; b[2][0]=a[0][0]; b[1][1]=a[1][1]; b[0][2]=a[2][2]; b[1][2]=a[2][1]; b[0][0]=a[0][2]; b[2][1]=a[1][0]; b[2][2]=a[2][0]; for(m=0;m<3;m++) { for(n=0;n<3;n++) printf(" ",a[m][n]); printf("\n"); } printf("\n"); for(m=0;m<3;m++) { for(n=0;n<3;n++) printf(" ",b[m][n]); printf("\n"); } printf("\n"); b[2][1]=a[1][2]; b[1][2]=a[0][1]; b[0][2]=a[0][0]; b[1][1]=a[1][1]; b[2][0]=a[2][2]; b[1][0]=a[2][1]; b[2][2]=a[0][2]; b[0][1]=a[1][0]; b[0][0]=a[2][0]; for(m=0;m<3;m++) { for(n=0;n<3;n++) printf(" ",b[m][n]); printf("\n"); } printf("\n"); b[1][0]=a[1][2]; b[2][1]=a[0][1]; b[2][2]=a[0][0]; b[1][1]=a[1][1]; b[0][0]=a[2][2]; b[0][1]=a[2][1]; b[2][0]=a[0][2]; b[1][2]=a[1][0]; b[0][2]=a[2][0]; for(m=0;m<3;m++) { for(n=0;n<3;n++) printf(" ",b[m][n]); printf("\n"); } return 0; } 
#include<iostream> #include<string.h> using namespace std; int main() {     char c[1000];     cin.getline(c,1000);     for(int i=0;i<strlen(c);i++)     {         char a=c[i]+1;         if(c[i]=='z')         cout<<"a";         else         cout<<a;     }     cout<<endl;     return 0; }
#include<iostream> #include<math.h> using namespace std;   int main() {     int n,k;     cin>>n>>k;     if(n==k || (n==1 && k==1))     cout<<"1"<<endl;     else     {         int c=n-k;         --n; --k;         long long int ans=1;         int big=max(k,c);         for(int i=big+1;i<=n;i++)         ans=ans*i;         for(int i=1;i<=min(k,c);i++)         ans=ans/i;         cout<<ans<<endl;     }     return 0; }
#include<algorithm> #include<iostream> #include<cstdio> #include<vector> #include<fstream> #include<iomanip> #include<bitset> #include<deque> #include<queue> #include<string> #include<map> #include<cstring> #include<sstream> #include<cmath> #include<cassert> using namespace std; #define MOD 10000  int divisors[500001];  int fpow(int a, int b) {     int x = 1, y = a;     while (b > 0)     {         if (b%2 == 1)         {             x = x*y;             x %= MOD;         }         y = y*y;         y %= MOD;         b >>= 1;     }     return x; }  int main() { 	memset(divisors, 0, sizeof divisors); 	for (int i = 1; i <= 500000; i++) 		for (int j = i; j <= 500000; j += i) 			divisors[j]++; 	int T, N; 	scanf("%d", &T); 	for (int t = 0; t < T; t++) 	{ 		scanf("%d", &N); 		if (N == 1) 		{ 			printf("1\n"); 			continue; 		} 		int fac = divisors[N]-2; 		bool exceed = 0; 		if ((fac&1) == 0) 		{ 			int ans = 1; 			int r = (fac>>1); 			if (N >= MOD && r >= 1) 				exceed = 1; 			else 			{ 				for (int i = 0; i < r; i++) 				{ 					ans = ans*N; 					if (ans >= MOD) 					{ 						exceed = 1; 						break; 					} 				} 			} 			if (exceed) 				printf("%04d\n", fpow(N%MOD, r)); 			else 				printf("%d\n", ans); 		} 		else 		{ 			int ans = (int)sqrt(N); 			int anss = ans; 			int r = ((fac-1)>>1); 			if (N >= MOD && r >= 1) 				exceed = 1; 			else 			{ 				for (int i = 0; i < r; i++) 				{ 					ans = ans*N; 					if (ans >= MOD) 					{ 						exceed = 1; 						break; 					} 				} 			} 			if (exceed) 				printf("%04d\n", (anss*fpow(N%MOD, r))%MOD); 			else 				printf("%d\n", ans); 		} 	} 	return 0; } 
    #include<iostream>     #include<cstdio>     using namespace std;     bool lp(int what_year){     bool bLeapYear = false;     if ((what_year % 4) ==0) {     if ((what_year % 100) == 0) {     bLeapYear = ((what_year % 400) == 0);     } else {     bLeapYear = true;     }     //bLeapYear = true;     }     /* if (what_year % 100 == 0 && what_year % 400 == 0)     bLeapYear = true;*/     return bLeapYear;     }     int main(){     int t,d,m,y,d1,m1,y1;     cin>>t;     while(t--){     cin>>d;     getchar();     cin>>m;     getchar();     cin>>y;     int st=0,st2=0;     if(d>31 || m>12)     cout<<"Invalid Date\n";     else if(m==2 && d>29)     cout<<"Invalid Date\n";     else{     if(!lp(y)){     if((m==2 && d>28) || ((m==1 || m==3 || m==5 || m==7 || m==8 || m==10 || m==12) && d>31) || ((m==4 || m==6 || m==9 || m==11) && d>30))     cout<<"Invalid Date\n";     else{     if(m==2)     d1=(d+1)%29;     else if(m==1 || m==3 || m==5 || m==7 || m==8 || m==10 || m==12)     d1=(d+1)%32;     else     d1=(d+1)%31;     if(d1==0)     d1=1;     m1=m;     if(d1==1)     m1=(m1+1)%13;     if(m1==0)     {     m1=1;     st=1;     }     y1=y;     if(st==1)     y1++;     cout<<d1<<"/"<<m1<<"/"<<y1<<endl;     }     }     else{     if((m==2 && d>29) || ((m==1 || m==3 || m==5 || m==7 || m==8 || m==10 || m==12) && d>31) || ((m==4 || m==6 || m==9 || m==11) && d>30))     cout<<"Invalid Date\n";     else{     if(m==2)     d1=(d+1)%30;     else if(m==1 || m==3 || m==5 || m==7 || m==8 || m==10 || m==12)     d1=(d+1)%32;     else     d1=(d+1)%31;     if(d1==0)     d1=1;     m1=m;     if(d1==1)     m1=(m1+1)%13;     if(m1==0)     {     m1=1;     st=1;     }     y1=y;     if(st==1)     y1++;     cout<<d1<<"/"<<m1<<"/"<<y1<<endl;     }     }     }     }     return 0;     } 
#include<bits/stdc++.h>  using namespace std;  int main() { 	int t,n,m,i,j,a[1009][1009],dp[1009][1009]; 	 	cin>>t; 	while(t--) 	{ 		cin>>n>>m; 		 		for(i=0;i<n;i++) 		{ 		 			for(j=0;j<m;j++) 			{ 				cin>>a[i][j]; 				dp[i][j]=INT_MAX; 			} 		} 		 		dp[0][0]=a[0][0];  		for(i=1;i<n;i++) 		{ 			dp[i][0]=a[i][0]+dp[i-1][0]; 		}  		for(j=1;j<m;j++) 		{ 			dp[0][j]=a[0][j]+dp[0][j-1]; 		}  		for(i=1;i<n;i++) 		{ 			for(j=1;j<m;j++) 			{ 				dp[i][j] = ( dp[i-1][j] < dp[i][j-1] ? ( dp[i-1][j] +a[i][j] ) : (dp[i][j-1]+a[i][j] )  ); 			} 		} 		cout<<dp[n-1][m-1]<<endl; 	} 	return 0; } 
#include <bits/stdc++.h> using namespace std; #define ll long long #define sz 1005 char maze[sz][sz]; int visited[sz][sz];  struct point{     int x,y; };  int bfs(point p,int n,int m) {     queue <point> q;     point t,r;     q.push(p);     visited[p.x][p.y]=1;     while(!q.empty())     {         t=q.front(); q.pop();         if(t.x-1>=0)         {             if(maze[t.x-1][t.y]!='#' && visited[t.x-1][t.y]==0){r.x=t.x-1; r.y=t.y; q.push(r); visited[r.x][r.y]=visited[t.x][t.y]+1;}         }         if(t.y-1>=0)         {             if(maze[t.x][t.y-1]!='#' && visited[t.x][t.y-1]==0){r.x=t.x; r.y=t.y-1; q.push(r);visited[r.x][r.y]=visited[t.x][t.y]+1;}         }         if(t.x+1<m)         {             if(maze[t.x+1][t.y]!='#' && visited[t.x+1][t.y]==0){r.x=t.x+1; r.y=t.y; q.push(r); visited[r.x][r.y]=visited[t.x][t.y]+1;}         }         if(t.y+1<n)         {             if(maze[t.x][t.y+1]!='#' && visited[t.x][t.y+1]==0){r.x=t.x; r.y=t.y+1; q.push(r); visited[r.x][r.y]=visited[t.x][t.y]+1;}         }         if(maze[t.x][t.y]=='E'){return visited[t.x][t.y]-1;}     }     return -1; } int main() {     memset(visited,0,sizeof(visited));     int n,m,i,j;     cin>>n>>m;     point start;     for(i=0;i<n;i++)     {         for(j=0;j<m;j++)         {             cin>>maze[i][j];             if(maze[i][j]=='S')             {                 start.x=i; start.y=j;             }         }     }     cout<<bfs(start,n,m);     return 0; } 
#include<iostream> using namespace std; int N,M; #define oo 100000000; int Matrix[1010][1010]; int visited[1010]; int Parent[1010]; long Distance[1010]; int index[1010]; template<class T> void Swap(T& a, T& b) {   T temp=b;   b=a;   a=temp; } void QuickSort(long Arr[],int left, int right) { 	long Mid=Arr[(left+right)/2]; 	int i=left; 	int j=right; 	while(i<=j) 	{ 	    while(Arr[i]<Mid) i++; 		while(Arr[j]>Mid) j--; 		if(i<=j) 		{ 			Swap(Arr[i],Arr[j]); 			Swap(index[i],index[j]); 			i++; 			j--; 		} 	 	} 	if(j>left) 		QuickSort(Arr,left,j); 	if(i<right) 		QuickSort(Arr,i,right); } int Mindis() { 	long Min=oo; 	int iMin=0; 	for(int i=1;i<=N;i++) 	{ 		if(!visited[i] && Min>Distance[i]) 		{ 			Min=Distance[i]; 			iMin=i; 		} 	} 	return iMin; } void prim() { 	Distance[1]=0; 	for(int i=1;i<=N;i++) 	{ 		int u= Mindis(); 		visited[u]=1; 		for(int i=1;i<=N;i++) 		{ 			if(!visited[i]&& Distance[i]>Matrix[u][i]) 			{ 				Distance[i]=Matrix[u][i]; 				Parent[i]=u; 			} 		} 	} } int main() { 	ios::sync_with_stdio(false); 	//freopen("input.txt","r",stdin); 	int T; 	cin>>T; 	for(int tc=0;tc<T;tc++) 	{ 		cin>>N>>M; 		for(int i=1;i<=N;i++) 		{ 			Distance[i]=oo; 			visited[i]=Parent[i]=0; 			for(int j=1;j<=N;j++) 				Matrix[i][j]=oo; 		} 		int x,y,z; 		for(int i=0;i<M;i++) 		{ 			cin>>x>>y>>z; 			Matrix[x][y]=z; 			Matrix[y][x]=z; 		} 		prim(); 		for(int i=1;i<=N;i++) 			index[i]=i; 		QuickSort(Distance,1,N); 		for(int i=1;i<=N;i++) 		{ 			if(!Distance[i]) 				continue; 			if(index[i]>Parent[index[i]] ) 				cout<<Parent[index[i]]<<" "<<index[i]<<" "<<Distance[i]<<endl; 			else 				cout<<index[i]<<" "<<Parent[index[i]]<<" "<<Distance[i]<<endl; 		} 		 	} 	return 0; }
#include<bits/stdc++.h> using namespace std;  typedef long long LL; LL dp[1000006]; int main() {     LL n, ans=0;     scanf("%lld", &n);     for(int i=0;i<n;i++)     {         int num;         scanf("%d", &num);         ans+=dp[num];         dp[num]++;     }     printf("%lld", ((n*(n-1))/2)-ans); } 
#include<stdio.h> #include<iostream> #include<vector> #include<queue> #include<algorithm> #include<sstream> #include<set> #include<map> #include<stack> #include<cmath> #include <map> #include<cstdlib> #include<cstring> #include<string> #include<set> #include<cassert> using namespace std;   #define DEBUG //on-off switch for prlling statements   // Input macros #define s(n)                        scanf("%d",&n) #define sc(n)                       scanf("%c",&n) #define sl(n)                       scanf("%lld",&n) #define sf(n)                       scanf("%lf",&n) #define ss(n)                       scanf("%s",n)   // Useful constants #define INF                        1000000000 #define EPS                         1e-14   // Useful hardware instructions #define bitcount                    __builtin_popcount #define gcd                         __gcd   // Useful container manipulation / traversal macros #define forall(i,a,b)               for(ll i=a;i<b;i++) #define foreach(v, c)               for( typeof( (c).begin()) v = (c).begin();  v != (c).end(); ++v) #define all(a)                      a.begin(), a.end() #define in(a,b)                     ( (b).find(a) != (b).end())  #define fill(a,v)                    memset(a, v, sizeof a) #define sz(a)                       ((ll)(a.size()))   // Some common useful functions #define maX(a,b)                     ( (a) > (b) ? (a) : (b)) #define miN(a,b)                     ( (a) < (b) ? (a) : (b))   #define ll long long int #define llu long long unsigned #define ld long #define mod 1000000007 #define F first #define S second #define pb push_back #define llu long long unsigned #define ld long ll ans[402]; ll dp[402][402][402]; ll wt[402]; ll c[402][402]; ll powval[402][402]; ll power(ll x,ll y) { 	if(y == 0) 	return 1; 	ll d=power(x,y/2); 	d=(d*d)%mod; 	if(y&1) 	{ 		d=(x*d)%mod; 	} 	return d; } ll divmodulo(ll num,ll den) { 	num=num%mod; 	den=power(den,mod-2); 	return (num*den)%mod; } ll mul(ll x,ll y) { 	return ((x%mod)*(y%mod))%mod; } ll ncr(ll n,ll r)// calculatencr { 	if(r == 0 || r==n) 	return n; 	ll num=1; 	ll den=1; 	for(int i=0;i<r;i++) 	{ 		num=(num*((n-i)%mod))%mod; 		den=(den*(i+1))%mod; 	} 	return divmodulo(num,den); 	 }  void calc(int x,ll k) { 	ll ans=0; 	ll y=wt[0]; 	ll val=divmodulo(((power(y,k+1)-1)%mod+mod)%mod,y-1); 	for(int j=0;j<=min((ll)400,k);j++) 	{ 	 		ll zero=k-j; 		ans=(ans+(val*dp[400][x][j]))%mod;  		val=divmodulo(((ncr(k+1,j+1)*power(y,k-j)-val)%mod+mod)%mod,y-1); 	} 	ans=((ans-dp[400][x][0])%mod+mod)%mod; 	printf("%lld\n",ans%mod); }  void preprocess()  { 	for(int i=0;i<=401;i++) 	{ 		powval[i][0] = 1; 		for(int j=1;j<=401;j++) 		{ 			powval[i][j] =( powval[i][j-1]*wt[i])%mod; 		} 	} 	fill(c,0); 	for(int i=0;i<=401;i++) 	{ 		c[i][0]= 1; 		c[i][i]=1; 	} 	for(int i=1;i<=401;i++) 	{ 		for(int j=1;j<i;j++) 		{ 			c[i][j] = (c[i-1][j] + c[i-1][j-1])%mod; 		 		} 	} } void solvedp() { 	dp[0][0][0]=1; 	for(int i=0;i<=400;i++) 	{ 		for(int j=0;j<=400;j++) 		{ 			for(int k=0;k<=j;k++) 			{  				int next=i+1; 				dp[next][j][k] =(dp[next][j][k]+dp[i][j][k] )%mod; 				int val=j; 				for(int l=1;l+k<=400;l++) 				{ 					val += next; 					if(val > 400) break; 					dp[next][val][k+l] = (dp[next][val][k+l]+((c[l+k][k]*powval[next][l])%mod)*dp[i][j][k])%mod; 		 				} 			} 		} 	} }  int main() { 	fill(wt,0); int n; 	ll k; 	s(n); 	sl(k); 	for(int i=0;i<n;i++) 	{ 		int x; 		s(x); 		wt[x]++; 	} 	preprocess(); 	solvedp(); 	assert(wt[0] != 1); 	int q; 	s(q); 	for(int i=0;i<q;i++) 	{ 		int x; 		s(x); 		if(wt[0] == 0) 		{ 			ll sum=0; 			for(int j=1;j<=min((ll)400,k);j++) 			{ 				sum=(sum+dp[400][x][j])%mod; 			} 			printf("%lld\n",sum%mod); 			continue; 		} 		calc(x,k); 	} }
#include <cstdio> #include <iostream> #include <vector> #include <set> #include <cstring> #include <map> #include <algorithm> #include <utility> #include <cmath> #include <stack> #include <queue> #include <sstream> #include <numeric> #include <iterator> using namespace std;  #define maX(a, b) ( (a) > (b) ? (a) : (b)) #define miN(a, b) ( (a) < (b) ? (a) : (b)) #define pb push_back #define mp make_pair #define fill(a, v) memset(a, v, sizeof a) #define tr(v, it) for(typeof((v).begin()) it = (v).begin(); it != (v).end();it++) #define sz(a) ((int)(a.size())) #define ff first #define ss second  const int INF = 1e9; const double eps = 1e-9; typedef long long lli;   lli N;  lli MOD;  vector<vector<lli> > v(31, vector<lli>(31)); vector<vector<lli> > zeros(31, vector<lli>(31));  void pre() {     for(lli i = 0;i < 31;i++) {         for(lli j = 0;j < 31;j++) {             v[i][j] = (i == j ? 1 : 0);             zeros[i][j] = 0;         }     }  }  vector<vector<lli> > add(vector<vector<lli> > v1, vector<vector<lli> > v2) {      for(lli i = 1;i <= N;i++) {         for(lli j = 1;j <= N;j++) {             v1[i][j] = (v1[i][j] + v2[i][j])%MOD;         }     }      return v1; }  vector<vector<lli> > mul(vector<vector<lli> > v1, vector<vector<lli> > v2) {     vector<vector<lli> > res(31, vector<lli> (31));     for(lli i = 1;i <= N;i++) {         for(lli j = 1;j <= N;j++) {             res[i][j] = 0;             for(lli k = 1;k <= N;k++) {                 res[i][j] = (res[i][j] + v1[i][k] * v2[k][j])%MOD;             }         }     }      return res; }  vector<vector<lli> > exp(vector<vector<lli> > base, long long p) {     vector<vector<lli> > ans = v;      while(p > 0) {         if(p&1)ans = mul(ans, base);         p >>= 1;         base = mul(base,base);     }     return ans; }  vector<vector<lli> > getGP(long long K, long long powOf2, vector<vector<lli> > r) {     if(K == 1) {         return v;     }      vector<vector<lli> > ans;      if(K&1) {         ans = exp(r, (K-1) * powOf2);     } else {         ans = zeros;     }      ans = add(ans, mul(add(v, exp(r, powOf2)), getGP(K/2, powOf2*2, r) ));     return ans; }    int main() {     pre();     MOD = 1000000007LL;     vector<vector<lli> > r;     r = zeros;      lli  M, K, a, b;     cin >> N >> M >>K;      for(int i = 0;i < M;i++) {         cin >> a >> b;         r[a][b]++;     }       vector<vector<lli> > tmp = getGP(K, 1, r);     tmp = mul(tmp,r);      lli Q;     cin >> Q;      while(Q--) {         cin >> a >> b;         cout << tmp[a][b] << endl;     }     return 0;  }         
#include <bits/stdc++.h> using namespace std; typedef long long LL;  const int MAXN = 1e6 + 9;  LL N,K; LL tim[MAXN];  inline bool isvalid(LL cur){ 	LL cnt = 0LL; 	for(int i = 0;i < K;++i) 		cnt += (cur / tim[i]);  	return (cnt >= N); }  int main (){    scanf("%lld %lld",&K,&N);     for(int i = 0;i < K;++i) 	 scanf("%lld",&tim[i]);     LL lo = 0,hi = 1e16;    while(lo < hi){    	 LL md = (lo + hi) >> 1;    	 if(isvalid(md)) hi = md;    	 else lo = md + 1;    }     printf("%lld\n",hi);    return 0; } 
// adijimmy #include <bits/stdc++.h> using namespace std; typedef long long int ll; const int mod = 1e9+7; #define REP(i, n) for (int i = 0; i < (int)(n); ++i) ll power(ll a,ll b){   ll res = 1;   while(b){     if(b&1) res = (res*a)%mod;     a = (a*a)%mod;     b >>= 1;   }   return res; } #define MAX 100005 ll degree[MAX]; int main(){   ll n,u,v;   scanf("%lld",&n);   for(ll i=0;i<n-1;i++){     scanf("%lld %lld",&u,&v);     u--; v--;     degree[u]++; degree[v]++;   }   ll res = n*(n-1)*(n-2)/6;   res -= (n-1)*(n-2);   for(ll i=0;i<n;i++){ 	res += (degree[i]*(degree[i]-1))/2;   }   cout << res << endl;   return 0; } 
#include<cstdio>  using namespace std;  typedef long long int int64;  int main() { 	int64 t, n, even, odd, temp; 	int64 ans; 	scanf("%lld",&t); 	while(t--) { 		even = 0; 		odd = 0; 		scanf("%lld",&n); 		for(int64 i = 0; i<n; i++) { 			scanf("%lld",&temp); 			if(temp%2) odd++; 			else even++; 		} 		ans = odd*even; 		ans += (even*(even-1))/2; 		printf("%lld\n",ans); 	} 	return 0; }
#include <bits/stdc++.h>  using namespace std;  #define pb push_back #define mp make_pair #define ll long long int #define s(x) scanf("%d", &x) #define sl(x) scanf("%lld", &x) #define mod 1000000007 #define get getchar_unlocked  int N;  struct node {     int x, ind; }seg[400005];  int a[100005]; int B[32][100005]; ll S[100005]; ll ans = 0;  void C_S_T(int l, int r, int ind) {     if (l == r) {         seg[ind].x = a[l];         seg[ind].ind = l;         return;     }     int m = (l+r)/2;     int p = 2*ind+1;     int q = p+1;     C_S_T(l, m, p);     C_S_T(m+1, r, q);     if (seg[p].x >= seg[q].x)         seg[ind] = seg[p];     else         seg[ind] = seg[q]; }  node getA(int x, int y, int l, int r, int ind) {     if (r < x || y < l) {         node A;         A.x = A.ind = -1;         return A;     }     if (x <= l && r <= y)         return seg[ind];     int m = (l+r)/2;     int p = 2*ind+1;     int q = p+1;     node A = getA(x, y, l, m, p);     node B = getA(x, y, m+1, r, q);     if (A.x >= B.x)         return A;     return B; }  void query(int l, int r) {     //cerr << l << " " << r << endl;     if (l >= r)         return;     int ind, l1, l2, i, r1, r2;     ll X, O1, O2, Z1, Z2;     node tmp = getA(l, r, 1, N, 0);     //cerr << "YES\n";     ind = tmp.ind;     l1 = l;     r1 = ind-1;     l2 = ind+1;     r2 = r;     for (i = 0; i < 25; ++i) {         X = (1 << i);         if (l1 <= r1) {             O1 = B[i][r1]-B[i][l1-1];             Z1 = r1-l1+1-O1;         }         else             O1 = Z1 = 0;         if (l2 <= r2) {             O2 = B[i][r2]-B[i][l2-1];             Z2 = r2-l2+1-O2;         }         else             O2 = Z2 = 0;         if (a[ind] & X) {             ans += (O1*O2*X);             ans += (Z1*Z2*X);         }         else {             ans += (O1*Z2*X);             ans += (O2*Z1*X);         }      //   cout << ans << endl;     }     if (l1 <= r1)         ans += S[r1]-S[l1-1];    // cout << ans << " ";     if (l2 <= r2)         ans += S[r2]-S[l2-1];     //cout << ans << endl;     query(l, ind-1);     query(ind+1, r); }  int main() {     int n, i, j;     s(n);     N = n;     for (i = 1; i <= n; ++i) {         s(a[i]);         S[i] = S[i-1]+a[i];         for (j = 0; j < 25; ++j) {             B[j][i] = B[j][i-1];             if (a[i] & (1 << j))                 ++B[j][i];         }     }     C_S_T(1, n, 0);     query(1, n);     cout << ans << endl;     return 0; } 
#include<bits/stdc++.h> using namespace std; #define ll long long int main() { 	ll t,i,k,x; 	cin>>t; 	while(t--) 	{ 		cin>>x; 		if(x==0) 		{ 			cout<<3<<endl; 		} 		else if(x==1) 		{ 			cout<<1<<endl; 		} 		else if(x%4==0) 		{ 			cout<<x<<endl; 		} 		else if(x%4==3) 		{ 			cout<<x-1<<endl; 		} 		else cout<<-1<<endl; 	} 	return 0; }
#include <iostream> #include <queue> using namespace std; #define S(n) scanf("%d",&n) #define FOR(i,a,s) for(int i=a;i<s;i++) struct node{     int data;     int fill; } arr[1001][1001]; struct hnode{     int x,y,val; }; struct CALess {      bool operator ()(hnode& lhs, hnode& rhs)      {          return lhs.val > rhs.val;      } }; void sink(int cr, int cc, int tr, int tc){     priority_queue<hnode, std::deque<hnode>, CALess> pq;      hnode cur;     hnode temp;     cur.val = arr[cr][cc].data;     cur.x = cr;     cur.y = cc;     pq.push(cur);     arr[cur.x][cur.y].fill = 1;     int x,y;     while(!pq.empty())     {         cur = pq.top();         pq.pop();         arr[cur.x][cur.y].fill = 2;         x = cur.x;         y = cur.y;         if(y-1 >= 0)         {             if(arr[x][y-1].fill == 0)             {                 arr[x][y-1].data += cur.val;                 temp.val = arr[x][y-1].data;                 temp.x = x;                 temp.y = y-1;                 pq.push(temp);                 arr[x][y-1].fill = 1;             }             else             {                 if(x-1>=0 && arr[x][y-1].fill == 2 && arr[x-1][y].fill == 0)                 {                     arr[x-1][y].data += cur.val;                     temp.val = arr[x-1][y].data;                     temp.x = x-1;                     temp.y = y;                     pq.push(temp);                     arr[x-1][y].fill = 1;                 }             }         }         if(y+1 < tc-x)         {             if(arr[x][y+1].fill == 0)             {                 arr[x][y+1].data += cur.val;                 temp.val = arr[x][y+1].data;                 temp.x = x;                 temp.y = y+1;                 pq.push(temp);                 arr[x][y+1].fill = 1;             }             else             {                 if(x-1>=0 && arr[x][y+1].fill == 2 && arr[x-1][y+1].fill == 0)                 {                     arr[x-1][y+1].data += cur.val;                     temp.val = arr[x-1][y+1].data;                     temp.x = x-1;                     temp.y = y+1;                     pq.push(temp);                     arr[x-1][y+1].fill = 1;                 }             }         }      }  } int main() {     int t = 1, n, k, h;     S(t);     FOR(i,0,t){          S(n);S(k);S(h);         FOR(j,0,k){             FOR(l,0,n-j){                 arr[j][l].data=0;                 arr[j][l].fill=0;             }         }         FOR(j,0,k){             FOR(l,0,n-j){                 S(arr[j][l].data);             }         }         sink(k-1, h-1, k, n);         int max = 0;         FOR(j,0,k){             FOR(l,0,n-j){                 if(max < arr[j][l].data)                     max = arr[j][l].data;             }         }         printf("%d\n",max);     }     return 0; } 
#include<bits/stdc++.h> #define mod 10000 #define ll long long int   using namespace std;  int stressfree[2002][2002],stressfull[2002][2002];  ll powmod(ll a,ll b)  {ll res=1;if(a>=mod)a%=mod;for(;b;b>>=1){if(b&1)res=res*a;if(res>=mod)res%=mod;a=a*a;if(a>=mod)a%=mod;}return res;}   long long int cat[1002];  int main() {  long long int t,n,m,x; cin>>t;  cat[0]=1; cat[1]=1;  for(int i=2;i<=1000;i++) {     for(int j=0;j<i;j++)     {         cat[i]+=cat[j]*cat[i-j-1];         cat[i]%=10000;     } }   while(t--) {     cin>>x;     cout<<cat[x-1]<<endl;  }   return 0; } 
#include <iostream>  using namespace std;  int main() {     int t, n, max_c, max_w, max_m, m, w, c;     scanf("%d", &t);     while (t--) {         scanf("%d %d %d %d", &n, &m, &w, &c);         max_c = 4 * n / 5;         if (max_c > c)             max_c = c;         max_w = 2 * (n - max_c) / 3;         if (max_w > w)             max_w = w;         max_m = n - max_w - max_c;         if (max_m > m)             max_m = m;         if (max_w > max_m * 2)             max_w = max_m * 2;         if (max_c > (max_w + max_m) * 4)             max_c = (max_w + max_m) * 4;         printf("%d %d %d\n", max_m, max_w, max_c);     }     return 0; } 
#include <iostream> #include <stdio.h>  using namespace std;  int main() {     long long t, n, powTwo;     scanf("%lld", &t);     while(t>0)     {         powTwo=1;         scanf("%lld", &n);         while(n/powTwo!=1)             powTwo*=2;         printf("%lld\n", powTwo);         t--;     }     return 0; } 
#include<bits/stdc++.h>  #define rep(i,n) for(int i=0;i<n;i++) #define ll long long #define pl(n) printf("%lld\n",n)  using namespace std;  int checkprime(int x) { 	int l=sqrt(x); 	 	if(x==1) 		return 0; 	if(x==2) 		return 1; 	 	for(int i=2;i<=l;i++) 		if(x%i==0) 			return 0; 	return 1; }  int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		string str; 		cin>>str; 		int len=str.length(); 		int freq[200]={0}; 		int maxfreq=-1; 		 		rep(i,len) 		{ 			freq[str[i]]++; 			if(freq[str[i]]>maxfreq) 				maxfreq=freq[str[i]]; 		} 		 		if(checkprime(maxfreq)==1) 		{ 			rep(i,200) 			if(freq[i]!=0 && (checkprime(freq[i])==1)) 			{ 				freq[i]-=freq[i]/2; 			} 		} 		 		else 		{ 			rep(i,200) 			if(freq[i]!=0 && (checkprime(freq[i])==0)) 				freq[i]-=freq[i]/2; 				 		} 		 		ll ans=0; 		rep(i,200) 			ans+=freq[i]; 		pl(ans); 	} 	return 0; } 
#include<bits/stdc++.h>  using namespace std;  int main() { 	int t; 	cin>>t; 	 	vector<string> v; 	 	for(int i=0;i<t;i++) 	{ 		string s; 		cin>>s; 		v.push_back(s); 	}	 	sort(v.begin(),v.end()); 	 	for(int i=0;i<t;i++) 	{ 		int j=i+1; 		int count=1; 		while(j<t && v[j]==v[i]) 		{ 			j++; 			count++; 		 		} 		 		cout<<v[i]<<" "<<count<<"\n";	 		i=j-1; 		 	} 	 	return 0; } 
#include<bits/stdc++.h> using namespace std;  int ex ,ey ,n ,i ,vrtx1 ,vrtx2 ,next;  struct vertex { 	int x ,y; }adj[1001];  long long dist(int x1 ,int y1 ,int x2 ,int y2) { 	return ((x1-x2) * (x1-x2) + (y1-y2) * (y1-y2));  } bool isvisited[1001]; long long min_dist[1001];  int main() { 	scanf("%d%d%d",&n,&ex,&ey);  	for(i = 1 ; i<=n ; ++i) { 		scanf("%d%d",&adj[i].x,&adj[i].y); 		min_dist[i] = dist(adj[i].x ,adj[i].y ,0 ,0); 	} 	adj[n+1].x = ex; adj[n+1].y = ey; 	min_dist[n+1] = ex*ex + ey*ey; 	long long min_prev = 1e10; 	next = 0; 	for(int index = 0 ; index <= n+1 ; ++index) { 		min_prev = 1e10; 		for(i = 0 ; i<=n+1 && !isvisited[next]; ++i) {  			min_dist[i] = min(min_dist[i] , min_dist[next] + dist(adj[next].x ,adj[next].y ,adj[i].x ,adj[i].y));  			//printf(" i = %d min_prev = %d min_dist[%d]=%lld vrtx1 = %d\n",i ,min_prev ,i ,min_dist[i] ,vrtx1);  			if(min_dist[i] < min_prev && !isvisited[i] && i!= next) {  				vrtx1 = i;  				min_prev = min_dist[i];  				//printf("to be next = %d min_prev = %lld i = %d\n",i,min_prev,i);  			}  		} 		//printf("next = (%d,%d)\n",adj[next].x ,adj[next].y); 		isvisited[next] = 1; 		next = vrtx1; 	} 	printf("%lld\n",min_dist[n+1]); 	return 0;	 }
#include<bits/stdc++.h> #define pb push_back #define mp make_pair using namespace std; inline int scan(){     int x=0;     char c = getchar_unlocked();     while(c<'0'||c>'9'){         c=getchar_unlocked();     }     while(c>='0'&&c<='9'){         x = (x<<3) + (x<<1) + c - '0';         c=getchar_unlocked();     }     return x; } class bit2d{     int n;     int m;     long long  **bit1;     long long **bit2;     long long **bit3;     long long **bit4;     void update(long long **bit,int x,int y,long long val){         for(int i=x;i<=n;i+=i&-i){             for(int j=y;j<=m;j+=j&-j){                 bit[i][j]+=val;             }         }     }          long long query(long long **bit,int x,int y){         long long res=0;         for(int i=x;i;i&=i-1){             for(int j=y;j;j&=j-1){                 res+=bit[i][j];             }         }         return res;     }     long long query(int x,int y){         return query(bit1,x,y)*x*y + query(bit2,x,y)*x + query(bit3,x,y)*y + query(bit4,x,y);     }     public:     void init(int sz,int zs){         n=sz;         m=zs;         bit1 = new long long* [n+1];         bit2 = new long long* [n+1];         bit3 = new long long* [n+1];         bit4 = new long long* [n+1];         for(int i=0;i<=n;++i){             bit1[i] = new long long [m+1];             bit2[i] = new long long [m+1];             bit3[i] = new long long [m+1];             bit4[i] = new long long [m+1];         }     }     void update(int x1,int y1,int x2,int y2,long long val){         update(bit1,x1,y1,val);         update(bit1,x1,y2+1,-val);         update(bit1,x2+1,y1,-val);         update(bit1,x2+1,y2+1,val);         update(bit2,x1,y1,-val*(y1-1));         update(bit2,x1,y2+1,val*y2);         update(bit2,x2+1,y1,val*(y1-1));         update(bit2,x2+1,y2+1,-y2*val);         update(bit3,x1,y1,-val*(x1-1));         update(bit3,x1,y2+1,val*(x1-1));         update(bit3,x2+1,y1,val*x2);         update(bit3,x2+1,y2+1,-x2*val);         update(bit4,x1,y1,(x1-1)*(y1-1)*val);         update(bit4,x1,y2+1,-y2*(x1-1)*val);         update(bit4,x2+1,y1,-x2*(y1-1)*val);         update(bit4,x2+1,y2+1,x2*y2*val);     }     long long query(int x1,int y1,int x2,int y2){         return query(x2,y2) - query(x1-1,y2) - query(x2,y1-1) + query(x1-1,y1-1);     } }; bit2d mybit; int main(){     //freopen("input.txt","r",stdin);     //freopen("output.txt","w",stdout);     int n=scan(),m=scan();     mybit.init(n,m);     for(int i=1;i<=n;++i){         for(int j=1;j<=m;++j){             mybit.update(i,j,i,j,scan());         }     }     int q=scan();     while(q--){         int type=scan(),x1=scan(),y1=scan(),x2=scan(),y2=scan();         if(type&1){             int val=scan();             mybit.update(x1,y1,x2,y2,val*1LL);         }         else{             printf("%lld\n",mybit.query(x1,y1,x2,y2));         }     } }
#include <bits/stdc++.h> using namespace std; // my sincerest thanks to e-maxx for sharing his fft implementation // fft implementation nicked from e-maxx.ru/algo double PI = 3.14159265359; typedef complex<double> base;   void fft (vector<base> & a, bool invert) { 	int n = (int) a.size();     //cout<<n<<endl; 	for (int i=1, j=0; i<n; ++i) { 		int bit = n >> 1; 		//cout<<j<<" "<<bit<<endl; 		for (; j>=bit; bit>>=1) 			{ 				j -= bit; 				//cout<<j<<" hi "<<bit<<endl; 			} 		j += bit; 		//cout<<i<<" bye "<<j<<endl; 		if (i < j) 			swap (a[i], a[j]); 	}   	for (int len=2; len<=n; len<<=1) { 		double ang = 2*PI/len * (invert ? -1 : 1); 		base wlen (cos(ang), sin(ang)); 		for (int i=0; i<n; i+=len) { 			base w (1); 			for (int j=0; j<len/2; ++j) { 				base u = a[i+j],  v = a[i+j+len/2] * w; 				a[i+j] = u + v; 				a[i+j+len/2] = u - v; 				w *= wlen; 			} 		} 	} 	if (invert) 		for (int i=0; i<n; ++i) 			a[i] /= n; } void squarer (const vector<int> & a,  vector<int> & msd) { 	vector<base> fa (a.begin(), a.end()); 	size_t n = 1; 	while (n < a.size())  n <<= 1; 	n <<= 1; 	fa.resize (n);   	fft (fa, false); 	for (size_t i=0; i<n; ++i) 		fa[i] *= fa[i]; 	fft (fa, true);   	msd.resize (n); 	for (size_t i=0; i<n; ++i) 		{ 			msd[i] = int (fa[i].real() + 0.5); 			//cout<<res[i]<<endl; 		} } int main() { 	int n,x; 	scanf("%d", &n); 	vector <int> poly(200001,0); 	poly[0]=1; 	for (int i = 0; i < n; ++i) 	{ 		scanf("%d", &x); 		poly[x]=1; 	} 	vector <int> ans; 	squarer(poly, ans); 	int m; 	scanf("%d", &m); 	int fans=0; 	while(m--) 	{ 		scanf("%d", &x); 		if(ans[x]) 			fans++; 	} 	printf("%d\n", fans); 	return 0; }
#include<stdio.h> #define s(x) scanf("%lld",&x) #define M 1000000007 typedef long long int ll; ll f(ll a,ll b,ll c) {  ll ans=1 ;                              while(b !=0 ) {                  if(b%2 == 1) {                           ans = ans*a ;                ans = ans%c;                  }    a = a*a;                     a %= c;                       b /= 2;                 } return ans; } int main() { 	ll t; 	s(t); 	while(t--) 	{ 		ll z,n;  		s(n); 		z=f(2,n,M); 		//if(z>0) 		printf("%lld\n",z-1); 		//else 	} 	return 0; }
#include<bits/stdc++.h> using namespace std;  vector<int> a[100005]; bool visited[100005]; int vertices;  void DfsInit() { 	for(int i=1;i<=vertices;i++) 	{ 		a[i].clear(); 		visited[i]=false; 	}	 } void addEdge(int v,int val) { 	a[v].push_back(val); 	a[val].push_back(v); }  int DFS(int v) { 	visited[v]=true; 	int s=1; 	 	for(int i=0;i<a[v].size();i++) 	{ 		if(!visited[a[v][i]]) 		{ 			s+=DFS(a[v][i]); 		} 	} 	return s; }  int main() { 	int t,n,k,x,y; 	cin>>t; 	while(t--) 	{ 		int ans=0; 		cin>>n; 		cin>>k; 		vertices = n; 		DfsInit(); 		for(int i=0;i<k;i++) 		{ 			cin>>x; 			cin>>y; 			addEdge(x,y); 		} 		for(int i=1;i<=n;i++) 		{ 			if(!visited[i]) 			{ 				if(!(DFS(i)&1)) 				ans++; 			} 		} 		cout<<ans<<endl; 	} 	return 0; } 
#include<stdio.h> #define s(x) scanf("%lld",&x) #define M 1000000007 typedef long long int ll; ll f(ll a,ll b,ll c) {  ll ans=1 ;                              while(b !=0 ) {                  if(b%2 == 1) {                           ans = ans*a ;                ans = ans%c;                  }    a = a*a;                     a %= c;                       b /= 2;                 } return ans; } int main() { 	//ll t; 	//s(t); 	ll a,b,c; 	s(a);s(b);s(c); 	while((a!=-1)||(b!=-1)||(c!=-1)) 	{ 		ll z;  		 		if(b==0&&c==0) 		z=0; 		else 		{ 		   z=f(b,c,M-1); 		} 		if(a==0&&z==0) 		z=0; 		else      	{ 		z=f(a,z,M);} 		//if(z>0) 		printf("%lld\n",z); 		//else 		s(a);s(b);s(c); 	} 	return 0; }
#include <bits/stdc++.h> using namespace std; const int N = 1e5 + 5; vector < int > tree[N]; set < int > dist[N]; int a[N]; int ptr[N]; int n , m , u , v; void UNION(set < int > & s1 , set < int > & s2){     for(set < int > :: iterator it = s1.begin(); it != s1.end(); ++it) s2.insert(*it); } long long cut = 0; void dfs(int node , int parent){     dist[node].insert(a[node]);     int pt = node;     for(int i = 0; i < tree[node].size(); ++i){         int child  = tree[node][i];         if(child != parent){             dfs(child , node);         if(dist[pt].size() >= dist[ptr[child]].size()){            UNION(dist[ptr[child]] , dist[pt]);         }else{             UNION(dist[pt] , dist[ptr[child]]);             pt = ptr[child];         }         }     }     ptr[node] = pt;     cut += dist[pt].size(); } long long get(int node , int par){     long long ret = dist[ptr[node]].size();     for(int i = 0; i < tree[node].size(); ++i){         if(tree[node][i] != par){             ret += get(tree[node][i] , node);         }     }    // cout << "Subarray rooted at : " << node << " = " << ret << endl;     return ret; } int main() {     ios_base :: sync_with_stdio(false);     cin.tie(NULL);     cin >> n >> m;     for(int i = 1; i <= n - 1; ++i){         cin >> u;         tree[u].push_back(i + 1);     }     for(int i = 1; i <= n; ++i) cin >> a[i];     dfs(1 , -1);     long long ans = get(1 , -1);     cout << cut << endl;     return 0; } 
#include<bits/stdc++.h> #define FOR(i,a,n) for(int i=a;i<n;i++) #define si(x) scanf("%d",&x) #define sll(x) scanf("%lld",&x) #define ss(x) scanf("%s",x) #define pi(x) printf("%d\n",x) #define pll(x) printf("%lld\n",x) #define ps(x) printf("%s\n",ch) #define all(x) (x).begin(),(x).end() #define M 1000000007 #define ll long long #define mp make_pair #define pb push_back #define fr first #define se second using namespace std; int block,cnt[1000069],arr[200069],n,m,k; ll ans[200069],tot=0; bool cmp(pair<int,pair<int,int> > l,pair<int,pair<int,int> > r) {     if(l.fr/block==r.fr/block)         return l.se.fr<r.se.fr;     return l.fr<r.fr; } void add(int x) {     tot+=(1LL*2*cnt[arr[x]]+1)*arr[x];     cnt[arr[x]]++;     //tot+=1LL*cnt[arr[x]]*cnt[arr[x]]*arr[x];    // cout<<arr[x]<<"add"<<cnt[arr[x]]<<"\n"; } void del(int x) {     tot-=(1LL*2*cnt[arr[x]]-1)*arr[x];     cnt[arr[x]]--;     //tot+=1LL*cnt[arr[x]]*cnt[arr[x]]*arr[x];     //cout<<arr[x]<<"del"<<cnt[arr[x]]<<"\n"; } int main() {     si(n),si(m);     FOR(i,1,n+1)         si(arr[i]);     block=569;     vector<pair<int,pair<int,int> > > q;     FOR(i,0,m)     {         int x,y;         si(x),si(y);         q.pb(mp(x,mp(y,i)));     }     sort(all(q),cmp);     int mor=0,mol=1;     FOR(i,0,q.size())     {         int ql=q[i].fr;         int qr=q[i].se.fr;         int in=q[i].se.se;         while(ql<mol)             add(--mol);         while(ql>mol)             del(mol++);         while(qr>mor)             add(++mor);         while(qr<mor)             del(mor--);       //  puts("");         ans[in]=tot;     }     FOR(i,0,q.size())         pll(ans[i]); 	return 0; } 
#include <iostream> #include <bits/stdc++.h> using namespace std;  int main() {     long long int t,i,a,b,c,k;     float ans;     scanf("%lld",&t);     for(i=1;i<=t;i++){         scanf("%lld%lld%lld%lld",&a,&b,&c,&k);         if(c>=k)           printf("0\n");         else {             c=c-k;             ans=ceil((-b+sqrt((b*b)-(4*a*c)))/(2*a));             printf("%.0f\n",ans);         }       } 	// your code goes here 	return 0; } 
#include <bits/stdc++.h> #define ll long long using namespace std; ll fact[12]; int main() {     int t;     fact[0]=1;     for(int i=1;i<=11;i++)         fact[i]=i*fact[i-1];     scanf("%d",&t);     while(t--){         char s[15];         scanf("%s",s);         int c=0;         int l=strlen(s);         for(int i=0;i<l;i++)             if(s[i]>='a' && s[i]<='z')                 c++;         printf("%lld\n",fact[c]);     }     return 0; } 
#include <bits/stdc++.h>  using namespace std; int main() {     int t;     scanf("%d",&t);     while(t--){         int n,m;         scanf("%d%d",&n,&m);         if(m<n){             printf("%d\n",n-m);         }         else{             int c=0;             while(m>n){                 if(m%2==1){                     c++;                     m++;                 }                 m/=2;                 c++;             }             printf("%d\n",c+n-m);         }     }     return 0; } 
#include <bits/stdc++.h>  using namespace std; int dp[1001][1001]; int arr[1005]; int n; int solve(int l,int r) {     if(l>r)         return 0;     if(dp[l][r]!=-1) return dp[l][r];     int ans1=0,ans2=0;     if(r-1>=0 && arr[l]<arr[r-1])          ans1=solve(l,r-2)+arr[r];     else ans1=solve(l+1,r-1)+arr[r];     if(l+1 < n && arr[l+1]>arr[r])             ans2=solve(l+2,r)+arr[l];     else ans2=solve(l+1,r-1)+arr[l];     return dp[l][r]=max(ans1,ans2); } int main() {     int t;     scanf("%d",&t);     while(t--){         memset(dp,-1,sizeof(dp));         int i;         scanf("%d",&n);         int sum=0;         for(i=0;i<n;i++){             scanf("%d",&arr[i]);             sum+=arr[i];         }         int ans=solve(0,n-1);         //cout<<ans<<"  "<<sum<<endl;         int diff=ans-(sum-ans);         if(diff>=0)             printf("1 %d\n",diff);         else printf("2 %d\n",-diff);     }     return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { long long int t; cin>>t; while(t--) { long long int i,n,k; cin>>n>>k; int a[n],sum=0; for(i=0;i<n;i++) { cin>>a[i]; } sort(a,a+n); int count=0; for(i=n-1;i>=0;i--) {     count++; if(count>=k+1) sum+=a[i]; } cout<<sum<<endl; } return 0; }
#include <bits/stdc++.h> using namespace std; //MACROS #define ui unsigned int #define ll long long #define ull unsigned ll #define ld long double #define db double #define pb push_back #define mp make_pair #define pii pair<int,int> #define pll pair<ll , ll> #define pil pair<int,ll> #define F first #define S second #define ff first #define ss second #define vi vector<int> #define vii vector< pii > #define vll vector< ll > #define mii map<int,int> #define mll map<ll,ll> #define mil map<int,ll> #define mli map<ll,int> #define si set<int> #define sll set<ll> #define vvi vector< vi > #define vvl vector< vll > #define vpll vector< pll > #define mod 1000000007 const int maxn = 1e5+100; int tot[maxn]; vi divisors[maxn]; int factor[maxn]; int fib[maxn]; void pre() { 	fib[0] = 0; 	fib[1]=1; 	for(int i = 2;i<maxn;i++) 	{ 		fib[i]=fib[i-1]+fib[i-2]; 		if(fib[i]>=mod) 			fib[i]-=mod; 	} 	memset(factor,0,sizeof factor); 	for(int i = 2;i*i<maxn;i++) 	{ 		if(!factor[i]) 		{ 			for(int j = i*i;j<maxn;j+=i) 			{ 				factor[j] = i; 			} 		} 	} 	for(int i = 1;i<maxn;i++) 	{ 		for(int j = i;j<maxn;j+=i) 		{ 			divisors[j].pb(i); 		} 	} 	tot[1]=1; 	for(int i = 2;i<maxn;i++) 	{ 		if(factor[i] == 0) 		{ 			tot[i] = i-1; 			continue; 		} 		int x = factor[i],y = i/x; 		if(y%x == 0) 		{ 			tot[i] = x*tot[y]; 		} 		else 		{ 			tot[i] = (x-1)*tot[y]; 		}  	} } int ans(int n) { 	n++; 	int ret = mod-1; 	for(int i = 0;i<divisors[n].size();i++) 	{ 		int d = divisors[n][i]; 		int num = tot[n/d]; 		ret += (num*1ll*fib[d])%mod; 		if(ret>=mod) 			ret-=mod; 	} 	return ret; } int main() { 	pre(); 	int t,n; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d",&n); 		printf("%d\n",ans(n)); 	} 	return 0; } 
#include<iostream> #include<limits.h> using namespace std; int main() { 	long long int i,j,k,t,n,q; 	long long int a[100000]; 	cin>>n>>q; 	long long int min=INT_MAX,max=INT_MIN; 	for(i=0;i<n;i++) 	{ 		cin>>a[i]; 		if(a[i]>max) 			max=a[i]; 		if(a[i]<min) 			min=a[i]; 	} 	for(i=0;i<q;i++) 	{ 		cin>>t; 		if((t<=max)&&(t>=min)) 			cout<<"Yes"<<endl; 		else 			cout<<"No"<<endl; 	}  }
/* theCodeGame */ //{{{ #include<iostream> #include<algorithm> #include<cmath> #include<climits> #include<vector> #include<list> #include<stack> #include<queue> #include<deque> #include<stack> #include<bitset> #include<set> #include<cstdlib> #include<cstdio> #include<cstring> #include<ctime> #include<map> #include<functional> #include<numeric> #include<utility> #include<sstream> #include<iomanip> #include<cctype> //#undef thecodegame #ifdef thecodegame     #include<debug.h> #else     #define DBG_ARR(a,b,c) {}     #define DBG_MAT(a,s,b,c) {}     #define DBG_VECT(a) {}     #define db(...) {}     #define dbt(x, ...) {} #endif  using namespace std;  #define assert(f) {if(!(f)){fprintf(stderr,"Line-->%d  Assertion failed: %s \n",__LINE__,#f);exit(1);}} #define MOD 	 1000000007LL #define LL 		 long long #define ULL      unsigned long long #define ABS(x)   ((x)<0?-(x):(x)) #define SQR(x) 	 ((x)*(x)) #define CUBE(x)  ((x)*(x)*(x)) #define SD(n)    scanf("%d",&n) #define SD2(n,m) scanf("%d %d",&n,&m) #define SLL(n)   scanf("%LLd",&n) #define SLU(n)   scanf("%LLu",&n) #define SS(n)    scanf("%s",n) #define pnl      printf("\n") #define REP(i,n)        for(__typeof(n) i=0;i<(n);i++) #define FOR(i,a,b)      for(__typeof(b) i=(a);i<(b);++i) #define FORE(i,a,b)     for(__typeof(b) i=(a);i<=(b);++i) #define FORD(i,a,b,d)   for(__typeof(b) i=(a);i<(b);i+=(d)) #define FORR(i,n,e)     for(__typeof(n) i=(n);i>=(e);--i) #define FORRD(i,n,e,d)  for(__typeof(n) i=(n);i>=(e);i-=(d)) #define REP_IT(it,m)    for(it=m.begin();it!=m.end();it++) #define FORI(it,s) 	    for(__typeof((s).begin()) (it)=(s).begin();(it)!=(s).end();(it)++) #define FOREACH(it, X)  for(__typeof((X).begin()) it = (X).begin(); it != (X).end(); ++it) #define UNIQUE(v)       sort(ALL(v)),v.erase(unique(ALL(v)),v.end()) #define FILL(a,b)       memset(a,b,sizeof(a)) #define ALL(v)          (v).begin(), (v).end() #define RALL(v)         (v).rbegin(), (v).rend() #define checkbit(n,b)    ( ((n) >> (b)) & 1) #define pb push_back #define mp make_pair #define XX first #define YY second  const double PI=acos(-1.0); const double EPS=1e-11; template<typename T>inline T mod(T N,T M){return (N%M+M)%M;} template<typename T>inline void checkmin(T &a,T b){if(b<a)a=b;} template<typename T>inline void checkmax(T &a,T b){if(b>a)a=b;} class minHeap{public:bool operator()(int& c1,int& c2){return c1>c2;}}; class maxHeap{public:bool operator()(int& c1,int& c2){return c1<c2;}}; #ifdef amy     #define getcx getchar #else     #define getcx getchar_unlocked #endif inline void inp(int &n){     n=0;int ch=getcx();int sign=1;     while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}     while(  ch >= '0' && ch <= '9' ){n = (n<<3)+(n<<1) + ch-'0', ch=getcx();}     n=n*sign; }  //}}} #define SIZE 20 #define MAXX 100000009  vector<int>v; vector<int> ::iterator it; int N; void precompute(){     for(int i=0;i<=6;i++){         for(int j=0;j<(1<<6);j++){             int x = j;             int cnum =0;             for(int k=0;k<i;k++){                 cnum*= 10;                 cnum += ((x&1)*2+1);                 x >>=1;             }             v.pb(cnum);             db(cnum);         }     }     UNIQUE(v); }//end precompute  void doThis(int cc){     SD(N);     it = upper_bound(v.begin(),v.end(),N+1);     it --;     cout<<*it<<endl;  }//end solve  int main(){ #ifdef amy 	freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\out.txt","w",stderr); #endif precompute(); int cases = 1; scanf("%d",&cases); FORE(i,1,cases){doThis(i);} #ifdef amy 	fprintf(stdout,"\nTIME: %.3lf sec\n",(double)clock()/(CLOCKS_PER_SEC)); #endif return 0; }//end main 
# include <iostream> # include <stdio.h> # include <stack> # include <queue> # include <vector> # include <algorithm> # include <climits> using namespace std;  # define rep(n) for (int i = 0; i < n; i++) typedef unsigned long long ll; typedef long l; typedef vector<int> vi; typedef vector <vi > vvi; typedef pair<int,int> Pi;  # define S(x) scanf ("%d", &x) # define Sl(x) scanf ("%ld", &x) # define Sll(x) scanf ("%lld", &x)  # define  pb push_back # define all(X) X.begin(), X.end()  ll ar[10000003]; ll finalans; ll finalpos; int main () { 	//ios_base::sync_with_stdio(false); 	ll t; 	ll n; 	ll temp = 0; 	cin >> t; 	while (t--) { 		ll ans = 0; 		finalans = ULLONG_MAX; 		finalpos = -1; 		cin >> n;  		for (ll i = 1; i <= n; i++) { 			cin >> ar[i]; 			ans = ans ^ ar[i]; 		} 		if (ans != 0 ) { 		for (ll i = 1; i <= n; i++) { 			if ((ans ^ ar[i]) < ar[i]) { 				finalans = min (ar[i] - (ans ^ ar[i]), finalans); 				finalpos = i; 			} 		} 		} 		 		if (ans == 0) 			cout <<"NO\n"; 		else 			cout <<"YES"<<" "<<finalpos << " " << finalans <<"\n"; 	} 	return 0;  } 		 
// RANBOT // 4N+1 // 4N+3 FOR A NUMBER TO BE REPREESENT AS SUM OF TWO NUMBERS IT SHUD IN THE FORM OF EVEN POWER OF (4N+3) PRIMES #include<iostream> #include<vector> #include<set> #include<map> #include<queue> #include<stack> #include<string> #include<algorithm> #include<functional> #include<iomanip> #include<cstdio> #include<cmath> #include<limits.h> #include<cstring> #include<cstdlib> #include<cfloat> #include<cassert> #define maxm(a,b) a>b?a:b; #define minm(a,b) a<b?a:b; using namespace std; //M lazy ;) typedef long long ll; typedef vector <int> vi; typedef pair< int ,int > pii; typedef istringstream iss; typedef ostringstream oss; typedef map<int,int> mp; #define pb push_back #define mp make_pair #define ff first #define ss second #define sz size() #define ln length() #define rep(i,n) for(int i=0;i<n;i++) #define fu(i,a,n) for(int i=a;i<=n;i++) #define fd(i,n,a) for(int i=n;i>=a;i--) #define all(a)  a.begin(),a.end() #define ESP (1e-9) #define gi(n) scanf("%d",&n) #define gl(n) cin >> n #define pi(n) printf("%d",n) #define pl(n) cout << n #define ps printf(" ") #define pn printf("\n") #define dg(n,s); printf("%s %d",s,n) #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min() #define traverse_map(a,b) for(mp::iterator it=a;it!=b;++it) #define MOD 1000000007 #define MAX 1000001 #define cases() int t; cin>>t; while(t--) // fast input function #define getcx getchar_unlocked // fast input function #ifdef ONLINE_JUDGE  inline void inp( int &n )  {     n=0;     int ch=getcx();int sign=1;     while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )             n = (n<<3)+(n<<1) + ch-'0', ch=getcx();     n=n*sign;   } #else inline void inp(int &n){  cin>>n; } #endif int Check(ll num){  ll k=num;  if(num==1)  return 0;   for(ll i=2;i<=sqrt(num);i++){ 		if(k%i==0) 		 return 0;  }   if(num%4==3)  return 0;   return 1; } int main(){  int t;  inp(t);  ll a,b,i;  while(t--){   cin>>a>>b;    ll count=0;    for(i=a;i<=b;i++)    if(Check(i)) 	count++; 	 	cout<<count<<endl;  }  return 0; } 
#include <bits/stdc++.h> #define f(i,x,y) for (int i = x; i < y; i++) #define fd(i,x,y) for(int i = x; i>= y; i--) #define FOR(it,A) for(typeof A.begin() it = A.begin(); it!=A.end(); it++) #define all(v) (v).begin(), (v).end() #define rall(v) (v).rbegin(), (v).rend() #define vint vector<int> #define ll long long #define clr(A,x) memset(A, x, sizeof A) #define pb push_back #define pii pair<int,int> #define fst first #define snd second #define ones(x) __builtin_popcount(x) #define cua(x) (x)*(x) #define eps (1e-9) #define oo (1<<30) #define debug(x) cout <<#x << " = " << x << endl #define adebug(x,n) cout <<#x<<endl; f(i,0,n)cout<<x[i]<<char(i+1==n?10:32) #define mdebug(x,m,n) cout <<#x<<endl; f(i,0,m)f(j,0,n)cout<<x[i][j]<<char(j+1==n?10:32) #define N 105 using namespace std;  int shift(int *s,int n){ 	int i = 0, j = 1, k = 0; 	int a,b; 	while( j<n && i+k+1<n ){ 		a = s[i+k]; b = s[(j+k)%n]; 		if( a==b ) k++; 		else if( a<b ) j=j+k+1, k = 0; 		else i = max(i+k+1,j), j = i+1, k = 0; 	} 	return i; } void unif(int *s, int n) { 	int i = shift(s, n); 	int t[n]; 	f(j,0,n) { 		t[j] = s[i]; 		i++; 		if (i == n) i = 0; 	} 	f(j,0,n) s[j] = t[j]; } int s[N], n; int r[N]; bool orden(int i, int j) { 	int tmp = s[i] - s[j]; 	if (tmp) return tmp < 0; 	return i < j; } void mapear(int t[N]) { 	f(i,0,n) r[i] = i; 	sort(r, r + n, orden); 	for (int i = 0, j = 0; i < n; i = j) { 		for (; j < n && s[r[i]] == s[r[j]]; j++) ; 		f(k,i,j) t[r[k]] = k+1==j? n + r[i] - r[k] : r[k+1] - r[k]; 	} } int lista[10005][N];  int main(){ 	int tc, m; 	cin >> tc;	 	while (tc--) { 		cin >> m >> n; 		f(i,0,m) { 			f(j,0,n) scanf("%d", s + j); 			mapear(lista[i]); 			unif(lista[i], n); 		} 		vector<pair<ll, ll> > v; 		ll m1 = 1e9+7, m2 = m1 + 2; 		f(i,0,m) { 			ll h1 = 0, h2 = 0; 			f(j,0,n) h1 = (101*h1 + lista[i][j]) % m1; 			f(j,0,n) h2 = (101*h2 + lista[i][j]) % m2; 			v.pb(pii(h1, h2)); 		} 		sort(all(v)); 		cout << unique(all(v)) - v.begin() << endl; 	} }  
#include<iostream> #include<bits/stdc++.h> #include<stdio.h> #include<string>  #define lld long long int #define d int using namespace std;  void display(lld res) {      while(res>9)         res=res%10;     switch(res)                 {                     case 1:  cout<<"one ";                     break;                     case 2:  cout<<"two ";                     break;                     case 3:  cout<<"three ";                     break;                     case 4:  cout<<"four ";                     break;                     case 5:  cout<<"five ";                     break;                     case 6:  cout<<"six ";                     break;                     case 7:  cout<<"seven ";                     break;                     case 8:  cout<<"eight ";                     break;                     case 9:  cout<<"nine ";                     break;                     case 0:  cout<<"zero ";                     break;                 } } int main() {     lld t,num1,num2,temp1,i,jtemp2,res;     char ch;     lld n1[10000];     lld n2[10000];     cin>>t;     while(t--)     {             cin>>num1>>num2>>ch;             lld i=0;             lld j=0,x;             while(num1!=0)             {                 n1[i]=num1%10;                 i++;                 num1/=10;             }          //   for(x=0; x<i; x++)          //       cout<<n1[x];             while(num2!=0)             {                 n2[j]=num2%10;                 j++;                 num2/=10;             }         //    for(x=0; x<j; x++)         //        cout<<n2[x];             if(ch=='+')             {                 for(i=j-1; i>=0; i--)                 {                     res=n1[i]+n2[i];                     display(res%10);                 }             }             else             {                  for(i=j-1; i>=0; i--)                 {                     res=n1[i]*n2[i];                     display(res%10);                 }             }             cout<<endl;     }     return 0; } 
#include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<string> #include<iostream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath> #include<string>   using namespace std;   #define s(n)					scanf("%d",&n) #define sl(n) 					scanf("%lld",&n) #define sf(n) 					scanf("%lf",&n) #define ss(n) 					scanf("%s",n) #define INF						(int)1e9 #define LINF					(long long)1e18 #define EPS						1e-9 #define maX(a,b)				((a)>(b)?(a):(b)) #define miN(a,b)				((a)<(b)?(a):(b)) #define abS(x)					((x)<0?-(x):(x)) #define FOR(i,a,b)				for(int i=a;i<b;i++) #define REP(i,n)				FOR(i,0,n) #define foreach(v,c)            for( typeof((c).begin()) v = (c).begin();  v != (c).end(); ++v) #define mp						make_pair #define FF						first #define SS						second #define tri(a,b,c)				mp(a,mp(b,c)) #define XX						first #define YY						second.first #define ZZ						second.second #define pb						push_back #define fill(a,v) 				memset(a,v,sizeof a) #define all(x)					x.begin(),x.end() #define SZ(v)					((int)(v.size())) #define DREP(a)					sort(all(a)); a.erase(unique(all(a)),a.end()) #define INDEX(arr,ind)			(lower_bound(all(arr),ind)-arr.begin()) #define debug(args...)			{dbg,args; cerr<<endl;} #define dline					cerr<<endl	 #define MOD                     23102009     typedef long long LL; typedef pair<int,int> PII; typedef pair<LL,LL> PLL; typedef pair<int,PII> TRI;   typedef vector<int> VI; typedef vector<LL> VL; typedef vector<PII> VII; typedef vector<PLL> VLL; typedef vector<TRI> VT;   typedef vector<VI> VVI; typedef vector<VL> VVL; typedef vector<VII> VVII; typedef vector<VLL> VVLL; typedef vector<VT> VVT;     /*Main code begins now */   int testnum; VL nums;   int cnt; int l,a,x;     void preprocess() { 	 } int calx(int n) { int u=0,x1=1,i; while(n){u++;n=n/10;} for(i=1;i<u;++i)x1=x1*10;  return x1;     }  void countdig(int n) {int x=0; while(n) { x++; n=n/10;   }    l=x;   } int lr(int n,int l) {     int x1=x;     int u,v,num=-1,i;     while(l--&&n)     {     u=n/x1;     v=n%x1;     n=v*10+u;  //   printf("lr---n=%d\n",n);     if(n>=num)     num=n;     if(n<x1)     x1=calx(n);     }     return num; } int rr(int n,int l) {    int u,v,num=-1,i;    int x1=x;     while(l--&&n)     {     u=n/10;     v=n%10;     n=v*x1+u;  //   printf("rr---n=%d\n",n);     if(n>=num)     num=n;     if(n<x1)     x1=calx(n);     }     return num;  } void solve() {         int p,q,r,s,u,v,x1,x2;     p=lr(a,l);     q=rr(a,l);          if(q>p)     p=q;          r=a;     s=a;     x1=x;     x2=x;     if(p<a)     {     u=r/x1;     v=r%x1;     r=v*10+u;     x1=calx(r);     u=r/10;     v=r%10;     r=v*x1+u;               u=s/10;     v=s%10;     s=v*x2+u;     x2=calx(s);        u=s/x2;        v=s%x2;        s=v*10+u;               //  printf("r=%d s=%d\n",r,s);     r=max(r,s);     p=max(p,r);            }     printf("%d\n",p); //    printf("%d %d\n",ans1,ans2);	 }       bool input() {      s(a);      x=1;      x=calx(a);      int i;      countdig(a);    //   for(i=1;i<l;++i)x=x*10; 	return true; }     int main() { 	preprocess(); 	int T=1;s(T); 	for(testnum=1;testnum<=T;testnum++) 	{ 		if(!input()) break; 		solve(); 	} return 0; }   
#include<iostream> using namespace std; #define mod 1000000007 #include<bits/stdc++.h> int visited[1000000]; list<int> li[10000000];   char arr[1000000+100];       int dfs(int start)  {    	  	stack<int> s;  	int c=0;  	s.push(start);  	char fill=arr[start];  	while(! s.empty())  	 {  	 	 int start=s.top();  	 	 if(arr[start]!='?') 		    { 		    	 c=1; 		   			 }  	 	 s.pop();  	 	   	 	 list<int>:: iterator it;  	 	   	 	 for(it=li[start].begin();it!=li[start].end();it++)   	 	  {  	 	  	   	 	   if(!visited[*it])  	 	  	  {  	 	  	  	visited[*it]=1;  	 	  	  	if(fill=='?') fill=arr[*it];  	 	  	  	else if(arr[*it]!='?' && fill!=arr[*it]) return -1;  	 	  	  	s.push(*it); 				  }            			} 	  }  	  return c;  }       int main()  {  	  int n,m;  	   cin>>n>>m;        vector<pair<int,int> >v;  	    cin>>arr;  	    int q;  	     cin>>q;  	     int c=0;  	     int f=0;  	     for(int i=0;i<q;i++)  	      {  	      	int a,b;  	      	 cin>>a>>b;  	      	 a-=1;  	      	 b-=1;  	      	 li[a].push_back(b);  	      	 	 li[b].push_back(a);  	      	 	   	      	  if(arr[a]=='?' && arr[b]!='?') arr[a]=arr[b];  	      	 else if(arr[b]=='?' && arr[a]!='?') arr[b]=arr[a];  	      	 else if(arr[a]!=arr[b] && arr[a]!='?')  	      	  {  	      	  	f=1; 				 } 	 		 				  	} 	   	   	   	long long int  ans=1; 	 	 for(int i=0;i<n;i++) 	 { 	 	if(!visited[i]) 	 	 { 	 	 	visited[i]=1; 	 	 int j=	dfs(i); 	 	 if(j==0) 	 	  { 	 	  	ans=(ans*m)%mod; 		   } 		   else if(j==-1) 		    { 		    	 f=1; 		    	 break; 			} 		  } 	 }  	if(f==1) 	{ 		 cout<<"-1"<<endl;  	      	  	  exit(0); 	}  	  		 cout<<ans<<endl;  }
#include<iostream> #include<vector> using namespace std; int main() { int t;             cin>>t;             while(t--)             {                 int n;                 cin>>n;                 int a[n];                 vector<int>b;                 for(int i=0;i<n;i++)                 {                      cin>>a[i];                 }                 int j=0;                 for(int i=0;i<n-1;)                 {                     char s;                     cin>>s;                     if(s=='a')                     {                         a[i+1]=a[i]+a[i+1];                         a[i]=1;                         i++;                     }                     else i++;                 }                 long long int res=1;                 for(int i=0;i<n;i++)                 {                     res=(res*a[i])%1000000007;                 }                 cout<<res<<"\n";              } } 
#include<iostream> #include<bits/stdc++.h> #include<math.h> using namespace std; int main() { 	int t; 	cin>>t; 	while(t--)    {    		long long int n;    		cin>>n;    		if(n%9==0)    		{    		   cout<<"0\n"; 		} 		   else 		   { 		   	long long int y=n/9; 		   	long long int a,b; 		   	a=abs(y*9-n); 		   	if(n>=0) 		   	b=abs((y+1)*9-n); 		   	else 		   	b=abs((y-1)*9-n); 		   	if(a<b) 		   	cout<<a<<"\n"; 		   	else 		   	cout<<b<<"\n"; 		   	 		   }    } }
#include <iostream> #include <vector> using namespace std;  vector<long long int> v;  void init() { 	long long int k;  	for(int i = 1; i < 250000; i++) 	{  		v.push_back(k); 		k += i*i; 	} }  int main() { 	int t,val; 	cin >> t; 	init(); 	for(int i = 0; i < t; i++) 	{ 		cin >> val; 		cout << v[val] << endl; 	} 	return 0; }
#include<cstdio> main() {     int test_cases;     scanf("%d",&test_cases);     for(int k=0;k<test_cases;k++)     {     	int a1,a2,a3,a4,ways,runs;         scanf("%d",&runs);         ways=0;         for(a1=runs;a1>=0;a1-=6)         {             for(a2=a1;a2>=0;a2-=4)             {                 for(a3=a2;a3>=0;a3-=2)                 {                     ways++;                 }             }         }           printf("%d\n",ways);     }   return 0; } 
#include<bits/stdc++.h> #include<iostream> using namespace std;  int main() {    long long int t,k,m,n,a[100000],j=0,i;     cin>>t;     while(t--)    {       j=0;     cin>>n>>m>>k;     int maxi=m;     for(i=0;i<n;i++)     {        maxi=m;        cin>>a[i];         while(maxi>0 && a[i]>=k)        {           a[i]=a[i]-k;           maxi--;        }         j=j+a[i];      }     cout<<(j%1000000007)<<"\n";    }  return 0; } 
#include<bits/stdc++.h> using namespace std; #define MOD 1000000007 #define LL unsigned long long  void MUL(LL F[2][2], LL M[2][2]);   void BP(LL F[2][2],LL n);  LL Solve(LL n) {   LL F[2][2] = {{1,1},{1,0}};   if (n == 0)       return 0;   BP(F, n-1);   return F[0][0]; }  void MUL(LL F[2][2], LL M[2][2]) {   LL x =  F[0][0]*M[0][0] + F[0][1]*M[1][0];   LL y =  F[0][0]*M[0][1] + F[0][1]*M[1][1];   LL z =  F[1][0]*M[0][0] + F[1][1]*M[1][0];   LL w =  F[1][0]*M[0][1] + F[1][1]*M[1][1];    F[0][0] = x%MOD;   F[0][1] = y%MOD;   F[1][0] = z%MOD;   F[1][1] = w%MOD; }  void BP(LL F[2][2], LL n) {   if( n == 0 || n == 1)       return;   LL M[2][2] = {{1,1},{1,0}};     BP(F, n/2);   MUL(F, F);     if (n%2 != 0)      MUL(F, M); }  int main() {     long T;     LL N;     scanf("%ld",&T);     while(T--)     {         scanf("%llu",&N);         printf("%llu\n",Solve(N));     }     return 0; } 
#include<bits/stdc++.h> using namespace std; int main() {     string s;     cin>>s;     int i=0,l=0,o=0,v=0,e=0,y=0,u=0;     int n=s.length();     for(int j=0;j<n;j++)     {         if(s[j]=='i')             i++;         else if(s[j]=='l')             l++;         else if(s[j]=='o')             o++;         else if(s[j]=='v')             v++;         else if(s[j]=='e')             e++;         else if(s[j]=='y')             y++;         else if(s[j]=='u')             u++;     }     if(i>=1&&l>=1&&o>=2&&v>=1&&e>=1&&y>=1&&u>=1)         cout<<"happy\n";     else         cout<<"sad\n"; } 
// @Author - Mayank Kataria (AMDOCS) !  #pragma warning(disable:4786) #pragma comment(linker, "/STACK:266777216")  #include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<set> #include<map> #include<functional> #include<string> #include<cstring> #include<cstdlib> #include<queue> #include<utility> #include<fstream> #include<sstream> #include<cmath> #include<stack> #include<cstdio> #include<ctime> #include<cassert>   using namespace std;  //Macros   #define FOR(i,a,b)    for(int i=a;i<b;i++) #define FORL(i,a,b)   for(LL i=a;i<b;i++) #define PB            push_back #define mp            make_pair #define X 		      first #define Y 		      second #define len			  size() #define s(n)          scanf("%d",&n); #define slld(n)       scanf("%lld",&n); #define sf(n)         scanf("%lf",&n); #define ss(n)         scanf("%s",n); #define INF           (int)1e9 #define EPS           1e-9 #define maX(a,b)      (a>b?a:b) #define miN(a,b)      (a<b?a:b) #define MEM(a,b)      memset(a,(b),sizeof(a))  //memset(arr,0,sizeof(arr)) #define istr(S)       istringstream sin(S) #define MOD           1000000007				    typedef vector<int> VI;      //1d integer VECTOR typedef vector<VI> VVI;      //2d integer VECTOR typedef pair<int,int> PII;   //pair typedef vector<PII> VPII;    //VECTOR of pairs typedef vector<string> VS;   //VECTOR of strings typedef vector<double> VD;   //1d double VECTOR  typedef long long LL; typedef long long int LLI; typedef unsigned long long ULL;   int main() { 	int T,N; 	 	scanf("%d",&T); 	 	while(T--) 	{ 		scanf("%d",&N); 		int ans = sqrt(N); 		printf("%d\n",ans); 	}	  return 0; }  
#include<cstdio> #include<iostream> #include<algorithm> using namespace std; typedef struct {     long long int val;     int in; }ad; bool cc(ad a,ad b) {     return(a.val>b.val); } int main() {     int t,n,i;     scanf("%d",&t);      while(t--)     {          scanf("%d",&n);          long long int b[n],d[n];          ad c[n];          for(i=0;i<n;i++)             {                 scanf("%lld",&c[i].val);                 c[i].in=i;             }          for(i=0;i<n;i++)             {                 scanf("%lld",&b[i]);                 d[i]=b[i];             }          sort(c,c+n,cc);          sort(d,d+n);          for(i=0;i<n;i++)             {                 if(d[i]!=b[c[i].in])                     break;             }          if(i==n)             printf("YES\n");          else             printf("NO\n");       } } 
#include <stdio.h> #include <memory.h> #include <vector> using namespace std; char b[41][41]; vector<int> con[1000]; int mx[1000]; bool vis[1000]; int x[41][41]; bool bpm(int v){ 	for(int i=0; i<con[v].size(); i++){ 		int j=con[v][i]; 		if(vis[j]) continue; 		vis[j]=1; 		if(mx[j]==-1 || bpm(mx[j])){ 			mx[j]=v; 			return 1; 		} 	} 	return 0; } int main(){     //freopen("in.txt", "r", stdin);     int T;     scanf("%d", &T);     int n, m, i, j;     while(T--){     	memset(b, 0, sizeof(b));     	for(i=0; i<1000; i++) con[i].clear();     	memset(x, -1, sizeof(x));         scanf("%d %d", &n, &m);         for(i=0; i<n; i++) scanf("%s", b[i]);         int cl=0;         for(i=0; i<n; i++){             for(j=0; j<m; j++){                 if(b[i][j]=='.'){ 					if(b[i][j+1]=='*') ++cl;                 }else{                 	x[i][j]=cl;                 }             }             ++cl;         }         int cm=0;         for(i=0; i<m; i++){             for(j=0; j<n; j++){                 if(b[j][i]=='.'){                 	if(b[j+1][i]=='*') ++cm;                 }else if(x[j][i]>=0){                 	con[cm].push_back(x[j][i]);                 }             }             ++cm;         }         memset(mx, -1, sizeof(mx));         int res=0;         for(i=0; i<cm; i++){         	memset(vis, 0, sizeof(vis));         	res+=bpm(i);         }         printf("%d\n", res);     } }
#include<bits/stdc++.h> using  namespace std; int main() {     int  t;     cin>>t;     while(t--) {         long int n;         cin>>n;         if(n%2==0) {             cout<<n<<endl;         }         else {             cout<<n-1<<endl;         }     }     return 0; } 
#include<bits/stdc++.h> using namespace std;  main(){      long long int a,b,p1,p2,ans,c;      while(1){         c=0;ans =0;         scanf("%lld %lld",&a,&b);         if(a==0&&b==0) break;          while(a||b){             p1=a%10;p2=b%10;             if(p1+p2+c>9) {c=(p1+p2+c)/10; ans++;}             a/=10;b/=10;         }         if(ans == 0) printf("No carry operation.\n");         else if(ans==1)  printf("1 carry operation.\n");         else printf("%lld carry operations.\n",ans);     }     } 
  #include<stdio.h>              int main()       {       printf("\n5\n13");       return 0;         }  
#include<cstdio> #include<cstdlib> #include<cmath> #include<cstring> #include<iostream> #include<algorithm>  using namespace std;  int main() {     for(int t = 1;;t++)     {             int n,m;             scanf("%d %d", &n, &m);             if(n==0 && m==0)                     break;             char arr[n][m+1];             for(int i = 0; i<n;i++)                 scanf("%s", &arr[i]);             if(t != 1)                  printf("\n");             printf("Field #%d:\n",t);             for(int i =0;i<n;i++)             {                     for(int j = 0;j<m;j++)                     {                             if(arr[i][j] == '*')                                 printf("*");                             else                             {                                 int cnt = 0;                                 if(i != 0)                                 {                                      if(arr[i-1][j] == '*')                                           cnt++;                                 }                                 if(i != n-1)                                 {                                      if(arr[i+1][j] == '*')                                           cnt++;                                 }                                 if(j != 0)                                 {                                      if(arr[i][j-1] == '*')                                           cnt++;                                 }                                 if(j != m-1)                                 {                                      if(arr[i][j+1] == '*')                                           cnt++;                                 }                                 if(i != 0 && j!=0)                                 {                                      if(arr[i-1][j-1] == '*')                                           cnt++;                                 }                                 if(i != 0 && j!=m-1)                                 {                                      if(arr[i-1][j+1] == '*')                                           cnt++;                                 }                                 if(i!=n-1 && j != 0)                                 {                                      if(arr[i+1][j-1] == '*')                                           cnt++;                                 }                                 if(i!=n-1 && j != m-1)                                 {                                      if(arr[i+1][j+1] == '*')                                           cnt++;                                 }                                                                  printf("%d",cnt);                             }                     }                     printf("\n");             }     } }              
#include<iostream> using namespace std; int main(){     int test;     cin>>test;     while(test--){                   int mat[6][6],ctr=0,i=0,j=0;                   for(i=0;i<6;i++){                   for(j=0;j<6;j++){                                   cin>>mat[i][j];                   }                   }                   for(i=0;i<6;i++){                   for(j=0;j<6;j++){                                    if(mat[i][j]==1){                                                     if(i==0 || i==5)                                                             ctr++;                                                     if(j==0 || j==5)                                                             ctr++;                                                     if(mat[i-1][j]==0)                                                                       ctr++;                                                     if(mat[i+1][j]==0)                                                                       ctr++;                                                     if(mat[i][j-1]==0)                                                                       ctr++;                                                     if(mat[i][j+1]==0)                                                                       ctr++;                                                     if(ctr==4){                                                                       cout<<"incorrect"<<endl;                                                                       ctr=-1;                                                                       break;                                                     }                                    }                                    }                                    if(ctr<0)                                             break;                   }                   if(ctr>0)                            cout<<"correct"<<endl;     }     return 0; } 
#include<iostream> using namespace std; int main(){     for(;;){             int m,n,i,j;             cin>>m>>n;             if(m==0 && n==0)                     break;             char ch[m][n];             for(i=0;i<m;i++){             for(j=0;j<n;j++){                              char c;                              cin>>c;                              ch[i][j]=tolower(c);             }             }             int test;             cin>>test;             while(test--){                           string str;                           cin>>str;                           int ctr=0;                           for(i=0;i<m;i++){                           for(j=0;j<n;j++){                                            if(ch[i][j]==tolower(str[0])){                                            if(ch[i][j-1]==tolower(str[1]) && ch[i][j-2]==tolower(str[2])){                                                                         ctr=-1;                                                                         cout<<i+1<<" "<<j+1<<endl;                                                                         break;                                            }                                            if(ch[i-1][j-1]==tolower(str[1]) && ch[i-2][j-2]==tolower(str[2])){                                                                         ctr=-1;                                                                         cout<<i+1<<" "<<j+1<<endl;                                                                         break;                                            }                                            if(ch[i-1][j]==tolower(str[1]) && ch[i-2][j]==tolower(str[2])){                                                                         ctr=-1;                                                                         cout<<i+1<<" "<<j+1<<endl;                                                                         break;                                            }                                            if(ch[i-1][j+1]==tolower(str[1]) && ch[i-2][j+2]==tolower(str[2])){                                                                         ctr=-1;                                                                         cout<<i+1<<" "<<j+1<<endl;                                                                         break;                                            }                                            if(ch[i][j+1]==tolower(str[1]) && ch[i][j+2]==tolower(str[2])){                                                                         ctr=-1;                                                                         cout<<i+1<<" "<<j+1<<endl;                                                                         break;                                            }                                            if(ch[i+1][j+1]==tolower(str[1]) && ch[i+2][j+2]==tolower(str[2])){                                                                         ctr=-1;                                                                         cout<<i+1<<" "<<j+1<<endl;                                                                         break;                                            }                                            if(ch[i+1][j]==tolower(str[1]) && ch[i+2][j]==tolower(str[2])){                                                                         ctr=-1;                                                                         cout<<i+1<<" "<<j+1<<endl;                                                                         break;                                            }                                            if(ch[i+1][j-1]==tolower(str[1]) && ch[i+2][j-2]==tolower(str[2])){                                                                         ctr=-1;                                                                         cout<<i+1<<" "<<j+1<<endl;                                                                         break;                                            }                                            }                           }                           if(ctr<0)                                    break;             }     }     }     return 0; } 
// codechef practice(peer) Windows #include<iostream> #define max(a,b) a>b?a:b #define min(a,b) a<b?a:b using namespace std; int main() {     int t;     int x1,y1,x2,y2,x3,y3,x4,y4,x5,x6,y5,y6;     cin>>t;     while(t--)     {               cin>>x1>>y1>>x2>>y2;               cin>>x3>>y3>>x4>>y4;               x5=max(x1,x3);               y5=max(y1,y3);               x6=min(x2,x4);               y6=min(y2,y4);               if((x5<x6)&&(y5<y6))cout <<x5<<" "<<y5<<" "<<x6<<" "<<y6;               else cout<<"No Overlap";               cout<<"\n";     } }                                                                        
#include<iostream> using namespace std; int main(){     cout<<"2 2 7"<<endl;     cout<<"0 0 10"<<endl;     cout<<"1 5 6"<<endl;     return 0; }
#include<iostream> using namespace std; int main(){     cout<<"1 fp*"<<endl;     cout<<"0 axfdp"<<endl;     cout<<"2 ade bmn"<<endl;     return 0; }
//Stupid Problem...  #include <stdio.h>   int main() { 	printf("ABCD\nABCE\nABCFX\n\nABCFX\nABCE\nABCD\n"); 	return 0; }  
#include<stdio.h> int main() {long long int a,b,cur,pre;int count; while(1) {scanf("%lld %lld",&a,&b); if((a==0)&&(b==0)) break; cur=2,pre=1;count=0; while(1) { cur=cur+pre;pre=cur-pre; if((cur>=a)&&(cur<=b)) count++; else if(cur>b) break; } printf("%d\n",count); } return 0; }
#include <cstdio> using namespace std;  int main() { printf("1 0\n2 2\n1 5 2 3 4 6\n1 5 2 4 3 6"); return 0; }
//8.4 Print all permutations of valid open and close parenthesis  #include <iostream> #include <bits/stdc++.h>  using namespace std;  int RN(int n) { 	int a = 0; 	while(n) 	{ 		a = a * 10 + n % 10; 		n = n/10; 	} 	return a; } bool palin(int n) { 	if(n==RN(n)) return true; 	else return false; } void compute(int n) { 	int cnt = 0; 	while(palin(n)==false) 	{ 		cnt++; 		n = n + RN(n); 	} 	cout<<cnt<<" "<<n; }  int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		int a; 		cin>>a; 		compute(a); 		cout<<endl; 	} 	return 0; } 		   	   
// codechef practice(peer) Windows #include<iostream> #define max(a,b) a>b?a:b #define min(a,b) a<b?a:b using namespace std; int main() {     int t;     int x1,y1,x2,y2,x3,y3,x4,y4,x5,x6,y5,y6;     cin>>t;     while(t--)     {               cin>>x1>>y1>>x2>>y2;               cin>>x3>>y3>>x4>>y4;               x5=max(x1,x3);               y5=max(y1,y3);               x6=min(x2,x4);               y6=min(y2,y4);               if((x5<x6)&&(y5<y6))cout <<x5<<" "<<y5<<" "<<x6<<" "<<y6;               else cout<<"No Overlap";               cout<<"\n";     } }                                                                        
#include <stdio.h>           int main()     {     printf("5 2 1 4 3\n1 3 5 2 4\n4 2 5 3");     return 0;     } 
#include<iostream> #include<string> #include<cstdlib> #include<cstdio> using namespace std; int main() { int r,c; cin>>r>>c; int a[25][25]={{0,0}}; string str; int i,j; while(cin>>str!=0) { int l=str.length(); if(l==1) break; string str1=str.substr(0,l-1); int v=atoi(str1.c_str()); if(str[l-1]=='H') { for(i=0;i<c;i++) { int out=0; for(j=0;j<r;j++) { if(a[j][i]==1) continue; int k=1,count=0; if(i+v>c){ out=1; break;} while(k<v) { if(a[j][i+k]==1) {count++; break;} k++; } if(count==0) { while(k>0) { k--; a[j][i+k]=1; } out=1; break; } } if(out==1) break; } } else if(str[l-1]=='V') { for(i=0;i<c;i++) { int out=0; for(j=0;j<r;j++) { if(a[j][i]==1) continue; int k=1,count=0; if(j+v>r) { break; } while(k<v) { if(a[j+k][i]==1) {count++; break;} k++; } if(count==0) { while(k>0) { k--; a[j+k][i]=1; } out=1; break; } } if(out==1) break; } } else if(str[l-1]=='S') { for(i=0;i<c;i++) { int out=0; for(j=0;j<r;j++) { if(a[j][i]==1) continue; int k=1,k1=1,count1=0,count=0; if(i+v>c){ out=1; break;} if(j+v>r) { break; } while(k<v) { if(a[j+k][i]==1) {count++; break;} k++; } while(k1<v) { if(a[j][i+k1]==1) {count1++; break;} k1++; } if(count1==0 && count==0) { k=0; while(k<v) { k1=v; while(k1>0) { k1--; a[j+k][i+k1]=1; } k++; } out=1; break; } } if(out==1) break; } } } for(i=r-1;i>=0;i--) { for(j=0;j<c;j++) cout<<a[i][j]; cout<<endl; } return 0; } 
#include <stdio.h>   int main() {     printf("1 4\n2 11\n3 14");     return 0; } 
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <limits> #include <string> #include <cassert>  using namespace std; typedef long long LL; typedef pair<int,int> pii; typedef pair< pii , pii > piiii;  #define forup(i,a,b) for(int i=a; i<b; ++i) #define fordn(i,a,b) for(int i=a; i>b; --i) #define rep(i,a) for(int i=0; i<a; ++i)  #define dforup(i,a,b) for(i=a; i<b; ++i) #define dfordn(i,a,b) for(i=a; i>b; --i) #define drep(i,a) for(i=0; i<a; ++i)  #define slenn(s,n) for(n=0; s[n]!='\0'; ++n)  #define gi(x) scanf("%d",&x) #define gl(x) cin>>x #define gd(x) scanf("%lf",&x) #define gs(x) scanf("%s",x)  #define pis(x) printf("%d ",x) #define pin(x) printf("%d\n",x) #define pls(x) cout<<x<<" " #define pln(x) cout<<x<<"\n" #define pds(x) printf("%.12f ",x) #define pdn(x) printf("%.12f\n",x) #define pnl() printf("\n")  #define fs first #define sc second #define loc first.first #define lmv first.second #define lct second.first #define rct second.second  #define pb push_back  const LL modref=1000000007ll;  const int max_n=100010;  int T; int n;  typedef set<piiii> sset;  sset S; sset::iterator it;  LL qmin,qmax;  LL p2[max_n]; void findp2() { 	p2[0]=1ll; 	forup(i,1,max_n) 		p2[i]=(p2[i-1]*2ll)%modref; }  LL fmax(LL s, LL e, LL r) { 	if(s>e) return 0ll; 	assert(r<=e-s+1);  	LL ret=p2[r]-1ll; 	ret*=p2[(n-2)-(s+r-1)]; ret%=modref; 	return ret; }  LL fmin(LL s, LL e, LL r) { 	if(s>e) return 0ll; 	assert(r<=e-s+1);  	LL ret=p2[r]-1ll; 	ret*=p2[(n-2)-e]; ret%=modref; 	return ret; }  int main() { 	findp2(); 	gi(T);  	rep(z,T) 	{ 		gi(n);  		S.clear(); 		S.insert(piiii(pii(-1,0),pii(0,0)));  		qmin=0ll; qmax=p2[n-1]-1ll; 		bool valid=true; 		int ci,cj; 		rep(i,n/2) 		{ 			gi(ci); --ci; gi(cj); 			if(not valid) { pin(-1); continue; }  			piiii cp; 			if(cj<=n/2) cp=piiii(pii(ci,0),pii(cj,ci+1-cj)); 			else cp=piiii(pii(ci,1),pii(ci+1-(n-cj+1),n-cj+1));  			it=S.upper_bound(cp); --it; // should work, not sure though .. 			if(not( it->lct<=cp.lct and it->rct<=cp.rct )) valid=false; 			++it; 			if(it!=S.end() and (not( it->lct>=cp.lct and it->rct>=cp.rct ))) valid=false; 			if(not valid) { pin(-1); continue; }  			if(it==S.end()) 			{ 				--it; 				int ploc=it->loc, /*plmv=it->lmv, plct=it->lct,*/ prct=it->rct; 				int cloc=cp.loc, clmv=cp.lmv, /*clct=cp.lct,*/ crct=cp.rct;  				if(clmv) { qmin += p2[n-2-cloc]; qmin%=modref; } 				qmin += fmin(ploc+1,cloc-1,(crct-prct-clmv)); qmin %= modref;  				if(clmv) { qmax += p2[n-2-cloc]; qmax%=modref; } 				qmax += modref-(p2[n-ploc-2]-1); qmax %= modref; 				qmax += (p2[n-cloc-2]-1); qmax %= modref; 				qmax += fmax(ploc+1,cloc-1,(crct-prct-clmv)); qmax %= modref; 			} 			else 			{ 				int nloc=it->loc, nlmv=it->lmv, /*nlct=it->lct,*/ nrct=it->rct; 				--it; 				int ploc=it->loc, /*plmv=it->lmv, plct=it->lct,*/ prct=it->rct; 				int cloc=cp.loc, clmv=cp.lmv, /*clct=cp.lct,*/ crct=cp.rct;  				if(clmv) { qmin += p2[n-2-cloc]; qmin%=modref; } 				qmin += modref-fmin(ploc+1,nloc-1,(nrct-prct-nlmv)); qmin %= modref; 				qmin += fmin(cloc+1,nloc-1,(nrct-crct-nlmv)); qmin%=modref; 				qmin += fmin(ploc+1,cloc-1,(crct-prct-clmv)); qmin%=modref;  				if(clmv) { qmax += p2[n-2-cloc]; qmax%=modref; } 				qmax += modref-fmax(ploc+1,nloc-1,(nrct-prct-nlmv)); qmax %= modref; 				qmax += fmax(cloc+1,nloc-1,(nrct-crct-nlmv)); qmax%=modref; 				qmax += fmax(ploc+1,cloc-1,(crct-prct-clmv)); qmax%=modref; 			}  			S.insert(cp); 			pis((int(qmin))); pin((int(qmax))); 		} 	} 	 	return 0; }
#include<iostream> #include<algorithm> #include<string> # define mod 1000000007 # define long long ll using namespace std; int main() { 	int t,n,x,y,i; 	string s; 	cin>>t; 	while(t--) 	{ 		x=0; 		y=0; 		cin>>s; 		for(i=0;i<s.length();i++) 		{ 			if(s[i]=='N') 			x++; 			if(s[i]=='S') 			x--; 			if(s[i]=='E') 			y++; 			if(s[i]=='W') 			y--; 		} 			//cout<<x<<" "<<y<<endl; 			if(x>0&&y>0) 			cout<<"NORTHEAST"<<endl; 			if(x>0&&y<0) 			cout<<"NORTHWEST"<<endl; 			if(x<0&&y>0) 			cout<<"SOUTHEAST"<<endl; 			if(x<0&&y<0) 			cout<<"SOUTHWEST"<<endl; 			if(x>0&&y==0) 			cout<<"NORTH"<<endl; 			if(x<0&&y==0) 			cout<<"SOUTH"<<endl; 			if(x==0&&y<0) 			cout<<"WEST"<<endl; 			if(x==0&&y>0) 			cout<<"EAST"<<endl;						 			 	} 	return 0; } 
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <climits> #include <cctype> #include <cassert>  using namespace std;  #define ulli        unsigned long long int #define lli         long long int #define clr(x)      memset(x,0) #define set(x)      memset(x,1) #define memset(x,i) memset(x,i,sizeof(x)) #define Sd(x)       scanf("%d",&x); #define Sf(x)       scanf("%f",&x); #define Sc(x)       scanf("%c",&x); #define Ss(x)       scanf("%s",x); #define Sulli(x)    scanf("%llu",&x) #define F(i,a,n)    for(int i=a;i<n;i++) #define FD(i,a,n)   for(int i=a;i>=n;i--) #define Nl          printf("\n");  //-----RELEVANT CODE-----  int main() {     //freopen("inp.txt","r",stdin);     int t,r,c;lli a[105][105],s,k;     scanf("%d",&t);     while(t--)     {         s=0;         scanf("%d %d %lld",&r,&c,&k);         //printf("%d %d %lld\n",r,c,k);         F(i,0,r) F(j,0,c) scanf("%lld",&a[i][j]);         s+=a[r-1][0];         int j=0;         FD(i,r-2,0)         {             if(j==0)             {                 if(a[i][j+1]<a[i][j])                     j++;             }             else if(j==c-1)             {                 if(a[i][j-1]<=a[i][j])                     j--;             }             else             {                 if(a[i][j-1]<=a[i][j] && a[i][j-1]<=a[i][j+1])                     j--;                if(a[i][j+1]<a[i][j] && a[i][j+1]<a[i][j-1])                     j++;             }             s+=a[i][j];         }             //printf("%lld %lld\n",s,k);             if(s<=k)                 printf("Yes\n");             else                 printf("No\n");     }     return 0; } 
#include <bits/stdc++.h> #define ll long long int #define s(a) scanf("%lld",&a) #define f first #define sc second #define pb push_back #define mp make_pair #define VALUETYPE long long int #define inf 10e16 #define EVEN(x) ((x%2)==0) #define ODD(x) ((x%2)==1)  using namespace std;  vector<ll>v[100001]; ll a[100001]; ll level[100001]; ll parent[100001]; vector<ll>topoSort; ll baap[100001][20]; ll dp[100001][20]; ll power[101];  ll mod=1000000007;  void dfs(ll ind,ll lst,ll lev) {     parent[ind]=lst;     level[ind]=lev;     for(int i=0;i<v[ind].size();i++) {         if(v[ind][i]==lst) continue;         dfs(v[ind][i],ind,lev+1);     }     topoSort.pb(ind); }  ll jthAncestor(ll ind,ll x) {     if(level[ind] < x) return -1;     ll ans = ind;     //cout<<ind<<endl;     for(int i=19;i>=0;i--) {         ll val = 1<<i;         if(val <= x) {             ans = baap[ans][i];             //cout<<ans<<endl;             x-=val;         }     }     return ans; }  int main() {     //freopen("inp.txt","r",stdin);     ll n,i,j,k,l,w,ww,x,y,z,m,d;     s(n);s(d);     for(i=1;i<=n;i++) s(a[i]);     for(i=1;i<n;i++) {         s(x);s(y);         v[x].pb(y);         v[y].pb(x);     }      power[0]=1;     for(i=1;i<19;i++) {         power[i]=power[i-1]*d;     }      dfs(1,-1,0);     for(i=1;i<=n;i++) {         baap[i][0]=parent[i];     }     for(j=1;j<20;j++) {         for(i=1;i<=n;i++) {             w = baap[i][j-1];             if(w==-1) {baap[i][j]=-1;continue;}             ww = baap[w][j-1];             if(ww==-1) {baap[i][j]=-1;continue;}             baap[i][j]=ww;         }     }     reverse(topoSort.begin(),topoSort.end());      dp[1][0]=a[1];     for(i=1;i<topoSort.size();i++) {         x = topoSort[i];         dp[x][0]=a[x];         for(j=1;j<20;j++) {             w = jthAncestor(x,power[j-1]);             if(w==-1) {                 dp[x][j]=0;             }             else {                 if(dp[w][j-1]!=0) {                     dp[x][j] = dp[w][j-1] + a[x];                     if(dp[x][j]>mod) dp[x][j]-=mod;                 }             }         }     }     ll ans = 0;      for(i=0;i<20;i++) {         for(j=1;j<=n;j++) {             ans = ans + dp[j][i];             if(ans>=mod) ans-=mod;         }     }     cout<<ans<<endl;     return 0; } 
#include<iostream> using namespace std;  int main() { int n; cin>>n; int sum=0; for(int i=1;i<=n;i++) sum+=i; cout<<sum<<endl; return 0; }
#include <iostream> using namespace std;   int main() {     long long int n;     cin>>n;     n=n/4;     cout<<(n*n)<<endl;         return 0; }
#include <iostream> using namespace std;  int main() {     int sum=0,temp=0;     cin>>temp; sum+=(3*temp);     cin>>temp>>temp; sum+=temp;     cout<<sum<<endl;     return 0; } 
#include<iostream> using namespace std; int main() { long a,b,c; cin>>a>>b>>c; if(a+b<c) cout<<"PROFIT"<<endl; else cout<<"LOSS"<<endl; return 0; }
#include <iostream> #include <string.h> using namespace std;  int main() {     char a[1000];     cin>>a;     for(int i=0;i<strlen(a);i++)     {         int p= a[i] - 'A';         p+=3;         p=p%26;         p+=65;         char d=p;         cout<<d;     }     cout<<endl;     return 0; }
//calculating area.. #include<iostream> using namespace std; int main() { 	float per,area,l,b; 	cin>>per; 	cin>>l; 	b = (per/2)-l; 	area = l*b; 	cout<<area; }
 #include <bits/stdc++.h> using namespace std;  typedef long long int ll; ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;} ll a[100001],ans[100001]; vector<ll> prime;   ll amaz(ll i) {   	ll sum=0;  	for(ll j=1;j<=sqrt(i);j++) 		if(i%j==0) 			sum+= (j+i/j);   	return sum-i ;  } int main() { 	ios_base::sync_with_stdio(0); cin.tie(0); 	 	ll n;cin>>n; 	cout<<amaz(n); 	 	return 0; }
#include<iostream> using namespace std; int main() {     int x1,y1,x2,y2,x,y;     cin>>x1>>y1>>x2>>y2>>x>>y;     if((x1<=x&&x<=x2)||(x1>=x&&x>=x2))        {            if((y1<=y&&y<=y2)||(y1>=y&&y>=y2))               {                   cout<<"INSIDE";                   return 0;               }        }        cout<<"OUTSIDE";        return 0; } 
#include <iostream> #include <cstdio> using namespace std; char is[200][200]; void chn(int,int); int main() { int n; cin>>n; for(int i=0;i<n;i++){ int x,y; cin>>x>>y; for(int j=0;j<x;j++) for(int k=0;k<y;k++) is[j][k]='.'; for(int j=0;j<x;j++) for(int k=0;k<y;k++) cin>>is[j][k]; int sum=0; for(int j=0;j<x;j++) for(int k=0;k<y;k++) {if(is[j][k]=='#')sum=sum+1; chn(j,k);} /* for(int j=0;j<x;j++){ for(int k=0;k<y;k++) cout<<is[j][k]; cout<<endl;}*/ cout<<sum<<endl; } }   void chn(int x,int y){ if(is[x][y]=='#') {is[x][y]='.'; chn(x-1,y-1); chn(x-1,y); chn(x-1,y+1); chn(x,y-1); chn(x,y+1); chn(x+1,y-1); chn(x+1,y); chn(x+1,y+1); } else return; }   
#include <iostream> #include <algorithm> using namespace std;  int main() {     int t; cin>>t;     while(t--)     {         long n; cin>>n;         long sum=0;         for(int i=1;i<=n/2;i++)         {             if(n%i==0)             sum+=i;         }         cout<<sum<<endl;     }     return 0; }
#include<algorithm> #include<iostream> #include<cstdio> #include<vector> #include<fstream> #include<iomanip> #include<bitset> #include<deque> #include<queue> #include<string> #include<map> #include<cstring> #include<sstream> #include<cmath> using namespace std;  #define gc getchar_unlocked   void scanint(int &x) { register int c = gc(); x = 0; for(;(c<48 || c>57);c = gc()); for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} } int a[500];   void recurse(int start,int end,int count,int &min) {     int i;     if(start>end)     return;      if(start==end)     {         if(count<min)         min=count;     }      for(i=1;i<=a[start];i++)     recurse(start+i,end,count+1,min); }  int main() {     int min=10000;      int n,i,t,x,y,flag;     scanint(t);     while(t--)     {         min=100000;         scanint(n);          for(i=0;i<n;i++)         scanint(a[i]);          recurse(0,n-1,0,min);         cout<<min<<"\n";       }     return 0; } 
#include<stdio.h> int main() {  int t,n,a,b,f,i;  scanf("%d",&t);  while(t)  {   f=0;   scanf("%d%d",&a,&b);   for(n=1;n<=a;n++)   {    for(i=n+1;i<=a;i++)    {     if(n*b%i==0)     {      f++;      break;     }     }   }   printf("%d\n",f);   t--;  }    return 0; }  
/*-->>Light Cavalry<<--*/  //Imp header files #include <iostream> #include <cstdio> #include <cstdlib> #include <cstring> #include <cmath> #include <algorithm> #include <set> #include <vector> #include <stack> #include <queue> #include <sstream> #include <map> #include <list> #include <deque> #include <bitset> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iomanip> #include <sstream> #include <ctime> #include <cassert> #include <climits> using namespace std;  //defined I/O #define si(n) scanf("%d",&n) #define sli(n) scanf("%ld",&n) #define slli(n) scanf("%lld",&n) #define sf(n) scanf("%lf",&n) #define GetLine(n) getline(cin,n); #define ss(n) scanf("%s",n) #define pi(n) printf("%d",n) #define pli(n) printf("%ld",n) #define plli(n) printf("%lld",n) #define pf(n) printf("%lf",n) #define ps(n) printf("%s",n) #define newLine printf("\n") #define space printf(" ") #define SWAP(a,b,t) t=a,a=b,b=t #define Loop(i,a,n) for(__typeof(n) i(a); i<n; i++) #define ULL unsigned long long int #define LL long long int   #define MOD 1000000007 //Imp functions int gcd(int a, int b){if(b == 0)return a;else return gcd(b,a % b);}     int main() { 	 	int n; 	si(n); 	 	string s[n]; 	 	Loop(i,0,n) 	{ 		cin>>s[i]; 		 	} 	int  m=s[0].length(); 	 	int a[n][m]; 	 	Loop(i,0,n) 	{ 		Loop(j,0,m) 		{ 			 			 			a[i][j]=9999; 			 			 //cout<<a[i][j]<<" "; 		} 		//cout<<endl; 		 	} 	 	a[0][0]=1;  	int x,y,z; 	Loop(i,0,n) 	{ 		Loop(j,0,m) 		{ 			if(s[i][j]=='0') 			{ 			int mi=9999; 			 			 			if(i-1>=0 && j-1>=0) 			mi=min(mi,a[i-1][j-1]+1); 			 			if(i-1>=0 && j+1<m) 			mi=min(mi,a[i-1][j+1]+1); 			 			if(i+1<n && j-1>=0) 			mi=min(mi,a[i+1][j-1]+1); 			 			if(i+1<n && j+1<m) 			mi=min(mi,a[i+1][j+1]+1); 			 			if(j-1>=0) 			mi=min(mi,a[i][j-1]+1); 			 			 			if(i-1>=0) 			mi=min(mi,a[i-1][j]+1); 			 			 			if(j+1<m) 			mi=min(mi,a[i][j+1]+1); 			 			if(i+1<n) 			mi=min(mi,a[i+1][j]+1); 			 			 			 			 			 			 			if(mi!=9999) 			a[i][j]=mi; 			 			} 			 			//cout<<a[i][j]<<" "; 			 		 		} 		//cout<<endl; 		 	} 	 	cout<<a[n-1][m-1]<<endl;  	 	 	return 0; }     
//#include<iostream.h> //#include<conio.h> #include<stdio.h> #include<string.h>  char a[20003][22];  int b[20002];  int c[20002]; //using namespace std; int main() {  int n,m,i,l,h,j,p,o,k,x;    scanf("%d%d",&n,&m);  while((n!=0)&&(m!=0))  {p=0;   for(i=0;i<n;i++)   b[i]=0;   x=0;   for(i=0;i<n;i++)   scanf("%s",a[i]);   for(i=0;i<n;i++)   {    if(x>n)    break;    h=0;    o=0;    for(l=0;l<p;l++)    {     if(i==c[l])      {o=1;      break;      }    }    //cout<<"workin for i="<<i<<endl;   if(o==0)   {     for(j=i;j<n;j++)     {      if(j!=i)      {       if(!strcmp(a[i],a[j]))       {x++;        h++;        c[p++]=j;       }       // cout<<"h="<<h<<endl;      }     }       b[h]+=1;     }              }   for(i=0;i<n;i++)   printf("%d\n",b[i]); // cout<<"enter n & m"<<endl;   scanf("%d%d",&n,&m);  }          // getch();     return 0;      }             
#include <cstdlib> #include <iostream> //#include<conio.h> //using namespace std; int a[150]; int main() {     int n=1,i,ra,m,mul,k=0,j,c;   //  time_t t;   // unsigned int seedval; while(1) {          scanf("%d",&n);        if(n==0)        break;        c=n; ra=1;     do     {        for(i=0;i<c-1;i++)        a[i]=i+2;               n=c;              // seedval=(unsigned)time(&t);      // srand(seedval);       // ra=((rand()%c)+1);            k=0;        m=0;               // cout<<"ra="<<ra<<endl;       // getch();       while((m==0)&&(n-1>1))       {         for(i=0;i<n-1;i++)        {         k++;         if(k%ra==0)         {//cout<<"k="<<k<<" "<<"i="<<i<<endl;           if((a[i]==13)&&(n-1>1))           m=1;           n--;           for(j=i;j<n-1;j++)           a[j]=a[j+1];           i--;         }        }        }    //  for(j=0;j<n-1;j++)      // cout<<a[j]<<" ";  ///  cout<<endl;     //  getch();     if(m==1)     ra++;     }while(m==1);                                         // if(ra>=n)       // m=1; printf("%d\n",ra);       //a[k++]=ra; }     // for(i=0;i<k;i++)     //cout<<a[i]<<endl; //getch();  return 0; } 
#include<iostream> #include<cstring> #include<cstdio> using namespace std; int main() { //thisistheeasyoneab  /*  t t y     h h o     i e n     s e e     i a a     s s b */     int i=1,j=0,p,c;     char s[500];     int t;     cin>>t;     while(t--)     {         i=1;         j=0;         cin>>c;         int d=c;         int e=1;         scanf("%s",s);         p=strlen(s);         int r=p/c;         //int flag=0;         int x=2*d-1;         int flag=0;         int cnt=1;         cout<<s[0];         p--;          while(p>0)         {             if(cnt==r)             {                 j=i;                 cnt=1;                 d--;                 cout<<s[i++];                 p--;                 x=2*d-1;                 e=2*c-x;                 flag=0;               }                if(flag==0)             {                 cout<<s[j+x];                 j=j+x;                 p--;                 flag=1;                 cnt++;             }             else             {                 cout<<s[j+e];                 j=j+e;                 flag=0;                 p--;                 cnt++;             }          }         cout<<"\n";          } } 
#include<iostream> #include<string.h>  using namespace std;  int main() {     long long int t,i,n,a,b,sum;;      cin>>t;      while(t--)     {         sum=0;         cin>>a>>b>>n;          if(n>2)         for(i=0;i<n-2;i++)         {             sum=a+b;             a=b;             b=sum;         }         else         if(n==1)    sum=a;         else         if(n==2)    sum=b;          cout<<sum<<endl;     }   return 0; } 
#include<iostream> #include<cstdio> using namespace std; int main() {      char str[25];      int num[4];      while(scanf("%s",&str)!=EOF)      {           int r=0,j=0;           for(int i=0;str[i]!='\0';i++)           {                if(str[i]!='.')                {                     r=str[i]-48+r*10;                }                else                {                     num[j]=r;                     j++;                     r=0;                }           }           num[j]=r;           if(num[0]>=1 && num[0]<=126 && num[1]>=0 && num[1]<=255 && num[2]>=0 && num[2]<=255 && num[3]>=0 && num[3]<=255)                   printf("Class A\n");              else if(num[0]>=128 && num[0]<=191 && num[1]>=0 && num[1]<=255 && num[2]>=0 && num[2]<=255 && num[3]>=0 && num[3]<=255)                   printf("Class B\n");              else if(num[0]>=192 && num[0]<=223 && num[1]>=0 && num[1]<=255 && num[2]>=0 && num[2]<=255 && num[3]>=0 && num[3]<=255)                   printf("Class C\n");              else if(num[0]>=224 && num[0]<=239 && num[1]>=0 && num[1]<=255 && num[2]>=0 && num[2]<=255 && num[3]>=0 && num[3]<=255)                   printf("Class D\n");               else if(num[0]>=240 && num[0]<=255 && num[1]>=0 && num[1]<=255 && num[2]>=0 && num[2]<=255 && num[3]>=0 && num[3]<=254)                   printf("Class E\n");               else printf("Invalid\n");      } } 
#include<iostream> #include<cstdio>  using namespace std;  int main() {     int a,b,c,flag1,flag2,min,i;      while(scanf("%d%d%d",&a,&b,&c)!=EOF)     {         flag1=0;         flag2=1;         if( a<b && a<c )         min=a;         else         if( b<a && b<c )         min=b;         else         min=c;          if( a*a+b*b==c*c || b*b+c*c==a*a || a*a+c*c==b*b )         flag1=1;          for(i=2;i<=min;i++)         {             if( a%i==0 && b%i==0 && c%i==0 )             flag2=0;         }          if(flag1 && flag2)         printf("YES\n");         else         printf("NO\n");      }    return 0; } 
/* Sahil Prakash */  #include<bits/stdc++.h>  using namespace std;  #define ull unsigned long long #define si(x) scanf("%d",&x) #define sull(x) scanf("%llu",&x) #define sch(x) scanf("%c",&x) #define sstr(s) scanf("%s",s) #define pri(x) printf("%d",x) #define pch(x) printf("%c",x) #define pull(x) printf("%llu",x) #define pstr(s) printf("%s",s) #define nl printf("\n")  int main() {     char s[26];     sstr(s);     while( strcmp(s,"*END*") != 0 )     { 	int i,j,k,l,flag1=0,flag2=0,len,count1=0,count2=0; 	len=strlen(s); 	j=len-2; 	i=0; 	while(i<j) 	{ 	    k=j-1; 	    l=i; 	    count1=count2=0; 	    flag1=flag2=0; 	    for(;k>l;--k) 	    { 		if(s[k] != s[l]) 		    count1++; 		l++; 	    } //		pri(count1); //		nl; 	    if(count1<=1) 		flag1=1; 	    k=j; 	    l=len-1; 	    for(;k<l;++k) 	    { 		if(s[k] != s[l]) 		    count2++; 		l--; 	    } //	    pri(count2); //		nl; 	    if(count2<=1) 		flag2=1; 	    if(flag1==1 && flag2==1) 	    { 		printf("%s is a double near palindrome.\n",s); 		break; 	    } 	    j--; 	} 	if(flag1!=1 || flag2!=1) 	    printf("%s is not a double near palindrome.\n",s); 	sstr(s);     }     return 0; } 
// by ma5termind #include<iostream> #include<vector> #include<set> #include<map> #include<queue> #include<stack> #include<string> #include<algorithm> #include<functional> #include<iomanip> #include<cstdio> #include<cmath> #include<limits.h> #include<cstring> #include<cstdlib> #include<cfloat> #include<cassert> #define maxm(a,b) a>b?a:b; #define minm(a,b) a<b?a:b; using namespace std; //M lazy ;) typedef long long ll; typedef vector <int> vi; typedef pair< int ,int > pii; typedef istringstream iss; typedef ostringstream oss; typedef map<int,int> mp; #define pb push_back #define mp make_pair #define ff first #define ss second #define sz size() #define ln length() #define rep(i,n) for(int i=0;i<n;i++) #define fu(i,a,n) for(int i=a;i<=n;i++) #define fd(i,n,a) for(int i=n;i>=a;i--) #define all(a)  a.begin(),a.end() #define ESP (1e-9) #define gi(n) scanf("%d",&n) #define gl(n) cin >> n #define pi(n) printf("%d",n) #define pl(n) cout << n #define ps printf(" ") #define pn printf("\n") #define dg(n,s); printf("%s %d",s,n) #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min() #define traverse_map(a,b) for(mp::iterator it=a;it!=b;++it) #define MOD 1000000007 #define MAX 1000001 #define cases() int t; cin>>t; while(t--) // fast input function #define getcx getchar_unlocked // fast input function #ifdef ONLINE_JUDGE  inline void inp( int &n )  {     n=0;     int ch=getcx();int sign=1;     while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )             n = (n<<3)+(n<<1) + ch-'0', ch=getcx();     n=n*sign;   } #else inline void inp(int &n){  cin>>n; } #endif int gcd(int a,int b){    if(b==0)    return a;    return gcd(b,a%b); } int main(){  //vi num;  //map<int,int>mark;     int a,b,c; 	while(scanf("%d%d%d",&a,&b,&c)!=EOF){ 	 	 	 if(a<0) 	  a*=-1; 	  if(b<0) 	  b*=-1; 	  if(c<0) 	  c*=-1; 	   	  if(c*c==a*a+b*b){  		  if(gcd(a,gcd(b,c))==1) 			cout<<"YES"<<endl; 		  else 		  cout<<"NO"<<endl; 	  } 	  else 	   cout<<"NO"<<endl; }  return 0; } 
#include<stdio.h> typedef long long ll; int p[40];  int main(){ 	register int i,j,k; ll t; 	scanf("%lld",&t); 	while(t){ 		for(i=0;t;i++){ 			p[i]=t%2; 			t=t/2; 		} 		j=1;k=1; 		for(i=i-2;i>=0;i--){ 			if(p[i])  j=j+k; 			else k=k+j; 		} 		printf("%d/%d\n",j,k); 		scanf("%lld",&t); 	} 	return 0; }
#include<stdio.h>   int main() { 	int count,a,b,c,d; 	char str[1024]; 	while((count=scanf("%d.%d.%d.%d",&a,&b,&c,&d))!=EOF) 	{ 		gets(str); 		if(count<4||a>255||b>255||c>255||d>=255||a<0||b<0||c<0||d<0||(a==0&&b==0&&c==0&&d==0)) 		printf("Invalid\n"); 		else 		{ 			if(a<=127) 			printf("Class A\n"); 			else if(a<=191) 			printf("Class B\n"); 			else if(a<=223) 			printf("Class C\n"); 			else if(a<=239) 			printf("Class D\n"); 			else 			printf("Class E\n"); 		} 	} 	return 0; } 
#include<iostream> using namespace std;  string arr[10][10]= {"0","0","0","0","0","0","0","0","0","0",                 "0","1","2","3","4","5","6","7","8","9",                 "0","2","4","6","8","10","12","14","16","18",                 "0","3","6","9","12","15","18","21","24","27",                 "0","4","8","12","16","20","24","28","32","36",                 "0","5","10","15","20","25","30","35","40","45",                 "0","6","12","18","24","30","36","42","48","54",                 "0","7","14","21","28","35","42","49","56","63",                 "0","8","16","24","32","40","48","56","64","72",                 "0","9","18","27","36","45","54","63","72","81"};                                    string add(string q,string w) {   long long int l1,l2,carry,sum,l,diff,flag,i,pos;     carry=0;     string s="";     l1=q.length();     l2=w.length();     if(l1>=l2)     {         l=l1;               flag=1;               diff=l1-l2;     }     else     {         l=l2;               diff=l2-l1;               flag=2;     }     if(flag==1)     {          for(i=0;i<diff;i++)                w=" "+w;     }     else     if(flag==2)     {          for(i=0;i<diff;i++)                q=" "+q;     }          for(i=l-1;i>=0;i--)     {                     sum=carry;                           if(q[i]!=' ')                           sum=sum+q[i]-48;                           if(w[i]!=' ')                           sum=sum+w[i]-48 ;                             carry=sum/10;                           sum=sum%10;                           s=(char)(sum+48)+s;     }     if(carry>0)     s=(char)(carry+48)+s;     pos=0;     flag=0;     l=s.length();     if(l>1)     {     for(i=0;i<l;i++)     {               if(s[i]!='0')                     {pos=i;                     flag=1;                     break;}     }     for(i=0;i<l-pos;i++)     s[i]=s[i+pos];         s.resize(l-pos); if(flag==0)      s="0";      }     return s;    }    string subd(string q,string w) {   long long int l1,l2,carry,sum,l,diff,flag,i,j,pos;     carry=0;     string s="";     //cout<<"doin... dekh lo"<<q<<" "<<w<<endl;     l1=q.length();     l2=w.length();     //cout<<l1<<" bty  "<<l2<<endl;     if(l1>=l2)     {         l=l1;               flag=1;               diff=l1-l2;     }     else     {         l=l2;               diff=l2-l1;               flag=2;     }     ///cout<<"diff dekho toh"<<diff<<endl;     if(flag==1)     {          for(i=0;i<diff;i++)                w=" "+w;     }     else     if(flag==2)     {          for(i=0;i<diff;i++)                q=" "+q;     }    // cout<<"q="<<q<<endl;     //cout<<"W="<<w<<endl;     for(i=l-1;i>=0;i--)     {                     if(q[i]>=w[i] && w[i]>34)                           s=(char)(q[i]-w[i]+48)+s;                           else                           if(w[i]<34)                           s=(char)(q[i])+s;                           else                           {                               for(j=i-1;j>=0;j--)                               {                  if(q[j]>w[j] && q[j]>48)                                                  {            pos=j;                                 //                              cout<<"pos="<<pos;                                                               break;                                                  }                               }                               q[pos]--;                               //cout<<"q="<<q<<endl;                               for(j=pos+1;j<i;j++)                               q[j]=q[j]+9;                               //cout<<"q="<<q<<endl;                               q[i]=q[i]+10;                               //cout<<"q="<<q<<endl;                               i++;                           }                }     pos=0;     flag=0;     l=s.length();     if(l>1)     {     for(i=0;i<l;i++)     {               if(s[i]!='0')                     {pos=i;                     flag=1;                     break;}     }     for(i=0;i<l-pos;i++)     s[i]=s[i+pos];      s.resize(l-pos);      if(flag==0)      s="0"; }   //cout<<"returnin s"<<s<<endl;     return s;    }           string mult(string a,string b) {   long long int l1,l2,flag,diff,max,l,i,pos;     string z1,z2,z0,s1,s2,ans;     l1=a.length();     //cout<<"a="<<a<<endl;   // cout<<"b="<<b<<endl;   /// cout<<"l1="<<l1<<endl;     l2=b.length();   // cout<<"l2="<<l2<<endl;   // cin>>i;     if(l1==1 && l2==1)     {z2=arr[ a[0]-48 ][ b[0]-48 ];     return z2;     }          else     {     if(l1>=l2)     {         l=l1;               flag=1;               diff=l1-l2;     }     else     {         l=l2;               diff=l2-l1;               flag=2;     }     if(flag==1)     {          for(i=0;i<diff;i++)                b='0'+b;     }     else     if(flag==2)     {          for(i=0;i<diff;i++)                a='0'+a;     }     max=(l-1)/2;   // cout<<"max="<<max<<endl;     z2=mult(a.substr(0,max+1),b.substr(0,max+1) );   // cout<<"z2="<<z2<<endl;     z0=mult(a.substr(max+1),b.substr(max+1) );   //  cout<<"z0="<<z0<<endl;   /// cout<<"z2 change? ="<<z2<<endl;   //  cout<<"s1=sudstr of"<<max+1;     s1=add(a.substr(0,max+1),a.substr(max+1) );   // cout<<"s1="<<s1<<endl;     s2=add(b.substr(0,max+1),b.substr(max+1) );   // /cout<<"s2="<<s2<<endl;     z1=mult(s1,s2); //   cout<<"z1 after multi s1 s2="<<z1<<endl;   // cout<<"z1="<<z1<<endl;   // cout<<"z2="<<z2<<endl;     z1=subd(z1,z2);    // cout<<"z1 - z2="<<z1<<endl;    // cout<<"z0="<<z0<<endl;     z1=subd(z1,z0);   // cout<<"z1 - z0="<<z1<<endl;   //  cout<<"max now"<<max<<endl;     for(i=0;i<2*(l/2);i++)     z2=z2+'0';   // / cout<<"z2 after ading 0="<<z2<<endl;     for(i=0;i<l/2;i++)     z1=z1+'0';    // cout<<"z1 after ading 0="<<z1<<endl;     z2=add(z2,z1);   // cout<<"z2 +z1="<<z2<<endl;     z2=add(z2,z0);   // cout<<"z2+ z0="<<z2<<endl;     pos=0;     l=z2.length();     flag=0;     if(l>1)     {     for(i=0;i<l;i++)     {               if(z2[i]!='0')                     {pos=i;flag=1;                     break;}     }     if(pos>0)     for(i=0;i<l-pos;i++)     z2[i]=z2[i+pos];      z2.resize(l-pos);     if(flag==0)     z2="0";     }    }   //cout<<"ans for"<<a<<"*"<<b<<endl<<z2<<endl;     return z2; }               int main() {               long long int u,l,p,flag,sub;      string a,b,c;      cin>>u;      while(u--)      {         cin>>a>>b;                sub=0;                if(a[0]=='-' && b[0]!='-')                sub=1;                else                if(a[0]!='-' && b[0]=='-')                sub=1;                if(a[0]=='-')                a=a.substr(1);                if(b[0]=='-')                b=b.substr(1);                c=mult(a,b);                flag=0;                l=c.length();                 if(sub==1)                                              printf("-");                     for(p=0;p<l;p++)                           {                  if(c[p]=='0' && flag==0)                                              continue;                                               else                                              {flag=1;                                                                                           printf("%c",c[p]);                                              }                           }                           if(flag==0)                           cout<<"0";                                              printf("\n");       } } 
#include<iostream> #include<map> #include<cstdio> #include<vector> #define rep(i,a,b) for(int i=a;i<b;i++) #define cin(n) scanf("%d",&n) #include<algorithm> #include<cstring> #define ill long long #define mod 1000000007   using namespace std; void computeLPSArray(char *pat, int M, int *lps); bool flag[500008]; void KMPSearch(char *pat, char *txt) {     int M = strlen(pat);     int N = strlen(txt);       // create lps[] that will hold the longest prefix suffix values for pattern     int *lps = (int *)malloc(sizeof(int)*M);     int j  = 0;  // index for pat[]       // Preprocess the pattern (calculate lps[] array)     computeLPSArray(pat, M, lps);       int i = 0;  // index for txt[]     while(i < N)     {       if(pat[j] == txt[i])       {         j++;         i++;       }         if (j == M)       {         //printf("Found pattern at index %d \n", i-j);         flag[i-1]=1;         j = lps[j-1];       }         // mismatch after j matches       else if(pat[j] != txt[i])       {         // Do not match lps[0..lps[j-1]] characters,         // they will match anyway         if(j != 0)          j = lps[j-1];         else          i = i+1;       }     }     free(lps); // to avoid memory leak }   void computeLPSArray(char *pat, int M, int *lps) {     int len = 0;  // lenght of the previous longest prefix suffix     int i;       lps[0] = 0; // lps[0] is always 0     i = 1;       // the loop calculates lps[i] for i = 1 to M-1     while(i < M)     {        if(pat[i] == pat[len])        {          len++;          lps[i] = len;          i++;        }        else // (pat[i] != pat[len])        {          if( len != 0 )          {            // This is tricky. Consider the example AAACAAAA and i = 7.            len = lps[len-1];              // Also, note that we do not increment i here          }          else // if (len == 0)          {            lps[i] = 0;            i++;          }        }     } }   int main() {     int t,m,n,i,j,k,l;     //cin(t);     t=1;     while(t--)     {         char s1[10008],s2[500019];         scanf("%s%s",&s1,&s2);         int dp[500009+9]={0};         memset(flag,0,sizeof(flag));         KMPSearch(s1,s2);         int len=strlen(s2),len2=strlen(s1); 		 		//for(i=0;i<len;i++)         //	cout<<flag[i]<<" ";         	         for(i=0;i<len;i++)         {             if(i>0)                 dp[i]=dp[i-1];             if(i>=len2-1&&flag[i])             {                 if(i>len2-1)                     dp[i]=(dp[i]+dp[i-len2])%mod;                 dp[i]=(dp[i]+1)%mod;             }         }         cout<<dp[len-1]<<"\n";     }     return 0; }  
#include<bits/stdc++.h> using namespace std;  int main() {  	int test,i; 	double ans[1000010]; 	 	ans[1]=0; 	ans[2]=1; 	ans[3]=1.5;  	for(i=4;i<1000010;i++) 	{ 		ans[i]=ans[i-1]+ans[i-2]+2; 		ans[i]/=2; 	} 	scanf("%d",&test);  	int x; 	for(i=0;i<test;i++) 	{ 		//cin>>x;                  scanf("%d",&x); 		printf("%0.6lf\n",ans[x]); 	} 	return 0; }     
#include<bits/stdc++.h> using namespace std; #define f first #define s second #define mp make_pair #define pb push_back #define ll long long int mark[100011],sz[100011],c[100011]; vector<int>adj[100011]; int p[100011]; multiset<int>s[100011]; multiset<int>::iterator it; void dfs(int u,int p1,int r) {     c[u]=min(c[u],r);     int mx=-1,loc=-1;     sz[u]=1;     for(int i=0;i<adj[u].size();i++)     {         int k=adj[u][i];         if(k==p1)             continue;         dfs(k,u,r);         sz[u]+=sz[k];         if(sz[k]>mx)         {             mx=sz[k];             loc=k;         }     }     if(mx==-1)     {         mark[u]=u;         if(c[u]>0)             s[u].insert(p[u]);         return;     }     mark[u]=mark[loc];     int t=mark[u];     for(int i=0;i<adj[u].size();i++)     {         int k=adj[u][i];         if(k==p1||k==loc)             continue;         int y=mark[k];         for(it=s[y].begin();it!=s[y].end();it++)             s[t].insert(*it);         //s[y].clear();     }     s[t].insert(p[u]);     while(s[t].size()>c[u])         s[t].erase(s[t].begin()); } int main() {     int n,i,j;     scanf("%d",&n);     for(i=1;i<=n;i++)         scanf("%d %d",&c[i],&p[i]);     for(i=0;i<n-1;i++)     {         int u,v;         scanf("%d %d",&u,&v);         adj[u].pb(v);         adj[v].pb(u);     }     dfs(1,-1,n);     ll ans=0LL;     for(set<int>::iterator it=s[mark[1]].begin();it!=s[mark[1]].end();it++)         ans+=*it;     printf("%lld\n",ans);     return 0; } 
#include<bits/stdc++.h> using namespace std; #define ll long long ll a[1003][1003],dp1[10003][1003],dp2[1003][1003]; int main() { 	int i,j,k,n,m,p; 	cin>>n>>m>>p; 	p=-p; 	for(i=0;i<=n+1;i++) 	for(j=0;j<=m+1;j++) 	{ 		dp1[i][j]=-1e9; 		dp2[i][j]=-1e9; 	} 	 	for(int i=1;i<=n;i++) 	{ 		for(int j=1;j<=m;j++) 		cin>>a[i][j]; 	} 	 	dp1[1][1]=a[1][1]; 	 	for(j=2;j<=m;j++) 	dp1[1][j]=dp1[1][j-1]+a[1][j]; 	 	for(i=2;i<=n;i++) 	dp1[i][1]=dp1[i-1][1]+a[i][1]; 	 	for(int i=2;i<=n;i++) 	{ 		for(int j=2;j<=m;j++) 		{ 			dp1[i][j]=max(dp1[i-1][j],dp1[i][j-1]) +a[i][j]; 		} 	} 	 	dp2[n][m]=a[n][m]; 	for(j=m-1;j>=1;j--) 	dp2[n][j]=dp2[n][j+1]+a[n][j]; 	 	for(i=n-1;i>=1;i--) 	dp2[i][m]=dp2[i+1][m]+a[i][m]; 	 	for(int i=n-1;i>=1;i--) 	{ 		for(int j=m-1;j>=1;j--) 		{ 			dp2[i][j]=max(dp2[i+1][j],dp2[i][j+1]) +a[i][j]; 		} 	} /*	cout<<endl; 	for(i=1;i<=n;i++) 	{ 		for(j=1;j<=m;j++) 		cout<<dp1[i][j]<<" "; 		cout<<endl; 	} 		cout<<endl; 	for(i=1;i<=n;i++) 	{ 		for(j=1;j<=m;j++) 		cout<<dp2[i][j]<<" "; 		cout<<endl; 	} 		cout<<endl; */		 	 	ll mx=dp2[1][1]; 	//cout<<"ans="<<ans<<endl; 	for(i=2;i<=n;++i)     {         for(j=2;j<=m;++j)         {                           if(j>=2 && i>=2) mx = max(mx,dp1[i][j-1]+a[i-1][j]+dp2[i][j]+p); // go up and come back             if(j>=2 && i>=2 && j<m) mx = max(mx,dp1[i][j-1]+a[i][j]+a[i-1][j]+dp2[i-1][j+1]+p);// go up then right                           if(i>=2 && j>=2) mx = max(mx,dp1[i-1][j]+a[i][j-1]+dp2[i][j]+p);// go left and come back             if(i>=2 && j>=2 && i<n) mx = max(mx,dp1[i-1][j]+a[i][j]+a[i][j-1]+dp2[i+1][j-1]+p); // go left then go down                           if(j>=2 &&i>=1&& i<n) mx = max(mx,dp1[i-1][j]+a[i][j]+a[i][j+1]+dp2[i+1][j]+p);//come right and go back                          if(j>=2 && i<n && j<m) mx = max(mx,dp1[i][j]+a[i+1][j]+dp2[i][j+1]+p);//come down and go back                                  }     } 	cout<<mx<<endl; }
 #include <bits/stdc++.h>  #define sc(x) scanf("%d",&x); #define sc2(x,y) scanf("%d%d",&x,&y); #define pr(x) printf("%d \n",x); #define scll(x) scanf("%lld",&x); #define scll2(x,y) scanf("lld",&x,&y); #define prll(x) printf("%lld \n",x); #define ll long long #define PII  pair<int,int>  using namespace std;  int mod=1e9 + 7;  struct tree {     int sum;     int l,r; } segtree[5000001]; inline tree merg(tree a,tree b){     tree c;     c.sum = ( a.sum | b.sum );     return c; } void buildtree(int i,int l,int r,int s[]) {     if(l==r)     {         segtree[i].sum=s[l];     //    cout<<i<<" "<<segtree[i].sum<<endl;         return;     }     buildtree( 2*i , l , (l+r)/2 , s );     buildtree( 2*i+1 , 1+(l+r)/2 , r , s );     segtree[i] = merg(segtree[2*i], segtree[2*i+1]);  //   cout<<i<<" "<<segtree[i].sum<<endl; } void updatetree(int i,int l,int r,int x,int y) {     if( l==x && r==x )     {         segtree[i].sum = y;         return;     }     else if( x <= (l+r)/2 ) updatetree( 2*i , l , (l+r)/2 , x , y );     else updatetree( 2*i+1 , (l+r)/2+1 , r , x , y );     segtree[i] = merg(segtree[2*i], segtree[2*i+1]); } tree query(int i,int l,int r,int c,int d) {     if( c==l && d==r ) return segtree[i];     else if( d <= (l+r)/2 ) return query( 2*i , l , (l+r)/2 , c , d );     else if( (l+r)/2 < c ) return query(2*i+1 , 1+(l+r)/2 , r , c , d);     else     {         tree a = query( 2*i, l , (l+r)/2 , c , (l+r)/2 );         tree b = query( 2*i+1 , 1+(l+r)/2 , r ,  1+(l+r)/2 , d );         tree mer;         mer = merg(a, b);         return mer;     } }   int ar[1000000+100];  ll p[1000000+100]; int main() {     p[0]=1;     int n,q;     sc2(n,q)     for(int i=0;i<n;i++){         sc(ar[i])         p[i+1]=(2*p[i])%mod;     }      buildtree(1,0,n-1,ar);     int x,l,r;     ll ans;     while(q--){         sc(x)sc2(l,r)         if(x==1){             ans = ((ll)query(1,0,n-1,l-1,r-1).sum * p[r-l])%mod;             prll(ans)         }         else{             updatetree(1,0,n-1,l-1,r);         }     }  } 
#include<iostream> #include<cstdio>   using namespace std;   int main(){     int tcs;     scanf("%d", &tcs);          while(tcs--){         int N, M;         int student_list[101] = {0};         int teacher_list[101] = {0};           scanf("%d", &M);         for(int i=0; i<M; i++)             scanf("%d", &student_list[i]);           scanf("%d", &N);         for(int i=0; i<N; i++)             scanf("%d", &teacher_list[i]);           int DIST[N+1][M+1];         for(int i=0; i<=M; i++)             DIST[0][i] = i;         for(int i=0; i<=N; i++)             DIST[i][0] = i;           for(int r=1; r<=N; r++){           for(int c=1; c<=M; c++){               if(student_list[c-1] == teacher_list[r-1]){                  DIST[r][c] = DIST[r-1][c-1];                } else {                  int min_val = min(DIST[r-1][c], DIST[r][c-1]);                  min_val = min(min_val, DIST[r-1][c-1]);                  DIST[r][c] = min_val+1;               }           }         }         /*         for(int r=0; r<=N; r++){           for(int c=0; c<=M; c++)               printf("%d", DIST[r][c]);           cout << endl;         }*/         printf("%d\n", DIST[N][M]);     }     return 0; } 
/*God is greater than any problem that u have and u have to not worry because when u pray and then worry, the worry nullify your prayer He is right here, right now !! */  #include <bits/stdc++.h> using namespace std; #define bitcnt __builtin_popcount #define ln length() #define rep(i, n) for(int i = 0; i < n; i++) #define rrep(i, n) for(int i = n - 1; i >= 0; i--) #define all(a)  a.begin(),a.end() #define LL long long #define limit 1000006 #define sl(n) scanf("%lld", &n) #define s(n)  scanf("%d", &n) #define pl(n) printf("%lld", n) #define pi(n)  printf("%d", n) #define pb push_back #define pn printf("\n") #define mod 1000000007 typedef vector<LL> row; typedef vector<row> matrix;  int in[26], out[26]; int graph[26][26]; int visited[26];  void print(LL *arr, LL n) { 	rep(i, n) cout << arr[i] << " "; 	cout << endl; }  bool check() { 	int flag = 0, flag1 = 0; 	rep(i, 26) { 		switch(in[i] - out[i]) { 			case 0 : 				break; 			case 1 : 				if(flag) return false; 				flag = 1; break; 			case -1 : 				if(flag1) return false;; 				flag1 = 1; break; 			default : 				return false; 		} 	} 	return true;	 }  void dfs(int v) { 	visited[v] = 1; 	rep(i, 26) { 		if(!visited[i] && graph[v][i]) { 			dfs(i); 		} 	} } bool fun() { 	if(!check()) return false; 	int i; 	//finding vectex 	for(i = 0; i < 26; i++) { 		if(in[i] != 0 || out[i] != 0) { 			break; 		} 	} 	//check whether from this vertex all vertices are visited are not 	dfs(i); 	int totalvertices = 0, visitedvertices = 0; 	rep(i, 26) if(visited[i]) visitedvertices++; 	rep(i, 26) if(in[i] != 0 || out[i] != 0) totalvertices++; 	return (totalvertices == visitedvertices); }  void solve() { 	//clearing step 	memset(in, 0, sizeof(in)); 	memset(out, 0, sizeof(out)); 	memset(graph, 0, sizeof(graph)); 	memset(visited, 0, sizeof(visited)); 	int n; 	s(n); 	char str[10005]; 	rep(i, n) { 		scanf("%s", str); 		int l = strlen(str); 		out[str[0] - 'a']++; 		in[str[l - 1] - 'a']++; 		graph[str[0] - 'a'][str[l - 1] - 'a']++; 		graph[str[l - 1] - 'a'][str[0] - 'a']++;	 	} 	bool ans = fun(); 	if(ans) { 		puts("The journey continues."); 	} 	else { 		puts("Journey ends here."); 	} }  int main() { 	int t; 	scanf("%d", &t); 	while(t--) { 		solve(); 	} 	return 0; } 
//#pragma warning (disable: 4786)  #include <sstream> #include <queue> #include <set> #include <map> #include <cstdio> #include <cstdlib> #include <cctype> #include <cmath> #include <iostream> #include <string> #include <vector> #include <algorithm> #include <bitset> #include <list> #include <string.h> using namespace std; #define print1(a)    cout<<a<<endl #define print2(a,b) cout<<a<<" "<<b<<endl #define print3(a,b,c) cout<<a<<" "<<b<<" "<<c<<endl #define oo          (1<<30) #define PI          3.141592653589793 #define pi          (2*acos(0)) #define ERR         1e-5 #define PRE         1e-8 #define SZ(s)       ((int)s.size()) #define LL          unsigned long long #define ISS         istringstream #define OSS         ostringstream #define VS          vector<string> #define VI          vector<int> #define VD          vector<double> #define VLL         vector<long long> #define SII         set<int>::iterator #define SI          set<int> #define mem(a,b)    memset(a,b,sizeof(a)) #define fr(i,a,b)   for(i=a;i<=b;i++) #define frn(i,a,b)  for(i=a;i>=b;i--) #define fri(a,b)    for(i=a;i<=b;i++) #define frin(a,b)   for(i=a;i>=b;i--) #define frj(a,b)    for(j=a;j<=b;j++) #define frjn(a,b)   for(j=a;j>=b;j--) #define frk(a,b)    for(k=a;k<=b;k++) #define frkn(a,b)   for(k=a;k>=b;k--) #define frl(a,b)    for(l=a;l<=b;l++) #define frln(a,b)   for(l=a;l>=b;l--) #define REP(i,n)    for(i=0;i<n;i++) #define EQ(a,b)     (fabs(a-b)<ERR) #define all(a,b,c)  for(int I=0;I<b;I++)    a[I] = c #define CROSS(a,b,c,d) ((b.x-a.x)*(d.y-c.y)-(d.x-c.x)*(b.y-a.y)) #define sqr(a)      ((a)*(a)) #define FORE(i,a)   for(typeof((a).begin())i=(a).begin();i!=(a).end();i++) #define typing(j,b) typeof((b).begin()) j=(b).begin(); #define BE(a)       a.begin(),a.end() #define rev(a)      reverse(BE(a)); #define sorta(a)    sort(BE(a)) #define pb          push_back #define popb        pop_back #define round(i,a)  i = ( a < 0 ) ? a - 0.5 : a + 0.5; #define makeint(n,s)  istringstream(s)>>n #define inpow(a,x,y) int i; a=x;fri(2,y)  a*=x #define cntbit(mask) __builtin_popcount(mask) #define debug_array(a,n) for(int i=0;i<n;i++) cerr<<a[i]<<" "; cerr<<endl; #define debug_matrix(mat,row,col) for(int i=0;i<row;i++) {for(int j=0;j<col;j++) cerr<<mat[i][j]<<" ";cerr<<endl;}  template<class T1> void debug(T1 e){cout<<e<<endl;} template<class T1,class T2> void debug(T1 e1,T2 e2){cout<<e1<<"\t"<<e2<<endl;} template<class T1,class T2,class T3> void debug(T1 e1,T2 e2,T3 e3){cout<<e1<<"\t"<<e2<<"\t"<<e3<<endl;} template<class T1,class T2,class T3,class T4> void debug(T1 e1,T2 e2,T3 e3,T4 e4){cout<<e1<<"\t"<<e2<<"\t"<<e3<<"\t"<<e4<<endl;} template<class T1,class T2,class T3,class T4,class T5> void debug(T1 e1,T2 e2,T3 e3,T4 e4,T5 e5){cout<<e1<<"\t"<<e2<<"\t"<<e3<<"\t"<<e4<<"\t"<<e5<<endl;} template<class T1,class T2,class T3,class T4,class T5,class T6> void debug(T1 e1,T2 e2,T3 e3,T4 e4,T5 e5,T6 e6){cout<<e1<<"\t"<<e2<<"\t"<<e3<<"\t"<<e4<<"\t"<<e5<<"\t"<<e6<<endl;} template<class T> void debug(vector< vector<T> > e,int row,int col){int i,j;REP(i,row) {REP(j,col) cout<<e[i][j]<<" ";cout<<endl;} cout<<endl;} template<class T> void debug(vector< basic_string<T> > e,int row,int col){int i,j;REP(i,row) {REP(j,col) cout<<e[i][j];cout<<endl;} cout<<endl;} template<class T> void debug(T e[110][110],int row,int col){int i,j;REP(i,row) {REP(j,col) cout<<e[i][j]<<" ";cout<<endl;}} template<class T> string toString(T n){ostringstream oss;oss<<n;oss.flush();return oss.str();} int toInt(string s){int r=0;istringstream sin(s);sin>>r;return r;} bool isVowel(char ch){ch=tolower(ch);if(ch=='a' || ch=='e' || ch=='i' || ch=='o' || ch=='u')return true;return false;} bool isUpper(char c){return c>='A' && c<='Z';} bool isLower(char c){return c>='a' && c<='z';} //*************************************************My Code Starts Here********************************************************************************* string Addition(string a,string b); //Addition any two string string Multiplication(string a,string b); //Multiplication between a and b string Multiplication(string a,int k);  //Multiplication between a and int k string Subtraction(string a,string b);  // Subtraction from a to b(a always >=b) string Division(string a,string b); //Division return a/b string Division(string a,int k);    //Division return a/k string Div_mod(string a,string b);  //Modulus of Division a%b int    Div_mod(string a,int k);     //Modulus of Division a%k string cut_leading_zero(string a);  //leading zero cut 001 -> 1 int    compare(string a,string b);  //(1 means a>b) (-1 means a<b) (0 means a=b) #define REV(i,n) for (i=n;i>=0;i--) #define FOR(i,p,k) for (i=p; i<k;i++)  string Multiplication(string a,string b) {     int i,j,multi,carry;     string ans,temp;      ans="0";     REV(j,SZ(b)-1)     {         temp="";         carry=0;         REV(i,SZ(a)-1)         {             multi=(a[i]-'0')*(b[j]-'0')+carry;             temp+=(multi%10+'0');             carry=multi/10;         }         if(carry)   temp+=(carry+'0');         rev(temp);         temp+=string(SZ(b)-j-1,'0');         ans=Addition(ans,temp);     }     ans=cut_leading_zero(ans);     return ans; } string Multiplication(string a,int k) {     string ans;     int i,sum,carry=0;      REV(i,SZ(a)-1)     {         sum=(a[i]-'0')*k+carry;         carry=sum/10;         ans+=(sum%10)+'0';     }     while(carry)    {ans+=(carry%10)+'0';carry/=10;}     rev(ans);     ans=cut_leading_zero(ans);     return ans; }  string Addition(string a,string b) {     int carry=0,i;     string ans;      if(SZ(a)>SZ(b)) b=string(SZ(a)-SZ(b),'0')+b;     if(SZ(b)>SZ(a)) a=string(SZ(b)-SZ(a),'0')+a;     ans.resize(SZ(a));     REV(i,SZ(a)-1)     {         int sum=carry+a[i]+b[i]-96;         ans[i]=(char)(sum%10+'0');         carry=sum/10;     }     if(carry)   ans.insert(0,string(1,carry+'0'));     ans=cut_leading_zero(ans);     return ans; }  string Subtraction(string a,string b) {     int borrow=0,i,sub;     string ans;     if(SZ(b)<SZ(a)) b=string(SZ(a)-SZ(b),'0')+b;     REV(i,SZ(a)-1)     {         sub=a[i]-b[i]-borrow;         if(sub<0)         {             sub+=10;             borrow=1;         }         else borrow=0;         ans+=sub+'0';     }     rev(ans);     ans=cut_leading_zero(ans);     return ans; }  string Division(string a,string b) {     string mod,temp,ans="0";     int i,j;      REP(i,SZ(a))     {         mod+=a[i];         mod=cut_leading_zero(mod);         FOR(j,0,10)         {             temp=Multiplication(b,j);             if(compare(temp,mod)==1)                 break;         }         temp=Multiplication(b,j-1);         mod=Subtraction(mod,temp);         ans+=(j-1)+'0';     }     mod=cut_leading_zero(mod);     ans=cut_leading_zero(ans);     return ans; }  string Division(string a,int k) {     int i,sum=0;     string ans="0";      REP(i,SZ(a))     {         sum=(sum*10+(a[i]-'0'));         ans+=(sum/k)+'0';         sum=sum%k;     }     ans=cut_leading_zero(ans);     return ans; }  string Div_mod(string a,string b) {     string mod,temp,ans="0";     int i,j;      REP(i,SZ(a))     {         mod+=a[i];         mod=cut_leading_zero(mod);         FOR(j,1,10)         {             temp=Multiplication(b,j);             if(compare(temp,mod)>0)                 break;         }         temp=Multiplication(b,j-1);         mod=Subtraction(mod,temp);         ans+=(j-1)+'0';     }     mod=cut_leading_zero(mod);     ans=cut_leading_zero(ans);     return mod; }  int Div_mod(string a,int k) {     int i,sum=0;      REP(i,SZ(a))         sum=(sum*10+(a[i]-'0'))%k;     return sum; }  int compare(string a,string b) {     int i;     a=cut_leading_zero(a);     b=cut_leading_zero(b);     if(SZ(a)>SZ(b)) return 1;   //bigger     if(SZ(a)<SZ(b)) return -1;  //smaller     REP(i,SZ(a))         if(a[i]>b[i])   return 1;   //bigger         else if(a[i]<b[i])  return -1; //smaller     return 0;   //equal }  string cut_leading_zero(string a) {     string s;     int i;     if(a[0]!='0')   return a;     REP(i,SZ(a)-1)  if(a[i]!='0')   break;     FOR(i,i,SZ(a))  s+=a[i];     return s; }  string gcd(string a,string b) {     if(b=="0") return a;     return gcd(b,Div_mod(a,b)); }  void make(string a,string b) {     if(a=="1")     {         print1(b);         return;     }      string x=Division(b,a);     if(Div_mod(b,a)!="0") x=Addition(x,"1");     cout<<x<<" ";      string numo=Subtraction(Multiplication(a,x),b);     string deno=Multiplication(b,x);     string d=gcd(numo,deno);     numo=Division(numo,d);     deno=Division(deno,d);     make(numo,deno); }   int main() {     string a,b;     while(cin>>a>>b)     {         if(a=="1"&&b=="1") break;         make(a,b);     }     return 0; } 
#include <bits/stdc++.h>  using namespace std;  const int N = 505; int sz;  vector < int > adj[N]; int color[N];  void reset () { 	for (int i = 0; i < N; i++) 		adj[i].clear (); }  bool dfs (int v, int col) { 	sz++; 	color[v] = col; 	for (int i = 0; i < adj[v].size (); i++) 		if (color[adj[v][i]] == -1) 		{ 			if (!dfs (adj[v][i], col ^ 1)) 				return false; 		} 		else if (color[adj[v][i]] == col) 			return false; 	return (sz >= 2); }  bool Check (int n) { 	memset (color, -1, sizeof (color)); 	int cnt = 0; 	bool bp = false; 	for (int i = 0; i < n; i++) 		if (color[i] == -1) 		{ 			cnt++; 			sz = 0; 			bp |= dfs (i, 0); 		} 	return (bp & cnt >= 2); }  int main () { 	int T, n, m, x, y; 	cin >> T; 	while (T--) 	{ 		cin >> n >> m; 		reset (); 		for (int i = 0; i < m; i++) 		{ 			cin >> x >> y; 			adj[x].push_back (y); 			adj[y].push_back (x); 		} 		if (Check (n)) 			cout << "YES" << endl; 		else 			cout << "NO" << endl; 	} 	return 0; }
/* author :  R Anirudh  */  #include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <cstring> #include <queue> #include <cassert> #include <climits> #include <limits> using namespace std; #define SIZE(A) ((int)(A.size())) #define MSET(A,x) memset(A,x,sizeof(A)); #define FILL(A,x) fill(A.begin(),A.end(),x) #define REP(i,N) for(int i=0;i<(int)(N);i++) #define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++) #define REV(i,a,b) for(int i=(int)(a);i>=(int)(b);i--) #define TR(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) #define ALL(x) x.begin(),x.end() #define INF (INT_MAX/2) #define LLINF (LONG_LONG_MAX/2LL) #define EPS 1e-12 #define GI ({int t;scanf("%d",&t);t;}) #define GL ({long long t;scanf("%lld",&t);t;}) #define GF ({double t;scanf("%lf",&t);t;}) #define bitCount(n) __builtin_popcount(n) #define MOD 10000009 #define MAXN 1000005 #define FIX(a) (((a)%MOD+MOD)%MOD) typedef long long LL; typedef unsigned long long ULL; #define pb push_back  list<int> *adj; bool *visited; int *costs; int component; list<int> *paths;  void dfs_util(int);  void dfs(int n){ component=0; FOR(i,0,n){ if(!visited[i]){ dfs_util(i); component++; } } }  void dfs_util(int v){  visited[v]=true; paths[component].pb(v); list<int>::iterator it; for(it=adj[v].begin();it!=adj[v].end();it++){  if(!visited[*it]){   dfs_util(*it); } } }   int main(){   int t; cin>>t; while(t--){ int n; LL m; scanf("%d %lld",&n,&m); adj = new list<int>[n]; visited = new bool[n]; costs = new int[n]; paths = new list<int>[n]; FOR(i,0,n){ visited[i]=false; } FOR(i,0,n){ scanf("%d",&costs[i]); } FOR(i,0,m){ int a,b; scanf("%d %d",&a,&b); a--; b--; adj[a].pb(b); adj[b].pb(a); }  dfs(n); LL total=0; list<int>::iterator it; FOR(i,0,component){ int min=INT_MAX;  for(it=paths[i].begin();it!=paths[i].end();it++){ if(costs[*it]<min){   min=costs[*it]; } } total+=min; }   printf("%lld\n",total); } return 0; } 
#include<iostream> #include<algorithm> #include<stdio.h> #include<stdlib.h> #include<string.h> #include<math.h>  using namespace std; typedef long long int llint; template <typename customDataType> void fastread(customDataType * a) {     char c=0; *a=0;     while(c<33){c=getchar_unlocked();}     while(c>33){*a=(*a<<3)+(*a<<1)+c-'0'; c=getchar_unlocked();}     return; }//fastread ends   int main() {     int numberOfPlanes,minToWish,seconds,xtemp,ytemp,tupdate;     int ppos_x[10000];     int ppos_y[10000];     int xchange[10000];     int ychange[10000];     float radius[10000];     fastread(&numberOfPlanes);     fastread(&minToWish);     float rmin=0,rmin_in;      for(int i=0;i<numberOfPlanes;++i)     {         fastread(&ppos_x[i]);         fastread(&ppos_y[i]);         fastread(&xchange[i]);         xchange[i] -= ppos_x[i];    //Xf-Xi;         fastread(&ychange[i]);         ychange[i]-= ppos_y[i];    //Yf-Yi;         radius[i] = sqrt(pow((llint)ppos_x[i],2)+pow((llint)ppos_y[i],2));     }      rmin=3000;     for(seconds=0;seconds<=1000;++seconds)     {         rmin_in=0;         for(int i=0;i<numberOfPlanes;++i)         {             xtemp = ppos_x[i] + xchange[i]*seconds;             ytemp = ppos_y[i] + ychange[i]*seconds;             radius[i] = sqrt(pow((llint)xtemp,2)+pow((llint)ytemp,2));         }         sort(radius,radius+numberOfPlanes);         rmin_in=radius[minToWish-1];         if(rmin > rmin_in)         {             rmin = rmin_in;             tupdate=seconds;         }     }     printf("%.2f\n%d\n",rmin,tupdate);     return 0; } 
/*   Name: Shed Problem   Copyright:    Author: Shobhit Saxena   Date: 17/12/12 21:37   Description: Dynamic solution of the shed problem. This algo takes O(lb) to solve the matrix. Better than the naive algorithm tht takes O(l^2 b^2).  */    #include<stdio.h>  #define MAX 1000  #define GETCHAR getchar//_unlocked  #define min(a,b,c) (a<b?(a<c?a:c):(b<c?b:c))  int matrix[1000][1000]; int main() {     int r,c;     char temp;          scanf("%d %d ",&r,&c);     int max=0;          for(int i=0;i<r;i++)     {             for(int j=0;j<c;j++)             {                     scanf(" %c",&temp);                     if(temp=='T') matrix[i][j]=0;                     else if(temp=='.')                     {                          if(!i||!j) matrix[i][j]=1;                          else                           {                               matrix[i][j]=1+min(matrix[i][j-1],matrix[i-1][j],matrix[i-1][j-1]);                                   }                               }                     max=max>matrix[i][j]?max:matrix[i][j];                                                   }               }     printf("%d\n",max?(max*max):-1);     return 0; } 
// This works!! //Data-structures includes #include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<string>   //Other Includes #include<iostream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath>  using namespace std;  #define pb		push_back #define mp	 	make_pair #define fill(a,v) 	memset(a, v, sizeof(a)) #define sz		size() #define all(x)		x.begin(), x.end() #define INDEX(arr,ind)	(lower_bound(all(arr),ind)-arr.begin()) #define FF		first #define SS		second #define T(t)            int t;scanf ("%d",&t);while (t--) typedef vector<int> VI; typedef vector<vector<int> > VVI; typedef long long LL; typedef vector<long long> VLL; typedef pair<int,int> PII; typedef vector<pair<int,int> > VPII; typedef pair<double,double> pdd;  int main() { 	int n; 	int i,j,k,flag=0,len;	 	char arr[111][111]; 	scanf ("%d",&n); 	for (i=0;i<n;i++) 		scanf ("%s",arr[i]); 	while (1) 	{ 		char s[111]; 		scanf ("%s",s); 		if (s[0]=='0') break; 		len=strlen(s); 		int pr=0; 		for (i=0;i<n;i++) 		{ 			for (j=0;j<n;j++) 			{ 				flag=0; 				if (n-j>=len) 				{ 					for (k=0;k<len;k++){ 						if (arr[i][j+k]!=s[k]){ 							flag=1;break;} 					} 					if (flag==0 && pr==0){  						printf ("%d,%d %d,%d\n",i+1,j+1,i+1,j+len); 						pr=1; 					} 				} 				flag=0; 				if (j+1>=len) 				{ 					for (k=0;k<len;k++){ 						if (arr[i][j-k]!=s[k]){ 							flag=1;break;} 					} 					if (flag==0 && pr==0){ 						printf ("%d,%d %d,%d\n",i+1,j+1,i+1,j+2-len); 						pr=1; 					} 				} 				flag=0; 				if (n-i>=len) 				{ 					for (k=0;k<len;k++){ 						if (arr[i+k][j]!=s[k]){ 							flag=1;break;} 					} 					if (flag==0 && pr==0){ 						printf ("%d,%d %d,%d\n",i+1,j+1,i+len,j+1); 						pr=1; 					} 				} 				flag=0; 				if (i+1>=len) 				{ 					for (k=0;k<len;k++){ 						if (arr[i-k][j]!=s[k]){ 							flag=1;break;} 					} 					if (flag==0 && pr==0){ 						printf ("%d,%d %d,%d\n",i+1,j+1,i+2-len,j+1); 						pr=1; 					} 				} 				flag=0; 				if (n-i>=len && n-j>=len) 				{ 					for (k=0;k<len;k++){ 						if (arr[i+k][j+k]!=s[k]){ 							flag=1;break;} 					} 					if (flag==0 && pr==0){ 						printf ("%d,%d %d,%d\n",i+1,j+1,i+len,j+len); 						pr=1; 					} 				} 				flag=0; 				if (j+1>=len && i+1>=len) 				{ 					for (k=0;k<len;k++){ 						if (arr[i-k][j-k]!=s[k]){ 							flag=1;break;} 					} 					if (flag==0 && pr==0){ 						printf ("%d,%d %d,%d\n",i+1,j+1,i+2-len,j-len+2); 						pr=1; 					} 				} 				if (pr==1) break; 			} 			if (pr==1) break; 		} 		if (pr==0) printf ("Not found\n"); 	} 	return 0; } 
#include <stdio.h> #include <stdlib.h> #include <math.h> #include <string.h> #include <algorithm>  #define N 200 #define K 20  int n, l[N], f[N], fm; char b[N][K], *p[N]; #define MIN(a,b) ((a)<(b)?(a):(b))  int comp(const void *a, const void *b) {     int d = strlen(*(char**)b) - strlen(*(char**)a);     if(d != 0) return d;     return strcmp(*(char**)a, *(char**)b); }  bool hopr(const char *a, const char *b) { char rep = 0; bool seen = false; for(int i = 0; a[i]; i++) { if(b[i] == rep) seen = true; if(a[i] != b[i]){ if(rep || a[i] > b[i]) return false; rep = b[i]; } } return seen; }  bool hopd(const char *a, const char *b) { int i; for(i = 0; a[i] == b[i]; i++); for(i++; a[i]; i++) if(a[i] != b[i-1]) return false; return true; }  int main() { scanf("%d", &n); for(int i = 0; i < n; i++) { scanf("%s", b[i]); p[i] = b[i]; } qsort(p, n, sizeof(char*), comp);  for(int i = 0; i < n; i++) l[i] = strlen(p[i]); fm = 0; for(int i = n-1; i >= 0; i--) { f[i] = 1; for(int j = i+1; j < n && l[i] - l[j] <= 1; j++) { if(((l[i]==l[j] && hopr(p[i], p[j])) || (l[i]==l[j]+1 && hopd(p[i],p[j]))) && f[i] < f[j]+1) f[i] = f[j]+1; } if(f[i] > fm) fm = f[i]; } printf("%d\n", fm); //system("pause"); return 0; } 
#include<cstdio> void getdata(int *arry , int size); void display(int *arry , int size); int result(int *input , int size);  int main() {   int output[1000];int ctr=0;   int coins;   scanf("%d " ,&coins);   while( coins>0)   {     int *input = new int[coins];     getdata(input , coins);     output[ctr]=result(input , coins);     ctr++;     scanf("%d ",&coins);   }   display(output , ctr);   return 0; }  int result(int *input , int size) {    int add=1;int count=0;    if(size==1)      return 1;    for(int i=1;i<size-1;i++)    {       if((add+input[i])<input[i+1])       { 	 add+=input[i]; 	 count++;       }    }    return (count+2); }  void getdata(int *arry , int size) {     for(int i=0;i<size;i++)    {      scanf("%d  " , &arry[i]);          } }  void display(int *arry , int size) {    for(int i=0;i<size;i++)    {      printf("%d\n" , arry[i]);    } }      
    #include<iostream>     #include<cstring>     #include<cmath>     #include<vector>     #include<map>     using namespace std;     static int factor(int a,int b)     {     	int co=0;  	   while(b*b <= a)     	{     		if(a%b==0)     		co+=factor(a/b,b);     		b++;     	}     	return co+1;     }     int main(void)     {     	while(1)     	{     		int n,c;     		cin>>n;     		if(n==0)     			break;     		c = factor(n,2);     		cout<< c-1 << endl;     	}     	return 0;     } 
#include<stdio.h> #include<algorithm> using namespace std; int main() { 	int n,a[50],i,j,l,b[50],count; 	while(scanf("%d",&n)) 	{ 		if(!n) 			break; 		for(i=0;i<n;i++) 			scanf("%d",&a[i]); 		sort(a,a+n); 		 		j=n/2-1; 		l=n-1; 		for(i=0;j>=0;) 		{ 			b[i]=a[j]; 			b[i+1]=a[l]; 			i = i+2; 			j--; 			l--; 		} 		b[i]=a[n/2]; 		count =0; 		for(i=1;i<n;i++) 		{ 			count += abs(b[i]-b[i-1]); 		} 		printf("%d\n",count); 	} 	return 0; }
// A Negative Base Problem // URL : http://www.codechef.com/problems/ENCD05 #include <iostream> #include <cstdio> #include <cstring> #include <algorithm>  using namespace std;  typedef long long ll; typedef unsigned long long ull;  string tonegbin(int x) { 		 string res = ""; 		 while(x != 0) 		 { 					if(((int)abs(x)) % 2 == 1) 					{ 						  res = "1" + res; 						  x = (x - 1) / -2; 			  		} 			  		else 			  		{ 						 res = "0" + res; 						 x /= -2; 			 	  	} 		 } 		 return res; }  int main() { 	 int n; 	 while(scanf("%d",&n) > 0) 	 { 					if(n == 0)break;   				  cout << tonegbin(n) << endl; 	 } 	 system("pause"); 	 return 0; }
#include<cstdio> #define max(a,b) ( ((a)>(b)) ? (a):(b)) int a[101][101],b[101][101]; int main() { 	int n; 	while(scanf("%d",&n)!=EOF) 	{ 		if(!n)break; 		for(int i=0;i<n;i++)for(int j=0;j<n;j++) 		{ 			scanf("%d",&a[i][j]); 			b[i][j] = (j==0)?a[i][j]:(b[i][j-1]+a[i][j]); 		} 		int maxsum = 0; 		for(int c1=0;c1<n;c1++)for(int c2=c1;c2<n;c2++) 		{ 			int temp = 0; 			for(int r=0;r<n;r++) 			{ 				temp = max(0,temp+(b[r][c2] - (c1==0?0:b[r][c1-1]) )); 				maxsum = max(maxsum,temp);  			} 		} 		printf("%d\n",maxsum); 	} } 
#ifndef PROGRAMMING_CONTESTS_H #define PROGRAMMING_CONTESTS_H #include <algorithm> #include <bitset> #include <cctype> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <iostream> #include <limits> #include <list> #include <map> #include <queue> #include <set> #include <sstream> #include <string> #include <typeinfo> #include <utility> #include <vector> #ifdef LOCALHOST static FILE* _freopen=freopen("input.txt","r",stdin); #else #define NDEBUG #endif #include <cassert> using namespace std;   typedef long long LL; typedef unsigned long long ULL; typedef pair<int,int> PII;   #define IT(c) typeof(c.begin()) #define PB push_back #define MP make_pair #define LEN(a) (sizeof(a)/sizeof(a[0])) #define ALL(c) c.begin(),c.end() #define FOR(i,a,b) for(int i=(a), _b=(b); i<_b; ++i) #define FORD(i,a,b) for(int i=(b-1), _a=(a); i>=_a; --i) #define FORE(i,c) for(IT(c) i=(c).begin(); i!=(c).end(); ++i)   static int RI(){int res;int r=scanf("%d ",&res);assert(r==1);return res;} static LL RLL(){LL res;int r=scanf("%lld ",&res);assert(r==1);return res;} static ULL RULL(){ULL res;int r=scanf("%llu ",&res);assert(r==1);return res;} static double RD(){double res;int r=scanf("%lf ",&res);assert(r==1);return res;} static string RS(){char buf[2000];int r=scanf("%s ",buf);assert(r==1);return string(buf);} static string RL(){string res;getline(cin,res);assert(cin.good());return res;} //Requires and discards line break at end of line. static const double PI=acos(-1.0), EPS=1e-10; template<typename T> static string str(T x){stringstream ss;ss<<x;return ss.str();} template<typename A,typename V> static void fill(A& a,V v){fill_n((V*)a,sizeof(a)/sizeof(v),v);} // Requires A is a V array. static double timer(){return 1.0*clock()/CLOCKS_PER_SEC;}   #endif //PROGRAMMING_CONTESTS_H     static int** comb(int n, int m=numeric_limits<int>::max()) {   assert(n >= 0 && m >= 1);   int** c = new int*[n+1];   for(int i = 0; i <= n; ++i) {     c[i] = new int[n+1]; memset(c[i],0,sizeof(c[i]));     c[i][0] = (c[i][i] = 1);     for(int j = 1; j <= i/2; ++j) {       c[i][j] = (c[i][i-j] = (c[i-1][j-1]+c[i-1][j])%m);       assert(0 <= c[i][j] && c[i][j] < m);     }   }   return c; }     LL mem[15][55][55][55];   int main(int argc, char** argv) {   int** ch=comb(15);   int n,a,b,c;   while(true){     cin>>n>>a>>b>>c;     if(n==0)break;     FORD(i,1,n+2){       FOR(aa,0,a+1){         FOR(bb,0,b+1){           FOR(cc,0,c+1){             LL res=0;             if(i==n+1)res=1;             else {               //use 1 char               if(aa>=i)res+=mem[i+1][aa-i][bb][cc];               if(bb>=i)res+=mem[i+1][aa][bb-i][cc];               if(cc>=i)res+=mem[i+1][aa][bb][cc-i];               //use 2 chars               if(i%2==0){                 if(aa>=i/2&&bb>=i/2)res+=ch[i][i/2]*mem[i+1][aa-i/2][bb-i/2][cc];                 if(aa>=i/2&&cc>=i/2)res+=ch[i][i/2]*mem[i+1][aa-i/2][bb][cc-i/2];                 if(bb>=i/2&&cc>=i/2)res+=ch[i][i/2]*mem[i+1][aa][bb-i/2][cc-i/2];                                                         }               //use 3 chars               if(i%3==0&&aa>=i/3&&bb>=i/3&&cc>=i/3)res+=ch[i][i/3]*ch[2*i/3][i/3]*mem[i+1][aa-i/3][bb-i/3][cc-i/3];             }             mem[i][aa][bb][cc]=res;           }         }       }     }     cout<<mem[1][a][b][c]<<endl;   }   return 0; }
#include<iostream> #include<stdio.h> int main() { 		 long long int n,cnt; 		 while(true) 		 	{ 		 	    scanf("%lld",&n); 		 	    if(n==0){break;} 		 	if(n%2==0) 		 		{ 		 		    cnt=(n*(n-2)*(2*n-5))/24; 		 		} 		 	else 		 		{ 		 		    cnt=((n-1)*(n-3)*(2*n-1))/24; 		 		} 		 		printf("%lld\n",cnt); 		 	}     return 0; } 
#include <iostream> #include <cstdlib>  using namespace std;  struct column { 	int *array; 	struct column *next; };  typedef struct column col;  int compare(int b[], int v[], int N);  int main() { 	int N; 	int i; 	int j; 	int count; 	int pattern = 0; 	int done = 0; 	int v[1000]; 	int *a; 	int *b; 	col *head; 	col *ptr;  	cin >> N;  	while(N != 0) { 		cin >> i >> j; 		pattern = j; 		head = new col; 		count = 0; 		 		b = (int *) malloc(sizeof(int) *  N); 		b[0] = b[N - 1] = 1;  		for(int loop = 0; loop < N; loop++) { 			cin >> v[loop]; 		}  		head -> array = a = v; 		head -> next = NULL; 		count++; 		 		ptr = head;  		for(count = 2; count <= j; count++) { 			for(int index = 1; index < N - 1; index++) { 				b[index] = (b[index - 1] * a[index + 1] + 1) / a[index]; 				if(count == j && (index + 1) == i) { 					cout << b[index] << endl; 					done = 1; 					break; 				} 			}  			if(done == 1) { 				done = 0; 				break; 			} 			if(compare(b,v,N)) { 				ptr -> next = new col; 				ptr = ptr -> next; 				ptr -> array = b; 				ptr -> next = NULL; 				a = b; 				b = (int *) malloc(sizeof(int) * N); 				b[0] = b[N - 1] = 1; 			} 			else { 				pattern = count - 1; 				j = j % pattern; 				if(j == 0) { 					j = pattern; 				} 				ptr = head; 				while(j != 1) { 					ptr = ptr -> next; 					j--; 				} 				cout << ptr -> array[i - 1] << endl; 				break; 			}  		}  		while(head != NULL) { 			ptr = head; 			head = head -> next; 			free(ptr); 		} 		 		cin >> N;  	}  	return 0; }  int compare(int b[], int v[], int N) { 	for(int i = 0; i < N; i++) { 		if(b[i] != v[i]) { 			return 1; 		} 	}  	return 0; } 
//DS includes #include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<bitset> #include<complex>  //Other Includes #include<sstream> #include<fstream> #include<iostream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath>    #define oo 					(int)13e7 #define s(n)					scanf("%d",&n) #define sl(n) 					scanf("%lld",&n) #define sf(n) 					scanf("%lf",&n) #define fill(a,v) 				memset(a, v, sizeof a) #define ull 					unsigned long long #define ll 						long long #define bitcount 			__builtin_popcount #define all(x) 				x.begin(), x.end() #define pb( z ) 				push_back( z ) #define gcd					__gcd using namespace std;  int n; //prev = 0 not connected left thing //prev = 1 connected left thing ull dp[64][2]; int vis[64][2], vid; ull solve( int p, int prev ) { 	//cout<< n << " " << p << " " << prev << endl; 	if( p==n-1 ) 	{ 		if( prev == 0 ) 			return 1LL; 		return 2LL; 	} 	ull &d = dp[p][prev]; 	int& v = vis[p][prev]; 	if( v == vid ) 		return d; 	ll ret = 0; v = vid; 	if( prev == 0 ) 	{ 		ret = solve( p+1, 1 ) + solve( p+1, 0 ); 	} 	else  	{ 		ret = 2*solve( p+1, 1 ) + solve( p+1, 0 ); 	} 	return d=ret; }  int main() { 	 	while( cin>>n ) 	{ 		if( !n ) break; 		fill( dp, -1 ); 		++vid; 		cout<< solve( 0, 0 ) << endl; 	} 	return 0; } 
/*Author: raunakrocks Raunak Talwar Final Year CSE'15  MNNIT-Allahabad raunaktalwar00@gmail.com */ #include<bits/stdc++.h> using namespace std; typedef long long ll; #define MAXI 100005 //#define inp(n) scanf("%lld",&n) //for codeforces :P #define FOX(i,n) for(ll i=0;i<n;i++) #define FOX1(i,n) for(ll i=1;i<=n;i++) #define FOX2(i,n) for(ll i=n;i>=1;i--)  #define pb push_back #define sf scanf #define pf printf #define MOD 1000000007 #define gc getchar_unlocked void inp(ll &n) { 	n=0; 	char ch=gc(); 	ll sign=1; 	while(ch<'0'||ch>'9') 	{ 		if(ch=='-') 			sign=-1; 		ch=gc();		 	}	 	while(ch>='0'&&ch<='9') 		{ 			n=(n<<3)+(n<<1)+(ch-'0'); 			ch=gc(); 		} 		n*=sign; } ll mini(ll a,ll b){ return a>b?b:a; } ll maxi(ll a,ll b){ return a>b?a:b; } /**my n^2 algo for the problem :P ****/ char s[MAXI]; ll h[MAXI]; void solve() { 	ll l=strlen(s); 	ll ans=0; 	memset(h,0,sizeof h); 	for(ll i=0;i<l;i++) 		h[s[i]]++; 	ll cnt=0; 	//cnt will count the number of char that occur odd # of times :P 	for(ll i='a';i<='z';i++) 	{ 		if(h[i]&1) 			cnt++; 	}		 	if(cnt>1) 	{ 		printf("Impossible\n"); 		return; 	} 	ans=0; 	for(ll i=0;i<l/2;i++) 	{ 	 		ll j=l-1-i; 		if(s[i]!=s[j]) 		{ 			//two possiblity  			ll p,q; 			for(p=j;s[i]!=s[p];p--); 			for(q=i;s[j]!=s[q];q++); 			if(j-p<q-i) 			{ 				ans=(ans+(j-p)); 				for(ll k=p;k<j;k++) 					s[k]=s[k+1]; 			 			 			} 			else 			{ 				ans=(ans+(q-i)); 				for(ll k=q;k>i;k--) 					s[k]=s[k-1]; 			} 		} 	 	} 	printf("%lld\n",ans);    }    int main() { 	clock_t startTime=clock(); 	/******START: code here*********/ 	while(cin>>s) 	{ 		if(s[0]=='0') 			break; 		solve();	  	}  	/******END:code here**********/ 	clock_t endTime=clock(); 	cerr<<"\nTime:"<< double(endTime - startTime) / CLOCKS_PER_SEC <<" seconds\n" ; 	return 0; }     
#include<iostream> #include<stdio.h> #include<string.h> #include<algorithm> #include<math.h> #include<iomanip> #include<stdlib.h> using namespace std;  long long int t,n,sum,i; int main() {     scanf("%lld",&t);     while(t--)     {   sum=0;         scanf("%lld",&n);         for(i=1;i<=n;i++)         {             sum+=(i/2);         }         printf("%lld\n",sum);     }     return 0; } 
#include<iostream>   #define MAX 200000   using namespace std;   int a[MAX]; int lefty[MAX]; int righty[MAX];   int main() {     int i,n,q,x,y,max;     scanf("%d",&n);     for(i=0;i<n;i++)     {          scanf("%d",&a[i]);     }     scanf("%d",&q);     max=a[0];     lefty[0]=max;     for(i=1;i<n;i++)     {                if(a[i]>max)                {                            max=a[i];                }                     lefty[i]=max;     }     max=a[n-1];     righty[n-1]=max;     for(i=n-1;i>=0;i--)     {          if(a[i]>max)          {                      max=a[i];          }          righty[i]=max;     }             for(i=0;i<q;i++)     {         scanf("%d%d",&x,&y);         max=0;         if(x>1 && y<n)         {                 if(lefty[x-2]>righty[y])                 {                   max=lefty[x-1];                   //cout<<x-1<<":";                 }                 else                 {                    max=righty[y];                    //cout<<y<<":";                 }         }                         else if(x>1 && y==n)         {              max=lefty[x-2];         }         else if(x==1 && y<n)         {              max=righty[y];         }         printf("%d\n",max);     }     return 0; }
#include<iostream> using namespace std;  int main() {     int t;     char yy;     string y;     int T,D,len;      scanf("%d",&t);     cin.get(yy);     while(t--)     {          getline(cin,y);          len=y.length();          T=D=-1;          if(y[0]=='D' || y[len-1]=='T')          goto end;          while(y[++D]!='D' &&  D<len){}              while(y[++T]!='T' && T<len){}     //     cout<<T<<" "<<D<<endl;          while(D!=len && T!=len)          {              while(y[++D]!='D' && D<len){}              while(y[++T]!='T' && T<len){}       //       cout<<T<<" "<<D<<endl;                if(D<T)                goto end;              }              if(D==len && T==len)              printf("YES\n");              else              printf("NO\n");              continue;              end:                  printf("NO\n");              }       //       system("pause");              return 0;              }                                                 
#include<iostream> #include<bitset> #include<cstdio> #include<vector> #include<algorithm> #include<cmath> using namespace std; typedef long long int LL;   const int N = 53000; bitset<N+5> v; void seive(){     v.set();     for(int i =2;i<=N;i+=2)v[i] = 0;     v[0]=v[1] = 0;v[2]=1;     int val = sqrt(N);     for(int i =3;i<=val+1;i+=2){         if(v[i])         for(int j = i*i;j<=N;j+=(i+i)){             v[j] = false;         }     } }   LL next(int n ){     LL i,j;     for(i =n+1;i<=N;i++){         if(v[i])break;     }     for(j=i+1;j<=N;j++){         if(v[j])break;     }     return i*j; }   int main(){     int T;     seive();     scanf("%d",&T);     while(T--){         int n;         scanf("%d",&n);         LL res = next(n);         printf("%lld\n",res);     }     return 0; }      
//CODE COPY  #include <stdio.h> #include<string.h> #define MAXN 100010 #include<iostream>  using namespace std;  bool p[MAXN]; int phi[MAXN], sm[MAXN], mb[MAXN]; long long r[MAXN];  void calc() {     int i, j, k;     memset(p,0,sizeof(p));     memset(phi,0,sizeof(phi));     for( i=1 ; i<MAXN ; i++ )     {         mb[i]=1;     }        for( i=2 ; i<MAXN ; i++ )     {         if( p[i]==0 )         {             for( j=i ; j<MAXN ; j+=i )             {                 mb[j]*=-1;                 p[j]=1;             }             p[i]=0;             if( i<1000 )             {                 for( j=i*i ; j<MAXN ; j+=i*i )                 {                     mb[j]=0;                 }             }         }     }      r[1]=1;     for( i=2 ; i<MAXN ; i++ )     {         if( mb[i]!=0 )         {             k=0;             for( j=i ; j<MAXN ; j+=i )             {                 k+=(mb[j]!=0);                 phi[j]+=mb[i]*k;             }              r[i]=2*(i+phi[i]);         } // //        if( mb[i]!=0 ) //        { // //        }         else         {             r[i]=2*i-1; // square er jonno, se nije zero         }         r[i]+=r[i-1];     }  // //    for(int i=2;i<=20;i++) //    { //        cout<<i<<" "<<i+phi[i]<<endl; //    } //    cout<<endl; }  void precal() {     calc(); }  int main() {     int t, n;      precal();      scanf("%d",&t);      while(t--)     {         scanf("%d",&n);         printf("%lld\n",r[n]);     }     return 0; } 
#include<stdio.h> #include<list>  using namespace std;  int n,L,q,temp,i,x,y,v,r,j,k; int virlist[100000]; void qsort(int a[],int l,int r); void swap(int &a,int &b); int part(int a[],int l,int r); int binsearch(int num); list<int> virus; list<int>::iterator it;  int main() {     scanf("%d",&n);     for(i=0;i<n;i++)     {          scanf("%d",&temp);          virlist[i]=temp;          virus.push_back(temp);     }     qsort(virlist,0,n-1);     scanf("%d %d",&L,&q);     for(i=1;i<L;i++)     {           for(j=0;j<n;j++)           {                             virus.push_back(virlist[j]);           }     }     for(i=1;i<=q;i++)     {           scanf("%d %d %d %d",&x,&y,&v,&r);           for(j=x;j<=y;j++)           {                if(binsearch(j)!=-1)                {                      for(k=1;k<=v;k++)                      {                            virus.push_back(j);                      }                }           }           virus.sort();           it=virus.begin();           for(k=1;k<r;k++){it++;}           printf("%d\n",*it);     }     }  void qsort(int a[],int l,int r) { 	if (l<r) 	{ 		int pivot=part(a,l,r); 		qsort(a,l,pivot-1); 		qsort(a,pivot+1,r); 	} }  int part(int a[],int l,int r) {     int pivot=a[l];         while(l<r)     {                   while(pivot<=a[r] && l<=r){r--;}               if(l<r)        {            swap(a[l],a[r]);        }        while(a[l]<pivot && l<=r){l++;}        if(l<r)        {            swap(a[l],a[r]);        }     }         return l; }  void swap(int &a,int &b) {      a=a+b;      b=a-b;      a=a-b; }  int binsearch(int num) {     int loc=-1,l=0,u=n-1,found=0,mid;     while(found==0)     {             mid=(l+u)/2;             if( virlist[mid]>num ){                  u=mid ;                  if(l==u && virlist[l]!=num){found=2;}             }             else if ( virlist[mid]<num ){                  l=mid + 1 ;                  if(l==u && virlist[l]!=num){found=2;}             }             else if ( virlist[mid]==num ){                  loc=mid;                  found=1;             }     }     return loc; }       
#include <stdio.h> #include <cmath> #include <vector> #include <complex> #include <memory.h>  using namespace std;  typedef complex<double> com; const double pi = 3.1415926535897932384626433832795;  vector <com> a,b; int q[66666], cnt[66666], cc[66666]; int len,n,i;  void fft(vector <com> &a,bool inv) {   int n,m,i,j;   double ang;   com u,w,wn;   vector <com> a0,a1;   n = a.size();   if (n == 1) return;   m = n >> 1;   a0.resize(m);   a1.resize(m);   for (i=0,j=0;i<n;i+=2,j++) {     a0[j] = a[i];     a1[j] = a[i+1];   }   fft(a0,inv);   fft(a1,inv);   ang = 2.0*pi/n;   if (inv) ang = -ang;   w = 1;   wn = complex<double>(cos(ang),sin(ang));   for (i=0;i<m;i++) {     u = w*a1[i];     a[i] = a0[i]+u;     a[i+m] = a0[i]-u;     if (inv) {       a[i] /= 2;       a[i+m] /= 2;     }     w *= wn;   } }  int main() {   len = 65536;   scanf("%d",&n);   for (i=0;i<len;i++) cnt[i] = 0;   for (i=0;i<n;i++) {     scanf("%d",&q[i]);     q[i] += 10000;     cnt[q[i]]++;   }   a.resize(len);   b.resize(len);   for (i=0;i<len;i++) a[i] = com(cnt[i],0);   for (i=0;i<len;i++) b[i] = a[i];   fft(a,false);   fft(b,false);   for (i=0;i<len;i++) a[i] *= b[i];   fft(a,true);   for (i=0;i<len;i++) a[i] = (int)(a[i].real()+0.5);   for (i=0;i<len;i++) b[i] = com(cnt[i],0);   fft(a,false);   fft(b,false);   for (i=0;i<len;i++) a[i] *= b[i];   fft(a,true);   for (i=0;i<len;i++) cc[i] = (int)(a[i].real()+0.5);   for (i=0;i<len;i++)     if (i & 1) a[i] = 0;     else a[i] = com(cnt[i >> 1],0);   for (i=0;i<len;i++) b[i] = com(cnt[i],0);   fft(a,false);   fft(b,false);   for (i=0;i<len;i++) a[i] *= b[i];   fft(a,true);   for (i=0;i<len;i++) cc[i] -= (int)(a[i].real()+0.5)*3;   for (i=0;i<n;i++) cc[q[i]*3] += 2;   for (i=0;i<len;i++)     if (cc[i] > 0) printf("%d : %d\n",i-30000,cc[i]/6);   return 0; } 
#include <iostream>  using namespace std; int ar[15]={1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384};  int main() {     int n;     cin>>n;     int r;     int no=n;     int cnt=0;     while(no!=0)     {     int i;     for(i=0;ar[i]<=no;i++);     int index=i-1;     r=n%ar[index];     no=r;     cnt++;     }     cout<<cnt;     return 0; } 
#include<stdio.h> //#include<conio.h> int main() {     int k=1,n,c=2;      scanf("%d",&n);    if(n==1)  {printf("%d",n);  return 0;}               for(int m=2;m<n;m*=2)     {k=1;                       while(k<m*2)             {//printf("%d %d\n",k,c);                                    k+=2;c++;             if(c==n) {printf("%d",k); //getch();             return 0;}                                              }                          }            // getch();             return 0;}  
/*   Anurag Anand  */  #include <iostream> #include <cstdio> #include <cassert> #include <cstring> #include <cstdlib> #include <algorithm> #include <vector> #include <cmath>  using namespace std;   int main() {     char s[150];     gets(s);     char c=getchar();     int count=0;     for(int i=0;s[i]!='\0';i++)     {             if(s[i]==c) count++;     }     printf("%d\n",count);     //system("pause");     return 0;   } 
#include <iostream> #include <string> using namespace std;  int main(){ 	int n; 	string number;  	cin >> n; 	for (int k = 0; k < n; k++){ 		bool yes = true; 		cin >> number; 		for (unsigned int i = 0; i < number.length(); i++){ 			switch (number[i]){ 				case '0': 				case '8': 				case '1': break;  				case '6': number[i] = '9'; break; 				case '9': number[i] = '6'; break;  				case '2': 				case '3': 				case '4': 				case '5': 				case '7': yes = false; 			} 			if (!yes){ break; } 		}  		if (yes){ 			cout << "yes" << endl; 			for (int i = number.length() - 1; i >= 0; i--){ 				cout << number[i]; 			} 			cout << endl; 		} 		else{ 			cout << "no" << endl; 		} 	}  	return 0; }
#include<stdio.h> #include<limits.h> typedef long long int LLI; LLI min (LLI a,LLI b) { return (a<b?a:b); } int main() { int test; int x; scanf("%d",&test); while(test--) { int n; scanf("%d",&n); LLI mina=INT_MAX; long long int total=0; int i; for(i=0;i<n;++i){ scanf("%d",&x); total+=x; mina=min(mina,total/(i+1)); } printf("%lld\n",mina); } return 0; }
#include <iostream>  using namespace std;  int main() { 	 	int t; 	int n; 	int i, j, k, flag; 	long int arr[100000], ans; 	long long int left[100000], right[100000], sum; 	scanf("%d", &t); 	 	while(t--) { 		 		scanf("%d", &n); 		flag = 0; 		for(i = 0; i < n; i++) { 			scanf("%ld", &arr[i]); 		} 		 		k = 0; 		sum = 0; 		for(i = 0; i < n; i++) { 			 			sum = arr[k] + sum; 			left[i] = sum; 			k++; 		} 		 		k = n - 1; 		sum = 0; 		for(i = n - 1; i >= 0; i--) { 			 			sum = arr[k] + sum; 			right[i] = sum; 			k--; 		} 		 		 		i = 0; 		j = n - 1; 		 		while(i < n - 1 && j > 0) { 			 			//cout << "l = " << left[i] << " r = " << right[j] << endl; 			 			if(left[i] < right[j]) { 				i++; 			} else if(left[i] > right[j]) { 				j--; 			} else if(left[i] == right[j]) { 				if((j - i) == -2 || (j - i) == 2) { 					 					flag = 1; 					break; 				} 			} 			 		} 		 		if(flag == 1) { 			cout << arr[i + 1] << endl; 		} else { 			cout << "NO EQUILIBRIUM" << endl; 		} 		 		 	} 	 	return 0; 	 }
#include<bits/stdc++.h> using namespace std; typedef long long LL; const LL MOD = 274877906944LL; int main(){ 	int t; 	cin >> t; 	while(t--){ 		LL A, D, N, X; 		cin >> A >> D >> N >> X; 		LL ans = 0; 		for(int i = 0;i <= N;++i){ 			ans = ((ans*X)%MOD + (A + D*i)%MOD)%MOD; 		} 		cout << ans << "\n"; 	} 	return 0; }
#include<iostream> #include<string> #include<stdio.h> using namespace std; int main() {     int t;     long int n;     cin>>t;     while(t--)     {         cin>>n;         if(n%2==0)             cout<<n<<endl;         else             cout<<n-1<<endl;     }     return 0; } 
/*God is greater than any problem that u have and u have to not worry because when u pray and then worry, the worry nullify your prayer He is right here, right now !! */  #include <bits/stdc++.h> using namespace std; #define bitcnt __builtin_popcount #define ln length() #define rep(i, n) for(int i = 0; i < n; i++) #define rrep(i, n) for(int i = n - 1; i >= 0; i--) #define all(a)  a.begin(),a.end() #define LL long long #define limit 1000006 #define sl(n) scanf("%lld", &n) #define s(n)  scanf("%d", &n) #define pl(n) printf("%lld", n) #define pi(n)  printf("%d", n) #define pb push_back #define pn printf("\n") #define mod 1000000007 typedef vector<LL> row; typedef vector<row> matrix;  int F[1000006]; char str[1000006]; char str1[1000006]; void print(LL *arr, LL n) { 	rep(i, n) cout << arr[i] << " "; 	cout << endl; }  void computeF(string s) { 	int size = s.ln; 	F[0] = F[1] = 0; 	for(int i = 2; i <= size; i++) { 		int j = F[i - 1]; 		while(true) { 			if(s[j] == s[i - 1]) { 				F[i] = j + 1; 				break; 			} 			if(j == 0) { 				F[i] = 0; 				break; 			} 			j = F[j]; 		} 	} }  void solve() { 	scanf("%s", str); 	int l = strlen(str); 	scanf("%s", str1); 	strcat(str, "#"); 	strcat(str, str1); 	//printf("%s", str); 	string s = string(str); 	computeF(s); 	int ans = F[s.ln]; 	if(ans > l) { 		ans = l; 	} 	if(ans == 0) { 		puts("0"); 	} 	else { 		for(int i = 0; i < ans; i++) { 			printf("%c", s[i]); 		} 		printf(" %d\n", ans); 	} }  int main() { 	int t = 1; 	//scanf("%d", &t); 	while(t--) { 		solve(); 	} 	return 0; } 
#include<stdio.h> int abs(int x) {     if(x>0)return x;     else return -x; } int main() {     int a,b,d,x,m=1000000007;     char c;     scanf("%d",&a);     c=getchar();     while(c>30)     {         scanf("%d",&b);         d=abs(b-a);         if(d<m)         m=d;         a=b;         c=getchar();     }     printf("%d\n",m);     return 0; } 
#include<string.h> #include<cstdio> //#include<conio.h> int main() {     char s[100];     int i,h;     scanf("%s",s);     h=strlen(s);     if(h>=3)     printf("%c%c%c",s[h/2-1],s[h/2],s[h/2+1]);     else     printf("0");    // getch();     return 0; } 
#include<iostream> #include <math.h> using namespace std; int main() {     int a,b,flag=0;     cin>>a>>b;     while(a>0 && flag==0)     {         int c=a%10;         int temp=b;         while(temp>0 && flag==0)         {             if((temp%10)==c)             flag=1;             temp=temp/10;         }         a=a/10;     }          if(flag==1)     cout<<"TRUE"<<endl;     else     cout<<"FALSE"<<endl;     return 0; }
#include <iostream> #include <string> using namespace std; int main() {     string s,s1;     s1 = "";     int i,l;     cin >> s;     l = s.size();     for(i=0;s[i]!='\0';i++){             if(s[i] == s[l-i-1]){                     s1 += s[i];             }else{                 break;             }     }     cout << s1 << endl;     return 0; } 
// @Author - Mayank Kataria (Lovely Professional University) !  #pragma warning(disable:4786) #pragma comment(linker, "/STACK:266777216")  #include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<set> #include<map> #include<functional> #include<string> #include<cstring> #include<cstdlib> #include<queue> #include<utility> #include<fstream> #include<sstream> #include<cmath> #include<stack> #include<cstdio> #include<ctime> #include<cassert>   using namespace std;  //Macros   #define FOR(i,a,b)    for(int i=a;i<b;i++) #define FORL(i,a,b)   for(LL i=a;i<b;i++) #define PB            push_back #define mp            make_pair #define X 		      first #define Y 		      second #define len			  size() #define s(n)          scanf("%d",&n); #define slld(n)       scanf("%lld",&n); #define sf(n)         scanf("%lf",&n); #define ss(n)         scanf("%s",n); #define INF           (int)1e9 #define EPS           1e-9 #define maX(a,b)      (a>b?a:b) #define miN(a,b)      (a<b?a:b) #define MEM(a,b)      memset(a,(b),sizeof(a))  //memset(arr,0,sizeof(arr)) #define istr(S)       istringstream sin(S) #define MOD           1000000007				    typedef vector<int> VI;      //1d integer VECTOR typedef vector<VI> VVI;      //2d integer VECTOR typedef pair<int,int> PII;   //pair typedef vector<PII> VPII;    //VECTOR of pairs typedef vector<string> VS;   //VECTOR of strings typedef vector<double> VD;   //1d double VECTOR  typedef long long LL; typedef long long int LLI;   int main() { 	int t,x,y; 		scanf("%d",&t); 		 		while(t--) 		{ 			scanf("%d %d",&x,&y); 			 			if(x == 0 || y==0) 			{ 			printf("0\n"); 			continue; 			} 			 			if(x==y) 			{ 				if(x%2==0) 				printf("%d\n",x+1); 				else 				printf("%d\n",x);	 			 				continue; 			} 			 			else 			{ 				int hrs=(x/2)+(y/2)+1; 				printf("%d\n",hrs); 			} 			 		}  return 0; }
#include <cstdio> #include <iostream> #include <algorithm> using namespace std; int dp1[1002][10002],dp2[1002][10002]; int marks[1005],tim[1005]; int main(){ int n,t; cin>>n>>t; for(int i=0;i<n;i++)     cin>>marks[i]; for(int i=0;i<n;i++)     cin>>tim[i]; for(int i=0;i<=n;i++)     for(int j=0;j<=t;j++)       dp1[i][j]=dp2[i][j]=0; for(int i=1;i<=n;i++){     for(int j=1;j<=t;j++){         if(j>=tim[i-1])             dp1[i][j]=max(marks[i-1]+dp1[i-1][j-tim[i-1]],dp1[i-1][j]);         else             dp1[i][j]=dp1[i-1][j];     } } for(int i=1;i<=n;i++){     for(int j=1;j<=t;j++){         if(j>=tim[i-1]){            int a = dp1[i-1][j-tim[i-1]] + 2*marks[i-1];            int b = max(dp2[i-1][j],dp2[i-1][j-tim[i-1]]+marks[i-1]);            dp2[i][j]=max(a,b);         }         else             dp2[i][j]=dp2[i-1][j];     } } cout<<dp2[n][t]<<endl; return 0; } 
#include <iostream> #include <vector> #include <algorithm> #include <string> using namespace std; typedef long long ull;  int main() {     ios_base::sync_with_stdio(false);     int t,n;     cin>>t;     while(t--)     {         cin>>n;         int a[n];         for(int i=0;i<n;i++)             cin>>a[i];         sort(a,a+n);         int x=0, y=0;         for(int i=n-1;i>=0;i--)             if(x<y)                 x += a[i];             else                 y += a[i];         cout<<abs(x-y)<<'\n';             }     //system("pause");     return 0; } 
#include<bits/stdc++.h> #define pii pair<int,int> #define Min(a,b) ((a<b) ? a:b) #define Max(a,b) ((a > b) ? a:b) #define Swap(a,b) (a=b+a-(b=a)) #define sn(n) scanf("%d",&n) #define schr(n) scanf("%c",&n) #define ss(n) scanf("%s",n) #define p(n) printf("%d",n) #define el putchar("\n"); #define sp putchar('') #define Fill(a,val) memset(a,val,sizeof(a)) #define pb push_back #define INFN 123456789 #define ll long long #define si short int #define vi vector<int> #define vvi vector<vvi> #define ITER(i,a) for( typeof(a.begin()) i=a.begin();i!=a.end();i++) #define _I int #define _D double #define _L long long  using namespace std; int gcd(int a,int b){ 	return (!b) ? a:gcd(b,a%b); }  char arr[10002]; _I ac,bc;  void func(){ 	_I i,j,len = strlen(arr); 	char n; 	_I tot_c = 0; 	_I min_c = 0; 	char rep_char; 	if(ac < bc) { 		min_c = ac; 		rep_char = 'a'; 	} 	else{ 		min_c = bc; 		rep_char = 'b'; 	} 	_I cnt = 0; 	for(i=0;i < len/2;i++){  		if(arr[i] == '/' && arr[len-i-1] == '/'){ 			tot_c += (2*min_c); 		} 		else if((arr[i] == 'a' && arr[len-i-1] == '/') || (arr[i] == '/' && arr[len-i-1] == 'a')){ 			tot_c += ac; 		} 		else if((arr[i] == 'b' && arr[len-i-1] == '/') || (arr[i] == '/' && arr[len-i-1] == 'b') ){ 			tot_c += bc; 		} 		else if(arr[i] != arr[len-i-1]){ 			cnt = 1; 			break; 		} 	} 	if(cnt){ 		cout << "-1" << endl; 	} 	else{ 		cout << tot_c << endl; 	} }  char N[10021] = {0}; void func1(){ 	if(N[0] & 1) { 		cout << "ODD" << endl; 	} 	else{ 		cout << "EVEN" << endl; 	} 	 }  _L a[100005];  void func2(_L N){ 	_I cnt = 0; 		for(_I i=0; i < N-1;i++){ 			for(_I j=i+1;j < N;j++){ 				if((a[i] ^ a[j] ) & 1){ 					cnt++; 				} 			} 		} 		cout << cnt << endl; }  _I main(){ 	_I t; 	cin >> t; 	_L N; 	for(_I test = 0;test < t;test++){ 		cin >> N; 		for(_I i= 0; i < N;i++){ 			cin >> a[i]; 		} 		func2(N); 	} 	return 0; 	 }
#include<iostream> using namespace std;  // Maximum number of digits in output #define MAX 500  int multiply(int x, int res[], int res_size);  // This function finds factorial of large numbers and prints them void factorial(int n) {     int res[MAX];      // Initialize result     res[0] = 1;     int res_size = 1;      // Apply simple factorial formula n! = 1 * 2 * 3 * 4...*n     for (int x=2; x<=n; x++)         res_size = multiply(x, res, res_size);    //  cout << "Factorial of given number is \n";     for (int i=res_size-1; i>=0; i--)         cout << res[i]; }  // This function multiplies x with the number represented by res[]. // res_size is size of res[] or number of digits in the number represented // by res[]. This function uses simple school mathematics for multiplication. // This function may value of res_size and returns the new value of res_size int multiply(int x, int res[], int res_size) {     int carry = 0;  // Initialize carry      // One by one multiply n with individual digits of res[]     for (int i=0; i<res_size; i++)     {         int prod = res[i] * x + carry;         res[i] = prod % 10;  // Store last digit of 'prod' in res[]         carry  = prod/10;    // Put rest in carry     }      // Put carry in res and increase result size     while (carry)     {         res[res_size] = carry%10;         carry = carry/10;         res_size++;     }     return res_size; }  // Driver program int main() {    int t,n;    cin>>t;    while(t--)    {        cin>>n;        factorial(n);        cout<<endl;    }      return 0; } 
#include<iostream> using namespace std; int main() {     int test;     long f=1,i,n;     scanf("%d",&test);     while(test--)     {         scanf("%d",&n);         for(i=2;i<=n;i++)         f=f*i;         cout<<f<<endl;         f=1;     } } 
#include<bits/stdc++.h> using namespace std; typedef long long ll; int main() {   string s1,s2;   cin>>s1>>s2;   ll ar[26]={0},ans=0;   ll i=0;   while(s1[i]!='\0')     ar[s1[i]-'A']++,i++;   i=0;   while(s2[i]!='\0')     ar[s2[i]-'A']++,i++;   for( i=0;i<26;i++)     if(ar[i]==2)     ans++;   cout<<ans;     } 
#include<cstdio> #include<cstdlib> #include<cstring> #include<cmath> #include<algorithm>  using namespace std;  #define MAX_A 100000 #define MAX_B 1000  int A[MAX_A+5], B[MAX_B+5]; int counts[MAX_B+5], done[MAX_B+5];  int contains( int val, int NB ){ 	int low = 0, high = NB - 1, mid; 	while( low <= high ){ 		mid = (low + high)/2; 		if( B[mid] == val ) 			return mid; 		if( B[mid] > val ) 			high = mid - 1; 		else 			low = mid + 1; 	} 	return -1; }  void performtest(){ 	int NA, NB, i, j; 	 	//Initialize 	scanf( "%d", &NA ); 	for( i=0; i<NA; i++ ) 		scanf( "%d", A + i ); 	scanf( "%d", &NB ); 	for( j=0; j<NB; j++ ) 		scanf( "%d", B + j ); 	 	memset( done, false, sizeof( done ) ); 	memset( counts, 0, sizeof( counts ) ); 	 	sort( B, B + NB ); 	 	for( i=0; i<NA; i++ ) 		A[i] = contains( A[i], NB ); 	 	long long result = 0; 	int pre = -1, total = 0; 	for( i=0; i<NA; i++ ) 		if( A[i] >= 0 ){ 			counts[ A[i] ]++; 			if( !done[ A[i] ] ){ 				done[ A[i] ] = true; 				total++; 			} 			if( total == NB ) 				break; 		} 	 	if( total < NB ){ 		printf( "0\n" ); 		return; 	} 	 	for( j=0; j<NA; j++ ) 		if( A[j] >= 0 ){ 			if( counts[ A[j] ] > 1 ) 				counts[ A[j] ]--; 			else 				break; 		} 	result = (long long)( j - pre )*(long long)( NA - i ); 	pre = j; 	 	for( i=i+1; i<NA; i++ ) 		if( A[i] >= 0 ){ 			counts[ A[i] ]++; 			for( j=pre; j<NA; j++ ) 				if( A[j] >= 0 ){ 					if( counts[ A[j] ] > 1 ) 						counts[ A[j] ]--; 					else 						break; 				} 			result += (long long)( j - pre )*(long long)( NA - i ); 			pre = j; 		} 	printf( "%lld\n", result ); }  int main(){ 	int tests; 	scanf( "%d", &tests ); 	while( tests-- ) 		performtest(); 	return 0; }
#include<bits/stdc++.h> using namespace std; int main() {       int n,m,a[205];       cin>>n>>m;       for(int i=0;i<n;i++)       {             cin>>a[i];       }       sort(a,a+n);       cout<<a[n-m];       return 0; } 
#include <bits/stdc++.h> using namespace std; typedef long long int ll; #define F(i,a,b) for(int i = (int)(a); i <= (int)(b); i++) #define RF(i,a,b) for(int i = (int)(a); i >= (int)(b); i--) #define pb push_back #define mp make_pair #define gc getchar_unlocked  int read_int(){     register int x = 0, c = gc();     int sign = 1;     while(c!='-' && (c<48 || c>57) ) c = gc();     if(c=='-')         sign = -1, c = gc();     while(c>=48 && c<=57)         x = (x<<1) + (x<<3) + c - 48, c = gc();     return sign*x; } int main() {     #ifndef ONLINE_JUDGE         freopen("input.txt","r",stdin);         freopen("output.txt","w",stdout);     #endif     int T,N;     T = read_int();     while(T--)     {         N = read_int();         int D[N];         F(i,0,N-1) D[i] = read_int();         sort(D,D+N);         int timer,counter;         int killed = 0;         timer = counter = 0;         F(i,0,N-1)         {             if(D[i]-timer > 0)             {                 timer++;                 counter++;                 if(counter == 6)                 {                     timer++;                     counter = 0;                 }             }             else             {                 killed = i;                 break;             }         }         if(killed == 0) printf("Bhai Ho!\n");         else printf("Killed %d\n",killed);     }     return 0; }  
#include <bits/stdc++.h> using namespace std; typedef long long int ll; #define F(i,a,b) for(int i = (int)(a); i <= (int)(b); i++) #define RF(i,a,b) for(int i = (int)(a); i >= (int)(b); i--) #define pb push_back #define mp make_pair #define gc getchar_unlocked  int read_int(){     register int x = 0, c = gc();     int sign = 1;     while(c!='-' && (c<48 || c>57) ) c = gc();     if(c=='-')         sign = -1, c = gc();     while(c>=48 && c<=57)         x = (x<<1) + (x<<3) + c - 48, c = gc();     return sign*x; } int main() {     #ifndef ONLINE_JUDGE         freopen("input.txt","r",stdin);         freopen("output.txt","w",stdout);     #endif     int T,L,_i;     char S[1005];     T = read_int();     while(T--)     {         scanf("%s",S);         L = strlen(S);         bool flag = 0;         _i = 0;         while(_i <= L-1)         {             if(S[_i] >= '0' && S[_i] <= '4')             {                 S[_i] = '5';                 flag = 1;                 break;             }             else if(S[_i] >= '6' && S[_i] <= '8')             {                 S[_i] = '9';                 flag = 1;                 break;             }             _i++;         }         if(flag)         {             F(i,_i+1,L-1) S[i] = '5';         }         else         {             flag = 0;             RF(i,L-1,0)             {                 if(S[i] == '5')                 {                     S[i] = '9';                     flag = 1;                     break;                 }             }             if(flag == 0)             {                 F(i,0,L) S[i] = '5';                 S[L+1] = '\0';             }         }         printf("%s\n",S);     }     return 0; }  
#include <vector> #include <iostream> #include <cmath> using namespace std;  int main()  {      int t, n, x;     cin>>t;     while(t--)  {         cin>>n;         while(n--)  {             cin>>x;             float digits = 0;             while(x)  {                 digits += log10(x); x--;             }             cout<<(int)digits + 1<<" ";         }         cout<<endl;     }     /*float digits = 0;     while(t)  {         digits += log10(t);         t--;     }     cout<<(int)digits + 1;*/     return 0; } 
    #include<stdio.h>           int main() {     int fact[200],n,num,bakup,carry,product,i,j,k=0;           scanf("%d",&n);           for(i=0;i<n;i++) {     scanf("%d",&num);     bakup=num;     j=0;     fact[0]=1;     fact[1]=-1;     for(j=1;j<=bakup;j++) {     k=0;     carry=0;     do {     if(fact[k]!=-1) {     product=j*fact[k]+carry;     fact[k]=product%10;     carry=product/10;     k++;     }     else {     while(carry) {     fact[k]=carry%10;     carry=carry/10;     k++;     }     fact[k]=-1;     k--;     break;     }     }while(1);     }           num=0;     while(k>=0) {     printf("%d",fact[k]);     k--;     }     printf("\n");     }     return 0;     }   
#include<iostream> #include<string.h> #include<math.h> #define MOD 1000000007 using namespace std; long long int fast_exp(int base, int exp) {     long long int k;     if(exp==1)     return base;     else     {         if(exp%2 == 0)         {         	k=fast_exp(base,exp/2);         	long long int base1=(k%MOD*k%MOD)%MOD;             if(base1 >= MOD)             return base1%MOD;             else             return base1;         }         else         {         	k=fast_exp(base,(exp-1)/2);         	long long int ans=((k%MOD*k%MOD)%MOD*base)%MOD;             //long long int ans = (base*  pow(fast_exp(base,(exp-1)/2),2));             if(ans >= MOD)             return ans%MOD;             else             return ans;         }     } } int main() { 	int t; 	long long int mod1,mod2,ans; 	char A[100005],B[100005]; 	cin>>t; 	while(t--) 	{ 		cin>>A; 		cin>>B; 		mod1=((int)A[0]-48)%MOD; 		for(int i=1;i<strlen(A);i++) 		{ 			mod1=(mod1*10+((int)A[i]-48))%MOD; 		} 		mod2=((int)B[0]-48)%(MOD-1); 		for(int i=1;i<strlen(B);i++) 		{ 			mod2=(mod2*10+((int)B[i]-48))%(MOD-1); 		} 		ans=fast_exp(mod1,mod2); 		cout<<ans<<endl;   	} } 
#include<bits/stdc++.h> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {         long long int n;         scanf("%lld",&n);         if(n%10==0)             cout<<n<<endl;         else         {             n=n/10;             cout<<(n+1)*10<<endl;         }     }     return 0;  } 
#include <bits/stdc++.h> using namespace std; #define N 100000 vector <int> adj[N + 10]; int mark[N + 10]; //int poss[N + 10];  //int mp[N + 10]; int disc[N + 10]; int low[N + 10]; int par[N + 10]; int dtime,cnt; int dfs(int,int); //void Bridges(int); int main() {     int tc,t;     scanf("%d",&tc);     while(tc--)     {         int n,m,i;         scanf("%d %d",&n,&m);         for(i = 1 ; i<=n ; i++)         {             //mp[i] = 0;             //poss[i] = 0;             mark[i] = 0;             adj[i].clear();             //adj2[i].clear();             disc[i] = 0;             low[i] = 0;             par[i] = 0;         }          for(i = 1 ; i<=m ; i++)         {             int u,v;             scanf("%d %d",&u,&v);             adj[u].push_back(v);             adj[v].push_back(u);         }         dtime = 0;         cnt = 0;         int temp = dfs(1,n);         printf("%d\n",cnt);         /*int cc = 0;         for(i = 1 ; i<=n ; i++)         {             mark[i] = 0;             if(poss[i] == 1)             {                 cc++;                 mp[cc] = i;                 poss[i] = cc;             }         }         for(i = 1 ; i<=n ; i++)         {             int sz = adj[i].size();             for(int j = 0 ; j<sz; j++)             {                 int v = adj[i][j];                 if(poss[i] > 0 && poss[v] > 0)                 {                     adj2[mp[i]].push_back(mp[v]);                     //adj2[mp[v]].push_back(mp[i]);                 }             }         }         cnt = 0;         Bridges(1);         printf("%d\n",cnt);*/     }     return 0; } int dfs(int u,int n) {     dtime++;     disc[u] = dtime;     low[u] = disc[u];     mark[u] = 1;     int sz = adj[u].size();     int fl = 0;     if(u == n) fl = 1;     for(int j = 0 ; j<sz ; j++)     {         int v = adj[u][j];         if(mark[v] == 0)         {             par[v] = u;             int temp = dfs(v,n);             if(fl == 0) fl = temp;             if(temp == 1)             {                 if(low[v] > disc[u]) cnt++;             }         }         if(v != par[u])         {             low[u] = min(low[u],low[v]);         }     }     mark[u] = 2;     //cout<<u<<" "<<fl<<" "<<low[u]<<" "<<disc[u]<<endl;     return fl; } /*void Bridges(int u) {     dtime++;     disc[u] = dtime;     low[u] = disc[u];     mark[u] = 1;     int sz = adj2[u].size();     for(int j = 0 ; j<sz ; j++)     {         int v = adj2[u][j];         if(mark[v] == 0)         {             par[v] = u;             Bridges(v);             if(low[v] > disc[u])cnt++;         }         if(v != par[u])         {             low[u] = min(low[u],disc[v]);         }     } }*/ 
#include<bits/stdc++.h> #define ll long long #define fi first #define se second ll mpow(ll a, ll n,ll mod) {ll ret=1;ll b=a;while(n) {if(n&1)     ret=(ret*b)%mod;b=(b*b)%mod;n>>=1;} return (ll)ret; } using namespace std; #define mem(x,a) memset(x,a,sizeof(x)) #define pii pair<int,int> #define mp make_pair #define pb push_back #define all(v) v.begin(),v.end() using namespace std; #define N (int)(2e1+4) ll temp[3][3],a[3][3],b[3][3]; ll mod=1e9+7; void mul(long long a[3][3], long long b[3][3], long long c[3][3]) {     mem(temp,0); 	for (int i = 0; i < 3; ++i) 		for (int j = 0; j < 3; ++j) 			for (int k = 0; k < 3; ++k) 				temp[i][j] = (temp[i][j] + a[i][k] * b[k][j] ) % mod; 	for (int i = 0; i < 3; ++i) 		for (int j = 0; j < 3; ++j) 			c[i][j] = temp[i][j]; } void pwr(long long a[3][3], long long n, long long b[3][3]) { 	for (int i = 0; i < 3; ++i) 		for (int j = 0; j < 3; ++j) 			b[i][j] = (i == j); 	while (n) 	{ 		if (n & 1) 			mul(b, a, b); 		n >>= 1; 		mul(a, a, a); 	} } int func(long long n, long long k) { 	k %= mod; 	if (n == 1) 		return k; 	long long ks = k * k % mod; 	mem(a,0); 	a[0][0] = a[2][0] = k; 	a[0][1] = a[2][1] = ks; 	a[1][0] = 1; 	a[2][2] = 1; 	pwr(a, n - 1, b); 	return (b[2][0] + b[2][2]) * k % mod; } void solve(){     ll n,k;     cin>>n>>k;     cout<<func(n,k)<<endl; } int main(){    //ios_base::sync_with_stdio(false);    int t=1;    cin>>t;    for(int i=1;i<=t;i++){        //printf("Case #%d: ",i);        solve();    }    return 0; } 
#include<cstdio> #include<iostream> #define deepak 1000000007 using namespace std; long long gcd(long long,long long); int main() { long long t; scanf("%lld",&t); while(t--) {     long long a,b;     long long c[100004]={0};     //memset(c,0,100004);     scanf("%lld%lld",&a,&b);     long long k=gcd(a,b);     c[0]=0;     c[1]=1; for(int i=2;i<=k;i++)     c[i]=((c[i-1]%deepak)+(c[i-2]%deepak))%deepak; printf("%lld\n",c[k]); } return 0; } long long  gcd(long long a,long long b) { if(a==0) return b; else if(b==0) return a; else if(a>b) gcd((a%b),b); else gcd((b%a),a); } 
#include <vector> #include <list> #include <map> #include <set> #include <deque> #include <queue> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <complex> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <cstring> #include <ctime> #include <cassert> using namespace std;  #define FOR(it,a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); ++it)  const int maxn = 16; const int maxm = maxn * 2;  int n, m; char input[maxn][maxn]; int label[maxn][maxn]; int ending[maxn][2];  int vertices, edges; int src, dest;  int length[maxm]; vector<int> cover[maxn][maxn]; vector<int> adjEdge[maxn];  int crossEdge[maxm]; set<int> S[maxn][maxn];  struct State {     int pos;     int holdLen;     int mask;      State(int pos, int mask) : pos(pos), holdLen(0), mask(mask) { }     State(int pos, int hold, int mask) : pos(pos), holdLen(hold), mask(mask) { }      bool insert() const {         return S[pos][holdLen].insert(mask).second;     } };  int main() {     int tests;     scanf("%d", &tests);     for (int cas = 1; cas <= tests; ++cas) {         scanf("%d%d", &n, &m);         for (int i = 0; i < n; i++) {             scanf("%s", input[i]);         }         vertices = edges = 0;         memset(label, -1, sizeof(label));         for (int i = 0; i < n; i++) {             for (int j = 0; j < m; j++) {                 if (input[i][j] == 'S' || input[i][j] == 'E' || input[i][j] == 'B') {                     if (input[i][j] == 'B') {                         src = vertices;                     } else if (input[i][j] == 'E') {                         dest = vertices;                     }                     adjEdge[vertices].clear();                     label[i][j] = vertices ++;                 }                 cover[i][j].clear();             }         }         int initialEdges = 0;         for (int i = 0; i < n; i++) {             for (int j = 0; j < m; j++) {                 if (label[i][j] < 0) {                     continue;                 }                 for (int k = 0; k < 2; k++) {                     int dx, dy;                     if (k == 0) {                         // right                         dx = 0, dy = 1;                     } else {                         // down                         dx = 1, dy = 0;                     }                     vector<pair<int,int> > path;                     int x = i + dx, y = j + dy, target = -1;                     while (x < n && y < m) {                         if (label[x][y] >= 0) {                             target = label[x][y];                             break;                         }                         path.push_back(make_pair(x, y));                         x += dx;                         y += dy;                     }                     if (target >= 0 && path.size()) {                         length[edges] = path.size() + 1;                         ending[edges][0] = label[i][j];                         ending[edges][1] = target;                         adjEdge[label[i][j]].push_back(edges);                         adjEdge[target].push_back(edges);                         FOR (it, path) {                             cover[it->first][it->second].push_back(edges);                         }                         char ch = input[path[0].first][path[0].second];                         if (k == 0 && ch == '-' || k == 1 && ch == '|') {                             initialEdges |= 1 << edges;                         }                         edges ++;                     }                 }             }         }         for (int i = 0; i < vertices; i++) {             for (int j = 0; j < maxn; j++) {                 S[i][j].clear();             }         }         memset(crossEdge, 0, sizeof(crossEdge));         for (int i = 0; i < n; i++) {             for (int j = 0; j < m; j++) {                 FOR (it, cover[i][j]) {                     FOR (jt, cover[i][j]) {                         crossEdge[*it] |= 1 << *jt;                     }                 }             }         }         State startS(src, initialEdges);         startS.insert();         queue<pair<State,int> > Q;         Q.push(make_pair(startS, 0));         int ans = 0;         while (!Q.empty()) {             State p = Q.front().first;             int dist = Q.front().second;             Q.pop();             if (p.pos == dest) {                 ans = dist;                 break;             }             if (p.holdLen > 0) {                 FOR (it, adjEdge[p.pos]) {                     if (length[*it] == p.holdLen && (crossEdge[*it] & p.mask) == 0) {                         // put down                         State q(p.pos, p.mask | 1 << *it);                         if (q.insert()) {                             Q.push(make_pair(q, dist + 1));                         }                     }                 }             }             FOR (it, adjEdge[p.pos]) {                 if (p.mask >> *it & 1) {                     if (p.holdLen == 0) {                         // pick up                         State q(p.pos, length[*it], p.mask & ~(1 << *it));                         if (q.insert()) {                             Q.push(make_pair(q, dist + 1));                         }                     }                     // move                     State q(ending[*it][0] ^ ending[*it][1] ^ p.pos, p.holdLen, p.mask);                     if (q.insert()) {                         Q.push(make_pair(q, dist + 1));                     }                 }             }         }         printf("%d\n", ans);     } } 
#include<cstdio> using namespace std; int r,c; bool win=false,jf; //int getchar_unlocked()  {return getchar();} //inline void fastRead_int(int &x) { //	register int c = getchar_unlocked(); //	x = 0; //	for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked()); //	for(; c>47 && c<58 ; c = getchar_unlocked()) { //		x = (x<<1) + (x<<3) + c - 48; //	} //}  int main(){ 	int i,j; 	scanf("%d",&r);  scanf("%d",&c); 	char maze[r][c]; 	for(i=0;i<r;i++) scanf("%s",&maze[i]);  	char ma[r][c]; 	int count=0; 	while(true){ 		count++; 		jf=false;                   ////check 		for(i=0;i<r;i++){ 			for(j=0;j<c;j++){ 				if(maze[i][j]=='J'){jf=true; 					if(i==0 || i==r-1 || j==c-1 || j==0) { win=true; goto label;     } 				} 			} 		} 		if(!jf){win=false; goto label;   } 		for(i=0;i<r;i++){                 //copy 			for(j=0;j<c;j++){ 				ma[i][j]=maze[i][j]; 			} 		} 		for(i=0;i<r;i++){                 //movej 			for(j=0;j<c;j++){ 				if(ma[i][j]=='J'){ 					if(j!=0 && ma[i][j-1]=='.') maze[i][j-1]='J'; 					if(i!=r-1 && ma[i+1][j]=='.') maze[i+1][j]='J'; 					if(i!=0 && ma[i-1][j]=='.') maze[i-1][j]='J'; 					if(j!=c-1 && ma[i][j+1]=='.') maze[i][j+1]='J'; 					maze[i][j]='K';	 				} 				else if(ma[i][j]=='F'){                 //movef 					if(j!=0 && (ma[i][j-1]=='.' || ma[i][j-1]=='J' || ma[i][j-1]=='K')) maze[i][j-1]='F'; 					if(j!=c-1 && (ma[i][j+1]=='.' || ma[i][j+1]=='J' || ma[i][j+1]=='K')) maze[i][j+1]='F'; 					if(i!=r-1 && (ma[i+1][j]=='.' || ma[i+1][j]=='J' || ma[i+1][j]=='K')) maze[i+1][j]='F'; 					if(i!=0 && (ma[i-1][j]=='.' || ma[i-1][j]=='J' || ma[i-1][j]=='K')) maze[i-1][j]='F';		 				} 			} 		} 	} 	label: {if(win) {printf("%d",count);  }   else printf("IMPOSSIBLE");   } 	return 0; } 
#include<bits/stdc++.h> #include<string> using namespace std; void reverse(char *str, int length) {     int start = 0;     int end = length -1;     while (start < end)     {         swap(*(str+start), *(str+end));         start++;         end--;     } }   // Implementation of itoa() char* itoa2(int num, char* str, int base) {     int i = 0;     bool isNegative = false;       /* Handle 0 explicitely, otherwise empty string is printed for 0 */     if (num == 0)     {         str[i++] = '0';         str[i] = '\0';         return str;     }       // In standard itoa(), negative numbers are handled only with      // base 10. Otherwise numbers are considered unsigned.     if (num < 0 && base == 10)     {         isNegative = true;         num = -num;     }       // Process individual digits     while (num != 0)     {         int rem = num % base;         str[i++] = (rem > 9)? (rem-10) + 'a' : rem + '0';         num = num/base;     }       // If number is negative, append '-'     if (isNegative)         str[i++] = '-';       str[i] = '\0'; // Append string terminator       // Reverse the string     reverse(str, i);       return str; } void LPSarray(string *s,int m,int *arr) { 	int i=0; 	arr[0]=0;//here array stores LPS value 	i++; 	int len=0; 	while(i<m) 	{ 		if(s[i]==s[len]) 		{ 			len++; 			arr[i]=len; 			i++; 		} 		else 		{ 			if(len!=0) 			{ 				len=arr[len-1];//we go to previous largest prefix which is also a suffix and then check 			} 			else 			{ 				arr[i]=0; 				i++; 			} 		} 	} } int st1[100005],st2[100005]; int y=0; void matchStr(string *text,string *pat,int n,int m) { 	int arr[m]; 	LPSarray(pat,m,arr); 	int i=0,j=0; 	while(i<n) 	{ 		if(text[i]==pat[j]) 		{ 			j++; 			i++; 		} 		if(j==m) 		{ 			//cout<<"match found at "<<i-j<<endl; 				st1[y++]=i-j; 			j=arr[j-1]; 		} 		else if(i<n&&text[i]!=pat[j]) 		{ 			if(j!=0) 			j=arr[j-1]; 			else 			i++; 		} 	} 	//delete(arr); } int x=0; void matchStr2(string *text,string *pat,int n,int m) { 	int arr[m]; 	LPSarray(pat,m,arr); 	int i=0,j=0; 	while(i<n) 	{ 		if(text[i]==pat[j]) 		{ 			j++; 			i++; 		} 		if(j==m) 		{ 			//cout<<"match found at "<<i-j<<endl; 				st2[x++]=i-j; 			j=arr[j-1]; 		} 		else if(i<n&&text[i]!=pat[j]) 		{ 			if(j!=0) 			j=arr[j-1]; 			else 			i++; 		} 	} 	//delete(arr); } string take[100005],cat1[100005],cat2[100005]; int main() { 	int n,k,l,p; 	char *f; 	scanf("%d%d%d",&n,&k,&l); 	for(int i=0;i<n;i++) 	{ 	  scanf("%d",&p); 	 stringstream out; 	 out<<p; 	  take[i]=out.str();	 	} 	for(int i=0;i<k;i++) 	{ 	  scanf("%d",&p); 	 stringstream out; 	 out<<p; 	  cat1[i]=out.str();	 	} 	for(int i=0;i<l;i++) 	{ 		scanf("%d",&p);		 	  stringstream out; 	 out<<p; 		cat2[i]=out.str(); 	} 	matchStr(take,cat1,n,k); 	matchStr2(take,cat2,n,l); 	long long ans=0; 	for(int i=0;i<y;i++) 	{ 		int z=lower_bound(st2,st2+x,st1[i])-st2; 		if(st2[z]==st1[i]) 		ans+=z+1; 		else 		ans+=z; 	} 	printf("%lld\n",ans); }
#include <cstdio> #include <cassert>  #include <vector> #include <queue> #include <algorithm>  using namespace std;  int N, M, K, C; int D[104][104];  class BipartiteMatching {    vector<bool> seen;    bool bpm(int u) {       for (int j = 0; j < adj[u].size(); ++j) {          int v = adj[u][j];          if (seen[v]) continue;          seen[v] = true;          if (matchR[v] < 0 || bpm(matchR[v])) {             matchL[u] = v;             matchR[v] = u;             return true;          }       }       return false;    } public:    size_t nL, nR;    vector< vector<int> > adj; // adjacency lists     vector<int> matchL, matchR;    BipartiteMatching(size_t _nL, size_t _nR) : nL(_nL), nR(_nR), adj(_nL) {}     int process() {       matchL.assign( nL, -1 ),       matchR.assign( nR, -1 );       int cnt = 0;       for (int i = 0; i < nL; ++i) {          seen = vector<bool>(nR, false);          if (bpm(i))             cnt++;       }       return cnt;    } };  bool check(int t) {    BipartiteMatching bpm(N, M*2);    for (int i = 0; i < N; ++i) {       for (int j = 0; j < M; ++j) {          if (D[i][j] + C <= t)             bpm.adj[i].push_back(j);          if (D[i][j] <= t)             bpm.adj[i].push_back(j + M);       }    }    return bpm.process() >= K; }  int binary_search() {    int lo = 0, hi = 20000000;    while (lo < hi) {       int mid = lo + (hi-lo)/2;       if (check(mid))          hi = mid;       else          lo = mid+1;    }    assert(check(lo));    return lo; }  int main(int argc, char* argv[]) {    int TC;    scanf("%d", &TC);    while (TC-- > 0) {       scanf("%d %d %d %d", &N, &M, &K, &C);       for (int i = 0; i < N; ++i)          for (int j = 0; j < M; ++j)             scanf("%d", &D[i][j]);       int res = binary_search();       printf("%d\n", res);    }     return 0; } 
#include<iostream> #include<stdio.h> using namespace std; int check(int a[],int n,int l,long long int k,long long int s,int num,int p) { 	if(l==n&&s==k)return ++num; 	else if(l==n&&s>k) 	{ 		 			s=0; 			p++; 			l=p; 			check(a,n,l,k,s,num,p); 	} 	else if(l==n&&s!=k)return num; 	else 	{ 		if(s<k) 		{ 			s=s+a[l];l++; 			check(a,n,l,k,s,num,p); 		} 		else if(s==k) 		{ 			num++; 			s=0;p=l; 			check(a,n,l,k,s,num,p); 		} 		else if(s>k) 		{ 			s=0; 			p++; 			l=p; 			check(a,n,l,k,s,num,p); 		} 	} } int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		long long int k;int n; 		cin>>n>>k; 		int a[n]; 		int i; 		for(i=0;i<n;i++)cin>>a[i]; 		int h=check(a,n,0,k,0,0,0); 		cout<<h<<"\n"; 	} 	return 0; }
#include<iostream> #include<math.h> using namespace std;     int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		int n,sum=0; 		cin>>n; 		for(int i=1;i<=n;i++) 		{ 			sum=sum+floor(i/2); 		} 		cout<<sum<<endl; 	} 	return 0; } 
// Program to print BFS traversal from a given source vertex. BFS(int s) // traverses vertices reachable from s. #include<iostream> #include <list> #include<stdlib.h>  using namespace std;  // This class represents a directed graph using adjacency list representation class Graph {     int V;    // No. of vertices     list<int> *adj;    // Pointer to an array containing adjacency lists public:     Graph(int V);  // Constructor     void addEdge(int v, int w); // function to add an edge to graph     void BFS(int s);  // prints BFS traversal from a given source s };  Graph::Graph(int V) {     this->V = V;     adj = new list<int>[V]; }  void Graph::addEdge(int v, int w) {     adj[v].push_back(w); // Add w to v’s list. 	adj[w].push_back(v);// undirected } int *map; void Graph::BFS(int s) {     // Mark all the vertices as not visited     bool *visited = new bool[V];     for(int i = 0; i < V; i++)         visited[i] = false;      // Create a queue for BFS     list<int> queue;      // Mark the current node as visited and enqueue it     visited[s] = true;     queue.push_back(s);      // 'i' will be used to get all adjacent vertices of a vertex     list<int>::iterator i;      while(!queue.empty())     {         // Dequeue a vertex from queue and print it         s = queue.front(); //        cout << s << " ";         queue.pop_front();          // Get all adjacent vertices of the dequeued vertex s         // If a adjacent has not been visited, then mark it visited         // and enqueue it         for(i = adj[s].begin(); i != adj[s].end(); ++i)         {             if(!visited[*i])             {                 visited[*i] = true;                 queue.push_back(*i);                 map[*i]=s; 			}         }     } }  // Driver program to test methods of graph class int main() {/*     // Create a graph given in the above diagram     Graph g(4);     g.addEdge(0, 1);     g.addEdge(0, 2);     g.addEdge(1, 2);     g.addEdge(2, 0);     g.addEdge(2, 3);     g.addEdge(3, 3);      cout << "Following is Breadth First Traversal (starting from vertex 2) \n";     g.BFS(2); */ 	int t; 	cin>>t; 	while(t--){ 	  int n,hq1,hq2; 		 cin>>n; 		 cin>>hq1; 		 cin>>hq2; 	   //inp(n); 	   //inp(hq1); 	   //inp(hq2);         Graph g(n+1);  	   for(int i=1;i<=n;i++){ 			if(i!=hq1) 			{int x; 			 cin>>x; 			 g.addEdge(i,x); 		    } 	   } 	   map=(int*)calloc(n+2,sizeof(int)); 	   g.BFS(hq2); 	   for(int i=1;i<=n;i++){ 			if(i!=hq2){ 				cout<<map[i]<<" "; 			} 	   } 	   cout<<endl; 	   free(map); 	}     return 0; } 
#include<stdio.h> #include<math.h>  main() {       int m,n,i;       scanf("%d%d",&m,&n);       int arr[m],arr1[n];       int s1=0,s2=0;       for(i=0;i<m;i++)       {scanf("%d",&arr[i]);s1+=arr[i];}       for(i=0;i<n;i++)       {scanf("%d",&arr1[i]);s2+=arr1[i];}       int res;       int add=(s1&1)^(s2&1);       if(s1>s2)       res=s2+add+(s1-s2)/2;       else       res=s1+add+(s2-s1)/2;       printf("%d\n",res); } 
#include <iostream> #include <string.h>   using namespace std;    int main() { 	 	long long int t; 	cin>>t; 	while(t--) 		{ 				string a; 				cin>>a; 				int l=a.length(); 				int i,num=0,x=0; 				for(i=0;i<l;i++) 				{ 					 					x=(x*10+int(a[i])-48)%17; 				} 				if(x==0) 				cout<<"YES"<<endl; 				else 				cout<<"NO"<<endl; 		} 		 	 	return 0; } 
#include <cstdio> #include <sstream> #include <cstring> using namespace std; int a[30]={ 0,2, 6, 14, 30, 62, 126, 254, 510, 1022, 2046, 4094, 8190, 16382, 32766, 65534, 131070, 262142, 524286, 1048574, 2097150, 4194302, 8388606, 16777214, 33554430, 67108862, 134217726, 268435454, 536870910, 1073741822 };  int getchar_unlocked() { return getchar(); } inline void fastRead_string(char *str) {     register char c = 0;     register int i = 0;     while (c < 33)    c = getchar_unlocked();     while (c != '\n') {  str[i] = c;         c = getchar_unlocked();         i = i + 1;      }     str[i] = '\0'; }  int main() { 	register int i,x,y;bool s7=false; 	scanf("%d",&x); 	for(i=0;i<32;i++){ 		if(a[i]>=x) break; 	} 	while(i>=1){ 		if(x>(a[i]+a[i-1])/2)  {s7=true; printf("7");  } 		else { printf("4"); s7=false;} 		x-=s7?(a[i]-a[i-1]):(a[i]-a[i-1])/2; 		i--; 	} 	return 0; }
#include<iostream> #include<cstdio> #include<map> #include<cstring> #define MXC 100000 #define MXF (MXC<<1) using namespace std; int comp[MXC]; int parent[MXF]; map<string,int>mymap; int FIND(int x) {     if(x==parent[x])return x;     else     {         parent[x]=FIND(parent[x]);         return parent[x];     } } void reset() {      mymap.clear();      memset(comp,0,sizeof comp);      memset(parent,0,sizeof parent); } int main() {     int t,n,id1,id2,p1,p2,p,ans;     char a[50],b[50];     //string a,b;     cin>>t;     while(t--)     {               cin>>n;               int curr=1;               reset();               while(n--)               {                         scanf("%s %s",a,b);                         //cin>>a>>b;                         id1=mymap[a];                         id2=mymap[b];                         if(!id1 && !id2)                         {                                 mymap[a]=id1=curr++;                                 mymap[b]=id2=curr++;                                 parent[id1]=parent[id2]=id1;                                 comp[id1]=2;                                 cout<<2<<endl;                         }                         else if(!id1)                         {                                 mymap[a]=id1=curr++;                                 p=FIND(id2);                                 parent[id1]=p;                                 comp[p]+=1;                                 cout<<comp[p]<<endl;                         }                         else if(!id2)                         {                                 mymap[b]=id2=curr++;                                 p=FIND(id1);                                 parent[id2]=p;                                   comp[p]+=1;                                 cout<<comp[p]<<endl;                         }                         else                         {                                 p1=FIND(id1);                                 p2=FIND(id2);                                 ans=comp[p1];                                 if(p1!=p2)                                 {                                           if(comp[p1]<comp[p2])                                           {                                                                parent[p1]=parent[p2];                                                                comp[p2]+=comp[p1];                                                                ans=comp[p2];                                           }                                           else                                           {                                                                parent[p2]=parent[p1];                                                                comp[p1]+=comp[p2];                                                                ans=comp[p1];                                           }                                 }                                 cout<<ans<<endl;                         }               }     } }                                                                                                                                                                                     
#include <stdio.h> char board [ 3 ][ 4 ]; void getwinner ( int & winx , int & wino ) { int i , j , cnt , x , o ; x = o = 0 ; for ( i = 0 ; i < 3 ; i ++ ) { cnt = 0 ; for ( j = 0 ; j < 3 ; j ++ ) cnt += board [ i ][ j ]; if ( cnt == 'X' * 3 ) x ++ ; else if ( cnt == 'O' * 3 ) o ++ ; } for ( i = 0 ; i < 3 ; i ++ ) { cnt = 0 ; for ( j = 0 ; j < 3 ; j ++ ) cnt += board [ j ][ i ]; if ( cnt == 'X' * 3 ) x ++ ; else if ( cnt == 'O' * 3 ) o ++ ; } for ( i = j = cnt = 0 ; i < 3 ; i ++ , j ++ ) cnt += board [ i ][ j ]; if ( cnt == 'X' * 3 ) x ++ ; else if ( cnt == 'O' * 3 ) o ++ ; for ( i = 0 , j = 2 , cnt = 0 ; i < 3 ; i ++ , j -- ) cnt += board [ i ][ j ]; if ( cnt == 'X' * 3 ) x ++ ; else if ( cnt == 'O' * 3 ) o ++ ; winx = x ; wino = o ; } int main () { int t , i , j , x , o , d , winx , wino ; for ( scanf ( "%d" , & t ); t ; t -- ) { for ( i = 0 ; i < 3 ; i ++ ) scanf ( "%s" , board [ i ]); x = o = d = 0 ; for ( i = 0 ; i < 3 ; i ++ ) for ( j = 0 ; j < 3 ; j ++ ) if ( board [ i ][ j ] == 'X' ) x ++ ; else if ( board [ i ][ j ] == 'O' ) o ++ ; else d ++ ; getwinner ( winx , wino ); if ( o > x || ( o == x && winx ) || x > o + 1 || ( x == o + 1 && wino ) || winx > 2 || wino > 1 || ( winx && wino )) printf ( "no \n " ); else printf ( "yes \n " ); } return 0 ; }
#include <iostream> using namespace std;  int main() { 	std::ios_base::sync_with_stdio(false); 	 	int limits[]={1, 2, 4, 8, 16, 32, 64}; 	char letters[]={'A', 'B', 'C', 'D', 'E', 'F', 'G'}; 	int t; 	cin>>t; 	while(t--) 	{ 		int l; 		cin>>l; 		 		if(l==2 || l==4 || l==5 || l==8 || l==9) 		{ 			cout<<endl; 			continue; 		} 		 		int v=0; 		if(l<2) 			v=1; 		else if(l<4) 			v=2; 		else if(l<8) 			v=3; 		else if(l<16) 			v=4; 		else if(l<32) 			v=5; 		else if(l<64) 			v=6; 		else v=7; 	 		int arr[v+1]; 		int sum=0; 		for(int i=0; i<v; i++) 		{ 			arr[i]=i+1; 			sum+=(i+1); 		} 		arr[v]=l; 		 		while(sum!=l) 		{ 			for(int i=0; i<v; i++) 			{ 				if(arr[i]<limits[i]) 				{ 					if(arr[i]+1<arr[i+1]) 					{ 						arr[i]++; 						sum++; 						break; 					} 				} 			} 		} 		 		char ans[l]; 		for(int i=0; i<l; i++) 		{ 			ans[i]='0'; 		} 		 		for(int i=0; i<v; i++) 		{ 			ans[arr[i]-1]=letters[i]; 		} 		 		int let=0, count=1; 		for(int i=0;i<l; i++) 		{ 			if(arr[let]==0) 			{ 				let++; 			} 			 			if(ans[i]=='0') 			{ 				ans[i]=letters[let]; 				arr[let]--; 			} 			else if(ans[i]==letters[let]) 				arr[let]--; 			else  				arr[ans[i]-'A']--; 		} 		for(int i=0; i<l; i++) 		{ 			cout<<ans[i]; 		} 		cout<<endl; 	} } 
#include<bits/stdc++.h> using namespace std; #define lli long long int #define f(i,a,b) for(i=a;i<b;i++) #define si(a) scanf("%d",&a); #define slli(a) scanf("%lld",&a); #define INF 1000000007 #define MAX 100005 #define pb(a) push_back(a) #define sn struct node lli arr[MAX],mul[MAX]; long double logproduct[MAX]; int GCDW(lli a, lli b, lli & l, lli & k) {         if (!a) {                 // gcd(0, b) = 0 * 0 + 1 * b                 l = 0;                 k = 1;                 return b;         }         int d = GCDW(b % a, a, k, l);         l -= (b / a) * k;         return d; } lli RevMod(lli a, lli m) {         lli x, y;         if (GCDW(a, m, x, y) != 1) return -1;         x %= m;         if (x < 0) x += m;         return x; } lli fun(lli &fd,lli r,lli n) {     lli i,cur=1,l=1,p1,p2;     long double tmp,diff;     i=1;           cur=(mul[r]*arr[1])%INF;     tmp=logproduct[r]+log10(arr[1]);     /*while(i<=n)     {     //cur=(cur*arr[i])%INF;     tmp=tmp+log10(arr[i]);     i+=r;     }*/     fd=1;     tmp=tmp-floor(tmp);     tmp=tmp*1000000000;     for(i=1;i<=9;i++)     {     p1=log10(i)*1000000000;     p2=log10(i+1)*1000000000;     	if(tmp>=p1 && tmp<p2)     	{     		fd=i;     		break;     	}     }     return cur; } void change(lli index,lli value,lli r,lli inverse) {     mul[r]=(mul[r]*inverse)%INF;     mul[r]=(mul[r]*value)%INF;     logproduct[r]=(logproduct[r])-(log10(arr[index]+0.0))+(log10(value+0.0)); }     int main()     {     	lli q,i,j,k,ans,m,n,r,t,p,a,b,fd,cur,tmp,tmp1,inverse;         long double curlog;     	slli(n);           	f(i,1,n+1)     	slli(arr[i]);          f(r,1,n+1)         {         i=1;         cur=1;         curlog=0;          while(i <= n)         {             if(i!=1)             {             cur=(cur*arr[i])%INF;             curlog=(curlog)+log10(arr[i]);                     }             i+=r;         }         mul[r]=cur;         logproduct[r]=(curlog);         }      	slli(q);     	while(q--)     	{     		slli(p);     		if(p == 1)     		{     			slli(a);     			slli(b);                 tmp=a-1;                  if(tmp!=0)                 {                     tmp1=sqrt(tmp);                     for(i=1;i<=tmp1;i++)                     {                           if(tmp%i == 0)                         {                             inverse=RevMod(arr[a],INF)%INF;                             change(a,b,i,inverse);                             if(i != (tmp/i))                                 change(a,b,tmp/i,inverse);                         }                          }                 }                 arr[a]=b;     		}     		else     		{     			fd=1;     			slli(r);     			ans=fun(fd,r,n);     			printf("%lld %lld\n",fd,ans);     		}     	}     } 
#include<bits/stdc++.h> using namespace std; int main() {     int t;     scanf("%d",&t);     while(t--)     {         int n,p,q;         scanf("%d",&n);         int a[n];         for(int i=0;i<n;i++)             a[i]=0;         for(int i=0;i<n-1;i++)         {              scanf("%d %d",&p,&q);             a[q]=1;         }         for(int i=0;i<n;i++)         {             if(a[i]==0)             {                 printf("%d\n",i);             }          }     }     return 0; } 
#include <cstdio> #include <cstring>  #include <iomanip> #include <iostream> #include <queue> #include <vector>  using namespace std;  const int MAXN = 100001;  bool vis[MAXN];  int dead[MAXN]; int d[MAXN];  vector<int> inf[MAXN];  int main() {     int t;     scanf("%d", &t);     while (t--) {         int n, m, x, y;         scanf("%d", &n);          for (int i = 0; i <= n; ++i) {             inf[i].clear();             d[i] = dead[i] = 0;             vis[i] = false;         }          for (int i = 0; i < n - 1; ++i) {             scanf("%d %d", &x, &y);             inf[x].push_back(y);             inf[y].push_back(x);         }          scanf("%d", &m);         for (int i = 0; i < m; ++i) {             scanf("%d", &x);             dead[x] = 1;         }          queue<int> q;         q.push(1);         d[1] = dead[1];         vis[1] = true;         while (!q.empty()) {             int node = q.front();             q.pop();              for (int i = 0; i < inf[node].size(); ++i) {                 int next = inf[node][i];                 if (!vis[next]) {                     vis[next] = true;                     d[next] = d[node] + dead[next];                     q.push(next);                 }             }         }          double exp_val = 0.0;         for (int v = 1; v <= n; ++v) {             d[v] -= dead[v];             if (d[v] > 0)                  exp_val += (1 - 1.0 / (double) (d[v] + 1));         }         cout << setprecision(12) << exp_val << "\n";     }          return 0; } 
#include<bits/stdc++.h> using namespace std; inline int scan(){     char c = getchar_unlocked();     int x = 0;     while(c<'0'||c>'9'){         c=getchar_unlocked();     }     while(c>='0'&&c<='9'){         x=(x<<1)+(x<<3)+c-'0';         c=getchar_unlocked();     }     return x; } inline void putint(int n){         int N = n, rev, count = 0;         rev = N;         if (!N){             putchar_unlocked('0');             putchar_unlocked('\n');             return ;         }         while (!(rev%10)){             count++;             rev/= 10;         }         rev = 0;         while (N) {              rev = (rev<<3) + (rev<<1) + N % 10;             N /= 10;         }          while (rev != 0){             putchar_unlocked(rev % 10 + '0');             rev /= 10;         }         while (count--){             putchar_unlocked('0');         }     putchar_unlocked('\n'); } vector<int> v[100001]; bool visited[100001]={0}; vector<int> ans; void bfs(int node){     queue<int> q;     q.push(node);     while(!q.empty()){         int u=q.front();         q.pop();         visited[u]=1;         int x=v[u].size();         for(int i=0;i<x;i++){             int child=v[u][i];             if(!visited[child]){                 q.push(child);                 ans.push_back(child);                 visited[child]=1;                 if(child==node){                     ans.clear();                     return;                 }             }         }     }      } int main(){     int t=scan();     while(t--){         for(int i=0;i<100001;i++){             v[i].clear();         }         memset(visited,0,sizeof(visited));         int n=scan(),m=scan();         while(m--){             int a=scan(),b=scan();             v[a].push_back(b);         }         bool f=0;         int an=0;         for(int i=1;i<=n;i++){             if(!visited[i]){             memset(visited,0,sizeof(visited));                 ans.clear();             bfs(i);                // cout<<ans.size()<<" ";                 if(ans.size()>=n-1){                     f=1;                     an=i;                    // if(i==2){                     //printf("%d ",ans.size());                     //}                      break;                 }             }         }         if(f==0){             putchar_unlocked('-');             putchar_unlocked('1');             putchar_unlocked('\n');         }         else{             putint(an);                      }         ans.clear();     } }
#include <bits/stdc++.h> #define M 1000000007 #define lli unsigned long long   using namespace std;   lli fast_pow(lli a, lli b) { 	lli res = 1LL; 	while ( b > 0 ) { 		if ( b & 1 ) res = (res*a)%M; 		a = (a*a)%M; 		b >>= 1; 	} 	return res; }   int main() { 	int t; 	lli n,k; 	scanf("%d", &t); 	while ( t-- ) { 		scanf("%lld%lld", &n, &k); 		lli base = 0, pro = 1; 		while ( 1 ) { 			if ( pro >= n ) break; 			pro *= 2LL; 			base++; 		} 		if ( pro != n ) base--; 		lli ans = fast_pow(base, k); 		printf("%lld\n", ans); 	} 	return 0; } 
//#include<bits/stdc++.h> #include <iostream> #include <cstdio> #include <vector> #include <map> #include <queue> #include <stack> #include <cstring> #include <algorithm> #include <cstdlib> #include <cmath> #include <set> using namespace std; #define w(t) while(t--) #define S(x) scanf("%d",&x) #define SLL(x) scanf("%lld",&x) #define P(x) printf("%d\n",x) #define fl(i , a, b) for(i = (int)a; i<(int)b; i++) #define mem(a , value) memset(a , value , sizeof(a)) #define tr(c, itr) for(itr = (c).begin(); itr != (c).end(); itr++) #define MOD 1000000007 #define MAX 1000000010 #define ll long long #define all(v) v.begin(),v.end() #define mp make_pair #define pb push_back #define f first #define s second typedef pair<int,int> pp; ll a[1002][1002]; ll dp[1002][1002]; void ncr() { 	int i , j ; 	for(i =0 ;i <= 23 ; i++) 	{ 		for(j =0 ; j<= i ; j++) 		{ 			if(i == 0 || j ==0 ) dp[i][j] =1; 			else 				dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]);  		} 	} 	// cout << dp[7][3] <<endl; } int main() { 	//std::ios_base::sync_with_stdio(false); 	int n  ,i , j ; 	ncr(); 	S(n); 	fl(i ,1 , n+1) 	{ 		fl(j , 1 , n+1) SLL(a[i][j]); 	} 	ll ans =0 ; 	for(i = 1; i<=n ; i++) 	{ 		for(j = i+1; j<= n ;j++) 		{ 			// i - j edge .  			for(int size =2 ; size <= n; size++) 			{ 				int p = size-2;  				ll ways = dp[n-2][p]; 				ans = ans + (a[i][j] * ways * (int(sqrt(size))));  			} 		} 	} 	cout << ans <<endl ; 	return 0; }
#include <bits/stdc++.h> using namespace std; int main() { 	vector<int> v(1000001),div(1000001); 	int t,i,j,n; 	v[1]=1; 	v[0]=1; 	for(i=2;i<=1000000;i++) 	{ 		if(v[i]==0) 		{ 			div[i]=1; 			for(j=2*i;j<=1000000;j=j+i) 			{ 				div[j]++; 				v[j]=1; 			} 		} 	} 	scanf("%d",&t); 	while(t--) 	{ 	   	scanf("%d",&n); 	   	if(v[div[n]]==0) 	   		printf("Funny\n"); 	   	else 	   		printf("Not Funny\n"); 	} 	return 0; } 
#pragma comment(linker, "/STACK:102400000,102400000") #include <iostream> #include <stdio.h> #include <algorithm> #include <string.h> #include <vector> #include <map> #include <queue> #include <set> #include <cmath> #include <fstream> #include <assert.h> #include <complex> using namespace std; #define vi vector<int> #define pii pair<int,int> #define pb push_back #define mp make_pair #define all(x) x.begin(),x.end() #define inf 1000000007 #define mod 1000000007 #define x first #define y second #define pi acos(-1.0) #define DBG(x) cerr<<(#x)<<"="<<x<<"\n"; #define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++) #define ull unsigned long long #define ll long long #define N 1000000  const int M=999999; double sum(int l,int r){     return (l+r)/2.*(r-l+1); } int main() {     //freopen("1.txt","w",stdout);     int T,i,j,k,ca=0,n,m;     scanf("%d",&n);     long double s=0,bias=0,ans=0,ave=M/2.;     deque<pair<int,long double> >q;     q.push_back(mp(1,1));     q.push_back(mp(M,0));         for(i=0;i<n;i++){         int v,r=N,x;s=0;         scanf("%d",&v);         int y=v;         while(v){             x=min(v,q.back().x);             v-=x;             q.back().x-=x;             s+=(q.back().y+bias)*x;             ans-=(bias+q.back().y)*sum(r-x,r-1);             if(q.back().x==0)q.pop_back();             r-=x;         }         q.push_front(mp(y,-bias));         bias+=s/N;         ans+=(1-s)*y;         ans+=s*ave;         printf("%.9lf\n",(double)ans);     }     return 0; }
#include<iostream> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {         long long n;         cin>>n;         cout<<n-1<<endl;     } } 
#include <iostream> #include <string> #include <stdlib.h> using namespace std;  struct guy { 	string name; 	int score; };  int main() { 	ios_base::sync_with_stdio(false); 	cin.tie(NULL);  	int t, score, flag=0, count=0, max=0, rem; 	string name, scoreS; 	cin >> t; 	guy a[t][15]; 	for (int z=0; z<t; z++) 	{ 		count=0; 		int n; 		cin >> n; cin.ignore(); 		for (int i=0; i<n; i++) 		{ 			flag=0; 			getline(cin, name, ' '); 			getline(cin, scoreS); 			score=atoi(scoreS.c_str()); 			for (int j=0; j<count; j++) 			{ 				if (a[z][j].name==name)  				{ 					a[z][j].score+=score; 					flag=1; 				} 			} 			if (flag==0) 			{ 				a[z][count].name=name; 				a[z][count].score=score; 				count++; 			} 		}  		max=0; 		for (int i=0; i<count; i++) 		{ 			if (a[z][i].score>max)  			{ 				max=a[z][i].score; 				rem=i; 			} 			//cout << count << " " << i << " " << a[z][i].name << " " << a[z][i].score << endl;	 		} 		cout << a[z][rem].name << " " << a[z][rem].score << endl; 	} }
#include<bits/stdc++.h> #include <math.h> using namespace std;  #define MOD 1000000007 #define MAX 2010 #define ll long long #define slld(t) scanf("%lld",&t) #define sd(t) scanf("%d",&t) #define sld(t) scanf("%ld",&t) #define pd(t) printf("%d\n",t) #define plld(t) printf("%lld\n",t) #define pcc pair<char,char> #define pp pair<int,int> #define pll pair<ll,ll> #define tr(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++) #define mp(a,b) make_pair(a,b) #define F first #define S second #define pb(x) push_back(x)  int A[1000007];  bool f(int x) { 	if(x==1) return false; 	int m = sqrt(x); 	if(m*m==x){ 		return true; 	} 	return false; } int main() { 	int t; 	sd(t); 	while(t--) 	{ 		int n; 		sd(n); 		int count = 0; 		for( int i=1; i<=n; i++) 		{ 			sd(A[i]); 			int k = __gcd(i,A[i]); 			if(f(k)) 			{ 				count++; 			} 		} 		sort(A+1,A+n+1); 		ll ans = 1; 		for( int i=n; i>n-count; i--) 		{ 			ans = ans*A[i]; 			ans%=MOD; 		} 		plld(ans); 	} }
#include<bits/stdc++.h> using namespace std;  #define ll long long #define inf 0x7fffffff #define SCD(t) scanf("%d",&t) #define SCLD(t) scanf("%ld",&t) #define SCLLD(t) scanf("%lld",&t) #define SCC(t) scanf("%c",&t) #define SCS(t) scanf("%s",t) #define SCF(t) scanf("%f",&t) #define SCLF(t) scanf("%lf",&t) #define pr pair<int,int> #define mp(a,b) make_pair(a,b) #define pb push_back #define fr first #define sc second #define mset(arr,val) memset(arr,val,sizeof(arr));  const int MAX = 500005; const int MOD = 1e9+7;  int gcd(int a,int b){ 	if(a%b == 0) return b; 	else return gcd(b,a%b); }  int arr[MAX]; int n,k; bool calc(int len){ 	int tlen = len; 	std::vector< int > pre(n+1); 	std::vector< int > suf(n+1); 	for(int i = 0;i<n;i+=len){ 		if(i+len>=n) len = n - i; 		int gcdp = arr[i]; 		int gcds = arr[i+len-1]; 		for (int j = 0; j < len; ++j) 		{ 			gcds = gcd(gcds,arr[i+len-1-j]); 			gcdp = gcd(gcdp,arr[i+j]); 			pre[i+j] = gcdp; 			suf[i+len-1-j] = gcds; 		} 	} 	// for (int i = 0; i < n; ++i) 	// { 	// 	cout<<i<<" "<<suf[i]<<" "<<pre[i]<<endl; 	// } 	len = tlen; 	for (int i = 0; i <= n-len; ++i) 	{ 		int gcdh = gcd(suf[i],pre[i+len-1]); 		if(gcdh >= k) return true; 	} 	return false; }  int main(){ 	// freopen("input.txt","r",stdin); 	cin>>n>>k; 	for (int i = 0; i < n; ++i) 	{ 		cin>>arr[i]; 	} 	// cout<<calc(4); 	int li = 0; 	int ul = n; 	while(li<ul){ 		int mid = (li+ul+1)/2; 		if(calc(mid)) 			li = mid; 		else 			ul = mid-1; 	} 	cout<<li; }
#include <bits/stdc++.h>  using namespace std;  typedef long long int ll;  int gcd(int a, int b) { 	while(b) 	{ 		int t = a % b; 		a = b; 		b = t; 	} 	return a; }  int main() { 	int T; 	scanf("%d",&T); 	while(T--) 	{ 		int N, Q; 		scanf("%d%d",&N,&Q); 		int* A = new int[N]; 		for(int i = 0;  i < N; i++) 			scanf("%d",&A[i]); 		int* ltor = new int[N]; 		int* rtol = new int[N]; 		ltor[0] = A[0]; 		for(int i = 1; i < N; i++) 			ltor[i] = gcd(max(A[i], ltor[i - 1]), min(A[i], ltor[i - 1])); 		rtol[N - 1] = A[N - 1]; 		for(int i = N - 2; i >= 0; i--) 			rtol[i] = gcd(max(A[i], rtol[i + 1]), min(A[i], rtol[i + 1])); 		int L, R; 		while(Q--) 		{ 			scanf("%d%d",&L,&R); 			L--, R--; 			if(L == 0) 				printf("%d\n",rtol[R + 1]); 			else if(R == N - 1) 				printf("%d\n",ltor[L - 1]); 			else 				printf("%d\n",gcd(ltor[L - 1], rtol[R + 1])); 		} 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; int C[100010],n; vector< pair<int,int> > E[100010]; vector<int> G[100010]; char visited[100010]; int D[100010]; vector<int> V;  int dfs(int x,int val) {   int ret=x;   vector<int>::iterator it;   for(it=G[x].begin();it!=G[x].end();it++)   {     if(visited[*it]!=val)     {        D[*it]=1+D[x];        visited[*it]=val;        int z = dfs(*it,val);         if(D[z]>D[ret])          ret=z;     }   }   return ret; }  int process(int g) {    for(int g2=g;g2<=100000;g2+=g)    {      vector< pair<int,int> >::iterator it;      for(it=E[g2].begin();it!=E[g2].end();it++)      {         pair<int,int> p= *it;          G[p.first].push_back(p.second);         G[p.second].push_back(p.first);         V.push_back(p.first);         V.push_back(p.second);      }    }     int ret=0;    vector<int>::iterator it;    for(it=V.begin();it!=V.end();it++)    {         if(visited[*it])           continue;            D[*it]=0;           visited[*it]=1;           int y = dfs(*it,1);           D[y]=0;           visited[y]=2;           y = dfs(y,2);           ret = max(ret,D[y]);    }     for(it=V.begin();it!=V.end();it++)    {       G[*it].clear();       visited[*it]=0;    }     V.clear();    return ret;   }  int main() {    int t;    cin>>t;    int x,y,c;     while(t--)    {      cin>>n;      int mxx=0;      for(int i=1;i<=100000;i++)       E[i].clear();        for(int i=0;i<n-1;i++)       {        cin>>x>>y>>c;        x--; y--;        mxx = max(mxx,c);        E[c].push_back(make_pair(x,y));       }        for(int g=1;g<=mxx;g++)       {          C[g]=0;            for(int g2=g;g2<=mxx;g2+=g)              C[g]+=E[g2].size();       }       long long ans=0;       for(int g=1;g<=mxx;g++)       {          int mx=0;           for(int g2=2*g;g2<=mxx;g2+=g)            mx=max(mx,C[g2]);         if(mx<C[g])           ans=max(ans,1LL*g*process(g));       }       cout<<ans<<endl;      }   } 
#include <bits/stdc++.h> using namespace std;  #define ll long long  ll all_xor(ll n){     if(n % 2 == 1){         if(n % 4 == 1)  return 1;         else return 0;     }     else{         if(n % 4 == 0)  return n;         else return n + 1;     } }  ll xor_even(ll n){     return (all_xor(n / 2) * 2); }  ll xor_odd(ll n){     return (all_xor(n) ^ xor_even(n - 1)); }  void solve(){     ll x, m, ans;     cin>>x>>m;      ans = all_xor(x + (2 * m) - 2) ^ all_xor(x - 1);     if(x % 2 == 0)  ans ^= (xor_odd(x + (2 * m) - 3) ^ xor_odd(x - 1));     else ans ^= (xor_even(x + (2 * m) - 3) ^ xor_even(x - 1));      if(x == 0 and m == 0)  ans = 0;      if(ans == 0)    cout<<"BOB"<<endl;     else cout<<"ALICE"<<endl; }  int main(){      int t;     cin>>t;     while(t--)  solve();     return 0; }
//Author : pakhandi // using namespace std;   #include<iostream> #include<cstdio> #include<cstdlib> #include<algorithm> #include<cmath> #include<cstring> #include<iterator> #include<sstream> #include<fstream> #include<cassert> #include<climits> #include<cstdlib> #include<string> #include<vector> #include<queue> #include<deque> #include<stack> #include<map> #include<set> #include<bitset>   #define wl(n) while(n--) #define fl(i,a,b) for(i=a; i<b; i++) #define rev(i,a,b) for(i=a; i>=b; i--) #define scan(n) scanf("%d", &n) #define scans(s) scanf("%s", s) #define scanc(c) scanf("%c", &c) #define scanp(f) scanf("%f", &f) #define print(n) printf("%d\n", n) #define prints(s) printf("%s\n", s) #define printc(c) printf("%c\n", c) #define printp(f) printf("%f\n", f) #define nline printf("\n") #define mclr(strn) strn.clear() #define ignr cin.ignore() #define MOD 1000000007 #define ll long long int #define u64 unsigned long long int int arr[10005]; int main() { 	int i, j, cases, k=1; 	int n, h, flag; 	scan(cases); 	wl(cases) 	{ 		scan(h); 		scan(n); 		flag=0; 		arr[0]=0; 		fl(i,1,n+1) 			scan(arr[i]); 		sort(arr, arr+(n+1)); 		fl(i,1,n+1) 		{ 			//cout<<arr[i]; 			if(arr[i]-arr[i-1]>h) 			{ 				printf("No"); 				flag=1; 				break; 			} 		} 		if(flag==0) 			printf("Yes"); 		nline; 	} 	return 0; }
//Author : pakhandi // using namespace std;   #include<iostream> #include<cstdio> #include<cstdlib> #include<algorithm> #include<cmath> #include<cstring> #include<iterator> #include<sstream> #include<fstream> #include<cassert> #include<climits> #include<cstdlib> #include<string> #include<vector> #include<queue> #include<deque> #include<stack> #include<map> #include<set> #include<bitset>   #define wl(n) while(n--) #define fl(i,a,b) for(i=a; i<b; i++) #define rev(i,a,b) for(i=a; i>=b; i--) #define scan(n) scanf("%d", &n) #define scans(s) scanf("%s", s) #define scanc(c) scanf("%c", &c) #define scanp(f) scanf("%f", &f) #define print(n) printf("%d\n", n) #define prints(s) printf("%s\n", s) #define printc(c) printf("%c\n", c) #define printp(f) printf("%f\n", f) #define nline printf("\n") #define mclr(strn) strn.clear() #define ignr cin.ignore() #define MOD 1000000007 #define ll long long int #define u64 unsigned long long int int arr[1000005]; int main() { 	int i, j, cases, k=1; 	scan(cases); 	int np, l, a, count; 	wl(cases) 	{ 		scan(np); 		scan(l); 		fl(i,0,1000005) 		{ 			arr[i]=0; 		} 		fl(i,0,l) 		{ 			scan(a); 			arr[a]++; 			scan(a); 			arr[a]++; 		} 		count=0; 		fl(i,0,1000005) 		{ 			if(arr[i]%2!=0 && arr[i]>0){ 				//cout<<arr[i]; 				count++; 				} 		} 		if(count==0 || count==2) 			printf("Possible"); 		else 			printf("Not Possible"); 		nline; 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; int visited[105]; int main() { 	int t,n,m,q,i,j; 	scanf("%d",&t); 	while(t--) 	{ 		vector< vector<int> > v(105); 		int count=0,temp1,temp2; 		scanf("%d",&n); 		for(i=1;i<=n;i++) 		visited[i]=0; 		scanf("%d %d",&m,&q); 		for(i=1;i<=m;i++) 		{ 			scanf("%d %d",&temp1,&temp2); 			v[temp1].push_back(temp2); 			v[temp2].push_back(temp1); 		} 		 		for(i=1;i<=n;i++) 		{ 			if(visited[i]==0) 			{ 				count++; 			    visited[i]=count; 				queue<int> q; 				q.push(i); 				while(!q.empty()) 				{	 						int temp=q.front(); 						q.pop(); 						int len=v[temp].size(); 						for(int i=0;i<len;i++) 						{ 							if(visited[v[temp][i]]==0) 							{ 							visited[v[temp][i]]=count; 							q.push(v[temp][i]); 							} 						} 				} 			} 		} 		for(i=1;i<=q;i++) 		{ 			scanf("%d %d",&temp1,&temp2); 			if(visited[temp1]!=visited[temp2]) 			printf("bus and taxi\n"); 			else 			printf("only bus\n"); 		} 	} 	return 0; }
#include <iostream> #include <algorithm> #include <vector> #include <string>  using namespace std;  int main() { 	int tc; 	cin >> tc; 	string sn; 	while (tc--) { 		cin >> sn; 		if(next_permutation(sn.begin(),sn.end())) 			cout << sn << endl; 		else 			cout << "-1"<<endl; 	} 	return 0; }
#include<iostream> using namespace std; int main() { int t,n,i,op; int a,dif; //cin>>t; scanf("%d",&t); for(int i=0;i<t;i++) {a=1; //cin>>n; scanf("%d",&n);  if(n==0||n==1) op=n;  else { while(a<=n) {a=a*2;}  a=a/2; dif=n-a; op=2*dif+1; } //cout<<op<<"\n"; printf("%d\n",op);  }  return 0; } 
#include <iostream> using namespace std;   int main() { 	int t; 	while(scanf("%d",&t) != EOF) 	{ 		printf("%d\n",t-1); 	} 	return 0; }
#include<iostream> #include<cstdio> #include<cstdlib> #include<algorithm> using namespace std;   typedef long long ULL; #define REP(i,N) for(int i = 0; i < N; i++)   int main() { 	int t, N; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d",&N); 		int * arr =(int *)calloc(N,sizeof(int)); 		int j; 		for(int i = 0; i < N; i++) 		{ 			scanf("%d",&arr[i]); 			j = arr[i] - i; 			arr[i] = j; 		} 		//cout<<"SORTING"<<endl; 		sort(arr,arr+N); 		//REP(i,N)	cout<<arr[i]<<" "; 		//cout<<endl; 		//cout<<"SORTING DONE"<<endl; 		int maxC=1,cnt=1; 		j = arr[0]; 		for(int i = 1; i < N; i++) 		{ 			if(arr[i] == j) 			{ 				cnt += 1; 				if(cnt > maxC) 					maxC = cnt; 			} 			else 			{ 				if(cnt > maxC)  					maxC = cnt; 				cnt = 1; 				j = arr[i]; 			} 		} 		printf("%d\n",N-maxC); 		free(arr); 	} 	return 0; }
//Author : pakhandi // using namespace std;   #include<iostream> #include<cstdio> #include<cstdlib> #include<algorithm> #include<cmath> #include<cstring>   #define wl(n) while(n--) #define fl(i,a,b) for(i=a; i<b; i++) #define rev(i,a,b) for(i=a; i>=b; i--) #define scan(n) scanf("%d", &n) #define scans(s) scanf("%s", s) #define scanc(c) scanf("%c", &c) #define scanp(f) scanf("%f", &f) #define scanll(l) scanf("%lld", &l) #define print(n) printf("%d\n", n) #define prints(s) printf("%s\n", s) #define printc(c) printf("%c\n", c) #define printp(f) printf("%f\n", f) #define printll(l) printf("%lld\n", l) #define nline printf("\n") #define mclr(strn) strn.clear() #define ignr cin.ignore() #define MOD 1000000007 #define ll long long int   int mat[3][2][4]=  {   {{10, 15, -25, 1} , {-10, -15, 25, 2}} ,   {{10, 15, -25, 0} , {-10, -20, 30, 1}} ,   {{10, 20, -30, 2} , {-10, -15, 25, 0}} };   int main() {   int i, j, cases=2, n;   int temp=0, eb=60, ew=100, eg=160, b, w, g, ele;     	  scan(n); 	  eb=60; ew=100; eg=160; 	  fl(i,0,n) 	  { 	    scan(ele); 		ele--; 	    eb=eb+mat[temp][ele][0]; 	    ew=ew+mat[temp][ele][1]; 	    eg=eg+mat[temp][ele][2]; 	    temp=mat[temp][ele][3]; 	  } 	  eb/=10; 	  ew/=10; 	  eg/=10; 	  printf("%d %d %d", eb,ew, eg); 	  nline;     return 0; } 
#include<iostream> #include<cstdio> #include<cstdlib> #include<algorithm>  using namespace std; typedef long long ll;  int main() { 	int t; 	ll ans,n; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%lld",&n); 		if(n == 1) 		{ 			printf("1\n"); 			continue; 		} 		ans = (n*n)/2 -1; 		printf("%lld\n",ans); 	} 	return 0; }
#include <bits/stdc++.h> #define pb push_back #define mp make_pair #define s(a) sort(a.begin(),a.end()) #define vecll vector<long long int> #define vecs vector<string> #define vecpll vector<pair<long long int,long long int> > #define rep(i,a,b) for(long long int (i)=(a);(i)<(b);(i)++) #define repr(i,b,a) for(long long int (i)=(b);(i)>=(a);(i)--) #define fast_IO ios_base::sync_with_stdio(false);cin.tie(0); #define while_tc long long int t;cin>>t;while(t--) #define ispow2(n) (n&&(!(n&(n-1))))      ///check if its perfect power of 2 #define MOD 1000000007 #define arrinput long long int n;cin>>n;long long int a[n];for(long long int i=0;i<n;i++)cin>>a[i] typedef long long int ll; using namespace std; int main() { 	while_tc 	{ 	ll n; 	ll ans=0; 	cin>>n; 	for(ll i=n;i!=0;i--) 	{ 		ans=ans+(i*(n/i)); 	} 	cout<<ans%1000000007<<endl;}  }
//	__R0b__ #include <iostream> using namespace std;  inline int gcd(int a,int b){ 	if(b==0) 		return a; 	return gcd(b,a%b); }  int main(){ 	int t; cin>> t; 	for(int i=1;i<=t;i++){ 		int a,b,c; cin>> a >> b >> c; 		int g = gcd (a,b); 		//cout << g << endl; 		if (c%g==0){ 			printf("Case %d: ",i); 			puts ("Yes"); 		} 		else{ 			printf("Case %d: ",i); 			puts("No"); 		} 	} 	return 0; } 
#include<bits/stdc++.h>   using namespace std;  #define M 1000000007 typedef long long ll; int main() { 	 	ll t; 	cin>>t; 	 for(ll l=1;l<=t;l++)	 {  	ll n; 		cin>>n; 		 		 ll a[n+1]; 	for(ll i=1;i<=n;i++) 	{ 		a[i]=i; 		a[i]=a[i]%M; 	} 		 		for(ll j=2;j<=n;j++) 		{ 			 			for(ll i=1;i<=n-j+1;i++  ) 			{ 				 				a[i]=a[i]+a[i+1]; 				 				a[i]=a[i]%M; 			} 			 			 			 			 		} 		 		 		 		cout<<"Case "<<l<<": "<<a[1]<<endl; 		 		 	//	    printf("Case %lld: 1\n",a[1]); 		 	} 	 	 	return 0; }
#include <iostream> #include <cstring> #include <cstdio> #include <cmath> #include <map> #include <cassert>  using namespace std;  int bkt_size; int n; int tree[223][200005]; int A[100005];  //Code for FAST INPUT :) template <typename T> inline void fi(T *a) {     register char c=0;     while (c<33) c=getchar_unlocked();     *a=0;     int tmp = 0;     while (c>33)     {         if ( c == 45 ) tmp = 1;         else *a=*a*10+c-'0';         c=getchar_unlocked();     }     if ( tmp == 1 ) *a = 0-(*a); }  void update(int idx1, int idx2, int val) {     while ( idx2 <= n ) {         tree[idx1][idx2] += val;         idx2 += (idx2 & (-idx2));     }     return; }  int query(int idx1, int idx2) {     int ans = 0;     while ( idx2 > 0 ) {         ans += tree[idx1][idx2];         idx2 -= (idx2 & (-idx2));     }     return ans; }  struct node {     int type;     int a;     int b;     int val;     node() {  }     node(int type, int a, int b, int val)     {          this->type = type;          this->a = a;          this->b = b;          this->val = val;     } }Q[100005];  int main() {     map <int, int> mp;     map <int, int> :: iterator it;     int q, cnt = 1, type, x, y, val, ans, idx;      fi(&n), fi(&q);     assert(n >= 1 && n <= 100000);     assert(q >= 1 && q <= 100000);     bkt_size = 220;      for ( int i = 1; i <= n; i++ ) fi(&A[i]), mp[A[i]] = 1, assert(A[i] >= 1 && A[i] <= 1000000000);      for ( int i = 1; i <= q; i++ ) {         fi(&type);         assert(type >= 1 && type <= 2);         if ( type == 1  ) {             fi(&x), fi(&val);             assert(x >= 1 && x <= n);             assert(val >= 1 && val <= 1000000000);             mp[val] = 1;             Q[i] = node(1,x,x,val);         }         else {             fi(&x), fi(&y), fi(&val);             assert(x <= y);             assert(x <= n && x >= 1 && y >= 1 && y <= n);             mp[val] = 1;             Q[i] = node(2,x,y,val);         }     }      for ( it = mp.begin(); it != mp.end(); it++ ) it->second = cnt++;      for ( int i = 1; i <= n; i++  ) A[i] = mp[A[i]];     for ( int i = 1; i <= q; i++ ) Q[i].val = mp[Q[i].val];      for ( int i = 1; i <= n; i++ ) update(i/bkt_size, A[i], 1);      for ( int i = 1; i <= q; i++ ) {         if ( Q[i].type == 1  ) {             update(Q[i].a/bkt_size, A[Q[i].a], -1);             A[Q[i].a] = Q[i].val;             update(Q[i].a/bkt_size, A[Q[i].a], 1);         }         else {             ans = 0;             idx = Q[i].a;             while ( idx%bkt_size != 0 && idx <= Q[i].b  ) {                 ans += (A[idx] <= Q[i].val);                 idx++;             }             while ( idx+bkt_size-1 <= Q[i].b ) {                 ans += query(idx/bkt_size, Q[i].val);                 idx += bkt_size;             }             while ( idx <= Q[i].b ) {                 ans += (A[idx] <= Q[i].val);                 idx++;             }             printf("%d\n", ans);         }     }     return 0; } 
#include<iostream> using namespace std;  int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		int w; 		cin>>w; 		if(w%2==0 && w!=2) 			cout<<"YES"<<endl; 		else 			cout<<"NO"<<endl; 	} 	return 0; }
#include<bits/stdc++.h> #define mod 215372682525LL using namespace std; //typedef long long ll; long long arr[100010]; long long ans[100010]; int main() { 	std::ios_base::sync_with_stdio(false); 	long long  t; 	cin>>t; 	while(t--) 	{ 		long long a,d,n,x,i; 		cin>>a>>d>>n>>x; 	 		memset(arr,0,sizeof(arr)); 		memset(ans,0,sizeof(ans)); 		arr[0]=1; 		ans[0]=1; 		for(i=1;i<=n+1;i++) 		{ 			arr[i]=((arr[i-1]%mod)*(x%mod))%mod; 			arr[i]%=mod; 			ans[i]=(ans[i-1]+arr[i])%mod; 			ans[i]%=mod; 			 		} 		long long  ans1=0; 		for(i=0;i<=n;i++) 		{ 			ans1+=(i*arr[n-i])%mod; 			ans1%=mod; 		} 	 		cout<<((ans1*d)%mod+(ans[n]*a)%mod)%mod<<endl; 	} }
#include<bits/stdc++.h> using namespace std; #define ll long long ll *id, cnt, *sz; map<ll,ll> mp;  //use this map to map indexes with data. void init(ll N) {     cnt = N; 	id = new ll[N+1]; 	sz = new ll[N+1];     for(ll i=1; i<=N; i++)     {         id[i] = i; 	    sz[i] = 1; 	} } ll find(ll p) {     if(id[p]==p)         return p;     return id[p]=find(id[p]); } // Replace sets containing x and y with their union. void merge(ll x, ll y) {     ll i = find(x);     ll j = find(y);     if (i == j) return;     // make smaller root point to larger one     if(sz[i]<sz[j])     {         id[i]=j;         sz[j]+=sz[i];     }     else     {         id[j]=i;         sz[i]+=sz[j];     }     cnt--; } vector<pair <ll, pair<ll, ll> > > p; vector<ll> mst[200003]; ll nodes,edges; long long kruskal() {     ll x, y;     long long cost, minimumCost = 0;     for(ll i = 0;i < edges;++i)     {         x = p[i].second.first;         y = p[i].second.second;         cost = p[i].first;         if(find(x) != find(y))         {             minimumCost += cost;             mst[x].push_back(y);             mst[y].push_back(x);             merge(x, y);         }     }     return minimumCost; } vector<pair<ll,ll> > v; bool visited[200003]; ll subcnt[200003],ans[200003]; ll dfs(int x, int par) {     ans[x] = 0;     subcnt[x] = 0;     for (int i = 0; i < mst[x].size(); i++)     {         if (mst[x][i] == par)             continue;         ll ccnt = dfs(mst[x][i], x);         ans[x] += ccnt * subcnt[x];         subcnt[x] += ccnt;     }     return subcnt[x] + 1; } bool comp(const pair<ll,ll> &a,const pair<ll,ll> &b) {     if(a.first!=b.first)     {         return a.first>b.first;     }     return a.second<b.second; } int main() {     ios_base::sync_with_stdio(false);     cin.tie(NULL);     cout.tie(NULL);     ll x, y;     long long weight, cost, minimumCost;     ll i,n;     cin >> nodes >> edges;     init(nodes);     //creating the sets     for(i = 0;i < edges;++i)     {         cin >> x >> y >> weight;         p.push_back(make_pair(weight, make_pair(x, y)));     }     sort(p.begin(),p.end());     minimumCost = kruskal();     dfs(1,-1);     for(i=1;i<=nodes;i++)     {         ans[i]+=subcnt[i]*(nodes-1-subcnt[i]);         v.push_back(make_pair(-ans[i],i));     }     sort(v.begin(),v.end());     for(i=0;i<v.size();i++)     {         cout<<v[i].second<<"\n";     }     return 0; } 
/* Written by: Durgesh Kr. Soni    ABV-IIITM Gwalior    Problem:GOOGOL04*/  #include<bits/stdc++.h> using namespace std;  //template tools #define pb                   push_back #define ppb                  pop_back #define mp                   make_pair #define ff                   first #define ss                   second  #define INF                  2147483647 #define INFLL                9223372036854775807LL #define PI                   acos(-1.0) #define E                    exp(1.0) #define EPS                  1e-12 #define gcd(_1,_2)           __gcd(_1,_2) #define lcm(_1,_2)           ((_1/gcd(_1,_2))*(_2)) #define cnt_1                __builtin_popcountll #define rep(i,a,b)           for(int i=(a);i<=(b);++i) #define rer(i,b,a)           for(int i=(b);i>=(a);--i) #define clr(_)               memset(_,false,sizeof(_)) #define feach(c,_)           for(__typeof((c).begin()) _=(c).begin();_!=(c).end();++_) #define all(_)               _.begin(),_.end() #define sz(_)                (int(_.size())) #define len(_)               (int(_.length())) #define T()                  int _;cin>>_;while(_--) #define exist(x,_)           (((_).find(x))!=((_).end()))  //traces #define SP                   system("pause") #define nl                   cout<<endl #define dbg(vari)            cerr<<#vari<<" = "<<(vari);nl #define dbgv(A,n)            nl;rep(ti,0,n-1) cout<<ti<<" -- > "<<A[ti]<<"\n"; #define dbgvp(Z)             nl;rep(ti,0,sz(Z)-1){cout<<ti<<" --> "<<Z[ti].ff<<" "<<Z[ti].ss<<"\n";} #define dbgg(W,n)            nl;rep(ti,1,n){cout<<ti<<" --> ";rep(tj,0,sz(W[ti])-1) cout<<"("<<W[ti][tj].ff<<" , "<<W[ti][tj].ss<<")"<<"  ";cout<<"\n";} #define dks                  cerr<<" ----- I am Here -----\n";SP #define fout(S,x)            cout<<fixed<<setprecision(x)<<(S)<<endl  typedef long long int LL;     typedef unsigned long long ULL;  typedef long double LD;      typedef pair<int,int> PII; typedef vector<int> VI;       typedef vector<PII> VPII;        typedef set<PII> SPII;       typedef vector<LL> VLL; typedef pair<LL,LL> PLL;      typedef vector<PLL> VPLL;        typedef set<PLL> SPLL;       typedef map<LL,LL> MLL; typedef map<string,int> MSI;  typedef map<int,VI> MVI;         typedef map<int,PII> MPII;   typedef vector<string> VS;  //mathematics #define dist(x1,y1,x2,y2)        ((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)) #define area(x1,y1,x2,y2,x3,y3)  (abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))/2.0)) #define ln(x)                    (LL(log2(double(x)))) #define dig(x)                   (LL(log10(double(x)))+1) #define ceil(a,b)                (LL(ceil(double(a)/double(b)))) #define sin(x)                   (sin((x*PI)/180.0)) #define sq(x)                    ((x)*(x))  #define gc                       getchar//_unlocked #define pc                       putchar//_unlocked #define RG                       100007  bool markP[RG];VLL prime; inline void sieve(){LL i,j;for(i=2;i*i<=RG;++i)if(!markP[i])for(j=i<<1;j<RG;j+=i)if(!markP[j])markP[j]=1;prime.pb(2);for(i=3;i<RG;i+=2)if(!markP[i])prime.pb(i);} inline void inp(int &x){register int c=gc();x=0;bool neg=0;for(;((c<48||c>57)&&c!='-');c=gc());if(c=='-'){neg=1;c=gc();}for(;c>47&&c<58;c=gc()){x=(x*10)+(c-48);}if(neg)x=-x;} inline LL modexp(LL a,LL b,const LL &mod){LL x=1;while(b>0){if(b&1){x*=a;if(x>=mod)x%=mod;};b>>=1;a*=a;if(a>=mod)a%=mod;}return x;} inline LL mulmod(LL a,LL b,const LL &mod){LL x=0;a%=mod;while(b>0){if(b&1){x+=a;if(x>=mod)x%=mod;}a<<=1;if(a>=mod)a%=mod;b>>=1;}return x;} inline LL invmod(LL &a,const LL &mod){return modexp(a,mod-2,mod);} inline LL power(LL a,LL b){LL x=1;while(b>0){if(b&1)x=(x*a);a*=a;b>>=1;}return x;} inline LL digSum(LL n){LL s=0;n=abs(n);while(n){s+=(n%10);n/=10;}return s;} inline string toStr(LL &num){ return static_cast<stringstream*>( &(stringstream()<<num))->str();} inline LL toNum(const string &st){LL num;stringstream ss(st);ss>>num;return num;} inline LL elePos(const vector<LL> &A,const LL &x){LL l=0,h=sz(A)-1,m;while(l<=h){ m=(h+l)>>1;if(x==A[m])return (m+1);(x<A[m])?(h=m-1):(l=m+1);}return -1;} inline LL comb(const LL &N,LL R){R>(N-R)?(R=N-R):R;LL mul=1LL;rep(i,0,R-1)mul=(mul*(N-i))/(i+1);return mul;} inline LL strmod(string &T,const LL &mod){LL mul=0;rep(i,0,len(T)-1){mul=(mul*10+T[i]-48);if(mul>=mod)mul%=mod;}return mul;} inline LL fib(LL n){LL i,j,h,k,t;i=h=1;j=k=0;while(n){if(n&1){t=j*h;j=i*h+j*k+t;i=i*k+t;}t=h*h;h=2*k*h+t;k=k*k+t;n>>=1;}return j;} inline bool isPrime(const LL &x){if(x<=3)return(x<=1?0:1);if(!(x&1)||!(x%3))return 0;for(LL i=5;i*i<=x;i+=6)if(!(x%i)||!(x%(i+2)))return 0;return 1;} inline bool isPalin(const string &st){int l=len(st);for(int i=0;(i<<1)<l;++i)if(st[i]!=st[l-i-1])return 0;return 1;} inline bool cmp(const PII &X,const PII &Y) {return (X.ff!=Y.ff)?(X.ff<Y.ff):(X.ss<Y.ss);}  #define MOD                  1000000007 #define MAX                  1000007  int A[MAX],temp[MAX]; inline int LIS(const int &n){ 	int ans=1; 	temp[1]=A[1]; 	rep(i,2,n){ 		if(A[i]<temp[1]) temp[1]=A[i]; 		else if(A[i]>=temp[ans]) temp[++ans]=A[i]; 		else { 			int l=1,h=ans,mid; 			while(l<=h){ 				mid=(l+h)/2; 				if(temp[mid]<=A[i] && temp[mid+1]>A[i]){ 					temp[mid+1]=A[i]; 					break; 				} 				if(temp[mid]<=A[i]) l=mid+1; 				else h=mid-1; 			} 		} 	} 	return ans; } 	 int main() { 	ios_base::sync_with_stdio(false); 	int n; 	cin>>n; 	rep(i,1,n) cin>>A[i]; 	cout<<n-LIS(n)<<endl; 	return 0; }                         
//	__R0b__ #include <iostream> #include <map> #include <iterator> using namespace std;  int main(){ 	//freopen ("input.txt","r",stdin); 	//freopen ("output.txt","w",stdout); 	int t; cin>> t; 	map <string , int> mapp; 	map <string , int>::iterator that; 	for (int i=0;i<t;i++){ 		string s; cin>>s; 		mapp [s]++; 	} 	for (that = mapp.begin(); that!=mapp.end();that++){ 		cout << that->first << " "<< that->second << endl; 	} 	return 0; }
#include <bits/stdc++.h> using namespace std; #define ull unsigned long long struct node { 	unsigned long long data; 	bool lazy , query1 , query2; 	node *left , *right; }; node *build(ull a[] , int strt , int end) { 	node *temp = (node *)malloc(sizeof(node)); 	if(strt == end) 	{ 		temp->data = a[strt]; 		temp->left = temp->right = NULL; 		temp->lazy = 0; 		temp->query1 = temp->query2 = 0; 		return temp; 	} 	int mid = (strt + end)/2;   	temp->left = build(a , strt,  mid); 	temp->right = build(a , mid + 1 , end); 	temp->data = temp->left->data ^ temp->right->data; 	temp->lazy = 0; 	temp->query1 = temp->query2 = 0; 	return temp; } void rangeupdate(node *root , int strt , int end , int x , int y , bool flag) { 	if(strt >= x && end <= y) 	{ 		if(!root->lazy) 		{ 			if(!((end - strt + 1) & 1)) 			{ 				if(((end - strt + 1)/2) & 1) 					root->data = ~root->data; 			} 			else 			{ 				if((flag && (((end - strt + 1)/2) & 1))||(!flag && !(((end - strt + 1)/2) & 1))) 					root->data = ~root->data;   			} 			if(!flag) 			{ 				root->query1 = 1; 				root->query2 = 0; 			} 			else 			{ 				root->query1 = 0; 				root->query2 = 1; 			} 			root->lazy = 1; 		} 		else 		{ 			if(flag) 			{ 				root->query2 = !root->query2; 				if(!root->query1 && !root->query2) 					root->lazy = 0; 				if(!((end - strt + 1) & 1)) 				{ 					if(((end - strt + 1)/2) & 1) 						root->data = ~root->data; 				} 				else 				{ 					if((((end - strt + 1)/2) & 1)) 						root->data = ~root->data; 				} 			} 			else 			{ 				root->query1 = !root->query1; 				if(!root->query1 && !root->query2) 					root->lazy = 0; 				if(!((end - strt + 1) & 1)) 				{ 					if(((end - strt + 1)/2) & 1) 						root->data = ~root->data; 				} 				else 				{ 					if(!(((end - strt + 1)/2) & 1)) 						root->data = ~root->data; 				} 			} 		} 		return; 	}   	int mid = (strt + end)/2;   	if(root->lazy) 	{ 		if(root->query1) 			rangeupdate(root->left , strt , mid , strt , mid , 0); 		if(root->query2) 			rangeupdate(root->left , strt , mid , strt,  mid , 1); 		if(!((mid - strt + 1) & 1)) 		{ 			if(root->query1) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 0); 			if(root->query2) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 1); 		} 		else 		{ 			if(root->query1) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 1); 			if(root->query2) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 0); 		} 		root->lazy = root->query1 = root->query2 = 0; 	}   	if(y <= mid) 		rangeupdate(root->left , strt , mid , x , y , flag); 	else if(x > mid) 		rangeupdate(root->right , mid + 1 , end , x , y , flag); 	else 	{ 		rangeupdate(root->left , strt , mid , x , mid , flag); 		if(!((mid - x + 1) & 1)) 		{ 			if(flag == 0) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , y , 0); 			else 				rangeupdate(root->right , mid + 1 , end , mid + 1 , y , 1); 		} 		else 		{ 			if(flag == 0) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , y , 1); 			else 				rangeupdate(root->right , mid + 1 , end , mid + 1 , y , 0); 		} 	} 	root->data = root->left->data ^ root->right->data; } void pointupdate(node *root , int strt , int end , int x , ull y) { 	if(strt == end) 	{ 		root->data = y; 		return; 	} 	int mid = (strt + end)/2;   	if(root->lazy) 	{ 		if(root->query1) 			rangeupdate(root->left , strt , mid , strt , mid , 0); 		if(root->query2) 			rangeupdate(root->left , strt , mid , strt,  mid , 1); 		if(!((mid - strt + 1) & 1)) 		{ 			if(root->query1) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 0); 			if(root->query2) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 1); 		} 		else 		{ 			if(root->query1) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 1); 			if(root->query2) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 0); 		} 		root->lazy = root->query1 = root->query2 = 0; 	}   	if(x <= mid) 		pointupdate(root->left , strt,  mid , x , y); 	else 		pointupdate(root->right , mid + 1 , end , x , y);   	root->data = root->left->data ^ root->right->data; } ull pointquery(node *root , int strt , int end , int x) { 	if(strt == end) 		return root->data;   	int mid = (strt + end)/2; 	if(root->lazy) 	{ 		if(root->query1) 			rangeupdate(root->left , strt , mid , strt , mid , 0); 		if(root->query2) 			rangeupdate(root->left , strt , mid , strt,  mid , 1); 		if(!((mid - strt + 1) & 1)) 		{ 			if(root->query1) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 0); 			if(root->query2) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 1); 		} 		else 		{ 			if(root->query1) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 1); 			if(root->query2) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 0); 		} 		root->lazy = root->query1 = root->query2 = 0; 	}   	if(x <= mid) 		return pointquery(root->left , strt , mid , x); 	else 		return pointquery(root->right , mid + 1 , end , x); } ull rangequery(node *root , int strt , int end , int x , int y) { 	if(strt >= x && end <= y) 		return root->data;   	int mid = (strt + end)/2; 	if(root->lazy) 	{ 		if(root->query1) 			rangeupdate(root->left , strt , mid , strt , mid , 0); 		if(root->query2) 			rangeupdate(root->left , strt , mid , strt,  mid , 1); 		if(!((mid - strt + 1) & 1)) 		{ 			if(root->query1) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 0); 			if(root->query2) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 1); 		} 		else 		{ 			if(root->query1) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 1); 			if(root->query2) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 0); 		} 		root->lazy = root->query1 = root->query2 = 0; 	}   	if(y <= mid) 		return rangequery(root->left , strt , mid , x , y); 	else if(x > mid) 		return rangequery(root->right , mid + 1 , end , x , y); 	else 		return rangequery(root->left , strt , mid , x , mid)^rangequery(root->right , mid + 1 , end , mid + 1 , y); } int main() { 	int n ,i; 	cin >> n; 	ull a[n]; 	for(i = 0;i < n;i++) 		cin >> a[i];   	node *root = NULL; 	root = build(a , 0 , n-1); 	ull x , y , q; 	cin >> q; 	char t; 	while(q--) 	{ 		cin >> t; 		if(t == 'A') 		{ 			cin >> x >> y; 			pointupdate(root , 0 , n-1 , x-1 , y); 		} 		else if(t == 'B') 		{ 			cin >> x >> y; 			rangeupdate(root , 0 , n-1 , x-1 , y-1 , 0); 		} 		else if(t == 'C') 		{ 			cin >> x; 			cout << pointquery(root , 0 , n-1 , x-1) << endl; 		} 		else 		{ 			cin >> x >> y; 			cout << rangequery(root , 0 , n-1 , x-1 , y-1) << endl; 		} 	} 	return 0; }  
#include<iostream> #include<cmath> using namespace std; #define LL long long int main() {  LL T,n,b,f,ans,x;  cin>>T;  while(T--)  {x=ans=f=0;   cin>>n>>b;   while(x<n)   {    ++x;    ans+=x;    if(ans==b)     f=1;   }   cout<<ans-f<<endl;  }  return 0; }
// //  main.c //  GENARSEQ // //  Created by Apekshit Jotwani on 02/12/13. //  Copyright (c) 2013 Apekshit Jotwani. All rights reserved. //  #include <stdio.h> // THIS IS GOPR...... int main(int argc, const char * argv[]) {      int t,h1,m1,s1,h2,m2,s2,diff;     scanf("%d",&t);     while(t--)     {         scanf("%d%d%d",&h1,&m1,&s1);         scanf("%d%d%d",&h2,&m2,&s2);         s1+=(m1*60)+(h1*3600);         s2+=(m2*60)+(h2*3600);         diff=(s2-s1)%400;         if(diff<=99||(diff>=200&&diff<=299))             printf("S\n");         else             printf("C\n");              }     return 0; } 
// codechef_codes.cpp : Defines the entry point for the console application.  #include <iostream> #include <vector> #include <algorithm> #include <string> #include <cstring> #include <cstdio> #include <cassert> #include <cmath> #include <time.h> #include <cstdlib> #include <deque>  using namespace std;  typedef long long ll; typedef unsigned long long ull; typedef vector<int> vi; typedef vector<ll> vll; typedef vector<vector<int> > vvi; typedef pair<int, int> ii; typedef vector<pair<int, int> > vii; typedef vector<vector<pair<int, int> > > vvii;  #define boost ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0) #define max(a,b) ((a)>(b)?a:b) #define min(a,b) ((a)<(b)?a:b) #define min_3(a,b,c) (min((a),min((b),(c)))) #define INF 1000000007 #define pb push_back  #define PB pop_back #define pf push_front #define PF pop_front #define MP make_pair #define all(x) (x).begin(), (x).end() #define nall(x) (x).rbegin(), (x).rend() #define tr(x,it) for(auto it = (x).begin();it!=(x).end();++it) #define ntr(x,it) for(auto it = (x).rbegin();it!=(x).rend();++it) #define mset(a,b) memset(a,b,sizeof(a)) #define ia(a,n) FOR(i,0,n-1)cin>>a[i] #define ia1(a,n) FOR(i,1,n)cin>>a[i] #define fpresent(c,x) ((c).find(x) != (c).end())  // set,map #define present(c,x) (find(all(c),x) != (c).end())  //vector #define F first #define S second #define FOR(i,a,b) for(int i=a;i<=b;++i) #define NFOR(i,a,b) for(int i=a;i>=b;--i) #define rep(i,n) FOR(i,0,n-1) #define TCASE int __T;cin>>__T;FOR(Tc,1,__T) inline int add(int a, int b, int m = INF) { a += b;if (a >= m)a -= m;return a; } inline int mul(int a, int b, int m = INF) { return (int)(((ll)a*(ll)b) % m); } inline int norm(int x, int m = INF) { if (x >= m)x %= m;if (x<0)x += m;return x; } inline int neg(int x, int m = INF) { x = -x;return norm(x); }   /// debug ////// #define pr(x,n) {rep(i,n)cout<<x[i]<<" ";cout<<endl;} #define pr1(x,n) {FOR(i,1,n)cout<<x[i]<<" ";cout<<endl;} #define DB(x)              cout<<__LINE__<<" :: "<<#x<< ": "<<x<<endl; #define DB2(x, y)          cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<endl; #define DB3(x, y, z)       cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<" | "<<#z<<": "<<z<<endl;  ll f[1000001],phi[1000001];   int main() { 	boost; 	ll tc,i,N,j; 	cin >> tc; 	while (tc--) { 		cin >> N ; 		if(N%2 == 0) 			cout << "Valar Morghulis" << endl; 		else 			cout << "Lannisters always pays their debts" << endl; 	} }
#include<cstdio> #include<iostream> #include<vector> #include<queue> using namespace std;  #define MAXN 1001 #define MAXM 400001  struct node {     int v,e; }ar[MAXM];  bool operator <(const node &a,const node &b) {     return a.e<b.e; }  vector <node > list[MAXN]; bool vis[MAXN]={false}; priority_queue <node > pq;  int main() {     int t;     scanf("%d",&t);     while(t--)     {         int n,m,a,b,c,ans=0;         scanf("%d%d",&n,&m);         for(int i=0;i<=n;i++)         {             list[i].clear();             vis[i]=false;         }         for(int i=0;i<m;i++)         {             node temp;             scanf("%d%d%d",&a,&b,&c);             temp.v=b;             temp.e=c;             list[a].push_back(temp);             temp.v=a;             list[b].push_back(temp);             ans+=c;         }         int sel=1;         for(int i=1;i<=n;i++)         {             //printf("%d\n",i);             if(vis[i]==false)             {                 sel=i;                 while(1)                 {                     vis[sel]=true;                     for(int i=0;i<list[sel].size();i++)                     {                         if(vis[list[sel][i].v]==false) pq.push(list[sel][i]);                         //printf("aman\n");                     }                     while(pq.empty()==false&&vis[(pq.top()).v]==true)pq.pop();                     if(pq.empty())break;                     sel=(pq.top()).v;                     ans-=(pq.top()).e;                     pq.pop();                 }             }         }         printf("%d\n",ans);     } } 
#include<stdio.h> #include<algorithm> using namespace std; int main() { int t,n,p; char ch[26]; scanf("%d",&t); while(t--) { int cmin=100000,pmin=0,i,j,s=0,v=0; //scanf("%s",ch); //printf("\n"); int dp[5010][60]={0}; scanf("%d",&n); scanf("%d",&p); fflush(stdin); int arr[n+1]; int arr1[n+1]; for(i=1;i<=n;i++) { scanf("%s",ch); fflush(stdin); scanf("%d",&arr[i]); scanf("%d",&arr1[i]); s+=arr1[i]; } for(i=1;i<=n;i++) { if(arr1[i]==0) v=v+arr[i]; dp[0][i]=v; } if(v>=p) { printf("0 %d\n",v); } else { for(i=1;i<=s;i++) {  dp[i][0]; for(j=1;j<=n;j++) { //if(i==0&&j==0||i!=0&&j==0) //dp[i][j]=0; //else //{ if(arr1[j]>i) dp[i][j]=dp[i][j-1]; else { int m=arr1[j]; //dp[i][j]= //if(dp[i-1][j-m]+arr[i]==j) dp[i][j]=dp[i][j-1]; dp[i][j]=max(dp[i-m][j-1]+arr[j],dp[i][j]); //else //dp[i][j]=dp[i-1][j-m]; } //} //if(j<=15) //printf("%d ",dp[i][j]); if(dp[i][j]>=p) { if(cmin>i) { cmin=i; pmin=dp[i][j]; } } } //printf("\n"); } //printf("%d %d\n",dp[2][7],dp[3][7]); printf("%d %d\n",cmin,pmin); } } return 0; } 
// by ma5termind #include<iostream> #include<vector> #include<set> #include<map> #include<queue> #include<stack> #include<string> #include<algorithm> #include<functional> #include<iomanip> #include<cstdio> #include<cmath> #include<limits.h> #include<cstring> #include<cstdlib> #include<bitset> #include<cfloat> #include<cassert> #define maxm(a,b) a>b?a:b; #define minm(a,b) a<b?a:b; using namespace std; //M lazy ;) typedef long long ll; typedef vector <int> vi; typedef pair< int ,int > pii; typedef istringstream iss; typedef ostringstream oss; typedef map<int,int> mp; #define pb push_back #define mp make_pair #define ff first #define ss second #define sz size() #define ln length() #define rep(i,n) for(int i=0;i<n;i++) #define fu(i,a,n) for(int i=a;i<=n;i++) #define fd(i,n,a) for(int i=n;i>=a;i--) #define all(a)  a.begin(),a.end() #define ESP (1e-9) #define gi(n) scanf("%d",&n) #define gl(n) cin >> n #define pi(n) printf("%d",n) #define pl(n) cout << n #define ps printf(" ") #define pn printf("\n") #define dg(n,s); printf("%s %d",s,n) #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min() #define traverse_map(a,b) for(mp::iterator it=a;it!=b;++it) #define MOD 1000000007 #define MAX 1000001 #define cases() int t; cin>>t; while(t--) // fast input function #define getcx getchar_unlocked // fast input function #ifdef ONLINE_JUDGE  inline void inp( int &n )  {     n=0;     int ch=getcx();int sign=1;     while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )             n = (n<<3)+(n<<1) + ch-'0', ch=getcx();     n=n*sign;   } #else inline void inp(int &n){  cin>>n; } #endif #define MAXN 10000001   ll phi[MAXN + 1],prime[MAXN/10];  bitset <MAXN + 1> mark; void sieve(){  int size=0;  for (int i = 2; i <= MAXN; i++ ){  	if(!mark[i]){ 	 	phi[i] = i-1; 		prime[size++]=i; 	} 	for (int j=0; j<size && prime[j]*i <= MAXN; j++ ){ 	 	mark[prime[j]*i]=1; 		if(i%prime[j]==0){ 		 	phi[i*prime[j]] = phi[i]*prime[j]; 			break; 		} 		else phi[i*prime[j]] = phi[i]*(prime[j]-1 ); 	}  } } int main(){  //int n;    sieve(); // precal O(n) algorithm to find the euler totient function    int i;   phi[0]=0;   phi[1]=3;   fu(i,2,MAXN-1){ 	 phi[i]=phi[i-1]+2*phi[i];   }   int t;   inp(t);      while(t--){    int n; 	inp(n); 	cout<<phi[n-1]<<endl;   }  return 0; } 
#include <bits/stdc++.h>  using namespace std;  int notPrime(int);  int main() {     int t,n,i,r;     long int sum;     cin>>t;     while(t--)     {         cin>>n;         sum = 0;         for(i=0;;i++)         {             if(i*(i+1) == 2*n)                 break;         }         r = i;         for(i=2;i<r;i++)         {             if(notPrime(i))             {             	sum += (pow(2,i)-2);             }             else             {             	sum += ((pow(2,i)-2)/i)*(i-1);             }         }         cout<<sum<<endl;     }     return 0; }  int notPrime(int a) {     int i,flag=0;     for(i=2;i<=sqrt(a);i++)     {         if(a%i == 0)         {             flag=1;             break;         }     }     return flag; } 
#include <iostream> #include <stdio.h> using namespace std; int gtob(int a, int b, int& c) { 	if(a==0) 		return 0; 	int g=(a%2)^gtob(a/2, b*2, c); 	c += g*b;	  	return g; }		  int main() { 	int t,n,ans; 	scanf("%d", &t); 	while(t--) 	{ 		ans=0; 		scanf("%d", &n); 		gtob(n,1,ans); 		printf("%d\n", ans); 	} 	return 0; }
#include <bits/stdc++.h> #define pb push_back #define sqr(x) (x)*(x) #define sz(a) int(a.size()) #define reset(a,b) memset(a,b,sizeof(a)) #define oo 1000000007  using namespace std;  typedef pair<int,int> pii; typedef unsigned long long ll;  long double mypow(long double base, int n){     if(n==0) return 1;     double t=mypow(base, n/2);     t=t*t;     if(n&1) return t*base;     return t; }  long double sum(long double a, long double d, long double r, int n){     return (a - (a + (n-1)*d) * mypow(r, n)) / (1 - r) + d * r * (1 - mypow(r, n-1)) / (1-r) / (1-r); }  int main(){ //    freopen("input.txt","r",stdin);      ll m,n,k;     cin>>m>>n>>k;     if(k!=1){         long double res=0;         for(int i=1; i<=m; ++i){             long double x = 1.0 * k * (m-i+1);             long double p = mypow(1.0/k,i);             long double s = sum(n, -1, p, n) * p;             res += x * s;         }         cout << fixed << setprecision(0) << round(res) + 1e-9 << endl;     }else{         long double res = (n*1.0*(n + 1)/2.0)*(m*1.0*(m + 1)/2.0);         cout << fixed << setprecision(0) << res << endl;     } }
#include<iostream> #include<stdio.h> #include<string.h> #include<cmath> #define intin(a)    scanf("%d",&a) #define scans(a)    scanf("%s",a) #define LL long long using namespace std; int main() {     int cases,r,c;     intin(cases);     while(cases--)     {   intin(r);intin(c);         if(!r || !c)  {cout<<"0\n";continue;}         if(r&1) r=r-(r/2+1);         else    r=r-r/2;          if(c&1) c=c-(c/2+1);         else    c=c-c/2;         cout<<1+r+c<<"\n";     } } 
#include<bits/stdc++.h> #define gc getchar_unlocked   void scanint(int &x) {     register int c = gc();     x = 0;     for(;(c<48 || c>57);c = gc());     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} } using namespace std; int main() {     int t;     //scanf("%d",&t);     scanint(t);     while(t--)     {         int m,n,i,j,k;         long long int res=0;         //scanf("%d%d",&m,&n);         scanint(m);         scanint(n);         if(m==1&&n==1)         {             printf("0\n");             continue;         }         if(m==1)         {             res=2+(n-2)*2;             printf("%lld\n",res);             continue;         }         if(n==1)         {             res=2+(m-2)*2;             printf("%lld\n",res);             continue;         }         res=12+5*(2*m+2*n-8)+8*(m*n-2*m-2*n+4);         printf("%lld\n",res);     }     return 0; }
#include<stdio.h> typedef long long ll;  int main(){ 	ll t,i,j,k,fact[21]; 	fact[0]=1; 	for(i=1;i<21;i++) fact[i]=i*fact[i-1]; 	scanf("%lld",&t); 	while(t--){ 		scanf("%lld",&k); 		ll res=0; 		for(i=2 ; i <= k; i++){ 			res+=(i%2==0) ? fact[k]/fact[i]:-fact[k]/fact[i] ; 		} 		printf("%lld\n",res); 	} 	return 0; } 
#include <iostream> using namespace std; #include<stdlib.h> #include<stdio.h> #include<string.h>  int main() { 	int t; 	cin>>t; 	long long int p,i; 	 	 	 	for(p=0;p<t;p++) 	{    	   char name[10]; 	   scanf("%s",name); 	   char str[1000]; 	   scanf("%s",str); 	    	   int flag=0; 	   int a[26]; 	   for(i=0;i<26;i++) 	    a[i]=0; 	     	   for(i=0;i<strlen(str);i++) 	   {   int k = str[i]-97; 	       a[k]++; 	   } 	   int count=0; 	   for(i=0;i<26;i++) 	   { 	   	count = count^a[i];	 	   }	    		  		if(count==0) 		{ 			if(name[0]=='T') 				cout<<"Varun"<<endl; 			else 				cout<<"Tarun"<<endl; 		} 		else{ 			if(name[0]=='T') 				cout<<"Tarun"<<endl; 			else 				cout<<"Varun"<<endl;  		}  	}     	 	 	 	return 0; } 
#pragma comment(linker, "/STACK:102400000,102400000") #include <iostream> #include <stdio.h> #include <algorithm> #include <string.h> #include <vector> #include <map> #include <queue> #include <set> #include <cmath> #include <fstream> #include <assert.h> #include <complex> using namespace std; #define vi vector<int> #define pii pair<int,int> #define pb push_back #define mp make_pair #define all(x) x.begin(),x.end() #define inf 1000000007 #define mod 1000000007 #define x first #define y second #define pi acos(-1.0) #define DBG(x) cerr<<(#x)<<"="<<x<<"\n"; #define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++) #define ull unsigned long long #define ll long long #define N 10010  char s[105][105]; int dir[][2]={-2,-1,-2,1,-1,-2,-1,2,1,-2,1,2,2,-1,2,1}; int n,m,id[105][105],sz,n1,m1; bool in(int x,int y){return x>=0&&x<n1&&y>=0&&y<m1;} int l1,l2,r1,r2; void dfs(int x,int y){     if(!in(x,y)||s[x][y]=='#'||id[x][y])return;     id[x][y]=sz;     l1=min(l1,x);l2=max(l2,x);     r1=min(r1,y);r2=max(r2,y);     dfs(x-1,y);     dfs(x+1,y);     dfs(x,y-1);     dfs(x,y+1); } int ans; int v[105],res[105],lim,goal[105],found,cnt; void go(int x,int sum){     if(found||ans==lim)return;     if(sum+min(n-x,m-sum)<=ans)return;     if(x==n){         if(ans<sum){             ans=sum;found=true;             cnt++;             //if(cnt>10)found=true;             for(int i=0;i<n;i++)goal[i]=res[i];         }         return;     }     if(res[x-1]!=-1)     for(int y=res[x-1]+3,k=0;k<m;y++,k++){         if(y>=m)y-=m;     if(!v[y]){         int ok=1;         for(int i=0;i<x;i++)if(res[i]!=-1){             if(x-i==y-res[i]){ok=0;break;}             if(i+res[i]==x+y){ok=0;break;}             if(i==x-2&&abs(y-res[i])==1){ok=0;break;}             if(i==x-1&&abs(y-res[i])==2){ok=0;break;}         }         if(ok){             v[y]=1;             res[x]=y;             go(x+1,sum+1);             v[y]=0;res[x]=-1;             //break;         }     }     }     else{         if(ans<sum)ans=sum;     } } void go1(int x,int sum){     if(ans==lim)return;     if(sum+min(n-x,m-sum)<=ans)return;     if(x==n){         if(ans<sum){             ans=sum;             for(int i=0;i<n;i++)goal[i]=res[i];         }         return;     }     for(int y=0;y<m;y++)     if(!v[y]){         int ok=1;         for(int i=0;i<x;i++)if(res[i]!=-1){             if(x-i==y-res[i]){ok=0;break;}             if(i+res[i]==x+y){ok=0;break;}             if(i==x-2&&abs(y-res[i])==1){ok=0;break;}             if(i==x-1&&abs(y-res[i])==2){ok=0;break;}         }         if(ok){             v[y]=1;             res[x]=y;             go1(x+1,sum+1);             v[y]=0;res[x]=-1;         }     }     go1(x+1,sum); } void func(){     ans=0;n=l2-l1+1,m=r2-r1+1;     for(int i=0;i<m;i++)v[i]=0;     for(int i=0;i<n;i++)res[i]=-1;     lim=min(n,m);found=false;cnt=0;     bool flag=false;     if(n>m)swap(n,m),flag=true;     if(lim<10){         go1(0,0);     }     else go(0,0);     //DBG(ans)     //cout<<n<<" "<<m<<":\n";     for(int i=0;i<n;i++)             if(goal[i]!=-1){                 if(!flag)s[l1+i][r1+goal[i]]='G';                 else s[l1+goal[i]][r1+n-1-i]='G';             }     //printf("-------------------\n"); } int main() {     //freopen("2.txt","w",stdout);     int T,i,j,k,ca=0;     scanf("%d",&T);     while(T--){         scanf("%d%d",&n,&m);         for(i=0;i<n;i++){             scanf("%s",s[i]);         }         n1=n,m1=m;         memset(id,0,sizeof(id));         sz=0;int sum=0;         for(i=0;i<n1;i++)             for(j=0;j<m1;j++)if(!id[i][j]&&s[i][j]=='.'){                 sz++;                 l1=l2=i;r1=r2=j;                 dfs(i,j);                 func();sum+=ans;             }         printf("%d\n",sum);         for(i=0;i<n1;i++)puts(s[i]);     }     return 0; }
#include<iostream> using namespace std; long long int fun(long long int a,long long int b){ 	if(a==0){ 		return b; 	} 	else{ 		return fun(b%a,a); 	} } int main() { 	int test; 	long long int g,n,m,odd1,even1,odd2,even2,num,den; 	scanf("%d",&test); 	while(test){ 		test--; 		scanf("%lld%lld",&n,&m); 		if(n%2==1){ 			odd1=(n/2)+1; 			even1=n/2; 		} 		else{ 				even1=n/2; 				odd1=(n/2); 		} 		if(m%2==1){ 			odd2=(m/2)+1; 			even2=m/2; 		} 		else{ 				even2=m/2; 				odd2=(m/2); 		} 		num=(even1*odd2)+(odd1*even2); 		den=(m*n); 		g=fun(num,den); 		printf("%lld/%lld\n",num/g,den/g); 	} 	return 0; }
#include<cstdio> #include<cstdlib>  using namespace std; #define mod 1000000007 long long power(int x, unsigned int y) {   long long temp;   if( y == 0)     return 1;   temp = power(x, y/2);   if (y%2 == 0)     return ((temp*temp)%mod);   else     return ((((x*temp)%mod)*temp) %mod); }   int main() {   int t,d;   scanf("%d",&t);   while(t--) {     scanf("%d",&d);     printf("%lld\n",power(7,d));   }   return 0; } 
#include<iostream> #include<cmath> #include<vector> #include<algorithm> #include<stdio.h> #include<list> #include<set> #include<string> #include<cstring> #define x getchar_unlocked() #define y putchar_unlocked using namespace std; inline void inp(int &n ) {//fast input function 	n=0; 	int ch=x,sign=1; 	while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=x;} 	while( ch >= '0' && ch <= '9' )  		n=(n<<3)+(n<<1)+ ch-'0', ch=x; 	n=n*sign; 	}  int R[100000],n,t,ans;  int main() { 	inp(t); 	while(t--) { 		set<int> s; 		set<int>::iterator it; 		inp(n); 		for(int i=0;i<n;i++) { 			inp(R[i]); 			R[i]=-R[i]; 			} 		for(int i=0;i<n;i++) { 			if(s.find(R[i])!=s.end()) 				continue; 			s.insert(R[i]); 			it=s.find(R[i]); 			it++; 			if(it!=s.end()) 				s.erase(it); 			} 		ans=s.size(); 		cout<<ans<<endl; 		} 	return 0; 	} 
#include<bits/stdc++.h> using namespace std; int main() { 	int t;scanf("%d",&t); 	int i,j; 	while(t--) 	{ 		char s[100]; 		cin>>s; 		int l = strlen(s); 		int cnt=0; 		for(i=0;i<l-1;i++) 		{ 			if(s[i]=='h') 			{ 				for(j=i+1;j<l;j++) 				{ 					if(s[j]=='m') 						cnt++; 					else 						break; 				} 			} 		} 		cout<<cnt<<endl; 	} 	return 0; } 
#include<stdio.h>    #include<math.h>    #include<string.h>    int main()    {    	int t;    	scanf("%d",&t);    	while(t--)    	{    		unsigned long long int i,n,c=0,s;    		char a[55]={'\0'};    		scanf("%s",a);    		n=strlen(a);  		if(n==1)  		printf("2\n");  		else  		{  		if(a[0]!=a[1])    		c++;    		for(i=1;i<n-1;i++)    		{    			if((a[i]!=a[i+1])&&(a[i]!=a[i-1]))    			c++;    		}    		if(a[n-1]!=a[n-2])    		c++;    		s=pow(2,c);    		printf("%llu\n",s);    	}  }    	return 0;    }
//hamiltonian cycle #include<bits/stdc++.h> #define ll long long #define maxe 2147483647 #define INF 1e16 #define si(x) scanf("%d",&x) #define sl(x) scanf("%ld",&x) #define sll(x) scanf("%lld",&x) #define ss(x) scanf("%s",x) #define pi(x) printf("%d\n",x) #define pl(x) printf("%ld\n",x) #define pll(x) printf("%lld\n",x) #define ps(x) printf("%s\n",x) #define iter(i,a,b) for(int i=a; i<b; i++) #define ited(i,a,b) for(int i=a;i>b;i--) #define mp make_pair  #define pb push_back  #define max(a,b) a>b?a:b #define min(a,b) a<b?a:b //#define pop pop_back  #define mod 1000000007 using namespace std; bool prime[1000001]; vector<int> vec; void seivec() { 	prime[0]=prime[1]=true; 	for(int i=2;i*i<1000001;i++) 		if(prime[i]==false) 			for(int j=2*i;j<1000001;j+=i) 				prime[j]=true; 	for(int i=2;i<1000001;i++) 		if(prime[i]==false) 			vec.pb(i);	 } ll mulmd(ll a,ll b,ll n) { 	ll an=0; 	while(b!=0) 	{ 		if(b%2==1) 			an=(an+a)%n; 		a=(a+a)%n; 		b/=2; 	} 	return an; } ll powe(ll a,ll b,ll n) { 	ll an=1; 	while(b!=0) 	{ 		if(b%2==1) 			an=mulmd(an,a,n); 		a=mulmd(a,a,n); 		b/=2; 	} 	return an; } bool miller(ll n,ll d) { 	ll a=2+rand()%(n-4); 	ll x=powe(a,d,n); 	if(x==1 || x==n-1) return true; 	while(d!=n-1) 	{ 		x=mulmd(x,x,n); 		d*=2; 		if(x==1) return false; 		if(x==n-1) return true; 	} 	return false; } bool checkp(ll n) { 	if(n<=1 && n==4) return false; 	if(n<=3)	return true; 	ll d=n-1; 	while(d%2==0) 		d/=2; 	int k=3; 	for(int i=0;i<k;i++) 		if(miller(n,d)==false) return false; 	return true; } ll calc(ll v) { 	ll an=0; 	for(int i=0;i<vec.size();i++) 	{ 		while(v%vec[i]==0) 		{ 			v/=vec[i]; 			an++; 		} 	} 	if(v==1) return an; 	if(checkp(v)) return an+1; 	else return an+2; } int main() { 	seivec(); 	int t; 	si(t); 	while(t--) 	{ 		ll n,k; 		sll(n);sll(k); 		ll tmp1=calc(k); 		ll tmp2=calc(n); 		ll t1=powe(2,tmp1,mod); 		ll an=powe(t1+1,tmp2,mod); 		pll(an); 	} 	return 0; }
/** * It is foolish to fear what we've yet to see and know */ #include <iostream> #include <iomanip> #include <algorithm> #include <vector> #include <map> #include <set> #include <stack> #include <queue> #include <climits> #include <cstdio> #include <cstring> #include <cctype> #include <cassert> #include <cmath> using namespace std;  #define trace(x) {cerr << #x << "=" << x <<endl;} #define trace2(x, y) {cerr << #x << "=" << x << " " << #y << "=" << y <<endl;} #define track(x) {cerr << #x << ":" << endl; for (int q = 0; q < x.size(); q++) {cerr << x[q] << " ";} cerr << endl;} #define trackarr(x, n) {cerr << #x << ":" << endl; for (int q = 0; q < n; q++) {cerr << x[q] << " ";} cerr << endl;} #define trackvv(x) {cerr << #x << ":" << endl; for (int i = 0; i < x.size(); i++) { cerr << "i:" << i << endl; for (int j = 0; j < x[i].size(); j++){cerr << x[i][j] << " ";} cerr << endl;} cerr << endl;} #define trackcr(x) {cerr << #x << ":" << endl; for (map<ll, int>::iterator i = x.begin(); i != x.end(); i++) {cerr << *i << " ";} cerr << endl;} template <typename Tk, typename Tv> ostream& operator<<(ostream& os, const pair<Tk, Tv> &p){os << "{" << p.first << ',' << p.second << "}";return os;}  typedef long long ll; typedef pair<int,int> ii;  const int MAX = 100005; const int MOD = 1000000000+7; const int INF = 1000000000;  int runScored[5] = {0, 1, 2, 4, 6};   bool exist[205][105][150][2][2]; int dp[205][105][150][2][2];  long long solve(int b, int n, int k, bool sl, bool l) {     if (k >= 100) {         return 1;     } else if (b == 0) {         return 0;     } else {         if (!exist[b][n][k][sl][l]) {             long long ways = 0;              if (n > 0) {                 for (int i = 0; i < 5; i++) {                     ways += solve(b, n-1, k+runScored[i], sl, l);                     if (ways >= MOD) ways -= MOD;                 }             }              int start = 0;             if (!sl && !l) start = 1;             for (int i = start; i < 5; i++) {                 ways += solve(b-1, n, k+runScored[i], l, (runScored[i]>0));                 if (ways >= MOD) ways -= MOD;             }              dp[b][n][k][sl][l] = ways;             exist[b][n][k][sl][l] = true;         }          return dp[b][n][k][sl][l];     } }  int main() {     int t;     scanf("%d", &t);     while (t--) {         int b, n;         scanf("%d%d", &b, &n);         long long answer = solve(b, n, 0, true, true);         printf("%lld\n", answer);     } }           
#include <bits/stdc++.h>  using namespace std;  #define pb push_back #define mp make_pair #define ll long long #define s(x) scanf("%d", &x) #define sl(x) scanf("%lld", &x) #define sd(x) scanf("%lf", &x) #define mod 1000000007 #define get getchar_unlocked  vector < pair < pair <int, int>, int> > v; int dp[25][200005]; char a[200005]; char b[200005]; int ansA[200005]; int ansB[200005]; int ansAUB[200005];  void suffix(char a[], string &P, int n, int ans[]) {     int i, j, k, x, y;     for (i = 0; i < n; ++i) {         dp[0][i] = a[i] - 97;         P.pb(a[i]);     }     bool con = true;     for (j = 0; con; ++j) {         v.clear();         for (i = 0; i < n; ++i) {             if (i+(1<<j) < n)                 v.pb(mp(mp(dp[j][i], dp[j][i+(1<<j)]), i));             else                 v.pb(mp(mp(dp[j][i], -1), i));         }         sort(v.begin(), v.end());         con = false;         dp[j+1][v[0].second] = 0;         for (i = 1; i < n; ++i) {             if (v[i].first == v[i-1].first) {                 dp[j+1][v[i].second] = dp[j+1][v[i-1].second];                 con = true;             }             else                 dp[j+1][v[i].second] = i;         }     }     int tmp;     ++ans[1];     --ans[n-v[0].second+1];     for (i = 1; i < v.size(); ++i) {         x = v[i].second;         y = v[i-1].second;         tmp = 0;         for (k = j; k >= 0 && x < n && y < n; --k) {             if (dp[k][x] == dp[k][y]) {                 x += (1<<k);                 y += (1<<k);                 tmp += (1<<k);             }         }         ++ans[tmp+1];         --ans[n-v[i].second+1];     } }  int main() {     string P, Q;     scanf("%s", a);     scanf("%s", b);     int lenA = strlen(a);     int lenB = strlen(b);     suffix(a, P, lenA, ansA);     P.pb('=');     suffix(b, P, lenB, ansB);     for (int i = 0; i < P.size(); ++i)         a[i] = P[i];     suffix(a, Q, lenA+lenB+1, ansAUB);     int i;     for (i = 1; i <= lenA; ++i)         ansA[i] += ansA[i-1];     for (i = 1; i <= lenB; ++i)         ansB[i] += ansB[i-1];     int j = lenA + lenB + 1;     for (i = 1; i <= j; ++i)         ansAUB[i] += ansAUB[i-1];     for (i = 1; i <= min(lenA, lenB)+1; ++i)         ansAUB[i] -= i;     int q, x, y;     s(q);     while (q--) {         s(x);         s(y);         if (x == 1)             printf("%d\n", ansA[y] + ansB[y] - ansAUB[y]);         else if (x == 2)             printf("%d\n", ansAUB[y]-ansB[y]);         else if (x == 3)             printf("%d\n", ansAUB[y]-ansA[y]);         else if (x == 4)             printf("%d\n", 2*ansAUB[y]-ansA[y]-ansB[y]);         else             assert(0);     }     return 0; } 
#include <iostream> #include <cmath> using namespace std; bool isprime(int a) { 	if(a==1) return false; 	if(a%2==0) return false; 	for(int i=3;i<=sqrt(a);i++) 	if(a%i==0) return false; 	return true; } int main () { int t; scanf("%d",&t); while(t--) { 	int n; 	scanf("%d",&n); 	int sum=0; 	for(int i=29;i<=n;i++) 	if(isprime(i)) sum+=i; 	 	cout<<sum<<endl; }   return 0; } 
#include <bits/stdc++.h> using namespace std; #define gc getchar #define pc putchar #define mod 1000000007 #define pb push_back #define line() printf("\n") #define space() printf(" ") typedef long long int lli; void sc(int& a){scanf("%d",&a);} void sc(lli& a){scanf("%lld",&a);} void sc(int& a, int& b){sc(a);sc(b);} void sc(int& a,int& b,int& c){sc(a);sc(b);sc(c);} void sc(lli& a,lli& b){sc(a);sc(b);} void sc(lli& a,lli& b,lli& c){sc(a,b);sc(c);} void write(int a){printf("%d",a);} void write(lli a){printf("%lld",a);} //int modpow(int a, int b, int mod){lli res=1;while(b>0){if(b&1)res=(res*a)%mod;a=(a*a)%mod;b=b/2;}return res%mod;}   int main() {     int t,n,i,x;     map<int,lli> mp;     cin>>t;     while(t--)     {         sc(n);         mp.clear();         for(i=0;i<n;i++)         {             sc(x);             mp[x+1]++;         }         int n1=mp.size();         lli ans=0;         for(map<int,lli> :: iterator it=mp.begin();it!=mp.end();it++)         {             int a=it->first;             lli b=it->second;             if(b%(lli)a==0) ans+=b;             else ans+=((b/(lli)a)+1)*a;         }         write(ans);line();     } }
#include<bits/stdc++.h> using namespace std; int  main() {     int t;     cin>>t;     string s;     while(t--) {         cin>>s;         int cnt = 0;         for(int i=0;i<s.size();i++) {             if(s[i]=='A'|| s[i]=='D' || s[i]=='O' || s[i]=='P' || s[i]=='Q' || s[i]=='R') {                 cnt++;             }             if(s[i]=='B') {                 cnt=cnt+2;             }         }         cout<<cnt<<endl;     }     return 0; } 
#include<stdio.h> #include<iostream> #include<string.h>  using namespace std;  int main(){     int t,cnt=0,temp,i=0;     string s;     cin>>t;     for(;t>0;t--){         cin>>s;         temp=s.length();         for(i=0;i<temp;i++){             if(s[i]=='A' || s[i]=='D' || s[i]=='O' || s[i]=='P' || s[i]=='Q' || s[i]=='R'){                 cnt+=1;             }             else if(s[i]=='B')                 cnt+=2;         }         cout<<cnt<<"\n";         cnt=0;     }     return 0; } 
 #include "bits/stdc++.h" using namespace std;  #define input()                   freopen("C:\\Users\\safayet007\\Desktop\\in.txt", "r", stdin) #define output()                  freopen("C:\\Users\\safayet007\\Desktop\\out.txt", "w", stdout); #define FOR(i, a, b)              for(__typeof(b) i = a; i <= b; i++) #define REP(i, a)                 for(__typeof(a) i = 0; i < a; i++) #define REPN(i, a)                for(__typeof(a) i = 1; i <= a; i++) #define ITERATE(it, v)            for(__typeof((v).begin()) it = (v).begin(); it != (v).end(); it++) #define D(x)                      cout << #x << " = " << (x) << endl #define all(v)                    (v).begin(), (v).end() #define SET(a, val)               memset(a, val, sizeof a) #define pb                        push_back #define mp                        make_pair #define endl                      '\n'  typedef long long vlong; typedef pair <int, int> pii;  int main () {     ios_base::sync_with_stdio(false); cin.tie(false);     int T; cin >> T;     int L[1005];     while(T --) {         int n; cin >> n;         SET(L, 0);         int up = 0;         REPN(i, n) {             int k; cin >> k; L[k] ++;             up = max(up, k);         }         REPN(i, n) {             int k; cin >> k; L[k] --;             up = max(up, k);         }         int ans = 0, cs = 0;         REPN(i, up) {             cs += L[i]; ans = max(ans, cs);         }         cout << ans << endl;     }     return 0; } 
#include<iostream> #include<stdio.h> #include<stdlib.h> #include<string> #include<string.h> #include<vector> #include<map> #include<algorithm> #include<limits.h> #include<set> #include<stack> #include<list> #include<queue> #include<math.h>   using namespace std; #define lli long long int #define ulli unsigned long long int #define in(t) scanf("%d",&t) #define inlf(t) scanf("%lf",&t) #define inl(t) scanf("%ld",&t) #define inll(t) scanf("%lld",&t) #define inlu(t) scanf("%llu",&t) #define MOD 1000000007  int main() {     int t,n,i,ans,b,c,d,e,f,g,h,l;     in(t);     while(t--)     {     ans=c=d=e=f=g=h=l=0;     in(n);     if(n<=6)     ans=2;     else if(n<=75)     ans=3;     else if(n<=480)     ans=4;     else if(n<=2205)     ans=5;     else if(n<=8232)     ans=6;     else if(n<=26544)     ans=7;     else     ans=8;     cout<<ans<<"\n";     }     return 0; } 
#include<stdio.h> void scanint(int &x){     char c = getchar_unlocked();     x = 0;     while(c<'0'||c>'9'){         c=getchar_unlocked();     }     while(c>='0'&&c<='9'){         x= (x<<1)+ (x<<3) + c - '0';         c=getchar_unlocked();     } } int main(){     int t;     scanint(t);     while(t--){         int n,k;         scanint(n);         scanint(k);         unsigned long long ans=n;         ans*=n-1;         ans=ans>>1;         if(k!=0){         ans -= (n-k);         }         printf("%llu\n",ans);     } } 
#include<iostream>  #include<algorithm>  #include<cstdio>  using namespace std;  int main()  {  int z,t,ai,i,n,c,a[100];  cin>>t;  while(t--)  {  cin>>n;  for(i=0;i<n;i++)  cin>>a[i];  sort(a,a+n);  c=6;  ai=0;  z=0;  while(ai<n)  {  if(a[ai]==0)  {  z=1;  break;  }  ai++;  c--;  for(i=ai;i<n;i++)  {  a[i]--;  }  if(c==0)  {  c=6;  for(i=ai;i<n;i++)  {  a[i]--;  }  }  }  if(z)  cout<<"NO";  else  cout<<"YES";  cout<<"\n";  }  } 
#include <iostream> #include <vector> #include <algorithm> using namespace std;   template<typename T1, typename T2> struct node {        T1 first;        T2 second;   };   int main() {     int t;     cin >> t;     while(t--) {       long int n, q, i, j;       cin >> n >> q;              vector< pair<long long int, long long int> > v;              for( i = 0; i < n; i++ ) {            long long int x, y;            cin >> x >> y;                        pair< long long int , long long int > p;            p.first = x;            p.second = y-x;                        v.push_back(p);                   }              sort( v.begin(), v.end() );              for( i = 0; i < q; i++ ) {            long long int x;                        cin >> x;                        int flag = 1;                        for( j = 0; j < n; j++ ) {                                  if( x < v[j].first )                    break;                                  if( x >= v[j].first && x <= v[j].first+v[j].second )                  { flag = 0; break; }            }                        if( flag == 1 )                cout << "YES\n";            else                cout << "NO\n";       }     } }                                
#include<iostream> #include<list> #include<map> using namespace std; int main() { 	int n;int m; 	int i,c,t,k; 	cin>>n>>m; 	list<int>arr[m+1]; 	 	map<string,int> Map; 	string s1,s2; 	int j=1; 	for(i=0;i<m;i++) 	{ 		cin>>s1>>s2; 		if(!Map[s1]) 		{ 			Map[s1]=j; 			j++; 		} 		k=Map[s1]; 		if(!Map[s2]) 		{ 			Map[s2]=j; 			j++; 		} 		c=Map[s2]; 		 		arr[k].push_back(c); 		arr[c].push_back(k); 	} 	cin>>t; 	for(i=0;i<t;i++) 	{ 		int count=0; 		cin>>s1; 		int x=Map[s1]; 		map<int,int> MM; 		list<int> ::iterator ii; 		list<int> ::iterator jj; 		for(ii=arr[x].begin();ii!=arr[x].end();ii++) 			MM[*ii]=1;  	 		MM[x]=1; 		ii=arr[x].begin(); 		for(ii;ii!=arr[x].end();ii++) 		 		{ 			for(jj=arr[*ii].begin();jj!=arr[*ii].end();jj++) 			{		 				if(!MM[*jj]) 				{ 					count++;	 					MM[*jj]=1; 				} 			} 		} 		cout<<count<<endl; 	} return 0; } 
#include <iostream> #include <stdio.h> #include <vector> #include <algorithm> using namespace std;   #define M 50000 #define s(a) scanf("%d",&(a))   bool compare_as_given(long long int a,long long int b) {     return(a>b); }   int main() {     int n,m;     s(n);     s(m);     long long int a[M];     for(int i=0;i<n;i++)         s(a[i]);     vector <long long int> xr(n*(n-1));     int k=0;     for(int i=0;i<n-1;i++)         for(int j=i+1;j<n;j++)            {                xr[k++]=a[i]^a[j];                //cout<<xr[i]<<" ";            }            //cout<<endl;     stable_sort(xr.begin(),xr.end(),compare_as_given);     long long int ans=0;     for(int i=0;i<m && i<k;i++)         ans+=xr[i];     printf("%lld\n",ans);     return 0; }
#include<cstdio> using namespace std;  typedef long long LL;  int main(){     int q;scanf("%d",&q);     while(q--){       LL no_of_numbers=9LL;       LL num;scanf("%lld",&num);       if(num==0){            printf("0\n");continue;       }       LL tmp,rem,digits;       for(digits=1;(tmp=num-digits*no_of_numbers)>0;digits++,num=tmp)            no_of_numbers=(no_of_numbers<<3)+(no_of_numbers<<1);       LL val=(rem=num%digits)>0? num/digits+1:num/digits;       val+=no_of_numbers/9LL-1;       if(rem){          for(int i=0;i<digits-rem;i++)            val/=10LL;       }       printf("%lld\n",val%10);     } } 
#include <iostream> #include <cmath> #define aa long long using namespace std; aa int square(aa int n) {     aa int num,rev=0;     while(n!=0)     {         num = n%10;         rev = rev + (num*num);         n = n/10;     }     return rev; } int main() {     aa int tc;     cin>>tc;     while(tc--)     {         aa int n,temp;         cin>>n;         aa int a[n];         for(int i=0;i<n;i++)         {             cin>>a[i];         }         for(int i=0;i<n;i++)         {             temp  = square(a[i]);             while(temp >= 10)             {                 temp = square(temp);             }             if(temp == 1) cout<<"YES"<<endl;             else cout<<"NO"<<endl;         }      } } 
#include <cstdio> using namespace std;  int main() {  		int t,i,n,a,j,ans;bool displaced; 		scanf("%i%i",&t,&n); 		while(t--) 		{ 	        scanf("%i",&j); 	        j++; 	        for(i=1,ans=0;i<n;i++,j++)                 { scanf("%i",&a);                   displaced=(a-j)%n;                   ans+=displaced;                 } 	        printf("%i\n",ans); 		}     return 0; } 
#include <bits/stdc++.h> using namespace std;  const long double pi = 3.14159265358979323846264338328;  int main(){     int t;     cin >> t;     while(t--){         long double r1,h1,r2,h2;         cin >> r1 >> h1 >> r2 >> h2;         long double ar1 = (pi*r1*r1*h1/3) + (2*pi*r1*r1*r1/3);         long double ar2 = pi*r2*r2*h2;         cout << setprecision(20) <<ar1 << " " << ar2 << endl;     } } 
 #include <iostream> #include <algorithm> #include <vector> #include <cstdio> #include <string> #include <bitset> #include <cmath> #include <list> #include <cstdlib> #include <map> #include <cstring> #include <set> #include <stack> #include <sstream> #include <queue> #include <ctime>  using namespace std;  #define debug(x) cout<<#x<<" = "<<x<<"\n" #define FOR(i,a,b)  for(int (i) = (a);(i)<(b);(i)++) #define   REP(i,n) FOR(i,0,n) #define  INF (1<<29) #define         pb push_back #define 	     sz size() #define         mp make_pair #define all(a) a.begin(),a.end() #define SI(n)               scanf("%d",&n); #define SL(n)               scanf("%lld",&n); #define fill(ar,val) memset(ar,val,sizeof ar) #define FORE(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++) #define fi first #define se second typedef long long ll; typedef pair<int,int>  pii; typedef vector<string> vs; ll s2i(string s) { istringstream iss(s); ll x;iss>>x; return x;} string i2s(ll x) { ostringstream oss; oss<<x; return oss.str();} /* Main code begins now */    long long mod;  long long powz( long long a, long long b) {  	if( b == 0) 		return 1;	  	if ( b & 1) 		return a* (powz(a,b-1))%mod; 	else { 	       long long k = powz(a,b/2);        		return k*k%mod;  	} }	       long long an[102][102]; long long colsum[102][102]; long long v[102]; long long a[101]; long long ans ; long long sum; long long area  ; void calculate_max_array( long long a[] , long long n, long long r) {  //	for ( int i = 0; i < n; i++) //		cout << a[i]<<" "; //	cout << endl; 	int dp[n]; 	dp[0] = a[0]; 	v[0] = 0; 	if ( dp[0] == ans) 		area = max(area,1*r); 	else if( dp[0] > ans) { 		area = 1*r; 		ans = dp[0]; 	} 	long long maxi = a[0]; 	long long colwidth = 1;  	for ( int i = 1; i < n; i++) { 		int k = dp[i-1] + a[i]; 		if ( k >= a[i]) { 			v[i] = v[i-1]; 			dp[i] = k; 		}	 		else { 			v[i] = i; 			dp[i] = a[i]; 		} 		if ( ans  == dp[i]  ) {  			colwidth = max(colwidth,i - v[i]+1); 			area = colwidth*r; 			ans = dp[i]; 		} 		else if ( ans < dp[i]) { 			colwidth = i - v[i] + 1; 			area = colwidth*r; 			ans = dp[i]; 		}	 	}	 }	 	 int main() { //	freopen("","r",stdin); //	freopne("","w",stdout);  	int t; 	scanf("%d",&t);  	while ( t-- ) { 		int n,m; 		string s; 		ans = -1000000; 		scanf("%d%d",&n,&m); 		vector < string > v; 		for ( int i = 0; i < n; i++){ 			cin >> s; 			v.pb(s); 		} 		cin >> mod; 		int F = 0; 		int I = 0; 		area = 1; 		for ( int i = 0; i < n; i++) { 			for ( int j = 0; j < m; j++) { 				colsum[i][j] = 0; 				if( v[i][j] == 'I') {   					an[i][j] = (int )powz((++I),i+j);	 				} 				else { 					an[i][j] = - (int)powz((++F),i+j); 					 				} //				cout << an[i][j]<<" "; 			} //			cout << endl; 			 		} //		cout<<"S"<< endl; 		for ( int i = 0; i < m; i++) { 			colsum[0][i] =an[0][i]; //			cout << colsum[0][i]<<" "; 		 	for ( int j = 1; j < n; j++) { 			  				colsum[j][i] += colsum[j-1][i] + an[j][i]; //				cout<< colsum[j][i] << " ";  			} //			cout << endl; 		} 	//	 cout <<"as" <<endl; 		for ( int i = 0; i < n; i++) { 			for ( int j = i; j < n; j++) { 				for ( int k = 0; k < m; k++) { 					 				       	if ( i != 0 ) 						a[k] = colsum[j][k] - colsum[i-1][k]; 					else 						a[k] = colsum[j][k];	 						 				} 				 calculate_max_array(a,m,j-i+1); 			       		       		 			} 		}	 		cout << area << endl;  	}	 			 	 	return 0; }               
#include <iostream> #include <cstdio> #include <cstring> #include <cstdlib> #include <cctype> #include <algorithm> #include <map> #include <vector> #include <list> #include <set> #include <queue> #include <deque> #include <stack> #include <string> #include <cmath> using namespace std; #define FOR(i,a,b) for(i=a;i<b;i++) #define REP(i,n) FOR(i,0,n) struct pb { 	int x,y; }posb[251],tmpb; vector<pb>useb; vector<int> a[251]; vector<int> b[251]; int n,s; struct pa { 	int x,y; }posa[251],tmpa; vector<pa>usea; int sa,sb; int pres(int a1,int b1) { 	int i,j; 	for(i=1;i<=sa;i++) 	{ 		if(posa[i].x==a1&&posa[i].y==b1) 			return 1; 	} 	for(j=1;j<=sb;j++) 	{ 		if(posb[j].x==a1&&posb[j].y==b1) 			return 1; 	}		 	return 0; } int frea(int a1,int b1) { 	int i; 	if(a1<1||b1<1||a1>n||b1>n) 		return 0; 	for(i=0;i<usea.size();i++) 		if(usea[i].x==a1&&usea[i].y==b1) 			return 0; 	if(!pres(a1,b1)) 	{ 		tmpa.x=a1; 		tmpa.y=b1; 		usea.push_back(tmpa); 	} } int freb(int a1,int b1) { 	if(a1<1||b1<1||a1>n||b1>n) 		return 0; 	int i; 	for(i=0;i<useb.size();i++) 		if(useb[i].x==a1&&useb[i].y==b1) 			return 0; 	if(!pres(a1,b1)) 	{ 		tmpb.x=a1; 		tmpb.y=b1; 		useb.push_back(tmpb); 	} } int chka(int f,int g) { 	if(posa[f].x==posa[g].x&&posa[f].y==posa[g].y) 		return 0; 	if(abs(posa[f].x-posa[g].x)==1&&posa[f].y==posa[g].y) 		return 1; 	else if(abs(posa[f].y-posa[g].y)==1&&posa[f].x==posa[g].x) 		return 1; 	return 0; } int chkb(int f,int g) { 	if(posb[f].x==posb[g].x&&posb[f].y==posb[g].y) 		return 0; 	if(abs(posb[f].x-posb[g].x)==1&&posb[f].y==posb[g].y) 		return 1; 	else if(abs(posb[f].y-posb[g].y)==1&&posb[f].x==posb[g].x) 		return 1; 	return 0; }  int tot,visita[1001],visitb[1001]; int dfsa(int v) { 	int i; 	tot++; 	visita[v]=1; 	frea(posa[v].x+1,posa[v].y); 	frea(posa[v].x,posa[v].y+1); 	frea(posa[v].x-1,posa[v].y); 	frea(posa[v].x,posa[v].y-1); 	for(i=0;i<a[v].size();i++) 	{ 		if(!visita[a[v][i]]) 			dfsa(a[v][i]); 	} } int dfsb(int v) { 	int i; 	tot++; 	visitb[v]=1; 	freb(posb[v].x+1,posb[v].y); 	freb(posb[v].x,posb[v].y+1); 	freb(posb[v].x-1,posb[v].y); 	freb(posb[v].x,posb[v].y-1);  	for(i=0;i<b[v].size();i++) 	{ 		if(!visitb[b[v][i]]) 			dfsb(b[v][i]); 	}  } struct an { 	char col; 	int d,c; }ans[1001]; bool cmpa(an p1, an p2) { 	if(p1.c!=p2.c) 		return (p1.c>p2.c); 	return (p1.d>p2.d); } bool cmpb(an p1,an p2) { 	if(p1.c!=p2.c) 		return (p1.c>p2.c); 	return (p1.d>p2.d); }  int main() { 	int t,i,j; 	scanf("%d\n",&t); 	int xt=0; 	char c; 	while(xt<t) 	{ 		xt++; 		sa=0; 		sb=0; 		fill(visita,visita+1001,0); 		fill(visitb,visitb+1001,0); 		scanf("%d %d",&n,&s); 		for(i=1;i<=s;i++) 		{ 			a[i].clear(); 			b[i].clear(); 			scanf(" %c ",&c); 				if(c=='B') 				{ 					sb++; 					scanf("%d %d",&posb[sb].x,&posb[sb].y); 				} 				else 				{ 					sa++; 					scanf("%d %d",&posa[sa].x,&posa[sa].y); 				} 		} 		printf("Case #%d:\n",xt); 		for(i=1;i<=sb;i++) 		{ 			for(j=i+1;j<=sb;j++) 			{ 				if(chkb(i,j)) 				{ 					b[i].push_back(j); 					b[j].push_back(i); 				} 			} 		} 	 		int ant=0; 		useb.clear(); 		for(i=1;i<=sb;i++) 		{ 			tot=0; 			if(!visitb[i]) 			{ 				dfsb(i); 				ans[ant].d=useb.size(); 				ans[ant].col='B'; 				ans[ant++].c=tot; //				printf("%d\n",tot); 			//	for(j=0;j<useb.size();j++) 		//			printf("%d %d, ",useb[j].x,useb[j].y); 	//			printf("\n"); 				useb.clear(); 			} 		} 		sort(ans,ans+ant ,cmpb); 		for(i=0;i<ant;i++) 			printf("%c %d %d\n",ans[i].col,ans[i].c,ans[i].d); //		printf("\n\n"); 		for(i=1;i<=sa;i++) 		{ 			for(j=i+1;j<=sa;j++) 			{ 				if(chka(i,j)) 				{ 					a[i].push_back(j); 					a[j].push_back(i); 				} 			} 		} 		ant=0; 		usea.clear(); 		for(i=1;i<=sa;i++) 		{ 			tot=0; 			if(!visita[i]) 			{ 				dfsa(i); 				ans[ant].d=usea.size(); 				ans[ant].col='W'; 				ans[ant++].c=tot; 				usea.clear(); 			} 		} //		for(i=1;i<=sa;i++) //		{ //			for(j=0;j<a[i].size();j++) //				printf("%d ",a[i][j]); //			printf("\n"); //		} 	sort(ans,ans+ant,cmpa); 		for(i=0;i<ant;i++) 			printf("%c %d %d\n",ans[i].col,ans[i].c,ans[i].d); 		printf("\n"); 	} 	return 0; } 
#include <iostream>  using namespace std; const long long mod=1000000000+7; typedef long long ll; static int fact[10000007];  ll powx(ll a,ll b){     if(b==0)return 1;     if(b==1)return a%mod;     if(b%2==1)return ((a%mod)*powx(a,b-1)%mod)%mod;     ll y=powx(a,b/2)%mod;     return (y*y)%mod; } int main() { int t;long long n;fact[0]=1; cin>>t; while(t--){     cin>>n;     long long ans=1;     for(long long i=1;i<=n;i++){             fact[i]=(fact[i-1]*i)%mod;                 ans=(ans*fact[i])%mod;                 if(ans<0)ans+=mod;         }     cout<<ans<<endl; }      return 0; } 
#include <iostream> #include <stdio.h> #include <string.h> #include <math.h> #include <vector> #include<stack> #include<set> #include<limits.h> #include <queue> #include <map> #include <cstdlib> #include <algorithm> //psyduck #define ll long long #define S(x) scanf("%d",&x) #define Sf(x) scanf("%f",&x) #define Slf(x) scanf("%lf",&x) #define Sl(x) scanf("%lld",&x) #define P(x)  printf("%d\n", x) #define Pf(x)  printf("%f\n", x) #define Plf(x)  printf("%lf\n", x) #define Pl(x)  printf("%lld\n", x) #define mem(x,i) memset(x,i,sizeof(x)) #define pb push_back #define mod 1000000007 #define INF 1000000000000000008LL using namespace std;  void dba(int debug_array[],int n){     for (int i = 1; i <= n; i++)cout << debug_array[i]<<" ";     cout << endl; } void db2a(int debug2d[100][100],int n, int m) {     for (int i = 1; i <= n; i++)         for(int j = 1; j <= m; j++)             cout << debug2d[i][j];         cout << endl; } ll int dp[1004][1005]; int main() {     ll int t,sum,m,n,i,j,k;     Sl(t);Sl(sum);     t++;     ll int ans = 0;     while(t--){         mem(dp,0);         Sl(n);Sl(m);         dp[0][0] = 1;         for (i = 1; i <= n; i++){             for (j = 1; j <= sum; j++){                 dp[i][j] = 0;                 if(j == 0){                     dp[i][0] = 1;                     continue;                 }                 for (k = 1; k <= m; k++){                     if(j >= k)                     dp[i][j] = (dp[i][j]+dp[i-1][j-k])%mod;                 }             }         }         //Pl(dp[n][sum]);         //ll int ans = 0;         ans = (ans + dp[n][sum])%mod;     }     Pl(ans); } 
#include<bits/stdc++.h> using namespace std; #define INF (1<<29) #define SET(a) memset(a,-1,sizeof(a)) #define ALL(a) a.begin(),a.end() #define CLR(a) memset(a,0,sizeof(a)) #define FILL(a,v) memset(a,v,sizeof(a)) #define PB push_back #define PI acos(-1.0) #define EPS 1e-9 #define MP(a,b) make_pair(a,b) #define MIN3(a,b,c) min(a,min(b,c)) #define MAX3(a,b,c) max(a,max(b,c)) #define CASE int t;scanf("%d",&t);while(t--) #define ll long long int #define lu unsigned long long #define MOD 1000000007 #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min() #define rep(i,n) for(int i=0;i<n;i++) #define fu(i,a,n) for(int i=a;i<=n;i++) #define fd(i,n,a) for(int i=n;i>=a;i--) #define gi(n) scanf("%d",&n) #define gl(n) scanf("%lld",&n) #define pi(n) printf("%d",n) #define pin(n) printf("%d\n",n) #define ps printf(" ") #define pn printf("\n")  typedef pair<int, int> ii; typedef vector<int> vi; typedef vector<ii> vii;   int main() {     int n;     gi(n);     int a[n],cnt[1001],mx=0,pos=0;     CLR(cnt);     rep(i,n)     {     	gi(a[i]);     	cnt[a[i]]++;     }     rep(i,1001)     {     	if(cnt[i]>mx)     	{     		mx =cnt[i];     		pos = i;     	}     }     printf("%d\n%d\n",pos,mx );     return 0; } 
#include <bits/stdc++.h> using namespace std;  #define ll long long #define ld long double #define sl(x) scanf("%lld",&x) #define pl(x) printf("%lld",x) #define sld(x) scanf("%Lf",&x) #define pld(x) scanf("%0.6Lf",x) #define pline() printf("\n")  int main(){     ll i,h;     ld n,a[102],m,sum=0;     ld ans1,ans2,res;     sld(n);sld(m);sl(h);     for(i=1;i<=m;i++){         sld(a[i]);         sum+=a[i];     }     if(sum>=n){         sum--;ans1=1;ans2=1;         //cout<<sum<<endl;         for(i=0;i<=n-2;i++){             ans1*=(sum-i)/(i+1);             //cout<<ans1<<endl;         }          sum++;         sum=sum-a[h];         //cout<<endl;         for(i=0;i<=n-2;i++){             ans2*=(sum-i)/(i+1);             //cout<<ans2<<endl;         }                  res=(ans1-ans2)/ans1;         printf("%Lf",res);     }     else     printf("-1");     pline(); 	return 0; } 
#include <bits/stdc++.h> using namespace std;  int main() {     int t;     cin>>t;     while(t--)     {     long long int n,ti;     cin>>n>>ti;          long long int T[n][n];     long long int toll[n][n];          for(int i=0;i<n;i++)       for(int j=0;j<n;j++)         cin>>T[i][j];                       for(int i=0;i<n;i++)       for(int j=0;j<n;j++)         cin>>toll[i][j];                   long long int dp[55][10005];          for(int i=0;i<55;i++)       for(int j=0;j<10005;j++)         dp[i][j]=INT_MAX;              for(int i=0;i<=ti;i++)       dp[0][i]=0;              for(int time=1;time<=ti;time++)       {        for(int destination=1;destination<n;destination++)          {           for(int source=0;source<n;source++)             {               if(destination==source)                  continue;                if(time>=T[source][destination])                dp[destination][time]=min(dp[destination][time],dp[source][time-T[source][destination]]+toll[source][destination]);             }           }       }     /*for(int i=0;i<n;i++)       { for(int j=0;j<=ti;j++)          {            cout<<dp[i][j]<<" ";          }         cout<<endl;       }*/     int min_time=ti;     while(dp[n-1][ti]==dp[n-1][ti-1])       {       ti--;        min_time--;       }     cout<<dp[n-1][ti]<<" "<<min_time<<endl;    } 	return 0; }
#include <iostream> #include <vector>  using namespace std;  int noOfBlocks, columnLength, rowLength;  struct Block { int period, cellNumber, row, column; vector<int> cells, rowChange, columnChange; }; Block *blocks;  int GCD(int a, int b) { return !b?a:GCD(b,a%b); }  inline int LCM(int a, int b) { return(a*b)/GCD(a,b); }  void sortBlocks() { int min=blocks[0].period; int index=0; for(int i=0; i<noOfBlocks; i++) 	{ 	if(min>blocks[i].period) 		{ 		min=blocks[i].period; 		index=i; 		} 	} if(index) 	{ 	Block temp; 	temp=blocks[0]; 	blocks[0]=blocks[index]; 	blocks[index]=temp; 	} }  int findTotalCells() { int limit=1, lcm=1, maxCells=blocks[0].period, minimumPeriod=blocks[0].period; bool flag; vector<int> newCommonCells; vector<bool> successfulCases; for(int j=0; j<noOfBlocks; j++) 	lcm=LCM(lcm,blocks[j].period); limit=lcm/blocks[0].period; for(int j=0; j<blocks[0].period; j++) 	{ 	int cellN=blocks[0].cells[j]; 	int k=0; 	flag=false; 	for(int I=0; I<limit&&!flag; I++) 		{ 		flag=true; 		for(int i=1; i<noOfBlocks; i++) 			{ 			if(cellN!=blocks[i].cells[(k+j)%blocks[i].period]) 				{ 				flag=false; 				break; 				} 			} 		k=k+minimumPeriod; 		} 	successfulCases.push_back(flag); 	} for(int i=0; i<minimumPeriod; i++) 	{ 	flag=true; 	int temp; 	if(successfulCases[i]==true) 		{ 		temp=blocks[0].cells[i]; 		for(int j=0; j<newCommonCells.size(); j++) 			if(temp==newCommonCells[j]) 				{ 				flag=false; 				break; 				} 		if(flag) 			newCommonCells.push_back(temp); 		} 	} return newCommonCells.size(); }  main() { int fall, temp; for(cin>>fall; fall--;) 	{ 	cin>>rowLength>>columnLength>>noOfBlocks; 	blocks=new Block[noOfBlocks]; 	for(int i=0; i<noOfBlocks; i++) 		{ 		cin>>blocks[i].cellNumber; 		cin>>blocks[i].period; 		for(int j=0; j<blocks[i].period; j++) 			{ 			cin>>temp; 			blocks[i].rowChange.push_back(temp); 			} 		for(int j=0; j<blocks[i].period; j++) 			{ 			cin>>temp; 			blocks[i].columnChange.push_back(temp); 			} 		for(int j=0; j<blocks[i].period; j++) 			blocks[i].cells.push_back(blocks[i].cellNumber+blocks[i].rowChange[j]*columnLength+blocks[i].columnChange[j]); 		blocks[i].rowChange.clear(); 		blocks[i].columnChange.clear(); 		} 	sortBlocks(); 	cout<<findTotalCells()<<endl; 	delete[] blocks; 	} return 0; } 
#include<bits/stdc++.h> using namespace std; int main(){ 	int t; 	cin>>t; 	while(t--){ 		string s; cin>>s; 		int l=s.size(); 		int f=0; 		for(int i=0; i<l-1; i++){ 			if(s[i]=='0' && s[i+1]=='1') f++; 		} 		cout<<f<<endl; 	} }
#include<iostream> using namespace std; int main() {     int test,n,b;     cin>>test;     while(test--)     {         cin>>n;         int count=0;         while(n)         {             b=n;             //cout<<(b&1)<<endl;             if((b&1)!=0)                 break;             count++;             n=n>>1;         }         cout<<count<<endl;     } } 
#include<iostream> #include<string.h> using namespace std; char arr[100001]; int num[10] = { 0 }; int apl[26] = { 0 }; int main() { 	int t; 	cin >> t; 	while (t--) 	{ 		cin >> arr; 		for (int i = 0; arr[i] != '\0'; i++) 		{ 			if (isalpha(arr[i])) 			{ 				apl[arr[i] - 'a']++; 			} 			else 				num[arr[i] - '0']++; 		} 		int ind1, ind2; 		ind1 = ind2 = 0; 		for (int i = 0; arr[i] != '\0'; i++) 		{ 			if (isalpha(arr[i])) 			{ 				while (!apl[ind2] && ind2<26) 				{ 					ind2++; 				} 				arr[i] = 'a' + ind2; 				apl[ind2]--; 			} 			else 			{ 				while (!num[ind1] && ind1 < 10) 					ind1++; 				arr[i] = '0' + ind1; 				num[ind1]--; 			} 		} 		cout << arr << endl;; 	}  return 0; }
#include<iostream>  using namespace std;  int main() { 	int t,x; 	long long n,sum,tot; 	cin >> t; 	while (t--) 	{ 		tot=sum = 0; 		cin >> n; 		sum = (n*(n + 1)); 		sum = sum >> 1; 		for (int i = 0; i < n-1; i++) 		{ 			cin >> x; 			tot += x; 		} 		cout << sum -tot<< endl; 	}  	return 0; }
#include <bits/stdc++.h> using namespace std;  int main()  { int test; long long int i, n ,m ; cin >> test;  while(test--) { long long int sum = 0; cin >>n >>m; long long diff = m-1; long long sum1 = (diff * (diff+1)) / 2; long long int x = n % m;  long long int extra = n/m;      sum =sum1 * extra;  if(x != 0) {   sum = sum + x*(x+1) / 2; }  cout << sum << endl;  }    //STUPID SHIT 	return 0; }
#include<iostream> #include<string.h> #include<stdio.h> using namespace std; int main() { int t; cin>> t; while(t--) {   int n;   cin>>n;   char a[10001];   scanf("%s" , &a);   int f= strlen(a);     int temp;  for(int i=0; i<f; i++)   {       temp = a[i] - 'a';     temp = (temp+n)%26;     char j=char(temp + 'a');     cout<<j;    }   cout<<"\n";   } } 
#include<iostream> #include<math.h> using namespace std; int len(long unsigned n) {	int l=0; 	while(n) n/=10,l++; 	return l; } int isprime(long unsigned n) {	long unsigned i; 	for(i=2;i<n;i++) 	if(n%i==0) break; 	if(i==n) return 1; 	else return 0; } long unsigned num_rot(long unsigned n,int f) {	int i,l=len(n)-1; 	while(f--) 	{	i=n%10; 		n/=10; 		n+=i*pow(10,l);	 	} 	return n; } int cir_prime(long unsigned n) {	long unsigned k=n; 	int l=len(n); 	if(isprime(k)) 	{	while(l--) 		{	k=num_rot(n,l); 			if(!isprime(k)) break; 			if(k<n && cir_prime(k)) break; 		} 		if (l==-1) return 1; 		else return 0; 	} 	else  		return 0; } int main() { 	long unsigned t,n,i; 	int count; 	cin>>t; 	while(t--) 	{	cin>>n; 		cout<<"Number of circular primes below "<<n<<" is "; 		count=0; 		for(i=2;i<n;i++) 		{	if(cir_prime(i)) count++; 		} 		cout<<count<<endl; 	} }
#include<iostream> using namespace std; long getSumOfDivisors(long n);  int main() {     long n,sum=0,sum1=0;     int t; cin>>t;     while(t--)     {         cin>>n;     sum=getSumOfDivisors(n);     sum1=getSumOfDivisors(sum);     if(sum1 == n)         cout<<"Yes, amicable with "<<sum<<endl;     else         cout<<"No"<<endl;     }     return 0; } long getSumOfDivisors(long n) {     long sum =1;     for(long i=2;i<=n/2;++i)     {         if(n % i == 0)         {             sum += i;         }     }     return sum; }
#include <stdio.h>  int main() {     int i = 100, rem, sum, temp, tnum;            for ( ; i <= 999; i++)     {         tnum = i;         sum = 0;         while (tnum > 0)         {             rem = tnum % 10;             temp = rem * rem * rem;             sum = temp + sum;             tnum = tnum / 10;         }         if (i == sum)             printf("%d\n", sum);     }     return 0;      }
#include <iostream> #include <bits/stdc++.h> #include <string> #include <cstring> using namespace std;  int dp[1000][1000];   int LCS(string s1, string s2) { 	int m, n, i, j; 	m = s1.length(); 	n = s2.length();  	for(i = 0; i <= m; i++) { 		for(j = 0; j <= n; j++) { 			if (i == 0) { 				dp[i][j] = 0; 			} else if (j == 0) { 				dp[i][j] = 0; 			} else if (s1[i-1] == s2[j-1]) { 				dp[i][j] = 1 + dp[i-1][j-1]; 			} else { 				dp[i][j] = max(dp[i-1][j], dp[i][j-1]); 			} 		} 	}  	return dp[m][n]; }  int main() { 	string s1, s2; 	cin>>s1>>s2; 	cout<<LCS(s1, s2)<<endl; 	return 0; } 
#include<stdio.h> #include<stdlib.h> #include<string.h>     struct node {        char cha;        struct node *next;        };         void push(struct node** head_ref, char new_data) {    struct node* new_node =(struct node*) malloc(sizeof(struct node));    new_node->cha = new_data;    new_node->next = (*head_ref);    (*head_ref)= new_node; } struct node* deleteit(struct node *temp,int n) {        n=n-1;      int count=1;      struct node *p,*q;      while(count<n)      {                    temp=temp->next;                    count++;                    }                    p = temp->next->next;                    q=temp->next;                    temp->next=p;     free(q);                   return p;                    }     int absolute(int x,int y)  {      if(y>x)      return y-x;      else      return x-y;      }        int main()        {            int t;            scanf("%d",&t);            while(t--)            {            int c[30],d[30],m,x,n=0,i;            char a[20007],b[20007];            struct node *head=NULL;            struct node *tem;            struct node *temp;            scanf("%s",a);            scanf("%s",b);            x=strlen(a);            m=strlen(b);            for(i=0;i<28;i++)            {                             c[i]=0;                             d[i]=0;                             }            for(i=0;i<x;i++)            {                            if(a[i]>='a'&&a[i]<='z')            c[a[i]-'a']++;            else            c[a[i]-'A']++;            }            for(i=0;i<m;i++)            {                            if(b[i]>='a'&&b[i]<='z')            d[b[i]-'a']++;            else            d[b[i]-'A']++;            }            for(i=0;i<28;i++)            n=n+absolute(c[i],d[i]);             push(&head,'s');             push(&head,'e');             push(&head,'m');   push(&head,'a');   push(&head,'l');   push(&head,'f');   tem=head;   while(tem->next!=NULL)   {                         tem=tem->next;                         }                         tem->next=head;                 if(n==0||n==1)             printf("SISTER\n");             else             {                temp=deleteit(head,n);                            temp=deleteit(temp,n);                           temp=deleteit(temp,n);                                temp=deleteit(temp,n);                                  temp=deleteit(temp,n);             if(temp->cha=='f')             printf("FRIENDS\n");             if(temp->cha=='l')             printf("LOVE\n");             if(temp->cha=='a')             printf("ADORE\n");             if(temp->cha=='m')             printf("MARRIAGE\n");             if(temp->cha=='e')             printf("ENEMIES\n");             if(temp->cha=='s')             printf("SISTER\n");             }             }             return 0;             } 
/* Success is a matter of hanging on, when others have let go. Its not who you are, that holds you back, its who you think you are not. The future belongs to those, who believe in the beauty of their dreams. */ //{ /* theCodeGame */ #include<iostream> #include<cmath> #include<algorithm> #include<climits> #include<vector> #include<queue> #include<bitset> #include<cstdlib> #include<cstdio> #include<cstring> #include<ctime> #include<map> using namespace std; #define MOD 1000000007LL #define LL long long #define ULL unsigned long long #define LD long double #define MAX(a,b) ((a)>(b)?(a):(b)) #define MIN(a,b) ((a)<(b)?(a):(b)) #define ABS(x)   ((x)<0?-(x):(x)) #define SQR(x) ((x)*(x)) #define CUBE(x) ((x)*(x)*(x)) #define si(n) scanf("%d",&n) #define si2(n,m) scanf("%d %d",&n,&m) #define sf(n) scanf("%f",&n) #define sl(n) scanf("%ld",&n) #define sll(n) scanf("%lld",&n) #define slu(n) scanf("%llu",&n) #define sd(n) scanf("%lf",&n) #define ss(n) scanf("%s",n) #define pnl printf("\n") #define REP(i,n) for(int i=0;i<(n);i++) #define FOR(i,a,b) for(int i=(a);i<(b);i++) #define FORR(i,n,e) for(int i=(n);i>=(e);i--) #define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d)) #define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d)) //#undef mydebug #ifdef mydebug #define DB(x) cout<<#x<<"="<<(x)<<"\n" #define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n" #define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n" #define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n" #define pnld pnl; #else #define DB(x) #define DB2(x,y) #define DB3(x,y,z) #define DB4(x,y,z,a) #define pnld #endif #define FILL(a,b) memset(a,b,sizeof(a)) const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; //template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;} void DBG_ARR(const int A[],int S,int N){cout<<"[";FOR(i,S,N){cout<<A[i]<<" ";}cout<<"]\n";} void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;} ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} //} const int TOP = 1; const int RIGHT = 2; const int BOTTOM = 3; const int LEFT = 4; int ROWS,COLS,ENTRY; int arr[11][11]; char INPUT[11];  void precompute(){} void doThis(){     scanf("%d %d %d",&ROWS,&COLS,&ENTRY);      FOR(i,0,ROWS){         ss(INPUT);         FOR(j,0,COLS){           arr[i][j] = INPUT[j];         }      }      int currROW = 0,currCOL = ENTRY-1;      int temp,loop,visited = 0;      while(1){               temp = arr[currROW][currCOL];               if(temp<0){//if already visited                       loop = 0 - (visited - temp - 1);                       printf("%dL\n",loop);                       return;                }else{                     arr[currROW][currCOL] = --visited;                     switch(temp){                                  case 78: case 110:                                       if(currROW == 0){                                                printf("%dE\n",(0-visited));                                                return;                                       }                                       else                                       currROW-=1;                                       break;                                  case 69: case 101:                                       if(currCOL == COLS-1){                                                printf("%dE\n",(0-visited));                                                return;                                       }                                       else                                       currCOL+=1;                                        break;                                  case 83: case 115:                                       if(currROW == ROWS-1){                                                printf("%dE\n",(0-visited));                                                return;                                       }                                       else                                       currROW+=1;                                       break;                                  case 87: case 119:                                       if(currCOL == 0){                                                printf("%dE\n",(0-visited));                                                return;                                       }                                       else                                       currCOL-=1;                                       break;                                  default : break;                     }//end switch               }//end if else      }//end while }  int main(){ #ifdef amy freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr); #endif precompute(); int t=1; scanf("%d",&t); while(t--){doThis();} #ifdef amy fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC)); #endif return 0; } 
/* bhupkas */  #include "bits/stdc++.h"  using namespace std;  int read () { 	bool minus = false; 	int result = 0; 	char ch; 	ch = getchar(); 	while (true) { 		if (ch == '-') break; 		if (ch >= '0' && ch <= '9') break; 		ch = getchar(); 	} 	if (ch == '-') minus = true; else result = ch-'0'; 	while (true) { 		ch = getchar(); 		if (ch < '0' || ch > '9') break; 		result = result*10 + (ch - '0'); 	} 	if (minus) 		return -result; 	else 		return result; }  int  A[100005]; int  memo[100005];  #define INF (int)(1e9) /*  int segtree[400005]; void build(int idx,int l,int r) { 	if(l == r)	 	{ 		segtree[idx] = A[l]; 		return; 	} 	int mid = (l + r ) >> 1; 	build(2*idx + 1 , l , mid); 	build(2*idx + 2 , mid + 1 , r); 	segtree[idx] = min(segtree[2*idx + 1] , segtree[2 * idx + 2]); }  int query(int idx, int l ,int r , int ql , int qr) { 	if(l > qr || r < ql)	return INF; 	if(l >= ql && r <= qr)	return segtree[idx];  	int mid = (l + r) >> 1; 	if(mid >= qr)	return query(2*idx + 1 , l , mid , ql , qr); 	else if(mid < ql)	return query(2*idx + 2 , mid + 1 , r , ql , qr); 	return min(query(2*idx + 1 , l , mid , ql , qr) , query(2*idx + 2 , mid + 1, r, ql, qr));	 }  void update(int idx, int l , int r , int index, int val) { 	if(index < l || index > r)	return; 	if(l == r && index == l)	 	{ 		segtree[idx] = val; 		return; 	} 	int mid = (l + r) >> 1; 	if(mid >= index)	update(2 * idx + 1, l , mid , index , val); 	else			update(2 * idx + 2, mid + 1, r , index, val); 	segtree[idx] = min(segtree[2*idx+1],segtree[2*idx+2]); } */ int main() { 	int t,n,d; 	t = read(); 	deque < int > q1,q2; 	while(t--) 	{ 		q1.clear(); 		q2.clear(); 		n = read(); 		d = read(); 		for(int i = 0 ; i < n ; i++)	A[i] = read(); 		for(int i = 0 ; i < n ; i++)	memo[i] = INF; 		//build(0,0,n-1); 		memo[0] = A[0]; 		q1.push_back(memo[0]); 		q2.push_back(memo[0]); 		//update(0,0,n-1,0,memo[0]); 		for(int i = 1 ; i < n ; i++) 		{	 			memo[i] = min(memo[i] , q1.front() + A[i]); 			while(!q1.empty() && memo[i] < q1.back())	q1.pop_back();			 			q1.push_back(memo[i]); 			q2.push_back(memo[i]); 			if(q2.size() > d) 			{ 				if(q2.front() == q1.front())	q1.pop_front() , q2.pop_front(); 				else	q2.pop_front(); 			} 			//update(0,0,n-1,i,memo[i]); 		} 		printf("%d\n",memo[n-1]); 	} 	return 0; }
#include <cstdio> #include <cmath> #include <cstring> int a[100001]; int countPalindrome(char *str) { 	int i,j,k,count=0; 	for(i=0;str[i];i++) 	{ 		k=i-1; 		j=i+1; 		while(k>=0 && str[j] && str[k]==str[j]) 		{             if(a[(j-k)+1]==0) 			   ++count; 			k--; 			j++; 		}  		k=i; 		j=i+1; 		if(k>=0 && str[j] && str[k]==str[j]) 			++count; 	} 	return count; } int main() {     int t;     char s[100001];     int i,j;     memset(a,0,sizeof a);     a[1]=a[0]=1;     for(i=2; i<=sqrt(100000); i++)         if(a[i]==0)             for(j=2; (i*j)<100000; j++)                 a[i*j]=1;     scanf("%d",&t);     while(t--)     {         scanf("%s",s);         printf("%d\n",countPalindrome(s));     }     return 0; } 
     #include<iostream>     #define modulo 10000007ULL     #define constant 2ULL     #define constant2 3ULL     using namespace std;     unsigned long long exponent(unsigned long long number,int n)     {     unsigned long long e;     if(n==0) return 1;     e = exponent(number,n/2);     e=(e*e)%modulo;     if(n&1)     e=(e*number)%modulo;     return e;     }     int main()     {     int t,n;int temp2=9988439;     cin>>t;     while(t--)     {     cin>>n;     if(n&1)     {     n--;     unsigned long long temp=((exponent(constant,n)-1)*(exponent(constant2,temp2)))%modulo;     unsigned long long res=(constant*temp+1)%modulo;     cout<<res<<"\n";     }     else     {     unsigned long long temp=((exponent(constant,n)-1)*(exponent(constant2,temp2)))%modulo;     cout<<temp<<"\n";     }     }     } 
/* bhupkas */  #include "bits/stdc++.h"  using namespace std;  int cnt[100005];  int read ()  { 	bool minus = false; 	int result = 0; 	char ch; 	ch = getchar(); 	while (true) { 		if (ch == '-') break; 		if (ch >= '0' && ch <= '9') break; 		ch = getchar(); 	} 	if (ch == '-') minus = true; else result = ch-'0'; 	while (true) { 		ch = getchar(); 		if (ch < '0' || ch > '9') break; 		result = result*10 + (ch - '0'); 	} 	if (minus) 		return -result; 	else 		return result; }  int main() { 	int t,n,q; 	t = read(); 	deque<int> Q; 	int a,b; 	int curr; 	int si; 	while(t--) 	{ 		si = 0; 		Q.clear(); 		n = read(); 		q = read(); 		memset(cnt,0,sizeof(cnt)); 		while(q--) 		{ 			a = read(); 			b = read(); 			if(a == 1) 			{	 				Q.push_back(b); 				if(cnt[b] == 0)	si++; 				cnt[b]++; 				if(si > n) 				{ 					while(si > n) 					{ 						curr = Q.front(); 						Q.pop_front(); 						cnt[curr]--; 						if(cnt[curr] == 0)	si--; 					} 				} 			} 			else 			{	 				if(cnt[b] > 0)	puts("YES"); 				else		puts("NO"); 			}	 		} 	} 	return 0;	 }
#include<bits/stdc++.h>  using namespace std;  static int dp[1000][1000] , arr1[1000][1000] , arr2[1000][1000];  int main () { 	int t , n , m , i , j , q , x1 , y1 , x2 , y2 , sum; 	 	cin >> t; 	 	while(t --) 	{ 		cin >> n >> m >> q; 		 		for(i = 0; i < n ; i++) 		{ 			for(j = 0; j < m; j ++) 				cin >> arr1[i][j]; 		} 		 		for(i = 0; i < n; i++) 		{ 			cin >> arr2[i][0]; 			 			if(arr2[i][0] == arr1[i][0]) 				dp[i][0] = 1; 				 			else 				dp[i][0] = 0; 		 			for(j = 1; j < m; j++) 			{ 				cin >> arr2[i][j]; 				 				if(arr2[i][j] == arr1[i][j]) 					dp[i][j] = dp[i][j - 1] + 1; 					 				else 					dp[i][j] = dp[i][j - 1]; 			} 			 		} 		 		for(j = 0; j < q; j++) 		{ 			cin >> x1 >> y1 >> x2 >> y2; 			 			sum = 0; 			 			for(i = x1 - 1; i <= x2 - 1; i++) 			{ 				if(arr2[i][y1 - 1] == arr1[i][y1 - 1]) 					sum = sum + dp[i][y2 - 1] - dp[i][y1 - 1] + 1; 					 				else 					sum = sum + dp[i][y2 - 1] - dp[i][y1 - 1]; 					 			} 			 			cout << sum << endl; 			 		} 		 	} 	 	return 0; 	 } 		 
//#include<utility>  #include <iostream> #include <cmath> #include <vector> #include <queue> #include <algorithm> #include <list> #include <stack> #include <string.h> #include <sstream> #include <stdio.h> //#define mod 1000000007 using namespace std; typedef  long long int ll;  int a[31][31][31][31];  int main() {     int t,n,i,j,k,l;     char s1[32],s2[32],s3[33],s4[33];     cin>>t;     while(t--)     {         cin>>n;         getchar();         for(i=1;i<=n;i++)             cin>>s1[i];         getchar();         for(i=1;i<=n;i++)             cin>>s2[i];         getchar();         for(i=1;i<=n;i++)             cin>>s3[i];         getchar();         for(i=1;i<=n;i++)             cin>>s4[i];         getchar();         for(i=0;i<=n;i++)             for(j=0;j<=n;j++)                 for(k=0;k<=n;k++)                     for(l=0;l<=n;l++)                     {                          if(i==0||j==0||k==0||l==0)                             a[i][j][k][l]=0;                         else if (s1[i]==s2[j] && s2[j]==s3[k] && s3[k]==s4[l])                             a[i][j][k][l]=a[i-1][j-1][k-1][l-1]+1;                         else a[i][j][k][l]=max(max(a[i-1][j][k][l],a[i][j-1][k][l]),max(a[i][j][k-1][l],a[i][j][k][l-1]));                     }         cout<<a[n][n][n][n]<<endl;     } }
#include<bits/stdc++.h> using namespace std; long long int fastread() {long long int t=0; char ch=getchar(); while(ch<33) ch=getchar(); while(ch>33) {t=t*10+ch-'0'; ch=getchar(); } return t; } int main() {  long long int i,j,k,t,n;  t=fastread();  while(t--)  {      n=fastread();      for(i=2,j=1;n!=1;)      {          if(n&1)             j+=i;          i<<=1;          n>>=1;      }      printf("%lld\n",j);  }  return 0; } 
// An easy concept, but using Lucas theorem disturbs me a lot! #include<stdio.h> #include<iostream> #include<vector> using namespace std; #define ll long long #define mod 100003  ll countFact(ll n, ll p) {     ll k=0;     while (n>=p)     {         k+=n/p;         n/=p;     }     return k; }   /* This function calculates (a^b)%MOD */ long long pow(ll a, ll b, ll MOD) {     long long x=1,y=a;      while(b > 0)     {         if(b%2 == 1)         {             x=(x*y);             if(x>MOD) x%=MOD;         }         y = (y*y);         if(y>MOD) y%=MOD;          b /= 2;     }     return x; }   /*  Modular Multiplicative Inverse     Using Euler's Theorem     a^(phi(m)) = 1 (mod m)     a^(-1) = a^(m-2) (mod m) */ long long InverseEuler(ll n,ll MOD) {     return pow(n,MOD-2,MOD); }   long long factMOD(ll n, ll MOD) {     long long res = 1;      while (n > 0)     {         for (ll i=2, m=n%MOD; i<=m; i++)             res = (res * i) % MOD;         if ((n/=MOD)%2 > 0)              res = MOD - res;     }     return res; }   long long C(ll n, ll r, ll MOD) {     if (countFact(n, MOD) > countFact(r, MOD) + countFact(n-r, MOD))         return 0;       return (factMOD(n, MOD) *             ((InverseEuler(factMOD(r, MOD), MOD) *              InverseEuler(factMOD(n-r, MOD), MOD)) % MOD)) % MOD; }  int main() { 	int test;scanf("%d",&test); 	while(test--) 	{ 		ll n,k;scanf("%lld%lld",&n,&k); 		if(k==1) 		{ 			printf("%lld\n",n%mod); 			continue; 		} 		ll ans=0; 		if(n-k-1>=k) 			ans+=C(n-k-1,k,mod); 		if(n-k-1>=k-2) 			ans+=C(n-k-1,k-2,mod); 		if(n-k-1>=k-1) 			ans+=2*C(n-k-1,k-1,mod); 		printf("%lld\n",(ans+mod)%mod); 	} 	return 0; }
#include<iostream> using namespace std; int main() { int n,t; long long arr[100002],dp[100006]; //cin>>t; scanf("%d",&t); while(t--) {   scanf("%d",&n);   for(int i=0;i<n;i++)    scanf("%lld",&arr[i]);   dp[n]=dp[n+1]=0;   for(int i=n-1;i>=0;i--)     dp[i]=max(arr[i]+dp[i+2],dp[i+1]);   //cout<<dp[0]<<endl;   printf("%lld\n",dp[0]); } return 0; } 
 #include<stdio.h> #include<string.h> #include<math.h> #include<stdlib.h>   long long int a[10000+1];  long long special_numbers(int d);    int main() {  int T;  scanf("%d", &T);  while (T--) {  int D;  scanf("%d", &D);  printf("%lld\n", special_numbers(D));  }    return 0;  }    long long special_numbers(int d) {  long long int count;  int i;  a[0]=0;a[1]=9;a[2]=90;a[3]=900;a[4]=8991;  if(d<=3)  return (9*pow(10,d-1));    if(d>=4)  {    for(i=5;i<=d;i++)  {  if(a[i]!=0)  continue;  else  {  count=((a[i-1]-a[i-4]*9)*10+a[i-4]*9*9)%1000000007;  if(count<0)  count=1000000007+count;  a[i]=count;  }  }  return a[d];  }    }
#include <iostream>  using namespace std;  int main() { 	int t; 	int b; 	int d; 	int temp; 	int iter; 	int last; 	int count;  	cin >> t;  	while (t--) { 		cin >> b;  		bool dist[b];  		for (int i = 0; i < b; i++) { 			dist[i] = 0; 		} 		 		iter = 1; 		count = 0; 		for (int i = 0; i < b; i++) { 			if (!dist[i]) { 				dist[i] = true; 				count++; 				last = i; 				d = i + 1;  				while (d < b) { 					temp = iter; 					 					while (temp && d < b) { 						if (!dist[d++]) { 							temp--; 						} 					} 					while (dist[d] && d < b) { 						d++; 					} 					if (!temp && d < b) { 						dist[d] = true; 						count++; 						last = d; 						d++; 					} 				} 				iter++; 			} 			if (count == b) { 				break; 			} 		}  		cout << last + 1 << endl; 	}  	return 0; } 
#include <bits/stdc++.h> #define ll long long int #define s(a) scanf("%lld",&a)  using namespace std;  ll tree[400001]={0}; ll a[200001];  ll update(ll l,ll r,ll node) {     if(l>r) return 0;     if(l==r) {tree[node]=a[l];return tree[node];}     else {ll mid=(l+r)/2;tree[node]=update(l,mid,2*node)+update(mid+1,r,2*node+1);return tree[node];} }  ll query(ll l,ll r,ll node,ll x,ll y) {     if(l>r)return 0;     ll mid=(l+r)/2;     if(y<l||x>r) return 0;     if(l>=x&&r<=y) return tree[node];     return query(l,mid,2*node,x,y)+query(mid+1,r,2*node+1,x,y); }  int main() {     ll n,q,i,x,y,t;     s(t);     while(t--) {     s(n);s(q);     for(i=1;i<=n;i++) {         s(a[i]);     }     x=update(1,n,1);    // for(i=1;i<2*n;i++) cout<<tree[i]<<endl;     while(q--) {         s(x);s(y);         cout<<query(1,n,1,x,y)<<endl;     }     }     return 0; } 
    #include<bits/stdc++.h>     using namespace std;     int main()     {     long int t;     scanf("%ld",&t);     while(t--)     {     long int n;     scanf("%ld",&n);     double p,m,b;     for(long int i=0;i<n;i++)     {     scanf("%lf %lf",&p,&m);     b=p-ceil(((m*p)/100));     printf("%.0lf\n",b);     }     }     return 0;     } 
#include <bits/stdc++.h> #define ll long long int #define s(a) scanf("%lld",&a)  using namespace std;  int main() {     ll t,n,k,i,j,tot;     s(t);     while(t--) {         s(n);s(k);         ll a[101]={0};         a[0]=1;         a[1]=1;         for(i=2;i<=n;i++) {             a[i]=a[i-1];             for(j=2;j<k;j++) {                 if(j>i) break;                 if(__gcd(j,k)>1) continue;                 if(i==j) {a[i]++;continue;}                 a[i]=a[i-j-1]+a[i];             }           //  cout<<a[i]<<endl;         }         cout<<a[n]<<endl;     }     return 0; } 
#include<bits/stdc++.h> using namespace std; #define lli long long int int main(){ 	int n,t; 	cin>>t; 	while(t--){ 		cin>>n; 		int x,tt; 		cin>>x; 		for(int i=1;i<n;i++){ 			cin>>tt; 			x=__gcd(x,tt); 		} 		if(x==1)cout<<n<<"\n"; 		else cout<<"0\n"; 	} 	 	return 0; } 
#include <stdio.h> #include <algorithm>   #define N 100010   using namespace std;   int arr[N]; int n;   int main() { 	scanf("%d", &n); 	for(int i = 0;i < n;i++) { 		scanf("%d", &arr[i]); 	} 	sort(arr, arr+n); 	int ans = 0; 	for(int i = 0, j = 0;j < n;j++) { 		while(i < j && 2*arr[i] < arr[j]) { 			i++; 		} 		if(j-i+1 > ans) {  			ans = j-i+1; 		} 	} 	printf("%d\n", n - ans); 	return 0; } 
#include<iostream> #include<cstdio> #include<algorithm> using namespace std; int main() {      int t,a[110],b[1010],c,n,x,y,d,h=0;     while(scanf("%d",&t)!=EOF)      {             cout<<"suck"<<endl;     }    return 0; }
#include<iostream> #include<algorithm>  bool comp(int a,int b) {      return a>b; }  using namespace std;  int main() {     char buf[10];     int t,i,n,tc=1;     int a[10],b[10],sum;     scanf("%s",buf);     //cout<<buf;     scanf("%d",&t);     //cout<<t;     while(scanf("%d",&n)!=EOF)     {               sum=0;               //scanf("%d",&n);               for(i=0;i<n;i++)               {                   scanf("%d",&a[i]);               }                              for(i=0;i<n;i++)               {                   scanf("%d",&b[i]);               }                              sort(a,a+n);               sort(b,b+n,comp);               for(i=0;i<n;i++)               {                   sum+=(a[i]*b[i]);               }               printf("Case #%d: %d\n",tc++,sum);     }     return 0; }
#include<cstdio> #include<algorithm> #include<iostream> using namespace std; int main() {     int test,count=1;     test=0;int i=1;     scanf("%d",&test);     while(test--)     {                              int fake;                  scanf("%d",&fake);                                    int n;                  scanf("%d",&n);                  int ar1[n],ar2[n];                                    for(int i=0;i<n;i++)                  scanf("%d",&ar1[i]);                                    if(n!=1)                  printf("Case #%d: %d\n",count,ar1[n-1]+(ar1[n-1]-ar1[n-2]));                  else                  printf("Case #%d: I don't know.\n",count);                  count++;     } return 0; }
#include<iostream> #include<cstdio> #include<algorithm> using namespace std; int main() {      int t,a[110],b[1010],c,n,x,y,d,h=0;     while(scanf("%d",&t)!=EOF)      {        for(int j=0;j<1010;j++)        b[j]=0;       cin>>c>>n;        for(int i=0;i<n;i++)       {              cin>>a[i];              b[a[i]]++;             if(b[a[i]]==2)              b[a[i]]--;       }       for(int k=0;k<n;k++)       {              d=c-a[k];              if(d>0)              {                   if(b[d]==1)                   break;              }       }       for(int z=0;z<n;z++)       {            if(d==a[z])            {               x=z;               break;            }       }          for(int z1=0;z1<n;z1++)       {            if((c-d)==a[z1])            {               y=z1;               break;            }       }        if(x==y)        x++;         h++;       cout<<"Case #"<<h<<": "<<min(x,y)+1<<" "<<max(x,y)+1<<endl;     }    return 0; }
#include <iostream> //#include<bits/stdc++.h> using namespace std; int dp[3200][3200];  int fnc(string ss){ 	int l= ss.length(); 	 	for(int i=0;i<l;i++){ 		dp[i][i]=1; 	} 	for(int i=0;i<l-1;i++){ 		if(ss[i]==ss[i+1]){ 			dp[i][i+1]=2; 		} 		else dp[i][i+1]=1; 	} 	 	for(int i=3;i<=l;i++){ 		for(int j=0;j<=l-i;j++){ 			if(ss[j]!=ss[j+i-1]){ 				dp[j][j+i-1]=max(dp[j][i+j-2],dp[j+1][i+j-1]); 			} 			if(ss[j]==ss[j+i-1]){ 				dp[j][i+j-1]=dp[j+1][i+j-2]+2; 			} 			 		} 	} 	int maxx=0; 	for(int i=1;i<l-1;i++){ 		int tp=dp[0][i]*dp[i+1][l-1]; 		if(tp>maxx)maxx=tp; 	} 	return maxx; }   int main() { 	//char ss[100000]; 	string ss; 	cin>>ss; 	cout<<fnc(ss); 	return 0; }
#include <iostream>  int main () { 	int n; 	int k; 	std::cin>>n>>k;  	int *a = new int[n]; 	int sum =0;  	for (int i=0; i<n; i++) 		std::cin>>a[i];  	for (int i=0; i<n-k; i++) 		sum+=(-1*a[i]); 	for (int i=n-k; i<n; i++) 		sum+=a[i];  	std::cout<<sum<<std::endl; 	delete a; 	return 0; }
#include<cstdio> #include<algorithm> using namespace std; #define rep(i,a,b) for(i=a;i<b;i++) #define max(a,b) ((a)<(b) ? (b) : (a)) int a[1000],n; int main() {     int ans = 0,i,j;     scanf("%d",&n);     rep(i,0,n) scanf("%d",&a[i]);     sort(a,a+n);     j = n/2;     if(n&1) {             ans += a[j+1] - a[j-1];             rep(i,j+2,n) ans += 2*a[i];             rep(i,0,j-1) ans -= 2*a[i];             ans += max(a[j]-a[j-1],a[j+1]-a[j]);     }     else {          ans += a[j] - a[j-1];          rep(i,j+1,n) ans += 2*a[i];          rep(i,0,j-1) ans -= 2*a[i];     }     printf("%d",ans);     return 0; } 
#include <iostream> #include <cstdio> #include <string> #include <vector> #include <set> #include <map> #include <queue> #include <cmath> #include <algorithm> #include <sstream> #include <stack> #include <cstring> #include <iomanip> #include <ctime> using namespace std; #define pb push_back #define INF 1000000000 #define FOR(i,n) for(int (i)=0;(i)<(n);++(i)) #define FORI(i,n) for(int (i)=1;(i)<=(n);++(i)) #define mp make_pair #define pii pair<int,int> #define ll long long #define vi vector<int> #define SZ(x) ((int)(x.size())) #define fi first #define se second #define wez(n) int (n); scanf("%d",&(n)); #define wez2(n,m) int (n),(m); scanf("%d %d",&(n),&(m)); #define wez3(n,m,k) int (n),(m),(k); scanf("%d %d %d",&(n),&(m),&(k)); inline void pisz(int n) { printf("%d\n",n); } template<typename T,typename TT> ostream& operator<<(ostream &s,pair<T,TT> t) {return s<<"("<<t.first<<","<<t.second<<")";} template<typename T> ostream& operator<<(ostream &s,vector<T> t){FOR(i,SZ(t))s<<t[i]<<" ";return s; } #define IN(x,y) ((y).find((x))!=(y).end()) #define DBG(vari) cerr<<#vari<<" = "<<(vari)<<endl; #define ALL(t) t.begin(),t.end() #define FOREACH(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++) #define TESTS wez(testow)while(testow--) #define REP(i,a,b) for(int (i)=(a);(i)<=(b);++i) #define REPD(i,a,b) for(int (i)=(a); (i)>=(b);--i) #define REMAX(a,b) (a)=max((a),(b)); #define REMIN(a,b) (a)=min((a),(b)); #define IOS ios_base::sync_with_stdio(0);   #define M (1<<17) int d[2*M+2];   void dodaj (int pos, int ile) {    for (int i = pos + M; i > 0; i >>= 1) {       d[i] += ile;    } }   int kty (int k) { // 1-based    int nr = 1;    while (nr < M) {       if (d[nr] < k) return -1;       if (d[2*nr] >= k) {          nr *= 2;       } else {          k -= d[2*nr];          nr = 2*nr + 1;       }    }    return nr - M; }   // uÅ¼ycie: np. inicjalizacja: /*    wez(n)    FOR(i,2*M) d[i] = 0;    FOR(i,n) scanf("%d",&d[i+M]);    REPD(i,M-1,1) d[i] = d[2*i] + d[2*i+1]; */   int f[100007];   int main () {    vector<pii> v;    int n = 100000;    int ile = n;    FOR(i,2*M) d[i] = 0;    FOR(i,n) d[i+M] = 1;    REPD(i,M-1,1) d[i] = d[2*i] + d[2*i+1];    while (ile > 2) {       int pot2 = 1;       while (pot2 <= ile) pot2 *= 2;       for (pot2 /= 2; pot2 > 0; pot2 /= 2) {          int ktory = kty(pot2);          dodaj(ktory, -1);          ile--;       }       v.pb(mp(1+kty(1), -1));       if (ile >= 2) {          //printf("%d %d\n",tr.find_kth(1),tr.find_kth(2));          v.pb(mp(1+kty(2),1+kty(1)));       }    }        TESTS {       wez(nn)       FORI(i,nn) scanf("%d",f+i);       int pos = 0;       while (pos < SZ(v) && v[pos].fi <= nn) ++pos; --pos;       //DBG(v[pos])       if (nn == 1) {          printf("%d\n",f[1]);       } else if (nn == 2) {          printf("%d %d\n",f[1],f[2]);       } else {          if (v[pos].se == -1) {             printf("%d\n", f[v[pos].fi]);          } else {             printf("%d %d\n", f[v[pos].se], f[v[pos].fi]);          }       }    } }
#include <string> #include <vector> #include <algorithm> #include <cmath> #include <set> #include <queue> #include <map> #include <cstdio> #include <iomanip> #include <sstream> #include <iostream> #include <cstring> #define REP(i,x,v)for(int i=x;i<=v;i++) #define REPD(i,x,v)for(int i=x;i>=v;i--) #define FOR(i,v)for(int i=0;i<v;i++) #define FORE(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++) #define REMIN(x,y) (x)=min((x),(y)) #define REMAX(x,y) (x)=max((x),(y)) #define pb push_back #define sz size() #define mp make_pair #define fi first #define se second #define ll long long #define IN(x,y) ((y).find((x))!=(y).end()) #define un(v) v.erase(unique(ALL(v)),v.end()) #define LOLDBG #ifdef LOLDBG #define DBG(vari) cerr<<#vari<<" = "<<vari<<endl; #define DBG2(v1,v2) cerr<<(v1)<<" - "<<(v2)<<endl; #else #define DBG(vari) #define DBG2(v1,v2) #endif #define CZ(x) scanf("%d",&(x)); #define CZ2(x,y) scanf("%d%d",&(x),&(y)); #define CZ3(x,y,z) scanf("%d%d%d",&(x),&(y),&(z)); #define ALL(x) (x).begin(),(x).end() #define tests int dsdsf;cin>>dsdsf;while(dsdsf--) #define testss int dsdsf;CZ(dsdsf);while(dsdsf--) using namespace std; typedef pair<int,int> pii; typedef vector<int> vi; template<typename T,typename TT> ostream &operator<<(ostream &s,pair<T,TT> t) {return s<<"("<<t.first<<","<<t.second<<")";} template<typename T> ostream &operator<<(ostream &s,vector<T> t){s<<"{";FOR(i,t.size())s<<t[i]<<(i==t.size()-1?"":",");return s<<"}"<<endl; }   #define M (1<<17)   struct ext {     int x;     ext(){x=0;}     inline ext operator+(const ext& A) const     {         ext w;         w.x=x^A.x;         return w;     } };   struct node//node() el neutralny {     int v[4];     node(){v[0]=v[1]=v[2]=v[3]=0;}     inline node operator+(const node& A) const     {         node w;         FOR(i,4) w.v[i]=v[i]+A.v[i];         return w;     }     node extend(ext E)     {         node w;         FOR(i,4) w.v[i]=v[i^E.x];         return w;     } };   node d[2*M]; ext e[2*M]; int A,B; ext V;   node qu(int l,int r,int nr) {     if (A<=l && r<=B) return d[nr];     if (A>r || B<l) return node();     return (qu(l,(l+r)/2,nr*2)+qu((l+r)/2+1,r,nr*2+1)).extend(e[nr]); }   node query(int a,int b) {     A=a;B=b;     return qu(0,M-1,1); }     void md(int l,int r,int nr) {     if (A<=l && r<=B)      {         d[nr]=d[nr].extend(V);         e[nr]=e[nr]+V;         return;     }     if (A>r || B<l) return;     md(l,(l+r)/2,nr*2);md((l+r)/2+1,r,nr*2+1);     d[nr]=(d[nr*2]+d[nr*2+1]).extend(e[nr]); }   void modify(int a,int b,ext val) {     A=a;B=b;V=val;     md(0,M-1,1); }   void czysc() {     FOR(i,2*M) d[i]=node();     FOR(i,2*M) e[i]=ext(); }   void bulk() {     REPD(i,M-1,1) d[i]=(d[i*2]+d[i*2+1]); }       int main() {     ios_base::sync_with_stdio(0);     int n;CZ(n);     czysc();     FOR(i,n)     {         int a;CZ(a);         d[M+i].v[a]=1;     }     bulk();     int q;CZ(q);     node tp;     ext f;     while(q--)     {         int a,b,c;         CZ3(a,b,c);         b--;c--;         if (a==0)         {             tp=query(b,c);             printf("%d %d %d %d\n",tp.v[1],tp.v[3],tp.v[0],tp.v[2]);         }         else         {             f.x=a;             modify(b,c,f);         }     }       return 0; }  
#include<cstdio>  using namespace std;  int n,t,f; int main() {       scanf("%d",&t);       while(t--)       {           scanf("%d%d",&n,&f);           if(n==1)           printf("1\n");           else if(f==2)           printf("-1\n");           else           printf("%d\n",3*n/2);       }         return 0; } 
//By Sainath #include<iostream> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {          int n,k;         cin>>n;         cin>>k;         int a[n+1];         int p[n+1];         int f;         for(int i=1;i<=n;i++)         {             cin>>a[i];         }         for(int i=1;i<=n;i++)         {             cin>>f;             p[f]=i;         }         while(k--)         {             int b[n+1];             for(int i=1;i<=n;i++) b[i]=a[i];             for(int i=1;i<=n;i++) a[i]=b[p[i]];         }         for(int i=1;i<=n;i++)         cout<<a[i]<<" ";         cout<<endl;     } } 
#include<algorithm> #include<iostream> #include<cstdio> using namespace std; #define MOD 1000000007  long long int pow2(int x) {     long long int t = 2;     long long int ans = 1;     while(x!=0)     { 	if(x%2) 	    ans = (ans * t) % MOD; 	t = (t*t) % MOD; 	x /= 2;     }     return ans; }  int main() {      int t,n,k,j;     cin>>t;      int a[200001];     while(t--)     {         cin>>n>>k;         for(int i=0;i<n;i++)             scanf("%d",a+i);         long long int ans=0;         j=0;         sort(a,a+n);          for(int i=0;i<n;i++)         {             for(;j<n&&(a[j]<=a[i]+k);j++);                  ans += pow2(j-i-1);                 ans %= MOD;         }         cout<<ans<<endl;      } } 
#include<stdio.h>  template <class T> struct node { 	T value; 	node* next; };  template <class T> class LL {     public:     LL();     void insert(T k);     void remove(T k);     bool search(T k);     node<T>* head;     node<T>* last; };  template <class T> LL<T>::LL() {     head = last = NULL; }  template <class T> void LL<T>::insert(T k) {     node<T>* temp = new node<T>();     temp->value = k;     temp->next = NULL;     if(head) last = last->next = temp;     else head = last = temp; }  template <class T> void LL<T>::remove(T k) {     node<T>* p = NULL;     node<T>* n = head;     while(n)     {         if(n->value == k)         {             if(n == head)             {                 head = n->next;                 if(!head) last = NULL;             }             else             {                 p->next = n->next;                 if(!(p->next)) last = p;             }             delete n;             return;         }         p = n;         n = n->next;     } }  template <class T> bool LL<T>::search(T k) {     node<T>* temp = head;     while(temp)     {         if(temp->value == k) break;         else temp = temp->next;     }     return (temp != NULL); }  #define _MAX_QUEUE_SIZE_ 1000  template <class T> class queue {     public:     queue();     ~queue();     void push(T n);     T pop();     bool isEmpty();     bool isFull();     private:     T* data;     int size;     int head;     int tail;     int filled; };  template <class T> queue<T>::queue() {     size = _MAX_QUEUE_SIZE_;     data = new T[size];     filled = 0;     tail = 0;     head = 0; }  template <class T> queue<T>::~queue() {     delete[] data; }  template <class T> void queue<T>::push(T n) {     try     {         if(filled != size)         {             data[tail++] = n;             filled++;             if(tail == size) tail = 0;             return;         }         throw -1;     }     catch(int e)     {         printf("Exception: Queue is full\n");     } }  template <class T> T queue<T>::pop() {     try     {         if(filled != 0)         {             T temp = data[head++];             filled--;             if(head == size) head = 0;             return temp;         }         throw -1;     }     catch(int e)     {         printf("Exception: Queue is empty\n");     } }  template <class T> bool queue<T>::isEmpty() {     return (filled==0); }  template <class T> bool queue<T>::isFull() {     return (filled==size); }  class FlowEdge {     public:     FlowEdge();     FlowEdge(FlowEdge& E);     FlowEdge(int x, int y, int c);     FlowEdge(int x, int y, int c, int f);     int From();     int To();     int Capacity();     int Flow();     int Other(int w);     int ResidualCapacityTo(int w);     void AddResidualFlowTo(int w, int delta);     FlowEdge& operator= (FlowEdge& E);     bool operator== (FlowEdge& E);     private:     int u;     int v;     int capacity;     int flow; };  FlowEdge::FlowEdge() {     u = -1;     v = -1;     capacity = 0;     flow = 0; }  FlowEdge::FlowEdge(FlowEdge& E) {     u = E.From();     v = E.To();     capacity = E.Capacity();     flow = E.Flow(); }  FlowEdge::FlowEdge(int x, int y, int c) { 	try 	{ 		if(c >= 0) 		{ 			u = x; 			v = y; 			capacity = c; 			flow = 0; 		} 		else throw 1; 	} 	catch(int e) 	{ 		printf("Exception %d: Negative edge capacity\n",e); 	} }  FlowEdge::FlowEdge(int x, int y, int c, int f) { 	try 	{ 		if(c >= 0) 		{ 			u = x; 			v = y; 			capacity = c; 			flow = f; 		} 		else throw 2; 	} 	catch(int e) 	{ 		printf("Exception %d: Negative edge capacity\n",e); 	} }  int FlowEdge::From() { 	return u; }  int FlowEdge::To() {     return v; }  int FlowEdge::Capacity() {     return capacity; }  int FlowEdge::Flow() {     return flow; }  int FlowEdge::Other(int w) { 	try 	{ 		if(w == u) return v; 		else if(w == v) return u; 		else throw 3; 	} 	catch(int e) 	{ 		printf("Exception %d: Illegal endpoint\n",e); 	} }  int FlowEdge::ResidualCapacityTo(int w) { 	try 	{ 		if(w == u) return flow; 		else if(w == v) return capacity-flow; 		else throw 4; 	} 	catch(int e) 	{ 		printf("Exception %d: Illegal endpoint\n",e); 	} }  void FlowEdge::AddResidualFlowTo(int w, int delta) { 	try 	{ 		if(w == u) flow -= delta; 		else if(w == v) flow += delta; 		else throw 5; 	} 	catch(int e) 	{ 		printf("Exception %d: Illegal endpoint\n",e); 	} }  FlowEdge& FlowEdge::operator= (FlowEdge& E) {     u = E.From();     v = E.To();     capacity = E.Capacity();     flow = E.Flow();     return *this; }  bool FlowEdge::operator== (FlowEdge& E) {     return u == E.From() && v == E.To() && capacity == E.Capacity() && flow == E.Flow(); }  class FlowNetwork {     public:     FlowNetwork();     FlowNetwork(int v);     ~FlowNetwork();     void AddEdge(FlowEdge* E);     int V();     int E();     void DFS(int s, bool* Visited);     int FordFulkerson(int s, int t);     protected: 	bool HasAugmentingPath(FlowEdge** &EdgeTo, int s, int t);     private:     int n;     int m;     LL<FlowEdge*>* Vertices; };  FlowNetwork::FlowNetwork() {     n = m = 0; }  FlowNetwork::FlowNetwork(int v) {     n = v;     m = 0;     Vertices = new LL<FlowEdge*>[n]; }  FlowNetwork::~FlowNetwork() {     delete Vertices; }  void FlowNetwork::AddEdge(FlowEdge* E) {     try     {         int u = E->From();         int v = E->To();         if(u<n && v<n)         {             Vertices[u].insert(E);             Vertices[v].insert(E);             m++;             return;         }         throw 1;     }     catch(int e)     {         printf("Exception %d: Invalid Edge\n",e);     } }  int FlowNetwork::V() {     return n; }  int FlowNetwork::E() {     return m; }  bool FlowNetwork::HasAugmentingPath(FlowEdge** &EdgeTo, int s, int t) { 	queue<int> Q; 	bool* Marked = new bool[n];  	for(int i=0; i<n; ++i) Marked[i] = false;  	Q.push(s); 	Marked[s] = true;  	int u,v; 	FlowEdge* e; 	node<FlowEdge*>* iterator;  	while(!Q.isEmpty()) 	{ 		u = Q.pop(); 		iterator = Vertices[u].head; 		while(iterator != NULL) 		{ 			e = iterator->value; 			v = e->Other(u); 			if(e->ResidualCapacityTo(v) > 0) 			{ 				if(!Marked[v]) 				{ 					Marked[v] = true; 					EdgeTo[v] = e; 					Q.push(v); 				} 			} 			iterator = iterator->next; 		} 	}  	bool result = Marked[t];  	delete[] Marked;  	return result; }  void FlowNetwork::DFS(int s, bool* Visited) { 	Visited[s] = true; 	int v;  	FlowEdge* e; 	node<FlowEdge*>* iterator = Vertices[s].head; 	while(iterator != NULL) 	{ 		e = iterator->value; 		v = e->Other(s); 		if(!Visited[v] && e->ResidualCapacityTo(v) > 0) 		{ 			DFS(v,Visited); 		} 		iterator = iterator->next; 	} }  int FlowNetwork::FordFulkerson(int s, int t) { 	FlowEdge** EdgeTo = new FlowEdge*[n]; 	for(int i=0; i<n; ++i) EdgeTo[i] = NULL;  	FlowEdge* ResidualEdge; 	int u,v; 	int bottleneck;  	while(HasAugmentingPath(EdgeTo,s,t)) 	{ 		v = t; 		ResidualEdge = EdgeTo[v]; 		u = ResidualEdge->Other(v); 		bottleneck = ResidualEdge->ResidualCapacityTo(v);  		while(u != s) 		{ 			v = u; 			ResidualEdge = EdgeTo[v]; 			u = ResidualEdge->Other(v); 			if(ResidualEdge->ResidualCapacityTo(v) < bottleneck) 			{ 				bottleneck = ResidualEdge->ResidualCapacityTo(v); 			} 		}  		v = t; 		ResidualEdge = EdgeTo[v]; 		u = ResidualEdge->Other(v); 		ResidualEdge->AddResidualFlowTo(v,bottleneck);  		while(u != s) 		{ 			v = u; 			ResidualEdge = EdgeTo[v]; 			u = ResidualEdge->Other(v); 			ResidualEdge->AddResidualFlowTo(v,bottleneck); 		} 	}  	delete[] EdgeTo;  	bool* Visited = new bool[n]; 	for(int i=0; i<n; ++i) Visited[i] = false;  	DFS(s,Visited);  	int c = s/2;  	int MinCount = 0;  	for(int i=0; i<c; ++i) 	{ 		if(!Visited[i]) MinCount++; 	}  	for(int i=c; i<s; ++i) 	{ 		if(Visited[i]) MinCount++; 	}  	return MinCount; }  int main() { 	//freopen("input1.txt","r",stdin); 	//freopen("output1.txt","w",stdout);  	const int INFINITY = 10000000;  	int N,T,V;  	scanf("%d",&N);  	// Rows from 0 to N-1, Columns from N to 2*N-1, Source at 2*N, Sink at 2*N+1  	V = 2*N+2;  	FlowNetwork FN(V);  	scanf("%d",&T);  	FlowEdge* F; 	int r,c;  	while(T--) 	{ 		scanf("%d%d",&r,&c); 		F = new FlowEdge(r-1,N+c-1,INFINITY); 		FN.AddEdge(F); 	}  	for(int i=0; i<N; ++i) 	{ 		F = new FlowEdge(2*N,i,1); 		FN.AddEdge(F); 		F = new FlowEdge(N+i,2*N+1,1); 		FN.AddEdge(F); 	}  	printf("%d\n",FN.FordFulkerson(2*N,2*N+1));  	return 0; } 
    #include<iostream>     using namespace std;     int main()     {     int t;     long long int n,i;     cin>>t;     while(t--)     {     cin>>n;     long long int a[n+1];     char s[n+1];     cin>>s;     for(i=1;i<=n;i++)     cin>>a[i];     for(i=1;i<=n;i++)     {         if(i!=a[i])        {          char temp=s[i-1];          s[i-1]=s[a[i]-1];          s[a[i]-1]=temp;        }     }        cout<<s<<endl;     }     return 0;     } 
#include<iostream> #include<algorithm> #include<stdio.h> using namespace std;  #define GETCHAR getchar_unlocked inline long long int readInt() { int flag=1; long long int n = 0; char c; while (1) { c=GETCHAR(); if(c>='0'&&c<='9') {n = n * 10 + c - '0';flag=0;} else if(flag!=1) break; } return n; }  long long int n,k; long long int arr[100010]; int solve(long long int n,long long int k){ 	//cout<<"hey"; 	int ans=0; 	sort(arr,arr+n); 	if(arr[1]==0) 	return -1; 	if(arr[n-1]==1 && arr[n-1]<=k) 	return -1; 	if(arr[n-2]==0 &&arr[n-1]<=k) 	return -1; 	if(arr[n-1]>k){ 		for(int i=1;i<n-1;i++) 		{ 			if(arr[i]<=k) 			ans++; 		} 	} 	else { 		long long int maxi=arr[n-1]; 		long long int secondmax=arr[n-2]; 		while(maxi<=k){ 			long long int temp=maxi*secondmax; 			secondmax=maxi; 			maxi=temp; 			ans++; 			//cout<<maxi<<"\n"; 		} 		arr[n-1]=maxi; 		arr[n-2]=secondmax; 		for(int i=1;i<n;i++){ 			if(arr[i]<=k) 			ans++; 		} 	} 	return ans; } int main(){ 	long long int t; 	t=readInt(); 	while(t--){ 		long long int n,k; 		n=readInt(); 		k=readInt(); 		for(int i=0;i<n;i++) 		arr[i]=readInt(); 		printf("%d\n",solve(n,k)); 	} }
#include<bits/stdc++.h> #define block 150 using namespace std; typedef long long ll; ll bit[20011]={0}; ll arr[20011]; vector<pair<pair<ll,ll> ,ll > >v; bool cmp(pair<pair<ll,ll> ,ll> a,pair<pair<ll,ll> ,ll> b) { 	if(a.first.first/block==b.first.first/block) 	{ 		return ((a.first.second/block)<(b.first.second/block)); 	} 	else 	{ 		return ((a.first.first/block)<(b.first.first/block)); 	} } void update(ll ind,ll val) { 	 	while(ind<20011) 	{ 		bit[ind]+=val; 		ind+=(ind&(-ind)); 	} } ll get(ll ind) { 	ll sum=0; 	while(ind) 	{ 		sum+=bit[ind]; 		ind-=(ind&(-ind)); 	} 	return sum; } int main() { 	ll n,i; 	scanf("%lld",&n); 	map<ll,ll>mm; 	mm.clear(); 	ll co=1; 	for(i=0;i<n;i++) 	{ 		scanf("%lld",&arr[i]); 		if(mm.find(arr[i])==mm.end()) 		{ 			mm[arr[i]]=1; 		} 	} 	map<ll,ll>::iterator it; 	for(it=mm.begin();it!=mm.end();it++) 	{ 		it->second = co++; 	} 	for(i=0;i<n;i++) 	{ 		arr[i]=mm[arr[i]]; 	} 	ll q,a,b; 	scanf("%lld",&q); 	ll kk=q; 	i=0; 	while(q--) 	{ 		 		scanf("%lld%lld",&a,&b); 		a--; 		b--; 		v.push_back(make_pair(make_pair(a,b),i)); 		i++; 	} 	q=kk; 	ll l=0; 	ll r=0; 	ll ans=0; 	sort(v.begin(),v.end(),cmp); 	vector<ll>anss; 	anss.clear(); 	for(i=0;i<q;i++) 	{ 		anss.push_back(0); 	} 	 	for(i=0;i<q;i++) 	{ 		//cout<<"ll"<<endl; 		 		a=v[i].first.first; 		b=v[i].first.second; 		//cout<<l<<" "<<r<<endl; 		while(l<a) 		{ 			ans-=get(arr[l]-1); 			update(arr[l],-1); 			l++; 		} 		while(l>a) 		{ 			ans+=get(arr[l-1]-1); 			update(arr[l-1],1); 			l--; 		} 		while(r<=b) 		{ 			ans+=get(20010)-get(arr[r]); 			update(arr[r],1); 			r++; 		} 		while(r>b+1) 		{ 			ans-=get(20010)-get(arr[r-1]); 			update(arr[r-1],-1); 			r--; 		} 		anss[v[i].second]=ans; 	//	cout<<ans<<endl; 	} 	for(i=0;i<q;i++) 	{ 		cout<<anss[i]<<endl; 	} }
#include <bits/stdc++.h> using namespace std; #define MAX 123456 #define MOD 1000000007 typedef unsigned long long LL;  vector<LL> v[MAX]; LL arr[MAX]; bool vis[MAX]; LL ans[MAX]; LL fin = 0;  bool dfs(LL idx){     vis[idx] = true;     LL res1 = 0, res2 = 1;     bool f1 = false;      for(size_t i = 0; i < v[idx].size(); ++i){         LL x = v[idx][i];         if (vis[x]) continue;          bool flag = dfs(x);         f1 |= flag;          LL rep = ans[x];         if (flag) {             res2 = ((res2%MOD) * (rep%MOD))%MOD;         }         else {             LL tmp1 = ((res1%MOD) + (rep%MOD))%MOD;              LL tmp2 = ((res1%MOD) * (rep%MOD))%MOD;             res1 = (tmp1 + tmp2)%MOD;         }     }      LL tmp1 = ((res1%MOD) * (res2%MOD))%MOD;     LL res = ((res2%MOD) + (tmp1%MOD))%MOD;     ans[idx] = res;      fin = (fin + ans[idx])%MOD;     f1 |= (arr[idx] == 1);     vis[idx] = false;     return f1; }  void solve(){     LL n,a,b,m;     memset(arr,0,sizeof(arr));     memset(ans,0,sizeof(ans));     memset(vis,false,sizeof(vis));     fin = 0;     cin >> n;      for(LL i = 0; i <= n; ++i) v[i].clear();     for(LL i = 0; i < n-1; ++i){         cin >> a >> b;         v[a].push_back(b);         v[b].push_back(a);     }     cin >> m;     if (m == 0){         dfs(1);         cout << fin << endl;     }     else {         LL mn = LLONG_MAX;         for(LL i = 0; i < m; ++i)             cin >> a, arr[a] = 1, mn = min(mn,a);         dfs(mn);         cout << ans[mn] << endl;     } }  int main() {     ios_base::sync_with_stdio(0);     LL t;     cin >> t;     while(t--){ solve(); }     return 0; } 
#include<stdio.h> #include<vector> using std::vector;  struct node {     int value[10];     int lazy; };  int GetSize(int n) {     int count = 1;     while(n)     {        n >>= 1;        count++;     }     count = 1<<count;     return count; }  void Init(vector<node>& segment, int index, vector<int>& A, int a, int b) {     if(a > b) return;     segment[index].lazy = 0;     if(a == b)     {         for(int i=0; i<10; ++i) segment[index].value[i] = 0;         segment[index].value[A[a]] = 1;         return;     }     int mid = a + (b-a)/2;     Init(segment, 2*index, A, a, mid);     Init(segment, 2*index+1, A, mid+1, b);     for(int i=0; i<10; ++i) segment[index].value[i] = segment[2*index].value[i] + segment[2*index+1].value[i]; }  void BuildTree(vector<node>& segment, vector<int>& A) {     int n = A.size();     int count = GetSize(n);     segment.resize(count);     Init(segment, 1, A, 0, n-1); }  void LazyUpdate(vector<node>& segment, int index, int left, int right, int a, int b, int v) {     if(segment[index].lazy)     {         int C = segment[index].lazy;         int temp[10];         for(int i=0; i<10; ++i) temp[i] = segment[index].value[i];         for(int i=0; i<10; ++i) segment[index].value[(i+C)%10] = temp[i];         if(left < right)         {             segment[2*index].lazy += segment[index].lazy;             segment[2*index+1].lazy += segment[index].lazy;         }         segment[index].lazy = 0;     }     if(left > right || a > right || b < left) return;     if(a <= left && b >= right)     {         int temp[10];         for(int i=0; i<10; ++i) temp[i] = segment[index].value[i];         for(int i=0; i<10; ++i) segment[index].value[(i+v)%10] = temp[i];         if(left < right)         {             segment[2*index].lazy += v;             segment[2*index+1].lazy += v;         }         return;     }     int mid = left + (right-left)/2;     LazyUpdate(segment, 2*index, left, mid, a, b, v);     LazyUpdate(segment, 2*index+1, mid+1, right, a, b, v);     for(int i=0; i<10; ++i) segment[index].value[i] = segment[2*index].value[i] + segment[2*index+1].value[i]; }  int primes[] = {2,3,5,7};  int LazyQuery(vector<node>& segment, int index, int left, int right, int a, int b) {     if(left > right || a > right || b < left) return 0;     if(segment[index].lazy)     {         int C = segment[index].lazy;         int temp[10];         for(int i=0; i<10; ++i) temp[i] = segment[index].value[i];         for(int i=0; i<10; ++i) segment[index].value[(i+C)%10] = temp[i];         if(left < right)         {             segment[2*index].lazy += segment[index].lazy;             segment[2*index+1].lazy += segment[index].lazy;         }         segment[index].lazy = 0;     }     if(a <= left && b >= right)     {         int ans = 0;         for(int i=0; i<4; ++i) ans += segment[index].value[primes[i]];         return ans;     }     int mid = left + (right-left)/2;     return LazyQuery(segment, 2*index, left, mid, a, b) + LazyQuery(segment, 2*index+1, mid+1, right, a, b); }  const int MaxN = 100000+5; int N; vector<int> AdjList[MaxN]; int subtree[MaxN]; int parent[MaxN]; int depth[MaxN]; vector<int> chains[MaxN]; int chainID[MaxN]; int position[MaxN]; int firstv[MaxN]; int size[MaxN]; int cost[MaxN]; bool explored[MaxN]; vector<node> segment[MaxN]; int cid;  void DFS(int v, int d) {     subtree[v] = 1;     depth[v] = d;     for(vector<int>::iterator it=AdjList[v].begin(); it != AdjList[v].end(); ++it)     {         int o = *it;         if(parent[o] == -1)         {             parent[o] = v;                         DFS(o,d+1);             subtree[v] += subtree[o];         }     } }  void FloodFill(int v, int id) {     position[v] = chains[id].size();     chains[id].push_back(v);     firstv[v] = chains[id][0];     chainID[v] = id;     explored[v] = true;     for(vector<int>::iterator it=AdjList[v].begin(); it != AdjList[v].end(); ++it)     {         int o = *it;         if(parent[o] == v && 2*subtree[o] >= subtree[v])         {             FloodFill(o, id);             break;         }     }     size[v] = chains[id].size(); }  void HeavyLightDecomposition() {     for(int i=1; i<=N; ++i) parent[i] = -1;     parent[1] = 0;     DFS(1, 0);     parent[1] = -1;     for(int i=1; i<=N; ++i) explored[i] = false;     cid = 0;     for(int i=1; i<=N; ++i)     {         if(!explored[i] && ((i == 1) || (2*subtree[i] < subtree[parent[i]])))         {             FloodFill(i, cid);             cid++;         }     }     for(int i=0; i<cid; ++i)     {         vector<int> A;         for(int j=0; j<chains[i].size(); ++j) A.push_back(cost[chains[i][j]]);         BuildTree(segment[i], A);     } }  int LCA(int a, int b) {     while(chainID[a] != chainID[b])     {         if(depth[firstv[a]] > depth[firstv[b]]) a = parent[firstv[a]];         else b = parent[firstv[b]];     }     return (depth[a] <= depth[b]) ? a : b; }  int Dist(int lca, int a) {     int ans = 0;     while(chainID[a] != chainID[lca])     {         ans += LazyQuery(segment[chainID[a]], 1, 0, size[a]-1, 0, position[a]);         a = parent[firstv[a]];     }     ans += LazyQuery(segment[chainID[lca]], 1, 0, size[lca]-1, position[lca], position[a]);     return ans; }  int Query(int A, int B) {     int lca = LCA(A,B);     return Dist(lca, A) + Dist(lca, B) - LazyQuery(segment[chainID[lca]], 1, 0, size[lca]-1, position[lca], position[lca]); }  void Change(int lca, int a, int C) {     while(chainID[a] != chainID[lca])     {         LazyUpdate(segment[chainID[a]], 1, 0, size[a]-1, 0, position[a], C);         a = parent[firstv[a]];     }     LazyUpdate(segment[chainID[lca]], 1, 0, size[lca]-1, position[lca], position[a], C); }  void Update(int A, int B, int C) {     int lca = LCA(A,B);     Change(lca, A, C);     Change(lca, B, C);     LazyUpdate(segment[chainID[lca]], 1, 0, size[lca]-1, position[lca], position[lca], 10 - C); }  int main() {     //freopen("test.txt","r",stdin);     //freopen("output.txt","w",stdout);     int u,v,T,A,B,C;     int str;     scanf("%d",&N);     for(int i=1; i<=N; ++i) scanf("%d",&cost[i]);     for(int i=1; i<N; ++i)     {         scanf("%d%d",&u,&v);         AdjList[u].push_back(v);         AdjList[v].push_back(u);     }     HeavyLightDecomposition();     scanf("%d",&T);     while(T--)     {         scanf("%d%d%d",&str,&A,&B);         if(str == 0) printf("%d\n", Query(A,B));         else         {             scanf("%d",&C);             Update(A,B,C%10);         }     }     return 0; } 
#include<bits/stdc++.h>  // Isme kya hai ;)  using namespace std;  #define TRACE  #ifdef TRACE     #define trace1(x)                cerr << #x << ": " << x << endl;     #define trace2(x, y)             cerr << #x << ": " << x << " | " << #y << ": " << y << endl;     #define trace3(x, y, z)          cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl;     #define trace4(a, b, c, d)       cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << endl;     #define trace5(a, b, c, d, e)    cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << endl;     #define trace6(a, b, c, d, e, f) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << " | " << #f << ": " << f << endl;  #else      #define trace1(x)     #define trace2(x, y)     #define trace3(x, y, z)     #define trace4(a, b, c, d)     #define trace5(a, b, c, d, e)     #define trace6(a, b, c, d, e, f)  #endif  #define ull unsigned long long #define ll long long #define Max(x,y) ((x)>(y)?(x):(y)) #define Min(x,y) ((x)<(y)?(x):(y)) #define Sl(x) scanf("%lld",&x) #define Su(x) scanf("%llu",&x) #define all(v) v.begin(),v.end() #define allr(v) v.rbegin(),v.rend() #define S(x) scanf("%d",&x) #define I(x) cin>>x #define IS(x) getline(cin,x) #define pii pair<int,int> #define pll pair<ll,ll> #define mii map<int,int> #define pps pair<ll,pll> #define ppi pair<pii,int> #define ppf pair<pll,ll> #define psi pair<string,int> #define pis pair<int,string> #define fr first #define se second #define p(x) cout<<(x) #define MOD 1000000007 #define eps 1e-7 #define V(x) vector<x> #define pb(x) push_back(x) #define mem(x,i) memset(x,i,sizeof(x)) #define fori(i,s,n) for(int i=(s);i<(n);i++) #define ford(i,s,n) for(int i=(n)-1;i>=(s);--i) #define INF 8944674407370955161LL #define debug(i,st,arr) fori(i,0,st){cout<<arr[i]<<" ";}cout<<endl; #define forci(i,sw) for((i)=(sw).begin();(i)!=(sw).end();(i)++) #define forcd(i,sw) for((i)=(sw).rbegin();(i)!=(sw).rend();(i)++)  int abs(int x) {if(x < 0) return -x; return x;}  int addmod(int v1, int v2) {     int v3 = v1+v2;     if(v3 >= MOD) v3 -= MOD;     return v3; }  int cc[201][201]; int a[13]; int dp[12][1000005]; int ar[20];  void pre() {     ar[0] = 1;      fori(i,1,13) {         ar[i] = 3*ar[i-1];     } }  int bit(int mask, int pos) {     return (mask/ar[pos])%3; }  int f(vector<int> v1, vector<int> v2) {     int ans = 0;     fori(i,0,v1.size()) {         fori(j,0,v2.size()) {             ans += cc[v1[i]][v2[j]];         }     }     return ans; }  int solve(int pos, int mask, int k) {     if(pos == k) {         V(int) v1, v2;         fori(i,0,k) {             if(bit(mask,i) == 1) {                 v1.pb(a[i]);             }             else {                 v2.pb(a[i]);             }         }         return f(v1,v2);     }     if(dp[pos][mask] != -1) return dp[pos][mask];     int ans;     if(pos%2 == 0) {         ans = 0;         fori(i,0,k) {             if(bit(mask,i) == 0) {                 ans = max(ans, solve(pos+1, mask+2*ar[i], k));             }         }     }     else {         ans = 10000000;         fori(i,0,k) {             if(bit(mask,i) == 0) {                 ans = min(ans, solve(pos+1, mask+ar[i], k));             }         }     }     return dp[pos][mask] = ans; }  int main() { //    freopen("input.in", "r", stdin); //    freopen("output.in", "w", stdout);     int n, m, k;     S(n), S(m), S(k);     pre();     mem(dp, -1);     int x, y, z;     fori(i,0,n) fori(j,0,n) cc[i][j] = 99999999;     fori(i,0,m) {         S(x), S(y), S(z);         x--, y--;         cc[x][y] = cc[y][x] = z;     }     fori(i,0,k) S(a[i]), a[i]--;     fori(k,0,n) fori(i,0,n) fori(j,0,n) cc[i][j] = min(cc[i][j], cc[i][k] + cc[k][j]);      p(solve(0, 0, k)), p(endl);     return 0; }  
#include<stdio.h> main() { 	char s[100001],a; 	int  an[123]={0},i,count,max,ans; 	scanf("%s",s); 	i=0; 	while(s[i]!='\0') 	{a=s[i],count=0; 		while(s[i]==a){ 			count++; 			i++; 		} 		if(count>an[a]) 		an[a]=count; 	}max=-1; 	for(i=97;i<=122;i++) 	if(an[i]>max) 	max=an[i],ans=i; 	printf("%c\n%d",ans,max); 	 }
#include <iostream> #include <cstring> #include <cmath> #include <cstdio> #include <climits> #include <ctime> #include <cassert> #include <cctype> #include <algorithm> #include <numeric> #include <map> #include <set> #include <queue> #include <string> #include <vector> #include <bitset>  #define MN 100005 #define MX 35 #define X first #define Y second #define pb push_back #define bit(x) (1LL << (x)) #define bnum(x) (__builtin_popcount(x)) #define sqr(x) ((x) * (x)) #define sz(x) ((int)(x.size())) #define PQ priority_queue  using namespace std; typedef long long LL; typedef double DB; typedef pair<LL, LL> pLL; typedef vector<int> vi;  template <class T> inline void chkmin(T &a, T b) { 	if (b < a) a = b; } template <class T> inline void chkmax(T &a, T b) { 	if (a < b) a = b; }  vi con[MN]; LL M; int n, m, K, X; LL a[MN]; int mrk[MN]; int pw[MX]; LL pwc[MX];  void input() { 	int i, u, v;  	scanf("%d%d%d", &n, &m, &K); 	for (i = 0; i < m; i++) { 		scanf("%d%d", &u, &v); 		u--, v--; 		con[u].pb(v); 		con[v].pb(u); 	} 	for (i = 0; i < n; i++) scanf("%lld", a + i); 	for (i = 0; i < K; i++) { 		scanf("%d", pw + i); 		pw[i]--; 		mrk[pw[i]] = i + 1; 	} 	for (i = 0; i < K; i++) scanf("%lld", pwc + i);  	scanf("%d%lld", &X, &M); 	for (i = 0; i < X; i++) { 		scanf("%d", &u); 		M += pwc[u - 1]; 	} }  int q[MN * 2], chk[MN]; pLL p[MX]; int pn;  bool cmp(const pLL &a, const pLL &b) { 	return 1.0 * a.X / a.Y > 1.0 * b.X / b.Y; }  LL sum[MX], sumc[MX]; void prepare() { 	LL cst, tot; 	int i, j, u, v; 	int st, en, flg;  	for (i = 0; i < n; i++) if (!chk[i]) { 		flg = st = en = 0; 		tot = 0; 		q[en++] = i; 		chk[i] = 1;  		while (st < en) { 			u = q[st++]; 			tot += a[u]; 			if (mrk[u] > 0) { 				if (flg == 0) flg = 1, cst = pwc[mrk[u] - 1]; 				else chkmin(cst, pwc[mrk[u] - 1]); 			}  			for (j = 0; j < sz(con[u]); j++) { 				v = con[u][j]; 				if (chk[v]) continue; 				chk[v] = 1, q[en++] = v; 			} 		}  		if (!flg) continue; 		if (cst <= M) p[pn++] = pLL(tot, cst); 	} }  LL rlt; void solve(int k, LL cst, LL mm) { 	/*if (sumc[k] <= cst) { 		chkmax(rlt, mm + sum[k]); 		return; 	}*/  	if(k == K+1){ 	    chkmax(rlt, mm ); 	    return ; 	}  	chkmax(rlt, mm); 	if (mm + sum[k] <= rlt) return; 	if (mm + 1.0 * p[k].X / p[k].Y * cst <= rlt) return; 	if (k == pn) return; 	if (cst >= p[k].Y) { 		solve(k + 1, cst - p[k].Y, mm + p[k].X); 	} 	solve(k + 1, cst, mm); }  int main() { //	freopen("in.txt", "r", stdin); //	freopen("out.txt", "w", stdout);  	int i; 	input(); 	prepare(); 	assert(pn <= 31);  	sort(p, p + pn, cmp); 	for (i = pn - 1; i >= 0; i--) { 		sum[i] = sum[i + 1] + p[i].X; 		sumc[i] = sumc[i + 1] + p[i].Y; 	}  	solve(0, M, 0);  	cout << rlt << endl; 	return 0; } 
#include <bits/stdc++.h> using namespace std; int E[600][600],T[600][600],R[600][600],par[700],vis[700]; int num; int bfsAugment(int a,int sink) {     queue<int>Q;     int i;     Q.push(a);     for(i=0;i<num;i++)         vis[i]=0;     int flow=INT_MAX;     bool flag=false;     vis[a]=1;     par[a]=-1;     while(!(Q.empty()))     {         a=Q.front();         Q.pop();         for(i=1;i<num;i++)         {             if(i==a)                 continue;             else             {                 if(E[a][i]>0&&vis[i]==0)                 {                     vis[i]=1;                     Q.push(i);                     par[i]=a;                      if(i==sink)                     {                         flag=true;                         break;                     }                 }              }         }         if(flag)             break;     }     if(flag==false)     {         return 0;     }     a=sink;     while(par[a]!=-1)     {         flow=min(flow,E[par[a]][a]);         a=par[a];     }     a=sink;     while(par[a]!=-1)     {         E[par[a]][a]-=flow;         E[a][par[a]]+=flow;         a=par[a];     }    // cout<<"Returning";     return flow; } int maxflow(int source,int sink) {     int a,ans=0;     while(1)     {         a=bfsAugment(source,sink);      //   cout<<a<<" Flow"<<endl;         if(a<=0)         {             return ans;         }         else         {             ans=ans+a;         }     } } int main() {     int n,m,a,b,c,t,i,j,ans;         scanf("%d %d",&n,&m);         memset(E,0,sizeof(E));         for(i=0;i<m;i++)         {              scanf("%d %d %d",&a,&b,&c);             E[a][b]=c;         }         num=n+1;         for(i=1;i<=n;i++)         {              for(j=1;j<=n;j++)             {                 if(E[i][j]!=0&&E[j][i]!=0)                 {                     E[i][num]=E[i][j];                     E[num][j]=E[i][j];                     E[i][j]=0;                     num++;                 }             }         }         for(i=1;i<num;i++)         {              for(j=1;j<num;j++)             {                T[i][j]=E[i][j];             }         }         scanf("%d",&t);         while(t>0)         {             t--;             scanf("%d %d",&a,&b);             ans=maxflow(a,b);             printf("%d\n",ans);             for(i=1;i<num;i++)             {                  for(j=1;j<num;j++)                 {                     E[i][j]=T[i][j];                 }             }         } } 
#include<stdio.h> #define max(a, b) (((a) >= (b)) ? (a) : (b)) int main(){ 	int t, n, no, m; scanf("%d", &t); 	while(t-- && scanf("%d", &n)){ 		m = 1; 		while(n-- && scanf("%d", &no))	m = max(m, no); 		printf("%d\n", m); 	}		 	return 0; }
#include<stdio.h> #include<iostream>  using namespace std; int main() { 	int a,b,c,d,e,f;  	cin>>a>>b>>c>>d>>e>>f;  	if(((a+b)==(d+e))&&((a+f)==(c+d))) 	{ 		cout<<"Losing"<<endl; 	}  	else 	{ 		cout<<"Winning"<<endl; 	} } 
#include<bits/stdc++.h>  // Isme kya hai ;)  using namespace std;  #define TRACE  #ifdef TRACE     #define trace1(x)                cerr << #x << ": " << x << endl;     #define trace2(x, y)             cerr << #x << ": " << x << " | " << #y << ": " << y << endl;     #define trace3(x, y, z)          cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl;     #define trace4(a, b, c, d)       cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << endl;     #define trace5(a, b, c, d, e)    cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << endl;     #define trace6(a, b, c, d, e, f) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << " | " << #f << ": " << f << endl;  #else      #define trace1(x)     #define trace2(x, y)     #define trace3(x, y, z)     #define trace4(a, b, c, d)     #define trace5(a, b, c, d, e)     #define trace6(a, b, c, d, e, f)  #endif  #define ull unsigned long long #define ll long long #define Max(x,y) ((x)>(y)?(x):(y)) #define Min(x,y) ((x)<(y)?(x):(y)) #define Sl(x) scanf("%lld",&x) #define Su(x) scanf("%llu",&x) #define all(v) v.begin(),v.end() #define allr(v) v.rbegin(),v.rend() #define S(x) scanf("%d",&x) #define I(x) cin>>x #define IS(x) getline(cin,x) #define pii pair<int,int> #define pll pair<ll,ll> #define mii map<int,int> #define pps pair<ll,pll> #define ppi pair<pii,int> #define ppf pair<pll,ll> #define psi pair<string,int> #define pis pair<int,string> #define fr first #define se second #define p(x) cout<<(x) #define MOD 1000000007 #define eps 1e-7 #define V(x) vector<x> #define pb(x) push_back(x) #define mem(x,i) memset(x,i,sizeof(x)) #define fori(i,s,n) for(int i=(s);i<(n);i++) #define ford(i,s,n) for(int i=(n)-1;i>=(s);--i) #define INF 8944674407370955161LL #define debug(i,st,arr) fori(i,0,st){cout<<arr[i]<<" ";}cout<<endl; #define forci(i,sw) for((i)=(sw).begin();(i)!=(sw).end();(i)++) #define forcd(i,sw) for((i)=(sw).rbegin();(i)!=(sw).rend();(i)++)  int abs(int x) {if(x < 0) return -x; return x;}  int addmod(int v1, int v2) {     int v3 = v1+v2;     if(v3 >= MOD) v3 -= MOD;     return v3; }  int cc[100]; ll x, n, m;  ll mul(ll a, ll b) {     ll mod = n;    a %= n;    b %= n;    long double res = a;    res *= b;    ll c = (ll)(res / mod);    a *= b;    a -= c * mod;    a %= mod;    if (a < 0) a += mod;    return a; }  ll pow(ll p1, ll p2) {     if(p2 == 0) return 1;     if(p2 % 2 == 0) {         ll tmp = pow(p1, p2/2);         return mul(tmp, tmp);     }     else {         return (mul(p1,pow(p1,p2-1)));     } }  ll solve(ll p1, ll p2) {     if(p2 == 0) return 1;     if(p2 % 2 == 0) {         ll tmp = (pow(p1,p2) + solve(p1,p2-1));         if(tmp >= n) tmp %= n;         return tmp;     }     else {         ll tmp = pow(p1,p2/2 + 1);         ll tmp2 = solve(p1, p2/2);         tmp2 += mul(tmp, tmp2);         if(tmp2 >= n) tmp2 %= n;         return tmp2;     } }  int main() { //    freopen("input.in", "r", stdin); //    freopen("output.in", "w", stdout);     int t;      S(t);     while(t--) {         Sl(x), Sl(m), Sl(n);         printf("%lld\n", (solve(x,m)));     }      return 0; }  
#include <bits/stdc++.h> using namespace std;  typedef long long ll; typedef unsigned long long ull; typedef vector<int> vi; typedef vector<ll> vll; typedef vector<vi> vvi; typedef pair<int,int> pii; typedef vector<pii > vii; typedef vector<pair<int, pair<int, int> > > viii; typedef pair<ll,ll> pll; typedef vector<string> vs; typedef vector<vii> vvii;  #define pb push_back #define mp make_pair #define X first #define Y second #define MEM(a,b) memset(a,(b),sizeof(a)) #define pr(a) cout<<#a<<" = "<<(a)<<endl #define sz(a) int((a).size()) #define all(a) a.begin(),a.end() #define loop(x,a,b) for(int (x) = (a);(x)<(b);(x)++) #define rep(x,n)   for(int (x)=0;(x)<(n);(x)++) #define tr(c,it) for(typeof((c).begin()) it = (c).begin(); it != (c).end(); it++) #define prc(a) tr(a, it) cout<<*(it)<<" "; cout<<endl #define pra(a,n) for(int i=0; i<(n); i++) cout<<((a)[i])<<" "; cout<<"\n" #define prdd(a,r,c) for(int i=0;i<(r);i++) { for(int j = 0;j<(c);j++) cout<<a[i][j]<<" "; cout<<endl; } cout<<endl;  #define present(c,x) ((c).find(x) != (c).end())  #define cpresent(c,x) (find(all(c),x) != (c).end()) #define ain(a,n) int ((a)[(n)]); for(int i=0; i<(n); i++) cin>>((a)[i])   #define md 30000000007 double miss[1500000],hit[1500000];  ll min(ll a,ll b) {   if(a<b)     return a;   return b; }  int main() {        ios::sync_with_stdio(false);     ll n,t,r;     double p;     cin>>n>>p>>t>>r;               rep(i,1500000)       hit[i] = 0,miss[i] = 0;     hit[1] = (1.0);     miss[1] = 0;      loop(i,1,1500000)     {        if(i - t >=  0)       {         double tmp = (1.0)/pow(i,p);         hit[i] += miss[i-t]*tmp;         miss[i] += miss[i-t] *(1-tmp);       }        if(i - t - r >= 0)       {         double tmp = (1.0)/pow(i,p);         hit[i] += hit[i-t-r]*tmp;         miss[i] += hit[i-t-r] *(1-tmp);       }       if(i == n)         break;     }     double ans = 0;     rep(i,min(n+1,1500000))       ans += hit[i];    printf("%.9lf",ans);      return 0; }  
#include <bits/stdc++.h> using namespace std;  // uzumaki naruto #define TRACE  #ifdef TRACE #define dbgarr(a,n)   cerr << "["; for(int i = 0; i < n; ++i) cerr << a[i] << " ";cerr << "\b]\n"; #define dbg(args...)  {debug,args; cerr<<endl;} #define pause()       cin.get();cin.get();  #else #define dbgarr(a,n) #define dbg(args...) #define pause() #endif  struct debugger {     template<typename T> debugger& operator , (const T& v) {         cerr<<v<<" "; return *this;     } } debug;  template <typename T1, typename T2> inline ostream& operator << (ostream& os, const pair<T1, T2>& p) {     return os << "(" << p.first << ", " << p.second << ")"; }  template<typename T> inline ostream &operator << (ostream & os,const vector<T>& v) {     bool first = true; os << "[";     for (typename vector<T>::const_iterator ii = v.begin(); ii != v.end(); ++ii) {         if(!first) os << ", ";         os << *ii; first = false;     }     return os << "]"; }  #define fr first #define se second #define pb push_back  typedef long long LL; typedef pair<int,int> pii; typedef vector<int> vi;  const LL mod = 1000000007LL; int n,m,x,y;  LL dp1[1005][1005][2]; bool vis1[1005][1005][2];  LL f1(int x,int cnt,int f){     if (cnt == y) return 0;     if (x == m) return 1;     if (vis1[x][cnt][f]) return dp1[x][cnt][f];     vis1[x][cnt][f] = true;      LL ans = 0;     for(int k = 0; k < 2; ++k){         int add = (k == f ? cnt : 0) + 1;         ans = (ans + f1(x+1,add,k))%mod;     }     dp1[x][cnt][f] = ans;     return ans; }  LL fast_pow(LL a,LL b){     LL ans = 1LL;     while(b > 0){         if (b & 1) ans = (ans * a)%mod;         a = (a * a)%mod;         b >>= 1;     }     return ans; }  const int mm2 = (1 << 7); LL dp2[mm2][mm2],tmp[mm2][mm2]; LL con[mm2][mm2];  LL valid(int mask1,int mask2){     for(int i = 0,k; i+y-1 < m; ++i){         for(int co = 0; co < 2; ++co){             for(k = i; k < m; ++k){                 int tx = (mask1 >> k) & 1;                 int ty = (mask2 >> k) & 1;                 if (tx != co or ty != co) break;             }             if (k-i >= y)                 return 0LL;         }     }     return 1LL; }  void mul(LL A[][mm2],LL B[][mm2]){     int sz = (1 << m);     for(int i = 0; i < sz; ++i){         for(int j = 0; j < sz; ++j){             tmp[i][j] = 0;             for(int k = 0; k < sz; ++k)                 tmp[i][j] = (tmp[i][j] + A[i][k]*B[k][j])%mod;         }     }      for(int i = 0; i < sz; ++i){         for(int j = 0; j < sz; ++j)             A[i][j] = tmp[i][j];     } }  void ident(LL A[][mm2]){     int sz = (1 << m);     for(int i = 0; i < sz; ++i){         for(int j = 0; j < sz; ++j)             A[i][j] = (i == j);     } }  void mat_power(int nn){     if (nn == 0){         ident(dp2);         return;     }      mat_power(nn/2);     mul(dp2,dp2);     if (nn&1) mul(dp2,con); }  bool pp[12][64][64]; long long cal[12][64][64];  bool check(int mask1,int mask2,int mask3){     int k;     for(int i = 0; i < m; ++i){         for(int co = 0; co < 2; ++co){             for(k = i; k < m; ++k){                 int t1 = (mask1 >> k) & 1;                 int t2 = (mask2 >> k) & 1;                 int t3 = (mask3 >> k) & 1;                 if (t1 != co) break;                 if (t2 != co) break;                 if (t3 != co) break;             }             if (k-i >= y) return false;         }     }     return true; }  long long f(int idx, int mask1, int mask2) {      if ( idx == n ) return 1;      if ( pp[idx][mask1][mask2] ) return cal[idx][mask1][mask2];      pp[idx][mask1][mask2] = true;      long long ans = 0;      for ( int i = 0; i < (1<<m); i++ ) {          if ( check(mask1,mask2,i) ) {             ans = (ans + f(idx+1, mask2, i))%mod;          }      }      cal[idx][mask1][mask2] = ans;      return ans; }  void get() {     long long ans;     if ( n == 1 ) {          ans = 1<<m;          ans %= mod;     }     else {         ans = 0;         for ( int i = 0; i < (1<<m); i++ ) {           for ( int j = 0; j < (1<<m); j++ ) {               ans = (ans + f(2,i,j))%mod;             }         }     }     cout << ans << endl; }  void solve(){     cin >> n >> m >> x >> y;     if (x == 1){         LL ans = f1(0,0,0);         ans = fast_pow(ans,n);         cout << ans << endl;     }      if (x == 2){         for(int i = 0; i < (1 << m); ++i){             for(int j = 0; j < (1 << m); ++j){                 con[i][j] = valid(i,j);             }         }          mat_power(n-1);         LL ans = 0;         for(int i = 0; i < (1 << m); ++i){             for(int j = 0; j < (1 << m); ++j)                 ans = (ans + dp2[i][j])%mod;         }         cout << ans << endl;     }     if ( x == 3 ) {     	get();     } }  int main() {     ios_base::sync_with_stdio(0);     solve();     return 0; } 
#include<stdio.h> #include<iostream> #include<vector> #define get getchar_unlocked using namespace std; typedef struct _node{ 	int val; 	int idx; }node;  typedef struct elements{ 	node n; 	node parent; 	int zeros; 	vector<int> child; }tree;  int visited[100001]={0}; tree ele[100001]; vector<int> inp[100001];  int val_arr[100001];   int scan() {     int n = 0, s = 1, ch = get();     while (ch < '0' || ch > '9') {         if (ch == '-')             s = -1;         ch = get();     }     while (ch >= '0' && ch <= '9') {         n = (n << 3) + (n << 1) + ch - '0';         ch = get();     }     return (n*s); }  void createTree(int p) { 	ele[p].n.val=val_arr[p]; 	ele[p].n.idx=p; 	int size=inp[p].size(); 	 	 	ele[p].zeros=0; 	if(ele[p].n.val==0) 	ele[p].zeros=1; 	 	 	int i; 	for(i=0;i<size;i++) 	{ 		if(visited[inp[p][i]]==1) 		continue; 		else 		{ 			visited[inp[p][i]]=1; 			ele[p].child.push_back(inp[p][i]); 			ele[inp[p][i]].parent.idx=p; 			createTree(inp[p][i]); 			ele[p].zeros+=ele[inp[p][i]].zeros; 		} 	} }   void printTree(int n) { 	int i; 	for(i=1;i<=n;i++) 	{ 		cout << ele[i].n.val << "\n"; 	} }  int getZero(int x) { 	int count=0,i; 	if(ele[x].n.val==0) 	count=1; 	int size=ele[x].child.size(); 	 	if(size==0) 	return count; 	 	for(i=0;i<size;i++) 	{ 		count+=getZero(ele[x].child[i]); 	} 	return count; }   void increase(int p) { 	ele[p].zeros++; 	int ptemp=ele[p].parent.idx; 	while(ptemp!=-1) 	{ 		ele[ptemp].zeros++; 		ptemp=ele[ptemp].parent.idx; 	} }   void decrease(int p) { 	ele[p].zeros--; 	int ptemp=ele[p].parent.idx; 	while(ptemp!=-1) 	{ 		ele[ptemp].zeros--; 		ptemp=ele[ptemp].parent.idx; 	} }  int main() { 	int N,Q;  	 	N=scan(); 	Q=scan(); 	int i,j; 	int x,y; 	for(i=0;i<N-1;i++) 	{ 		x=scan(); 		y=scan(); 		inp[x].push_back(y); 		inp[y].push_back(x); 	} 	 	for(i=1;i<=N;i++) 	{ 		val_arr[i]=scan();	 	} 	 	 	 	 	visited[1]=1; 	ele[1].parent.idx=-1; 	createTree(1); 	 	char ch; 	int count; 	bool flag=false; 	for(i=0;i<Q;++i) 	{ 		scanf("%c",&ch);	 		if(ch=='Q') 		{ 			x=scan(); 			count=ele[x].zeros; 			printf("%d\n",count); 		} 		else if(ch=='U') 		{ 			x=scan(); 			y=scan(); 			ele[x].n.val+=y; 			if(ele[x].n.val==0 && y!=0) 			increase(x); // increase 			if(ele[x].n.val==y && y!=0) 			decrease(x); // decrease 			 		} 		else 		{ 			i--; 		}  	} 	return 0; }
#pragma warning(disable:4786) #define _CRT_SECURE_NO_WARNINGS #pragma comment(linker, "/stack:16777216") #include <bits/stdc++.h> using namespace std; #define fast ios_base::sync_with_stdio(false); #define endl '\n' #define gc getchar_unlocked #define file freopen("iceparticle.in","r",stdin); #define terminate exit (EXIT_FAILURE) #define os_iterator ostream_iterator<data> screen(cout,endl) #define output(vec) copy(vec.begin(),vec.end(),screen) #define memory(dt,fill,length) memset ((dt),(fill),(length)) #define MAX int(1e9) + 7; #define timer 0  typedef vector<int> vec; typedef vector<vec> vvec; typedef long long ll; typedef vector<ll> vecll; typedef vector<vecll> vvecll; typedef char character; typedef int data; typedef pair<data, data> pint; typedef vector<pint> vpint; typedef float decimal;  inline ll input() { 	 	register int c = gc(); 	ll	x = 0; 	ll 	neg = 0; 	for(; ((c<48 || c>57) && c != '-');  	c = gc()); 	if(c == '-') 	 {  		neg = 1;  		c = gc(); 	 } 	for(; c>47 && c<58 ; c = gc())  			x = (x<<1) + (x<<3) + c - 48; 	return (neg)? 		-x:x; }  inline void process() {  	int t=input(); 	ll n; 	for(;t--;) { 	n=input(); 	if (n==1 || 		n==10|| 		n==100|| 		n==1000|| 		n==10000|| 		n==100000)  	cout << "NO" << endl;  	else  	cout << "YES" << endl; 	} }  int main (int argc, char * const argv[]) { 	 	if(timer) {	 	decimal bios_memsize;  	clock_t execution; 	execution=clock(); 	 	process(); 	bios_memsize=(clock()-execution)/(decimal)CLOCKS_PER_SEC; 	printf("[%.4f] sec\n",bios_memsize); } 	process(); 	 return 0; }  
#include<iostream> using namespace std; int main() { 	unsigned long int t; 	cin>>t; 	while(t--) 	{ 		unsigned long long n,k,q=0; 		cin>>n>>k; 		if(n==1) 			cout<<"1\n"; 		else if(k==1) 			cout<<n<<"\n"; 		else 		{ 			while(n) 			{ 			    q+=int(float(n%k));; 			    n=(n-(int(float(n%k))))/k; 			} 			cout<<q<<"\n"; 		} 	} 	return 0; } 
/* Sahil Prakash */  #include<bits/stdc++.h>  using namespace std;  #define ull unsigned long long #define si(x) scanf("%d",&x) #define sull(x) scanf("%llu",&x) #define sch(x) scanf("%c",&x) #define sstr(s) scanf("%s",s) #define pri(x) printf("%d",x) #define pch(x) printf("%c",x) #define pull(x) printf("%llu",x) #define pstr(s) printf("%s",s) #define nl printf("\n") #define MOD 1000000007  ull power( ull a, ull b ) {     ull res=1;     while(b)     { 	if(b%2) 	    res=((res%MOD)*(a%MOD))%MOD; 	a=((a%MOD)*(a%MOD))%MOD; 	b=b/2;     }     return res; } int main() {     int t;     si(t);     ull n,m,temp1,a,temp2;     while(t--)     { 	temp1=1; 	sull(n); sull(m); 	if(n>2) 	{ 	a=n-2; 	temp1=power(m-2,a); 	temp2=m-1; 	temp1=((temp1%MOD)*(temp2%MOD))%MOD; 	temp1=((m%MOD)*(temp1%MOD))%MOD; 	pull(temp1); 	} 	else 	{ 	    if(n==2) 	    temp1=((m%MOD)*((m-1)%MOD))%MOD; 	    else 	    temp1=m; 	    pull(temp1); 	} 	nl;     }     return 0; } 
#include <stdio.h> #include <string.h> #include <vector> #define lli long long int #define pb push_back  using namespace std;  vector <int> g[105]; lli mat[105][105]; int used[105]; int mt[105];  int kuhn(int node) {     if (used[node]) {         return 0;     }     used[node] = 1;      for (int i = 0; i < (int)g[node].size(); i++) {         int viz = g[node][i];          if (mt[viz] == -1 || kuhn(mt[viz])) {             mt[viz] = node;             return 1;         }     }     return 0; }  int main(void) {     int n, m, k;     lli l, r;     lli mid;     lli best;     int match;      scanf(" %d %d %d", &n, &m, &k);      for (int i = 0; i < n; i++) {         for (int j = 0; j < m; j++) {             scanf(" %lld", &mat[i][j]);         }     }      l = 1;     r = (lli)1e12;     best = r;     while(l <= r) {         for (int i = 0; i < n; i++) {             g[i].clear();         }          mid = (l + r) / 2;         for (int i = 0; i < n; i++) {             for (int j = 0; j < m; j++) {                 if (mat[i][j] <= mid) {                     g[i].pb(j);                 }             }         }          memset(mt, -1, sizeof(mt));         match = 0;         for (int i = 0; i < n; i++) {             memset(used, 0, sizeof(used));             if (kuhn(i)) {                 match++;             }         }          if (match >= k) {             best = mid;             r = mid - 1;         } else {             l = mid + 1;         }     }     printf("%lld\n", best);      return 0; } 
#include<bits/stdc++.h> using namespace std; #define ll long long  int arr[1010][1010];  int num[1000010]={0};  vector<int> edges[1000010];  bool visited[1000010]={false};  int diameter(int i) { 	vector<int> nodes; 	nodes.push_back(i); 	queue<int> bfs; 	bfs.push(i); 	int cnted=0,temp; 	visited[i]=true; 	int last=i; 	while(!bfs.empty()) 	{ 		temp=bfs.front(); 		cnted+=edges[temp].size(); 		last=temp; 		bfs.pop(); 		for(int j=0;j<edges[temp].size();j++) 		{ 			if(!visited[edges[temp][j]]) 			{ 				bfs.push(edges[temp][j]); 				visited[edges[temp][j]]=true; 				nodes.push_back(edges[temp][j]); 			} 		} 	} 	pair<int,int>tempp; 	if(cnted == 2*(nodes.size()-1)) 	{ 		for(int j=0;j<nodes.size();j++)visited[nodes[j]]=false; 		queue<pair<int,int> > bf; 		bf.push(make_pair(last,0)); 		visited[last]=true; 		 		while(!bf.empty()) 		{ 			tempp=bf.front(); 			 			last=tempp.second; 			temp=tempp.first; 			bf.pop(); 			for(int j=0;j<edges[temp].size();j++) 			{ 				if(!visited[edges[temp][j]]) 				{ 					bf.push(make_pair(edges[temp][j],last+1)); 					visited[edges[temp][j]]=true; 					//nodes.push_back(edges[temp][j]); 				} 			} 		} 		//cout<<i<<" "<<nodes.size()<<endl; 		return last; 	} 	//cout<<i<<" "<<nodes.size()<<endl; 	return -1; } int main() { 	 	int n,m; 	scanf("%d%d",&n,&m); 	//cout<<n<<" "<<m<<endl; 	std::map<int,int> mymap;   	std::map<int,int>::iterator it; 	 	int cnt=1; 	//cout<<cnt<<endl; 	for(int i=0;i<n;i++) 	{ 		for(int j=0;j<m;j++) 		{ 			scanf("%d",&arr[i][j]); 			//cout<<arr[i][j]<<" "; 			if(mymap.count(arr[i][j]) > 0) 			{ 				arr[i][j]=mymap[arr[i][j]]; 				num[arr[i][j]]++; 			} 			else 			{ 				mymap[arr[i][j]]=cnt; 				arr[i][j]=cnt; 				num[arr[i][j]]++; 				++cnt; 			} 			//cout<<arr[i][j]<<" "; 		} 		//cout<<endl; 	} 	 	for(int i=0;i<n;i++) 	{ 		for(int j=0;j<m;j++) 		{ 			if(i<n-1) 			{ 				if(arr[i][j]==arr[i+1][j]) 				{ 					edges[i*n+j].push_back(i*n+n+j); 					edges[i*n+n+j].push_back(i*n+j); 					//cout<<i*n+j<<" "<<i*n+n+j<<endl; 				} 			} 			if(j<m-1) 			{ 				if(arr[i][j]==arr[i][j+1]) 				{ 					edges[i*n+j].push_back(i*n+1+j); 					edges[i*n+1+j].push_back(i*n+j); 					//cout<<i*n+j<<" "<<i*n+1+j<<endl; 				} 			} 		} 	} 	 	long long res=1; 	for(int i=0;i<n*m;i++) 	{ 		if(visited[i]==false) 		{ 			 			int temp=diameter(i)+1; 			 			if(temp==0) 			{ 				res=max(res,(long long)num[arr[i/n][i%m]]); 			} 			else res=max(res,(long long)temp); 		} 	} 	cout<<res<<endl; 	 	 	 	 } 
#include<iostream> #include<vector> #include<cmath> #include<cassert> #define ll long long #define ld long double using namespace std; //testing void doit(ll n,ll phi) { 	if(phi == n-1){cout<<n;return;} 	//phi = (p-1) * (q-1) 	//phi=n+1 -p -q 	//p+q = n+1-phi 	ll sum=n+1-phi; 	ll a=1,b=-sum,c=phi+sum-1,ans; 	ans = (sum + (ll)sqrt((ld)sum*(ld)sum - (ld)4 * (ld)c))/2;	 	for(int i=-2;i<=2;++i) 	{ 		if(n%(ans-i)==0) 		{ 			cout<<min(ans-i,n/(ans-i))<<" "<<max(ans-i,n/(ans-i));return; 		} 	} 	//or phi=p*(p-1) 	ans = (1 + (ll)sqrt(1+4*(ld)phi) )/2; 	for(int i=-2;i<=2;++i) 	{ 		if((ans-i)*(ans-i) == n){cout<<ans-i<<" "<<ans-i;return;} 	} 	assert(0); } vector<bool> sieve(2000000,1); int main() { 	for(ll i=2;i<10000;++i) 	{ 		if(sieve[i]) 		{ 			for(ll j=i*i;j<2000000;j+=i) 				sieve[j]=0; 		} 	} 	int t; 	cin>>t; 	for(int q=0;q<t;++q) 	{ 		ll num,phi; 		cin>>num>>phi; 		ll n=num; 		for(int i=2;i<=min(1500000ll,n);++i) 		{ 			if(sieve[i]) 			{ 				int pow=0; 				while(n%i ==0) 				{ 					cout<<i<<" "; 					n/=i; 					pow++; 				} 				if(pow>0) 				{ 					phi/=(i-1); 					for(int q=0;q<pow-1;++q)phi/=i; 				} 			} 		} 		if(n!=1)doit(n,phi); 		cout<<endl; 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {         long long int e,o,sum=0;         cin>>e>>o;         sum=e+o;         if(sum%5==0)         {             cout<<abs(o-(sum/5)*3)<<endl;         }         else             cout<<"-1"<<endl;     }     return 0; } 
#include <bits/stdc++.h> using namespace std; #define infinity (1000000007) #define ll long long #define pii pair<int,int> #define ppi pair<pii,int> #define ppp pair<pii,pii> #define pip pair<int,pii> #define pb push_back #define s(n) scanf("%d",&n) #define s2(n,m) scanf("%d%d",&n,&m) #define s3(n,m,l) scanf("%d%d%d",&n,&m,&l) #define rep(i,n) for(int i=0;i<n;++i) ll pwr(ll a,ll b,ll mod) {ll ans=1; while(b) {if(b&1) ans=(ans*a)%mod; a=(a*a)%mod; b/=2; } return ans; } ll pwr(ll a,ll b) {ll ans=1; while(b) {if(b&1) ans*=a; a*=a; b/=2; } return ans; } ll gcd(ll a,ll b) {while(b) {ll temp=a; a=b; b=temp%b; } return a; } ll lcm(ll a,ll b) {return (a/gcd(a,b))*b; } ll modularInverse(ll a,ll m) {/*reminder: make sure m is prime*/ assert(false); return pwr(a,m-2,m); } const int mod=1000000007;   int sx[300001]; int sy[300001]; int K,L; int f[300001];  map<int,set<pii> > X,Y; int DP[300001]; int dp(int n) {     if(n==1)       return DP[n]=0;     if(DP[n]!=-1)     return DP[n];         int o1=-1e9;     int o2=-1e9;     int x=sx[n];     int y=sy[n];      set<pii>::iterator newY=upper_bound(X[x].begin(),X[x].end(),pii(y,n));     set<pii>::iterator newX=upper_bound(Y[y].begin(),Y[y].end(),pii(x,n));      if(newY!=X[x].end())     {       int idx=(*newY).second;       int dist=abs(y-(*newY).first);        int availFuel=dp(idx)+f[idx];       if(dist<=L && availFuel>=K)         o1=availFuel-K;     }      if(newX!=Y[y].end())     {       int idx=(*newX).second;       int dist=abs(x-(*newX).first);        int availFuel=dp(idx)+f[idx];       if(dist<=L && availFuel>=K)         o2=availFuel-K;     }      return DP[n]=max(o1,o2);  } int main() {   std::ios::sync_with_stdio(false);   int n;     cin>>n>>K>>L;   memset(DP,-1,sizeof DP);   for(int i=1;i<=n;++i)     {       int x,y,z;       cin>>x>>y>>z;       x=-x;       y=-y;       X[x].insert(pii(y,i));       Y[y].insert(pii(x,i));       sx[i]=x;       sy[i]=y;       f[i]=z;     }      // cout<<dp(5)<<endl;   int x=dp(n);    // for(int i=1;i<=n;++i)   // {   //   // if(DP[i]==-1)   //     // DP[i]=-1e9;   //   cout<<i<<" "<<dp(i)<<endl;   // }   if(x<0)   {     cout<<"NO\n";     return 0;   }   cout<<"YES\n";        vector<int> ans;   while(n!=1)   {     ans.pb(n);      int x=sx[n];     int y=sy[n];      set<pii>::iterator newY=upper_bound(X[x].begin(),X[x].end(),pii(y,n));     set<pii>::iterator newX=upper_bound(Y[y].begin(),Y[y].end(),pii(x,n));      if(newY!=X[x].end())     {       int idx=(*newY).second;       int dist=abs(y-(*newY).first);       int availFuel=DP[idx]+f[idx];        if(dist<=L && availFuel>=K)         {           if(availFuel-K==DP[n])             {               n=idx;               continue;             }         }     }       if(newX!=Y[y].end())     {       int idx=(*newX).second;       int dist=abs(x-(*newX).first);       int availFuel=DP[idx]+f[idx];        if(dist<=L && availFuel>=K)         {           if(availFuel-K==DP[n])             {               n=idx;               continue;             }         }     }           assert(false);    }   ans.pb(1);   reverse(ans.begin(),ans.end());   cout<<ans.size()<<"\n";   for(int i=0;i<ans.size();++i)   {     cout<<-sx[ans[i]]<<" "<<-sy[ans[i]]<<"\n";   }    cout<<x<<"\n"; }
#include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<map> #include<set> #include<queue> #include<utility> #include<cstring> #include<cmath> #define LL long long int #define mod 1000000007 #define vi vector<int> #define vvi vector < vi > #define pii pair<int,int> #define all(c) c.begin(),c.end() #define sf(x) scanf("%d",&x); #define sf2(x,y) scanf("%d%d",&x,&y); #define sl(n) scanf("%lld",&n); #define mem(a,val) memset(a,val,sizeof(a)) //#define for<(i,a,b) for(i=a;i<b;i++) //#define for=(i,a,b) for(i=a;i<=b;i++) #define nl printf("\n"); #define pb push_back #define mp make_pair #define f first #define s second using namespace std; int main() {	int t,x,y,n,res,r,size,c,k,i,j,sum,tot,lenx,leny,mat[105][105],dp[105][105][28]={{{0}}}; 	int sum1;	 	char ch; 	sf2(n,res); 	for(i=1;i<=n;i++) 	{	for(j=1;j<=n;j++) 		{	scanf(" %c",&ch); 			mat[i][j]=ch-'A'+1; 		} 	} 	dp[1][1][mat[1][1]]=1; 	// build 1-d mat 	for(c=1;c<=26;c++) 	{	for(j=2;j<=n;j++) 		{	dp[1][j][c]=dp[1][j-1][c]; 			if(mat[1][j]==c) 				dp[1][j][c]+=1; 		} 		for(i=2;i<=n;i++) 		{	dp[i][1][c]=dp[i-1][1][c]; 			if(mat[i][1]==c) 				dp[i][1][c]+=1; 		} 	} 	//build 2-d mat AUB=A+B-AB 	for(c=1;c<=26;c++) 	{	for(i=2;i<=n;i++) 		{	for(j=2;j<=n;j++) 			{	dp[i][j][c]=dp[i-1][j][c]+dp[i][j-1][c]-dp[i-1][j-1][c]; 				if(mat[i][j]==c) 					dp[i][j][c]+=1; 			} 		} 	} 	//debug 	c=2; 	/*for(c=1;c<=26;c++) 	{	for(i=1;i<=n;i++) 		{	for(j=1;j<=n;j++) 				cout<<dp[i][j][c]<<" "; 			nl; 		} 	}*/ 	sum=0;sum1=0; 	//To find all rect nd cal 	for(i=1;i<=n;i++) 	{	for(j=1;j<=n;j++) 		{	for(x=1;x<=i;x++) 			{	for(y=1;y<=j;y++) 				{	tot=0; 					for(c=1;c<=26;c++) 					{	if(dp[i][j][c]-dp[x-1][j][c]-dp[i][y-1][c]+dp[x-1][y-1][c]) 							tot++; 					} 					if(tot<=res) 					{	sum+=j-y+1; 						break; 					} 				}//break from y loop 			} 		} 	} 	//printf("%d\n",sum); 	res--; 	for(i=1;i<=n;i++) 	{	for(j=1;j<=n;j++) 		{	for(x=1;x<=i;x++) 			{	for(y=1;y<=j;y++) 				{	tot=0; 					for(c=1;c<=26;c++) 					{	if(dp[i][j][c]-dp[x-1][j][c]-dp[i][y-1][c]+dp[x-1][y-1][c]) 							tot++; 					} 					if(tot<=res) 					{	sum1+=j-y+1; 						break; 					} 				}//break from y loop 			} 		} 	} 	//printf("%d\n",sum1); 	printf("%d\n",sum-sum1); 	return 0; } 
#include<bits/stdc++.h> using namespace std; #define ll long long   pair<int,int> max_down[200010]; int max_top[200010]={0}; int parent[200010]={0}; bool visited[200010]={false}; vector<int> edges[200010]; long long res=0;  void dfs(int i) { 	visited[i]=true; 	int maxi=0,smaxi=0; 	for(int j=0;j<edges[i].size();j++) 	{ 		//cout<<i<<" "<<edges[i][j]<<"     "; 		if(!visited[edges[i][j]]) 		{ 			parent[edges[i][j]]=i; 			dfs(edges[i][j]); 			if(maxi<(1+max_down[edges[i][j]].first)){smaxi=maxi;maxi=1+max_down[edges[i][j]].first;} 			else if(smaxi<(1+max_down[edges[i][j]].first))smaxi=(1+max_down[edges[i][j]].first); 		} 	} 	max_down[i]=make_pair(maxi,smaxi); 	 	//cout<<1<<" "<<i<<" "<<maxi<<" "<<smaxi<<endl; 	 }  void dfs2(int i) { 	visited[i]=true; 	if(i==1) 	{ 		max_top[i]=0; 		res+=max_down[i].first; 		 	} 	else 	{ 		int par=parent[i]; 		 		int max_res=max_down[i].first,maxtop=1+max_top[par]; 		 		if(max_down[par].first == (1+max_down[i].first )) 		{ 			 			maxtop=max(maxtop,1+max_down[par].second); 		} 		else 		{ 			 			maxtop=max(maxtop,1+max_down[par].first); 		} 		max_top[i]=maxtop; 		max_res=max(max_res,max_top[i]); 		//cout<<i<<" "<<max_top[i]<<" "<<max_res<<endl; 		res+=max_res; 		 	} 	 	for(int j=0;j<edges[i].size();j++) 		{ 			if(!visited[edges[i][j]]) 			{ 				//cout<<i<<" "<<edges[i][j]<<" !!!   "; 				dfs2(edges[i][j]); 				 			} 		} } int main() { 	 	int t; 	cin>>t; 	 	while(t--) 	{ 		int n,te1,te2; 		res=0; 		scanf("%d",&n); 		for(int i=1;i<=n;i++){edges[i].clear();visited[i]=false;} 		 		for(int i=1;i<n;i++) 		{ 			scanf("%d%d",&te1,&te2); 			//cout<<te1<<" "<<te2<<endl; 			edges[te1].push_back(te2); 			edges[te2].push_back(te1); 		} 		 		dfs(1); 		for(int i=1;i<=n;i++){visited[i]=false;} 		dfs2(1); 		double resu=(double)res/(double)n; 		printf("%0.7lf\n",resu); 		 	} } 
#include<bits/stdc++.h> using namespace std; //#define MOD 1000000007 long long int power(long long int x, long long int y,long long int MOD) {     long long int temp;     if( y == 0)        return 1;     temp = power(x, y/2,MOD)%MOD;            if (y%2 == 0)         return (temp*temp)%MOD;     else     {         if(y > 0)             return (((x*temp)%MOD)*temp)%MOD;         else             return ((temp*temp)%MOD)/x;     } }   int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 	long long int k,a,c,d,x=1; 	scanf("%lld %lld",&k,&a); 		if(a==1) 	{ 		x=1; 	 	 	} 	else if(a==2||a==3) 	{ 			x=k; 	 	 	}  	else 	{ 		//a=a-3; 		x=power(k,power(2,a-3,1000000006),1000000007); 		 		  	 	} 		printf("%lld\n",x); 	 	 	}    return 0; }
#include <bits/stdc++.h> using namespace std; #define ull unsigned long long #define ll long long int #define pii pair<int,int> #define pb push_back #define mp make_pair #define F(i,a,n) for(int i=(a);i<(n);++i) #define FF(i,a,n) for(i=(a);i<(n);++i) #define REP(i,a,n) for(i=(a);i<=(n);++i) #define V(x) vector<x> #define Sd(x) scanf("%d",&x) #define Sl(x) scanf("%lld",&x) #define M(x,i) memset(x,i,sizeof(x)) #define all(c) c.begin(), c.end() #define present_mapset(c,x) ((c).find(x) != (c).end()) #define cpresent_vector(c,x) (find(all(c),x) != (c).end()) #define repstl(v)  for( typeof(v.begin()) it = v.begin(); it != v.end(); it++ ) #define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl #define matrix vector< vector<ll> > #define PI acos(-1.0) #define EPS 1e-9 #define F1 first #define S2 second #define Lf 2*r #define Rg 2*r+1 //vector< vector<int> >Matrix(N, vector<int>(M,0)); #define gc getchar_unlocked #define MAXNN 1000010 #define mod 1e9+7  inline void inputfile() { #ifndef ONLINE_JUDGE     freopen("input.in","r",stdin); #endif } inline void cpp_input() {ios_base::sync_with_stdio(false);     cin.tie(NULL);} template <typename T> void scanint(T &x) {     register int c = gc();     x = 0;     int neg = 0;     for(;((c<48 || c>57) && c != '-');c = gc());     if(c=='-') {neg=1;c=gc();}     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}     if(neg) x=-x; } int hash[10000000]; int arr[10000000]; int main() {     inputfile();     cpp_input();   int t,n,m,cnt;   M(arr,0);   M(hash,0);   scanint(n);scanint(m);   F(i,0,n)   {     scanint(t);     arr[t]=1;   }    cnt=0;   F(i,0,m)   {     scanint(t);     if(arr[t]==1 && hash[t]==0)         cnt++;     hash[t]=1;   }   printf("%d\n",cnt );   return 0; } 
#include<iostream> #include<cstdio> #include<cstring> #include<cstdlib> using namespace std;  char score[14]; 	int over,run,wickets,players[13],player1,player2,onbat,nextplayer,out_count=0; 	bool allout; 	int i,j; int main(){  	for(i=0;i<13;i++) 		players[i]=0; 	cin >> over; 	player1=1,player2=2; 	onbat=1; nextplayer=2; wickets=0; allout=false; 	for(i=0;i<over;i++) 	{ 		for(j=0;j<6;j++) 		{ 		    scanf("%s",score);          	if(strcmp(score,"W")==0) 			{ 				if(player1==onbat) 				{ 					player1=++nextplayer; 					onbat=player1; 				} 				else 				{ 					player2=++nextplayer; 					onbat=player2; 				} 				wickets++; 				out_count++; 				if(wickets==10) 				{ 					allout=true; 					break; 				}  			} 			else //if(strcmp(score,"1")==0||strcmp(score,"3")==0||strcmp(score,"5")==0) 			{ 				run=atoi(score); 				if(run <=6){ 				players[onbat]+=run; 				if(run&1)                 { 					if(player1==onbat) 					{ 						onbat=player2; 					} 					else 					{ 						onbat=player1; 					} 				} 				} 			} 		} 		if(allout)         { 			break; 		}             if(player1==onbat)             {                 onbat=player2;             } 		   else 		    {                 onbat=player1; 		    } 	} 	if((out_count==10)||(strcmp(score,"W")==0))        nextplayer--; 	for(i=1;i<=nextplayer;i++)        printf("Player %i %i\n",i,players[i]); 	return 0; } 
#include <bits/stdc++.h> using namespace std; #define ull unsigned long long #define ll long long int #define pii pair<int,int> #define pb push_back #define mp make_pair #define F(i,a,n) for(int i=(a);i<(n);++i) #define FF(i,a,n) for(i=(a);i<(n);++i) #define REP(i,a,n) for(i=(a);i<=(n);++i) #define V(x) vector<x> #define Sd(x) scanf("%d",&x) #define Sl(x) scanf("%lld",&x) #define M(x,i) memset(x,i,sizeof(x)) #define all(c) c.begin(), c.end() #define present_mapset(c,x) ((c).find(x) != (c).end()) #define cpresent_vector(c,x) (find(all(c),x) != (c).end()) #define repstl(v)  for( typeof(v.begin()) it = v.begin(); it != v.end(); it++ ) #define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl #define matrix vector< vector<ll> > #define PI acos(-1.0) #define EPS 1e-9 #define F1 first #define S2 second #define Lf 2*r #define Rg 2*r+1 //vector< vector<int> >Matrix(N, vector<int>(M,0)); #define gc getchar_unlocked #define MAXNN 1000010 #define mod 1e9+7  inline void inputfile() { #ifndef ONLINE_JUDGE     freopen("input.in","r",stdin); #endif } inline void cpp_input() {ios_base::sync_with_stdio(false);     cin.tie(NULL);} template <typename T> void scanint(T &x) {     register int c = gc();     x = 0;     int neg = 0;     for(;((c<48 || c>57) && c != '-');c = gc());     if(c=='-') {neg=1;c=gc();}     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}     if(neg) x=-x; }  //ind -> parent int ind[MAXNN],arr[MAXNN];  inline void func() {      M(ind,-1); }  int find(int x) {     if (ind[x]<0)     return x;     else     return find(ind[x]); }  void Union(int x,int y) {     int xroot,yroot;     xroot=find(x);     yroot=find(y);     if(xroot==yroot)         return;     if(ind[xroot]<=ind[yroot])         {             ind[xroot]+=ind[yroot];             ind[yroot]=xroot;         }     else     {         ind[yroot]+=ind[xroot];         ind[xroot]=yroot;     } } int main() {     inputfile();     cpp_input();   int t,i,n,m,x,y,final,k;   scanint(t);   while(t--){    scanint(n);scanint(m);scanint(k);    func();    while(m--)    {     scanint(x);     scanint(y);     Union(x,y);    }    sort(ind+1,ind+n+1);    final=0;    for(i=1; i<=n && ind[i]<0 && i<=k; i++)    {     final+=ind[i];    }    printf("%d\n",-final);      }   return 0; } 
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #define inf 1000000000 using namespace std;  int n,m,kid1,kid2,numberOfStores; vector<int> stores; int dist[105][105]; int res = inf; struct st { 	int x; 	int y; 	int c; };  struct st s[10050];  void floyd_warshall() { 	for(int i=0;i<105;i++) 		for(int j=0;j<105;j++) 			dist[i][j] = inf; 	for(int i=0;i<n;i++) 		dist[i][i] = 0; 	for(int i=0;i<m;i++) { 		dist[s[i].x][s[i].y] = s[i].c; 		dist[s[i].y][s[i].x] = s[i].c; 	} 	for(int k=0;k<n;k++) 		for(int i=0;i<n;i++) 			for(int j=0;j<n;j++) 				if (dist[i][j] > dist[i][k] + dist[k][j]) 	         		dist[i][j] = dist[i][k] + dist[k][j]; }  int calc(vector<int> a, vector<int> b) { 	int res1 = inf, res2 = inf, temp; 	sort(a.begin(), a.end()); 	sort(b.begin(), b.end()); 	do { 		temp = 0; 		if(a.size()>=1) 			temp = dist[kid1][a[0]]; 		for(int i=1;i<a.size();i++) { 			temp += dist[a[i-1]][a[i]]; 		} 		res1 = min(res1, temp); 	} while(next_permutation(a.begin(), a.end()));  	do { 		temp = 0; 		if(b.size()>=1) 			temp = dist[kid2][b[0]]; 		for(int i=1;i<b.size();i++) { 			temp += dist[b[i-1]][b[i]]; 		} 		res2 = min(res2, temp); 	} while(next_permutation(b.begin(), b.end())); 	return res1 + res2; }  void selectKid() { 	int temp = 1<<numberOfStores; 	//cout<<temp<<endl; 	for(int i=0;i<temp;i++) { 		vector<int> t1; 		vector<int> t2; 		t1.clear(); 		t2.clear(); 		for(int j=0;j<numberOfStores;j++) { 			if(i & 1<<j) { 				t1.push_back(stores[j]); 			} else { 				t2.push_back(stores[j]); 			} 		} 		res = min(res, calc(t1, t2)); 	} }  int main() { 	#ifndef ONLINE_JUDGE 		freopen("input.txt", "r", stdin); 	#endif 	stores.clear(); 	int t1; 	scanf("%d %d", &n, &m); 	for(int i=0;i<m;i++) { 		scanf("%d %d %d", &s[i].x, &s[i].y, &s[i].c); 	} 	floyd_warshall(); 	scanf("%d", &numberOfStores); 	for(int i=0;i<numberOfStores;i++) { 		scanf("%d", &t1); 		stores.push_back(t1); 	} 	scanf("%d %d", &kid1, &kid2); 	selectKid(); 	printf("%d\n", res); 	return 0; }
/* _____________________________________________________________ |  ____  |  |  ____  |  |___   ____|   |  ____  |   |__  __| | |  |  |  |  | |    | |      | |        | |    | |      | |   | |  |  |  |  | |    | |      | |        | |    | |      | |   | |  |__|  |  | |    | |      | |        | |    | |      | |   | |    ____|  | |____| |      | |        | |____| |      | |   | |    \      |  ____  |      | |        |  ____  |      | |   | | |\  \     | |    | |   _  | |        | |    | |      | |   | | | \  \    | |    | |  | \_/ |        | |    | |      | |   | |_|__\__\___|_|____|_|__\_____|________|_|____|_|______|_|___| */ #include<bits/stdc++.h> #define mp make_pair #define pb push_back using namespace std; inline int scan(){     char c = getchar_unlocked();     int x = 0;     while(c<'0'||c>'9'){         c=getchar_unlocked();     }     while(c>='0'&&c<='9'){         x=(x<<1)+(x<<3)+c-'0';         c=getchar_unlocked();     }     return x; } const int N = 2001; const int Z = 21; int t,n,z; int arr[N]; int rnd(int n){ 	if(n%10<5){ 		return n-(n%10); 	} 	return (n+10)-(n%10); } int memoize[N][Z]; int solve(int pos,int left){ 	if(left<0){ 		return 999999999; 	} 	if(pos>n){ 		return 0; 	} 	if(memoize[pos][left]!=-1){ 		return memoize[pos][left]; 	} 	int sum=0; 	int ret=999999999; 	for(int i=pos;i<=n;++i){ 		sum+=arr[i];         ret = min (ret , rnd(sum) + solve(i+1,left-1)); 	} 	return memoize[pos][left]=ret; } int main(){ 	t=1; 	while(t--){ 		memset(memoize,-1,sizeof(int)*N*Z); 		n=scan(),z=scan(); 		for(int i=1;i<=n;++i){ 			arr[i]=scan(); 		} 		int ans = solve(1,z+1); 		printf("%d\n",ans); 	} }
#include<bits/stdc++.h> using namespace std; int ans=INT_MIN; bool flag=false; class graph {     list<int> *adj;     public:      graph(int v)      {          adj=new list<int>[v];      }      void add_edge(int u,int v)      {          adj[u].push_back(v);      }      int dfs(int v,vector<bool>& visited,vector<int>& val)      {          //cout<<v<<"\n";          visited[v]=true;          list<int>::iterator it;          int rval=val[v];          for(it=adj[v].begin();it!=adj[v].end();it++)          {              if(!visited[*it])              {                  rval=min(rval,dfs(*it,visited,val));              }          }          if(!flag)          {              ans=(val[v]-rval);              flag=true;          }          else             ans=max(ans,val[v]-rval);         return rval;      } }; int main() {     int i,n,a,b,root;     scanf("%d",&n);     graph g(n);     vector<int> val(n);     for(i=0;i<n;i++)         scanf("%d",&(val[i]));     for(i=0;i<n;i++)     {         scanf("%d",&b);         a=i;         if(b!=-1)         {             b--;             g.add_edge(b,i);         }         else             root=i;     }     vector<bool> visited(n);     g.dfs(root,visited,val);     printf("%d",ans);     return 0; }
#include<iostream> #include<vector> #include<algorithm> #include<string> #include<sstream> #include<set> using namespace std;  int main(void) { 	int cases,N,K; 	vector<set<int> > p; 	cin>>cases; 	while(cases--) 	{ 		string str; 		cin>>N>>K; 		getline(cin,str); 		p.clear(); 		p.resize(N); 		for ( int i=0; i<K; i++ ) 		{ 			getline(cin,str); 			stringstream s(str);  			int k; 			while(s>>k) 				p[k-1].insert(i); 		} 		sort(p.begin(),p.end()); 		vector<set<int> >::iterator pit=p.begin(),it=pit; 		int count=1; 		for(++it; it!=p.end(); pit=it,++it) 			if(*it!=*pit) 				count++; 		cout<<count<<endl; 	}  } 
#include <bits/stdc++.h> using namespace std;  void solve(){ 	int a[3]; 	cin >> a[0] >> a[1] >> a[2]; 	sort(a,a+3); 	if (a[2] > a[0]+a[1]) 		cout << "Alice\n"; 	else if ((a[1]+a[2]+a[0])%2 == 0) 		cout << "Bob\n"; 	else  		cout << "Alice\n"; }  int main()  { 	ios_base::sync_with_stdio(0); 	int t;cin >> t; 	while(t--){solve();} 	return 0; }
#include<iostream> #include<algorithm> using namespace std;  struct node 	{ 	 int fr; 	 int v; 	};  bool operator<(const node& a,const node& b) 	{ 	 if(a.fr%2==b.fr%2) 		return a.v<b.v; 	 else 		return (a.fr%2==1); 	}   int main() {  int t;   cin>>t;  while(t--) 	{ 	 string s;  	 cin>>s; 	 node S[s.size()]; 	 int C[26]; 	 for(int i=0;i<26;i++) 		C[i]=0; 	 for(int i=0;i<s.size();i++) 		C[s[i]-'a']++; 	  	 for(int i=0;i<s.size();i++) 		{ 		 S[i].fr=C[s[i]-'a']; 		 S[i].v=s[i]; 		} 	 sort(S,S+s.size()); 	  	 for(int i=0;i<s.size();i++) 		cout<<(char)S[i].v; 	 cout<<"\n"; 	}  return 0; } 
#include<cstdio> #include<cstring> #include<cstdlib> #include<iostream> #include<cmath> #include<algorithm> #define ll long long using namespace std; int T,n; char a[1000005]; ll calcu() { 	ll ans=0; 	/*if(n&1)*/ ans=(ll) n*((n-1)/2); 	//else ans=(ll) n*(n/2-1); 	if(n%3==0) ans-=n/3*2; 	return ans; } ll del() { 	ll ans; 	if(n%2==1) 	   {int s1=0,i,s0=0; 	    for(i=0;i<n;i++) 	       {if(a[i]=='0') s0++; 		    else s1++; 		   } 		ans=(ll)s1*s0*3; 		if(n%3==0) 		   {s1=n/3; s0=n/3*2; 			for(i=0;i<n;i++) 		       {if(a[i]!=a[(i+s1)%n]) ans--; 			    if(a[i]!=a[(i+s0)%n]) ans--; 			   } 		   } 		return ans/2; 	   } 	else 	   {int i,s00=0,s01=0,s10=0,s11=0; 		for(i=0;i<n;i+=2) 		   {if(a[i]=='0') s00++; 		    else s01++; 		   } 		for(i=1;i<n;i+=2) 		   {if(a[i]=='0') s10++; 		    else s11++; 		   } 		ans=(ll)s00*s11*2; ans+=(ll)s01*s10*2; 		ans+=(ll)s00*s01*4; ans+=(ll)s10*s11*4; 		int n1,n2; 		n1=n/2; 		for(i=0;i<n;i++) 		   {if(a[i]!=a[(i+n1)%n]) ans--;} 		if(n%3==0) 		   {int s1=n/3,s0=n/3*2; 			for(i=0;i<n;i++) 		       {if(a[i]!=a[(i+s1)%n]) ans--; 			    if(a[i]!=a[(i+s0)%n]) ans--; 			   } 		   } 		return ans/2; 	   } } int main() { 	scanf("%d",&T); 	int k; 	for(k=1;k<=T;k++) 	   {scanf("%s",a); n=strlen(a); 		printf("Case %d: %lld\n",k,calcu()-del()); 	   } 	return 0; }
#include <bits/stdc++.h> using namespace std; #define ll long long #define lim 100000 #define pb push_back #define mp make_pair #define INF 1e18 ll n,m; ll a[501][501],ans[501][501]; ll getans( ll i,ll j) {    if(i==n+1)         return 0;       if(j<1||j>m)         return INF;            if(ans[i][j]!=INF)         return ans[i][j];       ans[i][j]=min(ans[i][j],a[i][j]+getans(i+1,j-1));       ans[i][j]=min(ans[i][j],a[i][j]+getans(i+1,j));       ans[i][j]=min(ans[i][j],a[i][j]+getans(i+1,j+1));       return ans[i][j]; }  int main() {     // freopen("input.txt","r",stdin);      ll t;      ll tt;            cin>>tt;      while(tt--)      {         cin>>t;         cin>>n>>m;                  for(ll i=1;i<=n;i++)             for(ll j=1;j<=m;j++)             {                 ans[i][j]=INF;                 cin>>a[i][j];             }             ll mn=INF;             for(ll i=1;i<=m;i++)             {                                  mn=min(mn,getans(1LL,i));             }             if(mn>=t)                 cout<<"NO"<<endl;             else cout<<"YES"<<endl;       }   } 
#include <bits/stdc++.h> using namespace std; #define ll long long #define lim 100000 #define pb push_back #define mp make_pair #define INF 100000 #define epsilon 1e-5 double n,m; double a[101]; double ann; ll cut; bool eq(double q,double w) {    q-=w;    if(q>-epsilon&&q<epsilon)     return true; return false; } void getans(ll per,ll i,double cap) {      //cout<<per<<" "<<i<<"   "<<a[i]<<"  "<<cap<<endl;     if(per==m)     return ;          if(eq(cap,a[i]))     {         return getans(per+1,i+1,ann);     }     else if(cap<a[i])     {         a[i]-=cap;         cut++;         //cout<<"sahdn"<<i<<endl;         return getans(per+1,i,ann);     }     else     {         return getans(per,i+1,cap-a[i]);     }  } int main() {      //freopen("input.txt","r",stdin);            int t;      cin>>t;      while(t--)      {          cin>>n>>m;          cut=0;          for(ll i=1;i<=n;i++)             a[i]=(double)INF;          ann=n/m;          ann*=INF;         getans(1LL,1LL,ann);         cout<<cut<<endl;       }   } 
#include <bits/stdc++.h> using namespace std; #define ll long long #define lim 100000 #define pb push_back #define mp make_pair #define INF 100000 #define epsilon 1e-5 bool cmp(pair<ll,ll>a,pair<ll,ll>b) {     if(a.first==b.first)     {         return a.second>b.second;     }     return a.first<b.first; }   ll n,k; vector< pair<ll,ll> >a[7]; vector<pair<ll,ll> >b[7]; ll ans[7]; void enhance() {     ll mn=1e18,indi,sum=0;     for(ll i=1;i<7;i++)     {     sum+=b[i][ans[i]].first;         if(b[i][ans[i]].second<mn)         {             mn=b[i][ans[i]].second;             indi=i;         }     }     if(ans[indi]==b[indi].size()-1)         return;      sum+=b[indi][ans[indi]+1].first-b[indi][ans[indi]].first;      if(sum>k)         return ;     ans[indi]++;     enhance(); } int main() { ll price,val,type;    //freopen("input.txt","r",stdin);     cin>>n>>k;           for(ll i=1;i<=n;i++)     {         cin>>type>>price>>val;         a[type].push_back(make_pair(price,val));     }     for(ll i=1;i<7;i++)         sort(a[i].begin(),a[i].end(),cmp);     pair<ll,ll>temp;     for(ll i=1;i<7;i++)     {     temp.first=a[i][0].first;           temp.second=a[i][0].second;           b[i].push_back(temp);         for(ll j=1;j<a[i].size();j++)         {             if(a[i][j].first==temp.first)                 continue;             if(a[i][j].second<temp.second)                 continue;             temp.first=a[i][j].first;           temp.second=a[i][j].second;           b[i].push_back(temp);         }     }     // for(ll i=1;i<7;i++)     //     {    cout<<"newe "<<i<<endl;     //         for(ll j=0;j<b[i].size();j++)     //     {     //         cout<<b[i][j].first<<" "<<b[i][j].second<<endl;     //     }     //     cout<<endl;     // }          ll sum=0;       for(ll i=1;i<7;i++)       {         ans[i]=0;         if(b[i].size()==0)         {             cout<<"0"<<endl;             return 0;         }         sum+=b[i][0].first;       }       if(sum>k)       {         cout<<"0"<<endl;             return 0;       }       enhance();       ll mn=1e18;       for(ll i=1;i<7;i++)       {         mn=min(b[i][ans[i]].second,mn);       }       cout<<mn<<endl;    } 
#include <bits/stdc++.h> using namespace std; #define ll long long #define lim 100000 #define pb push_back #define mp make_pair #define sd(n) scanf("%lld",&n)  ll a[100+1][100+1];  ll n,m; int main() {      ll curr=0,x;   // freopen("input.txt","r",stdin);     cin>>n>>m;     for(ll i=1;i<=n;i++)         for(ll j=1;j<=n;j++)             cin>>a[i][j];         while(m--)         {             cin>>x;             x%=360;                              if(x==270)               {                 for(ll j=n;j>=1;j--)                     {                         for(ll i=1;i<=n;i++)                             cout<<a[i][j]<<" ";                         cout<<endl;                     }                }               else if(x==180)               {                 for(ll i=n;i>=1;i--)                 {                     for(ll j=n;j>=1;j--)                         cout<<a[i][j]<<" ";                     cout<<endl;                                          }               }               else if(x==90)               {                 for(ll j=1;j<=n;j++)                 {                     for(ll i=n;i>=1;i--)                         cout<<a[i][j]<<" ";                     cout<<endl;                  }               }               else               {                 for(ll i=1;i<=n;i++)                 {                     for(ll j=1;j<=n;j++)                         cout<<a[i][j]<<" ";                     cout<<endl;                 }               }               cout<<endl;         }   } 
#include<stdio.h>  int generate(int,int,int,bool);  int **arr;  int main() {   int n,i,val=1,j,l,m,**brr;   bool flag=false;      scanf("%d",&n);      arr=new int*[n+1];   brr=new int*[n+1];      for(i=0;i<=n;i++)   {     arr[i]=new int[n+1];     brr[i]=new int[n+1];   }      for(i=n,j=1;i>=1;i-=2,j++)     val=generate(i,j,val,flag=!flag);            /*if(n%2!=0)   {     for(i=1;i<=n;i++)     {       for(j=1;j<=n;j++)       {       brr[i][n-j+1]=arr[i][j];       }     }        for(i=n;i>=1;i--)     {       for(j=1;j<=n;j++) 	printf("%5d ",brr[i][j]);       printf("\n");     }   }      else   {*/     for(i=1;i<=n;i++)     {       for(j=1;j<=n;j++) 	printf("%5d ",arr[i][j]);       printf("\n");     }   //}      return 0; }           int generate(int n,int start,int val,bool flag) {   int i;      if(flag==true)   {     for(i=start;i<start+n;i++)//first row       arr[start][i]=val++;        for(i=start+1;i<start+n;i++)//last column       arr[i][start+n-1]=val++;        for(i=start+n-2;i>=start;i--)//last row       arr[start+n-1][i]=val++;       for(i=start+n-2;i>=start+1;i--)//first column     arr[i][start]=val++;   }       else   {     for(i=start;i<start+n;i++)//first row       arr[i][start]=val++;        for(i=start+1;i<start+n;i++)//last column       arr[start+n-1][i]=val++;        for(i=start+n-2;i>=start;i--)//last row       arr[i][start+n-1]=val++;       for(i=start+n-2;i>=start+1;i--)//first column       arr[start][i]=val++;   }      return val; }
#include<iostream> #include<cstdio>  using namespace std;  long long count; int size;  void merge(int a[],int beg,int mid,int end) { 	int b[size]; 	int i,j,k; 	for(i=beg,j=mid+1,k=0;i<=mid||j<=end;k++) 	{ 		if(j>end||(a[i]<a[j]&&i<=mid)) 			b[k]=a[i++]; 		else	 		{ 			b[k]=a[j++]; 			count+=(mid-i+1); 		} 	} 	for(i=beg,k=0;i<=end;i++,k++) 		a[i]=b[k]; //	cout<<count<<"("<<beg<<","<<end<<") "; }  void msort(int a[],int beg,int end) { 	if(end-beg) 	{ 		int mid=(beg+end)/2; 		msort(a,beg,mid); 		msort(a,mid+1,end); 		merge(a,beg,mid,end); 	} }  int main() { 	int n; 	cin>>n; 	count=0; 	int a[n]; 	size = n; 	for(int i=0;i<n;i++) 		scanf("%d",a+i); 	msort(a, 0, n-1); 	cout<<count<<"\n"; 	return 0; } 
#include <stdio.h> #include <string.h> #include <vector> #include <algorithm>  #define MaxLengthAncestorList 100  class AncestorList { public: 	AncestorList(char ancestorListChar[]) 	{ 		unsigned int i = 0; 		for(; i < strlen(ancestorListChar); i++) 			ancestorListInteger[i] = ancestorListChar[i]; 		for(; i < MaxLengthAncestorList; i++) 			ancestorListInteger[i] = -1; 	}  	bool operator<(const AncestorList& ancestorListRight) const 	{ 		bool isLessThan = 0; 		for(unsigned int i = 0; i < MaxLengthAncestorList; i++) 		{ 			if((this->ancestorListInteger)[i] < ancestorListRight.ancestorListInteger[i]) 			{ 				isLessThan = 1; 				break; 			} 			else if((this->ancestorListInteger)[i] > ancestorListRight.ancestorListInteger[i]) 				break; 			else if((this->ancestorListInteger)[i] == -1) 				break; 			else if(ancestorListRight.ancestorListInteger[i] == -1) 				break; 		} 		return isLessThan; 	}  	unsigned int operator-(const AncestorList& ancestorListRight) const 	{ 		unsigned int i; 		for(i = 0; i < MaxLengthAncestorList; i++) 		{ 			if(((this->ancestorListInteger)[i] != ancestorListRight.ancestorListInteger[i]) || (((this->ancestorListInteger)[i] * ancestorListRight.ancestorListInteger[i]) == 1)) 				break; 		} 		return i; 	}  private: 	int ancestorListInteger[MaxLengthAncestorList]; };   int main() { 	char ancestorListInput[MaxLengthAncestorList + 1]; 	std::vector<AncestorList> ancestorListVector;  	unsigned int numberOfInputs, i; 	scanf("%d", &numberOfInputs); 	for(i = 0; i < numberOfInputs; i++) 	{ 		scanf("%s", ancestorListInput); 		ancestorListVector.push_back(AncestorList(ancestorListInput)); 	}  	std::sort(ancestorListVector.begin(), ancestorListVector.end());  	unsigned int numberOfMatches, maximumNumberOfMatches = 0; 	for(i = 0; i < (ancestorListVector.size() - 1); i++) 	{ 		numberOfMatches = ancestorListVector[i + 1] - ancestorListVector[i]; 		if(numberOfMatches > maximumNumberOfMatches) 			maximumNumberOfMatches = numberOfMatches; 	} 	printf("%d", maximumNumberOfMatches);  	return 0; }
#include <iostream> #include <sstream> #include <cstdio> #include <cstring> #include <cstdlib> #include <cmath> #include <memory> #include <cctype> #include <string> #include <vector> #include <list> #include <queue> #include <deque> #include <stack> #include <map> #include <set> #include <algorithm> using namespace std; #define FOR(i,a,b) for(int (i) = (a); (i) <= (b); ++(i)) #define RFOR(i,a,b) for(int (i) = (a); (i) >= (b); --(i)) #define INITIALIZE(a,b) memset((a),b,sizeof(a)) #define INF 1000000000 #define pi 2*acos(0.0) #define SQR(a) (a)*(a) #define MP make_pair #define MAX 100001 #define MODV 1000000007 #define mod(a,mb) if(a >= mb) a = a - mb; #define modx(a) mod(a,MODV)  typedef unsigned long long UInt; typedef long long Int;  void compPrime(int *primeArr,int n){} void compPhi(int *phiArr, int n){} void compFact(int *factArr, int n){} void compPow(int *powArr, int x, int n) {   int i;     powArr[0] = 1;     FOR(i,1,n){powArr[i] = powArr[i-1]*x;mod(powArr[i],MODV);} }  class Literal { public :     int count1 ;     int count0 ;     Literal(){count1 = count0 = 0;}  }; int main() {   int test,N,i,j, sum;   char Str[30];   scanf("%s", Str);   vector<char>OP;   vector<int>Val;    for(i=0; Str[i]!='\0'; i++)   {       if(Str[i]=='T')Val.push_back(1);       else if(Str[i]=='F')Val.push_back(0);       else OP.push_back(Str[i]);   }    N = Val.size();   Literal m[N+1][N+1];   FOR(i,1,N)     if(Val[i-1]==0)m[i][i].count0 =  1;     else m[i][i].count1 = 1;     int l,k;    int q1, q0;    int count00, count01, count10, count11;    FOR(l,2,N)    {        FOR(i, 1, N-l+1)        {            j = i + l - 1;            q1 = 0;            q0 = 0;            FOR(k,i,j-1)            {                count00 = m[i][k].count0 * m[k+1][j].count0;                count01 = m[i][k].count0 * m[k+1][j].count1;                count10 = m[i][k].count1 * m[k+1][j].count0;                count11 = m[i][k].count1 * m[k+1][j].count1;                if(OP[k-1]=='+'){q1 += count11+count10+count01; q0+=count00;}                else if(OP[k-1]=='.'){q1+=count11; q0+= count00+count10+count01;}                else {q1+= count01 + count10; q0+= count11 + count00;}             }            m[i][j].count1 = q1;            m[i][j].count0 = q0;        }    }     printf("%d\n", m[1][N].count1);   } 
#include<stdio.h> #include<string.h> int len; char s[1000]; int prime[] = {     2,      3,      5,      7,     11,     13,     17,     19,     23,     29,      31,     37,     41,     43,     47,     53,     59,     61,     67,     71,      73,     79,     83,     89,     97,    101,    103,    107,    109,    113,      127,    131,    137,    139,    149,    151,    157,    163,    167,    173,      179,    181,    191,    193,    197,    199,    211,    223,    227,    229,      233,    239,    241,    251,    257,    263,    269,    271,    277,    281,      283,    293,    307,    311,    313,    317,    331,    337,    347,    349,      353,    359,    367,    373,    379,    383,    389,    397,    401,    409,      419,    421,    431,    433,    439,    443,    449,    457,    461,    463,      467,    479,    487,    491,    499,    503,    509,    521,    523,    541,      547,    557,    563,    569,    571,    577,    587,    593,    599,    601,      607,    613,    617,    619,    631,    641,    643,    647,    653,    659,      661,    673,    677,    683,    691,    701,    709,    719,    727,    733,      739,    743,    751,    757,    761,    769,    773,    787,    797,    809,      811,    821,    823,    827,    829,    839,    853,    857,    859,    863,      877,    881,    883,    887,    907,    911,    919,    929,    937,    941,      947,    953,    967,    971,    977,    983,    991,    997,   1009,   1013,  };     int isdiv(long int k) { long int l=0; int j; for(j=0;j<len;j++) {if(s[j]==',')continue; l=l*10+(s[j]-'0'); //printf("%d\n",l); l%=k; } l%=k; return (!l); }   int num() {int m=0,l; for(l=0;l<len;l++) m=m*10 +(s[l]-'0'); return m; }   int main() {   int n,k,l=0; len=0; scanf("%s",s); len=strlen(s); if(len<=4) {l=1; n=num(); if(n<=1013) { if(n==1)l=0; for(k=0;k<170 && l;k++)if(prime[k]==n)l=0; goto ls; } } for(k=0;k<170 && !l;k++) if(isdiv(prime[k])){l=1;break;}   ls:if(l)printf("COMPOSITE\n"); else printf("PRIME\n"); return 0; }
#include <stdio.h> #include <string.h>   char Matrix[50][50]; int I;   char testBaseSurround ( int row, int col, int width) { int x=0; char *ptr = (char *)&Matrix[row][col]; x = width; while ( *ptr != '\0') { if ( *ptr++ == '#') return 0; if ( --x == 0) break; } return 1; }   int getColSpace ( char *ptr, int lim) { int sp=0; while ( *ptr++ == '*') ++sp; return sp > lim ? lim : sp; }   char testBase ( char *ptr, int width) { int sp=0; while ( *ptr++ == '#') ++sp; if ( sp != width) return 0; return 1; }   int findColumn ( int sc, int row, int col, int *Length) { int height=0; char *ptr=NULL; while ( Matrix[row][col] == '*') { *Length = 0; ptr = &Matrix[row][col]; if ( getColSpace ( ptr, sc) != sc) return 0;  ptr += sc; while ( *ptr == '#') { *Length = *Length + 1; ++ptr; } if ( getColSpace ( ptr, sc) != sc) return 0;  ++row; ++height; } return height; }   void findBase ( int *row, int *col) { int IBase=1, IBaseHeight=0, x=0, y=0, sc=0, ColLen=0; char *ptr = &Matrix[*row][*col]; ++ptr;  if ( *ptr != '#' && *(ptr+1) != '#') { *col = *col + 2; return; }  while ( *ptr++ == '#') ++IBase;    if ( *row != 0) { y = *row-1; x = *col; if ( !testBaseSurround ( y, x, IBase)) { *col = *col + 2;  return; } }    y = *row; x = *col; while ( Matrix[y][x] == '#') { if ( !testBase(&Matrix[y][x],IBase)) { *col = *col + IBase; return; } ++IBaseHeight; ++y; } sc = (IBase/3);   if ( (y = findColumn ( sc, y, x, &ColLen)) == 0) { *col = *col + IBase; return; } // if ( (ColLen + (2 * sc)) != IBase) { *col = *col + IBase;  return; } // y += (*row + IBaseHeight); // finding bottom base now x = IBaseHeight; while ( x != 0) { if ( !testBase(&Matrix[y][*col],IBase)) { *col = *col + IBase; return; } y++; --x; } // // test surround if ( !testBaseSurround ( y, *col, IBase)) { *col = *col + IBase; //printf ( "nope\n"); return; } //printf ( "ok\n"); ++I; *col = *col + IBase; }   int main() { unsigned char b; int r=0,c=0, rs=0, cs=0;   scanf ( "%d %d", &r, &c); memset ( &Matrix, 0, 50 * 50); I = 0;   for ( ; rs < r; ++rs) { for ( cs = 0; cs < c; ++cs) { while ( b = (char)getchar()) { if ( b == '\0') return 0; if ( b == '#' || b == '*') { Matrix[rs][cs] = b; break; }	 } } }    for ( rs = 0, cs=0; rs < r; cs=0,++rs) { while ( (b = Matrix[rs][cs]) != '\0') { if ( b == '#') findBase ( &rs, &cs); else ++cs; if ( cs > c) break; } } // printf ( "%d\n", I); return 0; }
#include<stdio.h> #include<string.h> #include<stdlib.h> int k[105],b[105][105],a[105],n,l; 	char str[105][105],st[105]; void func(int i) { /*for(int i=1;i<=n;i++) printf("%d ",a[i]); printf("\n");*/  	if(i>n) 	{ 		printf("Yes"); 		exit(0); 	} 	for(int j=1;j<=k[i];j++) 	{ 		if(a[b[i][j]]==1) 		{ 			a[b[i][j]]=0; 			func(i+1);                         a[b[i][j]]=1; 		} 	} 	 } int main() { 	 	scanf("%d",&n); 	for(int i=0;i<=n;i++) 	gets(st); 	for(int i=1;i<=n;i++) 	gets(str[i]); 	for(int i=1;i<=n;i++) 	{ 		scanf("%d",&k[i]); 		  		for(int j=1;j<=k[i];j++) 		{ 			scanf("%s",&st); 			for(l=1;l<=n;l++) 			{                if(strcmp(st,str[l])==0)                 break; 			} 			b[i][j]=l; 		}		 	} 	for(int i=1;i<=n;i++) 	a[i]=1; 	 	/*for(int i=1;i<=n;i++) 	{ 		printf("%d ",k[i]);  	} 	printf("\n"); 	for(int i=1;i<=n;i++) 	{ 		for(int j=1;j<=k[i];j++) 		{ 			printf("%d ",b[i][j]); 		} 		printf("\n"); 		 	} */ func(1); printf("No");	 	 }
#include<bits/stdc++.h> using namespace std;  const int N=5123456; char s[N];  int z[N];  void calZ() { 	int l=0, r=0; 	int len=strlen(s); 	for(int i=1;i<len;i++) { 		if(i<=r) z[i]=min(z[i-l], r-i+1); 		while(i+z[i]<len && s[z[i]]==s[i+z[i]]) z[i]++; 		if(z[i]>(r-i+1)) l=i, r=i+z[i]-1; 	} }  int main() { 	scanf("%s", s); 	calZ(); 	int q; 	scanf("%d", &q); 	while(q--) { 		int p; 		scanf("%d", &p); 		printf("%d\n", min(z[p], p)); 	} } 
#include<bits/stdc++.h> using namespace std; typedef long long int LL; #define sd(x) scanf("%d", &x) #define mp make_pair #define pb push_back #define vi vector<int> #define ft first #define sc second #define INF 1000000000 #define MOD 10000007 int n, k; pair<LL,LL> c[205]; LL cost[205][205]; LL dp[205][37]; LL func(int last, int tot) { 	if (tot < 0) { 		return 100000000000000LL; 	} 	if (last == n+1) { 		if (tot == 0) return 0; 		else return 100000000000000LL; 	} 	if (dp[last][tot] != -1) return dp[last][tot]; 	LL ans = 100000000000000LL; 	for (int i = last; i <= n; i++) { 		ans = min(ans, cost[last][i] + func(i+1, tot-1)); 	} 	return dp[last][tot] = ans; } int main() { 	int t; 	scanf("%d", &t); 	while (t--) { 		cin>>n>>k; 		memset(dp, -1, sizeof dp); 		for (int i = 1; i <= n; i++) cin>>c[i].first; 		for (int i = 1; i <= n; i++) cin>>c[i].second; 		sort(c+1, c+n+1); 		for (int i = 1; i <= n; i++) { 			for (int j = i; j <= n; j++) { 				int sel = i; 				LL cst = (j-i)*c[sel].second; 				for (int l = i; l <= j; l++) { 					cst += abs(c[sel].first - c[l].first);  				} 				cost[i][j] = cst; 				for (sel = i+1; sel <= j; sel++) { 					cst -= (j-i)*c[sel-1].second; 					cst += (j-i)*c[sel].second; 					cst -= (j - sel+1)*(c[sel].first - c[sel-1].first); 					cst += (sel - i)*(c[sel].first - c[sel-1].first); 					cost[i][j] = min(cost[i][j], cst); 				} 			//	cout<<cost[i][j]<<" "<<endl; 			} 		} 		 		printf("%lld\n", func(1, k)); 	} 	return 0; }
#include "bits/stdc++.h" using namespace std;         #define rep(i,n) for(int i = 0; i < n; ++i)         #define REP(i,a,b) for(int i = a ; i <= b; ++i)         #define rep1(i,n) for(int i = 1; i <=n ; ++i)         #define s(n) scanf("%lf",&n)         #define rev(i,n) for(int i = n-2; i >= 0 ; --i)         #define REV(i,a,b) for(int i = a ; i >= b ; --i)         #define INF 1000000000         #define pii pair<int,int>         #define pb(a) push_back(a)         #define ll long long         #define vi vector<int>         #define mii map<int,int>         #define msi map<string,int>         #define vii vector<vector<int> >         #define vpp vector<pair<int,int> >         #define MOD 1000000007         #define PDD pair<double,double>         #define vl vector<long long>         #define pil pair<int,long long>         #define pll pair<long long,long long>         #define sz(v) (int)v.size()         #define mp make_pair         #define pi 3.1415926536         #define gc getchar_unlocked         #define ios std::ios::sync_with_stdio(false)         #define e(a) exp(a)         #define limit 100000000         #define gc getchar_unlocked     ll pwr(ll a,ll b,ll mod) {a%=mod;if(a<0)a+=mod;ll ans=1; while(b) {if(b&1) ans=(ans*a)%mod; a=(a*a)%mod; b/=2; } return ans; }     ll pwr(ll a,ll b) {ll ans=1; while(b) {if(b&1) ans*=a; a*=a; b/=2; } return ans; }     ll gcd(ll a,ll b) {while(b) {ll temp=a; a=b; b=temp%b; } return a; }     ll lcm(ll a,ll b) {return (a/gcd(a,b))*b; }     // ll modularInverse(ll a,ll m) {/*reminder: make sure m is prime*/ assert(false); return pwr(a,m-2,m); } //vll v;     const double EPS = 1e-9;  /*two numbers are deemed equal if their abs difference is less than some small epsilon , [less than operator- if(a<b-EPS){}],[less than or equal -if(a<b+EPS){}]*/     vector<ll> m[33];     vector<ll> m1[33];     int main(int argc, char const *argv[])     {     	//ios;     	int n, k, A, B;     	scanf("%d%d%d%d", &n, &k, &A, &B);     	ll a[n+1];ll b[n+1];ll c[n+1];     	rep(i,n)     	scanf("%lld", &a[i]);     for(int i = 0; i < n; i++){ int number  = a[i];    ll pro = 1;      int flag = 0;      while(number % 2 == 0){      	flag = 1;          number = number / 2;               }      if(flag == 1)pro *= 2;      for(int j = 3; j <= sqrt(a[i]); j++){      	 flag = 0;          while(number % j == 0){          	flag = 1;          	number = number / j;           }          if(flag == 1)pro*=j;      }       if(number > 2){      	pro *= number;      }      a[i] = pro;    }    // for(int i = 0; i < n; i++){cout << a[i] << " " ;}cout << "\n";     	int divide = n/2;     	int divide1 = n - divide;     	ll prec = pwr(2, divide);     	ll prec1 = pwr(2, divide1);     	for(int i = 0; i < divide; i++){b[i] = a[i];}//firstpart 		for(int i = divide; i < n; i++)c[i-divide] = a[i];//secondpart     	//BITMASKS     	for(int i = 0; i < prec; i++){     		ll c1 = 0, pro = 0;     		for(int j = 0; j < divide; j++){     			if(i & (1<<j)){     				c1++;     				pro += b[j];     				// cout << "*"     			}     			     		}     		m[c1].push_back(pro);     	} // for(int i = 0 ; i <= 2; i++){ // 	cout << i <<  "\n"; // 	for(int j = 0 ; j  < m[i].size(); j++)cout << m[i][j] << " "; // 		cout << "\n"; // }     	for(int i = 0; i < prec1; i++){     		ll c1 = 0, pro = 0;     		for(int j = 0; j < divide1; j++){     			if(i & (1<<j)){     				c1++;     				pro += c[j];     			}     			     		}     		m1[c1].push_back(pro);     	}      	for(int i  = 0 ; i <= k; i++){     		sort(m1[i].begin(), m1[i].end());     	}      	//end BITMASKS     	ll c3 = 0;     	for(int i = 0; i <= k; i++){     		for(int j = 0; j <= k; j++){     			if(i+j <= k){     				for(int p = 0; p < m[i].size(); p++){     					// for(int q = 0; q < m1[j].size(); q++){     					// 	if(m1[j][q] + m[i][p] >= A && m1[j][q] + m[i][p] <= B)c3++;     					// }     					int val = A - m[i][p]; 						int id1 = lower_bound(m1[j].begin(),m1[j].end(),val) - m1[j].begin(); 						val = B - m[i][p]; 						int id2 = upper_bound(m1[j].begin(),m1[j].end(),val) - m1[j].begin() - 1; 						c3 = c3 + max(0,id2 - id1 + 1);     				}     			}     		}     	}     	printf("%lld", c3);     	return 0;     }
#include<bits/stdc++.h> using namespace std;  string str; string ans; int main(){ 	int n,k; 	cin>>n>>k; 	cin>>str; 	ans=""; 	int i,j; 	for(i=0;i<k;i++){ 		int cnt[26]; 		memset(cnt,0,sizeof(cnt)); 		for(j=i;j<n;j+=k){ 			cnt[str[j]-'a']++; 		} 		int maxi=0; 		char max_c=str[i]; 		for(j=2;j>=0;j--){ 			if(cnt[j]!=0&&cnt[j]>=maxi){ 				maxi=cnt[j]; 				max_c=(char)(j+'a'); 			} 		} 		ans+=max_c; 	} 	cout<<ans<<endl; 	return 0; }
 #include<iostream>     #include<algorithm>     #include<cstdio>     using namespace std;      int main()     {     	int n,i,j,k,cn;     	long long int N,m;     	long long int max;     	scanf("%d",&n);     	int id[n];     	long long int a[n],a1[n];      	for(i=0;i<n;i++)     	{     		scanf("%lld%lld",&m,&N);     		a[i]=m*N;     		a1[i]=a[i];     		//printf("%lld\n",arr[i]);      	}cn=0;     	sort(a1,a1+n);     	//for(i=0;i<n;i++)     	//printf("%lld\n",arr1[i]);     	for(i=n-1;i>=0;i--)     	{     		for(j=0;j<n;j++)     		if(a1[i]==a[j])     		{//printf("%d",j);     			id[cn++]=j+1;     			a[j]=-1;     			break;     		}     	}     	//for(i=0;i<n;i++)     	//printf("%d",index[i]);     	int q;     	scanf("%d",&q);     	while(q--)     	{     	scanf("%d",&k);         	printf("%d\n",id[k-1]);     	}     	return 0;} 
#include<iostream> #include<algorithm> #include<vector> #include<queue> #include<list> using namespace std; #define inf 100000000000000000LL long long int func(vector<pair<int,int> >*adj,int src,int des) { long long int ans[des+3]; fill(ans,ans+des+3,inf); priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q; q.push(make_pair(0,src)); ans[src]=0; while(!q.empty()) { pair<int,int>temp=q.top(); q.pop(); for(int i=0;i<adj[temp.second].size();i++) if(ans[adj[temp.second][i].second]>ans[temp.second]+adj[temp.second][i].first) { ans[adj[temp.second][i].second]=ans[temp.second]+adj[temp.second][i].first; q.push(make_pair(ans[adj[temp.second][i].second],adj[temp.second][i].second)); } } return ans[des]; } int main() { ios_base::sync_with_stdio(false); int n,r; cin>>n>>r; int h[n],c[n]; vector<pair<int,int> >adj[3*n]; for(int i=1;i<=n;i++) cin>>h[i]; for(int i=1;i<=n;i++) { cin>>c[i]; adj[i].push_back(make_pair(c[i],n+i)); adj[n+i].push_back(make_pair(c[i],i)); } adj[0].push_back(make_pair(c[1],1)); adj[0].push_back(make_pair(c[1],n+1)); adj[n].push_back(make_pair(0,2*n+1)); adj[2*n].push_back(make_pair(0,2*n+1)); while(r--) { int u,v; cin>>u>>v; if(h[u]<=h[v]) { adj[u].push_back(make_pair(0,v)); adj[n+v].push_back(make_pair(0,n+u)); } if(h[v]<=h[u]) { adj[v].push_back(make_pair(0,u)); adj[n+u].push_back(make_pair(0,n+v)); } } long long int ans=func(adj,0,2*n+1); if(ans>=inf) cout<<"-1"<<endl; else cout<<ans<<endl; return 0; } 
 #include<bits/stdc++.h>  using namespace std;  #define si(x) scanf("%d",&x) #define pri(x) printf("%d",x) #define sll(x) scanf("%lld",&x) #define pll(x) printf("%lld",x) #define sstr(s) scanf("%s",s) #define pstr(s) printf("%s",s) #define nl printf("\n") #define ll long long int  int main() {     ll n,m;     int p;     sll(n); sll(m); si(p);     int a[p],b[p];     int x=0;     map< pair<ll,ll>, int > mp;     for(int i=0;i<p;++i) { 	si(a[i]); si(b[i]); 	mp[make_pair(a[i],b[i])]++;     }     map< pair<ll,ll>, int>::iterator it;     for(it = mp.begin(); it!=mp.end();++it) { 	if(((it->first).first-1 + m-(it->first).second)%2==1) { 	    x = x ^ it->second; 	}     }     if(x) { 	cout<<"Yes\n";     }     else { 	cout<<"No\n";     }     return 0; } 
#include<iostream> #include<algorithm> #include<map> #include<set> #include<vector> using namespace std;  long long int dp[3005][3005]; bool a[3005][3005]; long long int n,c; map<long long int,long long int>m1,m2; set<long long int>s1,s2; vector<long long int>v1,v2; void gen(pair<long long int,long long int>*pos) { set<long long int>::iterator t; for(t=s1.begin();t!=s1.end();t++) { m1[*t]=++c; v1.push_back(*t); } c=0; for(t=s2.begin();t!=s2.end();t++) { m2[*t]=++c; v2.push_back(*t); } for(int i=0;i<n;i++) a[m1[pos[i].first]][m2[pos[i].second]]=true; for(int i=0;i<=n;i++) for(int j=0;j<=n;j++) if(i==0||j==0) dp[i][j]=0; else dp[i][j]=(a[i][j]==true)+dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]; }  bool check(int mid,int x,int y,int k) { long long int x1=x-mid-1,y1=y-mid-1; long long int x2=x+mid,y2=y+mid; x1=upper_bound(v1.begin(),v1.end(),x1)-v1.begin(); y1=upper_bound(v2.begin(),v2.end(),y1)-v2.begin(); x2=upper_bound(v1.begin(),v1.end(),x2)-v1.begin(); y2=upper_bound(v2.begin(),v2.end(),y2)-v2.begin(); long long int temp=dp[x2][y2]+dp[x1][y1]; temp-=dp[x2][y1]; temp-=dp[x1][y2]; return (temp>=k); }  long long int func(long long int x,long long int y,long long int k) { if(k>n) return -1; long long int c=100,beg=0,last=1000000000,mid; while(c--) { mid=beg+(last-beg)/2; if(check(mid,x,y,k)) last=mid; else beg=mid+1; } return last; }  int main() { ios_base::sync_with_stdio(false); cin>>n; pair<long long int,long long int>pos[n]; for(int i=0;i<n;i++) { cin>>pos[i].first>>pos[i].second; s1.insert(pos[i].first); s2.insert(pos[i].second); } gen(pos); int q; cin>>q; while(q--) { long long int x,y,k; cin>>x>>y>>k; cout<<func(x,y,k)<<endl; } return 0; } 
#include <cstdio> #include <iostream> #include <stdio.h> using namespace std; int main(int argc, char const *argv[]) { 	int t,n,k; 	float x,y; 	scanf("%d",&t); 	while(t--){ 		scanf("%d%d%f%f",&n,&k,&x,&y); 		//cout<<n*720/(x+y)<<"\n"; 		float numer = (n-k)*(1-y); 		float denom = n-(k*x+(n-k)*y); 		//cout<<(.4f)numer/denom<<"\n"; 		printf("%.4f\n",numer/denom); 	} 	return 0; }
#include<iostream> using namespace std;  int temp[] = {1,2,3,4}; int main() { for(int i=0;i<4;i++) cout<<temp[i]<<endl; return 0; }
#include<stdio.h> int help(int help) { help=help++; return ++help; } int main() { int test=10; int pleh=help(test); printf("%d\n",pleh); return 0; }
#include <stdio.h> using namespace std;  long long int f(long long int n) { 	long long int r; 	 	if(n >= 0) 		r = (n+1)*(n+2)*(n+3); 	 	return (r/6) ; }   int main() { 	long long int N,A,B,C; 	scanf("%lld%lld%lld%lld",&N,&A,&B,&C); 	printf("%lld\n",f(N)-f(N-A-1)-f(N-B-1)-f(N-C-1)+f(N-A-B-2)+f(N-A-C-2)+f(N-C-B-2)-f(N-A-B-C-3)); 	 	return 0;  }    /* #include <iostream> #include <algorithm> #include <map> #include <cstring> //memset  #define int64 long long int #define int64r register int64 #define int32 register int  using namespace std;  int main(){ 	 	 	 	return 0;  } */
#include <stdio.h> #include <string.h> int main() {int size; scanf ("%d",&size); int arr[size],i; for(i=0;i<size;i++) { scanf("%d",&arr[i]); printf("%d",arr[i]); } return 0; }
#include<stdio.h> using namespace std;  int main(void) { 	int i = 0, num = 1, tmp = 0; 	while(num<=10) 	{ 		i=2; 		tmp = 0; 		while(i <= num) 		{ 			if(num%i==0) 				tmp++; 			//end if 			if(tmp > 2) 				break; 			//end if	 			i++;  		}//end while 		 		if(tmp==1) 			printf("%3d, ", num); 		//end if 		num++;  	}//end if 	 	return 0;  }//end main
#include<iostream> using namespace std; int main() { cout<<"Intechxication2012"<<endl; return 0; }
#include<stdio.h> using namespace std; int main() { printf("%d",1); return 0; }
#include <stdio.h> int main() { int number = 0, rem = 0; scanf("%d",&number); rem = number % 2; if(rem == 0) printf("%d is an even number.\n", number); else printf("%d is an odd number.\n", number); return 0; }
#include <stdio.h> #include <stdlib.h> char names[6][60] = { "kisalaya", "kunal", "aaditya" "jp", "sambhav", "mayank" }; int main() { int i; int choice; for( i = 0; i < 1; i++ ) { choice = 5; printf( "%s", "mayank" ); } return 0; }
#include<stdio.h> int main() {             int a[]={1,2,3,4,5};             int j;             //Block 1 starts here   for(j=0;j<5;j++ )             {                         printf("%d",a[j]); }   //Block 1 ends here   }
#include<stdio.h> using namespace std;  int f(int); int main() {             int f(int);             int b;             b = f(20);             printf("%d",b);             return 0; }   int f(int a) {     return a>=20? a : 0; }
#include<stdio.h> int main() { printf("Executed"); return 0; }
#include<stdio.h> using namespace std; int main() {     char s='A'; printf("%c",s);  return 0; }
#include<cstdio> using namespace std; #define LL int long long int main() { LL t; scanf("%lld",&t); while(t--) {   LL n;   scanf("%lld",&n);   printf("%lld\n",(n*(n-1))/2); } return 0; }
#include<stdio.h> #include<math.h> void bin(long long int number,long long int count) { 	long long int i=1,j=1,t=0,s=1,k=0; 	while(number) 	{ 		 	//	printf("a%lld\n",number); 		if(number&1) 		{ 			 			s=count/j; 			if(s%2==0) 			{ 				//printf("b%lld lld\n",count,j); 			t+=(long long int)pow(2,k); 			//printf("%lld\n",t); 			} 			j=j*2; 			 		} 		number=number>>1; 		k++; 	} 	printf("%lld",t); 	printf("\n"); } 	 int main() { 	int testcases; 	long long int number,temporary,count; 	scanf("%d", &testcases); 	 	while(testcases--) { 		scanf("%lld%lld", &number, &count); 		bin(number,count); 		//printf("%lld\n",number>>1); 	} 	return 0; } 
#include <iostream> #include <cstdio> #include <cassert> using namespace std;  long long N, K, M; long long pos, scroll, up, down; long long length;  void perform(); long long top(long long k); bool visible(long long k);  int main() {   long long T;   assert(scanf("%lld",&T)==1);   while(T) {     perform();     T--;   }   return 0; }  void perform() {   pos = 1;   up = 1;   down = 1;   length = 0;   scroll = 0;   assert(scanf("%lld %lld %lld", &N, &K, &M)==3);      long long v;   for(long long i=0;i<M;++i) {     assert(scanf("%lld",&v)==1); //     cerr << scroll << " " << length << " " << up << " " << down << "\n";          down = max(down, v);     up = min(up, v);          if(visible(v))       continue;     if(v>pos) {       length += top(v) - pos;       pos = top(v);     }     else {       length += pos-v;       pos = v;     }     scroll++;          if(visible(up)&&visible(down))       scroll--;     else {       up = v;       down = v;     }   }      printf("%lld %lld\n", scroll, length); //   cerr << up << " " << down << "\n"; } long long top(long long k) {   return (k-K+1); } bool visible(long long k) {   if(k>=pos&&k<pos+K)     return true;   return false; }
using namespace std; #include <iostream> #include <assert.h> #define FORab(i,a,b) for(__typeof(b) i=(a);i<=(b);i++) #define FOR1(i,n) FORab(i,1,n) #define MAX 1010 #define ll long long ll mem[MAX][MAX]={0},cum[MAX][MAX]={0}; bool isMemed[MAX][MAX]={0}; ll solve(ll i, ll j) {     //cout<<i<<' '<<j<<endl;     if(isMemed[i][j]) {return mem[i][j];}     if(isMemed[j][i]) {return mem[i][j]=mem[j][i];}     //if(i == 0) return 0;     //if(j == 0) return 0;     isMemed[i][j] = true;     ll &ans = mem[i][j];     if(i < j) { swap(i,j); }     if(i%j == 0) return ans=i/j;     return ans=i/j+solve(j, i%j); }   int main() {       FOR1(i, MAX-1) FOR1(j, MAX-1) { solve(i, j); }     FOR1(i, MAX-1) FOR1(j, MAX-1)     {         cum[i][j]=cum[i-1][j]+mem[i][j];     }     //cout<<solve(4,4)<<" "<<solve(4,5)<<" "<<solve(5,4)<<" "<<solve(5,5)<<" "<<endl;     //cout<<mem[2][5]<<" "<<cum[2][5]<<endl;     ll x=0;     FORab(i,1,2)         FORab(j,5,10)x+=mem[i][j];         //cout<<x<<endl;     ll t; cin>>t;     FOR1(cno, t) {         ll m, n, p, q;         cin>>m>>n>>p>>q;         ll ans=0;         FORab(j, p, q) {             ll mdiv = (m-1)/j;             ll ndiv = n/j;             ll mmod = (m-1)%j;             ll nmod = n%j;             /*             if(mdiv == ndiv) {                 ans = getAns(j, mmod, nmod);             } else if(mmod < nmod) {                 getAns(j, mmod, nmod)+getAns(j, 1, mmod-1);*/                 ll msum=j*(mdiv*(mdiv-1))/2 + (mmod+1)*mdiv;                 ll nsum=j*(ndiv*(ndiv-1))/2 + (nmod+1)*ndiv;                // cout<<nsum<<" .. "<<msum<<endl;                 msum+=cum[j-1][j]*mdiv+cum[mmod][j];                 nsum+=cum[j-1][j]*ndiv+cum[nmod][j];                 ans+=nsum-msum;     //            cout<<nsum<<" "<<msum<<endl;                 //assert(nsum>=msum);                 //assert(ans>=0);             }             cout<<ans<<endl;     }       return 0; }  
#include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<string> #include<iostream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath>  using namespace std;  #define s(n)					scanf("%d",&n); #define sl(n)                   scanf("%lld", &n); #define sf(n) 					scanf("%lf",&n); #define ss(n) 					scanf("%s",n); #define INF						(int)1e9 #define LINF					(long long)1e18 #define EPS						1e-12 #define FOR(i,a,b)				for(int i=a;i<b;i++) #define REP(i,n)				FOR(i,0,n) #define foreach(v,c)            for( typeof((c).begin()) v = (c).begin();  v != (c).end(); ++v) #define mp						make_pair #define FF						first #define SS						second #define tri(a,b,c)				mp(a,mp(b,c)) #define XX						first.first #define YY						first.second #define ZZ						second #define pb						push_back #define fill(a,v) 				memset(a,v,sizeof a) #define all(x)					x.begin(),x.end() #define SZ(v)					((int)(v.size())) #define DREP(a)					sort(all(a)); a.erase(unique(all(a)),a.end()) #define INDEX(arr,ind)			(lower_bound(all(arr),ind)-arr.begin()) #define debug(args...)			{dbg,args; cerr<<endl;} #define dline					cerr<<endl #define SP                      system("pause"); #define HAHA                    printf("HAHA\n"); #define mod                     10000  void debugarr(int *arr, int ind1, int ind2) { 	cout<<"[ "; 	for(int i=ind1;i<=ind2;i++) 		cout<<arr[i]<<" "; 	cout<<"]"<<endl; }  typedef long long LL; typedef pair<int,int> PII; typedef pair<LL,LL> PLL; typedef pair<LL,PII> TRI;  typedef vector<int> VI; typedef vector<LL> VL; typedef vector<PII> VII; typedef vector<PLL> VLL; typedef vector<TRI> VT;  typedef vector<VI> VVI; typedef vector<VL> VVL; typedef vector<VII> VVII; typedef vector<VLL> VVLL; typedef vector<VT> VVT;  /////////////////////////////////////////////////////////////////////////////////////////  #define N 50005 #define base (1<<16)  int x[N], y[N]; pair< PII, int> a[N]; int n; map<int, int> xmap, ymap; int cnt[4][N]; int xt[N], yt[N]; int seg[base << 1];  //   23 //   01  int sum(int node, int l, int r, int L, int R) {     if(l == L && r == R) return seg[node];     int M = (L+R)>>1;     int NN = node << 1;     if(r <= M) return sum(NN, l, r, L, M);     if(l > M) return sum(NN|1, l, r, M+1, R);     return sum(NN, l, M, L, M) + sum(NN|1, M+1, r, M+1, R); }  void update(int ind, int val) {     for(int i = ind+base; i; i>>=1) seg[i] += val; }  void go(int ind) {     sort(a, a+n);     fill(seg, 0);     REP(i, n)     {         cnt[ind][a[i].ZZ] = sum(1, 0, a[i].YY, 0, base-1);         update(a[i].YY, 1);     } }  int main() {     int T; s(T)     while(T--)     {         fill(cnt, 0);         xmap.clear();         ymap.clear();         s(n)         REP(i, n)         {             s(x[i]) s(y[i])             a[i].XX = x[i];             a[i].YY = y[i];             a[i].ZZ = i;         }         int xcnt = 0;         sort(x, x+n);         REP(i, n) if(i == 0 || x[i] != x[i-1]) xmap[x[i]] = xcnt++;         int ycnt = 0;         sort(y, y+n);         REP(i, n) if(i == 0 || y[i] != y[i-1]) ymap[y[i]] = ycnt++;         REP(i, n)         {             a[i].XX = xmap[a[i].XX];             a[i].YY = ymap[a[i].YY];         }         go(0);         REP(i, n) a[i].XX = xcnt - 1 - a[i].XX;         go(1);         REP(i, n) a[i].YY = ycnt - 1 - a[i].YY;         go(2);         REP(i, n) a[i].XX = xcnt - 1 - a[i].XX;         go(3);         LL ans = 0LL;         REP(i, n)         {             //cout << cnt[0][i] << " " << cnt[1][i] << " " << cnt[2][i] << " " << cnt[3][i] << endl;             ans = (ans + (LL) cnt[0][i]*cnt[2][i]);             ans = (ans + (LL) cnt[1][i]*cnt[3][i]);         }         //cout << "ans ---------------- :O  ------- " << ans << endl;         fill(xt, 0); fill(yt, 0);         REP(i, n) xt[a[i].XX]++;         REP(i, n) yt[a[i].YY]++;         REP(i, xcnt) ans = (ans - (LL) xt[i]*(xt[i]-1)*(xt[i]-2)/6);         REP(i, ycnt) ans = (ans - (LL) yt[i]*(yt[i]-1)*(yt[i]-2)/6);         printf("%lld\n", ans<<1);     } }  
#include <cstdio> #include <iostream> #include <vector> #include <string> #include <string.h> #include <memory.h> #include <utility> #include <queue> #include <algorithm> #include <cmath> #include <map> #include <set> #include <ctime> using namespace std;   #define mp make_pair #define pb push_back #define sz(a) int((a).size()) #define forn(i, n) for (int i=0; i<(n); ++i)   typedef long long ll; typedef long double ld; typedef pair<int,int> pii;   const int maxn = 505; const int maxm = 5000000; const int inf = 1000000000;     vector<pii> g[maxn]; int cap[maxm], cost[maxm]; int V, E;   inline void add(int x, int y, int ca, int co) {   cap[E] = ca, cost[E] = co, g[x].pb(mp(y, E++));   cap[E] = 0, cost[E] = -co, g[y].pb(mp(x, E++)); }   int d[maxn], p[maxn], pe[maxn]; int u[maxn]; vector<int> q, nq; int n, m;   bool bf(int S, int T) {   forn (i, V) d[i] = inf, u[i] = 0, p[i] = -1;   q.clear();   d[S] = 0;   q.pb(S);   for (int it=1; !q.empty(); ++it)   {     nq.clear();     forn (i, sz(q))     {       int x = q[i];       forn (j, sz(g[x]))       {         int y = g[x][j].first, e = g[x][j].second;         if (d[y] > d[x]+cost[e] && cap[e] > 0)         {           d[y] = d[x]+cost[e];           p[y] = x, pe[y] = e;           if (u[y] != it)  u[y] = it, nq.pb(y);         }       }     }     q = nq;   }   return d[T] != inf; }   int mcmf(int S, int T) {   int flow = 0, res = 0;   while (bf(S, T))   {     int push = inf;     for (int x=T; p[x]!=-1; x=p[x])       push = min(push, cap[pe[x]]);     flow += push;     for (int x=T; p[x]!=-1; x=p[x])       res += cost[pe[x]] * push, cap[pe[x]] -= push, cap[pe[x]^1] += push;   }   if (flow != n) return -1;   return res; }   int main() {   int tc; scanf("%d", &tc);   while (tc--)   {     scanf("%d %d", &n, &m);     V = 2*n+2;     int S = V-2, T = V-1;     E = 0;     forn (i, V) g[i].clear();     forn (i, m)     {       int x, y, z; scanf("%d %d %d", &x, &y, &z);       --x, --y;       add(x, y+n, 1, z);     }     forn (i, n)     {       add(S, i, 1, 0);       add(i+n, T, 1, 0);     }     int res = mcmf(S, T);     if (res == -1) puts("Impossible");     else printf("%d\n", res);   }       return 0; } 
#include<iostream> #include<stdio.h> #include<stdlib.h> #include<algorithm> #include<sstream> #include<string> #include<string.h> #include<deque> #include<vector> #include<stack> #include<queue> #include<math.h> #include<map> #include<set>  using namespace std;  typedef long long LL; typedef pair<int,int> pii;  double PI = acos(-1); double EPS = 1e-7; int INF = 1000000000; int MAXINT = 2147483647; LL INFLL = 1000000000000000000LL; LL MAXLL = 9223372036854775807LL;  #define fi first #define se second #define mp make_pair #define pb push_back  #define SIZE(a) (int)a.size() #define ALL(a) a.begin(),a.end() #define RESET(a,b) memset(a,b,sizeof(a)) #define FOR(a,b,c) for (int (a)=(b); (a)<=(c); (a)++) #define FORD(a,b,c) for (int (a)=(b); (a)>=(c); (a)--) #define FORIT(a,b) for (__typeof((b).begin()) a=(b).begin(); a!=(b).end(); (a)++) #define MIN(a, b) (a) = min((a), (b)) #define MAX(a, b) (a) = max((a), (b)) #define PAUSE system("pause")  #define input(in) freopen(in,"r",stdin) #define output(out) freopen(out,"w",stdout)  pii M[8] = {mp(0,1),mp(1,0),mp(-1,0),mp(0,-1),mp(-1,1),mp(-1,-1),mp(1,-1),mp(1,1)};  /*\   \ \   \*/   LL A[50009],P[50009],C,N;  int main() { 	LL t; 	scanf("%lld",&t);     while(t--)     {     	A[0]=0;     	scanf("%lld%lld",&N,&C);     	for(LL i=1;i<=N;i++)     	{     		scanf("%lld",&A[i]);    		}    		for(LL i=0;i<N;i++)     	{     		scanf("%lld",&P[i]);    		}    		P[N]=0;    		    		LL total =0,fuel=0;    		FOR(now,0,N-1)         {         	LL k = now+1,buy=now;         	LL dist = A[now+1]-A[now];         	LL base = dist;         	while( k<N && C >= base )         	{         		if(P[k]<=P[now]) break;        			base += A[k+1]-A[k];         		k++;         	}         	         		         	if( C < base )        	 		base=C;  	 		  	 		base -= fuel;   	 		if(base>0)  	 		{         		total += P[buy]*base;    		        fuel = base + fuel - dist;    		    }    		    else fuel -= dist;         }                        printf("%lld\n",total);     } }
 #ifndef PROGRAMMING_CONTESTS_H #define PROGRAMMING_CONTESTS_H #include <algorithm> #include <bitset> #include <cctype> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <iostream> #include <limits> #include <list> #include <map> #include <queue> #include <set> #include <sstream> #include <string> #include <typeinfo> #include <utility> #include <vector> #ifdef LOCALHOST static FILE* _freopen=freopen("input.txt","r",stdin); #else #define NDEBUG #endif #include <cassert> using namespace std;  typedef long long LL; typedef unsigned long long ULL; typedef pair<int,int> PII;  #define IT(c) typeof(c.begin()) #define PB push_back #define MP make_pair #define LEN(a) (sizeof(a)/sizeof(a[0])) #define ALL(c) c.begin(),c.end() #define FOR(i,a,b) for(int i=(a), _b=(b); i<_b; ++i) #define FORD(i,a,b) for(int i=(b-1), _a=(a); i>=_a; --i) #define FORE(i,c) for(IT(c) i=(c).begin(); i!=(c).end(); ++i)  static int RI(){int res;int r=scanf("%d ",&res);assert(r==1);return res;} static LL RLL(){LL res;int r=scanf("%lld ",&res);assert(r==1);return res;} static ULL RULL(){ULL res;int r=scanf("%llu ",&res);assert(r==1);return res;} static double RD(){double res;int r=scanf("%lf ",&res);assert(r==1);return res;} static string RS(){char buf[2000];int r=scanf("%s ",buf);assert(r==1);return string(buf);} static string RL(){string res;getline(cin,res);assert(cin.good());return res;} //Requires and discards line break at end of line. static const double PI=acos(-1.0), EPS=1e-10; template<typename T> static string str(T x){stringstream ss;ss<<x;return ss.str();} template<typename A,typename V> static void fill(A& a,V v){fill_n((V*)a,sizeof(a)/sizeof(v),v);} // Requires A is a V array. static double timer(){return 1.0*clock()/CLOCKS_PER_SEC;}  #endif //PROGRAMMING_CONTESTS_H   int n,r,k,m=100000007; vector<int> a[405];  LL mem[405][405][2];  //direct is true iff can use the edge (parent,v) LL f(int parent, int parentI, int k, int direct){   int v=(parent==-1?1:a[parent][parentI]);   LL& res=mem[v][k][direct];   if(res!=-1) return res;   res=0;    bool hasChild=a[v].size()>0, hasRSib=parent!=-1&&parentI+1<a[parent].size();   if(!hasChild&&hasRSib){     res=(res+f(parent,parentI+1,k,direct))%m; //dont use edge     if(direct&&k>0)res=(res+f(parent,parentI+1,k-1,0))%m; //use edge   } else if(hasChild&&!hasRSib){     res=(res+f(v,0,k,1))%m; //dont use edge     if(direct&&k>0)res=(res+f(v,0,k-1,0))%m; //use edge   } else if(hasChild&&hasRSib){     FOR(give,0,k+1){ //how many to give to next sibling?       int left=k-give;       res=(res+f(v,0,left,1)*f(parent,parentI+1,give,direct))%m; //dont use edge       if(direct&&left>0)res=(res+f(v,0,left-1,0)*f(parent,parentI+1,give,0))%m; //use edge     }   } else {     res=(k==0||k==1&&direct);   }        return res; }   int main(int argc, char** argv) {   FOR(test,0,RI()){     n=RI(),r=RI(),k=RI();     FOR(i,1,n+1)a[i].clear();     fill(mem,-1);          vector<int> t[405];     FOR(i,0,r){       int v=RI(),w=RI();       t[v].PB(w);       t[w].PB(v);     }          queue<int> q;     q.push(1);     bool seen[405]={0};     seen[1]=true;     while(!q.empty()){       int v=q.front();       q.pop();       FOR(i,0,t[v].size()) {         int c=t[v][i];         if(!seen[c]){           seen[c]=true;           q.push(c);           a[v].PB(c);         }       }     }          cout<<f(-1,0,k,0)<<endl;   }   return 0; } 
#include <cstdio> #include <cstdlib> #include <cstring> #include <string> #include <vector> #include <iostream> #include <cmath> #include <set> #include <ctime> #include <algorithm> #define min(a,b)	((a)<(b)?(a):(b)) #define max(a,b)	((a)>(b)?(a):(b)) #define abs(a)	((a)<0?-(a):(a)) #define inf 214748364 #define pi 3.141592653589793 #define maxn 1010 #define maxm 30001 using namespace std; typedef long long ll; int con,st[maxm],en[maxm],next[maxm]; int fir[maxn]; int ma[maxm],l[maxm],t[maxm]; double v[maxm]; int n,m; double f[maxn]; //int g[maxn]; int head,tail,q[1000001]; inline void addline(int st,int en,double inpv) { 	next[++con]=fir[st],fir[st]=con; 	t[con]=en,v[con]=inpv; } inline bool check(double ans) { 	memset(fir,0,sizeof(fir)); 	con=0; 	for(int i=1;i<=m;++i) 		addline(st[i],en[i],ma[i]-l[i]*ans); 	memset(f,127,sizeof(f)); 	f[1]=0; 	q[head=tail=0]=1; 	while(head<=tail) 	{ 		int p=q[head++]; 		for(int i=fir[p];i;i=next[i]) 		if(f[t[i]]>f[p]+v[i]) 		{ 			f[t[i]]=f[p]+v[i]; 			q[++tail]=t[i]; //			g[t[i]]++; 			if(f[n]<=0) 				return 1; 		} 	} 	return f[n]<=0; } int main() { 	int tim; 	scanf("%d",&tim); 	while(tim--) 	{ 		scanf("%d%d",&n,&m); 		if(n<=1) 		{ 			printf("0.0000\n"); 			continue; 		} 		for(int i=1;i<=m;++i) 		{ 			scanf("%d%d%d%d",&st[i],&en[i],&ma[i],&l[i]); 			if(ma[i]<=60) 				ma[i]=l[i]*(70-ma[i]);else 				ma[i]=l[i]*10; 		} 		double low=0,high=1e4,mid; 		while(high-low>1e-6) 		{ 			mid=(low+high)/2.0; 			if(check(mid)) 				high=mid;else 				low=mid; 		} 		printf("%.4lf\n",low+0.0000499999999); //		printf("%.4lf\n",low); 	} 	return 0; } 
#include <bits/stdc++.h>  using namespace std;  const int N = 21;  const long long mod = (long long) 100000007 ;  long long a[N][N]; long long dp[(1<<N) + 5];  string conso;  int get_id(char ch) {     for (int i = 0; i < conso.size(); i++) {         if (conso[i] == ch) {             return i;         }     } }  string vowels = "AEIOU";  int isVowel(char ch) {     for (int i = 0; i < vowels.size(); i++) {         if (vowels[i] == ch) {             return true;         }     }     return false; }  int main() {     //freopen("in.txt", "r", stdin);      ios_base::sync_with_stdio(false);     cin.tie(NULL);      for (char i = 'A'; i <= 'Z'; i++) {         if (!isVowel(i))             conso += i;     }      //cout << conso << endl;      int n;     cin >> n;     for (int i = 0; i < n; i++) {         string s;         cin >> s;         int fir = get_id(s[0]);         int sec = get_id(s[s.size() - 1]);         a[fir][sec]++;     }      dp[0] = 1;     for (int mask = 0; mask < (1 << conso.size()); mask++) {         for (int i = 0; i < conso.size(); i++) {             if (!(mask & (1 << i))) {                 long long &res = dp[mask | (1 << i)];                 res += (dp[mask] * (long long) a[__builtin_popcount(mask)][i]) % mod;                 if (res >= mod) {                     res -= mod;                 }             }         }     }      cout << dp[(1 << conso.size()) - 1] << endl;       return 0; } 
#include<stdio.h> #include<stdlib.h> #include<assert.h> #include<deque> #include<iostream> #include<string.h> #include<math.h> #include<set> #include<map> #include<vector> #include<algorithm> #include<bitset> #include<stack> #include<queue> #define MODM 1000000007 #define MAXM 2147483647 #define mp make_pair #define ff first #define ss second #define Pi 3.14159265358979323846264 #define pb push_back #define pf push_front #define ppb pop_back #define ppf pop_front #define Sort(x) sort(x.begin(),x.end()) #define P pair<int,int> #define S(x) scanf("%d",&x); using namespace std; typedef long long int lli; typedef unsigned long long int llu;  lli gcd(lli a,lli b){if(a==0)return(b);else return(gcd(b%a,a));} lli fastpow(lli a,lli n,lli temp){if(n==1)return((a*temp)%MODM); if(n&1)temp=(temp*a)%MODM;return(fastpow((a*a)%MODM,n/2,temp));} int scan() {  int t=0,m=1;char c;c=getchar();while((c<'0' || c>'9') and c!='-') c=getchar();if(c=='-'){c=getchar();m=-1;}  while(c>='0' && c<='9'){t=(t<<3)+(t<<1)+c-'0';c=getchar();} return(t*m); } vector<int>v,hash; vector< vector<int> >adj; map< vector<int>,int>mymap; lli fact[10005]; char done[10005]; int num; lli solve(int nd,int par) {	 	lli ans=1; 	int nnd; 	vector<int>lst; 	lst.pb(-1); 	for(int i=0;i<adj[nd].size();i++) 	{ 		nnd=adj[nd][i]; 		if(nnd!=par) 		{	 			//printf("called to %d\n",nnd); 			ans=(ans*solve(nnd,nd))%MODM; 			if(mymap[hash]==0) 			{ 				mymap[hash]=(++num); 				lst.pb(num); 			} 			else 			lst.pb(mymap[hash]); 		} 	} 	//printf("node=%d %d\nlist\n",nd,lst.size()); 	Sort(lst); 	/*for(int i=0;i<lst.size();i++) 	printf("%d ",lst[i]); 	printf("\n");*/ 	int cnt=1; 	for(int i=1;i<lst.size();i++) 	{ 		if(lst[i]!=lst[i-1]) 		{ 			ans=(ans*fact[cnt])%MODM; 			cnt=1; 		} 		else cnt++; 	} 	ans=(ans*fact[cnt])%MODM; 	hash=lst; 	return(ans); }	 		 int main() { 	int n,t,x,y; 	lli ans,cnt; 	fact[0]=fact[1]=1; 	for(int i=2;i<=10001;i++) 	fact[i]=(fact[i-1]*i)%MODM; 	S(t); 	while(t--) 	{	 		num=0; 		mymap.clear(); adj.clear(); hash.clear(); 		S(n); 		for(int i=0;i<n;i++) 		adj.pb(v); 		for(int i=0;i<n-1;i++) 		{ 			S(x);S(y); 			adj[x].pb(y); 			adj[y].pb(x); 		} 		printf("%lld\n",solve(0,-1)); 	} 	return(0); } 				 				
#include <stdio.h>   using namespace std;   int state[55]; void rotate(int a, int b, int c, int d); void Permute(char code); long long lcm(long long a, long long b); long long gcd(long long a, long long b);   int main () { int i, j, T, temp; long long moves, cycle_len; char input[1010], code; bool seen[55]; scanf("%d", &T); while (T--) { for (i=1; i<=54; i++) { state[i] = i; seen[i] = false; } scanf("%s", input); i = 0; while (input[i] != '\0') { code = input[i]; if (input[i+1] != '\'' and input[i+1] != '2') { Permute(code); i++; } else { Permute(code); Permute(code); if (input[i+1] == '\'') Permute(code); i += 2; } } moves = 1; for (i=1; i<=54; i++) { if (seen[i]) continue; seen[i] = true; cycle_len = 1; temp = i; j = state[i]; while (temp != j) { j = state[j]; seen[j] = true; cycle_len++; } moves = lcm(moves, cycle_len); } printf("%lld\n", moves); } return 0; }   long long gcd(long long a, long long b) { if (a == 0) return b; if (b == 0) return a; if (a == 1 or b == 1) return 1; if (a == b) return a; if (a > b) return gcd(b, a%b); else return gcd(a, b%a); }   long long lcm(long long a, long long b) { if (a == 1) return b; if (b == 1) return a; if (a == b) return a; return (a/gcd(a, b))*b; }   void rotate(int a, int b, int c, int d) { int temp = state[d]; state[d] = state[c]; state[c] = state[b]; state[b] = state[a]; state[a] = temp; }   void Permute(char code) { switch(code) { case 'U': { rotate(19, 21, 27, 25); rotate(20, 24, 26, 22); rotate(7, 28, 39, 18); rotate(8, 31, 38, 15); rotate(9, 34, 37, 12); break; } case 'D': { rotate(46, 48, 54, 52); rotate(47, 51, 53, 49); rotate(43, 36, 3, 10); rotate(44, 33, 2, 13); rotate(45, 30, 1, 16); break; } case 'F': { rotate(37, 39, 45, 43); rotate(38, 42, 44, 40); rotate(25, 34, 48, 16); rotate(26, 35, 47, 17); rotate(27, 36, 46, 18); break; } case 'B': { rotate(1, 3, 9, 7); rotate(2, 6, 8, 4); rotate(19, 10, 54, 28); rotate(20, 11, 53, 29); rotate(21, 12, 52, 30); break; } case 'L': { rotate(10, 12, 18, 16); rotate(11, 15, 17, 13); rotate(1, 19, 37, 46); rotate(4, 22, 40, 49); rotate(7, 25, 43, 52); break; } case 'R': { rotate(28, 30, 36, 34); rotate(29, 33, 35, 31); rotate(48, 39, 21, 3); rotate(51, 42, 24, 6); rotate(54, 45, 27, 9); break; } } }
#include<cstdio> #include<cstdlib> #include<algorithm>  using namespace std;  typedef long long LL; const LL MOD = 100000007;  LL gcd(LL a, LL b){return b?gcd(b, a%b):a;}  int T; pair<LL, LL>p[4];   int main(){ 	for(scanf("%d", &T); T--; ){  		for(int i=0; i<4; i++)scanf("%lld%lld", &p[i].first, &p[i].second); 		sort(p, p+4);  		p[0].first=abs(p[1].first-p[0].first); 		p[0].second=abs(p[1].second-p[0].second);  		LL s = (p[0].first*p[0].first + p[0].second*p[0].second)%MOD; 		LL ans, g; 		g=gcd(p[0].first, p[0].second)%MOD; 		ans = 2*s*(s-2*g +1)%MOD; 		for(;ans<0;)ans+=MOD; 		printf("%lld\n", ans); 	} 	return 0; } 
#include<iostream> #include<stdio.h> #include<string.h> #include<stdlib.h> #define N 100000007 using namespace std;  struct dat{ 	int digit; 	int val; };  typedef struct dat dat;  dat getChar(char a) { 	dat tmp; 	if(a=='a') {tmp.digit=2;tmp.val=1;} 	else if(a=='b') {tmp.digit=2;tmp.val=2;} 	else if(a=='c') {tmp.digit=2;tmp.val=3;} 	else if(a=='d') {tmp.digit=3;tmp.val=1;} 	else if(a=='e') {tmp.digit=3;tmp.val=2;} 	else if(a=='f') {tmp.digit=3;tmp.val=3;} 	else if(a=='g') {tmp.digit=4;tmp.val=1;} 	else if(a=='h') {tmp.digit=4;tmp.val=2;} 	else if(a=='i') {tmp.digit=4;tmp.val=3;} 	else if(a=='j') {tmp.digit=5;tmp.val=1;} 	else if(a=='k') {tmp.digit=5;tmp.val=2;} 	else if(a=='l') {tmp.digit=5;tmp.val=3;} 	else if(a=='m') {tmp.digit=6;tmp.val=1;} 	else if(a=='n') {tmp.digit=6;tmp.val=2;} 	else if(a=='o') {tmp.digit=6;tmp.val=3;} 	else if(a=='p') {tmp.digit=7;tmp.val=1;} 	else if(a=='q') {tmp.digit=7;tmp.val=2;} 	else if(a=='r') {tmp.digit=7;tmp.val=3;} 	else if(a=='s') {tmp.digit=7;tmp.val=4;} 	else if(a=='t') {tmp.digit=8;tmp.val=1;} 	else if(a=='u') {tmp.digit=8;tmp.val=2;} 	else if(a=='v') {tmp.digit=8;tmp.val=3;} 	else if(a=='w') {tmp.digit=9;tmp.val=1;} 	else if(a=='x') {tmp.digit=9;tmp.val=2;} 	else if(a=='y') {tmp.digit=9;tmp.val=3;} 	else if(a=='z') {tmp.digit=9;tmp.val=4;} 	return tmp; }  int main() { 	int T,i; 	int dp1[500000]; 	int dp2[500000]; 	dp1[0]=dp2[0]=1; 	dp1[1]=dp2[1]=2; 	dp1[2]=dp2[2]=4; 	dp1[3]=dp2[3]=8; 	dp1[4]=16; 	dp2[4]=15; 	for (i=5;i<=410000;i++) 	{ 		dp2[i] = (dp2[i-1] + dp2[i-2] + dp2[i-3] + 1)%N; 		dp1[i] = (dp1[i-1] + dp1[i-2] + dp1[i-3] + dp1[i-4] + 1)%N; 	} 	scanf("%d",&T); 	char str[111111]; 	long long ans=1; 	while(T--) 	{ 		ans=1; 		scanf("%s",str); 		int l=strlen(str); 		dat buffer; 		dat temp; 		temp=getChar(str[0]); 		buffer.digit=temp.digit; 		buffer.val=temp.val; 		for(i=1;i<l;i++) 		{ 			temp=getChar(str[i]); 			if(temp.digit==buffer.digit) 			{ 				buffer.val+=temp.val; 			} 			else 			{ 				if(buffer.digit==7 || buffer.digit==9) 					ans=(ans*dp1[buffer.val-1])%N; 				else 					ans=(ans*dp2[buffer.val-1])%N; 				buffer.digit=temp.digit; 				buffer.val=temp.val; 			} 		} 		if(buffer.digit!=0) 		{ 			if(buffer.digit==7 || buffer.digit==9) 				ans=(ans*dp1[buffer.val-1])%N; 			else 				ans=(ans*dp2[buffer.val-1])%N; 		} 		printf("%lld\n",ans); 	} } 
#include<iostream> #include<cstdio> #include<vector> #include<algorithm> #include<utility>  using namespace std;  typedef long long int ULL;  vector<ULL> prime; int iterations = 10; int isp[605];  int isPrime(int n) {         if (n < 2)                 return false;         for (int i = 2; i * i <= n; i++)                 if (n % i == 0)                         return false;         return true; }  void compute() {         for (int i = 2; i <= 600; i++)         {                 if (isPrime(i))                         prime.push_back(i);         } }  const ULL mask = (1<<20)-1;  ULL mulMod(ULL a , ULL b , ULL c) {         ULL z= (a*(b&mask))%c  +  (((a<<20)%c)*(b>>20))%c;         while (z >= c)                 z -= c;         return z;  }  ULL modulo(ULL a, ULL b , ULL c) {         ULL res = 1;         while (b > 0)         {                 if (b & 1)                       res   = mulMod(res , a, c);                 a = mulMod(a , a, c);                 b >>= 1;         }         return res; }  int witness[] = {2 , 3, 5, 7 , 11};  int millerRabinTest(ULL N) {         if (N < 2)                  return false;         if (N % 2 == 0) return N == 2 ;         if (N % 3 == 0) return N == 3;         if (N % 5 == 0) return N == 5;         if (N % 7 == 0) return N == 7;         if (N % 11 == 0) return N == 11;         //if (N % 13 == 0) return N == 13;                  ULL  s = N - 1;         while ((s & 1) == 0)         {                 s /= 2;         }                  for (int i = 0; i  < iterations ; i++)         {                 ULL a = rand() % (N - 1) + 1 , temp = s;                 ULL mod = modulo(a , temp , N);                 while (temp != N - 1 && mod != 1 && mod != N - 1)                 {                         mod = mulMod(mod , mod , N);                         temp *= 2;                 }                 if (mod != N - 1 && (temp & 1) ==  0)                         return false;         }         return true; }  ULL solve(ULL N) {         N += 2;         if (N == 2)                 return 1;         for (int i = 0; i <= 600; i++)                 isp[i] = true;          /*                for (int i = 0; i < prime.size(); i++)         {                        ULL p = prime[i];                 if (p > N)                               break;                 ULL t = p;                 t = ((N  + p - 1) / p) * p;                 while (t < N + 600)                 {                         //cout<<t<<" ";                         if (p < t)                                 isp[t - N]  = false;                         t += p;                 }         }         /*         for (int i = 0; i < 600; i++)                 if (isp[i])                         cout<<i<<endl;                  //return true;         //cout<<millerRabinTest(34)<<endl;         */         for (ULL i = N ; ; i++)         {                 if (millerRabinTest(i))                 {                         //cout<<i<<endl;                         //cout<<"here"<<endl;                         return i;                 }         } }  int main() {         compute();         int T;         scanf("%d" , &T);                  while (T--)         {                 ULL x ;                 scanf("%llu" , &x);                 printf("%llu\n" , solve(x));         }                  return 0; }
#include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<string> #include<iostream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath> #include<string> //#include<debugger>   using namespace std;   #define s(n)					scanf("%d",&n) #define sl(n) 					scanf("%lld",&n) #define sf(n) 					scanf("%lf",&n) #define ss(n) 					scanf("%s",n) #define INF						(int)1e9 #define LINF					(long long)1e18 #define EPS						1e-9 #define maX(a,b)				((a)>(b)?(a):(b)) #define miN(a,b)				((a)<(b)?(a):(b)) #define abS(x)					((x)<0?-(x):(x)) #define FOR(i,a,b)				for(int i=a;i<b;i++) #define REP(i,n)				FOR(i,0,n) #define foreach(v,c)            for( typeof((c).begin()) v = (c).begin();  v != (c).end(); ++v) #define mp						make_pair #define FF						first #define SS						second #define tri(a,b,c)				mp(a,mp(b,c)) #define XX						first #define YY						second.first #define ZZ						second.second #define pb						push_back #define fill(a,v) 				memset(a,v,sizeof a) #define all(x)					x.begin(),x.end() #define SZ(v)					((int)(v.size())) #define DREP(a)					sort(all(a)); a.erase(unique(all(a)),a.end()) #define INDEX(arr,ind)			(lower_bound(all(arr),ind)-arr.begin()) #define debug(args...)			{dbg,args; cerr<<endl;} #define dline					cerr<<endl	   void sc(char &c){ 	char temp[4];	ss(temp);	 	c=temp[0]; }   struct debugger { 	template<typename T> debugger& operator , (const T& v) 	{	 		cerr<<v<<" ";	 		return *this;	 	} } dbg;         typedef long long LL; typedef pair<int,int> PII; typedef pair<LL,LL> PLL; typedef pair<int,PII> TRI;   typedef vector<int> VI; typedef vector<LL> VL; typedef vector<PII> VII; typedef vector<PLL> VLL; typedef vector<TRI> VT;   typedef vector<VI> VVI; typedef vector<VL> VVL; typedef vector<VII> VVII; typedef vector<VLL> VVLL; typedef vector<VT> VVT;     /*Main code begins now */   int testnum;     const int BASE = 1<<17; int r[3][BASE+BASE]; int f[3][BASE+BASE];   int lo,hi,mode; void update(int ind,int beg,int end) { 	if(beg>hi || end<lo) return; 	if(lo<=beg && end<=hi) 	{ 		r[mode][ind] = end-beg+1 - r[mode][ind]; 		f[mode][ind] = 1-f[mode][ind]; 		 		int len = end-beg+1; 		for(ind>>=1,len<<=1; ind; ind>>=1,len<<=1) 		{ 			r[mode][ind] = r[mode][ind+ind] + r[mode][ind+ind+1]; 			if(f[mode][ind]) 				r[mode][ind] = len - r[mode][ind]; 		} 		return; 	} 	 	int twice=ind<<1; 	int mid = (beg+end)>>1; 	 	update(twice,beg,mid); 	update(twice+1,mid+1,end); }   void updatex(int _lo,int _hi,int _mode) { 	lo=_lo; 	hi=_hi; 	mode=_mode; 	update(1,0,BASE-1); }   int query(int ind,int beg,int end,int flip) { 	if(beg>hi || end<lo) return 0; 	if(lo<=beg && end<=hi) return flip ? end-beg+1 - r[mode][ind] : r[mode][ind]; 	 	int twice=ind<<1; 	int mid = (beg+end)>>1; 	flip = flip^f[mode][ind]; 	 	return query(twice,beg,mid,flip) + query(twice+1,mid+1,end,flip); }   int query(int _lo,int _hi,int _mode) { 	lo=_lo; 	hi=_hi; 	mode=_mode; 	return query(1,0,BASE-1,0); }   void init() { 	fill(r,0); 	fill(f,0); } 	 int NX,NY,NZ,Q;       void preprocess() {   }   void solve() { 	init(); 	for(int i=0;i<Q;i++) 	{ 		int k; s(k); 		if(k==3) 		{ 			int x1,x2,y1,y2,z1,z2; 			s(x1); s(y1); s(z1); s(x2); s(y2); s(z2); 			LL a = query(x1,x2,0); LL na = x2-x1+1-a; 			LL b = query(y1,y2,1); LL nb = y2-y1+1-b; 			LL c = query(z1,z2,2); LL nc = z2-z1+1-c; 			LL ans = a*b*c + a*nb*nc + na*b*nc + na*nb*c; 			//debug(a,na," ",b,nb," ",c,nc); 			printf("%lld\n",ans); 		} 		else 		{ 			int c1,c2;  			s(c1); s(c2); 			updatex(c1,c2,k); 		} 	} 			 		 }       bool input() { 	s(NX); s(NY); s(NZ); s(Q); 	return true; }     int main() { 	preprocess(); 	int T; s(T); 	for(testnum=1;testnum<=T;testnum++) 	{ 		if(!input()) break; 		solve(); 	} }
#include<cstdio>  #define rep(i,n) for(int i=0;i<(n);i++)  using namespace std;  typedef long long ll;  const ll M=100000007;  ll gcd(ll a,ll b){ return b?gcd(b,a%b):a; }  int main(){ 	int T; scanf("%d",&T); 	while(T--){ 		ll N,Q; scanf("%lld%lld",&N,&Q); 		printf("%lld\n",Q*(1+((Q-1)/2)/(Q/gcd(N,Q)))%M); 	} 	return 0; } 
#include<stdio.h> #include<algorithm>  using namespace std;  int list[510][55]; int likes[510]; int count_[510]; int sorted[510]; bool mark[510]; int n, set_size, favList;  void print() { 	int i; 	for(i=0;i<n;i++) 		printf("%d ", count_[i]); 	printf("\n"); 	for(i=0;i<n;i++) 		printf("%d ", count_[sorted[i]]); 	printf("\n"); }   bool cmp(int a, int b) { 	if(count_[a]<count_[b]) 		return true; 	else 		return false; }  int main() { 	int i, j, k, l, temp, t; 	bool pr = true; 	scanf("%d", &t); 	while(t--) 	{ 		for(i=0;i<510;i++) 			likes[i]=count_[i]=0; 		for(i=0;i<510;i++) 			mark[i]=false; 		for(i=0;i<510;i++) 			sorted[i]=i; 			 		scanf("%d", &n); 		for(i=0;i<n;i++) 		{ 			scanf("%d", &k); 			likes[i]=k; 			for(j=0;j<k;j++) 			{ 				scanf("%d", &l); 				list[i][j]=l; 				count_[l]++; 			} 		} 		sort(sorted, sorted+n, cmp); 		//print(); 		for(i=0;i<n;i++) 		{ 			pr = true; 			if(count_[sorted[i]]<=i) 			{ 				//printf("Enter when i: %d\n", i); 				set_size = i+1; 				favList=0; 				for(j=0;j<n;j++) 				{ 					for(k=0;k<likes[j];k++) 					{ 						if(count_[list[j][k]]<=i) 						{ 							favList++; 							break; 						} 					} 				} 				if(favList<=i) 				{ 					printf("not safe\n"); 					pr = false; 					break; 				} 			} 		} 		if(pr) 			printf("safe\n"); 	} 	return 0; } 
#include<iostream> #include<stdio.h> using namespace std;  int a[177]={1,2,3,4,6,8,9,10,12,16,18,20,24,30,32,36,40,48,60,64,72,80,84,90,96,100,108,120,128,144,160,168,180,192,200,216,224,240,256,288,320,336,360,384,400,432,448,480,504,512,576,600,640,672,720,768,800,864,896,960,1008,1024,1152,1200,1280,1344,1440,1536,1600,1680,1728,1792,1920,2016,2048,2304,2400,2688,2880,3072,3360,3456,3584,3600,3840,4032,4096,4320,4608,4800,5040,5376,5760,6144,6720,6912,7168,7200,7680,8064,8192,8640,9216,10080,10368,10752,11520,12288,12960,13440,13824,14336,14400,15360,16128,16384,17280,18432,20160,20736,21504,23040,24576,25920,26880,27648,28672,28800,30720,32256,32768,34560,36864,40320,41472,43008,46080,48384,49152,51840,53760,55296,57600,61440,62208,64512,65536,69120,73728,80640,82944,86016,92160,96768,98304,103680,107520,110592,115200,122880,124416,129024,131072,138240,147456,153600,161280}; char value[168][100] = {"1","2","4","6","12","24","36","48","60","120","180","240","360","720","840","1260","1680","2520","5040","7560","10080","15120","20160","25200","27720","45360","50400","55440","83160","110880","166320","221760","277200","332640","498960","554400","665280","720720","1081080","1441440","2162160","2882880","3603600","4324320","6486480","7207200","8648640","10810800","14414400","17297280","21621600","32432400","36756720","43243200","61261200","73513440","110270160","122522400","147026880","183783600","245044800","294053760","367567200","551350800","698377680","735134400","1102701600","1396755360","2095133040","2205403200","2327925600","2793510720","3491888400","4655851200","5587021440","6983776800","10475665200","13967553600","20951330400","27935107200","41902660800","48886437600","64250746560","73329656400","80313433200","97772875200","128501493120","146659312800","160626866400","240940299600","293318625600","321253732800","481880599200","642507465600","963761198400","1124388064800","1606268664000","1686582097200","1927522396800","2248776129600","3212537328000","3373164194400","4497552259200","6746328388800","8995104518400","9316358251200","13492656777600","18632716502400","26985313555200","27949074753600","32607253879200","46581791256000","48910880818800","55898149507200","65214507758400","93163582512000","97821761637600","130429015516800","195643523275200","260858031033600","288807105787200","391287046550400","577614211574400","782574093100800","866421317361600","1010824870255200","1444035528936000","1516237305382800","1732842634723200","2021649740510400","2888071057872000","3032474610765600","4043299481020800","6064949221531200","8086598962041600","10108248702552000","12129898443062400","18194847664593600","20216497405104000","24259796886124800","30324746107656000","36389695329187200","48519593772249600","60649492215312000","72779390658374400","74801040398884800","106858629141264000","112201560598327200","149602080797769600","224403121196654400","299204161595539200","374005201994424000","448806242393308800","673209363589963200","748010403988848000","897612484786617600","1122015605983272000","1346418727179926400","1795224969573235200","2244031211966544000","2692837454359852800","3066842656354276800","4381203794791824000","4488062423933088000","6133685312708553600","8976124847866176000","9200527969062830400"};   int main() { 	int T; 	scanf("%d",&T); 	while(T--) 	{ 		int i; 		int n; 		scanf("%d",&n); 		for(i=0;i<167;i++) 		{ 			if(a[i]>n) 			{ 				printf("win %s\n",value[i]); 				break; 			}	 		} 		if(i==167) 			printf("lose\n"); 	} } 
#include<cmath> #include<cstdio> #include<vector>  #define rep(i,n) for(int i=0;i<(n);i++)  using namespace std;  const double PI=acos(-1);  const int V_MAX=100;  bool augment(int u,bool *vis,int match[2][V_MAX],const vector<int> *G){ 	if(u==-1) return true;  	rep(i,G[u].size()){ 		int v=G[u][i]; 		if(!vis[v]){ 			vis[v]=true; 			if(augment(match[1][v],vis,match,G)){ 				match[0][u]=v; 				match[1][v]=u; 				return true; 			} 		} 	} 	return false; }  int bipartite_matching(int L,int R,const vector<int> *G){ 	static int match[2][V_MAX]; 	rep(u,L) match[0][u]=-1; 	rep(v,R) match[1][v]=-1;  	int res=0; 	static bool vis[V_MAX]; 	rep(u,L){ 		rep(v,R) vis[v]=false; 		if(augment(u,vis,match,G)) res++; 	} 	return res; }  double dist(double r,double la1,double lo1,double la2,double lo2){ 	double x1=r*cos(lo1)*cos(la1),y1=r*sin(lo1)*cos(la1),z1=r*sin(la1); 	double x2=r*cos(lo2)*cos(la2),y2=r*sin(lo2)*cos(la2),z2=r*sin(la2); 	double d=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2)); 	double theta=acos(1-d*d/(2*r*r)); 	return r*theta; }  int main(){ 	int T; scanf("%d",&T); 	while(T--){ 		int n,m; 		double r; scanf("%d%d%lf",&n,&m,&r); 		double lat1[100],lon1[100],lat2[100],lon2[100]; 		rep(u,n) scanf("%lf%lf",lat1+u,lon1+u), lat1[u]*=PI/180, lon1[u]*=PI/180; 		rep(v,m) scanf("%lf%lf",lat2+v,lon2+v), lat2[v]*=PI/180, lon2[v]*=PI/180;  		double lo=0,hi=0; 		double d[100][100]; 		rep(u,n) rep(v,m) { 			d[u][v]=dist(r,lat1[u],lon1[u],lat2[v],lon2[v]); 			hi=max(hi,d[u][v]); 		}  		while(abs(hi-lo)/hi>1e-7){ 			double mi=(lo+hi)/2; 			vector<int> G[100]; 			rep(u,n) rep(v,m) if(d[u][v]<mi) G[u].push_back(v); 			if(bipartite_matching(n,m,G)==m) hi=mi; else lo=mi; 		} 		printf("%E\n",(lo+hi)/2); 	}  	return 0; } 
#include<iostream> #include<cstdio> #include<cstring>  using namespace std;  typedef long long int LL;  int N , M , Q; LL K;  int adjMat[105][105]; int visited[105]; int isConnected;  const LL mod = 100000007LL;  void dfs(int u , int target) {         visited[u] = true;         if (u == target) {                 isConnected = true;                 return;         }         for (int i = 0; i < N ;i ++) {                 if (adjMat[u][i] == 1 && !visited[i])                          dfs(i,target);         } }  void DFS(int u) {         visited[u] = true;         for (int i = 0; i < N; i++)                  if (!visited[i] && adjMat[u][i] == 1)                         DFS(i); }  int main() {         int T;         scanf("%d",&T);         while (T--) {                 memset(adjMat,0,sizeof(adjMat));                 memset(visited,0,sizeof(visited));                                                          scanf("%d%d%d",&N,&M,&Q);                 for (int i = 0; i < M; i++) {                         int t1 , t2;                         scanf("%d%d",&t1,&t2);                         adjMat[t1][t2] = 1;                         adjMat[t2][t1] = 1;                 }                                  int C = 0;                                  for (int i = 0 ; i < N ; i++) {                         if (!visited[i]) {                                 DFS(i);                                 C++;                         }                 }                                                  while (Q--) {                         isConnected = false;                         scanf("%lld",&K);                         if (K == 0 ) {                                 int a , b;                                  scanf("%d%d",&a,&b);                                 memset(visited,0,sizeof(visited));                                 dfs(a,b);                                 if (isConnected) {                                         adjMat[a][b] = 1;                                         adjMat[b][a] = 1;                                                   } else {                                         C --;                                         adjMat[a][b] = 1;                                         adjMat[b][a] = 1;                                 }                         } else if (K == 1) {                                 int a , b;                                  scanf("%d%d",&a,&b);                                 memset(visited,0,sizeof(visited));                                 dfs(a,b);                                 if (isConnected) {                                         adjMat[a][b] = 0;                                         adjMat[b][a] = 0;                                         isConnected = false;                                         memset(visited,0,sizeof(visited));                                         dfs(a,b);                                         if (!isConnected) C++;                                 }                                           } else {                                 LL ans = 1;                                 for (int i = 0; i < C ; i++) {                                         ans *= K;                                         if (ans >= mod)                                                 ans %= mod;                                 }                                 for (int i = 0;i < N - C; i++) {                                         ans *= (K - 1);                                         if (ans >= mod)                                                  ans %= mod;                                 }                                 printf("%lld\n", ans);                         }                 }                 }                return 0; }
#include<cstdio> #include<cstdlib> #include<cstring> #include<cmath> #include<cctype>  #include<iostream> #include<algorithm> #include<vector> #include<map>  using namespace std;  #define ll long long #define pb push_back #define SZ(a) ((int)a.size()) #define Max_N 1100 #define Set(a, b) memset(a, b, sizeof(a))  ll dp[Max_N]; vector<ll>V[Max_N];  ll process(ll cur);  int main() {     ll t, i, j, n, m, a, b;     scanf(" %lld", &t);         for(j=1;j<=t;j++)         {             scanf(" %lld %lld", &n, &m);             for(i=0;i<m;i++)             {                 scanf(" %lld %lld", &a, &b);                 V[a].pb(b);             }             ll Max=0;             Set(dp, 0);             for(i=0;i<n;i++)             {                 Max=max(Max, process(i));             }             for(i=0;i<n;i++) V[i].clear();             printf("%lld\n", Max);         }     return 0; }  ll process(ll cur) {     ll Max=1;     ll i, j;     if(dp[cur]!=0) return dp[cur];     for(i=0;i<SZ(V[cur]);i++)         Max=max(Max, process(V[cur][i])+1);     dp[cur]=Max;     return Max; } 
//#pragma comment(linker, "/STACK:16777216") #include <iostream> #include <cstdio> #include <cmath> #include <set> #include <vector> #include <map> #include <cstring> #include <sstream> #include <algorithm> #include <string> #include <queue> #include <fstream>  #define FOR(i,a,b) for(int i = (a); i <= (b); i++) #define FR(i,a) for(int i = 0; i < (a); i++) #define DR(i,a) for(int i = (a)-1; i >=0; i--) #define DOWN(i,a,b) for(int i = (a); i >= (b); i--) #define FORD(i,a,b) for(int i = (a), _b = (b); i >= _b; i--) #define REPD(i,n) for(int i = (n) - 1; i >= 0; i--) #define PB push_back #define MP make_pair #define F first #define S second #define RESET(c,x) memset(c,x,sizeof(c)) #define SIZE(c) (c).size() #define ALL(c) (c).begin(), (c).end()  #define REP(i,a) for(int i = 0; i < (a); i++)  #define sqr(x) ((x)*(x)) #define oo 2000000009  using namespace std; /*************************TEMPLATE**********************************/ long long convertToNum(string s) {     long long val = 0; FR(i,s.size()) val = val * 10 + s[i] - '0';     return val; } char bu[50]; string convertToString(int a) {     sprintf(bu,"%d",a);     return string(bu); } long long GCD(long long x,long long y)  {     if (!x) return y; if (!y) return x;     if (x == y) return x; if (x < y) return GCD(x,y%x); else return GCD(x%y,y); } long long POW(long long x,long long y,long long Base){     if (!y) return 1; long long u = POW(x,y/2,Base);     u = (u * u) % Base;     if (y & 1) return (u * x) % Base; else return u; }  //newstate = (newstate-1) & oldstate /**************************CODE HERE*****************************/  void OPEN() {     freopen("test.in","r",stdin);     freopen("test.out","w",stdout); } #define maxn 60003 int n,Q,g[maxn]; int x[maxn],y[maxn], Trace[maxn], PREV[maxn],d[maxn]; bool dd[maxn], onRoad[maxn], roadNode[maxn]; priority_queue< pair<int,int> > Heap; vector<int> list; vector< pair<int,int> > a[maxn]; vector< int> cs[maxn]; int D[maxn],f[maxn]; int m,q;  set< pair<int,int> > se; int parents[maxn]; void Print_Path(int source,int dest) { 	if(source==dest) 	{ 		//printf("%d ",source); 		list.push_back(source); 	} 	else if(parents[dest]==-1) 	{ 		//printf("No path from %d to %d\n",source,dest); 	} 	else 	{ 		Print_Path(source,parents[dest]); 	//	printf("%d ",dest); 		list.push_back(dest); 	} }  void init() {     FR(i,n) g[i] = oo, dd[i] = true;     g[n-1] = 0;     while (!Heap.empty()) Heap.pop();     Heap.push( make_pair(-g[n-1],n-1));     while (!Heap.empty()) {         pair<int,int> tmp = Heap.top();         Heap.pop();         if (!dd[tmp.second]) continue;         int u = tmp.second;         dd[u] = false;         FR(i,a[u].size()) {             int v = a[u][i].first;             if (!dd[v]) continue;             if (g[v] > g[u] + a[u][i].second) {                 g[v] = g[u] + a[u][i].second;                 Heap.push( make_pair(-g[v],v) );             }         }     }          FR(i,n) d[i] = oo, dd[i] = true, Trace[i] = -1,parents[i]=-1;     d[0] = 0;     while (!Heap.empty()) Heap.pop();     Heap.push( make_pair(-d[0],0));     while (!Heap.empty()) {         pair<int,int> tmp = Heap.top();         Heap.pop();         if (!dd[tmp.second]) continue;         int u = tmp.second;         dd[u] = false;         FR(i,a[u].size()) {             int v = a[u][i].first;             if (!dd[v]) continue;             if (d[v] > d[u] + a[u][i].second) {                 d[v] = d[u] + a[u][i].second;                 Trace[v] = cs[u][i]; 				parents[v]=u;                 Heap.push( make_pair(-d[v],v) );             }         }     }     FR(i,m) onRoad[i] = false;     FR(i,n) roadNode[i] = false;     int i = n-1,j;     list.clear();     //list.push_back(i);     roadNode[n-1] = true; 	Print_Path(0,n-1);     while (i != 0) {         j = Trace[i];         onRoad[j] = true;         if (y[j] == i) PREV[i] = x[j], i = x[j];         else PREV[i] = y[j], i = y[j];       //  list.push_back(i);         roadNode[i] = true;     }          //reverse(list.begin(),list.end());     FR(i,n) dd[i] = true;     while (!Heap.empty()) Heap.pop();          FR(i,n) D[i] = oo;     int save = oo;     se.clear();     for(int i = list.size() - 1; i >= 1; i--) {         int v = list[i];         int u = PREV[v];         int roadNo = Trace[v];         f[roadNo] = oo;         dd[v] = false; //        if (D[v] > g[v])          {             D[v] = g[v];             Heap.push(make_pair(-g[v],v));             while (!Heap.empty()) {                 pair<int,int> tmp = Heap.top();                 Heap.pop();                 int u = tmp.second;                 FR(i,a[u].size()) {                     if (onRoad[cs[u][i]]) continue;                     int v = a[u][i].first;                     if (D[v] > D[u] + a[u][i].second) {                         D[v] = D[u] + a[u][i].second;                         if (!roadNode[v])                         Heap.push(make_pair(-D[v],v) );                         if (dd[v] && roadNode[v] && f[roadNo] > D[v] + d[v]) {                             se.insert( make_pair(D[v] + d[v], v) );                         }                     }                 }                }         }         while (!se.empty()) {             set< pair<int,int> > ::iterator tmp = se.begin();             if (dd[(*tmp).second]) {                 f[roadNo] = (*tmp).first;                 break;             }             se.erase(tmp);         }     } } int main() { //    OPEN();     int ntest;     scanf("%d",&ntest);     while (ntest--) {         scanf("%d%d%d",&n,&m,&q);         FR(i,n) a[i].clear(), cs[i].clear();         int u,v,len;         FR(i,m) {             scanf("%d%d%d",&x[i],&y[i],&len);             u = x[i], v = y[i];             a[u].push_back( make_pair(v,len) );             a[v].push_back( make_pair(u,len) );             cs[u].push_back(i);             cs[v].push_back(i);         }         init();         int index;         FR(i,q) {             scanf("%d",&index);             if (n == 1) {                 printf("%d\n",0);                 continue;             }             if (!onRoad[index]) {                 printf("%d\n",d[n-1]);             }             else {                 if (f[index] == oo) printf("no route for corrupt ministers!!!\n");                 else printf("%d\n",f[index]);             }         }     }     return 0; }
#include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<string> #include<iostream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath>  using namespace std;  #define s(n)					scanf("%d",&n); #define sl(n)                   scanf("%lld", &n); #define sf(n) 					scanf("%lf",&n); #define ss(n) 					scanf("%s",n); #define INF						(int)1e9 #define LINF					(long long)1e18 #define EPS						1e-12 #define FOR(i,a,b)				for(int i=a;i<b;i++) #define REP(i,n)				FOR(i,0,n) #define foreach(v,c)            for( typeof((c).begin()) v = (c).begin();  v != (c).end(); ++v) #define mp						make_pair #define FF						first #define SS						second #define tri(a,b,c)				mp(a,mp(b,c)) #define XX						first #define YY						second.first #define ZZ						second.second #define pb						push_back #define fill(a,v) 				memset(a,v,sizeof a) #define all(x)					x.begin(),x.end() #define SZ(v)					((int)(v.size())) #define DREP(a)					sort(all(a)); a.erase(unique(all(a)),a.end()) #define INDEX(arr,ind)			(lower_bound(all(arr),ind)-arr.begin()) #define debug(args...)			{dbg,args; cerr<<endl;} #define dline					cerr<<endl #define SP                      system("pause"); #define HAHA                    printf("HAHA\n"); #define mod                     10000  void debugarr(int *arr, int ind1, int ind2) { 	cout<<"[ "; 	for(int i=ind1;i<=ind2;i++) 		cout<<arr[i]<<" "; 	cout<<"]"<<endl; }  typedef long long LL; typedef pair<int,int> PII; typedef pair<LL,LL> PLL; typedef pair<LL,PII> TRI;  typedef vector<int> VI; typedef vector<LL> VL; typedef vector<PII> VII; typedef vector<PLL> VLL; typedef vector<TRI> VT;  typedef vector<VI> VVI; typedef vector<VL> VVL; typedef vector<VII> VVII; typedef vector<VLL> VVLL; typedef vector<VT> VVT;  /////////////////////////////////////////////////////////////////////////////////////////  int n, m; int lev[10005]; int p[10005][15]; VI a[10005]; VI b[10005]; int dp[10005];  void dfs1(int u, int w) {     REP(i, a[u].size())     {         int v = a[u][i];         if(v == w) continue;         p[v][0] = u;         lev[v] = lev[u]+1;         dfs1(v, u);     } }  void dfs2(int u, int w) {     REP(i, a[u].size())     {         int v = a[u][i];         if(v == w) continue;         dfs2(v, u);         dp[u] += dp[v];     } }  int lca(int u, int v) {     if(lev[u] < lev[v]) swap(u, v);     for(int i = 14; i >= 0; i--)     {         if(lev[u]-(1<<i) >= lev[v]) u = p[u][i];     }     if(u == v) return u;     for(int i = 14; i>=0; i--)     {         if((p[u][i] != -1) && (p[u][i] != p[v][i]))         {             u = p[u][i];             v = p[v][i];         }     }     return p[u][0]; }  int main() {     int te; s(te) while(te--)     {         fill(dp, 0);         s(n) s(m)         FOR(i, 0, n)         {             a[i].clear();             b[i].clear();         }         FOR(i, 1, n)         {             int p, q; s(p) s(q)             a[p].pb(q);             a[q].pb(p);         }         FOR(i, 0, m)         {             int p, q; s(p) s(q)             b[p].pb(q);             b[q].pb(p);         }         lev[0] = 0;         fill(p, -1);         dfs1(0, -1);         FOR(j, 1, 15) FOR(i, 0, n) if(p[i][j-1] != -1) p[i][j] = p[p[i][j-1]][j-1];         FOR(u, 0, n) REP(i, b[u].size())         {             int v = b[u][i];             if(v < u)             {                 dp[u]++, dp[v]++, dp[lca(u, v)]-=2;             }         }         dfs2(0, -1);         int ans = 0;         FOR(i, 0, n) ans = max(ans, dp[i]);         printf("%d\n", ans);     } }  
#include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<string> #include<iostream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath> #include<string>   using namespace std;   #define s(n)                                 scanf("%d",&n) #define sl(n)                                   scanf("%lld",&n) #define sf(n)                                   scanf("%lf",&n)   #define EPS                                             1e-9   #define FOR(i,a,b)                              for(int i=a;i<b;i++) #define REP(i,n)                                FOR(i,0,n) #define foreach(v,c)            for( typeof((c).begin()) v = (c).begin();  v != (c).end(); ++v)   #define mp                                              make_pair #define pb                                              push_back   #define FF                                              first #define SS                                              second   #define tri(a,b,c)                              mp(a,mp(b,c)) #define XX                                              first #define YY                                              second.first #define ZZ                                              second.second   /*Important ones*/ #define fill(a,v)                               memset(a,v,sizeof a)     //Works properly only for v = 0 or -1 #define all(x)                                  x.begin(),x.end()   #define SZ(v)                                   ((int)(v.size())) #define DREP(a)                                 sort(all(a)); a.erase(unique(all(a)),a.end()) #define INDEX(arr,ind)                  (lower_bound(all(arr),ind)-arr.begin())   //typedefs. Use if you feel comfortable typedef pair<int,int> PII; typedef pair<long long,long long> PLL; typedef pair<int,PII> TRI;  typedef vector<int> VI; typedef long long LL; typedef vector<LL> VL; typedef vector<PII> VII; typedef vector<PLL> VLL; typedef vector<TRI> VT;   typedef vector<VI> VVI; typedef vector<VL> VVL; typedef vector<VII> VVII; typedef vector<VLL> VVLL; typedef vector<VT> VVT;  #define MAX 305  #define INF 1e9  int N, M, P, C, rech[MAX], adm[MAX][MAX];  int main(){ 	 	int X, Y, T; 	 	s(N);	s(M);	s(P);	s(C); 	FOR(i,0,P){ 		s(T); 		rech[T] = 1; 	} 	rech[N-1] = rech[0] = 1; 	FOR(i,0,N) 		FOR(j,0,N) 			adm[i][j] = INF; 	FOR(i,0,M){ 		s(X);	s(Y);	s(T); 		adm[X][Y] = adm[Y][X] = T; 	} 	FOR(k,0,N) 		FOR(i,0,N) 			FOR(j,0,N) 				adm[i][j] = min(adm[i][j], adm[i][k]+adm[k][j]); 	FOR(i,0,N) 		FOR(j,0,N) 			if(adm[i][j] > C || !rech[i] || !rech[j]) 				adm[i][j] = INF; 	FOR(k,0,N) 		FOR(i,0,N) 			FOR(j,0,N) 				adm[i][j] = min(adm[i][j], adm[i][k]+adm[k][j]); 	if(adm[0][N-1] == INF) 		cout<<-1<<endl; 	else 		cout<<adm[0][N-1]<<endl; 	 	return 0; 	 } 
/*takes two integers N and M and tries to find twice the sum of the quotients of the integer division of (i * N) by M varying i from 0 to M-1 both included. But as he started computing the sums for larger values of M and N, things started becoming very complex. So he has asked for your help. You need to output the sum that Bob needs. Input  The first line of the input contains an integer T denoting the number of test cases. Saurav Shekhar(sauravshekhar01@gmail.com) IOPC 2013*/  #include<stdio.h>  long long int gcd(long long int a, long long int b) {	long long int c; 	c = a%b; 	while(c) 	{	//printf("a = %d,b = %d\n",a,b); 		a = b; 		b = c; 		c = a%b; 	} 	//printf("gcd = %d\n",b); 	return b; }  int main() {	 	int T; 	long long int M,N,k=0; 	long long int sum = 0; 	scanf("%d",&T); 	while(T--) 	{ 		k=0; sum=0; 		scanf("%lld %lld",&M,&N);	//printf("%d\n",M); 		if(M>N) 			k = gcd(M,N); 		else 			k = gcd(N,M); 		sum = M*N -M -N + k ; 		printf("%lld\n",sum); 	} 	return 0; } 
#include <cstdio> #include <algorithm> #include<iostream> using namespace std;  #define S(x) scanf("%d",&x)  int main() {     int t,n,x,y;     S(t);     while(t--)     {         S(n);         int a[n],b[n];         for(int i=0;i<n;i++)         {             a[i]=0;             b[i]=0;         }             int r1,r2;         S(r1);         for(int i=0;i<n-1;i++)         {             S(x);S(y);             a[x]++;a[y]++;         }         S(r2);         for(int i=0;i<n-1;i++)         {             S(x);S(y);             b[x]++;b[y]++;         }         int ans1=a[r1],ans2=b[r2];         if(ans1!=ans2)putchar('0');         else         {         	std::sort(a,a+n);             std::sort(b,b+n); 			bool flag=false;             for(int i=0;i<n;i++)             {                 if(a[i]!=b[i])                 {                     flag=true;                     break;                 }             }             if(flag==false)putchar('1');             else putchar('0');         }         putchar(10);     } }
#include <cstdio> #include <cstdlib> #include <iostream> #include <cstring> using namespace std;  int main() { 	int test,n; 	scanf("%d",&test); 	while(test--) 	{ 		scanf("%d",&n); 		if(n%2==0 || n%3==0) 			printf("YES\n"); 		else 			printf("NO\n"); 	} 	return 0; }
#include <cstdio> #include <vector> #include <queue> using namespace std;  vector <int> adj[100000]; int degree[100000]={0};  void solve(int vertices,int lim) { 	int vertex; 	queue <int> store; 	for(int i=0;i<vertices;i++) 		if(degree[i]<lim) 		{ 			degree[i]=0; 			store.push(i); 		} 	while(!store.empty()) 	{ 		vertex=store.front(); 		store.pop(); 		degree[vertex]=0; 		for(int i=0;i<adj[vertex].size();i++) 			if(degree[adj[vertex][i]]) 			{ 				degree[adj[vertex][i]]--; 				if(degree[adj[vertex][i]]!=0 && degree[adj[vertex][i]]<lim) 					store.push(adj[vertex][i]); 			} 	} }  int main() { 	int vertices,edges,lim,x,y; 	scanf("%d %d %d",&vertices,&edges,&lim); 	for(int i=0;i<edges;i++) 	{ 		scanf("%d %d",&x,&y); 		adj[x].push_back(y); 		adj[y].push_back(x); 		degree[x]++; 		degree[y]++; 	} 	solve(vertices,lim); 	int cnt=0; 	for(int i=0;i<vertices;i++) 		if(degree[i]) 			cnt++; 	printf("%d\n",cnt); 	return 0; }
#include<iostream> #include<cstdio> #include<cstdlib> #include<vector> #include<queue> #include<map> #include<algorithm> #include<cstring> #include<cmath> #include<stack> #include<string> #include<cctype> #include<list> #include<set> #include<deque> #include<queue> #include<bitset> #include<functional> #include<numeric> #include<utility> #include<sstream> #include<iomanip> #include<ctime>   using namespace std;   long long int  prime[100000]; long long int p[10000],j;long long int m,MOD=1000000007; long long power(long int a,long long int b) { 	long long x=1,y=a;  	while(b > 0) 	{ 		if(b%2 == 1) 		{ 			x=(x*y); 			if(x>m) x%=m; 		} 		y = (y*y); 		if(y>m) y%=m;  		b /= 2; 	} 	return x; }   int main() {     long long int i,c,t,n,hcf;c=0;m=MOD;     long long int ans,curr,y,k,p1;     long long int lcm[100005];     for(i=0;i<100000;i++)prime[i]=0;     for(j=2;j+j<100000;j+=1) prime[2*j]=1;     for(i=3;i<3200;i+=2)     {                                         if(prime[i]==1) continue;           for(j=i;i*j<100000;j+=2) prime[i*j]=1;     }   j=0;   for(i=2;i<100000;i++) {if(prime[i]==0){ p[j]=i;j++;}}   lcm[0]=1;   lcm[1]=1;   for(i=2;i<100002;i++)   {                    t=i;                        if(!prime[i])lcm[i]=(lcm[i-1]*i)%m;                        else                        {c=0;              for(k=0;(p[k]*p[k]<=t)&&(k<j);k++)              {                                       if(i%p[k]==0){p1=p[k];c++;while(i%p[k]==0){i=i/p[k];}}                                       if(c>=1)break;              }                                       if((c==1)&&(i==1))lcm[t]=(lcm[t-1]*p1)%m;                                       else lcm[t]=lcm[t-1];                                       }                                                                              i=t; }                                                    /*for(i=0;i<10;i++)printf("%lld ",lcm[i]);*/   scanf("%lld",&t);   while(t--)   {             scanf("%lld",&n);n++;             /*for(i=0;(i<j)&&(p[i]<=n);i++)             {                                       curr=0;c=p[i];                                       while(c<=n)                                       {                                            curr++;                                            c=c*p[i];                                       }                                       y=p[i];//printf("%lld ",curr);  	while(curr > 0) 	{ 		if(curr%2 == 1) 		{ 			ans=(ans*y); 			if(ans>m) ans%=m; 		} 		y = (y*y); 		if(y>m) y%=m;  		curr /= 2; 	}              }*/                               ans=lcm[n];             ans=(ans*power(n,m-2))%m;                     printf("%lld\n",ans);     }                                                                                                                                                   return 0;     } 
#include <cstdio> #include <cstring> #include <queue>  int M, N, C, D; int dp[102*100*100*10];  char map[102][101][10];  inline int encrypt(int n, int c, int r, int d){     return ((n * C + c) * C + r) * D + d; }  inline void decrypt(int &n, int &c, int &r, int &d, int val){     d = val % D; val /= D;     r = val % C; val /= C;     c = val % C; val /= C;     n = val; }  void go(int n, int c, int r, int d, int val, std::queue<int>& que){      int obc = (n == 0 || n == N + 1)? c: ((((n + d) & 1)? c + r: c - r) + C) % C;     if(map[n][obc][d] == 'X') return;      int idx = encrypt(n, c, r, d);     if(dp[idx] == -1) dp[idx] = val, que.push(idx);  }  int main(){      scanf("%d %d %d %d\n" ,&M ,&N ,&C ,&D);      memset(dp, -1, sizeof(dp));      for(int i = 0; i < D; i++){         for(int j = 0; j < N+2; j++){             static char buf[200]; gets(buf);             for(int k = 0; k < C; k++) map[j][k][i] = buf[k];         }     }      int st, ed;     for(int c = 0; c < C; c++){         for(int d = 0; d < D; d++){             if(map[0][c][d] == 'S') st = encrypt(0, c, 0, d);         }     }      int ans = -1;     dp[st] = 0;     std::queue<int> que; que.push(st);     while(!que.empty()){          int n, c, r, d, idx;         idx = que.front(); que.pop();         if(dp[idx] > M) break;          decrypt(n, c, r, d, idx);         if(map[n][c][d] == 'D'){             ans = dp[idx];             break;         }          int nr = (r + 1) % C, stp = dp[idx] + 1;         if(n > 0) go(n - 1, c, nr, d, stp, que);         if(n < N + 1) go(n + 1, c, nr, d, stp, que);         if(c > 0) go(n, c - 1, nr, d, stp, que);         if(c < C - 1) go(n, c + 1, nr, d, stp, que);         if(d > 0) go(n, c, nr, d - 1, stp, que);         if(d < D - 1) go(n, c, nr, d + 1, stp, que);         go(n, c, nr, d, stp, que);      }      printf("%d\n" ,ans);  }
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring>  using namespace std; typedef pair<int, int> ii; #define int_max 200000000000  #define LL long long #define mp make_pair #define pb push_back LL gcd(LL m, LL n){ LL r; while (n != 0){ r=m%n; m=n; n=r;} return m; }  LL mod;  long long int expmod(int a,int b) { 	long long int x=1,y=a; 	while(b>0) 	{ 		if(b&1) x=(x*y)%mod; 		y=(y*y)%mod; 		b>>=1; 	} 	return x; } int main() { 	int t; 	scanf("%d", &t); 	while(t--) 	{ 		int n; 		scanf("%d", &n); 		mod=n*n; 		LL ans=expmod(2, n)+1; 		ans=ans%mod; 		printf("%lld\n", ans); 	}  	return 0; }  
#include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<string> #include<iostream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath> #include<string>   using namespace std;   #define s(n)                                 scanf("%d",&n) #define sl(n)                                   scanf("%lld",&n) #define sf(n)                                   scanf("%lf",&n)   #define EPS                                             1e-9   #define FOR(i,a,b)                              for(int i=a;i<b;i++) #define REP(i,n)                                FOR(i,0,n) #define foreach(v,c)            for( typeof((c).begin()) v = (c).begin();  v != (c).end(); ++v)   #define mp                                              make_pair #define pb                                              push_back   #define FF                                              first #define SS                                              second   #define tri(a,b,c)                              mp(a,mp(b,c)) #define XX                                              first #define YY                                              second.first #define ZZ                                              second.second   /*Important ones*/ #define fill(a,v)                               memset(a,v,sizeof a)     //Works properly only for v = 0 or -1 #define all(x)                                  x.begin(),x.end()   #define SZ(v)                                   ((int)(v.size())) #define DREP(a)                                 sort(all(a)); a.erase(unique(all(a)),a.end()) #define INDEX(arr,ind)                  (lower_bound(all(arr),ind)-arr.begin())   //typedefs. Use if you feel comfortable typedef pair<int,int> PII; typedef pair<long long,long long> PLL; typedef pair<int,PII> TRI;  typedef vector<int> VI; typedef long long LL; typedef vector<LL> VL; typedef vector<PII> VII; typedef vector<PLL> VLL; typedef vector<TRI> VT;   typedef vector<VI> VVI; typedef vector<VL> VVL; typedef vector<VII> VVII; typedef vector<VLL> VVLL; typedef vector<VT> VVT;  #define MAX 1010  #define INF 1e9 #define DIST(i,j) (abs(X[i]-X[j])+abs(Y[i]-Y[j])+abs(Z[i]-Z[j])) /* struct node{ 	int x, y, z, d; 	node(){} 	node(int X, int Y, int Z, int D){ 		x = X;	y = Y;	z = Z;	d = D; 	} };  bool operator < (node &a, node &b){ 	return a.d>b.d; } */ int N, X[MAX], Y[MAX], Z[MAX], pref[MAX], dp[MAX], ans;  int main(){ 	 	int tests; 	 	s(tests); 	FOR(testcases,0,tests){ 		s(N); 		FOR(i,0,N){ 			s(X[i]); 			s(Y[i]); 			s(Z[i]); 			if(i) 				pref[i] = pref[i-1] + DIST(i-1,i); 			else 				pref[i] = 0; 		} 		dp[0] = 0; 		FOR(i,1,N) 			dp[i] = pref[i-1]; 		FOR(i,2,N) 			FOR(j,1,i) 				dp[i] = min(dp[i], dp[j]+DIST(j-1,i)+pref[i-1]-pref[j]); 		ans = INF; 		FOR(i,1,N) 			ans = min(ans, dp[i]+pref[N-1]-pref[i]); 		printf("%d\n", ans); 	} 	 	return 0; 	 } 
#include <cstdio> #include <cstdlib> #include <iostream> #include <cstring> using namespace std;  bool can_send_msg(int x,int y,int u,int a[]) { 	while(a[x]!=u && a[x]!=y) 	{ 		x=a[x]; 	} 	if(a[x]==u && a[x]!=y) 		return 0; 	else 		return 1; }  int main() { 	int n,q; 	int u,x,y; 	scanf("%d %d",&n,&q); 	int a[n+1]; 	scanf("%d",&u); 	a[u]=u; 	for(int i=1;i<n;i++) 	{ 		scanf("%d %d",&x,&y); 		a[y]=x; 	} 	for(int i=0;i<q;i++) 	{ 		scanf("%d %d",&x,&y); 		if(can_send_msg(x,y,u,a)) 			printf("1\n"); 		else if(can_send_msg(y,x,u,a)) 			printf("-1\n"); 		else 			printf("0\n"); 	} 	return 0; }
#include<stdio.h> #include<math.h> #include<stdlib.h> #include<string.h> #include<ctype.h> #include<stack> #include<queue> #include<vector> #include<algorithm> #define MOD 1000000007 typedef long long LL ; int fact[10000005] ;  int main(){     int t,p,i,j;     LL rem,n,quo,ans;     fact[1] = 1;     scanf("%d",&t);     for(i=1;i<=t;i++){         scanf("%lld %d",&n,&p);         for(j=2;j<=p;j++) fact[j] = LL(fact[j-1])*j%p ;         ans = 1;         while(n > 0){            quo =  n/p ;            rem = n%p ;            ans = LL(ans)*(quo%2==0?1:-1)*fact[rem]%p ;            n = quo ;         }         if(ans < 0) ans+= p ;         printf("%d\n",ans);     } return 0; } 
#include <algorithm> #include <iostream> #include <cstdio> #include <vector> #include <utility> using namespace std;  #define		S(x)				scanf("%d",&x) #define		INC(i,a,b)			for(int i=a;i<b;++i) #define		REP(i,n)			INC(i,0,n) #define		FF				first #define		SS				second #define		mp				make_pair #define		tri(a,b,c)			mp(a,mp(b,c)) #define		XX				FF #define		YY				SS.FF #define		ZZ				SS.SS  typedef pair<int,int> PII; typedef pair<int,PII> TRI; typedef vector<int> VI; typedef vector<PII> VII;  const int MAX_N = 1e5, MAX_M = 2e5; bool ans = true; int n, m; TRI E[MAX_M]; int S[MAX_N], R[MAX_N]; int F[MAX_M];  int findSet(int); void link(int,int);  int main() {   S(n); S(m);   REP(i,n) {     S[i] = i;     R[i] = 0;   }   REP(i,m) {     S(E[i].YY); S(E[i].ZZ); S(E[i].XX);   }   sort(E,E+m);      int l, c=0, r=1;      REP(i,m) {     int d = E[i].ZZ;     if(d>c) {       if(r==1) { 	c = d; 	l = i; 	r = 0;       }       else { 	i = l-1; 	r = 1; 	continue;       }     }          int a = E[i].YY, b = E[i].ZZ;     if(r==1) {       if(findSet(a)!=findSet(b)) link(S[a],S[b]);       else if(F[i]==1) { 	ans = false; 	break;       }     }     else {       if(findSet(a)==findSet(b)) F[i] = 0;       else F[i] = 1;     }   }      if(ans) cout << "YES";   else cout << "NO";      return 0; }  int findSet(int v) {   if(v!=S[v]) S[v] = findSet(S[v]);   return S[v]; } void link(int a, int b) {   if(R[a]<R[b]) S[a] = b;   else {     S[b] = a;     if(R[a]==R[b]) R[a]++;   } }
#include <algorithm> #include <iostream> #include <cassert> #include <cstdio> #include <vector> #include <set> using namespace std;  #define		LL			long long #define		S(x)			scanf("%d",&x) #define		SL(x)			scanf("%lld",&x) #define		INC(i,a,b)		for(int i=a;i<b;++i) #define		REP(i,n)		INC(i,0,n) #define		mp			make_pair #define		FF			first #define		SS			second #define		tri(a,b,c)		mp(a,mp(b,c) #define		XX			FF #define		YY			SS.FF #define		ZZ			SS.SS #define		pb			push_back #define		SZ(arr)			((int)(arr.size()))  struct overtake {   LL d, s;   int a, b; // a is overtaken by b (not true ID) };  inline bool operator< (const overtake &x, const overtake &y) {   if(x.d*y.s < x.s*y.d) return true;   else if(x.d*y.s==x.s*y.d) {     if(x.a<y.a || (x.a==y.a && x.b<y.b)) return true;   }   return false; }  typedef pair<LL,LL> PLL; typedef pair<LL,PLL> TRI; typedef vector<int> VI;  const int MAX_N = 1e5+7; int n, q, L[MAX_N]; VI F; TRI H[MAX_N]; set<overtake> O;  void begin(); void repeat(); void answer(LL); bool check(int,LL);  int main() {   int t; S(t);   while(t--) {     begin();     repeat();     REP(i,q) {       LL pos; SL(pos);       answer(pos);     }   }   return 0; }  void begin() {   F.clear();   O.clear();   S(n); S(q);   REP(i,n) {     SL(H[i].XX); SL(H[i].YY); H[i].ZZ = i; // (distance, speed, ID)   }   sort(H,H+n,greater<TRI>()); // Sort in order of distance   REP(i,n) L[i] = i-1; // Linked list   F.pb(0); // First in race      // Add values to overtake set, and discard useless ones   INC(i,1,n) {     TRI curr = H[i];     TRI prev = H[L[i]]; // The horse just ahead          if(curr.YY<=prev.YY) {       L[i+1] = L[i];     }     else {       overtake temp;       temp.s = curr.YY-prev.YY; temp.d = prev.XX-curr.XX;       temp.a = L[i]; temp.b = i;       O.insert(temp);            }   } } void repeat() {   while(!O.empty()) {     overtake top = *O.begin();     O.erase(O.begin());     L[top.b] = L[top.a];     if(L[top.a]!=-1) {       overtake temp;       temp.a = L[top.a]; temp.b = top.a;       temp.s = H[temp.b].YY-H[temp.a].YY; temp.d = H[temp.a].XX-H[temp.b].XX;       assert(temp.s>0 && temp.d>0);       O.erase(O.find(temp));        temp.a = L[top.a]; temp.b = top.b;       temp.s = H[temp.b].YY-H[temp.a].YY; temp.d = H[temp.a].XX-H[temp.b].XX;       assert(temp.s>0 && temp.d>0); // b will eventually overtake a, necessarily       O.insert(temp);     }     else F.pb(top.b);   } } void answer(LL tm) {   int l=0,r=SZ(F);   while(r-l>1) {     int d = (r+l)/2;     if(check(d,tm)) l=d;     else r=d;   }   printf("%lld\n",H[F[l]].ZZ); } bool check(int h, LL tm) {   if(h==0) return true;   int curr = F[h];   int prev = F[h-1];      LL dcurr = H[curr].XX + (H[curr].YY*tm);   LL dprev = H[prev].XX + (H[prev].YY*tm);      if(dcurr>=dprev) return true;   return false; }
#include<stdio.h> #include<stdlib.h> #include<string.h> #define MOD 1000000007 typedef long long int ll ; int a[105][105],deg[105];  int inverse(int a){ 	int ans =1 , pow = a, n = MOD - 2; 	while(n){ 		if(n%2 == 1) ans = ll(ans)* pow %MOD ; 		pow = ll(pow) * pow % MOD ; 		n = n/2 ; 	} 	return ans ; }  void det(int n){ 	int inv,i,j,k,temp,not_zero,ans = 1; 	for(i=0;i<n;i++){ 		not_zero = i ; 		for(j=i;j<n;j++){ 			if(a[j][i] != 0){ 				not_zero = j; 				break; 			} 		} 		if(a[not_zero][i] == 0){ 			printf("0\n"); 			return ; 		} 		for(j=i;j<n;j++){ 			temp = a[i][j] ; 			a[i][j] = a[not_zero][j] ; 			a[not_zero][j] = temp ; 		} 		ans = ll(ans) * a[i][i] % MOD; 		inv =  inverse(a[i][i]); 		for(j=i+1;j<n;j++){ 			a[i][j] = ll(a[i][j])*inv%MOD ; 		} 		a[i][i] = 1; 		for(j=i+1;j<n;j++){ 		    if(a[j][i] == 0) continue ; 		    int c = a[j][i]; 			for(k=i;k<n;k++){ 				 temp = a[j][k] -  ll(a[i][k])*c%MOD ; 				 if(temp < 0) temp = temp + MOD ; 				 a[j][k] = temp ; 			} 		} 	} 	printf("%d\n",ans); }  int main(){ 	int t,n,m,x,y,i,j,temp[105][105]; 	scanf("%d",&t); 	while(t--){ 		scanf("%d%d",&n,&m); 		memset(a,0,sizeof(a)); 		memset(deg,0,sizeof(deg)); 		memset(temp,0,sizeof(temp)); 		while(m--){ 			scanf("%d%d",&x,&y); 			deg[x]++; deg[y]++; 			temp[x][y]=  temp[y][x] = 1 ; 		} 		for(i=0;i<n;i++){ 			for(j=0;j<n;j++){ 				if(i == j) a[i][j] = deg[i]; 				else a[i][j] = (temp[i][j] == 1)?MOD-1:0 ; 			} 		} 		det(n-1); 	} 	return 0; } 
#include<stdio.h> #include<iostream> #include<map> #include<set> #include<vector> #include<queue> #include<stack> #include<algorithm> #include<cmath>  #define MOD 1000000007 #define INF 2000000000  typedef unsigned long long llu;  using namespace std;  static llu mulmod(llu a,llu b,llu mod ) { if(a>=mod) a %=mod; if(b>=mod) b%=mod; long double res = a; res *= b; llu c = (llu)(res / mod); a *= b; a -= c * mod; a %= mod; if (a < 0) a += mod; return a; }      int main() {     int t;          long long n,b;          scanf("%d",&t);          while(t--)     {               scanf("%lld %lld",&n,&b);                              if(n==0)               {                       if(b==1)                        printf("Odd\n");                       else                        printf("Even\n");                                              continue;               }                              long long i;                              long long num=1,num2=1,tmp=b,pw=2;                              while(tmp%2==0)               {                              tmp/=2;                              pw*=2ll;               }                              for(i=1;i<=n;i++)               {                               num=mulmod(num,i,b);                               num2=mulmod(num2,i,pw);               }                              //printf("%lld\n",num);                                             if((pw+num2-(num%pw))%pw==0)               {                          printf("Even\n");               }               else               {                   printf("Odd\n");               }                    }                    return 0; } 
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <cmath> #include <algorithm> #include <functional> #include <numeric> #include <bitset> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <climits> #include <map> #include <cassert>  #define ull unsigned long long #define ill long long int #define pii pair<int,int> #define pb(x) push_back(x) #define F(i,a,n) for(i=(a);i<(n);++i) #define FD(i,a,n) for(i=(a);i>=(n);--i) #define FE(it,x) for(it=x.begin();it!=x.end();++it) #define V(x) vector<x> #define S(x) scanf("%d",&x) #define S1(x) scanf("%lld",&x) #define epsilon 0.000000000000001 #define pie acos (-1.0) #define MAXNODES 100001 #define sz size() #define MAX 100009 using namespace std;  ill a[MAX]; ill parent[MAX]; ill d[MAX]; ill level[MAX]; vector < vector <ill> > s; ill root; ill chainhead[MAX]; ill which[MAX]; ill where[MAX]; ill ssize[MAX]; ill chain;  class seg {     private:      public:         vector <ill> a;         vector <ill> flag;         ill ss;         void add (ill index)         {             ss++;         }          seg ()         {             ss = 0;         }          void space ()         {             a.resize (7*ss + 10);             fill (a.begin(), a.end(), 0);              flag.resize (7*ss + 10);             fill (flag.begin(), flag.end(), 0);         }          void build (ill node, ill x, ill y)         {             if (x > y) {                 return;             }             if (x == y) {                 a[node] = 0;                 return;             }             ill mid = (x+y)/2;             build (node*2, x, mid);             build (node*2 + 1, mid+1, y);             a[node] = a[node*2] + a[node*2 + 1];         }          void checking (ill node, ill x, ill y)         {             if (flag[node] == 0) {                 return;             }              ill mid = (x+y)/2;              if (2*node < 7*ss) {                 a[node*2] += (ill)(mid-x+1)*flag[node];                 flag[node*2] += flag[node];             }             if (2*node +1 < 7*ss) {                 a[node*2 +1] += (ill)(y-mid)*flag[node];                 flag[node*2 +1] += flag[node];             }             flag[node] = 0;         }          ill query (ill node, ill x, ill y, ill sx, ill sy)         {         //    cout << node << " " << 4*ss << " " << x << " " << y << " " << sx << " " << sy << endl;             if (x > y) {                 return 0;             }             if (x > sy || y < sx) {                 return 0;             }             checking (node, x, y);              if (sx <= x && sy >= y) {                 return a[node];             }              if (x == y) {                 return a[node];             }             ill mid = (x+y)/2;             if (sy <= mid) {                 return query (2*node, x, mid, sx, sy);             }             if (sx > mid) {                 return query (2*node +1, mid+1, y, sx, sy);             }             return query (2*node, x, mid, sx, sy) + query (2*node + 1, mid+1, y, sx, sy);         }            void update (ill node, ill x,                        ill y, ill sx, ill sy, ill value)         {             if (x > y) {                 return;             }             if (x  > sy || y < sx) {                 return;             }             checking(node, x, y);             if (x == y) {                 a[node] = a[node]+value;                // a[x] += value;                 return;             }                if (sx <= x && sy >= y) {                 flag[node] += value;                 a[node] = a[node]+((ill)(y-x+1)*value);                 return;             }             ill mid = (x+y)/2;             update (node*2, x, mid, sx, sy, value);             update (node*2 +1, mid+1, y, sx, sy, value);             a[node] = a[node*2] + a[node*2 +1];         } }; vector <seg> segment;  ill lca( ill a, ill b) {     while (which[a] != which[b]) {         ill a1 = chainhead[which[a]];         ill b1 = chainhead[which[b]];         if (level[a1] < level[b1]) {             b = parent[b1];         } else {             a = parent[a1];         }     }     if (a == -1 || b == -1) {         return root;     }     if (level[a] < level[b]) {         return a;     }     return b; }  ill query (ill u) {     ill sum = 0;     ill total=0;     while (u != -1) {        // cout << "AA " << u << endl;         ill cc = which[u];       //  cout << ssize[cc] << " " << where[u] << endl;         ill xx =  segment[cc].query (1, 0, ssize[cc]-1, where[u], where[u]);          sum = sum + total*xx;         xx =  segment[cc].query (1, 0, ssize[cc]-1, 0, where[u]);         sum = sum + xx;         total = total + (ill)(where[u]+1);         u = chainhead[cc];         u = parent[u];     }     return sum; }  void update (ill index, ill value) {     ill cc = which[index];     segment[cc].update (1, 0, ssize[cc]-1, where[index],  ssize[cc]-1, value); }   void dfs (ill index, ill p) {     d[index] = 1;     parent[index] = p;     ill i;      F (i, 0, s[index].size()) {         ill x = s[index][i];         if (x == p) {             continue;         }         level[x] = level[index] + 1;         dfs (x, index);         d[index] = d[index] + d[x];     } }  void hld (ill index, ill p) {     if (chainhead[chain] == -1) {         chainhead[chain] = index;     }     which[index] = chain;     where[index] = ssize[chain];     ssize[chain]++;     segment[chain].add (0);      ill i,j=-1,xx=-1;      F (i, 0, s[index].size()) {         ill x = s[index][i];         if (x == p) {             continue;         }         if (d[x] > xx) {             xx = d[x];             j = x;         }     }      if (j == -1) {         return;     }     hld (j, index);      F (i, 0, s[index].size()) {         ill x = s[index][i];         if (x == p || x == j) {             continue;         }         chain++;         hld (x, index);     } }  int main() {   // freopen ("input.txt", "r", stdin);     ill tt,ix=1;       ill i,n;     S1 (n);     ill qq;     S1 (qq);      S1 (root);     root--;      s.clear();      s.resize (n);     F (i, 0, n-1) {         ill x,y;         S1 (x);      S1 (y);         x--;        y--;         s[x].pb (y);         s[y].pb (x);     }      level[root] = 0;     dfs (root, -1);      segment.clear();     segment.resize (n+3);      chain = 0;     memset (chainhead, -1, sizeof(chainhead));     memset (ssize, 0, sizeof(ssize));      hld (root, -1);     F (i, 0, chain+4) {         segment[i].space ();         segment[i].build (1, 0, ssize[i]-1);     }     //cout << "SDAS" << endl;    //  cout << "SDAD " << qq << endl;     while (qq--) {         char ch[3];         scanf ("%s", ch);         if (ch[0] == 'U') {             ill x;             ill y;             S1(x);             S1(y);             x--;             update (x, y);              continue;         }          ill x,y;         S1(x);         S1(y);         x--;         y--;         ill ll = lca(x,y);         //  cout << x << " " << y << " " << ll << endl;         ill ans = query(y)+query(x)-query(ll)-(parent[ll]!=-1?query(parent[ll]):0);         printf ("%lld\n", ans);       //  cout << "A" << endl;       //  cout << endl;      }       return 0; }
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <limits> #include <string> #include <cassert>  using namespace std; typedef long long LL; typedef pair<int,int> pii;  #define forup(i,a,b) for(int i=a; i<b; ++i) #define fordn(i,a,b) for(int i=a; i>b; --i) #define rep(i,a) for(int i=0; i<a; ++i)  #define dforup(i,a,b) for(i=a; i<b; ++i) #define dfordn(i,a,b) for(i=a; i>b; --i) #define drep(i,a) for(i=0; i<a; ++i)  #define slenn(s,n) for(n=0; s[n]!=13 and s[n]!=0; ++n);s[n]=0  #define gi(x) scanf("%d",&x) #define gl(x) cin>>x #define gd(x) scanf("%lf",&x) #define gs(x) scanf("%s",x)  #define pis(x) printf("%d ",x) #define pin(x) printf("%d\n",x) #define pls(x) cout<<x<<" " #define pln(x) cout<<x<<"\n" #define pds(x) printf("%.12f ",x) #define pdn(x) printf("%.12f\n",x) #define pnl() printf("\n")  #define fs first #define sc second  #define pb push_back  const int inv=1000000000; const int minv=-inv;  const int max_n=100010;  // Geometry  struct point { 	LL xc,yc; 	point(){} 	point(LL xc_, LL yc_){xc=xc_; yc=yc_;} };  point operator +(const point &a, const point &b) {return point(a.xc+b.xc,a.yc+b.yc);} // Vector Addition point operator -(const point &a, const point &b) {return point(a.xc-b.xc,a.yc-b.yc);} // Vector Subtraction LL operator *(const point &a, const point &b) {return (a.xc*b.xc+a.yc*b.yc);} // Dot Product LL operator ^(const point &a, const point &b) {return (a.xc*b.yc-a.yc*b.xc);} // Cross Product : Right-Hand Rule  bool leftturn(const point &X1, const point &X2, const point &X3) { return (((X2-X1)^(X3-X2))>0ll); } bool straight(const point &X1, const point &X2, const point &X3) { return (((X2-X1)^(X3-X2))==0ll); }  point pfix; struct point_tan_cmp : public binary_function <point,point,bool> { 	bool operator() (const point &a, const point &b) { return ((a.yc-pfix.yc)*(b.xc-pfix.xc)>(b.yc-pfix.yc)*(a.xc-pfix.xc)); } }; // X: all points should be distinct // X: order of points in array will be changed // X: triples of points may be collinear // X: there should exist three non-collinear points // cX: points will be sorted in clockwise order (all turn will be right turns) void ConvexHull(point X[], int N, int cX[], int &cXsz) {	 	int fix=0; 	for(int i = 1; i<N; i++){ 		if(X[i].xc<X[fix].xc or (X[i].xc==X[fix].xc and X[i].yc>X[fix].yc)) 			fix=i; 	} 	swap(X[0],X[fix]); 	pfix=X[0]; 	 	sort(X+1,X+N,point_tan_cmp()); 	X[N]=X[0]; 	 	cXsz=0; 	cX[cXsz++]=0; 	cX[cXsz++]=1; 	forup(i,2,N+1) 	{ 		while(cXsz>=2 and (leftturn(X[cX[cXsz-2]],X[cX[cXsz-1]],X[i]) or straight(X[cX[cXsz-2]],X[cX[cXsz-1]],X[i]))) 			--cXsz; 		if(i==N) break; 		cX[cXsz++]=i; 	} }  // End  int T; int n; point P[max_n]; int H[max_n],nH;  int main() { 	gi(T);  	rep(z,T) 	{ 		gi(n);  		rep(i,n) 		{ 			gl(P[i].xc); 			gl(P[i].yc); 		}  		if(n<=2) 			pin(n-1); 		else 		{ 			ConvexHull(P,n,H,nH); 			pin(2*nH-3+3*(n-nH)); 		} 	} 	 	return 0; }
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime>  using namespace std;  #define REP(i, n) for(int i=0;i<n;i++) #define ll long long ll m;  ll cur[2][2]; ll mat[2][2];  void matmul(ll p[][2], ll q[][2]) { 	ll c[2][2]; 	REP(i, 2) 		REP(j, 2) 		{ 			c[i][j] = 0; 			REP(k, 2) 				c[i][j] += (p[i][k]*q[k][j]+m)%m; 		} 	REP(i, 2) 		REP(j, 2) 			p[i][j] = (c[i][j] + m)%m; }  void raise(ll exp) { 	ll mov[2][2]; 	mov[0][0] = mat[0][0]; mov[0][1] = mat[0][1]; 	mov[1][0] = mat[1][0]; mov[1][1] = mat[1][1]; 	if( exp == 1 ) 		return; 	mat[0][0] = mat[1][1] = 1; 	mat[0][1] = mat[1][0] = 0; 	while( exp ) 	{ 		if(exp%2 == 1 ) 			matmul(mat, mov); 		matmul(mov, mov); 		exp /= 2; 	} }  void update() { 	matmul(cur, mat); }  int main() { 	int t; 	cin>>t; 	int primes[100005]; 	REP(i, 100005) 		primes[i] = 1; 	primes[0] = primes[1] = 0; 	for( int i=2;i<100005;i++) 	{ 		if( primes[i] == 0 ) 			continue; 		for( int j=2*i;j<100005;j+=i) 			primes[j] = 0; 	} 	while( t-- ) 	{ 		ll n, r; 		cin>>n>>r>>m; 		if( m == 1 || n < r) 		{ 			cout<<0<<endl; 			continue; 		} 		ll factors[n+1]; 		REP(i, n+1) 			factors[i] = 0; 		for( int i=2;i<=n;i++) 		{ 			if( primes[i] == 0 ) 				continue; 			for( ll j=i;j<=n;j *= i ) 				factors[i] += n/j; 		} 		for( int i=2;i<=r;i++) 		{ 			if( primes[i] == 0 ) 				continue; 			for( ll j=i;j<=r;j *= i ) 				factors[i] -= r/j; 		} 		for( int i=2;i<=n-r;i++) 		{ 			if( primes[i] == 0 ) 				continue; 			for( ll j=i;j<=n-r;j *= i ) 				factors[i] -= (n-r)/j; 		} 		//cur[0][0] = 1; cur[1][1] = 1; 		//cur[1][0] = cur[0][1] = 0; 		mat[0][0] = 1; mat[0][1] = 1; 		mat[1][0] = 1; mat[1][1] = 0;  		REP(i, n+1) 		{ 			if( primes[i] == 0 || factors[i] <= 0 ) 				continue; 		//	cout<<i<<" "<<factors[i]<<endl; 			REP(j, factors[i]) 				raise(i); 		//	cout<<mat[0][0]<<endl; 	//		raise(factors[i]); 		} 		//if( mat[1][0] == 0 ) 		//	mat[1][0] = 1; 		cout<<mat[1][0]<<endl; 	} 	return 0; }     	   
#include <bits/stdc++.h> using namespace std; #define MID ((l+r) >> 1) #define LT (nd << 1) #define RT ((nd << 1) | 1) #define MAX 1123 typedef long long LL;  template <typename T> inline void fi(T *a) {  register char c=0;  while (c<33) c=getchar_unlocked();  *a=0;  int tmp = 0;  while (c>33)  {      if ( c == 45 ) tmp = 1;      else *a=*a*10+c-'0';      c=getchar_unlocked();  }  if ( tmp == 1 ) *a = 0-(*a); }  struct node{     LL lsum,rsum,msum,sum;     node():lsum(0),rsum(0),msum(0),sum(0){}     node(LL v):lsum(v),rsum(v),msum(v),sum(v){} };  node Merge(node left,node right){     node res;     res.sum = left.sum + right.sum;     res.lsum = max(left.lsum,left.sum+right.lsum);     res.rsum = max(right.rsum,right.sum+left.rsum);      res.msum = max(left.msum,right.msum);     res.msum = max(res.msum,left.rsum+right.lsum);     return res; }  LL A[MAX],S,N,Q; node RQ[MAX][MAX];  void compute(){     for(LL i = 0; i < S; ++i) RQ[i][i] = node(A[i]);     for(LL i = 1; i < S; ++i){         for(LL j = 0; j+i < S; ++j){             LL l = j, r = i+j;             RQ[j][j+i] = Merge(RQ[j][MID],RQ[MID+1][i+j]);         }     } }  node Range(LL st,LL sz){     if (st+sz-1 < S) return RQ[st][st+sz-1];      node n1 = RQ[st][S-1],res;     sz -= (S-st);      if (sz <= S)         res = RQ[0][sz-1];     else {         LL d = sz/S;         sz = sz%S;         node fr = RQ[0][S-1];         res = fr;          res.sum = res.sum*d;         if (fr.sum > 0){             res.lsum += max(fr.sum*(d-1),(LL)0);             res.rsum += max(fr.sum*(d-1),(LL)0);             LL ans = LLONG_MIN;             if (d > 1)                 ans = fr.lsum + fr.rsum + max(fr.sum*(d-2),(LL)0);             res.msum = max(res.msum,ans);         }          if (sz != 0)             res = Merge(res,RQ[0][sz-1]);     }      res = Merge(n1,res);     return res; }  struct seg{     vector<node> v;     vector<LL> lazy;     LL sz;      seg():sz(0){}     void Resize(LL k){         sz = k;         v.resize(3*sz,node());         lazy.resize(3*sz,-1);     }      void pushdown(LL nd,LL l,LL r){         if (lazy[nd] == -1) return;         LL v1 = lazy[nd];         node res = Range(v1,r-l+1);         v[nd] = res;         if (l != r)             lazy[LT] = v1, lazy[RT] = (v1+MID-l+1)%S;         lazy[nd] = -1;     }      void update(LL nd,LL l,LL r,LL a,LL b,LL M){         pushdown(nd,l,r);         if (l > b || r < a) return;         if (l >= a && r <= b){             lazy[nd] = (M+l-a)%S;             pushdown(nd,l,r);             return;         }          update(LT,l,MID,a,b,M);         update(RT,MID+1,r,a,b,M);         v[nd] = Merge(v[LT],v[RT]);     }      void update(LL a,LL b,LL M){         update(1,0,sz-1,a,b,M);     }      node query(LL nd,LL l,LL r,LL a,LL b){         pushdown(nd,l,r);         if (l >= a && r <= b)             return v[nd];          if (MID < a) return query(RT,MID+1,r,a,b);         if (MID+1 > b) return query(LT,l,MID,a,b);          node n1 = query(LT,l,MID,a,b);         node n2 = query(RT,MID+1,r,a,b);         return Merge(n1,n2);     }      node query(LL a,LL b){         return query(1,0,sz-1,a,b);     } };  void solve(){     fi(&S),fi(&N),fi(&Q);     for(int i = 0; i < S; ++i)         fi(&A[i]);     compute();      seg SG;     SG.Resize(N);      char ch[10];     LL a,b,c;     while(Q--){         scanf("%s",ch);         fi(&a),fi(&b),--a,--b;         if (ch[0] == 'U'){             fi(&c),--c;             c %= S;             SG.update(a,b,c);             continue;         }          node res = SG.query(a,b);         printf("%lld\n",res.msum);     } }  int main() {     solve();     return 0; } 
#include <cstdio> #include <cstdlib> #include <cstring> #include <vector> #include <algorithm> using namespace std;  bool graph[111][111]; char s[111][111];  int n, root; vector<int> adj[200]; int mate[200]; bool v1[200], v2[200];  template<typename T> int size(const T& c) { return int(c.size()); } template<typename T> T sqr(T x) { return x*x; } template<typename T> bool remin(T& x, T y) { if (x <= y) return false; x = y; return true; } template<typename T> bool remax(T& x, T y) { if (x >= y) return false; x = y; return true; }  #define FOR(i, a, b) for (int i(a), _b(b); i <= _b; ++i) #define FORD(i, a, b) for (int i(a), _b(b); i >= _b; --i) #define REP(i, n) for (int i(0), _n(n); i < _n; ++i) #define REPD(i, n) for (int i((n) - 1); i >= 0; --i)  bool dfs(int x) {   if (v1[x]) return false;   v1[x] = v2[x] = true;   REP(z, size(adj[x])) {     int y = adj[x][z];     if (y != root && mate[y] == -1) {       mate[x] = y;       mate[y] = x;       return true;     }   }   REP(z, size(adj[x])) {     int y = adj[x][z];     if (y != root && !v2[y] && dfs(mate[y])) {       mate[x] = y;       mate[y] = x;       return true;     }   }   v2[x] = false;   return false; }  int solve() {   int res = 0;   REP(z, 13) {     REP(i, n) random_shuffle(adj[i].begin(), adj[i].end());     REP(i, n) mate[i] = -1;     vector<int> order(n);     REP(i, n) order[i] = i;     random_shuffle(order.begin(), order.end());     int cur = 0;     REP(i, n) {       root = order[i];       if (mate[root] != -1) continue;       REP(i, n) v1[i] = v2[i] = false;       if (dfs(root)) ++cur;     }     remax(res, cur);   }   return res; }  int main() {     // freopen("J.in", "r", stdin);     // memset(matchL, -1, sizeof(matchL));     //     memset(matchR, -1, sizeof(matchR));     //     int matched = 0;     //     for (int i = 0; i < n; i++) {     //         memset(seen, false, sizeof(seen));     //         if (bpm(i)) matched++;     //     }      int T;      for (int T = 1;; T++) {         int m;         scanf("%d%d", &n, &m);         if (n + m == 0) break;         for (int i = 0; i < n; i++) scanf("%s", s[i]);          memset(graph, false, sizeof(graph));         for (int i = 0; i < n; i++)             for (int j = 0; j < n; j++)                 if (s[i][j] == '.') {                     graph[i][j] = true;                     graph[j][i] = true;                 }         for (int i = 0; i < n; i++) adj[i].clear();         for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) if (graph[i][j]) adj[i].push_back(j);          bool ok = true;         for (int i = 0; i < n; i++) {             int cnt = 0;             for (int j = 0; j < n; j++) if (graph[i][j]) cnt++;             if (cnt == 0) ok = false;         }          printf("Case#%d: ", T);          if (ok == false) { printf("IMPOSSIBLE\n"); continue; }          printf("%d\n", (n - solve()) * m);     }     return 0; }
#include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<set> #include<map> #include<string> #include<string.h> #include<cstring> #include<stack> #include<queue> #include<cassert> #include<cmath> using namespace std;  #define LL long long int #define PII pair<int,int> #define PB push_back #define MP make_pair #define INF 1000000000 #define debug(args...) do {cerr << #args << ": "; dbg,args; cerr << endl;} while(0) #define MOD 1000000007  string s; int dp[5001][5001][3][2]; int vis[5001][5001][3][2]; int citer = 0; char ss[2000]; int  getans(int n, int m, int cinter, int contin){     if(m < 0)m = 0;     if(n == -1)return (m == 0 && cinter == 0);     int &cret = dp[n][m][cinter][contin];     int &cvis = vis[n][m][cinter][contin];     if(cvis != citer){         LL ret = 0;         cvis = citer;         ret += getans(n - 1, m, cinter, 0);         if(s[n] != 'a'){             if(contin  == 1){                 ret += getans(n - 1, m, cinter, 1);             }             if(cinter > 0)                 ret += getans(n - 1, m, cinter - 1, 1);         }         else{             if(contin == 1)                 ret += getans(n - 1, m - 1, cinter, 1);             if(cinter > 0)                 ret += getans(n - 1, m - 1, cinter - 1, 1);         }         cret = ret % MOD;     }     return cret; } int main(){     int t, m;     cin >> t;     while(t--){         citer += 2;         cin >> s >> m;         cout<<getans(s.size() - 1, m, 3, 0)<<endl;     }              return 0; } 
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <limits> #include <string> #include <cassert>  using namespace std; typedef long long LL; typedef pair<int,int> pii;  #define forup(i,a,b) for(int i=a; i<b; ++i) #define fordn(i,a,b) for(int i=a; i>b; --i) #define rep(i,a) for(int i=0; i<a; ++i)  #define dforup(i,a,b) for(i=a; i<b; ++i) #define dfordn(i,a,b) for(i=a; i>b; --i) #define drep(i,a) for(i=0; i<a; ++i)  #define slenn(s,n) for(n=0; s[n]!=13 and s[n]!=0; ++n);s[n]=0  #define gi(x) scanf("%d",&x) #define gl(x) cin>>x #define gd(x) scanf("%lf",&x) #define gs(x) scanf("%s",x)  #define pis(x) printf("%d ",x) #define pin(x) printf("%d\n",x) #define pls(x) cout<<x<<" " #define pln(x) cout<<x<<"\n" #define pds(x) printf("%.12f ",x) #define pdn(x) printf("%.12f\n",x) #define pnl() printf("\n")  #define fs first #define sc second  #define pb push_back  const int inv=1000000000; const int minv=-inv;  const int max_n=1000010; const int flim=max_n+2010; const LL modref=1000000007ll;  LL fpow(const LL &a, const LL &p) { 	if(p==0ll) return 1ll;  	LL t=fpow(a,p/2ll); 	t*=t; t%=modref;  	if(p%2ll==1ll) { t*=a; t%=modref; }  	return t; }  int n; int c[1011]={0};  LL f[flim+1]; LL fi[flim+1];  LL ch(const int &i, const int &j) { 	if(i<0) return 0ll; 	if(j<0 or j>i) return 0ll;  	LL ret=(fi[j]*fi[i-j])%modref; 	ret*=f[i]; ret%=modref; 	return ret; }  LL dp[1011][2011]={0}; LL res[2011];  int main() { 	f[0]=1ll; 	for(int i=1; i<=flim; ++i) 		f[i]=((LL(i))*f[i-1])%modref; 	fi[flim]=fpow(f[flim],modref-2ll); 	for(int i=flim-1; i>=0; --i) 		fi[i]=(fi[i+1]*(LL(i+1)))%modref;  	gi(n);  	rep(i,n) 	{ 		int a; gi(a); 		++c[a]; 	}  	dp[0][0]=1ll; 	for(int i=1; i<=1000; ++i) 	{ 		for(int s=0; s<=2000; ++s) 		{ 			dp[i][s]=0ll;  			for(int k=0; k<=c[i]; ++k) 			{ 				if(s-(i+1)*k<0) break;  				LL ddp=(dp[i-1][s-k*(i+1)]*ch(c[i],k))%modref; 				if(k%2==1) ddp=modref-ddp;  				dp[i][s]+=ddp; 				if(dp[i][s]>=modref) dp[i][s]-=modref; 			} 		} 	}  	for(int s=0; s<=2000; ++s) 	{ 		res[s]=0ll; 		for(int i=0; i<=s; ++i) 		{ 			LL dres=dp[1000][i];  			int r=s-i; 			dres*=ch(n-1+r,n-1); dres%=modref;  			res[s]+=dres; if(res[s]>=modref) res[s]-=modref; 		} 	}  	int q; 	gi(q); 	rep(z,q) 	{ 		int s; gi(s); 		pin((int(res[s]))); 	} 	 	return 0; }
# include <iostream> # include <fstream> # include <sstream> # include <iomanip> # include <algorithm> # include <numeric> # include <cstdio> # include <cmath> # include <cstdlib> # include <cstring> # include <vector> # include <list> # include <set> # include <map> # include <stack> # include <queue> # include <deque> # define inf 1000000007 using namespace std; typedef unsigned long long int ulli; int main() {     #ifndef ONLINE_JUDGE         freopen("../input.txt","r",stdin);     #endif 	int t; 	int N, a, b, c, d, k, Q;  	bool vis[1005][2]; 	scanf("%d", &t); 	while(t--) {  		scanf("%d %d %d %d %d %d %d", &N, &a, &b, &c, &d, &k, &Q);  		for(int i=0;i<=1000;i++) {		 			vis[i][0] = false; 			vis[i][1] = false; 		} 		int res = inf; 		int iter = 0, steps, currN, applied; 		queue< pair< pair<int, int>, int> > q; 		q.push(make_pair(make_pair(N, 0), 1));                 q.push(make_pair(make_pair(N%d, 1), 0)); 		while(!q.empty()) { 			iter++;  			currN = q.front().first.first; 			steps = q.front().first.second; 			applied = q.front().second;  			q.pop();  			if(Q%k == (currN%k)) { 				res = steps; 				break; 			}  			if(vis[currN][applied]) { 				continue; 			} 			vis[currN][applied] = true; 			steps++;  			if(applied == 0) { 				//q.push(make_pair(make_pair(currN % d, steps), 0)); 				q.push(make_pair(make_pair((currN + a)%d, steps), 0)); 				q.push(make_pair(make_pair(((currN - b)%d + d)%d, steps), 0)); 				q.push(make_pair(make_pair((currN * c)%d, steps), 0)); 			}  			q.push(make_pair(make_pair((currN + a)%k, steps), 1)); 			q.push(make_pair(make_pair(((currN - b)%k + k)%k, steps), 1)); 			q.push(make_pair(make_pair((currN * c)%k, steps), 1)); 		} 		if(res == inf) 			printf("-1\n"); 		else 			printf("%d\n", res); 	}     return 0; }
#include <stdio.h> #include <iostream> #include <string> #include <string.h> using namespace std; int cs[100005]; #define min(a,b) (a<b?a:b) int main(){  	int T,m ; 	string S; 	 	scanf("%d",&T);  	while(T--){ 		cin >> S; 		memset(cs,0,sizeof(int)*S.length());  		for(int i = 0 ; i<S.length() ; i++) 			cs[i] = S[i]=='A';  		for(int i = 1 ; i<S.length() ; i++) 			cs[i] += cs[i-1];  		scanf("%d",&m);  		int ans = m-cs[m-1]; 		for(int i = 1 ; i+m-1<S.length() ; i++){ 			ans = min(ans,m-(cs[i+m-1]-cs[i-1])); 		} 		printf("%d\n",ans); 	} 	return 0; }
#include<cstdio> #include<iostream> #include<algorithm> #include<cmath> using namespace std; long long gcd(long long a, long long b) {     if(b==0)     return a;     else     {         return gcd(b,a%b);     } } int bitcount(long long a) {     int count=0;     while(a!=0)     {         if(a&1==1)         count++;         a=a/2;     }     return count; } main() {       int tc;       scanf("%d",&tc);       while(tc--)       {          long long p,q,g;          int count1;          scanf("%lld %lld",&p,&q);          if(p>=q)          g=gcd(p,q);          else          g=gcd(q,p);          p=p/g;          q=q/g;          if(p==1)          {             while((q&1)!=1)             {                q=q/2;             }             if(((q+1)&(q))==0)             printf("YES\n");             else             printf("NO\n");          }          else           {               int count2=0;               count1=bitcount(p);              // printf("%d",count1);               if(count1==1)               {                  while((q&1)!=1)                  {                      q=q/2;                  }                  if(((q+1)&(q))==0)                  {                     if(q>p || ((q+1)==p))                     printf("YES\n");                     else                     printf("NO\n");                  }                  else                  printf("NO\n");               }               else               printf("NO\n");          }       }       return 0;        }  
#include <iostream> #include <cstring>  using namespace std;  int source, sink, n, m; int cap[201][201], vis[201], node, a[201][201], aa[201][201]; int totr, totc, r[201], c[201];  bool flow(int pos) {     if(vis[pos] == node) return false;     vis[pos] = node;     for(int i = 0; i < n+m+2; i++) {         if(!cap[pos][i]) continue;         if(i == sink) {             cap[pos][i]--;             cap[i][pos]++;             if(pos < n) {                 a[pos][i] = 1;             }             else {                 a[i][pos] = 0;             }             return true;         }         if(flow(i)) {             cap[pos][i]--;             cap[i][pos]++;             if(pos < n) {                 a[pos][i] = 1;             }             else {                 a[i][pos] = 0;             }             return 1;         }     }     return false; }  int main() {     int t;     ios_base::sync_with_stdio(false);     cin >> t;     int cs = 0;     while(t--) {         cin >> n >> m;         cs++;         cout << "TestCase #:" << cs << endl;         totr = totc = 0;         for(int i = 0; i < n; i++) cin >> r[i], totr += r[i];         for(int j = 0; j < m; j++) cin >> c[j], totc += c[j];         source = n+m;         sink = n+m+1;         memset(cap, 0, sizeof(cap));         memset(aa, 0, sizeof(aa));         memset(a, 0, sizeof(a));         memset(vis, 0, sizeof(vis));         for(int i = 0; i < n; i++) {             cap[source][i] = r[i];         }          for(int i = 0; i < n; i++) {             for(int j = 0; j < m; j++) {                 cap[i][j+n] = 1;             }         }          for(int i = 0; i < m; i++) {             cap[i+n][sink] = c[i];         }         int ans = 0;         node = 1;         while(flow(source)) {             node++;             ans++;         }         //cout << ans << endl;         if(ans != totr || totr != totc) {             cout << -1 << endl;             continue;         }         for(int i = 0; i < n; i++) {             for(int j = 0; j < m; j++) {                 if(cap[j+n][i] == 1) {                     cap[j+n][i] = 0;                     cap[source][i]++;                     cap[i][source]--;                     cap[j+n][sink]++;                     cap[sink][j+n]--;                     node++;                     if(!flow(source)) {                         cap[j+n][i] = 1;                         cap[source][i]--;                         cap[i][source]++;                         cap[j+n][sink]--;                         cap[sink][j+n]++;                     }                 }                 else {                     cap[i][n+j] = 0;                 }             }         }          for(int i = 0; i < n; i++) {             for(int j = 0; j < m; j++) {                 cout << cap[j+n][i];             }             cout << endl;         }      } } 
#include <bits/stdc++.h>  using namespace std;  int Find (string S, int L, int K) { 	priority_queue < int > Q; 	int n = S.length (); 	int curr = 0, temp = 1; 	for (int i = 0; i < n - 1; i++) 	{ 		if (S[i] == S[i + 1]) 			temp++; 		else 		{ 			curr += min (K, temp); 			temp -= min (K, temp); 			if (temp) 				Q.push (temp); 			temp = 1; 		} 	} 	curr += min (K, temp); 	temp -= min (K, temp); 	if (temp) 		Q.push (temp); 	if (curr >= L) 		return L; 	int res = L; 	while (curr < L) 	{ 		temp = Q.top (); 		Q.pop (); 		curr += min (temp, K); 		temp -= min (temp, K); 		if (temp) 			Q.push (temp); 		res++; 	} 	return res; }  int main () { 	int T, L, K; 	string S; 	cin >> T; 	while (T--) 	{ 		cin >> S; 		cin >> K >> L; 		cout << Find (S, L, K) << endl; 	} 	return 0; } 
#include<stdio.h> #include<math.h> int main() { long long t ; double x,y,r,a,b,v; scanf("%lld",&t);  while(t--) { scanf("%lf %lf %lf %lf %lf %lf",&r,&x,&y,&a,&b,&v);  x = (x-a)*(x-a)+ (y-b)*(y-b);  x= r-sqrt(x);  x = x/v ; if(x<0) x=0; printf("%lf\n",x);  }   } 
#include<iostream> #include<cstdio> #include<cstring> #include<queue> #include<stack> #include<list> #include<cstring> #include<algorithm> #include<cmath> #include<set> #include<map>  using namespace std;  struct node {     int x, y; };  #define INF 10000000000000000LL #define M 1000000007LL typedef long long ll; typedef list<int> li; typedef stack<int> si; typedef queue<int> qi; typedef priority_queue<int> pqi; typedef pair<int,int> pii; typedef pair<ll,ll> pll; typedef pair<int,string> pis; typedef pair<string,int> psi;  class UF {  public:     int *id, cnt, *sz; 	// Create an empty union find data structure with N isolated sets.     UF(int N)     {         cnt = N;         id = new int[N];         sz = new int[N];         for(int i=0; i<N; i++)         {             id[i] = i;             sz[i] = 1;         } 	//cout<<"Done"<<endl;     }     ~UF()     {         delete [] id;         delete [] sz;     } 	// Return the id of component corresponding to object p.     int find(int p)     {         int root = p;         while (root != id[root])root = id[root];         /*while (p != root)         {             int newp = id[p];             id[p] = root;             p = newp;         }*/         //cout<<"!!"<<root<<endl;         return root;     } 	// Replace sets containing x and y with their union.     void merge(int x, int y)     {         int i = find(x);         int j = find(y);         if (i == j) return;  		// make smaller root point to larger one         if(sz[i] < sz[j])         {             id[i] = j;             sz[j] += sz[i];         }         else         {             id[j] = i;             sz[i] += sz[j];         }         cnt--;     } 	// Are objects x and y in the same set?     bool connected(int x, int y)     {         return find(x) == find(y);     } 	// Return the number of disjoint sets.     int count()     {         return cnt;     } }; vector<pair<int, pair <int,int > > > edg; int main() {     int t;     scanf("%d",&t);     while(t--)     {         edg.clear();         int n;         scanf("%d",&n);         int t1,t2,t3;         for(int i=0;i<n-1;i++)         {             scanf("%d",&t1);             scanf("%d",&t2);             scanf("%d",&t3);              edg.push_back(make_pair(-1*t3 , make_pair(t1,t2)));         }         sort(edg.begin(),edg.end());          UF sets(n);         long long ans=0;         int cnt1,cnt2,f1,f2;         for(int i=0;i<edg.size();i++)         {             //cout<<edg[i].second.first<<" "<<edg[i].second.second<<endl;             f1=sets.find(edg[i].second.first - 1);             //cout<<f1<<endl;             f2=sets.find(edg[i].second.second - 1);             //cout<<f1<<" "<<f2<<endl;             ans-=(((long long)(edg[i].first))*(long long)sets.sz[f1]*(long long)sets.sz[f2]);              sets.merge(f1,f2);          }         printf("%lld\n",ans);      }  } 
#include <cstdio> #include <algorithm> #include <vector>  using namespace std;  int N,Q; vector<pair<int,int> > adj[400013]; bool visited[400013]; int h[400013]; long long depth[400013]; int ancestor[400013][19];  void dfs(int x) {     visited[x] = 1;     for (int i=0;i<adj[x].size();i++) {         if (!visited[adj[x][i].first]) {             h[adj[x][i].first] = h[x]+1;             depth[adj[x][i].first] = depth[x]+adj[x][i].second;             dfs(adj[x][i].first);             ancestor[adj[x][i].first][0] = x;         }     }     ancestor[x][0] = -1; }  int findkth(int x, int k) {     int where = x;     for (int i=17;i>=0;i--) if (k&(1<<i)) where = ancestor[where][i];     return where; }  int lca(int a, int b) {     if (h[a]>h[b]) swap(a,b);     b = findkth(b,h[b]-h[a]);     if (a==b || b==-1) return a;     for (int i=17;i>=0;i--) {         if (h[a]<(1<<i)) continue;         int na = ancestor[a][i];         int nb = ancestor[b][i];         if (na!=nb) a = na, b = nb;     }     return ancestor[a][0]; }  int main() {     int T = 0;     scanf("%d",&T);     for (int t=0;t<T;t++) {         scanf("%d",&N);         for (int i=0;i<N;i++) {             adj[i].clear();             visited[i] = 0;             h[i] = 0;             depth[i] = 0;             for (int j=0;j<18;j++) ancestor[i][j] = 0;         }         for (int i=1;i<N;i++) {             int u = 0,v = 0,c = 0;             scanf("%d%d%d",&u,&v,&c);             u-=1; v-=1;             adj[u].push_back(make_pair(v,c));             adj[v].push_back(make_pair(u,c));         }         dfs(0);         for (int i=1;i<=17;i++) {             for (int j=0;j<N;j++) {                 if (h[j]<(1<<i)) ancestor[j][i] = -1;                 else ancestor[j][i] = ancestor[ancestor[j][i-1]][i-1];             }         }         scanf("%d",&Q);         for (int q=0;q<Q;q++) {             int a = 0,b = 0;             long long para = 0;             scanf("%d%d%lld",&a,&b,&para);             a-=1; b-=1;             int l = lca(a,b);             if (l==-1) {                 printf("NO\n");                 continue;             }             long long dist = depth[a]+depth[b]-2*depth[l];             long long looking = dist/2;             if (depth[a]-depth[l]<depth[b]-depth[l]) swap(a,b);             int where = a;             for (int i=17;i>=0;i--) {                 if (ancestor[where][i]==-1) continue;                 if (h[ancestor[where][i]]<h[l]) continue;                 if (depth[a]-depth[ancestor[where][i]]<=looking) where = ancestor[where][i];             }             int ok = 0;             if (abs((depth[a]-depth[where])-(dist-(depth[a]-depth[where])))<=para) ok = 1;             where = ancestor[where][0];             if (where!=-1 && abs((depth[a]-depth[where])-(dist-(depth[a]-depth[where])))<=para) ok = 1;             if (ok) printf("YES\n");             else printf("NO\n");         }     }      return 0; } 
/*Programmed by Ayush Jaggi*/  #include<bits/stdc++.h>  using namespace std;  #define pb push_back #define mp make_pair #define F first #define S second #define L(i,x,y) for(i=x;i<y;i++) #define l0(i,x) for(i=0;i<x;i++) #define l1(i,x) for(i=1;i<x;i++) #define pd(n) printf("%d",n) #define pdn(n) printf("%d\n",n) #define pds(n) printf("%d ",n) #define plld(n) printf("%lld",n) #define plldn(n) printf("%lld\n",n) #define pllds(n) printf("%lld ",n) #define pc(n) printf("%c",n) #define pn printf("\n") #define ps printf(" ") #define plf(n) printf("%.6lf",n) #define plfn(n) printf("%.6lf\n",n) #define plfs(n) printf("%.6lf ",n) #define pllf(n) printf("%.6llf",n) #define pllfn(n) printf("%.6llf\n",n) #define pllfs(n) printf("%.6llf ",n) #define psn(n) printf("%s\n",n) #define pss(n) printf("%s ",n) #define sd(n) scanf("%d",&n) #define sld(n) scanf("%ld",&n) #define slld(n) scanf("%lld",&n) #define slf(n) scanf("%lf",&n) #define ss(n) scanf("%s",n) #define sc(n) scanf("%c",&n) #define mem(n,m) memset(n,m,sizeof(n)) #define W(t) while(t--)  typedef long long LL; typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int,int> ii; typedef vector<string> VS;  /*template<class T> inline T gcd(T a, T b) {     return b ? gcd(b, a % b) : a; } inline void prime() {     int s, d, count=0;     lb=sqrt(n);     for(s=2; s<=lb; s++)         if(!pr[s])         {             sieve[count++]=s;             for(d=s*s; d<=n; d+=s)                 pr[d]=1;         } }  inline LL expo(LL base, int nent) {     if(nent==1)         return base;     else if(nent&1)     {         LL temp=expo(base,nent/2);         temp=temp*temp*base;         if(temp>=MOD)             temp%=MOD;         return temp;     }     else     {         LL temp=expo(base,nent/2);         temp*=temp;         if(temp>=MOD)             temp%=MOD;         return temp;     } }*/  LL MOD=1000000007, ans; string str1, str2, str; int sa[100005], pos[100005], lcp[100005], tmp[100005], gap, len, i, j, k, l1, fflag, beg, end, cur_beg, temp, t; //sorting can be improved in suffix arrays from std::sort to stable_sort or radix sort to make the complexity O(n) from O(nlogn)  inline bool sufcmp(int x, int y) {     if(pos[x]!=pos[y])         return pos[x]<pos[y];     x+=gap;     y+=gap;     return (x<len && y<len) ? pos[x]<pos[y] : x>y; }  inline void build_sa() {     len=str.length();     l0(i,len)     {         pos[i]=str[i];         sa[i]=i;     }     for(gap=1;; gap*=2)     {         sort(sa,sa+len,sufcmp);         tmp[0]=0;         l1(i,len)         tmp[i]=tmp[i-1]+sufcmp(sa[i-1],sa[i]);         l0(i,len)         pos[sa[i]]=tmp[i];         if(tmp[len-1]==len-1)             break;     } }  inline void build_lcp() {     k=0;     l0(i,len)     {         if(pos[i]!=len-1)             for(j=sa[pos[i]+1]; str[i+k]==str[j+k]; k++);         lcp[pos[i]]=k;         if(k)k--;     } }  /*inline void build_lcp() {     k=0;     l0(i,l1)     if(pos[i]!=len-1)     {         for(j=sa[pos[i]+1]; str[i+k]==str[j+k]; k++);         lcp[pos[i]]=k;         if(j>l1)             if(k>ans)             {                 ans=k;                 beg=j;                 end=beg+k;                 flag[j]=1;                 val[j].nlcp=k;             }             else if(k && k==ans)             {                 if(j<beg)                 {                     beg=j;                     end=beg+k;                 }                 flag[j]=1;                 val[j].nlcp=k;             }         if(k)             k--;     }     else         k=0;     k=0;     L(i,l1+1,len)     if(pos[i]!=len-1)     {         for(j=sa[pos[i]+1]; str[i+k]==str[j+k]; k++);         lcp[pos[i]]=k;         if(j<l1)         {             if(k>ans)             {                 ans=k;                 if(val[i].nlcp>=k)                     beg=val[i].start;                 else                     beg=i;                 end=beg+k;             }             else if(k && k==ans)             {                 //if(i==20)                 //cout<<"hi";                 if(val[i].nlcp>=k && val[i].start<beg)                 {                     beg=val[i].start;                     end=beg+k;                 }                 else if(i<beg)                 {                     beg=i;                     end=beg+k;                 }             }         }         else if(flag[i] && val[i].nlcp==ans && k>=ans)         {             if(j<beg)             {                 beg=j;                 end=beg+ans;             }             flag[j]=1;             val[j].nlcp=ans;          }         else if(j>i)         {             val[j].nlcp=k;             val[j].start=i;         }         if(k)             k--;     }     else         k=0; }*/  int main() {     //cout<<val[5].nlcp<<" "<<val[7].start<<endl;     sd(t);     while(t--)     {         sd(l1);         sd(temp);         cin>>str1>>str2;         str=str1+'$'+str2;         build_sa();         build_lcp();         //cout<<val[20].nlcp<<" "<<val[20].start<<endl;         /*l0(i,len)         cout<<sa[i]<<" ";         cout<<endl;         l0(i,len)         cout<<lcp[i];         cout<<endl;         l0(i,len)         cout<<flag[i]<<" ";         cout<<endl;*/         /*L(i,beg,end)         pc(str[i]);         if(ans)             pn;*/         temp=0;         ans=0;         //l0(i,len)         //cout<<lcp[i]<<" ";         //cout<<endl;          l1(i,len-1)         {             //cout<<lcp[i];             //cout<<lcp[i];             temp=min(temp,lcp[i]);             if((sa[i]<l1 && sa[i+1]>l1) || (sa[i]>l1 && sa[i+1]<l1))                 //if(temp<lcp[i])             {                 ans+=(lcp[i]-temp);                 temp=lcp[i];             }         }         plldn(ans);     }     return 0; } 
#include<bits/stdc++.h> #define s(n) scanf("%d",&n) #define sl(n) scanf("%lld",&n) #define p(n) printf("%d\n",n) #define mod 1000000009LL #define ll long long #define pb push_back #define mp make_pair #define N 100011 #define LN 21 using namespace std;  ll fib[N]; ll cfib[N]; struct T {  ll sum;  ll x;  ll y; }tree[4*N+14],tree1[4*N+14]; void build_tree(int idx,int l,int r) {  if(l==r)  {  tree[idx].sum=tree[idx].x=tree[idx].y=0;  tree1[idx].sum=tree1[idx].x=tree1[idx].y=0;  }  else  {   int mid=(l+r)/2;   build_tree(2*idx+1,l,mid);   build_tree(2*idx+2,mid+1,r);   tree[idx].sum=tree[idx].x=tree[idx].y=0;   tree1[idx].sum=tree1[idx].x=tree1[idx].y=0;  } } void lazy(int id,int l,int r,int ql,int qr) {   if(l>r)   return;   int el=r-l+1;   ll val=(tree[id].x*fib[el])%mod;   val=(val+tree[id].y*cfib[el-1])%mod;   tree[id].sum=(tree[id].sum+val)%mod;   if(l!=r)   {    int mid=(l+r)/2;    tree[2*id+1].x=(tree[2*id+1].x+tree[id].x)%mod;    tree[2*id+1].y=(tree[2*id+1].y+tree[id].y)%mod;    int el=mid-l+1;    tree[2*id+2].x=(tree[2*id+2].x+(tree[id].x*fib[el-1])%mod+(tree[id].y*fib[el])%mod)%mod;    tree[2*id+2].y=(tree[2*id+2].y+(tree[id].x*fib[el])%mod+(tree[id].y*fib[el+1])%mod)%mod;   }   tree[id].x=tree[id].y=0; }  void lazy2(int id,int l,int r,int ql,int qr) {   if(l>r)   return;   int el=r-l+1;   ll val=(tree1[id].x*fib[el])%mod;   val=(val+tree1[id].y*cfib[el-1])%mod;   tree1[id].sum=(tree1[id].sum+val)%mod;   if(l!=r)   {    int mid=(l+r)/2;    tree1[2*id+1].x=(tree1[2*id+1].x+tree1[id].x)%mod;    tree1[2*id+1].y=(tree1[2*id+1].y+tree1[id].y)%mod;    int el=mid-l+1;    tree1[2*id+2].x=(tree1[2*id+2].x+(tree1[id].x*fib[el-1])%mod+(tree1[id].y*fib[el])%mod)%mod;    tree1[2*id+2].y=(tree1[2*id+2].y+(tree1[id].x*fib[el])%mod+(tree1[id].y*fib[el+1])%mod)%mod;   }   tree1[id].x=tree1[id].y=0; } void update(int idx,int l,int r,int ql,int qr,int tr) {    int mid=(r+l)/2;    lazy(idx,l,r,ql,qr);   if(qr<l||ql>r||l>r)  return;  else if(ql<=l && qr>=r)  {   int en=r-ql+1+tr;   int str=l-ql+1+tr;   tree[idx].sum=((tree[idx].sum+cfib[en]-cfib[str-1])%mod+2*mod)%mod;   ll lx,ly;   lx=fib[str];   ly=fib[str+1];   if(l!=r)   {    int mid=(l+r)/2;    tree[2*idx+1].x=(tree[2*idx+1].x+lx)%mod;    tree[2*idx+1].y=(tree[2*idx+1].y+ly)%mod;    int el=mid-l+1;    tree[2*idx+2].x=(tree[2*idx+2].x+(lx*fib[el-1])%mod+(ly*fib[el])%mod)%mod;    tree[2*idx+2].y=(tree[2*idx+2].y+(lx*fib[el])%mod+(ly*fib[el+1])%mod)%mod;   }  }  else  {   update(2*idx+1,l,mid,ql,qr,tr);   update(2*idx+2,mid+1,r,ql,qr,tr);   tree[idx].sum=(tree[2*idx+1].sum+tree[2*idx+2].sum)%mod;  } }  void update2(int idx,int l,int r,int ql,int qr,int tr) {    int mid=(r+l)/2;    lazy2(idx,l,r,ql,qr);   if(qr<l||ql>r||l>r)  return;  else if(ql<=l && qr>=r)  {   int en=r-ql+1+tr;   int str=l-ql+1+tr;   tree1[idx].sum=((tree1[idx].sum+cfib[en]-cfib[str-1])%mod+2*mod)%mod;  // cout<<l<<" "<<r<<" "<<tree1[idx].sum<<" "<<ql<<" "<<qr<<endl;   ll lx,ly;   lx=fib[str];   ly=fib[str+1];   if(l!=r)   {    int mid=(l+r)/2;    tree1[2*idx+1].x=(tree1[2*idx+1].x+lx)%mod;    tree1[2*idx+1].y=(tree1[2*idx+1].y+ly)%mod;    int el=mid-l+1;    tree1[2*idx+2].x=(tree1[2*idx+2].x+(lx*fib[el-1])%mod+(ly*fib[el])%mod)%mod;    tree1[2*idx+2].y=(tree1[2*idx+2].y+(lx*fib[el])%mod+(ly*fib[el+1])%mod)%mod;   }  }  else  {   update2(2*idx+1,l,mid,ql,qr,tr);   update2(2*idx+2,mid+1,r,ql,qr,tr);   tree1[idx].sum=(tree1[2*idx+1].sum+tree1[2*idx+2].sum)%mod;   //cout<<l<<" "<<r<<" "<<tree1[idx].sum<<endl;  } }  ll query(int idx,int l,int r,int ql,int qr) {   int mid=(r+l)/2;      lazy(idx,l,r,ql,qr);   if(qr<l||ql>r||l>r)   return 0;   else if(ql<=l && qr>=r)   return tree[idx].sum;   else   return (query(2*idx+1,l,mid,ql,qr)+query(2*idx+2,mid+1,r,ql,qr))%mod; }  ll query2(int idx,int l,int r,int ql,int qr) {   int mid=(r+l)/2;      lazy2(idx,l,r,ql,qr);   if(qr<l||ql>r||l>r)   return 0;   else if(ql<=l && qr>=r)   {   return tree1[idx].sum;   }   else   return (query2(2*idx+1,l,mid,ql,qr)+query2(2*idx+2,mid+1,r,ql,qr))%mod; } int main() {  int i;  fib[0]=cfib[0]=0;  fib[1]=1;  for(i=2;i<N;++i)  fib[i]=(fib[i-1]+fib[i-2])%mod;  for(i=1;i<N;++i)  cfib[i]=(cfib[i-1]+fib[i])%mod;  int n,q;  cin>>n>>q;  build_tree(0,0,n-1);  for(i=0;i<q;++i)  {   int ty,x,y;   s(ty);s(x);s(y);   if(ty==1)   {    x--;    if(y<=x+1)    update(0,0,n-1,x-y+1,x,0);    else    update(0,0,n-1,0,x,y-x-1);    if(y>1)    {    if(x+y-1<=n-1)    update2(0,0,n-1,n-x-y,n-x-2,0);    else    update2(0,0,n-1,0,n-x-2,x+y-n);    }   }   else   {    x--;y--;    //assert(x<=y);    ll ans=query(0,0,n-1,x,y);    ans+=query2(0,0,n-1,n-1-y,n-1-x);    ans%=mod;    printf("%lld\n",ans);   }  } } 
#include<bits/stdc++.h>     using namespace std;     typedef long long ll;          #define max(a, b, c) ((a < b? (a < c? a : c) : (b < c? b : c)))       int main()     {         ll t,z,i,j,k,n,m,s,ans;         scanf("%lld",&t);         for(z=1;z<=t;z++)         {         	ll a,b,c;         	double p,q,r;             scanf("%lld%lld%lld",&a,&b,&c);             p=sqrt((a+b)*(a+b)+c*c);             q=sqrt((b+c)*(b+c)+a*a);               r=sqrt((a+c)*(a+c)+b*b);             printf("%.10lf\n",max(p,q,r));         }         return 0;     } 
#include<iostream> #include<cstdio> using namespace std;  #define MXN 100010  bool poss=1; int par[MXN]={0},n,a[MXN],c[MXN]={0};  void resolve(int l,int r) {     if(!poss) return;     int i,j;     for(i=l+1;i<=r;++i)     {            par[a[i]]=a[l];            if(c[i]>0)            {                            if(c[i]>r)                           {                                    poss=0;                                    return;                           }                      resolve(i,c[i]);                      i=c[i];            }     } }  /* 10 3 3 3 7 4 4 7 8 8 9 */  int main() {     int q,i,nd,l,r;     scanf("%d",&n);     for(i=1;i<=n;++i)     {          a[i]=i;          scanf("%d",&a[i]);     }     scanf("%d",&q);     //q=0;     if(a[1]!=1) poss=0;     while(q--)     {               scanf("%d%d%d",&nd,&l,&r);               if(a[l]!=nd) poss=0;               if(l==1 && r<n) poss=0;               if(c[l]>0 && c[l]!=r) poss=0;               c[l]=r;     }     resolve(1,n);     if(!poss) printf("0\n");     else     {         printf("1\n");         for(i=1;i<=n;++i)         {               if(i==a[1]) continue;               printf("%d %d\n",i,par[i]);         }     }     //system("pause"); } 
#include <bits/stdc++.h> using namespace std;  typedef long long ll; typedef unsigned long long ull; typedef vector<int> vi; typedef vector<ll> vll; typedef vector<vi> vvi; typedef pair<int,int> pii; typedef vector<pii > vii; typedef vector<pair<int, pair<int, int> > > viii; typedef pair<ll,ll> pll; typedef vector<string> vs; typedef vector<vii> vvii;  #define pb push_back #define mp make_pair #define X first #define Y second #define MEM(a,b) memset(a,(b),sizeof(a)) #define tr(c,it) for(typeof((c).begin()) it = (c).begin(); it != (c).end(); it++) #define all(a) a.begin(),a.end() #define loop(x,a,b) for(int (x) = (a);(x)<(b);(x)++) #define rep(x,n)   for(int (x)=0;(x)<(n);(x)++) #define present(c,x) ((c).find(x) != (c).end())  #define cpresent(c,x) (find(all(c),x) != (c).end()) #define ain(a,n) int ((a)[(n)]); for(int i=0; i<(n); i++) cin>>((a)[i])   #define md 1000000007 #define MAXN 200005  int main() {        ios::sync_with_stdio(false);     cin.tie(0);     int n;     cin>>n;      int deg[n];     MEM(deg,0);     int a[n][n];     MEM(a,0);     rep(i,n)       rep(j,i)       {         int t1,t2;         cin>>t1>>t2;         t1--;t2--;         deg[t1]++;         a[t1][t2] = 1;       }     vii v;     rep(i,n)       v.pb(mp(deg[i],i+1));     sort(all(v));     int tot = 0;     int f = 0;     rep(i,n-1)     {       tot += v[i].X;       if(tot <= (i+1)*(i)/2)         f = 1;     }     if(f == 0)     {       cout<<0<<"\n";     }     else     {       cout<<"1\n";       cout<<v[0].Y<<" "<<v[n-1].Y<<"\n";     }     return 0; } 
//Author:Hena Firdaus //GREEDY APPROACH...GIVING WA :() #include <bits/stdc++.h> using namespace std; int n,vc[100005],vis[100005]; vector<int>adj[100005]; int vertex_cover() {   	for(int i=1;i<=n;i++)   	{   		if(!vis[i])   		{   			for(int j=0;j<adj[i].size();j++)   			{   				int v=adj[i][j];   				if(vis[v]) continue;   					vis[v]=1;   					vis[i]=1;   					break;   				   			}   		}   	}   	int c=0;   	for(int i=1;i<=n;i++)   	{   		if(vis[i])   			c++;   		//cout<<vis[i]<<" ";   	}   	//cout<<endl;  return c/2; }  int main() { 	int m,a,b,k; 	cin>>n>>m>>k; 	while(m--) 	{ 		cin>>a>>b; 		adj[a].push_back(b); 		adj[b].push_back(a); 	} 		int vv; 		int h; 		memset(vis,0,sizeof(vis)); 		vv=vertex_cover(); 		//cout<<"vERTEX COVER:"<<vv<<endl; 		if(vv<k) 			cout<<"Case 1\n"; 		else 			 				cout<<"Case 2\n"; 	 	return 0; }
#include <bits/stdc++.h> using namespace std; typedef long long ll; #define N 200010 ll ar[N + 1];  ll inf = -1ll*4*pow(10,13) - 5; map <ll,vector<int> > mp; struct query {     ll x;     int id,l,r; }querys[N + 10];  ll ans[N + 10]; bool compare(query a,query b) {     return a.x < b.x; } struct seg {     ll maxsum,sum,psum,ssum; }segs[10*N + 10];  seg mergesegs(seg x,seg y) {     seg temp;     temp.sum = x.sum + y.sum;     temp.psum = max(x.psum,x.sum+y.psum);     temp.ssum = max(x.ssum+y.sum,y.ssum);     temp.maxsum = max(x.ssum+y.psum,max(x.maxsum,y.maxsum));     return temp; }  void Update(int nod,int b,int e,int x,ll v) {     if(b == e)     {         segs[nod].maxsum = v;         segs[nod].sum = v;         segs[nod].psum = v;         segs[nod].ssum = v;     }     else     {         int mid = (b+e)/2;         if(x<=mid) Update(2*nod+1,b,mid,x,v);         else Update(2*nod+2,mid+1,e,x,v);         segs[nod] = mergesegs(segs[2*nod+1],segs[2*nod+2]);     } }  seg Query(int nod,int b,int e,int l,int r) {     if(l<=b && e<=r)     {         return segs[nod];     }     else     {         int mid = (b+e)/2;         if(r <= mid) return Query(2*nod+1,b,mid,l,r);         else if(l > mid) return Query(2*nod+2,mid+1,e,l,r);         else return mergesegs(Query(2*nod+1,b,mid,l,r),Query(2*nod+2,mid+1,e,l,r));     } }   void Build(int nod,int b,int e) {     if(b == e)     {         segs[nod].maxsum = inf;         segs[nod].sum = inf;         segs[nod].psum = inf;         segs[nod].ssum = inf;     }     else     {         int mid = (b+e)/2;         Build(2*nod+1,b,mid);         Build(2*nod+2,mid+1,e);         segs[nod] = mergesegs(segs[2*nod+1],segs[2*nod+2]);     } }  int main() {     int n,q;      cin>>n>>q;      for(int i = 1 ; i<=n ; i++)     {        cin>>ar[i];         mp[ar[i]].push_back(i);     }     Build(0,1,n);      for(int i = 1 ; i<=q ; i++)     {         scanf("%d %d %lld",&querys[i].l,&querys[i].r,&querys[i].x);         querys[i].id = i;     }      sort(querys+1,querys+q+1,compare);      int j = 1;     for(map <ll,vector <int> > :: iterator it = mp.begin() ; it != mp.end() ; it++)     {         ll x = (*it).first;         while(j<=q && querys[j].x < x)         {             ans[querys[j].id] = Query(0,1,n,querys[j].l,querys[j].r).maxsum;             j++;         }         vector <int> &vec = (*it).second;         int sz = vec.size();         for(int i = 0 ; i<sz ; i++)         {             Update(0,1,n,vec[i],x);         }     }     while(j<=q)     {         ans[querys[j].id] = Query(0,1,n,querys[j].l,querys[j].r).maxsum;         j++;     }     for(int j = 1 ; j<=q ; j++)     {         if(ans[j] <= inf)         {             printf("xx\n");         }         else         {             printf("%lld\n",ans[j]);         }     }  } 
#include<bits/stdc++.h> using namespace std; typedef long long ll; ll ar[1000010],psum[1000010],x[1000010],y[1000010];  int main() { ll INF = LLONG_MAX;  int t; cin>>t; int n,i,j;  while(t--) {     cin>>n;     for(i=1;i<=n;i++)      cin>>ar[i];       sort(ar+1,ar+n+1);       for(i=1;i<=n;i++)       psum[i]=psum[i-1]+ar[i];      for(i=1;i<=n;i++)     {        j = (i+1)/2;         x[i] =(psum[i] - psum[j] - ar[j]*(i-j)) + (ar[j]*j - psum[j]);     }     reverse(ar+1,ar+n+1);       for(i=1;i<=n;i++)       psum[i]=psum[i-1]+ar[i];      for(i=1;i<=n;i++)     {        j = (i+1)/2;         y[n-i+1] = -(psum[i] - psum[j] - ar[j]*(i-j)) - (ar[j]*j - psum[j]);     }      y[n+1]=0;     x[0]=0;     ll ans=INF;     for(i=0;i<=n;i++)     {       ans=min(ans,x[i]+y[i+1]);     }     cout<<ans<<endl;     }   } 
#include <stdio.h>  int main() { 	int T; 	scanf("%d", &T);  	for (int t = 0; t < T; t++) 	{ 		int A[9][9]; 		int R[9],C[9],B[9]; 		for (int i = 0; i < 9; i++) 			R[i]=C[i]=B[i]=0; 		for (int i = 0; i < 9; i++) 			for (int j = 0; j < 9; j++) 			{ 				int x; 				scanf("%d", &x); 				x=x-1; 				A[i][j] = x; 				R[i] |= (1 << x); 				C[i] |= (1 << x); 				B[i/3+3*(j/3)] |= (1 << x);  			}  		bool ok = true; 		for (int i = 0; i < 9; i++) 		{ 			if (R[i] != 511 || B[i] != 511 || C[i] != 511  ) 			{ 				ok = false; 				break; 			} 		}  		if (ok) 			printf("Its A Sudoku\n"); 		else 			printf("Not A Sudoku\n"); 	}	  	return 0; }
// created by: Prashant Kumar Singh :) #include<iostream> #include<algorithm> #include<utility> #include<cstring> #include<string.h> #include<set> #include<queue> #include<map> #include<math.h> #include<stdio.h> #include<vector> #include<functional> #include<bitset> #include<iomanip> #define ll long long #define gr greater<ll>() #define pi acos(-1.0) #define pb push_back #define MS0(ar) memset(ar,0,sizeof ar) #define f first #define s second #define pii pair<int,int> #define pll pair<ll,ll> #define ind(a) scanf("%d",&a) #define inf(a) scanf("%lf",&a) #define inl(a) scanf("%lld",&a) #define ins(a) scanf("%s",a) #define pd(a) printf("%d\n",a) #define pl(a) printf("%lld\n",a); #define bitcnt(x) __builtin_popcountll(x) #define mp make_pair #define mod 1000000007 using namespace std; int dp[2][10001],n; int dis[10005],vis[10005]; int w[10005]; vector<pii>v[10005]; void dijistra(int src) {   for (int i = 1; i < n; i++)     dis[i] = mod;   MS0(vis);   int s, tmp;   dis[src] = 0;   priority_queue<pii, vector<pii>, greater<pii> > q;   q.push(pii(0, 0));   pii cur, tmp1;   while (!q.empty())   {     cur = q.top();     q.pop();     if (vis[cur.second])       continue;     vis[cur.second] = 1;     s = v[cur.second].size();     for (int i = 0; i < s; i++)     {       tmp1 = v[cur.second][i];       tmp = cur.first + tmp1.second;       if (dis[tmp1.first] > tmp)       {         dis[tmp1.first] = tmp;         q.push(pii(tmp, tmp1.first));       }     }   }    for (int i = 1; i < n; i++)     dis[i] *= 2;   return;  } int main() {   ios_base::sync_with_stdio(0);   cin.tie(0); #ifndef ONLINE_JUDGE   freopen("input.txt", "r", stdin); #endif   int e,t,a,b,c,d;   cin >> t;   while (t--)   {     cin >> n >> e >> d;     for (int i = 0; i < e; i++)     {       cin >> a >> b >> c;       v[a].pb(mp(b, c));       v[b].pb(mp(a, c));     }     MS0(dp);     for (int i = 1; i < n; i++)     {       cin >> w[i];     }     dijistra(0);     for (int i = 1; i < n; i++)     {       for (int j = 0; j <= d; j++)       {         if (j - dis[i] >= 0)         {           dp[(i&1)][j] = max(dp[!(i&1)][j], dp[!(i&1)][j - dis[i]] + w[i]);         }         else           dp[i&1][j] = dp[!(i&1)][j];       }     }     cout << dp[(n-1)&1][d] << endl;       for(int i = 0; i <= n; i++)         v[i].clear();   }    return 0; }
#include<bits/stdc++.h> using namespace std; map<string,int> mp; string name[10010]; vector<int> vec[10010]; int len[10010];  int main() {   int t,n,q,i,j;   cin>>t;   while(t--)   {    cin>>n>>q;    for(i=1;i<=n;i++)    {      vec[i].clear();      cin>>name[i];      mp[name[i]]=1;   //lexicographically sorted      len[i]=name[i].length();    }     int cnt=0;    map<string,int>::iterator it;     for(it=mp.begin();it!=mp.end();it++)    {      cnt++;      (*it).second=cnt;    }      for(i=1;i<=n;i++)    {      vec[mp[name[i]]].push_back(i);    }     int l,r;     int ans,sz;    while(q--)    {     cin>>l>>r;     ans=0;     sz=0;     for(i=1;i<=cnt;i++)     {       int ss=vec[i].size();       int le=0;       for(j=0;j<ss;j++)       {          if(vec[i][j]>=l && vec[i][j]<=r)          {             le=len[vec[i][j]];          }       }        if(le>0)       {          sz++; ans+=sz*le;       }     }     cout<<ans<<endl;      }      mp.clear();    }  } 
#include<iostream> #include<stdio.h> #include<map> #include<math.h> #include<string.h> #include<vector> #include<queue> #include<list> #include<iomanip> #include<algorithm> #define FOR(i,a,b) for(long long int i=(a);i<=(b);++i) #define NFOR(i,a,b) for(long long int i=(a);i>=(b);--i) #define pb push_back #define ll long long using namespace std; vector<ll>v; int main() {     ll t,n,x;     cin>>t;     while(t--)     {         cin>>n;       FOR(i,1,n)       {           cin>>x;           v.pb(x);       }       ll c=0;       ll inc=0,dec=0;       if(v[1]>v[0])         inc=1;       else         dec=1;       FOR(i,0,n-2)       {           if(inc)           {               if(v[i+1]<v[i])                 {c++;               inc=0;               dec=1;}           }           if(dec)           {               if(v[i+1]>v[i])                 {c++;               inc=1;               dec=0;}           }       }       cout<<c<<endl;       v.clear();     }     return 0; } 
#include<iostream> //#include<conio.h> //#include<fstream>  using namespace std;   unsigned long long int fib[]={0, 1 ,1ull ,2ull ,3ull ,5ull ,8ull ,13ull ,21ull ,34ull ,55ull ,89ull ,144ull ,233ull ,377ull ,610ull ,987ull ,1597ull ,2584ull ,4181ull ,6765ull ,10946ull ,17711ull ,28657ull ,46368ull ,75025ull ,121393ull ,196418ull ,317811ull ,514229ull ,832040ull ,1346269ull ,2178309ull ,3524578ull ,5702887ull ,9227465ull ,14930352ull ,24157817ull ,39088169ull ,63245986ull ,102334155ull ,165580141ull ,267914296ull ,433494437ull ,701408733ull ,1134903170ull ,1836311903ull ,2971215073ull ,4807526976ull ,7778742049ull ,12586269025ull ,20365011074ull ,32951280099ull ,53316291173ull ,86267571272ull ,139583862445ull ,225851433717ull ,365435296162ull ,591286729879ull ,956722026041ull ,1548008755920ull ,2504730781961ull ,4052739537881ull ,6557470319842ull ,10610209857723ull ,17167680177565ull ,27777890035288ull ,44945570212853ull ,72723460248141ull ,117669030460994ull ,190392490709135ull ,308061521170129ull ,498454011879264ull ,806515533049393ull ,1304969544928657ull ,2111485077978050ull ,3416454622906707ull ,5527939700884757ull ,8944394323791464ull ,14472334024676221ull ,23416728348467685ull ,37889062373143906ull ,61305790721611591ull ,99194853094755497ull ,160500643816367088ull ,259695496911122585ull ,420196140727489673ull ,679891637638612258ull ,1100087778366101931ull ,1779979416004714189ull ,2880067194370816120ull ,4660046610375530309ull ,7540113804746346429ull ,12200160415121876738ull};    bool binSearch(unsigned long long  n) {         int upper=93;   int lower=0;   int mid=0;   while(lower<=upper)   {                      mid=(lower+upper)/2;                      if(fib[mid]==n)                        return true;                      if(fib[mid]>n)upper=mid-1;                      else  lower=mid+1;                                             }      return false;        } int main() {             //  freopen("C:\\Users\\admin\\Desktop\\output.txt","w",stdout);   //  freopen("C:\\Users\\admin\\Desktop\\input.txt","r",stdin);               long long int t;     cin>>t;     unsigned long long int n;     while(t--)     {               cin>>n;  //             if(n==0 ){cout<<"YES\n";continue;}               if(binSearch(n))               {cout<<"YES\n";                               }               else               {                   cout<<"NO\n";               }                                                            }                                 //  getch();     return 0; } 
//FINDING KIDDO-smallest child of a parent //http://www.codechef.com/problems/ISM05  #include<iostream> using namespace std; int main(){ 	int t,n,i,j,sum; 	cin>>t; 	while(t--){ 		cin>>n; 		for(i=1;i<n;i++){ 			j=i; 			sum=i; 			while(j){ 				sum+=j%10; 				j/=10; 			} 			if(sum==n) break; 		} 		if(i==n) cout<<"NONE\n"; 		else cout<<i<<endl; 	} 	return 0; }
#include<stdio.h> #include<string.h> int main() { 	char a[102], c, temp; 	int te, i, j, p, q, n; 	scanf("%d\n", &te); 	while (te--) 	{ 		i = 0; 		gets(a); 		n = strlen(a); 		for (i = 0; i < n;) 		{ 			p = i; 			while (a[i] >= 97 && a[i] <= 122) 				i++; 			q = i - 1; 			while (p < q) 			{ 				temp = a[p]; 				a[p] = a[q]; 				a[q] = temp; 				p++; 				q--; 			} 			i++; 		} 		for (i = 0; i < n; i++) 			printf("%c", a[i]); 		printf("\n"); 	} 	return 0; }
#include<iostream> #include<bits/stdc++.h>   using namespace std; typedef long long ll; ll cal(ll n) { 	 	ll val=1,co=1; ll sum=0; while(val<= n) { //cout<<"inside"<<endl; 	if(co%2==1) {sum+=co; //cout<<"co"<<co<<endl; 	}	 	 	co++; 	val=val+co; 	 	 } 	 	val=val-co; 	 		ll k=co-1,kk= n -val;  if(kk!=0) 	{ 		if(kk%2==1) 		{ 		sum=sum+co;	 			 		} 	 		 		 	} 	 	 	return sum; } int main() { 	 	 	int t; 	cin>>t; 	while(t--) 	{ 	 ll n,m; cin>>n>>m; n--;   	 	 ll sum1=cal(n);   ll  sum=cal(m);  ll ans=sum-sum1;   cout<<ans<<endl;   } 	return 0; 	 }
#include<bits/stdc++.h> #define s(n) scanf("%d",&n) #define sl(n) scanf("%lld",&n) #define p(n) printf("%d\n",n) #define mod 1000000007LL #define ll long long #define pb push_back #define mp make_pair #define N 100011 #define LN 21 using namespace std; int bit[2*N],maxval,bit1[2*N],maxval1,bit2[2*N],bit3[2*N]; ll powmod(ll a,ll b,ll c) {  ll res=1LL;  while(b>0)  {   if(b&1)   res=(res*a)%c;   a=(a*a)%c;   b/=2;  }  return res; } ll inverse(ll a,ll MOD) { if(a==0) return 1LL; else return powmod(a,MOD-2,MOD); } void update(int idx,int val) {  while(idx<=maxval)  {   bit[idx]+=val;   idx+=(idx & -idx);  } } int query(int idx) {  int sum=0;  while(idx>0)  {    sum+=bit[idx];    idx-=(idx & -idx);  }  return sum; } ll fact[400005]; int lc[400005],lc1[400005];  ll ncr(int n,int r) {  ll num=fact[n];  ll den=(fact[r]*fact[n-r])%mod;  ll ans=(num*inverse(den,mod))%mod;  return ans; } int main() {  int t,n,l,k,i;  int a[50002];  s(t);  while(t--)  {   s(l);s(n);s(k);   for(i=0;i<n;++i)   s(a[i]);   sort(a,a+n);   ll ans=0;   for(i=0;i<n;++i)   {    if(a[i]>k)    ans+=(n-i-1);    else    {     int ri=n-1-i;     int lo=i+1;     int hi=n-1;     int id1,id2;     id1=id2=-1;     while(lo<=hi)     {      int mid=(lo+hi)/2;      if(a[mid]-a[i]>k)      {       id1=mid;       hi=mid-1;      }      else      lo=mid+1;     }     if(id1!=-1)     id1=n-id1;     lo=i+1;     hi=n-1;      while(lo<=hi)     {      int mid=(lo+hi)/2;      if(l-a[mid]>k)      {       id2=mid;       lo=mid+1;      }      else      hi=mid-1;     }     if(id2!=-1)     id2=id2-i;     //cout<<id1<<" "<<id2<<" "<<i<<endl;     id1=max(0,id1);     id2=max(id2,0);     ans+=min(ri,id1+id2);    }   }   cout<<ans<<endl;  } } 
#include<iostream> #include<fstream> #include<stdlib.h> #include<limits.h> #include<math.h> #include<cstdio> #include<vector> #include<string> #include<cstring> #include<queue> #include<map> #include<set> #include<algorithm> #include<iomanip> #include<bitset> using namespace std; int t,s,n; int main() { //freopen("ttt.txt", "r", stdin); scanf("%d",&t); while(t--) { scanf("%d",&s); n=0; while(s>0) {  if(!(s%2)) {     s/=2; } else {   s=s-1;   n++; } } printf("%d\n",n); }  return 0; } 
#include<bits/stdc++.h> #define s(n) scanf("%d",&n) #define sl(n) scanf("%lld",&n) #define p(n) printf("%d\n",n) #define mod 1000000007LL #define ll long long #define pb push_back #define mp make_pair #define N 100011 #define LN 21 using namespace std; int bit[2*N],maxval,bit1[2*N],maxval1,bit2[2*N],bit3[2*N]; ll powmod(ll a,ll b,ll c) {  ll res=1LL;  while(b>0)  {   if(b&1)   res=(res*a)%c;   a=(a*a)%c;   b/=2;  }  return res; } ll inverse(ll a,ll MOD) { if(a==0) return 1LL; else return powmod(a,MOD-2,MOD); } void update(int idx,int val) {  while(idx<=maxval)  {   bit[idx]+=val;   idx+=(idx & -idx);  } } int query(int idx) {  int sum=0;  while(idx>0)  {    sum+=bit[idx];    idx-=(idx & -idx);  }  return sum; } ll fact[400005]; int lc[400005],lc1[400005];  ll ncr(int n,int r) {  ll num=fact[n];  ll den=(fact[r]*fact[n-r])%mod;  ll ans=(num*inverse(den,mod))%mod;  return ans; } int main() { int i,t,n; fact[0]=fact[1]=1; for(i=2;i<=400000;++i) fact[i]=(fact[i-1]*i)%mod; cin>>t; while(t--) {  string s1;  cin>>s1>>n;  if(n==1)  {   int an=0;   for(i=0;i<s1.length();++i)   if(s1[i]=='o')   an++;   cout<<an<<endl;  }  else  {   int l=n/2;   if(s1[0]=='l')   lc[0]=1;   else   lc[0]=0;   for(i=1;i<s1.length();++i)   {    lc[i]=lc[i-1];    if(s1[i]=='l')    lc[i]++;   }   int len=s1.length();   assert(len<=400000);   if(s1[len-1]=='l')   lc1[len-1]=1;   else   lc1[len-1]=0;   for(i=len-2;i>=0;--i)   if(s1[i]=='l')   lc1[i]=lc1[i+1]+1;   else   lc1[i]=lc1[i+1];   ll ans=0;   for(i=0;i<len;++i)   {    if(s1[i]=='u')    {     if((lc[i]>=l) && (lc1[i]>=l))     ans+=(ncr(lc[i],l)*ncr(lc1[i],l));     assert(ans>=0);     ans%=mod;    }   }   cout<<ans<<endl;  } } return 0; } 
#include<iostream> using namespace std;  int main() {	 	 int t; 	 scanf("%d",&t); 	 while(t--) 	 {  		int a,xi,x,cnt=0;  		xi=0;  		for(int i=0;i<15;i++)  		{ 		 	scanf("%d",&a); 		 	xi=xi^a; 		 } 		 scanf("%d",&x); 		 while(xi) 		 {  			  			if(xi&1)  			cnt++;  			xi>>=1;  		}  		if(cnt>x)  		printf("YES\n");  		else 	 	printf("NO\n");  	} 	 return 0; }
#include<bits/stdc++.h>  using namespace std;  int func(int a1){ 	int ans =0; 	while(a1>0){ 		ans+= a1%2; 		ans++; 		a1 /= 2; 	} 	ans-=2; 	return ans; } int main(){ 	ios::sync_with_stdio(false);    int T; 	cin>>T; 	while(T--){ 	int n; 	cin>>n; 	int a = n, b =0, ans = 0,a1 = n; 	ans = func(a1); //	cout<<ans<<endl; 	int anscp = ans, ansc = ans; 	int n1 = n/2, n2 = n/2 + n%2; 	anscp = min(anscp, max(func(n1),func(n2)) ); 	while(a>0){ //		cout<<max(func(a),func(b))<<' '<<b<<endl; 		anscp = min(anscp,max(func(a),func(b))); 		 		b += a&(-a); 		ans -= 1; 		a -= a&(-a);  	}  	cout<<anscp<<endl; 	} 	return 0; } 
//Author : pakhandi // using namespace std;  #include<iostream> #include<cstdio> #include<cstdlib> #include<algorithm> #include<cmath> #include<cstring>  #define wl(n) while(n--) #define fl(i,a,b) for(i=a; i<b; i++) #define rev(i,a,b) for(i=a; i>=b; i--) #define scan(n) scanf("%d", &n) #define scans(s) scanf("%s", s) #define scanc(c) scanf("%c", &c) #define scanp(f) scanf("%f", &f) #define scanll(l) scanf("%lld", &l) #define print(n) printf("%d\n", n) #define prints(s) printf("%s\n", s) #define printc(c) printf("%c\n", c) #define printp(f) printf("%f\n", f) #define printll(l) printf("%lld\n", l) #define MOD 1000000007 #define ll long long int  int fgcd(int a, int b)		//a>b { 	if(a%b==0) 	{ 		return b; 	} 	return fgcd(b,a%b); }  int main() { 	int i, j, cases, x1, y1, x2, y2, ans, a, b; 	scan(cases); 	wl(cases) 	{ 		scan(x1); 		scan(y1); 		scan(x2); 		scan(y2); 		a=abs(x2-x1); 		b=abs(y2-y1); 		if(a==0) 		{ 			ans=b-1; 			//continue; 		} 		else if(b==0) 		{ 			ans=a-1; 			//continue; 		} 		else 			ans=fgcd(a,b)-1; 		if(ans>=0) 			print(ans); 		else 			printf("0\n"); 	} 	return 0; }
#include<iostream> #include<cstdio> #include<cstring> #include<cmath> #include<set> #include<vector> #include<map> #include<algorithm>  using namespace std;  #define maxn 300009 #define maxn1 100009 #define mod  1000000007 #define inf 10000009 #define gc getchar_unlocked  typedef long long ll; typedef pair<int,int> ii;  int n,c; int arr[maxn];  vector<int> v1[maxn1]; vector<int> :: iterator it1,it2;   struct segment { 	int total,color,length,st1,ed1; };  int read() {   int ret = 0;   char c = gc();   while(c<'0' || c>'9') c = gc();   while(c>='0' && c<='9') {     ret = 10 * ret + c - 48;     c = gc();   }   return ret; }  segment tree[4*maxn];  int func(int color , int start , int end) { 	it1 = lower_bound(v1[color].begin() , v1[color].end() , start); 	it2 = upper_bound(v1[color].begin() , v1[color].end() , end); 	 	if(it1!=v1[color].end() && it2!=v1[color].end()) 	{ 		int index1 = it1 - v1[color].begin() ; 		int index2 = it2 - v1[color].begin() ;  		index2--;  		if(v1[color][index2]<=end && v1[color][index2]>=start && v1[color][index1]>=start && v1[color][index1]<=end) 		return index2-index1 +1;  		else 		return 0; 	} 	 	else if(it1 != v1[color].end() && it2 == v1[color].end()) 	return (v1[color].size() - ( it1-v1[color].begin() ) );  	else if(it1 == v1[color].end() && it2 == v1[color].end()) 	return 0; }   segment merge(segment node1 , segment node2,int start1,int end1 , int start2 , int end2) { 	segment result;  	result.total = 0; 	result.color=-1; 	result.length=node1.length + node2.length; 	if(start1 != inf &&start2!=inf && end1!=inf && end2!=inf) 	{   		result.st1 = start1; 		result.ed1 = end2; 	} 	else if(start1 == inf && start2 !=inf && end1==inf && end2!=inf) 	{ 		result.st1 = start2; 		result.ed1 = end2; 	} 	else if(start1 != inf &&start2==inf && end1!=inf && end2==inf) 	{ 		result.st1 = start1; 		result.ed1 = end1; 	} 	else  	{ 		result.st1 = inf; 		result.ed1 =inf; 		return result; 	} 	if(node1.color == -1 && node2.color == -1) 	{ 		result.total = 0; 		result.color = -1; 	} 	else if(node1.color==-1 && node2.color!=-1) 	{ 		int t1 = func(node2.color , start1 , end1); 		if(t1 + node2.total > (result.length/2)) 		{ 			result.total = node2.total+t1; 			result.color = node2.color; 		} 	} 	else if(node1.color != -1 && node2.color == -1) 	{ 		int t1 = func(node1.color , start2 , end2); 		if(t1 + node1.total > (result.length/2)) 		{ 			result.total = node1.total + t1; 			result.color = node1.color; 		} 	} 	else if(node1.color != -1 && node2.color != -1) 	{ 		int color1 = node1.color; 		int color2 = node2.color; 		if(color1==color2) 		{ 			result.total = node1.total + node2.total; 			result.color = color1; 		} 		else 		{ 			int t1=0,t2=0; 			t1 = func(color1,start2,end2); 			t2 = func(color2,start1,end1);  			int len1 = node1.length; 			int len2 = node2.length; 			 			if(((len1+len2)/2) < t1+ node1.total) 			{ 				result.color = color1; 				result.total = t1+ node1.total; 			} 		  else if(((len1+len2)/2) < t2+ node2.total) 			{ 				result.color = color2; 				result.total = t2 + node2.total; 			} 		} 	}  	return result; }  void build_tree(int node, int a, int b)  {     if(a > b) return;    	if(a == b)  		{      		tree[node].color = arr[a]; 				tree[node].total = 1;  				tree[node].length = 1; 				tree[node].st1 =a; 				tree[node].ed1 = b; 				return; 		} 		 		int mid = (a+b)/2;	 		int start1 = a; 		int end1 = mid; 		int start2 = mid+1; 		int end2 = b;  		build_tree(node*2, a, (a+b)/2);  		build_tree(node*2+1, 1+(a+b)/2, b); 	 	  tree[node] = merge(tree[node*2], tree[node*2+1],tree[node*2].st1,tree[node*2].ed1,tree[node*2+1].st1,tree[node*2+1].ed1); }  segment query_tree(int node, int a, int b, int i, int j)  { 	segment res1,dummy,res2,res3,res4;  	dummy.total=0; 	dummy.color=-1; 	dummy.length=0; 	dummy.st1 = inf; 	dummy.ed1 = inf; 	if((a > b) || (a > j) || (b < i)) return dummy;  	 	if(a >= i && b <= j)  	{ 		res1.color = tree[node].color; 		res1.total = tree[node].total; 		res1.length = tree[node].length; 		res1.st1 = a; 		res1.ed1 = b; 		return res1; 	} 	 	int mid = (a+b)/2; 	int start1 = a; 	int end1 = mid; 	int start2 = mid+1; 	int end2 = b; 	  	res1 = query_tree(node*2, a, (a+b)/2, i, j);  	res2 = query_tree(1+node*2, 1+(a+b)/2, b, i, j);    	segment res = merge(res1,res2,res1.st1,res1.ed1,res2.st1,res2.ed1);  	return res; }  int main()  { 	//scanf("%d%d",&n,&c); 	n=read(); 	c=read(); 	for(int i=0;i<n;i++) 	{ 		//scanf("%d",&arr[i]); 		arr[i] = read(); 		v1[arr[i]].push_back(i); 	}  	build_tree(1,0,n-1); 	 	int m,l,r; 	scanf("%d",&m); 		 	for(int i=0;i<m;i++) 	{ 		l=read(); 		r = read(); 		//scanf("%d%d",&l,&r); 		l--; 		r--;  		segment result = query_tree(1,0,n-1,l,r);  		if(result.color==-1) 		printf("no\n"); 		else 		printf("yes %d\n",result.color);  	} 	return 0; } 
#include <bits/stdc++.h> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {         int x,y,z,u,v,i;         cin>>x>>y>>u>>v;         if(u>v)         {             i=floor((y-x)/(u-v));             z=u*i;             cout<<"("<<z+x<<","<<"0)"<<endl;         }         else             cout<<"not possible"<<endl;     }     return 0; }
#include<bits/stdc++.h> #include<iostream> using namespace std; bool perfectSquare(int x) { 	int s=sqrt(x); 	return(s*s==x); } int main() { 	int T,N1,N2; 	long long int N; 	cin>>T; 	while(T--) 	{ 		cin>>N; 		N1=5*N*N+4; 		N2=5*N*N-4; 		if(perfectSquare(N1) || perfectSquare(N2)) 		cout<<"is fibo"<<endl; 		else 		cout<<"not fibo"<<endl; 	} 	return 0; }
 #include<bits/stdc++.h>     using namespace std;       int minJumps(int arr[], int n)     {     int *jumps = new int[n]; // jumps[0] will hold the result     int min;     // Minimum number of jumps needed to reach last element     // from last elements itself is always 0     jumps[n-1] = 0;     int i, j;     // Start from the second element, move from right to left     // and construct the jumps[] array where jumps[i] represents     // minimum number of jumps needed to reach arr[m-1] from arr[i]     for (i = n-2; i >=0; i--)     {     // If arr[i] is 0 then arr[n-1] can't be reached from here     if (arr[i] == 0)     jumps[i] = INT_MAX;     // If we can direcly reach to the end point from here then     // jumps[i] is 1     else if (arr[i] >= n - i - 1)     jumps[i] = 1;     // Otherwise, to find out the minimum number of jumps needed     // to reach arr[n-1], check all the points reachable from here     // and jumps[] value for those points     else     {     min = INT_MAX; // initialize min value     // following loop checks with all reachable points and     // takes the minimum     for (j = i+1; j < n && j <= arr[i] + i; j++)     {     if (min > jumps[j])     min = jumps[j];     }     // Handle overflow     if (min != INT_MAX)     jumps[i] = min + 1;     else     jumps[i] = min; // or INT_MAX     }     }     return jumps[0];     }     // Driver program to test above function     int main()     {     int t,n;     cin>>t;     while(t--){     cin>>n;     int arr[1001];     int i;     for(i=0;i<n;i++)     cin>>arr[i];     printf("%d\n", minJumps(arr, n-1));     }     return 0;     }
#include<stdio.h> #include<algorithm> using namespace std; int pipes[10004]; int main() {     int cases;     scanf("%d",&cases);     while(cases--)     {         int num,i,flag=-1;         long long sum = 0;         scanf("%d",&num);         for(i=0; i<num; i++)         {             scanf("%d",&pipes[i]);             sum += pipes[i];         }         sort(pipes,pipes+num);         for(i=num-1; i>1; i--)         {             if(sum-pipes[i] > pipes[i])             {                 flag = i+1;                 break;             }             sum -= pipes[i];         }         printf("%d\n",flag);     }     return 0; } 
#include <math.h> #include<stdio.h> #include<iostream> using namespace std; int main() {   int arr[40];   arr[0]=0;   arr[1]=1;   arr[2]=1;   for(int i=3;i<=40;i++)     arr[i]=arr[i-1]+arr[i-2];   int test;   scanf("%d",&test);    while(test--)   {       int flag=0;       int n,i;       scanf("%d",&n);       if(n==0)       {           cout<<"Yes\n";           continue;       }       for(i=0;i<40;i++)       {         if(arr[i]==n)         {             printf("Yes\n");             flag=1;             break;         }       }       if(flag==0)         printf("No\n");   }   return 0; } 
#include <iostream> #include<cstdio> using namespace std; int main()    { int n; long int arr[]={ 3,4, 33,34,43,44, 333,334,343,344,433,434,443,444, 3333,3334,3343,3344,3433,3434,3443,3444, 4333,4334,4343,4344,4433,4434,4443,4444, 33333,33334,33343,33344,33433,33434,33443,33444, 34333,34334,34343,34344,34433,34434,34443,34444, 43333,43334,43343,43344,43433,43434,43443,43444, 44333,44334,44343,44344,44433,44434,44443,44444, 333333,333334,333343,333344,333433,333434,333443,333444, 334333,334334,334343,334344,334433,334434,334443,334444, 343333,343334,343343,343344,343433,343434,343443,343444, 344333,344334,344343,344344,344433,344434,344443,344444, 433333,433334,433343,433344,433433,433434}; scanf("%d",&n); printf("%ld",arr[n-1]); }
#include <iostream> #include<string.h> #include<algorithm> using namespace std;  int main() { char a[150],b[150]; int arr[150],brr[150],sum[200],lena,lenb; int i,m=0,k=0; cin>>a>>b; lena=strlen(a); lenb=strlen(b); for(i=lena-1;i>=0;i--) arr[k++]=a[i]-'0'; k=0; for(i=lenb-1;i>=0;i--) brr[k++]=b[i]-'0';  for(i=0;i<max(lena,lenb);i++) {  m=m+arr[i]+brr[i];  sum[i]=m%10;  m=m/10; } while(m>0) { sum[i++]=m%10; m=m/10; } cout<<"Result = "; for(k=i-1;k>=0;k--) cout<<sum[k];      	return 0; }
#include<stdio.h> int main() {         int a[200]; //array will have the capacity to store 200 digits.     int n,i,j,temp,m,x;        scanf("%d",&n);        a[0]=1;  //initializes array with only 1 digit, the digit 1.        m=1;    // initializes digit counter         temp = 0; //Initializes carry variable to 0.        for(i=1;i<=n;i++)        {             for(j=0;j<m;j++)             {                x = a[j]*i+temp; //x contains the digit by digit product                a[j]=x%10; //Contains the digit to store in position j                temp = x/10; //Contains the carry value that will be stored on later indexes             }              while(temp>0) //while loop that will store the carry value on array.              {                 a[m]=temp%10;                temp = temp/10;                m++; // increments digit counter              }       }               for(i=m-1;i>=0;i--) //printing answer               printf("%d",a[i]);               printf("\n");         return 0; }
#include <iostream> #include<map> using namespace std;  map<int,bool> visit;  int bin_search(int a[], int n, int k){ 	 	int low=0,high= n-1; 		 //	for(int i=0;i<n;i++) //		cout<<a[i]<<" "; 	 	 	while(low<=high){ 		int mid = (high+low)/2; 		 		if(a[mid] == k){ 			return 1; 		 		if(a[mid]>k) 		high=mid-1; 		else 		low= mid+1; 		} 	} 	 	return -1; }  int main() { 	// your code goes here 	int n; 	cin>>n; 	visit.clear(); 	int a[n+1],i; 	 	for(i=0;i<n;i++) 	{ 		cin>>a[i]; 		visit[a[i]]=1; 	} 		 	int sum; 	cin>>sum; 	bool f=0; 	 	for(i=0;i<n;i++){ 		int left = a[i]; 		 		if(sum>=left && visit[sum-left]==1) 		{ 			cout<<"YES\n"; 			f=1; 			break; 		} 	} 	 	if(f==0) 	cout<<"NO\n"; 	 	return 0; }
#include<iostream> #include<vector> #include<string.h> #include<stdio.h> #include<climits> #include<map> #include<math.h> #include<set> #include<algorithm> #define LL long long int #define P(N) printf("%d\n",N); #define S(N) scanf("%d",&N); #define SL(N) scanf("%lld",&N); #define pb push_back #define mp make_pair #define pnl printf("\n"); #define FOR(i,a,b) for (i=a;i<=b;i++) #define mem(a,val) memset(a,val,sizeof(a)) using namespace std; int gcd(int a, int b){ int temp; while(b>0)	{ temp= b; b=a%b; a=temp;}	return a;} vector<int>adj[5005]; int dp[5005][2]; // 0 include, 1 exclude void liss(int node) {     int include=1,exclude=0,len= adj[node].size(),V;     for(int i=0;i<len;i++)     {         V= adj[node][i];         liss(V);         include+=dp[V][1];         exclude+= max(dp[V][1],dp[V][0]);     }     dp[node][0]= include;     dp[node][1]= exclude;     return; } int main() {        #ifndef ONLINE_JUDGE        //     freopen("C:\\Users\\hp pc\\Desktop\\input.txt", "r", stdin);       #endif       int i,j,t,N,u,v;       S(t);       while(t--)       {             memset(dp,0,sizeof(dp));             S(N) N--;             for(int i=0;i<=N+1;i++)adj[i].clear();             while(N--)             {                 scanf("%d %d",&u,&v);                 adj[v].pb(u);             }             liss(0);             printf("%d\n",max(dp[0][0],dp[0][1]));       } return 0; } 
#include<iostream> #include<algorithm> using namespace std; int a[1001]; int main() {     int t,n,i,b;     cin>>t;     while(t--)     {         cin>>n;         for(i=1;i<=1000;i++)             a[i]=0;         for(i=1;i<=n;i++)         {            cin>>b;            a[b]++;          }         int c=0;         for(i=1;i<=1000;i++)         {             if(a[i]>1)                 c++;         }         cout<<c<<endl;     } } 
#include<iostream> #include<vector> #include<algorithm> #include<cstdio> #include<string> #include<cstdlib> #include<cmath> #include<set> #include<cstring> using namespace std; #define gc getchar_unlocked long read_int() {   char c = gc();   while(c<'0' || c>'9') c = gc();   long ret = 0;   while(c>='0' && c<='9') {     ret = 10 * ret + c - 48;     c = gc();   }   return ret; } main() {      int t;scanf("%d",&t);      while(t--)      {        int n=read_int();        int x=0,y=0;        for(int i=0;i<n;i++)        {           int a=read_int(),b=read_int();           x+=a;           y+=b;        }        cout<<x-y<<endl;      }      }
#include<bits/stdc++.h> using namespace std; int fun(long int n) { int ans=0; while(n%2==0) { n=n/2; ans=n; } for(int i=3;i<=sqrt(n);i=i+2) { while(n%i==0) { ans=i; n=n/i; } } if(n>2) ans=n; return ans; } int main() { int t; long int n; scanf("%d",&t); while(t--) { scanf("%ld",&n); int ans=fun(n); ans=n/ans; printf("%d\n",ans); } return 0; } 
#include<bits/stdc++.h> using namespace std; typedef unsigned long long ll; #define s(n) scanf("%llu",&n)   int main() { ll T,i,t1,t2,t3,sum=0;   s(T);   while(T--) { s(t1);s(t2);s(t3);sum=0;   sum= t1/3+t2/3+t3/3+ min( t1%3 , min( t2%3 ,t3%3 )); if((t1%3==2 && t2%3==2 && t3%3==0 &&t3>0) || (t3%3==2 && t2%3==2 && t1%3==0 &&t1>0) || (t1%3==2 && t3%3==2 && t2%3==0 &&t2>0))  sum++;  cout<<sum<<"\n";  }  }
#include<cstdio> #include<iostream> #include<cstring> using namespace std; long int dp[101][201]; long int dp1[101][201]; char inp[101][25];  int a[101][201]; int n,m; long int ret(int i,int j){ //	printf("%d %d\n",i,j); 	if(j==m){ 		return 0; 	} 	if(dp[i][j]==-1){ 		int k; 		int ind; 		long int minn=ret(i,j+1); 		ind=i; 		long int y; 		for(k=0;k<n;k++){ 			if(k!=i){ 				y=ret(k,j+1)+a[k][j]-(a[i][j]-100); 				if(y<minn){ 					minn=y; 					ind=k; 				} 			} 		} 		dp[i][j]=minn; 		dp1[i][j]=ind; 	} 	return dp[i][j]; } int main(){ 	char s[100]; 	while(1){ 		scanf("%s",s); 		if(strcmp(s,"TheEnd")==0){ 			break; 		} 		cin >> n >> m; 		int i,j; 		//cout << n << m << endl; 		for(i=0;i<n;i++){ 			scanf("%s",inp[i]); 			for(j=0;j<m;j++){ 				scanf("%d",&a[i][j]); 				dp[i][j]=-1; 			} 		} /*		for(i=0;i<n;i++){ 			for(j=0;j<m;j++){ 				printf("%d ",a[i][j]); 			} 			printf("\n"); 		}*/ 		long int minn=a[0][0]+ret(0,1); 		long int y; 		int out[m]; 		int ind=0; 		for(i=1;i<n;i++){ 			y=a[i][0]+ret(i,1); 			if(y<minn){ 				minn=y; 				ind=i; 			} 		} 		int k; 		k=0; 		out[k]=ind; 		k++; 		ind=dp1[ind][k]; 		while(k<m){ 			out[k]=ind; 			k++; 			ind=dp1[ind][k]; 		} /*		for(i=0;i<m;i++){ 			printf("%d ",out[i]); 		} 		printf("\n");*/ 		printf("%s\n",s); 		cout << "Tk "<< minn << endl; 		i=0; 		int c=0; 		while(i<m-1){ 			c=1; 			while(1){ 				if(i>=m-1){ 					break; 				} 				if(out[i]==out[i+1]){ 					i++; 					c++; 				} 				else{ 				break; 				} 			} 			printf("%s for %d month(s)\n",inp[out[i]],c); 			i++; 		} 		if(out[m-1]!=out[m-2]){ 			printf("%s for 1 month(s)\n",inp[out[m-1]]); 		} 		cout << endl; 	} 	printf("TheEnd\n"); 	return 0; } 
#include <cstdio> #include <cstring> #include <cmath> #include <algorithm> #include <vector> #include <utility> #include <set> #include <map> #include <iostream> #include <queue> #include <climits>  using namespace std;  typedef long long LL;  #define PB push_back #define FRO freopen("in.txt","r",stdin);  #define CLR(arr) memset( (arr),0,sizeof(arr) ); #define NEG(arr) memset( (arr),-1,sizeof(arr) );  typedef pair<int,int> pint; typedef map<int,int> mint;  #define SIZE 105  double h[SIZE][SIZE]; vector<double> cost[SIZE][SIZE];  struct node{     int r,c;     double val;     bool operator < (const node & p)const{return val>p.val;} };  bool vis[SIZE][SIZE];  int row ,col;  int dr[]={-1,0,1,0}; int dc[]={0,-1,0,1};  double dijkstra(int sr,int sc , int fr , int fc ){      for (int i=1;i<=row;++i){         for (int j=1;j<=col;++j){             vis[i][j]=false;         }     }      //CLR(vis);      node place,temp,u;     place.val=0;     place.r=sr;     place.c=sc;       priority_queue<node> q;      q.push(place);       while (!q.empty())     {         temp=q.top();q.pop();         if (temp.r == fr && temp.c ==fc ){             return temp.val;         }          if (vis[temp.r][temp.c])             continue;         vis[temp.r][temp.c]=true;           for (int i=0;i<4;++i)         {             u.r=temp.r+dr[i];             u.c=temp.c+dc[i];              if ( u.r>0 && u.r<=row && u.c>0 && u.c<=col && !vis[ u.r ][ u.c ] ){                 //cout<<cost[temp.r][temp.r].size()<<endl;                 u.val=temp.val+cost[temp.r][temp.c][i];                 q.push(u);             }         }     }     return -1; }   int main(){      //FRO      int kase;     scanf("%d",&kase);      for (int kk=1;kase--;++kk){          scanf("%d %d",&row,&col);          for (int i=1;i<=row;++i){             for (int j=1;j<=col;++j){                 scanf("%lf",&h[i][j]);                 cost[i][j].clear();             }         }         int r,c;         for (int i=1;i<=row;++i){             for (int j=1;j<=col;++j){                 for (int k=0;k<4;++k){                     r=i+dr[k];                     c=j+dc[k];                     double h1= h[i][j];                     double h2= h[ r ][ c ];                      if ( h1 > h2 ){                         cost[i][j].PB( 0.5 + 0.5 * sqrt( 1 + (h1 - h2 )*(h1 - h2 ) ) );                     }else{                         cost[i][j].PB( -0.5 + 1.5 * sqrt( 1 + (h1 - h2 )*(h1 - h2 ) ) );                     }                 }             }         }          int qq;         scanf("%d",&qq);         int sr,sc,fr,fc;         printf("Case %d:\n",kk);         while ( qq-- ){              scanf("%d %d %d %d",&sr,&sc,&fr,&fc);              printf("%.6lf\n",dijkstra( sr,sc,fr,fc ) );         }     }       return 0; } 
#include<iostream> #include<stdlib.h> #include<string> using namespace std; void LPSArray(string str) {     long long int l =str.length();     long long int *lps = (long long int *)malloc(sizeof(long long int)*l);     long long int len=0,i=1;     lps[0] = 0;     if(l-1!=0)         cout<<lps[0]<<" ";     while(i<l)     {         if(str[i]==str[len])         {             len++;             lps[i] = len;             if(i!=l-1)                 cout<<lps[i]<<" ";             i++;         }         else         {             if(len!=0)                 len = lps[len-1];             else             {                 lps[i]=0;                 if(i!=l-1)                     cout<<lps[i]<<" ";                 i++;             }         }     }     i--;     cout<<lps[i]<<endl;  } int main() {     string str;     cin>>str;     while(str.compare("End")!=0)     {         LPSArray(str);         cin>>str;     }     return 0; } 
#include <bits/stdc++.h>  using namespace std;  #define rept(i,a,b) for(int (i) = (a); i < (b); i++) #define rep(i,n) for(int (i) = 0; i < (n); i++) #define tr(c,it) for(__typeof(c.begin()) it = c.begin(); it != c.end(); ++it) #define all(c) c.begin(),c.end() #define inf (int)1e9 #define pb push_back #define mp make_pair #define fill(arr,val) memset(arr,val,sizeof(arr)) #define gi(n) scanf("%d",&n) #define gl(n) scanf("%lld",&n);  typedef long long ll; typedef unsigned long long ull; typedef vector<int> vi; typedef pair<int,int> pii;  #define mod 1000000007 #define M 110 int dim;  ll unit[M][M]; ll mat[M][M];  void print(ll a[][M]) {   for(int i=0;i<dim;++i) {     for(int j=0;j<dim;++j) printf("[%lld] ",a[i][j]);     puts("");   }   puts(""); }   void copy(ll a[][M],ll b[][M]) {   for(int i=0;i<dim;i++) {     for(int j=0;j<dim;j++) {       a[i][j] = b[i][j];     }   } }  void mul(ll a[][M], ll b[][M]) {   ll c[M][M];   for(int i=0;i<dim;i++) {     for(int j=0;j<dim;j++) {       c[i][j] = 0;       for(int k=0;k<dim;k++) {         c[i][j] = (c[i][j] + (a[i][k] * b[k][j]) % mod + 2 * mod) % mod;   while(c[i][j] < 0) c[i][j] += mod;       }     }   }   copy(a,c); }  void power(ll ab[][M],ll n,ll b[][M]) {   copy(b,unit);   ll a[M][M];   copy(a,ab);   while(n) {     if(n & 1) mul(b,a);     mul(a,a);     n >>= 1;   } }  int main() {   //freopen("in.txt","r",stdin);   for(int i=0;i<M;i++) {     for(int j=0;j<M;j++) {       if(i == j) unit[i][j] = 1;       else unit[i][j] = 0;     }   }   int tt;   gi(tt);   ll f[M];   ll sigma[M];   while(tt--) {     int m,n;     gi(m); gi(n); //cerr << n << " " << m << endl;     dim = m;     rep(i,m) scanf("%lld",f+i);     rep(i,m) f[i] = (f[i] + mod) % mod;     rep(i,m) scanf("%lld",sigma+i);     for(int j=0;j<m;j++) mat[0][j] = sigma[m-1-j];     for(int i=1;i<m;i++) {       for(int j=0;j<m;j++) {         if(i == j+1) mat[i][j] = 1;         else mat[i][j] = 0;       }     }     if(n < m) {       printf("%lld\n",f[n] % mod);       continue;     }     ll b[M][M];     power(mat,n-m+1,b);     //print(unit); print(mat); print(b);     ll ans = 0;     for(int i=0;i<m;i++) {       ans = (ans + (b[0][i] * f[m-1-i]) % mod + 2 * mod) % mod;       while(ans < 0) ans += mod;     }     ans %= mod;     printf("%lld\n",ans);   }   return 0; } 
#include<iostream> #include<cstdio> #include<algorithm> #include<queue> using namespace std; long long int n,m,i,j,q,r,t,k,a,b,sum; long long int xx; long long int deg[501]; int main() { 	cin>>t; 	for(k=0;k<t;k++) 	{ 		cin>>n; 		for(i=0;i<n;i++) 		{ 			deg[i] = 0; 		} 		cin>>m; 		for(i=0;i<m;i++) 		{ 			cin>>a>>b; 			deg[a-1]++; 			deg[b-1]++; 		} 		sort(deg,deg+n,std::greater<int>()); 		for(i=0;i<n;i++) 		{ 			if(deg[i] <  i) 				break; 		} 		sum = 0; 		for(j=0;j<i;j++) 		{ 			sum+=deg[j]; 		} 		for(j=i;j<n;j++) 		{ 			sum-=deg[j]; 		} 		sum-=(i)*(i-1); 		cout<<((sum==0)?"YES":"NO")<<endl; 	} 	return 0; } 				
#include <bits/stdc++.h>   using namespace std;   #define rept(i,a,b) for(int (i) = (a); i < (b); i++) #define rep(i,n) for(int (i) = 0; i < (n); i++) #define tr(c,it) for(__typeof(c.begin()) it = c.begin(); it != c.end(); ++it) #define all(c) c.begin(),c.end() #define inf (int)1e9 #define pb push_back #define mp make_pair #define fill(arr,val) memset(arr,val,sizeof(arr)) #define gi(n) scanf("%d",&n) #define gl(n) scanf("%lld",&n);   typedef long long ll; typedef unsigned long long ull; typedef vector<int> vi; typedef pair<int,int> pii;   int main() {   int tt;   gi(tt);   for(int qq = 1; qq <= tt; qq++) {     ll n,k;     priority_queue<ll,vector<ll>, greater<ll> > Q;     scanf("%lld %lld",&n,&k);     rep(i,n) {       ll x;       scanf("%lld",&x);       Q.push(x);     }     ll mod = (k - 2) - (n - 2) % (k - 1);     rep(i,mod) Q.push(0LL);     ll sum = 0;     while(Q.size() > 1) {       ll cnt = 0;       rep(i,k) { 	cnt += Q.top(); Q.pop();       }       // printf("cnt = %lld\n",cnt);       sum += cnt;       Q.push(cnt);     }     printf("Case %d: %lld\n",qq,sum);   }   return 0; } 
#include <bits/stdc++.h>   using namespace std;   #define rept(i,a,b) for(int (i) = (a); i < (b); i++) #define rep(i,n) for(int (i) = 0; i < (n); i++) #define tr(c,it) for(__typeof(c.begin()) it = c.begin(); it != c.end(); ++it) #define all(c) c.begin(),c.end() #define inf (int)1e9 #define pb push_back #define mp make_pair #define fill(arr,val) memset(arr,val,sizeof(arr)) #define gi(n) scanf("%d",&n) #define gl(n) scanf("%lld",&n);   typedef long long ll; typedef unsigned long long ull; typedef vector<int> vi; typedef pair<int,int> pii;   #define eps 1e-5   int main() {   int tt;   gi(tt);   int arr[111];   for(int qq = 1; qq <= tt; ++qq) {     printf("Case %d:\n",qq);     int n,m;     gi(n); gi(m);     rep(i,n) {       double x;       scanf("%lf",&x);       arr[i] = (int)(x * 100.0 + eps);     }     sort(arr,arr+n);     reverse(arr,arr+n);     //cout << "inp \n"; rep(i,n) cout << arr[i] << "\n";     int cnt = 0;     for(int mm = 1; mm <= m; mm++) {       printf("Scenario %d:\n",mm);       double x;       scanf("%lf",&x);       int val = (int)(x * 100.0 + eps);       for(int i = 0; i < n; i++) { 	if(val >= arr[i]) { 	  int cnt = val/arr[i]; 	  if(arr[i] % 100) printf("%.2lf ",arr[i]/100.0); 	  else printf("%d ",arr[i]/100); 	  printf("%d\n",cnt); 	  val -= arr[i] * cnt; 	}       }     }   }   return 0; }  
#include <iostream> #include <cstring>  #include <algorithm>  using namespace std; typedef long long L;  L M[51][51]; L N[51][51]; L F[51][51][51];  L m(L n, L p){ 	if(n == 1)return 1ll; 	if(p == 3)return (1ll<<n) - 1ll;  	if(M[n][p] != 0ll)return M[n][p];  	M[n][p] = 0;   	N[n][p] = -1ll;  	L temp;  	for(L i=1;i<n;i++){ 		temp = 2*m(i,p)+m(n-i,p-1);  		if(M[n][p] > temp || M[n][p] == 0) { 			M[n][p] = temp;  			N[n][p] = i;  		} 	} 	return M[n][p];   }   L f(L n, L p, L k){ 	m(n,p);  	L n1; 	if(p > 3)n1 = N[n][p];  	else n1 = n-1;  	if(F[n][p][k] != 0ll) return F[n][p][k];  	 	if(p == 3 && k == n){ 		return m(n-1, p) + 1ll; 	}  	if(n1 >= k){ 		return F[n][p][k] = m(n1,p) + m(n-n1,p-1) + f(n1,p,k);  	} 	return F[n][p][k] = m(n1,p) + f(n-n1,p-1,k - n1);  } int main() { 	L t, n, p, k;  	cin >> t;  	for(L cs=1;cs<=t;cs++){ 		cin >> n >> p >> k;  		cout << "Case " <<cs << ": " << f(n,p,k) << endl;  	}	 }
#include <bits/stdc++.h> using namespace std; #define gi(x) scanf("%d",&x)  #define pb push_back #define mp make_pair #define all(p) p.begin(),p.end() int dp[451][451][451]; int main(){ 	int t, alen, blen, clen; 	string a,b,c; 	gi(t); 	while(t-->0){ 		cin>>a; 		cin>>b; 		cin>>c; 		alen=a.length(); 		blen=a.length(); 		clen=a.length(); 		memset(dp,0,sizeof dp); 		for(int i=1;i<=alen;i++){ 			for(int j=1;j<=blen;j++){ 				for(int k=1;k<=clen;k++){ 					if(a[i-1]==b[j-1] && b[j-1]==c[k-1]){ 						dp[i][j][k]=1+dp[i-1][j-1][k-1]; 					} 					else{ 						dp[i][j][k]=max(max(dp[i-1][j][k],dp[i][j-1][k]),dp[i][j][k-1]); 					} 				} 			} 		} 		printf("%d\n",alen+blen+clen-3*(dp[alen][blen][clen])); 	} }
#include <vector> #include <queue> #include <map> #include <set> #include <utility> //Pair #include <algorithm> #include <sstream> // istringstream>> ostring stream<< #include <iostream> #include <iomanip> //setbase - cout << setbase (16); cout << 100 << endl; Prints 64 //setfill - cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77 //setprecision - cout << setprecision (4) << f << endl; Prints x.xxxx #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <limits> using namespace std;   //M lazy ;) typedef long long ll; typedef vector <int> vi; typedef pair< int ,int > pii; typedef istringstream iss; typedef ostringstream oss; #define pb push_back #define mp make_pair #define ff first #define ss second #define sz size() #define ln length() #define rep(i,n) for(int i=0;i<n;i++) #define fu(i,a,n) for(int i=a;i<=n;i++) #define fd(i,n,a) for(int i=n;i>=a;i--) #define all(a) a.begin(),a.end() #define ESP (1e-9)   #define gi(n) scanf("%d",&n) #define gl(n) cin >> n #define pi(n) printf("%d",n) #define pl(n) cout << n #define ps printf(" ") #define pn printf("\n") #define dg(n,s); printf("%s %d",s,n) #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min() #define mod 1000000007  int main(){  	ll t; 	cin >> t; 	//long long int modulo = 1000000007; 	ll n; 	while(t--){ 		cin >> n; 		ll part1 = (n*(n-1) /2 )%mod; 		ll part2 = (((n*(n-1))%mod)*((n-2)*(n-3)%mod))%mod; 		ll part3 = (part2 * 41666667LL)%mod; 		ll part4 = (part1 + part3 + 1LL)%mod; 		cout << part4 << endl; 			//ll ans= ((((n%modulo) * ((n-1)%modulo)%modulo) * 500000004)%modulo)%modulo + (((n%modulo)*((n-2)%modulo)%modulo)*(((((n-1)%modulo)*((n-3)%modulo))%modulo)* 41666667)%modulo)%modulo + 1;	 		//cout << ans << endl;   	}   	return 0; }
#include <bits/stdc++.h> using namespace std; #define gi(x) scanf("%d",&x)  #define pb push_back #define mp make_pair #define all(p) p.begin(),p.end() int main(){ 	int t,n,x,y,m,p; 	gi(t); 	while(t-->0){ 		gi(n); 		vector< vector<int> > graph(n+1); 		for(int i=0;i<n-1;i++){ 			gi(x);gi(y); 			graph[x].pb(y); 			graph[y].pb(x); 		} 		int marked[n+1]; 		int parent[n+1]; 		memset(marked,0,sizeof(marked)); 		memset(parent,-1,sizeof(parent)); 		queue<int> q; 		q.push(1); 		while(!q.empty()){ 			int pr=q.front(); 			q.pop(); 			for(int i=0;i<graph[pr].size();i++){ 				int ne=graph[pr][i]; 				if(marked[ne]==0){ 					marked[ne]=1; 					parent[ne]=pr; 					q.push(ne); 				} 			} 		} 		int present_ans=n; 		memset(marked,0,sizeof(marked)); 		gi(m); 		while(m--){ 			gi(p); 			int pr=p; 			while(pr!=-1 && marked[pr]==0){ 				marked[pr]=1; 				present_ans--; 				pr=parent[pr]; 			} 			printf("%d\n",present_ans); 		}  	} }
#include <bits/stdc++.h>   using namespace std;   typedef long long ll; typedef pair <int,int> pii; typedef vector <int> vi;   #define rep(i, n) for(int i = 0; i < (n); ++i)   #define pb push_back #define mp make_pair #define ff first #define ss second #define all(c) c.begin(), c.end() #define mset(a, v) memset(a, v, sizeof(a)) #define sz(a) ((int)a.size())   #define gi(x) scanf("%d", &x) #define pis(x) printf("%d ", x) #define pin(x) printf("%d\n", x) #define pnl printf("\n") #define dbn cerr << "\n" #define dbg(x) cerr << #x << " : " << (x) << " " #define dbs(x) cerr << (x) << " "   const int maxN = 101; const int maxM = 101;    const int inf = 0x3f3f3f3f;   struct Edge {   int u,v,flow,capacity;   Edge()   {    }   Edge(int u,int v,int flow,int capacity)   {     this->u=u;     this->v=v;     this->flow=flow;     this->capacity=capacity;    } };    vector<Edge> e; vector<vector<int> > G; int n,m; int source,sink; int dist[5001]; int ptr[5001];   bool findPath() {    memset(dist,-1,sizeof(dist));   dist[source]=0;   queue<int> Q;   Q.push(source);   while(!Q.empty())   {          int u=Q.front();     assert(dist[u]>=0);     // cout<<u<<endl;     Q.pop();      for (int i = 0; i < G[u].size(); ++i)         {       int ID=G[u][i];       // assert(u==e[ID].u);       int v=e[ID].v;        if( (dist[v]==-1) && e[ID].flow<e[ID].capacity)       {         // cout<<v<<endl;         dist[v]=dist[u]+1;         // cout<<dist[v]<<endl;         Q.push(v);         // if(v==sink)         //   return true;       }     }   }    return dist[sink]!=-1; }   int dfs(int u,int flow) {    if(flow==0)     return 0;   if(u==sink)     return flow;   for(;ptr[u]<G[u].size();++ptr[u])   {     int ID=G[u][ptr[u]];     int v=e[ID].v;          if(dist[v]!=dist[u]+1)       continue;          int pushed=dfs(v,min(flow,e[ID].capacity-e[ID].flow));     if(pushed)     {       e[ID].flow    +=pushed;       e[ID^1].flow  -=pushed;       return pushed;     }   }   return 0; } ll dinics() {   ll flow=0;   while(findPath())   {     memset(ptr,0,sizeof ptr);     while(int pushed=dfs(source,1e9))       flow+=pushed;   }   return flow; } void addEdge(int u,int v,int capacity) {     G[u].push_back(e.size());     e.push_back(Edge(u,v,0,capacity));     G[v].push_back(e.size());     e.push_back(Edge(v,u,0,0)); }   int main() {               int T;     gi(T);     int st[maxN], en[maxN];     int b[maxM], e[maxM], req[maxM];       rep (tc, T) {         int n, m;         gi(n), gi(m);           vi v;           rep (i, n) {             gi(st[i]), gi(en[i]);             v.pb(st[i]);             v.pb(en[i]);         }           rep (i, m) {             gi(b[i]), gi(e[i]), gi(req[i]);             v.pb(b[i]);             v.pb(e[i]);         }           sort(all(v));         v.resize(unique(all(v)) - v.begin());             int nodes = 2 + n + m + sz(v) - 1;         ::e.clear();         G.clear();         G.resize(nodes);               source = 0;         sink = nodes - 1;              rep (i, n) {             addEdge(source, i + 1, inf);               rep (j, sz(v) - 1) {                 if (v[j] >= st[i] and v[j + 1] <= en[i]) {                     addEdge(i + 1, n + 1 + j, (v[j + 1] - v[j]));                 }             }         }           rep (i, m) {             addEdge(n + 1 + sz(v) - 1 + i, sink, req[i]);               rep (j, sz(v) - 1) {                 if (v[j] >= b[i] and v[j + 1] <= e[i]) {                     addEdge(n + 1 + j, n + 1 + sz(v) - 1 + i, (v[j + 1] - v[j]));                 }             }         }           int flow = dinics();           int required = 0;         rep (i, m) required += req[i];           puts(flow == required ? "YES" : "NO");     }       return 0; } 
#include <iostream> #include <sstream> #include <fstream> #include <string> #include <vector> #include <deque> #include <queue> #include <stack> #include <set> #include <cstring> #include <list> #include <map> #include <algorithm> #include <functional> #include <utility> #include <bitset> #include <cmath> #include <cstdlib> #include <ctime> #include <cstdio> using namespace std; typedef long long          ll; typedef long double        ld; typedef pair<int,int>      pii; typedef pair<ll,ll>        pll; typedef vector<int>        vi; typedef vector<long long>  vll; #define mp                 make_pair #define pb                 push_back #define all(a)             a.begin(),a.end() #define sor(a)             sort(all(a)); #define rsor(a)            sor(a) reverse(all(a)); #define pr(n)              printf("%d ",n) #define s(n)               scanf("%d",&n) #define debug(a)           std::cerr<<#a<<"="<<(a)<<"\n" #define ss                 second #define ff                 first #define m0(x) 		   memset(x,0,sizeof(x)) #define snuke(c,itr)       for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++) const int mod=1e9+7; const long double PI = (long double)(3.1415926535897932384626433832795);  inline bool ispow2(int x){return (x!=0 && (x&(x-1))==0);} //0 or 1  template<class T> inline void cinarr(T a, int n){ for (int i=0;i<n;++i) cin >> a[i];}  inline ll powmod(ll a,ll b) {ll res = 1; while(b){if(b&1) res = (res*a)%mod;a = (a*a)%mod;b >>= 1;}return res;}  int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; } int fastMin(int x, int y) { return (((y-x)>>(32-1))&(x^y))^x; }  inline ll gcd(ll a,ll b){ll t;while(b){a=a%b;t=a;a=b;b=t;}return a;} inline ll lcm(ll a,ll b){return a/gcd(a,b)*b;}  const int mx =1005; ll dp[mx+1][mx+1]; int main() {     ios_base::sync_with_stdio(false); cin.tie(0);      for(int i=1;i<mx;i++)     {         for(int j=0;j<=i;j++)         {             if(j==0)             {                 dp[i][j] = 0;             }             else if(j==i)             {                 dp[i][j] =  1;             }             else             {                 dp[i][j] = (dp[i-1][j-1] + (i-1) * dp[i-1][j]) % mod;             }          }     }     int t; cin>>t;     while(t--)     {         int n,k; cin>>n>>k;         cout<< dp[n][k] % mod <<"\n";     }     return 0; }  
#include <bits/stdc++.h> using namespace std;  char a[1001],b[65],c[65];  int main() { 	int t,i,n,carry,l,temp; 	long long int k; 	cin>>t; 	while(t--) 	{ 		cin>>a; 		cin>>k; 		n=strlen(a); 		i=0; 		while(i<n) 		{	a[i]=a[i]-'0'; 			i++; 		} 		i=0; 		while(k!=0) 		{	b[i] = k % 2; 			k = k/2; 			i++; 		} 		b[i]='\0'; 		l=0; 		while(l<i) 		{ 			c[l]=b[i-l-1]; 			l++; 		} 		c[l]='\0'; 		n--; 		i--; 		carry=0; 		if(n>i) 		{ 			l=n+1; 			while(i>=0) 			{	temp=(a[n]+c[i]+carry)%2; 				carry=(a[n]+c[i]+carry)/2; 				a[n]=temp; 				n--; 				i--; 			} 			while(n>=0 && carry==1) 			{ 				temp=(a[n] + carry)%2; 				carry=(a[n]+carry)/2; 				a[n]=temp; 				n--; 			} 			i=0; 			while(i<l) 			{ 				a[i]=a[i]+'0'; 				i++; 			} 			if(n<0 && carry == 1) 				cout<<"1"<<a<<endl; 			else 				cout<<a<<endl; 		} 		else 		{ 			l=i+1; 			while(n>=0) 			{	temp=(a[n]+c[i]+carry)%2; 				carry=(a[n]+c[i]+carry)/2; 				c[i]=temp; 				n--; 				i--; 			} 			while(i>=0 && carry==1) 			{ 				temp=(c[i] + carry)%2; 				carry=(c[i]+carry)/2; 				c[i]=temp; 				i--; 			} 			if(i<0 && carry==1) 				cout<<"1"; 			i=0; 			while(i<l) 			{ 				c[i]=c[i]+'0'; 				i++; 			} 			cout<<c<<endl; 		} 	} 	return 0; }
#include <bits/stdc++.h> using namespace std;  #define LL long long  const LL MOD  = 1e9 + 7; LL power(LL a, LL b, LL c) { 	LL ret=1;  	while(b) { 		if(b&1) { 			ret = (ret*a)%c; 		} 		a = (a*a)%c; 		b >>= 1; 	} 	return ret; }  int main() { 	int t; 	scanf("%d", &t); 	while(t--) { 		LL n, k; 		scanf("%lld %lld", &n, &k);  		if(k == 1) { 			printf("0\n"); 		} 		else if(k==2) { 			printf("2\n"); 		} 		else{ 			long long val = (k-1 + (k-2)*(k-2)) % MOD; 			val = power(val, n-1, MOD); 			val = (((val*k)%MOD)*(k-1))%MOD; 			printf("%lld\n", val); 		}    	} }
#include <iostream> using namespace std;  int main() {int t,i,j,flag,flag1; cin>>t; while(t--) {string s,s1; flag=0;flag1=1; cin>>s>>s1; j=0; for(i=0;i<s1.length();i++) {if(flag==0)     {if(s[j]==s1[i])         j++;         else         {flag=1;             j++;             i--;         }              }     else     {if(s[j]==s1[i])         j++;         else         {flag1=0;         break;}              }      }      if(flag1==0)     cout<<"0"<<"\n";     else     cout<<"1"<<"\n"; } 	// your code goes here 	return 0; } 
#include <bits/stdc++.h>  typedef long long ll; using namespace std; #define NMAX 2751001 /* set<int> A[NMAX];  void Union(set<int> &A,set<int> B) {     for(typeof(B.begin()) it=B.begin();it!=B.end();it++)     {         A.insert(*it);     } }  set<int> Add(set<int> A,set<int> B) {     set<int> C;     for(typeof(A.begin()) it1=A.begin();it1!=A.end();it1++)     {         for(typeof(B.begin()) it2=B.begin();it2!=B.end();it2++)         {             C.insert( (*it1)+(*it2) );         }     }     return C; }  set<int> Mul(set<int> A,int B) {     set<int> C;     for(typeof(A.begin()) it1=A.begin();it1!=A.end();it1++)     {         C.insert( (*it1)*B );     }     return C; } */  ll ModPow(ll a,ll x,ll p) {     ll res=1;     while(x>0)     {         if(x%2!=0)             res=(res*a)%p;         a=(a*a)%p;         x/=2;     }     return (res%p); }     bool p[NMAX]; vector<int> P; int main() {     ios_base::sync_with_stdio(false);     cin.tie(NULL);     int i,j,q,k;     fill(p,p+NMAX,true);     p[0]=p[1]=false;     for(i=2;i*i<NMAX;i++)     {         if(p[i])         {             for(j=i*i;j<NMAX;j+=i)             {                 p[j]=false;             }         }     }     for(i=2;i<NMAX;i++)     {         if(p[i])             P.push_back(i);     }     cin>>q;     while(q--)     {         cin>>k;         --k;         cout<<ModPow(P[k],P[k],1000000007)<<'\n';     }     P.clear();     /*A[1].insert(0);     for(i=2;i<NMAX;i++)     {         if(p[i])         {             A[i].insert(1);         }         else         {             for(j=2;j*j<=i;j++)             {                 if(i%j==0)                 {                     Union(A[i],Add( Mul(A[j],i/j),Mul(A[i/j],j) ) );                 }             }         }         if((int)A[i].size()==1)         {             if(*A[i].begin()==i)             {                 cout<<i<<' ';             }         }     }*/          return 0; }
#include<iostream> using namespace std; int main() {     int t,n,k,i,r;     cin>>t;     while(t--)     {               cin>>n>>k;               long long int r=1;               if(n-k<k)k=n-k;               for(i=0;i<k;)               {                            r=r*n--;                            r=r/++i;               }               cout<<r<<"\n";     } }                                                                                        
#include<iostream> using namespace std;  int main() {     int n,t,i,j,k,cvalue,rvalue,sum;     int **solution;     cin>>t;     solution=new int *[t];     for(i=0;i<t;i++)     {         cin>>n;         int **matrix;         matrix=new int *[n];         for(j=0;j<n;j++)         {             matrix[j]=new int[n];             for(k=0;k<n;k++)                 cin>>matrix[j][k];         }         rvalue=-2;         for(j=0;j<n;j++)         {             sum=0;             for(k=0;k<n;k++)                 sum+=matrix[j][k];             if(sum%2!=0)             {                 if(rvalue!=-2)                     rvalue=-1;                 else                     rvalue=j;              }          }         cvalue=-2;         for(j=0;j<n;j++)         {             sum=0;             for(k=0;k<n;k++)                 sum+=matrix[k][j];             if(sum%2!=0)             {                 if(cvalue!=-2)                     cvalue=-1;                 else                     cvalue=j;              }          }         if(rvalue==-1 || cvalue==-1)         {             solution[i]=new int[2];             solution[i][0]=1;             solution[i][1]=0;         }         else if(rvalue==-2 && cvalue==-2)         {             solution[i]=new int[2];             solution[i][0]=1;             solution[i][1]=1;         }         else if(rvalue==-2 || cvalue==-2)         {             solution[i]=new int[2];             solution[i][0]=1;             solution[i][1]=0;         }         else         {             solution[i]=new int[3];             solution[i][0]=2;             solution[i][1]=rvalue+1;             solution[i][2]=cvalue+1;         }      }      for(i=0;i<t;i++)     {         if(solution[i][0]==2)         {             cout<<"("<<solution[i][1]<<","<<solution[i][2]<<")";         }         else             cout<<solution[i][1];         cout<<"\n";     }     return 0;   } 
#include<stdio.h>  void sort(int *ar,int *ab) {  int i=ab-ar;  for(int j=0;j<i;j++)  for(int k=0;k<i-1;k++)  {   if(ar[k]>ar[k+1])   {    int temp;    temp=ar[k];    ar[k]=ar[k+1];    ar[k+1]=temp;    }  }  } int main() {  //clrscr();  int test;  scanf("%d",&test);  for(int j=0;j<test;j++)  {  int num;  scanf("%d",&num);  if(num==1)  {  printf("%d\n",num);  continue;  }  if(num<10)  {  printf("%d\n",num+10);  continue;}  int ar[20];  int ind=0;  int has=0;  while(num>1){  has=0;  int b[4]={2,3,5,7};  for(int ij=0;ij<4;ij++)  { int i=b[ij];   if(num%i==0)  { ar[ind++]=i;   num=num/i;   has=1;   }   if(num==1)   break;  }  if(has==0)  {   printf("%d\n",-10);   break;  }  }  if(has==0)  {   has=1;   continue;  }  int flag;  aa:  flag=0;  sort(ar,ar+ind); // getch(); if(ind>2)  for(int k=ind-1;k>0;k--)  {   if(ar[k]*ar[k-1]/10==0)   {   flag=1;   ar[k-1]=ar[k]*ar[k-1];   ar[k]=ar[ind-1];   ind--;   }  }  if(flag)  goto aa;   for(int y=0;y<ind;y++)  {  printf("%d",ar[y]);  }  printf("\n");  } // getch(); return 0; }
#include<iostream> #include<cstring>  using namespace std;  int main(void) { 	int i=-1,j,k,m,n,c; 	struct str 	{ char s[100]; 	  int len,mir,pal; 	}count; 	while(1) 	{ 	   cin>>count.s; 	   c=strcmp(count.s,"#"); 	   if(c==0) 		break; 	   else 	   { 		++i; 		count.len=strlen(count.s); 		count.pal=1; 		count.mir=1; 		if((count.len)%2==0) 		{ m=(count.len)/2; 		  n=m-1; 		} 		else 		{ m=((count.len)/2)-1; 		  n=m+2; 		} 		for(j=m,k=n;j>=0;j--,k++) 		{ if((count.s[j]=='A')&&(count.s[k]=='A')) 		  {}  		  else if((count.s[j]=='E')&&(count.s[k]=='3')) 		  {count.pal=0;} 		  else if((count.s[j]=='H')&&(count.s[k]=='H')) 		  {} 		  else if((count.s[j]=='I')&&(count.s[k]=='I')) 		  {} 		  else if((count.s[j]=='J')&&(count.s[k]=='L')) 		  {count.pal=0;} 		  else if((count.s[j]=='L')&&(count.s[k]=='J')) 		  { count.pal=0;} 		  else if((count.s[j]=='M')&&(count.s[k]=='M')) 		  {} 		  else if((count.s[j]=='O')&&(count.s[k]=='O')) 		  {} 		  else if((count.s[j]=='S')&&(count.s[k]=='2')) 		  {count.pal=0;} 		  else if((count.s[j]=='T')&&(count.s[k]=='T')) 		  {} 		  else if((count.s[j]=='U')&&(count.s[k]=='U')) 		  {} 		  else if((count.s[j]=='V')&&(count.s[k]=='V')) 		  {} 		  else if((count.s[j]=='W')&&(count.s[k]=='W')) 		  {} 		  else if((count.s[j]=='X')&&(count.s[k]=='X')) 		  {} 		  else if((count.s[j]=='Y')&&(count.s[k]=='Y')) 		  {} 		  else if((count.s[j]=='Z')&&(count.s[k]=='5')) 		  {count.pal=0;} 		  else if((count.s[j]=='1')&&(count.s[k]=='1')) 		  {} 	 	  else if((count.s[j]=='2')&&(count.s[k]=='S')) 	 	  {count.pal=0;} 		  else if((count.s[j]=='3')&&(count.s[k]=='E')) 		  {count.pal=0;} 		  else if((count.s[j]=='5')&&(count.s[k]=='Z')) 		  {count.pal=0;} 		  else if((count.s[j]=='8')&&(count.s[k]=='8')) 	 	  {} 		  else 		  {count.mir=0; 		   break; 		  } 		} 		if(count.pal!=0) 		{ for(j=m,k=n;j>=0;j--,k++) 		  { if(count.s[j]!=count.s[k]) 		    { count.pal=0; 		      break; 		    } 		  } 		} 		if((count.pal!=0)&&(count.mir!=0)) 			cout<<"mirroredpalindrome\n"; 		else if((count.pal!=0)&&(count.mir==0)) 			cout<<"regularpalindrome\n"; 		else if((count.pal==0)&&(count.mir!=0)) 			cout<<"mirroredstring\n"; 		else 			cout<<"notpalindrome\n"; 		} 	} return 0; }  
#include <cstdio> #include <cstring> #include <cassert>  using namespace std;  int dict[1001][26];  int main() { 	int dictSize = 0; 	 	char s[10]; 	while(true) 	{ 		scanf("%s", s); 		if (s[0] == '#') 			break; 		 		for (int i = 0; i < 26; ++i) 			dict[dictSize][i] = 0; 		 		int len = strlen(s); 		for (int i = 0; i < len; ++i) 			++dict[dictSize][s[i] - 'a']; 		++dictSize; 	} 	char tmp; 	scanf("%c", &tmp); // ignore \n 	assert(tmp == '\r'); 	 	bool exit = false; 	while(!exit) 	{ 		int available[26]; 		for (int i = 0; i < 26; ++i) 			available[i] = 0; 		while(true) 		{ 			char c; 			scanf("%c", &c); 			if (c == '#') 			{ 				exit = true; 				break; 			} 			else if (c == ' ') 				continue; 			else if (c == '\r') 				break; 			else 				++available[c - 'a']; 		} 		 		if (exit) 			break; 		 		int count = 0; 		for (int i = 0; i < dictSize; ++i) 		{ 			bool possible = true; 			for (int j = 0; j < 26; ++j) 			{ 				if (dict[i][j] > available[j]) 				{ 					possible = false; 					break; 				} 			} 			if (possible) 				++count; 		} 		 		printf("%d\n", count); 	} 	 	return 0; }
// Templar Test // http://www.codechef.com/problems/KC205/  #include <iostream> #include <cstdio> #include <cstring> #include <algorithm> #include <vector> #include <cmath>  using namespace std;  int main() { 	 int t; 	 scanf("%d",&t); 	 while(t--) 	 { 				  int n, m; 				  scanf("%d%d",&m,&n); 				  int c; 				  if(m % 2 != 0 && n % 2 != 0) 						 c = (n * m + 1) / 2; 				  else 						 c = n * m / 2;  					if(m == 2) 					{ 						  c = n / 4 * 4 + 2 * (n % 4); 						  if(n % 4 == 3)c -= 2; 	 	  			} 	 	  			 	 	  			if(n == 2) 	 	  			{ 						  c = m / 4 * 4 + 2 * (m % 4); 						  if(m % 4 == 3)c -= 2; 	 	  	  		} 	 	  	  		if(n == 1)c = m; 	 	  	  		if(m == 1)c = n; 	 	  	  		printf("%d\n", c);   	 } 	 	 return 0; } 
 // (c) agaurav77 #include <iostream> #include <map>          // find(), clear() #include <vector>       // push_back(), pop_back(), front(), back() #include <list>         // push_back(), pop_back(), front(), back() --- SEQUENTIAL ACCESS #include <queue>        // push(), pop(), front(), back() #include <utility>      // make_pair() #include <algorithm>    // sort() #include <cmath> #include <cstdio> #include <climits>      // inf, minf #include <cstdlib>      // malloc() #include <sstream> #include <string> #include <cstring>      // memset() #define mp make_pair #define pb push_back using namespace std;  #define inf INT_MAX #define minf INT_MIN #define t(N) scanf("%d", &N); #define f(i,a,b) for(int i=a;i <= b; ++i) #define str string #define ll long long  #define inMap(a,b) (a.find(b) != a.end()) #define lastOne(i) (i&(-i)) #define MAX 100005  int B2a[MAX], B2b[MAX],  B5a[MAX], B5b[MAX]; int N;  // create an update function void update(int *BIT, int i, int val) {   while (i < N+5) {     BIT[i] += val;     i = i+lastOne(i);   } }  // create a cumulative query function int query(int *BIT, int i) {   int sum = 0;   while (i > 0) {     sum += BIT[i];     i = i-lastOne(i);   }   return sum; }  // create a function to update over range void updateRange(int *BIT, int *off, int L, int R, int val) {   update(BIT, L, val);   update(BIT, R+1, -val);   update(off, L, val*(L-1));   update(off, R+1, -val*R); }  int bitquery(int *BIT, int *off, int i) {   return i*query(BIT, i)-query(off, i); }  int main() {   // take in the test cases   int T;   t(T);    while (T--) {     // take in N, Q     int Q;     t(N); t(Q);      // empty BIT     memset(B2a, 0, sizeof(int)*(N+5));     memset(B2b, 0, sizeof(int)*(N+5));     memset(B5a, 0, sizeof(int)*(N+5));     memset(B5b, 0, sizeof(int)*(N+5));      // insert into BIT     int tmp;     f(i, 1, N) {       t(tmp);       int pow2 = 0, pow5 = 0;       while (tmp > 0 && tmp%2 == 0) {tmp /= 2; pow2++;}       while (tmp > 0 && tmp%5 == 0) {tmp /= 5; pow5++;}       updateRange(B2a, B2b, i, i, pow2);       updateRange(B5a, B5b, i, i, pow5);     }      // handle queries     int num, L, R, val;     f(i, 0, Q-1) {       // sanity check       // print number of 2s and 5s for each index       //f(j, 1, N) {       //  cout << j << " -> " << bitquery(B2a, B2b, j)-bitquery(B2a, B2b, j-1)       //            << "    " << bitquery(B5a, B5b, j)-bitquery(B5a, B5b, j-1) << endl;       //}            t(num);       if (num == 1) {         t(L); t(R);         // find number of trailing zeroes in L,R         // find powers of 2, 5 and take min         printf("%d\n", min( bitquery(B2a,B2b,R)-bitquery(B2a,B2b,L-1),                           bitquery(B5a,B5b,R)-bitquery(B5a,B5b,L-1) ));       } else {         t(L); t(R); t(val);         int pow2 = 0, pow5 = 0;         while (val > 0 && val%2 == 0) {val /= 2; pow2++;}         while (val > 0 && val%5 == 0) {val /= 5; pow5++;}         updateRange(B2a, B2b, L, R, pow2);         updateRange(B5a, B5b, L, R, pow5);       }     }   }   return 0; }  
#include<bits/stdc++.h> using namespace std; int main() {    int t,i,n;    scanf("%d",&t);    while(t--)    {        int sum=0,v;        scanf("%d",&n);        int a[100];        char c[100];       for(i=0;i<26;i++)         scanf("%d",&a[i]);       scanf("%s",c);       int l=strlen(c);       int d[100];       for(i=0;i<l;i++)       {           v=c[i]-97;           d[i]=a[v];       }       sort(d,d+l);       for(i=0;i<l-n;i++)         sum+=d[i];       printf("%d\n",sum);    }    return 0; } 
#include<iostream>   using namespace std;   int main() {     int a[500002],n,i,j,temp,t;     cin>>t;     while(t--)     {     cin>>n;     for(i=0;i<n;++i)         cin>>a[i];         int count=0;              for(i=1;i<n;++i)     {         for(j=0;j<(n-i);++j)             if(a[j]>a[j+1])             {   count++;                 temp=a[j];                 a[j]=a[j+1];                 a[j+1]=temp;             }     }          cout<<count<<endl;     }              return 0; }
#include<bits/stdc++.h> using namespace std; vector<int> G[1000]; int dist[1000]; bool visit[1000]; void dfs(int u,int v,int d) {     visit[u]=true;       //dist[u]=d;       if(u==v)         cout<<d<<endl;       for(int i=0;i<G[u].size();i++)       {             int x=G[u][i];             if(!visit[x])             dfs(x,v,d+1);       } } int main() {     int t;     cin>>t;     while(t--)     {         int n,f;         cin>>n>>f;         string s;         for(int i=0;i<1000;i++)          G[i].clear();         for(int i=0;i<n;i++)         {             cin>>s;             for(int j=0;j<n;j++)             {                 if(s[j]=='1')                 {                     G[i].push_back(j);                 }             }         }         /*         for(int i=0;i<n;i++)         {             for(int j=0;j<G[i].size();j++)             {                 cout<<G[i][j]<<" ";             }             cout<<endl;         }         */        memset(visit,false,sizeof visit);         dfs(0,f,0);        // cout<<dist[f-1]<<endl;     } } 
//KGP13A #include<cstdio> #include<iostream> #include<vector> #include<algorithm>  using namespace std;  vector< vector<int> > path(vector< vector<int> > adjmat) {     int n=static_cast<int>(adjmat[0].size());     vector< vector<int> > dprev(n,vector<int> (n));     copy(adjmat.begin(),adjmat.end(),dprev.begin());     for(int k=1;k<n;k++)     {         vector< vector<int> > dnext(n,vector<int> (n));         for(int i=1;i<n;i++)         {             for(int j=1;j<n;j++)             {                 //dnext[i][j]=min(dprev[i][j],dprev[i][k]+dprev[k][j]);                 if(dprev[i][j]==-1 && (dprev[i][k]==-1 || dprev[k][j]==-1))                 {                     dnext[i][j]=-1;                 }                 else if(dprev[i][j]==-1)                 {                     dnext[i][j]=dprev[i][k]+dprev[k][j];                 }                 else if(dprev[i][k]==-1 || dprev[k][j]==-1)                 {                     dnext[i][j]=dprev[i][j];                 }                 else                 {                     dnext[i][j]=min(dprev[i][j],dprev[i][k]+dprev[k][j]);                 }             }         }         copy(dnext.begin(),dnext.end(),dprev.begin());     }     return dprev; } int main() {     //freopen("KGP13A.txt","r",stdin);     int t;     cin>>t;     int n=t;     while(t--)     {         int k;         cin>>k;         vector<vector<int> > adjmat(k+1,vector<int> (k+1,-1));         vector<int> connected;         for(int i=0;i<=k;i++)         {             adjmat[i][i]=0;         }         for(int i=1;i<=k;i++)         {             int u=i;             int no,isconnected;             cin>>isconnected>>no;             if(isconnected==1)             {                 connected.push_back(i);             }             for(int j=1;j<=no;j++)             {                 int v,weight;                 cin>>v>>weight;                 adjmat[u][v]=weight;             }         }         vector< vector<int> > shortestPathmat;         shortestPathmat=path(adjmat);         /*         for(int i=1;i<=k;i++)         {             for(int j=1;j<=k;j++)             {                 printf("%d ",shortestPathmat[i][j]);             }             printf("\n");         }         */         int connectlen=static_cast<int>(connected.size());         int ans=-1;         for(int i=0;i<connectlen;i++)         {             for(int j=i+1;j<connectlen;j++)             {                 int u=connected[i];                 int v=connected[j];                 int totalans=0;                 for(int x=1;x<=k;x++)                 {                     if(shortestPathmat[u][x]+shortestPathmat[x][v]==shortestPathmat[u][v])                     {                         continue;                     }                     int mini=-1;                     for(int y=1;y<=k;y++)                     {                         if(shortestPathmat[u][y]+shortestPathmat[y][v]==shortestPathmat[u][v])                         {                             if(mini==-1)                             {                                 mini=shortestPathmat[x][y];                             }                             else                             {                                 mini=min(shortestPathmat[x][y],mini);                             }                         }                     }                     totalans+=mini;                 }                 if(ans==-1)                 {                     ans=totalans;                 }                 else                 {                     ans=min(totalans,ans);                 }             }         }         printf("Case %d: %d\n",n-t,ans);     } } 
#include<iostream> #define MAX 40 using namespace std; struct job { 	int s,f,pay; }JOB[MAX],temp; int main() { 	int T,c,i,j,K,M,D,k,result,m1,m2,t; 	cin>>T; 	for(c =1;c<=T;c++) 	{ 		cin>>K>>M; 		m1=m2=0; 		for(i=1;i<=K;i++) 		{ 			cin>>JOB[i].s>>JOB[i].f; 			JOB[i].pay=0; 			if(m1>JOB[i].s || m1==0) 				m1=JOB[i].s; 			if(m2<JOB[i].f) 				m2 = JOB[i].f; 		} 		 		for(i=0;i<M;i++) 		{ 			cin>>D; 			while(D--) 			{ 				cin>>j>>k; 				JOB[j].pay +=k; 			} 		} 		for(i=1;i<=K;i++) 		{ 			j= i-1; 			temp = JOB[i]; 			while(j>=0 && JOB[j].s >= temp.s) 			{ 				JOB[j+1]=JOB[j]; 				j--; 			} 			JOB[j+1]= temp; 		} 		result =0; 		for(i=m1;i<=m2;i++) 		{ 			t = 0; 			for(j=1;j<=K;j++) 			{ 				if(JOB[j].s <=i && JOB[j].f>=i) 					t+=JOB[j].pay; 				else if(JOB[j].s > i) 					break; 			} 			if(t>result) 				result = t; 		} 		cout<<"Case "<<c<<": "<<result<<endl; 	} 	return 0; }
#include <algorithm> #include <vector> #include <cstdio> #include <iostream> #include <cstring> using namespace std; const int MaxK = 201; int br = 0; int dp[MaxK][MaxK], next1[MaxK]; int time1[MaxK], cost[MaxK], prev1[MaxK], k, n, ce, t, tt; int preffix[MaxK][MaxK], sum; bool used[MaxK]; int x[MaxK][MaxK]; int cnt[MaxK], pr, dr, now[MaxK][MaxK];  void prepare(int n, int m) {   int sum = 0; time1[0] = 0;   for (int i=0; i<=cnt[n]; i++)   {     sum += time1[x[n][i]];     int sum1 = 0;      for (int j=0; j<=cnt[m]; j++)     {       sum1 += time1[x[m][j]];       preffix[i][j] = sum + sum1;     }   }    memset(dp, 0, sizeof(dp));   sum = 0;   int tt = 0;    for (int i=1; i<=cnt[n]; i++)   {     tt = preffix[i][0];     dp[i][0] = dp[i-1][0] + tt * cost[x[n][i]];   }    sum = 0;   tt = 0;    for (int j=1; j<=cnt[m]; j++)   {     tt = preffix[0][j];     dp[0][j] = dp[0][j-1] + tt * cost[x[m][j]];   }  //cout << cnt[n] << " " << cnt[m] << endl; /*   for (int i=0; i<=cnt[n]; i++)     for (int j=0; j<=cnt[m]; j++)   {    if (j!=cnt[m]) cout << dp[i][j] <<  " ";    else cout << dp[i][j] << endl;   } */ }  void update(int a, int b, int n, int m) {   cnt[1] = sum;   while (sum > 0)   {     if (((n>0) && (now[n][m] == 1)) || (m == 0))     {       x[1][sum] = x[a][n];       n--;     }     else     {       x[1][sum] = x[b][m];       m--;     }    sum --;   } }  int rek(int a, int b) {    if (dp[a][b] > 0) return dp[a][b];     int sum1 = rek(a-1, b) + preffix[a][b] * cost[x[pr][a]];    int sum2 = rek(a, b-1) + preffix[a][b] * cost[x[dr][b]];     if (sum1 < sum2)    {      dp[a][b] = sum1;      now[a][b] = 1;    }    else    {      dp[a][b] = sum2;      now[a][b] = 2;    }    return dp[a][b]; }  int main() {  scanf("%d", &t);   while (t--)  {   ce ++;   br = 0;   scanf("%d", &k);   memset(x, 0, sizeof(x));   memset(next1, 0, sizeof(next1));   memset(prev1, 0, sizeof(prev1));   memset(cnt, 0, sizeof(cnt));   memset(used, false, sizeof(used));   memset(preffix, 0 ,sizeof(preffix));   int i;    for (i=1; i<=k; i++)     scanf("%d", &time1[i]);   for (i=1; i<=k; i++)     scanf("%d", &cost[i]);   for (i=1; i<=k; i++)   {     next1[i] = i;     prev1[i] = i;   }    scanf("%d", &n);    for (i=1; i<=n; i++)   {     int a, b;     scanf("%d%d", &a, &b);     next1[b] = a;     prev1[a] = b;   }    for (i=1; i<=k; i++)   {    if (!used[i])    {      br ++;      int a = next1[i];      while (a != next1[a]) a = next1[a];       while (1 == 1)      {       x[br][++cnt[br]] = a;       used[a] = true;       if (a == prev1[a]) break;       a = prev1[a];      }    }   }   int k1, k2;   if (br == 1)  {    tt = 0;    sum = 0;    for (i=1; i<=k; i++)    {      tt += time1[x[1][i]];      sum += (tt * cost[x[1][i]]);    }    cout << "Case "<< ce << ": " << sum << endl;    continue;  }   for (i=2; i<=br; i++)  {   pr = 1; dr = i;   k1 = cnt[pr]; k2 = cnt[dr];   prepare(pr, dr);   rek(cnt[pr], cnt[dr]);   sum = cnt[pr] + cnt[dr];   update(pr, dr, cnt[pr],cnt[dr]);  }   cout << "Case " << ce << ": " << dp[k1][k2] << endl;    } } 
#include<iostream> #include<string> #include<algorithm> #include<stdio.h> #include<queue> #include<vector> #include<stack> #include<cstdlib> #include<sstream> #include<cassert> #include<fstream> #include<ctime> #include<list> #include<cmath> #include<set> #include<map> #include<cstring>  using namespace std;  #define s(n)					scanf("%d",&n) #define sl(n) 					scanf("%lld",&n) #define sf(n) 					scanf("%lf",&n) #define ss(n) 					scanf("%s",n) #define INF						(int)1e9 #define LINF					(long long)1e18 #define EPS						1e-9 #define maX(a,b)				((a)>(b)?(a):(b)) #define miN(a,b)				((a)<(b)?(a):(b)) #define abS(x)					((x)<0?-(x):(x)) #define FOR(i,a,b)				for(int i=a;i<=b;i++) #define rep(i,n)				FOR(i,0,n-1) #define foreach(v,c)            for( typeof((c).begin()) v = (c).begin();  v != (c).end(); ++v) #define mp						make_pair #define FF						first #define SS						second #define XX						first #define YY						second.first #define ZZ						second.second #define pb						push_back #define fill(a,v) 				memset(a,v,sizeof(a)) #define all(x)					x.begin(),x.end() #define sz(v)					((int)(v.size())) #define INDEX(arr,ind)			(lower_bound(all(arr),ind)-arr.begin())  typedef long long int lli; typedef pair<int,int> pii; typedef pair<lli,lli> pll; typedef vector<int> vi; typedef vector<lli> vlli; typedef vector<pii> vii;  const int MAXN = 2000015; const int MOD  = 1000000007;  /*Main code begins now */ int k; inline pii ch1(int id) { 	return mp((id)/k,(id)%k); } inline int ch2(pii p) { 	return (p.FF*k+p.SS); } int main() { 	int t,m,x,y,s1; 	#ifndef ONLINE_JUDGE 	freopen("input.txt","r",stdin); 	#endif	 	s(t); 	vi F; 	rep(z,t) 	{ 		F.clear(); 		s(k); 		k++; 		s(s1); 		s(m); 		rep(i,m) 		 { 		 	s(x); 		 	F.pb(x); 		 } 		pii s = ch1(s1); 		x = s.FF,y=s.SS; 		int ans = 0;  		rep(i,sz(F)) 		{ 			s = ch1(F[i]); 			ans+=abS(x-s.FF) + abS(y-s.SS) -1; 		} 		// rep(i,k*k) 		// { 		// 	s = ch1(i); 		// 	cout<<" "<<s.FF<<" "<<s.SS<<endl; 		// } 		// cout<<" ----- \n"; 		// rep(i,k) 		// { 		// 	rep(j,k) 		// 	{ 		// 		cout<<" "<<ch2(mp(i,j)); 		// 	} 		// 	cout<<endl; 		// } 		printf("Case %d: %d\n",z+1,ans); 		rep(i,k) 		{ 			rep(j,k) 			{ 				if(i<k-1) 				{ 					if(j==y) 					{ 						if(i<x) 						{ 							printf("%d %d 1\n",ch2(mp(i,j)),ch2(mp(i+1,j)));	 						} 						else 						{ 							printf("%d %d 0\n",ch2(mp(i,j)),ch2(mp(i+1,j)));		 						} 					} 					else if(j==0 || j==k-1) 					{ 						if(i<x) 						{ 							printf("%d %d 0\n",ch2(mp(i,j)),ch2(mp(i+1,j)));	 						} 						else 						{ 							printf("%d %d 1\n",ch2(mp(i,j)),ch2(mp(i+1,j)));		 						} 					} 					else 					{ 						if(i<x) 						{ 							printf("%d %d 1\n",ch2(mp(i,j)),ch2(mp(i+1,j)));	 						} 						else 						{ 							printf("%d %d 0\n",ch2(mp(i,j)),ch2(mp(i+1,j)));		 						} 					} 				} 				if(j<k-1) 				{ 					if(i==x) 					{ 						if(j<y) 						{ 							printf("%d %d 0\n",ch2(mp(i,j)),ch2(mp(i,j+1)));				 						} 						else 							printf("%d %d 1\n",ch2(mp(i,j)),ch2(mp(i,j+1)));					 					} 					else 					{ 						if(j<y) 						{ 							printf("%d %d 1\n",ch2(mp(i,j)),ch2(mp(i,j+1)));				 						} 						else 						{ 							printf("%d %d 0\n",ch2(mp(i,j)),ch2(mp(i,j+1)));					 						} 					} 				} 				  			} 		} 	} 	return 0; } 
#include<cstdio> #include<cstring> #include<cstdlib> #include<vector> #include<algorithm> #include<cmath> #include<stack> #include<queue> #include<iostream> #include<climits> #include<set> #include<map> #include<deque> #include<list> #include<string> #include<utility> #include<numeric> #include<iterator> #include<cctype> #include<ctime>  using namespace std;   #define fr(i,a,b) for(i=a;i<=b;i++) #define SI(a) scanf("%d",&a) #define SLL(a) scanf("%lld",&a) #define SL(a) scanf("%ld",&a) #define SF(a) scanf("%f",&a) #define MOD 1000000007 #define llu long long unsigned #define lld long long #define ld long  #define all(c)  c.begin(), c.end() #define tr(c, it)   for(typeof(c.begin()) it = c.begin(); it != c.end(); it++) #define pb push_back #define mp  make_pair  #define MIN(a, b)   ((a) < (b) ? (a) : (b)) #define MIN3(a, b, c)   ((MIN((a), (b)) > (c)) ? (c) : (MIN((a), (b)) #define INF INT_MAX #define MINF INT_MIN       //fast input   int scan_d()    {int ip=getchar(),ret=0,flag=1;for(;ip<'0'||ip>'9';ip=getchar())if(ip=='-'){flag=-1;ip=getchar();break;}for(;ip>='0'&&ip<='9';ip=getchar())ret=ret*10+ip-'0';return flag*ret;} ld scan_ld()    {int ip=getchar(),flag=1;ld ret=0;for(;ip<'0'||ip>'9';ip=getchar())if(ip=='-'){flag=-1;ip=getchar();break;}for(;ip>='0'&&ip<='9';ip=getchar())ret=ret*10+ip-'0';return flag*ret;} lld scan_lld()    {int ip=getchar(),flag=1;lld ret=0;for(;ip<'0'||ip>'9';ip=getchar())if(ip=='-'){flag=-1;ip=getchar();break;}for(;ip>='0'&&ip<='9';ip=getchar())ret=ret*10+ip-'0';return flag*ret;} llu scan_llu()    {int ip=getchar();llu ret=0;for(;ip<'0'||ip>'9';ip=getchar());for(;ip>='0'&&ip<='9';ip=getchar())ret=ret*10+ip-'0';return ret;}   //end of fast input   //fast output   //no line break void print_d(int n)     {if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[10];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<10);} void print_ld(ld n)     {if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[11];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} void print_lld(lld n)     {if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);} void print_llu(llu n)     {int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);}   //new line void println_d(int n)     {if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} void println_ld(ld n)     {if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);} void println_lld(lld n)     {if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} void println_llu(llu n)     {int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);}   //special char char sp; void printsp_d(int n)     {if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} void printsp_ld(ld n)     {if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);} void printsp_lld(lld n)     {if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} void printsp_llu(llu n)     {int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);}   //end of fast output  template<class T> T mymax(T a,T b) {     return a>b?a:b; } template<class T> T mymin(T a,T b) {     return a<b?a:b; }  int linepoints(int x1,int y1,int x2,int y2) {  	float f;   int n=mymax(y1-y2,y2-y1),d=mymax(x1-x2,x2-x1),count=0,i; 	fr(i,mymin(x1,x2)+1,mymax(x1,x2)-1) 	{ 		if((n*i)%d==0)count++; 	} 	return count; }  int gcd(int a, int b) {     return (b==0)?a:gcd(b, a%b); }   int gcd2(int a, int b) {     if(!a) return b+1;     if(!b) return a+1;     return gcd(a, b)+1; }   int main() { 	int T,t;               int i,b; int p1,p2,p3,p4;  float a; 	SI(T); 	t=T; 	while(T--) 	{ 	int X[5],Y[5]; 	fr(i,1,4){SI(X[i]);SI(Y[i]);}     a=0.5*(fabs( (X[1]*Y[2] - X[2]*Y[1]) + (X[2]*Y[3] - X[3]*Y[2]) + (X[3]*Y[4] - X[4]*Y[3]) + (X[4]*Y[1]-X[1]*Y[4]) ) );     p1=linepoints(X[1],Y[1],X[2],Y[2]);     p2=linepoints(X[2],Y[2],X[3],Y[3]);     p3=linepoints(X[3],Y[3],X[4],Y[4]);     p4=linepoints(X[4],Y[4],X[1],Y[1]);      p1= gcd2(abs(X[2]-X[1]), abs(Y[2]-Y[1]));     p2= gcd2(abs(X[3]-X[2]), abs(Y[3]-Y[2]));     p3= gcd2(abs(X[4]-X[3]), abs(Y[4]-Y[3]));     p4= gcd2(abs(X[1]-X[4]), abs(Y[1]-Y[4]));     b=p1+p2+p3+p4-4;     //printf("%f %d %d",a,(int)(a+1-b/2),b);     i=(int)(a+1-(float)b/2);     printf("Case %d: %d\n",t-T,i+b);     }     return 0; } 
#include <cstring> #include <iostream> #include <stdio.h> #include <cstdlib> #include <cctype> #include <algorithm> #include <map> #include <vector> #include <list> #include <set> #include <queue> #include <deque> #include <stack> #include <bits/stdc++.h> #include <string> #include <cmath> using namespace std; #define pb push_back #define mp make_pair #define mod 1000000007 #define ll long long #define int long long #define ff first #define ss second #define inf  1e9 #define infll 1e18 #define pr(x) printf("%lld\n",x) #define prs(x) printf("%lld ",x) #define sc(x) scanf("%lld",&x) #define trc(x) cout << #x << " = " << x << endl #define pii pair<int,int> #define fr(i,a,n) for(i=a;i<n;i++) #define fd(i,a,n) for(i=n;i>a;i--) #define fiv(v) for(i=0;i<v.size();i++) #define clr(a) memset(a,0,sizeof(a)) #define fill(a,v) memset(a,v,sizeof(a)) #define all(a) a.begin(),a.end() #define iter(c,it) for(typeof((c).begin()) it= (c).begin(); it != (c).end(); it++) ll dp[1005]; set<string>st; map<char,int>map1; vector<char>c1; ll solve(ll idx,ll n,string s) {    if(idx>=n)return 0;    if(dp[idx]!=-1)return dp[idx];    ll res=mod,f=0;    if(st.count(s))     f=1;    else f=0;    res=min(res,f+solve(idx+1,n,s+c1[idx]));    return res; } main() {     int i,n,j,k,l,m,t,c=0,ans,x;     sc(t);     fr(x,1,t+1)     {       sc(n);       st.clear();       string s;       vector<string>v;       fr(i,0,n)       {           cin>>s;           v.pb(s);       }       fr(i,0,10)       {           sc(l);           sc(k);           char ch;           fr(j,0,k)           {               cin>>ch;               map1[ch]=i;           }       }        fr(i,0,v.size())       {          s=v[i];          fr(j,0,s.size())          {              s[j]=map1[s[j]]+'0';          }          st.insert(s);       }       sc(n);       c1.clear();       fill(dp,0);       fr(i,0,n)       {          char ch;          cin>>ch;          c1.pb(ch);       }      for(i=1;i<=n;i++)       {           string s1="";           dp[i]=mod;           for(j=0;j<i;j++)           {               s1+=string(1,c1[j]);           }           for(j=0;j<i;j++)           {              if(st.count(s1)&&dp[j]!=mod)                 dp[i]=min(dp[i],dp[j]+1);              s1.erase(s1.begin());           }       }      // c=solve(0,n,"");      c=((dp[n]==mod)?0:dp[n]);       printf("Case %lld: %lld\n",x,(c==0)?-1:c);      }     return 0; } 
#include <iostream> #include <cstring> #include <queue> #include <vector>  using namespace std;  int cap[501][501]; int n, k; int val;  int maxflow() {     bool flow = true;     int ans = 0;     while(flow) {         flow = false;         queue<int> pq;         vector<int> vis(n+k+2);         pq.push(0);         int from[n+k+2];         memset(from, -1, sizeof(from));         while(!pq.empty())         {             int pos = pq.front();             pq.pop();             vis[pos] = 1;             if(pos == n+k+1) break;             for(int i = 0; i < n+k+2; i++) {                 if(cap[pos][i] && !vis[i]) {                     pq.push(i);                     from[i] = pos;                 }             }         }          if(vis[n+k+1]) flow = true;         else break;         int pos = n+k+1;         while(pos != 0) {             cap[from[pos]][pos]--;             cap[pos][from[pos]]++;             pos = from[pos];         }         ans++;     }     return ans; }  int main() {     int t;      cin >> t;     int cs = 0;     while(t--) {         cin >> n >> k;         memset(cap, 0, sizeof(cap));         for(int i = 0; i < n; i++) {             cin >> val;             cap[0][i+1] = val;             cap[i+1][0] = 0;             cap[i+1][n+k+1] = 1;             cap[n+k+1][i+1] = 0;         }         cs++;         for(int i = 0; i < k; i++) {             for(int j = 0; j < n; j++) {                 cin >> val;                 if(!val) {                     cap[j+1][n+i+1] = 1;                 }                 else cap[i+n+1][j+1] = val-1;             }         }          cout << "Case " << cs << ": " << maxflow() << endl;     } } 
#include <iostream> #include <vector> #include <algorithm> #include <cmath> #include <queue> #include <set> #include <cstdio> #include <cstdlib> #include <stack> #include <cstring> #include <iomanip> #include <cctype> #include <map> #include <cassert>   using namespace std;   int dp[105][105];   void solve(int t) {     int k,l; cin>>k>>l;     string a,b; cin>>a>>b;     int x,y; cin>>x>>y;     for(int i = 1;i <= k;i++) {         dp[i][0] = x + i;     }     for(int i = 1;i <= l;i++) {         dp[0][i] = min(x + i,y);     }     for(int i = 1;i <= k;i++) {         for(int j = 1;j <= l;j++) {             dp[i][j] = dp[i - 1][j - 1] + (a[i - 1] != b[j - 1]);             for(int  c = 1;c <= i;c++) {                 dp[i][j] = min(dp[i][j],dp[i - c][j] + c + x);             }             for(int c = 1;c <= j;c++) {                 dp[i][j] = min(dp[i][j],dp[i][j - c] + min(c + x,y) );             }         }     }     cout<<"Case "<<t<<": "<<dp[k][l]<<endl; }   int main() {     int t; cin>>t;     for(int i = 1;i <= t;i++) {         solve(i);     } } 
#include <iostream> #include <vector> #include <algorithm> #include <string> #include <cstdio> #include <cassert> #include <cmath> #include <time.h>  #define boost ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0) #define max(a,b) ((a)>(b)?a:b) #define min(a,b) ((a)<(b)?a:b) #define min_3(a,b,c) (min((a),min((b),(c)))) #define INF 1000000007  using namespace std;  int main() { 	boost; 	vector<int> v1; 	vector<int> v2; 	int tc; 	int n,k,key; 	cin >> tc; 	int count = 0; 	while (tc--) { 		v1.clear(); 		v2.clear(); 		long long sum = 0; 		cin >> n; 		for(int i = 0 ; i < n ; i++) { 			cin >> k; 			v1.push_back(k); 		} 		for (int i = 0; i < n; i++) { 			cin >> key; 			v2.push_back(key); 		} 		sort(v1.begin(),v1.end()); 		sort(v2.begin(),v2.end()); 		for (int i = 0; i < n; i++) { 			sum += fabs(v1[i]-v2[i]); 		} 		count++; 		cout << "Case "<<count<<": "<<sum<<endl; 	} }
/* Author : RISHAV GOYAL */  #include <bits/stdc++.h>  using namespace std;  #define LL long long int #define UL unsigned long long int  #define FOR(i,a,b) for(int i= (int)a; i<= (int)b; i++) #define rep(i,n) for(int i= int(1); i<= (int)n; i++) #define FORd(i,a,b,d) for(int i=(int)a; i<= (int)b; i+=(int)d)  #define pr() printf("Reached here 1...\n"); #define pr1() printf("Reached here 2...\n"); #define gc getchar_unlocked  #define si(a) scanf("%d",&a); #define sl(a) scanf("%lld",&a); #define ss(a) scanf("%s",a); #define sc(a) scanf("%c",&a); #define su(a) scanf("%llu",&a);  #define pi(a) printf("%d\n",a); #define pl(a) printf("%lld\n",a); #define ps(a) printf("%s\n",a); #define pu(a) printf("%llu\n",a);  #define arg(a,N) rep(i,N)si(a[i]);  #define CLR(a) memset(a,0,sizeof(a)); #define SET(a) memset(a,-1,sizeof(a));  #define str strlen #define pb(x) push_back(x) #define mp make_pair #define ii pair<int,int> #define gcd(a,b) __gcd(a,b)  #define mod int(1e9 +7) #define MAX int(1e5 + 10)  #define VI vector<int> #define VL vector<LL> #define VS vector<string> #define VC vector<char>   int gcd ( int a, int b ){int c;while(a!= 0){c=a;a=b%a;b=c;}return b;} LL powmod(LL a,int b,int n){LL rm=1;while (b){if (b % 2) { rm = (rm * a) % n; }a = (a * a) % n;b /= 2;}return rm;}  void sint(int &x) { 	register int c = gc(); 	x = 0; 	for(;(c<48 || c>57);c = gc()); 	for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} }  void sll(LL &x) { 	register LL c = gc(); 	x = 0; 	for(;(c<48 || c>57);c = gc()); 	for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} }  int dp[1010][1010];  int main() { 	string A,B; 	int la,lb,pos[300],T; 	cin >> T; 	FOR(ts,1,T){ 		CLR(dp); 		cin >> la >> lb >> A >> B; 		for(int i=1;i<=la;++i){ 			SET(pos); 			for(int j=1;j<=lb;++j){ 				dp[i][j] = dp[i-1][j]; 				pos[B[j-1]] = j; 				if( pos[A[i-1]] != -1){ 					dp[i][j] = max ( dp[i][j], 1 + dp[i-1][pos[A[i-1]]-1]); 				} 			} 		} 		cout << "Case "<<ts<<": "<<la + lb - dp[la][lb] <<endl; 	} 	return 0; } 
#include <stdio.h> #include <stdlib.h> #include <iostream> #include <string.h> #include <algorithm> #include <math.h> #include <vector> #include <queue> #include <set> #include <stack> #include <map> #define INF_MAX 2147483647 #define INF_MIN -2147483647 #define INF_LL 9223372036854775807LL #define INF 2000000000 #define PI acos(-1.0) #define inf INT_MAX #define llu unsigned long long int #define all(v) v.begin(),v.end() #define pb push_back #define mp make_pair #define F first #define S second #define si(n) scanf("%d",&n) #define slli(n) scanf("%lld",&n); #define ss(n) scanf("%s",n); using namespace std; typedef long long int LL;  pair<int , int > ppp[110]; int dp[104][(24*70)] , N;   int func(int index , int start_time) {   	if(index==0) 		return 0;  	if(dp[index][start_time]!=-1) 		return dp[index][start_time];  	if(ppp[index].first==-1)	//assign ith candidate for the interview 	{ 		dp[index][start_time] =  1  + func(index-1 , start_time); 	}   	if(start_time + ppp[index].second +30 <= ppp[index].first)	//assign ith candidate for the interview 		dp[index][start_time] = max(dp[index][start_time] , 1 + func(index-1 , start_time + ppp[index].second));  	//do not assign ith candidate for the interview 	dp[index][start_time] = max(dp[index][start_time] , func(index-1 , start_time));  	return dp[index][start_time];  }   int main() { int test; si(test);  for(int o=1;o<=test;o++) { memset(dp , -1 , sizeof(dp)); si(N); for(int i=1;i<=N;i++) 	si(ppp[i].second); for(int i=1;i<=N;i++){ 	si(ppp[i].first); } sort(ppp + 1 , ppp + N + 1); //but we have to sort in decreasing order reverse(ppp+1 , ppp+N+1);  // cout  << "Case " << o << << N - func(N , 0) << endl; printf("Case %d: %d\n",o ,  N - func(N , 0)); }  return 0; }             
# include <iostream> # include <fstream> # include <sstream> # include <algorithm> # include <cstdio> # include <cmath> # include <numeric> # include <cstdlib> # include <cstring> # include <vector> # include <list> # include <set> # include <map> # include <stack> # include <queue> # include <cctype> # include <climits> # include <complex>  using namespace std;  typedef long long LL; typedef unsigned long long ULL; typedef pair<int,int> PII; typedef vector<int> VI; typedef vector<VI> VVI; typedef pair<int,PII> TRI; typedef vector<string> VS;  #define REP(i,a,b) for(int i=a;i<b;i++) #define FOR(i,n) REP(i,0,n) #define ALL(v) (v).begin(),(v).end() #define TR(i,x) for(typeof(x.begin()) i=x.begin();i!=x.end();i++) #define bitcount(x) __builtin_popcount(x) #define pb push_back #define mp make_pair #define mt(a,b,c) mp(a,mp(b,c)) #define EPS (double)(1e-9) #define INF 1000000000 #define MOD 1000000007 #define PI (double)(3.141592653589793)  inline int inp() {     register int r=0,c;     for(c=getchar_unlocked(); c<=32; c=getchar_unlocked());     if(c=='-')         return -inp();     for(; c>32; r=(r<<1)+(r<<3)+c-'0',c=getchar_unlocked());     return r; }  long long int ans; double i,j,x,l,m1,inc; int x1,x2,y11,y2; int main() {      int t,k,X=0;     t = inp();     while(t--)     {X++;         ans=0;         k=inp();         x1=inp();         y11=inp();         x2=inp();         y2=inp();         int diffx=abs(x2-x1);        int diffy=abs(y2-y11);        if(x2>x1)        {            i=(double)x1+0.5;            inc=0.5;         }         else         {             i=(double)x1-0.5;             inc=-0.5;         }         l=(double)(y2-y11);          if((x2-x1)!=0 && (y2-y11)!=0)         {         l=l/(double)(x2-x1);             int cnt=0;         for(;(inc>0)?(i<(double)x2):(i>(double)x2); i+=inc*2)         {             j=(double)y11 + (l)*(i-(double)x1);                 x=j-floor(j);                if(abs(x-0.5)<1e-6)                     cnt++;         }         ans=diffx;         ans+=diffy;         ans+=cnt;         ans+=1;         printf("Case %d: %lld\n",X,ans);         }         else         printf("Case %d: %lld\n",X,abs(x2-x1)+abs(y2-y11)+1);     }     return 0; } 
#include<bits/stdc++.h> using namespace std;  bitset<1001> vis; int ady[1001][1001]; bool use[2002]; int T,t,h,g,k,resp,match[1001]; pair<int,int > ch[1001],cg[1001];  void restart(){     resp=0;     vis.reset();     for(int i=0;i<1001;i++){         use[i]=use[1001+i]=false;         match[i] = -1;          for(int j=0;j<1001;j++)             ady[i][j]=0;     } } void graph(){     for(int i=0;i<g;i++){         for(int j=0;j<h;j++){             if(abs(ch[j].first-cg[i].first)+abs(ch[j].second-cg[i].second)+abs(cg[i].first-k)+abs(cg[i].second-k) <= t)                 ady[i][j]=1;         }     } } bool path(int nd){     for(int i=0;i<h;i++){         if(ady[nd][i] != 1 || use[i])   continue;         use[i] = true;          if(match[i]==-1 || path(match[i])){             match[i] = nd;             return true;         }     }     return false; } void matching(){     for(int i=0;i<g;i++){         for(int j=0;j<1001;j++) use[j] = false;          if(path(i))  resp++;     } }  int main(){     scanf("%d",&T);      for(int z=1;z<=T;z++){         restart();          scanf("%d %d %d %d",&h,&g,&k,&t);         for(int i=0;i<h;i++)    scanf("%d %d",&ch[i].first,&ch[i].second);         for(int i=0;i<g;i++)    scanf("%d %d",&cg[i].first,&cg[i].second);          graph();         matching();         printf("Case %d: %d\n",z,resp);     } } 
#include<bits/stdc++.h> using namespace std ; int k , m , u , v , s , f , t ; const int maxn = 600 ;  int dist[maxn][7] , vis[maxn][7]; int INF = 1000000009 ;   struct node {     int v , s , f , t ;  };  typedef struct node node ;  struct node2 {     int r , e  , t ; //    bool operator <( node2 x ) const //    { //        return t < x.t ; //    } };  bool operator < (const node2 &a,const node2 &b) {     return a.t > b.t; }  typedef struct node2 node2 ;   vector< node >g[maxn] ;  int main() {       int n ;       cin >> n  ;       for ( int cas = 1 ; cas <= n ; cas++)       {           cin >> k >> m ;            for ( int j = 1 ; j <= k ; j++)             g[j].clear() ;             for ( int i = 1 ; i <= k ; i++)           {             for ( int j = 0 ; j <= 6 ; j++)                  {                     vis[i][j] = 0 ;                     dist[i][j] = INF ;                 }           }            for ( int j = 1 ; j <= m ; j++)           {               cin >> u >> v >> s >> f >> t ;               node a ;               a.v = v ;               a.s = s;               a.f = f ;               a.t = t ;               g[u].push_back(a) ;           }            dist[1][6] = 0 ;            priority_queue < node2 > q ;           node2 start ;           start.r = 1 ;           start.e = 6 ;           start.t = 0 ;            q.push(start) ;            while( !q.empty())           {             node2 x = q.top();             q.pop() ;             if ( vis[x.r][x.e] == 1 )                 continue ;              for( int j = 0 ; j < ( g[x.r]).size() ; j++)             {                 int v1 = g[x.r][j].v ;                  for ( int i = 0 ; i <= 24 ; i++)                 {                     int nt =  x.t + i  ;                      int nh = ( ( x.t ) + i  ) % 24 ;                      int ne = min ( x.e + i , 6 );                        if ( ( g[x.r][j].s <= nh ) && (   g[x.r][j].f >= nh ) &&  ( g[x.r][j].t <=  ne  ) )                       {                           if ( ( nt + g[x.r][j].t ) < ( dist[v1][ ne - g[x.r][j].t ]) )                            {                               dist[v1][ne - g[x.r][j].t] =  g[x.r][j].t + nt  ;                               node2 y;                                y.r = v1 ;                                y.e = ne - g[x.r][j].t ;                                y.t = dist[v1][ne - g[x.r][j].t];                                 q.push(y) ;                            }                       }                  }              }              vis[x.r][x.e] = 1 ;            }   int ans = INF ;   int fi , fj , fh ;   for ( int i = 0 ; i < 7 ; i++)  {      //for ( int h = 0 ; h < 24 ; h++)      //{          if( ans > dist[k][i])          {              ans = dist[k][i];              fi = k ;              fj =  i ;           }      //}  }  cout << "Case " << cas << ": " << ans  << endl ; //cout << " fj " <<  fj << endl ; }        return 0 ; } 
#include <stdio.h> #include <stdlib.h> #include <iostream> #include <string.h> #include <algorithm> #include <math.h> #include <vector> #include <queue> #include <set> #include <stack> #include <map> #define INF_MAX 2147483647 #define INF_MIN -2147483647 #define INF_LL 9223372036854775807LL #define INF 2000000000 #define PI acos(-1.0) #define inf INT_MAX #define llu unsigned long long int #define all(v) v.begin(),v.end() #define pb push_back #define mp make_pair #define F first #define S second #define si(n) scanf("%d",&n) #define slli(n) scanf("%lld",&n); #define ss(n) scanf("%s",n); using namespace std; typedef long long int LL; int dist[110][110] , dp[110][110][110]; //lasta and lastb denote the largest id of cities in both sets. int recur(int curr_node , int lasta , int lastb){	 	if(curr_node < 0) 		return 0;	 	if(curr_node == 0) 		return dist[0][lasta] + dist[0][lastb]; 	if(dp[curr_node][lasta][lastb]!=-1) 		return dp[curr_node][lasta][lastb];	 	int ret; 	//assign curr_node to set A 	ret = dist[curr_node][lasta] + recur(curr_node-1 , curr_node , lastb); 	ret = min(ret , recur( curr_node-1 , lasta , curr_node ) + dist[curr_node][lastb]); 	dp[curr_node][lasta][lastb] = ret; 	return ret; } int main() { int K , R , id , U , W , test; si(test); for(int o=1;o<=test;o++) { memset(dp , -1 , sizeof(dp)); si(K);si(R); for(int ln = 1; ln <= K+2 ; ln++){ 	si(id); 	dist[id][id] = 0; 	for(int j=1;j<=(K+1);j++){ 		si(U);si(W); 		dist[id][U] = W; 	} } int st = 0 , en = K+1; int ans = recur(K , K+1 , K+1) + R*(K+1); printf("Case %d: %d\n",o , ans); } return 0; }
	#include <iostream> 	#include<stack> 	#include<string> 	#include<vector> 	#include<set> 	#include<queue> 	#include<stdio.h> 	#include<string.h> 	#include<math.h> 	#include<algorithm> 	using namespace std;  	#define gc getchar 	#define p 1000000007 	#define MOD 1000000007 	#define pc(x) putchar(x) 	#define pi(n) printf("%d",n) 	#define pis(n) printf("%d ",n) 	#define pin(n) printf("%d\n",n) 	#define pll(n) printf("%lld",n) 	#define ps printf(" ") 	#define pn printf("\n") 	#define rep(i,n) for(i=0;i<n;i++) 	#define fu(i,a,n) for(i=a;i<=n;i++) 	#define fd(i,n,a) for(i=n;i>=a;i--) 	#define INV 333333336 	#define ll long long 	#define ull unsigned long long 	#define EPS 1e-9 	#define infi 2000000000  	inline int sn() 	{ 		int n=0; 		int ch=gc(); 		while( ch <48 )ch=gc(); 		while( ch >47 ) 		n = (n<<3)+(n<<1) + ch-'0', ch=gc(); 		    return n; 	}  	inline void wi(int n) 	{ 		int N = n, rev, count = 0; 		rev = N; 		if (N == 0) { pc('0');  return ;} 		while ((rev % 10) == 0) { count++; rev /= 10;} //obtain the count of the number of 0s 		rev = 0; 		while (N != 0) { rev = (rev<<3) + (rev<<1) + N % 10; N /= 10;}  //store reverse of N in rev 		while (rev != 0) { pc(rev % 10 + '0'); rev /= 10;} 		while (count--) pc('0'); 	}  		 	 	ll dig(ll n) 	{ 		ll t=0; 		while(n) 		{ 			t++; 			n/=10; 		}		 		return t; 	}	 		 	ll dig1(ll n) 	{ 		ll t=1,i; 		rep(i,n) 		{ 			t*=10; 			//n/=10; 		}		 		return t; 	}	 		 	int main() 	{ 		int t=sn(); 		for(int q=1;q<=t;q++) 		{ 			ll a,b,e,d,a1,a2,i; 			int x,y; 			scanf("%d %d",&x,&y); 			a=1; 			e=0; 			a1=100000000; 			a1*=1000000; 			rep(i,1000000) 			{ 				e++; 				a*=x; 				if(a>a1) 				a=a/(dig1(dig(x))); 				//pll(a);ps;pll((a/(dig1(dig(a)-dig(y)))));pn; 				if((a/(dig1(dig(a)-dig(y))))==y) break; 			} 			printf("Case %d: ",q);			 			pll(e);pn; 		} 	 	}               
#include <cstdlib> #include <cstdio> #include <algorithm> #include <vector> #include <queue> #include <cmath> #include <stack> #include <map> #include <set> #include <deque> #include <cstring> #include <functional> #include <climits> #include <list> #include <ctime> #include <complex>  #define F1(x,y,z) for(int x=y;x<z;x++) #define F2(x,y,z) for(int x=y;x<=z;x++) #define F3(x,y,z) for(int x=y;x>z;x--) #define F4(x,y,z) for(int x=y;x>=z;x--) #define pb push_back #define LL long long #define co complex<double>  #define MAX 100005 #define AMAX 1500 #define MOD 1000000007  #define f(c,d) ((1<<(c))*(d))  using namespace std;  int t,n,k; LL x[105],y[105],ans,z[105],ta;  int main(){     scanf("%d",&t);     while(t--){         ans=LLONG_MAX;         scanf("%d%d",&n,&k);         F1(a,0,n)scanf("%lld%lld",x+a,y+a);         F1(a,0,n)F1(b,0,n){             ta=0;             F1(c,0,n)z[c]=abs(x[c]-x[a])+abs(y[c]-y[b]);             sort(z,z+n);             F1(c,0,k)ta+=z[c];             ans=min(ans,ta);         }         printf("%lld\n",ans);     } 	//system("pause"); 	return 0; } 
#include<bits/stdc++.h> using namespace std;  typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int,int> ii; #define sz(a) int((a).size()) #define pb push_back #define all(c) (c).begin(),(c).end() #define tr(c,i) for(typeof((c).begin() i = (c).begin(); i != (c).end(); i++) #define present(c,x) ((c).find(x) != (c).end()) #define cpresent(c,x) (find(all(c),x) != (c).end())  #define S(x) scanf("%d",&x) #define S1(x) scanf("%lld",&x) #define P(x) printf("%d\n",x) #define P1(x) printf("%lld\n",x) #define Ps(x) printf("%d ",x) #define P1s(x) printf("%lld ",x) #define St(x) scanf("%s",x) #define Pt(x) printf("%s",x) #define Sa(a,n) for(int i=0;i<(n);i++){S1(a[i]);} #define Pa(a,n) for(int i=0;i<(n);i++){P1s(a[i]);}Pt("\n"); #define Y printf("even\n") #define N printf("odd\n") #define mod 1000000007 #define ll long long  ll power(ll b, ll e) {     ll p = 1;     while (e > 0) {         if(e&1) {             p = (p*b)%mod;         }         e = e>>1;         b = (b * b)%mod;     }     return p; } /* ll inp() { 	ll n=0,s=1; 	char c; 	for(c=getchar_unlocked();c<48||c>58;c=getchar_unlocked()) 	if(c=='-')s=-1; 	for(;c>47&&c<59;c=getchar_unlocked()) 	n=n*10+c-48; 	return n*s; }*/ char num[22]; int main() { 	ll n,i,t,j,l; 	for(S1(t);t--;) 	{ 		St(num); 		l=strlen(num); 		for(i=l-1;i>=0&&num[i]=='0';i--); 		if(num[i]=='.')             i--;         (num[i]%2==0)?Y:N;  	} 	return 0; } 
#include<stdio.h> #include<algorithm> using namespace std; int main() { 	long long int t,n,*a,i,max,m; 	scanf("%lld",&t); 	while(t--) 	{ 		scanf("%lld",&n); 		a=new long long int[n]; 		for(i=0;i<n;i++) 		scanf("%lld",&a[i]); 		for(i=0;i<n;i++) 		{ 		m=a[i]%9; 		if(m==0&&a[i]!=0) 		a[i]=9; 		else 		a[i]=m; 	    } 		sort(a,a+n); 		max=a[n-1]; 		switch(max) 		{ 			case 0: printf("red\n"); break; 			case 1: printf("blue\n"); break; 			case 2: printf("pink\n"); break; 			case 3: printf("white\n"); break; 			case 4: printf("black\n"); break; 			case 5: printf("violet\n"); break; 			case 6: printf("cyan\n"); break; 			case 7: printf("yellow\n"); break; 			case 8: printf("green\n"); break; 			case 9: printf("brown\n"); break; 		} 		delete a; 	} }
#include<iostream> #include<stdio.h> #include<string.h> using namespace std; int main() { 	int a[26],t,l,i; 	string s; 	scanf("%d",&t); 	while(t--) 	{ 		for(i=0;i<26;i++) 		a[i]=0; 		scanf("%d",&l); 		cin>>s; 		for(i=0;i<l;i++) 		{ 			a[s[i]-'a']++; 		} 		for(i=0;i<26;i++) 		{ 			if(a[i]%2==1) 			break; 		} 		cout<<char(i+'a')<<endl; 	} }
#include<bits/stdc++.h> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {         long long a,b,c,temp;           long long ab=0,bc=0,ca=0,abc=0;         cin>>a>>b>>c;         map<int,int> aa,bb,cc;         for(int i=0;i<a;i++)         {             cin>>temp;             aa[temp]++;           }         for(int i=0;i<b;i++)         {             cin>>temp;             bb[temp]++;             if(aa[temp]==1)                 ab++;           }         for(int i=0;i<c;i++)         {             cin>>temp;             cc[temp]++;             if(aa[temp]==1)                 ca++;             if(bb[temp]==1)                 bc++;             if(aa[temp]==1&&bb[temp]==1)                 abc++;           }               cout<<ab<<" "<<bc<<" "<<ca<<" "<<abc<<endl;     } } 
#include<bits/stdc++.h> using namespace std; int main() {     int t,n,a,i,f,g;     cin>>t>>n;     set<int> s;     for(i=0;i<n;i++)     {         cin>>a;         s.insert(a);     }     while(t--)     {         int p,q;         cin>>p>>q;         if(p==1)         {             s.insert(q);         }         else if(p==2)         {             s.erase(q);         }         else if(p==3)         {             if(s.size()<=1)             cout<<"-1"<<endl;             else             {                 set<int>::iterator it = s.end();                 int a=*(--it)+*(--it);                 cout<<a<<endl;             }         }       }     return 0; }  
#include<iostream> #include<cstdio> #include<cmath> #include<string> #include<cstring> #include<vector> #include<bitset> #include<map> #include<set> #include<climits> #include<algorithm> #include<utility> #include<cstdlib> #include<cctype> #include<queue> #include<sstream> #define read(x) scanf("%d",&x) #define write(x) printf("%d\n",x) #define assign(x,n) x=(int*)calloc(n,4) #define rep(i,n) for(i=1;i<=n;++i) typedef  long long int ull; using namespace std;  priority_queue<int> pr;  int main() {  int n,k,i,j;  cin>>n>>k;  for(i=0;i<k;i++)  {                  cin>>j;                  pr.push(j);  }  for(i=k;i<n;i++)  {                  cin>>j;                  if(j==-1)cout<<pr.top()<<endl;                  else {pr.push(j);pr.pop();}  }                                                //freopen("in.txt","r",stdin);freopen("out.txt","w",stdout); //getchar(); return 0; } 
#include<iostream> #include<cstdio> using namespace std; int main() {     int t;     scanf("%d",&t);     while(t--)     {         int m,n;         scanf("%d%d",&m,&n);         int k,l;         k=(n-1)*m+(m-1);         if(k%2==1)            printf("%s\n","[:=[first]");         else             printf("%s\n","[second]=:]");     }     return 0; } 
#include <bits/stdc++.h>   using namespace std;   #define MAX 1123456 typedef long long ll;   ll a[MAX];   int main() {   	int t; scanf("%d", &t);   	while(t--) {   		int N, M; scanf("%d %d", &N, &M);   		for(int i = 0; i < N; i++) scanf("%d", &a[i]);   		ll sum = 0; 		int i = 0;   		for(; i < M; i++) sum += a[i];   		for(;  i < N; i++) 			sum -= (ll)(ceil(a[i]/2));   		if(sum < 0) 			cout << "DEFEAT" << endl; 		else 			cout << "VICTORY" << endl; 	} 	return 0; } 
 #include <bits/stdc++.h> #define getcx getchar_unlocked  #ifdef WIN32     inline char getchar_unlocked(){return getchar();}     inline void putchar_unlocked(char x){putchar(x);} #endif // WINDOWS using namespace std;  typedef pair<int,int> ii; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ii> vii; #define sz(a) int((a).size()) #define pb push_back #define mp make_pair #define fi first #define se second #define _(x) memset(x,0,sizeof(x)) #define all(c) (c).begin(),(c).end() #define foreach(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) #define present(c,x) ((c).find(x) != (c).end()) #define cpresent(c,x) (find(all(c),x) != (c).end()) #define forall(i,a,b) for(int i=a;i<(b);i++) #define forb(i,a,b) for(int i=a;i>=(b);i--) #define ll long long #define ull unsigned long long #define ui unsigned int #define PI 3.1415926535897932384626 inline void pisz(int n) { printf("%d\n",n); } #define DBG(vari) cerr<<#vari<<" = "<<(vari)<<endl; #define printA(a,L,R) forall(i,L,R) cout << a[i] << (i==R?'\n':' ') #define printV(a) printA(a,0,a.size()-1)   inline int fi (){//fast input function     register int c = getcx();     int x = 0;     int neg = 0;     for(;((c<48 || c>57) && c != '-');c = getcx());     if(c=='-') {neg=1;c=getcx();}     for(;c>47 && c<58;c = getcx()) {x = (x<<1) + (x<<3) + c - 48;}     if(neg) x=-x;     return x; }  inline void fo(int a) { 	char snum[20]; 	int i=0;     int c =a; 	do{ 		snum[i++]=a%10+48; 		a=a/10; 	} 	while(a!=0); 	i=i-1;     if(c<0)         putchar_unlocked('-'); 	while(i>=0) 	putchar_unlocked(snum[i--]); 	putchar_unlocked('\n'); } #define N_PRIMES 2005 char s[2003]; int counts[27];  int main() {     int t = fi();      forall(cx,1,t+1){         scanf("%s",s);         int len = strlen(s);         int ans = INT_MAX;          _(counts);          forall(i,0,len){             counts[s[i]-'a']++;         }         sort(counts,counts+26);         reverse(counts,counts+26);          forall(k,1,27){             int tmp = 0;              if(len%k!=0)                 continue;              int mean =len/k;              forall(i,0,k){                 tmp += abs(counts[i]-mean);             }              forall(i,k,26){                 tmp += counts[i];             }              ans = min(ans,tmp/2);         }          printf("%d\n", ans);      }      return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { long long int t; cin>>t; while(t--) { char s[1009]; cin>>s; long long int i=0,sum=0; while(s[i]!='\0') { if(isdigit(s[i])) { sum+=s[i]-'0'; } i++; } cout<<sum<<endl; } return 0; }
#include<bits/stdc++.h> #define ll long long int #define mp make_pair #define pb push_back #define si(x) scanf("%d",&x) #define pi(x) printf("%d\n",x) #define s(x) scanf("%lld",&x) #define p(x) printf("%lld\n",x)  using namespace std;  int a[1002][1002]; int dp[4][1002][1002]; int main(){ int t; si(t); while(t--){    int n,m,i,j;    si(n);si(m);    for(i=0;i<=n+1;i++){         for(j=0;j<=m+1;j++){             a[i][j]=0;             dp[0][i][j]=0;dp[1][i][j]=0;dp[2][i][j]=0;dp[3][i][j]=0;         }     }     for(i=1;i<=n;i++){     for(j=1;j<=m;j++){         si(a[i][j]);     }    }    for(i=1;i<=n;i++){     for(j=1;j<=m;j++){          dp[0][i][j] =min(dp[0][i-1][j]+a[i][j],a[i][j]);          dp[1][n+1-i][j] =min(dp[1][n+1-i+1][j]+a[n+1-i][j],a[n+1-i][j]);          dp[2][i][j] =min(dp[2][i][j-1]+a[i][j],a[i][j]);          dp[3][i][m+1-j] =min(dp[3][i][m+1-j+1]+a[i][m+1-j],a[i][m+1-j]);     }    }     int ans=INT_MAX;    for(i=1;i<=n;i++){     for(j=1;j<=m;j++){          ans=min(dp[0][i][j]+dp[1][i][j]+dp[2][i][j]+dp[3][i][j]-3*a[i][j],ans);     }    }    pi(ans);  }  return 0; } 
 #include<bits/stdc++.h> using namespace std; #define D(x)        cout<<#x " = "<<(x)<<endl #define un(x)       x.erase(unique(x.begin(),x.end()), x.end()) #define sf(n)       scanf("%d", &n) #define sff(a,b)    scanf("%d %d", &a, &b) #define sfff(a,b,c) scanf("%d %d %d", &a, &b, &c) #define pb          push_back #define mp          make_pair #define xx          first #define yy          second #define hp          (LL) 999983 #define MAX         100000 typedef long long int LL;  const int rt = 317; int arr[MAX+11], lazy[MAX+5][rt+5], buk[rt+5];  int main() {     //freopen("c:\\Users\\User\\Desktop\\in.txt", "r", stdin);     //freopen("c:\\Users\\User\\Desktop\\out.txt", "w", stdout);      int i, j, k, n, q;     int st, gp;      sff(n,q);     while(q--)     {         sff(gp, st);         if(gp >= rt)         {             while(st <= n)             {                 arr[st]++;                 st += gp;             }         }         else lazy[st][gp]++;     }      for(gp = 1; gp < rt; gp++)     {         memset(buk, 0, sizeof(buk));         for(i = 1; i <= n; i++)         {             buk[i%gp] += lazy[i][gp];             arr[i] += buk[i%gp];         }     }      for(i = 1; i <= n; i++)         printf("%d ", arr[i]);      return 0; }    
#include <iostream> #include <cassert> #include <vector> #include <cstdio> #include <algorithm> using namespace std;  #define maxn 100005  vector<int>v[maxn]; int st[maxn],sp,u[maxn],N,T,i,j,x,y,was[maxn],avail; long long K;  bool dfs(int k){ 	st[++sp]=k;u[k]=1;--K; 	if(!K){ 		for(int i=1;i<sp;i++)printf("%d ",st[i]); 		printf("%d\n",st[sp]); 		return true; 	}else for(int j=0;j<v[k].size();j++)if(!u[v[k][j]]&&dfs(v[k][j]))break; 	--sp; 	return false; }  void DFS(int k){ 	was[k]=1; 	++avail; 	for(int j=0;j<v[k].size();j++) 		if(!was[v[k][j]]) 			DFS(v[k][j]); }  int main (int argc, char * const argv[]) { 	ios_base::sync_with_stdio(0); 	cin>>T; 	for(;T;T--){ 		for(avail=0,i=1;i<=N;i++)u[i]=was[i]=0,v[i].clear(); 		cin>>N>>K; 		for(i=1;i<N;i++){ 			cin>>x>>y; 			v[x].push_back(y); 			v[y].push_back(x); 			assert(1<=x&&x<=N&&1<=y&&y<=N); 		} 		DFS(1); 		assert(avail==N); 		for(i=1;i<=N;i++)sort(v[i].begin(),v[i].end()); 		for(i=1;i<=N;i++)if(K>N)K-=N;else{ 			dfs(i); 			break; 		} 		sp=0; 	}     return 0; }
#include <iostream> #include <fstream> #include <vector> #include <set> #include <map> #include <algorithm> #include <cstring> #include <assert.h> using namespace std; class BitMap { private: unsigned char* data, *data2; int w, h, bw; int x0, y0; int size; public: BitMap() { data=data2=NULL; } ~BitMap() { if (data) free(data); if (data2) free(data2); } void resize(int minx, int maxx, int miny, int maxy) { w=maxx-minx+1; h=maxy-miny+1; bw=(w+7)/8; x0=minx; y0=miny;  data=(unsigned char*)malloc(bw*h*sizeof(unsigned char)); data2=(unsigned char*)malloc(bw*h*sizeof(unsigned char)); memset(data, 0, bw*h); memset(data2, 0, bw*h); size=bw*h; } inline void mark(int x, int y) { x-=x0; y-=y0; if (x<0||x>=w) return; if (y<0||y>=h) return; int off=y*bw+x/8; assert(off<size); int mask=1<<(x%8); data2[off]|=mask; } inline bool valid(int x, int y) { x-=x0; y-=y0; if (x<0||x>=w) return false; if (y<0||y>=h) return false; return true; } inline unsigned char marked(int x, int y) { x-=x0; y-=y0; if (x<0||x>=w) return 0; if (y<0||y>=h) return 0; int off=y*bw+x/8; assert(off<size); unsigned char mask=1<<(x%8);  return data2[off]&mask; } inline unsigned char get(int x, int y) { x-=x0; y-=y0; assert(x>=0 && y>=0); int off=y*bw+x/8; assert(off<size); unsigned char mask=1<<(x%8); unsigned char ret=data[off]&mask; return ret; } inline unsigned char set(int x, int y) { x-=x0; y-=y0; assert(x>=0 && y>=0); int off=y*bw+x/8; assert(off<size); int mask=1<<(x%8); unsigned char ret=data[off]&mask; data[off]|=mask; return ret; } inline int steps(int x, int y) { assert(x||y); x=abs(x); y=abs(y); if (x==0) return y; if (y==0) return x; while(y>0) { x = x%y;  x^=y^=x^=y; //swap } return x; } inline short draw(int x1, int y1, int x2, int y2) { if (x1>x2) return draw(x2,y2,x1,y1); if (x1==x2 && y1>y2) return draw(x2,y2,x1,y1); //cout << "draw " << x1 << " " << y1 << " " << x2 << " " << y2 << endl; int st=steps(x2-x1, y2-y1); int dx=(x2-x1)/st, dy=(y2-y1)/st; unsigned char ret=0; //set(x1,y1); int i, j; for (i=x1-dx, j=y1-dy; valid(i, j); i-=dx, j-=dy) { if (get(i,j)) return 0; } for (i=x2+dx, j=y2+dy; valid(i, j); i+=dx, j+=dy) { if (get(i,j)) return 0; } int total=0; bool head = true; for (i=x1+dx, j=y1+dy; (i!=x2)||(j!=y2); i+=dx, j+=dy) { if (marked(i,j)) head = false; if (get(i, j)) { if (head) total++; head=true;  } } if (head) total++; return total; } }; class Point { public: Point(int xx, int yy):x(xx), y(yy) { } friend bool operator<(const Point&, const Point&); short x, y; }; inline bool operator<(const Point& a, const Point& b) { if (a.y<b.y) return true; if (a.y>b.y) return false; return (a.x<b.x); }; int towSize, skySize; vector<Point> pt, skyscrappers; #define INPUT cin //#define INPUT input //ifstream input("input.txt"); int main(int argc, char* argv[]) { int ntest, n, m; INPUT >> ntest; int x, y; while (ntest--) {  BitMap bitmap; //bitmap.steps(2, -3); pt.clear(); skyscrappers.clear(); INPUT >> n >> m; towSize=n; skySize=m; pt.reserve(n+1); skyscrappers.reserve(m+1); int minx=20000, maxx=-20000; int miny=20000, maxy=-20000; while (n--) { INPUT >> x >> y; minx=min(minx, x); maxx=max(maxx, x); miny=min(miny, y); maxy=max(maxy, y); pt.push_back(Point(x,y)); } bitmap.resize(minx, maxx, miny, maxy); int total=0; short i, j; for (i=0; i<towSize; i++) { bitmap.set(pt[i].x, pt[i].y); } sort(pt.begin(), pt.end()); while (m--) { INPUT >> x >> y; bitmap.mark(x, y); } for (i=0; i<towSize; i++) { for (j=i+1; j<towSize; j++) {  int n=(bitmap.draw(pt[i].x, pt[i].y, pt[j].x, pt[j].y)); total+=n; //cout << i << " " << j << " " << n << " " << total << endl; } } cout << total << endl; } return 0; }
/*	SURENDRA KUMAR MEENA	*/ #include <vector> #include <list> #include <map> #include <set> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <queue> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <climits> #include <cassert> #include <cstring> #include <cstdlib> #include <ctime> using namespace std; typedef long long int LL; #define R(i,m,n)	for(int i=m;i>=n;i--) #define FF(i,m,n)	for(int i=m;i<n;i++) #define F(i,n)	FF(i,0,n) #define S(t)	scanf("%d",&t)  char Word[55010][26],Pat[6]; int Lenw[55010],Lenw2[55010]; int val[55010][26]; int len; int val2[6]; bool existstar[6]; bool existalpha[6]; bool existmark[6]; int totcount[6]; int qq; int memo[25][5]; int wno;  bool WildcardMatching(){ 	int ii=0,jj=0,i,j; 	while(ii<Lenw[wno] && (Pat[jj]=='?' || Pat[jj]==Word[wno][ii]))	ii++,jj++; 	if(ii==Lenw[wno]){ 		if(jj<len && Pat[jj]=='*')	jj++; 		if(jj<len)	return 0; 		return 1; 	} 	if(jj==len)			return 0; 	if(Pat[jj]!='*')	return 0; 	i=ii+1;j=jj+1; 	while(ii<Lenw[wno]){ 		if(!existstar[jj] && len-jj!=Lenw[wno]-ii){ 			ii=i++,jj=j; 			continue; 		} 		if(!existalpha[jj]){ 			if(!existstar[jj]){ 				if(len-jj==Lenw[wno]-ii)	return 1; 				ii=i++,jj=j; 				continue; 			} 			if(totcount[jj]<=Lenw[wno]-ii)	return 1; 			ii=i++,jj=j; 			continue; 		} 		if(!existstar[jj] && !existmark[jj]){ 			while(jj<len && Pat[jj]==Word[wno][ii])	jj++,ii++; 			if(jj==len && ii==Lenw[wno])	return 1; 			ii=i++,jj=j; 			continue; 		} 		if(memo[ii][jj]!=qq){ 			memo[ii][jj]=qq; 			if(Pat[jj]=='?' || Pat[jj]==Word[wno][ii])	ii++,jj++; 			else if(Pat[jj]=='*'){ 				jj++; 				if(jj<len)	i=ii+1,j=jj; 				else		return 1; 			} 			else	ii=i++,jj=j; 		} 		else{ 			ii=i++;jj=j; 		} 	} 	while(Pat[jj]=='*')	jj++; 	return	jj==len; }  int main(){ 	int t,i,j,k; 	char ch; 	memset(memo,0,sizeof(memo)); 	qq=1; 	scanf("%d",&t); 	while(t--){ 		int n,q; 		scanf("%d%d",&n,&q); 		for(i=0;i<n;i++){ 			scanf("%s",Word[i]); 			Lenw[i]=strlen(Word[i]); 		} 		memcpy(Lenw2,Lenw,sizeof(Lenw)); 		sort(Lenw2,Lenw2+n); 		while(q--){ 			int ans=0; 			scanf("%s",Pat); 			printf("%s ",Pat); 			len=strlen(Pat); 			for(i=0;i<len-1;i++) 				if(Pat[i]=='?' && Pat[i+1]=='*'){	Pat[i]='*';	Pat[i+1]='?';	} 			char *p=Pat+1; 			for(j=1;Pat[j];j++){ 				if(Pat[j]=='*' && Pat[j]==Pat[j-1])	continue; 				*p++=Pat[j]; 			} 			*p='\0'; 			len=strlen(Pat); 			existstar[len]=0; 			existalpha[len]=0; 			existmark[len]=0; 			totcount[len]=0; 			for(i=len-1;i>=0;i--){ 				existstar[i]=(existstar[i+1]|(Pat[i]=='*')); 				existalpha[i]=existalpha[i+1]; 				existmark[i]=existmark[i+1]; 				totcount[i]=totcount[i+1]; 				if(Pat[i]=='?'){ 					totcount[i]++; 					existmark[i]=1; 				} 				else if(Pat[i]!='*')	existalpha[i]=1; 			} 			if(existalpha[0]==false && existstar[0]==true){ 				printf("%d\n",n-(lower_bound(Lenw2,Lenw2+n,totcount[0])-Lenw2)); 				continue; 			} 			for(wno=0;wno<n;wno++,qq++){ 				if(Pat[0]!='*' && Pat[0]!='?' && Word[wno][0]!=Pat[0])	continue; 				if(Pat[len-1]!='*' && Pat[len-1]!='?' && Word[wno][Lenw[wno]-1]!=Pat[len-1])	continue; 				if(WildcardMatching())	ans++; 			} 			printf("%d\n",ans); 		} 		puts(""); 	} 	return 0; } 
#define DEBUG 0   #include <stdio.h> #include <string.h> #include <math.h> #include <stdlib.h>   int is_prime(char s[13]) {   int sr, i;   long long unsigned n=0;   for(i=0;s[i]!='\0';i++)     n=n*10+s[i]-'0';   if(n<=1)     return 0;   if(n<=3)     return 1;   if(n%2==0)     return 0;   sr=(int)sqrt(n);   if(DEBUG)     printf("is %llu prime sr=%d\n", n, sr);   for(i=3;i<=sr;i+=2)     if(n%i==0)       return 0;   return 1; }   int done;   void solve(char s[13], int pos) {   int i;   if(s[pos]=='\0') {     if(is_prime(s)) {       done=1;       printf("%s\n", s);     }   } else if(s[pos]!='?')     solve(s, pos+1);   else {     if(pos==0)       for(i='1';i<='9'&&!done;i++) {         s[pos]=i;         solve(s, pos+1);       }     else       for(i='0';i<='9'&&!done;i++) {         s[pos]=i;         solve(s, pos+1);       }   } }   int main(void) {   char s[13];   int tc;   scanf("%d", &tc);   while(tc--) {     scanf("%s", &s);     done=0;     solve(s, 0);   }   return 0; }
    #include<iostream>     #include<vector>     #include<deque>     #include<map>     #include<algorithm>     #include<cstdlib>     #include<time.h>     #include<stdio.h>     #include <unistd.h>     #define TIMER_ON 0     #if TIMER_ON == 1     #define TIMER(x) x     #else     #define TIMER(x)     #endif     #define DEBUG_LEVEL 0     #if DEBUG_LEVEL > 0     #define DEBUG_LVL(LEVEL, STATEMENT) if((LEVEL+1)>DEBUG_LEVEL) STATEMENT     #else     #define DEBUG_LVL(LEVEL, STATEMENT)     #endif     #define DEBUG_SPECIFIC 0     #if DEBUG_SPECIFIC == 0     #define DEBUG_SPF(LEVEL, STATEMENT) if(LEVEL==DEBUG_SPECIFIC) STATEMENT     #else     #define DEBUG_SPF(LEVEL, STATEMENT)     #endif     typedef std::pair< unsigned int /*index*/, unsigned long /*height*/ > SkyScraper;     #define bldIndex first     #define bldHeight second     unsigned int nSkyscrapers;     unsigned int halfLen;     unsigned int quatLen;     class CitySkyLine : public std::deque< SkyScraper >     {     public:     SkyScraper check;     CitySkyLine():check(0,0){}     void check_push_back(unsigned int iii, unsigned long height)     {     DEBUG_LVL(1, std::cout << "[height("<<height<<")+iii("<<iii<<")+1] > [check.bldHeight("<<check.bldHeight<<")+check.bldIndex("<<check.bldIndex<<")]"<<std::endl);     if((height+iii+1)> (check.bldHeight+check.bldIndex) )     {     DEBUG_LVL(1, std::cout << "true" << std::endl);     while(size()>0)     {     check=back();     if(height > check.bldHeight && (iii-check.bldIndex) < (height-check.bldHeight) )     {     DEBUG_LVL(2, std::cout << "-----pop_back(idx="<<check.bldIndex<<", hgt="<<check.bldHeight<<")"<<std::endl);     pop_back();     }     else     break;     }     DEBUG_LVL(2, std::cout << "+++++push_back(idx="<<iii<<", hgt="<<height<<")"<<std::endl);     check=SkyScraper(iii,height);     push_back(check);     }     }     };     typedef std::map<unsigned int /* 4*Height */, CitySkyLine > City;     typedef std::vector< SkyScraper > CityAll;     bool compareHeight(const SkyScraper& a, const SkyScraper& b) { return a.bldHeight < b.bldHeight; }     bool compareIndex(const SkyScraper& a, const SkyScraper& b) { return a.bldIndex < b.bldIndex; }     unsigned long operator-(const SkyScraper& a, const SkyScraper& b)     {     DEBUG_LVL(1, std::cout << "a.idx=" << a.bldIndex << ", b.idx=" << b.bldIndex << ", a.hgt=" << a.bldHeight << ", b.hgt=" << b.bldHeight);     unsigned int bldgDistance = (a.bldIndex > b.bldIndex) ? (a.bldIndex - b.bldIndex) : (b.bldIndex - a.bldIndex);     if(bldgDistance > halfLen) bldgDistance = nSkyscrapers - bldgDistance;     DEBUG_LVL(1, std::cout <<", bldDist="<< bldgDistance << std::endl);     return a.bldHeight+b.bldHeight+bldgDistance;     }     void printCity(const City& city)     {     int lev=0;     std::cout << "#######start########" << std::endl;     for(City::const_iterator iter=city.begin(); iter != city.end(); iter++,lev++)     for(CitySkyLine::const_iterator blg=iter->second.begin(); blg != iter->second.end(); blg++)     std::cout <<"level="<<lev<< ", blg.idx="<< blg->bldIndex << ", blg.hgt=" << blg->bldHeight << std::endl;     std::cout << "#######end########" << std::endl;     }     void printCity(const CityAll& cityAll)     {     std::cout << "*********start*********" << std::endl;     for(CityAll::const_iterator blg=cityAll.begin(); blg != cityAll.end(); blg++)     std::cout << "*blg.idx="<< blg->bldIndex << ", blg.hgt=" << blg->bldHeight << std::endl;     std::cout << "*********end*********" << std::endl;     }     int main()     {     TIMER(time_t startTime=time(NULL));     TIMER(std::cerr<<"start ="<<startTime<<std::endl);     unsigned int arrIdx=0;     int readSize;     char input[1000000];     unsigned int iii=0, prevSize;     unsigned long height, minNextHeight;     readSize = read(0, input, sizeof(input)-1);     input[readSize]='\0';     for (nSkyscrapers = 0; input[arrIdx] >= '0'; ++arrIdx) nSkyscrapers = nSkyscrapers * 10 + (input[arrIdx] - '0');     for (;arrIdx<readSize && input[arrIdx] < '0'; ++arrIdx);     halfLen = nSkyscrapers/2;     quatLen = nSkyscrapers/4;     City city;     minNextHeight=0;     while(iii<nSkyscrapers)     {     height = 0;     for (; arrIdx<readSize && input[arrIdx] >= '0'; ++arrIdx) height = height * 10 + (input[arrIdx] - '0');     if(arrIdx==readSize)     {     readSize = read(0, input, sizeof(input)-1);     if(readSize < 0) exit(1);     input[readSize]='\0';     arrIdx=0;     for (; arrIdx<readSize && input[arrIdx] >= '0'; ++arrIdx) height = height * 10 + (input[arrIdx] - '0');     }     for (;arrIdx<readSize && input[arrIdx] < '0'; ++arrIdx);     DEBUG_LVL(2, std::cout << ">>>>height="<<height<<", minNextHeight="<<minNextHeight<<std::endl);     if(height>minNextHeight)     {     city[(height<<1)/nSkyscrapers].check_push_back(iii,height);     prevSize = city.size();     if( city.size() > 2 )     {     city.erase(city.begin());     }     minNextHeight = ((nSkyscrapers * (city.begin()->first))>>1);     }     iii++;     }     TIMER(time_t endTime=time(NULL));     TIMER(std::cerr<<"read end="<<endTime<<", runTime="<<endTime-startTime<<std::endl);     DEBUG_LVL(3, printCity(city));     unsigned int diffIdx;     City::iterator iter;     for(iter=city.begin(); iter != city.end(); iter++)     {     CitySkyLine& inLevel = iter->second;     diffIdx = nSkyscrapers + inLevel.front().bldIndex - inLevel.back().bldIndex;     while( inLevel.size()>2     && diffIdx < abs( long(inLevel.front().bldHeight) - inLevel.back().bldHeight) )     {     if(inLevel.front().bldHeight > inLevel.back().bldHeight)     {     inLevel.pop_back();     }     else     {     inLevel.pop_front();     }     diffIdx = nSkyscrapers + inLevel.front().bldIndex - inLevel.back().bldIndex;     }     }     DEBUG_LVL(3, printCity(city));     iter=city.begin();     CityAll cityAll;     if(city.size()==1)     {     cityAll = CityAll( iter->second.begin(), iter->second.end() );     }     else     {     City::iterator iter2 = iter;     iter2++;     cityAll.resize(iter->second.size()+iter2->second.size());     std::merge(iter->second.begin(), iter->second.end(), iter2->second.begin(),iter2->second.end(), cityAll.begin(), compareIndex);     }     DEBUG_LVL(3, printCity(cityAll));     iii=0;     CityAll::iterator iterAll = cityAll.begin();     unsigned long maxDistance=0, tmpDistance;     while(iterAll != cityAll.end())     {     CityAll::iterator iterAll2 = iterAll;     iterAll2++;     while(iterAll2 != cityAll.end())     {     if( maxDistance < (tmpDistance=(*iterAll) - (*iterAll2)) ) maxDistance = tmpDistance;     iterAll2++;     }     iterAll++;     }     std::cout<<maxDistance<<std::endl;     TIMER(endTime=time(NULL));     TIMER(std::cerr<<"cal end ="<<endTime<<", runTime="<<endTime-startTime<<std::endl);     return 0;     } 
#include<bits/stdc++.h> #define ull unsigned long long #define ll long long #define mp make_pair #define A first #define B second #define MIN (1<<31) #define MAX (1<<31) - 1 #define MOD 1000000007 #define scanint(n) scanf("%d",&n) using namespace std; #define N 1001 int A[N][N];	//matrix int dp[N][N]; int n,m; int calc(int x,int y){	//recursively calculates the sum of the sub-rectangle {(1,1) to (x,y)} 	if(x<1 || y<1)	dp[x][y]=0; 	if(dp[x][y]!=-1)	return dp[x][y]; 	dp[x][y] = calc(x-1,y) + calc(x,y-1) - calc(x-1,y-1) + A[x][y]; 	return dp[x][y]; } int main(){ 	for(int i=0;i<N;i++){ 		for(int j=0;j<N;j++)	dp[i][j]=-1; 	} 	scanint(n); 	scanint(m);//input the dimensions 	for(int i=1;i<=n;i++){ 		for(int j=1;j<=m;j++){ 				scanint(A[i][j]);	//take input 		} 	} 	dp[1][1]=A[1][1];	//base case 	for(int i=0;i<max(n,m);i++)	dp[i][0]=0; 	for(int i=0;i<max(n,m);i++)	dp[0][i]=0; 	int c,x1,y1,x2,y2; 	int ans=0; 	calc(n,m); 	scanint(c);	//no of queries 	for(int i=0;i<c;i++){ 		scanint(x1); 		scanint(y1); 		scanint(x2); 		scanint(y2);//input of coordinates 		ans = dp[x2][y2] - dp[x1-1][y2] - dp[x2][y1-1] + dp[x1-1][y1-1]; 		printf("%d\n",ans);	//output of the answer 	} 	return 0; }
#include <bits/stdc++.h> using namespace std; long long int sum(long long int x) { 	long long int s=0,t; 	while(x) 	{ 		t=x%10; 		if(t&1) 			s+=t; 		else 			s+=2*t; 		x/=10;	 	} 	return s%10; } long long int ssum(long long int x) { 	long long int s=0; 	while(x%10!=0) 		{ 			x--; 			s+=sum(x); 			//x--; 		} 	long long int k=x/10; 	s+=k*45; 	return s; } int main() { 	long long int t,a,b,ans; 	cin>>t; 	while(t--) 	{ 		cin>>a>>b; 		ans=ssum(b+1)-ssum(a); 		cout<<ans<<"\n"; 	} 	return 0; } 
#include <iostream> #include<queue> #include<vector> #include<algorithm>  using namespace std;  struct node { 	int n; 	vector<int> ds; 	bool visited; };  int main() { 	// your code goes here 	int N,L,i,j; 	cin>>N>>L; 	int d[N][N]; 	for(i=0;i<N;i++) 		for(j=0;j<N;j++) 			cin>>d[i][j]; 	 	queue<node*> q; 	vector<node> v; 	vector<int> w,x; 	 	node temp; 	node* temp2; 	temp.visited=false; 	 	for(i=0;i<N;i++) 	{ 		temp.n=i; 		temp.ds.push_back(0); 		v.push_back(temp); 	} 	 	q.push(&v[0]); 	 	while(!q.empty()) 	{ 		temp2=q.front(); 		q.pop(); 		 		if(temp2->visited==false) 		{ 			temp2->visited=true; 			 			for(i=0;i<N;i++) 			{ 				if(i!=temp2->n) 				{ 					if(v[i].visited==false) 					{ 						q.push(&v[i]); 						 						w=v[i].ds; 						x=temp2->ds;  						for(j=0;j<w.size();j++) 							temp2->ds.push_back(w[j]+d[i][temp2->n]);  						for(j=0;j<x.size();j++) 							v[i].ds.push_back(x[j]+d[i][temp2->n]); 					} 				} 			} 		} 	} 	 	if(find(v[N-1].ds.begin(),v[N-1].ds.end(),L-d[0][N-1])==v[N-1].ds.end()) 		cout<<"IMPOSSIBLE"; 	else 		cout<<"POSSIBLE"; 	return 0; }
#include <bits/stdc++.h>  using namespace std;  #define pb push_back #define mp make_pair  #define ALL(x) (x).begin(),(x).end() #define CLR(a,b) memset(a,b,sizeof(a)) #define REPN(x,a,b) for (int x=a; x<b;++x) #define REP(x,b) REPN(x, 0, b)  const int MAX = 125010; const int HB = 7; const int MOD = 1000000009; const int C = 10; int powers[MAX];  char P[MAX], Q[MAX]; int n; int hashes[2][11][MAX]; //hashes of P int PS[11], QS[11]; //hashes of substrings bool vis[11]; string Perm; //here we save our permutations int character_hashes[2][C + 1];  void initHash(char * S, int M[][MAX]) {     REP(i, 10) M[i][0] = 0;     REP(i, n) {         REP(j, 10) {             M[j][i+1] = M[j][i];             if (S[i] == 'a'+j) {                 M[j][i+1] += powers[i];                 if (M[j][i+1] >= MOD) M[j][i+1] -= MOD;             }         }     } }  int get_hash(int n, int hashes[], int l, int r) {   return ((hashes[r] - hashes[l - 1] + MOD) * 1ll * powers[n - r]) % MOD; }   bool check_substrings(int n, int l_1, int r_1, int l_2, int r_2) {   for (int i = 0; i < C; i++) {     character_hashes[0][i] = get_hash(n, hashes[0][i], l_1, r_1);     character_hashes[1][i] = get_hash(n, hashes[1][i], l_2, r_2);   }    sort(character_hashes[0], character_hashes[0] + C);   sort(character_hashes[1], character_hashes[1] + C);    for (int i = 0; i < C; i++) {     if (character_hashes[0][i] != character_hashes[1][i]) {       return false;     }   }    return true; }  bool character_is_taken[C + 1];  int eval(int px, int qx, char permutation[] ) {     int l = 1, r = min(n-px+2, n-qx+2);     while (l + 1 < r) {         int m = (l + r)/2;         if (check_substrings(n, px, px+m-1, qx, qx+m-1)) l = m;         else r = m;     }      int prefix_length = l;         memset(character_is_taken, false, sizeof(character_is_taken));       for (int i = 0; i < C; i++) {         int hash = get_hash(n, hashes[0][i], px, px + prefix_length - 1);         for (int j = 0; j < C; j++) {           if (!character_is_taken[j] && hash == get_hash(n, hashes[1][j], qx, qx + prefix_length - 1)) {             character_is_taken[j] = true;             permutation[i] = 'a' + j;             break;           }         }       }        permutation[C] = '\0';     return l; }  char resulting_permutation[11];  int main() {      powers[0] = 1;     REPN(i, 1, MAX) {         powers[i] = (powers[i-1]*1ll*HB)%MOD; //        printf("%d\n", powers[i]);     }      int T, q;     scanf("%d", &T);      REP(tc, T) {         scanf("%d %d", &n, &q);          scanf("%s", P);         scanf("%s", Q);          initHash(P, hashes[0]);         initHash(Q, hashes[1]);          REP(i, q) {             int px, qx;             scanf("%d %d", &px, &qx);             printf("%d %s\n", eval(px, qx, resulting_permutation), resulting_permutation);         }     }      return 0; } 
#include<iostream> #include<cstdio>  using namespace std; long long int num(long long int a) {     if(a==0)     {         return 0;     }     return(num(a/10)+a%10); } int main() {     long long int t,a,b;     scanf("%lld",&t);     while(t--)     {         scanf("%lld %lld",&a,&b);         long long int ans = num(a)*num(b);         while(ans>=10)         {             ans=num(ans);         }         printf("%lld\n",ans);     }     return(0); } 
#include<stdio.h>  int main() {     long long t,c,i;     int n;     scanf("%lld",&t);      while(t--)     {         long int sum=0;         scanf("%d %lld",&n,&c);         int a[n];         for(i=0;i<n;i++)        {            scanf("%d",&a[i]);            sum+=a[i];        }         if(c>=sum)         {             printf("Yes\n");         }         else if(c<=sum)         {             printf("No\n");          }       }     return 0; } 
#include<iostream> #include<cmath> #include<algorithm> #include<fstream> using namespace std; int main() { 	int t; 	long long int n,x; 	cin>>t; 	while(t--) 	{ 		signed long long int i; 		int flag=0; 		cin>>n; 		for(i=1;i<n;++i) 		{ 			//bruteforce on one side of the triangle 			x=(signed long long int)sqrt(n*n-i*i); 				//the second side of the right angled triangle where i is the first side 			if(x*x+i*i==n*n){flag=1;break;} 				//if this second side is indeed an integer.. it satisfies the pythagoras theorum 			//if one such pair x,i is found then we stop the bruteforce and indicate that the solution is found 		} 		if(flag)cout<<"YES\n"; 		else cout<<"NO\n"; 	} }
/*  * nunnally.c  *   * Copyright 2014 sudhakar <sudhakar@sudhakar-Presario-CQ62-Notebook-PC>  *   * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *   * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *   * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,  * MA 02110-1301, USA.  *   *   */   #include <stdio.h> #include <math.h> #include<iostream> #include<map> #include<vector> #include<cstring> #include<cmath> #include<algorithm> #include<cstdio> #include<fstream> using namespace std;  unsigned long long int tst,i,j,k,s,n,mod=1000000007;   int main(int argc, char **argv) { //freopen("TEST_5.txt", "r", stdin); //freopen("OUT_5.txt", "w", stdout);   	scanf("%llu",&tst); 	while(tst--){ 		s=0; 	scanf("%llu",&n); 	 	for(i=2;i<sqrt(n);++i){ 		if(n%i==0) 		s=s+ ((((i%mod)*(i%mod))%mod) + ((((n/i)%mod)*((n/i)%mod))%mod)); 		s%=mod; 		//printf("%llu %llu ",s,i); 		} 	if(i*i==n) 		{s+=n; s%=mod;} 		printf("%llu\n",s); 	 	} 	 	 	return 0; }  
#include<iostream> #include<cmath>  static unsigned long long int arr[]={0,1,4,27,256,3125,46656,823543,16777216,387420489ULL,10000000000ULL};  using namespace std;  int main(){ unsigned long long int t,N,A,B,K,i,j; 	 	cin>>t; 	while(t--){ 		cin>>A>>B; 		 		N = arr[A]-((A-1)*B); 		j=N; 		cout<<N; 		for(i=1;i<=A;i++){ 			j-=B; 			j-=(j/A); 			} 			K=j; 		cout<<" "<<K<<endl; 		 		} 		 	} 
#include<iostream> #include<cstdlib> using namespace std; long long gcd(long long a,long long b) { 	if(b==0) 	return a; 	else 	return gcd(b,a%b); } int main() { 	long long t; 	cin>>t; 	while(t--) 	{ 		long long n,m; 		cin>>n>>m; 		printf("%lld\n",gcd(n,m)); 	} 	return 0; }
#include <stdio.h> #include <string.h> #include <stdlib.h> #include <math.h> #include <assert.h> long long fun(long long x){     long long s=0;     while(x){         s=s+x%10;         x = x/10;     }     if(s>9)         s=fun(s);     return s; } int gcd(int a,int b){     if(a%b==0)         return b;     else         return gcd(b,a%b); } int main(){     int t;     scanf("%d",&t);     while(t--){         long long a,b,p,c,i;         scanf("%lld %lld %lld %lld",&a,&b,&c,&p);         long long x=a%9,ans=1,count;         while(b>0){             if(b%2==1) ans=(ans*x)%9;                 ans=(ans*ans)%9;             b/=2;         }         p += fun(ans);                    long long j=1,k,l,m;         x = p/c; x--;                ans = x+1;x--;          for(i=2*c;i<=p;i+=c){              l = j+1;              k = (x)/l;  l=0;                              if(l==0){                  k=0;                  for(m=i+c;m<=p;m+=c){                      if(gcd(i,m)!=c)                          k++;                  }              }              ans += x-k;              x--;              j++;                             }           printf("%d\n",ans);          }     return 0; } 
#include <bits/stdc++.h> using namespace std; const int mx = 10000001; const int nx = 100001; int odd[nx]; long long val[nx]; bool pr[mx];  void init() {     for (int z = 0; z < mx; pr[z] = 1, ++z);     for (int i = 2; i < mx; ++i) {         if (!pr[i]) continue;         if (i * 1ll * i >= mx) break;         for (int j = i * i; j < mx; pr[j] = 0, j += i);     } }  int main(int argc, char const *argv[]) {     init();     long long a, b;     scanf("%lld%lld", &a, &b);     int n = b - a + 1;     for (int i = 0; i < n; i++) odd[i] = 0, val[i] = i + a;     for (int i = 2; i < mx; i++) {         if (!pr[i]) continue;     	for (long long j = ((a + i  -1) / i) * i; j <= b; j += i) {     		int cnt = 0;             long long idx = j - a;             while ((val[idx] % i) == 0) {                 val[idx] /= i;                 cnt++;             }             cnt % 2 ? odd[idx]++ : odd[idx]--;     	}     }     for (int i = 0; i < n; i++) if (val[i] >= 2) odd[i]++;      int ans = 0;     for (int i = 0; i < n; i++) ans += (odd[i] > 0);     printf("%d\n", ans); 	return 0; } 
#include<bits/stdc++.h> using namespace std; #define ll long long #define f first #define s second #define pb push_back #define mp make_pair #define pii pair<int,int> #define pil pair<int,ll> #define pli pair<ll,int> #define pll pair<ll,ll> #define mod 95676260903887607LL vector<int>adj[100011]; int mn,loc,mark[100011]; vector<int>v; void dfs(int u,int p,int h) {     if(h>mn)     {         mn=h;         loc=u;     }     for(int i=0;i<adj[u].size();i++)         if(adj[u][i]!=p)             dfs(adj[u][i],u,h+1); } int dfs1(int u,int p,int h) {     if(u==loc)     {         v.pb(loc);         return 1;     }     for(int i=0;i<adj[u].size();i++)         if(adj[u][i]!=p)             if(dfs1(adj[u][i],u,h+1)==1)             {                 v.pb(u);                 return 1;             }     return 0; } int dfs2(int u,int p) {     mark[u]=1;     int mx=0;     for(int i=0;i<adj[u].size();i++)     {         if(adj[u][i]!=p&&mark[adj[u][i]]==0)             mx=max(mx,dfs2(adj[u][i],u)+1);     }     return mx; } int main() {     int i,j,n,k,t;     scanf("%d",&t);     while(t--)     {         scanf("%d",&n);         for(i=0;i<=n;i++)             adj[i].clear();         for(i=0;i<=n;i++)             mark[i]=0;         for(i=1;i<n;i++)         {             int p;             scanf("%d",&p);             adj[p].pb(i);             adj[i].pb(p);         }         mn=-1;         dfs(0,-1,0);         mn=-1;         int loc1=loc;         v.clear();         dfs(loc,-1,0);         dfs1(loc1,-1,0);         assert(v[0]==loc);         assert(v.back()==loc1);         assert(v.size()==mn+1); //        printf("%d\n",mn+1); //        for(i=0;i<v.size();i++) //            printf("%d ",v[i]); //        printf("\n");         int y,mx=1000111,mn1=1000000;         for(i=0;i<v.size();i++)         {             if(i==v.size()-1)                 y=dfs2(v[i],-1);             else                 y=dfs2(v[i],v[i+1]);            // cout<<v[i]<<" "<<y<<endl;             if(y==i)                 mn1=i;             if(y==mn-i)                 mx=min(mx,i);         }         printf("%d\n",mx-mn1+1);     }     return 0; } 
    #include<bits/stdc++.h>     using namespace std;     int compare(int a,int b){         if(a>b){             return 1;         }         else{             return 0;         }     }     int main(){         int n,a,m;             int r[105]={0};             int c[105]={0};             int d1=0,d2=0;             cin>>n;             for(int i=1;i<=n;i++){                 for(int j=1;j<=n;j++){                     cin>>a;                     if(i==j){                         d1+=a;                     }                     if((i+j)==n+1){                         d2+=a;                     }                     r[i]+=a;                     c[j]+=a;                 }             }             sort(r,r+n+1,compare);             sort(c,c+n+1,compare);             if(d1>d2){                 m=d1;             }             else{                 m=d2;             }             int m1,m2,m3;             m1=r[0];             m2=c[0];             m3=m;             int result=m1>m2&&m1>m3?m1:m2>m3?m2:m3;             cout<<result<<endl;         return 0;     }      
#include<iostream> #include<math.h>  using namespace std; int count(int); int main() {  int i,j=0,k=0,l=0;  cin>>i;   while(i>0)  {      j=j+i%10;      i=i/10;      l=j;  }   while(j>0)  {      k=k+j%10;      j=j/10;      l=k;  }   while(k>0)  {      l=0;      l=l+k%10;      k=k/10;   }  cout<<l<<endl;     return 0; }   
using namespace std; #include <cmath> #include <cstdio> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <string> #include <vector> #include <iostream> #include <sstream> #include <algorithm> #define all(c) (c).begin(),(c).end() #define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) typedef long long ll;  typedef pair<int,int> pii;  #define FOR(i,n) for (int i = 0; i < n; i++) #define SZ(x) ((int)x.size()) #define PB push_back #define MP make_pair #define sf(x) scanf("%d",&x) #define pf(x) printf("%d\n",x) #define split(str) {vs.clear();istringstream ss(str);while(ss>>(str))vs.push_back(str);} #define PI 3.141592653589793 int main() { 	int t; 	sf(t); 	while(t--) 	{ 		int n,m,k; 		sf(n); sf(m); sf(k); 		vector<int> v; 		FOR(i,n) 		{ 			string a; 			cin>>a; 			int c = 0; 			FOR(j,a.size()) 				if(a[j] == '*')c++; 			v.PB(c); 		} 		sort(all(v)); 		int i = 0; 		while(k>0) 		{ 			if(v[i] > m/2) 				break; 			v[i] = m-v[i]; 			k--; 			i++; 			if(i == v.size())break; 		} 		int minval = 1000000; 		if(k%2 != 0) 		{ 			FOR(i,v.size()) 				minval = min(minval, v[i] - (m-v[i])); 		} 		if(minval == 1000000) minval = 0; 		int ans = 0; 		FOR(i,v.size()) 			ans += v[i]; 		cout<<ans - minval<<endl; 	} }
#include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<map> #include<set> #include<queue> #include<utility> #include<cstring> #include<cmath> #define LL long long int #define mod 1000000007 #define vi vector<int> #define vvi vector < vi > #define pii pair<int,int> #define all(c) c.begin(),c.end() #define sf(x) scanf("%d",&x); #define sf2(x,y) scanf("%d%d",&x,&y); #define mem(a,val) memset(a,val,sizeof(a)) #define nl printf("\n"); #define pb push_back #define mp make_pair //#define f first //#define s second #define cf I64 using namespace std; int main() {	int t,i,j,n,m,ans,sum,a[105],x; 	cin>>t; 	while(t--) 	{	cin>>n; 		sum=0; 		for(i=0;i<n;i++)  		{	cin>>a[i]; 			sum+=a[i]; 		} 		if(sum%n!=0) cout<<"-1\n"; 		else 		{	sum=sum/n; 			x=0; 			for(i=0;i<n;i++) 				x+=abs(sum-a[i]); 			cout<<x<<endl;	 		} 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; int main() {     int t;     scanf("%d",&t);     while(t--)     {         int n,i,l,j,c,mx,k;          scanf("%d",&n);          int a[n],b[n];         for(i=0;i<n;++i)             scanf(" %d %d",&a[i],&b[i]);         if(n==1)         {             printf("1\n");             continue;         }         mx=1;         for(i=0;i<n;++i)         {             float s[n-i-1];             k=0;             for(j=i+1;j<n;++j)             {                 s[k++]=(((float)b[j]-(float)b[i])/((float)a[j]-(float)a[i]));             }          //   for(int yo=0;yo<k;yo++)            //     printf("%lf ",s[yo]);             //puts("");             sort(s,s+n-1-i);            //  for(int j=0;j<n-1-i;++j)              //   printf("%d ",s[j]);             int  c=1;             for(j=0;j<n-1-i;++j)             {                 if(s[j]==s[j+1])                     c++;                 else                 {                     if(c>mx)                         mx=c;                     c=1;                 }             }             //printf("max=%d\n",mx);         }         printf("%d\n",mx+1);     }     return 0; } 
#include<bits/stdc++.h> using namespace std; long int findhcf(long int a,long int b) { 	if(b%a==0) return a; 	return findhcf(b%a,a); } int main() { 	int t; 	long int x1,y1,x,y; 	cin>>t; 	while(t--) 	{ 		cin>>x1>>y1>>x>>y; 		x=fabs(x-x1); 		y=fabs(y-y1); 		if(x==0||y==0) {cout<<"0\n"; continue;} 		long int hcf=(x<y?findhcf(x,y):findhcf(y,x)); 		cout<<x+y-hcf<<"\n";		 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {         int n,ans=0,x;         cin>>n;         string s[1000],st="";         for(int i=0;i<n;i++)         {             cin>>s[i];         }         cin>>x;         for(int i=0;i<n;i++)         {             //ans=max(ans,count(s[i].begin(),s[i].end(),x));             char ch=x+'0';             int cnt=0;             for(int j=0;s[i][j];j++)             {                 if(s[i][j]==ch)                     cnt++;             }             if(cnt>ans)             {                 ans=cnt;                 st=s[i];             }         }         cout<<st<<endl;     }     return 0; } 
#include<bits/stdc++.h> #define gc getchar typedef long long int ll; using namespace std; ll read_int() { char c = gc(); while(c<'0' || c>'9') c = gc(); ll ret = 0; while(c>='0' && c<='9') { ret = 10 * ret + c - 48; c = gc(); } return ret; } bool isSubsetSum(ll a[], ll n, ll sum) {    if (sum == 0)      return true;    if (n == 0 && sum != 0)      return false;    if (a[n-1] > sum)      return isSubsetSum(a, n-1, sum);    return isSubsetSum(a, n-1, sum) || isSubsetSum(a, n-1, sum-a[n-1]); } int main() {     ll t,n,k,i;     cin>>t;     while(t--)     {         cin>>n>>k;         ll a[n+1];         for(i=0;i<n;i++)         {             cin>>a[i];         }         bool r=isSubsetSum(a,n,k);         if(r==true)             cout<<"YES\n";         else             cout<<"NO\n";     }     return 0; } 
// Tapan Sahni #include <algorithm> #include <iostream> #include <iterator> #include <numeric> #include <sstream> #include <fstream> #include <cassert> #include <climits> #include <cstdlib> #include <cstring> #include <string> #include <cstdio> #include <vector> #include <cmath> #include <queue> #include <deque> #include <stack> #include <list> #include <iomanip> #include <map> #include <complex> #include <set>  #define mod 1000000007  using namespace std; typedef long long LL;  const int N = 1000 + 10; const int inf = 1000000000;  int a[N]; int fdp[N][N] , fdp1[N][N]; vector <pair <int ,int> > v; int main() {   ios::sync_with_stdio(false) ; cin.tie(nullptr);   int t;   cin >> t;   while(t--) {     int n , k;     cin >> n >> k;     for(int i = 1; i <= n; i++) cin >> a[i];     int lis = 0;     for(int i = 0; i <= n + 1; i++)       for(int j = 0; j <= n + 1; j++){         fdp[i][j] = inf;         fdp1[i][j] = -1;       }     fdp[0][0] = 0;     for (int i = 1; i <= n; i++) {       for (int j = 0; j <= n; j++) {         fdp[i][j] = fdp[i - 1][j];         if (j && fdp[i - 1][j - 1] < a[i])           fdp[i][j] = min(fdp[i][j], a[i]);         if (fdp[i][j] != inf)           lis = max(lis, j);       }     }     fdp1[n + 1][0] = inf;     for (int i = n; i >= 1; i--){       for (int j = 0; j <= n; j++){         fdp1[i][j] = fdp1[i + 1][j];         if (j && fdp1[i + 1][j - 1] > a[i])           fdp1[i][j] = max(fdp1[i][j], a[i]);       }     }     LL ans = 0;     int r;     for (int i = 1; i < n; i++){       r = -1;       for (int j = 0; j <= lis; j++){         int j1 = lis - j;         if (fdp1[i + 1][j1] - fdp[i][j] > 1) {           if (fdp1[i + 1][j1] > k) {             if (fdp[i][j] >= r)               ans += max(k - fdp[i][j], 0);             else               ans += max(k - r + 1, 0);             break;           }           if (fdp[i][j] >= r)             ans += max(fdp1[i + 1][j1] - fdp[i][j] - 1, 0);           else             ans += max(fdp1[i + 1][j1] - r, 0);           r = fdp1[i + 1][j1];         }       }     }     ans += max(k - fdp[n][lis], 0);     ans += max(min(k, fdp1[1][lis] - 1), 0);     cout << ans << endl;   }      return  0; } // Never Quit 
#include<bits/stdc++.h> //#define inf 100000000 #define ll  long long #define pb push_back #define s(n) scanf("%d",&n) #define sl(n) scanf("%lld",&n)  #define p(n) printf("%lld\n",n) #define rep(i,a,n) for(i=a;i<=n;i++) #define vi vector<int> #define vii vector< vector<int> > #define vpii vector< pair<int,int> > #define mii map<int,int> #define pb push_back #define inf 1000000000LL #define mp make_pair #define MOD 1000000007LL #define N 1000007 using namespace std; ll powmod(long long a, long long b, long long c) {     ll ret=1LL;      while(b)     {         if(b & 1)             ret = (ret*a)%c;         a=(a*a)%c;          b>>=1;     }     return (ret)%c; } ll minverse(ll a,ll mod1) {     if(a==0LL)         return 1LL;     return powmod(a,(1LL*(mod1-2LL)),mod1)*1LL; } string s1; struct tree {  ll ans;  ll l;  ll r;  int f; }node[4*80000+5]; void build_tree(int idx,int l,int r) {  if(l==r)  {    if(s1[l]=='L')    {     node[idx].l=1;     node[idx].r=0;     node[idx].ans=0;    }    else    {       node[idx].l=0;     node[idx].r=1;     node[idx].ans=0;    }    node[idx].f=0;  }  else  {   int mid=(l+r)/2;   build_tree(2*idx+1,l,mid);   build_tree(2*idx+2,mid+1,r);   node[idx].l=node[2*idx+1].l+node[2*idx+2].l;   node[idx].r=node[2*idx+1].r+node[2*idx+2].r;   node[idx].ans=node[2*idx+1].ans+node[2*idx+2].ans+node[2*idx+1].r*node[2*idx+2].l;   node[idx].f=0;  } } void update(int idx,int l,int r,int ql,int qr) {  if(node[idx].f==1)  {   ll val1=node[idx].l;   ll val2=node[idx].r;   ll tot=(ll)(r-l+1)*(r-l)/2;   swap(node[idx].l,node[idx].r);   node[idx].ans=tot-node[idx].ans-(val1)*(val1-1)/2-(val2)*(val2-1)/2;   node[idx].f=0;   if(l<r)   {    node[2*idx+1].f=(node[2*idx+1].f)^1;    node[2*idx+2].f=(node[2*idx+2].f)^1;   }  }  if(ql>r||qr<l||l>r)  return;  if(ql<=l && qr>=r)  {    ll val1=node[idx].l;     ll val2=node[idx].r;    ll tot=(ll)(r-l+1)*(r-l)/2;    swap(node[idx].l,node[idx].r);    node[idx].ans=tot-node[idx].ans-(val1)*(val1-1)/2-(val2)*(val2-1)/2;    if(l<r)    {    node[2*idx+1].f=(node[2*idx+1].f)^1;    node[2*idx+2].f=(node[2*idx+2].f)^1;    }  }  else  {    int mid=(l+r)/2;    update(2*idx+1,l,mid,ql,qr);    update(2*idx+2,mid+1,r,ql,qr);    node[idx].l=node[2*idx+1].l+node[2*idx+2].l;   node[idx].r=node[2*idx+1].r+node[2*idx+2].r;   node[idx].ans=node[2*idx+1].ans+node[2*idx+2].ans+node[2*idx+1].r*node[2*idx+2].l;  } } int main() {  int n,i,n1,n2; s(n); cin>>s1; build_tree(0,0,n-1); /*cout<<node[0].l<<" "<<node[0].r<<" "<<node[0].ans<<endl;  cout<<node[1].l<<" "<<node[1].r<<" "<<node[1].ans<<endl;  cout<<node[2].l<<" "<<node[2].r<<" "<<node[2].ans<<endl;*/ int q; cin>>q; while(q--) {  s(n1);s(n2);  update(0,0,n-1,n1,n2);  /*cout<<node[0].l<<" "<<node[0].r<<" "<<node[0].ans<<" "<<node[0].f<<endl;  cout<<node[1].l<<" "<<node[1].r<<" "<<node[1].ans<<" "<<node[1].f<<endl;  cout<<node[2].l<<" "<<node[2].r<<" "<<node[2].ans<<" "<<node[2].f<<endl;*/  p(node[0].ans); } } 
#include <cstdio> #include <cstdlib> #include <algorithm> #include <queue> #include <cmath> #include <cstring> #include <iostream> #include <stack> #include <map> #include <vector> #include <utility> #include <set>  #define MOD (1000000007) #define MAXINT 1e9 #define EPS (1e-9) #define mp   make_pair #define pb   push_back #define fi   first #define se   second #define pii  pair<int,int>  #define pll  pair<long long,long long>   using namespace std; typedef long long int ll;   ll gcd(ll a,ll b) { 	if(a<b)	return gcd(b,a); 	if(b==0)	return a; 	return gcd(b,a%b); }  int main() { 	ll a,b,g,test,n; 	cin>>test; 	while(test--) 	{ 		cin>>n; 		a=(n*(n-1)); 		b=8; 		g=gcd(a,b); 		a=a/g; 		b=b/g; 		cout<<a<<"/"<<b<<endl; 	} 	return 0; }
#include<stdio.h> #define MOD 1000000007 int fac[2000001]; int modpow(int b){ 	long long res=1,base=b; 	int exp=MOD-2; 	while(exp>0){ 		if(exp&1){ 			res=res*base; 			if(res>=MOD)res%=MOD; 		} 		base=base*base; 		if(base>=MOD)base%=MOD; 		exp>>=1; 	} 	return res; } void init() { 	int i; 	long long temp; 	fac[0]=1; 	for(i=1;i<2000001;i++) 	{ 		temp=fac[i-1]; 		temp*=i; 		if(temp>=MOD)temp%=MOD; 		fac[i]=temp; 	} } int main() { 	int t,n,ans; 	long long num,den; 	init(); 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d",&n); 		num=fac[2*n-1]; 		den=fac[n-1]; 		den*=den; 		if(den>=MOD)den%=MOD; 		num*=modpow(den); 		if(num>=MOD)num%=MOD; 		printf("%lld\n",num); 	} 	return 0; }  
#include<iostream> #include <string.h> #include<math.h> #include <algorithm> #include<stdio.h>  using namespace std;  bool p[1000100]; int primes[100000];  int main() {int k=0,i,j;  long long a,b,z,number,x,y;     for (i=2;i<1000000;i++)  {      if (p[i]==0)      {                primes[k++]=i;                       for (j=i+i;j<1000000;j+=i)                       p[j]=1;      }   }   long long u=k;  int t;  long long product,check,exp,temp;  scanf("%d",&t);    while(t--)  {   scanf("%lld %lld %lld",&x,&y,&z);             k=0;   number=z;   while(z>1 && primes[k]*primes[k]<=number && k<u)   {        a=0;     while(z%primes[k]==0)                       {                                      a++;                                            z/=primes[k];                                                                 }     k++;    }           if (z==1)   {   check=primes[--k];            }           else   {       check=z;       a=1;   }                product=x*y;           exp=0;          temp=check;      while(product)     {     exp+= product/temp;            product=product/temp;           }                   printf("%lld\n",exp/a);            }                   return 0; }
#include<iostream> #include<vector> using namespace std;   int main() { 	int n,q; 	scanf("%d %d",&n,&q); 	 	int sum=0; 	vector<int> array(n); 	for(int i=0;i<n;i++) 	{ 		scanf("%d",&array[i]); 		sum+=array[i]; 	} 	 	vector<long long> Sum(sum+1); 	 	Sum[0]=1; 	 	for(int i=0;i<array.size();i++) 	{ 		for(int last=sum,first=sum-array[i];first>=0;first--,last--) 			Sum[last]|=Sum[first]<<1; 	} 	 	while(q--) 	{ 		int s,k; 		scanf("%d %d",&s,&k); 		if(s<Sum.size()&&Sum[s]&(((long long)1)<<k)) 			printf("YES"); 		else 			printf("NO"); 		printf("\n"); 	} 	 }
#include<bits/stdc++.h> using namespace std; #define ll long long int main() {     ll t,n,maxi,i,flag;     scanf("%lld",&t);     while(t--)     {         i=2;         flag=0;         scanf("%lld",&n);         while(n!=0)         {             if(n%i!=0)                 i++;             else             {                 while(n%i==0)                 {                     maxi=n;                 n=n/i;                 if(n==1)                 {                     printf("%lld\n",maxi);                     flag=1;                     break;                 }                 }                 if(flag)                     break;             }         }     }     return 0; } 
#include <iostream> #include <math.h> #include <stdio.h> #include <iomanip> using namespace std; double logfac[1000001]; int main() {int t; cin>>t; while(t--) {int n,k; cin>>n>>k; k=min(k,n-k); logfac[0]=0; for(int i = 1;i<=k;i++) {logfac[i]=logfac[i-1]+log2((long double)(n-i+1)/((long double)i));}  int z=k;  double ans=0; while(k>=0) {double x=logfac[k]; long double z = pow(2,x+1-n);  ans+=100.0*z;  if(k*z<1e-4) {break;} k--;}  printf("%.1f\n", ans);} return 0;}   
#include <iostream> using namespace std;  int main() {     int t; cin>>t;     while(t--)     {         int n; cin>>n;         int count=1;         for(int i=2;i<=(n/2);i++)         {             if(n%i==0)             count=(count*i)%10000;         }         if(count==0)         cout<<"0000"<<endl;         else         cout<<count<<endl;     }     return 0; } 
#include<bits/stdc++.h>  using namespace std;  #define in(a,x,y) (a>=x && a<=y) #define out(a,x,y) (!in(a,x,y)) #define sz(a) ((int)a.size()) #define repv(i,a) for(int i=0;i<sz(a);i++) #define revv(i,a) for(int i=sz(a)-1;i>=0;i--) #define rep(i,a,b) for(int i=a;i<=b;i++) #define rev(i,a,b) for(int i=a;i>=b;i--) #define all(a) a.begin(),a.end() #define pb push_back  #define AND(a,b) ((a) & (b)) #define OR(a,b) ((a)|(b)) #define XOR(a,b) ((a) ^ (b)) #define xx first #define yy second #define mp make_pair #define sqr(x) ((x)*(x)) #define sqrt(x) sqrt(1.0*(x))  #define LB(a,x) (lower_bound(all(a),x)-a.begin()) //  first element in the range [first,last) which does not compare less than val. #define UB(a,x) (upper_bound(all(a),x)-a.begin()) //  first element in the range [first,last) which compares greater than val. #define forit(it, s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it++) #define left nokol_left #define right nokol_right #define countbit(x) __builtin_popcountll((ll)x) #define PQ priority_queue #define FAST ios_base::sync_with_stdio(0);cin.tie(0); #define Unique(store) store.resize(unique(store.begin(),store.end())-store.begin()) #define READ(f) freopen(f, "r", stdin) #define WRITE(f) freopen(f, "w", stdout)  typedef long long ll; typedef unsigned int uint; typedef unsigned long long ull; typedef pair<int,int> pii; typedef pair<long long,long long> pll; typedef vector<int> vi; typedef vector<long long> vll;  template<class T>T __sqr(const T x){return x*x;} template< class T, class X > inline T __pow(T a,X y) {T z=1; rep(i,1,y){z*=a;} return z; } template< class T > inline T gcd(T a,T b) {a=abs(a);b=abs(b); if(!b) return a; return __gcd(b,a%b);} template< class T > inline T lcm(T a,T b) {a=abs(a);b=abs(b); return (a/__gcd(a,b))*b;} inline bool ispow2(int x){return (x!=0 && (x&(x-1))==0);} template<class T>void UpdateMin(T &x,T y){  if(y<x){x=y;}} template<class T>void UpdateMax(T &x,T y){if(x<y){x=y;}} template<class T,class X, class Y > inline T bigmod(T n,X m,Y mod){ull ret=1, a = n%mod ; while(m){ if(m&1)ret=(ret*a)%mod; m>>=1; a=(a*a)%mod; }ret%=mod;return (T)ret;} template<class T, class Y > inline T modinv(T n,Y mod) {return bigmod(n,mod-2,mod);}  template<class T,class X> int getbit(T s,X i) { return (s >> i) & 1; } template<class T,class X> T onbit(T s, X i) { return s | (T(1) << i); } template<class T,class X> T offbit(T s, X i) { return s & (~(T(1) << i)); } template<class T> inline void read(T &n){char c;for (c = getchar(); !(c >= '0' && c <= '9'); c = getchar()); n = c - '0';for (c = getchar(); c >= '0' && c <= '9'; c = getchar()) n = n * 10 + c - '0';}  void extended_euclid(ll a,ll b,ll &x,ll &y){ if(!b){ x = 1 , y = 0  ;  return ;} ll xx,yy; extended_euclid(b,a%b,xx,yy); x = yy; y = xx - (a/b)*yy; } pair<ll, pair<ll, ll> > extendedEuclid(ll a, ll b) { ll x = 1, y = 0; ll xLast = 0, yLast = 1; ll q, r, m, n; while(a != 0) {q = b / a; r = b % a; m = xLast - q * x; n = yLast - q * y; xLast = x, yLast = y; x = m, y = n; b = a, a = r; } return make_pair(b, make_pair(xLast, yLast)); }  const ll mod[]  ={0,1000000007,1000000009,1000000021,1000000033,1000000097,1000000093,1000000097,1000000103}; //const ll base[] ={0,1000003,1000033,1000037,1000039,1000081,1000099,1000117,1000121};  #define pi acos(-1.0) #define eps  1e-12 #define MX   (lmt+20) #define inf  1000000000000000000LL #define MOD  1000000007LL //---------->0123456789123465789 #define lmt  800000  int N,i,j; struct base {     double real, imag;     base(){real=0.0; imag=0.0;}     void clr(){real=0.0; imag=0.0;} } a[MX], b[MX]; void fft (base* a, int n, bool invert); inline base multiply(const base& left, const base& right);  ll cnt[MX] , ans;  void calc_fft(ll x){          int n = 1 , mx = max(N, N);         while (n <  mx )  n <<= 1;         n<<=1;  //        cout<<"N == > "<<n<<endl;          fft(a, n, false);         fft(b, n, false);         for(i=0;i<n;i++){             a[i] = multiply(a[i], b[i]);         }         fft(a, n, true);          rep(i,0,n-1){             cnt[i] += (ll)x * (ll)(a[i].real + .5);         }          return ; }  int  c[MX] , d[MX];  int main() {     int ts , k;     scanf("%d",&ts);      while(ts--){                scanf("%d%d",&N,&k);              memset(c , 0 , sizeof c);             memset(d , 0 , sizeof d);               memset(cnt , 0 , sizeof cnt);              rep(i,0,N-1) scanf("%d",c+i);              rev(i,k-1,0) scanf("%d",d+i);              rep(i,1,3){                 rep(j,1,3){ ll x;                     scanf("%lld",&x);                     // input type                      rep(k,0,4*N){ a[k].clr();b[k].clr(); }                      rep(k,0,N-1){                         a[k].real = (c[k]==i);                         b[k].real = (d[k]==j);                     }                      calc_fft(x);                 }              }               ll ans = inf;               rep(i,k-1,N -1){ // //                cout<<cnt[i]<<" ";                 ans = min(ans , cnt[i]);              } //             cout<<endl;              printf("%lld\n",ans);     }      return 0; }  /* aaaccc caccacaa */  void fft (base* a, int n, bool invert) { 	for (int i=1, j=0; i<n; ++i) 	{ 		int bit = (n >> 1); 		for (; j>=bit; bit>>=1) 			j -= bit; 		j += bit; 		if (i < j) 			swap (a[i], a[j]); 	}  	for (int len=2; len<=n; len<<=1) 	{ 		double ang = 2*pi/len * (invert ? -1 : 1);  		double cs = cos(ang); 		double sn = sin(ang);  		for (int i=0; i<n; i+=len) 		{ 			ll hlen = (len >> 1);  			double wreal = 1; 			double wimag = 0; 			base u;  			base* pa1 = a + i; 			base* pa2 = a + i + hlen;  			for (int j=0; j<hlen; ++j) 			{ 				base& a1 = *pa1++; 				base& a2 = *pa2++;  				u = a1;  				double vreal = a2.real * wreal - a2.imag * wimag; 				double vimag = a2.real * wimag + a2.imag * wreal;  				a1.real += vreal; 				a1.imag += vimag;  				a2.real = u.real - vreal; 				a2.imag = u.imag - vimag;  				double wreal2 = wreal;  				wreal = wreal * cs - wimag * sn; 				wimag = wreal2 * sn + wimag * cs;   			} 		} 	} 	if (invert) 		for (int i= n; i >= 0; --i) 			a[i].real /= n; }  inline base multiply(const base& left, const base& right) { 	base res; 	res.real = left.real * right.real - left.imag * right.imag; 	res.imag = left.real * right.imag + left.imag * right.real;  	return res; } 
#include<iostream> #include<cmath> #include<cstring> #include<cstdio> //#include<conio.h> using namespace std;   #ifndef ONLINE_JUDGE #define getchar_unlocked() getchar() #endif // ONLINE_JUDGE   inline int input(){int n=0,ch=getchar_unlocked();while(ch<48)ch=getchar_unlocked();while(ch>47)n=(n<<3)+(n<<1)+ch-'0',ch=getchar_unlocked();return n;}   void solve(int n) {     double d=(double)(2*n);     d=sqrt(d);     //cout<<d<<endl;     int x=(int)(d+0.5);     printf("%d\n",x); }   int main() {     int t;     cin>>t;     while(t--)     {         int n;         n=input();         solve(n);     }     //getch();     return 0; } 
#include<cstdio> inline void fastRead_int(long long int &x) {     register long long int c = getchar_unlocked();     x = 0;     long long neg = 0;      for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked());      if(c=='-') {         neg = 1;     	c = getchar_unlocked();     }      for(; c>47 && c<58 ; c = getchar_unlocked()) {     	x = (x<<1) + (x<<3) + c - 48;     }      if(neg)     	x = -x; } int main(){ long t; scanf("%ld",&t); while(t--){     long long int p,q;     fastRead_int(p);     fastRead_int(q);     if((p&1)&&(q&1))         printf("B\n");     else         printf("A\n"); } return 0; } 
#include<bits/stdc++.h> #define fr first #define se second using namespace std; int tree[1000005]; pair<int,int> a[1000005]; int m;int n; int visited[1000005]; struct triple {     int x,y,z; }p[1000005]; int marks[100005]; inline void update(int idx,int val){      while(idx<=m && idx>0) {         tree[idx]+=val;         idx+=(idx&-idx);     } } inline int  query(int idx) {     int sum=0;     while(idx>0) {         sum+=tree[idx];         idx-=(idx&-idx);     }     return sum; } bool cmp(struct triple a,struct triple b) {     return a.y<b.y; } int ans[1000000]; int main() {     scanf("%d",&n);     for(int i=1;i<=n;i++) {         scanf("%d",&marks[i]);     }     scanf("%d",&m);     for(int i=1;i<=m;i++) {         int x;         scanf("%d",&x);         a[i].fr=x;         a[i].se=marks[x];     }     int cnt=1;     for(int i=m+1;i<=2*m;i++) {         a[i].fr=a[cnt].fr;         a[i].se=a[cnt].se;         cnt++;     }     m=2*m;     int q;scanf("%d",&q);     for(int i=1;i<=q;i++) {         scanf("%d%d",&p[i].x,&p[i].y);             p[i].y=p[i].x+p[i].y-1;             p[i].z=i;     }     sort(p+1,p+q+1,cmp);     int j=1;     for(int i=1;i<=q;i++) {         while(j<=p[i].y) {             if(!visited[a[j].first]) {                 visited[a[j].first]=j;                 update(j,a[j].second);      //         cout<<query(j)-query(0)<<endl;              }              else {                 update(visited[a[j].first],-a[j].second);                 visited[a[j].first]=j;                 update(j,a[j].second);    //           cout<<query(j)-query(0)<<endl;             }             j++;         }         ans[p[i].z]=query(p[i].y)-query(p[i].x-1); //      cout<<query(p[i].y)<<" "<<query(p[i].x-1)<<endl;     }     for(int i=1;i<=q;i++) {         printf("%d\n",ans[i]);     } } 
#include <iostream> #include <cstdio> #include <algorithm> #include <cstring> #include <string> #include <cctype> #include <stack> #include <queue> #include <list> #include <vector> #include <map> #include <sstream> #include <cmath> #include <bitset> #include <utility> #include <set> #define pi acos(-1.0) using namespace std; typedef long long ll; typedef vector<int> vi; typedef vector<ll> vll; typedef pair<int, int> ii; typedef vector<ii> vii; typedef set<int> si; typedef map<string, int> msi; int a[1000000+1]={0}; int b[1000000+1]={0}; #define mmin(a,b,c) min(a,min(b,c)) int main() { 	string s,t; 	ll p,t1,n; 	cin>>t1; 	while(t1--) 	{ 		cin>>s; 		fill(a,a+1000000+1,0); 		if(s[0]=='L') 		{ 			a[0]=1; 		} 		for(int i=1;i<s.length();i++) 		{ 			a[i]=a[i-1]; 			if(s[i]=='L') 			{ 				a[i]++; 			} 		} 		if(s[s.length()-1]=='L') 		{ 			b[0]=1; 		} 		for(int i=s.length()-1;i>=0;i--) 		{ 			b[i]=b[i+1]; 			if(s[i]=='L') 			{ 				b[i]++; 			} 		} 		vi v; 		ll sum=0; 		for(int i=0;i<s.length();i++) 		{ 			if(s[i]=='O') 			{ 				sum+=(a[i]*b[i]); 			} 		} 		 		cout<<sum<<endl; 	}  return 0;  } 
#include<iostream> #include<string.h> using namespace std;  int abs(int a,int b){ 	if(a>=b){ 		return a-b; 	} 	else{ 		return b-a; 	} 	 }  int main(){ 	int t; 	cin>>t; 	while(t--){ 		char a[1001], b[1001]; 		int x[26]={0}, y[26]={0}; 		cin>>a>>b; 		int l=strlen(a); 		int m=strlen(b); 		for(int i=0; i<l; i++){ 			if(a[i]<'a'){ 				x[a[i]-'A']++; 			} 			else{ 				x[a[i]-'a']++; 			} 			 		} 		for(int i=0; i<m; i++){ 			if(b[i]<'a'){ 				y[b[i]-'A']++; 			} 			else{ 				y[b[i]-'a']++; 			} 		} 		long long int sum=0; 		for(int i=0; i<26; i++){ 			sum+=abs(x[i],y[i]); 		} 			cout<<sum<<endl; 		 	} }
#include<iostream> #include<cstdio> #include<cmath> #include<cstring> #include<stdlib.h> #include<algorithm> #define getcx getchar_unlocked #define pc(x) putchar_unlocked(x); #ifndef ONLINE_JUDGE     #define getcx getchar #endif using namespace std; #define ull unsigned long long int #define lli long long int #define li long int #define ii int #define mod 1000000007 ii A[201][201]; ii b[201][201]; ii mark[201][201]; ii d[] = {-1,0,1}; ii n,m;  inline ii dfs ( ii i, ii j, ii k ) { 	ii val=0; 	for ( ii p=0;p<3;p++ ) 	{ 		for ( ii q=0;q<3;q++ ) 		{ 			if ( i+d[p]>=0 && i+d[p]<n && j+d[q]>=0 && j+d[q]<m ) 			{ 				if ( A[i+d[p]][j+d[q]]==k+1 ) 					val = max(val,dfs(i+d[p],j+d[q],k+1)); 			} 		} 	}  	return val+1;  }  ii main() { 	//your code goes here 	ii t,i,j,ans;  	cin>>t; 	while(t--) 	{ 		cin>>n>>m; 		for ( i=0;i<n;i++ ) 			for ( j=0;j<m;j++ ) 				cin>>A[i][j];  		ans=0; 		for ( i=0;i<n;i++ ) 		{ 			for ( j=0;j<m;j++ ) 			{ 				if ( A[i][j]==0 ) 				{ 					ans = max(ans,dfs(i,j,0)); 					//memset(mark,0,sizeof(mark)); 				} 			} 		} 		printf("%d\n",ans);  	} 	return 0; } 
/* Sab moh maya hai  _._ _..._ .-',     _.._(`)) '-. `     '  /-._.-'    ',/    )         \            '.   / _    _    |             \  |  a    a    /              |  \   .-.                     ;   '-('' ).-'       ,'       ;      '-;           |      .'         \           \    /         | 7  .__  _.-\   \         | |  |  ``/  /`  /        /,_|  |   /,_/   /           /,_/      '`-' */ #include<bits/stdc++.h> using namespace std; typedef long long ll; typedef vector<int> vi; typedef pair<int,int> pii; typedef pair<ll,ll> pll; typedef vector<pii> vpii; typedef unsigned long long llu;  #define debug(x) cerr<<#x<<" "<<x<<endl; #define f first #define s second #define mp make_pair #define pb push_back int main() {     int t,n;     scanf("%d",&t);     while(t--)     {         scanf("%d",&n);         int k=sqrt(n);         if(n&1)             printf("%d\n",n-k);         else             printf("%d\n",k);     }     return 0;  } 
#include <bits/stdc++.h>  using namespace std;  int main() {     unsigned long long int t,d,r,p,num;     scanf("%llu %llu",&t,&d);     while(t--)     {         scanf("%llu %llu",&num,&p);         r=num%d;         if(r==0 || r==1)         {             cout<<r<<endl;         }         else         {             r=pow(r,p);             r=r%d;             printf("%llu\n",r);         }      }     return 0; } 
#include <iostream> using namespace std;  int getbits(int temp){ 	 	int n =0; 	 	while(temp){ 		if(temp%2!=0) 		n++; 		 		temp/=2; 	} 	 	return n; }  int main() { 	// your code goes here 	int n; 	cin>>n; 	 	while(n--){	 	int cnt=0; 		 	int a,b; 	cin>>a>>b; 	 	if(a!=b){ 		cnt = getbits((a^b)); 	} 	 	cout<<cnt<<endl; 	} 	 	return 0; }
#include<bits/stdc++.h> #define pii pair<int,int> #define Min(a,b) ((a<b) ? a:b) #define Max(a,b) ((a > b) ? a:b) #define Swap(a,b) (a=b+a-(b=a)) #define sn(n) scanf("%d",&n) #define schr(n) scanf("%c",&n) #define ss(n) scanf("%s",n) #define p(n) printf("%d",n) #define el putchar("\n"); #define sp putchar('') #define Fill(a,val) memset(a,val,sizeof(a)) #define pb push_back #define INFN 123456789 #define ll long long #define si short int #define vi vector<int> #define vvi vector<vvi> #define ITER(i,a) for( typeof(a.begin()) i=a.begin();i!=a.end();i++) #define _I int #define _D double #define _L long long  using namespace std; int gcd(int a,int b){ 	return (!b) ? a:gcd(b,a%b); }  char arr[10002]; _I ac,bc;  void func(){ 	_I i,j,len = strlen(arr); 	char n; 	_I tot_c = 0; 	_I min_c = 0; 	char rep_char; 	if(ac < bc) { 		min_c = ac; 		rep_char = 'a'; 	} 	else{ 		min_c = bc; 		rep_char = 'b'; 	} 	_I cnt = 0; 	for(i=0;i < len/2;i++){  		if(arr[i] == '/' && arr[len-i-1] == '/'){ 			tot_c += (2*min_c); 		} 		else if((arr[i] == 'a' && arr[len-i-1] == '/') || (arr[i] == '/' && arr[len-i-1] == 'a')){ 			tot_c += ac; 		} 		else if((arr[i] == 'b' && arr[len-i-1] == '/') || (arr[i] == '/' && arr[len-i-1] == 'b') ){ 			tot_c += bc; 		} 		else if(arr[i] != arr[len-i-1]){ 			cnt = 1; 			break; 		} 	} 	if(cnt){ 		cout << "-1" << endl; 	} 	else{ 		cout << tot_c << endl; 	} }  char N[10021] = {0}; void func1(){ 	if(N[0] & 1) { 		cout << "ODD" << endl; 	} 	else{ 		cout << "EVEN" << endl; 	} 	 }  _L a[100005];  void func2(_L N){ 	_I cnt = 0; 		for(_I i=0; i < N-1;i++){ 			for(_I j=i+1;j < N;j++){ 				if((a[i] ^ a[j] ) & 1){ 					cnt++; 				} 			} 		} 		cout << cnt << endl; }  _I dp[20][20];  void func3(_L N){ 	for(_I i=0;i < N+1;i++){ 		for(_I j=0;j<N+1;j++){ 			dp[i][0]=dp[0][i]=1; 		} 	} 	for(_I i=1;i<N+1;i++){ 		for(_I j=1;j<N+1;j++){ 			dp[i][j] = dp[i-1][j] + dp[i][j-1]; 		} 	} 	cout << dp[N][N] << endl; }  void func4(char s[1000001]){ 	_I i,j; 	_I len = strlen(s); 	_I mx = 0,cnt = 0,cnt_r=0 ; 	for(i = 0; i < len ;i++){ 		if(s[i]=='K')cnt++; 		else cnt--,cnt_r++; 		if(cnt < 0) cnt = 0; 		mx = max(mx,cnt); 	} 	cout << mx+cnt_r << endl; 	 }  _I main(){ 	_I t; 	cin >> t; 	char s[1000001]; 	for(_I test = 0;test < t;test++){ 		cin >> s; 		func4(s); 	} 	return 0; 	 }
#include<iostream> #include<math.h> using namespace std; int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		long int n; 		long int ans=0; 		cin>>n; 		if(n%2==0) 		{ 			ans=0; 		} 		else 		{ 			for(long int i=1;i<=n;i=i+2) 			{ 				ans=ans^i; 			} 		} 		cout<<ans<<"\n"; 	}  }
#include<stdio.h> #include<stdlib.h> #include<math.h> #include<string.h> #include<assert.h>  #define REP(i,a,b) for(i=a;i<b;i++) #define rep(i,n) REP(i,0,n)  #define ll long long #define M 1000000007  int main(){   int T;   char in[20000];   int n, i, j;   int cnt[10], a, b, c, d, sum, use[10];   ll res, tmp;    scanf("%d",&T);     while(T--){ 		scanf("%s",in);     //assert( scanf("%s",in)==1 );     n = strlen(in);     //assert( 1<=n && n<=10000 );     //rep(i,n) assert( '0'<=in[i] && in[i]<='9' );      rep(i,n) in[i] -= '0';      rep(i,10) cnt[i] = 0;     rep(i,n) cnt[in[i]]++; /* cnt[i] = the number of digits i in the input string */      res = 0;     rep(a,11) REP(b,a,11) REP(c,b,11) REP(d,c,11)     { /* use digits a, b, c and d. (if x=10, then x is unused) */       sum = 0;       rep(i,10) use[i] = 0;       if(a < 10) sum += a, use[a]++;       if(b < 10) sum += b, use[b]++;       if(c < 10) sum += c, use[c]++;       if(d < 10) sum += d, use[d]++;       if(sum==0 || sum%9) continue;       tmp = 1;       rep(i,10) rep(j,use[i]) tmp = tmp * (cnt[i]-j) / (j+1); /* the combination will fit in long long:) */       res += tmp;     }      printf("%d\n",(int)(res%M));   }    return 0; } 
#include <stdio.h>  int main() { 	int n,i; 	scanf("%d",&n); 	long long temp,k=0; 	for(i=1;i<n;i++){ 		scanf("%lld",&temp); 		k=k+(temp-1)*i; 		 	} 	scanf("%lld",&temp); 	k=k+temp*n; 	printf("%lld",k); 	return 0; }
#include<cstdio> #include<iostream> #include<cstring> using namespace std; typedef unsigned long long ll; ll  MOD=ll( 1000000007); ll Fibo(int n)     {         ll  fib[2][2]={{1,1},{1,0}},ret[2][2]={{1,0},{0,1}},tmp[2][2]={{0,0},{0,0}};         while(n)         {             if(n&1)              {                 memset(tmp,0,sizeof tmp);                 for(int i=0;i<2;i++) for(int j=0;j<2;j++) for(int k=0;k<2;k++)                          tmp[i][j]=(tmp[i][j]+ret[i][k]*fib[k][j])%MOD;                 for(int i=0;i<2;i++) for(int j=0;j<2;j++) ret[i][j]=tmp[i][j];             }             memset(tmp,0,sizeof tmp);             for(int i=0;i<2;i++) for(int j=0;j<2;j++) for(int k=0;k<2;k++)                                     tmp[i][j]=(tmp[i][j]+fib[i][k]*fib[k][j])%MOD;                         for(int i=0;i<2;i++) for(int j=0;j<2;j++) fib[i][j]=tmp[i][j];             n/=2;           }         return (ret[0][1])%MOD;     }       int main()     {         int t;         long long int m,n;         for(scanf("%d",&t);t>0;t--)         {             scanf("%lld%lld",&n,&m);             cout<<(Fibo(m+2+1)-Fibo(n+1+1)+MOD)%MOD<<endl;;         }     } 
#include<vector> #include<algorithm> #include<iostream> #include<cmath> #include<cstring> #include<cstdio> #include<map> #include<set> using namespace std;  typedef long long int lli;  int main() {     int t;     cin>>t;     while(t--)     {         int n;         long long int f;         cin>>n>>f;         long long int arr[n];         for(int i=0;i<n;i++)             cin>>arr[i];         long long int space;         sort(arr,arr+n);         cin>>space;         long long int ans = 0;         if(n<=space)         {             for(int i=0;i<n;i++)                 ans += arr[i];             space = space-n;             ans -= space*f;             cout<<ans<<endl;         }         else         {             for(int i=0;i<space;i++)                 ans += arr[i];             cout<<ans<<endl;         }     }     return 0; } 
 #include<bits/stdc++.h> #define all(x) x.begin(), x.end() #define pb(x) push_back(x) #define cout2(x, y) cout << x << " " << y << endl #define N 2005 #define MOD 1000000007  using namespace std;  int oddPal[N], evenPal[N];  int P[N]; bool vis[N];  int Find(int x){ 	 	if(x == P[x])return x; 	return P[x] = Find(P[x]);	 }  void Union(int x, int y){ 	 	x = Find(x); 	y = Find(y); 	P[x] = y;	 }  int main(){  	int tc = 0; 	scanf("%d", &tc); 	 	while(tc--){ 		 		int n, m; 		scanf("%d%d", &n, &m);	 		 		for(int i = 0; i <= n; i++){ 			 			oddPal[i] = evenPal[i] = 0; 			P[i] = i; 			vis[i] = false; 		} 			 		int l, r; 		for(int i = 0; i < m; i++){ 			 			scanf("%d%d", &l, &r); 			l--, r--; 			 			if((r - l + 1)&1)oddPal[(r + l)>>1] = max(oddPal[(r + l)>>1], r);	 			else evenPal[(r + l)>>1] = max(evenPal[(r + l)>>1], r); 			 		} 		 		for(int i = 0; i < n; i++){ 			for(int j = i, len, c; j < n; j++){ 				 				len = (j - i + 1); 				c = ((i + j)>>1); 				 				if((len&1) && oddPal[c] >= j)Union(i, j); 				else if((len&1) == 0 && evenPal[c] >= j)Union(i, j);	 			} 		} 		 		long long ans = 1; 		for(int i = 0; i < n; i++){ 			 			if(vis[Find(i)])continue;	 			vis[Find(i)] = true; 			 			ans = ans * 26; 			if(ans >= MOD)ans %= MOD; 		}  		printf("%lld\n", ans); 	}   } 
#include<bits/stdc++.h> using namespace std; #define sc(a) scanf("%lld",&a) #define pr(a) printf("%lld",a) typedef long long ll; int a[100000]; int main() { 	ll n,t,i,j; 	sc(t); 	while(t--) 	{ 		sc(n); 		for(i=0;i<n;i++) 			sc(a[i]); 		sort(a,a+n); 		ll ctr=1, maxCtr = 0, elem = a[0]; 		for(i=1;i<n;i++) 		{ 			if(i>0 && a[i]!=a[i-1]) 			{ 				if(ctr>maxCtr) 				{ 					maxCtr = ctr; 					elem = a[i-1]; 				} 				ctr = 1; 			} 			if(a[i]==a[i-1]) 				ctr++; 		} 		if(maxCtr > n/2) 			pr(elem); 		else 			printf("NO MAJOR"); 		printf("\n"); 	} 	return 0; }
#include<stdio.h> #include<math.h>  using namespace std; int main(){ int t,i; int n; scanf("%d",&t); while(t--) {   double sum=0;    int temp=5;     scanf("%d",&n);    while(n!=0)    {     if(n&1)         sum+=temp;     temp*=5;      n=n>>1;     }    printf("%.0f\n",sum);    }   return 0; } 
#include <iostream> #include <stdio.h> #include <string>  using namespace std;  int main() { 	 	int t, i, k, n; 	 	scanf("%d", &t ); 	cin.ignore(); 	 	while( t-- ) { 		 		string str1, str2, str3; 		 		getline( cin, str1 ); 		getline( cin, str2 ); 		 		str3 = str1 + str1; 		n = str3.length(); 		 		k = str3.find( str2 ); 		 		if( ( k >= 0 ) && ( k < n ) ) 			printf("YES\n"); 		else 			printf("NO\n"); 		 		str1.clear(); 		str2.clear(); 		str3.clear(); 		 	} 	return 0; } 
    #include <iostream>     #include<cmath>     #include<algorithm>     #define tiny 1e-3     using namespace std;           int main()     {     	int n;     	cin>>n;     	int x1,y1,x2,y2,x3,y3;     	for(int i=1;i<=n;i++)     	{     	   cout<<"Case #"<<i<<": ";     	   cin>>x1>>y1>>x2>>y2>>x3>>y3;     	   int flag=0;     	   int asq=(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);     	   int bsq=(x2-x3)*(x2-x3)+(y2-y3)*(y2-y3);     	   int csq=(x3-x1)*(x3-x1)+(y3-y1)*(y3-y1);     	   double a=sqrt(1.0*asq);     	   double b=sqrt(1.0*bsq);     	   double c=sqrt(1.0*csq);     	     	   int arr[3];            arr[0] = asq;  arr[1] = bsq;  arr[2] = csq;            sort(arr, arr + 3);     	   asq= arr[0];  bsq = arr[1];  csq = arr[2];     	   if((a+b-c>tiny) && (a+c-b>tiny) && (b+c-a>tiny) )     	   flag=1;     	   if(flag!=1)     	   {     	      cout<<"not a triangle\n";     		  continue;     		       	    }     	     	if(asq==bsq || asq==csq || bsq==csq )     	{     		if((asq+bsq==csq))     			{     				cout<<"isosceles right triangle\n";     				continue;     			}     		else if((asq+bsq<csq))      		   {     		    	cout<<"isosceles obtuse triangle\n";     			    continue;     		   }     			else if((asq+bsq>csq) )      			{     				cout<<"isosceles acute triangle\n";     				continue;     			}     	}     	else     	{     		  	if((asq+bsq==csq))     			{     				cout<<"scalene right triangle\n";     				continue;     			}     			else if((asq+bsq<csq))      			{     				cout<<"scalene obtuse triangle\n";     				continue;     			}     			else if((asq+bsq>csq) )      			{     				cout<<"scalene acute triangle\n";     				continue;     			}     	}     	}     	     	     	return 0;     } 
// Author: thecodekaiser #include <iostream> #include <cstdlib> #include <cstring> #include <cstdio>  using namespace std;  void solve() { 	int marks[5][101]; 	int cnt[5];  	memset(marks,0,sizeof(marks)); 	memset(cnt,0,sizeof(cnt));  	int N, m; 	cin >> N; 	char ch; 	for(int i = 0; i < N; i++) 	{ 		scanf("\n%c %d",&ch,&m); 		marks[(int) ch - 'A'][m]++; 		cnt[(int) ch - 'A']++; 	}   	for(int i = 0; i < 5; i++) 	{ 		int flag = 0; 		for(int j = 0; j < 101; j++) 		{ 			if(marks[i][j] > cnt[i]/10) 			{ flag = 1; cout << j << " " ;} 		} 		if(flag == 0) 			cout << "Nothing Unusual" << endl; 		else    cout << endl; 	} 	return; }   int main() { 	solve(); 	return 0; }
#include <bits/stdc++.h>  using namespace std ;  typedef long long ll ; // //#define INF 100000001 //#define MAX 10100   //int rr[]= {-1,-1,0,0,1,1}; //int cc[]= {-1,0,-1,1,0,1}; //int rr[]= {0,0,1,-1};/*4 side move*/ //int cc[]= {-1,1,0,0};/*4 side move*/ //int rr[]= {1,1,0,-1,-1,-1,0,1};/*8 side move*/ //int cc[]= {0,1,1,1,0,-1,-1,-1};/*8 side move*/ //int rr[]={1,1,2,2,-1,-1,-2,-2};/*night move*/ //int cc[]={2,-2,1,-1,2,-2,1,-1};/*night move*/  template< class T > T _abs(T n) { return (n < 0 ? -n : n); } template< class T > T _max(T a, T b) { return (!(a < b) ? a : b); } template< class T > T _min(T a, T b) { return (a < b ? a : b); } template< class T > T sq(T x) { return x * x; } template< class T > T gcd(T a, T b) { return (b != 0 ? gcd<T>(b, a%b) : a); } template< class T > T lcm(T a, T b) { return (a / gcd<T>(a, b) * b); } template < class T > T power(T N , T P) { return (P == 0) ?  1 : N * power(N , P - 1); } // //#define Maxi 100000005 //#define sq sqrt(Maxi) // // //bool yes_no[Maxi] ; //int prime[6 * 1000000], sz = 0 ; // //void seive() //{ //    int i, j ; //    yes_no[0] = yes_no[1] = true ; //    yes_no[2] = false ; //    prime[sz++] = 2 ; //    for( i = 4; i <= Maxi; i+= 2) //        yes_no[i] = true ; //    for( i = 3; i <= sq; i += 2 ) //        if( yes_no[i] == false ) //            for( j = i * i ; j <= Maxi; j += ( 2 * i ) ) //                yes_no[j] = true ; // //    for( i = 3; i <= Maxi; i += 2 ) //        if( yes_no[i] == false ) //       // cout << sz << endl; //            prime[sz++] = i ; ////    for( i = 0; i < 20; i++ ) ////        printf("%d\n", prime[i]) ; //}    //ll bigmod(ll num , ll p , ll mod) //{ //    ll sum = 1 , temp = num; //    while(p) //    { //        if(p & 1) sum = (sum * temp) % mod; //        temp = (temp * temp) % mod; p = p >> 1; //    } //    return sum; //}  int main() {     int a[100005], i, tst, cas = 0, l, n, cnt, k  ;     scanf("%d", &tst) ;     while(tst--)     {         int m ;         scanf("%d", &n) ;         if( n % 2 )             puts("0") ;         else         {             n = n / 2 - 1 ;             printf("9") ;             for( i = 0; i < n; i++ )                 printf("0") ;             puts("") ;         }     }     return 0 ; } 
#include <bits/stdc++.h>    #ifndef ONLINE_JUDGE     #define gc getchar     #define pc putchar #else     #define gc getchar_unlocked     #define pc putchar_unlocked #endif     using namespace std;     typedef long long ll; typedef vector<int> vi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef set<int> si; typedef map<string, int> msi;   template< class T > T _abs(T n) { return (n < 0 ? -n : n); }   template< class T > T _max(T a, T b) { return (!(a < b) ? a : b); }   template< class T > T _min(T a, T b) { return (a < b ? a : b); }     template< class T > T gcd(T a, T b) { return (b != 0 ? gcd<T>(b, a%b) : a); }   template< class T > T lcm(T a, T b) { return (a / gcd<T>(a, b) * b); }   template< class T > bool inside(T a, T b, T c) { return a<=b && b<=c; }       inline int fr() {     register int c = gc(); 	int x = 0;      for(; (c<48 || c>57); c = gc());     for(; c>47 && c<58 ; c = gc()) {         x = x*10 + c - 48; } return x;} inline void fp(int n){     if (n / 10 != 0)         fp(n / 10);     putchar((n % 10) + '0'); }  inline ll frl() {     register int c = gc(); 	ll x = 0;      for(; (c<48 || c>57); c = gc());     for(; c>47 && c<58 ; c = gc()) {         x = x*10 + c - 48; } return x;} inline void fpl(ll n){     if (n / 10 != 0)         fp(n / 10);     putchar((n % 10) + '0'); }  #define SWAP(a,b) {a^=b;b^=a;a^=b;} #define MP(x, y) make_pair(x, y) #define SZ(a) int((a).size())      #define SET(p) memset(p, -1, sizeof(p))   #define SETINF(p) memset(p, 127, sizeof(p))   #define CLR(p) memset(p, 0, sizeof(p))     #define CPY(d, s) memcpy(d, s, sizeof(s))     #define PB(x) push_back(x)   #define bitcount      __builtin_popcount #define all(c) (c).begin(),(c).end()  #define present(c,x) ((c).find(x) != (c).end())  #define cpresent(c,x) (find(all(c),x) != (c).end())   #define fi first   #define se second      #define REP(i, a, b) for (int i = int(a); i < int(b); i++) // a to b, and variable i is local! #define REPN(i, a, b) for (int i = int(a); i <= int(b); i++) #define RTR(container, it) for(typeof(container.begin()) it = container.end()-1; it >= container.begin(); --it) #define TR(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); ++it)  #define TRY(i,o) freopen(i,"r",stdin); freopen(o,"w",stdout);  #define sf(n)                       scanf("%lf",&n) #define ss(n)                       scanf("%s",n)  #define INF 0x7f7f7f7f #define SINF 1000000000 //safe inf for floyd warshall  deque<int> dmax;  int main() {  	int a[1000001]; 	int n,k,max1=0; 	dmax.clear(); 	n=fr(); 	REP(i,0,n){ 		a[i]=fr(); 	} 	k=fr(); 	int j; 	for(j=0;j<k;++j){ 		while(!dmax.empty()&&a[j]>=a[dmax.back()]) 			dmax.pop_back(); 		dmax.PB(j); 	} 	fp(a[dmax.front()]); 	for(;j<n;++j){ 		while(!dmax.empty()&&dmax.front()<=(j-k)) 			dmax.pop_front(); 		while(!dmax.empty()&&a[j]>=a[dmax.back()]) 			dmax.pop_back(); 		dmax.PB(j); 		pc(' '); 		fp(a[dmax.front()]); 	} return 0;    }   
#include <cstdio> using namespace std; long long dp[501][10][1024]; #define mod 1000000007 int main(){ int t,n,m; for(int i=0;i<=9;i++)     dp[1][i][1<<i] = 1; for(int i=2;i<=500;i++){     for(int j=0;j<=9;j++){         if(j==0){             for(int k=0;k<1024;k++){                 dp[i][j][k|(1<<j)] += dp[i-1][j+1][k];                 if(dp[i][j][k|(1<<j)]>=mod)                     dp[i][j][k|(1<<j)]%=mod;             }         }         else if(j==9){             for(int k=0;k<1024;k++){                 dp[i][j][k|(1<<j)] += dp[i-1][j-1][k];                 if(dp[i][j][k|(1<<j)]>=mod)                     dp[i][j][k|(1<<j)]%=mod;             }         }         else{             for(int k=0;k<1024;k++){                 dp[i][j][k|(1<<j)] += dp[i-1][j-1][k];                 if(dp[i][j][k|(1<<j)]>=mod)                     dp[i][j][k|(1<<j)]%=mod;                 dp[i][j][k|(1<<j)] += dp[i-1][j+1][k];                 if(dp[i][j][k|(1<<j)]>=mod)                     dp[i][j][k|(1<<j)]%=mod;             }         }     } } scanf("%d",&t); while(t--){  scanf("%d %d",&n,&m);  long long int sum = 0;  int mask = 0;  for(int i=0;i<n;i++)     mask |= (1<<i);  for(int i=1;i<=m;i++){     for(int j=1;j<=9;j++){         sum=(sum+dp[i][j][mask])%mod;     }  }  printf("%lld\n",sum); } return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { 	int t, p=0; 	 	cin>>t; 	while(p<t) 	{  	int n; 	cin>>n; 	long long int a[20000]={0}; 	for(int i=0;i<n;i++) 	{  long long int b; 	  cin>>b; 		a[b]++; 	} 	int v;int count=0; 	for(int j=0;j<20000;j++) 	{ 		if(a[j]>count) 		{ 			v=j; 			count=a[j]; 		} 	} 	cout<<v<<" "<<count<<endl; 	p++;	 		 	} 	return 0; }
#include <iostream> #include <cstdlib> #include <cstring> #include <sstream> #include <cassert> #include <utility> #include <string> #include <bitset> #include <vector> #include <cstdio> #include <stack> #include <queue> #include <list> #include <set> #include <map> #include <algorithm> #include <cmath> #include <complex>   using namespace std;   typedef long long        LL; typedef pair<int, int>   pii; typedef pair<int, pii>   piii; typedef vector<int>      vi; typedef vector<pii>      vii;   //Fast Input  inline void inpint( int &n ) {   n=0; register int ch = getchar_unlocked(); int sign = 1;   while(ch < '0' || ch > '9') { if(ch == '-') sign=-1; ch = getchar_unlocked(); }   while(ch >= '0' && ch <= '9') { n = (n << 3) + (n << 1) + ch - '0', ch = getchar_unlocked(); }   n = n * sign; } //End Fast Input   inline string itostr(int a){     char x[100];     sprintf(x,"%d",a); string s = x;     return s; }   inline int strtoi(string a){     char x[100]; int res;     strcpy(x,a.c_str()); sscanf(x,"%d",&res);     return res; }   inline int sqr(int x){return x * x;} inline int cube(int x){return x * x * x;}   const LL LLINF      = 9223372036854775807LL; const LL LLINF17    = 100000000000000000LL; const int INF       = 2147483647; const int INF9      = 1e9; const int MOD       = 1000000007; const double eps    = 1e-7; const double PI     = acos(-1.0);   #define FORIT(a,b)   for (__typeof((b).begin()) (a)=(b).begin(); (a)!=(b).end(); (a)++) #define FOR(a,b,c)   for (int (a)=(b); (a)<(c); (a)++) #define FORN(a,b,c)  for (int (a)=(b); (a)<=(c); (a)++) #define FORD(a,b,c)  for (int (a)=(b); (a)>=(c); (a)--) #define REP(i,n)     FOR(i,0,n) #define REPN(i,n)    FORN(i,1,n) #define REPD(i,n)    FORD(i,n,1)   #define RESET(a,b)   memset(a,b,sizeof(a))  #define SYNC         ios_base::sync_with_stdio(0); #define SIZE(a)      (int)(a.size()) #define MIN(a,b)     (a) = min((a),(b)) #define MAX(a,b)     (a) = max((a),(b)) #define input(in)    freopen(in,"r",stdin) #define output(out)  freopen(out,"w",stdout) #define ALL(a)       a.begin(),a.end() #define RALL(a)      a.rbegin(),a.rend() #define SIZE(a)      (int)(a.size()) #define LEN(a)       (int)(a.length())   #define FIN(x)       freopen(x,"r",stdin) #define FOUT(x)      freopen(x,"w",stdout) #define FCLOSE       {fclose(stdin); fclose(stdout);}   #define fi           first #define se           second #define pb           push_back #define mp           make_pair   int dr[] = {1,0,-1,0,-1,1,1,-1}; int dc[] = {0,-1,0,1,1,1,-1,-1}; int t, n, arr[1000005], cnt[10000005]; int main(){ 	inpint(t); 	while(t--){ 		inpint(n); int maxval = 0; 		REPN(i,n){ 			inpint(arr[i]); 			MAX(maxval, arr[i]); 			cnt[arr[i]]++; 		}   		int ans = 1; 		for(int i = 1; i <= maxval; i++){ 			int sum = 0; 			for(int j = 1; j <= maxval / i; j++){ 				sum += cnt[i * j]; 				if(sum >= 2){ 					MAX(ans,i); 					break; 				} 			} 		} 		printf("%d\n",ans); 		if(t >= 1) FORN(i,0,maxval) cnt[i] = 0; 	}   	return 0; } 
#include<bits/stdc++.h> using namespace std;   #define sd(mark) scanf("%d",&mark) #define ss(mark) scanf("%s",&mark) #define sl(mark) scanf("%lld",&mark) #define clr(mark) memset(mark,0,sizeof(mark)) #define F first #define S second #define MP make_pair #define PB push_back #define ll long long bool dp[110][130][130]; vector<pair<int,int> > v[110]; int ans=0; void go(int i,int j,int k) { 	int l; 	ans=max(ans,k); 	dp[i][j][k]=1; 	for(l=0;l<v[i].size();++l) 	{ 		if(!dp[v[i][l].F][v[i][l].S][(k^(j&(v[i][l].S)))]) 			go(v[i][l].F,v[i][l].S,(k^(j&(v[i][l].S)))); 	} } int main() { 	int i,j,k,n,m,x,y,c; 	for(i=0;i<110;++i) 		for(j=0;j<130;++j) 			for(k=0;k<130;++k) 				dp[i][j][k]=0; 	sd(n); 	sd(m); 	for(i=0;i<m;++i) 	{ 		sd(x);sd(y);sd(c); 		--x;--y; 		v[x].PB(MP(y,c)); 		v[y].PB(MP(x,c)); 	} 	for(i=0;i<n;++i) 	{ 		if(!dp[i][127][0]) 			go(i,127,0); 	} 	printf("%d\n",ans); }
#include<iostream> #ifdef ONLINE_JUDGE #	define gc getchar_unlocked #else #	define gc getchar #endif inline void fps(long long &x) {     register int c = gc(); 	x = 0;     for(;((c<48 || c>57));c = gc());     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} } main() {       long long t,n;       fps(t);       while(t--)       {          fps(n);                 if(n==1)printf("0\n");          else printf("%lld\n",(n*n)/2-1);       } }        
#include <cstdio> #include <vector>  using namespace std;  long long pow(long long x, int n, int p) { 	if (n == 0) 		return 1; 	long long res = pow(x, n / 2, p); 	res = (res * res) % p; 	if (n % 2 == 1) 		res = (res * x) % p; 	return res; }  int main() { 	int t; 	scanf("%d", &t); 	for (int i = 1; i <= t; i++) { 		int n; 		int p; 		scanf("%d%d", &n, &p); 		vector <int> x(n), y(n); 		for (int j = 0; j < n; j++) 			scanf("%d%d", &x[j], &y[j]); 		int cur = 1; 		long long dx = 0; 		long long dy = 0; 		while (cur < n && dx == 0 && dy == 0) { 			dx = x[0] - x[cur]; 			dy = y[0] - y[cur]; 			cur++; 		} 		if (dx == 0 && dy == 0) { 			printf("Case #%d: MULTIPLE SOLUTIONS\n", i); 			continue; 		} 		if (dx == 0) { 			printf("Case #%d: NO SOLUTIONS\n", i); 			continue; 		} 		if (dx < 0) 			dx += p; 		if (dy < 0) 			dy += p; 		long long a = (dy * pow(dx, p - 2, p)) % p; 		long long b = (y[0] - a * x[0]) % p; 		if (b < 0) 			b += p; 		bool good = true; 		for (int j = 0; j < n; j++) { 			if ((a * x[j] + b) % p != y[j]) { 				good = false; 				break; 			} 		} 		if (good) 			printf("Case #%d: %lld %lld\n", i, a, b); 		else 			printf("Case #%d: NO SOLUTIONS\n", i); 	} 	return 0; }
#include <bits/stdc++.h>  using namespace std;  int main() {     int t;     scanf("%d",&t);      while (t--) {         long long n;         scanf("%lld",&n);         if (n&1)             printf("NO\n");         else             printf("YES\n");     }      return 0; } 
#include<iostream> #include<cstdio> #include<algorithm> #include<cstring> #include<string> using namespace std;  int a[505][505]; int fn(int i,int j); char s1[505],s2[505];  int main(){     string st1,st2;     int T,i,j,mx,n,m;     scanf("%d\n",&T);     while(T--){mx=0;         getline(cin,st1);         getline(cin,st2);         for(i=0;i<=st1.length();i++){             s1[i]=st1[i];             if(s1[i]>='A' && s1[i]<='Z')s1[i]+=32;         }         for(i=0;i<=st2.length();i++){             s2[i]=st2[i];             if(s2[i]>='A' && s2[i]<='Z')s2[i]+=32;         }          n=strlen(s1); m=strlen(s2);          for(i=0;i<=n;i++)for(j=0;j<=m;j++)a[i][j]=0;         for(i=0;i<n;i++)for(j=0;j<m;j++)if(s1[i]==s2[j]){             mx=max(mx,fn(i,j));         }         printf("%d\n",m-mx);     }     return 0;  }  int fn(int I,int J){     if(I==0){         if(s1[I]==s2[J]) return 1;         else return 0;     }      else if(J==0){         if(s1[I]==s2[J]) return 1;         else return 0;     }      if(a[I][J]!=0)return a[I][J];     int i,j,m=1;     for(i=I-1;i>=0;i--)for(j=J-1;j>=0;j--)if(s1[i]==s2[j]){         m=max(m,1+fn(i,j));     }     a[I][J]=m;     return m; } 
#include<stdio.h> #include<algorithm> using namespace std; int main() { 	int w1,w2,t,n1,n2,x,ans; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d%d%d%d",&w1,&w2,&n1,&n2); 		ans=0; 		x=min(w2/2,n2); 		w2-=2*x; 		n2-=x; 		ans+=2*x; 		x=min(w1/2,n2); 		w2-=2*x; 		n2-=x; 		ans+=2*x; 		x=min(w1+w2,n1); 		ans+=x; 		printf("%d\n",ans); 	} }
#include<stdio.h> #include<string.h> #include<stdlib.h> #define ll long long #define MOD 1000000007 #define min(a,b) ((a<b)?a:b) #define max(a,b) ((a>b)?a:b)  ll dp[27][100010]={0}; int main() { 	int test;scanf("%d",&test); 	while(test--) 	{ 		char junk;scanf("%c",&junk); 		int d;char st[100010]; 		scanf("%s",st); 		scanf("%d",&d); 		memset(dp,0,sizeof(dp)); 		int len=strlen(st); 		d=min(d,25); 		if(st[0]=='.') 			for(int i=0;i<26;i++) 				dp[i][0]=1; 		else 			dp[st[0]-'a'][0]=1; 		for(int i=1;i<len;i++) 		{ 			if(st[i]!='.') 			{ 				int pres=st[i]-'a'; 				for(int j=0;j<26;j++) 				{ 					if(abs(pres-j)<=d) 						dp[pres][i]=(dp[pres][i]+dp[j][i-1])%MOD; 				} 			} 			else 			{ 				if(st[i-1]=='.') 				{ 					for(int j=0;j<26;j++) 					{ 						// for dp[j][i] 						for(int k=0;k<26;k++) 						{ 							if(abs(j-k)<=d) 								dp[j][i]=(dp[j][i]+dp[k][i-1])%MOD; 						} 					} 				} 				else 				{ 					int prev=st[i-1]-'a'; 					for(int j=0;j<26;j++) 					{ 						if(abs(j-prev)<=d) 							dp[j][i]=(dp[j][i]+dp[prev][i-1])%MOD; 					} 				} 			} 		} 		ll ans=0; 		for(int i=0;i<26;i++) 			ans=(ans+dp[i][len-1])%MOD; 		printf("%lld\n",(ans+MOD)%MOD); 	} 	return 0; }
#include <bits/stdc++.h> using namespace std;  int tree[100001]; int n;  void update(int id, int val) {     while(id<=n)     {         tree[id]+=val;         id += (id&(-id));     } }  int read(int id) {     int s=0;      while(id>0)     {         s = s+ tree[id];         id -= id&(-id);     }      return s; }  int main() {      int t,i,a,v;      cin>>t;      while(t--)     {         cin>>n;          for(i=0;i<=n;i++)             tree[i]=0;          for(i=0;i<n;i++)         {             cin>>a;             update(a, 1);              v = a - read(a-1);             cout<<v<<"\n";          }      }      return 0; } 
#include<iostream> #include<cstdio> using namespace std;  int main() { 	int t,n,m,a[10010]; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d%d",&n,&m); 		for(int i=0;i<m;i++) 		{ 			scanf("%d",&a[i]); 		} 		int ans=1,bag=n,col; 		bool end=false; 		while(!end) 		{ 			col=ans; 		//	cout << "trying.."  << col << endl; 			bag=n-ans; 			if(bag<0) 			{ 				printf("-1\n"); 				break; 			} 			for(int i=1;i<m;i++) 			{ 				if(a[i]!=a[i-1]) 				{ 					bag-=a[i]-a[i-1]; 					col+=a[i]-a[i-1];  				} 				else  				{ 					col-=1; 				} 				if(bag<0) 				{ 					printf("-1\n"); 					end=true; 					break;  				} 				else if(col<1) 				{	 					ans+=(-col)+1; 					break; 					 				}   			} 			if(!end && col>0) 			{	 					printf("%d\n",ans); 					break; 			} 		} 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; #define ll long long int bool compare1(vector<ll> v1,vector<ll> v2){ return v1[1]<v2[1]; } bool compare2(vector<ll> v1,vector<ll> v2){ return v1[0]<v2[0]; } int main() { ll n,x,y,d,i,l,r,ans=0;   vector <vector<ll> > v;   vector <ll> q;   cin>>n;   for(i=0;i<n;i++)   { cin>>x>>y>>d;     q.push_back(x);     q.push_back(x+d);     v.push_back(q);     q.clear(); 	//cout<<1;   }      sort(v.begin(),v.end(),compare1);   sort(v.begin(),v.end(),compare2);      for(i=0;i<n;i++)   if(i==0)   { l=v[i][0];   	r=v[i][1];   	ans+=(r-l+1);   }   else   { if(v[i][0]<=r && v[i][1]>r)     { ans+=(v[i][1]-r);       l=v[i][0];   	  r=v[i][1]; 	}     else if(v[i][0]>r && v[i][1]>r) 	{ l=v[i][0];   	  r=v[i][1];   	  ans+=(r-l+1); 	}  	   }      cout<<ans;   return 0; }
#include <cstdio> #include <cstring>  using namespace std;  const int MAXN = 120;  struct poly {     int deg;     long double coef[MAXN]; };  poly polys[MAXN]; char str[MAXN]; char aux[MAXN];  int main() {     int t;     scanf("%d", &t);     while (t--) {         int lev = 0;         scanf("%s", str);          int n = strlen(str);         for (int i = 0; i < n; ++i) {             if (str[i] == 'm' || str[i] == 'M') {                 ++lev;                  aux[lev] = str[i];             } else {                 ++lev;                 aux[lev] = 'x';                 polys[lev].deg = 1;                 polys[lev].coef[0] = 0.0;                 polys[lev].coef[1] = 1.0;                  while (lev >= 3 && aux[lev] == 'x' && aux[lev - 1] == 'x') {                     // compute probability encoding logic statements as polys                     // e.g., min(p, q) < x <=> p < x or q < x                      // <=> (p < x) + (q < x) - (p < x and q < x)                     if (aux[lev - 2] == 'm') {                         // min(p(x), q(x)) = p(x) + q(x) - p(x) * q(x)                         //                 = -(1 - p(x)) * (1 - q(x)) + 1                         polys[lev - 2].deg = polys[lev - 1].deg + polys[lev].deg;                         for (int p = 0; p <= polys[lev - 2].deg; ++p)                             polys[lev - 2].coef[p] = 0;                          for (int p = 0; p <= polys[lev].deg; ++p)                             polys[lev].coef[p] = -polys[lev].coef[p];                         polys[lev].coef[0] += 1.0;                          for (int p = 0; p <= polys[lev - 1].deg; ++p)                             polys[lev - 1].coef[p] = -polys[lev - 1].coef[p];                         polys[lev - 1].coef[0] += 1.0;                          for (int p = 0; p <= polys[lev].deg; ++p)                             for (int q = 0; q <= polys[lev - 1].deg; ++q)                                 polys[lev - 2].coef[p + q] += polys[lev].coef[p] *                                     polys[lev - 1].coef[q];                          for (int p = 0; p <= polys[lev - 2].deg; ++p)                             polys[lev - 2].coef[p] = -polys[lev - 2].coef[p];                         polys[lev - 2].coef[0] += 1.0;                     } else {                         // max(p(x), q(x)) = p(x) * q(x)                         polys[lev - 2].deg = polys[lev - 1].deg + polys[lev].deg;                         for (int p = 0; p <= polys[lev - 2].deg; ++p)                             polys[lev - 2].coef[p] = 0;                          for (int p = 0; p <= polys[lev].deg; ++p)                             for (int q = 0; q <= polys[lev - 1].deg; ++q)                                 polys[lev - 2].coef[p + q] += polys[lev].coef[p] *                                     polys[lev - 1].coef[q];                     }                     aux[lev - 2] = 'x';                     lev = lev - 2;                 }             }         }          long double prob = 1.0;         for (int i = 1; i <= polys[lev].deg; ++i)             prob -= polys[lev].coef[i] / (i + 1);         printf("%.9Lf\n", prob);     }      return 0; } 
#include<iostream> using namespace std; int main(){        //  ios_base::sync_with_stdio(false);     // cin.tie(NULL);          int t;     cin>>t;     while(t--) 	{         int n,m;         cin>>n>>m;         char a[1001][1001];         for(int i=0; i<n; i++) 		{             cin>>a[i];         }         for(int i=0; i<n; i++) 		{             for(int j=m-1; j>=0; j--) 		{                 cout<<a[i][j];         }          		    cout<<endl;         }     } } 
#include <bits/stdc++.h>  using namespace std;  typedef long long ll; typedef vector<int> vi; typedef pair<int,int> pii; typedef map<int,int> mi;  #define si(a) scanf("%d",&a) #define sii(a,b) scanf("%d %d",&a,&b) #define nl printf("\n"); #define pb push_back #define mp make_pair #define all(c) (c).begin(),(c).end() #define f(i,a,b) for(i=a;i<b;i++) #define rf(i,a,b) for(i=a;i>=b;i--) #define clr(x,a) memset(x,a,sizeof(x)) #define MAX 100010 #define MOD 1000000007  ll n,m; ll a[MAX],b[MAX],mk[MAX]; vector<ll> v; vi w;  int main(){     ll r,k,i,c=0,x=0,y=0,j,t,l,x1=0,y1=0;     ll z=0,ans=0;string p[1000];      clr(a,0);     f(i,2,sqrt(1e9)+1){         if(!a[i]){             v.pb(i*i);             for(j=2*i;j<sqrt(1e9)+1;j+=i)                 a[j]=1;         }     }     cin>>t;     while(t--){         cin>>x>>y;         cout << upper_bound(v.begin(), v.end(), y) - lower_bound(v.begin(), v.end(), x) << endl;     }     return 0; } 
#include<stdio.h> #include<iostream> #include<math.h> #include<algorithm> #include<cstdlib> #include<string.h> using namespace std; int t,n,s=0,k,l,i,sum; int a[1000];  int main()  {   scanf("%d",&t);    while(t--)   { sum=0;   scanf("%d",&n);     for(i=0;i<n-1;i++)    scanf("%d",&a[i]);      sum=(n*n+n)/2;    for(i=0;i<n-1;i++)     sum=sum-a[i];     cout<<sum<<endl;   }  return 0;  }  
/* 	Name:Shubhendu Shishir 	Copyright:aiden 	Author: aiden 	Date: 	Description: */ #include<bits/stdc++.h> #define gcd(a,b) __gcd(a,b) #define lcm(a,b) (a*(b/gcd(a,b))) #define max3(a,b,c) max(a,max(b,c)) #define min3(a,b,c) min(a,min(b,c)) #define mod		1000000007 #define ll		long long int #define s(n)		scanf("%lld",&n); #define sc(c)		scanf("%c",&c); #define ss(s)		scanf("%s",s); #define loop(x,a,b)	for(x=a;x<b;x++) #define rep(i,n)	for(i=0;i<n;i++) #define mp		make_pair #define pb		push_back #define	vi		vector<ll> #define pll             pair<ll,ll> #define vp		vector<Pll> #define vs		vector<string> #define vvi		vector<VI> #define vvs	vector<VS> #define F first #define S second ll power(ll b, ll e) {     ll p = 1;     while (e > 0) {         if(e&1) {             p = (p*b)%mod;         }         e = e>>1;         b = (b * b)%mod;     }     return p; } using namespace std; int main() { ll a,b,n,m,c,d,i,count=0,sum=0,t,cs=0; s(t); while(t--)   {   s(n);   ll arr[100001];   s(arr[1]);   d=arr[1];   c=1;   for(i=2;i<n;i++)   {   	c=c^i;   	s(arr[i]);   	d=d^arr[i];   }   c=c^n;   m=c^d;   cout<<m<<endl;   } return 0; } 
#include <string> #include <vector> #include <cstdlib> #include <cstdio> #include <cmath> #include <algorithm> #include <ctime> #include <list> #include <map> #include <set> #include <iostream> #include <sstream> #include <cstring> #include <queue> #include <deque> #include <cassert> #include <cctype> #define MP make_pair using namespace std; typedef pair<int, int> PII; typedef unsigned long long ULL; typedef long long LL;  #define MOD #define INF #define MAXN 12  const int dx[] = {-1, 1, 0, 0}; const int dy[] = {0, 0, -1, 1};  int R, C; char grid[MAXN+1][MAXN+1]; vector<PII> food;  void findit(PII pnt, int dc, vector<vector<int> > &adj) {     int dp[R][C];     memset(dp, -1, sizeof(dp));     dp[pnt.first][pnt.second] = 0;     queue<PII> Q;     Q.push(pnt);     while(!Q.empty())     {         PII p = Q.front();         Q.pop();          for(int i=0; i<4; ++i)         {             int xx = p.first+dx[i], yy = p.second + dy[i];             if(xx<0 || yy<0 || xx >=R || yy>=C || grid[xx][yy]=='#' || dp[xx][yy]>-1)                 continue;             dp[xx][yy] = dp[p.first][p.second] + 1;             Q.push(MP(xx,yy));         }     }     for(int i=0; i<food.size(); ++i)         adj[dc][i] = dp[food[i].first][food[i].second]; }  int solve() {     food.clear();     for(int i=0; i<R; ++i)         for(int j=0; j<C; ++j)             if(grid[i][j] == 'H')                 food.push_back(MP(i,j));     for(int i=0; i<R; ++i)         for(int j=0; j<C; ++j)             if(grid[i][j] == 'F')                 food.push_back(MP(i,j));     int N = food.size();     vector< vector <int> > adj(N, vector<int>(N));      for(int i=0; i<N; ++i)for(int j=0; j<N; ++j) adj[i][j] = -1;     for(int i=0; i<N; ++i)         findit(food[i], i, adj);     for(int i=0; i<N; ++i)for(int j=0; j<N; ++j)         if(adj[i][j] == -1)return -1;       vector<int> pm(N-1);     int K = N-1;     for(int i=0; i<K; ++i)         pm[i] = i+1;     int rs = R*C+10;     do     {         int r = 0;         for(int i=0; i<(K-1); ++i)             r += adj[pm[i]][pm[i+1]];         r += adj[0][pm[0]] + adj[pm[K-1]][0];         rs = min(r, rs);     }while(next_permutation(pm.begin(), pm.end()));     return rs/2; }  void readInput() {     scanf("%d%d", &R, &C);     for(int i=0; i<R; ++i)         scanf("%s", grid[i]);  }  int main() {      int testcases;     scanf("%d", &testcases);     for(int caseno=1; caseno<=testcases; caseno++)     {         printf("Case %d: ", caseno);         readInput();         printf("%d\n", solve());     }     return 0; }   
#include <bits/stdc++.h> using namespace std;  int a[1000001];  int main(){     int n;     cin >> n;     int ma = 0, ma2 = 0;     for(int i = 0; i < n; i++) cin >> a[i];     for(int i = 0; i < n; i++){         ma = max(ma,a[i]);     }     for(int i = 0; i < n; i++){         if(a[i] != ma) ma2 = max(ma2,a[i]);     }     cout << ma2 << endl; } 
#include<bits/stdc++.h> using namespace std;  #define sd(a) scanf("%lld",&a) #define ss(a) scanf("%s",&a) #define sl(a) scanf("%lld",&a) #define clr(a) memset(a,0,sizeof(a)) #define debug(a) printf("check%d\n",a) #define rep(i) #define F first #define S second #define MP make_pair #define PB push_back #define ll long long #define M 10000  ll ans[110][10010]; ll diff[110][10010]; ll diff1[110][10010]; ll a[10010]; ll pre[10010];  int main() { 	//freopen("in.txt","r",stdin); 	//freopen("out.txt","w",stdout);  	ll t,n,m,s,i,j,mod; 	sd(t); 	while(t--) 	{ 		sd(n); 		s=sqrt(n); 		for(i=0;i*s<n;++i) 			for(j=0;j<10010;++j) 				ans[i][j]=diff[i][j]=diff1[i][j]=0; 		for(i=0;i<n;++i) 		{ 			ll minn=100000; 			sd(a[i]); 			pre[i]=a[i]; 			if(i) 				pre[i]+=pre[i-1]; 			 			diff1[i/s][a[i]+1]+=a[i]; 			diff1[i/s][a[i]+2]-=a[i];  			diff1[i/s][M+1]-=a[i]; 			diff1[i/s][M+2]+=a[i];  			for(j=1;j*j<=a[i];++j) 			{ 				ll l=a[i]/(j+1)+1; 				ll r=a[i]/j; 				ll A=a[i]%l; 				minn=min(minn,l); 				 				diff1[i/s][l]+=A; 				diff1[i/s][l+1]-=A; 				 				diff1[i/s][l+1]-=j; 				diff1[i/s][r+1]+=j;  				diff1[i/s][r+1]-=(A-(r-l)*j); 				diff1[i/s][r+2]+=(A-(r-l)*j);  			} 			 			for(j=1;j*j<a[i]&&j<minn;++j) 			{ 				diff1[i/s][j  ]+=(a[i]%j); 				diff1[i/s][j+1]-=(a[i]%j); 				diff1[i/s][j+1]-=(a[i]%j); 				diff1[i/s][j+2]+=(a[i]%j); 			} 		} 		 		for(i=0;i*s<n;++i) 		{ 			diff[i][0]=diff1[i][0]; 			for(j=1;j<10010;++j) 				diff[i][j]=diff[i][j-1]+diff1[i][j]; 			ans[i][0]=diff[i][0]; 			for(j=1;j<10010;++j) 				ans[i][j]=ans[i][j-1]+diff[i][j]; 		} 		sd(m); 		while(m--) 		{ 			ll l,r; 			sd(l);sd(r);sd(mod); 			--l;--r; 			if(mod>M) 			{ 				ll ans=pre[r]; 				if(l) 					ans-=pre[l-1]; 				printf("%lld\n",ans); 				return 0; 			} 			ll out=0; 			ll sl=l/s+1,sr=r/s-1; 			if(l%s==0) 				sl--; 			if((r+1)%s==0) 				sr++; 			if(sl>sr) 			{ 				for(i=l;i<=r;++i) 					out=out+a[i]%mod; 			} 			else 			{ 				for(i=l;i<sl*s;++i) 					out=out+a[i]%mod; 				for(i=(sr+1)*s;i<=r;++i) 					out=out+a[i]%mod; 				for(i=sl;i<=sr;++i) 					out+=ans[i][mod]; 			} 			printf("%lld\n",out); 		} 	} 	//for(i=0;i*s<n;++i) 	//	cout<<ans[i][9]<<'\n'; } 
#include<bits/stdc++.h> using namespace std; #define lim 10000000+1 int ans(int n,int k) { 	int r=0,p=k; 	while(k<=n) 	{ 		r+=n/k; 		k*=p; 	} 	//cout<<n<<" "<<k<<" "<<r<<" opopo"<<endl; 	return r;       } int an(int n,int h) { 	int y=0; 	while(n%h==0) 	{ 		n/=h; 		y++; 	} 	return y; } vector<int>v; bool w[lim]; int main() {   for(int i=2;i*i<lim;i++) { 	if(w[i]==false) 	{ 		for(int j=2*i;j<lim;j+=i) 		w[j]=true; 	} } for(int i=2;i<lim;i++) { 	if(w[i]==false) 	v.push_back(i); } 	int t; 	int n,k,res=1000000; 	cin>>t; 	while(t--) 	{ res=1000000; 	cin>>n>>k; 	for(int i=0;v[i]<=k;i++) 	 	{ //cout<<v[i]<<" pp"<<endl; 		if(k%v[i]==0) 		{ 	            	            res=min(res,ans(n,v[i])/an(k,v[i])); 	             		} }  	cout<<res<<endl; 	 } }
#include <iostream> #include <stdio.h> #include <cmath> #include <string.h> #include <limits.h> #include <stdlib.h> #include <algorithm> using namespace std; long long ways; void func(int cost[],int total,int nummovie,int index,int n) {     if(total==0&&nummovie==0)     {         ways++;         return;     }     if(index>=n)     {         return;     }     if(total<0||nummovie==0)     {         return;     }     func(cost,total-cost[index],nummovie-1,index+1,n);     func(cost,total,nummovie,index+1,n); }  int main() {     //freopen("input.txt","r",stdin);     int cases;     scanf("%d",&cases);     while(cases--)     {         int n,total;         scanf("%d%d",&n,&total);         int cost[5000];         for(int i=0;i<n;i++)         {             getchar();             char str[100];             gets(str);             scanf("%d",&cost[i]);         }         sort(cost,cost+n);        /* ways=0;         int movienum=3;         int index=0;         func(cost,k,movienum,index,n);         printf("%lld\n",ways);   */         ways=0;         for(int i=0;i<n;i++)         {             for(int j=i+1;j<n;j++)             for(int k=j+1;k<n;k++)             {                 if(cost[i]+cost[j]+cost[k]==total)                 ways++;             }             //printf("%d ",ways);         }         printf("%lld\n",ways);     }     return 0; } 
//{{{ #include<iostream> #include<algorithm> #include<cmath> #include<climits> #include<vector> #include<list> #include<stack> #include<queue> #include<deque> #include<stack> #include<bitset> #include<set> #include<cstdlib> #include<cstdio> #include<cstring> #include<ctime> #include<map> #include<functional> #include<numeric> #include<utility> #include<sstream> #include<iomanip> #include<cctype> //#undef thecodegame #ifdef thecodegame     #include<debug.h> #else     #define DBG_ARR(a,b,c) {}     #define DBG_MAT(a,s,b,c) {}     #define DBG_VECT(a) {}     #define db(...) {}     #define dbt(x, ...) {} #endif  using namespace std;  #define assert(f) {if(!(f)){fprintf(stderr,"Line-->%d  Assertion failed: %s \n",__LINE__,#f);exit(1);}} #define MOD 	 1000000007LL #define LL 		 long long #define ULL      unsigned long long #define ABS(x)   ((x)<0?-(x):(x)) #define SQR(x) 	 ((x)*(x)) #define CUBE(x)  ((x)*(x)*(x)) #define SD(n)    scanf("%d",&n) #define SD2(n,m) scanf("%d %d",&n,&m) #define SLL(n)   scanf("%lld",&n) #define SLU(n)   scanf("%llu",&n) #define SS(n)    scanf("%s",n) #define pnl      printf("\n") #define REP(i,n)        for(__typeof(n) i=0;i<(n);i++) #define FOR(i,a,b)      for(__typeof(b) i=(a);i<(b);++i) #define FORE(i,a,b)     for(__typeof(b) i=(a);i<=(b);++i) #define FORD(i,a,b,d)   for(__typeof(b) i=(a);i<(b);i+=(d)) #define FORR(i,n,e)     for(__typeof(n) i=(n);i>=(e);--i) #define FORRD(i,n,e,d)  for(__typeof(n) i=(n);i>=(e);i-=(d)) #define REP_IT(it,m)    for(it=m.begin();it!=m.end();it++) #define FORI(it,s) 	    for(__typeof((s).begin()) (it)=(s).begin();(it)!=(s).end();(it)++) #define FOREACH(it, X)  for(__typeof((X).begin()) it = (X).begin(); it != (X).end(); ++it) #define UNIQUE(v)       sort(ALL(v)),v.erase(unique(ALL(v)),v.end()) #define FILL(a,b)       memset(a,b,sizeof(a)) #define ALL(v)          (v).begin(), (v).end() #define RALL(v)         (v).rbegin(), (v).rend() #define checkbit(n,b)   (((n)>>(b))&1) #define PB push_back #define MP make_pair #define XX first #define YY second  const double PI=acos(-1.0); const double EPS=1e-11; template<typename T>inline T mod(T N,T M){return (N%M+M)%M;} double start;//time #ifdef amy     #define getcx getchar #else 	#define SD(x) inp(x) 	#define SD2(x,y) SD(x);SD(y);     #define getcx getchar_unlocked #endif template<typename T>inline void inp(T &n){     n=0;int ch=getcx();int sign=1;     while(ch<'0'||ch>'9'){if(ch=='-')sign=-1;ch=getcx();}     while(ch>='0'&&ch<='9'){n=(n<<3)+(n<<1)+ch-'0',ch=getcx();}     n=n*sign; }  //}}} #define SIZE 100000009 #define MAXX 100000009  void pre(){}//end precompute class Set{     vector<int>pset,prank;     public:     Set(int n){         pset.resize(n);         prank.assign(n,1);         REP(i,n){             pset[i]=i;         }     }     int getSet(int i){         return pset[i];     }     int getRank(int i){         return prank[i];     }     int findSet(int i){         if(pset[i]==i){             return i;         }         return  pset[i]=findSet(pset[i]);     }     bool isSameSet(int i,int j){         return findSet(i)==findSet(j);     }     void unionSet(int i,int j){         int x=findSet(i),y=findSet(j);         if(x==y){             return;         }         if(prank[x]<prank[y]){             pset[x]=y;             prank[y]+=prank[x];         }else{             pset[y]=x;             prank[x]+=prank[y];         }     } }; LL nc2(LL x){     return (x*(x-1))>>1; } int N,M,x,y; LL ans; int arr[SIZE]; void doThis(int ccc){     SD2(N,M);     ans = nc2(N);     if(!M){         printf("%lld\n",ans);         return;     }     Set s(N);     REP(i,M){         SD2(x,y);         s.unionSet(x-1,y-1);     }     REP(i,N){         if(s.getSet(i)==i){             ans-=nc2(s.getRank(i));         }     }     printf("%lld\n",ans);  }//end doThis int main(){ start = clock(); ios_base::sync_with_stdio(false); #ifdef amy 	freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\out.txt","w",stderr); #endif pre(); int cases = 1; //SD(cases); FORE(i,1,cases){doThis(i);} #ifdef amy 	fprintf(stdout,"\nTIME: %.3lf sec\n",(double)(clock()-start)/(CLOCKS_PER_SEC)); #endif //while((clock()-start)<0.999*CLOCKS_PER_SEC){} // :D :D return 0; }//end main 
#include <iostream> #include <stdio.h> #include <limits.h>  using namespace std;  #define MAXN 20 #define MAXP 10000 #define INF INT_MAX  int arr[MAXP], b[MAXP + 1]; int Left[MAXP], Right[MAXP]; long long int inversions;  void merge(int p, int q, int r){ 	int i, j, L, R, K; 	 	L = R = 0;     K = p; 	     while(p <= q) { 		Left[L++] = arr[p]; 		p++; 	} 	 	q = q + 1; 	while(q <= r) { 		Right[R++] = arr[q]; 		q++; 	} 	 	i = j = 0; 	while(i < L && j < R) { 		if(Left[i] <= Right[j]) 			arr[K++] = Left[i++]; 			 		else { 			arr[K++] = Right[j++]; 			inversions += (L - i); 		} 	} 	 	while(i < L) 		arr[K++] = Left[i++]; 		 	while(j < R)   		arr[K++] = Right[j++]; }  void mergesort(int p, int r){ 	int q; 	if(p < r){ 		q = (p + r) / 2; 		mergesort(p, q); 		mergesort(q + 1, r); 		merge(p, q, r); 	} }  int pref[MAXN][MAXP];  int main(){ 	int N, M;     long long int ans; 	 	ans = INF; 	scanf("%d %d", &N, &M); 	 	for(int i = 0; i < N; i++) {     	for(int j = 0; j < M; j++)     		scanf("%d", &pref[i][j]);     } 	     for(int i = 0; i < N; i++) {             for(int k = 0; k < M; k++)                      b[pref[i][k]] = k + 1;                          inversions = 0;             for(int j = 0; j < N; j++) {                     for(int k = 0; k < M; k++)                              arr[k] = b[pref[j][k]];                     mergesort(0, M - 1);             }                          ans = min(ans, inversions);     }     	 	printf("%lld\n", ans); 	return 0; } 
#include <stdio.h>   int main() { 	int t; 	scanf("%d",&t); 	while(t!=0) 	{ 		double a,b,c; 		scanf("%lf %lf %lf",&a,&b,&c); 		double p1=0; 		if(b>a) 		{ 			long int temp; 			temp=a; 			a=b; 			b=temp; 		}//a>b 		if(c==0) 			p1=0; 		else if(b==0 && a==0) 			p1=1; 		else if(b==0) 		{ 			if(a>c) 				p1=(double)c/a; 			else 				p1=1; 		} 		else if(c>=a+b) 			p1=1; 		else 		{ 			if(c<=b) 				p1=(double)c*c/(2*a*b); 			else if(a>=c && c>b) 				p1=(double)(2*c-b)/(2*a); 			else if(c>=a) 				p1=((double)b*(c-b) + (double)(b+c-a)*(a+b-c)/2)/(a*b); 		} 		printf("%0.6lf \n", p1); 		t--; 	} 	return 0; } 
#include<cstdio> using namespace std; int gcd(int x,int y) {     return y?gcd(y,x%y):x; } int main() {     int t,i,n,g,acut,cnt;     long long int s,rf,ms,mrf;     scanf("%d",&t);     while(t--)     {         cnt=0;         scanf("%d%lld%lld",&n,&ms,&mrf);         for(i=0;i<n;i++)         {             scanf("%lld%lld",&s,&rf);             if((s>ms)||(rf>mrf)) cnt++;         }         scanf("%d",&acut);         g=gcd(cnt,acut);         printf("%d/%d\n",cnt/g,acut/g);     }     return 0; } 
#include<iostream> using namespace std;   int main() { 	double n=0.0,sum=0.0; 	for(int i=0;i<12;i++) 	{ 		cin >> n; 		sum+=n; 	} 	cout << "$" << sum/12.0; 	return 0; } 
#include<iostream> using namespace std; #include<stdio.h> int last_digit_fact(int n) { 	int i,j,pw,pw2=0,pw5=0,res=1; 	for(i=1;i<=n;i++) 	{ 		j=i; 		while(j%2==0) 		{ 			j=j/2; 			pw2++; 		} 		while(j%5==0) 		{ 			j=j/5; 			pw5++; 		} 		res=(res*(j%10))%10; 	} 		pw=pw2-pw5; 		for(i=1;i<=pw;i++) 		{ 			res=(res*2)%10; 		} 		return res; }  int main() {   int n,ans;   scanf("%d",&n);   while(n!=0)   {   	 ans=last_digit_fact(n);      printf("%d\n",ans);      scanf("%d",&n);   }      return 0; } 
#include <iostream> #include <string.h> using namespace std; int isRunaround(long unsigned n) { 	int l=0; 	char a[10]; 	while(n) 	{ 		*(a+l)=n%10+'0'; 		n/=10; 		l++;	 	} 	*(a+l)='\0'; 	l--; 	do 	{ 		n=*(a+l)-'0'; 		*(a+l)='-'; 		while(n--) 		{ 			if(l==0) 				l=strlen(a)-1; 			else 				l=l-1;	 		} 	}while(*(a+l)!='-'); 	if(l!=strlen(a)-1) 		return 0; 	for(l=0;l<strlen(a);l++) 	if(*(a+l)!='-') break; 	if(l==strlen(a)) 		return 1; 	else  		return 0; } int main() { 	long unsigned n,k=1,m,l,i,j; 	char a[10]; 	cin>>n; 	while(n) 	{ 		n++; 		while(!isRunaround(n)) 		{ 			while(1) 			{ 				n++; 				m=n; 				l=0; 				while(m) 				{ 					*(a+l)=m%10+'0'; 					m/=10; 					l++;	 				}*(a+l)='\0'; 				for(i=0;i<l;i++) 				if(*(a+i)=='0') break; 				if(i!=l) continue; 				for(i=0;i<l;i++) 				{ 					for(j=i+1;j<l;j++) 					if(*(a+i)==*(a+j))	break; 					if(j!=l)  break; 				} 				if(i==l) break; 			} 		} 		cout<<"Case "<<k<<": "<<n<<endl; 		cin>>n;		 		k++;	 	} 	return 0; }
#include<iostream> #include<algorithm> #include<math.h> #include <limits.h> using namespace std; #define M 100005 int st[M],sst[M]; #define gc getchar_unlocked void scanint(int &x) { register int c = gc(); x = 0; int neg = 0; for(;((c<48 || c>57) && c != '-');c = gc()); if(c=='-') {neg=1;c=gc();} for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} if(neg) x=-x; } int MQ(int st[],int s,int e,int l,int m,int idxx){ 	 	if(l<=s && m>=e) 	return st[idxx]; 	 	if(l>e || m<s) 	return -1; 	 	int md=(s+e)/2; 	int fz=max(MQ(st,s,md,l,m,2*idxx+1),MQ(st,md+1,e,l,m,2*idxx+2)); 	return fz; 	 } int MMQ(int sst[],int s,int e,int l,int m,int idxx){ 	 	if(l<=s && m>=e) 	return sst[idxx]; 	 	if(l>e || m<s) 	return INT_MAX; 	 	int md=(s+e)/2; 	int fz=min(MMQ(sst,s,md,l,m,2*idxx+1),MMQ(sst,md+1,e,l,m,2*idxx+2)); 	return fz; 	 } int SGT(int a[],int s,int e,int st[],int idx){ 	 	if(s==e){ 		st[idx]=a[s]; 		return a[s]; 	} 	int mid=(s+e)/2; 	st[idx]=max(SGT(a,s,mid,st,2*idx+1),SGT(a,mid+1,e,st,2*idx+2)); 	return st[idx]; } int SGGT(int a[],int s,int e,int sst[],int idx){ 	 	if(s==e){ 		sst[idx]=a[s]; 		return a[s]; 	} 	int mid=(s+e)/2; 	sst[idx]=min(SGGT(a,s,mid,sst,2*idx+1),SGGT(a,mid+1,e,sst,2*idx+2)); 	return sst[idx]; } int main(){ 	 	int i,j,k,l,m,t,n,a[100005]; 	scanint(n); 	scanint(t); 	for(i=0;i<n;i++) 		cin>>a[i]; 	 	SGT(a,0,n-1,st,0); 	SGGT(a,0,n-1,sst,0);  while(t--){ 	scanint(l); 	scanint(m); int ff=	(MQ(st,0,n-1,l,m,0)-MMQ(sst,0,n-1,l,m,0)); 	cout<<ff<<endl; 	} }
    #include<bits/stdc++.h>     using namespace std;      int main()     {     	int T,N,Z,L,R,mid,temp;     	scanf("%d",&T);     	while(T--)     	{     		scanf("%d %d %d",&L,&R,&N);     		temp=R-L;     		int cnt=1;     		/*if(temp==1)     		{     			printf("0 0\n1\n");     			continue;     		}*/     		while(temp>=1 && !(L==N && R==N))     		{     			cnt++;     			printf("%d %d\n",L,R);     			mid=(L+R)/2;     			if(mid>=N)     			{     				R=mid;     				temp=mid-L;     			}     			else     			{     				L=mid+1;     				temp=R-mid-1;     			}     		}     		printf("%d %d\n",L,R);     		printf("%d\n",cnt);     	}     	return 0;     } 
#include<iostream> #include<cstdio> #include<vector> #include<algorithm> #include<string> #include<string.h> #include<math.h> #define in_t(t) scanf("%d",&t) using namespace std; int main() {     int  with;     double bal;     scanf("%d",&with);     scanf("%lf",&bal);     if(with>bal)     printf("%.2lf\n",bal);     else if(with==bal)     printf("%.2lf\n",bal);     else if (with%5==0)     printf("%.2lf\n",bal-with-0.50);     else if(with%5)     printf("%.2lf\n",bal);     return 0; }      
//By Sainath :) #include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <limits> #include <string> #include <cassert> #include <cstring>  using namespace std; typedef long long LL; typedef pair<int,int> pii;  #define forup(i,a,b) for(int i=a; i<b; ++i) #define fordn(i,a,b) for(int i=a; i>b; --i) #define rep(i,a) for(int i=0; i<a; ++i)  #define dforup(i,a,b) for(i=a; i<b; ++i) #define dfordn(i,a,b) for(i=a; i>b; --i) #define drep(i,a) for(i=0; i<a; ++i)  #define slenn(s,n) for(n=0; s[n]!='\0'; ++n)  #define gi(x) scanf("%d",&x) #define gl(x) cin>>x #define gd(x) scanf("%lf",&x) #define gs(x) scanf("%s",x)  #define pis(x) printf("%d ",x) #define pin(x) printf("%d\n",x) #define pls(x) cout<<x<<" " #define pln(x) cout<<x<<"\n" #define pds(x) printf("%.12f ",x) #define pdn(x) printf("%.12f\n",x) #define pnl() printf("\n")  #define fs first #define sc second  #define pb push_back int main() { 	int t,i; 	gi(t); 	while(t--) 	{ 		char a[12]; 		gs(a); 		int dots=0; 		slenn(a,i) 		{ 			switch(a[i]) 			{ 				case '0':printf("-----");dots+=0;break; 				case '1':printf(".----");dots+=1;break; 				case '2':printf("..---");dots+=2;break; 				case '3':printf("...--");dots+=3;break; 				case '4':printf("....-");dots+=4;break; 				case '5':printf(".....");dots+=5;break; 				case '6':printf("-....");dots+=4;break; 				case '7':printf("--...");dots+=3;break; 				case '8':printf("---..");dots+=2;break; 				case '9':printf("----.");dots+=1;break;  			};  		} 		printf("\n%d\n",dots); 	}  return 0; } 
#include <iostream> #include<string.h> using namespace std;  int main() { 	char msg[101]; 	gets(msg); 	int l,i; 	l=strlen(msg); 	for(i=0;i<l;i++) 	{ cout<<(char)(((int)msg[i])-7); 	} 	return 0; }
#include<iostream> #include<iomanip> #include<string.h> using namespace std; int convert(char); int main() {     int T;     char A[20],B[20];     cin>>T;     while(T--)     {         cin>>A>>B;         if(strlen(A)==1 && strlen(B)==1 && ((A[0]>=50 && A[0]<=57) || A[0]=='A' || A[0]=='J' || A[0]=='Q' || A[0]=='K') && ((B[0]>=50 && B[0]<=57) || B[0]=='A' || B[0]=='J' || B[0]=='Q' || B[0]=='K'))         {                 if(convert(A[0])+convert(B[0])<=11)                     cout<<"HIT\n";                 else                     cout<<"STAND\n";         }         else             cout<<"INVALID\n";     }     return 0; } int convert(char a) {     if(a=='A')         return(11);     else if(a=='J' || a=='Q' || a=='K')         return(10);     else         return(a-'0'); }
#include<iostream> #include<string.h> #include<stdlib.h> using namespace std; int main() {     int t,i,j,l,count;char a;     cin>>t;          for(j=0;j<t;j++)     {               count=1;     char me[100];     cin>>me;     l=strlen(me);     char A[3]={'A','B','C'},D[3]={'D','E','F'},G[3]={'G','H','I'},J[3]={'J','K','L'},M[3]={'M','N','O'},P[4]={'P','Q','R','S'};     char T[3]={'T','U','V'},W[4]={'W','X','Y','Z'};             for(i=0;i<l;i++)             {                             if(me[i]==me[i+1])                             count++;                             else                              {                                  if(me[i]=='2')                                  cout<<A[count-1];                                  else if(me[i]=='3')                                  cout<<D[count-1];                                  else if(me[i]=='4')                                  cout<<G[count-1];                                  else if(me[i]=='5')                                  cout<<J[count-1];                                  else if(me[i]=='6')                                  cout<<M[count-1];                                  else if(me[i]=='7')                                  cout<<P[count-1];                                  else if(me[i]=='8')                                  cout<<T[count-1];                                  else if(me[i]=='9')                                  cout<<W[count-1];                                  else if(me[i]=='0')                                  cout<<" ";                                  count=1;                                  }                             }                             cout<<endl;             }                  return 0;     } 
#include<iostream> #include<math.h> using namespace std; int len(long unsigned n) {    int l=0; 	while(n) n/=10,l++; 	return l; } int isprime(long unsigned n) {	long unsigned i; 	for(i=2;i<n;i++) 	if(n%i==0) break; 	if(i==n) return 1; 	else return 0; } long unsigned num_rot(long unsigned n,int f) {	int i,l=len(n)-1; 	while(f--) 	{	i=n%10; 		n/=10; 		n+=i*pow(10,l);	 	} 	return n; } int cir_prime(long unsigned n) {	long unsigned k=n; 	int l=len(n); 	if(isprime(k)) 	{	while(l--) 		{	k=num_rot(n,l); 			if(!isprime(k)) break; 			if(k<n && cir_prime(k)) break; 		} 		if (l==-1) return 1; 		else return 0; 	} 	else  		return 0; } int main() { 	int t,i; 	cin>>t; 	long unsigned *n=new long unsigned[t]; 	for(i=0;i<t;i++) 	cin>>*(n+i); 	for(i=0;i<t;i++) 	cout<<cir_prime(*(n+i))<<" "; 	return 0;	 }
#include<algorithm> #include<iostream> using namespace std; int main() {     int t; cin>>t;     while(t--)     {         int n; cin>>n;         int arr[n];         for(int i=0;i<n;i++)         cin>>arr[i];         sort(arr,arr+n);         for(int i=0;i<n-1;i++)         cout<<arr[i]<<" ";         cout<<arr[n-1]<<endl;     }     return 0; }
#include <stdio.h>  using namespace std;  int main() { 	int a,b,c,t,n; 	scanf("%d",&n); 	while(n--){ 		scanf("%d",&a); 		scanf("%d",&b); 		scanf("%d",&c); 		t = 0; 		if((a > b)&&(a < c) || (a > c) && (a < b) ){ 			t = a; 		} 		else if((b > a)&&(b < c) || (b > c) && (b < a)){ 			t = b; 		} 		else if(a == b) { 			t = b; 		} 		else { 			t = c; 		}		 	printf("%d",t); 	printf("\n");	 			 	} 	return 0; }
#include <iostream> #include <math.h> using namespace std;  int main() {     unsigned long long tcases, count=0;     double a, b, c, len, diagonal;          cin >>tcases;     cin >>a >>b >>c;     diagonal=sqrt((a*a) + (b*b) + (c*c));          while (tcases--)     {         cin >>len;         if (len<=diagonal)          count++;     }     cout <<count <<endl;     return 0; } 
#include<stdio.h> #include<iostream> #include<string.h> #include<math.h> #include<vector> #include<queue> #include<stack> #define min(a,b) a>b?b:a #define max(a,b) a>b?a:b  using namespace std;  int main() {     int t,end=0;     scanf("%d",&t);     char c;     while(scanf("%c",&c) && c!='\n');     while(t--)     {               stack <char> s;               char ch;               int flag=0;               while(1)               { 			int eof=1;                       while(scanf("%c",&ch)!=EOF)                       { 						eof=0; 						//cout<<"sdsdf\n";                                             if(ch==' ')                                             {flag=1; break;}                                             else if(ch=='\n')                                             {flag=2;break;}                                             //else if(ch==EOF)                                             //{flag=3; break;}                                             else                                             {flag=0;s.push(ch);}                       } 			if(eof) {end=1;break;}                       while(!s.empty())                       {printf("%c",s.top());s.pop();}                       if(flag==1)                       printf(" ");                       else if(flag==2)                       {printf("\n");break;}                                                                                    }               if(end)               break;     }   return 0;  }
#include<bits/stdc++.h> using namespace std; int main() {     ios_base::sync_with_stdio(0);     int n,m,a[100][100],mini=INT_MAX,lmini=INT_MIN,minindex=0;     cin>>n>>m;     for(int i=0;i<n;i++){         for(int j=0;j<m;j++){             cin>>a[i][j];             if(a[i][j]<mini){                 mini=a[i][j];             }         }         if(lmini<mini){             lmini=mini;             minindex=i;         }         mini=INT_MAX;     }     cout<<lmini<<endl;     return 0; } 
#include<iostream> #include<bits/stdc++.h> #include<stdio.h> #include<string>  #define lld long long int #define d int using namespace std;  int main() {     lld t,num;     char a[10000];     char temp;      cin>>t;     while(t--)     {         lld i , j,ln;         scanf("%s",&a);         scanf("%lld",&num);         for(i=0; i<num; i++)         {             for(j=i+1; j<num; j++)             {                 temp=a[i];                 a[i]=a[j];                 a[j]=temp;             }         }         ln=strlen(a);         for(i=num; i< ln; i++)         {                 a[i]=static_cast<char>(90-a[i]+65);         }         cout<<a<<endl;     }     return 0; } 
#include <iostream> #include <cstdio> #define ll int using namespace std;  ll mintree[2000005]; ll maxtree[200005]; ll arr[100005]; ll MAX = 1000000000; ll n,q,l,r;  void buildmax(ll node, ll start, ll end) {     if(start == end)     {         // Leaf node will have a single element        maxtree[node] = arr[start];     }     else     {         ll mid = (start + end) / 2;         // Recurse on the left child         buildmax(2*node, start, mid);         // Recurse on the right child         buildmax(2*node+1, mid+1, end);         // Internal node will have the sum of both of its children         ll d1 = maxtree[2*node];         ll d2 = maxtree[2*node+1];         maxtree[node] =  d1>d2 ? d1 : d2;     } }  void buildmin(ll node, ll start, ll end) {     if(start == end)     {         // Leaf node will have a single element        mintree[node] = arr[start];     }     else     {         ll mid = (start + end) / 2;         // Recurse on the left child         buildmin(2*node, start, mid);         // Recurse on the right child         buildmin(2*node+1, mid+1, end);         // Internal node will have the sum of both of its children         ll d1 = mintree[2*node];         ll d2 = mintree[2*node+1];         mintree[node] =  d1<d2 ? d1 : d2;     } }  ll querymax(ll node, ll start, ll end, ll l, ll r) {     if(r < start or end < l)     {         // range represented by a node is completely outside the given range         return -1;     }     if(l <= start and end <= r)     {         // range represented by a node is completely inside the given range         return maxtree[node];     }     // range represented by a node is partially inside and partially outside the given range     ll mid = (start + end) / 2;     ll p1 = querymax(2*node, start, mid, l, r);     ll p2 = querymax(2*node+1, mid+1, end, l, r);     return  p1>p2 ? p1 : p2; }  ll querymin(ll node, ll start, ll end, ll l, ll r) {     if(r < start or end < l)     {         // range represented by a node is completely outside the given range         return MAX;     }     if(l <= start and end <= r)     {         // range represented by a node is completely inside the given range         return mintree[node];     }     // range represented by a node is partially inside and partially outside the given range     ll mid = (start + end) / 2;     ll p1 = querymin(2*node, start, mid, l, r);     ll p2 = querymin(2*node+1, mid+1, end, l, r);     return  p1<p2 ? p1 : p2; }  int main() { 	// your code goes here 	 	scanf("%d",&n); 	 	for(ll i=1;i<=n;i++){ 		scanf("%d",arr+i); 	} 	 	buildmin(1,1,n); 	buildmax(1,1,n); 	 	scanf("%d",&q); 	 	while(q--){ 		scanf("%d %d",&l,&r); 		l++; 		r++; 		ll a1 = querymin(1, 1, n, l, r); 		ll a2 = querymax(1, 1, n, l, r); 		ll b1 = querymax(1, 1, n, 1, l-1); 		ll b2 = querymax(1, 1, n, r+1, n); 		b1 = max(b1,b2); 		double dd1 = (double)b1; 		 		double dd2 = (double)a2; 		 		dd2 -= (double)a1; 		dd2 /= 2; 		double ans = dd1>dd2 ? dd1 : dd2; 		 		ans += (double)a1; 		 		printf("%0.1f\n",ans); 	} 	 	return 0; }
#include<iostream> #include<stdio.h> #include<stdlib.h> #include<string> #include<string.h> using namespace std;  void LPSArray(int lps[],char sub[]) {     lps[0]=0;     int i=1,len=0;     while(i<strlen(sub))     {         if(sub[len]==sub[i])         {             len++;             lps[i] = len;             i++;         }         else         {             if(len!=0)                 len = lps[len-1];             else             {                 lps[i] = 0;                 i++;             }         }     } }  int KMP(char str[]) {     char s[11];     int i,j =0;     for(i=strlen(str)-1;i>=0;i--)     {         s[j] = str[i];         j++;     }     s[j] = 0;     int lt = strlen(str);     int lp = strlen(s);     //printf("lt: %d,lp: %d\n",lt,lp);     int *lps = (int *)malloc(sizeof(int)*lp);     LPSArray(lps,s);     i=0;     j=0;     int k=1;     //cout<<"TEXT: "<<str<<" ";     //cout<<"PATTERN: "<<sub<<endl;     while(i<lt)     {         if(s[j]==str[i])         {             //printf("i: %d, j: %d\n",i,j);             i++;             j++;         }         if(j==lp)         {             //printf("HI\n");             k=0;             j=lps[j-1];         }         else if(i<lt && s[j]!=str[i])         {             //printf("HI AGAIN\n");             if(j!=0)                 j = lps[j-1];             else                 i++;         }     }     return k; }  int main() {     int T,i,j,k,f=0;     char str[11],sub[11];     scanf("%d",&T);     while(T--)     {         cin>>str;         k = KMP(str);         if(k==0)             printf("YES\n");         else             printf("NO\n");     }     return 0; } 
#include<stdio.h>   int main() {     int t=0;     long long int n,k,m;       scanf("%d",&t);       while(t--)     {         scanf("%lld%lld%lld",&n,&k,&m);         if(k == 1)             printf("\n%lld",n);         else         {             while((n%k==0) && m)             {                 n /= k;                 m--;             }             if(m % 2 != 0)                 n *= k;             printf("\n%lld",n);         }     }     return 0; }
#include<bits/stdc++.h>  using namespace std;  int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		int n; 		cin>>n; 		int v[100005]; 	 		for(int i=1;i<=n;i++) 			cin>>v[i]; 		if(n==2) 		{ 			cout<<v[2]<<endl; 			continue; 		} 		int a[100005] = {0}; 		long long lsum = 0; 		for(int i=2;i<=n;i++) 		{ 			if(a[i] == 1) 				continue; 			long long sum =0 ; 			for(int j=i;j<=n;j = j+i) 			{ 				sum+= v[j]; 				a[j] = 1; 			} 			if(sum > lsum) 				lsum = sum; 		} 		cout<<lsum<<endl; 	} 	return 0; }
#include<iostream> #include<algorithm> #include<cstring> using namespace std; int main() {	std::ios::sync_with_stdio(false); 	int n,m; 	cin>>n>>m; 	int a[n],b[m],c[m+n-1]; 	memset(c,0,sizeof(c)); 	for(int i=0;i<n;i++) 	cin>>a[i]; 	for(int i=0;i<m;i++) 	cin>>b[i]; 	for(int i=0;i<n;i++) 	{ 		for(int j=0;j<m;j++) 		{ 			c[i+j]+=a[i]*b[j]; 		} 	} 	cout<<c[0]; 	for(int i=1;i<m+n-1;i++) 	cout<<" + "<<c[i]<<"x^"<<i; 	cout<<"\n"; 	return 0; }
#include<bits/stdc++.h> using namespace std;  const int base = 1000000000; const int base_digits = 9;  struct bigint {     vector<int> a;     int sign;      bigint() :         sign(1) {     }      bigint(long long v) {         *this = v;     }      bigint(const string &s) {         read(s);     }      void operator=(const bigint &v) {         sign = v.sign;         a = v.a;     }      void operator=(long long v) {         sign = 1;         if (v < 0)             sign = -1, v = -v;         for (; v > 0; v = v / base)             a.push_back(v % base);     }      bigint operator+(const bigint &v) const {         if (sign == v.sign) {             bigint res = v;              for (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) || carry; ++i) {                 if (i == (int) res.a.size())                     res.a.push_back(0);                 res.a[i] += carry + (i < (int) a.size() ? a[i] : 0);                 carry = res.a[i] >= base;                 if (carry)                     res.a[i] -= base;             }             return res;         }         return *this - (-v);     }      bigint operator-(const bigint &v) const {         if (sign == v.sign) {             if (abs() >= v.abs()) {                 bigint res = *this;                 for (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) {                     res.a[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);                     carry = res.a[i] < 0;                     if (carry)                         res.a[i] += base;                 }                 res.trim();                 return res;             }             return -(v - *this);         }         return *this + (-v);     }      void operator*=(int v) {         if (v < 0)             sign = -sign, v = -v;         for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {             if (i == (int) a.size())                 a.push_back(0);             long long cur = a[i] * (long long) v + carry;             carry = (int) (cur / base);             a[i] = (int) (cur % base);             //asm("divl %%ecx" : "=a"(carry), "=d"(a[i]) : "A"(cur), "c"(base));         }         trim();     }      bigint operator*(int v) const {         bigint res = *this;         res *= v;         return res;     }      friend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {         int norm = base / (b1.a.back() + 1);         bigint a = a1.abs() * norm;         bigint b = b1.abs() * norm;         bigint q, r;         q.a.resize(a.a.size());          for (int i = a.a.size() - 1; i >= 0; i--) {             r *= base;             r += a.a[i];             int s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];             int s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];             int d = ((long long) base * s1 + s2) / b.a.back();             r -= b * d;             while (r < 0)                 r += b, --d;             q.a[i] = d;         }          q.sign = a1.sign * b1.sign;         r.sign = a1.sign;         q.trim();         r.trim();         return make_pair(q, r / norm);     }      bigint operator/(const bigint &v) const {         return divmod(*this, v).first;     }      bigint operator%(const bigint &v) const {         return divmod(*this, v).second;     }      void operator/=(int v) {         if (v < 0)             sign = -sign, v = -v;         for (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) {             long long cur = a[i] + rem * (long long) base;             a[i] = (int) (cur / v);             rem = (int) (cur % v);         }         trim();     }      bigint operator/(int v) const {         bigint res = *this;         res /= v;         return res;     }      int operator%(int v) const {         if (v < 0)             v = -v;         int m = 0;         for (int i = a.size() - 1; i >= 0; --i)             m = (a[i] + m * (long long) base) % v;         return m * sign;     }      void operator+=(const bigint &v) {         *this = *this + v;     }     void operator-=(const bigint &v) {         *this = *this - v;     }     void operator*=(const bigint &v) {         *this = *this * v;     }     void operator/=(const bigint &v) {         *this = *this / v;     }      bool operator<(const bigint &v) const {         if (sign != v.sign)             return sign < v.sign;         if (a.size() != v.a.size())             return a.size() * sign < v.a.size() * v.sign;         for (int i = a.size() - 1; i >= 0; i--)             if (a[i] != v.a[i])                 return a[i] * sign < v.a[i] * sign;         return false;     }      bool operator>(const bigint &v) const {         return v < *this;     }     bool operator<=(const bigint &v) const {         return !(v < *this);     }     bool operator>=(const bigint &v) const {         return !(*this < v);     }     bool operator==(const bigint &v) const {         return !(*this < v) && !(v < *this);     }     bool operator!=(const bigint &v) const {         return *this < v || v < *this;     }      void trim() {         while (!a.empty() && !a.back())             a.pop_back();         if (a.empty())             sign = 1;     }      bool isZero() const {         return a.empty() || (a.size() == 1 && !a[0]);     }      bigint operator-() const {         bigint res = *this;         res.sign = -sign;         return res;     }      bigint abs() const {         bigint res = *this;         res.sign *= res.sign;         return res;     }      long long longValue() const {         long long res = 0;         for (int i = a.size() - 1; i >= 0; i--)             res = res * base + a[i];         return res * sign;     }      friend bigint gcd(const bigint &a, const bigint &b) {         return b.isZero() ? a : gcd(b, a % b);     }     friend bigint lcm(const bigint &a, const bigint &b) {         return a / gcd(a, b) * b;     }      void read(const string &s) {         sign = 1;         a.clear();         int pos = 0;         while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {             if (s[pos] == '-')                 sign = -sign;             ++pos;         }         for (int i = s.size() - 1; i >= pos; i -= base_digits) {             int x = 0;             for (int j = max(pos, i - base_digits + 1); j <= i; j++)                 x = x * 10 + s[j] - '0';             a.push_back(x);         }         trim();     }      friend istream& operator>>(istream &stream, bigint &v) {         string s;         stream >> s;         v.read(s);         return stream;     }      friend ostream& operator<<(ostream &stream, const bigint &v) {         if (v.sign == -1)             stream << '-';         stream << (v.a.empty() ? 0 : v.a.back());         for (int i = (int) v.a.size() - 2; i >= 0; --i)             stream << setw(base_digits) << setfill('0') << v.a[i];         return stream;     }      static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {         vector<long long> p(max(old_digits, new_digits) + 1);         p[0] = 1;         for (int i = 1; i < (int) p.size(); i++)             p[i] = p[i - 1] * 10;         vector<int> res;         long long cur = 0;         int cur_digits = 0;         for (int i = 0; i < (int) a.size(); i++) {             cur += a[i] * p[cur_digits];             cur_digits += old_digits;             while (cur_digits >= new_digits) {                 res.push_back(int(cur % p[new_digits]));                 cur /= p[new_digits];                 cur_digits -= new_digits;             }         }         res.push_back((int) cur);         while (!res.empty() && !res.back())             res.pop_back();         return res;     }      typedef vector<long long> vll;      static vll karatsubaMultiply(const vll &a, const vll &b) {         int n = a.size();         vll res(n + n);         if (n <= 32) {             for (int i = 0; i < n; i++)                 for (int j = 0; j < n; j++)                     res[i + j] += a[i] * b[j];             return res;         }          int k = n >> 1;         vll a1(a.begin(), a.begin() + k);         vll a2(a.begin() + k, a.end());         vll b1(b.begin(), b.begin() + k);         vll b2(b.begin() + k, b.end());          vll a1b1 = karatsubaMultiply(a1, b1);         vll a2b2 = karatsubaMultiply(a2, b2);          for (int i = 0; i < k; i++)             a2[i] += a1[i];         for (int i = 0; i < k; i++)             b2[i] += b1[i];          vll r = karatsubaMultiply(a2, b2);         for (int i = 0; i < (int) a1b1.size(); i++)             r[i] -= a1b1[i];         for (int i = 0; i < (int) a2b2.size(); i++)             r[i] -= a2b2[i];          for (int i = 0; i < (int) r.size(); i++)             res[i + k] += r[i];         for (int i = 0; i < (int) a1b1.size(); i++)             res[i] += a1b1[i];         for (int i = 0; i < (int) a2b2.size(); i++)             res[i + n] += a2b2[i];         return res;     }      bigint operator*(const bigint &v) const {         vector<int> a6 = convert_base(this->a, base_digits, 6);         vector<int> b6 = convert_base(v.a, base_digits, 6);         vll a(a6.begin(), a6.end());         vll b(b6.begin(), b6.end());         while (a.size() < b.size())             a.push_back(0);         while (b.size() < a.size())             b.push_back(0);         while (a.size() & (a.size() - 1))             a.push_back(0), b.push_back(0);         vll c = karatsubaMultiply(a, b);         bigint res;         res.sign = sign * v.sign;         for (int i = 0, carry = 0; i < (int) c.size(); i++) {             long long cur = c[i] + carry;             res.a.push_back((int) (cur % 1000000));             carry = (int) (cur / 1000000);         }         res.a = convert_base(res.a, 6, base_digits);         res.trim();         return res;     } }; int main() {     bigint a,b,c;     cin>>a;     cin>>b;     c=a*b;     cout<<c<<endl;     return 0; } 
#include<iostream> using namespace std;   int main() {     int q;     cin>>q;     while(q!=0)     {long long int x;     cin>>x;long long int s=0,a=1,b=2;     long long int y=0;     if(x==0 || x==1 || x==2)        cout<<"YES"<<endl;        else     for(int i=0;i<70;i++)       if(y>x)         {cout<<"NO"<<endl;break;}         else if(y==x)            {cout<<"YES"<<endl;break;}            else            {y=s+a+b;s=a;a=b;b=y;}         q--;     }return 0; }
#include<iostream> using namespace std; int main() {     int t;     cin>>t;     for(int i=0;i<t;i++)     {         long int n;         cin>>n;         if(n!=1){         if(n%2==0)         {           long int k=n/2;           k=-1*k;           cout<<k<<endl;         }         else         {             long int k=n/2;           k=-1*k;           k=k+n;           cout<<k<<endl;         }     }      else             cout<<"1"<<endl;      }     return 0; } 
#include<stdio.h> #include<string.h> #include<iostream> #include<algorithm> using namespace std; int main() { 	int t,i; 	cin>>t; 	while(t--) 	{ 		int n; 		cin>>n;getchar(); 		char s[2000]; 		char arr[50]; 		for(i=0;i<n;i++) 		{ 			cin>>s; 			int k=strlen(s); 			sort(s,s+k); 			arr[i]=s[k/2]; 		} 		arr[n]='\0'; 		printf("%s\n",arr); 	} 	return 0; }
#include<bits/stdc++.h> using namespace std;  typedef long long ll; int main() {     ll t;     cin>>t;     while(t--)     {         ll n;         cin>>n;         ll dp[n],a[n];     cin>>a[0];         for(ll i=1;i<n;i++){                 cin>>a[i];             dp[i]=a[i]-a[i-1];         }        ll start=1;        ll en=n-1;         ll s=0,mi,ans=0;         while(start<=en)         {            s=mi=dp[start];             for(ll i=start+1;i<n;i++){             s+=dp[i];                 if(s<mi)                 mi=s,start=i;             }ans+=mi;                 start++;         }         cout<<ans<<endl;      } }  
#include<bits/stdc++.h> using namespace std; int prime1(int n) {     int i;     for(i=2;i<=sqrt(n);i++)     {         if(n%i==0)         {             return 0;         }     }     return 1; } int main() { 	vector<int> v(1299710); 	vector<int> st1,st2; 	int i,j,num,in1,in2,n; 	map<int,int> prime,comp; 	in1=in2=0; 	prime[0]=comp[0]=0; 	for(i=2;i<=1299709;i++) 	{ 		if(v[i]==0) 		{ 			in1++;             prime[in1]=i; 			for(j=2*i;j<=1299709;j=j+i) 				v[j]=1; 		} 		else 		{ 		    in2++; 		    comp[in2]=i; 		} 	} 	map<int,int>::iterator it1; 	scanf("%d",&n); 	int p,c,maxi;     p=c=0; 	for(i=0;i<n;i++) 	{ 	    scanf("%d",&(num)); 	    if(num<1299710) 	    { 	        if(v[num]) 	         { 	             c++; 	             st2.push_back(num); 	         } 	       else 	       { 	           p++; 	           st1.push_back(num); 	       } 	             	    } 	    else 	    { 	        if(prime1(num)) 	        { 	            p++; 	            st1.push_back(num); 	        } 	         else 	         { 	            c++; 	            st2.push_back(num); 	         } 	    } 	} 	maxi=max(prime[p],comp[c]); 	//printf("%d %d %d\n",p,c,maxi); 	vector<int> ans(maxi+1); 	n=maxi+1; 	int n1,n2; 	n1=p; 	n2=c; 	    i=0; 	    it1=prime.begin(); 	    it1++; 	    for(it1=it1;(it1!=prime.end())&&(n1!=0);it1++) 	    { 	        ans[it1->second]=st1[i]; 	        //printf("%d %d\n",it1->second,st1[i]); 	        i++; 	        n1--; 	    } 	    i=0; 	    it1=comp.begin(); 	    it1++; 	    for(it1=it1;(it1!=comp.end())&&(n2!=0);it1++) 	    { 	        ans[it1->second]=st2[i]; 	       // printf("%d %d\n",it1->second,st2[i]); 	        i++; 	        n2--; 	    } 	for(i=0;i<n;i++) 	{ 	   printf("%d ",ans[i]); 	} 	return 0; }
#include <iostream> #include <cstdio> #include <cmath>  using namespace std;  long long fact(long long n) {     if ( n == 0 ) return 1;     return n*fact(n-1); }  int main() {     long long n,a,b,c1,c2;     int ans,temp;          scanf("%lld", &n);          while ( n-- ) {           c1 = 0;           c2 = 0;           scanf("%lld%lld", &a, &b);           ans = fact(a)/(fact(a-b)*fact(b));           //printf("%lld %lld\n", (int)(log10(ans)+1),int(log2(ans)+1));           temp = ans;           while ( temp ) {                 c1++;                 temp = temp/10;           }           while (  ans ) {                 c2++;                 ans = ans >> 1;           }            printf("%lld %lld\n", c1, c2);     }          return 0; }       
#include <stdio.h> #include <iostream> typedef long long ll; using namespace std; const int mod=10000007; int n,m,q;  char buf[21];int ix; int putchar_unlocked(char ch) { return putchar(ch);  } inline void writeL(int x) {      ix = 20;      buf[20] = '\n';      do       {         buf[--ix] = (x % 10) + '0';         x/= 10;      }while(x);      do      {         putchar_unlocked(buf[ix]);      } while (buf[ix++] != '\n'); }   int getchar_unlocked()  {return getchar();} inline void Read(int &x) { 	register int c= getchar_unlocked(); 	x = 0; 	for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked()); 	for(; c>47 && c<58 ; c = getchar_unlocked()) { 		x = (x<<1) + (x<<3) + c - 48; 	} }  struct node { int sum,type; } arr[500009];   void  update(int node,int type,int px,int py,int qx,int qy,int xx,int yy,int upd) { if(px==qx and py==qy and px==xx and py==yy) { arr[node].sum=upd; return; } int left,mid,right; 	left=node<<1; 	right=left+1; if(type==1){ 	mid=(px+qx)/2; 	if(xx<=mid) 	update(left,0,px,py,mid,qy,xx,yy,upd); 	else 	update(right,0,mid+1,py,qx,qy,xx,yy,upd); 	 }else{ 	mid=(py+qy)/2; 	if(yy<=mid) 	update(left,1,px,py,qx,mid,xx,yy,upd); 	else 	update(right,1,px,mid+1,qx,qy,xx,yy,upd); } arr[node].sum=arr[left].sum+arr[right].sum;  }   int query(int node,int type,int px,int py,int qx,int qy,int x1,int y1,int x2,int y2){ 	 if(px==x1 and py==y1 and qx==x2 and qy==y2) { return arr[node].sum; } int left,mid,right; 	left=node<<1; 	right=left+1; if(type==1){ 	mid=(px+qx)/2; 	if(x2<=mid) 	return query(left,0,px,py,mid,qy,x1,y1,x2,y2); 	else if(x1>mid) 	return query(right,0,mid+1,py,qx,qy,x1,y1,x2,y2); 	else return query(left,0,px,py,mid,qy,x1,y1,mid,y2) + query(right,0,mid+1,py,qx,qy,mid+1,y1,x2,y2); }else{ 	mid=(py+qy)/2; 	if(y2<=mid) 	return query(left,1,px,py,qx,mid,x1,y1,x2,y2); 	else if(y1>mid) 	return query(right,1,px,mid+1,qx,qy,x1,y1,x2,y2); 	else return query(left,1,px,py,qx,mid,x1,y1,x2,mid) + query(right,1,px,mid+1,qx,qy,x1,mid+1,x2,y2); } }     int main(){ 	int i,j,k,ii; 	Read(n); Read(m); 	for(i=0;i<n;i++) for(j=0;j<m;j++){Read(ii); update(1,1,0,0,n-1,m-1,i,j,ii); } 	Read(q); 	while(q--){ 		int px,py,qx,qy; 		Read(px);Read(py);Read(qx);Read(qy); 		writeL(query(1,1,0,0,n-1,m-1,px-1,py-1,qx-1,qy-1) ); 	} 	return 0; } 
#include<cstdio> using namespace std; //int getchar_unlocked()  {return getchar();} inline void fastRead_int(int &x) { 	register int c = getchar_unlocked(); 	x = 0; 	for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked()); 	for(; c>47 && c<58 ; c = getchar_unlocked()) { 		x = (x<<1) + (x<<3) + c - 48; 	} }  int main(){ 	int t,n;//,i,j,k,min; 	scanf("%d",&t); 	while(t--){ 		fastRead_int(n); 		n--; 		printf("%d\n",4*n*n+5*n+1); 	} 	return 0; } 
#include <stdio.h> #include <iostream> typedef long long ll; using namespace std; const int mod=10000007; int n,a,b;  char buf[21];int ix; //int putchar_unlocked(char ch) { return putchar(ch);  } inline void writeL(int x) {      ix = 20;      buf[20] = '\n';      do       {         buf[--ix] = (x % 10) + '0';         x/= 10;      }while(x);      do      {         putchar_unlocked(buf[ix]);      } while (buf[ix++] != '\n'); }   //int getchar_unlocked()  {return getchar();} inline void Read(int &x) { 	register int c= getchar_unlocked(); 	x = 0; 	for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked()); 	for(; c>47 && c<58 ; c = getchar_unlocked()) { 		x = (x<<1) + (x<<3) + c - 48; 	} }  int get(int v){ 	int ans=0; 	while(v>0){ 		ans+=(v&1); 		v=v>>1; 	} 	return ans; }  int ret(int bits){ 	int s=n,ans=0; 	while(s--){ 		ans<<=1; 		if(bits> 0){ ans+=1;bits--;} 	} 	return ans; }  int main(){ 	int t,i,j,k,ii; 	Read(t); 	while(t--){ 		Read(n); Read(a); Read(b); 		ii=get(a)+get(b); 		ii=(ii<=n)?ii:2*n-ii; 		writeL(ret(ii)); 	} 	return 0; } 
#include<iostream> #include<vector> #include<algorithm> #include<cstdio> #include<cstdlib> #include<string.h> #include<cstring> using namespace std; int revint(int x) { 	int y=0; 	while(x!=0) 	{ 	  y=y*10+(x%10); 	  x=x/10; 	} 	 return y; } main() { 	int t;cin>>t; 	while(t--) 	{       int n1,n2;       cin>>n1>>n2;       n1=revint(n1);       n2=revint(n2);       n1=n1+n2;       cout<<revint(n1)<<endl; 	} }
#include<iostream> using namespace std; int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		long int n; 		cin>>n; 		int a[8]; 		int len=0; 		int m=n; 		while(m>0) 		{ 			a[len++]=m%10; 			m=m/10; 		} 	//	cout<<len; 		if((len)%2==0) 		{ 			int flag=0; 			int i,j; 	    	for(i=len-1,j=0;i>j;i--,j++) 	      { 	     		  if(i!=j+1) 	     		  { 	     		  	if(a[i]!=a[j]) 	     		  	{ 	     		  		flag=1; 	     		  		a[j]=max(a[i],a[j]); 	    	     	a[i]=a[j]; 					   } 				  } 				   else 				   { 				   	  if(!flag) 				   	  { 				   	  	if(a[i]==a[j]) 				   	  	a[i]=a[i]+1,a[j]=a[j]+1; 				   	  	else 				   	  	{ 				   	  	 a[j]=max(a[i],a[j]); 	    	     	       a[i]=a[j]; 					 } 				   	  	 					  } 				   } 	      		  } 	    } 	    else 	    { 	    	int flag=0; 	    	int i,j; 	     	    	for(i=len-1,j=0;i>j;i--,j++) 	    	{ 	    		if(a[i]!=a[j]) 	    		{ 	    		flag=1; 	    		a[j]=max(a[i],a[j]); 	    		a[i]=a[j]; 	    	    } 	    		 			} 			if(!flag) 			a[i]=a[i]+1; 		} 		for(int i=len-1;i>=0;i--) 		{ 			cout<<a[i]; 		} 		cout<<"\n"; 	} 	 }
#include<iostream> #include<stdio.h> #include<string.h> #include<stdlib.h> #define MAXSIZE 1000000  using namespace std;  int main() { 	 	int t, i, n, flag; 	char *s;  	scanf("%d", &t );  	while( t-- ) {  		s = new char[ MAXSIZE ];		 		scanf("%s", s );	 		n = strlen( s );  		if( n == 1 ) 			printf("valid\n"); 		else {  			flag = 1;  			for( i = 0;i < n - 1;i++ ) 				if( s[ i ] > s[ i + 1 ] ) { 			 					flag = 0; 					break;			 				} 			if( flag ) 				printf("valid\n");  			else { 			 					flag = 1; 				 					for( i = 0;i < n - 1;i++ ) 						if( s[ i ] < s[ i + 1 ] ) { 			 							flag = 0; 							break;			 						} 					if( flag ) 						printf("valid\n"); 					else 						printf("invalid\n"); 			} 		} 		delete s; 	}  	return 0; } 
#include<iostream> #include<stdio.h> #include<vector> #include<iterator> #include<algorithm>  using namespace std;  static bool func( int a, int b ) { 	 	return ( a <= ( b + 1 ) ); }  int main() { 	 	int t, n, i, flag, j, temp;  	scanf( "%d", &t );  	while( t-- ) { 		 		scanf("%d", &n ); 		vector<int> A( n );  		for( i = 0;i < n;i++ ) 			scanf("%d", &A[ i ] ); 		 		flag = 1; 		for( i = 0;i < n - 1;i++ ) 			if( A[ i ] < A[ i + 1 ] ) { 				 				flag = 0; 				break;			 			}  		if( flag ) {  			copy( A.begin(), A.end(),ostream_iterator<int> ( cout, " " ) ); 			printf("\n");		 		}  		else {  			flag = 1; 			for( i = 0;i < n - 1;i++ ) 				if( A[ i ] > A[ i + 1 ] ) { 				 					flag = 0; 					break;			 				} 			if( flag ) {  				copy( A.begin(), A.end(),ostream_iterator<int> ( cout, " " ) ); 				printf("\n");		 			}  			else { 				 				for( i = 0;i < n;i++ ) { 					for( j = 0;j < n - 1;j++ ) { 						if( A[ j ] > ( A[ j + 1 ] + 1 ) ) { 								 							temp = A[ j ]; 							A[ j ] = A[ j + 1 ]; 							A[ j + 1 ] = temp; 						 						} 					} 				}  				copy( A.begin(), A.end(),ostream_iterator<int> ( cout, " " ) ); 				printf("\n");		  			}  		}		 		 	}  	return 0; } 
#include<bits/stdc++.h> using namespace std; long long a[1000000],b[1000000]; int main() {     long long n,k,i,j,c=0,yo=0;     long long sum=0;     scanf("%lld%lld",&n,&k);     for(i=0;i<n;i++)         scanf("%lld",&a[i]);     for(i=0;i<k;i++)         sum+=a[i];     b[c++]=sum;     for(i=k;i<n;i++)     {         sum-=a[yo++];         sum+=a[i];         b[c++]=sum;     }    // for(i=0;i<c;i++)      //  printf("%d ",b[i]);     long long t;     scanf("%lld",&t);     while(t--)     {         long long s,x;      scanf("%lld%lld",&s,&x);      long long f=0;      sum=0;     yo=0;      for(i=0;i<s;i++)         sum+=b[i];     if(sum==x)         f=1;     else      for(i=s;i<c;i++)      {          sum-=b[yo++];          sum+=b[i];          //printf("%lld ",sum);          if(sum==x)          {              f=1;              break;          }      }      if(f==1)         printf("YES\n");      else         printf("NO\n");     }     return 0; } 
#include<stdio.h> //#include<conio.h> int main() {     long int n1,n2,i,j,diff,min=10000000;     scanf("%ld",&n1);     long int a[n1];     for(i=0;i<n1;i++)     scanf("%ld",&a[i]);     scanf("%ld",&n2);     long int b[n2];     for(i=0;i<n2;i++)     scanf("%ld",&b[i]);     for(i=0;i<n1;i++)     for(j=0;j<n2;j++)     {                      diff=a[i]-b[j];                      if((a[i]-b[j])<0)                      diff=-diff;                      if(diff<min)                      min=diff;     }     printf("%ld\n",min);     //getch();     return 0; } 
#include<bits/stdc++.h> using namespace std;  int main(){      string a;     vector<string>v;     int i,start=0;     getline(cin,a);      for(i=0;i<a.length();i++){         if(a[i]==' '){             //cout<<"init start "<<start<<' '<<i<<endl;             string temp=a.substr(start,i-start);             reverse(temp.begin(),temp.end());             //cout<<temp<<endl;             v.push_back(temp);             start=i+1;         //cout<<"final start "<<start<<' '<<i<<endl;         }     }     string temp=a.substr(start,a.length()-start-1);     reverse(temp.begin(),temp.end());     v.push_back(temp);      for(i=0;i<v.size()-1;i++){         cout<<v[i]<<' ';     }     cout<<v[v.size()-1]<<a[a.length()-1]<<endl;    } 
#include<iostream> using namespace std; int main() {     long int t;     cin>>t;     for(int i=0;i<t;i++)     {         long int n;         cin>>n;         if(n%4==0)             cout<<"Second"<<endl;         else             cout<<"First"<<endl;     }     return 0; } 
#include <iostream> #include <list> #include <cstdio> #include <cstring> using namespace std; typedef long long int int64;  int m2 (int i) {return (i+30000) % 2;}  void incrt (int64 t[2][2], int x, int y, int64 s) {   t[m2 (x)][m2 (y)] = t[m2 (x)][m2 (y)] + s;}  void incrt2 (int64 t[2], int x, int64 s) {   t[m2 (x)] = t[m2 (x)] + s;}  void print_t (int64 t[][2]){   cout << "00 " << t[0][0] << " 01 " << t[0][1] <<     " 10 " << t[1][0] << " 11 " << t[1][1] << endl;}  int64 solve () {   int n; scanf("%d",&n);   int64 a [2][2]; int64 b [2][2]; int64 c [2][2]; int64 d [2][2];   int64 ac [2][2]; int64 bd [2][2];   int64 rep [] = {0, 0};    int i,j,k,l;   for (i=0; i<2; i++){     for (j=0; j<2; j++){       a[i][j]=0; b[i][j]=0; c[i][j]=0; d[i][j]=0; ac[i][j]=0; bd[i][j]=0;}   }   //lecture des données     int x,y;   for (i=1;i <= n;i++){     scanf("%d %d",&x,&y);     //cout << "x=" << x << " y=" << y << endl;     if (x > 0 & y > 0) {incrt (a, x, y, 1);}      if (x > 0 & y < 0) {incrt (b, x, y, 1);}      if (x < 0 & y < 0) {incrt (c, x, y, 1);}      if (x < 0 & y > 0) {incrt (d, x, y, 1);}    }   //print_t (a); print_t (b); print_t (c); print_t (d);   for (i=0; i<2; i++){     for (j=0; j<2; j++){       for (k=0; k<2; k++){ 	for (l=0; l<2; l++){ 	  incrt (ac, i+k, j+l, a[i][j] * c[k][l]);}}}}   for (i=0; i<2; i++){     for (j=0; j<2; j++){       for (k=0; k<2; k++){ 	for (l=0; l<2; l++){ 	  incrt (bd, i+k, j+l, b[i][j] * d[k][l]);}}}}   //print_t (ac); print_t (bd);   for (i=0; i<2; i++){     for (j=0; j<2; j++){       for (k=0; k<2; k++){ 	for (l=0; l<2; l++){ 	  incrt2 (rep, (i*l + j*k), ac[i][j] * bd[k][l]);}}}}   return rep[0]; }  int main () {   int t;   cin >> t;   //cout << "t=" << t << endl;   for (int i=1; i<=t; i++){   cout << solve () << endl;   }  return 0; }  
#include<bits/stdc++.h> using namespace std; int main() { int n,a[100009],i,pos=0,uu,ll,u,l,j;   scanf("%d",&n);   for(i=0;i<n;i++)   scanf("%d",&a[i]);      uu=ll=u=l=a[0];      for(i=1;i<n;i++)   { if(a[i]==u+1)       ++u;     else if(a[i]==l-1)     { --l;   	  pos=i;   	  ll=l;   	  uu=u;     }     else if(a[i]<l-1)     {  	  for(j=i;j<n;j++)       if(l>1)       { a[j]=l-1;       	--l; 	  }   	  else if(u<n) 	  { a[j]=u+1; 		++u; 	  } 	   	  break; 	} 	else if(a[i]>u+1) 	{ a[pos]=uu+1; 	  ++uu; 	  ++ll; 	   	  for(j=pos+1;j<n;j++)         if(ll>1)       	{ a[j]=ll-1;       	  --ll; 		}   		else if(uu<n) 		{ a[j]=uu+1; 		  ++uu; 	    } 	   	  break;	 	}    }    for(i=0;i<n;i++)  printf("%d ",a[i]);     return 0; }
#include<iostream> #include<algorithm>  using namespace std;  int main() { 	int n; cin>>n; 	long arr[n]; 	 	for(int i=0;i<n;i++) 	cin>>arr[i]; 	sort(arr,arr+n); 	 	int counter=0; 	for(int i=0;i<n-1;i++) 	{ 		if(arr[i]==arr[i+1]) 		counter++; 	} 	cout<<counter<<endl; 	 	return 0; }
#include <stdio.h> #include <stdlib.h>  int main() {     int n,m,i,j,l,c;     int a[20][20];     scanf("%d",&n);     scanf("%d",&m);     for(i=0;i<n;i++)     for(j=0;j<m;j++)     scanf("%d",&a[i][j]);      // Check all chairs in a row     for(i=0;i<n;i++)     {         l=a[i][0];         for(j=1;j<m;j++)         {             if(a[i][j]==l)             c=1;             else             {                 c=0;                 break;             }         }         if(c==1)         continue;         else         break;     }     for(i=0;i<n-1;i++)     {         if(c==1)         {             for(j=0;j<m;j++)             {                 if(a[i][j]==a[i+1][j])                 {                     c=0;                     break;                 }             }             if(c==0)             break;         }         else         break;     }     if(c==1)     printf("YES\n");     else     printf("NO\n");     return 0; }
#include<stdio.h> #include<iostream> #include<stdlib.h> #include<string.h> #include<math.h> #include<vector> #include<queue> #include<stack> #include<algorithm> #include<map> #include<limits>  #define min(a,b) (a>b?b:a) #define max(a,b) (a>b?a:b) #define si(n) scanf("%d",&n) #define sc(n) scanf("%c",&n) #define sll(n) scanf("%lld",&n) #define sull(n) scanf("%llu",&n) #define ss(str) scanf("%s",str) #define sf(n) scanf("%f",&n) #define sd(n) scanf("%lf",&n) #define I int  #define ll long long int #define ull unsigned long long int  #define mod(a) (a<0?-a:a) #define as_0 48 #define as_A 65 #define as_a 97 #define mem1(a) memset(a,0,sizeof(a)) #define mem2(a) memset(a,0,sizeof a)  //#include<conio.h>  using namespace std; void find_primes(vector<int> &primes, int n) {   int i,j;   int arr[n+5];   mem1(arr);      for(i=4;i<n+1;i+=2)   arr[i]=1;      for(i=3;i*i<n+1;i+=2)   {                          if(arr[i]==0)                          for(j=i*i;j<n+1;j=j+i)                          arr[j]=1;   }      primes.push_back(1);   for(i=2;i<=n;i++)   if(arr[i]==0 && 2*i>n)   {primes.push_back(i);}  } int main() {      //freopen("input.txt","r",stdin);    //freopen("output.txt","w",stdout);        char str[1009];    ss(str);        int arr[30];mem1(arr);        int i;    for(i=0;i<strlen(str);i++)    arr[str[i]-as_a]++;        //for(i=0;i<26;i++) printf("%d ",arr[i]);        int n=strlen(str);        vector<int> primes;    find_primes(primes,n);            int x=n-primes.size();        //for(i=0;i<primes.size();i++) printf("%d ",primes[i]);        for(i=0;i<=25;i++)    if(arr[i]>=x)    break;        if(i==26)    printf("NO\n");    else    {        printf("YES\n");        char str2[n+10];        int j,k;                for(j=0;j<n;j++)        {                        int z=binary_search(primes.begin(),primes.end(),j+1);                        //printf("z=%d\n",z);                        if(z==0)                        {str2[j]=(char)(i+as_a);                        arr[i]--;}        }                for(i=0;i<primes.size();i++)        {                                    for(j=0;j<26;j++)                                    if(arr[j]>0)                                    {                                                str2[primes[i]-1]=(char)(j+as_a); arr[j]--; break;                                    }        }        str2[n]='\0';        printf("%s",str2);    }   getchar();   getchar();  //getch();  return 0;  } 
#include<iostream> #include<cmath> using namespace std; int main() {     int n,m,a;     cin>>n>>m>>a;     if(m>n){         int t=m;         m=n;         n=t;     }          int sum=1,top=0;     if (n > a){     top = int(ceil(n * 1.0 / a));     sum = top;     }   if (m > a){     sum += top * (int(ceil((m * 1.0 - a) / a))); } cout<<sum<<endl;   }
#include<cstdio> #include<queue> #include<cstring> using namespace std;  char Cell[101][101]; int dx[] = { 0, 1, 1, 1,-1,-1,-1, 0 }; int dy[] = { 1, 0, 1,-1, 1,-1, 0,-1 }; int N,L,Visited[101][101],Distance[101][101];  int isSafe(int x, int y) {     return (  (x>=0 && x<N && y>=0 && y<L)  &&  Visited[x][y]==0 && Cell[x][y]=='0'  ); }  int Bfs(int i, int j) {     int dir,read=1;     Distance[i][j]=read;     Visited[i][j]=1;     queue<pair<int, int> > q;     q.push(make_pair(i,j));          while(!q.empty())     {       pair<int, int> pr;       pr=q.front();       q.pop();       int x=pr.first;       int y=pr.second;       for(dir=0; dir<8; dir++)       {           int xx=x+dx[dir], yy=y+dy[dir];           if( isSafe(xx,yy) ) {  q.push(make_pair(xx,yy));  Visited[xx][yy]=1;  Distance[xx][yy] = Distance[x][y]+1;  }       }       read=read+1;    }   return Distance[N-1][L-1]; }  int main() {     int i;     scanf("%d",&N);     for(i=0; i<N; i++)  scanf("%s",Cell[i]);     L=strlen(Cell[0]);     printf("%d\n",Bfs(0,0));   return 0; }
using namespace std;   #include<iostream>   int main() {     char arr[51], temp;     int no, count=0, i, j;     scanf("%d",&no);     scanf("%s",arr);     for(i=0; i<no; i++)     {         temp=arr[i];         for(j=i+1; arr[j]==temp; j++, count++)         i=j-1;     }     cout<<count;      return 0; }
#include<stdio.h>  long long Cval[1024];  long long C(int n) { 	if(Cval[n] != -1) 		return Cval[n]; 	long long ans=0; 	if(n==0) 	ans=1; 		 	for(int i=1; i<=n; i++) 	ans+=C(i-1) * C(n-i); 	 	ans=ans%100003; 	 	return (Cval[n]=ans); }  int main(void) { 	for(int i=0; i<1023; i++) 	Cval[i]=-1; 	 	int T, N; 	 	scanf("%d",&T); 	 	while(T--) 	{ 		scanf("%d",&N); 		 		printf("%lld\n",C(N)); 	} 	 	return 0; }
#include <iostream>  using namespace std;  char mat[105][105]; char color[105][105];  bool fine(int a,int b, int n)   {     return (a >= 1 && b >= 1 && a <= n && b <= n && color[a][b] == 'w' && mat[a][b] == 'S'); }  void call(int a,int b,int n)    {     color[a][b] = 'g';     if(fine(a-1,b-1,n))call(a-1,b-1,n);     if(fine(a-1,b,n))call(a-1,b,n);     if(fine(a-1,b+1,n))call(a-1,b+1,n);     if(fine(a,b-1,n))call(a,b-1,n);     if(fine(a,b+1,n))call(a,b+1,n);     if(fine(a+1,b-1,n))call(a+1,b-1,n);     if(fine(a+1,b,n))call(a+1,b,n);     if(fine(a+1,b+1,n))call(a+1,b+1,n);     color[a][b] = 'b'; }  int main() {      int t,n;scanf("%d",&t);     while (t--) {         scanf("%d",&n);         for(int i = 1; i <= n ; ++i)    {             scanf("%s",mat[i] + 1);         }          for(int i = 1; i <= n ; ++i)for(int j = 1; j <= n ; ++j)color[i][j] = 'w';          int components = 0;          for(int i = 1; i <= n ; ++i)    {             for(int j = 1; j <= n ; ++j)    {                 if(color[i][j] == 'w' && mat[i][j] == 'S'){call(i,j,n);++components;}             }         }          if(components & 1)printf("Alice\n");         else printf("Bob\n");      }      return 0; }
#include <bits/stdc++.h> using namespace std; int main()  {     int t,i,n;     string s;     scanf("%d",&t);     while(t--)     {         cin>>s;          n=s.size();         for( i=n-1;i>=0;i--)         {             if(s[i]=='4')             {                 s[i]='7';                 break;             }             else                 s[i]='4';          }         if(i<0)             cout<<"4"<<s<<endl;         else cout<<s<<endl;     }  } 
#include<cstdio> using namespace std; int main() { return 0;}
#include <bits/stdc++.h>  #define clr(x) memset((x), 0, sizeof(x)) #define all(x) (x).begin(), (x).end() #define pb push_back #define mp make_pair #define in(x) int (x); input((x)); #define x first #define y second typedef int itn;  //#define next next12345 //#define prev prev12345 #define left lefdsf232 #define right rig43783 #define x1 x12345 #define y1 y12345  using namespace std;  template<typename T> T gcd(T x, T y) {     while (y > 0) {         x %= y;         swap(x, y);     }     return x; }  template<class T> T lcm(T a, T b) {     return a / gcd(a, b) * b; }   template<class _T> inline _T sqr(const _T &x) {     return x * x; }  template<class _T> inline string tostr(const _T &a) {     ostringstream os("");     os << a;     return os.str(); }  typedef long double ld; typedef long long ll; typedef unsigned long long ull; typedef pair<int, int> PII; const ld PI = 3.1415926535897932384626433832795L;  template<typename T> inline void input(T &a) {     static int ed;     a = 0;     while (!isdigit(ed = getchar()) && ed != '-') { }     char neg = 0;     if (ed == '-') {         neg = 1;         ed = getchar();     }     while (isdigit(ed)) {         a = 10 * a + ed - '0';         ed = getchar();     }     if (neg) a = -a; }  template<typename T = int> inline T nxt() {     T res;     input(res);     return res; }  mt19937 generator;  bool check(int v) {     if (v < 2) return false;     for (int i = 2; i * i <= v; ++i) {         if (v % i == 0) {             return false;         }     }     return true; }  long long pw(long long a, long long n, long long m) {     ll res = 1;     while (n) {         if (n & 1ll) {             res = res * a % m;         }         a = a * a % m;         n >>= 1;     }     return res; }   void pre() { }  void gen() { }  const int N = 3000;  vector <int> g[N];  int dp[N][N];  int leaves[N];  int l;  void dfs(int v, int p) {     int ch = 0;     leaves[v] = 0;     for (int to : g[v]) {         if (to == p) continue;         dfs(to, v);         leaves[v] += leaves[to];         ch += 1;     }      if (ch == 0) {         dp[v][0] = 0;         dp[v][1] = 1;         leaves[v] = 1;         return;     }      for (int i = 0; i <= leaves[v] && i <= l; ++i) {         dp[v][i] = 0x3f3f3f3f;     }      dp[v][0] = 0;     if (leaves[v] <= l) dp[v][leaves[v]] = 1;      int s = 0;      for (int to : g[v]) {         if (to == p) {             continue;         }         for (int k = min(s, l); k >= 0; --k) {             for (int j = 1; j <= leaves[to] && j + k <= l; ++j) {                 dp[v][k + j] = min(dp[v][k + j], dp[v][k] + dp[to][j]);             }         }         s += leaves[to];     } }  void read() {     int n = nxt();      for (int i = 1; i < n; ++i) {         int u = nxt() - 1;         int v = nxt() - 1;         g[u].pb(v);         g[v].pb(u);     }      for (int i = 0; i < n; ++i) {         l += g[i].size() == 1;     }     l /= 2;     int ans = l;     int z = 0;     vector <int> order(n);     iota(all(order), 0);     random_shuffle(all(order));     double mt;     while (z < n) {         int root = order[z++];         double start = clock();         dfs(root, root);         double end = clock();         if (z == 1) {             mt = end - start;         }         ans = min(ans, dp[root][l]);         if (end + mt > 1.9 * CLOCKS_PER_SEC) {             break;         }     }     cout << ans << "\n"; }   void solve2() { }   int main(int argc, char ** argv) {  #ifdef LOCAL     freopen("input.txt", "r", stdin);     //freopen("output.txt", "w", stdout); #else     #define fname "d"     //freopen(fname".in", "r", stdin);     //freopen(fname".out", "w", stdout); #endif     int t = 1;     pre(); #ifdef LOCAL #endif  //    test();      int c = 0;     while (t--) {         //gen();         read(); //        gen(); //        gen2();     }   #ifdef LOCAL     cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC * 1000 << " ms." << endl; #endif     return 0; }
#include<iostream> using namespace std; #include<vector>  #define mod 1000000007 vector<long long> f(100005+1,1); void fun(){       for (int i=2; i<=100005;i++)         f[i]= (f[i-1]*i) % mod; } long long pow(int a, int b, int MOD) {     long long x=1,y=a;     while(b > 0)     {         if(b%2 == 1)         {             x=(x*y);             if(x>MOD) x%=MOD;         }         y = (y*y);         if(y>MOD) y%=MOD;         b /= 2;     }     return x; }   /*  Modular Multiplicative Inverse     Using Euler's Theorem     a^(phi(m)) = 1 (mod m)     a^(-1) = a^(m-2) (mod m) */ long long InverseEuler(int n, int MOD) {     return pow(n,MOD-2,MOD); }   long long C(int n, int r, int MOD) {       return (f[n]*((InverseEuler(f[r], MOD) * InverseEuler(f[n-r], MOD)) % MOD)) % MOD; } int main() {        int t;    cin >>t;    fun();    while(t--)    {     int MOD=1000000007;        int n,k;        cin >>n>>k;        cout << C(n,k,MOD) <<endl;    }    return 0; }
#include<stdio.h> #include<string.h> #define ll long long #define limit (ll) 1e7 int P[limit+1]; int count=0;   void gen() {   memset(P,0,sizeof(P));   P[0]=-1,P[1]=-1;   ll k=0,i,j;   for(i=2;i<=limit;i++)   {      if(P[i]==0)      {         P[i]=++k;         for(j=i*i;j<=limit;j+=i)            P[j]=-1;      }   } }   int main() {     int t,n;     gen();     scanf("%d",&t);     while(t--)     {           scanf("%d",&n);           printf("%d\n",P[n]);     }     return 0; }  
#include<stdio.h> long long int pow(long int n,long int m) { 	long long int k; 	if(m==0) 		return 1; 	 	if(m==1) 		return n; 	 	k=pow(n,m/2);	 	if(m%2==0) 		return k*k; 	 	if(m%2==1) 		return k*k*n; } int main() { 	int  ans,n,i; 	scanf("%d",&n); 	for(i=0;i<=n;i++) 		if(pow(2,i)>n) 			break; 			 	ans=n-pow(2,i-1); 	ans=ans*2+1; 	printf("%d\n",ans); 	return 0; }
#include <bits/stdc++.h> using namespace std; char inp[100005]; int main() { 	int t; 	scanf("%d", &t); 	while(t--) 	{ 		int n; 		scanf("%d", &n); 		scanf("%s", inp); 		int ctr = 1, tot = 0; 		long long int ans = 0; 		map <int,int> M; 		for (int i = 0; i < n; ++i) 		{ 			if(inp[i] == 'c') 			{ 				ans+=M[tot]; 				ctr++; 			} 			else 			{ 				M[tot]+=ctr; 				ctr = 0; 				if(inp[i] == 'a') 					tot-=2; 				else 					tot+=3; 				ans+=M[tot]; 				ctr++; 			} 		} 		printf("%lld\n", ans); 	} 	return 0; } 
#include<iostream> #include<algorithm> using namespace std;  int main() { int t,pen,n,x,y,i;     scanf("%d",&t);     while(t--)     { pen=0;               scanf("%d%d%d",&n,&x,&y);               int a[n],b[n];               for(i=0;i<n;i++)                                              scanf("%d%d",&a[i],&b[i]);                               sort(a,a+n);                               sort(b,b+n);                                                          for(i=0;i<n;i++)                           {                                           if(a[i]==b[i])                                           continue;                                                                                   else   if(b[i]>a[i])                                                 pen+=(b[i]-a[i])*x;                                                                                    else                               pen+=(a[i]-b[i])*y;                               }                                              printf("%d\n",pen);               }               return 0;               } 
#include<iostream> #include<set> using namespace std; int main() { 	int t=10; 	while(t--) 	{ 		set<int> s; 		for(int i=0;i<10;i++) 		{ 			int n; 			cin>>n; 			if(n%42>=0) 			s.insert(n%42); 		} 		cout<<s.size()<<"\n"; 	} }
#include<iostream> using namespace std; int fi(int n)       {         int result = n;         for(int i=2;i*i <= n;i++)         {           if (n % i == 0) result -= result / i;           while (n % i == 0) n /= i;         }         if (n > 1) result -= result / n;         return result;       }  	 int main() { 	int t,n,ans; 	cin>>t; 	while(t--) 	{ 		cin>>n; 		cout<<fi(n)<<endl; 		 	} 	return 0; }
//{ #include<iostream> #include<cmath> #include<algorithm> #include<climits> #include<vector> #include<bitset> #include<cstdlib> #include<cstdio> #include<cstring> #include<ctime> #include<map> using namespace std; #define MOD 1000000007LL #define LL long long #define ULL unsigned long long #define LD long double #define MAX(a,b) ((a)>(b)?(a):(b)) #define MIN(a,b) ((a)<(b)?(a):(b)) #define ABS(x)   ((x)<0?-(x):(x)) #define SQR(x) ((x)*(x)) #define CUBE(x) ((x)*(x)*(x)) #define si(n) scanf("%d",&n) #define si2(n,m) scanf("%d %d",&n,&m) #define sf(n) scanf("%f",&n) #define sl(n) scanf("%ld",&n) #define sll(n) scanf("%lld",&n) #define slu(n) scanf("%llu",&n) #define sd(n) scanf("%lf",&n) #define ss(n) scanf("%s",n) #define pnl printf("\n") #define REP(i,n) for(int i=0;i<(n);i++) #define FOR(i,a,b) for(int i=(a);i<(b);i++) #define FORR(i,n,e) for(int i=(n);i>=(e);i--) #define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d)) #define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d))  //#undef mydebug #ifdef mydebug #define DB(x) cout<<#x<<"="<<(x)<<"\n" #define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n" #define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n" #define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n" #define pnld pnl; #else #define DB(x) #define DB2(x,y) #define DB3(x,y,z) #define DB4(x,y,z,a) #define pnld #endif #define FILL(a,b) memset(a,b,sizeof(a)) const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; //template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;} void DBG_ARR(const int A[],int N){cout<<"[";REP(i,N){cout<<A[i]<<" ";}cout<<"]\n";} void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;} ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} //} void precompute(){} void doThis(){     int C,Digit;     si2(C,Digit);     int count=0;     int ans=1;     int thisDigit;     while(count<C){         int j=ans;//we will check if this is valid or not         bool inValid=false;         while(j){             thisDigit=j%10;             j/=10;             if(thisDigit==Digit){                 inValid=true;                 break;             }         }          if(!inValid){             count++;         }         ans++;      }     ans-=1;     printf("%d\n",ans); }  int main(){ #ifdef amy freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr); #endif precompute(); int t=1; scanf("%d",&t); while(t--){doThis();} #ifdef amy fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC)); #endif return 0; } 
#include <iostream> #include <sstream> #include <cstdio> #include <cmath> #include <cstring> #include <cctype> #include <string> #include <vector> #include <list> #include <set> #include <map> #include <queue> #include <stack> #include <algorithm> #include <functional> using namespace std;  #define DEBUG(x) cout << '>' << #x << ':' << x << endl; #define REP(i,n) for(int i=0;i<(n);i++) #define FOR(i,a,b) for(int i=(a);i<=(b);i++) #define FORD(i,a,b) for(int i=(a);i>=(b);i--) inline bool EQ(double a, double b) { return fabs(a-b) < 1e-9; } const int INF = 1<<29; typedef long long ll; inline int two(int n) { return 1 << n; } inline int test(int n, int b) { return (n>>b)&1; } inline void set_bit(int & n, int b) { n |= two(b); } inline void unset_bit(int & n, int b) { n &= ~two(b); } inline int last_bit(int n) { return n & (-n); } inline int ones(int n) { int res = 0; while(n && ++res) n-=n&(-n); return res; } template<class T> void chmax(T & a, const T & b) { a = max(a, b); } template<class T> void chmin(T & a, const T & b) { a = min(a, b); }  /////////////////////////////////////////////////////////////////////  bool Vis[111][111]; long long dp[111][111]; int N; int Arr[111];   long long rec(int pos, int bche) { 	if(pos == N) return dp[pos][bche] = 0; 	if(bche == 0) return dp[pos][bche] = 0;  	if(Vis[pos][bche]) return dp[pos][bche]; 	Vis[pos][bche] = true;  	long long ans = rec(pos + 1, bche); 	long long sum = 0; 	for(int i = pos; i < N; ++i) { 		ans = max(ans, rec(i + 1, bche - 1) + sum + Arr[i]); 		sum += Arr[i]; 	}  	return dp[pos][bche] = ans; }  int main() { 	scanf("%d", &N); 	for(int i = 0; i < N; ++i) { 		scanf("%d", &Arr[i]); 	}  	memset(Vis, 0, sizeof Vis); 	for(int i = N; i >= 0; --i) { 		rec(0, i); 	}  	int Q; 	scanf("%d", &Q); 	while(Q--) { 		int M; 		scanf("%d", &M);  		int low = 0; 		int high = N;  		while(high - low > 2) { 			int mid = (low + high) >> 1; 			 			long long sum = dp[0][mid]; 			if(sum >= M) { 				high = mid; 			} else { 				low = mid; 			} 		}  		int Ans = -1; 		for(int i = low; i <= high; ++i) { 			long long ans = dp[0][i]; 			if(ans >= M) { 				Ans = i; 				break; 			} 		}  		if(Ans == -1) { 			puts("Not Possible"); 		} else { 			printf("%d\n", Ans); 		}  	}     return 0; }    
#include<bits/stdc++.h> using namespace std; int main() {     int t;     cin>>t;     while(t--) {         long int n;         cin>>n;         if(n&1) cout<<"BOB"<<endl;         else cout<<"ALICE"<<endl;     }     return 0; } 
#include <bits/stdc++.h> using namespace std; typedef long long int ll; #define F(i,a,b) for(int i = (int)(a); i <= (int)(b); i++) #define RF(i,a,b) for(int i = (int)(a); i >= (int)(b); i--) #define pb push_back #define mp make_pair int main() {     #ifndef ONLINE_JUDGE         freopen("input.txt","r",stdin);         freopen("output.txt","w",stdout);     #endif     int T,N;     T = 1;     while(T--)     {         N = 999;         int Fact[100000];         int digits,carry,mult;         digits = 1;         carry = 0;         Fact[0] = 1;         F(i,1,N)         {             F(j,0,digits-1)             {                 mult = Fact[j]*i + carry;                 Fact[j] = mult%10;                 carry = mult/10;             }             while(carry > 0)             {                 Fact[digits] = carry%10;                 carry /= 10;                 digits++;             }         }         printf("%d\n",digits);         RF(i,digits-1,0) printf("%d",Fact[i]);     }     return 0; }   
#include<cstdio> #include<vector> #include<queue> #include<algorithm> using namespace std; int dp[30000]={0},xtra[1005],mask[1005],a[]={2,3,5,7,11,13,17,19,23,29,31}; #define pp pair<int,int> #define ppp pair<pp,int> vector<int> G[1005]; int main() {     int t,i,j,l=0;     scanf("%d",&t);     for(i=1;i<=1000;i++)     {         int temp=i;         for(j=0;j<11;j++)         {             while(temp%a[j]==0)             {                 mask[i]|=(1<<j);                 temp/=a[j];             }         }         xtra[i]=temp;     }     while(t--)     {         int n,arr[1005],i,j,ans=0,val=0;         scanf("%d",&n);         for(i=0;i<n;i++)         {             //printf("i=%d\n",i);             scanf("%d",&arr[i]);             if(arr[i]==1)             {             	val++;             	continue;             }             if(xtra[arr[i]]>1)                 G[xtra[arr[i]]].push_back(mask[arr[i]]);             else             {             	//printf("i=%d\n",i);                 for(j=0;j<2048;j++)                 {                     //printf("j=%d\n",j);                     int m=mask[arr[i]];                     if((m&j)==0)                     {                         dp[m|j]=max(dp[m|j],dp[j]+1);                     }                     ans=max(ans,dp[j]);                 }             }         }         for(i=2;i<=1000;i++)         {             if(G[i].empty())                 continue;             int si=G[i].size(),temp[3000]={0},k;             for(k=0;k<si;k++)             {                 int v=G[i][k];                 for(j=0;j<2048;j++)                 {                     if((v&j)==0)                     {                         temp[v|j]=max(temp[v|j],dp[j]+1);                     }                 }             }             for(j=0;j<2048;j++)             {                 dp[j]=max(dp[j],temp[j]);                 ans=max(ans,dp[j]);             }             G[i].clear();         }         //printf("val=%d ans=%d\n",val,ans);         printf("%d\n",ans+val);         for(j=0;j<2048;j++)         	dp[j]=0;     }     return 0; } 
#include<iostream> #include<algorithm> #include<cstdio> #include<string.h> #include<climits> #include<vector> #include<stack> #include<set> #include<math.h> using namespace std; #define FOR(i,a,b) for(i=a;i<=b;i++) #define sint(i) scanf("%d",&i) #define ss(s) scanf("%s",s) #define pii pair<int,int> #define mp(i,j) make_pair(i,j) #define ll long long #define MAX 1000000000 #define MOD 1000000007 #define vi vector<int> #define vvi vector < vi > #define pb(i) push_back(i); #define tr(v,it) for(it=v.begin();it!=v.end();it++) int main() {     int i;     int t;     cin>>t;     while(t--)     {          int n;         cin>>n;         int a[n];         for(int i=0;i<n;i++)         {             cin>>a[i];             cout<<a[i];         }         cout<<endl;         int pos=-1;         for(int i=n-1;i>0;i--)         {             if(a[i]>a[i-1])             {                 pos=i-1;                 break;             }         }         if(pos==-1)         {             cout<<"NO NXTBIG\n";         }         else         {             int num=11,num_pos;             for(int i=pos;i<n;i++)             {                 if(a[i]>a[pos] && a[i]<=num)                 {                     num=a[i];                     num_pos=i;                 }             }             swap(a[num_pos],a[pos]);             reverse(a+pos+1,a+n);             for(int i=0;i<n;i++)             cout<<a[i];             cout<<"\n";         }     }     return 0; } 
#include <iostream>  using namespace std;  int palin(unsigned long long n) { 	unsigned long long m = 0,x = n;	 	while ( n > 0 ) { 		m = m*10 + n%10; 		n = n/10; 	} 	if ( m == x) return 1;	 	return 0; }  int main()	 { 	unsigned long long n,i,x; 	cin >> n; 	while ( n-- ) { 		cin >> x; 		for ( i = x;; i++ ) { 			if ( palin(i) == 1 ) { 				cout << i << endl; 				break; 			} 		} 	} 	return 0; }  
#include<iostream> #include<cstdio> #include<cstdlib> #include<cstring> #include<string> #include<cmath> #include<cctype> #include<algorithm> using namespace std; int ch[52][52]; int main() {     int n,t,i,j,x,s,m;     scanf("%d",&t);     while(t--)     {         scanf("%d",&n);         for(i=1; i<=n; i++)         {             for(j=1; j<=n; j++)             {                 scanf("%d",&ch[i][j]);             }         }         for(i=2; i<=n; i++)         {             for(j=1; j<=n; j++)             {                 ch[i][j]=ch[1][j]-ch[i][j];             }         }         x=0;         for(i=2; i<=n; i++)         {             s=ch[i][1];             for(j=2; j<=n; j++)             {                 if(ch[i][j]!=s)                 {                     x=1;                     break;                 }             }         }         if(x)             printf("No\n");         else             printf("Yes\n");     }     return 0; }
#include<bits/stdc++.h> using namespace std; int main() { 	int t; 	char a[101]; 	cin>>t; 	while(t--) 	{ 		cin>>a; 		int l=strlen(a); 		int sum=0; 		int count=0; 		for(int i=0;i<l;i++) 		{ 			count++; 			if(count==7) 			{ 				count=0; 				continue; 			} 			if(a[i]=='M') 			sum+=3; 			else 			sum=sum+4; 	}  	cout<<sum<<"\n"; 	} }
#include<bits/stdc++.h> using namespace std; int d[1005][3]; int ans[1005]; int main() { 	int t,sd,sh,sv,se,ps,pm,pl;     int a[3],c[3];     a[0]=4,a[1]=6,a[2]=8; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d%d%d%d%d%d%d",&sd,&sh,&sv,&se,&c[0],&c[1],&c[2]); 		int sum=sh+sv*2+se*3; 	  for(int i=0;i<=1000;i++) 	  ans[i]=1000000; 		memset(d,0,sizeof d); 		ans[0]=0; 		for(int i=0;i<=2;i++) 		{ 			for(int j=a[i];j<=1000;j++) 			{ 			//	cout<<a[i]<<endl; 			if(ans[j-a[i]]+c[i]<ans[j]) 			{ 				ans[j]=ans[j-a[i]]+c[i]; 			    for(int k=0;k<3;k++) 			    { 			    	if(i!=k) 			    	d[j][k]=d[j-a[i]][k]; 			    	else 			    	d[j][k]=d[j-a[i]][k]+1; 			    } 			} 			} 		} 		int j=sum; 	   while(ans[j]>=1000000) 	   j++; 		printf("%d %d %d\n",d[j][0],d[j][1],d[j][2]); 	} }
#include<bits/stdc++.h> using namespace std; int bob[100005],alice[100005],lalice[100005],lbob[100005]; int main() { 	int t,n,a1,a2,b1,b2; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d%d%d%d%d",&n,&a1,&a2,&b1,&b2); 		for(int i=0;i<=n;i++) 		{ 			bob[i]=0; 			alice[i]=0; 			lbob[i]=-1; 			lalice[i]=-1; 		} 		lalice[0]=0; 		lbob[0]=0; 		for(int i=1;i<=n;i++) 		{ 			int one=i-a1,two=i-a2; 			if(one>=0&&lbob[one]>=two) 			alice[i]=1; 			one=i-b1,two=i-b2; 			if(one>=0&&lalice[one]>=two) 			bob[i]=1; 			lalice[i]=lalice[i-1]; 			lbob[i]=lbob[i-1]; 			if(!alice[i]) 			lalice[i]=i; 			if(!bob[i]) 			lbob[i]=i; 		} 		if(alice[n]) 		printf("Alice\n"); 		else 		printf("Bob\n"); 	} }
    #include<iostream>     using namespace std;     #include<algorithm>     int main()     {         long long int t,arr[100001],i,n,sam,ma=-1;         cin>>t;         while(t--)         {             cin>>n;             ma=-1;             sam=1;             for(i=0;i<n;i++)             {                 cin>>arr[i];             }             sort(arr,arr+n);             for(i=0;i<n-1;i++)             {                // cout<<i<<endl;                 if(arr[i]==arr[i+1])                 {                     sam++;                 }                 else                 {                     ma=ma<sam?sam:ma;                     sam=1;                 }              }             cout<<(ma<sam?sam:ma)<<endl;          }     } 
#include <iostream> #include <string.h>   using namespace std;   int main() { 	 	int n; 	cin>>n; 	int a[n] ,counto=0,counte=0; 	for(int i=0;i<n;i++) 	{ 		cin>>a[i]; 	} 	for(int i=0;i<n;i++) 	{ 		 		if(a[i]%2==0) 		counte++; 		else if(a[i]%2==1) 		counto++; 	} 	 	int x=counte-counto; 	if(x>=0) 	cout<<x<<endl; 	else  	cout<<-x<<endl; 	 	return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		int n; 		scanf("%d",&n); 		int arr[n]; 		int i,j; 		for(i=0;i<n;i++) 		scanf("%d",&arr[i]); 		long long s1,s2; 		s1=s2=0; 		int c=0; 		for(i=0;i<(1<<n);i++) 		{ 			s1=0; 			s2=0; 			int e1,e2; 			e1=0; 			e2=0; 			for(j=0;j<n;j++) 			{ 				if(i&(1<<j)) 				{ 					s1+=arr[j];e1++; 				} 				else 				{ 					s2+=arr[j];e2++; 				} 			} 			if(n%2==0) 			{ 				if(e1==(n/2)&&e2==(n/2)) 				{ 					if(abs(s1-s2)%7==0) 					{ 						c=1; 						break; 					} 				} 			} 			else 			{ 				if((e1==(n/2)&&e2==(n+1)/2)||(e1==(n+1)/2&&e2==(n/2))) 				{ 					if(abs(s1-s2)%7==0) 					{ 						c=1; 						break; 					} 				} 			} 		} 		if(c==0) 		{ 			printf("Vignesh\n"); 		} 		else 		{ 			printf("Aravind\n"); 		} 	} 	return 0; } 
#include<stdio.h> #include<iostream> using namespace std; main(){ 	int n,ans=1; 	cin>>n; 	if(n==1) 		cout<<1<<endl; 	else if(n==2) 		cout<<2<<endl; 	else{ 		while(n>0){ 			if(n%2==1) 				ans=ans*2; 			n=n/2; 			} 		cout<<ans<<endl; 	}  }
#include <bits/stdc++.h> using namespace std; #define pb push_back #define mp make_pair #define ff first #define ss second #define ll long long #define sd(x) scanf("%d",&x) ll group[1000005]; ll size[1000005]; map<int,ll>ans; vector<pair<int,pair<int,int> > >v; ll val=0; int findroot(int x){     if(group[x]!=x)         group[x]=findroot(group[x]);     return group[x]; } void merge(int u,int v){     u=findroot(u);     v=findroot(v);     if(u!=v){        // cout<<"hello"<<endl;        // cout<<"u= "<<u<<" "<<size[u]<<endl;        // cout<<"v= "<<v<<" "<<size[v]<<endl;         val-=((ll)((size[u])*(size[u]-1))/2);         val-=((ll)((size[v])*(size[v]-1))/2);         size[u]+=size[v];         size[v]=0;         group[v]=u;         val+=((ll)((size[u])*(size[u]-1))/2);     } } int main(){     int n,m,q;     cin>>n>>m>>q;     for(int i=1;i<=n;i++){         group[i]=i;         size[i]=1;     }     for(int i=1;i<=m;i++){         int a,b,c;         sd(a);         sd(b);         sd(c);         v.pb(mp(c,mp(a,b)));     }     sort(v.begin(),v.end());     reverse(v.begin(),v.end());     for(int i=0;i<m;i++){         merge(v[i].ss.ff,v[i].ss.ss);         ans[v[i].ff]=val;     }     vector<int>yolo;     map<int,ll>::iterator it;     for(it=ans.begin();it!=ans.end();it++){         yolo.pb(it->ff);     }     while (q--) {         int r;         sd(r);         //map<int,ll>::iterator it;         vector<int>::iterator itt;         itt = lower_bound(yolo.begin(),yolo.end(),r);         if (itt == yolo.end()) {             puts("0");             continue;         }         printf("%lld ",ans[(*itt)]);     }     return 0; } 
#include<bits/stdc++.h> #define ll long long using namespace std; ll cnt; pair<ll,ll> st[100010]; ll d[100010]; inline void scanint(ll* x) { 	register char c = getchar_unlocked(); 	*x = 0; 	for(; (c<48)||(c>57);c = getchar_unlocked()); 	for(; (c>47)&&(c<58);c = getchar_unlocked()) 		*x = (ll)((((*x)<<1) + ((*x)<<3)) + c - 48); } inline void printint(ll n) { 	if(n == 0) 	{ 		putchar_unlocked('0'); 		putchar_unlocked('\n'); 	} 	else 	{ 		char buf[20]; 		buf[19] = '\n'; 		int i = 18; 		while(n) 		{ 			buf[i--] = n % 10 + '0'; 			n /= 10; 		} 		while(buf[i] != '\n') 			putchar_unlocked(buf[++i]); 	} }     ll* merge(ll* a,ll i, ll m,ll j){   ll x,y,z;   ll n1 = m-i+1;   ll n2 = j-m;   ll c[n1],d[n2];   for(x=0;x<n1;x++){      c[x]=a[i+x];   }   for(x=0;x<n2;x++){      d[x]=a[m+1+x];   }   x=0ll;   y=0ll;   z=i;    while(x<n1&&y<n2){     if(c[x]<=d[y]){       a[z]=c[x];       x++;     }     else{       cnt=cnt+n1-x;       a[z]=d[y];       y++;     }     z++;   }    while(x<n1){     a[z]=c[x];     z++;     x++;    }   while(y<n2){     a[z]=d[y];     z++;     y++;   }   return a; } void mergesort(ll *a,ll i, ll j){   if(i<j){   ll m = (i+j)/2;   mergesort(a,i,m);   mergesort(a,m+1,j);   merge(a,i,m,j);     } }    int main(){          ll t;      //   cin>>t;         scanint(&t);          while(t--){               cnt=0;               memset(st,0,sizeof(st));                              ll n,t1,i,v,ans=0,inp;            //   cin>>n>>t1;               scanint(&n);               scanint(&t1);                for(i=1;i<=n;i++){               //    cin>>inp[i]>>v;               scanint(&inp);               scanint(&v);                    st[i]=make_pair(inp,v);                } 			 sort(st+1,st+n+1);              for(i=0;i<n;i++){              	 d[i]=st[i+1].first+st[i+1].second*t1;              }  //           			mergesort(d,0,n-1);             printint(cnt);           }  } 
#include <iostream> #include <cstring> #include <vector> #include <queue> #include <cmath> #include <string>  using namespace std;  struct node{ 	int x,y,num; 	string seq; 	 	bool operator < (node X)const{          return num > X.num;     } 	 };   bool validNode(node n){ 	if(n.x+n.y <= 200 && n.x+n.y > 0) return true; 	return false;	 }  bool visited[201][201];  int main(){ 	int T; 	node st,sd; 	int a; 	cin>>T; 	 	 	while(T--){ 	cin>>a; 	string ans = "-1"; 	if(a%5 == 0) { 		cout<<ans<<endl; 		continue; 	} 	st.x = 1; st.y = 0;st.num = 8%a;st.seq = "8"; 	sd.x = 0; sd.y = 1;sd.num = 6%a;sd.seq = "6"; 	 	priority_queue<node> Q;     Q.push(st);     Q.push(sd);     memset(visited,false,sizeof(visited));                   node aux;     while(!Q.empty()){ 		aux = Q.top(); 		Q.pop(); 		 		if(visited[aux.x][aux.y]) continue; 		visited[aux.x][aux.y] = true;                  int anum = aux.num;          		if( anum == 0){ 			ans = aux.seq; 			break; 		}  		node n1,n2; 		n1.x = aux.x+1;n1.y = aux.y;n1.num = fmod((aux.num % a)+ fmod(8*pow(10,aux.x+aux.y),a),a);n1.seq = "8"+aux.seq; 		n2.x = aux.x;n2.y = aux.y+1;n2.num = (((aux.num)*(10))%a + 6%a)%a;n2.seq = aux.seq+"6"; 		 		 		if(validNode(n1))Q.push(n1); 		if(validNode(n2))Q.push(n2); 	}	 	 	cout<<ans<<endl;	 	 } 	return 0; } 
#include<cstdio> #include<cstring> using namespace std; int main() {     int n;     scanf("%d",&n);     int a[n][n];     memset(a,0,sizeof(a));     int i,j,k,c=0,m=n*n;     if(n%2==1)     {         while(m>0)             {             for(i=n-c-1;i>=c;i--)             a[n-c-1][i]=m--;             if(m<=0)             break;             for(i=n-c-2;i>=c;i--)             a[i][c]=m--;             if(m<=0)             break;             for(i=c+1;i<=n-c-1;i++)             a[c][i]=m--;             if(m<=0)             break;             for(i=c+1;i<n-c-1;i++)         a[i][n-c-1]=m--;         c++;          }     }     else     {         while(m>0)         {             for(i=c;i<=n-c-1;i++)             a[c][i]=m--;             if(m<=0)             break;             for(i=c+1;i<=n-c-1;i++)             a[i][n-c-1]=m--;             if(m<=0)             break;             for(i=n-c-2;i>=c;i--)             a[n-c-1][i]=m--;             if(m<=0)             break;             for(i=n-c-2;i>c;i--)             a[i][c]=m--;             c++;          }     }     for(i=0;i<n;i++)     {         printf("\n");         for(j=0;j<n;j++)         printf("%d\t",a[i][j]);      }     return 0; }   
#include<iostream> #include<cstring> using namespace std ; #define rep(i,a,b) for ( int i = (a) ; i < (b) ; i++ ) int ctr = 0 ; int gr[100][100] , vis[100][100] ; int N ; int dx[4]={1,0,0,-1}; int dy[4]={0,1,-1,0};  void dfs(int m , int n) { 	if ( m==N-1 && n== N-1) ctr++ ; 	vis[m][n]=true; 	if ( m+1<N && !vis[m+1][n] && gr[m+1][n]==0 ) dfs(m+1,n) ; 	if ( n+1<N && !vis[m][n+1] && gr[m][n+1]==0 ) dfs(m,n+1) ; 	if ( m-1>=0 && !vis[m-1][n] && gr[m-1][n]==0 ) dfs(m-1,n) ; 	if ( n-1>=0 && !vis[m][n-1] && gr[m][n-1]==0 ) dfs(m,n-1) ; 	vis[m][n]=false; }  int main ( ) {  	cin >> N ; 	rep(i,0,N) rep(j,0,N) cin >> gr[i][j] ; 	memset(vis,0,sizeof(vis)); 	dfs(0,0); 	cout << ctr << endl ; 	return 0 ; }
#include<cstdio> #include<fstream> typedef long long ll; #define M 1000000007 using namespace std; #define BUF 4096 char ibuf[BUF]; int ipt = BUF;  int readInt() { 	while (ipt < BUF && ibuf[ipt] < '0') ipt++; 	if (ipt == BUF) { 		fread(ibuf, 1, BUF, stdin); 		ipt = 0; 		while (ipt < BUF && ibuf[ipt] < '0') ipt++; 	} 	int n = 0; 	while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0'); 	if (ipt == BUF) { 		fread(ibuf, 1, BUF, stdin); 		ipt = 0; 		while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0'); 	} 	return n; } int cc[]={1 ,3 ,7 ,13 ,19 ,27 ,39 ,49 ,63 ,79 ,91 ,109 ,133 ,147 ,181 ,207 ,223 ,253 ,289 ,307 ,349 ,387 ,399 ,459 ,481 ,529 ,567 ,613 ,649 ,709 ,763 ,807 ,843 ,927 ,949 ,1009 ,1093 ,1111 ,1189 ,1261 ,1321 ,1359 ,1471 ,1483 ,1579 ,1693 ,1719 ,1807 ,1899 ,1933 ,2023 ,2161 ,2187 ,2269 ,2367 ,2479 ,2533 ,2703 ,2739 ,2799 ,2967 ,3019 ,3147 ,3199 ,3327 ,3421 ,3529 ,3619 ,3807 ,3841 ,3913 ,4083 ,4203 ,4249 ,4407 ,4603 ,4623 ,4783 ,4891 ,5067 ,5163 ,5293 ,5401 ,5547 ,5667 ,5767 ,5971 ,6109 ,6159 ,6387 ,6559 ,6589 ,6799 ,6927 ,7069 ,7219 ,7369 ,7483 ,7741 ,7849 ,7963 ,8173 ,8401 ,8419 ,8607 ,8847 ,8923 ,9193 ,9303 ,9511 ,9679 ,9889,10001}; int main(){ 	int t,n,i,j; 	scanf("%d",&t); 	while(t--){ 		scanf("%d",&n); 		for(i=0;cc[i]<=n;i++){ 			printf("%d ",cc[i]); 		} 		printf("\n"); 	} 	return 0; } 
    #include<iostream>     #include<cstdio>     #include<vector>     #include<string>     using namespace std;     int a[10000500];     int main()     {     int i;     int j;     int k;     int l;     int num;     int test;     int n;     a[1]=1;     a[2]=2;     a[3]=2;     l=4;     num=3;     for(i=4;l<10000000;i++)     {     j = a[i-1];     for(k=1;k<=j;k++)     {     a[l++]=num;     }     num++;     }     scanf("%d",&test);     while(test--){     scanf("%d",&n);     printf("%d\n",a[n]);     }     return 0;     } 
#include<iostream> using namespace std; int dp[10000000]; int main() {     int n,k;     cin>>n>>k;     dp[1]=1;     for(int i=2;i<=n;i++)     {         dp[i]=(dp[i-1]+(k-1))%i+1;      }     cout<<dp[n]<<endl;  } 
 /* Come on Code on!!!! re_hash dev_cpp */  #include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <cstring> #include <queue> #include <ctime> #include <cassert> #include <climits> #include <limits> using namespace std;  #define S(a) scanf("%d",&(a)) #define P(a) printf("%d",(a)) #define NL printf("\n") #define SL(a) scanf("%lld",&(a)) #define PL(a) printf("%lld",(a)) #define ll long long int #define FOR(I,A,B) for(int I= (A); I<(B); ++I) #define all(c) c.begin(), c.end() #define stop system("pause") #define pb push_back #define mp make_pair #define tr(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++)  int main(){     int t;     S(t);     while(t--){         int a,b;         int x,y;         S(a);S(b);S(x);S(y);         int mx = max(a-x,x-1);         int my = max(b-y,y-1);         P(mx+my);         NL;     }     return 0; }          
 /* Come on Code on!!!! re_hash dev_cpp */  #include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <cstring> #include <queue> #include <ctime> #include <cassert> #include <climits> #include <limits> using namespace std;  #define S(a) scanf("%d",&(a)) #define P(a) printf("%d",(a)) #define NL printf("\n") #define SL(a) scanf("%lld",&(a)) #define PL(a) printf("%lld",(a)) #define ll long long int #define FOR(I,A,B) for(int I= (A); I<(B); ++I) #define all(c) c.begin(), c.end() #define stop system("pause") #define pb push_back #define mp make_pair #define tr(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) #define INF 100000000  int main(){     int test;     S(test);     while(test--){         int n,t,m;         S(n);S(t);S(m);         t+=t;         int dp[1500];         dp[0]=0;         FOR(i,1,m+1){             int temp;             S(temp);             dp[i]=INF;             for(int j=i;j>=max(1,i-n+1);j--){                 dp[i]=min(dp[i],max(dp[j-1],temp)+t);             }         }         P(dp[m]-t/2);         printf(" ");         P((m-1)/n + 1);         NL;     }     return 0; }                                   
#include "stdio.h" #include "stdlib.h" #include <algorithm>  long long int nC2(long int i) {return ((i*(i-1))/2);}  long int n; int *array; long int *cumulative;  int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%ld",&n); 		array = new int [n]; 		cumulative = new long int [n]; 		for(long int index=0;index<n;index++) scanf("%d",array+index); 		cumulative[0] = array[0]; 		for(long int index=1;index<n;index++) cumulative[index] = cumulative[index-1] + array[index]; 		std::sort(cumulative,cumulative+n); 		long int current = cumulative[0]; 		long int count = 1; 		long long int result = 0; 		for(long int index=1;index<n;index++) 		{ 			if(cumulative[index]==current) count++; 			else  			{	 				result += nC2(count); 				if(current == 0) result += count; 				current = cumulative[index]; 				count = 1; 			} 		} 		result += nC2(count); 		if(current == 0) result += count; 		printf("%lld\n",result); 	}   	return 0; }
#include <iostream> #include <cstdio> #include <vector> #include <cstring> #include <string> #include <map>  using namespace std;  int main(){     int t;     scanf("%d",&t);     while(t--){                int n;                scanf("%d",&n);                vector <vector <int> > bomb(201,vector <int>(201,0));                int x,y;                for(int i=0;i<n;++i){                        scanf("%d%d",&x,&y);                        bomb[x][y]=1;                        }                int cc=0;                for(int i=0;i<=200;++i){                        for(int j=0;j<=200;++j){                                if(bomb[i][j]==0)                                                 continue;                                bool a,b,c,d;                                a=false;                                for(int ii=0;ii<j;++ii){                                        if(bomb[i][ii]==1){                                                           a=true;                                                           break;                                                           }                                        }                                b=false;                                for(int ii=j+1;ii<=200;++ii){                                        if(bomb[i][ii]==1){                                                           b=true;                                                           break;                                                           }                                        }                                c=false;                                for(int ii=0;ii<i;++ii){                                        if(bomb[ii][j]==1){                                                           c=true;                                                           break;                                                           }                                        }                                 d=false;                                for(int ii=i+1;ii<=200;++ii){                                        if(bomb[ii][j]==1){                                                           d=true;                                                           break;                                                           }                                        }                                                         if((a & b & c & d))                                      cc++;                                                 }                        //cout<<endl;                        //system("pause");                        }                printf("%d\n",cc);                }     return 0; }  
#include <cstdio>   #define MOD 1000000007   int fact[5001], invfact[5001];   int powmod(int base, int expo){     if(expo==0) 		return 1; 	else if(expo&1) 		return (long long)base*powmod(base, expo-1)%MOD; 	else{ 		int root=powmod(base, expo>>1); 		return (long long)root*root%MOD; 	} }   int inverse(int x){ 	return powmod(x, MOD-2); }   void init(){ 	fact[0]=1; 	for(int i=1; i<=5000; i++) 		fact[i]=(long long)i*fact[i-1]%MOD; 	invfact[5000]=inverse(fact[5000]); 	for(int i=5000; i>0; i--) 		invfact[i-1]=(long long)i*invfact[i]%MOD; }   int nCr(int n, int r){ 	if(r>n || r<0) 		return 0; 	return (long long)((long long)fact[n]*invfact[r]%MOD)*invfact[n-r]%MOD; }   int main(){ 	init(); 	int N, K; 	while(scanf("%d %d", &N, &K) && !(N==0 && K==0)){         if(K==0) {puts("0");continue;}         N = N/2;         		int res=2ll*nCr(N-1, (K)/2)*nCr(N-1, (K-1)/2)%MOD; 		printf("%d\n", res); 	} }  
#include <stdio.h> #include <stdlib.h> #include <string.h> #define Hash 1001007 using namespace std;  int fa[Hash],num[Hash]; int son[Hash],next[300001],tot; char str[300001][100]; int T,n,i,j,k,aim,a1,a2; char s1[100],s2[100],s[100];  int hash(char s[],int l) { 	int i; 	long long re=0; 	for(i=0;i<l;++i)re=(re*1456+s[i]+78114)%Hash; 	return re; }  int get(int p) { 	if(fa[p]==p)return p; 	fa[p]=get(fa[p]); 	return fa[p]; }  int main() { 	scanf("%d",&T); 	for(;T;--T) 	{ 		scanf("%d",&n); 		for(i=0;i<Hash;++i)son[i]=0; 		for(i=1;i<=n;++i) 		{ 			scanf("%s%s",s1,s2); 			a1=j=hash(s1,strlen(s1)); 			for(j=son[j];j;j=next[j])if(strcmp(str[j],s1)==0)break; 			a2=k=hash(s2,strlen(s2)); 			for(k=son[k];k;k=next[k])if(strcmp(str[k],s2)==0)break; 			if(!j){++tot;j=tot;memcpy(str[j],s1,sizeof(s1));next[tot]=son[a1];son[a1]=tot;fa[tot]=tot;num[tot]=1;} 			if(!k){++tot;k=tot;memcpy(str[k],s2,sizeof(s2));next[tot]=son[a2];son[a2]=tot;fa[tot]=tot;num[tot]=1;} 			j=get(j);k=get(k); 			if(j!=k) 			{ 				fa[j]=k; 				num[k]+=num[j]; 			} 			printf("%d\n",num[get(j)]); 		} 	} } 
#include <ios> #include <cstring> #include <algorithm> using namespace std;  const int MAX = 100; int dp[MAX][MAX], lcslen, len1, len2; char s1[MAX], s2[MAX], s3[MAX];  int lcs(int i, int j) { 	int &ret = dp[i][j]; 	if(i==len1 || j==len2) return ret = 0; 	if(ret != -1) return ret; 	ret = 0; 	if(s1[i]==s2[j]) ret = 1 + lcs(i+1, j+1); 	else ret = max(lcs(i+1, j), lcs(i, j+1)); 	return ret; }  void printAll(int na, int nb, int d) { 	if(d==lcslen) { 		s3[d] = 0; 		puts(s3); 		return; 	} 	if(na==len1 || nb==len2) return; 	for(char ch='a'; ch<='z'; ch++) { 		bool done = false; 		for(int i=na; i<len1; i++) { 			if(ch==s1[i]) { 				for(int j=nb; j<len2; j++) { 					if(ch==s2[j] && lcs(i, j)==lcslen-d) { 						s3[d] = ch; 						printAll(i+1, j+1, d+1); 						done = true; 						break; 					} 				} 			} 			if(done) break; 		} 	} }  int main() { 	int t, i, j; 	scanf("%d", &t); 	while(t--) { 		scanf("%s%s", s1, s2); 		len1 = strlen(s1); 		len2 = strlen(s2); 		for(i=0; i<len1; i++) 			for(j=0; j<len2; j++) 				dp[i][j] = -1; 		lcslen = lcs(0, 0); 		printAll(0, 0, 0); 		if(t) puts(""); 	} 	return 0; }
#include <iostream> #include <cstdio> #include <cmath> using namespace std; int main () {     char ch[10];     while (scanf("%s",ch)!=EOF)     {         int i,ans,n,e;         n=10*(ch[0]-'0')+ch[1]-'0';         e=ch[3]-'0';         if(!(n||e))break;         while (e--)          n*=10;         int c=1;         while (c<=n)          c<<=1;         ans=((n-(c>>1))<<1)+1;         printf("%d\n",ans);     }     return 0; }
#include<iostream> #include<cstdio> #include<cstring> #include<cmath>  using namespace std;  int n,m,ms; int set[1001][1001];  struct st{ 	int p,sz; }s[1001000];   int findSet(int x){ 	if( x!=s[x].p ) return s[x].p=findSet(s[x].p); 	return s[x].p; } void Union(int x,int y){  ///cout<<x<<" link "<<y<<endl; 	x=findSet(x); y=findSet(y); 	if( x==y ) return ; 	s[x].p=y; 	s[y].sz+=s[x].sz; 	ms=max(ms,s[y].sz); }  int main (){ 	scanf("%d %d",&n,&m); 	int q; scanf("%d",&q); 	for(int i=0;i<=n;i++) { 		 s[i].p=-1; s[i].sz=1; 	} 	for(int i=0;i<q;i++){ 		int c,a,b; 		scanf("%d",&a); 		if( a==0 ) printf("%d\n",ms); 		else { 			scanf("%d %d",&a,&b); // cout<<a<<" "<<b<<endl; 			if( set[a][b] ) continue; 			set[a][b]=1; ms=max(ms,1); 			 			c=(a-1)*m+b;  //cout<<"c"<<c<<endl; 			s[c].p=c; s[c].sz=1; 			 			if( a-1   && set[a-1][b])  Union(c, (a-2)*m+b); 			if( b-1   && set[a][b-1])  Union(c, (a-1)*m+b-1); 			if(a+1<=n && set[a+1][b])  Union(c, (a  )*m+b); 			if(b+1<=m && set[a][b+1])  Union(c, (a-1)*m+b+1); 			 		} 	} 	 	 	return 0; }
#include<iostream> #include<bits/stdc++.h> using namespace std; char s[200001]; int a[200001][26]={0}; int main() { 	 	cin>>s; 	long int q; 	cin>>q; 	long int l=strlen(s); 	for(int i=0;i<l;i++) 	{ 		for(int j=0;j<26;j++) 		{ 			if(i!=0) 			a[i][j]=a[i-1][j]; 		} 		a[i][s[i]-'a']++; 	} 	while(q--) 	{ 		long int l,r; 		cin>>l>>r; 		int ans=0; 		int flag=0; 		for(int i=0;i<26;i++) 		{ 			if(l!=1) 		    ans+=a[r-1][i]-a[l-2][i]; 		    else 		    ans+=a[r-1][i]; 		    if(ans%2!=0) 		    { 		    	ans=ans-1; 		    	flag=1; 			} 		     		} 		if(flag) 		{ 			ans=ans+1; 		} 		cout<<ans<<"\n"; 		 	} 	 }
#include<iostream> #include<cstring> using namespace std;   int main() { 	int i,j,k,t,n,f,count,len,len1; 	char str[10001]; 	cin>>t; 	while(t--) 	{ 	   cin>>str; 	  len=0; 	  len1=strlen(str)-1; 	   f=1; 	   count=0; 		while(len<len1) 		{ 		    if(str[len]!=str[len1]) 		    { 		    	if(count==0) 		    	count++; 		    	else 		    	{ 		    		f=0; 		    		break; 				} 			} 			len++; 			len1--; 		} 	      	if(f)      	cout<<"yes"<<endl;      	else      	cout<<"no"<<endl; 	} 	return 0; }  
#include <stdio.h> #include <string.h>   int main() {     int test_cases, i, cost_a, cost_b, totalcost;     scanf("\n%i", &test_cases);     char s[10001];     while(test_cases--)     {         scanf("\n%[^\n]", s);         scanf("\n%i\n%i", &cost_a, &cost_b);         int temp = strlen(s), flag = 1, min_cost = cost_a<cost_b ? cost_a : cost_b;         totalcost = 0;         for (i=0 ; i<temp/2; i++)         {             if (s[i]=='/' || s[temp-i-1]=='/')             {                 if (s[i] == s[temp-i-1])                     totalcost += 2*min_cost;                 else if (s[i]=='a' || s[temp-i-1]=='a')                     totalcost +=cost_a;                 else if (s[i]=='b' || s[temp-i-1]=='b')                     totalcost +=cost_b;             }             else if (s[i] != s[temp-i-1])             {                 flag = 0;                 printf("-1\n");                 break;             }         }         if (flag)             printf("%i\n",totalcost);     }     return 0; }
#include <bits/stdc++.h>  using namespace std;  #define FOR(i,a,b) for(int i=(a);i<(b);i++) #define SZ(x) ((int)(x).size()) #define FORV(i,x) FOR(i,0,SZ(x)) #define FORD(i,a,b) for(int i=(a);i>=(b);i--) #define MP make_pair #define PB push_back #define ALL(x) x.begin(),x.end() #define ULL unsigned long long #define LL long long #define mset(x,v) memset(x,v,sizeof x) #define F first #define S second  string s,x;  int main() { 	ios::sync_with_stdio(false); 	int t,n; 	cin>>t; 	while(t--) 	{ 		cin>>n>>s; 		x=s; 		reverse(ALL(x)); 		cout<<((x==s)?1:2)<<endl; 	} 	return 0; } 
#include <iostream> #include <cstdio> #include <cstring> using namespace std;  int main() {     int t, q;     scanf("%d", &t);     while(t--)     {         char a[100001];         scanf("%s", a);         scanf("%d", &q);         while(q--)         {             char word[100001], *p;             int c=0;             scanf("%s", word);             p=strstr(a, word);             while(p!=NULL)             {                 p=strstr(p+1,word);                 c++;             }             printf("%d\n", c);         }      }      return 0; } 
#include<iostream> #include<cstdlib> #include<cstdio> #include<vector> #include<climits> using namespace std;  int min(vector<int>& v) {   int j,minval=INT_MAX;   for(j=0;j<v.size();j++)   {     if(v[j]<minval) 		minval=v[j];   }   return minval; }  void print(vector<int>& x) {   int i;   for(i=0;i<x.size();i++) 	  cout << x[i] << " ";    cout << "\n"; } int main() { vector<int> v; vector<int> w; int t,i,n,n1,j,value,minval1,minval2,flag;  scanf("%d",&t); for(i=0;i<t;i++) {  flag=0;   scanf("%d",&n);   int size=v.size();   if(size!=0)   {    v.erase(v.begin(),v.begin()+size);   }     for(j=0;j<n;j++)   {    scanf("%d",&value);    v.push_back(value);   }   while(1)   { 	minval1=INT_MAX; 	minval2=INT_MAX;    if(v.size()==0 && w.size()==0)      break;    if(v.size()!=0)     minval1=min(v);    if(w.size()!=0)    minval2=min(w);    int l1=w.size();      if(minval1<minval2)    { 	if(v.size()!=0) 	{	       n1=v[0];      if(n1!=minval1) 	 { 	 w.push_back(n1);      }         v.erase(v.begin()); 	}      }     else    {     if(l1!=0)     {      int k1=l1-1;       n1=w[k1];     if(n1!=minval2)     {        flag=1;         w.erase(w.begin(),w.begin()+l1);     	break;     }     else      w.erase(w.begin()+k1);     } 	else 	 break;   }         }       if(flag==1)    printf("no\n");   else 	printf("yes\n");    } return 0; } 
#include <iostream> #include <string> #include <climits> #include <cstdio> #include <cstdlib> #include <cmath> #include <vector> #include <algorithm> #include <utility> #include <queue> #include <stack> #include <map> #include <set> #include <cstring> using namespace std; #define PR(x) cout << #x " = " << x << "\n"; #define EMPTY 2147483647 void orderify(std::vector<std::vector<int> > &p, int i, int j, int &count, int r, int c) { 	if (i>r || j>c) 	{ 		return; 	} 	int x=-1, y=-1;  	if (i+1<r && p[i+1][j]<p[i][j]) 	{ 		p[i][j]=p[i+1][j]; 		x=i+1; y=j; 	} 	if (j+1<c && p[i][j+1]<p[i][j]) 	{ 		p[i][j]=p[i][j+1]; 		x=i; y=j+1; 	}  	if (x!=-1) 	{ 		count++; 		p[x][y]=INT_MAX; 		orderify(p, x, y, count,r,c); 	} } int main(int argc, char const *argv[]) { 	ios_base::sync_with_stdio(0); 	int r,c, t,temp; cin>>t; 	while(t--) 	{ 		cin>>r>>c; 		std::vector<std::vector<int> > p(r, std::vector<int> ()); 		for (int i = 0; i < r; ++i) 		{ 			for (int j = 0; j < c; ++j) 			{ 				cin>>temp; 				p[i].push_back(temp); 				if (p[i][j]==EMPTY) p[i][j]=INT_MAX; 			} 		}  		p[0][0]=INT_MAX; 		int count=0; 		orderify(p,0,0,count,r,c); 		cout<<count<<endl; 	} 	return 0; }
#include <iostream> using namespace std;   int main() {     int t;          cin>>t;          while(t--)     {         int n,i,j,flag=0;                  cin>>n;                  int a[n][n];                  for(i=0;i<n;i++)         {             for(j=0;j<n;j++)             {                 cin>>a[i][j];             }         }                  int k=n/2;                  for(i=0;i<n;i++)         {             for(j=0;j<n;j++)             {                 if(a[i][j]!=a[n-1-i][n-j-1])                 {                     flag=1;                                  }             }         }                           if(flag==0)         cout<<"Yes"<<"\n";         else         cout<<"No"<<"\n";     } }
#include <queue> #include <algorithm> #include <iostream> #include <cmath> #include <cstdlib> #include <cstring> #include <numeric>  #define FOR(A,B,C) for(int A=B;A<C;A++) #define EFOR(A,B,C) for(int A=B;A<=C;A++) #define RFOR(A,B,C) for(int A=B;A>=C;A--) #define MEM(A,B) memset(A,B,sizeof(A)) #define PB(A,B) A.push_back(B); #define SZ(A) int(A.size()) #define MP(A,B) make_pair(A,B)  using namespace std;  inline void Input(int &N) { 	int ch; 	N=0;  	while((ch<'0'||ch>'9') && ch!=EOF) 		ch=getchar();  	do 		N=(N<<3)+(N<<1)+(ch-'0'); 	while((ch=getchar())>='0' && ch<='9');  	return; }  int R,C; /*int grid[3000][3000]; int mxD[2][3000]; int mnD[2][3000];  void optPath() { 	mxD[0][0]=mnD[0][0]=grid[0][0];  	FOR(cl,1,C){ 		mxD[0][cl]=mxD[0][cl-1]+grid[0][cl]; 		mnD[0][cl]=mnD[0][cl-1]+grid[0][cl]; 	}  	FOR(rw,1,R){ 		mxD[rw&1][0]=mxD[(rw-1)&1][0]+grid[rw][0]; 		mnD[rw&1][0]=mnD[(rw-1)&1][0]+grid[rw][0];  		FOR(cl,1,C){ 			mxD[rw&1][cl]=max(mxD[rw&1][cl-1],mxD[(rw-1)&1][cl])+grid[rw][cl]; 			mnD[rw&1][cl]=min(mnD[rw&1][cl-1],mnD[(rw-1)&1][cl])+grid[rw][cl]; 		} 	}  	printf("%d %d\n",mxD[(R-1)&1][C-1],mnD[(R-1)&1][C-1]);  	return; }*/  int main() { //	freopen("Input.txt","r",stdin); 	int T; 	Input(T);  	char A[3001],B[3001]; 	while(T--){ 		Input(R); 		scanf("%s",A);  		Input(C); 		scanf("%s",B);  		int firR1=-1,lstC1=-1,lstR1; 		int firR0=-1,firC0=-1,lstR0,lstC0;  		FOR(rw,0,R){ 			if(A[rw]=='1'){ 				firR1=(firR1==-1)?rw:firR1; 				lstR1=rw; 			} else { 				firR0=(firR0==-1)?rw:firR0; 				lstR0=rw; 			} 		}  		FOR(cl,0,C){ 			if(B[cl]=='1') 				lstC1=cl; 			else { 				firC0=(firC0==-1)?cl:firC0; 				lstC0=cl; 			} 		}  		int mx;  		if(firR1==-1 || lstC1==-1) 			printf("0 "); 		else { 			mx=0; 			EFOR(cl,0,lstC1)		mx+=(B[cl]-'0'); 			FOR(rw,firR1+1,R)		mx+=(A[rw]-'0'); 			printf("%d ",mx); 		}  		if(firR0==-1 && firC0==-1) 			printf("%d\n",R+C-1); 		else if(firR0==-1) 			printf("%d\n",count(B,B+C,'1')); 		else if(firC0==-1) 			printf("%d\n",count(A,A+R,'1')); 		else 			printf("%d\n",min(firR0,firC0)+min(C-1-lstC0,R-1-lstR0)); 	}  //	fclose(stdin); 	return 0; } 
#include<iostream> #include<fstream> #include<vector> #include<cstring> #include<map> #define in cin #define out cout using namespace std; const int Nmax = 1001; const int MOD1 = 734057; const int MOD2 = 941911; int d[2][Nmax][Nmax]; char s[Nmax+2]; map< pair<int,int>,vector< pair<int,int> > > M; int main(){     #ifndef ONLINE_JUDGE     ifstream in("test.in");     ofstream out("test.out");     #endif     d[0][0][1]=d[1][0][1]=1;     for(int i=1;i<Nmax;i++){         for(int j=1;j<Nmax;j++){             d[0][i][j]=(d[0][i-1][j]+d[0][i][j-1])%MOD1;             d[1][i][j]=(d[1][i-1][j]+d[1][i][j-1])%MOD2;             M[make_pair(d[0][i][j],d[1][i][j])].push_back(make_pair(i,j));         }     }     int T; in>>T; in.get();     while(T--){         in.getline(s+1,Nmax);         int n=strlen(s+1);         int m1=0,m2=0;         for(int i=1;i<=n;i++){             m1=(m1*10+(int(s[i])-'0'))%MOD1;             m2=(m2*10+(int(s[i])-'0'))%MOD2;         }         int mn=M[make_pair(m1,m2)].size();         if(mn==0) out<<"The Grid is Too Big!\n";         else{             out<<mn<<'\n';             for(vector< pair<int,int> >::iterator it=M[make_pair(m1,m2)].begin();it!=M[make_pair(m1,m2)].end();++it){                 out<<it->first<<' '<<it->second<<'\n';             }         }     }     return 0; }
#include <bits/stdc++.h> #define ll long long using namespace std; ll int ans,mat[30][30],visited[30][30]; ll int n,m; bool valid(int x,int y) { 		if(x>=0 && x<n && y>=0 && y<m && mat[x][y]==0 && !visited[x][y]) 		return 1; 		return 0; } void mydfs(ll int x,ll int y) { 	ll int p=0; 	if(valid(x,y)) 	{ 		visited[x][y]=1; 		if(valid(x+1,y)) 		{ 			p++; 		} 		if(valid(x-1,y)) 		{ 			p++; 		} 		if(valid(x,y-1)) 		{ 			p++; 		} 		if(valid(x,y+1)) 		{ 			p++; 		} 		if(valid(x+1,y)) 		{ 			mydfs(x+1,y); 		} 		if(valid(x-1,y)) 		{ 			mydfs(x-1,y); 		} 		if(valid(x,y-1)) 		{ 			mydfs(x,y-1); 		} 		if(valid(x,y+1)) 		{ 			mydfs(x,y+1); 		} 		if(p!=0) 		{ 			//~ cout<<p<<endl; 			ans*=p; 		} 	} } int main() { 	ios_base::sync_with_stdio(false); 	cin.tie(NULL); 	ll int test; 	cin>>test; 	while(test--) 	{ 		cin>>n>>m; 		ll int i,j; 		string s; 		for(i=0;i<n;i++) 		{ 			cin>>s; 			for(j=0;j<m;j++) 			{ 				mat[i][j]=(s.at(j)-'0'); 				visited[i][j]=0; 			} 		} 		ans=1; 		bool found=0; 		for(i=0;i<n;i++) 		{ 			for(j=0;j<m;j++) 			{ 				if(mat[i][j]==0) 				{ 					mydfs(i,j); 					found=1; 					break; 				} 			} 			if(found) 			break; 		} 		cout<<ans<<endl; 	} 	return 0; } 
#include <iostream> #include <climits> using namespace std; int eggDrop(int f, int e) { 	if(f <= 1) 		return f; 	int dp[f+1][e+1]; 	for(int i=0;i<=f;i++) 		for(int j=0;j<=e;j++) 			dp[i][j] = 0; 	for(int i=1;i<=f;i++) 	{ 		for(int j=1;j<=e;j++) 		{ 			if(j == 1) 			{ 				dp[i][j] = i; 				continue; 			} 			int currMin = INT_MAX; 			int tmp; 			for(int k=1;k<=i;k++) 			{ 				tmp = ((dp[k-1][j-1]+1)>dp[i-k][j]?(dp[k-1][j-1]+1):dp[i-k][j]); 				tmp++; 				if(tmp < currMin) 					currMin = tmp; 			} 			dp[i][j] = currMin; 		} 	} 	/* 	for(int i=0;i<=f;i++) 	{ 		for(int j=0;j<=e;j++) 			cout << dp[i][j] << " "; 		cout << endl; 	} 	*/ 	dp[f][e]++; 	return dp[f][e]; }   int main() { 	//code 	int tc; 	cin >> tc; 	int n,k; 	while(tc-- > 0) 	{ 	    cin >> n >> k; 	    cout << eggDrop(n,k) << endl; 	} 	return 0; } 
#include<stdio.h> #include<math.h> #define ld long double  ld abs(ld a) { return a>0?a:-a; } ld max(ld a, ld b) { return a>b?a:b; }  int main()  { 	int N, min_index = 0; 	scanf("%d", &N); 	ld ave_x = 0.0, ave_y = 0.0, min, sum = 0.0, x[N+1], y[N+1]; 	 	for(int i=0; i<N; i++)  scanf("%Lf%Lf",&x[i],&y[i]); 	 	for(int i=0; i<N; i++)  	{ 		ave_x += x[i]/(ld)N; 		ave_y += y[i]/(ld)N; 	} 	 	min = sqrt((ave_x-x[0])*(ave_x-x[0]) + (ave_y-y[0])*(ave_y-y[0])); 	for(int i=1; i<N; i++)  	{ 		ld quo = sqrt((ave_x-x[i])*(ave_x-x[i]) + (ave_y-y[i])*(ave_y-y[i])); 		if(quo < min)  		{ 			min = quo; 			min_index = i; 		} 	} 	 	for(int i=0; i<N; i++)   sum += max(abs(x[min_index]-x[i]), abs(y[min_index]-y[i])); 	printf("%0.0Lf\n",sum); 	 	return 0; }
#include<iostream> using namespace std; int TestAdd(int a,int b) {          if(a <1)return b;         return(TestAdd((a&b)<<1,a^b));     } int main() {     int n1,n2,sum;     cin>>n1>>n2;     sum=TestAdd(n1,n2);     cout<<sum;     return 0; }
#include<bits/stdc++.h> using namespace std; #define lint long long int main() {     int temp,index,x,num,l,t,r,it;     scanf("%d",&it);     while(it--)     {     int two[100]={1};     scanf("%d%d",&num,&r);     if(num==r) printf("0.00\n");     else if(r==0){     l=0;     num=num-r+1;     for(t=1;t<=num;t++)     {         temp=0;         for(index=0;index<=l;index++)         {             x=(two[index]*2)+temp;             two[index]=x%10;             temp=x/10;         }         for(temp;temp!=0;temp=temp/10)         {             l++;             two[l]=temp%10;         }      }     for(t=l;t>=1;t--)     {         printf("%d",two[t]);     }          printf("%d.00\n",two[0]-2);      }     else     {       l=0;     num=num;     for(t=1;t<=num;t++)     {         temp=0;         for(index=0;index<=l;index++)         {             x=(two[index]*2)+temp;             two[index]=x%10;             temp=x/10;         }         for(temp;temp!=0;temp=temp/10)         {             l++;             two[l]=temp%10;         }      }     for(t=l;t>=1;t--)     {         printf("%d",two[t]);     }          printf("%d.00\n",two[0]);      }      }     } 
#include <iostream> #include <cstdio> #include <string> #include <algorithm> #include <vector> #include <sstream>  using namespace std;  int main(){ 	int T; 	cin >> T; 	string emptyLine; 	getline(cin, emptyLine); 	while(T--){ 		vector< vector<string> > info(5); 		for(int i = 0; i < 5; i++){ 			string line; 			getline(cin, line); 			stringstream ss(line); 			string item; 			while (std::getline(ss, item, ' ')) { 				info[i].push_back(item); 			} 		}  		/*for(int i = 0; i < 5; i++){ 			for(vector<string>::iterator it = info[i].begin(); it != info[i].end(); it++) 				cout << *it << "\t"; 			cout << endl; 		}*/   		string seq = "ABCDE"; 		bool found = false; 		do { 			bool next = false; 			for(int i = 0; i < 5 && !next; i++){ 				char check = 'A'+i; 				int j = seq.find(check); 				for(vector<string>::iterator it = info[i].begin(); it != info[i].end() && !next; it++){ 					if (isalpha((*it)[0])){ 						if((*it)[0] == 'N'){ 							if (isalpha((*it)[1])){ 								if ((j<4 && seq[j+1] == (*it)[1]) || (j>0 && seq[j-1] == (*it)[1])) 								{ 									next = true; 									continue; 								} 							} 							else{ 								if (j == (*it)[1]-'1') 								{ 									next = true; 									continue; 								} 							} 						} 						else{ 							if ((j<4 && seq[j+1] != (*it)[0]) && (j>0 && seq[j-1] != (*it)[0])) 							{ 								next = true; 								continue; 							}  						} 					} 					else if ((*it)[0] == '+'){ 						int k; 						for (k = j+1; k < 5; k++) 							if (seq[k] == (*it)[1]) 								break; 						if (k != 5) 						{ 							next = true; 							continue; 						} 					} 					else if ((*it)[0] == '-'){ 						int k; 						for (k = j-1; k >= 0; k--) 							if (seq[k] == (*it)[1]) 								break; 						if (k != -1) 						{ 							next = true; 							continue; 						} 					} 					else{ 						if (j != (*it)[0] - '1') 						{ 							next = true; 							continue; 						} 					} 				} 			}  			if (!next){ 				found = true; 				break; 			}  		} while ( next_permutation(seq.begin(),seq.end()) && !found);  		cout << seq << endl; 	}  	return 0; } 
#include <iostream> #include <cstdio> #include <cstring> #include <queue> #include <algorithm> #include <vector> #include <cassert> using namespace std; int _clock;  struct Chef { 	int working; 	bool isWorking() 	{ 		return working != 0; 	} 	void work() 	{ 		assert(working); 		working++; 		if(working == 6) working = 0; 	} }chef[5]; void pass() { 	for (int i = 0; i < 5; ++i) 		if (chef[i].isWorking()) chef[i].work(); 	_clock++; } int waittime; struct Per { 	int time; 	int order[5]; 	int p; 	bool servered; 	bool isServered() 	{ 		return servered; 	} 	Per(){p = 0; servered = false;} 	void finish() 	{ 		order[cuisine()] -= 2; 		servered = false; 	} 	void wait() 	{ 		waittime++; 	} 	int cuisine() 	{ 		if (p == 5) return 5; 		while (order[p] == 0) p++; 		return p; 	} 	void deal() 	{ 		servered = true; 	} 	bool operator < (const Per &e)const 	{ 		return time < e.time; 	} }; const int Maxn = 1000000; Per que[Maxn]; int in, out; vector<Per> vec; int s, n; void solve() { 	in = 0, out = 0; 	//cout << vec[1].time <<" " << vec.size() << endl; 	for (_clock = 0; s < vec.size() || in > out; pass()) 	{ 		if (s < vec.size()) 		{ 			if (_clock == vec[s].time) 			{ 				que[(in++) % Maxn] = vec[s]; 				s++; 			} 		} 		while (in > out) 		{ 			int cui = que[(out) % Maxn].cuisine(); 			if (cui == 5)  			{ 				out++; 				continue; 			} 			if (que[out % Maxn].isServered() && chef[cui].isWorking() == false)  			{ 			//	cout << que[out].time <<" " << cui << endl; 				que[out % Maxn].finish(); 				que[(in++) % Maxn] = que[(out++) % Maxn]; 				chef[cui].working = 1; 			} 			else break; 		} 		if (in > out) 		{	 			Per& p = que[out % Maxn]; 			int cui = p.cuisine(); 			if (p.isServered() == false) 			{ 				p.deal(); 			//	cout<< _clock <<" " <<p.time << " " << p.p<<" " <<chef[cui].working<< endl; 			} 			else if (chef[cui].isWorking()) 				p.wait(); 		} 	} }  int main() { 	int T; 	scanf("%d", &T); 	while (T--) 	{ 		waittime = 0; 		s = 0; 		scanf("%d", &n); 		vec.clear(); 		for (int i = 0; i < n; ++i) 		{ 			Per per; 			scanf("%d", &per.time); 			for (int j = 0; j < 5; ++j) 				scanf("%d", &per.order[j]); 			per.p = 0; 			vec.push_back(per); 		} 		sort(vec.begin(), vec.end()); 		solve(); 		printf("%d\n", waittime); 	} 	return 0; }
#include<iostream> #include<cstdio>  using namespace std;  struct point {        int x,y; }p[4];  int dist(point a, point b) {     return (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y); }  bool lineIntersects(point a1,point a2,point b1,point b2) {      float det;      det = (a2.x - a1.x) * (b2.y - b1.y) - (b2.x - b1.x) * (a2.y - a1.y);            if(det == 0)      return 0;            float num1,num2;            num1 = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y)*(a1.x - b1.x);            num2 = (b2.x - b1.x)*(a1.y - b1.y) - (b2.y - b1.y)*(a1.x - b1.x);            if((num1 < 0) == det > 0)      return 0;            if((num2 < 0) == det > 0)      return 0;            if( ((num1 > det) == (det > 0)) || ((num2 > det) == (det > 0)) )      return 0;             return 1; }  int cross(point a,point b,point c) {     return (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x); }   int main() {     int t,x,y;          int i,j;          scanf("%d",&t);                   while(t--)     {           for(i=0;i<4;i++)           {              scanf("%d%d",&x,&y);              p[i].x = x;              p[i].y = y;               }                          int diag1,diag2,side1,side2;                      int flag = 0;                      for(i=0;i<4;i++)           {              for(j=i+1;j<4;j++)              {                 if((p[i].x == p[j].x) && (p[i].y == p[j].y))                 {                    flag = 1;                 }              }           }                      int flag1 = 0;                      if(!cross(p[0],p[1],p[2]))           flag1 = 1;                      if(!cross(p[1],p[2],p[3]))           flag1 = 1;                      if(!cross(p[2],p[3],p[0]))           flag1 = 1;                      if(!cross(p[3],p[0],p[1]))           flag1 = 1;                      if(flag || flag1 || lineIntersects(p[0],p[1],p[2],p[3]) || lineIntersects(p[0],p[3],p[1],p[2]) )           {                   printf("NONE\n");           }                     else if( (p[0].x + p[2].x == p[1].x + p[3].x) && (p[0].y + p[2].y == p[1].y + p[3].y) )           {                    side1 = dist(p[0],p[1]);                    side2 = dist(p[0],p[3]);                    diag1 = dist(p[0],p[2]);                    diag2 = dist(p[1],p[3]);                                        if(diag1 == diag2)                    {                             if(side1 == side2)                             {                                      printf("SQUARE\n");                             }                             else                             {                                      printf("RECTANGLE\n");                             }                    }                    else                    {                             if(side1 == side2)                             {                                      printf("RHOMBUS\n");                             }                             else                             {                                      printf("PARALLELOGRAM\n");                             }                    }           }           else           {                    printf("QUADRILATERAL\n");           }                }     return 0; } 
#include <iostream> #include <cstdio> #include <vector> #include <stack> #include <queue> #include <string> #include <cstring> #include <map> #include <cstdlib> #include <algorithm> #include <list> #include <deque> #include <bitset> #include <cmath> #include <functional> #include <set>  using namespace std;  bool esPrimo(int n) {     if (n < 2) return false;     if (n == 2) return true;     if (n % 2 == 0) return false;     int sqr = (int)sqrt(n);      for (int i = 3; i <= sqr; i += 2)     {         if (n % i == 0)         {             return false;         }     }     return true; }  int sumarDig(string n) {     int sum = 0;     for (int i = 0; i < n.size(); i++)     {         sum +=  (n[i]-'0');     }     return sum; }  char buffer[100]; std::string to_string(int k){ 	sprintf(buffer, "%d", k); 	return std::string(buffer); }  int main() {     int t ;     scanf("%d", &t);     while (t--)     {         int L,U;         scanf("%d", &L);         scanf("%d", &U);          int ans = 0;         for (int i = L; i <= U; i++)         {             if (esPrimo(sumarDig(to_string(i)  )))             {                 ans++;             }         }         printf("%d\n", ans);     }   } 
#include<bits/stdc++.h> using namespace std; #define sd(x) scanf("%d",&x) #define slld(x) scanf("%lld",&x) #define ss(x) scanf("%s",x) #define ll long long #define mod 1000000007 #define bitcount    __builtin_popcountll #define pb push_back int main() {     //freopen("in.txt","r",stdin);     //freopen("out.txt","w",stdout);     int t,n,i,j,k,a[55],b[55],s,s1;     sd(t);     while(t--)     {     	sd(n);     	s=0;     	for(i=0;i<n;i++)     	{     		sd(a[i]);     		s+=a[i];     	}     	s-=(n*(n-1))/2;     	if(s>=0&&s%n==0)     	{     		s1=0;     		for(i=0;i<n;i++)     		{     			b[i]=i+s/n;     			s1+=abs(a[i]-b[i]);     		}     		printf("%d\n",s1/2);        	}        	else        		printf("-1\n");     }     return 0; }
//some variables var four_letter_words = ["doup","frig","ours","skep","smar","spad","rale","plat","viol","esox","culb","amok","oont","coif","coir","aver","keen","vuln","tsar","apse","onyx","peen"]; var seven_letter_words = ["abalone","abandon","ability","abolish","abdomen","abraham","abyssal","academy","account","achieve","acidity","acquire","acrobat","acronym","acrylic","actress","adaptor","address","already","adjourn","admiral","advance","advisor","aerator","aerosol","affable","afflict","affront","african","backlit","backlog","backrub","badland","baggage","bailout","balance","ballboy","balloon","baloney","bananas","bandage","bandaid"]; var five_letter_words = ["pople","carom","ergot","aglet","cubeb","nerpa","taler","qitra","decoy","swain","oxter","panic"];  var i, j, k; var crypto = require('crypto'); var possibility, hash;  for (i=0; i<four_letter_words.length; i++) { 	for (j=0; j<seven_letter_words.length; j++) { 		for (k=0; k<five_letter_words.length; k++) { 			possibility = "The world is " + four_letter_words[i] + " " + seven_letter_words[j] + " this email was a " + five_letter_words[k]; 			hash = crypto.createHash('md5').update(possibility).digest("hex"); 			if (hash == "0c049ca2ad590d34d1753419f64eff19") { 				console.log(possibility); 				break; 			} 		} 	} }  
#include<iostream> #include <cstdio> using namespace std;  void convertdtob(int n) {     int b=7;      if (n == 0)         return;         long long int x = n % b;      n /= b;      if (x < 0)         n += 1;      convertdtob(n);      cout<< x ; }  int main() {     long long int n;      while(1)     {          cin>>n;         if(n==-1)         {             break;         }          else     if (n != 0) convertdtob(n); cout<<"\n";     }     return 0; } 
#include<iostream> #include<cstdio> using namespace std;  int main() {    long long int n, a,b,next, c;     cin>>a>>b;    cin>>n;    for ( c = 0 ; c < n ; c++ )    {       if ( c <= 1 )          next = c;       else       {          next = a+b;          a=b;         b= next;       }     }     cout<<next<<endl;    return 0; } 
#include<bits/stdc++.h> #define LL long long int #define sc(x) scanf("%d",&x) #define sl(x) scanf("%lld",&x) #define pf(x) printf("%d\t",x) #define pl(x) printf("%lld\n",x) #define pb push_back #define F first #define S second #define maxn 1005 #define M 1000000007 using namespace std;  int main() { 	int t,j=0; 	sc(t); 	t=t*2; 	while(j<t/2) 	{ 	for(int i=1;i<=t;i++) 	{ 		if(i<=j || i>t-j) 		{ 			printf("-"); 		} 		else 		{ 			printf("*"); 		} 	} 	j++; 	printf("\n"); } j=0; if(t&1) { 	while(j<=t/2) 	{ 	for(int i=1;i<=t;i++) 	{ 		if(i==t/2-j+1 || i==t/2+j+1) 		{ 			printf("*"); 		} 		else 		{ 			printf("-"); 		} 	} 	j++; 	printf("\n"); } } else { 	while(j+1<t/2) 	{ 	for(int i=1;i<=t;i++) 	{ 		if(i==t/2-j || i==t/2+j+1) 		{ 			printf("*"); 		} 		else 		{ 			printf("-"); 		} 	} 	j++; 	printf("\n"); } for(int i=1;i<=t;i++) { 	printf("*"); } printf("\n"); } 	return 0; }
#include <cassert> #include <cctype> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <iostream> #include <sstream> #include <iomanip> #include <string> #include <vector> #include <deque> #include <list> #include <set> #include <map> #include <bitset> #include <stack> #include <queue> #include <algorithm> #include <functional> #include <iterator> #include <numeric> #include <utility> using namespace std;  template< class T > T _abs(T n) { return (n < 0 ? -n : n); } template< class T > T _max(T a, T b) { return (!(a < b) ? a : b); } template< class T > T _min(T a, T b) { return (a < b ? a : b); } template< class T > T sq(T x) { return x * x; } template< class T > T gcd(T a, T b) { return (b != 0 ? gcd<T>(b, a%b) : a); } template< class T > T lcm(T a, T b) { return (a / gcd<T>(a, b) * b); } template< class T > bool inside(T a, T b, T c) { return a<=b && b<=c; } template< class T > void setmax(T &a, T b) { if(a < b) a = b; } template< class T > void setmin(T &a, T b) { if(b < a) a = b; }  #define ALL(c) c.begin(), c.end() #define PB(x) push_back(x) #define UB(s, e, x) upper_bound(s, e, x) #define LB(s, e, x) lower_bound(s, e, x) #define REV(s, e) reverse(s, e); #define SZ(c) c.size() #define SET(p) memset(p, -1, sizeof(p)) #define CLR(p) memset(p, 0, sizeof(p)) #define MEM(p, v) memset(p, v, sizeof(p)) #define CPY(d, s) memcpy(d, s, sizeof(s)) #define ll long long #define ff first #define ss second #define DEBUG if(0)  #define si(x) scanf("%d",&x) #define pi(x) printf("%d\n",x) #define siz 100100 struct date {        int m,d,y;        double r;        };        bool comp1(date x, date y)        {             return x.r>y.r;             }        bool comp2(date x, date y)        {             if(x.y==y.y)             {                if(x.m==y.m)                      return x.d<y.d;             else             return x.m<y.m;             }             else             return x.y<y.y;             }              int main() {     int i=0,m,d,y;     char c,ch,str[1000];     date p[100010],q[100010];     double a;     while( 1)     {            scanf("%lf",&a);            if(a==-1.0l)            break;          // scanf("%d%c%d%c%d",&m,&c,&d,&ch,&y);          scanf("%s",str);          p[i].r=a;          p[i].m=(str[0]-'0')*10+(str[1]-'0');           p[i].d=(str[3]-'0')*10+(str[4]-'0');           p[i].y=(str[6]-'0')*10+(str[7]-'0');          q[i].r=a;          q[i].m=(str[0]-'0')*10+(str[1]-'0');           q[i].d=(str[3]-'0')*10+(str[4]-'0');           q[i].y=(str[6]-'0')*10+(str[7]-'0');                      i++;                                 }                      int n=i;          // for(i=0;i<n;i++)              //printf("%d %d %d %d %d\n",p[i].r,p[i].m,p[i].d,p[i].y);        sort(p,p+n,comp1);        cout<<"Money:\n";                  for(i=0;i<n;i++)           {cout<<"["<<p[i].r<<", ";  printf("%d%d/%d%d/%d%d]\n",p[i].m/10,p[i].m%10,p[i].d/10,p[i].d%10,p[i].y/10,p[i].y%10);           }         sort(q,q+n,comp2);        cout<<"Date:\n";          for(i=0;i<n;i++)            {cout<<"["<<q[i].r<<", ";  printf("%d%d/%d%d/%d%d]\n",q[i].m/10,q[i].m%10,q[i].d/10,q[i].d%10,q[i].y/10,q[i].y%10);            }          // cin>>i;                   return 0;           }           
#include <stdio.h>  #include<iostream>  using namespace std; int josephus(int n, int k) {   if (n == 1)     return 1;   else     /* The position returned by josephus(n - 1, k) is adjusted because the        recursive call josephus(n - 1, k) considers the original position         k%n + 1 as position 1 */     return (josephus(n - 1, k) + k-1) % n + 1; }   // Driver Program to test above function int main() {   int n,k;   cin>>n>>k;   printf("%d\n", josephus(n, k));   return 0; }
#include<iostream> #include<vector> #include<algorithm> #include<string.h> using namespace std; int main() { int n,m,i,s;   char x[200000]; while(1) { scanf("%d%d",&n,&m); if(n==0 && m==0) break; int b[20000]={0}; vector <string> a; for(i=0;i<n;i++) { scanf("%s",&x); a.push_back(x); } sort(a.begin(),a.end()); s=1; for(i=1;i<n;i++) { if(a[i]==a[i-1]) s++; else { b[s-1]++; s=1; } } b[s-1]++; for(i=0;i<n;i++) printf("%d\n",b[i]); } } 
#include <bits/stdc++.h> #define ll long long int #define MAX 201 #define EPS 1e-9 #define MOD 1000000007 #define INF 1e9 #define pn() printf("\n") #define vint vector <int> #define vpint vector <pair<int,int> > #define pb push_back #define mp make_pair #define ft first #define sd second #define gc() getchar_unlocked() #define ms(x,v) memset(x,v,sizeof x) #define pr_arr(i,x,size) for(i=0;i<size;i++) cout<<x[i]<<" " #define ff(i,a,b) for(i=a;i<=b;i++) #define fb(i,a,b) for(i=a;i>=b;i--) #define gprint(i) cout<<"Case #"<<i<<": " using namespace std;  template<class T> void scanint(T &x) {     register T c = gc();     x = 0;     T neg = 0;     for(;((c<48 || c>57) && c != '-');c = gc());     if(c=='-') {neg=1;c=gc();}     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}     if(neg) x=-x; }  template<class T> T modulus(T x,int m=MOD) {     return (((x%m)+m)%m); }  inline bool lt(double a, double b) {     return a + EPS < b; } inline bool gt(double a, double b) {     return a > b + EPS; } inline bool eq(double a, double b) {     return fabs(a - b) < EPS; }  ll power(ll base,ll p) {     if(p==0)         return 1;     ll temp=1;     while(p>1)     {         if(p%2!=0)             temp=(1LL*(base*temp)%MOD);         base=(1LL*(base*base)%MOD);         p/=2;     }     ll ans=(1LL*(base*temp)%MOD);     return ans; }  char arr[MAX][MAX]; int visited[MAX][MAX]; int t,n,m;  void bfs(int a,int b) { 		queue <pair<int,int> > q; 		q.push(mp(a,b)); 		int i,j; 		visited[a][b]=1; 		while(!q.empty()) 		{ 			pair<int,int> u=q.front(); 			q.pop(); 			ff(i,-1,1) 			{ 				ff(j,-1,1) 				{ 					if(i+u.ft>=0 && i+u.ft<n && j+u.sd>=0 && j+u.sd<m && visited[u.ft+i][u.sd+j]==0) 					{ 						visited[i+u.ft][u.sd+j]=1; 						if(arr[u.ft+i][u.sd+j]=='#') 						{ 							q.push(mp(u.ft+i,u.sd+j)); 						} 					} 				} 			} 		} }   int main() {     ios::sync_with_stdio(false);     int i,j;     scanf("%d",&t);     while(t--)     {     	//ms(arr,0);     	ms(visited,0);     	scanf("%d %d",&n,&m);     	int ans=0;     	ff(i,0,n-1)     	{     		// ff(j,0,m-1)     		// {     		// 	char temp;     			scanf("%s",&arr[i]);     		//	arr[i][j]=(temp=='#'?1:0);     		// }     	}     	ff(i,1,n-2)     	{     		ff(j,1,m-2)     		{     			if(visited[i][j]==0 && arr[i][j]=='#')     			{     				bfs(i,j);     				ans++;     			}     		}     	}     	printf("%d\n",ans);     }     return 0; }
#include<bits/stdc++.h> using namespace std; typedef long long ll; int main() {     ll t,a;     cin>>t;      ll ar[500001];       for(ll i=1;i<=500000;i++)         ar[i]=1;           for(ll i=2;i<=500000;i++)            for(ll j=1;(i*j)<=500000;j++)            ar[i*j]+=i;     while(t--){             cin>>a;             cout<<ar[a]-a<<endl;           }     } 
#include<stdio.h> int main(){         int a,b,a1,c=0;         int temp;         scanf("%d %d",&a,&b);         while(1){             if(a==0)             break;            int arr[10]={0};            if(a>b){            int t=a;            a=b;            b=t;            }             while(a<=b){                 a1=a;                   while(a1){                 temp=a1%10;                 arr[temp]=arr[temp]+1;                 a1=a1/10;                 }                 a=a+1;             }             c++;             printf("Case %d:",c);             for(int i=0;i<10;i++){             printf(" %d:%d",i,arr[i]);             }             printf("\n");               scanf("%d %d",&a,&b);         }         return 0; }
#include <iostream> #include <limits.h> #define min(a,b) (((a) < (b)) ? (a) : (b))  using namespace std; int table[10001];     int main(){ 	int d, n1, n2, k, l, m; 	cin>>d; 	while(d){ 		cin>>n1>>n2>>k; 		for(int i = 0; i <= n2 - n1; i++) 				table[i] = INT_MAX; 		table[0] = 0; 		for(int i = 0 ; i < k; i++){ 				cin>>l >>m; 				for(int	 i = m; i <= n2-n1; i++){ 						if(table[i - m]!= INT_MAX){ 							table[i] = min(table[i], table[i - m] + l); 						} 				} 		}  		switch(table[n2-n1]){ 		case (INT_MAX): 			cout<<"This is impossible."<<endl; 			break; 		default: 			cout<<"The minimum amount of money in the piggy-bank is "<<table[n2-n1]<<"."<<endl; 		}  		d--; 	}  	return 0; } 
#include<stdio.h> //#include<conio.h> #include<math.h>   int main() {          long long  int t=-1,a[200],c[200],g=0;           long long int n=0,k=0,p=0;             long long int i=0,j=0;            long long int x=0;                                 while(1)           {                        scanf("%lld",&n);                          if(n!=-1){                      for(i=n;i>=0;i--)                  scanf("%lld",&c[i]);                  scanf("%lld",&k);                  for(i=0;i<k;i++)                  scanf("%lld",&a[i]);                  p++;                  printf("Case %lld:\n",p);                                    for(j=0;j<k;j++)                  {                            g=1;                              for(i=0;i<=n;i++)                     {                                                           x+=(c[i]*g);                       g*=a[j];                     }                     printf("%lld\n",x);                     x=0;                   }                  }                  else                  break;                 // scanf("%lld",&n);                       }                     // getch();           return 0; }
#include<iostream> #include<list> using namespace std; class Graph{ int V; list<int> *adj;  bool iscyclicutil(int v,bool visited[],int parent); public:     Graph(int V); void addEdge(int v,int w); bool istree(); }; Graph::Graph(int V) {     this->V=V;     adj=new list<int>[V]; } void Graph::addEdge(int v,int w) {     adj[v].push_back(w);     adj[w].push_back(v); } bool Graph::iscyclicutil(int v,bool visited[],int parent) {     visited[v]=true;     list <int>:: iterator i;     for(i=adj[v].begin();i!=adj[v].end();++i)     {         if(!visited[*i])         {             if(iscyclicutil(*i,visited,v))             return true;          }         else if(*i!=parent)             return true;     }     return false; } bool Graph::istree() {     bool *visited=new bool[V];     for(int i=0;i<V;i++)         visited[i]=false;     if(iscyclicutil(0,visited,-1))         return false;     for(int i=0;i<V;i++)     {         if(visited[i]==false)             return false;     }  return true;  } int main() {     int v,e;     cin>>v>>e;     Graph g(v);     for(int i=0;i<e;i++)     {         int v,w;         cin>>v>>w;         g.addEdge(v-1,w-1);     }     if(g.istree())         cout<<"YES"<<endl;     else         cout<<"NO"<<endl;     return 0; } 
/* Author: Karlheinz Jung */ /* Compiler: C++ @ ideone.com */ /* Computer: Rabbit 286 */  #include <iostream> #include <deque> #include <vector> #include <algorithm>  using namespace std;  const int BI_MAX=10000;  struct BigInteger { deque<short> val; int flags; BigInteger(int n=0) 	{ 	flags=0; 	if(n) flags=n/abs(n); 	while(n) 		{ 		val.push_back(n%BI_MAX); 		n/=BI_MAX; 		}         } void clear_leading_zero() 	{ 	while(val.back()==0) val.pop_back(); 	} string to_string() 	{ 	if(val.size()==0) return "0"; 	char res[val.size()*4+5]; 	char *r; 	r=res+val.size()*4+4; 	*(r--)='\0'; 	for(int i=0; i<(int)val.size(); i++) 		{ 		int t=val[i]; 		for(int j=0; j<4; j++) 			{ 			if(t==0&&i==(int)val.size()-1) break; 			(*r--)=t%10+'0'; 			t/=10;                         }                 } 	return string(r+1);         } };  BigInteger add(const BigInteger &a, const BigInteger &b) { BigInteger res(0); short va, vb, k=0; for(int i=0; i<max<int>(a.val.size(),b.val.size()); i++) 	{ 	if(i<(int)a.val.size()) 		va=a.val[i]; 	else 		va=0; 	if(i<(int)b.val.size()) 		vb=b.val[i]; 	else 		vb=0; 	va+=k; 	k=(va+vb)>=BI_MAX; 	res.val.push_back(va+vb-(k?BI_MAX:0));         } if(k)res.val.push_back(k); return res; }  BigInteger mul(const BigInteger &a, const BigInteger &b) { int k=0, i, j; BigInteger res(0); for(int i=0; i<(int)a.val.size()+(int)b.val.size()+1; i++) 	{ 	res.val.push_back(0);         } for(i=0; i<(int)a.val.size(); i++) 	{ 	k=0; 	for(j=0; j<(int)b.val.size(); j++) 		{ 		k=a.val[i]*b.val[j]+k; 		res.val[i+j]+=k%BI_MAX; 		k/=BI_MAX; 		if(res.val[i+j]>=BI_MAX) 			{ 			res.val[i+j]-=BI_MAX;k++;                         } 		} 	while(k) 		{ 		res.val[i+j]+=k; 		if(res.val[i+j]>=BI_MAX) 			{ 			res.val[i+j]-=BI_MAX; 			k=1; 			} 		else 			k=0;                         j++; 		} 	} res.clear_leading_zero(); return res; }  BigInteger operator+(const BigInteger &a,const BigInteger &b) { return add(a,b); }  BigInteger operator*(const BigInteger &a,const BigInteger &b) { return mul(a,b); }  vector<string> fibs;  bool compare(const string &a, const string &b) { if(a.size()!=b.size())return a.size()<b.size(); 	return a<b; }  int main() { BigInteger n, a=2, b=1; fibs.push_back(b.to_string()); fibs.push_back(a.to_string()); while(1) 	{ 	n=a+b; 	b=a; 	a=n; 	fibs.push_back(n.to_string()); 	if(fibs.back().size()>101) break; 	} string aa, bb; for(;cin>>aa>>bb;) 	{ 	if(aa=="0"&&bb=="0") break; 	cout<<upper_bound(fibs.begin(),fibs.end(),bb,compare)-lower_bound(fibs.begin(),fibs.end(),aa,compare)<<endl; 	} return 0; } 
/* Success is a matter of hanging on, when others have let go. Its not who you are, that holds you back, its who you think you are not. The future belongs to those, who believe in the beauty of their dreams. */ //{ /* theCodeGame */ #include<iostream> #include<cmath> #include<algorithm> #include<climits> #include<vector> #include<queue> #include<stack> #include<bitset> #include<cstdlib> #include<cstdio> #include<cstring> #include<ctime> #include<map> using namespace std; #define MOD 1000000007LL #define LL long long #define ULL unsigned long long #define LD long double #define MAX(a,b) ((a)>(b)?(a):(b)) #define MIN(a,b) ((a)<(b)?(a):(b)) #define ABS(x)   ((x)<0?-(x):(x)) #define SQR(x) ((x)*(x)) #define CUBE(x) ((x)*(x)*(x)) #define si(n) scanf("%d",&n) #define si2(n,m) scanf("%d %d",&n,&m) #define sf(n) scanf("%f",&n) #define sl(n) scanf("%ld",&n) #define sll(n) scanf("%lld",&n) #define slu(n) scanf("%llu",&n) #define sd(n) scanf("%lf",&n) #define ss(n) scanf("%s",n) #define pnl printf("\n") #define FORD(i,a,b,d) for(typeof(b) i=(a);i<(b);i+=(d)) #define FOR(i,a,b) for(typeof(b) i=(a);i<(b);i++) #define REP(i,n) for(typeof(n) i=0;i<(n);i++) #define FORR(i,n,e) for(typeof(n) i=(n);i>=(e);i--) #define FORRD(i,n,e,d) for(typeof(n) i=(n);i>=(e);i-=(d)) #define FILL(a,b) memset(a,b,sizeof(a)) //#undef mydebug #ifdef mydebug #define DB(x) cout<<#x<<"="<<(x)<<"\n" #define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n" #define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n" #define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n" #define DBG_ARR(a,b,c) DBG(a,b,c) #define pnld pnl; #else #define DB(x) #define DB2(x,y) #define DB3(x,y,z) #define DB4(x,y,z,a) #define DBG_ARR(a,b,c) #define pnld #endif const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; template <typename T>void swap(T &x,T &y){T t=x;x=y;y=t;} template <typename T>void DBG(const T A,int S,int N){cout<<"[";FOR(i,S,N){cout<<"#"<<i<<":"<<A[i]<<" ";}cout<<"]\n";} ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} //} #define size 300 char a[size], b[size][size]; void precompute(){} void doThis(){     	int column, x, row, k, z; 	si(column); 	getchar();     while(column!=0){ 	ss(a); 	DB2(column,a); 	int x =strlen(a); 	row=x/column; 	FOR(i,0,row){         k=(i+1)*column;         z=k;             if(i%2==0){                 FOR(j,0,column){                     b[i][j]=a[z-column];                     z++;                 }             }              if(i%2!=0){                 FOR(j,0,column){                     b[i][j]=a[z-1];                     z--;                 }             } 	} 	FOR(i,0,column){ 	    FOR(j,0,row){ 	        cout<<b[j][i]; 	    } 	} 	pnl; 	si(column); 	getchar();     } }  int main(){ #ifdef amy freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr); #endif precompute(); int t=1; //scanf("%d",&t); while(t--){doThis();} #ifdef amy fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC)); #endif return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { int t,n;   scanf("%d",&t);   while(t--)   { scanf("%d",&n);        vector<int> v(n,-1);     int val,len=n+1,i,l,r,ans=0;     v[0]=0; 	for(i=1;i<=n;i++)     { scanf("%d",&val);       ans+=val; 	  ans%=n; 	  //cout<<ans<<" "; 	  if(v[ans]!=-1 && i-v[ans]<len) 	  { l=v[ans]+1; 	    r=i; 	    len=i-v[ans]; 	    //cout<<l<<" "<<r<<" "; 	  } 	           v[ans]=i;	 	} 	   	  printf("%d %d\n",l-1,r-1);   } 	return 0; }
#include<iostream> #include<vector> #include<set> #include<map> #include<queue> #include<stack> #include<string> #include<algorithm> #include<functional> #include<iomanip> #include<cstdio> #include<cmath> #include<limits.h> #include<cstring> #include<cstdlib> #include<cfloat> #include<cassert> #define maxm(a,b) a>b?a:b; #define minm(a,b) a<b?a:b; using namespace std; //M lazy ;) typedef long long ll; typedef vector <int> vi; typedef pair< int ,int > pii; typedef istringstream iss; typedef ostringstream oss; typedef map<int,int> mp; #define pb push_back #define mp make_pair #define ff first #define ss second #define sz size() #define ln length() #define rep(i,n) for(int i=0;i<n;i++) #define fu(i,a,n) for(int i=a;i<=n;i++) #define fd(i,n,a) for(int i=n;i>=a;i--) #define all(a)  a.begin(),a.end() #define ESP (1e-9) #define gi(n) scanf("%d",&n) #define gl(n) cin >> n #define pi(n) printf("%d",n) #define pl(n) cout << n #define ps printf(" ") #define pn printf("\n") #define dg(n,s); printf("%s %d",s,n) #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min() #define traverse_map(a,b) for(mp::iterator it=a;it!=b;++it) #define MOD 1000000007 #define MAX 1000001 #define cases() int t; cin>>t; while(t--) // fast input function #define getcx getchar_unlocked // fast input function #ifdef ONLINE_JUDGE  inline void inp( int &n )  {     n=0;     int ch=getcx();int sign=1;     while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )             n = (n<<3)+(n<<1) + ch-'0', ch=getcx();     n=n*sign;   } #else inline void inp(int &n){  cin>>n; } #endif  #include <stdio.h> #include <math.h>  int CheckTriple(int temp){    int n=temp;    while(n%2==0)    { 		n/=2;    }    if(n==1)    return 0;        for(int i=3;i<=sqrt(temp);i+=2)   { 			 if(n%i==0){  					if(i%4==1) 					 return 1; 					 else{ 							while(n%i==0) 							 n/=i; 					 } 			 }   }      if(n>1){    if(n%4==1)     return 1;   }  return 0;  }  int main(){ 		int t; 		inp(t); 		while(t--){ 		  int n; 		   inp(n); 		   if(CheckTriple(n)) 			cout<<"PERFECT"<<endl; 		    else 			 cout<<"IMPERFECT"<<endl; 		}  } 
#include<bits/stdc++.h> //#define inf 100000000 #define ll  long long #define pb push_back #define s(n) scanf("%d",&n) #define sl(n) scanf("%lld",&n)  #define p(n) printf("%lld\n",n) #define rep(i,a,n) for(i=a;i<=n;i++) #define vi vector<int> #define vii vector< vector<int> > #define vpii vector< pair<int,int> > #define mii map<int,int> #define pb push_back #define inf 1000000000LL #define mp make_pair #define MOD 1000000007LL #define N 1000007 using namespace std; ll powmod(long long a, long long b, long long c) {     ll ret=1LL;      while(b)     {         if(b & 1)             ret = (ret*a)%c;         a=(a*a)%c;          b>>=1;     }     return (ret)%c; } ll minverse(ll a,ll mod1) {     if(a==0LL)         return 1LL;     return powmod(a,(1LL*(mod1-2LL)),mod1)*1LL; } int dp1[21][21]; int bit[21]; ll dp[1200000];  int main() { int t,n,i,j,k,n1,n2,m; s(t); while(t--) { memset(dp1,0,sizeof(dp1)); memset(bit,0,sizeof(bit));  s(n);s(m);  for(i=1;i<=m;++i)  {   s(n1);s(n2);   dp1[n1][n2]=1;  } for(i=1;i<=n;++i) 		{ 			for(j=1;j<=n;++j) 			{ 				bit[i]=bit[i]+((dp1[i][j]?1:0)<<(j-1)); 			} 		}  dp[0]=1;  for(i=1;i<(1<<n);++i)  {    dp[i]=0;    for(j=0;j<n;++j)    {      if(i&(1<<j))      {       if((i&(bit[j+1]))==0)       dp[i]=(dp[i]+dp[i-(1<<j)])%MOD;      }    }  }    //cout<<sum<<" "<<dp[sum]<<endl;  p(dp[(1<<n)-1]); } } 
#include<bits/stdc++.h> using namespace std; #define temp 0 #define perm 1 #define INF (int(1e9)) #define INFL ((long long int)(1e18)) #define in2(n,m) scanf("%d %d",&n,&m); #define in3(x,y,z) scanf("%d %d %d",&x,&y,&z); #define in4(p,q,r,s) scanf("%d %d %d %d",&p,&q,&r,&s); #define unsetBit(BITT,X) (BITT&(~(1<<X))); #define setBit(BITT,X) (BITT|(1<<X)); #define bitIsSet(BITT,X) (BITT&(1<<X)) #define bitIsNotSet(BITT,X) (!(BITT&(1<<X))) #define getcx getchar inline void in(int &n) {     n=0; int ch = getcx(); int sign = 1;     while(ch < '0' || ch > '9') { if(ch == '-') sign=-1; ch = getcx(); }     while(ch >= '0' && ch <= '9') { n = (n << 3) + (n << 1) + ch - '0', ch = getcx(); }     n = n * sign; } #define mod 1000000007 #define pii pair< int , int > #define V 100000 int res[V+5],prime[V+5]; void pre() {     for(int i=2; i<=V; i++)     {         if(prime[i]==0)//a prime         {             res[i] = 1;             for(int j=i+i; j<=V; j+=i)             {                 res[j] = res[j/i] + 1;                 prime[j] = 1;             }         }     }     int mx = 0;     for(int i=1; i<=V; i++)     {         //printf("%d %d\n",i,res[i]);         mx = max( mx , res[i] );     }     //printf("%d\n",mx); } vector<int> v[20]; long long int dp[20][100005]; long long int A[20], B[20] , C[20]; long long int func(int pos,int idx) {     if(dp[pos][idx]!=-1)     {         //printf("bb\n");         return dp[pos][idx];     }     /*int sdx = idx;     long long int ans = 0;     for(int i=0; i<v[pos].size(); i++)     {         idx++;         long long int p = v[pos][i];         p *= idx;         p *= idx;          ans += p;     }*/     long long int Idx = idx+1;     long long int ans = Idx*Idx*A[pos] + Idx*B[pos] + C[pos];     dp[pos][idx] = ans;     return ans; } int lim; int n; long long int memo[1<<17]; long long int solve(int bitMask) {     if(memo[bitMask]!=-1)     {         //printf("aa\n");         return memo[bitMask];     }     int cnt = 0;     for(int i=0; i<=lim; i++)     {         if(bitMask&(1<<i))         {             cnt += (int)v[i].size();         }     }     //printf("lim is %d and n is %d and cnt is %d\n",lim,n,cnt);     if(cnt==n)     {         return 0;     }     long long int ans = 0;     for(int i=0; i<=lim; i++)     {         if(bitMask&(1<<i))         {             continue;         }         //bit is not set , lets use it         long long int curr = func(i,cnt);         int newMask = bitMask|(1<<i);         ans = max( ans , curr+solve(newMask) );     }     memo[bitMask] = ans;     return ans; } int main() {     pre();     in(n);     int mx = 0;     for(int i=1; i<=n; i++)     {         int x,y;         in(x);         in(y);         int pos = res[x];         v[pos].push_back(y);          mx = max( mx , pos );     }     for(int i=0; i<=mx; i++)     {         sort(v[i].begin(),v[i].end());         //printf("i is %d and size is %d\n",i,v[i].size());     }     for(int i=0; i<=mx; i++)     {         A[i] = 0;         for(int j=0; j<v[i].size(); j++)         {             A[i] += v[i][j];         }          B[i] = 0;         C[i] = 0;         for(int j=1; j<v[i].size(); j++)         {             long long int p = 2;             p *= j;             p *= v[i][j];             B[i] += p;//2*j*v[i][j];              long long int q = j;             q *= j;             q *= v[i][j];              C[i] += q;//j*j*v[i][j]          }     }     /*for(int i=0; i<=mx; i++)     {         printf("i is %d %lld %lld %lld\n",i,A[i],B[i],C[i]);     }*/     lim = mx;     memset(memo,-1,sizeof(memo));     memset(dp,-1,sizeof(dp));     long long int ans = solve(0);     printf("%lld\n",ans); } 
#include<iostream> using namespace std; int main() {  int t,n,a;  cin>>t;  while(t--)  {   cin>>n;   while(n--)    cin>>a;   cout<<1<<endl;  }  return 0; }
#include<cstdio> #include<iostream> #include<algorithm> #include<cstring> using namespace std; int main() { int k,t; int ans[10][5]; for(int i = 0; i <= 9; i++){ ans[i][0] = i; for(int j = 1; j <= 3; j++){ ans[i][j] = ans[i][j-1] * i; ans[i][j] %= 10; } }    long long int p;    char s[25];    scanf("%d",&t);    while(t--)    {      scanf("%s %lld",&s,&p);      k=s[strlen(s)-1]-'0';      if(p==0){printf("1\n");continue;}      p--;      printf("%d\n",ans[k][p%4]);    }    return 0; }
#include <iostream> #include <stdio.h>  #define ll long long int  using namespace std;  int main() {          int t;     scanf("%d", &t);          while(t--) {       int n;       scanf("%d", &n);              int lens[n];       for(int i =0; i<n; i++) {           scanf("%d", &lens[i]);          }              ll ans =0;              for(int i =1; i<n; i++) {          if(lens[i] > lens[i-1]) {                 ans ++;             }            }                     cout << ans << endl;     }                 return 0;    } 
 // (c) agaurav77 #include <iostream> #include <map>          // find(), clear() #include <vector>       // push_back(), pop_back(), front(), back() #include <list>         // push_back(), pop_back(), front(), back() --- SEQUENTIAL ACCESS #include <queue>        // push(), pop(), front(), back() #include <utility>      // make_pair() #include <algorithm>    // sort() #include <cmath> #include <cstdio> #include <climits>      // inf, minf #include <cstdlib>      // malloc() #include <sstream> #include <string> #include <cstring>      // memset() #define mp make_pair #define pb push_back using namespace std;  #define inf INT_MAX #define minf INT_MIN #define t(N) scanf("%d", &N); #define f(i,a,b) for(int i=a;i <= b; ++i) #define str string #define ll long long  #define inMap(a,b) (a.find(b) != a.end())  int main() {   int T;   cin >> T;      while (T--) {     int N;     cin >> N;      int arr[N];     f(i, 0, N-1) cin >> arr[i];      int maxcnt = 0, currcnt = 0;     f(i, 0, N-2) {       if (arr[i] == arr[i+1]) currcnt++;       else {         maxcnt = maxcnt > currcnt ? maxcnt : currcnt;         currcnt = 0;       }     }     maxcnt = maxcnt > currcnt ? maxcnt : currcnt;     cout << maxcnt << endl;   }    return 0; }    
#include <bits/stdc++.h> using namespace std; long long fact[1000005]; int T,N; int main() { 	for(int i=1; i<=1000000; i++)fact[i]=1; 	for(int i=2; i<=1000000; i++) 	{ 		fact[i]++; 		for(int j=i+i; j<=1000000; j+=i)fact[j]++; 	} 	 	for(int i=2; i<=1000000; i++)fact[i]=fact[i-1]+fact[i]; 	cin>>T; 	while(T--) 	{ 		scanf("%d",&N); 		cout<<(fact[N]*2)<<"\n"; 	} 	return 0; }
// laflare #include<iostream> #include<vector> #include<set> #include<map> #include<queue> #include<stack> #include<string> #include<algorithm> #include<functional> #include<iomanip> #include<cstdio> #include<cmath> #include<limits.h> #include<cstring> #include<cstdlib> #include<cfloat> #include<cassert> #define maxm(a,b) a>b?a:b; #define minm(a,b) a<b?a:b; using namespace std; //M lazy ;) typedef long long ll; typedef vector <int> vi; typedef pair< int ,int > pii; typedef istringstream iss; typedef ostringstream oss; typedef map<int,int> mp; #define pb push_back #define mp make_pair #define ff first #define ss second #define sz size() #define ln length() #define rep(i,n) for(int i=0;i<n;i++) #define fu(i,a,n) for(int i=a;i<=n;i++) #define fd(i,n,a) for(int i=n;i>=a;i--) #define all(a)  a.begin(),a.end() #define ESP (1e-9) #define gi(n) scanf("%d",&n) #define gl(n) cin >> n #define pi(n) printf("%d",n) #define pl(n) cout << n #define ps printf(" ") #define pn printf("\n") #define dg(n,s); printf("%s %d",s,n) #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min() #define traverse_map(a,b) for(mp::iterator it=a;it!=b;++it) #define MOD 1000000007 #define MAX 1000001 #define cases() int t; cin>>t; while(t--) // fast input function #define getcx getchar_unlocked // fast input function #ifdef ONLINE_JUDGE  inline void inp( int &n )  {     n=0;     int ch=getcx();int sign=1;     while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )             n = (n<<3)+(n<<1) + ch-'0', ch=getcx();     n=n*sign;   } #else inline void inp(int &n){  cin>>n; } #endif /* inline long long inp(){ 	char c = getchar_unlocked(); 	long long n = 0; 	while(c < '0' || c > '9') c = getchar_unlocked(); 	while(c >= '0' && c <= '9') 		n = (n<<3) + (n<<1) + c - '0', c = getchar_unlocked(); 	return n; }  #define pc putchar_unlocked inline void oup(int n){ 	if(!n) pc('0'); 	char pb[2]; 	int pi = 0; 	while(n) pb[pi++] = (n%10) + '0', n /= 10; 	while(pi) pc(pb[--pi]); }*/ bool compare(const long long &a,const long long &b){ 	return a<b; } int main(){  int t;  inp(t);  while(t--){    int *M,*C;    int n,k;    inp(n);    inp(k);    M=(int*)calloc((n+1),sizeof(int));    C=(int*)calloc((n+1),sizeof(int));        for(int i=1;i<=n;i++) 	inp(M[i]); 	    for(int i=1;i<=k;i++)    {    int a,b; 		inp(a); 		inp(b); 		for(int j=a;j<=b;j++) 		 C[j]++;    }        sort(M,M+n+1,compare);    sort(C,C+n+1,compare);     ll sum=0;    for(int i=0;i<=n;i++) 	 sum+=C[i]*M[i]; 	    printf("%lld\n",sum);    free(M);    free(C);  }  return 0; } 
#include <stdio.h> #include <string.h> #include <vector> #include <iostream> using namespace std;   char str[1000]; int l; const int letters = 'z' - 'a' + 1;   bool is_palidrome(){     for (int i = 0; i < l/2; ++i) {         if (str[i] != str[l-i-1]) return false;     }     return true; }   bool is_pangram(vector<bool>& alphabet) {     for (int i = 0; i < l; ++i) {         alphabet[str[i]-'a'] = true;     }     for (int i = 0; i < letters; ++i){         if(!alphabet[i]) return false;     }     return true; }     int main() {     int t;     scanf ("%d", &t);     while (t--) {         scanf ("%s", str);         l = strlen(str);         vector<bool> alphabet(letters, false);           bool palindrome = is_palidrome();         bool pangram = is_pangram(alphabet);           if (palindrome and pangram) printf("palingram\n");         else if (palindrome) printf("palindrome\n");         else if (pangram) printf("pangram\n");         else printf("none\n");       } }
#include<cstdio> #include<cstring> using namespace std; int isPalin(char s[]) { 	int i,K=strlen(s); 	for(i=0;i<=K/2;++i) 		if(s[i]!=s[K-i-1]) 			return 0; 	return 1; } int main() { 	int T; 	scanf("%d",&T); 	while(T--) 	{ 		int K,i,j,l,count=0; 		char s[21]; 		scanf("%d%s",&K,s); 		for(i=0;i<=(strlen(s)-K);++i) 		{ 			char tmp[21]; 			l=0; 			for(j=i;j<(K+i);++j) 				tmp[l++]=s[j]; 			tmp[l]='\0'; 			count+=isPalin(tmp); 		} 		printf("%d\n",count); 	} 	return 0; }
#include <bits/stdc++.h> using namespace std; #define pb push_back #define mp make_pair #define ff first #define ss second #define sd(x) scanf("%d",&x) vector<int>arr; int main(){ 	int n; 	sd(n); 	for(int i=0;i<n;i++){ 		int temp; 		sd(temp); 		arr.push_back(temp); 	} 	vector<int>table; 	table.pb(arr[0]); 	//int len=1; 	for(int i=1;i<n;i++){ 		if(arr[i]<table[0]) 			table[0]=arr[i]; 		else if(arr[i]>=table[table.size()-1]) 			table.pb(arr[i]); 		else 			table[upper_bound(table.begin(),table.end(),arr[i])-table.begin()]=arr[i]; 	} 	cout<<table.size(); 	return 0; }
#include<bits/stdc++.h> using namespace std; #define f(i,a,b) for(int i=(int)(a);i<(int)(b);i++) #define rf(i,a,b) for(int i=(int)(a);i>=(int)(b);i--) #define s(n)                        scanf("%d",&n) #define p(n)			    printf("%d\n",n) #define sl(n)                       scanf("%lld",&n) #define pl(n)			    printf("%lld\n",n) #define ll long long int int main() {     int t;     s(t);     while(t--)     {         ll n,sum=0;         sl(n);         ll a[n+2];         f(i,0,n)         {             sl(a[i]);             sum+=a[i];         }             if(sum%n==0)                 pl(n);              else pl(n-1);     }     return 0; } 
 #include<iostream> #include<stdio.h> using namespace std; int main() {     int t;     int i,j,x,y;     scanf("%d",&t);     while(t--)     {         int count=0;         scanf("%d %d",&x,&y);         if(y%x==0)            printf("%d\n",y/x);            else             {                 while(y>0)                 {                     y=y-x;                     count+=1;                 }             printf("%d\n",count);             }      }     return 0; } 
#include<stdio.h> int main() {     int t,n,p;     char a[7];     scanf("%d",&t);     while(t--)     {         scanf("%d%s%d",&n,a,&p);         if(a[0]=='e')         {             printf("%d\n",2*p-1);         }         else         {             printf("%d\n",2*p);         }     }     return 0; } 
#include<iostream> #include<bits/stdc++.h> #include<cstdlib> #include<algorithm> using namespace std; int main(void) { 	  	unsigned long long k,t,n,i,m,a[100000]; 	m=1; 	for(i=1;i<=100000;i++) 	{ 	    m=(m*i)%1589540031; 	    a[i-1]=m; 	} 	scanf("%llu",&t); 	while(t--) 	{ 		cin>>n; 		 	    cout<<a[n-1]<<endl; 	} 	return 0; } 
#define gc getchar_unlocked #define pc putchar_unlocked #include<bits/stdc++.h> using namespace std; typedef long long int lli; inline int readInt(); inline lli readLong(); inline void printInt(int a); inline void printLong(lli a); int main(){     int t=readInt();     while (t--) {         lli n = readLong();         pair<lli,lli> p[n];         for(lli i=0;i<n;i++) {             lli a = readLong(),x=readLong();             p[i].second=a,p[i].first=x;         }         sort(p,p+n);         if(n==1 && p[0].first==0) {cout<<0<<endl;continue;}         for (lli i = n-1; i>=0; i--) {             if(i!=n-1&&p[i].first!=0) cout<<" + ";             if (p[i].first > 1) {                 cout<<p[i].second*p[i].first<<"x^"<<p[i].first-1;             }             else if (p[i].first == 1) {                 cout<<p[i].second;             }             else {break;}         }         cout<<endl;     }     return 0; } inline int readInt(){     int n=0; int ch=gc(); int sign=1;     while( ch < '0' || ch > '9' ){         if(ch=='-')sign=-1; ch=gc();     }     while(  ch >= '0' && ch <= '9' )         n = (n<<3)+(n<<1) + ch-'0', ch=gc();     return n*sign; } inline void printInt(int a) {     char snum[20]; int i=0;     if(a<0) {pc('-'); a=-a;}     do {         snum[i++]=a%10+48; a=a/10;     }     while(a!=0);     i=i-1;     while(i>=0)         pc(snum[i--]);     pc('\n');     //pc(' '); } inline lli readLong(){     lli n=0; lli ch=gc();int sign=1;     while( ch < '0' || ch > '9' ){         if(ch=='-')sign=-1; ch=gc();     }     while(  ch >= '0' && ch <= '9' )         n = (n<<3)+(n<<1) + ch-'0', ch=gc();     return n*sign; } inline void printLong(lli a) {     char snum[50]; lli i=0;     if(a<0) {pc('-'); a=-a;}     do {         snum[i++]=a%10+48; a=a/10;     }     while(a!=0);     i=i-1;     while(i>=0)         pc(snum[i--]);     pc('\n');     //pc(' '); } 
#include<bits/stdc++.h> using namespace std; #define ll long long ll dp[4502][4502]; ll sol[4502][4502]; char str[4504]; int main() {     int n,m;     scanf("%d%d",&n,&m);     int i,j;     char ch;     int a=n;     int b=m;     for(i=1;i<=a;i++)     {         scanf("%s",str);         for(j=1;j<=b;j++)         {            if(str[j-1]=='C')                 dp[i][j]=1+dp[i][j-1];             else                 dp[i][j]=0;          }     }     ll ans=-1;     for(j=1;j<=m;j++)     {            ll maxir=-1;          for(i=1;i<=n;i++)         {             ll int l=0;             ll int r=dp[i][j]+1;             maxir=max(maxir,r);             sol[l][j]++;             sol[r][j]--;         }         ll maxi=-1;         for(i=1;i<=maxir;i++)         {             sol[i][j]=sol[i-1][j]+sol[i][j];             maxi=max(maxi,i*sol[i][j]);         }     //cout<<maxi<<endl;         ans=max(maxi,ans);     }    printf("%lld\n",ans);   } 
#include <iostream> using namespace std; char a[500][500]; int n; bool lighted[500]; bool ispossible(int i,int j){          for(int k = i+1;k < n;k++) if(a[k][j] == '#') return false;     if(lighted[j]) return false;     return true; }  int main(){     int t;     cin >> t;     while(t--){     cin >> n;     int count = 0;     int latest;     for(int i = 0;i < n;i++) lighted[i] = false;     for(int i = 0;i < n;i++){         for(int j = 0;j < n;j++) cin >> a[i][j];     }     for(int i = 0;i < n;i++){         latest = -1;         for(int j = 0;j < n;j++){             if(a[i][j] == '#') break;             if(ispossible(i,j)) latest = j;         }         if(latest != -1) lighted[latest] = true;              }     cout << endl;     for(int i =0;i < n;i++) if(lighted[i]) count++;     /*for(int i = 0;i < n;i++) {                  if(lighted[i]) cout << 1 << " ";         else cout << 0 << " ";     }*/     //cout << endl;     cout << count << endl;     }      }
#include <bits/stdc++.h> using namespace std;   long long K, M;   long long alpha[26], ans[26]; char S[10004];   int func(long long N) {     int len = 0;          for(int i=0; i<26; i++)     {         ans[i] = alpha[i]*K/N;                  if((alpha[i]*K)%N)             ans[i]++;                  len+= ans[i];     }          if(len>M)         return 0;          return 1; }   long long solve(long long left, long long right) {     long long mid = (left+right)/2;          if(!func(mid))         return solve(mid+1, right);          if(left==mid)         return mid;          return solve(left, mid); }   int main() {          scanf(" %s %lld %lld", S, &K, &M);          for(int i=0; S[i]!='\0'; i++)         alpha[S[i]-'a']++;          int x = 0;          for(int i=0; i<26; i++)         x+= (alpha[i]>0);          if(x>M)         printf("-1\n");     else     {         printf("%lld\n", solve(1, 1000000000000000001LL));                  int x = 0;                  for(int i=0; i<26; i++)             x+= ans[i];                  for(int i=0; i<M-x; i++)             printf("a");                  for(int i=0; i<26; i++)             while(ans[i])             {                 printf("%c", 'a'+i);                 ans[i]--;             }                  printf("\n");     }      	return 0; }
#include <string> #include <vector> #include <map> #include <iostream> using namespace std; map<char, int> mp;  int main() {     int t;     cin>>t;     while(t--)     {         int x;         cin>>x;                  if(x%2!=0||x==0)             cout<<"No"<<endl;         else             cout<<"Yes"<<endl;     } }          
#include<iostream> #include<math.h> #include<stdio.h> using namespace std; #define MAX 1000001 long long int cnt[1000001],p[1000001];   long long int pf(long long int n) { 	for(int i=2;i<MAX;i++) 	{ 		if(!p[i]){ 			cnt[i]++; 			 			for(int j=i+i;j<MAX;j+=i) 			{ 				p[j]=1; 				long long int tmp=j; 				while(tmp%i==0){ 				 				cnt[j]+=1; 				tmp/=i; 				} 			} 		} 		 	} 	 	for(int i=1;i<MAX;i++) 	{ 		//cout<<i<<" "<<cnt[i]<<endl; 		cnt[i]+=cnt[i-1]; 	} } int main() { 	std::ios::sync_with_stdio(false); 	long long int t,p,q,i,j,ans; 	scanf("%lld",&t); 	pf(MAX); 	while(t--)	 	{ 		scanf("%lld%lld",&p,&q); 		ans=0; 		ans=cnt[q]-cnt[p-1]; 		printf("%lld\n",ans); 	} }
#include<bits/stdc++.h> using namespace std; #define ll long long ll power(ll a,ll b,ll mod) {     if(b==0)         return 1;     if(b==1)         return a;     ll temp=power(a,b/2,mod);     temp=(temp*temp)%mod;     if(b%2)         temp=(temp*a)%mod;     return temp; } int main() {     ll t,n,m,k,ans;     scanf("%lld",&t);     while(t--)     {         scanf("%lld%lld%lld",&n,&m,&k);         ans=power(n,m,k);         printf("%lld\n",ans);     }     return 0; } 
