#include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<string> #include<iostream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath>  using namespace std;  #define s(n)					scanf("%d",&n); #define sl(n)                   scanf("%lld", &n); #define sf(n) 					scanf("%lf",&n); #define ss(n) 					scanf("%s",n); #define INF						(int)1e9 #define LINF					(long long)1e18 #define EPS						1e-12 #define FOR(i,a,b)				for(int i=a;i<b;i++) #define REP(i,n)				FOR(i,0,n) #define foreach(v,c)            for( typeof((c).begin()) v = (c).begin();  v != (c).end(); ++v) #define mp						make_pair #define FF						first #define SS						second #define tri(a,b,c)				mp(a,mp(b,c)) #define XX						first.first #define YY						first.second #define ZZ						second #define pb						push_back #define fill(a,v) 				memset(a,v,sizeof a) #define all(x)					x.begin(),x.end() #define SZ(v)					((int)(v.size())) #define DREP(a)					sort(all(a)); a.erase(unique(all(a)),a.end()) #define INDEX(arr,ind)			(lower_bound(all(arr),ind)-arr.begin()) #define debug(args...)			{dbg,args; cerr<<endl;} #define dline					cerr<<endl #define SP                      system("pause"); #define HAHA                    printf("HAHA\n"); #define mod                     10000  void debugarr(int *arr, int ind1, int ind2) { 	cout<<"[ "; 	for(int i=ind1;i<=ind2;i++) 		cout<<arr[i]<<" "; 	cout<<"]"<<endl; }  typedef long long LL; typedef pair<int,int> PII; typedef pair<LL,LL> PLL; typedef pair<LL,PII> TRI;  typedef vector<int> VI; typedef vector<LL> VL; typedef vector<PII> VII; typedef vector<PLL> VLL; typedef vector<TRI> VT;  typedef vector<VI> VVI; typedef vector<VL> VVL; typedef vector<VII> VVII; typedef vector<VLL> VVLL; typedef vector<VT> VVT;  /////////////////////////////////////////////////////////////////////////////////////////  #define N 50005 #define base (1<<16)  int x[N], y[N]; pair< PII, int> a[N]; int n; map<int, int> xmap, ymap; int cnt[4][N]; int xt[N], yt[N]; int seg[base << 1];  //   23 //   01  int sum(int node, int l, int r, int L, int R) {     if(l == L && r == R) return seg[node];     int M = (L+R)>>1;     int NN = node << 1;     if(r <= M) return sum(NN, l, r, L, M);     if(l > M) return sum(NN|1, l, r, M+1, R);     return sum(NN, l, M, L, M) + sum(NN|1, M+1, r, M+1, R); }  void update(int ind, int val) {     for(int i = ind+base; i; i>>=1) seg[i] += val; }  void go(int ind) {     sort(a, a+n);     fill(seg, 0);     REP(i, n)     {         cnt[ind][a[i].ZZ] = sum(1, 0, a[i].YY, 0, base-1);         update(a[i].YY, 1);     } }  int main() {     int T; s(T)     while(T--)     {         fill(cnt, 0);         xmap.clear();         ymap.clear();         s(n)         REP(i, n)         {             s(x[i]) s(y[i])             a[i].XX = x[i];             a[i].YY = y[i];             a[i].ZZ = i;         }         int xcnt = 0;         sort(x, x+n);         REP(i, n) if(i == 0 || x[i] != x[i-1]) xmap[x[i]] = xcnt++;         int ycnt = 0;         sort(y, y+n);         REP(i, n) if(i == 0 || y[i] != y[i-1]) ymap[y[i]] = ycnt++;         REP(i, n)         {             a[i].XX = xmap[a[i].XX];             a[i].YY = ymap[a[i].YY];         }         go(0);         REP(i, n) a[i].XX = xcnt - 1 - a[i].XX;         go(1);         REP(i, n) a[i].YY = ycnt - 1 - a[i].YY;         go(2);         REP(i, n) a[i].XX = xcnt - 1 - a[i].XX;         go(3);         LL ans = 0LL;         REP(i, n)         {             //cout << cnt[0][i] << " " << cnt[1][i] << " " << cnt[2][i] << " " << cnt[3][i] << endl;             ans = (ans + (LL) cnt[0][i]*cnt[2][i]);             ans = (ans + (LL) cnt[1][i]*cnt[3][i]);         }         //cout << "ans ---------------- :O  ------- " << ans << endl;         fill(xt, 0); fill(yt, 0);         REP(i, n) xt[a[i].XX]++;         REP(i, n) yt[a[i].YY]++;         REP(i, xcnt) ans = (ans - (LL) xt[i]*(xt[i]-1)*(xt[i]-2)/6);         REP(i, ycnt) ans = (ans - (LL) yt[i]*(yt[i]-1)*(yt[i]-2)/6);         printf("%lld\n", ans<<1);     } }  
#include <cstdio> #include <iostream> #include <vector> #include <string> #include <string.h> #include <memory.h> #include <utility> #include <queue> #include <algorithm> #include <cmath> #include <map> #include <set> #include <ctime> using namespace std;   #define mp make_pair #define pb push_back #define sz(a) int((a).size()) #define forn(i, n) for (int i=0; i<(n); ++i)   typedef long long ll; typedef long double ld; typedef pair<int,int> pii;   const int maxn = 505; const int maxm = 5000000; const int inf = 1000000000;     vector<pii> g[maxn]; int cap[maxm], cost[maxm]; int V, E;   inline void add(int x, int y, int ca, int co) {   cap[E] = ca, cost[E] = co, g[x].pb(mp(y, E++));   cap[E] = 0, cost[E] = -co, g[y].pb(mp(x, E++)); }   int d[maxn], p[maxn], pe[maxn]; int u[maxn]; vector<int> q, nq; int n, m;   bool bf(int S, int T) {   forn (i, V) d[i] = inf, u[i] = 0, p[i] = -1;   q.clear();   d[S] = 0;   q.pb(S);   for (int it=1; !q.empty(); ++it)   {     nq.clear();     forn (i, sz(q))     {       int x = q[i];       forn (j, sz(g[x]))       {         int y = g[x][j].first, e = g[x][j].second;         if (d[y] > d[x]+cost[e] && cap[e] > 0)         {           d[y] = d[x]+cost[e];           p[y] = x, pe[y] = e;           if (u[y] != it)  u[y] = it, nq.pb(y);         }       }     }     q = nq;   }   return d[T] != inf; }   int mcmf(int S, int T) {   int flow = 0, res = 0;   while (bf(S, T))   {     int push = inf;     for (int x=T; p[x]!=-1; x=p[x])       push = min(push, cap[pe[x]]);     flow += push;     for (int x=T; p[x]!=-1; x=p[x])       res += cost[pe[x]] * push, cap[pe[x]] -= push, cap[pe[x]^1] += push;   }   if (flow != n) return -1;   return res; }   int main() {   int tc; scanf("%d", &tc);   while (tc--)   {     scanf("%d %d", &n, &m);     V = 2*n+2;     int S = V-2, T = V-1;     E = 0;     forn (i, V) g[i].clear();     forn (i, m)     {       int x, y, z; scanf("%d %d %d", &x, &y, &z);       --x, --y;       add(x, y+n, 1, z);     }     forn (i, n)     {       add(S, i, 1, 0);       add(i+n, T, 1, 0);     }     int res = mcmf(S, T);     if (res == -1) puts("Impossible");     else printf("%d\n", res);   }       return 0; } 
#include<iostream> #include<stdio.h> #include<stdlib.h> #include<algorithm> #include<sstream> #include<string> #include<string.h> #include<deque> #include<vector> #include<stack> #include<queue> #include<math.h> #include<map> #include<set>  using namespace std;  typedef long long LL; typedef pair<int,int> pii;  double PI = acos(-1); double EPS = 1e-7; int INF = 1000000000; int MAXINT = 2147483647; LL INFLL = 1000000000000000000LL; LL MAXLL = 9223372036854775807LL;  #define fi first #define se second #define mp make_pair #define pb push_back  #define SIZE(a) (int)a.size() #define ALL(a) a.begin(),a.end() #define RESET(a,b) memset(a,b,sizeof(a)) #define FOR(a,b,c) for (int (a)=(b); (a)<=(c); (a)++) #define FORD(a,b,c) for (int (a)=(b); (a)>=(c); (a)--) #define FORIT(a,b) for (__typeof((b).begin()) a=(b).begin(); a!=(b).end(); (a)++) #define MIN(a, b) (a) = min((a), (b)) #define MAX(a, b) (a) = max((a), (b)) #define PAUSE system("pause")  #define input(in) freopen(in,"r",stdin) #define output(out) freopen(out,"w",stdout)  pii M[8] = {mp(0,1),mp(1,0),mp(-1,0),mp(0,-1),mp(-1,1),mp(-1,-1),mp(1,-1),mp(1,1)};  /*\   \ \   \*/   LL A[50009],P[50009],C,N;  int main() { 	LL t; 	scanf("%lld",&t);     while(t--)     {     	A[0]=0;     	scanf("%lld%lld",&N,&C);     	for(LL i=1;i<=N;i++)     	{     		scanf("%lld",&A[i]);    		}    		for(LL i=0;i<N;i++)     	{     		scanf("%lld",&P[i]);    		}    		P[N]=0;    		    		LL total =0,fuel=0;    		FOR(now,0,N-1)         {         	LL k = now+1,buy=now;         	LL dist = A[now+1]-A[now];         	LL base = dist;         	while( k<N && C >= base )         	{         		if(P[k]<=P[now]) break;        			base += A[k+1]-A[k];         		k++;         	}         	         		         	if( C < base )        	 		base=C;  	 		  	 		base -= fuel;   	 		if(base>0)  	 		{         		total += P[buy]*base;    		        fuel = base + fuel - dist;    		    }    		    else fuel -= dist;         }                        printf("%lld\n",total);     } }
 #ifndef PROGRAMMING_CONTESTS_H #define PROGRAMMING_CONTESTS_H #include <algorithm> #include <bitset> #include <cctype> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <iostream> #include <limits> #include <list> #include <map> #include <queue> #include <set> #include <sstream> #include <string> #include <typeinfo> #include <utility> #include <vector> #ifdef LOCALHOST static FILE* _freopen=freopen("input.txt","r",stdin); #else #define NDEBUG #endif #include <cassert> using namespace std;  typedef long long LL; typedef unsigned long long ULL; typedef pair<int,int> PII;  #define IT(c) typeof(c.begin()) #define PB push_back #define MP make_pair #define LEN(a) (sizeof(a)/sizeof(a[0])) #define ALL(c) c.begin(),c.end() #define FOR(i,a,b) for(int i=(a), _b=(b); i<_b; ++i) #define FORD(i,a,b) for(int i=(b-1), _a=(a); i>=_a; --i) #define FORE(i,c) for(IT(c) i=(c).begin(); i!=(c).end(); ++i)  static int RI(){int res;int r=scanf("%d ",&res);assert(r==1);return res;} static LL RLL(){LL res;int r=scanf("%lld ",&res);assert(r==1);return res;} static ULL RULL(){ULL res;int r=scanf("%llu ",&res);assert(r==1);return res;} static double RD(){double res;int r=scanf("%lf ",&res);assert(r==1);return res;} static string RS(){char buf[2000];int r=scanf("%s ",buf);assert(r==1);return string(buf);} static string RL(){string res;getline(cin,res);assert(cin.good());return res;} //Requires and discards line break at end of line. static const double PI=acos(-1.0), EPS=1e-10; template<typename T> static string str(T x){stringstream ss;ss<<x;return ss.str();} template<typename A,typename V> static void fill(A& a,V v){fill_n((V*)a,sizeof(a)/sizeof(v),v);} // Requires A is a V array. static double timer(){return 1.0*clock()/CLOCKS_PER_SEC;}  #endif //PROGRAMMING_CONTESTS_H   int n,r,k,m=100000007; vector<int> a[405];  LL mem[405][405][2];  //direct is true iff can use the edge (parent,v) LL f(int parent, int parentI, int k, int direct){   int v=(parent==-1?1:a[parent][parentI]);   LL& res=mem[v][k][direct];   if(res!=-1) return res;   res=0;    bool hasChild=a[v].size()>0, hasRSib=parent!=-1&&parentI+1<a[parent].size();   if(!hasChild&&hasRSib){     res=(res+f(parent,parentI+1,k,direct))%m; //dont use edge     if(direct&&k>0)res=(res+f(parent,parentI+1,k-1,0))%m; //use edge   } else if(hasChild&&!hasRSib){     res=(res+f(v,0,k,1))%m; //dont use edge     if(direct&&k>0)res=(res+f(v,0,k-1,0))%m; //use edge   } else if(hasChild&&hasRSib){     FOR(give,0,k+1){ //how many to give to next sibling?       int left=k-give;       res=(res+f(v,0,left,1)*f(parent,parentI+1,give,direct))%m; //dont use edge       if(direct&&left>0)res=(res+f(v,0,left-1,0)*f(parent,parentI+1,give,0))%m; //use edge     }   } else {     res=(k==0||k==1&&direct);   }        return res; }   int main(int argc, char** argv) {   FOR(test,0,RI()){     n=RI(),r=RI(),k=RI();     FOR(i,1,n+1)a[i].clear();     fill(mem,-1);          vector<int> t[405];     FOR(i,0,r){       int v=RI(),w=RI();       t[v].PB(w);       t[w].PB(v);     }          queue<int> q;     q.push(1);     bool seen[405]={0};     seen[1]=true;     while(!q.empty()){       int v=q.front();       q.pop();       FOR(i,0,t[v].size()) {         int c=t[v][i];         if(!seen[c]){           seen[c]=true;           q.push(c);           a[v].PB(c);         }       }     }          cout<<f(-1,0,k,0)<<endl;   }   return 0; } 
#include <cstdio> #include <cstdlib> #include <cstring> #include <string> #include <vector> #include <iostream> #include <cmath> #include <set> #include <ctime> #include <algorithm> #define min(a,b)	((a)<(b)?(a):(b)) #define max(a,b)	((a)>(b)?(a):(b)) #define abs(a)	((a)<0?-(a):(a)) #define inf 214748364 #define pi 3.141592653589793 #define maxn 1010 #define maxm 30001 using namespace std; typedef long long ll; int con,st[maxm],en[maxm],next[maxm]; int fir[maxn]; int ma[maxm],l[maxm],t[maxm]; double v[maxm]; int n,m; double f[maxn]; //int g[maxn]; int head,tail,q[1000001]; inline void addline(int st,int en,double inpv) { 	next[++con]=fir[st],fir[st]=con; 	t[con]=en,v[con]=inpv; } inline bool check(double ans) { 	memset(fir,0,sizeof(fir)); 	con=0; 	for(int i=1;i<=m;++i) 		addline(st[i],en[i],ma[i]-l[i]*ans); 	memset(f,127,sizeof(f)); 	f[1]=0; 	q[head=tail=0]=1; 	while(head<=tail) 	{ 		int p=q[head++]; 		for(int i=fir[p];i;i=next[i]) 		if(f[t[i]]>f[p]+v[i]) 		{ 			f[t[i]]=f[p]+v[i]; 			q[++tail]=t[i]; //			g[t[i]]++; 			if(f[n]<=0) 				return 1; 		} 	} 	return f[n]<=0; } int main() { 	int tim; 	scanf("%d",&tim); 	while(tim--) 	{ 		scanf("%d%d",&n,&m); 		if(n<=1) 		{ 			printf("0.0000\n"); 			continue; 		} 		for(int i=1;i<=m;++i) 		{ 			scanf("%d%d%d%d",&st[i],&en[i],&ma[i],&l[i]); 			if(ma[i]<=60) 				ma[i]=l[i]*(70-ma[i]);else 				ma[i]=l[i]*10; 		} 		double low=0,high=1e4,mid; 		while(high-low>1e-6) 		{ 			mid=(low+high)/2.0; 			if(check(mid)) 				high=mid;else 				low=mid; 		} 		printf("%.4lf\n",low+0.0000499999999); //		printf("%.4lf\n",low); 	} 	return 0; } 
#include <bits/stdc++.h>  using namespace std;  const int N = 21;  const long long mod = (long long) 100000007 ;  long long a[N][N]; long long dp[(1<<N) + 5];  string conso;  int get_id(char ch) {     for (int i = 0; i < conso.size(); i++) {         if (conso[i] == ch) {             return i;         }     } }  string vowels = "AEIOU";  int isVowel(char ch) {     for (int i = 0; i < vowels.size(); i++) {         if (vowels[i] == ch) {             return true;         }     }     return false; }  int main() {     //freopen("in.txt", "r", stdin);      ios_base::sync_with_stdio(false);     cin.tie(NULL);      for (char i = 'A'; i <= 'Z'; i++) {         if (!isVowel(i))             conso += i;     }      //cout << conso << endl;      int n;     cin >> n;     for (int i = 0; i < n; i++) {         string s;         cin >> s;         int fir = get_id(s[0]);         int sec = get_id(s[s.size() - 1]);         a[fir][sec]++;     }      dp[0] = 1;     for (int mask = 0; mask < (1 << conso.size()); mask++) {         for (int i = 0; i < conso.size(); i++) {             if (!(mask & (1 << i))) {                 long long &res = dp[mask | (1 << i)];                 res += (dp[mask] * (long long) a[__builtin_popcount(mask)][i]) % mod;                 if (res >= mod) {                     res -= mod;                 }             }         }     }      cout << dp[(1 << conso.size()) - 1] << endl;       return 0; } 
#include<stdio.h> #include<stdlib.h> #include<assert.h> #include<deque> #include<iostream> #include<string.h> #include<math.h> #include<set> #include<map> #include<vector> #include<algorithm> #include<bitset> #include<stack> #include<queue> #define MODM 1000000007 #define MAXM 2147483647 #define mp make_pair #define ff first #define ss second #define Pi 3.14159265358979323846264 #define pb push_back #define pf push_front #define ppb pop_back #define ppf pop_front #define Sort(x) sort(x.begin(),x.end()) #define P pair<int,int> #define S(x) scanf("%d",&x); using namespace std; typedef long long int lli; typedef unsigned long long int llu;  lli gcd(lli a,lli b){if(a==0)return(b);else return(gcd(b%a,a));} lli fastpow(lli a,lli n,lli temp){if(n==1)return((a*temp)%MODM); if(n&1)temp=(temp*a)%MODM;return(fastpow((a*a)%MODM,n/2,temp));} int scan() {  int t=0,m=1;char c;c=getchar();while((c<'0' || c>'9') and c!='-') c=getchar();if(c=='-'){c=getchar();m=-1;}  while(c>='0' && c<='9'){t=(t<<3)+(t<<1)+c-'0';c=getchar();} return(t*m); } vector<int>v,hash; vector< vector<int> >adj; map< vector<int>,int>mymap; lli fact[10005]; char done[10005]; int num; lli solve(int nd,int par) {	 	lli ans=1; 	int nnd; 	vector<int>lst; 	lst.pb(-1); 	for(int i=0;i<adj[nd].size();i++) 	{ 		nnd=adj[nd][i]; 		if(nnd!=par) 		{	 			//printf("called to %d\n",nnd); 			ans=(ans*solve(nnd,nd))%MODM; 			if(mymap[hash]==0) 			{ 				mymap[hash]=(++num); 				lst.pb(num); 			} 			else 			lst.pb(mymap[hash]); 		} 	} 	//printf("node=%d %d\nlist\n",nd,lst.size()); 	Sort(lst); 	/*for(int i=0;i<lst.size();i++) 	printf("%d ",lst[i]); 	printf("\n");*/ 	int cnt=1; 	for(int i=1;i<lst.size();i++) 	{ 		if(lst[i]!=lst[i-1]) 		{ 			ans=(ans*fact[cnt])%MODM; 			cnt=1; 		} 		else cnt++; 	} 	ans=(ans*fact[cnt])%MODM; 	hash=lst; 	return(ans); }	 		 int main() { 	int n,t,x,y; 	lli ans,cnt; 	fact[0]=fact[1]=1; 	for(int i=2;i<=10001;i++) 	fact[i]=(fact[i-1]*i)%MODM; 	S(t); 	while(t--) 	{	 		num=0; 		mymap.clear(); adj.clear(); hash.clear(); 		S(n); 		for(int i=0;i<n;i++) 		adj.pb(v); 		for(int i=0;i<n-1;i++) 		{ 			S(x);S(y); 			adj[x].pb(y); 			adj[y].pb(x); 		} 		printf("%lld\n",solve(0,-1)); 	} 	return(0); } 				 				
#include <stdio.h>   using namespace std;   int state[55]; void rotate(int a, int b, int c, int d); void Permute(char code); long long lcm(long long a, long long b); long long gcd(long long a, long long b);   int main () { int i, j, T, temp; long long moves, cycle_len; char input[1010], code; bool seen[55]; scanf("%d", &T); while (T--) { for (i=1; i<=54; i++) { state[i] = i; seen[i] = false; } scanf("%s", input); i = 0; while (input[i] != '\0') { code = input[i]; if (input[i+1] != '\'' and input[i+1] != '2') { Permute(code); i++; } else { Permute(code); Permute(code); if (input[i+1] == '\'') Permute(code); i += 2; } } moves = 1; for (i=1; i<=54; i++) { if (seen[i]) continue; seen[i] = true; cycle_len = 1; temp = i; j = state[i]; while (temp != j) { j = state[j]; seen[j] = true; cycle_len++; } moves = lcm(moves, cycle_len); } printf("%lld\n", moves); } return 0; }   long long gcd(long long a, long long b) { if (a == 0) return b; if (b == 0) return a; if (a == 1 or b == 1) return 1; if (a == b) return a; if (a > b) return gcd(b, a%b); else return gcd(a, b%a); }   long long lcm(long long a, long long b) { if (a == 1) return b; if (b == 1) return a; if (a == b) return a; return (a/gcd(a, b))*b; }   void rotate(int a, int b, int c, int d) { int temp = state[d]; state[d] = state[c]; state[c] = state[b]; state[b] = state[a]; state[a] = temp; }   void Permute(char code) { switch(code) { case 'U': { rotate(19, 21, 27, 25); rotate(20, 24, 26, 22); rotate(7, 28, 39, 18); rotate(8, 31, 38, 15); rotate(9, 34, 37, 12); break; } case 'D': { rotate(46, 48, 54, 52); rotate(47, 51, 53, 49); rotate(43, 36, 3, 10); rotate(44, 33, 2, 13); rotate(45, 30, 1, 16); break; } case 'F': { rotate(37, 39, 45, 43); rotate(38, 42, 44, 40); rotate(25, 34, 48, 16); rotate(26, 35, 47, 17); rotate(27, 36, 46, 18); break; } case 'B': { rotate(1, 3, 9, 7); rotate(2, 6, 8, 4); rotate(19, 10, 54, 28); rotate(20, 11, 53, 29); rotate(21, 12, 52, 30); break; } case 'L': { rotate(10, 12, 18, 16); rotate(11, 15, 17, 13); rotate(1, 19, 37, 46); rotate(4, 22, 40, 49); rotate(7, 25, 43, 52); break; } case 'R': { rotate(28, 30, 36, 34); rotate(29, 33, 35, 31); rotate(48, 39, 21, 3); rotate(51, 42, 24, 6); rotate(54, 45, 27, 9); break; } } }
#include<cstdio> #include<cstdlib> #include<algorithm>  using namespace std;  typedef long long LL; const LL MOD = 100000007;  LL gcd(LL a, LL b){return b?gcd(b, a%b):a;}  int T; pair<LL, LL>p[4];   int main(){ 	for(scanf("%d", &T); T--; ){  		for(int i=0; i<4; i++)scanf("%lld%lld", &p[i].first, &p[i].second); 		sort(p, p+4);  		p[0].first=abs(p[1].first-p[0].first); 		p[0].second=abs(p[1].second-p[0].second);  		LL s = (p[0].first*p[0].first + p[0].second*p[0].second)%MOD; 		LL ans, g; 		g=gcd(p[0].first, p[0].second)%MOD; 		ans = 2*s*(s-2*g +1)%MOD; 		for(;ans<0;)ans+=MOD; 		printf("%lld\n", ans); 	} 	return 0; } 
#include<iostream> #include<stdio.h> #include<string.h> #include<stdlib.h> #define N 100000007 using namespace std;  struct dat{ 	int digit; 	int val; };  typedef struct dat dat;  dat getChar(char a) { 	dat tmp; 	if(a=='a') {tmp.digit=2;tmp.val=1;} 	else if(a=='b') {tmp.digit=2;tmp.val=2;} 	else if(a=='c') {tmp.digit=2;tmp.val=3;} 	else if(a=='d') {tmp.digit=3;tmp.val=1;} 	else if(a=='e') {tmp.digit=3;tmp.val=2;} 	else if(a=='f') {tmp.digit=3;tmp.val=3;} 	else if(a=='g') {tmp.digit=4;tmp.val=1;} 	else if(a=='h') {tmp.digit=4;tmp.val=2;} 	else if(a=='i') {tmp.digit=4;tmp.val=3;} 	else if(a=='j') {tmp.digit=5;tmp.val=1;} 	else if(a=='k') {tmp.digit=5;tmp.val=2;} 	else if(a=='l') {tmp.digit=5;tmp.val=3;} 	else if(a=='m') {tmp.digit=6;tmp.val=1;} 	else if(a=='n') {tmp.digit=6;tmp.val=2;} 	else if(a=='o') {tmp.digit=6;tmp.val=3;} 	else if(a=='p') {tmp.digit=7;tmp.val=1;} 	else if(a=='q') {tmp.digit=7;tmp.val=2;} 	else if(a=='r') {tmp.digit=7;tmp.val=3;} 	else if(a=='s') {tmp.digit=7;tmp.val=4;} 	else if(a=='t') {tmp.digit=8;tmp.val=1;} 	else if(a=='u') {tmp.digit=8;tmp.val=2;} 	else if(a=='v') {tmp.digit=8;tmp.val=3;} 	else if(a=='w') {tmp.digit=9;tmp.val=1;} 	else if(a=='x') {tmp.digit=9;tmp.val=2;} 	else if(a=='y') {tmp.digit=9;tmp.val=3;} 	else if(a=='z') {tmp.digit=9;tmp.val=4;} 	return tmp; }  int main() { 	int T,i; 	int dp1[500000]; 	int dp2[500000]; 	dp1[0]=dp2[0]=1; 	dp1[1]=dp2[1]=2; 	dp1[2]=dp2[2]=4; 	dp1[3]=dp2[3]=8; 	dp1[4]=16; 	dp2[4]=15; 	for (i=5;i<=410000;i++) 	{ 		dp2[i] = (dp2[i-1] + dp2[i-2] + dp2[i-3] + 1)%N; 		dp1[i] = (dp1[i-1] + dp1[i-2] + dp1[i-3] + dp1[i-4] + 1)%N; 	} 	scanf("%d",&T); 	char str[111111]; 	long long ans=1; 	while(T--) 	{ 		ans=1; 		scanf("%s",str); 		int l=strlen(str); 		dat buffer; 		dat temp; 		temp=getChar(str[0]); 		buffer.digit=temp.digit; 		buffer.val=temp.val; 		for(i=1;i<l;i++) 		{ 			temp=getChar(str[i]); 			if(temp.digit==buffer.digit) 			{ 				buffer.val+=temp.val; 			} 			else 			{ 				if(buffer.digit==7 || buffer.digit==9) 					ans=(ans*dp1[buffer.val-1])%N; 				else 					ans=(ans*dp2[buffer.val-1])%N; 				buffer.digit=temp.digit; 				buffer.val=temp.val; 			} 		} 		if(buffer.digit!=0) 		{ 			if(buffer.digit==7 || buffer.digit==9) 				ans=(ans*dp1[buffer.val-1])%N; 			else 				ans=(ans*dp2[buffer.val-1])%N; 		} 		printf("%lld\n",ans); 	} } 
#include<iostream> #include<cstdio> #include<vector> #include<algorithm> #include<utility>  using namespace std;  typedef long long int ULL;  vector<ULL> prime; int iterations = 10; int isp[605];  int isPrime(int n) {         if (n < 2)                 return false;         for (int i = 2; i * i <= n; i++)                 if (n % i == 0)                         return false;         return true; }  void compute() {         for (int i = 2; i <= 600; i++)         {                 if (isPrime(i))                         prime.push_back(i);         } }  const ULL mask = (1<<20)-1;  ULL mulMod(ULL a , ULL b , ULL c) {         ULL z= (a*(b&mask))%c  +  (((a<<20)%c)*(b>>20))%c;         while (z >= c)                 z -= c;         return z;  }  ULL modulo(ULL a, ULL b , ULL c) {         ULL res = 1;         while (b > 0)         {                 if (b & 1)                       res   = mulMod(res , a, c);                 a = mulMod(a , a, c);                 b >>= 1;         }         return res; }  int witness[] = {2 , 3, 5, 7 , 11};  int millerRabinTest(ULL N) {         if (N < 2)                  return false;         if (N % 2 == 0) return N == 2 ;         if (N % 3 == 0) return N == 3;         if (N % 5 == 0) return N == 5;         if (N % 7 == 0) return N == 7;         if (N % 11 == 0) return N == 11;         //if (N % 13 == 0) return N == 13;                  ULL  s = N - 1;         while ((s & 1) == 0)         {                 s /= 2;         }                  for (int i = 0; i  < iterations ; i++)         {                 ULL a = rand() % (N - 1) + 1 , temp = s;                 ULL mod = modulo(a , temp , N);                 while (temp != N - 1 && mod != 1 && mod != N - 1)                 {                         mod = mulMod(mod , mod , N);                         temp *= 2;                 }                 if (mod != N - 1 && (temp & 1) ==  0)                         return false;         }         return true; }  ULL solve(ULL N) {         N += 2;         if (N == 2)                 return 1;         for (int i = 0; i <= 600; i++)                 isp[i] = true;          /*                for (int i = 0; i < prime.size(); i++)         {                        ULL p = prime[i];                 if (p > N)                               break;                 ULL t = p;                 t = ((N  + p - 1) / p) * p;                 while (t < N + 600)                 {                         //cout<<t<<" ";                         if (p < t)                                 isp[t - N]  = false;                         t += p;                 }         }         /*         for (int i = 0; i < 600; i++)                 if (isp[i])                         cout<<i<<endl;                  //return true;         //cout<<millerRabinTest(34)<<endl;         */         for (ULL i = N ; ; i++)         {                 if (millerRabinTest(i))                 {                         //cout<<i<<endl;                         //cout<<"here"<<endl;                         return i;                 }         } }  int main() {         compute();         int T;         scanf("%d" , &T);                  while (T--)         {                 ULL x ;                 scanf("%llu" , &x);                 printf("%llu\n" , solve(x));         }                  return 0; }
#include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<string> #include<iostream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath> #include<string> //#include<debugger>   using namespace std;   #define s(n)					scanf("%d",&n) #define sl(n) 					scanf("%lld",&n) #define sf(n) 					scanf("%lf",&n) #define ss(n) 					scanf("%s",n) #define INF						(int)1e9 #define LINF					(long long)1e18 #define EPS						1e-9 #define maX(a,b)				((a)>(b)?(a):(b)) #define miN(a,b)				((a)<(b)?(a):(b)) #define abS(x)					((x)<0?-(x):(x)) #define FOR(i,a,b)				for(int i=a;i<b;i++) #define REP(i,n)				FOR(i,0,n) #define foreach(v,c)            for( typeof((c).begin()) v = (c).begin();  v != (c).end(); ++v) #define mp						make_pair #define FF						first #define SS						second #define tri(a,b,c)				mp(a,mp(b,c)) #define XX						first #define YY						second.first #define ZZ						second.second #define pb						push_back #define fill(a,v) 				memset(a,v,sizeof a) #define all(x)					x.begin(),x.end() #define SZ(v)					((int)(v.size())) #define DREP(a)					sort(all(a)); a.erase(unique(all(a)),a.end()) #define INDEX(arr,ind)			(lower_bound(all(arr),ind)-arr.begin()) #define debug(args...)			{dbg,args; cerr<<endl;} #define dline					cerr<<endl	   void sc(char &c){ 	char temp[4];	ss(temp);	 	c=temp[0]; }   struct debugger { 	template<typename T> debugger& operator , (const T& v) 	{	 		cerr<<v<<" ";	 		return *this;	 	} } dbg;         typedef long long LL; typedef pair<int,int> PII; typedef pair<LL,LL> PLL; typedef pair<int,PII> TRI;   typedef vector<int> VI; typedef vector<LL> VL; typedef vector<PII> VII; typedef vector<PLL> VLL; typedef vector<TRI> VT;   typedef vector<VI> VVI; typedef vector<VL> VVL; typedef vector<VII> VVII; typedef vector<VLL> VVLL; typedef vector<VT> VVT;     /*Main code begins now */   int testnum;     const int BASE = 1<<17; int r[3][BASE+BASE]; int f[3][BASE+BASE];   int lo,hi,mode; void update(int ind,int beg,int end) { 	if(beg>hi || end<lo) return; 	if(lo<=beg && end<=hi) 	{ 		r[mode][ind] = end-beg+1 - r[mode][ind]; 		f[mode][ind] = 1-f[mode][ind]; 		 		int len = end-beg+1; 		for(ind>>=1,len<<=1; ind; ind>>=1,len<<=1) 		{ 			r[mode][ind] = r[mode][ind+ind] + r[mode][ind+ind+1]; 			if(f[mode][ind]) 				r[mode][ind] = len - r[mode][ind]; 		} 		return; 	} 	 	int twice=ind<<1; 	int mid = (beg+end)>>1; 	 	update(twice,beg,mid); 	update(twice+1,mid+1,end); }   void updatex(int _lo,int _hi,int _mode) { 	lo=_lo; 	hi=_hi; 	mode=_mode; 	update(1,0,BASE-1); }   int query(int ind,int beg,int end,int flip) { 	if(beg>hi || end<lo) return 0; 	if(lo<=beg && end<=hi) return flip ? end-beg+1 - r[mode][ind] : r[mode][ind]; 	 	int twice=ind<<1; 	int mid = (beg+end)>>1; 	flip = flip^f[mode][ind]; 	 	return query(twice,beg,mid,flip) + query(twice+1,mid+1,end,flip); }   int query(int _lo,int _hi,int _mode) { 	lo=_lo; 	hi=_hi; 	mode=_mode; 	return query(1,0,BASE-1,0); }   void init() { 	fill(r,0); 	fill(f,0); } 	 int NX,NY,NZ,Q;       void preprocess() {   }   void solve() { 	init(); 	for(int i=0;i<Q;i++) 	{ 		int k; s(k); 		if(k==3) 		{ 			int x1,x2,y1,y2,z1,z2; 			s(x1); s(y1); s(z1); s(x2); s(y2); s(z2); 			LL a = query(x1,x2,0); LL na = x2-x1+1-a; 			LL b = query(y1,y2,1); LL nb = y2-y1+1-b; 			LL c = query(z1,z2,2); LL nc = z2-z1+1-c; 			LL ans = a*b*c + a*nb*nc + na*b*nc + na*nb*c; 			//debug(a,na," ",b,nb," ",c,nc); 			printf("%lld\n",ans); 		} 		else 		{ 			int c1,c2;  			s(c1); s(c2); 			updatex(c1,c2,k); 		} 	} 			 		 }       bool input() { 	s(NX); s(NY); s(NZ); s(Q); 	return true; }     int main() { 	preprocess(); 	int T; s(T); 	for(testnum=1;testnum<=T;testnum++) 	{ 		if(!input()) break; 		solve(); 	} }
#include<cstdio>  #define rep(i,n) for(int i=0;i<(n);i++)  using namespace std;  typedef long long ll;  const ll M=100000007;  ll gcd(ll a,ll b){ return b?gcd(b,a%b):a; }  int main(){ 	int T; scanf("%d",&T); 	while(T--){ 		ll N,Q; scanf("%lld%lld",&N,&Q); 		printf("%lld\n",Q*(1+((Q-1)/2)/(Q/gcd(N,Q)))%M); 	} 	return 0; } 
#include<stdio.h> #include<algorithm>  using namespace std;  int list[510][55]; int likes[510]; int count_[510]; int sorted[510]; bool mark[510]; int n, set_size, favList;  void print() { 	int i; 	for(i=0;i<n;i++) 		printf("%d ", count_[i]); 	printf("\n"); 	for(i=0;i<n;i++) 		printf("%d ", count_[sorted[i]]); 	printf("\n"); }   bool cmp(int a, int b) { 	if(count_[a]<count_[b]) 		return true; 	else 		return false; }  int main() { 	int i, j, k, l, temp, t; 	bool pr = true; 	scanf("%d", &t); 	while(t--) 	{ 		for(i=0;i<510;i++) 			likes[i]=count_[i]=0; 		for(i=0;i<510;i++) 			mark[i]=false; 		for(i=0;i<510;i++) 			sorted[i]=i; 			 		scanf("%d", &n); 		for(i=0;i<n;i++) 		{ 			scanf("%d", &k); 			likes[i]=k; 			for(j=0;j<k;j++) 			{ 				scanf("%d", &l); 				list[i][j]=l; 				count_[l]++; 			} 		} 		sort(sorted, sorted+n, cmp); 		//print(); 		for(i=0;i<n;i++) 		{ 			pr = true; 			if(count_[sorted[i]]<=i) 			{ 				//printf("Enter when i: %d\n", i); 				set_size = i+1; 				favList=0; 				for(j=0;j<n;j++) 				{ 					for(k=0;k<likes[j];k++) 					{ 						if(count_[list[j][k]]<=i) 						{ 							favList++; 							break; 						} 					} 				} 				if(favList<=i) 				{ 					printf("not safe\n"); 					pr = false; 					break; 				} 			} 		} 		if(pr) 			printf("safe\n"); 	} 	return 0; } 
#include<iostream> #include<stdio.h> using namespace std;  int a[177]={1,2,3,4,6,8,9,10,12,16,18,20,24,30,32,36,40,48,60,64,72,80,84,90,96,100,108,120,128,144,160,168,180,192,200,216,224,240,256,288,320,336,360,384,400,432,448,480,504,512,576,600,640,672,720,768,800,864,896,960,1008,1024,1152,1200,1280,1344,1440,1536,1600,1680,1728,1792,1920,2016,2048,2304,2400,2688,2880,3072,3360,3456,3584,3600,3840,4032,4096,4320,4608,4800,5040,5376,5760,6144,6720,6912,7168,7200,7680,8064,8192,8640,9216,10080,10368,10752,11520,12288,12960,13440,13824,14336,14400,15360,16128,16384,17280,18432,20160,20736,21504,23040,24576,25920,26880,27648,28672,28800,30720,32256,32768,34560,36864,40320,41472,43008,46080,48384,49152,51840,53760,55296,57600,61440,62208,64512,65536,69120,73728,80640,82944,86016,92160,96768,98304,103680,107520,110592,115200,122880,124416,129024,131072,138240,147456,153600,161280}; char value[168][100] = {"1","2","4","6","12","24","36","48","60","120","180","240","360","720","840","1260","1680","2520","5040","7560","10080","15120","20160","25200","27720","45360","50400","55440","83160","110880","166320","221760","277200","332640","498960","554400","665280","720720","1081080","1441440","2162160","2882880","3603600","4324320","6486480","7207200","8648640","10810800","14414400","17297280","21621600","32432400","36756720","43243200","61261200","73513440","110270160","122522400","147026880","183783600","245044800","294053760","367567200","551350800","698377680","735134400","1102701600","1396755360","2095133040","2205403200","2327925600","2793510720","3491888400","4655851200","5587021440","6983776800","10475665200","13967553600","20951330400","27935107200","41902660800","48886437600","64250746560","73329656400","80313433200","97772875200","128501493120","146659312800","160626866400","240940299600","293318625600","321253732800","481880599200","642507465600","963761198400","1124388064800","1606268664000","1686582097200","1927522396800","2248776129600","3212537328000","3373164194400","4497552259200","6746328388800","8995104518400","9316358251200","13492656777600","18632716502400","26985313555200","27949074753600","32607253879200","46581791256000","48910880818800","55898149507200","65214507758400","93163582512000","97821761637600","130429015516800","195643523275200","260858031033600","288807105787200","391287046550400","577614211574400","782574093100800","866421317361600","1010824870255200","1444035528936000","1516237305382800","1732842634723200","2021649740510400","2888071057872000","3032474610765600","4043299481020800","6064949221531200","8086598962041600","10108248702552000","12129898443062400","18194847664593600","20216497405104000","24259796886124800","30324746107656000","36389695329187200","48519593772249600","60649492215312000","72779390658374400","74801040398884800","106858629141264000","112201560598327200","149602080797769600","224403121196654400","299204161595539200","374005201994424000","448806242393308800","673209363589963200","748010403988848000","897612484786617600","1122015605983272000","1346418727179926400","1795224969573235200","2244031211966544000","2692837454359852800","3066842656354276800","4381203794791824000","4488062423933088000","6133685312708553600","8976124847866176000","9200527969062830400"};   int main() { 	int T; 	scanf("%d",&T); 	while(T--) 	{ 		int i; 		int n; 		scanf("%d",&n); 		for(i=0;i<167;i++) 		{ 			if(a[i]>n) 			{ 				printf("win %s\n",value[i]); 				break; 			}	 		} 		if(i==167) 			printf("lose\n"); 	} } 
#include<cmath> #include<cstdio> #include<vector>  #define rep(i,n) for(int i=0;i<(n);i++)  using namespace std;  const double PI=acos(-1);  const int V_MAX=100;  bool augment(int u,bool *vis,int match[2][V_MAX],const vector<int> *G){ 	if(u==-1) return true;  	rep(i,G[u].size()){ 		int v=G[u][i]; 		if(!vis[v]){ 			vis[v]=true; 			if(augment(match[1][v],vis,match,G)){ 				match[0][u]=v; 				match[1][v]=u; 				return true; 			} 		} 	} 	return false; }  int bipartite_matching(int L,int R,const vector<int> *G){ 	static int match[2][V_MAX]; 	rep(u,L) match[0][u]=-1; 	rep(v,R) match[1][v]=-1;  	int res=0; 	static bool vis[V_MAX]; 	rep(u,L){ 		rep(v,R) vis[v]=false; 		if(augment(u,vis,match,G)) res++; 	} 	return res; }  double dist(double r,double la1,double lo1,double la2,double lo2){ 	double x1=r*cos(lo1)*cos(la1),y1=r*sin(lo1)*cos(la1),z1=r*sin(la1); 	double x2=r*cos(lo2)*cos(la2),y2=r*sin(lo2)*cos(la2),z2=r*sin(la2); 	double d=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)+(z1-z2)*(z1-z2)); 	double theta=acos(1-d*d/(2*r*r)); 	return r*theta; }  int main(){ 	int T; scanf("%d",&T); 	while(T--){ 		int n,m; 		double r; scanf("%d%d%lf",&n,&m,&r); 		double lat1[100],lon1[100],lat2[100],lon2[100]; 		rep(u,n) scanf("%lf%lf",lat1+u,lon1+u), lat1[u]*=PI/180, lon1[u]*=PI/180; 		rep(v,m) scanf("%lf%lf",lat2+v,lon2+v), lat2[v]*=PI/180, lon2[v]*=PI/180;  		double lo=0,hi=0; 		double d[100][100]; 		rep(u,n) rep(v,m) { 			d[u][v]=dist(r,lat1[u],lon1[u],lat2[v],lon2[v]); 			hi=max(hi,d[u][v]); 		}  		while(abs(hi-lo)/hi>1e-7){ 			double mi=(lo+hi)/2; 			vector<int> G[100]; 			rep(u,n) rep(v,m) if(d[u][v]<mi) G[u].push_back(v); 			if(bipartite_matching(n,m,G)==m) hi=mi; else lo=mi; 		} 		printf("%E\n",(lo+hi)/2); 	}  	return 0; } 
#include<iostream> #include<cstdio> #include<cstring>  using namespace std;  typedef long long int LL;  int N , M , Q; LL K;  int adjMat[105][105]; int visited[105]; int isConnected;  const LL mod = 100000007LL;  void dfs(int u , int target) {         visited[u] = true;         if (u == target) {                 isConnected = true;                 return;         }         for (int i = 0; i < N ;i ++) {                 if (adjMat[u][i] == 1 && !visited[i])                          dfs(i,target);         } }  void DFS(int u) {         visited[u] = true;         for (int i = 0; i < N; i++)                  if (!visited[i] && adjMat[u][i] == 1)                         DFS(i); }  int main() {         int T;         scanf("%d",&T);         while (T--) {                 memset(adjMat,0,sizeof(adjMat));                 memset(visited,0,sizeof(visited));                                                          scanf("%d%d%d",&N,&M,&Q);                 for (int i = 0; i < M; i++) {                         int t1 , t2;                         scanf("%d%d",&t1,&t2);                         adjMat[t1][t2] = 1;                         adjMat[t2][t1] = 1;                 }                                  int C = 0;                                  for (int i = 0 ; i < N ; i++) {                         if (!visited[i]) {                                 DFS(i);                                 C++;                         }                 }                                                  while (Q--) {                         isConnected = false;                         scanf("%lld",&K);                         if (K == 0 ) {                                 int a , b;                                  scanf("%d%d",&a,&b);                                 memset(visited,0,sizeof(visited));                                 dfs(a,b);                                 if (isConnected) {                                         adjMat[a][b] = 1;                                         adjMat[b][a] = 1;                                                   } else {                                         C --;                                         adjMat[a][b] = 1;                                         adjMat[b][a] = 1;                                 }                         } else if (K == 1) {                                 int a , b;                                  scanf("%d%d",&a,&b);                                 memset(visited,0,sizeof(visited));                                 dfs(a,b);                                 if (isConnected) {                                         adjMat[a][b] = 0;                                         adjMat[b][a] = 0;                                         isConnected = false;                                         memset(visited,0,sizeof(visited));                                         dfs(a,b);                                         if (!isConnected) C++;                                 }                                           } else {                                 LL ans = 1;                                 for (int i = 0; i < C ; i++) {                                         ans *= K;                                         if (ans >= mod)                                                 ans %= mod;                                 }                                 for (int i = 0;i < N - C; i++) {                                         ans *= (K - 1);                                         if (ans >= mod)                                                  ans %= mod;                                 }                                 printf("%lld\n", ans);                         }                 }                 }                return 0; }
#include<cstdio> #include<cstdlib> #include<cstring> #include<cmath> #include<cctype>  #include<iostream> #include<algorithm> #include<vector> #include<map>  using namespace std;  #define ll long long #define pb push_back #define SZ(a) ((int)a.size()) #define Max_N 1100 #define Set(a, b) memset(a, b, sizeof(a))  ll dp[Max_N]; vector<ll>V[Max_N];  ll process(ll cur);  int main() {     ll t, i, j, n, m, a, b;     scanf(" %lld", &t);         for(j=1;j<=t;j++)         {             scanf(" %lld %lld", &n, &m);             for(i=0;i<m;i++)             {                 scanf(" %lld %lld", &a, &b);                 V[a].pb(b);             }             ll Max=0;             Set(dp, 0);             for(i=0;i<n;i++)             {                 Max=max(Max, process(i));             }             for(i=0;i<n;i++) V[i].clear();             printf("%lld\n", Max);         }     return 0; }  ll process(ll cur) {     ll Max=1;     ll i, j;     if(dp[cur]!=0) return dp[cur];     for(i=0;i<SZ(V[cur]);i++)         Max=max(Max, process(V[cur][i])+1);     dp[cur]=Max;     return Max; } 
//#pragma comment(linker, "/STACK:16777216") #include <iostream> #include <cstdio> #include <cmath> #include <set> #include <vector> #include <map> #include <cstring> #include <sstream> #include <algorithm> #include <string> #include <queue> #include <fstream>  #define FOR(i,a,b) for(int i = (a); i <= (b); i++) #define FR(i,a) for(int i = 0; i < (a); i++) #define DR(i,a) for(int i = (a)-1; i >=0; i--) #define DOWN(i,a,b) for(int i = (a); i >= (b); i--) #define FORD(i,a,b) for(int i = (a), _b = (b); i >= _b; i--) #define REPD(i,n) for(int i = (n) - 1; i >= 0; i--) #define PB push_back #define MP make_pair #define F first #define S second #define RESET(c,x) memset(c,x,sizeof(c)) #define SIZE(c) (c).size() #define ALL(c) (c).begin(), (c).end()  #define REP(i,a) for(int i = 0; i < (a); i++)  #define sqr(x) ((x)*(x)) #define oo 2000000009  using namespace std; /*************************TEMPLATE**********************************/ long long convertToNum(string s) {     long long val = 0; FR(i,s.size()) val = val * 10 + s[i] - '0';     return val; } char bu[50]; string convertToString(int a) {     sprintf(bu,"%d",a);     return string(bu); } long long GCD(long long x,long long y)  {     if (!x) return y; if (!y) return x;     if (x == y) return x; if (x < y) return GCD(x,y%x); else return GCD(x%y,y); } long long POW(long long x,long long y,long long Base){     if (!y) return 1; long long u = POW(x,y/2,Base);     u = (u * u) % Base;     if (y & 1) return (u * x) % Base; else return u; }  //newstate = (newstate-1) & oldstate /**************************CODE HERE*****************************/  void OPEN() {     freopen("test.in","r",stdin);     freopen("test.out","w",stdout); } #define maxn 60003 int n,Q,g[maxn]; int x[maxn],y[maxn], Trace[maxn], PREV[maxn],d[maxn]; bool dd[maxn], onRoad[maxn], roadNode[maxn]; priority_queue< pair<int,int> > Heap; vector<int> list; vector< pair<int,int> > a[maxn]; vector< int> cs[maxn]; int D[maxn],f[maxn]; int m,q;  set< pair<int,int> > se; int parents[maxn]; void Print_Path(int source,int dest) { 	if(source==dest) 	{ 		//printf("%d ",source); 		list.push_back(source); 	} 	else if(parents[dest]==-1) 	{ 		//printf("No path from %d to %d\n",source,dest); 	} 	else 	{ 		Print_Path(source,parents[dest]); 	//	printf("%d ",dest); 		list.push_back(dest); 	} }  void init() {     FR(i,n) g[i] = oo, dd[i] = true;     g[n-1] = 0;     while (!Heap.empty()) Heap.pop();     Heap.push( make_pair(-g[n-1],n-1));     while (!Heap.empty()) {         pair<int,int> tmp = Heap.top();         Heap.pop();         if (!dd[tmp.second]) continue;         int u = tmp.second;         dd[u] = false;         FR(i,a[u].size()) {             int v = a[u][i].first;             if (!dd[v]) continue;             if (g[v] > g[u] + a[u][i].second) {                 g[v] = g[u] + a[u][i].second;                 Heap.push( make_pair(-g[v],v) );             }         }     }          FR(i,n) d[i] = oo, dd[i] = true, Trace[i] = -1,parents[i]=-1;     d[0] = 0;     while (!Heap.empty()) Heap.pop();     Heap.push( make_pair(-d[0],0));     while (!Heap.empty()) {         pair<int,int> tmp = Heap.top();         Heap.pop();         if (!dd[tmp.second]) continue;         int u = tmp.second;         dd[u] = false;         FR(i,a[u].size()) {             int v = a[u][i].first;             if (!dd[v]) continue;             if (d[v] > d[u] + a[u][i].second) {                 d[v] = d[u] + a[u][i].second;                 Trace[v] = cs[u][i]; 				parents[v]=u;                 Heap.push( make_pair(-d[v],v) );             }         }     }     FR(i,m) onRoad[i] = false;     FR(i,n) roadNode[i] = false;     int i = n-1,j;     list.clear();     //list.push_back(i);     roadNode[n-1] = true; 	Print_Path(0,n-1);     while (i != 0) {         j = Trace[i];         onRoad[j] = true;         if (y[j] == i) PREV[i] = x[j], i = x[j];         else PREV[i] = y[j], i = y[j];       //  list.push_back(i);         roadNode[i] = true;     }          //reverse(list.begin(),list.end());     FR(i,n) dd[i] = true;     while (!Heap.empty()) Heap.pop();          FR(i,n) D[i] = oo;     int save = oo;     se.clear();     for(int i = list.size() - 1; i >= 1; i--) {         int v = list[i];         int u = PREV[v];         int roadNo = Trace[v];         f[roadNo] = oo;         dd[v] = false; //        if (D[v] > g[v])          {             D[v] = g[v];             Heap.push(make_pair(-g[v],v));             while (!Heap.empty()) {                 pair<int,int> tmp = Heap.top();                 Heap.pop();                 int u = tmp.second;                 FR(i,a[u].size()) {                     if (onRoad[cs[u][i]]) continue;                     int v = a[u][i].first;                     if (D[v] > D[u] + a[u][i].second) {                         D[v] = D[u] + a[u][i].second;                         if (!roadNode[v])                         Heap.push(make_pair(-D[v],v) );                         if (dd[v] && roadNode[v] && f[roadNo] > D[v] + d[v]) {                             se.insert( make_pair(D[v] + d[v], v) );                         }                     }                 }                }         }         while (!se.empty()) {             set< pair<int,int> > ::iterator tmp = se.begin();             if (dd[(*tmp).second]) {                 f[roadNo] = (*tmp).first;                 break;             }             se.erase(tmp);         }     } } int main() { //    OPEN();     int ntest;     scanf("%d",&ntest);     while (ntest--) {         scanf("%d%d%d",&n,&m,&q);         FR(i,n) a[i].clear(), cs[i].clear();         int u,v,len;         FR(i,m) {             scanf("%d%d%d",&x[i],&y[i],&len);             u = x[i], v = y[i];             a[u].push_back( make_pair(v,len) );             a[v].push_back( make_pair(u,len) );             cs[u].push_back(i);             cs[v].push_back(i);         }         init();         int index;         FR(i,q) {             scanf("%d",&index);             if (n == 1) {                 printf("%d\n",0);                 continue;             }             if (!onRoad[index]) {                 printf("%d\n",d[n-1]);             }             else {                 if (f[index] == oo) printf("no route for corrupt ministers!!!\n");                 else printf("%d\n",f[index]);             }         }     }     return 0; }
#include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<string> #include<iostream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath>  using namespace std;  #define s(n)					scanf("%d",&n); #define sl(n)                   scanf("%lld", &n); #define sf(n) 					scanf("%lf",&n); #define ss(n) 					scanf("%s",n); #define INF						(int)1e9 #define LINF					(long long)1e18 #define EPS						1e-12 #define FOR(i,a,b)				for(int i=a;i<b;i++) #define REP(i,n)				FOR(i,0,n) #define foreach(v,c)            for( typeof((c).begin()) v = (c).begin();  v != (c).end(); ++v) #define mp						make_pair #define FF						first #define SS						second #define tri(a,b,c)				mp(a,mp(b,c)) #define XX						first #define YY						second.first #define ZZ						second.second #define pb						push_back #define fill(a,v) 				memset(a,v,sizeof a) #define all(x)					x.begin(),x.end() #define SZ(v)					((int)(v.size())) #define DREP(a)					sort(all(a)); a.erase(unique(all(a)),a.end()) #define INDEX(arr,ind)			(lower_bound(all(arr),ind)-arr.begin()) #define debug(args...)			{dbg,args; cerr<<endl;} #define dline					cerr<<endl #define SP                      system("pause"); #define HAHA                    printf("HAHA\n"); #define mod                     10000  void debugarr(int *arr, int ind1, int ind2) { 	cout<<"[ "; 	for(int i=ind1;i<=ind2;i++) 		cout<<arr[i]<<" "; 	cout<<"]"<<endl; }  typedef long long LL; typedef pair<int,int> PII; typedef pair<LL,LL> PLL; typedef pair<LL,PII> TRI;  typedef vector<int> VI; typedef vector<LL> VL; typedef vector<PII> VII; typedef vector<PLL> VLL; typedef vector<TRI> VT;  typedef vector<VI> VVI; typedef vector<VL> VVL; typedef vector<VII> VVII; typedef vector<VLL> VVLL; typedef vector<VT> VVT;  /////////////////////////////////////////////////////////////////////////////////////////  int n, m; int lev[10005]; int p[10005][15]; VI a[10005]; VI b[10005]; int dp[10005];  void dfs1(int u, int w) {     REP(i, a[u].size())     {         int v = a[u][i];         if(v == w) continue;         p[v][0] = u;         lev[v] = lev[u]+1;         dfs1(v, u);     } }  void dfs2(int u, int w) {     REP(i, a[u].size())     {         int v = a[u][i];         if(v == w) continue;         dfs2(v, u);         dp[u] += dp[v];     } }  int lca(int u, int v) {     if(lev[u] < lev[v]) swap(u, v);     for(int i = 14; i >= 0; i--)     {         if(lev[u]-(1<<i) >= lev[v]) u = p[u][i];     }     if(u == v) return u;     for(int i = 14; i>=0; i--)     {         if((p[u][i] != -1) && (p[u][i] != p[v][i]))         {             u = p[u][i];             v = p[v][i];         }     }     return p[u][0]; }  int main() {     int te; s(te) while(te--)     {         fill(dp, 0);         s(n) s(m)         FOR(i, 0, n)         {             a[i].clear();             b[i].clear();         }         FOR(i, 1, n)         {             int p, q; s(p) s(q)             a[p].pb(q);             a[q].pb(p);         }         FOR(i, 0, m)         {             int p, q; s(p) s(q)             b[p].pb(q);             b[q].pb(p);         }         lev[0] = 0;         fill(p, -1);         dfs1(0, -1);         FOR(j, 1, 15) FOR(i, 0, n) if(p[i][j-1] != -1) p[i][j] = p[p[i][j-1]][j-1];         FOR(u, 0, n) REP(i, b[u].size())         {             int v = b[u][i];             if(v < u)             {                 dp[u]++, dp[v]++, dp[lca(u, v)]-=2;             }         }         dfs2(0, -1);         int ans = 0;         FOR(i, 0, n) ans = max(ans, dp[i]);         printf("%d\n", ans);     } }  
#include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<string> #include<iostream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath> #include<string>   using namespace std;   #define s(n)                                 scanf("%d",&n) #define sl(n)                                   scanf("%lld",&n) #define sf(n)                                   scanf("%lf",&n)   #define EPS                                             1e-9   #define FOR(i,a,b)                              for(int i=a;i<b;i++) #define REP(i,n)                                FOR(i,0,n) #define foreach(v,c)            for( typeof((c).begin()) v = (c).begin();  v != (c).end(); ++v)   #define mp                                              make_pair #define pb                                              push_back   #define FF                                              first #define SS                                              second   #define tri(a,b,c)                              mp(a,mp(b,c)) #define XX                                              first #define YY                                              second.first #define ZZ                                              second.second   /*Important ones*/ #define fill(a,v)                               memset(a,v,sizeof a)     //Works properly only for v = 0 or -1 #define all(x)                                  x.begin(),x.end()   #define SZ(v)                                   ((int)(v.size())) #define DREP(a)                                 sort(all(a)); a.erase(unique(all(a)),a.end()) #define INDEX(arr,ind)                  (lower_bound(all(arr),ind)-arr.begin())   //typedefs. Use if you feel comfortable typedef pair<int,int> PII; typedef pair<long long,long long> PLL; typedef pair<int,PII> TRI;  typedef vector<int> VI; typedef long long LL; typedef vector<LL> VL; typedef vector<PII> VII; typedef vector<PLL> VLL; typedef vector<TRI> VT;   typedef vector<VI> VVI; typedef vector<VL> VVL; typedef vector<VII> VVII; typedef vector<VLL> VVLL; typedef vector<VT> VVT;  #define MAX 305  #define INF 1e9  int N, M, P, C, rech[MAX], adm[MAX][MAX];  int main(){ 	 	int X, Y, T; 	 	s(N);	s(M);	s(P);	s(C); 	FOR(i,0,P){ 		s(T); 		rech[T] = 1; 	} 	rech[N-1] = rech[0] = 1; 	FOR(i,0,N) 		FOR(j,0,N) 			adm[i][j] = INF; 	FOR(i,0,M){ 		s(X);	s(Y);	s(T); 		adm[X][Y] = adm[Y][X] = T; 	} 	FOR(k,0,N) 		FOR(i,0,N) 			FOR(j,0,N) 				adm[i][j] = min(adm[i][j], adm[i][k]+adm[k][j]); 	FOR(i,0,N) 		FOR(j,0,N) 			if(adm[i][j] > C || !rech[i] || !rech[j]) 				adm[i][j] = INF; 	FOR(k,0,N) 		FOR(i,0,N) 			FOR(j,0,N) 				adm[i][j] = min(adm[i][j], adm[i][k]+adm[k][j]); 	if(adm[0][N-1] == INF) 		cout<<-1<<endl; 	else 		cout<<adm[0][N-1]<<endl; 	 	return 0; 	 } 
/*takes two integers N and M and tries to find twice the sum of the quotients of the integer division of (i * N) by M varying i from 0 to M-1 both included. But as he started computing the sums for larger values of M and N, things started becoming very complex. So he has asked for your help. You need to output the sum that Bob needs. Input  The first line of the input contains an integer T denoting the number of test cases. Saurav Shekhar(sauravshekhar01@gmail.com) IOPC 2013*/  #include<stdio.h>  long long int gcd(long long int a, long long int b) {	long long int c; 	c = a%b; 	while(c) 	{	//printf("a = %d,b = %d\n",a,b); 		a = b; 		b = c; 		c = a%b; 	} 	//printf("gcd = %d\n",b); 	return b; }  int main() {	 	int T; 	long long int M,N,k=0; 	long long int sum = 0; 	scanf("%d",&T); 	while(T--) 	{ 		k=0; sum=0; 		scanf("%lld %lld",&M,&N);	//printf("%d\n",M); 		if(M>N) 			k = gcd(M,N); 		else 			k = gcd(N,M); 		sum = M*N -M -N + k ; 		printf("%lld\n",sum); 	} 	return 0; } 
#include <cstdio> #include <algorithm> #include<iostream> using namespace std;  #define S(x) scanf("%d",&x)  int main() {     int t,n,x,y;     S(t);     while(t--)     {         S(n);         int a[n],b[n];         for(int i=0;i<n;i++)         {             a[i]=0;             b[i]=0;         }             int r1,r2;         S(r1);         for(int i=0;i<n-1;i++)         {             S(x);S(y);             a[x]++;a[y]++;         }         S(r2);         for(int i=0;i<n-1;i++)         {             S(x);S(y);             b[x]++;b[y]++;         }         int ans1=a[r1],ans2=b[r2];         if(ans1!=ans2)putchar('0');         else         {         	std::sort(a,a+n);             std::sort(b,b+n); 			bool flag=false;             for(int i=0;i<n;i++)             {                 if(a[i]!=b[i])                 {                     flag=true;                     break;                 }             }             if(flag==false)putchar('1');             else putchar('0');         }         putchar(10);     } }
#include <cstdio> #include <cstdlib> #include <iostream> #include <cstring> using namespace std;  int main() { 	int test,n; 	scanf("%d",&test); 	while(test--) 	{ 		scanf("%d",&n); 		if(n%2==0 || n%3==0) 			printf("YES\n"); 		else 			printf("NO\n"); 	} 	return 0; }
#include <cstdio> #include <vector> #include <queue> using namespace std;  vector <int> adj[100000]; int degree[100000]={0};  void solve(int vertices,int lim) { 	int vertex; 	queue <int> store; 	for(int i=0;i<vertices;i++) 		if(degree[i]<lim) 		{ 			degree[i]=0; 			store.push(i); 		} 	while(!store.empty()) 	{ 		vertex=store.front(); 		store.pop(); 		degree[vertex]=0; 		for(int i=0;i<adj[vertex].size();i++) 			if(degree[adj[vertex][i]]) 			{ 				degree[adj[vertex][i]]--; 				if(degree[adj[vertex][i]]!=0 && degree[adj[vertex][i]]<lim) 					store.push(adj[vertex][i]); 			} 	} }  int main() { 	int vertices,edges,lim,x,y; 	scanf("%d %d %d",&vertices,&edges,&lim); 	for(int i=0;i<edges;i++) 	{ 		scanf("%d %d",&x,&y); 		adj[x].push_back(y); 		adj[y].push_back(x); 		degree[x]++; 		degree[y]++; 	} 	solve(vertices,lim); 	int cnt=0; 	for(int i=0;i<vertices;i++) 		if(degree[i]) 			cnt++; 	printf("%d\n",cnt); 	return 0; }
#include<iostream> #include<cstdio> #include<cstdlib> #include<vector> #include<queue> #include<map> #include<algorithm> #include<cstring> #include<cmath> #include<stack> #include<string> #include<cctype> #include<list> #include<set> #include<deque> #include<queue> #include<bitset> #include<functional> #include<numeric> #include<utility> #include<sstream> #include<iomanip> #include<ctime>   using namespace std;   long long int  prime[100000]; long long int p[10000],j;long long int m,MOD=1000000007; long long power(long int a,long long int b) { 	long long x=1,y=a;  	while(b > 0) 	{ 		if(b%2 == 1) 		{ 			x=(x*y); 			if(x>m) x%=m; 		} 		y = (y*y); 		if(y>m) y%=m;  		b /= 2; 	} 	return x; }   int main() {     long long int i,c,t,n,hcf;c=0;m=MOD;     long long int ans,curr,y,k,p1;     long long int lcm[100005];     for(i=0;i<100000;i++)prime[i]=0;     for(j=2;j+j<100000;j+=1) prime[2*j]=1;     for(i=3;i<3200;i+=2)     {                                         if(prime[i]==1) continue;           for(j=i;i*j<100000;j+=2) prime[i*j]=1;     }   j=0;   for(i=2;i<100000;i++) {if(prime[i]==0){ p[j]=i;j++;}}   lcm[0]=1;   lcm[1]=1;   for(i=2;i<100002;i++)   {                    t=i;                        if(!prime[i])lcm[i]=(lcm[i-1]*i)%m;                        else                        {c=0;              for(k=0;(p[k]*p[k]<=t)&&(k<j);k++)              {                                       if(i%p[k]==0){p1=p[k];c++;while(i%p[k]==0){i=i/p[k];}}                                       if(c>=1)break;              }                                       if((c==1)&&(i==1))lcm[t]=(lcm[t-1]*p1)%m;                                       else lcm[t]=lcm[t-1];                                       }                                                                              i=t; }                                                    /*for(i=0;i<10;i++)printf("%lld ",lcm[i]);*/   scanf("%lld",&t);   while(t--)   {             scanf("%lld",&n);n++;             /*for(i=0;(i<j)&&(p[i]<=n);i++)             {                                       curr=0;c=p[i];                                       while(c<=n)                                       {                                            curr++;                                            c=c*p[i];                                       }                                       y=p[i];//printf("%lld ",curr);  	while(curr > 0) 	{ 		if(curr%2 == 1) 		{ 			ans=(ans*y); 			if(ans>m) ans%=m; 		} 		y = (y*y); 		if(y>m) y%=m;  		curr /= 2; 	}              }*/                               ans=lcm[n];             ans=(ans*power(n,m-2))%m;                     printf("%lld\n",ans);     }                                                                                                                                                   return 0;     } 
#include <cstdio> #include <cstring> #include <queue>  int M, N, C, D; int dp[102*100*100*10];  char map[102][101][10];  inline int encrypt(int n, int c, int r, int d){     return ((n * C + c) * C + r) * D + d; }  inline void decrypt(int &n, int &c, int &r, int &d, int val){     d = val % D; val /= D;     r = val % C; val /= C;     c = val % C; val /= C;     n = val; }  void go(int n, int c, int r, int d, int val, std::queue<int>& que){      int obc = (n == 0 || n == N + 1)? c: ((((n + d) & 1)? c + r: c - r) + C) % C;     if(map[n][obc][d] == 'X') return;      int idx = encrypt(n, c, r, d);     if(dp[idx] == -1) dp[idx] = val, que.push(idx);  }  int main(){      scanf("%d %d %d %d\n" ,&M ,&N ,&C ,&D);      memset(dp, -1, sizeof(dp));      for(int i = 0; i < D; i++){         for(int j = 0; j < N+2; j++){             static char buf[200]; gets(buf);             for(int k = 0; k < C; k++) map[j][k][i] = buf[k];         }     }      int st, ed;     for(int c = 0; c < C; c++){         for(int d = 0; d < D; d++){             if(map[0][c][d] == 'S') st = encrypt(0, c, 0, d);         }     }      int ans = -1;     dp[st] = 0;     std::queue<int> que; que.push(st);     while(!que.empty()){          int n, c, r, d, idx;         idx = que.front(); que.pop();         if(dp[idx] > M) break;          decrypt(n, c, r, d, idx);         if(map[n][c][d] == 'D'){             ans = dp[idx];             break;         }          int nr = (r + 1) % C, stp = dp[idx] + 1;         if(n > 0) go(n - 1, c, nr, d, stp, que);         if(n < N + 1) go(n + 1, c, nr, d, stp, que);         if(c > 0) go(n, c - 1, nr, d, stp, que);         if(c < C - 1) go(n, c + 1, nr, d, stp, que);         if(d > 0) go(n, c, nr, d - 1, stp, que);         if(d < D - 1) go(n, c, nr, d + 1, stp, que);         go(n, c, nr, d, stp, que);      }      printf("%d\n" ,ans);  }
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring>  using namespace std; typedef pair<int, int> ii; #define int_max 200000000000  #define LL long long #define mp make_pair #define pb push_back LL gcd(LL m, LL n){ LL r; while (n != 0){ r=m%n; m=n; n=r;} return m; }  LL mod;  long long int expmod(int a,int b) { 	long long int x=1,y=a; 	while(b>0) 	{ 		if(b&1) x=(x*y)%mod; 		y=(y*y)%mod; 		b>>=1; 	} 	return x; } int main() { 	int t; 	scanf("%d", &t); 	while(t--) 	{ 		int n; 		scanf("%d", &n); 		mod=n*n; 		LL ans=expmod(2, n)+1; 		ans=ans%mod; 		printf("%lld\n", ans); 	}  	return 0; }  
#include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<string> #include<iostream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath> #include<string>   using namespace std;   #define s(n)                                 scanf("%d",&n) #define sl(n)                                   scanf("%lld",&n) #define sf(n)                                   scanf("%lf",&n)   #define EPS                                             1e-9   #define FOR(i,a,b)                              for(int i=a;i<b;i++) #define REP(i,n)                                FOR(i,0,n) #define foreach(v,c)            for( typeof((c).begin()) v = (c).begin();  v != (c).end(); ++v)   #define mp                                              make_pair #define pb                                              push_back   #define FF                                              first #define SS                                              second   #define tri(a,b,c)                              mp(a,mp(b,c)) #define XX                                              first #define YY                                              second.first #define ZZ                                              second.second   /*Important ones*/ #define fill(a,v)                               memset(a,v,sizeof a)     //Works properly only for v = 0 or -1 #define all(x)                                  x.begin(),x.end()   #define SZ(v)                                   ((int)(v.size())) #define DREP(a)                                 sort(all(a)); a.erase(unique(all(a)),a.end()) #define INDEX(arr,ind)                  (lower_bound(all(arr),ind)-arr.begin())   //typedefs. Use if you feel comfortable typedef pair<int,int> PII; typedef pair<long long,long long> PLL; typedef pair<int,PII> TRI;  typedef vector<int> VI; typedef long long LL; typedef vector<LL> VL; typedef vector<PII> VII; typedef vector<PLL> VLL; typedef vector<TRI> VT;   typedef vector<VI> VVI; typedef vector<VL> VVL; typedef vector<VII> VVII; typedef vector<VLL> VVLL; typedef vector<VT> VVT;  #define MAX 1010  #define INF 1e9 #define DIST(i,j) (abs(X[i]-X[j])+abs(Y[i]-Y[j])+abs(Z[i]-Z[j])) /* struct node{ 	int x, y, z, d; 	node(){} 	node(int X, int Y, int Z, int D){ 		x = X;	y = Y;	z = Z;	d = D; 	} };  bool operator < (node &a, node &b){ 	return a.d>b.d; } */ int N, X[MAX], Y[MAX], Z[MAX], pref[MAX], dp[MAX], ans;  int main(){ 	 	int tests; 	 	s(tests); 	FOR(testcases,0,tests){ 		s(N); 		FOR(i,0,N){ 			s(X[i]); 			s(Y[i]); 			s(Z[i]); 			if(i) 				pref[i] = pref[i-1] + DIST(i-1,i); 			else 				pref[i] = 0; 		} 		dp[0] = 0; 		FOR(i,1,N) 			dp[i] = pref[i-1]; 		FOR(i,2,N) 			FOR(j,1,i) 				dp[i] = min(dp[i], dp[j]+DIST(j-1,i)+pref[i-1]-pref[j]); 		ans = INF; 		FOR(i,1,N) 			ans = min(ans, dp[i]+pref[N-1]-pref[i]); 		printf("%d\n", ans); 	} 	 	return 0; 	 } 
#include <cstdio> #include <cstdlib> #include <iostream> #include <cstring> using namespace std;  bool can_send_msg(int x,int y,int u,int a[]) { 	while(a[x]!=u && a[x]!=y) 	{ 		x=a[x]; 	} 	if(a[x]==u && a[x]!=y) 		return 0; 	else 		return 1; }  int main() { 	int n,q; 	int u,x,y; 	scanf("%d %d",&n,&q); 	int a[n+1]; 	scanf("%d",&u); 	a[u]=u; 	for(int i=1;i<n;i++) 	{ 		scanf("%d %d",&x,&y); 		a[y]=x; 	} 	for(int i=0;i<q;i++) 	{ 		scanf("%d %d",&x,&y); 		if(can_send_msg(x,y,u,a)) 			printf("1\n"); 		else if(can_send_msg(y,x,u,a)) 			printf("-1\n"); 		else 			printf("0\n"); 	} 	return 0; }
#include<stdio.h> #include<math.h> #include<stdlib.h> #include<string.h> #include<ctype.h> #include<stack> #include<queue> #include<vector> #include<algorithm> #define MOD 1000000007 typedef long long LL ; int fact[10000005] ;  int main(){     int t,p,i,j;     LL rem,n,quo,ans;     fact[1] = 1;     scanf("%d",&t);     for(i=1;i<=t;i++){         scanf("%lld %d",&n,&p);         for(j=2;j<=p;j++) fact[j] = LL(fact[j-1])*j%p ;         ans = 1;         while(n > 0){            quo =  n/p ;            rem = n%p ;            ans = LL(ans)*(quo%2==0?1:-1)*fact[rem]%p ;            n = quo ;         }         if(ans < 0) ans+= p ;         printf("%d\n",ans);     } return 0; } 
#include <algorithm> #include <iostream> #include <cstdio> #include <vector> #include <utility> using namespace std;  #define		S(x)				scanf("%d",&x) #define		INC(i,a,b)			for(int i=a;i<b;++i) #define		REP(i,n)			INC(i,0,n) #define		FF				first #define		SS				second #define		mp				make_pair #define		tri(a,b,c)			mp(a,mp(b,c)) #define		XX				FF #define		YY				SS.FF #define		ZZ				SS.SS  typedef pair<int,int> PII; typedef pair<int,PII> TRI; typedef vector<int> VI; typedef vector<PII> VII;  const int MAX_N = 1e5, MAX_M = 2e5; bool ans = true; int n, m; TRI E[MAX_M]; int S[MAX_N], R[MAX_N]; int F[MAX_M];  int findSet(int); void link(int,int);  int main() {   S(n); S(m);   REP(i,n) {     S[i] = i;     R[i] = 0;   }   REP(i,m) {     S(E[i].YY); S(E[i].ZZ); S(E[i].XX);   }   sort(E,E+m);      int l, c=0, r=1;      REP(i,m) {     int d = E[i].ZZ;     if(d>c) {       if(r==1) { 	c = d; 	l = i; 	r = 0;       }       else { 	i = l-1; 	r = 1; 	continue;       }     }          int a = E[i].YY, b = E[i].ZZ;     if(r==1) {       if(findSet(a)!=findSet(b)) link(S[a],S[b]);       else if(F[i]==1) { 	ans = false; 	break;       }     }     else {       if(findSet(a)==findSet(b)) F[i] = 0;       else F[i] = 1;     }   }      if(ans) cout << "YES";   else cout << "NO";      return 0; }  int findSet(int v) {   if(v!=S[v]) S[v] = findSet(S[v]);   return S[v]; } void link(int a, int b) {   if(R[a]<R[b]) S[a] = b;   else {     S[b] = a;     if(R[a]==R[b]) R[a]++;   } }
#include <algorithm> #include <iostream> #include <cassert> #include <cstdio> #include <vector> #include <set> using namespace std;  #define		LL			long long #define		S(x)			scanf("%d",&x) #define		SL(x)			scanf("%lld",&x) #define		INC(i,a,b)		for(int i=a;i<b;++i) #define		REP(i,n)		INC(i,0,n) #define		mp			make_pair #define		FF			first #define		SS			second #define		tri(a,b,c)		mp(a,mp(b,c) #define		XX			FF #define		YY			SS.FF #define		ZZ			SS.SS #define		pb			push_back #define		SZ(arr)			((int)(arr.size()))  struct overtake {   LL d, s;   int a, b; // a is overtaken by b (not true ID) };  inline bool operator< (const overtake &x, const overtake &y) {   if(x.d*y.s < x.s*y.d) return true;   else if(x.d*y.s==x.s*y.d) {     if(x.a<y.a || (x.a==y.a && x.b<y.b)) return true;   }   return false; }  typedef pair<LL,LL> PLL; typedef pair<LL,PLL> TRI; typedef vector<int> VI;  const int MAX_N = 1e5+7; int n, q, L[MAX_N]; VI F; TRI H[MAX_N]; set<overtake> O;  void begin(); void repeat(); void answer(LL); bool check(int,LL);  int main() {   int t; S(t);   while(t--) {     begin();     repeat();     REP(i,q) {       LL pos; SL(pos);       answer(pos);     }   }   return 0; }  void begin() {   F.clear();   O.clear();   S(n); S(q);   REP(i,n) {     SL(H[i].XX); SL(H[i].YY); H[i].ZZ = i; // (distance, speed, ID)   }   sort(H,H+n,greater<TRI>()); // Sort in order of distance   REP(i,n) L[i] = i-1; // Linked list   F.pb(0); // First in race      // Add values to overtake set, and discard useless ones   INC(i,1,n) {     TRI curr = H[i];     TRI prev = H[L[i]]; // The horse just ahead          if(curr.YY<=prev.YY) {       L[i+1] = L[i];     }     else {       overtake temp;       temp.s = curr.YY-prev.YY; temp.d = prev.XX-curr.XX;       temp.a = L[i]; temp.b = i;       O.insert(temp);            }   } } void repeat() {   while(!O.empty()) {     overtake top = *O.begin();     O.erase(O.begin());     L[top.b] = L[top.a];     if(L[top.a]!=-1) {       overtake temp;       temp.a = L[top.a]; temp.b = top.a;       temp.s = H[temp.b].YY-H[temp.a].YY; temp.d = H[temp.a].XX-H[temp.b].XX;       assert(temp.s>0 && temp.d>0);       O.erase(O.find(temp));        temp.a = L[top.a]; temp.b = top.b;       temp.s = H[temp.b].YY-H[temp.a].YY; temp.d = H[temp.a].XX-H[temp.b].XX;       assert(temp.s>0 && temp.d>0); // b will eventually overtake a, necessarily       O.insert(temp);     }     else F.pb(top.b);   } } void answer(LL tm) {   int l=0,r=SZ(F);   while(r-l>1) {     int d = (r+l)/2;     if(check(d,tm)) l=d;     else r=d;   }   printf("%lld\n",H[F[l]].ZZ); } bool check(int h, LL tm) {   if(h==0) return true;   int curr = F[h];   int prev = F[h-1];      LL dcurr = H[curr].XX + (H[curr].YY*tm);   LL dprev = H[prev].XX + (H[prev].YY*tm);      if(dcurr>=dprev) return true;   return false; }
#include<stdio.h> #include<stdlib.h> #include<string.h> #define MOD 1000000007 typedef long long int ll ; int a[105][105],deg[105];  int inverse(int a){ 	int ans =1 , pow = a, n = MOD - 2; 	while(n){ 		if(n%2 == 1) ans = ll(ans)* pow %MOD ; 		pow = ll(pow) * pow % MOD ; 		n = n/2 ; 	} 	return ans ; }  void det(int n){ 	int inv,i,j,k,temp,not_zero,ans = 1; 	for(i=0;i<n;i++){ 		not_zero = i ; 		for(j=i;j<n;j++){ 			if(a[j][i] != 0){ 				not_zero = j; 				break; 			} 		} 		if(a[not_zero][i] == 0){ 			printf("0\n"); 			return ; 		} 		for(j=i;j<n;j++){ 			temp = a[i][j] ; 			a[i][j] = a[not_zero][j] ; 			a[not_zero][j] = temp ; 		} 		ans = ll(ans) * a[i][i] % MOD; 		inv =  inverse(a[i][i]); 		for(j=i+1;j<n;j++){ 			a[i][j] = ll(a[i][j])*inv%MOD ; 		} 		a[i][i] = 1; 		for(j=i+1;j<n;j++){ 		    if(a[j][i] == 0) continue ; 		    int c = a[j][i]; 			for(k=i;k<n;k++){ 				 temp = a[j][k] -  ll(a[i][k])*c%MOD ; 				 if(temp < 0) temp = temp + MOD ; 				 a[j][k] = temp ; 			} 		} 	} 	printf("%d\n",ans); }  int main(){ 	int t,n,m,x,y,i,j,temp[105][105]; 	scanf("%d",&t); 	while(t--){ 		scanf("%d%d",&n,&m); 		memset(a,0,sizeof(a)); 		memset(deg,0,sizeof(deg)); 		memset(temp,0,sizeof(temp)); 		while(m--){ 			scanf("%d%d",&x,&y); 			deg[x]++; deg[y]++; 			temp[x][y]=  temp[y][x] = 1 ; 		} 		for(i=0;i<n;i++){ 			for(j=0;j<n;j++){ 				if(i == j) a[i][j] = deg[i]; 				else a[i][j] = (temp[i][j] == 1)?MOD-1:0 ; 			} 		} 		det(n-1); 	} 	return 0; } 
#include<stdio.h> #include<iostream> #include<map> #include<set> #include<vector> #include<queue> #include<stack> #include<algorithm> #include<cmath>  #define MOD 1000000007 #define INF 2000000000  typedef unsigned long long llu;  using namespace std;  static llu mulmod(llu a,llu b,llu mod ) { if(a>=mod) a %=mod; if(b>=mod) b%=mod; long double res = a; res *= b; llu c = (llu)(res / mod); a *= b; a -= c * mod; a %= mod; if (a < 0) a += mod; return a; }      int main() {     int t;          long long n,b;          scanf("%d",&t);          while(t--)     {               scanf("%lld %lld",&n,&b);                              if(n==0)               {                       if(b==1)                        printf("Odd\n");                       else                        printf("Even\n");                                              continue;               }                              long long i;                              long long num=1,num2=1,tmp=b,pw=2;                              while(tmp%2==0)               {                              tmp/=2;                              pw*=2ll;               }                              for(i=1;i<=n;i++)               {                               num=mulmod(num,i,b);                               num2=mulmod(num2,i,pw);               }                              //printf("%lld\n",num);                                             if((pw+num2-(num%pw))%pw==0)               {                          printf("Even\n");               }               else               {                   printf("Odd\n");               }                    }                    return 0; } 
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <cmath> #include <algorithm> #include <functional> #include <numeric> #include <bitset> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <climits> #include <map> #include <cassert>  #define ull unsigned long long #define ill long long int #define pii pair<int,int> #define pb(x) push_back(x) #define F(i,a,n) for(i=(a);i<(n);++i) #define FD(i,a,n) for(i=(a);i>=(n);--i) #define FE(it,x) for(it=x.begin();it!=x.end();++it) #define V(x) vector<x> #define S(x) scanf("%d",&x) #define S1(x) scanf("%lld",&x) #define epsilon 0.000000000000001 #define pie acos (-1.0) #define MAXNODES 100001 #define sz size() #define MAX 100009 using namespace std;  ill a[MAX]; ill parent[MAX]; ill d[MAX]; ill level[MAX]; vector < vector <ill> > s; ill root; ill chainhead[MAX]; ill which[MAX]; ill where[MAX]; ill ssize[MAX]; ill chain;  class seg {     private:      public:         vector <ill> a;         vector <ill> flag;         ill ss;         void add (ill index)         {             ss++;         }          seg ()         {             ss = 0;         }          void space ()         {             a.resize (7*ss + 10);             fill (a.begin(), a.end(), 0);              flag.resize (7*ss + 10);             fill (flag.begin(), flag.end(), 0);         }          void build (ill node, ill x, ill y)         {             if (x > y) {                 return;             }             if (x == y) {                 a[node] = 0;                 return;             }             ill mid = (x+y)/2;             build (node*2, x, mid);             build (node*2 + 1, mid+1, y);             a[node] = a[node*2] + a[node*2 + 1];         }          void checking (ill node, ill x, ill y)         {             if (flag[node] == 0) {                 return;             }              ill mid = (x+y)/2;              if (2*node < 7*ss) {                 a[node*2] += (ill)(mid-x+1)*flag[node];                 flag[node*2] += flag[node];             }             if (2*node +1 < 7*ss) {                 a[node*2 +1] += (ill)(y-mid)*flag[node];                 flag[node*2 +1] += flag[node];             }             flag[node] = 0;         }          ill query (ill node, ill x, ill y, ill sx, ill sy)         {         //    cout << node << " " << 4*ss << " " << x << " " << y << " " << sx << " " << sy << endl;             if (x > y) {                 return 0;             }             if (x > sy || y < sx) {                 return 0;             }             checking (node, x, y);              if (sx <= x && sy >= y) {                 return a[node];             }              if (x == y) {                 return a[node];             }             ill mid = (x+y)/2;             if (sy <= mid) {                 return query (2*node, x, mid, sx, sy);             }             if (sx > mid) {                 return query (2*node +1, mid+1, y, sx, sy);             }             return query (2*node, x, mid, sx, sy) + query (2*node + 1, mid+1, y, sx, sy);         }            void update (ill node, ill x,                        ill y, ill sx, ill sy, ill value)         {             if (x > y) {                 return;             }             if (x  > sy || y < sx) {                 return;             }             checking(node, x, y);             if (x == y) {                 a[node] = a[node]+value;                // a[x] += value;                 return;             }                if (sx <= x && sy >= y) {                 flag[node] += value;                 a[node] = a[node]+((ill)(y-x+1)*value);                 return;             }             ill mid = (x+y)/2;             update (node*2, x, mid, sx, sy, value);             update (node*2 +1, mid+1, y, sx, sy, value);             a[node] = a[node*2] + a[node*2 +1];         } }; vector <seg> segment;  ill lca( ill a, ill b) {     while (which[a] != which[b]) {         ill a1 = chainhead[which[a]];         ill b1 = chainhead[which[b]];         if (level[a1] < level[b1]) {             b = parent[b1];         } else {             a = parent[a1];         }     }     if (a == -1 || b == -1) {         return root;     }     if (level[a] < level[b]) {         return a;     }     return b; }  ill query (ill u) {     ill sum = 0;     ill total=0;     while (u != -1) {        // cout << "AA " << u << endl;         ill cc = which[u];       //  cout << ssize[cc] << " " << where[u] << endl;         ill xx =  segment[cc].query (1, 0, ssize[cc]-1, where[u], where[u]);          sum = sum + total*xx;         xx =  segment[cc].query (1, 0, ssize[cc]-1, 0, where[u]);         sum = sum + xx;         total = total + (ill)(where[u]+1);         u = chainhead[cc];         u = parent[u];     }     return sum; }  void update (ill index, ill value) {     ill cc = which[index];     segment[cc].update (1, 0, ssize[cc]-1, where[index],  ssize[cc]-1, value); }   void dfs (ill index, ill p) {     d[index] = 1;     parent[index] = p;     ill i;      F (i, 0, s[index].size()) {         ill x = s[index][i];         if (x == p) {             continue;         }         level[x] = level[index] + 1;         dfs (x, index);         d[index] = d[index] + d[x];     } }  void hld (ill index, ill p) {     if (chainhead[chain] == -1) {         chainhead[chain] = index;     }     which[index] = chain;     where[index] = ssize[chain];     ssize[chain]++;     segment[chain].add (0);      ill i,j=-1,xx=-1;      F (i, 0, s[index].size()) {         ill x = s[index][i];         if (x == p) {             continue;         }         if (d[x] > xx) {             xx = d[x];             j = x;         }     }      if (j == -1) {         return;     }     hld (j, index);      F (i, 0, s[index].size()) {         ill x = s[index][i];         if (x == p || x == j) {             continue;         }         chain++;         hld (x, index);     } }  int main() {   // freopen ("input.txt", "r", stdin);     ill tt,ix=1;       ill i,n;     S1 (n);     ill qq;     S1 (qq);      S1 (root);     root--;      s.clear();      s.resize (n);     F (i, 0, n-1) {         ill x,y;         S1 (x);      S1 (y);         x--;        y--;         s[x].pb (y);         s[y].pb (x);     }      level[root] = 0;     dfs (root, -1);      segment.clear();     segment.resize (n+3);      chain = 0;     memset (chainhead, -1, sizeof(chainhead));     memset (ssize, 0, sizeof(ssize));      hld (root, -1);     F (i, 0, chain+4) {         segment[i].space ();         segment[i].build (1, 0, ssize[i]-1);     }     //cout << "SDAS" << endl;    //  cout << "SDAD " << qq << endl;     while (qq--) {         char ch[3];         scanf ("%s", ch);         if (ch[0] == 'U') {             ill x;             ill y;             S1(x);             S1(y);             x--;             update (x, y);              continue;         }          ill x,y;         S1(x);         S1(y);         x--;         y--;         ill ll = lca(x,y);         //  cout << x << " " << y << " " << ll << endl;         ill ans = query(y)+query(x)-query(ll)-(parent[ll]!=-1?query(parent[ll]):0);         printf ("%lld\n", ans);       //  cout << "A" << endl;       //  cout << endl;      }       return 0; }
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <limits> #include <string> #include <cassert>  using namespace std; typedef long long LL; typedef pair<int,int> pii;  #define forup(i,a,b) for(int i=a; i<b; ++i) #define fordn(i,a,b) for(int i=a; i>b; --i) #define rep(i,a) for(int i=0; i<a; ++i)  #define dforup(i,a,b) for(i=a; i<b; ++i) #define dfordn(i,a,b) for(i=a; i>b; --i) #define drep(i,a) for(i=0; i<a; ++i)  #define slenn(s,n) for(n=0; s[n]!=13 and s[n]!=0; ++n);s[n]=0  #define gi(x) scanf("%d",&x) #define gl(x) cin>>x #define gd(x) scanf("%lf",&x) #define gs(x) scanf("%s",x)  #define pis(x) printf("%d ",x) #define pin(x) printf("%d\n",x) #define pls(x) cout<<x<<" " #define pln(x) cout<<x<<"\n" #define pds(x) printf("%.12f ",x) #define pdn(x) printf("%.12f\n",x) #define pnl() printf("\n")  #define fs first #define sc second  #define pb push_back  const int inv=1000000000; const int minv=-inv;  const int max_n=100010;  // Geometry  struct point { 	LL xc,yc; 	point(){} 	point(LL xc_, LL yc_){xc=xc_; yc=yc_;} };  point operator +(const point &a, const point &b) {return point(a.xc+b.xc,a.yc+b.yc);} // Vector Addition point operator -(const point &a, const point &b) {return point(a.xc-b.xc,a.yc-b.yc);} // Vector Subtraction LL operator *(const point &a, const point &b) {return (a.xc*b.xc+a.yc*b.yc);} // Dot Product LL operator ^(const point &a, const point &b) {return (a.xc*b.yc-a.yc*b.xc);} // Cross Product : Right-Hand Rule  bool leftturn(const point &X1, const point &X2, const point &X3) { return (((X2-X1)^(X3-X2))>0ll); } bool straight(const point &X1, const point &X2, const point &X3) { return (((X2-X1)^(X3-X2))==0ll); }  point pfix; struct point_tan_cmp : public binary_function <point,point,bool> { 	bool operator() (const point &a, const point &b) { return ((a.yc-pfix.yc)*(b.xc-pfix.xc)>(b.yc-pfix.yc)*(a.xc-pfix.xc)); } }; // X: all points should be distinct // X: order of points in array will be changed // X: triples of points may be collinear // X: there should exist three non-collinear points // cX: points will be sorted in clockwise order (all turn will be right turns) void ConvexHull(point X[], int N, int cX[], int &cXsz) {	 	int fix=0; 	for(int i = 1; i<N; i++){ 		if(X[i].xc<X[fix].xc or (X[i].xc==X[fix].xc and X[i].yc>X[fix].yc)) 			fix=i; 	} 	swap(X[0],X[fix]); 	pfix=X[0]; 	 	sort(X+1,X+N,point_tan_cmp()); 	X[N]=X[0]; 	 	cXsz=0; 	cX[cXsz++]=0; 	cX[cXsz++]=1; 	forup(i,2,N+1) 	{ 		while(cXsz>=2 and (leftturn(X[cX[cXsz-2]],X[cX[cXsz-1]],X[i]) or straight(X[cX[cXsz-2]],X[cX[cXsz-1]],X[i]))) 			--cXsz; 		if(i==N) break; 		cX[cXsz++]=i; 	} }  // End  int T; int n; point P[max_n]; int H[max_n],nH;  int main() { 	gi(T);  	rep(z,T) 	{ 		gi(n);  		rep(i,n) 		{ 			gl(P[i].xc); 			gl(P[i].yc); 		}  		if(n<=2) 			pin(n-1); 		else 		{ 			ConvexHull(P,n,H,nH); 			pin(2*nH-3+3*(n-nH)); 		} 	} 	 	return 0; }
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime>  using namespace std;  #define REP(i, n) for(int i=0;i<n;i++) #define ll long long ll m;  ll cur[2][2]; ll mat[2][2];  void matmul(ll p[][2], ll q[][2]) { 	ll c[2][2]; 	REP(i, 2) 		REP(j, 2) 		{ 			c[i][j] = 0; 			REP(k, 2) 				c[i][j] += (p[i][k]*q[k][j]+m)%m; 		} 	REP(i, 2) 		REP(j, 2) 			p[i][j] = (c[i][j] + m)%m; }  void raise(ll exp) { 	ll mov[2][2]; 	mov[0][0] = mat[0][0]; mov[0][1] = mat[0][1]; 	mov[1][0] = mat[1][0]; mov[1][1] = mat[1][1]; 	if( exp == 1 ) 		return; 	mat[0][0] = mat[1][1] = 1; 	mat[0][1] = mat[1][0] = 0; 	while( exp ) 	{ 		if(exp%2 == 1 ) 			matmul(mat, mov); 		matmul(mov, mov); 		exp /= 2; 	} }  void update() { 	matmul(cur, mat); }  int main() { 	int t; 	cin>>t; 	int primes[100005]; 	REP(i, 100005) 		primes[i] = 1; 	primes[0] = primes[1] = 0; 	for( int i=2;i<100005;i++) 	{ 		if( primes[i] == 0 ) 			continue; 		for( int j=2*i;j<100005;j+=i) 			primes[j] = 0; 	} 	while( t-- ) 	{ 		ll n, r; 		cin>>n>>r>>m; 		if( m == 1 || n < r) 		{ 			cout<<0<<endl; 			continue; 		} 		ll factors[n+1]; 		REP(i, n+1) 			factors[i] = 0; 		for( int i=2;i<=n;i++) 		{ 			if( primes[i] == 0 ) 				continue; 			for( ll j=i;j<=n;j *= i ) 				factors[i] += n/j; 		} 		for( int i=2;i<=r;i++) 		{ 			if( primes[i] == 0 ) 				continue; 			for( ll j=i;j<=r;j *= i ) 				factors[i] -= r/j; 		} 		for( int i=2;i<=n-r;i++) 		{ 			if( primes[i] == 0 ) 				continue; 			for( ll j=i;j<=n-r;j *= i ) 				factors[i] -= (n-r)/j; 		} 		//cur[0][0] = 1; cur[1][1] = 1; 		//cur[1][0] = cur[0][1] = 0; 		mat[0][0] = 1; mat[0][1] = 1; 		mat[1][0] = 1; mat[1][1] = 0;  		REP(i, n+1) 		{ 			if( primes[i] == 0 || factors[i] <= 0 ) 				continue; 		//	cout<<i<<" "<<factors[i]<<endl; 			REP(j, factors[i]) 				raise(i); 		//	cout<<mat[0][0]<<endl; 	//		raise(factors[i]); 		} 		//if( mat[1][0] == 0 ) 		//	mat[1][0] = 1; 		cout<<mat[1][0]<<endl; 	} 	return 0; }     	   
#include <bits/stdc++.h> using namespace std; #define MID ((l+r) >> 1) #define LT (nd << 1) #define RT ((nd << 1) | 1) #define MAX 1123 typedef long long LL;  template <typename T> inline void fi(T *a) {  register char c=0;  while (c<33) c=getchar_unlocked();  *a=0;  int tmp = 0;  while (c>33)  {      if ( c == 45 ) tmp = 1;      else *a=*a*10+c-'0';      c=getchar_unlocked();  }  if ( tmp == 1 ) *a = 0-(*a); }  struct node{     LL lsum,rsum,msum,sum;     node():lsum(0),rsum(0),msum(0),sum(0){}     node(LL v):lsum(v),rsum(v),msum(v),sum(v){} };  node Merge(node left,node right){     node res;     res.sum = left.sum + right.sum;     res.lsum = max(left.lsum,left.sum+right.lsum);     res.rsum = max(right.rsum,right.sum+left.rsum);      res.msum = max(left.msum,right.msum);     res.msum = max(res.msum,left.rsum+right.lsum);     return res; }  LL A[MAX],S,N,Q; node RQ[MAX][MAX];  void compute(){     for(LL i = 0; i < S; ++i) RQ[i][i] = node(A[i]);     for(LL i = 1; i < S; ++i){         for(LL j = 0; j+i < S; ++j){             LL l = j, r = i+j;             RQ[j][j+i] = Merge(RQ[j][MID],RQ[MID+1][i+j]);         }     } }  node Range(LL st,LL sz){     if (st+sz-1 < S) return RQ[st][st+sz-1];      node n1 = RQ[st][S-1],res;     sz -= (S-st);      if (sz <= S)         res = RQ[0][sz-1];     else {         LL d = sz/S;         sz = sz%S;         node fr = RQ[0][S-1];         res = fr;          res.sum = res.sum*d;         if (fr.sum > 0){             res.lsum += max(fr.sum*(d-1),(LL)0);             res.rsum += max(fr.sum*(d-1),(LL)0);             LL ans = LLONG_MIN;             if (d > 1)                 ans = fr.lsum + fr.rsum + max(fr.sum*(d-2),(LL)0);             res.msum = max(res.msum,ans);         }          if (sz != 0)             res = Merge(res,RQ[0][sz-1]);     }      res = Merge(n1,res);     return res; }  struct seg{     vector<node> v;     vector<LL> lazy;     LL sz;      seg():sz(0){}     void Resize(LL k){         sz = k;         v.resize(3*sz,node());         lazy.resize(3*sz,-1);     }      void pushdown(LL nd,LL l,LL r){         if (lazy[nd] == -1) return;         LL v1 = lazy[nd];         node res = Range(v1,r-l+1);         v[nd] = res;         if (l != r)             lazy[LT] = v1, lazy[RT] = (v1+MID-l+1)%S;         lazy[nd] = -1;     }      void update(LL nd,LL l,LL r,LL a,LL b,LL M){         pushdown(nd,l,r);         if (l > b || r < a) return;         if (l >= a && r <= b){             lazy[nd] = (M+l-a)%S;             pushdown(nd,l,r);             return;         }          update(LT,l,MID,a,b,M);         update(RT,MID+1,r,a,b,M);         v[nd] = Merge(v[LT],v[RT]);     }      void update(LL a,LL b,LL M){         update(1,0,sz-1,a,b,M);     }      node query(LL nd,LL l,LL r,LL a,LL b){         pushdown(nd,l,r);         if (l >= a && r <= b)             return v[nd];          if (MID < a) return query(RT,MID+1,r,a,b);         if (MID+1 > b) return query(LT,l,MID,a,b);          node n1 = query(LT,l,MID,a,b);         node n2 = query(RT,MID+1,r,a,b);         return Merge(n1,n2);     }      node query(LL a,LL b){         return query(1,0,sz-1,a,b);     } };  void solve(){     fi(&S),fi(&N),fi(&Q);     for(int i = 0; i < S; ++i)         fi(&A[i]);     compute();      seg SG;     SG.Resize(N);      char ch[10];     LL a,b,c;     while(Q--){         scanf("%s",ch);         fi(&a),fi(&b),--a,--b;         if (ch[0] == 'U'){             fi(&c),--c;             c %= S;             SG.update(a,b,c);             continue;         }          node res = SG.query(a,b);         printf("%lld\n",res.msum);     } }  int main() {     solve();     return 0; } 
#include <cstdio> #include <cstdlib> #include <cstring> #include <vector> #include <algorithm> using namespace std;  bool graph[111][111]; char s[111][111];  int n, root; vector<int> adj[200]; int mate[200]; bool v1[200], v2[200];  template<typename T> int size(const T& c) { return int(c.size()); } template<typename T> T sqr(T x) { return x*x; } template<typename T> bool remin(T& x, T y) { if (x <= y) return false; x = y; return true; } template<typename T> bool remax(T& x, T y) { if (x >= y) return false; x = y; return true; }  #define FOR(i, a, b) for (int i(a), _b(b); i <= _b; ++i) #define FORD(i, a, b) for (int i(a), _b(b); i >= _b; --i) #define REP(i, n) for (int i(0), _n(n); i < _n; ++i) #define REPD(i, n) for (int i((n) - 1); i >= 0; --i)  bool dfs(int x) {   if (v1[x]) return false;   v1[x] = v2[x] = true;   REP(z, size(adj[x])) {     int y = adj[x][z];     if (y != root && mate[y] == -1) {       mate[x] = y;       mate[y] = x;       return true;     }   }   REP(z, size(adj[x])) {     int y = adj[x][z];     if (y != root && !v2[y] && dfs(mate[y])) {       mate[x] = y;       mate[y] = x;       return true;     }   }   v2[x] = false;   return false; }  int solve() {   int res = 0;   REP(z, 13) {     REP(i, n) random_shuffle(adj[i].begin(), adj[i].end());     REP(i, n) mate[i] = -1;     vector<int> order(n);     REP(i, n) order[i] = i;     random_shuffle(order.begin(), order.end());     int cur = 0;     REP(i, n) {       root = order[i];       if (mate[root] != -1) continue;       REP(i, n) v1[i] = v2[i] = false;       if (dfs(root)) ++cur;     }     remax(res, cur);   }   return res; }  int main() {     // freopen("J.in", "r", stdin);     // memset(matchL, -1, sizeof(matchL));     //     memset(matchR, -1, sizeof(matchR));     //     int matched = 0;     //     for (int i = 0; i < n; i++) {     //         memset(seen, false, sizeof(seen));     //         if (bpm(i)) matched++;     //     }      int T;      for (int T = 1;; T++) {         int m;         scanf("%d%d", &n, &m);         if (n + m == 0) break;         for (int i = 0; i < n; i++) scanf("%s", s[i]);          memset(graph, false, sizeof(graph));         for (int i = 0; i < n; i++)             for (int j = 0; j < n; j++)                 if (s[i][j] == '.') {                     graph[i][j] = true;                     graph[j][i] = true;                 }         for (int i = 0; i < n; i++) adj[i].clear();         for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) if (graph[i][j]) adj[i].push_back(j);          bool ok = true;         for (int i = 0; i < n; i++) {             int cnt = 0;             for (int j = 0; j < n; j++) if (graph[i][j]) cnt++;             if (cnt == 0) ok = false;         }          printf("Case#%d: ", T);          if (ok == false) { printf("IMPOSSIBLE\n"); continue; }          printf("%d\n", (n - solve()) * m);     }     return 0; }
#include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<set> #include<map> #include<string> #include<string.h> #include<cstring> #include<stack> #include<queue> #include<cassert> #include<cmath> using namespace std;  #define LL long long int #define PII pair<int,int> #define PB push_back #define MP make_pair #define INF 1000000000 #define debug(args...) do {cerr << #args << ": "; dbg,args; cerr << endl;} while(0) #define MOD 1000000007  string s; int dp[5001][5001][3][2]; int vis[5001][5001][3][2]; int citer = 0; char ss[2000]; int  getans(int n, int m, int cinter, int contin){     if(m < 0)m = 0;     if(n == -1)return (m == 0 && cinter == 0);     int &cret = dp[n][m][cinter][contin];     int &cvis = vis[n][m][cinter][contin];     if(cvis != citer){         LL ret = 0;         cvis = citer;         ret += getans(n - 1, m, cinter, 0);         if(s[n] != 'a'){             if(contin  == 1){                 ret += getans(n - 1, m, cinter, 1);             }             if(cinter > 0)                 ret += getans(n - 1, m, cinter - 1, 1);         }         else{             if(contin == 1)                 ret += getans(n - 1, m - 1, cinter, 1);             if(cinter > 0)                 ret += getans(n - 1, m - 1, cinter - 1, 1);         }         cret = ret % MOD;     }     return cret; } int main(){     int t, m;     cin >> t;     while(t--){         citer += 2;         cin >> s >> m;         cout<<getans(s.size() - 1, m, 3, 0)<<endl;     }              return 0; } 
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <limits> #include <string> #include <cassert>  using namespace std; typedef long long LL; typedef pair<int,int> pii;  #define forup(i,a,b) for(int i=a; i<b; ++i) #define fordn(i,a,b) for(int i=a; i>b; --i) #define rep(i,a) for(int i=0; i<a; ++i)  #define dforup(i,a,b) for(i=a; i<b; ++i) #define dfordn(i,a,b) for(i=a; i>b; --i) #define drep(i,a) for(i=0; i<a; ++i)  #define slenn(s,n) for(n=0; s[n]!=13 and s[n]!=0; ++n);s[n]=0  #define gi(x) scanf("%d",&x) #define gl(x) cin>>x #define gd(x) scanf("%lf",&x) #define gs(x) scanf("%s",x)  #define pis(x) printf("%d ",x) #define pin(x) printf("%d\n",x) #define pls(x) cout<<x<<" " #define pln(x) cout<<x<<"\n" #define pds(x) printf("%.12f ",x) #define pdn(x) printf("%.12f\n",x) #define pnl() printf("\n")  #define fs first #define sc second  #define pb push_back  const int inv=1000000000; const int minv=-inv;  const int max_n=1000010; const int flim=max_n+2010; const LL modref=1000000007ll;  LL fpow(const LL &a, const LL &p) { 	if(p==0ll) return 1ll;  	LL t=fpow(a,p/2ll); 	t*=t; t%=modref;  	if(p%2ll==1ll) { t*=a; t%=modref; }  	return t; }  int n; int c[1011]={0};  LL f[flim+1]; LL fi[flim+1];  LL ch(const int &i, const int &j) { 	if(i<0) return 0ll; 	if(j<0 or j>i) return 0ll;  	LL ret=(fi[j]*fi[i-j])%modref; 	ret*=f[i]; ret%=modref; 	return ret; }  LL dp[1011][2011]={0}; LL res[2011];  int main() { 	f[0]=1ll; 	for(int i=1; i<=flim; ++i) 		f[i]=((LL(i))*f[i-1])%modref; 	fi[flim]=fpow(f[flim],modref-2ll); 	for(int i=flim-1; i>=0; --i) 		fi[i]=(fi[i+1]*(LL(i+1)))%modref;  	gi(n);  	rep(i,n) 	{ 		int a; gi(a); 		++c[a]; 	}  	dp[0][0]=1ll; 	for(int i=1; i<=1000; ++i) 	{ 		for(int s=0; s<=2000; ++s) 		{ 			dp[i][s]=0ll;  			for(int k=0; k<=c[i]; ++k) 			{ 				if(s-(i+1)*k<0) break;  				LL ddp=(dp[i-1][s-k*(i+1)]*ch(c[i],k))%modref; 				if(k%2==1) ddp=modref-ddp;  				dp[i][s]+=ddp; 				if(dp[i][s]>=modref) dp[i][s]-=modref; 			} 		} 	}  	for(int s=0; s<=2000; ++s) 	{ 		res[s]=0ll; 		for(int i=0; i<=s; ++i) 		{ 			LL dres=dp[1000][i];  			int r=s-i; 			dres*=ch(n-1+r,n-1); dres%=modref;  			res[s]+=dres; if(res[s]>=modref) res[s]-=modref; 		} 	}  	int q; 	gi(q); 	rep(z,q) 	{ 		int s; gi(s); 		pin((int(res[s]))); 	} 	 	return 0; }
# include <iostream> # include <fstream> # include <sstream> # include <iomanip> # include <algorithm> # include <numeric> # include <cstdio> # include <cmath> # include <cstdlib> # include <cstring> # include <vector> # include <list> # include <set> # include <map> # include <stack> # include <queue> # include <deque> # define inf 1000000007 using namespace std; typedef unsigned long long int ulli; int main() {     #ifndef ONLINE_JUDGE         freopen("../input.txt","r",stdin);     #endif 	int t; 	int N, a, b, c, d, k, Q;  	bool vis[1005][2]; 	scanf("%d", &t); 	while(t--) {  		scanf("%d %d %d %d %d %d %d", &N, &a, &b, &c, &d, &k, &Q);  		for(int i=0;i<=1000;i++) {		 			vis[i][0] = false; 			vis[i][1] = false; 		} 		int res = inf; 		int iter = 0, steps, currN, applied; 		queue< pair< pair<int, int>, int> > q; 		q.push(make_pair(make_pair(N, 0), 1));                 q.push(make_pair(make_pair(N%d, 1), 0)); 		while(!q.empty()) { 			iter++;  			currN = q.front().first.first; 			steps = q.front().first.second; 			applied = q.front().second;  			q.pop();  			if(Q%k == (currN%k)) { 				res = steps; 				break; 			}  			if(vis[currN][applied]) { 				continue; 			} 			vis[currN][applied] = true; 			steps++;  			if(applied == 0) { 				//q.push(make_pair(make_pair(currN % d, steps), 0)); 				q.push(make_pair(make_pair((currN + a)%d, steps), 0)); 				q.push(make_pair(make_pair(((currN - b)%d + d)%d, steps), 0)); 				q.push(make_pair(make_pair((currN * c)%d, steps), 0)); 			}  			q.push(make_pair(make_pair((currN + a)%k, steps), 1)); 			q.push(make_pair(make_pair(((currN - b)%k + k)%k, steps), 1)); 			q.push(make_pair(make_pair((currN * c)%k, steps), 1)); 		} 		if(res == inf) 			printf("-1\n"); 		else 			printf("%d\n", res); 	}     return 0; }
#include <stdio.h> #include <iostream> #include <string> #include <string.h> using namespace std; int cs[100005]; #define min(a,b) (a<b?a:b) int main(){  	int T,m ; 	string S; 	 	scanf("%d",&T);  	while(T--){ 		cin >> S; 		memset(cs,0,sizeof(int)*S.length());  		for(int i = 0 ; i<S.length() ; i++) 			cs[i] = S[i]=='A';  		for(int i = 1 ; i<S.length() ; i++) 			cs[i] += cs[i-1];  		scanf("%d",&m);  		int ans = m-cs[m-1]; 		for(int i = 1 ; i+m-1<S.length() ; i++){ 			ans = min(ans,m-(cs[i+m-1]-cs[i-1])); 		} 		printf("%d\n",ans); 	} 	return 0; }
#include<cstdio> #include<iostream> #include<algorithm> #include<cmath> using namespace std; long long gcd(long long a, long long b) {     if(b==0)     return a;     else     {         return gcd(b,a%b);     } } int bitcount(long long a) {     int count=0;     while(a!=0)     {         if(a&1==1)         count++;         a=a/2;     }     return count; } main() {       int tc;       scanf("%d",&tc);       while(tc--)       {          long long p,q,g;          int count1;          scanf("%lld %lld",&p,&q);          if(p>=q)          g=gcd(p,q);          else          g=gcd(q,p);          p=p/g;          q=q/g;          if(p==1)          {             while((q&1)!=1)             {                q=q/2;             }             if(((q+1)&(q))==0)             printf("YES\n");             else             printf("NO\n");          }          else           {               int count2=0;               count1=bitcount(p);              // printf("%d",count1);               if(count1==1)               {                  while((q&1)!=1)                  {                      q=q/2;                  }                  if(((q+1)&(q))==0)                  {                     if(q>p || ((q+1)==p))                     printf("YES\n");                     else                     printf("NO\n");                  }                  else                  printf("NO\n");               }               else               printf("NO\n");          }       }       return 0;        }  
#include <iostream> #include <cstring>  using namespace std;  int source, sink, n, m; int cap[201][201], vis[201], node, a[201][201], aa[201][201]; int totr, totc, r[201], c[201];  bool flow(int pos) {     if(vis[pos] == node) return false;     vis[pos] = node;     for(int i = 0; i < n+m+2; i++) {         if(!cap[pos][i]) continue;         if(i == sink) {             cap[pos][i]--;             cap[i][pos]++;             if(pos < n) {                 a[pos][i] = 1;             }             else {                 a[i][pos] = 0;             }             return true;         }         if(flow(i)) {             cap[pos][i]--;             cap[i][pos]++;             if(pos < n) {                 a[pos][i] = 1;             }             else {                 a[i][pos] = 0;             }             return 1;         }     }     return false; }  int main() {     int t;     ios_base::sync_with_stdio(false);     cin >> t;     int cs = 0;     while(t--) {         cin >> n >> m;         cs++;         cout << "TestCase #:" << cs << endl;         totr = totc = 0;         for(int i = 0; i < n; i++) cin >> r[i], totr += r[i];         for(int j = 0; j < m; j++) cin >> c[j], totc += c[j];         source = n+m;         sink = n+m+1;         memset(cap, 0, sizeof(cap));         memset(aa, 0, sizeof(aa));         memset(a, 0, sizeof(a));         memset(vis, 0, sizeof(vis));         for(int i = 0; i < n; i++) {             cap[source][i] = r[i];         }          for(int i = 0; i < n; i++) {             for(int j = 0; j < m; j++) {                 cap[i][j+n] = 1;             }         }          for(int i = 0; i < m; i++) {             cap[i+n][sink] = c[i];         }         int ans = 0;         node = 1;         while(flow(source)) {             node++;             ans++;         }         //cout << ans << endl;         if(ans != totr || totr != totc) {             cout << -1 << endl;             continue;         }         for(int i = 0; i < n; i++) {             for(int j = 0; j < m; j++) {                 if(cap[j+n][i] == 1) {                     cap[j+n][i] = 0;                     cap[source][i]++;                     cap[i][source]--;                     cap[j+n][sink]++;                     cap[sink][j+n]--;                     node++;                     if(!flow(source)) {                         cap[j+n][i] = 1;                         cap[source][i]--;                         cap[i][source]++;                         cap[j+n][sink]--;                         cap[sink][j+n]++;                     }                 }                 else {                     cap[i][n+j] = 0;                 }             }         }          for(int i = 0; i < n; i++) {             for(int j = 0; j < m; j++) {                 cout << cap[j+n][i];             }             cout << endl;         }      } } 
#include <bits/stdc++.h>  using namespace std;  int Find (string S, int L, int K) { 	priority_queue < int > Q; 	int n = S.length (); 	int curr = 0, temp = 1; 	for (int i = 0; i < n - 1; i++) 	{ 		if (S[i] == S[i + 1]) 			temp++; 		else 		{ 			curr += min (K, temp); 			temp -= min (K, temp); 			if (temp) 				Q.push (temp); 			temp = 1; 		} 	} 	curr += min (K, temp); 	temp -= min (K, temp); 	if (temp) 		Q.push (temp); 	if (curr >= L) 		return L; 	int res = L; 	while (curr < L) 	{ 		temp = Q.top (); 		Q.pop (); 		curr += min (temp, K); 		temp -= min (temp, K); 		if (temp) 			Q.push (temp); 		res++; 	} 	return res; }  int main () { 	int T, L, K; 	string S; 	cin >> T; 	while (T--) 	{ 		cin >> S; 		cin >> K >> L; 		cout << Find (S, L, K) << endl; 	} 	return 0; } 
#include<stdio.h> #include<math.h> int main() { long long t ; double x,y,r,a,b,v; scanf("%lld",&t);  while(t--) { scanf("%lf %lf %lf %lf %lf %lf",&r,&x,&y,&a,&b,&v);  x = (x-a)*(x-a)+ (y-b)*(y-b);  x= r-sqrt(x);  x = x/v ; if(x<0) x=0; printf("%lf\n",x);  }   } 
#include<iostream> #include<cstdio> #include<cstring> #include<queue> #include<stack> #include<list> #include<cstring> #include<algorithm> #include<cmath> #include<set> #include<map>  using namespace std;  struct node {     int x, y; };  #define INF 10000000000000000LL #define M 1000000007LL typedef long long ll; typedef list<int> li; typedef stack<int> si; typedef queue<int> qi; typedef priority_queue<int> pqi; typedef pair<int,int> pii; typedef pair<ll,ll> pll; typedef pair<int,string> pis; typedef pair<string,int> psi;  class UF {  public:     int *id, cnt, *sz; 	// Create an empty union find data structure with N isolated sets.     UF(int N)     {         cnt = N;         id = new int[N];         sz = new int[N];         for(int i=0; i<N; i++)         {             id[i] = i;             sz[i] = 1;         } 	//cout<<"Done"<<endl;     }     ~UF()     {         delete [] id;         delete [] sz;     } 	// Return the id of component corresponding to object p.     int find(int p)     {         int root = p;         while (root != id[root])root = id[root];         /*while (p != root)         {             int newp = id[p];             id[p] = root;             p = newp;         }*/         //cout<<"!!"<<root<<endl;         return root;     } 	// Replace sets containing x and y with their union.     void merge(int x, int y)     {         int i = find(x);         int j = find(y);         if (i == j) return;  		// make smaller root point to larger one         if(sz[i] < sz[j])         {             id[i] = j;             sz[j] += sz[i];         }         else         {             id[j] = i;             sz[i] += sz[j];         }         cnt--;     } 	// Are objects x and y in the same set?     bool connected(int x, int y)     {         return find(x) == find(y);     } 	// Return the number of disjoint sets.     int count()     {         return cnt;     } }; vector<pair<int, pair <int,int > > > edg; int main() {     int t;     scanf("%d",&t);     while(t--)     {         edg.clear();         int n;         scanf("%d",&n);         int t1,t2,t3;         for(int i=0;i<n-1;i++)         {             scanf("%d",&t1);             scanf("%d",&t2);             scanf("%d",&t3);              edg.push_back(make_pair(-1*t3 , make_pair(t1,t2)));         }         sort(edg.begin(),edg.end());          UF sets(n);         long long ans=0;         int cnt1,cnt2,f1,f2;         for(int i=0;i<edg.size();i++)         {             //cout<<edg[i].second.first<<" "<<edg[i].second.second<<endl;             f1=sets.find(edg[i].second.first - 1);             //cout<<f1<<endl;             f2=sets.find(edg[i].second.second - 1);             //cout<<f1<<" "<<f2<<endl;             ans-=(((long long)(edg[i].first))*(long long)sets.sz[f1]*(long long)sets.sz[f2]);              sets.merge(f1,f2);          }         printf("%lld\n",ans);      }  } 
#include <cstdio> #include <algorithm> #include <vector>  using namespace std;  int N,Q; vector<pair<int,int> > adj[400013]; bool visited[400013]; int h[400013]; long long depth[400013]; int ancestor[400013][19];  void dfs(int x) {     visited[x] = 1;     for (int i=0;i<adj[x].size();i++) {         if (!visited[adj[x][i].first]) {             h[adj[x][i].first] = h[x]+1;             depth[adj[x][i].first] = depth[x]+adj[x][i].second;             dfs(adj[x][i].first);             ancestor[adj[x][i].first][0] = x;         }     }     ancestor[x][0] = -1; }  int findkth(int x, int k) {     int where = x;     for (int i=17;i>=0;i--) if (k&(1<<i)) where = ancestor[where][i];     return where; }  int lca(int a, int b) {     if (h[a]>h[b]) swap(a,b);     b = findkth(b,h[b]-h[a]);     if (a==b || b==-1) return a;     for (int i=17;i>=0;i--) {         if (h[a]<(1<<i)) continue;         int na = ancestor[a][i];         int nb = ancestor[b][i];         if (na!=nb) a = na, b = nb;     }     return ancestor[a][0]; }  int main() {     int T = 0;     scanf("%d",&T);     for (int t=0;t<T;t++) {         scanf("%d",&N);         for (int i=0;i<N;i++) {             adj[i].clear();             visited[i] = 0;             h[i] = 0;             depth[i] = 0;             for (int j=0;j<18;j++) ancestor[i][j] = 0;         }         for (int i=1;i<N;i++) {             int u = 0,v = 0,c = 0;             scanf("%d%d%d",&u,&v,&c);             u-=1; v-=1;             adj[u].push_back(make_pair(v,c));             adj[v].push_back(make_pair(u,c));         }         dfs(0);         for (int i=1;i<=17;i++) {             for (int j=0;j<N;j++) {                 if (h[j]<(1<<i)) ancestor[j][i] = -1;                 else ancestor[j][i] = ancestor[ancestor[j][i-1]][i-1];             }         }         scanf("%d",&Q);         for (int q=0;q<Q;q++) {             int a = 0,b = 0;             long long para = 0;             scanf("%d%d%lld",&a,&b,&para);             a-=1; b-=1;             int l = lca(a,b);             if (l==-1) {                 printf("NO\n");                 continue;             }             long long dist = depth[a]+depth[b]-2*depth[l];             long long looking = dist/2;             if (depth[a]-depth[l]<depth[b]-depth[l]) swap(a,b);             int where = a;             for (int i=17;i>=0;i--) {                 if (ancestor[where][i]==-1) continue;                 if (h[ancestor[where][i]]<h[l]) continue;                 if (depth[a]-depth[ancestor[where][i]]<=looking) where = ancestor[where][i];             }             int ok = 0;             if (abs((depth[a]-depth[where])-(dist-(depth[a]-depth[where])))<=para) ok = 1;             where = ancestor[where][0];             if (where!=-1 && abs((depth[a]-depth[where])-(dist-(depth[a]-depth[where])))<=para) ok = 1;             if (ok) printf("YES\n");             else printf("NO\n");         }     }      return 0; } 
/*Programmed by Ayush Jaggi*/  #include<bits/stdc++.h>  using namespace std;  #define pb push_back #define mp make_pair #define F first #define S second #define L(i,x,y) for(i=x;i<y;i++) #define l0(i,x) for(i=0;i<x;i++) #define l1(i,x) for(i=1;i<x;i++) #define pd(n) printf("%d",n) #define pdn(n) printf("%d\n",n) #define pds(n) printf("%d ",n) #define plld(n) printf("%lld",n) #define plldn(n) printf("%lld\n",n) #define pllds(n) printf("%lld ",n) #define pc(n) printf("%c",n) #define pn printf("\n") #define ps printf(" ") #define plf(n) printf("%.6lf",n) #define plfn(n) printf("%.6lf\n",n) #define plfs(n) printf("%.6lf ",n) #define pllf(n) printf("%.6llf",n) #define pllfn(n) printf("%.6llf\n",n) #define pllfs(n) printf("%.6llf ",n) #define psn(n) printf("%s\n",n) #define pss(n) printf("%s ",n) #define sd(n) scanf("%d",&n) #define sld(n) scanf("%ld",&n) #define slld(n) scanf("%lld",&n) #define slf(n) scanf("%lf",&n) #define ss(n) scanf("%s",n) #define sc(n) scanf("%c",&n) #define mem(n,m) memset(n,m,sizeof(n)) #define W(t) while(t--)  typedef long long LL; typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int,int> ii; typedef vector<string> VS;  /*template<class T> inline T gcd(T a, T b) {     return b ? gcd(b, a % b) : a; } inline void prime() {     int s, d, count=0;     lb=sqrt(n);     for(s=2; s<=lb; s++)         if(!pr[s])         {             sieve[count++]=s;             for(d=s*s; d<=n; d+=s)                 pr[d]=1;         } }  inline LL expo(LL base, int nent) {     if(nent==1)         return base;     else if(nent&1)     {         LL temp=expo(base,nent/2);         temp=temp*temp*base;         if(temp>=MOD)             temp%=MOD;         return temp;     }     else     {         LL temp=expo(base,nent/2);         temp*=temp;         if(temp>=MOD)             temp%=MOD;         return temp;     } }*/  LL MOD=1000000007, ans; string str1, str2, str; int sa[100005], pos[100005], lcp[100005], tmp[100005], gap, len, i, j, k, l1, fflag, beg, end, cur_beg, temp, t; //sorting can be improved in suffix arrays from std::sort to stable_sort or radix sort to make the complexity O(n) from O(nlogn)  inline bool sufcmp(int x, int y) {     if(pos[x]!=pos[y])         return pos[x]<pos[y];     x+=gap;     y+=gap;     return (x<len && y<len) ? pos[x]<pos[y] : x>y; }  inline void build_sa() {     len=str.length();     l0(i,len)     {         pos[i]=str[i];         sa[i]=i;     }     for(gap=1;; gap*=2)     {         sort(sa,sa+len,sufcmp);         tmp[0]=0;         l1(i,len)         tmp[i]=tmp[i-1]+sufcmp(sa[i-1],sa[i]);         l0(i,len)         pos[sa[i]]=tmp[i];         if(tmp[len-1]==len-1)             break;     } }  inline void build_lcp() {     k=0;     l0(i,len)     {         if(pos[i]!=len-1)             for(j=sa[pos[i]+1]; str[i+k]==str[j+k]; k++);         lcp[pos[i]]=k;         if(k)k--;     } }  /*inline void build_lcp() {     k=0;     l0(i,l1)     if(pos[i]!=len-1)     {         for(j=sa[pos[i]+1]; str[i+k]==str[j+k]; k++);         lcp[pos[i]]=k;         if(j>l1)             if(k>ans)             {                 ans=k;                 beg=j;                 end=beg+k;                 flag[j]=1;                 val[j].nlcp=k;             }             else if(k && k==ans)             {                 if(j<beg)                 {                     beg=j;                     end=beg+k;                 }                 flag[j]=1;                 val[j].nlcp=k;             }         if(k)             k--;     }     else         k=0;     k=0;     L(i,l1+1,len)     if(pos[i]!=len-1)     {         for(j=sa[pos[i]+1]; str[i+k]==str[j+k]; k++);         lcp[pos[i]]=k;         if(j<l1)         {             if(k>ans)             {                 ans=k;                 if(val[i].nlcp>=k)                     beg=val[i].start;                 else                     beg=i;                 end=beg+k;             }             else if(k && k==ans)             {                 //if(i==20)                 //cout<<"hi";                 if(val[i].nlcp>=k && val[i].start<beg)                 {                     beg=val[i].start;                     end=beg+k;                 }                 else if(i<beg)                 {                     beg=i;                     end=beg+k;                 }             }         }         else if(flag[i] && val[i].nlcp==ans && k>=ans)         {             if(j<beg)             {                 beg=j;                 end=beg+ans;             }             flag[j]=1;             val[j].nlcp=ans;          }         else if(j>i)         {             val[j].nlcp=k;             val[j].start=i;         }         if(k)             k--;     }     else         k=0; }*/  int main() {     //cout<<val[5].nlcp<<" "<<val[7].start<<endl;     sd(t);     while(t--)     {         sd(l1);         sd(temp);         cin>>str1>>str2;         str=str1+'$'+str2;         build_sa();         build_lcp();         //cout<<val[20].nlcp<<" "<<val[20].start<<endl;         /*l0(i,len)         cout<<sa[i]<<" ";         cout<<endl;         l0(i,len)         cout<<lcp[i];         cout<<endl;         l0(i,len)         cout<<flag[i]<<" ";         cout<<endl;*/         /*L(i,beg,end)         pc(str[i]);         if(ans)             pn;*/         temp=0;         ans=0;         //l0(i,len)         //cout<<lcp[i]<<" ";         //cout<<endl;          l1(i,len-1)         {             //cout<<lcp[i];             //cout<<lcp[i];             temp=min(temp,lcp[i]);             if((sa[i]<l1 && sa[i+1]>l1) || (sa[i]>l1 && sa[i+1]<l1))                 //if(temp<lcp[i])             {                 ans+=(lcp[i]-temp);                 temp=lcp[i];             }         }         plldn(ans);     }     return 0; } 
#include<bits/stdc++.h> #define s(n) scanf("%d",&n) #define sl(n) scanf("%lld",&n) #define p(n) printf("%d\n",n) #define mod 1000000009LL #define ll long long #define pb push_back #define mp make_pair #define N 100011 #define LN 21 using namespace std;  ll fib[N]; ll cfib[N]; struct T {  ll sum;  ll x;  ll y; }tree[4*N+14],tree1[4*N+14]; void build_tree(int idx,int l,int r) {  if(l==r)  {  tree[idx].sum=tree[idx].x=tree[idx].y=0;  tree1[idx].sum=tree1[idx].x=tree1[idx].y=0;  }  else  {   int mid=(l+r)/2;   build_tree(2*idx+1,l,mid);   build_tree(2*idx+2,mid+1,r);   tree[idx].sum=tree[idx].x=tree[idx].y=0;   tree1[idx].sum=tree1[idx].x=tree1[idx].y=0;  } } void lazy(int id,int l,int r,int ql,int qr) {   if(l>r)   return;   int el=r-l+1;   ll val=(tree[id].x*fib[el])%mod;   val=(val+tree[id].y*cfib[el-1])%mod;   tree[id].sum=(tree[id].sum+val)%mod;   if(l!=r)   {    int mid=(l+r)/2;    tree[2*id+1].x=(tree[2*id+1].x+tree[id].x)%mod;    tree[2*id+1].y=(tree[2*id+1].y+tree[id].y)%mod;    int el=mid-l+1;    tree[2*id+2].x=(tree[2*id+2].x+(tree[id].x*fib[el-1])%mod+(tree[id].y*fib[el])%mod)%mod;    tree[2*id+2].y=(tree[2*id+2].y+(tree[id].x*fib[el])%mod+(tree[id].y*fib[el+1])%mod)%mod;   }   tree[id].x=tree[id].y=0; }  void lazy2(int id,int l,int r,int ql,int qr) {   if(l>r)   return;   int el=r-l+1;   ll val=(tree1[id].x*fib[el])%mod;   val=(val+tree1[id].y*cfib[el-1])%mod;   tree1[id].sum=(tree1[id].sum+val)%mod;   if(l!=r)   {    int mid=(l+r)/2;    tree1[2*id+1].x=(tree1[2*id+1].x+tree1[id].x)%mod;    tree1[2*id+1].y=(tree1[2*id+1].y+tree1[id].y)%mod;    int el=mid-l+1;    tree1[2*id+2].x=(tree1[2*id+2].x+(tree1[id].x*fib[el-1])%mod+(tree1[id].y*fib[el])%mod)%mod;    tree1[2*id+2].y=(tree1[2*id+2].y+(tree1[id].x*fib[el])%mod+(tree1[id].y*fib[el+1])%mod)%mod;   }   tree1[id].x=tree1[id].y=0; } void update(int idx,int l,int r,int ql,int qr,int tr) {    int mid=(r+l)/2;    lazy(idx,l,r,ql,qr);   if(qr<l||ql>r||l>r)  return;  else if(ql<=l && qr>=r)  {   int en=r-ql+1+tr;   int str=l-ql+1+tr;   tree[idx].sum=((tree[idx].sum+cfib[en]-cfib[str-1])%mod+2*mod)%mod;   ll lx,ly;   lx=fib[str];   ly=fib[str+1];   if(l!=r)   {    int mid=(l+r)/2;    tree[2*idx+1].x=(tree[2*idx+1].x+lx)%mod;    tree[2*idx+1].y=(tree[2*idx+1].y+ly)%mod;    int el=mid-l+1;    tree[2*idx+2].x=(tree[2*idx+2].x+(lx*fib[el-1])%mod+(ly*fib[el])%mod)%mod;    tree[2*idx+2].y=(tree[2*idx+2].y+(lx*fib[el])%mod+(ly*fib[el+1])%mod)%mod;   }  }  else  {   update(2*idx+1,l,mid,ql,qr,tr);   update(2*idx+2,mid+1,r,ql,qr,tr);   tree[idx].sum=(tree[2*idx+1].sum+tree[2*idx+2].sum)%mod;  } }  void update2(int idx,int l,int r,int ql,int qr,int tr) {    int mid=(r+l)/2;    lazy2(idx,l,r,ql,qr);   if(qr<l||ql>r||l>r)  return;  else if(ql<=l && qr>=r)  {   int en=r-ql+1+tr;   int str=l-ql+1+tr;   tree1[idx].sum=((tree1[idx].sum+cfib[en]-cfib[str-1])%mod+2*mod)%mod;  // cout<<l<<" "<<r<<" "<<tree1[idx].sum<<" "<<ql<<" "<<qr<<endl;   ll lx,ly;   lx=fib[str];   ly=fib[str+1];   if(l!=r)   {    int mid=(l+r)/2;    tree1[2*idx+1].x=(tree1[2*idx+1].x+lx)%mod;    tree1[2*idx+1].y=(tree1[2*idx+1].y+ly)%mod;    int el=mid-l+1;    tree1[2*idx+2].x=(tree1[2*idx+2].x+(lx*fib[el-1])%mod+(ly*fib[el])%mod)%mod;    tree1[2*idx+2].y=(tree1[2*idx+2].y+(lx*fib[el])%mod+(ly*fib[el+1])%mod)%mod;   }  }  else  {   update2(2*idx+1,l,mid,ql,qr,tr);   update2(2*idx+2,mid+1,r,ql,qr,tr);   tree1[idx].sum=(tree1[2*idx+1].sum+tree1[2*idx+2].sum)%mod;   //cout<<l<<" "<<r<<" "<<tree1[idx].sum<<endl;  } }  ll query(int idx,int l,int r,int ql,int qr) {   int mid=(r+l)/2;      lazy(idx,l,r,ql,qr);   if(qr<l||ql>r||l>r)   return 0;   else if(ql<=l && qr>=r)   return tree[idx].sum;   else   return (query(2*idx+1,l,mid,ql,qr)+query(2*idx+2,mid+1,r,ql,qr))%mod; }  ll query2(int idx,int l,int r,int ql,int qr) {   int mid=(r+l)/2;      lazy2(idx,l,r,ql,qr);   if(qr<l||ql>r||l>r)   return 0;   else if(ql<=l && qr>=r)   {   return tree1[idx].sum;   }   else   return (query2(2*idx+1,l,mid,ql,qr)+query2(2*idx+2,mid+1,r,ql,qr))%mod; } int main() {  int i;  fib[0]=cfib[0]=0;  fib[1]=1;  for(i=2;i<N;++i)  fib[i]=(fib[i-1]+fib[i-2])%mod;  for(i=1;i<N;++i)  cfib[i]=(cfib[i-1]+fib[i])%mod;  int n,q;  cin>>n>>q;  build_tree(0,0,n-1);  for(i=0;i<q;++i)  {   int ty,x,y;   s(ty);s(x);s(y);   if(ty==1)   {    x--;    if(y<=x+1)    update(0,0,n-1,x-y+1,x,0);    else    update(0,0,n-1,0,x,y-x-1);    if(y>1)    {    if(x+y-1<=n-1)    update2(0,0,n-1,n-x-y,n-x-2,0);    else    update2(0,0,n-1,0,n-x-2,x+y-n);    }   }   else   {    x--;y--;    //assert(x<=y);    ll ans=query(0,0,n-1,x,y);    ans+=query2(0,0,n-1,n-1-y,n-1-x);    ans%=mod;    printf("%lld\n",ans);   }  } } 
#include<bits/stdc++.h>     using namespace std;     typedef long long ll;          #define max(a, b, c) ((a < b? (a < c? a : c) : (b < c? b : c)))       int main()     {         ll t,z,i,j,k,n,m,s,ans;         scanf("%lld",&t);         for(z=1;z<=t;z++)         {         	ll a,b,c;         	double p,q,r;             scanf("%lld%lld%lld",&a,&b,&c);             p=sqrt((a+b)*(a+b)+c*c);             q=sqrt((b+c)*(b+c)+a*a);               r=sqrt((a+c)*(a+c)+b*b);             printf("%.10lf\n",max(p,q,r));         }         return 0;     } 
#include<iostream> #include<cstdio> using namespace std;  #define MXN 100010  bool poss=1; int par[MXN]={0},n,a[MXN],c[MXN]={0};  void resolve(int l,int r) {     if(!poss) return;     int i,j;     for(i=l+1;i<=r;++i)     {            par[a[i]]=a[l];            if(c[i]>0)            {                            if(c[i]>r)                           {                                    poss=0;                                    return;                           }                      resolve(i,c[i]);                      i=c[i];            }     } }  /* 10 3 3 3 7 4 4 7 8 8 9 */  int main() {     int q,i,nd,l,r;     scanf("%d",&n);     for(i=1;i<=n;++i)     {          a[i]=i;          scanf("%d",&a[i]);     }     scanf("%d",&q);     //q=0;     if(a[1]!=1) poss=0;     while(q--)     {               scanf("%d%d%d",&nd,&l,&r);               if(a[l]!=nd) poss=0;               if(l==1 && r<n) poss=0;               if(c[l]>0 && c[l]!=r) poss=0;               c[l]=r;     }     resolve(1,n);     if(!poss) printf("0\n");     else     {         printf("1\n");         for(i=1;i<=n;++i)         {               if(i==a[1]) continue;               printf("%d %d\n",i,par[i]);         }     }     //system("pause"); } 
#include <bits/stdc++.h> using namespace std;  typedef long long ll; typedef unsigned long long ull; typedef vector<int> vi; typedef vector<ll> vll; typedef vector<vi> vvi; typedef pair<int,int> pii; typedef vector<pii > vii; typedef vector<pair<int, pair<int, int> > > viii; typedef pair<ll,ll> pll; typedef vector<string> vs; typedef vector<vii> vvii;  #define pb push_back #define mp make_pair #define X first #define Y second #define MEM(a,b) memset(a,(b),sizeof(a)) #define tr(c,it) for(typeof((c).begin()) it = (c).begin(); it != (c).end(); it++) #define all(a) a.begin(),a.end() #define loop(x,a,b) for(int (x) = (a);(x)<(b);(x)++) #define rep(x,n)   for(int (x)=0;(x)<(n);(x)++) #define present(c,x) ((c).find(x) != (c).end())  #define cpresent(c,x) (find(all(c),x) != (c).end()) #define ain(a,n) int ((a)[(n)]); for(int i=0; i<(n); i++) cin>>((a)[i])   #define md 1000000007 #define MAXN 200005  int main() {        ios::sync_with_stdio(false);     cin.tie(0);     int n;     cin>>n;      int deg[n];     MEM(deg,0);     int a[n][n];     MEM(a,0);     rep(i,n)       rep(j,i)       {         int t1,t2;         cin>>t1>>t2;         t1--;t2--;         deg[t1]++;         a[t1][t2] = 1;       }     vii v;     rep(i,n)       v.pb(mp(deg[i],i+1));     sort(all(v));     int tot = 0;     int f = 0;     rep(i,n-1)     {       tot += v[i].X;       if(tot <= (i+1)*(i)/2)         f = 1;     }     if(f == 0)     {       cout<<0<<"\n";     }     else     {       cout<<"1\n";       cout<<v[0].Y<<" "<<v[n-1].Y<<"\n";     }     return 0; } 
//Author:Hena Firdaus //GREEDY APPROACH...GIVING WA :() #include <bits/stdc++.h> using namespace std; int n,vc[100005],vis[100005]; vector<int>adj[100005]; int vertex_cover() {   	for(int i=1;i<=n;i++)   	{   		if(!vis[i])   		{   			for(int j=0;j<adj[i].size();j++)   			{   				int v=adj[i][j];   				if(vis[v]) continue;   					vis[v]=1;   					vis[i]=1;   					break;   				   			}   		}   	}   	int c=0;   	for(int i=1;i<=n;i++)   	{   		if(vis[i])   			c++;   		//cout<<vis[i]<<" ";   	}   	//cout<<endl;  return c/2; }  int main() { 	int m,a,b,k; 	cin>>n>>m>>k; 	while(m--) 	{ 		cin>>a>>b; 		adj[a].push_back(b); 		adj[b].push_back(a); 	} 		int vv; 		int h; 		memset(vis,0,sizeof(vis)); 		vv=vertex_cover(); 		//cout<<"vERTEX COVER:"<<vv<<endl; 		if(vv<k) 			cout<<"Case 1\n"; 		else 			 				cout<<"Case 2\n"; 	 	return 0; }
#include <bits/stdc++.h> using namespace std; typedef long long ll; #define N 200010 ll ar[N + 1];  ll inf = -1ll*4*pow(10,13) - 5; map <ll,vector<int> > mp; struct query {     ll x;     int id,l,r; }querys[N + 10];  ll ans[N + 10]; bool compare(query a,query b) {     return a.x < b.x; } struct seg {     ll maxsum,sum,psum,ssum; }segs[10*N + 10];  seg mergesegs(seg x,seg y) {     seg temp;     temp.sum = x.sum + y.sum;     temp.psum = max(x.psum,x.sum+y.psum);     temp.ssum = max(x.ssum+y.sum,y.ssum);     temp.maxsum = max(x.ssum+y.psum,max(x.maxsum,y.maxsum));     return temp; }  void Update(int nod,int b,int e,int x,ll v) {     if(b == e)     {         segs[nod].maxsum = v;         segs[nod].sum = v;         segs[nod].psum = v;         segs[nod].ssum = v;     }     else     {         int mid = (b+e)/2;         if(x<=mid) Update(2*nod+1,b,mid,x,v);         else Update(2*nod+2,mid+1,e,x,v);         segs[nod] = mergesegs(segs[2*nod+1],segs[2*nod+2]);     } }  seg Query(int nod,int b,int e,int l,int r) {     if(l<=b && e<=r)     {         return segs[nod];     }     else     {         int mid = (b+e)/2;         if(r <= mid) return Query(2*nod+1,b,mid,l,r);         else if(l > mid) return Query(2*nod+2,mid+1,e,l,r);         else return mergesegs(Query(2*nod+1,b,mid,l,r),Query(2*nod+2,mid+1,e,l,r));     } }   void Build(int nod,int b,int e) {     if(b == e)     {         segs[nod].maxsum = inf;         segs[nod].sum = inf;         segs[nod].psum = inf;         segs[nod].ssum = inf;     }     else     {         int mid = (b+e)/2;         Build(2*nod+1,b,mid);         Build(2*nod+2,mid+1,e);         segs[nod] = mergesegs(segs[2*nod+1],segs[2*nod+2]);     } }  int main() {     int n,q;      cin>>n>>q;      for(int i = 1 ; i<=n ; i++)     {        cin>>ar[i];         mp[ar[i]].push_back(i);     }     Build(0,1,n);      for(int i = 1 ; i<=q ; i++)     {         scanf("%d %d %lld",&querys[i].l,&querys[i].r,&querys[i].x);         querys[i].id = i;     }      sort(querys+1,querys+q+1,compare);      int j = 1;     for(map <ll,vector <int> > :: iterator it = mp.begin() ; it != mp.end() ; it++)     {         ll x = (*it).first;         while(j<=q && querys[j].x < x)         {             ans[querys[j].id] = Query(0,1,n,querys[j].l,querys[j].r).maxsum;             j++;         }         vector <int> &vec = (*it).second;         int sz = vec.size();         for(int i = 0 ; i<sz ; i++)         {             Update(0,1,n,vec[i],x);         }     }     while(j<=q)     {         ans[querys[j].id] = Query(0,1,n,querys[j].l,querys[j].r).maxsum;         j++;     }     for(int j = 1 ; j<=q ; j++)     {         if(ans[j] <= inf)         {             printf("xx\n");         }         else         {             printf("%lld\n",ans[j]);         }     }  } 
#include<bits/stdc++.h> using namespace std; typedef long long ll; ll ar[1000010],psum[1000010],x[1000010],y[1000010];  int main() { ll INF = LLONG_MAX;  int t; cin>>t; int n,i,j;  while(t--) {     cin>>n;     for(i=1;i<=n;i++)      cin>>ar[i];       sort(ar+1,ar+n+1);       for(i=1;i<=n;i++)       psum[i]=psum[i-1]+ar[i];      for(i=1;i<=n;i++)     {        j = (i+1)/2;         x[i] =(psum[i] - psum[j] - ar[j]*(i-j)) + (ar[j]*j - psum[j]);     }     reverse(ar+1,ar+n+1);       for(i=1;i<=n;i++)       psum[i]=psum[i-1]+ar[i];      for(i=1;i<=n;i++)     {        j = (i+1)/2;         y[n-i+1] = -(psum[i] - psum[j] - ar[j]*(i-j)) - (ar[j]*j - psum[j]);     }      y[n+1]=0;     x[0]=0;     ll ans=INF;     for(i=0;i<=n;i++)     {       ans=min(ans,x[i]+y[i+1]);     }     cout<<ans<<endl;     }   } 
#include <stdio.h>  int main() { 	int T; 	scanf("%d", &T);  	for (int t = 0; t < T; t++) 	{ 		int A[9][9]; 		int R[9],C[9],B[9]; 		for (int i = 0; i < 9; i++) 			R[i]=C[i]=B[i]=0; 		for (int i = 0; i < 9; i++) 			for (int j = 0; j < 9; j++) 			{ 				int x; 				scanf("%d", &x); 				x=x-1; 				A[i][j] = x; 				R[i] |= (1 << x); 				C[i] |= (1 << x); 				B[i/3+3*(j/3)] |= (1 << x);  			}  		bool ok = true; 		for (int i = 0; i < 9; i++) 		{ 			if (R[i] != 511 || B[i] != 511 || C[i] != 511  ) 			{ 				ok = false; 				break; 			} 		}  		if (ok) 			printf("Its A Sudoku\n"); 		else 			printf("Not A Sudoku\n"); 	}	  	return 0; }
// created by: Prashant Kumar Singh :) #include<iostream> #include<algorithm> #include<utility> #include<cstring> #include<string.h> #include<set> #include<queue> #include<map> #include<math.h> #include<stdio.h> #include<vector> #include<functional> #include<bitset> #include<iomanip> #define ll long long #define gr greater<ll>() #define pi acos(-1.0) #define pb push_back #define MS0(ar) memset(ar,0,sizeof ar) #define f first #define s second #define pii pair<int,int> #define pll pair<ll,ll> #define ind(a) scanf("%d",&a) #define inf(a) scanf("%lf",&a) #define inl(a) scanf("%lld",&a) #define ins(a) scanf("%s",a) #define pd(a) printf("%d\n",a) #define pl(a) printf("%lld\n",a); #define bitcnt(x) __builtin_popcountll(x) #define mp make_pair #define mod 1000000007 using namespace std; int dp[2][10001],n; int dis[10005],vis[10005]; int w[10005]; vector<pii>v[10005]; void dijistra(int src) {   for (int i = 1; i < n; i++)     dis[i] = mod;   MS0(vis);   int s, tmp;   dis[src] = 0;   priority_queue<pii, vector<pii>, greater<pii> > q;   q.push(pii(0, 0));   pii cur, tmp1;   while (!q.empty())   {     cur = q.top();     q.pop();     if (vis[cur.second])       continue;     vis[cur.second] = 1;     s = v[cur.second].size();     for (int i = 0; i < s; i++)     {       tmp1 = v[cur.second][i];       tmp = cur.first + tmp1.second;       if (dis[tmp1.first] > tmp)       {         dis[tmp1.first] = tmp;         q.push(pii(tmp, tmp1.first));       }     }   }    for (int i = 1; i < n; i++)     dis[i] *= 2;   return;  } int main() {   ios_base::sync_with_stdio(0);   cin.tie(0); #ifndef ONLINE_JUDGE   freopen("input.txt", "r", stdin); #endif   int e,t,a,b,c,d;   cin >> t;   while (t--)   {     cin >> n >> e >> d;     for (int i = 0; i < e; i++)     {       cin >> a >> b >> c;       v[a].pb(mp(b, c));       v[b].pb(mp(a, c));     }     MS0(dp);     for (int i = 1; i < n; i++)     {       cin >> w[i];     }     dijistra(0);     for (int i = 1; i < n; i++)     {       for (int j = 0; j <= d; j++)       {         if (j - dis[i] >= 0)         {           dp[(i&1)][j] = max(dp[!(i&1)][j], dp[!(i&1)][j - dis[i]] + w[i]);         }         else           dp[i&1][j] = dp[!(i&1)][j];       }     }     cout << dp[(n-1)&1][d] << endl;       for(int i = 0; i <= n; i++)         v[i].clear();   }    return 0; }
#include<bits/stdc++.h> using namespace std; map<string,int> mp; string name[10010]; vector<int> vec[10010]; int len[10010];  int main() {   int t,n,q,i,j;   cin>>t;   while(t--)   {    cin>>n>>q;    for(i=1;i<=n;i++)    {      vec[i].clear();      cin>>name[i];      mp[name[i]]=1;   //lexicographically sorted      len[i]=name[i].length();    }     int cnt=0;    map<string,int>::iterator it;     for(it=mp.begin();it!=mp.end();it++)    {      cnt++;      (*it).second=cnt;    }      for(i=1;i<=n;i++)    {      vec[mp[name[i]]].push_back(i);    }     int l,r;     int ans,sz;    while(q--)    {     cin>>l>>r;     ans=0;     sz=0;     for(i=1;i<=cnt;i++)     {       int ss=vec[i].size();       int le=0;       for(j=0;j<ss;j++)       {          if(vec[i][j]>=l && vec[i][j]<=r)          {             le=len[vec[i][j]];          }       }        if(le>0)       {          sz++; ans+=sz*le;       }     }     cout<<ans<<endl;      }      mp.clear();    }  } 
#include<iostream> #include<stdio.h> #include<map> #include<math.h> #include<string.h> #include<vector> #include<queue> #include<list> #include<iomanip> #include<algorithm> #define FOR(i,a,b) for(long long int i=(a);i<=(b);++i) #define NFOR(i,a,b) for(long long int i=(a);i>=(b);--i) #define pb push_back #define ll long long using namespace std; vector<ll>v; int main() {     ll t,n,x;     cin>>t;     while(t--)     {         cin>>n;       FOR(i,1,n)       {           cin>>x;           v.pb(x);       }       ll c=0;       ll inc=0,dec=0;       if(v[1]>v[0])         inc=1;       else         dec=1;       FOR(i,0,n-2)       {           if(inc)           {               if(v[i+1]<v[i])                 {c++;               inc=0;               dec=1;}           }           if(dec)           {               if(v[i+1]>v[i])                 {c++;               inc=1;               dec=0;}           }       }       cout<<c<<endl;       v.clear();     }     return 0; } 
#include<iostream> //#include<conio.h> //#include<fstream>  using namespace std;   unsigned long long int fib[]={0, 1 ,1ull ,2ull ,3ull ,5ull ,8ull ,13ull ,21ull ,34ull ,55ull ,89ull ,144ull ,233ull ,377ull ,610ull ,987ull ,1597ull ,2584ull ,4181ull ,6765ull ,10946ull ,17711ull ,28657ull ,46368ull ,75025ull ,121393ull ,196418ull ,317811ull ,514229ull ,832040ull ,1346269ull ,2178309ull ,3524578ull ,5702887ull ,9227465ull ,14930352ull ,24157817ull ,39088169ull ,63245986ull ,102334155ull ,165580141ull ,267914296ull ,433494437ull ,701408733ull ,1134903170ull ,1836311903ull ,2971215073ull ,4807526976ull ,7778742049ull ,12586269025ull ,20365011074ull ,32951280099ull ,53316291173ull ,86267571272ull ,139583862445ull ,225851433717ull ,365435296162ull ,591286729879ull ,956722026041ull ,1548008755920ull ,2504730781961ull ,4052739537881ull ,6557470319842ull ,10610209857723ull ,17167680177565ull ,27777890035288ull ,44945570212853ull ,72723460248141ull ,117669030460994ull ,190392490709135ull ,308061521170129ull ,498454011879264ull ,806515533049393ull ,1304969544928657ull ,2111485077978050ull ,3416454622906707ull ,5527939700884757ull ,8944394323791464ull ,14472334024676221ull ,23416728348467685ull ,37889062373143906ull ,61305790721611591ull ,99194853094755497ull ,160500643816367088ull ,259695496911122585ull ,420196140727489673ull ,679891637638612258ull ,1100087778366101931ull ,1779979416004714189ull ,2880067194370816120ull ,4660046610375530309ull ,7540113804746346429ull ,12200160415121876738ull};    bool binSearch(unsigned long long  n) {         int upper=93;   int lower=0;   int mid=0;   while(lower<=upper)   {                      mid=(lower+upper)/2;                      if(fib[mid]==n)                        return true;                      if(fib[mid]>n)upper=mid-1;                      else  lower=mid+1;                                             }      return false;        } int main() {             //  freopen("C:\\Users\\admin\\Desktop\\output.txt","w",stdout);   //  freopen("C:\\Users\\admin\\Desktop\\input.txt","r",stdin);               long long int t;     cin>>t;     unsigned long long int n;     while(t--)     {               cin>>n;  //             if(n==0 ){cout<<"YES\n";continue;}               if(binSearch(n))               {cout<<"YES\n";                               }               else               {                   cout<<"NO\n";               }                                                            }                                 //  getch();     return 0; } 
//FINDING KIDDO-smallest child of a parent //http://www.codechef.com/problems/ISM05  #include<iostream> using namespace std; int main(){ 	int t,n,i,j,sum; 	cin>>t; 	while(t--){ 		cin>>n; 		for(i=1;i<n;i++){ 			j=i; 			sum=i; 			while(j){ 				sum+=j%10; 				j/=10; 			} 			if(sum==n) break; 		} 		if(i==n) cout<<"NONE\n"; 		else cout<<i<<endl; 	} 	return 0; }
#include<stdio.h> #include<string.h> int main() { 	char a[102], c, temp; 	int te, i, j, p, q, n; 	scanf("%d\n", &te); 	while (te--) 	{ 		i = 0; 		gets(a); 		n = strlen(a); 		for (i = 0; i < n;) 		{ 			p = i; 			while (a[i] >= 97 && a[i] <= 122) 				i++; 			q = i - 1; 			while (p < q) 			{ 				temp = a[p]; 				a[p] = a[q]; 				a[q] = temp; 				p++; 				q--; 			} 			i++; 		} 		for (i = 0; i < n; i++) 			printf("%c", a[i]); 		printf("\n"); 	} 	return 0; }
#include<iostream> #include<bits/stdc++.h>   using namespace std; typedef long long ll; ll cal(ll n) { 	 	ll val=1,co=1; ll sum=0; while(val<= n) { //cout<<"inside"<<endl; 	if(co%2==1) {sum+=co; //cout<<"co"<<co<<endl; 	}	 	 	co++; 	val=val+co; 	 	 } 	 	val=val-co; 	 		ll k=co-1,kk= n -val;  if(kk!=0) 	{ 		if(kk%2==1) 		{ 		sum=sum+co;	 			 		} 	 		 		 	} 	 	 	return sum; } int main() { 	 	 	int t; 	cin>>t; 	while(t--) 	{ 	 ll n,m; cin>>n>>m; n--;   	 	 ll sum1=cal(n);   ll  sum=cal(m);  ll ans=sum-sum1;   cout<<ans<<endl;   } 	return 0; 	 }
#include<bits/stdc++.h> #define s(n) scanf("%d",&n) #define sl(n) scanf("%lld",&n) #define p(n) printf("%d\n",n) #define mod 1000000007LL #define ll long long #define pb push_back #define mp make_pair #define N 100011 #define LN 21 using namespace std; int bit[2*N],maxval,bit1[2*N],maxval1,bit2[2*N],bit3[2*N]; ll powmod(ll a,ll b,ll c) {  ll res=1LL;  while(b>0)  {   if(b&1)   res=(res*a)%c;   a=(a*a)%c;   b/=2;  }  return res; } ll inverse(ll a,ll MOD) { if(a==0) return 1LL; else return powmod(a,MOD-2,MOD); } void update(int idx,int val) {  while(idx<=maxval)  {   bit[idx]+=val;   idx+=(idx & -idx);  } } int query(int idx) {  int sum=0;  while(idx>0)  {    sum+=bit[idx];    idx-=(idx & -idx);  }  return sum; } ll fact[400005]; int lc[400005],lc1[400005];  ll ncr(int n,int r) {  ll num=fact[n];  ll den=(fact[r]*fact[n-r])%mod;  ll ans=(num*inverse(den,mod))%mod;  return ans; } int main() {  int t,n,l,k,i;  int a[50002];  s(t);  while(t--)  {   s(l);s(n);s(k);   for(i=0;i<n;++i)   s(a[i]);   sort(a,a+n);   ll ans=0;   for(i=0;i<n;++i)   {    if(a[i]>k)    ans+=(n-i-1);    else    {     int ri=n-1-i;     int lo=i+1;     int hi=n-1;     int id1,id2;     id1=id2=-1;     while(lo<=hi)     {      int mid=(lo+hi)/2;      if(a[mid]-a[i]>k)      {       id1=mid;       hi=mid-1;      }      else      lo=mid+1;     }     if(id1!=-1)     id1=n-id1;     lo=i+1;     hi=n-1;      while(lo<=hi)     {      int mid=(lo+hi)/2;      if(l-a[mid]>k)      {       id2=mid;       lo=mid+1;      }      else      hi=mid-1;     }     if(id2!=-1)     id2=id2-i;     //cout<<id1<<" "<<id2<<" "<<i<<endl;     id1=max(0,id1);     id2=max(id2,0);     ans+=min(ri,id1+id2);    }   }   cout<<ans<<endl;  } } 
#include<iostream> #include<fstream> #include<stdlib.h> #include<limits.h> #include<math.h> #include<cstdio> #include<vector> #include<string> #include<cstring> #include<queue> #include<map> #include<set> #include<algorithm> #include<iomanip> #include<bitset> using namespace std; int t,s,n; int main() { //freopen("ttt.txt", "r", stdin); scanf("%d",&t); while(t--) { scanf("%d",&s); n=0; while(s>0) {  if(!(s%2)) {     s/=2; } else {   s=s-1;   n++; } } printf("%d\n",n); }  return 0; } 
#include<bits/stdc++.h> #define s(n) scanf("%d",&n) #define sl(n) scanf("%lld",&n) #define p(n) printf("%d\n",n) #define mod 1000000007LL #define ll long long #define pb push_back #define mp make_pair #define N 100011 #define LN 21 using namespace std; int bit[2*N],maxval,bit1[2*N],maxval1,bit2[2*N],bit3[2*N]; ll powmod(ll a,ll b,ll c) {  ll res=1LL;  while(b>0)  {   if(b&1)   res=(res*a)%c;   a=(a*a)%c;   b/=2;  }  return res; } ll inverse(ll a,ll MOD) { if(a==0) return 1LL; else return powmod(a,MOD-2,MOD); } void update(int idx,int val) {  while(idx<=maxval)  {   bit[idx]+=val;   idx+=(idx & -idx);  } } int query(int idx) {  int sum=0;  while(idx>0)  {    sum+=bit[idx];    idx-=(idx & -idx);  }  return sum; } ll fact[400005]; int lc[400005],lc1[400005];  ll ncr(int n,int r) {  ll num=fact[n];  ll den=(fact[r]*fact[n-r])%mod;  ll ans=(num*inverse(den,mod))%mod;  return ans; } int main() { int i,t,n; fact[0]=fact[1]=1; for(i=2;i<=400000;++i) fact[i]=(fact[i-1]*i)%mod; cin>>t; while(t--) {  string s1;  cin>>s1>>n;  if(n==1)  {   int an=0;   for(i=0;i<s1.length();++i)   if(s1[i]=='o')   an++;   cout<<an<<endl;  }  else  {   int l=n/2;   if(s1[0]=='l')   lc[0]=1;   else   lc[0]=0;   for(i=1;i<s1.length();++i)   {    lc[i]=lc[i-1];    if(s1[i]=='l')    lc[i]++;   }   int len=s1.length();   assert(len<=400000);   if(s1[len-1]=='l')   lc1[len-1]=1;   else   lc1[len-1]=0;   for(i=len-2;i>=0;--i)   if(s1[i]=='l')   lc1[i]=lc1[i+1]+1;   else   lc1[i]=lc1[i+1];   ll ans=0;   for(i=0;i<len;++i)   {    if(s1[i]=='u')    {     if((lc[i]>=l) && (lc1[i]>=l))     ans+=(ncr(lc[i],l)*ncr(lc1[i],l));     assert(ans>=0);     ans%=mod;    }   }   cout<<ans<<endl;  } } return 0; } 
#include<iostream> using namespace std;  int main() {	 	 int t; 	 scanf("%d",&t); 	 while(t--) 	 {  		int a,xi,x,cnt=0;  		xi=0;  		for(int i=0;i<15;i++)  		{ 		 	scanf("%d",&a); 		 	xi=xi^a; 		 } 		 scanf("%d",&x); 		 while(xi) 		 {  			  			if(xi&1)  			cnt++;  			xi>>=1;  		}  		if(cnt>x)  		printf("YES\n");  		else 	 	printf("NO\n");  	} 	 return 0; }
#include<bits/stdc++.h>  using namespace std;  int func(int a1){ 	int ans =0; 	while(a1>0){ 		ans+= a1%2; 		ans++; 		a1 /= 2; 	} 	ans-=2; 	return ans; } int main(){ 	ios::sync_with_stdio(false);    int T; 	cin>>T; 	while(T--){ 	int n; 	cin>>n; 	int a = n, b =0, ans = 0,a1 = n; 	ans = func(a1); //	cout<<ans<<endl; 	int anscp = ans, ansc = ans; 	int n1 = n/2, n2 = n/2 + n%2; 	anscp = min(anscp, max(func(n1),func(n2)) ); 	while(a>0){ //		cout<<max(func(a),func(b))<<' '<<b<<endl; 		anscp = min(anscp,max(func(a),func(b))); 		 		b += a&(-a); 		ans -= 1; 		a -= a&(-a);  	}  	cout<<anscp<<endl; 	} 	return 0; } 
//Author : pakhandi // using namespace std;  #include<iostream> #include<cstdio> #include<cstdlib> #include<algorithm> #include<cmath> #include<cstring>  #define wl(n) while(n--) #define fl(i,a,b) for(i=a; i<b; i++) #define rev(i,a,b) for(i=a; i>=b; i--) #define scan(n) scanf("%d", &n) #define scans(s) scanf("%s", s) #define scanc(c) scanf("%c", &c) #define scanp(f) scanf("%f", &f) #define scanll(l) scanf("%lld", &l) #define print(n) printf("%d\n", n) #define prints(s) printf("%s\n", s) #define printc(c) printf("%c\n", c) #define printp(f) printf("%f\n", f) #define printll(l) printf("%lld\n", l) #define MOD 1000000007 #define ll long long int  int fgcd(int a, int b)		//a>b { 	if(a%b==0) 	{ 		return b; 	} 	return fgcd(b,a%b); }  int main() { 	int i, j, cases, x1, y1, x2, y2, ans, a, b; 	scan(cases); 	wl(cases) 	{ 		scan(x1); 		scan(y1); 		scan(x2); 		scan(y2); 		a=abs(x2-x1); 		b=abs(y2-y1); 		if(a==0) 		{ 			ans=b-1; 			//continue; 		} 		else if(b==0) 		{ 			ans=a-1; 			//continue; 		} 		else 			ans=fgcd(a,b)-1; 		if(ans>=0) 			print(ans); 		else 			printf("0\n"); 	} 	return 0; }
#include<iostream> #include<cstdio> #include<cstring> #include<cmath> #include<set> #include<vector> #include<map> #include<algorithm>  using namespace std;  #define maxn 300009 #define maxn1 100009 #define mod  1000000007 #define inf 10000009 #define gc getchar_unlocked  typedef long long ll; typedef pair<int,int> ii;  int n,c; int arr[maxn];  vector<int> v1[maxn1]; vector<int> :: iterator it1,it2;   struct segment { 	int total,color,length,st1,ed1; };  int read() {   int ret = 0;   char c = gc();   while(c<'0' || c>'9') c = gc();   while(c>='0' && c<='9') {     ret = 10 * ret + c - 48;     c = gc();   }   return ret; }  segment tree[4*maxn];  int func(int color , int start , int end) { 	it1 = lower_bound(v1[color].begin() , v1[color].end() , start); 	it2 = upper_bound(v1[color].begin() , v1[color].end() , end); 	 	if(it1!=v1[color].end() && it2!=v1[color].end()) 	{ 		int index1 = it1 - v1[color].begin() ; 		int index2 = it2 - v1[color].begin() ;  		index2--;  		if(v1[color][index2]<=end && v1[color][index2]>=start && v1[color][index1]>=start && v1[color][index1]<=end) 		return index2-index1 +1;  		else 		return 0; 	} 	 	else if(it1 != v1[color].end() && it2 == v1[color].end()) 	return (v1[color].size() - ( it1-v1[color].begin() ) );  	else if(it1 == v1[color].end() && it2 == v1[color].end()) 	return 0; }   segment merge(segment node1 , segment node2,int start1,int end1 , int start2 , int end2) { 	segment result;  	result.total = 0; 	result.color=-1; 	result.length=node1.length + node2.length; 	if(start1 != inf &&start2!=inf && end1!=inf && end2!=inf) 	{   		result.st1 = start1; 		result.ed1 = end2; 	} 	else if(start1 == inf && start2 !=inf && end1==inf && end2!=inf) 	{ 		result.st1 = start2; 		result.ed1 = end2; 	} 	else if(start1 != inf &&start2==inf && end1!=inf && end2==inf) 	{ 		result.st1 = start1; 		result.ed1 = end1; 	} 	else  	{ 		result.st1 = inf; 		result.ed1 =inf; 		return result; 	} 	if(node1.color == -1 && node2.color == -1) 	{ 		result.total = 0; 		result.color = -1; 	} 	else if(node1.color==-1 && node2.color!=-1) 	{ 		int t1 = func(node2.color , start1 , end1); 		if(t1 + node2.total > (result.length/2)) 		{ 			result.total = node2.total+t1; 			result.color = node2.color; 		} 	} 	else if(node1.color != -1 && node2.color == -1) 	{ 		int t1 = func(node1.color , start2 , end2); 		if(t1 + node1.total > (result.length/2)) 		{ 			result.total = node1.total + t1; 			result.color = node1.color; 		} 	} 	else if(node1.color != -1 && node2.color != -1) 	{ 		int color1 = node1.color; 		int color2 = node2.color; 		if(color1==color2) 		{ 			result.total = node1.total + node2.total; 			result.color = color1; 		} 		else 		{ 			int t1=0,t2=0; 			t1 = func(color1,start2,end2); 			t2 = func(color2,start1,end1);  			int len1 = node1.length; 			int len2 = node2.length; 			 			if(((len1+len2)/2) < t1+ node1.total) 			{ 				result.color = color1; 				result.total = t1+ node1.total; 			} 		  else if(((len1+len2)/2) < t2+ node2.total) 			{ 				result.color = color2; 				result.total = t2 + node2.total; 			} 		} 	}  	return result; }  void build_tree(int node, int a, int b)  {     if(a > b) return;    	if(a == b)  		{      		tree[node].color = arr[a]; 				tree[node].total = 1;  				tree[node].length = 1; 				tree[node].st1 =a; 				tree[node].ed1 = b; 				return; 		} 		 		int mid = (a+b)/2;	 		int start1 = a; 		int end1 = mid; 		int start2 = mid+1; 		int end2 = b;  		build_tree(node*2, a, (a+b)/2);  		build_tree(node*2+1, 1+(a+b)/2, b); 	 	  tree[node] = merge(tree[node*2], tree[node*2+1],tree[node*2].st1,tree[node*2].ed1,tree[node*2+1].st1,tree[node*2+1].ed1); }  segment query_tree(int node, int a, int b, int i, int j)  { 	segment res1,dummy,res2,res3,res4;  	dummy.total=0; 	dummy.color=-1; 	dummy.length=0; 	dummy.st1 = inf; 	dummy.ed1 = inf; 	if((a > b) || (a > j) || (b < i)) return dummy;  	 	if(a >= i && b <= j)  	{ 		res1.color = tree[node].color; 		res1.total = tree[node].total; 		res1.length = tree[node].length; 		res1.st1 = a; 		res1.ed1 = b; 		return res1; 	} 	 	int mid = (a+b)/2; 	int start1 = a; 	int end1 = mid; 	int start2 = mid+1; 	int end2 = b; 	  	res1 = query_tree(node*2, a, (a+b)/2, i, j);  	res2 = query_tree(1+node*2, 1+(a+b)/2, b, i, j);    	segment res = merge(res1,res2,res1.st1,res1.ed1,res2.st1,res2.ed1);  	return res; }  int main()  { 	//scanf("%d%d",&n,&c); 	n=read(); 	c=read(); 	for(int i=0;i<n;i++) 	{ 		//scanf("%d",&arr[i]); 		arr[i] = read(); 		v1[arr[i]].push_back(i); 	}  	build_tree(1,0,n-1); 	 	int m,l,r; 	scanf("%d",&m); 		 	for(int i=0;i<m;i++) 	{ 		l=read(); 		r = read(); 		//scanf("%d%d",&l,&r); 		l--; 		r--;  		segment result = query_tree(1,0,n-1,l,r);  		if(result.color==-1) 		printf("no\n"); 		else 		printf("yes %d\n",result.color);  	} 	return 0; } 
#include <bits/stdc++.h> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {         int x,y,z,u,v,i;         cin>>x>>y>>u>>v;         if(u>v)         {             i=floor((y-x)/(u-v));             z=u*i;             cout<<"("<<z+x<<","<<"0)"<<endl;         }         else             cout<<"not possible"<<endl;     }     return 0; }
#include<bits/stdc++.h> #include<iostream> using namespace std; bool perfectSquare(int x) { 	int s=sqrt(x); 	return(s*s==x); } int main() { 	int T,N1,N2; 	long long int N; 	cin>>T; 	while(T--) 	{ 		cin>>N; 		N1=5*N*N+4; 		N2=5*N*N-4; 		if(perfectSquare(N1) || perfectSquare(N2)) 		cout<<"is fibo"<<endl; 		else 		cout<<"not fibo"<<endl; 	} 	return 0; }
 #include<bits/stdc++.h>     using namespace std;       int minJumps(int arr[], int n)     {     int *jumps = new int[n]; // jumps[0] will hold the result     int min;     // Minimum number of jumps needed to reach last element     // from last elements itself is always 0     jumps[n-1] = 0;     int i, j;     // Start from the second element, move from right to left     // and construct the jumps[] array where jumps[i] represents     // minimum number of jumps needed to reach arr[m-1] from arr[i]     for (i = n-2; i >=0; i--)     {     // If arr[i] is 0 then arr[n-1] can't be reached from here     if (arr[i] == 0)     jumps[i] = INT_MAX;     // If we can direcly reach to the end point from here then     // jumps[i] is 1     else if (arr[i] >= n - i - 1)     jumps[i] = 1;     // Otherwise, to find out the minimum number of jumps needed     // to reach arr[n-1], check all the points reachable from here     // and jumps[] value for those points     else     {     min = INT_MAX; // initialize min value     // following loop checks with all reachable points and     // takes the minimum     for (j = i+1; j < n && j <= arr[i] + i; j++)     {     if (min > jumps[j])     min = jumps[j];     }     // Handle overflow     if (min != INT_MAX)     jumps[i] = min + 1;     else     jumps[i] = min; // or INT_MAX     }     }     return jumps[0];     }     // Driver program to test above function     int main()     {     int t,n;     cin>>t;     while(t--){     cin>>n;     int arr[1001];     int i;     for(i=0;i<n;i++)     cin>>arr[i];     printf("%d\n", minJumps(arr, n-1));     }     return 0;     }
#include<stdio.h> #include<algorithm> using namespace std; int pipes[10004]; int main() {     int cases;     scanf("%d",&cases);     while(cases--)     {         int num,i,flag=-1;         long long sum = 0;         scanf("%d",&num);         for(i=0; i<num; i++)         {             scanf("%d",&pipes[i]);             sum += pipes[i];         }         sort(pipes,pipes+num);         for(i=num-1; i>1; i--)         {             if(sum-pipes[i] > pipes[i])             {                 flag = i+1;                 break;             }             sum -= pipes[i];         }         printf("%d\n",flag);     }     return 0; } 
#include <math.h> #include<stdio.h> #include<iostream> using namespace std; int main() {   int arr[40];   arr[0]=0;   arr[1]=1;   arr[2]=1;   for(int i=3;i<=40;i++)     arr[i]=arr[i-1]+arr[i-2];   int test;   scanf("%d",&test);    while(test--)   {       int flag=0;       int n,i;       scanf("%d",&n);       if(n==0)       {           cout<<"Yes\n";           continue;       }       for(i=0;i<40;i++)       {         if(arr[i]==n)         {             printf("Yes\n");             flag=1;             break;         }       }       if(flag==0)         printf("No\n");   }   return 0; } 
#include <iostream> #include<cstdio> using namespace std; int main()    { int n; long int arr[]={ 3,4, 33,34,43,44, 333,334,343,344,433,434,443,444, 3333,3334,3343,3344,3433,3434,3443,3444, 4333,4334,4343,4344,4433,4434,4443,4444, 33333,33334,33343,33344,33433,33434,33443,33444, 34333,34334,34343,34344,34433,34434,34443,34444, 43333,43334,43343,43344,43433,43434,43443,43444, 44333,44334,44343,44344,44433,44434,44443,44444, 333333,333334,333343,333344,333433,333434,333443,333444, 334333,334334,334343,334344,334433,334434,334443,334444, 343333,343334,343343,343344,343433,343434,343443,343444, 344333,344334,344343,344344,344433,344434,344443,344444, 433333,433334,433343,433344,433433,433434}; scanf("%d",&n); printf("%ld",arr[n-1]); }
#include <iostream> #include<string.h> #include<algorithm> using namespace std;  int main() { char a[150],b[150]; int arr[150],brr[150],sum[200],lena,lenb; int i,m=0,k=0; cin>>a>>b; lena=strlen(a); lenb=strlen(b); for(i=lena-1;i>=0;i--) arr[k++]=a[i]-'0'; k=0; for(i=lenb-1;i>=0;i--) brr[k++]=b[i]-'0';  for(i=0;i<max(lena,lenb);i++) {  m=m+arr[i]+brr[i];  sum[i]=m%10;  m=m/10; } while(m>0) { sum[i++]=m%10; m=m/10; } cout<<"Result = "; for(k=i-1;k>=0;k--) cout<<sum[k];      	return 0; }
#include<stdio.h> int main() {         int a[200]; //array will have the capacity to store 200 digits.     int n,i,j,temp,m,x;        scanf("%d",&n);        a[0]=1;  //initializes array with only 1 digit, the digit 1.        m=1;    // initializes digit counter         temp = 0; //Initializes carry variable to 0.        for(i=1;i<=n;i++)        {             for(j=0;j<m;j++)             {                x = a[j]*i+temp; //x contains the digit by digit product                a[j]=x%10; //Contains the digit to store in position j                temp = x/10; //Contains the carry value that will be stored on later indexes             }              while(temp>0) //while loop that will store the carry value on array.              {                 a[m]=temp%10;                temp = temp/10;                m++; // increments digit counter              }       }               for(i=m-1;i>=0;i--) //printing answer               printf("%d",a[i]);               printf("\n");         return 0; }
#include <iostream> #include<map> using namespace std;  map<int,bool> visit;  int bin_search(int a[], int n, int k){ 	 	int low=0,high= n-1; 		 //	for(int i=0;i<n;i++) //		cout<<a[i]<<" "; 	 	 	while(low<=high){ 		int mid = (high+low)/2; 		 		if(a[mid] == k){ 			return 1; 		 		if(a[mid]>k) 		high=mid-1; 		else 		low= mid+1; 		} 	} 	 	return -1; }  int main() { 	// your code goes here 	int n; 	cin>>n; 	visit.clear(); 	int a[n+1],i; 	 	for(i=0;i<n;i++) 	{ 		cin>>a[i]; 		visit[a[i]]=1; 	} 		 	int sum; 	cin>>sum; 	bool f=0; 	 	for(i=0;i<n;i++){ 		int left = a[i]; 		 		if(sum>=left && visit[sum-left]==1) 		{ 			cout<<"YES\n"; 			f=1; 			break; 		} 	} 	 	if(f==0) 	cout<<"NO\n"; 	 	return 0; }
#include<iostream> #include<vector> #include<string.h> #include<stdio.h> #include<climits> #include<map> #include<math.h> #include<set> #include<algorithm> #define LL long long int #define P(N) printf("%d\n",N); #define S(N) scanf("%d",&N); #define SL(N) scanf("%lld",&N); #define pb push_back #define mp make_pair #define pnl printf("\n"); #define FOR(i,a,b) for (i=a;i<=b;i++) #define mem(a,val) memset(a,val,sizeof(a)) using namespace std; int gcd(int a, int b){ int temp; while(b>0)	{ temp= b; b=a%b; a=temp;}	return a;} vector<int>adj[5005]; int dp[5005][2]; // 0 include, 1 exclude void liss(int node) {     int include=1,exclude=0,len= adj[node].size(),V;     for(int i=0;i<len;i++)     {         V= adj[node][i];         liss(V);         include+=dp[V][1];         exclude+= max(dp[V][1],dp[V][0]);     }     dp[node][0]= include;     dp[node][1]= exclude;     return; } int main() {        #ifndef ONLINE_JUDGE        //     freopen("C:\\Users\\hp pc\\Desktop\\input.txt", "r", stdin);       #endif       int i,j,t,N,u,v;       S(t);       while(t--)       {             memset(dp,0,sizeof(dp));             S(N) N--;             for(int i=0;i<=N+1;i++)adj[i].clear();             while(N--)             {                 scanf("%d %d",&u,&v);                 adj[v].pb(u);             }             liss(0);             printf("%d\n",max(dp[0][0],dp[0][1]));       } return 0; } 
#include<iostream> #include<algorithm> using namespace std; int a[1001]; int main() {     int t,n,i,b;     cin>>t;     while(t--)     {         cin>>n;         for(i=1;i<=1000;i++)             a[i]=0;         for(i=1;i<=n;i++)         {            cin>>b;            a[b]++;          }         int c=0;         for(i=1;i<=1000;i++)         {             if(a[i]>1)                 c++;         }         cout<<c<<endl;     } } 
#include<iostream> #include<vector> #include<algorithm> #include<cstdio> #include<string> #include<cstdlib> #include<cmath> #include<set> #include<cstring> using namespace std; #define gc getchar_unlocked long read_int() {   char c = gc();   while(c<'0' || c>'9') c = gc();   long ret = 0;   while(c>='0' && c<='9') {     ret = 10 * ret + c - 48;     c = gc();   }   return ret; } main() {      int t;scanf("%d",&t);      while(t--)      {        int n=read_int();        int x=0,y=0;        for(int i=0;i<n;i++)        {           int a=read_int(),b=read_int();           x+=a;           y+=b;        }        cout<<x-y<<endl;      }      }
#include<bits/stdc++.h> using namespace std; int fun(long int n) { int ans=0; while(n%2==0) { n=n/2; ans=n; } for(int i=3;i<=sqrt(n);i=i+2) { while(n%i==0) { ans=i; n=n/i; } } if(n>2) ans=n; return ans; } int main() { int t; long int n; scanf("%d",&t); while(t--) { scanf("%ld",&n); int ans=fun(n); ans=n/ans; printf("%d\n",ans); } return 0; } 
#include<bits/stdc++.h> using namespace std; typedef unsigned long long ll; #define s(n) scanf("%llu",&n)   int main() { ll T,i,t1,t2,t3,sum=0;   s(T);   while(T--) { s(t1);s(t2);s(t3);sum=0;   sum= t1/3+t2/3+t3/3+ min( t1%3 , min( t2%3 ,t3%3 )); if((t1%3==2 && t2%3==2 && t3%3==0 &&t3>0) || (t3%3==2 && t2%3==2 && t1%3==0 &&t1>0) || (t1%3==2 && t3%3==2 && t2%3==0 &&t2>0))  sum++;  cout<<sum<<"\n";  }  }
#include<cstdio> #include<iostream> #include<cstring> using namespace std; long int dp[101][201]; long int dp1[101][201]; char inp[101][25];  int a[101][201]; int n,m; long int ret(int i,int j){ //	printf("%d %d\n",i,j); 	if(j==m){ 		return 0; 	} 	if(dp[i][j]==-1){ 		int k; 		int ind; 		long int minn=ret(i,j+1); 		ind=i; 		long int y; 		for(k=0;k<n;k++){ 			if(k!=i){ 				y=ret(k,j+1)+a[k][j]-(a[i][j]-100); 				if(y<minn){ 					minn=y; 					ind=k; 				} 			} 		} 		dp[i][j]=minn; 		dp1[i][j]=ind; 	} 	return dp[i][j]; } int main(){ 	char s[100]; 	while(1){ 		scanf("%s",s); 		if(strcmp(s,"TheEnd")==0){ 			break; 		} 		cin >> n >> m; 		int i,j; 		//cout << n << m << endl; 		for(i=0;i<n;i++){ 			scanf("%s",inp[i]); 			for(j=0;j<m;j++){ 				scanf("%d",&a[i][j]); 				dp[i][j]=-1; 			} 		} /*		for(i=0;i<n;i++){ 			for(j=0;j<m;j++){ 				printf("%d ",a[i][j]); 			} 			printf("\n"); 		}*/ 		long int minn=a[0][0]+ret(0,1); 		long int y; 		int out[m]; 		int ind=0; 		for(i=1;i<n;i++){ 			y=a[i][0]+ret(i,1); 			if(y<minn){ 				minn=y; 				ind=i; 			} 		} 		int k; 		k=0; 		out[k]=ind; 		k++; 		ind=dp1[ind][k]; 		while(k<m){ 			out[k]=ind; 			k++; 			ind=dp1[ind][k]; 		} /*		for(i=0;i<m;i++){ 			printf("%d ",out[i]); 		} 		printf("\n");*/ 		printf("%s\n",s); 		cout << "Tk "<< minn << endl; 		i=0; 		int c=0; 		while(i<m-1){ 			c=1; 			while(1){ 				if(i>=m-1){ 					break; 				} 				if(out[i]==out[i+1]){ 					i++; 					c++; 				} 				else{ 				break; 				} 			} 			printf("%s for %d month(s)\n",inp[out[i]],c); 			i++; 		} 		if(out[m-1]!=out[m-2]){ 			printf("%s for 1 month(s)\n",inp[out[m-1]]); 		} 		cout << endl; 	} 	printf("TheEnd\n"); 	return 0; } 
#include <cstdio> #include <cstring> #include <cmath> #include <algorithm> #include <vector> #include <utility> #include <set> #include <map> #include <iostream> #include <queue> #include <climits>  using namespace std;  typedef long long LL;  #define PB push_back #define FRO freopen("in.txt","r",stdin);  #define CLR(arr) memset( (arr),0,sizeof(arr) ); #define NEG(arr) memset( (arr),-1,sizeof(arr) );  typedef pair<int,int> pint; typedef map<int,int> mint;  #define SIZE 105  double h[SIZE][SIZE]; vector<double> cost[SIZE][SIZE];  struct node{     int r,c;     double val;     bool operator < (const node & p)const{return val>p.val;} };  bool vis[SIZE][SIZE];  int row ,col;  int dr[]={-1,0,1,0}; int dc[]={0,-1,0,1};  double dijkstra(int sr,int sc , int fr , int fc ){      for (int i=1;i<=row;++i){         for (int j=1;j<=col;++j){             vis[i][j]=false;         }     }      //CLR(vis);      node place,temp,u;     place.val=0;     place.r=sr;     place.c=sc;       priority_queue<node> q;      q.push(place);       while (!q.empty())     {         temp=q.top();q.pop();         if (temp.r == fr && temp.c ==fc ){             return temp.val;         }          if (vis[temp.r][temp.c])             continue;         vis[temp.r][temp.c]=true;           for (int i=0;i<4;++i)         {             u.r=temp.r+dr[i];             u.c=temp.c+dc[i];              if ( u.r>0 && u.r<=row && u.c>0 && u.c<=col && !vis[ u.r ][ u.c ] ){                 //cout<<cost[temp.r][temp.r].size()<<endl;                 u.val=temp.val+cost[temp.r][temp.c][i];                 q.push(u);             }         }     }     return -1; }   int main(){      //FRO      int kase;     scanf("%d",&kase);      for (int kk=1;kase--;++kk){          scanf("%d %d",&row,&col);          for (int i=1;i<=row;++i){             for (int j=1;j<=col;++j){                 scanf("%lf",&h[i][j]);                 cost[i][j].clear();             }         }         int r,c;         for (int i=1;i<=row;++i){             for (int j=1;j<=col;++j){                 for (int k=0;k<4;++k){                     r=i+dr[k];                     c=j+dc[k];                     double h1= h[i][j];                     double h2= h[ r ][ c ];                      if ( h1 > h2 ){                         cost[i][j].PB( 0.5 + 0.5 * sqrt( 1 + (h1 - h2 )*(h1 - h2 ) ) );                     }else{                         cost[i][j].PB( -0.5 + 1.5 * sqrt( 1 + (h1 - h2 )*(h1 - h2 ) ) );                     }                 }             }         }          int qq;         scanf("%d",&qq);         int sr,sc,fr,fc;         printf("Case %d:\n",kk);         while ( qq-- ){              scanf("%d %d %d %d",&sr,&sc,&fr,&fc);              printf("%.6lf\n",dijkstra( sr,sc,fr,fc ) );         }     }       return 0; } 
#include<iostream> #include<stdlib.h> #include<string> using namespace std; void LPSArray(string str) {     long long int l =str.length();     long long int *lps = (long long int *)malloc(sizeof(long long int)*l);     long long int len=0,i=1;     lps[0] = 0;     if(l-1!=0)         cout<<lps[0]<<" ";     while(i<l)     {         if(str[i]==str[len])         {             len++;             lps[i] = len;             if(i!=l-1)                 cout<<lps[i]<<" ";             i++;         }         else         {             if(len!=0)                 len = lps[len-1];             else             {                 lps[i]=0;                 if(i!=l-1)                     cout<<lps[i]<<" ";                 i++;             }         }     }     i--;     cout<<lps[i]<<endl;  } int main() {     string str;     cin>>str;     while(str.compare("End")!=0)     {         LPSArray(str);         cin>>str;     }     return 0; } 
#include <bits/stdc++.h>  using namespace std;  #define rept(i,a,b) for(int (i) = (a); i < (b); i++) #define rep(i,n) for(int (i) = 0; i < (n); i++) #define tr(c,it) for(__typeof(c.begin()) it = c.begin(); it != c.end(); ++it) #define all(c) c.begin(),c.end() #define inf (int)1e9 #define pb push_back #define mp make_pair #define fill(arr,val) memset(arr,val,sizeof(arr)) #define gi(n) scanf("%d",&n) #define gl(n) scanf("%lld",&n);  typedef long long ll; typedef unsigned long long ull; typedef vector<int> vi; typedef pair<int,int> pii;  #define mod 1000000007 #define M 110 int dim;  ll unit[M][M]; ll mat[M][M];  void print(ll a[][M]) {   for(int i=0;i<dim;++i) {     for(int j=0;j<dim;++j) printf("[%lld] ",a[i][j]);     puts("");   }   puts(""); }   void copy(ll a[][M],ll b[][M]) {   for(int i=0;i<dim;i++) {     for(int j=0;j<dim;j++) {       a[i][j] = b[i][j];     }   } }  void mul(ll a[][M], ll b[][M]) {   ll c[M][M];   for(int i=0;i<dim;i++) {     for(int j=0;j<dim;j++) {       c[i][j] = 0;       for(int k=0;k<dim;k++) {         c[i][j] = (c[i][j] + (a[i][k] * b[k][j]) % mod + 2 * mod) % mod;   while(c[i][j] < 0) c[i][j] += mod;       }     }   }   copy(a,c); }  void power(ll ab[][M],ll n,ll b[][M]) {   copy(b,unit);   ll a[M][M];   copy(a,ab);   while(n) {     if(n & 1) mul(b,a);     mul(a,a);     n >>= 1;   } }  int main() {   //freopen("in.txt","r",stdin);   for(int i=0;i<M;i++) {     for(int j=0;j<M;j++) {       if(i == j) unit[i][j] = 1;       else unit[i][j] = 0;     }   }   int tt;   gi(tt);   ll f[M];   ll sigma[M];   while(tt--) {     int m,n;     gi(m); gi(n); //cerr << n << " " << m << endl;     dim = m;     rep(i,m) scanf("%lld",f+i);     rep(i,m) f[i] = (f[i] + mod) % mod;     rep(i,m) scanf("%lld",sigma+i);     for(int j=0;j<m;j++) mat[0][j] = sigma[m-1-j];     for(int i=1;i<m;i++) {       for(int j=0;j<m;j++) {         if(i == j+1) mat[i][j] = 1;         else mat[i][j] = 0;       }     }     if(n < m) {       printf("%lld\n",f[n] % mod);       continue;     }     ll b[M][M];     power(mat,n-m+1,b);     //print(unit); print(mat); print(b);     ll ans = 0;     for(int i=0;i<m;i++) {       ans = (ans + (b[0][i] * f[m-1-i]) % mod + 2 * mod) % mod;       while(ans < 0) ans += mod;     }     ans %= mod;     printf("%lld\n",ans);   }   return 0; } 
#include<iostream> #include<cstdio> #include<algorithm> #include<queue> using namespace std; long long int n,m,i,j,q,r,t,k,a,b,sum; long long int xx; long long int deg[501]; int main() { 	cin>>t; 	for(k=0;k<t;k++) 	{ 		cin>>n; 		for(i=0;i<n;i++) 		{ 			deg[i] = 0; 		} 		cin>>m; 		for(i=0;i<m;i++) 		{ 			cin>>a>>b; 			deg[a-1]++; 			deg[b-1]++; 		} 		sort(deg,deg+n,std::greater<int>()); 		for(i=0;i<n;i++) 		{ 			if(deg[i] <  i) 				break; 		} 		sum = 0; 		for(j=0;j<i;j++) 		{ 			sum+=deg[j]; 		} 		for(j=i;j<n;j++) 		{ 			sum-=deg[j]; 		} 		sum-=(i)*(i-1); 		cout<<((sum==0)?"YES":"NO")<<endl; 	} 	return 0; } 				
#include <bits/stdc++.h>   using namespace std;   #define rept(i,a,b) for(int (i) = (a); i < (b); i++) #define rep(i,n) for(int (i) = 0; i < (n); i++) #define tr(c,it) for(__typeof(c.begin()) it = c.begin(); it != c.end(); ++it) #define all(c) c.begin(),c.end() #define inf (int)1e9 #define pb push_back #define mp make_pair #define fill(arr,val) memset(arr,val,sizeof(arr)) #define gi(n) scanf("%d",&n) #define gl(n) scanf("%lld",&n);   typedef long long ll; typedef unsigned long long ull; typedef vector<int> vi; typedef pair<int,int> pii;   int main() {   int tt;   gi(tt);   for(int qq = 1; qq <= tt; qq++) {     ll n,k;     priority_queue<ll,vector<ll>, greater<ll> > Q;     scanf("%lld %lld",&n,&k);     rep(i,n) {       ll x;       scanf("%lld",&x);       Q.push(x);     }     ll mod = (k - 2) - (n - 2) % (k - 1);     rep(i,mod) Q.push(0LL);     ll sum = 0;     while(Q.size() > 1) {       ll cnt = 0;       rep(i,k) { 	cnt += Q.top(); Q.pop();       }       // printf("cnt = %lld\n",cnt);       sum += cnt;       Q.push(cnt);     }     printf("Case %d: %lld\n",qq,sum);   }   return 0; } 
#include <bits/stdc++.h>   using namespace std;   #define rept(i,a,b) for(int (i) = (a); i < (b); i++) #define rep(i,n) for(int (i) = 0; i < (n); i++) #define tr(c,it) for(__typeof(c.begin()) it = c.begin(); it != c.end(); ++it) #define all(c) c.begin(),c.end() #define inf (int)1e9 #define pb push_back #define mp make_pair #define fill(arr,val) memset(arr,val,sizeof(arr)) #define gi(n) scanf("%d",&n) #define gl(n) scanf("%lld",&n);   typedef long long ll; typedef unsigned long long ull; typedef vector<int> vi; typedef pair<int,int> pii;   #define eps 1e-5   int main() {   int tt;   gi(tt);   int arr[111];   for(int qq = 1; qq <= tt; ++qq) {     printf("Case %d:\n",qq);     int n,m;     gi(n); gi(m);     rep(i,n) {       double x;       scanf("%lf",&x);       arr[i] = (int)(x * 100.0 + eps);     }     sort(arr,arr+n);     reverse(arr,arr+n);     //cout << "inp \n"; rep(i,n) cout << arr[i] << "\n";     int cnt = 0;     for(int mm = 1; mm <= m; mm++) {       printf("Scenario %d:\n",mm);       double x;       scanf("%lf",&x);       int val = (int)(x * 100.0 + eps);       for(int i = 0; i < n; i++) { 	if(val >= arr[i]) { 	  int cnt = val/arr[i]; 	  if(arr[i] % 100) printf("%.2lf ",arr[i]/100.0); 	  else printf("%d ",arr[i]/100); 	  printf("%d\n",cnt); 	  val -= arr[i] * cnt; 	}       }     }   }   return 0; }  
#include <iostream> #include <cstring>  #include <algorithm>  using namespace std; typedef long long L;  L M[51][51]; L N[51][51]; L F[51][51][51];  L m(L n, L p){ 	if(n == 1)return 1ll; 	if(p == 3)return (1ll<<n) - 1ll;  	if(M[n][p] != 0ll)return M[n][p];  	M[n][p] = 0;   	N[n][p] = -1ll;  	L temp;  	for(L i=1;i<n;i++){ 		temp = 2*m(i,p)+m(n-i,p-1);  		if(M[n][p] > temp || M[n][p] == 0) { 			M[n][p] = temp;  			N[n][p] = i;  		} 	} 	return M[n][p];   }   L f(L n, L p, L k){ 	m(n,p);  	L n1; 	if(p > 3)n1 = N[n][p];  	else n1 = n-1;  	if(F[n][p][k] != 0ll) return F[n][p][k];  	 	if(p == 3 && k == n){ 		return m(n-1, p) + 1ll; 	}  	if(n1 >= k){ 		return F[n][p][k] = m(n1,p) + m(n-n1,p-1) + f(n1,p,k);  	} 	return F[n][p][k] = m(n1,p) + f(n-n1,p-1,k - n1);  } int main() { 	L t, n, p, k;  	cin >> t;  	for(L cs=1;cs<=t;cs++){ 		cin >> n >> p >> k;  		cout << "Case " <<cs << ": " << f(n,p,k) << endl;  	}	 }
#include <bits/stdc++.h> using namespace std; #define gi(x) scanf("%d",&x)  #define pb push_back #define mp make_pair #define all(p) p.begin(),p.end() int dp[451][451][451]; int main(){ 	int t, alen, blen, clen; 	string a,b,c; 	gi(t); 	while(t-->0){ 		cin>>a; 		cin>>b; 		cin>>c; 		alen=a.length(); 		blen=a.length(); 		clen=a.length(); 		memset(dp,0,sizeof dp); 		for(int i=1;i<=alen;i++){ 			for(int j=1;j<=blen;j++){ 				for(int k=1;k<=clen;k++){ 					if(a[i-1]==b[j-1] && b[j-1]==c[k-1]){ 						dp[i][j][k]=1+dp[i-1][j-1][k-1]; 					} 					else{ 						dp[i][j][k]=max(max(dp[i-1][j][k],dp[i][j-1][k]),dp[i][j][k-1]); 					} 				} 			} 		} 		printf("%d\n",alen+blen+clen-3*(dp[alen][blen][clen])); 	} }
#include <vector> #include <queue> #include <map> #include <set> #include <utility> //Pair #include <algorithm> #include <sstream> // istringstream>> ostring stream<< #include <iostream> #include <iomanip> //setbase - cout << setbase (16); cout << 100 << endl; Prints 64 //setfill - cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77 //setprecision - cout << setprecision (4) << f << endl; Prints x.xxxx #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <limits> using namespace std;   //M lazy ;) typedef long long ll; typedef vector <int> vi; typedef pair< int ,int > pii; typedef istringstream iss; typedef ostringstream oss; #define pb push_back #define mp make_pair #define ff first #define ss second #define sz size() #define ln length() #define rep(i,n) for(int i=0;i<n;i++) #define fu(i,a,n) for(int i=a;i<=n;i++) #define fd(i,n,a) for(int i=n;i>=a;i--) #define all(a) a.begin(),a.end() #define ESP (1e-9)   #define gi(n) scanf("%d",&n) #define gl(n) cin >> n #define pi(n) printf("%d",n) #define pl(n) cout << n #define ps printf(" ") #define pn printf("\n") #define dg(n,s); printf("%s %d",s,n) #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min() #define mod 1000000007  int main(){  	ll t; 	cin >> t; 	//long long int modulo = 1000000007; 	ll n; 	while(t--){ 		cin >> n; 		ll part1 = (n*(n-1) /2 )%mod; 		ll part2 = (((n*(n-1))%mod)*((n-2)*(n-3)%mod))%mod; 		ll part3 = (part2 * 41666667LL)%mod; 		ll part4 = (part1 + part3 + 1LL)%mod; 		cout << part4 << endl; 			//ll ans= ((((n%modulo) * ((n-1)%modulo)%modulo) * 500000004)%modulo)%modulo + (((n%modulo)*((n-2)%modulo)%modulo)*(((((n-1)%modulo)*((n-3)%modulo))%modulo)* 41666667)%modulo)%modulo + 1;	 		//cout << ans << endl;   	}   	return 0; }
#include <bits/stdc++.h> using namespace std; #define gi(x) scanf("%d",&x)  #define pb push_back #define mp make_pair #define all(p) p.begin(),p.end() int main(){ 	int t,n,x,y,m,p; 	gi(t); 	while(t-->0){ 		gi(n); 		vector< vector<int> > graph(n+1); 		for(int i=0;i<n-1;i++){ 			gi(x);gi(y); 			graph[x].pb(y); 			graph[y].pb(x); 		} 		int marked[n+1]; 		int parent[n+1]; 		memset(marked,0,sizeof(marked)); 		memset(parent,-1,sizeof(parent)); 		queue<int> q; 		q.push(1); 		while(!q.empty()){ 			int pr=q.front(); 			q.pop(); 			for(int i=0;i<graph[pr].size();i++){ 				int ne=graph[pr][i]; 				if(marked[ne]==0){ 					marked[ne]=1; 					parent[ne]=pr; 					q.push(ne); 				} 			} 		} 		int present_ans=n; 		memset(marked,0,sizeof(marked)); 		gi(m); 		while(m--){ 			gi(p); 			int pr=p; 			while(pr!=-1 && marked[pr]==0){ 				marked[pr]=1; 				present_ans--; 				pr=parent[pr]; 			} 			printf("%d\n",present_ans); 		}  	} }
#include <bits/stdc++.h>   using namespace std;   typedef long long ll; typedef pair <int,int> pii; typedef vector <int> vi;   #define rep(i, n) for(int i = 0; i < (n); ++i)   #define pb push_back #define mp make_pair #define ff first #define ss second #define all(c) c.begin(), c.end() #define mset(a, v) memset(a, v, sizeof(a)) #define sz(a) ((int)a.size())   #define gi(x) scanf("%d", &x) #define pis(x) printf("%d ", x) #define pin(x) printf("%d\n", x) #define pnl printf("\n") #define dbn cerr << "\n" #define dbg(x) cerr << #x << " : " << (x) << " " #define dbs(x) cerr << (x) << " "   const int maxN = 101; const int maxM = 101;    const int inf = 0x3f3f3f3f;   struct Edge {   int u,v,flow,capacity;   Edge()   {    }   Edge(int u,int v,int flow,int capacity)   {     this->u=u;     this->v=v;     this->flow=flow;     this->capacity=capacity;    } };    vector<Edge> e; vector<vector<int> > G; int n,m; int source,sink; int dist[5001]; int ptr[5001];   bool findPath() {    memset(dist,-1,sizeof(dist));   dist[source]=0;   queue<int> Q;   Q.push(source);   while(!Q.empty())   {          int u=Q.front();     assert(dist[u]>=0);     // cout<<u<<endl;     Q.pop();      for (int i = 0; i < G[u].size(); ++i)         {       int ID=G[u][i];       // assert(u==e[ID].u);       int v=e[ID].v;        if( (dist[v]==-1) && e[ID].flow<e[ID].capacity)       {         // cout<<v<<endl;         dist[v]=dist[u]+1;         // cout<<dist[v]<<endl;         Q.push(v);         // if(v==sink)         //   return true;       }     }   }    return dist[sink]!=-1; }   int dfs(int u,int flow) {    if(flow==0)     return 0;   if(u==sink)     return flow;   for(;ptr[u]<G[u].size();++ptr[u])   {     int ID=G[u][ptr[u]];     int v=e[ID].v;          if(dist[v]!=dist[u]+1)       continue;          int pushed=dfs(v,min(flow,e[ID].capacity-e[ID].flow));     if(pushed)     {       e[ID].flow    +=pushed;       e[ID^1].flow  -=pushed;       return pushed;     }   }   return 0; } ll dinics() {   ll flow=0;   while(findPath())   {     memset(ptr,0,sizeof ptr);     while(int pushed=dfs(source,1e9))       flow+=pushed;   }   return flow; } void addEdge(int u,int v,int capacity) {     G[u].push_back(e.size());     e.push_back(Edge(u,v,0,capacity));     G[v].push_back(e.size());     e.push_back(Edge(v,u,0,0)); }   int main() {               int T;     gi(T);     int st[maxN], en[maxN];     int b[maxM], e[maxM], req[maxM];       rep (tc, T) {         int n, m;         gi(n), gi(m);           vi v;           rep (i, n) {             gi(st[i]), gi(en[i]);             v.pb(st[i]);             v.pb(en[i]);         }           rep (i, m) {             gi(b[i]), gi(e[i]), gi(req[i]);             v.pb(b[i]);             v.pb(e[i]);         }           sort(all(v));         v.resize(unique(all(v)) - v.begin());             int nodes = 2 + n + m + sz(v) - 1;         ::e.clear();         G.clear();         G.resize(nodes);               source = 0;         sink = nodes - 1;              rep (i, n) {             addEdge(source, i + 1, inf);               rep (j, sz(v) - 1) {                 if (v[j] >= st[i] and v[j + 1] <= en[i]) {                     addEdge(i + 1, n + 1 + j, (v[j + 1] - v[j]));                 }             }         }           rep (i, m) {             addEdge(n + 1 + sz(v) - 1 + i, sink, req[i]);               rep (j, sz(v) - 1) {                 if (v[j] >= b[i] and v[j + 1] <= e[i]) {                     addEdge(n + 1 + j, n + 1 + sz(v) - 1 + i, (v[j + 1] - v[j]));                 }             }         }           int flow = dinics();           int required = 0;         rep (i, m) required += req[i];           puts(flow == required ? "YES" : "NO");     }       return 0; } 
#include <iostream> #include <sstream> #include <fstream> #include <string> #include <vector> #include <deque> #include <queue> #include <stack> #include <set> #include <cstring> #include <list> #include <map> #include <algorithm> #include <functional> #include <utility> #include <bitset> #include <cmath> #include <cstdlib> #include <ctime> #include <cstdio> using namespace std; typedef long long          ll; typedef long double        ld; typedef pair<int,int>      pii; typedef pair<ll,ll>        pll; typedef vector<int>        vi; typedef vector<long long>  vll; #define mp                 make_pair #define pb                 push_back #define all(a)             a.begin(),a.end() #define sor(a)             sort(all(a)); #define rsor(a)            sor(a) reverse(all(a)); #define pr(n)              printf("%d ",n) #define s(n)               scanf("%d",&n) #define debug(a)           std::cerr<<#a<<"="<<(a)<<"\n" #define ss                 second #define ff                 first #define m0(x) 		   memset(x,0,sizeof(x)) #define snuke(c,itr)       for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++) const int mod=1e9+7; const long double PI = (long double)(3.1415926535897932384626433832795);  inline bool ispow2(int x){return (x!=0 && (x&(x-1))==0);} //0 or 1  template<class T> inline void cinarr(T a, int n){ for (int i=0;i<n;++i) cin >> a[i];}  inline ll powmod(ll a,ll b) {ll res = 1; while(b){if(b&1) res = (res*a)%mod;a = (a*a)%mod;b >>= 1;}return res;}  int fastMax(int x, int y) { return (((y-x)>>(32-1))&(x^y))^y; } int fastMin(int x, int y) { return (((y-x)>>(32-1))&(x^y))^x; }  inline ll gcd(ll a,ll b){ll t;while(b){a=a%b;t=a;a=b;b=t;}return a;} inline ll lcm(ll a,ll b){return a/gcd(a,b)*b;}  const int mx =1005; ll dp[mx+1][mx+1]; int main() {     ios_base::sync_with_stdio(false); cin.tie(0);      for(int i=1;i<mx;i++)     {         for(int j=0;j<=i;j++)         {             if(j==0)             {                 dp[i][j] = 0;             }             else if(j==i)             {                 dp[i][j] =  1;             }             else             {                 dp[i][j] = (dp[i-1][j-1] + (i-1) * dp[i-1][j]) % mod;             }          }     }     int t; cin>>t;     while(t--)     {         int n,k; cin>>n>>k;         cout<< dp[n][k] % mod <<"\n";     }     return 0; }  
#include <bits/stdc++.h> using namespace std;  char a[1001],b[65],c[65];  int main() { 	int t,i,n,carry,l,temp; 	long long int k; 	cin>>t; 	while(t--) 	{ 		cin>>a; 		cin>>k; 		n=strlen(a); 		i=0; 		while(i<n) 		{	a[i]=a[i]-'0'; 			i++; 		} 		i=0; 		while(k!=0) 		{	b[i] = k % 2; 			k = k/2; 			i++; 		} 		b[i]='\0'; 		l=0; 		while(l<i) 		{ 			c[l]=b[i-l-1]; 			l++; 		} 		c[l]='\0'; 		n--; 		i--; 		carry=0; 		if(n>i) 		{ 			l=n+1; 			while(i>=0) 			{	temp=(a[n]+c[i]+carry)%2; 				carry=(a[n]+c[i]+carry)/2; 				a[n]=temp; 				n--; 				i--; 			} 			while(n>=0 && carry==1) 			{ 				temp=(a[n] + carry)%2; 				carry=(a[n]+carry)/2; 				a[n]=temp; 				n--; 			} 			i=0; 			while(i<l) 			{ 				a[i]=a[i]+'0'; 				i++; 			} 			if(n<0 && carry == 1) 				cout<<"1"<<a<<endl; 			else 				cout<<a<<endl; 		} 		else 		{ 			l=i+1; 			while(n>=0) 			{	temp=(a[n]+c[i]+carry)%2; 				carry=(a[n]+c[i]+carry)/2; 				c[i]=temp; 				n--; 				i--; 			} 			while(i>=0 && carry==1) 			{ 				temp=(c[i] + carry)%2; 				carry=(c[i]+carry)/2; 				c[i]=temp; 				i--; 			} 			if(i<0 && carry==1) 				cout<<"1"; 			i=0; 			while(i<l) 			{ 				c[i]=c[i]+'0'; 				i++; 			} 			cout<<c<<endl; 		} 	} 	return 0; }
#include <bits/stdc++.h> using namespace std;  #define LL long long  const LL MOD  = 1e9 + 7; LL power(LL a, LL b, LL c) { 	LL ret=1;  	while(b) { 		if(b&1) { 			ret = (ret*a)%c; 		} 		a = (a*a)%c; 		b >>= 1; 	} 	return ret; }  int main() { 	int t; 	scanf("%d", &t); 	while(t--) { 		LL n, k; 		scanf("%lld %lld", &n, &k);  		if(k == 1) { 			printf("0\n"); 		} 		else if(k==2) { 			printf("2\n"); 		} 		else{ 			long long val = (k-1 + (k-2)*(k-2)) % MOD; 			val = power(val, n-1, MOD); 			val = (((val*k)%MOD)*(k-1))%MOD; 			printf("%lld\n", val); 		}    	} }
#include <iostream> using namespace std;  int main() {int t,i,j,flag,flag1; cin>>t; while(t--) {string s,s1; flag=0;flag1=1; cin>>s>>s1; j=0; for(i=0;i<s1.length();i++) {if(flag==0)     {if(s[j]==s1[i])         j++;         else         {flag=1;             j++;             i--;         }              }     else     {if(s[j]==s1[i])         j++;         else         {flag1=0;         break;}              }      }      if(flag1==0)     cout<<"0"<<"\n";     else     cout<<"1"<<"\n"; } 	// your code goes here 	return 0; } 
#include <bits/stdc++.h>  typedef long long ll; using namespace std; #define NMAX 2751001 /* set<int> A[NMAX];  void Union(set<int> &A,set<int> B) {     for(typeof(B.begin()) it=B.begin();it!=B.end();it++)     {         A.insert(*it);     } }  set<int> Add(set<int> A,set<int> B) {     set<int> C;     for(typeof(A.begin()) it1=A.begin();it1!=A.end();it1++)     {         for(typeof(B.begin()) it2=B.begin();it2!=B.end();it2++)         {             C.insert( (*it1)+(*it2) );         }     }     return C; }  set<int> Mul(set<int> A,int B) {     set<int> C;     for(typeof(A.begin()) it1=A.begin();it1!=A.end();it1++)     {         C.insert( (*it1)*B );     }     return C; } */  ll ModPow(ll a,ll x,ll p) {     ll res=1;     while(x>0)     {         if(x%2!=0)             res=(res*a)%p;         a=(a*a)%p;         x/=2;     }     return (res%p); }     bool p[NMAX]; vector<int> P; int main() {     ios_base::sync_with_stdio(false);     cin.tie(NULL);     int i,j,q,k;     fill(p,p+NMAX,true);     p[0]=p[1]=false;     for(i=2;i*i<NMAX;i++)     {         if(p[i])         {             for(j=i*i;j<NMAX;j+=i)             {                 p[j]=false;             }         }     }     for(i=2;i<NMAX;i++)     {         if(p[i])             P.push_back(i);     }     cin>>q;     while(q--)     {         cin>>k;         --k;         cout<<ModPow(P[k],P[k],1000000007)<<'\n';     }     P.clear();     /*A[1].insert(0);     for(i=2;i<NMAX;i++)     {         if(p[i])         {             A[i].insert(1);         }         else         {             for(j=2;j*j<=i;j++)             {                 if(i%j==0)                 {                     Union(A[i],Add( Mul(A[j],i/j),Mul(A[i/j],j) ) );                 }             }         }         if((int)A[i].size()==1)         {             if(*A[i].begin()==i)             {                 cout<<i<<' ';             }         }     }*/          return 0; }
#include<iostream> using namespace std; int main() {     int t,n,k,i,r;     cin>>t;     while(t--)     {               cin>>n>>k;               long long int r=1;               if(n-k<k)k=n-k;               for(i=0;i<k;)               {                            r=r*n--;                            r=r/++i;               }               cout<<r<<"\n";     } }                                                                                        
#include<iostream> using namespace std;  int main() {     int n,t,i,j,k,cvalue,rvalue,sum;     int **solution;     cin>>t;     solution=new int *[t];     for(i=0;i<t;i++)     {         cin>>n;         int **matrix;         matrix=new int *[n];         for(j=0;j<n;j++)         {             matrix[j]=new int[n];             for(k=0;k<n;k++)                 cin>>matrix[j][k];         }         rvalue=-2;         for(j=0;j<n;j++)         {             sum=0;             for(k=0;k<n;k++)                 sum+=matrix[j][k];             if(sum%2!=0)             {                 if(rvalue!=-2)                     rvalue=-1;                 else                     rvalue=j;              }          }         cvalue=-2;         for(j=0;j<n;j++)         {             sum=0;             for(k=0;k<n;k++)                 sum+=matrix[k][j];             if(sum%2!=0)             {                 if(cvalue!=-2)                     cvalue=-1;                 else                     cvalue=j;              }          }         if(rvalue==-1 || cvalue==-1)         {             solution[i]=new int[2];             solution[i][0]=1;             solution[i][1]=0;         }         else if(rvalue==-2 && cvalue==-2)         {             solution[i]=new int[2];             solution[i][0]=1;             solution[i][1]=1;         }         else if(rvalue==-2 || cvalue==-2)         {             solution[i]=new int[2];             solution[i][0]=1;             solution[i][1]=0;         }         else         {             solution[i]=new int[3];             solution[i][0]=2;             solution[i][1]=rvalue+1;             solution[i][2]=cvalue+1;         }      }      for(i=0;i<t;i++)     {         if(solution[i][0]==2)         {             cout<<"("<<solution[i][1]<<","<<solution[i][2]<<")";         }         else             cout<<solution[i][1];         cout<<"\n";     }     return 0;   } 
#include<stdio.h>  void sort(int *ar,int *ab) {  int i=ab-ar;  for(int j=0;j<i;j++)  for(int k=0;k<i-1;k++)  {   if(ar[k]>ar[k+1])   {    int temp;    temp=ar[k];    ar[k]=ar[k+1];    ar[k+1]=temp;    }  }  } int main() {  //clrscr();  int test;  scanf("%d",&test);  for(int j=0;j<test;j++)  {  int num;  scanf("%d",&num);  if(num==1)  {  printf("%d\n",num);  continue;  }  if(num<10)  {  printf("%d\n",num+10);  continue;}  int ar[20];  int ind=0;  int has=0;  while(num>1){  has=0;  int b[4]={2,3,5,7};  for(int ij=0;ij<4;ij++)  { int i=b[ij];   if(num%i==0)  { ar[ind++]=i;   num=num/i;   has=1;   }   if(num==1)   break;  }  if(has==0)  {   printf("%d\n",-10);   break;  }  }  if(has==0)  {   has=1;   continue;  }  int flag;  aa:  flag=0;  sort(ar,ar+ind); // getch(); if(ind>2)  for(int k=ind-1;k>0;k--)  {   if(ar[k]*ar[k-1]/10==0)   {   flag=1;   ar[k-1]=ar[k]*ar[k-1];   ar[k]=ar[ind-1];   ind--;   }  }  if(flag)  goto aa;   for(int y=0;y<ind;y++)  {  printf("%d",ar[y]);  }  printf("\n");  } // getch(); return 0; }
#include<iostream> #include<cstring>  using namespace std;  int main(void) { 	int i=-1,j,k,m,n,c; 	struct str 	{ char s[100]; 	  int len,mir,pal; 	}count; 	while(1) 	{ 	   cin>>count.s; 	   c=strcmp(count.s,"#"); 	   if(c==0) 		break; 	   else 	   { 		++i; 		count.len=strlen(count.s); 		count.pal=1; 		count.mir=1; 		if((count.len)%2==0) 		{ m=(count.len)/2; 		  n=m-1; 		} 		else 		{ m=((count.len)/2)-1; 		  n=m+2; 		} 		for(j=m,k=n;j>=0;j--,k++) 		{ if((count.s[j]=='A')&&(count.s[k]=='A')) 		  {}  		  else if((count.s[j]=='E')&&(count.s[k]=='3')) 		  {count.pal=0;} 		  else if((count.s[j]=='H')&&(count.s[k]=='H')) 		  {} 		  else if((count.s[j]=='I')&&(count.s[k]=='I')) 		  {} 		  else if((count.s[j]=='J')&&(count.s[k]=='L')) 		  {count.pal=0;} 		  else if((count.s[j]=='L')&&(count.s[k]=='J')) 		  { count.pal=0;} 		  else if((count.s[j]=='M')&&(count.s[k]=='M')) 		  {} 		  else if((count.s[j]=='O')&&(count.s[k]=='O')) 		  {} 		  else if((count.s[j]=='S')&&(count.s[k]=='2')) 		  {count.pal=0;} 		  else if((count.s[j]=='T')&&(count.s[k]=='T')) 		  {} 		  else if((count.s[j]=='U')&&(count.s[k]=='U')) 		  {} 		  else if((count.s[j]=='V')&&(count.s[k]=='V')) 		  {} 		  else if((count.s[j]=='W')&&(count.s[k]=='W')) 		  {} 		  else if((count.s[j]=='X')&&(count.s[k]=='X')) 		  {} 		  else if((count.s[j]=='Y')&&(count.s[k]=='Y')) 		  {} 		  else if((count.s[j]=='Z')&&(count.s[k]=='5')) 		  {count.pal=0;} 		  else if((count.s[j]=='1')&&(count.s[k]=='1')) 		  {} 	 	  else if((count.s[j]=='2')&&(count.s[k]=='S')) 	 	  {count.pal=0;} 		  else if((count.s[j]=='3')&&(count.s[k]=='E')) 		  {count.pal=0;} 		  else if((count.s[j]=='5')&&(count.s[k]=='Z')) 		  {count.pal=0;} 		  else if((count.s[j]=='8')&&(count.s[k]=='8')) 	 	  {} 		  else 		  {count.mir=0; 		   break; 		  } 		} 		if(count.pal!=0) 		{ for(j=m,k=n;j>=0;j--,k++) 		  { if(count.s[j]!=count.s[k]) 		    { count.pal=0; 		      break; 		    } 		  } 		} 		if((count.pal!=0)&&(count.mir!=0)) 			cout<<"mirroredpalindrome\n"; 		else if((count.pal!=0)&&(count.mir==0)) 			cout<<"regularpalindrome\n"; 		else if((count.pal==0)&&(count.mir!=0)) 			cout<<"mirroredstring\n"; 		else 			cout<<"notpalindrome\n"; 		} 	} return 0; }  
#include <cstdio> #include <cstring> #include <cassert>  using namespace std;  int dict[1001][26];  int main() { 	int dictSize = 0; 	 	char s[10]; 	while(true) 	{ 		scanf("%s", s); 		if (s[0] == '#') 			break; 		 		for (int i = 0; i < 26; ++i) 			dict[dictSize][i] = 0; 		 		int len = strlen(s); 		for (int i = 0; i < len; ++i) 			++dict[dictSize][s[i] - 'a']; 		++dictSize; 	} 	char tmp; 	scanf("%c", &tmp); // ignore \n 	assert(tmp == '\r'); 	 	bool exit = false; 	while(!exit) 	{ 		int available[26]; 		for (int i = 0; i < 26; ++i) 			available[i] = 0; 		while(true) 		{ 			char c; 			scanf("%c", &c); 			if (c == '#') 			{ 				exit = true; 				break; 			} 			else if (c == ' ') 				continue; 			else if (c == '\r') 				break; 			else 				++available[c - 'a']; 		} 		 		if (exit) 			break; 		 		int count = 0; 		for (int i = 0; i < dictSize; ++i) 		{ 			bool possible = true; 			for (int j = 0; j < 26; ++j) 			{ 				if (dict[i][j] > available[j]) 				{ 					possible = false; 					break; 				} 			} 			if (possible) 				++count; 		} 		 		printf("%d\n", count); 	} 	 	return 0; }
// Templar Test // http://www.codechef.com/problems/KC205/  #include <iostream> #include <cstdio> #include <cstring> #include <algorithm> #include <vector> #include <cmath>  using namespace std;  int main() { 	 int t; 	 scanf("%d",&t); 	 while(t--) 	 { 				  int n, m; 				  scanf("%d%d",&m,&n); 				  int c; 				  if(m % 2 != 0 && n % 2 != 0) 						 c = (n * m + 1) / 2; 				  else 						 c = n * m / 2;  					if(m == 2) 					{ 						  c = n / 4 * 4 + 2 * (n % 4); 						  if(n % 4 == 3)c -= 2; 	 	  			} 	 	  			 	 	  			if(n == 2) 	 	  			{ 						  c = m / 4 * 4 + 2 * (m % 4); 						  if(m % 4 == 3)c -= 2; 	 	  	  		} 	 	  	  		if(n == 1)c = m; 	 	  	  		if(m == 1)c = n; 	 	  	  		printf("%d\n", c);   	 } 	 	 return 0; } 
 // (c) agaurav77 #include <iostream> #include <map>          // find(), clear() #include <vector>       // push_back(), pop_back(), front(), back() #include <list>         // push_back(), pop_back(), front(), back() --- SEQUENTIAL ACCESS #include <queue>        // push(), pop(), front(), back() #include <utility>      // make_pair() #include <algorithm>    // sort() #include <cmath> #include <cstdio> #include <climits>      // inf, minf #include <cstdlib>      // malloc() #include <sstream> #include <string> #include <cstring>      // memset() #define mp make_pair #define pb push_back using namespace std;  #define inf INT_MAX #define minf INT_MIN #define t(N) scanf("%d", &N); #define f(i,a,b) for(int i=a;i <= b; ++i) #define str string #define ll long long  #define inMap(a,b) (a.find(b) != a.end()) #define lastOne(i) (i&(-i)) #define MAX 100005  int B2a[MAX], B2b[MAX],  B5a[MAX], B5b[MAX]; int N;  // create an update function void update(int *BIT, int i, int val) {   while (i < N+5) {     BIT[i] += val;     i = i+lastOne(i);   } }  // create a cumulative query function int query(int *BIT, int i) {   int sum = 0;   while (i > 0) {     sum += BIT[i];     i = i-lastOne(i);   }   return sum; }  // create a function to update over range void updateRange(int *BIT, int *off, int L, int R, int val) {   update(BIT, L, val);   update(BIT, R+1, -val);   update(off, L, val*(L-1));   update(off, R+1, -val*R); }  int bitquery(int *BIT, int *off, int i) {   return i*query(BIT, i)-query(off, i); }  int main() {   // take in the test cases   int T;   t(T);    while (T--) {     // take in N, Q     int Q;     t(N); t(Q);      // empty BIT     memset(B2a, 0, sizeof(int)*(N+5));     memset(B2b, 0, sizeof(int)*(N+5));     memset(B5a, 0, sizeof(int)*(N+5));     memset(B5b, 0, sizeof(int)*(N+5));      // insert into BIT     int tmp;     f(i, 1, N) {       t(tmp);       int pow2 = 0, pow5 = 0;       while (tmp > 0 && tmp%2 == 0) {tmp /= 2; pow2++;}       while (tmp > 0 && tmp%5 == 0) {tmp /= 5; pow5++;}       updateRange(B2a, B2b, i, i, pow2);       updateRange(B5a, B5b, i, i, pow5);     }      // handle queries     int num, L, R, val;     f(i, 0, Q-1) {       // sanity check       // print number of 2s and 5s for each index       //f(j, 1, N) {       //  cout << j << " -> " << bitquery(B2a, B2b, j)-bitquery(B2a, B2b, j-1)       //            << "    " << bitquery(B5a, B5b, j)-bitquery(B5a, B5b, j-1) << endl;       //}            t(num);       if (num == 1) {         t(L); t(R);         // find number of trailing zeroes in L,R         // find powers of 2, 5 and take min         printf("%d\n", min( bitquery(B2a,B2b,R)-bitquery(B2a,B2b,L-1),                           bitquery(B5a,B5b,R)-bitquery(B5a,B5b,L-1) ));       } else {         t(L); t(R); t(val);         int pow2 = 0, pow5 = 0;         while (val > 0 && val%2 == 0) {val /= 2; pow2++;}         while (val > 0 && val%5 == 0) {val /= 5; pow5++;}         updateRange(B2a, B2b, L, R, pow2);         updateRange(B5a, B5b, L, R, pow5);       }     }   }   return 0; }  
#include<bits/stdc++.h> using namespace std; int main() {    int t,i,n;    scanf("%d",&t);    while(t--)    {        int sum=0,v;        scanf("%d",&n);        int a[100];        char c[100];       for(i=0;i<26;i++)         scanf("%d",&a[i]);       scanf("%s",c);       int l=strlen(c);       int d[100];       for(i=0;i<l;i++)       {           v=c[i]-97;           d[i]=a[v];       }       sort(d,d+l);       for(i=0;i<l-n;i++)         sum+=d[i];       printf("%d\n",sum);    }    return 0; } 
#include<iostream>   using namespace std;   int main() {     int a[500002],n,i,j,temp,t;     cin>>t;     while(t--)     {     cin>>n;     for(i=0;i<n;++i)         cin>>a[i];         int count=0;              for(i=1;i<n;++i)     {         for(j=0;j<(n-i);++j)             if(a[j]>a[j+1])             {   count++;                 temp=a[j];                 a[j]=a[j+1];                 a[j+1]=temp;             }     }          cout<<count<<endl;     }              return 0; }
#include<bits/stdc++.h> using namespace std; vector<int> G[1000]; int dist[1000]; bool visit[1000]; void dfs(int u,int v,int d) {     visit[u]=true;       //dist[u]=d;       if(u==v)         cout<<d<<endl;       for(int i=0;i<G[u].size();i++)       {             int x=G[u][i];             if(!visit[x])             dfs(x,v,d+1);       } } int main() {     int t;     cin>>t;     while(t--)     {         int n,f;         cin>>n>>f;         string s;         for(int i=0;i<1000;i++)          G[i].clear();         for(int i=0;i<n;i++)         {             cin>>s;             for(int j=0;j<n;j++)             {                 if(s[j]=='1')                 {                     G[i].push_back(j);                 }             }         }         /*         for(int i=0;i<n;i++)         {             for(int j=0;j<G[i].size();j++)             {                 cout<<G[i][j]<<" ";             }             cout<<endl;         }         */        memset(visit,false,sizeof visit);         dfs(0,f,0);        // cout<<dist[f-1]<<endl;     } } 
//KGP13A #include<cstdio> #include<iostream> #include<vector> #include<algorithm>  using namespace std;  vector< vector<int> > path(vector< vector<int> > adjmat) {     int n=static_cast<int>(adjmat[0].size());     vector< vector<int> > dprev(n,vector<int> (n));     copy(adjmat.begin(),adjmat.end(),dprev.begin());     for(int k=1;k<n;k++)     {         vector< vector<int> > dnext(n,vector<int> (n));         for(int i=1;i<n;i++)         {             for(int j=1;j<n;j++)             {                 //dnext[i][j]=min(dprev[i][j],dprev[i][k]+dprev[k][j]);                 if(dprev[i][j]==-1 && (dprev[i][k]==-1 || dprev[k][j]==-1))                 {                     dnext[i][j]=-1;                 }                 else if(dprev[i][j]==-1)                 {                     dnext[i][j]=dprev[i][k]+dprev[k][j];                 }                 else if(dprev[i][k]==-1 || dprev[k][j]==-1)                 {                     dnext[i][j]=dprev[i][j];                 }                 else                 {                     dnext[i][j]=min(dprev[i][j],dprev[i][k]+dprev[k][j]);                 }             }         }         copy(dnext.begin(),dnext.end(),dprev.begin());     }     return dprev; } int main() {     //freopen("KGP13A.txt","r",stdin);     int t;     cin>>t;     int n=t;     while(t--)     {         int k;         cin>>k;         vector<vector<int> > adjmat(k+1,vector<int> (k+1,-1));         vector<int> connected;         for(int i=0;i<=k;i++)         {             adjmat[i][i]=0;         }         for(int i=1;i<=k;i++)         {             int u=i;             int no,isconnected;             cin>>isconnected>>no;             if(isconnected==1)             {                 connected.push_back(i);             }             for(int j=1;j<=no;j++)             {                 int v,weight;                 cin>>v>>weight;                 adjmat[u][v]=weight;             }         }         vector< vector<int> > shortestPathmat;         shortestPathmat=path(adjmat);         /*         for(int i=1;i<=k;i++)         {             for(int j=1;j<=k;j++)             {                 printf("%d ",shortestPathmat[i][j]);             }             printf("\n");         }         */         int connectlen=static_cast<int>(connected.size());         int ans=-1;         for(int i=0;i<connectlen;i++)         {             for(int j=i+1;j<connectlen;j++)             {                 int u=connected[i];                 int v=connected[j];                 int totalans=0;                 for(int x=1;x<=k;x++)                 {                     if(shortestPathmat[u][x]+shortestPathmat[x][v]==shortestPathmat[u][v])                     {                         continue;                     }                     int mini=-1;                     for(int y=1;y<=k;y++)                     {                         if(shortestPathmat[u][y]+shortestPathmat[y][v]==shortestPathmat[u][v])                         {                             if(mini==-1)                             {                                 mini=shortestPathmat[x][y];                             }                             else                             {                                 mini=min(shortestPathmat[x][y],mini);                             }                         }                     }                     totalans+=mini;                 }                 if(ans==-1)                 {                     ans=totalans;                 }                 else                 {                     ans=min(totalans,ans);                 }             }         }         printf("Case %d: %d\n",n-t,ans);     } } 
#include<iostream> #define MAX 40 using namespace std; struct job { 	int s,f,pay; }JOB[MAX],temp; int main() { 	int T,c,i,j,K,M,D,k,result,m1,m2,t; 	cin>>T; 	for(c =1;c<=T;c++) 	{ 		cin>>K>>M; 		m1=m2=0; 		for(i=1;i<=K;i++) 		{ 			cin>>JOB[i].s>>JOB[i].f; 			JOB[i].pay=0; 			if(m1>JOB[i].s || m1==0) 				m1=JOB[i].s; 			if(m2<JOB[i].f) 				m2 = JOB[i].f; 		} 		 		for(i=0;i<M;i++) 		{ 			cin>>D; 			while(D--) 			{ 				cin>>j>>k; 				JOB[j].pay +=k; 			} 		} 		for(i=1;i<=K;i++) 		{ 			j= i-1; 			temp = JOB[i]; 			while(j>=0 && JOB[j].s >= temp.s) 			{ 				JOB[j+1]=JOB[j]; 				j--; 			} 			JOB[j+1]= temp; 		} 		result =0; 		for(i=m1;i<=m2;i++) 		{ 			t = 0; 			for(j=1;j<=K;j++) 			{ 				if(JOB[j].s <=i && JOB[j].f>=i) 					t+=JOB[j].pay; 				else if(JOB[j].s > i) 					break; 			} 			if(t>result) 				result = t; 		} 		cout<<"Case "<<c<<": "<<result<<endl; 	} 	return 0; }
#include <algorithm> #include <vector> #include <cstdio> #include <iostream> #include <cstring> using namespace std; const int MaxK = 201; int br = 0; int dp[MaxK][MaxK], next1[MaxK]; int time1[MaxK], cost[MaxK], prev1[MaxK], k, n, ce, t, tt; int preffix[MaxK][MaxK], sum; bool used[MaxK]; int x[MaxK][MaxK]; int cnt[MaxK], pr, dr, now[MaxK][MaxK];  void prepare(int n, int m) {   int sum = 0; time1[0] = 0;   for (int i=0; i<=cnt[n]; i++)   {     sum += time1[x[n][i]];     int sum1 = 0;      for (int j=0; j<=cnt[m]; j++)     {       sum1 += time1[x[m][j]];       preffix[i][j] = sum + sum1;     }   }    memset(dp, 0, sizeof(dp));   sum = 0;   int tt = 0;    for (int i=1; i<=cnt[n]; i++)   {     tt = preffix[i][0];     dp[i][0] = dp[i-1][0] + tt * cost[x[n][i]];   }    sum = 0;   tt = 0;    for (int j=1; j<=cnt[m]; j++)   {     tt = preffix[0][j];     dp[0][j] = dp[0][j-1] + tt * cost[x[m][j]];   }  //cout << cnt[n] << " " << cnt[m] << endl; /*   for (int i=0; i<=cnt[n]; i++)     for (int j=0; j<=cnt[m]; j++)   {    if (j!=cnt[m]) cout << dp[i][j] <<  " ";    else cout << dp[i][j] << endl;   } */ }  void update(int a, int b, int n, int m) {   cnt[1] = sum;   while (sum > 0)   {     if (((n>0) && (now[n][m] == 1)) || (m == 0))     {       x[1][sum] = x[a][n];       n--;     }     else     {       x[1][sum] = x[b][m];       m--;     }    sum --;   } }  int rek(int a, int b) {    if (dp[a][b] > 0) return dp[a][b];     int sum1 = rek(a-1, b) + preffix[a][b] * cost[x[pr][a]];    int sum2 = rek(a, b-1) + preffix[a][b] * cost[x[dr][b]];     if (sum1 < sum2)    {      dp[a][b] = sum1;      now[a][b] = 1;    }    else    {      dp[a][b] = sum2;      now[a][b] = 2;    }    return dp[a][b]; }  int main() {  scanf("%d", &t);   while (t--)  {   ce ++;   br = 0;   scanf("%d", &k);   memset(x, 0, sizeof(x));   memset(next1, 0, sizeof(next1));   memset(prev1, 0, sizeof(prev1));   memset(cnt, 0, sizeof(cnt));   memset(used, false, sizeof(used));   memset(preffix, 0 ,sizeof(preffix));   int i;    for (i=1; i<=k; i++)     scanf("%d", &time1[i]);   for (i=1; i<=k; i++)     scanf("%d", &cost[i]);   for (i=1; i<=k; i++)   {     next1[i] = i;     prev1[i] = i;   }    scanf("%d", &n);    for (i=1; i<=n; i++)   {     int a, b;     scanf("%d%d", &a, &b);     next1[b] = a;     prev1[a] = b;   }    for (i=1; i<=k; i++)   {    if (!used[i])    {      br ++;      int a = next1[i];      while (a != next1[a]) a = next1[a];       while (1 == 1)      {       x[br][++cnt[br]] = a;       used[a] = true;       if (a == prev1[a]) break;       a = prev1[a];      }    }   }   int k1, k2;   if (br == 1)  {    tt = 0;    sum = 0;    for (i=1; i<=k; i++)    {      tt += time1[x[1][i]];      sum += (tt * cost[x[1][i]]);    }    cout << "Case "<< ce << ": " << sum << endl;    continue;  }   for (i=2; i<=br; i++)  {   pr = 1; dr = i;   k1 = cnt[pr]; k2 = cnt[dr];   prepare(pr, dr);   rek(cnt[pr], cnt[dr]);   sum = cnt[pr] + cnt[dr];   update(pr, dr, cnt[pr],cnt[dr]);  }   cout << "Case " << ce << ": " << dp[k1][k2] << endl;    } } 
#include<iostream> #include<string> #include<algorithm> #include<stdio.h> #include<queue> #include<vector> #include<stack> #include<cstdlib> #include<sstream> #include<cassert> #include<fstream> #include<ctime> #include<list> #include<cmath> #include<set> #include<map> #include<cstring>  using namespace std;  #define s(n)					scanf("%d",&n) #define sl(n) 					scanf("%lld",&n) #define sf(n) 					scanf("%lf",&n) #define ss(n) 					scanf("%s",n) #define INF						(int)1e9 #define LINF					(long long)1e18 #define EPS						1e-9 #define maX(a,b)				((a)>(b)?(a):(b)) #define miN(a,b)				((a)<(b)?(a):(b)) #define abS(x)					((x)<0?-(x):(x)) #define FOR(i,a,b)				for(int i=a;i<=b;i++) #define rep(i,n)				FOR(i,0,n-1) #define foreach(v,c)            for( typeof((c).begin()) v = (c).begin();  v != (c).end(); ++v) #define mp						make_pair #define FF						first #define SS						second #define XX						first #define YY						second.first #define ZZ						second.second #define pb						push_back #define fill(a,v) 				memset(a,v,sizeof(a)) #define all(x)					x.begin(),x.end() #define sz(v)					((int)(v.size())) #define INDEX(arr,ind)			(lower_bound(all(arr),ind)-arr.begin())  typedef long long int lli; typedef pair<int,int> pii; typedef pair<lli,lli> pll; typedef vector<int> vi; typedef vector<lli> vlli; typedef vector<pii> vii;  const int MAXN = 2000015; const int MOD  = 1000000007;  /*Main code begins now */ int k; inline pii ch1(int id) { 	return mp((id)/k,(id)%k); } inline int ch2(pii p) { 	return (p.FF*k+p.SS); } int main() { 	int t,m,x,y,s1; 	#ifndef ONLINE_JUDGE 	freopen("input.txt","r",stdin); 	#endif	 	s(t); 	vi F; 	rep(z,t) 	{ 		F.clear(); 		s(k); 		k++; 		s(s1); 		s(m); 		rep(i,m) 		 { 		 	s(x); 		 	F.pb(x); 		 } 		pii s = ch1(s1); 		x = s.FF,y=s.SS; 		int ans = 0;  		rep(i,sz(F)) 		{ 			s = ch1(F[i]); 			ans+=abS(x-s.FF) + abS(y-s.SS) -1; 		} 		// rep(i,k*k) 		// { 		// 	s = ch1(i); 		// 	cout<<" "<<s.FF<<" "<<s.SS<<endl; 		// } 		// cout<<" ----- \n"; 		// rep(i,k) 		// { 		// 	rep(j,k) 		// 	{ 		// 		cout<<" "<<ch2(mp(i,j)); 		// 	} 		// 	cout<<endl; 		// } 		printf("Case %d: %d\n",z+1,ans); 		rep(i,k) 		{ 			rep(j,k) 			{ 				if(i<k-1) 				{ 					if(j==y) 					{ 						if(i<x) 						{ 							printf("%d %d 1\n",ch2(mp(i,j)),ch2(mp(i+1,j)));	 						} 						else 						{ 							printf("%d %d 0\n",ch2(mp(i,j)),ch2(mp(i+1,j)));		 						} 					} 					else if(j==0 || j==k-1) 					{ 						if(i<x) 						{ 							printf("%d %d 0\n",ch2(mp(i,j)),ch2(mp(i+1,j)));	 						} 						else 						{ 							printf("%d %d 1\n",ch2(mp(i,j)),ch2(mp(i+1,j)));		 						} 					} 					else 					{ 						if(i<x) 						{ 							printf("%d %d 1\n",ch2(mp(i,j)),ch2(mp(i+1,j)));	 						} 						else 						{ 							printf("%d %d 0\n",ch2(mp(i,j)),ch2(mp(i+1,j)));		 						} 					} 				} 				if(j<k-1) 				{ 					if(i==x) 					{ 						if(j<y) 						{ 							printf("%d %d 0\n",ch2(mp(i,j)),ch2(mp(i,j+1)));				 						} 						else 							printf("%d %d 1\n",ch2(mp(i,j)),ch2(mp(i,j+1)));					 					} 					else 					{ 						if(j<y) 						{ 							printf("%d %d 1\n",ch2(mp(i,j)),ch2(mp(i,j+1)));				 						} 						else 						{ 							printf("%d %d 0\n",ch2(mp(i,j)),ch2(mp(i,j+1)));					 						} 					} 				} 				  			} 		} 	} 	return 0; } 
#include<cstdio> #include<cstring> #include<cstdlib> #include<vector> #include<algorithm> #include<cmath> #include<stack> #include<queue> #include<iostream> #include<climits> #include<set> #include<map> #include<deque> #include<list> #include<string> #include<utility> #include<numeric> #include<iterator> #include<cctype> #include<ctime>  using namespace std;   #define fr(i,a,b) for(i=a;i<=b;i++) #define SI(a) scanf("%d",&a) #define SLL(a) scanf("%lld",&a) #define SL(a) scanf("%ld",&a) #define SF(a) scanf("%f",&a) #define MOD 1000000007 #define llu long long unsigned #define lld long long #define ld long  #define all(c)  c.begin(), c.end() #define tr(c, it)   for(typeof(c.begin()) it = c.begin(); it != c.end(); it++) #define pb push_back #define mp  make_pair  #define MIN(a, b)   ((a) < (b) ? (a) : (b)) #define MIN3(a, b, c)   ((MIN((a), (b)) > (c)) ? (c) : (MIN((a), (b)) #define INF INT_MAX #define MINF INT_MIN       //fast input   int scan_d()    {int ip=getchar(),ret=0,flag=1;for(;ip<'0'||ip>'9';ip=getchar())if(ip=='-'){flag=-1;ip=getchar();break;}for(;ip>='0'&&ip<='9';ip=getchar())ret=ret*10+ip-'0';return flag*ret;} ld scan_ld()    {int ip=getchar(),flag=1;ld ret=0;for(;ip<'0'||ip>'9';ip=getchar())if(ip=='-'){flag=-1;ip=getchar();break;}for(;ip>='0'&&ip<='9';ip=getchar())ret=ret*10+ip-'0';return flag*ret;} lld scan_lld()    {int ip=getchar(),flag=1;lld ret=0;for(;ip<'0'||ip>'9';ip=getchar())if(ip=='-'){flag=-1;ip=getchar();break;}for(;ip>='0'&&ip<='9';ip=getchar())ret=ret*10+ip-'0';return flag*ret;} llu scan_llu()    {int ip=getchar();llu ret=0;for(;ip<'0'||ip>'9';ip=getchar());for(;ip>='0'&&ip<='9';ip=getchar())ret=ret*10+ip-'0';return ret;}   //end of fast input   //fast output   //no line break void print_d(int n)     {if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[10];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<10);} void print_ld(ld n)     {if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[11];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} void print_lld(lld n)     {if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);} void print_llu(llu n)     {int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<21);}   //new line void println_d(int n)     {if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} void println_ld(ld n)     {if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);} void println_lld(lld n)     {if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} void println_llu(llu n)     {int i=21;char output_buffer[22];output_buffer[21]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);}   //special char char sp; void printsp_d(int n)     {if(n<0){n=-n;putchar('-');}int i=10;char output_buffer[11];output_buffer[10]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<11);} void printsp_ld(ld n)     {if(n<0){n=-n;putchar('-');}int i=11;char output_buffer[12];output_buffer[11]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<12);} void printsp_lld(lld n)     {if(n<0){n=-n;putchar('-');}int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);} void printsp_llu(llu n)     {int i=21;char output_buffer[22];output_buffer[21]=sp;do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar(output_buffer[i]);}while(++i<22);}   //end of fast output  template<class T> T mymax(T a,T b) {     return a>b?a:b; } template<class T> T mymin(T a,T b) {     return a<b?a:b; }  int linepoints(int x1,int y1,int x2,int y2) {  	float f;   int n=mymax(y1-y2,y2-y1),d=mymax(x1-x2,x2-x1),count=0,i; 	fr(i,mymin(x1,x2)+1,mymax(x1,x2)-1) 	{ 		if((n*i)%d==0)count++; 	} 	return count; }  int gcd(int a, int b) {     return (b==0)?a:gcd(b, a%b); }   int gcd2(int a, int b) {     if(!a) return b+1;     if(!b) return a+1;     return gcd(a, b)+1; }   int main() { 	int T,t;               int i,b; int p1,p2,p3,p4;  float a; 	SI(T); 	t=T; 	while(T--) 	{ 	int X[5],Y[5]; 	fr(i,1,4){SI(X[i]);SI(Y[i]);}     a=0.5*(fabs( (X[1]*Y[2] - X[2]*Y[1]) + (X[2]*Y[3] - X[3]*Y[2]) + (X[3]*Y[4] - X[4]*Y[3]) + (X[4]*Y[1]-X[1]*Y[4]) ) );     p1=linepoints(X[1],Y[1],X[2],Y[2]);     p2=linepoints(X[2],Y[2],X[3],Y[3]);     p3=linepoints(X[3],Y[3],X[4],Y[4]);     p4=linepoints(X[4],Y[4],X[1],Y[1]);      p1= gcd2(abs(X[2]-X[1]), abs(Y[2]-Y[1]));     p2= gcd2(abs(X[3]-X[2]), abs(Y[3]-Y[2]));     p3= gcd2(abs(X[4]-X[3]), abs(Y[4]-Y[3]));     p4= gcd2(abs(X[1]-X[4]), abs(Y[1]-Y[4]));     b=p1+p2+p3+p4-4;     //printf("%f %d %d",a,(int)(a+1-b/2),b);     i=(int)(a+1-(float)b/2);     printf("Case %d: %d\n",t-T,i+b);     }     return 0; } 
#include <cstring> #include <iostream> #include <stdio.h> #include <cstdlib> #include <cctype> #include <algorithm> #include <map> #include <vector> #include <list> #include <set> #include <queue> #include <deque> #include <stack> #include <bits/stdc++.h> #include <string> #include <cmath> using namespace std; #define pb push_back #define mp make_pair #define mod 1000000007 #define ll long long #define int long long #define ff first #define ss second #define inf  1e9 #define infll 1e18 #define pr(x) printf("%lld\n",x) #define prs(x) printf("%lld ",x) #define sc(x) scanf("%lld",&x) #define trc(x) cout << #x << " = " << x << endl #define pii pair<int,int> #define fr(i,a,n) for(i=a;i<n;i++) #define fd(i,a,n) for(i=n;i>a;i--) #define fiv(v) for(i=0;i<v.size();i++) #define clr(a) memset(a,0,sizeof(a)) #define fill(a,v) memset(a,v,sizeof(a)) #define all(a) a.begin(),a.end() #define iter(c,it) for(typeof((c).begin()) it= (c).begin(); it != (c).end(); it++) ll dp[1005]; set<string>st; map<char,int>map1; vector<char>c1; ll solve(ll idx,ll n,string s) {    if(idx>=n)return 0;    if(dp[idx]!=-1)return dp[idx];    ll res=mod,f=0;    if(st.count(s))     f=1;    else f=0;    res=min(res,f+solve(idx+1,n,s+c1[idx]));    return res; } main() {     int i,n,j,k,l,m,t,c=0,ans,x;     sc(t);     fr(x,1,t+1)     {       sc(n);       st.clear();       string s;       vector<string>v;       fr(i,0,n)       {           cin>>s;           v.pb(s);       }       fr(i,0,10)       {           sc(l);           sc(k);           char ch;           fr(j,0,k)           {               cin>>ch;               map1[ch]=i;           }       }        fr(i,0,v.size())       {          s=v[i];          fr(j,0,s.size())          {              s[j]=map1[s[j]]+'0';          }          st.insert(s);       }       sc(n);       c1.clear();       fill(dp,0);       fr(i,0,n)       {          char ch;          cin>>ch;          c1.pb(ch);       }      for(i=1;i<=n;i++)       {           string s1="";           dp[i]=mod;           for(j=0;j<i;j++)           {               s1+=string(1,c1[j]);           }           for(j=0;j<i;j++)           {              if(st.count(s1)&&dp[j]!=mod)                 dp[i]=min(dp[i],dp[j]+1);              s1.erase(s1.begin());           }       }      // c=solve(0,n,"");      c=((dp[n]==mod)?0:dp[n]);       printf("Case %lld: %lld\n",x,(c==0)?-1:c);      }     return 0; } 
#include <iostream> #include <cstring> #include <queue> #include <vector>  using namespace std;  int cap[501][501]; int n, k; int val;  int maxflow() {     bool flow = true;     int ans = 0;     while(flow) {         flow = false;         queue<int> pq;         vector<int> vis(n+k+2);         pq.push(0);         int from[n+k+2];         memset(from, -1, sizeof(from));         while(!pq.empty())         {             int pos = pq.front();             pq.pop();             vis[pos] = 1;             if(pos == n+k+1) break;             for(int i = 0; i < n+k+2; i++) {                 if(cap[pos][i] && !vis[i]) {                     pq.push(i);                     from[i] = pos;                 }             }         }          if(vis[n+k+1]) flow = true;         else break;         int pos = n+k+1;         while(pos != 0) {             cap[from[pos]][pos]--;             cap[pos][from[pos]]++;             pos = from[pos];         }         ans++;     }     return ans; }  int main() {     int t;      cin >> t;     int cs = 0;     while(t--) {         cin >> n >> k;         memset(cap, 0, sizeof(cap));         for(int i = 0; i < n; i++) {             cin >> val;             cap[0][i+1] = val;             cap[i+1][0] = 0;             cap[i+1][n+k+1] = 1;             cap[n+k+1][i+1] = 0;         }         cs++;         for(int i = 0; i < k; i++) {             for(int j = 0; j < n; j++) {                 cin >> val;                 if(!val) {                     cap[j+1][n+i+1] = 1;                 }                 else cap[i+n+1][j+1] = val-1;             }         }          cout << "Case " << cs << ": " << maxflow() << endl;     } } 
#include <iostream> #include <vector> #include <algorithm> #include <cmath> #include <queue> #include <set> #include <cstdio> #include <cstdlib> #include <stack> #include <cstring> #include <iomanip> #include <cctype> #include <map> #include <cassert>   using namespace std;   int dp[105][105];   void solve(int t) {     int k,l; cin>>k>>l;     string a,b; cin>>a>>b;     int x,y; cin>>x>>y;     for(int i = 1;i <= k;i++) {         dp[i][0] = x + i;     }     for(int i = 1;i <= l;i++) {         dp[0][i] = min(x + i,y);     }     for(int i = 1;i <= k;i++) {         for(int j = 1;j <= l;j++) {             dp[i][j] = dp[i - 1][j - 1] + (a[i - 1] != b[j - 1]);             for(int  c = 1;c <= i;c++) {                 dp[i][j] = min(dp[i][j],dp[i - c][j] + c + x);             }             for(int c = 1;c <= j;c++) {                 dp[i][j] = min(dp[i][j],dp[i][j - c] + min(c + x,y) );             }         }     }     cout<<"Case "<<t<<": "<<dp[k][l]<<endl; }   int main() {     int t; cin>>t;     for(int i = 1;i <= t;i++) {         solve(i);     } } 
#include <iostream> #include <vector> #include <algorithm> #include <string> #include <cstdio> #include <cassert> #include <cmath> #include <time.h>  #define boost ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0) #define max(a,b) ((a)>(b)?a:b) #define min(a,b) ((a)<(b)?a:b) #define min_3(a,b,c) (min((a),min((b),(c)))) #define INF 1000000007  using namespace std;  int main() { 	boost; 	vector<int> v1; 	vector<int> v2; 	int tc; 	int n,k,key; 	cin >> tc; 	int count = 0; 	while (tc--) { 		v1.clear(); 		v2.clear(); 		long long sum = 0; 		cin >> n; 		for(int i = 0 ; i < n ; i++) { 			cin >> k; 			v1.push_back(k); 		} 		for (int i = 0; i < n; i++) { 			cin >> key; 			v2.push_back(key); 		} 		sort(v1.begin(),v1.end()); 		sort(v2.begin(),v2.end()); 		for (int i = 0; i < n; i++) { 			sum += fabs(v1[i]-v2[i]); 		} 		count++; 		cout << "Case "<<count<<": "<<sum<<endl; 	} }
/* Author : RISHAV GOYAL */  #include <bits/stdc++.h>  using namespace std;  #define LL long long int #define UL unsigned long long int  #define FOR(i,a,b) for(int i= (int)a; i<= (int)b; i++) #define rep(i,n) for(int i= int(1); i<= (int)n; i++) #define FORd(i,a,b,d) for(int i=(int)a; i<= (int)b; i+=(int)d)  #define pr() printf("Reached here 1...\n"); #define pr1() printf("Reached here 2...\n"); #define gc getchar_unlocked  #define si(a) scanf("%d",&a); #define sl(a) scanf("%lld",&a); #define ss(a) scanf("%s",a); #define sc(a) scanf("%c",&a); #define su(a) scanf("%llu",&a);  #define pi(a) printf("%d\n",a); #define pl(a) printf("%lld\n",a); #define ps(a) printf("%s\n",a); #define pu(a) printf("%llu\n",a);  #define arg(a,N) rep(i,N)si(a[i]);  #define CLR(a) memset(a,0,sizeof(a)); #define SET(a) memset(a,-1,sizeof(a));  #define str strlen #define pb(x) push_back(x) #define mp make_pair #define ii pair<int,int> #define gcd(a,b) __gcd(a,b)  #define mod int(1e9 +7) #define MAX int(1e5 + 10)  #define VI vector<int> #define VL vector<LL> #define VS vector<string> #define VC vector<char>   int gcd ( int a, int b ){int c;while(a!= 0){c=a;a=b%a;b=c;}return b;} LL powmod(LL a,int b,int n){LL rm=1;while (b){if (b % 2) { rm = (rm * a) % n; }a = (a * a) % n;b /= 2;}return rm;}  void sint(int &x) { 	register int c = gc(); 	x = 0; 	for(;(c<48 || c>57);c = gc()); 	for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} }  void sll(LL &x) { 	register LL c = gc(); 	x = 0; 	for(;(c<48 || c>57);c = gc()); 	for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} }  int dp[1010][1010];  int main() { 	string A,B; 	int la,lb,pos[300],T; 	cin >> T; 	FOR(ts,1,T){ 		CLR(dp); 		cin >> la >> lb >> A >> B; 		for(int i=1;i<=la;++i){ 			SET(pos); 			for(int j=1;j<=lb;++j){ 				dp[i][j] = dp[i-1][j]; 				pos[B[j-1]] = j; 				if( pos[A[i-1]] != -1){ 					dp[i][j] = max ( dp[i][j], 1 + dp[i-1][pos[A[i-1]]-1]); 				} 			} 		} 		cout << "Case "<<ts<<": "<<la + lb - dp[la][lb] <<endl; 	} 	return 0; } 
#include <stdio.h> #include <stdlib.h> #include <iostream> #include <string.h> #include <algorithm> #include <math.h> #include <vector> #include <queue> #include <set> #include <stack> #include <map> #define INF_MAX 2147483647 #define INF_MIN -2147483647 #define INF_LL 9223372036854775807LL #define INF 2000000000 #define PI acos(-1.0) #define inf INT_MAX #define llu unsigned long long int #define all(v) v.begin(),v.end() #define pb push_back #define mp make_pair #define F first #define S second #define si(n) scanf("%d",&n) #define slli(n) scanf("%lld",&n); #define ss(n) scanf("%s",n); using namespace std; typedef long long int LL;  pair<int , int > ppp[110]; int dp[104][(24*70)] , N;   int func(int index , int start_time) {   	if(index==0) 		return 0;  	if(dp[index][start_time]!=-1) 		return dp[index][start_time];  	if(ppp[index].first==-1)	//assign ith candidate for the interview 	{ 		dp[index][start_time] =  1  + func(index-1 , start_time); 	}   	if(start_time + ppp[index].second +30 <= ppp[index].first)	//assign ith candidate for the interview 		dp[index][start_time] = max(dp[index][start_time] , 1 + func(index-1 , start_time + ppp[index].second));  	//do not assign ith candidate for the interview 	dp[index][start_time] = max(dp[index][start_time] , func(index-1 , start_time));  	return dp[index][start_time];  }   int main() { int test; si(test);  for(int o=1;o<=test;o++) { memset(dp , -1 , sizeof(dp)); si(N); for(int i=1;i<=N;i++) 	si(ppp[i].second); for(int i=1;i<=N;i++){ 	si(ppp[i].first); } sort(ppp + 1 , ppp + N + 1); //but we have to sort in decreasing order reverse(ppp+1 , ppp+N+1);  // cout  << "Case " << o << << N - func(N , 0) << endl; printf("Case %d: %d\n",o ,  N - func(N , 0)); }  return 0; }             
# include <iostream> # include <fstream> # include <sstream> # include <algorithm> # include <cstdio> # include <cmath> # include <numeric> # include <cstdlib> # include <cstring> # include <vector> # include <list> # include <set> # include <map> # include <stack> # include <queue> # include <cctype> # include <climits> # include <complex>  using namespace std;  typedef long long LL; typedef unsigned long long ULL; typedef pair<int,int> PII; typedef vector<int> VI; typedef vector<VI> VVI; typedef pair<int,PII> TRI; typedef vector<string> VS;  #define REP(i,a,b) for(int i=a;i<b;i++) #define FOR(i,n) REP(i,0,n) #define ALL(v) (v).begin(),(v).end() #define TR(i,x) for(typeof(x.begin()) i=x.begin();i!=x.end();i++) #define bitcount(x) __builtin_popcount(x) #define pb push_back #define mp make_pair #define mt(a,b,c) mp(a,mp(b,c)) #define EPS (double)(1e-9) #define INF 1000000000 #define MOD 1000000007 #define PI (double)(3.141592653589793)  inline int inp() {     register int r=0,c;     for(c=getchar_unlocked(); c<=32; c=getchar_unlocked());     if(c=='-')         return -inp();     for(; c>32; r=(r<<1)+(r<<3)+c-'0',c=getchar_unlocked());     return r; }  long long int ans; double i,j,x,l,m1,inc; int x1,x2,y11,y2; int main() {      int t,k,X=0;     t = inp();     while(t--)     {X++;         ans=0;         k=inp();         x1=inp();         y11=inp();         x2=inp();         y2=inp();         int diffx=abs(x2-x1);        int diffy=abs(y2-y11);        if(x2>x1)        {            i=(double)x1+0.5;            inc=0.5;         }         else         {             i=(double)x1-0.5;             inc=-0.5;         }         l=(double)(y2-y11);          if((x2-x1)!=0 && (y2-y11)!=0)         {         l=l/(double)(x2-x1);             int cnt=0;         for(;(inc>0)?(i<(double)x2):(i>(double)x2); i+=inc*2)         {             j=(double)y11 + (l)*(i-(double)x1);                 x=j-floor(j);                if(abs(x-0.5)<1e-6)                     cnt++;         }         ans=diffx;         ans+=diffy;         ans+=cnt;         ans+=1;         printf("Case %d: %lld\n",X,ans);         }         else         printf("Case %d: %lld\n",X,abs(x2-x1)+abs(y2-y11)+1);     }     return 0; } 
#include<bits/stdc++.h> using namespace std;  bitset<1001> vis; int ady[1001][1001]; bool use[2002]; int T,t,h,g,k,resp,match[1001]; pair<int,int > ch[1001],cg[1001];  void restart(){     resp=0;     vis.reset();     for(int i=0;i<1001;i++){         use[i]=use[1001+i]=false;         match[i] = -1;          for(int j=0;j<1001;j++)             ady[i][j]=0;     } } void graph(){     for(int i=0;i<g;i++){         for(int j=0;j<h;j++){             if(abs(ch[j].first-cg[i].first)+abs(ch[j].second-cg[i].second)+abs(cg[i].first-k)+abs(cg[i].second-k) <= t)                 ady[i][j]=1;         }     } } bool path(int nd){     for(int i=0;i<h;i++){         if(ady[nd][i] != 1 || use[i])   continue;         use[i] = true;          if(match[i]==-1 || path(match[i])){             match[i] = nd;             return true;         }     }     return false; } void matching(){     for(int i=0;i<g;i++){         for(int j=0;j<1001;j++) use[j] = false;          if(path(i))  resp++;     } }  int main(){     scanf("%d",&T);      for(int z=1;z<=T;z++){         restart();          scanf("%d %d %d %d",&h,&g,&k,&t);         for(int i=0;i<h;i++)    scanf("%d %d",&ch[i].first,&ch[i].second);         for(int i=0;i<g;i++)    scanf("%d %d",&cg[i].first,&cg[i].second);          graph();         matching();         printf("Case %d: %d\n",z,resp);     } } 
#include<bits/stdc++.h> using namespace std ; int k , m , u , v , s , f , t ; const int maxn = 600 ;  int dist[maxn][7] , vis[maxn][7]; int INF = 1000000009 ;   struct node {     int v , s , f , t ;  };  typedef struct node node ;  struct node2 {     int r , e  , t ; //    bool operator <( node2 x ) const //    { //        return t < x.t ; //    } };  bool operator < (const node2 &a,const node2 &b) {     return a.t > b.t; }  typedef struct node2 node2 ;   vector< node >g[maxn] ;  int main() {       int n ;       cin >> n  ;       for ( int cas = 1 ; cas <= n ; cas++)       {           cin >> k >> m ;            for ( int j = 1 ; j <= k ; j++)             g[j].clear() ;             for ( int i = 1 ; i <= k ; i++)           {             for ( int j = 0 ; j <= 6 ; j++)                  {                     vis[i][j] = 0 ;                     dist[i][j] = INF ;                 }           }            for ( int j = 1 ; j <= m ; j++)           {               cin >> u >> v >> s >> f >> t ;               node a ;               a.v = v ;               a.s = s;               a.f = f ;               a.t = t ;               g[u].push_back(a) ;           }            dist[1][6] = 0 ;            priority_queue < node2 > q ;           node2 start ;           start.r = 1 ;           start.e = 6 ;           start.t = 0 ;            q.push(start) ;            while( !q.empty())           {             node2 x = q.top();             q.pop() ;             if ( vis[x.r][x.e] == 1 )                 continue ;              for( int j = 0 ; j < ( g[x.r]).size() ; j++)             {                 int v1 = g[x.r][j].v ;                  for ( int i = 0 ; i <= 24 ; i++)                 {                     int nt =  x.t + i  ;                      int nh = ( ( x.t ) + i  ) % 24 ;                      int ne = min ( x.e + i , 6 );                        if ( ( g[x.r][j].s <= nh ) && (   g[x.r][j].f >= nh ) &&  ( g[x.r][j].t <=  ne  ) )                       {                           if ( ( nt + g[x.r][j].t ) < ( dist[v1][ ne - g[x.r][j].t ]) )                            {                               dist[v1][ne - g[x.r][j].t] =  g[x.r][j].t + nt  ;                               node2 y;                                y.r = v1 ;                                y.e = ne - g[x.r][j].t ;                                y.t = dist[v1][ne - g[x.r][j].t];                                 q.push(y) ;                            }                       }                  }              }              vis[x.r][x.e] = 1 ;            }   int ans = INF ;   int fi , fj , fh ;   for ( int i = 0 ; i < 7 ; i++)  {      //for ( int h = 0 ; h < 24 ; h++)      //{          if( ans > dist[k][i])          {              ans = dist[k][i];              fi = k ;              fj =  i ;           }      //}  }  cout << "Case " << cas << ": " << ans  << endl ; //cout << " fj " <<  fj << endl ; }        return 0 ; } 
#include <stdio.h> #include <stdlib.h> #include <iostream> #include <string.h> #include <algorithm> #include <math.h> #include <vector> #include <queue> #include <set> #include <stack> #include <map> #define INF_MAX 2147483647 #define INF_MIN -2147483647 #define INF_LL 9223372036854775807LL #define INF 2000000000 #define PI acos(-1.0) #define inf INT_MAX #define llu unsigned long long int #define all(v) v.begin(),v.end() #define pb push_back #define mp make_pair #define F first #define S second #define si(n) scanf("%d",&n) #define slli(n) scanf("%lld",&n); #define ss(n) scanf("%s",n); using namespace std; typedef long long int LL; int dist[110][110] , dp[110][110][110]; //lasta and lastb denote the largest id of cities in both sets. int recur(int curr_node , int lasta , int lastb){	 	if(curr_node < 0) 		return 0;	 	if(curr_node == 0) 		return dist[0][lasta] + dist[0][lastb]; 	if(dp[curr_node][lasta][lastb]!=-1) 		return dp[curr_node][lasta][lastb];	 	int ret; 	//assign curr_node to set A 	ret = dist[curr_node][lasta] + recur(curr_node-1 , curr_node , lastb); 	ret = min(ret , recur( curr_node-1 , lasta , curr_node ) + dist[curr_node][lastb]); 	dp[curr_node][lasta][lastb] = ret; 	return ret; } int main() { int K , R , id , U , W , test; si(test); for(int o=1;o<=test;o++) { memset(dp , -1 , sizeof(dp)); si(K);si(R); for(int ln = 1; ln <= K+2 ; ln++){ 	si(id); 	dist[id][id] = 0; 	for(int j=1;j<=(K+1);j++){ 		si(U);si(W); 		dist[id][U] = W; 	} } int st = 0 , en = K+1; int ans = recur(K , K+1 , K+1) + R*(K+1); printf("Case %d: %d\n",o , ans); } return 0; }
	#include <iostream> 	#include<stack> 	#include<string> 	#include<vector> 	#include<set> 	#include<queue> 	#include<stdio.h> 	#include<string.h> 	#include<math.h> 	#include<algorithm> 	using namespace std;  	#define gc getchar 	#define p 1000000007 	#define MOD 1000000007 	#define pc(x) putchar(x) 	#define pi(n) printf("%d",n) 	#define pis(n) printf("%d ",n) 	#define pin(n) printf("%d\n",n) 	#define pll(n) printf("%lld",n) 	#define ps printf(" ") 	#define pn printf("\n") 	#define rep(i,n) for(i=0;i<n;i++) 	#define fu(i,a,n) for(i=a;i<=n;i++) 	#define fd(i,n,a) for(i=n;i>=a;i--) 	#define INV 333333336 	#define ll long long 	#define ull unsigned long long 	#define EPS 1e-9 	#define infi 2000000000  	inline int sn() 	{ 		int n=0; 		int ch=gc(); 		while( ch <48 )ch=gc(); 		while( ch >47 ) 		n = (n<<3)+(n<<1) + ch-'0', ch=gc(); 		    return n; 	}  	inline void wi(int n) 	{ 		int N = n, rev, count = 0; 		rev = N; 		if (N == 0) { pc('0');  return ;} 		while ((rev % 10) == 0) { count++; rev /= 10;} //obtain the count of the number of 0s 		rev = 0; 		while (N != 0) { rev = (rev<<3) + (rev<<1) + N % 10; N /= 10;}  //store reverse of N in rev 		while (rev != 0) { pc(rev % 10 + '0'); rev /= 10;} 		while (count--) pc('0'); 	}  		 	 	ll dig(ll n) 	{ 		ll t=0; 		while(n) 		{ 			t++; 			n/=10; 		}		 		return t; 	}	 		 	ll dig1(ll n) 	{ 		ll t=1,i; 		rep(i,n) 		{ 			t*=10; 			//n/=10; 		}		 		return t; 	}	 		 	int main() 	{ 		int t=sn(); 		for(int q=1;q<=t;q++) 		{ 			ll a,b,e,d,a1,a2,i; 			int x,y; 			scanf("%d %d",&x,&y); 			a=1; 			e=0; 			a1=100000000; 			a1*=1000000; 			rep(i,1000000) 			{ 				e++; 				a*=x; 				if(a>a1) 				a=a/(dig1(dig(x))); 				//pll(a);ps;pll((a/(dig1(dig(a)-dig(y)))));pn; 				if((a/(dig1(dig(a)-dig(y))))==y) break; 			} 			printf("Case %d: ",q);			 			pll(e);pn; 		} 	 	}               
#include <cstdlib> #include <cstdio> #include <algorithm> #include <vector> #include <queue> #include <cmath> #include <stack> #include <map> #include <set> #include <deque> #include <cstring> #include <functional> #include <climits> #include <list> #include <ctime> #include <complex>  #define F1(x,y,z) for(int x=y;x<z;x++) #define F2(x,y,z) for(int x=y;x<=z;x++) #define F3(x,y,z) for(int x=y;x>z;x--) #define F4(x,y,z) for(int x=y;x>=z;x--) #define pb push_back #define LL long long #define co complex<double>  #define MAX 100005 #define AMAX 1500 #define MOD 1000000007  #define f(c,d) ((1<<(c))*(d))  using namespace std;  int t,n,k; LL x[105],y[105],ans,z[105],ta;  int main(){     scanf("%d",&t);     while(t--){         ans=LLONG_MAX;         scanf("%d%d",&n,&k);         F1(a,0,n)scanf("%lld%lld",x+a,y+a);         F1(a,0,n)F1(b,0,n){             ta=0;             F1(c,0,n)z[c]=abs(x[c]-x[a])+abs(y[c]-y[b]);             sort(z,z+n);             F1(c,0,k)ta+=z[c];             ans=min(ans,ta);         }         printf("%lld\n",ans);     } 	//system("pause"); 	return 0; } 
#include<bits/stdc++.h> using namespace std;  typedef vector<int> vi; typedef vector<vi> vvi; typedef pair<int,int> ii; #define sz(a) int((a).size()) #define pb push_back #define all(c) (c).begin(),(c).end() #define tr(c,i) for(typeof((c).begin() i = (c).begin(); i != (c).end(); i++) #define present(c,x) ((c).find(x) != (c).end()) #define cpresent(c,x) (find(all(c),x) != (c).end())  #define S(x) scanf("%d",&x) #define S1(x) scanf("%lld",&x) #define P(x) printf("%d\n",x) #define P1(x) printf("%lld\n",x) #define Ps(x) printf("%d ",x) #define P1s(x) printf("%lld ",x) #define St(x) scanf("%s",x) #define Pt(x) printf("%s",x) #define Sa(a,n) for(int i=0;i<(n);i++){S1(a[i]);} #define Pa(a,n) for(int i=0;i<(n);i++){P1s(a[i]);}Pt("\n"); #define Y printf("even\n") #define N printf("odd\n") #define mod 1000000007 #define ll long long  ll power(ll b, ll e) {     ll p = 1;     while (e > 0) {         if(e&1) {             p = (p*b)%mod;         }         e = e>>1;         b = (b * b)%mod;     }     return p; } /* ll inp() { 	ll n=0,s=1; 	char c; 	for(c=getchar_unlocked();c<48||c>58;c=getchar_unlocked()) 	if(c=='-')s=-1; 	for(;c>47&&c<59;c=getchar_unlocked()) 	n=n*10+c-48; 	return n*s; }*/ char num[22]; int main() { 	ll n,i,t,j,l; 	for(S1(t);t--;) 	{ 		St(num); 		l=strlen(num); 		for(i=l-1;i>=0&&num[i]=='0';i--); 		if(num[i]=='.')             i--;         (num[i]%2==0)?Y:N;  	} 	return 0; } 
#include<stdio.h> #include<algorithm> using namespace std; int main() { 	long long int t,n,*a,i,max,m; 	scanf("%lld",&t); 	while(t--) 	{ 		scanf("%lld",&n); 		a=new long long int[n]; 		for(i=0;i<n;i++) 		scanf("%lld",&a[i]); 		for(i=0;i<n;i++) 		{ 		m=a[i]%9; 		if(m==0&&a[i]!=0) 		a[i]=9; 		else 		a[i]=m; 	    } 		sort(a,a+n); 		max=a[n-1]; 		switch(max) 		{ 			case 0: printf("red\n"); break; 			case 1: printf("blue\n"); break; 			case 2: printf("pink\n"); break; 			case 3: printf("white\n"); break; 			case 4: printf("black\n"); break; 			case 5: printf("violet\n"); break; 			case 6: printf("cyan\n"); break; 			case 7: printf("yellow\n"); break; 			case 8: printf("green\n"); break; 			case 9: printf("brown\n"); break; 		} 		delete a; 	} }
#include<iostream> #include<stdio.h> #include<string.h> using namespace std; int main() { 	int a[26],t,l,i; 	string s; 	scanf("%d",&t); 	while(t--) 	{ 		for(i=0;i<26;i++) 		a[i]=0; 		scanf("%d",&l); 		cin>>s; 		for(i=0;i<l;i++) 		{ 			a[s[i]-'a']++; 		} 		for(i=0;i<26;i++) 		{ 			if(a[i]%2==1) 			break; 		} 		cout<<char(i+'a')<<endl; 	} }
#include<bits/stdc++.h> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {         long long a,b,c,temp;           long long ab=0,bc=0,ca=0,abc=0;         cin>>a>>b>>c;         map<int,int> aa,bb,cc;         for(int i=0;i<a;i++)         {             cin>>temp;             aa[temp]++;           }         for(int i=0;i<b;i++)         {             cin>>temp;             bb[temp]++;             if(aa[temp]==1)                 ab++;           }         for(int i=0;i<c;i++)         {             cin>>temp;             cc[temp]++;             if(aa[temp]==1)                 ca++;             if(bb[temp]==1)                 bc++;             if(aa[temp]==1&&bb[temp]==1)                 abc++;           }               cout<<ab<<" "<<bc<<" "<<ca<<" "<<abc<<endl;     } } 
#include<bits/stdc++.h> using namespace std; int main() {     int t,n,a,i,f,g;     cin>>t>>n;     set<int> s;     for(i=0;i<n;i++)     {         cin>>a;         s.insert(a);     }     while(t--)     {         int p,q;         cin>>p>>q;         if(p==1)         {             s.insert(q);         }         else if(p==2)         {             s.erase(q);         }         else if(p==3)         {             if(s.size()<=1)             cout<<"-1"<<endl;             else             {                 set<int>::iterator it = s.end();                 int a=*(--it)+*(--it);                 cout<<a<<endl;             }         }       }     return 0; }  
#include<iostream> #include<cstdio> #include<cmath> #include<string> #include<cstring> #include<vector> #include<bitset> #include<map> #include<set> #include<climits> #include<algorithm> #include<utility> #include<cstdlib> #include<cctype> #include<queue> #include<sstream> #define read(x) scanf("%d",&x) #define write(x) printf("%d\n",x) #define assign(x,n) x=(int*)calloc(n,4) #define rep(i,n) for(i=1;i<=n;++i) typedef  long long int ull; using namespace std;  priority_queue<int> pr;  int main() {  int n,k,i,j;  cin>>n>>k;  for(i=0;i<k;i++)  {                  cin>>j;                  pr.push(j);  }  for(i=k;i<n;i++)  {                  cin>>j;                  if(j==-1)cout<<pr.top()<<endl;                  else {pr.push(j);pr.pop();}  }                                                //freopen("in.txt","r",stdin);freopen("out.txt","w",stdout); //getchar(); return 0; } 
#include<iostream> #include<cstdio> using namespace std; int main() {     int t;     scanf("%d",&t);     while(t--)     {         int m,n;         scanf("%d%d",&m,&n);         int k,l;         k=(n-1)*m+(m-1);         if(k%2==1)            printf("%s\n","[:=[first]");         else             printf("%s\n","[second]=:]");     }     return 0; } 
#include <bits/stdc++.h>   using namespace std;   #define MAX 1123456 typedef long long ll;   ll a[MAX];   int main() {   	int t; scanf("%d", &t);   	while(t--) {   		int N, M; scanf("%d %d", &N, &M);   		for(int i = 0; i < N; i++) scanf("%d", &a[i]);   		ll sum = 0; 		int i = 0;   		for(; i < M; i++) sum += a[i];   		for(;  i < N; i++) 			sum -= (ll)(ceil(a[i]/2));   		if(sum < 0) 			cout << "DEFEAT" << endl; 		else 			cout << "VICTORY" << endl; 	} 	return 0; } 
 #include <bits/stdc++.h> #define getcx getchar_unlocked  #ifdef WIN32     inline char getchar_unlocked(){return getchar();}     inline void putchar_unlocked(char x){putchar(x);} #endif // WINDOWS using namespace std;  typedef pair<int,int> ii; typedef vector<int> vi; typedef vector<vi> vvi; typedef vector<ii> vii; #define sz(a) int((a).size()) #define pb push_back #define mp make_pair #define fi first #define se second #define _(x) memset(x,0,sizeof(x)) #define all(c) (c).begin(),(c).end() #define foreach(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) #define present(c,x) ((c).find(x) != (c).end()) #define cpresent(c,x) (find(all(c),x) != (c).end()) #define forall(i,a,b) for(int i=a;i<(b);i++) #define forb(i,a,b) for(int i=a;i>=(b);i--) #define ll long long #define ull unsigned long long #define ui unsigned int #define PI 3.1415926535897932384626 inline void pisz(int n) { printf("%d\n",n); } #define DBG(vari) cerr<<#vari<<" = "<<(vari)<<endl; #define printA(a,L,R) forall(i,L,R) cout << a[i] << (i==R?'\n':' ') #define printV(a) printA(a,0,a.size()-1)   inline int fi (){//fast input function     register int c = getcx();     int x = 0;     int neg = 0;     for(;((c<48 || c>57) && c != '-');c = getcx());     if(c=='-') {neg=1;c=getcx();}     for(;c>47 && c<58;c = getcx()) {x = (x<<1) + (x<<3) + c - 48;}     if(neg) x=-x;     return x; }  inline void fo(int a) { 	char snum[20]; 	int i=0;     int c =a; 	do{ 		snum[i++]=a%10+48; 		a=a/10; 	} 	while(a!=0); 	i=i-1;     if(c<0)         putchar_unlocked('-'); 	while(i>=0) 	putchar_unlocked(snum[i--]); 	putchar_unlocked('\n'); } #define N_PRIMES 2005 char s[2003]; int counts[27];  int main() {     int t = fi();      forall(cx,1,t+1){         scanf("%s",s);         int len = strlen(s);         int ans = INT_MAX;          _(counts);          forall(i,0,len){             counts[s[i]-'a']++;         }         sort(counts,counts+26);         reverse(counts,counts+26);          forall(k,1,27){             int tmp = 0;              if(len%k!=0)                 continue;              int mean =len/k;              forall(i,0,k){                 tmp += abs(counts[i]-mean);             }              forall(i,k,26){                 tmp += counts[i];             }              ans = min(ans,tmp/2);         }          printf("%d\n", ans);      }      return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { long long int t; cin>>t; while(t--) { char s[1009]; cin>>s; long long int i=0,sum=0; while(s[i]!='\0') { if(isdigit(s[i])) { sum+=s[i]-'0'; } i++; } cout<<sum<<endl; } return 0; }
#include<bits/stdc++.h> #define ll long long int #define mp make_pair #define pb push_back #define si(x) scanf("%d",&x) #define pi(x) printf("%d\n",x) #define s(x) scanf("%lld",&x) #define p(x) printf("%lld\n",x)  using namespace std;  int a[1002][1002]; int dp[4][1002][1002]; int main(){ int t; si(t); while(t--){    int n,m,i,j;    si(n);si(m);    for(i=0;i<=n+1;i++){         for(j=0;j<=m+1;j++){             a[i][j]=0;             dp[0][i][j]=0;dp[1][i][j]=0;dp[2][i][j]=0;dp[3][i][j]=0;         }     }     for(i=1;i<=n;i++){     for(j=1;j<=m;j++){         si(a[i][j]);     }    }    for(i=1;i<=n;i++){     for(j=1;j<=m;j++){          dp[0][i][j] =min(dp[0][i-1][j]+a[i][j],a[i][j]);          dp[1][n+1-i][j] =min(dp[1][n+1-i+1][j]+a[n+1-i][j],a[n+1-i][j]);          dp[2][i][j] =min(dp[2][i][j-1]+a[i][j],a[i][j]);          dp[3][i][m+1-j] =min(dp[3][i][m+1-j+1]+a[i][m+1-j],a[i][m+1-j]);     }    }     int ans=INT_MAX;    for(i=1;i<=n;i++){     for(j=1;j<=m;j++){          ans=min(dp[0][i][j]+dp[1][i][j]+dp[2][i][j]+dp[3][i][j]-3*a[i][j],ans);     }    }    pi(ans);  }  return 0; } 
 #include<bits/stdc++.h> using namespace std; #define D(x)        cout<<#x " = "<<(x)<<endl #define un(x)       x.erase(unique(x.begin(),x.end()), x.end()) #define sf(n)       scanf("%d", &n) #define sff(a,b)    scanf("%d %d", &a, &b) #define sfff(a,b,c) scanf("%d %d %d", &a, &b, &c) #define pb          push_back #define mp          make_pair #define xx          first #define yy          second #define hp          (LL) 999983 #define MAX         100000 typedef long long int LL;  const int rt = 317; int arr[MAX+11], lazy[MAX+5][rt+5], buk[rt+5];  int main() {     //freopen("c:\\Users\\User\\Desktop\\in.txt", "r", stdin);     //freopen("c:\\Users\\User\\Desktop\\out.txt", "w", stdout);      int i, j, k, n, q;     int st, gp;      sff(n,q);     while(q--)     {         sff(gp, st);         if(gp >= rt)         {             while(st <= n)             {                 arr[st]++;                 st += gp;             }         }         else lazy[st][gp]++;     }      for(gp = 1; gp < rt; gp++)     {         memset(buk, 0, sizeof(buk));         for(i = 1; i <= n; i++)         {             buk[i%gp] += lazy[i][gp];             arr[i] += buk[i%gp];         }     }      for(i = 1; i <= n; i++)         printf("%d ", arr[i]);      return 0; }    
#include <iostream> #include <cassert> #include <vector> #include <cstdio> #include <algorithm> using namespace std;  #define maxn 100005  vector<int>v[maxn]; int st[maxn],sp,u[maxn],N,T,i,j,x,y,was[maxn],avail; long long K;  bool dfs(int k){ 	st[++sp]=k;u[k]=1;--K; 	if(!K){ 		for(int i=1;i<sp;i++)printf("%d ",st[i]); 		printf("%d\n",st[sp]); 		return true; 	}else for(int j=0;j<v[k].size();j++)if(!u[v[k][j]]&&dfs(v[k][j]))break; 	--sp; 	return false; }  void DFS(int k){ 	was[k]=1; 	++avail; 	for(int j=0;j<v[k].size();j++) 		if(!was[v[k][j]]) 			DFS(v[k][j]); }  int main (int argc, char * const argv[]) { 	ios_base::sync_with_stdio(0); 	cin>>T; 	for(;T;T--){ 		for(avail=0,i=1;i<=N;i++)u[i]=was[i]=0,v[i].clear(); 		cin>>N>>K; 		for(i=1;i<N;i++){ 			cin>>x>>y; 			v[x].push_back(y); 			v[y].push_back(x); 			assert(1<=x&&x<=N&&1<=y&&y<=N); 		} 		DFS(1); 		assert(avail==N); 		for(i=1;i<=N;i++)sort(v[i].begin(),v[i].end()); 		for(i=1;i<=N;i++)if(K>N)K-=N;else{ 			dfs(i); 			break; 		} 		sp=0; 	}     return 0; }
#include <iostream> #include <fstream> #include <vector> #include <set> #include <map> #include <algorithm> #include <cstring> #include <assert.h> using namespace std; class BitMap { private: unsigned char* data, *data2; int w, h, bw; int x0, y0; int size; public: BitMap() { data=data2=NULL; } ~BitMap() { if (data) free(data); if (data2) free(data2); } void resize(int minx, int maxx, int miny, int maxy) { w=maxx-minx+1; h=maxy-miny+1; bw=(w+7)/8; x0=minx; y0=miny;  data=(unsigned char*)malloc(bw*h*sizeof(unsigned char)); data2=(unsigned char*)malloc(bw*h*sizeof(unsigned char)); memset(data, 0, bw*h); memset(data2, 0, bw*h); size=bw*h; } inline void mark(int x, int y) { x-=x0; y-=y0; if (x<0||x>=w) return; if (y<0||y>=h) return; int off=y*bw+x/8; assert(off<size); int mask=1<<(x%8); data2[off]|=mask; } inline bool valid(int x, int y) { x-=x0; y-=y0; if (x<0||x>=w) return false; if (y<0||y>=h) return false; return true; } inline unsigned char marked(int x, int y) { x-=x0; y-=y0; if (x<0||x>=w) return 0; if (y<0||y>=h) return 0; int off=y*bw+x/8; assert(off<size); unsigned char mask=1<<(x%8);  return data2[off]&mask; } inline unsigned char get(int x, int y) { x-=x0; y-=y0; assert(x>=0 && y>=0); int off=y*bw+x/8; assert(off<size); unsigned char mask=1<<(x%8); unsigned char ret=data[off]&mask; return ret; } inline unsigned char set(int x, int y) { x-=x0; y-=y0; assert(x>=0 && y>=0); int off=y*bw+x/8; assert(off<size); int mask=1<<(x%8); unsigned char ret=data[off]&mask; data[off]|=mask; return ret; } inline int steps(int x, int y) { assert(x||y); x=abs(x); y=abs(y); if (x==0) return y; if (y==0) return x; while(y>0) { x = x%y;  x^=y^=x^=y; //swap } return x; } inline short draw(int x1, int y1, int x2, int y2) { if (x1>x2) return draw(x2,y2,x1,y1); if (x1==x2 && y1>y2) return draw(x2,y2,x1,y1); //cout << "draw " << x1 << " " << y1 << " " << x2 << " " << y2 << endl; int st=steps(x2-x1, y2-y1); int dx=(x2-x1)/st, dy=(y2-y1)/st; unsigned char ret=0; //set(x1,y1); int i, j; for (i=x1-dx, j=y1-dy; valid(i, j); i-=dx, j-=dy) { if (get(i,j)) return 0; } for (i=x2+dx, j=y2+dy; valid(i, j); i+=dx, j+=dy) { if (get(i,j)) return 0; } int total=0; bool head = true; for (i=x1+dx, j=y1+dy; (i!=x2)||(j!=y2); i+=dx, j+=dy) { if (marked(i,j)) head = false; if (get(i, j)) { if (head) total++; head=true;  } } if (head) total++; return total; } }; class Point { public: Point(int xx, int yy):x(xx), y(yy) { } friend bool operator<(const Point&, const Point&); short x, y; }; inline bool operator<(const Point& a, const Point& b) { if (a.y<b.y) return true; if (a.y>b.y) return false; return (a.x<b.x); }; int towSize, skySize; vector<Point> pt, skyscrappers; #define INPUT cin //#define INPUT input //ifstream input("input.txt"); int main(int argc, char* argv[]) { int ntest, n, m; INPUT >> ntest; int x, y; while (ntest--) {  BitMap bitmap; //bitmap.steps(2, -3); pt.clear(); skyscrappers.clear(); INPUT >> n >> m; towSize=n; skySize=m; pt.reserve(n+1); skyscrappers.reserve(m+1); int minx=20000, maxx=-20000; int miny=20000, maxy=-20000; while (n--) { INPUT >> x >> y; minx=min(minx, x); maxx=max(maxx, x); miny=min(miny, y); maxy=max(maxy, y); pt.push_back(Point(x,y)); } bitmap.resize(minx, maxx, miny, maxy); int total=0; short i, j; for (i=0; i<towSize; i++) { bitmap.set(pt[i].x, pt[i].y); } sort(pt.begin(), pt.end()); while (m--) { INPUT >> x >> y; bitmap.mark(x, y); } for (i=0; i<towSize; i++) { for (j=i+1; j<towSize; j++) {  int n=(bitmap.draw(pt[i].x, pt[i].y, pt[j].x, pt[j].y)); total+=n; //cout << i << " " << j << " " << n << " " << total << endl; } } cout << total << endl; } return 0; }
/*	SURENDRA KUMAR MEENA	*/ #include <vector> #include <list> #include <map> #include <set> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <queue> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <climits> #include <cassert> #include <cstring> #include <cstdlib> #include <ctime> using namespace std; typedef long long int LL; #define R(i,m,n)	for(int i=m;i>=n;i--) #define FF(i,m,n)	for(int i=m;i<n;i++) #define F(i,n)	FF(i,0,n) #define S(t)	scanf("%d",&t)  char Word[55010][26],Pat[6]; int Lenw[55010],Lenw2[55010]; int val[55010][26]; int len; int val2[6]; bool existstar[6]; bool existalpha[6]; bool existmark[6]; int totcount[6]; int qq; int memo[25][5]; int wno;  bool WildcardMatching(){ 	int ii=0,jj=0,i,j; 	while(ii<Lenw[wno] && (Pat[jj]=='?' || Pat[jj]==Word[wno][ii]))	ii++,jj++; 	if(ii==Lenw[wno]){ 		if(jj<len && Pat[jj]=='*')	jj++; 		if(jj<len)	return 0; 		return 1; 	} 	if(jj==len)			return 0; 	if(Pat[jj]!='*')	return 0; 	i=ii+1;j=jj+1; 	while(ii<Lenw[wno]){ 		if(!existstar[jj] && len-jj!=Lenw[wno]-ii){ 			ii=i++,jj=j; 			continue; 		} 		if(!existalpha[jj]){ 			if(!existstar[jj]){ 				if(len-jj==Lenw[wno]-ii)	return 1; 				ii=i++,jj=j; 				continue; 			} 			if(totcount[jj]<=Lenw[wno]-ii)	return 1; 			ii=i++,jj=j; 			continue; 		} 		if(!existstar[jj] && !existmark[jj]){ 			while(jj<len && Pat[jj]==Word[wno][ii])	jj++,ii++; 			if(jj==len && ii==Lenw[wno])	return 1; 			ii=i++,jj=j; 			continue; 		} 		if(memo[ii][jj]!=qq){ 			memo[ii][jj]=qq; 			if(Pat[jj]=='?' || Pat[jj]==Word[wno][ii])	ii++,jj++; 			else if(Pat[jj]=='*'){ 				jj++; 				if(jj<len)	i=ii+1,j=jj; 				else		return 1; 			} 			else	ii=i++,jj=j; 		} 		else{ 			ii=i++;jj=j; 		} 	} 	while(Pat[jj]=='*')	jj++; 	return	jj==len; }  int main(){ 	int t,i,j,k; 	char ch; 	memset(memo,0,sizeof(memo)); 	qq=1; 	scanf("%d",&t); 	while(t--){ 		int n,q; 		scanf("%d%d",&n,&q); 		for(i=0;i<n;i++){ 			scanf("%s",Word[i]); 			Lenw[i]=strlen(Word[i]); 		} 		memcpy(Lenw2,Lenw,sizeof(Lenw)); 		sort(Lenw2,Lenw2+n); 		while(q--){ 			int ans=0; 			scanf("%s",Pat); 			printf("%s ",Pat); 			len=strlen(Pat); 			for(i=0;i<len-1;i++) 				if(Pat[i]=='?' && Pat[i+1]=='*'){	Pat[i]='*';	Pat[i+1]='?';	} 			char *p=Pat+1; 			for(j=1;Pat[j];j++){ 				if(Pat[j]=='*' && Pat[j]==Pat[j-1])	continue; 				*p++=Pat[j]; 			} 			*p='\0'; 			len=strlen(Pat); 			existstar[len]=0; 			existalpha[len]=0; 			existmark[len]=0; 			totcount[len]=0; 			for(i=len-1;i>=0;i--){ 				existstar[i]=(existstar[i+1]|(Pat[i]=='*')); 				existalpha[i]=existalpha[i+1]; 				existmark[i]=existmark[i+1]; 				totcount[i]=totcount[i+1]; 				if(Pat[i]=='?'){ 					totcount[i]++; 					existmark[i]=1; 				} 				else if(Pat[i]!='*')	existalpha[i]=1; 			} 			if(existalpha[0]==false && existstar[0]==true){ 				printf("%d\n",n-(lower_bound(Lenw2,Lenw2+n,totcount[0])-Lenw2)); 				continue; 			} 			for(wno=0;wno<n;wno++,qq++){ 				if(Pat[0]!='*' && Pat[0]!='?' && Word[wno][0]!=Pat[0])	continue; 				if(Pat[len-1]!='*' && Pat[len-1]!='?' && Word[wno][Lenw[wno]-1]!=Pat[len-1])	continue; 				if(WildcardMatching())	ans++; 			} 			printf("%d\n",ans); 		} 		puts(""); 	} 	return 0; } 
#define DEBUG 0   #include <stdio.h> #include <string.h> #include <math.h> #include <stdlib.h>   int is_prime(char s[13]) {   int sr, i;   long long unsigned n=0;   for(i=0;s[i]!='\0';i++)     n=n*10+s[i]-'0';   if(n<=1)     return 0;   if(n<=3)     return 1;   if(n%2==0)     return 0;   sr=(int)sqrt(n);   if(DEBUG)     printf("is %llu prime sr=%d\n", n, sr);   for(i=3;i<=sr;i+=2)     if(n%i==0)       return 0;   return 1; }   int done;   void solve(char s[13], int pos) {   int i;   if(s[pos]=='\0') {     if(is_prime(s)) {       done=1;       printf("%s\n", s);     }   } else if(s[pos]!='?')     solve(s, pos+1);   else {     if(pos==0)       for(i='1';i<='9'&&!done;i++) {         s[pos]=i;         solve(s, pos+1);       }     else       for(i='0';i<='9'&&!done;i++) {         s[pos]=i;         solve(s, pos+1);       }   } }   int main(void) {   char s[13];   int tc;   scanf("%d", &tc);   while(tc--) {     scanf("%s", &s);     done=0;     solve(s, 0);   }   return 0; }
    #include<iostream>     #include<vector>     #include<deque>     #include<map>     #include<algorithm>     #include<cstdlib>     #include<time.h>     #include<stdio.h>     #include <unistd.h>     #define TIMER_ON 0     #if TIMER_ON == 1     #define TIMER(x) x     #else     #define TIMER(x)     #endif     #define DEBUG_LEVEL 0     #if DEBUG_LEVEL > 0     #define DEBUG_LVL(LEVEL, STATEMENT) if((LEVEL+1)>DEBUG_LEVEL) STATEMENT     #else     #define DEBUG_LVL(LEVEL, STATEMENT)     #endif     #define DEBUG_SPECIFIC 0     #if DEBUG_SPECIFIC == 0     #define DEBUG_SPF(LEVEL, STATEMENT) if(LEVEL==DEBUG_SPECIFIC) STATEMENT     #else     #define DEBUG_SPF(LEVEL, STATEMENT)     #endif     typedef std::pair< unsigned int /*index*/, unsigned long /*height*/ > SkyScraper;     #define bldIndex first     #define bldHeight second     unsigned int nSkyscrapers;     unsigned int halfLen;     unsigned int quatLen;     class CitySkyLine : public std::deque< SkyScraper >     {     public:     SkyScraper check;     CitySkyLine():check(0,0){}     void check_push_back(unsigned int iii, unsigned long height)     {     DEBUG_LVL(1, std::cout << "[height("<<height<<")+iii("<<iii<<")+1] > [check.bldHeight("<<check.bldHeight<<")+check.bldIndex("<<check.bldIndex<<")]"<<std::endl);     if((height+iii+1)> (check.bldHeight+check.bldIndex) )     {     DEBUG_LVL(1, std::cout << "true" << std::endl);     while(size()>0)     {     check=back();     if(height > check.bldHeight && (iii-check.bldIndex) < (height-check.bldHeight) )     {     DEBUG_LVL(2, std::cout << "-----pop_back(idx="<<check.bldIndex<<", hgt="<<check.bldHeight<<")"<<std::endl);     pop_back();     }     else     break;     }     DEBUG_LVL(2, std::cout << "+++++push_back(idx="<<iii<<", hgt="<<height<<")"<<std::endl);     check=SkyScraper(iii,height);     push_back(check);     }     }     };     typedef std::map<unsigned int /* 4*Height */, CitySkyLine > City;     typedef std::vector< SkyScraper > CityAll;     bool compareHeight(const SkyScraper& a, const SkyScraper& b) { return a.bldHeight < b.bldHeight; }     bool compareIndex(const SkyScraper& a, const SkyScraper& b) { return a.bldIndex < b.bldIndex; }     unsigned long operator-(const SkyScraper& a, const SkyScraper& b)     {     DEBUG_LVL(1, std::cout << "a.idx=" << a.bldIndex << ", b.idx=" << b.bldIndex << ", a.hgt=" << a.bldHeight << ", b.hgt=" << b.bldHeight);     unsigned int bldgDistance = (a.bldIndex > b.bldIndex) ? (a.bldIndex - b.bldIndex) : (b.bldIndex - a.bldIndex);     if(bldgDistance > halfLen) bldgDistance = nSkyscrapers - bldgDistance;     DEBUG_LVL(1, std::cout <<", bldDist="<< bldgDistance << std::endl);     return a.bldHeight+b.bldHeight+bldgDistance;     }     void printCity(const City& city)     {     int lev=0;     std::cout << "#######start########" << std::endl;     for(City::const_iterator iter=city.begin(); iter != city.end(); iter++,lev++)     for(CitySkyLine::const_iterator blg=iter->second.begin(); blg != iter->second.end(); blg++)     std::cout <<"level="<<lev<< ", blg.idx="<< blg->bldIndex << ", blg.hgt=" << blg->bldHeight << std::endl;     std::cout << "#######end########" << std::endl;     }     void printCity(const CityAll& cityAll)     {     std::cout << "*********start*********" << std::endl;     for(CityAll::const_iterator blg=cityAll.begin(); blg != cityAll.end(); blg++)     std::cout << "*blg.idx="<< blg->bldIndex << ", blg.hgt=" << blg->bldHeight << std::endl;     std::cout << "*********end*********" << std::endl;     }     int main()     {     TIMER(time_t startTime=time(NULL));     TIMER(std::cerr<<"start ="<<startTime<<std::endl);     unsigned int arrIdx=0;     int readSize;     char input[1000000];     unsigned int iii=0, prevSize;     unsigned long height, minNextHeight;     readSize = read(0, input, sizeof(input)-1);     input[readSize]='\0';     for (nSkyscrapers = 0; input[arrIdx] >= '0'; ++arrIdx) nSkyscrapers = nSkyscrapers * 10 + (input[arrIdx] - '0');     for (;arrIdx<readSize && input[arrIdx] < '0'; ++arrIdx);     halfLen = nSkyscrapers/2;     quatLen = nSkyscrapers/4;     City city;     minNextHeight=0;     while(iii<nSkyscrapers)     {     height = 0;     for (; arrIdx<readSize && input[arrIdx] >= '0'; ++arrIdx) height = height * 10 + (input[arrIdx] - '0');     if(arrIdx==readSize)     {     readSize = read(0, input, sizeof(input)-1);     if(readSize < 0) exit(1);     input[readSize]='\0';     arrIdx=0;     for (; arrIdx<readSize && input[arrIdx] >= '0'; ++arrIdx) height = height * 10 + (input[arrIdx] - '0');     }     for (;arrIdx<readSize && input[arrIdx] < '0'; ++arrIdx);     DEBUG_LVL(2, std::cout << ">>>>height="<<height<<", minNextHeight="<<minNextHeight<<std::endl);     if(height>minNextHeight)     {     city[(height<<1)/nSkyscrapers].check_push_back(iii,height);     prevSize = city.size();     if( city.size() > 2 )     {     city.erase(city.begin());     }     minNextHeight = ((nSkyscrapers * (city.begin()->first))>>1);     }     iii++;     }     TIMER(time_t endTime=time(NULL));     TIMER(std::cerr<<"read end="<<endTime<<", runTime="<<endTime-startTime<<std::endl);     DEBUG_LVL(3, printCity(city));     unsigned int diffIdx;     City::iterator iter;     for(iter=city.begin(); iter != city.end(); iter++)     {     CitySkyLine& inLevel = iter->second;     diffIdx = nSkyscrapers + inLevel.front().bldIndex - inLevel.back().bldIndex;     while( inLevel.size()>2     && diffIdx < abs( long(inLevel.front().bldHeight) - inLevel.back().bldHeight) )     {     if(inLevel.front().bldHeight > inLevel.back().bldHeight)     {     inLevel.pop_back();     }     else     {     inLevel.pop_front();     }     diffIdx = nSkyscrapers + inLevel.front().bldIndex - inLevel.back().bldIndex;     }     }     DEBUG_LVL(3, printCity(city));     iter=city.begin();     CityAll cityAll;     if(city.size()==1)     {     cityAll = CityAll( iter->second.begin(), iter->second.end() );     }     else     {     City::iterator iter2 = iter;     iter2++;     cityAll.resize(iter->second.size()+iter2->second.size());     std::merge(iter->second.begin(), iter->second.end(), iter2->second.begin(),iter2->second.end(), cityAll.begin(), compareIndex);     }     DEBUG_LVL(3, printCity(cityAll));     iii=0;     CityAll::iterator iterAll = cityAll.begin();     unsigned long maxDistance=0, tmpDistance;     while(iterAll != cityAll.end())     {     CityAll::iterator iterAll2 = iterAll;     iterAll2++;     while(iterAll2 != cityAll.end())     {     if( maxDistance < (tmpDistance=(*iterAll) - (*iterAll2)) ) maxDistance = tmpDistance;     iterAll2++;     }     iterAll++;     }     std::cout<<maxDistance<<std::endl;     TIMER(endTime=time(NULL));     TIMER(std::cerr<<"cal end ="<<endTime<<", runTime="<<endTime-startTime<<std::endl);     return 0;     } 
#include<bits/stdc++.h> #define ull unsigned long long #define ll long long #define mp make_pair #define A first #define B second #define MIN (1<<31) #define MAX (1<<31) - 1 #define MOD 1000000007 #define scanint(n) scanf("%d",&n) using namespace std; #define N 1001 int A[N][N];	//matrix int dp[N][N]; int n,m; int calc(int x,int y){	//recursively calculates the sum of the sub-rectangle {(1,1) to (x,y)} 	if(x<1 || y<1)	dp[x][y]=0; 	if(dp[x][y]!=-1)	return dp[x][y]; 	dp[x][y] = calc(x-1,y) + calc(x,y-1) - calc(x-1,y-1) + A[x][y]; 	return dp[x][y]; } int main(){ 	for(int i=0;i<N;i++){ 		for(int j=0;j<N;j++)	dp[i][j]=-1; 	} 	scanint(n); 	scanint(m);//input the dimensions 	for(int i=1;i<=n;i++){ 		for(int j=1;j<=m;j++){ 				scanint(A[i][j]);	//take input 		} 	} 	dp[1][1]=A[1][1];	//base case 	for(int i=0;i<max(n,m);i++)	dp[i][0]=0; 	for(int i=0;i<max(n,m);i++)	dp[0][i]=0; 	int c,x1,y1,x2,y2; 	int ans=0; 	calc(n,m); 	scanint(c);	//no of queries 	for(int i=0;i<c;i++){ 		scanint(x1); 		scanint(y1); 		scanint(x2); 		scanint(y2);//input of coordinates 		ans = dp[x2][y2] - dp[x1-1][y2] - dp[x2][y1-1] + dp[x1-1][y1-1]; 		printf("%d\n",ans);	//output of the answer 	} 	return 0; }
#include <bits/stdc++.h> using namespace std; long long int sum(long long int x) { 	long long int s=0,t; 	while(x) 	{ 		t=x%10; 		if(t&1) 			s+=t; 		else 			s+=2*t; 		x/=10;	 	} 	return s%10; } long long int ssum(long long int x) { 	long long int s=0; 	while(x%10!=0) 		{ 			x--; 			s+=sum(x); 			//x--; 		} 	long long int k=x/10; 	s+=k*45; 	return s; } int main() { 	long long int t,a,b,ans; 	cin>>t; 	while(t--) 	{ 		cin>>a>>b; 		ans=ssum(b+1)-ssum(a); 		cout<<ans<<"\n"; 	} 	return 0; } 
#include <iostream> #include<queue> #include<vector> #include<algorithm>  using namespace std;  struct node { 	int n; 	vector<int> ds; 	bool visited; };  int main() { 	// your code goes here 	int N,L,i,j; 	cin>>N>>L; 	int d[N][N]; 	for(i=0;i<N;i++) 		for(j=0;j<N;j++) 			cin>>d[i][j]; 	 	queue<node*> q; 	vector<node> v; 	vector<int> w,x; 	 	node temp; 	node* temp2; 	temp.visited=false; 	 	for(i=0;i<N;i++) 	{ 		temp.n=i; 		temp.ds.push_back(0); 		v.push_back(temp); 	} 	 	q.push(&v[0]); 	 	while(!q.empty()) 	{ 		temp2=q.front(); 		q.pop(); 		 		if(temp2->visited==false) 		{ 			temp2->visited=true; 			 			for(i=0;i<N;i++) 			{ 				if(i!=temp2->n) 				{ 					if(v[i].visited==false) 					{ 						q.push(&v[i]); 						 						w=v[i].ds; 						x=temp2->ds;  						for(j=0;j<w.size();j++) 							temp2->ds.push_back(w[j]+d[i][temp2->n]);  						for(j=0;j<x.size();j++) 							v[i].ds.push_back(x[j]+d[i][temp2->n]); 					} 				} 			} 		} 	} 	 	if(find(v[N-1].ds.begin(),v[N-1].ds.end(),L-d[0][N-1])==v[N-1].ds.end()) 		cout<<"IMPOSSIBLE"; 	else 		cout<<"POSSIBLE"; 	return 0; }
#include <bits/stdc++.h>  using namespace std;  #define pb push_back #define mp make_pair  #define ALL(x) (x).begin(),(x).end() #define CLR(a,b) memset(a,b,sizeof(a)) #define REPN(x,a,b) for (int x=a; x<b;++x) #define REP(x,b) REPN(x, 0, b)  const int MAX = 125010; const int HB = 7; const int MOD = 1000000009; const int C = 10; int powers[MAX];  char P[MAX], Q[MAX]; int n; int hashes[2][11][MAX]; //hashes of P int PS[11], QS[11]; //hashes of substrings bool vis[11]; string Perm; //here we save our permutations int character_hashes[2][C + 1];  void initHash(char * S, int M[][MAX]) {     REP(i, 10) M[i][0] = 0;     REP(i, n) {         REP(j, 10) {             M[j][i+1] = M[j][i];             if (S[i] == 'a'+j) {                 M[j][i+1] += powers[i];                 if (M[j][i+1] >= MOD) M[j][i+1] -= MOD;             }         }     } }  int get_hash(int n, int hashes[], int l, int r) {   return ((hashes[r] - hashes[l - 1] + MOD) * 1ll * powers[n - r]) % MOD; }   bool check_substrings(int n, int l_1, int r_1, int l_2, int r_2) {   for (int i = 0; i < C; i++) {     character_hashes[0][i] = get_hash(n, hashes[0][i], l_1, r_1);     character_hashes[1][i] = get_hash(n, hashes[1][i], l_2, r_2);   }    sort(character_hashes[0], character_hashes[0] + C);   sort(character_hashes[1], character_hashes[1] + C);    for (int i = 0; i < C; i++) {     if (character_hashes[0][i] != character_hashes[1][i]) {       return false;     }   }    return true; }  bool character_is_taken[C + 1];  int eval(int px, int qx, char permutation[] ) {     int l = 1, r = min(n-px+2, n-qx+2);     while (l + 1 < r) {         int m = (l + r)/2;         if (check_substrings(n, px, px+m-1, qx, qx+m-1)) l = m;         else r = m;     }      int prefix_length = l;         memset(character_is_taken, false, sizeof(character_is_taken));       for (int i = 0; i < C; i++) {         int hash = get_hash(n, hashes[0][i], px, px + prefix_length - 1);         for (int j = 0; j < C; j++) {           if (!character_is_taken[j] && hash == get_hash(n, hashes[1][j], qx, qx + prefix_length - 1)) {             character_is_taken[j] = true;             permutation[i] = 'a' + j;             break;           }         }       }        permutation[C] = '\0';     return l; }  char resulting_permutation[11];  int main() {      powers[0] = 1;     REPN(i, 1, MAX) {         powers[i] = (powers[i-1]*1ll*HB)%MOD; //        printf("%d\n", powers[i]);     }      int T, q;     scanf("%d", &T);      REP(tc, T) {         scanf("%d %d", &n, &q);          scanf("%s", P);         scanf("%s", Q);          initHash(P, hashes[0]);         initHash(Q, hashes[1]);          REP(i, q) {             int px, qx;             scanf("%d %d", &px, &qx);             printf("%d %s\n", eval(px, qx, resulting_permutation), resulting_permutation);         }     }      return 0; } 
#include<iostream> #include<cstdio>  using namespace std; long long int num(long long int a) {     if(a==0)     {         return 0;     }     return(num(a/10)+a%10); } int main() {     long long int t,a,b;     scanf("%lld",&t);     while(t--)     {         scanf("%lld %lld",&a,&b);         long long int ans = num(a)*num(b);         while(ans>=10)         {             ans=num(ans);         }         printf("%lld\n",ans);     }     return(0); } 
#include<stdio.h>  int main() {     long long t,c,i;     int n;     scanf("%lld",&t);      while(t--)     {         long int sum=0;         scanf("%d %lld",&n,&c);         int a[n];         for(i=0;i<n;i++)        {            scanf("%d",&a[i]);            sum+=a[i];        }         if(c>=sum)         {             printf("Yes\n");         }         else if(c<=sum)         {             printf("No\n");          }       }     return 0; } 
#include<iostream> #include<cmath> #include<algorithm> #include<fstream> using namespace std; int main() { 	int t; 	long long int n,x; 	cin>>t; 	while(t--) 	{ 		signed long long int i; 		int flag=0; 		cin>>n; 		for(i=1;i<n;++i) 		{ 			//bruteforce on one side of the triangle 			x=(signed long long int)sqrt(n*n-i*i); 				//the second side of the right angled triangle where i is the first side 			if(x*x+i*i==n*n){flag=1;break;} 				//if this second side is indeed an integer.. it satisfies the pythagoras theorum 			//if one such pair x,i is found then we stop the bruteforce and indicate that the solution is found 		} 		if(flag)cout<<"YES\n"; 		else cout<<"NO\n"; 	} }
/*  * nunnally.c  *   * Copyright 2014 sudhakar <sudhakar@sudhakar-Presario-CQ62-Notebook-PC>  *   * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *   * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *   * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,  * MA 02110-1301, USA.  *   *   */   #include <stdio.h> #include <math.h> #include<iostream> #include<map> #include<vector> #include<cstring> #include<cmath> #include<algorithm> #include<cstdio> #include<fstream> using namespace std;  unsigned long long int tst,i,j,k,s,n,mod=1000000007;   int main(int argc, char **argv) { //freopen("TEST_5.txt", "r", stdin); //freopen("OUT_5.txt", "w", stdout);   	scanf("%llu",&tst); 	while(tst--){ 		s=0; 	scanf("%llu",&n); 	 	for(i=2;i<sqrt(n);++i){ 		if(n%i==0) 		s=s+ ((((i%mod)*(i%mod))%mod) + ((((n/i)%mod)*((n/i)%mod))%mod)); 		s%=mod; 		//printf("%llu %llu ",s,i); 		} 	if(i*i==n) 		{s+=n; s%=mod;} 		printf("%llu\n",s); 	 	} 	 	 	return 0; }  
#include<iostream> #include<cmath>  static unsigned long long int arr[]={0,1,4,27,256,3125,46656,823543,16777216,387420489ULL,10000000000ULL};  using namespace std;  int main(){ unsigned long long int t,N,A,B,K,i,j; 	 	cin>>t; 	while(t--){ 		cin>>A>>B; 		 		N = arr[A]-((A-1)*B); 		j=N; 		cout<<N; 		for(i=1;i<=A;i++){ 			j-=B; 			j-=(j/A); 			} 			K=j; 		cout<<" "<<K<<endl; 		 		} 		 	} 
#include<iostream> #include<cstdlib> using namespace std; long long gcd(long long a,long long b) { 	if(b==0) 	return a; 	else 	return gcd(b,a%b); } int main() { 	long long t; 	cin>>t; 	while(t--) 	{ 		long long n,m; 		cin>>n>>m; 		printf("%lld\n",gcd(n,m)); 	} 	return 0; }
#include <stdio.h> #include <string.h> #include <stdlib.h> #include <math.h> #include <assert.h> long long fun(long long x){     long long s=0;     while(x){         s=s+x%10;         x = x/10;     }     if(s>9)         s=fun(s);     return s; } int gcd(int a,int b){     if(a%b==0)         return b;     else         return gcd(b,a%b); } int main(){     int t;     scanf("%d",&t);     while(t--){         long long a,b,p,c,i;         scanf("%lld %lld %lld %lld",&a,&b,&c,&p);         long long x=a%9,ans=1,count;         while(b>0){             if(b%2==1) ans=(ans*x)%9;                 ans=(ans*ans)%9;             b/=2;         }         p += fun(ans);                    long long j=1,k,l,m;         x = p/c; x--;                ans = x+1;x--;          for(i=2*c;i<=p;i+=c){              l = j+1;              k = (x)/l;  l=0;                              if(l==0){                  k=0;                  for(m=i+c;m<=p;m+=c){                      if(gcd(i,m)!=c)                          k++;                  }              }              ans += x-k;              x--;              j++;                             }           printf("%d\n",ans);          }     return 0; } 
#include <bits/stdc++.h> using namespace std; const int mx = 10000001; const int nx = 100001; int odd[nx]; long long val[nx]; bool pr[mx];  void init() {     for (int z = 0; z < mx; pr[z] = 1, ++z);     for (int i = 2; i < mx; ++i) {         if (!pr[i]) continue;         if (i * 1ll * i >= mx) break;         for (int j = i * i; j < mx; pr[j] = 0, j += i);     } }  int main(int argc, char const *argv[]) {     init();     long long a, b;     scanf("%lld%lld", &a, &b);     int n = b - a + 1;     for (int i = 0; i < n; i++) odd[i] = 0, val[i] = i + a;     for (int i = 2; i < mx; i++) {         if (!pr[i]) continue;     	for (long long j = ((a + i  -1) / i) * i; j <= b; j += i) {     		int cnt = 0;             long long idx = j - a;             while ((val[idx] % i) == 0) {                 val[idx] /= i;                 cnt++;             }             cnt % 2 ? odd[idx]++ : odd[idx]--;     	}     }     for (int i = 0; i < n; i++) if (val[i] >= 2) odd[i]++;      int ans = 0;     for (int i = 0; i < n; i++) ans += (odd[i] > 0);     printf("%d\n", ans); 	return 0; } 
#include<bits/stdc++.h> using namespace std; #define ll long long #define f first #define s second #define pb push_back #define mp make_pair #define pii pair<int,int> #define pil pair<int,ll> #define pli pair<ll,int> #define pll pair<ll,ll> #define mod 95676260903887607LL vector<int>adj[100011]; int mn,loc,mark[100011]; vector<int>v; void dfs(int u,int p,int h) {     if(h>mn)     {         mn=h;         loc=u;     }     for(int i=0;i<adj[u].size();i++)         if(adj[u][i]!=p)             dfs(adj[u][i],u,h+1); } int dfs1(int u,int p,int h) {     if(u==loc)     {         v.pb(loc);         return 1;     }     for(int i=0;i<adj[u].size();i++)         if(adj[u][i]!=p)             if(dfs1(adj[u][i],u,h+1)==1)             {                 v.pb(u);                 return 1;             }     return 0; } int dfs2(int u,int p) {     mark[u]=1;     int mx=0;     for(int i=0;i<adj[u].size();i++)     {         if(adj[u][i]!=p&&mark[adj[u][i]]==0)             mx=max(mx,dfs2(adj[u][i],u)+1);     }     return mx; } int main() {     int i,j,n,k,t;     scanf("%d",&t);     while(t--)     {         scanf("%d",&n);         for(i=0;i<=n;i++)             adj[i].clear();         for(i=0;i<=n;i++)             mark[i]=0;         for(i=1;i<n;i++)         {             int p;             scanf("%d",&p);             adj[p].pb(i);             adj[i].pb(p);         }         mn=-1;         dfs(0,-1,0);         mn=-1;         int loc1=loc;         v.clear();         dfs(loc,-1,0);         dfs1(loc1,-1,0);         assert(v[0]==loc);         assert(v.back()==loc1);         assert(v.size()==mn+1); //        printf("%d\n",mn+1); //        for(i=0;i<v.size();i++) //            printf("%d ",v[i]); //        printf("\n");         int y,mx=1000111,mn1=1000000;         for(i=0;i<v.size();i++)         {             if(i==v.size()-1)                 y=dfs2(v[i],-1);             else                 y=dfs2(v[i],v[i+1]);            // cout<<v[i]<<" "<<y<<endl;             if(y==i)                 mn1=i;             if(y==mn-i)                 mx=min(mx,i);         }         printf("%d\n",mx-mn1+1);     }     return 0; } 
    #include<bits/stdc++.h>     using namespace std;     int compare(int a,int b){         if(a>b){             return 1;         }         else{             return 0;         }     }     int main(){         int n,a,m;             int r[105]={0};             int c[105]={0};             int d1=0,d2=0;             cin>>n;             for(int i=1;i<=n;i++){                 for(int j=1;j<=n;j++){                     cin>>a;                     if(i==j){                         d1+=a;                     }                     if((i+j)==n+1){                         d2+=a;                     }                     r[i]+=a;                     c[j]+=a;                 }             }             sort(r,r+n+1,compare);             sort(c,c+n+1,compare);             if(d1>d2){                 m=d1;             }             else{                 m=d2;             }             int m1,m2,m3;             m1=r[0];             m2=c[0];             m3=m;             int result=m1>m2&&m1>m3?m1:m2>m3?m2:m3;             cout<<result<<endl;         return 0;     }      
#include<iostream> #include<math.h>  using namespace std; int count(int); int main() {  int i,j=0,k=0,l=0;  cin>>i;   while(i>0)  {      j=j+i%10;      i=i/10;      l=j;  }   while(j>0)  {      k=k+j%10;      j=j/10;      l=k;  }   while(k>0)  {      l=0;      l=l+k%10;      k=k/10;   }  cout<<l<<endl;     return 0; }   
using namespace std; #include <cmath> #include <cstdio> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <string> #include <vector> #include <iostream> #include <sstream> #include <algorithm> #define all(c) (c).begin(),(c).end() #define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) typedef long long ll;  typedef pair<int,int> pii;  #define FOR(i,n) for (int i = 0; i < n; i++) #define SZ(x) ((int)x.size()) #define PB push_back #define MP make_pair #define sf(x) scanf("%d",&x) #define pf(x) printf("%d\n",x) #define split(str) {vs.clear();istringstream ss(str);while(ss>>(str))vs.push_back(str);} #define PI 3.141592653589793 int main() { 	int t; 	sf(t); 	while(t--) 	{ 		int n,m,k; 		sf(n); sf(m); sf(k); 		vector<int> v; 		FOR(i,n) 		{ 			string a; 			cin>>a; 			int c = 0; 			FOR(j,a.size()) 				if(a[j] == '*')c++; 			v.PB(c); 		} 		sort(all(v)); 		int i = 0; 		while(k>0) 		{ 			if(v[i] > m/2) 				break; 			v[i] = m-v[i]; 			k--; 			i++; 			if(i == v.size())break; 		} 		int minval = 1000000; 		if(k%2 != 0) 		{ 			FOR(i,v.size()) 				minval = min(minval, v[i] - (m-v[i])); 		} 		if(minval == 1000000) minval = 0; 		int ans = 0; 		FOR(i,v.size()) 			ans += v[i]; 		cout<<ans - minval<<endl; 	} }
#include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<map> #include<set> #include<queue> #include<utility> #include<cstring> #include<cmath> #define LL long long int #define mod 1000000007 #define vi vector<int> #define vvi vector < vi > #define pii pair<int,int> #define all(c) c.begin(),c.end() #define sf(x) scanf("%d",&x); #define sf2(x,y) scanf("%d%d",&x,&y); #define mem(a,val) memset(a,val,sizeof(a)) #define nl printf("\n"); #define pb push_back #define mp make_pair //#define f first //#define s second #define cf I64 using namespace std; int main() {	int t,i,j,n,m,ans,sum,a[105],x; 	cin>>t; 	while(t--) 	{	cin>>n; 		sum=0; 		for(i=0;i<n;i++)  		{	cin>>a[i]; 			sum+=a[i]; 		} 		if(sum%n!=0) cout<<"-1\n"; 		else 		{	sum=sum/n; 			x=0; 			for(i=0;i<n;i++) 				x+=abs(sum-a[i]); 			cout<<x<<endl;	 		} 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; int main() {     int t;     scanf("%d",&t);     while(t--)     {         int n,i,l,j,c,mx,k;          scanf("%d",&n);          int a[n],b[n];         for(i=0;i<n;++i)             scanf(" %d %d",&a[i],&b[i]);         if(n==1)         {             printf("1\n");             continue;         }         mx=1;         for(i=0;i<n;++i)         {             float s[n-i-1];             k=0;             for(j=i+1;j<n;++j)             {                 s[k++]=(((float)b[j]-(float)b[i])/((float)a[j]-(float)a[i]));             }          //   for(int yo=0;yo<k;yo++)            //     printf("%lf ",s[yo]);             //puts("");             sort(s,s+n-1-i);            //  for(int j=0;j<n-1-i;++j)              //   printf("%d ",s[j]);             int  c=1;             for(j=0;j<n-1-i;++j)             {                 if(s[j]==s[j+1])                     c++;                 else                 {                     if(c>mx)                         mx=c;                     c=1;                 }             }             //printf("max=%d\n",mx);         }         printf("%d\n",mx+1);     }     return 0; } 
#include<bits/stdc++.h> using namespace std; long int findhcf(long int a,long int b) { 	if(b%a==0) return a; 	return findhcf(b%a,a); } int main() { 	int t; 	long int x1,y1,x,y; 	cin>>t; 	while(t--) 	{ 		cin>>x1>>y1>>x>>y; 		x=fabs(x-x1); 		y=fabs(y-y1); 		if(x==0||y==0) {cout<<"0\n"; continue;} 		long int hcf=(x<y?findhcf(x,y):findhcf(y,x)); 		cout<<x+y-hcf<<"\n";		 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {         int n,ans=0,x;         cin>>n;         string s[1000],st="";         for(int i=0;i<n;i++)         {             cin>>s[i];         }         cin>>x;         for(int i=0;i<n;i++)         {             //ans=max(ans,count(s[i].begin(),s[i].end(),x));             char ch=x+'0';             int cnt=0;             for(int j=0;s[i][j];j++)             {                 if(s[i][j]==ch)                     cnt++;             }             if(cnt>ans)             {                 ans=cnt;                 st=s[i];             }         }         cout<<st<<endl;     }     return 0; } 
#include<bits/stdc++.h> #define gc getchar typedef long long int ll; using namespace std; ll read_int() { char c = gc(); while(c<'0' || c>'9') c = gc(); ll ret = 0; while(c>='0' && c<='9') { ret = 10 * ret + c - 48; c = gc(); } return ret; } bool isSubsetSum(ll a[], ll n, ll sum) {    if (sum == 0)      return true;    if (n == 0 && sum != 0)      return false;    if (a[n-1] > sum)      return isSubsetSum(a, n-1, sum);    return isSubsetSum(a, n-1, sum) || isSubsetSum(a, n-1, sum-a[n-1]); } int main() {     ll t,n,k,i;     cin>>t;     while(t--)     {         cin>>n>>k;         ll a[n+1];         for(i=0;i<n;i++)         {             cin>>a[i];         }         bool r=isSubsetSum(a,n,k);         if(r==true)             cout<<"YES\n";         else             cout<<"NO\n";     }     return 0; } 
// Tapan Sahni #include <algorithm> #include <iostream> #include <iterator> #include <numeric> #include <sstream> #include <fstream> #include <cassert> #include <climits> #include <cstdlib> #include <cstring> #include <string> #include <cstdio> #include <vector> #include <cmath> #include <queue> #include <deque> #include <stack> #include <list> #include <iomanip> #include <map> #include <complex> #include <set>  #define mod 1000000007  using namespace std; typedef long long LL;  const int N = 1000 + 10; const int inf = 1000000000;  int a[N]; int fdp[N][N] , fdp1[N][N]; vector <pair <int ,int> > v; int main() {   ios::sync_with_stdio(false) ; cin.tie(nullptr);   int t;   cin >> t;   while(t--) {     int n , k;     cin >> n >> k;     for(int i = 1; i <= n; i++) cin >> a[i];     int lis = 0;     for(int i = 0; i <= n + 1; i++)       for(int j = 0; j <= n + 1; j++){         fdp[i][j] = inf;         fdp1[i][j] = -1;       }     fdp[0][0] = 0;     for (int i = 1; i <= n; i++) {       for (int j = 0; j <= n; j++) {         fdp[i][j] = fdp[i - 1][j];         if (j && fdp[i - 1][j - 1] < a[i])           fdp[i][j] = min(fdp[i][j], a[i]);         if (fdp[i][j] != inf)           lis = max(lis, j);       }     }     fdp1[n + 1][0] = inf;     for (int i = n; i >= 1; i--){       for (int j = 0; j <= n; j++){         fdp1[i][j] = fdp1[i + 1][j];         if (j && fdp1[i + 1][j - 1] > a[i])           fdp1[i][j] = max(fdp1[i][j], a[i]);       }     }     LL ans = 0;     int r;     for (int i = 1; i < n; i++){       r = -1;       for (int j = 0; j <= lis; j++){         int j1 = lis - j;         if (fdp1[i + 1][j1] - fdp[i][j] > 1) {           if (fdp1[i + 1][j1] > k) {             if (fdp[i][j] >= r)               ans += max(k - fdp[i][j], 0);             else               ans += max(k - r + 1, 0);             break;           }           if (fdp[i][j] >= r)             ans += max(fdp1[i + 1][j1] - fdp[i][j] - 1, 0);           else             ans += max(fdp1[i + 1][j1] - r, 0);           r = fdp1[i + 1][j1];         }       }     }     ans += max(k - fdp[n][lis], 0);     ans += max(min(k, fdp1[1][lis] - 1), 0);     cout << ans << endl;   }      return  0; } // Never Quit 
#include<bits/stdc++.h> //#define inf 100000000 #define ll  long long #define pb push_back #define s(n) scanf("%d",&n) #define sl(n) scanf("%lld",&n)  #define p(n) printf("%lld\n",n) #define rep(i,a,n) for(i=a;i<=n;i++) #define vi vector<int> #define vii vector< vector<int> > #define vpii vector< pair<int,int> > #define mii map<int,int> #define pb push_back #define inf 1000000000LL #define mp make_pair #define MOD 1000000007LL #define N 1000007 using namespace std; ll powmod(long long a, long long b, long long c) {     ll ret=1LL;      while(b)     {         if(b & 1)             ret = (ret*a)%c;         a=(a*a)%c;          b>>=1;     }     return (ret)%c; } ll minverse(ll a,ll mod1) {     if(a==0LL)         return 1LL;     return powmod(a,(1LL*(mod1-2LL)),mod1)*1LL; } string s1; struct tree {  ll ans;  ll l;  ll r;  int f; }node[4*80000+5]; void build_tree(int idx,int l,int r) {  if(l==r)  {    if(s1[l]=='L')    {     node[idx].l=1;     node[idx].r=0;     node[idx].ans=0;    }    else    {       node[idx].l=0;     node[idx].r=1;     node[idx].ans=0;    }    node[idx].f=0;  }  else  {   int mid=(l+r)/2;   build_tree(2*idx+1,l,mid);   build_tree(2*idx+2,mid+1,r);   node[idx].l=node[2*idx+1].l+node[2*idx+2].l;   node[idx].r=node[2*idx+1].r+node[2*idx+2].r;   node[idx].ans=node[2*idx+1].ans+node[2*idx+2].ans+node[2*idx+1].r*node[2*idx+2].l;   node[idx].f=0;  } } void update(int idx,int l,int r,int ql,int qr) {  if(node[idx].f==1)  {   ll val1=node[idx].l;   ll val2=node[idx].r;   ll tot=(ll)(r-l+1)*(r-l)/2;   swap(node[idx].l,node[idx].r);   node[idx].ans=tot-node[idx].ans-(val1)*(val1-1)/2-(val2)*(val2-1)/2;   node[idx].f=0;   if(l<r)   {    node[2*idx+1].f=(node[2*idx+1].f)^1;    node[2*idx+2].f=(node[2*idx+2].f)^1;   }  }  if(ql>r||qr<l||l>r)  return;  if(ql<=l && qr>=r)  {    ll val1=node[idx].l;     ll val2=node[idx].r;    ll tot=(ll)(r-l+1)*(r-l)/2;    swap(node[idx].l,node[idx].r);    node[idx].ans=tot-node[idx].ans-(val1)*(val1-1)/2-(val2)*(val2-1)/2;    if(l<r)    {    node[2*idx+1].f=(node[2*idx+1].f)^1;    node[2*idx+2].f=(node[2*idx+2].f)^1;    }  }  else  {    int mid=(l+r)/2;    update(2*idx+1,l,mid,ql,qr);    update(2*idx+2,mid+1,r,ql,qr);    node[idx].l=node[2*idx+1].l+node[2*idx+2].l;   node[idx].r=node[2*idx+1].r+node[2*idx+2].r;   node[idx].ans=node[2*idx+1].ans+node[2*idx+2].ans+node[2*idx+1].r*node[2*idx+2].l;  } } int main() {  int n,i,n1,n2; s(n); cin>>s1; build_tree(0,0,n-1); /*cout<<node[0].l<<" "<<node[0].r<<" "<<node[0].ans<<endl;  cout<<node[1].l<<" "<<node[1].r<<" "<<node[1].ans<<endl;  cout<<node[2].l<<" "<<node[2].r<<" "<<node[2].ans<<endl;*/ int q; cin>>q; while(q--) {  s(n1);s(n2);  update(0,0,n-1,n1,n2);  /*cout<<node[0].l<<" "<<node[0].r<<" "<<node[0].ans<<" "<<node[0].f<<endl;  cout<<node[1].l<<" "<<node[1].r<<" "<<node[1].ans<<" "<<node[1].f<<endl;  cout<<node[2].l<<" "<<node[2].r<<" "<<node[2].ans<<" "<<node[2].f<<endl;*/  p(node[0].ans); } } 
#include <cstdio> #include <cstdlib> #include <algorithm> #include <queue> #include <cmath> #include <cstring> #include <iostream> #include <stack> #include <map> #include <vector> #include <utility> #include <set>  #define MOD (1000000007) #define MAXINT 1e9 #define EPS (1e-9) #define mp   make_pair #define pb   push_back #define fi   first #define se   second #define pii  pair<int,int>  #define pll  pair<long long,long long>   using namespace std; typedef long long int ll;   ll gcd(ll a,ll b) { 	if(a<b)	return gcd(b,a); 	if(b==0)	return a; 	return gcd(b,a%b); }  int main() { 	ll a,b,g,test,n; 	cin>>test; 	while(test--) 	{ 		cin>>n; 		a=(n*(n-1)); 		b=8; 		g=gcd(a,b); 		a=a/g; 		b=b/g; 		cout<<a<<"/"<<b<<endl; 	} 	return 0; }
#include<stdio.h> #define MOD 1000000007 int fac[2000001]; int modpow(int b){ 	long long res=1,base=b; 	int exp=MOD-2; 	while(exp>0){ 		if(exp&1){ 			res=res*base; 			if(res>=MOD)res%=MOD; 		} 		base=base*base; 		if(base>=MOD)base%=MOD; 		exp>>=1; 	} 	return res; } void init() { 	int i; 	long long temp; 	fac[0]=1; 	for(i=1;i<2000001;i++) 	{ 		temp=fac[i-1]; 		temp*=i; 		if(temp>=MOD)temp%=MOD; 		fac[i]=temp; 	} } int main() { 	int t,n,ans; 	long long num,den; 	init(); 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d",&n); 		num=fac[2*n-1]; 		den=fac[n-1]; 		den*=den; 		if(den>=MOD)den%=MOD; 		num*=modpow(den); 		if(num>=MOD)num%=MOD; 		printf("%lld\n",num); 	} 	return 0; }  
#include<iostream> #include <string.h> #include<math.h> #include <algorithm> #include<stdio.h>  using namespace std;  bool p[1000100]; int primes[100000];  int main() {int k=0,i,j;  long long a,b,z,number,x,y;     for (i=2;i<1000000;i++)  {      if (p[i]==0)      {                primes[k++]=i;                       for (j=i+i;j<1000000;j+=i)                       p[j]=1;      }   }   long long u=k;  int t;  long long product,check,exp,temp;  scanf("%d",&t);    while(t--)  {   scanf("%lld %lld %lld",&x,&y,&z);             k=0;   number=z;   while(z>1 && primes[k]*primes[k]<=number && k<u)   {        a=0;     while(z%primes[k]==0)                       {                                      a++;                                            z/=primes[k];                                                                 }     k++;    }           if (z==1)   {   check=primes[--k];            }           else   {       check=z;       a=1;   }                product=x*y;           exp=0;          temp=check;      while(product)     {     exp+= product/temp;            product=product/temp;           }                   printf("%lld\n",exp/a);            }                   return 0; }
#include<iostream> #include<vector> using namespace std;   int main() { 	int n,q; 	scanf("%d %d",&n,&q); 	 	int sum=0; 	vector<int> array(n); 	for(int i=0;i<n;i++) 	{ 		scanf("%d",&array[i]); 		sum+=array[i]; 	} 	 	vector<long long> Sum(sum+1); 	 	Sum[0]=1; 	 	for(int i=0;i<array.size();i++) 	{ 		for(int last=sum,first=sum-array[i];first>=0;first--,last--) 			Sum[last]|=Sum[first]<<1; 	} 	 	while(q--) 	{ 		int s,k; 		scanf("%d %d",&s,&k); 		if(s<Sum.size()&&Sum[s]&(((long long)1)<<k)) 			printf("YES"); 		else 			printf("NO"); 		printf("\n"); 	} 	 }
#include<bits/stdc++.h> using namespace std; #define ll long long int main() {     ll t,n,maxi,i,flag;     scanf("%lld",&t);     while(t--)     {         i=2;         flag=0;         scanf("%lld",&n);         while(n!=0)         {             if(n%i!=0)                 i++;             else             {                 while(n%i==0)                 {                     maxi=n;                 n=n/i;                 if(n==1)                 {                     printf("%lld\n",maxi);                     flag=1;                     break;                 }                 }                 if(flag)                     break;             }         }     }     return 0; } 
#include <iostream> #include <math.h> #include <stdio.h> #include <iomanip> using namespace std; double logfac[1000001]; int main() {int t; cin>>t; while(t--) {int n,k; cin>>n>>k; k=min(k,n-k); logfac[0]=0; for(int i = 1;i<=k;i++) {logfac[i]=logfac[i-1]+log2((long double)(n-i+1)/((long double)i));}  int z=k;  double ans=0; while(k>=0) {double x=logfac[k]; long double z = pow(2,x+1-n);  ans+=100.0*z;  if(k*z<1e-4) {break;} k--;}  printf("%.1f\n", ans);} return 0;}   
#include <iostream> using namespace std;  int main() {     int t; cin>>t;     while(t--)     {         int n; cin>>n;         int count=1;         for(int i=2;i<=(n/2);i++)         {             if(n%i==0)             count=(count*i)%10000;         }         if(count==0)         cout<<"0000"<<endl;         else         cout<<count<<endl;     }     return 0; } 
#include<bits/stdc++.h>  using namespace std;  #define in(a,x,y) (a>=x && a<=y) #define out(a,x,y) (!in(a,x,y)) #define sz(a) ((int)a.size()) #define repv(i,a) for(int i=0;i<sz(a);i++) #define revv(i,a) for(int i=sz(a)-1;i>=0;i--) #define rep(i,a,b) for(int i=a;i<=b;i++) #define rev(i,a,b) for(int i=a;i>=b;i--) #define all(a) a.begin(),a.end() #define pb push_back  #define AND(a,b) ((a) & (b)) #define OR(a,b) ((a)|(b)) #define XOR(a,b) ((a) ^ (b)) #define xx first #define yy second #define mp make_pair #define sqr(x) ((x)*(x)) #define sqrt(x) sqrt(1.0*(x))  #define LB(a,x) (lower_bound(all(a),x)-a.begin()) //  first element in the range [first,last) which does not compare less than val. #define UB(a,x) (upper_bound(all(a),x)-a.begin()) //  first element in the range [first,last) which compares greater than val. #define forit(it, s) for(__typeof(s.begin()) it = s.begin(); it != s.end(); it++) #define left nokol_left #define right nokol_right #define countbit(x) __builtin_popcountll((ll)x) #define PQ priority_queue #define FAST ios_base::sync_with_stdio(0);cin.tie(0); #define Unique(store) store.resize(unique(store.begin(),store.end())-store.begin()) #define READ(f) freopen(f, "r", stdin) #define WRITE(f) freopen(f, "w", stdout)  typedef long long ll; typedef unsigned int uint; typedef unsigned long long ull; typedef pair<int,int> pii; typedef pair<long long,long long> pll; typedef vector<int> vi; typedef vector<long long> vll;  template<class T>T __sqr(const T x){return x*x;} template< class T, class X > inline T __pow(T a,X y) {T z=1; rep(i,1,y){z*=a;} return z; } template< class T > inline T gcd(T a,T b) {a=abs(a);b=abs(b); if(!b) return a; return __gcd(b,a%b);} template< class T > inline T lcm(T a,T b) {a=abs(a);b=abs(b); return (a/__gcd(a,b))*b;} inline bool ispow2(int x){return (x!=0 && (x&(x-1))==0);} template<class T>void UpdateMin(T &x,T y){  if(y<x){x=y;}} template<class T>void UpdateMax(T &x,T y){if(x<y){x=y;}} template<class T,class X, class Y > inline T bigmod(T n,X m,Y mod){ull ret=1, a = n%mod ; while(m){ if(m&1)ret=(ret*a)%mod; m>>=1; a=(a*a)%mod; }ret%=mod;return (T)ret;} template<class T, class Y > inline T modinv(T n,Y mod) {return bigmod(n,mod-2,mod);}  template<class T,class X> int getbit(T s,X i) { return (s >> i) & 1; } template<class T,class X> T onbit(T s, X i) { return s | (T(1) << i); } template<class T,class X> T offbit(T s, X i) { return s & (~(T(1) << i)); } template<class T> inline void read(T &n){char c;for (c = getchar(); !(c >= '0' && c <= '9'); c = getchar()); n = c - '0';for (c = getchar(); c >= '0' && c <= '9'; c = getchar()) n = n * 10 + c - '0';}  void extended_euclid(ll a,ll b,ll &x,ll &y){ if(!b){ x = 1 , y = 0  ;  return ;} ll xx,yy; extended_euclid(b,a%b,xx,yy); x = yy; y = xx - (a/b)*yy; } pair<ll, pair<ll, ll> > extendedEuclid(ll a, ll b) { ll x = 1, y = 0; ll xLast = 0, yLast = 1; ll q, r, m, n; while(a != 0) {q = b / a; r = b % a; m = xLast - q * x; n = yLast - q * y; xLast = x, yLast = y; x = m, y = n; b = a, a = r; } return make_pair(b, make_pair(xLast, yLast)); }  const ll mod[]  ={0,1000000007,1000000009,1000000021,1000000033,1000000097,1000000093,1000000097,1000000103}; //const ll base[] ={0,1000003,1000033,1000037,1000039,1000081,1000099,1000117,1000121};  #define pi acos(-1.0) #define eps  1e-12 #define MX   (lmt+20) #define inf  1000000000000000000LL #define MOD  1000000007LL //---------->0123456789123465789 #define lmt  800000  int N,i,j; struct base {     double real, imag;     base(){real=0.0; imag=0.0;}     void clr(){real=0.0; imag=0.0;} } a[MX], b[MX]; void fft (base* a, int n, bool invert); inline base multiply(const base& left, const base& right);  ll cnt[MX] , ans;  void calc_fft(ll x){          int n = 1 , mx = max(N, N);         while (n <  mx )  n <<= 1;         n<<=1;  //        cout<<"N == > "<<n<<endl;          fft(a, n, false);         fft(b, n, false);         for(i=0;i<n;i++){             a[i] = multiply(a[i], b[i]);         }         fft(a, n, true);          rep(i,0,n-1){             cnt[i] += (ll)x * (ll)(a[i].real + .5);         }          return ; }  int  c[MX] , d[MX];  int main() {     int ts , k;     scanf("%d",&ts);      while(ts--){                scanf("%d%d",&N,&k);              memset(c , 0 , sizeof c);             memset(d , 0 , sizeof d);               memset(cnt , 0 , sizeof cnt);              rep(i,0,N-1) scanf("%d",c+i);              rev(i,k-1,0) scanf("%d",d+i);              rep(i,1,3){                 rep(j,1,3){ ll x;                     scanf("%lld",&x);                     // input type                      rep(k,0,4*N){ a[k].clr();b[k].clr(); }                      rep(k,0,N-1){                         a[k].real = (c[k]==i);                         b[k].real = (d[k]==j);                     }                      calc_fft(x);                 }              }               ll ans = inf;               rep(i,k-1,N -1){ // //                cout<<cnt[i]<<" ";                 ans = min(ans , cnt[i]);              } //             cout<<endl;              printf("%lld\n",ans);     }      return 0; }  /* aaaccc caccacaa */  void fft (base* a, int n, bool invert) { 	for (int i=1, j=0; i<n; ++i) 	{ 		int bit = (n >> 1); 		for (; j>=bit; bit>>=1) 			j -= bit; 		j += bit; 		if (i < j) 			swap (a[i], a[j]); 	}  	for (int len=2; len<=n; len<<=1) 	{ 		double ang = 2*pi/len * (invert ? -1 : 1);  		double cs = cos(ang); 		double sn = sin(ang);  		for (int i=0; i<n; i+=len) 		{ 			ll hlen = (len >> 1);  			double wreal = 1; 			double wimag = 0; 			base u;  			base* pa1 = a + i; 			base* pa2 = a + i + hlen;  			for (int j=0; j<hlen; ++j) 			{ 				base& a1 = *pa1++; 				base& a2 = *pa2++;  				u = a1;  				double vreal = a2.real * wreal - a2.imag * wimag; 				double vimag = a2.real * wimag + a2.imag * wreal;  				a1.real += vreal; 				a1.imag += vimag;  				a2.real = u.real - vreal; 				a2.imag = u.imag - vimag;  				double wreal2 = wreal;  				wreal = wreal * cs - wimag * sn; 				wimag = wreal2 * sn + wimag * cs;   			} 		} 	} 	if (invert) 		for (int i= n; i >= 0; --i) 			a[i].real /= n; }  inline base multiply(const base& left, const base& right) { 	base res; 	res.real = left.real * right.real - left.imag * right.imag; 	res.imag = left.real * right.imag + left.imag * right.real;  	return res; } 
#include<iostream> #include<cmath> #include<cstring> #include<cstdio> //#include<conio.h> using namespace std;   #ifndef ONLINE_JUDGE #define getchar_unlocked() getchar() #endif // ONLINE_JUDGE   inline int input(){int n=0,ch=getchar_unlocked();while(ch<48)ch=getchar_unlocked();while(ch>47)n=(n<<3)+(n<<1)+ch-'0',ch=getchar_unlocked();return n;}   void solve(int n) {     double d=(double)(2*n);     d=sqrt(d);     //cout<<d<<endl;     int x=(int)(d+0.5);     printf("%d\n",x); }   int main() {     int t;     cin>>t;     while(t--)     {         int n;         n=input();         solve(n);     }     //getch();     return 0; } 
#include<cstdio> inline void fastRead_int(long long int &x) {     register long long int c = getchar_unlocked();     x = 0;     long long neg = 0;      for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked());      if(c=='-') {         neg = 1;     	c = getchar_unlocked();     }      for(; c>47 && c<58 ; c = getchar_unlocked()) {     	x = (x<<1) + (x<<3) + c - 48;     }      if(neg)     	x = -x; } int main(){ long t; scanf("%ld",&t); while(t--){     long long int p,q;     fastRead_int(p);     fastRead_int(q);     if((p&1)&&(q&1))         printf("B\n");     else         printf("A\n"); } return 0; } 
#include<bits/stdc++.h> #define fr first #define se second using namespace std; int tree[1000005]; pair<int,int> a[1000005]; int m;int n; int visited[1000005]; struct triple {     int x,y,z; }p[1000005]; int marks[100005]; inline void update(int idx,int val){      while(idx<=m && idx>0) {         tree[idx]+=val;         idx+=(idx&-idx);     } } inline int  query(int idx) {     int sum=0;     while(idx>0) {         sum+=tree[idx];         idx-=(idx&-idx);     }     return sum; } bool cmp(struct triple a,struct triple b) {     return a.y<b.y; } int ans[1000000]; int main() {     scanf("%d",&n);     for(int i=1;i<=n;i++) {         scanf("%d",&marks[i]);     }     scanf("%d",&m);     for(int i=1;i<=m;i++) {         int x;         scanf("%d",&x);         a[i].fr=x;         a[i].se=marks[x];     }     int cnt=1;     for(int i=m+1;i<=2*m;i++) {         a[i].fr=a[cnt].fr;         a[i].se=a[cnt].se;         cnt++;     }     m=2*m;     int q;scanf("%d",&q);     for(int i=1;i<=q;i++) {         scanf("%d%d",&p[i].x,&p[i].y);             p[i].y=p[i].x+p[i].y-1;             p[i].z=i;     }     sort(p+1,p+q+1,cmp);     int j=1;     for(int i=1;i<=q;i++) {         while(j<=p[i].y) {             if(!visited[a[j].first]) {                 visited[a[j].first]=j;                 update(j,a[j].second);      //         cout<<query(j)-query(0)<<endl;              }              else {                 update(visited[a[j].first],-a[j].second);                 visited[a[j].first]=j;                 update(j,a[j].second);    //           cout<<query(j)-query(0)<<endl;             }             j++;         }         ans[p[i].z]=query(p[i].y)-query(p[i].x-1); //      cout<<query(p[i].y)<<" "<<query(p[i].x-1)<<endl;     }     for(int i=1;i<=q;i++) {         printf("%d\n",ans[i]);     } } 
#include <iostream> #include <cstdio> #include <algorithm> #include <cstring> #include <string> #include <cctype> #include <stack> #include <queue> #include <list> #include <vector> #include <map> #include <sstream> #include <cmath> #include <bitset> #include <utility> #include <set> #define pi acos(-1.0) using namespace std; typedef long long ll; typedef vector<int> vi; typedef vector<ll> vll; typedef pair<int, int> ii; typedef vector<ii> vii; typedef set<int> si; typedef map<string, int> msi; int a[1000000+1]={0}; int b[1000000+1]={0}; #define mmin(a,b,c) min(a,min(b,c)) int main() { 	string s,t; 	ll p,t1,n; 	cin>>t1; 	while(t1--) 	{ 		cin>>s; 		fill(a,a+1000000+1,0); 		if(s[0]=='L') 		{ 			a[0]=1; 		} 		for(int i=1;i<s.length();i++) 		{ 			a[i]=a[i-1]; 			if(s[i]=='L') 			{ 				a[i]++; 			} 		} 		if(s[s.length()-1]=='L') 		{ 			b[0]=1; 		} 		for(int i=s.length()-1;i>=0;i--) 		{ 			b[i]=b[i+1]; 			if(s[i]=='L') 			{ 				b[i]++; 			} 		} 		vi v; 		ll sum=0; 		for(int i=0;i<s.length();i++) 		{ 			if(s[i]=='O') 			{ 				sum+=(a[i]*b[i]); 			} 		} 		 		cout<<sum<<endl; 	}  return 0;  } 
#include<iostream> #include<string.h> using namespace std;  int abs(int a,int b){ 	if(a>=b){ 		return a-b; 	} 	else{ 		return b-a; 	} 	 }  int main(){ 	int t; 	cin>>t; 	while(t--){ 		char a[1001], b[1001]; 		int x[26]={0}, y[26]={0}; 		cin>>a>>b; 		int l=strlen(a); 		int m=strlen(b); 		for(int i=0; i<l; i++){ 			if(a[i]<'a'){ 				x[a[i]-'A']++; 			} 			else{ 				x[a[i]-'a']++; 			} 			 		} 		for(int i=0; i<m; i++){ 			if(b[i]<'a'){ 				y[b[i]-'A']++; 			} 			else{ 				y[b[i]-'a']++; 			} 		} 		long long int sum=0; 		for(int i=0; i<26; i++){ 			sum+=abs(x[i],y[i]); 		} 			cout<<sum<<endl; 		 	} }
#include<iostream> #include<cstdio> #include<cmath> #include<cstring> #include<stdlib.h> #include<algorithm> #define getcx getchar_unlocked #define pc(x) putchar_unlocked(x); #ifndef ONLINE_JUDGE     #define getcx getchar #endif using namespace std; #define ull unsigned long long int #define lli long long int #define li long int #define ii int #define mod 1000000007 ii A[201][201]; ii b[201][201]; ii mark[201][201]; ii d[] = {-1,0,1}; ii n,m;  inline ii dfs ( ii i, ii j, ii k ) { 	ii val=0; 	for ( ii p=0;p<3;p++ ) 	{ 		for ( ii q=0;q<3;q++ ) 		{ 			if ( i+d[p]>=0 && i+d[p]<n && j+d[q]>=0 && j+d[q]<m ) 			{ 				if ( A[i+d[p]][j+d[q]]==k+1 ) 					val = max(val,dfs(i+d[p],j+d[q],k+1)); 			} 		} 	}  	return val+1;  }  ii main() { 	//your code goes here 	ii t,i,j,ans;  	cin>>t; 	while(t--) 	{ 		cin>>n>>m; 		for ( i=0;i<n;i++ ) 			for ( j=0;j<m;j++ ) 				cin>>A[i][j];  		ans=0; 		for ( i=0;i<n;i++ ) 		{ 			for ( j=0;j<m;j++ ) 			{ 				if ( A[i][j]==0 ) 				{ 					ans = max(ans,dfs(i,j,0)); 					//memset(mark,0,sizeof(mark)); 				} 			} 		} 		printf("%d\n",ans);  	} 	return 0; } 
/* Sab moh maya hai  _._ _..._ .-',     _.._(`)) '-. `     '  /-._.-'    ',/    )         \            '.   / _    _    |             \  |  a    a    /              |  \   .-.                     ;   '-('' ).-'       ,'       ;      '-;           |      .'         \           \    /         | 7  .__  _.-\   \         | |  |  ``/  /`  /        /,_|  |   /,_/   /           /,_/      '`-' */ #include<bits/stdc++.h> using namespace std; typedef long long ll; typedef vector<int> vi; typedef pair<int,int> pii; typedef pair<ll,ll> pll; typedef vector<pii> vpii; typedef unsigned long long llu;  #define debug(x) cerr<<#x<<" "<<x<<endl; #define f first #define s second #define mp make_pair #define pb push_back int main() {     int t,n;     scanf("%d",&t);     while(t--)     {         scanf("%d",&n);         int k=sqrt(n);         if(n&1)             printf("%d\n",n-k);         else             printf("%d\n",k);     }     return 0;  } 
#include <bits/stdc++.h>  using namespace std;  int main() {     unsigned long long int t,d,r,p,num;     scanf("%llu %llu",&t,&d);     while(t--)     {         scanf("%llu %llu",&num,&p);         r=num%d;         if(r==0 || r==1)         {             cout<<r<<endl;         }         else         {             r=pow(r,p);             r=r%d;             printf("%llu\n",r);         }      }     return 0; } 
#include <iostream> using namespace std;  int getbits(int temp){ 	 	int n =0; 	 	while(temp){ 		if(temp%2!=0) 		n++; 		 		temp/=2; 	} 	 	return n; }  int main() { 	// your code goes here 	int n; 	cin>>n; 	 	while(n--){	 	int cnt=0; 		 	int a,b; 	cin>>a>>b; 	 	if(a!=b){ 		cnt = getbits((a^b)); 	} 	 	cout<<cnt<<endl; 	} 	 	return 0; }
#include<bits/stdc++.h> #define pii pair<int,int> #define Min(a,b) ((a<b) ? a:b) #define Max(a,b) ((a > b) ? a:b) #define Swap(a,b) (a=b+a-(b=a)) #define sn(n) scanf("%d",&n) #define schr(n) scanf("%c",&n) #define ss(n) scanf("%s",n) #define p(n) printf("%d",n) #define el putchar("\n"); #define sp putchar('') #define Fill(a,val) memset(a,val,sizeof(a)) #define pb push_back #define INFN 123456789 #define ll long long #define si short int #define vi vector<int> #define vvi vector<vvi> #define ITER(i,a) for( typeof(a.begin()) i=a.begin();i!=a.end();i++) #define _I int #define _D double #define _L long long  using namespace std; int gcd(int a,int b){ 	return (!b) ? a:gcd(b,a%b); }  char arr[10002]; _I ac,bc;  void func(){ 	_I i,j,len = strlen(arr); 	char n; 	_I tot_c = 0; 	_I min_c = 0; 	char rep_char; 	if(ac < bc) { 		min_c = ac; 		rep_char = 'a'; 	} 	else{ 		min_c = bc; 		rep_char = 'b'; 	} 	_I cnt = 0; 	for(i=0;i < len/2;i++){  		if(arr[i] == '/' && arr[len-i-1] == '/'){ 			tot_c += (2*min_c); 		} 		else if((arr[i] == 'a' && arr[len-i-1] == '/') || (arr[i] == '/' && arr[len-i-1] == 'a')){ 			tot_c += ac; 		} 		else if((arr[i] == 'b' && arr[len-i-1] == '/') || (arr[i] == '/' && arr[len-i-1] == 'b') ){ 			tot_c += bc; 		} 		else if(arr[i] != arr[len-i-1]){ 			cnt = 1; 			break; 		} 	} 	if(cnt){ 		cout << "-1" << endl; 	} 	else{ 		cout << tot_c << endl; 	} }  char N[10021] = {0}; void func1(){ 	if(N[0] & 1) { 		cout << "ODD" << endl; 	} 	else{ 		cout << "EVEN" << endl; 	} 	 }  _L a[100005];  void func2(_L N){ 	_I cnt = 0; 		for(_I i=0; i < N-1;i++){ 			for(_I j=i+1;j < N;j++){ 				if((a[i] ^ a[j] ) & 1){ 					cnt++; 				} 			} 		} 		cout << cnt << endl; }  _I dp[20][20];  void func3(_L N){ 	for(_I i=0;i < N+1;i++){ 		for(_I j=0;j<N+1;j++){ 			dp[i][0]=dp[0][i]=1; 		} 	} 	for(_I i=1;i<N+1;i++){ 		for(_I j=1;j<N+1;j++){ 			dp[i][j] = dp[i-1][j] + dp[i][j-1]; 		} 	} 	cout << dp[N][N] << endl; }  void func4(char s[1000001]){ 	_I i,j; 	_I len = strlen(s); 	_I mx = 0,cnt = 0,cnt_r=0 ; 	for(i = 0; i < len ;i++){ 		if(s[i]=='K')cnt++; 		else cnt--,cnt_r++; 		if(cnt < 0) cnt = 0; 		mx = max(mx,cnt); 	} 	cout << mx+cnt_r << endl; 	 }  _I main(){ 	_I t; 	cin >> t; 	char s[1000001]; 	for(_I test = 0;test < t;test++){ 		cin >> s; 		func4(s); 	} 	return 0; 	 }
#include<iostream> #include<math.h> using namespace std; int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		long int n; 		long int ans=0; 		cin>>n; 		if(n%2==0) 		{ 			ans=0; 		} 		else 		{ 			for(long int i=1;i<=n;i=i+2) 			{ 				ans=ans^i; 			} 		} 		cout<<ans<<"\n"; 	}  }
#include<stdio.h> #include<stdlib.h> #include<math.h> #include<string.h> #include<assert.h>  #define REP(i,a,b) for(i=a;i<b;i++) #define rep(i,n) REP(i,0,n)  #define ll long long #define M 1000000007  int main(){   int T;   char in[20000];   int n, i, j;   int cnt[10], a, b, c, d, sum, use[10];   ll res, tmp;    scanf("%d",&T);     while(T--){ 		scanf("%s",in);     //assert( scanf("%s",in)==1 );     n = strlen(in);     //assert( 1<=n && n<=10000 );     //rep(i,n) assert( '0'<=in[i] && in[i]<='9' );      rep(i,n) in[i] -= '0';      rep(i,10) cnt[i] = 0;     rep(i,n) cnt[in[i]]++; /* cnt[i] = the number of digits i in the input string */      res = 0;     rep(a,11) REP(b,a,11) REP(c,b,11) REP(d,c,11)     { /* use digits a, b, c and d. (if x=10, then x is unused) */       sum = 0;       rep(i,10) use[i] = 0;       if(a < 10) sum += a, use[a]++;       if(b < 10) sum += b, use[b]++;       if(c < 10) sum += c, use[c]++;       if(d < 10) sum += d, use[d]++;       if(sum==0 || sum%9) continue;       tmp = 1;       rep(i,10) rep(j,use[i]) tmp = tmp * (cnt[i]-j) / (j+1); /* the combination will fit in long long:) */       res += tmp;     }      printf("%d\n",(int)(res%M));   }    return 0; } 
#include <stdio.h>  int main() { 	int n,i; 	scanf("%d",&n); 	long long temp,k=0; 	for(i=1;i<n;i++){ 		scanf("%lld",&temp); 		k=k+(temp-1)*i; 		 	} 	scanf("%lld",&temp); 	k=k+temp*n; 	printf("%lld",k); 	return 0; }
#include<cstdio> #include<iostream> #include<cstring> using namespace std; typedef unsigned long long ll; ll  MOD=ll( 1000000007); ll Fibo(int n)     {         ll  fib[2][2]={{1,1},{1,0}},ret[2][2]={{1,0},{0,1}},tmp[2][2]={{0,0},{0,0}};         while(n)         {             if(n&1)              {                 memset(tmp,0,sizeof tmp);                 for(int i=0;i<2;i++) for(int j=0;j<2;j++) for(int k=0;k<2;k++)                          tmp[i][j]=(tmp[i][j]+ret[i][k]*fib[k][j])%MOD;                 for(int i=0;i<2;i++) for(int j=0;j<2;j++) ret[i][j]=tmp[i][j];             }             memset(tmp,0,sizeof tmp);             for(int i=0;i<2;i++) for(int j=0;j<2;j++) for(int k=0;k<2;k++)                                     tmp[i][j]=(tmp[i][j]+fib[i][k]*fib[k][j])%MOD;                         for(int i=0;i<2;i++) for(int j=0;j<2;j++) fib[i][j]=tmp[i][j];             n/=2;           }         return (ret[0][1])%MOD;     }       int main()     {         int t;         long long int m,n;         for(scanf("%d",&t);t>0;t--)         {             scanf("%lld%lld",&n,&m);             cout<<(Fibo(m+2+1)-Fibo(n+1+1)+MOD)%MOD<<endl;;         }     } 
#include<vector> #include<algorithm> #include<iostream> #include<cmath> #include<cstring> #include<cstdio> #include<map> #include<set> using namespace std;  typedef long long int lli;  int main() {     int t;     cin>>t;     while(t--)     {         int n;         long long int f;         cin>>n>>f;         long long int arr[n];         for(int i=0;i<n;i++)             cin>>arr[i];         long long int space;         sort(arr,arr+n);         cin>>space;         long long int ans = 0;         if(n<=space)         {             for(int i=0;i<n;i++)                 ans += arr[i];             space = space-n;             ans -= space*f;             cout<<ans<<endl;         }         else         {             for(int i=0;i<space;i++)                 ans += arr[i];             cout<<ans<<endl;         }     }     return 0; } 
 #include<bits/stdc++.h> #define all(x) x.begin(), x.end() #define pb(x) push_back(x) #define cout2(x, y) cout << x << " " << y << endl #define N 2005 #define MOD 1000000007  using namespace std;  int oddPal[N], evenPal[N];  int P[N]; bool vis[N];  int Find(int x){ 	 	if(x == P[x])return x; 	return P[x] = Find(P[x]);	 }  void Union(int x, int y){ 	 	x = Find(x); 	y = Find(y); 	P[x] = y;	 }  int main(){  	int tc = 0; 	scanf("%d", &tc); 	 	while(tc--){ 		 		int n, m; 		scanf("%d%d", &n, &m);	 		 		for(int i = 0; i <= n; i++){ 			 			oddPal[i] = evenPal[i] = 0; 			P[i] = i; 			vis[i] = false; 		} 			 		int l, r; 		for(int i = 0; i < m; i++){ 			 			scanf("%d%d", &l, &r); 			l--, r--; 			 			if((r - l + 1)&1)oddPal[(r + l)>>1] = max(oddPal[(r + l)>>1], r);	 			else evenPal[(r + l)>>1] = max(evenPal[(r + l)>>1], r); 			 		} 		 		for(int i = 0; i < n; i++){ 			for(int j = i, len, c; j < n; j++){ 				 				len = (j - i + 1); 				c = ((i + j)>>1); 				 				if((len&1) && oddPal[c] >= j)Union(i, j); 				else if((len&1) == 0 && evenPal[c] >= j)Union(i, j);	 			} 		} 		 		long long ans = 1; 		for(int i = 0; i < n; i++){ 			 			if(vis[Find(i)])continue;	 			vis[Find(i)] = true; 			 			ans = ans * 26; 			if(ans >= MOD)ans %= MOD; 		}  		printf("%lld\n", ans); 	}   } 
#include<bits/stdc++.h> using namespace std; #define sc(a) scanf("%lld",&a) #define pr(a) printf("%lld",a) typedef long long ll; int a[100000]; int main() { 	ll n,t,i,j; 	sc(t); 	while(t--) 	{ 		sc(n); 		for(i=0;i<n;i++) 			sc(a[i]); 		sort(a,a+n); 		ll ctr=1, maxCtr = 0, elem = a[0]; 		for(i=1;i<n;i++) 		{ 			if(i>0 && a[i]!=a[i-1]) 			{ 				if(ctr>maxCtr) 				{ 					maxCtr = ctr; 					elem = a[i-1]; 				} 				ctr = 1; 			} 			if(a[i]==a[i-1]) 				ctr++; 		} 		if(maxCtr > n/2) 			pr(elem); 		else 			printf("NO MAJOR"); 		printf("\n"); 	} 	return 0; }
#include<stdio.h> #include<math.h>  using namespace std; int main(){ int t,i; int n; scanf("%d",&t); while(t--) {   double sum=0;    int temp=5;     scanf("%d",&n);    while(n!=0)    {     if(n&1)         sum+=temp;     temp*=5;      n=n>>1;     }    printf("%.0f\n",sum);    }   return 0; } 
#include <iostream> #include <stdio.h> #include <string>  using namespace std;  int main() { 	 	int t, i, k, n; 	 	scanf("%d", &t ); 	cin.ignore(); 	 	while( t-- ) { 		 		string str1, str2, str3; 		 		getline( cin, str1 ); 		getline( cin, str2 ); 		 		str3 = str1 + str1; 		n = str3.length(); 		 		k = str3.find( str2 ); 		 		if( ( k >= 0 ) && ( k < n ) ) 			printf("YES\n"); 		else 			printf("NO\n"); 		 		str1.clear(); 		str2.clear(); 		str3.clear(); 		 	} 	return 0; } 
    #include <iostream>     #include<cmath>     #include<algorithm>     #define tiny 1e-3     using namespace std;           int main()     {     	int n;     	cin>>n;     	int x1,y1,x2,y2,x3,y3;     	for(int i=1;i<=n;i++)     	{     	   cout<<"Case #"<<i<<": ";     	   cin>>x1>>y1>>x2>>y2>>x3>>y3;     	   int flag=0;     	   int asq=(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);     	   int bsq=(x2-x3)*(x2-x3)+(y2-y3)*(y2-y3);     	   int csq=(x3-x1)*(x3-x1)+(y3-y1)*(y3-y1);     	   double a=sqrt(1.0*asq);     	   double b=sqrt(1.0*bsq);     	   double c=sqrt(1.0*csq);     	     	   int arr[3];            arr[0] = asq;  arr[1] = bsq;  arr[2] = csq;            sort(arr, arr + 3);     	   asq= arr[0];  bsq = arr[1];  csq = arr[2];     	   if((a+b-c>tiny) && (a+c-b>tiny) && (b+c-a>tiny) )     	   flag=1;     	   if(flag!=1)     	   {     	      cout<<"not a triangle\n";     		  continue;     		       	    }     	     	if(asq==bsq || asq==csq || bsq==csq )     	{     		if((asq+bsq==csq))     			{     				cout<<"isosceles right triangle\n";     				continue;     			}     		else if((asq+bsq<csq))      		   {     		    	cout<<"isosceles obtuse triangle\n";     			    continue;     		   }     			else if((asq+bsq>csq) )      			{     				cout<<"isosceles acute triangle\n";     				continue;     			}     	}     	else     	{     		  	if((asq+bsq==csq))     			{     				cout<<"scalene right triangle\n";     				continue;     			}     			else if((asq+bsq<csq))      			{     				cout<<"scalene obtuse triangle\n";     				continue;     			}     			else if((asq+bsq>csq) )      			{     				cout<<"scalene acute triangle\n";     				continue;     			}     	}     	}     	     	     	return 0;     } 
// Author: thecodekaiser #include <iostream> #include <cstdlib> #include <cstring> #include <cstdio>  using namespace std;  void solve() { 	int marks[5][101]; 	int cnt[5];  	memset(marks,0,sizeof(marks)); 	memset(cnt,0,sizeof(cnt));  	int N, m; 	cin >> N; 	char ch; 	for(int i = 0; i < N; i++) 	{ 		scanf("\n%c %d",&ch,&m); 		marks[(int) ch - 'A'][m]++; 		cnt[(int) ch - 'A']++; 	}   	for(int i = 0; i < 5; i++) 	{ 		int flag = 0; 		for(int j = 0; j < 101; j++) 		{ 			if(marks[i][j] > cnt[i]/10) 			{ flag = 1; cout << j << " " ;} 		} 		if(flag == 0) 			cout << "Nothing Unusual" << endl; 		else    cout << endl; 	} 	return; }   int main() { 	solve(); 	return 0; }
#include <bits/stdc++.h>  using namespace std ;  typedef long long ll ; // //#define INF 100000001 //#define MAX 10100   //int rr[]= {-1,-1,0,0,1,1}; //int cc[]= {-1,0,-1,1,0,1}; //int rr[]= {0,0,1,-1};/*4 side move*/ //int cc[]= {-1,1,0,0};/*4 side move*/ //int rr[]= {1,1,0,-1,-1,-1,0,1};/*8 side move*/ //int cc[]= {0,1,1,1,0,-1,-1,-1};/*8 side move*/ //int rr[]={1,1,2,2,-1,-1,-2,-2};/*night move*/ //int cc[]={2,-2,1,-1,2,-2,1,-1};/*night move*/  template< class T > T _abs(T n) { return (n < 0 ? -n : n); } template< class T > T _max(T a, T b) { return (!(a < b) ? a : b); } template< class T > T _min(T a, T b) { return (a < b ? a : b); } template< class T > T sq(T x) { return x * x; } template< class T > T gcd(T a, T b) { return (b != 0 ? gcd<T>(b, a%b) : a); } template< class T > T lcm(T a, T b) { return (a / gcd<T>(a, b) * b); } template < class T > T power(T N , T P) { return (P == 0) ?  1 : N * power(N , P - 1); } // //#define Maxi 100000005 //#define sq sqrt(Maxi) // // //bool yes_no[Maxi] ; //int prime[6 * 1000000], sz = 0 ; // //void seive() //{ //    int i, j ; //    yes_no[0] = yes_no[1] = true ; //    yes_no[2] = false ; //    prime[sz++] = 2 ; //    for( i = 4; i <= Maxi; i+= 2) //        yes_no[i] = true ; //    for( i = 3; i <= sq; i += 2 ) //        if( yes_no[i] == false ) //            for( j = i * i ; j <= Maxi; j += ( 2 * i ) ) //                yes_no[j] = true ; // //    for( i = 3; i <= Maxi; i += 2 ) //        if( yes_no[i] == false ) //       // cout << sz << endl; //            prime[sz++] = i ; ////    for( i = 0; i < 20; i++ ) ////        printf("%d\n", prime[i]) ; //}    //ll bigmod(ll num , ll p , ll mod) //{ //    ll sum = 1 , temp = num; //    while(p) //    { //        if(p & 1) sum = (sum * temp) % mod; //        temp = (temp * temp) % mod; p = p >> 1; //    } //    return sum; //}  int main() {     int a[100005], i, tst, cas = 0, l, n, cnt, k  ;     scanf("%d", &tst) ;     while(tst--)     {         int m ;         scanf("%d", &n) ;         if( n % 2 )             puts("0") ;         else         {             n = n / 2 - 1 ;             printf("9") ;             for( i = 0; i < n; i++ )                 printf("0") ;             puts("") ;         }     }     return 0 ; } 
#include <bits/stdc++.h>    #ifndef ONLINE_JUDGE     #define gc getchar     #define pc putchar #else     #define gc getchar_unlocked     #define pc putchar_unlocked #endif     using namespace std;     typedef long long ll; typedef vector<int> vi; typedef pair<int, int> ii; typedef vector<ii> vii; typedef set<int> si; typedef map<string, int> msi;   template< class T > T _abs(T n) { return (n < 0 ? -n : n); }   template< class T > T _max(T a, T b) { return (!(a < b) ? a : b); }   template< class T > T _min(T a, T b) { return (a < b ? a : b); }     template< class T > T gcd(T a, T b) { return (b != 0 ? gcd<T>(b, a%b) : a); }   template< class T > T lcm(T a, T b) { return (a / gcd<T>(a, b) * b); }   template< class T > bool inside(T a, T b, T c) { return a<=b && b<=c; }       inline int fr() {     register int c = gc(); 	int x = 0;      for(; (c<48 || c>57); c = gc());     for(; c>47 && c<58 ; c = gc()) {         x = x*10 + c - 48; } return x;} inline void fp(int n){     if (n / 10 != 0)         fp(n / 10);     putchar((n % 10) + '0'); }  inline ll frl() {     register int c = gc(); 	ll x = 0;      for(; (c<48 || c>57); c = gc());     for(; c>47 && c<58 ; c = gc()) {         x = x*10 + c - 48; } return x;} inline void fpl(ll n){     if (n / 10 != 0)         fp(n / 10);     putchar((n % 10) + '0'); }  #define SWAP(a,b) {a^=b;b^=a;a^=b;} #define MP(x, y) make_pair(x, y) #define SZ(a) int((a).size())      #define SET(p) memset(p, -1, sizeof(p))   #define SETINF(p) memset(p, 127, sizeof(p))   #define CLR(p) memset(p, 0, sizeof(p))     #define CPY(d, s) memcpy(d, s, sizeof(s))     #define PB(x) push_back(x)   #define bitcount      __builtin_popcount #define all(c) (c).begin(),(c).end()  #define present(c,x) ((c).find(x) != (c).end())  #define cpresent(c,x) (find(all(c),x) != (c).end())   #define fi first   #define se second      #define REP(i, a, b) for (int i = int(a); i < int(b); i++) // a to b, and variable i is local! #define REPN(i, a, b) for (int i = int(a); i <= int(b); i++) #define RTR(container, it) for(typeof(container.begin()) it = container.end()-1; it >= container.begin(); --it) #define TR(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); ++it)  #define TRY(i,o) freopen(i,"r",stdin); freopen(o,"w",stdout);  #define sf(n)                       scanf("%lf",&n) #define ss(n)                       scanf("%s",n)  #define INF 0x7f7f7f7f #define SINF 1000000000 //safe inf for floyd warshall  deque<int> dmax;  int main() {  	int a[1000001]; 	int n,k,max1=0; 	dmax.clear(); 	n=fr(); 	REP(i,0,n){ 		a[i]=fr(); 	} 	k=fr(); 	int j; 	for(j=0;j<k;++j){ 		while(!dmax.empty()&&a[j]>=a[dmax.back()]) 			dmax.pop_back(); 		dmax.PB(j); 	} 	fp(a[dmax.front()]); 	for(;j<n;++j){ 		while(!dmax.empty()&&dmax.front()<=(j-k)) 			dmax.pop_front(); 		while(!dmax.empty()&&a[j]>=a[dmax.back()]) 			dmax.pop_back(); 		dmax.PB(j); 		pc(' '); 		fp(a[dmax.front()]); 	} return 0;    }   
#include <cstdio> using namespace std; long long dp[501][10][1024]; #define mod 1000000007 int main(){ int t,n,m; for(int i=0;i<=9;i++)     dp[1][i][1<<i] = 1; for(int i=2;i<=500;i++){     for(int j=0;j<=9;j++){         if(j==0){             for(int k=0;k<1024;k++){                 dp[i][j][k|(1<<j)] += dp[i-1][j+1][k];                 if(dp[i][j][k|(1<<j)]>=mod)                     dp[i][j][k|(1<<j)]%=mod;             }         }         else if(j==9){             for(int k=0;k<1024;k++){                 dp[i][j][k|(1<<j)] += dp[i-1][j-1][k];                 if(dp[i][j][k|(1<<j)]>=mod)                     dp[i][j][k|(1<<j)]%=mod;             }         }         else{             for(int k=0;k<1024;k++){                 dp[i][j][k|(1<<j)] += dp[i-1][j-1][k];                 if(dp[i][j][k|(1<<j)]>=mod)                     dp[i][j][k|(1<<j)]%=mod;                 dp[i][j][k|(1<<j)] += dp[i-1][j+1][k];                 if(dp[i][j][k|(1<<j)]>=mod)                     dp[i][j][k|(1<<j)]%=mod;             }         }     } } scanf("%d",&t); while(t--){  scanf("%d %d",&n,&m);  long long int sum = 0;  int mask = 0;  for(int i=0;i<n;i++)     mask |= (1<<i);  for(int i=1;i<=m;i++){     for(int j=1;j<=9;j++){         sum=(sum+dp[i][j][mask])%mod;     }  }  printf("%lld\n",sum); } return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { 	int t, p=0; 	 	cin>>t; 	while(p<t) 	{  	int n; 	cin>>n; 	long long int a[20000]={0}; 	for(int i=0;i<n;i++) 	{  long long int b; 	  cin>>b; 		a[b]++; 	} 	int v;int count=0; 	for(int j=0;j<20000;j++) 	{ 		if(a[j]>count) 		{ 			v=j; 			count=a[j]; 		} 	} 	cout<<v<<" "<<count<<endl; 	p++;	 		 	} 	return 0; }
#include <iostream> #include <cstdlib> #include <cstring> #include <sstream> #include <cassert> #include <utility> #include <string> #include <bitset> #include <vector> #include <cstdio> #include <stack> #include <queue> #include <list> #include <set> #include <map> #include <algorithm> #include <cmath> #include <complex>   using namespace std;   typedef long long        LL; typedef pair<int, int>   pii; typedef pair<int, pii>   piii; typedef vector<int>      vi; typedef vector<pii>      vii;   //Fast Input  inline void inpint( int &n ) {   n=0; register int ch = getchar_unlocked(); int sign = 1;   while(ch < '0' || ch > '9') { if(ch == '-') sign=-1; ch = getchar_unlocked(); }   while(ch >= '0' && ch <= '9') { n = (n << 3) + (n << 1) + ch - '0', ch = getchar_unlocked(); }   n = n * sign; } //End Fast Input   inline string itostr(int a){     char x[100];     sprintf(x,"%d",a); string s = x;     return s; }   inline int strtoi(string a){     char x[100]; int res;     strcpy(x,a.c_str()); sscanf(x,"%d",&res);     return res; }   inline int sqr(int x){return x * x;} inline int cube(int x){return x * x * x;}   const LL LLINF      = 9223372036854775807LL; const LL LLINF17    = 100000000000000000LL; const int INF       = 2147483647; const int INF9      = 1e9; const int MOD       = 1000000007; const double eps    = 1e-7; const double PI     = acos(-1.0);   #define FORIT(a,b)   for (__typeof((b).begin()) (a)=(b).begin(); (a)!=(b).end(); (a)++) #define FOR(a,b,c)   for (int (a)=(b); (a)<(c); (a)++) #define FORN(a,b,c)  for (int (a)=(b); (a)<=(c); (a)++) #define FORD(a,b,c)  for (int (a)=(b); (a)>=(c); (a)--) #define REP(i,n)     FOR(i,0,n) #define REPN(i,n)    FORN(i,1,n) #define REPD(i,n)    FORD(i,n,1)   #define RESET(a,b)   memset(a,b,sizeof(a))  #define SYNC         ios_base::sync_with_stdio(0); #define SIZE(a)      (int)(a.size()) #define MIN(a,b)     (a) = min((a),(b)) #define MAX(a,b)     (a) = max((a),(b)) #define input(in)    freopen(in,"r",stdin) #define output(out)  freopen(out,"w",stdout) #define ALL(a)       a.begin(),a.end() #define RALL(a)      a.rbegin(),a.rend() #define SIZE(a)      (int)(a.size()) #define LEN(a)       (int)(a.length())   #define FIN(x)       freopen(x,"r",stdin) #define FOUT(x)      freopen(x,"w",stdout) #define FCLOSE       {fclose(stdin); fclose(stdout);}   #define fi           first #define se           second #define pb           push_back #define mp           make_pair   int dr[] = {1,0,-1,0,-1,1,1,-1}; int dc[] = {0,-1,0,1,1,1,-1,-1}; int t, n, arr[1000005], cnt[10000005]; int main(){ 	inpint(t); 	while(t--){ 		inpint(n); int maxval = 0; 		REPN(i,n){ 			inpint(arr[i]); 			MAX(maxval, arr[i]); 			cnt[arr[i]]++; 		}   		int ans = 1; 		for(int i = 1; i <= maxval; i++){ 			int sum = 0; 			for(int j = 1; j <= maxval / i; j++){ 				sum += cnt[i * j]; 				if(sum >= 2){ 					MAX(ans,i); 					break; 				} 			} 		} 		printf("%d\n",ans); 		if(t >= 1) FORN(i,0,maxval) cnt[i] = 0; 	}   	return 0; } 
#include<bits/stdc++.h> using namespace std;   #define sd(mark) scanf("%d",&mark) #define ss(mark) scanf("%s",&mark) #define sl(mark) scanf("%lld",&mark) #define clr(mark) memset(mark,0,sizeof(mark)) #define F first #define S second #define MP make_pair #define PB push_back #define ll long long bool dp[110][130][130]; vector<pair<int,int> > v[110]; int ans=0; void go(int i,int j,int k) { 	int l; 	ans=max(ans,k); 	dp[i][j][k]=1; 	for(l=0;l<v[i].size();++l) 	{ 		if(!dp[v[i][l].F][v[i][l].S][(k^(j&(v[i][l].S)))]) 			go(v[i][l].F,v[i][l].S,(k^(j&(v[i][l].S)))); 	} } int main() { 	int i,j,k,n,m,x,y,c; 	for(i=0;i<110;++i) 		for(j=0;j<130;++j) 			for(k=0;k<130;++k) 				dp[i][j][k]=0; 	sd(n); 	sd(m); 	for(i=0;i<m;++i) 	{ 		sd(x);sd(y);sd(c); 		--x;--y; 		v[x].PB(MP(y,c)); 		v[y].PB(MP(x,c)); 	} 	for(i=0;i<n;++i) 	{ 		if(!dp[i][127][0]) 			go(i,127,0); 	} 	printf("%d\n",ans); }
#include<iostream> #ifdef ONLINE_JUDGE #	define gc getchar_unlocked #else #	define gc getchar #endif inline void fps(long long &x) {     register int c = gc(); 	x = 0;     for(;((c<48 || c>57));c = gc());     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} } main() {       long long t,n;       fps(t);       while(t--)       {          fps(n);                 if(n==1)printf("0\n");          else printf("%lld\n",(n*n)/2-1);       } }        
#include <cstdio> #include <vector>  using namespace std;  long long pow(long long x, int n, int p) { 	if (n == 0) 		return 1; 	long long res = pow(x, n / 2, p); 	res = (res * res) % p; 	if (n % 2 == 1) 		res = (res * x) % p; 	return res; }  int main() { 	int t; 	scanf("%d", &t); 	for (int i = 1; i <= t; i++) { 		int n; 		int p; 		scanf("%d%d", &n, &p); 		vector <int> x(n), y(n); 		for (int j = 0; j < n; j++) 			scanf("%d%d", &x[j], &y[j]); 		int cur = 1; 		long long dx = 0; 		long long dy = 0; 		while (cur < n && dx == 0 && dy == 0) { 			dx = x[0] - x[cur]; 			dy = y[0] - y[cur]; 			cur++; 		} 		if (dx == 0 && dy == 0) { 			printf("Case #%d: MULTIPLE SOLUTIONS\n", i); 			continue; 		} 		if (dx == 0) { 			printf("Case #%d: NO SOLUTIONS\n", i); 			continue; 		} 		if (dx < 0) 			dx += p; 		if (dy < 0) 			dy += p; 		long long a = (dy * pow(dx, p - 2, p)) % p; 		long long b = (y[0] - a * x[0]) % p; 		if (b < 0) 			b += p; 		bool good = true; 		for (int j = 0; j < n; j++) { 			if ((a * x[j] + b) % p != y[j]) { 				good = false; 				break; 			} 		} 		if (good) 			printf("Case #%d: %lld %lld\n", i, a, b); 		else 			printf("Case #%d: NO SOLUTIONS\n", i); 	} 	return 0; }
#include <bits/stdc++.h>  using namespace std;  int main() {     int t;     scanf("%d",&t);      while (t--) {         long long n;         scanf("%lld",&n);         if (n&1)             printf("NO\n");         else             printf("YES\n");     }      return 0; } 
#include<iostream> #include<cstdio> #include<algorithm> #include<cstring> #include<string> using namespace std;  int a[505][505]; int fn(int i,int j); char s1[505],s2[505];  int main(){     string st1,st2;     int T,i,j,mx,n,m;     scanf("%d\n",&T);     while(T--){mx=0;         getline(cin,st1);         getline(cin,st2);         for(i=0;i<=st1.length();i++){             s1[i]=st1[i];             if(s1[i]>='A' && s1[i]<='Z')s1[i]+=32;         }         for(i=0;i<=st2.length();i++){             s2[i]=st2[i];             if(s2[i]>='A' && s2[i]<='Z')s2[i]+=32;         }          n=strlen(s1); m=strlen(s2);          for(i=0;i<=n;i++)for(j=0;j<=m;j++)a[i][j]=0;         for(i=0;i<n;i++)for(j=0;j<m;j++)if(s1[i]==s2[j]){             mx=max(mx,fn(i,j));         }         printf("%d\n",m-mx);     }     return 0;  }  int fn(int I,int J){     if(I==0){         if(s1[I]==s2[J]) return 1;         else return 0;     }      else if(J==0){         if(s1[I]==s2[J]) return 1;         else return 0;     }      if(a[I][J]!=0)return a[I][J];     int i,j,m=1;     for(i=I-1;i>=0;i--)for(j=J-1;j>=0;j--)if(s1[i]==s2[j]){         m=max(m,1+fn(i,j));     }     a[I][J]=m;     return m; } 
#include<stdio.h> #include<algorithm> using namespace std; int main() { 	int w1,w2,t,n1,n2,x,ans; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d%d%d%d",&w1,&w2,&n1,&n2); 		ans=0; 		x=min(w2/2,n2); 		w2-=2*x; 		n2-=x; 		ans+=2*x; 		x=min(w1/2,n2); 		w2-=2*x; 		n2-=x; 		ans+=2*x; 		x=min(w1+w2,n1); 		ans+=x; 		printf("%d\n",ans); 	} }
#include<stdio.h> #include<string.h> #include<stdlib.h> #define ll long long #define MOD 1000000007 #define min(a,b) ((a<b)?a:b) #define max(a,b) ((a>b)?a:b)  ll dp[27][100010]={0}; int main() { 	int test;scanf("%d",&test); 	while(test--) 	{ 		char junk;scanf("%c",&junk); 		int d;char st[100010]; 		scanf("%s",st); 		scanf("%d",&d); 		memset(dp,0,sizeof(dp)); 		int len=strlen(st); 		d=min(d,25); 		if(st[0]=='.') 			for(int i=0;i<26;i++) 				dp[i][0]=1; 		else 			dp[st[0]-'a'][0]=1; 		for(int i=1;i<len;i++) 		{ 			if(st[i]!='.') 			{ 				int pres=st[i]-'a'; 				for(int j=0;j<26;j++) 				{ 					if(abs(pres-j)<=d) 						dp[pres][i]=(dp[pres][i]+dp[j][i-1])%MOD; 				} 			} 			else 			{ 				if(st[i-1]=='.') 				{ 					for(int j=0;j<26;j++) 					{ 						// for dp[j][i] 						for(int k=0;k<26;k++) 						{ 							if(abs(j-k)<=d) 								dp[j][i]=(dp[j][i]+dp[k][i-1])%MOD; 						} 					} 				} 				else 				{ 					int prev=st[i-1]-'a'; 					for(int j=0;j<26;j++) 					{ 						if(abs(j-prev)<=d) 							dp[j][i]=(dp[j][i]+dp[prev][i-1])%MOD; 					} 				} 			} 		} 		ll ans=0; 		for(int i=0;i<26;i++) 			ans=(ans+dp[i][len-1])%MOD; 		printf("%lld\n",(ans+MOD)%MOD); 	} 	return 0; }
#include <bits/stdc++.h> using namespace std;  int tree[100001]; int n;  void update(int id, int val) {     while(id<=n)     {         tree[id]+=val;         id += (id&(-id));     } }  int read(int id) {     int s=0;      while(id>0)     {         s = s+ tree[id];         id -= id&(-id);     }      return s; }  int main() {      int t,i,a,v;      cin>>t;      while(t--)     {         cin>>n;          for(i=0;i<=n;i++)             tree[i]=0;          for(i=0;i<n;i++)         {             cin>>a;             update(a, 1);              v = a - read(a-1);             cout<<v<<"\n";          }      }      return 0; } 
#include<iostream> #include<cstdio> using namespace std;  int main() { 	int t,n,m,a[10010]; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d%d",&n,&m); 		for(int i=0;i<m;i++) 		{ 			scanf("%d",&a[i]); 		} 		int ans=1,bag=n,col; 		bool end=false; 		while(!end) 		{ 			col=ans; 		//	cout << "trying.."  << col << endl; 			bag=n-ans; 			if(bag<0) 			{ 				printf("-1\n"); 				break; 			} 			for(int i=1;i<m;i++) 			{ 				if(a[i]!=a[i-1]) 				{ 					bag-=a[i]-a[i-1]; 					col+=a[i]-a[i-1];  				} 				else  				{ 					col-=1; 				} 				if(bag<0) 				{ 					printf("-1\n"); 					end=true; 					break;  				} 				else if(col<1) 				{	 					ans+=(-col)+1; 					break; 					 				}   			} 			if(!end && col>0) 			{	 					printf("%d\n",ans); 					break; 			} 		} 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; #define ll long long int bool compare1(vector<ll> v1,vector<ll> v2){ return v1[1]<v2[1]; } bool compare2(vector<ll> v1,vector<ll> v2){ return v1[0]<v2[0]; } int main() { ll n,x,y,d,i,l,r,ans=0;   vector <vector<ll> > v;   vector <ll> q;   cin>>n;   for(i=0;i<n;i++)   { cin>>x>>y>>d;     q.push_back(x);     q.push_back(x+d);     v.push_back(q);     q.clear(); 	//cout<<1;   }      sort(v.begin(),v.end(),compare1);   sort(v.begin(),v.end(),compare2);      for(i=0;i<n;i++)   if(i==0)   { l=v[i][0];   	r=v[i][1];   	ans+=(r-l+1);   }   else   { if(v[i][0]<=r && v[i][1]>r)     { ans+=(v[i][1]-r);       l=v[i][0];   	  r=v[i][1]; 	}     else if(v[i][0]>r && v[i][1]>r) 	{ l=v[i][0];   	  r=v[i][1];   	  ans+=(r-l+1); 	}  	   }      cout<<ans;   return 0; }
#include <cstdio> #include <cstring>  using namespace std;  const int MAXN = 120;  struct poly {     int deg;     long double coef[MAXN]; };  poly polys[MAXN]; char str[MAXN]; char aux[MAXN];  int main() {     int t;     scanf("%d", &t);     while (t--) {         int lev = 0;         scanf("%s", str);          int n = strlen(str);         for (int i = 0; i < n; ++i) {             if (str[i] == 'm' || str[i] == 'M') {                 ++lev;                  aux[lev] = str[i];             } else {                 ++lev;                 aux[lev] = 'x';                 polys[lev].deg = 1;                 polys[lev].coef[0] = 0.0;                 polys[lev].coef[1] = 1.0;                  while (lev >= 3 && aux[lev] == 'x' && aux[lev - 1] == 'x') {                     // compute probability encoding logic statements as polys                     // e.g., min(p, q) < x <=> p < x or q < x                      // <=> (p < x) + (q < x) - (p < x and q < x)                     if (aux[lev - 2] == 'm') {                         // min(p(x), q(x)) = p(x) + q(x) - p(x) * q(x)                         //                 = -(1 - p(x)) * (1 - q(x)) + 1                         polys[lev - 2].deg = polys[lev - 1].deg + polys[lev].deg;                         for (int p = 0; p <= polys[lev - 2].deg; ++p)                             polys[lev - 2].coef[p] = 0;                          for (int p = 0; p <= polys[lev].deg; ++p)                             polys[lev].coef[p] = -polys[lev].coef[p];                         polys[lev].coef[0] += 1.0;                          for (int p = 0; p <= polys[lev - 1].deg; ++p)                             polys[lev - 1].coef[p] = -polys[lev - 1].coef[p];                         polys[lev - 1].coef[0] += 1.0;                          for (int p = 0; p <= polys[lev].deg; ++p)                             for (int q = 0; q <= polys[lev - 1].deg; ++q)                                 polys[lev - 2].coef[p + q] += polys[lev].coef[p] *                                     polys[lev - 1].coef[q];                          for (int p = 0; p <= polys[lev - 2].deg; ++p)                             polys[lev - 2].coef[p] = -polys[lev - 2].coef[p];                         polys[lev - 2].coef[0] += 1.0;                     } else {                         // max(p(x), q(x)) = p(x) * q(x)                         polys[lev - 2].deg = polys[lev - 1].deg + polys[lev].deg;                         for (int p = 0; p <= polys[lev - 2].deg; ++p)                             polys[lev - 2].coef[p] = 0;                          for (int p = 0; p <= polys[lev].deg; ++p)                             for (int q = 0; q <= polys[lev - 1].deg; ++q)                                 polys[lev - 2].coef[p + q] += polys[lev].coef[p] *                                     polys[lev - 1].coef[q];                     }                     aux[lev - 2] = 'x';                     lev = lev - 2;                 }             }         }          long double prob = 1.0;         for (int i = 1; i <= polys[lev].deg; ++i)             prob -= polys[lev].coef[i] / (i + 1);         printf("%.9Lf\n", prob);     }      return 0; } 
#include<iostream> using namespace std; int main(){        //  ios_base::sync_with_stdio(false);     // cin.tie(NULL);          int t;     cin>>t;     while(t--) 	{         int n,m;         cin>>n>>m;         char a[1001][1001];         for(int i=0; i<n; i++) 		{             cin>>a[i];         }         for(int i=0; i<n; i++) 		{             for(int j=m-1; j>=0; j--) 		{                 cout<<a[i][j];         }          		    cout<<endl;         }     } } 
#include <bits/stdc++.h>  using namespace std;  typedef long long ll; typedef vector<int> vi; typedef pair<int,int> pii; typedef map<int,int> mi;  #define si(a) scanf("%d",&a) #define sii(a,b) scanf("%d %d",&a,&b) #define nl printf("\n"); #define pb push_back #define mp make_pair #define all(c) (c).begin(),(c).end() #define f(i,a,b) for(i=a;i<b;i++) #define rf(i,a,b) for(i=a;i>=b;i--) #define clr(x,a) memset(x,a,sizeof(x)) #define MAX 100010 #define MOD 1000000007  ll n,m; ll a[MAX],b[MAX],mk[MAX]; vector<ll> v; vi w;  int main(){     ll r,k,i,c=0,x=0,y=0,j,t,l,x1=0,y1=0;     ll z=0,ans=0;string p[1000];      clr(a,0);     f(i,2,sqrt(1e9)+1){         if(!a[i]){             v.pb(i*i);             for(j=2*i;j<sqrt(1e9)+1;j+=i)                 a[j]=1;         }     }     cin>>t;     while(t--){         cin>>x>>y;         cout << upper_bound(v.begin(), v.end(), y) - lower_bound(v.begin(), v.end(), x) << endl;     }     return 0; } 
#include<stdio.h> #include<iostream> #include<math.h> #include<algorithm> #include<cstdlib> #include<string.h> using namespace std; int t,n,s=0,k,l,i,sum; int a[1000];  int main()  {   scanf("%d",&t);    while(t--)   { sum=0;   scanf("%d",&n);     for(i=0;i<n-1;i++)    scanf("%d",&a[i]);      sum=(n*n+n)/2;    for(i=0;i<n-1;i++)     sum=sum-a[i];     cout<<sum<<endl;   }  return 0;  }  
/* 	Name:Shubhendu Shishir 	Copyright:aiden 	Author: aiden 	Date: 	Description: */ #include<bits/stdc++.h> #define gcd(a,b) __gcd(a,b) #define lcm(a,b) (a*(b/gcd(a,b))) #define max3(a,b,c) max(a,max(b,c)) #define min3(a,b,c) min(a,min(b,c)) #define mod		1000000007 #define ll		long long int #define s(n)		scanf("%lld",&n); #define sc(c)		scanf("%c",&c); #define ss(s)		scanf("%s",s); #define loop(x,a,b)	for(x=a;x<b;x++) #define rep(i,n)	for(i=0;i<n;i++) #define mp		make_pair #define pb		push_back #define	vi		vector<ll> #define pll             pair<ll,ll> #define vp		vector<Pll> #define vs		vector<string> #define vvi		vector<VI> #define vvs	vector<VS> #define F first #define S second ll power(ll b, ll e) {     ll p = 1;     while (e > 0) {         if(e&1) {             p = (p*b)%mod;         }         e = e>>1;         b = (b * b)%mod;     }     return p; } using namespace std; int main() { ll a,b,n,m,c,d,i,count=0,sum=0,t,cs=0; s(t); while(t--)   {   s(n);   ll arr[100001];   s(arr[1]);   d=arr[1];   c=1;   for(i=2;i<n;i++)   {   	c=c^i;   	s(arr[i]);   	d=d^arr[i];   }   c=c^n;   m=c^d;   cout<<m<<endl;   } return 0; } 
#include <string> #include <vector> #include <cstdlib> #include <cstdio> #include <cmath> #include <algorithm> #include <ctime> #include <list> #include <map> #include <set> #include <iostream> #include <sstream> #include <cstring> #include <queue> #include <deque> #include <cassert> #include <cctype> #define MP make_pair using namespace std; typedef pair<int, int> PII; typedef unsigned long long ULL; typedef long long LL;  #define MOD #define INF #define MAXN 12  const int dx[] = {-1, 1, 0, 0}; const int dy[] = {0, 0, -1, 1};  int R, C; char grid[MAXN+1][MAXN+1]; vector<PII> food;  void findit(PII pnt, int dc, vector<vector<int> > &adj) {     int dp[R][C];     memset(dp, -1, sizeof(dp));     dp[pnt.first][pnt.second] = 0;     queue<PII> Q;     Q.push(pnt);     while(!Q.empty())     {         PII p = Q.front();         Q.pop();          for(int i=0; i<4; ++i)         {             int xx = p.first+dx[i], yy = p.second + dy[i];             if(xx<0 || yy<0 || xx >=R || yy>=C || grid[xx][yy]=='#' || dp[xx][yy]>-1)                 continue;             dp[xx][yy] = dp[p.first][p.second] + 1;             Q.push(MP(xx,yy));         }     }     for(int i=0; i<food.size(); ++i)         adj[dc][i] = dp[food[i].first][food[i].second]; }  int solve() {     food.clear();     for(int i=0; i<R; ++i)         for(int j=0; j<C; ++j)             if(grid[i][j] == 'H')                 food.push_back(MP(i,j));     for(int i=0; i<R; ++i)         for(int j=0; j<C; ++j)             if(grid[i][j] == 'F')                 food.push_back(MP(i,j));     int N = food.size();     vector< vector <int> > adj(N, vector<int>(N));      for(int i=0; i<N; ++i)for(int j=0; j<N; ++j) adj[i][j] = -1;     for(int i=0; i<N; ++i)         findit(food[i], i, adj);     for(int i=0; i<N; ++i)for(int j=0; j<N; ++j)         if(adj[i][j] == -1)return -1;       vector<int> pm(N-1);     int K = N-1;     for(int i=0; i<K; ++i)         pm[i] = i+1;     int rs = R*C+10;     do     {         int r = 0;         for(int i=0; i<(K-1); ++i)             r += adj[pm[i]][pm[i+1]];         r += adj[0][pm[0]] + adj[pm[K-1]][0];         rs = min(r, rs);     }while(next_permutation(pm.begin(), pm.end()));     return rs/2; }  void readInput() {     scanf("%d%d", &R, &C);     for(int i=0; i<R; ++i)         scanf("%s", grid[i]);  }  int main() {      int testcases;     scanf("%d", &testcases);     for(int caseno=1; caseno<=testcases; caseno++)     {         printf("Case %d: ", caseno);         readInput();         printf("%d\n", solve());     }     return 0; }   
#include <bits/stdc++.h> using namespace std;  int a[1000001];  int main(){     int n;     cin >> n;     int ma = 0, ma2 = 0;     for(int i = 0; i < n; i++) cin >> a[i];     for(int i = 0; i < n; i++){         ma = max(ma,a[i]);     }     for(int i = 0; i < n; i++){         if(a[i] != ma) ma2 = max(ma2,a[i]);     }     cout << ma2 << endl; } 
#include<bits/stdc++.h> using namespace std;  #define sd(a) scanf("%lld",&a) #define ss(a) scanf("%s",&a) #define sl(a) scanf("%lld",&a) #define clr(a) memset(a,0,sizeof(a)) #define debug(a) printf("check%d\n",a) #define rep(i) #define F first #define S second #define MP make_pair #define PB push_back #define ll long long #define M 10000  ll ans[110][10010]; ll diff[110][10010]; ll diff1[110][10010]; ll a[10010]; ll pre[10010];  int main() { 	//freopen("in.txt","r",stdin); 	//freopen("out.txt","w",stdout);  	ll t,n,m,s,i,j,mod; 	sd(t); 	while(t--) 	{ 		sd(n); 		s=sqrt(n); 		for(i=0;i*s<n;++i) 			for(j=0;j<10010;++j) 				ans[i][j]=diff[i][j]=diff1[i][j]=0; 		for(i=0;i<n;++i) 		{ 			ll minn=100000; 			sd(a[i]); 			pre[i]=a[i]; 			if(i) 				pre[i]+=pre[i-1]; 			 			diff1[i/s][a[i]+1]+=a[i]; 			diff1[i/s][a[i]+2]-=a[i];  			diff1[i/s][M+1]-=a[i]; 			diff1[i/s][M+2]+=a[i];  			for(j=1;j*j<=a[i];++j) 			{ 				ll l=a[i]/(j+1)+1; 				ll r=a[i]/j; 				ll A=a[i]%l; 				minn=min(minn,l); 				 				diff1[i/s][l]+=A; 				diff1[i/s][l+1]-=A; 				 				diff1[i/s][l+1]-=j; 				diff1[i/s][r+1]+=j;  				diff1[i/s][r+1]-=(A-(r-l)*j); 				diff1[i/s][r+2]+=(A-(r-l)*j);  			} 			 			for(j=1;j*j<a[i]&&j<minn;++j) 			{ 				diff1[i/s][j  ]+=(a[i]%j); 				diff1[i/s][j+1]-=(a[i]%j); 				diff1[i/s][j+1]-=(a[i]%j); 				diff1[i/s][j+2]+=(a[i]%j); 			} 		} 		 		for(i=0;i*s<n;++i) 		{ 			diff[i][0]=diff1[i][0]; 			for(j=1;j<10010;++j) 				diff[i][j]=diff[i][j-1]+diff1[i][j]; 			ans[i][0]=diff[i][0]; 			for(j=1;j<10010;++j) 				ans[i][j]=ans[i][j-1]+diff[i][j]; 		} 		sd(m); 		while(m--) 		{ 			ll l,r; 			sd(l);sd(r);sd(mod); 			--l;--r; 			if(mod>M) 			{ 				ll ans=pre[r]; 				if(l) 					ans-=pre[l-1]; 				printf("%lld\n",ans); 				return 0; 			} 			ll out=0; 			ll sl=l/s+1,sr=r/s-1; 			if(l%s==0) 				sl--; 			if((r+1)%s==0) 				sr++; 			if(sl>sr) 			{ 				for(i=l;i<=r;++i) 					out=out+a[i]%mod; 			} 			else 			{ 				for(i=l;i<sl*s;++i) 					out=out+a[i]%mod; 				for(i=(sr+1)*s;i<=r;++i) 					out=out+a[i]%mod; 				for(i=sl;i<=sr;++i) 					out+=ans[i][mod]; 			} 			printf("%lld\n",out); 		} 	} 	//for(i=0;i*s<n;++i) 	//	cout<<ans[i][9]<<'\n'; } 
#include<bits/stdc++.h> using namespace std; #define lim 10000000+1 int ans(int n,int k) { 	int r=0,p=k; 	while(k<=n) 	{ 		r+=n/k; 		k*=p; 	} 	//cout<<n<<" "<<k<<" "<<r<<" opopo"<<endl; 	return r;       } int an(int n,int h) { 	int y=0; 	while(n%h==0) 	{ 		n/=h; 		y++; 	} 	return y; } vector<int>v; bool w[lim]; int main() {   for(int i=2;i*i<lim;i++) { 	if(w[i]==false) 	{ 		for(int j=2*i;j<lim;j+=i) 		w[j]=true; 	} } for(int i=2;i<lim;i++) { 	if(w[i]==false) 	v.push_back(i); } 	int t; 	int n,k,res=1000000; 	cin>>t; 	while(t--) 	{ res=1000000; 	cin>>n>>k; 	for(int i=0;v[i]<=k;i++) 	 	{ //cout<<v[i]<<" pp"<<endl; 		if(k%v[i]==0) 		{ 	            	            res=min(res,ans(n,v[i])/an(k,v[i])); 	             		} }  	cout<<res<<endl; 	 } }
#include <iostream> #include <stdio.h> #include <cmath> #include <string.h> #include <limits.h> #include <stdlib.h> #include <algorithm> using namespace std; long long ways; void func(int cost[],int total,int nummovie,int index,int n) {     if(total==0&&nummovie==0)     {         ways++;         return;     }     if(index>=n)     {         return;     }     if(total<0||nummovie==0)     {         return;     }     func(cost,total-cost[index],nummovie-1,index+1,n);     func(cost,total,nummovie,index+1,n); }  int main() {     //freopen("input.txt","r",stdin);     int cases;     scanf("%d",&cases);     while(cases--)     {         int n,total;         scanf("%d%d",&n,&total);         int cost[5000];         for(int i=0;i<n;i++)         {             getchar();             char str[100];             gets(str);             scanf("%d",&cost[i]);         }         sort(cost,cost+n);        /* ways=0;         int movienum=3;         int index=0;         func(cost,k,movienum,index,n);         printf("%lld\n",ways);   */         ways=0;         for(int i=0;i<n;i++)         {             for(int j=i+1;j<n;j++)             for(int k=j+1;k<n;k++)             {                 if(cost[i]+cost[j]+cost[k]==total)                 ways++;             }             //printf("%d ",ways);         }         printf("%lld\n",ways);     }     return 0; } 
//{{{ #include<iostream> #include<algorithm> #include<cmath> #include<climits> #include<vector> #include<list> #include<stack> #include<queue> #include<deque> #include<stack> #include<bitset> #include<set> #include<cstdlib> #include<cstdio> #include<cstring> #include<ctime> #include<map> #include<functional> #include<numeric> #include<utility> #include<sstream> #include<iomanip> #include<cctype> //#undef thecodegame #ifdef thecodegame     #include<debug.h> #else     #define DBG_ARR(a,b,c) {}     #define DBG_MAT(a,s,b,c) {}     #define DBG_VECT(a) {}     #define db(...) {}     #define dbt(x, ...) {} #endif  using namespace std;  #define assert(f) {if(!(f)){fprintf(stderr,"Line-->%d  Assertion failed: %s \n",__LINE__,#f);exit(1);}} #define MOD 	 1000000007LL #define LL 		 long long #define ULL      unsigned long long #define ABS(x)   ((x)<0?-(x):(x)) #define SQR(x) 	 ((x)*(x)) #define CUBE(x)  ((x)*(x)*(x)) #define SD(n)    scanf("%d",&n) #define SD2(n,m) scanf("%d %d",&n,&m) #define SLL(n)   scanf("%lld",&n) #define SLU(n)   scanf("%llu",&n) #define SS(n)    scanf("%s",n) #define pnl      printf("\n") #define REP(i,n)        for(__typeof(n) i=0;i<(n);i++) #define FOR(i,a,b)      for(__typeof(b) i=(a);i<(b);++i) #define FORE(i,a,b)     for(__typeof(b) i=(a);i<=(b);++i) #define FORD(i,a,b,d)   for(__typeof(b) i=(a);i<(b);i+=(d)) #define FORR(i,n,e)     for(__typeof(n) i=(n);i>=(e);--i) #define FORRD(i,n,e,d)  for(__typeof(n) i=(n);i>=(e);i-=(d)) #define REP_IT(it,m)    for(it=m.begin();it!=m.end();it++) #define FORI(it,s) 	    for(__typeof((s).begin()) (it)=(s).begin();(it)!=(s).end();(it)++) #define FOREACH(it, X)  for(__typeof((X).begin()) it = (X).begin(); it != (X).end(); ++it) #define UNIQUE(v)       sort(ALL(v)),v.erase(unique(ALL(v)),v.end()) #define FILL(a,b)       memset(a,b,sizeof(a)) #define ALL(v)          (v).begin(), (v).end() #define RALL(v)         (v).rbegin(), (v).rend() #define checkbit(n,b)   (((n)>>(b))&1) #define PB push_back #define MP make_pair #define XX first #define YY second  const double PI=acos(-1.0); const double EPS=1e-11; template<typename T>inline T mod(T N,T M){return (N%M+M)%M;} double start;//time #ifdef amy     #define getcx getchar #else 	#define SD(x) inp(x) 	#define SD2(x,y) SD(x);SD(y);     #define getcx getchar_unlocked #endif template<typename T>inline void inp(T &n){     n=0;int ch=getcx();int sign=1;     while(ch<'0'||ch>'9'){if(ch=='-')sign=-1;ch=getcx();}     while(ch>='0'&&ch<='9'){n=(n<<3)+(n<<1)+ch-'0',ch=getcx();}     n=n*sign; }  //}}} #define SIZE 100000009 #define MAXX 100000009  void pre(){}//end precompute class Set{     vector<int>pset,prank;     public:     Set(int n){         pset.resize(n);         prank.assign(n,1);         REP(i,n){             pset[i]=i;         }     }     int getSet(int i){         return pset[i];     }     int getRank(int i){         return prank[i];     }     int findSet(int i){         if(pset[i]==i){             return i;         }         return  pset[i]=findSet(pset[i]);     }     bool isSameSet(int i,int j){         return findSet(i)==findSet(j);     }     void unionSet(int i,int j){         int x=findSet(i),y=findSet(j);         if(x==y){             return;         }         if(prank[x]<prank[y]){             pset[x]=y;             prank[y]+=prank[x];         }else{             pset[y]=x;             prank[x]+=prank[y];         }     } }; LL nc2(LL x){     return (x*(x-1))>>1; } int N,M,x,y; LL ans; int arr[SIZE]; void doThis(int ccc){     SD2(N,M);     ans = nc2(N);     if(!M){         printf("%lld\n",ans);         return;     }     Set s(N);     REP(i,M){         SD2(x,y);         s.unionSet(x-1,y-1);     }     REP(i,N){         if(s.getSet(i)==i){             ans-=nc2(s.getRank(i));         }     }     printf("%lld\n",ans);  }//end doThis int main(){ start = clock(); ios_base::sync_with_stdio(false); #ifdef amy 	freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\out.txt","w",stderr); #endif pre(); int cases = 1; //SD(cases); FORE(i,1,cases){doThis(i);} #ifdef amy 	fprintf(stdout,"\nTIME: %.3lf sec\n",(double)(clock()-start)/(CLOCKS_PER_SEC)); #endif //while((clock()-start)<0.999*CLOCKS_PER_SEC){} // :D :D return 0; }//end main 
#include <iostream> #include <stdio.h> #include <limits.h>  using namespace std;  #define MAXN 20 #define MAXP 10000 #define INF INT_MAX  int arr[MAXP], b[MAXP + 1]; int Left[MAXP], Right[MAXP]; long long int inversions;  void merge(int p, int q, int r){ 	int i, j, L, R, K; 	 	L = R = 0;     K = p; 	     while(p <= q) { 		Left[L++] = arr[p]; 		p++; 	} 	 	q = q + 1; 	while(q <= r) { 		Right[R++] = arr[q]; 		q++; 	} 	 	i = j = 0; 	while(i < L && j < R) { 		if(Left[i] <= Right[j]) 			arr[K++] = Left[i++]; 			 		else { 			arr[K++] = Right[j++]; 			inversions += (L - i); 		} 	} 	 	while(i < L) 		arr[K++] = Left[i++]; 		 	while(j < R)   		arr[K++] = Right[j++]; }  void mergesort(int p, int r){ 	int q; 	if(p < r){ 		q = (p + r) / 2; 		mergesort(p, q); 		mergesort(q + 1, r); 		merge(p, q, r); 	} }  int pref[MAXN][MAXP];  int main(){ 	int N, M;     long long int ans; 	 	ans = INF; 	scanf("%d %d", &N, &M); 	 	for(int i = 0; i < N; i++) {     	for(int j = 0; j < M; j++)     		scanf("%d", &pref[i][j]);     } 	     for(int i = 0; i < N; i++) {             for(int k = 0; k < M; k++)                      b[pref[i][k]] = k + 1;                          inversions = 0;             for(int j = 0; j < N; j++) {                     for(int k = 0; k < M; k++)                              arr[k] = b[pref[j][k]];                     mergesort(0, M - 1);             }                          ans = min(ans, inversions);     }     	 	printf("%lld\n", ans); 	return 0; } 
#include <stdio.h>   int main() { 	int t; 	scanf("%d",&t); 	while(t!=0) 	{ 		double a,b,c; 		scanf("%lf %lf %lf",&a,&b,&c); 		double p1=0; 		if(b>a) 		{ 			long int temp; 			temp=a; 			a=b; 			b=temp; 		}//a>b 		if(c==0) 			p1=0; 		else if(b==0 && a==0) 			p1=1; 		else if(b==0) 		{ 			if(a>c) 				p1=(double)c/a; 			else 				p1=1; 		} 		else if(c>=a+b) 			p1=1; 		else 		{ 			if(c<=b) 				p1=(double)c*c/(2*a*b); 			else if(a>=c && c>b) 				p1=(double)(2*c-b)/(2*a); 			else if(c>=a) 				p1=((double)b*(c-b) + (double)(b+c-a)*(a+b-c)/2)/(a*b); 		} 		printf("%0.6lf \n", p1); 		t--; 	} 	return 0; } 
#include<cstdio> using namespace std; int gcd(int x,int y) {     return y?gcd(y,x%y):x; } int main() {     int t,i,n,g,acut,cnt;     long long int s,rf,ms,mrf;     scanf("%d",&t);     while(t--)     {         cnt=0;         scanf("%d%lld%lld",&n,&ms,&mrf);         for(i=0;i<n;i++)         {             scanf("%lld%lld",&s,&rf);             if((s>ms)||(rf>mrf)) cnt++;         }         scanf("%d",&acut);         g=gcd(cnt,acut);         printf("%d/%d\n",cnt/g,acut/g);     }     return 0; } 
#include<iostream> using namespace std;   int main() { 	double n=0.0,sum=0.0; 	for(int i=0;i<12;i++) 	{ 		cin >> n; 		sum+=n; 	} 	cout << "$" << sum/12.0; 	return 0; } 
#include<iostream> using namespace std; #include<stdio.h> int last_digit_fact(int n) { 	int i,j,pw,pw2=0,pw5=0,res=1; 	for(i=1;i<=n;i++) 	{ 		j=i; 		while(j%2==0) 		{ 			j=j/2; 			pw2++; 		} 		while(j%5==0) 		{ 			j=j/5; 			pw5++; 		} 		res=(res*(j%10))%10; 	} 		pw=pw2-pw5; 		for(i=1;i<=pw;i++) 		{ 			res=(res*2)%10; 		} 		return res; }  int main() {   int n,ans;   scanf("%d",&n);   while(n!=0)   {   	 ans=last_digit_fact(n);      printf("%d\n",ans);      scanf("%d",&n);   }      return 0; } 
#include <iostream> #include <string.h> using namespace std; int isRunaround(long unsigned n) { 	int l=0; 	char a[10]; 	while(n) 	{ 		*(a+l)=n%10+'0'; 		n/=10; 		l++;	 	} 	*(a+l)='\0'; 	l--; 	do 	{ 		n=*(a+l)-'0'; 		*(a+l)='-'; 		while(n--) 		{ 			if(l==0) 				l=strlen(a)-1; 			else 				l=l-1;	 		} 	}while(*(a+l)!='-'); 	if(l!=strlen(a)-1) 		return 0; 	for(l=0;l<strlen(a);l++) 	if(*(a+l)!='-') break; 	if(l==strlen(a)) 		return 1; 	else  		return 0; } int main() { 	long unsigned n,k=1,m,l,i,j; 	char a[10]; 	cin>>n; 	while(n) 	{ 		n++; 		while(!isRunaround(n)) 		{ 			while(1) 			{ 				n++; 				m=n; 				l=0; 				while(m) 				{ 					*(a+l)=m%10+'0'; 					m/=10; 					l++;	 				}*(a+l)='\0'; 				for(i=0;i<l;i++) 				if(*(a+i)=='0') break; 				if(i!=l) continue; 				for(i=0;i<l;i++) 				{ 					for(j=i+1;j<l;j++) 					if(*(a+i)==*(a+j))	break; 					if(j!=l)  break; 				} 				if(i==l) break; 			} 		} 		cout<<"Case "<<k<<": "<<n<<endl; 		cin>>n;		 		k++;	 	} 	return 0; }
#include<iostream> #include<algorithm> #include<math.h> #include <limits.h> using namespace std; #define M 100005 int st[M],sst[M]; #define gc getchar_unlocked void scanint(int &x) { register int c = gc(); x = 0; int neg = 0; for(;((c<48 || c>57) && c != '-');c = gc()); if(c=='-') {neg=1;c=gc();} for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} if(neg) x=-x; } int MQ(int st[],int s,int e,int l,int m,int idxx){ 	 	if(l<=s && m>=e) 	return st[idxx]; 	 	if(l>e || m<s) 	return -1; 	 	int md=(s+e)/2; 	int fz=max(MQ(st,s,md,l,m,2*idxx+1),MQ(st,md+1,e,l,m,2*idxx+2)); 	return fz; 	 } int MMQ(int sst[],int s,int e,int l,int m,int idxx){ 	 	if(l<=s && m>=e) 	return sst[idxx]; 	 	if(l>e || m<s) 	return INT_MAX; 	 	int md=(s+e)/2; 	int fz=min(MMQ(sst,s,md,l,m,2*idxx+1),MMQ(sst,md+1,e,l,m,2*idxx+2)); 	return fz; 	 } int SGT(int a[],int s,int e,int st[],int idx){ 	 	if(s==e){ 		st[idx]=a[s]; 		return a[s]; 	} 	int mid=(s+e)/2; 	st[idx]=max(SGT(a,s,mid,st,2*idx+1),SGT(a,mid+1,e,st,2*idx+2)); 	return st[idx]; } int SGGT(int a[],int s,int e,int sst[],int idx){ 	 	if(s==e){ 		sst[idx]=a[s]; 		return a[s]; 	} 	int mid=(s+e)/2; 	sst[idx]=min(SGGT(a,s,mid,sst,2*idx+1),SGGT(a,mid+1,e,sst,2*idx+2)); 	return sst[idx]; } int main(){ 	 	int i,j,k,l,m,t,n,a[100005]; 	scanint(n); 	scanint(t); 	for(i=0;i<n;i++) 		cin>>a[i]; 	 	SGT(a,0,n-1,st,0); 	SGGT(a,0,n-1,sst,0);  while(t--){ 	scanint(l); 	scanint(m); int ff=	(MQ(st,0,n-1,l,m,0)-MMQ(sst,0,n-1,l,m,0)); 	cout<<ff<<endl; 	} }
    #include<bits/stdc++.h>     using namespace std;      int main()     {     	int T,N,Z,L,R,mid,temp;     	scanf("%d",&T);     	while(T--)     	{     		scanf("%d %d %d",&L,&R,&N);     		temp=R-L;     		int cnt=1;     		/*if(temp==1)     		{     			printf("0 0\n1\n");     			continue;     		}*/     		while(temp>=1 && !(L==N && R==N))     		{     			cnt++;     			printf("%d %d\n",L,R);     			mid=(L+R)/2;     			if(mid>=N)     			{     				R=mid;     				temp=mid-L;     			}     			else     			{     				L=mid+1;     				temp=R-mid-1;     			}     		}     		printf("%d %d\n",L,R);     		printf("%d\n",cnt);     	}     	return 0;     } 
#include<iostream> #include<cstdio> #include<vector> #include<algorithm> #include<string> #include<string.h> #include<math.h> #define in_t(t) scanf("%d",&t) using namespace std; int main() {     int  with;     double bal;     scanf("%d",&with);     scanf("%lf",&bal);     if(with>bal)     printf("%.2lf\n",bal);     else if(with==bal)     printf("%.2lf\n",bal);     else if (with%5==0)     printf("%.2lf\n",bal-with-0.50);     else if(with%5)     printf("%.2lf\n",bal);     return 0; }      
//By Sainath :) #include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <limits> #include <string> #include <cassert> #include <cstring>  using namespace std; typedef long long LL; typedef pair<int,int> pii;  #define forup(i,a,b) for(int i=a; i<b; ++i) #define fordn(i,a,b) for(int i=a; i>b; --i) #define rep(i,a) for(int i=0; i<a; ++i)  #define dforup(i,a,b) for(i=a; i<b; ++i) #define dfordn(i,a,b) for(i=a; i>b; --i) #define drep(i,a) for(i=0; i<a; ++i)  #define slenn(s,n) for(n=0; s[n]!='\0'; ++n)  #define gi(x) scanf("%d",&x) #define gl(x) cin>>x #define gd(x) scanf("%lf",&x) #define gs(x) scanf("%s",x)  #define pis(x) printf("%d ",x) #define pin(x) printf("%d\n",x) #define pls(x) cout<<x<<" " #define pln(x) cout<<x<<"\n" #define pds(x) printf("%.12f ",x) #define pdn(x) printf("%.12f\n",x) #define pnl() printf("\n")  #define fs first #define sc second  #define pb push_back int main() { 	int t,i; 	gi(t); 	while(t--) 	{ 		char a[12]; 		gs(a); 		int dots=0; 		slenn(a,i) 		{ 			switch(a[i]) 			{ 				case '0':printf("-----");dots+=0;break; 				case '1':printf(".----");dots+=1;break; 				case '2':printf("..---");dots+=2;break; 				case '3':printf("...--");dots+=3;break; 				case '4':printf("....-");dots+=4;break; 				case '5':printf(".....");dots+=5;break; 				case '6':printf("-....");dots+=4;break; 				case '7':printf("--...");dots+=3;break; 				case '8':printf("---..");dots+=2;break; 				case '9':printf("----.");dots+=1;break;  			};  		} 		printf("\n%d\n",dots); 	}  return 0; } 
#include <iostream> #include<string.h> using namespace std;  int main() { 	char msg[101]; 	gets(msg); 	int l,i; 	l=strlen(msg); 	for(i=0;i<l;i++) 	{ cout<<(char)(((int)msg[i])-7); 	} 	return 0; }
#include<iostream> #include<iomanip> #include<string.h> using namespace std; int convert(char); int main() {     int T;     char A[20],B[20];     cin>>T;     while(T--)     {         cin>>A>>B;         if(strlen(A)==1 && strlen(B)==1 && ((A[0]>=50 && A[0]<=57) || A[0]=='A' || A[0]=='J' || A[0]=='Q' || A[0]=='K') && ((B[0]>=50 && B[0]<=57) || B[0]=='A' || B[0]=='J' || B[0]=='Q' || B[0]=='K'))         {                 if(convert(A[0])+convert(B[0])<=11)                     cout<<"HIT\n";                 else                     cout<<"STAND\n";         }         else             cout<<"INVALID\n";     }     return 0; } int convert(char a) {     if(a=='A')         return(11);     else if(a=='J' || a=='Q' || a=='K')         return(10);     else         return(a-'0'); }
#include<iostream> #include<string.h> #include<stdlib.h> using namespace std; int main() {     int t,i,j,l,count;char a;     cin>>t;          for(j=0;j<t;j++)     {               count=1;     char me[100];     cin>>me;     l=strlen(me);     char A[3]={'A','B','C'},D[3]={'D','E','F'},G[3]={'G','H','I'},J[3]={'J','K','L'},M[3]={'M','N','O'},P[4]={'P','Q','R','S'};     char T[3]={'T','U','V'},W[4]={'W','X','Y','Z'};             for(i=0;i<l;i++)             {                             if(me[i]==me[i+1])                             count++;                             else                              {                                  if(me[i]=='2')                                  cout<<A[count-1];                                  else if(me[i]=='3')                                  cout<<D[count-1];                                  else if(me[i]=='4')                                  cout<<G[count-1];                                  else if(me[i]=='5')                                  cout<<J[count-1];                                  else if(me[i]=='6')                                  cout<<M[count-1];                                  else if(me[i]=='7')                                  cout<<P[count-1];                                  else if(me[i]=='8')                                  cout<<T[count-1];                                  else if(me[i]=='9')                                  cout<<W[count-1];                                  else if(me[i]=='0')                                  cout<<" ";                                  count=1;                                  }                             }                             cout<<endl;             }                  return 0;     } 
#include<iostream> #include<math.h> using namespace std; int len(long unsigned n) {    int l=0; 	while(n) n/=10,l++; 	return l; } int isprime(long unsigned n) {	long unsigned i; 	for(i=2;i<n;i++) 	if(n%i==0) break; 	if(i==n) return 1; 	else return 0; } long unsigned num_rot(long unsigned n,int f) {	int i,l=len(n)-1; 	while(f--) 	{	i=n%10; 		n/=10; 		n+=i*pow(10,l);	 	} 	return n; } int cir_prime(long unsigned n) {	long unsigned k=n; 	int l=len(n); 	if(isprime(k)) 	{	while(l--) 		{	k=num_rot(n,l); 			if(!isprime(k)) break; 			if(k<n && cir_prime(k)) break; 		} 		if (l==-1) return 1; 		else return 0; 	} 	else  		return 0; } int main() { 	int t,i; 	cin>>t; 	long unsigned *n=new long unsigned[t]; 	for(i=0;i<t;i++) 	cin>>*(n+i); 	for(i=0;i<t;i++) 	cout<<cir_prime(*(n+i))<<" "; 	return 0;	 }
#include<algorithm> #include<iostream> using namespace std; int main() {     int t; cin>>t;     while(t--)     {         int n; cin>>n;         int arr[n];         for(int i=0;i<n;i++)         cin>>arr[i];         sort(arr,arr+n);         for(int i=0;i<n-1;i++)         cout<<arr[i]<<" ";         cout<<arr[n-1]<<endl;     }     return 0; }
#include <stdio.h>  using namespace std;  int main() { 	int a,b,c,t,n; 	scanf("%d",&n); 	while(n--){ 		scanf("%d",&a); 		scanf("%d",&b); 		scanf("%d",&c); 		t = 0; 		if((a > b)&&(a < c) || (a > c) && (a < b) ){ 			t = a; 		} 		else if((b > a)&&(b < c) || (b > c) && (b < a)){ 			t = b; 		} 		else if(a == b) { 			t = b; 		} 		else { 			t = c; 		}		 	printf("%d",t); 	printf("\n");	 			 	} 	return 0; }
#include <iostream> #include <math.h> using namespace std;  int main() {     unsigned long long tcases, count=0;     double a, b, c, len, diagonal;          cin >>tcases;     cin >>a >>b >>c;     diagonal=sqrt((a*a) + (b*b) + (c*c));          while (tcases--)     {         cin >>len;         if (len<=diagonal)          count++;     }     cout <<count <<endl;     return 0; } 
#include<stdio.h> #include<iostream> #include<string.h> #include<math.h> #include<vector> #include<queue> #include<stack> #define min(a,b) a>b?b:a #define max(a,b) a>b?a:b  using namespace std;  int main() {     int t,end=0;     scanf("%d",&t);     char c;     while(scanf("%c",&c) && c!='\n');     while(t--)     {               stack <char> s;               char ch;               int flag=0;               while(1)               { 			int eof=1;                       while(scanf("%c",&ch)!=EOF)                       { 						eof=0; 						//cout<<"sdsdf\n";                                             if(ch==' ')                                             {flag=1; break;}                                             else if(ch=='\n')                                             {flag=2;break;}                                             //else if(ch==EOF)                                             //{flag=3; break;}                                             else                                             {flag=0;s.push(ch);}                       } 			if(eof) {end=1;break;}                       while(!s.empty())                       {printf("%c",s.top());s.pop();}                       if(flag==1)                       printf(" ");                       else if(flag==2)                       {printf("\n");break;}                                                                                    }               if(end)               break;     }   return 0;  }
#include<bits/stdc++.h> using namespace std; int main() {     ios_base::sync_with_stdio(0);     int n,m,a[100][100],mini=INT_MAX,lmini=INT_MIN,minindex=0;     cin>>n>>m;     for(int i=0;i<n;i++){         for(int j=0;j<m;j++){             cin>>a[i][j];             if(a[i][j]<mini){                 mini=a[i][j];             }         }         if(lmini<mini){             lmini=mini;             minindex=i;         }         mini=INT_MAX;     }     cout<<lmini<<endl;     return 0; } 
#include<iostream> #include<bits/stdc++.h> #include<stdio.h> #include<string>  #define lld long long int #define d int using namespace std;  int main() {     lld t,num;     char a[10000];     char temp;      cin>>t;     while(t--)     {         lld i , j,ln;         scanf("%s",&a);         scanf("%lld",&num);         for(i=0; i<num; i++)         {             for(j=i+1; j<num; j++)             {                 temp=a[i];                 a[i]=a[j];                 a[j]=temp;             }         }         ln=strlen(a);         for(i=num; i< ln; i++)         {                 a[i]=static_cast<char>(90-a[i]+65);         }         cout<<a<<endl;     }     return 0; } 
#include <iostream> #include <cstdio> #define ll int using namespace std;  ll mintree[2000005]; ll maxtree[200005]; ll arr[100005]; ll MAX = 1000000000; ll n,q,l,r;  void buildmax(ll node, ll start, ll end) {     if(start == end)     {         // Leaf node will have a single element        maxtree[node] = arr[start];     }     else     {         ll mid = (start + end) / 2;         // Recurse on the left child         buildmax(2*node, start, mid);         // Recurse on the right child         buildmax(2*node+1, mid+1, end);         // Internal node will have the sum of both of its children         ll d1 = maxtree[2*node];         ll d2 = maxtree[2*node+1];         maxtree[node] =  d1>d2 ? d1 : d2;     } }  void buildmin(ll node, ll start, ll end) {     if(start == end)     {         // Leaf node will have a single element        mintree[node] = arr[start];     }     else     {         ll mid = (start + end) / 2;         // Recurse on the left child         buildmin(2*node, start, mid);         // Recurse on the right child         buildmin(2*node+1, mid+1, end);         // Internal node will have the sum of both of its children         ll d1 = mintree[2*node];         ll d2 = mintree[2*node+1];         mintree[node] =  d1<d2 ? d1 : d2;     } }  ll querymax(ll node, ll start, ll end, ll l, ll r) {     if(r < start or end < l)     {         // range represented by a node is completely outside the given range         return -1;     }     if(l <= start and end <= r)     {         // range represented by a node is completely inside the given range         return maxtree[node];     }     // range represented by a node is partially inside and partially outside the given range     ll mid = (start + end) / 2;     ll p1 = querymax(2*node, start, mid, l, r);     ll p2 = querymax(2*node+1, mid+1, end, l, r);     return  p1>p2 ? p1 : p2; }  ll querymin(ll node, ll start, ll end, ll l, ll r) {     if(r < start or end < l)     {         // range represented by a node is completely outside the given range         return MAX;     }     if(l <= start and end <= r)     {         // range represented by a node is completely inside the given range         return mintree[node];     }     // range represented by a node is partially inside and partially outside the given range     ll mid = (start + end) / 2;     ll p1 = querymin(2*node, start, mid, l, r);     ll p2 = querymin(2*node+1, mid+1, end, l, r);     return  p1<p2 ? p1 : p2; }  int main() { 	// your code goes here 	 	scanf("%d",&n); 	 	for(ll i=1;i<=n;i++){ 		scanf("%d",arr+i); 	} 	 	buildmin(1,1,n); 	buildmax(1,1,n); 	 	scanf("%d",&q); 	 	while(q--){ 		scanf("%d %d",&l,&r); 		l++; 		r++; 		ll a1 = querymin(1, 1, n, l, r); 		ll a2 = querymax(1, 1, n, l, r); 		ll b1 = querymax(1, 1, n, 1, l-1); 		ll b2 = querymax(1, 1, n, r+1, n); 		b1 = max(b1,b2); 		double dd1 = (double)b1; 		 		double dd2 = (double)a2; 		 		dd2 -= (double)a1; 		dd2 /= 2; 		double ans = dd1>dd2 ? dd1 : dd2; 		 		ans += (double)a1; 		 		printf("%0.1f\n",ans); 	} 	 	return 0; }
#include<iostream> #include<stdio.h> #include<stdlib.h> #include<string> #include<string.h> using namespace std;  void LPSArray(int lps[],char sub[]) {     lps[0]=0;     int i=1,len=0;     while(i<strlen(sub))     {         if(sub[len]==sub[i])         {             len++;             lps[i] = len;             i++;         }         else         {             if(len!=0)                 len = lps[len-1];             else             {                 lps[i] = 0;                 i++;             }         }     } }  int KMP(char str[]) {     char s[11];     int i,j =0;     for(i=strlen(str)-1;i>=0;i--)     {         s[j] = str[i];         j++;     }     s[j] = 0;     int lt = strlen(str);     int lp = strlen(s);     //printf("lt: %d,lp: %d\n",lt,lp);     int *lps = (int *)malloc(sizeof(int)*lp);     LPSArray(lps,s);     i=0;     j=0;     int k=1;     //cout<<"TEXT: "<<str<<" ";     //cout<<"PATTERN: "<<sub<<endl;     while(i<lt)     {         if(s[j]==str[i])         {             //printf("i: %d, j: %d\n",i,j);             i++;             j++;         }         if(j==lp)         {             //printf("HI\n");             k=0;             j=lps[j-1];         }         else if(i<lt && s[j]!=str[i])         {             //printf("HI AGAIN\n");             if(j!=0)                 j = lps[j-1];             else                 i++;         }     }     return k; }  int main() {     int T,i,j,k,f=0;     char str[11],sub[11];     scanf("%d",&T);     while(T--)     {         cin>>str;         k = KMP(str);         if(k==0)             printf("YES\n");         else             printf("NO\n");     }     return 0; } 
#include<stdio.h>   int main() {     int t=0;     long long int n,k,m;       scanf("%d",&t);       while(t--)     {         scanf("%lld%lld%lld",&n,&k,&m);         if(k == 1)             printf("\n%lld",n);         else         {             while((n%k==0) && m)             {                 n /= k;                 m--;             }             if(m % 2 != 0)                 n *= k;             printf("\n%lld",n);         }     }     return 0; }
#include<bits/stdc++.h>  using namespace std;  int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		int n; 		cin>>n; 		int v[100005]; 	 		for(int i=1;i<=n;i++) 			cin>>v[i]; 		if(n==2) 		{ 			cout<<v[2]<<endl; 			continue; 		} 		int a[100005] = {0}; 		long long lsum = 0; 		for(int i=2;i<=n;i++) 		{ 			if(a[i] == 1) 				continue; 			long long sum =0 ; 			for(int j=i;j<=n;j = j+i) 			{ 				sum+= v[j]; 				a[j] = 1; 			} 			if(sum > lsum) 				lsum = sum; 		} 		cout<<lsum<<endl; 	} 	return 0; }
#include<iostream> #include<algorithm> #include<cstring> using namespace std; int main() {	std::ios::sync_with_stdio(false); 	int n,m; 	cin>>n>>m; 	int a[n],b[m],c[m+n-1]; 	memset(c,0,sizeof(c)); 	for(int i=0;i<n;i++) 	cin>>a[i]; 	for(int i=0;i<m;i++) 	cin>>b[i]; 	for(int i=0;i<n;i++) 	{ 		for(int j=0;j<m;j++) 		{ 			c[i+j]+=a[i]*b[j]; 		} 	} 	cout<<c[0]; 	for(int i=1;i<m+n-1;i++) 	cout<<" + "<<c[i]<<"x^"<<i; 	cout<<"\n"; 	return 0; }
#include<bits/stdc++.h> using namespace std;  const int base = 1000000000; const int base_digits = 9;  struct bigint {     vector<int> a;     int sign;      bigint() :         sign(1) {     }      bigint(long long v) {         *this = v;     }      bigint(const string &s) {         read(s);     }      void operator=(const bigint &v) {         sign = v.sign;         a = v.a;     }      void operator=(long long v) {         sign = 1;         if (v < 0)             sign = -1, v = -v;         for (; v > 0; v = v / base)             a.push_back(v % base);     }      bigint operator+(const bigint &v) const {         if (sign == v.sign) {             bigint res = v;              for (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) || carry; ++i) {                 if (i == (int) res.a.size())                     res.a.push_back(0);                 res.a[i] += carry + (i < (int) a.size() ? a[i] : 0);                 carry = res.a[i] >= base;                 if (carry)                     res.a[i] -= base;             }             return res;         }         return *this - (-v);     }      bigint operator-(const bigint &v) const {         if (sign == v.sign) {             if (abs() >= v.abs()) {                 bigint res = *this;                 for (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) {                     res.a[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);                     carry = res.a[i] < 0;                     if (carry)                         res.a[i] += base;                 }                 res.trim();                 return res;             }             return -(v - *this);         }         return *this + (-v);     }      void operator*=(int v) {         if (v < 0)             sign = -sign, v = -v;         for (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {             if (i == (int) a.size())                 a.push_back(0);             long long cur = a[i] * (long long) v + carry;             carry = (int) (cur / base);             a[i] = (int) (cur % base);             //asm("divl %%ecx" : "=a"(carry), "=d"(a[i]) : "A"(cur), "c"(base));         }         trim();     }      bigint operator*(int v) const {         bigint res = *this;         res *= v;         return res;     }      friend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {         int norm = base / (b1.a.back() + 1);         bigint a = a1.abs() * norm;         bigint b = b1.abs() * norm;         bigint q, r;         q.a.resize(a.a.size());          for (int i = a.a.size() - 1; i >= 0; i--) {             r *= base;             r += a.a[i];             int s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];             int s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];             int d = ((long long) base * s1 + s2) / b.a.back();             r -= b * d;             while (r < 0)                 r += b, --d;             q.a[i] = d;         }          q.sign = a1.sign * b1.sign;         r.sign = a1.sign;         q.trim();         r.trim();         return make_pair(q, r / norm);     }      bigint operator/(const bigint &v) const {         return divmod(*this, v).first;     }      bigint operator%(const bigint &v) const {         return divmod(*this, v).second;     }      void operator/=(int v) {         if (v < 0)             sign = -sign, v = -v;         for (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) {             long long cur = a[i] + rem * (long long) base;             a[i] = (int) (cur / v);             rem = (int) (cur % v);         }         trim();     }      bigint operator/(int v) const {         bigint res = *this;         res /= v;         return res;     }      int operator%(int v) const {         if (v < 0)             v = -v;         int m = 0;         for (int i = a.size() - 1; i >= 0; --i)             m = (a[i] + m * (long long) base) % v;         return m * sign;     }      void operator+=(const bigint &v) {         *this = *this + v;     }     void operator-=(const bigint &v) {         *this = *this - v;     }     void operator*=(const bigint &v) {         *this = *this * v;     }     void operator/=(const bigint &v) {         *this = *this / v;     }      bool operator<(const bigint &v) const {         if (sign != v.sign)             return sign < v.sign;         if (a.size() != v.a.size())             return a.size() * sign < v.a.size() * v.sign;         for (int i = a.size() - 1; i >= 0; i--)             if (a[i] != v.a[i])                 return a[i] * sign < v.a[i] * sign;         return false;     }      bool operator>(const bigint &v) const {         return v < *this;     }     bool operator<=(const bigint &v) const {         return !(v < *this);     }     bool operator>=(const bigint &v) const {         return !(*this < v);     }     bool operator==(const bigint &v) const {         return !(*this < v) && !(v < *this);     }     bool operator!=(const bigint &v) const {         return *this < v || v < *this;     }      void trim() {         while (!a.empty() && !a.back())             a.pop_back();         if (a.empty())             sign = 1;     }      bool isZero() const {         return a.empty() || (a.size() == 1 && !a[0]);     }      bigint operator-() const {         bigint res = *this;         res.sign = -sign;         return res;     }      bigint abs() const {         bigint res = *this;         res.sign *= res.sign;         return res;     }      long long longValue() const {         long long res = 0;         for (int i = a.size() - 1; i >= 0; i--)             res = res * base + a[i];         return res * sign;     }      friend bigint gcd(const bigint &a, const bigint &b) {         return b.isZero() ? a : gcd(b, a % b);     }     friend bigint lcm(const bigint &a, const bigint &b) {         return a / gcd(a, b) * b;     }      void read(const string &s) {         sign = 1;         a.clear();         int pos = 0;         while (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {             if (s[pos] == '-')                 sign = -sign;             ++pos;         }         for (int i = s.size() - 1; i >= pos; i -= base_digits) {             int x = 0;             for (int j = max(pos, i - base_digits + 1); j <= i; j++)                 x = x * 10 + s[j] - '0';             a.push_back(x);         }         trim();     }      friend istream& operator>>(istream &stream, bigint &v) {         string s;         stream >> s;         v.read(s);         return stream;     }      friend ostream& operator<<(ostream &stream, const bigint &v) {         if (v.sign == -1)             stream << '-';         stream << (v.a.empty() ? 0 : v.a.back());         for (int i = (int) v.a.size() - 2; i >= 0; --i)             stream << setw(base_digits) << setfill('0') << v.a[i];         return stream;     }      static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {         vector<long long> p(max(old_digits, new_digits) + 1);         p[0] = 1;         for (int i = 1; i < (int) p.size(); i++)             p[i] = p[i - 1] * 10;         vector<int> res;         long long cur = 0;         int cur_digits = 0;         for (int i = 0; i < (int) a.size(); i++) {             cur += a[i] * p[cur_digits];             cur_digits += old_digits;             while (cur_digits >= new_digits) {                 res.push_back(int(cur % p[new_digits]));                 cur /= p[new_digits];                 cur_digits -= new_digits;             }         }         res.push_back((int) cur);         while (!res.empty() && !res.back())             res.pop_back();         return res;     }      typedef vector<long long> vll;      static vll karatsubaMultiply(const vll &a, const vll &b) {         int n = a.size();         vll res(n + n);         if (n <= 32) {             for (int i = 0; i < n; i++)                 for (int j = 0; j < n; j++)                     res[i + j] += a[i] * b[j];             return res;         }          int k = n >> 1;         vll a1(a.begin(), a.begin() + k);         vll a2(a.begin() + k, a.end());         vll b1(b.begin(), b.begin() + k);         vll b2(b.begin() + k, b.end());          vll a1b1 = karatsubaMultiply(a1, b1);         vll a2b2 = karatsubaMultiply(a2, b2);          for (int i = 0; i < k; i++)             a2[i] += a1[i];         for (int i = 0; i < k; i++)             b2[i] += b1[i];          vll r = karatsubaMultiply(a2, b2);         for (int i = 0; i < (int) a1b1.size(); i++)             r[i] -= a1b1[i];         for (int i = 0; i < (int) a2b2.size(); i++)             r[i] -= a2b2[i];          for (int i = 0; i < (int) r.size(); i++)             res[i + k] += r[i];         for (int i = 0; i < (int) a1b1.size(); i++)             res[i] += a1b1[i];         for (int i = 0; i < (int) a2b2.size(); i++)             res[i + n] += a2b2[i];         return res;     }      bigint operator*(const bigint &v) const {         vector<int> a6 = convert_base(this->a, base_digits, 6);         vector<int> b6 = convert_base(v.a, base_digits, 6);         vll a(a6.begin(), a6.end());         vll b(b6.begin(), b6.end());         while (a.size() < b.size())             a.push_back(0);         while (b.size() < a.size())             b.push_back(0);         while (a.size() & (a.size() - 1))             a.push_back(0), b.push_back(0);         vll c = karatsubaMultiply(a, b);         bigint res;         res.sign = sign * v.sign;         for (int i = 0, carry = 0; i < (int) c.size(); i++) {             long long cur = c[i] + carry;             res.a.push_back((int) (cur % 1000000));             carry = (int) (cur / 1000000);         }         res.a = convert_base(res.a, 6, base_digits);         res.trim();         return res;     } }; int main() {     bigint a,b,c;     cin>>a;     cin>>b;     c=a*b;     cout<<c<<endl;     return 0; } 
#include<iostream> using namespace std;   int main() {     int q;     cin>>q;     while(q!=0)     {long long int x;     cin>>x;long long int s=0,a=1,b=2;     long long int y=0;     if(x==0 || x==1 || x==2)        cout<<"YES"<<endl;        else     for(int i=0;i<70;i++)       if(y>x)         {cout<<"NO"<<endl;break;}         else if(y==x)            {cout<<"YES"<<endl;break;}            else            {y=s+a+b;s=a;a=b;b=y;}         q--;     }return 0; }
#include<iostream> using namespace std; int main() {     int t;     cin>>t;     for(int i=0;i<t;i++)     {         long int n;         cin>>n;         if(n!=1){         if(n%2==0)         {           long int k=n/2;           k=-1*k;           cout<<k<<endl;         }         else         {             long int k=n/2;           k=-1*k;           k=k+n;           cout<<k<<endl;         }     }      else             cout<<"1"<<endl;      }     return 0; } 
#include<stdio.h> #include<string.h> #include<iostream> #include<algorithm> using namespace std; int main() { 	int t,i; 	cin>>t; 	while(t--) 	{ 		int n; 		cin>>n;getchar(); 		char s[2000]; 		char arr[50]; 		for(i=0;i<n;i++) 		{ 			cin>>s; 			int k=strlen(s); 			sort(s,s+k); 			arr[i]=s[k/2]; 		} 		arr[n]='\0'; 		printf("%s\n",arr); 	} 	return 0; }
#include<bits/stdc++.h> using namespace std;  typedef long long ll; int main() {     ll t;     cin>>t;     while(t--)     {         ll n;         cin>>n;         ll dp[n],a[n];     cin>>a[0];         for(ll i=1;i<n;i++){                 cin>>a[i];             dp[i]=a[i]-a[i-1];         }        ll start=1;        ll en=n-1;         ll s=0,mi,ans=0;         while(start<=en)         {            s=mi=dp[start];             for(ll i=start+1;i<n;i++){             s+=dp[i];                 if(s<mi)                 mi=s,start=i;             }ans+=mi;                 start++;         }         cout<<ans<<endl;      } }  
#include<bits/stdc++.h> using namespace std; int prime1(int n) {     int i;     for(i=2;i<=sqrt(n);i++)     {         if(n%i==0)         {             return 0;         }     }     return 1; } int main() { 	vector<int> v(1299710); 	vector<int> st1,st2; 	int i,j,num,in1,in2,n; 	map<int,int> prime,comp; 	in1=in2=0; 	prime[0]=comp[0]=0; 	for(i=2;i<=1299709;i++) 	{ 		if(v[i]==0) 		{ 			in1++;             prime[in1]=i; 			for(j=2*i;j<=1299709;j=j+i) 				v[j]=1; 		} 		else 		{ 		    in2++; 		    comp[in2]=i; 		} 	} 	map<int,int>::iterator it1; 	scanf("%d",&n); 	int p,c,maxi;     p=c=0; 	for(i=0;i<n;i++) 	{ 	    scanf("%d",&(num)); 	    if(num<1299710) 	    { 	        if(v[num]) 	         { 	             c++; 	             st2.push_back(num); 	         } 	       else 	       { 	           p++; 	           st1.push_back(num); 	       } 	             	    } 	    else 	    { 	        if(prime1(num)) 	        { 	            p++; 	            st1.push_back(num); 	        } 	         else 	         { 	            c++; 	            st2.push_back(num); 	         } 	    } 	} 	maxi=max(prime[p],comp[c]); 	//printf("%d %d %d\n",p,c,maxi); 	vector<int> ans(maxi+1); 	n=maxi+1; 	int n1,n2; 	n1=p; 	n2=c; 	    i=0; 	    it1=prime.begin(); 	    it1++; 	    for(it1=it1;(it1!=prime.end())&&(n1!=0);it1++) 	    { 	        ans[it1->second]=st1[i]; 	        //printf("%d %d\n",it1->second,st1[i]); 	        i++; 	        n1--; 	    } 	    i=0; 	    it1=comp.begin(); 	    it1++; 	    for(it1=it1;(it1!=comp.end())&&(n2!=0);it1++) 	    { 	        ans[it1->second]=st2[i]; 	       // printf("%d %d\n",it1->second,st2[i]); 	        i++; 	        n2--; 	    } 	for(i=0;i<n;i++) 	{ 	   printf("%d ",ans[i]); 	} 	return 0; }
#include <iostream> #include <cstdio> #include <cmath>  using namespace std;  long long fact(long long n) {     if ( n == 0 ) return 1;     return n*fact(n-1); }  int main() {     long long n,a,b,c1,c2;     int ans,temp;          scanf("%lld", &n);          while ( n-- ) {           c1 = 0;           c2 = 0;           scanf("%lld%lld", &a, &b);           ans = fact(a)/(fact(a-b)*fact(b));           //printf("%lld %lld\n", (int)(log10(ans)+1),int(log2(ans)+1));           temp = ans;           while ( temp ) {                 c1++;                 temp = temp/10;           }           while (  ans ) {                 c2++;                 ans = ans >> 1;           }            printf("%lld %lld\n", c1, c2);     }          return 0; }       
#include <stdio.h> #include <iostream> typedef long long ll; using namespace std; const int mod=10000007; int n,m,q;  char buf[21];int ix; int putchar_unlocked(char ch) { return putchar(ch);  } inline void writeL(int x) {      ix = 20;      buf[20] = '\n';      do       {         buf[--ix] = (x % 10) + '0';         x/= 10;      }while(x);      do      {         putchar_unlocked(buf[ix]);      } while (buf[ix++] != '\n'); }   int getchar_unlocked()  {return getchar();} inline void Read(int &x) { 	register int c= getchar_unlocked(); 	x = 0; 	for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked()); 	for(; c>47 && c<58 ; c = getchar_unlocked()) { 		x = (x<<1) + (x<<3) + c - 48; 	} }  struct node { int sum,type; } arr[500009];   void  update(int node,int type,int px,int py,int qx,int qy,int xx,int yy,int upd) { if(px==qx and py==qy and px==xx and py==yy) { arr[node].sum=upd; return; } int left,mid,right; 	left=node<<1; 	right=left+1; if(type==1){ 	mid=(px+qx)/2; 	if(xx<=mid) 	update(left,0,px,py,mid,qy,xx,yy,upd); 	else 	update(right,0,mid+1,py,qx,qy,xx,yy,upd); 	 }else{ 	mid=(py+qy)/2; 	if(yy<=mid) 	update(left,1,px,py,qx,mid,xx,yy,upd); 	else 	update(right,1,px,mid+1,qx,qy,xx,yy,upd); } arr[node].sum=arr[left].sum+arr[right].sum;  }   int query(int node,int type,int px,int py,int qx,int qy,int x1,int y1,int x2,int y2){ 	 if(px==x1 and py==y1 and qx==x2 and qy==y2) { return arr[node].sum; } int left,mid,right; 	left=node<<1; 	right=left+1; if(type==1){ 	mid=(px+qx)/2; 	if(x2<=mid) 	return query(left,0,px,py,mid,qy,x1,y1,x2,y2); 	else if(x1>mid) 	return query(right,0,mid+1,py,qx,qy,x1,y1,x2,y2); 	else return query(left,0,px,py,mid,qy,x1,y1,mid,y2) + query(right,0,mid+1,py,qx,qy,mid+1,y1,x2,y2); }else{ 	mid=(py+qy)/2; 	if(y2<=mid) 	return query(left,1,px,py,qx,mid,x1,y1,x2,y2); 	else if(y1>mid) 	return query(right,1,px,mid+1,qx,qy,x1,y1,x2,y2); 	else return query(left,1,px,py,qx,mid,x1,y1,x2,mid) + query(right,1,px,mid+1,qx,qy,x1,mid+1,x2,y2); } }     int main(){ 	int i,j,k,ii; 	Read(n); Read(m); 	for(i=0;i<n;i++) for(j=0;j<m;j++){Read(ii); update(1,1,0,0,n-1,m-1,i,j,ii); } 	Read(q); 	while(q--){ 		int px,py,qx,qy; 		Read(px);Read(py);Read(qx);Read(qy); 		writeL(query(1,1,0,0,n-1,m-1,px-1,py-1,qx-1,qy-1) ); 	} 	return 0; } 
#include<cstdio> using namespace std; //int getchar_unlocked()  {return getchar();} inline void fastRead_int(int &x) { 	register int c = getchar_unlocked(); 	x = 0; 	for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked()); 	for(; c>47 && c<58 ; c = getchar_unlocked()) { 		x = (x<<1) + (x<<3) + c - 48; 	} }  int main(){ 	int t,n;//,i,j,k,min; 	scanf("%d",&t); 	while(t--){ 		fastRead_int(n); 		n--; 		printf("%d\n",4*n*n+5*n+1); 	} 	return 0; } 
#include <stdio.h> #include <iostream> typedef long long ll; using namespace std; const int mod=10000007; int n,a,b;  char buf[21];int ix; //int putchar_unlocked(char ch) { return putchar(ch);  } inline void writeL(int x) {      ix = 20;      buf[20] = '\n';      do       {         buf[--ix] = (x % 10) + '0';         x/= 10;      }while(x);      do      {         putchar_unlocked(buf[ix]);      } while (buf[ix++] != '\n'); }   //int getchar_unlocked()  {return getchar();} inline void Read(int &x) { 	register int c= getchar_unlocked(); 	x = 0; 	for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked()); 	for(; c>47 && c<58 ; c = getchar_unlocked()) { 		x = (x<<1) + (x<<3) + c - 48; 	} }  int get(int v){ 	int ans=0; 	while(v>0){ 		ans+=(v&1); 		v=v>>1; 	} 	return ans; }  int ret(int bits){ 	int s=n,ans=0; 	while(s--){ 		ans<<=1; 		if(bits> 0){ ans+=1;bits--;} 	} 	return ans; }  int main(){ 	int t,i,j,k,ii; 	Read(t); 	while(t--){ 		Read(n); Read(a); Read(b); 		ii=get(a)+get(b); 		ii=(ii<=n)?ii:2*n-ii; 		writeL(ret(ii)); 	} 	return 0; } 
#include<iostream> #include<vector> #include<algorithm> #include<cstdio> #include<cstdlib> #include<string.h> #include<cstring> using namespace std; int revint(int x) { 	int y=0; 	while(x!=0) 	{ 	  y=y*10+(x%10); 	  x=x/10; 	} 	 return y; } main() { 	int t;cin>>t; 	while(t--) 	{       int n1,n2;       cin>>n1>>n2;       n1=revint(n1);       n2=revint(n2);       n1=n1+n2;       cout<<revint(n1)<<endl; 	} }
#include<iostream> using namespace std; int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		long int n; 		cin>>n; 		int a[8]; 		int len=0; 		int m=n; 		while(m>0) 		{ 			a[len++]=m%10; 			m=m/10; 		} 	//	cout<<len; 		if((len)%2==0) 		{ 			int flag=0; 			int i,j; 	    	for(i=len-1,j=0;i>j;i--,j++) 	      { 	     		  if(i!=j+1) 	     		  { 	     		  	if(a[i]!=a[j]) 	     		  	{ 	     		  		flag=1; 	     		  		a[j]=max(a[i],a[j]); 	    	     	a[i]=a[j]; 					   } 				  } 				   else 				   { 				   	  if(!flag) 				   	  { 				   	  	if(a[i]==a[j]) 				   	  	a[i]=a[i]+1,a[j]=a[j]+1; 				   	  	else 				   	  	{ 				   	  	 a[j]=max(a[i],a[j]); 	    	     	       a[i]=a[j]; 					 } 				   	  	 					  } 				   } 	      		  } 	    } 	    else 	    { 	    	int flag=0; 	    	int i,j; 	     	    	for(i=len-1,j=0;i>j;i--,j++) 	    	{ 	    		if(a[i]!=a[j]) 	    		{ 	    		flag=1; 	    		a[j]=max(a[i],a[j]); 	    		a[i]=a[j]; 	    	    } 	    		 			} 			if(!flag) 			a[i]=a[i]+1; 		} 		for(int i=len-1;i>=0;i--) 		{ 			cout<<a[i]; 		} 		cout<<"\n"; 	} 	 }
#include<iostream> #include<stdio.h> #include<string.h> #include<stdlib.h> #define MAXSIZE 1000000  using namespace std;  int main() { 	 	int t, i, n, flag; 	char *s;  	scanf("%d", &t );  	while( t-- ) {  		s = new char[ MAXSIZE ];		 		scanf("%s", s );	 		n = strlen( s );  		if( n == 1 ) 			printf("valid\n"); 		else {  			flag = 1;  			for( i = 0;i < n - 1;i++ ) 				if( s[ i ] > s[ i + 1 ] ) { 			 					flag = 0; 					break;			 				} 			if( flag ) 				printf("valid\n");  			else { 			 					flag = 1; 				 					for( i = 0;i < n - 1;i++ ) 						if( s[ i ] < s[ i + 1 ] ) { 			 							flag = 0; 							break;			 						} 					if( flag ) 						printf("valid\n"); 					else 						printf("invalid\n"); 			} 		} 		delete s; 	}  	return 0; } 
#include<iostream> #include<stdio.h> #include<vector> #include<iterator> #include<algorithm>  using namespace std;  static bool func( int a, int b ) { 	 	return ( a <= ( b + 1 ) ); }  int main() { 	 	int t, n, i, flag, j, temp;  	scanf( "%d", &t );  	while( t-- ) { 		 		scanf("%d", &n ); 		vector<int> A( n );  		for( i = 0;i < n;i++ ) 			scanf("%d", &A[ i ] ); 		 		flag = 1; 		for( i = 0;i < n - 1;i++ ) 			if( A[ i ] < A[ i + 1 ] ) { 				 				flag = 0; 				break;			 			}  		if( flag ) {  			copy( A.begin(), A.end(),ostream_iterator<int> ( cout, " " ) ); 			printf("\n");		 		}  		else {  			flag = 1; 			for( i = 0;i < n - 1;i++ ) 				if( A[ i ] > A[ i + 1 ] ) { 				 					flag = 0; 					break;			 				} 			if( flag ) {  				copy( A.begin(), A.end(),ostream_iterator<int> ( cout, " " ) ); 				printf("\n");		 			}  			else { 				 				for( i = 0;i < n;i++ ) { 					for( j = 0;j < n - 1;j++ ) { 						if( A[ j ] > ( A[ j + 1 ] + 1 ) ) { 								 							temp = A[ j ]; 							A[ j ] = A[ j + 1 ]; 							A[ j + 1 ] = temp; 						 						} 					} 				}  				copy( A.begin(), A.end(),ostream_iterator<int> ( cout, " " ) ); 				printf("\n");		  			}  		}		 		 	}  	return 0; } 
#include<bits/stdc++.h> using namespace std; long long a[1000000],b[1000000]; int main() {     long long n,k,i,j,c=0,yo=0;     long long sum=0;     scanf("%lld%lld",&n,&k);     for(i=0;i<n;i++)         scanf("%lld",&a[i]);     for(i=0;i<k;i++)         sum+=a[i];     b[c++]=sum;     for(i=k;i<n;i++)     {         sum-=a[yo++];         sum+=a[i];         b[c++]=sum;     }    // for(i=0;i<c;i++)      //  printf("%d ",b[i]);     long long t;     scanf("%lld",&t);     while(t--)     {         long long s,x;      scanf("%lld%lld",&s,&x);      long long f=0;      sum=0;     yo=0;      for(i=0;i<s;i++)         sum+=b[i];     if(sum==x)         f=1;     else      for(i=s;i<c;i++)      {          sum-=b[yo++];          sum+=b[i];          //printf("%lld ",sum);          if(sum==x)          {              f=1;              break;          }      }      if(f==1)         printf("YES\n");      else         printf("NO\n");     }     return 0; } 
#include<stdio.h> //#include<conio.h> int main() {     long int n1,n2,i,j,diff,min=10000000;     scanf("%ld",&n1);     long int a[n1];     for(i=0;i<n1;i++)     scanf("%ld",&a[i]);     scanf("%ld",&n2);     long int b[n2];     for(i=0;i<n2;i++)     scanf("%ld",&b[i]);     for(i=0;i<n1;i++)     for(j=0;j<n2;j++)     {                      diff=a[i]-b[j];                      if((a[i]-b[j])<0)                      diff=-diff;                      if(diff<min)                      min=diff;     }     printf("%ld\n",min);     //getch();     return 0; } 
#include<bits/stdc++.h> using namespace std;  int main(){      string a;     vector<string>v;     int i,start=0;     getline(cin,a);      for(i=0;i<a.length();i++){         if(a[i]==' '){             //cout<<"init start "<<start<<' '<<i<<endl;             string temp=a.substr(start,i-start);             reverse(temp.begin(),temp.end());             //cout<<temp<<endl;             v.push_back(temp);             start=i+1;         //cout<<"final start "<<start<<' '<<i<<endl;         }     }     string temp=a.substr(start,a.length()-start-1);     reverse(temp.begin(),temp.end());     v.push_back(temp);      for(i=0;i<v.size()-1;i++){         cout<<v[i]<<' ';     }     cout<<v[v.size()-1]<<a[a.length()-1]<<endl;    } 
#include<iostream> using namespace std; int main() {     long int t;     cin>>t;     for(int i=0;i<t;i++)     {         long int n;         cin>>n;         if(n%4==0)             cout<<"Second"<<endl;         else             cout<<"First"<<endl;     }     return 0; } 
#include <iostream> #include <list> #include <cstdio> #include <cstring> using namespace std; typedef long long int int64;  int m2 (int i) {return (i+30000) % 2;}  void incrt (int64 t[2][2], int x, int y, int64 s) {   t[m2 (x)][m2 (y)] = t[m2 (x)][m2 (y)] + s;}  void incrt2 (int64 t[2], int x, int64 s) {   t[m2 (x)] = t[m2 (x)] + s;}  void print_t (int64 t[][2]){   cout << "00 " << t[0][0] << " 01 " << t[0][1] <<     " 10 " << t[1][0] << " 11 " << t[1][1] << endl;}  int64 solve () {   int n; scanf("%d",&n);   int64 a [2][2]; int64 b [2][2]; int64 c [2][2]; int64 d [2][2];   int64 ac [2][2]; int64 bd [2][2];   int64 rep [] = {0, 0};    int i,j,k,l;   for (i=0; i<2; i++){     for (j=0; j<2; j++){       a[i][j]=0; b[i][j]=0; c[i][j]=0; d[i][j]=0; ac[i][j]=0; bd[i][j]=0;}   }   //lecture des donnes     int x,y;   for (i=1;i <= n;i++){     scanf("%d %d",&x,&y);     //cout << "x=" << x << " y=" << y << endl;     if (x > 0 & y > 0) {incrt (a, x, y, 1);}      if (x > 0 & y < 0) {incrt (b, x, y, 1);}      if (x < 0 & y < 0) {incrt (c, x, y, 1);}      if (x < 0 & y > 0) {incrt (d, x, y, 1);}    }   //print_t (a); print_t (b); print_t (c); print_t (d);   for (i=0; i<2; i++){     for (j=0; j<2; j++){       for (k=0; k<2; k++){ 	for (l=0; l<2; l++){ 	  incrt (ac, i+k, j+l, a[i][j] * c[k][l]);}}}}   for (i=0; i<2; i++){     for (j=0; j<2; j++){       for (k=0; k<2; k++){ 	for (l=0; l<2; l++){ 	  incrt (bd, i+k, j+l, b[i][j] * d[k][l]);}}}}   //print_t (ac); print_t (bd);   for (i=0; i<2; i++){     for (j=0; j<2; j++){       for (k=0; k<2; k++){ 	for (l=0; l<2; l++){ 	  incrt2 (rep, (i*l + j*k), ac[i][j] * bd[k][l]);}}}}   return rep[0]; }  int main () {   int t;   cin >> t;   //cout << "t=" << t << endl;   for (int i=1; i<=t; i++){   cout << solve () << endl;   }  return 0; }  
#include<bits/stdc++.h> using namespace std; int main() { int n,a[100009],i,pos=0,uu,ll,u,l,j;   scanf("%d",&n);   for(i=0;i<n;i++)   scanf("%d",&a[i]);      uu=ll=u=l=a[0];      for(i=1;i<n;i++)   { if(a[i]==u+1)       ++u;     else if(a[i]==l-1)     { --l;   	  pos=i;   	  ll=l;   	  uu=u;     }     else if(a[i]<l-1)     {  	  for(j=i;j<n;j++)       if(l>1)       { a[j]=l-1;       	--l; 	  }   	  else if(u<n) 	  { a[j]=u+1; 		++u; 	  } 	   	  break; 	} 	else if(a[i]>u+1) 	{ a[pos]=uu+1; 	  ++uu; 	  ++ll; 	   	  for(j=pos+1;j<n;j++)         if(ll>1)       	{ a[j]=ll-1;       	  --ll; 		}   		else if(uu<n) 		{ a[j]=uu+1; 		  ++uu; 	    } 	   	  break;	 	}    }    for(i=0;i<n;i++)  printf("%d ",a[i]);     return 0; }
#include<iostream> #include<algorithm>  using namespace std;  int main() { 	int n; cin>>n; 	long arr[n]; 	 	for(int i=0;i<n;i++) 	cin>>arr[i]; 	sort(arr,arr+n); 	 	int counter=0; 	for(int i=0;i<n-1;i++) 	{ 		if(arr[i]==arr[i+1]) 		counter++; 	} 	cout<<counter<<endl; 	 	return 0; }
#include <stdio.h> #include <stdlib.h>  int main() {     int n,m,i,j,l,c;     int a[20][20];     scanf("%d",&n);     scanf("%d",&m);     for(i=0;i<n;i++)     for(j=0;j<m;j++)     scanf("%d",&a[i][j]);      // Check all chairs in a row     for(i=0;i<n;i++)     {         l=a[i][0];         for(j=1;j<m;j++)         {             if(a[i][j]==l)             c=1;             else             {                 c=0;                 break;             }         }         if(c==1)         continue;         else         break;     }     for(i=0;i<n-1;i++)     {         if(c==1)         {             for(j=0;j<m;j++)             {                 if(a[i][j]==a[i+1][j])                 {                     c=0;                     break;                 }             }             if(c==0)             break;         }         else         break;     }     if(c==1)     printf("YES\n");     else     printf("NO\n");     return 0; }
#include<stdio.h> #include<iostream> #include<stdlib.h> #include<string.h> #include<math.h> #include<vector> #include<queue> #include<stack> #include<algorithm> #include<map> #include<limits>  #define min(a,b) (a>b?b:a) #define max(a,b) (a>b?a:b) #define si(n) scanf("%d",&n) #define sc(n) scanf("%c",&n) #define sll(n) scanf("%lld",&n) #define sull(n) scanf("%llu",&n) #define ss(str) scanf("%s",str) #define sf(n) scanf("%f",&n) #define sd(n) scanf("%lf",&n) #define I int  #define ll long long int #define ull unsigned long long int  #define mod(a) (a<0?-a:a) #define as_0 48 #define as_A 65 #define as_a 97 #define mem1(a) memset(a,0,sizeof(a)) #define mem2(a) memset(a,0,sizeof a)  //#include<conio.h>  using namespace std; void find_primes(vector<int> &primes, int n) {   int i,j;   int arr[n+5];   mem1(arr);      for(i=4;i<n+1;i+=2)   arr[i]=1;      for(i=3;i*i<n+1;i+=2)   {                          if(arr[i]==0)                          for(j=i*i;j<n+1;j=j+i)                          arr[j]=1;   }      primes.push_back(1);   for(i=2;i<=n;i++)   if(arr[i]==0 && 2*i>n)   {primes.push_back(i);}  } int main() {      //freopen("input.txt","r",stdin);    //freopen("output.txt","w",stdout);        char str[1009];    ss(str);        int arr[30];mem1(arr);        int i;    for(i=0;i<strlen(str);i++)    arr[str[i]-as_a]++;        //for(i=0;i<26;i++) printf("%d ",arr[i]);        int n=strlen(str);        vector<int> primes;    find_primes(primes,n);            int x=n-primes.size();        //for(i=0;i<primes.size();i++) printf("%d ",primes[i]);        for(i=0;i<=25;i++)    if(arr[i]>=x)    break;        if(i==26)    printf("NO\n");    else    {        printf("YES\n");        char str2[n+10];        int j,k;                for(j=0;j<n;j++)        {                        int z=binary_search(primes.begin(),primes.end(),j+1);                        //printf("z=%d\n",z);                        if(z==0)                        {str2[j]=(char)(i+as_a);                        arr[i]--;}        }                for(i=0;i<primes.size();i++)        {                                    for(j=0;j<26;j++)                                    if(arr[j]>0)                                    {                                                str2[primes[i]-1]=(char)(j+as_a); arr[j]--; break;                                    }        }        str2[n]='\0';        printf("%s",str2);    }   getchar();   getchar();  //getch();  return 0;  } 
#include<iostream> #include<cmath> using namespace std; int main() {     int n,m,a;     cin>>n>>m>>a;     if(m>n){         int t=m;         m=n;         n=t;     }          int sum=1,top=0;     if (n > a){     top = int(ceil(n * 1.0 / a));     sum = top;     }   if (m > a){     sum += top * (int(ceil((m * 1.0 - a) / a))); } cout<<sum<<endl;   }
#include<cstdio> #include<queue> #include<cstring> using namespace std;  char Cell[101][101]; int dx[] = { 0, 1, 1, 1,-1,-1,-1, 0 }; int dy[] = { 1, 0, 1,-1, 1,-1, 0,-1 }; int N,L,Visited[101][101],Distance[101][101];  int isSafe(int x, int y) {     return (  (x>=0 && x<N && y>=0 && y<L)  &&  Visited[x][y]==0 && Cell[x][y]=='0'  ); }  int Bfs(int i, int j) {     int dir,read=1;     Distance[i][j]=read;     Visited[i][j]=1;     queue<pair<int, int> > q;     q.push(make_pair(i,j));          while(!q.empty())     {       pair<int, int> pr;       pr=q.front();       q.pop();       int x=pr.first;       int y=pr.second;       for(dir=0; dir<8; dir++)       {           int xx=x+dx[dir], yy=y+dy[dir];           if( isSafe(xx,yy) ) {  q.push(make_pair(xx,yy));  Visited[xx][yy]=1;  Distance[xx][yy] = Distance[x][y]+1;  }       }       read=read+1;    }   return Distance[N-1][L-1]; }  int main() {     int i;     scanf("%d",&N);     for(i=0; i<N; i++)  scanf("%s",Cell[i]);     L=strlen(Cell[0]);     printf("%d\n",Bfs(0,0));   return 0; }
using namespace std;   #include<iostream>   int main() {     char arr[51], temp;     int no, count=0, i, j;     scanf("%d",&no);     scanf("%s",arr);     for(i=0; i<no; i++)     {         temp=arr[i];         for(j=i+1; arr[j]==temp; j++, count++)         i=j-1;     }     cout<<count;      return 0; }
#include<stdio.h>  long long Cval[1024];  long long C(int n) { 	if(Cval[n] != -1) 		return Cval[n]; 	long long ans=0; 	if(n==0) 	ans=1; 		 	for(int i=1; i<=n; i++) 	ans+=C(i-1) * C(n-i); 	 	ans=ans%100003; 	 	return (Cval[n]=ans); }  int main(void) { 	for(int i=0; i<1023; i++) 	Cval[i]=-1; 	 	int T, N; 	 	scanf("%d",&T); 	 	while(T--) 	{ 		scanf("%d",&N); 		 		printf("%lld\n",C(N)); 	} 	 	return 0; }
#include <iostream>  using namespace std;  char mat[105][105]; char color[105][105];  bool fine(int a,int b, int n)   {     return (a >= 1 && b >= 1 && a <= n && b <= n && color[a][b] == 'w' && mat[a][b] == 'S'); }  void call(int a,int b,int n)    {     color[a][b] = 'g';     if(fine(a-1,b-1,n))call(a-1,b-1,n);     if(fine(a-1,b,n))call(a-1,b,n);     if(fine(a-1,b+1,n))call(a-1,b+1,n);     if(fine(a,b-1,n))call(a,b-1,n);     if(fine(a,b+1,n))call(a,b+1,n);     if(fine(a+1,b-1,n))call(a+1,b-1,n);     if(fine(a+1,b,n))call(a+1,b,n);     if(fine(a+1,b+1,n))call(a+1,b+1,n);     color[a][b] = 'b'; }  int main() {      int t,n;scanf("%d",&t);     while (t--) {         scanf("%d",&n);         for(int i = 1; i <= n ; ++i)    {             scanf("%s",mat[i] + 1);         }          for(int i = 1; i <= n ; ++i)for(int j = 1; j <= n ; ++j)color[i][j] = 'w';          int components = 0;          for(int i = 1; i <= n ; ++i)    {             for(int j = 1; j <= n ; ++j)    {                 if(color[i][j] == 'w' && mat[i][j] == 'S'){call(i,j,n);++components;}             }         }          if(components & 1)printf("Alice\n");         else printf("Bob\n");      }      return 0; }
#include <bits/stdc++.h> using namespace std; int main()  {     int t,i,n;     string s;     scanf("%d",&t);     while(t--)     {         cin>>s;          n=s.size();         for( i=n-1;i>=0;i--)         {             if(s[i]=='4')             {                 s[i]='7';                 break;             }             else                 s[i]='4';          }         if(i<0)             cout<<"4"<<s<<endl;         else cout<<s<<endl;     }  } 
#include<cstdio> using namespace std; int main() { return 0;}
#include <bits/stdc++.h>  #define clr(x) memset((x), 0, sizeof(x)) #define all(x) (x).begin(), (x).end() #define pb push_back #define mp make_pair #define in(x) int (x); input((x)); #define x first #define y second typedef int itn;  //#define next next12345 //#define prev prev12345 #define left lefdsf232 #define right rig43783 #define x1 x12345 #define y1 y12345  using namespace std;  template<typename T> T gcd(T x, T y) {     while (y > 0) {         x %= y;         swap(x, y);     }     return x; }  template<class T> T lcm(T a, T b) {     return a / gcd(a, b) * b; }   template<class _T> inline _T sqr(const _T &x) {     return x * x; }  template<class _T> inline string tostr(const _T &a) {     ostringstream os("");     os << a;     return os.str(); }  typedef long double ld; typedef long long ll; typedef unsigned long long ull; typedef pair<int, int> PII; const ld PI = 3.1415926535897932384626433832795L;  template<typename T> inline void input(T &a) {     static int ed;     a = 0;     while (!isdigit(ed = getchar()) && ed != '-') { }     char neg = 0;     if (ed == '-') {         neg = 1;         ed = getchar();     }     while (isdigit(ed)) {         a = 10 * a + ed - '0';         ed = getchar();     }     if (neg) a = -a; }  template<typename T = int> inline T nxt() {     T res;     input(res);     return res; }  mt19937 generator;  bool check(int v) {     if (v < 2) return false;     for (int i = 2; i * i <= v; ++i) {         if (v % i == 0) {             return false;         }     }     return true; }  long long pw(long long a, long long n, long long m) {     ll res = 1;     while (n) {         if (n & 1ll) {             res = res * a % m;         }         a = a * a % m;         n >>= 1;     }     return res; }   void pre() { }  void gen() { }  const int N = 3000;  vector <int> g[N];  int dp[N][N];  int leaves[N];  int l;  void dfs(int v, int p) {     int ch = 0;     leaves[v] = 0;     for (int to : g[v]) {         if (to == p) continue;         dfs(to, v);         leaves[v] += leaves[to];         ch += 1;     }      if (ch == 0) {         dp[v][0] = 0;         dp[v][1] = 1;         leaves[v] = 1;         return;     }      for (int i = 0; i <= leaves[v] && i <= l; ++i) {         dp[v][i] = 0x3f3f3f3f;     }      dp[v][0] = 0;     if (leaves[v] <= l) dp[v][leaves[v]] = 1;      int s = 0;      for (int to : g[v]) {         if (to == p) {             continue;         }         for (int k = min(s, l); k >= 0; --k) {             for (int j = 1; j <= leaves[to] && j + k <= l; ++j) {                 dp[v][k + j] = min(dp[v][k + j], dp[v][k] + dp[to][j]);             }         }         s += leaves[to];     } }  void read() {     int n = nxt();      for (int i = 1; i < n; ++i) {         int u = nxt() - 1;         int v = nxt() - 1;         g[u].pb(v);         g[v].pb(u);     }      for (int i = 0; i < n; ++i) {         l += g[i].size() == 1;     }     l /= 2;     int ans = l;     int z = 0;     vector <int> order(n);     iota(all(order), 0);     random_shuffle(all(order));     double mt;     while (z < n) {         int root = order[z++];         double start = clock();         dfs(root, root);         double end = clock();         if (z == 1) {             mt = end - start;         }         ans = min(ans, dp[root][l]);         if (end + mt > 1.9 * CLOCKS_PER_SEC) {             break;         }     }     cout << ans << "\n"; }   void solve2() { }   int main(int argc, char ** argv) {  #ifdef LOCAL     freopen("input.txt", "r", stdin);     //freopen("output.txt", "w", stdout); #else     #define fname "d"     //freopen(fname".in", "r", stdin);     //freopen(fname".out", "w", stdout); #endif     int t = 1;     pre(); #ifdef LOCAL #endif  //    test();      int c = 0;     while (t--) {         //gen();         read(); //        gen(); //        gen2();     }   #ifdef LOCAL     cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC * 1000 << " ms." << endl; #endif     return 0; }
#include<iostream> using namespace std; #include<vector>  #define mod 1000000007 vector<long long> f(100005+1,1); void fun(){       for (int i=2; i<=100005;i++)         f[i]= (f[i-1]*i) % mod; } long long pow(int a, int b, int MOD) {     long long x=1,y=a;     while(b > 0)     {         if(b%2 == 1)         {             x=(x*y);             if(x>MOD) x%=MOD;         }         y = (y*y);         if(y>MOD) y%=MOD;         b /= 2;     }     return x; }   /*  Modular Multiplicative Inverse     Using Euler's Theorem     a^(phi(m)) = 1 (mod m)     a^(-1) = a^(m-2) (mod m) */ long long InverseEuler(int n, int MOD) {     return pow(n,MOD-2,MOD); }   long long C(int n, int r, int MOD) {       return (f[n]*((InverseEuler(f[r], MOD) * InverseEuler(f[n-r], MOD)) % MOD)) % MOD; } int main() {        int t;    cin >>t;    fun();    while(t--)    {     int MOD=1000000007;        int n,k;        cin >>n>>k;        cout << C(n,k,MOD) <<endl;    }    return 0; }
#include<stdio.h> #include<string.h> #define ll long long #define limit (ll) 1e7 int P[limit+1]; int count=0;   void gen() {   memset(P,0,sizeof(P));   P[0]=-1,P[1]=-1;   ll k=0,i,j;   for(i=2;i<=limit;i++)   {      if(P[i]==0)      {         P[i]=++k;         for(j=i*i;j<=limit;j+=i)            P[j]=-1;      }   } }   int main() {     int t,n;     gen();     scanf("%d",&t);     while(t--)     {           scanf("%d",&n);           printf("%d\n",P[n]);     }     return 0; }  
#include<stdio.h> long long int pow(long int n,long int m) { 	long long int k; 	if(m==0) 		return 1; 	 	if(m==1) 		return n; 	 	k=pow(n,m/2);	 	if(m%2==0) 		return k*k; 	 	if(m%2==1) 		return k*k*n; } int main() { 	int  ans,n,i; 	scanf("%d",&n); 	for(i=0;i<=n;i++) 		if(pow(2,i)>n) 			break; 			 	ans=n-pow(2,i-1); 	ans=ans*2+1; 	printf("%d\n",ans); 	return 0; }
#include <bits/stdc++.h> using namespace std; char inp[100005]; int main() { 	int t; 	scanf("%d", &t); 	while(t--) 	{ 		int n; 		scanf("%d", &n); 		scanf("%s", inp); 		int ctr = 1, tot = 0; 		long long int ans = 0; 		map <int,int> M; 		for (int i = 0; i < n; ++i) 		{ 			if(inp[i] == 'c') 			{ 				ans+=M[tot]; 				ctr++; 			} 			else 			{ 				M[tot]+=ctr; 				ctr = 0; 				if(inp[i] == 'a') 					tot-=2; 				else 					tot+=3; 				ans+=M[tot]; 				ctr++; 			} 		} 		printf("%lld\n", ans); 	} 	return 0; } 
#include<iostream> #include<algorithm> using namespace std;  int main() { int t,pen,n,x,y,i;     scanf("%d",&t);     while(t--)     { pen=0;               scanf("%d%d%d",&n,&x,&y);               int a[n],b[n];               for(i=0;i<n;i++)                                              scanf("%d%d",&a[i],&b[i]);                               sort(a,a+n);                               sort(b,b+n);                                                          for(i=0;i<n;i++)                           {                                           if(a[i]==b[i])                                           continue;                                                                                   else   if(b[i]>a[i])                                                 pen+=(b[i]-a[i])*x;                                                                                    else                               pen+=(a[i]-b[i])*y;                               }                                              printf("%d\n",pen);               }               return 0;               } 
#include<iostream> #include<set> using namespace std; int main() { 	int t=10; 	while(t--) 	{ 		set<int> s; 		for(int i=0;i<10;i++) 		{ 			int n; 			cin>>n; 			if(n%42>=0) 			s.insert(n%42); 		} 		cout<<s.size()<<"\n"; 	} }
#include<iostream> using namespace std; int fi(int n)       {         int result = n;         for(int i=2;i*i <= n;i++)         {           if (n % i == 0) result -= result / i;           while (n % i == 0) n /= i;         }         if (n > 1) result -= result / n;         return result;       }  	 int main() { 	int t,n,ans; 	cin>>t; 	while(t--) 	{ 		cin>>n; 		cout<<fi(n)<<endl; 		 	} 	return 0; }
//{ #include<iostream> #include<cmath> #include<algorithm> #include<climits> #include<vector> #include<bitset> #include<cstdlib> #include<cstdio> #include<cstring> #include<ctime> #include<map> using namespace std; #define MOD 1000000007LL #define LL long long #define ULL unsigned long long #define LD long double #define MAX(a,b) ((a)>(b)?(a):(b)) #define MIN(a,b) ((a)<(b)?(a):(b)) #define ABS(x)   ((x)<0?-(x):(x)) #define SQR(x) ((x)*(x)) #define CUBE(x) ((x)*(x)*(x)) #define si(n) scanf("%d",&n) #define si2(n,m) scanf("%d %d",&n,&m) #define sf(n) scanf("%f",&n) #define sl(n) scanf("%ld",&n) #define sll(n) scanf("%lld",&n) #define slu(n) scanf("%llu",&n) #define sd(n) scanf("%lf",&n) #define ss(n) scanf("%s",n) #define pnl printf("\n") #define REP(i,n) for(int i=0;i<(n);i++) #define FOR(i,a,b) for(int i=(a);i<(b);i++) #define FORR(i,n,e) for(int i=(n);i>=(e);i--) #define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d)) #define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d))  //#undef mydebug #ifdef mydebug #define DB(x) cout<<#x<<"="<<(x)<<"\n" #define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n" #define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n" #define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n" #define pnld pnl; #else #define DB(x) #define DB2(x,y) #define DB3(x,y,z) #define DB4(x,y,z,a) #define pnld #endif #define FILL(a,b) memset(a,b,sizeof(a)) const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; //template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;} void DBG_ARR(const int A[],int N){cout<<"[";REP(i,N){cout<<A[i]<<" ";}cout<<"]\n";} void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;} ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} //} void precompute(){} void doThis(){     int C,Digit;     si2(C,Digit);     int count=0;     int ans=1;     int thisDigit;     while(count<C){         int j=ans;//we will check if this is valid or not         bool inValid=false;         while(j){             thisDigit=j%10;             j/=10;             if(thisDigit==Digit){                 inValid=true;                 break;             }         }          if(!inValid){             count++;         }         ans++;      }     ans-=1;     printf("%d\n",ans); }  int main(){ #ifdef amy freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr); #endif precompute(); int t=1; scanf("%d",&t); while(t--){doThis();} #ifdef amy fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC)); #endif return 0; } 
#include <iostream> #include <sstream> #include <cstdio> #include <cmath> #include <cstring> #include <cctype> #include <string> #include <vector> #include <list> #include <set> #include <map> #include <queue> #include <stack> #include <algorithm> #include <functional> using namespace std;  #define DEBUG(x) cout << '>' << #x << ':' << x << endl; #define REP(i,n) for(int i=0;i<(n);i++) #define FOR(i,a,b) for(int i=(a);i<=(b);i++) #define FORD(i,a,b) for(int i=(a);i>=(b);i--) inline bool EQ(double a, double b) { return fabs(a-b) < 1e-9; } const int INF = 1<<29; typedef long long ll; inline int two(int n) { return 1 << n; } inline int test(int n, int b) { return (n>>b)&1; } inline void set_bit(int & n, int b) { n |= two(b); } inline void unset_bit(int & n, int b) { n &= ~two(b); } inline int last_bit(int n) { return n & (-n); } inline int ones(int n) { int res = 0; while(n && ++res) n-=n&(-n); return res; } template<class T> void chmax(T & a, const T & b) { a = max(a, b); } template<class T> void chmin(T & a, const T & b) { a = min(a, b); }  /////////////////////////////////////////////////////////////////////  bool Vis[111][111]; long long dp[111][111]; int N; int Arr[111];   long long rec(int pos, int bche) { 	if(pos == N) return dp[pos][bche] = 0; 	if(bche == 0) return dp[pos][bche] = 0;  	if(Vis[pos][bche]) return dp[pos][bche]; 	Vis[pos][bche] = true;  	long long ans = rec(pos + 1, bche); 	long long sum = 0; 	for(int i = pos; i < N; ++i) { 		ans = max(ans, rec(i + 1, bche - 1) + sum + Arr[i]); 		sum += Arr[i]; 	}  	return dp[pos][bche] = ans; }  int main() { 	scanf("%d", &N); 	for(int i = 0; i < N; ++i) { 		scanf("%d", &Arr[i]); 	}  	memset(Vis, 0, sizeof Vis); 	for(int i = N; i >= 0; --i) { 		rec(0, i); 	}  	int Q; 	scanf("%d", &Q); 	while(Q--) { 		int M; 		scanf("%d", &M);  		int low = 0; 		int high = N;  		while(high - low > 2) { 			int mid = (low + high) >> 1; 			 			long long sum = dp[0][mid]; 			if(sum >= M) { 				high = mid; 			} else { 				low = mid; 			} 		}  		int Ans = -1; 		for(int i = low; i <= high; ++i) { 			long long ans = dp[0][i]; 			if(ans >= M) { 				Ans = i; 				break; 			} 		}  		if(Ans == -1) { 			puts("Not Possible"); 		} else { 			printf("%d\n", Ans); 		}  	}     return 0; }    
#include<bits/stdc++.h> using namespace std; int main() {     int t;     cin>>t;     while(t--) {         long int n;         cin>>n;         if(n&1) cout<<"BOB"<<endl;         else cout<<"ALICE"<<endl;     }     return 0; } 
#include <bits/stdc++.h> using namespace std; typedef long long int ll; #define F(i,a,b) for(int i = (int)(a); i <= (int)(b); i++) #define RF(i,a,b) for(int i = (int)(a); i >= (int)(b); i--) #define pb push_back #define mp make_pair int main() {     #ifndef ONLINE_JUDGE         freopen("input.txt","r",stdin);         freopen("output.txt","w",stdout);     #endif     int T,N;     T = 1;     while(T--)     {         N = 999;         int Fact[100000];         int digits,carry,mult;         digits = 1;         carry = 0;         Fact[0] = 1;         F(i,1,N)         {             F(j,0,digits-1)             {                 mult = Fact[j]*i + carry;                 Fact[j] = mult%10;                 carry = mult/10;             }             while(carry > 0)             {                 Fact[digits] = carry%10;                 carry /= 10;                 digits++;             }         }         printf("%d\n",digits);         RF(i,digits-1,0) printf("%d",Fact[i]);     }     return 0; }   
#include<cstdio> #include<vector> #include<queue> #include<algorithm> using namespace std; int dp[30000]={0},xtra[1005],mask[1005],a[]={2,3,5,7,11,13,17,19,23,29,31}; #define pp pair<int,int> #define ppp pair<pp,int> vector<int> G[1005]; int main() {     int t,i,j,l=0;     scanf("%d",&t);     for(i=1;i<=1000;i++)     {         int temp=i;         for(j=0;j<11;j++)         {             while(temp%a[j]==0)             {                 mask[i]|=(1<<j);                 temp/=a[j];             }         }         xtra[i]=temp;     }     while(t--)     {         int n,arr[1005],i,j,ans=0,val=0;         scanf("%d",&n);         for(i=0;i<n;i++)         {             //printf("i=%d\n",i);             scanf("%d",&arr[i]);             if(arr[i]==1)             {             	val++;             	continue;             }             if(xtra[arr[i]]>1)                 G[xtra[arr[i]]].push_back(mask[arr[i]]);             else             {             	//printf("i=%d\n",i);                 for(j=0;j<2048;j++)                 {                     //printf("j=%d\n",j);                     int m=mask[arr[i]];                     if((m&j)==0)                     {                         dp[m|j]=max(dp[m|j],dp[j]+1);                     }                     ans=max(ans,dp[j]);                 }             }         }         for(i=2;i<=1000;i++)         {             if(G[i].empty())                 continue;             int si=G[i].size(),temp[3000]={0},k;             for(k=0;k<si;k++)             {                 int v=G[i][k];                 for(j=0;j<2048;j++)                 {                     if((v&j)==0)                     {                         temp[v|j]=max(temp[v|j],dp[j]+1);                     }                 }             }             for(j=0;j<2048;j++)             {                 dp[j]=max(dp[j],temp[j]);                 ans=max(ans,dp[j]);             }             G[i].clear();         }         //printf("val=%d ans=%d\n",val,ans);         printf("%d\n",ans+val);         for(j=0;j<2048;j++)         	dp[j]=0;     }     return 0; } 
#include<iostream> #include<algorithm> #include<cstdio> #include<string.h> #include<climits> #include<vector> #include<stack> #include<set> #include<math.h> using namespace std; #define FOR(i,a,b) for(i=a;i<=b;i++) #define sint(i) scanf("%d",&i) #define ss(s) scanf("%s",s) #define pii pair<int,int> #define mp(i,j) make_pair(i,j) #define ll long long #define MAX 1000000000 #define MOD 1000000007 #define vi vector<int> #define vvi vector < vi > #define pb(i) push_back(i); #define tr(v,it) for(it=v.begin();it!=v.end();it++) int main() {     int i;     int t;     cin>>t;     while(t--)     {          int n;         cin>>n;         int a[n];         for(int i=0;i<n;i++)         {             cin>>a[i];             cout<<a[i];         }         cout<<endl;         int pos=-1;         for(int i=n-1;i>0;i--)         {             if(a[i]>a[i-1])             {                 pos=i-1;                 break;             }         }         if(pos==-1)         {             cout<<"NO NXTBIG\n";         }         else         {             int num=11,num_pos;             for(int i=pos;i<n;i++)             {                 if(a[i]>a[pos] && a[i]<=num)                 {                     num=a[i];                     num_pos=i;                 }             }             swap(a[num_pos],a[pos]);             reverse(a+pos+1,a+n);             for(int i=0;i<n;i++)             cout<<a[i];             cout<<"\n";         }     }     return 0; } 
#include <iostream>  using namespace std;  int palin(unsigned long long n) { 	unsigned long long m = 0,x = n;	 	while ( n > 0 ) { 		m = m*10 + n%10; 		n = n/10; 	} 	if ( m == x) return 1;	 	return 0; }  int main()	 { 	unsigned long long n,i,x; 	cin >> n; 	while ( n-- ) { 		cin >> x; 		for ( i = x;; i++ ) { 			if ( palin(i) == 1 ) { 				cout << i << endl; 				break; 			} 		} 	} 	return 0; }  
#include<iostream> #include<cstdio> #include<cstdlib> #include<cstring> #include<string> #include<cmath> #include<cctype> #include<algorithm> using namespace std; int ch[52][52]; int main() {     int n,t,i,j,x,s,m;     scanf("%d",&t);     while(t--)     {         scanf("%d",&n);         for(i=1; i<=n; i++)         {             for(j=1; j<=n; j++)             {                 scanf("%d",&ch[i][j]);             }         }         for(i=2; i<=n; i++)         {             for(j=1; j<=n; j++)             {                 ch[i][j]=ch[1][j]-ch[i][j];             }         }         x=0;         for(i=2; i<=n; i++)         {             s=ch[i][1];             for(j=2; j<=n; j++)             {                 if(ch[i][j]!=s)                 {                     x=1;                     break;                 }             }         }         if(x)             printf("No\n");         else             printf("Yes\n");     }     return 0; }
#include<bits/stdc++.h> using namespace std; int main() { 	int t; 	char a[101]; 	cin>>t; 	while(t--) 	{ 		cin>>a; 		int l=strlen(a); 		int sum=0; 		int count=0; 		for(int i=0;i<l;i++) 		{ 			count++; 			if(count==7) 			{ 				count=0; 				continue; 			} 			if(a[i]=='M') 			sum+=3; 			else 			sum=sum+4; 	}  	cout<<sum<<"\n"; 	} }
#include<bits/stdc++.h> using namespace std; int d[1005][3]; int ans[1005]; int main() { 	int t,sd,sh,sv,se,ps,pm,pl;     int a[3],c[3];     a[0]=4,a[1]=6,a[2]=8; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d%d%d%d%d%d%d",&sd,&sh,&sv,&se,&c[0],&c[1],&c[2]); 		int sum=sh+sv*2+se*3; 	  for(int i=0;i<=1000;i++) 	  ans[i]=1000000; 		memset(d,0,sizeof d); 		ans[0]=0; 		for(int i=0;i<=2;i++) 		{ 			for(int j=a[i];j<=1000;j++) 			{ 			//	cout<<a[i]<<endl; 			if(ans[j-a[i]]+c[i]<ans[j]) 			{ 				ans[j]=ans[j-a[i]]+c[i]; 			    for(int k=0;k<3;k++) 			    { 			    	if(i!=k) 			    	d[j][k]=d[j-a[i]][k]; 			    	else 			    	d[j][k]=d[j-a[i]][k]+1; 			    } 			} 			} 		} 		int j=sum; 	   while(ans[j]>=1000000) 	   j++; 		printf("%d %d %d\n",d[j][0],d[j][1],d[j][2]); 	} }
#include<bits/stdc++.h> using namespace std; int bob[100005],alice[100005],lalice[100005],lbob[100005]; int main() { 	int t,n,a1,a2,b1,b2; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d%d%d%d%d",&n,&a1,&a2,&b1,&b2); 		for(int i=0;i<=n;i++) 		{ 			bob[i]=0; 			alice[i]=0; 			lbob[i]=-1; 			lalice[i]=-1; 		} 		lalice[0]=0; 		lbob[0]=0; 		for(int i=1;i<=n;i++) 		{ 			int one=i-a1,two=i-a2; 			if(one>=0&&lbob[one]>=two) 			alice[i]=1; 			one=i-b1,two=i-b2; 			if(one>=0&&lalice[one]>=two) 			bob[i]=1; 			lalice[i]=lalice[i-1]; 			lbob[i]=lbob[i-1]; 			if(!alice[i]) 			lalice[i]=i; 			if(!bob[i]) 			lbob[i]=i; 		} 		if(alice[n]) 		printf("Alice\n"); 		else 		printf("Bob\n"); 	} }
    #include<iostream>     using namespace std;     #include<algorithm>     int main()     {         long long int t,arr[100001],i,n,sam,ma=-1;         cin>>t;         while(t--)         {             cin>>n;             ma=-1;             sam=1;             for(i=0;i<n;i++)             {                 cin>>arr[i];             }             sort(arr,arr+n);             for(i=0;i<n-1;i++)             {                // cout<<i<<endl;                 if(arr[i]==arr[i+1])                 {                     sam++;                 }                 else                 {                     ma=ma<sam?sam:ma;                     sam=1;                 }              }             cout<<(ma<sam?sam:ma)<<endl;          }     } 
#include <iostream> #include <string.h>   using namespace std;   int main() { 	 	int n; 	cin>>n; 	int a[n] ,counto=0,counte=0; 	for(int i=0;i<n;i++) 	{ 		cin>>a[i]; 	} 	for(int i=0;i<n;i++) 	{ 		 		if(a[i]%2==0) 		counte++; 		else if(a[i]%2==1) 		counto++; 	} 	 	int x=counte-counto; 	if(x>=0) 	cout<<x<<endl; 	else  	cout<<-x<<endl; 	 	return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		int n; 		scanf("%d",&n); 		int arr[n]; 		int i,j; 		for(i=0;i<n;i++) 		scanf("%d",&arr[i]); 		long long s1,s2; 		s1=s2=0; 		int c=0; 		for(i=0;i<(1<<n);i++) 		{ 			s1=0; 			s2=0; 			int e1,e2; 			e1=0; 			e2=0; 			for(j=0;j<n;j++) 			{ 				if(i&(1<<j)) 				{ 					s1+=arr[j];e1++; 				} 				else 				{ 					s2+=arr[j];e2++; 				} 			} 			if(n%2==0) 			{ 				if(e1==(n/2)&&e2==(n/2)) 				{ 					if(abs(s1-s2)%7==0) 					{ 						c=1; 						break; 					} 				} 			} 			else 			{ 				if((e1==(n/2)&&e2==(n+1)/2)||(e1==(n+1)/2&&e2==(n/2))) 				{ 					if(abs(s1-s2)%7==0) 					{ 						c=1; 						break; 					} 				} 			} 		} 		if(c==0) 		{ 			printf("Vignesh\n"); 		} 		else 		{ 			printf("Aravind\n"); 		} 	} 	return 0; } 
#include<stdio.h> #include<iostream> using namespace std; main(){ 	int n,ans=1; 	cin>>n; 	if(n==1) 		cout<<1<<endl; 	else if(n==2) 		cout<<2<<endl; 	else{ 		while(n>0){ 			if(n%2==1) 				ans=ans*2; 			n=n/2; 			} 		cout<<ans<<endl; 	}  }
#include <bits/stdc++.h> using namespace std; #define pb push_back #define mp make_pair #define ff first #define ss second #define ll long long #define sd(x) scanf("%d",&x) ll group[1000005]; ll size[1000005]; map<int,ll>ans; vector<pair<int,pair<int,int> > >v; ll val=0; int findroot(int x){     if(group[x]!=x)         group[x]=findroot(group[x]);     return group[x]; } void merge(int u,int v){     u=findroot(u);     v=findroot(v);     if(u!=v){        // cout<<"hello"<<endl;        // cout<<"u= "<<u<<" "<<size[u]<<endl;        // cout<<"v= "<<v<<" "<<size[v]<<endl;         val-=((ll)((size[u])*(size[u]-1))/2);         val-=((ll)((size[v])*(size[v]-1))/2);         size[u]+=size[v];         size[v]=0;         group[v]=u;         val+=((ll)((size[u])*(size[u]-1))/2);     } } int main(){     int n,m,q;     cin>>n>>m>>q;     for(int i=1;i<=n;i++){         group[i]=i;         size[i]=1;     }     for(int i=1;i<=m;i++){         int a,b,c;         sd(a);         sd(b);         sd(c);         v.pb(mp(c,mp(a,b)));     }     sort(v.begin(),v.end());     reverse(v.begin(),v.end());     for(int i=0;i<m;i++){         merge(v[i].ss.ff,v[i].ss.ss);         ans[v[i].ff]=val;     }     vector<int>yolo;     map<int,ll>::iterator it;     for(it=ans.begin();it!=ans.end();it++){         yolo.pb(it->ff);     }     while (q--) {         int r;         sd(r);         //map<int,ll>::iterator it;         vector<int>::iterator itt;         itt = lower_bound(yolo.begin(),yolo.end(),r);         if (itt == yolo.end()) {             puts("0");             continue;         }         printf("%lld ",ans[(*itt)]);     }     return 0; } 
#include<bits/stdc++.h> #define ll long long using namespace std; ll cnt; pair<ll,ll> st[100010]; ll d[100010]; inline void scanint(ll* x) { 	register char c = getchar_unlocked(); 	*x = 0; 	for(; (c<48)||(c>57);c = getchar_unlocked()); 	for(; (c>47)&&(c<58);c = getchar_unlocked()) 		*x = (ll)((((*x)<<1) + ((*x)<<3)) + c - 48); } inline void printint(ll n) { 	if(n == 0) 	{ 		putchar_unlocked('0'); 		putchar_unlocked('\n'); 	} 	else 	{ 		char buf[20]; 		buf[19] = '\n'; 		int i = 18; 		while(n) 		{ 			buf[i--] = n % 10 + '0'; 			n /= 10; 		} 		while(buf[i] != '\n') 			putchar_unlocked(buf[++i]); 	} }     ll* merge(ll* a,ll i, ll m,ll j){   ll x,y,z;   ll n1 = m-i+1;   ll n2 = j-m;   ll c[n1],d[n2];   for(x=0;x<n1;x++){      c[x]=a[i+x];   }   for(x=0;x<n2;x++){      d[x]=a[m+1+x];   }   x=0ll;   y=0ll;   z=i;    while(x<n1&&y<n2){     if(c[x]<=d[y]){       a[z]=c[x];       x++;     }     else{       cnt=cnt+n1-x;       a[z]=d[y];       y++;     }     z++;   }    while(x<n1){     a[z]=c[x];     z++;     x++;    }   while(y<n2){     a[z]=d[y];     z++;     y++;   }   return a; } void mergesort(ll *a,ll i, ll j){   if(i<j){   ll m = (i+j)/2;   mergesort(a,i,m);   mergesort(a,m+1,j);   merge(a,i,m,j);     } }    int main(){          ll t;      //   cin>>t;         scanint(&t);          while(t--){               cnt=0;               memset(st,0,sizeof(st));                              ll n,t1,i,v,ans=0,inp;            //   cin>>n>>t1;               scanint(&n);               scanint(&t1);                for(i=1;i<=n;i++){               //    cin>>inp[i]>>v;               scanint(&inp);               scanint(&v);                    st[i]=make_pair(inp,v);                } 			 sort(st+1,st+n+1);              for(i=0;i<n;i++){              	 d[i]=st[i+1].first+st[i+1].second*t1;              }  //           			mergesort(d,0,n-1);             printint(cnt);           }  } 
#include <iostream> #include <cstring> #include <vector> #include <queue> #include <cmath> #include <string>  using namespace std;  struct node{ 	int x,y,num; 	string seq; 	 	bool operator < (node X)const{          return num > X.num;     } 	 };   bool validNode(node n){ 	if(n.x+n.y <= 200 && n.x+n.y > 0) return true; 	return false;	 }  bool visited[201][201];  int main(){ 	int T; 	node st,sd; 	int a; 	cin>>T; 	 	 	while(T--){ 	cin>>a; 	string ans = "-1"; 	if(a%5 == 0) { 		cout<<ans<<endl; 		continue; 	} 	st.x = 1; st.y = 0;st.num = 8%a;st.seq = "8"; 	sd.x = 0; sd.y = 1;sd.num = 6%a;sd.seq = "6"; 	 	priority_queue<node> Q;     Q.push(st);     Q.push(sd);     memset(visited,false,sizeof(visited));                   node aux;     while(!Q.empty()){ 		aux = Q.top(); 		Q.pop(); 		 		if(visited[aux.x][aux.y]) continue; 		visited[aux.x][aux.y] = true;                  int anum = aux.num;          		if( anum == 0){ 			ans = aux.seq; 			break; 		}  		node n1,n2; 		n1.x = aux.x+1;n1.y = aux.y;n1.num = fmod((aux.num % a)+ fmod(8*pow(10,aux.x+aux.y),a),a);n1.seq = "8"+aux.seq; 		n2.x = aux.x;n2.y = aux.y+1;n2.num = (((aux.num)*(10))%a + 6%a)%a;n2.seq = aux.seq+"6"; 		 		 		if(validNode(n1))Q.push(n1); 		if(validNode(n2))Q.push(n2); 	}	 	 	cout<<ans<<endl;	 	 } 	return 0; } 
#include<cstdio> #include<cstring> using namespace std; int main() {     int n;     scanf("%d",&n);     int a[n][n];     memset(a,0,sizeof(a));     int i,j,k,c=0,m=n*n;     if(n%2==1)     {         while(m>0)             {             for(i=n-c-1;i>=c;i--)             a[n-c-1][i]=m--;             if(m<=0)             break;             for(i=n-c-2;i>=c;i--)             a[i][c]=m--;             if(m<=0)             break;             for(i=c+1;i<=n-c-1;i++)             a[c][i]=m--;             if(m<=0)             break;             for(i=c+1;i<n-c-1;i++)         a[i][n-c-1]=m--;         c++;          }     }     else     {         while(m>0)         {             for(i=c;i<=n-c-1;i++)             a[c][i]=m--;             if(m<=0)             break;             for(i=c+1;i<=n-c-1;i++)             a[i][n-c-1]=m--;             if(m<=0)             break;             for(i=n-c-2;i>=c;i--)             a[n-c-1][i]=m--;             if(m<=0)             break;             for(i=n-c-2;i>c;i--)             a[i][c]=m--;             c++;          }     }     for(i=0;i<n;i++)     {         printf("\n");         for(j=0;j<n;j++)         printf("%d\t",a[i][j]);      }     return 0; }   
#include<iostream> #include<cstring> using namespace std ; #define rep(i,a,b) for ( int i = (a) ; i < (b) ; i++ ) int ctr = 0 ; int gr[100][100] , vis[100][100] ; int N ; int dx[4]={1,0,0,-1}; int dy[4]={0,1,-1,0};  void dfs(int m , int n) { 	if ( m==N-1 && n== N-1) ctr++ ; 	vis[m][n]=true; 	if ( m+1<N && !vis[m+1][n] && gr[m+1][n]==0 ) dfs(m+1,n) ; 	if ( n+1<N && !vis[m][n+1] && gr[m][n+1]==0 ) dfs(m,n+1) ; 	if ( m-1>=0 && !vis[m-1][n] && gr[m-1][n]==0 ) dfs(m-1,n) ; 	if ( n-1>=0 && !vis[m][n-1] && gr[m][n-1]==0 ) dfs(m,n-1) ; 	vis[m][n]=false; }  int main ( ) {  	cin >> N ; 	rep(i,0,N) rep(j,0,N) cin >> gr[i][j] ; 	memset(vis,0,sizeof(vis)); 	dfs(0,0); 	cout << ctr << endl ; 	return 0 ; }
#include<cstdio> #include<fstream> typedef long long ll; #define M 1000000007 using namespace std; #define BUF 4096 char ibuf[BUF]; int ipt = BUF;  int readInt() { 	while (ipt < BUF && ibuf[ipt] < '0') ipt++; 	if (ipt == BUF) { 		fread(ibuf, 1, BUF, stdin); 		ipt = 0; 		while (ipt < BUF && ibuf[ipt] < '0') ipt++; 	} 	int n = 0; 	while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0'); 	if (ipt == BUF) { 		fread(ibuf, 1, BUF, stdin); 		ipt = 0; 		while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0'); 	} 	return n; } int cc[]={1 ,3 ,7 ,13 ,19 ,27 ,39 ,49 ,63 ,79 ,91 ,109 ,133 ,147 ,181 ,207 ,223 ,253 ,289 ,307 ,349 ,387 ,399 ,459 ,481 ,529 ,567 ,613 ,649 ,709 ,763 ,807 ,843 ,927 ,949 ,1009 ,1093 ,1111 ,1189 ,1261 ,1321 ,1359 ,1471 ,1483 ,1579 ,1693 ,1719 ,1807 ,1899 ,1933 ,2023 ,2161 ,2187 ,2269 ,2367 ,2479 ,2533 ,2703 ,2739 ,2799 ,2967 ,3019 ,3147 ,3199 ,3327 ,3421 ,3529 ,3619 ,3807 ,3841 ,3913 ,4083 ,4203 ,4249 ,4407 ,4603 ,4623 ,4783 ,4891 ,5067 ,5163 ,5293 ,5401 ,5547 ,5667 ,5767 ,5971 ,6109 ,6159 ,6387 ,6559 ,6589 ,6799 ,6927 ,7069 ,7219 ,7369 ,7483 ,7741 ,7849 ,7963 ,8173 ,8401 ,8419 ,8607 ,8847 ,8923 ,9193 ,9303 ,9511 ,9679 ,9889,10001}; int main(){ 	int t,n,i,j; 	scanf("%d",&t); 	while(t--){ 		scanf("%d",&n); 		for(i=0;cc[i]<=n;i++){ 			printf("%d ",cc[i]); 		} 		printf("\n"); 	} 	return 0; } 
    #include<iostream>     #include<cstdio>     #include<vector>     #include<string>     using namespace std;     int a[10000500];     int main()     {     int i;     int j;     int k;     int l;     int num;     int test;     int n;     a[1]=1;     a[2]=2;     a[3]=2;     l=4;     num=3;     for(i=4;l<10000000;i++)     {     j = a[i-1];     for(k=1;k<=j;k++)     {     a[l++]=num;     }     num++;     }     scanf("%d",&test);     while(test--){     scanf("%d",&n);     printf("%d\n",a[n]);     }     return 0;     } 
#include<iostream> using namespace std; int dp[10000000]; int main() {     int n,k;     cin>>n>>k;     dp[1]=1;     for(int i=2;i<=n;i++)     {         dp[i]=(dp[i-1]+(k-1))%i+1;      }     cout<<dp[n]<<endl;  } 
 /* Come on Code on!!!! re_hash dev_cpp */  #include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <cstring> #include <queue> #include <ctime> #include <cassert> #include <climits> #include <limits> using namespace std;  #define S(a) scanf("%d",&(a)) #define P(a) printf("%d",(a)) #define NL printf("\n") #define SL(a) scanf("%lld",&(a)) #define PL(a) printf("%lld",(a)) #define ll long long int #define FOR(I,A,B) for(int I= (A); I<(B); ++I) #define all(c) c.begin(), c.end() #define stop system("pause") #define pb push_back #define mp make_pair #define tr(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++)  int main(){     int t;     S(t);     while(t--){         int a,b;         int x,y;         S(a);S(b);S(x);S(y);         int mx = max(a-x,x-1);         int my = max(b-y,y-1);         P(mx+my);         NL;     }     return 0; }          
 /* Come on Code on!!!! re_hash dev_cpp */  #include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <cstring> #include <queue> #include <ctime> #include <cassert> #include <climits> #include <limits> using namespace std;  #define S(a) scanf("%d",&(a)) #define P(a) printf("%d",(a)) #define NL printf("\n") #define SL(a) scanf("%lld",&(a)) #define PL(a) printf("%lld",(a)) #define ll long long int #define FOR(I,A,B) for(int I= (A); I<(B); ++I) #define all(c) c.begin(), c.end() #define stop system("pause") #define pb push_back #define mp make_pair #define tr(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) #define INF 100000000  int main(){     int test;     S(test);     while(test--){         int n,t,m;         S(n);S(t);S(m);         t+=t;         int dp[1500];         dp[0]=0;         FOR(i,1,m+1){             int temp;             S(temp);             dp[i]=INF;             for(int j=i;j>=max(1,i-n+1);j--){                 dp[i]=min(dp[i],max(dp[j-1],temp)+t);             }         }         P(dp[m]-t/2);         printf(" ");         P((m-1)/n + 1);         NL;     }     return 0; }                                   
#include "stdio.h" #include "stdlib.h" #include <algorithm>  long long int nC2(long int i) {return ((i*(i-1))/2);}  long int n; int *array; long int *cumulative;  int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%ld",&n); 		array = new int [n]; 		cumulative = new long int [n]; 		for(long int index=0;index<n;index++) scanf("%d",array+index); 		cumulative[0] = array[0]; 		for(long int index=1;index<n;index++) cumulative[index] = cumulative[index-1] + array[index]; 		std::sort(cumulative,cumulative+n); 		long int current = cumulative[0]; 		long int count = 1; 		long long int result = 0; 		for(long int index=1;index<n;index++) 		{ 			if(cumulative[index]==current) count++; 			else  			{	 				result += nC2(count); 				if(current == 0) result += count; 				current = cumulative[index]; 				count = 1; 			} 		} 		result += nC2(count); 		if(current == 0) result += count; 		printf("%lld\n",result); 	}   	return 0; }
#include <iostream> #include <cstdio> #include <vector> #include <cstring> #include <string> #include <map>  using namespace std;  int main(){     int t;     scanf("%d",&t);     while(t--){                int n;                scanf("%d",&n);                vector <vector <int> > bomb(201,vector <int>(201,0));                int x,y;                for(int i=0;i<n;++i){                        scanf("%d%d",&x,&y);                        bomb[x][y]=1;                        }                int cc=0;                for(int i=0;i<=200;++i){                        for(int j=0;j<=200;++j){                                if(bomb[i][j]==0)                                                 continue;                                bool a,b,c,d;                                a=false;                                for(int ii=0;ii<j;++ii){                                        if(bomb[i][ii]==1){                                                           a=true;                                                           break;                                                           }                                        }                                b=false;                                for(int ii=j+1;ii<=200;++ii){                                        if(bomb[i][ii]==1){                                                           b=true;                                                           break;                                                           }                                        }                                c=false;                                for(int ii=0;ii<i;++ii){                                        if(bomb[ii][j]==1){                                                           c=true;                                                           break;                                                           }                                        }                                 d=false;                                for(int ii=i+1;ii<=200;++ii){                                        if(bomb[ii][j]==1){                                                           d=true;                                                           break;                                                           }                                        }                                                         if((a & b & c & d))                                      cc++;                                                 }                        //cout<<endl;                        //system("pause");                        }                printf("%d\n",cc);                }     return 0; }  
#include <cstdio>   #define MOD 1000000007   int fact[5001], invfact[5001];   int powmod(int base, int expo){     if(expo==0) 		return 1; 	else if(expo&1) 		return (long long)base*powmod(base, expo-1)%MOD; 	else{ 		int root=powmod(base, expo>>1); 		return (long long)root*root%MOD; 	} }   int inverse(int x){ 	return powmod(x, MOD-2); }   void init(){ 	fact[0]=1; 	for(int i=1; i<=5000; i++) 		fact[i]=(long long)i*fact[i-1]%MOD; 	invfact[5000]=inverse(fact[5000]); 	for(int i=5000; i>0; i--) 		invfact[i-1]=(long long)i*invfact[i]%MOD; }   int nCr(int n, int r){ 	if(r>n || r<0) 		return 0; 	return (long long)((long long)fact[n]*invfact[r]%MOD)*invfact[n-r]%MOD; }   int main(){ 	init(); 	int N, K; 	while(scanf("%d %d", &N, &K) && !(N==0 && K==0)){         if(K==0) {puts("0");continue;}         N = N/2;         		int res=2ll*nCr(N-1, (K)/2)*nCr(N-1, (K-1)/2)%MOD; 		printf("%d\n", res); 	} }  
#include <stdio.h> #include <stdlib.h> #include <string.h> #define Hash 1001007 using namespace std;  int fa[Hash],num[Hash]; int son[Hash],next[300001],tot; char str[300001][100]; int T,n,i,j,k,aim,a1,a2; char s1[100],s2[100],s[100];  int hash(char s[],int l) { 	int i; 	long long re=0; 	for(i=0;i<l;++i)re=(re*1456+s[i]+78114)%Hash; 	return re; }  int get(int p) { 	if(fa[p]==p)return p; 	fa[p]=get(fa[p]); 	return fa[p]; }  int main() { 	scanf("%d",&T); 	for(;T;--T) 	{ 		scanf("%d",&n); 		for(i=0;i<Hash;++i)son[i]=0; 		for(i=1;i<=n;++i) 		{ 			scanf("%s%s",s1,s2); 			a1=j=hash(s1,strlen(s1)); 			for(j=son[j];j;j=next[j])if(strcmp(str[j],s1)==0)break; 			a2=k=hash(s2,strlen(s2)); 			for(k=son[k];k;k=next[k])if(strcmp(str[k],s2)==0)break; 			if(!j){++tot;j=tot;memcpy(str[j],s1,sizeof(s1));next[tot]=son[a1];son[a1]=tot;fa[tot]=tot;num[tot]=1;} 			if(!k){++tot;k=tot;memcpy(str[k],s2,sizeof(s2));next[tot]=son[a2];son[a2]=tot;fa[tot]=tot;num[tot]=1;} 			j=get(j);k=get(k); 			if(j!=k) 			{ 				fa[j]=k; 				num[k]+=num[j]; 			} 			printf("%d\n",num[get(j)]); 		} 	} } 
#include <ios> #include <cstring> #include <algorithm> using namespace std;  const int MAX = 100; int dp[MAX][MAX], lcslen, len1, len2; char s1[MAX], s2[MAX], s3[MAX];  int lcs(int i, int j) { 	int &ret = dp[i][j]; 	if(i==len1 || j==len2) return ret = 0; 	if(ret != -1) return ret; 	ret = 0; 	if(s1[i]==s2[j]) ret = 1 + lcs(i+1, j+1); 	else ret = max(lcs(i+1, j), lcs(i, j+1)); 	return ret; }  void printAll(int na, int nb, int d) { 	if(d==lcslen) { 		s3[d] = 0; 		puts(s3); 		return; 	} 	if(na==len1 || nb==len2) return; 	for(char ch='a'; ch<='z'; ch++) { 		bool done = false; 		for(int i=na; i<len1; i++) { 			if(ch==s1[i]) { 				for(int j=nb; j<len2; j++) { 					if(ch==s2[j] && lcs(i, j)==lcslen-d) { 						s3[d] = ch; 						printAll(i+1, j+1, d+1); 						done = true; 						break; 					} 				} 			} 			if(done) break; 		} 	} }  int main() { 	int t, i, j; 	scanf("%d", &t); 	while(t--) { 		scanf("%s%s", s1, s2); 		len1 = strlen(s1); 		len2 = strlen(s2); 		for(i=0; i<len1; i++) 			for(j=0; j<len2; j++) 				dp[i][j] = -1; 		lcslen = lcs(0, 0); 		printAll(0, 0, 0); 		if(t) puts(""); 	} 	return 0; }
#include <iostream> #include <cstdio> #include <cmath> using namespace std; int main () {     char ch[10];     while (scanf("%s",ch)!=EOF)     {         int i,ans,n,e;         n=10*(ch[0]-'0')+ch[1]-'0';         e=ch[3]-'0';         if(!(n||e))break;         while (e--)          n*=10;         int c=1;         while (c<=n)          c<<=1;         ans=((n-(c>>1))<<1)+1;         printf("%d\n",ans);     }     return 0; }
#include<iostream> #include<cstdio> #include<cstring> #include<cmath>  using namespace std;  int n,m,ms; int set[1001][1001];  struct st{ 	int p,sz; }s[1001000];   int findSet(int x){ 	if( x!=s[x].p ) return s[x].p=findSet(s[x].p); 	return s[x].p; } void Union(int x,int y){  ///cout<<x<<" link "<<y<<endl; 	x=findSet(x); y=findSet(y); 	if( x==y ) return ; 	s[x].p=y; 	s[y].sz+=s[x].sz; 	ms=max(ms,s[y].sz); }  int main (){ 	scanf("%d %d",&n,&m); 	int q; scanf("%d",&q); 	for(int i=0;i<=n;i++) { 		 s[i].p=-1; s[i].sz=1; 	} 	for(int i=0;i<q;i++){ 		int c,a,b; 		scanf("%d",&a); 		if( a==0 ) printf("%d\n",ms); 		else { 			scanf("%d %d",&a,&b); // cout<<a<<" "<<b<<endl; 			if( set[a][b] ) continue; 			set[a][b]=1; ms=max(ms,1); 			 			c=(a-1)*m+b;  //cout<<"c"<<c<<endl; 			s[c].p=c; s[c].sz=1; 			 			if( a-1   && set[a-1][b])  Union(c, (a-2)*m+b); 			if( b-1   && set[a][b-1])  Union(c, (a-1)*m+b-1); 			if(a+1<=n && set[a+1][b])  Union(c, (a  )*m+b); 			if(b+1<=m && set[a][b+1])  Union(c, (a-1)*m+b+1); 			 		} 	} 	 	 	return 0; }
#include<iostream> #include<bits/stdc++.h> using namespace std; char s[200001]; int a[200001][26]={0}; int main() { 	 	cin>>s; 	long int q; 	cin>>q; 	long int l=strlen(s); 	for(int i=0;i<l;i++) 	{ 		for(int j=0;j<26;j++) 		{ 			if(i!=0) 			a[i][j]=a[i-1][j]; 		} 		a[i][s[i]-'a']++; 	} 	while(q--) 	{ 		long int l,r; 		cin>>l>>r; 		int ans=0; 		int flag=0; 		for(int i=0;i<26;i++) 		{ 			if(l!=1) 		    ans+=a[r-1][i]-a[l-2][i]; 		    else 		    ans+=a[r-1][i]; 		    if(ans%2!=0) 		    { 		    	ans=ans-1; 		    	flag=1; 			} 		     		} 		if(flag) 		{ 			ans=ans+1; 		} 		cout<<ans<<"\n"; 		 	} 	 }
#include<iostream> #include<cstring> using namespace std;   int main() { 	int i,j,k,t,n,f,count,len,len1; 	char str[10001]; 	cin>>t; 	while(t--) 	{ 	   cin>>str; 	  len=0; 	  len1=strlen(str)-1; 	   f=1; 	   count=0; 		while(len<len1) 		{ 		    if(str[len]!=str[len1]) 		    { 		    	if(count==0) 		    	count++; 		    	else 		    	{ 		    		f=0; 		    		break; 				} 			} 			len++; 			len1--; 		} 	      	if(f)      	cout<<"yes"<<endl;      	else      	cout<<"no"<<endl; 	} 	return 0; }  
#include <stdio.h> #include <string.h>   int main() {     int test_cases, i, cost_a, cost_b, totalcost;     scanf("\n%i", &test_cases);     char s[10001];     while(test_cases--)     {         scanf("\n%[^\n]", s);         scanf("\n%i\n%i", &cost_a, &cost_b);         int temp = strlen(s), flag = 1, min_cost = cost_a<cost_b ? cost_a : cost_b;         totalcost = 0;         for (i=0 ; i<temp/2; i++)         {             if (s[i]=='/' || s[temp-i-1]=='/')             {                 if (s[i] == s[temp-i-1])                     totalcost += 2*min_cost;                 else if (s[i]=='a' || s[temp-i-1]=='a')                     totalcost +=cost_a;                 else if (s[i]=='b' || s[temp-i-1]=='b')                     totalcost +=cost_b;             }             else if (s[i] != s[temp-i-1])             {                 flag = 0;                 printf("-1\n");                 break;             }         }         if (flag)             printf("%i\n",totalcost);     }     return 0; }
#include <bits/stdc++.h>  using namespace std;  #define FOR(i,a,b) for(int i=(a);i<(b);i++) #define SZ(x) ((int)(x).size()) #define FORV(i,x) FOR(i,0,SZ(x)) #define FORD(i,a,b) for(int i=(a);i>=(b);i--) #define MP make_pair #define PB push_back #define ALL(x) x.begin(),x.end() #define ULL unsigned long long #define LL long long #define mset(x,v) memset(x,v,sizeof x) #define F first #define S second  string s,x;  int main() { 	ios::sync_with_stdio(false); 	int t,n; 	cin>>t; 	while(t--) 	{ 		cin>>n>>s; 		x=s; 		reverse(ALL(x)); 		cout<<((x==s)?1:2)<<endl; 	} 	return 0; } 
#include <iostream> #include <cstdio> #include <cstring> using namespace std;  int main() {     int t, q;     scanf("%d", &t);     while(t--)     {         char a[100001];         scanf("%s", a);         scanf("%d", &q);         while(q--)         {             char word[100001], *p;             int c=0;             scanf("%s", word);             p=strstr(a, word);             while(p!=NULL)             {                 p=strstr(p+1,word);                 c++;             }             printf("%d\n", c);         }      }      return 0; } 
#include<iostream> #include<cstdlib> #include<cstdio> #include<vector> #include<climits> using namespace std;  int min(vector<int>& v) {   int j,minval=INT_MAX;   for(j=0;j<v.size();j++)   {     if(v[j]<minval) 		minval=v[j];   }   return minval; }  void print(vector<int>& x) {   int i;   for(i=0;i<x.size();i++) 	  cout << x[i] << " ";    cout << "\n"; } int main() { vector<int> v; vector<int> w; int t,i,n,n1,j,value,minval1,minval2,flag;  scanf("%d",&t); for(i=0;i<t;i++) {  flag=0;   scanf("%d",&n);   int size=v.size();   if(size!=0)   {    v.erase(v.begin(),v.begin()+size);   }     for(j=0;j<n;j++)   {    scanf("%d",&value);    v.push_back(value);   }   while(1)   { 	minval1=INT_MAX; 	minval2=INT_MAX;    if(v.size()==0 && w.size()==0)      break;    if(v.size()!=0)     minval1=min(v);    if(w.size()!=0)    minval2=min(w);    int l1=w.size();      if(minval1<minval2)    { 	if(v.size()!=0) 	{	       n1=v[0];      if(n1!=minval1) 	 { 	 w.push_back(n1);      }         v.erase(v.begin()); 	}      }     else    {     if(l1!=0)     {      int k1=l1-1;       n1=w[k1];     if(n1!=minval2)     {        flag=1;         w.erase(w.begin(),w.begin()+l1);     	break;     }     else      w.erase(w.begin()+k1);     } 	else 	 break;   }         }       if(flag==1)    printf("no\n");   else 	printf("yes\n");    } return 0; } 
#include <iostream> #include <string> #include <climits> #include <cstdio> #include <cstdlib> #include <cmath> #include <vector> #include <algorithm> #include <utility> #include <queue> #include <stack> #include <map> #include <set> #include <cstring> using namespace std; #define PR(x) cout << #x " = " << x << "\n"; #define EMPTY 2147483647 void orderify(std::vector<std::vector<int> > &p, int i, int j, int &count, int r, int c) { 	if (i>r || j>c) 	{ 		return; 	} 	int x=-1, y=-1;  	if (i+1<r && p[i+1][j]<p[i][j]) 	{ 		p[i][j]=p[i+1][j]; 		x=i+1; y=j; 	} 	if (j+1<c && p[i][j+1]<p[i][j]) 	{ 		p[i][j]=p[i][j+1]; 		x=i; y=j+1; 	}  	if (x!=-1) 	{ 		count++; 		p[x][y]=INT_MAX; 		orderify(p, x, y, count,r,c); 	} } int main(int argc, char const *argv[]) { 	ios_base::sync_with_stdio(0); 	int r,c, t,temp; cin>>t; 	while(t--) 	{ 		cin>>r>>c; 		std::vector<std::vector<int> > p(r, std::vector<int> ()); 		for (int i = 0; i < r; ++i) 		{ 			for (int j = 0; j < c; ++j) 			{ 				cin>>temp; 				p[i].push_back(temp); 				if (p[i][j]==EMPTY) p[i][j]=INT_MAX; 			} 		}  		p[0][0]=INT_MAX; 		int count=0; 		orderify(p,0,0,count,r,c); 		cout<<count<<endl; 	} 	return 0; }
#include <iostream> using namespace std;   int main() {     int t;          cin>>t;          while(t--)     {         int n,i,j,flag=0;                  cin>>n;                  int a[n][n];                  for(i=0;i<n;i++)         {             for(j=0;j<n;j++)             {                 cin>>a[i][j];             }         }                  int k=n/2;                  for(i=0;i<n;i++)         {             for(j=0;j<n;j++)             {                 if(a[i][j]!=a[n-1-i][n-j-1])                 {                     flag=1;                                  }             }         }                           if(flag==0)         cout<<"Yes"<<"\n";         else         cout<<"No"<<"\n";     } }
#include <queue> #include <algorithm> #include <iostream> #include <cmath> #include <cstdlib> #include <cstring> #include <numeric>  #define FOR(A,B,C) for(int A=B;A<C;A++) #define EFOR(A,B,C) for(int A=B;A<=C;A++) #define RFOR(A,B,C) for(int A=B;A>=C;A--) #define MEM(A,B) memset(A,B,sizeof(A)) #define PB(A,B) A.push_back(B); #define SZ(A) int(A.size()) #define MP(A,B) make_pair(A,B)  using namespace std;  inline void Input(int &N) { 	int ch; 	N=0;  	while((ch<'0'||ch>'9') && ch!=EOF) 		ch=getchar();  	do 		N=(N<<3)+(N<<1)+(ch-'0'); 	while((ch=getchar())>='0' && ch<='9');  	return; }  int R,C; /*int grid[3000][3000]; int mxD[2][3000]; int mnD[2][3000];  void optPath() { 	mxD[0][0]=mnD[0][0]=grid[0][0];  	FOR(cl,1,C){ 		mxD[0][cl]=mxD[0][cl-1]+grid[0][cl]; 		mnD[0][cl]=mnD[0][cl-1]+grid[0][cl]; 	}  	FOR(rw,1,R){ 		mxD[rw&1][0]=mxD[(rw-1)&1][0]+grid[rw][0]; 		mnD[rw&1][0]=mnD[(rw-1)&1][0]+grid[rw][0];  		FOR(cl,1,C){ 			mxD[rw&1][cl]=max(mxD[rw&1][cl-1],mxD[(rw-1)&1][cl])+grid[rw][cl]; 			mnD[rw&1][cl]=min(mnD[rw&1][cl-1],mnD[(rw-1)&1][cl])+grid[rw][cl]; 		} 	}  	printf("%d %d\n",mxD[(R-1)&1][C-1],mnD[(R-1)&1][C-1]);  	return; }*/  int main() { //	freopen("Input.txt","r",stdin); 	int T; 	Input(T);  	char A[3001],B[3001]; 	while(T--){ 		Input(R); 		scanf("%s",A);  		Input(C); 		scanf("%s",B);  		int firR1=-1,lstC1=-1,lstR1; 		int firR0=-1,firC0=-1,lstR0,lstC0;  		FOR(rw,0,R){ 			if(A[rw]=='1'){ 				firR1=(firR1==-1)?rw:firR1; 				lstR1=rw; 			} else { 				firR0=(firR0==-1)?rw:firR0; 				lstR0=rw; 			} 		}  		FOR(cl,0,C){ 			if(B[cl]=='1') 				lstC1=cl; 			else { 				firC0=(firC0==-1)?cl:firC0; 				lstC0=cl; 			} 		}  		int mx;  		if(firR1==-1 || lstC1==-1) 			printf("0 "); 		else { 			mx=0; 			EFOR(cl,0,lstC1)		mx+=(B[cl]-'0'); 			FOR(rw,firR1+1,R)		mx+=(A[rw]-'0'); 			printf("%d ",mx); 		}  		if(firR0==-1 && firC0==-1) 			printf("%d\n",R+C-1); 		else if(firR0==-1) 			printf("%d\n",count(B,B+C,'1')); 		else if(firC0==-1) 			printf("%d\n",count(A,A+R,'1')); 		else 			printf("%d\n",min(firR0,firC0)+min(C-1-lstC0,R-1-lstR0)); 	}  //	fclose(stdin); 	return 0; } 
#include<iostream> #include<fstream> #include<vector> #include<cstring> #include<map> #define in cin #define out cout using namespace std; const int Nmax = 1001; const int MOD1 = 734057; const int MOD2 = 941911; int d[2][Nmax][Nmax]; char s[Nmax+2]; map< pair<int,int>,vector< pair<int,int> > > M; int main(){     #ifndef ONLINE_JUDGE     ifstream in("test.in");     ofstream out("test.out");     #endif     d[0][0][1]=d[1][0][1]=1;     for(int i=1;i<Nmax;i++){         for(int j=1;j<Nmax;j++){             d[0][i][j]=(d[0][i-1][j]+d[0][i][j-1])%MOD1;             d[1][i][j]=(d[1][i-1][j]+d[1][i][j-1])%MOD2;             M[make_pair(d[0][i][j],d[1][i][j])].push_back(make_pair(i,j));         }     }     int T; in>>T; in.get();     while(T--){         in.getline(s+1,Nmax);         int n=strlen(s+1);         int m1=0,m2=0;         for(int i=1;i<=n;i++){             m1=(m1*10+(int(s[i])-'0'))%MOD1;             m2=(m2*10+(int(s[i])-'0'))%MOD2;         }         int mn=M[make_pair(m1,m2)].size();         if(mn==0) out<<"The Grid is Too Big!\n";         else{             out<<mn<<'\n';             for(vector< pair<int,int> >::iterator it=M[make_pair(m1,m2)].begin();it!=M[make_pair(m1,m2)].end();++it){                 out<<it->first<<' '<<it->second<<'\n';             }         }     }     return 0; }
#include <bits/stdc++.h> #define ll long long using namespace std; ll int ans,mat[30][30],visited[30][30]; ll int n,m; bool valid(int x,int y) { 		if(x>=0 && x<n && y>=0 && y<m && mat[x][y]==0 && !visited[x][y]) 		return 1; 		return 0; } void mydfs(ll int x,ll int y) { 	ll int p=0; 	if(valid(x,y)) 	{ 		visited[x][y]=1; 		if(valid(x+1,y)) 		{ 			p++; 		} 		if(valid(x-1,y)) 		{ 			p++; 		} 		if(valid(x,y-1)) 		{ 			p++; 		} 		if(valid(x,y+1)) 		{ 			p++; 		} 		if(valid(x+1,y)) 		{ 			mydfs(x+1,y); 		} 		if(valid(x-1,y)) 		{ 			mydfs(x-1,y); 		} 		if(valid(x,y-1)) 		{ 			mydfs(x,y-1); 		} 		if(valid(x,y+1)) 		{ 			mydfs(x,y+1); 		} 		if(p!=0) 		{ 			//~ cout<<p<<endl; 			ans*=p; 		} 	} } int main() { 	ios_base::sync_with_stdio(false); 	cin.tie(NULL); 	ll int test; 	cin>>test; 	while(test--) 	{ 		cin>>n>>m; 		ll int i,j; 		string s; 		for(i=0;i<n;i++) 		{ 			cin>>s; 			for(j=0;j<m;j++) 			{ 				mat[i][j]=(s.at(j)-'0'); 				visited[i][j]=0; 			} 		} 		ans=1; 		bool found=0; 		for(i=0;i<n;i++) 		{ 			for(j=0;j<m;j++) 			{ 				if(mat[i][j]==0) 				{ 					mydfs(i,j); 					found=1; 					break; 				} 			} 			if(found) 			break; 		} 		cout<<ans<<endl; 	} 	return 0; } 
#include <iostream> #include <climits> using namespace std; int eggDrop(int f, int e) { 	if(f <= 1) 		return f; 	int dp[f+1][e+1]; 	for(int i=0;i<=f;i++) 		for(int j=0;j<=e;j++) 			dp[i][j] = 0; 	for(int i=1;i<=f;i++) 	{ 		for(int j=1;j<=e;j++) 		{ 			if(j == 1) 			{ 				dp[i][j] = i; 				continue; 			} 			int currMin = INT_MAX; 			int tmp; 			for(int k=1;k<=i;k++) 			{ 				tmp = ((dp[k-1][j-1]+1)>dp[i-k][j]?(dp[k-1][j-1]+1):dp[i-k][j]); 				tmp++; 				if(tmp < currMin) 					currMin = tmp; 			} 			dp[i][j] = currMin; 		} 	} 	/* 	for(int i=0;i<=f;i++) 	{ 		for(int j=0;j<=e;j++) 			cout << dp[i][j] << " "; 		cout << endl; 	} 	*/ 	dp[f][e]++; 	return dp[f][e]; }   int main() { 	//code 	int tc; 	cin >> tc; 	int n,k; 	while(tc-- > 0) 	{ 	    cin >> n >> k; 	    cout << eggDrop(n,k) << endl; 	} 	return 0; } 
#include<stdio.h> #include<math.h> #define ld long double  ld abs(ld a) { return a>0?a:-a; } ld max(ld a, ld b) { return a>b?a:b; }  int main()  { 	int N, min_index = 0; 	scanf("%d", &N); 	ld ave_x = 0.0, ave_y = 0.0, min, sum = 0.0, x[N+1], y[N+1]; 	 	for(int i=0; i<N; i++)  scanf("%Lf%Lf",&x[i],&y[i]); 	 	for(int i=0; i<N; i++)  	{ 		ave_x += x[i]/(ld)N; 		ave_y += y[i]/(ld)N; 	} 	 	min = sqrt((ave_x-x[0])*(ave_x-x[0]) + (ave_y-y[0])*(ave_y-y[0])); 	for(int i=1; i<N; i++)  	{ 		ld quo = sqrt((ave_x-x[i])*(ave_x-x[i]) + (ave_y-y[i])*(ave_y-y[i])); 		if(quo < min)  		{ 			min = quo; 			min_index = i; 		} 	} 	 	for(int i=0; i<N; i++)   sum += max(abs(x[min_index]-x[i]), abs(y[min_index]-y[i])); 	printf("%0.0Lf\n",sum); 	 	return 0; }
#include<iostream> using namespace std; int TestAdd(int a,int b) {          if(a <1)return b;         return(TestAdd((a&b)<<1,a^b));     } int main() {     int n1,n2,sum;     cin>>n1>>n2;     sum=TestAdd(n1,n2);     cout<<sum;     return 0; }
#include<bits/stdc++.h> using namespace std; #define lint long long int main() {     int temp,index,x,num,l,t,r,it;     scanf("%d",&it);     while(it--)     {     int two[100]={1};     scanf("%d%d",&num,&r);     if(num==r) printf("0.00\n");     else if(r==0){     l=0;     num=num-r+1;     for(t=1;t<=num;t++)     {         temp=0;         for(index=0;index<=l;index++)         {             x=(two[index]*2)+temp;             two[index]=x%10;             temp=x/10;         }         for(temp;temp!=0;temp=temp/10)         {             l++;             two[l]=temp%10;         }      }     for(t=l;t>=1;t--)     {         printf("%d",two[t]);     }          printf("%d.00\n",two[0]-2);      }     else     {       l=0;     num=num;     for(t=1;t<=num;t++)     {         temp=0;         for(index=0;index<=l;index++)         {             x=(two[index]*2)+temp;             two[index]=x%10;             temp=x/10;         }         for(temp;temp!=0;temp=temp/10)         {             l++;             two[l]=temp%10;         }      }     for(t=l;t>=1;t--)     {         printf("%d",two[t]);     }          printf("%d.00\n",two[0]);      }      }     } 
#include <iostream> #include <cstdio> #include <string> #include <algorithm> #include <vector> #include <sstream>  using namespace std;  int main(){ 	int T; 	cin >> T; 	string emptyLine; 	getline(cin, emptyLine); 	while(T--){ 		vector< vector<string> > info(5); 		for(int i = 0; i < 5; i++){ 			string line; 			getline(cin, line); 			stringstream ss(line); 			string item; 			while (std::getline(ss, item, ' ')) { 				info[i].push_back(item); 			} 		}  		/*for(int i = 0; i < 5; i++){ 			for(vector<string>::iterator it = info[i].begin(); it != info[i].end(); it++) 				cout << *it << "\t"; 			cout << endl; 		}*/   		string seq = "ABCDE"; 		bool found = false; 		do { 			bool next = false; 			for(int i = 0; i < 5 && !next; i++){ 				char check = 'A'+i; 				int j = seq.find(check); 				for(vector<string>::iterator it = info[i].begin(); it != info[i].end() && !next; it++){ 					if (isalpha((*it)[0])){ 						if((*it)[0] == 'N'){ 							if (isalpha((*it)[1])){ 								if ((j<4 && seq[j+1] == (*it)[1]) || (j>0 && seq[j-1] == (*it)[1])) 								{ 									next = true; 									continue; 								} 							} 							else{ 								if (j == (*it)[1]-'1') 								{ 									next = true; 									continue; 								} 							} 						} 						else{ 							if ((j<4 && seq[j+1] != (*it)[0]) && (j>0 && seq[j-1] != (*it)[0])) 							{ 								next = true; 								continue; 							}  						} 					} 					else if ((*it)[0] == '+'){ 						int k; 						for (k = j+1; k < 5; k++) 							if (seq[k] == (*it)[1]) 								break; 						if (k != 5) 						{ 							next = true; 							continue; 						} 					} 					else if ((*it)[0] == '-'){ 						int k; 						for (k = j-1; k >= 0; k--) 							if (seq[k] == (*it)[1]) 								break; 						if (k != -1) 						{ 							next = true; 							continue; 						} 					} 					else{ 						if (j != (*it)[0] - '1') 						{ 							next = true; 							continue; 						} 					} 				} 			}  			if (!next){ 				found = true; 				break; 			}  		} while ( next_permutation(seq.begin(),seq.end()) && !found);  		cout << seq << endl; 	}  	return 0; } 
#include <iostream> #include <cstdio> #include <cstring> #include <queue> #include <algorithm> #include <vector> #include <cassert> using namespace std; int _clock;  struct Chef { 	int working; 	bool isWorking() 	{ 		return working != 0; 	} 	void work() 	{ 		assert(working); 		working++; 		if(working == 6) working = 0; 	} }chef[5]; void pass() { 	for (int i = 0; i < 5; ++i) 		if (chef[i].isWorking()) chef[i].work(); 	_clock++; } int waittime; struct Per { 	int time; 	int order[5]; 	int p; 	bool servered; 	bool isServered() 	{ 		return servered; 	} 	Per(){p = 0; servered = false;} 	void finish() 	{ 		order[cuisine()] -= 2; 		servered = false; 	} 	void wait() 	{ 		waittime++; 	} 	int cuisine() 	{ 		if (p == 5) return 5; 		while (order[p] == 0) p++; 		return p; 	} 	void deal() 	{ 		servered = true; 	} 	bool operator < (const Per &e)const 	{ 		return time < e.time; 	} }; const int Maxn = 1000000; Per que[Maxn]; int in, out; vector<Per> vec; int s, n; void solve() { 	in = 0, out = 0; 	//cout << vec[1].time <<" " << vec.size() << endl; 	for (_clock = 0; s < vec.size() || in > out; pass()) 	{ 		if (s < vec.size()) 		{ 			if (_clock == vec[s].time) 			{ 				que[(in++) % Maxn] = vec[s]; 				s++; 			} 		} 		while (in > out) 		{ 			int cui = que[(out) % Maxn].cuisine(); 			if (cui == 5)  			{ 				out++; 				continue; 			} 			if (que[out % Maxn].isServered() && chef[cui].isWorking() == false)  			{ 			//	cout << que[out].time <<" " << cui << endl; 				que[out % Maxn].finish(); 				que[(in++) % Maxn] = que[(out++) % Maxn]; 				chef[cui].working = 1; 			} 			else break; 		} 		if (in > out) 		{	 			Per& p = que[out % Maxn]; 			int cui = p.cuisine(); 			if (p.isServered() == false) 			{ 				p.deal(); 			//	cout<< _clock <<" " <<p.time << " " << p.p<<" " <<chef[cui].working<< endl; 			} 			else if (chef[cui].isWorking()) 				p.wait(); 		} 	} }  int main() { 	int T; 	scanf("%d", &T); 	while (T--) 	{ 		waittime = 0; 		s = 0; 		scanf("%d", &n); 		vec.clear(); 		for (int i = 0; i < n; ++i) 		{ 			Per per; 			scanf("%d", &per.time); 			for (int j = 0; j < 5; ++j) 				scanf("%d", &per.order[j]); 			per.p = 0; 			vec.push_back(per); 		} 		sort(vec.begin(), vec.end()); 		solve(); 		printf("%d\n", waittime); 	} 	return 0; }
#include<iostream> #include<cstdio>  using namespace std;  struct point {        int x,y; }p[4];  int dist(point a, point b) {     return (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y); }  bool lineIntersects(point a1,point a2,point b1,point b2) {      float det;      det = (a2.x - a1.x) * (b2.y - b1.y) - (b2.x - b1.x) * (a2.y - a1.y);            if(det == 0)      return 0;            float num1,num2;            num1 = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y)*(a1.x - b1.x);            num2 = (b2.x - b1.x)*(a1.y - b1.y) - (b2.y - b1.y)*(a1.x - b1.x);            if((num1 < 0) == det > 0)      return 0;            if((num2 < 0) == det > 0)      return 0;            if( ((num1 > det) == (det > 0)) || ((num2 > det) == (det > 0)) )      return 0;             return 1; }  int cross(point a,point b,point c) {     return (b.x - a.x)*(c.y - a.y) - (b.y - a.y)*(c.x - a.x); }   int main() {     int t,x,y;          int i,j;          scanf("%d",&t);                   while(t--)     {           for(i=0;i<4;i++)           {              scanf("%d%d",&x,&y);              p[i].x = x;              p[i].y = y;               }                          int diag1,diag2,side1,side2;                      int flag = 0;                      for(i=0;i<4;i++)           {              for(j=i+1;j<4;j++)              {                 if((p[i].x == p[j].x) && (p[i].y == p[j].y))                 {                    flag = 1;                 }              }           }                      int flag1 = 0;                      if(!cross(p[0],p[1],p[2]))           flag1 = 1;                      if(!cross(p[1],p[2],p[3]))           flag1 = 1;                      if(!cross(p[2],p[3],p[0]))           flag1 = 1;                      if(!cross(p[3],p[0],p[1]))           flag1 = 1;                      if(flag || flag1 || lineIntersects(p[0],p[1],p[2],p[3]) || lineIntersects(p[0],p[3],p[1],p[2]) )           {                   printf("NONE\n");           }                     else if( (p[0].x + p[2].x == p[1].x + p[3].x) && (p[0].y + p[2].y == p[1].y + p[3].y) )           {                    side1 = dist(p[0],p[1]);                    side2 = dist(p[0],p[3]);                    diag1 = dist(p[0],p[2]);                    diag2 = dist(p[1],p[3]);                                        if(diag1 == diag2)                    {                             if(side1 == side2)                             {                                      printf("SQUARE\n");                             }                             else                             {                                      printf("RECTANGLE\n");                             }                    }                    else                    {                             if(side1 == side2)                             {                                      printf("RHOMBUS\n");                             }                             else                             {                                      printf("PARALLELOGRAM\n");                             }                    }           }           else           {                    printf("QUADRILATERAL\n");           }                }     return 0; } 
#include <iostream> #include <cstdio> #include <vector> #include <stack> #include <queue> #include <string> #include <cstring> #include <map> #include <cstdlib> #include <algorithm> #include <list> #include <deque> #include <bitset> #include <cmath> #include <functional> #include <set>  using namespace std;  bool esPrimo(int n) {     if (n < 2) return false;     if (n == 2) return true;     if (n % 2 == 0) return false;     int sqr = (int)sqrt(n);      for (int i = 3; i <= sqr; i += 2)     {         if (n % i == 0)         {             return false;         }     }     return true; }  int sumarDig(string n) {     int sum = 0;     for (int i = 0; i < n.size(); i++)     {         sum +=  (n[i]-'0');     }     return sum; }  char buffer[100]; std::string to_string(int k){ 	sprintf(buffer, "%d", k); 	return std::string(buffer); }  int main() {     int t ;     scanf("%d", &t);     while (t--)     {         int L,U;         scanf("%d", &L);         scanf("%d", &U);          int ans = 0;         for (int i = L; i <= U; i++)         {             if (esPrimo(sumarDig(to_string(i)  )))             {                 ans++;             }         }         printf("%d\n", ans);     }   } 
#include<bits/stdc++.h> using namespace std; #define sd(x) scanf("%d",&x) #define slld(x) scanf("%lld",&x) #define ss(x) scanf("%s",x) #define ll long long #define mod 1000000007 #define bitcount    __builtin_popcountll #define pb push_back int main() {     //freopen("in.txt","r",stdin);     //freopen("out.txt","w",stdout);     int t,n,i,j,k,a[55],b[55],s,s1;     sd(t);     while(t--)     {     	sd(n);     	s=0;     	for(i=0;i<n;i++)     	{     		sd(a[i]);     		s+=a[i];     	}     	s-=(n*(n-1))/2;     	if(s>=0&&s%n==0)     	{     		s1=0;     		for(i=0;i<n;i++)     		{     			b[i]=i+s/n;     			s1+=abs(a[i]-b[i]);     		}     		printf("%d\n",s1/2);        	}        	else        		printf("-1\n");     }     return 0; }
//some variables var four_letter_words = ["doup","frig","ours","skep","smar","spad","rale","plat","viol","esox","culb","amok","oont","coif","coir","aver","keen","vuln","tsar","apse","onyx","peen"]; var seven_letter_words = ["abalone","abandon","ability","abolish","abdomen","abraham","abyssal","academy","account","achieve","acidity","acquire","acrobat","acronym","acrylic","actress","adaptor","address","already","adjourn","admiral","advance","advisor","aerator","aerosol","affable","afflict","affront","african","backlit","backlog","backrub","badland","baggage","bailout","balance","ballboy","balloon","baloney","bananas","bandage","bandaid"]; var five_letter_words = ["pople","carom","ergot","aglet","cubeb","nerpa","taler","qitra","decoy","swain","oxter","panic"];  var i, j, k; var crypto = require('crypto'); var possibility, hash;  for (i=0; i<four_letter_words.length; i++) { 	for (j=0; j<seven_letter_words.length; j++) { 		for (k=0; k<five_letter_words.length; k++) { 			possibility = "The world is " + four_letter_words[i] + " " + seven_letter_words[j] + " this email was a " + five_letter_words[k]; 			hash = crypto.createHash('md5').update(possibility).digest("hex"); 			if (hash == "0c049ca2ad590d34d1753419f64eff19") { 				console.log(possibility); 				break; 			} 		} 	} }  
#include<iostream> #include <cstdio> using namespace std;  void convertdtob(int n) {     int b=7;      if (n == 0)         return;         long long int x = n % b;      n /= b;      if (x < 0)         n += 1;      convertdtob(n);      cout<< x ; }  int main() {     long long int n;      while(1)     {          cin>>n;         if(n==-1)         {             break;         }          else     if (n != 0) convertdtob(n); cout<<"\n";     }     return 0; } 
#include<iostream> #include<cstdio> using namespace std;  int main() {    long long int n, a,b,next, c;     cin>>a>>b;    cin>>n;    for ( c = 0 ; c < n ; c++ )    {       if ( c <= 1 )          next = c;       else       {          next = a+b;          a=b;         b= next;       }     }     cout<<next<<endl;    return 0; } 
#include<bits/stdc++.h> #define LL long long int #define sc(x) scanf("%d",&x) #define sl(x) scanf("%lld",&x) #define pf(x) printf("%d\t",x) #define pl(x) printf("%lld\n",x) #define pb push_back #define F first #define S second #define maxn 1005 #define M 1000000007 using namespace std;  int main() { 	int t,j=0; 	sc(t); 	t=t*2; 	while(j<t/2) 	{ 	for(int i=1;i<=t;i++) 	{ 		if(i<=j || i>t-j) 		{ 			printf("-"); 		} 		else 		{ 			printf("*"); 		} 	} 	j++; 	printf("\n"); } j=0; if(t&1) { 	while(j<=t/2) 	{ 	for(int i=1;i<=t;i++) 	{ 		if(i==t/2-j+1 || i==t/2+j+1) 		{ 			printf("*"); 		} 		else 		{ 			printf("-"); 		} 	} 	j++; 	printf("\n"); } } else { 	while(j+1<t/2) 	{ 	for(int i=1;i<=t;i++) 	{ 		if(i==t/2-j || i==t/2+j+1) 		{ 			printf("*"); 		} 		else 		{ 			printf("-"); 		} 	} 	j++; 	printf("\n"); } for(int i=1;i<=t;i++) { 	printf("*"); } printf("\n"); } 	return 0; }
#include <cassert> #include <cctype> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <iostream> #include <sstream> #include <iomanip> #include <string> #include <vector> #include <deque> #include <list> #include <set> #include <map> #include <bitset> #include <stack> #include <queue> #include <algorithm> #include <functional> #include <iterator> #include <numeric> #include <utility> using namespace std;  template< class T > T _abs(T n) { return (n < 0 ? -n : n); } template< class T > T _max(T a, T b) { return (!(a < b) ? a : b); } template< class T > T _min(T a, T b) { return (a < b ? a : b); } template< class T > T sq(T x) { return x * x; } template< class T > T gcd(T a, T b) { return (b != 0 ? gcd<T>(b, a%b) : a); } template< class T > T lcm(T a, T b) { return (a / gcd<T>(a, b) * b); } template< class T > bool inside(T a, T b, T c) { return a<=b && b<=c; } template< class T > void setmax(T &a, T b) { if(a < b) a = b; } template< class T > void setmin(T &a, T b) { if(b < a) a = b; }  #define ALL(c) c.begin(), c.end() #define PB(x) push_back(x) #define UB(s, e, x) upper_bound(s, e, x) #define LB(s, e, x) lower_bound(s, e, x) #define REV(s, e) reverse(s, e); #define SZ(c) c.size() #define SET(p) memset(p, -1, sizeof(p)) #define CLR(p) memset(p, 0, sizeof(p)) #define MEM(p, v) memset(p, v, sizeof(p)) #define CPY(d, s) memcpy(d, s, sizeof(s)) #define ll long long #define ff first #define ss second #define DEBUG if(0)  #define si(x) scanf("%d",&x) #define pi(x) printf("%d\n",x) #define siz 100100 struct date {        int m,d,y;        double r;        };        bool comp1(date x, date y)        {             return x.r>y.r;             }        bool comp2(date x, date y)        {             if(x.y==y.y)             {                if(x.m==y.m)                      return x.d<y.d;             else             return x.m<y.m;             }             else             return x.y<y.y;             }              int main() {     int i=0,m,d,y;     char c,ch,str[1000];     date p[100010],q[100010];     double a;     while( 1)     {            scanf("%lf",&a);            if(a==-1.0l)            break;          // scanf("%d%c%d%c%d",&m,&c,&d,&ch,&y);          scanf("%s",str);          p[i].r=a;          p[i].m=(str[0]-'0')*10+(str[1]-'0');           p[i].d=(str[3]-'0')*10+(str[4]-'0');           p[i].y=(str[6]-'0')*10+(str[7]-'0');          q[i].r=a;          q[i].m=(str[0]-'0')*10+(str[1]-'0');           q[i].d=(str[3]-'0')*10+(str[4]-'0');           q[i].y=(str[6]-'0')*10+(str[7]-'0');                      i++;                                 }                      int n=i;          // for(i=0;i<n;i++)              //printf("%d %d %d %d %d\n",p[i].r,p[i].m,p[i].d,p[i].y);        sort(p,p+n,comp1);        cout<<"Money:\n";                  for(i=0;i<n;i++)           {cout<<"["<<p[i].r<<", ";  printf("%d%d/%d%d/%d%d]\n",p[i].m/10,p[i].m%10,p[i].d/10,p[i].d%10,p[i].y/10,p[i].y%10);           }         sort(q,q+n,comp2);        cout<<"Date:\n";          for(i=0;i<n;i++)            {cout<<"["<<q[i].r<<", ";  printf("%d%d/%d%d/%d%d]\n",q[i].m/10,q[i].m%10,q[i].d/10,q[i].d%10,q[i].y/10,q[i].y%10);            }          // cin>>i;                   return 0;           }           
#include <stdio.h>  #include<iostream>  using namespace std; int josephus(int n, int k) {   if (n == 1)     return 1;   else     /* The position returned by josephus(n - 1, k) is adjusted because the        recursive call josephus(n - 1, k) considers the original position         k%n + 1 as position 1 */     return (josephus(n - 1, k) + k-1) % n + 1; }   // Driver Program to test above function int main() {   int n,k;   cin>>n>>k;   printf("%d\n", josephus(n, k));   return 0; }
#include<iostream> #include<vector> #include<algorithm> #include<string.h> using namespace std; int main() { int n,m,i,s;   char x[200000]; while(1) { scanf("%d%d",&n,&m); if(n==0 && m==0) break; int b[20000]={0}; vector <string> a; for(i=0;i<n;i++) { scanf("%s",&x); a.push_back(x); } sort(a.begin(),a.end()); s=1; for(i=1;i<n;i++) { if(a[i]==a[i-1]) s++; else { b[s-1]++; s=1; } } b[s-1]++; for(i=0;i<n;i++) printf("%d\n",b[i]); } } 
#include <bits/stdc++.h> #define ll long long int #define MAX 201 #define EPS 1e-9 #define MOD 1000000007 #define INF 1e9 #define pn() printf("\n") #define vint vector <int> #define vpint vector <pair<int,int> > #define pb push_back #define mp make_pair #define ft first #define sd second #define gc() getchar_unlocked() #define ms(x,v) memset(x,v,sizeof x) #define pr_arr(i,x,size) for(i=0;i<size;i++) cout<<x[i]<<" " #define ff(i,a,b) for(i=a;i<=b;i++) #define fb(i,a,b) for(i=a;i>=b;i--) #define gprint(i) cout<<"Case #"<<i<<": " using namespace std;  template<class T> void scanint(T &x) {     register T c = gc();     x = 0;     T neg = 0;     for(;((c<48 || c>57) && c != '-');c = gc());     if(c=='-') {neg=1;c=gc();}     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}     if(neg) x=-x; }  template<class T> T modulus(T x,int m=MOD) {     return (((x%m)+m)%m); }  inline bool lt(double a, double b) {     return a + EPS < b; } inline bool gt(double a, double b) {     return a > b + EPS; } inline bool eq(double a, double b) {     return fabs(a - b) < EPS; }  ll power(ll base,ll p) {     if(p==0)         return 1;     ll temp=1;     while(p>1)     {         if(p%2!=0)             temp=(1LL*(base*temp)%MOD);         base=(1LL*(base*base)%MOD);         p/=2;     }     ll ans=(1LL*(base*temp)%MOD);     return ans; }  char arr[MAX][MAX]; int visited[MAX][MAX]; int t,n,m;  void bfs(int a,int b) { 		queue <pair<int,int> > q; 		q.push(mp(a,b)); 		int i,j; 		visited[a][b]=1; 		while(!q.empty()) 		{ 			pair<int,int> u=q.front(); 			q.pop(); 			ff(i,-1,1) 			{ 				ff(j,-1,1) 				{ 					if(i+u.ft>=0 && i+u.ft<n && j+u.sd>=0 && j+u.sd<m && visited[u.ft+i][u.sd+j]==0) 					{ 						visited[i+u.ft][u.sd+j]=1; 						if(arr[u.ft+i][u.sd+j]=='#') 						{ 							q.push(mp(u.ft+i,u.sd+j)); 						} 					} 				} 			} 		} }   int main() {     ios::sync_with_stdio(false);     int i,j;     scanf("%d",&t);     while(t--)     {     	//ms(arr,0);     	ms(visited,0);     	scanf("%d %d",&n,&m);     	int ans=0;     	ff(i,0,n-1)     	{     		// ff(j,0,m-1)     		// {     		// 	char temp;     			scanf("%s",&arr[i]);     		//	arr[i][j]=(temp=='#'?1:0);     		// }     	}     	ff(i,1,n-2)     	{     		ff(j,1,m-2)     		{     			if(visited[i][j]==0 && arr[i][j]=='#')     			{     				bfs(i,j);     				ans++;     			}     		}     	}     	printf("%d\n",ans);     }     return 0; }
#include<bits/stdc++.h> using namespace std; typedef long long ll; int main() {     ll t,a;     cin>>t;      ll ar[500001];       for(ll i=1;i<=500000;i++)         ar[i]=1;           for(ll i=2;i<=500000;i++)            for(ll j=1;(i*j)<=500000;j++)            ar[i*j]+=i;     while(t--){             cin>>a;             cout<<ar[a]-a<<endl;           }     } 
#include<stdio.h> int main(){         int a,b,a1,c=0;         int temp;         scanf("%d %d",&a,&b);         while(1){             if(a==0)             break;            int arr[10]={0};            if(a>b){            int t=a;            a=b;            b=t;            }             while(a<=b){                 a1=a;                   while(a1){                 temp=a1%10;                 arr[temp]=arr[temp]+1;                 a1=a1/10;                 }                 a=a+1;             }             c++;             printf("Case %d:",c);             for(int i=0;i<10;i++){             printf(" %d:%d",i,arr[i]);             }             printf("\n");               scanf("%d %d",&a,&b);         }         return 0; }
#include <iostream> #include <limits.h> #define min(a,b) (((a) < (b)) ? (a) : (b))  using namespace std; int table[10001];     int main(){ 	int d, n1, n2, k, l, m; 	cin>>d; 	while(d){ 		cin>>n1>>n2>>k; 		for(int i = 0; i <= n2 - n1; i++) 				table[i] = INT_MAX; 		table[0] = 0; 		for(int i = 0 ; i < k; i++){ 				cin>>l >>m; 				for(int	 i = m; i <= n2-n1; i++){ 						if(table[i - m]!= INT_MAX){ 							table[i] = min(table[i], table[i - m] + l); 						} 				} 		}  		switch(table[n2-n1]){ 		case (INT_MAX): 			cout<<"This is impossible."<<endl; 			break; 		default: 			cout<<"The minimum amount of money in the piggy-bank is "<<table[n2-n1]<<"."<<endl; 		}  		d--; 	}  	return 0; } 
#include<stdio.h> //#include<conio.h> #include<math.h>   int main() {          long long  int t=-1,a[200],c[200],g=0;           long long int n=0,k=0,p=0;             long long int i=0,j=0;            long long int x=0;                                 while(1)           {                        scanf("%lld",&n);                          if(n!=-1){                      for(i=n;i>=0;i--)                  scanf("%lld",&c[i]);                  scanf("%lld",&k);                  for(i=0;i<k;i++)                  scanf("%lld",&a[i]);                  p++;                  printf("Case %lld:\n",p);                                    for(j=0;j<k;j++)                  {                            g=1;                              for(i=0;i<=n;i++)                     {                                                           x+=(c[i]*g);                       g*=a[j];                     }                     printf("%lld\n",x);                     x=0;                   }                  }                  else                  break;                 // scanf("%lld",&n);                       }                     // getch();           return 0; }
#include<iostream> #include<list> using namespace std; class Graph{ int V; list<int> *adj;  bool iscyclicutil(int v,bool visited[],int parent); public:     Graph(int V); void addEdge(int v,int w); bool istree(); }; Graph::Graph(int V) {     this->V=V;     adj=new list<int>[V]; } void Graph::addEdge(int v,int w) {     adj[v].push_back(w);     adj[w].push_back(v); } bool Graph::iscyclicutil(int v,bool visited[],int parent) {     visited[v]=true;     list <int>:: iterator i;     for(i=adj[v].begin();i!=adj[v].end();++i)     {         if(!visited[*i])         {             if(iscyclicutil(*i,visited,v))             return true;          }         else if(*i!=parent)             return true;     }     return false; } bool Graph::istree() {     bool *visited=new bool[V];     for(int i=0;i<V;i++)         visited[i]=false;     if(iscyclicutil(0,visited,-1))         return false;     for(int i=0;i<V;i++)     {         if(visited[i]==false)             return false;     }  return true;  } int main() {     int v,e;     cin>>v>>e;     Graph g(v);     for(int i=0;i<e;i++)     {         int v,w;         cin>>v>>w;         g.addEdge(v-1,w-1);     }     if(g.istree())         cout<<"YES"<<endl;     else         cout<<"NO"<<endl;     return 0; } 
/* Author: Karlheinz Jung */ /* Compiler: C++ @ ideone.com */ /* Computer: Rabbit 286 */  #include <iostream> #include <deque> #include <vector> #include <algorithm>  using namespace std;  const int BI_MAX=10000;  struct BigInteger { deque<short> val; int flags; BigInteger(int n=0) 	{ 	flags=0; 	if(n) flags=n/abs(n); 	while(n) 		{ 		val.push_back(n%BI_MAX); 		n/=BI_MAX; 		}         } void clear_leading_zero() 	{ 	while(val.back()==0) val.pop_back(); 	} string to_string() 	{ 	if(val.size()==0) return "0"; 	char res[val.size()*4+5]; 	char *r; 	r=res+val.size()*4+4; 	*(r--)='\0'; 	for(int i=0; i<(int)val.size(); i++) 		{ 		int t=val[i]; 		for(int j=0; j<4; j++) 			{ 			if(t==0&&i==(int)val.size()-1) break; 			(*r--)=t%10+'0'; 			t/=10;                         }                 } 	return string(r+1);         } };  BigInteger add(const BigInteger &a, const BigInteger &b) { BigInteger res(0); short va, vb, k=0; for(int i=0; i<max<int>(a.val.size(),b.val.size()); i++) 	{ 	if(i<(int)a.val.size()) 		va=a.val[i]; 	else 		va=0; 	if(i<(int)b.val.size()) 		vb=b.val[i]; 	else 		vb=0; 	va+=k; 	k=(va+vb)>=BI_MAX; 	res.val.push_back(va+vb-(k?BI_MAX:0));         } if(k)res.val.push_back(k); return res; }  BigInteger mul(const BigInteger &a, const BigInteger &b) { int k=0, i, j; BigInteger res(0); for(int i=0; i<(int)a.val.size()+(int)b.val.size()+1; i++) 	{ 	res.val.push_back(0);         } for(i=0; i<(int)a.val.size(); i++) 	{ 	k=0; 	for(j=0; j<(int)b.val.size(); j++) 		{ 		k=a.val[i]*b.val[j]+k; 		res.val[i+j]+=k%BI_MAX; 		k/=BI_MAX; 		if(res.val[i+j]>=BI_MAX) 			{ 			res.val[i+j]-=BI_MAX;k++;                         } 		} 	while(k) 		{ 		res.val[i+j]+=k; 		if(res.val[i+j]>=BI_MAX) 			{ 			res.val[i+j]-=BI_MAX; 			k=1; 			} 		else 			k=0;                         j++; 		} 	} res.clear_leading_zero(); return res; }  BigInteger operator+(const BigInteger &a,const BigInteger &b) { return add(a,b); }  BigInteger operator*(const BigInteger &a,const BigInteger &b) { return mul(a,b); }  vector<string> fibs;  bool compare(const string &a, const string &b) { if(a.size()!=b.size())return a.size()<b.size(); 	return a<b; }  int main() { BigInteger n, a=2, b=1; fibs.push_back(b.to_string()); fibs.push_back(a.to_string()); while(1) 	{ 	n=a+b; 	b=a; 	a=n; 	fibs.push_back(n.to_string()); 	if(fibs.back().size()>101) break; 	} string aa, bb; for(;cin>>aa>>bb;) 	{ 	if(aa=="0"&&bb=="0") break; 	cout<<upper_bound(fibs.begin(),fibs.end(),bb,compare)-lower_bound(fibs.begin(),fibs.end(),aa,compare)<<endl; 	} return 0; } 
/* Success is a matter of hanging on, when others have let go. Its not who you are, that holds you back, its who you think you are not. The future belongs to those, who believe in the beauty of their dreams. */ //{ /* theCodeGame */ #include<iostream> #include<cmath> #include<algorithm> #include<climits> #include<vector> #include<queue> #include<stack> #include<bitset> #include<cstdlib> #include<cstdio> #include<cstring> #include<ctime> #include<map> using namespace std; #define MOD 1000000007LL #define LL long long #define ULL unsigned long long #define LD long double #define MAX(a,b) ((a)>(b)?(a):(b)) #define MIN(a,b) ((a)<(b)?(a):(b)) #define ABS(x)   ((x)<0?-(x):(x)) #define SQR(x) ((x)*(x)) #define CUBE(x) ((x)*(x)*(x)) #define si(n) scanf("%d",&n) #define si2(n,m) scanf("%d %d",&n,&m) #define sf(n) scanf("%f",&n) #define sl(n) scanf("%ld",&n) #define sll(n) scanf("%lld",&n) #define slu(n) scanf("%llu",&n) #define sd(n) scanf("%lf",&n) #define ss(n) scanf("%s",n) #define pnl printf("\n") #define FORD(i,a,b,d) for(typeof(b) i=(a);i<(b);i+=(d)) #define FOR(i,a,b) for(typeof(b) i=(a);i<(b);i++) #define REP(i,n) for(typeof(n) i=0;i<(n);i++) #define FORR(i,n,e) for(typeof(n) i=(n);i>=(e);i--) #define FORRD(i,n,e,d) for(typeof(n) i=(n);i>=(e);i-=(d)) #define FILL(a,b) memset(a,b,sizeof(a)) //#undef mydebug #ifdef mydebug #define DB(x) cout<<#x<<"="<<(x)<<"\n" #define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n" #define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n" #define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n" #define DBG_ARR(a,b,c) DBG(a,b,c) #define pnld pnl; #else #define DB(x) #define DB2(x,y) #define DB3(x,y,z) #define DB4(x,y,z,a) #define DBG_ARR(a,b,c) #define pnld #endif const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; template <typename T>void swap(T &x,T &y){T t=x;x=y;y=t;} template <typename T>void DBG(const T A,int S,int N){cout<<"[";FOR(i,S,N){cout<<"#"<<i<<":"<<A[i]<<" ";}cout<<"]\n";} ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} //} #define size 300 char a[size], b[size][size]; void precompute(){} void doThis(){     	int column, x, row, k, z; 	si(column); 	getchar();     while(column!=0){ 	ss(a); 	DB2(column,a); 	int x =strlen(a); 	row=x/column; 	FOR(i,0,row){         k=(i+1)*column;         z=k;             if(i%2==0){                 FOR(j,0,column){                     b[i][j]=a[z-column];                     z++;                 }             }              if(i%2!=0){                 FOR(j,0,column){                     b[i][j]=a[z-1];                     z--;                 }             } 	} 	FOR(i,0,column){ 	    FOR(j,0,row){ 	        cout<<b[j][i]; 	    } 	} 	pnl; 	si(column); 	getchar();     } }  int main(){ #ifdef amy freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr); #endif precompute(); int t=1; //scanf("%d",&t); while(t--){doThis();} #ifdef amy fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC)); #endif return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { int t,n;   scanf("%d",&t);   while(t--)   { scanf("%d",&n);        vector<int> v(n,-1);     int val,len=n+1,i,l,r,ans=0;     v[0]=0; 	for(i=1;i<=n;i++)     { scanf("%d",&val);       ans+=val; 	  ans%=n; 	  //cout<<ans<<" "; 	  if(v[ans]!=-1 && i-v[ans]<len) 	  { l=v[ans]+1; 	    r=i; 	    len=i-v[ans]; 	    //cout<<l<<" "<<r<<" "; 	  } 	           v[ans]=i;	 	} 	   	  printf("%d %d\n",l-1,r-1);   } 	return 0; }
#include<iostream> #include<vector> #include<set> #include<map> #include<queue> #include<stack> #include<string> #include<algorithm> #include<functional> #include<iomanip> #include<cstdio> #include<cmath> #include<limits.h> #include<cstring> #include<cstdlib> #include<cfloat> #include<cassert> #define maxm(a,b) a>b?a:b; #define minm(a,b) a<b?a:b; using namespace std; //M lazy ;) typedef long long ll; typedef vector <int> vi; typedef pair< int ,int > pii; typedef istringstream iss; typedef ostringstream oss; typedef map<int,int> mp; #define pb push_back #define mp make_pair #define ff first #define ss second #define sz size() #define ln length() #define rep(i,n) for(int i=0;i<n;i++) #define fu(i,a,n) for(int i=a;i<=n;i++) #define fd(i,n,a) for(int i=n;i>=a;i--) #define all(a)  a.begin(),a.end() #define ESP (1e-9) #define gi(n) scanf("%d",&n) #define gl(n) cin >> n #define pi(n) printf("%d",n) #define pl(n) cout << n #define ps printf(" ") #define pn printf("\n") #define dg(n,s); printf("%s %d",s,n) #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min() #define traverse_map(a,b) for(mp::iterator it=a;it!=b;++it) #define MOD 1000000007 #define MAX 1000001 #define cases() int t; cin>>t; while(t--) // fast input function #define getcx getchar_unlocked // fast input function #ifdef ONLINE_JUDGE  inline void inp( int &n )  {     n=0;     int ch=getcx();int sign=1;     while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )             n = (n<<3)+(n<<1) + ch-'0', ch=getcx();     n=n*sign;   } #else inline void inp(int &n){  cin>>n; } #endif  #include <stdio.h> #include <math.h>  int CheckTriple(int temp){    int n=temp;    while(n%2==0)    { 		n/=2;    }    if(n==1)    return 0;        for(int i=3;i<=sqrt(temp);i+=2)   { 			 if(n%i==0){  					if(i%4==1) 					 return 1; 					 else{ 							while(n%i==0) 							 n/=i; 					 } 			 }   }      if(n>1){    if(n%4==1)     return 1;   }  return 0;  }  int main(){ 		int t; 		inp(t); 		while(t--){ 		  int n; 		   inp(n); 		   if(CheckTriple(n)) 			cout<<"PERFECT"<<endl; 		    else 			 cout<<"IMPERFECT"<<endl; 		}  } 
#include<bits/stdc++.h> //#define inf 100000000 #define ll  long long #define pb push_back #define s(n) scanf("%d",&n) #define sl(n) scanf("%lld",&n)  #define p(n) printf("%lld\n",n) #define rep(i,a,n) for(i=a;i<=n;i++) #define vi vector<int> #define vii vector< vector<int> > #define vpii vector< pair<int,int> > #define mii map<int,int> #define pb push_back #define inf 1000000000LL #define mp make_pair #define MOD 1000000007LL #define N 1000007 using namespace std; ll powmod(long long a, long long b, long long c) {     ll ret=1LL;      while(b)     {         if(b & 1)             ret = (ret*a)%c;         a=(a*a)%c;          b>>=1;     }     return (ret)%c; } ll minverse(ll a,ll mod1) {     if(a==0LL)         return 1LL;     return powmod(a,(1LL*(mod1-2LL)),mod1)*1LL; } int dp1[21][21]; int bit[21]; ll dp[1200000];  int main() { int t,n,i,j,k,n1,n2,m; s(t); while(t--) { memset(dp1,0,sizeof(dp1)); memset(bit,0,sizeof(bit));  s(n);s(m);  for(i=1;i<=m;++i)  {   s(n1);s(n2);   dp1[n1][n2]=1;  } for(i=1;i<=n;++i) 		{ 			for(j=1;j<=n;++j) 			{ 				bit[i]=bit[i]+((dp1[i][j]?1:0)<<(j-1)); 			} 		}  dp[0]=1;  for(i=1;i<(1<<n);++i)  {    dp[i]=0;    for(j=0;j<n;++j)    {      if(i&(1<<j))      {       if((i&(bit[j+1]))==0)       dp[i]=(dp[i]+dp[i-(1<<j)])%MOD;      }    }  }    //cout<<sum<<" "<<dp[sum]<<endl;  p(dp[(1<<n)-1]); } } 
#include<bits/stdc++.h> using namespace std; #define temp 0 #define perm 1 #define INF (int(1e9)) #define INFL ((long long int)(1e18)) #define in2(n,m) scanf("%d %d",&n,&m); #define in3(x,y,z) scanf("%d %d %d",&x,&y,&z); #define in4(p,q,r,s) scanf("%d %d %d %d",&p,&q,&r,&s); #define unsetBit(BITT,X) (BITT&(~(1<<X))); #define setBit(BITT,X) (BITT|(1<<X)); #define bitIsSet(BITT,X) (BITT&(1<<X)) #define bitIsNotSet(BITT,X) (!(BITT&(1<<X))) #define getcx getchar inline void in(int &n) {     n=0; int ch = getcx(); int sign = 1;     while(ch < '0' || ch > '9') { if(ch == '-') sign=-1; ch = getcx(); }     while(ch >= '0' && ch <= '9') { n = (n << 3) + (n << 1) + ch - '0', ch = getcx(); }     n = n * sign; } #define mod 1000000007 #define pii pair< int , int > #define V 100000 int res[V+5],prime[V+5]; void pre() {     for(int i=2; i<=V; i++)     {         if(prime[i]==0)//a prime         {             res[i] = 1;             for(int j=i+i; j<=V; j+=i)             {                 res[j] = res[j/i] + 1;                 prime[j] = 1;             }         }     }     int mx = 0;     for(int i=1; i<=V; i++)     {         //printf("%d %d\n",i,res[i]);         mx = max( mx , res[i] );     }     //printf("%d\n",mx); } vector<int> v[20]; long long int dp[20][100005]; long long int A[20], B[20] , C[20]; long long int func(int pos,int idx) {     if(dp[pos][idx]!=-1)     {         //printf("bb\n");         return dp[pos][idx];     }     /*int sdx = idx;     long long int ans = 0;     for(int i=0; i<v[pos].size(); i++)     {         idx++;         long long int p = v[pos][i];         p *= idx;         p *= idx;          ans += p;     }*/     long long int Idx = idx+1;     long long int ans = Idx*Idx*A[pos] + Idx*B[pos] + C[pos];     dp[pos][idx] = ans;     return ans; } int lim; int n; long long int memo[1<<17]; long long int solve(int bitMask) {     if(memo[bitMask]!=-1)     {         //printf("aa\n");         return memo[bitMask];     }     int cnt = 0;     for(int i=0; i<=lim; i++)     {         if(bitMask&(1<<i))         {             cnt += (int)v[i].size();         }     }     //printf("lim is %d and n is %d and cnt is %d\n",lim,n,cnt);     if(cnt==n)     {         return 0;     }     long long int ans = 0;     for(int i=0; i<=lim; i++)     {         if(bitMask&(1<<i))         {             continue;         }         //bit is not set , lets use it         long long int curr = func(i,cnt);         int newMask = bitMask|(1<<i);         ans = max( ans , curr+solve(newMask) );     }     memo[bitMask] = ans;     return ans; } int main() {     pre();     in(n);     int mx = 0;     for(int i=1; i<=n; i++)     {         int x,y;         in(x);         in(y);         int pos = res[x];         v[pos].push_back(y);          mx = max( mx , pos );     }     for(int i=0; i<=mx; i++)     {         sort(v[i].begin(),v[i].end());         //printf("i is %d and size is %d\n",i,v[i].size());     }     for(int i=0; i<=mx; i++)     {         A[i] = 0;         for(int j=0; j<v[i].size(); j++)         {             A[i] += v[i][j];         }          B[i] = 0;         C[i] = 0;         for(int j=1; j<v[i].size(); j++)         {             long long int p = 2;             p *= j;             p *= v[i][j];             B[i] += p;//2*j*v[i][j];              long long int q = j;             q *= j;             q *= v[i][j];              C[i] += q;//j*j*v[i][j]          }     }     /*for(int i=0; i<=mx; i++)     {         printf("i is %d %lld %lld %lld\n",i,A[i],B[i],C[i]);     }*/     lim = mx;     memset(memo,-1,sizeof(memo));     memset(dp,-1,sizeof(dp));     long long int ans = solve(0);     printf("%lld\n",ans); } 
#include<iostream> using namespace std; int main() {  int t,n,a;  cin>>t;  while(t--)  {   cin>>n;   while(n--)    cin>>a;   cout<<1<<endl;  }  return 0; }
#include<cstdio> #include<iostream> #include<algorithm> #include<cstring> using namespace std; int main() { int k,t; int ans[10][5]; for(int i = 0; i <= 9; i++){ ans[i][0] = i; for(int j = 1; j <= 3; j++){ ans[i][j] = ans[i][j-1] * i; ans[i][j] %= 10; } }    long long int p;    char s[25];    scanf("%d",&t);    while(t--)    {      scanf("%s %lld",&s,&p);      k=s[strlen(s)-1]-'0';      if(p==0){printf("1\n");continue;}      p--;      printf("%d\n",ans[k][p%4]);    }    return 0; }
#include <iostream> #include <stdio.h>  #define ll long long int  using namespace std;  int main() {          int t;     scanf("%d", &t);          while(t--) {       int n;       scanf("%d", &n);              int lens[n];       for(int i =0; i<n; i++) {           scanf("%d", &lens[i]);          }              ll ans =0;              for(int i =1; i<n; i++) {          if(lens[i] > lens[i-1]) {                 ans ++;             }            }                     cout << ans << endl;     }                 return 0;    } 
 // (c) agaurav77 #include <iostream> #include <map>          // find(), clear() #include <vector>       // push_back(), pop_back(), front(), back() #include <list>         // push_back(), pop_back(), front(), back() --- SEQUENTIAL ACCESS #include <queue>        // push(), pop(), front(), back() #include <utility>      // make_pair() #include <algorithm>    // sort() #include <cmath> #include <cstdio> #include <climits>      // inf, minf #include <cstdlib>      // malloc() #include <sstream> #include <string> #include <cstring>      // memset() #define mp make_pair #define pb push_back using namespace std;  #define inf INT_MAX #define minf INT_MIN #define t(N) scanf("%d", &N); #define f(i,a,b) for(int i=a;i <= b; ++i) #define str string #define ll long long  #define inMap(a,b) (a.find(b) != a.end())  int main() {   int T;   cin >> T;      while (T--) {     int N;     cin >> N;      int arr[N];     f(i, 0, N-1) cin >> arr[i];      int maxcnt = 0, currcnt = 0;     f(i, 0, N-2) {       if (arr[i] == arr[i+1]) currcnt++;       else {         maxcnt = maxcnt > currcnt ? maxcnt : currcnt;         currcnt = 0;       }     }     maxcnt = maxcnt > currcnt ? maxcnt : currcnt;     cout << maxcnt << endl;   }    return 0; }    
#include <bits/stdc++.h> using namespace std; long long fact[1000005]; int T,N; int main() { 	for(int i=1; i<=1000000; i++)fact[i]=1; 	for(int i=2; i<=1000000; i++) 	{ 		fact[i]++; 		for(int j=i+i; j<=1000000; j+=i)fact[j]++; 	} 	 	for(int i=2; i<=1000000; i++)fact[i]=fact[i-1]+fact[i]; 	cin>>T; 	while(T--) 	{ 		scanf("%d",&N); 		cout<<(fact[N]*2)<<"\n"; 	} 	return 0; }
// laflare #include<iostream> #include<vector> #include<set> #include<map> #include<queue> #include<stack> #include<string> #include<algorithm> #include<functional> #include<iomanip> #include<cstdio> #include<cmath> #include<limits.h> #include<cstring> #include<cstdlib> #include<cfloat> #include<cassert> #define maxm(a,b) a>b?a:b; #define minm(a,b) a<b?a:b; using namespace std; //M lazy ;) typedef long long ll; typedef vector <int> vi; typedef pair< int ,int > pii; typedef istringstream iss; typedef ostringstream oss; typedef map<int,int> mp; #define pb push_back #define mp make_pair #define ff first #define ss second #define sz size() #define ln length() #define rep(i,n) for(int i=0;i<n;i++) #define fu(i,a,n) for(int i=a;i<=n;i++) #define fd(i,n,a) for(int i=n;i>=a;i--) #define all(a)  a.begin(),a.end() #define ESP (1e-9) #define gi(n) scanf("%d",&n) #define gl(n) cin >> n #define pi(n) printf("%d",n) #define pl(n) cout << n #define ps printf(" ") #define pn printf("\n") #define dg(n,s); printf("%s %d",s,n) #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min() #define traverse_map(a,b) for(mp::iterator it=a;it!=b;++it) #define MOD 1000000007 #define MAX 1000001 #define cases() int t; cin>>t; while(t--) // fast input function #define getcx getchar_unlocked // fast input function #ifdef ONLINE_JUDGE  inline void inp( int &n )  {     n=0;     int ch=getcx();int sign=1;     while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )             n = (n<<3)+(n<<1) + ch-'0', ch=getcx();     n=n*sign;   } #else inline void inp(int &n){  cin>>n; } #endif /* inline long long inp(){ 	char c = getchar_unlocked(); 	long long n = 0; 	while(c < '0' || c > '9') c = getchar_unlocked(); 	while(c >= '0' && c <= '9') 		n = (n<<3) + (n<<1) + c - '0', c = getchar_unlocked(); 	return n; }  #define pc putchar_unlocked inline void oup(int n){ 	if(!n) pc('0'); 	char pb[2]; 	int pi = 0; 	while(n) pb[pi++] = (n%10) + '0', n /= 10; 	while(pi) pc(pb[--pi]); }*/ bool compare(const long long &a,const long long &b){ 	return a<b; } int main(){  int t;  inp(t);  while(t--){    int *M,*C;    int n,k;    inp(n);    inp(k);    M=(int*)calloc((n+1),sizeof(int));    C=(int*)calloc((n+1),sizeof(int));        for(int i=1;i<=n;i++) 	inp(M[i]); 	    for(int i=1;i<=k;i++)    {    int a,b; 		inp(a); 		inp(b); 		for(int j=a;j<=b;j++) 		 C[j]++;    }        sort(M,M+n+1,compare);    sort(C,C+n+1,compare);     ll sum=0;    for(int i=0;i<=n;i++) 	 sum+=C[i]*M[i]; 	    printf("%lld\n",sum);    free(M);    free(C);  }  return 0; } 
#include <stdio.h> #include <string.h> #include <vector> #include <iostream> using namespace std;   char str[1000]; int l; const int letters = 'z' - 'a' + 1;   bool is_palidrome(){     for (int i = 0; i < l/2; ++i) {         if (str[i] != str[l-i-1]) return false;     }     return true; }   bool is_pangram(vector<bool>& alphabet) {     for (int i = 0; i < l; ++i) {         alphabet[str[i]-'a'] = true;     }     for (int i = 0; i < letters; ++i){         if(!alphabet[i]) return false;     }     return true; }     int main() {     int t;     scanf ("%d", &t);     while (t--) {         scanf ("%s", str);         l = strlen(str);         vector<bool> alphabet(letters, false);           bool palindrome = is_palidrome();         bool pangram = is_pangram(alphabet);           if (palindrome and pangram) printf("palingram\n");         else if (palindrome) printf("palindrome\n");         else if (pangram) printf("pangram\n");         else printf("none\n");       } }
#include<cstdio> #include<cstring> using namespace std; int isPalin(char s[]) { 	int i,K=strlen(s); 	for(i=0;i<=K/2;++i) 		if(s[i]!=s[K-i-1]) 			return 0; 	return 1; } int main() { 	int T; 	scanf("%d",&T); 	while(T--) 	{ 		int K,i,j,l,count=0; 		char s[21]; 		scanf("%d%s",&K,s); 		for(i=0;i<=(strlen(s)-K);++i) 		{ 			char tmp[21]; 			l=0; 			for(j=i;j<(K+i);++j) 				tmp[l++]=s[j]; 			tmp[l]='\0'; 			count+=isPalin(tmp); 		} 		printf("%d\n",count); 	} 	return 0; }
#include <bits/stdc++.h> using namespace std; #define pb push_back #define mp make_pair #define ff first #define ss second #define sd(x) scanf("%d",&x) vector<int>arr; int main(){ 	int n; 	sd(n); 	for(int i=0;i<n;i++){ 		int temp; 		sd(temp); 		arr.push_back(temp); 	} 	vector<int>table; 	table.pb(arr[0]); 	//int len=1; 	for(int i=1;i<n;i++){ 		if(arr[i]<table[0]) 			table[0]=arr[i]; 		else if(arr[i]>=table[table.size()-1]) 			table.pb(arr[i]); 		else 			table[upper_bound(table.begin(),table.end(),arr[i])-table.begin()]=arr[i]; 	} 	cout<<table.size(); 	return 0; }
#include<bits/stdc++.h> using namespace std; #define f(i,a,b) for(int i=(int)(a);i<(int)(b);i++) #define rf(i,a,b) for(int i=(int)(a);i>=(int)(b);i--) #define s(n)                        scanf("%d",&n) #define p(n)			    printf("%d\n",n) #define sl(n)                       scanf("%lld",&n) #define pl(n)			    printf("%lld\n",n) #define ll long long int int main() {     int t;     s(t);     while(t--)     {         ll n,sum=0;         sl(n);         ll a[n+2];         f(i,0,n)         {             sl(a[i]);             sum+=a[i];         }             if(sum%n==0)                 pl(n);              else pl(n-1);     }     return 0; } 
 #include<iostream> #include<stdio.h> using namespace std; int main() {     int t;     int i,j,x,y;     scanf("%d",&t);     while(t--)     {         int count=0;         scanf("%d %d",&x,&y);         if(y%x==0)            printf("%d\n",y/x);            else             {                 while(y>0)                 {                     y=y-x;                     count+=1;                 }             printf("%d\n",count);             }      }     return 0; } 
#include<stdio.h> int main() {     int t,n,p;     char a[7];     scanf("%d",&t);     while(t--)     {         scanf("%d%s%d",&n,a,&p);         if(a[0]=='e')         {             printf("%d\n",2*p-1);         }         else         {             printf("%d\n",2*p);         }     }     return 0; } 
#include<iostream> #include<bits/stdc++.h> #include<cstdlib> #include<algorithm> using namespace std; int main(void) { 	  	unsigned long long k,t,n,i,m,a[100000]; 	m=1; 	for(i=1;i<=100000;i++) 	{ 	    m=(m*i)%1589540031; 	    a[i-1]=m; 	} 	scanf("%llu",&t); 	while(t--) 	{ 		cin>>n; 		 	    cout<<a[n-1]<<endl; 	} 	return 0; } 
#define gc getchar_unlocked #define pc putchar_unlocked #include<bits/stdc++.h> using namespace std; typedef long long int lli; inline int readInt(); inline lli readLong(); inline void printInt(int a); inline void printLong(lli a); int main(){     int t=readInt();     while (t--) {         lli n = readLong();         pair<lli,lli> p[n];         for(lli i=0;i<n;i++) {             lli a = readLong(),x=readLong();             p[i].second=a,p[i].first=x;         }         sort(p,p+n);         if(n==1 && p[0].first==0) {cout<<0<<endl;continue;}         for (lli i = n-1; i>=0; i--) {             if(i!=n-1&&p[i].first!=0) cout<<" + ";             if (p[i].first > 1) {                 cout<<p[i].second*p[i].first<<"x^"<<p[i].first-1;             }             else if (p[i].first == 1) {                 cout<<p[i].second;             }             else {break;}         }         cout<<endl;     }     return 0; } inline int readInt(){     int n=0; int ch=gc(); int sign=1;     while( ch < '0' || ch > '9' ){         if(ch=='-')sign=-1; ch=gc();     }     while(  ch >= '0' && ch <= '9' )         n = (n<<3)+(n<<1) + ch-'0', ch=gc();     return n*sign; } inline void printInt(int a) {     char snum[20]; int i=0;     if(a<0) {pc('-'); a=-a;}     do {         snum[i++]=a%10+48; a=a/10;     }     while(a!=0);     i=i-1;     while(i>=0)         pc(snum[i--]);     pc('\n');     //pc(' '); } inline lli readLong(){     lli n=0; lli ch=gc();int sign=1;     while( ch < '0' || ch > '9' ){         if(ch=='-')sign=-1; ch=gc();     }     while(  ch >= '0' && ch <= '9' )         n = (n<<3)+(n<<1) + ch-'0', ch=gc();     return n*sign; } inline void printLong(lli a) {     char snum[50]; lli i=0;     if(a<0) {pc('-'); a=-a;}     do {         snum[i++]=a%10+48; a=a/10;     }     while(a!=0);     i=i-1;     while(i>=0)         pc(snum[i--]);     pc('\n');     //pc(' '); } 
#include<bits/stdc++.h> using namespace std; #define ll long long ll dp[4502][4502]; ll sol[4502][4502]; char str[4504]; int main() {     int n,m;     scanf("%d%d",&n,&m);     int i,j;     char ch;     int a=n;     int b=m;     for(i=1;i<=a;i++)     {         scanf("%s",str);         for(j=1;j<=b;j++)         {            if(str[j-1]=='C')                 dp[i][j]=1+dp[i][j-1];             else                 dp[i][j]=0;          }     }     ll ans=-1;     for(j=1;j<=m;j++)     {            ll maxir=-1;          for(i=1;i<=n;i++)         {             ll int l=0;             ll int r=dp[i][j]+1;             maxir=max(maxir,r);             sol[l][j]++;             sol[r][j]--;         }         ll maxi=-1;         for(i=1;i<=maxir;i++)         {             sol[i][j]=sol[i-1][j]+sol[i][j];             maxi=max(maxi,i*sol[i][j]);         }     //cout<<maxi<<endl;         ans=max(maxi,ans);     }    printf("%lld\n",ans);   } 
#include <iostream> using namespace std; char a[500][500]; int n; bool lighted[500]; bool ispossible(int i,int j){          for(int k = i+1;k < n;k++) if(a[k][j] == '#') return false;     if(lighted[j]) return false;     return true; }  int main(){     int t;     cin >> t;     while(t--){     cin >> n;     int count = 0;     int latest;     for(int i = 0;i < n;i++) lighted[i] = false;     for(int i = 0;i < n;i++){         for(int j = 0;j < n;j++) cin >> a[i][j];     }     for(int i = 0;i < n;i++){         latest = -1;         for(int j = 0;j < n;j++){             if(a[i][j] == '#') break;             if(ispossible(i,j)) latest = j;         }         if(latest != -1) lighted[latest] = true;              }     cout << endl;     for(int i =0;i < n;i++) if(lighted[i]) count++;     /*for(int i = 0;i < n;i++) {                  if(lighted[i]) cout << 1 << " ";         else cout << 0 << " ";     }*/     //cout << endl;     cout << count << endl;     }      }
#include <bits/stdc++.h> using namespace std;   long long K, M;   long long alpha[26], ans[26]; char S[10004];   int func(long long N) {     int len = 0;          for(int i=0; i<26; i++)     {         ans[i] = alpha[i]*K/N;                  if((alpha[i]*K)%N)             ans[i]++;                  len+= ans[i];     }          if(len>M)         return 0;          return 1; }   long long solve(long long left, long long right) {     long long mid = (left+right)/2;          if(!func(mid))         return solve(mid+1, right);          if(left==mid)         return mid;          return solve(left, mid); }   int main() {          scanf(" %s %lld %lld", S, &K, &M);          for(int i=0; S[i]!='\0'; i++)         alpha[S[i]-'a']++;          int x = 0;          for(int i=0; i<26; i++)         x+= (alpha[i]>0);          if(x>M)         printf("-1\n");     else     {         printf("%lld\n", solve(1, 1000000000000000001LL));                  int x = 0;                  for(int i=0; i<26; i++)             x+= ans[i];                  for(int i=0; i<M-x; i++)             printf("a");                  for(int i=0; i<26; i++)             while(ans[i])             {                 printf("%c", 'a'+i);                 ans[i]--;             }                  printf("\n");     }      	return 0; }
#include <string> #include <vector> #include <map> #include <iostream> using namespace std; map<char, int> mp;  int main() {     int t;     cin>>t;     while(t--)     {         int x;         cin>>x;                  if(x%2!=0||x==0)             cout<<"No"<<endl;         else             cout<<"Yes"<<endl;     } }          
#include<iostream> #include<math.h> #include<stdio.h> using namespace std; #define MAX 1000001 long long int cnt[1000001],p[1000001];   long long int pf(long long int n) { 	for(int i=2;i<MAX;i++) 	{ 		if(!p[i]){ 			cnt[i]++; 			 			for(int j=i+i;j<MAX;j+=i) 			{ 				p[j]=1; 				long long int tmp=j; 				while(tmp%i==0){ 				 				cnt[j]+=1; 				tmp/=i; 				} 			} 		} 		 	} 	 	for(int i=1;i<MAX;i++) 	{ 		//cout<<i<<" "<<cnt[i]<<endl; 		cnt[i]+=cnt[i-1]; 	} } int main() { 	std::ios::sync_with_stdio(false); 	long long int t,p,q,i,j,ans; 	scanf("%lld",&t); 	pf(MAX); 	while(t--)	 	{ 		scanf("%lld%lld",&p,&q); 		ans=0; 		ans=cnt[q]-cnt[p-1]; 		printf("%lld\n",ans); 	} }
#include<bits/stdc++.h> using namespace std; #define ll long long ll power(ll a,ll b,ll mod) {     if(b==0)         return 1;     if(b==1)         return a;     ll temp=power(a,b/2,mod);     temp=(temp*temp)%mod;     if(b%2)         temp=(temp*a)%mod;     return temp; } int main() {     ll t,n,m,k,ans;     scanf("%lld",&t);     while(t--)     {         scanf("%lld%lld%lld",&n,&m,&k);         ans=power(n,m,k);         printf("%lld\n",ans);     }     return 0; } 
