#include<bits/stdc++.h> #define gc getchar_unlocked #define pc putchar_unlocked #define pb push_back #define mk make_pair #define MOD 1000000009 #define ll long long int #define mc(B) memset(B,'\0',sizeof B) #define mi(B) memset(B,0,sizeof B) #define MAX 800001 #define rep(i,a,b) for(int i=(int)a;i<(int)b;i++) #define rrep(i,a) for(int i=(int)a;i>=(int)0;i--) #define ab(a) (a<0)?(-1*a):a #define my_size(x) ((char*)(&x+1)-(char*)&x)  using namespace std; inline void rdint(int &n) { n=0; char c=gc(); while(c < '0' or c > '9') c=gc(); while(c>='0' and c<='9') { n=(n<<3)+(n<<1)+c-'0'; c=gc(); }} inline void rdlong(ll &n) { n=0; char c=gc(); while(c < '0' or c > '9') c=gc(); while(c>='0' and c<='9') { n=(n<<3)+(n<<1)+c-'0'; c=gc(); }} inline void print(int a) { char s[20]; int i=0; do { s[i++]=a%10+'0'; a/=10; } while(a); i--; while(i>=0) pc(s[i--]); pc('\n'); } inline void prlong(ll a) { char s[20]; int i=0; do { s[i++]=a%10+'0'; a/=10; } while(a); i--; while(i>=0) pc(s[i--]); pc('\n'); } inline int power(int a, int b) { int x=1, y=a; while(b>0) { if(b&1) x*=y; y*=y; b/=2;} return x; } inline int powerl(ll a, ll b) { ll x=1, y=a; while(b>0) { if(b&1) x*=y; x%=MOD; y*=y; y%=MOD; b/=2;} return x%MOD; } inline int gcd(int a, int b) { if(!b) return a; return gcd(b, a%b); } inline void strrev(char *s) { char t; for(int i=0, j=strlen(s)-1;i<j;i++,j--) t=*(s+i), *(s+i)=*(s+j), *(s+j)=t; } template<typename T> int mysize(T &x) { return ((char*)(&x+1)-(char*)&x); }  const int LIM=1000010; int flag[LIM]; inline void gensieve() { mi(flag); int i,j; flag[0] = flag[1] = 1; for(i=4;i<LIM;i+=2) flag[i]=1;  	for (i = 3;i*i < LIM;i=i+2) if(!flag[i]) for(j=i*i;j<LIM;j=j+2*i) flag[j]=1; } int fact (int num) {     if (num <=1 )         return 1;     else         return num * fact (num-1); }   int find_big (char str[], int start) {     int x = str[start];     int count = 0;     int trav;     for (trav = start + 1; *(str + trav ); trav++)     {         if (str[trav] > x)             count++;     }     return count; }   int find_rank (char str[]) {     int len = strlen (str);     int mul = fact (len);       int trav;     int res = 1;     for (trav = 0; *(str + trav); trav++ )     {         int small = find_big (str, trav);         mul = mul / (len - trav);         res += mul * small;       }     return res;     }   void reverse (char str[]) {     int start = 0;     int end = strlen (str)-1;     while (start <= end)     {         char temp = str[start];         str[start] = str[end];         str[end] = temp;         start++;         end--;     }     printf("%s\n",str);   }   void column  (int num) {     char str[20];     int index = 0;     while (num >0 )     {         int rem = num % 26;         if (rem == 0)         {             str[index++] = 'Z';             num = num /26 -1;         }         else         {             str[index++] = rem-1 + 'A';             num = num /26;         }     }     str[index] = '\0';     reverse (str);   }   int main() {     int t;     scanf("%d",&t);     char *str = (char *)malloc (sizeof(char) * 10);     while (t--)     {         scanf("%s",str);         int res = find_rank (str);         column(res);     }     return 0; }
#include<iostream> using namespace std; int main(){ 	cout<<"NOT YET!"; }
#include<bits/stdc++.h> using namespace std; int main() { 	int t; 	cin>>t; 	int arr[26]; 	char c; 	//C,C#,D,D#,E,F,F#,G,G#,A,B and S 	int arrC[10]={9,10,0,2,4,5,7,11}; 	int arrs[8]={0,0,1,3,0,6,8}; 	while(t--) 	{int ind[3]; 		 		for( int i=0;i<3;i++) 		{ 		cin>>c; 		if(c>='a')ind[i]=arrs[c-'a']; 		else if(c=='S')ind[i]=11; 		else ind[i]=arrC[c-'A']; 	} 	int first,second; 	//cout<<ind[0]<<" "<<ind[1]<<" "<<ind[2]<<endl; 	if(ind[0]>ind[1])first=12+ind[1]-ind[0]; 	else first=ind[1]-ind[0]; 	if(ind[1]>ind[2])second=12+ind[2]-ind[1]; 	else second=ind[2]-ind[1]; 	 	//cout<<first<<" "<<second<<" "<<endl; 	 	if(first==4 )cout<<"Major"<<endl; 	else cout<<"Minor"<<endl; 	 	 		 	} 	 	return 0; }
#include<iostream> using namespace std; int main() { int n; long long h; for(int i=1;i<=n;i++) cin>>h; for(int i=1;i<=n;i++) cin>>h; cout<<"2"<<endl; }
#include<iostream> #include<string> #include<map> #include<algorithm> #include<vector> using namespace std; int main() { 	int t; 	cin>>t; 	 	for(int x=1;x<=t;x++) 	{ 		int n; 		cin>>n; 		map<string,vector<string> > mp; 			map<string,vector<string> > ::iterator it;         string v;         for(int i=0;i<n;i++)         {         	cin>>v;         	int l=v.length();         	string s;         	s+=v[l-3];         	s+=v[l-2];         	s+=v[l-1];         	mp[s].push_back(v);         	 		} 		cout<<"Case : "<<x<<"\n"; 		vector<string> ::iterator tt; 		for(it=mp.begin();it!=mp.end();it++) 		{ 			vector<string> v=it->second; //			for(int i=0;i<v.size();i++) //			{ //				cout<<v[i]<<" "; //			}             sort(v.begin(),v.end()); 			for(tt=v.begin();tt!=v.end();tt++) 			cout<<(*tt)<<" "; 			cout<<"\n"; 		} 		 	//	x++; 	} }
#include<stdio.h> using namespace std; int gcd(int x,int y) { 	if(x==0) 	return y; 	if(y==0) 	return x; 	if(x==y) 	return x; 	else 	return gcd(y,x%y); } int main() { 	int t,a,b,n,x; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d%d%d",&a,&b,&n); 		x=gcd(a,b); 		//printf("x=%d\n",x); 		if((n%x==0)&&(n<=a||n<=b)) 		printf("YES\n"); 		else 		printf("NO\n"); 	} }
#include <iostream> #include<stdio.h> using namespace std;  bool isOpening(char ch) {     return (ch=='(' || ch=='[' || ch=='{'); }  bool isClosing(char ch) {     return (ch==')' || ch==']' || ch=='}'); }  bool check(char ch, char ch1) {     return((ch=='{'&&ch1=='}')||(ch=='['&&ch1==']')||(ch=='('&&ch1==')')); }  int main() {     int t;     cin>>t;     while(t--)     {         int i,j=-1,flag=0;         char s[1001],a[1001]={'\0'};         scanf("%s",s);         for(i=0;s[i]!='\0';i++)         {             if(isOpening(s[i]))             {                 j++;                 a[j]=s[i];             }             else if(isClosing(s[i]))             {                 if(!check(a[j],s[i]))                 {flag=1;                 break;                 }                 else                 {                     a[j]='\0';                     j--;                 }             }         }          if(flag==0 && j==-1)         cout<<"BALANCED"<<endl;          else         cout<<"NOT BALANCED"<<endl;     }     return 0; }
#include<bits/stdc++.h>     using namespace std;     #define vi vector<int>     #define ll long long     #define pb push_back     int vis[100];vi v1[100];     int b1,pi;     void dfs(int x,string s)     {     string s1=s,n="";     int a=x;     vis[x]=-1;     if(x==0)     s+='0';     while(x)     {     n+=char((x%10)+48);     x/=10;     }           for (int i = n.size()-1; i >=0; --i)     {     s+=n[i];     }     x=a;     s+=" ";     //cout<<"at "<<a<<" \ns="<<s<<"\n";     if(x==b1)     {     pi++;     cout<<s<<"\n";     return ;     }     //cout<<v1[1].size();     for (int i = 0; i < v1[x].size(); ++i)     {     //cout<<"**";     //cout<<"x="<<x<<" x1="<<v1[x][i]<<"\n";     if(v1[x][i]!=b1)     if(vis[v1[x][i]]==-1)     continue;     //cout<<"*";     vis[v1[x][i]]++;     dfs(v1[x][i],s);     }     vis[x]=1;     return;     }           int main()     {     int t2;     cin>>t2;     while(t2--)     {     int n,a,b,z,t,t1;     int c;           memset(vis,0,sizeof vis);     vi v[100];           cin>>n>>a>>b>>z>>c;     for (int i = 0; i < c; ++i)     {     scanf("%d%d",&t,&t1);     v[t].pb(t1);     }     for (int i = 0; i < 100; ++i)     {     v1[i]=v[i];     }     /*if(a==b&&b==z)     {           cout<<a<<"\nYES\n";     continue;     }     if(a==b)     {     cout<<a<<"\nNO\n";     continue;     }*/           pi=0;     b1=b;     string s="";     vis[a]++;     dfs(a,s);     memset(vis,0,sizeof vis);     queue<int>q;     if(pi==0)     {           cout<<"NO PATH\n";     continue;     }     q.push(a);     int f=0;     while(!q.empty()&&!f)     {     int x=q.front();     q.pop();     if(x==z)     continue;     for (int i = 0; i < v[x].size(); ++i)     {     if(vis[v[x][i]])     continue;     if(v[x][i]==b)     {     f=1;     break;     }     if(i==z)     continue;     vis[v[x][i]]++;     q.push(v[x][i]);     }     }     if(f==0&&a!=b)     cout<<"YES\n";     else     cout<<"NO\n";           }     return 0;     }  
#include <bits/stdc++.h> #define MOD 1000000007 using namespace std;   pair<long long,long long> BB[2005]; long long ANS[2005],FF[200005],INVF[200005];   long long expoMod(long long b,long long K) {     if(K==0)         return 1;     long long ANS=expoMod(b,K/2);     ANS=(ANS*ANS)%MOD;     if(K%2==0) return ANS;     else{         ANS=(ANS*b)%MOD;         return ANS;     } }   long long compute(long long a,long long b,long long c,long long d) {     long long x = c-a;     long long y = d-b;     long long res = FF[x+y];     res = (res * INVF[x]) % MOD;     res = (res * INVF[y]) % MOD;     res = res % MOD;     return res; }   int main() {     //freopen("inp.in","r",stdin);     long long t,M,N,K,x,y;          FF[0] = 1;          for(long long i = 1 ; i <= 200005 ; i++) FF[i] = (FF[i-1]*i) % MOD;       INVF[200005] = expoMod(FF[200005],MOD-2);     for(long long i = 200004; i >= 0 ; i--) INVF[i] = ( INVF[i+1]*(i+1) ) % MOD;     int T;     cin >> T;     while(T--){     cin >> M >> N >> K;       for(int i = 0 ; i < K ; i++)     {         cin >> x >> y;         BB[i]=make_pair(x,y);     }       BB[K]=make_pair(M,N);     sort(BB,BB+K+1);       for(int i=0;i<=K;i++) ANS[i]=compute(1,1,BB[i].first,BB[i].second);          for(int i=0;i<K;i++)     {         for(int j=i+1;j<K+1;j++)         {             if((BB[j].first<BB[i].first) or (BB[j].second<BB[i].second))                 continue;             ANS[j]=(ANS[j]-(ANS[i]*compute(BB[i].first,BB[i].second,BB[j].first,BB[j].second))%MOD+MOD)%MOD;         }     }       if(ANS[K] < 0) ANS[K]+=MOD;     cout << ANS[K] << "\n";     }     return 0; }  
    //coding dijkstras in my own style #include <iostream> #include <vector> #include <queue> #include <cmath> using namespace std; struct compare {     bool operator()(const pair<double,int>& l, const pair<double,int>& r)     {         return l.first < r.first;     } }; int main() {         //cout<<MAX_INPUT;               int test;     cin>>test;               while(test--)     {         int V;         cin>>V;                  vector<pair<double,int> > adj[10000];         int a,b;         double w;         scanf("%d%d%lf",&a,&b,&w);                  while(a!=-1&&b!=-1&&w!=-1)         {             adj[a].push_back(make_pair(w,b));             adj[b].push_back(make_pair(w,a));                          scanf("%d%d%lf",&a,&b,&w);                                   }                                    double weight[1000]={0};         bool color[10000]={0};//if the node is reached and shortest distance for it is calculated then there is no need to repush anything for it         for(int i=1;i<=V;i++)         {             weight[i]=-1000000000;                                   }                      //start with node a and push all it's vertices in the priority queue...check till the time the priority queue is not empty..if it is still full just go to those nodes which aren't yet colored and color only those nodes where you have reached the minimum way using the priority queue         int source,dest;                  source=1;         dest=V;                      //cin>>source>>dest;         weight[source]=0;         color[source]=true;         priority_queue<pair<double,int>,vector<pair<double, int> >,compare > p1;                  for(int i=0;i<adj[source].size();i++)         {             p1.push(adj[source][i]);                 //  cout<<p1.top().first;                              // p1.top().second+=weight[source];         }                  double min_weight=10000000;         while(!p1.empty())         {             int curr=p1.top().second;                                           //cout<<curr;                 //cout<<"is the node currently"<<endl;             weight[curr]=p1.top().first;                              //cout<<weight[curr]<<endl;                          if(weight[curr]<min_weight)                 min_weight=weight[curr];                                       color[curr]=true;                          if(p1.top().second==dest)                 break;                          p1.pop();                          for(int i=0;i<adj[curr].size();i++)             {                 if(!color[adj[curr][i].second])                 {                                          p1.push(make_pair(adj[curr][i].first, adj[curr][i].second));                                                                                                     }                              }                                                                          }                                        //for(int i=1;i<=3;i++)             //if(weight[dest]!=1000000000)                  if(V!=1)             printf("%lf\n",min_weight);                  else             printf("0\n");                 //cout<<min_weight<<endl;                      //else             //cout<<-1<<endl;             //cout<<weight[dest]<<endl;                  for(int i=0;i<=V;i++)         {             adj[i].clear();                  }                       }           } 
#include<iostream> #include<stdlib.h> #include<algorithm> using namespace std; int main() {     long long unsigned t,m;     string n;     char k;     cin>>t;     while(t--)     {         cin>>n>>k;         m=count(n.begin(),n.end(),k);         cout<<m<<"\n";       }     return 0; } 
#include<iostream> #include<stdio.h> #include<string.h> using namespace std;   int IndexOf(char a[], char c) {     int i=0;     for(i=0;i<strlen(a);i++)     {         if(a[i]==c)         return i;     }     return -1; }   int main() {     char row1[]="qwertyuiop";     char row2[]="asdfghjkl";     char row3[]="zxcvbnm";     bool uppercase=false;     char q[1000];     cin.getline(q,1000);     char ans[1000];         {             int i=0;             for(i=0;i<strlen(q);i++)             {                 uppercase=false;                 char c=q[i];                 if(c==' ' || c=='A' || c=='a' || c=='Q' || c=='q' || c=='Z' || c=='z')                 {                     switch(c)                         {                                 case 'A':c='L';break;                                 case 'a':c='l';break;                                 case 'Q':c='P';break;                                 case 'q':c='p';break;                                 case 'z':c='m';break;                                 case 'Z':c='M';break;                         }                         ans[i]=c;                 }                 else                 {                     if(c-97 < 0)                     {                         c+=32;                         uppercase=true;                     }                     int k1,k2,k3;                     k1=IndexOf(row1,c);                     k2=IndexOf(row2,c);                     k3=IndexOf(row3,c);                                          if(k1>0)                     c=row1[--k1];                     else if(k2>0)                     c=row2[--k2];                     else                     c=row3[--k3];                     if(uppercase==true)                     c-=32;                     ans[i]=c;                 }             }             ans[i]='\0';             cout<<ans<<endl;         }     return 0; }
#include<stdio.h> int main() { int i,j,a[3][3],b[3][3],k=15,m,n; for(m=0;m<3;m++) for(n=0;n<3;n++) { a[m][n]=0; } m=1; n=2; a[m][n]=k; for(i=0;i<3;i++) { 	while(m==n&&m,n<2) 	{ 	m++; 	n++; 	k++; 	a[m][n]=k; 	} 	if(m==2&&n==2) 	n--; 	if(m!=n&&n==2) 	{ 	if(m==0) 	{ 	k++; 	a[m][n]=k; 	n=n-2; 	m++; 	} 	else 	{ 	k++; 	m++; 	n=n-2; 	a[m][n]=k; 	} 	} 	if(m!=n&&n==0) 	{ 	if(m==1) 	{ 	k++; 	a[m][n]=k; 	} 	else 	{ 	m=m-2; 	n++; 	k++; 	a[m][n]=k; 	} 	} 	if(m!=n&&n==1) 	{ 	if(a[m][n]==0) 	{ 	k++; 	a[m][n]=k; 	m=m-2; 	n++; 	} 	else 	{ 	n--; 	k++; 	a[m][n]=k; 	} 	} } b[0][1]=a[1][2]; b[1][0]=a[0][1]; b[2][0]=a[0][0]; b[1][1]=a[1][1]; b[0][2]=a[2][2]; b[1][2]=a[2][1]; b[0][0]=a[0][2]; b[2][1]=a[1][0]; b[2][2]=a[2][0]; for(m=0;m<3;m++) { for(n=0;n<3;n++) printf(" ",a[m][n]); printf("\n"); } printf("\n"); for(m=0;m<3;m++) { for(n=0;n<3;n++) printf(" ",b[m][n]); printf("\n"); } printf("\n"); b[2][1]=a[1][2]; b[1][2]=a[0][1]; b[0][2]=a[0][0]; b[1][1]=a[1][1]; b[2][0]=a[2][2]; b[1][0]=a[2][1]; b[2][2]=a[0][2]; b[0][1]=a[1][0]; b[0][0]=a[2][0]; for(m=0;m<3;m++) { for(n=0;n<3;n++) printf(" ",b[m][n]); printf("\n"); } printf("\n"); b[1][0]=a[1][2]; b[2][1]=a[0][1]; b[2][2]=a[0][0]; b[1][1]=a[1][1]; b[0][0]=a[2][2]; b[0][1]=a[2][1]; b[2][0]=a[0][2]; b[1][2]=a[1][0]; b[0][2]=a[2][0]; for(m=0;m<3;m++) { for(n=0;n<3;n++) printf(" ",b[m][n]); printf("\n"); } return 0; } 
#include<iostream> #include<string.h> using namespace std; int main() {     char c[1000];     cin.getline(c,1000);     for(int i=0;i<strlen(c);i++)     {         char a=c[i]+1;         if(c[i]=='z')         cout<<"a";         else         cout<<a;     }     cout<<endl;     return 0; }
#include<iostream> #include<math.h> using namespace std;   int main() {     int n,k;     cin>>n>>k;     if(n==k || (n==1 && k==1))     cout<<"1"<<endl;     else     {         int c=n-k;         --n; --k;         long long int ans=1;         int big=max(k,c);         for(int i=big+1;i<=n;i++)         ans=ans*i;         for(int i=1;i<=min(k,c);i++)         ans=ans/i;         cout<<ans<<endl;     }     return 0; }
#include<algorithm> #include<iostream> #include<cstdio> #include<vector> #include<fstream> #include<iomanip> #include<bitset> #include<deque> #include<queue> #include<string> #include<map> #include<cstring> #include<sstream> #include<cmath> #include<cassert> using namespace std; #define MOD 10000  int divisors[500001];  int fpow(int a, int b) {     int x = 1, y = a;     while (b > 0)     {         if (b%2 == 1)         {             x = x*y;             x %= MOD;         }         y = y*y;         y %= MOD;         b >>= 1;     }     return x; }  int main() { 	memset(divisors, 0, sizeof divisors); 	for (int i = 1; i <= 500000; i++) 		for (int j = i; j <= 500000; j += i) 			divisors[j]++; 	int T, N; 	scanf("%d", &T); 	for (int t = 0; t < T; t++) 	{ 		scanf("%d", &N); 		if (N == 1) 		{ 			printf("1\n"); 			continue; 		} 		int fac = divisors[N]-2; 		bool exceed = 0; 		if ((fac&1) == 0) 		{ 			int ans = 1; 			int r = (fac>>1); 			if (N >= MOD && r >= 1) 				exceed = 1; 			else 			{ 				for (int i = 0; i < r; i++) 				{ 					ans = ans*N; 					if (ans >= MOD) 					{ 						exceed = 1; 						break; 					} 				} 			} 			if (exceed) 				printf("%04d\n", fpow(N%MOD, r)); 			else 				printf("%d\n", ans); 		} 		else 		{ 			int ans = (int)sqrt(N); 			int anss = ans; 			int r = ((fac-1)>>1); 			if (N >= MOD && r >= 1) 				exceed = 1; 			else 			{ 				for (int i = 0; i < r; i++) 				{ 					ans = ans*N; 					if (ans >= MOD) 					{ 						exceed = 1; 						break; 					} 				} 			} 			if (exceed) 				printf("%04d\n", (anss*fpow(N%MOD, r))%MOD); 			else 				printf("%d\n", ans); 		} 	} 	return 0; } 
    #include<iostream>     #include<cstdio>     using namespace std;     bool lp(int what_year){     bool bLeapYear = false;     if ((what_year % 4) ==0) {     if ((what_year % 100) == 0) {     bLeapYear = ((what_year % 400) == 0);     } else {     bLeapYear = true;     }     //bLeapYear = true;     }     /* if (what_year % 100 == 0 && what_year % 400 == 0)     bLeapYear = true;*/     return bLeapYear;     }     int main(){     int t,d,m,y,d1,m1,y1;     cin>>t;     while(t--){     cin>>d;     getchar();     cin>>m;     getchar();     cin>>y;     int st=0,st2=0;     if(d>31 || m>12)     cout<<"Invalid Date\n";     else if(m==2 && d>29)     cout<<"Invalid Date\n";     else{     if(!lp(y)){     if((m==2 && d>28) || ((m==1 || m==3 || m==5 || m==7 || m==8 || m==10 || m==12) && d>31) || ((m==4 || m==6 || m==9 || m==11) && d>30))     cout<<"Invalid Date\n";     else{     if(m==2)     d1=(d+1)%29;     else if(m==1 || m==3 || m==5 || m==7 || m==8 || m==10 || m==12)     d1=(d+1)%32;     else     d1=(d+1)%31;     if(d1==0)     d1=1;     m1=m;     if(d1==1)     m1=(m1+1)%13;     if(m1==0)     {     m1=1;     st=1;     }     y1=y;     if(st==1)     y1++;     cout<<d1<<"/"<<m1<<"/"<<y1<<endl;     }     }     else{     if((m==2 && d>29) || ((m==1 || m==3 || m==5 || m==7 || m==8 || m==10 || m==12) && d>31) || ((m==4 || m==6 || m==9 || m==11) && d>30))     cout<<"Invalid Date\n";     else{     if(m==2)     d1=(d+1)%30;     else if(m==1 || m==3 || m==5 || m==7 || m==8 || m==10 || m==12)     d1=(d+1)%32;     else     d1=(d+1)%31;     if(d1==0)     d1=1;     m1=m;     if(d1==1)     m1=(m1+1)%13;     if(m1==0)     {     m1=1;     st=1;     }     y1=y;     if(st==1)     y1++;     cout<<d1<<"/"<<m1<<"/"<<y1<<endl;     }     }     }     }     return 0;     } 
#include<bits/stdc++.h>  using namespace std;  int main() { 	int t,n,m,i,j,a[1009][1009],dp[1009][1009]; 	 	cin>>t; 	while(t--) 	{ 		cin>>n>>m; 		 		for(i=0;i<n;i++) 		{ 		 			for(j=0;j<m;j++) 			{ 				cin>>a[i][j]; 				dp[i][j]=INT_MAX; 			} 		} 		 		dp[0][0]=a[0][0];  		for(i=1;i<n;i++) 		{ 			dp[i][0]=a[i][0]+dp[i-1][0]; 		}  		for(j=1;j<m;j++) 		{ 			dp[0][j]=a[0][j]+dp[0][j-1]; 		}  		for(i=1;i<n;i++) 		{ 			for(j=1;j<m;j++) 			{ 				dp[i][j] = ( dp[i-1][j] < dp[i][j-1] ? ( dp[i-1][j] +a[i][j] ) : (dp[i][j-1]+a[i][j] )  ); 			} 		} 		cout<<dp[n-1][m-1]<<endl; 	} 	return 0; } 
#include <bits/stdc++.h> using namespace std; #define ll long long #define sz 1005 char maze[sz][sz]; int visited[sz][sz];  struct point{     int x,y; };  int bfs(point p,int n,int m) {     queue <point> q;     point t,r;     q.push(p);     visited[p.x][p.y]=1;     while(!q.empty())     {         t=q.front(); q.pop();         if(t.x-1>=0)         {             if(maze[t.x-1][t.y]!='#' && visited[t.x-1][t.y]==0){r.x=t.x-1; r.y=t.y; q.push(r); visited[r.x][r.y]=visited[t.x][t.y]+1;}         }         if(t.y-1>=0)         {             if(maze[t.x][t.y-1]!='#' && visited[t.x][t.y-1]==0){r.x=t.x; r.y=t.y-1; q.push(r);visited[r.x][r.y]=visited[t.x][t.y]+1;}         }         if(t.x+1<m)         {             if(maze[t.x+1][t.y]!='#' && visited[t.x+1][t.y]==0){r.x=t.x+1; r.y=t.y; q.push(r); visited[r.x][r.y]=visited[t.x][t.y]+1;}         }         if(t.y+1<n)         {             if(maze[t.x][t.y+1]!='#' && visited[t.x][t.y+1]==0){r.x=t.x; r.y=t.y+1; q.push(r); visited[r.x][r.y]=visited[t.x][t.y]+1;}         }         if(maze[t.x][t.y]=='E'){return visited[t.x][t.y]-1;}     }     return -1; } int main() {     memset(visited,0,sizeof(visited));     int n,m,i,j;     cin>>n>>m;     point start;     for(i=0;i<n;i++)     {         for(j=0;j<m;j++)         {             cin>>maze[i][j];             if(maze[i][j]=='S')             {                 start.x=i; start.y=j;             }         }     }     cout<<bfs(start,n,m);     return 0; } 
#include<iostream> using namespace std; int N,M; #define oo 100000000; int Matrix[1010][1010]; int visited[1010]; int Parent[1010]; long Distance[1010]; int index[1010]; template<class T> void Swap(T& a, T& b) {   T temp=b;   b=a;   a=temp; } void QuickSort(long Arr[],int left, int right) { 	long Mid=Arr[(left+right)/2]; 	int i=left; 	int j=right; 	while(i<=j) 	{ 	    while(Arr[i]<Mid) i++; 		while(Arr[j]>Mid) j--; 		if(i<=j) 		{ 			Swap(Arr[i],Arr[j]); 			Swap(index[i],index[j]); 			i++; 			j--; 		} 	 	} 	if(j>left) 		QuickSort(Arr,left,j); 	if(i<right) 		QuickSort(Arr,i,right); } int Mindis() { 	long Min=oo; 	int iMin=0; 	for(int i=1;i<=N;i++) 	{ 		if(!visited[i] && Min>Distance[i]) 		{ 			Min=Distance[i]; 			iMin=i; 		} 	} 	return iMin; } void prim() { 	Distance[1]=0; 	for(int i=1;i<=N;i++) 	{ 		int u= Mindis(); 		visited[u]=1; 		for(int i=1;i<=N;i++) 		{ 			if(!visited[i]&& Distance[i]>Matrix[u][i]) 			{ 				Distance[i]=Matrix[u][i]; 				Parent[i]=u; 			} 		} 	} } int main() { 	ios::sync_with_stdio(false); 	//freopen("input.txt","r",stdin); 	int T; 	cin>>T; 	for(int tc=0;tc<T;tc++) 	{ 		cin>>N>>M; 		for(int i=1;i<=N;i++) 		{ 			Distance[i]=oo; 			visited[i]=Parent[i]=0; 			for(int j=1;j<=N;j++) 				Matrix[i][j]=oo; 		} 		int x,y,z; 		for(int i=0;i<M;i++) 		{ 			cin>>x>>y>>z; 			Matrix[x][y]=z; 			Matrix[y][x]=z; 		} 		prim(); 		for(int i=1;i<=N;i++) 			index[i]=i; 		QuickSort(Distance,1,N); 		for(int i=1;i<=N;i++) 		{ 			if(!Distance[i]) 				continue; 			if(index[i]>Parent[index[i]] ) 				cout<<Parent[index[i]]<<" "<<index[i]<<" "<<Distance[i]<<endl; 			else 				cout<<index[i]<<" "<<Parent[index[i]]<<" "<<Distance[i]<<endl; 		} 		 	} 	return 0; }
#include<bits/stdc++.h> using namespace std;  typedef long long LL; LL dp[1000006]; int main() {     LL n, ans=0;     scanf("%lld", &n);     for(int i=0;i<n;i++)     {         int num;         scanf("%d", &num);         ans+=dp[num];         dp[num]++;     }     printf("%lld", ((n*(n-1))/2)-ans); } 
#include<stdio.h> #include<iostream> #include<vector> #include<queue> #include<algorithm> #include<sstream> #include<set> #include<map> #include<stack> #include<cmath> #include <map> #include<cstdlib> #include<cstring> #include<string> #include<set> #include<cassert> using namespace std;   #define DEBUG //on-off switch for prlling statements   // Input macros #define s(n)                        scanf("%d",&n) #define sc(n)                       scanf("%c",&n) #define sl(n)                       scanf("%lld",&n) #define sf(n)                       scanf("%lf",&n) #define ss(n)                       scanf("%s",n)   // Useful constants #define INF                        1000000000 #define EPS                         1e-14   // Useful hardware instructions #define bitcount                    __builtin_popcount #define gcd                         __gcd   // Useful container manipulation / traversal macros #define forall(i,a,b)               for(ll i=a;i<b;i++) #define foreach(v, c)               for( typeof( (c).begin()) v = (c).begin();  v != (c).end(); ++v) #define all(a)                      a.begin(), a.end() #define in(a,b)                     ( (b).find(a) != (b).end())  #define fill(a,v)                    memset(a, v, sizeof a) #define sz(a)                       ((ll)(a.size()))   // Some common useful functions #define maX(a,b)                     ( (a) > (b) ? (a) : (b)) #define miN(a,b)                     ( (a) < (b) ? (a) : (b))   #define ll long long int #define llu long long unsigned #define ld long #define mod 1000000007 #define F first #define S second #define pb push_back #define llu long long unsigned #define ld long ll ans[402]; ll dp[402][402][402]; ll wt[402]; ll c[402][402]; ll powval[402][402]; ll power(ll x,ll y) { 	if(y == 0) 	return 1; 	ll d=power(x,y/2); 	d=(d*d)%mod; 	if(y&1) 	{ 		d=(x*d)%mod; 	} 	return d; } ll divmodulo(ll num,ll den) { 	num=num%mod; 	den=power(den,mod-2); 	return (num*den)%mod; } ll mul(ll x,ll y) { 	return ((x%mod)*(y%mod))%mod; } ll ncr(ll n,ll r)// calculatencr { 	if(r == 0 || r==n) 	return n; 	ll num=1; 	ll den=1; 	for(int i=0;i<r;i++) 	{ 		num=(num*((n-i)%mod))%mod; 		den=(den*(i+1))%mod; 	} 	return divmodulo(num,den); 	 }  void calc(int x,ll k) { 	ll ans=0; 	ll y=wt[0]; 	ll val=divmodulo(((power(y,k+1)-1)%mod+mod)%mod,y-1); 	for(int j=0;j<=min((ll)400,k);j++) 	{ 	 		ll zero=k-j; 		ans=(ans+(val*dp[400][x][j]))%mod;  		val=divmodulo(((ncr(k+1,j+1)*power(y,k-j)-val)%mod+mod)%mod,y-1); 	} 	ans=((ans-dp[400][x][0])%mod+mod)%mod; 	printf("%lld\n",ans%mod); }  void preprocess()  { 	for(int i=0;i<=401;i++) 	{ 		powval[i][0] = 1; 		for(int j=1;j<=401;j++) 		{ 			powval[i][j] =( powval[i][j-1]*wt[i])%mod; 		} 	} 	fill(c,0); 	for(int i=0;i<=401;i++) 	{ 		c[i][0]= 1; 		c[i][i]=1; 	} 	for(int i=1;i<=401;i++) 	{ 		for(int j=1;j<i;j++) 		{ 			c[i][j] = (c[i-1][j] + c[i-1][j-1])%mod; 		 		} 	} } void solvedp() { 	dp[0][0][0]=1; 	for(int i=0;i<=400;i++) 	{ 		for(int j=0;j<=400;j++) 		{ 			for(int k=0;k<=j;k++) 			{  				int next=i+1; 				dp[next][j][k] =(dp[next][j][k]+dp[i][j][k] )%mod; 				int val=j; 				for(int l=1;l+k<=400;l++) 				{ 					val += next; 					if(val > 400) break; 					dp[next][val][k+l] = (dp[next][val][k+l]+((c[l+k][k]*powval[next][l])%mod)*dp[i][j][k])%mod; 		 				} 			} 		} 	} }  int main() { 	fill(wt,0); int n; 	ll k; 	s(n); 	sl(k); 	for(int i=0;i<n;i++) 	{ 		int x; 		s(x); 		wt[x]++; 	} 	preprocess(); 	solvedp(); 	assert(wt[0] != 1); 	int q; 	s(q); 	for(int i=0;i<q;i++) 	{ 		int x; 		s(x); 		if(wt[0] == 0) 		{ 			ll sum=0; 			for(int j=1;j<=min((ll)400,k);j++) 			{ 				sum=(sum+dp[400][x][j])%mod; 			} 			printf("%lld\n",sum%mod); 			continue; 		} 		calc(x,k); 	} }
#include <cstdio> #include <iostream> #include <vector> #include <set> #include <cstring> #include <map> #include <algorithm> #include <utility> #include <cmath> #include <stack> #include <queue> #include <sstream> #include <numeric> #include <iterator> using namespace std;  #define maX(a, b) ( (a) > (b) ? (a) : (b)) #define miN(a, b) ( (a) < (b) ? (a) : (b)) #define pb push_back #define mp make_pair #define fill(a, v) memset(a, v, sizeof a) #define tr(v, it) for(typeof((v).begin()) it = (v).begin(); it != (v).end();it++) #define sz(a) ((int)(a.size())) #define ff first #define ss second  const int INF = 1e9; const double eps = 1e-9; typedef long long lli;   lli N;  lli MOD;  vector<vector<lli> > v(31, vector<lli>(31)); vector<vector<lli> > zeros(31, vector<lli>(31));  void pre() {     for(lli i = 0;i < 31;i++) {         for(lli j = 0;j < 31;j++) {             v[i][j] = (i == j ? 1 : 0);             zeros[i][j] = 0;         }     }  }  vector<vector<lli> > add(vector<vector<lli> > v1, vector<vector<lli> > v2) {      for(lli i = 1;i <= N;i++) {         for(lli j = 1;j <= N;j++) {             v1[i][j] = (v1[i][j] + v2[i][j])%MOD;         }     }      return v1; }  vector<vector<lli> > mul(vector<vector<lli> > v1, vector<vector<lli> > v2) {     vector<vector<lli> > res(31, vector<lli> (31));     for(lli i = 1;i <= N;i++) {         for(lli j = 1;j <= N;j++) {             res[i][j] = 0;             for(lli k = 1;k <= N;k++) {                 res[i][j] = (res[i][j] + v1[i][k] * v2[k][j])%MOD;             }         }     }      return res; }  vector<vector<lli> > exp(vector<vector<lli> > base, long long p) {     vector<vector<lli> > ans = v;      while(p > 0) {         if(p&1)ans = mul(ans, base);         p >>= 1;         base = mul(base,base);     }     return ans; }  vector<vector<lli> > getGP(long long K, long long powOf2, vector<vector<lli> > r) {     if(K == 1) {         return v;     }      vector<vector<lli> > ans;      if(K&1) {         ans = exp(r, (K-1) * powOf2);     } else {         ans = zeros;     }      ans = add(ans, mul(add(v, exp(r, powOf2)), getGP(K/2, powOf2*2, r) ));     return ans; }    int main() {     pre();     MOD = 1000000007LL;     vector<vector<lli> > r;     r = zeros;      lli  M, K, a, b;     cin >> N >> M >>K;      for(int i = 0;i < M;i++) {         cin >> a >> b;         r[a][b]++;     }       vector<vector<lli> > tmp = getGP(K, 1, r);     tmp = mul(tmp,r);      lli Q;     cin >> Q;      while(Q--) {         cin >> a >> b;         cout << tmp[a][b] << endl;     }     return 0;  }         
#include <bits/stdc++.h> using namespace std; typedef long long LL;  const int MAXN = 1e6 + 9;  LL N,K; LL tim[MAXN];  inline bool isvalid(LL cur){ 	LL cnt = 0LL; 	for(int i = 0;i < K;++i) 		cnt += (cur / tim[i]);  	return (cnt >= N); }  int main (){    scanf("%lld %lld",&K,&N);     for(int i = 0;i < K;++i) 	 scanf("%lld",&tim[i]);     LL lo = 0,hi = 1e16;    while(lo < hi){    	 LL md = (lo + hi) >> 1;    	 if(isvalid(md)) hi = md;    	 else lo = md + 1;    }     printf("%lld\n",hi);    return 0; } 
// adijimmy #include <bits/stdc++.h> using namespace std; typedef long long int ll; const int mod = 1e9+7; #define REP(i, n) for (int i = 0; i < (int)(n); ++i) ll power(ll a,ll b){   ll res = 1;   while(b){     if(b&1) res = (res*a)%mod;     a = (a*a)%mod;     b >>= 1;   }   return res; } #define MAX 100005 ll degree[MAX]; int main(){   ll n,u,v;   scanf("%lld",&n);   for(ll i=0;i<n-1;i++){     scanf("%lld %lld",&u,&v);     u--; v--;     degree[u]++; degree[v]++;   }   ll res = n*(n-1)*(n-2)/6;   res -= (n-1)*(n-2);   for(ll i=0;i<n;i++){ 	res += (degree[i]*(degree[i]-1))/2;   }   cout << res << endl;   return 0; } 
#include<cstdio>  using namespace std;  typedef long long int int64;  int main() { 	int64 t, n, even, odd, temp; 	int64 ans; 	scanf("%lld",&t); 	while(t--) { 		even = 0; 		odd = 0; 		scanf("%lld",&n); 		for(int64 i = 0; i<n; i++) { 			scanf("%lld",&temp); 			if(temp%2) odd++; 			else even++; 		} 		ans = odd*even; 		ans += (even*(even-1))/2; 		printf("%lld\n",ans); 	} 	return 0; }
#include <bits/stdc++.h>  using namespace std;  #define pb push_back #define mp make_pair #define ll long long int #define s(x) scanf("%d", &x) #define sl(x) scanf("%lld", &x) #define mod 1000000007 #define get getchar_unlocked  int N;  struct node {     int x, ind; }seg[400005];  int a[100005]; int B[32][100005]; ll S[100005]; ll ans = 0;  void C_S_T(int l, int r, int ind) {     if (l == r) {         seg[ind].x = a[l];         seg[ind].ind = l;         return;     }     int m = (l+r)/2;     int p = 2*ind+1;     int q = p+1;     C_S_T(l, m, p);     C_S_T(m+1, r, q);     if (seg[p].x >= seg[q].x)         seg[ind] = seg[p];     else         seg[ind] = seg[q]; }  node getA(int x, int y, int l, int r, int ind) {     if (r < x || y < l) {         node A;         A.x = A.ind = -1;         return A;     }     if (x <= l && r <= y)         return seg[ind];     int m = (l+r)/2;     int p = 2*ind+1;     int q = p+1;     node A = getA(x, y, l, m, p);     node B = getA(x, y, m+1, r, q);     if (A.x >= B.x)         return A;     return B; }  void query(int l, int r) {     //cerr << l << " " << r << endl;     if (l >= r)         return;     int ind, l1, l2, i, r1, r2;     ll X, O1, O2, Z1, Z2;     node tmp = getA(l, r, 1, N, 0);     //cerr << "YES\n";     ind = tmp.ind;     l1 = l;     r1 = ind-1;     l2 = ind+1;     r2 = r;     for (i = 0; i < 25; ++i) {         X = (1 << i);         if (l1 <= r1) {             O1 = B[i][r1]-B[i][l1-1];             Z1 = r1-l1+1-O1;         }         else             O1 = Z1 = 0;         if (l2 <= r2) {             O2 = B[i][r2]-B[i][l2-1];             Z2 = r2-l2+1-O2;         }         else             O2 = Z2 = 0;         if (a[ind] & X) {             ans += (O1*O2*X);             ans += (Z1*Z2*X);         }         else {             ans += (O1*Z2*X);             ans += (O2*Z1*X);         }      //   cout << ans << endl;     }     if (l1 <= r1)         ans += S[r1]-S[l1-1];    // cout << ans << " ";     if (l2 <= r2)         ans += S[r2]-S[l2-1];     //cout << ans << endl;     query(l, ind-1);     query(ind+1, r); }  int main() {     int n, i, j;     s(n);     N = n;     for (i = 1; i <= n; ++i) {         s(a[i]);         S[i] = S[i-1]+a[i];         for (j = 0; j < 25; ++j) {             B[j][i] = B[j][i-1];             if (a[i] & (1 << j))                 ++B[j][i];         }     }     C_S_T(1, n, 0);     query(1, n);     cout << ans << endl;     return 0; } 
#include<bits/stdc++.h> using namespace std; #define ll long long int main() { 	ll t,i,k,x; 	cin>>t; 	while(t--) 	{ 		cin>>x; 		if(x==0) 		{ 			cout<<3<<endl; 		} 		else if(x==1) 		{ 			cout<<1<<endl; 		} 		else if(x%4==0) 		{ 			cout<<x<<endl; 		} 		else if(x%4==3) 		{ 			cout<<x-1<<endl; 		} 		else cout<<-1<<endl; 	} 	return 0; }
#include <iostream> #include <queue> using namespace std; #define S(n) scanf("%d",&n) #define FOR(i,a,s) for(int i=a;i<s;i++) struct node{     int data;     int fill; } arr[1001][1001]; struct hnode{     int x,y,val; }; struct CALess {      bool operator ()(hnode& lhs, hnode& rhs)      {          return lhs.val > rhs.val;      } }; void sink(int cr, int cc, int tr, int tc){     priority_queue<hnode, std::deque<hnode>, CALess> pq;      hnode cur;     hnode temp;     cur.val = arr[cr][cc].data;     cur.x = cr;     cur.y = cc;     pq.push(cur);     arr[cur.x][cur.y].fill = 1;     int x,y;     while(!pq.empty())     {         cur = pq.top();         pq.pop();         arr[cur.x][cur.y].fill = 2;         x = cur.x;         y = cur.y;         if(y-1 >= 0)         {             if(arr[x][y-1].fill == 0)             {                 arr[x][y-1].data += cur.val;                 temp.val = arr[x][y-1].data;                 temp.x = x;                 temp.y = y-1;                 pq.push(temp);                 arr[x][y-1].fill = 1;             }             else             {                 if(x-1>=0 && arr[x][y-1].fill == 2 && arr[x-1][y].fill == 0)                 {                     arr[x-1][y].data += cur.val;                     temp.val = arr[x-1][y].data;                     temp.x = x-1;                     temp.y = y;                     pq.push(temp);                     arr[x-1][y].fill = 1;                 }             }         }         if(y+1 < tc-x)         {             if(arr[x][y+1].fill == 0)             {                 arr[x][y+1].data += cur.val;                 temp.val = arr[x][y+1].data;                 temp.x = x;                 temp.y = y+1;                 pq.push(temp);                 arr[x][y+1].fill = 1;             }             else             {                 if(x-1>=0 && arr[x][y+1].fill == 2 && arr[x-1][y+1].fill == 0)                 {                     arr[x-1][y+1].data += cur.val;                     temp.val = arr[x-1][y+1].data;                     temp.x = x-1;                     temp.y = y+1;                     pq.push(temp);                     arr[x-1][y+1].fill = 1;                 }             }         }      }  } int main() {     int t = 1, n, k, h;     S(t);     FOR(i,0,t){          S(n);S(k);S(h);         FOR(j,0,k){             FOR(l,0,n-j){                 arr[j][l].data=0;                 arr[j][l].fill=0;             }         }         FOR(j,0,k){             FOR(l,0,n-j){                 S(arr[j][l].data);             }         }         sink(k-1, h-1, k, n);         int max = 0;         FOR(j,0,k){             FOR(l,0,n-j){                 if(max < arr[j][l].data)                     max = arr[j][l].data;             }         }         printf("%d\n",max);     }     return 0; } 
#include<bits/stdc++.h> #define mod 10000 #define ll long long int   using namespace std;  int stressfree[2002][2002],stressfull[2002][2002];  ll powmod(ll a,ll b)  {ll res=1;if(a>=mod)a%=mod;for(;b;b>>=1){if(b&1)res=res*a;if(res>=mod)res%=mod;a=a*a;if(a>=mod)a%=mod;}return res;}   long long int cat[1002];  int main() {  long long int t,n,m,x; cin>>t;  cat[0]=1; cat[1]=1;  for(int i=2;i<=1000;i++) {     for(int j=0;j<i;j++)     {         cat[i]+=cat[j]*cat[i-j-1];         cat[i]%=10000;     } }   while(t--) {     cin>>x;     cout<<cat[x-1]<<endl;  }   return 0; } 
#include <iostream>  using namespace std;  int main() {     int t, n, max_c, max_w, max_m, m, w, c;     scanf("%d", &t);     while (t--) {         scanf("%d %d %d %d", &n, &m, &w, &c);         max_c = 4 * n / 5;         if (max_c > c)             max_c = c;         max_w = 2 * (n - max_c) / 3;         if (max_w > w)             max_w = w;         max_m = n - max_w - max_c;         if (max_m > m)             max_m = m;         if (max_w > max_m * 2)             max_w = max_m * 2;         if (max_c > (max_w + max_m) * 4)             max_c = (max_w + max_m) * 4;         printf("%d %d %d\n", max_m, max_w, max_c);     }     return 0; } 
#include <iostream> #include <stdio.h>  using namespace std;  int main() {     long long t, n, powTwo;     scanf("%lld", &t);     while(t>0)     {         powTwo=1;         scanf("%lld", &n);         while(n/powTwo!=1)             powTwo*=2;         printf("%lld\n", powTwo);         t--;     }     return 0; } 
#include<bits/stdc++.h>  #define rep(i,n) for(int i=0;i<n;i++) #define ll long long #define pl(n) printf("%lld\n",n)  using namespace std;  int checkprime(int x) { 	int l=sqrt(x); 	 	if(x==1) 		return 0; 	if(x==2) 		return 1; 	 	for(int i=2;i<=l;i++) 		if(x%i==0) 			return 0; 	return 1; }  int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		string str; 		cin>>str; 		int len=str.length(); 		int freq[200]={0}; 		int maxfreq=-1; 		 		rep(i,len) 		{ 			freq[str[i]]++; 			if(freq[str[i]]>maxfreq) 				maxfreq=freq[str[i]]; 		} 		 		if(checkprime(maxfreq)==1) 		{ 			rep(i,200) 			if(freq[i]!=0 && (checkprime(freq[i])==1)) 			{ 				freq[i]-=freq[i]/2; 			} 		} 		 		else 		{ 			rep(i,200) 			if(freq[i]!=0 && (checkprime(freq[i])==0)) 				freq[i]-=freq[i]/2; 				 		} 		 		ll ans=0; 		rep(i,200) 			ans+=freq[i]; 		pl(ans); 	} 	return 0; } 
#include<bits/stdc++.h>  using namespace std;  int main() { 	int t; 	cin>>t; 	 	vector<string> v; 	 	for(int i=0;i<t;i++) 	{ 		string s; 		cin>>s; 		v.push_back(s); 	}	 	sort(v.begin(),v.end()); 	 	for(int i=0;i<t;i++) 	{ 		int j=i+1; 		int count=1; 		while(j<t && v[j]==v[i]) 		{ 			j++; 			count++; 		 		} 		 		cout<<v[i]<<" "<<count<<"\n";	 		i=j-1; 		 	} 	 	return 0; } 
#include<bits/stdc++.h> using namespace std;  int ex ,ey ,n ,i ,vrtx1 ,vrtx2 ,next;  struct vertex { 	int x ,y; }adj[1001];  long long dist(int x1 ,int y1 ,int x2 ,int y2) { 	return ((x1-x2) * (x1-x2) + (y1-y2) * (y1-y2));  } bool isvisited[1001]; long long min_dist[1001];  int main() { 	scanf("%d%d%d",&n,&ex,&ey);  	for(i = 1 ; i<=n ; ++i) { 		scanf("%d%d",&adj[i].x,&adj[i].y); 		min_dist[i] = dist(adj[i].x ,adj[i].y ,0 ,0); 	} 	adj[n+1].x = ex; adj[n+1].y = ey; 	min_dist[n+1] = ex*ex + ey*ey; 	long long min_prev = 1e10; 	next = 0; 	for(int index = 0 ; index <= n+1 ; ++index) { 		min_prev = 1e10; 		for(i = 0 ; i<=n+1 && !isvisited[next]; ++i) {  			min_dist[i] = min(min_dist[i] , min_dist[next] + dist(adj[next].x ,adj[next].y ,adj[i].x ,adj[i].y));  			//printf(" i = %d min_prev = %d min_dist[%d]=%lld vrtx1 = %d\n",i ,min_prev ,i ,min_dist[i] ,vrtx1);  			if(min_dist[i] < min_prev && !isvisited[i] && i!= next) {  				vrtx1 = i;  				min_prev = min_dist[i];  				//printf("to be next = %d min_prev = %lld i = %d\n",i,min_prev,i);  			}  		} 		//printf("next = (%d,%d)\n",adj[next].x ,adj[next].y); 		isvisited[next] = 1; 		next = vrtx1; 	} 	printf("%lld\n",min_dist[n+1]); 	return 0;	 }
#include<bits/stdc++.h> #define pb push_back #define mp make_pair using namespace std; inline int scan(){     int x=0;     char c = getchar_unlocked();     while(c<'0'||c>'9'){         c=getchar_unlocked();     }     while(c>='0'&&c<='9'){         x = (x<<3) + (x<<1) + c - '0';         c=getchar_unlocked();     }     return x; } class bit2d{     int n;     int m;     long long  **bit1;     long long **bit2;     long long **bit3;     long long **bit4;     void update(long long **bit,int x,int y,long long val){         for(int i=x;i<=n;i+=i&-i){             for(int j=y;j<=m;j+=j&-j){                 bit[i][j]+=val;             }         }     }          long long query(long long **bit,int x,int y){         long long res=0;         for(int i=x;i;i&=i-1){             for(int j=y;j;j&=j-1){                 res+=bit[i][j];             }         }         return res;     }     long long query(int x,int y){         return query(bit1,x,y)*x*y + query(bit2,x,y)*x + query(bit3,x,y)*y + query(bit4,x,y);     }     public:     void init(int sz,int zs){         n=sz;         m=zs;         bit1 = new long long* [n+1];         bit2 = new long long* [n+1];         bit3 = new long long* [n+1];         bit4 = new long long* [n+1];         for(int i=0;i<=n;++i){             bit1[i] = new long long [m+1];             bit2[i] = new long long [m+1];             bit3[i] = new long long [m+1];             bit4[i] = new long long [m+1];         }     }     void update(int x1,int y1,int x2,int y2,long long val){         update(bit1,x1,y1,val);         update(bit1,x1,y2+1,-val);         update(bit1,x2+1,y1,-val);         update(bit1,x2+1,y2+1,val);         update(bit2,x1,y1,-val*(y1-1));         update(bit2,x1,y2+1,val*y2);         update(bit2,x2+1,y1,val*(y1-1));         update(bit2,x2+1,y2+1,-y2*val);         update(bit3,x1,y1,-val*(x1-1));         update(bit3,x1,y2+1,val*(x1-1));         update(bit3,x2+1,y1,val*x2);         update(bit3,x2+1,y2+1,-x2*val);         update(bit4,x1,y1,(x1-1)*(y1-1)*val);         update(bit4,x1,y2+1,-y2*(x1-1)*val);         update(bit4,x2+1,y1,-x2*(y1-1)*val);         update(bit4,x2+1,y2+1,x2*y2*val);     }     long long query(int x1,int y1,int x2,int y2){         return query(x2,y2) - query(x1-1,y2) - query(x2,y1-1) + query(x1-1,y1-1);     } }; bit2d mybit; int main(){     //freopen("input.txt","r",stdin);     //freopen("output.txt","w",stdout);     int n=scan(),m=scan();     mybit.init(n,m);     for(int i=1;i<=n;++i){         for(int j=1;j<=m;++j){             mybit.update(i,j,i,j,scan());         }     }     int q=scan();     while(q--){         int type=scan(),x1=scan(),y1=scan(),x2=scan(),y2=scan();         if(type&1){             int val=scan();             mybit.update(x1,y1,x2,y2,val*1LL);         }         else{             printf("%lld\n",mybit.query(x1,y1,x2,y2));         }     } }
#include <bits/stdc++.h> using namespace std; // my sincerest thanks to e-maxx for sharing his fft implementation // fft implementation nicked from e-maxx.ru/algo double PI = 3.14159265359; typedef complex<double> base;   void fft (vector<base> & a, bool invert) { 	int n = (int) a.size();     //cout<<n<<endl; 	for (int i=1, j=0; i<n; ++i) { 		int bit = n >> 1; 		//cout<<j<<" "<<bit<<endl; 		for (; j>=bit; bit>>=1) 			{ 				j -= bit; 				//cout<<j<<" hi "<<bit<<endl; 			} 		j += bit; 		//cout<<i<<" bye "<<j<<endl; 		if (i < j) 			swap (a[i], a[j]); 	}   	for (int len=2; len<=n; len<<=1) { 		double ang = 2*PI/len * (invert ? -1 : 1); 		base wlen (cos(ang), sin(ang)); 		for (int i=0; i<n; i+=len) { 			base w (1); 			for (int j=0; j<len/2; ++j) { 				base u = a[i+j],  v = a[i+j+len/2] * w; 				a[i+j] = u + v; 				a[i+j+len/2] = u - v; 				w *= wlen; 			} 		} 	} 	if (invert) 		for (int i=0; i<n; ++i) 			a[i] /= n; } void squarer (const vector<int> & a,  vector<int> & msd) { 	vector<base> fa (a.begin(), a.end()); 	size_t n = 1; 	while (n < a.size())  n <<= 1; 	n <<= 1; 	fa.resize (n);   	fft (fa, false); 	for (size_t i=0; i<n; ++i) 		fa[i] *= fa[i]; 	fft (fa, true);   	msd.resize (n); 	for (size_t i=0; i<n; ++i) 		{ 			msd[i] = int (fa[i].real() + 0.5); 			//cout<<res[i]<<endl; 		} } int main() { 	int n,x; 	scanf("%d", &n); 	vector <int> poly(200001,0); 	poly[0]=1; 	for (int i = 0; i < n; ++i) 	{ 		scanf("%d", &x); 		poly[x]=1; 	} 	vector <int> ans; 	squarer(poly, ans); 	int m; 	scanf("%d", &m); 	int fans=0; 	while(m--) 	{ 		scanf("%d", &x); 		if(ans[x]) 			fans++; 	} 	printf("%d\n", fans); 	return 0; }
#include<stdio.h> #define s(x) scanf("%lld",&x) #define M 1000000007 typedef long long int ll; ll f(ll a,ll b,ll c) {  ll ans=1 ;                              while(b !=0 ) {                  if(b%2 == 1) {                           ans = ans*a ;                ans = ans%c;                  }    a = a*a;                     a %= c;                       b /= 2;                 } return ans; } int main() { 	ll t; 	s(t); 	while(t--) 	{ 		ll z,n;  		s(n); 		z=f(2,n,M); 		//if(z>0) 		printf("%lld\n",z-1); 		//else 	} 	return 0; }
#include<bits/stdc++.h> using namespace std;  vector<int> a[100005]; bool visited[100005]; int vertices;  void DfsInit() { 	for(int i=1;i<=vertices;i++) 	{ 		a[i].clear(); 		visited[i]=false; 	}	 } void addEdge(int v,int val) { 	a[v].push_back(val); 	a[val].push_back(v); }  int DFS(int v) { 	visited[v]=true; 	int s=1; 	 	for(int i=0;i<a[v].size();i++) 	{ 		if(!visited[a[v][i]]) 		{ 			s+=DFS(a[v][i]); 		} 	} 	return s; }  int main() { 	int t,n,k,x,y; 	cin>>t; 	while(t--) 	{ 		int ans=0; 		cin>>n; 		cin>>k; 		vertices = n; 		DfsInit(); 		for(int i=0;i<k;i++) 		{ 			cin>>x; 			cin>>y; 			addEdge(x,y); 		} 		for(int i=1;i<=n;i++) 		{ 			if(!visited[i]) 			{ 				if(!(DFS(i)&1)) 				ans++; 			} 		} 		cout<<ans<<endl; 	} 	return 0; } 
#include<stdio.h> #define s(x) scanf("%lld",&x) #define M 1000000007 typedef long long int ll; ll f(ll a,ll b,ll c) {  ll ans=1 ;                              while(b !=0 ) {                  if(b%2 == 1) {                           ans = ans*a ;                ans = ans%c;                  }    a = a*a;                     a %= c;                       b /= 2;                 } return ans; } int main() { 	//ll t; 	//s(t); 	ll a,b,c; 	s(a);s(b);s(c); 	while((a!=-1)||(b!=-1)||(c!=-1)) 	{ 		ll z;  		 		if(b==0&&c==0) 		z=0; 		else 		{ 		   z=f(b,c,M-1); 		} 		if(a==0&&z==0) 		z=0; 		else      	{ 		z=f(a,z,M);} 		//if(z>0) 		printf("%lld\n",z); 		//else 		s(a);s(b);s(c); 	} 	return 0; }
#include <bits/stdc++.h> using namespace std; const int N = 1e5 + 5; vector < int > tree[N]; set < int > dist[N]; int a[N]; int ptr[N]; int n , m , u , v; void UNION(set < int > & s1 , set < int > & s2){     for(set < int > :: iterator it = s1.begin(); it != s1.end(); ++it) s2.insert(*it); } long long cut = 0; void dfs(int node , int parent){     dist[node].insert(a[node]);     int pt = node;     for(int i = 0; i < tree[node].size(); ++i){         int child  = tree[node][i];         if(child != parent){             dfs(child , node);         if(dist[pt].size() >= dist[ptr[child]].size()){            UNION(dist[ptr[child]] , dist[pt]);         }else{             UNION(dist[pt] , dist[ptr[child]]);             pt = ptr[child];         }         }     }     ptr[node] = pt;     cut += dist[pt].size(); } long long get(int node , int par){     long long ret = dist[ptr[node]].size();     for(int i = 0; i < tree[node].size(); ++i){         if(tree[node][i] != par){             ret += get(tree[node][i] , node);         }     }    // cout << "Subarray rooted at : " << node << " = " << ret << endl;     return ret; } int main() {     ios_base :: sync_with_stdio(false);     cin.tie(NULL);     cin >> n >> m;     for(int i = 1; i <= n - 1; ++i){         cin >> u;         tree[u].push_back(i + 1);     }     for(int i = 1; i <= n; ++i) cin >> a[i];     dfs(1 , -1);     long long ans = get(1 , -1);     cout << cut << endl;     return 0; } 
#include<bits/stdc++.h> #define FOR(i,a,n) for(int i=a;i<n;i++) #define si(x) scanf("%d",&x) #define sll(x) scanf("%lld",&x) #define ss(x) scanf("%s",x) #define pi(x) printf("%d\n",x) #define pll(x) printf("%lld\n",x) #define ps(x) printf("%s\n",ch) #define all(x) (x).begin(),(x).end() #define M 1000000007 #define ll long long #define mp make_pair #define pb push_back #define fr first #define se second using namespace std; int block,cnt[1000069],arr[200069],n,m,k; ll ans[200069],tot=0; bool cmp(pair<int,pair<int,int> > l,pair<int,pair<int,int> > r) {     if(l.fr/block==r.fr/block)         return l.se.fr<r.se.fr;     return l.fr<r.fr; } void add(int x) {     tot+=(1LL*2*cnt[arr[x]]+1)*arr[x];     cnt[arr[x]]++;     //tot+=1LL*cnt[arr[x]]*cnt[arr[x]]*arr[x];    // cout<<arr[x]<<"add"<<cnt[arr[x]]<<"\n"; } void del(int x) {     tot-=(1LL*2*cnt[arr[x]]-1)*arr[x];     cnt[arr[x]]--;     //tot+=1LL*cnt[arr[x]]*cnt[arr[x]]*arr[x];     //cout<<arr[x]<<"del"<<cnt[arr[x]]<<"\n"; } int main() {     si(n),si(m);     FOR(i,1,n+1)         si(arr[i]);     block=569;     vector<pair<int,pair<int,int> > > q;     FOR(i,0,m)     {         int x,y;         si(x),si(y);         q.pb(mp(x,mp(y,i)));     }     sort(all(q),cmp);     int mor=0,mol=1;     FOR(i,0,q.size())     {         int ql=q[i].fr;         int qr=q[i].se.fr;         int in=q[i].se.se;         while(ql<mol)             add(--mol);         while(ql>mol)             del(mol++);         while(qr>mor)             add(++mor);         while(qr<mor)             del(mor--);       //  puts("");         ans[in]=tot;     }     FOR(i,0,q.size())         pll(ans[i]); 	return 0; } 
#include <iostream> #include <bits/stdc++.h> using namespace std;  int main() {     long long int t,i,a,b,c,k;     float ans;     scanf("%lld",&t);     for(i=1;i<=t;i++){         scanf("%lld%lld%lld%lld",&a,&b,&c,&k);         if(c>=k)           printf("0\n");         else {             c=c-k;             ans=ceil((-b+sqrt((b*b)-(4*a*c)))/(2*a));             printf("%.0f\n",ans);         }       } 	// your code goes here 	return 0; } 
#include <bits/stdc++.h> #define ll long long using namespace std; ll fact[12]; int main() {     int t;     fact[0]=1;     for(int i=1;i<=11;i++)         fact[i]=i*fact[i-1];     scanf("%d",&t);     while(t--){         char s[15];         scanf("%s",s);         int c=0;         int l=strlen(s);         for(int i=0;i<l;i++)             if(s[i]>='a' && s[i]<='z')                 c++;         printf("%lld\n",fact[c]);     }     return 0; } 
#include <bits/stdc++.h>  using namespace std; int main() {     int t;     scanf("%d",&t);     while(t--){         int n,m;         scanf("%d%d",&n,&m);         if(m<n){             printf("%d\n",n-m);         }         else{             int c=0;             while(m>n){                 if(m%2==1){                     c++;                     m++;                 }                 m/=2;                 c++;             }             printf("%d\n",c+n-m);         }     }     return 0; } 
#include <bits/stdc++.h>  using namespace std; int dp[1001][1001]; int arr[1005]; int n; int solve(int l,int r) {     if(l>r)         return 0;     if(dp[l][r]!=-1) return dp[l][r];     int ans1=0,ans2=0;     if(r-1>=0 && arr[l]<arr[r-1])          ans1=solve(l,r-2)+arr[r];     else ans1=solve(l+1,r-1)+arr[r];     if(l+1 < n && arr[l+1]>arr[r])             ans2=solve(l+2,r)+arr[l];     else ans2=solve(l+1,r-1)+arr[l];     return dp[l][r]=max(ans1,ans2); } int main() {     int t;     scanf("%d",&t);     while(t--){         memset(dp,-1,sizeof(dp));         int i;         scanf("%d",&n);         int sum=0;         for(i=0;i<n;i++){             scanf("%d",&arr[i]);             sum+=arr[i];         }         int ans=solve(0,n-1);         //cout<<ans<<"  "<<sum<<endl;         int diff=ans-(sum-ans);         if(diff>=0)             printf("1 %d\n",diff);         else printf("2 %d\n",-diff);     }     return 0; } 
#include<bits/stdc++.h> using namespace std; int main() { long long int t; cin>>t; while(t--) { long long int i,n,k; cin>>n>>k; int a[n],sum=0; for(i=0;i<n;i++) { cin>>a[i]; } sort(a,a+n); int count=0; for(i=n-1;i>=0;i--) {     count++; if(count>=k+1) sum+=a[i]; } cout<<sum<<endl; } return 0; }
#include <bits/stdc++.h> using namespace std; //MACROS #define ui unsigned int #define ll long long #define ull unsigned ll #define ld long double #define db double #define pb push_back #define mp make_pair #define pii pair<int,int> #define pll pair<ll , ll> #define pil pair<int,ll> #define F first #define S second #define ff first #define ss second #define vi vector<int> #define vii vector< pii > #define vll vector< ll > #define mii map<int,int> #define mll map<ll,ll> #define mil map<int,ll> #define mli map<ll,int> #define si set<int> #define sll set<ll> #define vvi vector< vi > #define vvl vector< vll > #define vpll vector< pll > #define mod 1000000007 const int maxn = 1e5+100; int tot[maxn]; vi divisors[maxn]; int factor[maxn]; int fib[maxn]; void pre() { 	fib[0] = 0; 	fib[1]=1; 	for(int i = 2;i<maxn;i++) 	{ 		fib[i]=fib[i-1]+fib[i-2]; 		if(fib[i]>=mod) 			fib[i]-=mod; 	} 	memset(factor,0,sizeof factor); 	for(int i = 2;i*i<maxn;i++) 	{ 		if(!factor[i]) 		{ 			for(int j = i*i;j<maxn;j+=i) 			{ 				factor[j] = i; 			} 		} 	} 	for(int i = 1;i<maxn;i++) 	{ 		for(int j = i;j<maxn;j+=i) 		{ 			divisors[j].pb(i); 		} 	} 	tot[1]=1; 	for(int i = 2;i<maxn;i++) 	{ 		if(factor[i] == 0) 		{ 			tot[i] = i-1; 			continue; 		} 		int x = factor[i],y = i/x; 		if(y%x == 0) 		{ 			tot[i] = x*tot[y]; 		} 		else 		{ 			tot[i] = (x-1)*tot[y]; 		}  	} } int ans(int n) { 	n++; 	int ret = mod-1; 	for(int i = 0;i<divisors[n].size();i++) 	{ 		int d = divisors[n][i]; 		int num = tot[n/d]; 		ret += (num*1ll*fib[d])%mod; 		if(ret>=mod) 			ret-=mod; 	} 	return ret; } int main() { 	pre(); 	int t,n; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d",&n); 		printf("%d\n",ans(n)); 	} 	return 0; } 
#include<iostream> #include<limits.h> using namespace std; int main() { 	long long int i,j,k,t,n,q; 	long long int a[100000]; 	cin>>n>>q; 	long long int min=INT_MAX,max=INT_MIN; 	for(i=0;i<n;i++) 	{ 		cin>>a[i]; 		if(a[i]>max) 			max=a[i]; 		if(a[i]<min) 			min=a[i]; 	} 	for(i=0;i<q;i++) 	{ 		cin>>t; 		if((t<=max)&&(t>=min)) 			cout<<"Yes"<<endl; 		else 			cout<<"No"<<endl; 	}  }
/* theCodeGame */ //{{{ #include<iostream> #include<algorithm> #include<cmath> #include<climits> #include<vector> #include<list> #include<stack> #include<queue> #include<deque> #include<stack> #include<bitset> #include<set> #include<cstdlib> #include<cstdio> #include<cstring> #include<ctime> #include<map> #include<functional> #include<numeric> #include<utility> #include<sstream> #include<iomanip> #include<cctype> //#undef thecodegame #ifdef thecodegame     #include<debug.h> #else     #define DBG_ARR(a,b,c) {}     #define DBG_MAT(a,s,b,c) {}     #define DBG_VECT(a) {}     #define db(...) {}     #define dbt(x, ...) {} #endif  using namespace std;  #define assert(f) {if(!(f)){fprintf(stderr,"Line-->%d  Assertion failed: %s \n",__LINE__,#f);exit(1);}} #define MOD 	 1000000007LL #define LL 		 long long #define ULL      unsigned long long #define ABS(x)   ((x)<0?-(x):(x)) #define SQR(x) 	 ((x)*(x)) #define CUBE(x)  ((x)*(x)*(x)) #define SD(n)    scanf("%d",&n) #define SD2(n,m) scanf("%d %d",&n,&m) #define SLL(n)   scanf("%LLd",&n) #define SLU(n)   scanf("%LLu",&n) #define SS(n)    scanf("%s",n) #define pnl      printf("\n") #define REP(i,n)        for(__typeof(n) i=0;i<(n);i++) #define FOR(i,a,b)      for(__typeof(b) i=(a);i<(b);++i) #define FORE(i,a,b)     for(__typeof(b) i=(a);i<=(b);++i) #define FORD(i,a,b,d)   for(__typeof(b) i=(a);i<(b);i+=(d)) #define FORR(i,n,e)     for(__typeof(n) i=(n);i>=(e);--i) #define FORRD(i,n,e,d)  for(__typeof(n) i=(n);i>=(e);i-=(d)) #define REP_IT(it,m)    for(it=m.begin();it!=m.end();it++) #define FORI(it,s) 	    for(__typeof((s).begin()) (it)=(s).begin();(it)!=(s).end();(it)++) #define FOREACH(it, X)  for(__typeof((X).begin()) it = (X).begin(); it != (X).end(); ++it) #define UNIQUE(v)       sort(ALL(v)),v.erase(unique(ALL(v)),v.end()) #define FILL(a,b)       memset(a,b,sizeof(a)) #define ALL(v)          (v).begin(), (v).end() #define RALL(v)         (v).rbegin(), (v).rend() #define checkbit(n,b)    ( ((n) >> (b)) & 1) #define pb push_back #define mp make_pair #define XX first #define YY second  const double PI=acos(-1.0); const double EPS=1e-11; template<typename T>inline T mod(T N,T M){return (N%M+M)%M;} template<typename T>inline void checkmin(T &a,T b){if(b<a)a=b;} template<typename T>inline void checkmax(T &a,T b){if(b>a)a=b;} class minHeap{public:bool operator()(int& c1,int& c2){return c1>c2;}}; class maxHeap{public:bool operator()(int& c1,int& c2){return c1<c2;}}; #ifdef amy     #define getcx getchar #else     #define getcx getchar_unlocked #endif inline void inp(int &n){     n=0;int ch=getcx();int sign=1;     while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}     while(  ch >= '0' && ch <= '9' ){n = (n<<3)+(n<<1) + ch-'0', ch=getcx();}     n=n*sign; }  //}}} #define SIZE 20 #define MAXX 100000009  vector<int>v; vector<int> ::iterator it; int N; void precompute(){     for(int i=0;i<=6;i++){         for(int j=0;j<(1<<6);j++){             int x = j;             int cnum =0;             for(int k=0;k<i;k++){                 cnum*= 10;                 cnum += ((x&1)*2+1);                 x >>=1;             }             v.pb(cnum);             db(cnum);         }     }     UNIQUE(v); }//end precompute  void doThis(int cc){     SD(N);     it = upper_bound(v.begin(),v.end(),N+1);     it --;     cout<<*it<<endl;  }//end solve  int main(){ #ifdef amy 	freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\out.txt","w",stderr); #endif precompute(); int cases = 1; scanf("%d",&cases); FORE(i,1,cases){doThis(i);} #ifdef amy 	fprintf(stdout,"\nTIME: %.3lf sec\n",(double)clock()/(CLOCKS_PER_SEC)); #endif return 0; }//end main 
# include <iostream> # include <stdio.h> # include <stack> # include <queue> # include <vector> # include <algorithm> # include <climits> using namespace std;  # define rep(n) for (int i = 0; i < n; i++) typedef unsigned long long ll; typedef long l; typedef vector<int> vi; typedef vector <vi > vvi; typedef pair<int,int> Pi;  # define S(x) scanf ("%d", &x) # define Sl(x) scanf ("%ld", &x) # define Sll(x) scanf ("%lld", &x)  # define  pb push_back # define all(X) X.begin(), X.end()  ll ar[10000003]; ll finalans; ll finalpos; int main () { 	//ios_base::sync_with_stdio(false); 	ll t; 	ll n; 	ll temp = 0; 	cin >> t; 	while (t--) { 		ll ans = 0; 		finalans = ULLONG_MAX; 		finalpos = -1; 		cin >> n;  		for (ll i = 1; i <= n; i++) { 			cin >> ar[i]; 			ans = ans ^ ar[i]; 		} 		if (ans != 0 ) { 		for (ll i = 1; i <= n; i++) { 			if ((ans ^ ar[i]) < ar[i]) { 				finalans = min (ar[i] - (ans ^ ar[i]), finalans); 				finalpos = i; 			} 		} 		} 		 		if (ans == 0) 			cout <<"NO\n"; 		else 			cout <<"YES"<<" "<<finalpos << " " << finalans <<"\n"; 	} 	return 0;  } 		 
// RANBOT // 4N+1 // 4N+3 FOR A NUMBER TO BE REPREESENT AS SUM OF TWO NUMBERS IT SHUD IN THE FORM OF EVEN POWER OF (4N+3) PRIMES #include<iostream> #include<vector> #include<set> #include<map> #include<queue> #include<stack> #include<string> #include<algorithm> #include<functional> #include<iomanip> #include<cstdio> #include<cmath> #include<limits.h> #include<cstring> #include<cstdlib> #include<cfloat> #include<cassert> #define maxm(a,b) a>b?a:b; #define minm(a,b) a<b?a:b; using namespace std; //M lazy ;) typedef long long ll; typedef vector <int> vi; typedef pair< int ,int > pii; typedef istringstream iss; typedef ostringstream oss; typedef map<int,int> mp; #define pb push_back #define mp make_pair #define ff first #define ss second #define sz size() #define ln length() #define rep(i,n) for(int i=0;i<n;i++) #define fu(i,a,n) for(int i=a;i<=n;i++) #define fd(i,n,a) for(int i=n;i>=a;i--) #define all(a)  a.begin(),a.end() #define ESP (1e-9) #define gi(n) scanf("%d",&n) #define gl(n) cin >> n #define pi(n) printf("%d",n) #define pl(n) cout << n #define ps printf(" ") #define pn printf("\n") #define dg(n,s); printf("%s %d",s,n) #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min() #define traverse_map(a,b) for(mp::iterator it=a;it!=b;++it) #define MOD 1000000007 #define MAX 1000001 #define cases() int t; cin>>t; while(t--) // fast input function #define getcx getchar_unlocked // fast input function #ifdef ONLINE_JUDGE  inline void inp( int &n )  {     n=0;     int ch=getcx();int sign=1;     while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )             n = (n<<3)+(n<<1) + ch-'0', ch=getcx();     n=n*sign;   } #else inline void inp(int &n){  cin>>n; } #endif int Check(ll num){  ll k=num;  if(num==1)  return 0;   for(ll i=2;i<=sqrt(num);i++){ 		if(k%i==0) 		 return 0;  }   if(num%4==3)  return 0;   return 1; } int main(){  int t;  inp(t);  ll a,b,i;  while(t--){   cin>>a>>b;    ll count=0;    for(i=a;i<=b;i++)    if(Check(i)) 	count++; 	 	cout<<count<<endl;  }  return 0; } 
#include <bits/stdc++.h> #define f(i,x,y) for (int i = x; i < y; i++) #define fd(i,x,y) for(int i = x; i>= y; i--) #define FOR(it,A) for(typeof A.begin() it = A.begin(); it!=A.end(); it++) #define all(v) (v).begin(), (v).end() #define rall(v) (v).rbegin(), (v).rend() #define vint vector<int> #define ll long long #define clr(A,x) memset(A, x, sizeof A) #define pb push_back #define pii pair<int,int> #define fst first #define snd second #define ones(x) __builtin_popcount(x) #define cua(x) (x)*(x) #define eps (1e-9) #define oo (1<<30) #define debug(x) cout <<#x << " = " << x << endl #define adebug(x,n) cout <<#x<<endl; f(i,0,n)cout<<x[i]<<char(i+1==n?10:32) #define mdebug(x,m,n) cout <<#x<<endl; f(i,0,m)f(j,0,n)cout<<x[i][j]<<char(j+1==n?10:32) #define N 105 using namespace std;  int shift(int *s,int n){ 	int i = 0, j = 1, k = 0; 	int a,b; 	while( j<n && i+k+1<n ){ 		a = s[i+k]; b = s[(j+k)%n]; 		if( a==b ) k++; 		else if( a<b ) j=j+k+1, k = 0; 		else i = max(i+k+1,j), j = i+1, k = 0; 	} 	return i; } void unif(int *s, int n) { 	int i = shift(s, n); 	int t[n]; 	f(j,0,n) { 		t[j] = s[i]; 		i++; 		if (i == n) i = 0; 	} 	f(j,0,n) s[j] = t[j]; } int s[N], n; int r[N]; bool orden(int i, int j) { 	int tmp = s[i] - s[j]; 	if (tmp) return tmp < 0; 	return i < j; } void mapear(int t[N]) { 	f(i,0,n) r[i] = i; 	sort(r, r + n, orden); 	for (int i = 0, j = 0; i < n; i = j) { 		for (; j < n && s[r[i]] == s[r[j]]; j++) ; 		f(k,i,j) t[r[k]] = k+1==j? n + r[i] - r[k] : r[k+1] - r[k]; 	} } int lista[10005][N];  int main(){ 	int tc, m; 	cin >> tc;	 	while (tc--) { 		cin >> m >> n; 		f(i,0,m) { 			f(j,0,n) scanf("%d", s + j); 			mapear(lista[i]); 			unif(lista[i], n); 		} 		vector<pair<ll, ll> > v; 		ll m1 = 1e9+7, m2 = m1 + 2; 		f(i,0,m) { 			ll h1 = 0, h2 = 0; 			f(j,0,n) h1 = (101*h1 + lista[i][j]) % m1; 			f(j,0,n) h2 = (101*h2 + lista[i][j]) % m2; 			v.pb(pii(h1, h2)); 		} 		sort(all(v)); 		cout << unique(all(v)) - v.begin() << endl; 	} }  
#include<iostream> #include<bits/stdc++.h> #include<stdio.h> #include<string>  #define lld long long int #define d int using namespace std;  void display(lld res) {      while(res>9)         res=res%10;     switch(res)                 {                     case 1:  cout<<"one ";                     break;                     case 2:  cout<<"two ";                     break;                     case 3:  cout<<"three ";                     break;                     case 4:  cout<<"four ";                     break;                     case 5:  cout<<"five ";                     break;                     case 6:  cout<<"six ";                     break;                     case 7:  cout<<"seven ";                     break;                     case 8:  cout<<"eight ";                     break;                     case 9:  cout<<"nine ";                     break;                     case 0:  cout<<"zero ";                     break;                 } } int main() {     lld t,num1,num2,temp1,i,jtemp2,res;     char ch;     lld n1[10000];     lld n2[10000];     cin>>t;     while(t--)     {             cin>>num1>>num2>>ch;             lld i=0;             lld j=0,x;             while(num1!=0)             {                 n1[i]=num1%10;                 i++;                 num1/=10;             }          //   for(x=0; x<i; x++)          //       cout<<n1[x];             while(num2!=0)             {                 n2[j]=num2%10;                 j++;                 num2/=10;             }         //    for(x=0; x<j; x++)         //        cout<<n2[x];             if(ch=='+')             {                 for(i=j-1; i>=0; i--)                 {                     res=n1[i]+n2[i];                     display(res%10);                 }             }             else             {                  for(i=j-1; i>=0; i--)                 {                     res=n1[i]*n2[i];                     display(res%10);                 }             }             cout<<endl;     }     return 0; } 
#include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<string> #include<iostream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath> #include<string>   using namespace std;   #define s(n)					scanf("%d",&n) #define sl(n) 					scanf("%lld",&n) #define sf(n) 					scanf("%lf",&n) #define ss(n) 					scanf("%s",n) #define INF						(int)1e9 #define LINF					(long long)1e18 #define EPS						1e-9 #define maX(a,b)				((a)>(b)?(a):(b)) #define miN(a,b)				((a)<(b)?(a):(b)) #define abS(x)					((x)<0?-(x):(x)) #define FOR(i,a,b)				for(int i=a;i<b;i++) #define REP(i,n)				FOR(i,0,n) #define foreach(v,c)            for( typeof((c).begin()) v = (c).begin();  v != (c).end(); ++v) #define mp						make_pair #define FF						first #define SS						second #define tri(a,b,c)				mp(a,mp(b,c)) #define XX						first #define YY						second.first #define ZZ						second.second #define pb						push_back #define fill(a,v) 				memset(a,v,sizeof a) #define all(x)					x.begin(),x.end() #define SZ(v)					((int)(v.size())) #define DREP(a)					sort(all(a)); a.erase(unique(all(a)),a.end()) #define INDEX(arr,ind)			(lower_bound(all(arr),ind)-arr.begin()) #define debug(args...)			{dbg,args; cerr<<endl;} #define dline					cerr<<endl	 #define MOD                     23102009     typedef long long LL; typedef pair<int,int> PII; typedef pair<LL,LL> PLL; typedef pair<int,PII> TRI;   typedef vector<int> VI; typedef vector<LL> VL; typedef vector<PII> VII; typedef vector<PLL> VLL; typedef vector<TRI> VT;   typedef vector<VI> VVI; typedef vector<VL> VVL; typedef vector<VII> VVII; typedef vector<VLL> VVLL; typedef vector<VT> VVT;     /*Main code begins now */   int testnum; VL nums;   int cnt; int l,a,x;     void preprocess() { 	 } int calx(int n) { int u=0,x1=1,i; while(n){u++;n=n/10;} for(i=1;i<u;++i)x1=x1*10;  return x1;     }  void countdig(int n) {int x=0; while(n) { x++; n=n/10;   }    l=x;   } int lr(int n,int l) {     int x1=x;     int u,v,num=-1,i;     while(l--&&n)     {     u=n/x1;     v=n%x1;     n=v*10+u;  //   printf("lr---n=%d\n",n);     if(n>=num)     num=n;     if(n<x1)     x1=calx(n);     }     return num; } int rr(int n,int l) {    int u,v,num=-1,i;    int x1=x;     while(l--&&n)     {     u=n/10;     v=n%10;     n=v*x1+u;  //   printf("rr---n=%d\n",n);     if(n>=num)     num=n;     if(n<x1)     x1=calx(n);     }     return num;  } void solve() {         int p,q,r,s,u,v,x1,x2;     p=lr(a,l);     q=rr(a,l);          if(q>p)     p=q;          r=a;     s=a;     x1=x;     x2=x;     if(p<a)     {     u=r/x1;     v=r%x1;     r=v*10+u;     x1=calx(r);     u=r/10;     v=r%10;     r=v*x1+u;               u=s/10;     v=s%10;     s=v*x2+u;     x2=calx(s);        u=s/x2;        v=s%x2;        s=v*10+u;               //  printf("r=%d s=%d\n",r,s);     r=max(r,s);     p=max(p,r);            }     printf("%d\n",p); //    printf("%d %d\n",ans1,ans2);	 }       bool input() {      s(a);      x=1;      x=calx(a);      int i;      countdig(a);    //   for(i=1;i<l;++i)x=x*10; 	return true; }     int main() { 	preprocess(); 	int T=1;s(T); 	for(testnum=1;testnum<=T;testnum++) 	{ 		if(!input()) break; 		solve(); 	} return 0; }   
#include<iostream> using namespace std; #define mod 1000000007 #include<bits/stdc++.h> int visited[1000000]; list<int> li[10000000];   char arr[1000000+100];       int dfs(int start)  {    	  	stack<int> s;  	int c=0;  	s.push(start);  	char fill=arr[start];  	while(! s.empty())  	 {  	 	 int start=s.top();  	 	 if(arr[start]!='?') 		    { 		    	 c=1; 		   			 }  	 	 s.pop();  	 	   	 	 list<int>:: iterator it;  	 	   	 	 for(it=li[start].begin();it!=li[start].end();it++)   	 	  {  	 	  	   	 	   if(!visited[*it])  	 	  	  {  	 	  	  	visited[*it]=1;  	 	  	  	if(fill=='?') fill=arr[*it];  	 	  	  	else if(arr[*it]!='?' && fill!=arr[*it]) return -1;  	 	  	  	s.push(*it); 				  }            			} 	  }  	  return c;  }       int main()  {  	  int n,m;  	   cin>>n>>m;        vector<pair<int,int> >v;  	    cin>>arr;  	    int q;  	     cin>>q;  	     int c=0;  	     int f=0;  	     for(int i=0;i<q;i++)  	      {  	      	int a,b;  	      	 cin>>a>>b;  	      	 a-=1;  	      	 b-=1;  	      	 li[a].push_back(b);  	      	 	 li[b].push_back(a);  	      	 	   	      	  if(arr[a]=='?' && arr[b]!='?') arr[a]=arr[b];  	      	 else if(arr[b]=='?' && arr[a]!='?') arr[b]=arr[a];  	      	 else if(arr[a]!=arr[b] && arr[a]!='?')  	      	  {  	      	  	f=1; 				 } 	 		 				  	} 	   	   	   	long long int  ans=1; 	 	 for(int i=0;i<n;i++) 	 { 	 	if(!visited[i]) 	 	 { 	 	 	visited[i]=1; 	 	 int j=	dfs(i); 	 	 if(j==0) 	 	  { 	 	  	ans=(ans*m)%mod; 		   } 		   else if(j==-1) 		    { 		    	 f=1; 		    	 break; 			} 		  } 	 }  	if(f==1) 	{ 		 cout<<"-1"<<endl;  	      	  	  exit(0); 	}  	  		 cout<<ans<<endl;  }
#include<iostream> #include<vector> using namespace std; int main() { int t;             cin>>t;             while(t--)             {                 int n;                 cin>>n;                 int a[n];                 vector<int>b;                 for(int i=0;i<n;i++)                 {                      cin>>a[i];                 }                 int j=0;                 for(int i=0;i<n-1;)                 {                     char s;                     cin>>s;                     if(s=='a')                     {                         a[i+1]=a[i]+a[i+1];                         a[i]=1;                         i++;                     }                     else i++;                 }                 long long int res=1;                 for(int i=0;i<n;i++)                 {                     res=(res*a[i])%1000000007;                 }                 cout<<res<<"\n";              } } 
#include<iostream> #include<bits/stdc++.h> #include<math.h> using namespace std; int main() { 	int t; 	cin>>t; 	while(t--)    {    		long long int n;    		cin>>n;    		if(n%9==0)    		{    		   cout<<"0\n"; 		} 		   else 		   { 		   	long long int y=n/9; 		   	long long int a,b; 		   	a=abs(y*9-n); 		   	if(n>=0) 		   	b=abs((y+1)*9-n); 		   	else 		   	b=abs((y-1)*9-n); 		   	if(a<b) 		   	cout<<a<<"\n"; 		   	else 		   	cout<<b<<"\n"; 		   	 		   }    } }
#include <iostream> #include <vector> using namespace std;  vector<long long int> v;  void init() { 	long long int k;  	for(int i = 1; i < 250000; i++) 	{  		v.push_back(k); 		k += i*i; 	} }  int main() { 	int t,val; 	cin >> t; 	init(); 	for(int i = 0; i < t; i++) 	{ 		cin >> val; 		cout << v[val] << endl; 	} 	return 0; }
#include<cstdio> main() {     int test_cases;     scanf("%d",&test_cases);     for(int k=0;k<test_cases;k++)     {     	int a1,a2,a3,a4,ways,runs;         scanf("%d",&runs);         ways=0;         for(a1=runs;a1>=0;a1-=6)         {             for(a2=a1;a2>=0;a2-=4)             {                 for(a3=a2;a3>=0;a3-=2)                 {                     ways++;                 }             }         }           printf("%d\n",ways);     }   return 0; } 
#include<bits/stdc++.h> #include<iostream> using namespace std;  int main() {    long long int t,k,m,n,a[100000],j=0,i;     cin>>t;     while(t--)    {       j=0;     cin>>n>>m>>k;     int maxi=m;     for(i=0;i<n;i++)     {        maxi=m;        cin>>a[i];         while(maxi>0 && a[i]>=k)        {           a[i]=a[i]-k;           maxi--;        }         j=j+a[i];      }     cout<<(j%1000000007)<<"\n";    }  return 0; } 
#include<bits/stdc++.h> using namespace std; #define MOD 1000000007 #define LL unsigned long long  void MUL(LL F[2][2], LL M[2][2]);   void BP(LL F[2][2],LL n);  LL Solve(LL n) {   LL F[2][2] = {{1,1},{1,0}};   if (n == 0)       return 0;   BP(F, n-1);   return F[0][0]; }  void MUL(LL F[2][2], LL M[2][2]) {   LL x =  F[0][0]*M[0][0] + F[0][1]*M[1][0];   LL y =  F[0][0]*M[0][1] + F[0][1]*M[1][1];   LL z =  F[1][0]*M[0][0] + F[1][1]*M[1][0];   LL w =  F[1][0]*M[0][1] + F[1][1]*M[1][1];    F[0][0] = x%MOD;   F[0][1] = y%MOD;   F[1][0] = z%MOD;   F[1][1] = w%MOD; }  void BP(LL F[2][2], LL n) {   if( n == 0 || n == 1)       return;   LL M[2][2] = {{1,1},{1,0}};     BP(F, n/2);   MUL(F, F);     if (n%2 != 0)      MUL(F, M); }  int main() {     long T;     LL N;     scanf("%ld",&T);     while(T--)     {         scanf("%llu",&N);         printf("%llu\n",Solve(N));     }     return 0; } 
#include<bits/stdc++.h> using namespace std; int main() {     string s;     cin>>s;     int i=0,l=0,o=0,v=0,e=0,y=0,u=0;     int n=s.length();     for(int j=0;j<n;j++)     {         if(s[j]=='i')             i++;         else if(s[j]=='l')             l++;         else if(s[j]=='o')             o++;         else if(s[j]=='v')             v++;         else if(s[j]=='e')             e++;         else if(s[j]=='y')             y++;         else if(s[j]=='u')             u++;     }     if(i>=1&&l>=1&&o>=2&&v>=1&&e>=1&&y>=1&&u>=1)         cout<<"happy\n";     else         cout<<"sad\n"; } 
// @Author - Mayank Kataria (AMDOCS) !  #pragma warning(disable:4786) #pragma comment(linker, "/STACK:266777216")  #include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<set> #include<map> #include<functional> #include<string> #include<cstring> #include<cstdlib> #include<queue> #include<utility> #include<fstream> #include<sstream> #include<cmath> #include<stack> #include<cstdio> #include<ctime> #include<cassert>   using namespace std;  //Macros   #define FOR(i,a,b)    for(int i=a;i<b;i++) #define FORL(i,a,b)   for(LL i=a;i<b;i++) #define PB            push_back #define mp            make_pair #define X 		      first #define Y 		      second #define len			  size() #define s(n)          scanf("%d",&n); #define slld(n)       scanf("%lld",&n); #define sf(n)         scanf("%lf",&n); #define ss(n)         scanf("%s",n); #define INF           (int)1e9 #define EPS           1e-9 #define maX(a,b)      (a>b?a:b) #define miN(a,b)      (a<b?a:b) #define MEM(a,b)      memset(a,(b),sizeof(a))  //memset(arr,0,sizeof(arr)) #define istr(S)       istringstream sin(S) #define MOD           1000000007				    typedef vector<int> VI;      //1d integer VECTOR typedef vector<VI> VVI;      //2d integer VECTOR typedef pair<int,int> PII;   //pair typedef vector<PII> VPII;    //VECTOR of pairs typedef vector<string> VS;   //VECTOR of strings typedef vector<double> VD;   //1d double VECTOR  typedef long long LL; typedef long long int LLI; typedef unsigned long long ULL;   int main() { 	int T,N; 	 	scanf("%d",&T); 	 	while(T--) 	{ 		scanf("%d",&N); 		int ans = sqrt(N); 		printf("%d\n",ans); 	}	  return 0; }  
#include<cstdio> #include<iostream> #include<algorithm> using namespace std; typedef struct {     long long int val;     int in; }ad; bool cc(ad a,ad b) {     return(a.val>b.val); } int main() {     int t,n,i;     scanf("%d",&t);      while(t--)     {          scanf("%d",&n);          long long int b[n],d[n];          ad c[n];          for(i=0;i<n;i++)             {                 scanf("%lld",&c[i].val);                 c[i].in=i;             }          for(i=0;i<n;i++)             {                 scanf("%lld",&b[i]);                 d[i]=b[i];             }          sort(c,c+n,cc);          sort(d,d+n);          for(i=0;i<n;i++)             {                 if(d[i]!=b[c[i].in])                     break;             }          if(i==n)             printf("YES\n");          else             printf("NO\n");       } } 
#include <stdio.h> #include <memory.h> #include <vector> using namespace std; char b[41][41]; vector<int> con[1000]; int mx[1000]; bool vis[1000]; int x[41][41]; bool bpm(int v){ 	for(int i=0; i<con[v].size(); i++){ 		int j=con[v][i]; 		if(vis[j]) continue; 		vis[j]=1; 		if(mx[j]==-1 || bpm(mx[j])){ 			mx[j]=v; 			return 1; 		} 	} 	return 0; } int main(){     //freopen("in.txt", "r", stdin);     int T;     scanf("%d", &T);     int n, m, i, j;     while(T--){     	memset(b, 0, sizeof(b));     	for(i=0; i<1000; i++) con[i].clear();     	memset(x, -1, sizeof(x));         scanf("%d %d", &n, &m);         for(i=0; i<n; i++) scanf("%s", b[i]);         int cl=0;         for(i=0; i<n; i++){             for(j=0; j<m; j++){                 if(b[i][j]=='.'){ 					if(b[i][j+1]=='*') ++cl;                 }else{                 	x[i][j]=cl;                 }             }             ++cl;         }         int cm=0;         for(i=0; i<m; i++){             for(j=0; j<n; j++){                 if(b[j][i]=='.'){                 	if(b[j+1][i]=='*') ++cm;                 }else if(x[j][i]>=0){                 	con[cm].push_back(x[j][i]);                 }             }             ++cm;         }         memset(mx, -1, sizeof(mx));         int res=0;         for(i=0; i<cm; i++){         	memset(vis, 0, sizeof(vis));         	res+=bpm(i);         }         printf("%d\n", res);     } }
#include<bits/stdc++.h> using  namespace std; int main() {     int  t;     cin>>t;     while(t--) {         long int n;         cin>>n;         if(n%2==0) {             cout<<n<<endl;         }         else {             cout<<n-1<<endl;         }     }     return 0; } 
#include<bits/stdc++.h> using namespace std;  main(){      long long int a,b,p1,p2,ans,c;      while(1){         c=0;ans =0;         scanf("%lld %lld",&a,&b);         if(a==0&&b==0) break;          while(a||b){             p1=a%10;p2=b%10;             if(p1+p2+c>9) {c=(p1+p2+c)/10; ans++;}             a/=10;b/=10;         }         if(ans == 0) printf("No carry operation.\n");         else if(ans==1)  printf("1 carry operation.\n");         else printf("%lld carry operations.\n",ans);     }     } 
  #include<stdio.h>              int main()       {       printf("\n5\n13");       return 0;         }  
#include<cstdio> #include<cstdlib> #include<cmath> #include<cstring> #include<iostream> #include<algorithm>  using namespace std;  int main() {     for(int t = 1;;t++)     {             int n,m;             scanf("%d %d", &n, &m);             if(n==0 && m==0)                     break;             char arr[n][m+1];             for(int i = 0; i<n;i++)                 scanf("%s", &arr[i]);             if(t != 1)                  printf("\n");             printf("Field #%d:\n",t);             for(int i =0;i<n;i++)             {                     for(int j = 0;j<m;j++)                     {                             if(arr[i][j] == '*')                                 printf("*");                             else                             {                                 int cnt = 0;                                 if(i != 0)                                 {                                      if(arr[i-1][j] == '*')                                           cnt++;                                 }                                 if(i != n-1)                                 {                                      if(arr[i+1][j] == '*')                                           cnt++;                                 }                                 if(j != 0)                                 {                                      if(arr[i][j-1] == '*')                                           cnt++;                                 }                                 if(j != m-1)                                 {                                      if(arr[i][j+1] == '*')                                           cnt++;                                 }                                 if(i != 0 && j!=0)                                 {                                      if(arr[i-1][j-1] == '*')                                           cnt++;                                 }                                 if(i != 0 && j!=m-1)                                 {                                      if(arr[i-1][j+1] == '*')                                           cnt++;                                 }                                 if(i!=n-1 && j != 0)                                 {                                      if(arr[i+1][j-1] == '*')                                           cnt++;                                 }                                 if(i!=n-1 && j != m-1)                                 {                                      if(arr[i+1][j+1] == '*')                                           cnt++;                                 }                                                                  printf("%d",cnt);                             }                     }                     printf("\n");             }     } }              
#include<iostream> using namespace std; int main(){     int test;     cin>>test;     while(test--){                   int mat[6][6],ctr=0,i=0,j=0;                   for(i=0;i<6;i++){                   for(j=0;j<6;j++){                                   cin>>mat[i][j];                   }                   }                   for(i=0;i<6;i++){                   for(j=0;j<6;j++){                                    if(mat[i][j]==1){                                                     if(i==0 || i==5)                                                             ctr++;                                                     if(j==0 || j==5)                                                             ctr++;                                                     if(mat[i-1][j]==0)                                                                       ctr++;                                                     if(mat[i+1][j]==0)                                                                       ctr++;                                                     if(mat[i][j-1]==0)                                                                       ctr++;                                                     if(mat[i][j+1]==0)                                                                       ctr++;                                                     if(ctr==4){                                                                       cout<<"incorrect"<<endl;                                                                       ctr=-1;                                                                       break;                                                     }                                    }                                    }                                    if(ctr<0)                                             break;                   }                   if(ctr>0)                            cout<<"correct"<<endl;     }     return 0; } 
#include<iostream> using namespace std; int main(){     for(;;){             int m,n,i,j;             cin>>m>>n;             if(m==0 && n==0)                     break;             char ch[m][n];             for(i=0;i<m;i++){             for(j=0;j<n;j++){                              char c;                              cin>>c;                              ch[i][j]=tolower(c);             }             }             int test;             cin>>test;             while(test--){                           string str;                           cin>>str;                           int ctr=0;                           for(i=0;i<m;i++){                           for(j=0;j<n;j++){                                            if(ch[i][j]==tolower(str[0])){                                            if(ch[i][j-1]==tolower(str[1]) && ch[i][j-2]==tolower(str[2])){                                                                         ctr=-1;                                                                         cout<<i+1<<" "<<j+1<<endl;                                                                         break;                                            }                                            if(ch[i-1][j-1]==tolower(str[1]) && ch[i-2][j-2]==tolower(str[2])){                                                                         ctr=-1;                                                                         cout<<i+1<<" "<<j+1<<endl;                                                                         break;                                            }                                            if(ch[i-1][j]==tolower(str[1]) && ch[i-2][j]==tolower(str[2])){                                                                         ctr=-1;                                                                         cout<<i+1<<" "<<j+1<<endl;                                                                         break;                                            }                                            if(ch[i-1][j+1]==tolower(str[1]) && ch[i-2][j+2]==tolower(str[2])){                                                                         ctr=-1;                                                                         cout<<i+1<<" "<<j+1<<endl;                                                                         break;                                            }                                            if(ch[i][j+1]==tolower(str[1]) && ch[i][j+2]==tolower(str[2])){                                                                         ctr=-1;                                                                         cout<<i+1<<" "<<j+1<<endl;                                                                         break;                                            }                                            if(ch[i+1][j+1]==tolower(str[1]) && ch[i+2][j+2]==tolower(str[2])){                                                                         ctr=-1;                                                                         cout<<i+1<<" "<<j+1<<endl;                                                                         break;                                            }                                            if(ch[i+1][j]==tolower(str[1]) && ch[i+2][j]==tolower(str[2])){                                                                         ctr=-1;                                                                         cout<<i+1<<" "<<j+1<<endl;                                                                         break;                                            }                                            if(ch[i+1][j-1]==tolower(str[1]) && ch[i+2][j-2]==tolower(str[2])){                                                                         ctr=-1;                                                                         cout<<i+1<<" "<<j+1<<endl;                                                                         break;                                            }                                            }                           }                           if(ctr<0)                                    break;             }     }     }     return 0; } 
// codechef practice(peer) Windows #include<iostream> #define max(a,b) a>b?a:b #define min(a,b) a<b?a:b using namespace std; int main() {     int t;     int x1,y1,x2,y2,x3,y3,x4,y4,x5,x6,y5,y6;     cin>>t;     while(t--)     {               cin>>x1>>y1>>x2>>y2;               cin>>x3>>y3>>x4>>y4;               x5=max(x1,x3);               y5=max(y1,y3);               x6=min(x2,x4);               y6=min(y2,y4);               if((x5<x6)&&(y5<y6))cout <<x5<<" "<<y5<<" "<<x6<<" "<<y6;               else cout<<"No Overlap";               cout<<"\n";     } }                                                                        
#include<iostream> using namespace std; int main(){     cout<<"2 2 7"<<endl;     cout<<"0 0 10"<<endl;     cout<<"1 5 6"<<endl;     return 0; }
#include<iostream> using namespace std; int main(){     cout<<"1 fp*"<<endl;     cout<<"0 axfdp"<<endl;     cout<<"2 ade bmn"<<endl;     return 0; }
//Stupid Problem...  #include <stdio.h>   int main() { 	printf("ABCD\nABCE\nABCFX\n\nABCFX\nABCE\nABCD\n"); 	return 0; }  
#include<stdio.h> int main() {long long int a,b,cur,pre;int count; while(1) {scanf("%lld %lld",&a,&b); if((a==0)&&(b==0)) break; cur=2,pre=1;count=0; while(1) { cur=cur+pre;pre=cur-pre; if((cur>=a)&&(cur<=b)) count++; else if(cur>b) break; } printf("%d\n",count); } return 0; }
#include <cstdio> using namespace std;  int main() { printf("1 0\n2 2\n1 5 2 3 4 6\n1 5 2 4 3 6"); return 0; }
//8.4 Print all permutations of valid open and close parenthesis  #include <iostream> #include <bits/stdc++.h>  using namespace std;  int RN(int n) { 	int a = 0; 	while(n) 	{ 		a = a * 10 + n % 10; 		n = n/10; 	} 	return a; } bool palin(int n) { 	if(n==RN(n)) return true; 	else return false; } void compute(int n) { 	int cnt = 0; 	while(palin(n)==false) 	{ 		cnt++; 		n = n + RN(n); 	} 	cout<<cnt<<" "<<n; }  int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		int a; 		cin>>a; 		compute(a); 		cout<<endl; 	} 	return 0; } 		   	   
// codechef practice(peer) Windows #include<iostream> #define max(a,b) a>b?a:b #define min(a,b) a<b?a:b using namespace std; int main() {     int t;     int x1,y1,x2,y2,x3,y3,x4,y4,x5,x6,y5,y6;     cin>>t;     while(t--)     {               cin>>x1>>y1>>x2>>y2;               cin>>x3>>y3>>x4>>y4;               x5=max(x1,x3);               y5=max(y1,y3);               x6=min(x2,x4);               y6=min(y2,y4);               if((x5<x6)&&(y5<y6))cout <<x5<<" "<<y5<<" "<<x6<<" "<<y6;               else cout<<"No Overlap";               cout<<"\n";     } }                                                                        
#include <stdio.h>           int main()     {     printf("5 2 1 4 3\n1 3 5 2 4\n4 2 5 3");     return 0;     } 
#include<iostream> #include<string> #include<cstdlib> #include<cstdio> using namespace std; int main() { int r,c; cin>>r>>c; int a[25][25]={{0,0}}; string str; int i,j; while(cin>>str!=0) { int l=str.length(); if(l==1) break; string str1=str.substr(0,l-1); int v=atoi(str1.c_str()); if(str[l-1]=='H') { for(i=0;i<c;i++) { int out=0; for(j=0;j<r;j++) { if(a[j][i]==1) continue; int k=1,count=0; if(i+v>c){ out=1; break;} while(k<v) { if(a[j][i+k]==1) {count++; break;} k++; } if(count==0) { while(k>0) { k--; a[j][i+k]=1; } out=1; break; } } if(out==1) break; } } else if(str[l-1]=='V') { for(i=0;i<c;i++) { int out=0; for(j=0;j<r;j++) { if(a[j][i]==1) continue; int k=1,count=0; if(j+v>r) { break; } while(k<v) { if(a[j+k][i]==1) {count++; break;} k++; } if(count==0) { while(k>0) { k--; a[j+k][i]=1; } out=1; break; } } if(out==1) break; } } else if(str[l-1]=='S') { for(i=0;i<c;i++) { int out=0; for(j=0;j<r;j++) { if(a[j][i]==1) continue; int k=1,k1=1,count1=0,count=0; if(i+v>c){ out=1; break;} if(j+v>r) { break; } while(k<v) { if(a[j+k][i]==1) {count++; break;} k++; } while(k1<v) { if(a[j][i+k1]==1) {count1++; break;} k1++; } if(count1==0 && count==0) { k=0; while(k<v) { k1=v; while(k1>0) { k1--; a[j+k][i+k1]=1; } k++; } out=1; break; } } if(out==1) break; } } } for(i=r-1;i>=0;i--) { for(j=0;j<c;j++) cout<<a[i][j]; cout<<endl; } return 0; } 
#include <stdio.h>   int main() {     printf("1 4\n2 11\n3 14");     return 0; } 
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <limits> #include <string> #include <cassert>  using namespace std; typedef long long LL; typedef pair<int,int> pii; typedef pair< pii , pii > piiii;  #define forup(i,a,b) for(int i=a; i<b; ++i) #define fordn(i,a,b) for(int i=a; i>b; --i) #define rep(i,a) for(int i=0; i<a; ++i)  #define dforup(i,a,b) for(i=a; i<b; ++i) #define dfordn(i,a,b) for(i=a; i>b; --i) #define drep(i,a) for(i=0; i<a; ++i)  #define slenn(s,n) for(n=0; s[n]!='\0'; ++n)  #define gi(x) scanf("%d",&x) #define gl(x) cin>>x #define gd(x) scanf("%lf",&x) #define gs(x) scanf("%s",x)  #define pis(x) printf("%d ",x) #define pin(x) printf("%d\n",x) #define pls(x) cout<<x<<" " #define pln(x) cout<<x<<"\n" #define pds(x) printf("%.12f ",x) #define pdn(x) printf("%.12f\n",x) #define pnl() printf("\n")  #define fs first #define sc second #define loc first.first #define lmv first.second #define lct second.first #define rct second.second  #define pb push_back  const LL modref=1000000007ll;  const int max_n=100010;  int T; int n;  typedef set<piiii> sset;  sset S; sset::iterator it;  LL qmin,qmax;  LL p2[max_n]; void findp2() { 	p2[0]=1ll; 	forup(i,1,max_n) 		p2[i]=(p2[i-1]*2ll)%modref; }  LL fmax(LL s, LL e, LL r) { 	if(s>e) return 0ll; 	assert(r<=e-s+1);  	LL ret=p2[r]-1ll; 	ret*=p2[(n-2)-(s+r-1)]; ret%=modref; 	return ret; }  LL fmin(LL s, LL e, LL r) { 	if(s>e) return 0ll; 	assert(r<=e-s+1);  	LL ret=p2[r]-1ll; 	ret*=p2[(n-2)-e]; ret%=modref; 	return ret; }  int main() { 	findp2(); 	gi(T);  	rep(z,T) 	{ 		gi(n);  		S.clear(); 		S.insert(piiii(pii(-1,0),pii(0,0)));  		qmin=0ll; qmax=p2[n-1]-1ll; 		bool valid=true; 		int ci,cj; 		rep(i,n/2) 		{ 			gi(ci); --ci; gi(cj); 			if(not valid) { pin(-1); continue; }  			piiii cp; 			if(cj<=n/2) cp=piiii(pii(ci,0),pii(cj,ci+1-cj)); 			else cp=piiii(pii(ci,1),pii(ci+1-(n-cj+1),n-cj+1));  			it=S.upper_bound(cp); --it; // should work, not sure though .. 			if(not( it->lct<=cp.lct and it->rct<=cp.rct )) valid=false; 			++it; 			if(it!=S.end() and (not( it->lct>=cp.lct and it->rct>=cp.rct ))) valid=false; 			if(not valid) { pin(-1); continue; }  			if(it==S.end()) 			{ 				--it; 				int ploc=it->loc, /*plmv=it->lmv, plct=it->lct,*/ prct=it->rct; 				int cloc=cp.loc, clmv=cp.lmv, /*clct=cp.lct,*/ crct=cp.rct;  				if(clmv) { qmin += p2[n-2-cloc]; qmin%=modref; } 				qmin += fmin(ploc+1,cloc-1,(crct-prct-clmv)); qmin %= modref;  				if(clmv) { qmax += p2[n-2-cloc]; qmax%=modref; } 				qmax += modref-(p2[n-ploc-2]-1); qmax %= modref; 				qmax += (p2[n-cloc-2]-1); qmax %= modref; 				qmax += fmax(ploc+1,cloc-1,(crct-prct-clmv)); qmax %= modref; 			} 			else 			{ 				int nloc=it->loc, nlmv=it->lmv, /*nlct=it->lct,*/ nrct=it->rct; 				--it; 				int ploc=it->loc, /*plmv=it->lmv, plct=it->lct,*/ prct=it->rct; 				int cloc=cp.loc, clmv=cp.lmv, /*clct=cp.lct,*/ crct=cp.rct;  				if(clmv) { qmin += p2[n-2-cloc]; qmin%=modref; } 				qmin += modref-fmin(ploc+1,nloc-1,(nrct-prct-nlmv)); qmin %= modref; 				qmin += fmin(cloc+1,nloc-1,(nrct-crct-nlmv)); qmin%=modref; 				qmin += fmin(ploc+1,cloc-1,(crct-prct-clmv)); qmin%=modref;  				if(clmv) { qmax += p2[n-2-cloc]; qmax%=modref; } 				qmax += modref-fmax(ploc+1,nloc-1,(nrct-prct-nlmv)); qmax %= modref; 				qmax += fmax(cloc+1,nloc-1,(nrct-crct-nlmv)); qmax%=modref; 				qmax += fmax(ploc+1,cloc-1,(crct-prct-clmv)); qmax%=modref; 			}  			S.insert(cp); 			pis((int(qmin))); pin((int(qmax))); 		} 	} 	 	return 0; }
#include<iostream> #include<algorithm> #include<string> # define mod 1000000007 # define long long ll using namespace std; int main() { 	int t,n,x,y,i; 	string s; 	cin>>t; 	while(t--) 	{ 		x=0; 		y=0; 		cin>>s; 		for(i=0;i<s.length();i++) 		{ 			if(s[i]=='N') 			x++; 			if(s[i]=='S') 			x--; 			if(s[i]=='E') 			y++; 			if(s[i]=='W') 			y--; 		} 			//cout<<x<<" "<<y<<endl; 			if(x>0&&y>0) 			cout<<"NORTHEAST"<<endl; 			if(x>0&&y<0) 			cout<<"NORTHWEST"<<endl; 			if(x<0&&y>0) 			cout<<"SOUTHEAST"<<endl; 			if(x<0&&y<0) 			cout<<"SOUTHWEST"<<endl; 			if(x>0&&y==0) 			cout<<"NORTH"<<endl; 			if(x<0&&y==0) 			cout<<"SOUTH"<<endl; 			if(x==0&&y<0) 			cout<<"WEST"<<endl; 			if(x==0&&y>0) 			cout<<"EAST"<<endl;						 			 	} 	return 0; } 
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #include <cstring> #include <climits> #include <cctype> #include <cassert>  using namespace std;  #define ulli        unsigned long long int #define lli         long long int #define clr(x)      memset(x,0) #define set(x)      memset(x,1) #define memset(x,i) memset(x,i,sizeof(x)) #define Sd(x)       scanf("%d",&x); #define Sf(x)       scanf("%f",&x); #define Sc(x)       scanf("%c",&x); #define Ss(x)       scanf("%s",x); #define Sulli(x)    scanf("%llu",&x) #define F(i,a,n)    for(int i=a;i<n;i++) #define FD(i,a,n)   for(int i=a;i>=n;i--) #define Nl          printf("\n");  //-----RELEVANT CODE-----  int main() {     //freopen("inp.txt","r",stdin);     int t,r,c;lli a[105][105],s,k;     scanf("%d",&t);     while(t--)     {         s=0;         scanf("%d %d %lld",&r,&c,&k);         //printf("%d %d %lld\n",r,c,k);         F(i,0,r) F(j,0,c) scanf("%lld",&a[i][j]);         s+=a[r-1][0];         int j=0;         FD(i,r-2,0)         {             if(j==0)             {                 if(a[i][j+1]<a[i][j])                     j++;             }             else if(j==c-1)             {                 if(a[i][j-1]<=a[i][j])                     j--;             }             else             {                 if(a[i][j-1]<=a[i][j] && a[i][j-1]<=a[i][j+1])                     j--;                if(a[i][j+1]<a[i][j] && a[i][j+1]<a[i][j-1])                     j++;             }             s+=a[i][j];         }             //printf("%lld %lld\n",s,k);             if(s<=k)                 printf("Yes\n");             else                 printf("No\n");     }     return 0; } 
#include <bits/stdc++.h> #define ll long long int #define s(a) scanf("%lld",&a) #define f first #define sc second #define pb push_back #define mp make_pair #define VALUETYPE long long int #define inf 10e16 #define EVEN(x) ((x%2)==0) #define ODD(x) ((x%2)==1)  using namespace std;  vector<ll>v[100001]; ll a[100001]; ll level[100001]; ll parent[100001]; vector<ll>topoSort; ll baap[100001][20]; ll dp[100001][20]; ll power[101];  ll mod=1000000007;  void dfs(ll ind,ll lst,ll lev) {     parent[ind]=lst;     level[ind]=lev;     for(int i=0;i<v[ind].size();i++) {         if(v[ind][i]==lst) continue;         dfs(v[ind][i],ind,lev+1);     }     topoSort.pb(ind); }  ll jthAncestor(ll ind,ll x) {     if(level[ind] < x) return -1;     ll ans = ind;     //cout<<ind<<endl;     for(int i=19;i>=0;i--) {         ll val = 1<<i;         if(val <= x) {             ans = baap[ans][i];             //cout<<ans<<endl;             x-=val;         }     }     return ans; }  int main() {     //freopen("inp.txt","r",stdin);     ll n,i,j,k,l,w,ww,x,y,z,m,d;     s(n);s(d);     for(i=1;i<=n;i++) s(a[i]);     for(i=1;i<n;i++) {         s(x);s(y);         v[x].pb(y);         v[y].pb(x);     }      power[0]=1;     for(i=1;i<19;i++) {         power[i]=power[i-1]*d;     }      dfs(1,-1,0);     for(i=1;i<=n;i++) {         baap[i][0]=parent[i];     }     for(j=1;j<20;j++) {         for(i=1;i<=n;i++) {             w = baap[i][j-1];             if(w==-1) {baap[i][j]=-1;continue;}             ww = baap[w][j-1];             if(ww==-1) {baap[i][j]=-1;continue;}             baap[i][j]=ww;         }     }     reverse(topoSort.begin(),topoSort.end());      dp[1][0]=a[1];     for(i=1;i<topoSort.size();i++) {         x = topoSort[i];         dp[x][0]=a[x];         for(j=1;j<20;j++) {             w = jthAncestor(x,power[j-1]);             if(w==-1) {                 dp[x][j]=0;             }             else {                 if(dp[w][j-1]!=0) {                     dp[x][j] = dp[w][j-1] + a[x];                     if(dp[x][j]>mod) dp[x][j]-=mod;                 }             }         }     }     ll ans = 0;      for(i=0;i<20;i++) {         for(j=1;j<=n;j++) {             ans = ans + dp[j][i];             if(ans>=mod) ans-=mod;         }     }     cout<<ans<<endl;     return 0; } 
#include<iostream> using namespace std;  int main() { int n; cin>>n; int sum=0; for(int i=1;i<=n;i++) sum+=i; cout<<sum<<endl; return 0; }
#include <iostream> using namespace std;   int main() {     long long int n;     cin>>n;     n=n/4;     cout<<(n*n)<<endl;         return 0; }
#include <iostream> using namespace std;  int main() {     int sum=0,temp=0;     cin>>temp; sum+=(3*temp);     cin>>temp>>temp; sum+=temp;     cout<<sum<<endl;     return 0; } 
#include<iostream> using namespace std; int main() { long a,b,c; cin>>a>>b>>c; if(a+b<c) cout<<"PROFIT"<<endl; else cout<<"LOSS"<<endl; return 0; }
#include <iostream> #include <string.h> using namespace std;  int main() {     char a[1000];     cin>>a;     for(int i=0;i<strlen(a);i++)     {         int p= a[i] - 'A';         p+=3;         p=p%26;         p+=65;         char d=p;         cout<<d;     }     cout<<endl;     return 0; }
//calculating area.. #include<iostream> using namespace std; int main() { 	float per,area,l,b; 	cin>>per; 	cin>>l; 	b = (per/2)-l; 	area = l*b; 	cout<<area; }
 #include <bits/stdc++.h> using namespace std;  typedef long long int ll; ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;} ll a[100001],ans[100001]; vector<ll> prime;   ll amaz(ll i) {   	ll sum=0;  	for(ll j=1;j<=sqrt(i);j++) 		if(i%j==0) 			sum+= (j+i/j);   	return sum-i ;  } int main() { 	ios_base::sync_with_stdio(0); cin.tie(0); 	 	ll n;cin>>n; 	cout<<amaz(n); 	 	return 0; }
#include<iostream> using namespace std; int main() {     int x1,y1,x2,y2,x,y;     cin>>x1>>y1>>x2>>y2>>x>>y;     if((x1<=x&&x<=x2)||(x1>=x&&x>=x2))        {            if((y1<=y&&y<=y2)||(y1>=y&&y>=y2))               {                   cout<<"INSIDE";                   return 0;               }        }        cout<<"OUTSIDE";        return 0; } 
#include <iostream> #include <cstdio> using namespace std; char is[200][200]; void chn(int,int); int main() { int n; cin>>n; for(int i=0;i<n;i++){ int x,y; cin>>x>>y; for(int j=0;j<x;j++) for(int k=0;k<y;k++) is[j][k]='.'; for(int j=0;j<x;j++) for(int k=0;k<y;k++) cin>>is[j][k]; int sum=0; for(int j=0;j<x;j++) for(int k=0;k<y;k++) {if(is[j][k]=='#')sum=sum+1; chn(j,k);} /* for(int j=0;j<x;j++){ for(int k=0;k<y;k++) cout<<is[j][k]; cout<<endl;}*/ cout<<sum<<endl; } }   void chn(int x,int y){ if(is[x][y]=='#') {is[x][y]='.'; chn(x-1,y-1); chn(x-1,y); chn(x-1,y+1); chn(x,y-1); chn(x,y+1); chn(x+1,y-1); chn(x+1,y); chn(x+1,y+1); } else return; }   
#include <iostream> #include <algorithm> using namespace std;  int main() {     int t; cin>>t;     while(t--)     {         long n; cin>>n;         long sum=0;         for(int i=1;i<=n/2;i++)         {             if(n%i==0)             sum+=i;         }         cout<<sum<<endl;     }     return 0; }
#include<algorithm> #include<iostream> #include<cstdio> #include<vector> #include<fstream> #include<iomanip> #include<bitset> #include<deque> #include<queue> #include<string> #include<map> #include<cstring> #include<sstream> #include<cmath> using namespace std;  #define gc getchar_unlocked   void scanint(int &x) { register int c = gc(); x = 0; for(;(c<48 || c>57);c = gc()); for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} } int a[500];   void recurse(int start,int end,int count,int &min) {     int i;     if(start>end)     return;      if(start==end)     {         if(count<min)         min=count;     }      for(i=1;i<=a[start];i++)     recurse(start+i,end,count+1,min); }  int main() {     int min=10000;      int n,i,t,x,y,flag;     scanint(t);     while(t--)     {         min=100000;         scanint(n);          for(i=0;i<n;i++)         scanint(a[i]);          recurse(0,n-1,0,min);         cout<<min<<"\n";       }     return 0; } 
#include<stdio.h> int main() {  int t,n,a,b,f,i;  scanf("%d",&t);  while(t)  {   f=0;   scanf("%d%d",&a,&b);   for(n=1;n<=a;n++)   {    for(i=n+1;i<=a;i++)    {     if(n*b%i==0)     {      f++;      break;     }     }   }   printf("%d\n",f);   t--;  }    return 0; }  
/*-->>Light Cavalry<<--*/  //Imp header files #include <iostream> #include <cstdio> #include <cstdlib> #include <cstring> #include <cmath> #include <algorithm> #include <set> #include <vector> #include <stack> #include <queue> #include <sstream> #include <map> #include <list> #include <deque> #include <bitset> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iomanip> #include <sstream> #include <ctime> #include <cassert> #include <climits> using namespace std;  //defined I/O #define si(n) scanf("%d",&n) #define sli(n) scanf("%ld",&n) #define slli(n) scanf("%lld",&n) #define sf(n) scanf("%lf",&n) #define GetLine(n) getline(cin,n); #define ss(n) scanf("%s",n) #define pi(n) printf("%d",n) #define pli(n) printf("%ld",n) #define plli(n) printf("%lld",n) #define pf(n) printf("%lf",n) #define ps(n) printf("%s",n) #define newLine printf("\n") #define space printf(" ") #define SWAP(a,b,t) t=a,a=b,b=t #define Loop(i,a,n) for(__typeof(n) i(a); i<n; i++) #define ULL unsigned long long int #define LL long long int   #define MOD 1000000007 //Imp functions int gcd(int a, int b){if(b == 0)return a;else return gcd(b,a % b);}     int main() { 	 	int n; 	si(n); 	 	string s[n]; 	 	Loop(i,0,n) 	{ 		cin>>s[i]; 		 	} 	int  m=s[0].length(); 	 	int a[n][m]; 	 	Loop(i,0,n) 	{ 		Loop(j,0,m) 		{ 			 			 			a[i][j]=9999; 			 			 //cout<<a[i][j]<<" "; 		} 		//cout<<endl; 		 	} 	 	a[0][0]=1;  	int x,y,z; 	Loop(i,0,n) 	{ 		Loop(j,0,m) 		{ 			if(s[i][j]=='0') 			{ 			int mi=9999; 			 			 			if(i-1>=0 && j-1>=0) 			mi=min(mi,a[i-1][j-1]+1); 			 			if(i-1>=0 && j+1<m) 			mi=min(mi,a[i-1][j+1]+1); 			 			if(i+1<n && j-1>=0) 			mi=min(mi,a[i+1][j-1]+1); 			 			if(i+1<n && j+1<m) 			mi=min(mi,a[i+1][j+1]+1); 			 			if(j-1>=0) 			mi=min(mi,a[i][j-1]+1); 			 			 			if(i-1>=0) 			mi=min(mi,a[i-1][j]+1); 			 			 			if(j+1<m) 			mi=min(mi,a[i][j+1]+1); 			 			if(i+1<n) 			mi=min(mi,a[i+1][j]+1); 			 			 			 			 			 			 			if(mi!=9999) 			a[i][j]=mi; 			 			} 			 			//cout<<a[i][j]<<" "; 			 		 		} 		//cout<<endl; 		 	} 	 	cout<<a[n-1][m-1]<<endl;  	 	 	return 0; }     
//#include<iostream.h> //#include<conio.h> #include<stdio.h> #include<string.h>  char a[20003][22];  int b[20002];  int c[20002]; //using namespace std; int main() {  int n,m,i,l,h,j,p,o,k,x;    scanf("%d%d",&n,&m);  while((n!=0)&&(m!=0))  {p=0;   for(i=0;i<n;i++)   b[i]=0;   x=0;   for(i=0;i<n;i++)   scanf("%s",a[i]);   for(i=0;i<n;i++)   {    if(x>n)    break;    h=0;    o=0;    for(l=0;l<p;l++)    {     if(i==c[l])      {o=1;      break;      }    }    //cout<<"workin for i="<<i<<endl;   if(o==0)   {     for(j=i;j<n;j++)     {      if(j!=i)      {       if(!strcmp(a[i],a[j]))       {x++;        h++;        c[p++]=j;       }       // cout<<"h="<<h<<endl;      }     }       b[h]+=1;     }              }   for(i=0;i<n;i++)   printf("%d\n",b[i]); // cout<<"enter n & m"<<endl;   scanf("%d%d",&n,&m);  }          // getch();     return 0;      }             
#include <cstdlib> #include <iostream> //#include<conio.h> //using namespace std; int a[150]; int main() {     int n=1,i,ra,m,mul,k=0,j,c;   //  time_t t;   // unsigned int seedval; while(1) {          scanf("%d",&n);        if(n==0)        break;        c=n; ra=1;     do     {        for(i=0;i<c-1;i++)        a[i]=i+2;               n=c;              // seedval=(unsigned)time(&t);      // srand(seedval);       // ra=((rand()%c)+1);            k=0;        m=0;               // cout<<"ra="<<ra<<endl;       // getch();       while((m==0)&&(n-1>1))       {         for(i=0;i<n-1;i++)        {         k++;         if(k%ra==0)         {//cout<<"k="<<k<<" "<<"i="<<i<<endl;           if((a[i]==13)&&(n-1>1))           m=1;           n--;           for(j=i;j<n-1;j++)           a[j]=a[j+1];           i--;         }        }        }    //  for(j=0;j<n-1;j++)      // cout<<a[j]<<" ";  ///  cout<<endl;     //  getch();     if(m==1)     ra++;     }while(m==1);                                         // if(ra>=n)       // m=1; printf("%d\n",ra);       //a[k++]=ra; }     // for(i=0;i<k;i++)     //cout<<a[i]<<endl; //getch();  return 0; } 
#include<iostream> #include<cstring> #include<cstdio> using namespace std; int main() { //thisistheeasyoneab  /*  t t y     h h o     i e n     s e e     i a a     s s b */     int i=1,j=0,p,c;     char s[500];     int t;     cin>>t;     while(t--)     {         i=1;         j=0;         cin>>c;         int d=c;         int e=1;         scanf("%s",s);         p=strlen(s);         int r=p/c;         //int flag=0;         int x=2*d-1;         int flag=0;         int cnt=1;         cout<<s[0];         p--;          while(p>0)         {             if(cnt==r)             {                 j=i;                 cnt=1;                 d--;                 cout<<s[i++];                 p--;                 x=2*d-1;                 e=2*c-x;                 flag=0;               }                if(flag==0)             {                 cout<<s[j+x];                 j=j+x;                 p--;                 flag=1;                 cnt++;             }             else             {                 cout<<s[j+e];                 j=j+e;                 flag=0;                 p--;                 cnt++;             }          }         cout<<"\n";          } } 
#include<iostream> #include<string.h>  using namespace std;  int main() {     long long int t,i,n,a,b,sum;;      cin>>t;      while(t--)     {         sum=0;         cin>>a>>b>>n;          if(n>2)         for(i=0;i<n-2;i++)         {             sum=a+b;             a=b;             b=sum;         }         else         if(n==1)    sum=a;         else         if(n==2)    sum=b;          cout<<sum<<endl;     }   return 0; } 
#include<iostream> #include<cstdio> using namespace std; int main() {      char str[25];      int num[4];      while(scanf("%s",&str)!=EOF)      {           int r=0,j=0;           for(int i=0;str[i]!='\0';i++)           {                if(str[i]!='.')                {                     r=str[i]-48+r*10;                }                else                {                     num[j]=r;                     j++;                     r=0;                }           }           num[j]=r;           if(num[0]>=1 && num[0]<=126 && num[1]>=0 && num[1]<=255 && num[2]>=0 && num[2]<=255 && num[3]>=0 && num[3]<=255)                   printf("Class A\n");              else if(num[0]>=128 && num[0]<=191 && num[1]>=0 && num[1]<=255 && num[2]>=0 && num[2]<=255 && num[3]>=0 && num[3]<=255)                   printf("Class B\n");              else if(num[0]>=192 && num[0]<=223 && num[1]>=0 && num[1]<=255 && num[2]>=0 && num[2]<=255 && num[3]>=0 && num[3]<=255)                   printf("Class C\n");              else if(num[0]>=224 && num[0]<=239 && num[1]>=0 && num[1]<=255 && num[2]>=0 && num[2]<=255 && num[3]>=0 && num[3]<=255)                   printf("Class D\n");               else if(num[0]>=240 && num[0]<=255 && num[1]>=0 && num[1]<=255 && num[2]>=0 && num[2]<=255 && num[3]>=0 && num[3]<=254)                   printf("Class E\n");               else printf("Invalid\n");      } } 
#include<iostream> #include<cstdio>  using namespace std;  int main() {     int a,b,c,flag1,flag2,min,i;      while(scanf("%d%d%d",&a,&b,&c)!=EOF)     {         flag1=0;         flag2=1;         if( a<b && a<c )         min=a;         else         if( b<a && b<c )         min=b;         else         min=c;          if( a*a+b*b==c*c || b*b+c*c==a*a || a*a+c*c==b*b )         flag1=1;          for(i=2;i<=min;i++)         {             if( a%i==0 && b%i==0 && c%i==0 )             flag2=0;         }          if(flag1 && flag2)         printf("YES\n");         else         printf("NO\n");      }    return 0; } 
/* Sahil Prakash */  #include<bits/stdc++.h>  using namespace std;  #define ull unsigned long long #define si(x) scanf("%d",&x) #define sull(x) scanf("%llu",&x) #define sch(x) scanf("%c",&x) #define sstr(s) scanf("%s",s) #define pri(x) printf("%d",x) #define pch(x) printf("%c",x) #define pull(x) printf("%llu",x) #define pstr(s) printf("%s",s) #define nl printf("\n")  int main() {     char s[26];     sstr(s);     while( strcmp(s,"*END*") != 0 )     { 	int i,j,k,l,flag1=0,flag2=0,len,count1=0,count2=0; 	len=strlen(s); 	j=len-2; 	i=0; 	while(i<j) 	{ 	    k=j-1; 	    l=i; 	    count1=count2=0; 	    flag1=flag2=0; 	    for(;k>l;--k) 	    { 		if(s[k] != s[l]) 		    count1++; 		l++; 	    } //		pri(count1); //		nl; 	    if(count1<=1) 		flag1=1; 	    k=j; 	    l=len-1; 	    for(;k<l;++k) 	    { 		if(s[k] != s[l]) 		    count2++; 		l--; 	    } //	    pri(count2); //		nl; 	    if(count2<=1) 		flag2=1; 	    if(flag1==1 && flag2==1) 	    { 		printf("%s is a double near palindrome.\n",s); 		break; 	    } 	    j--; 	} 	if(flag1!=1 || flag2!=1) 	    printf("%s is not a double near palindrome.\n",s); 	sstr(s);     }     return 0; } 
// by ma5termind #include<iostream> #include<vector> #include<set> #include<map> #include<queue> #include<stack> #include<string> #include<algorithm> #include<functional> #include<iomanip> #include<cstdio> #include<cmath> #include<limits.h> #include<cstring> #include<cstdlib> #include<cfloat> #include<cassert> #define maxm(a,b) a>b?a:b; #define minm(a,b) a<b?a:b; using namespace std; //M lazy ;) typedef long long ll; typedef vector <int> vi; typedef pair< int ,int > pii; typedef istringstream iss; typedef ostringstream oss; typedef map<int,int> mp; #define pb push_back #define mp make_pair #define ff first #define ss second #define sz size() #define ln length() #define rep(i,n) for(int i=0;i<n;i++) #define fu(i,a,n) for(int i=a;i<=n;i++) #define fd(i,n,a) for(int i=n;i>=a;i--) #define all(a)  a.begin(),a.end() #define ESP (1e-9) #define gi(n) scanf("%d",&n) #define gl(n) cin >> n #define pi(n) printf("%d",n) #define pl(n) cout << n #define ps printf(" ") #define pn printf("\n") #define dg(n,s); printf("%s %d",s,n) #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min() #define traverse_map(a,b) for(mp::iterator it=a;it!=b;++it) #define MOD 1000000007 #define MAX 1000001 #define cases() int t; cin>>t; while(t--) // fast input function #define getcx getchar_unlocked // fast input function #ifdef ONLINE_JUDGE  inline void inp( int &n )  {     n=0;     int ch=getcx();int sign=1;     while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )             n = (n<<3)+(n<<1) + ch-'0', ch=getcx();     n=n*sign;   } #else inline void inp(int &n){  cin>>n; } #endif int gcd(int a,int b){    if(b==0)    return a;    return gcd(b,a%b); } int main(){  //vi num;  //map<int,int>mark;     int a,b,c; 	while(scanf("%d%d%d",&a,&b,&c)!=EOF){ 	 	 	 if(a<0) 	  a*=-1; 	  if(b<0) 	  b*=-1; 	  if(c<0) 	  c*=-1; 	   	  if(c*c==a*a+b*b){  		  if(gcd(a,gcd(b,c))==1) 			cout<<"YES"<<endl; 		  else 		  cout<<"NO"<<endl; 	  } 	  else 	   cout<<"NO"<<endl; }  return 0; } 
#include<stdio.h> typedef long long ll; int p[40];  int main(){ 	register int i,j,k; ll t; 	scanf("%lld",&t); 	while(t){ 		for(i=0;t;i++){ 			p[i]=t%2; 			t=t/2; 		} 		j=1;k=1; 		for(i=i-2;i>=0;i--){ 			if(p[i])  j=j+k; 			else k=k+j; 		} 		printf("%d/%d\n",j,k); 		scanf("%lld",&t); 	} 	return 0; }
#include<stdio.h>   int main() { 	int count,a,b,c,d; 	char str[1024]; 	while((count=scanf("%d.%d.%d.%d",&a,&b,&c,&d))!=EOF) 	{ 		gets(str); 		if(count<4||a>255||b>255||c>255||d>=255||a<0||b<0||c<0||d<0||(a==0&&b==0&&c==0&&d==0)) 		printf("Invalid\n"); 		else 		{ 			if(a<=127) 			printf("Class A\n"); 			else if(a<=191) 			printf("Class B\n"); 			else if(a<=223) 			printf("Class C\n"); 			else if(a<=239) 			printf("Class D\n"); 			else 			printf("Class E\n"); 		} 	} 	return 0; } 
#include<iostream> using namespace std;  string arr[10][10]= {"0","0","0","0","0","0","0","0","0","0",                 "0","1","2","3","4","5","6","7","8","9",                 "0","2","4","6","8","10","12","14","16","18",                 "0","3","6","9","12","15","18","21","24","27",                 "0","4","8","12","16","20","24","28","32","36",                 "0","5","10","15","20","25","30","35","40","45",                 "0","6","12","18","24","30","36","42","48","54",                 "0","7","14","21","28","35","42","49","56","63",                 "0","8","16","24","32","40","48","56","64","72",                 "0","9","18","27","36","45","54","63","72","81"};                                    string add(string q,string w) {   long long int l1,l2,carry,sum,l,diff,flag,i,pos;     carry=0;     string s="";     l1=q.length();     l2=w.length();     if(l1>=l2)     {         l=l1;               flag=1;               diff=l1-l2;     }     else     {         l=l2;               diff=l2-l1;               flag=2;     }     if(flag==1)     {          for(i=0;i<diff;i++)                w=" "+w;     }     else     if(flag==2)     {          for(i=0;i<diff;i++)                q=" "+q;     }          for(i=l-1;i>=0;i--)     {                     sum=carry;                           if(q[i]!=' ')                           sum=sum+q[i]-48;                           if(w[i]!=' ')                           sum=sum+w[i]-48 ;                             carry=sum/10;                           sum=sum%10;                           s=(char)(sum+48)+s;     }     if(carry>0)     s=(char)(carry+48)+s;     pos=0;     flag=0;     l=s.length();     if(l>1)     {     for(i=0;i<l;i++)     {               if(s[i]!='0')                     {pos=i;                     flag=1;                     break;}     }     for(i=0;i<l-pos;i++)     s[i]=s[i+pos];         s.resize(l-pos); if(flag==0)      s="0";      }     return s;    }    string subd(string q,string w) {   long long int l1,l2,carry,sum,l,diff,flag,i,j,pos;     carry=0;     string s="";     //cout<<"doin... dekh lo"<<q<<" "<<w<<endl;     l1=q.length();     l2=w.length();     //cout<<l1<<" bty  "<<l2<<endl;     if(l1>=l2)     {         l=l1;               flag=1;               diff=l1-l2;     }     else     {         l=l2;               diff=l2-l1;               flag=2;     }     ///cout<<"diff dekho toh"<<diff<<endl;     if(flag==1)     {          for(i=0;i<diff;i++)                w=" "+w;     }     else     if(flag==2)     {          for(i=0;i<diff;i++)                q=" "+q;     }    // cout<<"q="<<q<<endl;     //cout<<"W="<<w<<endl;     for(i=l-1;i>=0;i--)     {                     if(q[i]>=w[i] && w[i]>34)                           s=(char)(q[i]-w[i]+48)+s;                           else                           if(w[i]<34)                           s=(char)(q[i])+s;                           else                           {                               for(j=i-1;j>=0;j--)                               {                  if(q[j]>w[j] && q[j]>48)                                                  {            pos=j;                                 //                              cout<<"pos="<<pos;                                                               break;                                                  }                               }                               q[pos]--;                               //cout<<"q="<<q<<endl;                               for(j=pos+1;j<i;j++)                               q[j]=q[j]+9;                               //cout<<"q="<<q<<endl;                               q[i]=q[i]+10;                               //cout<<"q="<<q<<endl;                               i++;                           }                }     pos=0;     flag=0;     l=s.length();     if(l>1)     {     for(i=0;i<l;i++)     {               if(s[i]!='0')                     {pos=i;                     flag=1;                     break;}     }     for(i=0;i<l-pos;i++)     s[i]=s[i+pos];      s.resize(l-pos);      if(flag==0)      s="0"; }   //cout<<"returnin s"<<s<<endl;     return s;    }           string mult(string a,string b) {   long long int l1,l2,flag,diff,max,l,i,pos;     string z1,z2,z0,s1,s2,ans;     l1=a.length();     //cout<<"a="<<a<<endl;   // cout<<"b="<<b<<endl;   /// cout<<"l1="<<l1<<endl;     l2=b.length();   // cout<<"l2="<<l2<<endl;   // cin>>i;     if(l1==1 && l2==1)     {z2=arr[ a[0]-48 ][ b[0]-48 ];     return z2;     }          else     {     if(l1>=l2)     {         l=l1;               flag=1;               diff=l1-l2;     }     else     {         l=l2;               diff=l2-l1;               flag=2;     }     if(flag==1)     {          for(i=0;i<diff;i++)                b='0'+b;     }     else     if(flag==2)     {          for(i=0;i<diff;i++)                a='0'+a;     }     max=(l-1)/2;   // cout<<"max="<<max<<endl;     z2=mult(a.substr(0,max+1),b.substr(0,max+1) );   // cout<<"z2="<<z2<<endl;     z0=mult(a.substr(max+1),b.substr(max+1) );   //  cout<<"z0="<<z0<<endl;   /// cout<<"z2 change? ="<<z2<<endl;   //  cout<<"s1=sudstr of"<<max+1;     s1=add(a.substr(0,max+1),a.substr(max+1) );   // cout<<"s1="<<s1<<endl;     s2=add(b.substr(0,max+1),b.substr(max+1) );   // /cout<<"s2="<<s2<<endl;     z1=mult(s1,s2); //   cout<<"z1 after multi s1 s2="<<z1<<endl;   // cout<<"z1="<<z1<<endl;   // cout<<"z2="<<z2<<endl;     z1=subd(z1,z2);    // cout<<"z1 - z2="<<z1<<endl;    // cout<<"z0="<<z0<<endl;     z1=subd(z1,z0);   // cout<<"z1 - z0="<<z1<<endl;   //  cout<<"max now"<<max<<endl;     for(i=0;i<2*(l/2);i++)     z2=z2+'0';   // / cout<<"z2 after ading 0="<<z2<<endl;     for(i=0;i<l/2;i++)     z1=z1+'0';    // cout<<"z1 after ading 0="<<z1<<endl;     z2=add(z2,z1);   // cout<<"z2 +z1="<<z2<<endl;     z2=add(z2,z0);   // cout<<"z2+ z0="<<z2<<endl;     pos=0;     l=z2.length();     flag=0;     if(l>1)     {     for(i=0;i<l;i++)     {               if(z2[i]!='0')                     {pos=i;flag=1;                     break;}     }     if(pos>0)     for(i=0;i<l-pos;i++)     z2[i]=z2[i+pos];      z2.resize(l-pos);     if(flag==0)     z2="0";     }    }   //cout<<"ans for"<<a<<"*"<<b<<endl<<z2<<endl;     return z2; }               int main() {               long long int u,l,p,flag,sub;      string a,b,c;      cin>>u;      while(u--)      {         cin>>a>>b;                sub=0;                if(a[0]=='-' && b[0]!='-')                sub=1;                else                if(a[0]!='-' && b[0]=='-')                sub=1;                if(a[0]=='-')                a=a.substr(1);                if(b[0]=='-')                b=b.substr(1);                c=mult(a,b);                flag=0;                l=c.length();                 if(sub==1)                                              printf("-");                     for(p=0;p<l;p++)                           {                  if(c[p]=='0' && flag==0)                                              continue;                                               else                                              {flag=1;                                                                                           printf("%c",c[p]);                                              }                           }                           if(flag==0)                           cout<<"0";                                              printf("\n");       } } 
#include<iostream> #include<map> #include<cstdio> #include<vector> #define rep(i,a,b) for(int i=a;i<b;i++) #define cin(n) scanf("%d",&n) #include<algorithm> #include<cstring> #define ill long long #define mod 1000000007   using namespace std; void computeLPSArray(char *pat, int M, int *lps); bool flag[500008]; void KMPSearch(char *pat, char *txt) {     int M = strlen(pat);     int N = strlen(txt);       // create lps[] that will hold the longest prefix suffix values for pattern     int *lps = (int *)malloc(sizeof(int)*M);     int j  = 0;  // index for pat[]       // Preprocess the pattern (calculate lps[] array)     computeLPSArray(pat, M, lps);       int i = 0;  // index for txt[]     while(i < N)     {       if(pat[j] == txt[i])       {         j++;         i++;       }         if (j == M)       {         //printf("Found pattern at index %d \n", i-j);         flag[i-1]=1;         j = lps[j-1];       }         // mismatch after j matches       else if(pat[j] != txt[i])       {         // Do not match lps[0..lps[j-1]] characters,         // they will match anyway         if(j != 0)          j = lps[j-1];         else          i = i+1;       }     }     free(lps); // to avoid memory leak }   void computeLPSArray(char *pat, int M, int *lps) {     int len = 0;  // lenght of the previous longest prefix suffix     int i;       lps[0] = 0; // lps[0] is always 0     i = 1;       // the loop calculates lps[i] for i = 1 to M-1     while(i < M)     {        if(pat[i] == pat[len])        {          len++;          lps[i] = len;          i++;        }        else // (pat[i] != pat[len])        {          if( len != 0 )          {            // This is tricky. Consider the example AAACAAAA and i = 7.            len = lps[len-1];              // Also, note that we do not increment i here          }          else // if (len == 0)          {            lps[i] = 0;            i++;          }        }     } }   int main() {     int t,m,n,i,j,k,l;     //cin(t);     t=1;     while(t--)     {         char s1[10008],s2[500019];         scanf("%s%s",&s1,&s2);         int dp[500009+9]={0};         memset(flag,0,sizeof(flag));         KMPSearch(s1,s2);         int len=strlen(s2),len2=strlen(s1); 		 		//for(i=0;i<len;i++)         //	cout<<flag[i]<<" ";         	         for(i=0;i<len;i++)         {             if(i>0)                 dp[i]=dp[i-1];             if(i>=len2-1&&flag[i])             {                 if(i>len2-1)                     dp[i]=(dp[i]+dp[i-len2])%mod;                 dp[i]=(dp[i]+1)%mod;             }         }         cout<<dp[len-1]<<"\n";     }     return 0; }  
#include<bits/stdc++.h> using namespace std;  int main() {  	int test,i; 	double ans[1000010]; 	 	ans[1]=0; 	ans[2]=1; 	ans[3]=1.5;  	for(i=4;i<1000010;i++) 	{ 		ans[i]=ans[i-1]+ans[i-2]+2; 		ans[i]/=2; 	} 	scanf("%d",&test);  	int x; 	for(i=0;i<test;i++) 	{ 		//cin>>x;                  scanf("%d",&x); 		printf("%0.6lf\n",ans[x]); 	} 	return 0; }     
#include<bits/stdc++.h> using namespace std; #define f first #define s second #define mp make_pair #define pb push_back #define ll long long int mark[100011],sz[100011],c[100011]; vector<int>adj[100011]; int p[100011]; multiset<int>s[100011]; multiset<int>::iterator it; void dfs(int u,int p1,int r) {     c[u]=min(c[u],r);     int mx=-1,loc=-1;     sz[u]=1;     for(int i=0;i<adj[u].size();i++)     {         int k=adj[u][i];         if(k==p1)             continue;         dfs(k,u,r);         sz[u]+=sz[k];         if(sz[k]>mx)         {             mx=sz[k];             loc=k;         }     }     if(mx==-1)     {         mark[u]=u;         if(c[u]>0)             s[u].insert(p[u]);         return;     }     mark[u]=mark[loc];     int t=mark[u];     for(int i=0;i<adj[u].size();i++)     {         int k=adj[u][i];         if(k==p1||k==loc)             continue;         int y=mark[k];         for(it=s[y].begin();it!=s[y].end();it++)             s[t].insert(*it);         //s[y].clear();     }     s[t].insert(p[u]);     while(s[t].size()>c[u])         s[t].erase(s[t].begin()); } int main() {     int n,i,j;     scanf("%d",&n);     for(i=1;i<=n;i++)         scanf("%d %d",&c[i],&p[i]);     for(i=0;i<n-1;i++)     {         int u,v;         scanf("%d %d",&u,&v);         adj[u].pb(v);         adj[v].pb(u);     }     dfs(1,-1,n);     ll ans=0LL;     for(set<int>::iterator it=s[mark[1]].begin();it!=s[mark[1]].end();it++)         ans+=*it;     printf("%lld\n",ans);     return 0; } 
#include<bits/stdc++.h> using namespace std; #define ll long long ll a[1003][1003],dp1[10003][1003],dp2[1003][1003]; int main() { 	int i,j,k,n,m,p; 	cin>>n>>m>>p; 	p=-p; 	for(i=0;i<=n+1;i++) 	for(j=0;j<=m+1;j++) 	{ 		dp1[i][j]=-1e9; 		dp2[i][j]=-1e9; 	} 	 	for(int i=1;i<=n;i++) 	{ 		for(int j=1;j<=m;j++) 		cin>>a[i][j]; 	} 	 	dp1[1][1]=a[1][1]; 	 	for(j=2;j<=m;j++) 	dp1[1][j]=dp1[1][j-1]+a[1][j]; 	 	for(i=2;i<=n;i++) 	dp1[i][1]=dp1[i-1][1]+a[i][1]; 	 	for(int i=2;i<=n;i++) 	{ 		for(int j=2;j<=m;j++) 		{ 			dp1[i][j]=max(dp1[i-1][j],dp1[i][j-1]) +a[i][j]; 		} 	} 	 	dp2[n][m]=a[n][m]; 	for(j=m-1;j>=1;j--) 	dp2[n][j]=dp2[n][j+1]+a[n][j]; 	 	for(i=n-1;i>=1;i--) 	dp2[i][m]=dp2[i+1][m]+a[i][m]; 	 	for(int i=n-1;i>=1;i--) 	{ 		for(int j=m-1;j>=1;j--) 		{ 			dp2[i][j]=max(dp2[i+1][j],dp2[i][j+1]) +a[i][j]; 		} 	} /*	cout<<endl; 	for(i=1;i<=n;i++) 	{ 		for(j=1;j<=m;j++) 		cout<<dp1[i][j]<<" "; 		cout<<endl; 	} 		cout<<endl; 	for(i=1;i<=n;i++) 	{ 		for(j=1;j<=m;j++) 		cout<<dp2[i][j]<<" "; 		cout<<endl; 	} 		cout<<endl; */		 	 	ll mx=dp2[1][1]; 	//cout<<"ans="<<ans<<endl; 	for(i=2;i<=n;++i)     {         for(j=2;j<=m;++j)         {                           if(j>=2 && i>=2) mx = max(mx,dp1[i][j-1]+a[i-1][j]+dp2[i][j]+p); // go up and come back             if(j>=2 && i>=2 && j<m) mx = max(mx,dp1[i][j-1]+a[i][j]+a[i-1][j]+dp2[i-1][j+1]+p);// go up then right                           if(i>=2 && j>=2) mx = max(mx,dp1[i-1][j]+a[i][j-1]+dp2[i][j]+p);// go left and come back             if(i>=2 && j>=2 && i<n) mx = max(mx,dp1[i-1][j]+a[i][j]+a[i][j-1]+dp2[i+1][j-1]+p); // go left then go down                           if(j>=2 &&i>=1&& i<n) mx = max(mx,dp1[i-1][j]+a[i][j]+a[i][j+1]+dp2[i+1][j]+p);//come right and go back                          if(j>=2 && i<n && j<m) mx = max(mx,dp1[i][j]+a[i+1][j]+dp2[i][j+1]+p);//come down and go back                                  }     } 	cout<<mx<<endl; }
 #include <bits/stdc++.h>  #define sc(x) scanf("%d",&x); #define sc2(x,y) scanf("%d%d",&x,&y); #define pr(x) printf("%d \n",x); #define scll(x) scanf("%lld",&x); #define scll2(x,y) scanf("lld",&x,&y); #define prll(x) printf("%lld \n",x); #define ll long long #define PII  pair<int,int>  using namespace std;  int mod=1e9 + 7;  struct tree {     int sum;     int l,r; } segtree[5000001]; inline tree merg(tree a,tree b){     tree c;     c.sum = ( a.sum | b.sum );     return c; } void buildtree(int i,int l,int r,int s[]) {     if(l==r)     {         segtree[i].sum=s[l];     //    cout<<i<<" "<<segtree[i].sum<<endl;         return;     }     buildtree( 2*i , l , (l+r)/2 , s );     buildtree( 2*i+1 , 1+(l+r)/2 , r , s );     segtree[i] = merg(segtree[2*i], segtree[2*i+1]);  //   cout<<i<<" "<<segtree[i].sum<<endl; } void updatetree(int i,int l,int r,int x,int y) {     if( l==x && r==x )     {         segtree[i].sum = y;         return;     }     else if( x <= (l+r)/2 ) updatetree( 2*i , l , (l+r)/2 , x , y );     else updatetree( 2*i+1 , (l+r)/2+1 , r , x , y );     segtree[i] = merg(segtree[2*i], segtree[2*i+1]); } tree query(int i,int l,int r,int c,int d) {     if( c==l && d==r ) return segtree[i];     else if( d <= (l+r)/2 ) return query( 2*i , l , (l+r)/2 , c , d );     else if( (l+r)/2 < c ) return query(2*i+1 , 1+(l+r)/2 , r , c , d);     else     {         tree a = query( 2*i, l , (l+r)/2 , c , (l+r)/2 );         tree b = query( 2*i+1 , 1+(l+r)/2 , r ,  1+(l+r)/2 , d );         tree mer;         mer = merg(a, b);         return mer;     } }   int ar[1000000+100];  ll p[1000000+100]; int main() {     p[0]=1;     int n,q;     sc2(n,q)     for(int i=0;i<n;i++){         sc(ar[i])         p[i+1]=(2*p[i])%mod;     }      buildtree(1,0,n-1,ar);     int x,l,r;     ll ans;     while(q--){         sc(x)sc2(l,r)         if(x==1){             ans = ((ll)query(1,0,n-1,l-1,r-1).sum * p[r-l])%mod;             prll(ans)         }         else{             updatetree(1,0,n-1,l-1,r);         }     }  } 
#include<iostream> #include<cstdio>   using namespace std;   int main(){     int tcs;     scanf("%d", &tcs);          while(tcs--){         int N, M;         int student_list[101] = {0};         int teacher_list[101] = {0};           scanf("%d", &M);         for(int i=0; i<M; i++)             scanf("%d", &student_list[i]);           scanf("%d", &N);         for(int i=0; i<N; i++)             scanf("%d", &teacher_list[i]);           int DIST[N+1][M+1];         for(int i=0; i<=M; i++)             DIST[0][i] = i;         for(int i=0; i<=N; i++)             DIST[i][0] = i;           for(int r=1; r<=N; r++){           for(int c=1; c<=M; c++){               if(student_list[c-1] == teacher_list[r-1]){                  DIST[r][c] = DIST[r-1][c-1];                } else {                  int min_val = min(DIST[r-1][c], DIST[r][c-1]);                  min_val = min(min_val, DIST[r-1][c-1]);                  DIST[r][c] = min_val+1;               }           }         }         /*         for(int r=0; r<=N; r++){           for(int c=0; c<=M; c++)               printf("%d", DIST[r][c]);           cout << endl;         }*/         printf("%d\n", DIST[N][M]);     }     return 0; } 
/*God is greater than any problem that u have and u have to not worry because when u pray and then worry, the worry nullify your prayer He is right here, right now !! */  #include <bits/stdc++.h> using namespace std; #define bitcnt __builtin_popcount #define ln length() #define rep(i, n) for(int i = 0; i < n; i++) #define rrep(i, n) for(int i = n - 1; i >= 0; i--) #define all(a)  a.begin(),a.end() #define LL long long #define limit 1000006 #define sl(n) scanf("%lld", &n) #define s(n)  scanf("%d", &n) #define pl(n) printf("%lld", n) #define pi(n)  printf("%d", n) #define pb push_back #define pn printf("\n") #define mod 1000000007 typedef vector<LL> row; typedef vector<row> matrix;  int in[26], out[26]; int graph[26][26]; int visited[26];  void print(LL *arr, LL n) { 	rep(i, n) cout << arr[i] << " "; 	cout << endl; }  bool check() { 	int flag = 0, flag1 = 0; 	rep(i, 26) { 		switch(in[i] - out[i]) { 			case 0 : 				break; 			case 1 : 				if(flag) return false; 				flag = 1; break; 			case -1 : 				if(flag1) return false;; 				flag1 = 1; break; 			default : 				return false; 		} 	} 	return true;	 }  void dfs(int v) { 	visited[v] = 1; 	rep(i, 26) { 		if(!visited[i] && graph[v][i]) { 			dfs(i); 		} 	} } bool fun() { 	if(!check()) return false; 	int i; 	//finding vectex 	for(i = 0; i < 26; i++) { 		if(in[i] != 0 || out[i] != 0) { 			break; 		} 	} 	//check whether from this vertex all vertices are visited are not 	dfs(i); 	int totalvertices = 0, visitedvertices = 0; 	rep(i, 26) if(visited[i]) visitedvertices++; 	rep(i, 26) if(in[i] != 0 || out[i] != 0) totalvertices++; 	return (totalvertices == visitedvertices); }  void solve() { 	//clearing step 	memset(in, 0, sizeof(in)); 	memset(out, 0, sizeof(out)); 	memset(graph, 0, sizeof(graph)); 	memset(visited, 0, sizeof(visited)); 	int n; 	s(n); 	char str[10005]; 	rep(i, n) { 		scanf("%s", str); 		int l = strlen(str); 		out[str[0] - 'a']++; 		in[str[l - 1] - 'a']++; 		graph[str[0] - 'a'][str[l - 1] - 'a']++; 		graph[str[l - 1] - 'a'][str[0] - 'a']++;	 	} 	bool ans = fun(); 	if(ans) { 		puts("The journey continues."); 	} 	else { 		puts("Journey ends here."); 	} }  int main() { 	int t; 	scanf("%d", &t); 	while(t--) { 		solve(); 	} 	return 0; } 
//#pragma warning (disable: 4786)  #include <sstream> #include <queue> #include <set> #include <map> #include <cstdio> #include <cstdlib> #include <cctype> #include <cmath> #include <iostream> #include <string> #include <vector> #include <algorithm> #include <bitset> #include <list> #include <string.h> using namespace std; #define print1(a)    cout<<a<<endl #define print2(a,b) cout<<a<<" "<<b<<endl #define print3(a,b,c) cout<<a<<" "<<b<<" "<<c<<endl #define oo          (1<<30) #define PI          3.141592653589793 #define pi          (2*acos(0)) #define ERR         1e-5 #define PRE         1e-8 #define SZ(s)       ((int)s.size()) #define LL          unsigned long long #define ISS         istringstream #define OSS         ostringstream #define VS          vector<string> #define VI          vector<int> #define VD          vector<double> #define VLL         vector<long long> #define SII         set<int>::iterator #define SI          set<int> #define mem(a,b)    memset(a,b,sizeof(a)) #define fr(i,a,b)   for(i=a;i<=b;i++) #define frn(i,a,b)  for(i=a;i>=b;i--) #define fri(a,b)    for(i=a;i<=b;i++) #define frin(a,b)   for(i=a;i>=b;i--) #define frj(a,b)    for(j=a;j<=b;j++) #define frjn(a,b)   for(j=a;j>=b;j--) #define frk(a,b)    for(k=a;k<=b;k++) #define frkn(a,b)   for(k=a;k>=b;k--) #define frl(a,b)    for(l=a;l<=b;l++) #define frln(a,b)   for(l=a;l>=b;l--) #define REP(i,n)    for(i=0;i<n;i++) #define EQ(a,b)     (fabs(a-b)<ERR) #define all(a,b,c)  for(int I=0;I<b;I++)    a[I] = c #define CROSS(a,b,c,d) ((b.x-a.x)*(d.y-c.y)-(d.x-c.x)*(b.y-a.y)) #define sqr(a)      ((a)*(a)) #define FORE(i,a)   for(typeof((a).begin())i=(a).begin();i!=(a).end();i++) #define typing(j,b) typeof((b).begin()) j=(b).begin(); #define BE(a)       a.begin(),a.end() #define rev(a)      reverse(BE(a)); #define sorta(a)    sort(BE(a)) #define pb          push_back #define popb        pop_back #define round(i,a)  i = ( a < 0 ) ? a - 0.5 : a + 0.5; #define makeint(n,s)  istringstream(s)>>n #define inpow(a,x,y) int i; a=x;fri(2,y)  a*=x #define cntbit(mask) __builtin_popcount(mask) #define debug_array(a,n) for(int i=0;i<n;i++) cerr<<a[i]<<" "; cerr<<endl; #define debug_matrix(mat,row,col) for(int i=0;i<row;i++) {for(int j=0;j<col;j++) cerr<<mat[i][j]<<" ";cerr<<endl;}  template<class T1> void debug(T1 e){cout<<e<<endl;} template<class T1,class T2> void debug(T1 e1,T2 e2){cout<<e1<<"\t"<<e2<<endl;} template<class T1,class T2,class T3> void debug(T1 e1,T2 e2,T3 e3){cout<<e1<<"\t"<<e2<<"\t"<<e3<<endl;} template<class T1,class T2,class T3,class T4> void debug(T1 e1,T2 e2,T3 e3,T4 e4){cout<<e1<<"\t"<<e2<<"\t"<<e3<<"\t"<<e4<<endl;} template<class T1,class T2,class T3,class T4,class T5> void debug(T1 e1,T2 e2,T3 e3,T4 e4,T5 e5){cout<<e1<<"\t"<<e2<<"\t"<<e3<<"\t"<<e4<<"\t"<<e5<<endl;} template<class T1,class T2,class T3,class T4,class T5,class T6> void debug(T1 e1,T2 e2,T3 e3,T4 e4,T5 e5,T6 e6){cout<<e1<<"\t"<<e2<<"\t"<<e3<<"\t"<<e4<<"\t"<<e5<<"\t"<<e6<<endl;} template<class T> void debug(vector< vector<T> > e,int row,int col){int i,j;REP(i,row) {REP(j,col) cout<<e[i][j]<<" ";cout<<endl;} cout<<endl;} template<class T> void debug(vector< basic_string<T> > e,int row,int col){int i,j;REP(i,row) {REP(j,col) cout<<e[i][j];cout<<endl;} cout<<endl;} template<class T> void debug(T e[110][110],int row,int col){int i,j;REP(i,row) {REP(j,col) cout<<e[i][j]<<" ";cout<<endl;}} template<class T> string toString(T n){ostringstream oss;oss<<n;oss.flush();return oss.str();} int toInt(string s){int r=0;istringstream sin(s);sin>>r;return r;} bool isVowel(char ch){ch=tolower(ch);if(ch=='a' || ch=='e' || ch=='i' || ch=='o' || ch=='u')return true;return false;} bool isUpper(char c){return c>='A' && c<='Z';} bool isLower(char c){return c>='a' && c<='z';} //*************************************************My Code Starts Here********************************************************************************* string Addition(string a,string b); //Addition any two string string Multiplication(string a,string b); //Multiplication between a and b string Multiplication(string a,int k);  //Multiplication between a and int k string Subtraction(string a,string b);  // Subtraction from a to b(a always >=b) string Division(string a,string b); //Division return a/b string Division(string a,int k);    //Division return a/k string Div_mod(string a,string b);  //Modulus of Division a%b int    Div_mod(string a,int k);     //Modulus of Division a%k string cut_leading_zero(string a);  //leading zero cut 001 -> 1 int    compare(string a,string b);  //(1 means a>b) (-1 means a<b) (0 means a=b) #define REV(i,n) for (i=n;i>=0;i--) #define FOR(i,p,k) for (i=p; i<k;i++)  string Multiplication(string a,string b) {     int i,j,multi,carry;     string ans,temp;      ans="0";     REV(j,SZ(b)-1)     {         temp="";         carry=0;         REV(i,SZ(a)-1)         {             multi=(a[i]-'0')*(b[j]-'0')+carry;             temp+=(multi%10+'0');             carry=multi/10;         }         if(carry)   temp+=(carry+'0');         rev(temp);         temp+=string(SZ(b)-j-1,'0');         ans=Addition(ans,temp);     }     ans=cut_leading_zero(ans);     return ans; } string Multiplication(string a,int k) {     string ans;     int i,sum,carry=0;      REV(i,SZ(a)-1)     {         sum=(a[i]-'0')*k+carry;         carry=sum/10;         ans+=(sum%10)+'0';     }     while(carry)    {ans+=(carry%10)+'0';carry/=10;}     rev(ans);     ans=cut_leading_zero(ans);     return ans; }  string Addition(string a,string b) {     int carry=0,i;     string ans;      if(SZ(a)>SZ(b)) b=string(SZ(a)-SZ(b),'0')+b;     if(SZ(b)>SZ(a)) a=string(SZ(b)-SZ(a),'0')+a;     ans.resize(SZ(a));     REV(i,SZ(a)-1)     {         int sum=carry+a[i]+b[i]-96;         ans[i]=(char)(sum%10+'0');         carry=sum/10;     }     if(carry)   ans.insert(0,string(1,carry+'0'));     ans=cut_leading_zero(ans);     return ans; }  string Subtraction(string a,string b) {     int borrow=0,i,sub;     string ans;     if(SZ(b)<SZ(a)) b=string(SZ(a)-SZ(b),'0')+b;     REV(i,SZ(a)-1)     {         sub=a[i]-b[i]-borrow;         if(sub<0)         {             sub+=10;             borrow=1;         }         else borrow=0;         ans+=sub+'0';     }     rev(ans);     ans=cut_leading_zero(ans);     return ans; }  string Division(string a,string b) {     string mod,temp,ans="0";     int i,j;      REP(i,SZ(a))     {         mod+=a[i];         mod=cut_leading_zero(mod);         FOR(j,0,10)         {             temp=Multiplication(b,j);             if(compare(temp,mod)==1)                 break;         }         temp=Multiplication(b,j-1);         mod=Subtraction(mod,temp);         ans+=(j-1)+'0';     }     mod=cut_leading_zero(mod);     ans=cut_leading_zero(ans);     return ans; }  string Division(string a,int k) {     int i,sum=0;     string ans="0";      REP(i,SZ(a))     {         sum=(sum*10+(a[i]-'0'));         ans+=(sum/k)+'0';         sum=sum%k;     }     ans=cut_leading_zero(ans);     return ans; }  string Div_mod(string a,string b) {     string mod,temp,ans="0";     int i,j;      REP(i,SZ(a))     {         mod+=a[i];         mod=cut_leading_zero(mod);         FOR(j,1,10)         {             temp=Multiplication(b,j);             if(compare(temp,mod)>0)                 break;         }         temp=Multiplication(b,j-1);         mod=Subtraction(mod,temp);         ans+=(j-1)+'0';     }     mod=cut_leading_zero(mod);     ans=cut_leading_zero(ans);     return mod; }  int Div_mod(string a,int k) {     int i,sum=0;      REP(i,SZ(a))         sum=(sum*10+(a[i]-'0'))%k;     return sum; }  int compare(string a,string b) {     int i;     a=cut_leading_zero(a);     b=cut_leading_zero(b);     if(SZ(a)>SZ(b)) return 1;   //bigger     if(SZ(a)<SZ(b)) return -1;  //smaller     REP(i,SZ(a))         if(a[i]>b[i])   return 1;   //bigger         else if(a[i]<b[i])  return -1; //smaller     return 0;   //equal }  string cut_leading_zero(string a) {     string s;     int i;     if(a[0]!='0')   return a;     REP(i,SZ(a)-1)  if(a[i]!='0')   break;     FOR(i,i,SZ(a))  s+=a[i];     return s; }  string gcd(string a,string b) {     if(b=="0") return a;     return gcd(b,Div_mod(a,b)); }  void make(string a,string b) {     if(a=="1")     {         print1(b);         return;     }      string x=Division(b,a);     if(Div_mod(b,a)!="0") x=Addition(x,"1");     cout<<x<<" ";      string numo=Subtraction(Multiplication(a,x),b);     string deno=Multiplication(b,x);     string d=gcd(numo,deno);     numo=Division(numo,d);     deno=Division(deno,d);     make(numo,deno); }   int main() {     string a,b;     while(cin>>a>>b)     {         if(a=="1"&&b=="1") break;         make(a,b);     }     return 0; } 
#include <bits/stdc++.h>  using namespace std;  const int N = 505; int sz;  vector < int > adj[N]; int color[N];  void reset () { 	for (int i = 0; i < N; i++) 		adj[i].clear (); }  bool dfs (int v, int col) { 	sz++; 	color[v] = col; 	for (int i = 0; i < adj[v].size (); i++) 		if (color[adj[v][i]] == -1) 		{ 			if (!dfs (adj[v][i], col ^ 1)) 				return false; 		} 		else if (color[adj[v][i]] == col) 			return false; 	return (sz >= 2); }  bool Check (int n) { 	memset (color, -1, sizeof (color)); 	int cnt = 0; 	bool bp = false; 	for (int i = 0; i < n; i++) 		if (color[i] == -1) 		{ 			cnt++; 			sz = 0; 			bp |= dfs (i, 0); 		} 	return (bp & cnt >= 2); }  int main () { 	int T, n, m, x, y; 	cin >> T; 	while (T--) 	{ 		cin >> n >> m; 		reset (); 		for (int i = 0; i < m; i++) 		{ 			cin >> x >> y; 			adj[x].push_back (y); 			adj[y].push_back (x); 		} 		if (Check (n)) 			cout << "YES" << endl; 		else 			cout << "NO" << endl; 	} 	return 0; }
/* author :  R Anirudh  */  #include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <cstring> #include <queue> #include <cassert> #include <climits> #include <limits> using namespace std; #define SIZE(A) ((int)(A.size())) #define MSET(A,x) memset(A,x,sizeof(A)); #define FILL(A,x) fill(A.begin(),A.end(),x) #define REP(i,N) for(int i=0;i<(int)(N);i++) #define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++) #define REV(i,a,b) for(int i=(int)(a);i>=(int)(b);i--) #define TR(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) #define ALL(x) x.begin(),x.end() #define INF (INT_MAX/2) #define LLINF (LONG_LONG_MAX/2LL) #define EPS 1e-12 #define GI ({int t;scanf("%d",&t);t;}) #define GL ({long long t;scanf("%lld",&t);t;}) #define GF ({double t;scanf("%lf",&t);t;}) #define bitCount(n) __builtin_popcount(n) #define MOD 10000009 #define MAXN 1000005 #define FIX(a) (((a)%MOD+MOD)%MOD) typedef long long LL; typedef unsigned long long ULL; #define pb push_back  list<int> *adj; bool *visited; int *costs; int component; list<int> *paths;  void dfs_util(int);  void dfs(int n){ component=0; FOR(i,0,n){ if(!visited[i]){ dfs_util(i); component++; } } }  void dfs_util(int v){  visited[v]=true; paths[component].pb(v); list<int>::iterator it; for(it=adj[v].begin();it!=adj[v].end();it++){  if(!visited[*it]){   dfs_util(*it); } } }   int main(){   int t; cin>>t; while(t--){ int n; LL m; scanf("%d %lld",&n,&m); adj = new list<int>[n]; visited = new bool[n]; costs = new int[n]; paths = new list<int>[n]; FOR(i,0,n){ visited[i]=false; } FOR(i,0,n){ scanf("%d",&costs[i]); } FOR(i,0,m){ int a,b; scanf("%d %d",&a,&b); a--; b--; adj[a].pb(b); adj[b].pb(a); }  dfs(n); LL total=0; list<int>::iterator it; FOR(i,0,component){ int min=INT_MAX;  for(it=paths[i].begin();it!=paths[i].end();it++){ if(costs[*it]<min){   min=costs[*it]; } } total+=min; }   printf("%lld\n",total); } return 0; } 
#include<iostream> #include<algorithm> #include<stdio.h> #include<stdlib.h> #include<string.h> #include<math.h>  using namespace std; typedef long long int llint; template <typename customDataType> void fastread(customDataType * a) {     char c=0; *a=0;     while(c<33){c=getchar_unlocked();}     while(c>33){*a=(*a<<3)+(*a<<1)+c-'0'; c=getchar_unlocked();}     return; }//fastread ends   int main() {     int numberOfPlanes,minToWish,seconds,xtemp,ytemp,tupdate;     int ppos_x[10000];     int ppos_y[10000];     int xchange[10000];     int ychange[10000];     float radius[10000];     fastread(&numberOfPlanes);     fastread(&minToWish);     float rmin=0,rmin_in;      for(int i=0;i<numberOfPlanes;++i)     {         fastread(&ppos_x[i]);         fastread(&ppos_y[i]);         fastread(&xchange[i]);         xchange[i] -= ppos_x[i];    //Xf-Xi;         fastread(&ychange[i]);         ychange[i]-= ppos_y[i];    //Yf-Yi;         radius[i] = sqrt(pow((llint)ppos_x[i],2)+pow((llint)ppos_y[i],2));     }      rmin=3000;     for(seconds=0;seconds<=1000;++seconds)     {         rmin_in=0;         for(int i=0;i<numberOfPlanes;++i)         {             xtemp = ppos_x[i] + xchange[i]*seconds;             ytemp = ppos_y[i] + ychange[i]*seconds;             radius[i] = sqrt(pow((llint)xtemp,2)+pow((llint)ytemp,2));         }         sort(radius,radius+numberOfPlanes);         rmin_in=radius[minToWish-1];         if(rmin > rmin_in)         {             rmin = rmin_in;             tupdate=seconds;         }     }     printf("%.2f\n%d\n",rmin,tupdate);     return 0; } 
/*   Name: Shed Problem   Copyright:    Author: Shobhit Saxena   Date: 17/12/12 21:37   Description: Dynamic solution of the shed problem. This algo takes O(lb) to solve the matrix. Better than the naive algorithm tht takes O(l^2 b^2).  */    #include<stdio.h>  #define MAX 1000  #define GETCHAR getchar//_unlocked  #define min(a,b,c) (a<b?(a<c?a:c):(b<c?b:c))  int matrix[1000][1000]; int main() {     int r,c;     char temp;          scanf("%d %d ",&r,&c);     int max=0;          for(int i=0;i<r;i++)     {             for(int j=0;j<c;j++)             {                     scanf(" %c",&temp);                     if(temp=='T') matrix[i][j]=0;                     else if(temp=='.')                     {                          if(!i||!j) matrix[i][j]=1;                          else                           {                               matrix[i][j]=1+min(matrix[i][j-1],matrix[i-1][j],matrix[i-1][j-1]);                                   }                               }                     max=max>matrix[i][j]?max:matrix[i][j];                                                   }               }     printf("%d\n",max?(max*max):-1);     return 0; } 
// This works!! //Data-structures includes #include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<string>   //Other Includes #include<iostream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath>  using namespace std;  #define pb		push_back #define mp	 	make_pair #define fill(a,v) 	memset(a, v, sizeof(a)) #define sz		size() #define all(x)		x.begin(), x.end() #define INDEX(arr,ind)	(lower_bound(all(arr),ind)-arr.begin()) #define FF		first #define SS		second #define T(t)            int t;scanf ("%d",&t);while (t--) typedef vector<int> VI; typedef vector<vector<int> > VVI; typedef long long LL; typedef vector<long long> VLL; typedef pair<int,int> PII; typedef vector<pair<int,int> > VPII; typedef pair<double,double> pdd;  int main() { 	int n; 	int i,j,k,flag=0,len;	 	char arr[111][111]; 	scanf ("%d",&n); 	for (i=0;i<n;i++) 		scanf ("%s",arr[i]); 	while (1) 	{ 		char s[111]; 		scanf ("%s",s); 		if (s[0]=='0') break; 		len=strlen(s); 		int pr=0; 		for (i=0;i<n;i++) 		{ 			for (j=0;j<n;j++) 			{ 				flag=0; 				if (n-j>=len) 				{ 					for (k=0;k<len;k++){ 						if (arr[i][j+k]!=s[k]){ 							flag=1;break;} 					} 					if (flag==0 && pr==0){  						printf ("%d,%d %d,%d\n",i+1,j+1,i+1,j+len); 						pr=1; 					} 				} 				flag=0; 				if (j+1>=len) 				{ 					for (k=0;k<len;k++){ 						if (arr[i][j-k]!=s[k]){ 							flag=1;break;} 					} 					if (flag==0 && pr==0){ 						printf ("%d,%d %d,%d\n",i+1,j+1,i+1,j+2-len); 						pr=1; 					} 				} 				flag=0; 				if (n-i>=len) 				{ 					for (k=0;k<len;k++){ 						if (arr[i+k][j]!=s[k]){ 							flag=1;break;} 					} 					if (flag==0 && pr==0){ 						printf ("%d,%d %d,%d\n",i+1,j+1,i+len,j+1); 						pr=1; 					} 				} 				flag=0; 				if (i+1>=len) 				{ 					for (k=0;k<len;k++){ 						if (arr[i-k][j]!=s[k]){ 							flag=1;break;} 					} 					if (flag==0 && pr==0){ 						printf ("%d,%d %d,%d\n",i+1,j+1,i+2-len,j+1); 						pr=1; 					} 				} 				flag=0; 				if (n-i>=len && n-j>=len) 				{ 					for (k=0;k<len;k++){ 						if (arr[i+k][j+k]!=s[k]){ 							flag=1;break;} 					} 					if (flag==0 && pr==0){ 						printf ("%d,%d %d,%d\n",i+1,j+1,i+len,j+len); 						pr=1; 					} 				} 				flag=0; 				if (j+1>=len && i+1>=len) 				{ 					for (k=0;k<len;k++){ 						if (arr[i-k][j-k]!=s[k]){ 							flag=1;break;} 					} 					if (flag==0 && pr==0){ 						printf ("%d,%d %d,%d\n",i+1,j+1,i+2-len,j-len+2); 						pr=1; 					} 				} 				if (pr==1) break; 			} 			if (pr==1) break; 		} 		if (pr==0) printf ("Not found\n"); 	} 	return 0; } 
#include <stdio.h> #include <stdlib.h> #include <math.h> #include <string.h> #include <algorithm>  #define N 200 #define K 20  int n, l[N], f[N], fm; char b[N][K], *p[N]; #define MIN(a,b) ((a)<(b)?(a):(b))  int comp(const void *a, const void *b) {     int d = strlen(*(char**)b) - strlen(*(char**)a);     if(d != 0) return d;     return strcmp(*(char**)a, *(char**)b); }  bool hopr(const char *a, const char *b) { char rep = 0; bool seen = false; for(int i = 0; a[i]; i++) { if(b[i] == rep) seen = true; if(a[i] != b[i]){ if(rep || a[i] > b[i]) return false; rep = b[i]; } } return seen; }  bool hopd(const char *a, const char *b) { int i; for(i = 0; a[i] == b[i]; i++); for(i++; a[i]; i++) if(a[i] != b[i-1]) return false; return true; }  int main() { scanf("%d", &n); for(int i = 0; i < n; i++) { scanf("%s", b[i]); p[i] = b[i]; } qsort(p, n, sizeof(char*), comp);  for(int i = 0; i < n; i++) l[i] = strlen(p[i]); fm = 0; for(int i = n-1; i >= 0; i--) { f[i] = 1; for(int j = i+1; j < n && l[i] - l[j] <= 1; j++) { if(((l[i]==l[j] && hopr(p[i], p[j])) || (l[i]==l[j]+1 && hopd(p[i],p[j]))) && f[i] < f[j]+1) f[i] = f[j]+1; } if(f[i] > fm) fm = f[i]; } printf("%d\n", fm); //system("pause"); return 0; } 
#include<cstdio> void getdata(int *arry , int size); void display(int *arry , int size); int result(int *input , int size);  int main() {   int output[1000];int ctr=0;   int coins;   scanf("%d " ,&coins);   while( coins>0)   {     int *input = new int[coins];     getdata(input , coins);     output[ctr]=result(input , coins);     ctr++;     scanf("%d ",&coins);   }   display(output , ctr);   return 0; }  int result(int *input , int size) {    int add=1;int count=0;    if(size==1)      return 1;    for(int i=1;i<size-1;i++)    {       if((add+input[i])<input[i+1])       { 	 add+=input[i]; 	 count++;       }    }    return (count+2); }  void getdata(int *arry , int size) {     for(int i=0;i<size;i++)    {      scanf("%d  " , &arry[i]);          } }  void display(int *arry , int size) {    for(int i=0;i<size;i++)    {      printf("%d\n" , arry[i]);    } }      
    #include<iostream>     #include<cstring>     #include<cmath>     #include<vector>     #include<map>     using namespace std;     static int factor(int a,int b)     {     	int co=0;  	   while(b*b <= a)     	{     		if(a%b==0)     		co+=factor(a/b,b);     		b++;     	}     	return co+1;     }     int main(void)     {     	while(1)     	{     		int n,c;     		cin>>n;     		if(n==0)     			break;     		c = factor(n,2);     		cout<< c-1 << endl;     	}     	return 0;     } 
#include<stdio.h> #include<algorithm> using namespace std; int main() { 	int n,a[50],i,j,l,b[50],count; 	while(scanf("%d",&n)) 	{ 		if(!n) 			break; 		for(i=0;i<n;i++) 			scanf("%d",&a[i]); 		sort(a,a+n); 		 		j=n/2-1; 		l=n-1; 		for(i=0;j>=0;) 		{ 			b[i]=a[j]; 			b[i+1]=a[l]; 			i = i+2; 			j--; 			l--; 		} 		b[i]=a[n/2]; 		count =0; 		for(i=1;i<n;i++) 		{ 			count += abs(b[i]-b[i-1]); 		} 		printf("%d\n",count); 	} 	return 0; }
// A Negative Base Problem // URL : http://www.codechef.com/problems/ENCD05 #include <iostream> #include <cstdio> #include <cstring> #include <algorithm>  using namespace std;  typedef long long ll; typedef unsigned long long ull;  string tonegbin(int x) { 		 string res = ""; 		 while(x != 0) 		 { 					if(((int)abs(x)) % 2 == 1) 					{ 						  res = "1" + res; 						  x = (x - 1) / -2; 			  		} 			  		else 			  		{ 						 res = "0" + res; 						 x /= -2; 			 	  	} 		 } 		 return res; }  int main() { 	 int n; 	 while(scanf("%d",&n) > 0) 	 { 					if(n == 0)break;   				  cout << tonegbin(n) << endl; 	 } 	 system("pause"); 	 return 0; }
#include<cstdio> #define max(a,b) ( ((a)>(b)) ? (a):(b)) int a[101][101],b[101][101]; int main() { 	int n; 	while(scanf("%d",&n)!=EOF) 	{ 		if(!n)break; 		for(int i=0;i<n;i++)for(int j=0;j<n;j++) 		{ 			scanf("%d",&a[i][j]); 			b[i][j] = (j==0)?a[i][j]:(b[i][j-1]+a[i][j]); 		} 		int maxsum = 0; 		for(int c1=0;c1<n;c1++)for(int c2=c1;c2<n;c2++) 		{ 			int temp = 0; 			for(int r=0;r<n;r++) 			{ 				temp = max(0,temp+(b[r][c2] - (c1==0?0:b[r][c1-1]) )); 				maxsum = max(maxsum,temp);  			} 		} 		printf("%d\n",maxsum); 	} } 
#ifndef PROGRAMMING_CONTESTS_H #define PROGRAMMING_CONTESTS_H #include <algorithm> #include <bitset> #include <cctype> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> #include <ctime> #include <iostream> #include <limits> #include <list> #include <map> #include <queue> #include <set> #include <sstream> #include <string> #include <typeinfo> #include <utility> #include <vector> #ifdef LOCALHOST static FILE* _freopen=freopen("input.txt","r",stdin); #else #define NDEBUG #endif #include <cassert> using namespace std;   typedef long long LL; typedef unsigned long long ULL; typedef pair<int,int> PII;   #define IT(c) typeof(c.begin()) #define PB push_back #define MP make_pair #define LEN(a) (sizeof(a)/sizeof(a[0])) #define ALL(c) c.begin(),c.end() #define FOR(i,a,b) for(int i=(a), _b=(b); i<_b; ++i) #define FORD(i,a,b) for(int i=(b-1), _a=(a); i>=_a; --i) #define FORE(i,c) for(IT(c) i=(c).begin(); i!=(c).end(); ++i)   static int RI(){int res;int r=scanf("%d ",&res);assert(r==1);return res;} static LL RLL(){LL res;int r=scanf("%lld ",&res);assert(r==1);return res;} static ULL RULL(){ULL res;int r=scanf("%llu ",&res);assert(r==1);return res;} static double RD(){double res;int r=scanf("%lf ",&res);assert(r==1);return res;} static string RS(){char buf[2000];int r=scanf("%s ",buf);assert(r==1);return string(buf);} static string RL(){string res;getline(cin,res);assert(cin.good());return res;} //Requires and discards line break at end of line. static const double PI=acos(-1.0), EPS=1e-10; template<typename T> static string str(T x){stringstream ss;ss<<x;return ss.str();} template<typename A,typename V> static void fill(A& a,V v){fill_n((V*)a,sizeof(a)/sizeof(v),v);} // Requires A is a V array. static double timer(){return 1.0*clock()/CLOCKS_PER_SEC;}   #endif //PROGRAMMING_CONTESTS_H     static int** comb(int n, int m=numeric_limits<int>::max()) {   assert(n >= 0 && m >= 1);   int** c = new int*[n+1];   for(int i = 0; i <= n; ++i) {     c[i] = new int[n+1]; memset(c[i],0,sizeof(c[i]));     c[i][0] = (c[i][i] = 1);     for(int j = 1; j <= i/2; ++j) {       c[i][j] = (c[i][i-j] = (c[i-1][j-1]+c[i-1][j])%m);       assert(0 <= c[i][j] && c[i][j] < m);     }   }   return c; }     LL mem[15][55][55][55];   int main(int argc, char** argv) {   int** ch=comb(15);   int n,a,b,c;   while(true){     cin>>n>>a>>b>>c;     if(n==0)break;     FORD(i,1,n+2){       FOR(aa,0,a+1){         FOR(bb,0,b+1){           FOR(cc,0,c+1){             LL res=0;             if(i==n+1)res=1;             else {               //use 1 char               if(aa>=i)res+=mem[i+1][aa-i][bb][cc];               if(bb>=i)res+=mem[i+1][aa][bb-i][cc];               if(cc>=i)res+=mem[i+1][aa][bb][cc-i];               //use 2 chars               if(i%2==0){                 if(aa>=i/2&&bb>=i/2)res+=ch[i][i/2]*mem[i+1][aa-i/2][bb-i/2][cc];                 if(aa>=i/2&&cc>=i/2)res+=ch[i][i/2]*mem[i+1][aa-i/2][bb][cc-i/2];                 if(bb>=i/2&&cc>=i/2)res+=ch[i][i/2]*mem[i+1][aa][bb-i/2][cc-i/2];                                                         }               //use 3 chars               if(i%3==0&&aa>=i/3&&bb>=i/3&&cc>=i/3)res+=ch[i][i/3]*ch[2*i/3][i/3]*mem[i+1][aa-i/3][bb-i/3][cc-i/3];             }             mem[i][aa][bb][cc]=res;           }         }       }     }     cout<<mem[1][a][b][c]<<endl;   }   return 0; }
#include<iostream> #include<stdio.h> int main() { 		 long long int n,cnt; 		 while(true) 		 	{ 		 	    scanf("%lld",&n); 		 	    if(n==0){break;} 		 	if(n%2==0) 		 		{ 		 		    cnt=(n*(n-2)*(2*n-5))/24; 		 		} 		 	else 		 		{ 		 		    cnt=((n-1)*(n-3)*(2*n-1))/24; 		 		} 		 		printf("%lld\n",cnt); 		 	}     return 0; } 
#include <iostream> #include <cstdlib>  using namespace std;  struct column { 	int *array; 	struct column *next; };  typedef struct column col;  int compare(int b[], int v[], int N);  int main() { 	int N; 	int i; 	int j; 	int count; 	int pattern = 0; 	int done = 0; 	int v[1000]; 	int *a; 	int *b; 	col *head; 	col *ptr;  	cin >> N;  	while(N != 0) { 		cin >> i >> j; 		pattern = j; 		head = new col; 		count = 0; 		 		b = (int *) malloc(sizeof(int) *  N); 		b[0] = b[N - 1] = 1;  		for(int loop = 0; loop < N; loop++) { 			cin >> v[loop]; 		}  		head -> array = a = v; 		head -> next = NULL; 		count++; 		 		ptr = head;  		for(count = 2; count <= j; count++) { 			for(int index = 1; index < N - 1; index++) { 				b[index] = (b[index - 1] * a[index + 1] + 1) / a[index]; 				if(count == j && (index + 1) == i) { 					cout << b[index] << endl; 					done = 1; 					break; 				} 			}  			if(done == 1) { 				done = 0; 				break; 			} 			if(compare(b,v,N)) { 				ptr -> next = new col; 				ptr = ptr -> next; 				ptr -> array = b; 				ptr -> next = NULL; 				a = b; 				b = (int *) malloc(sizeof(int) * N); 				b[0] = b[N - 1] = 1; 			} 			else { 				pattern = count - 1; 				j = j % pattern; 				if(j == 0) { 					j = pattern; 				} 				ptr = head; 				while(j != 1) { 					ptr = ptr -> next; 					j--; 				} 				cout << ptr -> array[i - 1] << endl; 				break; 			}  		}  		while(head != NULL) { 			ptr = head; 			head = head -> next; 			free(ptr); 		} 		 		cin >> N;  	}  	return 0; }  int compare(int b[], int v[], int N) { 	for(int i = 0; i < N; i++) { 		if(b[i] != v[i]) { 			return 1; 		} 	}  	return 0; } 
//DS includes #include<vector> #include<stack> #include<set> #include<map> #include<queue> #include<deque> #include<bitset> #include<complex>  //Other Includes #include<sstream> #include<fstream> #include<iostream> #include<algorithm> #include<cstring> #include<cassert> #include<cstdlib> #include<cstdio> #include<cmath>    #define oo 					(int)13e7 #define s(n)					scanf("%d",&n) #define sl(n) 					scanf("%lld",&n) #define sf(n) 					scanf("%lf",&n) #define fill(a,v) 				memset(a, v, sizeof a) #define ull 					unsigned long long #define ll 						long long #define bitcount 			__builtin_popcount #define all(x) 				x.begin(), x.end() #define pb( z ) 				push_back( z ) #define gcd					__gcd using namespace std;  int n; //prev = 0 not connected left thing //prev = 1 connected left thing ull dp[64][2]; int vis[64][2], vid; ull solve( int p, int prev ) { 	//cout<< n << " " << p << " " << prev << endl; 	if( p==n-1 ) 	{ 		if( prev == 0 ) 			return 1LL; 		return 2LL; 	} 	ull &d = dp[p][prev]; 	int& v = vis[p][prev]; 	if( v == vid ) 		return d; 	ll ret = 0; v = vid; 	if( prev == 0 ) 	{ 		ret = solve( p+1, 1 ) + solve( p+1, 0 ); 	} 	else  	{ 		ret = 2*solve( p+1, 1 ) + solve( p+1, 0 ); 	} 	return d=ret; }  int main() { 	 	while( cin>>n ) 	{ 		if( !n ) break; 		fill( dp, -1 ); 		++vid; 		cout<< solve( 0, 0 ) << endl; 	} 	return 0; } 
/*Author: raunakrocks Raunak Talwar Final Year CSE'15  MNNIT-Allahabad raunaktalwar00@gmail.com */ #include<bits/stdc++.h> using namespace std; typedef long long ll; #define MAXI 100005 //#define inp(n) scanf("%lld",&n) //for codeforces :P #define FOX(i,n) for(ll i=0;i<n;i++) #define FOX1(i,n) for(ll i=1;i<=n;i++) #define FOX2(i,n) for(ll i=n;i>=1;i--)  #define pb push_back #define sf scanf #define pf printf #define MOD 1000000007 #define gc getchar_unlocked void inp(ll &n) { 	n=0; 	char ch=gc(); 	ll sign=1; 	while(ch<'0'||ch>'9') 	{ 		if(ch=='-') 			sign=-1; 		ch=gc();		 	}	 	while(ch>='0'&&ch<='9') 		{ 			n=(n<<3)+(n<<1)+(ch-'0'); 			ch=gc(); 		} 		n*=sign; } ll mini(ll a,ll b){ return a>b?b:a; } ll maxi(ll a,ll b){ return a>b?a:b; } /**my n^2 algo for the problem :P ****/ char s[MAXI]; ll h[MAXI]; void solve() { 	ll l=strlen(s); 	ll ans=0; 	memset(h,0,sizeof h); 	for(ll i=0;i<l;i++) 		h[s[i]]++; 	ll cnt=0; 	//cnt will count the number of char that occur odd # of times :P 	for(ll i='a';i<='z';i++) 	{ 		if(h[i]&1) 			cnt++; 	}		 	if(cnt>1) 	{ 		printf("Impossible\n"); 		return; 	} 	ans=0; 	for(ll i=0;i<l/2;i++) 	{ 	 		ll j=l-1-i; 		if(s[i]!=s[j]) 		{ 			//two possiblity  			ll p,q; 			for(p=j;s[i]!=s[p];p--); 			for(q=i;s[j]!=s[q];q++); 			if(j-p<q-i) 			{ 				ans=(ans+(j-p)); 				for(ll k=p;k<j;k++) 					s[k]=s[k+1]; 			 			 			} 			else 			{ 				ans=(ans+(q-i)); 				for(ll k=q;k>i;k--) 					s[k]=s[k-1]; 			} 		} 	 	} 	printf("%lld\n",ans);    }    int main() { 	clock_t startTime=clock(); 	/******START: code here*********/ 	while(cin>>s) 	{ 		if(s[0]=='0') 			break; 		solve();	  	}  	/******END:code here**********/ 	clock_t endTime=clock(); 	cerr<<"\nTime:"<< double(endTime - startTime) / CLOCKS_PER_SEC <<" seconds\n" ; 	return 0; }     
#include<iostream> #include<stdio.h> #include<string.h> #include<algorithm> #include<math.h> #include<iomanip> #include<stdlib.h> using namespace std;  long long int t,n,sum,i; int main() {     scanf("%lld",&t);     while(t--)     {   sum=0;         scanf("%lld",&n);         for(i=1;i<=n;i++)         {             sum+=(i/2);         }         printf("%lld\n",sum);     }     return 0; } 
#include<iostream>   #define MAX 200000   using namespace std;   int a[MAX]; int lefty[MAX]; int righty[MAX];   int main() {     int i,n,q,x,y,max;     scanf("%d",&n);     for(i=0;i<n;i++)     {          scanf("%d",&a[i]);     }     scanf("%d",&q);     max=a[0];     lefty[0]=max;     for(i=1;i<n;i++)     {                if(a[i]>max)                {                            max=a[i];                }                     lefty[i]=max;     }     max=a[n-1];     righty[n-1]=max;     for(i=n-1;i>=0;i--)     {          if(a[i]>max)          {                      max=a[i];          }          righty[i]=max;     }             for(i=0;i<q;i++)     {         scanf("%d%d",&x,&y);         max=0;         if(x>1 && y<n)         {                 if(lefty[x-2]>righty[y])                 {                   max=lefty[x-1];                   //cout<<x-1<<":";                 }                 else                 {                    max=righty[y];                    //cout<<y<<":";                 }         }                         else if(x>1 && y==n)         {              max=lefty[x-2];         }         else if(x==1 && y<n)         {              max=righty[y];         }         printf("%d\n",max);     }     return 0; }
#include<iostream> using namespace std;  int main() {     int t;     char yy;     string y;     int T,D,len;      scanf("%d",&t);     cin.get(yy);     while(t--)     {          getline(cin,y);          len=y.length();          T=D=-1;          if(y[0]=='D' || y[len-1]=='T')          goto end;          while(y[++D]!='D' &&  D<len){}              while(y[++T]!='T' && T<len){}     //     cout<<T<<" "<<D<<endl;          while(D!=len && T!=len)          {              while(y[++D]!='D' && D<len){}              while(y[++T]!='T' && T<len){}       //       cout<<T<<" "<<D<<endl;                if(D<T)                goto end;              }              if(D==len && T==len)              printf("YES\n");              else              printf("NO\n");              continue;              end:                  printf("NO\n");              }       //       system("pause");              return 0;              }                                                 
#include<iostream> #include<bitset> #include<cstdio> #include<vector> #include<algorithm> #include<cmath> using namespace std; typedef long long int LL;   const int N = 53000; bitset<N+5> v; void seive(){     v.set();     for(int i =2;i<=N;i+=2)v[i] = 0;     v[0]=v[1] = 0;v[2]=1;     int val = sqrt(N);     for(int i =3;i<=val+1;i+=2){         if(v[i])         for(int j = i*i;j<=N;j+=(i+i)){             v[j] = false;         }     } }   LL next(int n ){     LL i,j;     for(i =n+1;i<=N;i++){         if(v[i])break;     }     for(j=i+1;j<=N;j++){         if(v[j])break;     }     return i*j; }   int main(){     int T;     seive();     scanf("%d",&T);     while(T--){         int n;         scanf("%d",&n);         LL res = next(n);         printf("%lld\n",res);     }     return 0; }      
//CODE COPY  #include <stdio.h> #include<string.h> #define MAXN 100010 #include<iostream>  using namespace std;  bool p[MAXN]; int phi[MAXN], sm[MAXN], mb[MAXN]; long long r[MAXN];  void calc() {     int i, j, k;     memset(p,0,sizeof(p));     memset(phi,0,sizeof(phi));     for( i=1 ; i<MAXN ; i++ )     {         mb[i]=1;     }        for( i=2 ; i<MAXN ; i++ )     {         if( p[i]==0 )         {             for( j=i ; j<MAXN ; j+=i )             {                 mb[j]*=-1;                 p[j]=1;             }             p[i]=0;             if( i<1000 )             {                 for( j=i*i ; j<MAXN ; j+=i*i )                 {                     mb[j]=0;                 }             }         }     }      r[1]=1;     for( i=2 ; i<MAXN ; i++ )     {         if( mb[i]!=0 )         {             k=0;             for( j=i ; j<MAXN ; j+=i )             {                 k+=(mb[j]!=0);                 phi[j]+=mb[i]*k;             }              r[i]=2*(i+phi[i]);         } // //        if( mb[i]!=0 ) //        { // //        }         else         {             r[i]=2*i-1; // square er jonno, se nije zero         }         r[i]+=r[i-1];     }  // //    for(int i=2;i<=20;i++) //    { //        cout<<i<<" "<<i+phi[i]<<endl; //    } //    cout<<endl; }  void precal() {     calc(); }  int main() {     int t, n;      precal();      scanf("%d",&t);      while(t--)     {         scanf("%d",&n);         printf("%lld\n",r[n]);     }     return 0; } 
#include<stdio.h> #include<list>  using namespace std;  int n,L,q,temp,i,x,y,v,r,j,k; int virlist[100000]; void qsort(int a[],int l,int r); void swap(int &a,int &b); int part(int a[],int l,int r); int binsearch(int num); list<int> virus; list<int>::iterator it;  int main() {     scanf("%d",&n);     for(i=0;i<n;i++)     {          scanf("%d",&temp);          virlist[i]=temp;          virus.push_back(temp);     }     qsort(virlist,0,n-1);     scanf("%d %d",&L,&q);     for(i=1;i<L;i++)     {           for(j=0;j<n;j++)           {                             virus.push_back(virlist[j]);           }     }     for(i=1;i<=q;i++)     {           scanf("%d %d %d %d",&x,&y,&v,&r);           for(j=x;j<=y;j++)           {                if(binsearch(j)!=-1)                {                      for(k=1;k<=v;k++)                      {                            virus.push_back(j);                      }                }           }           virus.sort();           it=virus.begin();           for(k=1;k<r;k++){it++;}           printf("%d\n",*it);     }     }  void qsort(int a[],int l,int r) { 	if (l<r) 	{ 		int pivot=part(a,l,r); 		qsort(a,l,pivot-1); 		qsort(a,pivot+1,r); 	} }  int part(int a[],int l,int r) {     int pivot=a[l];         while(l<r)     {                   while(pivot<=a[r] && l<=r){r--;}               if(l<r)        {            swap(a[l],a[r]);        }        while(a[l]<pivot && l<=r){l++;}        if(l<r)        {            swap(a[l],a[r]);        }     }         return l; }  void swap(int &a,int &b) {      a=a+b;      b=a-b;      a=a-b; }  int binsearch(int num) {     int loc=-1,l=0,u=n-1,found=0,mid;     while(found==0)     {             mid=(l+u)/2;             if( virlist[mid]>num ){                  u=mid ;                  if(l==u && virlist[l]!=num){found=2;}             }             else if ( virlist[mid]<num ){                  l=mid + 1 ;                  if(l==u && virlist[l]!=num){found=2;}             }             else if ( virlist[mid]==num ){                  loc=mid;                  found=1;             }     }     return loc; }       
#include <stdio.h> #include <cmath> #include <vector> #include <complex> #include <memory.h>  using namespace std;  typedef complex<double> com; const double pi = 3.1415926535897932384626433832795;  vector <com> a,b; int q[66666], cnt[66666], cc[66666]; int len,n,i;  void fft(vector <com> &a,bool inv) {   int n,m,i,j;   double ang;   com u,w,wn;   vector <com> a0,a1;   n = a.size();   if (n == 1) return;   m = n >> 1;   a0.resize(m);   a1.resize(m);   for (i=0,j=0;i<n;i+=2,j++) {     a0[j] = a[i];     a1[j] = a[i+1];   }   fft(a0,inv);   fft(a1,inv);   ang = 2.0*pi/n;   if (inv) ang = -ang;   w = 1;   wn = complex<double>(cos(ang),sin(ang));   for (i=0;i<m;i++) {     u = w*a1[i];     a[i] = a0[i]+u;     a[i+m] = a0[i]-u;     if (inv) {       a[i] /= 2;       a[i+m] /= 2;     }     w *= wn;   } }  int main() {   len = 65536;   scanf("%d",&n);   for (i=0;i<len;i++) cnt[i] = 0;   for (i=0;i<n;i++) {     scanf("%d",&q[i]);     q[i] += 10000;     cnt[q[i]]++;   }   a.resize(len);   b.resize(len);   for (i=0;i<len;i++) a[i] = com(cnt[i],0);   for (i=0;i<len;i++) b[i] = a[i];   fft(a,false);   fft(b,false);   for (i=0;i<len;i++) a[i] *= b[i];   fft(a,true);   for (i=0;i<len;i++) a[i] = (int)(a[i].real()+0.5);   for (i=0;i<len;i++) b[i] = com(cnt[i],0);   fft(a,false);   fft(b,false);   for (i=0;i<len;i++) a[i] *= b[i];   fft(a,true);   for (i=0;i<len;i++) cc[i] = (int)(a[i].real()+0.5);   for (i=0;i<len;i++)     if (i & 1) a[i] = 0;     else a[i] = com(cnt[i >> 1],0);   for (i=0;i<len;i++) b[i] = com(cnt[i],0);   fft(a,false);   fft(b,false);   for (i=0;i<len;i++) a[i] *= b[i];   fft(a,true);   for (i=0;i<len;i++) cc[i] -= (int)(a[i].real()+0.5)*3;   for (i=0;i<n;i++) cc[q[i]*3] += 2;   for (i=0;i<len;i++)     if (cc[i] > 0) printf("%d : %d\n",i-30000,cc[i]/6);   return 0; } 
#include <iostream>  using namespace std; int ar[15]={1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384};  int main() {     int n;     cin>>n;     int r;     int no=n;     int cnt=0;     while(no!=0)     {     int i;     for(i=0;ar[i]<=no;i++);     int index=i-1;     r=n%ar[index];     no=r;     cnt++;     }     cout<<cnt;     return 0; } 
#include<stdio.h> //#include<conio.h> int main() {     int k=1,n,c=2;      scanf("%d",&n);    if(n==1)  {printf("%d",n);  return 0;}               for(int m=2;m<n;m*=2)     {k=1;                       while(k<m*2)             {//printf("%d %d\n",k,c);                                    k+=2;c++;             if(c==n) {printf("%d",k); //getch();             return 0;}                                              }                          }            // getch();             return 0;}  
/*   Anurag Anand  */  #include <iostream> #include <cstdio> #include <cassert> #include <cstring> #include <cstdlib> #include <algorithm> #include <vector> #include <cmath>  using namespace std;   int main() {     char s[150];     gets(s);     char c=getchar();     int count=0;     for(int i=0;s[i]!='\0';i++)     {             if(s[i]==c) count++;     }     printf("%d\n",count);     //system("pause");     return 0;   } 
#include <iostream> #include <string> using namespace std;  int main(){ 	int n; 	string number;  	cin >> n; 	for (int k = 0; k < n; k++){ 		bool yes = true; 		cin >> number; 		for (unsigned int i = 0; i < number.length(); i++){ 			switch (number[i]){ 				case '0': 				case '8': 				case '1': break;  				case '6': number[i] = '9'; break; 				case '9': number[i] = '6'; break;  				case '2': 				case '3': 				case '4': 				case '5': 				case '7': yes = false; 			} 			if (!yes){ break; } 		}  		if (yes){ 			cout << "yes" << endl; 			for (int i = number.length() - 1; i >= 0; i--){ 				cout << number[i]; 			} 			cout << endl; 		} 		else{ 			cout << "no" << endl; 		} 	}  	return 0; }
#include<stdio.h> #include<limits.h> typedef long long int LLI; LLI min (LLI a,LLI b) { return (a<b?a:b); } int main() { int test; int x; scanf("%d",&test); while(test--) { int n; scanf("%d",&n); LLI mina=INT_MAX; long long int total=0; int i; for(i=0;i<n;++i){ scanf("%d",&x); total+=x; mina=min(mina,total/(i+1)); } printf("%lld\n",mina); } return 0; }
#include <iostream>  using namespace std;  int main() { 	 	int t; 	int n; 	int i, j, k, flag; 	long int arr[100000], ans; 	long long int left[100000], right[100000], sum; 	scanf("%d", &t); 	 	while(t--) { 		 		scanf("%d", &n); 		flag = 0; 		for(i = 0; i < n; i++) { 			scanf("%ld", &arr[i]); 		} 		 		k = 0; 		sum = 0; 		for(i = 0; i < n; i++) { 			 			sum = arr[k] + sum; 			left[i] = sum; 			k++; 		} 		 		k = n - 1; 		sum = 0; 		for(i = n - 1; i >= 0; i--) { 			 			sum = arr[k] + sum; 			right[i] = sum; 			k--; 		} 		 		 		i = 0; 		j = n - 1; 		 		while(i < n - 1 && j > 0) { 			 			//cout << "l = " << left[i] << " r = " << right[j] << endl; 			 			if(left[i] < right[j]) { 				i++; 			} else if(left[i] > right[j]) { 				j--; 			} else if(left[i] == right[j]) { 				if((j - i) == -2 || (j - i) == 2) { 					 					flag = 1; 					break; 				} 			} 			 		} 		 		if(flag == 1) { 			cout << arr[i + 1] << endl; 		} else { 			cout << "NO EQUILIBRIUM" << endl; 		} 		 		 	} 	 	return 0; 	 }
#include<bits/stdc++.h> using namespace std; typedef long long LL; const LL MOD = 274877906944LL; int main(){ 	int t; 	cin >> t; 	while(t--){ 		LL A, D, N, X; 		cin >> A >> D >> N >> X; 		LL ans = 0; 		for(int i = 0;i <= N;++i){ 			ans = ((ans*X)%MOD + (A + D*i)%MOD)%MOD; 		} 		cout << ans << "\n"; 	} 	return 0; }
#include<iostream> #include<string> #include<stdio.h> using namespace std; int main() {     int t;     long int n;     cin>>t;     while(t--)     {         cin>>n;         if(n%2==0)             cout<<n<<endl;         else             cout<<n-1<<endl;     }     return 0; } 
/*God is greater than any problem that u have and u have to not worry because when u pray and then worry, the worry nullify your prayer He is right here, right now !! */  #include <bits/stdc++.h> using namespace std; #define bitcnt __builtin_popcount #define ln length() #define rep(i, n) for(int i = 0; i < n; i++) #define rrep(i, n) for(int i = n - 1; i >= 0; i--) #define all(a)  a.begin(),a.end() #define LL long long #define limit 1000006 #define sl(n) scanf("%lld", &n) #define s(n)  scanf("%d", &n) #define pl(n) printf("%lld", n) #define pi(n)  printf("%d", n) #define pb push_back #define pn printf("\n") #define mod 1000000007 typedef vector<LL> row; typedef vector<row> matrix;  int F[1000006]; char str[1000006]; char str1[1000006]; void print(LL *arr, LL n) { 	rep(i, n) cout << arr[i] << " "; 	cout << endl; }  void computeF(string s) { 	int size = s.ln; 	F[0] = F[1] = 0; 	for(int i = 2; i <= size; i++) { 		int j = F[i - 1]; 		while(true) { 			if(s[j] == s[i - 1]) { 				F[i] = j + 1; 				break; 			} 			if(j == 0) { 				F[i] = 0; 				break; 			} 			j = F[j]; 		} 	} }  void solve() { 	scanf("%s", str); 	int l = strlen(str); 	scanf("%s", str1); 	strcat(str, "#"); 	strcat(str, str1); 	//printf("%s", str); 	string s = string(str); 	computeF(s); 	int ans = F[s.ln]; 	if(ans > l) { 		ans = l; 	} 	if(ans == 0) { 		puts("0"); 	} 	else { 		for(int i = 0; i < ans; i++) { 			printf("%c", s[i]); 		} 		printf(" %d\n", ans); 	} }  int main() { 	int t = 1; 	//scanf("%d", &t); 	while(t--) { 		solve(); 	} 	return 0; } 
#include<stdio.h> int abs(int x) {     if(x>0)return x;     else return -x; } int main() {     int a,b,d,x,m=1000000007;     char c;     scanf("%d",&a);     c=getchar();     while(c>30)     {         scanf("%d",&b);         d=abs(b-a);         if(d<m)         m=d;         a=b;         c=getchar();     }     printf("%d\n",m);     return 0; } 
#include<string.h> #include<cstdio> //#include<conio.h> int main() {     char s[100];     int i,h;     scanf("%s",s);     h=strlen(s);     if(h>=3)     printf("%c%c%c",s[h/2-1],s[h/2],s[h/2+1]);     else     printf("0");    // getch();     return 0; } 
#include<iostream> #include <math.h> using namespace std; int main() {     int a,b,flag=0;     cin>>a>>b;     while(a>0 && flag==0)     {         int c=a%10;         int temp=b;         while(temp>0 && flag==0)         {             if((temp%10)==c)             flag=1;             temp=temp/10;         }         a=a/10;     }          if(flag==1)     cout<<"TRUE"<<endl;     else     cout<<"FALSE"<<endl;     return 0; }
#include <iostream> #include <string> using namespace std; int main() {     string s,s1;     s1 = "";     int i,l;     cin >> s;     l = s.size();     for(i=0;s[i]!='\0';i++){             if(s[i] == s[l-i-1]){                     s1 += s[i];             }else{                 break;             }     }     cout << s1 << endl;     return 0; } 
// @Author - Mayank Kataria (Lovely Professional University) !  #pragma warning(disable:4786) #pragma comment(linker, "/STACK:266777216")  #include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<set> #include<map> #include<functional> #include<string> #include<cstring> #include<cstdlib> #include<queue> #include<utility> #include<fstream> #include<sstream> #include<cmath> #include<stack> #include<cstdio> #include<ctime> #include<cassert>   using namespace std;  //Macros   #define FOR(i,a,b)    for(int i=a;i<b;i++) #define FORL(i,a,b)   for(LL i=a;i<b;i++) #define PB            push_back #define mp            make_pair #define X 		      first #define Y 		      second #define len			  size() #define s(n)          scanf("%d",&n); #define slld(n)       scanf("%lld",&n); #define sf(n)         scanf("%lf",&n); #define ss(n)         scanf("%s",n); #define INF           (int)1e9 #define EPS           1e-9 #define maX(a,b)      (a>b?a:b) #define miN(a,b)      (a<b?a:b) #define MEM(a,b)      memset(a,(b),sizeof(a))  //memset(arr,0,sizeof(arr)) #define istr(S)       istringstream sin(S) #define MOD           1000000007				    typedef vector<int> VI;      //1d integer VECTOR typedef vector<VI> VVI;      //2d integer VECTOR typedef pair<int,int> PII;   //pair typedef vector<PII> VPII;    //VECTOR of pairs typedef vector<string> VS;   //VECTOR of strings typedef vector<double> VD;   //1d double VECTOR  typedef long long LL; typedef long long int LLI;   int main() { 	int t,x,y; 		scanf("%d",&t); 		 		while(t--) 		{ 			scanf("%d %d",&x,&y); 			 			if(x == 0 || y==0) 			{ 			printf("0\n"); 			continue; 			} 			 			if(x==y) 			{ 				if(x%2==0) 				printf("%d\n",x+1); 				else 				printf("%d\n",x);	 			 				continue; 			} 			 			else 			{ 				int hrs=(x/2)+(y/2)+1; 				printf("%d\n",hrs); 			} 			 		}  return 0; }
#include <cstdio> #include <iostream> #include <algorithm> using namespace std; int dp1[1002][10002],dp2[1002][10002]; int marks[1005],tim[1005]; int main(){ int n,t; cin>>n>>t; for(int i=0;i<n;i++)     cin>>marks[i]; for(int i=0;i<n;i++)     cin>>tim[i]; for(int i=0;i<=n;i++)     for(int j=0;j<=t;j++)       dp1[i][j]=dp2[i][j]=0; for(int i=1;i<=n;i++){     for(int j=1;j<=t;j++){         if(j>=tim[i-1])             dp1[i][j]=max(marks[i-1]+dp1[i-1][j-tim[i-1]],dp1[i-1][j]);         else             dp1[i][j]=dp1[i-1][j];     } } for(int i=1;i<=n;i++){     for(int j=1;j<=t;j++){         if(j>=tim[i-1]){            int a = dp1[i-1][j-tim[i-1]] + 2*marks[i-1];            int b = max(dp2[i-1][j],dp2[i-1][j-tim[i-1]]+marks[i-1]);            dp2[i][j]=max(a,b);         }         else             dp2[i][j]=dp2[i-1][j];     } } cout<<dp2[n][t]<<endl; return 0; } 
#include <iostream> #include <vector> #include <algorithm> #include <string> using namespace std; typedef long long ull;  int main() {     ios_base::sync_with_stdio(false);     int t,n;     cin>>t;     while(t--)     {         cin>>n;         int a[n];         for(int i=0;i<n;i++)             cin>>a[i];         sort(a,a+n);         int x=0, y=0;         for(int i=n-1;i>=0;i--)             if(x<y)                 x += a[i];             else                 y += a[i];         cout<<abs(x-y)<<'\n';             }     //system("pause");     return 0; } 
#include<bits/stdc++.h> #define pii pair<int,int> #define Min(a,b) ((a<b) ? a:b) #define Max(a,b) ((a > b) ? a:b) #define Swap(a,b) (a=b+a-(b=a)) #define sn(n) scanf("%d",&n) #define schr(n) scanf("%c",&n) #define ss(n) scanf("%s",n) #define p(n) printf("%d",n) #define el putchar("\n"); #define sp putchar('') #define Fill(a,val) memset(a,val,sizeof(a)) #define pb push_back #define INFN 123456789 #define ll long long #define si short int #define vi vector<int> #define vvi vector<vvi> #define ITER(i,a) for( typeof(a.begin()) i=a.begin();i!=a.end();i++) #define _I int #define _D double #define _L long long  using namespace std; int gcd(int a,int b){ 	return (!b) ? a:gcd(b,a%b); }  char arr[10002]; _I ac,bc;  void func(){ 	_I i,j,len = strlen(arr); 	char n; 	_I tot_c = 0; 	_I min_c = 0; 	char rep_char; 	if(ac < bc) { 		min_c = ac; 		rep_char = 'a'; 	} 	else{ 		min_c = bc; 		rep_char = 'b'; 	} 	_I cnt = 0; 	for(i=0;i < len/2;i++){  		if(arr[i] == '/' && arr[len-i-1] == '/'){ 			tot_c += (2*min_c); 		} 		else if((arr[i] == 'a' && arr[len-i-1] == '/') || (arr[i] == '/' && arr[len-i-1] == 'a')){ 			tot_c += ac; 		} 		else if((arr[i] == 'b' && arr[len-i-1] == '/') || (arr[i] == '/' && arr[len-i-1] == 'b') ){ 			tot_c += bc; 		} 		else if(arr[i] != arr[len-i-1]){ 			cnt = 1; 			break; 		} 	} 	if(cnt){ 		cout << "-1" << endl; 	} 	else{ 		cout << tot_c << endl; 	} }  char N[10021] = {0}; void func1(){ 	if(N[0] & 1) { 		cout << "ODD" << endl; 	} 	else{ 		cout << "EVEN" << endl; 	} 	 }  _L a[100005];  void func2(_L N){ 	_I cnt = 0; 		for(_I i=0; i < N-1;i++){ 			for(_I j=i+1;j < N;j++){ 				if((a[i] ^ a[j] ) & 1){ 					cnt++; 				} 			} 		} 		cout << cnt << endl; }  _I main(){ 	_I t; 	cin >> t; 	_L N; 	for(_I test = 0;test < t;test++){ 		cin >> N; 		for(_I i= 0; i < N;i++){ 			cin >> a[i]; 		} 		func2(N); 	} 	return 0; 	 }
#include<iostream> using namespace std;  // Maximum number of digits in output #define MAX 500  int multiply(int x, int res[], int res_size);  // This function finds factorial of large numbers and prints them void factorial(int n) {     int res[MAX];      // Initialize result     res[0] = 1;     int res_size = 1;      // Apply simple factorial formula n! = 1 * 2 * 3 * 4...*n     for (int x=2; x<=n; x++)         res_size = multiply(x, res, res_size);    //  cout << "Factorial of given number is \n";     for (int i=res_size-1; i>=0; i--)         cout << res[i]; }  // This function multiplies x with the number represented by res[]. // res_size is size of res[] or number of digits in the number represented // by res[]. This function uses simple school mathematics for multiplication. // This function may value of res_size and returns the new value of res_size int multiply(int x, int res[], int res_size) {     int carry = 0;  // Initialize carry      // One by one multiply n with individual digits of res[]     for (int i=0; i<res_size; i++)     {         int prod = res[i] * x + carry;         res[i] = prod % 10;  // Store last digit of 'prod' in res[]         carry  = prod/10;    // Put rest in carry     }      // Put carry in res and increase result size     while (carry)     {         res[res_size] = carry%10;         carry = carry/10;         res_size++;     }     return res_size; }  // Driver program int main() {    int t,n;    cin>>t;    while(t--)    {        cin>>n;        factorial(n);        cout<<endl;    }      return 0; } 
#include<iostream> using namespace std; int main() {     int test;     long f=1,i,n;     scanf("%d",&test);     while(test--)     {         scanf("%d",&n);         for(i=2;i<=n;i++)         f=f*i;         cout<<f<<endl;         f=1;     } } 
#include<bits/stdc++.h> using namespace std; typedef long long ll; int main() {   string s1,s2;   cin>>s1>>s2;   ll ar[26]={0},ans=0;   ll i=0;   while(s1[i]!='\0')     ar[s1[i]-'A']++,i++;   i=0;   while(s2[i]!='\0')     ar[s2[i]-'A']++,i++;   for( i=0;i<26;i++)     if(ar[i]==2)     ans++;   cout<<ans;     } 
#include<cstdio> #include<cstdlib> #include<cstring> #include<cmath> #include<algorithm>  using namespace std;  #define MAX_A 100000 #define MAX_B 1000  int A[MAX_A+5], B[MAX_B+5]; int counts[MAX_B+5], done[MAX_B+5];  int contains( int val, int NB ){ 	int low = 0, high = NB - 1, mid; 	while( low <= high ){ 		mid = (low + high)/2; 		if( B[mid] == val ) 			return mid; 		if( B[mid] > val ) 			high = mid - 1; 		else 			low = mid + 1; 	} 	return -1; }  void performtest(){ 	int NA, NB, i, j; 	 	//Initialize 	scanf( "%d", &NA ); 	for( i=0; i<NA; i++ ) 		scanf( "%d", A + i ); 	scanf( "%d", &NB ); 	for( j=0; j<NB; j++ ) 		scanf( "%d", B + j ); 	 	memset( done, false, sizeof( done ) ); 	memset( counts, 0, sizeof( counts ) ); 	 	sort( B, B + NB ); 	 	for( i=0; i<NA; i++ ) 		A[i] = contains( A[i], NB ); 	 	long long result = 0; 	int pre = -1, total = 0; 	for( i=0; i<NA; i++ ) 		if( A[i] >= 0 ){ 			counts[ A[i] ]++; 			if( !done[ A[i] ] ){ 				done[ A[i] ] = true; 				total++; 			} 			if( total == NB ) 				break; 		} 	 	if( total < NB ){ 		printf( "0\n" ); 		return; 	} 	 	for( j=0; j<NA; j++ ) 		if( A[j] >= 0 ){ 			if( counts[ A[j] ] > 1 ) 				counts[ A[j] ]--; 			else 				break; 		} 	result = (long long)( j - pre )*(long long)( NA - i ); 	pre = j; 	 	for( i=i+1; i<NA; i++ ) 		if( A[i] >= 0 ){ 			counts[ A[i] ]++; 			for( j=pre; j<NA; j++ ) 				if( A[j] >= 0 ){ 					if( counts[ A[j] ] > 1 ) 						counts[ A[j] ]--; 					else 						break; 				} 			result += (long long)( j - pre )*(long long)( NA - i ); 			pre = j; 		} 	printf( "%lld\n", result ); }  int main(){ 	int tests; 	scanf( "%d", &tests ); 	while( tests-- ) 		performtest(); 	return 0; }
#include<bits/stdc++.h> using namespace std; int main() {       int n,m,a[205];       cin>>n>>m;       for(int i=0;i<n;i++)       {             cin>>a[i];       }       sort(a,a+n);       cout<<a[n-m];       return 0; } 
#include <bits/stdc++.h> using namespace std; typedef long long int ll; #define F(i,a,b) for(int i = (int)(a); i <= (int)(b); i++) #define RF(i,a,b) for(int i = (int)(a); i >= (int)(b); i--) #define pb push_back #define mp make_pair #define gc getchar_unlocked  int read_int(){     register int x = 0, c = gc();     int sign = 1;     while(c!='-' && (c<48 || c>57) ) c = gc();     if(c=='-')         sign = -1, c = gc();     while(c>=48 && c<=57)         x = (x<<1) + (x<<3) + c - 48, c = gc();     return sign*x; } int main() {     #ifndef ONLINE_JUDGE         freopen("input.txt","r",stdin);         freopen("output.txt","w",stdout);     #endif     int T,N;     T = read_int();     while(T--)     {         N = read_int();         int D[N];         F(i,0,N-1) D[i] = read_int();         sort(D,D+N);         int timer,counter;         int killed = 0;         timer = counter = 0;         F(i,0,N-1)         {             if(D[i]-timer > 0)             {                 timer++;                 counter++;                 if(counter == 6)                 {                     timer++;                     counter = 0;                 }             }             else             {                 killed = i;                 break;             }         }         if(killed == 0) printf("Bhai Ho!\n");         else printf("Killed %d\n",killed);     }     return 0; }  
#include <bits/stdc++.h> using namespace std; typedef long long int ll; #define F(i,a,b) for(int i = (int)(a); i <= (int)(b); i++) #define RF(i,a,b) for(int i = (int)(a); i >= (int)(b); i--) #define pb push_back #define mp make_pair #define gc getchar_unlocked  int read_int(){     register int x = 0, c = gc();     int sign = 1;     while(c!='-' && (c<48 || c>57) ) c = gc();     if(c=='-')         sign = -1, c = gc();     while(c>=48 && c<=57)         x = (x<<1) + (x<<3) + c - 48, c = gc();     return sign*x; } int main() {     #ifndef ONLINE_JUDGE         freopen("input.txt","r",stdin);         freopen("output.txt","w",stdout);     #endif     int T,L,_i;     char S[1005];     T = read_int();     while(T--)     {         scanf("%s",S);         L = strlen(S);         bool flag = 0;         _i = 0;         while(_i <= L-1)         {             if(S[_i] >= '0' && S[_i] <= '4')             {                 S[_i] = '5';                 flag = 1;                 break;             }             else if(S[_i] >= '6' && S[_i] <= '8')             {                 S[_i] = '9';                 flag = 1;                 break;             }             _i++;         }         if(flag)         {             F(i,_i+1,L-1) S[i] = '5';         }         else         {             flag = 0;             RF(i,L-1,0)             {                 if(S[i] == '5')                 {                     S[i] = '9';                     flag = 1;                     break;                 }             }             if(flag == 0)             {                 F(i,0,L) S[i] = '5';                 S[L+1] = '\0';             }         }         printf("%s\n",S);     }     return 0; }  
#include <vector> #include <iostream> #include <cmath> using namespace std;  int main()  {      int t, n, x;     cin>>t;     while(t--)  {         cin>>n;         while(n--)  {             cin>>x;             float digits = 0;             while(x)  {                 digits += log10(x); x--;             }             cout<<(int)digits + 1<<" ";         }         cout<<endl;     }     /*float digits = 0;     while(t)  {         digits += log10(t);         t--;     }     cout<<(int)digits + 1;*/     return 0; } 
    #include<stdio.h>           int main() {     int fact[200],n,num,bakup,carry,product,i,j,k=0;           scanf("%d",&n);           for(i=0;i<n;i++) {     scanf("%d",&num);     bakup=num;     j=0;     fact[0]=1;     fact[1]=-1;     for(j=1;j<=bakup;j++) {     k=0;     carry=0;     do {     if(fact[k]!=-1) {     product=j*fact[k]+carry;     fact[k]=product%10;     carry=product/10;     k++;     }     else {     while(carry) {     fact[k]=carry%10;     carry=carry/10;     k++;     }     fact[k]=-1;     k--;     break;     }     }while(1);     }           num=0;     while(k>=0) {     printf("%d",fact[k]);     k--;     }     printf("\n");     }     return 0;     }   
#include<iostream> #include<string.h> #include<math.h> #define MOD 1000000007 using namespace std; long long int fast_exp(int base, int exp) {     long long int k;     if(exp==1)     return base;     else     {         if(exp%2 == 0)         {         	k=fast_exp(base,exp/2);         	long long int base1=(k%MOD*k%MOD)%MOD;             if(base1 >= MOD)             return base1%MOD;             else             return base1;         }         else         {         	k=fast_exp(base,(exp-1)/2);         	long long int ans=((k%MOD*k%MOD)%MOD*base)%MOD;             //long long int ans = (base*  pow(fast_exp(base,(exp-1)/2),2));             if(ans >= MOD)             return ans%MOD;             else             return ans;         }     } } int main() { 	int t; 	long long int mod1,mod2,ans; 	char A[100005],B[100005]; 	cin>>t; 	while(t--) 	{ 		cin>>A; 		cin>>B; 		mod1=((int)A[0]-48)%MOD; 		for(int i=1;i<strlen(A);i++) 		{ 			mod1=(mod1*10+((int)A[i]-48))%MOD; 		} 		mod2=((int)B[0]-48)%(MOD-1); 		for(int i=1;i<strlen(B);i++) 		{ 			mod2=(mod2*10+((int)B[i]-48))%(MOD-1); 		} 		ans=fast_exp(mod1,mod2); 		cout<<ans<<endl;   	} } 
#include<bits/stdc++.h> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {         long long int n;         scanf("%lld",&n);         if(n%10==0)             cout<<n<<endl;         else         {             n=n/10;             cout<<(n+1)*10<<endl;         }     }     return 0;  } 
#include <bits/stdc++.h> using namespace std; #define N 100000 vector <int> adj[N + 10]; int mark[N + 10]; //int poss[N + 10];  //int mp[N + 10]; int disc[N + 10]; int low[N + 10]; int par[N + 10]; int dtime,cnt; int dfs(int,int); //void Bridges(int); int main() {     int tc,t;     scanf("%d",&tc);     while(tc--)     {         int n,m,i;         scanf("%d %d",&n,&m);         for(i = 1 ; i<=n ; i++)         {             //mp[i] = 0;             //poss[i] = 0;             mark[i] = 0;             adj[i].clear();             //adj2[i].clear();             disc[i] = 0;             low[i] = 0;             par[i] = 0;         }          for(i = 1 ; i<=m ; i++)         {             int u,v;             scanf("%d %d",&u,&v);             adj[u].push_back(v);             adj[v].push_back(u);         }         dtime = 0;         cnt = 0;         int temp = dfs(1,n);         printf("%d\n",cnt);         /*int cc = 0;         for(i = 1 ; i<=n ; i++)         {             mark[i] = 0;             if(poss[i] == 1)             {                 cc++;                 mp[cc] = i;                 poss[i] = cc;             }         }         for(i = 1 ; i<=n ; i++)         {             int sz = adj[i].size();             for(int j = 0 ; j<sz; j++)             {                 int v = adj[i][j];                 if(poss[i] > 0 && poss[v] > 0)                 {                     adj2[mp[i]].push_back(mp[v]);                     //adj2[mp[v]].push_back(mp[i]);                 }             }         }         cnt = 0;         Bridges(1);         printf("%d\n",cnt);*/     }     return 0; } int dfs(int u,int n) {     dtime++;     disc[u] = dtime;     low[u] = disc[u];     mark[u] = 1;     int sz = adj[u].size();     int fl = 0;     if(u == n) fl = 1;     for(int j = 0 ; j<sz ; j++)     {         int v = adj[u][j];         if(mark[v] == 0)         {             par[v] = u;             int temp = dfs(v,n);             if(fl == 0) fl = temp;             if(temp == 1)             {                 if(low[v] > disc[u]) cnt++;             }         }         if(v != par[u])         {             low[u] = min(low[u],low[v]);         }     }     mark[u] = 2;     //cout<<u<<" "<<fl<<" "<<low[u]<<" "<<disc[u]<<endl;     return fl; } /*void Bridges(int u) {     dtime++;     disc[u] = dtime;     low[u] = disc[u];     mark[u] = 1;     int sz = adj2[u].size();     for(int j = 0 ; j<sz ; j++)     {         int v = adj2[u][j];         if(mark[v] == 0)         {             par[v] = u;             Bridges(v);             if(low[v] > disc[u])cnt++;         }         if(v != par[u])         {             low[u] = min(low[u],disc[v]);         }     } }*/ 
#include<bits/stdc++.h> #define ll long long #define fi first #define se second ll mpow(ll a, ll n,ll mod) {ll ret=1;ll b=a;while(n) {if(n&1)     ret=(ret*b)%mod;b=(b*b)%mod;n>>=1;} return (ll)ret; } using namespace std; #define mem(x,a) memset(x,a,sizeof(x)) #define pii pair<int,int> #define mp make_pair #define pb push_back #define all(v) v.begin(),v.end() using namespace std; #define N (int)(2e1+4) ll temp[3][3],a[3][3],b[3][3]; ll mod=1e9+7; void mul(long long a[3][3], long long b[3][3], long long c[3][3]) {     mem(temp,0); 	for (int i = 0; i < 3; ++i) 		for (int j = 0; j < 3; ++j) 			for (int k = 0; k < 3; ++k) 				temp[i][j] = (temp[i][j] + a[i][k] * b[k][j] ) % mod; 	for (int i = 0; i < 3; ++i) 		for (int j = 0; j < 3; ++j) 			c[i][j] = temp[i][j]; } void pwr(long long a[3][3], long long n, long long b[3][3]) { 	for (int i = 0; i < 3; ++i) 		for (int j = 0; j < 3; ++j) 			b[i][j] = (i == j); 	while (n) 	{ 		if (n & 1) 			mul(b, a, b); 		n >>= 1; 		mul(a, a, a); 	} } int func(long long n, long long k) { 	k %= mod; 	if (n == 1) 		return k; 	long long ks = k * k % mod; 	mem(a,0); 	a[0][0] = a[2][0] = k; 	a[0][1] = a[2][1] = ks; 	a[1][0] = 1; 	a[2][2] = 1; 	pwr(a, n - 1, b); 	return (b[2][0] + b[2][2]) * k % mod; } void solve(){     ll n,k;     cin>>n>>k;     cout<<func(n,k)<<endl; } int main(){    //ios_base::sync_with_stdio(false);    int t=1;    cin>>t;    for(int i=1;i<=t;i++){        //printf("Case #%d: ",i);        solve();    }    return 0; } 
#include<cstdio> #include<iostream> #define deepak 1000000007 using namespace std; long long gcd(long long,long long); int main() { long long t; scanf("%lld",&t); while(t--) {     long long a,b;     long long c[100004]={0};     //memset(c,0,100004);     scanf("%lld%lld",&a,&b);     long long k=gcd(a,b);     c[0]=0;     c[1]=1; for(int i=2;i<=k;i++)     c[i]=((c[i-1]%deepak)+(c[i-2]%deepak))%deepak; printf("%lld\n",c[k]); } return 0; } long long  gcd(long long a,long long b) { if(a==0) return b; else if(b==0) return a; else if(a>b) gcd((a%b),b); else gcd((b%a),a); } 
#include <vector> #include <list> #include <map> #include <set> #include <deque> #include <queue> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <complex> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <cstring> #include <ctime> #include <cassert> using namespace std;  #define FOR(it,a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); ++it)  const int maxn = 16; const int maxm = maxn * 2;  int n, m; char input[maxn][maxn]; int label[maxn][maxn]; int ending[maxn][2];  int vertices, edges; int src, dest;  int length[maxm]; vector<int> cover[maxn][maxn]; vector<int> adjEdge[maxn];  int crossEdge[maxm]; set<int> S[maxn][maxn];  struct State {     int pos;     int holdLen;     int mask;      State(int pos, int mask) : pos(pos), holdLen(0), mask(mask) { }     State(int pos, int hold, int mask) : pos(pos), holdLen(hold), mask(mask) { }      bool insert() const {         return S[pos][holdLen].insert(mask).second;     } };  int main() {     int tests;     scanf("%d", &tests);     for (int cas = 1; cas <= tests; ++cas) {         scanf("%d%d", &n, &m);         for (int i = 0; i < n; i++) {             scanf("%s", input[i]);         }         vertices = edges = 0;         memset(label, -1, sizeof(label));         for (int i = 0; i < n; i++) {             for (int j = 0; j < m; j++) {                 if (input[i][j] == 'S' || input[i][j] == 'E' || input[i][j] == 'B') {                     if (input[i][j] == 'B') {                         src = vertices;                     } else if (input[i][j] == 'E') {                         dest = vertices;                     }                     adjEdge[vertices].clear();                     label[i][j] = vertices ++;                 }                 cover[i][j].clear();             }         }         int initialEdges = 0;         for (int i = 0; i < n; i++) {             for (int j = 0; j < m; j++) {                 if (label[i][j] < 0) {                     continue;                 }                 for (int k = 0; k < 2; k++) {                     int dx, dy;                     if (k == 0) {                         // right                         dx = 0, dy = 1;                     } else {                         // down                         dx = 1, dy = 0;                     }                     vector<pair<int,int> > path;                     int x = i + dx, y = j + dy, target = -1;                     while (x < n && y < m) {                         if (label[x][y] >= 0) {                             target = label[x][y];                             break;                         }                         path.push_back(make_pair(x, y));                         x += dx;                         y += dy;                     }                     if (target >= 0 && path.size()) {                         length[edges] = path.size() + 1;                         ending[edges][0] = label[i][j];                         ending[edges][1] = target;                         adjEdge[label[i][j]].push_back(edges);                         adjEdge[target].push_back(edges);                         FOR (it, path) {                             cover[it->first][it->second].push_back(edges);                         }                         char ch = input[path[0].first][path[0].second];                         if (k == 0 && ch == '-' || k == 1 && ch == '|') {                             initialEdges |= 1 << edges;                         }                         edges ++;                     }                 }             }         }         for (int i = 0; i < vertices; i++) {             for (int j = 0; j < maxn; j++) {                 S[i][j].clear();             }         }         memset(crossEdge, 0, sizeof(crossEdge));         for (int i = 0; i < n; i++) {             for (int j = 0; j < m; j++) {                 FOR (it, cover[i][j]) {                     FOR (jt, cover[i][j]) {                         crossEdge[*it] |= 1 << *jt;                     }                 }             }         }         State startS(src, initialEdges);         startS.insert();         queue<pair<State,int> > Q;         Q.push(make_pair(startS, 0));         int ans = 0;         while (!Q.empty()) {             State p = Q.front().first;             int dist = Q.front().second;             Q.pop();             if (p.pos == dest) {                 ans = dist;                 break;             }             if (p.holdLen > 0) {                 FOR (it, adjEdge[p.pos]) {                     if (length[*it] == p.holdLen && (crossEdge[*it] & p.mask) == 0) {                         // put down                         State q(p.pos, p.mask | 1 << *it);                         if (q.insert()) {                             Q.push(make_pair(q, dist + 1));                         }                     }                 }             }             FOR (it, adjEdge[p.pos]) {                 if (p.mask >> *it & 1) {                     if (p.holdLen == 0) {                         // pick up                         State q(p.pos, length[*it], p.mask & ~(1 << *it));                         if (q.insert()) {                             Q.push(make_pair(q, dist + 1));                         }                     }                     // move                     State q(ending[*it][0] ^ ending[*it][1] ^ p.pos, p.holdLen, p.mask);                     if (q.insert()) {                         Q.push(make_pair(q, dist + 1));                     }                 }             }         }         printf("%d\n", ans);     } } 
#include<cstdio> using namespace std; int r,c; bool win=false,jf; //int getchar_unlocked()  {return getchar();} //inline void fastRead_int(int &x) { //	register int c = getchar_unlocked(); //	x = 0; //	for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked()); //	for(; c>47 && c<58 ; c = getchar_unlocked()) { //		x = (x<<1) + (x<<3) + c - 48; //	} //}  int main(){ 	int i,j; 	scanf("%d",&r);  scanf("%d",&c); 	char maze[r][c]; 	for(i=0;i<r;i++) scanf("%s",&maze[i]);  	char ma[r][c]; 	int count=0; 	while(true){ 		count++; 		jf=false;                   ////check 		for(i=0;i<r;i++){ 			for(j=0;j<c;j++){ 				if(maze[i][j]=='J'){jf=true; 					if(i==0 || i==r-1 || j==c-1 || j==0) { win=true; goto label;     } 				} 			} 		} 		if(!jf){win=false; goto label;   } 		for(i=0;i<r;i++){                 //copy 			for(j=0;j<c;j++){ 				ma[i][j]=maze[i][j]; 			} 		} 		for(i=0;i<r;i++){                 //movej 			for(j=0;j<c;j++){ 				if(ma[i][j]=='J'){ 					if(j!=0 && ma[i][j-1]=='.') maze[i][j-1]='J'; 					if(i!=r-1 && ma[i+1][j]=='.') maze[i+1][j]='J'; 					if(i!=0 && ma[i-1][j]=='.') maze[i-1][j]='J'; 					if(j!=c-1 && ma[i][j+1]=='.') maze[i][j+1]='J'; 					maze[i][j]='K';	 				} 				else if(ma[i][j]=='F'){                 //movef 					if(j!=0 && (ma[i][j-1]=='.' || ma[i][j-1]=='J' || ma[i][j-1]=='K')) maze[i][j-1]='F'; 					if(j!=c-1 && (ma[i][j+1]=='.' || ma[i][j+1]=='J' || ma[i][j+1]=='K')) maze[i][j+1]='F'; 					if(i!=r-1 && (ma[i+1][j]=='.' || ma[i+1][j]=='J' || ma[i+1][j]=='K')) maze[i+1][j]='F'; 					if(i!=0 && (ma[i-1][j]=='.' || ma[i-1][j]=='J' || ma[i-1][j]=='K')) maze[i-1][j]='F';		 				} 			} 		} 	} 	label: {if(win) {printf("%d",count);  }   else printf("IMPOSSIBLE");   } 	return 0; } 
#include<bits/stdc++.h> #include<string> using namespace std; void reverse(char *str, int length) {     int start = 0;     int end = length -1;     while (start < end)     {         swap(*(str+start), *(str+end));         start++;         end--;     } }   // Implementation of itoa() char* itoa2(int num, char* str, int base) {     int i = 0;     bool isNegative = false;       /* Handle 0 explicitely, otherwise empty string is printed for 0 */     if (num == 0)     {         str[i++] = '0';         str[i] = '\0';         return str;     }       // In standard itoa(), negative numbers are handled only with      // base 10. Otherwise numbers are considered unsigned.     if (num < 0 && base == 10)     {         isNegative = true;         num = -num;     }       // Process individual digits     while (num != 0)     {         int rem = num % base;         str[i++] = (rem > 9)? (rem-10) + 'a' : rem + '0';         num = num/base;     }       // If number is negative, append '-'     if (isNegative)         str[i++] = '-';       str[i] = '\0'; // Append string terminator       // Reverse the string     reverse(str, i);       return str; } void LPSarray(string *s,int m,int *arr) { 	int i=0; 	arr[0]=0;//here array stores LPS value 	i++; 	int len=0; 	while(i<m) 	{ 		if(s[i]==s[len]) 		{ 			len++; 			arr[i]=len; 			i++; 		} 		else 		{ 			if(len!=0) 			{ 				len=arr[len-1];//we go to previous largest prefix which is also a suffix and then check 			} 			else 			{ 				arr[i]=0; 				i++; 			} 		} 	} } int st1[100005],st2[100005]; int y=0; void matchStr(string *text,string *pat,int n,int m) { 	int arr[m]; 	LPSarray(pat,m,arr); 	int i=0,j=0; 	while(i<n) 	{ 		if(text[i]==pat[j]) 		{ 			j++; 			i++; 		} 		if(j==m) 		{ 			//cout<<"match found at "<<i-j<<endl; 				st1[y++]=i-j; 			j=arr[j-1]; 		} 		else if(i<n&&text[i]!=pat[j]) 		{ 			if(j!=0) 			j=arr[j-1]; 			else 			i++; 		} 	} 	//delete(arr); } int x=0; void matchStr2(string *text,string *pat,int n,int m) { 	int arr[m]; 	LPSarray(pat,m,arr); 	int i=0,j=0; 	while(i<n) 	{ 		if(text[i]==pat[j]) 		{ 			j++; 			i++; 		} 		if(j==m) 		{ 			//cout<<"match found at "<<i-j<<endl; 				st2[x++]=i-j; 			j=arr[j-1]; 		} 		else if(i<n&&text[i]!=pat[j]) 		{ 			if(j!=0) 			j=arr[j-1]; 			else 			i++; 		} 	} 	//delete(arr); } string take[100005],cat1[100005],cat2[100005]; int main() { 	int n,k,l,p; 	char *f; 	scanf("%d%d%d",&n,&k,&l); 	for(int i=0;i<n;i++) 	{ 	  scanf("%d",&p); 	 stringstream out; 	 out<<p; 	  take[i]=out.str();	 	} 	for(int i=0;i<k;i++) 	{ 	  scanf("%d",&p); 	 stringstream out; 	 out<<p; 	  cat1[i]=out.str();	 	} 	for(int i=0;i<l;i++) 	{ 		scanf("%d",&p);		 	  stringstream out; 	 out<<p; 		cat2[i]=out.str(); 	} 	matchStr(take,cat1,n,k); 	matchStr2(take,cat2,n,l); 	long long ans=0; 	for(int i=0;i<y;i++) 	{ 		int z=lower_bound(st2,st2+x,st1[i])-st2; 		if(st2[z]==st1[i]) 		ans+=z+1; 		else 		ans+=z; 	} 	printf("%lld\n",ans); }
#include <cstdio> #include <cassert>  #include <vector> #include <queue> #include <algorithm>  using namespace std;  int N, M, K, C; int D[104][104];  class BipartiteMatching {    vector<bool> seen;    bool bpm(int u) {       for (int j = 0; j < adj[u].size(); ++j) {          int v = adj[u][j];          if (seen[v]) continue;          seen[v] = true;          if (matchR[v] < 0 || bpm(matchR[v])) {             matchL[u] = v;             matchR[v] = u;             return true;          }       }       return false;    } public:    size_t nL, nR;    vector< vector<int> > adj; // adjacency lists     vector<int> matchL, matchR;    BipartiteMatching(size_t _nL, size_t _nR) : nL(_nL), nR(_nR), adj(_nL) {}     int process() {       matchL.assign( nL, -1 ),       matchR.assign( nR, -1 );       int cnt = 0;       for (int i = 0; i < nL; ++i) {          seen = vector<bool>(nR, false);          if (bpm(i))             cnt++;       }       return cnt;    } };  bool check(int t) {    BipartiteMatching bpm(N, M*2);    for (int i = 0; i < N; ++i) {       for (int j = 0; j < M; ++j) {          if (D[i][j] + C <= t)             bpm.adj[i].push_back(j);          if (D[i][j] <= t)             bpm.adj[i].push_back(j + M);       }    }    return bpm.process() >= K; }  int binary_search() {    int lo = 0, hi = 20000000;    while (lo < hi) {       int mid = lo + (hi-lo)/2;       if (check(mid))          hi = mid;       else          lo = mid+1;    }    assert(check(lo));    return lo; }  int main(int argc, char* argv[]) {    int TC;    scanf("%d", &TC);    while (TC-- > 0) {       scanf("%d %d %d %d", &N, &M, &K, &C);       for (int i = 0; i < N; ++i)          for (int j = 0; j < M; ++j)             scanf("%d", &D[i][j]);       int res = binary_search();       printf("%d\n", res);    }     return 0; } 
#include<iostream> #include<stdio.h> using namespace std; int check(int a[],int n,int l,long long int k,long long int s,int num,int p) { 	if(l==n&&s==k)return ++num; 	else if(l==n&&s>k) 	{ 		 			s=0; 			p++; 			l=p; 			check(a,n,l,k,s,num,p); 	} 	else if(l==n&&s!=k)return num; 	else 	{ 		if(s<k) 		{ 			s=s+a[l];l++; 			check(a,n,l,k,s,num,p); 		} 		else if(s==k) 		{ 			num++; 			s=0;p=l; 			check(a,n,l,k,s,num,p); 		} 		else if(s>k) 		{ 			s=0; 			p++; 			l=p; 			check(a,n,l,k,s,num,p); 		} 	} } int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		long long int k;int n; 		cin>>n>>k; 		int a[n]; 		int i; 		for(i=0;i<n;i++)cin>>a[i]; 		int h=check(a,n,0,k,0,0,0); 		cout<<h<<"\n"; 	} 	return 0; }
#include<iostream> #include<math.h> using namespace std;     int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		int n,sum=0; 		cin>>n; 		for(int i=1;i<=n;i++) 		{ 			sum=sum+floor(i/2); 		} 		cout<<sum<<endl; 	} 	return 0; } 
// Program to print BFS traversal from a given source vertex. BFS(int s) // traverses vertices reachable from s. #include<iostream> #include <list> #include<stdlib.h>  using namespace std;  // This class represents a directed graph using adjacency list representation class Graph {     int V;    // No. of vertices     list<int> *adj;    // Pointer to an array containing adjacency lists public:     Graph(int V);  // Constructor     void addEdge(int v, int w); // function to add an edge to graph     void BFS(int s);  // prints BFS traversal from a given source s };  Graph::Graph(int V) {     this->V = V;     adj = new list<int>[V]; }  void Graph::addEdge(int v, int w) {     adj[v].push_back(w); // Add w to v’s list. 	adj[w].push_back(v);// undirected } int *map; void Graph::BFS(int s) {     // Mark all the vertices as not visited     bool *visited = new bool[V];     for(int i = 0; i < V; i++)         visited[i] = false;      // Create a queue for BFS     list<int> queue;      // Mark the current node as visited and enqueue it     visited[s] = true;     queue.push_back(s);      // 'i' will be used to get all adjacent vertices of a vertex     list<int>::iterator i;      while(!queue.empty())     {         // Dequeue a vertex from queue and print it         s = queue.front(); //        cout << s << " ";         queue.pop_front();          // Get all adjacent vertices of the dequeued vertex s         // If a adjacent has not been visited, then mark it visited         // and enqueue it         for(i = adj[s].begin(); i != adj[s].end(); ++i)         {             if(!visited[*i])             {                 visited[*i] = true;                 queue.push_back(*i);                 map[*i]=s; 			}         }     } }  // Driver program to test methods of graph class int main() {/*     // Create a graph given in the above diagram     Graph g(4);     g.addEdge(0, 1);     g.addEdge(0, 2);     g.addEdge(1, 2);     g.addEdge(2, 0);     g.addEdge(2, 3);     g.addEdge(3, 3);      cout << "Following is Breadth First Traversal (starting from vertex 2) \n";     g.BFS(2); */ 	int t; 	cin>>t; 	while(t--){ 	  int n,hq1,hq2; 		 cin>>n; 		 cin>>hq1; 		 cin>>hq2; 	   //inp(n); 	   //inp(hq1); 	   //inp(hq2);         Graph g(n+1);  	   for(int i=1;i<=n;i++){ 			if(i!=hq1) 			{int x; 			 cin>>x; 			 g.addEdge(i,x); 		    } 	   } 	   map=(int*)calloc(n+2,sizeof(int)); 	   g.BFS(hq2); 	   for(int i=1;i<=n;i++){ 			if(i!=hq2){ 				cout<<map[i]<<" "; 			} 	   } 	   cout<<endl; 	   free(map); 	}     return 0; } 
#include<stdio.h> #include<math.h>  main() {       int m,n,i;       scanf("%d%d",&m,&n);       int arr[m],arr1[n];       int s1=0,s2=0;       for(i=0;i<m;i++)       {scanf("%d",&arr[i]);s1+=arr[i];}       for(i=0;i<n;i++)       {scanf("%d",&arr1[i]);s2+=arr1[i];}       int res;       int add=(s1&1)^(s2&1);       if(s1>s2)       res=s2+add+(s1-s2)/2;       else       res=s1+add+(s2-s1)/2;       printf("%d\n",res); } 
#include <iostream> #include <string.h>   using namespace std;    int main() { 	 	long long int t; 	cin>>t; 	while(t--) 		{ 				string a; 				cin>>a; 				int l=a.length(); 				int i,num=0,x=0; 				for(i=0;i<l;i++) 				{ 					 					x=(x*10+int(a[i])-48)%17; 				} 				if(x==0) 				cout<<"YES"<<endl; 				else 				cout<<"NO"<<endl; 		} 		 	 	return 0; } 
#include <cstdio> #include <sstream> #include <cstring> using namespace std; int a[30]={ 0,2, 6, 14, 30, 62, 126, 254, 510, 1022, 2046, 4094, 8190, 16382, 32766, 65534, 131070, 262142, 524286, 1048574, 2097150, 4194302, 8388606, 16777214, 33554430, 67108862, 134217726, 268435454, 536870910, 1073741822 };  int getchar_unlocked() { return getchar(); } inline void fastRead_string(char *str) {     register char c = 0;     register int i = 0;     while (c < 33)    c = getchar_unlocked();     while (c != '\n') {  str[i] = c;         c = getchar_unlocked();         i = i + 1;      }     str[i] = '\0'; }  int main() { 	register int i,x,y;bool s7=false; 	scanf("%d",&x); 	for(i=0;i<32;i++){ 		if(a[i]>=x) break; 	} 	while(i>=1){ 		if(x>(a[i]+a[i-1])/2)  {s7=true; printf("7");  } 		else { printf("4"); s7=false;} 		x-=s7?(a[i]-a[i-1]):(a[i]-a[i-1])/2; 		i--; 	} 	return 0; }
#include<iostream> #include<cstdio> #include<map> #include<cstring> #define MXC 100000 #define MXF (MXC<<1) using namespace std; int comp[MXC]; int parent[MXF]; map<string,int>mymap; int FIND(int x) {     if(x==parent[x])return x;     else     {         parent[x]=FIND(parent[x]);         return parent[x];     } } void reset() {      mymap.clear();      memset(comp,0,sizeof comp);      memset(parent,0,sizeof parent); } int main() {     int t,n,id1,id2,p1,p2,p,ans;     char a[50],b[50];     //string a,b;     cin>>t;     while(t--)     {               cin>>n;               int curr=1;               reset();               while(n--)               {                         scanf("%s %s",a,b);                         //cin>>a>>b;                         id1=mymap[a];                         id2=mymap[b];                         if(!id1 && !id2)                         {                                 mymap[a]=id1=curr++;                                 mymap[b]=id2=curr++;                                 parent[id1]=parent[id2]=id1;                                 comp[id1]=2;                                 cout<<2<<endl;                         }                         else if(!id1)                         {                                 mymap[a]=id1=curr++;                                 p=FIND(id2);                                 parent[id1]=p;                                 comp[p]+=1;                                 cout<<comp[p]<<endl;                         }                         else if(!id2)                         {                                 mymap[b]=id2=curr++;                                 p=FIND(id1);                                 parent[id2]=p;                                   comp[p]+=1;                                 cout<<comp[p]<<endl;                         }                         else                         {                                 p1=FIND(id1);                                 p2=FIND(id2);                                 ans=comp[p1];                                 if(p1!=p2)                                 {                                           if(comp[p1]<comp[p2])                                           {                                                                parent[p1]=parent[p2];                                                                comp[p2]+=comp[p1];                                                                ans=comp[p2];                                           }                                           else                                           {                                                                parent[p2]=parent[p1];                                                                comp[p1]+=comp[p2];                                                                ans=comp[p1];                                           }                                 }                                 cout<<ans<<endl;                         }               }     } }                                                                                                                                                                                     
#include <stdio.h> char board [ 3 ][ 4 ]; void getwinner ( int & winx , int & wino ) { int i , j , cnt , x , o ; x = o = 0 ; for ( i = 0 ; i < 3 ; i ++ ) { cnt = 0 ; for ( j = 0 ; j < 3 ; j ++ ) cnt += board [ i ][ j ]; if ( cnt == 'X' * 3 ) x ++ ; else if ( cnt == 'O' * 3 ) o ++ ; } for ( i = 0 ; i < 3 ; i ++ ) { cnt = 0 ; for ( j = 0 ; j < 3 ; j ++ ) cnt += board [ j ][ i ]; if ( cnt == 'X' * 3 ) x ++ ; else if ( cnt == 'O' * 3 ) o ++ ; } for ( i = j = cnt = 0 ; i < 3 ; i ++ , j ++ ) cnt += board [ i ][ j ]; if ( cnt == 'X' * 3 ) x ++ ; else if ( cnt == 'O' * 3 ) o ++ ; for ( i = 0 , j = 2 , cnt = 0 ; i < 3 ; i ++ , j -- ) cnt += board [ i ][ j ]; if ( cnt == 'X' * 3 ) x ++ ; else if ( cnt == 'O' * 3 ) o ++ ; winx = x ; wino = o ; } int main () { int t , i , j , x , o , d , winx , wino ; for ( scanf ( "%d" , & t ); t ; t -- ) { for ( i = 0 ; i < 3 ; i ++ ) scanf ( "%s" , board [ i ]); x = o = d = 0 ; for ( i = 0 ; i < 3 ; i ++ ) for ( j = 0 ; j < 3 ; j ++ ) if ( board [ i ][ j ] == 'X' ) x ++ ; else if ( board [ i ][ j ] == 'O' ) o ++ ; else d ++ ; getwinner ( winx , wino ); if ( o > x || ( o == x && winx ) || x > o + 1 || ( x == o + 1 && wino ) || winx > 2 || wino > 1 || ( winx && wino )) printf ( "no \n " ); else printf ( "yes \n " ); } return 0 ; }
#include <iostream> using namespace std;  int main() { 	std::ios_base::sync_with_stdio(false); 	 	int limits[]={1, 2, 4, 8, 16, 32, 64}; 	char letters[]={'A', 'B', 'C', 'D', 'E', 'F', 'G'}; 	int t; 	cin>>t; 	while(t--) 	{ 		int l; 		cin>>l; 		 		if(l==2 || l==4 || l==5 || l==8 || l==9) 		{ 			cout<<endl; 			continue; 		} 		 		int v=0; 		if(l<2) 			v=1; 		else if(l<4) 			v=2; 		else if(l<8) 			v=3; 		else if(l<16) 			v=4; 		else if(l<32) 			v=5; 		else if(l<64) 			v=6; 		else v=7; 	 		int arr[v+1]; 		int sum=0; 		for(int i=0; i<v; i++) 		{ 			arr[i]=i+1; 			sum+=(i+1); 		} 		arr[v]=l; 		 		while(sum!=l) 		{ 			for(int i=0; i<v; i++) 			{ 				if(arr[i]<limits[i]) 				{ 					if(arr[i]+1<arr[i+1]) 					{ 						arr[i]++; 						sum++; 						break; 					} 				} 			} 		} 		 		char ans[l]; 		for(int i=0; i<l; i++) 		{ 			ans[i]='0'; 		} 		 		for(int i=0; i<v; i++) 		{ 			ans[arr[i]-1]=letters[i]; 		} 		 		int let=0, count=1; 		for(int i=0;i<l; i++) 		{ 			if(arr[let]==0) 			{ 				let++; 			} 			 			if(ans[i]=='0') 			{ 				ans[i]=letters[let]; 				arr[let]--; 			} 			else if(ans[i]==letters[let]) 				arr[let]--; 			else  				arr[ans[i]-'A']--; 		} 		for(int i=0; i<l; i++) 		{ 			cout<<ans[i]; 		} 		cout<<endl; 	} } 
#include<bits/stdc++.h> using namespace std; #define lli long long int #define f(i,a,b) for(i=a;i<b;i++) #define si(a) scanf("%d",&a); #define slli(a) scanf("%lld",&a); #define INF 1000000007 #define MAX 100005 #define pb(a) push_back(a) #define sn struct node lli arr[MAX],mul[MAX]; long double logproduct[MAX]; int GCDW(lli a, lli b, lli & l, lli & k) {         if (!a) {                 // gcd(0, b) = 0 * 0 + 1 * b                 l = 0;                 k = 1;                 return b;         }         int d = GCDW(b % a, a, k, l);         l -= (b / a) * k;         return d; } lli RevMod(lli a, lli m) {         lli x, y;         if (GCDW(a, m, x, y) != 1) return -1;         x %= m;         if (x < 0) x += m;         return x; } lli fun(lli &fd,lli r,lli n) {     lli i,cur=1,l=1,p1,p2;     long double tmp,diff;     i=1;           cur=(mul[r]*arr[1])%INF;     tmp=logproduct[r]+log10(arr[1]);     /*while(i<=n)     {     //cur=(cur*arr[i])%INF;     tmp=tmp+log10(arr[i]);     i+=r;     }*/     fd=1;     tmp=tmp-floor(tmp);     tmp=tmp*1000000000;     for(i=1;i<=9;i++)     {     p1=log10(i)*1000000000;     p2=log10(i+1)*1000000000;     	if(tmp>=p1 && tmp<p2)     	{     		fd=i;     		break;     	}     }     return cur; } void change(lli index,lli value,lli r,lli inverse) {     mul[r]=(mul[r]*inverse)%INF;     mul[r]=(mul[r]*value)%INF;     logproduct[r]=(logproduct[r])-(log10(arr[index]+0.0))+(log10(value+0.0)); }     int main()     {     	lli q,i,j,k,ans,m,n,r,t,p,a,b,fd,cur,tmp,tmp1,inverse;         long double curlog;     	slli(n);           	f(i,1,n+1)     	slli(arr[i]);          f(r,1,n+1)         {         i=1;         cur=1;         curlog=0;          while(i <= n)         {             if(i!=1)             {             cur=(cur*arr[i])%INF;             curlog=(curlog)+log10(arr[i]);                     }             i+=r;         }         mul[r]=cur;         logproduct[r]=(curlog);         }      	slli(q);     	while(q--)     	{     		slli(p);     		if(p == 1)     		{     			slli(a);     			slli(b);                 tmp=a-1;                  if(tmp!=0)                 {                     tmp1=sqrt(tmp);                     for(i=1;i<=tmp1;i++)                     {                           if(tmp%i == 0)                         {                             inverse=RevMod(arr[a],INF)%INF;                             change(a,b,i,inverse);                             if(i != (tmp/i))                                 change(a,b,tmp/i,inverse);                         }                          }                 }                 arr[a]=b;     		}     		else     		{     			fd=1;     			slli(r);     			ans=fun(fd,r,n);     			printf("%lld %lld\n",fd,ans);     		}     	}     } 
#include<bits/stdc++.h> using namespace std; int main() {     int t;     scanf("%d",&t);     while(t--)     {         int n,p,q;         scanf("%d",&n);         int a[n];         for(int i=0;i<n;i++)             a[i]=0;         for(int i=0;i<n-1;i++)         {              scanf("%d %d",&p,&q);             a[q]=1;         }         for(int i=0;i<n;i++)         {             if(a[i]==0)             {                 printf("%d\n",i);             }          }     }     return 0; } 
#include <cstdio> #include <cstring>  #include <iomanip> #include <iostream> #include <queue> #include <vector>  using namespace std;  const int MAXN = 100001;  bool vis[MAXN];  int dead[MAXN]; int d[MAXN];  vector<int> inf[MAXN];  int main() {     int t;     scanf("%d", &t);     while (t--) {         int n, m, x, y;         scanf("%d", &n);          for (int i = 0; i <= n; ++i) {             inf[i].clear();             d[i] = dead[i] = 0;             vis[i] = false;         }          for (int i = 0; i < n - 1; ++i) {             scanf("%d %d", &x, &y);             inf[x].push_back(y);             inf[y].push_back(x);         }          scanf("%d", &m);         for (int i = 0; i < m; ++i) {             scanf("%d", &x);             dead[x] = 1;         }          queue<int> q;         q.push(1);         d[1] = dead[1];         vis[1] = true;         while (!q.empty()) {             int node = q.front();             q.pop();              for (int i = 0; i < inf[node].size(); ++i) {                 int next = inf[node][i];                 if (!vis[next]) {                     vis[next] = true;                     d[next] = d[node] + dead[next];                     q.push(next);                 }             }         }          double exp_val = 0.0;         for (int v = 1; v <= n; ++v) {             d[v] -= dead[v];             if (d[v] > 0)                  exp_val += (1 - 1.0 / (double) (d[v] + 1));         }         cout << setprecision(12) << exp_val << "\n";     }          return 0; } 
#include<bits/stdc++.h> using namespace std; inline int scan(){     char c = getchar_unlocked();     int x = 0;     while(c<'0'||c>'9'){         c=getchar_unlocked();     }     while(c>='0'&&c<='9'){         x=(x<<1)+(x<<3)+c-'0';         c=getchar_unlocked();     }     return x; } inline void putint(int n){         int N = n, rev, count = 0;         rev = N;         if (!N){             putchar_unlocked('0');             putchar_unlocked('\n');             return ;         }         while (!(rev%10)){             count++;             rev/= 10;         }         rev = 0;         while (N) {              rev = (rev<<3) + (rev<<1) + N % 10;             N /= 10;         }          while (rev != 0){             putchar_unlocked(rev % 10 + '0');             rev /= 10;         }         while (count--){             putchar_unlocked('0');         }     putchar_unlocked('\n'); } vector<int> v[100001]; bool visited[100001]={0}; vector<int> ans; void bfs(int node){     queue<int> q;     q.push(node);     while(!q.empty()){         int u=q.front();         q.pop();         visited[u]=1;         int x=v[u].size();         for(int i=0;i<x;i++){             int child=v[u][i];             if(!visited[child]){                 q.push(child);                 ans.push_back(child);                 visited[child]=1;                 if(child==node){                     ans.clear();                     return;                 }             }         }     }      } int main(){     int t=scan();     while(t--){         for(int i=0;i<100001;i++){             v[i].clear();         }         memset(visited,0,sizeof(visited));         int n=scan(),m=scan();         while(m--){             int a=scan(),b=scan();             v[a].push_back(b);         }         bool f=0;         int an=0;         for(int i=1;i<=n;i++){             if(!visited[i]){             memset(visited,0,sizeof(visited));                 ans.clear();             bfs(i);                // cout<<ans.size()<<" ";                 if(ans.size()>=n-1){                     f=1;                     an=i;                    // if(i==2){                     //printf("%d ",ans.size());                     //}                      break;                 }             }         }         if(f==0){             putchar_unlocked('-');             putchar_unlocked('1');             putchar_unlocked('\n');         }         else{             putint(an);                      }         ans.clear();     } }
#include <bits/stdc++.h> #define M 1000000007 #define lli unsigned long long   using namespace std;   lli fast_pow(lli a, lli b) { 	lli res = 1LL; 	while ( b > 0 ) { 		if ( b & 1 ) res = (res*a)%M; 		a = (a*a)%M; 		b >>= 1; 	} 	return res; }   int main() { 	int t; 	lli n,k; 	scanf("%d", &t); 	while ( t-- ) { 		scanf("%lld%lld", &n, &k); 		lli base = 0, pro = 1; 		while ( 1 ) { 			if ( pro >= n ) break; 			pro *= 2LL; 			base++; 		} 		if ( pro != n ) base--; 		lli ans = fast_pow(base, k); 		printf("%lld\n", ans); 	} 	return 0; } 
//#include<bits/stdc++.h> #include <iostream> #include <cstdio> #include <vector> #include <map> #include <queue> #include <stack> #include <cstring> #include <algorithm> #include <cstdlib> #include <cmath> #include <set> using namespace std; #define w(t) while(t--) #define S(x) scanf("%d",&x) #define SLL(x) scanf("%lld",&x) #define P(x) printf("%d\n",x) #define fl(i , a, b) for(i = (int)a; i<(int)b; i++) #define mem(a , value) memset(a , value , sizeof(a)) #define tr(c, itr) for(itr = (c).begin(); itr != (c).end(); itr++) #define MOD 1000000007 #define MAX 1000000010 #define ll long long #define all(v) v.begin(),v.end() #define mp make_pair #define pb push_back #define f first #define s second typedef pair<int,int> pp; ll a[1002][1002]; ll dp[1002][1002]; void ncr() { 	int i , j ; 	for(i =0 ;i <= 23 ; i++) 	{ 		for(j =0 ; j<= i ; j++) 		{ 			if(i == 0 || j ==0 ) dp[i][j] =1; 			else 				dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]);  		} 	} 	// cout << dp[7][3] <<endl; } int main() { 	//std::ios_base::sync_with_stdio(false); 	int n  ,i , j ; 	ncr(); 	S(n); 	fl(i ,1 , n+1) 	{ 		fl(j , 1 , n+1) SLL(a[i][j]); 	} 	ll ans =0 ; 	for(i = 1; i<=n ; i++) 	{ 		for(j = i+1; j<= n ;j++) 		{ 			// i - j edge .  			for(int size =2 ; size <= n; size++) 			{ 				int p = size-2;  				ll ways = dp[n-2][p]; 				ans = ans + (a[i][j] * ways * (int(sqrt(size))));  			} 		} 	} 	cout << ans <<endl ; 	return 0; }
#include <bits/stdc++.h> using namespace std; int main() { 	vector<int> v(1000001),div(1000001); 	int t,i,j,n; 	v[1]=1; 	v[0]=1; 	for(i=2;i<=1000000;i++) 	{ 		if(v[i]==0) 		{ 			div[i]=1; 			for(j=2*i;j<=1000000;j=j+i) 			{ 				div[j]++; 				v[j]=1; 			} 		} 	} 	scanf("%d",&t); 	while(t--) 	{ 	   	scanf("%d",&n); 	   	if(v[div[n]]==0) 	   		printf("Funny\n"); 	   	else 	   		printf("Not Funny\n"); 	} 	return 0; } 
#pragma comment(linker, "/STACK:102400000,102400000") #include <iostream> #include <stdio.h> #include <algorithm> #include <string.h> #include <vector> #include <map> #include <queue> #include <set> #include <cmath> #include <fstream> #include <assert.h> #include <complex> using namespace std; #define vi vector<int> #define pii pair<int,int> #define pb push_back #define mp make_pair #define all(x) x.begin(),x.end() #define inf 1000000007 #define mod 1000000007 #define x first #define y second #define pi acos(-1.0) #define DBG(x) cerr<<(#x)<<"="<<x<<"\n"; #define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++) #define ull unsigned long long #define ll long long #define N 1000000  const int M=999999; double sum(int l,int r){     return (l+r)/2.*(r-l+1); } int main() {     //freopen("1.txt","w",stdout);     int T,i,j,k,ca=0,n,m;     scanf("%d",&n);     long double s=0,bias=0,ans=0,ave=M/2.;     deque<pair<int,long double> >q;     q.push_back(mp(1,1));     q.push_back(mp(M,0));         for(i=0;i<n;i++){         int v,r=N,x;s=0;         scanf("%d",&v);         int y=v;         while(v){             x=min(v,q.back().x);             v-=x;             q.back().x-=x;             s+=(q.back().y+bias)*x;             ans-=(bias+q.back().y)*sum(r-x,r-1);             if(q.back().x==0)q.pop_back();             r-=x;         }         q.push_front(mp(y,-bias));         bias+=s/N;         ans+=(1-s)*y;         ans+=s*ave;         printf("%.9lf\n",(double)ans);     }     return 0; }
#include<iostream> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {         long long n;         cin>>n;         cout<<n-1<<endl;     } } 
#include <iostream> #include <string> #include <stdlib.h> using namespace std;  struct guy { 	string name; 	int score; };  int main() { 	ios_base::sync_with_stdio(false); 	cin.tie(NULL);  	int t, score, flag=0, count=0, max=0, rem; 	string name, scoreS; 	cin >> t; 	guy a[t][15]; 	for (int z=0; z<t; z++) 	{ 		count=0; 		int n; 		cin >> n; cin.ignore(); 		for (int i=0; i<n; i++) 		{ 			flag=0; 			getline(cin, name, ' '); 			getline(cin, scoreS); 			score=atoi(scoreS.c_str()); 			for (int j=0; j<count; j++) 			{ 				if (a[z][j].name==name)  				{ 					a[z][j].score+=score; 					flag=1; 				} 			} 			if (flag==0) 			{ 				a[z][count].name=name; 				a[z][count].score=score; 				count++; 			} 		}  		max=0; 		for (int i=0; i<count; i++) 		{ 			if (a[z][i].score>max)  			{ 				max=a[z][i].score; 				rem=i; 			} 			//cout << count << " " << i << " " << a[z][i].name << " " << a[z][i].score << endl;	 		} 		cout << a[z][rem].name << " " << a[z][rem].score << endl; 	} }
#include<bits/stdc++.h> #include <math.h> using namespace std;  #define MOD 1000000007 #define MAX 2010 #define ll long long #define slld(t) scanf("%lld",&t) #define sd(t) scanf("%d",&t) #define sld(t) scanf("%ld",&t) #define pd(t) printf("%d\n",t) #define plld(t) printf("%lld\n",t) #define pcc pair<char,char> #define pp pair<int,int> #define pll pair<ll,ll> #define tr(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++) #define mp(a,b) make_pair(a,b) #define F first #define S second #define pb(x) push_back(x)  int A[1000007];  bool f(int x) { 	if(x==1) return false; 	int m = sqrt(x); 	if(m*m==x){ 		return true; 	} 	return false; } int main() { 	int t; 	sd(t); 	while(t--) 	{ 		int n; 		sd(n); 		int count = 0; 		for( int i=1; i<=n; i++) 		{ 			sd(A[i]); 			int k = __gcd(i,A[i]); 			if(f(k)) 			{ 				count++; 			} 		} 		sort(A+1,A+n+1); 		ll ans = 1; 		for( int i=n; i>n-count; i--) 		{ 			ans = ans*A[i]; 			ans%=MOD; 		} 		plld(ans); 	} }
#include<bits/stdc++.h> using namespace std;  #define ll long long #define inf 0x7fffffff #define SCD(t) scanf("%d",&t) #define SCLD(t) scanf("%ld",&t) #define SCLLD(t) scanf("%lld",&t) #define SCC(t) scanf("%c",&t) #define SCS(t) scanf("%s",t) #define SCF(t) scanf("%f",&t) #define SCLF(t) scanf("%lf",&t) #define pr pair<int,int> #define mp(a,b) make_pair(a,b) #define pb push_back #define fr first #define sc second #define mset(arr,val) memset(arr,val,sizeof(arr));  const int MAX = 500005; const int MOD = 1e9+7;  int gcd(int a,int b){ 	if(a%b == 0) return b; 	else return gcd(b,a%b); }  int arr[MAX]; int n,k; bool calc(int len){ 	int tlen = len; 	std::vector< int > pre(n+1); 	std::vector< int > suf(n+1); 	for(int i = 0;i<n;i+=len){ 		if(i+len>=n) len = n - i; 		int gcdp = arr[i]; 		int gcds = arr[i+len-1]; 		for (int j = 0; j < len; ++j) 		{ 			gcds = gcd(gcds,arr[i+len-1-j]); 			gcdp = gcd(gcdp,arr[i+j]); 			pre[i+j] = gcdp; 			suf[i+len-1-j] = gcds; 		} 	} 	// for (int i = 0; i < n; ++i) 	// { 	// 	cout<<i<<" "<<suf[i]<<" "<<pre[i]<<endl; 	// } 	len = tlen; 	for (int i = 0; i <= n-len; ++i) 	{ 		int gcdh = gcd(suf[i],pre[i+len-1]); 		if(gcdh >= k) return true; 	} 	return false; }  int main(){ 	// freopen("input.txt","r",stdin); 	cin>>n>>k; 	for (int i = 0; i < n; ++i) 	{ 		cin>>arr[i]; 	} 	// cout<<calc(4); 	int li = 0; 	int ul = n; 	while(li<ul){ 		int mid = (li+ul+1)/2; 		if(calc(mid)) 			li = mid; 		else 			ul = mid-1; 	} 	cout<<li; }
#include <bits/stdc++.h>  using namespace std;  typedef long long int ll;  int gcd(int a, int b) { 	while(b) 	{ 		int t = a % b; 		a = b; 		b = t; 	} 	return a; }  int main() { 	int T; 	scanf("%d",&T); 	while(T--) 	{ 		int N, Q; 		scanf("%d%d",&N,&Q); 		int* A = new int[N]; 		for(int i = 0;  i < N; i++) 			scanf("%d",&A[i]); 		int* ltor = new int[N]; 		int* rtol = new int[N]; 		ltor[0] = A[0]; 		for(int i = 1; i < N; i++) 			ltor[i] = gcd(max(A[i], ltor[i - 1]), min(A[i], ltor[i - 1])); 		rtol[N - 1] = A[N - 1]; 		for(int i = N - 2; i >= 0; i--) 			rtol[i] = gcd(max(A[i], rtol[i + 1]), min(A[i], rtol[i + 1])); 		int L, R; 		while(Q--) 		{ 			scanf("%d%d",&L,&R); 			L--, R--; 			if(L == 0) 				printf("%d\n",rtol[R + 1]); 			else if(R == N - 1) 				printf("%d\n",ltor[L - 1]); 			else 				printf("%d\n",gcd(ltor[L - 1], rtol[R + 1])); 		} 	} 	return 0; } 
#include<bits/stdc++.h> using namespace std; int C[100010],n; vector< pair<int,int> > E[100010]; vector<int> G[100010]; char visited[100010]; int D[100010]; vector<int> V;  int dfs(int x,int val) {   int ret=x;   vector<int>::iterator it;   for(it=G[x].begin();it!=G[x].end();it++)   {     if(visited[*it]!=val)     {        D[*it]=1+D[x];        visited[*it]=val;        int z = dfs(*it,val);         if(D[z]>D[ret])          ret=z;     }   }   return ret; }  int process(int g) {    for(int g2=g;g2<=100000;g2+=g)    {      vector< pair<int,int> >::iterator it;      for(it=E[g2].begin();it!=E[g2].end();it++)      {         pair<int,int> p= *it;          G[p.first].push_back(p.second);         G[p.second].push_back(p.first);         V.push_back(p.first);         V.push_back(p.second);      }    }     int ret=0;    vector<int>::iterator it;    for(it=V.begin();it!=V.end();it++)    {         if(visited[*it])           continue;            D[*it]=0;           visited[*it]=1;           int y = dfs(*it,1);           D[y]=0;           visited[y]=2;           y = dfs(y,2);           ret = max(ret,D[y]);    }     for(it=V.begin();it!=V.end();it++)    {       G[*it].clear();       visited[*it]=0;    }     V.clear();    return ret;   }  int main() {    int t;    cin>>t;    int x,y,c;     while(t--)    {      cin>>n;      int mxx=0;      for(int i=1;i<=100000;i++)       E[i].clear();        for(int i=0;i<n-1;i++)       {        cin>>x>>y>>c;        x--; y--;        mxx = max(mxx,c);        E[c].push_back(make_pair(x,y));       }        for(int g=1;g<=mxx;g++)       {          C[g]=0;            for(int g2=g;g2<=mxx;g2+=g)              C[g]+=E[g2].size();       }       long long ans=0;       for(int g=1;g<=mxx;g++)       {          int mx=0;           for(int g2=2*g;g2<=mxx;g2+=g)            mx=max(mx,C[g2]);         if(mx<C[g])           ans=max(ans,1LL*g*process(g));       }       cout<<ans<<endl;      }   } 
#include <bits/stdc++.h> using namespace std;  #define ll long long  ll all_xor(ll n){     if(n % 2 == 1){         if(n % 4 == 1)  return 1;         else return 0;     }     else{         if(n % 4 == 0)  return n;         else return n + 1;     } }  ll xor_even(ll n){     return (all_xor(n / 2) * 2); }  ll xor_odd(ll n){     return (all_xor(n) ^ xor_even(n - 1)); }  void solve(){     ll x, m, ans;     cin>>x>>m;      ans = all_xor(x + (2 * m) - 2) ^ all_xor(x - 1);     if(x % 2 == 0)  ans ^= (xor_odd(x + (2 * m) - 3) ^ xor_odd(x - 1));     else ans ^= (xor_even(x + (2 * m) - 3) ^ xor_even(x - 1));      if(x == 0 and m == 0)  ans = 0;      if(ans == 0)    cout<<"BOB"<<endl;     else cout<<"ALICE"<<endl; }  int main(){      int t;     cin>>t;     while(t--)  solve();     return 0; }
//Author : pakhandi // using namespace std;   #include<iostream> #include<cstdio> #include<cstdlib> #include<algorithm> #include<cmath> #include<cstring> #include<iterator> #include<sstream> #include<fstream> #include<cassert> #include<climits> #include<cstdlib> #include<string> #include<vector> #include<queue> #include<deque> #include<stack> #include<map> #include<set> #include<bitset>   #define wl(n) while(n--) #define fl(i,a,b) for(i=a; i<b; i++) #define rev(i,a,b) for(i=a; i>=b; i--) #define scan(n) scanf("%d", &n) #define scans(s) scanf("%s", s) #define scanc(c) scanf("%c", &c) #define scanp(f) scanf("%f", &f) #define print(n) printf("%d\n", n) #define prints(s) printf("%s\n", s) #define printc(c) printf("%c\n", c) #define printp(f) printf("%f\n", f) #define nline printf("\n") #define mclr(strn) strn.clear() #define ignr cin.ignore() #define MOD 1000000007 #define ll long long int #define u64 unsigned long long int int arr[10005]; int main() { 	int i, j, cases, k=1; 	int n, h, flag; 	scan(cases); 	wl(cases) 	{ 		scan(h); 		scan(n); 		flag=0; 		arr[0]=0; 		fl(i,1,n+1) 			scan(arr[i]); 		sort(arr, arr+(n+1)); 		fl(i,1,n+1) 		{ 			//cout<<arr[i]; 			if(arr[i]-arr[i-1]>h) 			{ 				printf("No"); 				flag=1; 				break; 			} 		} 		if(flag==0) 			printf("Yes"); 		nline; 	} 	return 0; }
//Author : pakhandi // using namespace std;   #include<iostream> #include<cstdio> #include<cstdlib> #include<algorithm> #include<cmath> #include<cstring> #include<iterator> #include<sstream> #include<fstream> #include<cassert> #include<climits> #include<cstdlib> #include<string> #include<vector> #include<queue> #include<deque> #include<stack> #include<map> #include<set> #include<bitset>   #define wl(n) while(n--) #define fl(i,a,b) for(i=a; i<b; i++) #define rev(i,a,b) for(i=a; i>=b; i--) #define scan(n) scanf("%d", &n) #define scans(s) scanf("%s", s) #define scanc(c) scanf("%c", &c) #define scanp(f) scanf("%f", &f) #define print(n) printf("%d\n", n) #define prints(s) printf("%s\n", s) #define printc(c) printf("%c\n", c) #define printp(f) printf("%f\n", f) #define nline printf("\n") #define mclr(strn) strn.clear() #define ignr cin.ignore() #define MOD 1000000007 #define ll long long int #define u64 unsigned long long int int arr[1000005]; int main() { 	int i, j, cases, k=1; 	scan(cases); 	int np, l, a, count; 	wl(cases) 	{ 		scan(np); 		scan(l); 		fl(i,0,1000005) 		{ 			arr[i]=0; 		} 		fl(i,0,l) 		{ 			scan(a); 			arr[a]++; 			scan(a); 			arr[a]++; 		} 		count=0; 		fl(i,0,1000005) 		{ 			if(arr[i]%2!=0 && arr[i]>0){ 				//cout<<arr[i]; 				count++; 				} 		} 		if(count==0 || count==2) 			printf("Possible"); 		else 			printf("Not Possible"); 		nline; 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; int visited[105]; int main() { 	int t,n,m,q,i,j; 	scanf("%d",&t); 	while(t--) 	{ 		vector< vector<int> > v(105); 		int count=0,temp1,temp2; 		scanf("%d",&n); 		for(i=1;i<=n;i++) 		visited[i]=0; 		scanf("%d %d",&m,&q); 		for(i=1;i<=m;i++) 		{ 			scanf("%d %d",&temp1,&temp2); 			v[temp1].push_back(temp2); 			v[temp2].push_back(temp1); 		} 		 		for(i=1;i<=n;i++) 		{ 			if(visited[i]==0) 			{ 				count++; 			    visited[i]=count; 				queue<int> q; 				q.push(i); 				while(!q.empty()) 				{	 						int temp=q.front(); 						q.pop(); 						int len=v[temp].size(); 						for(int i=0;i<len;i++) 						{ 							if(visited[v[temp][i]]==0) 							{ 							visited[v[temp][i]]=count; 							q.push(v[temp][i]); 							} 						} 				} 			} 		} 		for(i=1;i<=q;i++) 		{ 			scanf("%d %d",&temp1,&temp2); 			if(visited[temp1]!=visited[temp2]) 			printf("bus and taxi\n"); 			else 			printf("only bus\n"); 		} 	} 	return 0; }
#include <iostream> #include <algorithm> #include <vector> #include <string>  using namespace std;  int main() { 	int tc; 	cin >> tc; 	string sn; 	while (tc--) { 		cin >> sn; 		if(next_permutation(sn.begin(),sn.end())) 			cout << sn << endl; 		else 			cout << "-1"<<endl; 	} 	return 0; }
#include<iostream> using namespace std; int main() { int t,n,i,op; int a,dif; //cin>>t; scanf("%d",&t); for(int i=0;i<t;i++) {a=1; //cin>>n; scanf("%d",&n);  if(n==0||n==1) op=n;  else { while(a<=n) {a=a*2;}  a=a/2; dif=n-a; op=2*dif+1; } //cout<<op<<"\n"; printf("%d\n",op);  }  return 0; } 
#include <iostream> using namespace std;   int main() { 	int t; 	while(scanf("%d",&t) != EOF) 	{ 		printf("%d\n",t-1); 	} 	return 0; }
#include<iostream> #include<cstdio> #include<cstdlib> #include<algorithm> using namespace std;   typedef long long ULL; #define REP(i,N) for(int i = 0; i < N; i++)   int main() { 	int t, N; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%d",&N); 		int * arr =(int *)calloc(N,sizeof(int)); 		int j; 		for(int i = 0; i < N; i++) 		{ 			scanf("%d",&arr[i]); 			j = arr[i] - i; 			arr[i] = j; 		} 		//cout<<"SORTING"<<endl; 		sort(arr,arr+N); 		//REP(i,N)	cout<<arr[i]<<" "; 		//cout<<endl; 		//cout<<"SORTING DONE"<<endl; 		int maxC=1,cnt=1; 		j = arr[0]; 		for(int i = 1; i < N; i++) 		{ 			if(arr[i] == j) 			{ 				cnt += 1; 				if(cnt > maxC) 					maxC = cnt; 			} 			else 			{ 				if(cnt > maxC)  					maxC = cnt; 				cnt = 1; 				j = arr[i]; 			} 		} 		printf("%d\n",N-maxC); 		free(arr); 	} 	return 0; }
//Author : pakhandi // using namespace std;   #include<iostream> #include<cstdio> #include<cstdlib> #include<algorithm> #include<cmath> #include<cstring>   #define wl(n) while(n--) #define fl(i,a,b) for(i=a; i<b; i++) #define rev(i,a,b) for(i=a; i>=b; i--) #define scan(n) scanf("%d", &n) #define scans(s) scanf("%s", s) #define scanc(c) scanf("%c", &c) #define scanp(f) scanf("%f", &f) #define scanll(l) scanf("%lld", &l) #define print(n) printf("%d\n", n) #define prints(s) printf("%s\n", s) #define printc(c) printf("%c\n", c) #define printp(f) printf("%f\n", f) #define printll(l) printf("%lld\n", l) #define nline printf("\n") #define mclr(strn) strn.clear() #define ignr cin.ignore() #define MOD 1000000007 #define ll long long int   int mat[3][2][4]=  {   {{10, 15, -25, 1} , {-10, -15, 25, 2}} ,   {{10, 15, -25, 0} , {-10, -20, 30, 1}} ,   {{10, 20, -30, 2} , {-10, -15, 25, 0}} };   int main() {   int i, j, cases=2, n;   int temp=0, eb=60, ew=100, eg=160, b, w, g, ele;     	  scan(n); 	  eb=60; ew=100; eg=160; 	  fl(i,0,n) 	  { 	    scan(ele); 		ele--; 	    eb=eb+mat[temp][ele][0]; 	    ew=ew+mat[temp][ele][1]; 	    eg=eg+mat[temp][ele][2]; 	    temp=mat[temp][ele][3]; 	  } 	  eb/=10; 	  ew/=10; 	  eg/=10; 	  printf("%d %d %d", eb,ew, eg); 	  nline;     return 0; } 
#include<iostream> #include<cstdio> #include<cstdlib> #include<algorithm>  using namespace std; typedef long long ll;  int main() { 	int t; 	ll ans,n; 	scanf("%d",&t); 	while(t--) 	{ 		scanf("%lld",&n); 		if(n == 1) 		{ 			printf("1\n"); 			continue; 		} 		ans = (n*n)/2 -1; 		printf("%lld\n",ans); 	} 	return 0; }
#include <bits/stdc++.h> #define pb push_back #define mp make_pair #define s(a) sort(a.begin(),a.end()) #define vecll vector<long long int> #define vecs vector<string> #define vecpll vector<pair<long long int,long long int> > #define rep(i,a,b) for(long long int (i)=(a);(i)<(b);(i)++) #define repr(i,b,a) for(long long int (i)=(b);(i)>=(a);(i)--) #define fast_IO ios_base::sync_with_stdio(false);cin.tie(0); #define while_tc long long int t;cin>>t;while(t--) #define ispow2(n) (n&&(!(n&(n-1))))      ///check if its perfect power of 2 #define MOD 1000000007 #define arrinput long long int n;cin>>n;long long int a[n];for(long long int i=0;i<n;i++)cin>>a[i] typedef long long int ll; using namespace std; int main() { 	while_tc 	{ 	ll n; 	ll ans=0; 	cin>>n; 	for(ll i=n;i!=0;i--) 	{ 		ans=ans+(i*(n/i)); 	} 	cout<<ans%1000000007<<endl;}  }
//	__R0b__ #include <iostream> using namespace std;  inline int gcd(int a,int b){ 	if(b==0) 		return a; 	return gcd(b,a%b); }  int main(){ 	int t; cin>> t; 	for(int i=1;i<=t;i++){ 		int a,b,c; cin>> a >> b >> c; 		int g = gcd (a,b); 		//cout << g << endl; 		if (c%g==0){ 			printf("Case %d: ",i); 			puts ("Yes"); 		} 		else{ 			printf("Case %d: ",i); 			puts("No"); 		} 	} 	return 0; } 
#include<bits/stdc++.h>   using namespace std;  #define M 1000000007 typedef long long ll; int main() { 	 	ll t; 	cin>>t; 	 for(ll l=1;l<=t;l++)	 {  	ll n; 		cin>>n; 		 		 ll a[n+1]; 	for(ll i=1;i<=n;i++) 	{ 		a[i]=i; 		a[i]=a[i]%M; 	} 		 		for(ll j=2;j<=n;j++) 		{ 			 			for(ll i=1;i<=n-j+1;i++  ) 			{ 				 				a[i]=a[i]+a[i+1]; 				 				a[i]=a[i]%M; 			} 			 			 			 			 		} 		 		 		 		cout<<"Case "<<l<<": "<<a[1]<<endl; 		 		 	//	    printf("Case %lld: 1\n",a[1]); 		 	} 	 	 	return 0; }
#include <iostream> #include <cstring> #include <cstdio> #include <cmath> #include <map> #include <cassert>  using namespace std;  int bkt_size; int n; int tree[223][200005]; int A[100005];  //Code for FAST INPUT :) template <typename T> inline void fi(T *a) {     register char c=0;     while (c<33) c=getchar_unlocked();     *a=0;     int tmp = 0;     while (c>33)     {         if ( c == 45 ) tmp = 1;         else *a=*a*10+c-'0';         c=getchar_unlocked();     }     if ( tmp == 1 ) *a = 0-(*a); }  void update(int idx1, int idx2, int val) {     while ( idx2 <= n ) {         tree[idx1][idx2] += val;         idx2 += (idx2 & (-idx2));     }     return; }  int query(int idx1, int idx2) {     int ans = 0;     while ( idx2 > 0 ) {         ans += tree[idx1][idx2];         idx2 -= (idx2 & (-idx2));     }     return ans; }  struct node {     int type;     int a;     int b;     int val;     node() {  }     node(int type, int a, int b, int val)     {          this->type = type;          this->a = a;          this->b = b;          this->val = val;     } }Q[100005];  int main() {     map <int, int> mp;     map <int, int> :: iterator it;     int q, cnt = 1, type, x, y, val, ans, idx;      fi(&n), fi(&q);     assert(n >= 1 && n <= 100000);     assert(q >= 1 && q <= 100000);     bkt_size = 220;      for ( int i = 1; i <= n; i++ ) fi(&A[i]), mp[A[i]] = 1, assert(A[i] >= 1 && A[i] <= 1000000000);      for ( int i = 1; i <= q; i++ ) {         fi(&type);         assert(type >= 1 && type <= 2);         if ( type == 1  ) {             fi(&x), fi(&val);             assert(x >= 1 && x <= n);             assert(val >= 1 && val <= 1000000000);             mp[val] = 1;             Q[i] = node(1,x,x,val);         }         else {             fi(&x), fi(&y), fi(&val);             assert(x <= y);             assert(x <= n && x >= 1 && y >= 1 && y <= n);             mp[val] = 1;             Q[i] = node(2,x,y,val);         }     }      for ( it = mp.begin(); it != mp.end(); it++ ) it->second = cnt++;      for ( int i = 1; i <= n; i++  ) A[i] = mp[A[i]];     for ( int i = 1; i <= q; i++ ) Q[i].val = mp[Q[i].val];      for ( int i = 1; i <= n; i++ ) update(i/bkt_size, A[i], 1);      for ( int i = 1; i <= q; i++ ) {         if ( Q[i].type == 1  ) {             update(Q[i].a/bkt_size, A[Q[i].a], -1);             A[Q[i].a] = Q[i].val;             update(Q[i].a/bkt_size, A[Q[i].a], 1);         }         else {             ans = 0;             idx = Q[i].a;             while ( idx%bkt_size != 0 && idx <= Q[i].b  ) {                 ans += (A[idx] <= Q[i].val);                 idx++;             }             while ( idx+bkt_size-1 <= Q[i].b ) {                 ans += query(idx/bkt_size, Q[i].val);                 idx += bkt_size;             }             while ( idx <= Q[i].b ) {                 ans += (A[idx] <= Q[i].val);                 idx++;             }             printf("%d\n", ans);         }     }     return 0; } 
#include<iostream> using namespace std;  int main() { 	int t; 	cin>>t; 	while(t--) 	{ 		int w; 		cin>>w; 		if(w%2==0 && w!=2) 			cout<<"YES"<<endl; 		else 			cout<<"NO"<<endl; 	} 	return 0; }
#include<bits/stdc++.h> #define mod 215372682525LL using namespace std; //typedef long long ll; long long arr[100010]; long long ans[100010]; int main() { 	std::ios_base::sync_with_stdio(false); 	long long  t; 	cin>>t; 	while(t--) 	{ 		long long a,d,n,x,i; 		cin>>a>>d>>n>>x; 	 		memset(arr,0,sizeof(arr)); 		memset(ans,0,sizeof(ans)); 		arr[0]=1; 		ans[0]=1; 		for(i=1;i<=n+1;i++) 		{ 			arr[i]=((arr[i-1]%mod)*(x%mod))%mod; 			arr[i]%=mod; 			ans[i]=(ans[i-1]+arr[i])%mod; 			ans[i]%=mod; 			 		} 		long long  ans1=0; 		for(i=0;i<=n;i++) 		{ 			ans1+=(i*arr[n-i])%mod; 			ans1%=mod; 		} 	 		cout<<((ans1*d)%mod+(ans[n]*a)%mod)%mod<<endl; 	} }
#include<bits/stdc++.h> using namespace std; #define ll long long ll *id, cnt, *sz; map<ll,ll> mp;  //use this map to map indexes with data. void init(ll N) {     cnt = N; 	id = new ll[N+1]; 	sz = new ll[N+1];     for(ll i=1; i<=N; i++)     {         id[i] = i; 	    sz[i] = 1; 	} } ll find(ll p) {     if(id[p]==p)         return p;     return id[p]=find(id[p]); } // Replace sets containing x and y with their union. void merge(ll x, ll y) {     ll i = find(x);     ll j = find(y);     if (i == j) return;     // make smaller root point to larger one     if(sz[i]<sz[j])     {         id[i]=j;         sz[j]+=sz[i];     }     else     {         id[j]=i;         sz[i]+=sz[j];     }     cnt--; } vector<pair <ll, pair<ll, ll> > > p; vector<ll> mst[200003]; ll nodes,edges; long long kruskal() {     ll x, y;     long long cost, minimumCost = 0;     for(ll i = 0;i < edges;++i)     {         x = p[i].second.first;         y = p[i].second.second;         cost = p[i].first;         if(find(x) != find(y))         {             minimumCost += cost;             mst[x].push_back(y);             mst[y].push_back(x);             merge(x, y);         }     }     return minimumCost; } vector<pair<ll,ll> > v; bool visited[200003]; ll subcnt[200003],ans[200003]; ll dfs(int x, int par) {     ans[x] = 0;     subcnt[x] = 0;     for (int i = 0; i < mst[x].size(); i++)     {         if (mst[x][i] == par)             continue;         ll ccnt = dfs(mst[x][i], x);         ans[x] += ccnt * subcnt[x];         subcnt[x] += ccnt;     }     return subcnt[x] + 1; } bool comp(const pair<ll,ll> &a,const pair<ll,ll> &b) {     if(a.first!=b.first)     {         return a.first>b.first;     }     return a.second<b.second; } int main() {     ios_base::sync_with_stdio(false);     cin.tie(NULL);     cout.tie(NULL);     ll x, y;     long long weight, cost, minimumCost;     ll i,n;     cin >> nodes >> edges;     init(nodes);     //creating the sets     for(i = 0;i < edges;++i)     {         cin >> x >> y >> weight;         p.push_back(make_pair(weight, make_pair(x, y)));     }     sort(p.begin(),p.end());     minimumCost = kruskal();     dfs(1,-1);     for(i=1;i<=nodes;i++)     {         ans[i]+=subcnt[i]*(nodes-1-subcnt[i]);         v.push_back(make_pair(-ans[i],i));     }     sort(v.begin(),v.end());     for(i=0;i<v.size();i++)     {         cout<<v[i].second<<"\n";     }     return 0; } 
/* Written by: Durgesh Kr. Soni    ABV-IIITM Gwalior    Problem:GOOGOL04*/  #include<bits/stdc++.h> using namespace std;  //template tools #define pb                   push_back #define ppb                  pop_back #define mp                   make_pair #define ff                   first #define ss                   second  #define INF                  2147483647 #define INFLL                9223372036854775807LL #define PI                   acos(-1.0) #define E                    exp(1.0) #define EPS                  1e-12 #define gcd(_1,_2)           __gcd(_1,_2) #define lcm(_1,_2)           ((_1/gcd(_1,_2))*(_2)) #define cnt_1                __builtin_popcountll #define rep(i,a,b)           for(int i=(a);i<=(b);++i) #define rer(i,b,a)           for(int i=(b);i>=(a);--i) #define clr(_)               memset(_,false,sizeof(_)) #define feach(c,_)           for(__typeof((c).begin()) _=(c).begin();_!=(c).end();++_) #define all(_)               _.begin(),_.end() #define sz(_)                (int(_.size())) #define len(_)               (int(_.length())) #define T()                  int _;cin>>_;while(_--) #define exist(x,_)           (((_).find(x))!=((_).end()))  //traces #define SP                   system("pause") #define nl                   cout<<endl #define dbg(vari)            cerr<<#vari<<" = "<<(vari);nl #define dbgv(A,n)            nl;rep(ti,0,n-1) cout<<ti<<" -- > "<<A[ti]<<"\n"; #define dbgvp(Z)             nl;rep(ti,0,sz(Z)-1){cout<<ti<<" --> "<<Z[ti].ff<<" "<<Z[ti].ss<<"\n";} #define dbgg(W,n)            nl;rep(ti,1,n){cout<<ti<<" --> ";rep(tj,0,sz(W[ti])-1) cout<<"("<<W[ti][tj].ff<<" , "<<W[ti][tj].ss<<")"<<"  ";cout<<"\n";} #define dks                  cerr<<" ----- I am Here -----\n";SP #define fout(S,x)            cout<<fixed<<setprecision(x)<<(S)<<endl  typedef long long int LL;     typedef unsigned long long ULL;  typedef long double LD;      typedef pair<int,int> PII; typedef vector<int> VI;       typedef vector<PII> VPII;        typedef set<PII> SPII;       typedef vector<LL> VLL; typedef pair<LL,LL> PLL;      typedef vector<PLL> VPLL;        typedef set<PLL> SPLL;       typedef map<LL,LL> MLL; typedef map<string,int> MSI;  typedef map<int,VI> MVI;         typedef map<int,PII> MPII;   typedef vector<string> VS;  //mathematics #define dist(x1,y1,x2,y2)        ((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)) #define area(x1,y1,x2,y2,x3,y3)  (abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))/2.0)) #define ln(x)                    (LL(log2(double(x)))) #define dig(x)                   (LL(log10(double(x)))+1) #define ceil(a,b)                (LL(ceil(double(a)/double(b)))) #define sin(x)                   (sin((x*PI)/180.0)) #define sq(x)                    ((x)*(x))  #define gc                       getchar//_unlocked #define pc                       putchar//_unlocked #define RG                       100007  bool markP[RG];VLL prime; inline void sieve(){LL i,j;for(i=2;i*i<=RG;++i)if(!markP[i])for(j=i<<1;j<RG;j+=i)if(!markP[j])markP[j]=1;prime.pb(2);for(i=3;i<RG;i+=2)if(!markP[i])prime.pb(i);} inline void inp(int &x){register int c=gc();x=0;bool neg=0;for(;((c<48||c>57)&&c!='-');c=gc());if(c=='-'){neg=1;c=gc();}for(;c>47&&c<58;c=gc()){x=(x*10)+(c-48);}if(neg)x=-x;} inline LL modexp(LL a,LL b,const LL &mod){LL x=1;while(b>0){if(b&1){x*=a;if(x>=mod)x%=mod;};b>>=1;a*=a;if(a>=mod)a%=mod;}return x;} inline LL mulmod(LL a,LL b,const LL &mod){LL x=0;a%=mod;while(b>0){if(b&1){x+=a;if(x>=mod)x%=mod;}a<<=1;if(a>=mod)a%=mod;b>>=1;}return x;} inline LL invmod(LL &a,const LL &mod){return modexp(a,mod-2,mod);} inline LL power(LL a,LL b){LL x=1;while(b>0){if(b&1)x=(x*a);a*=a;b>>=1;}return x;} inline LL digSum(LL n){LL s=0;n=abs(n);while(n){s+=(n%10);n/=10;}return s;} inline string toStr(LL &num){ return static_cast<stringstream*>( &(stringstream()<<num))->str();} inline LL toNum(const string &st){LL num;stringstream ss(st);ss>>num;return num;} inline LL elePos(const vector<LL> &A,const LL &x){LL l=0,h=sz(A)-1,m;while(l<=h){ m=(h+l)>>1;if(x==A[m])return (m+1);(x<A[m])?(h=m-1):(l=m+1);}return -1;} inline LL comb(const LL &N,LL R){R>(N-R)?(R=N-R):R;LL mul=1LL;rep(i,0,R-1)mul=(mul*(N-i))/(i+1);return mul;} inline LL strmod(string &T,const LL &mod){LL mul=0;rep(i,0,len(T)-1){mul=(mul*10+T[i]-48);if(mul>=mod)mul%=mod;}return mul;} inline LL fib(LL n){LL i,j,h,k,t;i=h=1;j=k=0;while(n){if(n&1){t=j*h;j=i*h+j*k+t;i=i*k+t;}t=h*h;h=2*k*h+t;k=k*k+t;n>>=1;}return j;} inline bool isPrime(const LL &x){if(x<=3)return(x<=1?0:1);if(!(x&1)||!(x%3))return 0;for(LL i=5;i*i<=x;i+=6)if(!(x%i)||!(x%(i+2)))return 0;return 1;} inline bool isPalin(const string &st){int l=len(st);for(int i=0;(i<<1)<l;++i)if(st[i]!=st[l-i-1])return 0;return 1;} inline bool cmp(const PII &X,const PII &Y) {return (X.ff!=Y.ff)?(X.ff<Y.ff):(X.ss<Y.ss);}  #define MOD                  1000000007 #define MAX                  1000007  int A[MAX],temp[MAX]; inline int LIS(const int &n){ 	int ans=1; 	temp[1]=A[1]; 	rep(i,2,n){ 		if(A[i]<temp[1]) temp[1]=A[i]; 		else if(A[i]>=temp[ans]) temp[++ans]=A[i]; 		else { 			int l=1,h=ans,mid; 			while(l<=h){ 				mid=(l+h)/2; 				if(temp[mid]<=A[i] && temp[mid+1]>A[i]){ 					temp[mid+1]=A[i]; 					break; 				} 				if(temp[mid]<=A[i]) l=mid+1; 				else h=mid-1; 			} 		} 	} 	return ans; } 	 int main() { 	ios_base::sync_with_stdio(false); 	int n; 	cin>>n; 	rep(i,1,n) cin>>A[i]; 	cout<<n-LIS(n)<<endl; 	return 0; }                         
//	__R0b__ #include <iostream> #include <map> #include <iterator> using namespace std;  int main(){ 	//freopen ("input.txt","r",stdin); 	//freopen ("output.txt","w",stdout); 	int t; cin>> t; 	map <string , int> mapp; 	map <string , int>::iterator that; 	for (int i=0;i<t;i++){ 		string s; cin>>s; 		mapp [s]++; 	} 	for (that = mapp.begin(); that!=mapp.end();that++){ 		cout << that->first << " "<< that->second << endl; 	} 	return 0; }
#include <bits/stdc++.h> using namespace std; #define ull unsigned long long struct node { 	unsigned long long data; 	bool lazy , query1 , query2; 	node *left , *right; }; node *build(ull a[] , int strt , int end) { 	node *temp = (node *)malloc(sizeof(node)); 	if(strt == end) 	{ 		temp->data = a[strt]; 		temp->left = temp->right = NULL; 		temp->lazy = 0; 		temp->query1 = temp->query2 = 0; 		return temp; 	} 	int mid = (strt + end)/2;   	temp->left = build(a , strt,  mid); 	temp->right = build(a , mid + 1 , end); 	temp->data = temp->left->data ^ temp->right->data; 	temp->lazy = 0; 	temp->query1 = temp->query2 = 0; 	return temp; } void rangeupdate(node *root , int strt , int end , int x , int y , bool flag) { 	if(strt >= x && end <= y) 	{ 		if(!root->lazy) 		{ 			if(!((end - strt + 1) & 1)) 			{ 				if(((end - strt + 1)/2) & 1) 					root->data = ~root->data; 			} 			else 			{ 				if((flag && (((end - strt + 1)/2) & 1))||(!flag && !(((end - strt + 1)/2) & 1))) 					root->data = ~root->data;   			} 			if(!flag) 			{ 				root->query1 = 1; 				root->query2 = 0; 			} 			else 			{ 				root->query1 = 0; 				root->query2 = 1; 			} 			root->lazy = 1; 		} 		else 		{ 			if(flag) 			{ 				root->query2 = !root->query2; 				if(!root->query1 && !root->query2) 					root->lazy = 0; 				if(!((end - strt + 1) & 1)) 				{ 					if(((end - strt + 1)/2) & 1) 						root->data = ~root->data; 				} 				else 				{ 					if((((end - strt + 1)/2) & 1)) 						root->data = ~root->data; 				} 			} 			else 			{ 				root->query1 = !root->query1; 				if(!root->query1 && !root->query2) 					root->lazy = 0; 				if(!((end - strt + 1) & 1)) 				{ 					if(((end - strt + 1)/2) & 1) 						root->data = ~root->data; 				} 				else 				{ 					if(!(((end - strt + 1)/2) & 1)) 						root->data = ~root->data; 				} 			} 		} 		return; 	}   	int mid = (strt + end)/2;   	if(root->lazy) 	{ 		if(root->query1) 			rangeupdate(root->left , strt , mid , strt , mid , 0); 		if(root->query2) 			rangeupdate(root->left , strt , mid , strt,  mid , 1); 		if(!((mid - strt + 1) & 1)) 		{ 			if(root->query1) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 0); 			if(root->query2) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 1); 		} 		else 		{ 			if(root->query1) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 1); 			if(root->query2) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 0); 		} 		root->lazy = root->query1 = root->query2 = 0; 	}   	if(y <= mid) 		rangeupdate(root->left , strt , mid , x , y , flag); 	else if(x > mid) 		rangeupdate(root->right , mid + 1 , end , x , y , flag); 	else 	{ 		rangeupdate(root->left , strt , mid , x , mid , flag); 		if(!((mid - x + 1) & 1)) 		{ 			if(flag == 0) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , y , 0); 			else 				rangeupdate(root->right , mid + 1 , end , mid + 1 , y , 1); 		} 		else 		{ 			if(flag == 0) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , y , 1); 			else 				rangeupdate(root->right , mid + 1 , end , mid + 1 , y , 0); 		} 	} 	root->data = root->left->data ^ root->right->data; } void pointupdate(node *root , int strt , int end , int x , ull y) { 	if(strt == end) 	{ 		root->data = y; 		return; 	} 	int mid = (strt + end)/2;   	if(root->lazy) 	{ 		if(root->query1) 			rangeupdate(root->left , strt , mid , strt , mid , 0); 		if(root->query2) 			rangeupdate(root->left , strt , mid , strt,  mid , 1); 		if(!((mid - strt + 1) & 1)) 		{ 			if(root->query1) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 0); 			if(root->query2) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 1); 		} 		else 		{ 			if(root->query1) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 1); 			if(root->query2) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 0); 		} 		root->lazy = root->query1 = root->query2 = 0; 	}   	if(x <= mid) 		pointupdate(root->left , strt,  mid , x , y); 	else 		pointupdate(root->right , mid + 1 , end , x , y);   	root->data = root->left->data ^ root->right->data; } ull pointquery(node *root , int strt , int end , int x) { 	if(strt == end) 		return root->data;   	int mid = (strt + end)/2; 	if(root->lazy) 	{ 		if(root->query1) 			rangeupdate(root->left , strt , mid , strt , mid , 0); 		if(root->query2) 			rangeupdate(root->left , strt , mid , strt,  mid , 1); 		if(!((mid - strt + 1) & 1)) 		{ 			if(root->query1) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 0); 			if(root->query2) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 1); 		} 		else 		{ 			if(root->query1) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 1); 			if(root->query2) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 0); 		} 		root->lazy = root->query1 = root->query2 = 0; 	}   	if(x <= mid) 		return pointquery(root->left , strt , mid , x); 	else 		return pointquery(root->right , mid + 1 , end , x); } ull rangequery(node *root , int strt , int end , int x , int y) { 	if(strt >= x && end <= y) 		return root->data;   	int mid = (strt + end)/2; 	if(root->lazy) 	{ 		if(root->query1) 			rangeupdate(root->left , strt , mid , strt , mid , 0); 		if(root->query2) 			rangeupdate(root->left , strt , mid , strt,  mid , 1); 		if(!((mid - strt + 1) & 1)) 		{ 			if(root->query1) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 0); 			if(root->query2) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 1); 		} 		else 		{ 			if(root->query1) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 1); 			if(root->query2) 				rangeupdate(root->right , mid + 1 , end , mid + 1 , end , 0); 		} 		root->lazy = root->query1 = root->query2 = 0; 	}   	if(y <= mid) 		return rangequery(root->left , strt , mid , x , y); 	else if(x > mid) 		return rangequery(root->right , mid + 1 , end , x , y); 	else 		return rangequery(root->left , strt , mid , x , mid)^rangequery(root->right , mid + 1 , end , mid + 1 , y); } int main() { 	int n ,i; 	cin >> n; 	ull a[n]; 	for(i = 0;i < n;i++) 		cin >> a[i];   	node *root = NULL; 	root = build(a , 0 , n-1); 	ull x , y , q; 	cin >> q; 	char t; 	while(q--) 	{ 		cin >> t; 		if(t == 'A') 		{ 			cin >> x >> y; 			pointupdate(root , 0 , n-1 , x-1 , y); 		} 		else if(t == 'B') 		{ 			cin >> x >> y; 			rangeupdate(root , 0 , n-1 , x-1 , y-1 , 0); 		} 		else if(t == 'C') 		{ 			cin >> x; 			cout << pointquery(root , 0 , n-1 , x-1) << endl; 		} 		else 		{ 			cin >> x >> y; 			cout << rangequery(root , 0 , n-1 , x-1 , y-1) << endl; 		} 	} 	return 0; }  
#include<iostream> #include<cmath> using namespace std; #define LL long long int main() {  LL T,n,b,f,ans,x;  cin>>T;  while(T--)  {x=ans=f=0;   cin>>n>>b;   while(x<n)   {    ++x;    ans+=x;    if(ans==b)     f=1;   }   cout<<ans-f<<endl;  }  return 0; }
// //  main.c //  GENARSEQ // //  Created by Apekshit Jotwani on 02/12/13. //  Copyright (c) 2013 Apekshit Jotwani. All rights reserved. //  #include <stdio.h> // THIS IS GOPR...... int main(int argc, const char * argv[]) {      int t,h1,m1,s1,h2,m2,s2,diff;     scanf("%d",&t);     while(t--)     {         scanf("%d%d%d",&h1,&m1,&s1);         scanf("%d%d%d",&h2,&m2,&s2);         s1+=(m1*60)+(h1*3600);         s2+=(m2*60)+(h2*3600);         diff=(s2-s1)%400;         if(diff<=99||(diff>=200&&diff<=299))             printf("S\n");         else             printf("C\n");              }     return 0; } 
// codechef_codes.cpp : Defines the entry point for the console application.  #include <iostream> #include <vector> #include <algorithm> #include <string> #include <cstring> #include <cstdio> #include <cassert> #include <cmath> #include <time.h> #include <cstdlib> #include <deque>  using namespace std;  typedef long long ll; typedef unsigned long long ull; typedef vector<int> vi; typedef vector<ll> vll; typedef vector<vector<int> > vvi; typedef pair<int, int> ii; typedef vector<pair<int, int> > vii; typedef vector<vector<pair<int, int> > > vvii;  #define boost ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0) #define max(a,b) ((a)>(b)?a:b) #define min(a,b) ((a)<(b)?a:b) #define min_3(a,b,c) (min((a),min((b),(c)))) #define INF 1000000007 #define pb push_back  #define PB pop_back #define pf push_front #define PF pop_front #define MP make_pair #define all(x) (x).begin(), (x).end() #define nall(x) (x).rbegin(), (x).rend() #define tr(x,it) for(auto it = (x).begin();it!=(x).end();++it) #define ntr(x,it) for(auto it = (x).rbegin();it!=(x).rend();++it) #define mset(a,b) memset(a,b,sizeof(a)) #define ia(a,n) FOR(i,0,n-1)cin>>a[i] #define ia1(a,n) FOR(i,1,n)cin>>a[i] #define fpresent(c,x) ((c).find(x) != (c).end())  // set,map #define present(c,x) (find(all(c),x) != (c).end())  //vector #define F first #define S second #define FOR(i,a,b) for(int i=a;i<=b;++i) #define NFOR(i,a,b) for(int i=a;i>=b;--i) #define rep(i,n) FOR(i,0,n-1) #define TCASE int __T;cin>>__T;FOR(Tc,1,__T) inline int add(int a, int b, int m = INF) { a += b;if (a >= m)a -= m;return a; } inline int mul(int a, int b, int m = INF) { return (int)(((ll)a*(ll)b) % m); } inline int norm(int x, int m = INF) { if (x >= m)x %= m;if (x<0)x += m;return x; } inline int neg(int x, int m = INF) { x = -x;return norm(x); }   /// debug ////// #define pr(x,n) {rep(i,n)cout<<x[i]<<" ";cout<<endl;} #define pr1(x,n) {FOR(i,1,n)cout<<x[i]<<" ";cout<<endl;} #define DB(x)              cout<<__LINE__<<" :: "<<#x<< ": "<<x<<endl; #define DB2(x, y)          cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<endl; #define DB3(x, y, z)       cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<" | "<<#z<<": "<<z<<endl;  ll f[1000001],phi[1000001];   int main() { 	boost; 	ll tc,i,N,j; 	cin >> tc; 	while (tc--) { 		cin >> N ; 		if(N%2 == 0) 			cout << "Valar Morghulis" << endl; 		else 			cout << "Lannisters always pays their debts" << endl; 	} }
#include<cstdio> #include<iostream> #include<vector> #include<queue> using namespace std;  #define MAXN 1001 #define MAXM 400001  struct node {     int v,e; }ar[MAXM];  bool operator <(const node &a,const node &b) {     return a.e<b.e; }  vector <node > list[MAXN]; bool vis[MAXN]={false}; priority_queue <node > pq;  int main() {     int t;     scanf("%d",&t);     while(t--)     {         int n,m,a,b,c,ans=0;         scanf("%d%d",&n,&m);         for(int i=0;i<=n;i++)         {             list[i].clear();             vis[i]=false;         }         for(int i=0;i<m;i++)         {             node temp;             scanf("%d%d%d",&a,&b,&c);             temp.v=b;             temp.e=c;             list[a].push_back(temp);             temp.v=a;             list[b].push_back(temp);             ans+=c;         }         int sel=1;         for(int i=1;i<=n;i++)         {             //printf("%d\n",i);             if(vis[i]==false)             {                 sel=i;                 while(1)                 {                     vis[sel]=true;                     for(int i=0;i<list[sel].size();i++)                     {                         if(vis[list[sel][i].v]==false) pq.push(list[sel][i]);                         //printf("aman\n");                     }                     while(pq.empty()==false&&vis[(pq.top()).v]==true)pq.pop();                     if(pq.empty())break;                     sel=(pq.top()).v;                     ans-=(pq.top()).e;                     pq.pop();                 }             }         }         printf("%d\n",ans);     } } 
#include<stdio.h> #include<algorithm> using namespace std; int main() { int t,n,p; char ch[26]; scanf("%d",&t); while(t--) { int cmin=100000,pmin=0,i,j,s=0,v=0; //scanf("%s",ch); //printf("\n"); int dp[5010][60]={0}; scanf("%d",&n); scanf("%d",&p); fflush(stdin); int arr[n+1]; int arr1[n+1]; for(i=1;i<=n;i++) { scanf("%s",ch); fflush(stdin); scanf("%d",&arr[i]); scanf("%d",&arr1[i]); s+=arr1[i]; } for(i=1;i<=n;i++) { if(arr1[i]==0) v=v+arr[i]; dp[0][i]=v; } if(v>=p) { printf("0 %d\n",v); } else { for(i=1;i<=s;i++) {  dp[i][0]; for(j=1;j<=n;j++) { //if(i==0&&j==0||i!=0&&j==0) //dp[i][j]=0; //else //{ if(arr1[j]>i) dp[i][j]=dp[i][j-1]; else { int m=arr1[j]; //dp[i][j]= //if(dp[i-1][j-m]+arr[i]==j) dp[i][j]=dp[i][j-1]; dp[i][j]=max(dp[i-m][j-1]+arr[j],dp[i][j]); //else //dp[i][j]=dp[i-1][j-m]; } //} //if(j<=15) //printf("%d ",dp[i][j]); if(dp[i][j]>=p) { if(cmin>i) { cmin=i; pmin=dp[i][j]; } } } //printf("\n"); } //printf("%d %d\n",dp[2][7],dp[3][7]); printf("%d %d\n",cmin,pmin); } } return 0; } 
// by ma5termind #include<iostream> #include<vector> #include<set> #include<map> #include<queue> #include<stack> #include<string> #include<algorithm> #include<functional> #include<iomanip> #include<cstdio> #include<cmath> #include<limits.h> #include<cstring> #include<cstdlib> #include<bitset> #include<cfloat> #include<cassert> #define maxm(a,b) a>b?a:b; #define minm(a,b) a<b?a:b; using namespace std; //M lazy ;) typedef long long ll; typedef vector <int> vi; typedef pair< int ,int > pii; typedef istringstream iss; typedef ostringstream oss; typedef map<int,int> mp; #define pb push_back #define mp make_pair #define ff first #define ss second #define sz size() #define ln length() #define rep(i,n) for(int i=0;i<n;i++) #define fu(i,a,n) for(int i=a;i<=n;i++) #define fd(i,n,a) for(int i=n;i>=a;i--) #define all(a)  a.begin(),a.end() #define ESP (1e-9) #define gi(n) scanf("%d",&n) #define gl(n) cin >> n #define pi(n) printf("%d",n) #define pl(n) cout << n #define ps printf(" ") #define pn printf("\n") #define dg(n,s); printf("%s %d",s,n) #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min() #define traverse_map(a,b) for(mp::iterator it=a;it!=b;++it) #define MOD 1000000007 #define MAX 1000001 #define cases() int t; cin>>t; while(t--) // fast input function #define getcx getchar_unlocked // fast input function #ifdef ONLINE_JUDGE  inline void inp( int &n )  {     n=0;     int ch=getcx();int sign=1;     while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}      while(  ch >= '0' && ch <= '9' )             n = (n<<3)+(n<<1) + ch-'0', ch=getcx();     n=n*sign;   } #else inline void inp(int &n){  cin>>n; } #endif #define MAXN 10000001   ll phi[MAXN + 1],prime[MAXN/10];  bitset <MAXN + 1> mark; void sieve(){  int size=0;  for (int i = 2; i <= MAXN; i++ ){  	if(!mark[i]){ 	 	phi[i] = i-1; 		prime[size++]=i; 	} 	for (int j=0; j<size && prime[j]*i <= MAXN; j++ ){ 	 	mark[prime[j]*i]=1; 		if(i%prime[j]==0){ 		 	phi[i*prime[j]] = phi[i]*prime[j]; 			break; 		} 		else phi[i*prime[j]] = phi[i]*(prime[j]-1 ); 	}  } } int main(){  //int n;    sieve(); // precal O(n) algorithm to find the euler totient function    int i;   phi[0]=0;   phi[1]=3;   fu(i,2,MAXN-1){ 	 phi[i]=phi[i-1]+2*phi[i];   }   int t;   inp(t);      while(t--){    int n; 	inp(n); 	cout<<phi[n-1]<<endl;   }  return 0; } 
#include <bits/stdc++.h>  using namespace std;  int notPrime(int);  int main() {     int t,n,i,r;     long int sum;     cin>>t;     while(t--)     {         cin>>n;         sum = 0;         for(i=0;;i++)         {             if(i*(i+1) == 2*n)                 break;         }         r = i;         for(i=2;i<r;i++)         {             if(notPrime(i))             {             	sum += (pow(2,i)-2);             }             else             {             	sum += ((pow(2,i)-2)/i)*(i-1);             }         }         cout<<sum<<endl;     }     return 0; }  int notPrime(int a) {     int i,flag=0;     for(i=2;i<=sqrt(a);i++)     {         if(a%i == 0)         {             flag=1;             break;         }     }     return flag; } 
#include <iostream> #include <stdio.h> using namespace std; int gtob(int a, int b, int& c) { 	if(a==0) 		return 0; 	int g=(a%2)^gtob(a/2, b*2, c); 	c += g*b;	  	return g; }		  int main() { 	int t,n,ans; 	scanf("%d", &t); 	while(t--) 	{ 		ans=0; 		scanf("%d", &n); 		gtob(n,1,ans); 		printf("%d\n", ans); 	} 	return 0; }
#include <bits/stdc++.h> #define pb push_back #define sqr(x) (x)*(x) #define sz(a) int(a.size()) #define reset(a,b) memset(a,b,sizeof(a)) #define oo 1000000007  using namespace std;  typedef pair<int,int> pii; typedef unsigned long long ll;  long double mypow(long double base, int n){     if(n==0) return 1;     double t=mypow(base, n/2);     t=t*t;     if(n&1) return t*base;     return t; }  long double sum(long double a, long double d, long double r, int n){     return (a - (a + (n-1)*d) * mypow(r, n)) / (1 - r) + d * r * (1 - mypow(r, n-1)) / (1-r) / (1-r); }  int main(){ //    freopen("input.txt","r",stdin);      ll m,n,k;     cin>>m>>n>>k;     if(k!=1){         long double res=0;         for(int i=1; i<=m; ++i){             long double x = 1.0 * k * (m-i+1);             long double p = mypow(1.0/k,i);             long double s = sum(n, -1, p, n) * p;             res += x * s;         }         cout << fixed << setprecision(0) << round(res) + 1e-9 << endl;     }else{         long double res = (n*1.0*(n + 1)/2.0)*(m*1.0*(m + 1)/2.0);         cout << fixed << setprecision(0) << res << endl;     } }
#include<iostream> #include<stdio.h> #include<string.h> #include<cmath> #define intin(a)    scanf("%d",&a) #define scans(a)    scanf("%s",a) #define LL long long using namespace std; int main() {     int cases,r,c;     intin(cases);     while(cases--)     {   intin(r);intin(c);         if(!r || !c)  {cout<<"0\n";continue;}         if(r&1) r=r-(r/2+1);         else    r=r-r/2;          if(c&1) c=c-(c/2+1);         else    c=c-c/2;         cout<<1+r+c<<"\n";     } } 
#include<bits/stdc++.h> #define gc getchar_unlocked   void scanint(int &x) {     register int c = gc();     x = 0;     for(;(c<48 || c>57);c = gc());     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;} } using namespace std; int main() {     int t;     //scanf("%d",&t);     scanint(t);     while(t--)     {         int m,n,i,j,k;         long long int res=0;         //scanf("%d%d",&m,&n);         scanint(m);         scanint(n);         if(m==1&&n==1)         {             printf("0\n");             continue;         }         if(m==1)         {             res=2+(n-2)*2;             printf("%lld\n",res);             continue;         }         if(n==1)         {             res=2+(m-2)*2;             printf("%lld\n",res);             continue;         }         res=12+5*(2*m+2*n-8)+8*(m*n-2*m-2*n+4);         printf("%lld\n",res);     }     return 0; }
#include<stdio.h> typedef long long ll;  int main(){ 	ll t,i,j,k,fact[21]; 	fact[0]=1; 	for(i=1;i<21;i++) fact[i]=i*fact[i-1]; 	scanf("%lld",&t); 	while(t--){ 		scanf("%lld",&k); 		ll res=0; 		for(i=2 ; i <= k; i++){ 			res+=(i%2==0) ? fact[k]/fact[i]:-fact[k]/fact[i] ; 		} 		printf("%lld\n",res); 	} 	return 0; } 
#include <iostream> using namespace std; #include<stdlib.h> #include<stdio.h> #include<string.h>  int main() { 	int t; 	cin>>t; 	long long int p,i; 	 	 	 	for(p=0;p<t;p++) 	{    	   char name[10]; 	   scanf("%s",name); 	   char str[1000]; 	   scanf("%s",str); 	    	   int flag=0; 	   int a[26]; 	   for(i=0;i<26;i++) 	    a[i]=0; 	     	   for(i=0;i<strlen(str);i++) 	   {   int k = str[i]-97; 	       a[k]++; 	   } 	   int count=0; 	   for(i=0;i<26;i++) 	   { 	   	count = count^a[i];	 	   }	    		  		if(count==0) 		{ 			if(name[0]=='T') 				cout<<"Varun"<<endl; 			else 				cout<<"Tarun"<<endl; 		} 		else{ 			if(name[0]=='T') 				cout<<"Tarun"<<endl; 			else 				cout<<"Varun"<<endl;  		}  	}     	 	 	 	return 0; } 
#pragma comment(linker, "/STACK:102400000,102400000") #include <iostream> #include <stdio.h> #include <algorithm> #include <string.h> #include <vector> #include <map> #include <queue> #include <set> #include <cmath> #include <fstream> #include <assert.h> #include <complex> using namespace std; #define vi vector<int> #define pii pair<int,int> #define pb push_back #define mp make_pair #define all(x) x.begin(),x.end() #define inf 1000000007 #define mod 1000000007 #define x first #define y second #define pi acos(-1.0) #define DBG(x) cerr<<(#x)<<"="<<x<<"\n"; #define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++) #define ull unsigned long long #define ll long long #define N 10010  char s[105][105]; int dir[][2]={-2,-1,-2,1,-1,-2,-1,2,1,-2,1,2,2,-1,2,1}; int n,m,id[105][105],sz,n1,m1; bool in(int x,int y){return x>=0&&x<n1&&y>=0&&y<m1;} int l1,l2,r1,r2; void dfs(int x,int y){     if(!in(x,y)||s[x][y]=='#'||id[x][y])return;     id[x][y]=sz;     l1=min(l1,x);l2=max(l2,x);     r1=min(r1,y);r2=max(r2,y);     dfs(x-1,y);     dfs(x+1,y);     dfs(x,y-1);     dfs(x,y+1); } int ans; int v[105],res[105],lim,goal[105],found,cnt; void go(int x,int sum){     if(found||ans==lim)return;     if(sum+min(n-x,m-sum)<=ans)return;     if(x==n){         if(ans<sum){             ans=sum;found=true;             cnt++;             //if(cnt>10)found=true;             for(int i=0;i<n;i++)goal[i]=res[i];         }         return;     }     if(res[x-1]!=-1)     for(int y=res[x-1]+3,k=0;k<m;y++,k++){         if(y>=m)y-=m;     if(!v[y]){         int ok=1;         for(int i=0;i<x;i++)if(res[i]!=-1){             if(x-i==y-res[i]){ok=0;break;}             if(i+res[i]==x+y){ok=0;break;}             if(i==x-2&&abs(y-res[i])==1){ok=0;break;}             if(i==x-1&&abs(y-res[i])==2){ok=0;break;}         }         if(ok){             v[y]=1;             res[x]=y;             go(x+1,sum+1);             v[y]=0;res[x]=-1;             //break;         }     }     }     else{         if(ans<sum)ans=sum;     } } void go1(int x,int sum){     if(ans==lim)return;     if(sum+min(n-x,m-sum)<=ans)return;     if(x==n){         if(ans<sum){             ans=sum;             for(int i=0;i<n;i++)goal[i]=res[i];         }         return;     }     for(int y=0;y<m;y++)     if(!v[y]){         int ok=1;         for(int i=0;i<x;i++)if(res[i]!=-1){             if(x-i==y-res[i]){ok=0;break;}             if(i+res[i]==x+y){ok=0;break;}             if(i==x-2&&abs(y-res[i])==1){ok=0;break;}             if(i==x-1&&abs(y-res[i])==2){ok=0;break;}         }         if(ok){             v[y]=1;             res[x]=y;             go1(x+1,sum+1);             v[y]=0;res[x]=-1;         }     }     go1(x+1,sum); } void func(){     ans=0;n=l2-l1+1,m=r2-r1+1;     for(int i=0;i<m;i++)v[i]=0;     for(int i=0;i<n;i++)res[i]=-1;     lim=min(n,m);found=false;cnt=0;     bool flag=false;     if(n>m)swap(n,m),flag=true;     if(lim<10){         go1(0,0);     }     else go(0,0);     //DBG(ans)     //cout<<n<<" "<<m<<":\n";     for(int i=0;i<n;i++)             if(goal[i]!=-1){                 if(!flag)s[l1+i][r1+goal[i]]='G';                 else s[l1+goal[i]][r1+n-1-i]='G';             }     //printf("-------------------\n"); } int main() {     //freopen("2.txt","w",stdout);     int T,i,j,k,ca=0;     scanf("%d",&T);     while(T--){         scanf("%d%d",&n,&m);         for(i=0;i<n;i++){             scanf("%s",s[i]);         }         n1=n,m1=m;         memset(id,0,sizeof(id));         sz=0;int sum=0;         for(i=0;i<n1;i++)             for(j=0;j<m1;j++)if(!id[i][j]&&s[i][j]=='.'){                 sz++;                 l1=l2=i;r1=r2=j;                 dfs(i,j);                 func();sum+=ans;             }         printf("%d\n",sum);         for(i=0;i<n1;i++)puts(s[i]);     }     return 0; }
#include<iostream> using namespace std; long long int fun(long long int a,long long int b){ 	if(a==0){ 		return b; 	} 	else{ 		return fun(b%a,a); 	} } int main() { 	int test; 	long long int g,n,m,odd1,even1,odd2,even2,num,den; 	scanf("%d",&test); 	while(test){ 		test--; 		scanf("%lld%lld",&n,&m); 		if(n%2==1){ 			odd1=(n/2)+1; 			even1=n/2; 		} 		else{ 				even1=n/2; 				odd1=(n/2); 		} 		if(m%2==1){ 			odd2=(m/2)+1; 			even2=m/2; 		} 		else{ 				even2=m/2; 				odd2=(m/2); 		} 		num=(even1*odd2)+(odd1*even2); 		den=(m*n); 		g=fun(num,den); 		printf("%lld/%lld\n",num/g,den/g); 	} 	return 0; }
#include<cstdio> #include<cstdlib>  using namespace std; #define mod 1000000007 long long power(int x, unsigned int y) {   long long temp;   if( y == 0)     return 1;   temp = power(x, y/2);   if (y%2 == 0)     return ((temp*temp)%mod);   else     return ((((x*temp)%mod)*temp) %mod); }   int main() {   int t,d;   scanf("%d",&t);   while(t--) {     scanf("%d",&d);     printf("%lld\n",power(7,d));   }   return 0; } 
#include<iostream> #include<cmath> #include<vector> #include<algorithm> #include<stdio.h> #include<list> #include<set> #include<string> #include<cstring> #define x getchar_unlocked() #define y putchar_unlocked using namespace std; inline void inp(int &n ) {//fast input function 	n=0; 	int ch=x,sign=1; 	while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=x;} 	while( ch >= '0' && ch <= '9' )  		n=(n<<3)+(n<<1)+ ch-'0', ch=x; 	n=n*sign; 	}  int R[100000],n,t,ans;  int main() { 	inp(t); 	while(t--) { 		set<int> s; 		set<int>::iterator it; 		inp(n); 		for(int i=0;i<n;i++) { 			inp(R[i]); 			R[i]=-R[i]; 			} 		for(int i=0;i<n;i++) { 			if(s.find(R[i])!=s.end()) 				continue; 			s.insert(R[i]); 			it=s.find(R[i]); 			it++; 			if(it!=s.end()) 				s.erase(it); 			} 		ans=s.size(); 		cout<<ans<<endl; 		} 	return 0; 	} 
#include<bits/stdc++.h> using namespace std; int main() { 	int t;scanf("%d",&t); 	int i,j; 	while(t--) 	{ 		char s[100]; 		cin>>s; 		int l = strlen(s); 		int cnt=0; 		for(i=0;i<l-1;i++) 		{ 			if(s[i]=='h') 			{ 				for(j=i+1;j<l;j++) 				{ 					if(s[j]=='m') 						cnt++; 					else 						break; 				} 			} 		} 		cout<<cnt<<endl; 	} 	return 0; } 
#include<stdio.h>    #include<math.h>    #include<string.h>    int main()    {    	int t;    	scanf("%d",&t);    	while(t--)    	{    		unsigned long long int i,n,c=0,s;    		char a[55]={'\0'};    		scanf("%s",a);    		n=strlen(a);  		if(n==1)  		printf("2\n");  		else  		{  		if(a[0]!=a[1])    		c++;    		for(i=1;i<n-1;i++)    		{    			if((a[i]!=a[i+1])&&(a[i]!=a[i-1]))    			c++;    		}    		if(a[n-1]!=a[n-2])    		c++;    		s=pow(2,c);    		printf("%llu\n",s);    	}  }    	return 0;    }
//hamiltonian cycle #include<bits/stdc++.h> #define ll long long #define maxe 2147483647 #define INF 1e16 #define si(x) scanf("%d",&x) #define sl(x) scanf("%ld",&x) #define sll(x) scanf("%lld",&x) #define ss(x) scanf("%s",x) #define pi(x) printf("%d\n",x) #define pl(x) printf("%ld\n",x) #define pll(x) printf("%lld\n",x) #define ps(x) printf("%s\n",x) #define iter(i,a,b) for(int i=a; i<b; i++) #define ited(i,a,b) for(int i=a;i>b;i--) #define mp make_pair  #define pb push_back  #define max(a,b) a>b?a:b #define min(a,b) a<b?a:b //#define pop pop_back  #define mod 1000000007 using namespace std; bool prime[1000001]; vector<int> vec; void seivec() { 	prime[0]=prime[1]=true; 	for(int i=2;i*i<1000001;i++) 		if(prime[i]==false) 			for(int j=2*i;j<1000001;j+=i) 				prime[j]=true; 	for(int i=2;i<1000001;i++) 		if(prime[i]==false) 			vec.pb(i);	 } ll mulmd(ll a,ll b,ll n) { 	ll an=0; 	while(b!=0) 	{ 		if(b%2==1) 			an=(an+a)%n; 		a=(a+a)%n; 		b/=2; 	} 	return an; } ll powe(ll a,ll b,ll n) { 	ll an=1; 	while(b!=0) 	{ 		if(b%2==1) 			an=mulmd(an,a,n); 		a=mulmd(a,a,n); 		b/=2; 	} 	return an; } bool miller(ll n,ll d) { 	ll a=2+rand()%(n-4); 	ll x=powe(a,d,n); 	if(x==1 || x==n-1) return true; 	while(d!=n-1) 	{ 		x=mulmd(x,x,n); 		d*=2; 		if(x==1) return false; 		if(x==n-1) return true; 	} 	return false; } bool checkp(ll n) { 	if(n<=1 && n==4) return false; 	if(n<=3)	return true; 	ll d=n-1; 	while(d%2==0) 		d/=2; 	int k=3; 	for(int i=0;i<k;i++) 		if(miller(n,d)==false) return false; 	return true; } ll calc(ll v) { 	ll an=0; 	for(int i=0;i<vec.size();i++) 	{ 		while(v%vec[i]==0) 		{ 			v/=vec[i]; 			an++; 		} 	} 	if(v==1) return an; 	if(checkp(v)) return an+1; 	else return an+2; } int main() { 	seivec(); 	int t; 	si(t); 	while(t--) 	{ 		ll n,k; 		sll(n);sll(k); 		ll tmp1=calc(k); 		ll tmp2=calc(n); 		ll t1=powe(2,tmp1,mod); 		ll an=powe(t1+1,tmp2,mod); 		pll(an); 	} 	return 0; }
/** * It is foolish to fear what we've yet to see and know */ #include <iostream> #include <iomanip> #include <algorithm> #include <vector> #include <map> #include <set> #include <stack> #include <queue> #include <climits> #include <cstdio> #include <cstring> #include <cctype> #include <cassert> #include <cmath> using namespace std;  #define trace(x) {cerr << #x << "=" << x <<endl;} #define trace2(x, y) {cerr << #x << "=" << x << " " << #y << "=" << y <<endl;} #define track(x) {cerr << #x << ":" << endl; for (int q = 0; q < x.size(); q++) {cerr << x[q] << " ";} cerr << endl;} #define trackarr(x, n) {cerr << #x << ":" << endl; for (int q = 0; q < n; q++) {cerr << x[q] << " ";} cerr << endl;} #define trackvv(x) {cerr << #x << ":" << endl; for (int i = 0; i < x.size(); i++) { cerr << "i:" << i << endl; for (int j = 0; j < x[i].size(); j++){cerr << x[i][j] << " ";} cerr << endl;} cerr << endl;} #define trackcr(x) {cerr << #x << ":" << endl; for (map<ll, int>::iterator i = x.begin(); i != x.end(); i++) {cerr << *i << " ";} cerr << endl;} template <typename Tk, typename Tv> ostream& operator<<(ostream& os, const pair<Tk, Tv> &p){os << "{" << p.first << ',' << p.second << "}";return os;}  typedef long long ll; typedef pair<int,int> ii;  const int MAX = 100005; const int MOD = 1000000000+7; const int INF = 1000000000;  int runScored[5] = {0, 1, 2, 4, 6};   bool exist[205][105][150][2][2]; int dp[205][105][150][2][2];  long long solve(int b, int n, int k, bool sl, bool l) {     if (k >= 100) {         return 1;     } else if (b == 0) {         return 0;     } else {         if (!exist[b][n][k][sl][l]) {             long long ways = 0;              if (n > 0) {                 for (int i = 0; i < 5; i++) {                     ways += solve(b, n-1, k+runScored[i], sl, l);                     if (ways >= MOD) ways -= MOD;                 }             }              int start = 0;             if (!sl && !l) start = 1;             for (int i = start; i < 5; i++) {                 ways += solve(b-1, n, k+runScored[i], l, (runScored[i]>0));                 if (ways >= MOD) ways -= MOD;             }              dp[b][n][k][sl][l] = ways;             exist[b][n][k][sl][l] = true;         }          return dp[b][n][k][sl][l];     } }  int main() {     int t;     scanf("%d", &t);     while (t--) {         int b, n;         scanf("%d%d", &b, &n);         long long answer = solve(b, n, 0, true, true);         printf("%lld\n", answer);     } }           
#include <bits/stdc++.h>  using namespace std;  #define pb push_back #define mp make_pair #define ll long long #define s(x) scanf("%d", &x) #define sl(x) scanf("%lld", &x) #define sd(x) scanf("%lf", &x) #define mod 1000000007 #define get getchar_unlocked  vector < pair < pair <int, int>, int> > v; int dp[25][200005]; char a[200005]; char b[200005]; int ansA[200005]; int ansB[200005]; int ansAUB[200005];  void suffix(char a[], string &P, int n, int ans[]) {     int i, j, k, x, y;     for (i = 0; i < n; ++i) {         dp[0][i] = a[i] - 97;         P.pb(a[i]);     }     bool con = true;     for (j = 0; con; ++j) {         v.clear();         for (i = 0; i < n; ++i) {             if (i+(1<<j) < n)                 v.pb(mp(mp(dp[j][i], dp[j][i+(1<<j)]), i));             else                 v.pb(mp(mp(dp[j][i], -1), i));         }         sort(v.begin(), v.end());         con = false;         dp[j+1][v[0].second] = 0;         for (i = 1; i < n; ++i) {             if (v[i].first == v[i-1].first) {                 dp[j+1][v[i].second] = dp[j+1][v[i-1].second];                 con = true;             }             else                 dp[j+1][v[i].second] = i;         }     }     int tmp;     ++ans[1];     --ans[n-v[0].second+1];     for (i = 1; i < v.size(); ++i) {         x = v[i].second;         y = v[i-1].second;         tmp = 0;         for (k = j; k >= 0 && x < n && y < n; --k) {             if (dp[k][x] == dp[k][y]) {                 x += (1<<k);                 y += (1<<k);                 tmp += (1<<k);             }         }         ++ans[tmp+1];         --ans[n-v[i].second+1];     } }  int main() {     string P, Q;     scanf("%s", a);     scanf("%s", b);     int lenA = strlen(a);     int lenB = strlen(b);     suffix(a, P, lenA, ansA);     P.pb('=');     suffix(b, P, lenB, ansB);     for (int i = 0; i < P.size(); ++i)         a[i] = P[i];     suffix(a, Q, lenA+lenB+1, ansAUB);     int i;     for (i = 1; i <= lenA; ++i)         ansA[i] += ansA[i-1];     for (i = 1; i <= lenB; ++i)         ansB[i] += ansB[i-1];     int j = lenA + lenB + 1;     for (i = 1; i <= j; ++i)         ansAUB[i] += ansAUB[i-1];     for (i = 1; i <= min(lenA, lenB)+1; ++i)         ansAUB[i] -= i;     int q, x, y;     s(q);     while (q--) {         s(x);         s(y);         if (x == 1)             printf("%d\n", ansA[y] + ansB[y] - ansAUB[y]);         else if (x == 2)             printf("%d\n", ansAUB[y]-ansB[y]);         else if (x == 3)             printf("%d\n", ansAUB[y]-ansA[y]);         else if (x == 4)             printf("%d\n", 2*ansAUB[y]-ansA[y]-ansB[y]);         else             assert(0);     }     return 0; } 
#include <iostream> #include <cmath> using namespace std; bool isprime(int a) { 	if(a==1) return false; 	if(a%2==0) return false; 	for(int i=3;i<=sqrt(a);i++) 	if(a%i==0) return false; 	return true; } int main () { int t; scanf("%d",&t); while(t--) { 	int n; 	scanf("%d",&n); 	int sum=0; 	for(int i=29;i<=n;i++) 	if(isprime(i)) sum+=i; 	 	cout<<sum<<endl; }   return 0; } 
#include <bits/stdc++.h> using namespace std; #define gc getchar #define pc putchar #define mod 1000000007 #define pb push_back #define line() printf("\n") #define space() printf(" ") typedef long long int lli; void sc(int& a){scanf("%d",&a);} void sc(lli& a){scanf("%lld",&a);} void sc(int& a, int& b){sc(a);sc(b);} void sc(int& a,int& b,int& c){sc(a);sc(b);sc(c);} void sc(lli& a,lli& b){sc(a);sc(b);} void sc(lli& a,lli& b,lli& c){sc(a,b);sc(c);} void write(int a){printf("%d",a);} void write(lli a){printf("%lld",a);} //int modpow(int a, int b, int mod){lli res=1;while(b>0){if(b&1)res=(res*a)%mod;a=(a*a)%mod;b=b/2;}return res%mod;}   int main() {     int t,n,i,x;     map<int,lli> mp;     cin>>t;     while(t--)     {         sc(n);         mp.clear();         for(i=0;i<n;i++)         {             sc(x);             mp[x+1]++;         }         int n1=mp.size();         lli ans=0;         for(map<int,lli> :: iterator it=mp.begin();it!=mp.end();it++)         {             int a=it->first;             lli b=it->second;             if(b%(lli)a==0) ans+=b;             else ans+=((b/(lli)a)+1)*a;         }         write(ans);line();     } }
#include<bits/stdc++.h> using namespace std; int  main() {     int t;     cin>>t;     string s;     while(t--) {         cin>>s;         int cnt = 0;         for(int i=0;i<s.size();i++) {             if(s[i]=='A'|| s[i]=='D' || s[i]=='O' || s[i]=='P' || s[i]=='Q' || s[i]=='R') {                 cnt++;             }             if(s[i]=='B') {                 cnt=cnt+2;             }         }         cout<<cnt<<endl;     }     return 0; } 
#include<stdio.h> #include<iostream> #include<string.h>  using namespace std;  int main(){     int t,cnt=0,temp,i=0;     string s;     cin>>t;     for(;t>0;t--){         cin>>s;         temp=s.length();         for(i=0;i<temp;i++){             if(s[i]=='A' || s[i]=='D' || s[i]=='O' || s[i]=='P' || s[i]=='Q' || s[i]=='R'){                 cnt+=1;             }             else if(s[i]=='B')                 cnt+=2;         }         cout<<cnt<<"\n";         cnt=0;     }     return 0; } 
 #include "bits/stdc++.h" using namespace std;  #define input()                   freopen("C:\\Users\\safayet007\\Desktop\\in.txt", "r", stdin) #define output()                  freopen("C:\\Users\\safayet007\\Desktop\\out.txt", "w", stdout); #define FOR(i, a, b)              for(__typeof(b) i = a; i <= b; i++) #define REP(i, a)                 for(__typeof(a) i = 0; i < a; i++) #define REPN(i, a)                for(__typeof(a) i = 1; i <= a; i++) #define ITERATE(it, v)            for(__typeof((v).begin()) it = (v).begin(); it != (v).end(); it++) #define D(x)                      cout << #x << " = " << (x) << endl #define all(v)                    (v).begin(), (v).end() #define SET(a, val)               memset(a, val, sizeof a) #define pb                        push_back #define mp                        make_pair #define endl                      '\n'  typedef long long vlong; typedef pair <int, int> pii;  int main () {     ios_base::sync_with_stdio(false); cin.tie(false);     int T; cin >> T;     int L[1005];     while(T --) {         int n; cin >> n;         SET(L, 0);         int up = 0;         REPN(i, n) {             int k; cin >> k; L[k] ++;             up = max(up, k);         }         REPN(i, n) {             int k; cin >> k; L[k] --;             up = max(up, k);         }         int ans = 0, cs = 0;         REPN(i, up) {             cs += L[i]; ans = max(ans, cs);         }         cout << ans << endl;     }     return 0; } 
#include<iostream> #include<stdio.h> #include<stdlib.h> #include<string> #include<string.h> #include<vector> #include<map> #include<algorithm> #include<limits.h> #include<set> #include<stack> #include<list> #include<queue> #include<math.h>   using namespace std; #define lli long long int #define ulli unsigned long long int #define in(t) scanf("%d",&t) #define inlf(t) scanf("%lf",&t) #define inl(t) scanf("%ld",&t) #define inll(t) scanf("%lld",&t) #define inlu(t) scanf("%llu",&t) #define MOD 1000000007  int main() {     int t,n,i,ans,b,c,d,e,f,g,h,l;     in(t);     while(t--)     {     ans=c=d=e=f=g=h=l=0;     in(n);     if(n<=6)     ans=2;     else if(n<=75)     ans=3;     else if(n<=480)     ans=4;     else if(n<=2205)     ans=5;     else if(n<=8232)     ans=6;     else if(n<=26544)     ans=7;     else     ans=8;     cout<<ans<<"\n";     }     return 0; } 
#include<stdio.h> void scanint(int &x){     char c = getchar_unlocked();     x = 0;     while(c<'0'||c>'9'){         c=getchar_unlocked();     }     while(c>='0'&&c<='9'){         x= (x<<1)+ (x<<3) + c - '0';         c=getchar_unlocked();     } } int main(){     int t;     scanint(t);     while(t--){         int n,k;         scanint(n);         scanint(k);         unsigned long long ans=n;         ans*=n-1;         ans=ans>>1;         if(k!=0){         ans -= (n-k);         }         printf("%llu\n",ans);     } } 
#include<iostream>  #include<algorithm>  #include<cstdio>  using namespace std;  int main()  {  int z,t,ai,i,n,c,a[100];  cin>>t;  while(t--)  {  cin>>n;  for(i=0;i<n;i++)  cin>>a[i];  sort(a,a+n);  c=6;  ai=0;  z=0;  while(ai<n)  {  if(a[ai]==0)  {  z=1;  break;  }  ai++;  c--;  for(i=ai;i<n;i++)  {  a[i]--;  }  if(c==0)  {  c=6;  for(i=ai;i<n;i++)  {  a[i]--;  }  }  }  if(z)  cout<<"NO";  else  cout<<"YES";  cout<<"\n";  }  } 
#include <iostream> #include <vector> #include <algorithm> using namespace std;   template<typename T1, typename T2> struct node {        T1 first;        T2 second;   };   int main() {     int t;     cin >> t;     while(t--) {       long int n, q, i, j;       cin >> n >> q;              vector< pair<long long int, long long int> > v;              for( i = 0; i < n; i++ ) {            long long int x, y;            cin >> x >> y;                        pair< long long int , long long int > p;            p.first = x;            p.second = y-x;                        v.push_back(p);                   }              sort( v.begin(), v.end() );              for( i = 0; i < q; i++ ) {            long long int x;                        cin >> x;                        int flag = 1;                        for( j = 0; j < n; j++ ) {                                  if( x < v[j].first )                    break;                                  if( x >= v[j].first && x <= v[j].first+v[j].second )                  { flag = 0; break; }            }                        if( flag == 1 )                cout << "YES\n";            else                cout << "NO\n";       }     } }                                
#include<iostream> #include<list> #include<map> using namespace std; int main() { 	int n;int m; 	int i,c,t,k; 	cin>>n>>m; 	list<int>arr[m+1]; 	 	map<string,int> Map; 	string s1,s2; 	int j=1; 	for(i=0;i<m;i++) 	{ 		cin>>s1>>s2; 		if(!Map[s1]) 		{ 			Map[s1]=j; 			j++; 		} 		k=Map[s1]; 		if(!Map[s2]) 		{ 			Map[s2]=j; 			j++; 		} 		c=Map[s2]; 		 		arr[k].push_back(c); 		arr[c].push_back(k); 	} 	cin>>t; 	for(i=0;i<t;i++) 	{ 		int count=0; 		cin>>s1; 		int x=Map[s1]; 		map<int,int> MM; 		list<int> ::iterator ii; 		list<int> ::iterator jj; 		for(ii=arr[x].begin();ii!=arr[x].end();ii++) 			MM[*ii]=1;  	 		MM[x]=1; 		ii=arr[x].begin(); 		for(ii;ii!=arr[x].end();ii++) 		 		{ 			for(jj=arr[*ii].begin();jj!=arr[*ii].end();jj++) 			{		 				if(!MM[*jj]) 				{ 					count++;	 					MM[*jj]=1; 				} 			} 		} 		cout<<count<<endl; 	} return 0; } 
#include <iostream> #include <stdio.h> #include <vector> #include <algorithm> using namespace std;   #define M 50000 #define s(a) scanf("%d",&(a))   bool compare_as_given(long long int a,long long int b) {     return(a>b); }   int main() {     int n,m;     s(n);     s(m);     long long int a[M];     for(int i=0;i<n;i++)         s(a[i]);     vector <long long int> xr(n*(n-1));     int k=0;     for(int i=0;i<n-1;i++)         for(int j=i+1;j<n;j++)            {                xr[k++]=a[i]^a[j];                //cout<<xr[i]<<" ";            }            //cout<<endl;     stable_sort(xr.begin(),xr.end(),compare_as_given);     long long int ans=0;     for(int i=0;i<m && i<k;i++)         ans+=xr[i];     printf("%lld\n",ans);     return 0; }
#include<cstdio> using namespace std;  typedef long long LL;  int main(){     int q;scanf("%d",&q);     while(q--){       LL no_of_numbers=9LL;       LL num;scanf("%lld",&num);       if(num==0){            printf("0\n");continue;       }       LL tmp,rem,digits;       for(digits=1;(tmp=num-digits*no_of_numbers)>0;digits++,num=tmp)            no_of_numbers=(no_of_numbers<<3)+(no_of_numbers<<1);       LL val=(rem=num%digits)>0? num/digits+1:num/digits;       val+=no_of_numbers/9LL-1;       if(rem){          for(int i=0;i<digits-rem;i++)            val/=10LL;       }       printf("%lld\n",val%10);     } } 
#include <iostream> #include <cmath> #define aa long long using namespace std; aa int square(aa int n) {     aa int num,rev=0;     while(n!=0)     {         num = n%10;         rev = rev + (num*num);         n = n/10;     }     return rev; } int main() {     aa int tc;     cin>>tc;     while(tc--)     {         aa int n,temp;         cin>>n;         aa int a[n];         for(int i=0;i<n;i++)         {             cin>>a[i];         }         for(int i=0;i<n;i++)         {             temp  = square(a[i]);             while(temp >= 10)             {                 temp = square(temp);             }             if(temp == 1) cout<<"YES"<<endl;             else cout<<"NO"<<endl;         }      } } 
#include <cstdio> using namespace std;  int main() {  		int t,i,n,a,j,ans;bool displaced; 		scanf("%i%i",&t,&n); 		while(t--) 		{ 	        scanf("%i",&j); 	        j++; 	        for(i=1,ans=0;i<n;i++,j++)                 { scanf("%i",&a);                   displaced=(a-j)%n;                   ans+=displaced;                 } 	        printf("%i\n",ans); 		}     return 0; } 
#include <bits/stdc++.h> using namespace std;  const long double pi = 3.14159265358979323846264338328;  int main(){     int t;     cin >> t;     while(t--){         long double r1,h1,r2,h2;         cin >> r1 >> h1 >> r2 >> h2;         long double ar1 = (pi*r1*r1*h1/3) + (2*pi*r1*r1*r1/3);         long double ar2 = pi*r2*r2*h2;         cout << setprecision(20) <<ar1 << " " << ar2 << endl;     } } 
 #include <iostream> #include <algorithm> #include <vector> #include <cstdio> #include <string> #include <bitset> #include <cmath> #include <list> #include <cstdlib> #include <map> #include <cstring> #include <set> #include <stack> #include <sstream> #include <queue> #include <ctime>  using namespace std;  #define debug(x) cout<<#x<<" = "<<x<<"\n" #define FOR(i,a,b)  for(int (i) = (a);(i)<(b);(i)++) #define   REP(i,n) FOR(i,0,n) #define  INF (1<<29) #define         pb push_back #define 	     sz size() #define         mp make_pair #define all(a) a.begin(),a.end() #define SI(n)               scanf("%d",&n); #define SL(n)               scanf("%lld",&n); #define fill(ar,val) memset(ar,val,sizeof ar) #define FORE(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++) #define fi first #define se second typedef long long ll; typedef pair<int,int>  pii; typedef vector<string> vs; ll s2i(string s) { istringstream iss(s); ll x;iss>>x; return x;} string i2s(ll x) { ostringstream oss; oss<<x; return oss.str();} /* Main code begins now */    long long mod;  long long powz( long long a, long long b) {  	if( b == 0) 		return 1;	  	if ( b & 1) 		return a* (powz(a,b-1))%mod; 	else { 	       long long k = powz(a,b/2);        		return k*k%mod;  	} }	       long long an[102][102]; long long colsum[102][102]; long long v[102]; long long a[101]; long long ans ; long long sum; long long area  ; void calculate_max_array( long long a[] , long long n, long long r) {  //	for ( int i = 0; i < n; i++) //		cout << a[i]<<" "; //	cout << endl; 	int dp[n]; 	dp[0] = a[0]; 	v[0] = 0; 	if ( dp[0] == ans) 		area = max(area,1*r); 	else if( dp[0] > ans) { 		area = 1*r; 		ans = dp[0]; 	} 	long long maxi = a[0]; 	long long colwidth = 1;  	for ( int i = 1; i < n; i++) { 		int k = dp[i-1] + a[i]; 		if ( k >= a[i]) { 			v[i] = v[i-1]; 			dp[i] = k; 		}	 		else { 			v[i] = i; 			dp[i] = a[i]; 		} 		if ( ans  == dp[i]  ) {  			colwidth = max(colwidth,i - v[i]+1); 			area = colwidth*r; 			ans = dp[i]; 		} 		else if ( ans < dp[i]) { 			colwidth = i - v[i] + 1; 			area = colwidth*r; 			ans = dp[i]; 		}	 	}	 }	 	 int main() { //	freopen("","r",stdin); //	freopne("","w",stdout);  	int t; 	scanf("%d",&t);  	while ( t-- ) { 		int n,m; 		string s; 		ans = -1000000; 		scanf("%d%d",&n,&m); 		vector < string > v; 		for ( int i = 0; i < n; i++){ 			cin >> s; 			v.pb(s); 		} 		cin >> mod; 		int F = 0; 		int I = 0; 		area = 1; 		for ( int i = 0; i < n; i++) { 			for ( int j = 0; j < m; j++) { 				colsum[i][j] = 0; 				if( v[i][j] == 'I') {   					an[i][j] = (int )powz((++I),i+j);	 				} 				else { 					an[i][j] = - (int)powz((++F),i+j); 					 				} //				cout << an[i][j]<<" "; 			} //			cout << endl; 			 		} //		cout<<"S"<< endl; 		for ( int i = 0; i < m; i++) { 			colsum[0][i] =an[0][i]; //			cout << colsum[0][i]<<" "; 		 	for ( int j = 1; j < n; j++) { 			  				colsum[j][i] += colsum[j-1][i] + an[j][i]; //				cout<< colsum[j][i] << " ";  			} //			cout << endl; 		} 	//	 cout <<"as" <<endl; 		for ( int i = 0; i < n; i++) { 			for ( int j = i; j < n; j++) { 				for ( int k = 0; k < m; k++) { 					 				       	if ( i != 0 ) 						a[k] = colsum[j][k] - colsum[i-1][k]; 					else 						a[k] = colsum[j][k];	 						 				} 				 calculate_max_array(a,m,j-i+1); 			       		       		 			} 		}	 		cout << area << endl;  	}	 			 	 	return 0; }               
#include <iostream> #include <cstdio> #include <cstring> #include <cstdlib> #include <cctype> #include <algorithm> #include <map> #include <vector> #include <list> #include <set> #include <queue> #include <deque> #include <stack> #include <string> #include <cmath> using namespace std; #define FOR(i,a,b) for(i=a;i<b;i++) #define REP(i,n) FOR(i,0,n) struct pb { 	int x,y; }posb[251],tmpb; vector<pb>useb; vector<int> a[251]; vector<int> b[251]; int n,s; struct pa { 	int x,y; }posa[251],tmpa; vector<pa>usea; int sa,sb; int pres(int a1,int b1) { 	int i,j; 	for(i=1;i<=sa;i++) 	{ 		if(posa[i].x==a1&&posa[i].y==b1) 			return 1; 	} 	for(j=1;j<=sb;j++) 	{ 		if(posb[j].x==a1&&posb[j].y==b1) 			return 1; 	}		 	return 0; } int frea(int a1,int b1) { 	int i; 	if(a1<1||b1<1||a1>n||b1>n) 		return 0; 	for(i=0;i<usea.size();i++) 		if(usea[i].x==a1&&usea[i].y==b1) 			return 0; 	if(!pres(a1,b1)) 	{ 		tmpa.x=a1; 		tmpa.y=b1; 		usea.push_back(tmpa); 	} } int freb(int a1,int b1) { 	if(a1<1||b1<1||a1>n||b1>n) 		return 0; 	int i; 	for(i=0;i<useb.size();i++) 		if(useb[i].x==a1&&useb[i].y==b1) 			return 0; 	if(!pres(a1,b1)) 	{ 		tmpb.x=a1; 		tmpb.y=b1; 		useb.push_back(tmpb); 	} } int chka(int f,int g) { 	if(posa[f].x==posa[g].x&&posa[f].y==posa[g].y) 		return 0; 	if(abs(posa[f].x-posa[g].x)==1&&posa[f].y==posa[g].y) 		return 1; 	else if(abs(posa[f].y-posa[g].y)==1&&posa[f].x==posa[g].x) 		return 1; 	return 0; } int chkb(int f,int g) { 	if(posb[f].x==posb[g].x&&posb[f].y==posb[g].y) 		return 0; 	if(abs(posb[f].x-posb[g].x)==1&&posb[f].y==posb[g].y) 		return 1; 	else if(abs(posb[f].y-posb[g].y)==1&&posb[f].x==posb[g].x) 		return 1; 	return 0; }  int tot,visita[1001],visitb[1001]; int dfsa(int v) { 	int i; 	tot++; 	visita[v]=1; 	frea(posa[v].x+1,posa[v].y); 	frea(posa[v].x,posa[v].y+1); 	frea(posa[v].x-1,posa[v].y); 	frea(posa[v].x,posa[v].y-1); 	for(i=0;i<a[v].size();i++) 	{ 		if(!visita[a[v][i]]) 			dfsa(a[v][i]); 	} } int dfsb(int v) { 	int i; 	tot++; 	visitb[v]=1; 	freb(posb[v].x+1,posb[v].y); 	freb(posb[v].x,posb[v].y+1); 	freb(posb[v].x-1,posb[v].y); 	freb(posb[v].x,posb[v].y-1);  	for(i=0;i<b[v].size();i++) 	{ 		if(!visitb[b[v][i]]) 			dfsb(b[v][i]); 	}  } struct an { 	char col; 	int d,c; }ans[1001]; bool cmpa(an p1, an p2) { 	if(p1.c!=p2.c) 		return (p1.c>p2.c); 	return (p1.d>p2.d); } bool cmpb(an p1,an p2) { 	if(p1.c!=p2.c) 		return (p1.c>p2.c); 	return (p1.d>p2.d); }  int main() { 	int t,i,j; 	scanf("%d\n",&t); 	int xt=0; 	char c; 	while(xt<t) 	{ 		xt++; 		sa=0; 		sb=0; 		fill(visita,visita+1001,0); 		fill(visitb,visitb+1001,0); 		scanf("%d %d",&n,&s); 		for(i=1;i<=s;i++) 		{ 			a[i].clear(); 			b[i].clear(); 			scanf(" %c ",&c); 				if(c=='B') 				{ 					sb++; 					scanf("%d %d",&posb[sb].x,&posb[sb].y); 				} 				else 				{ 					sa++; 					scanf("%d %d",&posa[sa].x,&posa[sa].y); 				} 		} 		printf("Case #%d:\n",xt); 		for(i=1;i<=sb;i++) 		{ 			for(j=i+1;j<=sb;j++) 			{ 				if(chkb(i,j)) 				{ 					b[i].push_back(j); 					b[j].push_back(i); 				} 			} 		} 	 		int ant=0; 		useb.clear(); 		for(i=1;i<=sb;i++) 		{ 			tot=0; 			if(!visitb[i]) 			{ 				dfsb(i); 				ans[ant].d=useb.size(); 				ans[ant].col='B'; 				ans[ant++].c=tot; //				printf("%d\n",tot); 			//	for(j=0;j<useb.size();j++) 		//			printf("%d %d, ",useb[j].x,useb[j].y); 	//			printf("\n"); 				useb.clear(); 			} 		} 		sort(ans,ans+ant ,cmpb); 		for(i=0;i<ant;i++) 			printf("%c %d %d\n",ans[i].col,ans[i].c,ans[i].d); //		printf("\n\n"); 		for(i=1;i<=sa;i++) 		{ 			for(j=i+1;j<=sa;j++) 			{ 				if(chka(i,j)) 				{ 					a[i].push_back(j); 					a[j].push_back(i); 				} 			} 		} 		ant=0; 		usea.clear(); 		for(i=1;i<=sa;i++) 		{ 			tot=0; 			if(!visita[i]) 			{ 				dfsa(i); 				ans[ant].d=usea.size(); 				ans[ant].col='W'; 				ans[ant++].c=tot; 				usea.clear(); 			} 		} //		for(i=1;i<=sa;i++) //		{ //			for(j=0;j<a[i].size();j++) //				printf("%d ",a[i][j]); //			printf("\n"); //		} 	sort(ans,ans+ant,cmpa); 		for(i=0;i<ant;i++) 			printf("%c %d %d\n",ans[i].col,ans[i].c,ans[i].d); 		printf("\n"); 	} 	return 0; } 
#include <iostream>  using namespace std; const long long mod=1000000000+7; typedef long long ll; static int fact[10000007];  ll powx(ll a,ll b){     if(b==0)return 1;     if(b==1)return a%mod;     if(b%2==1)return ((a%mod)*powx(a,b-1)%mod)%mod;     ll y=powx(a,b/2)%mod;     return (y*y)%mod; } int main() { int t;long long n;fact[0]=1; cin>>t; while(t--){     cin>>n;     long long ans=1;     for(long long i=1;i<=n;i++){             fact[i]=(fact[i-1]*i)%mod;                 ans=(ans*fact[i])%mod;                 if(ans<0)ans+=mod;         }     cout<<ans<<endl; }      return 0; } 
#include <iostream> #include <stdio.h> #include <string.h> #include <math.h> #include <vector> #include<stack> #include<set> #include<limits.h> #include <queue> #include <map> #include <cstdlib> #include <algorithm> //psyduck #define ll long long #define S(x) scanf("%d",&x) #define Sf(x) scanf("%f",&x) #define Slf(x) scanf("%lf",&x) #define Sl(x) scanf("%lld",&x) #define P(x)  printf("%d\n", x) #define Pf(x)  printf("%f\n", x) #define Plf(x)  printf("%lf\n", x) #define Pl(x)  printf("%lld\n", x) #define mem(x,i) memset(x,i,sizeof(x)) #define pb push_back #define mod 1000000007 #define INF 1000000000000000008LL using namespace std;  void dba(int debug_array[],int n){     for (int i = 1; i <= n; i++)cout << debug_array[i]<<" ";     cout << endl; } void db2a(int debug2d[100][100],int n, int m) {     for (int i = 1; i <= n; i++)         for(int j = 1; j <= m; j++)             cout << debug2d[i][j];         cout << endl; } ll int dp[1004][1005]; int main() {     ll int t,sum,m,n,i,j,k;     Sl(t);Sl(sum);     t++;     ll int ans = 0;     while(t--){         mem(dp,0);         Sl(n);Sl(m);         dp[0][0] = 1;         for (i = 1; i <= n; i++){             for (j = 1; j <= sum; j++){                 dp[i][j] = 0;                 if(j == 0){                     dp[i][0] = 1;                     continue;                 }                 for (k = 1; k <= m; k++){                     if(j >= k)                     dp[i][j] = (dp[i][j]+dp[i-1][j-k])%mod;                 }             }         }         //Pl(dp[n][sum]);         //ll int ans = 0;         ans = (ans + dp[n][sum])%mod;     }     Pl(ans); } 
#include<bits/stdc++.h> using namespace std; #define INF (1<<29) #define SET(a) memset(a,-1,sizeof(a)) #define ALL(a) a.begin(),a.end() #define CLR(a) memset(a,0,sizeof(a)) #define FILL(a,v) memset(a,v,sizeof(a)) #define PB push_back #define PI acos(-1.0) #define EPS 1e-9 #define MP(a,b) make_pair(a,b) #define MIN3(a,b,c) min(a,min(b,c)) #define MAX3(a,b,c) max(a,max(b,c)) #define CASE int t;scanf("%d",&t);while(t--) #define ll long long int #define lu unsigned long long #define MOD 1000000007 #define imax numeric_limits<int>::max() #define imin numeric_limits<int>::min() #define lmax numeric_limits<ll>::max() #define lmin numeric_limits<ll>::min() #define rep(i,n) for(int i=0;i<n;i++) #define fu(i,a,n) for(int i=a;i<=n;i++) #define fd(i,n,a) for(int i=n;i>=a;i--) #define gi(n) scanf("%d",&n) #define gl(n) scanf("%lld",&n) #define pi(n) printf("%d",n) #define pin(n) printf("%d\n",n) #define ps printf(" ") #define pn printf("\n")  typedef pair<int, int> ii; typedef vector<int> vi; typedef vector<ii> vii;   int main() {     int n;     gi(n);     int a[n],cnt[1001],mx=0,pos=0;     CLR(cnt);     rep(i,n)     {     	gi(a[i]);     	cnt[a[i]]++;     }     rep(i,1001)     {     	if(cnt[i]>mx)     	{     		mx =cnt[i];     		pos = i;     	}     }     printf("%d\n%d\n",pos,mx );     return 0; } 
#include <bits/stdc++.h> using namespace std;  #define ll long long #define ld long double #define sl(x) scanf("%lld",&x) #define pl(x) printf("%lld",x) #define sld(x) scanf("%Lf",&x) #define pld(x) scanf("%0.6Lf",x) #define pline() printf("\n")  int main(){     ll i,h;     ld n,a[102],m,sum=0;     ld ans1,ans2,res;     sld(n);sld(m);sl(h);     for(i=1;i<=m;i++){         sld(a[i]);         sum+=a[i];     }     if(sum>=n){         sum--;ans1=1;ans2=1;         //cout<<sum<<endl;         for(i=0;i<=n-2;i++){             ans1*=(sum-i)/(i+1);             //cout<<ans1<<endl;         }          sum++;         sum=sum-a[h];         //cout<<endl;         for(i=0;i<=n-2;i++){             ans2*=(sum-i)/(i+1);             //cout<<ans2<<endl;         }                  res=(ans1-ans2)/ans1;         printf("%Lf",res);     }     else     printf("-1");     pline(); 	return 0; } 
#include <bits/stdc++.h> using namespace std;  int main() {     int t;     cin>>t;     while(t--)     {     long long int n,ti;     cin>>n>>ti;          long long int T[n][n];     long long int toll[n][n];          for(int i=0;i<n;i++)       for(int j=0;j<n;j++)         cin>>T[i][j];                       for(int i=0;i<n;i++)       for(int j=0;j<n;j++)         cin>>toll[i][j];                   long long int dp[55][10005];          for(int i=0;i<55;i++)       for(int j=0;j<10005;j++)         dp[i][j]=INT_MAX;              for(int i=0;i<=ti;i++)       dp[0][i]=0;              for(int time=1;time<=ti;time++)       {        for(int destination=1;destination<n;destination++)          {           for(int source=0;source<n;source++)             {               if(destination==source)                  continue;                if(time>=T[source][destination])                dp[destination][time]=min(dp[destination][time],dp[source][time-T[source][destination]]+toll[source][destination]);             }           }       }     /*for(int i=0;i<n;i++)       { for(int j=0;j<=ti;j++)          {            cout<<dp[i][j]<<" ";          }         cout<<endl;       }*/     int min_time=ti;     while(dp[n-1][ti]==dp[n-1][ti-1])       {       ti--;        min_time--;       }     cout<<dp[n-1][ti]<<" "<<min_time<<endl;    } 	return 0; }
#include <iostream> #include <vector>  using namespace std;  int noOfBlocks, columnLength, rowLength;  struct Block { int period, cellNumber, row, column; vector<int> cells, rowChange, columnChange; }; Block *blocks;  int GCD(int a, int b) { return !b?a:GCD(b,a%b); }  inline int LCM(int a, int b) { return(a*b)/GCD(a,b); }  void sortBlocks() { int min=blocks[0].period; int index=0; for(int i=0; i<noOfBlocks; i++) 	{ 	if(min>blocks[i].period) 		{ 		min=blocks[i].period; 		index=i; 		} 	} if(index) 	{ 	Block temp; 	temp=blocks[0]; 	blocks[0]=blocks[index]; 	blocks[index]=temp; 	} }  int findTotalCells() { int limit=1, lcm=1, maxCells=blocks[0].period, minimumPeriod=blocks[0].period; bool flag; vector<int> newCommonCells; vector<bool> successfulCases; for(int j=0; j<noOfBlocks; j++) 	lcm=LCM(lcm,blocks[j].period); limit=lcm/blocks[0].period; for(int j=0; j<blocks[0].period; j++) 	{ 	int cellN=blocks[0].cells[j]; 	int k=0; 	flag=false; 	for(int I=0; I<limit&&!flag; I++) 		{ 		flag=true; 		for(int i=1; i<noOfBlocks; i++) 			{ 			if(cellN!=blocks[i].cells[(k+j)%blocks[i].period]) 				{ 				flag=false; 				break; 				} 			} 		k=k+minimumPeriod; 		} 	successfulCases.push_back(flag); 	} for(int i=0; i<minimumPeriod; i++) 	{ 	flag=true; 	int temp; 	if(successfulCases[i]==true) 		{ 		temp=blocks[0].cells[i]; 		for(int j=0; j<newCommonCells.size(); j++) 			if(temp==newCommonCells[j]) 				{ 				flag=false; 				break; 				} 		if(flag) 			newCommonCells.push_back(temp); 		} 	} return newCommonCells.size(); }  main() { int fall, temp; for(cin>>fall; fall--;) 	{ 	cin>>rowLength>>columnLength>>noOfBlocks; 	blocks=new Block[noOfBlocks]; 	for(int i=0; i<noOfBlocks; i++) 		{ 		cin>>blocks[i].cellNumber; 		cin>>blocks[i].period; 		for(int j=0; j<blocks[i].period; j++) 			{ 			cin>>temp; 			blocks[i].rowChange.push_back(temp); 			} 		for(int j=0; j<blocks[i].period; j++) 			{ 			cin>>temp; 			blocks[i].columnChange.push_back(temp); 			} 		for(int j=0; j<blocks[i].period; j++) 			blocks[i].cells.push_back(blocks[i].cellNumber+blocks[i].rowChange[j]*columnLength+blocks[i].columnChange[j]); 		blocks[i].rowChange.clear(); 		blocks[i].columnChange.clear(); 		} 	sortBlocks(); 	cout<<findTotalCells()<<endl; 	delete[] blocks; 	} return 0; } 
#include<bits/stdc++.h> using namespace std; int main(){ 	int t; 	cin>>t; 	while(t--){ 		string s; cin>>s; 		int l=s.size(); 		int f=0; 		for(int i=0; i<l-1; i++){ 			if(s[i]=='0' && s[i+1]=='1') f++; 		} 		cout<<f<<endl; 	} }
#include<iostream> using namespace std; int main() {     int test,n,b;     cin>>test;     while(test--)     {         cin>>n;         int count=0;         while(n)         {             b=n;             //cout<<(b&1)<<endl;             if((b&1)!=0)                 break;             count++;             n=n>>1;         }         cout<<count<<endl;     } } 
#include<iostream> #include<string.h> using namespace std; char arr[100001]; int num[10] = { 0 }; int apl[26] = { 0 }; int main() { 	int t; 	cin >> t; 	while (t--) 	{ 		cin >> arr; 		for (int i = 0; arr[i] != '\0'; i++) 		{ 			if (isalpha(arr[i])) 			{ 				apl[arr[i] - 'a']++; 			} 			else 				num[arr[i] - '0']++; 		} 		int ind1, ind2; 		ind1 = ind2 = 0; 		for (int i = 0; arr[i] != '\0'; i++) 		{ 			if (isalpha(arr[i])) 			{ 				while (!apl[ind2] && ind2<26) 				{ 					ind2++; 				} 				arr[i] = 'a' + ind2; 				apl[ind2]--; 			} 			else 			{ 				while (!num[ind1] && ind1 < 10) 					ind1++; 				arr[i] = '0' + ind1; 				num[ind1]--; 			} 		} 		cout << arr << endl;; 	}  return 0; }
#include<iostream>  using namespace std;  int main() { 	int t,x; 	long long n,sum,tot; 	cin >> t; 	while (t--) 	{ 		tot=sum = 0; 		cin >> n; 		sum = (n*(n + 1)); 		sum = sum >> 1; 		for (int i = 0; i < n-1; i++) 		{ 			cin >> x; 			tot += x; 		} 		cout << sum -tot<< endl; 	}  	return 0; }
#include <bits/stdc++.h> using namespace std;  int main()  { int test; long long int i, n ,m ; cin >> test;  while(test--) { long long int sum = 0; cin >>n >>m; long long diff = m-1; long long sum1 = (diff * (diff+1)) / 2; long long int x = n % m;  long long int extra = n/m;      sum =sum1 * extra;  if(x != 0) {   sum = sum + x*(x+1) / 2; }  cout << sum << endl;  }    //STUPID SHIT 	return 0; }
#include<iostream> #include<string.h> #include<stdio.h> using namespace std; int main() { int t; cin>> t; while(t--) {   int n;   cin>>n;   char a[10001];   scanf("%s" , &a);   int f= strlen(a);     int temp;  for(int i=0; i<f; i++)   {       temp = a[i] - 'a';     temp = (temp+n)%26;     char j=char(temp + 'a');     cout<<j;    }   cout<<"\n";   } } 
#include<iostream> #include<math.h> using namespace std; int len(long unsigned n) {	int l=0; 	while(n) n/=10,l++; 	return l; } int isprime(long unsigned n) {	long unsigned i; 	for(i=2;i<n;i++) 	if(n%i==0) break; 	if(i==n) return 1; 	else return 0; } long unsigned num_rot(long unsigned n,int f) {	int i,l=len(n)-1; 	while(f--) 	{	i=n%10; 		n/=10; 		n+=i*pow(10,l);	 	} 	return n; } int cir_prime(long unsigned n) {	long unsigned k=n; 	int l=len(n); 	if(isprime(k)) 	{	while(l--) 		{	k=num_rot(n,l); 			if(!isprime(k)) break; 			if(k<n && cir_prime(k)) break; 		} 		if (l==-1) return 1; 		else return 0; 	} 	else  		return 0; } int main() { 	long unsigned t,n,i; 	int count; 	cin>>t; 	while(t--) 	{	cin>>n; 		cout<<"Number of circular primes below "<<n<<" is "; 		count=0; 		for(i=2;i<n;i++) 		{	if(cir_prime(i)) count++; 		} 		cout<<count<<endl; 	} }
#include<iostream> using namespace std; long getSumOfDivisors(long n);  int main() {     long n,sum=0,sum1=0;     int t; cin>>t;     while(t--)     {         cin>>n;     sum=getSumOfDivisors(n);     sum1=getSumOfDivisors(sum);     if(sum1 == n)         cout<<"Yes, amicable with "<<sum<<endl;     else         cout<<"No"<<endl;     }     return 0; } long getSumOfDivisors(long n) {     long sum =1;     for(long i=2;i<=n/2;++i)     {         if(n % i == 0)         {             sum += i;         }     }     return sum; }
#include <stdio.h>  int main() {     int i = 100, rem, sum, temp, tnum;            for ( ; i <= 999; i++)     {         tnum = i;         sum = 0;         while (tnum > 0)         {             rem = tnum % 10;             temp = rem * rem * rem;             sum = temp + sum;             tnum = tnum / 10;         }         if (i == sum)             printf("%d\n", sum);     }     return 0;      }
#include <iostream> #include <bits/stdc++.h> #include <string> #include <cstring> using namespace std;  int dp[1000][1000];   int LCS(string s1, string s2) { 	int m, n, i, j; 	m = s1.length(); 	n = s2.length();  	for(i = 0; i <= m; i++) { 		for(j = 0; j <= n; j++) { 			if (i == 0) { 				dp[i][j] = 0; 			} else if (j == 0) { 				dp[i][j] = 0; 			} else if (s1[i-1] == s2[j-1]) { 				dp[i][j] = 1 + dp[i-1][j-1]; 			} else { 				dp[i][j] = max(dp[i-1][j], dp[i][j-1]); 			} 		} 	}  	return dp[m][n]; }  int main() { 	string s1, s2; 	cin>>s1>>s2; 	cout<<LCS(s1, s2)<<endl; 	return 0; } 
#include<stdio.h> #include<stdlib.h> #include<string.h>     struct node {        char cha;        struct node *next;        };         void push(struct node** head_ref, char new_data) {    struct node* new_node =(struct node*) malloc(sizeof(struct node));    new_node->cha = new_data;    new_node->next = (*head_ref);    (*head_ref)= new_node; } struct node* deleteit(struct node *temp,int n) {        n=n-1;      int count=1;      struct node *p,*q;      while(count<n)      {                    temp=temp->next;                    count++;                    }                    p = temp->next->next;                    q=temp->next;                    temp->next=p;     free(q);                   return p;                    }     int absolute(int x,int y)  {      if(y>x)      return y-x;      else      return x-y;      }        int main()        {            int t;            scanf("%d",&t);            while(t--)            {            int c[30],d[30],m,x,n=0,i;            char a[20007],b[20007];            struct node *head=NULL;            struct node *tem;            struct node *temp;            scanf("%s",a);            scanf("%s",b);            x=strlen(a);            m=strlen(b);            for(i=0;i<28;i++)            {                             c[i]=0;                             d[i]=0;                             }            for(i=0;i<x;i++)            {                            if(a[i]>='a'&&a[i]<='z')            c[a[i]-'a']++;            else            c[a[i]-'A']++;            }            for(i=0;i<m;i++)            {                            if(b[i]>='a'&&b[i]<='z')            d[b[i]-'a']++;            else            d[b[i]-'A']++;            }            for(i=0;i<28;i++)            n=n+absolute(c[i],d[i]);             push(&head,'s');             push(&head,'e');             push(&head,'m');   push(&head,'a');   push(&head,'l');   push(&head,'f');   tem=head;   while(tem->next!=NULL)   {                         tem=tem->next;                         }                         tem->next=head;                 if(n==0||n==1)             printf("SISTER\n");             else             {                temp=deleteit(head,n);                            temp=deleteit(temp,n);                           temp=deleteit(temp,n);                                temp=deleteit(temp,n);                                  temp=deleteit(temp,n);             if(temp->cha=='f')             printf("FRIENDS\n");             if(temp->cha=='l')             printf("LOVE\n");             if(temp->cha=='a')             printf("ADORE\n");             if(temp->cha=='m')             printf("MARRIAGE\n");             if(temp->cha=='e')             printf("ENEMIES\n");             if(temp->cha=='s')             printf("SISTER\n");             }             }             return 0;             } 
/* Success is a matter of hanging on, when others have let go. Its not who you are, that holds you back, its who you think you are not. The future belongs to those, who believe in the beauty of their dreams. */ //{ /* theCodeGame */ #include<iostream> #include<cmath> #include<algorithm> #include<climits> #include<vector> #include<queue> #include<bitset> #include<cstdlib> #include<cstdio> #include<cstring> #include<ctime> #include<map> using namespace std; #define MOD 1000000007LL #define LL long long #define ULL unsigned long long #define LD long double #define MAX(a,b) ((a)>(b)?(a):(b)) #define MIN(a,b) ((a)<(b)?(a):(b)) #define ABS(x)   ((x)<0?-(x):(x)) #define SQR(x) ((x)*(x)) #define CUBE(x) ((x)*(x)*(x)) #define si(n) scanf("%d",&n) #define si2(n,m) scanf("%d %d",&n,&m) #define sf(n) scanf("%f",&n) #define sl(n) scanf("%ld",&n) #define sll(n) scanf("%lld",&n) #define slu(n) scanf("%llu",&n) #define sd(n) scanf("%lf",&n) #define ss(n) scanf("%s",n) #define pnl printf("\n") #define REP(i,n) for(int i=0;i<(n);i++) #define FOR(i,a,b) for(int i=(a);i<(b);i++) #define FORR(i,n,e) for(int i=(n);i>=(e);i--) #define FORD(i,a,b,d) for(int i=(a);i<(b);i+=(d)) #define FORRD(i,n,e,d) for(int i=(n);i>=(e);i-=(d)) //#undef mydebug #ifdef mydebug #define DB(x) cout<<#x<<"="<<(x)<<"\n" #define DB2(x,y) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\n" #define DB3(x,y,z) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\n" #define DB4(x,y,z,a) cout<<#x<<"="<<(x)<<"\t"<<#y<<"="<<(y)<<"\t"<<#z<<"="<<(z)<<"\t"<<#a<<"="<<(a)<<"\n" #define pnld pnl; #else #define DB(x) #define DB2(x,y) #define DB3(x,y,z) #define DB4(x,y,z,a) #define pnld #endif #define FILL(a,b) memset(a,b,sizeof(a)) const double PI=3.14159265358979323846264338327950288419716939937510582097494459230; //template <class T>void swap(T &x,T &y){T t;t=x;x=y;y=t;} void DBG_ARR(const int A[],int S,int N){cout<<"[";FOR(i,S,N){cout<<A[i]<<" ";}cout<<"]\n";} void swaps (char &x,char &y){char t;t=x;x=y;y=t;}void swapi(int &a,int &b){int t;t=a;a=b;b=t;} ULL gcd(ULL a,ULL b){if(a==0)return b;if(b==0)return a;if(a==1||b==1)return 1;if(a==b)return a;if(a>b)return gcd(b,a%b);else return gcd(a,b%a);} //} const int TOP = 1; const int RIGHT = 2; const int BOTTOM = 3; const int LEFT = 4; int ROWS,COLS,ENTRY; int arr[11][11]; char INPUT[11];  void precompute(){} void doThis(){     scanf("%d %d %d",&ROWS,&COLS,&ENTRY);      FOR(i,0,ROWS){         ss(INPUT);         FOR(j,0,COLS){           arr[i][j] = INPUT[j];         }      }      int currROW = 0,currCOL = ENTRY-1;      int temp,loop,visited = 0;      while(1){               temp = arr[currROW][currCOL];               if(temp<0){//if already visited                       loop = 0 - (visited - temp - 1);                       printf("%dL\n",loop);                       return;                }else{                     arr[currROW][currCOL] = --visited;                     switch(temp){                                  case 78: case 110:                                       if(currROW == 0){                                                printf("%dE\n",(0-visited));                                                return;                                       }                                       else                                       currROW-=1;                                       break;                                  case 69: case 101:                                       if(currCOL == COLS-1){                                                printf("%dE\n",(0-visited));                                                return;                                       }                                       else                                       currCOL+=1;                                        break;                                  case 83: case 115:                                       if(currROW == ROWS-1){                                                printf("%dE\n",(0-visited));                                                return;                                       }                                       else                                       currROW+=1;                                       break;                                  case 87: case 119:                                       if(currCOL == 0){                                                printf("%dE\n",(0-visited));                                                return;                                       }                                       else                                       currCOL-=1;                                       break;                                  default : break;                     }//end switch               }//end if else      }//end while }  int main(){ #ifdef amy freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\err.txt", "w", stderr); #endif precompute(); int t=1; scanf("%d",&t); while(t--){doThis();} #ifdef amy fprintf(stdout,"\nTIME: %.3lf sec\n", (double)clock()/(CLOCKS_PER_SEC)); #endif return 0; } 
/* bhupkas */  #include "bits/stdc++.h"  using namespace std;  int read () { 	bool minus = false; 	int result = 0; 	char ch; 	ch = getchar(); 	while (true) { 		if (ch == '-') break; 		if (ch >= '0' && ch <= '9') break; 		ch = getchar(); 	} 	if (ch == '-') minus = true; else result = ch-'0'; 	while (true) { 		ch = getchar(); 		if (ch < '0' || ch > '9') break; 		result = result*10 + (ch - '0'); 	} 	if (minus) 		return -result; 	else 		return result; }  int  A[100005]; int  memo[100005];  #define INF (int)(1e9) /*  int segtree[400005]; void build(int idx,int l,int r) { 	if(l == r)	 	{ 		segtree[idx] = A[l]; 		return; 	} 	int mid = (l + r ) >> 1; 	build(2*idx + 1 , l , mid); 	build(2*idx + 2 , mid + 1 , r); 	segtree[idx] = min(segtree[2*idx + 1] , segtree[2 * idx + 2]); }  int query(int idx, int l ,int r , int ql , int qr) { 	if(l > qr || r < ql)	return INF; 	if(l >= ql && r <= qr)	return segtree[idx];  	int mid = (l + r) >> 1; 	if(mid >= qr)	return query(2*idx + 1 , l , mid , ql , qr); 	else if(mid < ql)	return query(2*idx + 2 , mid + 1 , r , ql , qr); 	return min(query(2*idx + 1 , l , mid , ql , qr) , query(2*idx + 2 , mid + 1, r, ql, qr));	 }  void update(int idx, int l , int r , int index, int val) { 	if(index < l || index > r)	return; 	if(l == r && index == l)	 	{ 		segtree[idx] = val; 		return; 	} 	int mid = (l + r) >> 1; 	if(mid >= index)	update(2 * idx + 1, l , mid , index , val); 	else			update(2 * idx + 2, mid + 1, r , index, val); 	segtree[idx] = min(segtree[2*idx+1],segtree[2*idx+2]); } */ int main() { 	int t,n,d; 	t = read(); 	deque < int > q1,q2; 	while(t--) 	{ 		q1.clear(); 		q2.clear(); 		n = read(); 		d = read(); 		for(int i = 0 ; i < n ; i++)	A[i] = read(); 		for(int i = 0 ; i < n ; i++)	memo[i] = INF; 		//build(0,0,n-1); 		memo[0] = A[0]; 		q1.push_back(memo[0]); 		q2.push_back(memo[0]); 		//update(0,0,n-1,0,memo[0]); 		for(int i = 1 ; i < n ; i++) 		{	 			memo[i] = min(memo[i] , q1.front() + A[i]); 			while(!q1.empty() && memo[i] < q1.back())	q1.pop_back();			 			q1.push_back(memo[i]); 			q2.push_back(memo[i]); 			if(q2.size() > d) 			{ 				if(q2.front() == q1.front())	q1.pop_front() , q2.pop_front(); 				else	q2.pop_front(); 			} 			//update(0,0,n-1,i,memo[i]); 		} 		printf("%d\n",memo[n-1]); 	} 	return 0; }
#include <cstdio> #include <cmath> #include <cstring> int a[100001]; int countPalindrome(char *str) { 	int i,j,k,count=0; 	for(i=0;str[i];i++) 	{ 		k=i-1; 		j=i+1; 		while(k>=0 && str[j] && str[k]==str[j]) 		{             if(a[(j-k)+1]==0) 			   ++count; 			k--; 			j++; 		}  		k=i; 		j=i+1; 		if(k>=0 && str[j] && str[k]==str[j]) 			++count; 	} 	return count; } int main() {     int t;     char s[100001];     int i,j;     memset(a,0,sizeof a);     a[1]=a[0]=1;     for(i=2; i<=sqrt(100000); i++)         if(a[i]==0)             for(j=2; (i*j)<100000; j++)                 a[i*j]=1;     scanf("%d",&t);     while(t--)     {         scanf("%s",s);         printf("%d\n",countPalindrome(s));     }     return 0; } 
     #include<iostream>     #define modulo 10000007ULL     #define constant 2ULL     #define constant2 3ULL     using namespace std;     unsigned long long exponent(unsigned long long number,int n)     {     unsigned long long e;     if(n==0) return 1;     e = exponent(number,n/2);     e=(e*e)%modulo;     if(n&1)     e=(e*number)%modulo;     return e;     }     int main()     {     int t,n;int temp2=9988439;     cin>>t;     while(t--)     {     cin>>n;     if(n&1)     {     n--;     unsigned long long temp=((exponent(constant,n)-1)*(exponent(constant2,temp2)))%modulo;     unsigned long long res=(constant*temp+1)%modulo;     cout<<res<<"\n";     }     else     {     unsigned long long temp=((exponent(constant,n)-1)*(exponent(constant2,temp2)))%modulo;     cout<<temp<<"\n";     }     }     } 
/* bhupkas */  #include "bits/stdc++.h"  using namespace std;  int cnt[100005];  int read ()  { 	bool minus = false; 	int result = 0; 	char ch; 	ch = getchar(); 	while (true) { 		if (ch == '-') break; 		if (ch >= '0' && ch <= '9') break; 		ch = getchar(); 	} 	if (ch == '-') minus = true; else result = ch-'0'; 	while (true) { 		ch = getchar(); 		if (ch < '0' || ch > '9') break; 		result = result*10 + (ch - '0'); 	} 	if (minus) 		return -result; 	else 		return result; }  int main() { 	int t,n,q; 	t = read(); 	deque<int> Q; 	int a,b; 	int curr; 	int si; 	while(t--) 	{ 		si = 0; 		Q.clear(); 		n = read(); 		q = read(); 		memset(cnt,0,sizeof(cnt)); 		while(q--) 		{ 			a = read(); 			b = read(); 			if(a == 1) 			{	 				Q.push_back(b); 				if(cnt[b] == 0)	si++; 				cnt[b]++; 				if(si > n) 				{ 					while(si > n) 					{ 						curr = Q.front(); 						Q.pop_front(); 						cnt[curr]--; 						if(cnt[curr] == 0)	si--; 					} 				} 			} 			else 			{	 				if(cnt[b] > 0)	puts("YES"); 				else		puts("NO"); 			}	 		} 	} 	return 0;	 }
#include<bits/stdc++.h>  using namespace std;  static int dp[1000][1000] , arr1[1000][1000] , arr2[1000][1000];  int main () { 	int t , n , m , i , j , q , x1 , y1 , x2 , y2 , sum; 	 	cin >> t; 	 	while(t --) 	{ 		cin >> n >> m >> q; 		 		for(i = 0; i < n ; i++) 		{ 			for(j = 0; j < m; j ++) 				cin >> arr1[i][j]; 		} 		 		for(i = 0; i < n; i++) 		{ 			cin >> arr2[i][0]; 			 			if(arr2[i][0] == arr1[i][0]) 				dp[i][0] = 1; 				 			else 				dp[i][0] = 0; 		 			for(j = 1; j < m; j++) 			{ 				cin >> arr2[i][j]; 				 				if(arr2[i][j] == arr1[i][j]) 					dp[i][j] = dp[i][j - 1] + 1; 					 				else 					dp[i][j] = dp[i][j - 1]; 			} 			 		} 		 		for(j = 0; j < q; j++) 		{ 			cin >> x1 >> y1 >> x2 >> y2; 			 			sum = 0; 			 			for(i = x1 - 1; i <= x2 - 1; i++) 			{ 				if(arr2[i][y1 - 1] == arr1[i][y1 - 1]) 					sum = sum + dp[i][y2 - 1] - dp[i][y1 - 1] + 1; 					 				else 					sum = sum + dp[i][y2 - 1] - dp[i][y1 - 1]; 					 			} 			 			cout << sum << endl; 			 		} 		 	} 	 	return 0; 	 } 		 
//#include<utility>  #include <iostream> #include <cmath> #include <vector> #include <queue> #include <algorithm> #include <list> #include <stack> #include <string.h> #include <sstream> #include <stdio.h> //#define mod 1000000007 using namespace std; typedef  long long int ll;  int a[31][31][31][31];  int main() {     int t,n,i,j,k,l;     char s1[32],s2[32],s3[33],s4[33];     cin>>t;     while(t--)     {         cin>>n;         getchar();         for(i=1;i<=n;i++)             cin>>s1[i];         getchar();         for(i=1;i<=n;i++)             cin>>s2[i];         getchar();         for(i=1;i<=n;i++)             cin>>s3[i];         getchar();         for(i=1;i<=n;i++)             cin>>s4[i];         getchar();         for(i=0;i<=n;i++)             for(j=0;j<=n;j++)                 for(k=0;k<=n;k++)                     for(l=0;l<=n;l++)                     {                          if(i==0||j==0||k==0||l==0)                             a[i][j][k][l]=0;                         else if (s1[i]==s2[j] && s2[j]==s3[k] && s3[k]==s4[l])                             a[i][j][k][l]=a[i-1][j-1][k-1][l-1]+1;                         else a[i][j][k][l]=max(max(a[i-1][j][k][l],a[i][j-1][k][l]),max(a[i][j][k-1][l],a[i][j][k][l-1]));                     }         cout<<a[n][n][n][n]<<endl;     } }
#include<bits/stdc++.h> using namespace std; long long int fastread() {long long int t=0; char ch=getchar(); while(ch<33) ch=getchar(); while(ch>33) {t=t*10+ch-'0'; ch=getchar(); } return t; } int main() {  long long int i,j,k,t,n;  t=fastread();  while(t--)  {      n=fastread();      for(i=2,j=1;n!=1;)      {          if(n&1)             j+=i;          i<<=1;          n>>=1;      }      printf("%lld\n",j);  }  return 0; } 
// An easy concept, but using Lucas theorem disturbs me a lot! #include<stdio.h> #include<iostream> #include<vector> using namespace std; #define ll long long #define mod 100003  ll countFact(ll n, ll p) {     ll k=0;     while (n>=p)     {         k+=n/p;         n/=p;     }     return k; }   /* This function calculates (a^b)%MOD */ long long pow(ll a, ll b, ll MOD) {     long long x=1,y=a;      while(b > 0)     {         if(b%2 == 1)         {             x=(x*y);             if(x>MOD) x%=MOD;         }         y = (y*y);         if(y>MOD) y%=MOD;          b /= 2;     }     return x; }   /*  Modular Multiplicative Inverse     Using Euler's Theorem     a^(phi(m)) = 1 (mod m)     a^(-1) = a^(m-2) (mod m) */ long long InverseEuler(ll n,ll MOD) {     return pow(n,MOD-2,MOD); }   long long factMOD(ll n, ll MOD) {     long long res = 1;      while (n > 0)     {         for (ll i=2, m=n%MOD; i<=m; i++)             res = (res * i) % MOD;         if ((n/=MOD)%2 > 0)              res = MOD - res;     }     return res; }   long long C(ll n, ll r, ll MOD) {     if (countFact(n, MOD) > countFact(r, MOD) + countFact(n-r, MOD))         return 0;       return (factMOD(n, MOD) *             ((InverseEuler(factMOD(r, MOD), MOD) *              InverseEuler(factMOD(n-r, MOD), MOD)) % MOD)) % MOD; }  int main() { 	int test;scanf("%d",&test); 	while(test--) 	{ 		ll n,k;scanf("%lld%lld",&n,&k); 		if(k==1) 		{ 			printf("%lld\n",n%mod); 			continue; 		} 		ll ans=0; 		if(n-k-1>=k) 			ans+=C(n-k-1,k,mod); 		if(n-k-1>=k-2) 			ans+=C(n-k-1,k-2,mod); 		if(n-k-1>=k-1) 			ans+=2*C(n-k-1,k-1,mod); 		printf("%lld\n",(ans+mod)%mod); 	} 	return 0; }
#include<iostream> using namespace std; int main() { int n,t; long long arr[100002],dp[100006]; //cin>>t; scanf("%d",&t); while(t--) {   scanf("%d",&n);   for(int i=0;i<n;i++)    scanf("%lld",&arr[i]);   dp[n]=dp[n+1]=0;   for(int i=n-1;i>=0;i--)     dp[i]=max(arr[i]+dp[i+2],dp[i+1]);   //cout<<dp[0]<<endl;   printf("%lld\n",dp[0]); } return 0; } 
 #include<stdio.h> #include<string.h> #include<math.h> #include<stdlib.h>   long long int a[10000+1];  long long special_numbers(int d);    int main() {  int T;  scanf("%d", &T);  while (T--) {  int D;  scanf("%d", &D);  printf("%lld\n", special_numbers(D));  }    return 0;  }    long long special_numbers(int d) {  long long int count;  int i;  a[0]=0;a[1]=9;a[2]=90;a[3]=900;a[4]=8991;  if(d<=3)  return (9*pow(10,d-1));    if(d>=4)  {    for(i=5;i<=d;i++)  {  if(a[i]!=0)  continue;  else  {  count=((a[i-1]-a[i-4]*9)*10+a[i-4]*9*9)%1000000007;  if(count<0)  count=1000000007+count;  a[i]=count;  }  }  return a[d];  }    }
#include <iostream>  using namespace std;  int main() { 	int t; 	int b; 	int d; 	int temp; 	int iter; 	int last; 	int count;  	cin >> t;  	while (t--) { 		cin >> b;  		bool dist[b];  		for (int i = 0; i < b; i++) { 			dist[i] = 0; 		} 		 		iter = 1; 		count = 0; 		for (int i = 0; i < b; i++) { 			if (!dist[i]) { 				dist[i] = true; 				count++; 				last = i; 				d = i + 1;  				while (d < b) { 					temp = iter; 					 					while (temp && d < b) { 						if (!dist[d++]) { 							temp--; 						} 					} 					while (dist[d] && d < b) { 						d++; 					} 					if (!temp && d < b) { 						dist[d] = true; 						count++; 						last = d; 						d++; 					} 				} 				iter++; 			} 			if (count == b) { 				break; 			} 		}  		cout << last + 1 << endl; 	}  	return 0; } 
#include <bits/stdc++.h> #define ll long long int #define s(a) scanf("%lld",&a)  using namespace std;  ll tree[400001]={0}; ll a[200001];  ll update(ll l,ll r,ll node) {     if(l>r) return 0;     if(l==r) {tree[node]=a[l];return tree[node];}     else {ll mid=(l+r)/2;tree[node]=update(l,mid,2*node)+update(mid+1,r,2*node+1);return tree[node];} }  ll query(ll l,ll r,ll node,ll x,ll y) {     if(l>r)return 0;     ll mid=(l+r)/2;     if(y<l||x>r) return 0;     if(l>=x&&r<=y) return tree[node];     return query(l,mid,2*node,x,y)+query(mid+1,r,2*node+1,x,y); }  int main() {     ll n,q,i,x,y,t;     s(t);     while(t--) {     s(n);s(q);     for(i=1;i<=n;i++) {         s(a[i]);     }     x=update(1,n,1);    // for(i=1;i<2*n;i++) cout<<tree[i]<<endl;     while(q--) {         s(x);s(y);         cout<<query(1,n,1,x,y)<<endl;     }     }     return 0; } 
    #include<bits/stdc++.h>     using namespace std;     int main()     {     long int t;     scanf("%ld",&t);     while(t--)     {     long int n;     scanf("%ld",&n);     double p,m,b;     for(long int i=0;i<n;i++)     {     scanf("%lf %lf",&p,&m);     b=p-ceil(((m*p)/100));     printf("%.0lf\n",b);     }     }     return 0;     } 
#include <bits/stdc++.h> #define ll long long int #define s(a) scanf("%lld",&a)  using namespace std;  int main() {     ll t,n,k,i,j,tot;     s(t);     while(t--) {         s(n);s(k);         ll a[101]={0};         a[0]=1;         a[1]=1;         for(i=2;i<=n;i++) {             a[i]=a[i-1];             for(j=2;j<k;j++) {                 if(j>i) break;                 if(__gcd(j,k)>1) continue;                 if(i==j) {a[i]++;continue;}                 a[i]=a[i-j-1]+a[i];             }           //  cout<<a[i]<<endl;         }         cout<<a[n]<<endl;     }     return 0; } 
#include<bits/stdc++.h> using namespace std; #define lli long long int int main(){ 	int n,t; 	cin>>t; 	while(t--){ 		cin>>n; 		int x,tt; 		cin>>x; 		for(int i=1;i<n;i++){ 			cin>>tt; 			x=__gcd(x,tt); 		} 		if(x==1)cout<<n<<"\n"; 		else cout<<"0\n"; 	} 	 	return 0; } 
#include <stdio.h> #include <algorithm>   #define N 100010   using namespace std;   int arr[N]; int n;   int main() { 	scanf("%d", &n); 	for(int i = 0;i < n;i++) { 		scanf("%d", &arr[i]); 	} 	sort(arr, arr+n); 	int ans = 0; 	for(int i = 0, j = 0;j < n;j++) { 		while(i < j && 2*arr[i] < arr[j]) { 			i++; 		} 		if(j-i+1 > ans) {  			ans = j-i+1; 		} 	} 	printf("%d\n", n - ans); 	return 0; } 
#include<iostream> #include<cstdio> #include<algorithm> using namespace std; int main() {      int t,a[110],b[1010],c,n,x,y,d,h=0;     while(scanf("%d",&t)!=EOF)      {             cout<<"suck"<<endl;     }    return 0; }
#include<iostream> #include<algorithm>  bool comp(int a,int b) {      return a>b; }  using namespace std;  int main() {     char buf[10];     int t,i,n,tc=1;     int a[10],b[10],sum;     scanf("%s",buf);     //cout<<buf;     scanf("%d",&t);     //cout<<t;     while(scanf("%d",&n)!=EOF)     {               sum=0;               //scanf("%d",&n);               for(i=0;i<n;i++)               {                   scanf("%d",&a[i]);               }                              for(i=0;i<n;i++)               {                   scanf("%d",&b[i]);               }                              sort(a,a+n);               sort(b,b+n,comp);               for(i=0;i<n;i++)               {                   sum+=(a[i]*b[i]);               }               printf("Case #%d: %d\n",tc++,sum);     }     return 0; }
#include<cstdio> #include<algorithm> #include<iostream> using namespace std; int main() {     int test,count=1;     test=0;int i=1;     scanf("%d",&test);     while(test--)     {                              int fake;                  scanf("%d",&fake);                                    int n;                  scanf("%d",&n);                  int ar1[n],ar2[n];                                    for(int i=0;i<n;i++)                  scanf("%d",&ar1[i]);                                    if(n!=1)                  printf("Case #%d: %d\n",count,ar1[n-1]+(ar1[n-1]-ar1[n-2]));                  else                  printf("Case #%d: I don't know.\n",count);                  count++;     } return 0; }
#include<iostream> #include<cstdio> #include<algorithm> using namespace std; int main() {      int t,a[110],b[1010],c,n,x,y,d,h=0;     while(scanf("%d",&t)!=EOF)      {        for(int j=0;j<1010;j++)        b[j]=0;       cin>>c>>n;        for(int i=0;i<n;i++)       {              cin>>a[i];              b[a[i]]++;             if(b[a[i]]==2)              b[a[i]]--;       }       for(int k=0;k<n;k++)       {              d=c-a[k];              if(d>0)              {                   if(b[d]==1)                   break;              }       }       for(int z=0;z<n;z++)       {            if(d==a[z])            {               x=z;               break;            }       }          for(int z1=0;z1<n;z1++)       {            if((c-d)==a[z1])            {               y=z1;               break;            }       }        if(x==y)        x++;         h++;       cout<<"Case #"<<h<<": "<<min(x,y)+1<<" "<<max(x,y)+1<<endl;     }    return 0; }
#include <iostream> //#include<bits/stdc++.h> using namespace std; int dp[3200][3200];  int fnc(string ss){ 	int l= ss.length(); 	 	for(int i=0;i<l;i++){ 		dp[i][i]=1; 	} 	for(int i=0;i<l-1;i++){ 		if(ss[i]==ss[i+1]){ 			dp[i][i+1]=2; 		} 		else dp[i][i+1]=1; 	} 	 	for(int i=3;i<=l;i++){ 		for(int j=0;j<=l-i;j++){ 			if(ss[j]!=ss[j+i-1]){ 				dp[j][j+i-1]=max(dp[j][i+j-2],dp[j+1][i+j-1]); 			} 			if(ss[j]==ss[j+i-1]){ 				dp[j][i+j-1]=dp[j+1][i+j-2]+2; 			} 			 		} 	} 	int maxx=0; 	for(int i=1;i<l-1;i++){ 		int tp=dp[0][i]*dp[i+1][l-1]; 		if(tp>maxx)maxx=tp; 	} 	return maxx; }   int main() { 	//char ss[100000]; 	string ss; 	cin>>ss; 	cout<<fnc(ss); 	return 0; }
#include <iostream>  int main () { 	int n; 	int k; 	std::cin>>n>>k;  	int *a = new int[n]; 	int sum =0;  	for (int i=0; i<n; i++) 		std::cin>>a[i];  	for (int i=0; i<n-k; i++) 		sum+=(-1*a[i]); 	for (int i=n-k; i<n; i++) 		sum+=a[i];  	std::cout<<sum<<std::endl; 	delete a; 	return 0; }
#include<cstdio> #include<algorithm> using namespace std; #define rep(i,a,b) for(i=a;i<b;i++) #define max(a,b) ((a)<(b) ? (b) : (a)) int a[1000],n; int main() {     int ans = 0,i,j;     scanf("%d",&n);     rep(i,0,n) scanf("%d",&a[i]);     sort(a,a+n);     j = n/2;     if(n&1) {             ans += a[j+1] - a[j-1];             rep(i,j+2,n) ans += 2*a[i];             rep(i,0,j-1) ans -= 2*a[i];             ans += max(a[j]-a[j-1],a[j+1]-a[j]);     }     else {          ans += a[j] - a[j-1];          rep(i,j+1,n) ans += 2*a[i];          rep(i,0,j-1) ans -= 2*a[i];     }     printf("%d",ans);     return 0; } 
#include <iostream> #include <cstdio> #include <string> #include <vector> #include <set> #include <map> #include <queue> #include <cmath> #include <algorithm> #include <sstream> #include <stack> #include <cstring> #include <iomanip> #include <ctime> using namespace std; #define pb push_back #define INF 1000000000 #define FOR(i,n) for(int (i)=0;(i)<(n);++(i)) #define FORI(i,n) for(int (i)=1;(i)<=(n);++(i)) #define mp make_pair #define pii pair<int,int> #define ll long long #define vi vector<int> #define SZ(x) ((int)(x.size())) #define fi first #define se second #define wez(n) int (n); scanf("%d",&(n)); #define wez2(n,m) int (n),(m); scanf("%d %d",&(n),&(m)); #define wez3(n,m,k) int (n),(m),(k); scanf("%d %d %d",&(n),&(m),&(k)); inline void pisz(int n) { printf("%d\n",n); } template<typename T,typename TT> ostream& operator<<(ostream &s,pair<T,TT> t) {return s<<"("<<t.first<<","<<t.second<<")";} template<typename T> ostream& operator<<(ostream &s,vector<T> t){FOR(i,SZ(t))s<<t[i]<<" ";return s; } #define IN(x,y) ((y).find((x))!=(y).end()) #define DBG(vari) cerr<<#vari<<" = "<<(vari)<<endl; #define ALL(t) t.begin(),t.end() #define FOREACH(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++) #define TESTS wez(testow)while(testow--) #define REP(i,a,b) for(int (i)=(a);(i)<=(b);++i) #define REPD(i,a,b) for(int (i)=(a); (i)>=(b);--i) #define REMAX(a,b) (a)=max((a),(b)); #define REMIN(a,b) (a)=min((a),(b)); #define IOS ios_base::sync_with_stdio(0);   #define M (1<<17) int d[2*M+2];   void dodaj (int pos, int ile) {    for (int i = pos + M; i > 0; i >>= 1) {       d[i] += ile;    } }   int kty (int k) { // 1-based    int nr = 1;    while (nr < M) {       if (d[nr] < k) return -1;       if (d[2*nr] >= k) {          nr *= 2;       } else {          k -= d[2*nr];          nr = 2*nr + 1;       }    }    return nr - M; }   // uÅ¼ycie: np. inicjalizacja: /*    wez(n)    FOR(i,2*M) d[i] = 0;    FOR(i,n) scanf("%d",&d[i+M]);    REPD(i,M-1,1) d[i] = d[2*i] + d[2*i+1]; */   int f[100007];   int main () {    vector<pii> v;    int n = 100000;    int ile = n;    FOR(i,2*M) d[i] = 0;    FOR(i,n) d[i+M] = 1;    REPD(i,M-1,1) d[i] = d[2*i] + d[2*i+1];    while (ile > 2) {       int pot2 = 1;       while (pot2 <= ile) pot2 *= 2;       for (pot2 /= 2; pot2 > 0; pot2 /= 2) {          int ktory = kty(pot2);          dodaj(ktory, -1);          ile--;       }       v.pb(mp(1+kty(1), -1));       if (ile >= 2) {          //printf("%d %d\n",tr.find_kth(1),tr.find_kth(2));          v.pb(mp(1+kty(2),1+kty(1)));       }    }        TESTS {       wez(nn)       FORI(i,nn) scanf("%d",f+i);       int pos = 0;       while (pos < SZ(v) && v[pos].fi <= nn) ++pos; --pos;       //DBG(v[pos])       if (nn == 1) {          printf("%d\n",f[1]);       } else if (nn == 2) {          printf("%d %d\n",f[1],f[2]);       } else {          if (v[pos].se == -1) {             printf("%d\n", f[v[pos].fi]);          } else {             printf("%d %d\n", f[v[pos].se], f[v[pos].fi]);          }       }    } }
#include <string> #include <vector> #include <algorithm> #include <cmath> #include <set> #include <queue> #include <map> #include <cstdio> #include <iomanip> #include <sstream> #include <iostream> #include <cstring> #define REP(i,x,v)for(int i=x;i<=v;i++) #define REPD(i,x,v)for(int i=x;i>=v;i--) #define FOR(i,v)for(int i=0;i<v;i++) #define FORE(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++) #define REMIN(x,y) (x)=min((x),(y)) #define REMAX(x,y) (x)=max((x),(y)) #define pb push_back #define sz size() #define mp make_pair #define fi first #define se second #define ll long long #define IN(x,y) ((y).find((x))!=(y).end()) #define un(v) v.erase(unique(ALL(v)),v.end()) #define LOLDBG #ifdef LOLDBG #define DBG(vari) cerr<<#vari<<" = "<<vari<<endl; #define DBG2(v1,v2) cerr<<(v1)<<" - "<<(v2)<<endl; #else #define DBG(vari) #define DBG2(v1,v2) #endif #define CZ(x) scanf("%d",&(x)); #define CZ2(x,y) scanf("%d%d",&(x),&(y)); #define CZ3(x,y,z) scanf("%d%d%d",&(x),&(y),&(z)); #define ALL(x) (x).begin(),(x).end() #define tests int dsdsf;cin>>dsdsf;while(dsdsf--) #define testss int dsdsf;CZ(dsdsf);while(dsdsf--) using namespace std; typedef pair<int,int> pii; typedef vector<int> vi; template<typename T,typename TT> ostream &operator<<(ostream &s,pair<T,TT> t) {return s<<"("<<t.first<<","<<t.second<<")";} template<typename T> ostream &operator<<(ostream &s,vector<T> t){s<<"{";FOR(i,t.size())s<<t[i]<<(i==t.size()-1?"":",");return s<<"}"<<endl; }   #define M (1<<17)   struct ext {     int x;     ext(){x=0;}     inline ext operator+(const ext& A) const     {         ext w;         w.x=x^A.x;         return w;     } };   struct node//node() el neutralny {     int v[4];     node(){v[0]=v[1]=v[2]=v[3]=0;}     inline node operator+(const node& A) const     {         node w;         FOR(i,4) w.v[i]=v[i]+A.v[i];         return w;     }     node extend(ext E)     {         node w;         FOR(i,4) w.v[i]=v[i^E.x];         return w;     } };   node d[2*M]; ext e[2*M]; int A,B; ext V;   node qu(int l,int r,int nr) {     if (A<=l && r<=B) return d[nr];     if (A>r || B<l) return node();     return (qu(l,(l+r)/2,nr*2)+qu((l+r)/2+1,r,nr*2+1)).extend(e[nr]); }   node query(int a,int b) {     A=a;B=b;     return qu(0,M-1,1); }     void md(int l,int r,int nr) {     if (A<=l && r<=B)      {         d[nr]=d[nr].extend(V);         e[nr]=e[nr]+V;         return;     }     if (A>r || B<l) return;     md(l,(l+r)/2,nr*2);md((l+r)/2+1,r,nr*2+1);     d[nr]=(d[nr*2]+d[nr*2+1]).extend(e[nr]); }   void modify(int a,int b,ext val) {     A=a;B=b;V=val;     md(0,M-1,1); }   void czysc() {     FOR(i,2*M) d[i]=node();     FOR(i,2*M) e[i]=ext(); }   void bulk() {     REPD(i,M-1,1) d[i]=(d[i*2]+d[i*2+1]); }       int main() {     ios_base::sync_with_stdio(0);     int n;CZ(n);     czysc();     FOR(i,n)     {         int a;CZ(a);         d[M+i].v[a]=1;     }     bulk();     int q;CZ(q);     node tp;     ext f;     while(q--)     {         int a,b,c;         CZ3(a,b,c);         b--;c--;         if (a==0)         {             tp=query(b,c);             printf("%d %d %d %d\n",tp.v[1],tp.v[3],tp.v[0],tp.v[2]);         }         else         {             f.x=a;             modify(b,c,f);         }     }       return 0; }  
#include<cstdio>  using namespace std;  int n,t,f; int main() {       scanf("%d",&t);       while(t--)       {           scanf("%d%d",&n,&f);           if(n==1)           printf("1\n");           else if(f==2)           printf("-1\n");           else           printf("%d\n",3*n/2);       }         return 0; } 
//By Sainath #include<iostream> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {          int n,k;         cin>>n;         cin>>k;         int a[n+1];         int p[n+1];         int f;         for(int i=1;i<=n;i++)         {             cin>>a[i];         }         for(int i=1;i<=n;i++)         {             cin>>f;             p[f]=i;         }         while(k--)         {             int b[n+1];             for(int i=1;i<=n;i++) b[i]=a[i];             for(int i=1;i<=n;i++) a[i]=b[p[i]];         }         for(int i=1;i<=n;i++)         cout<<a[i]<<" ";         cout<<endl;     } } 
#include<algorithm> #include<iostream> #include<cstdio> using namespace std; #define MOD 1000000007  long long int pow2(int x) {     long long int t = 2;     long long int ans = 1;     while(x!=0)     { 	if(x%2) 	    ans = (ans * t) % MOD; 	t = (t*t) % MOD; 	x /= 2;     }     return ans; }  int main() {      int t,n,k,j;     cin>>t;      int a[200001];     while(t--)     {         cin>>n>>k;         for(int i=0;i<n;i++)             scanf("%d",a+i);         long long int ans=0;         j=0;         sort(a,a+n);          for(int i=0;i<n;i++)         {             for(;j<n&&(a[j]<=a[i]+k);j++);                  ans += pow2(j-i-1);                 ans %= MOD;         }         cout<<ans<<endl;      } } 
#include<stdio.h>  template <class T> struct node { 	T value; 	node* next; };  template <class T> class LL {     public:     LL();     void insert(T k);     void remove(T k);     bool search(T k);     node<T>* head;     node<T>* last; };  template <class T> LL<T>::LL() {     head = last = NULL; }  template <class T> void LL<T>::insert(T k) {     node<T>* temp = new node<T>();     temp->value = k;     temp->next = NULL;     if(head) last = last->next = temp;     else head = last = temp; }  template <class T> void LL<T>::remove(T k) {     node<T>* p = NULL;     node<T>* n = head;     while(n)     {         if(n->value == k)         {             if(n == head)             {                 head = n->next;                 if(!head) last = NULL;             }             else             {                 p->next = n->next;                 if(!(p->next)) last = p;             }             delete n;             return;         }         p = n;         n = n->next;     } }  template <class T> bool LL<T>::search(T k) {     node<T>* temp = head;     while(temp)     {         if(temp->value == k) break;         else temp = temp->next;     }     return (temp != NULL); }  #define _MAX_QUEUE_SIZE_ 1000  template <class T> class queue {     public:     queue();     ~queue();     void push(T n);     T pop();     bool isEmpty();     bool isFull();     private:     T* data;     int size;     int head;     int tail;     int filled; };  template <class T> queue<T>::queue() {     size = _MAX_QUEUE_SIZE_;     data = new T[size];     filled = 0;     tail = 0;     head = 0; }  template <class T> queue<T>::~queue() {     delete[] data; }  template <class T> void queue<T>::push(T n) {     try     {         if(filled != size)         {             data[tail++] = n;             filled++;             if(tail == size) tail = 0;             return;         }         throw -1;     }     catch(int e)     {         printf("Exception: Queue is full\n");     } }  template <class T> T queue<T>::pop() {     try     {         if(filled != 0)         {             T temp = data[head++];             filled--;             if(head == size) head = 0;             return temp;         }         throw -1;     }     catch(int e)     {         printf("Exception: Queue is empty\n");     } }  template <class T> bool queue<T>::isEmpty() {     return (filled==0); }  template <class T> bool queue<T>::isFull() {     return (filled==size); }  class FlowEdge {     public:     FlowEdge();     FlowEdge(FlowEdge& E);     FlowEdge(int x, int y, int c);     FlowEdge(int x, int y, int c, int f);     int From();     int To();     int Capacity();     int Flow();     int Other(int w);     int ResidualCapacityTo(int w);     void AddResidualFlowTo(int w, int delta);     FlowEdge& operator= (FlowEdge& E);     bool operator== (FlowEdge& E);     private:     int u;     int v;     int capacity;     int flow; };  FlowEdge::FlowEdge() {     u = -1;     v = -1;     capacity = 0;     flow = 0; }  FlowEdge::FlowEdge(FlowEdge& E) {     u = E.From();     v = E.To();     capacity = E.Capacity();     flow = E.Flow(); }  FlowEdge::FlowEdge(int x, int y, int c) { 	try 	{ 		if(c >= 0) 		{ 			u = x; 			v = y; 			capacity = c; 			flow = 0; 		} 		else throw 1; 	} 	catch(int e) 	{ 		printf("Exception %d: Negative edge capacity\n",e); 	} }  FlowEdge::FlowEdge(int x, int y, int c, int f) { 	try 	{ 		if(c >= 0) 		{ 			u = x; 			v = y; 			capacity = c; 			flow = f; 		} 		else throw 2; 	} 	catch(int e) 	{ 		printf("Exception %d: Negative edge capacity\n",e); 	} }  int FlowEdge::From() { 	return u; }  int FlowEdge::To() {     return v; }  int FlowEdge::Capacity() {     return capacity; }  int FlowEdge::Flow() {     return flow; }  int FlowEdge::Other(int w) { 	try 	{ 		if(w == u) return v; 		else if(w == v) return u; 		else throw 3; 	} 	catch(int e) 	{ 		printf("Exception %d: Illegal endpoint\n",e); 	} }  int FlowEdge::ResidualCapacityTo(int w) { 	try 	{ 		if(w == u) return flow; 		else if(w == v) return capacity-flow; 		else throw 4; 	} 	catch(int e) 	{ 		printf("Exception %d: Illegal endpoint\n",e); 	} }  void FlowEdge::AddResidualFlowTo(int w, int delta) { 	try 	{ 		if(w == u) flow -= delta; 		else if(w == v) flow += delta; 		else throw 5; 	} 	catch(int e) 	{ 		printf("Exception %d: Illegal endpoint\n",e); 	} }  FlowEdge& FlowEdge::operator= (FlowEdge& E) {     u = E.From();     v = E.To();     capacity = E.Capacity();     flow = E.Flow();     return *this; }  bool FlowEdge::operator== (FlowEdge& E) {     return u == E.From() && v == E.To() && capacity == E.Capacity() && flow == E.Flow(); }  class FlowNetwork {     public:     FlowNetwork();     FlowNetwork(int v);     ~FlowNetwork();     void AddEdge(FlowEdge* E);     int V();     int E();     void DFS(int s, bool* Visited);     int FordFulkerson(int s, int t);     protected: 	bool HasAugmentingPath(FlowEdge** &EdgeTo, int s, int t);     private:     int n;     int m;     LL<FlowEdge*>* Vertices; };  FlowNetwork::FlowNetwork() {     n = m = 0; }  FlowNetwork::FlowNetwork(int v) {     n = v;     m = 0;     Vertices = new LL<FlowEdge*>[n]; }  FlowNetwork::~FlowNetwork() {     delete Vertices; }  void FlowNetwork::AddEdge(FlowEdge* E) {     try     {         int u = E->From();         int v = E->To();         if(u<n && v<n)         {             Vertices[u].insert(E);             Vertices[v].insert(E);             m++;             return;         }         throw 1;     }     catch(int e)     {         printf("Exception %d: Invalid Edge\n",e);     } }  int FlowNetwork::V() {     return n; }  int FlowNetwork::E() {     return m; }  bool FlowNetwork::HasAugmentingPath(FlowEdge** &EdgeTo, int s, int t) { 	queue<int> Q; 	bool* Marked = new bool[n];  	for(int i=0; i<n; ++i) Marked[i] = false;  	Q.push(s); 	Marked[s] = true;  	int u,v; 	FlowEdge* e; 	node<FlowEdge*>* iterator;  	while(!Q.isEmpty()) 	{ 		u = Q.pop(); 		iterator = Vertices[u].head; 		while(iterator != NULL) 		{ 			e = iterator->value; 			v = e->Other(u); 			if(e->ResidualCapacityTo(v) > 0) 			{ 				if(!Marked[v]) 				{ 					Marked[v] = true; 					EdgeTo[v] = e; 					Q.push(v); 				} 			} 			iterator = iterator->next; 		} 	}  	bool result = Marked[t];  	delete[] Marked;  	return result; }  void FlowNetwork::DFS(int s, bool* Visited) { 	Visited[s] = true; 	int v;  	FlowEdge* e; 	node<FlowEdge*>* iterator = Vertices[s].head; 	while(iterator != NULL) 	{ 		e = iterator->value; 		v = e->Other(s); 		if(!Visited[v] && e->ResidualCapacityTo(v) > 0) 		{ 			DFS(v,Visited); 		} 		iterator = iterator->next; 	} }  int FlowNetwork::FordFulkerson(int s, int t) { 	FlowEdge** EdgeTo = new FlowEdge*[n]; 	for(int i=0; i<n; ++i) EdgeTo[i] = NULL;  	FlowEdge* ResidualEdge; 	int u,v; 	int bottleneck;  	while(HasAugmentingPath(EdgeTo,s,t)) 	{ 		v = t; 		ResidualEdge = EdgeTo[v]; 		u = ResidualEdge->Other(v); 		bottleneck = ResidualEdge->ResidualCapacityTo(v);  		while(u != s) 		{ 			v = u; 			ResidualEdge = EdgeTo[v]; 			u = ResidualEdge->Other(v); 			if(ResidualEdge->ResidualCapacityTo(v) < bottleneck) 			{ 				bottleneck = ResidualEdge->ResidualCapacityTo(v); 			} 		}  		v = t; 		ResidualEdge = EdgeTo[v]; 		u = ResidualEdge->Other(v); 		ResidualEdge->AddResidualFlowTo(v,bottleneck);  		while(u != s) 		{ 			v = u; 			ResidualEdge = EdgeTo[v]; 			u = ResidualEdge->Other(v); 			ResidualEdge->AddResidualFlowTo(v,bottleneck); 		} 	}  	delete[] EdgeTo;  	bool* Visited = new bool[n]; 	for(int i=0; i<n; ++i) Visited[i] = false;  	DFS(s,Visited);  	int c = s/2;  	int MinCount = 0;  	for(int i=0; i<c; ++i) 	{ 		if(!Visited[i]) MinCount++; 	}  	for(int i=c; i<s; ++i) 	{ 		if(Visited[i]) MinCount++; 	}  	return MinCount; }  int main() { 	//freopen("input1.txt","r",stdin); 	//freopen("output1.txt","w",stdout);  	const int INFINITY = 10000000;  	int N,T,V;  	scanf("%d",&N);  	// Rows from 0 to N-1, Columns from N to 2*N-1, Source at 2*N, Sink at 2*N+1  	V = 2*N+2;  	FlowNetwork FN(V);  	scanf("%d",&T);  	FlowEdge* F; 	int r,c;  	while(T--) 	{ 		scanf("%d%d",&r,&c); 		F = new FlowEdge(r-1,N+c-1,INFINITY); 		FN.AddEdge(F); 	}  	for(int i=0; i<N; ++i) 	{ 		F = new FlowEdge(2*N,i,1); 		FN.AddEdge(F); 		F = new FlowEdge(N+i,2*N+1,1); 		FN.AddEdge(F); 	}  	printf("%d\n",FN.FordFulkerson(2*N,2*N+1));  	return 0; } 
    #include<iostream>     using namespace std;     int main()     {     int t;     long long int n,i;     cin>>t;     while(t--)     {     cin>>n;     long long int a[n+1];     char s[n+1];     cin>>s;     for(i=1;i<=n;i++)     cin>>a[i];     for(i=1;i<=n;i++)     {         if(i!=a[i])        {          char temp=s[i-1];          s[i-1]=s[a[i]-1];          s[a[i]-1]=temp;        }     }        cout<<s<<endl;     }     return 0;     } 
#include<iostream> #include<algorithm> #include<stdio.h> using namespace std;  #define GETCHAR getchar_unlocked inline long long int readInt() { int flag=1; long long int n = 0; char c; while (1) { c=GETCHAR(); if(c>='0'&&c<='9') {n = n * 10 + c - '0';flag=0;} else if(flag!=1) break; } return n; }  long long int n,k; long long int arr[100010]; int solve(long long int n,long long int k){ 	//cout<<"hey"; 	int ans=0; 	sort(arr,arr+n); 	if(arr[1]==0) 	return -1; 	if(arr[n-1]==1 && arr[n-1]<=k) 	return -1; 	if(arr[n-2]==0 &&arr[n-1]<=k) 	return -1; 	if(arr[n-1]>k){ 		for(int i=1;i<n-1;i++) 		{ 			if(arr[i]<=k) 			ans++; 		} 	} 	else { 		long long int maxi=arr[n-1]; 		long long int secondmax=arr[n-2]; 		while(maxi<=k){ 			long long int temp=maxi*secondmax; 			secondmax=maxi; 			maxi=temp; 			ans++; 			//cout<<maxi<<"\n"; 		} 		arr[n-1]=maxi; 		arr[n-2]=secondmax; 		for(int i=1;i<n;i++){ 			if(arr[i]<=k) 			ans++; 		} 	} 	return ans; } int main(){ 	long long int t; 	t=readInt(); 	while(t--){ 		long long int n,k; 		n=readInt(); 		k=readInt(); 		for(int i=0;i<n;i++) 		arr[i]=readInt(); 		printf("%d\n",solve(n,k)); 	} }
#include<bits/stdc++.h> #define block 150 using namespace std; typedef long long ll; ll bit[20011]={0}; ll arr[20011]; vector<pair<pair<ll,ll> ,ll > >v; bool cmp(pair<pair<ll,ll> ,ll> a,pair<pair<ll,ll> ,ll> b) { 	if(a.first.first/block==b.first.first/block) 	{ 		return ((a.first.second/block)<(b.first.second/block)); 	} 	else 	{ 		return ((a.first.first/block)<(b.first.first/block)); 	} } void update(ll ind,ll val) { 	 	while(ind<20011) 	{ 		bit[ind]+=val; 		ind+=(ind&(-ind)); 	} } ll get(ll ind) { 	ll sum=0; 	while(ind) 	{ 		sum+=bit[ind]; 		ind-=(ind&(-ind)); 	} 	return sum; } int main() { 	ll n,i; 	scanf("%lld",&n); 	map<ll,ll>mm; 	mm.clear(); 	ll co=1; 	for(i=0;i<n;i++) 	{ 		scanf("%lld",&arr[i]); 		if(mm.find(arr[i])==mm.end()) 		{ 			mm[arr[i]]=1; 		} 	} 	map<ll,ll>::iterator it; 	for(it=mm.begin();it!=mm.end();it++) 	{ 		it->second = co++; 	} 	for(i=0;i<n;i++) 	{ 		arr[i]=mm[arr[i]]; 	} 	ll q,a,b; 	scanf("%lld",&q); 	ll kk=q; 	i=0; 	while(q--) 	{ 		 		scanf("%lld%lld",&a,&b); 		a--; 		b--; 		v.push_back(make_pair(make_pair(a,b),i)); 		i++; 	} 	q=kk; 	ll l=0; 	ll r=0; 	ll ans=0; 	sort(v.begin(),v.end(),cmp); 	vector<ll>anss; 	anss.clear(); 	for(i=0;i<q;i++) 	{ 		anss.push_back(0); 	} 	 	for(i=0;i<q;i++) 	{ 		//cout<<"ll"<<endl; 		 		a=v[i].first.first; 		b=v[i].first.second; 		//cout<<l<<" "<<r<<endl; 		while(l<a) 		{ 			ans-=get(arr[l]-1); 			update(arr[l],-1); 			l++; 		} 		while(l>a) 		{ 			ans+=get(arr[l-1]-1); 			update(arr[l-1],1); 			l--; 		} 		while(r<=b) 		{ 			ans+=get(20010)-get(arr[r]); 			update(arr[r],1); 			r++; 		} 		while(r>b+1) 		{ 			ans-=get(20010)-get(arr[r-1]); 			update(arr[r-1],-1); 			r--; 		} 		anss[v[i].second]=ans; 	//	cout<<ans<<endl; 	} 	for(i=0;i<q;i++) 	{ 		cout<<anss[i]<<endl; 	} }
#include <bits/stdc++.h> using namespace std; #define MAX 123456 #define MOD 1000000007 typedef unsigned long long LL;  vector<LL> v[MAX]; LL arr[MAX]; bool vis[MAX]; LL ans[MAX]; LL fin = 0;  bool dfs(LL idx){     vis[idx] = true;     LL res1 = 0, res2 = 1;     bool f1 = false;      for(size_t i = 0; i < v[idx].size(); ++i){         LL x = v[idx][i];         if (vis[x]) continue;          bool flag = dfs(x);         f1 |= flag;          LL rep = ans[x];         if (flag) {             res2 = ((res2%MOD) * (rep%MOD))%MOD;         }         else {             LL tmp1 = ((res1%MOD) + (rep%MOD))%MOD;              LL tmp2 = ((res1%MOD) * (rep%MOD))%MOD;             res1 = (tmp1 + tmp2)%MOD;         }     }      LL tmp1 = ((res1%MOD) * (res2%MOD))%MOD;     LL res = ((res2%MOD) + (tmp1%MOD))%MOD;     ans[idx] = res;      fin = (fin + ans[idx])%MOD;     f1 |= (arr[idx] == 1);     vis[idx] = false;     return f1; }  void solve(){     LL n,a,b,m;     memset(arr,0,sizeof(arr));     memset(ans,0,sizeof(ans));     memset(vis,false,sizeof(vis));     fin = 0;     cin >> n;      for(LL i = 0; i <= n; ++i) v[i].clear();     for(LL i = 0; i < n-1; ++i){         cin >> a >> b;         v[a].push_back(b);         v[b].push_back(a);     }     cin >> m;     if (m == 0){         dfs(1);         cout << fin << endl;     }     else {         LL mn = LLONG_MAX;         for(LL i = 0; i < m; ++i)             cin >> a, arr[a] = 1, mn = min(mn,a);         dfs(mn);         cout << ans[mn] << endl;     } }  int main() {     ios_base::sync_with_stdio(0);     LL t;     cin >> t;     while(t--){ solve(); }     return 0; } 
#include<stdio.h> #include<vector> using std::vector;  struct node {     int value[10];     int lazy; };  int GetSize(int n) {     int count = 1;     while(n)     {        n >>= 1;        count++;     }     count = 1<<count;     return count; }  void Init(vector<node>& segment, int index, vector<int>& A, int a, int b) {     if(a > b) return;     segment[index].lazy = 0;     if(a == b)     {         for(int i=0; i<10; ++i) segment[index].value[i] = 0;         segment[index].value[A[a]] = 1;         return;     }     int mid = a + (b-a)/2;     Init(segment, 2*index, A, a, mid);     Init(segment, 2*index+1, A, mid+1, b);     for(int i=0; i<10; ++i) segment[index].value[i] = segment[2*index].value[i] + segment[2*index+1].value[i]; }  void BuildTree(vector<node>& segment, vector<int>& A) {     int n = A.size();     int count = GetSize(n);     segment.resize(count);     Init(segment, 1, A, 0, n-1); }  void LazyUpdate(vector<node>& segment, int index, int left, int right, int a, int b, int v) {     if(segment[index].lazy)     {         int C = segment[index].lazy;         int temp[10];         for(int i=0; i<10; ++i) temp[i] = segment[index].value[i];         for(int i=0; i<10; ++i) segment[index].value[(i+C)%10] = temp[i];         if(left < right)         {             segment[2*index].lazy += segment[index].lazy;             segment[2*index+1].lazy += segment[index].lazy;         }         segment[index].lazy = 0;     }     if(left > right || a > right || b < left) return;     if(a <= left && b >= right)     {         int temp[10];         for(int i=0; i<10; ++i) temp[i] = segment[index].value[i];         for(int i=0; i<10; ++i) segment[index].value[(i+v)%10] = temp[i];         if(left < right)         {             segment[2*index].lazy += v;             segment[2*index+1].lazy += v;         }         return;     }     int mid = left + (right-left)/2;     LazyUpdate(segment, 2*index, left, mid, a, b, v);     LazyUpdate(segment, 2*index+1, mid+1, right, a, b, v);     for(int i=0; i<10; ++i) segment[index].value[i] = segment[2*index].value[i] + segment[2*index+1].value[i]; }  int primes[] = {2,3,5,7};  int LazyQuery(vector<node>& segment, int index, int left, int right, int a, int b) {     if(left > right || a > right || b < left) return 0;     if(segment[index].lazy)     {         int C = segment[index].lazy;         int temp[10];         for(int i=0; i<10; ++i) temp[i] = segment[index].value[i];         for(int i=0; i<10; ++i) segment[index].value[(i+C)%10] = temp[i];         if(left < right)         {             segment[2*index].lazy += segment[index].lazy;             segment[2*index+1].lazy += segment[index].lazy;         }         segment[index].lazy = 0;     }     if(a <= left && b >= right)     {         int ans = 0;         for(int i=0; i<4; ++i) ans += segment[index].value[primes[i]];         return ans;     }     int mid = left + (right-left)/2;     return LazyQuery(segment, 2*index, left, mid, a, b) + LazyQuery(segment, 2*index+1, mid+1, right, a, b); }  const int MaxN = 100000+5; int N; vector<int> AdjList[MaxN]; int subtree[MaxN]; int parent[MaxN]; int depth[MaxN]; vector<int> chains[MaxN]; int chainID[MaxN]; int position[MaxN]; int firstv[MaxN]; int size[MaxN]; int cost[MaxN]; bool explored[MaxN]; vector<node> segment[MaxN]; int cid;  void DFS(int v, int d) {     subtree[v] = 1;     depth[v] = d;     for(vector<int>::iterator it=AdjList[v].begin(); it != AdjList[v].end(); ++it)     {         int o = *it;         if(parent[o] == -1)         {             parent[o] = v;                         DFS(o,d+1);             subtree[v] += subtree[o];         }     } }  void FloodFill(int v, int id) {     position[v] = chains[id].size();     chains[id].push_back(v);     firstv[v] = chains[id][0];     chainID[v] = id;     explored[v] = true;     for(vector<int>::iterator it=AdjList[v].begin(); it != AdjList[v].end(); ++it)     {         int o = *it;         if(parent[o] == v && 2*subtree[o] >= subtree[v])         {             FloodFill(o, id);             break;         }     }     size[v] = chains[id].size(); }  void HeavyLightDecomposition() {     for(int i=1; i<=N; ++i) parent[i] = -1;     parent[1] = 0;     DFS(1, 0);     parent[1] = -1;     for(int i=1; i<=N; ++i) explored[i] = false;     cid = 0;     for(int i=1; i<=N; ++i)     {         if(!explored[i] && ((i == 1) || (2*subtree[i] < subtree[parent[i]])))         {             FloodFill(i, cid);             cid++;         }     }     for(int i=0; i<cid; ++i)     {         vector<int> A;         for(int j=0; j<chains[i].size(); ++j) A.push_back(cost[chains[i][j]]);         BuildTree(segment[i], A);     } }  int LCA(int a, int b) {     while(chainID[a] != chainID[b])     {         if(depth[firstv[a]] > depth[firstv[b]]) a = parent[firstv[a]];         else b = parent[firstv[b]];     }     return (depth[a] <= depth[b]) ? a : b; }  int Dist(int lca, int a) {     int ans = 0;     while(chainID[a] != chainID[lca])     {         ans += LazyQuery(segment[chainID[a]], 1, 0, size[a]-1, 0, position[a]);         a = parent[firstv[a]];     }     ans += LazyQuery(segment[chainID[lca]], 1, 0, size[lca]-1, position[lca], position[a]);     return ans; }  int Query(int A, int B) {     int lca = LCA(A,B);     return Dist(lca, A) + Dist(lca, B) - LazyQuery(segment[chainID[lca]], 1, 0, size[lca]-1, position[lca], position[lca]); }  void Change(int lca, int a, int C) {     while(chainID[a] != chainID[lca])     {         LazyUpdate(segment[chainID[a]], 1, 0, size[a]-1, 0, position[a], C);         a = parent[firstv[a]];     }     LazyUpdate(segment[chainID[lca]], 1, 0, size[lca]-1, position[lca], position[a], C); }  void Update(int A, int B, int C) {     int lca = LCA(A,B);     Change(lca, A, C);     Change(lca, B, C);     LazyUpdate(segment[chainID[lca]], 1, 0, size[lca]-1, position[lca], position[lca], 10 - C); }  int main() {     //freopen("test.txt","r",stdin);     //freopen("output.txt","w",stdout);     int u,v,T,A,B,C;     int str;     scanf("%d",&N);     for(int i=1; i<=N; ++i) scanf("%d",&cost[i]);     for(int i=1; i<N; ++i)     {         scanf("%d%d",&u,&v);         AdjList[u].push_back(v);         AdjList[v].push_back(u);     }     HeavyLightDecomposition();     scanf("%d",&T);     while(T--)     {         scanf("%d%d%d",&str,&A,&B);         if(str == 0) printf("%d\n", Query(A,B));         else         {             scanf("%d",&C);             Update(A,B,C%10);         }     }     return 0; } 
#include<bits/stdc++.h>  // Isme kya hai ;)  using namespace std;  #define TRACE  #ifdef TRACE     #define trace1(x)                cerr << #x << ": " << x << endl;     #define trace2(x, y)             cerr << #x << ": " << x << " | " << #y << ": " << y << endl;     #define trace3(x, y, z)          cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl;     #define trace4(a, b, c, d)       cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << endl;     #define trace5(a, b, c, d, e)    cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << endl;     #define trace6(a, b, c, d, e, f) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << " | " << #f << ": " << f << endl;  #else      #define trace1(x)     #define trace2(x, y)     #define trace3(x, y, z)     #define trace4(a, b, c, d)     #define trace5(a, b, c, d, e)     #define trace6(a, b, c, d, e, f)  #endif  #define ull unsigned long long #define ll long long #define Max(x,y) ((x)>(y)?(x):(y)) #define Min(x,y) ((x)<(y)?(x):(y)) #define Sl(x) scanf("%lld",&x) #define Su(x) scanf("%llu",&x) #define all(v) v.begin(),v.end() #define allr(v) v.rbegin(),v.rend() #define S(x) scanf("%d",&x) #define I(x) cin>>x #define IS(x) getline(cin,x) #define pii pair<int,int> #define pll pair<ll,ll> #define mii map<int,int> #define pps pair<ll,pll> #define ppi pair<pii,int> #define ppf pair<pll,ll> #define psi pair<string,int> #define pis pair<int,string> #define fr first #define se second #define p(x) cout<<(x) #define MOD 1000000007 #define eps 1e-7 #define V(x) vector<x> #define pb(x) push_back(x) #define mem(x,i) memset(x,i,sizeof(x)) #define fori(i,s,n) for(int i=(s);i<(n);i++) #define ford(i,s,n) for(int i=(n)-1;i>=(s);--i) #define INF 8944674407370955161LL #define debug(i,st,arr) fori(i,0,st){cout<<arr[i]<<" ";}cout<<endl; #define forci(i,sw) for((i)=(sw).begin();(i)!=(sw).end();(i)++) #define forcd(i,sw) for((i)=(sw).rbegin();(i)!=(sw).rend();(i)++)  int abs(int x) {if(x < 0) return -x; return x;}  int addmod(int v1, int v2) {     int v3 = v1+v2;     if(v3 >= MOD) v3 -= MOD;     return v3; }  int cc[201][201]; int a[13]; int dp[12][1000005]; int ar[20];  void pre() {     ar[0] = 1;      fori(i,1,13) {         ar[i] = 3*ar[i-1];     } }  int bit(int mask, int pos) {     return (mask/ar[pos])%3; }  int f(vector<int> v1, vector<int> v2) {     int ans = 0;     fori(i,0,v1.size()) {         fori(j,0,v2.size()) {             ans += cc[v1[i]][v2[j]];         }     }     return ans; }  int solve(int pos, int mask, int k) {     if(pos == k) {         V(int) v1, v2;         fori(i,0,k) {             if(bit(mask,i) == 1) {                 v1.pb(a[i]);             }             else {                 v2.pb(a[i]);             }         }         return f(v1,v2);     }     if(dp[pos][mask] != -1) return dp[pos][mask];     int ans;     if(pos%2 == 0) {         ans = 0;         fori(i,0,k) {             if(bit(mask,i) == 0) {                 ans = max(ans, solve(pos+1, mask+2*ar[i], k));             }         }     }     else {         ans = 10000000;         fori(i,0,k) {             if(bit(mask,i) == 0) {                 ans = min(ans, solve(pos+1, mask+ar[i], k));             }         }     }     return dp[pos][mask] = ans; }  int main() { //    freopen("input.in", "r", stdin); //    freopen("output.in", "w", stdout);     int n, m, k;     S(n), S(m), S(k);     pre();     mem(dp, -1);     int x, y, z;     fori(i,0,n) fori(j,0,n) cc[i][j] = 99999999;     fori(i,0,m) {         S(x), S(y), S(z);         x--, y--;         cc[x][y] = cc[y][x] = z;     }     fori(i,0,k) S(a[i]), a[i]--;     fori(k,0,n) fori(i,0,n) fori(j,0,n) cc[i][j] = min(cc[i][j], cc[i][k] + cc[k][j]);      p(solve(0, 0, k)), p(endl);     return 0; }  
#include<stdio.h> main() { 	char s[100001],a; 	int  an[123]={0},i,count,max,ans; 	scanf("%s",s); 	i=0; 	while(s[i]!='\0') 	{a=s[i],count=0; 		while(s[i]==a){ 			count++; 			i++; 		} 		if(count>an[a]) 		an[a]=count; 	}max=-1; 	for(i=97;i<=122;i++) 	if(an[i]>max) 	max=an[i],ans=i; 	printf("%c\n%d",ans,max); 	 }
#include <iostream> #include <cstring> #include <cmath> #include <cstdio> #include <climits> #include <ctime> #include <cassert> #include <cctype> #include <algorithm> #include <numeric> #include <map> #include <set> #include <queue> #include <string> #include <vector> #include <bitset>  #define MN 100005 #define MX 35 #define X first #define Y second #define pb push_back #define bit(x) (1LL << (x)) #define bnum(x) (__builtin_popcount(x)) #define sqr(x) ((x) * (x)) #define sz(x) ((int)(x.size())) #define PQ priority_queue  using namespace std; typedef long long LL; typedef double DB; typedef pair<LL, LL> pLL; typedef vector<int> vi;  template <class T> inline void chkmin(T &a, T b) { 	if (b < a) a = b; } template <class T> inline void chkmax(T &a, T b) { 	if (a < b) a = b; }  vi con[MN]; LL M; int n, m, K, X; LL a[MN]; int mrk[MN]; int pw[MX]; LL pwc[MX];  void input() { 	int i, u, v;  	scanf("%d%d%d", &n, &m, &K); 	for (i = 0; i < m; i++) { 		scanf("%d%d", &u, &v); 		u--, v--; 		con[u].pb(v); 		con[v].pb(u); 	} 	for (i = 0; i < n; i++) scanf("%lld", a + i); 	for (i = 0; i < K; i++) { 		scanf("%d", pw + i); 		pw[i]--; 		mrk[pw[i]] = i + 1; 	} 	for (i = 0; i < K; i++) scanf("%lld", pwc + i);  	scanf("%d%lld", &X, &M); 	for (i = 0; i < X; i++) { 		scanf("%d", &u); 		M += pwc[u - 1]; 	} }  int q[MN * 2], chk[MN]; pLL p[MX]; int pn;  bool cmp(const pLL &a, const pLL &b) { 	return 1.0 * a.X / a.Y > 1.0 * b.X / b.Y; }  LL sum[MX], sumc[MX]; void prepare() { 	LL cst, tot; 	int i, j, u, v; 	int st, en, flg;  	for (i = 0; i < n; i++) if (!chk[i]) { 		flg = st = en = 0; 		tot = 0; 		q[en++] = i; 		chk[i] = 1;  		while (st < en) { 			u = q[st++]; 			tot += a[u]; 			if (mrk[u] > 0) { 				if (flg == 0) flg = 1, cst = pwc[mrk[u] - 1]; 				else chkmin(cst, pwc[mrk[u] - 1]); 			}  			for (j = 0; j < sz(con[u]); j++) { 				v = con[u][j]; 				if (chk[v]) continue; 				chk[v] = 1, q[en++] = v; 			} 		}  		if (!flg) continue; 		if (cst <= M) p[pn++] = pLL(tot, cst); 	} }  LL rlt; void solve(int k, LL cst, LL mm) { 	/*if (sumc[k] <= cst) { 		chkmax(rlt, mm + sum[k]); 		return; 	}*/  	if(k == K+1){ 	    chkmax(rlt, mm ); 	    return ; 	}  	chkmax(rlt, mm); 	if (mm + sum[k] <= rlt) return; 	if (mm + 1.0 * p[k].X / p[k].Y * cst <= rlt) return; 	if (k == pn) return; 	if (cst >= p[k].Y) { 		solve(k + 1, cst - p[k].Y, mm + p[k].X); 	} 	solve(k + 1, cst, mm); }  int main() { //	freopen("in.txt", "r", stdin); //	freopen("out.txt", "w", stdout);  	int i; 	input(); 	prepare(); 	assert(pn <= 31);  	sort(p, p + pn, cmp); 	for (i = pn - 1; i >= 0; i--) { 		sum[i] = sum[i + 1] + p[i].X; 		sumc[i] = sumc[i + 1] + p[i].Y; 	}  	solve(0, M, 0);  	cout << rlt << endl; 	return 0; } 
#include <bits/stdc++.h> using namespace std; int E[600][600],T[600][600],R[600][600],par[700],vis[700]; int num; int bfsAugment(int a,int sink) {     queue<int>Q;     int i;     Q.push(a);     for(i=0;i<num;i++)         vis[i]=0;     int flow=INT_MAX;     bool flag=false;     vis[a]=1;     par[a]=-1;     while(!(Q.empty()))     {         a=Q.front();         Q.pop();         for(i=1;i<num;i++)         {             if(i==a)                 continue;             else             {                 if(E[a][i]>0&&vis[i]==0)                 {                     vis[i]=1;                     Q.push(i);                     par[i]=a;                      if(i==sink)                     {                         flag=true;                         break;                     }                 }              }         }         if(flag)             break;     }     if(flag==false)     {         return 0;     }     a=sink;     while(par[a]!=-1)     {         flow=min(flow,E[par[a]][a]);         a=par[a];     }     a=sink;     while(par[a]!=-1)     {         E[par[a]][a]-=flow;         E[a][par[a]]+=flow;         a=par[a];     }    // cout<<"Returning";     return flow; } int maxflow(int source,int sink) {     int a,ans=0;     while(1)     {         a=bfsAugment(source,sink);      //   cout<<a<<" Flow"<<endl;         if(a<=0)         {             return ans;         }         else         {             ans=ans+a;         }     } } int main() {     int n,m,a,b,c,t,i,j,ans;         scanf("%d %d",&n,&m);         memset(E,0,sizeof(E));         for(i=0;i<m;i++)         {              scanf("%d %d %d",&a,&b,&c);             E[a][b]=c;         }         num=n+1;         for(i=1;i<=n;i++)         {              for(j=1;j<=n;j++)             {                 if(E[i][j]!=0&&E[j][i]!=0)                 {                     E[i][num]=E[i][j];                     E[num][j]=E[i][j];                     E[i][j]=0;                     num++;                 }             }         }         for(i=1;i<num;i++)         {              for(j=1;j<num;j++)             {                T[i][j]=E[i][j];             }         }         scanf("%d",&t);         while(t>0)         {             t--;             scanf("%d %d",&a,&b);             ans=maxflow(a,b);             printf("%d\n",ans);             for(i=1;i<num;i++)             {                  for(j=1;j<num;j++)                 {                     E[i][j]=T[i][j];                 }             }         } } 
#include<stdio.h> #define max(a, b) (((a) >= (b)) ? (a) : (b)) int main(){ 	int t, n, no, m; scanf("%d", &t); 	while(t-- && scanf("%d", &n)){ 		m = 1; 		while(n-- && scanf("%d", &no))	m = max(m, no); 		printf("%d\n", m); 	}		 	return 0; }
#include<stdio.h> #include<iostream>  using namespace std; int main() { 	int a,b,c,d,e,f;  	cin>>a>>b>>c>>d>>e>>f;  	if(((a+b)==(d+e))&&((a+f)==(c+d))) 	{ 		cout<<"Losing"<<endl; 	}  	else 	{ 		cout<<"Winning"<<endl; 	} } 
#include<bits/stdc++.h>  // Isme kya hai ;)  using namespace std;  #define TRACE  #ifdef TRACE     #define trace1(x)                cerr << #x << ": " << x << endl;     #define trace2(x, y)             cerr << #x << ": " << x << " | " << #y << ": " << y << endl;     #define trace3(x, y, z)          cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl;     #define trace4(a, b, c, d)       cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << endl;     #define trace5(a, b, c, d, e)    cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << endl;     #define trace6(a, b, c, d, e, f) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << " | " << #f << ": " << f << endl;  #else      #define trace1(x)     #define trace2(x, y)     #define trace3(x, y, z)     #define trace4(a, b, c, d)     #define trace5(a, b, c, d, e)     #define trace6(a, b, c, d, e, f)  #endif  #define ull unsigned long long #define ll long long #define Max(x,y) ((x)>(y)?(x):(y)) #define Min(x,y) ((x)<(y)?(x):(y)) #define Sl(x) scanf("%lld",&x) #define Su(x) scanf("%llu",&x) #define all(v) v.begin(),v.end() #define allr(v) v.rbegin(),v.rend() #define S(x) scanf("%d",&x) #define I(x) cin>>x #define IS(x) getline(cin,x) #define pii pair<int,int> #define pll pair<ll,ll> #define mii map<int,int> #define pps pair<ll,pll> #define ppi pair<pii,int> #define ppf pair<pll,ll> #define psi pair<string,int> #define pis pair<int,string> #define fr first #define se second #define p(x) cout<<(x) #define MOD 1000000007 #define eps 1e-7 #define V(x) vector<x> #define pb(x) push_back(x) #define mem(x,i) memset(x,i,sizeof(x)) #define fori(i,s,n) for(int i=(s);i<(n);i++) #define ford(i,s,n) for(int i=(n)-1;i>=(s);--i) #define INF 8944674407370955161LL #define debug(i,st,arr) fori(i,0,st){cout<<arr[i]<<" ";}cout<<endl; #define forci(i,sw) for((i)=(sw).begin();(i)!=(sw).end();(i)++) #define forcd(i,sw) for((i)=(sw).rbegin();(i)!=(sw).rend();(i)++)  int abs(int x) {if(x < 0) return -x; return x;}  int addmod(int v1, int v2) {     int v3 = v1+v2;     if(v3 >= MOD) v3 -= MOD;     return v3; }  int cc[100]; ll x, n, m;  ll mul(ll a, ll b) {     ll mod = n;    a %= n;    b %= n;    long double res = a;    res *= b;    ll c = (ll)(res / mod);    a *= b;    a -= c * mod;    a %= mod;    if (a < 0) a += mod;    return a; }  ll pow(ll p1, ll p2) {     if(p2 == 0) return 1;     if(p2 % 2 == 0) {         ll tmp = pow(p1, p2/2);         return mul(tmp, tmp);     }     else {         return (mul(p1,pow(p1,p2-1)));     } }  ll solve(ll p1, ll p2) {     if(p2 == 0) return 1;     if(p2 % 2 == 0) {         ll tmp = (pow(p1,p2) + solve(p1,p2-1));         if(tmp >= n) tmp %= n;         return tmp;     }     else {         ll tmp = pow(p1,p2/2 + 1);         ll tmp2 = solve(p1, p2/2);         tmp2 += mul(tmp, tmp2);         if(tmp2 >= n) tmp2 %= n;         return tmp2;     } }  int main() { //    freopen("input.in", "r", stdin); //    freopen("output.in", "w", stdout);     int t;      S(t);     while(t--) {         Sl(x), Sl(m), Sl(n);         printf("%lld\n", (solve(x,m)));     }      return 0; }  
#include <bits/stdc++.h> using namespace std;  typedef long long ll; typedef unsigned long long ull; typedef vector<int> vi; typedef vector<ll> vll; typedef vector<vi> vvi; typedef pair<int,int> pii; typedef vector<pii > vii; typedef vector<pair<int, pair<int, int> > > viii; typedef pair<ll,ll> pll; typedef vector<string> vs; typedef vector<vii> vvii;  #define pb push_back #define mp make_pair #define X first #define Y second #define MEM(a,b) memset(a,(b),sizeof(a)) #define pr(a) cout<<#a<<" = "<<(a)<<endl #define sz(a) int((a).size()) #define all(a) a.begin(),a.end() #define loop(x,a,b) for(int (x) = (a);(x)<(b);(x)++) #define rep(x,n)   for(int (x)=0;(x)<(n);(x)++) #define tr(c,it) for(typeof((c).begin()) it = (c).begin(); it != (c).end(); it++) #define prc(a) tr(a, it) cout<<*(it)<<" "; cout<<endl #define pra(a,n) for(int i=0; i<(n); i++) cout<<((a)[i])<<" "; cout<<"\n" #define prdd(a,r,c) for(int i=0;i<(r);i++) { for(int j = 0;j<(c);j++) cout<<a[i][j]<<" "; cout<<endl; } cout<<endl;  #define present(c,x) ((c).find(x) != (c).end())  #define cpresent(c,x) (find(all(c),x) != (c).end()) #define ain(a,n) int ((a)[(n)]); for(int i=0; i<(n); i++) cin>>((a)[i])   #define md 30000000007 double miss[1500000],hit[1500000];  ll min(ll a,ll b) {   if(a<b)     return a;   return b; }  int main() {        ios::sync_with_stdio(false);     ll n,t,r;     double p;     cin>>n>>p>>t>>r;               rep(i,1500000)       hit[i] = 0,miss[i] = 0;     hit[1] = (1.0);     miss[1] = 0;      loop(i,1,1500000)     {        if(i - t >=  0)       {         double tmp = (1.0)/pow(i,p);         hit[i] += miss[i-t]*tmp;         miss[i] += miss[i-t] *(1-tmp);       }        if(i - t - r >= 0)       {         double tmp = (1.0)/pow(i,p);         hit[i] += hit[i-t-r]*tmp;         miss[i] += hit[i-t-r] *(1-tmp);       }       if(i == n)         break;     }     double ans = 0;     rep(i,min(n+1,1500000))       ans += hit[i];    printf("%.9lf",ans);      return 0; }  
#include <bits/stdc++.h> using namespace std;  // uzumaki naruto #define TRACE  #ifdef TRACE #define dbgarr(a,n)   cerr << "["; for(int i = 0; i < n; ++i) cerr << a[i] << " ";cerr << "\b]\n"; #define dbg(args...)  {debug,args; cerr<<endl;} #define pause()       cin.get();cin.get();  #else #define dbgarr(a,n) #define dbg(args...) #define pause() #endif  struct debugger {     template<typename T> debugger& operator , (const T& v) {         cerr<<v<<" "; return *this;     } } debug;  template <typename T1, typename T2> inline ostream& operator << (ostream& os, const pair<T1, T2>& p) {     return os << "(" << p.first << ", " << p.second << ")"; }  template<typename T> inline ostream &operator << (ostream & os,const vector<T>& v) {     bool first = true; os << "[";     for (typename vector<T>::const_iterator ii = v.begin(); ii != v.end(); ++ii) {         if(!first) os << ", ";         os << *ii; first = false;     }     return os << "]"; }  #define fr first #define se second #define pb push_back  typedef long long LL; typedef pair<int,int> pii; typedef vector<int> vi;  const LL mod = 1000000007LL; int n,m,x,y;  LL dp1[1005][1005][2]; bool vis1[1005][1005][2];  LL f1(int x,int cnt,int f){     if (cnt == y) return 0;     if (x == m) return 1;     if (vis1[x][cnt][f]) return dp1[x][cnt][f];     vis1[x][cnt][f] = true;      LL ans = 0;     for(int k = 0; k < 2; ++k){         int add = (k == f ? cnt : 0) + 1;         ans = (ans + f1(x+1,add,k))%mod;     }     dp1[x][cnt][f] = ans;     return ans; }  LL fast_pow(LL a,LL b){     LL ans = 1LL;     while(b > 0){         if (b & 1) ans = (ans * a)%mod;         a = (a * a)%mod;         b >>= 1;     }     return ans; }  const int mm2 = (1 << 7); LL dp2[mm2][mm2],tmp[mm2][mm2]; LL con[mm2][mm2];  LL valid(int mask1,int mask2){     for(int i = 0,k; i+y-1 < m; ++i){         for(int co = 0; co < 2; ++co){             for(k = i; k < m; ++k){                 int tx = (mask1 >> k) & 1;                 int ty = (mask2 >> k) & 1;                 if (tx != co or ty != co) break;             }             if (k-i >= y)                 return 0LL;         }     }     return 1LL; }  void mul(LL A[][mm2],LL B[][mm2]){     int sz = (1 << m);     for(int i = 0; i < sz; ++i){         for(int j = 0; j < sz; ++j){             tmp[i][j] = 0;             for(int k = 0; k < sz; ++k)                 tmp[i][j] = (tmp[i][j] + A[i][k]*B[k][j])%mod;         }     }      for(int i = 0; i < sz; ++i){         for(int j = 0; j < sz; ++j)             A[i][j] = tmp[i][j];     } }  void ident(LL A[][mm2]){     int sz = (1 << m);     for(int i = 0; i < sz; ++i){         for(int j = 0; j < sz; ++j)             A[i][j] = (i == j);     } }  void mat_power(int nn){     if (nn == 0){         ident(dp2);         return;     }      mat_power(nn/2);     mul(dp2,dp2);     if (nn&1) mul(dp2,con); }  bool pp[12][64][64]; long long cal[12][64][64];  bool check(int mask1,int mask2,int mask3){     int k;     for(int i = 0; i < m; ++i){         for(int co = 0; co < 2; ++co){             for(k = i; k < m; ++k){                 int t1 = (mask1 >> k) & 1;                 int t2 = (mask2 >> k) & 1;                 int t3 = (mask3 >> k) & 1;                 if (t1 != co) break;                 if (t2 != co) break;                 if (t3 != co) break;             }             if (k-i >= y) return false;         }     }     return true; }  long long f(int idx, int mask1, int mask2) {      if ( idx == n ) return 1;      if ( pp[idx][mask1][mask2] ) return cal[idx][mask1][mask2];      pp[idx][mask1][mask2] = true;      long long ans = 0;      for ( int i = 0; i < (1<<m); i++ ) {          if ( check(mask1,mask2,i) ) {             ans = (ans + f(idx+1, mask2, i))%mod;          }      }      cal[idx][mask1][mask2] = ans;      return ans; }  void get() {     long long ans;     if ( n == 1 ) {          ans = 1<<m;          ans %= mod;     }     else {         ans = 0;         for ( int i = 0; i < (1<<m); i++ ) {           for ( int j = 0; j < (1<<m); j++ ) {               ans = (ans + f(2,i,j))%mod;             }         }     }     cout << ans << endl; }  void solve(){     cin >> n >> m >> x >> y;     if (x == 1){         LL ans = f1(0,0,0);         ans = fast_pow(ans,n);         cout << ans << endl;     }      if (x == 2){         for(int i = 0; i < (1 << m); ++i){             for(int j = 0; j < (1 << m); ++j){                 con[i][j] = valid(i,j);             }         }          mat_power(n-1);         LL ans = 0;         for(int i = 0; i < (1 << m); ++i){             for(int j = 0; j < (1 << m); ++j)                 ans = (ans + dp2[i][j])%mod;         }         cout << ans << endl;     }     if ( x == 3 ) {     	get();     } }  int main() {     ios_base::sync_with_stdio(0);     solve();     return 0; } 
#include<stdio.h> #include<iostream> #include<vector> #define get getchar_unlocked using namespace std; typedef struct _node{ 	int val; 	int idx; }node;  typedef struct elements{ 	node n; 	node parent; 	int zeros; 	vector<int> child; }tree;  int visited[100001]={0}; tree ele[100001]; vector<int> inp[100001];  int val_arr[100001];   int scan() {     int n = 0, s = 1, ch = get();     while (ch < '0' || ch > '9') {         if (ch == '-')             s = -1;         ch = get();     }     while (ch >= '0' && ch <= '9') {         n = (n << 3) + (n << 1) + ch - '0';         ch = get();     }     return (n*s); }  void createTree(int p) { 	ele[p].n.val=val_arr[p]; 	ele[p].n.idx=p; 	int size=inp[p].size(); 	 	 	ele[p].zeros=0; 	if(ele[p].n.val==0) 	ele[p].zeros=1; 	 	 	int i; 	for(i=0;i<size;i++) 	{ 		if(visited[inp[p][i]]==1) 		continue; 		else 		{ 			visited[inp[p][i]]=1; 			ele[p].child.push_back(inp[p][i]); 			ele[inp[p][i]].parent.idx=p; 			createTree(inp[p][i]); 			ele[p].zeros+=ele[inp[p][i]].zeros; 		} 	} }   void printTree(int n) { 	int i; 	for(i=1;i<=n;i++) 	{ 		cout << ele[i].n.val << "\n"; 	} }  int getZero(int x) { 	int count=0,i; 	if(ele[x].n.val==0) 	count=1; 	int size=ele[x].child.size(); 	 	if(size==0) 	return count; 	 	for(i=0;i<size;i++) 	{ 		count+=getZero(ele[x].child[i]); 	} 	return count; }   void increase(int p) { 	ele[p].zeros++; 	int ptemp=ele[p].parent.idx; 	while(ptemp!=-1) 	{ 		ele[ptemp].zeros++; 		ptemp=ele[ptemp].parent.idx; 	} }   void decrease(int p) { 	ele[p].zeros--; 	int ptemp=ele[p].parent.idx; 	while(ptemp!=-1) 	{ 		ele[ptemp].zeros--; 		ptemp=ele[ptemp].parent.idx; 	} }  int main() { 	int N,Q;  	 	N=scan(); 	Q=scan(); 	int i,j; 	int x,y; 	for(i=0;i<N-1;i++) 	{ 		x=scan(); 		y=scan(); 		inp[x].push_back(y); 		inp[y].push_back(x); 	} 	 	for(i=1;i<=N;i++) 	{ 		val_arr[i]=scan();	 	} 	 	 	 	 	visited[1]=1; 	ele[1].parent.idx=-1; 	createTree(1); 	 	char ch; 	int count; 	bool flag=false; 	for(i=0;i<Q;++i) 	{ 		scanf("%c",&ch);	 		if(ch=='Q') 		{ 			x=scan(); 			count=ele[x].zeros; 			printf("%d\n",count); 		} 		else if(ch=='U') 		{ 			x=scan(); 			y=scan(); 			ele[x].n.val+=y; 			if(ele[x].n.val==0 && y!=0) 			increase(x); // increase 			if(ele[x].n.val==y && y!=0) 			decrease(x); // decrease 			 		} 		else 		{ 			i--; 		}  	} 	return 0; }
#pragma warning(disable:4786) #define _CRT_SECURE_NO_WARNINGS #pragma comment(linker, "/stack:16777216") #include <bits/stdc++.h> using namespace std; #define fast ios_base::sync_with_stdio(false); #define endl '\n' #define gc getchar_unlocked #define file freopen("iceparticle.in","r",stdin); #define terminate exit (EXIT_FAILURE) #define os_iterator ostream_iterator<data> screen(cout,endl) #define output(vec) copy(vec.begin(),vec.end(),screen) #define memory(dt,fill,length) memset ((dt),(fill),(length)) #define MAX int(1e9) + 7; #define timer 0  typedef vector<int> vec; typedef vector<vec> vvec; typedef long long ll; typedef vector<ll> vecll; typedef vector<vecll> vvecll; typedef char character; typedef int data; typedef pair<data, data> pint; typedef vector<pint> vpint; typedef float decimal;  inline ll input() { 	 	register int c = gc(); 	ll	x = 0; 	ll 	neg = 0; 	for(; ((c<48 || c>57) && c != '-');  	c = gc()); 	if(c == '-') 	 {  		neg = 1;  		c = gc(); 	 } 	for(; c>47 && c<58 ; c = gc())  			x = (x<<1) + (x<<3) + c - 48; 	return (neg)? 		-x:x; }  inline void process() {  	int t=input(); 	ll n; 	for(;t--;) { 	n=input(); 	if (n==1 || 		n==10|| 		n==100|| 		n==1000|| 		n==10000|| 		n==100000)  	cout << "NO" << endl;  	else  	cout << "YES" << endl; 	} }  int main (int argc, char * const argv[]) { 	 	if(timer) {	 	decimal bios_memsize;  	clock_t execution; 	execution=clock(); 	 	process(); 	bios_memsize=(clock()-execution)/(decimal)CLOCKS_PER_SEC; 	printf("[%.4f] sec\n",bios_memsize); } 	process(); 	 return 0; }  
#include<iostream> using namespace std; int main() { 	unsigned long int t; 	cin>>t; 	while(t--) 	{ 		unsigned long long n,k,q=0; 		cin>>n>>k; 		if(n==1) 			cout<<"1\n"; 		else if(k==1) 			cout<<n<<"\n"; 		else 		{ 			while(n) 			{ 			    q+=int(float(n%k));; 			    n=(n-(int(float(n%k))))/k; 			} 			cout<<q<<"\n"; 		} 	} 	return 0; } 
/* Sahil Prakash */  #include<bits/stdc++.h>  using namespace std;  #define ull unsigned long long #define si(x) scanf("%d",&x) #define sull(x) scanf("%llu",&x) #define sch(x) scanf("%c",&x) #define sstr(s) scanf("%s",s) #define pri(x) printf("%d",x) #define pch(x) printf("%c",x) #define pull(x) printf("%llu",x) #define pstr(s) printf("%s",s) #define nl printf("\n") #define MOD 1000000007  ull power( ull a, ull b ) {     ull res=1;     while(b)     { 	if(b%2) 	    res=((res%MOD)*(a%MOD))%MOD; 	a=((a%MOD)*(a%MOD))%MOD; 	b=b/2;     }     return res; } int main() {     int t;     si(t);     ull n,m,temp1,a,temp2;     while(t--)     { 	temp1=1; 	sull(n); sull(m); 	if(n>2) 	{ 	a=n-2; 	temp1=power(m-2,a); 	temp2=m-1; 	temp1=((temp1%MOD)*(temp2%MOD))%MOD; 	temp1=((m%MOD)*(temp1%MOD))%MOD; 	pull(temp1); 	} 	else 	{ 	    if(n==2) 	    temp1=((m%MOD)*((m-1)%MOD))%MOD; 	    else 	    temp1=m; 	    pull(temp1); 	} 	nl;     }     return 0; } 
#include <stdio.h> #include <string.h> #include <vector> #define lli long long int #define pb push_back  using namespace std;  vector <int> g[105]; lli mat[105][105]; int used[105]; int mt[105];  int kuhn(int node) {     if (used[node]) {         return 0;     }     used[node] = 1;      for (int i = 0; i < (int)g[node].size(); i++) {         int viz = g[node][i];          if (mt[viz] == -1 || kuhn(mt[viz])) {             mt[viz] = node;             return 1;         }     }     return 0; }  int main(void) {     int n, m, k;     lli l, r;     lli mid;     lli best;     int match;      scanf(" %d %d %d", &n, &m, &k);      for (int i = 0; i < n; i++) {         for (int j = 0; j < m; j++) {             scanf(" %lld", &mat[i][j]);         }     }      l = 1;     r = (lli)1e12;     best = r;     while(l <= r) {         for (int i = 0; i < n; i++) {             g[i].clear();         }          mid = (l + r) / 2;         for (int i = 0; i < n; i++) {             for (int j = 0; j < m; j++) {                 if (mat[i][j] <= mid) {                     g[i].pb(j);                 }             }         }          memset(mt, -1, sizeof(mt));         match = 0;         for (int i = 0; i < n; i++) {             memset(used, 0, sizeof(used));             if (kuhn(i)) {                 match++;             }         }          if (match >= k) {             best = mid;             r = mid - 1;         } else {             l = mid + 1;         }     }     printf("%lld\n", best);      return 0; } 
#include<bits/stdc++.h> using namespace std; #define ll long long  int arr[1010][1010];  int num[1000010]={0};  vector<int> edges[1000010];  bool visited[1000010]={false};  int diameter(int i) { 	vector<int> nodes; 	nodes.push_back(i); 	queue<int> bfs; 	bfs.push(i); 	int cnted=0,temp; 	visited[i]=true; 	int last=i; 	while(!bfs.empty()) 	{ 		temp=bfs.front(); 		cnted+=edges[temp].size(); 		last=temp; 		bfs.pop(); 		for(int j=0;j<edges[temp].size();j++) 		{ 			if(!visited[edges[temp][j]]) 			{ 				bfs.push(edges[temp][j]); 				visited[edges[temp][j]]=true; 				nodes.push_back(edges[temp][j]); 			} 		} 	} 	pair<int,int>tempp; 	if(cnted == 2*(nodes.size()-1)) 	{ 		for(int j=0;j<nodes.size();j++)visited[nodes[j]]=false; 		queue<pair<int,int> > bf; 		bf.push(make_pair(last,0)); 		visited[last]=true; 		 		while(!bf.empty()) 		{ 			tempp=bf.front(); 			 			last=tempp.second; 			temp=tempp.first; 			bf.pop(); 			for(int j=0;j<edges[temp].size();j++) 			{ 				if(!visited[edges[temp][j]]) 				{ 					bf.push(make_pair(edges[temp][j],last+1)); 					visited[edges[temp][j]]=true; 					//nodes.push_back(edges[temp][j]); 				} 			} 		} 		//cout<<i<<" "<<nodes.size()<<endl; 		return last; 	} 	//cout<<i<<" "<<nodes.size()<<endl; 	return -1; } int main() { 	 	int n,m; 	scanf("%d%d",&n,&m); 	//cout<<n<<" "<<m<<endl; 	std::map<int,int> mymap;   	std::map<int,int>::iterator it; 	 	int cnt=1; 	//cout<<cnt<<endl; 	for(int i=0;i<n;i++) 	{ 		for(int j=0;j<m;j++) 		{ 			scanf("%d",&arr[i][j]); 			//cout<<arr[i][j]<<" "; 			if(mymap.count(arr[i][j]) > 0) 			{ 				arr[i][j]=mymap[arr[i][j]]; 				num[arr[i][j]]++; 			} 			else 			{ 				mymap[arr[i][j]]=cnt; 				arr[i][j]=cnt; 				num[arr[i][j]]++; 				++cnt; 			} 			//cout<<arr[i][j]<<" "; 		} 		//cout<<endl; 	} 	 	for(int i=0;i<n;i++) 	{ 		for(int j=0;j<m;j++) 		{ 			if(i<n-1) 			{ 				if(arr[i][j]==arr[i+1][j]) 				{ 					edges[i*n+j].push_back(i*n+n+j); 					edges[i*n+n+j].push_back(i*n+j); 					//cout<<i*n+j<<" "<<i*n+n+j<<endl; 				} 			} 			if(j<m-1) 			{ 				if(arr[i][j]==arr[i][j+1]) 				{ 					edges[i*n+j].push_back(i*n+1+j); 					edges[i*n+1+j].push_back(i*n+j); 					//cout<<i*n+j<<" "<<i*n+1+j<<endl; 				} 			} 		} 	} 	 	long long res=1; 	for(int i=0;i<n*m;i++) 	{ 		if(visited[i]==false) 		{ 			 			int temp=diameter(i)+1; 			 			if(temp==0) 			{ 				res=max(res,(long long)num[arr[i/n][i%m]]); 			} 			else res=max(res,(long long)temp); 		} 	} 	cout<<res<<endl; 	 	 	 	 } 
#include<iostream> #include<vector> #include<cmath> #include<cassert> #define ll long long #define ld long double using namespace std; //testing void doit(ll n,ll phi) { 	if(phi == n-1){cout<<n;return;} 	//phi = (p-1) * (q-1) 	//phi=n+1 -p -q 	//p+q = n+1-phi 	ll sum=n+1-phi; 	ll a=1,b=-sum,c=phi+sum-1,ans; 	ans = (sum + (ll)sqrt((ld)sum*(ld)sum - (ld)4 * (ld)c))/2;	 	for(int i=-2;i<=2;++i) 	{ 		if(n%(ans-i)==0) 		{ 			cout<<min(ans-i,n/(ans-i))<<" "<<max(ans-i,n/(ans-i));return; 		} 	} 	//or phi=p*(p-1) 	ans = (1 + (ll)sqrt(1+4*(ld)phi) )/2; 	for(int i=-2;i<=2;++i) 	{ 		if((ans-i)*(ans-i) == n){cout<<ans-i<<" "<<ans-i;return;} 	} 	assert(0); } vector<bool> sieve(2000000,1); int main() { 	for(ll i=2;i<10000;++i) 	{ 		if(sieve[i]) 		{ 			for(ll j=i*i;j<2000000;j+=i) 				sieve[j]=0; 		} 	} 	int t; 	cin>>t; 	for(int q=0;q<t;++q) 	{ 		ll num,phi; 		cin>>num>>phi; 		ll n=num; 		for(int i=2;i<=min(1500000ll,n);++i) 		{ 			if(sieve[i]) 			{ 				int pow=0; 				while(n%i ==0) 				{ 					cout<<i<<" "; 					n/=i; 					pow++; 				} 				if(pow>0) 				{ 					phi/=(i-1); 					for(int q=0;q<pow-1;++q)phi/=i; 				} 			} 		} 		if(n!=1)doit(n,phi); 		cout<<endl; 	} 	return 0; }
#include<bits/stdc++.h> using namespace std; int main() {     int t;     cin>>t;     while(t--)     {         long long int e,o,sum=0;         cin>>e>>o;         sum=e+o;         if(sum%5==0)         {             cout<<abs(o-(sum/5)*3)<<endl;         }         else             cout<<"-1"<<endl;     }     return 0; } 
#include <bits/stdc++.h> using namespace std; #define infinity (1000000007) #define ll long long #define pii pair<int,int> #define ppi pair<pii,int> #define ppp pair<pii,pii> #define pip pair<int,pii> #define pb push_back #define s(n) scanf("%d",&n) #define s2(n,m) scanf("%d%d",&n,&m) #define s3(n,m,l) scanf("%d%d%d",&n,&m,&l) #define rep(i,n) for(int i=0;i<n;++i) ll pwr(ll a,ll b,ll mod) {ll ans=1; while(b) {if(b&1) ans=(ans*a)%mod; a=(a*a)%mod; b/=2; } return ans; } ll pwr(ll a,ll b) {ll ans=1; while(b) {if(b&1) ans*=a; a*=a; b/=2; } return ans; } ll gcd(ll a,ll b) {while(b) {ll temp=a; a=b; b=temp%b; } return a; } ll lcm(ll a,ll b) {return (a/gcd(a,b))*b; } ll modularInverse(ll a,ll m) {/*reminder: make sure m is prime*/ assert(false); return pwr(a,m-2,m); } const int mod=1000000007;   int sx[300001]; int sy[300001]; int K,L; int f[300001];  map<int,set<pii> > X,Y; int DP[300001]; int dp(int n) {     if(n==1)       return DP[n]=0;     if(DP[n]!=-1)     return DP[n];         int o1=-1e9;     int o2=-1e9;     int x=sx[n];     int y=sy[n];      set<pii>::iterator newY=upper_bound(X[x].begin(),X[x].end(),pii(y,n));     set<pii>::iterator newX=upper_bound(Y[y].begin(),Y[y].end(),pii(x,n));      if(newY!=X[x].end())     {       int idx=(*newY).second;       int dist=abs(y-(*newY).first);        int availFuel=dp(idx)+f[idx];       if(dist<=L && availFuel>=K)         o1=availFuel-K;     }      if(newX!=Y[y].end())     {       int idx=(*newX).second;       int dist=abs(x-(*newX).first);        int availFuel=dp(idx)+f[idx];       if(dist<=L && availFuel>=K)         o2=availFuel-K;     }      return DP[n]=max(o1,o2);  } int main() {   std::ios::sync_with_stdio(false);   int n;     cin>>n>>K>>L;   memset(DP,-1,sizeof DP);   for(int i=1;i<=n;++i)     {       int x,y,z;       cin>>x>>y>>z;       x=-x;       y=-y;       X[x].insert(pii(y,i));       Y[y].insert(pii(x,i));       sx[i]=x;       sy[i]=y;       f[i]=z;     }      // cout<<dp(5)<<endl;   int x=dp(n);    // for(int i=1;i<=n;++i)   // {   //   // if(DP[i]==-1)   //     // DP[i]=-1e9;   //   cout<<i<<" "<<dp(i)<<endl;   // }   if(x<0)   {     cout<<"NO\n";     return 0;   }   cout<<"YES\n";        vector<int> ans;   while(n!=1)   {     ans.pb(n);      int x=sx[n];     int y=sy[n];      set<pii>::iterator newY=upper_bound(X[x].begin(),X[x].end(),pii(y,n));     set<pii>::iterator newX=upper_bound(Y[y].begin(),Y[y].end(),pii(x,n));      if(newY!=X[x].end())     {       int idx=(*newY).second;       int dist=abs(y-(*newY).first);       int availFuel=DP[idx]+f[idx];        if(dist<=L && availFuel>=K)         {           if(availFuel-K==DP[n])             {               n=idx;               continue;             }         }     }       if(newX!=Y[y].end())     {       int idx=(*newX).second;       int dist=abs(x-(*newX).first);       int availFuel=DP[idx]+f[idx];        if(dist<=L && availFuel>=K)         {           if(availFuel-K==DP[n])             {               n=idx;               continue;             }         }     }           assert(false);    }   ans.pb(1);   reverse(ans.begin(),ans.end());   cout<<ans.size()<<"\n";   for(int i=0;i<ans.size();++i)   {     cout<<-sx[ans[i]]<<" "<<-sy[ans[i]]<<"\n";   }    cout<<x<<"\n"; }
#include<iostream> #include<cstdio> #include<algorithm> #include<vector> #include<map> #include<set> #include<queue> #include<utility> #include<cstring> #include<cmath> #define LL long long int #define mod 1000000007 #define vi vector<int> #define vvi vector < vi > #define pii pair<int,int> #define all(c) c.begin(),c.end() #define sf(x) scanf("%d",&x); #define sf2(x,y) scanf("%d%d",&x,&y); #define sl(n) scanf("%lld",&n); #define mem(a,val) memset(a,val,sizeof(a)) //#define for<(i,a,b) for(i=a;i<b;i++) //#define for=(i,a,b) for(i=a;i<=b;i++) #define nl printf("\n"); #define pb push_back #define mp make_pair #define f first #define s second using namespace std; int main() {	int t,x,y,n,res,r,size,c,k,i,j,sum,tot,lenx,leny,mat[105][105],dp[105][105][28]={{{0}}}; 	int sum1;	 	char ch; 	sf2(n,res); 	for(i=1;i<=n;i++) 	{	for(j=1;j<=n;j++) 		{	scanf(" %c",&ch); 			mat[i][j]=ch-'A'+1; 		} 	} 	dp[1][1][mat[1][1]]=1; 	// build 1-d mat 	for(c=1;c<=26;c++) 	{	for(j=2;j<=n;j++) 		{	dp[1][j][c]=dp[1][j-1][c]; 			if(mat[1][j]==c) 				dp[1][j][c]+=1; 		} 		for(i=2;i<=n;i++) 		{	dp[i][1][c]=dp[i-1][1][c]; 			if(mat[i][1]==c) 				dp[i][1][c]+=1; 		} 	} 	//build 2-d mat AUB=A+B-AB 	for(c=1;c<=26;c++) 	{	for(i=2;i<=n;i++) 		{	for(j=2;j<=n;j++) 			{	dp[i][j][c]=dp[i-1][j][c]+dp[i][j-1][c]-dp[i-1][j-1][c]; 				if(mat[i][j]==c) 					dp[i][j][c]+=1; 			} 		} 	} 	//debug 	c=2; 	/*for(c=1;c<=26;c++) 	{	for(i=1;i<=n;i++) 		{	for(j=1;j<=n;j++) 				cout<<dp[i][j][c]<<" "; 			nl; 		} 	}*/ 	sum=0;sum1=0; 	//To find all rect nd cal 	for(i=1;i<=n;i++) 	{	for(j=1;j<=n;j++) 		{	for(x=1;x<=i;x++) 			{	for(y=1;y<=j;y++) 				{	tot=0; 					for(c=1;c<=26;c++) 					{	if(dp[i][j][c]-dp[x-1][j][c]-dp[i][y-1][c]+dp[x-1][y-1][c]) 							tot++; 					} 					if(tot<=res) 					{	sum+=j-y+1; 						break; 					} 				}//break from y loop 			} 		} 	} 	//printf("%d\n",sum); 	res--; 	for(i=1;i<=n;i++) 	{	for(j=1;j<=n;j++) 		{	for(x=1;x<=i;x++) 			{	for(y=1;y<=j;y++) 				{	tot=0; 					for(c=1;c<=26;c++) 					{	if(dp[i][j][c]-dp[x-1][j][c]-dp[i][y-1][c]+dp[x-1][y-1][c]) 							tot++; 					} 					if(tot<=res) 					{	sum1+=j-y+1; 						break; 					} 				}//break from y loop 			} 		} 	} 	//printf("%d\n",sum1); 	printf("%d\n",sum-sum1); 	return 0; } 
#include<bits/stdc++.h> using namespace std; #define ll long long   pair<int,int> max_down[200010]; int max_top[200010]={0}; int parent[200010]={0}; bool visited[200010]={false}; vector<int> edges[200010]; long long res=0;  void dfs(int i) { 	visited[i]=true; 	int maxi=0,smaxi=0; 	for(int j=0;j<edges[i].size();j++) 	{ 		//cout<<i<<" "<<edges[i][j]<<"     "; 		if(!visited[edges[i][j]]) 		{ 			parent[edges[i][j]]=i; 			dfs(edges[i][j]); 			if(maxi<(1+max_down[edges[i][j]].first)){smaxi=maxi;maxi=1+max_down[edges[i][j]].first;} 			else if(smaxi<(1+max_down[edges[i][j]].first))smaxi=(1+max_down[edges[i][j]].first); 		} 	} 	max_down[i]=make_pair(maxi,smaxi); 	 	//cout<<1<<" "<<i<<" "<<maxi<<" "<<smaxi<<endl; 	 }  void dfs2(int i) { 	visited[i]=true; 	if(i==1) 	{ 		max_top[i]=0; 		res+=max_down[i].first; 		 	} 	else 	{ 		int par=parent[i]; 		 		int max_res=max_down[i].first,maxtop=1+max_top[par]; 		 		if(max_down[par].first == (1+max_down[i].first )) 		{ 			 			maxtop=max(maxtop,1+max_down[par].second); 		} 		else 		{ 			 			maxtop=max(maxtop,1+max_down[par].first); 		} 		max_top[i]=maxtop; 		max_res=max(max_res,max_top[i]); 		//cout<<i<<" "<<max_top[i]<<" "<<max_res<<endl; 		res+=max_res; 		 	} 	 	for(int j=0;j<edges[i].size();j++) 		{ 			if(!visited[edges[i][j]]) 			{ 				//cout<<i<<" "<<edges[i][j]<<" !!!   "; 				dfs2(edges[i][j]); 				 			} 		} } int main() { 	 	int t; 	cin>>t; 	 	while(t--) 	{ 		int n,te1,te2; 		res=0; 		scanf("%d",&n); 		for(int i=1;i<=n;i++){edges[i].clear();visited[i]=false;} 		 		for(int i=1;i<n;i++) 		{ 			scanf("%d%d",&te1,&te2); 			//cout<<te1<<" "<<te2<<endl; 			edges[te1].push_back(te2); 			edges[te2].push_back(te1); 		} 		 		dfs(1); 		for(int i=1;i<=n;i++){visited[i]=false;} 		dfs2(1); 		double resu=(double)res/(double)n; 		printf("%0.7lf\n",resu); 		 	} } 
#include<bits/stdc++.h> using namespace std; //#define MOD 1000000007 long long int power(long long int x, long long int y,long long int MOD) {     long long int temp;     if( y == 0)        return 1;     temp = power(x, y/2,MOD)%MOD;            if (y%2 == 0)         return (temp*temp)%MOD;     else     {         if(y > 0)             return (((x*temp)%MOD)*temp)%MOD;         else             return ((temp*temp)%MOD)/x;     } }   int main() { 	int t; 	scanf("%d",&t); 	while(t--) 	{ 	long long int k,a,c,d,x=1; 	scanf("%lld %lld",&k,&a); 		if(a==1) 	{ 		x=1; 	 	 	} 	else if(a==2||a==3) 	{ 			x=k; 	 	 	}  	else 	{ 		//a=a-3; 		x=power(k,power(2,a-3,1000000006),1000000007); 		 		  	 	} 		printf("%lld\n",x); 	 	 	}    return 0; }
#include <bits/stdc++.h> using namespace std; #define ull unsigned long long #define ll long long int #define pii pair<int,int> #define pb push_back #define mp make_pair #define F(i,a,n) for(int i=(a);i<(n);++i) #define FF(i,a,n) for(i=(a);i<(n);++i) #define REP(i,a,n) for(i=(a);i<=(n);++i) #define V(x) vector<x> #define Sd(x) scanf("%d",&x) #define Sl(x) scanf("%lld",&x) #define M(x,i) memset(x,i,sizeof(x)) #define all(c) c.begin(), c.end() #define present_mapset(c,x) ((c).find(x) != (c).end()) #define cpresent_vector(c,x) (find(all(c),x) != (c).end()) #define repstl(v)  for( typeof(v.begin()) it = v.begin(); it != v.end(); it++ ) #define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl #define matrix vector< vector<ll> > #define PI acos(-1.0) #define EPS 1e-9 #define F1 first #define S2 second #define Lf 2*r #define Rg 2*r+1 //vector< vector<int> >Matrix(N, vector<int>(M,0)); #define gc getchar_unlocked #define MAXNN 1000010 #define mod 1e9+7  inline void inputfile() { #ifndef ONLINE_JUDGE     freopen("input.in","r",stdin); #endif } inline void cpp_input() {ios_base::sync_with_stdio(false);     cin.tie(NULL);} template <typename T> void scanint(T &x) {     register int c = gc();     x = 0;     int neg = 0;     for(;((c<48 || c>57) && c != '-');c = gc());     if(c=='-') {neg=1;c=gc();}     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}     if(neg) x=-x; } int hash[10000000]; int arr[10000000]; int main() {     inputfile();     cpp_input();   int t,n,m,cnt;   M(arr,0);   M(hash,0);   scanint(n);scanint(m);   F(i,0,n)   {     scanint(t);     arr[t]=1;   }    cnt=0;   F(i,0,m)   {     scanint(t);     if(arr[t]==1 && hash[t]==0)         cnt++;     hash[t]=1;   }   printf("%d\n",cnt );   return 0; } 
#include<iostream> #include<cstdio> #include<cstring> #include<cstdlib> using namespace std;  char score[14]; 	int over,run,wickets,players[13],player1,player2,onbat,nextplayer,out_count=0; 	bool allout; 	int i,j; int main(){  	for(i=0;i<13;i++) 		players[i]=0; 	cin >> over; 	player1=1,player2=2; 	onbat=1; nextplayer=2; wickets=0; allout=false; 	for(i=0;i<over;i++) 	{ 		for(j=0;j<6;j++) 		{ 		    scanf("%s",score);          	if(strcmp(score,"W")==0) 			{ 				if(player1==onbat) 				{ 					player1=++nextplayer; 					onbat=player1; 				} 				else 				{ 					player2=++nextplayer; 					onbat=player2; 				} 				wickets++; 				out_count++; 				if(wickets==10) 				{ 					allout=true; 					break; 				}  			} 			else //if(strcmp(score,"1")==0||strcmp(score,"3")==0||strcmp(score,"5")==0) 			{ 				run=atoi(score); 				if(run <=6){ 				players[onbat]+=run; 				if(run&1)                 { 					if(player1==onbat) 					{ 						onbat=player2; 					} 					else 					{ 						onbat=player1; 					} 				} 				} 			} 		} 		if(allout)         { 			break; 		}             if(player1==onbat)             {                 onbat=player2;             } 		   else 		    {                 onbat=player1; 		    } 	} 	if((out_count==10)||(strcmp(score,"W")==0))        nextplayer--; 	for(i=1;i<=nextplayer;i++)        printf("Player %i %i\n",i,players[i]); 	return 0; } 
#include <bits/stdc++.h> using namespace std; #define ull unsigned long long #define ll long long int #define pii pair<int,int> #define pb push_back #define mp make_pair #define F(i,a,n) for(int i=(a);i<(n);++i) #define FF(i,a,n) for(i=(a);i<(n);++i) #define REP(i,a,n) for(i=(a);i<=(n);++i) #define V(x) vector<x> #define Sd(x) scanf("%d",&x) #define Sl(x) scanf("%lld",&x) #define M(x,i) memset(x,i,sizeof(x)) #define all(c) c.begin(), c.end() #define present_mapset(c,x) ((c).find(x) != (c).end()) #define cpresent_vector(c,x) (find(all(c),x) != (c).end()) #define repstl(v)  for( typeof(v.begin()) it = v.begin(); it != v.end(); it++ ) #define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl #define matrix vector< vector<ll> > #define PI acos(-1.0) #define EPS 1e-9 #define F1 first #define S2 second #define Lf 2*r #define Rg 2*r+1 //vector< vector<int> >Matrix(N, vector<int>(M,0)); #define gc getchar_unlocked #define MAXNN 1000010 #define mod 1e9+7  inline void inputfile() { #ifndef ONLINE_JUDGE     freopen("input.in","r",stdin); #endif } inline void cpp_input() {ios_base::sync_with_stdio(false);     cin.tie(NULL);} template <typename T> void scanint(T &x) {     register int c = gc();     x = 0;     int neg = 0;     for(;((c<48 || c>57) && c != '-');c = gc());     if(c=='-') {neg=1;c=gc();}     for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}     if(neg) x=-x; }  //ind -> parent int ind[MAXNN],arr[MAXNN];  inline void func() {      M(ind,-1); }  int find(int x) {     if (ind[x]<0)     return x;     else     return find(ind[x]); }  void Union(int x,int y) {     int xroot,yroot;     xroot=find(x);     yroot=find(y);     if(xroot==yroot)         return;     if(ind[xroot]<=ind[yroot])         {             ind[xroot]+=ind[yroot];             ind[yroot]=xroot;         }     else     {         ind[yroot]+=ind[xroot];         ind[xroot]=yroot;     } } int main() {     inputfile();     cpp_input();   int t,i,n,m,x,y,final,k;   scanint(t);   while(t--){    scanint(n);scanint(m);scanint(k);    func();    while(m--)    {     scanint(x);     scanint(y);     Union(x,y);    }    sort(ind+1,ind+n+1);    final=0;    for(i=1; i<=n && ind[i]<0 && i<=k; i++)    {     final+=ind[i];    }    printf("%d\n",-final);      }   return 0; } 
#include <vector> #include <list> #include <map> #include <set> #include <queue> #include <deque> #include <stack> #include <bitset> #include <algorithm> #include <functional> #include <numeric> #include <utility> #include <sstream> #include <iostream> #include <iomanip> #include <cstdio> #include <cmath> #include <cstdlib> #include <ctime> #define inf 1000000000 using namespace std;  int n,m,kid1,kid2,numberOfStores; vector<int> stores; int dist[105][105]; int res = inf; struct st { 	int x; 	int y; 	int c; };  struct st s[10050];  void floyd_warshall() { 	for(int i=0;i<105;i++) 		for(int j=0;j<105;j++) 			dist[i][j] = inf; 	for(int i=0;i<n;i++) 		dist[i][i] = 0; 	for(int i=0;i<m;i++) { 		dist[s[i].x][s[i].y] = s[i].c; 		dist[s[i].y][s[i].x] = s[i].c; 	} 	for(int k=0;k<n;k++) 		for(int i=0;i<n;i++) 			for(int j=0;j<n;j++) 				if (dist[i][j] > dist[i][k] + dist[k][j]) 	         		dist[i][j] = dist[i][k] + dist[k][j]; }  int calc(vector<int> a, vector<int> b) { 	int res1 = inf, res2 = inf, temp; 	sort(a.begin(), a.end()); 	sort(b.begin(), b.end()); 	do { 		temp = 0; 		if(a.size()>=1) 			temp = dist[kid1][a[0]]; 		for(int i=1;i<a.size();i++) { 			temp += dist[a[i-1]][a[i]]; 		} 		res1 = min(res1, temp); 	} while(next_permutation(a.begin(), a.end()));  	do { 		temp = 0; 		if(b.size()>=1) 			temp = dist[kid2][b[0]]; 		for(int i=1;i<b.size();i++) { 			temp += dist[b[i-1]][b[i]]; 		} 		res2 = min(res2, temp); 	} while(next_permutation(b.begin(), b.end())); 	return res1 + res2; }  void selectKid() { 	int temp = 1<<numberOfStores; 	//cout<<temp<<endl; 	for(int i=0;i<temp;i++) { 		vector<int> t1; 		vector<int> t2; 		t1.clear(); 		t2.clear(); 		for(int j=0;j<numberOfStores;j++) { 			if(i & 1<<j) { 				t1.push_back(stores[j]); 			} else { 				t2.push_back(stores[j]); 			} 		} 		res = min(res, calc(t1, t2)); 	} }  int main() { 	#ifndef ONLINE_JUDGE 		freopen("input.txt", "r", stdin); 	#endif 	stores.clear(); 	int t1; 	scanf("%d %d", &n, &m); 	for(int i=0;i<m;i++) { 		scanf("%d %d %d", &s[i].x, &s[i].y, &s[i].c); 	} 	floyd_warshall(); 	scanf("%d", &numberOfStores); 	for(int i=0;i<numberOfStores;i++) { 		scanf("%d", &t1); 		stores.push_back(t1); 	} 	scanf("%d %d", &kid1, &kid2); 	selectKid(); 	printf("%d\n", res); 	return 0; }
/* _____________________________________________________________ |  ____  |  |  ____  |  |___   ____|   |  ____  |   |__  __| | |  |  |  |  | |    | |      | |        | |    | |      | |   | |  |  |  |  | |    | |      | |        | |    | |      | |   | |  |__|  |  | |    | |      | |        | |    | |      | |   | |    ____|  | |____| |      | |        | |____| |      | |   | |    \      |  ____  |      | |        |  ____  |      | |   | | |\  \     | |    | |   _  | |        | |    | |      | |   | | | \  \    | |    | |  | \_/ |        | |    | |      | |   | |_|__\__\___|_|____|_|__\_____|________|_|____|_|______|_|___| */ #include<bits/stdc++.h> #define mp make_pair #define pb push_back using namespace std; inline int scan(){     char c = getchar_unlocked();     int x = 0;     while(c<'0'||c>'9'){         c=getchar_unlocked();     }     while(c>='0'&&c<='9'){         x=(x<<1)+(x<<3)+c-'0';         c=getchar_unlocked();     }     return x; } const int N = 2001; const int Z = 21; int t,n,z; int arr[N]; int rnd(int n){ 	if(n%10<5){ 		return n-(n%10); 	} 	return (n+10)-(n%10); } int memoize[N][Z]; int solve(int pos,int left){ 	if(left<0){ 		return 999999999; 	} 	if(pos>n){ 		return 0; 	} 	if(memoize[pos][left]!=-1){ 		return memoize[pos][left]; 	} 	int sum=0; 	int ret=999999999; 	for(int i=pos;i<=n;++i){ 		sum+=arr[i];         ret = min (ret , rnd(sum) + solve(i+1,left-1)); 	} 	return memoize[pos][left]=ret; } int main(){ 	t=1; 	while(t--){ 		memset(memoize,-1,sizeof(int)*N*Z); 		n=scan(),z=scan(); 		for(int i=1;i<=n;++i){ 			arr[i]=scan(); 		} 		int ans = solve(1,z+1); 		printf("%d\n",ans); 	} }
#include<bits/stdc++.h> using namespace std; int ans=INT_MIN; bool flag=false; class graph {     list<int> *adj;     public:      graph(int v)      {          adj=new list<int>[v];      }      void add_edge(int u,int v)      {          adj[u].push_back(v);      }      int dfs(int v,vector<bool>& visited,vector<int>& val)      {          //cout<<v<<"\n";          visited[v]=true;          list<int>::iterator it;          int rval=val[v];          for(it=adj[v].begin();it!=adj[v].end();it++)          {              if(!visited[*it])              {                  rval=min(rval,dfs(*it,visited,val));              }          }          if(!flag)          {              ans=(val[v]-rval);              flag=true;          }          else             ans=max(ans,val[v]-rval);         return rval;      } }; int main() {     int i,n,a,b,root;     scanf("%d",&n);     graph g(n);     vector<int> val(n);     for(i=0;i<n;i++)         scanf("%d",&(val[i]));     for(i=0;i<n;i++)     {         scanf("%d",&b);         a=i;         if(b!=-1)         {             b--;             g.add_edge(b,i);         }         else             root=i;     }     vector<bool> visited(n);     g.dfs(root,visited,val);     printf("%d",ans);     return 0; }
#include<iostream> #include<vector> #include<algorithm> #include<string> #include<sstream> #include<set> using namespace std;  int main(void) { 	int cases,N,K; 	vector<set<int> > p; 	cin>>cases; 	while(cases--) 	{ 		string str; 		cin>>N>>K; 		getline(cin,str); 		p.clear(); 		p.resize(N); 		for ( int i=0; i<K; i++ ) 		{ 			getline(cin,str); 			stringstream s(str);  			int k; 			while(s>>k) 				p[k-1].insert(i); 		} 		sort(p.begin(),p.end()); 		vector<set<int> >::iterator pit=p.begin(),it=pit; 		int count=1; 		for(++it; it!=p.end(); pit=it,++it) 			if(*it!=*pit) 				count++; 		cout<<count<<endl; 	}  } 
#include <bits/stdc++.h> using namespace std;  void solve(){ 	int a[3]; 	cin >> a[0] >> a[1] >> a[2]; 	sort(a,a+3); 	if (a[2] > a[0]+a[1]) 		cout << "Alice\n"; 	else if ((a[1]+a[2]+a[0])%2 == 0) 		cout << "Bob\n"; 	else  		cout << "Alice\n"; }  int main()  { 	ios_base::sync_with_stdio(0); 	int t;cin >> t; 	while(t--){solve();} 	return 0; }
#include<iostream> #include<algorithm> using namespace std;  struct node 	{ 	 int fr; 	 int v; 	};  bool operator<(const node& a,const node& b) 	{ 	 if(a.fr%2==b.fr%2) 		return a.v<b.v; 	 else 		return (a.fr%2==1); 	}   int main() {  int t;   cin>>t;  while(t--) 	{ 	 string s;  	 cin>>s; 	 node S[s.size()]; 	 int C[26]; 	 for(int i=0;i<26;i++) 		C[i]=0; 	 for(int i=0;i<s.size();i++) 		C[s[i]-'a']++; 	  	 for(int i=0;i<s.size();i++) 		{ 		 S[i].fr=C[s[i]-'a']; 		 S[i].v=s[i]; 		} 	 sort(S,S+s.size()); 	  	 for(int i=0;i<s.size();i++) 		cout<<(char)S[i].v; 	 cout<<"\n"; 	}  return 0; } 
#include<cstdio> #include<cstring> #include<cstdlib> #include<iostream> #include<cmath> #include<algorithm> #define ll long long using namespace std; int T,n; char a[1000005]; ll calcu() { 	ll ans=0; 	/*if(n&1)*/ ans=(ll) n*((n-1)/2); 	//else ans=(ll) n*(n/2-1); 	if(n%3==0) ans-=n/3*2; 	return ans; } ll del() { 	ll ans; 	if(n%2==1) 	   {int s1=0,i,s0=0; 	    for(i=0;i<n;i++) 	       {if(a[i]=='0') s0++; 		    else s1++; 		   } 		ans=(ll)s1*s0*3; 		if(n%3==0) 		   {s1=n/3; s0=n/3*2; 			for(i=0;i<n;i++) 		       {if(a[i]!=a[(i+s1)%n]) ans--; 			    if(a[i]!=a[(i+s0)%n]) ans--; 			   } 		   } 		return ans/2; 	   } 	else 	   {int i,s00=0,s01=0,s10=0,s11=0; 		for(i=0;i<n;i+=2) 		   {if(a[i]=='0') s00++; 		    else s01++; 		   } 		for(i=1;i<n;i+=2) 		   {if(a[i]=='0') s10++; 		    else s11++; 		   } 		ans=(ll)s00*s11*2; ans+=(ll)s01*s10*2; 		ans+=(ll)s00*s01*4; ans+=(ll)s10*s11*4; 		int n1,n2; 		n1=n/2; 		for(i=0;i<n;i++) 		   {if(a[i]!=a[(i+n1)%n]) ans--;} 		if(n%3==0) 		   {int s1=n/3,s0=n/3*2; 			for(i=0;i<n;i++) 		       {if(a[i]!=a[(i+s1)%n]) ans--; 			    if(a[i]!=a[(i+s0)%n]) ans--; 			   } 		   } 		return ans/2; 	   } } int main() { 	scanf("%d",&T); 	int k; 	for(k=1;k<=T;k++) 	   {scanf("%s",a); n=strlen(a); 		printf("Case %d: %lld\n",k,calcu()-del()); 	   } 	return 0; }
#include <bits/stdc++.h> using namespace std; #define ll long long #define lim 100000 #define pb push_back #define mp make_pair #define INF 1e18 ll n,m; ll a[501][501],ans[501][501]; ll getans( ll i,ll j) {    if(i==n+1)         return 0;       if(j<1||j>m)         return INF;            if(ans[i][j]!=INF)         return ans[i][j];       ans[i][j]=min(ans[i][j],a[i][j]+getans(i+1,j-1));       ans[i][j]=min(ans[i][j],a[i][j]+getans(i+1,j));       ans[i][j]=min(ans[i][j],a[i][j]+getans(i+1,j+1));       return ans[i][j]; }  int main() {     // freopen("input.txt","r",stdin);      ll t;      ll tt;            cin>>tt;      while(tt--)      {         cin>>t;         cin>>n>>m;                  for(ll i=1;i<=n;i++)             for(ll j=1;j<=m;j++)             {                 ans[i][j]=INF;                 cin>>a[i][j];             }             ll mn=INF;             for(ll i=1;i<=m;i++)             {                                  mn=min(mn,getans(1LL,i));             }             if(mn>=t)                 cout<<"NO"<<endl;             else cout<<"YES"<<endl;       }   } 
#include <bits/stdc++.h> using namespace std; #define ll long long #define lim 100000 #define pb push_back #define mp make_pair #define INF 100000 #define epsilon 1e-5 double n,m; double a[101]; double ann; ll cut; bool eq(double q,double w) {    q-=w;    if(q>-epsilon&&q<epsilon)     return true; return false; } void getans(ll per,ll i,double cap) {      //cout<<per<<" "<<i<<"   "<<a[i]<<"  "<<cap<<endl;     if(per==m)     return ;          if(eq(cap,a[i]))     {         return getans(per+1,i+1,ann);     }     else if(cap<a[i])     {         a[i]-=cap;         cut++;         //cout<<"sahdn"<<i<<endl;         return getans(per+1,i,ann);     }     else     {         return getans(per,i+1,cap-a[i]);     }  } int main() {      //freopen("input.txt","r",stdin);            int t;      cin>>t;      while(t--)      {          cin>>n>>m;          cut=0;          for(ll i=1;i<=n;i++)             a[i]=(double)INF;          ann=n/m;          ann*=INF;         getans(1LL,1LL,ann);         cout<<cut<<endl;       }   } 
#include <bits/stdc++.h> using namespace std; #define ll long long #define lim 100000 #define pb push_back #define mp make_pair #define INF 100000 #define epsilon 1e-5 bool cmp(pair<ll,ll>a,pair<ll,ll>b) {     if(a.first==b.first)     {         return a.second>b.second;     }     return a.first<b.first; }   ll n,k; vector< pair<ll,ll> >a[7]; vector<pair<ll,ll> >b[7]; ll ans[7]; void enhance() {     ll mn=1e18,indi,sum=0;     for(ll i=1;i<7;i++)     {     sum+=b[i][ans[i]].first;         if(b[i][ans[i]].second<mn)         {             mn=b[i][ans[i]].second;             indi=i;         }     }     if(ans[indi]==b[indi].size()-1)         return;      sum+=b[indi][ans[indi]+1].first-b[indi][ans[indi]].first;      if(sum>k)         return ;     ans[indi]++;     enhance(); } int main() { ll price,val,type;    //freopen("input.txt","r",stdin);     cin>>n>>k;           for(ll i=1;i<=n;i++)     {         cin>>type>>price>>val;         a[type].push_back(make_pair(price,val));     }     for(ll i=1;i<7;i++)         sort(a[i].begin(),a[i].end(),cmp);     pair<ll,ll>temp;     for(ll i=1;i<7;i++)     {     temp.first=a[i][0].first;           temp.second=a[i][0].second;           b[i].push_back(temp);         for(ll j=1;j<a[i].size();j++)         {             if(a[i][j].first==temp.first)                 continue;             if(a[i][j].second<temp.second)                 continue;             temp.first=a[i][j].first;           temp.second=a[i][j].second;           b[i].push_back(temp);         }     }     // for(ll i=1;i<7;i++)     //     {    cout<<"newe "<<i<<endl;     //         for(ll j=0;j<b[i].size();j++)     //     {     //         cout<<b[i][j].first<<" "<<b[i][j].second<<endl;     //     }     //     cout<<endl;     // }          ll sum=0;       for(ll i=1;i<7;i++)       {         ans[i]=0;         if(b[i].size()==0)         {             cout<<"0"<<endl;             return 0;         }         sum+=b[i][0].first;       }       if(sum>k)       {         cout<<"0"<<endl;             return 0;       }       enhance();       ll mn=1e18;       for(ll i=1;i<7;i++)       {         mn=min(b[i][ans[i]].second,mn);       }       cout<<mn<<endl;    } 
#include <bits/stdc++.h> using namespace std; #define ll long long #define lim 100000 #define pb push_back #define mp make_pair #define sd(n) scanf("%lld",&n)  ll a[100+1][100+1];  ll n,m; int main() {      ll curr=0,x;   // freopen("input.txt","r",stdin);     cin>>n>>m;     for(ll i=1;i<=n;i++)         for(ll j=1;j<=n;j++)             cin>>a[i][j];         while(m--)         {             cin>>x;             x%=360;                              if(x==270)               {                 for(ll j=n;j>=1;j--)                     {                         for(ll i=1;i<=n;i++)                             cout<<a[i][j]<<" ";                         cout<<endl;                     }                }               else if(x==180)               {                 for(ll i=n;i>=1;i--)                 {                     for(ll j=n;j>=1;j--)                         cout<<a[i][j]<<" ";                     cout<<endl;                                          }               }               else if(x==90)               {                 for(ll j=1;j<=n;j++)                 {                     for(ll i=n;i>=1;i--)                         cout<<a[i][j]<<" ";                     cout<<endl;                  }               }               else               {                 for(ll i=1;i<=n;i++)                 {                     for(ll j=1;j<=n;j++)                         cout<<a[i][j]<<" ";                     cout<<endl;                 }               }               cout<<endl;         }   } 
#include<stdio.h>  int generate(int,int,int,bool);  int **arr;  int main() {   int n,i,val=1,j,l,m,**brr;   bool flag=false;      scanf("%d",&n);      arr=new int*[n+1];   brr=new int*[n+1];      for(i=0;i<=n;i++)   {     arr[i]=new int[n+1];     brr[i]=new int[n+1];   }      for(i=n,j=1;i>=1;i-=2,j++)     val=generate(i,j,val,flag=!flag);            /*if(n%2!=0)   {     for(i=1;i<=n;i++)     {       for(j=1;j<=n;j++)       {       brr[i][n-j+1]=arr[i][j];       }     }        for(i=n;i>=1;i--)     {       for(j=1;j<=n;j++) 	printf("%5d ",brr[i][j]);       printf("\n");     }   }      else   {*/     for(i=1;i<=n;i++)     {       for(j=1;j<=n;j++) 	printf("%5d ",arr[i][j]);       printf("\n");     }   //}      return 0; }           int generate(int n,int start,int val,bool flag) {   int i;      if(flag==true)   {     for(i=start;i<start+n;i++)//first row       arr[start][i]=val++;        for(i=start+1;i<start+n;i++)//last column       arr[i][start+n-1]=val++;        for(i=start+n-2;i>=start;i--)//last row       arr[start+n-1][i]=val++;       for(i=start+n-2;i>=start+1;i--)//first column     arr[i][start]=val++;   }       else   {     for(i=start;i<start+n;i++)//first row       arr[i][start]=val++;        for(i=start+1;i<start+n;i++)//last column       arr[start+n-1][i]=val++;        for(i=start+n-2;i>=start;i--)//last row       arr[i][start+n-1]=val++;       for(i=start+n-2;i>=start+1;i--)//first column       arr[start][i]=val++;   }      return val; }
#include<iostream> #include<cstdio>  using namespace std;  long long count; int size;  void merge(int a[],int beg,int mid,int end) { 	int b[size]; 	int i,j,k; 	for(i=beg,j=mid+1,k=0;i<=mid||j<=end;k++) 	{ 		if(j>end||(a[i]<a[j]&&i<=mid)) 			b[k]=a[i++]; 		else	 		{ 			b[k]=a[j++]; 			count+=(mid-i+1); 		} 	} 	for(i=beg,k=0;i<=end;i++,k++) 		a[i]=b[k]; //	cout<<count<<"("<<beg<<","<<end<<") "; }  void msort(int a[],int beg,int end) { 	if(end-beg) 	{ 		int mid=(beg+end)/2; 		msort(a,beg,mid); 		msort(a,mid+1,end); 		merge(a,beg,mid,end); 	} }  int main() { 	int n; 	cin>>n; 	count=0; 	int a[n]; 	size = n; 	for(int i=0;i<n;i++) 		scanf("%d",a+i); 	msort(a, 0, n-1); 	cout<<count<<"\n"; 	return 0; } 
#include <stdio.h> #include <string.h> #include <vector> #include <algorithm>  #define MaxLengthAncestorList 100  class AncestorList { public: 	AncestorList(char ancestorListChar[]) 	{ 		unsigned int i = 0; 		for(; i < strlen(ancestorListChar); i++) 			ancestorListInteger[i] = ancestorListChar[i]; 		for(; i < MaxLengthAncestorList; i++) 			ancestorListInteger[i] = -1; 	}  	bool operator<(const AncestorList& ancestorListRight) const 	{ 		bool isLessThan = 0; 		for(unsigned int i = 0; i < MaxLengthAncestorList; i++) 		{ 			if((this->ancestorListInteger)[i] < ancestorListRight.ancestorListInteger[i]) 			{ 				isLessThan = 1; 				break; 			} 			else if((this->ancestorListInteger)[i] > ancestorListRight.ancestorListInteger[i]) 				break; 			else if((this->ancestorListInteger)[i] == -1) 				break; 			else if(ancestorListRight.ancestorListInteger[i] == -1) 				break; 		} 		return isLessThan; 	}  	unsigned int operator-(const AncestorList& ancestorListRight) const 	{ 		unsigned int i; 		for(i = 0; i < MaxLengthAncestorList; i++) 		{ 			if(((this->ancestorListInteger)[i] != ancestorListRight.ancestorListInteger[i]) || (((this->ancestorListInteger)[i] * ancestorListRight.ancestorListInteger[i]) == 1)) 				break; 		} 		return i; 	}  private: 	int ancestorListInteger[MaxLengthAncestorList]; };   int main() { 	char ancestorListInput[MaxLengthAncestorList + 1]; 	std::vector<AncestorList> ancestorListVector;  	unsigned int numberOfInputs, i; 	scanf("%d", &numberOfInputs); 	for(i = 0; i < numberOfInputs; i++) 	{ 		scanf("%s", ancestorListInput); 		ancestorListVector.push_back(AncestorList(ancestorListInput)); 	}  	std::sort(ancestorListVector.begin(), ancestorListVector.end());  	unsigned int numberOfMatches, maximumNumberOfMatches = 0; 	for(i = 0; i < (ancestorListVector.size() - 1); i++) 	{ 		numberOfMatches = ancestorListVector[i + 1] - ancestorListVector[i]; 		if(numberOfMatches > maximumNumberOfMatches) 			maximumNumberOfMatches = numberOfMatches; 	} 	printf("%d", maximumNumberOfMatches);  	return 0; }
#include <iostream> #include <sstream> #include <cstdio> #include <cstring> #include <cstdlib> #include <cmath> #include <memory> #include <cctype> #include <string> #include <vector> #include <list> #include <queue> #include <deque> #include <stack> #include <map> #include <set> #include <algorithm> using namespace std; #define FOR(i,a,b) for(int (i) = (a); (i) <= (b); ++(i)) #define RFOR(i,a,b) for(int (i) = (a); (i) >= (b); --(i)) #define INITIALIZE(a,b) memset((a),b,sizeof(a)) #define INF 1000000000 #define pi 2*acos(0.0) #define SQR(a) (a)*(a) #define MP make_pair #define MAX 100001 #define MODV 1000000007 #define mod(a,mb) if(a >= mb) a = a - mb; #define modx(a) mod(a,MODV)  typedef unsigned long long UInt; typedef long long Int;  void compPrime(int *primeArr,int n){} void compPhi(int *phiArr, int n){} void compFact(int *factArr, int n){} void compPow(int *powArr, int x, int n) {   int i;     powArr[0] = 1;     FOR(i,1,n){powArr[i] = powArr[i-1]*x;mod(powArr[i],MODV);} }  class Literal { public :     int count1 ;     int count0 ;     Literal(){count1 = count0 = 0;}  }; int main() {   int test,N,i,j, sum;   char Str[30];   scanf("%s", Str);   vector<char>OP;   vector<int>Val;    for(i=0; Str[i]!='\0'; i++)   {       if(Str[i]=='T')Val.push_back(1);       else if(Str[i]=='F')Val.push_back(0);       else OP.push_back(Str[i]);   }    N = Val.size();   Literal m[N+1][N+1];   FOR(i,1,N)     if(Val[i-1]==0)m[i][i].count0 =  1;     else m[i][i].count1 = 1;     int l,k;    int q1, q0;    int count00, count01, count10, count11;    FOR(l,2,N)    {        FOR(i, 1, N-l+1)        {            j = i + l - 1;            q1 = 0;            q0 = 0;            FOR(k,i,j-1)            {                count00 = m[i][k].count0 * m[k+1][j].count0;                count01 = m[i][k].count0 * m[k+1][j].count1;                count10 = m[i][k].count1 * m[k+1][j].count0;                count11 = m[i][k].count1 * m[k+1][j].count1;                if(OP[k-1]=='+'){q1 += count11+count10+count01; q0+=count00;}                else if(OP[k-1]=='.'){q1+=count11; q0+= count00+count10+count01;}                else {q1+= count01 + count10; q0+= count11 + count00;}             }            m[i][j].count1 = q1;            m[i][j].count0 = q0;        }    }     printf("%d\n", m[1][N].count1);   } 
#include<stdio.h> #include<string.h> int len; char s[1000]; int prime[] = {     2,      3,      5,      7,     11,     13,     17,     19,     23,     29,      31,     37,     41,     43,     47,     53,     59,     61,     67,     71,      73,     79,     83,     89,     97,    101,    103,    107,    109,    113,      127,    131,    137,    139,    149,    151,    157,    163,    167,    173,      179,    181,    191,    193,    197,    199,    211,    223,    227,    229,      233,    239,    241,    251,    257,    263,    269,    271,    277,    281,      283,    293,    307,    311,    313,    317,    331,    337,    347,    349,      353,    359,    367,    373,    379,    383,    389,    397,    401,    409,      419,    421,    431,    433,    439,    443,    449,    457,    461,    463,      467,    479,    487,    491,    499,    503,    509,    521,    523,    541,      547,    557,    563,    569,    571,    577,    587,    593,    599,    601,      607,    613,    617,    619,    631,    641,    643,    647,    653,    659,      661,    673,    677,    683,    691,    701,    709,    719,    727,    733,      739,    743,    751,    757,    761,    769,    773,    787,    797,    809,      811,    821,    823,    827,    829,    839,    853,    857,    859,    863,      877,    881,    883,    887,    907,    911,    919,    929,    937,    941,      947,    953,    967,    971,    977,    983,    991,    997,   1009,   1013,  };     int isdiv(long int k) { long int l=0; int j; for(j=0;j<len;j++) {if(s[j]==',')continue; l=l*10+(s[j]-'0'); //printf("%d\n",l); l%=k; } l%=k; return (!l); }   int num() {int m=0,l; for(l=0;l<len;l++) m=m*10 +(s[l]-'0'); return m; }   int main() {   int n,k,l=0; len=0; scanf("%s",s); len=strlen(s); if(len<=4) {l=1; n=num(); if(n<=1013) { if(n==1)l=0; for(k=0;k<170 && l;k++)if(prime[k]==n)l=0; goto ls; } } for(k=0;k<170 && !l;k++) if(isdiv(prime[k])){l=1;break;}   ls:if(l)printf("COMPOSITE\n"); else printf("PRIME\n"); return 0; }
#include <stdio.h> #include <string.h>   char Matrix[50][50]; int I;   char testBaseSurround ( int row, int col, int width) { int x=0; char *ptr = (char *)&Matrix[row][col]; x = width; while ( *ptr != '\0') { if ( *ptr++ == '#') return 0; if ( --x == 0) break; } return 1; }   int getColSpace ( char *ptr, int lim) { int sp=0; while ( *ptr++ == '*') ++sp; return sp > lim ? lim : sp; }   char testBase ( char *ptr, int width) { int sp=0; while ( *ptr++ == '#') ++sp; if ( sp != width) return 0; return 1; }   int findColumn ( int sc, int row, int col, int *Length) { int height=0; char *ptr=NULL; while ( Matrix[row][col] == '*') { *Length = 0; ptr = &Matrix[row][col]; if ( getColSpace ( ptr, sc) != sc) return 0;  ptr += sc; while ( *ptr == '#') { *Length = *Length + 1; ++ptr; } if ( getColSpace ( ptr, sc) != sc) return 0;  ++row; ++height; } return height; }   void findBase ( int *row, int *col) { int IBase=1, IBaseHeight=0, x=0, y=0, sc=0, ColLen=0; char *ptr = &Matrix[*row][*col]; ++ptr;  if ( *ptr != '#' && *(ptr+1) != '#') { *col = *col + 2; return; }  while ( *ptr++ == '#') ++IBase;    if ( *row != 0) { y = *row-1; x = *col; if ( !testBaseSurround ( y, x, IBase)) { *col = *col + 2;  return; } }    y = *row; x = *col; while ( Matrix[y][x] == '#') { if ( !testBase(&Matrix[y][x],IBase)) { *col = *col + IBase; return; } ++IBaseHeight; ++y; } sc = (IBase/3);   if ( (y = findColumn ( sc, y, x, &ColLen)) == 0) { *col = *col + IBase; return; } // if ( (ColLen + (2 * sc)) != IBase) { *col = *col + IBase;  return; } // y += (*row + IBaseHeight); // finding bottom base now x = IBaseHeight; while ( x != 0) { if ( !testBase(&Matrix[y][*col],IBase)) { *col = *col + IBase; return; } y++; --x; } // // test surround if ( !testBaseSurround ( y, *col, IBase)) { *col = *col + IBase; //printf ( "nope\n"); return; } //printf ( "ok\n"); ++I; *col = *col + IBase; }   int main() { unsigned char b; int r=0,c=0, rs=0, cs=0;   scanf ( "%d %d", &r, &c); memset ( &Matrix, 0, 50 * 50); I = 0;   for ( ; rs < r; ++rs) { for ( cs = 0; cs < c; ++cs) { while ( b = (char)getchar()) { if ( b == '\0') return 0; if ( b == '#' || b == '*') { Matrix[rs][cs] = b; break; }	 } } }    for ( rs = 0, cs=0; rs < r; cs=0,++rs) { while ( (b = Matrix[rs][cs]) != '\0') { if ( b == '#') findBase ( &rs, &cs); else ++cs; if ( cs > c) break; } } // printf ( "%d\n", I); return 0; }
#include<stdio.h> #include<string.h> #include<stdlib.h> int k[105],b[105][105],a[105],n,l; 	char str[105][105],st[105]; void func(int i) { /*for(int i=1;i<=n;i++) printf("%d ",a[i]); printf("\n");*/  	if(i>n) 	{ 		printf("Yes"); 		exit(0); 	} 	for(int j=1;j<=k[i];j++) 	{ 		if(a[b[i][j]]==1) 		{ 			a[b[i][j]]=0; 			func(i+1);                         a[b[i][j]]=1; 		} 	} 	 } int main() { 	 	scanf("%d",&n); 	for(int i=0;i<=n;i++) 	gets(st); 	for(int i=1;i<=n;i++) 	gets(str[i]); 	for(int i=1;i<=n;i++) 	{ 		scanf("%d",&k[i]); 		  		for(int j=1;j<=k[i];j++) 		{ 			scanf("%s",&st); 			for(l=1;l<=n;l++) 			{                if(strcmp(st,str[l])==0)                 break; 			} 			b[i][j]=l; 		}		 	} 	for(int i=1;i<=n;i++) 	a[i]=1; 	 	/*for(int i=1;i<=n;i++) 	{ 		printf("%d ",k[i]);  	} 	printf("\n"); 	for(int i=1;i<=n;i++) 	{ 		for(int j=1;j<=k[i];j++) 		{ 			printf("%d ",b[i][j]); 		} 		printf("\n"); 		 	} */ func(1); printf("No");	 	 }
#include<bits/stdc++.h> using namespace std;  const int N=5123456; char s[N];  int z[N];  void calZ() { 	int l=0, r=0; 	int len=strlen(s); 	for(int i=1;i<len;i++) { 		if(i<=r) z[i]=min(z[i-l], r-i+1); 		while(i+z[i]<len && s[z[i]]==s[i+z[i]]) z[i]++; 		if(z[i]>(r-i+1)) l=i, r=i+z[i]-1; 	} }  int main() { 	scanf("%s", s); 	calZ(); 	int q; 	scanf("%d", &q); 	while(q--) { 		int p; 		scanf("%d", &p); 		printf("%d\n", min(z[p], p)); 	} } 
#include<bits/stdc++.h> using namespace std; typedef long long int LL; #define sd(x) scanf("%d", &x) #define mp make_pair #define pb push_back #define vi vector<int> #define ft first #define sc second #define INF 1000000000 #define MOD 10000007 int n, k; pair<LL,LL> c[205]; LL cost[205][205]; LL dp[205][37]; LL func(int last, int tot) { 	if (tot < 0) { 		return 100000000000000LL; 	} 	if (last == n+1) { 		if (tot == 0) return 0; 		else return 100000000000000LL; 	} 	if (dp[last][tot] != -1) return dp[last][tot]; 	LL ans = 100000000000000LL; 	for (int i = last; i <= n; i++) { 		ans = min(ans, cost[last][i] + func(i+1, tot-1)); 	} 	return dp[last][tot] = ans; } int main() { 	int t; 	scanf("%d", &t); 	while (t--) { 		cin>>n>>k; 		memset(dp, -1, sizeof dp); 		for (int i = 1; i <= n; i++) cin>>c[i].first; 		for (int i = 1; i <= n; i++) cin>>c[i].second; 		sort(c+1, c+n+1); 		for (int i = 1; i <= n; i++) { 			for (int j = i; j <= n; j++) { 				int sel = i; 				LL cst = (j-i)*c[sel].second; 				for (int l = i; l <= j; l++) { 					cst += abs(c[sel].first - c[l].first);  				} 				cost[i][j] = cst; 				for (sel = i+1; sel <= j; sel++) { 					cst -= (j-i)*c[sel-1].second; 					cst += (j-i)*c[sel].second; 					cst -= (j - sel+1)*(c[sel].first - c[sel-1].first); 					cst += (sel - i)*(c[sel].first - c[sel-1].first); 					cost[i][j] = min(cost[i][j], cst); 				} 			//	cout<<cost[i][j]<<" "<<endl; 			} 		} 		 		printf("%lld\n", func(1, k)); 	} 	return 0; }
#include "bits/stdc++.h" using namespace std;         #define rep(i,n) for(int i = 0; i < n; ++i)         #define REP(i,a,b) for(int i = a ; i <= b; ++i)         #define rep1(i,n) for(int i = 1; i <=n ; ++i)         #define s(n) scanf("%lf",&n)         #define rev(i,n) for(int i = n-2; i >= 0 ; --i)         #define REV(i,a,b) for(int i = a ; i >= b ; --i)         #define INF 1000000000         #define pii pair<int,int>         #define pb(a) push_back(a)         #define ll long long         #define vi vector<int>         #define mii map<int,int>         #define msi map<string,int>         #define vii vector<vector<int> >         #define vpp vector<pair<int,int> >         #define MOD 1000000007         #define PDD pair<double,double>         #define vl vector<long long>         #define pil pair<int,long long>         #define pll pair<long long,long long>         #define sz(v) (int)v.size()         #define mp make_pair         #define pi 3.1415926536         #define gc getchar_unlocked         #define ios std::ios::sync_with_stdio(false)         #define e(a) exp(a)         #define limit 100000000         #define gc getchar_unlocked     ll pwr(ll a,ll b,ll mod) {a%=mod;if(a<0)a+=mod;ll ans=1; while(b) {if(b&1) ans=(ans*a)%mod; a=(a*a)%mod; b/=2; } return ans; }     ll pwr(ll a,ll b) {ll ans=1; while(b) {if(b&1) ans*=a; a*=a; b/=2; } return ans; }     ll gcd(ll a,ll b) {while(b) {ll temp=a; a=b; b=temp%b; } return a; }     ll lcm(ll a,ll b) {return (a/gcd(a,b))*b; }     // ll modularInverse(ll a,ll m) {/*reminder: make sure m is prime*/ assert(false); return pwr(a,m-2,m); } //vll v;     const double EPS = 1e-9;  /*two numbers are deemed equal if their abs difference is less than some small epsilon , [less than operator- if(a<b-EPS){}],[less than or equal -if(a<b+EPS){}]*/     vector<ll> m[33];     vector<ll> m1[33];     int main(int argc, char const *argv[])     {     	//ios;     	int n, k, A, B;     	scanf("%d%d%d%d", &n, &k, &A, &B);     	ll a[n+1];ll b[n+1];ll c[n+1];     	rep(i,n)     	scanf("%lld", &a[i]);     for(int i = 0; i < n; i++){ int number  = a[i];    ll pro = 1;      int flag = 0;      while(number % 2 == 0){      	flag = 1;          number = number / 2;               }      if(flag == 1)pro *= 2;      for(int j = 3; j <= sqrt(a[i]); j++){      	 flag = 0;          while(number % j == 0){          	flag = 1;          	number = number / j;           }          if(flag == 1)pro*=j;      }       if(number > 2){      	pro *= number;      }      a[i] = pro;    }    // for(int i = 0; i < n; i++){cout << a[i] << " " ;}cout << "\n";     	int divide = n/2;     	int divide1 = n - divide;     	ll prec = pwr(2, divide);     	ll prec1 = pwr(2, divide1);     	for(int i = 0; i < divide; i++){b[i] = a[i];}//firstpart 		for(int i = divide; i < n; i++)c[i-divide] = a[i];//secondpart     	//BITMASKS     	for(int i = 0; i < prec; i++){     		ll c1 = 0, pro = 0;     		for(int j = 0; j < divide; j++){     			if(i & (1<<j)){     				c1++;     				pro += b[j];     				// cout << "*"     			}     			     		}     		m[c1].push_back(pro);     	} // for(int i = 0 ; i <= 2; i++){ // 	cout << i <<  "\n"; // 	for(int j = 0 ; j  < m[i].size(); j++)cout << m[i][j] << " "; // 		cout << "\n"; // }     	for(int i = 0; i < prec1; i++){     		ll c1 = 0, pro = 0;     		for(int j = 0; j < divide1; j++){     			if(i & (1<<j)){     				c1++;     				pro += c[j];     			}     			     		}     		m1[c1].push_back(pro);     	}      	for(int i  = 0 ; i <= k; i++){     		sort(m1[i].begin(), m1[i].end());     	}      	//end BITMASKS     	ll c3 = 0;     	for(int i = 0; i <= k; i++){     		for(int j = 0; j <= k; j++){     			if(i+j <= k){     				for(int p = 0; p < m[i].size(); p++){     					// for(int q = 0; q < m1[j].size(); q++){     					// 	if(m1[j][q] + m[i][p] >= A && m1[j][q] + m[i][p] <= B)c3++;     					// }     					int val = A - m[i][p]; 						int id1 = lower_bound(m1[j].begin(),m1[j].end(),val) - m1[j].begin(); 						val = B - m[i][p]; 						int id2 = upper_bound(m1[j].begin(),m1[j].end(),val) - m1[j].begin() - 1; 						c3 = c3 + max(0,id2 - id1 + 1);     				}     			}     		}     	}     	printf("%lld", c3);     	return 0;     }
#include<bits/stdc++.h> using namespace std;  string str; string ans; int main(){ 	int n,k; 	cin>>n>>k; 	cin>>str; 	ans=""; 	int i,j; 	for(i=0;i<k;i++){ 		int cnt[26]; 		memset(cnt,0,sizeof(cnt)); 		for(j=i;j<n;j+=k){ 			cnt[str[j]-'a']++; 		} 		int maxi=0; 		char max_c=str[i]; 		for(j=2;j>=0;j--){ 			if(cnt[j]!=0&&cnt[j]>=maxi){ 				maxi=cnt[j]; 				max_c=(char)(j+'a'); 			} 		} 		ans+=max_c; 	} 	cout<<ans<<endl; 	return 0; }
 #include<iostream>     #include<algorithm>     #include<cstdio>     using namespace std;      int main()     {     	int n,i,j,k,cn;     	long long int N,m;     	long long int max;     	scanf("%d",&n);     	int id[n];     	long long int a[n],a1[n];      	for(i=0;i<n;i++)     	{     		scanf("%lld%lld",&m,&N);     		a[i]=m*N;     		a1[i]=a[i];     		//printf("%lld\n",arr[i]);      	}cn=0;     	sort(a1,a1+n);     	//for(i=0;i<n;i++)     	//printf("%lld\n",arr1[i]);     	for(i=n-1;i>=0;i--)     	{     		for(j=0;j<n;j++)     		if(a1[i]==a[j])     		{//printf("%d",j);     			id[cn++]=j+1;     			a[j]=-1;     			break;     		}     	}     	//for(i=0;i<n;i++)     	//printf("%d",index[i]);     	int q;     	scanf("%d",&q);     	while(q--)     	{     	scanf("%d",&k);         	printf("%d\n",id[k-1]);     	}     	return 0;} 
#include<iostream> #include<algorithm> #include<vector> #include<queue> #include<list> using namespace std; #define inf 100000000000000000LL long long int func(vector<pair<int,int> >*adj,int src,int des) { long long int ans[des+3]; fill(ans,ans+des+3,inf); priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >q; q.push(make_pair(0,src)); ans[src]=0; while(!q.empty()) { pair<int,int>temp=q.top(); q.pop(); for(int i=0;i<adj[temp.second].size();i++) if(ans[adj[temp.second][i].second]>ans[temp.second]+adj[temp.second][i].first) { ans[adj[temp.second][i].second]=ans[temp.second]+adj[temp.second][i].first; q.push(make_pair(ans[adj[temp.second][i].second],adj[temp.second][i].second)); } } return ans[des]; } int main() { ios_base::sync_with_stdio(false); int n,r; cin>>n>>r; int h[n],c[n]; vector<pair<int,int> >adj[3*n]; for(int i=1;i<=n;i++) cin>>h[i]; for(int i=1;i<=n;i++) { cin>>c[i]; adj[i].push_back(make_pair(c[i],n+i)); adj[n+i].push_back(make_pair(c[i],i)); } adj[0].push_back(make_pair(c[1],1)); adj[0].push_back(make_pair(c[1],n+1)); adj[n].push_back(make_pair(0,2*n+1)); adj[2*n].push_back(make_pair(0,2*n+1)); while(r--) { int u,v; cin>>u>>v; if(h[u]<=h[v]) { adj[u].push_back(make_pair(0,v)); adj[n+v].push_back(make_pair(0,n+u)); } if(h[v]<=h[u]) { adj[v].push_back(make_pair(0,u)); adj[n+u].push_back(make_pair(0,n+v)); } } long long int ans=func(adj,0,2*n+1); if(ans>=inf) cout<<"-1"<<endl; else cout<<ans<<endl; return 0; } 
 #include<bits/stdc++.h>  using namespace std;  #define si(x) scanf("%d",&x) #define pri(x) printf("%d",x) #define sll(x) scanf("%lld",&x) #define pll(x) printf("%lld",x) #define sstr(s) scanf("%s",s) #define pstr(s) printf("%s",s) #define nl printf("\n") #define ll long long int  int main() {     ll n,m;     int p;     sll(n); sll(m); si(p);     int a[p],b[p];     int x=0;     map< pair<ll,ll>, int > mp;     for(int i=0;i<p;++i) { 	si(a[i]); si(b[i]); 	mp[make_pair(a[i],b[i])]++;     }     map< pair<ll,ll>, int>::iterator it;     for(it = mp.begin(); it!=mp.end();++it) { 	if(((it->first).first-1 + m-(it->first).second)%2==1) { 	    x = x ^ it->second; 	}     }     if(x) { 	cout<<"Yes\n";     }     else { 	cout<<"No\n";     }     return 0; } 
#include<iostream> #include<algorithm> #include<map> #include<set> #include<vector> using namespace std;  long long int dp[3005][3005]; bool a[3005][3005]; long long int n,c; map<long long int,long long int>m1,m2; set<long long int>s1,s2; vector<long long int>v1,v2; void gen(pair<long long int,long long int>*pos) { set<long long int>::iterator t; for(t=s1.begin();t!=s1.end();t++) { m1[*t]=++c; v1.push_back(*t); } c=0; for(t=s2.begin();t!=s2.end();t++) { m2[*t]=++c; v2.push_back(*t); } for(int i=0;i<n;i++) a[m1[pos[i].first]][m2[pos[i].second]]=true; for(int i=0;i<=n;i++) for(int j=0;j<=n;j++) if(i==0||j==0) dp[i][j]=0; else dp[i][j]=(a[i][j]==true)+dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]; }  bool check(int mid,int x,int y,int k) { long long int x1=x-mid-1,y1=y-mid-1; long long int x2=x+mid,y2=y+mid; x1=upper_bound(v1.begin(),v1.end(),x1)-v1.begin(); y1=upper_bound(v2.begin(),v2.end(),y1)-v2.begin(); x2=upper_bound(v1.begin(),v1.end(),x2)-v1.begin(); y2=upper_bound(v2.begin(),v2.end(),y2)-v2.begin(); long long int temp=dp[x2][y2]+dp[x1][y1]; temp-=dp[x2][y1]; temp-=dp[x1][y2]; return (temp>=k); }  long long int func(long long int x,long long int y,long long int k) { if(k>n) return -1; long long int c=100,beg=0,last=1000000000,mid; while(c--) { mid=beg+(last-beg)/2; if(check(mid,x,y,k)) last=mid; else beg=mid+1; } return last; }  int main() { ios_base::sync_with_stdio(false); cin>>n; pair<long long int,long long int>pos[n]; for(int i=0;i<n;i++) { cin>>pos[i].first>>pos[i].second; s1.insert(pos[i].first); s2.insert(pos[i].second); } gen(pos); int q; cin>>q; while(q--) { long long int x,y,k; cin>>x>>y>>k; cout<<func(x,y,k)<<endl; } return 0; } 
#include <cstdio> #include <iostream> #include <stdio.h> using namespace std; int main(int argc, char const *argv[]) { 	int t,n,k; 	float x,y; 	scanf("%d",&t); 	while(t--){ 		scanf("%d%d%f%f",&n,&k,&x,&y); 		//cout<<n*720/(x+y)<<"\n"; 		float numer = (n-k)*(1-y); 		float denom = n-(k*x+(n-k)*y); 		//cout<<(.4f)numer/denom<<"\n"; 		printf("%.4f\n",numer/denom); 	} 	return 0; }
#include<iostream> using namespace std;  int temp[] = {1,2,3,4}; int main() { for(int i=0;i<4;i++) cout<<temp[i]<<endl; return 0; }
#include<stdio.h> int help(int help) { help=help++; return ++help; } int main() { int test=10; int pleh=help(test); printf("%d\n",pleh); return 0; }
#include <stdio.h> using namespace std;  long long int f(long long int n) { 	long long int r; 	 	if(n >= 0) 		r = (n+1)*(n+2)*(n+3); 	 	return (r/6) ; }   int main() { 	long long int N,A,B,C; 	scanf("%lld%lld%lld%lld",&N,&A,&B,&C); 	printf("%lld\n",f(N)-f(N-A-1)-f(N-B-1)-f(N-C-1)+f(N-A-B-2)+f(N-A-C-2)+f(N-C-B-2)-f(N-A-B-C-3)); 	 	return 0;  }    /* #include <iostream> #include <algorithm> #include <map> #include <cstring> //memset  #define int64 long long int #define int64r register int64 #define int32 register int  using namespace std;  int main(){ 	 	 	 	return 0;  } */
#include <stdio.h> #include <string.h> int main() {int size; scanf ("%d",&size); int arr[size],i; for(i=0;i<size;i++) { scanf("%d",&arr[i]); printf("%d",arr[i]); } return 0; }
#include<stdio.h> using namespace std;  int main(void) { 	int i = 0, num = 1, tmp = 0; 	while(num<=10) 	{ 		i=2; 		tmp = 0; 		while(i <= num) 		{ 			if(num%i==0) 				tmp++; 			//end if 			if(tmp > 2) 				break; 			//end if	 			i++;  		}//end while 		 		if(tmp==1) 			printf("%3d, ", num); 		//end if 		num++;  	}//end if 	 	return 0;  }//end main
#include<iostream> using namespace std; int main() { cout<<"Intechxication2012"<<endl; return 0; }
#include<stdio.h> using namespace std; int main() { printf("%d",1); return 0; }
#include <stdio.h> int main() { int number = 0, rem = 0; scanf("%d",&number); rem = number % 2; if(rem == 0) printf("%d is an even number.\n", number); else printf("%d is an odd number.\n", number); return 0; }
#include <stdio.h> #include <stdlib.h> char names[6][60] = { "kisalaya", "kunal", "aaditya" "jp", "sambhav", "mayank" }; int main() { int i; int choice; for( i = 0; i < 1; i++ ) { choice = 5; printf( "%s", "mayank" ); } return 0; }
#include<stdio.h> int main() {             int a[]={1,2,3,4,5};             int j;             //Block 1 starts here   for(j=0;j<5;j++ )             {                         printf("%d",a[j]); }   //Block 1 ends here   }
#include<stdio.h> using namespace std;  int f(int); int main() {             int f(int);             int b;             b = f(20);             printf("%d",b);             return 0; }   int f(int a) {     return a>=20? a : 0; }
#include<stdio.h> int main() { printf("Executed"); return 0; }
#include<stdio.h> using namespace std; int main() {     char s='A'; printf("%c",s);  return 0; }
#include<cstdio> using namespace std; #define LL int long long int main() { LL t; scanf("%lld",&t); while(t--) {   LL n;   scanf("%lld",&n);   printf("%lld\n",(n*(n-1))/2); } return 0; }
#include<stdio.h> #include<math.h> void bin(long long int number,long long int count) { 	long long int i=1,j=1,t=0,s=1,k=0; 	while(number) 	{ 		 	//	printf("a%lld\n",number); 		if(number&1) 		{ 			 			s=count/j; 			if(s%2==0) 			{ 				//printf("b%lld lld\n",count,j); 			t+=(long long int)pow(2,k); 			//printf("%lld\n",t); 			} 			j=j*2; 			 		} 		number=number>>1; 		k++; 	} 	printf("%lld",t); 	printf("\n"); } 	 int main() { 	int testcases; 	long long int number,temporary,count; 	scanf("%d", &testcases); 	 	while(testcases--) { 		scanf("%lld%lld", &number, &count); 		bin(number,count); 		//printf("%lld\n",number>>1); 	} 	return 0; } 
#include <iostream> #include <cstdio> #include <cassert> using namespace std;  long long N, K, M; long long pos, scroll, up, down; long long length;  void perform(); long long top(long long k); bool visible(long long k);  int main() {   long long T;   assert(scanf("%lld",&T)==1);   while(T) {     perform();     T--;   }   return 0; }  void perform() {   pos = 1;   up = 1;   down = 1;   length = 0;   scroll = 0;   assert(scanf("%lld %lld %lld", &N, &K, &M)==3);      long long v;   for(long long i=0;i<M;++i) {     assert(scanf("%lld",&v)==1); //     cerr << scroll << " " << length << " " << up << " " << down << "\n";          down = max(down, v);     up = min(up, v);          if(visible(v))       continue;     if(v>pos) {       length += top(v) - pos;       pos = top(v);     }     else {       length += pos-v;       pos = v;     }     scroll++;          if(visible(up)&&visible(down))       scroll--;     else {       up = v;       down = v;     }   }      printf("%lld %lld\n", scroll, length); //   cerr << up << " " << down << "\n"; } long long top(long long k) {   return (k-K+1); } bool visible(long long k) {   if(k>=pos&&k<pos+K)     return true;   return false; }
using namespace std; #include <iostream> #include <assert.h> #define FORab(i,a,b) for(__typeof(b) i=(a);i<=(b);i++) #define FOR1(i,n) FORab(i,1,n) #define MAX 1010 #define ll long long ll mem[MAX][MAX]={0},cum[MAX][MAX]={0}; bool isMemed[MAX][MAX]={0}; ll solve(ll i, ll j) {     //cout<<i<<' '<<j<<endl;     if(isMemed[i][j]) {return mem[i][j];}     if(isMemed[j][i]) {return mem[i][j]=mem[j][i];}     //if(i == 0) return 0;     //if(j == 0) return 0;     isMemed[i][j] = true;     ll &ans = mem[i][j];     if(i < j) { swap(i,j); }     if(i%j == 0) return ans=i/j;     return ans=i/j+solve(j, i%j); }   int main() {       FOR1(i, MAX-1) FOR1(j, MAX-1) { solve(i, j); }     FOR1(i, MAX-1) FOR1(j, MAX-1)     {         cum[i][j]=cum[i-1][j]+mem[i][j];     }     //cout<<solve(4,4)<<" "<<solve(4,5)<<" "<<solve(5,4)<<" "<<solve(5,5)<<" "<<endl;     //cout<<mem[2][5]<<" "<<cum[2][5]<<endl;     ll x=0;     FORab(i,1,2)         FORab(j,5,10)x+=mem[i][j];         //cout<<x<<endl;     ll t; cin>>t;     FOR1(cno, t) {         ll m, n, p, q;         cin>>m>>n>>p>>q;         ll ans=0;         FORab(j, p, q) {             ll mdiv = (m-1)/j;             ll ndiv = n/j;             ll mmod = (m-1)%j;             ll nmod = n%j;             /*             if(mdiv == ndiv) {                 ans = getAns(j, mmod, nmod);             } else if(mmod < nmod) {                 getAns(j, mmod, nmod)+getAns(j, 1, mmod-1);*/                 ll msum=j*(mdiv*(mdiv-1))/2 + (mmod+1)*mdiv;                 ll nsum=j*(ndiv*(ndiv-1))/2 + (nmod+1)*ndiv;                // cout<<nsum<<" .. "<<msum<<endl;                 msum+=cum[j-1][j]*mdiv+cum[mmod][j];                 nsum+=cum[j-1][j]*ndiv+cum[nmod][j];                 ans+=nsum-msum;     //            cout<<nsum<<" "<<msum<<endl;                 //assert(nsum>=msum);                 //assert(ans>=0);             }             cout<<ans<<endl;     }       return 0; }  
