t = input() _NEWLINE for tests in xrange(t): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT a = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT s = sum(a) _NEWLINE  _INDENT  _INDENT if s%n !=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = s/n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a.sort() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT time = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for items in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT time+=abs(c-items) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print time
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE long int findhcf(long int a,long int b) _NEWLINE { _NEWLINE 	if(b%a==0) return a; _NEWLINE 	return findhcf(b%a,a); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	long int x1,y1,x,y; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		cin>>x1>>y1>>x>>y; _NEWLINE 		x=fabs(x-x1); _NEWLINE 		y=fabs(y-y1); _NEWLINE 		if(x==0||y==0) {cout<<"0\n"; continue;} _NEWLINE 		long int hcf=(x<y?findhcf(x,y):findhcf(y,x)); _NEWLINE 		cout<<x+y-hcf<<"\n";		 _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
for _ in range(input()): _NEWLINE 	n=input() _NEWLINE 	a=raw_input().split() _NEWLINE 	x=raw_input() _NEWLINE 	b=[0]*n _NEWLINE 	#n=a[0].count(x) _NEWLINE 	#print n _NEWLINE 	for i in range(n): _NEWLINE 		c=a[i].count(x) _NEWLINE 		b[i]=c _NEWLINE 	m=max(b) _NEWLINE 	#print b _NEWLINE 	for i in range(n): _NEWLINE 		if b[i]==m: _NEWLINE 			print a[i] _NEWLINE 			break _NEWLINE 		 _NEWLINE 		
// Tapan Sahni _NEWLINE #include <algorithm> _NEWLINE #include <iostream> _NEWLINE #include <iterator> _NEWLINE #include <numeric> _NEWLINE #include <sstream> _NEWLINE #include <fstream> _NEWLINE #include <cassert> _NEWLINE #include <climits> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <string> _NEWLINE #include <cstdio> _NEWLINE #include <vector> _NEWLINE #include <cmath> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <list> _NEWLINE #include <iomanip> _NEWLINE #include <map> _NEWLINE #include <complex> _NEWLINE #include <set> _NEWLINE  _NEWLINE #define mod 1000000007 _NEWLINE  _NEWLINE using namespace std; _NEWLINE typedef long long LL; _NEWLINE  _NEWLINE const int N = 1000 + 10; _NEWLINE const int inf = 1000000000; _NEWLINE  _NEWLINE int a[N]; _NEWLINE int fdp[N][N] , fdp1[N][N]; _NEWLINE vector <pair <int ,int> > v; _NEWLINE int main() { _NEWLINE  _INDENT ios::sync_with_stdio(false) ; cin.tie(nullptr); _NEWLINE  _INDENT int t; _NEWLINE  _INDENT cin >> t; _NEWLINE  _INDENT while(t--) { _NEWLINE  _INDENT  _INDENT int n , k; _NEWLINE  _INDENT  _INDENT cin >> n >> k; _NEWLINE  _INDENT  _INDENT for(int i = 1; i <= n; i++) cin >> a[i]; _NEWLINE  _INDENT  _INDENT int lis = 0; _NEWLINE  _INDENT  _INDENT for(int i = 0; i <= n + 1; i++) _NEWLINE  _INDENT  _INDENT  _INDENT for(int j = 0; j <= n + 1; j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fdp[i][j] = inf; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fdp1[i][j] = -1; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT fdp[0][0] = 0; _NEWLINE  _INDENT  _INDENT for (int i = 1; i <= n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT for (int j = 0; j <= n; j++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fdp[i][j] = fdp[i - 1][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (j && fdp[i - 1][j - 1] < a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fdp[i][j] = min(fdp[i][j], a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (fdp[i][j] != inf) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lis = max(lis, j); _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT fdp1[n + 1][0] = inf; _NEWLINE  _INDENT  _INDENT for (int i = n; i >= 1; i--){ _NEWLINE  _INDENT  _INDENT  _INDENT for (int j = 0; j <= n; j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fdp1[i][j] = fdp1[i + 1][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (j && fdp1[i + 1][j - 1] > a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fdp1[i][j] = max(fdp1[i][j], a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT LL ans = 0; _NEWLINE  _INDENT  _INDENT int r; _NEWLINE  _INDENT  _INDENT for (int i = 1; i < n; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT r = -1; _NEWLINE  _INDENT  _INDENT  _INDENT for (int j = 0; j <= lis; j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int j1 = lis - j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (fdp1[i + 1][j1] - fdp[i][j] > 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (fdp1[i + 1][j1] > k) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (fdp[i][j] >= r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += max(k - fdp[i][j], 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += max(k - r + 1, 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (fdp[i][j] >= r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += max(fdp1[i + 1][j1] - fdp[i][j] - 1, 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += max(fdp1[i + 1][j1] - r, 0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r = fdp1[i + 1][j1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ans += max(k - fdp[n][lis], 0); _NEWLINE  _INDENT  _INDENT ans += max(min(k, fdp1[1][lis] - 1), 0); _NEWLINE  _INDENT  _INDENT cout << ans << endl; _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT return _INDENT 0; _NEWLINE } _NEWLINE // Never Quit _NEWLINE 
/* _INDENT _NEWLINE  * File: _INDENT  main.c _NEWLINE  * Author: APOORV _NEWLINE  * _NEWLINE  * Created on 27 June, 2013, 12:03 AM _NEWLINE  */ _NEWLINE  _NEWLINE #include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE  _NEWLINE /* _NEWLINE  * _INDENT _NEWLINE  */ _NEWLINE int generate_solution(int x,int y); _NEWLINE void generate_seq(); _NEWLINE void init(); _NEWLINE int check_arr(int x,int i,int j); _NEWLINE int check_reachable(int x,int y,int i); _NEWLINE  _NEWLINE int seq[294][2]; _INDENT _NEWLINE  _NEWLINE int main(int argc, char** argv) { _NEWLINE  _INDENT  _INDENT init(); _NEWLINE  _INDENT  _INDENT generate_seq(); _NEWLINE  _NEWLINE  _INDENT  _INDENT int cnt,x,y,ans; _NEWLINE  _INDENT  _INDENT scanf("%d",&cnt); _NEWLINE  _INDENT  _INDENT while (cnt>0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d",&x,&y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=generate_solution(x,y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (ans>0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("Bhima %d\n",ans); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("Shiva %d\n",-1*ans); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt--; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return (EXIT_SUCCESS); _NEWLINE } _NEWLINE  _NEWLINE void init() { _NEWLINE  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT for (i=0;i<350;i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT seq[i][0] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT seq[i][1] = 0; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE void generate_seq() { _NEWLINE  _INDENT  _INDENT int x,y,val,flag,loop_var; _NEWLINE  _INDENT  _INDENT x=y=val=flag=0; _NEWLINE  _INDENT  _INDENT while (y<1001) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x+=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y+=3; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT loop_var=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (loop_var<val) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (seq[loop_var][1]==x) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT loop_var++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (flag == 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (x<1001 && y<1001) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT seq[val][0]=x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT seq[val][1]=y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int generate_solution(int x,int y) { _NEWLINE  _INDENT  _INDENT int flag=0; _NEWLINE  _INDENT  _INDENT if (x==0 && y==0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT flag = check_arr(x,0,293) + check_arr(y,0,293); _NEWLINE  _INDENT  _INDENT if ((seq[flag][1]==y || seq[flag][1]==x)&&(seq[flag][0]==y || seq[flag][0]==x)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return -(2*flag); _NEWLINE  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flag = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (flag<=293) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (check_reachable(x,y,flag)!=0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return ((2*flag)+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return flag; _NEWLINE } _NEWLINE  _NEWLINE int check_arr(int x,int i,int j) { _NEWLINE  _INDENT  _INDENT if (i==j) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (seq[i][0]==x) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (seq[(i+j)/2][0] < x) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return check_arr(x,(((j+i)/2)+1),j); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } else { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return check_arr(x,i,((j+i)/2)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int check_reachable(int x,int y,int i) { _NEWLINE  _INDENT  _INDENT int flag =0; _NEWLINE  _INDENT  _INDENT if (seq[i][1]==y || seq[i][1]==x || seq[i][0]==y || seq[i][0]==x) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flag = 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if ( ((x-seq[i][0]-y+seq[i][1])*(x-seq[i][0]-y+seq[i][1]))<4 || ((x-seq[i][1]-y+seq[i][0])*(x-seq[i][1]-y+seq[i][0]))<4 ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flag = 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return flag; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include <string.h> _NEWLINE #include<math.h> _NEWLINE #include <algorithm> _NEWLINE #include<stdio.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE bool p[1000100]; _NEWLINE int primes[100000]; _NEWLINE  _NEWLINE int main() _NEWLINE {int k=0,i,j; _NEWLINE  long long a,b,z,number,x,y; _NEWLINE  _INDENT _NEWLINE  _INDENT for (i=2;i<1000000;i++) _NEWLINE  { _NEWLINE  _INDENT  _INDENT  if (p[i]==0) _NEWLINE  _INDENT  _INDENT  { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT primes[k++]=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (j=i+i;j<1000000;j+=i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[j]=1; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  } _INDENT _NEWLINE  long long u=k; _NEWLINE  int t; _NEWLINE  long long product,check,exp,temp; _NEWLINE  scanf("%d",&t); _NEWLINE  _INDENT _NEWLINE  while(t--) _NEWLINE  { _NEWLINE  _INDENT scanf("%lld %lld %lld",&x,&y,&z); _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT k=0; _NEWLINE  _INDENT number=z; _NEWLINE  _INDENT while(z>1 && primes[k]*primes[k]<=number && k<u) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  a=0; _NEWLINE  _INDENT  _INDENT while(z%primes[k]==0) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  z/=primes[k]; _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT k++; _NEWLINE  _INDENT  } _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT if (z==1) _NEWLINE  _INDENT { _NEWLINE  _INDENT check=primes[--k]; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT } _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT else _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT check=z; _NEWLINE  _INDENT  _INDENT  _INDENT a=1; _NEWLINE  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT product=x*y; _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT exp=0; _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT temp=check; _NEWLINE  _NEWLINE  _INDENT  _INDENT while(product) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT exp+= product/temp; _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT product=product/temp; _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT printf("%lld\n",exp/a); _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  return 0; _NEWLINE }
#include <stdio.h> _NEWLINE #include <string.h> _NEWLINE  _INDENT _NEWLINE #define min(a,b) ((a<b)?(a):(b)) _NEWLINE #define LL long long int _NEWLINE  _INDENT _NEWLINE main() _NEWLINE { _NEWLINE int n, q, x, y, s, k=-1, i=-1, c=0; _NEWLINE int a[102]; _NEWLINE LL v=0; _NEWLINE LL w[200000]; _NEWLINE for(scanf("%d %d",&n,&q),memset(w,0,sizeof(w)); ++i<n; scanf("%d",&a[i]),v+=a[i]); _NEWLINE for(y=v; ++k<n; w[x]|=1) _NEWLINE for(x=a[k],c+=x,i=min(y,c)+1; --i>=x; w[i]|=(w[i-x]<<(long long)1)); _NEWLINE for(i=-1; ++i<q; scanf("%d %d",&s,&k),puts(w[s]&((long long)1<<(k-1))?"YES":"NO")); _NEWLINE return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE const int N=1000001; _NEWLINE double fac[N]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int h, i, j, t, n, k; _NEWLINE  _INDENT  _INDENT fac[0]=0; _NEWLINE  _INDENT  _INDENT for(i=1;i<N;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fac[i]=fac[i-1]+log(i); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT for(h=0;h<t;h++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n>>k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT double div=(log(2))*(n-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int start=(k<n-k) ? k : n-k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT double ans=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT double s=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=start;i>=0;i--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=exp(fac[n]-fac[i]-fac[n-i]-div); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s<1e-10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans*=100; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%.1f\n", ans); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
def factors(n): _NEWLINE  _INDENT  _INDENT return reduce(list.__add__, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0)) _NEWLINE t = long(raw_input()) _NEWLINE while t: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT a = long(raw_input()) _NEWLINE  _INDENT  _INDENT b = [] _NEWLINE  _INDENT  _INDENT b = factors(a) _NEWLINE  _INDENT  _INDENT b = list(set(b)) _NEWLINE  _INDENT  _INDENT b.sort() _NEWLINE  _INDENT  _INDENT c = 1 _NEWLINE  _INDENT  _INDENT for i in xrange(len(b)-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c*=b[i] _NEWLINE  _INDENT  _INDENT c = str(c) _NEWLINE  _INDENT  _INDENT print c[-4:] _NEWLINE 
for _ in range(input()): _NEWLINE 	c,d=map(int,raw_input().split()) _NEWLINE 	if not c%2 or not d%2: _NEWLINE 		print 'A' _NEWLINE 	else: _NEWLINE 		print 'B'
#include<stdio.h> _NEWLINE #include<string.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n,k,i,j,g; _NEWLINE  _INDENT  _INDENT long long count,l,o; _NEWLINE  _INDENT  _INDENT char a[100001]; _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT while(n--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s",a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=strlen(a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=o=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=k-1;i>=0;i--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]=='L') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=o; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(a[i]=='O') o+=l; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",count); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT unsigned long long int t,d,r,p,num; _NEWLINE  _INDENT  _INDENT scanf("%llu %llu",&t,&d); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%llu %llu",&num,&p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r=num%d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(r==0 || r==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<r<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=pow(r,p); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=r%d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%llu\n",r); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
def ncr(n,r): _NEWLINE  _INDENT  _INDENT if(n==0):	 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT if(r==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return n _NEWLINE  _INDENT  _INDENT if(r==2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return n*(n-1)/2 _NEWLINE  _INDENT  _INDENT if(r==3): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return ((n*(n-1)/2)*(n-2)/3)%1000000007 _NEWLINE  _INDENT  _INDENT return (((n*(n-1)/2)*(n-2)/3)*(n-3)/4)%1000000007 _NEWLINE for i in xrange(input()): _NEWLINE  _INDENT  _INDENT a=raw_input() _NEWLINE  _INDENT  _INDENT count=[a.count('0'), a.count('1'), a.count('2'), a.count('3'), a.count('4'), a.count('5'), a.count('6'), a.count('7'), a.count('8'), a.count('9')] _NEWLINE  _INDENT  _INDENT ans=0 _NEWLINE  _INDENT  _INDENT for j in xrange(11): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for k in xrange(j,11): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for l in xrange(k,11): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for m in xrange(l,11): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT used=[0,0,0,0,0,0,0,0,0,0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j<10: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=j _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT used[j]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if k<10: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT used[k]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l<10: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=l _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT used[l]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if m<10: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s+=m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT used[m]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if s>0 and s%9==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for n in xrange(10): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if used[n]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val=(ncr(count[n],used[n])*val)%1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans+val)%1000000007 _NEWLINE  _INDENT  _INDENT print ans _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE vector<bool> prime(10000,true); _NEWLINE vector<int> v; _NEWLINE void compute() _NEWLINE { _NEWLINE 	for(int p=2;p<=10000;p++) _NEWLINE 	{ _NEWLINE 		if(prime[p]==true) _NEWLINE 		{ _NEWLINE 			for(int i=2*p;i<=10000;i=i+p) _NEWLINE 			{ _NEWLINE 				prime[i]=false; _NEWLINE 			} _NEWLINE 			v.push_back(p); _INDENT _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	compute(); _NEWLINE 	int n,k; _NEWLINE 	cin>>n>>k; _NEWLINE 	int cnt=0; _NEWLINE 	bool flag=false; _NEWLINE 	int i=0; _NEWLINE 	while(v[i]+v[i+1]+1<=n) _NEWLINE 	{ _NEWLINE 		int k=v[i]+v[i+1]; _NEWLINE 		if(binary_search(v.begin(),v.end(),k+1)){ _NEWLINE 			cnt++; _NEWLINE 		} _NEWLINE 		i++; _NEWLINE 	} _INDENT _NEWLINE  _NEWLINE 	if(cnt>=k)cout<<"YES\n"; _NEWLINE 	else cout<<"NO\n"; _NEWLINE }
t=input() _NEWLINE while t: _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT a=map(int,bin(n)[2:]+'0') _NEWLINE  _INDENT  _INDENT num=0L _NEWLINE  _INDENT  _INDENT for i in xrange(len(a)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num+=a[len(a)-i-1]*(5**i) _NEWLINE  _INDENT  _INDENT print num _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT  _NEWLINE 
t = int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT s = raw_input().strip() _NEWLINE  _INDENT  _INDENT s += s _NEWLINE  _INDENT  _INDENT f = raw_input().strip() _NEWLINE  _INDENT  _INDENT if f in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO"
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll long long _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",(int)((1.0d*n*(n+2)*(2*n+1)/8))); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
for _ in range(input()): _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT if n%2 == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print '0' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = '9' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = n/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c += '0' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print c
# cook your code here _NEWLINE t=int(raw_input()) _NEWLINE for x in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT d=dict() _NEWLINE  _INDENT  _INDENT l=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT for temp in l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(temp in d.keys()): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[temp]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[temp]=1 _NEWLINE  _INDENT  _INDENT m=d.keys()[0] _NEWLINE  _INDENT  _INDENT m_c=d[d.keys()[0]] _NEWLINE  _INDENT  _INDENT for k in d.keys(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if((d[k]>m_c) or (d[k]==m_c and k<m)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m=k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m_c=d[k] _NEWLINE  _INDENT  _INDENT print str(m)+" "+str(m_c)
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define ll unsigned long long int _NEWLINE #define endl "\n" _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT //cin.sync_with_stdio(false); _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d", &t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll N ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cin >> N ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld", &N); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if( N ==1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("0\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n" , (ll)(N*N -2)/2); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include <cstdio> _NEWLINE #include <vector> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long pow(long long x, int n, int p) { _NEWLINE 	if (n == 0) _NEWLINE 		return 1; _NEWLINE 	long long res = pow(x, n / 2, p); _NEWLINE 	res = (res * res) % p; _NEWLINE 	if (n % 2 == 1) _NEWLINE 		res = (res * x) % p; _NEWLINE 	return res; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	int t; _NEWLINE 	scanf("%d", &t); _NEWLINE 	for (int i = 1; i <= t; i++) { _NEWLINE 		int n; _NEWLINE 		int p; _NEWLINE 		scanf("%d%d", &n, &p); _NEWLINE 		vector <int> x(n), y(n); _NEWLINE 		for (int j = 0; j < n; j++) _NEWLINE 			scanf("%d%d", &x[j], &y[j]); _NEWLINE 		int cur = 1; _NEWLINE 		long long dx = 0; _NEWLINE 		long long dy = 0; _NEWLINE 		while (cur < n && dx == 0 && dy == 0) { _NEWLINE 			dx = x[0] - x[cur]; _NEWLINE 			dy = y[0] - y[cur]; _NEWLINE 			cur++; _NEWLINE 		} _NEWLINE 		if (dx == 0 && dy == 0) { _NEWLINE 			printf("Case #%d: MULTIPLE SOLUTIONS\n", i); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		if (dx == 0) { _NEWLINE 			printf("Case #%d: NO SOLUTIONS\n", i); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		if (dx < 0) _NEWLINE 			dx += p; _NEWLINE 		if (dy < 0) _NEWLINE 			dy += p; _NEWLINE 		long long a = (dy * pow(dx, p - 2, p)) % p; _NEWLINE 		long long b = (y[0] - a * x[0]) % p; _NEWLINE 		if (b < 0) _NEWLINE 			b += p; _NEWLINE 		bool good = true; _NEWLINE 		for (int j = 0; j < n; j++) { _NEWLINE 			if ((a * x[j] + b) % p != y[j]) { _NEWLINE 				good = false; _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if (good) _NEWLINE 			printf("Case #%d: %lld %lld\n", i, a, b); _NEWLINE 		else _NEWLINE 			printf("Case #%d: NO SOLUTIONS\n", i); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
# python3 _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _NEWLINE  _INDENT  _INDENT t = int(raw_input()) _NEWLINE  _INDENT  _INDENT l = [] _NEWLINE  _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT while(i < t and t <= 10**6): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ch = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(ch <= 10**18): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l.append(ch) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i = i + 1 _NEWLINE  _INDENT  _INDENT for i in l: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(i % 2 == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE 
def d(s1,s2): _NEWLINE  _INDENT  _INDENT if len(s1) > len(s2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s1,s2 = s2,s1 _NEWLINE  _INDENT  _INDENT distances = range(len(s1) + 1) _NEWLINE  _INDENT  _INDENT for index2,char2 in enumerate(s2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT newDistances = [index2+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for index1,char1 in enumerate(s1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if char1 == char2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT newDistances.append(distances[index1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT newDistances.append(1 + min((distances[index1], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  distances[index1+1], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  newDistances[-1]))) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT distances = newDistances _NEWLINE  _INDENT  _INDENT return distances[-1] _NEWLINE t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT s = raw_input().lower().split() _NEWLINE  _INDENT  _INDENT r = raw_input().lower().split() _NEWLINE  _INDENT  _INDENT dist = 0 _NEWLINE  _INDENT  _INDENT for i in range(len(s)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dist += d(s[i],r[i]) _NEWLINE  _INDENT  _INDENT print dist _NEWLINE 
import datetime as dt _NEWLINE T = int(raw_input()) _NEWLINE while T: _NEWLINE 	start,end=map(str,raw_input().split()) _NEWLINE 	start_dt = dt.datetime.strptime(start, '%H:%M:%S') _NEWLINE 	end_dt = dt.datetime.strptime(end, '%H:%M:%S') _NEWLINE 	diff = (end_dt - start_dt) _INDENT _NEWLINE 	diff.seconds/60 _NEWLINE 	i = 0 _INDENT _NEWLINE 	ans = str(diff) _NEWLINE 	if ans[0] == '-': _NEWLINE 		ans = ans[8:16] _NEWLINE 	if ans[1] == ':': _NEWLINE 		print ans[0], _NEWLINE 		print "HOURS", _NEWLINE 		print int(ans[2])*10+int(ans[3]), _NEWLINE 		print "MINUTES", _NEWLINE 		print int(ans[5])*10+int(ans[6]), _NEWLINE 		print "SECONDS" _NEWLINE 	else: _NEWLINE 		print int(ans[0])*10+int(ans[1]), _NEWLINE 		print "HOURS", _NEWLINE 		print int(ans[3])*10+int(ans[4]), _NEWLINE 		print "MINUTES", _NEWLINE 		print int(ans[6])*10+int(ans[7]), _NEWLINE 		print "SECONDS" _NEWLINE 	T-=1
T=input() _NEWLINE while T: _NEWLINE  _INDENT  _INDENT  _INDENT T-=1 _NEWLINE  _INDENT  _INDENT  _INDENT n,m=[int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT  _INDENT while n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr2=[] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr=raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in arr: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr2.append(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in range (0,len(arr2)/2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=arr2[len(arr2)-i-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr2[len(arr2)-1-i]=arr[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr2[i]=c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "".join(arr2) _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE 
for each_case in range(input()): _NEWLINE  _INDENT  _INDENT length=input() _NEWLINE  _INDENT  _INDENT the_list=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT for i in range(1,length+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT the_list.index(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT except Exception as error: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _NEWLINE 
t=int(raw_input()) _NEWLINE for i in range(0,t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT arr=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT mark=[0]*(n+1) _NEWLINE  _INDENT  _INDENT for u in arr: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mark[u]=mark[u]+1 _NEWLINE  _INDENT  _INDENT for i in range(1,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if mark[i]==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE 
#include <string> _NEWLINE #include <vector> _NEWLINE #include <cstdlib> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <algorithm> _NEWLINE #include <ctime> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <iostream> _NEWLINE #include <sstream> _NEWLINE #include <cstring> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <cassert> _NEWLINE #include <cctype> _NEWLINE #define MP make_pair _NEWLINE using namespace std; _NEWLINE typedef pair<int, int> PII; _NEWLINE typedef unsigned long long ULL; _NEWLINE typedef long long LL; _NEWLINE  _NEWLINE #define MOD _NEWLINE #define INF _NEWLINE #define MAXN 12 _NEWLINE  _NEWLINE const int dx[] = {-1, 1, 0, 0}; _NEWLINE const int dy[] = {0, 0, -1, 1}; _NEWLINE  _NEWLINE int R, C; _NEWLINE char grid[MAXN+1][MAXN+1]; _NEWLINE vector<PII> food; _NEWLINE  _NEWLINE void findit(PII pnt, int dc, vector<vector<int> > &adj) _NEWLINE { _NEWLINE  _INDENT  _INDENT int dp[R][C]; _NEWLINE  _INDENT  _INDENT memset(dp, -1, sizeof(dp)); _NEWLINE  _INDENT  _INDENT dp[pnt.first][pnt.second] = 0; _NEWLINE  _INDENT  _INDENT queue<PII> Q; _NEWLINE  _INDENT  _INDENT Q.push(pnt); _NEWLINE  _INDENT  _INDENT while(!Q.empty()) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT PII p = Q.front(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Q.pop(); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0; i<4; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int xx = p.first+dx[i], yy = p.second + dy[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(xx<0 || yy<0 || xx >=R || yy>=C || grid[xx][yy]=='#' || dp[xx][yy]>-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[xx][yy] = dp[p.first][p.second] + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT Q.push(MP(xx,yy)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0; i<food.size(); ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT adj[dc][i] = dp[food[i].first][food[i].second]; _NEWLINE } _NEWLINE  _NEWLINE int solve() _NEWLINE { _NEWLINE  _INDENT  _INDENT food.clear(); _NEWLINE  _INDENT  _INDENT for(int i=0; i<R; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0; j<C; ++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(grid[i][j] == 'H') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT food.push_back(MP(i,j)); _NEWLINE  _INDENT  _INDENT for(int i=0; i<R; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0; j<C; ++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(grid[i][j] == 'F') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT food.push_back(MP(i,j)); _NEWLINE  _INDENT  _INDENT int N = food.size(); _NEWLINE  _INDENT  _INDENT vector< vector <int> > adj(N, vector<int>(N)); _NEWLINE  _NEWLINE  _INDENT  _INDENT for(int i=0; i<N; ++i)for(int j=0; j<N; ++j) adj[i][j] = -1; _NEWLINE  _INDENT  _INDENT for(int i=0; i<N; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT findit(food[i], i, adj); _NEWLINE  _INDENT  _INDENT for(int i=0; i<N; ++i)for(int j=0; j<N; ++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(adj[i][j] == -1)return -1; _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT vector<int> pm(N-1); _NEWLINE  _INDENT  _INDENT int K = N-1; _NEWLINE  _INDENT  _INDENT for(int i=0; i<K; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pm[i] = i+1; _NEWLINE  _INDENT  _INDENT int rs = R*C+10; _NEWLINE  _INDENT  _INDENT do _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int r = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0; i<(K-1); ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r += adj[pm[i]][pm[i+1]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r += adj[0][pm[0]] + adj[pm[K-1]][0]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rs = min(r, rs); _NEWLINE  _INDENT  _INDENT }while(next_permutation(pm.begin(), pm.end())); _NEWLINE  _INDENT  _INDENT return rs/2; _NEWLINE } _NEWLINE  _NEWLINE void readInput() _NEWLINE { _NEWLINE  _INDENT  _INDENT scanf("%d%d", &R, &C); _NEWLINE  _INDENT  _INDENT for(int i=0; i<R; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s", grid[i]); _NEWLINE  _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _NEWLINE  _INDENT  _INDENT int testcases; _NEWLINE  _INDENT  _INDENT scanf("%d", &testcases); _NEWLINE  _INDENT  _INDENT for(int caseno=1; caseno<=testcases; caseno++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("Case %d: ", caseno); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT readInput(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n", solve()); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define lim 10000000+1 _NEWLINE int ans(int n,int k) _NEWLINE { _NEWLINE 	int r=0,p=k; _NEWLINE 	while(k<=n) _NEWLINE 	{ _NEWLINE 		r+=n/k; _NEWLINE 		k*=p; _NEWLINE 	} _NEWLINE 	//cout<<n<<" "<<k<<" "<<r<<" opopo"<<endl; _NEWLINE 	return r; _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE } _NEWLINE int an(int n,int h) _NEWLINE { _NEWLINE 	int y=0; _NEWLINE 	while(n%h==0) _NEWLINE 	{ _NEWLINE 		n/=h; _NEWLINE 		y++; _NEWLINE 	} _NEWLINE 	return y; _NEWLINE } _NEWLINE vector<int>v; _NEWLINE bool w[lim]; _NEWLINE int main() _NEWLINE { _INDENT  for(int i=2;i*i<lim;i++) _NEWLINE { _NEWLINE 	if(w[i]==false) _NEWLINE 	{ _NEWLINE 		for(int j=2*i;j<lim;j+=i) _NEWLINE 		w[j]=true; _NEWLINE 	} _NEWLINE } _NEWLINE for(int i=2;i<lim;i++) _NEWLINE { _NEWLINE 	if(w[i]==false) _NEWLINE 	v.push_back(i); _NEWLINE } _NEWLINE 	int t; _NEWLINE 	int n,k,res=1000000; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ res=1000000; _NEWLINE 	cin>>n>>k; _NEWLINE 	for(int i=0;v[i]<=k;i++) _NEWLINE 	 _NEWLINE 	{ //cout<<v[i]<<" pp"<<endl; _NEWLINE 		if(k%v[i]==0) _NEWLINE 		{ _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res=min(res,ans(n,v[i])/an(k,v[i])); _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 		} _NEWLINE } _NEWLINE  _NEWLINE 	cout<<res<<endl; _NEWLINE 	 _NEWLINE } _NEWLINE }
t = int(input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT a,b,c = map(float, raw_input().split()) _NEWLINE  _INDENT  _INDENT ans = 0.0 _NEWLINE  _INDENT  _INDENT if(a==0 and b ==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT elif (a==0 and b!=0): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (c>=b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = 1.0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = c/b _NEWLINE  _NEWLINE  _INDENT  _INDENT elif (a!=0 and b==0): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(c>=a): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = 1.0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = c/a _NEWLINE  _NEWLINE  _INDENT  _INDENT elif (c<=a and c<=b): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = ((c/a)*(c/b))/2 _NEWLINE  _NEWLINE  _INDENT  _INDENT elif (b<= c and c<a): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = (c/(2*a))*(c/b)-((c-b)/(2*a))*(c-b)/b _NEWLINE  _NEWLINE  _INDENT  _INDENT elif (a<=c and c<b): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = (c/(2*a))*(c/b)-((c-a)/(2*a))*((c-a)/b) _NEWLINE  _NEWLINE  _INDENT  _INDENT elif (c > a and c > b and c<=(a+b)): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = (c/(2*a))*(c/b)-((c-a)/(2*a))*((c-a)/b)-((c-b)/(2*a))*((c-b)/b) _NEWLINE  _NEWLINE  _INDENT  _INDENT elif c>(a+b): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT print ans
#include <stdio.h> _NEWLINE int max(int,int,int); _NEWLINE int main(void) _INDENT _NEWLINE { _NEWLINE int m,a=0,b=0,c=0,t=0; _NEWLINE scanf("%d",&t); _NEWLINE while(t--) _NEWLINE { _NEWLINE scanf("%d%d%d",&a,&b,&c); _NEWLINE m=max(a,b,c); _NEWLINE if(((m==a)&&(a==(b+c)))||((m==b)&&(b==(a+c)))||((m==c)&&(c==(b+a)))) _NEWLINE { _NEWLINE printf("1\n"); _NEWLINE } _NEWLINE else _NEWLINE { _NEWLINE  _INDENT  _INDENT printf("0\n"); _NEWLINE } _NEWLINE } _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE int max(int x,int y,int z) _NEWLINE { _NEWLINE int ma; _NEWLINE if ((x>y)&&(x>z)) _NEWLINE ma=x; _NEWLINE else if(y>z) _NEWLINE ma=y; _NEWLINE else _NEWLINE ma=z; _NEWLINE return ma; _NEWLINE }
a=1 _NEWLINE i=2 _NEWLINE l=[1]*10001 _NEWLINE  _NEWLINE eps=10**30 _NEWLINE  _NEWLINE while(i<10001): _NEWLINE 	te=i _NEWLINE 	while(te%10==0): _NEWLINE 		te/=10 _NEWLINE 	a*=te _NEWLINE 	while(a%10==0): _NEWLINE 		a/=10 _NEWLINE 	a%=eps _NEWLINE 	l[i]=a _NEWLINE 	i+=1 _NEWLINE  _NEWLINE n=input() _NEWLINE while(n>0): _NEWLINE 	print l[n]%10 _NEWLINE 	n=input() _NEWLINE 
 _NEWLINE # Fully upgraded Segment Tree _NEWLINE import math _NEWLINE """ _NEWLINE if you are not me... _NEWLINE  _INDENT tstart = tree start _NEWLINE  _INDENT qstart = query start _NEWLINE  _INDENT rest are self explanatory _NEWLINE """ _NEWLINE  _NEWLINE def middle(start,end): _NEWLINE  _INDENT  _INDENT return start + (end-start)/2 _NEWLINE  _NEWLINE def MintreeCreate(arr,n): _NEWLINE  _INDENT  _INDENT h = int(math.ceil(math.log(n,2))) _NEWLINE  _INDENT  _INDENT stree = [0]*(2*2**h-1) _NEWLINE  _INDENT  _INDENT fillMin(stree,0,n-1,arr,0) _NEWLINE  _INDENT  _INDENT return stree _NEWLINE def fillMin(stree,tstart,tend,arr,index): _NEWLINE  _INDENT  _INDENT if tstart == tend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stree[index] = arr[tstart] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return arr[tstart] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid = middle(tstart,tend) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stree[index] = min(fillMin(stree,tstart,mid,arr,index*2+1),fillMin(stree,mid+1,tend,arr,index*2+2)) _NEWLINE  _INDENT  _INDENT return stree[index] _NEWLINE  _NEWLINE def MaxtreeCreate(arr,n): _NEWLINE  _INDENT  _INDENT h = int(math.ceil(math.log(n,2))) _NEWLINE  _INDENT  _INDENT stree = [0]*(2*2**h-1) _NEWLINE  _INDENT  _INDENT fillMax(stree,0,n-1,arr,0) _NEWLINE  _INDENT  _INDENT return stree _NEWLINE def fillMax(stree,tstart,tend,arr,index): _NEWLINE  _INDENT  _INDENT if tstart == tend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stree[index] = arr[tstart] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return arr[tstart] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid = middle(tstart,tend) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stree[index] = max(fillMax(stree,tstart,mid,arr,index*2+1),fillMax(stree,mid+1,tend,arr,index*2+2)) _NEWLINE  _INDENT  _INDENT return stree[index] _NEWLINE  _NEWLINE def SumtreeCreate(arr,n): _NEWLINE  _INDENT  _INDENT h = int(math.ceil(math.log(n,2))) _NEWLINE  _INDENT  _INDENT stree = [0]*(2*2**h-1) _NEWLINE  _INDENT  _INDENT fillSum(stree,0,n-1,arr,0) _NEWLINE  _INDENT  _INDENT return stree _NEWLINE def fillSum(stree,tstart,tend,arr,index): _NEWLINE  _INDENT  _INDENT if tstart == tend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stree[index] = arr[tstart] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return arr[tstart] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid = middle(tstart,tend) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stree[index] = (fillSum(stree,tstart,mid,arr,index*2+1)+fillSum(stree,mid+1,tend,arr,index*2+2)) _NEWLINE  _INDENT  _INDENT return stree[index] _NEWLINE  _NEWLINE  _NEWLINE def getSum(stree,n,qstart,qend): _NEWLINE  _INDENT  _INDENT return getSumTill(stree,0,n-1,qstart,qend,0) _NEWLINE  _NEWLINE def getSumTill(stree,tstart,tend,qstart,qend,index): _NEWLINE  _INDENT  _INDENT if qstart <= tstart and qend >= tend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return stree[index] _NEWLINE  _INDENT  _INDENT if tend < qstart or tstart > qend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT mid = middle(tstart,tend) _NEWLINE  _INDENT  _INDENT return getSumTill(stree,tstart,mid,qstart,qend,index*2+1)+getSumTill(stree,mid+1,tend,qstart,qend,index*2+2) _NEWLINE  _NEWLINE def getMin(stree,n,qstart,qend): _NEWLINE  _INDENT  _INDENT return getMinTill(stree,0,n-1,qstart,qend,0) _NEWLINE  _NEWLINE def getMinTill(stree,tstart,tend,qstart,qend,index): _NEWLINE  _INDENT  _INDENT if qstart <= tstart and qend >= tend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return stree[index] _NEWLINE  _INDENT  _INDENT if tend < qstart or tstart > qend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 10**50 _NEWLINE  _INDENT  _INDENT mid = middle(tstart,tend) _NEWLINE  _INDENT  _INDENT return min(getMinTill(stree,tstart,mid,qstart,qend,index*2+1),getMinTill(stree,mid+1,tend,qstart,qend,index*2+2)) _NEWLINE  _NEWLINE def getMax(stree,n,qstart,qend): _NEWLINE  _INDENT  _INDENT return getMaxTill(stree,0,n-1,qstart,qend,0) _NEWLINE  _NEWLINE def getMaxTill(stree,tstart,tend,qstart,qend,index): _NEWLINE  _INDENT  _INDENT if qstart <= tstart and qend >= tend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return stree[index] _NEWLINE  _INDENT  _INDENT if tend < qstart or tstart > qend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return -10**50 _NEWLINE  _INDENT  _INDENT mid = middle(tstart,tend) _NEWLINE  _INDENT  _INDENT return max(getMaxTill(stree,tstart,mid,qstart,qend,index*2+1),getMaxTill(stree,mid+1,tend,qstart,qend,index*2+2)) _NEWLINE  _NEWLINE def updateVal(arr,stree,n,i,new_value): _NEWLINE  _INDENT  _INDENT difference = new_value - arr[i] _NEWLINE  _INDENT  _INDENT arr[i] = new_value _NEWLINE  _INDENT  _INDENT updateValTill(stree,0,n-1,i,difference,0) _NEWLINE  _NEWLINE def updateValTill(stree,tstart,tend,i,difference,index): _NEWLINE  _INDENT  _INDENT if i < tstart or i > tend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT stree[index] += difference _NEWLINE  _INDENT  _INDENT if tstart != tend: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid = middle(tstart,tend) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT updateValTill(stree,tstart,mid,i,difference,2*index+1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT updateValTill(stree,mid+1,tend,i,difference,2*index+2) _NEWLINE  _NEWLINE n,q = map(int,raw_input().split()) _NEWLINE arr = map(int,raw_input().split()) _NEWLINE MinSegmentTree = MintreeCreate(arr,n) _NEWLINE MaxSegmentTree = MaxtreeCreate(arr,n) _NEWLINE while q > 0: _NEWLINE  _INDENT  _INDENT q -= 1 _NEWLINE  _INDENT  _INDENT left,right = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print getMax(MaxSegmentTree,n,left,right)-getMin(MinSegmentTree,n,left,right)
x=raw_input() _NEWLINE x=x.split(" ") _NEWLINE y=float(x[1]) _NEWLINE y=round(y,2) _NEWLINE x=int(x[0]) _NEWLINE if x > y: _NEWLINE  _INDENT  _INDENT print y _NEWLINE elif x%5 ==0 and x< y-0.50: _NEWLINE  _INDENT  _INDENT print("{0:.2f}".format(y-x-0.50)) _NEWLINE else: _NEWLINE  _INDENT  _INDENT print y
# your code goes here _NEWLINE """author : rjohari23""" _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE while t: _NEWLINE 	no = raw_input() _NEWLINE 	ans = '' _NEWLINE 	 _NEWLINE 	for i in range(10): _NEWLINE 		if no[i] == '0': _NEWLINE 			ans += '-----' _NEWLINE 		if no[i] == '1': _NEWLINE 			ans += '.----' _NEWLINE 		if no[i] == '2': _NEWLINE 			ans += '..---' _NEWLINE 		if no[i] == '3': _NEWLINE 			ans += '...--' _NEWLINE 		if no[i] == '4': _NEWLINE 			ans += '....-' _NEWLINE 		if no[i] == '5': _NEWLINE 			ans += '.....' _NEWLINE 		if no[i] == '6': _NEWLINE 			ans += '-....' _NEWLINE 		if no[i] == '7': _NEWLINE 			ans += '--...' _NEWLINE 		if no[i] == '8': _NEWLINE 			ans += '---..' _NEWLINE 		if no[i] == '9': _NEWLINE 			ans += '----.' _NEWLINE 		 _NEWLINE 	print ans _NEWLINE 	print ans.count('.') _NEWLINE 	 _NEWLINE 	t -= 1
def len(n): _NEWLINE  _INDENT  _INDENT l=0 _NEWLINE  _INDENT  _INDENT while n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n/=10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l+=1 _NEWLINE  _INDENT  _INDENT return l _NEWLINE  _NEWLINE def isprime(n): _NEWLINE  _INDENT  _INDENT if n==2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT var=None _NEWLINE  _INDENT  _INDENT for i in xrange(2,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT var=i _NEWLINE  _INDENT  _INDENT if var==n-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE def num_rot(n,f): _NEWLINE  _INDENT  _INDENT l=len(n)-1 _NEWLINE  _INDENT  _INDENT while f: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=n%10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n/=10 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n+=i*(10**l) _NEWLINE  _INDENT  _INDENT return n _NEWLINE  _NEWLINE def cir_prime(n): _NEWLINE  _INDENT  _INDENT k=n _NEWLINE  _INDENT  _INDENT l=len(n) _NEWLINE  _INDENT  _INDENT if isprime(k)==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while l!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=num_rot(n,l) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if isprime(k)!=1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if k<n and cir_prime(k)!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE t=int(input()) _NEWLINE a=raw_input().split(" ") _NEWLINE for j in a: _NEWLINE  _INDENT  _INDENT print cir_prime(int(j)), _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
t = input() _NEWLINE for i in range(t): _NEWLINE 	n = input() _NEWLINE 	a = map(int,raw_input().split()) _NEWLINE 	a.sort() _NEWLINE 	for j in a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print j 
n = int(raw_input()) _NEWLINE a, b, c = map(int, raw_input().split()) _NEWLINE l = map(int, raw_input().split()) _NEWLINE ans, count = 0, 0 _NEWLINE ans = a*a + b*b + c*c _NEWLINE for i in xrange(len(l)): _NEWLINE 	if l[i]*l[i]<=ans: _NEWLINE 		count = count + 1 _NEWLINE print count _NEWLINE 		 _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	// your code goes here _NEWLINE 	int n,m; _NEWLINE 	cin>>n>>m; _NEWLINE 	int mval=INT_MIN; _NEWLINE 	for(int i=0;i<n;i++) _NEWLINE 	{ _NEWLINE 		int x; _NEWLINE 		int temp=INT_MAX; _NEWLINE 		for(int j=0;j<m;j++) _NEWLINE 		{ _NEWLINE 			cin>>x; _NEWLINE 			temp=min(temp,x); _NEWLINE 		} _NEWLINE 		mval=max(mval,temp); _NEWLINE 	} _NEWLINE 	cout<<mval<<endl; _NEWLINE 	return 0; _NEWLINE }
INF=10**20 _NEWLINE ZERO=0 _NEWLINE  _NEWLINE def buildMaxTree(pos,start,end): _NEWLINE  _INDENT  _INDENT if (start==end): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT min_tree_arr[pos]=a[start] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return None _NEWLINE  _INDENT  _INDENT mid =(start+end)/2 _NEWLINE  _INDENT  _INDENT buildMaxTree(2*pos,start,mid) _NEWLINE  _INDENT  _INDENT buildMaxTree(2*pos+1,mid+1,end) _NEWLINE  _INDENT  _INDENT min_tree_arr[pos]=max(min_tree_arr[2*pos],min_tree_arr[2*pos+1]) _NEWLINE  _NEWLINE def buildMinTree(pos,start,end): _NEWLINE  _INDENT  _INDENT if (start==end): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT max_tree_arr[pos]=a[start] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return None _NEWLINE  _INDENT  _INDENT mid =(start+end)/2 _NEWLINE  _INDENT  _INDENT buildMinTree(2*pos,start,mid) _NEWLINE  _INDENT  _INDENT buildMinTree(2*pos+1,mid+1,end) _NEWLINE  _INDENT  _INDENT max_tree_arr[pos]=min(max_tree_arr[2*pos],max_tree_arr[2*pos+1]) _NEWLINE  _NEWLINE def queryMaxTree(pos,start,end,l,r): _NEWLINE  _INDENT  _INDENT if (l>end or r<start) or (l>r): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return ZERO _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  #No-Overlap _NEWLINE  _INDENT  _INDENT if (l<=start and r>=end): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return min_tree_arr[pos] _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #Total-Overlap _NEWLINE  _INDENT  _INDENT mid=(start+end)/2 _INDENT _NEWLINE  _INDENT  _INDENT left=queryMaxTree(2*pos,start,mid,l,r) _NEWLINE  _INDENT  _INDENT right=queryMaxTree(2*pos+1,mid+1,end,l,r) _NEWLINE  _INDENT  _INDENT return max(left,right) _NEWLINE  _NEWLINE def queryMinTree(pos,start,end,l,r): _NEWLINE  _INDENT  _INDENT if (l>end or r<start) or (l>r): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return INF _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #No-Overlap _NEWLINE  _INDENT  _INDENT if (l<=start and r>=end): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return max_tree_arr[pos] _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #Total-Overlap _NEWLINE  _INDENT  _INDENT mid=(start+end)/2 _NEWLINE  _INDENT  _INDENT left=queryMinTree(2*pos,start,mid,l,r) _NEWLINE  _INDENT  _INDENT right=queryMinTree(2*pos+1,mid+1,end,l,r) _NEWLINE  _INDENT  _INDENT return min(left,right) _NEWLINE  _NEWLINE a=[0] _NEWLINE n=input() _NEWLINE arr=map(int,raw_input().split()) _NEWLINE a.extend(arr) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  #To_make_1-based-indexing _NEWLINE  _NEWLINE min_tree_arr=[0]*(4*n+1) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #max_segment_tree_size _NEWLINE max_tree_arr=[0]*(4*n+1) _NEWLINE  _NEWLINE buildMaxTree(1,1,n) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  #Tree_building_process _NEWLINE buildMinTree(1,1,n) _NEWLINE  _NEWLINE for query in xrange(input()): _NEWLINE  _INDENT  _INDENT l,r=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT l+=1 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #To_make_1-based-indexing _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT r+=1 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #To_make_1-based-indexing _NEWLINE  _INDENT  _INDENT minn=queryMinTree(1,1,n,l,r) _NEWLINE  _INDENT  _INDENT maxx=queryMaxTree(1,1,n,l,r) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #Tree_querying_process _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT max_left=queryMaxTree(1,1,n,1,l-1) _NEWLINE  _INDENT  _INDENT max_right=queryMaxTree(1,1,n,r+1,n) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT max_outer=max(max_left,max_right)+minn _NEWLINE  _INDENT  _INDENT max_inner=minn+(maxx-minn)/2.0 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if(max_inner>max_outer): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print max_inner _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print float(max_outer) _NEWLINE 
#!/bin/python _NEWLINE  _NEWLINE T=int(raw_input()) _NEWLINE while T: _NEWLINE 	S=raw_input() _NEWLINE 	F=1 _NEWLINE 	for i in range(0,len(S)/2+1): _NEWLINE 		if S[i]==S[len(S)-1-i]: _NEWLINE 			continue _NEWLINE 		else: _INDENT _NEWLINE 			F=0 _NEWLINE 			break _NEWLINE 	if F: _NEWLINE 		print 'YES' _NEWLINE 	else: print 'NO' _NEWLINE 	T-=1
def readInt(d): _NEWLINE  _INDENT  _INDENT return map(int, raw_input().strip().split(d)) _NEWLINE #print readInt(',') _NEWLINE  _NEWLINE def f(N, K, M): _NEWLINE 	if K==1: return N; _NEWLINE 	while M > 0 and N%K == 0: _NEWLINE 		M -= 1 _NEWLINE 		N /= K _NEWLINE 	if M == 0: return N; _NEWLINE 	if M%2 == 0: _NEWLINE 		return N; _NEWLINE 	return N*K; _NEWLINE  _NEWLINE t = input() _NEWLINE for _ in xrange(t): _NEWLINE 	N,K,M = readInt(' ') _NEWLINE 	print f(N,K,M) _NEWLINE 
for _ in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT li=[0] _NEWLINE  _INDENT  _INDENT lis=map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT li+=lis _NEWLINE  _INDENT  _INDENT ans=0 _NEWLINE  _INDENT  _INDENT inc=2 _NEWLINE  _INDENT  _INDENT while(inc<=n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(inc, n+1, inc): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp+=li[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=max(ans, temp) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT inc+=1 _NEWLINE  _INDENT  _INDENT print ans _NEWLINE  _INDENT  _INDENT 
a=input() _NEWLINE b=input() _NEWLINE print(a*b)
import sys _NEWLINE  _NEWLINE for __ in range(input()) : _NEWLINE  _INDENT  _INDENT n = input() _NEWLINE  _INDENT  _INDENT if n==1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT k = n _NEWLINE  _INDENT  _INDENT os , es = n/2 if not n&1 else (n/2)+1 , 0 _NEWLINE  _INDENT  _INDENT n = n/2 _INDENT _NEWLINE  _INDENT  _INDENT es = 2*(n*(n+1)/2) _NEWLINE  _INDENT  _INDENT if k&1 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT os += 2*(n*(n-1)/2) _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT os += 2*(n*(n-1)/2) _NEWLINE  _INDENT  _INDENT print os-es
t=input() _NEWLINE while t>0: _NEWLINE 	n=input() _NEWLINE 	B=[] _NEWLINE 	for i in xrange(n): _NEWLINE 		A=raw_input() _NEWLINE 		A=sorted(A) _NEWLINE 		B.append(A[len(A)/2]) _NEWLINE 	print "".join(B) _NEWLINE 	t=t-1 _NEWLINE 	 _NEWLINE 		
t = int(raw_input()) _NEWLINE for tt in range(t) : _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT m = int(raw_input()) _NEWLINE  _INDENT  _INDENT k = int(raw_input()) _NEWLINE  _INDENT  _INDENT print pow(n,m,k) 
#BISMILLAH _NEWLINE #NCRAAS _NEWLINE import operator as op _NEWLINE import math _NEWLINE  _NEWLINE def ncr(n, r): _NEWLINE 	r = min(r, n-r) _NEWLINE 	if r == 0: return n _NEWLINE 	num = reduce(op.mul, xrange(n, n-r, -1)) _NEWLINE 	denom = reduce(op.mul, xrange(1, r+1)) _NEWLINE 	return num//denom _NEWLINE  _NEWLINE if __name__ == '__main__' : _NEWLINE 	T=raw_input() _NEWLINE 	T=int(T) _NEWLINE 	while T > 0 : _NEWLINE 		s=raw_input().split(' ') _NEWLINE 		n=int(s[0]) _NEWLINE 		m=int(s[1]) _NEWLINE 		value = math.factorial(n)/math.factorial(m)/math.factorial(n-m) _NEWLINE 		if value ==1 : _NEWLINE 			print "1 1" _NEWLINE 		else : _NEWLINE 			print int(math.log(value,10))+1,int(math.log(value,2))+1 _NEWLINE 		T-=1 _NEWLINE  _NEWLINE 
/***********Template Starts Here***********/ _NEWLINE //#include <bits/stdc++.h> _NEWLINE #include <cstdio> _NEWLINE #include <cstring> _NEWLINE #include <cmath> _NEWLINE #include <algorithm> _NEWLINE #include <map> _NEWLINE #include <queue> _NEWLINE #include <stack> _NEWLINE #include <vector> _NEWLINE #include <deque> _NEWLINE #include <functional> _NEWLINE #include <string> _NEWLINE #include <iostream> _NEWLINE #include <cctype> _NEWLINE #include <set> _NEWLINE #include <climits> _NEWLINE #include <iomanip> _NEWLINE #include <cassert> _NEWLINE #include <sstream> _NEWLINE //#include <unordered_map> _NEWLINE  _NEWLINE #define pb push_back _NEWLINE #define nl puts ("") _NEWLINE #define sp printf ( " " ) _NEWLINE #define phl printf ( "hello\n" ) _NEWLINE #define ff first _NEWLINE #define ss second _NEWLINE #define POPCOUNT __builtin_popcountll _NEWLINE #define RIGHTMOST __builtin_ctzll _NEWLINE #define LEFTMOST(x) (63-__builtin_clzll((x))) _NEWLINE #define MP make_pair _NEWLINE #define FOR(i,x,y) for(int i = (x) ; i <= (y) ; ++i) _NEWLINE #define ROF(i,x,y) for(int i = (y) ; i >= (x) ; --i) _NEWLINE #define CLR(x,y) memset(x,y,sizeof(x)) _NEWLINE #define UNIQUE(V) (V).erase(unique((V).begin(),(V).end()),(V).end()) _NEWLINE #define MIN(a,b) ((a)<(b)?(a):(b)) _NEWLINE #define MAX(a,b) ((a)>(b)?(a):(b)) _NEWLINE #define NUMDIGIT(x,y) (((int)(log10((x))/log10((y))))+1) _NEWLINE #define SQ(x) ((x)*(x)) _NEWLINE #define ABS(x) ((x)<0?-(x):(x)) _NEWLINE #define FABS(x) ((x)+eps<0?-(x):(x)) _NEWLINE #define ALL(x) (x).begin(),(x).end() _NEWLINE #define LCM(x,y) (((x)/gcd((x),(y)))*(y)) _NEWLINE #define SZ(x) ((int)(x).size()) _NEWLINE #define LL long long _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long vlong; _NEWLINE typedef unsigned long long uvlong; _NEWLINE typedef pair < int, int > pii; _NEWLINE typedef pair < vlong, vlong > pll; _NEWLINE typedef vector<pii> vii; _NEWLINE typedef vector<int> vi; _NEWLINE  _NEWLINE const vlong inf = 2147383647; _NEWLINE const double pi = 2 * acos ( 0.0 ); _NEWLINE const double eps = 1e-9; _NEWLINE  _NEWLINE #ifdef forthright48 _NEWLINE  _INDENT  _INDENT  #include <ctime> _NEWLINE  _INDENT  _INDENT  clock_t tStart = clock(); _NEWLINE  _INDENT  _INDENT  #define debug(args...) {dbg,args; cerr<<endl;} _NEWLINE  _INDENT  _INDENT  #define timeStamp printf("Execution Time: %.2fs\n", (double)(clock() - tStart)/CLOCKS_PER_SEC) _NEWLINE #else _NEWLINE  _INDENT  _INDENT #define debug(args...) _INDENT // Just strip off all debug tokens _NEWLINE  _INDENT  _INDENT #define timeStamp _NEWLINE #endif _NEWLINE  _NEWLINE struct debugger{ _NEWLINE  _INDENT  _INDENT template<typename T> debugger& operator , (const T& v){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cerr<<v<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return *this; _NEWLINE  _INDENT  _INDENT } _NEWLINE }dbg; _NEWLINE  _NEWLINE //int knightDir[8][2] = { {-2,1},{-1,2},{1,2},{2,1},{2,-1},{-1,-2},{1,-2},{-2,-1} }; _NEWLINE //int dir4[4][2] = {{-1,0},{0,1},{1,0},{0,-1}}; _NEWLINE  _NEWLINE inline vlong gcd ( vlong a, vlong b ) { _NEWLINE  _INDENT  _INDENT a = ABS ( a ); b = ABS ( b ); _NEWLINE  _INDENT  _INDENT while ( b ) { a = a % b; swap ( a, b ); } return a; _NEWLINE } _NEWLINE  _NEWLINE vlong ext_gcd ( vlong A, vlong B, vlong *X, vlong *Y ){ _NEWLINE  _INDENT  _INDENT vlong x, y, u, v, m, n, a, b, q, r; _NEWLINE  _INDENT  _INDENT x = 0; y = 1; _NEWLINE  _INDENT  _INDENT u = 1; v = 0; _NEWLINE  _INDENT  _INDENT for (a = A, b = B; 0 != a; b = a, a = r, x = u, y = v, u = m, v = n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q = b / a; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r = b % a; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m = x - (u * q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = y - (v * q); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT *X = x; *Y = y; _NEWLINE  _INDENT  _INDENT return b; _NEWLINE } _NEWLINE  _NEWLINE inline vlong modInv ( vlong a, vlong m ) { _NEWLINE  _INDENT  _INDENT vlong x, y; _NEWLINE  _INDENT  _INDENT ext_gcd( a, m, &x, &y ); _NEWLINE  _INDENT  _INDENT if ( x < 0 ) x += m; //modInv is never negative _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE  _NEWLINE inline vlong power ( vlong a, vlong p ) { _NEWLINE  _INDENT  _INDENT vlong res = 1, x = a; _NEWLINE  _INDENT  _INDENT while ( p ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ( p & 1 ) res = ( res * x ); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = ( x * x ); p >>= 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _NEWLINE inline vlong bigmod ( vlong a, vlong p, vlong m ) { _NEWLINE  _INDENT  _INDENT vlong res = 1 % m, x = a % m; _NEWLINE  _INDENT  _INDENT while ( p ) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ( p & 1 ) res = ( res * x ) % m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = ( x * x ) % m; p >>= 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _NEWLINE /***********Template Ends Here***********/ _NEWLINE  _NEWLINE LL t, tc = 0; _NEWLINE LL n, m, c[10005], d[10005]; _NEWLINE LL dp[2002], cur, now; _NEWLINE pll st[2002]; _NEWLINE  _NEWLINE bool meet(pll p1, pll p2, LL pos) { _NEWLINE  _INDENT  _INDENT LL v1 = p1.ff*pos + p1.ss; _NEWLINE  _INDENT  _INDENT LL v2 = p2.ff*pos + p2.ss; _NEWLINE  _INDENT  _INDENT return v1 > v2; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main () { _NEWLINE  _INDENT  _INDENT #ifdef forthright48 _NEWLINE  _INDENT  _INDENT freopen ( "zz_test.txt", "r", stdin ); _NEWLINE  _INDENT  _INDENT //freopen ( "output.txt", "w", stdout ); _NEWLINE  _INDENT  _INDENT #endif // forthright48 _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%lld", &t); _NEWLINE  _NEWLINE  _INDENT  _INDENT while (tc<t) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tc++; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld", &n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld", &m); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (LL i=1; i<=n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld", &c[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(c+1,c+1+n); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i=1; i<=n; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[i] = d[i-1] + c[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT CLR(dp,-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[0] = 0; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int mm=1; mm<=m; mm++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cur = now = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT st[cur++] = MP (n-mm+1,dp[mm-1]-(n-mm+1)*d[mm-1]); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //debug(st[0].ff , st[0].ss); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int i=mm; i<=n; i++) { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT LL last = dp[i]; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (now < cur-1 && meet(st[now],st[now+1],d[i])) { now++; } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i] = d[i]*st[now].ff + st[now].ss; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //debug(i, "~", dp[i], d[i], st[now].ff, st[now].ss); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pll ins = MP (n-i,last-d[i]*(n-i)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (last == -1) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT st[cur++] = ins; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //debug(mm, "->", dp[n]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", dp[n]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
 _NEWLINE import sys _NEWLINE  _NEWLINE T = int(raw_input()) _NEWLINE  _NEWLINE while T : _NEWLINE  _NEWLINE 	a , b = map(list,sys.stdin.readline().split()) _NEWLINE 	 _NEWLINE 	 _NEWLINE 	i = 0 _NEWLINE 	j = len(a) - 1 _NEWLINE 	 _NEWLINE 	while i <= j : _NEWLINE 		t = a[i] _NEWLINE 		a[i] = a[j] _INDENT _NEWLINE 		a[j] = t _NEWLINE 		i+=1 _NEWLINE 		j-=1 _NEWLINE 	 _NEWLINE 	i = 0 _NEWLINE 	j = len(b)-1 _NEWLINE 	 _NEWLINE 	while i<= j : _NEWLINE 		t = b[i] _NEWLINE 		b[i] = b[j] _INDENT _NEWLINE 		b[j] = t _NEWLINE 		i+=1 _NEWLINE 		j-=1 _NEWLINE 	 _NEWLINE 	a = "".join(a) _NEWLINE 	a = int(a) _NEWLINE 	b = "".join(b) _NEWLINE 	b = int(b) _NEWLINE 	 _NEWLINE 	a+=b _NEWLINE 	 _NEWLINE 	a = list(str(a)) _NEWLINE 	 _NEWLINE 	i = 0 _NEWLINE 	j = len(a) - 1 _NEWLINE 	 _NEWLINE 	while i <= j : _NEWLINE 		t = a[i] _NEWLINE 		a[i] = a[j] _INDENT _NEWLINE 		a[j] = t _NEWLINE 		i+=1 _NEWLINE 		j-=1 _NEWLINE 	 _NEWLINE 	a = "".join(a) _NEWLINE 	a = int(a) _NEWLINE 	print a _NEWLINE 	T-=1 _NEWLINE 	
t = int(raw_input()) _NEWLINE for _ in range(t): _NEWLINE 	n = int(raw_input()) _NEWLINE 	n+=1 _NEWLINE 	while True: _NEWLINE 		tmp = str(n) _NEWLINE 		if tmp==tmp[::-1]: _NEWLINE 			print tmp _NEWLINE 			break _NEWLINE 		n+=1 _NEWLINE 
T=input() _NEWLINE while T: _NEWLINE  _INDENT  _INDENT T-=1 _NEWLINE  _INDENT  _INDENT inv=0 _NEWLINE  _INDENT  _INDENT N=list(str(input())) _NEWLINE  _INDENT  _INDENT length=len(N) _NEWLINE  _INDENT  _INDENT for i in range(0,length): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N[i]=int(N[i]) _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT while i<length-1 and N[i+1]==N[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT if i==length-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'valid' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT if N[i+1]>N[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while i<length-1 and N[i+1]>=N[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i==length-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'valid' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif N[i+1]<N[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'invalid' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT elif N[i+1]<N[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while i<length-1 and N[i+1]<=N[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i==length-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'valid' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif N[i+1]>N[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'invalid' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE 
a=list(map(int,raw_input().split())) _NEWLINE b=list(map(int,raw_input().split())) _NEWLINE arr=[] _NEWLINE for i in range(1,len(a)): _NEWLINE  _INDENT  _INDENT for j in range(1,len(b)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr.append(abs(a[i]-b[j])) _NEWLINE arr=sorted(arr) _NEWLINE print arr[0]
#!/usr/bin/env python _NEWLINE  _NEWLINE ALPHA _INDENT = ''.join(map(lambda x: chr(65 + x), range(26))) _NEWLINE ALPHA += ALPHA.lower() _NEWLINE ALPHA += ''.join(map(str, range(10))) _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S = raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT except: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT W = '' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R = '' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for c in S: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if _INDENT c in ALPHA: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT W += c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT R += ''.join(reversed(W)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT R += c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT W _INDENT = '' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if W: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT R += ''.join(reversed(W)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print R _NEWLINE  _NEWLINE main() _NEWLINE  _NEWLINE 
t=int(input()) _NEWLINE while(t>0): _NEWLINE 	n=int(input()) _NEWLINE 	a=map(int,raw_input().split(" ")) _NEWLINE 	i=n-1 _NEWLINE 	m=a[i] _NEWLINE 	ans=0 _NEWLINE 	i=n-2 _NEWLINE 	while(i>=0): _NEWLINE 		if(m>a[i]): _NEWLINE 			ans+=m-a[i] _NEWLINE 		elif(m<a[i]): _NEWLINE 			m=a[i] _NEWLINE 		i-=1 _NEWLINE 	print ans _NEWLINE 			 _NEWLINE 	t-=1 _NEWLINE 
cases = int(raw_input()) _NEWLINE  _NEWLINE for case in xrange(cases): _NEWLINE  _INDENT  initial_number = int(raw_input()) _NEWLINE  _INDENT  if initial_number % 4: _NEWLINE  _INDENT  _INDENT  _INDENT  print "First" _NEWLINE  _INDENT  else: _NEWLINE  _INDENT  _INDENT  _INDENT  print "Second"
for t in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT a = [[0]*4 for x in range(4)] _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT (x, y) = (int(j) for j in raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT index = -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if y > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT index = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif y < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT index = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif x < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if y < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT index = 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif y > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT index = 3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if index != -1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[index][((abs(x) & 1) * 2) + (abs(y) & 1)] += 1 _NEWLINE  _INDENT  _INDENT result = 0 _NEWLINE  _INDENT  _INDENT for i1 in range(4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i2 in range(4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i3 in range(4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i4 in range(4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x1 = i1 ^ i2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x1 &= x1 >> 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x2 = i2 ^ i3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x2 &= x2 >> 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x3 = i3 ^ i4 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x3 &= x3 >> 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x4 = i4 ^ i1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x4 &= x4 >> 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = x1 ^ x2 ^ x3 ^ x4 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if x == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result += a[0][i1] * a[1][i2] * a[2][i3] * a[3][i4] _NEWLINE  _INDENT  _INDENT print result
# your code goes here _NEWLINE m,n = map(int,raw_input().split()) _NEWLINE a = [] _NEWLINE for _ in range(m): _NEWLINE 	a.append(map(int,raw_input().split())) _NEWLINE  _NEWLINE flag = 1 _NEWLINE for i in range(m): _NEWLINE 	for j in range(n): _NEWLINE 		if j > 0: _NEWLINE 			if a[i][j-1] != a[i][j]: _NEWLINE 				flag = 0 _NEWLINE 				break _NEWLINE 		if i > 0: _NEWLINE 			if a[i-1][j] == a[i][j]: _NEWLINE 				flag = 0 _NEWLINE 				break _NEWLINE 		 _NEWLINE 	if flag == 0: _NEWLINE 		break _NEWLINE  _NEWLINE if flag == 0: _NEWLINE 	print "NO" _NEWLINE else: _NEWLINE 	print "YES"
from math import factorial as fac _NEWLINE def catalan(n): _NEWLINE  _INDENT  _INDENT return fac(2*n) // fac(n+1) // fac(n) _NEWLINE  _INDENT _NEWLINE def num_handshakes(n): _NEWLINE  _INDENT  _INDENT if n % 2 == 1: return 0 _NEWLINE  _INDENT  _INDENT return catalan(n//2) _NEWLINE T=int(raw_input()) _NEWLINE while T>0: _NEWLINE  _INDENT  _INDENT N=int(raw_input()) _NEWLINE  _INDENT  _INDENT print num_handshakes(2*N) %100003 _NEWLINE  _INDENT  _INDENT T=T-1
#!/usr/bin/python _NEWLINE  _NEWLINE if __name__=="__main__": _NEWLINE 	N=input() _NEWLINE 	while(N): _NEWLINE 		s=raw_input() _NEWLINE 		l=len(s) _NEWLINE 		x="" _NEWLINE 		f=0 _NEWLINE 		for i in range(l): _NEWLINE 			if s[l-i-1]=='4' and f==0: _NEWLINE 				x='7'+x _NEWLINE 				f=1 _NEWLINE 			elif s[l-i-1]=='7' and f==0: _NEWLINE 				x='4'+x _NEWLINE 			else: x=s[l-i-1]+x		 _NEWLINE 		if f==0: _NEWLINE 			print '4'+x _NEWLINE 		else:print x _NEWLINE 		N-=1 _NEWLINE 
import datetime _NEWLINE dt='21/03/2012' _NEWLINE day, month, year = (int(x) for x in dt.split('/')) _INDENT  _INDENT  _NEWLINE ans=datetime.date(year,month,day) _NEWLINE print (ans.strftime("%A"))
x=int(raw_input()) _NEWLINE l=int(raw_input()) _NEWLINE b=int(raw_input()) _NEWLINE y=0 _NEWLINE while(x): _NEWLINE  _INDENT  _INDENT a=int(raw_input()) _NEWLINE  _INDENT  _INDENT y=y+a _NEWLINE  _INDENT  _INDENT x-=1 _NEWLINE if(y==(l*b)): _NEWLINE  _INDENT  _INDENT  print "YES" _NEWLINE else: _NEWLINE  _INDENT  _INDENT  print "NO" _NEWLINE 
#include <bits/stdc++.h> _NEWLINE  _NEWLINE #define clr(x) memset((x), 0, sizeof(x)) _NEWLINE #define all(x) (x).begin(), (x).end() _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define in(x) int (x); input((x)); _NEWLINE #define x first _NEWLINE #define y second _NEWLINE typedef int itn; _NEWLINE  _NEWLINE //#define next next12345 _NEWLINE //#define prev prev12345 _NEWLINE #define left lefdsf232 _NEWLINE #define right rig43783 _NEWLINE #define x1 x12345 _NEWLINE #define y1 y12345 _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE template<typename T> _NEWLINE T gcd(T x, T y) { _NEWLINE  _INDENT  _INDENT while (y > 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x %= y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT swap(x, y); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE  _NEWLINE template<class T> _NEWLINE T lcm(T a, T b) { _NEWLINE  _INDENT  _INDENT return a / gcd(a, b) * b; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE template<class _T> _NEWLINE inline _T sqr(const _T &x) { _NEWLINE  _INDENT  _INDENT return x * x; _NEWLINE } _NEWLINE  _NEWLINE template<class _T> _NEWLINE inline string tostr(const _T &a) { _NEWLINE  _INDENT  _INDENT ostringstream os(""); _NEWLINE  _INDENT  _INDENT os << a; _NEWLINE  _INDENT  _INDENT return os.str(); _NEWLINE } _NEWLINE  _NEWLINE typedef long double ld; _NEWLINE typedef long long ll; _NEWLINE typedef unsigned long long ull; _NEWLINE typedef pair<int, int> PII; _NEWLINE const ld PI = 3.1415926535897932384626433832795L; _NEWLINE  _NEWLINE template<typename T> _NEWLINE inline void input(T &a) { _NEWLINE  _INDENT  _INDENT static int ed; _NEWLINE  _INDENT  _INDENT a = 0; _NEWLINE  _INDENT  _INDENT while (!isdigit(ed = getchar()) && ed != '-') { } _NEWLINE  _INDENT  _INDENT char neg = 0; _NEWLINE  _INDENT  _INDENT if (ed == '-') { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT neg = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ed = getchar(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while (isdigit(ed)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = 10 * a + ed - '0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ed = getchar(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if (neg) a = -a; _NEWLINE } _NEWLINE  _NEWLINE template<typename T = int> _NEWLINE inline T nxt() { _NEWLINE  _INDENT  _INDENT T res; _NEWLINE  _INDENT  _INDENT input(res); _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _NEWLINE mt19937 generator; _NEWLINE  _NEWLINE bool check(int v) { _NEWLINE  _INDENT  _INDENT if (v < 2) return false; _NEWLINE  _INDENT  _INDENT for (int i = 2; i * i <= v; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (v % i == 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return true; _NEWLINE } _NEWLINE  _NEWLINE long long pw(long long a, long long n, long long m) { _NEWLINE  _INDENT  _INDENT ll res = 1; _NEWLINE  _INDENT  _INDENT while (n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (n & 1ll) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res = res * a % m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = a * a % m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n >>= 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE void pre() { _NEWLINE } _NEWLINE  _NEWLINE void gen() { _NEWLINE } _NEWLINE  _NEWLINE const int N = 3000; _NEWLINE  _NEWLINE vector <int> g[N]; _NEWLINE  _NEWLINE int dp[N][N]; _NEWLINE  _NEWLINE int leaves[N]; _NEWLINE  _NEWLINE int l; _NEWLINE  _NEWLINE void dfs(int v, int p) { _NEWLINE  _INDENT  _INDENT int ch = 0; _NEWLINE  _INDENT  _INDENT leaves[v] = 0; _NEWLINE  _INDENT  _INDENT for (int to : g[v]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (to == p) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs(to, v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT leaves[v] += leaves[to]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ch += 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT if (ch == 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[v][0] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[v][1] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT leaves[v] = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT for (int i = 0; i <= leaves[v] && i <= l; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[v][i] = 0x3f3f3f3f; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT dp[v][0] = 0; _NEWLINE  _INDENT  _INDENT if (leaves[v] <= l) dp[v][leaves[v]] = 1; _NEWLINE  _NEWLINE  _INDENT  _INDENT int s = 0; _NEWLINE  _NEWLINE  _INDENT  _INDENT for (int to : g[v]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (to == p) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int k = min(s, l); k >= 0; --k) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 1; j <= leaves[to] && j + k <= l; ++j) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[v][k + j] = min(dp[v][k + j], dp[v][k] + dp[to][j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s += leaves[to]; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE void read() { _NEWLINE  _INDENT  _INDENT int n = nxt(); _NEWLINE  _NEWLINE  _INDENT  _INDENT for (int i = 1; i < n; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int u = nxt() - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int v = nxt() - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT g[u].pb(v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT g[v].pb(u); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT for (int i = 0; i < n; ++i) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l += g[i].size() == 1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT l /= 2; _NEWLINE  _INDENT  _INDENT int ans = l; _NEWLINE  _INDENT  _INDENT int z = 0; _NEWLINE  _INDENT  _INDENT vector <int> order(n); _NEWLINE  _INDENT  _INDENT iota(all(order), 0); _NEWLINE  _INDENT  _INDENT random_shuffle(all(order)); _NEWLINE  _INDENT  _INDENT double mt; _NEWLINE  _INDENT  _INDENT while (z < n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int root = order[z++]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT double start = clock(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs(root, root); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT double end = clock(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (z == 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mt = end - start; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = min(ans, dp[root][l]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (end + mt > 1.9 * CLOCKS_PER_SEC) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout << ans << "\n"; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE void solve2() { } _NEWLINE  _NEWLINE  _NEWLINE int main(int argc, char ** argv) { _NEWLINE  _NEWLINE #ifdef LOCAL _NEWLINE  _INDENT  _INDENT freopen("input.txt", "r", stdin); _NEWLINE  _INDENT  _INDENT //freopen("output.txt", "w", stdout); _NEWLINE #else _NEWLINE  _INDENT  _INDENT #define fname "d" _NEWLINE  _INDENT  _INDENT //freopen(fname".in", "r", stdin); _NEWLINE  _INDENT  _INDENT //freopen(fname".out", "w", stdout); _NEWLINE #endif _NEWLINE  _INDENT  _INDENT int t = 1; _NEWLINE  _INDENT  _INDENT pre(); _NEWLINE #ifdef LOCAL _NEWLINE #endif _NEWLINE  _NEWLINE // _INDENT  _INDENT test(); _NEWLINE  _NEWLINE  _INDENT  _INDENT int c = 0; _NEWLINE  _INDENT  _INDENT while (t--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //gen(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT read(); _NEWLINE // _INDENT  _INDENT  _INDENT  _INDENT gen(); _NEWLINE // _INDENT  _INDENT  _INDENT  _INDENT gen2(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE #ifdef LOCAL _NEWLINE  _INDENT  _INDENT cerr << "Time elapsed: " << 1.0 * clock() / CLOCKS_PER_SEC * 1000 << " ms." << endl; _NEWLINE #endif _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
t=int(raw_input()) _NEWLINE mod=1000000007 _NEWLINE fact=[] _NEWLINE def power(a,b): _NEWLINE  _INDENT  _INDENT if b==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=power(a,b/2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l=(l*l)%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if b%2==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return (l*a)%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return l _NEWLINE  _NEWLINE  _NEWLINE def factoria(n): _NEWLINE  _INDENT  _INDENT fact.append(1) _NEWLINE  _INDENT  _INDENT for i in range(1,100010): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num=(fact[i-1]*i)%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fact.append(num) _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT temp=raw_input().split(' ') _NEWLINE  _INDENT  _INDENT n=int(temp[0]) _NEWLINE  _INDENT  _INDENT k=int(temp[1]) _NEWLINE  _INDENT  _INDENT if n<k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "0" _NEWLINE  _INDENT  _INDENT else: _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT factoria(100000) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans1=fact[n-k] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans2=fact[k] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=(power(ans1,mod-2)*power(ans2,mod-2))%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans*fact[n])%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE 
for i in range(10): _NEWLINE  _INDENT  _INDENT a=set() _NEWLINE  _INDENT  _INDENT for k in range(10): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t=int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a.add(t%42) _NEWLINE  _INDENT  _INDENT print len(a)
def calc2(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tp=n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s='' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while tp>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=tp%9 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(k==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=9 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=str(k)+s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tp=(tp-k)/9 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return int(s) _INDENT  _INDENT  _NEWLINE def calc1(n,d): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT di=dict() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(0,9): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i<d: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT di[i]=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT di[i]=i+1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s='' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tp=n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while tp>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=str(di[tp%9])+s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tp/=9 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return int(s) _NEWLINE inp=int(raw_input()) _NEWLINE for t in range(0,inp): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT st=raw_input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ls=st.split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=int(ls[0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d=int(ls[1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if d!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print calc1(n,d) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print calc2(n) _NEWLINE 
import random _NEWLINE T=input() _NEWLINE list=[] _NEWLINE count=0 _NEWLINE for i in range(T): _NEWLINE  _INDENT  _INDENT l=input() _NEWLINE  _INDENT  _INDENT list.append(l) _NEWLINE for j in range(T): _NEWLINE  _INDENT  _INDENT if list[j]%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'ALICE' _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 'BOB' 
import math _NEWLINE s=math.factorial(999) _NEWLINE s=str(s) _NEWLINE print len(s) _NEWLINE print s 
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if str(n)==str(n)[::-1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n+=1
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _INDENT _NEWLINE { _NEWLINE 	int n,t,i,count,max,a[100001]; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT max=INT_MIN; _NEWLINE 	 _INDENT  _INDENT count=1; _NEWLINE 	 _INDENT  _INDENT cin>>n; _NEWLINE 	 _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE 	 _INDENT  _INDENT cin>>a[i]; _NEWLINE 	 _INDENT  _INDENT sort(a,a+n); _NEWLINE 	 _INDENT  _INDENT for(i=0;i<n-1;i++) _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT if(a[i]==a[i+1]) _NEWLINE 	 _INDENT  _INDENT count++; _NEWLINE 	 _INDENT  _INDENT else _NEWLINE 	 _INDENT  _INDENT count=1; _NEWLINE 	 _INDENT  _INDENT if(count>max) _NEWLINE 	 _INDENT  _INDENT max=count; _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT cout<<max<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
n = int(raw_input()) _NEWLINE num = [] _NEWLINE ans = 0 _NEWLINE num = raw_input().split(" ") _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT if int(num[i])%2 == 0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans += 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans -= 1 _NEWLINE print abs(ans)
print 2**(bin(int(raw_input())).count('1'))
#include<bits/stdc++.h> _NEWLINE #define ll long long _NEWLINE using namespace std; _NEWLINE ll cnt; _NEWLINE pair<ll,ll> st[100010]; _NEWLINE ll d[100010]; _NEWLINE inline void scanint(ll* x) _NEWLINE { _NEWLINE 	register char c = getchar_unlocked(); _NEWLINE 	*x = 0; _NEWLINE 	for(; (c<48)||(c>57);c = getchar_unlocked()); _NEWLINE 	for(; (c>47)&&(c<58);c = getchar_unlocked()) _NEWLINE 		*x = (ll)((((*x)<<1) + ((*x)<<3)) + c - 48); _NEWLINE } _NEWLINE inline void printint(ll n) _NEWLINE { _NEWLINE 	if(n == 0) _NEWLINE 	{ _NEWLINE 		putchar_unlocked('0'); _NEWLINE 		putchar_unlocked('\n'); _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		char buf[20]; _NEWLINE 		buf[19] = '\n'; _NEWLINE 		int i = 18; _NEWLINE 		while(n) _NEWLINE 		{ _NEWLINE 			buf[i--] = n % 10 + '0'; _NEWLINE 			n /= 10; _NEWLINE 		} _NEWLINE 		while(buf[i] != '\n') _NEWLINE 			putchar_unlocked(buf[++i]); _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE ll* merge(ll* a,ll i, ll m,ll j){ _NEWLINE  _INDENT ll x,y,z; _NEWLINE  _INDENT ll n1 = m-i+1; _NEWLINE  _INDENT ll n2 = j-m; _NEWLINE  _INDENT ll c[n1],d[n2]; _NEWLINE  _INDENT for(x=0;x<n1;x++){ _NEWLINE  _INDENT  _INDENT  c[x]=a[i+x]; _NEWLINE  _INDENT } _NEWLINE  _INDENT for(x=0;x<n2;x++){ _NEWLINE  _INDENT  _INDENT  d[x]=a[m+1+x]; _NEWLINE  _INDENT } _NEWLINE  _INDENT x=0ll; _NEWLINE  _INDENT y=0ll; _NEWLINE  _INDENT z=i; _NEWLINE  _NEWLINE  _INDENT while(x<n1&&y<n2){ _NEWLINE  _INDENT  _INDENT if(c[x]<=d[y]){ _NEWLINE  _INDENT  _INDENT  _INDENT a[z]=c[x]; _NEWLINE  _INDENT  _INDENT  _INDENT x++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT cnt=cnt+n1-x; _NEWLINE  _INDENT  _INDENT  _INDENT a[z]=d[y]; _NEWLINE  _INDENT  _INDENT  _INDENT y++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT z++; _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT while(x<n1){ _NEWLINE  _INDENT  _INDENT a[z]=c[x]; _NEWLINE  _INDENT  _INDENT z++; _NEWLINE  _INDENT  _INDENT x++; _NEWLINE  _NEWLINE  _INDENT } _NEWLINE  _INDENT while(y<n2){ _NEWLINE  _INDENT  _INDENT a[z]=d[y]; _NEWLINE  _INDENT  _INDENT z++; _NEWLINE  _INDENT  _INDENT y++; _NEWLINE  _INDENT } _NEWLINE  _INDENT return a; _NEWLINE } _NEWLINE void mergesort(ll *a,ll i, ll j){ _NEWLINE  _INDENT if(i<j){ _NEWLINE  _INDENT ll m = (i+j)/2; _NEWLINE  _INDENT mergesort(a,i,m); _NEWLINE  _INDENT mergesort(a,m+1,j); _NEWLINE  _INDENT merge(a,i,m,j); _NEWLINE  _NEWLINE  _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE int main(){ _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll t; _NEWLINE  _INDENT  _INDENT  // _INDENT  cin>>t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanint(&t); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memset(st,0,sizeof(st)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll n,t1,i,v,ans=0,inp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // _INDENT  cin>>n>>t1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanint(&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanint(&t1); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // _INDENT  _INDENT cin>>inp[i]>>v; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanint(&inp); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanint(&v); _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  st[i]=make_pair(inp,v); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 			 sort(st+1,st+n+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(i=0;i<n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  	 d[i]=st[i+1].first+st[i+1].second*t1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _NEWLINE // _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 			mergesort(d,0,n-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printint(cnt); _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE } _NEWLINE 
import java.util.*; _NEWLINE class anticlockspiralfill _NEWLINE { _NEWLINE public static void main(String args[]) _NEWLINE { _NEWLINE int k,c,i,j,l,a[][]; _NEWLINE Scanner sc=new Scanner(System.in); _NEWLINE l=sc.nextInt(); _NEWLINE a=new int[l][l]; _NEWLINE switch(l%2) _NEWLINE { _NEWLINE  _INDENT  _INDENT case 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=l/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=k;j=k-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(c=1;c<=l*l;c++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i<(l-k)&&j==(k-1)&&i!=k-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(j<(l-k)&&i==(l-k)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(i>(k-1)&&j==(l-k)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(j>=(k-1)&&i==(k-1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(j==(k-1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE break; _NEWLINE case 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=l/2+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i=k-1;j=k-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(c=1;c<=l*l;c++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i>(k-1)&&j==(l-k)&&i!=(l-k)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(j>(k-1)&&i==(k-1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(i<(l-k)&&j==(k-1)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(j<=(l-k)&&i==(l-k)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(j==(l-k)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE break; _NEWLINE } _NEWLINE  _INDENT  _INDENT for(i=0;i<l;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;j<l;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.print(a[i][j]+"\t"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE }
#include<iostream> _NEWLINE #include<cstring> _NEWLINE using namespace std ; _NEWLINE #define rep(i,a,b) for ( int i = (a) ; i < (b) ; i++ ) _NEWLINE int ctr = 0 ; _NEWLINE int gr[100][100] , vis[100][100] ; _NEWLINE int N ; _NEWLINE int dx[4]={1,0,0,-1}; _NEWLINE int dy[4]={0,1,-1,0}; _NEWLINE  _NEWLINE void dfs(int m , int n) _NEWLINE { _NEWLINE 	if ( m==N-1 && n== N-1) ctr++ ; _NEWLINE 	vis[m][n]=true; _NEWLINE 	if ( m+1<N && !vis[m+1][n] && gr[m+1][n]==0 ) dfs(m+1,n) ; _NEWLINE 	if ( n+1<N && !vis[m][n+1] && gr[m][n+1]==0 ) dfs(m,n+1) ; _NEWLINE 	if ( m-1>=0 && !vis[m-1][n] && gr[m-1][n]==0 ) dfs(m-1,n) ; _NEWLINE 	if ( n-1>=0 && !vis[m][n-1] && gr[m][n-1]==0 ) dfs(m,n-1) ; _NEWLINE 	vis[m][n]=false; _NEWLINE } _NEWLINE  _NEWLINE int main ( ) _NEWLINE { _NEWLINE  _NEWLINE 	cin >> N ; _NEWLINE 	rep(i,0,N) rep(j,0,N) cin >> gr[i][j] ; _NEWLINE 	memset(vis,0,sizeof(vis)); _NEWLINE 	dfs(0,0); _NEWLINE 	cout << ctr << endl ; _NEWLINE 	return 0 ; _NEWLINE }
import java.util.*; _NEWLINE import java.lang.*; _NEWLINE import java.io.*; _NEWLINE  _NEWLINE  class NitsSats{ _NEWLINE 	public static void main(String [] args){ _NEWLINE 	int []a=new int[10001]; _NEWLINE 	for(int i=1;i<10001;i++) a[i]=1; _NEWLINE 	int temp=2; _NEWLINE 	int n=10001; _NEWLINE 	while(temp<n){ _NEWLINE 		int c=temp; _NEWLINE 		for(int i=1;i<10001;i++){ _NEWLINE 			if(a[i]==1&&c>0){ _NEWLINE 				c-=1; _NEWLINE 			} _NEWLINE 			if(c==0){ _NEWLINE 				a[i]=0; _NEWLINE 				c=temp; _NEWLINE 				n-=1; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		temp+=1; _NEWLINE 	} _NEWLINE 	//for(int i=1;i<50;i++) System.out.print(a[i]+" "); System.out.println(""); _NEWLINE 	int t; _NEWLINE 	Scanner sc = new Scanner (System.in); _NEWLINE 	t = sc.nextInt(); _NEWLINE 	while(t!=0){ _NEWLINE 		t-=1; _NEWLINE 		n = sc.nextInt(); _NEWLINE 		for(int i=1;i<=n;i++){ _NEWLINE 			if(a[i]==1) System.out.print(i+" "); _NEWLINE 			else continue; _NEWLINE 		} _NEWLINE 		System.out.println(""); _NEWLINE 	} _NEWLINE  _NEWLINE 	} _NEWLINE }
#include<stdio.h> _NEWLINE int a[10001000]; _NEWLINE int main() _NEWLINE { _NEWLINE 	int i,j,k,l=2,m=2,t=1; _NEWLINE 	a[0]=1; _NEWLINE 	a[1]=2; _NEWLINE 	for(k=1,m=2;k<25474;k++) _NEWLINE 	{ _NEWLINE 		for(j=0;j<a[k];j++,t++) _NEWLINE 			a[t]=m; _NEWLINE 		if(t>10000000) _NEWLINE 			goto end; _NEWLINE 		m++; _NEWLINE 	} _NEWLINE end:; _NEWLINE  _INDENT  _INDENT int test; _NEWLINE  _INDENT  _INDENT scanf("%d",&test); _NEWLINE 	for(i=0;i<test;i++) _NEWLINE 	{ _NEWLINE 		int n; _NEWLINE 		scanf("%d",&n); _NEWLINE 		printf("%d\n",a[n-1]); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE using namespace std; _NEWLINE int dp[10000000]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n,k; _NEWLINE  _INDENT  _INDENT cin>>n>>k; _NEWLINE  _INDENT  _INDENT dp[1]=1; _NEWLINE  _INDENT  _INDENT for(int i=2;i<=n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[i]=(dp[i-1]+(k-1))%i+1; _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout<<dp[n]<<endl; _NEWLINE  _NEWLINE } _NEWLINE 
 _NEWLINE /* Come on Code on!!!! _NEWLINE re_hash _NEWLINE dev_cpp _NEWLINE */ _NEWLINE  _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <queue> _NEWLINE #include <ctime> _NEWLINE #include <cassert> _NEWLINE #include <climits> _NEWLINE #include <limits> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define S(a) scanf("%d",&(a)) _NEWLINE #define P(a) printf("%d",(a)) _NEWLINE #define NL printf("\n") _NEWLINE #define SL(a) scanf("%lld",&(a)) _NEWLINE #define PL(a) printf("%lld",(a)) _NEWLINE #define ll long long int _NEWLINE #define FOR(I,A,B) for(int I= (A); I<(B); ++I) _NEWLINE #define all(c) c.begin(), c.end() _NEWLINE #define stop system("pause") _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define tr(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT S(t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int a,b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x,y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S(a);S(b);S(x);S(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int mx = max(a-x,x-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int my = max(b-y,y-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P(mx+my); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT NL; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
 _NEWLINE /* Come on Code on!!!! _NEWLINE re_hash _NEWLINE dev_cpp _NEWLINE */ _NEWLINE  _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <queue> _NEWLINE #include <ctime> _NEWLINE #include <cassert> _NEWLINE #include <climits> _NEWLINE #include <limits> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define S(a) scanf("%d",&(a)) _NEWLINE #define P(a) printf("%d",(a)) _NEWLINE #define NL printf("\n") _NEWLINE #define SL(a) scanf("%lld",&(a)) _NEWLINE #define PL(a) printf("%lld",(a)) _NEWLINE #define ll long long int _NEWLINE #define FOR(I,A,B) for(int I= (A); I<(B); ++I) _NEWLINE #define all(c) c.begin(), c.end() _NEWLINE #define stop system("pause") _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define tr(container, it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) _NEWLINE #define INF 100000000 _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int test; _NEWLINE  _INDENT  _INDENT S(test); _NEWLINE  _INDENT  _INDENT while(test--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n,t,m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT S(n);S(t);S(m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t+=t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int dp[1500]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[0]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT FOR(i,1,m+1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S(temp); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i]=INF; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=i;j>=max(1,i-n+1);j--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i]=min(dp[i],max(dp[j-1],temp)+t); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P(dp[m]-t/2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P((m-1)/n + 1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT NL; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
#include "stdio.h" _NEWLINE #include "stdlib.h" _NEWLINE #include <algorithm> _NEWLINE  _NEWLINE long long int nC2(long int i) {return ((i*(i-1))/2);} _NEWLINE  _NEWLINE long int n; _NEWLINE int *array; _NEWLINE long int *cumulative; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		scanf("%ld",&n); _NEWLINE 		array = new int [n]; _NEWLINE 		cumulative = new long int [n]; _NEWLINE 		for(long int index=0;index<n;index++) scanf("%d",array+index); _NEWLINE 		cumulative[0] = array[0]; _NEWLINE 		for(long int index=1;index<n;index++) cumulative[index] = cumulative[index-1] + array[index]; _NEWLINE 		std::sort(cumulative,cumulative+n); _NEWLINE 		long int current = cumulative[0]; _NEWLINE 		long int count = 1; _NEWLINE 		long long int result = 0; _NEWLINE 		for(long int index=1;index<n;index++) _NEWLINE 		{ _NEWLINE 			if(cumulative[index]==current) count++; _NEWLINE 			else _INDENT _NEWLINE 			{	 _NEWLINE 				result += nC2(count); _NEWLINE 				if(current == 0) result += count; _NEWLINE 				current = cumulative[index]; _NEWLINE 				count = 1; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		result += nC2(count); _NEWLINE 		if(current == 0) result += count; _NEWLINE 		printf("%lld\n",result); _NEWLINE 	} _NEWLINE  _NEWLINE  _NEWLINE 	return 0; _NEWLINE }
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <vector> _NEWLINE #include <cstring> _NEWLINE #include <string> _NEWLINE #include <map> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  int n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  vector <vector <int> > bomb(201,vector <int>(201,0)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  int x,y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int i=0;i<n;++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%d%d",&x,&y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  bomb[x][y]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  int cc=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int i=0;i<=200;++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int j=0;j<=200;++j){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(bomb[i][j]==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  bool a,b,c,d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  a=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int ii=0;ii<j;++ii){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(bomb[i][ii]==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  b=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int ii=j+1;ii<=200;++ii){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(bomb[i][ii]==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  c=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int ii=0;ii<i;++ii){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(bomb[ii][j]==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  d=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int ii=i+1;ii<=200;++ii){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(bomb[ii][j]==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if((a & b & c & d)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cc++; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //cout<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  //system("pause"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("%d\n",cc); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include <cstdio> _NEWLINE  _INDENT _NEWLINE #define MOD 1000000007 _NEWLINE  _INDENT _NEWLINE int fact[5001], invfact[5001]; _NEWLINE  _INDENT _NEWLINE int powmod(int base, int expo){ _NEWLINE  _INDENT  _INDENT if(expo==0) _NEWLINE 		return 1; _NEWLINE 	else if(expo&1) _NEWLINE 		return (long long)base*powmod(base, expo-1)%MOD; _NEWLINE 	else{ _NEWLINE 		int root=powmod(base, expo>>1); _NEWLINE 		return (long long)root*root%MOD; _NEWLINE 	} _NEWLINE } _NEWLINE  _INDENT _NEWLINE int inverse(int x){ _NEWLINE 	return powmod(x, MOD-2); _NEWLINE } _NEWLINE  _INDENT _NEWLINE void init(){ _NEWLINE 	fact[0]=1; _NEWLINE 	for(int i=1; i<=5000; i++) _NEWLINE 		fact[i]=(long long)i*fact[i-1]%MOD; _NEWLINE 	invfact[5000]=inverse(fact[5000]); _NEWLINE 	for(int i=5000; i>0; i--) _NEWLINE 		invfact[i-1]=(long long)i*invfact[i]%MOD; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int nCr(int n, int r){ _NEWLINE 	if(r>n || r<0) _NEWLINE 		return 0; _NEWLINE 	return (long long)((long long)fact[n]*invfact[r]%MOD)*invfact[n-r]%MOD; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main(){ _NEWLINE 	init(); _NEWLINE 	int N, K; _NEWLINE 	while(scanf("%d %d", &N, &K) && !(N==0 && K==0)){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(K==0) {puts("0");continue;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = N/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE 		int res=2ll*nCr(N-1, (K)/2)*nCr(N-1, (K-1)/2)%MOD; _NEWLINE 		printf("%d\n", res); _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE 
#include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<string.h> _NEWLINE #define Hash 1001007 _NEWLINE  _NEWLINE int fa[Hash],num[Hash],son[Hash],next[300001],tot,T,n,i,j,k,aim,a1,a2; _NEWLINE char str[300001][100],s1[100],s2[100],s[100]; _NEWLINE  _NEWLINE int hash(char s[],int l) _NEWLINE { _NEWLINE  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT long long re=0; _NEWLINE  _INDENT  _INDENT for(i=0;i<l;++i)re=(re*1456+s[i]+78114)%Hash; _NEWLINE  _INDENT  _INDENT return re; _NEWLINE } _NEWLINE  _NEWLINE int get(int p) _NEWLINE { _NEWLINE 	if(fa[p]==p)return p; _NEWLINE 	fa[p]=get(fa[p]); _NEWLINE 	return fa[p]; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	scanf("%d",&T); _NEWLINE 	while(T--) _NEWLINE 	{ _NEWLINE 		scanf("%d",&n); _NEWLINE 		for(i=0;i<Hash;++i)son[i]=0; _NEWLINE 		for(i=1;i<=n;++i) _NEWLINE 		{ _NEWLINE 			scanf("%s%s",s1,s2); _NEWLINE 			a1=j=hash(s1,strlen(s1)); _NEWLINE 			for(j=son[j];j;j=next[j])if(strcmp(str[j],s1)==0)break; _NEWLINE 			a2=k=hash(s2,strlen(s2)); _NEWLINE 			for(k=son[k];k;k=next[k])if(strcmp(str[k],s2)==0)break; _NEWLINE 			if(!j){++tot;j=tot;memcpy(str[j],s1,sizeof(s1));next[tot]=son[a1];son[a1]=tot;fa[tot]=tot;num[tot]=1;} _NEWLINE 			if(!k){++tot;k=tot;memcpy(str[k],s2,sizeof(s2));next[tot]=son[a2];son[a2]=tot;fa[tot]=tot;num[tot]=1;} _NEWLINE 			j=get(j);k=get(k); _NEWLINE 			if(j!=k) _NEWLINE 			{ _NEWLINE 				fa[j]=k; _NEWLINE 				num[k]+=num[j]; _NEWLINE 			} _NEWLINE 			printf("%d\n",num[get(j)]); _NEWLINE 		} _NEWLINE 	} _NEWLINE }
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<cstring> _NEWLINE #include<cmath> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int n,m,ms; _NEWLINE int set[1001][1001]; _NEWLINE  _NEWLINE struct st{ _NEWLINE 	int p,sz; _NEWLINE }s[1001000]; _NEWLINE  _NEWLINE  _NEWLINE int findSet(int x){ _NEWLINE 	if( x!=s[x].p ) return s[x].p=findSet(s[x].p); _NEWLINE 	return s[x].p; _NEWLINE } _NEWLINE void Union(int x,int y){ _INDENT ///cout<<x<<" link "<<y<<endl; _NEWLINE 	x=findSet(x); y=findSet(y); _NEWLINE 	if( x==y ) return ; _NEWLINE 	s[x].p=y; _NEWLINE 	s[y].sz+=s[x].sz; _NEWLINE 	ms=max(ms,s[y].sz); _NEWLINE } _NEWLINE  _NEWLINE int main (){ _NEWLINE 	scanf("%d %d",&n,&m); _NEWLINE 	int q; scanf("%d",&q); _NEWLINE 	for(int i=0;i<=n;i++) { _NEWLINE 		 s[i].p=-1; s[i].sz=1; _NEWLINE 	} _NEWLINE 	for(int i=0;i<q;i++){ _NEWLINE 		int c,a,b; _NEWLINE 		scanf("%d",&a); _NEWLINE 		if( a==0 ) printf("%d\n",ms); _NEWLINE 		else { _NEWLINE 			scanf("%d %d",&a,&b); // cout<<a<<" "<<b<<endl; _NEWLINE 			if( set[a][b] ) continue; _NEWLINE 			set[a][b]=1; ms=max(ms,1); _NEWLINE 			 _NEWLINE 			c=(a-1)*m+b; _INDENT //cout<<"c"<<c<<endl; _NEWLINE 			s[c].p=c; s[c].sz=1; _NEWLINE 			 _NEWLINE 			if( a-1 _INDENT  && set[a-1][b]) _INDENT Union(c, (a-2)*m+b); _NEWLINE 			if( b-1 _INDENT  && set[a][b-1]) _INDENT Union(c, (a-1)*m+b-1); _NEWLINE 			if(a+1<=n && set[a+1][b]) _INDENT Union(c, (a _INDENT )*m+b); _NEWLINE 			if(b+1<=m && set[a][b+1]) _INDENT Union(c, (a-1)*m+b+1); _NEWLINE 			 _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int a[200005][26]={0}; _NEWLINE int main() _NEWLINE { _NEWLINE 	char str[200001]; _NEWLINE 	cin>>str; _NEWLINE 	int len=strlen(str); _NEWLINE 	for(int i=0;i<len;i++) _NEWLINE 	{ _NEWLINE 			for(int j=0;j<26;j++) _NEWLINE 				a[i+1][j]=a[i][j]; _NEWLINE 		a[i+1][str[i]-'a']++; _NEWLINE 	} _NEWLINE 	int q; _NEWLINE 	cin>>q; _NEWLINE 	while(q--) _NEWLINE 	{ _NEWLINE 		int ans=0,f=0,l,r; _NEWLINE 		cin>>l>>r; _NEWLINE 		for(int i=0;i<26;i++) _NEWLINE 		{ _NEWLINE 			ans+=a[r][i]-a[l-1][i]; _NEWLINE 			if(ans%2!=0) _NEWLINE 			{ _NEWLINE 				ans=ans-1; _NEWLINE 				f=1; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(f==1)	 _NEWLINE 		ans=ans+1; _NEWLINE 		cout<<ans<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } 
#include<stdio.h> _NEWLINE int f[1000005]; _NEWLINE void Prefix(char p[],int m) _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j; _NEWLINE  _INDENT  _INDENT f[0]=0; _NEWLINE  _INDENT  _INDENT i=1; _NEWLINE  _INDENT  _INDENT j=0; _NEWLINE  _INDENT  _INDENT while(i<m) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(p[i]==p[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f[i]=j+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(j>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j=f[j-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f[i]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE int KMP(char t[],char p[],int m,int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT int i=0,j=0; _NEWLINE  _INDENT  _INDENT Prefix(p,m); _NEWLINE int _INDENT  _INDENT  count=0; _NEWLINE  _INDENT  _INDENT while(i<n) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(t[i]==p[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(j==m-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(j>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=f[j-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return count; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n; _NEWLINE  _INDENT  _INDENT char s[100005],a[100005]; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%s",s); _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT while(n--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT scanf("%s",a); _NEWLINE  _INDENT  int final =KMP(s,a,strlen(a),strlen(s)); _NEWLINE  _INDENT  printf("%d\n",final); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE  _INDENT _NEWLINE long long count,m,n,space[100][100]; _NEWLINE void lot(int i,int j){ _NEWLINE 	if((i==m-1&&j==n-1)||(i==m-1&&space[i][j+1]==2147483647)||(j==n-1&&space[i+1][j]==2147483647)||((space[i][j+1]==2147483647)&&space[i+1][j]==2147483647)); _NEWLINE 	else{ _NEWLINE 		count++; _NEWLINE 		if(i==m-1||space[i+1][j]==2147483647){ _NEWLINE 			lot(i,j+1); _NEWLINE 		} _NEWLINE 		else if(j==n-1||space[i][j+1]==2147483647){ _NEWLINE 			lot(i+1,j); _NEWLINE 		} _NEWLINE 		else if(space[i][j+1]<space[i+1][j]){ _NEWLINE 			lot(i,j+1); _NEWLINE 		} _NEWLINE 		else{ _NEWLINE 			lot(i+1,j); _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE 	 _NEWLINE 	 _NEWLINE int main(){ _NEWLINE 	long long inputs,i,j; _NEWLINE 	scanf("%lld",&inputs); _NEWLINE 	while(inputs){ _NEWLINE 		scanf("%lld",&m); _NEWLINE 		scanf("%lld",&n); _NEWLINE 		for(i=0;i<m;i++){ _NEWLINE 			for(j=0;j<n;j++){ _NEWLINE 				scanf("%lld",&space[i][j]); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		count=0; _NEWLINE 		lot(0,0); _NEWLINE 		printf("%lld\n",count); _NEWLINE 		inputs--; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }	
t_cases = int(raw_input()) _NEWLINE  _NEWLINE for i in range(t_cases): _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT g_size = int(raw_input()) _NEWLINE  _INDENT  _INDENT passw = "" _NEWLINE  _INDENT  _INDENT for i in range(g_size): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT passw = passw+''.join((raw_input()).split(" ")) _NEWLINE  _NEWLINE  _INDENT  _INDENT if passw == passw[::-1] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "Yes" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "No" _NEWLINE 
#include<iostream> _NEWLINE #include<fstream> _NEWLINE #include<vector> _NEWLINE #include<cstring> _NEWLINE #include<map> _NEWLINE #define in cin _NEWLINE #define out cout _NEWLINE using namespace std; _NEWLINE const int Nmax = 1001; _NEWLINE const int MOD1 = 734057; _NEWLINE const int MOD2 = 941911; _NEWLINE int d[2][Nmax][Nmax]; _NEWLINE char s[Nmax+2]; _NEWLINE map< pair<int,int>,vector< pair<int,int> > > M; _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  _INDENT ifstream in("test.in"); _NEWLINE  _INDENT  _INDENT ofstream out("test.out"); _NEWLINE  _INDENT  _INDENT #endif _NEWLINE  _INDENT  _INDENT d[0][0][1]=d[1][0][1]=1; _NEWLINE  _INDENT  _INDENT for(int i=1;i<Nmax;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=1;j<Nmax;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[0][i][j]=(d[0][i-1][j]+d[0][i][j-1])%MOD1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[1][i][j]=(d[1][i-1][j]+d[1][i][j-1])%MOD2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT M[make_pair(d[0][i][j],d[1][i][j])].push_back(make_pair(i,j)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int T; in>>T; in.get(); _NEWLINE  _INDENT  _INDENT while(T--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT in.getline(s+1,Nmax); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n=strlen(s+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int m1=0,m2=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m1=(m1*10+(int(s[i])-'0'))%MOD1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m2=(m2*10+(int(s[i])-'0'))%MOD2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int mn=M[make_pair(m1,m2)].size(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(mn==0) out<<"The Grid is Too Big!\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT out<<mn<<'\n'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(vector< pair<int,int> >::iterator it=M[make_pair(m1,m2)].begin();it!=M[make_pair(m1,m2)].end();++it){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT out<<it->first<<' '<<it->second<<'\n'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <iostream> _NEWLINE #include <climits> _NEWLINE using namespace std; _NEWLINE int eggDrop(int f, int e) _NEWLINE { _NEWLINE 	if(f <= 1) _NEWLINE 		return f; _NEWLINE 	int dp[f+1][e+1]; _NEWLINE 	for(int i=0;i<=f;i++) _NEWLINE 		for(int j=0;j<=e;j++) _NEWLINE 			dp[i][j] = 0; _NEWLINE 	for(int i=1;i<=f;i++) _NEWLINE 	{ _NEWLINE 		for(int j=1;j<=e;j++) _NEWLINE 		{ _NEWLINE 			if(j == 1) _NEWLINE 			{ _NEWLINE 				dp[i][j] = i; _NEWLINE 				continue; _NEWLINE 			} _NEWLINE 			int currMin = INT_MAX; _NEWLINE 			int tmp; _NEWLINE 			for(int k=1;k<=i;k++) _NEWLINE 			{ _NEWLINE 				tmp = ((dp[k-1][j-1]+1)>dp[i-k][j]?(dp[k-1][j-1]+1):dp[i-k][j]); _NEWLINE 				tmp++; _NEWLINE 				if(tmp < currMin) _NEWLINE 					currMin = tmp; _NEWLINE 			} _NEWLINE 			dp[i][j] = currMin; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	/* _NEWLINE 	for(int i=0;i<=f;i++) _NEWLINE 	{ _NEWLINE 		for(int j=0;j<=e;j++) _NEWLINE 			cout << dp[i][j] << " "; _NEWLINE 		cout << endl; _NEWLINE 	} _NEWLINE 	*/ _NEWLINE 	dp[f][e]++; _NEWLINE 	return dp[f][e]; _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() { _NEWLINE 	//code _NEWLINE 	int tc; _NEWLINE 	cin >> tc; _NEWLINE 	int n,k; _NEWLINE 	while(tc-- > 0) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT cin >> n >> k; _NEWLINE 	 _INDENT  _INDENT cout << eggDrop(n,k) << endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int tc;cin>>tc; _NEWLINE  _INDENT  _INDENT while(tc--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int coun=0;string s;cin>>s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT set<char> S(s.begin(),s.end());set<char>::iterator it; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(it = S.begin();it!=S.end();it++) coun++;cout<<coun<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE }
#include<stdio.h> _NEWLINE #include<math.h> _NEWLINE #define ld long double _NEWLINE  _NEWLINE ld abs(ld a) { return a>0?a:-a; } _NEWLINE ld max(ld a, ld b) { return a>b?a:b; } _NEWLINE  _NEWLINE int main() _INDENT _NEWLINE { _NEWLINE 	int N, min_index = 0; _NEWLINE 	scanf("%d", &N); _NEWLINE 	ld ave_x = 0.0, ave_y = 0.0, min, sum = 0.0, x[N+1], y[N+1]; _NEWLINE 	 _NEWLINE 	for(int i=0; i<N; i++) _INDENT scanf("%Lf%Lf",&x[i],&y[i]); _NEWLINE 	 _NEWLINE 	for(int i=0; i<N; i++) _INDENT _NEWLINE 	{ _NEWLINE 		ave_x += x[i]/(ld)N; _NEWLINE 		ave_y += y[i]/(ld)N; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	min = sqrt((ave_x-x[0])*(ave_x-x[0]) + (ave_y-y[0])*(ave_y-y[0])); _NEWLINE 	for(int i=1; i<N; i++) _INDENT _NEWLINE 	{ _NEWLINE 		ld quo = sqrt((ave_x-x[i])*(ave_x-x[i]) + (ave_y-y[i])*(ave_y-y[i])); _NEWLINE 		if(quo < min) _INDENT _NEWLINE 		{ _NEWLINE 			min = quo; _NEWLINE 			min_index = i; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	for(int i=0; i<N; i++) _INDENT  sum += max(abs(x[min_index]-x[i]), abs(y[min_index]-y[i])); _NEWLINE 	printf("%0.0Lf\n",sum); _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int x,y,z; _NEWLINE  _INDENT  _INDENT scanf("%d%d",&x,&y); _NEWLINE  _INDENT  _INDENT z=-x-y; _NEWLINE  _INDENT  _INDENT printf("%d\n",-z); _NEWLINE } _NEWLINE 
process.stdin.resume(); _INDENT _NEWLINE process.stdin.on('data', function(chunk) { _NEWLINE  _INDENT var lines = chunk.toString().split('\n'); _NEWLINE  _INDENT var lineSplit = lines[0].trim().split(' '); _NEWLINE  _INDENT var n = parseInt(lineSplit[0]); _NEWLINE  _INDENT var k = parseInt(lineSplit[1]); _NEWLINE  _INDENT if( n > 100000){ _NEWLINE  _INDENT  _INDENT process.exit(); _NEWLINE  _INDENT } _NEWLINE  _INDENT  _NEWLINE  _INDENT lineSplit = lines[1].trim().split(' '); _NEWLINE  _INDENT lineSplit.sort(); _NEWLINE  _INDENT var count = 0; _NEWLINE  _INDENT  _NEWLINE  _INDENT for(var i=0;i<n-1;i++){ _NEWLINE  _INDENT  _INDENT var num1 = parseInt(lineSplit[i]); _NEWLINE  _INDENT  _INDENT for(var j=i+1;j<n;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT var num2 = parseInt(lineSplit[j]); _NEWLINE  _INDENT  _INDENT  _INDENT if(num1 + k === num2){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j = n; _NEWLINE  _INDENT  _INDENT  _INDENT } else if (num1 + k < num2) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j = n; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT process.stdout.write(count.toString() + "\n"); _NEWLINE  _INDENT  _NEWLINE }); _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define lint long long _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int temp,index,x,num,l,t,r,it; _NEWLINE  _INDENT  _INDENT scanf("%d",&it); _NEWLINE  _INDENT  _INDENT while(it--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT int two[100]={1}; _NEWLINE  _INDENT  _INDENT scanf("%d%d",&num,&r); _NEWLINE  _INDENT  _INDENT if(num==r) printf("0.00\n"); _NEWLINE  _INDENT  _INDENT else if(r==0){ _NEWLINE  _INDENT  _INDENT l=0; _NEWLINE  _INDENT  _INDENT num=num-r+1; _NEWLINE  _INDENT  _INDENT for(t=1;t<=num;t++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(index=0;index<=l;index++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=(two[index]*2)+temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT two[index]=x%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=x/10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(temp;temp!=0;temp=temp/10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT two[l]=temp%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(t=l;t>=1;t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d",two[t]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  printf("%d.00\n",two[0]-2); _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT l=0; _NEWLINE  _INDENT  _INDENT num=num; _NEWLINE  _INDENT  _INDENT for(t=1;t<=num;t++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(index=0;index<=l;index++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=(two[index]*2)+temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT two[index]=x%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=x/10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(temp;temp!=0;temp=temp/10) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT two[l]=temp%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(t=l;t>=1;t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d",two[t]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  printf("%d.00\n",two[0]); _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE 
#include <iostream> _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE #include <fstream> _NEWLINE #include <algorithm> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	//ifstream fin("pbuzz.in"); _NEWLINE 	int A; _NEWLINE 	char B; _NEWLINE 	vector<int> FRONT; _NEWLINE 	vector<int> BACK; _NEWLINE 	int counter = 1; _NEWLINE 	cin >> A; _NEWLINE 	FRONT.push_back(A); _NEWLINE 	while(cin>>B>>A) _NEWLINE 	{ _NEWLINE 		if(counter % 2 == 0) _NEWLINE 			FRONT.push_back(A); _NEWLINE 		else _NEWLINE 			BACK.push_back(A); _NEWLINE 		counter++; _NEWLINE 	} _NEWLINE  _NEWLINE 	//sort(FRONT.begin(), FRONT.end()); _NEWLINE 	//sort(BACK.rbegin(), BACK.rend()); _NEWLINE  _NEWLINE 	for(vector<int>::iterator it = FRONT.begin(); it!= FRONT.end(); it++) _NEWLINE 	{ _NEWLINE 		cout << *it << ","; _NEWLINE 	} _NEWLINE  _NEWLINE 	for(int x = BACK.size()-1; x>=0; x--) _NEWLINE 	{ _NEWLINE 		cout << BACK[x] << (x != 0 ? "," : "\n"); _NEWLINE 	} _NEWLINE }
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <string> _NEWLINE #include <algorithm> _NEWLINE #include <vector> _NEWLINE #include <sstream> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main(){ _NEWLINE 	int T; _NEWLINE 	cin >> T; _NEWLINE 	string emptyLine; _NEWLINE 	getline(cin, emptyLine); _NEWLINE 	while(T--){ _NEWLINE 		vector< vector<string> > info(5); _NEWLINE 		for(int i = 0; i < 5; i++){ _NEWLINE 			string line; _NEWLINE 			getline(cin, line); _NEWLINE 			stringstream ss(line); _NEWLINE 			string item; _NEWLINE 			while (std::getline(ss, item, ' ')) { _NEWLINE 				info[i].push_back(item); _NEWLINE 			} _NEWLINE 		} _NEWLINE  _NEWLINE 		/*for(int i = 0; i < 5; i++){ _NEWLINE 			for(vector<string>::iterator it = info[i].begin(); it != info[i].end(); it++) _NEWLINE 				cout << *it << "\t"; _NEWLINE 			cout << endl; _NEWLINE 		}*/ _NEWLINE  _NEWLINE  _NEWLINE 		string seq = "ABCDE"; _NEWLINE 		bool found = false; _NEWLINE 		do { _NEWLINE 			bool next = false; _NEWLINE 			for(int i = 0; i < 5 && !next; i++){ _NEWLINE 				char check = 'A'+i; _NEWLINE 				int j = seq.find(check); _NEWLINE 				for(vector<string>::iterator it = info[i].begin(); it != info[i].end() && !next; it++){ _NEWLINE 					if (isalpha((*it)[0])){ _NEWLINE 						if((*it)[0] == 'N'){ _NEWLINE 							if (isalpha((*it)[1])){ _NEWLINE 								if ((j<4 && seq[j+1] == (*it)[1]) || (j>0 && seq[j-1] == (*it)[1])) _NEWLINE 								{ _NEWLINE 									next = true; _NEWLINE 									continue; _NEWLINE 								} _NEWLINE 							} _NEWLINE 							else{ _NEWLINE 								if (j == (*it)[1]-'1') _NEWLINE 								{ _NEWLINE 									next = true; _NEWLINE 									continue; _NEWLINE 								} _NEWLINE 							} _NEWLINE 						} _NEWLINE 						else{ _NEWLINE 							if ((j<4 && seq[j+1] != (*it)[0]) && (j>0 && seq[j-1] != (*it)[0])) _NEWLINE 							{ _NEWLINE 								next = true; _NEWLINE 								continue; _NEWLINE 							} _NEWLINE  _NEWLINE 						} _NEWLINE 					} _NEWLINE 					else if ((*it)[0] == '+'){ _NEWLINE 						int k; _NEWLINE 						for (k = j+1; k < 5; k++) _NEWLINE 							if (seq[k] == (*it)[1]) _NEWLINE 								break; _NEWLINE 						if (k != 5) _NEWLINE 						{ _NEWLINE 							next = true; _NEWLINE 							continue; _NEWLINE 						} _NEWLINE 					} _NEWLINE 					else if ((*it)[0] == '-'){ _NEWLINE 						int k; _NEWLINE 						for (k = j-1; k >= 0; k--) _NEWLINE 							if (seq[k] == (*it)[1]) _NEWLINE 								break; _NEWLINE 						if (k != -1) _NEWLINE 						{ _NEWLINE 							next = true; _NEWLINE 							continue; _NEWLINE 						} _NEWLINE 					} _NEWLINE 					else{ _NEWLINE 						if (j != (*it)[0] - '1') _NEWLINE 						{ _NEWLINE 							next = true; _NEWLINE 							continue; _NEWLINE 						} _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE  _NEWLINE 			if (!next){ _NEWLINE 				found = true; _NEWLINE 				break; _NEWLINE 			} _NEWLINE  _NEWLINE 		} while ( next_permutation(seq.begin(),seq.end()) && !found); _NEWLINE  _NEWLINE 		cout << seq << endl; _NEWLINE 	} _NEWLINE  _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <cstring> _NEWLINE #include <queue> _NEWLINE #include <algorithm> _NEWLINE #include <vector> _NEWLINE #include <cassert> _NEWLINE using namespace std; _NEWLINE int _clock; _NEWLINE  _NEWLINE struct Chef _NEWLINE { _NEWLINE 	int working; _NEWLINE 	bool isWorking() _NEWLINE 	{ _NEWLINE 		return working != 0; _NEWLINE 	} _NEWLINE 	void work() _NEWLINE 	{ _NEWLINE 		assert(working); _NEWLINE 		working++; _NEWLINE 		if(working == 6) working = 0; _NEWLINE 	} _NEWLINE }chef[5]; _NEWLINE void pass() _NEWLINE { _NEWLINE 	for (int i = 0; i < 5; ++i) _NEWLINE 		if (chef[i].isWorking()) chef[i].work(); _NEWLINE 	_clock++; _NEWLINE } _NEWLINE int waittime; _NEWLINE struct Per _NEWLINE { _NEWLINE 	int time; _NEWLINE 	int order[5]; _NEWLINE 	int p; _NEWLINE 	bool servered; _NEWLINE 	bool isServered() _NEWLINE 	{ _NEWLINE 		return servered; _NEWLINE 	} _NEWLINE 	Per(){p = 0; servered = false;} _NEWLINE 	void finish() _NEWLINE 	{ _NEWLINE 		order[cuisine()] -= 2; _NEWLINE 		servered = false; _NEWLINE 	} _NEWLINE 	void wait() _NEWLINE 	{ _NEWLINE 		waittime++; _NEWLINE 	} _NEWLINE 	int cuisine() _NEWLINE 	{ _NEWLINE 		if (p == 5) return 5; _NEWLINE 		while (order[p] == 0) p++; _NEWLINE 		return p; _NEWLINE 	} _NEWLINE 	void deal() _NEWLINE 	{ _NEWLINE 		servered = true; _NEWLINE 	} _NEWLINE 	bool operator < (const Per &e)const _NEWLINE 	{ _NEWLINE 		return time < e.time; _NEWLINE 	} _NEWLINE }; _NEWLINE const int Maxn = 1000000; _NEWLINE Per que[Maxn]; _NEWLINE int in, out; _NEWLINE vector<Per> vec; _NEWLINE int s, n; _NEWLINE void solve() _NEWLINE { _NEWLINE 	in = 0, out = 0; _NEWLINE 	//cout << vec[1].time <<" " << vec.size() << endl; _NEWLINE 	for (_clock = 0; s < vec.size() || in > out; pass()) _NEWLINE 	{ _NEWLINE 		if (s < vec.size()) _NEWLINE 		{ _NEWLINE 			if (_clock == vec[s].time) _NEWLINE 			{ _NEWLINE 				que[(in++) % Maxn] = vec[s]; _NEWLINE 				s++; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		while (in > out) _NEWLINE 		{ _NEWLINE 			int cui = que[(out) % Maxn].cuisine(); _NEWLINE 			if (cui == 5) _INDENT _NEWLINE 			{ _NEWLINE 				out++; _NEWLINE 				continue; _NEWLINE 			} _NEWLINE 			if (que[out % Maxn].isServered() && chef[cui].isWorking() == false) _INDENT _NEWLINE 			{ _NEWLINE 			//	cout << que[out].time <<" " << cui << endl; _NEWLINE 				que[out % Maxn].finish(); _NEWLINE 				que[(in++) % Maxn] = que[(out++) % Maxn]; _NEWLINE 				chef[cui].working = 1; _NEWLINE 			} _NEWLINE 			else break; _NEWLINE 		} _NEWLINE 		if (in > out) _NEWLINE 		{	 _NEWLINE 			Per& p = que[out % Maxn]; _NEWLINE 			int cui = p.cuisine(); _NEWLINE 			if (p.isServered() == false) _NEWLINE 			{ _NEWLINE 				p.deal(); _NEWLINE 			//	cout<< _clock <<" " <<p.time << " " << p.p<<" " <<chef[cui].working<< endl; _NEWLINE 			} _NEWLINE 			else if (chef[cui].isWorking()) _NEWLINE 				p.wait(); _NEWLINE 		} _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int T; _NEWLINE 	scanf("%d", &T); _NEWLINE 	while (T--) _NEWLINE 	{ _NEWLINE 		waittime = 0; _NEWLINE 		s = 0; _NEWLINE 		scanf("%d", &n); _NEWLINE 		vec.clear(); _NEWLINE 		for (int i = 0; i < n; ++i) _NEWLINE 		{ _NEWLINE 			Per per; _NEWLINE 			scanf("%d", &per.time); _NEWLINE 			for (int j = 0; j < 5; ++j) _NEWLINE 				scanf("%d", &per.order[j]); _NEWLINE 			per.p = 0; _NEWLINE 			vec.push_back(per); _NEWLINE 		} _NEWLINE 		sort(vec.begin(), vec.end()); _NEWLINE 		solve(); _NEWLINE 		printf("%d\n", waittime); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
import java.awt.geom.Line2D; _NEWLINE import java.io.ByteArrayInputStream; _NEWLINE import java.io.IOException; _NEWLINE import java.io.InputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE  _INDENT _NEWLINE public class Main { _NEWLINE static InputStream is; _NEWLINE static PrintWriter out; _NEWLINE static String INPUT = ""; _NEWLINE static void solve() _NEWLINE { _NEWLINE outer: _NEWLINE for(int T = ni();T >= 1;T--){ _NEWLINE long[][] co = new long[4][]; _NEWLINE for(int i = 0;i < 4;i++){ _NEWLINE co[i] = new long[]{ni(), ni()}; _NEWLINE } _NEWLINE long ab = d2(co[0], co[1]); _NEWLINE long bc = d2(co[1], co[2]); _NEWLINE long cd = d2(co[2], co[3]); _NEWLINE long da = d2(co[3], co[0]); _NEWLINE for(int k = 0;k < 4;k++){ _NEWLINE if( _NEWLINE (co[(k+1)%4][0]-co[k][0])*(co[(k+2)%4][1]-co[(k+1)%4][1])- _NEWLINE (co[(k+1)%4][1]-co[k][1])*(co[(k+2)%4][0]-co[(k+1)%4][0]) _NEWLINE == 0){ _NEWLINE out.println("NONE"); _NEWLINE continue outer; _NEWLINE } _NEWLINE } _NEWLINE if(Line2D.linesIntersect(co[0][0], co[0][1], co[1][0], co[1][1], co[2][0], co[2][1], co[3][0], co[3][1])){ _NEWLINE out.println("NONE"); _NEWLINE continue outer; _NEWLINE } _NEWLINE if(Line2D.linesIntersect(co[1][0], co[1][1], co[2][0], co[2][1], co[3][0], co[3][1], co[0][0], co[0][1])){ _NEWLINE out.println("NONE"); _NEWLINE continue outer; _NEWLINE } _NEWLINE boolean rho = false; _NEWLINE boolean par = false; _NEWLINE if(ab > 0 && ab == bc && bc == cd && cd == da){ _NEWLINE rho = true; _NEWLINE } _NEWLINE if( _NEWLINE ab > 0 && bc > 0 && cd > 0 && da > 0 && _NEWLINE (co[3][0]-co[2][0])*(co[1][1]-co[0][1])-(co[3][1]-co[2][1])*(co[1][0]-co[0][0]) == 0 && _NEWLINE (co[0][0]-co[3][0])*(co[2][1]-co[1][1])-(co[0][1]-co[3][1])*(co[2][0]-co[1][0]) == 0){ _NEWLINE par = true; _NEWLINE } _NEWLINE int ct = 0; _NEWLINE for(int k = 0;k < 4;k++){ _NEWLINE if( _NEWLINE (co[(k+1)%4][0]-co[(k)%4][0])*(co[(k+2)%4][0]-co[(k+1)%4][0])+ _NEWLINE (co[(k+1)%4][1]-co[(k)%4][1])*(co[(k+2)%4][1]-co[(k+1)%4][1]) _NEWLINE == 0)ct++; _NEWLINE } _NEWLINE if(ct == 4 && rho){ _NEWLINE out.println("SQUARE"); _NEWLINE }else if(ct == 4 && par){ _NEWLINE out.println("RECTANGLE"); _NEWLINE }else if(rho){ _NEWLINE out.println("RHOMBUS"); _NEWLINE }else if(par){ _NEWLINE out.println("PARALLELOGRAM"); _NEWLINE }else{ _NEWLINE out.println("QUADRILATERAL"); _NEWLINE } _NEWLINE } _NEWLINE } _NEWLINE public static long d2(long[] a, long[] b) _NEWLINE { _NEWLINE return (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1]); _NEWLINE } _NEWLINE public static void main(String[] args) throws Exception _NEWLINE { _NEWLINE long S = System.currentTimeMillis(); _NEWLINE is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes()); _NEWLINE out = new PrintWriter(System.out); _NEWLINE solve(); _NEWLINE out.flush(); _NEWLINE long G = System.currentTimeMillis(); _NEWLINE tr(G-S+"ms"); _NEWLINE } _NEWLINE private static boolean eof() _NEWLINE { _NEWLINE if(lenbuf == -1)return true; _NEWLINE int lptr = ptrbuf; _NEWLINE while(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false; _NEWLINE try { _NEWLINE is.mark(1000); _NEWLINE while(true){ _NEWLINE int b = is.read(); _NEWLINE if(b == -1){ _NEWLINE is.reset(); _NEWLINE return true; _NEWLINE }else if(!isSpaceChar(b)){ _NEWLINE is.reset(); _NEWLINE return false; _NEWLINE } _NEWLINE } _NEWLINE } catch (IOException e) { _NEWLINE return true; _NEWLINE } _NEWLINE } _NEWLINE private static byte[] inbuf = new byte[1024]; _NEWLINE static int lenbuf = 0, ptrbuf = 0; _NEWLINE private static int readByte() _NEWLINE { _NEWLINE if(lenbuf == -1)throw new InputMismatchException(); _NEWLINE if(ptrbuf >= lenbuf){ _NEWLINE ptrbuf = 0; _NEWLINE try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); } _NEWLINE if(lenbuf <= 0)return -1; _NEWLINE } _NEWLINE return inbuf[ptrbuf++]; _NEWLINE } _NEWLINE private static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); } _NEWLINE private static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; } _NEWLINE private static double nd() { return Double.parseDouble(ns()); } _NEWLINE private static char nc() { return (char)skip(); } _NEWLINE private static String ns() _NEWLINE { _NEWLINE int b = skip(); _NEWLINE StringBuilder sb = new StringBuilder(); _NEWLINE while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ') _NEWLINE sb.appendCodePoint(b); _NEWLINE b = readByte(); _NEWLINE } _NEWLINE return sb.toString(); _NEWLINE } _NEWLINE private static char[] ns(int n) _NEWLINE { _NEWLINE char[] buf = new char[n]; _NEWLINE int b = skip(), p = 0; _NEWLINE while(p < n && !(isSpaceChar(b))){ _NEWLINE buf[p++] = (char)b; _NEWLINE b = readByte(); _NEWLINE } _NEWLINE return n == p ? buf : Arrays.copyOf(buf, p); _NEWLINE } _NEWLINE private static char[][] nm(int n, int m) _NEWLINE { _NEWLINE char[][] map = new char[n][]; _NEWLINE for(int i = 0;i < n;i++)map[i] = ns(m); _NEWLINE return map; _NEWLINE } _NEWLINE private static int[] na(int n) _NEWLINE { _NEWLINE int[] a = new int[n]; _NEWLINE for(int i = 0;i < n;i++)a[i] = ni(); _NEWLINE return a; _NEWLINE } _NEWLINE private static int ni() _NEWLINE { _NEWLINE int num = 0, b; _NEWLINE boolean minus = false; _NEWLINE while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE if(b == '-'){ _NEWLINE minus = true; _NEWLINE b = readByte(); _NEWLINE } _NEWLINE while(true){ _NEWLINE if(b >= '0' && b <= '9'){ _NEWLINE num = num * 10 + (b - '0'); _NEWLINE }else{ _NEWLINE return minus ? -num : num; _NEWLINE } _NEWLINE b = readByte(); _NEWLINE } _NEWLINE } _NEWLINE private static long nl() _NEWLINE { _NEWLINE long num = 0; _NEWLINE int b; _NEWLINE boolean minus = false; _NEWLINE while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')); _NEWLINE if(b == '-'){ _NEWLINE minus = true; _NEWLINE b = readByte(); _NEWLINE } _NEWLINE while(true){ _NEWLINE if(b >= '0' && b <= '9'){ _NEWLINE num = num * 10 + (b - '0'); _NEWLINE }else{ _NEWLINE return minus ? -num : num; _NEWLINE } _NEWLINE b = readByte(); _NEWLINE } _NEWLINE } _NEWLINE private static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); } _NEWLINE }
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stack> _NEWLINE #include<string> _NEWLINE #include<queue> _NEWLINE #include<stdlib.h> _NEWLINE #include<vector> _NEWLINE #include<cmath> _NEWLINE #define pb push_back _NEWLINE #define big long long _NEWLINE #define FOR(i,a,b) for(i=a;i<=b;i++) _NEWLINE #define RFOR(i,a,b) for(i=a;i>=b;i--) _NEWLINE #define vi vector<int> _NEWLINE #define vb vector<big> _NEWLINE using namespace std; _NEWLINE big checkprime(big n) _NEWLINE { _NEWLINE  _INDENT  _INDENT big i,count=0; _NEWLINE  _INDENT  _INDENT FOR(i,2,n-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n%i==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(count==1 || n==1)return 0; _NEWLINE  _INDENT  _INDENT return 1; _NEWLINE } _NEWLINE int main() { _NEWLINE 	big l,t,n,i,j,k,r,temp,m,x,y,z,a,b,c,sig,sum=0; _NEWLINE 	vb v; _NEWLINE 	big count=0; _NEWLINE 	string s; _NEWLINE 	cin>>t; _NEWLINE 	 _NEWLINE 	FOR(k,1,t) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT count=0; _NEWLINE 	 _INDENT  _INDENT cin>>l>>r; _NEWLINE 	 FOR(i,l,r) _NEWLINE 	 { _NEWLINE 	 _INDENT  _INDENT  _NEWLINE 	 _INDENT  _INDENT m=i; _NEWLINE 	 _INDENT  _INDENT sum=0; _NEWLINE 	 _INDENT  _INDENT while(m>0) _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT sum+=m%10; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT m/=10; _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT //cout<<"sum,num are "<<sum<<" "<<i<<endl; _NEWLINE 	 _INDENT  _INDENT if(checkprime(sum)==1) count++; _NEWLINE 	 } _NEWLINE 	 _INDENT  _INDENT cout<<count<<endl; _NEWLINE 	} _NEWLINE  _INDENT  _INDENT  _NEWLINE 	return 0; _NEWLINE }
for x in range(0,input()): _NEWLINE  k,q = input(),map(int,raw_input().split()) _NEWLINE  n = (2*sum(q) -k*k -k)/(2.0*k)+1 _NEWLINE  if(n == int(n)): _INDENT print sum(([abs(a - b) for a, b in zip(q, range( int(n), int(n)+k))]))/2 _NEWLINE  else: print - 1
//some variables _NEWLINE var four_letter_words = ["doup","frig","ours","skep","smar","spad","rale","plat","viol","esox","culb","amok","oont","coif","coir","aver","keen","vuln","tsar","apse","onyx","peen"]; _NEWLINE var seven_letter_words = ["abalone","abandon","ability","abolish","abdomen","abraham","abyssal","academy","account","achieve","acidity","acquire","acrobat","acronym","acrylic","actress","adaptor","address","already","adjourn","admiral","advance","advisor","aerator","aerosol","affable","afflict","affront","african","backlit","backlog","backrub","badland","baggage","bailout","balance","ballboy","balloon","baloney","bananas","bandage","bandaid"]; _NEWLINE var five_letter_words = ["pople","carom","ergot","aglet","cubeb","nerpa","taler","qitra","decoy","swain","oxter","panic"]; _NEWLINE  _NEWLINE var i, j, k; _NEWLINE var crypto = require('crypto'); _NEWLINE var possibility, hash; _NEWLINE  _NEWLINE for (i=0; i<four_letter_words.length; i++) { _NEWLINE 	for (j=0; j<seven_letter_words.length; j++) { _NEWLINE 		for (k=0; k<five_letter_words.length; k++) { _NEWLINE 			possibility = "The world is " + four_letter_words[i] + " " + seven_letter_words[j] + " this email was a " + five_letter_words[k]; _NEWLINE 			hash = crypto.createHash('md5').update(possibility).digest("hex"); _NEWLINE 			if (hash == "0c049ca2ad590d34d1753419f64eff19") { _NEWLINE 				console.log(possibility); _NEWLINE 				break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE } _INDENT _NEWLINE 
import sys _NEWLINE def numberToBase(n, b): _NEWLINE  _INDENT  _INDENT temp='' _NEWLINE  _INDENT  _INDENT while n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp+=str(n % b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n /= b _NEWLINE  _INDENT  _INDENT return temp _NEWLINE a=map(int,sys.stdin.readline().split()) _NEWLINE i=0 _NEWLINE while a[i]!=-1: _NEWLINE  _INDENT  _INDENT s=numberToBase(a[i],7) _NEWLINE  _INDENT  _INDENT s=s[::-1] _NEWLINE  _INDENT  _INDENT sys.stdout.write(s+" ") _NEWLINE  _INDENT  _INDENT i+=1 _NEWLINE 
fib=[] _NEWLINE  _NEWLINE i1,i2,i3=map(int, raw_input().split()) _NEWLINE y=i3 _NEWLINE  _NEWLINE p=i1 _NEWLINE fib.append(p) _NEWLINE r=i2 _NEWLINE fib.append(r) _NEWLINE  _NEWLINE while(y): _NEWLINE  _INDENT  _INDENT n=p+r _NEWLINE  _INDENT  _INDENT fib.append(n) _NEWLINE  _INDENT  _INDENT p=r _NEWLINE  _INDENT  _INDENT r=n _NEWLINE  _INDENT  _INDENT y-=1 _NEWLINE  _NEWLINE print fib.pop((i3-1)) _NEWLINE 
t=input() _NEWLINE t=t*2 _NEWLINE s="" _NEWLINE s1="" _NEWLINE st=[] _NEWLINE for i in range(0,t): _NEWLINE  _INDENT  _INDENT s=s+"*" _NEWLINE for i in range(0,t): _NEWLINE 	s1=s1+"-" _NEWLINE st.append(s) _NEWLINE temp="-" _NEWLINE for i in range(2,t,2): _NEWLINE  _INDENT  _INDENT temp2=temp+s[:t-i]+temp _NEWLINE  _INDENT  _INDENT st.append(temp2) _NEWLINE  _INDENT  _INDENT temp=temp+"-" _NEWLINE for i in range(t/2-1,0,-1): _NEWLINE 	temp2=s1[:i]+"*"+s1[i:t-i-2]+"*"+s1[t-i:] _NEWLINE 	st.append(temp2) _NEWLINE for each in st: _NEWLINE 	print each _NEWLINE print st[0]
import sys _NEWLINE def josephus(n,k): _NEWLINE  _INDENT  _INDENT if n==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (josephus(n-1,k)+k-1)%n+1 _NEWLINE n,k=map(int,sys.stdin.readline().split()) _NEWLINE sys.stdout.write("%d"%josephus(n,k)) _NEWLINE 
def div(n): _NEWLINE  _INDENT  _INDENT s=set() _NEWLINE  _INDENT  _INDENT for i in range(1,int(n**0.5)+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s.add(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s.add(n/i) _NEWLINE  _INDENT  _INDENT return sum(s)-n _NEWLINE  _INDENT  _INDENT  _NEWLINE q=int(raw_input()) _NEWLINE for i in range(q): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT print div(n)
import sys _NEWLINE  _NEWLINE def solve(GP,vis,V,cur,flag,parent) : _NEWLINE  _INDENT  _INDENT vis[cur] = 1 _NEWLINE  _INDENT  _INDENT for i in GP[cur] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (parent[cur]!=i) and V==i : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not vis[i] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT parent[i] = cur _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return solve(GP,vis,V,i,1,parent) _NEWLINE  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE n , m = map(int,sys.stdin.readline().split()) _NEWLINE GP _INDENT = [[] for __ in range(n+1)] _NEWLINE for i in range(m) : _NEWLINE  _INDENT  _INDENT a , b = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT GP[a].append(b) _NEWLINE  _INDENT  _INDENT GP[b].append(a) _NEWLINE  _NEWLINE ans , vis = True , [0 for __ in range(n+1)] _NEWLINE for i in range(1,n+1) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not vis[i] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT vis[i] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = solve(GP,vis,i,i,0,[0 for __ in range(n+1)]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ans == False : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _NEWLINE print "YES" if ans else "NO"
import bisect _INDENT _NEWLINE def find_lt(a,x): _NEWLINE  _INDENT  _INDENT #find rightmost value less than or equal to x _NEWLINE  _INDENT  _INDENT i=bisect.bisect_right(a,x) _NEWLINE  _INDENT  _INDENT if i: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return i-1 _INDENT _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return -1 _NEWLINE def find_ge(a,x): _NEWLINE  _INDENT  _INDENT #find leftmost item greator than or equal to x _NEWLINE  _INDENT  _INDENT i=bisect.bisect_left(a,x) _NEWLINE  _INDENT  _INDENT if i!=len(a): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return i _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return -1 _NEWLINE fibo=[]; _NEWLINE fibo.append(1); _NEWLINE fibo.append(1); _NEWLINE for i in xrange(500): _NEWLINE  _INDENT  _INDENT fibo.append(fibo[-2]+fibo[-1]); _NEWLINE  _INDENT  _INDENT #print fibo[len(fibo)-1]; _NEWLINE  _INDENT  _INDENT #print len(str(fibo[len(fibo)-1])); _NEWLINE while True: _NEWLINE  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a,b=map(int,raw_input().split()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a==0 and b==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  break; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT left=find_ge(fibo,a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT right=find_lt(fibo,b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print left,right _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print fibo[left],fibo[right] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if left==-1 or right==-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print right-left+1 _NEWLINE  _INDENT  _INDENT except: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT _NEWLINE 
def pd33(): _NEWLINE 	while True: _NEWLINE 		n=int(raw_input()) _NEWLINE 		if not n: break _NEWLINE 		s=raw_input() _NEWLINE 		if n>0: _NEWLINE 			m=len(s)/n _NEWLINE 			for i in range(n): _NEWLINE 				k=0 _NEWLINE 				for j in range(m): _NEWLINE 					if j%2!=0: _NEWLINE 						k=2*abs((n-1)/2.0-i) _NEWLINE 					else: _NEWLINE 						k=0 _NEWLINE 					if i>=n/2: _NEWLINE 						k=-k _NEWLINE 					sys.stdout.write(s[int(i+n*j+k)]) _NEWLINE 			print _NEWLINE 		 _NEWLINE 		 _NEWLINE  _NEWLINE  _NEWLINE if __name__=="__main__": _NEWLINE 	import sys _NEWLINE 	pd33()
t=int(raw_input()) _NEWLINE for i in range(0,t): _NEWLINE  _INDENT  _INDENT h,m=map(int, raw_input().split(":")) _NEWLINE  _INDENT  _INDENT ans = abs(30*h - 5.5*m) _NEWLINE  _INDENT  _INDENT p=min(360-ans,ans) _NEWLINE  _INDENT  _INDENT if(p%5==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO"
#include<cstdio> _NEWLINE #include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<cstring> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE int k,t; _NEWLINE int ans[10][5]; _NEWLINE for(int i = 0; i <= 9; i++){ _NEWLINE ans[i][0] = i; _NEWLINE for(int j = 1; j <= 3; j++){ _NEWLINE ans[i][j] = ans[i][j-1] * i; _NEWLINE ans[i][j] %= 10; _NEWLINE } _NEWLINE } _NEWLINE  _INDENT  long long int p; _NEWLINE  _INDENT  char s[25]; _NEWLINE  _INDENT  scanf("%d",&t); _NEWLINE  _INDENT  while(t--) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT  scanf("%s %lld",&s,&p); _NEWLINE  _INDENT  _INDENT  k=s[strlen(s)-1]-'0'; _NEWLINE  _INDENT  _INDENT  if(p==0){printf("1\n");continue;} _NEWLINE  _INDENT  _INDENT  p--; _NEWLINE  _INDENT  _INDENT  printf("%d\n",ans[k][p%4]); _NEWLINE  _INDENT  } _NEWLINE  _INDENT  return 0; _NEWLINE }
 _NEWLINE  _NEWLINE t= long(raw_input()); _NEWLINE  _NEWLINE while ( t ): _NEWLINE 	n = long(raw_input()); _NEWLINE 	 _NEWLINE 	a= map(long, raw_input().split()); _NEWLINE 	 _NEWLINE 	b=sum(a); _NEWLINE 	 _NEWLINE 	if ( b%2 ): _NEWLINE 		print "Sam"; _NEWLINE 	else: _NEWLINE 		print "Zuck"; _NEWLINE  _NEWLINE 	t-=1; _NEWLINE 
for x in range(input()): _NEWLINE  _INDENT  _INDENT ndays = input() _NEWLINE  _INDENT  _INDENT nsize = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT last = nsize[0] _NEWLINE  _INDENT  _INDENT incr = 0 _NEWLINE  _INDENT  _INDENT for i in nsize: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i>last: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT incr+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT last = i _NEWLINE  _INDENT  _INDENT print incr _INDENT _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 
from collections import Counter _NEWLINE for x in range(input()): _NEWLINE  _INDENT  _INDENT ndays = input() _NEWLINE  _INDENT  _INDENT nsize = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print max(Counter(nsize).values())-1
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE long long fact[1000005]; _NEWLINE int T,N; _NEWLINE int main() _NEWLINE { _NEWLINE 	for(int i=1; i<=1000000; i++)fact[i]=1; _NEWLINE 	for(int i=2; i<=1000000; i++) _NEWLINE 	{ _NEWLINE 		fact[i]++; _NEWLINE 		for(int j=i+i; j<=1000000; j+=i)fact[j]++; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	for(int i=2; i<=1000000; i++)fact[i]=fact[i-1]+fact[i]; _NEWLINE 	cin>>T; _NEWLINE 	while(T--) _NEWLINE 	{ _NEWLINE 		scanf("%d",&N); _NEWLINE 		cout<<(fact[N]*2)<<"\n"; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
def pali(st): _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT n=len(st) _NEWLINE  _INDENT  _INDENT while(i<n/2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(st[i]!=st[n-1-i]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT if(i==n/2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE def pang(st): _NEWLINE  _INDENT  _INDENT li=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'] _NEWLINE  _INDENT  _INDENT lii=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT n=len(st) _NEWLINE  _INDENT  _INDENT while(i<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lii[li.index(st[i])]+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT while(i<26): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(lii[i]==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT if(i==26): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE t=int(raw_input()) _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT s=raw_input() _NEWLINE  _INDENT  _INDENT if(pali(s)==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pang(s)==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print("palingram") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print("palindrome") _NEWLINE  _INDENT  _INDENT elif(pang(s)==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print("pangram") _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print("none") _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE 
t=input() _NEWLINE while(t): _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT x=raw_input() _NEWLINE  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT for i in range(0,len(x)-n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=x[i:i+n] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(s==s[::-1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=c+1 _NEWLINE  _INDENT  _INDENT print c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
def LIS(A): _NEWLINE 	DP = [0]*len(A) _NEWLINE 	DP[0] = 1 _NEWLINE 	for x in range(1,len(A)): DP[x] = max([DP[y] + 1 if A[y] <= A[x] else 1 for y in range(x)]) _NEWLINE 	return max(DP) _NEWLINE raw_input() _NEWLINE  _NEWLINE  _INDENT _NEWLINE # binary search _NEWLINE # search for *max* j in lo..hi, s.t., s[m[j]] < s[i] _NEWLINE def binary_search(s, i, m, p, lo, hi): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s[m[hi]] <= s[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return hi _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if lo > hi: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0 # not found _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid = lo + (hi - lo)/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s[m[mid]] < s[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return binary_search(s, i, m, p, mid, hi - 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return binary_search(s, i, m, p, lo, mid - 1) _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE def search(s, i, m, p, L): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return binary_search(s, i, m, p, 1, L) _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _NEWLINE def lis(s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n = len(s) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # for an increasing sequence of length j, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # m[j] = k is the position of the smallest value s[k] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # that is end of the sequence of length j. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # so s[m[1]], s[m[2]], ... s[m[L]] is the longest sequence. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m = [-1]*(n + 1) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # p[i] is the position of the predecessor of s[i] in an increasing sequence. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # need to use p[i] in binary search _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p = [0]*n _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # current max length _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT L = 0 _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i, si in enumerate(s): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # search for maximum j, s.t., s[m[j]] < s[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # i.e., j is the max length of an i.s that has end value less than s[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = search(s, i, m, p, L) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # parrent of i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p[i] = m[j] _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j == L or s[m[j + 1]] > s[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # update the end of sequence of length j + 1 to be i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # it can happen when j == L, i.e., x[i] extends the current longest i.s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # OR, x[i] is a new end of an existing i.s. of length j + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT m[j + 1] = i _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT L = max(L, j + 1) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return L _NEWLINE  _INDENT _NEWLINE print lis([int(x) for x in raw_input().split()]) _NEWLINE 
#include <stdio.h> _NEWLINE  _NEWLINE int main(void) { _NEWLINE 	int p,n,t; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		char a[5]; _NEWLINE 		int odd[504],even[503],i,j=0,k=0; _NEWLINE 		scanf("%d%s%d",&n,a,&p); _NEWLINE 		for(i=1;i<=n;i++) _NEWLINE 		{ _NEWLINE 			if(i%2==0) _NEWLINE 			 even[j++]=i; _NEWLINE 			else _NEWLINE 			 odd[k++]=i; _NEWLINE 		} _NEWLINE 		if(a[0]=='o') _NEWLINE 		 printf("%d\n",even[p-1]); _NEWLINE 		else _NEWLINE 		 printf("%d\n",odd[p-1]); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
arr=[1] _NEWLINE for i in xrange(1,100001): _NEWLINE  _INDENT  _INDENT arr.append(((arr[i-1]%1589540031)*(i%1589540031))%1589540031) _NEWLINE t=int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT print arr[n] _NEWLINE 
# your code goes here _NEWLINE from sys import stdin, stdout _NEWLINE t = int(stdin.readline()) _NEWLINE while t: _NEWLINE 	t -= 1 _NEWLINE 	n = int(stdin.readline()) _NEWLINE 	d = [] _NEWLINE 	for _ in xrange(n): _NEWLINE 		a, p = map(int, stdin.readline().strip().split(' ')) _NEWLINE 		d.append([p,a]) _NEWLINE 		if n>1 and p == 0: _NEWLINE 			d.pop() _NEWLINE 			n -= 1 _NEWLINE 	ans = "" _NEWLINE 	for i in range(len(d)): _NEWLINE 		if i < n-1: _NEWLINE 			if d[i][0] == 1: _NEWLINE 				ans += str(d[i][1]*(d[i][0])) _NEWLINE 			else: _NEWLINE 				ans += str(d[i][1]*(d[i][0])) + "x^" + str(d[i][0]-1) _NEWLINE 			ans += " + " _NEWLINE 		else: _NEWLINE 			if d[i][0] == 0 and n == 1: _NEWLINE 				ans = "0" _NEWLINE 			elif d[i][0] == 1: _NEWLINE 				ans += str(d[i][1]*(d[i][0])) _NEWLINE 			else: _NEWLINE 				ans += str(d[i][1]*(d[i][0])) + "x^" + str(d[i][0]-1) _NEWLINE 	stdout.write(ans + '\n') _NEWLINE 	
for i in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x%2<>0 and x<>1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'No' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if x<>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'Yes' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 'No' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
import java.math.BigInteger; _NEWLINE import java.util.Scanner; _NEWLINE  _NEWLINE /** _NEWLINE  * Created by Jess on 4/16/2015. _NEWLINE  */ _NEWLINE public class Main { _NEWLINE  _INDENT  _INDENT public static void main(String[] args) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Scanner sc = new Scanner(System.in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int tcs; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT BigInteger base, mod, power; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tcs = sc.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < tcs; i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT base = sc.nextBigInteger();; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT power = sc.nextBigInteger(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mod = sc.nextBigInteger(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT base = base.modPow(power, mod); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(base); _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE 
#include<stdio.h> _NEWLINE #include<string.h> _NEWLINE #include<math.h> _NEWLINE int main() _NEWLINE { _NEWLINE  int t; _NEWLINE  long long i,j,num,n,k,tmp,rem,ans; _NEWLINE  scanf("%d",&t); _NEWLINE  while(t--){ _NEWLINE  _INDENT scanf("%lld",&num); _NEWLINE  _INDENT tmp = 0, n = 0; _NEWLINE  _INDENT while(tmp < num){ _NEWLINE  _INDENT  n =n+1; _NEWLINE  _INDENT  tmp = pow(2,n+1) - 2; _NEWLINE  _INDENT } _NEWLINE  _INDENT tmp = pow(2,n)-2; _NEWLINE  _INDENT ans = num - tmp -1; _NEWLINE  _INDENT char str[100000]; _NEWLINE  _INDENT k = -1; _NEWLINE  _INDENT while(ans>0){ _NEWLINE  _INDENT  rem = ans%2; _NEWLINE  _INDENT  k = k+1; _NEWLINE  _INDENT  str[k] = rem + '0'; _NEWLINE  _INDENT  ans = ans/2; _NEWLINE  _INDENT  } _NEWLINE  _INDENT  j = n-k-1; _NEWLINE  _INDENT  for(i =1; i<= j; i++) _NEWLINE  _INDENT  _INDENT printf("5"); _NEWLINE  _INDENT  for(i =k; i>=0; i--) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT if(str[i] == '0') _NEWLINE  _INDENT  _INDENT  _INDENT printf("5"); _NEWLINE  _INDENT  _INDENT else _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT printf("6"); _NEWLINE  _INDENT  } _NEWLINE  _INDENT  printf("\n"); _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE  }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT int a1[10][10],a2[10][10],a[10][10],i,j,k,r,sum=0; _NEWLINE  _INDENT  _INDENT scanf("%d",&r); _NEWLINE 	for(i=0;i<r;i++) _NEWLINE 	{ _NEWLINE 	for(j=0;j<r;j++) _NEWLINE 	{ _NEWLINE 	scanf("%d",&a1[i][j]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE 	for(i=0;i<r;i++) _NEWLINE 	{ _NEWLINE 	for(j=0;j<r;j++) _NEWLINE 	{ _NEWLINE  _INDENT  _INDENT scanf("%d",&a2[i][j]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE 	for(i=0;i<r;i++) _NEWLINE 	{ _NEWLINE 	for(j=0;j<r;j++) _NEWLINE 	{ _NEWLINE 	for(k=0;k<r;k++) _NEWLINE 	{ _NEWLINE 	sum=sum+a1[i][k]*a2[k][j]; _NEWLINE 	} _NEWLINE 	a[i][j]=sum; _NEWLINE  _INDENT  _INDENT  _INDENT  sum=0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE 	for(i=0;i<r;i++) _NEWLINE 	{ _NEWLINE 	for(j=0;j<r;j++) _NEWLINE 	{ _NEWLINE 	printf("%d ",a[i][j]); _NEWLINE 	} _NEWLINE 	printf("\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE return 0; _NEWLINE }
//PPOW, Setter's solution _NEWLINE #include<iostream> _NEWLINE int powers[13][4006]={0}; _NEWLINE int main() _NEWLINE { _NEWLINE 	int a,n,i,j,k=0,r,b,o,sum,t; _NEWLINE 	//FILE *f1=freopen("in2.txt","r",stdin); _NEWLINE 	//FILE *f2=freopen("out2.txt","w",stdout); _NEWLINE 	r=0; _NEWLINE 	//po[0]=1; _NEWLINE 	for(o=2;o<=9;o++) _NEWLINE 	{ _NEWLINE 		k=0; _NEWLINE 		r=0; _NEWLINE 		int po[4004]={0}; _NEWLINE 		po[0]=1; _NEWLINE 		 _NEWLINE 	 _INDENT for(i=1;i<=4000;i++) _NEWLINE 	 _INDENT { _NEWLINE 		for(j=0;j<=k;j++) _NEWLINE 		{ _NEWLINE 		 po[j]=po[j]*o+r; _NEWLINE 		 r=po[j]/10; _NEWLINE 		 po[j]=po[j]%10; _NEWLINE 		 //sum=0; _NEWLINE 		 _INDENT _NEWLINE 		 if(r!=0&&j==k) _NEWLINE 		 k++; _NEWLINE 		} _NEWLINE 		sum=0; _NEWLINE 		for(int l=0;l<=k;l++) _NEWLINE 	 _INDENT  _INDENT  sum+=po[l]; _NEWLINE 	 _INDENT  _INDENT  powers[o][i]=sum; _NEWLINE 		 _NEWLINE 	 _INDENT } _NEWLINE 	 // printf("k=%d\n",k); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(i=0;i<=4000;i++) _NEWLINE  _INDENT  _INDENT powers[1][i]=1; _NEWLINE  _INDENT  _INDENT for(i=1;i<=9;i++) _NEWLINE  _INDENT  _INDENT powers[i][0]=1; _NEWLINE 	 _NEWLINE //	printf("computed\n"); _NEWLINE 	scanf("%d",&t); _NEWLINE 	for(i=1;i<=t;i++) _NEWLINE 	{ _NEWLINE 		scanf("%d%d",&a,&b); _NEWLINE 		printf("Case %d: %d\n",i,powers[a][b]); _NEWLINE 	}	 _NEWLINE //	fclose(f1); _NEWLINE //	fclose(f2); _NEWLINE 	return 0; _NEWLINE } 
for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT a,b,c=map(float,raw_input().split()) _NEWLINE  _INDENT  _INDENT t=(a+b+c)*(a+b-c)*(a+c-b)*(b+c-a) _NEWLINE  _INDENT  _INDENT t=a*b*c/(t**0.5) _NEWLINE  _INDENT  _INDENT print t _NEWLINE 
t=input("") _NEWLINE while t: _NEWLINE  _INDENT t=t-1 _NEWLINE  _INDENT a=input("") _NEWLINE  _INDENT if(a==2): _NEWLINE  _INDENT  _INDENT print "YES" _INDENT  _NEWLINE  _INDENT elif(a%4==1): _NEWLINE  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT else: _NEWLINE  _INDENT  _INDENT print "NO" _NEWLINE 
T = input() _NEWLINE for _ in range(T): _NEWLINE 	input() _NEWLINE 	m = map(int, raw_input().split()) _NEWLINE 	print str(m[1:])[1:-1].replace(',',''), m[0]
n = int(raw_input()) _NEWLINE  _NEWLINE if n % 2 ==0: _NEWLINE  _INDENT  _INDENT print "YES" _NEWLINE else: _NEWLINE  _INDENT  _INDENT print "NO"
#include <cstring> _NEWLINE #include <iostream> _NEWLINE #include <stdio.h> _NEWLINE #include <cstdlib> _NEWLINE #include <cctype> _NEWLINE #include <algorithm> _NEWLINE #include <map> _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bits/stdc++.h> _NEWLINE #include <string> _NEWLINE #include <cmath> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define mod 1000000007 _NEWLINE #define ll long long _NEWLINE #define ff first _NEWLINE #define ss second _NEWLINE #define inf _INDENT 1e9 _NEWLINE #define infll 1e18 _NEWLINE #define pr(x) printf("%d\n",x) _NEWLINE #define prs(x) printf("%d ",x) _NEWLINE #define sc(x) scanf("%d",&x) _NEWLINE #define trc(x) cout << #x << " = " << x << endl _NEWLINE #define fr(i,a,n) for(i=a;i<n;i++) _NEWLINE #define fd(i,a,n) for(i=n;i>a;i--) _NEWLINE #define fiv(v) for(i=0;i<v.size();i++) _NEWLINE #define fill(a,v) memset(a,v,sizeof(a)) _NEWLINE #define all(a) a.begin(),a.end() _NEWLINE #define iter(c,it) for(typeof((c).begin()) it= (c).begin(); it != (c).end(); it++) _NEWLINE  _NEWLINE typedef pair<int,int> pi; _NEWLINE typedef vector<int> vi; _NEWLINE  _NEWLINE char s[101]; _NEWLINE int dp[102][2][102],n; _NEWLINE int sol(char s[],int i,int last,int con,int p,int q) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(i==n)return 0; _NEWLINE  _INDENT  _INDENT int &res=dp[i][last][con]; _NEWLINE  _INDENT  _INDENT if(res!=-1)return res; _NEWLINE  _INDENT  _INDENT res=0; _NEWLINE  _INDENT  _INDENT if(last==0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(con<p) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res=max(res,(s[i]=='W')+sol(s,i+1,0,con+1,p,q)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res=max(res,(s[i]!='W')+sol(s,i+1,1,1,p,q)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(con<q) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res=max(res,(s[i]!='W')+sol(s,i+1,1,con+1,p,q)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res=max(res,(s[i]=='W')+sol(s,i+1,0,1,p,q)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return res; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int i,j,k,l,m,t,c=0,ans; _NEWLINE  _INDENT  _INDENT #ifndef ONLINE_JUDGE _NEWLINE  _INDENT  // freopen("in.txt","r",stdin); _NEWLINE  _INDENT  _INDENT #endif _NEWLINE  _INDENT  _INDENT sc(t); _NEWLINE  _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT int p,q; _NEWLINE  _INDENT  _INDENT  _INDENT sc(p);sc(q); _NEWLINE  _INDENT  _INDENT  _INDENT scanf("%s",s); _NEWLINE  _INDENT  _INDENT  _INDENT fill(dp,-1); _NEWLINE  _INDENT  _INDENT  _INDENT n=strlen(s); _NEWLINE  _INDENT  _INDENT  _INDENT j=sol(s,0,0,0,p,q); _NEWLINE  _INDENT  _INDENT  _INDENT pr(j); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
from math import sqrt _NEWLINE t=input() _NEWLINE while t!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(2,int(sqrt(n))+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if n%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if str(i).find('5')!=-1 or str(i).find('3')!=-1 or str(i).find('6')!=-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # _INDENT  _INDENT  _INDENT  print i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if str(n/i).find('5')!=-1 or str(n/i).find('3')!=-1 or str(n/i).find('6')!=-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # _INDENT  _INDENT  _INDENT  print n/i _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if str(n).find('3')!=-1 or str(n).find('5')!=-1 or str(n).find('6')!=-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t-=1
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE vector<int> vec; _NEWLINE  _NEWLINE #define INPUT(_x) int _x;cin>>_x; _NEWLINE #define FOR(i,a,b) for(int i=a;i<=b;i++) _NEWLINE #define TCASE int _t;cin>>_t;FOR(i,1,_t) _NEWLINE #define VECTORFILL(_vec) int _x;cin>>_x;while(_x!=-1){_vec.push_back(_x);cin>>_x;} _NEWLINE #define VECTOR_FILL(_vec,size) int _x;FOR(i,1,size){cin>>_x; _vec.push_back(_x);} _NEWLINE #define VECTORPRINT(_vec) int _t=-1;while((++_t)<_vec.size()){cout<<_vec[_t]<<" ";} _NEWLINE  _NEWLINE long long int factorial(int x){ _NEWLINE  _INDENT  _INDENT if(x==1) return 1; _NEWLINE  _INDENT  _INDENT else return x*factorial(x-1); _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT TCASE{ _NEWLINE  _INDENT  _INDENT  _INDENT  int t; cin>>t; _NEWLINE  _INDENT  _INDENT  _INDENT  long long int ans=0; _NEWLINE  _INDENT  _INDENT  _INDENT  if(t==1) ans=0; _NEWLINE  _INDENT  _INDENT  _INDENT  else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  FOR(i,2,t){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int sign=pow(-1,i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+= sign*factorial(t)/factorial(i); _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<ans<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
def ps(n): _NEWLINE  _INDENT  _INDENT r = int(n**0.5) _NEWLINE  _INDENT  _INDENT assert r*r <= n and (r+1)**2 > n _NEWLINE  _INDENT  _INDENT V = [n//i for i in range(1,r+1)] _NEWLINE  _INDENT  _INDENT V += list(range(V[-1]-1,0,-1)) _NEWLINE  _INDENT  _INDENT S = {i:i*(i+1)//2-1 for i in V} _NEWLINE  _INDENT  _INDENT for p in range(2,r+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if S[p] > S[p-1]: _INDENT # p is prime _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sp = S[p-1] _INDENT # sum of primes smaller than p _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p2 = p*p _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for v in V: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if v < p2: break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S[v] -= p*(S[v//p] - sp) _NEWLINE  _INDENT  _INDENT return S[n]# your code goes here _NEWLINE  _NEWLINE print ps(int(raw_input()))
from random import randint _NEWLINE def fun(N): _NEWLINE 	if N>1 : _NEWLINE 		for _ in xrange(5): _NEWLINE 			Num=randint(1,N-1) _NEWLINE 			if pow(Num,N-1,N)!=1: _NEWLINE 				return False _NEWLINE 		return True _NEWLINE 	return False _NEWLINE for _ in xrange(input()): _NEWLINE 	if(fun(input())): _NEWLINE 		print "PRIME" _NEWLINE 	else: _NEWLINE 		print "COMPOSITE" _NEWLINE 
def millerRabin(n): _NEWLINE 	# Returns true if probable prime, false if composite _NEWLINE 	bases _INDENT  _INDENT  = [2,3,5,7,11,13,17,19,23] _NEWLINE 	nm1 _INDENT  _INDENT  _INDENT  = n-1 _NEWLINE 	m _INDENT  _INDENT  _INDENT  _INDENT  = nm1 _NEWLINE 	d _INDENT  _INDENT  _INDENT  _INDENT  = 0 _NEWLINE  _NEWLINE 	if n in bases: _NEWLINE 		return True _NEWLINE 	if n < 2: _NEWLINE 		return False _NEWLINE  _NEWLINE 	while not m&1: _NEWLINE 		d _INDENT  _INDENT += 1 _NEWLINE 		m _INDENT  >>= 1 _NEWLINE  _NEWLINE 	for a in bases: _NEWLINE 		done_for_base = False _NEWLINE  _NEWLINE 		b _INDENT  = pow(a,m,n) _NEWLINE 		if b == 1 or b == nm1 : _NEWLINE 			#done_for_base = True _NEWLINE 			continue _NEWLINE 		for k in range(d-1): _NEWLINE 			b = pow(b,2,n) _NEWLINE 			if b == 1: _NEWLINE 				return False _NEWLINE 			elif b == nm1: _NEWLINE 				done_for_base = True _NEWLINE 				break _NEWLINE 		if not done_for_base: _NEWLINE 			return False _NEWLINE 	return True _NEWLINE  _NEWLINE def valAt(x,y): _NEWLINE 	if x>y: _NEWLINE 		if x+y > 0: _NEWLINE 			n _INDENT = 4*x*x - 3*x + y _NEWLINE 		else : _NEWLINE 			n _INDENT = 4*y*y - 3*y + x _NEWLINE 	else: _NEWLINE 		if x+y > 0: _NEWLINE 			n _INDENT = 4*y*y - _INDENT x - y _NEWLINE 		else : _NEWLINE 			n _INDENT = 4*x*x - _INDENT y - x _NEWLINE 	return n _NEWLINE  _NEWLINE def solveCase(x,y): _NEWLINE 	r _INDENT  _INDENT = 0 _NEWLINE 	n _INDENT  _INDENT = valAt(x,y) _NEWLINE 	if millerRabin(n): _NEWLINE 		return r _NEWLINE 	while True: _NEWLINE 		r _INDENT += 1 _NEWLINE 		for k in range(r): _NEWLINE 			n1 _INDENT = valAt(x + r-k, y + 0-k) _NEWLINE 			n2 _INDENT = valAt(x + 0-k, y - r+k) _NEWLINE 			n3 _INDENT = valAt(x - r+k, y + 0+k) _NEWLINE 			n4 _INDENT = valAt(x + 0+k, y + r-k) _NEWLINE 			for n in [n1,n2,n3,n4]: _NEWLINE 				if millerRabin(n): _NEWLINE 					return r _NEWLINE  _NEWLINE def main(): _NEWLINE 	T _INDENT = int(raw_input('')) _NEWLINE 	for t in range(T): _NEWLINE 		x,y = [ int(i) for i in raw_input().split() ] _NEWLINE 		ans = solveCase(x,y) _NEWLINE 		print ans _NEWLINE  _NEWLINE  _NEWLINE main() _NEWLINE 
while 1: _NEWLINE 	N,M=map(int,raw_input().split()); _NEWLINE 	if N==0 and M==0: _NEWLINE 		break _NEWLINE 	else: _NEWLINE 		A,B=N,M; CR=0; ct=0; _NEWLINE 		while A or B: _NEWLINE 			q,r=A%10,B%10; _NEWLINE 			if q+r+CR>9: _NEWLINE 				ct+=1;	CR=1; _NEWLINE 			A/=10;	B/=10; _NEWLINE 		if ct==0: _NEWLINE 			print "No carry operation." _NEWLINE 		elif ct==1: _NEWLINE 			print "1 carry operation." _NEWLINE 		else: _NEWLINE 			print "%d carry operations." %ct _NEWLINE 			 _INDENT _NEWLINE 
#include <stdio.h> _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int n,a[200],index,temp,i,t,j; _NEWLINE  _INDENT  _INDENT int prime[27]={1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97}; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[0]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT index=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=0;(prime[j]<=n)&&(j<26);j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<=index;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=(a[i]*prime[j])+temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i]=temp%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=temp/10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(temp>0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[++index]=temp%10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=temp/10; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=index;i>=0;i--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d",a[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return(0); _NEWLINE }
a=input() _NEWLINE for i in range(a): _NEWLINE 	b=raw_input() _NEWLINE 	string="" _NEWLINE 	for j in b: _NEWLINE 		k=ord(j) _NEWLINE 		if(48<=k<=57): _NEWLINE 			string+=chr(k+57) _NEWLINE 		elif(97<=k<=104): _NEWLINE 			string+=chr(k+18) _NEWLINE 		elif(105<=k<=114): _NEWLINE 			string+=chr(k-57) _NEWLINE 		elif(115<=k<=122): _NEWLINE 			string+=chr(k-18) _NEWLINE 		else: _NEWLINE 			string+=j _NEWLINE 	print string _NEWLINE 
tc = int(raw_input()) _NEWLINE while (tc>0): _NEWLINE 	tc = tc - 1 _NEWLINE 	a, b, c = map(int, raw_input().split()) _NEWLINE 	print a*720/(b+c) _NEWLINE 
def isNumberPrime(n): _NEWLINE  _INDENT  _INDENT if n == 2: return True _NEWLINE  _INDENT  _INDENT if n % 2 == 0 or n == 1: return False _NEWLINE  _INDENT  _INDENT for num in xrange(3, int(n**0.5) + 2, 2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n % num == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT return True _NEWLINE  _NEWLINE def isPalindrome(n): _NEWLINE  _INDENT  _INDENT s = str(n) _NEWLINE  _INDENT  _INDENT return s==s[::-1] _NEWLINE  _NEWLINE def prpalin(): _NEWLINE  _INDENT  _INDENT """1 <= N <= 1000000""" _NEWLINE  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT while not (isPalindrome(N) and isNumberPrime(N)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N += 1 _NEWLINE  _INDENT  _INDENT print N _INDENT  _INDENT _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT prpalin()
#include<bits/stdc++.h> _NEWLINE #define LL long long _NEWLINE using namespace std; _NEWLINE pair<LL,LL>pa[30010]; _NEWLINE int bs(LL x, int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT int start=0, end=n-1, mid= (start+end)>>1; _NEWLINE  _INDENT  _INDENT while(end-start>=2) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pa[mid].first<=x) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start=mid; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else end=mid-1; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid= (start+end)>>1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(1) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pa[end].first<x) return end; end--; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE } _NEWLINE main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,i,j,N; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&N); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<N;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&pa[i].second); _INDENT //starting _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&pa[i].first); // finishing time _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pa[N].first= pa[N].second= - 1000000000000LL; // append it at the beginning so that the if a number less than x is not found it returns 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(pa,pa+N); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT // now calculate P[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT LL dp[N+10]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int P[N+10]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P[0]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<N;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT P[j]= bs(pa[j].second,j); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[0]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<N;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[i]= max(dp[i-1], dp[P[i]]+ pa[i].first- pa[i].second+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",dp[N-1]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  return 0; _NEWLINE }
#chiragjn _NEWLINE t=int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE 	n,m=map(int,raw_input().split()) _NEWLINE 	print m+(n>>1) if m<=n/2 else m-(n>>1)
for _ in range(input()): _NEWLINE 	s=raw_input().split() _NEWLINE 	c=0 _NEWLINE 	for i in range(len(s)): _NEWLINE 		if s[i][0]==s[i][4] and s[i][1]==s[i][3]: _NEWLINE 			c+=1 _NEWLINE 		elif s[i][0]==s[i][1]and s[i][3]==s[i][4]: _NEWLINE 			c+=1 _NEWLINE 		elif s[i][0]==s[i][3] and s[i][1]==s[i][4]: _NEWLINE 			c+=1 _NEWLINE 	print c		
n=int(input()) _NEWLINE l=[] _NEWLINE for i in range(0,n): _NEWLINE  x=raw_input() _NEWLINE  val=0 _NEWLINE  for char in x: _NEWLINE  _INDENT val=val+ord(char)-64 _NEWLINE  l.append(val) _NEWLINE for i in l: _NEWLINE  print i
lis=[i for i in range(2,100002,2)] _NEWLINE lis1=[] _NEWLINE for i in xrange(len(lis)): _NEWLINE  _INDENT  _INDENT lis1.append(lis[i]) _NEWLINE s=lis1[0] _NEWLINE  _NEWLINE for i in range(1,len(lis1)): _NEWLINE  _INDENT  _INDENT lis1[i]+=s _NEWLINE  _INDENT  _INDENT s=lis1[i] _NEWLINE #print lis1 _INDENT  _INDENT  _NEWLINE for _ in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT for i in xrange(len(lis1)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n<=lis1[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT #print i _NEWLINE  _INDENT  _INDENT if n<=lis1[i]-(i+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print lis[i]-1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print lis[i]
#!/usr/bin/env python _NEWLINE MAXN = 26 _NEWLINE  _NEWLINE parent = [0] * MAXN _NEWLINE rank _INDENT  = [0] * MAXN _NEWLINE  _NEWLINE def UF_MakeSet(): _NEWLINE  _INDENT  _INDENT for x in xrange(MAXN): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT parent[x] = x _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rank[x] _INDENT  = 0 _NEWLINE  _NEWLINE def UF_Union(x, y): _NEWLINE  _INDENT  _INDENT xRoot = UF_Find(x) _NEWLINE  _INDENT  _INDENT yRoot = UF_Find(y) _NEWLINE  _INDENT  _INDENT if _INDENT  xRoot == yRoot: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  return _NEWLINE  _INDENT  _INDENT if _INDENT  rank[xRoot] < rank[yRoot]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  parent[xRoot] = yRoot _NEWLINE  _INDENT  _INDENT elif rank[xRoot] > rank[yRoot]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  parent[yRoot] = xRoot _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  parent[yRoot] = xRoot _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  rank[xRoot] _INDENT += 1 _NEWLINE  _NEWLINE def UF_Find(x): _NEWLINE  _INDENT  _INDENT if parent[x] != x: _NEWLINE  _INDENT  _INDENT  _INDENT  parent[x] = UF_Find(parent[x]) _NEWLINE  _INDENT  _INDENT return parent[x] _NEWLINE  _NEWLINE def isABconnected(G, e): _NEWLINE  _INDENT  _INDENT UF_MakeSet() _NEWLINE  _INDENT  _INDENT for i in xrange(len(G)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i == e: continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = ord(G[i][0])-ord('A') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = ord(G[i][1])-ord('A') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT UF_Union(x, y) _NEWLINE  _INDENT  _INDENT return UF_Find(0) == UF_Find(1) _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT G = [] _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT R = raw_input().strip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if R == 'END': break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT G += [R] _NEWLINE  _INDENT  _INDENT N = 0 _NEWLINE  _INDENT  _INDENT for i in xrange(len(G)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not isABconnected(G, i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  print G[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  N += 1 _NEWLINE  _INDENT  _INDENT if not N: _NEWLINE  _INDENT  _INDENT  _INDENT  print 'Too Bad, We Lose' _NEWLINE  _NEWLINE main() _NEWLINE  _NEWLINE 
 _NEWLINE n = input() _NEWLINE q = raw_input() _NEWLINE  _NEWLINE o = ['']*n _NEWLINE c = 0 _NEWLINE for i in xrange(n): _NEWLINE 	q1 = int(q[n-1-i], 16)%4 _NEWLINE 	q2 = int(q[n-1-i], 16)/4 # 00-00 11-11 10-01 10-01 : 0-0 3-3 1-2 2-1 _NEWLINE 	a = (q1+q2+c) % 4 _NEWLINE 	c = (q1+q2+c) / 4 _NEWLINE 	o[n-1-i] = '{:02b}'.format(a) _NEWLINE  _NEWLINE print ''.join(o) _NEWLINE 
import math _NEWLINE t=input() _NEWLINE while t>0: _NEWLINE 	t-=1 _NEWLINE 	time=raw_input() _NEWLINE 	hrs=int(time[0:2]) _NEWLINE  _NEWLINE 	mint=int(time[2:4]) _NEWLINE 	#print hrs," _INDENT ",mint _NEWLINE 	p=input() _NEWLINE 	mi=p/60 _NEWLINE 	sec=p%60 _NEWLINE 	 _NEWLINE 	hs=0 _NEWLINE 	if mi>=60: _NEWLINE 		hs+=(mi/60) _NEWLINE 		mi%=60 _NEWLINE  _NEWLINE 	 _NEWLINE 		 _NEWLINE  _NEWLINE 	hrs=(hrs+hs)%24 _NEWLINE 	mint=(mint+mi) _NEWLINE 	if mint>=60: _NEWLINE 		hrs+=1 _NEWLINE 		hrs%=24 _NEWLINE 		mint%=60 _NEWLINE 	 _NEWLINE 	if(sec >0): _NEWLINE  _NEWLINE 		if(not(hrs==23 and mint==59)): _NEWLINE 			mint+=1 _NEWLINE 			if(mint>=60): _NEWLINE 				hrs+=1 _NEWLINE 				hrs%=24 _NEWLINE 				mint%=60 _NEWLINE 			 _NEWLINE 		 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	 _NEWLINE 	h="" _NEWLINE 	s="" _NEWLINE 	if hrs<10: _NEWLINE 		h="0"+str(hrs) _NEWLINE 	else: _NEWLINE 		h=str(hrs) _NEWLINE 	if mint<10: _NEWLINE 		s="0"+str(mint) _NEWLINE 	else: _NEWLINE 		s=str(mint) _NEWLINE 	print h+s	 _NEWLINE 
 _NEWLINE  _NEWLINE tt = int(raw_input()) _NEWLINE  _NEWLINE def printMaxActivities(s, f, n): _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT f, s = zip(*sorted(zip(f, s))) _NEWLINE  _INDENT  _INDENT #print f, s, f[0], s[1] _NEWLINE  _INDENT  _INDENT i = 0 _NEWLINE  _INDENT  _INDENT ans = 1 _NEWLINE  _INDENT  _INDENT for j in xrange(n): _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # If this activity has start time greater than _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # or equal to the finish time of previously _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # selected activity, then select it _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s[j] > f[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #sol1.append(j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print 'adsf' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = j _NEWLINE  _NEWLINE  _INDENT  _INDENT #print sol1 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return ans _NEWLINE  _NEWLINE sol = [] _NEWLINE for i in xrange(tt): _NEWLINE  _INDENT  _INDENT b = int(raw_input()) _NEWLINE  _INDENT  _INDENT start = [] _NEWLINE  _INDENT  _INDENT finish = [] _NEWLINE  _INDENT  _INDENT for j in xrange(b): _NEWLINE  _INDENT  _INDENT 	a = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT 	start.append(a[0]) _NEWLINE  _INDENT  _INDENT 	finish.append(a[1]) _NEWLINE  _NEWLINE  _INDENT  _INDENT #print start, finish _NEWLINE  _INDENT  _INDENT sol.append(printMaxActivities(start, finish, b)) _NEWLINE  _NEWLINE for i in xrange(tt): _NEWLINE  _INDENT  _INDENT print sol[i] _NEWLINE 
lis=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'] _NEWLINE a=raw_input().strip() _NEWLINE leng=len(a) _NEWLINE count=0 _NEWLINE if(leng%2==1): _NEWLINE 	count+=1 _NEWLINE flag=1 _NEWLINE for i in lis: _NEWLINE 	k=a.count(i) _NEWLINE 	if(k%2==1): _NEWLINE 		if(count>0): _NEWLINE 			count-=1 _NEWLINE 		else: _NEWLINE 			flag=0 _NEWLINE 			break _NEWLINE if(flag==1): _NEWLINE 	print "YES" _NEWLINE else: _NEWLINE 	print "NO" _NEWLINE 
#include<bits/stdc++.h> _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE using namespace std; _NEWLINE inline int scan(){ _NEWLINE  _INDENT  _INDENT char c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT int x = 0; _NEWLINE  _INDENT  _INDENT while(c<'0'||c>'9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(c>='0'&&c<='9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=(x<<1)+(x<<3)+c-'0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE const int N = 100001; _NEWLINE const int SQN = 350; _NEWLINE int freq[SQN][N]={0}; _NEWLINE long long val[SQN]={0}; _NEWLINE int start[SQN]; _NEWLINE int finish[SQN]; _NEWLINE int n,sqn,m; _NEWLINE int timer=0; _NEWLINE int treestart[N]; _NEWLINE int treeend[N]; _NEWLINE int rev[N]; _NEWLINE list<int> v[N]; _NEWLINE int level[N]={0}; _NEWLINE int lookup[N]; _NEWLINE long long sum[N]={0}; _NEWLINE void dfs(int node,int parent){ _NEWLINE  _INDENT  _INDENT level[node]=level[parent]+1; _NEWLINE  _INDENT  _INDENT treestart[node]=++timer; _NEWLINE  _INDENT  _INDENT rev[timer]=node; _NEWLINE  _INDENT  _INDENT for(list<int>::iterator it = v[node].begin();it!=v[node].end();++it){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(*it!=parent) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dfs(*it,node); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT treeend[node]=timer; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT n=scan(),m=scan(); _NEWLINE  _INDENT  _INDENT for(int i=1;i<n;++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int a=scan(),b=scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v[a].pb(b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v[b].pb(a); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT dfs(1,0); _NEWLINE  _INDENT  _INDENT int sqn = sqrt(n); _NEWLINE  _INDENT  _INDENT int cur=1; _NEWLINE  _INDENT  _INDENT for(int i=1;i<=n;){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int j=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT start[cur]=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(j<i+sqn&&j<=n){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT freq[cur][level[rev[j]]]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lookup[j-1]=cur; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT finish[cur]=j-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ++cur; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(m--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int type=scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(type==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int levl = scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long vall = scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<cur;++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT val[i]+=1LL*freq[i][levl+1]*vall; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum[levl+1]+=vall; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int node = scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int x=lookup[treestart[node]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int y=lookup[treeend[node]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long res=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=x;i<=y;++i){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(start[i]>=treestart[node]&&finish[i]<=treeend[node]){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res+=val[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(start[i]<treestart[node]){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=treestart[node];j<=min(treeend[node],finish[i]);++j){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res+=sum[level[rev[j]]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j= max(start[i],treestart[node]);j<=treeend[node];++j){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res+=sum[level[rev[j]]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",res); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE }
#include<iostream> _NEWLINE #include<string> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT string s; _NEWLINE  _INDENT  _INDENT getline(cin,s); _NEWLINE  _INDENT  _INDENT char r; _NEWLINE  _INDENT  _INDENT cin>>r; _NEWLINE  _INDENT  _INDENT int c=0; _NEWLINE  _INDENT  _INDENT for(int i=0;i<s.size();i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(s[i]==r) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<c<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
import java.io.*; _NEWLINE public class Main _NEWLINE { _NEWLINE  _INDENT public static void main(String args[])throws IOException _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT BufferedReader in=new BufferedReader(new InputStreamReader(System.in)); _NEWLINE  _INDENT  _INDENT  _INDENT int t,n,k,i,j; _NEWLINE  _INDENT  _INDENT  _INDENT //t=Integer.parseInt(in.readLine()); _NEWLINE  _INDENT  _INDENT  _INDENT //while(t>=1) _NEWLINE  _INDENT  _INDENT  _INDENT //{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n=Integer.parseInt(in.readLine()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=n-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=k;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  System.out.print(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=i;j>=1;j--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  System.out.print(j); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=2;j<=i;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  System.out.print(j); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=(n-1);i>=1;i--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=k;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  System.out.print(" "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=i;j>=1;j--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  System.out.print(j); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=2;j<=i;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  System.out.print(j); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT // _INDENT t--; _NEWLINE  _INDENT  _INDENT  _INDENT //} _NEWLINE  _INDENT } _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define LL _INDENT  _INDENT  _INDENT long long _NEWLINE #define LD _INDENT  _INDENT  _INDENT long double _NEWLINE #define PB		push_back _NEWLINE #define LOOP(i,n) _INDENT for(int i=0;i<(n);i++) _NEWLINE #define FOR(i,a,b) for(int i=(a);i<(b);i++) _NEWLINE #define mod		1000000007 _NEWLINE int main() _NEWLINE { _NEWLINE 	int n; _NEWLINE 	cin>>n; _NEWLINE 	printf("%f",cos(n*3.14/180.0)); _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <string.h> _NEWLINE #include <stdlib.h> _NEWLINE #include<math.h> _NEWLINE int cnt=0; _NEWLINE void m(int q,int w,int a,int b){ _NEWLINE  _INDENT  _INDENT if(q<0 || w<0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT if(q==a && w==b){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if(q>a||w>b) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT m(q+1,w,a,b); _NEWLINE  _INDENT  _INDENT m(q,w+1,a,b); _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while (t>0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int a,b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d",&a,&b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m(0,0,a,b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",cnt); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt=0; _NEWLINE  _INDENT  _INDENT } _NEWLINE }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE int t=10,n,m=0,arr[11][21],i,j,a[10]; _NEWLINE for(t=0;t<10;t++) _NEWLINE { _NEWLINE scanf("%d",&a[t]); _NEWLINE if(a[t]>m) _NEWLINE m=a[t]; _NEWLINE } _NEWLINE for(i=0;i<10;i++) _NEWLINE { _NEWLINE for(j=0;j<m-a[i];j++) _NEWLINE arr[j][i]=0; _NEWLINE for(;j<m;j++) _NEWLINE arr[j][i]=1; _NEWLINE } _NEWLINE for(i=0;i<m;i++) _NEWLINE {for(j=0;j<10;j++) _NEWLINE if(arr[i][j]==0) _NEWLINE printf(" "); _NEWLINE else if(arr[i][j]==1) _NEWLINE printf("*"); _NEWLINE printf("\n"); _NEWLINE } _NEWLINE return 0; _NEWLINE }
#include<stdio.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int x,i,j,k,t,n,a[25],b[20],c=0; _NEWLINE 	scanf("%d",&t); _NEWLINE 	for(x=0;x<t;x++) _NEWLINE 	{ _NEWLINE 		scanf("%d",&n); _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 			scanf("%d",&b[i]); _NEWLINE 		for(i=0;i<n-2;i++) _NEWLINE 		 _INDENT  _INDENT  _INDENT for(j=i+1;j<n-1;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  		for(k=j+1;k<n;k++) _NEWLINE 			 _INDENT  _INDENT  _INDENT  _INDENT  if((b[i]+b[j]>b[k])&&(b[i]+b[k]>b[j])&&(b[j]+b[k]>b[i])) _NEWLINE 				 _INDENT  c++;	 _NEWLINE 		a[x]=c; _NEWLINE 		c=0; _NEWLINE 	} _NEWLINE 	for(i=0;i<t;i++) _NEWLINE 		printf("%d\n",a[i]); _NEWLINE }
#include<iostream> _NEWLINE #include<stdio.h> _NEWLINE using namespace std; _NEWLINE  int main() _NEWLINE  { _NEWLINE  _INDENT  _INDENT  int t; _NEWLINE  _INDENT  _INDENT  scanf("%d",&t); _NEWLINE  _INDENT  _INDENT  while(t--) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  int x1,x2,x3,x4,y1,y2,y3,y4; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  scanf("%d %d %d %d",&y1,&y2,&y3,&y4); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  x2=y1+y4-y3; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  x3=y2-y1-y4; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  x4=y1-(x2+x3); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  x1=x4-x2-y3; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  printf("%d %d %d %d\n",x1,x2,x3,x4); _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  return(0); _NEWLINE  } _NEWLINE 
import java.io.OutputStreamWriter; _NEWLINE import java.io.BufferedWriter; _NEWLINE import java.util.Comparator; _NEWLINE import java.io.OutputStream; _NEWLINE import java.io.PrintWriter; _NEWLINE import java.io.Writer; _NEWLINE import java.util.List; _NEWLINE import java.io.IOException; _NEWLINE import java.util.Arrays; _NEWLINE import java.util.InputMismatchException; _NEWLINE import java.util.ArrayList; _NEWLINE import java.util.NoSuchElementException; _NEWLINE import java.math.BigInteger; _NEWLINE import java.io.InputStream; _NEWLINE import java.math.*; _NEWLINE  _INDENT _NEWLINE public class Main { _NEWLINE public static void main(String[] args) { _NEWLINE InputStream inputStream = System.in; _NEWLINE OutputStream outputStream = System.out; _NEWLINE InputReader in = new InputReader(inputStream); _NEWLINE OutputWriter out = new OutputWriter(outputStream); _NEWLINE int testCount = Integer.parseInt(in.next()); _NEWLINE String S; _NEWLINE BigInteger q,high,low,mid,r; _NEWLINE int a,b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 1; i <= testCount; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S=in.next(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q=new BigInteger(S); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT low=new BigInteger("0"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT high=q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=low.compareTo(high); _NEWLINE 				//out.printLine(a); _NEWLINE 				//out.printLine(S.toString()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mid=new BigInteger("0"); _NEWLINE 				while(a==-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mid=low.add(high); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mid=mid.divide(new BigInteger("2")); _NEWLINE 						/* _NEWLINE 						out.printLine("low"+low.toString()); _NEWLINE 						out.printLine("high"+high.toString()); _NEWLINE 						out.printLine("mid"+mid.toString());*/ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=mid.pow(2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b=r.compareTo(q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(b==-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT low=mid;//.add(new BigInteger("1")); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(b==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT high=mid;//.subtract(new BigInteger("1")); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE 						a=low.compareTo(high); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(q.compareTo(low.pow(2))==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S=low.toString(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(q.compareTo(high.pow(2))==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT S=high.toString(); _NEWLINE 				else _NEWLINE 					S=mid.toString(); _NEWLINE 				/* _NEWLINE 				out.printLine("low"+low.toString()); _NEWLINE 				out.printLine("high"+high.toString()); _NEWLINE 				out.printLine("high"+mid.toString()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT */ _NEWLINE 				out.printLine(S); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 				} _NEWLINE 				 _NEWLINE out.close(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE } _NEWLINE class InputReader { _NEWLINE  _INDENT _NEWLINE private InputStream stream; _NEWLINE private byte[] buf = new byte[1024]; _NEWLINE private int curChar; _NEWLINE private int numChars; _NEWLINE private SpaceCharFilter filter; _NEWLINE  _INDENT _NEWLINE public InputReader(InputStream stream) { _NEWLINE this.stream = stream; _NEWLINE } _NEWLINE  _INDENT _NEWLINE public int read() { _NEWLINE if (numChars == -1) _NEWLINE throw new InputMismatchException(); _NEWLINE if (curChar >= numChars) { _NEWLINE curChar = 0; _NEWLINE try { _NEWLINE numChars = stream.read(buf); _NEWLINE } catch (IOException e) { _NEWLINE throw new InputMismatchException(); _NEWLINE } _NEWLINE if (numChars <= 0) _NEWLINE return -1; _NEWLINE } _NEWLINE return buf[curChar++]; _NEWLINE } _NEWLINE  _INDENT _NEWLINE public int readInt() { _NEWLINE int c = read(); _NEWLINE while (isSpaceChar(c)) _NEWLINE c = read(); _NEWLINE int sgn = 1; _NEWLINE if (c == '-') { _NEWLINE sgn = -1; _NEWLINE c = read(); _NEWLINE } _NEWLINE int res = 0; _NEWLINE do { _NEWLINE if (c < '0' || c > '9') _NEWLINE throw new InputMismatchException(); _NEWLINE res *= 10; _NEWLINE res += c - '0'; _NEWLINE c = read(); _NEWLINE } while (!isSpaceChar(c)); _NEWLINE return res * sgn; _NEWLINE } _NEWLINE  _INDENT _NEWLINE public String readString() { _NEWLINE int c = read(); _NEWLINE while (isSpaceChar(c)) _NEWLINE c = read(); _NEWLINE StringBuilder res = new StringBuilder(); _NEWLINE do { _NEWLINE res.appendCodePoint(c); _NEWLINE c = read(); _NEWLINE } while (!isSpaceChar(c)); _NEWLINE return res.toString(); _NEWLINE } _NEWLINE  _INDENT _NEWLINE public boolean isSpaceChar(int c) { _NEWLINE if (filter != null) _NEWLINE return filter.isSpaceChar(c); _NEWLINE return isWhitespace(c); _NEWLINE } _NEWLINE  _INDENT _NEWLINE public static boolean isWhitespace(int c) { _NEWLINE return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; _NEWLINE } _NEWLINE  _INDENT _NEWLINE public String next() { _NEWLINE return readString(); _NEWLINE } _NEWLINE  _INDENT _NEWLINE public interface SpaceCharFilter { _NEWLINE public boolean isSpaceChar(int ch); _NEWLINE } _NEWLINE } _NEWLINE  _INDENT _NEWLINE class OutputWriter { _NEWLINE private final PrintWriter writer; _NEWLINE  _INDENT _NEWLINE public OutputWriter(OutputStream outputStream) { _NEWLINE writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream))); _NEWLINE } _NEWLINE  _INDENT _NEWLINE public OutputWriter(Writer writer) { _NEWLINE this.writer = new PrintWriter(writer); _NEWLINE } _NEWLINE  _INDENT _NEWLINE public void print(Object...objects) { _NEWLINE for (int i = 0; i < objects.length; i++) { _NEWLINE if (i != 0) _NEWLINE writer.print(' '); _NEWLINE writer.print(objects[i]); _NEWLINE } _NEWLINE } _NEWLINE  _INDENT _NEWLINE public void printLine(Object...objects) { _NEWLINE print(objects); _NEWLINE writer.println(); _NEWLINE } _NEWLINE  _INDENT _NEWLINE public void close() { _NEWLINE writer.close(); _NEWLINE } _NEWLINE  _INDENT _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE double polygonArea(long int X[], long int Y[], long int numPoints) _INDENT _NEWLINE { _INDENT _NEWLINE  _INDENT long int i; _INDENT  _INDENT  _INDENT  _INDENT  // Accumulates area in the loop _NEWLINE  _INDENT double area=0; _NEWLINE 	for(i=0;i<numPoints;i++) _NEWLINE 	{ _NEWLINE 		if(i==numPoints-1) _NEWLINE 		area+=(X[i]*Y[0]-X[0]*Y[i]); _NEWLINE 		else _NEWLINE 		area+=(X[i]*Y[i+1]-X[i+1]*Y[i]); _NEWLINE 		 _NEWLINE 	} _NEWLINE 	 _NEWLINE  _INDENT return abs(area/2); _NEWLINE } _INDENT _NEWLINE int main(){ _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT long int t; _NEWLINE  _INDENT  cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE 	{ _NEWLINE  	 _INDENT  long _INDENT int n,i,j; //n for no. of polygon _NEWLINE  	 _INDENT  double area=0; _NEWLINE  _INDENT  _INDENT  _INDENT  cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  long int X[n]; _NEWLINE  	 _INDENT  long int Y[n]; _NEWLINE 	 _INDENT  long int val; _NEWLINE  	 _INDENT  for(i=0;i<n;i++) _NEWLINE 	 _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>X[i]; _NEWLINE  					 _NEWLINE  _INDENT  	 _INDENT  } _NEWLINE  _INDENT  	 _INDENT  for(i=0;i<n;i++) _NEWLINE 	 _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>Y[i]; _NEWLINE  					 _NEWLINE  _INDENT  	 _INDENT  } _NEWLINE  _INDENT  	 _INDENT  _INDENT _NEWLINE  _INDENT  	 _INDENT  area=polygonArea(X, Y, n); _NEWLINE  _INDENT  	 _INDENT  printf("%.1f",area); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  
#include <iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int n; _NEWLINE  _NEWLINE int main() { _NEWLINE 	// your code goes here _NEWLINE 	 _NEWLINE 	cin >> n; _NEWLINE 	 _NEWLINE 	int p = n; _NEWLINE 	int count = 0; _NEWLINE 	while(p>0){ _NEWLINE 		int q = p%2; _NEWLINE 		p /= 2; _NEWLINE 		if(q==1) _NEWLINE 			count++; _NEWLINE 	} _NEWLINE 	 _NEWLINE 	int r = 1<<count; _NEWLINE  _NEWLINE 	r = n+1-r; _NEWLINE 	cout << r << endl; _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE }
from re import findall _NEWLINE count = int(raw_input()) _NEWLINE def test(p): _NEWLINE  _INDENT  _INDENT x,y = p _NEWLINE  _INDENT  _INDENT global m _NEWLINE  _INDENT  _INDENT if eval(str(y)+".0")/x <= m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT return False _NEWLINE for i in range(count): _NEWLINE  _INDENT  _INDENT n,a,b = [int(x) for x in findall("\d+",raw_input())] _NEWLINE  _INDENT  _INDENT m,net = eval(str(a) + ".0")/b,0 _NEWLINE  _INDENT  _INDENT xx,yr = xrange(1,n+1),int(eval(str(n)+"*"+str(a)+".0")/b) _NEWLINE  _INDENT  _INDENT if a%b != 0 and n%b != 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT yr += 1 _NEWLINE  _INDENT  _INDENT for y in range(1,yr): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT total = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for x in xx: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if test((x,y)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT total += n+1-x _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if total != 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if y == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  net += total * (total-1)/2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT net += total * (total-1)/2 * y _NEWLINE  _INDENT  _INDENT print net
import java.io.*; _NEWLINE public class Main { _NEWLINE 	public static void main(String args[]) throws IOException{ _NEWLINE try{ _NEWLINE 		BufferedReader obj = new BufferedReader(new InputStreamReader(System.in)); _NEWLINE 		String str = obj.readLine(); _NEWLINE 		int len = str.length(); _NEWLINE 		//System.out.println(len); _NEWLINE 		int n = Integer.parseInt(str); _NEWLINE 		//System.out.println(n); _NEWLINE 		/*double pow = Math.pow(10,len-1); _NEWLINE 		int intpow = (int)pow;*/ _NEWLINE 		boolean valid = true; _NEWLINE 		int digits[] = new int[len]; _NEWLINE 		int temp = n; _NEWLINE 		for(int i=len-1;i>=0;i--){ _NEWLINE 			digits[i] = temp%10; _NEWLINE 			temp /= 10; _NEWLINE 		} _NEWLINE 		for(int i=0;i<len;i++){ _NEWLINE 			if(digits[i]!=0){ _NEWLINE 				if(n%digits[i]!=0){ _NEWLINE 					valid = false; _NEWLINE 					break; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(valid==true) _NEWLINE 			System.out.println("Valid"); _NEWLINE 		else _NEWLINE 			System.out.println("Invalid"); _NEWLINE }catch(Exception e){} _NEWLINE 	} _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #define MOD 1000000007 _NEWLINE #define LL long long _NEWLINE  _NEWLINE LL Pow(int n) { _NEWLINE 	if(n <= 0) return 1; _NEWLINE 	LL x = Pow(n/2) % MOD; _NEWLINE 	LL k = (long long) (x*x)%MOD; _NEWLINE 	if(n%2) k = (2*k)%MOD; _NEWLINE 	return k%MOD; _NEWLINE } _NEWLINE int main() { _NEWLINE 	int t,n; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) { _NEWLINE 		scanf("%d",&n); _NEWLINE 		printf("%lld\n",Pow(n)); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
//Author : pakhandi _NEWLINE // _NEWLINE using namespace std; _NEWLINE  _NEWLINE #include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<cstdlib> _NEWLINE #include<algorithm> _NEWLINE #include<cmath> _NEWLINE #include<cstring> _NEWLINE  _NEWLINE #define wl(n) while(n--) _NEWLINE #define fl(i,a,b) for(i=a; i<b; i++) _NEWLINE #define rev(i,a,b) for(i=a; i>=b; i--) _NEWLINE #define print(n) printf("%d\n", n) _NEWLINE #define scan(n) scanf("%d", &n) _NEWLINE #define MOD 1000000007 _NEWLINE #define ll long long int _NEWLINE  _NEWLINE char str1[505], operations[505]; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int i, j, cases; _NEWLINE 	int a, b, len1, count; _NEWLINE 	long long int ans; _NEWLINE 	while(1) _NEWLINE 	{ _NEWLINE 		scanf("%s", str1); _NEWLINE 		if(str1[0]=='0' && str1[1]=='\0') _NEWLINE 			break; _NEWLINE 		len1=strlen(str1); _NEWLINE 		count=0; _NEWLINE 		fl(i,0,len1) _NEWLINE 		{ _NEWLINE 			if(str1[i]=='+' || str1[i]=='-' || str1[i]=='*' || str1[i]=='/') _NEWLINE 			{ _NEWLINE 				operations[count++]=str1[i]; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		//count++; _NEWLINE 		scanf("%lld", &ans); _NEWLINE 		ans=ans*1LL; _NEWLINE 		fl(i,0,count) _NEWLINE 		{ _NEWLINE 			scan(a); _NEWLINE 			if(operations[i]=='+') _NEWLINE 				ans=(ans+a)*1LL; _NEWLINE 			else if(operations[i]=='-') _NEWLINE 				ans=(ans-a)*1LL; _NEWLINE 			else if(operations[i]=='*') _NEWLINE 				ans=(ans*a)*1LL; _NEWLINE 			else _NEWLINE 				ans=(ans/a)*1LL; _NEWLINE 			 _NEWLINE 			ans=(ans%MOD)*1LL; _NEWLINE 		} _NEWLINE 		print(ans); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import java.io.*; _NEWLINE  _NEWLINE class Main _NEWLINE { _NEWLINE 	public static void main(String args[]) _NEWLINE 	{ _NEWLINE 		String s; _NEWLINE 		long N; _NEWLINE 		BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); _NEWLINE 		for(;;) _NEWLINE 		{ _NEWLINE 			try _NEWLINE 			{ _NEWLINE 				s=br.readLine(); _NEWLINE 				N=Long.parseLong(s); _NEWLINE 				System.out.println(N-1); _NEWLINE 			} _NEWLINE 			catch(Exception e) _NEWLINE 			{ _NEWLINE 				System.exit(0); _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE }
#include<stdio.h> _NEWLINE //#include<conio.h> _NEWLINE #include<math.h> _NEWLINE int bsearchsmallerside(int *a,int low ,int high,int item) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(high==low) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return low; _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int _INDENT  mid=(low+high)/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(item==a[mid]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return mid; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else if(item>a[mid]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT low=mid+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return(bsearchsmallerside(a,low,high,item)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT high=mid; _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return(bsearchsmallerside(a,low,high,item)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE int N,p,q,count,T,reverse,a[100000],i,j,i1,count1,loop,x,y,c; _NEWLINE a[0]=2; _NEWLINE a[1]=3; _NEWLINE count=2; _NEWLINE for(i=5,j,loop=1;i<=100001;loop++) _NEWLINE 		{ _NEWLINE 			 i1=sqrt(i); _NEWLINE 			for(j=0;(j<count)&&(a[j]<=i1);j++) _NEWLINE 			{ _NEWLINE 				if(i%a[j]==0) _NEWLINE 				break; _NEWLINE 			} _NEWLINE 			if(a[j]>i1) _NEWLINE 			{ _NEWLINE 			a[count]=i; _NEWLINE 			count++; _NEWLINE 			} _NEWLINE 			if(loop%2!=0) _NEWLINE 			i+=2; _NEWLINE 			else _NEWLINE 			i+=4;			 _NEWLINE 		} _INDENT  _NEWLINE 		 _NEWLINE 		//printf("%d %d %d",count,a[count],a[count-1]); _NEWLINE 		scanf("%d",&T); _NEWLINE 		while(T--) _NEWLINE 		{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT reverse=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d",&p,&q); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(p>q) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=q; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q=p; _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT reverse=1; _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //printf("enter N"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&N); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=bsearchsmallerside(a,0,9591,p+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y=bsearchsmallerside(a,0,9591,q-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[y]>=q) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y=y-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[x]<=p) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=x+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //printf("\n%d %d\n",a[x],a[y]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[x]>a[y] || a[x]>=q || a[y]<=p) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("-1\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count1=(y-x)+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N=N%count1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(N==0) _INDENT N=count1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //if(reverse==1) N=count1-N+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",a[x+(N-1)]); _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //getch(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
for u in range(input()): _NEWLINE  _INDENT  _INDENT string = raw_input().split() _NEWLINE  _INDENT  _INDENT if int(string[-1]) > 200: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print u + 1
#include<iostream> _NEWLINE #include<math.h> _NEWLINE #include<vector> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int * sort(int * A,int size,int level) _NEWLINE { _NEWLINE 	int i,j,temp,indices[10],count[10],div=pow(10,level); _NEWLINE 	for(i=0;i<10;i++) _NEWLINE 	{ _NEWLINE 		count[i]=0; _NEWLINE 		indices[i]=0; _NEWLINE 	} _NEWLINE 	for(i=0;i<size;i++) _NEWLINE 	{ _NEWLINE 		count[(A[i]/div)%10]++; _NEWLINE 	} _NEWLINE 	int **Ax=new int *[10]; _NEWLINE 	for(i=0;i<10;i++) _NEWLINE 	{ _NEWLINE 		Ax[i]=new int[count[i]]; _NEWLINE 	} _NEWLINE 	for(i=0;i<size;i++) _NEWLINE 	{ _NEWLINE 		temp=(A[i]/div)%10; _NEWLINE 		Ax[temp][indices[temp]]=A[i]; _NEWLINE 		indices[temp]++; _NEWLINE 	} _NEWLINE 	if(level!=0) _NEWLINE 	for(i=0;i<10;i++) _NEWLINE 	{ _NEWLINE 		if(count[i]>1) _NEWLINE 		Ax[i]=sort(Ax[i],count[i],level-1); _NEWLINE 	} _NEWLINE 	temp=0; _NEWLINE 	for(i=0;i<10;i++)//ascending _NEWLINE 	{ _NEWLINE 		for(j=0;j<count[i];j++) _NEWLINE 		{ _NEWLINE 			A[temp+j]=Ax[i][j]; _NEWLINE 		} _NEWLINE 		temp+=count[i]; _NEWLINE 		delete Ax[i]; _NEWLINE 	} _NEWLINE 	delete Ax; _NEWLINE 	return A;	 _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int i,n,*A; _NEWLINE 	cin>>n; _NEWLINE 	A=new int[n]; _NEWLINE 	for(i=0;i<n;i++)cin>>A[i]; _NEWLINE 	A= sort(A,n,9); _NEWLINE 	 _NEWLINE 	for(i=0;i<n;i++)cout<<A[i]<<" "; _NEWLINE 	return 0; _NEWLINE 	 _NEWLINE } _NEWLINE 
n,m=map(int,raw_input().split()) _NEWLINE a=[0]*(n+2) _NEWLINE #print a _NEWLINE for i in range(m): _NEWLINE 	left,right=map(int,raw_input().split()) _NEWLINE 	a[left]+=1 _NEWLINE 	a[right+1]-=1 _NEWLINE for j in range(1,n+1): _NEWLINE 	a[j]+=a[j-1] _NEWLINE a=a[:n+1] _NEWLINE a.sort() _NEWLINE #print a _NEWLINE print a[(n/2)+1] _NEWLINE 
l=[0]*1000003 _NEWLINE l[0]=1 _NEWLINE for i in range(1,len(l)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT l[i]=i*l[i-1]%1000003 _NEWLINE for i in range(input()): _NEWLINE 	n,x=map(int,raw_input().split()) _NEWLINE 	if n>=1000003: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "0" _NEWLINE 	else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print ((l[n])*x)%1000003 _NEWLINE 
# your code goes here _NEWLINE t = input() _NEWLINE for i in xrange(t): _NEWLINE 	s = raw_input() _NEWLINE 	count = 0 _NEWLINE 	for j in s: _NEWLINE 		count+=(ord(j)-96) _NEWLINE 	print count
t=input() _NEWLINE while(t>0): _NEWLINE 	n=input() _NEWLINE 	A=[] _NEWLINE 	for i in range(n): _NEWLINE 		A.append(raw_input()) _NEWLINE 	s=raw_input() _NEWLINE 	for i in range(len(A)): _NEWLINE 		if(s==A[i]): _NEWLINE 			print "yes" _NEWLINE 			break _NEWLINE 	else: _NEWLINE 		print "no" _NEWLINE 	t=t-1 _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int deepayan(int n,int k,int m) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(n==1) return 0; _NEWLINE  _INDENT  _INDENT return ((deepayan(n-1,k,m+1)+m*k)%n); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n,t,k; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT scanf("%d",&k); _NEWLINE  _INDENT  _INDENT printf("%d\n",(deepayan(n,k,1)+1));} _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
import sys _NEWLINE  _NEWLINE def base(n): _NEWLINE 	max=0 _NEWLINE 	while(n!=0): _NEWLINE 		if(n%10 > max): _NEWLINE 			max=n%10 _NEWLINE 			 _NEWLINE 		n=n/10 _NEWLINE 	return max+1 _NEWLINE  _NEWLINE def convert(n,b): _NEWLINE 	i=0 _NEWLINE 	sum=0 _NEWLINE 	while(n!=0): _NEWLINE 		sum+=(n%10)*pow(b,i) _NEWLINE 		i=i+1 _NEWLINE 		n=n/10 _NEWLINE 	 _NEWLINE 	return sum _NEWLINE  _NEWLINE def main(): _NEWLINE 	t=int(raw_input()) _NEWLINE 	 _NEWLINE 	while(t!=0): _NEWLINE 		a,b=map(int,raw_input().split()) _NEWLINE 		a=convert(a,base(a)) _NEWLINE 		b=convert(b,base(b)) _NEWLINE 		print a+b _NEWLINE 		t=t-1 _NEWLINE if __name__ == '__main__': _NEWLINE 	main()
t = input() _NEWLINE while t: _NEWLINE 		t-=1 _NEWLINE 		x,y = [int(x) for x in raw_input().split()] _NEWLINE 		print( ( (y - x + 1) * (y - x) ) / 2 )
import string _NEWLINE for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT string=str(raw_input()).lower() _NEWLINE  _INDENT  _INDENT punctuation=['!','@','#',' ','$','%','^','&','*','(',')','-','=','+','[',']',"'",';','/''1','2','3','4','5','6','','7','8','9','0'] _NEWLINE  _INDENT  _INDENT string1=[f for f in string if f not in punctuation] _NEWLINE  _INDENT  _INDENT string=''.join(string1) _NEWLINE  _INDENT  _INDENT dictionary={} _NEWLINE  _INDENT  _INDENT for i in string: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dictionary[i]=dictionary.get(i,0)+1 _NEWLINE  _INDENT  _INDENT maxvals=max(dictionary.values()) _NEWLINE  _INDENT  _INDENT new=[] _NEWLINE  _INDENT  _INDENT for a,b in dictionary.items(): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b==maxvals): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT new.append(ord(a)) _NEWLINE  _INDENT  _INDENT print str(unichr(max(new))) _NEWLINE 
def multiply(m1, m2, mod): _NEWLINE  _INDENT  _INDENT return [ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT [(m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]) % mod, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  (m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]) % mod], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT [(m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]) % mod, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  (m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]) % mod] _NEWLINE  _INDENT  _INDENT ] _NEWLINE  _NEWLINE def findNthPower(n, mod): _NEWLINE  _INDENT  _INDENT A = [[1, 1], [1, 0]] _NEWLINE  _INDENT  _INDENT if n == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return A _NEWLINE  _INDENT  _INDENT r = findNthPower(n / 2, mod) _NEWLINE  _INDENT  _INDENT r = multiply(r, r, mod) _NEWLINE  _INDENT  _INDENT if n % 2 == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r = multiply(r, A, mod) _NEWLINE  _INDENT  _INDENT return r _NEWLINE  _NEWLINE  _NEWLINE def solve(n, m): _NEWLINE  _INDENT  _INDENT r = findNthPower(2*n-1, m) _NEWLINE  _INDENT  _INDENT return "%s/%s" % (r[0][1], r[0][0]) _NEWLINE  _NEWLINE  _NEWLINE def main(): _NEWLINE  _INDENT  _INDENT for _ in range(int(raw_input())): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n, m = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print("%s" % solve(n, m)) _NEWLINE  _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT main()
def solve(N, stones): _NEWLINE  _INDENT  _INDENT tmp = 0 _NEWLINE  _INDENT  _INDENT for n in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp += stones[n] / (n+1) _NEWLINE  _INDENT  _INDENT if tmp % 2 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 'BOB' _NEWLINE  _INDENT  _INDENT return 'ALICE' _NEWLINE  _NEWLINE def resn04(): _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for t in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stones = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print solve(N, stones) _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT resn04()
q=int(raw_input()) _NEWLINE for i in range(q): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT n-=1 _NEWLINE  _INDENT  _INDENT print (((pow(2,n,8388608)*( ( (pow(n,2,8388608)+(n%8388608))%8388608 + (2%8388608) )%8388608)%8388608)%8388608)-(1%8388608))%8388608
__author__ = 'Rajan' _NEWLINE  _NEWLINE l=int(raw_input()) _NEWLINE x=0 _NEWLINE A=['0','2','4','6','8'] _NEWLINE  _NEWLINE while(x<l): _NEWLINE  _INDENT  _INDENT for i in range(0,l): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=raw_input() _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n[0] in A): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "EVEN" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=x+1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "ODD" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=x+1
def OptimizedDivideAndConquerSingleSellProfit(arr): _NEWLINE  _INDENT  _INDENT # If the array is empty, the maximum profit is zero. _NEWLINE  _INDENT  _INDENT if len(arr) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT # This recursive helper function implements the above recurrence. _INDENT It _NEWLINE  _INDENT  _INDENT # returns a triple of (max profit, min array value, max array value). _INDENT For _NEWLINE  _INDENT  _INDENT # efficiency reasons, we always reuse the array and specify the bounds as _NEWLINE  _INDENT  _INDENT # [lhs, rhs] _NEWLINE  _INDENT  _INDENT def Recursion(arr, lhs, rhs): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # If the array has just one element, we return that the profit is zero _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # but the minimum and maximum values are just that array value. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if lhs == rhs: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return (0, arr[lhs], arr[rhs]) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # Recursively compute the values for the first and latter half of the _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # array. _INDENT To do this, we need to split the array in half. _INDENT The line _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # below accomplishes this in a way that, if ported to other languages, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # cannot result in an integer overflow. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mid = lhs + (rhs - lhs) / 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # Perform the recursion. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ( leftProfit, _INDENT leftMin, _INDENT leftMax) = Recursion(arr, lhs, mid) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT (rightProfit, rightMin, rightMax) = Recursion(arr, mid + 1, rhs) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # Our result is the maximum possible profit, the minimum of the two _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # minima we've found (since the minimum of these two values gives the _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # minimum of the overall array), and the maximum of the two maxima. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT maxProfit = max(leftProfit, rightProfit, rightMax - leftMin) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (maxProfit, min(leftMin, rightMin), max(leftMax, rightMax)) _NEWLINE  _NEWLINE  _INDENT  _INDENT # Using our recursive helper function, compute the resulting value. _NEWLINE  _INDENT  _INDENT profit, _, _ = Recursion(arr, 0, len(arr) - 1) _NEWLINE  _INDENT  _INDENT return profit _NEWLINE  _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE while(t): _NEWLINE 	t -= 1 _NEWLINE 	n = int(raw_input()) _NEWLINE 	x = raw_input() _NEWLINE 	x = map(int, x.split()) _NEWLINE 	ans = OptimizedDivideAndConquerSingleSellProfit(x) _NEWLINE 	print ans
#include<stdio.h> _NEWLINE #include<string.h> _NEWLINE //#include<iostream> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT char a[22],r; _NEWLINE  _INDENT  _INDENT int t,i; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s",a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r='1'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=strlen(a)-1;i>=0;i--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(a[i]=='1'&&r=='1') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i]='0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r='1'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else if(r=='1'&&a[i]=='0') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i]='1'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r='0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else if(r=='0') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(r=='1') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("1"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%s\n",a); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  // system("pause"); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
#include<iostream> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE int t; cin>>t; _NEWLINE while(t--) _NEWLINE { _NEWLINE long long int dashes=0; _NEWLINE long long int x; cin>>x; _NEWLINE while(x) _NEWLINE { _NEWLINE int r=x%10; _NEWLINE switch(r) _NEWLINE { _NEWLINE case 1:dashes+=4;break; _NEWLINE case 2:;case 3:;case 5:dashes+=10;break; _NEWLINE case 4:dashes+=8;break; _NEWLINE case 6:;case 0:; case 9:dashes+=18;break; _NEWLINE case 7:dashes+=9;break; _NEWLINE case 8:dashes+=21;break; _NEWLINE } _NEWLINE x=x/10; _NEWLINE } _NEWLINE cout<<dashes<<endl; _NEWLINE } _NEWLINE return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE using namespace std; _NEWLINE void quickSort(int[],int,int); _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,m,c,j,a[1000000]; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(j<m) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d",&a[j++]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(m%2==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  c = -1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT quickSort(a,0,m-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = a[m/2]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",c); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE void quickSort(int arr[], int left, int right) { _NEWLINE  _INDENT  _INDENT  _INDENT int i = left, j = right; _NEWLINE  _INDENT  _INDENT  _INDENT bool end = false; _NEWLINE  _INDENT  _INDENT  _INDENT int tmp; _NEWLINE  _INDENT  _INDENT  _INDENT int pivot = arr[(left + right) / 2]; _NEWLINE  _INDENT  _INDENT  _INDENT /* partition */ _NEWLINE  _INDENT  _INDENT  _INDENT while (i <= j) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (arr[i] < pivot) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (arr[j] > pivot) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (i <= j) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp = arr[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i] = arr[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[j] = tmp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j--; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT /* recursion */ _NEWLINE  _INDENT  _INDENT  _INDENT if (left < j){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT quickSort(arr, left, j); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT if (i < right){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT quickSort(arr, i, right); _NEWLINE } _NEWLINE  _INDENT  _INDENT  _INDENT if (i >= right && left >= j){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE }} 
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stack> _NEWLINE #include<string> _NEWLINE #include<queue> _NEWLINE #include<stdlib.h> _NEWLINE #include<vector> _NEWLINE #include<cmath> _NEWLINE #define pb push_back _NEWLINE #define big long long _NEWLINE #define FOR(i,a,b) for(i=a;i<=b;i++) _NEWLINE #define RFOR(i,a,b) for(i=a;i>=b;i--) _NEWLINE #define vi vector<int> _NEWLINE #define vb vector<big> _NEWLINE using namespace std; _NEWLINE big fact(big n) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(n==0 || n==1) return 1; _NEWLINE  _INDENT  _INDENT return n*fact(n-1); _NEWLINE } _NEWLINE big gcd(big a, big b) _NEWLINE { _NEWLINE  _INDENT  _INDENT if (a == 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return b; _NEWLINE  _INDENT  _INDENT return gcd(b%a, a); _NEWLINE } _NEWLINE int main() { _NEWLINE 	big l,t,n,m,i,j,k,temp,*arr,f,a,b,a1,b1,cr,count; _NEWLINE 	double x1=0,x2,y1,y2,x3,y3,m1,m2,m3; _NEWLINE 	int h,num=0,prev,sum; _NEWLINE 	vb v,line; _NEWLINE 	char c; _NEWLINE 	string s,final; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t-->0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  cin>>s; _NEWLINE  _INDENT  _INDENT  _INDENT  l=s.length(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  RFOR(i,s.length()/2-1,0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout<<s[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  RFOR(i,s.length()-1,s.length()/2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout<<s[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  cout<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stack> _NEWLINE #include<string> _NEWLINE #include<queue> _NEWLINE #include<stdlib.h> _NEWLINE #include<vector> _NEWLINE #include<cmath> _NEWLINE #define pb push_back _NEWLINE #define big long long _NEWLINE #define FOR(i,a,b) for(i=a;i<=b;i++) _NEWLINE #define RFOR(i,a,b) for(i=a;i>=b;i--) _NEWLINE #define vi vector<int> _NEWLINE #define vb vector<big> _NEWLINE using namespace std; _NEWLINE int main() { _NEWLINE 	big l,t,n,i,j,k,temp,c,count; _NEWLINE 	vb v; _NEWLINE 	cin>>t; _NEWLINE 	while(t-->0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v.clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT FOR(i,0,n-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v.pb(temp*3); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT FOR(i,0,n-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v[i]+=temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(v.begin(),v.end()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<v[n-1]<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stack> _NEWLINE #include<string> _NEWLINE #include<queue> _NEWLINE #include<stdlib.h> _NEWLINE #include<vector> _NEWLINE #include<cmath> _NEWLINE #define pb push_back _NEWLINE #define big long long _NEWLINE #define FOR(i,a,b) for(i=a;i<=b;i++) _NEWLINE #define RFOR(i,a,b) for(i=a;i>=b;i--) _NEWLINE #define vi vector<int> _NEWLINE #define vb vector<big> _NEWLINE using namespace std; _NEWLINE int main() { _NEWLINE 	big l,t,n,i,j,k,temp,c,*arr,inv=0,linv=0,mi=0,ni=0,m,mt,lv; _NEWLINE 	double x1=0,x2,y1,y2,x3,y3,m1,m2,m3; _NEWLINE 	int h,num=0,prev; _NEWLINE 	vb v,line; _NEWLINE 	string s; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t-->0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=n-n%2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<(n/4)*(n/4+(n/2)%2)<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT int n,T; _NEWLINE  _INDENT int l,r,b,t,a3; _NEWLINE  _INDENT int v1,v2,v3,v4; _NEWLINE  _INDENT int x1[22],x2[22],y1[22],y2[22]; _NEWLINE  _INDENT cin>>T; _NEWLINE  _INDENT while(T--) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT cin>>v1>>v2>>v3>>v4; _NEWLINE  _INDENT  _INDENT  _INDENT x1[i]=v1<v3?v1:v3; _NEWLINE  _INDENT  _INDENT  _INDENT y1[i]=v2<v4?v2:v4; _NEWLINE  _INDENT  _INDENT  _INDENT x2[i]=v1>v3?v1:v3; _NEWLINE  _INDENT  _INDENT  _INDENT y2[i]=v2>v4?v2:v4; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT l=x1[0]; _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT if(x1[i]>l) _NEWLINE 	l=x1[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT r=x2[0]; _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT if(x2[i]<r) _NEWLINE 	r=x2[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT b=y1[0]; _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT if(y1[i]>b) _NEWLINE 	b=y1[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT t=y2[0]; _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT if(y2[i]<t) _NEWLINE 	t=y2[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT a3=(l-r)*(b-t); _NEWLINE  _INDENT  _INDENT  _INDENT if(a3<0) _NEWLINE 	a3=-a3; _NEWLINE  _INDENT  _INDENT  // cout<<"l,r,b,t="<<l<<" "<<r<<" "<<b<<" "<<t<<endl; _NEWLINE  _INDENT  _INDENT if(l<r&&b<t) _NEWLINE  _INDENT  _INDENT  _INDENT cout<<a3<<endl; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  cout<<0<<endl; _NEWLINE  _INDENT } _NEWLINE  _INDENT return 0; _NEWLINE }
#include <iostream> _NEWLINE #include <algorithm> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n; cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int group[n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>group[i]; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int c=group[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bool print=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=i+1;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(group[j]==c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT {print=false;break;} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(print==true) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<c<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<iostream> _NEWLINE #include<cstring> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,total,a[4],sol[40005],j,i; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(a,0,sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(sol,0,sizeof(sol)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>total>>a[0]>>a[1]>>a[2]>>a[3]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sol[0]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<4;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=total;j>=0;j--) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(sol[j]==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol[j+a[i]]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(sol[total]==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"YES"<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<"NO"<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE #define LL long long int _NEWLINE #define REP(i,n) for(int i=0;i<n;++i) _NEWLINE #define REPP(i,a,b) for(int i=a;i<b;++i) _NEWLINE #define TC int t;scanf("%d",&t);while (t-->0) _NEWLINE #define INP(x) scanf("%d",&x) _NEWLINE #define OUT(x) printf("%d\n",x) _NEWLINE #define INPLL(x) scanf("%lld",&x) _NEWLINE #define OUTLL(x) printf("%lld\n",x) _NEWLINE #define INPS(x) scanf("%s",x) _NEWLINE #define OUTS(x) printf("%s\n",x) _NEWLINE #define INPD(x) scanf("%lf",&x) _NEWLINE #define OUTD(x) printf("%.6lf\n",x) _NEWLINE #define MEM(a,b) memset(a,b,sizeof(a)) _NEWLINE #define MP make_pair _NEWLINE #define PB push_back _NEWLINE #define PII pair<int,int> _NEWLINE #define PLL pair<long long,long long> _NEWLINE #define VPII vector<pair<int,int > _NEWLINE #define debug(x) cout<<"### x is: "<<x<<"###"<<endl _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define MOD 1000000007 _NEWLINE #define mod 10000007 _NEWLINE #define PI 3.14159265359 _NEWLINE using namespace std; _NEWLINE bool a[1000000]; _NEWLINE LL primes[1000000],in=0; _NEWLINE void Sieve(int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT memset(a,true,sizeof(a)); _NEWLINE  _INDENT  _INDENT a[1]=false; _NEWLINE  _INDENT  _INDENT for(int i=2;i*i<=n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=2*i;j<n;j+=i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[j]=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=2;i<=n;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT primes[in++]=i; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE LL calc(LL idx,LL cur,LL k) _NEWLINE { _NEWLINE 		LL square=primes[idx]*primes[idx]; _NEWLINE 		LL newCur=square*cur; _NEWLINE 		LL res=0; _NEWLINE  _NEWLINE 		if(newCur<0||newCur>k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE 		res+=k/(newCur); _NEWLINE 		res+=calc(idx+1,cur,k); _NEWLINE 		if(newCur>0&&newCur<k) _NEWLINE 			res-=calc(idx+1,newCur,k); _NEWLINE 		return res; _NEWLINE } _NEWLINE LL getNumber(LL n) _NEWLINE { _NEWLINE 		LL lo=1; LL hi=2000000000l; _NEWLINE 		while(lo<hi) _NEWLINE 		{ _NEWLINE 			LL mid=lo+(hi-lo)/2; _NEWLINE 			LL cnt=mid-calc(0,1,mid); _NEWLINE 			if(cnt<n) _NEWLINE 			{ _NEWLINE 				lo=mid+1; _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				hi=mid; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return lo; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT Sieve(1000000); _NEWLINE  _INDENT  _INDENT LL n; _NEWLINE  _INDENT  _INDENT TC _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT INPLL(n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT OUTLL(getNumber(n)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE #include <stdlib.h> _NEWLINE  #include<iostream> _NEWLINE  using namespace std; _NEWLINE /* Following function is needed for library function qsort(). Refer _NEWLINE  _INDENT  http://www.cplusplus.com/reference/clibrary/cstdlib/qsort/ */ _NEWLINE int comp(const void* a, const void* b) _NEWLINE { _INDENT return *(int*)a > *(int*)b ; } _NEWLINE  _INDENT _NEWLINE // Function to count all possible triangles with arr[] elements _NEWLINE int findNumberOfTriangles(int arr[], int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT // Sort the array elements in non-decreasing order _NEWLINE  _INDENT  _INDENT qsort(arr, n, sizeof( arr[0] ), comp); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Initialize count of triangles _NEWLINE  _INDENT  _INDENT int count = 0; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT // Fix the first element. _INDENT We need to run till n-3 as the other two elements are _NEWLINE  _INDENT  _INDENT // selected from arr[i+1...n-1] _NEWLINE  _INDENT  _INDENT for (int i = 0; i < n-2; ++i) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT // Initialize index of the rightmost third element _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int k = i+2; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT // Fix the second element _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j = i+1; j < n; ++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Find the rightmost element which is smaller than the sum _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // of two fixed elements _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // The important thing to note here is, we use the previous _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // value of k. If value of arr[i] + arr[j-1] was greater than arr[k], _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // then arr[i] + arr[j] must be greater than k, because the _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // array is sorted. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (k < n && arr[i] + arr[j] > arr[k]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  ++k; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // Total number of possible triangles that can be formed _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // with the two fixed elements is k - j - 1. _INDENT The two fixed _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // elements are arr[i] and arr[j]. _INDENT All elements between arr[j+1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // to arr[k-1] can form a triangle with arr[i] and arr[j]. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // One is subtracted from k because k is incremented one extra _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // in above while loop. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // k will always be greater than j. If j becomes equal to k, then _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // above loop will increment k, because arr[k] + arr[i] is always _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT // greater than arr[k] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += k - j - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT return count; _NEWLINE } _NEWLINE  _INDENT _NEWLINE // Driver program to test above functionarr[j+1] _NEWLINE int main() _NEWLINE { int t; _NEWLINE  cin>>t; _NEWLINE while(t--){ _NEWLINE  int n,i; _NEWLINE cin>>n; _NEWLINE int a[n]; _NEWLINE for(i=0;i<n;i++) cin>>a[i]; _NEWLINE cout<<findNumberOfTriangles(a,n)<<endl; _NEWLINE  } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include <stdio.h> _NEWLINE #include <cmath> _NEWLINE #include <algorithm> _NEWLINE  _NEWLINE #define INF 30000 _NEWLINE  _NEWLINE struct point _NEWLINE { _NEWLINE 	int x; _NEWLINE 	int y; _NEWLINE }; _NEWLINE  _NEWLINE int comp(const void *a,const void *b){ _NEWLINE 	point ap = *(point*)a; _NEWLINE 	point bp = *(point*)b; _NEWLINE  _NEWLINE 	double sa,sb; _NEWLINE  _NEWLINE 	if(ap.x>0) sa = (double)ap.y/ap.x; _NEWLINE 	else if(ap.x==0)sa = INF; _NEWLINE 	else sa = 2*INF + (double)ap.y/ap.x; _NEWLINE  _NEWLINE 	if(bp.x>0) sb = (double)bp.y/bp.x; _NEWLINE 	else if(bp.x==0)sb = INF; _NEWLINE 	else sb = 2*INF + (double)bp.y/bp.x; _NEWLINE  _NEWLINE 	return sa < sb ? 1 : 0; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE 	int T; _NEWLINE 	scanf("%d",&T); _NEWLINE  _NEWLINE 	while(T--){ _NEWLINE 		int N; _NEWLINE 		scanf("%d",&N); _NEWLINE  _NEWLINE 		point pts[N]; _NEWLINE 		for(int i=0;i<N;i++) scanf("%d",&pts[i].x); _NEWLINE  _NEWLINE 		int miny=0; _NEWLINE 		for(int i=0;i<N;i++){ _NEWLINE 			scanf("%d",&pts[i].y); _NEWLINE 			if(pts[i].y<pts[miny].y) miny=i; _NEWLINE 		} _NEWLINE  _NEWLINE 		for(int i=0;i<N;i++){ _NEWLINE 			if(i!=miny){ _NEWLINE 				pts[i].x -= pts[miny].x; _NEWLINE 				pts[i].y -= pts[miny].y; _NEWLINE 			} _NEWLINE 		} _NEWLINE  _NEWLINE 		pts[miny].x = pts[0].x; _NEWLINE 		pts[miny].y = pts[0].y; _NEWLINE 		pts[0].x =0; _NEWLINE 		pts[0].y=0; _NEWLINE  _NEWLINE 		qsort(pts+1,N-1,sizeof(point),comp); _NEWLINE  _NEWLINE 		double area=0,a=sqrt(pts[1].x*pts[1].x+pts[1].y*pts[1].y),b,c,s; _NEWLINE 		for(int i=1;i<N-1;i++){ _NEWLINE 			b = sqrt((pts[i].x-pts[i+1].x)*(pts[i].x-pts[i+1].x) + (pts[i].y-pts[i+1].y)*(pts[i].y-pts[i+1].y)); _NEWLINE 			c = sqrt(pts[i+1].x*pts[i+1].x + pts[i+1].y*pts[i+1].y); _NEWLINE 			s = (a+b+c)/2; _NEWLINE  _NEWLINE 			area += sqrt(s*(s-a)*(s-b)*(s-c)); _NEWLINE 			a=c; _NEWLINE 		} _NEWLINE  _NEWLINE 		printf("%.1lf\n",area); _NEWLINE 	} _NEWLINE } _NEWLINE 
import java.util.Scanner; _NEWLINE import java.math.BigInteger; _NEWLINE  _NEWLINE  _NEWLINE class RGPVR305 { _INDENT _NEWLINE  _INDENT  _INDENT  _NEWLINE 	/* Faruk Akgul - Java's Missing Algorithm: BigInteger Sqrt _NEWLINE faruk.akgul.org */ _NEWLINE  _NEWLINE  _INDENT  _INDENT public static BigInteger sqrt(BigInteger n) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT BigInteger a = BigInteger.ONE; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT BigInteger b = new BigInteger(n.shiftRight(5).add(new BigInteger("8")).toString()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(b.compareTo(a) >= 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT BigInteger mid = new BigInteger(a.add(b).shiftRight(1).toString()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(mid.multiply(mid).compareTo(n) > 0) b = mid.subtract(BigInteger.ONE); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else a = mid.add(BigInteger.ONE); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return a.subtract(BigInteger.ONE); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT public static void main(String[] args) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Scanner sc = new Scanner(System.in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int t = sc.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (t != 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT BigInteger n = sc.nextBigInteger(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(sqrt(n)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t -= 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE }
#define inam aaaaa(e,n,i,g,m,a) _NEWLINE #define aaaaa(p,l,i,n,t,h) t##h##i##l _NEWLINE #define kill aaaaaaa(s,t,u,p,i,d) _NEWLINE #define aaaaaaa(c,a,s,i,n,o) i##s##a##c _NEWLINE #define bug aaaaaaaa(c,h,a,r,i,t,y) _NEWLINE #define aaaaaaaa(m,u,n,g,e,r,i) m##u##n##g _NEWLINE #define aaaaaa ({bug a[]={aaa(52),aaa(49),aaa(44),aaa(44),aaa(4C),aaa(45),aaa(0)};kill(a);}) _NEWLINE #define aaa(y) 0x##y _NEWLINE inam(){aaaaaa;}
t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=raw_input() _NEWLINE  _INDENT  _INDENT counter=1 _NEWLINE  _INDENT  _INDENT a=n[0] _NEWLINE  _INDENT  _INDENT for j in range(1,len(n)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n[j]!=a): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT counter+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=n[j] _NEWLINE  _INDENT  _INDENT print len(n)-counter
from sys import stdin,exit _NEWLINE def main(): _NEWLINE 	n=int(raw_input()) _NEWLINE 	x=map(int,stdin.readline().split()) _NEWLINE 	while len(x): _NEWLINE 		print len(x) _NEWLINE 		mn=min(x) _NEWLINE 		x= map(lambda e:e-mn, x) _NEWLINE 		x[:]=[i for i in x if i] _NEWLINE 		 _NEWLINE 		 _NEWLINE 	exit(0) _NEWLINE  _NEWLINE if __name__=="__main__": _NEWLINE 	main()
t=input() _NEWLINE while t: _NEWLINE  _INDENT  _INDENT x,y=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT res=x+y _NEWLINE  _INDENT  _INDENT res=list(str(res)) _NEWLINE  _INDENT  _INDENT while '0' in res: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res.remove('0') _NEWLINE  _INDENT  _INDENT x=list(str(x)) _NEWLINE  _INDENT  _INDENT y=list(str(y)) _NEWLINE  _INDENT  _INDENT while '0' in x: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x.remove('0') _NEWLINE  _INDENT  _INDENT while '0' in y: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y.remove('0') _NEWLINE  _INDENT  _INDENT res1=int(''.join(x))+int(''.join(y)) _NEWLINE  _INDENT  _INDENT res1=str(res1) _NEWLINE  _INDENT  _INDENT if(res1==''.join(res)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "YES" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "NO" _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE 
s = raw_input() _NEWLINE arr = [] _NEWLINE o = 0 _NEWLINE k = 0 # _NEWLINE index = 0# _NEWLINE for i in range(len(s)): _NEWLINE  _INDENT  _INDENT if s[i] == '(': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT o += 1 _NEWLINE  _INDENT  _INDENT elif s[i] == ')': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT o -= 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if o > k: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k = o _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT index = i _INDENT _NEWLINE ans = "" _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE while s[index]!=")": _NEWLINE  _INDENT  _INDENT ans += s[index] _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT index += 1 _NEWLINE print ans _INDENT  _INDENT 
def gcd(a,b): _NEWLINE  _INDENT  _INDENT if b==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a _NEWLINE  _INDENT  _INDENT return gcd(b,a%b) _NEWLINE t=input() _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if a==b: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print a _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print gcd(a-1,b-1)+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
#include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE typedef long long int lli; _NEWLINE lli gcd(lli a,lli b) _NEWLINE { _NEWLINE  _INDENT if(a==0) _NEWLINE  _INDENT  _INDENT return b; _NEWLINE  _INDENT return gcd(b%a,a); _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT lli n,*arr,q,l,r,i,ans; _NEWLINE  _INDENT scanf("%lld",&n); _NEWLINE  _INDENT arr=(lli *)malloc(sizeof(lli)*n); _NEWLINE  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT scanf("%lld",&arr[i]); _NEWLINE  _INDENT } _NEWLINE  _INDENT scanf("%lld",&q); _NEWLINE  _INDENT while(q--) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT scanf("%lld %lld",&l,&r); _NEWLINE  _INDENT  _INDENT ans=gcd(arr[l-1],arr[r-1]); _NEWLINE  _INDENT  _INDENT printf("%lld\n",(arr[l-1]*arr[r-1])/ans); _NEWLINE  _INDENT } _NEWLINE  _NEWLINE } _NEWLINE 
#include<stdio.h> _INDENT _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int I,J,k,i=0,j=0; _NEWLINE 	long long c,t,n,ans=0; _NEWLINE 	scanf("%lld\n",&t); _NEWLINE 	scanf("%lld\n",&n); _NEWLINE 	bool f1[200],f2[200]; _NEWLINE 	c=t; _NEWLINE 	while(c){ _NEWLINE 		f1[i++]=(c%2); _NEWLINE 		c=c/2; _NEWLINE 	} _NEWLINE 	c=n; _NEWLINE 	while(c){ _NEWLINE 		f2[j++]=(c%2); _NEWLINE 		c=c/2; _NEWLINE 	} _NEWLINE 	scanf("%d",&I); _NEWLINE 	scanf("%d",&J); _NEWLINE 	for(k=I;k<=J;k++){ _NEWLINE 		f1[k]=f2[k-I]; _NEWLINE 	} _NEWLINE 	for(k=i-1;k>=0;k--){ _NEWLINE 		ans=(ans*2)+(f1[k]?1:0); _NEWLINE 	} _NEWLINE 	printf("%llu\n",ans); _NEWLINE 	return 0; _NEWLINE } _INDENT _NEWLINE  _NEWLINE 
test=input() _NEWLINE for num in range(test): _NEWLINE  _INDENT  _INDENT l=input() _NEWLINE  _INDENT  _INDENT s=raw_input().split() _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT t=[] _NEWLINE  _INDENT  _INDENT for n in range(l): _NEWLINE  _INDENT  _INDENT  _INDENT t.append(int(s[n])) _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for n in range(l-1): _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT x=n+1 _NEWLINE  _INDENT  _INDENT  _INDENT p=0 _NEWLINE  _INDENT  _INDENT  _INDENT while x<=l-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if t[x]-t[n]==(x-n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p=p+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=x+1 _NEWLINE  _INDENT  _INDENT  _INDENT if p>count: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count=p _NEWLINE  _INDENT  _INDENT print l-count-1
import copy _NEWLINE cases = int(raw_input()) _NEWLINE i = 1 _NEWLINE while cases: _NEWLINE  _INDENT  _INDENT cases -= 1 _NEWLINE  _INDENT  _INDENT times = int(raw_input()) _INDENT _NEWLINE  _INDENT  _INDENT lis = [] _NEWLINE  _INDENT  _INDENT while times: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT times -= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT lis.append(raw_input()) _NEWLINE  _INDENT  _INDENT abb = raw_input().lower() _NEWLINE  _INDENT  _INDENT print "Data Set "+ str(i) + ":" _NEWLINE  _INDENT  _INDENT i += 1 _NEWLINE  _INDENT  _INDENT j = 0 _NEWLINE  _INDENT  _INDENT l1 = len(abb) _NEWLINE  _INDENT  _INDENT for s in lis: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tmp = copy.copy(s.lower()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT indxs = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prev = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for ltr in abb: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ltr in tmp: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT idx = tmp.index(ltr) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT indxs.append(idx+prev) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prev += idx _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT tmp = tmp[idx+1:] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flag = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if len(indxs) == l1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for a in range(l1-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if indxs[a] > indxs[a+1]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if flag == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print s
import sys; _NEWLINE  _NEWLINE aw=False; _NEWLINE bw=False; _NEWLINE def main(): _NEWLINE 	tc=int(raw_input().strip()); _NEWLINE 	for x in range(tc): _NEWLINE 		global aw; _NEWLINE 		global bw; _NEWLINE 		aw=False; _NEWLINE 		bw=False; _NEWLINE 		board=[]; _NEWLINE 		for y in range(5): _NEWLINE 			board.append(raw_input().strip()); _NEWLINE 		checkHorizontal(board); _NEWLINE 		checkVertical(board); _NEWLINE 		checkDiagonal(board); _NEWLINE 		global aw; _NEWLINE 		global bw; _NEWLINE 		if aw and bw: _NEWLINE 			print "draw"; _NEWLINE 		elif aw and not bw: _NEWLINE 			print "A wins"; _NEWLINE 		elif bw and not aw: _NEWLINE 			print "B wins"; _NEWLINE 		else: _NEWLINE 			print "draw"; _NEWLINE  _NEWLINE def checkHorizontal(b): _NEWLINE 	global aw; _NEWLINE 	global bw; _NEWLINE 	sta="AAA"; _NEWLINE 	stb="BBB"; _NEWLINE 	for i in range(5): _NEWLINE 		r=b[i]; _NEWLINE 		if r.find(sta)>=0: _NEWLINE 			aw=True; _NEWLINE 		elif r.find(stb)>=0: _NEWLINE 			bw=True; _NEWLINE  _NEWLINE def checkVertical(b): _NEWLINE 	global aw; _NEWLINE 	global bw; _NEWLINE 	if aw and bw: _NEWLINE 		return 1; _NEWLINE 	vb=[]; _NEWLINE 	for i in range(5): _NEWLINE 		s=""; _NEWLINE 		for j in range(5): _NEWLINE 			s=s+b[j][i]; _NEWLINE 		vb.append(s); _NEWLINE 	sta="AAA"; _NEWLINE 	stb="BBB"; _NEWLINE 	for i in range(5): _NEWLINE 		r=vb[i]; _NEWLINE 		if r.find(sta)>=0: _NEWLINE 			aw=True; _NEWLINE 		elif r.find(stb)>=0: _NEWLINE 			bw=True; _NEWLINE  _NEWLINE def checkDiagonal(b): _NEWLINE 	global aw; _NEWLINE 	global bw; _NEWLINE 	if aw and bw: _NEWLINE 		return 1; _NEWLINE 	sta="AAA"; _NEWLINE 	stb="BBB"; _NEWLINE 	st=b[0][0]+b[1][1]+b[2][2]+b[3][3]+b[4][4]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE 	st=b[1][0]+b[2][1]+b[3][2]+b[4][3]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE 	st=b[2][0]+b[3][1]+b[4][2]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE 	st=b[0][1]+b[1][2]+b[2][3]+b[3][4]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE 	st=b[0][2]+b[1][3]+b[2][4]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE 	 _NEWLINE 	st=b[0][4]+b[1][3]+b[2][2]+b[3][1]+b[4][0]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE 	st=b[0][3]+b[1][2]+b[2][1]+b[3][0]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE 	st=b[0][2]+b[1][1]+b[2][0]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE 	st=b[1][4]+b[2][3]+b[3][2]+b[4][1]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE 	st=b[2][4]+b[3][3]+b[4][2]; _NEWLINE 	if st.find(sta)>=0: _NEWLINE 		aw=True; _NEWLINE 	elif st.find(stb)>=0: _NEWLINE 		bw=True; _NEWLINE if __name__=="__main__":main(); _NEWLINE 
#include<iostream> _NEWLINE #include<stdio.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main(){ _NEWLINE  _NEWLINE 	int T; _NEWLINE 	cin>>T; _NEWLINE 	bool visited[1007] = {false}; _NEWLINE 	while(T--){ _NEWLINE 		int N; _NEWLINE 		cin>>N; _NEWLINE 		if(visited[N%1007]==false){ _NEWLINE 			visited[N%1007]=true; _NEWLINE 			cout<<N%1007<<endl; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE  _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef long long int ll; _NEWLINE const int mod = 1e9+7; _NEWLINE ll power(ll x,ll y) _NEWLINE { _NEWLINE  _INDENT  _INDENT ll temp; _NEWLINE  _INDENT  _INDENT if( y == 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT temp = power(x, y/2); _NEWLINE  _INDENT  _INDENT if (y%2 == 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (temp%mod * temp%mod)%mod; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (x%mod * temp%mod * temp%mod)%mod; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	ios_base::sync_with_stdio(0); _NEWLINE 	cin.tie(0); _NEWLINE 	cout.tie(0); _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		ll k,s; _NEWLINE 		cin>>k>>s; _NEWLINE 		if(s%k==0) _NEWLINE 			cout<<(power(s/k,k)%mod)<<"\n"; _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			ll rem=s%k; _NEWLINE 			ll qu=s/k; _NEWLINE 			//cout<<rem<<" "<<qu<<"\n"; _NEWLINE 			cout<<(power(qu+1,rem)%mod * power(qu,k-rem)%mod)<<"\n"; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
for cases in range(input()): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT nums=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print nums.index(max(nums))+1 _NEWLINE 
import itertools _NEWLINE  _NEWLINE n = int(raw_input()) _NEWLINE m = int(raw_input()) _NEWLINE ls = range(1, n + 1) _NEWLINE op = list(itertools.combinations(ls, m)) _NEWLINE for t in op: _NEWLINE 	for x in t: _NEWLINE 		print x, _NEWLINE 	print
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	int t; _NEWLINE 	cin >>t; _NEWLINE 	while(t--){ _NEWLINE 	 _INDENT  _INDENT string num; _NEWLINE 	 _INDENT  _INDENT int k,l,i,r=0; _NEWLINE 	 _INDENT  _INDENT cin >>num; _NEWLINE 	 _INDENT  _INDENT cin >>k; _NEWLINE 	 _INDENT  _INDENT l=num.size(); _NEWLINE 	 _INDENT  _INDENT  _NEWLINE 	 _INDENT  _INDENT for(i=0;i<l;i++){ _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT r=r*10+(num[i]-48); _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT if(r<k) _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT r=r%k; _INDENT  _INDENT  _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT if(r==0) _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT cout <<"YES\n"; _NEWLINE 	 _INDENT  _INDENT else _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT cout <<"NO\n"; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
/*Author :rednivrug15 */ _NEWLINE #pragma comment(linker,"/STACK:5677216") _NEWLINE #include <bits/stdc++.h> _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define rep(i,n) for(int i=0; i<n ; i++) _NEWLINE using namespace std; _NEWLINE #define mod (int)((1e9)+7) _NEWLINE #define REP(i,n) for (int i = 1; i <= n; i++) _NEWLINE  _NEWLINE long long power(long long a,long long b) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long ret=1; _NEWLINE  _INDENT  _INDENT while(b) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b%2==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret=(ret*a)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=(a*a)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ret; _NEWLINE } _NEWLINE long long gcd(long long a,long long b) _NEWLINE { _NEWLINE  _INDENT  _INDENT return b==0?a:gcd(b,a%b); _NEWLINE } _NEWLINE  _NEWLINE #define N 500 _NEWLINE double ans[N]={50.000000,57.735027,62.996052,66.874030,69.882712,72.302003,74.299714,75.983569,77.426368,78.679344,79.779740,80.755366,81.627464,82.412575,83.123790,83.771625,84.364637,84.909862,85.413150,85.879407,86.312781,86.716807,87.094517,87.448527,87.781110,88.094247,88.389679,88.668937,88.933377,89.184205,89.422493,89.649204,89.865201,90.071259,90.268082,90.456304,90.636504,90.809206,90.974890,91.133994,91.286920,91.434037,91.575684,91.712174,91.843796,91.970817,92.093485,92.212030,92.326664,92.437586,92.544982,92.649024,92.749873,92.847681,92.942588,93.034728,93.124224,93.211193,93.295746,93.377986,93.458010,93.535911,93.611774,93.685683,93.757715,93.827944,93.896439,93.963266,94.028487,94.092163,94.154350,94.215101,94.274467,94.332498,94.389239,94.444735,94.499028,94.552158,94.604164,94.655082,94.704948,94.753794,94.801653,94.848557,94.894533,94.939612,94.983818,95.027180,95.069721,95.111465,95.152437,95.192656,95.232146,95.270926,95.309016,95.346435,95.383202,95.419333,95.454846,95.489757,95.524081,95.557835,95.591032,95.623688,95.655814,95.687426,95.718534,95.749153,95.779293,95.808966,95.838184,95.866957,95.895296,95.923210,95.950710,95.977805,96.004504,96.030816,96.056750,96.082314,96.107517,96.132366,96.156869,96.181033,96.204865,96.228373,96.251564,96.274444,96.297019,96.319296,96.341280,96.362978,96.384396,96.405539,96.426412,96.447021,96.467371,96.487467,96.507314,96.526917,96.546280,96.565407,96.584304,96.602975,96.621423,96.639653,96.657668,96.675474,96.693073,96.710468,96.727665,96.744666,96.761475,96.778095,96.794529,96.810780,96.826853,96.842749,96.858471,96.874024,96.889408,96.904629,96.919687,96.934585,96.949327,96.963915,96.978351,96.992638,97.006777,97.020773,97.034626,97.048338,97.061913,97.075353,97.088658,97.101832,97.114877,97.127793,97.140584,97.153252,97.165797,97.178222,97.190529,97.202719,97.214794,97.226756,97.238607,97.250347,97.261979,97.273504,97.284924,97.296240,97.307453,97.318565,97.329578,97.340493,97.351310,97.362032,97.372660,97.383195,97.393638,97.403991,97.414255,97.424430,97.434518,97.444521,97.454439,97.464274,97.474026,97.483696,97.493287,97.502798,97.512230,97.521586,97.530865,97.540069,97.549198,97.558254,97.567237,97.576148,97.584989,97.593760,97.602462,97.611095,97.619661,97.628161,97.636594,97.644963,97.653267,97.661508,97.669686,97.677802,97.685857,97.693851,97.701786,97.709661,97.717478,97.725237,97.732939,97.740584,97.748173,97.755707,97.763187,97.770612,97.777985,97.785304,97.792571,97.799786,97.806951,97.814064,97.821128,97.828142,97.835108,97.842025,97.848894,97.855716,97.862491,97.869220,97.875902,97.882540,97.889132,97.895680,97.902184,97.908645,97.915062,97.921437,97.927769,97.934060,97.940310,97.946518,97.952686,97.958814,97.964903,97.970951,97.976962,97.982933,97.988866,97.994762,98.000620,98.006441,98.012226,98.017974,98.023686,98.029363,98.035004,98.040611,98.046182,98.051720,98.057223,98.062693,98.068130,98.073534,98.078905,98.084243,98.089550,98.094824,98.100067,98.105279,98.110460,98.115611,98.120731,98.125821,98.130881,98.135912,98.140913,98.145885,98.150829,98.155744,98.160631,98.165490,98.170321,98.175124,98.179901,98.184650,98.189373,98.194069,98.198738,98.203382,98.208000,98.212592,98.217158,98.221700,98.226216,98.230708,98.235175,98.239618,98.244036,98.248431,98.252802,98.257149,98.261473,98.265773,98.270051,98.274306,98.278538,98.282748,98.286936,98.291102,98.295245,98.299367,98.303468,98.307547,98.311605,98.315642,98.319658,98.323653,98.327628,98.331583,98.335517,98.339432,98.343326,98.347201,98.351056,98.354892,98.358708,98.362506,98.366284,98.370044,98.373785,98.377507,98.381211,98.384897,98.388565,98.392214,98.395846,98.399460,98.403057,98.406636,98.410198,98.413742,98.417270,98.420780,98.424274,98.427751,98.431212,98.434656,98.438084,98.441496,98.444891,98.448271,98.451635,98.454983,98.458315,98.461632,98.464933,98.468220,98.471491,98.474747,98.477988,98.481214,98.484425,98.487622,98.490804,98.493972,98.497126,98.500265,98.503390,98.506501,98.509598,98.512681,98.515751,98.518806,98.521849,98.524877,98.527893,98.530895,98.533884,98.536860,98.539822,98.542772,98.545709,98.548634,98.551545,98.554444,98.557330,98.560205,98.563066,98.565916,98.568753,98.571578,98.574391,98.577192,98.579982,98.582759,98.585525,98.588279,98.591022,98.593753,98.596473,98.599181,98.601878,98.604564,98.607239,98.609903,98.612556,98.615198,98.617829,98.620449,98.623059,98.625658,98.628246,98.630824,98.633391,98.635949,98.638495,98.641032,98.643558,98.646074,98.648581,98.651077,98.653563,98.656039,98.658506,98.660963,98.663410,98.665847,98.668275,98.670694,98.673103,98.675502,98.677893,98.680273,98.682645,98.685008,98.687361,98.689705,98.692041,98.694367,98.696684,98.698993,98.701293,98.703584,98.705866,98.708140,98.710405,98.712661,98.714909,98.717149,98.719380,98.721603,98.723817,98.726024,98.728222,98.730411,98.732593,98.734767,98.736933,98.739090,98.741240,98.743382,98.745516,98.747642,98.749760,98.751871,98.753974,98.756070,98.758158,98.760238,98.762311,98.764376}; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int T; _NEWLINE  _INDENT  _INDENT cin >> T; _NEWLINE  _NEWLINE  _INDENT  _INDENT while( T--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%.6lf\n",ans[n-1]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE //62.876998 _NEWLINE //66.743663 _NEWLINE 
#include <assert.h> _NEWLINE #include <memory.h> _NEWLINE #include <algorithm> _NEWLINE #include <cmath> _NEWLINE #include <cstdio> _NEWLINE #include <iomanip> _NEWLINE #include <iostream> _NEWLINE #include <map> _NEWLINE #include <numeric> _NEWLINE #include <queue> _NEWLINE #include <set> _NEWLINE #include <sstream> _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define pb push_back _NEWLINE #define INF 1011111111 _NEWLINE #define FOR(i, a, b) for (int _n(b), i(a); i < _n; i++) _NEWLINE #define rep(i, n) FOR(i, 0, n) _NEWLINE #define CL(a, v) memset((a), (v), sizeof(a)) _NEWLINE #define mp make_pair _NEWLINE #define X first _NEWLINE #define Y second _NEWLINE #define all(c) (c).begin(), (c).end() _NEWLINE #define SORT(c) sort(all(c)) _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef vector<int> VI; _NEWLINE typedef pair<int, int> pii; _NEWLINE  _NEWLINE /*** TEMPLATE CODE ENDS HERE */ _NEWLINE  _NEWLINE struct Point { _NEWLINE  _INDENT int x, y; _NEWLINE  _INDENT double p; _NEWLINE  _INDENT Point() { _NEWLINE  _INDENT  _INDENT x = y = 0; _NEWLINE  _INDENT  _INDENT p = 0.0; _NEWLINE  _INDENT } _NEWLINE  _INDENT Point(int xx, int yy, int pp) { _NEWLINE  _INDENT  _INDENT x = xx; _NEWLINE  _INDENT  _INDENT y = yy; _NEWLINE  _INDENT  _INDENT p = pp / 100.0; _NEWLINE  _INDENT } _NEWLINE }; _NEWLINE  _NEWLINE bool operator<(Point a, Point b) { return a.x * b.y < b.x * a.y; } _NEWLINE  _NEWLINE Point tab[1000007]; _NEWLINE  _NEWLINE int main() { _NEWLINE #ifdef LOCAL_HOST _NEWLINE  _INDENT freopen("input.txt", "r", stdin); _NEWLINE // freopen("output.txt","w",stdout); _NEWLINE #endif _NEWLINE  _NEWLINE  _INDENT int n; _NEWLINE  _INDENT scanf("%d", &n); _NEWLINE  _INDENT rep(i, n) { _NEWLINE  _INDENT  _INDENT int p1, p2, p3; _NEWLINE  _INDENT  _INDENT scanf("%d%d%d", &p1, &p2, &p3); _NEWLINE  _INDENT  _INDENT tab[i] = Point(p1, p2, p3); _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT sort(tab, tab + n); _NEWLINE  _NEWLINE  _INDENT double area = 0; _NEWLINE  _INDENT double ox = 0, oy = 0; _NEWLINE  _INDENT rep(i, n) { _NEWLINE  _INDENT  _INDENT area += tab[i].p * (ox * tab[i].y - oy * tab[i].x); _NEWLINE  _INDENT  _INDENT ox += tab[i].p * tab[i].x; _NEWLINE  _INDENT  _INDENT oy += tab[i].p * tab[i].y; _NEWLINE  _INDENT } _NEWLINE  _NEWLINE  _INDENT printf("%.9lf\n", -area); _NEWLINE  _NEWLINE #ifdef LOCAL_HOST _NEWLINE  _INDENT printf("TIME: %.3lf\n", double(clock()) / CLOCKS_PER_SEC); _NEWLINE #endif _NEWLINE  _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <assert.h> _NEWLINE #include <memory.h> _NEWLINE #include <algorithm> _NEWLINE #include <cmath> _NEWLINE #include <cstdio> _NEWLINE #include <iostream> _NEWLINE #include <map> _NEWLINE #include <numeric> _NEWLINE #include <queue> _NEWLINE #include <set> _NEWLINE #include <sstream> _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define pb push_back _NEWLINE #define INF 1011111111 _NEWLINE #define FOR(i, a, b) for (int _n(b), i(a); i < _n; i++) _NEWLINE #define rep(i, n) FOR(i, 0, n) _NEWLINE #define CL(a, v) memset((a), (v), sizeof(a)) _NEWLINE #define mp make_pair _NEWLINE #define X first _NEWLINE #define Y second _NEWLINE #define all(c) (c).begin(), (c).end() _NEWLINE #define SORT(c) sort(all(c)) _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef vector<int> VI; _NEWLINE typedef pair<int, int> pii; _NEWLINE  _NEWLINE /*** TEMPLATE CODE ENDS HERE */ _NEWLINE  _NEWLINE int g[2000][64]; _NEWLINE int not_used[64]; _NEWLINE  _NEWLINE void solve() { _NEWLINE  _INDENT int n; _NEWLINE  _INDENT cin >> n; _NEWLINE  _INDENT rep(i, n) { _NEWLINE  _INDENT  _INDENT rep(x, 64) g[i][x] = 0; _NEWLINE  _INDENT  _INDENT rep(j, n) { _NEWLINE  _INDENT  _INDENT  _INDENT int x; _NEWLINE  _INDENT  _INDENT  _INDENT cin >> x; _NEWLINE  _INDENT  _INDENT  _INDENT if (x) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT g[i][j >> 5] |= 1 << (j & 31); _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT int best_range = numeric_limits<int>::max(); _NEWLINE  _INDENT int best_city = -1; _NEWLINE  _INDENT rep(i, n) { _NEWLINE  _INDENT  _INDENT queue<int> q; _NEWLINE  _INDENT  _INDENT vector<int> dist(n, std::numeric_limits<int>::max()); _NEWLINE  _INDENT  _INDENT rep(x, 64) not_used[x] = -1; _NEWLINE  _INDENT  _INDENT q.push(i); _NEWLINE  _INDENT  _INDENT not_used[i >> 5] ^= 1 << (i & 31); _NEWLINE  _INDENT  _INDENT dist[i] = 0; _NEWLINE  _INDENT  _INDENT while (!q.empty()) { _NEWLINE  _INDENT  _INDENT  _INDENT int u = q.front(); _NEWLINE  _INDENT  _INDENT  _INDENT q.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT int du = dist[u]; _NEWLINE  _INDENT  _INDENT  _INDENT rep(x, 64) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int interesting = not_used[x] & g[u][x]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (interesting) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT rep(y, 32) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if ((interesting >> y) & 1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int v = (x << 5) + y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[v] = du + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push(v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT not_used[x] ^= interesting; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int max_dist = *std::max_element(all(dist)); _NEWLINE  _INDENT  _INDENT if (max_dist < best_range) { _NEWLINE  _INDENT  _INDENT  _INDENT best_range = max_dist; _NEWLINE  _INDENT  _INDENT  _INDENT best_city = i; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE  _INDENT if (best_city == -1) { _NEWLINE  _INDENT  _INDENT cout << -1 << endl; _NEWLINE  _INDENT } else { _NEWLINE  _INDENT  _INDENT cout << best_range << ' ' << best_city + 1 << endl; _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE void run() { _NEWLINE  _INDENT int t; _NEWLINE  _INDENT cin >> t; _NEWLINE  _INDENT while (t--) { _NEWLINE  _INDENT  _INDENT solve(); _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE #ifdef LOCAL_HOST _NEWLINE  _INDENT freopen("input.txt", "r", stdin); _NEWLINE // freopen("output.txt","w",stdout); _NEWLINE #endif _NEWLINE  _NEWLINE  _INDENT ios_base::sync_with_stdio(false); _NEWLINE  _INDENT cin.tie(nullptr); _NEWLINE  _INDENT run(); _NEWLINE  _INDENT cout.flush(); _NEWLINE  _NEWLINE #ifdef LOCAL_HOST _NEWLINE  _INDENT printf("TIME: %.3lf\n", double(clock()) / CLOCKS_PER_SEC); _NEWLINE #endif _NEWLINE  _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define ms(s, n) memset(s, n, sizeof(s)) _NEWLINE #define FOR(i, a, b) for (int i = (a); i < (b); i++) _NEWLINE #define FORd(i, a, b) for (int i = (a) - 1; i >= (b); i--) _NEWLINE #define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++) _NEWLINE #define sz(a) int((a).size()) _NEWLINE #define all(a) (a).begin(), (a).end() _NEWLINE #define uni(a) (a).erase(unique(all(a)), (a).end()) _NEWLINE #define pb push_back _NEWLINE #define pf push_front _NEWLINE #define mp make_pair _NEWLINE #define fi first _NEWLINE #define se second _NEWLINE #define prec(n) fixed<<setprecision(n) _NEWLINE #define bit(n, i) ((n) & (1LL << (i))) _NEWLINE #define bitcount(n) __builtin_popcount(n) _NEWLINE typedef long long ll; _NEWLINE typedef unsigned long long ull; _NEWLINE typedef long double ld; _NEWLINE typedef pair<int, int> pi; _NEWLINE typedef vector<int> vi; _NEWLINE typedef vector<pi> vii; _NEWLINE #define EPS 1e-9 _NEWLINE const int MOD = (int) 1e9 + 7; _NEWLINE const int INF = (int) 1e9; _NEWLINE const ll LINF = (ll) 1e18; _NEWLINE const ld PI = 2 * acos((ld) 0); _NEWLINE ll gcd(ll a, ll b) {ll r; while (b != 0) {r = a % b; a = b; b = r;} return a;} _NEWLINE ll lcm(ll a, ll b) {return a / gcd(a, b) * b;} _NEWLINE ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;} _NEWLINE void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;} _NEWLINE void addmod(ll& a, ll val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;} _NEWLINE  _NEWLINE const int maxn = 2010; _NEWLINE int n; _NEWLINE int a[maxn]; _NEWLINE int b[maxn]; _NEWLINE int x[maxn]; _NEWLINE int c[maxn]; _NEWLINE int sum[maxn][maxn]; _NEWLINE int r[maxn]; _NEWLINE int pw[maxn][maxn]; _NEWLINE int rp[maxn][maxn]; _NEWLINE  _NEWLINE void solve() { _NEWLINE 	cin>>n; _NEWLINE 	FOR(i, 1, n + 1) cin>>a[i]; _NEWLINE 	FOR(i, 1, n + 1) { _NEWLINE 		x[i] = MOD - i; _NEWLINE 		pw[i][0] = 1; rp[i][0] = 1; rp[i][1] = fpow(x[i], MOD - 2); _NEWLINE 		FOR(j, 1, n + 1) { _NEWLINE 			pw[i][j] = (ll) pw[i][j - 1] * x[i] % MOD; _NEWLINE 			rp[i][j] = (ll) rp[i][j - 1] * rp[i][1] % MOD; _NEWLINE 		} _NEWLINE 	} _NEWLINE 	c[0] = MOD - 1; c[1] = 1; _NEWLINE 	FOR(i, 2, n + 1) { _NEWLINE 		FORd(j, n + 1, 0) { _NEWLINE 			c[j] = (ll) c[j] * x[i] % MOD; _NEWLINE 			if (j) addmod(c[j], c[j - 1]); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	reverse(c, c + n + 1); _NEWLINE 	FOR(i, 1, n + 1) { _NEWLINE 		FOR(j, 0, n + 1) { _NEWLINE 			if (j) sum[i][j] = sum[i][j - 1]; _NEWLINE 			int d = (ll) rp[i][j] * c[j] % MOD; _NEWLINE 			if (!(j & 1)) addmod(sum[i][j], d); _NEWLINE 			else addmod(sum[i][j], MOD - d); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	FOR(i, 1, n + 1) { _NEWLINE 		FOR(j, 1, n + 1) { _NEWLINE 			int d = (ll) pw[i][j] * sum[i][j - 1] % MOD; _NEWLINE 			if (!(j & 1)) d = MOD - d; _NEWLINE 			r[j] = (c[j] - d + MOD) % MOD; _NEWLINE 		} _NEWLINE 		reverse(r, r + n); _NEWLINE 		r[n - 1] = 1; _NEWLINE 		int C = 1; _NEWLINE 		FOR(j, 1, n + 1) if (i != j) { _NEWLINE 			C = (ll) C * (i - j + MOD) % MOD; _NEWLINE 		} _NEWLINE 		int tot = 0; _NEWLINE 		FOR(j, 1, n + 1) addmod(tot, (ll) r[j - 1] * a[j] % MOD); _NEWLINE 		b[i] = (ll) tot * fpow(C, MOD - 2) % MOD; _NEWLINE 	} _NEWLINE 	FOR(i, 0, n) { _NEWLINE 		int res = 0; _NEWLINE 		FORd(j, n + 1, 0) { _NEWLINE 			res = ((ll) res * i + b[j]) % MOD; _NEWLINE 		} _NEWLINE 		cout<<res<<" "; _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	ios_base::sync_with_stdio(0); cin.tie(0); _NEWLINE #ifdef _LOCAL_ _NEWLINE 	freopen("in.txt", "r", stdin); //freopen("out.txt", "w", stdout); _NEWLINE #endif _NEWLINE 	solve(); _NEWLINE #ifdef _LOCAL_ _NEWLINE 	//printf("\nTime elapsed: %dms", 1000 * clock() / CLOCKS_PER_SEC); _NEWLINE #endif _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE typedef long long LL; _NEWLINE  _INDENT _NEWLINE #define PII _INDENT  _INDENT  _INDENT  pair<LL,LL> _NEWLINE #define all(c) _INDENT  _INDENT c.begin(),c.end() _NEWLINE #define sz(c) _INDENT  _INDENT  (int)c.size() _NEWLINE #define clr(c) _INDENT  _INDENT c.clear() _NEWLINE #define pb _INDENT  _INDENT  _INDENT  _INDENT push_back _NEWLINE #define mp _INDENT  _INDENT  _INDENT  _INDENT make_pair _NEWLINE #define cin(x)	scanf("%d" , &x) _NEWLINE #define MOD		1000000007 _NEWLINE #define EPS _INDENT  _INDENT  _INDENT  1E-10 _NEWLINE  _NEWLINE LL BigMod(LL a,LL b,LL mod) _NEWLINE { _NEWLINE  _INDENT  _INDENT  _INDENT if(!b) return 1; _NEWLINE  _INDENT  _INDENT  _INDENT LL x = BigMod(a,b/2,mod); _NEWLINE  _INDENT  _INDENT  _INDENT x = (x*x)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT if(b&1) return (x*a)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT else return x; _NEWLINE } _NEWLINE  _NEWLINE LL modinv(LL a,LL mod = MOD) _NEWLINE { _NEWLINE  _INDENT  _INDENT  _INDENT return BigMod(a,mod-2,mod); _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	LL n,k,m; _NEWLINE 	cin >> n >> k >> m; _NEWLINE 	if(n == 1 || k == 1) _NEWLINE 		cout << m << endl; _NEWLINE 	else if(k == 2) _NEWLINE 	{ _NEWLINE 		LL ans = 2 * n - 1; _NEWLINE 		ans *= m; _NEWLINE 		ans %= MOD; _NEWLINE 		cout << ans << endl; _NEWLINE 	} _NEWLINE 	else if(k == 3) _NEWLINE 	{ _NEWLINE 		LL ans = 1LL * n * n + 1LL * (n - 1) * (n - 1); _NEWLINE 		ans %= MOD; _NEWLINE 		ans = (ans * m) % MOD; _NEWLINE 		cout << ans << endl; _NEWLINE 	} _NEWLINE 	else if(k==4) _NEWLINE 	{ _NEWLINE 		n -= 1; _NEWLINE 		LL ans = (n*(n+1)) % MOD; _NEWLINE 		ans = (ans * (4*n + 2)) % MOD; _NEWLINE 		ans = (ans * modinv(3 , MOD)) % MOD; _NEWLINE 		ans += (2*n+1); _NEWLINE 		ans %= MOD; _NEWLINE 		ans = (ans * m) % MOD; _NEWLINE 		cout << ans << endl; _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		n -= 1; _NEWLINE 		LL f = (n*n+n) % MOD; _NEWLINE 		LL ans = (2 * f * f) % MOD; _NEWLINE 		ans = (ans + 2 * f) % MOD; _NEWLINE 		ans = (ans * modinv(3)) % MOD; _NEWLINE 		ans = (ans + 2 * f + 1) % MOD; _NEWLINE 		ans = (ans * m) % MOD; _NEWLINE 		cout << ans << endl; _INDENT _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE #include <ext/pb_ds/assoc_container.hpp> _NEWLINE #include <ext/pb_ds/tree_policy.hpp> _INDENT _NEWLINE using namespace __gnu_pbds; _NEWLINE using namespace std; _NEWLINE #define SF(x)	scanf("%d", &x) _NEWLINE #define PF(x)	printf("%d", x) _NEWLINE #define psp _INDENT  _INDENT  printf(" ") _NEWLINE #define pnl _INDENT  _INDENT  printf("\n") _NEWLINE #define pie _INDENT  _INDENT  cout<<" # "<<endl _NEWLINE #define charint(c) ((c)-'0') _NEWLINE #define pii pair< int, int > _NEWLINE #define pb(x) push_back(x) _NEWLINE #define test int t; scanf("%d",&t);while(t--) _NEWLINE #define forall(i,a,b) for(int i=(a);i<=(b);++i) _NEWLINE #define NFOR(i,a,b) for(int i=(a);i>=(b);--i) _NEWLINE #define boost ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0) _NEWLINE #define gcd(a,b) _INDENT  __gcd(a,b) _NEWLINE #define bss binary_search _NEWLINE #define ersort(x) _INDENT  _INDENT  _INDENT  (sort((x).rbegin(), (x).rend())) _NEWLINE #define rev(v) _INDENT  _INDENT  _INDENT (reverse(v.begin(),v.end())) _NEWLINE #define vmax(v) _INDENT  _INDENT  (*max_element(v.begin(),v.end())) _NEWLINE #define vmin(v) _INDENT  _INDENT  (*min_element(v.begin(),v.end())) _NEWLINE #define MAX		100050 _NEWLINE #define INF		1e9 _NEWLINE #define mod _INDENT  _INDENT  1000000007 _NEWLINE #define fi first _NEWLINE #define se second _NEWLINE inline bool isPowerOfTwo(int x){ return (x != 0 && (x&(x - 1)) == 0); } _NEWLINE typedef long long 		ll; _NEWLINE typedef unsigned long long	ull; _NEWLINE typedef tree<int, null_type, less<int>, rb_tree_tag,tree_order_statistics_node_update> ordered_set; _NEWLINE inline int add(int a,int b, int m=mod){a+=b;if(a>=m)a-=m;return a;} _NEWLINE inline int mul(int a,int b, int m=mod){return (int)(((ll)a*(ll)b)%m);} _NEWLINE ll expo(ll base,ll pow){ _NEWLINE  _INDENT  _INDENT ll ans = 1; _NEWLINE  _INDENT  _INDENT while(pow!=0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(pow&1==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = ans*base; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans = ans%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT base *= base; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT base%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pow/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE } _NEWLINE ll inv(ll x){ _NEWLINE  _INDENT  _INDENT return expo(x,mod-2); _NEWLINE } _NEWLINE int expFactor(int n, int p) _NEWLINE { _NEWLINE  _INDENT  _INDENT int x = p; _NEWLINE  _INDENT  _INDENT int exponent = 0; _NEWLINE  _INDENT  _INDENT while ((n/x) > 0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT exponent += n/x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x *= p; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return exponent; _NEWLINE } _NEWLINE inline int countsetbit(int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT unsigned int count = 0; _NEWLINE  _INDENT  _INDENT while (n) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT n &= (n-1) ; _NEWLINE  _INDENT  _INDENT  _INDENT count++; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return count; _NEWLINE } _NEWLINE inline int abs(int x){ _NEWLINE 	if(x<0) _NEWLINE 	return -x; _NEWLINE 	return x; _NEWLINE } _NEWLINE ll _sieve_size; _INDENT _NEWLINE bitset<10000010> bs; _INDENT _NEWLINE vector <int> primes; _INDENT _NEWLINE void sieve(ll upperbound) { _INDENT _NEWLINE 	_sieve_size = upperbound + 1; _INDENT _NEWLINE 	bs.set(); _NEWLINE 	bs[0] = bs[1] = 0; _NEWLINE 	for (ll i = 2; i <= _sieve_size; i++) _INDENT _NEWLINE 	if (bs[i]) { _NEWLINE 		for (ll j = i * i; j <= _sieve_size; j += i) _INDENT _NEWLINE 			bs[j] = 0; _NEWLINE 		primes.push_back((int)i); _INDENT _NEWLINE 	} _INDENT _NEWLINE } _INDENT _NEWLINE bool isPrime(ll N) { _NEWLINE if (N <= _sieve_size) return bs[N]; _INDENT _NEWLINE for (int i = 0; i < (int)primes.size(); i++) _NEWLINE if (N % primes[i] == 0) return false; _NEWLINE return true; _NEWLINE } _NEWLINE int n,m,val[MAX],wt[MAX];long double cv[MAX]; _NEWLINE bool ck(long double mi){ _NEWLINE 	forall(i,0,n-1){ _NEWLINE 		cv[i]=val[i]-mi*wt[i]; _NEWLINE 	} _NEWLINE 	sort(cv,cv+n,greater<long double>()); _NEWLINE 	long double tp=0; _NEWLINE 	forall(i,0,m-1){ _NEWLINE 		tp+=cv[i]; _NEWLINE 	} _NEWLINE 	return (tp>=0); _NEWLINE } _NEWLINE int main(){ _NEWLINE 	test{ _NEWLINE 		cin>>n>>m; _NEWLINE 		forall(i,0,n-1) _NEWLINE 		cin>>val[i]>>wt[i]; _NEWLINE 		long double lw=0,he=2e5,mi; _NEWLINE 		while(he-lw>(1e-8)){ _NEWLINE 			mi=(lw+he)/2.0; _NEWLINE 			if(ck(mi)){ _NEWLINE 				lw=mi; _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				he=mi; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		double as=(he+lw)/2.0; _NEWLINE 		printf("%.8lf\n",as); _NEWLINE 	} _NEWLINE } 
#include<bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE typedef long long ll; _NEWLINE int ar[17]; _NEWLINE ll dp[34000][1107]; _NEWLINE int DV, K; _NEWLINE int n = 0; _NEWLINE  _NEWLINE int c = 1; _NEWLINE ll _INDENT f(int idx, int bmsk, int modulo) { _NEWLINE  _NEWLINE 	if (idx == n) { _NEWLINE 		if (modulo == K) _NEWLINE 			return 1; _NEWLINE 		else _NEWLINE 			return 0; _NEWLINE 	} _NEWLINE 	if (dp[bmsk][modulo] != -1) _NEWLINE 		return dp[bmsk][modulo]; _NEWLINE  _NEWLINE 	ll ans = 0; _NEWLINE 	int xyar[10] = {0}; _NEWLINE  _NEWLINE 	for (int i = 0; i < n; i++) { _NEWLINE 		if ( (bmsk & (1 << i)) == 0) { _NEWLINE 			if (xyar[ar[i]] == 0) _INDENT _NEWLINE 			{ _NEWLINE 				//cout <<ar[i]<<"^^"<<endl; _NEWLINE 				//ll x = (modulo * 10 + ar[i]) % DV; _NEWLINE  _NEWLINE 				ans += f ( idx+1, bmsk | (1 << i), (modulo * 10 + ar[i])%DV); _NEWLINE 				xyar[ar[i]] = 1; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	dp[bmsk][modulo] = ans; _NEWLINE 	return ans; _NEWLINE  _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	memset(dp, -1LL, sizeof(dp)); _NEWLINE 	ll _INDENT num; _NEWLINE 	cin >> num >> DV >> K; _NEWLINE 	 _NEWLINE 	if (num == 0) { _NEWLINE 		if (K > 0) cout <<"0\n"; _NEWLINE 		else cout <<"1\n"; _NEWLINE 		return 0; _NEWLINE 	} _NEWLINE 	while (num > 0) { _NEWLINE 		ar[n] = num % 10; _NEWLINE 		num /= 10; _NEWLINE 		n++; _NEWLINE 	} _NEWLINE 	cout <<f(0,0,0)<<endl; _NEWLINE 	return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE typedef long long LL; _NEWLINE const int MAXN = 100000 + 10, K = 17, M = 1e9 + 7; _NEWLINE  _NEWLINE vector<int> G[MAXN]; _NEWLINE int dep[MAXN], f[MAXN][K + 1]; _NEWLINE int st[MAXN], ed[MAXN], loc[MAXN << 1]; _NEWLINE int n, m, P, dfn; _NEWLINE  _NEWLINE void dfs(int x, int par = -1) { _NEWLINE  _INDENT loc[st[x] = dfn++] = x; _NEWLINE  _INDENT for (int i = 1; i <= K; ++i) f[x][i] = f[f[x][i - 1]][i - 1]; _NEWLINE  _INDENT for (auto &y: G[x]) if (y != par) { _NEWLINE  _INDENT  _INDENT dep[y] = dep[f[y][0] = x] + 1; _NEWLINE  _INDENT  _INDENT dfs(y, x); _NEWLINE  _INDENT } _NEWLINE  _INDENT loc[ed[x] = dfn++] = x; _NEWLINE } _NEWLINE int lca(int x, int y) { _NEWLINE  _INDENT if (x == y) return x; _NEWLINE  _INDENT if (dep[x] < dep[y]) swap(x, y); _NEWLINE  _INDENT for (int i = K; ~i; --i) { _NEWLINE  _INDENT  _INDENT if (dep[f[x][i]] >= dep[y]) x = f[x][i]; _NEWLINE  _INDENT } _NEWLINE  _INDENT if (x == y) return x; _NEWLINE  _INDENT for (int i = K; ~i; --i) { _NEWLINE  _INDENT  _INDENT if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; _NEWLINE  _INDENT } _NEWLINE  _INDENT return f[x][0]; _NEWLINE } _NEWLINE  _NEWLINE int val[MAXN], inv[MAXN], vis[MAXN], sum; _NEWLINE int cnt[MAXN], mul[MAXN], ans[MAXN]; _NEWLINE void deal(int x) { _NEWLINE  _INDENT int c = val[x]; vis[x] ^= 1; _NEWLINE  _INDENT sum += M - mul[c]; if (sum >= M) sum -= M; _NEWLINE  _INDENT if (!vis[x]) { _NEWLINE  _INDENT  _INDENT mul[c] = 1ll * mul[c] * inv[c] % M; _NEWLINE  _INDENT  _INDENT if (--cnt[c] == 0) mul[c] = 0; _NEWLINE  _INDENT } _NEWLINE  _INDENT else { _NEWLINE  _INDENT  _INDENT if (++cnt[c] == 1) mul[c] = 1; _NEWLINE  _INDENT  _INDENT mul[c] = 1ll * mul[c] * c % M; _NEWLINE  _INDENT } _NEWLINE  _INDENT sum += mul[c]; if (sum >= M) sum -= M; _NEWLINE } _NEWLINE  _NEWLINE struct Node { _NEWLINE  _INDENT int l, r, z, id; _NEWLINE  _INDENT bool operator < (const Node &rhs) { _NEWLINE  _INDENT  _INDENT return l / P == rhs.l / P ? r < rhs.r : l / P < rhs.l / P; _NEWLINE  _INDENT } _NEWLINE } Q[MAXN]; _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT scanf("%d", &n); _NEWLINE  _INDENT for (int i = 1; i <= n; ++i) scanf("%d", val + i); _NEWLINE  _INDENT for (int i = 1; i < n; ++i) { _NEWLINE  _INDENT  _INDENT int u, v; scanf("%d%d", &u, &v); _NEWLINE  _INDENT  _INDENT G[u].push_back(v); _NEWLINE  _INDENT  _INDENT G[v].push_back(u); _NEWLINE  _INDENT } _NEWLINE  _INDENT dfs(dep[1] = 1); _NEWLINE  _INDENT P = sqrt(n * 2); _NEWLINE  _INDENT scanf("%d", &m); _NEWLINE  _INDENT for (int i = 0; i < m; ++i) { _NEWLINE  _INDENT  _INDENT int x, y; scanf("%d%d", &x, &y); _NEWLINE  _INDENT  _INDENT if (st[x] > st[y]) swap(x, y); _NEWLINE  _INDENT  _INDENT int z = lca(x, y); Q[i].id = i; _NEWLINE  _INDENT  _INDENT if (z == x) Q[i].l = st[x], Q[i].r = st[y]; _NEWLINE  _INDENT  _INDENT else Q[i].l = ed[x], Q[i].r = st[y], Q[i].z = z; _NEWLINE  _INDENT } _NEWLINE  _INDENT sort(Q, Q + m); _NEWLINE  _INDENT inv[1] = 1; sum = 0; _NEWLINE  _INDENT for (int i = 2; i < MAXN; ++i) { _NEWLINE  _INDENT  _INDENT inv[i] = LL(M - inv[M % i]) * (M / i) % M; _NEWLINE  _INDENT } _NEWLINE  _INDENT for (int i = 0, l = 0, r = -1; i < m; ++i) { _NEWLINE  _INDENT  _INDENT if (r < Q[i].r) { _NEWLINE  _INDENT  _INDENT  _INDENT for (++r; r <= Q[i].r; ++r) deal(loc[r]); _NEWLINE  _INDENT  _INDENT  _INDENT --r; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for (; r > Q[i].r; --r) deal(loc[r]); _NEWLINE  _INDENT  _INDENT for (; l < Q[i].l; ++l) deal(loc[l]); _NEWLINE  _INDENT  _INDENT if (l > Q[i].l) { _NEWLINE  _INDENT  _INDENT  _INDENT for (--l; l >= Q[i].l; --l) deal(loc[l]); _NEWLINE  _INDENT  _INDENT  _INDENT ++l; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if (Q[i].z) deal(Q[i].z); _NEWLINE  _INDENT  _INDENT ans[Q[i].id] = sum; _NEWLINE  _INDENT  _INDENT if (Q[i].z) deal(Q[i].z); _NEWLINE  _INDENT } _NEWLINE  _INDENT for (int i = 0; i < m; ++ i) printf("%d\n", ans[i]); _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
/*Author :rednivrug15 */ _NEWLINE #pragma comment(linker,"/STACK:5677216") _NEWLINE #include <bits/stdc++.h> _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define rep(i,n) for(int i=0; i<n ; i++) _NEWLINE using namespace std; _NEWLINE #define mod (int)((1e9)+7) _NEWLINE #define REP(i,n) for (int i = 1; i <= n; i++) _NEWLINE  _INDENT _NEWLINE long long power(long long a,long long b) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long ret=1; _NEWLINE  _INDENT  _INDENT while(b) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b%2==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret=(ret*a)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=(a*a)%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ret; _NEWLINE } _NEWLINE long long gcd(long long a,long long b) _NEWLINE { _NEWLINE  _INDENT  _INDENT return b==0?a:gcd(b,a%b); _NEWLINE } _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long L; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %lld",&n,&L); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vector < pair < long long, int > > coins(n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for( int i=0; i<n; i++ ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&coins[i].first); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT coins[i].second=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sort(coins.begin(),coins.end()); _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if( coins[0].first!=1 ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("-1\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT vector < long long > ans(n,0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bool flag=false; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long sum=0; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for( int i=0; i<n; ++i ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if( sum>=coins[i].first) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum += coins[i].first; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans[coins[i].second]++; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long remaining; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if( i!=n-1 ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT remaining=coins[i+1].first-sum-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT remaining=L-sum; _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if( remaining>0 ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans[coins[i].second] += (remaining+coins[i].first-1)/coins[i].first; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum += ((remaining+coins[i].first-1)/coins[i].first)*coins[i].first; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if( flag==true || sum>L) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT puts("-1"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for( int i=0; i<n; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld ",ans[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT puts(""); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  int N,K ; _NEWLINE  _INDENT  cin >> N >> K ; _NEWLINE  _INDENT  int A[1001] ; _NEWLINE  _INDENT  for(int i=0 ; i<N ; i++){ _NEWLINE 	 _INDENT  cin >> A[i] ; _NEWLINE  _INDENT  } _NEWLINE  _INDENT  sort(A,A+N) ; _NEWLINE  _INDENT  cout << A[K-1] ; _NEWLINE } _NEWLINE  _NEWLINE 
/* Author: Karlheinz Jung */ _NEWLINE /* Compiler: Borland Turbo C 2.01 */ _NEWLINE /* Computer: Rabbit 286 */ _NEWLINE /* Problem: Spiral Chess (SC) */ _NEWLINE  _NEWLINE #include <stdio.h> _NEWLINE  _NEWLINE #ifndef ONLINE_JUDGE _NEWLINE 	#define siz 10 _NEWLINE #else _NEWLINE 	#define siz 110 _NEWLINE #endif _NEWLINE #define MI(a,b) a<b?a:b _NEWLINE  _NEWLINE int N, Q; _NEWLINE int grid[siz][siz], qBlack[siz][siz], qWhite[siz][siz]; _NEWLINE int dir[][2]= {{0,1},{1,0},{0,-1},{-1,0}}; _NEWLINE  _NEWLINE int bQuery(int r1, int c1, int r2, int c2) _NEWLINE { _NEWLINE return qBlack[r1][c1]-qBlack[r1][c2+1]-qBlack[r2+1][c1]+qBlack[r2+1][c2+1]; _NEWLINE } _NEWLINE  _NEWLINE int wQuery(int r1, int c1, int r2, int c2) _NEWLINE { _NEWLINE return qWhite[r1][c1]-qWhite[r1][c2+1]-qWhite[r2+1][c1]+qWhite[r2+1][c2+1]; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE int T, total, caseID=1, i, j, k, curDir, ii, jj, blackSum, whiteSum, r1, c1, r2, c2, sol1, sol2; _NEWLINE  _NEWLINE for(scanf("%d",&T); caseID<=T; caseID++) _NEWLINE 	{ _NEWLINE 	scanf("%d", &N); _NEWLINE 	total=N*N; _NEWLINE 	i=j=curDir=0; _NEWLINE 	memset(grid, -1, sizeof grid); _NEWLINE 	for(k=0; k<total; k++) _NEWLINE 		{ _NEWLINE 		scanf("%d",&grid[i][j]); _NEWLINE 		ii=i+dir[curDir][0]; _NEWLINE 		jj=j+dir[curDir][1]; _NEWLINE 		if(ii<0||ii>=N||jj<0||jj>=N||grid[ii][jj]!=-1) curDir=(curDir+1)%4; _NEWLINE 		i+=dir[curDir][0]; _NEWLINE 		j+=dir[curDir][1]; _NEWLINE 		} _NEWLINE 	memset(qBlack,0,sizeof(qBlack)); _NEWLINE 	memset(qWhite,0,sizeof(qWhite)); _NEWLINE 	for(i=N-1; i>=0; i--) _NEWLINE 		{ _NEWLINE 		blackSum=whiteSum=0; _NEWLINE 		for(j=N-1; j>=0; j--) _NEWLINE 			{ _NEWLINE 			if((i+j)%2) _NEWLINE 				blackSum+=grid[i][j]; _NEWLINE 			else _NEWLINE 				whiteSum+=grid[i][j]; _NEWLINE 			qBlack[i][j]=i==N-1?blackSum:qBlack[i+1][j]+blackSum; _NEWLINE 			qWhite[i][j]=i==N-1?whiteSum:qWhite[i+1][j]+whiteSum; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	scanf("%d",&Q); _NEWLINE 	printf("Case #%d:\n", caseID); _NEWLINE 	for(k=0; k<Q; k++) _NEWLINE 		{ _NEWLINE 		scanf("%d %d %d %d",&r1,&c1,&r2,&c2); _NEWLINE 		sol1=wQuery(r1,c1,r2,c2); _NEWLINE 		sol2=bQuery(r1,c1,r2,c2); _NEWLINE 		printf("%d\n",MI(sol1,sol2)); _NEWLINE 		} _NEWLINE 	printf("\n"); _NEWLINE 	} _NEWLINE return 0; _NEWLINE } _NEWLINE 
n=input() _NEWLINE s=map(int,raw_input().split()) _NEWLINE s.sort(reverse=True) _NEWLINE print s[0],s[1]
#include<stdio.h> _NEWLINE #define mod 1000000009 _NEWLINE void scanlong(unsigned long long &x){ _NEWLINE  _INDENT  _INDENT char c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT x = 0; _NEWLINE  _INDENT  _INDENT while(c<'0'||c>'9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(c>='0'&&c<='9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x= (x<<1)+ (x<<3) + c - '0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE void scanint(int &x){ _NEWLINE  _INDENT  _INDENT char c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT x = 0; _NEWLINE  _INDENT  _INDENT while(c<'0'||c>'9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(c>='0'&&c<='9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x= (x<<1)+ (x<<3) + c - '0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE unsigned long long a[3][3]={{0,0,1},{1,0,1},{0,1,0}}; _NEWLINE void power(unsigned long long b){ _NEWLINE  _INDENT  _INDENT unsigned long long c[3][3]; _NEWLINE  _INDENT  _INDENT for(int i=0;i<3;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<3;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c[i][j]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c[i][i]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(b){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b&1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT unsigned long long temp[3][3]={0}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<3;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<3;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int k=0;k<3;k++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp[i][j]+=(a[i][k]*c[k][j])%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp[i][j]%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<3;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<3;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c[i][j]=temp[i][j]; _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT unsigned long long temp[3][3]={0}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<3;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<3;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int k=0;k<3;k++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp[i][j]+=(a[i][k]*a[k][j])%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp[i][j]%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<3;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<3;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=temp[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b>>=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0;i<3;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<3;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j] =c[i][j]; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanint(t); _NEWLINE  _INDENT  _INDENT int f[5]={0,0,1,1,1}; _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[0][0]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[0][1]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[0][2]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[1][0]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[1][1]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[1][2]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[2][0]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[2][1]=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[2][2]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT unsigned long long n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanlong(n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(n<5){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",f[n]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT unsigned long long c[3][3]={{0,0,1},{0,1,1},{1,1,1}}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT power(n-4); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT unsigned long long ans = (c[2][0] * a[0][2])%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=(c[2][1] * a[1][2])%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=(c[2][2]*a[2][2])%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%llu\n",ans%mod); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE }
# your code goes here _NEWLINE from math import ceil, log _NEWLINE from sys import stdin, stdout _NEWLINE st = [] _NEWLINE def getMid(s, e): _NEWLINE 	return s + (e-s) / 2 _NEWLINE  _NEWLINE def construct(st, arr, ss, se, si, type): _NEWLINE 	if se == ss: _NEWLINE 		if se%2 == type: _NEWLINE 			st[si] = arr[ss] _NEWLINE 		else: _NEWLINE 			st[si] = 0 _NEWLINE 		return st[si] _NEWLINE 	m = getMid(ss, se) _NEWLINE 	st[si] = max(construct(st, arr, ss, m, si*2+1, type), construct(st, arr, m+1, se, si*2 + 2, type)) _NEWLINE 	return st[si] _NEWLINE 		 _NEWLINE def createSegTree(arr, type): _NEWLINE 	st = [0] * (2 * (pow(2, int(ceil(log(len(arr))/log(2)))) - 1)) _NEWLINE 	construct(st, arr, 0, len(arr)-1, 0, type) _NEWLINE 	return st _NEWLINE 	 _NEWLINE def getMaxUtil(st, ss, se, qs, qe, si): _NEWLINE 	if qs <= ss and qe >= se: _NEWLINE 		return st[si]; _NEWLINE 	if se < qs or ss > qe: _NEWLINE 		return 0 _NEWLINE 	mid = getMid(ss, se) _NEWLINE 	return max(getMaxUtil(st, ss, mid, qs, qe, 2 * si + 1), _NEWLINE  _INDENT  _INDENT getMaxUtil(st, mid + 1, se, qs, qe, 2 * si + 2)) _NEWLINE  _NEWLINE def getMax(st, n, qs, qe): _NEWLINE 	if qs < 0 or qe > n-1 or qs > qe: _NEWLINE 		return -1 _NEWLINE 	return getMaxUtil(st, 0, n-1, qs, qe, 0) _NEWLINE 	 _NEWLINE def updateUtil(st, ss, se, pos, val, si, type): _NEWLINE 	if pos < ss or pos > se: _NEWLINE 		return _NEWLINE 	if ss == se: _NEWLINE 		if pos%2 == type: _NEWLINE 			st[si] = val _NEWLINE 		return _NEWLINE 	mid = getMid(ss, se) _NEWLINE 	updateUtil(st, ss, mid, pos, val, 2*si+1, type) _NEWLINE 	updateUtil(st, mid+1, se, pos, val, 2*si+2, type) _NEWLINE 	st[si] = max(st[2*si+1], st[2*si+2]) _NEWLINE 	 _NEWLINE def update(st, n, pos, val, type): _NEWLINE 	updateUtil(st, 0, n-1, pos, val, 0, type) _NEWLINE 	 _NEWLINE n, q = map(int, stdin.readline().strip().split(' ')) _NEWLINE arr = map(int, stdin.readline().strip().split(' ')) _NEWLINE odd = createSegTree(arr, 1) _NEWLINE even = createSegTree(arr, 0) _NEWLINE while q: _NEWLINE 	q -= 1 _NEWLINE 	c, l, r = map(int, stdin.readline().strip().split(' ')) _NEWLINE 	if c == 1: _NEWLINE 		update(odd, n, l-1, r, 1) _NEWLINE 		update(even, n, l-1, r, 0) _NEWLINE 	else: _NEWLINE 		stdout.write(str(getMax(odd, n, l-1, r-1) + getMax(even, n, l-1, r-1)) + "\n")
/* _NEWLINE  * _INDENT p.cpp _NEWLINE  * _INDENT Created on: Aug 1, 2016 _NEWLINE  * _INDENT Author: Tarun Anand _NEWLINE  * _INDENT Copyright (c) 2016 Tarun Anand. All rights reserved. _NEWLINE  */ _NEWLINE #include<bits/stdc++.h> _NEWLINE #include<sstream> _NEWLINE using namespace std; _NEWLINE #define mod 1000000007 _NEWLINE #define all(v) v.begin(),v.end() _NEWLINE #define loop(i,a,b) for(i=a;i<b;i++) _NEWLINE #define revloop(i,a,b) for(i=a;i>=b;i--) _NEWLINE #define stloop(it,v) for(it=v.begin();it!=v.end();++it) _NEWLINE #define ii pair<int,int> _NEWLINE #define MP make_pair _NEWLINE #define pb push_back _NEWLINE #define ll long long int _NEWLINE #define fill(v,d) memset(v,d,sizeof(v)) _NEWLINE #define c 100000 _NEWLINE int main() _NEWLINE { _INDENT std::ios::sync_with_stdio(false); _NEWLINE  _INDENT  cin.tie(0); _NEWLINE  _INDENT  ll t,i,n; _NEWLINE  _INDENT  cin>>t; _NEWLINE  _INDENT  while(t--) _NEWLINE  _INDENT  { cin>>n; _NEWLINE  _INDENT  _INDENT  cout<<2*n-1<<endl; _NEWLINE  _INDENT  } _NEWLINE  _INDENT  return 0; _NEWLINE } _NEWLINE 
for i in xrange(input()): _NEWLINE  _INDENT  _INDENT  N=input() _NEWLINE  _INDENT  _INDENT  c=1 _NEWLINE  _INDENT  _INDENT  S=2 _NEWLINE  _INDENT  _INDENT  while c<N: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c%2!=0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  S=(S*2)-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  S=(S*2)+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=1 _NEWLINE  _INDENT  _INDENT  print S _NEWLINE 
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define all(X) (X).begin(),(X).end() _NEWLINE #define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) _NEWLINE  _NEWLINE int T,N,i; _NEWLINE long double A,D,t[10111],st[10111],Mv[10111]; _NEWLINE long double EPS = 1e-6; _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT scanf("%d",&T); _NEWLINE  _INDENT  _INDENT while(T--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %Lf %Lf",&N,&A,&D); _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<N;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%Lf %Lf",st+i,Mv+i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long double Sin = (Mv[i] * Mv[i]) / (2*A); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(Sin + EPS >= D) _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t[i] = st[i] + sqrtl((2*D)/A); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long double tin = Mv[i] / A; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long double ta = (D - Sin) / Mv[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t[i] = tin + ta + st[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<N;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t[i] = max(t[i],t[i-1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<N;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%Lf\n",t[i]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _INDENT  _INDENT  _NEWLINE 
#include<bits/stdc++.h> _NEWLINE #define s(a) scanf("%lld",&a) _NEWLINE using namespace std; _NEWLINE typedef long long int LLD; _NEWLINE LLD t,n,m,a1,a2,b1,b2,MOD; _NEWLINE LLD p1[303][303],p2[303][303]; _NEWLINE LLD modulo(LLD a,LLD b,LLD c){ _NEWLINE  _INDENT  _INDENT LLD x=1,y=a; // long long is taken to avoid overflow of intermediate results _NEWLINE  _INDENT  _INDENT while(b > 0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b%2 == 1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=(x*y)%c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = (y*y)%c; // squaring the base _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b /= 2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x%c; _NEWLINE } _NEWLINE inline LLD modexp(LLD a,LLD b) _NEWLINE { _NEWLINE 	LLD ans=1; _NEWLINE 	while(b) _NEWLINE 	{ _NEWLINE 		if(b&1) _NEWLINE 		{ _NEWLINE 			ans=(ans*a)%MOD; _NEWLINE 			b--; _NEWLINE 		} _NEWLINE 		a = (a*a)%MOD; _NEWLINE 		b=b/2; _NEWLINE 	} _INDENT  _NEWLINE 	return ans%MOD; _NEWLINE } _NEWLINE LLD rowmax[303],colmax[303]; _NEWLINE LLD rvalue[303][303]; _NEWLINE int main() _NEWLINE { _NEWLINE 	s(t); _NEWLINE 	LLD i,j; _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		s(n); _NEWLINE 		s(m); _NEWLINE 		s(a1);s(a2);s(b1);s(b2);s(MOD); _NEWLINE 		for(i=1;i<=n;i++) _NEWLINE 		for(j=1;j<=m;j++) _NEWLINE 		{ _NEWLINE 			rvalue[i][j]=0; _NEWLINE 			p1[i][j]=modulo((a1*i+a2*j)%MOD,(MOD-2),MOD); _NEWLINE 			p2[i][j]=modulo((b2*i+b1*j)%MOD,(MOD-2),MOD);	 _NEWLINE 		} _NEWLINE 		LLD temp; _NEWLINE 		for(i=1;i<=n;i++) _NEWLINE 		{ _NEWLINE 			temp=-1; _NEWLINE 			for(j=1;j<=m;j++) _NEWLINE 				if(p2[i][j]>temp) _NEWLINE 					temp=p2[i][j]; _NEWLINE 			for(j=1;j<=m;j++) _NEWLINE 				if(p2[i][j]==temp) rvalue[i][j]++; _NEWLINE 		} _NEWLINE 		for(i=1;i<=m;i++) _NEWLINE 		{ _NEWLINE 			temp=-1; _NEWLINE 			for(j=1;j<=n;j++) _NEWLINE 				if(p1[j][i]>temp) _NEWLINE 					temp=p1[j][i]; _NEWLINE 			for(j=1;j<=n;j++) _NEWLINE 				if(p1[j][i]==temp) rvalue[j][i]++; _NEWLINE 		} _NEWLINE 		bool flag = 0; _NEWLINE 		vector<pair<int,int> > v; _NEWLINE 		int row[303]={0},col[303]={0}; _NEWLINE 		for(i=1;i<=n;i++) _NEWLINE 		for(j=1;j<=m;j++) _NEWLINE 		{ _NEWLINE 			if(!flag && rvalue[i][j]==2) _NEWLINE 			{ _NEWLINE 				cout<<i<<" "<<j<<endl; _NEWLINE 				flag=1; _NEWLINE 				i=n;break; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(!flag)printf("-1\n"); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import java.io.*; _NEWLINE import java.math.*; _NEWLINE import java.util.*; _NEWLINE import java.lang.*; _NEWLINE  _INDENT _NEWLINE class Main2{ _INDENT _NEWLINE  _INDENT _NEWLINE 	public static InputStream inputStream = System.in; _NEWLINE 	public static OutputStream outputStream = System.out; _NEWLINE 	public static FastReader in = new FastReader(inputStream); _NEWLINE 	public static PrintWriter out = new PrintWriter(outputStream); _NEWLINE  _INDENT _NEWLINE 	public static void main(String[] args)throws java.lang.Exception{ _NEWLINE 		new Main2().run(); _NEWLINE 		out.close(); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	long MOD = 1000000003; _NEWLINE 	 _NEWLINE 	boolean[] flag; _NEWLINE 	int comps = 0; _NEWLINE 	ArrayList<Integer>[] graph; _NEWLINE 	int n; _NEWLINE 	long[][] memo; _NEWLINE 	 _NEWLINE 	void run()throws RuntimeException{ _NEWLINE 		int t = in.nextInt(); _NEWLINE 		for(int i=0; i<t; i++){ _NEWLINE 			n = in.nextInt(); _NEWLINE 			int m = in.nextInt(); _NEWLINE 			graph = new ArrayList[n]; _NEWLINE 			for(int j=0; j<n; j++){ _NEWLINE 				graph[j] = new ArrayList<Integer>(); _NEWLINE 			} _NEWLINE 			for(int j=0; j<m; j++){ _NEWLINE 				int a = in.nextInt(); _NEWLINE 				int b = in.nextInt(); _NEWLINE 				graph[a].add(b-n); _NEWLINE 			} _NEWLINE 			int mask = (int)Math.pow(2, n)-1; _NEWLINE 			memo = new long[n][(int)Math.pow(2, n)]; _NEWLINE 			for(int j=0; j<memo.length; j++){ _NEWLINE 				Arrays.fill(memo[j], -1); _NEWLINE 			} _NEWLINE 			out.println(ways(0, mask)); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	 _NEWLINE 	long ways(int start, int mask){ _NEWLINE //		System.out.println("called " + start + " " + Integer.toBinaryString(mask)); _NEWLINE 		if(start==n){ _NEWLINE 			return 1; _NEWLINE 		} _NEWLINE 		if(mask==0){ _NEWLINE //			System.out.println("edge 0"); _NEWLINE 			return 0; _NEWLINE 		} _NEWLINE 		if(memo[start][mask] != -1){ _NEWLINE 			return memo[start][mask]; _NEWLINE 		} _NEWLINE 		long ans = 0; _NEWLINE 		for(Integer to : graph[start]){ _NEWLINE 			if((mask&(1<<to)) != 0){ // If girl can be taken _NEWLINE //				System.out.println("taken " + to); _NEWLINE 				int newMask = (mask ^ (1 << to)); _INDENT // take girl _NEWLINE 				ans += ways(start+1, newMask); _INDENT // num ways _NEWLINE 				ans %= 1000000003; _NEWLINE 			} _NEWLINE 		} _NEWLINE //		System.out.println("returning " + ans); _NEWLINE 		memo[start][mask] = ans; _NEWLINE 		return ans; _NEWLINE 	} _NEWLINE } _NEWLINE  _INDENT _NEWLINE class FastReader{ _NEWLINE 	private boolean finished = false; _NEWLINE  _INDENT _NEWLINE 	private InputStream stream; _NEWLINE 	private byte[] buf = new byte[1024]; _NEWLINE 	private int curChar; _NEWLINE 	private int numChars; _NEWLINE 	private SpaceCharFilter filter; _NEWLINE  _INDENT _NEWLINE 	public FastReader(InputStream stream){ _NEWLINE 		this.stream = stream; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public int read(){ _NEWLINE 		if (numChars == -1){ _NEWLINE 			throw new InputMismatchException (); _NEWLINE 		} _NEWLINE 		if (curChar >= numChars){ _NEWLINE 			curChar = 0; _NEWLINE 			try{ _NEWLINE 				numChars = stream.read (buf); _NEWLINE 			} catch (IOException e){ _NEWLINE 				throw new InputMismatchException (); _NEWLINE 			} _NEWLINE 			if (numChars <= 0){ _NEWLINE 				return -1; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return buf[curChar++]; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public int peek(){ _NEWLINE 		if (numChars == -1){ _NEWLINE 			return -1; _NEWLINE 		} _NEWLINE 		if (curChar >= numChars){ _NEWLINE 			curChar = 0; _NEWLINE 			try{ _NEWLINE 				numChars = stream.read (buf); _NEWLINE 			} catch (IOException e){ _NEWLINE 				return -1; _NEWLINE 			} _NEWLINE 			if (numChars <= 0){ _NEWLINE 				return -1; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return buf[curChar]; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public int nextInt(){ _NEWLINE 		int c = read (); _NEWLINE 		while (isSpaceChar (c)) _NEWLINE 			c = read (); _NEWLINE 		int sgn = 1; _NEWLINE 		if (c == '-'){ _NEWLINE 			sgn = -1; _NEWLINE 			c = read (); _NEWLINE 		} _NEWLINE 		int res = 0; _NEWLINE 		do{ _NEWLINE 			if(c==','){ _NEWLINE 				c = read(); _NEWLINE 			} _NEWLINE 			if (c < '0' || c > '9'){ _NEWLINE 				throw new InputMismatchException (); _NEWLINE 			} _NEWLINE 			res *= 10; _NEWLINE 			res += c - '0'; _NEWLINE 			c = read (); _NEWLINE 		} while (!isSpaceChar (c)); _NEWLINE 		return res * sgn; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public long nextLong(){ _NEWLINE 		int c = read (); _NEWLINE 		while (isSpaceChar (c)) _NEWLINE 			c = read (); _NEWLINE 		int sgn = 1; _NEWLINE 		if (c == '-'){ _NEWLINE 			sgn = -1; _NEWLINE 			c = read (); _NEWLINE 		} _NEWLINE 		long res = 0; _NEWLINE 		do{ _NEWLINE 			if (c < '0' || c > '9'){ _NEWLINE 				throw new InputMismatchException (); _NEWLINE 			} _NEWLINE 			res *= 10; _NEWLINE 			res += c - '0'; _NEWLINE 			c = read (); _NEWLINE 		} while (!isSpaceChar (c)); _NEWLINE 		return res * sgn; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public String nextString(){ _NEWLINE 		int c = read (); _NEWLINE 		while (isSpaceChar (c)) _NEWLINE 			c = read (); _NEWLINE 		StringBuilder res = new StringBuilder (); _NEWLINE 		do{ _NEWLINE 			res.appendCodePoint (c); _NEWLINE 			c = read (); _NEWLINE 		} while (!isSpaceChar (c)); _NEWLINE 		return res.toString (); _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public boolean isSpaceChar(int c){ _NEWLINE 		if (filter != null){ _NEWLINE 			return filter.isSpaceChar (c); _NEWLINE 		} _NEWLINE 		return isWhitespace (c); _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public static boolean isWhitespace(int c){ _NEWLINE 		return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	private String readLine0(){ _NEWLINE 		StringBuilder buf = new StringBuilder (); _NEWLINE 		int c = read (); _NEWLINE 		while (c != '\n' && c != -1){ _NEWLINE 			if (c != '\r'){ _NEWLINE 				buf.appendCodePoint (c); _NEWLINE 			} _NEWLINE 			c = read (); _NEWLINE 		} _NEWLINE 		return buf.toString (); _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public String nextLine(){ _NEWLINE 		String s = readLine0 (); _NEWLINE 		while (s.trim ().length () == 0) _NEWLINE 			s = readLine0 (); _NEWLINE 		return s; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public String nextLine(boolean ignoreEmptyLines){ _NEWLINE 		if (ignoreEmptyLines){ _NEWLINE 			return nextLine (); _NEWLINE 		}else{ _NEWLINE 			return readLine0 (); _NEWLINE 		} _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public BigInteger nextBigInteger(){ _NEWLINE 		try{ _NEWLINE 			return new BigInteger (nextString ()); _NEWLINE 		} catch (NumberFormatException e){ _NEWLINE 			throw new InputMismatchException (); _NEWLINE 		} _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public char nextCharacter(){ _NEWLINE 		int c = read (); _NEWLINE 		while (isSpaceChar (c)) _NEWLINE 			c = read (); _NEWLINE 		return (char) c; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public double nextDouble(){ _NEWLINE 		int c = read (); _NEWLINE 		while (isSpaceChar (c)) _NEWLINE 			c = read (); _NEWLINE 		int sgn = 1; _NEWLINE 		if (c == '-'){ _NEWLINE 			sgn = -1; _NEWLINE 			c = read (); _NEWLINE 		} _NEWLINE 		double res = 0; _NEWLINE 		while (!isSpaceChar (c) && c != '.'){ _NEWLINE 			if (c == 'e' || c == 'E'){ _NEWLINE 				return res * Math.pow (10, nextInt ()); _NEWLINE 			} _NEWLINE 			if (c < '0' || c > '9'){ _NEWLINE 				throw new InputMismatchException (); _NEWLINE 			} _NEWLINE 			res *= 10; _NEWLINE 			res += c - '0'; _NEWLINE 			c = read (); _NEWLINE 		} _NEWLINE 		if (c == '.'){ _NEWLINE 			c = read (); _NEWLINE 			double m = 1; _NEWLINE 			while (!isSpaceChar (c)){ _NEWLINE 				if (c == 'e' || c == 'E'){ _NEWLINE 					return res * Math.pow (10, nextInt ()); _NEWLINE 				} _NEWLINE 				if (c < '0' || c > '9'){ _NEWLINE 					throw new InputMismatchException (); _NEWLINE 				} _NEWLINE 				m /= 10; _NEWLINE 				res += (c - '0') * m; _NEWLINE 				c = read (); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		return res * sgn; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public boolean isExhausted(){ _NEWLINE 		int value; _NEWLINE 		while (isSpaceChar (value = peek ()) && value != -1) _NEWLINE 			read (); _NEWLINE 		return value == -1; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public String next(){ _NEWLINE 		return nextString (); _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public SpaceCharFilter getFilter(){ _NEWLINE 		return filter; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public void setFilter(SpaceCharFilter filter){ _NEWLINE 		this.filter = filter; _NEWLINE 	} _NEWLINE  _INDENT _NEWLINE 	public interface SpaceCharFilter{ _NEWLINE 		public boolean isSpaceChar(int ch); _NEWLINE 	} _NEWLINE } 
#include<iostream> _NEWLINE #include<cassert> _NEWLINE #include<cstdlib> _NEWLINE #include<cstring> _NEWLINE #include<utility> _NEWLINE #include<sstream> _NEWLINE #include<algorithm> _NEWLINE #include<cstdio> _NEWLINE #include<vector> _NEWLINE #include<string> _NEWLINE #include<cctype> _NEWLINE #include<queue> _NEWLINE #include<deque> _NEWLINE #include<stack> _NEWLINE #include<cmath> _NEWLINE #include<ctime> _NEWLINE #include<list> _NEWLINE #include<map> _NEWLINE #include<set> _NEWLINE #define pi (acos(-1.0)) _NEWLINE #define Abs(a) (((a)<0) ? (-(a)) :(a) ) _NEWLINE #define rep(i,n) for((i)=0;(i)<(n);(i)++) _NEWLINE #define Rep(i,n) for(int i=0;i<(n);i++) _NEWLINE #define Rrep(i,n) for(int i=n-1;i>=0;i--) _NEWLINE #define rrep(i,n) for((i)=(n)-1;(i)>=0;(i)--) _NEWLINE #define Pii pair<int,int> _NEWLINE #define PB push_back _NEWLINE #define Size(x) ((int)(x.size())) _NEWLINE #define MIN(a,b) ((a)<(b) ? (a):(b)) _NEWLINE #define MAX(a,b) ((a)>(b) ? (a):(b)) _NEWLINE using namespace std; _NEWLINE typedef long long mint; _NEWLINE typedef unsigned long long umint; _NEWLINE char a[5001],b[5001]; _NEWLINE int d[2][2][5005][5005]; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT //freopen("in.txt","r",stdin); _NEWLINE  _INDENT  _INDENT int t,T,sa,sb,k,mx,ka,kb; _NEWLINE  _INDENT  _INDENT int i,j; _NEWLINE  _INDENT  _INDENT scanf("%d",&T); _NEWLINE  _INDENT  _INDENT for(t=1; t<=T; t++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d%d",&sa,&sb,&k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%s%s",a,b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(k>min(sa,sb)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT puts("-1"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep(ka,2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT rep(kb,2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0; i<=sa; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=0; j<=sb; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ka*k>i||kb*k>j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[ka][kb][i][j]=-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[ka][kb][i][j]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(i==0||j==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i-1]==b[j-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<"oria "<<d[ka][kb][i-1][j-1]<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[ka][kb][i][j]=MAX(d[ka][kb][i][j],(d[ka][kb][i-1][j-1]+1)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[ka][kb][i][j-1]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[ka][kb][i-1][j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ka) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[0][kb][i-k][j]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(kb) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[ka][0][i][j-k]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(ka&&kb) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d[ka][kb][i][j]=MAX(d[ka][kb][i][j],d[0][0][i-k][j-k]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT //cout<<ka<<" "<<kb<<" "<<i<<" "<<j<<" "<<d[ka][kb][i][j]<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //cout<<d[1][1][sa][sb]<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",MAX(0,d[1][1][sa][sb])); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE 
#include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <vector> _NEWLINE #include <cstring> _NEWLINE #include <string> _NEWLINE #include <cmath> _NEWLINE #include <ctime> _NEWLINE #include <utility> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <stack> _NEWLINE #include <sstream> _NEWLINE #define FOR(a,b,c) for (int a=b,_c=c;a<=_c;a++) _NEWLINE #define FORD(a,b,c) for (int a=b;a>=c;a--) _NEWLINE #define REP(i,a) for(int i=0,_a=(a); i<_a; ++i) _NEWLINE #define REPD(i,a) for(int i=(a)-1; i>=0; --i) _NEWLINE #define pb push_back _NEWLINE #define mp make_pair _NEWLINE #define fi first _NEWLINE #define se second _NEWLINE #define sz(a) int(a.size()) _NEWLINE #define reset(a,b) memset(a,b,sizeof(a)) _NEWLINE #define oo 1000000000000000007ll _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef pair<int, int> pii; _NEWLINE typedef pair<ll, int > plli; _NEWLINE  _NEWLINE const int maxn = 100007; _NEWLINE  _NEWLINE  _NEWLINE int main() { _NEWLINE 	//freopen("test.txt","r",stdin); _NEWLINE  _NEWLINE 	int qr; _NEWLINE  _NEWLINE 	cin >> qr; _NEWLINE  _NEWLINE 	for (int i1 = 0; i1 < qr; ++i1) { _NEWLINE 		set<plli> myset; _NEWLINE 		vector<pii> a[maxn]; _NEWLINE 		vector<int> list; _NEWLINE 		bool free1[maxn]; _NEWLINE 		int n, m, t, trace[maxn]; _NEWLINE 		ll d[maxn]; _NEWLINE  _NEWLINE 		scanf("%d%d%d", &n, &m, &t); _NEWLINE 		int u, v, w; _NEWLINE 		REP(i, m) { _NEWLINE 			scanf("%d%d%d", &u, &v, &w); _NEWLINE 			a[u].pb(pii(v, w)); _NEWLINE 			a[v].pb(pii(u, w)); _NEWLINE 		} _NEWLINE  _NEWLINE 		for (int i2 = 0; i2 < t; ++i2) { _NEWLINE 			int rr; _NEWLINE 			cin >> rr; _NEWLINE 			reset(free1, 1); _NEWLINE 			d[1] = 0; _NEWLINE 			FOR(i, 2, n) d[i] = oo; _NEWLINE 			myset.insert(pii(0, 1)); _NEWLINE 			while (!myset.empty()) { _NEWLINE 				u = myset.begin()->se; myset.erase(myset.begin()); _NEWLINE 				free1[u] = 0; _NEWLINE 				REP(i, sz(a[u])) { _NEWLINE 					v = a[u][i].fi; w = a[u][i].se; _NEWLINE 					if (free1[v] && d[v]>d[u] + w) { _NEWLINE 						if (d[v] != oo) myset.erase(myset.find(plli(d[v], v))); _NEWLINE 						d[v] = d[u] + w; _NEWLINE 						trace[v] = u; _NEWLINE 						myset.insert(plli(d[v], v)); _NEWLINE 					} _NEWLINE 				} _NEWLINE 			} _NEWLINE  _NEWLINE 			if (d[rr] == oo) printf("-1\n"); _NEWLINE 			else { _NEWLINE 				cout << d[rr] << endl; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	 _NEWLINE 	//getch(); _NEWLINE 	return 0; _NEWLINE }
import sys _NEWLINE  _NEWLINE  _NEWLINE def euler_phi(x): _NEWLINE  _INDENT  _INDENT i = 2 _NEWLINE  _INDENT  _INDENT factors = set([]) _NEWLINE  _INDENT  _INDENT ret = x _NEWLINE  _INDENT  _INDENT while(i<=x): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (x%i == 0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT factors.add(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = x / i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = 2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = i + 1 _NEWLINE  _INDENT  _INDENT #print factors _NEWLINE  _INDENT  _INDENT for factor in factors: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ret = (ret * (factor-1)) / factor _NEWLINE  _INDENT  _INDENT return ret _NEWLINE  _NEWLINE t _INDENT = int(sys.stdin.readline()) _NEWLINE for i in range(0,t): _NEWLINE  _INDENT  _INDENT n = int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT print euler_phi(n)
import sys _NEWLINE  _NEWLINE def main(): _NEWLINE  _NEWLINE  _INDENT  _INDENT store={'one':1, 'two':2, 'three':3, 'four': 4, 'five' : 5, 'six' : 6, _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  'seven' : 7, 'eight' : 8, 'nine' : 9, 'zero' : 0} _NEWLINE  _NEWLINE  _INDENT  _INDENT array=['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  'nine', 'zero'] _NEWLINE  _NEWLINE  _INDENT  _INDENT t=int(sys.stdin.readline()) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in range(t): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT word=raw_input().strip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT expected=len(word)-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in array: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if len(word)==len(j): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT match=sum(a==b for a, b in zip(j, word)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if match==expected: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print store[j] _NEWLINE main() _NEWLINE 
#include<iostream> _NEWLINE #include<cstdio> _NEWLINE #include<vector> _NEWLINE #include<algorithm> _NEWLINE #define mod 1000000007 _NEWLINE void scanint(int &x){ _NEWLINE  _INDENT  _INDENT char c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT x = 0; _NEWLINE  _INDENT  _INDENT while(c<'0'||c>'9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(c>='0'&&c<='9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x= (x<<1)+ (x<<3) + c - '0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT unsigned long long a[105][105]={0}; _NEWLINE  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT scanint(n); _NEWLINE  _INDENT  _INDENT n*=n; _NEWLINE  _INDENT  _INDENT for(int i=1;i<n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[i][i+1]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int q; _NEWLINE  _INDENT  _INDENT scanint(q); _NEWLINE  _INDENT  _INDENT while(q--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x,y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanint(x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanint(y); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[x][y]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int k; _NEWLINE  _INDENT  _INDENT scanint(k); _NEWLINE  _INDENT  _INDENT unsigned long long iden[101][101]={0}; _NEWLINE  _INDENT  _INDENT for(int i=0;i<101;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT iden[i][i]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(k){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(k&1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT unsigned long long temp[101][101]={0}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=1;j<=n;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int k=1;k<=n;k++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp[i][j]+=a[i][k]*iden[k][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp[i][j]%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=1;j<=n;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT iden[i][j]=temp[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT unsigned long long temp[101][101]={0}; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=1;j<=n;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int k=1;k<=n;k++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp[i][j]+=a[i][k]*a[k][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp[i][j]%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int j=1;j<=n;j++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i][j]=temp[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k>>=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT printf("%llu",iden[1][n]%mod); _NEWLINE } _NEWLINE 
x=input("") _NEWLINE y=raw_input("") _NEWLINE count=0 _NEWLINE for i in y: _NEWLINE  _INDENT  _INDENT if i==".": _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE print count _NEWLINE 
def fun(n): _NEWLINE  _INDENT  _INDENT d=n*(n+1)/2 _NEWLINE  _INDENT  _INDENT return d _NEWLINE x=input("") _NEWLINE m=list() _NEWLINE for i in range(0,x,1): _NEWLINE  _INDENT  _INDENT m.append(fun(input(""))) _NEWLINE for i in m: _NEWLINE  _INDENT  _INDENT print i _NEWLINE 
# Konrad Talik _NEWLINE T=input() _NEWLINE while T: _NEWLINE  n=input() _NEWLINE  while ((n%2)==0)and n>1: _NEWLINE  _INDENT n/=2 _NEWLINE  print int(n==1);T-=1 _NEWLINE 
#Enter your code here _NEWLINE a=raw_input().split() _NEWLINE n=int(a[0]) _NEWLINE q=int(a[1]) _NEWLINE a=raw_input().split() _NEWLINE for i in xrange(n): _NEWLINE  _INDENT  _INDENT a[i]=int(a[i]) _NEWLINE hola=[0] _NEWLINE hola.append(a[0]) _NEWLINE for i in range(1,n): _NEWLINE  _INDENT  _INDENT a[i]+=a[i-1] _NEWLINE  _INDENT  _INDENT hola.append(a[i]) _NEWLINE #print hola _NEWLINE for i in xrange(q): _NEWLINE  _INDENT  _INDENT ra=raw_input().split() _NEWLINE  _INDENT  _INDENT l=int(ra[0]) _NEWLINE  _INDENT  _INDENT r=int(ra[1]) _NEWLINE  _INDENT  _INDENT #print hola[l-1],hola[r] _NEWLINE  _INDENT  _INDENT print hola[n]+hola[l-1]-hola[r]
# cook your code here _NEWLINE T = int(raw_input()) _NEWLINE for i in range(T): _NEWLINE  _INDENT  _INDENT (n,m) = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if n<m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "L" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "R" _NEWLINE  _INDENT  _INDENT elif m<n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if m%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "U" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "D" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if n%2==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "L" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "R"
#include <cstdio> _NEWLINE using namespace std; _NEWLINE int pp[40100],i,j,x,T,n,k,ans,tot,pr[400],ct[400],cnt; _NEWLINE bool p[40100]; _NEWLINE int phi(int x) { _NEWLINE  _INDENT  _INDENT int ans=x; _NEWLINE  _INDENT  _INDENT for (i=0;i<tot && pp[i]*pp[i]<=x;i++) if (x%pp[i]==0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=ans/pp[i]*(pp[i]-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while (x%pp[i]==0) x/=pp[i]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT if (x!=1) ans=ans/x*(x-1); _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE } _NEWLINE int power(int a,int x) { _NEWLINE 	long long s=a,ans=1; _NEWLINE 	for (int i=0;x>>i;i++) { _NEWLINE 		if ((x>>i)&1) ans=ans*s%(n+1); _NEWLINE 		s=s*s%(n+1); _NEWLINE 	} _NEWLINE 	return ans; _NEWLINE } _NEWLINE void dfs(int dep,int res,int cur) { _NEWLINE  _INDENT  _INDENT if (res>=ans) return; _NEWLINE  _INDENT  _INDENT if (dep==cnt) {if (res!=1 && cur==1) ans=res;return;} _NEWLINE  _INDENT  _INDENT for (int i=0;i<=ct[dep];i++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs(dep+1,res,cur); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res=res*pr[dep]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cur=power(cur,pr[dep]); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT for (i=2;i<=40000;i++) if (!p[i]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pp[tot++]=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (j=i;j<=40000;j+=i) p[j]=1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for (scanf("%d",&T);T;T--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d",&n,&k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=phi(n+1);ans=x; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (cnt=j=0;j<tot && pp[j]*pp[j]<=x;j++) if (x%pp[j]==0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pr[cnt]=pp[j];ct[cnt]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while (x%pp[j]==0) x/=pp[j],ct[cnt]++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (x!=1) pr[cnt]=x,ct[cnt]=1,cnt++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dfs(0,1,k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%d\n",ans); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <vector> _NEWLINE #include <limits.h> _NEWLINE #include <stdio.h> _NEWLINE #include <string> _NEWLINE #include <map> _NEWLINE #include <sstream> _NEWLINE using namespace std; _NEWLINE int n, t; _NEWLINE int a[200500]; _NEWLINE int aux[200500]; _NEWLINE int inv = 0; _NEWLINE void merge(int l, int m, int r) { _NEWLINE 	for (int i = l; i <= r; i++) _NEWLINE 		aux[i] = a[i]; _NEWLINE 	int lb = l, rb = r, mb = m; _NEWLINE 	for (int i = lb; i <= rb; i++) { _NEWLINE 		if (m + 1 > rb) { _NEWLINE 			a[i] = aux[l]; _NEWLINE 			//printf("%d and %d in %d inv +\n", l, m + 1, i); _NEWLINE 			l++; _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		if (l > mb) { _NEWLINE 			a[i] = aux[m + 1]; _NEWLINE 			//printf("%d and %d in %d \n", l, m + 1, i); _NEWLINE 			m++; _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		if (aux[l] > aux[m + 1]) { _NEWLINE 			//printf("%d and %d in %d inv +\n", l, m + 1, i); _NEWLINE 			inv += mb - l + 1; _NEWLINE 			a[i] = aux[m + 1]; _NEWLINE 			m++; _NEWLINE 		} else { _NEWLINE 			a[i] = aux[l]; _NEWLINE 			//printf("%d and %d in %d\n", l, m + 1, i); _NEWLINE 			l++; _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE } _NEWLINE void msort(int l, int r) { _NEWLINE 	if (l >= r) _NEWLINE 		return; _NEWLINE 	int m = l + (r - l) / 2; _NEWLINE 	msort(l, m); _NEWLINE 	msort(m + 1, r); _NEWLINE 	merge(l, m, r); _NEWLINE } _NEWLINE void solve() { _NEWLINE 	inv = 0; _NEWLINE 	for (int i = 0 ; i < 200000 ; i++) { _NEWLINE 		a[i] = 0; _NEWLINE 		aux[i] = 0; _NEWLINE 	} _NEWLINE 	scanf("%d", &n); _NEWLINE 	for (int i = 1; i <= n; i++) _NEWLINE 		scanf("%d", &a[i]); _NEWLINE 	msort(1, n); _NEWLINE 	printf("%d\n", inv); _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	scanf("%d", &t); _NEWLINE 	for (int times = 1; times <= t; times++) _NEWLINE 		solve(); _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE #include<iostream> _NEWLINE #include<math.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,n,m; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n>>m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%.2f\n",(pow(2,n+1)-pow(2,m+1))); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<string> _NEWLINE #include<algorithm> _NEWLINE #include<vector> _NEWLINE #include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<math.h> _NEWLINE using namespace std; _NEWLINE #define mod 1000000007 _NEWLINE #define size 200001 _NEWLINE  _NEWLINE long long n, i, j, sum; _NEWLINE vector<long long> pos(size); _NEWLINE vector<long long> pi(size); _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--){ _NEWLINE 		cin>>n; _NEWLINE 		for(i=0; i<n; ++i){ _NEWLINE 			cin>>pos[i]; _NEWLINE 		} _NEWLINE 		for(i=0; i<n; ++i){ _NEWLINE 			cin>>pi[i]; _NEWLINE 		} _NEWLINE 		sum=0; _NEWLINE 		for(i=0; i< n-1; ++i){ _NEWLINE 			for(j=i+1; j<n; ++j){ _NEWLINE 				if(pi[i]>pi[j]) _NEWLINE 					sum = (sum + pi[i]*abs(pos[i]-pos[j]))%mod; _NEWLINE 				else _NEWLINE 					sum = (sum + pi[j]*abs(pos[i]-pos[j]))%mod; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		cout<<sum<<endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
#include<iostream> _NEWLINE using namespace std; _NEWLINE void merges(int arr[],int l,int m,int r) _NEWLINE { _NEWLINE  int i=0;int j=0;int k=l; _NEWLINE  int n1=m-l+1; _NEWLINE  int n2=r-m; _NEWLINE  int a[n1]; _NEWLINE  int b[n2]; _NEWLINE  for(int x=0;x<n1;x++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[x]=arr[l+x]; _NEWLINE  for(int x=0;x<n2;x++) _NEWLINE  _INDENT  _INDENT b[x]=arr[m+1+x]; _NEWLINE  while(i<n1&&j<n2) _NEWLINE  { _NEWLINE  _INDENT  _INDENT  if(a[i]<=b[j]) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT arr[k]=a[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[k]=b[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k++; _NEWLINE  } _NEWLINE  while(i<n1){ _NEWLINE  _INDENT  _INDENT arr[k]=a[i]; _NEWLINE  _INDENT  _INDENT i++; _NEWLINE  _INDENT  _INDENT k++; _NEWLINE  } _NEWLINE  while(j<n2){ _NEWLINE  _INDENT  _INDENT arr[k]=b[j]; _NEWLINE  _INDENT  _INDENT j++; _NEWLINE  _INDENT  _INDENT k++; _NEWLINE  } _NEWLINE } _NEWLINE void mergesort(int l,int r,int arr[]) _NEWLINE { _NEWLINE  if(l<r) _NEWLINE  { _NEWLINE  _INDENT  _INDENT  int m=l+(r-l)/2; _NEWLINE  _INDENT  _INDENT  mergesort(l,m,arr); _NEWLINE  _INDENT  _INDENT  mergesort(m+1,r,arr); _NEWLINE  _INDENT  _INDENT  merges(arr,l,m,r); _NEWLINE  } _NEWLINE } _NEWLINE void print(int arr[],int n) _NEWLINE { _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<arr[i]<<endl; _NEWLINE  _INDENT  _INDENT cout<<endl; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int n; _NEWLINE  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT int a[n]; _NEWLINE  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>a[i]; _NEWLINE  _INDENT  _INDENT mergesort(0,n-1,a); _NEWLINE  _INDENT  _INDENT print(a,n); _NEWLINE } _NEWLINE 
a = input() _NEWLINE l1 = [] _NEWLINE for b in range(a): _NEWLINE  _INDENT  _INDENT c = input() _NEWLINE  _INDENT  _INDENT l1.append(c) _NEWLINE l1.sort() _NEWLINE for c in l1: _NEWLINE  _INDENT  _INDENT print c
N=int(raw_input()) _NEWLINE H=[int(num) for num in raw_input().split()] _NEWLINE  _NEWLINE S=[0 for i in xrange(len(H))] _NEWLINE def populateS(i): _NEWLINE  _INDENT  _INDENT num=1 _NEWLINE  _INDENT  _INDENT minVal=10**9 _NEWLINE  _INDENT  _INDENT while(num<=i): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT val = abs(H[i]-H[i-num])+S[i-num] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if val<minVal: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT minVal=val _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT num = num*2 _NEWLINE  _INDENT  _INDENT return minVal _NEWLINE  _NEWLINE for i in xrange(1,len(H)): _NEWLINE  _INDENT  _INDENT S[i] = populateS(i) _NEWLINE print S[-1] _NEWLINE 
import re _NEWLINE t=raw_input() _NEWLINE flag=1 _NEWLINE  _NEWLINE if len(t)<5: _NEWLINE  _INDENT  _INDENT flag=0 _NEWLINE regex=re.compile('[a-z]') _NEWLINE if len(regex.findall(t))==0: _NEWLINE  _INDENT  _INDENT flag=0 _NEWLINE regex2=re.compile('[A-Z]') _NEWLINE if len(regex2.findall(t))==0: _NEWLINE  _INDENT  _INDENT flag=0 _NEWLINE regex3=re.compile('[0-9]') _NEWLINE if len(regex3.findall(t))==0: _NEWLINE  _INDENT  _INDENT flag=0 _NEWLINE if flag==1: _NEWLINE  _INDENT  _INDENT print "YES" _NEWLINE else: _NEWLINE  _INDENT  _INDENT print "NO" _NEWLINE 
t=input() _NEWLINE while t > 0 : _NEWLINE  _INDENT n=input() _NEWLINE  _INDENT if n==0 : _NEWLINE  _INDENT  print n _NEWLINE  _INDENT else : _NEWLINE  _INDENT  x=(2*n - 1)/2 _NEWLINE  _INDENT  y=(2*n -1)**2 + x _NEWLINE  _INDENT  print y _NEWLINE  _INDENT t=t-1 
testcase = input() _NEWLINE for i in range(0, testcase): _NEWLINE 	n, q = map(int, raw_input().split()) _NEWLINE 	s = raw_input() _NEWLINE 	for j in range(0, q): _NEWLINE 		c, t = raw_input().split() _NEWLINE 		if(t == "even"): _NEWLINE 			if(s.count(c)%2 == 0): _NEWLINE 				print "yes" _NEWLINE 			else: _NEWLINE 				print "no" _NEWLINE 		else: _NEWLINE 			if(s.count(c)%2 == 1): _NEWLINE 				print "yes" _NEWLINE 			else: _NEWLINE 				print "no"
t=int(raw_input()) _NEWLINE while t: _NEWLINE 	t-=1 _NEWLINE 	a=raw_input() _NEWLINE 	b=raw_input() _NEWLINE 	b=b+b _NEWLINE 	if a in b: print 'YES' _NEWLINE 	else: print 'NO'
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _INDENT _NEWLINE #define ll long long int _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE #define s(n) scanf("%d",&n); _NEWLINE #define sl(n) scanf("%lld",&n); _NEWLINE #define p(n) printf("%d\n",n) _NEWLINE #define pl(n) printf("%lld\n",n) _NEWLINE  int a[111111]; _NEWLINE  class node{ _NEWLINE  _INDENT _NEWLINE 	public: _NEWLINE 	 _NEWLINE  	bool ap; _NEWLINE  	int d; _NEWLINE  	int l; _NEWLINE  	int r; _NEWLINE  	int size; _NEWLINE  		node(){} _NEWLINE  		node(int x){ _NEWLINE  			ap=1; _NEWLINE  			d=0; _NEWLINE  			l=r=x; _NEWLINE  			size=1; _NEWLINE  		} _NEWLINE  }; _NEWLINE  _INDENT _NEWLINE  class tree{ _NEWLINE  	node tt[4*100000+15]; _NEWLINE  	public: _NEWLINE  		tree(){}; _NEWLINE  		void build(int s,int e,int idx ); _NEWLINE  		node init(int x); _NEWLINE  		node combine(node x,node y); _NEWLINE  		void update(int s,int e,int idx, int id,int x); _NEWLINE  		node query(int s,int e,int idx,int i,int j); _NEWLINE  }; _NEWLINE  _INDENT _NEWLINE  node tree:: init(int x){ _NEWLINE  	node t(x); _NEWLINE  	return t; _NEWLINE  } _NEWLINE  node tree:: combine(node x,node y){ _NEWLINE  	node t; _NEWLINE  	if(x.size==1&&y.size==1){ _NEWLINE  		t.ap=1; _NEWLINE  		t.d=y.l-x.r; _NEWLINE  	} _NEWLINE  	else if(x.size==1&&y.size!=1){ _NEWLINE  		t.ap=(y.l==x.r+y.d); _NEWLINE  		t.d=t.ap?y.d:0; _NEWLINE  	} _NEWLINE  	else if(x.size!=1&&y.size==1){ _NEWLINE  		t.ap=(y.l==x.r+x.d); _NEWLINE  		t.d=t.ap?x.d:0; _NEWLINE  	} _NEWLINE  	else{ _NEWLINE  		t.ap=x.ap&&y.ap&&(y.l==x.r+x.d&&x.d==y.d); _NEWLINE  		t.d=t.ap?x.d:0; _NEWLINE  	} _NEWLINE  	t.l=x.l; _NEWLINE  	t.r=y.r; _NEWLINE  	t.size=x.size+y.size; _NEWLINE  	return t; _NEWLINE  } _NEWLINE void tree:: build(int s,int e,int idx){ _NEWLINE 	if(s==e){ _NEWLINE 		tt[idx]=init(a[s]); _NEWLINE 		return ; _NEWLINE 	} _NEWLINE 	int m=(s+e)>>1; _NEWLINE 	int l=(idx<<1)+1; _NEWLINE 	int r=l+1; _NEWLINE 	build(s,m,l); _NEWLINE 	build(m+1,e,r); _NEWLINE 	tt[idx]=combine(tt[l],tt[r]); _NEWLINE } _NEWLINE void _INDENT tree:: update(int s,int e,int idx,int id,int x) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(s>e||id>e||id<s)return; _NEWLINE  _INDENT  _INDENT if(s==e&&s==id) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT tt[idx]=init(x); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT int m=(s+e)>>1; _NEWLINE 	int _INDENT l=(idx<<1)+1; _NEWLINE 	int r=l+1; _NEWLINE  _INDENT  _INDENT update(s,m,l,id,x); _NEWLINE  _INDENT  _INDENT update(m+1,e,r,id,x); _NEWLINE  _INDENT  _INDENT tt[idx]=combine(tt[l],tt[r]); _NEWLINE } _NEWLINE node tree:: query(int s,int e,int idx,int i,int j){ _NEWLINE 	if(s>=i&&e<=j) _NEWLINE 		return tt[idx]; _NEWLINE 	int m=(s+e)>>1; _NEWLINE 	int l=(idx<<1)+1; _NEWLINE 	int r=l+1; _NEWLINE 	if(m<i) _NEWLINE 		return query(m+1,e,r,i,j); _NEWLINE 	if(m>=j) _NEWLINE 		return query(s,m,l,i,j); _NEWLINE 	return combine(query(s,m,l,i,j),query(m+1,e,r,i,j)); _NEWLINE } _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE int main(){ _NEWLINE 	tree t; _NEWLINE 	int n; _NEWLINE 	cin>>n; _NEWLINE 	int i,j; _NEWLINE 	for(i=0;i<n;i++) _NEWLINE 		cin>>a[i]; _NEWLINE 	t.build(0,n-1,0); _NEWLINE 	int q; _NEWLINE 	cin>>q; _NEWLINE 	while(q--){ _NEWLINE 		int ty; _NEWLINE 		int i,j; _NEWLINE 		cin>>ty>>i>>j; _NEWLINE 		if(ty){ _NEWLINE 			node tt=t.query(0,n-1,0,i-1,j-1); _NEWLINE 			cout<<tt.ap<<endl; _NEWLINE 		} _NEWLINE 		else{ _NEWLINE 			i--; _NEWLINE 			a[i]=j; _NEWLINE 			t.update(0,n-1,0,i-1,j); _NEWLINE 		} _NEWLINE 	} _NEWLINE } 
def getAns(x,M): _NEWLINE  _INDENT  _INDENT a=1 _NEWLINE  _INDENT  _INDENT b=x _NEWLINE  _INDENT  _INDENT while b!=1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=M/b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a*=c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a%=M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b*=c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b%=M _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if b>M/2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=M-a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT b=M-b _NEWLINE  _INDENT  _INDENT return a _NEWLINE t=int(input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n,p=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if n<p: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=p-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while i>n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f=(f*i)%p _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i-=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r=p-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print (r*getAns(f,p))%p _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "0" _NEWLINE 
from sys import stdin,stdout _NEWLINE  _NEWLINE for i in xrange(int(stdin.readline().strip())): _NEWLINE  _INDENT  _INDENT string = stdin.readline().strip() _NEWLINE  _INDENT  _INDENT d = int(stdin.readline().strip()) _NEWLINE  _INDENT  _INDENT length = len(string) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT stdout.write(string[d-1:]) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT if d % 2 == 0 and length % 2 == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stdout.write(string[:d-1]) _NEWLINE  _INDENT  _INDENT elif d % 2 == 0 and length % 2 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stdout.write(string[:d-1][::-1]) _NEWLINE  _INDENT  _INDENT elif d % 2 == 1 and length % 2 == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stdout.write(string[:d-1][::-1]) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT stdout.write(string[:d-1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print
/* _NEWLINE  _INDENT  Ashutosh Singla <ashu1461@gmail.com> _NEWLINE Algorithm: _NEWLINE #tags: _NEWLINE date: Sat Oct 19 23:47:28 IST 2013 _NEWLINE  */ _NEWLINE  _NEWLINE #include<stdio.h> _NEWLINE #include<stdlib.h> _NEWLINE #include<string.h> _NEWLINE #include<math.h> _NEWLINE #include<iostream> _NEWLINE #include<vector> _NEWLINE #include<map> _NEWLINE #include<set> _NEWLINE #include<stack> _NEWLINE #include<queue> _NEWLINE #include<algorithm> _NEWLINE  _NEWLINE using namespace std; _NEWLINE typedef vector<int> vi; _INDENT _NEWLINE typedef pair<int,int> ii; _NEWLINE typedef long long LL; _NEWLINE #define FL(a) memset(a, 0, sizeof a); _NEWLINE #define fill(a,v,N) memset(a, v, sizeof(a[0])*N) _NEWLINE #define sz(a) int((a).size()) _INDENT _NEWLINE #define pb push_back _INDENT _NEWLINE #define si(n) scanf("%d",&n) _NEWLINE #define sin(n) scanf("%d\n",&n) // for scanning strings .. _NEWLINE #define sill(n) scanf("%lld",&n) _NEWLINE #define pi(n) printf("%d\n",n); _NEWLINE #define pill(n) printf("%lld\n",n); _NEWLINE #define pis(n) printf("%d ",n); _NEWLINE  _NEWLINE #define all(c) (c).begin(),(c).end() _NEWLINE #define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) _NEWLINE #define present(c,x) ((c).find(x) != (c).end()) _INDENT // map and set find .. _INDENT _NEWLINE #define cpresent(c,x) (find(all(c),x) != (c).end()) _INDENT // stl find .. _NEWLINE #define FREP(b) for(int i=0;i<b;i++) _NEWLINE #define FREPr(b) for(int i=b-1;i>=0;i--) _NEWLINE #define REP(a,b,c) for(int a=b;a<c;a++) _NEWLINE #define REPr(a,b,c) for(int a=b;a>b;a--) _NEWLINE #define mp(a,b) make_pair(a,b); _NEWLINE typedef pair<int, int> ii; _NEWLINE #define MAX_S 100007 _NEWLINE /* _NEWLINE  _INDENT  struct data{ _NEWLINE  _INDENT  }; _NEWLINE  _INDENT  bool operator < (const data &a1, const data &a2){ _NEWLINE  _INDENT  } _NEWLINE  */ _NEWLINE double dp[2508][1300]; _NEWLINE double recursion(int T, int k){ _NEWLINE  _INDENT  _INDENT if(k > T/2 || k < 0 || T<0) return -1.00; _INDENT _NEWLINE  _INDENT  _INDENT if(k == T/2) return k; _NEWLINE  _INDENT  _INDENT if(dp[T][k]!=-1.00) return dp[T][k]; _NEWLINE  _NEWLINE  _INDENT  _INDENT double P1 = (double)(k)/(double)(T-k); _NEWLINE  _INDENT  _INDENT double P2 = (double)(1.0-P1)*(1.0/(double)(T-k-1.0)); _NEWLINE  _INDENT  _INDENT double P3 = (double)k*P2; _NEWLINE  _INDENT  _INDENT double P4 = (double)(1.0-P1)*(double)(1.0-1.0/(T-k-1.0)-(1.0)*k/(T-k-1.0)); _NEWLINE  _INDENT  _INDENT // _INDENT  _INDENT printf("here for t .. %d %d %lf %lf %lf %lf\n",T,k,P1,P2,P3,P4).. _INDENT _NEWLINE  _INDENT  _INDENT dp[T][k] = P1*(1.0 + recursion(T-2, k-1))+ // case: any known card _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P2*(1.0 + recursion(T-2, k))+ // case: both new + both matching _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P3*(2.0 + recursion(T-2, k))+ _INDENT  // case: one new + prev known card _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT P4*(1.0 + recursion(T, k+2)); _INDENT  // case : none of the above _NEWLINE // _INDENT  _INDENT printf("%lf\n", P4); _NEWLINE  _INDENT  _INDENT return dp[T][k]; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int a,b; _NEWLINE  _INDENT  _INDENT FREP(2508){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT REP(j,0,1300){ dp[i][j] = -1.00; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT dp[0][0] = 0; _NEWLINE  _INDENT  _INDENT while(scanf("%d %d",&a, &b)!=EOF){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%.4lf\n", recursion(a*b, 0)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE  _NEWLINE 
#include<iostream> _NEWLINE #include<stdio.h> _NEWLINE  _NEWLINE using namespace std ; _NEWLINE int main() _NEWLINE { _NEWLINE 	int i=0 ; _NEWLINE 	while(1){	int N ; _NEWLINE 		int a[100],move=0,sum=0 ; _NEWLINE 		 _NEWLINE 		//scanf("%d",&x) ; _NEWLINE 		scanf("%d",&N); _NEWLINE 		if(N==0) _NEWLINE 		break ; _NEWLINE 		for(int j=0 ;j<N ;j++) _NEWLINE 		a[j]=0 ; _NEWLINE 		for(int j=0 ; j<N ; j++) _NEWLINE 		 { _NEWLINE 		 scanf("%d",&a[j]) ; _NEWLINE 		 sum+=a[j]; _INDENT _NEWLINE 		 } _NEWLINE 		 sum=sum/N ; _NEWLINE 		 for(int j=0 ; j<N ; j++) _NEWLINE 		 { _NEWLINE 		 if(a[j]>(sum)) _NEWLINE 		 move+=a[j]-sum; _NEWLINE 		 else _NEWLINE 		 move+=sum-a[j] ;	 _NEWLINE 		 } _NEWLINE 		 i++ ; _NEWLINE 		 printf("Set #%d\n",i) ; _NEWLINE 		 printf("The minimum number of moves is %d.\n\n",move/2) ; _NEWLINE 	} _NEWLINE 	 _NEWLINE return 0 ; _NEWLINE 	 _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE #define llt unsigned int _NEWLINE int main() _NEWLINE { _NEWLINE 	unsigned int x; _NEWLINE 	cin>>x; _NEWLINE 	llt even_bits = x & 0xAAAAAAAA; _INDENT _NEWLINE 	llt odd_bits = x & 0x55555555; _INDENT _NEWLINE  _NEWLINE 	even_bits >>= 1; _INDENT _NEWLINE 	odd_bits <<= 1; _INDENT _NEWLINE  _NEWLINE 	 cout<<(even_bits | odd_bits)<<endl; _INDENT _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE  _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _NEWLINE  _INDENT  _INDENT while (t--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n,m; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d",&n,&m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int mini = min(n,m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (mini&1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("Rohan\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("Kshitij\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int val[20],a[20][20],d[20],fin; _NEWLINE  _NEWLINE void dfs(int r, int n, int ans, int mask){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mask|=1<<r; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans+=d[r]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[r][i]==1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if((mask&(1<<i))==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  dfs(i,n,ans,mask); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fin=max(ans,fin); _NEWLINE  _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memset(a,0,sizeof(a)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memset(d,0,sizeof(d)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT fin=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memset(val,0,sizeof(val)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int n,i,j,op=-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>d[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(j=1;j<=n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cin>>a[i][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=n;i++){ _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dfs(i,n,0,0); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<fin<<endl; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE } _NEWLINE 
#Enter your code here _NEWLINE a = input() _NEWLINE for b in range(a): _NEWLINE 	c = input() _NEWLINE 	if c % 26== 0: _NEWLINE 		print c/26 _NEWLINE 	elif (c % 26) == c: _NEWLINE 		print 1 _NEWLINE 	else: _NEWLINE 		print (c/26)+1 _NEWLINE 		 _NEWLINE 
/* _NEWLINE TEEPA HAIN _INDENT _NEWLINE DEKH RAHA HUN KUCH CHEEZE _NEWLINE ----------------------------------------------------------------------------- _NEWLINE Author : _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT --------------------------------------------------------- _NEWLINE  _INDENT  _INDENT UTKAR$H $AXENA _INDENT --------------------------------------------------------- _NEWLINE  _INDENT  _INDENT IIT INDORE _INDENT  _INDENT  _INDENT --------------------------------------------------------- _NEWLINE ----------------------------------------------------------------------------- _NEWLINE */ _NEWLINE #include<bits/stdc++.h> _NEWLINE #include<iostream> _NEWLINE using namespace std; _NEWLINE #define fre 	freopen("0.in","r",stdin),freopen("0.out","w",stdout) _NEWLINE #define MOD 1000000007 _NEWLINE #define lld signed long long int _NEWLINE #define scanll(x) scanf("%lld",&x) _NEWLINE #define printll(x) printf("%lld\n",x) _NEWLINE #define boost ios_base::sync_with_stdio(0) _NEWLINE //vector<int> g[2*100000+5];int par[2*100000+5]; _NEWLINE #define MX 600000+5 _NEWLINE lld F[MX]; _NEWLINE lld G[MX]; _NEWLINE lld A[MX]; _NEWLINE  _NEWLINE lld sF[MX][21]; _NEWLINE bool flag_sF[MX][21]; _NEWLINE lld sG[MX][21]; _NEWLINE bool flag_sG[MX][21]; _NEWLINE  _NEWLINE lld rec1(int mask,int i){ _NEWLINE 	if(i==-1){ _NEWLINE 		return G[mask]; _NEWLINE 	} _NEWLINE 	if(flag_sF[mask][i]) _NEWLINE 		return sF[mask][i]; _NEWLINE  _NEWLINE 	flag_sF[mask][i] = 1; _NEWLINE 	sF[mask][i] = rec1(mask,i-1); _NEWLINE 	if(mask&(1<<i)){ _NEWLINE 		sF[mask][i] = (sF[mask][i] + rec1(mask^(1<<i),i-1))%MOD; _NEWLINE 	} _NEWLINE 	return sF[mask][i]; _NEWLINE } _NEWLINE lld rec2(int mask,int i){ _NEWLINE 	if(i==-1){ _NEWLINE 		return (F[mask]*F[mask])%MOD; _NEWLINE 	} _NEWLINE 	if(flag_sG[mask][i]) _NEWLINE 		return sG[mask][i]; _NEWLINE  _NEWLINE 	flag_sG[mask][i] = 1; _NEWLINE 	sG[mask][i] = rec2(mask,i-1); _NEWLINE 	if(mask&(1<<i)){ _NEWLINE 		sG[mask][i] = (sG[mask][i] + rec2(mask^(1<<i),i-1))%MOD; _NEWLINE 	} _NEWLINE 	return sG[mask][i]; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	//fre; _NEWLINE 	int N; _NEWLINE 	cin>>N; _NEWLINE 	assert(N<=600000); _NEWLINE 	for(int i=0;i<N;++i){ _NEWLINE 		scanll(A[i]); _NEWLINE 		assert(1<=A[i] and A[i]<=1000000000); _NEWLINE 	} _NEWLINE 	for(int i=0;i<N;++i){ _NEWLINE 		F[i] = (A[i]*A[i] + rec1(i,20)*rec1(i,20)) % MOD; _NEWLINE 		G[i] = (rec2(i,20)) % MOD; _NEWLINE 		for(int j=0;j<=20;++j){ _NEWLINE 			flag_sF[i][j] = 0; _NEWLINE 		} _NEWLINE 		for(int j=0;j<=20;++j){ _NEWLINE 			flag_sG[i][j] = 0; _NEWLINE 		} _INDENT _NEWLINE 		rec1(i, 20); _NEWLINE 		G[i] = (rec2(i,20)) % MOD; _NEWLINE 		 _NEWLINE 	} _NEWLINE 	lld ans = 0; _NEWLINE 	for(int i=0;i<N;++i){ _NEWLINE 		ans = (ans+((i*F[i])%MOD)*G[i])%MOD; _NEWLINE 	} _NEWLINE 	printll(ans); _NEWLINE }
 _NEWLINE #include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #if !ONLINE_JUDGE _NEWLINE #include "debug.h" _NEWLINE #else _NEWLINE #endif _NEWLINE  _NEWLINE typedef long long int LL; _NEWLINE typedef unsigned long long LLU; _NEWLINE typedef long double LD; _NEWLINE  _NEWLINE #define INF 1500000000000000000LL _NEWLINE #define MOD 1000000007 _NEWLINE #define F first _NEWLINE #define S second _NEWLINE #define PB push_back _NEWLINE #define MK make_pair _NEWLINE #define LEN(vale) strlen(vale) _NEWLINE #define SZ(vale) (int)vale.size() _NEWLINE #define SQ(A) ((A)*(A)) _NEWLINE #define FI(i,fa,fb) for(int i=fa;i<fb;++i) _NEWLINE #define FD(i,fa,fb) for(int i=fa;i>fb;--i) _NEWLINE #define FT(it,S) for(it = (S).begin(); it != (S).end(); ++it) _INDENT _NEWLINE #define bits(vale) __builtin_popcount(vale) _NEWLINE #define VT vector _NEWLINE  _NEWLINE #define SET1(array,val,sz) for(int i=0;i<sz;i++)array[i]=val; _NEWLINE #define SET2(array,val,sz1,sz2) for(int i=0;i<sz1;i++)for(int j=0;j<sz2;j++)array[i][j]=val; _NEWLINE  _NEWLINE #define ALL(a) a.begin(),a.end() _NEWLINE #define LB (lower_bound) _NEWLINE #define UB (upper_bound) _NEWLINE  _NEWLINE #define SI(vale) scanf("%d",&vale) _NEWLINE #define PI(vale) printf("%d\n",vale) _NEWLINE #define PIS(vale) printf("%d ",vale) _NEWLINE #define SL(vale) scanf("%lld",&vale) _NEWLINE #define PL(vale) printf("%lld\n",vale) _NEWLINE #define PLS(vale) printf("%lld ",vale) _NEWLINE #define SS(vale) scanf("%s",vale) _NEWLINE #define PS(vale) printf("%s\n",vale) _NEWLINE #define SLD(vale) scanf("%Lf",&vale) _NEWLINE #define PLD(vale) printf("%0.12Lf\n",vale) _NEWLINE #define NL printf("\n") _NEWLINE #define TCS() int testcase; SI(testcase);while(testcase--) _INDENT _NEWLINE  _NEWLINE typedef pair<int,int> PR; _NEWLINE bool deb = false; _NEWLINE const int N = 1000011; _NEWLINE int n,k; _NEWLINE char a[N]; _NEWLINE char pattern[N],text[N]; _INDENT  _INDENT _NEWLINE int lenp,lent; _INDENT _NEWLINE int F[N],match; _NEWLINE  _NEWLINE void build_fail() { _NEWLINE  _INDENT  _INDENT  F[0] = F[1] = 0; _NEWLINE  _INDENT  _INDENT  for(int i=2;i<=lenp;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int j = F[i-1]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(pattern[j] == pattern[i-1]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT F[i] = j+1; break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(j == 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT F[i] = 0; _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  j = F[j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  } _NEWLINE } _NEWLINE  _NEWLINE void kmp() { _NEWLINE  _INDENT  _INDENT  build_fail(); _NEWLINE  _INDENT  _INDENT  int i = 0,j = 0; _NEWLINE  _INDENT  _INDENT  while(1) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(j == lent) break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(text[j] == pattern[i]) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  i++,j++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(i == lenp) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT match++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(i > 0) i = F[i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else j++; _NEWLINE  _INDENT  _INDENT  } _NEWLINE } _NEWLINE  _NEWLINE bool f(LL v){ _NEWLINE  _INDENT  _INDENT  FI(i,0,v) pattern[i] = text[i]; _NEWLINE  _INDENT  _INDENT  pattern[v] = '\0'; _NEWLINE  _INDENT  _INDENT  lenp = v; _NEWLINE  _INDENT  _INDENT  match = 0; _NEWLINE  _INDENT  _INDENT  kmp(); _NEWLINE  _INDENT  _INDENT  if(match >= k) return 1; _NEWLINE  _INDENT  _INDENT  return 0; _NEWLINE } _NEWLINE  _NEWLINE LL bs(LL lo,LL hi){ _NEWLINE  _INDENT  _INDENT  _INDENT  LL ans = -1; _NEWLINE  _INDENT  _INDENT  _INDENT  while(lo < hi){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT LL mid = lo + (hi-lo)/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(f(mid)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  lo = mid + 1,ans = mid; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  hi = mid; _NEWLINE  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  return ans; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT  //clock_t tStart = clock(); _NEWLINE  _INDENT  _INDENT  int t; _NEWLINE  _INDENT  _INDENT  //TCS(){ _NEWLINE  _INDENT  _INDENT  SI(lent); _NEWLINE  _INDENT  _INDENT  SS(text); _NEWLINE  _INDENT  _INDENT  SI(k); _NEWLINE  _INDENT  _INDENT  int ans = (bs(0,lent+3)); _NEWLINE  _INDENT  _INDENT  if(ans == -1) ans = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT PI(ans); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT FI(i,0,ans) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  printf("%c",text[i]); NL; _NEWLINE  _INDENT  _INDENT  //exectime(); _NEWLINE  _INDENT  _INDENT  return 0; _INDENT _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE 
import sys _INDENT _NEWLINE t=int(input()) _NEWLINE while t>0: _NEWLINE 	A=list(raw_input()) _NEWLINE 	B=list(raw_input()) _NEWLINE 	C=list(set(B)) _NEWLINE 	D=[] _NEWLINE 	F=[] _NEWLINE 	Arr=[] _NEWLINE 	for i in xrange(len(C)): _NEWLINE 		D.append(A.count(C[i])) _NEWLINE 		F.append(B.count(C[i])) _NEWLINE 		Arr.append(D[i]/F[i]) _NEWLINE 	print min(Arr) _NEWLINE 	t=t-1
from sys import stdin _NEWLINE  _NEWLINE class Trie: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT def __init__(self): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT self.nextL = [-1] * 300000 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT self.nextR = [-1] * 300000 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT self.sizeL = [0] * 300000 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT self.sizeR = [0] * 300000 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT self.hash = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT def insert(self, no): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT node = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for bit in xrange(17, -1, -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = no & 1 << bit != 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nexT = self.nextL if i == 0 else self.nextR _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT size = self.sizeL if i == 0 else self.sizeR _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if nexT[node] == -1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT nexT[node] = self.hash _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT self.hash += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT size[node] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT node = nexT[node] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT def query(self, no, k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if k >= 1 << 17: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return self.sizeL[0] + self.sizeR[0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT node, count = 0, 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for bit in xrange(17, -1, -1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i = no & 1 << bit != 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j = k _INDENT & 1 << bit != 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if node == -1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return count _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count += self.sizeL[node] if i == 0 else self.sizeR[node] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT node = self.nextL[node] if (i ^ j) == 0 else self.nextR[node] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return count _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE lines = iter(stdin.readlines()) _NEWLINE for tc in xrange(int(next(lines))): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N, K = map(int, next(lines).split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT A = list(map(int, next(lines).split())) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT trie = Trie() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT trie.insert(0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT xorPrefix = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for a in A: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT xorPrefix ^= a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans += trie.query(xorPrefix, K) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT trie.insert(xorPrefix) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans
t = int(raw_input()) _NEWLINE  _NEWLINE for x in range(t): _NEWLINE 	inputs = raw_input() _NEWLINE 	inputs = inputs.split(" ") _NEWLINE 	m = int(inputs[0]) _NEWLINE 	n = int(inputs[1]) _NEWLINE  _NEWLINE 	city_array = [] _NEWLINE 	for x in range(m): _NEWLINE 		temp = raw_input() _NEWLINE 		temp = temp.split(" ") _NEWLINE 		city_array.append(temp) _NEWLINE  _NEWLINE  _NEWLINE 	for x in range(m): _NEWLINE 		for y in range(n): _NEWLINE 			if city_array[x][y] == '1': _NEWLINE 				city_array[x][y] = 1 _NEWLINE 			else: _NEWLINE 				city_array[x][y] = 0 _NEWLINE  _NEWLINE 	for x in range(1,m): _NEWLINE 		for y in range(1,n): _NEWLINE 			if city_array[x][y] == 1: _NEWLINE 				city_array[x][y] = min(city_array[x-1][y],city_array[x][y-1],city_array[x-1][y-1]) + 1 _NEWLINE 			else: _NEWLINE 				city_array[x][y] = 0 _NEWLINE  _NEWLINE 	max_length = 0 _NEWLINE 	for x in range(m): _NEWLINE 		for y in range(n): _NEWLINE 			if city_array[x][y] > max_length: _NEWLINE 				max_length = city_array[x][y] _NEWLINE  _NEWLINE 	print(max_length) _NEWLINE 
#include <bits/stdc++.h> _NEWLINE #define ll long long _NEWLINE #define mod 1000000007 _NEWLINE #define upperlimit 1000100 _NEWLINE #define INF 1000000000 _NEWLINE #define INFL 1000000000000000000 _NEWLINE #define eps 1e-8 _NEWLINE #define endl '\n' _NEWLINE #define sd(n) scanf("%d",&n) _NEWLINE #define slld(n) scanf("%lld",&n) _NEWLINE #define pd(n) printf("%d",n) _NEWLINE #define plld(n) printf("%lld",n) _NEWLINE #define pds(n) printf("%d ",n) _NEWLINE #define pllds(n) printf("%lld ",n) _NEWLINE #define pdn(n) printf("%d\n",n) _NEWLINE #define plldn(n) printf("%lld\n",n) _NEWLINE #define REP(i,a,b) for(i=a;i<=b;i++) _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE #define pcc pair<char,char> _NEWLINE #define pii pair<int,int> _NEWLINE #define pll pair<ll,ll> _NEWLINE #define tr(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++) _NEWLINE #define F first _NEWLINE #define S second _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE ll gcd(ll n1,ll n2){ _NEWLINE 	if(n1%n2==0)return n2; _NEWLINE 	return gcd(n2,n1%n2); _NEWLINE } _NEWLINE ll powmod(ll base,ll exponent) _NEWLINE { _NEWLINE 	ll ans=1; _NEWLINE 	while(exponent){ _NEWLINE 		if(exponent&1)ans=(ans*base)%mod; _NEWLINE 		base=(base*base)%mod; _NEWLINE 		exponent/=2; _NEWLINE 	} _NEWLINE 	return ans; _NEWLINE } _NEWLINE int arr[upperlimit+1]; _NEWLINE vector <int> factors[upperlimit+1]; _NEWLINE bool prime[upperlimit+1]; _NEWLINE int mobius[upperlimit+1]; _NEWLINE int f[upperlimit+1]; _NEWLINE int g[upperlimit+1]; _NEWLINE int cnt[upperlimit+1]; _NEWLINE int dp[upperlimit+1]; _NEWLINE ll fn(ll n){ _NEWLINE 	return (powmod(2,n)-1+mod)%mod; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int n,q,x,y,i,j,k,t; _NEWLINE 	for(i=2;i*i<=upperlimit;i++)if(!prime[i])for(j=i*i;j<=upperlimit;j+=i)prime[j]=true; _NEWLINE 	for(i=1;i<=upperlimit;i++){ _NEWLINE 		mobius[i]=1; _NEWLINE 		for(j=i;j<=upperlimit;j+=i)factors[j].pb(i); _NEWLINE 	} _NEWLINE 	for(i=2;i*i<=upperlimit;i++)if(!prime[i])for(j=i*i;j<=upperlimit;j+=i*i)mobius[j]=0; _NEWLINE 	for(i=2;i<=upperlimit;i++)if(!prime[i])for(j=i;j<=upperlimit;j+=i)mobius[j]*=-1; _NEWLINE 	for(i=2;i<=upperlimit;i++)if(!prime[i])for(ll j1=i;j1<=upperlimit;j1*=i)f[j1]=1; _NEWLINE 	for(i=1;i<=upperlimit;i++)if(mobius[i]!=0)for(j=i;j<=upperlimit;j+=i)g[j]=(mod+g[j]+mobius[i]*f[j/i])%mod; _NEWLINE 	sd(t); _NEWLINE 	while(t--){ _NEWLINE 		ll answer=0,temp; _NEWLINE 		for(i=0;i<=upperlimit;i++){ _NEWLINE 			arr[i]=0; _NEWLINE 			cnt[i]=0; _NEWLINE 			dp[i]=0; _NEWLINE 		} _NEWLINE 		sd(n); _NEWLINE 		sd(q); _NEWLINE 		for(i=1;i<=n;i++){ _NEWLINE 			sd(arr[i]); _NEWLINE 			cnt[arr[i]]++; _NEWLINE 		} _NEWLINE 		for(i=1;i<=upperlimit;i++)for(j=i;j<=upperlimit;j+=i)dp[i]+=cnt[j]; _NEWLINE 		for(i=1;i<=upperlimit;i++){ _NEWLINE 			temp=(fn(dp[i])*g[i])%mod; _NEWLINE 			answer+=temp; _NEWLINE 			if(answer>=mod)answer-=mod; _NEWLINE 		} _NEWLINE 		while(q--){ _NEWLINE 			sd(x); _NEWLINE 			sd(y); _NEWLINE 			for(i=0;i<factors[arr[x]].size();i++){ _NEWLINE 				j=factors[arr[x]][i]; _NEWLINE 				dp[j]--; _NEWLINE 				temp=(mod-powmod(2,dp[j]))%mod; _NEWLINE 				temp=(temp*g[j])%mod; _NEWLINE 				answer+=temp; _NEWLINE 				if(answer>=mod)answer-=mod; _NEWLINE 			} _NEWLINE 			arr[x]=y; _NEWLINE 			for(i=0;i<factors[arr[x]].size();i++){ _NEWLINE 				j=factors[arr[x]][i]; _NEWLINE 				temp=(mod+powmod(2,dp[j]))%mod; _NEWLINE 				temp=(temp*g[j])%mod; _NEWLINE 				dp[j]++; _NEWLINE 				answer+=temp; _NEWLINE 				if(answer>=mod)answer-=mod; _NEWLINE 			} _NEWLINE 			plldn(answer); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE # define l long int _NEWLINE int main() _NEWLINE { _NEWLINE 	string s("1"); _NEWLINE 	s.resize(5911116); _NEWLINE 	l j=0; _NEWLINE 	l t; _NEWLINE 	string k; _NEWLINE 	l n; _NEWLINE 	for(l i=1;i<=1000000;i++) _NEWLINE 	{ _NEWLINE 		if(i/10==0) {s.at(j)=i+'0'; j++;} _NEWLINE 		else if(i/100==0){ _NEWLINE 			s.at(j)=i/10 +'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=i%10+'0'; _NEWLINE 			j++; _NEWLINE 		} _NEWLINE 		else if(i/1000==0) _NEWLINE 		{ _NEWLINE 			s.at(j)=i/100+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%100)/10+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%10)+'0'; _NEWLINE 			j++; _NEWLINE 		} _NEWLINE 		else if(i/10000==0) _NEWLINE 		{ _NEWLINE 			s.at(j)=i/1000+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%1000)/100+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%100)/10+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%10)+'0'; _NEWLINE 			j++; _NEWLINE 		} _NEWLINE 		else if(i/100000==0) _NEWLINE 		{ _NEWLINE 			s.at(j)=i/10000+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%10000)/1000+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%1000)/100+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%100)/10+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%10)+'0'; _NEWLINE 			j++;	 _NEWLINE 		} _NEWLINE 		else if(i/1000000==0) _NEWLINE 		{ _NEWLINE 			s.at(j)=i/100000+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%100000)/10000+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%10000)/1000+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%1000)/100+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%100)/10+'0'; _NEWLINE 			j++; _NEWLINE 			s.at(j)=(i%10)+'0'; _NEWLINE 			j++;	 _NEWLINE 		} _NEWLINE 		else if(i==1000000) _NEWLINE 		{ _NEWLINE 			s.at(j)=1+'0'; j++; _NEWLINE 			for(int r=0;r<6;r++) _NEWLINE 			{ _NEWLINE 				s.at(j+r)=0+'0'; _NEWLINE 			} _NEWLINE 		} _NEWLINE 	} _NEWLINE 	//cout<<s<<"\n"; _NEWLINE 	cin>>t; _NEWLINE 	while(t--){ _NEWLINE 		cin>>n>>k; _NEWLINE 		//int len=strlen(n); _NEWLINE 		l r; _NEWLINE 		//cout<<len<<"\n"; _NEWLINE 		/*switch(len) _NEWLINE 		{ _NEWLINE 			case 1: r=atoll(n); break; _NEWLINE 			case 2: r=(atoll(n)-5)*2 +1; break; _NEWLINE 			case 3: r=(atoll(n)-37)*3 +3; break; _NEWLINE 			case 4: r=(atoll(n)-278)*4 +5; break; _NEWLINE 			case 5: r=(atoll(n)-2222)*5 +4; break; _NEWLINE 			case 6: r=(atoll(n)-14815)*6 +5; break; _NEWLINE 			case 7: r=5911116; _NEWLINE 		}*/ _NEWLINE 		if(n/10==0) r=n; _NEWLINE 		else if(n/100==0) r=(n-5)*2+1; _NEWLINE 		else if(n/1000==0) r=(n-37)*3 +3; _NEWLINE 		else if(n/10000==0) r=(n-278)*4 +5; _NEWLINE 		else if(n/100000==0) r=(n-2222)*5+4; _NEWLINE 		else if(n/1000000==0) r=(n-18519)*6+9; _NEWLINE 		else r=5911116; _NEWLINE 		string a=s.substr(0,r); _NEWLINE 		//cout<<a<<"\n"; _NEWLINE 		//cout<<r<<"\n"; _NEWLINE 		l pos=-1; _NEWLINE 		l cnt=-1; _NEWLINE 		do{ _NEWLINE 			cnt++; _NEWLINE 			pos=a.find(k,pos+1); _NEWLINE 			//cout<<pos<<"\n"; _NEWLINE 		}while(pos!=string::npos); _NEWLINE 		cout<<cnt<<"\n"; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
import math _NEWLINE for _ in range(input()): _NEWLINE 	n=input() _NEWLINE 	s=int(math.floor(n//10)) _NEWLINE 	 _NEWLINE 	print ((s*(s+1))/2)*10 _NEWLINE 		
#include<bits/stdc++.h> _NEWLINE #define mod 1000000007 _NEWLINE using namespace std; _NEWLINE static long long int f[1000001],inv[1000001]; _NEWLINE long long po(long long a,int b){ _NEWLINE  _INDENT  _INDENT long long x=1,y=a; _NEWLINE  _INDENT  _INDENT while(b>0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b%2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=x*y,x%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y=y*y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE long long int C(int n,int r){ _NEWLINE  _INDENT  _INDENT if(n==0||r==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT long long int ans=f[n]; _NEWLINE  _INDENT  _INDENT long long int x=inv[n-r]; _NEWLINE  _INDENT  _INDENT long long int y=inv[r]; _NEWLINE  _INDENT  _INDENT ans=(ans*x)%mod; _NEWLINE  _INDENT  _INDENT ans=(ans*y)%mod; _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE  _INDENT  _INDENT  _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT f[0]=1; _NEWLINE  _INDENT  _INDENT inv[0]=po(1,mod-2); _NEWLINE  _INDENT  _INDENT for(long long int i=1;i<1000001;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f[i]=(f[i-1]*i)%mod,inv[i]=po(f[i],mod-2); _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT while(t--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x,y,a,b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d %d %d",&x,&y,&a,&b); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x++,y++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long total=C(x+y-2,x-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //printf("%lld\n",total) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long ex=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int b1=(y-b-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b1<0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("0\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long long temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<a;i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int r,c; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=x-i,c=y-b1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=(C(i+b1,i)*C(r+c-3,c-2))%mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // temp*=temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  // temp%=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ex+=temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(ex>=mod) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ex-=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //ex=C(a+b-2,a-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT //rintf("%lld %lld\n",ex,total); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT total-=ex; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT total+=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(total>=mod) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  total-=mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n",total); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE /* _NEWLINE 400000 400000 200000 200000 _NEWLINE */
#include <iostream> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE bool matrix[1001][1001]; _NEWLINE int arr[1001][1001]; _NEWLINE  _NEWLINE inline int ones(int x1,int y1, int x2, int y2) _NEWLINE { _NEWLINE  _INDENT int ctr=arr[x2][y2]-arr[x1][y2]-arr[x2][y1]+arr[x1][y1]; _NEWLINE  _INDENT return ctr; _NEWLINE } _NEWLINE  _NEWLINE void ones(int n) _NEWLINE { _NEWLINE  _INDENT for(int x=1;x<=n;++x) _NEWLINE  _INDENT { _NEWLINE  _INDENT  for( int y=1;y<=n;++y) _NEWLINE  _INDENT  { _NEWLINE  _INDENT  _INDENT arr[x][y]=arr[x-1][y]+arr[x][y-1]-arr[x-1][y-1]; _NEWLINE  _INDENT  _INDENT if( matrix[x][y] ) arr[x][y]+=1; _NEWLINE  _INDENT  } _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT  int t,n,h,w,area,temp,m; _NEWLINE  _INDENT  _INDENT  cin>>t; _NEWLINE  _INDENT  _INDENT  while(t--) _NEWLINE  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<=n; ++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[0][i]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT arr[i][0]=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=n;++i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=1;j<=n;++j) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>matrix[i][j]; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ones(n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT area=arr[n][n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT h=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m=-1; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(area==1 || area==0) { cout<< 0 <<endl; continue; } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(h<=n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(area%h==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  w=area/h; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(w<=n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for( int i=1; i<=n-h+1; ++i ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for( int j=1; j<=n-w+1; ++j ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  temp=ones(i-1,j-1,i+h-1,j+w-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(temp>m) m=temp; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT h++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(m<0) cout<<m<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<area-m<<endl; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
T=input() _NEWLINE for _ in xrange(T): _NEWLINE 	N,C=map(int,raw_input().split()) _NEWLINE 	A=map(int,raw_input().split()) _NEWLINE 	val,temp=0,0 _NEWLINE 	for x in A: _NEWLINE 		x-=C _NEWLINE 		temp=max(0,temp+x) _NEWLINE 		val=max(temp,val) _NEWLINE 	print val _NEWLINE 	 _NEWLINE 
t=10 _NEWLINE while(t): _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT for i in range(42,1+n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=bin(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if "101010" in s: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=c+1 _NEWLINE  _INDENT  _INDENT print c _INDENT  _INDENT  _INDENT _NEWLINE 
n = int(raw_input()) _NEWLINE while n > 0: _NEWLINE 	n -= 1 _NEWLINE 	a = raw_input() _NEWLINE 	b = raw_input() _NEWLINE 	c = "" _NEWLINE 	for x in a: _NEWLINE 		#print x _NEWLINE 		if x >= 'A' and x <= 'Z': _NEWLINE 			x = b[ord(x)-ord('A')] _NEWLINE 		c += x _NEWLINE 	print c _NEWLINE 
// codechef_codes.cpp : Defines the entry point for the console application. _NEWLINE // _NEWLINE  _NEWLINE #include <iostream> _NEWLINE #include <vector> _NEWLINE #include <algorithm> _NEWLINE #include <string> _NEWLINE #include <cstring> _NEWLINE #include <cstdio> _NEWLINE #include <cassert> _NEWLINE #include <cmath> _NEWLINE #include <time.h> _NEWLINE #include <cstdlib> _NEWLINE  _NEWLINE #define boost ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0) _NEWLINE #define max(a,b) ((a)>(b)?a:b) _NEWLINE #define min(a,b) ((a)<(b)?a:b) _NEWLINE #define min_3(a,b,c) (min((a),min((b),(c)))) _NEWLINE #define INF 1000000007 _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE int a[107]; _NEWLINE  _NEWLINE int main() { _NEWLINE 	boost; _NEWLINE 	int tc,l,co,cou; _NEWLINE 	string str; _NEWLINE 	cin >> tc; _NEWLINE 	while (tc--) { _NEWLINE 		cou = 0; _NEWLINE 		cin >> str; _NEWLINE 		int ans = 0 , c1 =0; _NEWLINE 		for (int i = 0; i < str.length(); i++) { _NEWLINE 			if(str[i] == 'N')	a[i] = c1++; _NEWLINE 			else _NEWLINE 				a[i] = c1; _NEWLINE 		} _NEWLINE 		for (int i = 0; i < str.length(); i++) { _NEWLINE 			if(str[i] == 'O')	ans = min(ans+1,a[i]); _NEWLINE 		} _NEWLINE 		cout << ans << endl; _NEWLINE 	} _NEWLINE 	 _NEWLINE }
n = int(raw_input()) _NEWLINE p = map(float, raw_input().split()) _NEWLINE  _NEWLINE e = [p[0]] _NEWLINE for i in range(1,n): _NEWLINE  _INDENT  _INDENT ans = (e[i-1]+p[i-1]+1)*p[i] _NEWLINE  _INDENT  _INDENT e.append(ans) _NEWLINE  _INDENT  _INDENT  _NEWLINE for i in range(n-1): _NEWLINE  _INDENT  _INDENT e[i+1]+=e[i] _NEWLINE  _INDENT  _INDENT  _NEWLINE print e[n-1]
mod = 1000000009 _NEWLINE n,k = map(int,raw_input().split()) _NEWLINE p = pow(2,k,mod) _NEWLINE ans = 1 _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT p-=1 _NEWLINE  _INDENT  _INDENT ans*=p _NEWLINE  _INDENT  _INDENT ans%= mod _NEWLINE print ans
 _NEWLINE  _NEWLINE  _NEWLINE for b in range(input()): _NEWLINE  _INDENT  _INDENT c = input() _NEWLINE  _INDENT  _INDENT d = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT d.sort() _NEWLINE  _INDENT  _INDENT for k in range(d[0],0,-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for l in d: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l % k == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if flag == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE 
#include <stdio.h> _NEWLINE #include <vector> _NEWLINE #define MX_N 1010 _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE vector<int> arr[MX_N]; _NEWLINE int team[MX_N]; _NEWLINE int t,n,error; _NEWLINE  _NEWLINE void dfs(int i,int T) { _NEWLINE 	if(team[i]) { _NEWLINE 		if(team[i] != T) error = 1; _NEWLINE 		return; _NEWLINE 	} _NEWLINE 	team[i] = T; _NEWLINE 	for(int j=0;j<arr[i].size();j++) { _NEWLINE 		dfs(arr[i][j],-T); _NEWLINE 	} _NEWLINE } _NEWLINE int main() { _NEWLINE 	int i,j; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) { _NEWLINE 		scanf("%d",&n); _NEWLINE 		for(i=1;i<=n;i++) { _NEWLINE 			team[i] = 0; _NEWLINE 			while(!arr[i].empty()) arr[i].pop_back(); _NEWLINE 		} _NEWLINE 		for(i=1;i<=n;i++) { _NEWLINE 			int x,y; _NEWLINE 			scanf("%d",&x); _NEWLINE 			while(x--) { _NEWLINE 				scanf("%d",&y); _NEWLINE 				arr[i].push_back(y); _NEWLINE 				arr[y].push_back(i); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		error = 0; _NEWLINE 		for(i=1;i<=n;i++) { _NEWLINE 			if(!team[i]) { _NEWLINE 				dfs(i,1); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(error) { _NEWLINE 			printf("-1"); _NEWLINE 		}else { _NEWLINE 			for(i=1;i<=n;i++) { _NEWLINE 				if(team[i] == 1) _NEWLINE 					printf("L"); _NEWLINE 				else _NEWLINE 					printf("R"); _NEWLINE 			} _NEWLINE 		} _NEWLINE 		printf("\n"); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
/* _NEWLINE  * To change this template, choose Tools | Templates _NEWLINE  * and open the template in the editor. _NEWLINE  */ _NEWLINE  _NEWLINE /** _NEWLINE  * _NEWLINE  * @author Saransh _NEWLINE  */ _NEWLINE import java.io.*; _NEWLINE import java.util.*; _NEWLINE public class Main { _NEWLINE  _NEWLINE  _INDENT  _INDENT /** _NEWLINE  _INDENT  _INDENT  * @param args the command line arguments _NEWLINE  _INDENT  _INDENT  */ _NEWLINE  _INDENT  _INDENT static boolean marked[]; _NEWLINE  _INDENT  _INDENT static int memo[]; _NEWLINE  _INDENT  _INDENT public static void main(String[] args) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT // TODO code application logic here _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT try _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ParserLose p=new ParserLose(System.in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT marked=new boolean[100001]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memo=new int[100001]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<100000;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT find(i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int t=p.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(t-->0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int m=find(p.nextInt()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT catch(Exception e) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT public static int find(int t) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(t<=0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(t==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT marked[t]=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memo[t]=t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(t==2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT marked[t]=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memo[t]=t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(t==3) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT marked[t]=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT memo[t]=t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 3; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(marked[t]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return memo[t]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int min=Integer.MAX_VALUE; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=1;i<=t/2;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(t%i==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int k=1+find(t-i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(k<min) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT min=k; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT marked[t]=true; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memo[t]=min; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return min; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT public static int dig(int a) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return a; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a%10+dig(a/10); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT public static void check(String a,String b) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char tmp1[]=a.toCharArray(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char tmp2[]=b.toCharArray(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(tmp1.length!=tmp2.length) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println("NO"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Arrays.sort(tmp1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Arrays.sort(tmp2); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<tmp1.length;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(tmp1[i]!=tmp2[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println("NO"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT System.out.println("YES"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE } _NEWLINE  _NEWLINE class ParserLose _NEWLINE { _NEWLINE  _INDENT  _INDENT final private int BUFFER_SIZE = 1 << 16; _NEWLINE  _INDENT  _INDENT private DataInputStream din; _NEWLINE  _INDENT  _INDENT private byte[] buffer; _NEWLINE  _INDENT  _INDENT private int bufferPointer,bytesRead; _NEWLINE  _INDENT  _INDENT public ParserLose(InputStream in) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT din=new DataInputStream (in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT buffer=new byte[BUFFER_SIZE]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bufferPointer=bytesRead=0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT public int nextInt() throws Exception _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int ret=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT byte c =read(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(c<=' ')c=read(); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT do{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ret=ret*10+(c-'0'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=read(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT }while(c>' '); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return ret; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT public String nextString() throws Exception _NEWLINE 	 _INDENT  { _NEWLINE 		 _INDENT  StringBuffer sb=new StringBuffer(""); _NEWLINE 		 _INDENT  byte c = read(); _NEWLINE 		 _INDENT  while (c <= ' ') c = read(); _NEWLINE 		 _INDENT  do _NEWLINE 		 _INDENT  { _NEWLINE 			 _INDENT  sb.append((char)c); _NEWLINE 			 _INDENT  c=read(); _NEWLINE 		 _INDENT  }while(c>' '); _NEWLINE 		 _INDENT  return sb.toString(); _NEWLINE 	 _INDENT  } _NEWLINE 	 _INDENT  public char nextChar() throws Exception _NEWLINE 	 _INDENT  { _NEWLINE 		 _INDENT  byte c=read(); _NEWLINE 		 _INDENT  while(c<=' ') c= read(); _NEWLINE 		 _INDENT  return (char)c; _NEWLINE 	 _INDENT  } _NEWLINE  _INDENT  _INDENT private byte read() throws Exception _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(bufferPointer==bytesRead)fillBuffer(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return buffer[bufferPointer++]; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT private void fillBuffer() throws Exception _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT bytesRead=din.read(buffer,bufferPointer=0,BUFFER_SIZE); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(bytesRead==-1)buffer[0]=-1; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE }
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	int t; _NEWLINE 	cin>>t; _NEWLINE 	while(t--){ _NEWLINE 	 _INDENT  _INDENT string a,b; _NEWLINE 	 _INDENT  _INDENT cin>>a>>b; _NEWLINE 	 _INDENT  _INDENT map<char,int>count1; _NEWLINE 	 _INDENT  _INDENT map<char,int>count2; _NEWLINE 	 _INDENT  _INDENT for(int i=0;i<a.length();i++) count1[a[i]]++; _NEWLINE 	 _INDENT  _INDENT for(int i=0;i<b.length();i++) count2[b[i]]++; _NEWLINE 	 _INDENT  _INDENT bool flag=true; _NEWLINE 	 _INDENT  _INDENT for(char i='a';i<='z';i++){ _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT if(count1!=count2){ _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag=false; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT if(flag) cout<<"YES\n"; _NEWLINE 	 _INDENT  _INDENT else cout<<"NO\n"; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE using namespace std; _NEWLINE #include<stdio.h> _INDENT _NEWLINE int dp[1002][1002]; _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE 	int t,m,n,k; _NEWLINE 	scanf("%d", &t); _NEWLINE 	while(t--) _NEWLINE 	{ _NEWLINE 		scanf("%d %d %d", &m, &n, &k); _NEWLINE 		m++; _NEWLINE 		n++; _NEWLINE 		dp[0][1] = 1; _NEWLINE 		for(int i = 1; i <= m; i++) _NEWLINE 			for(int j = 1; j <= n; j++) _NEWLINE 				dp[i][j] = (dp[i][j-1] + dp[i-1][j])%k; _NEWLINE 		/* _NEWLINE 		for(int i = 1; i <= m; i++) _NEWLINE 		{ _NEWLINE 			for(int j = 1; j <= n; j++) _NEWLINE 			cout<<dp[i][j]<<" "; _NEWLINE 			cout<<"\n"; _NEWLINE 		} _NEWLINE 		*/		 _NEWLINE 		printf("%d\n", dp[m][n]); _NEWLINE 	} _NEWLINE } 
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t,i; _NEWLINE  _INDENT  _INDENT scanf("%d",&t); _NEWLINE  _INDENT  _INDENT for(i=1;i<=t;i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int x,y,z,s,p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d%d%d",&x,&y,&z); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p=x+y; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=z%p; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(s>x||s==0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("Anish\n"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("Aman\n"); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<stack> _NEWLINE #include<string> _NEWLINE #include<queue> _NEWLINE #include<stdlib.h> _NEWLINE #include<vector> _NEWLINE #include<cmath> _NEWLINE #define pb push_back _NEWLINE #define big long long _NEWLINE #define FOR(i,a,b) for(i=a;i<=b;i++) _NEWLINE #define RFOR(i,a,b) for(i=a;i>=b;i--) _NEWLINE #define vi vector<int> _NEWLINE #define vb vector<big> _NEWLINE using namespace std; _NEWLINE big fact(big n) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(n==0 || n==1) return 1; _NEWLINE  _INDENT  _INDENT return n*fact(n-1); _NEWLINE } _NEWLINE int main() { _NEWLINE 	big l,t,n,i,j,k,temp,c,*arr,sum,f; _NEWLINE 	double x1=0,x2,y1,y2,x3,y3,m1,m2,m3; _NEWLINE 	int h,num=0,prev; _NEWLINE 	vb v,line; _NEWLINE 	string s; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT while(t-->0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<4*n*n*n+6*n*n*(n-1)<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE 	return 0; _NEWLINE }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE int t,n,a,b,c,i,j; _NEWLINE long long int e; _NEWLINE scanf("%d",&t); _NEWLINE while(t--) _NEWLINE { _NEWLINE e=0; _NEWLINE scanf("%d %d %d %d",&n,&a,&b,&c); _NEWLINE for(i=0;i<=a&&i<=n;i++) _NEWLINE { _NEWLINE for(j=0;j<=b&&j<=n-i;j++) _NEWLINE { _NEWLINE e++; _NEWLINE if(c>(n-(i+j))) _NEWLINE { _NEWLINE e=e+(n-(i+j)); _NEWLINE } _NEWLINE else _NEWLINE { _NEWLINE e=e+c; _NEWLINE } _NEWLINE } _NEWLINE } _NEWLINE printf("%lld\n",e); _NEWLINE } _NEWLINE return 0; _NEWLINE } 
 _NEWLINE import java.util.Scanner; _NEWLINE  _NEWLINE class decreasingstrings _NEWLINE { _NEWLINE  _INDENT  _INDENT public static void main(String args[])throws Exception _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT try{ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Scanner in=new Scanner(System.in); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT long t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int n,r,d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT String st="zyxwvutsrqponmlkjihgfedcba"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t=in.nextLong(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(t-->0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n=in.nextInt(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT String res=""; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(n<=25) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(st.substring((25-n),st.length())); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  r=n%25; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  d=n/25; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(r>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  res=st.substring(25-r); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for(int i=0;i<d;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  res+=st; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  System.out.println(res); _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT catch(Exception e) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT e.printStackTrace(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE } _NEWLINE 
import java.lang.*; _NEWLINE import java.io.*; _NEWLINE import java.net.*; _NEWLINE import java.util.*; _NEWLINE  _NEWLINE class Main { _NEWLINE  _NEWLINE  _INDENT  _INDENT public static String recRemove(String orig, String remove) { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT String remStart = "<" + remove + ">"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT String remEnd = "</" + remove + ">"; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int end = orig.indexOf(remEnd); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(end==-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  return orig; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT String newString1 = orig.substring(0, end); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT String newString2 = orig.substring(end + remEnd.length(), orig.length()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int start = newString1.lastIndexOf(remStart); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT newString1 = newString1.substring(0, start); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT orig = newString1 + newString2; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return recRemove(orig, remove); _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT public static String spaceAdjust(String orig) { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int index = orig.indexOf(" _INDENT "); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(index==-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return orig; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT String newString1 = orig.substring(0, index+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT String newString2 = ""; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT try { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT newString2 = orig.substring(index+2, orig.length()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT catch (Exception e) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT orig = newString1 + newString2; _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return spaceAdjust(orig); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT public static void main(String[] args) throws Exception { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT String line; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT line = br.readLine(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int t = Integer.valueOf(line).intValue(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT StringTokenizer strTok; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while ((t--) > 0) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT line = br.readLine(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT strTok = new StringTokenizer(line, "}"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT String orig = strTok.nextToken(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT String remove = strTok.nextToken(); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT strTok = new StringTokenizer(remove, ","); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT remove = strTok.nextToken(); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT strTok = new StringTokenizer(orig, "{"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT orig = strTok.nextToken(); _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT orig = spaceAdjust(recRemove(orig, remove)).trim(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(orig.length()==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println("NO TEXT"); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT System.out.println(orig); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE }
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int k , n , t , b[65]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313} _INDENT ; _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  int _INDENT i , c[100000] , a[9592] , j , r , q ; _NEWLINE  _INDENT  _INDENT  long long int s; _NEWLINE  _INDENT  _INDENT  for(i=0 ; i<100000 ; i++) _NEWLINE  _INDENT  { c[i] = i + 1 ; } _NEWLINE  _INDENT _NEWLINE  _INDENT  c[0] = 0 ; _NEWLINE  _NEWLINE  _INDENT  for(i=0 ; i<65 ; i++) _NEWLINE  _INDENT  { _INDENT  _NEWLINE  _INDENT  _INDENT  for(j=b[i] ; j<100000 ; j+=b[i]) _NEWLINE  _INDENT  _INDENT  { _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  if(c[j-1]>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { if(c[j-1]!=b[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c[j-1]=0 ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  } _NEWLINE  _INDENT  j=0; _NEWLINE  _INDENT  _INDENT  for(i=0 ; i<100000 ; i++) _NEWLINE  _INDENT  { _INDENT if( c[i]>0 ) _NEWLINE  _INDENT  _INDENT  { a[j] = c[i] ; _NEWLINE  _INDENT  _INDENT  _INDENT  j++ ; _NEWLINE  _INDENT  _INDENT  } _NEWLINE  _INDENT  } _NEWLINE  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT _NEWLINE scanf("%d",&t); _NEWLINE while(t--) _NEWLINE { _INDENT  _INDENT s = 0 ; _NEWLINE  _INDENT  _INDENT scanf("%d",&n); _NEWLINE  _INDENT  _INDENT scanf("%d",&k); _INDENT _NEWLINE  _INDENT  _INDENT if(k==0) _NEWLINE  _INDENT  _INDENT { _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=n-2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s*=(s+1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s /=2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s+=n-2+1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("%llu\n",s); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT else _NEWLINE  _INDENT  _INDENT if(k>9592) _NEWLINE  _INDENT  _INDENT { printf("0\n"); } _NEWLINE  _INDENT else _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT if(a[k-1]<=n) _NEWLINE  _INDENT  _INDENT s=n-a[k-1]+1; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT s = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for( i=1 ; i<9592 ; i++ ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  { _INDENT  if((i+k-1>=9592)||(a[i+k-1]>n)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  break ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r = n + 1 - a[i+k-1] ; _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q = a[i] - a[i-1] ; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  s+=r*q ; _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  } _NEWLINE  _INDENT  _INDENT printf("%llu\n",s) ; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE } _NEWLINE return 0 ; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _NEWLINE 
#include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <string.h> _NEWLINE #include <cstring> _NEWLINE #define oo (int)1e9 _NEWLINE #define fill( a , v ) memset( a , v , sizeof (a) ) _NEWLINE #define bits( x ) __builtin_popcount( x ) _NEWLINE #define gcd( a , b ) __gcd( a, b ) _NEWLINE #define lcm( a , b ) (a/gcd( a, b ) ) * b _NEWLINE #define add push_back _NEWLINE #define s(n) scanf( "%d" , &n ) _NEWLINE const int mxn = 10000 + 10; _NEWLINE typedef long long ll; _NEWLINE  _NEWLINE using namespace std; _NEWLINE int dx[]={0,0,1,-1}; _NEWLINE int dy[]={1,-1,0,0}; _NEWLINE  _NEWLINE int dp[16][1<<16][2]; _NEWLINE short vis[16][1<<16][2]; _NEWLINE int id; _NEWLINE int mat[4][4]; _NEWLINE int a[4][4]; _NEWLINE  _NEWLINE int solve( int prev , int mask , int turn ) _NEWLINE { _NEWLINE 	if( !mask )return 0; _NEWLINE 	 _NEWLINE 	int &d = dp[prev][mask][turn]; _NEWLINE 	short &v = vis[prev][mask][turn]; _NEWLINE 	 _NEWLINE 	if( v == id )return d; _NEWLINE 	v = id; _NEWLINE 	 _NEWLINE 	if( turn ) d = oo; _NEWLINE 	else d = -oo; _NEWLINE 	 _NEWLINE 	if( turn ) _NEWLINE 	{ _NEWLINE 		int x = prev / 4; _NEWLINE 		int y = prev % 4; _NEWLINE 		 _NEWLINE 		bool neighbour = 0; _NEWLINE 		for(int i=0;i<4;i++) _NEWLINE 		{ _NEWLINE 			int nx = x + dx[i]; _NEWLINE 			int ny = y + dy[i]; _NEWLINE 			 _NEWLINE 			if( nx >= 0 && ny >= 0 && nx < 4 && ny < 4 ) _NEWLINE 			{ _NEWLINE 				int mm = mat[nx][ny]; _NEWLINE 				 _NEWLINE 				if( mask & mm ) _NEWLINE 				{ _NEWLINE 					neighbour = 1; _NEWLINE 					d = min( d , -a[nx][ny] + solve( nx * 4 + ny , mask ^ mm , !turn ) ); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		if( !neighbour ) _NEWLINE 		{ _NEWLINE 			for(int i=0;i<16;i++) _NEWLINE 			 if( mask & 1<<i ) _NEWLINE 			 d = min( d , -a[i/4][i%4] + solve( i , mask ^ 1<<i , !turn ) _INDENT ); _NEWLINE 		} _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		int x = prev / 4; _NEWLINE 		int y = prev % 4; _NEWLINE 		 _NEWLINE 		bool neighbour = 0; _NEWLINE 		for(int i=0;i<4;i++) _NEWLINE 		{ _NEWLINE 			int nx = x + dx[i]; _NEWLINE 			int ny = y + dy[i]; _NEWLINE 			 _NEWLINE 			if( nx >= 0 && ny >= 0 && nx < 4 && ny < 4 ) _NEWLINE 			{ _NEWLINE 				int mm = mat[nx][ny]; _NEWLINE 				 _NEWLINE 				if( mask & mm ) _NEWLINE 				{ _NEWLINE 					neighbour = 1; _NEWLINE 					d = max( d , a[nx][ny] + solve( nx * 4 + ny , mask ^ mm , !turn ) ); _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		 _NEWLINE 		if( !neighbour ) _NEWLINE 		{ _NEWLINE 			for(int i=0;i<16;i++) _NEWLINE 			 if( mask & 1<<i ) _NEWLINE 			 d = max( d , a[i/4][i%4] + solve( i , mask ^ 1<<i , !turn ) _INDENT ); _NEWLINE 		}		 _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return d; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	for(int i=0,c=1;i<4;i++) _NEWLINE 	 for(int j=0;j<4;j++,c<<=1) _NEWLINE 	 _INDENT mat[i][j] = c; _NEWLINE 	 _INDENT  _NEWLINE 	 _INDENT  _NEWLINE 	int runs; _NEWLINE 	s( runs ); _NEWLINE 	 _NEWLINE 	while( runs-- ) _NEWLINE 	{ _NEWLINE 		++id; _NEWLINE 		for(int i=0;i<4;i++) _NEWLINE 		 for(int j=0;j<4;j++) _NEWLINE 		 _INDENT s( a[i][j] ); _NEWLINE 		 _INDENT  _NEWLINE 		int soln = -oo; _NEWLINE 		int mm = (1<<16)-1; _NEWLINE 		 _NEWLINE 		for(int i=0;i<16;i++) _NEWLINE 		 soln = max( soln , a[i/4][i%4] + solve( i , mm ^ 1<<i , 1 ) _INDENT ); _NEWLINE 		 _INDENT _NEWLINE 		 printf( "%d\n" , soln ); _NEWLINE 	} _NEWLINE } _NEWLINE 
#include <stdio.h> _NEWLINE  _INDENT _NEWLINE  _INDENT _NEWLINE long long int mod=1000000007; _INDENT _NEWLINE  _NEWLINE long long int p_cal(long long int x, long long int y) _NEWLINE { _NEWLINE  _INDENT  _INDENT long long int temp; _NEWLINE  _INDENT  _INDENT if( y == 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1; _NEWLINE  _INDENT  _INDENT temp = p_cal(x, y/2); _NEWLINE  _INDENT  _INDENT if (y%2 == 0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (temp*temp)%mod; _NEWLINE  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return (((x*temp)%mod)*temp)%mod; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT long long int n,T,p,ans,x=2; _INDENT _NEWLINE  _INDENT scanf("%lld",&T); _NEWLINE  _INDENT while(T--) _NEWLINE  _INDENT { _NEWLINE 	 _INDENT scanf("%lld",&n); _NEWLINE  _INDENT 	 _INDENT p=p_cal(2,n-1); _NEWLINE  _INDENT 	 _INDENT printf("%lld\n",p); _NEWLINE  } _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE 
#include<iostream> _NEWLINE #include <stdio.h> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; cin>>t; _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int size=0; cin>>size; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int s=0,c=0,sg=0,cg=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT char tt; cin.get(tt); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<size;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT char d; cin>>d; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(d=='S') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s==4) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=0;c=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sg++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else if(c==4) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=0;c=0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cg++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<sg<<"-"<<cg; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(s>0 || c>0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(s==3) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=40; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=s*15; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(c==3) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=40; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else c=c*15; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<","<<s<<"-"<<c<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
#!usr/bin/python _NEWLINE #function for removing zeros at the end _NEWLINE def cut(n): _NEWLINE  _INDENT  _NEWLINE  _INDENT if (n==0): _INDENT _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _NEWLINE  _INDENT while(n>0): _NEWLINE  _INDENT  _INDENT if(n%10 == 0): _NEWLINE  _INDENT  _INDENT  _INDENT n=n/10; _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT break; _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT return n; _NEWLINE  _INDENT  _NEWLINE  _INDENT  _NEWLINE  _INDENT  _NEWLINE case=input(); _NEWLINE #taking input _NEWLINE string=[]; _NEWLINE for i in range(case) : _NEWLINE 	string.append(raw_input()); _NEWLINE  _INDENT  _INDENT  _INDENT  	 _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	 _NEWLINE  _NEWLINE  _NEWLINE #operating on them _NEWLINE for i in range(case): _NEWLINE 	 _NEWLINE 	list=string[i].lower().split('x'); _NEWLINE 	 _NEWLINE 	l=len(list); _NEWLINE 	 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #got the list of nos _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if ('0' in list): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print "Robot hanged."; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t=1; _NEWLINE 	for j in list: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	j=int(j); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	j=cut(j*t); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	t=j; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t=t%10;	 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	 _NEWLINE 	print t; _NEWLINE 		 _NEWLINE 		 _NEWLINE 		 _NEWLINE 		 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT 
import sys _NEWLINE  _NEWLINE for __ in range(input()) : _NEWLINE  _INDENT  _INDENT n , k = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT lists = map(int,sys.stdin.readline().split()) _NEWLINE  _INDENT  _INDENT dp = [0]*(k+1) _NEWLINE  _INDENT  _INDENT dp[0]=1 _NEWLINE  _INDENT  _INDENT for i in lists : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(k-i,-1,-1) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if dp[k] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if dp[j] : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dp[j+i] = 1 _NEWLINE  _INDENT  _INDENT print dp[k] _NEWLINE 
#include	<iostream> _NEWLINE  _NEWLINE using std::cin; _NEWLINE using std::cout; _NEWLINE using std::endl; _NEWLINE  _NEWLINE #include	<cstring> _NEWLINE  _NEWLINE  _NEWLINE #define		Chars		22 _NEWLINE #define		base		1000000000 _NEWLINE  _NEWLINE int main(){ _NEWLINE 	int cases, i, j; _NEWLINE 	char ch; _NEWLINE 	char string[] = "welcome to conscientia"; _NEWLINE 	long int *cal1 = new long int[Chars]; _NEWLINE 	long int *cal2 = new long int[Chars]; _NEWLINE 	cin >> cases; _NEWLINE 	cin.get(); _NEWLINE 	for(i = 0; i < cases; ++i){ _NEWLINE 		memset(cal1, 0, sizeof(int) * Chars); _NEWLINE 		memset(cal2, 0, sizeof(int) * Chars); _NEWLINE 		while((ch = cin.get()) != '\n'){ _NEWLINE 			for(j = 0; j < Chars; ++j){ _NEWLINE 				if(ch == string[j]){ _NEWLINE 					if(j == 0) _NEWLINE 						cal2[j] = _INDENT (cal1[j] + 1) % base; _NEWLINE 					else _NEWLINE 						cal2[j] = (cal1[j] + cal1[j - 1]) % base; _NEWLINE 				} else { _NEWLINE 					cal2[j] = cal1[j]; _NEWLINE 					if(cal2[j] == 0) _NEWLINE 						break; _NEWLINE 				} _NEWLINE 			} _NEWLINE 			memcpy(cal1, cal2, sizeof(int) * Chars); _NEWLINE 			memset(cal2, 0, sizeof(int) * Chars);			 _NEWLINE 		} _NEWLINE 		cout << cal1[Chars - 1] << endl; _NEWLINE 	} _NEWLINE 	return 0;	 _NEWLINE }
#include<stdio.h> _NEWLINE #include<math.h> _NEWLINE #define MAX_PRIME 3402 _NEWLINE  _NEWLINE int prime[MAX_PRIME]; _NEWLINE bool chkPrime[1000002]={true,true}; _NEWLINE  _NEWLINE inline void initPrimes() { _NEWLINE  _INDENT  _INDENT  _INDENT  const int lim = 31627; _NEWLINE  _INDENT  _INDENT  _INDENT  int currPos=1,primeCount=0; _NEWLINE  _INDENT  _INDENT  _INDENT  do { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  while(chkPrime[currPos]) currPos++; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  prime[primeCount++]=currPos; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  int temp=currPos; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  while((temp+=currPos)<=lim) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  chkPrime[temp]=true; _NEWLINE 		 _INDENT  currPos++; _NEWLINE  _INDENT  _INDENT  _INDENT  } while(currPos<=MAX_PRIME); _NEWLINE 	 _INDENT  while(currPos<=lim){ _NEWLINE 	 _INDENT  _INDENT  _INDENT  if(!chkPrime[currPos]) _NEWLINE 			 _INDENT prime[primeCount++]=currPos; _INDENT _NEWLINE 		 _INDENT  currPos++; _NEWLINE 	 _INDENT  } _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	initPrimes(); _NEWLINE  _INDENT  _INDENT int testCases; _NEWLINE 	scanf("%d",&testCases); _NEWLINE  _INDENT  _INDENT while(testCases--){ _NEWLINE  _INDENT  _INDENT  _INDENT  int a,b,i,j; _NEWLINE 	 _INDENT  scanf("%d%d",&a,&b); _NEWLINE  _NEWLINE 	 _INDENT  for(i=b-a;i>=0;i--) _NEWLINE 	 _INDENT  _INDENT  _INDENT  chkPrime[i]=true; _NEWLINE 	 _INDENT  if(a==1) _NEWLINE 	 _INDENT  _INDENT  _INDENT chkPrime[0]=false; _NEWLINE 	 _INDENT  int lim = (int)sqrt((double)b); _NEWLINE 	 _INDENT  for(i=0;prime[i]<=lim;i++){ _NEWLINE 		 _INDENT  j=a-a%prime[i]; _NEWLINE 		 _INDENT  if(j<a) _NEWLINE 			 _INDENT  j+=prime[i]; _NEWLINE 		 _INDENT  while(j<=b){ _NEWLINE 		 _INDENT  _INDENT  _INDENT  if(j!=prime[i]) _NEWLINE 				 _INDENT  chkPrime[j-a]=false; _NEWLINE 		 _INDENT  _INDENT  _INDENT  j+=prime[i]; _NEWLINE 		 _INDENT  } _NEWLINE 	 _INDENT  } _NEWLINE 	 _INDENT  int count=0; _NEWLINE 	 _INDENT  for(i=2;i<=b-a;i++) _NEWLINE 	 _INDENT  _INDENT  _INDENT  if(chkPrime[i-2]&&chkPrime[i]) _NEWLINE 			 _INDENT  count++; _NEWLINE  _INDENT  _INDENT  _INDENT  printf("%d\n",count); _NEWLINE  _INDENT  _INDENT } _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE #define pb(x) push_back(x) _NEWLINE #define mp(i,j) make_pair(i,j) _NEWLINE #define ll long long _INDENT _NEWLINE int lolol; _NEWLINE #define S(x) lolol=scanf("%l64d", &x) _NEWLINE #define s(x) lolol=scanf("%d", &x) _NEWLINE #define getchar_unlocked getchar _NEWLINE using namespace std; _NEWLINE inline int scan(){ _NEWLINE  _INDENT  _INDENT char c = getchar_unlocked(); _NEWLINE  _INDENT  _INDENT int x = 0; _NEWLINE  _INDENT  _INDENT while(c<'0'||c>'9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT while(c>='0'&&c<='9'){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=(x<<1)+(x<<3)+c-'0'; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=getchar_unlocked(); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return x; _NEWLINE } _NEWLINE int main(){ _NEWLINE  _INDENT  _INDENT ll n,m; _NEWLINE  _INDENT  _INDENT n=scan(); m=scan(); _NEWLINE  _INDENT  _INDENT vector<pair<ll,ll> > a[n+1]; _NEWLINE  _INDENT  _INDENT while(m--){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll x,y,z; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x=scan(); y=scan(); z=scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[x].pb(mp(y,2*z)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[y].pb(mp(x,2*z)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT vector<ll> pol; _NEWLINE  _INDENT  _INDENT ll k; k=scan(); _NEWLINE  _INDENT  _INDENT for(int i=0; i<k; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll x; x=scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pol.pb(x); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ll p; _INDENT _NEWLINE  _INDENT  _INDENT p=scan(); _NEWLINE  _INDENT  _INDENT vector<ll> boost; _NEWLINE  _INDENT  _INDENT for(int i=0; i<p; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll x; x=scan(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT boost.pb(x); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ll st,en; st=scan(); en=scan(); _NEWLINE  _INDENT  _INDENT ll dist[n+1]; memset(dist,-1,sizeof dist); _NEWLINE  _INDENT  _INDENT priority_queue<pair<ll,ll> > q; _NEWLINE  _INDENT  _INDENT q.push(mp(0,en)); _NEWLINE  _INDENT  _INDENT dist[en]=0; _NEWLINE  _INDENT  _INDENT while(!q.empty()){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll node=q.top().second; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll sz=a[node].size(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0; i<sz; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll nbr=a[node][i].first; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll wt=a[node][i].second; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(dist[nbr]==-1 || dist[nbr]>dist[node]+wt){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[nbr]=dist[node]+wt; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push(mp(-dist[nbr],nbr)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT ll dist_thief=dist[st]; _NEWLINE  _INDENT  _INDENT if(dist_thief==-1){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0; i<k; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(dist[pol[i]]>=0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(dist[pol[i]]<=dist[st]){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<-1<<endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0; i<p; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(dist[boost[i]]>=0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[boost[i]].pb(mp(en,dist[boost[i]]/2)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[en].pb(mp(boost[i],dist[boost[i]]/2)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT memset(dist,-1,sizeof(dist)); _NEWLINE  _INDENT  _INDENT dist[en]=0; _NEWLINE  _INDENT  _INDENT q.push(mp(0,en)); _NEWLINE  _INDENT  _INDENT while(!q.empty()){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll node=q.top().second; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q.pop(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll sz=a[node].size(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0; i<sz; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll nbr=a[node][i].first; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ll wt=a[node][i].second; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(dist[nbr]==-1 || dist[nbr]>dist[node]+wt){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dist[nbr]=dist[node]+wt; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT q.push(mp(-dist[nbr],nbr)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for(int i=0; i<k; i++){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(dist[pol[i]]<=(dist_thief)){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT cout<<(dist_thief/2); _NEWLINE  _INDENT  _INDENT  _NEWLINE }
while(1): _NEWLINE  try: _NEWLINE  _INDENT  t=raw_input() _NEWLINE  _INDENT  a=[] _NEWLINE  _INDENT  while(len(a)==0): _NEWLINE  _INDENT  _INDENT  a=raw_input().split() _NEWLINE  _INDENT  sum=0 _NEWLINE  _INDENT  a.reverse() _NEWLINE  _INDENT  x="" _NEWLINE  _INDENT  k=len(a) _NEWLINE  _INDENT  for j in range(k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  a[j]=int(a[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  sum=sum+a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  x=x+str(a[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  if(j!=k-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  x=x+" " _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  print x _NEWLINE  _INDENT  print sum _NEWLINE  except EOFError: break _INDENT 
def tidrice(): _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT for t in xrange(T): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT N = int(raw_input()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT votes = {} _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for n in xrange(N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT user, score = raw_input().split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if score == '+': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT votes[user] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT votes[user] = -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print sum(votes.values()) _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE  _INDENT  _INDENT tidrice()
import sys _NEWLINE  _NEWLINE dp , MOD = [] , 10**9+7 _NEWLINE def compute() : _NEWLINE  _INDENT  _INDENT dp.extend([1,1]) _NEWLINE  _INDENT  _INDENT for i in range(2,10**6+1) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp.append(dp[i-1]+dp[i-2]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dp[-1] = dp[-1]%MOD _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE if __name__ == "__main__" : _NEWLINE  _INDENT  _INDENT compute() _NEWLINE  _INDENT  _INDENT for __ in range(input()) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print dp[input()]
n=int(input()) _NEWLINE def fun( n): _NEWLINE 	if n==0: _NEWLINE 		return 1 _NEWLINE 	if n==1: _NEWLINE 		return 2 _NEWLINE 	return 2*fun(n-1) _NEWLINE ans=fun(n)	 _NEWLINE print ans	 _NEWLINE 	 _NEWLINE 	 _NEWLINE  _NEWLINE  _INDENT  
def fact(n): _NEWLINE  _INDENT  _INDENT if(n<=1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return fact(n-1)*n _NEWLINE t=input() _NEWLINE while t: _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT r=len(raw_input().strip())-1 _NEWLINE  _INDENT  _INDENT print fact(2*r)/(fact(r)*fact(r+1)) _NEWLINE 
test=raw_input() _NEWLINE t=int(test) _NEWLINE while(t>0): _NEWLINE 	lst=[] _NEWLINE 	n=int(raw_input()) _NEWLINE 	lst=map(int,raw_input().split()) _NEWLINE 	if((max(lst)-min(lst))>1): _NEWLINE 		print "BAD" _NEWLINE 	else: _NEWLINE 		print "GOOD" _NEWLINE 	t=t-1
import sys _NEWLINE nCase = int(sys.stdin.readline()) _NEWLINE for i in range(nCase): _NEWLINE 	n = int(sys.stdin.readline()) - 1 _NEWLINE 	print pow(2,n,1000)
t=int(raw_input()) _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT n,m=[int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT p=[int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT if n==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print m _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans=m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range (len(p)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if p[i]<=m: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if p[j]>p[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=m/p[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=m-c*p[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=a+c*p[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a>ans: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ans _NEWLINE  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT 
t=input() _NEWLINE for x in range(0,t): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT s=bin(n) _NEWLINE  _INDENT  _INDENT cnt=s.count('1') _NEWLINE  _INDENT  _INDENT print cnt _NEWLINE 
t=input() _NEWLINE for _ in xrange(t): _NEWLINE 	a,b=map(int,raw_input().split()) _NEWLINE 	print max(a,b),(a+b)
/* Divanshu Garg */ _NEWLINE #include <vector> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <queue> _NEWLINE #include <deque> _NEWLINE #include <stack> _NEWLINE #include <bitset> _NEWLINE #include <algorithm> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <iomanip> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <cstdlib> _NEWLINE #include <ctime> _NEWLINE #include <cstring> _NEWLINE #include <climits> _NEWLINE #include <cctype> _NEWLINE #include <cassert> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define ull unsigned long long _NEWLINE #define ill long long int _NEWLINE #define pii pair<int,int> _NEWLINE #define piii pair< int,pii > _NEWLINE #define pb(x) push_back(x) _NEWLINE #define F(i,a,n) for(i=(a);i<(n);++i) _NEWLINE #define FD(i,a,n) for(i=(a);i>=(n);--i) _NEWLINE #define FE(it,x) for(it=x.begin();it!=x.end();++it) _NEWLINE #define V(x) vector<x> _NEWLINE #define S(x) scanf("%d",&x) _NEWLINE #define Sl(x) scanf("%lld",&x) _NEWLINE #define M(x,i) memset(x,i,sizeof(x)) _NEWLINE #define debug(i,sz,x) F(i,0,sz){cout<<x[i]<<" ";}cout<<endl _NEWLINE #define fr first _NEWLINE #define se second _NEWLINE  _NEWLINE int k; _NEWLINE int grundy[1005]; _NEWLINE  _NEWLINE int f(int n) { _NEWLINE  _INDENT  _INDENT if ( n < k ) return 0; _NEWLINE 	if ( n == k ) return 1; _NEWLINE  _INDENT  _INDENT if ( grundy[n] != -1 ) return grundy[n]; _NEWLINE  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT set<int> mex; _NEWLINE  _INDENT  _INDENT F(i,1,(n-k+1)) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int temp = f(i)^f(n-k-i); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mex.insert(temp); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT set<int>::iterator it; _NEWLINE  _INDENT  _INDENT int ans = 0; _NEWLINE  _INDENT  _INDENT FE(it,mex) {if (*it !=ans) break;ans++;} _NEWLINE 	grundy[n] = ans; _NEWLINE  _INDENT  _INDENT return ans; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT M(grundy,-1); _NEWLINE  _INDENT  _INDENT int t,i,n; _NEWLINE  _INDENT  _INDENT cin >> t >> k; _NEWLINE  _INDENT  _INDENT F(i,0,t) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin >> n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << (f(n)>0?"Brainy":"Clumsy") << endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE }
T=input() _NEWLINE while T: _NEWLINE  _INDENT  _INDENT T-=1 _NEWLINE  _INDENT  _INDENT tl,n=[int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT if n==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=1 _NEWLINE  _INDENT  _INDENT print pow(tl,n,pow(10,9)+7) _NEWLINE 
import math _INDENT _NEWLINE id = input() _NEWLINE t = input() _NEWLINE  _NEWLINE def equals(a,b): _NEWLINE 	if (abs(a-b) < 0.000001): _NEWLINE 		return True ; _INDENT _NEWLINE 	return False ; _INDENT _NEWLINE  _NEWLINE def dist(x1,y1,x2,y2): _INDENT _NEWLINE 	return math.sqrt((x1-x2)**2+(y1-y2)**2) ; _INDENT _NEWLINE  _NEWLINE while (t!=0) : _INDENT _NEWLINE 	s = raw_input() _NEWLINE 	s1 = s.split(" ") _INDENT _NEWLINE 	x1 = int(s1[0]) _INDENT _NEWLINE 	y1 = int(s1[1]) _NEWLINE 	x2 = int(s1[2]) _INDENT _NEWLINE 	y2 = int(s1[3]) _NEWLINE 	x3 = int(s1[4]) _INDENT _NEWLINE 	y3 = int(s1[5]) _NEWLINE  _NEWLINE 	l = [] _NEWLINE 	l.append(dist(x1,y1,x2,y2)) _NEWLINE 	l.append(dist(x2,y2,x3,y3)) _NEWLINE 	l.append(dist(x3,y3,x1,y1)) _NEWLINE 	l.sort() _NEWLINE 	a = l[0] _NEWLINE 	b = l[1] _NEWLINE 	c = l[2] _NEWLINE  _NEWLINE 	if (id == 1): _NEWLINE 		if (equals(a,b) | equals(b,c) | equals(c,a)): _NEWLINE 			print "Isosceles triangle" _INDENT _NEWLINE 		else : _INDENT _NEWLINE 			print "Scalene triangle" _NEWLINE 	if (id == 2): _NEWLINE 		if (equals(a,b) | equals(b,c) | equals(c,a)): _NEWLINE 			print "Isosceles", _NEWLINE 			if (equals(a**2+b**2,c**2)): _NEWLINE 				print "right triangle" _NEWLINE 			elif (a**2+b**2 > c**2): _NEWLINE 				print "acute triangle" _NEWLINE 			else : _NEWLINE 				print "obtuse triangle" _NEWLINE 		else : _INDENT _NEWLINE 			print "Scalene", _NEWLINE 			if (equals(a**2+b**2,c**2)): _NEWLINE 				print "right triangle" _NEWLINE 			elif (a**2+b**2 > c**2): _NEWLINE 				print "acute triangle" _NEWLINE 			else : _NEWLINE 				print "obtuse triangle" _NEWLINE 	t-= 1
#include <algorithm> _NEWLINE #include <bitset> _NEWLINE #include <cmath> _NEWLINE #include <ctime> _NEWLINE #include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <deque> _NEWLINE #include <fstream> _NEWLINE #include <functional> _NEWLINE #include <iostream> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <sstream> _NEWLINE #include <stack> _NEWLINE #include <queue> _NEWLINE #include <utility> _NEWLINE #include <vector> _NEWLINE #define mod 1000000007 _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long up[20010][22],down[20010][22]; _NEWLINE int n,k,T; _NEWLINE vector<int> adj[20010]; _NEWLINE int pre[20010]; _NEWLINE long long c[22][22],sum[22]; _NEWLINE  _NEWLINE void calc_down(int u) _NEWLINE { _NEWLINE  _INDENT  _INDENT for (int i = 0; i < adj[u].size(); i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int v = adj[u][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (pre[u] == v) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pre[v] = u; _INDENT calc_down(v); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for (int i = 0; i <= k; i++) down[u][i] = 1; _NEWLINE  _INDENT  _INDENT for (int i = 0; i < adj[u].size(); i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int v = adj[u][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (pre[u] == v) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j <= k; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int t = 0; t <= j; t++) down[u][j] = (down[u][j] + c[j][t] * down[v][t]) % mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE void calc_up(int u) _NEWLINE { _NEWLINE // _INDENT  _INDENT cout << "iter to: " << u << endl; _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for (int i = 0; i <= k; i++) sum[i] = 1; _NEWLINE  _INDENT  _INDENT for (int i = 0; i < adj[u].size(); i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int v = adj[u][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (pre[u] == v) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j <= k; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int t = 0; t <= j; t++) sum[j] = (sum[j] + c[j][t] * down[v][t]) % mod; _NEWLINE  _INDENT  _INDENT } _NEWLINE /* _INDENT  _INDENT cout << "without root" << endl; _NEWLINE  _INDENT  _INDENT for (int j = 0; j <= k; j++) cout << sum[j] << ' '; _NEWLINE  _INDENT  _INDENT cout << endl;*/ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for (int j = 0; j <= k; j++) sum[j] = (sum[j] + up[u][j]) % mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE /* _INDENT  _INDENT cout << "with root" << endl; _NEWLINE  _INDENT  _INDENT for (int j = 0; j <= k; j++) cout << sum[j] << ' '; _NEWLINE  _INDENT  _INDENT cout << endl;*/ _NEWLINE  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for (int i = 0; i < adj[u].size(); i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int v = adj[u][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (pre[u] == v) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j <= k; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int t = 0; t <= j; t++) sum[j] = (sum[j] - c[j][t] * down[v][t]) % mod; _NEWLINE /* _INDENT  _INDENT  _INDENT  _INDENT cout << "processed: " << v << endl; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j <= k; j++) cout << sum[j] << ' '; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << endl;*/ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j <= k; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int t = 0; t <= j; t++) up[v][j] = (up[v][j] + c[j][t] * sum[t]) % mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j <= k; j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int t = 0; t <= j; t++) sum[j] = (sum[j] + c[j][t] * down[v][t]) % mod; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT } _NEWLINE // _INDENT  _INDENT cout << endl; _NEWLINE  _INDENT  _INDENT for (int i = 0; i < adj[u].size(); i++) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int v = adj[u][i]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (pre[u] == v) continue; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT calc_up(v); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE // _INDENT  _INDENT freopen("treesum.in","r",stdin); _NEWLINE // _INDENT  _INDENT freopen("treesum.ou","w",stdout); _NEWLINE  _INDENT  _INDENT scanf("%d", &T); _NEWLINE  _INDENT  _INDENT memset(c,0,sizeof(c)); _NEWLINE  _INDENT  _INDENT c[0][0] = 1; _NEWLINE  _INDENT  _INDENT for (int i = 1; i <= 20; i++) _NEWLINE  _INDENT  _INDENT  _INDENT for (int j = 0; j <= i; j++) _NEWLINE  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c[i][j] = c[i - 1][j]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (j) c[i][j] = (c[i][j] + c[i - 1][j - 1]) % mod; _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT while (T--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%d %d", &n, &k); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n; i++) adj[i].clear(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n - 1; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT int u,v; _INDENT scanf("%d %d", &u, &v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT adj[u].push_back(v); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT adj[v].push_back(u); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n; i++) pre[i] = -1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT calc_down(0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for (int j = 0; j <= k; j++) up[i][j] = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT calc_up(0); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (int i = 0; i < n; i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT long long ans = (up[i][k] + down[i][k]) % mod; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT printf("%lld\n", (ans + mod) % mod); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT printf("\n"); _NEWLINE  _INDENT  _INDENT } _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE } _NEWLINE 
#include<bits/stdc++.h> _NEWLINE #define pb(x) push_back(x) _NEWLINE #define all(x) x.begin(), x.end() _NEWLINE #define cout2(x, y) cout << x << " " << y << _INDENT endl _NEWLINE #define N 100005 _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE long long tree[2][3 * N], A1[N], A2[N], A3[N], B[3 * N], aux[N]; _NEWLINE  _NEWLINE int add = 1e9, mod = 10000; _NEWLINE map<int, int>mapa[10000]; _NEWLINE  _NEWLINE void update(int x, int id, long long val){ _NEWLINE 	 _NEWLINE 	for(int i = x; i < 3 * N; i += i&-i)tree[id][i] += val;	 _NEWLINE } _NEWLINE  _NEWLINE long long query(int x, int id){ _NEWLINE 	 _NEWLINE 	long long ans = 0; _NEWLINE 	for(int i = x; i > 0; i -= i&-i)ans += tree[id][i]; _NEWLINE 	return ans;	 _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE  _NEWLINE 	int tc = 0; _NEWLINE 	scanf("%d", &tc); _NEWLINE 	 _NEWLINE 	while(tc--){ _NEWLINE 		 _NEWLINE 		for(int i = 0; i < mod; i++)mapa[i].clear(); _NEWLINE 		memset(tree, 0, sizeof tree); _NEWLINE 		 _NEWLINE 		int P, Q, R, top = 0; _NEWLINE 		 _NEWLINE 		scanf("%d", &P); _NEWLINE 		for(int i = 0; i < P; i++)scanf("%lld", &A1[i]), B[top++] = A1[i] += add; _NEWLINE 		 _NEWLINE 		scanf("%d", &Q); _NEWLINE 		for(int i = 0; i < Q; i++)scanf("%lld", &A2[i]), B[top++] = A2[i] += add; _NEWLINE 		 _NEWLINE 		scanf("%d", &R); _NEWLINE 		for(int i = 0; i < R; i++)scanf("%lld", &A3[i]), B[top++] = A3[i] += add; _NEWLINE 		 _NEWLINE 		sort(B, B + top); _NEWLINE 		int id = 1; _NEWLINE 		 _NEWLINE 		for(int i = 0; i < top; i++) _NEWLINE 			if(mapa[B[i]%mod].find(B[i]) == mapa[B[i]%mod].end()) _NEWLINE 				mapa[B[i]%mod][B[i]] = id++; _NEWLINE 		 _NEWLINE 		for(int i = 0; i < P; i++)A1[i] = mapa[A1[i]%mod][A1[i]]; _NEWLINE 		for(int i = 0; i < Q; i++)A2[i] = mapa[A2[i]%mod][A2[i]]; _NEWLINE 		for(int i = 0; i < R; i++)A3[i] = mapa[A3[i]%mod][A3[i]]; _NEWLINE 		 _NEWLINE 		for(int i = 0; i < Q; i++){ _NEWLINE 			 _NEWLINE 			if(i < P)update(A1[i], 0, 1); _NEWLINE 			aux[i] = query(A2[i], 0); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		long long ans = 0; _NEWLINE 		for(int i = 0; i < R; i++){ _NEWLINE 			 _NEWLINE 			if(i < Q)update(A2[i], 1, aux[i]); _NEWLINE 			ans _INDENT += query(A3[i], 1); _NEWLINE 		} _NEWLINE 		 _NEWLINE 		printf("%lld\n", ans); _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE 
t = int(raw_input()) _NEWLINE for i in range(0, t): _NEWLINE 	p, y = raw_input().split() _NEWLINE 	p = int(p) _NEWLINE 	y = int(y) _NEWLINE 	for j in range(0, (y-2000)): _NEWLINE 		p = p**2 % (10**9 + 7) _NEWLINE 	print p % (10**9 + 7)	
t = input() _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT d = 9999999 _NEWLINE  _INDENT  _INDENT index = 0 _NEWLINE  _INDENT  _INDENT for j in range(10): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mn = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = max(mn)-min(mn) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if s<=d: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT d = s _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT index = j+1 _NEWLINE  _INDENT  _INDENT print index,d _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
t=raw_input() _NEWLINE t=int(t) _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT f,m=raw_input().split() _NEWLINE  _INDENT  _INDENT f=int(f); _NEWLINE  _INDENT  _INDENT m=int(m); _NEWLINE  _INDENT  _INDENT if m%f==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "CORRECT" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "WRONG" _NEWLINE  _INDENT  _INDENT t=t-1
t=input() _NEWLINE m=1000000007 _NEWLINE for i in range(0,t): _NEWLINE  _INDENT  _INDENT n=input() _NEWLINE  _INDENT  _INDENT if n<=3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "0" _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print (n*(n-3)/2)%m _NEWLINE 
#include <bits/stdc++.h> _NEWLINE #define rf freopen("inp.in", "r", stdin) _NEWLINE using namespace std; _NEWLINE  _NEWLINE const int MAX = 100005; _NEWLINE vector < int > edgeList[MAX]; _NEWLINE vector < int > bridgeTree[MAX]; _NEWLINE  _NEWLINE int A[MAX], B[MAX], V[MAX]; _NEWLINE int N, M, Q; _NEWLINE pair < int, int > DP[MAX]; _NEWLINE int D[MAX], L[MAX], cur = 0; _NEWLINE  _NEWLINE bool isBridge[MAX]; _NEWLINE  _NEWLINE void dfs(int u, int p){ _NEWLINE 	D[u] = L[u] = ++cur; _NEWLINE 	V[u] = 1; _NEWLINE 	for(int i = 0 ; i < edgeList[u].size() ; i++){ _NEWLINE 		int v = A[edgeList[u][i]] + B[edgeList[u][i]] - u; _NEWLINE 		if(v == p) continue; _NEWLINE 		if(V[v] == 0){ _NEWLINE 			dfs(v, u); _NEWLINE 			L[u] = min(L[u], L[v]); _NEWLINE 			if(L[v] > D[u]) isBridge[edgeList[u][i]] = true; _NEWLINE 		} _NEWLINE 		else L[u] = min(L[u], D[v]); _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int dfs2(int u, int p){ _NEWLINE 	int x = 1; _NEWLINE 	V[u] = 1; _NEWLINE 	for(int i = 0 ; i < bridgeTree[u].size() ; i++){ _NEWLINE 		int v = bridgeTree[u][i]; _NEWLINE 		if(v == p) continue; _NEWLINE 		x += dfs2(v, u); _NEWLINE 	} _NEWLINE 	return x; _NEWLINE } _NEWLINE  _NEWLINE long long choose(int x){ _NEWLINE 	long long res = ( (x)*1LL*(x-1) ) / 2; _NEWLINE 	return res; _NEWLINE } _NEWLINE  _NEWLINE int main(){ _NEWLINE 		 _NEWLINE 	scanf("%d %d %d\n", &N, &M, &Q); _NEWLINE 	for(int i = 1 ; i <= M ; i++){ _NEWLINE 		scanf("%d %d\n", &A[i], &B[i]); _NEWLINE 		edgeList[A[i]].push_back(i); _NEWLINE 		edgeList[B[i]].push_back(i); _NEWLINE 	} _NEWLINE  _NEWLINE 	for(int i = 1 ; i <= N ; i++){ _NEWLINE 		if(V[i] == 0) _NEWLINE 			dfs(i, -1); _NEWLINE 	} _NEWLINE  _NEWLINE 	for(int i = 1 ; i <= M ; i++){ _NEWLINE 		if(isBridge[i]){ _NEWLINE 			bridgeTree[A[i]].push_back(B[i]); _NEWLINE 			bridgeTree[B[i]].push_back(A[i]); _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	for(int i = 1 ; i <= N ; i++) V[i] = 0; _NEWLINE 	 _NEWLINE 	long long K = 0; _NEWLINE 	for(int i = 1 ; i <= N ; i++){ _NEWLINE 		if(V[i] == 0) K += choose(dfs2(i, -1)); _NEWLINE 	} _NEWLINE  _NEWLINE 	if(K >= Q){ _NEWLINE 		printf("-1\n"); _NEWLINE 		return 0; _NEWLINE 	} _NEWLINE  _NEWLINE 	++K; _NEWLINE  _NEWLINE 	DP[0].first = DP[0].second = 0; _NEWLINE 	DP[1].first = 2, DP[1].second = 1; _NEWLINE 	 _NEWLINE 	for(int i = 2; i <= K ; i++){ _NEWLINE 		DP[i].first = 1e9; _NEWLINE 		for(int j = 2 ; ; j++){ _NEWLINE 			long long p = choose(j); _NEWLINE 			if(i >= p && (DP[i - p].first + j < DP[i].first) ){ _NEWLINE 				DP[i].first _INDENT = DP[i - p].first _INDENT + j; _NEWLINE 				DP[i].second = DP[i - p].second + 1; _NEWLINE 			} _NEWLINE 			if(i < p) break; _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	int res = DP[K].first += (DP[K].second == 2); _NEWLINE 	printf("%d\n",res); _NEWLINE }
#include<iostream> _NEWLINE #include<iomanip> _NEWLINE using namespace std; _NEWLINE int main() _NEWLINE { _NEWLINE 	int x; _NEWLINE 	double w,y,z; _NEWLINE 	cin>>x>>y; _NEWLINE 	if((double)(y-x)>=0.50) _NEWLINE 	{ _NEWLINE 		if(x%5==0 ) _NEWLINE 	{ _NEWLINE 		y=(y-(double)x-0.50); _NEWLINE 	//	std::cout<<std::fixed; _NEWLINE 	//std::cout<<std::setprecision(2)<<y<<'\n'; _NEWLINE 	} _INDENT _NEWLINE } _NEWLINE std::cout<<std::fixed; _NEWLINE 	std::cout<<std::setprecision(2)<<y; _NEWLINE return 0; _NEWLINE } 
#include<bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main(){ _NEWLINE int t; _NEWLINE scanf("%d",&t); _NEWLINE while(t--){ _NEWLINE  _NEWLINE deque<int> q; _NEWLINE int n,x; _NEWLINE scanf("%d",&n); _NEWLINE for(int i=0;i<n;i++) _NEWLINE scanf("%d",&x),q.push_back(x); _NEWLINE x=0; _NEWLINE int f=0,g=0; _NEWLINE long long suml=0,sumr=0; _NEWLINE 	while(!q.empty()){ _NEWLINE 		if(suml<=sumr) _NEWLINE 		suml+=q.front()+1,q.pop_front(); _NEWLINE 		else sumr+=q.back()+1,q.pop_back(); _NEWLINE 		 _NEWLINE 	 _NEWLINE 	} _NEWLINE 	cout<<max(sumr,suml)+1<<endl; _NEWLINE } _NEWLINE return 0; _NEWLINE }
import numpy as np _NEWLINE import bisect _NEWLINE t=int(raw_input()) _NEWLINE x=np.array(list(map(int,raw_input().split()))) _NEWLINE x=sorted(x) _NEWLINE #print x _NEWLINE n=int(raw_input()) _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT p=bisect.bisect_left(x,a) _NEWLINE  _INDENT  _INDENT q=bisect.bisect_right(x,b) _NEWLINE  _INDENT  _INDENT print q-p
dp=[0 for i in xrange(100001)] _NEWLINE m=(10**9)+7 _NEWLINE dp[0]=1 _NEWLINE dp[1]=0 _NEWLINE for i in xrange(2,100001): _NEWLINE  _INDENT  _INDENT dp[i]=(i-1)*(dp[i-1]+dp[i-2])%m _NEWLINE  _NEWLINE for _ in xrange(input()): _NEWLINE  _INDENT  _INDENT print dp[input()]
#include<iostream> _NEWLINE #include<algorithm> _NEWLINE #include<functional> _NEWLINE #include<utility> _NEWLINE #include<cstring> _NEWLINE #include<climits> _NEWLINE #include<cstdlib> _NEWLINE #include<cstdio> _NEWLINE #include<vector> _NEWLINE #include<cmath> _NEWLINE #include<stack> _NEWLINE #include<queue> _NEWLINE #include<deque> _NEWLINE #include<map> _NEWLINE #include<set> _NEWLINE #define MAX LONG_LONG_MAX _NEWLINE #define MIN LONG_LONG_MIN _NEWLINE #define ll long long _NEWLINE #define mp make_pair _NEWLINE #define pb push_back _NEWLINE #define M 1000000007 _NEWLINE #define ff first _NEWLINE #define ss second _NEWLINE #define INF 1e17 _NEWLINE using namespace std; _NEWLINE  _NEWLINE ll exponentiation(ll a,ll b) _NEWLINE { _NEWLINE  _INDENT  _INDENT ll ans=1; _NEWLINE  _INDENT  _INDENT while(b>0) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  if(b%2==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ans=(ans*a)%M; _NEWLINE  _INDENT  _INDENT  _INDENT  a=(a*a)%M; _NEWLINE  _INDENT  _INDENT  _INDENT  b/=2; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return ans%M; _NEWLINE } _NEWLINE ll maxi=MIN; _NEWLINE ll fen_tree[100000]; _NEWLINE ll update(ll index,ll value) _NEWLINE { _NEWLINE  _INDENT  _INDENT while(index<=maxi) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT fen_tree[index]+=value; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT index+=((index)&(-index)); _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE ll build(ll index) _NEWLINE { _NEWLINE  _INDENT  _INDENT ll sum=0; _NEWLINE  _INDENT  _INDENT while(index>0){ _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sum+=fen_tree[index]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT index-=((index)&(-index)); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT return sum; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT ll t,n; _NEWLINE  _INDENT  _INDENT scanf("%lld",&t); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(fen_tree,0,sizeof(fen_tree)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ll sum,arr[n]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld",&arr[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT maxi=*max_element(arr,arr+n); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(int j=0;j<n;j++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum=build(arr[j]-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cout<<sum<<" "; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT update(arr[j],1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE int t,i; _NEWLINE scanf("%d",&t); _NEWLINE for(i=1;i<=t;i++) _NEWLINE { _NEWLINE long long int x,y,z,t,a,b,gcd; _NEWLINE scanf("%lld%lld",&x,&y); _NEWLINE a=x; _NEWLINE b=y; _NEWLINE while(b!=0){ _NEWLINE t=b; _NEWLINE b=a%b; _NEWLINE a=t; _NEWLINE } _NEWLINE gcd=a; _NEWLINE z=x*y/gcd; _NEWLINE printf("%lld\n%lld\n",gcd,z); _NEWLINE } _NEWLINE } _NEWLINE 
#include <iostream> _NEWLINE #include <string> _NEWLINE using namespace std; _NEWLINE  _NEWLINE bool find(string S1, string S2) { _NEWLINE 	for(int i = 0; i < S2.size(); i++) { _NEWLINE 		if (S1[i] != S2[i]) _NEWLINE 			return false; _NEWLINE 	} _NEWLINE 	return true; _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE 	int N, Q; _NEWLINE 	long long int priority[1000]; _NEWLINE 	string name[1000], query; _NEWLINE 	cin >> N; _NEWLINE 	for(int i = 0; i < N; i++) { _NEWLINE 		cin >> name[i] >> priority[i]; _NEWLINE 	} _NEWLINE 	cin >> Q; _NEWLINE 	for(int i = 0; i < Q; i++) { _NEWLINE 		long long int max = -1000000001; _NEWLINE 		int pos = -1; _NEWLINE 		cin >> query; _NEWLINE 		for(int j = 0; j < N; j++) { _NEWLINE 			if(find(name[j], query)) { _NEWLINE 				if(priority[j] > max) { _NEWLINE 					max = priority[j]; _NEWLINE 					pos = j; _NEWLINE 				} _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(pos != -1) _NEWLINE 			cout << name[pos] << endl; _NEWLINE 		else _NEWLINE 			cout << "NO" << endl; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
import java.math.BigInteger; _NEWLINE import java.io.*; _NEWLINE class Main _NEWLINE { _NEWLINE public static void main(String args[]) _NEWLINE { _NEWLINE int d; _NEWLINE String s1,s2; _NEWLINE BigInteger b1,b2; _NEWLINE BigInteger bi[]; _NEWLINE try _NEWLINE { _NEWLINE BufferedReader bf=new BufferedReader(new InputStreamReader(System.in)); _NEWLINE d=Integer.parseInt(bf.readLine()); _NEWLINE while(d-->0) _NEWLINE { _NEWLINE s1=bf.readLine(); _NEWLINE s2=bf.readLine(); _NEWLINE if(s2.equals("0")) _NEWLINE { _NEWLINE System.out.println("0 0"); _NEWLINE continue; _NEWLINE } _NEWLINE b1=new BigInteger(s1); _NEWLINE b2=new BigInteger(s2); _NEWLINE bi=b1.divideAndRemainder(b2); _NEWLINE System.out.println(bi[1]+" "+bi[0]); _NEWLINE } _NEWLINE }catch(Exception ioe){} _NEWLINE } _NEWLINE }
""" _NEWLINE f = open('Alarge.in','r') _NEWLINE a = f.read() _NEWLINE b = a.split('\n') _NEWLINE del(b[-1]) _NEWLINE f.close() _NEWLINE """ _NEWLINE import sys _NEWLINE  _NEWLINE def solve(l): _NEWLINE  _INDENT  _INDENT del(l[-1]) _NEWLINE  _INDENT  _INDENT pos = {} _NEWLINE  _INDENT  _INDENT pos['X'] = [] _NEWLINE  _INDENT  _INDENT pos['O'] = [] _NEWLINE  _INDENT  _INDENT pos['T'] = None _NEWLINE  _INDENT  _INDENT for i in xrange(len(l)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(len(l[0])): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l[i][j] == 'T': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pos['T'] = (i,j) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif l[i][j] == 'X': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pos['X'].append((i,j)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif l[i][j] == 'O': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pos['O'].append((i,j)) _NEWLINE  _NEWLINE  _INDENT  _INDENT ## Check Row. _NEWLINE  _INDENT  _INDENT #for i in xrange(4): _NEWLINE  _INDENT  _INDENT # _INDENT  _INDENT for j in xrange(4): _NEWLINE  _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _NEWLINE  _INDENT  _INDENT while count < 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = a + [l[count][i]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m = same(a) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if m != None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if m[0] == True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return m[1] + ' won' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT ## Check Column. _NEWLINE  _NEWLINE  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT while count < 4: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(4): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = a + [l[i][count]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #print a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m = same(a) _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if m != None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if m[0] == True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return m[1] + ' won' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT ## Check Diagonal. _NEWLINE  _NEWLINE  _INDENT  _INDENT ## First diagonal... _NEWLINE  _INDENT  _INDENT partial = [l[i][i] for i in xrange(4)] _NEWLINE  _INDENT  _INDENT m = same(partial) _NEWLINE  _INDENT  _INDENT if m != None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if m[0] == True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return m[1] + ' won' _NEWLINE  _NEWLINE  _INDENT  _INDENT ## Second diagonal... _NEWLINE  _NEWLINE  _INDENT  _INDENT p = [l[i][j] for i in xrange(4) for j in xrange(4) if i + j == 3] _NEWLINE  _INDENT  _INDENT m = same(p) _NEWLINE  _INDENT  _INDENT if m != None: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if m[0] == True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return m[1] + ' won' _NEWLINE  _NEWLINE  _INDENT  _INDENT for i in xrange(len(l)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(len(l[0])): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if l[i][j] == '.': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return 'Game not completed' _NEWLINE  _NEWLINE  _INDENT  _INDENT return 'Draw' _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE def same(partial_list): _NEWLINE  _INDENT  _INDENT q = partial_list _NEWLINE  _INDENT  _INDENT symbol = q[0] _NEWLINE  _INDENT  _INDENT ######################### _NEWLINE  _INDENT  _INDENT if symbol == 'T': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = q[1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a != '.': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(2,len(q)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if q[i] != a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False, -1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return True, a _NEWLINE  _INDENT  _INDENT ######################### _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT elif symbol != '.': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT pos = -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ## symbol is either 'X' or 'O'.... _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = False _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(len(q)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if q[i] == 'T': _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT pos = i _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if c == False: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT ## i.e. there is no 'T' in q _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(len(q)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if q[i] != symbol: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False, -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return True, q[0] _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: ## c == True, i.e. there is a 'T' in q _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(len(q)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i != pos and q[i] != symbol: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False, -1 _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return True,q[0] _NEWLINE  _INDENT  _INDENT ########################## _NEWLINE  _NEWLINE T = int(sys.stdin.readline()) _NEWLINE for casenum in xrange(T): _NEWLINE  _INDENT  _INDENT x = [] _NEWLINE  _INDENT  _INDENT y = [] _NEWLINE  _INDENT  _INDENT for i in xrange(5): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = sys.stdin.readline().strip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x.append(a) _NEWLINE  _NEWLINE  _INDENT  _INDENT for i in xrange(len(x)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s = '' _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for v in x[i].split(' '): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s += v _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y.append(s) _NEWLINE  _INDENT  _INDENT #print y _NEWLINE  _INDENT  _INDENT print 'Case #%d: %s' % (casenum + 1, solve(y)) _NEWLINE 
using namespace std; _NEWLINE  _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE #include <cstdlib> _NEWLINE #include <cstdio> _NEWLINE #include <cmath> _NEWLINE #include <algorithm> _NEWLINE #include <ctime> _NEWLINE #include <list> _NEWLINE #include <map> _NEWLINE #include <set> _NEWLINE #include <bitset> _NEWLINE #include <functional> _NEWLINE #include <numeric> _NEWLINE #include <utility> _NEWLINE #include <iostream> _NEWLINE #include <fstream> _NEWLINE #include <sstream> _NEWLINE #include <string.h> _NEWLINE #include <stack> _NEWLINE #include <queue> _NEWLINE #include <limits.h> _NEWLINE #include <iterator> _NEWLINE #include <iomanip> _NEWLINE #include <time.h> _NEWLINE  _NEWLINE #define null NULL _NEWLINE #define PRINT_NEW_LINE printf("\n") _NEWLINE #define gc getchar_unlocked _NEWLINE #define MAX_INPUT_SIZE 1001 _NEWLINE #define CODEFORCES_MAX_INPUT_SIZE 101 _NEWLINE #define TOPCODER_MAX_INPUT_SIZE 51 _NEWLINE #define ALPHABET_SIZE 26 _NEWLINE #define HACKER_RANK_LOWER_CASE "hackerrank" _NEWLINE #define MAX_SIZE_USER_INPUT 101 _NEWLINE #define LIMIT 10000001 _NEWLINE #define MODN 1000000007 _NEWLINE #define MAX_SIZE 1000001 _NEWLINE  _NEWLINE #define gc getchar_unlocked _NEWLINE  _NEWLINE void solveProblem() { _NEWLINE  _INDENT  _INDENT unsigned int testCases, size; _NEWLINE  _INDENT  _INDENT long long int input, result; _NEWLINE  _INDENT  _INDENT scanf("%u", &testCases); _NEWLINE  _INDENT  _INDENT while (testCases--) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT scanf("%u", &size); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT result = 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for (unsigned int counter = 0; counter < size; counter++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT scanf("%lld", &input); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT result = (result * input) % MODN; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout << result % MODN << endl; _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE  _NEWLINE int main() { _NEWLINE  _INDENT  _INDENT solveProblem(); _NEWLINE  _INDENT  _INDENT return 0; _NEWLINE } _NEWLINE 
for _ in range(input()): _NEWLINE 	n=int(input()) _NEWLINE #	temp=pow(2,n) _NEWLINE 	if n==1: _NEWLINE 		print 1 _NEWLINE 	else: _NEWLINE 		print 0 _NEWLINE 	#for i in range(temp): _NEWLINE 	#	res^=i _NEWLINE 	#print res	 _NEWLINE 		
t=int(raw_input()) _NEWLINE for x in range(t): _NEWLINE 	s=raw_input() _NEWLINE 	print s.count(' ')+1
#include <stdio.h> _NEWLINE #include <string.h> _NEWLINE int main() _NEWLINE { _NEWLINE 	char str[100][10001]; _NEWLINE 	int i=0,v[5],t,j; _NEWLINE 	long long wow[100]; _NEWLINE 	scanf("%d",&t); _NEWLINE 	for(j=0;j<t;j++) _NEWLINE 	{ _NEWLINE 	scanf("%s",str[j]); _NEWLINE 	} _NEWLINE 	for(j=0;j<t;j++) _NEWLINE 	{ _NEWLINE 		for(i=0;i<5;i++) _NEWLINE 	{ _NEWLINE 		v[i]=0; _NEWLINE 	} _NEWLINE 	for(i=0;str[j][i]!='\0';i++) _NEWLINE 	{ _NEWLINE 		switch(str[j][i]) _NEWLINE 		{ _NEWLINE 		case 'A' : _NEWLINE 			v[0]+=2; _NEWLINE 			break; _NEWLINE 			case 'E' : _NEWLINE 			v[1]+=2; _NEWLINE 			break; _NEWLINE 			case 'I' : _NEWLINE 			v[2]+=2; _NEWLINE 			break; _NEWLINE 			case 'O' : _NEWLINE 			v[3]+=2; _NEWLINE 			break; _NEWLINE 			case 'U' : _NEWLINE 			v[4]+=2; _NEWLINE 			break; _NEWLINE 			case 'a' : _NEWLINE 			v[0]++; _NEWLINE 			break; _NEWLINE 			case 'e' : _NEWLINE 			v[1]++; _NEWLINE 			break; _NEWLINE 			case 'i' : _NEWLINE 			v[2]++; _NEWLINE 			break; _NEWLINE 			case 'o' : _NEWLINE 			v[3]++; _NEWLINE 			break; _NEWLINE 			case 'u' : _NEWLINE 			v[4]++; _NEWLINE 			break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 		} _NEWLINE 	} _NEWLINE 	wow[j]=1; _NEWLINE 		for(i=0;i<5;i++) _NEWLINE 		{ _NEWLINE 			if(v[i]!=0) _NEWLINE 			{ _NEWLINE 			wow[j]=wow[j]*v[i]; _NEWLINE 			} _NEWLINE 		} _NEWLINE //	if(v[0]+v[1]+v[2]+v[3]+v[4]==0) _NEWLINE //		wow[j]=0; _NEWLINE 	} _NEWLINE 	for(j=0;j<t;j++) _NEWLINE 	{ _NEWLINE 		printf("%lld\n",wow[j]); _NEWLINE 	} _NEWLINE 	 _NEWLINE 	return 0; _NEWLINE } _INDENT  _INDENT  
#include <bits/stdc++.h> _NEWLINE using namespace std; _NEWLINE int T,N; _NEWLINE int A[100005]; _NEWLINE int main() _NEWLINE { _NEWLINE 	cin>>T; _NEWLINE 	while(T--) _NEWLINE 	{ _NEWLINE 		scanf("%d",&N); _NEWLINE 		for(int i=0; i<N; i++)scanf("%d",&A[i]); _NEWLINE 		sort(A,A+N); _NEWLINE 		int flag=0; _NEWLINE 		int curr=0; _NEWLINE 		int ans=0; int cnt=0; _NEWLINE 		for(int i=0; i<N ; i++) _NEWLINE 		{ _NEWLINE 			int tmp=A[i]-curr; _NEWLINE 			if(tmp<=0){ _NEWLINE 				flag=1; _NEWLINE 				break; _NEWLINE 			} _NEWLINE 			curr++; _NEWLINE 			ans++; _NEWLINE 			cnt++; _NEWLINE 			if(cnt==6) _NEWLINE 			{ _NEWLINE 				cnt=0; _NEWLINE 				curr++; _NEWLINE 			} _NEWLINE 		} _NEWLINE 		if(flag==1)cout<<"Goodbye Rick"<<"\n"<<ans<<"\n"; _NEWLINE 		else cout<<"Rick now go and save Carl and Judas"<<"\n"; _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE }
// AUTHOR: ARVIND NAIR _NEWLINE  _NEWLINE #include<bits/stdc++.h> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long ll; _NEWLINE typedef pair<int,int> pii; _NEWLINE typedef vector<int> vi; _NEWLINE  _NEWLINE #define as(z,x,y) assert(x <=z _INDENT && z<= y); _NEWLINE #define s(x) _INDENT  scanf("%d",&x) _NEWLINE #define rep(a,c) _INDENT  for ( long int (a)=0; (a)<(c); (a)++) _NEWLINE #define repn(a,b,c) _INDENT for ( long int (a)=(b); (a)<=(c); (a)++) _NEWLINE #define repd(a,b,c) _INDENT for ( _INDENT long int (a)=(b); (a)>=(c); (a)--) _NEWLINE #define all(v) (v).begin(),(v).end() _NEWLINE #define fi _INDENT first _NEWLINE #define se _INDENT second _NEWLINE #define pb _INDENT push_back _NEWLINE #define mp _INDENT make_pair _NEWLINE #define INF (int)1e9 _NEWLINE #define EPS (double)(1e-9) _NEWLINE #define MOD (int)1e9+7 _NEWLINE #define M(x,i) memset(x,i,sizeof(x)) _NEWLINE #define trace(x) _INDENT  _INDENT cout<<#x<<" is "<<x<<"\n" _NEWLINE #define sz(x) (int)(x.size()) _NEWLINE #define tr(i) for(typeof(i.begin()) it=i.begin(); it!=i.end();it++) _NEWLINE #define MAXN 1000005 _NEWLINE  _NEWLINE int flag[4*MAXN]; _NEWLINE vector<pii> v; _NEWLINE  _NEWLINE struct node { _NEWLINE  _INDENT int sum; _NEWLINE  _INDENT node(int l,int r):sum(0) {} _NEWLINE  _INDENT node():sum(-1) _INDENT {} _NEWLINE  _NEWLINE }tree[4*MAXN]; _NEWLINE  _NEWLINE void push(int v,int start, int end) { _NEWLINE  _INDENT  _NEWLINE  _INDENT int mid=(start+end)>>1; _NEWLINE  _INDENT  _INDENT tree[2*v].sum+=flag[v]; _NEWLINE  _INDENT  _INDENT tree[2*v+1].sum+=flag[v]; _NEWLINE  _INDENT  _INDENT flag[2*v]+=flag[v]; _NEWLINE  _INDENT  _INDENT flag[2*v+1]+=flag[v]; _NEWLINE  _NEWLINE  _INDENT  _INDENT flag[v]=0; _NEWLINE } _NEWLINE  _NEWLINE void add(int v,int start, int end,int val) { _NEWLINE  _INDENT tree[v].sum+=val; _NEWLINE  _INDENT flag[v]+=val; _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE void build(int v,int start, int end) { _NEWLINE  _NEWLINE  _INDENT  if(start==end) _NEWLINE  _INDENT  _INDENT { _INDENT tree[v]=node(start,end); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  int mid=(start+end)>>1; _NEWLINE  _INDENT  _INDENT  _INDENT  build(2*v,start,mid); _NEWLINE  _INDENT  _INDENT  _INDENT  build(2*v+1,mid+1,end); _NEWLINE  _INDENT  _INDENT  _INDENT  tree[v].sum=max(tree[2*v].sum,tree[2*v+1].sum); _NEWLINE  _INDENT  _INDENT  _NEWLINE } _NEWLINE  _NEWLINE void update(int v,int start, int end, int l, int r, int val) _INDENT { _NEWLINE  _NEWLINE  _INDENT if(start>r or end<l) _NEWLINE  _INDENT  _INDENT return; _NEWLINE  _NEWLINE  _INDENT if(l<=start and r>=end) _NEWLINE  _INDENT  { add(v,start,end,val); _NEWLINE  _INDENT  _INDENT  _INDENT return; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT push(v,start,end); _NEWLINE  _INDENT  _INDENT  int mid=(start+end)>>1; _NEWLINE  _INDENT  _INDENT  _INDENT  update(2*v,start,mid,l,r,val); _NEWLINE  _INDENT  _INDENT  _INDENT  update(2*v+1,mid+1,end,l,r,val); _NEWLINE  _NEWLINE  _INDENT  _INDENT tree[v].sum=max(tree[2*v].sum,tree[2*v+1].sum); _NEWLINE } _NEWLINE  _NEWLINE int query(int v, int start, int end, int l, int r) _INDENT { _NEWLINE  _NEWLINE if(l>end or r<start) _INDENT _NEWLINE  _INDENT return 0; _NEWLINE  _NEWLINE  _INDENT if(l<=start and r>=end) _NEWLINE  _INDENT  _INDENT return tree[v].sum; _NEWLINE  _NEWLINE  _INDENT  push(v,start,end); _NEWLINE  _INDENT  int mid=(start+end)>>1; _NEWLINE  _INDENT  _INDENT  _INDENT  int res1=query(2*v,start,mid,l,r); _NEWLINE  _INDENT  _INDENT  _INDENT  int res2=query(2*v+1,mid+1,end,l,r); _NEWLINE  _NEWLINE  _INDENT return max(res1,res2); _NEWLINE  _INDENT  _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { ios_base::sync_with_stdio(false); _INDENT cin.tie(0); _INDENT _NEWLINE  _NEWLINE int n; cin>>n; _NEWLINE M(flag,0); _NEWLINE build(1,1,MAXN); _NEWLINE  _NEWLINE rep(i,n) { _NEWLINE  _NEWLINE  _INDENT int x,y; cin>>x>>y; _NEWLINE  _INDENT --y; _NEWLINE  _INDENT v.pb(mp(x,y)); _NEWLINE  _INDENT update(1,1,MAXN,x,y,1); _NEWLINE } _NEWLINE  _NEWLINE vi ans; _NEWLINE  _NEWLINE  rep(i,n) { _NEWLINE  _INDENT  _NEWLINE  _INDENT update(1,1,MAXN,v[i].fi,v[i].se,-1); _NEWLINE  _INDENT  _INDENT int ret=query(1,1,MAXN,1,MAXN); _NEWLINE  _INDENT  _INDENT if(ret<2) _NEWLINE  _INDENT  _INDENT  _INDENT ans.pb(i+1); _NEWLINE  _INDENT  _INDENT update(1,1,MAXN,v[i].fi,v[i].se,1); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT cout<<sz(ans)<<"\n"; _NEWLINE  _NEWLINE  _INDENT  _INDENT rep(i,sz(ans)) _NEWLINE  _INDENT  _INDENT cout<<ans[i]<<" "; _NEWLINE return 0; _NEWLINE } _NEWLINE 
#include<stdio.h> _NEWLINE int main() _NEWLINE { _NEWLINE 	int tc,n,i,j,q=0,ans=0,temp=0,num=0; _NEWLINE 	int *a,*b; _NEWLINE 	scanf("%d",&tc); _NEWLINE 	while(tc--) _NEWLINE 	{ _NEWLINE 		q=0; _NEWLINE 		ans=0; _NEWLINE 		scanf("%d",&n); _NEWLINE 		a=(int *)malloc(n*sizeof(int)); _NEWLINE 		b=(int *)malloc(n*sizeof(int)); _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 			scanf("%d",&a[i]); _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 			scanf("%d",&b[i]); _NEWLINE 		for(i=0;i<n;i++) _NEWLINE 		{ _NEWLINE 			if(num==a[i] && i!=0) _NEWLINE 				continue; _NEWLINE 			num=a[i]; _NEWLINE 			for(j=0;j<n;j++) _NEWLINE 			{ _NEWLINE 				temp=b[j]; _NEWLINE 				if(temp==b[j+1]) _NEWLINE 					continue; _NEWLINE 				if(temp>=num) _NEWLINE 				{ _NEWLINE 					q=j-i; _NEWLINE 				} _NEWLINE 					 _NEWLINE 			} _NEWLINE 			if(q>ans) _NEWLINE 				ans=q; _NEWLINE 		} _NEWLINE 		printf("%d\n",ans);		 _NEWLINE 	} _NEWLINE }	 _INDENT  _INDENT 
for i in xrange(int(raw_input())): _NEWLINE  _INDENT  _INDENT x=int(raw_input()) _NEWLINE  _INDENT  _INDENT if x%4==0:print x _NEWLINE  _INDENT  _INDENT if x%4==1:print 1 _NEWLINE  _INDENT  _INDENT if x%4==2:print x+1 _NEWLINE  _INDENT  _INDENT if x%4==3:print 0 _NEWLINE  _INDENT  _INDENT  _NEWLINE 
string = list(raw_input()) _NEWLINE orig_string_len = len(string) _NEWLINE s = 0 _NEWLINE while s <= orig_string_len - 3: _NEWLINE  _INDENT  _INDENT if (string[s] == ' ' and string[s + 1] == ' '): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT del string[s] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT orig_string_len -= 1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s += 1 _NEWLINE print ''.join(string) _NEWLINE 
#include <iostream> _NEWLINE #include <cmath> _NEWLINE using namespace std; _NEWLINE  _NEWLINE int main() { _NEWLINE 	int N,Nc,K,a,op=1; _NEWLINE 	cin>>N>>K; _NEWLINE 	Nc=N--; _NEWLINE 	cin>>a; _NEWLINE 	while(N--) _NEWLINE 	{ _NEWLINE 	 _INDENT  _INDENT int b; _NEWLINE 	 _INDENT  _INDENT cin>>b; _NEWLINE 	 _INDENT  _INDENT if(abs(a-b)<=K) _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT op++; _NEWLINE 	 _INDENT  _INDENT else _NEWLINE 	 _INDENT  _INDENT { _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT cout<<op<<endl; _NEWLINE 	 _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE 	 _INDENT  _INDENT } _NEWLINE 	 _INDENT  _INDENT a=b; _NEWLINE 	} _NEWLINE 	cout<<Nc<<endl; _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
def f(n): _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT temp=1 _NEWLINE  _INDENT  _INDENT for i in range(5,n+1,5): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT temp=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t=i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while t%5==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t/=5 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT count+=i*temp _NEWLINE  _INDENT  _INDENT return count _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT print f(n) _INDENT 
import sys _NEWLINE  _NEWLINE s = raw_input() _NEWLINE cnt , n = [[0 for _ in range(len(s)+1)] for __ in range(3)] , len(s) _NEWLINE if s[0] == 'A' : _NEWLINE  _INDENT  _INDENT cnt[0][0] = 1 _NEWLINE elif s[0] == 'B' : _NEWLINE  _INDENT  _INDENT cnt[1][0] = 1 _NEWLINE else : _NEWLINE  _INDENT  _INDENT cnt[2][0] = 1 _NEWLINE for i in range(1,n) : _NEWLINE  _INDENT  _INDENT if s[i] == 'A' : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[0][i] = cnt[0][i-1]+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[1][i] = cnt[1][i-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[2][i] = cnt[2][i-1] _NEWLINE  _INDENT  _INDENT elif s[i] == 'B' : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[1][i] = cnt[1][i-1]+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[0][i] = cnt[0][i-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[2][i] = cnt[2][i-1] _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[2][i] = cnt[2][i-1]+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[1][i] = cnt[1][i-1] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt[0][i] = cnt[0][i-1] _NEWLINE  _NEWLINE ans , dic = 0 , {} _NEWLINE for i in range(n+1) : _NEWLINE  _INDENT  _INDENT if not dic.has_key((cnt[0][i]-cnt[1][i] , cnt[0][i]-cnt[2][i])) : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[(cnt[0][i]-cnt[1][i] , cnt[0][i]-cnt[2][i])] = 1 _NEWLINE  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans += dic[(cnt[0][i]-cnt[1][i] , cnt[0][i]-cnt[2][i])] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[(cnt[0][i]-cnt[1][i] , cnt[0][i]-cnt[2][i])]+= 1 _NEWLINE  _NEWLINE print ans _NEWLINE 
#include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <cstring> _NEWLINE #include <stack> _NEWLINE #include <vector> _NEWLINE #include <queue> _NEWLINE #include <algorithm> _NEWLINE using namespace std; _NEWLINE struct point _NEWLINE { _NEWLINE 	int dis,v,next; _NEWLINE }e[20010]; _NEWLINE int cnt,head[110]; _NEWLINE void addedge(int u,int v,int dis) _NEWLINE { _NEWLINE 	e[cnt].v = v; _NEWLINE 	e[cnt].dis = dis; _NEWLINE 	e[cnt].next = head[u]; _NEWLINE 	head[u] = cnt ++; _NEWLINE } _NEWLINE int dis[110],visit[110]; _NEWLINE queue<int> q; _NEWLINE int c[110]; _NEWLINE int spfa(int n,int r) _NEWLINE { _NEWLINE 	memset(c,0,sizeof(c)); _NEWLINE 	while(!q.empty()) q.pop(); _NEWLINE 	for(int i = 1; i <= n; i ++) { _NEWLINE 		dis[i] = r; _NEWLINE 		q.push(i); _NEWLINE 		visit[i] = 1; _NEWLINE 	} _NEWLINE 	while(!q.empty()) { _NEWLINE 		int u = q.front(); _NEWLINE 		q.pop(); _NEWLINE 		visit[u] = 0; _NEWLINE 		for(int i = head[u]; i != -1; i = e[i].next) _INDENT _NEWLINE 			if(dis[e[i].v] < dis[u] + e[i].dis) { _NEWLINE 				dis[e[i].v] = dis[u] + e[i].dis; _NEWLINE 				if(!visit[e[i].v]) { _NEWLINE 					c[e[i].v] ++; _NEWLINE 					if(c[e[i].v] > n) return 0; _NEWLINE 					visit[e[i].v] ++; _NEWLINE 					q.push(e[i].v); _NEWLINE 				} _NEWLINE 			} _NEWLINE 	} _NEWLINE 	int sum = 0; _NEWLINE 	for(int i = 1; i <= n; i ++) _NEWLINE 		sum += dis[i]; _NEWLINE 	printf("%d\n",sum); _NEWLINE 	for(int i = 1; i <= n; i ++) { _NEWLINE 		printf("%d",dis[i]); _NEWLINE 		if(i == n) printf("\n"); _NEWLINE 		else printf(" "); _NEWLINE 	} _NEWLINE 	return 1; _NEWLINE } _NEWLINE int main() _NEWLINE { _NEWLINE 	int n,m,r,t,x,y,z; _NEWLINE 	scanf("%d",&t); _NEWLINE 	while(t--) { _NEWLINE 		scanf("%d%d%d",&n,&m,&r); _NEWLINE 		memset(head,-1,sizeof(head)); _NEWLINE 		cnt = 0; _NEWLINE 		while(m --) { _NEWLINE 			scanf("%d%d%d",&x,&y,&z); _NEWLINE 			addedge(y,x,z); _NEWLINE 		} _NEWLINE 		if(!spfa(n,r)) printf("Inconsistent analysis.\n"); _NEWLINE 	} _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import math as m _NEWLINE no=int(raw_input()) _NEWLINE out=[] _NEWLINE inp=[] _NEWLINE for i in range(no): _NEWLINE  _INDENT  _INDENT a,b= map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT inp.append([a,b]) _NEWLINE  _NEWLINE for inputar in inp: _NEWLINE  _INDENT  _INDENT a=inputar[0] _NEWLINE  _INDENT  _INDENT b=inputar[1] _NEWLINE  _NEWLINE  _INDENT  _INDENT if(a/2<b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT out.append(-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT sol=[i for i in range(1,a+1)] _NEWLINE  _INDENT  _INDENT if(b==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT out.append(sol) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT interval=m.ceil(a/float(b)) _NEWLINE  _INDENT  _INDENT if(int(interval)%2==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while(i<a-2*b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in range(i,i+b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=sol[j+b] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol[j+b]=sol[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol[j]=temp _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=2*b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i=a-2*b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i,a-b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=sol.pop(a-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol.insert(i,temp) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(0,a-b,2*b): _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i,i+b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=sol[j+b] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol[j+b]=sol[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol[j]=temp _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=b _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i,a-b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT temp=sol.pop(a-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sol.insert(i,temp) _NEWLINE  _INDENT  _INDENT out.append(sol) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE for i in out: _NEWLINE  _INDENT  _INDENT if(i==-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print "-1" _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ' '.join(map(str,i)) _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 
import sys _NEWLINE  _INDENT _NEWLINE n = input() _NEWLINE lists = map(int,sys.stdin.readline().split()) _NEWLINE bit = [0]*32 _NEWLINE for i in lists : _NEWLINE 	bits = 0 _NEWLINE 	while i : _NEWLINE 		if i&1 : _NEWLINE 			bit[bits] += 1 _NEWLINE 		i >>= 1 _NEWLINE 		bits += 1 _NEWLINE  _INDENT _NEWLINE ans = 0 _NEWLINE for i in range(0,32) : _NEWLINE 	if bit[i] : _NEWLINE 		ans += (bit[i]*(bit[i]-1)/2)*(1<<i) _NEWLINE  _NEWLINE print ans
import heapq _NEWLINE def func(pq,sum,res,n,flag): _NEWLINE  _INDENT  _INDENT if n==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if flag: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heapq.heappush(pq, sum) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT func(pq, sum+res[n-1], res, n-1, True) _NEWLINE  _INDENT  _INDENT func(pq, sum, res, n-1, flag) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _NEWLINE  _NEWLINE t=int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT res=[] _NEWLINE  _INDENT  _INDENT pq=[] _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT n=int(raw_input()) _NEWLINE  _INDENT  _INDENT x=raw_input() _NEWLINE  _INDENT  _INDENT ss=map(int,x.split())#ss-->subset sum list _NEWLINE  _INDENT  _INDENT ss.sort() _NEWLINE  _INDENT  _INDENT if n==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res.append(ss[1]) _NEWLINE  _INDENT  _INDENT elif n==2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res.append(ss[1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res.append(ss[2]) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res.append(ss[1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT res.append(ss[2]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT heapq.heappush(pq,ss[1]+ss[2]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for x in range(3,len(ss)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if len(pq)>0 and ss[x]==pq[0]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT heapq.heappop(pq) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT func(pq, ss[x], res, len(res), False) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT res.append(ss[x]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if len(res)==n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  print res[j], _NEWLINE  _INDENT  _INDENT print '' _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT 
tests = input() _NEWLINE for t in range(tests): _NEWLINE 	v = [0]*1001 _NEWLINE 	n, k = map(int, raw_input().split()) _NEWLINE 	x = map(int, raw_input().split()) _NEWLINE 	for i in range(n): _NEWLINE 		v[x[i]] += 1 _NEWLINE 	ok = False _NEWLINE 	for i in range(1001): _NEWLINE 		if (i-k-1>=0): v[i] += v[i-k-1] _NEWLINE 		if (v[i] >= n-1): ok = True _NEWLINE 	print "YES" if ok else "NO"
 _NEWLINE def solve(v): _NEWLINE 	global x _NEWLINE 	global b _NEWLINE 	global c _NEWLINE 	global merged _NEWLINE 	 _NEWLINE 	 _NEWLINE 	for i in merged: _NEWLINE 		if len(i) == 2: _NEWLINE 			v -= i[1] _NEWLINE 		elif v >= i[1]: _NEWLINE 			v += i[2] _NEWLINE 		 _NEWLINE 		if v <= 0: _NEWLINE 			return False _NEWLINE 	 _NEWLINE 	return True _NEWLINE 	 _NEWLINE 	 _NEWLINE  _NEWLINE def bin_search(mx):	 _NEWLINE 	low, high = 1, mx _NEWLINE 	while low <= high: _NEWLINE 		v = (low+high)/2 _NEWLINE 		rvc, rvp = solve(v), solve(v-1) _NEWLINE 		if rvc and not rvp: _NEWLINE 			return v _NEWLINE 		 _NEWLINE 		if rvc: _NEWLINE 			high = v-1 _NEWLINE 		else: _NEWLINE 			low = v+1 _NEWLINE 		 _NEWLINE def merge(): _NEWLINE 	global b _NEWLINE 	global c _NEWLINE 	global dish _NEWLINE 	global clan _NEWLINE 	 _NEWLINE 	tmp = [] _NEWLINE 	i,j = 0, 0 _NEWLINE 	while i < b and j < c: _NEWLINE 		if dish[i][0] < clan[j][0]: _NEWLINE 			tmp.append(dish[i]) _NEWLINE 			i += 1 _NEWLINE 		else: _NEWLINE 			tmp.append(clan[j]) _NEWLINE 			j += 1 _NEWLINE 	 _NEWLINE 	while i < b: _NEWLINE 		tmp.append(dish[i]) _NEWLINE 		i += 1 _NEWLINE 	 _NEWLINE 	#~ while j < c: _NEWLINE 		#~ tmp.append(clan[j]) _NEWLINE 		#~ j += 1 _NEWLINE 	 _NEWLINE 	return tmp _NEWLINE 	 _NEWLINE  _NEWLINE x,b,c = 0,0,0 _NEWLINE dish = [] _NEWLINE clan = [] _NEWLINE merged = [] _NEWLINE t = int(raw_input()) _NEWLINE for i in range(t): _NEWLINE 	x = int(raw_input()) _NEWLINE 	b = [int(j) for j in raw_input().split()] _NEWLINE 	dish = [[b[j],b[j+1]] for j in range(1, len(b[1:]), 2)] _NEWLINE 	b = b[0] _NEWLINE 	 _NEWLINE 	c = [int(j) for j in raw_input().split()] _NEWLINE 	clan = [[c[j],c[j+1],c[j+2]] for j in range(1, len(c[1:]), 3)] _NEWLINE 	c = c[0] _NEWLINE 	 _NEWLINE 	mx = sum([j[1] for j in dish]) + 1 _NEWLINE 	 _NEWLINE 	merged = merge() _NEWLINE 	#~ print merged _NEWLINE 	print bin_search(mx) _NEWLINE 
 _NEWLINE C = [[0 for x in xrange(100)] for x in xrange(100)] _NEWLINE  _NEWLINE def dp(): _NEWLINE  _INDENT  _INDENT for i in range(100): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(min(99, i)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if j == 0 or j == i: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT C[i][j] = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT C[i][j] = C[i - 1][j - 1] + C[i - 1][j]; _NEWLINE  _NEWLINE def work(r, c, g): _NEWLINE  _INDENT  _INDENT maxUsed = -1 _NEWLINE  _INDENT  _INDENT ans = [] _NEWLINE  _INDENT  _INDENT x = r _NEWLINE  _INDENT  _INDENT y = _INDENT c _NEWLINE  _INDENT  _INDENT while C[x][y] < g: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = x + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x == 100: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = 99; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT while C[x][y] > g: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = x - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if x < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT if C[x][y] == g: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print g _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return; _NEWLINE  _NEWLINE  _INDENT  _INDENT ans += [C[x][y]] _NEWLINE  _INDENT  _INDENT g -= C[x][y] _NEWLINE  _INDENT  _INDENT maxUsed = C[x][y] _NEWLINE  _INDENT  _INDENT y = y - 1; _NEWLINE  _INDENT  _INDENT while g > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while C[x][y] < g and C[x][y] <= maxUsed: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = x + 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if x == 100: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = 99; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while C[x][y] > g or C[x][y] >= maxUsed: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = x - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if x < 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = 0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ans += [C[x][y]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT g -= C[x][y]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = y - 1; _NEWLINE  _NEWLINE  _INDENT  _INDENT print len(ans); _NEWLINE  _INDENT  _INDENT s = "" _NEWLINE  _INDENT  _INDENT for q in ans: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s += str(q) + " " _NEWLINE  _INDENT  _INDENT print s _NEWLINE  _NEWLINE  _NEWLINE if __name__ == '__main__': _NEWLINE  _INDENT  _INDENT dp() _NEWLINE  _INDENT  _INDENT T = int(raw_input()) _NEWLINE  _INDENT  _INDENT while T > 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT T = T - 1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT r, c, g = map(int, raw_input().split()); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT work(r, c, g) _NEWLINE  _INDENT  _INDENT exit(0) _NEWLINE 
import math _NEWLINE  _NEWLINE list_u = [] _NEWLINE list_v = [] _NEWLINE  _NEWLINE def find_level(n): _NEWLINE 	return int(math.floor(math.log(n,2))) + 1 _NEWLINE  _NEWLINE def find_lca(u, v): _NEWLINE 	while u != v: _NEWLINE 		while u > v: _NEWLINE 			if u % 2 == 0: _NEWLINE 				list_u.append(0) _NEWLINE 			else: _NEWLINE 				list_u.append(1) _NEWLINE 			u = u / 2 _NEWLINE 		while v > u: _NEWLINE 			if v % 2 == 0: _NEWLINE 				list_v.append(0) _NEWLINE 			else: _NEWLINE 				list_v.append(1) _NEWLINE 			v = v / 2 _NEWLINE 	# list_u.reverse() _NEWLINE 	# list_v.reverse() _NEWLINE 	return u _NEWLINE  _NEWLINE if __name__ == "__main__": _NEWLINE 	Q = raw_input() _NEWLINE 	Q = int(Q) _NEWLINE 	while(Q > 0): _NEWLINE 		Q -= 1 _NEWLINE 		del list_u[:] _NEWLINE 		del list_v[:] _NEWLINE 		ans = 0 _NEWLINE 		n_u_v = raw_input() _NEWLINE 		n, u, v = n_u_v.split() _NEWLINE 		n = int(n) _NEWLINE 		u = int(u) _NEWLINE 		v = int(v) _NEWLINE 		lca = find_lca(u, v) _NEWLINE 		# n_level = find_level(n) _NEWLINE 		# lca_level = find_level(lca) _NEWLINE 		# u_level = find_level(u) _NEWLINE 		# v_level = find_level(v) _NEWLINE 		# max_diff_level = max(u_level - lca_level, v_level - lca_level) _NEWLINE 		# ans += 2**(n_level - max_diff_level - 1) - 1 _NEWLINE 		# complex_level = n_level - max_diff_level _NEWLINE 		# start = 2**(complex_level - 1) _NEWLINE 		# end = 2**(complex_level) _NEWLINE 		# for i in xrange(start, end): _NEWLINE 		# 	tmp = i _NEWLINE 		# 	for item in list_u: _NEWLINE 		# 		tmp = tmp*2 + item _NEWLINE 		# 		if tmp > n: _NEWLINE 		# 			break _NEWLINE 		# 	if tmp > n: _NEWLINE 		# 		break _NEWLINE 		# 	tmp = i _NEWLINE 		# 	for item in list_v: _NEWLINE 		# 		tmp = tmp*2 + item _NEWLINE 		# 		if tmp > n: _NEWLINE 		# 			break _NEWLINE 		# 	if tmp > n: _NEWLINE 		# 		break _NEWLINE 		# 	else: _NEWLINE 		# 		ans += 1 _NEWLINE 		tmp = n _NEWLINE 		for item in list_u: _NEWLINE 			if tmp % 2 != item: _NEWLINE 				tmp -= 1 _NEWLINE 			tmp /= 2 _NEWLINE 		num1 = tmp _NEWLINE 		tmp = n _NEWLINE 		for item in list_v: _NEWLINE 			if tmp % 2 != item: _NEWLINE 				tmp -= 1 _NEWLINE 			tmp /= 2 _NEWLINE 		num2 = tmp _NEWLINE 		ans = min(num1, num2) _NEWLINE 		print ans _NEWLINE 
bcof = [[1 for i in xrange(n+1)] for n in xrange(102)] _NEWLINE  _NEWLINE for i in xrange(1, 101): _NEWLINE 	for j in xrange(1, i+1): _NEWLINE 		bcof[i+1][j] = bcof[i][j-1] + bcof[i][j] _NEWLINE  _NEWLINE for _ in xrange(int(raw_input())): _NEWLINE 	n, k, p = map(int, raw_input().split()) _NEWLINE 	s = 0 _NEWLINE 	ans = [n for _ in xrange(k+1)] _NEWLINE 	for i in xrange(1, k+1): _NEWLINE 		ans[i] = (pow(n+1, i+1)) - 1 _NEWLINE 		for j in range(2, i+2): _NEWLINE 			ans[i] -= ((bcof[i+1][j]*ans[i+1-j])) _NEWLINE 		ans[i] = (ans[i]/(i+1)) _NEWLINE 	print (ans[k] % p)
#!/usr/bin/python _NEWLINE mod = 1000000007 _NEWLINE #import psyco _NEWLINE #psyco.full() _NEWLINE def matrix_mult(A, B): _NEWLINE  _INDENT C = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] _NEWLINE  _INDENT for i in range(3): _NEWLINE 	 _INDENT for j in range(3): _NEWLINE 		 _INDENT for k in range(3): _NEWLINE 			 _INDENT C[i][k] = (C[i][k] + A[i][j] * B[j][k]) _NEWLINE 	 _INDENT 	 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(C[i][k] > 1000000007): _NEWLINE 				C[i][k] = C[i][k] % 1000000007 _NEWLINE  _INDENT return C _NEWLINE  _NEWLINE def matrix_mult_1(A, B): _NEWLINE  _INDENT C = [[0, 0],[0,0]] _NEWLINE  _INDENT for i in range(2): _NEWLINE 	 _INDENT for j in range(2): _NEWLINE 		 _INDENT for k in range(2): _NEWLINE 			 _INDENT C[i][k] = (C[i][k] + A[i][j] * B[j][k]) % 1000000007 _NEWLINE  _INDENT return C _NEWLINE  _NEWLINE def matrix_mult_4(A, B): _NEWLINE  _INDENT C = [[0, 0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]] _NEWLINE  _INDENT for i in range(5): _NEWLINE 	 _INDENT for j in range(5): _NEWLINE 		 _INDENT for k in range(5): _NEWLINE 			 _INDENT C[i][k] = (C[i][k] + A[i][j] * B[j][k]) _NEWLINE 		 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(C[i][k] > 1000000007): _NEWLINE 				C[i][k] = C[i][k] % 1000000007 _NEWLINE  _INDENT return C _NEWLINE  _NEWLINE def matrix_mult_5(A,B): _NEWLINE  _INDENT C=[] _NEWLINE  _INDENT for i in range(9): _NEWLINE 	 _INDENT C.append([0,0,0,0,0,0,0,0,0]) _NEWLINE  _INDENT for i in range(9): _NEWLINE 	 _INDENT for j in range(9): _NEWLINE 		 _INDENT for k in range(9): _NEWLINE 			 _INDENT C[i][k] = (C[i][k] + A[i][j] * B[j][k]) _NEWLINE 		 _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(C[i][k] > 1000000007): _NEWLINE 				C[i][k] = C[i][k] % 1000000007 _NEWLINE  _INDENT return C _NEWLINE  _NEWLINE def matrix_mult_6(A,B): _NEWLINE  _INDENT C=[] _NEWLINE  _INDENT for i in range(18): _NEWLINE 	 _INDENT C.append([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) _NEWLINE  _INDENT for i in range(18): _NEWLINE 	 _INDENT for j in range(18): _NEWLINE 		 _INDENT for k in range(18): _NEWLINE 			 _INDENT #if( A[i][j] > mod): _NEWLINE 		#		 _INDENT A[i][j] = A[i][j] % mod _NEWLINE 		#	 _INDENT elif (B[j][k] > mod): _NEWLINE 		#		 _INDENT B[j][k] = B[j][k] % mod _NEWLINE 			 _INDENT C[i][k] = (C[i][k] + A[i][j] * B[j][k]) _NEWLINE 	 _INDENT  _INDENT  _INDENT  # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(C[i][k] > mod): _NEWLINE 			 _INDENT C[i][k] = C[i][k] % mod _NEWLINE  _INDENT return C _NEWLINE  _NEWLINE def fast_exp(A, n, flag): _NEWLINE  _INDENT if n == 1: _NEWLINE 	return A _NEWLINE  _INDENT else: _NEWLINE  _INDENT  _INDENT if n & 1 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT A1 = fast_exp(A, n/2,flag) _NEWLINE  _INDENT  _INDENT  _INDENT if(flag == 2): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult_1(A1, A1) _NEWLINE  _INDENT  _INDENT  _INDENT elif (flag == 3): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult(A1,A1) _NEWLINE  _INDENT  _INDENT  _INDENT elif (flag == 4): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult_4(A1,A1) _NEWLINE  _INDENT  _INDENT  _INDENT elif( flag == 5): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult_5(A1,A1) _NEWLINE  _INDENT  _INDENT  _INDENT elif (flag == 6): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult_6(A1,A1) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT A1 = fast_exp(A,n-1,flag) _NEWLINE  _INDENT  _INDENT  _INDENT if(flag == 2): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult_1(A,A1) _NEWLINE  _INDENT  _INDENT  _INDENT elif(flag == 3): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult(A,A1) _NEWLINE  _INDENT  _INDENT  _INDENT elif(flag == 4): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult_4(A,A1) _NEWLINE  _INDENT  _INDENT  _INDENT elif(flag == 5): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult_5(A,A1) _NEWLINE  _INDENT  _INDENT  _INDENT elif(flag == 6): _NEWLINE 	 _INDENT  _INDENT  _INDENT return matrix_mult_6(A,A1) _NEWLINE  _NEWLINE def fast_pow(n): _NEWLINE  _INDENT if n == 1: _NEWLINE 	return 2 _NEWLINE  _INDENT if n == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 1 _NEWLINE  _INDENT else: _NEWLINE  _INDENT  _INDENT if n % 2 == 0: _NEWLINE 		 _INDENT  _INDENT  _INDENT  _INDENT ans = fast_pow(n/2) _NEWLINE  _INDENT  _INDENT  _INDENT 		 _INDENT  	ans = ans % mod _NEWLINE  _INDENT  _INDENT  			return (ans*ans) % mod _NEWLINE  _INDENT  _INDENT else: _NEWLINE 			ans = fast_pow(n-1) _NEWLINE 		 _INDENT  _INDENT  _INDENT  _INDENT ans = ans % mod _NEWLINE 		 _INDENT  _INDENT  _INDENT  _INDENT return ans*2 _NEWLINE  _NEWLINE def solve_1(n): _NEWLINE  _INDENT  _INDENT A = [[0,1,0],[0,0,1],[1,1,1]] _NEWLINE  _INDENT  _INDENT A_n = fast_exp(A,n-3) _NEWLINE  _INDENT  _INDENT return A_n[2][0] + A_n[2][1] + A_n[2][2]*2 _NEWLINE  _NEWLINE def solve_2(n): _NEWLINE  _INDENT  _INDENT if(n == 1): _NEWLINE 	 _INDENT  _INDENT return 2 _NEWLINE  _INDENT  _INDENT elif(n == 2): _NEWLINE 	 _INDENT  _INDENT return 7 _NEWLINE  _INDENT  _INDENT A = [[0,1],[2,3]] _NEWLINE  _INDENT  _INDENT A_n = fast_exp(A,n-2,2) _NEWLINE  _INDENT  _INDENT return A_n[1][0]*2 + A_n[1][1]*7 _NEWLINE  _NEWLINE def solve_3(n): _NEWLINE  _INDENT  _INDENT A = [[0,1,0],[0,0,1],[-2,3,6]] _NEWLINE  _INDENT  _INDENT if(n == 1): _NEWLINE 	 _INDENT  _INDENT return 4 _NEWLINE  _INDENT  _INDENT elif(n == 2): _NEWLINE 	 _INDENT  _INDENT return 25 _NEWLINE  _INDENT  _INDENT elif(n == 3): _NEWLINE  _INDENT  _INDENT 	 _INDENT  _INDENT return 161 _NEWLINE  _INDENT  _INDENT A_n = fast_exp(A,n-3,3) _NEWLINE  _INDENT  _INDENT return A_n[2][0]*4 + A_n[2][1]*25 + A_n[2][2]*161 _NEWLINE  _NEWLINE def solve_4(n): _NEWLINE  _INDENT  _INDENT ans= [8,89,1033,11929,137845] _NEWLINE  _INDENT  _INDENT if(n <= 5): _NEWLINE 	 _INDENT  _INDENT return ans[n-1] _NEWLINE  _INDENT  _INDENT A = [[0,1,0,0,0],[0,0,1,0,0],[0,0,0,1,0],[0,0,0,0,1],[8,-30,-21,20,10]] _NEWLINE  _INDENT  _INDENT A_n = fast_exp(A,n-5,4) _NEWLINE  _INDENT  _INDENT return A_n[4][0]*8 + A_n[4][1]*89 + A_n[4][2]*1033 + A_n[4][3]*11929 + A_n[4][4]* 137845 _NEWLINE  _NEWLINE def solve_5(n): _NEWLINE  _INDENT  _INDENT ans = [16,317,6631,137845,2867739,59655167,1240971177,25815151595,537016650729] _NEWLINE  _INDENT  _INDENT if(n <= 9): _NEWLINE 	 _INDENT  _INDENT return ans[n-1] _NEWLINE  _INDENT  _INDENT A = [[0,1,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0],[0,0,0,0,1,0,0,0,0],[0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,1],[-10,69,29,-662,790,73,-278,9,21]] _NEWLINE  _INDENT  _INDENT Ab = fast_exp(A,n-9,5) _NEWLINE  _INDENT  _INDENT return Ab[8][0]*16 + Ab[8][1]*317+ Ab[8][2]*6631+ Ab[8][3]*137845+Ab[8][4]*2867739+Ab[8][5]*59655167 + Ab[8][6]*1240971177 + Ab[8][7]* 25815151595 + Ab[8][8]*537016650729 _INDENT _NEWLINE  _NEWLINE def solve_6(n): _NEWLINE 	ans =[32,1129,42563,1592731,59655167,2234126207,83670667271,3133560234217,117355367786585,4395090865370635,164601109918978615,6164497208894901477,230867373009598884627,8646243499452479433569,323811570588787197424201,12127108524504811121752257,454173891617617632766031151,17009324474195992258878836533] _NEWLINE 	if(n <= 18): _NEWLINE 		return ans[n-1] _NEWLINE 	for i in range(18): _NEWLINE 		ans[i] = ans[i] % mod _NEWLINE 	A=[[0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]] _NEWLINE 	A.append([28,-622,3386,6203,-70276,38077,355981,-410368,-499260,751787,154999,-396016,27152,50702,-3905,-2391,120,36]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Ab = fast_exp(A,n-18,6) _NEWLINE 	#print len(ans) _NEWLINE 	finalans = 0 _NEWLINE 	for i in range(18): _NEWLINE 		finalans = finalans + ((Ab[17][i] % mod)*ans[i]) % mod _NEWLINE 		if(finalans > mod): _NEWLINE 			finalans % mod _NEWLINE 	return finalans _NEWLINE inp = raw_input() _NEWLINE inp = inp.split() _NEWLINE #print inp[0],inp[1] _NEWLINE inp[0] = int(inp[0]); inp[1] = int(inp[1]); _NEWLINE if(inp[0] == 1): _NEWLINE 	if(inp[1] == 1): _NEWLINE 		print 2 _NEWLINE 	else: _NEWLINE 		print fast_pow(inp[1])%mod _NEWLINE elif(inp[0] == 2): _NEWLINE 	print (solve_2(inp[1])*2)%mod _NEWLINE elif(inp[0] == 3): _NEWLINE 	print (solve_3(inp[1])*2)%mod _NEWLINE elif(inp[0] == 4): _NEWLINE 	print (solve_4(inp[1])*2)%mod _NEWLINE elif(inp[0] == 5): _NEWLINE 	print (solve_5(inp[1])*2)%mod _NEWLINE elif(inp[0] == 6): _NEWLINE 	print (solve_6(inp[1])*2)%mod _NEWLINE 
// Alfonso2 Peterssen (mukel) _NEWLINE #include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <sstream> _NEWLINE  _NEWLINE #include <algorithm> _NEWLINE #include <vector> _NEWLINE #include <deque> _NEWLINE #include <queue> _NEWLINE #include <stack> _NEWLINE #include <set> _NEWLINE #include <map> _NEWLINE  _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #include <cmath> _NEWLINE #include <cassert> _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long int64; _NEWLINE  _NEWLINE #define endl '\n' _NEWLINE #define SZ(c) ((int)((c).size())) _NEWLINE #define REP(i, n) for (int i = 0; i < (int)(n); ++i) _NEWLINE #define FOR(i, b, e) for (int i = (int)(b); i <= (int)(e); ++i) _NEWLINE #define ALL(c) (c).begin(), (c).end() _NEWLINE  _NEWLINE struct fastCin { _NEWLINE 	char cur; _NEWLINE 	inline char nextChar() { return cur = getc_unlocked(stdin); } _NEWLINE 	inline char peekChar() { return cur; } _NEWLINE 	inline operator bool() { return (peekChar() != 0); } _NEWLINE 	inline static bool isBlank(char c) { return (c < '0' && c); } _NEWLINE 	inline bool skipBlanks() { while (isBlank(nextChar())); return peekChar() != 0; } _NEWLINE 	fastCin() { cur = 0; } _NEWLINE 	char tmp[1 << 8]; _NEWLINE 	inline fastCin& operator >> (int & n) { _NEWLINE 		if (skipBlanks()) { _NEWLINE 			int sign = +1; _NEWLINE 			if (peekChar() == '-') { _NEWLINE 				sign = -1; _NEWLINE 				n = nextChar() - '0'; _NEWLINE 			} _NEWLINE 			else _NEWLINE 				n = peekChar() - '0'; _NEWLINE 			while (!isBlank(nextChar())) { _NEWLINE 				n *= 10; _NEWLINE 				n += peekChar() - '0'; _NEWLINE 			} _NEWLINE 			n *= sign; _NEWLINE 		} _NEWLINE 		return *this; _NEWLINE 	} _NEWLINE 	inline fastCin& operator >> (int64 & n) { _NEWLINE 		if (skipBlanks()) { _NEWLINE 			int sign = +1; _NEWLINE 			if (peekChar() == '-') { _NEWLINE 				sign = -1; _NEWLINE 				n = nextChar() - '0'; _NEWLINE 			} _NEWLINE 			else _NEWLINE 				n = peekChar() - '0'; _NEWLINE 			while (!isBlank(nextChar())) { _NEWLINE 				n *= 10; _NEWLINE 				n += peekChar() - '0'; _NEWLINE 			} _NEWLINE 			n *= sign; _NEWLINE 		} _NEWLINE 		return *this; _NEWLINE 	} _NEWLINE 	#define cin cin2 _NEWLINE } cin2; _NEWLINE  _NEWLINE const int64 _NEWLINE 	MAXN = 2 * 3114LL * 3114 * 3114 * 3114 * 3114; _NEWLINE  _NEWLINE vector< int64 > powerNums; _NEWLINE  _NEWLINE int64 squareRoot(int64 n) _NEWLINE { _NEWLINE 	int64 r = sqrt(n); _NEWLINE 	//while (r * r < n) ++r; _NEWLINE 	//while (r * r > n) --r; _NEWLINE 	return r; _NEWLINE } _NEWLINE  _NEWLINE bool isPowerNum(int64 n) _NEWLINE { _NEWLINE 	if (n < 4) return false; _NEWLINE 	int64 sq = squareRoot(n); _NEWLINE 	return sq * sq == n || binary_search(ALL(powerNums), n); _NEWLINE } _NEWLINE  _NEWLINE int64 getPowerNumsLessThan(int64 n) _NEWLINE { _NEWLINE 	if (n < 4) return 0; _NEWLINE  _NEWLINE 	int64 sq = squareRoot(n); _NEWLINE  _NEWLINE 	int64 r = lower_bound(ALL(powerNums), n) - powerNums.begin(); _NEWLINE  _NEWLINE 	r += sq - 1; _NEWLINE 	if (sq * sq == n) _NEWLINE 		--r; _NEWLINE  _NEWLINE 	return r; _NEWLINE } _NEWLINE  _NEWLINE int64 getNonPowerIndex(int64 n) _NEWLINE { _NEWLINE 	assert( !isPowerNum(n) ); _NEWLINE 	return n - getPowerNumsLessThan(n) + 1; _NEWLINE } _NEWLINE  _NEWLINE int simulate(int64 n) _NEWLINE { _NEWLINE 	int64 nIndex = getNonPowerIndex(n); _NEWLINE  _NEWLINE 	//cout << "nIndex = " << nIndex << endl; _NEWLINE  _NEWLINE 	int64 pos = 2; _NEWLINE  _NEWLINE 	int steps = 0; _NEWLINE  _NEWLINE 	int64 lo, hi; _NEWLINE  _NEWLINE 	while (1) _NEWLINE 	{ _NEWLINE 		steps++; _NEWLINE  _NEWLINE 		if (pos == nIndex) _NEWLINE 			return steps; _NEWLINE  _NEWLINE 		if (pos < nIndex) _NEWLINE 			pos *= 2; _NEWLINE 		else _NEWLINE 		{ _NEWLINE 			lo = pos / 2; _NEWLINE 			hi = pos; _NEWLINE 			break; _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	while (lo + 1 < hi) _NEWLINE 	{ _NEWLINE 		int64 mid = (lo + hi) / 2; _NEWLINE  _NEWLINE 		steps++; _NEWLINE  _NEWLINE 		if (mid == nIndex) _NEWLINE 			return steps; _NEWLINE  _NEWLINE 		if (mid < nIndex) _NEWLINE 			lo = mid; _NEWLINE 		else _NEWLINE 			hi = mid; _NEWLINE 	} _NEWLINE  _NEWLINE 	return steps + 1; _NEWLINE } _NEWLINE  _NEWLINE void calcNonSquarePowerNums() _NEWLINE { _NEWLINE 	powerNums.reserve(1 << 20); _NEWLINE  _NEWLINE 	for (int64 a = 2, f; (f = a * a * a) <= MAXN; ++a) _NEWLINE 	{ _NEWLINE 		int64 limit = MAXN / a + 1; _NEWLINE 		for (;;) { _NEWLINE 			int64 sq = squareRoot(f); _NEWLINE  _NEWLINE 			if (sq * sq != f) _NEWLINE 				powerNums.push_back(f); _NEWLINE  _NEWLINE 			if (f >= limit) _NEWLINE 				break; _NEWLINE 			f *= a; _NEWLINE 		} _NEWLINE 	} _NEWLINE  _NEWLINE 	sort(ALL(powerNums)); _NEWLINE 	powerNums.erase(unique(ALL(powerNums)), powerNums.end()); _NEWLINE  _NEWLINE 	//cout << SZ(powerNums) << endl; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	calcNonSquarePowerNums(); _NEWLINE  _NEWLINE 	int T; _NEWLINE 	for (cin >> T; T--;) _NEWLINE 	{ _NEWLINE 		int64 P; cin >> P; _NEWLINE 		if (isPowerNum(P)) _NEWLINE 			cout << getPowerNumsLessThan(P) + 1 << endl; _NEWLINE 		else _NEWLINE 			cout << simulate(P) << endl; _NEWLINE 	} _NEWLINE  _NEWLINE 	return 0; _NEWLINE } _NEWLINE 
import sys _NEWLINE f = sys.stdin _NEWLINE  _NEWLINE T = int(f.readline()) _NEWLINE for tc in xrange(T): _NEWLINE  _INDENT  _INDENT N = int(f.readline()) _NEWLINE  _INDENT  _INDENT if N%2 == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in xrange(N): f.readline() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT x,y = [list(l) for l in zip(*[[int(c) for c in f.readline().split()] for i in xrange(N)])] _NEWLINE  _INDENT  _INDENT x.sort(),y.sort() _NEWLINE  _INDENT  _INDENT x1,y1 = ( v[N/2] - v[N/2 - 1] + 1 for v in (x,y)) _NEWLINE  _INDENT  _INDENT print x1*y1 _NEWLINE 
# matrix multiplication function _NEWLINE def matmul(a,b,l,m,n): _NEWLINE 	c = [] _NEWLINE 	for i in range(l): _NEWLINE 		dummy = [] _NEWLINE 		for j in range(n): _NEWLINE 			ans = 0 _NEWLINE 			for k in range(m): _NEWLINE 				ans = ans + a[i][k] * b[k][j] _NEWLINE 			dummy.append(ans) _NEWLINE 		c.append(dummy) _NEWLINE 	return c _NEWLINE  _NEWLINE #function to create identity matrix in case matrix is raised to power 0 _NEWLINE def identity_matrix(n): _NEWLINE 	c = [] _NEWLINE 	for i in range(n): _NEWLINE 		k = [] _NEWLINE 		for j in range(n): _NEWLINE 			if i == j: _NEWLINE 				k.append(1.0) _NEWLINE 			else: _NEWLINE 				k.append(0.0) _NEWLINE 		c.append(k) _NEWLINE 	return c _NEWLINE  _NEWLINE #function to raise a matrix A to power n _NEWLINE def power_matrix(a,n): _NEWLINE 	if n == 0: _NEWLINE 		return identity_matrix(26) _NEWLINE 	elif n == 1: _NEWLINE 		return a _NEWLINE 	elif n%2 == 0: _NEWLINE 		return power_matrix(matmul(a,a,26,26,26),n/2) _NEWLINE 	elif n%2 == 1: _NEWLINE 		return matmul(a,power_matrix(matmul(a,a,26,26,26),(n-1)/2),26,26,26) _NEWLINE  _INDENT  _INDENT  _INDENT _NEWLINE  _NEWLINE dup3 = [] _NEWLINE for i in range(17576): _NEWLINE 	dup3.append(0) _NEWLINE dup2 = [] _NEWLINE for i in range(676): _NEWLINE 	dup2.append(0) _NEWLINE dup1 = [] _NEWLINE for i in range(26): _NEWLINE 	dup1.append(0) _NEWLINE  _NEWLINE def initialize(): _NEWLINE 	for i in range(17576): _NEWLINE 		dup3[i] = 0 _NEWLINE 	for i in range(676): _NEWLINE 		dup2[i] = 0 _NEWLINE 	for i in range(26): _NEWLINE 		dup1[i] = 0 _NEWLINE  _NEWLINE def duplicate(s): _NEWLINE 	l = len(s) _NEWLINE 	ans = 1 _NEWLINE 	if l == 1: _NEWLINE 		ans = ord(s[0])-97 _NEWLINE 		if dup1[ans] == 1: _NEWLINE 			return 1 _NEWLINE 		else: _NEWLINE 			dup1[ans] = 1 _NEWLINE 			return 0 _NEWLINE 	elif l == 2: _NEWLINE 		ans = 26*(ord(s[0])-97) + (ord(s[1])-97) _NEWLINE 		if dup2[ans] == 1: _NEWLINE 			return 1 _NEWLINE 		else: _NEWLINE 			dup2[ans] = 1 _NEWLINE 			return 0 _NEWLINE 	elif l == 3: _NEWLINE 		ans = 676*(ord(s[0])-97) + 26*(ord(s[1])-97) + (ord(s[2])-97) _NEWLINE 		if dup3[ans] == 1: _NEWLINE 			return 1 _NEWLINE 		else: _NEWLINE 			dup3[ans] = 1 _NEWLINE 			return 0 _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE a = [] _NEWLINE for i in range(26): _NEWLINE 	k = [] _NEWLINE 	for j in range(26): _NEWLINE 		k.append(0.0) _NEWLINE 	a.append(k) _NEWLINE t = input() _NEWLINE for dummy in range(t): _NEWLINE 	initialize() _NEWLINE 	n, k = raw_input().split() _NEWLINE 	n = int(n) _NEWLINE 	k = int(k) _NEWLINE 	word = raw_input() _NEWLINE 	length = len(word) _NEWLINE 	word = list(word) _NEWLINE 	for i in range(length): _NEWLINE 		word[i] = ord(word[i]) - 97 _NEWLINE 	for i in range(26): _NEWLINE 		num = raw_input().split() _NEWLINE 		for j in range(26): _NEWLINE 			a[i][j] = float(num[j]) _NEWLINE 	a = power_matrix(a,k) _NEWLINE 	prob = 0 _NEWLINE 	for j in range(n): _NEWLINE 		p1 = 1 _NEWLINE 		str1 = raw_input() _NEWLINE 		if(len(str1) != length): _NEWLINE 			continue _NEWLINE 		elif duplicate(str1) == 1: _NEWLINE 			continue _NEWLINE 		else: _NEWLINE 			s = list(str1) _NEWLINE 			for i in range(len(s)): _NEWLINE 				s[i] = ord(s[i])-97 _NEWLINE 			for i in range(length): _NEWLINE 				p1 = p1*a[word[i]][s[i]] _NEWLINE 				if p1 == 0: _NEWLINE 					break _NEWLINE 			prob = prob + p1 _NEWLINE 	print prob 
t = int(raw_input()) _NEWLINE for i in xrange(t): _NEWLINE  _INDENT  _INDENT n = int(raw_input()) _NEWLINE  _INDENT  _INDENT a = map(int, raw_input().split()) _NEWLINE  _INDENT  _INDENT mi = a[0] _NEWLINE  _INDENT  _INDENT ma = a[0] _NEWLINE  _INDENT  _INDENT for j in xrange(1,n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = mi*a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = mi+a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d = mi-a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT e = ma*a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT f = ma+a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT g = ma-a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mi = min(b,c,d,e,f,g) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ma = max(b,c,d,e,f,g) _NEWLINE  _INDENT  _INDENT print mi _NEWLINE 
c=[] _NEWLINE for i in range(100001): _NEWLINE  _INDENT  _INDENT c.append(-1) _NEWLINE n,k=map(int,raw_input().split()) _NEWLINE l=list(map(int,raw_input().split())) _NEWLINE maxl=max(l) _NEWLINE ans=0 _NEWLINE maxi=-1 _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT if k<l[i]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(k,maxl+1,l[i]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c[j]!=-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT maxi=max(maxi,c[j]) _NEWLINE  _INDENT  _INDENT ans+=i-maxi _NEWLINE  _INDENT  _INDENT c[l[i]]=i _NEWLINE print ans _NEWLINE 
test = input() _NEWLINE from itertools import combinations _NEWLINE while test: _NEWLINE  _INDENT  _INDENT test-=1 _NEWLINE  _INDENT  _INDENT n,k = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT weights = [] _NEWLINE  _INDENT  _INDENT costs = [] _NEWLINE  _INDENT  _INDENT index = [] _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c,w = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT costs.append(c) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT weights.append(w) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT index.append(i) _NEWLINE  _INDENT  _INDENT max = 0 _NEWLINE  _INDENT  _INDENT for r in range(1,n+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for sub in combinations(index,r): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cost = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT weight = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in sub: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cost += costs[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT weight += weights[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if cost <=k and weight > max: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT max = weight _NEWLINE  _INDENT  _INDENT print max _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE 
"""flag=1 _NEWLINE def sor(a,n): _NEWLINE  _INDENT  _INDENT global flag _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT while i<len(a): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT o=[] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t=a[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #del(a[i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #a=[t]+a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT k=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while j<len(a): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(t>a[j]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT k=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT o=[t]+o _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print t," ",a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t=a[j] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #del(a[j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #i+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #a=[t]+a _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #if(j==len(a)-1)&(k==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  # flag+=1 _INDENT  _INDENT  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(o!=[]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a=o[::-1] _INDENT  _INDENT _NEWLINE def sort(a,n): _NEWLINE  _INDENT  _INDENT global flag _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT while i<n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while j<n-1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]>a[j]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT flag+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while((j<n-1)&(a[i]>a[j])): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t=a[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[i]=a[j] _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[j]=t _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1""" _NEWLINE def index(lis,l,r,k): _NEWLINE  _INDENT  _INDENT while(r-l>1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT m=l+(r-l)/2; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(lis[m]<=k): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT l=m _NEWLINE  _INDENT  _INDENT return r _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE def count(lis,n): _NEWLINE  _INDENT  _INDENT t=[] _NEWLINE  _INDENT  _INDENT len1=1 _NEWLINE  _INDENT  _INDENT t+=[lis[0]] _NEWLINE  _INDENT  _INDENT i=1 _NEWLINE  _INDENT  _INDENT while i<n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(lis[i]>t[0]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t[0]=lis[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif(lis[i]<t[len1-1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t+=[lis[i]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT len1+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t[index(t,-1,len1-1,lis[i])]=lis[i] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT """if(len(t)!=0): _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  k=0 _NEWLINE  _INDENT  _INDENT  l=[] _NEWLINE  _INDENT  _INDENT  for i in t: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  t=k _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  k=lis[k:].index(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  l+=[k+t] _NEWLINE  _INDENT  _INDENT  i=0 _NEWLINE  _INDENT  _INDENT  while i<len(l): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  del(lis[l[i]-i]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  i+=1""" _NEWLINE  _INDENT  _INDENT return len1 _INDENT  _INDENT  _INDENT _NEWLINE t=input() _NEWLINE a=[int(x) for x in raw_input().split()] _NEWLINE """l=0 _NEWLINE while(len(a)!=0): _NEWLINE  _INDENT  _INDENT  g=count(a,t) _NEWLINE  _INDENT  _INDENT  l+=1 _NEWLINE  _INDENT  _INDENT  if(g!=a): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  a=g _NEWLINE  _INDENT  _INDENT  else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  l+=len(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  break""" _NEWLINE print count(a,t) _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _NEWLINE 
p=10**9+7; _NEWLINE  _NEWLINE def modpow(x,n): _NEWLINE 	if(n==0): _NEWLINE 		return 1; _NEWLINE 	elif(n%2==0): _NEWLINE 		m=modpow(x,n/2); _NEWLINE 		return (m*m)%p; _NEWLINE 	else: _NEWLINE 		m=modpow(x,n/2); _NEWLINE 		return (m*m*x)%p;		 _NEWLINE  _NEWLINE def modinv(x): _NEWLINE 	return modpow(x,p-2); _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE inv2=modinv(2); _NEWLINE mods=[1]*31; _NEWLINE  _NEWLINE mod2s=[1]*31; _NEWLINE for i in range(1,31): _NEWLINE 	mods[i]=(mods[i-1]*3)%p; _NEWLINE 	mod2s[i]=(mod2s[i-1]*2); _NEWLINE  _NEWLINE #A:0 indexed array, m:no. of minutes,x:position in array _NEWLINE #Returns the sum upto position x(0 indexed) _NEWLINE def computeSum(A,m,x): _NEWLINE 	if(x==-1): _NEWLINE 		return 0; _NEWLINE 	sum1=0; _NEWLINE 	n=len(A)-1;# An extra element at the end _NEWLINE 	i=1; _NEWLINE 	while((i<=n)and((i*(2**m)-1)<=x)): _NEWLINE 		#INV:Sum of indices upto (i-1)*(2^m)-1 has been taken, i.e. the elements before old A[i-1] (exclusive) has been considered _NEWLINE 		sum1=(sum1+A[i-1]+(A[i]+A[i-1])*(mods[m]-1)*inv2)%p; _NEWLINE 		i=i+1; _NEWLINE 	if((i<=n)and ((i-1)*(2**m))<=x): _NEWLINE 		sum1=(sum1+A[i-1]+computePartSum(A[i-1],A[i],m,x-mod2s[m]*(i-1)))%p; _NEWLINE 	return sum1; _NEWLINE  _NEWLINE def computePartSum(a,b,m,x): _NEWLINE 	if(m==0): _NEWLINE 		return 0; _NEWLINE 	mid=2**(m-1)	 _NEWLINE 	if(x<mid): _NEWLINE 		return computePartSum(a,(a+b)%p,m-1,x); _NEWLINE 	elif(x==mid): _NEWLINE 		return (a+b+(a+(a+b))*(mods[m-1]-1)*inv2)%p; _NEWLINE 	else:# x>mid _NEWLINE 		return 	(a+b+(a+(a+b))*(mods[m-1]-1)*inv2+computePartSum(a+b,b,m-1,x-(mid)))%p; _NEWLINE  _NEWLINE  _NEWLINE T=input(); _NEWLINE sums=[]; _NEWLINE for i in range(T): _NEWLINE 	[N,m,x,y]=map(lambda x:int(x),raw_input().split()); _NEWLINE 	x=x-1; _NEWLINE 	y=y-1; _NEWLINE 	A=map(lambda x:int(x),raw_input().split()); _NEWLINE 	A.append(0); _NEWLINE 	sums.append((computeSum(A,m,y)-computeSum(A,m,x-1))%p); _NEWLINE  _NEWLINE for s in sums: _NEWLINE 	print(s);
def comb(n,k): _NEWLINE 	return math.factorial(n)/(math.factorial(k)*math.factorial(n-k)) _NEWLINE 	 _NEWLINE import math _NEWLINE t=int(raw_input()) _NEWLINE while t: _NEWLINE 	t=t-1 _NEWLINE 	s=raw_input() _NEWLINE 	n,k,m=(long(x) for x in s.split()) _NEWLINE 	ans='' _NEWLINE 	if comb(n,k)<m: _NEWLINE 		print -1 _NEWLINE 		continue _NEWLINE 	for x in range(0,n): _NEWLINE 		 _NEWLINE 		if n-(x+1)-k>=0: _NEWLINE 			c=comb(n-(x+1),k) _NEWLINE 		else: _NEWLINE 			c=0 _NEWLINE 		if c<m: _NEWLINE 			ans=ans+'1' _NEWLINE 			k=k-1 _NEWLINE 			m=m-c _NEWLINE 		else: _NEWLINE 			ans=ans+'0' _NEWLINE 	print ans _NEWLINE 
def fn(): _NEWLINE  _INDENT  _INDENT mod = 1000000007 _NEWLINE  _INDENT  _INDENT u,d,m,n = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT a = [] _NEWLINE  _INDENT  _INDENT for i in range(3): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t = [] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t.append(0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a.append(t) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t1 = pow(i,d,n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t2 = (u-i)/n + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t2 %= mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[0][t1]+=t2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a[0][t1]%=mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[1][(i+j)%n]+= (a[0][i] * a[0][j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[1][(i+j)%n]%= mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT for i in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[2][(i+j)%n]+= (a[0][i]* a[1][j]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a[2][(i+j)%n]%= mod _NEWLINE  _NEWLINE  _INDENT  _INDENT print a[2][m] % mod _NEWLINE  _NEWLINE t = int(raw_input()) _NEWLINE  _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT fn()
__author__ = 'user' _NEWLINE d = {} _NEWLINE def find_max(v): _NEWLINE  _INDENT  _INDENT if d.__contains__(v): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return d[v] _NEWLINE  _INDENT  _INDENT a = v/2 _NEWLINE  _INDENT  _INDENT b = v/3 _NEWLINE  _INDENT  _INDENT c = v/4 _NEWLINE  _INDENT  _INDENT if a+b+c > v: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d[v]=find_max(a)+find_max(b)+find_max(c) _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d[v]=v _NEWLINE  _INDENT  _INDENT return d[v] _NEWLINE  _NEWLINE for _ in xrange(10): _NEWLINE  _INDENT  _INDENT v = input() _NEWLINE  _NEWLINE  _INDENT  _INDENT print find_max(v)
from sys import stdin _NEWLINE  _INDENT _NEWLINE MOD = 1000000007 _NEWLINE  _INDENT _NEWLINE for trial in xrange(int(stdin.readline())): _NEWLINE  _INDENT  _INDENT N,K = map(int,stdin.readline().split()) _NEWLINE  _INDENT  _INDENT Kmod = K%MOD _NEWLINE  _INDENT  _INDENT K1mod=(K-1)%MOD _NEWLINE  _INDENT  _INDENT K2mod=(K-2)%MOD _NEWLINE  _INDENT  _INDENT if K==1: print 0 _NEWLINE  _INDENT  _INDENT elif K==2: print 2 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT inner = ((Kmod*K1mod*K1mod)%MOD + (Kmod*K1mod*K2mod*K2mod)%MOD)%MOD _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if N==1: print (K*(K-1))%MOD _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif N==2: print inner _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: print ((inner)*pow(K**2-3*K+3,N-2,MOD))%MOD 
n,m=map(int,raw_input().split()) _NEWLINE dic={} _NEWLINE for i in range(n): _NEWLINE  _INDENT  _INDENT a,b,c,d=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if (a,b) in dic: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if dic[(a,b)][1]<=d: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT dic[(a,b)]=[c,d] _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dic[(a,b)]=[c,d] _NEWLINE for i in range(m): _NEWLINE  _INDENT  _INDENT a,b=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT print dic[(a,b)][0] _NEWLINE #print dic
import sys _NEWLINE scan = lambda:sys.stdin.readline().rstrip() _NEWLINE  _NEWLINE def hammingDist(a,b): _NEWLINE 	return sum(a[i]!=b[i] for i in range(len(a))) _NEWLINE  _NEWLINE goodStr2 = [[],[],[],[],[],[],[],[],[]] _NEWLINE goodStr3 = [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]] _NEWLINE  _NEWLINE def isGood(s): _NEWLINE  _INDENT  _INDENT l = len(s) _NEWLINE  _INDENT  _INDENT if l<3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  # for i in range(l-2): _NEWLINE  _INDENT  _INDENT  _INDENT  # _INDENT  _INDENT  for j in range(1,l/2+1): _NEWLINE  _INDENT  _INDENT  _INDENT  # _INDENT  _INDENT  _INDENT  _INDENT  if i+2*j > l-1: _NEWLINE  _INDENT  _INDENT  _INDENT  # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  break _NEWLINE  _INDENT  _INDENT  _INDENT  # _INDENT  _INDENT  _INDENT  _INDENT  if s[i] == s[i+j] and s[i+j] == s[i+ 2*j]: _NEWLINE  _INDENT  _INDENT  _INDENT  # _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i = l-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(1,15): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i < 2*j: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if s[i] == s[i-j] and s[i-j] == s[i-2*j]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT return True _NEWLINE  _NEWLINE def genGoodStr2(string): _NEWLINE  _INDENT  _INDENT if len(string)>=9: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT if isGood(string): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT goodStr2[len(string)].append(string) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT genGoodStr2(string+"a") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT genGoodStr2(string+"b") _NEWLINE  _NEWLINE def genGoodStr3(string): _NEWLINE  _INDENT  _INDENT if len(string)>=27: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _NEWLINE  _INDENT  _INDENT if isGood(string): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT goodStr3[len(string)].append(string) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT genGoodStr3(string+"a") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT genGoodStr3(string+"b") _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT genGoodStr3(string+"c") _NEWLINE  _NEWLINE  _NEWLINE genGoodStr2("a") _NEWLINE genGoodStr2("b") _NEWLINE genGoodStr3("a") _NEWLINE genGoodStr3("b") _NEWLINE genGoodStr3("c") _NEWLINE  _NEWLINE #print len(goodStr2) _NEWLINE #print len(goodStr3) _NEWLINE  _NEWLINE for t in range(int(scan())): _NEWLINE  _INDENT  _INDENT #a_k = raw_input().split(' ') _NEWLINE  _INDENT  _INDENT A,K = map(int,scan().split()) _NEWLINE  _INDENT  _INDENT #A = int(a_k[0]) _NEWLINE  _INDENT  _INDENT #K = int(a_k[1]) _NEWLINE  _INDENT  _INDENT s = scan() _NEWLINE  _INDENT  _INDENT l = len(s) _NEWLINE  _INDENT  _INDENT if A==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l < 3: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT elif A==2: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l<9: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lim = len(goodStr2[l]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in range(lim): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if hammingDist(goodStr2[l][i],s) <= K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print count _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT else: # A==3 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if l<27: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT lim = len(goodStr3[l]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for i in range(lim): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if hammingDist(goodStr3[l][i],s) <= K: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print count _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE 
def power(a,b): _NEWLINE  _INDENT  _INDENT x=1 _NEWLINE  _INDENT  _INDENT while(b): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(b&1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x=(x*a)%m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=(a*a)%m _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b>>=1 _NEWLINE  _INDENT  _INDENT return x _NEWLINE m=10**9+7 _NEWLINE t=int(raw_input()) _NEWLINE while t>0: _NEWLINE  _INDENT  _INDENT t-=1 _NEWLINE  _INDENT  _INDENT n,k=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if k==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT inv=power(k-1,m-2) _NEWLINE  _INDENT  _INDENT inv=power(inv,3) _NEWLINE  _INDENT  _INDENT inv=(k*inv)%m _NEWLINE  _INDENT  _INDENT temp=power(k,n) _NEWLINE  _INDENT  _INDENT n1=(n*n)%m _NEWLINE  _INDENT  _INDENT t6=(((3*n1)%m+6*n+2)*temp)%m _NEWLINE  _INDENT  _INDENT t1=(2*((temp*k)%m)*(3*n1+3*n+2))%m _NEWLINE  _INDENT  _INDENT t2=(((temp*k*k)%m)*(3*n1-1))%m _NEWLINE  _INDENT  _INDENT temp1=power(k,2*n+1) _NEWLINE  _INDENT  _INDENT t3=(6*(n+1)*temp1)%m _NEWLINE  _INDENT  _INDENT t4=(6*k*((n*temp1)%m))%m _NEWLINE  _INDENT  _INDENT t5=power(k,3*n+2) _NEWLINE  _INDENT  _INDENT ans=(t6+t5-t4+t3+t2-t1-2*k-2)%m _NEWLINE  _INDENT  _INDENT ans=(ans*inv)%m _NEWLINE  _INDENT  _INDENT print ans 
uniqueueId = 0 _NEWLINE class Dictionary(object): _NEWLINE 	#generic dectionary object _NEWLINE 	def __init__(self, type): _NEWLINE 		self.descriptor = type _NEWLINE 		self.hashTable = {} _NEWLINE  _NEWLINE 	def setKeyValPair(self, key, value): _NEWLINE 		self.hashTable[key] = value _NEWLINE  _NEWLINE 	def getValue(self, key): _NEWLINE 		if key in self.hashTable: _NEWLINE 			return self.hashTable[key] _NEWLINE 		return None _NEWLINE  _NEWLINE #helper funcs _NEWLINE def getObject(name): _NEWLINE 	global dictionary _NEWLINE 	obj = dictionary.getValue(name) _NEWLINE 	if obj == None: _NEWLINE 		obj = Person(name) _NEWLINE 		dummyAncestor = Person(None) _NEWLINE 		dummyAncestor.initChildrenList(obj) _NEWLINE 		obj.initParentList(dummyAncestor) _NEWLINE 	return obj _NEWLINE  _NEWLINE def setFirstObjectParentofSecondObject(parentObj, child): _NEWLINE 	#is it possible that parentObj is already a parent of child? No since there are no cyclic relations _NEWLINE 	for parentOtherHalf in child.getParentList(): _NEWLINE 		break _NEWLINE 	newParents = set([parentObj]) _NEWLINE  _NEWLINE 	#update the children set _NEWLINE 	parentObj.appendChildren(parentOtherHalf.getChildrenList()) _NEWLINE 	if type(parentOtherHalf.getName()) != type(1): _NEWLINE 		parentObj.setOtherHalf(parentOtherHalf) _NEWLINE 		parentOtherHalf.setOtherHalf(parentObj) _NEWLINE 		parentOtherHalf.initChildrenList(parentObj.getChildrenList()) _NEWLINE 		newParents.add(parentOtherHalf) _NEWLINE 	elif parentObj.getOtherHalf() != None: _NEWLINE 		existingOtherHalf = parentObj.getOtherHalf() _NEWLINE 		newParents.add(existingOtherHalf) _NEWLINE 		existingOtherHalf.initChildrenList(parentObj.getChildrenList()) _NEWLINE 		 _NEWLINE 	#update the parent set in the children _NEWLINE 	for child in parentObj.getChildrenList(): _NEWLINE 		child.initParentList(newParents) _NEWLINE  _NEWLINE def setTheObjectBros(bro1, bro2): _NEWLINE 	bBro1Parent = not bro1.isMyCurrentParentDummy() _NEWLINE 	bBro2Parent = not bro2.isMyCurrentParentDummy() _NEWLINE 	parent1 = bro1.getParentList() _NEWLINE 	parent2 = bro2.getParentList() _NEWLINE 	for parentBro1 in parent1: _NEWLINE 		break _NEWLINE 	for parentBro2 in parent2: _NEWLINE 		break _NEWLINE 	broBand1 = parentBro1.getChildrenList() _NEWLINE 	broBand2 = parentBro2.getChildrenList() _NEWLINE  _NEWLINE 	if bBro1Parent and bBro2Parent: _NEWLINE 		newParents = parent1.union(parent2) _NEWLINE 		newBroBand = broBand1.union(broBand2) _NEWLINE 		for bro in newBroBand: _NEWLINE 			bro.initParentList(newParents) _NEWLINE 		parentBro1.initChildrenList(newBroBand) _NEWLINE 		parentBro2.initChildrenList(newBroBand) _NEWLINE 		#update other half fields too! _NEWLINE 		if parentBro1.__hash__() != parentBro2.__hash__(): _NEWLINE 			parentBro1.setOtherHalf(parentBro2) _NEWLINE 			parentBro2.setOtherHalf(parentBro1) _NEWLINE 	elif bBro1Parent or bBro2Parent: _NEWLINE 		#make sure that bro1 is the one with valid parent parent1 _NEWLINE 		if not bBro1Parent: _NEWLINE 			bro1, bro2 = bro2, bro1 _NEWLINE 			parent1, parent2 = parent2, parent1 _NEWLINE 			broBand1, broBand2 = broBand2, broBand1 _NEWLINE 		iterParent1 = iter(parent1) _NEWLINE 		half1 = next(iterParent1) _NEWLINE 		half1.appendChildren(broBand2) _NEWLINE 		if len(parent1) == 2: _NEWLINE 			half2 = next(iterParent1) _NEWLINE 			half2.initChildrenList(half1.getChildrenList()) _NEWLINE 		for bro in broBand2: _NEWLINE 			bro.initParentList(parent1) _NEWLINE 	else: _NEWLINE 		#make sure that bro1 is the one with higher no. of bros _NEWLINE 		if len(broBand1) < len(broBand2): _NEWLINE 			bro1, bro2 = bro2, bro1 _NEWLINE 			parent1, parent2 = parent2, parent1 _NEWLINE 			broBand1, broBand2 = broBand2, broBand1 _NEWLINE 		for parent in parent1: _NEWLINE 			break _NEWLINE 		parent.appendChildren(broBand2) _NEWLINE 		for bro in broBand2: _NEWLINE 			bro.initParentList(parent1) _NEWLINE  _NEWLINE def bfs(bfsPerson): _NEWLINE 	global distance, visited, currentVisitedCount _NEWLINE 	bfsPersonId = bfsPerson.__hash__() _NEWLINE 	queue = [[bfsPerson, 0]] _NEWLINE 	while len(queue) != 0: _NEWLINE 		thisPersonEntry = queue.pop(0) _NEWLINE 		thisPerson = thisPersonEntry[0] _NEWLINE 		thisPersonId = thisPerson.__hash__() _NEWLINE 		#mark it as visited and update its distance _NEWLINE 		if visited[thisPersonId] != currentVisitedCount: _NEWLINE 			visited[thisPersonId] = currentVisitedCount _NEWLINE 		else: _NEWLINE 			continue _NEWLINE 		thisPersonDist = thisPersonEntry[1] _NEWLINE 		distance[bfsPersonId][thisPersonId] = thisPersonDist _NEWLINE 		#append thisPersonEntry's parents, siblings, and offsprings to the list, if they are not already visited, _INDENT with updated distance _NEWLINE 		#parents _NEWLINE 		for parent in thisPerson.getParentList(): _NEWLINE 			if type(parent.getName()) != type(1) and visited[parent.__hash__()] != currentVisitedCount: _NEWLINE 				queue.append([parent, thisPersonDist + 1]) _NEWLINE 		#siblings _NEWLINE 		#The outer for loop is executed only once. It serves the purpose of initialization of parent _NEWLINE 		for parent in thisPerson.getParentList(): _NEWLINE 			for sibling in parent.getChildrenList(): _NEWLINE 				if visited[sibling.__hash__()] != currentVisitedCount: _NEWLINE 					queue.append([sibling, thisPersonDist + 1]) _NEWLINE 			break; _NEWLINE 		#children _NEWLINE 		for child in thisPerson.getChildrenList(): _NEWLINE 			if visited[child.__hash__()] != currentVisitedCount: _NEWLINE 				queue.append([child, thisPersonDist + 1]) _NEWLINE 		 _NEWLINE  _NEWLINE def getDistance(person1, person2): _NEWLINE 	global distance, currentVisitedCount _NEWLINE 	if distance[person1.__hash__()][person1.__hash__()] == 0: _NEWLINE 		return distance[person1.__hash__()][person2.__hash__()] _NEWLINE 	elif distance[person2.__hash__()][person2.__hash__()] == 0: _NEWLINE 		return distance[person2.__hash__()][person1.__hash__()] _NEWLINE 	else:#polulate the distance array for person1 _NEWLINE 		bfs(person1) _NEWLINE 		currentVisitedCount += 1 _NEWLINE 		return distance[person1.__hash__()][person2.__hash__()] _NEWLINE  _NEWLINE class Person(object): _NEWLINE 	def __init__(self, name): _NEWLINE 		#if name is None, its a dummy object. _NEWLINE 		global dictionary, uniqueueId _NEWLINE 		if name == None: _NEWLINE 			self.name = uniqueueId _NEWLINE 		else: _NEWLINE 			self.name = name _NEWLINE 		self.uid = uniqueueId _NEWLINE 		uniqueueId += 1 _NEWLINE 		self.otherHalf = None _NEWLINE 		#use dictionary instead of list _NEWLINE 		self.parents = set() _NEWLINE 		self.children = set() _NEWLINE 		dictionary.setKeyValPair(self.name, self) _NEWLINE  _NEWLINE 	def __hash__(self): _NEWLINE 		# The only required property is that objects which compare equal have the same hash value _NEWLINE 		return self.uid _NEWLINE 	 _NEWLINE 	def __str__(self): _NEWLINE 		return str(self.name) _NEWLINE  _NEWLINE 	def getName(self): _NEWLINE 		return self.name _NEWLINE  _NEWLINE 	def getOtherHalf(self): _NEWLINE 		return self.otherHalf _NEWLINE  _NEWLINE 	def getParentList(self): _NEWLINE 		return self.parents _NEWLINE  _NEWLINE 	def getChildrenList(self): _NEWLINE 		return self.children _NEWLINE  _NEWLINE 	def appendChildren(self, children): _NEWLINE 		if isinstance(children , set): _NEWLINE 			self.children = self.children.union(children) _NEWLINE 		else: _NEWLINE 			self.children.add(children) _NEWLINE  _NEWLINE 	def initChildrenList(self, children): _NEWLINE 		#used for setting same set of children for both parents, so that changes are propogated to them _NEWLINE 		if isinstance(children , set): _NEWLINE 			self.children = children _NEWLINE 		#used while normal initialization of child od dummy parent _NEWLINE 		else: _NEWLINE 			self.children = set([children]) _NEWLINE  _NEWLINE 	def appendParent(self, parent): _NEWLINE 		if isinstance(parent, set): _NEWLINE 			self.parents = self.parents.union(parent) _NEWLINE 		else: _NEWLINE 			self.parents.add(parent) _NEWLINE  _NEWLINE 	def initParentList(self, parents): _NEWLINE 		#used for setting same set of parent for all the children, so that changes are propogated to all _NEWLINE 		if isinstance(parents, set): _NEWLINE 			self.parents = parents _NEWLINE 		#used while normal initialization of dummy parent for a child _NEWLINE 		else: _NEWLINE 			self.parents = set([parents]) _NEWLINE  _NEWLINE 	def setOtherHalf(self, otherHalf): _NEWLINE 		self.otherHalf = otherHalf _NEWLINE  _NEWLINE 	def isMyCurrentParentDummy(self): _NEWLINE 		return len(self.parents) == 1 and type(next(iter(self.parents)).getName()) == type(1) _NEWLINE  _NEWLINE  _NEWLINE #main prog _NEWLINE #create a dictionary to lookup Person object from its name _NEWLINE dictionary = Dictionary("nameLookupTable") _NEWLINE NRStr = raw_input().split() _NEWLINE N = int(NRStr[0]) _NEWLINE R = int(NRStr[1]) _NEWLINE for i in range(R): _NEWLINE 	relation = raw_input().split() _NEWLINE 	if relation[2] == "father" or relation[2] == "mother": _NEWLINE 		parentObj = getObject(relation[0]) _NEWLINE 		child = getObject(relation[4]) _NEWLINE 		setFirstObjectParentofSecondObject(parentObj, child) _NEWLINE 	elif relation[2] == "son" or relation[2] == "daughter": _NEWLINE 		parentObj = getObject(relation[4]) _NEWLINE 		child = getObject(relation[0]) _NEWLINE 		setFirstObjectParentofSecondObject(parentObj, child) _NEWLINE 	else: _NEWLINE 		c1 = getObject(relation[0]) _NEWLINE 		c2 = getObject(relation[4]) _NEWLINE 		setTheObjectBros(c1, c2) _NEWLINE 	 _NEWLINE #for name in dictionary.hashTable: _NEWLINE #	personObj = dictionary.hashTable[name] #This is hacky _NEWLINE #	if type(personObj.getName()) != type(1): _NEWLINE #		print _NEWLINE #		print "person name: ", personObj _NEWLINE #		print "Other half: ", personObj.getOtherHalf() _NEWLINE #		print "Its offsprings: \n\t", _INDENT _NEWLINE #		for child in personObj.getChildrenList(): _NEWLINE #			print child, _NEWLINE #		print _NEWLINE #		print "Its parent list: \n\t", _INDENT _NEWLINE #		for parent in personObj.getParentList(): _NEWLINE #			print parent, _NEWLINE #		print _NEWLINE #distance is 2d list which is indexed by person's uniqueue id. uniqueue id can never go beyond 2*N _NEWLINE distance = [[ -1 for i in range(2*N + 1)] for j in range(2*N + 1)] _NEWLINE currentVisitedCount = 1 _NEWLINE visited = [0] * 2*N _NEWLINE Q = int(raw_input()) _NEWLINE for i in range(Q): _NEWLINE 	strXY = raw_input().split() _NEWLINE 	X = getObject(strXY[0]) _NEWLINE 	Y = getObject(strXY[1]) _NEWLINE 	print getDistance(X, Y) _NEWLINE 
cases=int(raw_input()) _NEWLINE while cases: _NEWLINE 	length=int(raw_input()) _NEWLINE 	m=raw_input().split() _NEWLINE 	arr=map(int,m) _NEWLINE 	 _NEWLINE 	hash=[-1]*length _NEWLINE 	modu=[0]*(length+1) _NEWLINE 	sum=0 _NEWLINE 	modu[0]=0 _NEWLINE 	hash[0]=0 _NEWLINE 	for i in range(1,length+1): _NEWLINE 		sum=sum+arr[i-1] _NEWLINE 		x=sum%length _NEWLINE 		if hash[x]==-1: _NEWLINE 			hash[x]=i _NEWLINE 		else: _NEWLINE 			count=i-hash[x] _NEWLINE 			print count _NEWLINE 			for j in range(hash[x],i): _NEWLINE 				print j+1, _NEWLINE 			print " "		 _NEWLINE 			break		 _NEWLINE 	cases-=1 _NEWLINE 	 _NEWLINE 	 _NEWLINE 		 _NEWLINE 	 _NEWLINE 		 _NEWLINE 	 _NEWLINE 	 _NEWLINE 
import sys,copy _NEWLINE mynumber=0 _NEWLINE def merge(a,b,n,m): _NEWLINE  _INDENT  _INDENT global mynumber _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT j=0 _NEWLINE  _INDENT  _INDENT c=[] _NEWLINE  _INDENT  _INDENT if(n==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return b _NEWLINE  _INDENT  _INDENT if(m==0): _NEWLINE  _INDENT  _INDENT  _INDENT return a _NEWLINE  _INDENT  _INDENT while((i<n) and (j<m)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(a[i]<=b[j]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=[a[i]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c+=[b[j]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT mynumber+=len(a[i:]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT if(i<n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c+=a[i:] _NEWLINE  _INDENT  _INDENT if(j<m): _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c+=b[j:] _NEWLINE  _INDENT  _INDENT return c _NEWLINE def mergesort(a,n): _NEWLINE  _INDENT  _INDENT if(n==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return a _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=mergesort(a[:n/2],n/2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=mergesort(a[n/2:],n-n/2) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return merge(b,c,n/2,n-n/2) _NEWLINE def count_inversions(arr,n): _NEWLINE  _INDENT  _INDENT global mynumber _NEWLINE  _INDENT  _INDENT mynumber=0 _NEWLINE  _INDENT  _INDENT arr2=copy.deepcopy(arr) _NEWLINE  _INDENT  _INDENT #arr2[x],arr2[y]=arr2[y],arr2[x] _NEWLINE  _INDENT  _INDENT mergesort(arr2,n) _NEWLINE  _INDENT  _INDENT return mynumber _NEWLINE def another_count_inversions(arr,n): _NEWLINE  _INDENT  _INDENT i=0 _NEWLINE  _INDENT  _INDENT count=0 _NEWLINE  _INDENT  _INDENT while i<n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT j=i+1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while j<n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(arr[j]<arr[i]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT count+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT j+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1 _NEWLINE  _INDENT  _INDENT return count _NEWLINE def count_inversions2(a,n): _NEWLINE  _INDENT res = 0 _NEWLINE  _INDENT counts = [0]*(n+1) _NEWLINE  _INDENT rank = { v : i+1 for i, v in enumerate(sorted(a)) } _NEWLINE  _INDENT for x in reversed(a): _NEWLINE  _INDENT  _INDENT i = rank[x] - 1 _NEWLINE  _INDENT  _INDENT while i: _NEWLINE  _INDENT  _INDENT  _INDENT res += counts[i] _NEWLINE  _INDENT  _INDENT  _INDENT i -= i & -i _NEWLINE  _INDENT  _INDENT i = rank[x] _NEWLINE  _INDENT  _INDENT while i <= len(a): _NEWLINE  _INDENT  _INDENT  _INDENT counts[i] += 1 _NEWLINE  _INDENT  _INDENT  _INDENT i += i & -i _NEWLINE  _INDENT return res _NEWLINE n,q=[int(x) for x in raw_input().split()] _NEWLINE arr=[int(x) for x in raw_input().split()] _NEWLINE value=count_inversions2(arr,n) _NEWLINE while q: _NEWLINE  _INDENT  _INDENT x,y=[int(x) for x in raw_input().split()] _NEWLINE  _INDENT  _INDENT if(x>y): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(arr[x-1]>arr[y-1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT value+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT value-=1 _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(arr[y-1]>arr[x-1]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT value+=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT value-=1 _NEWLINE  _INDENT  _INDENT k=x-1 _NEWLINE  _INDENT  _INDENT z=y-1 _NEWLINE  _INDENT  _INDENT arr[k],arr[z]=arr[z],arr[k] _NEWLINE  _INDENT  _INDENT print value%2 _NEWLINE  _INDENT  _INDENT q-=1 _NEWLINE  _INDENT  _INDENT  _NEWLINE 
import numpy as np _NEWLINE import math _NEWLINE def inv_2(A): _NEWLINE  _INDENT  _INDENT M=A.size _NEWLINE  _INDENT  _INDENT N=int(math.sqrt(M)) _NEWLINE  _INDENT  _INDENT bakra=np.copy(A) _NEWLINE  _INDENT  _INDENT inv=np.identity(N,int) _NEWLINE  _INDENT  _INDENT for i in xrange(0,N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if bakra[i,i] == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT loc=np.where(bakra[i:N,i]==1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT p=len(loc[0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if p >= 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT loc = loc[0][0] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT loc=loc + i _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bakra[i,:]= (bakra[i,:] + bakra[loc,:])%2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT inv[i,:]= (inv[i,:] + inv[loc,:])%2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if bakra[i,i] == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i + 1,N): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if bakra[j,i] == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bakra[j,:]=(bakra[i,:] + bakra[j,:])%2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT inv[j,:]=(inv[i,:] + inv[j,:])%2 _NEWLINE  _INDENT  _INDENT for i in xrange(N-1,-1,- 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in xrange(i - 1,-1,- 1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if bakra[j,i] == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT bakra[j,:]=(bakra[i,:] + bakra[j,:])%2 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT inv[j,:]=(inv[i,:] + inv[j,:])%2 _NEWLINE  _INDENT  _INDENT return inv _NEWLINE  _INDENT  _NEWLINE def playMatrix(siz): _NEWLINE  _INDENT  _INDENT v=None _NEWLINE  _INDENT  _INDENT I=np.identity(siz,int) _NEWLINE  _INDENT  _INDENT Z=I * 0 _NEWLINE  _INDENT  _INDENT C=np.identity(siz,int) _NEWLINE  _INDENT  _INDENT for pp in range(siz): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for qq in range(siz): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT diff = abs(pp-qq) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if diff <=1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT C[pp,qq]=1 _NEWLINE  _NEWLINE 			 _NEWLINE  _INDENT  _INDENT for pp in range(siz): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c = None _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for qq in range(siz): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT diff = abs(pp-qq) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if diff == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT TMP = C _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif diff ==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT TMP = I _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT TMP = Z _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if qq ==0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = TMP _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c = np.hstack((c,TMP)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if pp ==0 : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v=c _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT v = np.vstack((v,c)) _NEWLINE  _INDENT  _INDENT return v _NEWLINE for gg in range(0,int((raw_input()))): _NEWLINE  _INDENT  _INDENT siz = int(raw_input()) _NEWLINE  _INDENT  _INDENT A = playMatrix(siz) _NEWLINE  _INDENT  _INDENT iA= inv_2(A) _NEWLINE  _INDENT  _INDENT B=[] _NEWLINE  _INDENT  _INDENT for xx in range(siz): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT B = B+ map(int,(list(raw_input().strip()))) _NEWLINE  _INDENT  _INDENT B = np.array(B,int) _NEWLINE  _INDENT  _INDENT ans = np.dot(B,iA)%2 _NEWLINE  _INDENT  _INDENT i=0 _INDENT  _NEWLINE  _INDENT  _INDENT print int(sum(ans)) _NEWLINE  _NEWLINE  _INDENT  _INDENT for k in ans: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if int(k)==1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print str(i/siz+1) +' '+str(i%siz + 1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT i+=1
from math import sqrt _NEWLINE  _INDENT _NEWLINE def fn(): _NEWLINE  _INDENT  _INDENT a,b,c = map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT if a == 0 and b > 0 and c==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print -1 _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return _INDENT _NEWLINE  _INDENT  _INDENT af,cf = [], [] _NEWLINE  _INDENT  _INDENT for i in range(1,int(sqrt(a))+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i*i == a: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT af.append(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT af.append(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT af.append(a/i) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT for i in range(1,int(sqrt(c))+1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i*i == c: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cf.append(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if c%i==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cf.append(i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cf.append(c/i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT xy = [] _NEWLINE  _INDENT  _INDENT for g in af: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if g*g - b*g>0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if (g*c+a)%(g*g-b*g)==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT xy.append((g*c+a)/(g*g-b*g)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif g*g - b*g == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if a == 0 and c ==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print -1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return _INDENT _NEWLINE  _INDENT  _INDENT if a==0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for x in cf: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT xy.append(c/x) _NEWLINE  _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT np = [] _NEWLINE  _INDENT  _INDENT for i in xy: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cnt = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for j in range(2,int(sqrt(i)+1)): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if i%j == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT while(i%j==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT i/=j _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if i != 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT cnt += 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT np.append(cnt) _NEWLINE  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT sm = 0 _NEWLINE  _INDENT  _INDENT for i in np: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT sm+=pow(2,i) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE  _INDENT  _INDENT print sm _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE t = int(raw_input()) _NEWLINE for i in range(t): _NEWLINE  _INDENT  _INDENT fn() _INDENT 
#!/usr/bin/env python _NEWLINE  _NEWLINE # _NEWLINE # a basic implementation of the Pollard rho factorization _NEWLINE # Written by Mark VandeWettering <markv@pixar.com> _NEWLINE # _NEWLINE  _NEWLINE import sys _NEWLINE import locale _NEWLINE import random _NEWLINE try: _NEWLINE  _INDENT  _INDENT import readline _NEWLINE except ImportError, msg: _NEWLINE  _INDENT  _INDENT print msg _NEWLINE  _INDENT  _INDENT print "Line editing disabled." _NEWLINE  _NEWLINE # an inefficient but straightforward way to find primes... _NEWLINE  _NEWLINE def primes(n): _NEWLINE  _INDENT  _INDENT primes = [2] _NEWLINE  _INDENT  _INDENT for x in range(3, n, 2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT prime = True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for p in primes: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if p * p > n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if x % p == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # it's composite.. _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT prime = False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if prime: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT primes.append(x) _NEWLINE  _INDENT  _INDENT return primes _NEWLINE  _NEWLINE class FactorError(Exception): _NEWLINE  _INDENT  _INDENT def __init__(self, value): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT self.value = value _NEWLINE  _INDENT  _INDENT def __str__(self): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return repr(self.value) _NEWLINE  _NEWLINE def miller_rabin_pass(a, n): _NEWLINE  _INDENT  _INDENT d = n - 1 _NEWLINE  _INDENT  _INDENT s = 0 _NEWLINE  _INDENT  _INDENT while d % 2 == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d >>= 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s += 1 _NEWLINE  _NEWLINE  _INDENT  _INDENT a_to_power = pow(a, d, n) _NEWLINE  _INDENT  _INDENT if a_to_power == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT for i in xrange(s-1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if a_to_power == n - 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return True _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a_to_power = (a_to_power * a_to_power) % n _NEWLINE  _INDENT  _INDENT return a_to_power == n - 1 _NEWLINE  _NEWLINE def isprime(n): _NEWLINE  _INDENT  _INDENT for repeat in xrange(20): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = 0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while a == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT a = random.randrange(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not miller_rabin_pass(a, n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT return True _NEWLINE  _NEWLINE def gcd(a, b): _NEWLINE  _INDENT  _INDENT while b != 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a, b = b, a%b _NEWLINE  _INDENT  _INDENT return a _NEWLINE  _NEWLINE def findfactor(n): _NEWLINE  _INDENT  _INDENT for c in range(1, 10): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = y = random.randint(1, n-1) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT x = (x * x + c) % n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = (y * y + c) % n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT y = (y * y + c) % n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT t = gcd(n, abs(x-y)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if t == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT x = (x * x + c) % n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y = (y * y + c) % n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT y = (y * y + c) % n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT elif t == n: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return t _NEWLINE  _INDENT  _INDENT raise FactorError("couldn't find a factor.") _NEWLINE  _NEWLINE def factor(n): _NEWLINE  _INDENT  _INDENT r = [] _NEWLINE  _INDENT  _INDENT for p in primes(10000): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while n % p == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r.append(p) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n = n / p _NEWLINE  _INDENT  _INDENT if n == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return r _NEWLINE  _INDENT  _INDENT while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if isprime(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r.append(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT f = findfactor(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r.append(f) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n = n / f _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT except FactorError, msg: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r.append(n) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _INDENT  _INDENT r.sort() _NEWLINE  _INDENT  _INDENT return r _NEWLINE  _NEWLINE # this function would be easier to write recursively, but _NEWLINE # python isn't good at tail recursion, so in theory, it could _NEWLINE # fail. _INDENT Too bad. _NEWLINE  _NEWLINE def shorten(flist): _NEWLINE  _INDENT  _INDENT slist = [] _NEWLINE  _INDENT  _INDENT idx = 0 _NEWLINE  _INDENT  _INDENT while flist[idx:] != []: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT hd = flist[idx] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT idx = idx + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT exp = 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT while flist[idx:] != [] and flist[idx] == hd: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT exp = exp + 1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT idx = idx + 1 _NEWLINE 	 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if exp > 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT 	slist.append([hd,exp]) _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE 		#slist.append(locale.format("%d", hd, True) + "**"+str(exp)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else: _NEWLINE 		slist.append([hd,exp]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  # slist.append(locale.format("%d", hd, True)) _NEWLINE  _INDENT  _INDENT return slist _NEWLINE  _NEWLINE def factorit(n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT flist = shorten(factor(n)) _NEWLINE 	sum=0 _NEWLINE 	for pair in flist: _NEWLINE 		sum+=pair[0]*pair[1] _NEWLINE 	return sum _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE while True: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT try: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT num = input() _NEWLINE 		if(num<2): _NEWLINE 			print num _NEWLINE 		else: _NEWLINE 			print factorit(num) _NEWLINE 				 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #except NameError, msg: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print >> sys.stderr, msg _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #except SyntaxError, msg: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print >> sys.stderr, msg _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT #except KeyboardInterrupt, msg: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print >> sys.stderr, "**Interrupted**" _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #continue _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT except EOFError, msg: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT #print _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT break _NEWLINE  _NEWLINE 
def prime(n,p): _NEWLINE 	i=2 _NEWLINE 	a=[0]*(n+1) _NEWLINE 	i=2 _NEWLINE 	while (i<=n): _NEWLINE 		if (a[i]==0): _NEWLINE 			p.append(i); _NEWLINE 			j=i*i; _NEWLINE 			while (j<=n): _NEWLINE 				a[j]=1; _NEWLINE 				j+=i; _NEWLINE 		i+=1; _NEWLINE 	return len(p) _NEWLINE  _NEWLINE def checksq(a): _NEWLINE 	b=int(a**0.5) _NEWLINE 	return b*b==a _NEWLINE  _NEWLINE def gcd(a,b): _NEWLINE 	if a%b==0: _NEWLINE 		return b _NEWLINE 	return gcd(b,a%b) _NEWLINE  _NEWLINE def pow22(base,ex,k): _NEWLINE 	a=base _NEWLINE 	re=1 _NEWLINE 	while (ex>0): _NEWLINE 		if (ex%2==1): _NEWLINE 			re=re*a; _NEWLINE 			re=re%k; _NEWLINE 		a=a*a; _NEWLINE 		a=a%k; _NEWLINE 		ex=ex/2; _NEWLINE 	return re; _NEWLINE  _NEWLINE MAX=10**6 _NEWLINE MOD=1000000007 _NEWLINE  _NEWLINE p=[] _NEWLINE prime(10**6,p) _NEWLINE MAX=len(p) _NEWLINE cube=[] _NEWLINE sq=[] _NEWLINE one=[] _NEWLINE i=0 _NEWLINE while i<MAX: _NEWLINE 	cube.append(p[i]*p[i]*p[i]) _NEWLINE 	sq.append(p[i]*p[i]) _NEWLINE 	one.append(p[i]) _NEWLINE 	i+=1 _NEWLINE  _NEWLINE t=input() _NEWLINE while t: _NEWLINE 	ans=1 _NEWLINE 	n=input() _NEWLINE 	pow1=[] _NEWLINE 	pow2=[] _NEWLINE 	d={} _NEWLINE 	b=map(int,raw_input().split()) _NEWLINE 	a=[] _NEWLINE 	for x in b: _NEWLINE 		i=0 _NEWLINE 		while x>1 and i<MAX and x>=one[i]*one[i]*one[i]: _NEWLINE 			if (x%cube[i]==0): _NEWLINE 				x/=cube[i] _NEWLINE 				if p[i] in d: _NEWLINE 					d[p[i]]+=3 _NEWLINE 				else: _NEWLINE 					d[p[i]]=3 _NEWLINE 				i-=1 _NEWLINE 			elif (x%sq[i]==0): _NEWLINE 				x/=sq[i] _NEWLINE 				if p[i] in d: _NEWLINE 					d[p[i]]+=2 _NEWLINE 				else: _NEWLINE 					d[p[i]]=2 _NEWLINE 				i-=1 _NEWLINE 			elif (x%one[i]==0): _NEWLINE 				x/=one[i] _NEWLINE 				if p[i] in d: _NEWLINE 					d[p[i]]+=1 _NEWLINE 				else: _NEWLINE 					d[p[i]]=1 _NEWLINE 				i-=1 _NEWLINE 			i+=1 _NEWLINE 		if (x!=1): _NEWLINE 			a.append(x) _NEWLINE 	i=0 _NEWLINE 	while i<len(a): _NEWLINE 		j=i+1 _NEWLINE 		while j<len(a): _NEWLINE 			g=gcd(a[i],a[j]) _NEWLINE 			if (g!=1 and g!=max(a[j],a[i])): _NEWLINE 				if (a[i]/g in d): _NEWLINE 					d[a[i]/g]+=1 _NEWLINE 				else: _NEWLINE 					d[a[i]/g]=1 _NEWLINE 				if (a[j]/g in d): _NEWLINE 					d[a[j]/g]+=1 _NEWLINE 				else: _NEWLINE 					d[a[j]/g]=1 _NEWLINE 				if g in d: _NEWLINE 					d[g]+=2 _NEWLINE 				else: _NEWLINE 					d[g]=2 _NEWLINE 				a[i]=1 _NEWLINE 				a[j]=1 _NEWLINE 			j+=1 _NEWLINE 		i+=1 _NEWLINE  _NEWLINE 	for x in a: _NEWLINE 		if x!=1: _NEWLINE 			if (checksq(x)): _NEWLINE 				y=int(x**0.5) _NEWLINE 				if y in d: _NEWLINE 					d[y]+=2 _NEWLINE 				else: _NEWLINE 					d[y]=2 _NEWLINE 			else: _NEWLINE 				if x in d: _NEWLINE 					d[x]+=1 _NEWLINE 				else: _NEWLINE 					d[x]=1 _NEWLINE  _NEWLINE 	te=d.keys() _NEWLINE 	for x in te: _NEWLINE 		for y in te: _NEWLINE 			g=gcd(x,y) _NEWLINE 			if (x!=y and g!=1): _NEWLINE 				if (x/g in d): _NEWLINE 					d[x/g]+=min(d[x],d[y]) _NEWLINE 				else: _NEWLINE 					d[x/g]=min(d[x],d[y]) _NEWLINE 				if (y/g in d): _NEWLINE 					d[y/g]+=min(d[x],d[y]) _NEWLINE 				else: _NEWLINE 					d[y/g]=min(d[x],d[y]) _NEWLINE 				if g in d: _NEWLINE 					d[g]+=min(d[x],d[y])*2 _NEWLINE 				else: _NEWLINE 					d[g]=min(d[x],d[y])*2 _NEWLINE 				d[x],d[y]=d[x]-min(d[x],d[y]),d[y]-min(d[x],d[y]) _NEWLINE 	for x in d: _NEWLINE 		if (d[x]!=0): _NEWLINE 			if (d[x]%3==0): _NEWLINE 				mult=d[x] _NEWLINE 			else: _NEWLINE 				mult=(d[x]/3+1)*3 _NEWLINE 			ans=ans*pow22(x,mult,MOD) _NEWLINE 			ans%=MOD _NEWLINE 	print ans _NEWLINE 	t-=1
import math _NEWLINE # def isWinning(position, memo = None): _NEWLINE # 	if memo == None: _NEWLINE # 		#Initialize memo on first call. _NEWLINE # 		memo = {} _NEWLINE # 	if position in memo: _NEWLINE # 		return memo[position] _NEWLINE # 	if position == 0: _NEWLINE # 		memo[position] = 0 _NEWLINE # 		return 0 _NEWLINE # 	moves = [] _NEWLINE # 	if position >=0: _NEWLINE # 		moves.append(position//6) _NEWLINE # 	if position >=0: _NEWLINE # 		moves.append(position//5) _NEWLINE # 	if position >=0: _NEWLINE # 		moves.append(position//4) _NEWLINE # 	if position >=0: _NEWLINE # 		moves.append(position//3) _NEWLINE # 	if position >=0: _NEWLINE # 		moves.append(position//2) _NEWLINE # 	for x in moves: _NEWLINE # 		if not isWinning(x, memo) == 1: _NEWLINE # 			memo[position] = 1 _NEWLINE # 			return 1 _NEWLINE # 	memo[position] = 0 _NEWLINE # 	return 0 _NEWLINE def grundyNumbers(position, memo = None): _NEWLINE 	if memo == None: _NEWLINE 		memo = {} _NEWLINE 	if position in memo: _NEWLINE 		return memo[position] _NEWLINE 	if position == 0: _NEWLINE 		return 0 _NEWLINE 	moves = [] _NEWLINE 	moves.append(grundyNumbers(position//6, memo)) _NEWLINE 	moves.append(grundyNumbers(position//5, memo)) _NEWLINE 	moves.append(grundyNumbers(position//4, memo)) _NEWLINE 	moves.append(grundyNumbers(position//3, memo)) _NEWLINE 	moves.append(grundyNumbers(position//2, memo)) _NEWLINE 	moves.sort() _NEWLINE 	answer = 0 _NEWLINE 	for x in moves: _NEWLINE 		if answer == x: _NEWLINE 			answer += 1 _NEWLINE 	memo[position] = answer _NEWLINE 	return answer _NEWLINE  _NEWLINE  _NEWLINE def isWinning2(position): _NEWLINE 	if position == 0: _NEWLINE 		return 0 _NEWLINE 	if position == 1: _NEWLINE 		return 1 _NEWLINE 	if position == 2 or position == 3: _NEWLINE 		return 2 _NEWLINE 	if position == 4 or position == 5: _NEWLINE 		return 3 _NEWLINE 	p = int(math.log(2*position, 12)) _NEWLINE 	if math.log(2*position + 1) < math.log(12)*p + math.log(2): _NEWLINE 		return 0 _NEWLINE 	elif math.log(2*position + 1) < math.log(12)*p + math.log(4): _NEWLINE 		return 1 _NEWLINE 	elif math.log(2*position + 1) < math.log(12)*p + math.log(8): _NEWLINE 		return 2 _NEWLINE 	else: _NEWLINE 		return 3 _NEWLINE  _NEWLINE grunds = [0, 1, 2, 2, 3, 3, 0, 0, 0, 0, 0, 0] _NEWLINE def grundy2(n): _NEWLINE 	return grunds[n] if n < 12 else grundy2(n / 12) _NEWLINE 	 _NEWLINE  _NEWLINE test_case = int(raw_input()) _NEWLINE for t in xrange(test_case): _NEWLINE 	n = int(raw_input()) _NEWLINE 	array = map(int, raw_input().split()) _NEWLINE 	result = 0 _NEWLINE 	for a in xrange(len(array)): _NEWLINE 		if a == 0: _NEWLINE 			result = grundy2(array[a]) _NEWLINE 		else: _NEWLINE 			result = result^grundy2(array[a]) _NEWLINE 	#print result _NEWLINE 	if result == 0: _NEWLINE 		print 'Derek' _NEWLINE 	else: _NEWLINE 		print 'Henry' _NEWLINE # import random _NEWLINE # for i in xrange(100000): _NEWLINE # 	value = random.randint(1,10*18) _NEWLINE # 	if not isWinning2(value) == grundy2(value): _NEWLINE # 		print 'F' _NEWLINE # for i in range(100000): _NEWLINE 	# isWinning2(i) _NEWLINE # print grundyNumbers(10**18) _NEWLINE # print grundyNumbers(1)^grundyNumbers(2)
def minCost(n,c,m, p): _NEWLINE 	if n == 1: _NEWLINE 		return '0.000000000' _NEWLINE 	 _NEWLINE 	if c.find('.') != -1: _NEWLINE 		arr = c.split('.') _NEWLINE 		ic = int(arr[0]) _NEWLINE 		while len(arr[1]) != 9: _NEWLINE 			arr[1] = arr[1] + '0' _NEWLINE 		fc = '0'+ '.' + arr[1] _NEWLINE 		ccoeff = n-m-1 _NEWLINE 		tp = n*(n-1) _NEWLINE 	else: _NEWLINE 		ic = int(c) _NEWLINE 		fc = '0.000000000' _NEWLINE  _NEWLINE 	#print "ic : ", ic, "fc : ", fc _NEWLINE 	 _NEWLINE 	mintpSpTree = 2*(n-1)* (n-1) _NEWLINE 	mintp = n*(n-1) _NEWLINE 	#minFlyCost = c*(n-m-1) _NEWLINE 	twoDistinctEdges = False; _NEWLINE  _NEWLINE 	if m == 0: _NEWLINE 		tp = mintpSpTree _NEWLINE 		minedges = n-1 _NEWLINE 		if ic <2: #fully connected graph _NEWLINE 			tp = mintp _NEWLINE 			ccoeff = (n*(n-1))/2 _NEWLINE 		elif ic >=2: _NEWLINE 			tp = mintpSpTree _NEWLINE 			ccoeff = n-1 _NEWLINE 	elif m == 1: _NEWLINE 		tp = mintpSpTree _NEWLINE 		minedges = n-2 _NEWLINE 		if ic < 2: #fully connected graph _NEWLINE 			tp = mintp _NEWLINE 			ccoeff = (n*(n-1))/2 - 1 _NEWLINE 		elif ic >=2: _NEWLINE 			tp = mintpSpTree _NEWLINE 			ccoeff = n-2 _NEWLINE 	else: _NEWLINE 		#only one edge points are same _NEWLINE 		if((p[0][0] == p[1][0] or p[0][0] == p[1][1]) and( p[0][1] == p[1][0] or p[0][1] == p[1][1])): _INDENT _NEWLINE 			tp = mintpSpTree _NEWLINE 			minedges = n-2 _NEWLINE 			if ic < 2: #fully connected graph _NEWLINE 				tp = mintp _NEWLINE 				ccoeff = (n*(n-1))/2 - 1 _NEWLINE 			elif ic >=2: _NEWLINE 				tp = mintpSpTree _NEWLINE 				ccoeff = n-2 _NEWLINE 		#two edges sharing one node _INDENT _NEWLINE 		elif(p[0][0] == p[1][0] or p[0][0] == p[1][1] or p[0][1] == p[1][0] or p[0][1] == p[1][1]): _INDENT _NEWLINE 			tp = mintpSpTree _NEWLINE 			minedges = n-3 _NEWLINE 			if ic < 2: _INDENT _NEWLINE 				tp = mintp _NEWLINE 				ccoeff = (n*(n-1))/2 - 2 _NEWLINE 			elif ic >=2: _NEWLINE 				tp = mintpSpTree _NEWLINE 				ccoeff = n-3 _NEWLINE 		#two distinct edges _NEWLINE 		else: _NEWLINE 			minedges = n-3 _NEWLINE 			tp1 = 2*(n+1)*(n-2) _NEWLINE 			ccoeff1 = n-3 _NEWLINE  _NEWLINE 			tp2 = mintpSpTree-2 _NEWLINE 			ccoeff2 = n-2 _NEWLINE 			 _NEWLINE 			if ic>=2*(n-2): _NEWLINE 				tp = tp1 _NEWLINE 				ccoeff = ccoeff1 _NEWLINE 			else: _NEWLINE 				tp = tp2 _NEWLINE 				ccoeff = ccoeff2 _NEWLINE 				if ic < 2: _NEWLINE 					tp = mintp _NEWLINE 					ccoeff = (n*(n-1))/2 -2 _NEWLINE 				elif ic >=2: _NEWLINE 					tp = tp2 _NEWLINE 					ccoeff = ccoeff2 _NEWLINE 		 _NEWLINE 	#print "--------ic : ", ic, "fc : ", fc _NEWLINE 	#print "--------tp : ", tp, "ccoeff : ", ccoeff _NEWLINE 	 _NEWLINE 	itotal = ic* ccoeff + tp _NEWLINE 	#print "itotal is ", itotal _NEWLINE 	ftotal = int(fc[2:]) _NEWLINE 	#print "ftotal is ", ftotal _NEWLINE 	 _NEWLINE 	ftotal = ftotal*ccoeff _NEWLINE 	#print "ftotal 1 is ", ftotal _NEWLINE 	fitotal = ftotal/1000000000 _NEWLINE 	itotal = itotal + fitotal _NEWLINE 	#print "fitotap is ", fitotal _NEWLINE 	ftotal = ftotal - fitotal*1000000000 _NEWLINE 	#print "11ftotap is ", fitotal _NEWLINE 	#print "22ftotal is ", ftotal _NEWLINE 	sf = "%s"%ftotal _NEWLINE 	while len(sf)!=9: _NEWLINE 		sf = '0' + sf _NEWLINE 	si = "%s"%itotal _NEWLINE 	return si + '.' + sf _NEWLINE  _NEWLINE  _NEWLINE 		#itotal = itotal + fitotal _NEWLINE 		 _NEWLINE 		#ftotal = fc*ccoeff _NEWLINE 		#if ftotal >1: _NEWLINE 		#	iftotal = int(ftotal) _NEWLINE 		#	ftotal = ftotal - iftotal _NEWLINE 		#	itotal = itotal + iftotal _NEWLINE 		#a = "%d"%itotal _NEWLINE 		#b = "%.9f"%ftotal _NEWLINE 		#return a+b _NEWLINE 		#return mintc1 _NEWLINE if __name__ == "__main__": _NEWLINE 	t = int(raw_input()) _NEWLINE 	for i in range(0,t): _NEWLINE 		n = 0 _NEWLINE 		c = 0 _NEWLINE 		m = 0; _NEWLINE 		s = raw_input() _NEWLINE 		s = s.split(' ') _NEWLINE 		n = int(s[0]) _NEWLINE 		c = s[1] _NEWLINE 		m = int(s[2]) _NEWLINE 		l = [] _NEWLINE 		for k in range(0,m): _NEWLINE 			s1 = raw_input() _NEWLINE 			s1 = s1.split(' ') _NEWLINE 			p1 = int(s1[0]) _NEWLINE 			p2 = int(s1[1]) _NEWLINE 			l.append((p1,p2)) _NEWLINE 			 _NEWLINE 		print minCost(n,c,m,l) _NEWLINE 
#include <algorithm> _NEWLINE #include <iostream> _NEWLINE #include <sstream> _NEWLINE #include <cassert> _NEWLINE #include <cstring> _NEWLINE #include <cstdlib> _NEWLINE #include <cstdio> _NEWLINE #include <string> _NEWLINE #include <vector> _NEWLINE #include <bitset> _NEWLINE #include <queue> _NEWLINE #include <stack> _NEWLINE #include <cmath> _NEWLINE #include <deque> _NEWLINE #include <ctime> _NEWLINE #include <list> _NEWLINE #include <set> _NEWLINE #include <map> _NEWLINE #include <iomanip> _NEWLINE //zlb// _NEWLINE  _NEWLINE using namespace std; _NEWLINE  _NEWLINE typedef long long _INDENT  _INDENT  LL; _NEWLINE typedef unsigned long long _INDENT  _INDENT  uLL; _NEWLINE typedef pair<LL,LL> pii; _NEWLINE  _NEWLINE double PI _INDENT = acos(-1); _NEWLINE double EPS = 1e-7; _NEWLINE LL INF _INDENT  _INDENT = 1000000000; _NEWLINE LL MOD _INDENT  _INDENT = 1000000007; _NEWLINE LL MAXINT = 2147483647; _NEWLINE LL INFLL _INDENT  = 1000000000000000000LL; _NEWLINE LL MAXLL _INDENT  = 9223372036854775807LL; _NEWLINE  _NEWLINE #define fi _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT first _NEWLINE #define se _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT second _NEWLINE #define mp _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT make_pair _NEWLINE #define pb _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT push_back _NEWLINE #define SIZE(a) _INDENT  _INDENT  _INDENT  (int)a.size() _NEWLINE #define MIN(a, b) _INDENT  _INDENT  (a) = min((a), (b)) _NEWLINE #define MAX(a, b) _INDENT  _INDENT  (a) = max((a), (b)) _NEWLINE #define input(in) _INDENT  _INDENT  freopen(in,"r",stdin) _NEWLINE #define output(out) _INDENT  freopen(out,"w",stdout) _NEWLINE #define RESET(a, b) _INDENT  memset(a,b,sizeof(a)) _NEWLINE #define FOR(a, b, c) _INDENT for (int (a)=(b); (a)<=(c); (a)++) _NEWLINE #define FORD(a, b, c) for (int (a)=(b); (a)>=(c); (a)--) _NEWLINE #define FORIT(a, b) _INDENT  for (__typeof((b).begin()) a=(b).begin(); a!=(b).end(); a++) _NEWLINE  _NEWLINE LL mx[8] = {-1,1,0,0,-1,-1,1,1}; _NEWLINE LL my[8] = {0,0,-1,1,-1,1,-1,1}; _NEWLINE  _NEWLINE // ------------ // _NEWLINE  _NEWLINE  #define getcx getchar _NEWLINE  _NEWLINE  inline void inp( int &n ) _INDENT _NEWLINE  { _NEWLINE  _INDENT  _INDENT n=0; _NEWLINE  _INDENT  _INDENT int ch=getcx();int sign=1; _NEWLINE  _INDENT  _INDENT while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();} _NEWLINE  _NEWLINE  _INDENT  _INDENT while( _INDENT ch >= '0' && ch <= '9' ) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT n = (n<<3)+(n<<1) + ch-'0', ch=getcx(); _NEWLINE  _INDENT  _INDENT n=n*sign; _NEWLINE  _INDENT } _INDENT  _INDENT _NEWLINE  _NEWLINE struct seg _NEWLINE { _NEWLINE 	int s,d,sum; _NEWLINE }; _NEWLINE  _NEWLINE int x[100005]; _NEWLINE int expp[3][100005]; _NEWLINE seg lol[3][400005]; _NEWLINE int n,q,R; _NEWLINE int p[3]; _NEWLINE  _NEWLINE inline int pwr(int id,int num,int ex) _NEWLINE { _NEWLINE 	if (ex == 0) return 1; _NEWLINE 	else if (ex%2==0) _NEWLINE 	{ _NEWLINE 		int tmp = pwr(id,num,ex/2); _NEWLINE 		return ((LL)tmp*tmp)%(LL)p[id]; _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		return ((LL)num*pwr(id,num,ex-1))%(LL)p[id]; _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE int tmp2[3]; _NEWLINE int tmp3[3]; _NEWLINE bool yoy[3]; _NEWLINE  _NEWLINE inline int val(int id,int k,int l,int r) _NEWLINE { _NEWLINE 	int n = (r-l+1); _NEWLINE 	if (!yoy[id]) _NEWLINE 	{ _NEWLINE 		LL s1 = n; _NEWLINE 		LL s2 = ((2*lol[id][k].s)+((LL)(n-1)*lol[id][k].d)); _NEWLINE 		if (s1&1) s2/=2; _NEWLINE 		else s1 /=2; _INDENT _NEWLINE 		return (((LL)s1*(s2%(LL)p[id]))+(LL)lol[id][k].sum)%(LL)p[id]; _NEWLINE 	} _NEWLINE 	else _NEWLINE 	{ _NEWLINE 		int s1 = (((((((LL)lol[id][k].s+(((LL)(n-1)*(LL)lol[id][k].d)%p[id]))*(LL)expp[id][n])%p[id])-(LL)lol[id][k].s))*(LL)tmp2[id])%p[id]-((((LL)lol[id][k].d*(LL)R)%p[id]*((LL)(expp[id][n-1]-1+p[id])))%p[id]*(LL)tmp3[id])%p[id]; _NEWLINE 		s1 %= p[id]; _NEWLINE 		if (s1 < 0) s1 += p[id]; _NEWLINE 		return ((LL)lol[id][k].sum+s1)%p[id]; _NEWLINE 	} _NEWLINE } _NEWLINE  _NEWLINE  _NEWLINE  _NEWLINE inline void build(int k=1,int l=1,int r=n) _NEWLINE { _NEWLINE 	lol[1][k].sum = lol[1][k].s = lol[1][k].d = 0; _NEWLINE 	lol[2][k].sum = lol[2][k].s = lol[2][k].d = 0; _NEWLINE 	if (l == r) _NEWLINE 	{ _NEWLINE 		lol[1][k].sum = x[l]%p[1]; _NEWLINE 		lol[2][k].sum = x[l]%p[2]; _NEWLINE 		return; _NEWLINE 	} _NEWLINE 	int m = (l+r)/2; _NEWLINE 	build(2*k,l,m); _NEWLINE 	build(2*k+1,m+1,r); _NEWLINE 	lol[1][k].sum = (val(1,2*k,l,m)+val(1,2*k+1,m+1,r))%p[1]; _NEWLINE 	lol[2][k].sum = (val(2,2*k,l,m)+val(2,2*k+1,m+1,r))%p[2]; _NEWLINE } _NEWLINE  _NEWLINE inline void pass(int id,int k,int l,int r) _NEWLINE { _NEWLINE 	int m = (l+r)/2; _NEWLINE 	lol[id][2*k].s = (lol[id][2*k].s+lol[id][k].s); _NEWLINE 	if (lol[id][2*k].s >= p[id]) lol[id][2*k].s -= p[id]; _NEWLINE 	lol[id][2*k].d = (lol[id][2*k].d+lol[id][k].d)%p[id]; _NEWLINE 	if (lol[id][2*k].d >= p[id]) lol[id][2*k].d -= p[id]; _NEWLINE  _NEWLINE 	int dif = m+1-l; _NEWLINE 	lol[id][2*k+1].s += ((LL)expp[id][dif]*(lol[id][k].s+(dif*(LL)lol[id][k].d)%p[id])%p[id])%p[id]; _NEWLINE 	lol[id][2*k+1].d += ((LL)expp[id][dif]*(LL)lol[id][k].d)%p[id]; _NEWLINE 	if (lol[id][2*k+1].s >= p[id]) lol[id][2*k+1].s -= p[id]; _NEWLINE 	if (lol[id][2*k+1].d >= p[id]) lol[id][2*k+1].d -= p[id]; _NEWLINE  _NEWLINE  _NEWLINE 	lol[id][k].s = lol[id][k].d = 0; _NEWLINE } _NEWLINE  _NEWLINE inline void update(int s,int d,int x,int y,int id,int k=1,int l=1,int r=n) _NEWLINE { _NEWLINE 	//cout << "UPDATE " << s << " " << d << " " << x << " " << y << " " << k << " " << l << " " << r << endl; _NEWLINE 	if (l > y || r < x) return; _NEWLINE 	if (x <= l && r <= y) _NEWLINE 	{ _NEWLINE 		lol[id][k].s = (lol[id][k].s+s); _NEWLINE 		if (lol[id][k].s >= p[id]) lol[id][k].s -= p[id]; _NEWLINE 		lol[id][k].d = (lol[id][k].d+d); _NEWLINE 		if (lol[id][k].d >= p[id]) lol[id][k].d -= p[id]; _NEWLINE 		return; _NEWLINE 	} _NEWLINE 	int m = (l+r)/2; _NEWLINE 	pass(id,k,l,r); _NEWLINE 	if (x <= m) _NEWLINE 	{ _NEWLINE 		update(s,d,x,min(y,m),id,2*k,l,m); _NEWLINE 	} _NEWLINE 	if (y >= m+1) _NEWLINE 	{ _NEWLINE 		if (x <= m) _INDENT _NEWLINE 		{ _NEWLINE 			int dif = m+1-x; _NEWLINE 			s = ((LL)expp[id][dif]*(s+(((LL)dif*d)%p[id])))%p[id]; _NEWLINE 			d = ((LL)expp[id][dif]*(LL)d)%p[id]; _NEWLINE 			update(s,d,max(m+1,x),y,id,2*k+1,m+1,r); _NEWLINE 		} _NEWLINE 		else update(s,d,max(m+1,x),y,id,2*k+1,m+1,r); _NEWLINE 	} _NEWLINE 	lol[id][k].sum = (val(id,2*k,l,m)+val(id,2*k+1,m+1,r))%p[id]; _NEWLINE } _NEWLINE  _NEWLINE inline int query(int x,int y,int id,int k=1,int l=1,int r=n) _NEWLINE { _NEWLINE 	if (l > y || r < x) return 0; _NEWLINE 	if (x <= l && r <= y) _NEWLINE 	{ _NEWLINE 		return val(id,k,l,r); _NEWLINE 	} _NEWLINE 	int m = (l+r)/2; _NEWLINE 	pass(id,k,l,r); _NEWLINE 	int res = (query(x,y,id,2*k,l,m)+query(x,y,id,2*k+1,m+1,r))%p[id]; _NEWLINE 	lol[id][k].sum = (val(id,2*k,l,m)+val(id,2*k+1,m+1,r))%p[id]; _NEWLINE 	return res; _NEWLINE } _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE 	int T; _NEWLINE 	scanf("%d",&T); _NEWLINE 	FOR(tc,1,T) _NEWLINE 	{ _NEWLINE 		//scanf("%d%d%d%d%d",&n,&q,&R,&p[1],&p[2]); _NEWLINE 		inp(n); _NEWLINE 		inp(q); _NEWLINE 		inp(R); _NEWLINE 		inp(p[1]); _NEWLINE 		inp(p[2]); _NEWLINE 		expp[1][0] = 1; _NEWLINE 		expp[2][0] = 1; _NEWLINE 		tmp2[1] = pwr(1,R-1,p[1]-2); _NEWLINE 		tmp2[2] = pwr(2,R-1,p[2]-2); _NEWLINE 		tmp3[2] = ((LL)tmp2[2]*tmp2[2])%p[2]; _NEWLINE 		tmp3[1] = ((LL)tmp2[1]*tmp2[1])%p[1]; _NEWLINE 		 _NEWLINE 		yoy[1] = (R-1)%p[1]; _NEWLINE 		yoy[2] = (R-1)%p[2]; _NEWLINE 		FOR(a,1,n) _NEWLINE 		{ _NEWLINE 			//scanf("%d",&x[a]); _NEWLINE 			inp(x[a]); _NEWLINE 			expp[1][a] = ((LL)expp[1][a-1]*R)%(LL)p[1]; _NEWLINE 			expp[2][a] = ((LL)expp[2][a-1]*R)%(LL)p[2]; _NEWLINE 		} _NEWLINE 		build(); _NEWLINE 		while(q--) _NEWLINE 		{ _NEWLINE 			int t,s,d,x,y,g; _NEWLINE 			inp(t); _NEWLINE 			//scanf("%d",&t); _NEWLINE 			if (t == 0) _NEWLINE 			{ _NEWLINE 				//scanf("%d %d %d %d",&s,&d,&x,&y); _NEWLINE 				inp(s); _NEWLINE 				inp(d); _NEWLINE 				inp(x); _NEWLINE 				inp(y); _NEWLINE 				update(s%p[1],d%p[1],x,y,1); _NEWLINE 				update(s%p[2],d%p[2],x,y,2); _NEWLINE 			} _NEWLINE 			else if (t == 1) _NEWLINE 			{ _NEWLINE 				//scanf("%d %d",&x,&g); _NEWLINE 				inp(x); _NEWLINE 				inp(g); _NEWLINE 				int t1 = query(x,x,1); _NEWLINE 				int t2 = query(x,x,2); _NEWLINE 				int tmp = pwr(2,t2,g); _NEWLINE 				update((p[1]-t1+tmp)%p[1],0,x,x,1); _NEWLINE 				update((p[2]-t2+tmp)%p[2],0,x,x,2); _NEWLINE 			} _NEWLINE 			else _NEWLINE 			{ _NEWLINE 				//scanf("%d %d",&x,&y); _NEWLINE 				inp(x); _NEWLINE 				inp(y); _NEWLINE 				printf("%d\n",(query(x,y,1)+p[1])%p[1]); _NEWLINE 			} _NEWLINE 		} _NEWLINE  _NEWLINE 	} _NEWLINE } _NEWLINE 
from fractions import gcd _NEWLINE for dfj in range(input()): _NEWLINE  _INDENT  _INDENT a,b,c,d = [int(i) for i in raw_input().split()] _NEWLINE  _INDENT  _INDENT g = gcd(c,d) _NEWLINE  _INDENT  _INDENT print(min((a-b)%g,(b-a)%g))
def get_opposite(point, dimention): _NEWLINE 	opposite_vertex = [i for i in point] _NEWLINE 	opposite_vertex[dimention] = -point[dimention] _NEWLINE 	return opposite_vertex _NEWLINE  _NEWLINE  _NEWLINE def print_vertex(start_point, dimention): _NEWLINE 	if dimention == 0: _NEWLINE 		opposite_vertex _INDENT = get_opposite(start_point, dimention) _NEWLINE 		print ' '.join([str(i) for i in start_point]) _NEWLINE 		print ' '.join([str(i) for i in opposite_vertex]) _NEWLINE 		return opposite_vertex _NEWLINE 	end_vertex = print_vertex(start_point, dimention-1) _NEWLINE 	opposite_vertex = get_opposite(end_vertex, dimention) _NEWLINE 	return print_vertex(opposite_vertex, dimention-1) _NEWLINE  _NEWLINE T = int(raw_input()) _NEWLINE for t in xrange(T): _NEWLINE 	input = raw_input().split(' ') _NEWLINE 	N, D = int(input[0]), int(input[1]) _NEWLINE 	l = [int(i) for i in raw_input().split(' ')] _NEWLINE 	if D < 4: _NEWLINE 		print -2 _NEWLINE 		continue _NEWLINE 	print_vertex(l, N-1) _NEWLINE 		 _NEWLINE 
/* _NEWLINE author:jxy _NEWLINE lang:C/C++ _NEWLINE university:China,Xidian University _NEWLINE **If you need to reprint,please indicate the source** _NEWLINE */ _NEWLINE #include <iostream> _NEWLINE #include <cstdio> _NEWLINE #include <cstdlib> _NEWLINE #include <cstring> _NEWLINE #define Maxn 314160 _NEWLINE using namespace std; _NEWLINE inline void inp( int &n )//fast input function _NEWLINE { _NEWLINE 	n=0; _NEWLINE 	int ch=getchar(),sign=1; _NEWLINE 	while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getchar();} _NEWLINE 	while( ch >= '0' && ch <= '9' ) _NEWLINE  		n=(n<<3)+(n<<1)+ ch-'0', ch=getchar(); _NEWLINE 	n=n*sign; _NEWLINE 	return; _NEWLINE } _NEWLINE char s[100]; _NEWLINE int k=0; _NEWLINE inline void out(int &a) _NEWLINE { _NEWLINE  _INDENT  _INDENT if(a==0){putchar('0');return;} _NEWLINE  _INDENT  _INDENT while(a) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s[k++]=a%10+'0',a/=10; _NEWLINE  _INDENT  _INDENT while(k) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT putchar(s[--k]); _NEWLINE  _INDENT  _INDENT return; _NEWLINE } _NEWLINE int R[Maxn];//房间客人 _NEWLINE int room[Maxn],start[Maxn]; _NEWLINE int n,m; _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int T,i; _NEWLINE  _INDENT  _INDENT scanf("%d",&T); _NEWLINE  _INDENT  _INDENT while(T--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT inp(n);inp(m); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT memset(R,0,n*sizeof(R[0])); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT int time,inc,now=0,ll=n-1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=m;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT inp(time); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT inp(inc); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start[i]=time; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(n!=now)//没住满，依次安排 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT room[i]=now-inc; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT R[now++]=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT else//已住满，赶走之前的人 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if(inc==n){room[i]=0;continue;}//没房间 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT room[i]=ll-inc; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start[R[ll]]=time-start[R[ll]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT R[ll]=i; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ++time; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=0;i<n;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT start[R[i]]=time-start[R[i]]; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for(i=1;i<=m;i++) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT out(room[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putchar(' '); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT out(start[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT putchar('\n'); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#!/usr/bin/python _NEWLINE ## Solve Every Sudoku Puzzle _NEWLINE  _NEWLINE ## See http://norvig.com/sudoku.html _NEWLINE ## modified by jc.unternet.net for CodeChef SudokuX competition _NEWLINE  _NEWLINE ## Throughout this program we have: _NEWLINE ## _INDENT  r is a row, _INDENT  _INDENT e.g. 'A' _NEWLINE ## _INDENT  c is a column, e.g. '3' _NEWLINE ## _INDENT  s is a square, e.g. 'A3' _NEWLINE ## _INDENT  d is a digit, _INDENT e.g. '9' _NEWLINE ## _INDENT  u is a unit, _INDENT  e.g. ['A1','B1','C1','D1','E1','F1','G1','H1','I1'] _NEWLINE ## _INDENT  g is a grid, _INDENT  e.g. 81 non-blank chars, e.g. starting with '.18...7... _NEWLINE ## _INDENT  values is a dict of possible values, e.g. {'A1':'123489', 'A2':'8', ...} _NEWLINE import sys _NEWLINE  _NEWLINE def cross(A, B): _NEWLINE  _INDENT  _INDENT return [a+b for a in A for b in B] _NEWLINE  _NEWLINE rows = 'ABCDEFGHI' _NEWLINE cols = '123456789' _NEWLINE digits _INDENT  = '123456789' _NEWLINE squares _INDENT = cross(rows, cols) _NEWLINE unitlist = ([cross(rows, c) for c in cols] + _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT [cross(r, cols) for r in rows] + _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')] + _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT [map(''.join, map(None, rows, cols))] + _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT [map(''.join, map(None, rows, cols[::-1]))] _NEWLINE ) _NEWLINE  _NEWLINE units = dict((s, [u for u in unitlist if s in u]) _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for s in squares) _NEWLINE peers = dict((s, set(s2 for u in units[s] for s2 in u if s2 != s)) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for s in squares) _NEWLINE  _NEWLINE def main(): _NEWLINE  input = map(str.strip, sys.stdin.readlines()) _NEWLINE  number = int(input.pop(0)) _NEWLINE  for i in range(number): _NEWLINE  _INDENT sudoku = parse_grid(''.join(input[i * 10:(i * 10) + 10])) _NEWLINE  _INDENT print codechef(search(sudoku)) _NEWLINE  _INDENT  _NEWLINE def search(values): _NEWLINE  _INDENT  _INDENT "Using depth-first search and propagation, try all possible values." _NEWLINE  _INDENT  _INDENT if values is False: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False ## Failed earlier _NEWLINE  _INDENT  _INDENT if all(len(values[s]) == 1 for s in squares): _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return values ## Solved! _NEWLINE  _INDENT  _INDENT ## Chose the unfilled square s with the fewest possibilities _NEWLINE  _INDENT  _INDENT _,s = min((len(values[s]), s) for s in squares if len(values[s]) > 1) _NEWLINE  _INDENT  _INDENT return some(search(assign(values.copy(), s, d)) _INDENT _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for d in values[s]) _NEWLINE  _NEWLINE def assign(values, s, d): _NEWLINE  _INDENT  _INDENT "Eliminate all the other values (except d) from values[s] and propagate." _NEWLINE  _INDENT  _INDENT if all(eliminate(values, s, d2) for d2 in values[s] if d2 != d): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return values _NEWLINE  _INDENT  _INDENT else: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _NEWLINE def eliminate(values, s, d): _NEWLINE  _INDENT  _INDENT "Eliminate d from values[s]; propagate when values or places <= 2." _NEWLINE  _INDENT  _INDENT if d not in values[s]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return values ## Already eliminated _NEWLINE  _INDENT  _INDENT values[s] = values[s].replace(d,'') _NEWLINE  _INDENT  _INDENT if len(values[s]) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return False ## Contradiction: removed last value _NEWLINE  _INDENT  _INDENT elif len(values[s]) == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT ## If there is only one value (d2) left in square, remove it from peers _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT d2, = values[s] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not all(eliminate(values, s2, d2) for s2 in peers[s]): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT ## Now check the places where d appears in the units of s _NEWLINE  _INDENT  _INDENT for u in units[s]: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT dplaces = [s for s in u if d in values[s]] _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if len(dplaces) == 0: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT elif len(dplaces) == 1: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT # d can only be in one place in unit; assign it there _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT if not assign(values, dplaces[0], d): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT return values _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _NEWLINE def parse_grid(grid): _NEWLINE  _INDENT  _INDENT "Given a string of 81 digits (or .0-), return a dict of {cell:values}" _NEWLINE  _INDENT  _INDENT grid = [c for c in grid if c in '0.-123456789'] _NEWLINE  _INDENT  _INDENT values = dict((s, digits) for s in squares) ## Each square can be any digit _NEWLINE  _INDENT  _INDENT for s,d in zip(squares, grid): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if d in digits and not assign(values, s, d): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT return False _NEWLINE  _INDENT  _INDENT return values _NEWLINE  _NEWLINE def solve_file(filename, sep='\n', action=lambda x: x): _NEWLINE  _INDENT  _INDENT "Parse a file into a sequence of 81-char descriptions and solve them." _NEWLINE  _INDENT  _INDENT results = [action(search(parse_grid(grid))) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  for grid in file(filename).read().strip().split(sep)] _NEWLINE  _INDENT  _INDENT print "## Got %d out of %d" % ( _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT sum((r is not False) for r in results), len(results)) _NEWLINE  _INDENT  _INDENT return results _NEWLINE  _NEWLINE def codechef(values): _NEWLINE  answers = [values[square] for square in squares] _NEWLINE  board = '' _NEWLINE  for row in range(0, len(answers), 9): _NEWLINE  _INDENT board += ''.join(answers[row:row+9]) + '\n' _NEWLINE  return board _NEWLINE  _NEWLINE def printboard(values): _NEWLINE  _INDENT  _INDENT "Used for debugging." _NEWLINE  _INDENT  _INDENT width = 1+max(len(values[s]) for s in squares) _NEWLINE  _INDENT  _INDENT line = '\n' + '+'.join(['-'*(width*3)]*3) _NEWLINE  _INDENT  _INDENT for r in rows: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT print ''.join(values[r+c].center(width)+(c in '36' and '|' or '') _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT for c in cols) + (r in 'CF' and line or '') _NEWLINE  _INDENT  _INDENT print _NEWLINE  _INDENT  _INDENT return values _NEWLINE  _NEWLINE def all(seq): _NEWLINE  _INDENT  _INDENT for e in seq: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if not e: return False _NEWLINE  _INDENT  _INDENT return True _NEWLINE  _NEWLINE def some(seq): _NEWLINE  _INDENT  _INDENT for e in seq: _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if e: return e _NEWLINE  _INDENT  _INDENT return False _NEWLINE  _NEWLINE main() _NEWLINE  _NEWLINE ## References used: _NEWLINE ## http://www.scanraid.com/BasicStrategies.htm _NEWLINE ## http://www.krazydad.com/blog/2005/09/29/an-index-of-sudoku-strategies/ _NEWLINE ## http://www2.warwick.ac.uk/fac/sci/moac/currentstudents/peter_cock/python/sudoku/ _NEWLINE 
def power(a,b,mod): _NEWLINE  _INDENT  _INDENT r=1 _NEWLINE  _INDENT  _INDENT if(a==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT return 0; _NEWLINE  _INDENT  _INDENT while (b>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (b%2==1): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  r =((r)*(a))%mod _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=b>>1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=((a)*(a))%mod _NEWLINE  _INDENT  _INDENT return r _NEWLINE t=(int)(raw_input().strip()) _NEWLINE p=[0 for i in range(200)]; _NEWLINE q=[0 for i in range(200)]; _NEWLINE l=[0 for i in range(200)]; _NEWLINE while(t>0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t=t-1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b=raw_input().strip() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a=b.split() _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v=int(a[0]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT n=int(a[1]) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # print v _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT # print n _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT p[0],p[1],a0, b0, c0, m0=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT q[0],q[1],a1, b1, c1, m1=map(int,raw_input().split()) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s=1 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT mod=1000000007 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT c=0 _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT for i in range(0, n): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(i>=2): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  p[i]=((((a0 * a0)) * p[i-1])+((b0 * p[i-2] ))+c0)%m0; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  q[i]=(((((a1 * a1)) * q[i-1]) + (b1 * q[i-2] ))+c1)%m1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  l[i]=((p[i]*m1)+q[i]); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  if(l[i]!=0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT s=(s*(l[i]%(mod-1)))%(mod-1); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT c=1; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if (c==0): _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT r=power(v%mod,s,mod) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print r _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else : _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT print '1' _NEWLINE 
#include <stdio.h> _NEWLINE #include <algorithm> _NEWLINE #include <vector> _NEWLINE #include <stack> _NEWLINE  _INDENT _NEWLINE /* given any string of left and right parens, after removing all matching left _NEWLINE  _INDENT  and right parens, what remains is a string consisting of some number of _INDENT _NEWLINE  _INDENT  left parans followed by some number of right parens */ _NEWLINE struct ReducedStr1 { _NEWLINE  _INDENT int left_count; _NEWLINE  _INDENT int right_count; _NEWLINE  _INDENT ReducedStr1(char paren = 0) : _INDENT _NEWLINE  _INDENT  _INDENT left_count((paren == '(') ? 1 : 0), _NEWLINE  _INDENT  _INDENT right_count((paren == ')') ? 1 : 0) _NEWLINE  _INDENT {} _INDENT _NEWLINE }; _NEWLINE  _INDENT _NEWLINE ReducedStr1 operator+(ReducedStr1 a, ReducedStr1 b) { _NEWLINE  _INDENT ReducedStr1 ret; _NEWLINE  _INDENT int cancelled = std::min(a.left_count, b.right_count); _NEWLINE  _INDENT ret.left_count = a.left_count + b.left_count - cancelled; _NEWLINE  _INDENT ret.right_count = a.right_count + b.right_count - cancelled; _NEWLINE  _INDENT return ret; _NEWLINE } _INDENT _NEWLINE  _INDENT _NEWLINE struct ReducedStr { _NEWLINE  _INDENT ReducedStr1 forward, reverse; _NEWLINE  _INDENT ReducedStr(char paren = 0) : forward(paren), reverse(paren) {} _NEWLINE }; _NEWLINE  _INDENT _NEWLINE ReducedStr operator+(ReducedStr a, ReducedStr b) { _NEWLINE  _INDENT ReducedStr ret; _NEWLINE  _INDENT ret.forward = a.forward + b.forward; _NEWLINE  _INDENT ret.reverse = b.reverse + a.reverse; _NEWLINE  _INDENT return ret; _NEWLINE } _NEWLINE  _INDENT _NEWLINE struct Node; _NEWLINE  _INDENT _NEWLINE struct AncestorInfo { _NEWLINE  _INDENT Node* n; _NEWLINE  _INDENT ReducedStr str; // path string to n (not including paren at n) _NEWLINE  _INDENT AncestorInfo(Node* n, ReducedStr str) : n(n), str(str) {} _NEWLINE }; _NEWLINE  _INDENT _NEWLINE struct Node { _NEWLINE  _INDENT char paren; _INDENT // ')' or '(' _NEWLINE  _INDENT std::vector<AncestorInfo> anc; // anc[i] is 2^i hops toward the root _NEWLINE  _INDENT std::vector<Node*> adj; // list of adjacent nodes _NEWLINE  _INDENT int level; _NEWLINE  _INDENT Node() : paren(0) {} _NEWLINE  _INDENT Node* find_ancestor_at_level(int level, ReducedStr& str) _NEWLINE  _INDENT { _NEWLINE  _INDENT  _INDENT if (this->level <= level) return this; _NEWLINE  _INDENT  _INDENT int i; _NEWLINE  _INDENT  _INDENT for (i=0;i<anc.size();i++) _NEWLINE  _INDENT  _INDENT  _INDENT if (anc[i].n->level <= level) break; _NEWLINE  _INDENT  _INDENT if (i != anc.size() && anc[i].n->level == level) { _NEWLINE  _INDENT  _INDENT  _INDENT str = str + anc[i].str; _NEWLINE  _INDENT  _INDENT  _INDENT return anc[i].n; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT str = str + anc[i-1].str; _NEWLINE  _INDENT  _INDENT return anc[i-1].n->find_ancestor_at_level(level, str); _NEWLINE  _INDENT } _NEWLINE }; _NEWLINE  _INDENT _NEWLINE Node* find_common_ancestor(Node* u, Node* v, ReducedStr& s, ReducedStr& t) _NEWLINE { _NEWLINE  _INDENT if (u == v) return u; _NEWLINE  _INDENT int i; _NEWLINE  _INDENT for (i=0;i<u->anc.size();i++) _NEWLINE  _INDENT  _INDENT if (u->anc[i].n == v->anc[i].n) break; _NEWLINE  _INDENT if (i==0) { _NEWLINE  _INDENT  _INDENT s = s + u->anc[0].str; _NEWLINE  _INDENT  _INDENT t = t + v->anc[0].str; _NEWLINE  _INDENT  _INDENT return u->anc[i].n; _NEWLINE  _INDENT } _NEWLINE  _INDENT s = s + u->anc[i-1].str; _NEWLINE  _INDENT t = t + v->anc[i-1].str; _NEWLINE  _INDENT return find_common_ancestor(u->anc[i-1].n, v->anc[i-1].n, s, t); _NEWLINE } _NEWLINE  _INDENT _NEWLINE int is_balanced(Node *u, Node* v) _NEWLINE { _NEWLINE  _INDENT ReducedStr s, t; _NEWLINE  _INDENT if (u->level > v->level) _NEWLINE  _INDENT  _INDENT u = u->find_ancestor_at_level(v->level, s); _NEWLINE  _INDENT else if (v->level > u->level) _NEWLINE  _INDENT  _INDENT v = v->find_ancestor_at_level(u->level, t); _NEWLINE  _INDENT _NEWLINE  _INDENT Node* w = find_common_ancestor(u,v,s,t); _NEWLINE  _INDENT _NEWLINE  _INDENT ReducedStr1 path = s.forward + w->paren + t.reverse; _NEWLINE  _INDENT return (!path.left_count && !path.right_count); _NEWLINE } _NEWLINE  _INDENT _NEWLINE void make_tree(Node* root) _NEWLINE { _NEWLINE  _INDENT std::stack<Node*> st; _NEWLINE  _INDENT st.push(root); _NEWLINE  _INDENT root->level = 0; _NEWLINE  _INDENT while (!st.empty()) { _NEWLINE  _INDENT  _INDENT Node* u = st.top(); _NEWLINE  _INDENT  _INDENT st.pop(); _NEWLINE  _INDENT  _INDENT for (int j=0;j<u->adj.size();j++) { _NEWLINE  _INDENT  _INDENT  _INDENT Node* v = u->adj[j]; _NEWLINE  _INDENT  _INDENT  _INDENT if (v == root || !v->anc.empty()) continue; _NEWLINE  _INDENT  _INDENT  _INDENT v->anc.push_back(AncestorInfo(u, ReducedStr(v->paren))); _NEWLINE  _INDENT  _INDENT  _INDENT Node* w = u; _NEWLINE  _INDENT  _INDENT  _INDENT for (int k=1;k <= w->anc.size();k++) { _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT Node* x = w->anc[k-1].n; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT v->anc.push_back( _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT  _INDENT AncestorInfo(x, v->anc[k-1].str + w->anc[k-1].str)); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT w = x; _NEWLINE  _INDENT  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT  _INDENT v->level = u->level + 1; _NEWLINE  _INDENT  _INDENT  _INDENT st.push(v); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _NEWLINE } _NEWLINE  _INDENT _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT int T; _NEWLINE  _INDENT _NEWLINE  _INDENT scanf("%d\n", &T); _NEWLINE  _INDENT for (int i=0;i<T;i++) { _NEWLINE  _INDENT  _INDENT int N, Q; _NEWLINE  _INDENT  _INDENT scanf("%d %d\n", &N, &Q); _NEWLINE  _INDENT  _INDENT std::vector<Node> tree(N); _NEWLINE  _INDENT  _INDENT for (int j=0;j<(N-1);j++) { _NEWLINE  _INDENT  _INDENT  _INDENT int u, v; _NEWLINE  _INDENT  _INDENT  _INDENT scanf("%d %d\n", &u, &v); _NEWLINE  _INDENT  _INDENT  _INDENT --u; --v; _NEWLINE  _INDENT  _INDENT  _INDENT tree[u].adj.push_back(&tree[v]); _NEWLINE  _INDENT  _INDENT  _INDENT tree[v].adj.push_back(&tree[u]); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT for (int j=0;j<N;j++) { _NEWLINE  _INDENT  _INDENT  _INDENT char c; _NEWLINE  _INDENT  _INDENT  _INDENT scanf(j == (N-1) ? "%c\n" : "%c ", &c); _NEWLINE  _INDENT  _INDENT  _INDENT tree[j].paren = c; _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT  _INDENT make_tree(&tree[0]); _NEWLINE  _INDENT  _INDENT for (int j=0;j<Q;j++) { _NEWLINE  _INDENT  _INDENT  _INDENT int u, v; _NEWLINE  _INDENT  _INDENT  _INDENT scanf("%d %d\n", &u, &v); _NEWLINE  _INDENT  _INDENT  _INDENT --u; --v; _NEWLINE  _INDENT  _INDENT  _INDENT printf("%s\n", is_balanced(&tree[u], &tree[v]) ? "Yes" : "No"); _NEWLINE  _INDENT  _INDENT } _NEWLINE  _INDENT } _INDENT _NEWLINE  _INDENT return 0; _NEWLINE } _NEWLINE  
#include <map> _NEWLINE #include <set> _NEWLINE #include <list> _NEWLINE #include <cmath> _NEWLINE #include <ctime> _NEWLINE #include <deque> _NEWLINE #include <queue> _NEWLINE #include <stack> _NEWLINE #include <string> _NEWLINE #include <bitset> _NEWLINE #include <cstdio> _NEWLINE #include <limits> _NEWLINE #include <vector> _NEWLINE #include <cstring> _NEWLINE #include <cstdlib> _NEWLINE #include <sstream> _NEWLINE #include <iostream> _NEWLINE #include <algorithm> _NEWLINE using namespace std; _NEWLINE  _NEWLINE #define MOD 1000000007 _NEWLINE #define ll long long _NEWLINE #define REP(i,a) for(i=0;i<a;i++) _NEWLINE #define FOR(i,a,b) for(i=a;i<b;i++) _NEWLINE #define VE vector<int> _NEWLINE #define SZ size() _NEWLINE #define PB push_back _NEWLINE  _NEWLINE //inline ll NFIBO(ll a){ll phi=(1+sqrt(5))/2; ll x=floor(pow(phi,a)/sqrt(5)+1/2); return x;} _NEWLINE //inline void FFIBO(unsigned ll n,unsigned ll ans[]){unsigned ll a,b,c,d;if(n == 0){ans[0] = 0;ans[1] = 1;return;}FFIBO((n/2),ans);a = ans[0];b = ans[1];c = 2*b - a;if(c < 0)c += MOD;c = (a * c) % MOD;d = (a*a + b*b) % MOD;if(n%2 == 0){ans[0] = c;ans[1] = d;}else{ans[0] = d;ans[1] = c+d;}} _NEWLINE  _NEWLINE  _NEWLINE int main() _NEWLINE { _NEWLINE  _INDENT  _INDENT int t; _NEWLINE  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT cin.ignore(254,'\n'); _NEWLINE  _INDENT  _INDENT while(t--) _NEWLINE  _INDENT  _INDENT { _NEWLINE  _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT string s,t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT const char *a,*b; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>s; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cin>>t; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT s.assign(s.begin(), unique(s.begin(),s.end())); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT t.assign(t.begin(), unique(t.begin(), t.end())); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT a = s.c_str(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT b = t.c_str(); _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT if(strcmp(a,b)==0) _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"Yes\n"; _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT else _NEWLINE  _INDENT  _INDENT  _INDENT  _INDENT cout<<"No\n"; _NEWLINE  _NEWLINE  _INDENT  _INDENT } _NEWLINE } _NEWLINE 
#include <bits/stdc++.h> _NEWLINE #define forn(i, a, n) for (int i = a; i < n; ++i) _NEWLINE #define forr(i, a, n) for (int i = (n) - 1; i >= a; --i) _NEWLINE #define pb push_back _NEWLINE #define pf push_front _NEWLINE #define lag long long _NEWLINE  _NEWLINE using namespace std; _NEWLINE const int M = 1e9 + 7; _NEWLINE const int N = 1e5 + 7; _NEWLINE  _NEWLINE int t, n, p[N], e[N], pr[N], size; _NEWLINE bool is[N]; _NEWLINE lag fact[N] = {1}; _NEWLINE lag mp(lag b, lag e, lag m) { _NEWLINE 	lag a = 1; _NEWLINE 	b %= m; _NEWLINE 	while (e) { _NEWLINE 		if (e & 1) a = a * b % m; _NEWLINE 		e >>= 1; _NEWLINE 		b = b * b % m; _NEWLINE 	} _NEWLINE 	return a; _NEWLINE } _NEWLINE lag inv(lag x) { _NEWLINE 	return mp(x, M - 2, M); _NEWLINE } _NEWLINE lag choose(int n, int k) { _NEWLINE 	return fact[n] * inv(fact[k]) % M * inv(fact[n-k]) % M; _NEWLINE } _NEWLINE int get(int n, int p) { _NEWLINE 	int k = 0; _NEWLINE 	while (n / p > 0) { _NEWLINE 		k += n / p; _NEWLINE 		n /= p; _NEWLINE 	} _NEWLINE 	return k; _NEWLINE } _NEWLINE lag choosem(int n, int k) { _NEWLINE 	// modulo (M - 1) _NEWLINE 	lag a = 1; _NEWLINE 	forn (i, 0, size) { _NEWLINE 		if (pr[i] > n) _NEWLINE 			break; _NEWLINE 		int e = get(n, pr[i]) - get(k, pr[i]) - get(n - k, pr[i]); _NEWLINE 		a = a * mp(pr[i], e, M-1) % (M-1); _NEWLINE 	} _NEWLINE 	return a; _NEWLINE } _NEWLINE int main() { _NEWLINE 	forn (i, 1, N) _NEWLINE 		fact[i] = fact[i-1] * i % M; _NEWLINE 	forn (i, 2, N) _NEWLINE 		is[i] = true; _NEWLINE 	for (int i = 2; i*i < N; ++i) _NEWLINE 		if (is[i]) _NEWLINE 			for (int j = i*i; j < N; j += i) _NEWLINE 				is[j] = false; _NEWLINE 	forn (i, 2, N) _NEWLINE 		if (is[i]) _NEWLINE 			pr[size++] = i; _NEWLINE 	scanf("%d", &t); _NEWLINE 	while (t--) { _NEWLINE 		scanf("%d", &n); _NEWLINE 		lag P = 1; _NEWLINE 		forn (i, 0, n) { _NEWLINE 			scanf("%d%d", p+i, e+i); _NEWLINE 			P = P * e[i] % M; _NEWLINE 		} _NEWLINE 		if (n == 1) { _NEWLINE 			printf("1 %lld\n", (P + 1) % M); _NEWLINE 			continue; _NEWLINE 		} _NEWLINE 		lag antichains = choose(n, n / 2); _NEWLINE 		lag same; _NEWLINE 		if (n & 1) { _NEWLINE 			same = mp(P, choosem(n - 1, n/2 - 1), M) + mp(P, choosem(n - 1, (n + 1) / 2 - 1), M); _NEWLINE 		} else { _NEWLINE 			same = mp(P, choosem(n - 1, n/2 - 1), M); _NEWLINE 		} _NEWLINE 		printf("%lld %lld\n", (antichains%M+M)%M, (same%M+M)%M); _NEWLINE 	} _NEWLINE }
