#!/usr/bin/env python
# -*- coding: utf-8 -*-

def matrix ():
    ## 入力
    # 標準入力を取得
    a = raw_input()
    s = raw_input()
    # 入力を処理に合った形に変換
    rect_sum    = int(a)          # 矩形領域内の合計値
    numbers     = map(int,s)      # 数値列
    len_numbers = len(s)          # 数値列の長さ

    ## 一辺の合計値リストを作成
    # 合計値をインデックスとしたテーブルを作成．中身は出現回数．
    edge_sums = [0] * 36001

    # 端から端までの累積和とその出現回数を算出
    partial_sums = []
    psum = 0
    for num in numbers:
        psum += num
        edge_sums[psum] += 1
        partial_sums.append(psum)
    max_edge_sums = psum
    # 残りの各合計値は，端から端までの累積和を基にして，
    # 端から順に値を引いていくことで算出．
    # *************************************************
    # *** ここが遅い！0.7秒くらいかかってる         ***
    # *** どうやら edge_sums[] の中身を参照するのに ***
    # *** 0.5秒くらいかかってるもよう               ***
    # *************************************************
    for index, left in enumerate(partial_sums):
        for right in partial_sums[index+1:]:
            edge_sums[right - left] += 1

    ## 一辺の相方となる，もう一辺の合計値の数を足していく
    if rect_sum != 0:
        # a が 0 でない場合，矩形の合計値は両辺の合計値の積となる
        # もう一辺の合計値を算出しつつ，出現回数を順に足していく
        answer = 0
        for index, value in enumerate(edge_sums[1:], 1):
            if rect_sum % index != 0:
                continue
            another_edge_sum = rect_sum / index
            if (another_edge_sum > max_edge_sums):
                continue
            answer += edge_sums[another_edge_sum] * value
    else:
        # a が0の場合，一方が0であればよいので，
        # 全パターンから，両方が0でないパターンの総数を引けばよい
        # *********************************************************************
        # *** 何故か、num_nonzero = num_all - edge_sums[0] にすると遅くなる ***
        # *********************************************************************
        num_all = sum(edge_sums)
        num_nonzero = sum(edge_sums[1:])
        answer = (num_all ** 2) - (num_nonzero ** 2)
    print answer
    return

if __name__ == '__main__':
    matrix()
