#include <iostream>
#include <algorithm>
#include <cmath>
#include <vector>
using namespace std;

#define double long double
#define LL long long

const LL MOD = 1e9 + 7;
const LL K = sqrt(MOD);
const double PI = acos(-1);
const int N = 30005;

LL p2[N], fac[N], inv[N];

struct complex{
	double re, im;
	complex(){}
	complex(double _re, double _im) : re(_re), im(_im){}
	complex operator + (const complex &a) const{ return complex(re + a.re, im + a.im); }
	complex operator - (const complex &a) const{ return complex(re - a.re, im - a.im); }
	complex operator * (const complex &a) const{ return complex(re * a.re - im * a.im, re * a.im + im * a.re); }
	complex operator / (const double &a) const{ return complex(re / a, im / a); }
	complex operator * (const double &a) const{ return complex(re * a, im * a); }
};

void fft(vector <complex> &a, bool invert){
	int n = (int) a.size();
	for(int i = 1, j = 0; i < n; i++){
		int bit = n >> 1;
		for(; j >= bit; bit >>= 1) j -= bit;
		j += bit;
		if(i < j) swap(a[i], a[j]);
	}
	for(int len = 2; len <= n; len <<= 1){
		double ang = 2.0 * PI / len * (invert ? -1 : 1);
		complex wlen (cos(ang), sin(ang));
		for(int i = 0; i < n; i += len){
			complex w (1, 0);
			for(int j = 0; j < len / 2; j++){
				complex u = a[i + j], v = a[i + j + len / 2] * w;
				a[i + j] = u + v;
				a[i + j + len / 2] = u - v;
				w = w * wlen;
			}
		}
	}
	if(invert) for(int i = 0; i < n; i++) a[i] = a[i] / n;
}

void multiply_fft(const vector <LL> &a, const vector <LL> &b, vector <LL> &res){
	size_t n = 1;
	while(n < max(a.size(), b.size())) n <<= 1;
	n <<= 1;
	vector <complex> fa(n), fb(n);
	for(size_t i = 0; i < n; i++) fa[i].re = fa[i].im = fb[i].re = fb[i].im = 0;
	for(size_t i = 0; i < a.size(); i++) fa[i].re = a[i], fa[i].im = 0;
	for(size_t i = 0; i < b.size(); i++) fb[i].re = b[i], fb[i].im = 0;
	fft(fa, false); fft(fb, false);
	for(size_t i = 0; i < n; i++) fa[i] = fa[i] * fb[i];
	fft(fa, true);
	res.resize(n);
	for(size_t i = 0; i < n; i++) res[i] = (LL) (fa[i].re +0.5), res[i] %= MOD;
//	cout << "############ " << res.size() << " ######\n";
}

void multiply(const vector<LL> &a, const vector<LL> &b, vector<LL> &res){
	int n = a.size();
	vector<LL> a1(n), a2(n), b1(n), b2(n), r1, r2, r3, r4;
	for(int i = 0; i < n; i++){
		a1[i] = a[i] % K;
		a2[i] = a[i] / K;
		b1[i] = b[i] % K;
		b2[i] = b[i] / K;
	}
	multiply_fft(a1, b1, res);
	multiply_fft(a1, b2, r2);
	multiply_fft(a2, b1, r3);
	multiply_fft(a2, b2, r4);
	res.resize(n);
	for(int i = 0; i < n; i++){
		res[i] += (r2[i] + r3[i]) * K % MOD;
		res[i] += r4[i] * (K * K % MOD) % MOD;
		res[i] %= MOD;
	}
}

LL power(LL a, LL n){
	return n == 0 ? 1 : (power(a * a % MOD, n / 2) * (n & 1 ? a : 1) % MOD);
}

LL dp[N];
vector<LL> normal;

void build(int n, int k){
	if(n == 1){
		for(int i = 0; i < N; i++) dp[i] = inv[i];
		dp[0] = 0;
	}else if(n & 1){
		build(n - 1, k);
		vector<LL> dp1;
		for(int i = 0; i <= k; i++) dp1.push_back(dp[i] * p2[i] % MOD);
		multiply(dp1, normal, dp1);
		for(int i = 0; i <= k; i++) dp[i] = dp1[i];
	}else{
		build(n / 2, k);
		vector<LL> dp1, dp2;
		for(int i = 0; i <= k; i++) dp1.push_back(dp[i] * power(p2[n / 2], i) % MOD), dp2.push_back(dp[i]);
		multiply(dp1, dp2, dp1);
		for(int i = 0; i <= k; i++) dp[i] = dp1[i];
	}
//	cout << "when build " << n << ": ";
//	for(int i = 0; i <= k; i++) cout << dp[i] * fac[i] % MOD << " "; cout << endl;
}

int main(){
	p2[0] = inv[0] = fac[0] = 1;
	for(int i = 1; i < N; i++) fac[i] = fac[i - 1] * i % MOD, inv[i] = power(fac[i], MOD - 2), p2[i] = p2[i - 1] * 2LL % MOD;
	int n, c, k;
	cin >> n >> k;
	if(n > k){
		cout << 0 << endl;
		return 0;
	}
	for(int i = 0; i <= k; i++) normal.push_back(inv[i]);
	normal[0] = 0;
	/*
	vector<LL> a, b;
	while(n--){
		cin >> c;
		a.push_back(c);
	}
	while(k--){
		cin >> c;
		b.push_back(c);
	}
	multiply(a, b, a);
	for(int i = 0; i < a.size(); i++) cout << a[i] << " "; cout << endl;
	*/
	build(n, k);
	LL ans = 0;
	for(int i = n; i <= k; i++) ans = (ans + dp[i] * (fac[k] * inv[k - i] % MOD) % MOD) % MOD;
	cout << ans % MOD << endl;
	return 0;
}