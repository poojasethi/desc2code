#include <bits/stdtr1c++.h>

#define MAX 65536
#define clr(ar) memset(ar, 0, sizeof(ar))
#define read() freopen("lol.txt", "r", stdin)
#define dbg(x) cout << #x << " = " << x << endl

using namespace std;

namespace fft{
    struct complx{
        long double real, img;

        inline complx(){
            real = img = 0.0;
        }

        inline complx(long double x){
            real = x, img = 0.0;
        }

        inline complx(long double x, long double y){
            real = x, img = y;
        }

        inline void operator += (complx &other){
            real += other.real, img += other.img;
        }

        inline void operator -= (complx &other){
            real -= other.real, img -= other.img;
        }

        inline complx operator + (complx &other){
            return complx(real + other.real, img + other.img);
        }

        inline complx operator - (complx &other){
            return complx(real - other.real, img - other.img);
        }

        inline complx operator * (complx& other){
            return complx((real * other.real) - (img * other.img), (real * other.img) + (img * other.real));
        }
    };

    complx P[MAX >> 1], P1[MAX], P2[MAX];

    void FFT(complx *ar, int n, int inv){
        int i, j, k, len, len2;
        const long double p = 4.0 * inv * acos(0.0);

        for (i = 1, j = 0; i < n; i++){
            for (k = n >> 1; j >= k; k >>= 1) j -= k;
            j += k;
            if (i < j) swap(ar[i], ar[j]);
        }

        for (len = 2; len <= n; len <<= 1){
            len2 = len >> 1;
            long double theta = p / len;
            complx mul(cos(theta), sin(theta));
            for (i = 1, P[0] = complx(1, 0); i < len2; i++) P[i] = (P[i - 1] * mul);

            for (i = 0; i < n; i += len){
                complx t, *x = ar + i, *y = ar + i + len2, *l = ar + i + len2, *z = P;
                for (; x != l; x++, y++, z++){
                    t = (*y) * (*z), *y = *x - t;
                    *x += t;
                }
            }
        }

        if (inv == -1){
            long double tmp = 1.0 / n;
            for (i = 0; i < n; i++) ar[i].real *= tmp;
        }
    }

    void cmplx_conv(int n, complx* A, complx* B){
        int m = 1 << (32 - __builtin_clz(n) - (__builtin_popcount(n) == 1));
        for (int i = n; i < m; i++) A[i] = B[i] = complx(0);
        FFT(A, m, 1), FFT(B, m, 1);
        for (int i = 0; i < m; i++) A[i] = A[i] * B[i];
        FFT(A, m, -1);
    }

    int cmplx_mul(int a, complx* A, int b, complx* B){
        int n = a + b - 1;
        int m = 1 << (32 - __builtin_clz(n) - (__builtin_popcount(n) == 1));
        for (int i = a; i < m; i++) A[i] = complx(0);
        for (int i = b; i < m; i++) B[i] = complx(0);
        FFT(A, m, 1), FFT(B, m, 1);
        for (int i = 0; i < m; i++) A[i] = A[i] * B[i];
        FFT(A, m, -1);
        return m;
    }

    int mul(int a, int* A, int b, int* B){
        for (int i = 0; i < a; i++) P1[i] = complx(A[i], 0.0);
        for (int i = 0; i < b; i++) P2[i] = complx(B[i], 0.0);
        int len = cmplx_mul(a, P1, b, P2);
        for (int i = 0; i < len; i++) A[i] = floor(P1[i].real + 0.5);
        return len;
    }

    void conv(int n, int* A, int* B){
        for (int i = 0; i < n; i++) P1[i] = complx(A[i], 0.0), P2[i] = complx(B[i], 0.0);
        cmplx_conv(n, P1, P2);
        for (int i = 0; i < n; i++) A[i] = floor(P1[i].real + 0.5);
    }

    int llmul(int a, long long* A, int b, long long* B){
        for (int i = 0; i < a; i++) P1[i] = complx(A[i], 0.0);
        for (int i = 0; i < b; i++) P2[i] = complx(B[i], 0.0);
        int len = cmplx_mul(a, P1, b, P2);
        for (int i = 0; i < len; i++) A[i] = floor(P1[i].real + 0.5);
        return len;
    }

    int mul(int a, int* A, int b, int* B, int mod){
        long long ar[6][MAX];
        int i, s = sqrt(0.9 + mod);

        for (i = 0; i < a; i++){
            ar[0][i] = ar[5][i] = A[i] % s;
            ar[1][i] = ar[4][i] = A[i] / s;
        }
        for (i = 0; i < b; i++) ar[2][i] = B[i] % s, ar[3][i] = B[i] / s;

        llmul(a, ar[5], b, ar[2]), llmul(a, ar[0], b, ar[3]);
        llmul(a, ar[4], b, ar[2]), llmul(a, ar[1], b, ar[3]);

        for (i = 0; i < (a + b - 1); i++){
            A[i] = ( ((ar[0][i] + ar[4][i]) * s) + ar[5][i] + (ar[1][i] * s % mod * s)) % mod;
        }
        return (a + b - 1);
    }

    int fastmul(int a, int* A, int b, int* B, int mod){
        complx ar[4][MAX];
        int i, m, n = a + b - 1, s = sqrt(0.9 + mod);
        m = 1 << (32 - __builtin_clz(n) - (__builtin_popcount(n) == 1));
        for (i = 0; i < a; i++) ar[0][i] = complx(A[i] % s, 0), ar[1][i] = complx(A[i] / s, 0);
        for (i = 0; i < b; i++) ar[2][i] = complx(B[i] % s, 0), ar[3][i] = complx(B[i] / s, 0);
        for (i = a; i < m; i++) ar[0][i] = ar[1][i] = complx(0);
        for (i = b; i < m; i++) ar[2][i] = ar[3][i] = complx(0);

        for (i = 0; i < 4; i++) FFT(ar[i], m, 1);
        for (i = 0; i < m; i++){
            P1[i] = ar[0][i] * ar[2][i], P2[i] = ar[1][i] * ar[2][i];
            ar[0][i] = ar[0][i] * ar[3][i], ar[1][i] = ar[1][i] * ar[3][i];
        }
        FFT(ar[0], m, -1), FFT(ar[1], m, -1), FFT(P2, m, -1), FFT(P1, m, -1);

        for (i = 0; i < (a + b - 1); i++){
            long long x = floor(ar[0][i].real + 0.5), y = floor(P2[i].real + 0.5);
            long long z = floor(P1[i].real + 0.5), w = floor(ar[1][i].real + 0.5);
            A[i] = ( ((x + y) * s) + z + (w * s % mod * s)) % mod;
        }
        return (a + b - 1);
    }
}

const int MOD = 1000000007;
int fact[MAX], inv[MAX], A[MAX], B[MAX];

int expo(int a, int b){
    int res = 1;

    while (b){
        if (b & 1) res = (long long)res * a % MOD;
        a = (long long)a * a % MOD;
        b >>= 1;
    }
    return res;
}

int binomial(int n, int k){
    if (k > n) return 0;
    int x = ((long long)inv[k] * inv[n - k]) % MOD;
    return ((long long)x * fact[n]) % MOD;
}

vector <int> solve(int n, int k){
    int i, j, l, r;
    vector <int> a, b, v;

    v.resize(k + 1, 0);
    if (n == 1){
        for (i = 1; i <= k; i++) v[i] = 1;
        return v;
    }

    l = n >> 1, r = n - l;
    if (n & 1) l = n - 1, r = 1;

    a = b = solve(l, k);
    if (l != r) b = solve(r, k);
    for (j = 0; j <= k; j++) a[j] = ((long long)a[j] * inv[j]) % MOD;
    for (j = 0; j <= k; j++) a[j] = ((long long)a[j] * expo(2, j * r)) % MOD;
    for (j = 0; j <= k; j++) b[j] = ((long long)b[j] * inv[j]) % MOD;

    for (i = 0; i <= k; i++) A[i] = a[i], B[i] = b[i];
    fft::mul(k + 1, A, k + 1, B, MOD);
    for (i = 0; i <= k; i++) v[i] = ((long long)A[i] * fact[i]) % MOD;
    return v;
}

int main(){
    int i, j, k;
    long long n, x, y, res;

    for (fact[0] = 1, i = 1; i < MAX; i++) fact[i] = ((long long)i * fact[i - 1]) % MOD;
    inv[MAX - 1] = expo(fact[MAX - 1], MOD - 2);
    for (i = MAX - 2; i >= 0; i--) inv[i] = ((long long)inv[i + 1] * (i + 1)) % MOD;

    while (scanf("%lld %d", &n, &k) != EOF){
        if (n > k) res = 0;
        else{
            res = 0;
            vector <int> v = solve(n, k);
            for (i = 0; i <= k; i++) res = (res + ((long long)v[i] * binomial(k, i))) % MOD;
        }
        printf("%lld\n", res % MOD);
    }
    return 0;
}
