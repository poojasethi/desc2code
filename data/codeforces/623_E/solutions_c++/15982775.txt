#include <iostream>
#include <algorithm>
#include <cmath>
#include <vector>
using namespace std;

#define double long double
#define LL long long

const LL MOD = 1e9 + 7;
const LL K = sqrt(MOD);
const double PI = acos(-1);
const int N = 30005;


struct complex{
	double re, im;
	complex(){}
	complex(double _re, double _im) : re(_re), im(_im){}
	complex operator + (const complex &a) const{ return complex(re + a.re, im + a.im); }
	complex operator - (const complex &a) const{ return complex(re - a.re, im - a.im); }
	complex operator * (const complex &a) const{ return complex(re * a.re - im * a.im, re * a.im + im * a.re); }
	complex operator / (const double &a) const{ return complex(re / a, im / a); }
	complex operator * (const double &a) const{ return complex(re * a, im * a); }
};

void fft(vector <complex> &a, bool invert){
	int n = (int) a.size();
	for(int i = 1, j = 0; i < n; i++){
		int bit = n >> 1;
		for(; j >= bit; bit >>= 1) j -= bit;
		j += bit;
		if(i < j) swap(a[i], a[j]);
	}
	for(int len = 2; len <= n; len <<= 1){
		double ang = 2.0 * PI / len * (invert ? -1 : 1);
		complex wlen (cos(ang), sin(ang));
		for(int i = 0; i < n; i += len){
			complex w (1, 0);
			for(int j = 0; j < len / 2; j++){
				complex u = a[i + j], v = a[i + j + len / 2] * w;
				a[i + j] = u + v;
				a[i + j + len / 2] = u - v;
				w = w * wlen;
			}
		}
	}
	if(invert) for(int i = 0; i < n; i++) a[i] = a[i] / n;
}

void multiply_fft(const vector <LL> &a, const vector <LL> &b, vector <LL> &res){
	size_t n = 1;
	while(n < max(a.size(), b.size())) n <<= 1;
	n <<= 1;
	vector <complex> fa(n), fb(n);
	for(size_t i = 0; i < n; i++) fa[i].re = fa[i].im = fb[i].re = fb[i].im = 0;
	for(size_t i = 0; i < a.size(); i++) fa[i].re = a[i], fa[i].im = 0;
	for(size_t i = 0; i < b.size(); i++) fb[i].re = b[i], fb[i].im = 0;
	fft(fa, false); fft(fb, false);
	for(size_t i = 0; i < n; i++) fa[i] = fa[i] * fb[i];
	fft(fa, true);
	res.resize(n);
	for(size_t i = 0; i < n; i++) res[i] = (LL) (fa[i].re +0.5), res[i] %= MOD;
}

void multiply(const vector <LL> &a, const vector <LL> &b, vector <LL> &res){
	int n = a.size();
	vector <LL> a1(n), a2(n), b1(n), b2(n), r2, r3, r4;
	for(int i = 0; i < n; i++){
		a1[i] = a[i] % K;
		a2[i] = a[i] / K;
		b1[i] = b[i] % K;
		b2[i] = b[i] / K;
	}
	multiply_fft(a1, b1, res);
	multiply_fft(a1, b2, r2);
	multiply_fft(a2, b1, r3);
	multiply_fft(a2, b2, r4);
	res.resize(n);
	for(int i = 0; i < n; i++){
		res[i] += (r2[i] + r3[i]) * K % MOD;
		res[i] += r4[i] * (K * K % MOD) % MOD;
		res[i] %= MOD;
	}
}

LL power(LL a, LL n){
	return n == 0 ? 1 : (power(a * a % MOD, n / 2) * (n & 1 ? a : 1) % MOD);
}

vector <LL> normal, dp;
LL inv[N];

void build(int n, int k){
	if(n == 1){
		dp.resize(k + 1);
		dp[0] = 0;
		for(int i = 1; i <= k; i++) dp[i] = inv[i];
	}else if(n & 1){
		build(n - 1, k);
		LL pwr = 1, base = 2;
		for(int i = 0; i <= k; i++){
			dp[i] = dp[i] * pwr % MOD;
			pwr = pwr * base % MOD;
		}
		multiply(dp, normal, dp);
		dp.resize(k + 1);
	}else{
		build(n / 2, k);
		vector <LL> dp2 (k + 1);
		LL pwr = 1, base = power(2, n / 2);
		for(int i = 0; i <= k; i++){
			dp2[i] = dp[i];
			dp[i] = dp[i] * pwr % MOD;
			pwr = pwr * base % MOD;
		}
		multiply(dp, dp2, dp);
		dp.resize(k + 1);
	}
}

int main(){
	ios_base :: sync_with_stdio(0);
	cin.tie(0);
	int n, c, k;
	cin >> n >> k;
	if(n > k){
		cout << 0 << endl;
		return 0;
	}
	inv[0] = 1;
	for(int i = 1; i <= k; i++){
		inv[i] = inv[i - 1] * power(i, MOD - 2) % MOD;
	}
	normal.resize(k + 1);
	normal[0] = 0;
	for(int i = 1; i <= k; i++) normal[i] = inv[i];
	build(n, k);
	LL ans = 0, fac = 1;
	for(int i = 2; i <= k; i++) fac = fac * i % MOD;
	for(int i = n; i <= k; i++) ans = (ans + dp[i] * inv[k - i]) % MOD;
	cout << ans * fac % MOD << endl;
	return 0;
}