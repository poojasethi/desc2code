#include <cmath>
#include <cctype>
#include <cstdio>
#include <climits>
#include <cstring>

#include <map>
#include <set>
#include <list>
#include <queue>
#include <stack>
#include <deque>
#include <vector>
#include <bitset>
#include <string>
#include <sstream>
#include <iomanip>
#include <iostream>
#include <algorithm>

#define  D(x)             cout << #x " = " << (x) << endl;
#define  foreach(it, c)   for(typeof((c).begin()) it = (c).begin(); it!=(c).end(); ++it)
#define  foreachr(it, c)  for(typeof((c).rbegin()) it = (c).rbegin(); it!=(c).rend(); ++it)
#define  EPS              1e-9
#define  PI               acos(-1)

typedef unsigned long long int ull;
typedef long long int ll;
typedef std::stringstream ss;

inline int cmp(double x, double y=0, double tol=EPS) {
    return (x <= y + tol) ? (x + tol < y) ? -1 : 0 : 1;
}

#define PRECISION   1000000ll

ll solve(std::string seq) {
    ll right = 0, steps = 0;

    bool flag = true;
    ll right_rollback = 0, steps_rollback = 0;

    for(int i = 0; i < seq.size(); ++i, ++steps, ++steps_rollback)
        if( seq[i] != 'X' ) {
            ++right;
            if( seq[i] != (steps&1? 'R': 'L') )
                ++steps;

            if( seq[i] == (steps_rollback&1? 'R': 'L') ) {
                ++right_rollback;
                flag = true;
            }
            else {
                flag = !flag;
                if( flag )
                    --steps_rollback;
                else {
                    ++right_rollback;
                    ++steps_rollback;
                }
            }
        }

    steps += steps % 2;
    if( steps_rollback % 2 ) {
        if( flag )
            ++steps_rollback;
        else {
            --steps_rollback;
            --right_rollback;
        }
    }

    ll ans = 100ll * PRECISION * right_rollback / steps_rollback;
    return std::max(100ll * PRECISION * right / steps, ans);
}

int main() {
    //freopen("input.txt", "r", stdin);

    char c;
    int n = 0;
    std::string seq;
    while( std::cin >> c ) {
        if( c != 'X' && n && c == seq[n-1] ) {
            seq += 'X';
            ++n;
        }
        seq += c;
        ++n;
    }

    ll ans = solve(seq);
    if( seq[0] == seq[n-1] && seq[0] != 'X' )
        ans = std::max(solve(seq + 'X'), solve('X' + seq));

    printf("%I64d.%06I64d\n", ans / PRECISION, ans % PRECISION);

    //while(1);
    return 0;
}
