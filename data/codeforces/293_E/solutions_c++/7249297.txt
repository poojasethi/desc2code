#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define ull unsigned long long
#define pii pair<int, int>
#define pb push_back
#define mp make_pair
#define VAL(x) #x << " = " << (x) << "   "
#define SQR(a) ((a) * (a))
#define SZ(x) ((int) (x).size())
#define ALL(x) (x).begin(), (x).end()
#define CLR(x, a) memset(x, a, sizeof x)
#define FOREACH(i, x) for(__typeof((x).begin()) i = (x).begin(); i != (x).end(); i ++)
#define FOR(i, n) for (int i = 0; i < (n); i ++)
#define X first
#define Y second

const int MAXN = 100 * 1000 + 10;

ll L, W;

int fen[MAXN];

void add(int x, int val) {
	for (int i = x + 1; i < MAXN; i += i & (-i)) 
		fen[i] += val;
}

int get(int x) {
	int ans = 0;
	for (int i = x; i > 0; i -= i & (-i)) ans += fen[i];
	return ans;
}

ll calc(vector<pii> d) {
	sort(ALL(d));
	for (int i = 0; i < SZ(d); i ++)
		add(d[i].Y,  1);

	ll ans = 0;
	for (int i = 0, j = SZ(d) - 1; i < SZ(d) && i <= j; i ++) {
		add(d[i].Y, -1);
		while (i < j && d[i].X + d[j].X > W) {
			add(d[j].Y, -1);
			j --;
		}
		
		if (L - d[i].Y < 0) continue;
		ans += get(L - d[i].Y + 1);
	}
	return ans;
}

queue<int> q;
vector<pii> adj[MAXN];
int deg[MAXN];
bool mark[MAXN];

void go(int x, int par) {
	deg[x] = 0;
	FOREACH(i, adj[x]) {
		int v = i->X;
		if (!mark[v]) deg[x] ++;
		if (v != par && !mark[v]) go(v, x);
	}

	if (deg[x] <= 1) q.push(x);
}

int findCenter(int x, int par) {
	while (SZ(q)) q.pop();

	go(x, par);
	while (SZ(q) > 1) {
		int x = q.front(); q.pop();

		FOREACH(i, adj[x]) {
			int v = i->X;
			if (!mark[v] && deg[v] > 1) {
				deg[v] --;
				if (deg[v] == 1) q.push(v);
			}
		}
	}
	return q.front();
}

vector<pii> d;

void dfs(int x, int par, int l, int w) {
	d.pb(mp(w, l));

	FOREACH(i, adj[x]) {
		int v = i->X, tw = i->Y;
		if (v == par || mark[v]) continue;

		dfs(v, x, l + 1, w + tw);
	}
}

ll solve(int x) {
	x = findCenter(x, -1);
	mark[x] = true;

	d.clear();
	dfs(x, -1, 0, 0);

	ll ans = calc(d);

	FOR(i, SZ(adj[x])) {
		int v = adj[x][i].X, w = adj[x][i].Y;
		if (mark[v]) continue;

		d.clear();
		dfs(v, x, 1, w);
		ans -= calc(d);
	}

	FOR(i, SZ(adj[x])) {
		int v = adj[x][i].X;
		if (mark[v]) continue;
		
		ans += solve(adj[x][i].X);
	}
	return ans;
}

int main () {
	ios::sync_with_stdio(false);

	int n;
	cin >> n >> L >> W;
	for (int i = 1; i < n; i ++) {
		int p, w; cin >> p >> w; p--;
		adj[i].pb(mp(p, w));
		adj[p].pb(mp(i, w));
	}

	cout << solve(0) << endl;
	return 0;
}

