#include<queue>
#include<cstdio>
#include<vector>
#include<iostream>
#include<algorithm>
using namespace std;
typedef __int64 LL;
const int INF = 0x7FFFFFFF;
const int maxn = 2e5 + 10;
int n, l, w, x, y;

struct Tree
{
	int ft[maxn], nt[maxn], u[maxn], v[maxn], sz;
	int mx[maxn], ct[maxn], vis[maxn], t;
	struct point
	{
		int x, y, z;
		point(int x = 0, int y = 0, int z = 0) :x(x), y(y), z(z) {};
		bool operator<(const point&a)const
		{
			return x == a.x ? y == a.y ? z < a.z : y < a.y : x < a.x;
		}
	}a[maxn], b[maxn];

	void clear(int n)
	{
		mx[sz = 0] = INF;
		for (int i = 1; i <= n; i++) ft[i] = -1, vis[i] = 0;
	}
	void AddEdge(int x, int y, int z)
	{
		u[sz] = y;	v[sz] = z;	nt[sz] = ft[x];	ft[x] = sz++;
		u[sz] = x;	v[sz] = z;	nt[sz] = ft[y]; ft[y] = sz++;
	}
	int dfs(int x, int fa, int sum)
	{
		int y = mx[x] = (ct[x] = 1) - 1;
		for (int i = ft[x]; i != -1; i = nt[i])
		{
			if (vis[u[i]] || u[i] == fa) continue;
			int z = dfs(u[i], x, sum);
			ct[x] += ct[u[i]];
			mx[x] = max(mx[x], ct[u[i]]);
			y = mx[y] < mx[z] ? y : z;
		}
		mx[x] = max(mx[x], sum - ct[x]);
		return mx[x] < mx[y] ? x : y;
	}
	void get(int x, int fa, int dep, int len)
	{
		a[t++] = point(dep, len, 0);
		a[t++] = point(l - dep, w - len, 1);
		for (int i = ft[x]; i != -1; i = nt[i])
		{
			if (u[i] == fa || vis[u[i]]) continue;
			get(u[i], x, dep + 1, len + v[i]);
		}
	}
	LL merge(int l, int r)
	{
		if (l == r) return 0;
		int m = l + r >> 1;
		LL ans = merge(l, m) + merge(m + 1, r);
		for (int i = l, j = l, k = m + 1, ct = 0; i <= r; i++)
		{
			if (j <= m && (a[j].y < a[k].y || a[j].y == a[k].y&&a[j].z <= a[k].z || k > r))
			{
				b[i] = a[j++];	ct += b[i].z ^ 1;
			}
			else
			{
				b[i] = a[k++];	ans += b[i].z*ct;
			}
		}
		for (int i = l; i <= r; i++) a[i] = b[i];
		return ans;
	}
	LL find(int x, int dep, int len)
	{
		LL ans = t = 0;
		get(x, -1, dep, len);
		sort(a, a + t);
		for (int i = 0; i < t; i++)
		{
			if (a[i].x + a[i].x <= l&&a[i].y + a[i].y <= w) ans += a[i].z ^ 1;
		}
		return merge(0, t - 1) - ans >> 1;
	}
	LL work(int x, int sum)
	{
		int y = dfs(x, -1, sum);
		LL ans = find(y, 0, 0);	vis[y] = 1;
		for (int i = ft[y]; i != -1; i = nt[i])
		{
			if (vis[u[i]]) continue;
			ans -= find(u[i], 1, v[i]);
			ans += work(u[i], ct[u[i]] > ct[y] ? sum - ct[y] : ct[u[i]]);
		}
		return ans;
	}
}solve;

int main()
{
	while (scanf("%d%d%d", &n, &l, &w) != EOF)
	{
		solve.clear(n);
		for (int i = 1; i < n; i++)
		{
			scanf("%d%d", &x, &y);
			solve.AddEdge(i + 1, x, y);
		}
		printf("%I64d\n", solve.work(1, n));
	}
	return 0;
}
	 	  		 	 		 	  			  		 				 		