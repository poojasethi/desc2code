#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
struct Edge
{
	int num;
	int len;
	int next;
};
struct Node
{
	int len;
	int w;
};
Edge e[1000000];
int p[100001];
int f1[100001];
int f2[100001];
int t[200001];
Node a[100001];
int d[100001];
int d2[100001];
bool mark[100001];
int z;
int n, L, W;
long long ans;
void add(int u, int v, int l)
{
	z++;
	e[z].num = v;
	e[z].next = p[u];
	e[z].len = l;
	p[u] = z;
}
int lowbit(int x)
{
	return x & (-x);
}
void add(int x, int k)
{
	x++;
	while(x <= n+1)
	{
		t[x] += k;
		x += lowbit(x);
	}
	return ;
}
int sum(int x)
{
	x++;
	int s = 0;
	while(x > 0)
	{
		s += t[x];
		x -= lowbit(x);
	}
	return s;
}
void dfs1(int u, int fa)
{
	z++;
	f1[u] = 1;
	for(int temp = p[u]; temp != -1; temp = e[temp].next)
	{
		int v = e[temp].num;
		if(v == fa || mark[v])
			continue;
		dfs1(v, u);
		f1[u] += f1[v];
	}
	return ;
}
void dfs2(int u, int fa, int& cur)
{
	f2[u] = 0;
	for(int temp = p[u]; temp != -1; temp = e[temp].next)
	{
		int v = e[temp].num;
		if(v == fa || mark[v])
			continue;
		dfs2(v, u, cur);
		f2[u] = max(f2[u], f1[v]);
	}
	f2[u] = max(f2[u], z - 1 - f1[u]);
	if(cur == -1 || f2[u] < f2[cur])
		cur = u;
	return ;
}
void findroot(int u, int fa, int& cur)
{
	z = 0;
	cur = -1;
	f2[fa] = 0;
	dfs1(u, fa);
	dfs2(u, fa, cur);
}
void dfs(int u, int fa)
{
	z++;
	a[z].w = d[u];
	a[z].len = d2[u];
	for(int temp = p[u]; temp != -1; temp = e[temp].next)
	{
		int v = e[temp].num;
		if(v == fa || mark[v])
			continue;
		d[v] = d[u] + e[temp].len;
		d2[v] = d2[u] + 1;
		dfs(v, u);
	}
	
}
bool cmp(Node u, Node v)
{
	return u.w < v.w;
}
long long calc(int u, int l, int l2)
{
	z = 0;
	d2[u] = l2;
	d[u] = l;
	dfs(u, 0);
	sort(a+1, a+z+1, cmp);
	int r = z;
	long long x = 0;
	for(int l = 1; l <= z; l++)
		add(a[l].len, 1);
	for(int l = 1; l <= z; l++)
	{
		while(r > l && a[l].w + a[r].w > W)
		{
			add(a[r].len, -1);
			r--;
		}
		if(l <= r)
			add(a[l].len, -1);
		x += (long long)sum(L - a[l].len);
		
	}
	
	return x;
}
void work(int cur)
{
	int u = cur;
	ans += calc(u, 0, 0);
	mark[u] = true;
	for(int temp = p[u]; temp != -1; temp = e[temp].next)
	{
		int v = e[temp].num;
		if(mark[v])
			continue;
		ans -= calc(v, e[temp].len, 1);
		findroot(v, u, cur);
		work(cur);
	}
	return ;
}
void solve()
{
	ans = 0;
	z = 0;
	memset(p, -1, sizeof(p));
	memset(mark, 0, sizeof(mark));
	for(int i = 1; i < n; i++)
	{
		int k1, k2, k;
		scanf("%d%d", &k2, &k);
		k1 = i+1;
		add(k1, k2, k);
		add(k2, k1, k);
	}
	int cur;
	findroot(1, 0, cur);
	work(cur);
	printf("%I64d\n", ans);
}
int main()
{
	scanf("%d%d%d", &n, &L, &W);
	solve();
	return 0;
}
