#include<math.h>
#include<algorithm>
#include<cstdlib>
#include<iostream>
#include<stdio.h>
#include<map>
#include<set>
#include<string>
#include<vector>
#include<queue>
#include<time.h>
#define Pi 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679
#define E 0.000001
#define P 100000007
#define MA(a,b) (a>b?a:b)
#define MI(a,b) (a<b?a:b)
#define minn min_element
#define maxx max_element
#define W first
#define L second
#define mp make_pair
#define pb push_back
using namespace std;
int CE,in,nn,np,n,m,II,i,j,k,l,r,w;
vector <int> v[100001],s[100001];
vector < pair <int,int> >  T[100001];
bool f[100001];
multiset <pair <int,int> > S;
multiset <pair <int,int> > ::iterator IT;
int sum[1000000];
vector <int> ad;
long long A;
int fi(int x,int fr)
{
    if (f[x]) return 0;
    int R=1;
    for (int i=0;i<v[x].size();i++)
        if (v[x][i]!=fr)
        R+=fi(v[x][i],x);
    if (R>np/2 && CE==0) CE=x;
    return R;
}
void go(int x,int fr,int I,int ll, int ww)
{
      if (f[x]) return;
      T[I].pb(mp(ww,ll));
     for (int i=0;i<v[x].size();i++)
        if (v[x][i]!=fr) go(v[x][i],x,I,ll+1,ww+s[x][i]);
}
int main() {
    cin>>n>>l>>w;
    for (i=2;i<=n;i++)
    {
        scanf("%d%d",&m,&r);
        v[i].pb(m);
        v[m].pb(i);
        s[i].pb(r);
        s[m].pb(r);
    }
    nn=n;
    while (nn)
    for (in=1;in<=n;in++)
    if (!f[in])
    {
        nn--;
        CE=0; np=fi(in,in);
        CE=0; np=fi(in,in);
        for (i=0;i<v[CE].size();i++)
        if (f[v[CE][i]]==0)
        {
            T[i].clear();
            go(v[CE][i],CE,i,1,s[CE][i]);
        }
        S.clear();
        S.insert(mp(0,0));
        for (II=0;II<v[CE].size();II++)
        if (f[v[CE][II]]==0)
        {
            sort(T[II].begin(),T[II].end());
            reverse(T[II].begin(),T[II].end());
            IT=S.begin();
            for (i=0;i<ad.size();i++)
            for (j=ad[i];j<=n+1;j=j*2-(j&(j-1)))sum[j]--;
            ad.clear();
            for (i=0;i<T[II].size();i++)
            {
                while ((*IT).W+T[II][i].W<=w && IT!=S.end()){
                for (j=(*IT).L+1;j<=n+1;j=j*2-(j&(j-1)))sum[j]++;
                ad.pb((*IT).L+1);
                IT++;
                }
                if (l-T[II][i].L>=0)
                for (j=l-T[II][i].L+1;j>0;j&=j-1) A+=sum[j];
            }
            for (i=0;i<T[II].size();i++)
            S.insert(T[II][i]);
   }
        f[CE]=1;
    }
   cout<<A<<endl;
    return 0;
}
