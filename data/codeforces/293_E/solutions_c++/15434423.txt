#include<cstdio>
#include<cctype>
#include<queue>
#include<cmath>
#include<cstring>
#include<algorithm>
#define rep(i,s,t) for(int i=s;i<=t;i++)
#define dwn(i,s,t) for(int i=s;i>=t;i--)
#define ren for(int i=first[x];i;i=next[i])
using namespace std;
inline int read() {
    int x=0,f=1;char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0';
    return x*f;
}
typedef long long ll;
const int maxn=100010;
const int maxm=200010;
int n,L,W,first[maxn],next[maxm],to[maxm],dis[maxm],s[maxn],f[maxn],size,root,e;
void AddEdge(int u,int v,int w) {
	dis[++e]=w;to[e]=v;next[e]=first[u];first[u]=e;
}
int vis[maxn];
void getroot(int x,int fa) {
	int maxs=0;s[x]=1;
	ren if(to[i]!=fa&&!vis[to[i]]) {
		getroot(to[i],x);
		s[x]+=s[to[i]];
		maxs=max(maxs,s[to[i]]);
	}
	f[x]=max(maxs,size-s[x]);
	if(f[root]>f[x]) root=x;
}
ll ans;
struct Node {
	int len,dep;
	bool operator < (const Node& ths) const {
		return len<ths.len;
	}
}A[maxn];
int cnt;
void dfs(int x,int fa,int clen,int cdep) {
	A[++cnt]=(Node){clen,cdep+1};
	ren if(to[i]!=fa&&!vis[to[i]]) dfs(to[i],x,clen+dis[i],cdep+1);
}
int sumv[maxn];
void add(int x,int v) {if(x>L) return;for(;x<=L;x+=x&-x) sumv[x]+=v;}
int sum(int x) {
	if(x<=0) return 0;
	int res=0;
	for(;x;x-=x&-x) res+=sumv[x];
	return res;
}
ll cal(int x,int dep0,int dis0) {
	cnt=0;dfs(x,0,dep0,dis0);
	sort(A+1,A+cnt+1);ll res=0;
	int l=1,r=cnt;
	rep(i,2,cnt) add(A[i].dep,1);
	while(l<r) {
		if(A[l].len+A[r].len>W) add(A[r--].dep,-1);
		else res+=sum(L-A[l].dep),add(A[++l].dep,-1);
	}
	return res;
}
void solve(int x) {
	vis[x]=1;ans+=cal(x,0,0);
	ren if(!vis[to[i]]) {
		ans-=cal(to[i],dis[i],1);
		f[0]=size=s[to[i]];getroot(to[i],root=0);
		solve(root);
	}
}
int main() {
	n=read();L=read()+2;W=read();
	rep(i,2,n) {
		int p=read(),w=read();
		AddEdge(p,i,w);
		AddEdge(i,p,w);
	}
	size=f[0]=n;getroot(1,root=0);
	solve(root);
	printf("%I64d\n",ans);
	return ~~(0-0);
}
