#include <iostream>
#include <cstdio>
#include <cmath>
#include <vector>
#include <algorithm>
#define EPS 1E-9
#define EPS1 1E-6
using namespace std;
#define double long double
double ANS;
struct point{
  double x,y;
  point(double _x=0,double _y=0){x=_x;y=_y;}
  point operator-(point w){return point(x-w.x,y-w.y);}
  point operator+(point w){return point(x+w.x,y+w.y);}
  double MOD(){return sqrt(x*x+y*y);}
  bool operator<(const point& w)const{return (abs(x-w.x)>EPS?x<w.x:y<w.y);}
  void read(){
   #undef double
   double _x,_y;
   scanf("%lf%lf",&_x,&_y);
   x=_x;y=_y;
   #define double long double
             }
};
double vp(point a,point b){return (a.x*b.y-a.y*b.x);}
int ORI(point a,point b){
  double VP=vp(a,b);
  return (abs(VP)<EPS1?0:(VP>0?1:-1));
}
bool intersect(point f1,point t1,point f2,point t2){
  if(ORI(f2-f1,t1-f1)*ORI(t2-f1,t1-f1)>0)return false;
  if(ORI(f1-f2,t2-f2)*ORI(t1-f2,t2-f2)>0)return false;
  return true;
}
struct prava{
  double a,b,c;
  prava(point f=point(0,0),point s=point(1,1)){a=s.y-f.y;b=f.x-s.x;c=s.x*f.y-f.x*s.y;}
  point IP(prava w){
   point R;
   if(abs(a)<EPS){R.y=(-c)/b;R.x=(-w.b*R.y-w.c)/w.a;}
   else{R.y=(w.a*c-a*w.c)/(a*w.b-w.a*b);R.x=(-b*R.y-c)/a;}
   return R;
                   }
};
int n;
point tri[100][3];
bool inside(point w,int T){
  if(ORI(w-tri[T][0],tri[T][1]-tri[T][0])*ORI(tri[T][2]-tri[T][0],tri[T][1]-tri[T][0])<=0)return false;
  if(ORI(w-tri[T][1],tri[T][2]-tri[T][1])*ORI(tri[T][0]-tri[T][1],tri[T][2]-tri[T][1])<=0)return false;
  if(ORI(w-tri[T][2],tri[T][0]-tri[T][2])*ORI(tri[T][1]-tri[T][2],tri[T][0]-tri[T][2])<=0)return false;
  return true;
}
void solve_side(int T,int f,int s){
  vector<point> P;
  P.push_back(tri[T][f]);P.push_back(tri[T][s]);
  for(int i=0;i<n;++i){
   if(i==T)continue;
   if(intersect(tri[i][0],tri[i][1],tri[T][f],tri[T][s]))
    P.push_back(prava(tri[i][0],tri[i][1]).IP(prava(tri[T][f],tri[T][s])));
   if(intersect(tri[i][1],tri[i][2],tri[T][f],tri[T][s]))
    P.push_back(prava(tri[i][1],tri[i][2]).IP(prava(tri[T][f],tri[T][s])));
   if(intersect(tri[i][2],tri[i][0],tri[T][f],tri[T][s]))
    P.push_back(prava(tri[i][2],tri[i][0]).IP(prava(tri[T][f],tri[T][s])));
                      }
  sort(P.begin(),P.end());
  for(int i=1;i<P.size();++i){
   point MID((P[i-1].x+P[i].x)/2,(P[i-1].y+P[i].y)/2);
   for(int j=0;j<n;++j)
    if(inside(MID,j))goto END;
   ANS+=(P[i]-P[i-1]).MOD();
   END:;
                             }
}
#undef double
int main(){
  int i,j,k,l;
  //system("pause");
  scanf("%d",&n);
  for(i=0;i<n;++i){tri[i][0].read();tri[i][1].read();tri[i][2].read();}
  for(i=0;i<n;++i){
   solve_side(i,0,1);
   solve_side(i,1,2);
   solve_side(i,2,0);
                  }
  printf("%.10lf\n",(double)ANS);
  //system("pause");
  return 0;
}
