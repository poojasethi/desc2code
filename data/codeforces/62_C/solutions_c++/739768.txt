#include <iostream>
#include <vector>
#include <complex>
#include <algorithm>
#include <cmath>

using namespace std;

typedef complex<double> point;

double prodesc(point p1,point p2)
{
  return real(conj(p1)*p2);
}

double prodvec(point p1,point p2)
{
  return imag(conj(p1)*p2);
}

double error=0.0000000001;

int signo(double x)
{
  if (x<-error) return -1;
  if (x>error) return 1;
  return 0;
}

pair<double,int> interseccion(point p1,point v1,point p2,point v2)
{
  point p=p1+(prodvec(p2-p1,v2)/prodvec(v1,v2))*v1;

  return pair<double,int> (prodesc(v1,p-p1)/abs(v1),signo(prodvec(v1,v2)));
}

bool hayinterseccion(point p1,point v1,point p2,point v2,
		     point p3,point v3)
{
  return
    (signo(prodvec(v1,p2-p1))!=0 and
     signo(prodvec(v1,p2+v2-p1))!=0 and
     signo(prodvec(v1,p2-p1))!=signo(prodvec(v1,p2+v2-p1))) or
    (signo(prodvec(v1,p2-p1))!=0 and
     signo(prodvec(v1,p2+v2-p1))==0 and
     signo(prodvec(v1,p3+v3-p1))!=0 and
     signo(prodvec(v1,p2-p1))!=signo(prodvec(v1,p3+v3-p1)));
}

point llegir()
{
  double x,y;
  cin>>x>>y;
  return point(x,y);
}

int main()
{
  cout.setf(ios::fixed);
  cout.precision(10);
  int n;
  cin>>n;
  vector<pair<point,point> > segmento;
  vector<int> next;
  for (int i=0;i<n;i++) {
    point p1=llegir();
    point p2=llegir();
    point p3=llegir();
    if (signo(prodvec(p2-p1,p3-p2))==-1)
      swap(p2,p3);
    segmento.push_back(pair<point,point> (p1,p2-p1));
    segmento.push_back(pair<point,point> (p2,p3-p2));
    segmento.push_back(pair<point,point> (p3,p1-p3));
    int pos=int(next.size());
    next.push_back(pos+1);
    next.push_back(pos+2);
    next.push_back(pos);
  }
  double total=0;
  for (int i=0;i<int(segmento.size());i++) {
    pair<point,point> s=segmento[i];
    vector<pair<double,int> > inter;
    for (int j=0;j<int(segmento.size());j++) {
      if (i!=j) {
	pair<point,point> ss=segmento[j];
	pair<point,point> sss=segmento[next[j]];
	if (hayinterseccion(s.first,s.second,ss.first,ss.second,
			    sss.first,sss.second)) {
	  inter.push_back(interseccion(s.first,s.second,ss.first,ss.second));
	}
      }
    }
    double posini=0;
    double posfin=abs(s.second);
    inter.push_back(pair<double,int> (posini,0));
    inter.push_back(pair<double,int> (posfin,0));
    sort(inter.begin(),inter.end());
    int count=0;
    count=inter[0].second;
    for (int j=1;j<int(inter.size());j++) {
      if (count==0 and inter[j].first>posini and inter[j].first<posfin+error
	  and inter[j-1].first<posfin and inter[j-1].first>-error)
	total+=inter[j].first-inter[j-1].first;
      count+=inter[j].second;
    }
  }
  cout<<total<<endl;
}
