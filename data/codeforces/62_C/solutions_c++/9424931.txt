#include <bits/stdc++.h>
using namespace std;

const double eps = 1e-6;
typedef long long ll;

inline double sqr(double x) {
  return x * x;
}

struct PointF {
  double x, y;
  PointF(double x = 0, double y = 0) : x(x), y(y) {}
  bool operator<(PointF other) const {
    if (fabs(x - other.x) < eps)
      return y < other.y;
    return x < other.x;
  }
  double distTo(PointF P) {
    return sqrt(sqr(x - P.x) + sqr(y - P.y));
  }
};

struct PointI {
  int x, y;
  PointI(int x = 0, int y = 0) : x(x), y(y) {}
  bool operator<(PointI other) const {
    if (x == other.x)
      return y < other.y;
    return x < other.x;
  }
};

int sign(double x) {
  if (fabs(x) < eps) return 0;
  if (x > 0) return 1;
  return -1;
}

struct Triangle {
  PointI p[3];
  bool inside(PointF P) {
    int minus = 0, plus = 0;
    for (int i = 0; i < 3; ++i) {
      ll A = p[i].y - p[(i + 1) % 3].y;
      ll B = p[(i + 1) % 3].x - p[i].x;
      ll C = -A*p[i].x -B*p[i].y;
      int sgn = sign(A * P.x + B * P.y + C);
      if (sgn == 1) ++plus;
      if (sgn == -1) ++minus;
    }
    return max(minus, plus) == 3;
  }
} triangle[101];

struct Segment {
  PointI p[2];
  Segment(PointI a, PointI b) {
    p[0] = a;
    p[1] = b;
  }
  bool liesOnSegment(PointF P) {
    return (P.x + eps > min(p[0].x, p[1].x) &&
	    P.x - eps < max(p[0].x, p[1].x) &&
	    P.y + eps > min(p[0].y, p[1].y) &&
	    P.y - eps < max(p[0].y, p[1].y));
  }
  PointF intersection(Segment other) {
    ll A1 = p[0].y - p[1].y;
    ll B1 = p[1].x - p[0].x;
    ll C1 = -A1*p[0].x - B1*p[0].y;
    ll A2 = other.p[0].y - other.p[1].y;
    ll B2 = other.p[1].x - other.p[0].x;
    ll C2 = -A2*other.p[0].x -B2*other.p[0].y;
    if (B1*A2==B2*A1)
      return PointF(-1, -1);
    PointF inter = PointF((B2 * C1 - C2 * B1) * 1.0 / (B1 * A2 - B2 * A1),
		  (A2 * C1 - C2 * A1) * 1.0 / (B2 * A1 - A2 * B1));
    if (!liesOnSegment(inter) || !other.liesOnSegment(inter))
      inter = PointF(-1, -1);
    return inter;
  }
};

vector<PointF> segments[333];
int n;

int main() {
  //freopen("input.txt", "r", stdin);
  scanf("%d", &n);
  for (int i = 0; i < n; ++i) {
    for (int j = 0; j < 3; ++j) {
      scanf("%d %d", &triangle[i].p[j].x, &triangle[i].p[j].y);
    }
  }
  for (int i = 0; i < n; ++i) {
    for (int j = 0; j < n; ++j) {
      for (int k = 0; k < 3; ++k) {
	for (int l = 0; l < 3; ++l) {
	  if (i == j && k == l) continue;
	  Segment A(triangle[i].p[k], triangle[i].p[(k + 1) % 3]);
	  Segment B(triangle[j].p[l], triangle[j].p[(l + 1) % 3]);
	  PointF inter = A.intersection(B);
	  if (inter.x > -eps)
	    segments[3 * i + k].push_back(inter);
	}
      }
    }
  }
  double res = 0;
  for (int i = 0; i < 333; ++i) {
    sort(segments[i].begin(), segments[i].end());
    for (int j = 1; j < (int)segments[i].size(); ++j) {
      PointF mid((segments[i][j - 1].x + segments[i][j].x) / 2.0,
		 (segments[i][j - 1].y + segments[i][j].y) / 2.0);
      bool ok = true;
      for (int k = 0; ok && k < n; ++k)
	if (triangle[k].inside(mid))
	  ok = false;
      if (ok)
	res += segments[i][j - 1].distTo(segments[i][j]);
    }
  }
  printf("%.18lf\n", res);
  return 0;
}
