#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <cmath>
#define N 310
#define db double
#define eps (1e-8)
#define For(i,x,y) for (i=x;i<=y;i++)
using namespace std;
const db ang=0.1546316434691;
struct ww {
	db x,y;
	inline void read() {
		scanf("%lf%lf",&x,&y);
	}
	inline ww zhuan(db ang) {
		return (ww){cos(ang)*x-sin(ang)*y,sin(ang)*x+cos(ang)*y};
	}
	inline db operator * (const ww &A) {
		return x*A.y-y*A.x;
	}
	inline ww operator - (const ww &A) {
		return (ww){x-A.x,y-A.y};
	}
	inline db com() {
		return x*x+y*y;
	}
} a[5];
struct w {
	ww a,b;
	int ty;
} b[N];
struct W {
	db x,y,len;
	int a;
} d[N];
int i,j,k,n,m,s;
db c[N*N],an;
inline bool cc1(const ww &a,const ww &b) {
	return a.x<b.x;
}
inline void gao(w A,w B) {
	if (((A.b-A.a)*(B.a-A.a))*((A.b-A.a)*(B.b-A.a))>-eps) return;
	swap(A,B);
	db s1=(A.b-A.a)*(B.a-A.a),s2=(A.b-A.a)*(B.b-A.a);
	if (s1*s2>-eps) return;
	c[++s]=B.a.x+(B.b.x-B.a.x)*s1/(s1-s2);
}
inline bool cc2(const W &a,const W &b) {
	return a.x+eps<b.x||abs(a.x-b.x)<eps&&a.y<b.y;
}
inline ww get(w A,db b) {
	db y=A.a.y+(A.b.y-A.a.y)*(b-A.a.x)/(A.b.x-A.a.x);
	return (ww){b,y};
}
int main() {
	scanf("%d",&n);
	For(i,1,n) {
		For(j,0,2) a[j].read(),a[j]=a[j].zhuan(ang);
		sort(a,a+3,cc1);
		db sum=0; a[3]=a[0];
		For(j,0,2) sum+=a[j]*a[j+1];
		b[++m]=(w){a[0],a[1],sum<0};
		b[++m]=(w){a[1],a[2],sum<0};
		b[++m]=(w){a[0],a[2],sum>0};
		For(j,0,2) c[++s]=a[j].x;
	}
	For(i,1,m)For(j,i+1,m) gao(b[i],b[j]);
	sort(c+1,c+s+1);
	k=s; s=0;
	For(i,1,k) if (!s||c[s]+eps<c[i]) c[++s]=c[i];
	For(i,1,s-1) {
		int t=0;
		For(j,1,m) {
			w A=b[j];
			if (A.b.x>c[i]&&A.a.x<c[i+1]) {
				ww B=get(A,c[i]),C=get(A,c[i+1]);
				ww D=C-B;
				d[++t]=(W){B.y,C.y,sqrt(D.com()),A.ty};
			}
		}
		sort(d+1,d+t+1,cc2);
		int cen=0;
		For(j,1,t) {
			if (!cen) an+=d[j].len;
			cen+=d[j].a?1:-1;
			if (!cen) an+=d[j].len;
		}
	}
	printf("%.12lf\n",an);
	//for(;;);
	return 0;
}
