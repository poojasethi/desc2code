#include<cmath>
#include<cstdio>
#include<iomanip>
#include<set>
#include<iostream>
#include<algorithm>
#include<vector>
#include<cstring>
using namespace std;
typedef long double ld;
ld eps = 1e-7;
int cmp(ld a, ld b = 0){
	return a + eps < b ? -1 : a - eps > b ? 1 : 0;
}
struct point{
	ld x, y;
	point(ld a = 0, ld b = 0): x(a), y(b){}
	bool operator <(const point& q)const{
		if(int t = cmp(x, q.x)) return t < 0;
		else return cmp(y, q.y) < 0;
	}
	bool operator ==(const point& q) const{
		return cmp(x, q.x) == 0 && cmp(y, q.y) == 0;
	}
	void read(){
		cin >> x >> y;
	}
};

ld dist(point& a, point& b){
	return hypot(a.x - b.x, a.y - b.y);
}
point mid(point& a, point& b){
	return point((a.x + b.x) / 2, (a.y + b.y) / 2);
}

int cross(point& a, point& p, point& q){
	ld x = (p.x - a.x) * (q.y - a.y) - (p.y - a.y) * (q.x - a.x);
	return cmp(x); 
}
bool on(point& a, point &p, point& q){
	if(cmp(p.x, q.x) == 0) return cmp(a.y, min(p.y, q.y)) >= 0 && cmp(a.y, max(p.y, q.y)) <= 0;
	return cmp(a.x, min(p.x, q.x)) >= 0 && cmp(a.x, max(p.x, q.x)) <= 0;
}
point tri[100][4];
int n;

bool libre(point p){
	for(int i = 0; i < n; i++){
		int a1 = cross(p, tri[i][0], tri[i][1]);
		int a2 = cross(p, tri[i][1], tri[i][2]);
		int a3 = cross(p, tri[i][2], tri[i][3]);
		if(a1 != 0 && a2 != 0 && a3 != 0)
			if(a1 == a2 && a2 == a3) return false;
	}
	return true;
}

int main(){
	scanf("%d", &n);
	for(int i = 0; i < n; i++) for(int j = 0; j < 3; j++) tri[i][j].read();	
	for(int i = 0; i < n; i++) tri[i][3] = tri[i][0];
	ld res = 0;
	point pivot;
	for(int i = 0; i < n; i++) for(int j = 0; j < 3; j++){
		vector<point> inter;
		ld A1 = tri[i][j + 1].y - tri[i][j].y;
		ld B1 = tri[i][j].x - tri[i][j + 1].x;
		ld C1 = A1 * tri[i][j].x + B1 * tri[i][j].y;
		inter.push_back(tri[i][j]);
		inter.push_back(tri[i][j + 1]);
		for(int a = 0; a < n; a++) for(int b = 0; b < 3; b++){
			ld A2 = tri[a][b + 1].y - tri[a][b].y;
			ld B2 = tri[a][b].x - tri[a][b + 1].x;
			ld C2 = A2 * tri[a][b].x + B2 * tri[a][b].y;
			ld det = A1 * B2 - A2 * B1;
			if(cmp(det) != 0){
				point p((C1 * B2 - C2 * B1) / det, (A1 * C2 - A2 * C1) / det);
				if(on(p, tri[i][j], tri[i][j + 1]) && on(p, tri[a][b], tri[a][b + 1]))
					inter.push_back(p);
			}
		}
		sort(inter.begin(), inter.end());
		inter.erase(unique(inter.begin(), inter.end()), inter.end());
		
		for(int k = 1; k < inter.size(); k++){
			point aux =  mid(inter[k], inter[k - 1]);
			if(i == 1 && j == 1 && k == 1)  pivot = aux;
			if(libre(aux)) res += dist(inter[k], inter[k - 1]);
		}
	}
	cout << setprecision(10) << res << endl;
	//printf("%.10Lf\n", res);
}
