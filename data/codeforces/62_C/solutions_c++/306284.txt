#include <iostream>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <vector>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <ctime>
#include <cstdlib>
#include <cctype>
#include <cassert>
#include <utility>
#include <complex>

using namespace std;

typedef long long LL;
typedef long double LD;

#define NAME "task"

//solution

const LD EPS = 1e-7;

struct Point
{
	LD x, y;
	int id;

	Point(LD _x, LD _y, LD _id) : x(_x), y(_y), id(_id) {}
	Point() {}
};

istream& operator >> (istream& istr, Point& p)
{
	istr >> p.x >> p.y;
	return istr;
}

ostream& operator << (ostream& ostr, Point p)
{
	ostr << '(' << p.x << ' ' << p.y << ") ";
	return ostr;
}

bool operator < (Point a, Point b)
{
	if (fabs(a.x - b.x) > EPS)
		return a.x < b.x;
	return a.y < b.y;
}

LD sqr(LD x)
{
	return x * x;
}

LD dist(Point a, Point b)
{
	return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));
}

int n;
vector<Point> a;
vector<Point> b;
vector<Point> c;

vector<Point> ps;

void consider(Point s, Point t, Point d, Point e, int id)
{
	LD a1 = t.y - s.y;
	LD b1 = s.x - t.x;
	LD c1 = a1 * s.x + b1 * s.y;

	LD a2 = e.y - d.y;
	LD b2 = d.x - e.x;
	LD c2 = a2 * d.x + b2 * d.y;

	LD det = a1 * b2 - a2 * b1;
	LD detX = c1 * b2 - c2 * b1;
	LD detY = a1 * c2 - a2 * c1;

	if (fabs(det) < EPS) return;
	Point p(detX / det, detY / det, id);
	if (p < min(d, e) || max(d, e) < p) return;
	ps.push_back(p);
}

LD solve(Point s, Point t, int id)
{
	ps.clear();
	s.id = t.id = id;
	ps.push_back(s); ps.push_back(t);
	for (int i = 0; i < n; i++)
	{
		 if (i == id) continue;
		 consider(s, t, a[i], b[i], i);
		 consider(s, t, b[i], c[i], i);
		 consider(s, t, c[i], a[i], i);
	}	
	sort(ps.begin(), ps.end());

	vector<int> first(n, -1), last(n, -1);
	for (int i = 0; i < ps.size(); i++)
		if (first[ps[i].id] == -1)
			first[ps[i].id] = i;
	for (int i = ps.size() - 1; i >= 0; i--)
		if (last[ps[i].id] == -1)
			last[ps[i].id] = i;

	int depth = 0;
	bool inside = false;
	LD ret = 0.0;
	for (int i = 0; i < ps.size(); i++)
	{
		if (depth == 0 && i - 1 >= 0 && inside)
			ret += dist(ps[i], ps[i - 1]);
		if (ps[i].id == id) 
		{
			inside ^= 1;
			continue;
		}

		if (i == first[ps[i].id])
			depth++;
		if (i == last[ps[i].id])
			depth--;			
	}

	#ifdef DEBUG
	cerr << "solve " << s << ' ' << t << " returns " << ret << '\n';
	cerr << "ps ";
	for (int i = 0; i < ps.size(); i++) cerr << ps[i];
	cerr << '\n';
	#endif

	return ret;
}

int main()
{
	cin >> n;
	a.resize(n); b.resize(n); c.resize(n);
	for (int i = 0; i < n; i++)
		cin >> a[i] >> b[i] >> c[i];

	LD ans = 0.0;
	for (int i = 0; i < n; i++)
		ans += solve(a[i], b[i], i) + solve(b[i], c[i], i) + solve(c[i], a[i], i);

	cout << fixed << setprecision(9) << ans << '\n';

    return 0;
}
