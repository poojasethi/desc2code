#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <string>
#include <vector>
#include <queue>
#include <cmath>
#include <map>
#include <set>
#define PB push_back
#define MP make_pair
using namespace std;
typedef pair<int, int> PII;
typedef long long LL;
#define EPS (1e-8)

const int MAXN = 110;
struct Point {
    double x, y;
    Point(){}
    Point(double inx, double iny):x(inx), y(iny){}
    void Scan() {
        scanf("%lf%lf", &x, &y);
    }
} tri[MAXN][3];

double Cp(Point O, Point A, Point B) {
    A.x -= O.x; A.y -= O.y;
    B.x -= O.x; B.y -= O.y;
    return A.x * B.y - B.x * A.y;
}

double Dist(Point A, Point B) {
    return sqrt( (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y) );
}

int n;
double ans = 0.0;

int main() {

    scanf("%d", &n);
    for (int i = 0; i < n; i++)
        for (int j = 0; j < 3; j++)
            tri[i][j].Scan();
    for (int i = 0; i < n; i++)
        for (int i2 = 0; i2 < 3; i2++) {
            Point A = tri[i][i2];
            Point B = tri[i][(i2 + 1) % 3];
            vector<double> sta;
            sta.PB(0.0); sta.PB(1.0);
            for (int j = 0; j < n; j++) {
                if (i == j) continue;
                for (int j2 = 0; j2 < 3; j2++) {
                    Point C = tri[j][j2];
                    Point D = tri[j][(j2 + 1) % 3];
                    if (Cp(C, D, A) * Cp(C, D, B) + EPS > 0) continue;
                    if (Cp(A, B, D) * Cp(A, B, C) + EPS > 0) continue;
                    double area1 = Cp(C, D, A);
                    double area2 = Cp(C, D, B);
                    sta.PB(area1 / (area1 - area2));
                }
            }
            sort(sta.begin(), sta.end());
            double all = 0.0;
            for (int si = 0; si + 1 < sta.size(); si++) {
                double mid = sta[si] + sta[si + 1];
                mid /= 2;
                Point now((B.x - A.x) * mid + A.x, (B.y - A.y) * mid + A.y);
                bool ff = true;
                for (int j = 0; j < n && ff; j++) {
                    if (i == j) continue;
                    double area1 = 0.0;
                    for (int j2 = 0; j2 < 3; j2++)
                        area1 += fabs(Cp(now, tri[j][j2], tri[j][(j2+1)%3]));
                    double area2 = fabs(Cp(tri[j][0], tri[j][1], tri[j][2]));
                    if (fabs(area1 - area2) < EPS) ff = false;
                }
                if (ff) all += sta[si + 1] - sta[si];
            }
            ans += Dist(A, B) * all;
        }
    printf("%.10f\n", ans);
    return 0;
}
