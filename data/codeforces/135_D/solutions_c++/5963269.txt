#include <map>
#include <set>
#include <queue>
#include <stack>
#include <cctype>
#include <cstdio>
#include <string>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

typedef long long LL;
typedef pair<int, int> PII;

#define FILE freopen("../data.in","r",stdin)
#define REP(i,n) for(int i=0; i<(n); i++)
#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin(); it!=(a).end(); it++)

const int N = 1100;
const int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};
const int dy[] = {1, 0, -1, 0, 1, -1, 1, -1};

struct Point {
	int x, y;
	
	Point() {}
	Point(int x, int y)
	:x(x), y(y) {}
	
	bool operator < (const Point& a) const {
		return x < a.x || (x == a.x && y < a.y);
	}
};

set<Point> st;

char mz[N][N];
bool vis[N][N];
int n, m;
bool out;

bool check4() {
	for (int i = 0; i < n - 1; i++)
		for (int j = 0; j < m - 1; j++)
			if (mz[i][j] == '1' && mz[i + 1][j] == '1' && mz[i][j + 1] == '1' && mz[i + 1][j + 1] == '1')
				return true;
	return false;
}

void fill(int x, int y) {
	vis[x][y] = true;
	for (int d = 0; d < 8; d++) {
		int nx = x + dx[d], ny = y + dy[d];
		if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
			if (mz[nx][ny] == '1')
				st.insert(Point(nx, ny));
			else if (!vis[nx][ny] && mz[nx][ny] == '0')
				fill(nx, ny);
		} else
			out = true;
	}
}

void go(int x, int y) {
	st.erase(Point(x, y));
	for (int d = 0; d < 4; d++) {
		int nx = x + dx[d];
		int ny = y + dy[d];
		if (st.count(Point(nx, ny)))
			go(nx, ny);
	}
}

int ok() {
	int tmp = st.size();
	if (tmp <= 4)
		return 0;
	foreach(it, st) {
		int cnt = 0;
		for (int d = 0; d < 4; d++) {
			int nx = it->x + dx[d];
			int ny = it->y + dy[d];
			if (st.count(Point(nx, ny)))
				cnt++;
		}
		if (cnt != 2)
			return 0;
	}
	go(st.begin()->x, st.begin()->y);
	return st.size() ? 0 : tmp;
}

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 0; i < n; i++)
		scanf("%s", mz[i]);
	memset(vis, 0, sizeof(vis));
	int ans = 0;
	if (check4())
		ans = 4;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			if (mz[i][j] == '0' && !vis[i][j]) {
				out = false;
				st.clear();
				fill(i, j);
				if (out)
					st.clear();
// foreach(it, st) printf("%d %d\n", it->x, it->y);
				ans = max(ans, ok());
			}
	cout << ans << endl;
    return 0;
}

	    	     	    		    			