#include <iostream>
#include <vector>
using namespace std;

#define foreach(i, a) for(__typeof((a).begin()) _ind=(a).begin(); _ind!=(a).end(); _ind++) \
						for(bool _flag=true; _flag;) \
							for(__typeof(*(a).begin()) &i = *_ind; _flag; _flag = false)
#define SZ(a) ((int)(a).size())
#define all(a) a.begin(),a.end()
typedef long long ll;
typedef pair<int,int> pii;
const int INF = 2e9;
const int MAXn = 1000;
char tb[MAXn][MAXn+1];
bool mark[MAXn][MAXn],mark2[MAXn][MAXn];
vector<pii> one;
int rn, cn;

bool f;
bool valid(int r, int c) { return 0<=r&&r<rn && 0<=c&&c<cn; }
void dfs_zero(int r, int c)
{
	mark[r][c] = true;
	for(int i = -1; i <= 1; i++)
		for(int j = -1; j <= 1; j++)
		{
			int nr=r+i,nc=c+j;
			if(!valid(nr,nc))
			{
				f=true;
				continue;
			}
			if(mark[nr][nc]==true) continue;
			if(tb[nr][nc]=='0')
				dfs_zero(nr,nc);
			else
			{
				mark[nr][nc]=true;
				one.push_back(pii(nr,nc));
			}
		}
}

int one_c;
void dfs_one(int r, int c)
{
	one_c++;
	mark2[r][c]=true;
	int count=0;
	for(int i = -1; i <= 1; i++)
		for(int j = -1; j <= 1; j++)
		{
			if(i*j!=0) continue;
			int nr=r+i,nc=c+j;
			if(!valid(nr,nc)) continue;
			if(mark[nr][nc] && tb[nr][nc]=='1') count++;
			if(mark2[nr][nc]==false&&mark[nr][nc]==true&&tb[nr][nc]=='1')
				dfs_one(nr,nc);
		}
	if(count != 3) f = true;
}

int dfs(int r, int c)
{
	one.clear();
	f=false;
	dfs_zero(r,c);
	if(SZ(one) == 0)
		return 0;
	one_c=0;
	dfs_one(one[0].first,one[0].second);
	foreach(i,one)
		mark2[i.first][i.second]=mark[i.first][i.second]=false;
	if(f==true) return 0;
	if(one_c==SZ(one))
		return one_c;
	else
		return 0;
}

int main()
{
	ios::sync_with_stdio(false);
	cin >> rn >> cn;
	for(int i = 0; i < rn; i++)
		cin >> tb[i];
	int mx=0;
	for(int i = 0; i < rn; i++)
		for(int j = 0; j < cn; j++)
			if(mark[i][j] == false && tb[i][j] == '0')
				mx=max(mx,dfs(i,j));
	for(int i = 0; i < rn-1; i++)
		for(int j = 0; j < cn-1; j++)
			if(tb[i][j]=='1'&&tb[i+1][j]=='1'&&tb[i][j+1]=='1'&&tb[i+1][j+1]=='1')
				mx=max(mx,4);
	cout << mx << endl;
	return 0;
}
