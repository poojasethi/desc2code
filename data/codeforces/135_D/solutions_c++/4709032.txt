#include <cstdio>
#include <queue>
#include <vector>

#define X first
#define Y second
#define pb push_back
#define mp make_pair

using namespace std;


const int MaxN = 1000 + 111;

int n, m, u;

int d[MaxN][MaxN],cnt;

char a[MaxN][MaxN];


queue < pair <int, int> > q;
vector < pair <int, int> > v;

void push1(int x, int y)
{
	if (x >= 1 && x <= n && y >= 1 && y <= m && a[x][y] == '1' && !d[x][y])
		d[x][y] = cnt,q.push(mp(x, y));
}

int f[MaxN * MaxN], g[MaxN][MaxN];

int mark0(int x, int y)
{
	if (x < 1 || n < x || y < 1 || m < y)
		return u++;
	if (a[x][y] == '1') {
		if (f[d[x][y]] != cnt) 
			u++, f[d[x][y]] = cnt;
		if (g[x][y] != cnt) 
			g[x][y] = cnt, v.pb(mp(x, y));
	} else {
		if (d[x][y]) return 0;

		d[x][y] = -1;
		q.push(mp(x, y));
	}
}
const int d4x[] = {0,0,1,-1};
const int d4y[] = {1,-1,0,0};
int main(){
	//freopen("D.in","r",stdin);
	//freopen("D.out","w",stdout);

	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
		scanf("%s",a[i] + 1);

	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			if (d[i][j] == 0 && a[i][j] == '1')	{
				cnt++,push1(i, j);
				while (!q.empty()) {
					int x = q.front().X,
						y = q.front().Y;
					q.pop();
					for (int dir = 0; dir < 4; dir++)
						push1(x + d4x[dir], y + d4y[dir]);
				}
			}
	
	int ans = 0;
	for (int i = 1; i <= n - 1; i++)
		for (int j = 1; j <= m - 1; j++)
			if (a[i][j] == '1' && a[i][j + 1] == '1' && a[i + 1][j] == '1' && a[i + 1][j + 1] == '1')
				ans = 4;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			if (a[i][j] == '0' && d[i][j] == 0)	{
				u = 0;v.clear();cnt++;mark0(i, j);
				while (!q.empty()) {
					int	x = q.front().X,
						y = q.front().Y; q.pop();
					for (int dx = -1; dx <= 1; dx++)
						for (int dy = -1; dy <= 1; dy++)
							mark0(x + dx, y + dy);
				}
				if (u == 1){
					for (int i = 0; i < v.size(); i++)
						g[v[i].X][v[i].Y] = 0;

					for (int i = 0; i < v.size(); i++)
						for (int dir = 0; dir < 4; dir++)
							g[v[i].X + d4x[dir]][v[i].Y + d4y[dir]]++;

					bool flag = true;
					for (int i = 0; i < v.size(); i++)
						if (g[v[i].X][v[i].Y] != 2)	{
							flag = false;
							break;
						}
					if (flag) ans = max(ans, (int)v.size());
				}
			}
	printf("%d\n", ans);
	return 0;
}