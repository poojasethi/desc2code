# -*- coding: utf-8 -*-
import sys
import heapq
from collections import defaultdict
from collections import OrderedDict
import copy
from collections import deque


class Solver(object):

    def run(self):
        r, s, p = readarray(int)

        dp = [[[0.0]*101 for row in xrange(101)] for col in xrange(101)]
        dp[r][s][p] = 1.0

        for i in sorted(xrange(101), reverse=True):
            for j in sorted(xrange(101), reverse=True):
                for k in sorted(xrange(101), reverse=True):

                    TOTAL = i*j + j*k + k*i
                    if dp[i][j][k] != 0.0 and TOTAL != 0:
                        # r kills s
                        dp[i][j-1][k] += float(i*j)/TOTAL * dp[i][j][k]

                        # s kills p
                        dp[i][j][k-1] += float(j*k)/TOTAL * dp[i][j][k]

                        # p kills r
                        dp[i-1][j][k] += float(k*i)/TOTAL * dp[i][j][k]

        rp = 0.0
        sp = 0.0
        pp = 0.0

        for i in xrange(101):
            if dp[i][0][0] != 0.0:
                rp += dp[i][0][0]
        for i in xrange(101):
            if dp[0][i][0] != 0.0:
                sp += dp[0][i][0]
        for i in xrange(101):
            if dp[0][0][i] != 0.0:
                pp += dp[0][0][i]

        print("%2.12f %2.12f %2.12f" % (rp, sp, pp))



####################################
# ここからは見ちゃダメ！

def read(foo):
    return foo(raw_input())
def readarray(foo):
    return [foo(x) for x in raw_input().split()]
def dbg(a):
    sys.stderr.write(str(a))
def dbgln(a):
    sys.stderr.write(str(a) + "\n")
# https://gist.github.com/kachayev/5910538
def topological(graph):
    GRAY, BLACK = 0, 1
    order, enter, state = deque(), set(graph), {}
    def dfs(node):
        state[node] = GRAY
        for k in graph.get(node, ()):
            sk = state.get(k, None)
            if sk == GRAY: raise ValueError("cycle")
            if sk == BLACK: continue
            enter.discard(k)
            dfs(k)
        order.appendleft(node)
        state[node] = BLACK
    while enter: dfs(enter.pop())
    return order
# l1 to l2 -> line
# ls1 to ls2 -> line segment
def lineIntersect( l1, l2, ls1, ls2 ):
    l1x, l1y = l1
    l2x, l2y = l2
    ls1x, ls1y = ls1
    ls2x, ls2y = ls2
    if (((l1x - l2x) * (ls1y - l1y) + (l1y - l2y) * (l1x - ls1x)) *
        ((l1x - l2x) * (ls2y - l1y) + (l1y - l2y) * (l1x - ls2x)) > 0):
        return False
    return True
# p1 to p2 -> line segment
# p3 to p4 -> line segemnt
def intersect( p1, p2, p3, p4 ):
    if lineIntersect(p1, p2, p3, p4) and lineIntersect(p3, p4, p1, p2):
        return True
    return False

if __name__ == '__main__':
    Solver().run()
