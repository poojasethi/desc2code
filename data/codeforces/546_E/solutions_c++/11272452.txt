#include <cstdio>
#include <cstring>
#include <numeric>
#include <algorithm>

const int N = 200 + 10, E = N * N, INF = 1 << 25;

int n, m, a[N], b[N], ans[N][N];

int adj[N], s, t;
int to[E], next[E], cap[E], cnt = 2;

inline void Link(int a, int b, int c) {
  to[cnt] = b, next[cnt] = adj[a], cap[cnt] = c, adj[a] = cnt++;
  to[cnt] = a, next[cnt] = adj[b], cap[cnt] = 0, adj[b] = cnt++;
}

int h[N], gap[N];

int DFS(int a, int df) {
  if (a == t) return df;
  for (int it = adj[a]; it; it = next[it]) {
    int b = to[it];
    if (cap[it] && h[a] == h[b] + 1) {
      int f = DFS(b, std::min(df, cap[it]));
      cap[it] -= f;
      cap[it ^ 1] += f;
      return f;
    }
  }
  if (--gap[h[a]] == 0) h[s] = t + 1;
  ++gap[++h[a]];
  return 0;
}

int Flow() {
  memset(h, 0, sizeof h);
  memset(gap, 0, sizeof gap);
  int res = 0;
  while (h[s] < t) res += DFS(s, INF);
  return res;
}

int main() {
  scanf("%d%d", &n, &m);
  for (int i = 1; i <= n; ++i) scanf("%d", a + i);
  for (int i = 1; i <= n; ++i) scanf("%d", b + i);
  if (std::accumulate(a + 1, a + n + 1, 0) != std::accumulate(b + 1, b + n + 1, 0)) {
    puts("NO");
    return 0;
  }
  while (m--) {
    int p, q;
    scanf("%d%d", &p, &q);
    Link(p, q + n, INF);
    ans[p][q] = cnt - 1;
    Link(q, p + n, INF);
    ans[q][p] = cnt - 1;
  }
  s = n * 2 + 1, t = n * 2 + 2;
  for (int i = 1; i <= n; ++i) {
    Link(s, i, a[i]);
    Link(i, i + n, INF);
    ans[i][i] = cnt - 1;
    Link(i + n, t, b[i]);
  }
  if (Flow() == std::accumulate(b + 1, b + n + 1, 0)) {
    puts("YES");
    for (int i = 1; i <= n; ++i)
      for (int j = 1; j <= n; ++j)
        printf("%d%c", cap[ans[i][j]], j == n ? '\n' : ' ');
  } else {
    puts("NO");
  }
  return 0;
}

	  		 					 	 	   		 	   	  			