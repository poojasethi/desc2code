class Edge(object):
    def __init__(self, u, v, w, flow):
        self.source = u
        self.sink = v
        self.capacity = w
        self.flow = flow

class FlowNetwork(object):
    def __init__(self, verticies):
        self.adj = [list() for x in xrange(verticies)]

    def get_edges(self, v):
        return self.adj[v]

    def add_edge(self, u, v, w=0):
        edge = Edge(u,v,w,0)
        redge = Edge(v,u,0,0)
        edge.redge = redge
        redge.redge = edge
        self.adj[u].append(edge)
        self.adj[v].append(redge)
        
#     def find_path(self, source, sink, path):
#         if source == sink: return path
#         for edge in self.get_edges(source):
#             residual = edge.capacity - edge.flow
#             if residual > 0 and edge not in path:
#                 pathcopy = set(path)
#                 pathcopy.add(edge)
#                 result = self.find_path( edge.sink, sink, pathcopy)
#                 if result != None:
#                     return result
                
    def pathparent(self, source, sink, verticies):
        parents = {} 
        if self.path(-1, source, sink, parents):
            l = list()
            cur = sink
            while cur != source:
                l.append(parents[cur])
                cur = parents[cur].source
            return l
        return False
        
    def path(self, prev, cur, sink, parents):
        if (cur == sink): 
            return True
        for edge in self.get_edges(cur):
            if edge.sink != prev and edge.capacity - edge.flow > 0 and edge.sink not in parents:
                parents[edge.sink] = edge
                if self.path(edge.source, edge.sink, sink, parents): return True
        return False
                
        

#     def find_path(self, source, sink, path):
#         if source == sink: return path
#         for edge in self.get_edges(source):
#             residual = edge.capacity - edge.flow
#             if residual > 0 and edge not in path:
#                 pathcopy = set(path)
#                 pathcopy.add(edge)
#                 result = self.find_path( edge.sink, sink, pathcopy)
#                 if result != None:
#                     return result

    def max_flow(self, source, sink, verticies):
        path = self.pathparent(source, sink, verticies)
        while path:
            flow = 1000
            for edge in path: flow = min(flow, edge.capacity - edge.flow)
            for edge in path:
                edge.flow += flow
                edge.redge.flow -= flow
            path = self.pathparent(source, sink, verticies)
        return sum(edge.flow for edge in self.get_edges(source))

def solve():
    n, m = list(map(int, raw_input().split()))
    begin = list(map(int, raw_input().split()))
    end = list(map(int, raw_input().split()))
    fn = FlowNetwork(2*n+2)
    for i in xrange(n):
        fn.add_edge(i, i + n, begin[i])
        fn.add_edge(2*n, i, begin[i])
        fn.add_edge(i + n, 2 * n + 1, end[i])
    for i in xrange(m):
        p, q = list(map(int, raw_input().split()))
        p -= 1
        q -= 1
        fn.add_edge(p, q + n, begin[p])
        fn.add_edge(q, p + n, begin[q])
    maxflow = fn.max_flow(2*n, 2*n + 1, 2*n + 2)
    if maxflow != sum(begin) or sum(begin) != sum(end):
        print("NO")
    else:
        print("YES")
        res = [[0 for x in xrange(n)] for x in xrange(n)]
        for start in xrange(n):
            edgelist = fn.get_edges(start);
            for edge in edgelist:
                if edge.sink >= n and edge.sink < 2 *n:
                    res[edge.source][edge.sink-n] = edge.flow
        for i in xrange(n):
            print(" ".join(map(str, res[i])))


solve()