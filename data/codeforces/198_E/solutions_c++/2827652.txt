/*
Author: LJQ
PROG: Codeforces #125 Div1 E. Gripping Story
DATE: 2012.12.26
*/
#include <cstdio>
#include <cstring>
#include <queue>
#include <utility>
#include <algorithm>

using namespace std;

typedef long long LL;

const int maxn = 250005;

bool vis[maxn]; int num[maxn];
int p[maxn], mass[maxn]; LL dis2[maxn], r2[maxn];
int n, ns, ret, x0, y0;

void init()
{
	scanf("%d%d%d%I64d%d", &x0, &y0, &p[0], &r2[0], &n); r2[0] *= r2[0];
	LL x, y;
	for (int i = 1; i <= n; i ++){
		scanf("%I64d%I64d%d%d%I64d", &x, &y, &mass[i], &p[i], &r2[i]);
		r2[i] *= r2[i]; dis2[i] = (x - x0) * (x - x0) + (y - y0) * (y - y0);
	}
}

#define lowbit(x) ((x) & ((x) ^ ((x) - 1)))

priority_queue < pair <LL, int> > que[maxn];//fen_wick tree, every node is a heap
int stack[maxn];

void work()
{
	ns = 0;
	for (int i = 1; i <= n; i ++) num[++ ns] = mass[i];
	sort(num + 1, num + ns + 1);
	ns = unique(num + 1, num + ns + 1) - (num + 1);//lisanhua
	for (int i = 1; i <= n; i ++){//build_tree_heap
		int cur = lower_bound(num + 1, num + ns + 1, mass[i]) - num;
		for (int j = cur; j <= ns; j += lowbit(j))
			que[j].push(make_pair(-dis2[i], i));
	}
	ret = 0; stack[0] = 0; vis[0] = 1;
	for (int i = 0; i <= ret; i ++){
		int u = stack[i];
		int v = upper_bound(num + 1, num + ns + 1, p[u]) - num - 1;//limit
		for (int j = v; j; j -= lowbit(j))
			while (que[j].size() && -que[j].top().first <= r2[u]){//can be reached
				int w = que[j].top().second;
				if (!vis[w]) vis[w] = 1, stack[++ ret] = w;
				que[j].pop();
			}
	}
}

void print()
{
	printf("%d\n", ret);
}

int main()
{
	init();
	work();
	print();
	return 0;
}
