#include<cstdio>
#include<utility>
#include<queue>
#include<algorithm>
#define fo(i,a,b) for(i=a;i<=b;++i)
using namespace std;
const int mn=301000;
typedef long long LL;
struct node
{
    int v,k;
}now;
struct gripper
{
    LL d;
    int m,p,r;
}g[mn];
bool operator <(node a,node b){return a.v>b.v;}
priority_queue<node>Q[mn];
bool del[mn];
int n,m,i,j,k,L;
LL pos[mn];
int X,Y,P,R,p[mn],r[mn],st,ed,ans;
LL sqr(int v){return (long long)v*v;}
void add(int p,const node&v)
{
    for(;p<=L;p+=p&(-p))Q[p].push(v);
}
void upd(int x,int m)
{
    for(;x;x-=x&(-x))
        while(Q[x].size())
        {
            now=Q[x].top();
            if(now.v>m)break;
            Q[x].pop();
            if(!del[now.k])
            {
                ++ans,del[now.k]=1;
                ++ed,p[ed]=g[now.k].p,r[ed]=g[now.k].r;
            }
        }
}
int main()
{
    scanf("%d%d%d%d%d",&X,&Y,&P,&R,&n);
    fo(i,1,n)
    {
        scanf("%d%d%d%d%d",&j,&k,&g[i].m,&g[i].p,&g[i].r);
        pos[i]=g[i].d=sqr(j-X)+sqr(k-Y);
    }
    sort(pos+1,pos+1+n),L=unique(pos+1,pos+1+n)-pos-1;
    fo(i,1,n)
    {
        j=lower_bound(pos+1,pos+1+L,g[i].d)-pos;
        now.v=g[i].m,now.k=i;
        add(j,now);
    }
    st=ed=1,p[1]=P,r[1]=R;
    while(st<=ed)
    {
        P=p[st],R=upper_bound(pos+1,pos+1+L,sqr(r[st]))-pos-1;
        upd(R,P);
        ++st;
    }
    printf("%d\n",ans);
    return 0;
}