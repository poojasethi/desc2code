#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#define N 260000 // large scale N^2 fail
#define int64 long long
using namespace std;
struct ppp{
    int p,r;
}a[N];
int id[N],X,Y,P[N],M[N],x,y,i,j,n,bfs[N],flag[N],r,l,head[N],len,
    next[N*25],e[N*25];
int64 d[N];
bool cmp(const int a,const int b){
    return d[a]>d[b];//distance from large to low
}
int main(){
    scanf("%d%d%d%d%d",&X,&Y,&a[0].p,&a[0].r,&n);
    for(i=1;i<=n;++i){
        scanf("%d%d%d%d%d",&x,&y,&M[i],&a[i].p,&a[i].r);
        d[i]=(int64)(X-x)*(X-x)+(int64)(Y-y)*(Y-y);//distance^2 from now
        id[i]=i;
        P[i]=M[i];//store mass
    }
    sort(id+1,id+n+1,cmp);
    sort(P+1,P+n+1);
    for(i=1;i<=n;++i){
        x=id[i];//the id which has largest mass being the first one
        j=lower_bound(P+1,P+n+1,M[x])-P;//find mass that reachable
        for(;j<=n;j+=j&(-j)){
            next[++len]=head[j];//build graph
            head[j]=len;//link from a larger mass to all lower
            e[len]=x;
        }
    }
    bfs[l=r=1]=0;
    while(l<=r){
        x=bfs[l++];
        j=upper_bound(P+1,P+n+1,a[x].p)-P-1;//所有小於等於
        for(;j;j-=j&(-j)){
            while(head[j] && d[y=e[head[j]]]<=(int64)a[x].r*a[x].r){//note dis^2 is ordered 
                if(!flag[y]){
                    bfs[++r]=y;
                    flag[y]=1;
                }
                head[j]=next[head[j]];//***** delete those treated in adjacent edge list
            }
        }
    }
    printf("%d\n",r-1);//the initial one no need to count
}
