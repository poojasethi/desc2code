#include <cstdio>
#include <algorithm>
using namespace std;
#define rep(i,n) for (int i=0;i<n;i++)
struct G{long long d,r;int m,p;}p[251000];
long long X,Y;int q[251000],c[1001000],n,M,t,x,y;
bool operator<(const G&a,const G&b) {return a.d<b.d;}
#define upd(a,b) if (p[a].m>p[b].m) a=b;
int query(int x){int s=0;for(int l=M,r=x+M+1;l^r^1;l>>=1,r>>=1){if(~l&1) upd(s,c[l^1]);if(r&1) upd(s,c[r^1]);}return s;}
void modify(int x,int v){for(p[x].m=v,(x+=M)>>=1;x;x>>=1){c[x]=c[x+x];upd(c[x],c[x+x+1]);}}
int main() {
	scanf("%d%d%d%d%d",&x,&y,&p[0].p,&p[0].r,&n);p[0].m=2000000001;
	rep(i,n) {
		scanf("%I64d%I64d%d%d%d",&X,&Y,&p[i+1].m,&p[i+1].p,&p[i+1].r);
		p[i+1].d=(X-x)*(X-x)+(Y-y)*(Y-y);
	}
	rep(i,n+1) p[i].r*=p[i].r;sort(p,p+n+1);
	for(M=1;M<=n+1;M*=2);for (int i=M;i<=M+n;i++) c[i]=i-M;
	rep(i,n) modify(i+1,p[i+1].m);
	q[0]=0;t=1;
	rep(i,t) {
		G tmp=p[q[i]];tmp.d=tmp.r;
		int l=upper_bound(p,p+n+1,tmp)-p-1;
		while (1) {
			int d=query(l);
			if (p[d].m<=p[q[i]].p) modify(d,2000000000),q[t++]=d;
				else break;
		}
	}
	printf("%d\n",t-1);
}