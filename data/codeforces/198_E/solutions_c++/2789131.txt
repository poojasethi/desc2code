#include <cstdio>
#include <cstring>
#include <algorithm>
#include <set>
using namespace std;

const int maxn = 500001;

typedef long long i64;

i64 n;
i64 bak,top;
i64 vis[maxn],list[maxn],D[maxn],pos[maxn],M[maxn],P[maxn],R[maxn];

struct cmq
{
    bool operator () (const i64 &a,const i64 &b) const 
        {
            return D[a] < D[b];
        }
};

multiset < i64 , cmq > cnt[maxn];

void solve(i64 x,i64 y)
{
    set < i64 >::iterator it;
    for (; x; x -= x & -x)
    {
        for (it = cnt[x].begin(); it != cnt[x].end(); ++it)
            if (!vis[*it]) 
                if (D[*it] <= y) vis[list[++top] = (*it)] = true;
                else break;
        cnt[x].erase(cnt[x].begin(),it);
    }
}

i64 bound(i64 x)
{
    i64 l,r,mid;
    if (M[pos[n]] <= x) return n;
    for (l = 1,r = n; l < r; )
    {
        mid = (l+r) >> 1;
        if (M[pos[mid]] <= x) l = mid+1;
        else r = mid;
    }
    return l-1;
}
i64 cmp(i64 a,i64 b){return M[a] < M[b];}

int main()
{
    i64 Ox,Oy;
    i64 i,j,x,y;

    scanf("%I64d %I64d %I64d %I64d %I64d\n",&Ox,&Oy,&P[0],&R[0],&n);
    R[0] *= R[0];
    for (i = 1; i <= n; ++i)
    {
        scanf("%I64d %I64d %I64d %I64d %I64d\n",&x,&y,&M[i],&P[i],&R[i]);
        R[i] *= R[i];
        x -= Ox,y -= Oy;
        D[i] = x*x+y*y;
        pos[i] = i;
    }

    sort(pos+1,pos+n+1,cmp);
    for (i = 1; i <= n; ++i)
        for (j = i; j <= n; j += j & -j)
            cnt[j].insert(pos[i]);
    for (list[bak = top = 1] = 0; bak <= top; ++bak)
        solve(bound(P[list[bak]]),R[list[bak]]);
    printf("%I64d",top-1);

    return 0;
}
