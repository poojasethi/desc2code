#include <cstdio>
#include <queue>
#include <algorithm>

typedef long long LL;

using namespace std;

const int maxn = 250010;
int n, x0, y0, x, y, p, m, r, ans, disc[maxn * 2], cnt;
bool del[maxn];
struct magnet{int m, p; LL d, r;} mag[maxn], tmp;
queue<magnet> Q;
priority_queue<pair<LL, int> > T[maxn * 2];

int main(){
	scanf("%d%d%d%d%d", &x0, &y0, &p, &r, &n);
	tmp.p = p; tmp.r = (LL)r * r; disc[cnt++] = p;
	for (int i = 0; i < n; i++){
		scanf("%d%d%d%d%d", &x, &y, &m, &p, &r); x -= x0; y -= y0;
		mag[i].m = m; mag[i].p = p; mag[i].r = (LL)r * r;
		mag[i].d = (LL)x * x + (LL)y * y;
		disc[cnt++] = p; disc[cnt++] = m;
	}
	sort(disc, disc + cnt);
	tmp.p = lower_bound(disc, disc + cnt, tmp.p) - disc + 1; Q.push(tmp);
	for (int i = 0; i < n; i++)
		mag[i].p = lower_bound(disc, disc + cnt, mag[i].p) - disc + 1,
		mag[i].m = lower_bound(disc, disc + cnt, mag[i].m) - disc + 1;
	for (int i = 0; i < n; i++)
		for (int p = mag[i].m; p <= cnt; p += p & -p)
			T[p].push(make_pair(-mag[i].d, i));

	while (!Q.empty()){
		tmp = Q.front(); Q.pop();
		while (true){
			pair<LL, int> S(-3e18, 0);
			for (int p = tmp.p; p; p -= p & -p){
				while (T[p].size() > 0 && del[T[p].top().second]) T[p].pop();
				if (T[p].size() > 0) S = max(S, T[p].top());
			}
			if (-S.first <= tmp.r){
				ans++; Q.push(mag[S.second]);
				del[S.second] = true;
			} else break;
		}
	}
	printf("%d", ans);
}
