#include<cstdio>
#include<queue>
#include<algorithm>
#include<cstring>
#include<iostream>;
using namespace std;
typedef long long LL;
const int maxn = 250010;
int n,x0,y0,x,y,p,m,r,ans,dis[maxn*2],cnt;
bool del[maxn];
struct magnet{
    int m,p;
    LL d,r;
}   mag[maxn],tmp;
queue<magnet> Q;
priority_queue<pair<LL, int> > T[maxn*2];
int main(){
    //freopen("AC.in","r",stdin);
    //freopen("AC.out","w",stdout);
	scanf("%d%d%d%d%d", &x0, &y0, &p, &r, &n);
	tmp.p=p;tmp.r=(LL)r*r;dis[cnt++]=p;
	for (int i = 0; i < n; i++){
		scanf("%d%d%d%d%d",&x,&y,&m,&p,&r);
        x-=x0;y-=y0;
		mag[i].m=m; mag[i].p=p; 
        mag[i].r=(LL)r *r;
		mag[i].d=(LL)x*x+(LL)y*y;
		dis[cnt++]=p;
        dis[cnt++]=m;
	}
	sort(dis,dis+cnt);
	tmp.p=lower_bound(dis,dis+cnt,tmp.p)-dis+1;
    Q.push(tmp);
	for (int i = 0; i < n; i++)
		mag[i].p = lower_bound(dis, dis + cnt, mag[i].p) - dis + 1,
		mag[i].m = lower_bound(dis, dis + cnt, mag[i].m) - dis + 1;
	for (int i = 0; i < n; i++)
		for (int p = mag[i].m; p <= cnt; p += p & -p)
			T[p].push(make_pair(-mag[i].d, i));

	while (!Q.empty()){
		tmp = Q.front(); Q.pop();
		while (true){
			pair<LL, int> S(-3e18, 0);
			for (int p = tmp.p; p; p -= p & -p){
				while (T[p].size() > 0 && del[T[p].top().second]) T[p].pop();
				if (T[p].size() > 0) S = max(S, T[p].top());
			}
			if (-S.first <= tmp.r){
				ans++; Q.push(mag[S.second]);
				del[S.second] = true;
			} else break;
		}
	}
	printf("%d", ans);
	return 0;
}
