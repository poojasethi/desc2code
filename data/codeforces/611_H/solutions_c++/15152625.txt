#include <cstdlib>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <queue>
#include <cmath>
#include <stack>
#include <map>
#include <set>
#include <deque>
#include <cstring>
#include <functional>
#include <climits>
#include <list>
#include <ctime>
#include <complex>
 
#define F1(x,y,z) for(int x=y;x<z;x++)
#define F2(x,y,z) for(int x=y;x<=z;x++)
#define F3(x,y,z) for(int x=y;x>z;x--)
#define F4(x,y,z) for(int x=y;x>=z;x--)
#define pb push_back
#define LL long long
#define co complex<double>
 
#define MAX 100005
#define AMAX 1500
#define MOD ((LL)1000000007)

#define f(c,d) ((1<<(c))*(d))

using namespace std;

int n,m,ta,tb,tc,td,cnt[10][10],ct[10][10],i[10],d[105],ss,tt,tot,st[]={1,10,100,1000,10000,100000},si[]={9,90,900,9000,90000,900000};
char x[30];
bool used[10];
vector<int> te;
vector<pair<int,int> > edd;
vector<int> ed[105],to,l;
vector<pair<int,pair<int,int> > > ii;
queue<int> q;

bool bfs(){
    F1(a,0,tot)d[a]=-1;
    d[ss]=0;
    q=queue<int>();
    q.push(ss);
    while(!q.empty()){
		F1(a,0,ed[q.front()].size())if(d[to[ed[q.front()][a]]]==-1&&l[ed[q.front()][a]]){
			d[to[ed[q.front()][a]]]=d[q.front()]+1;
			if(to[ed[q.front()][a]]==tt)return 1;
			q.push(to[ed[q.front()][a]]);
		}
        q.pop();
    }
    return 0;
}

int dfs(int a,int b){
    if(a==tt)return b;
    int re=0,tx;
	F1(c,0,ed[a].size())if(d[to[ed[a][c]]]==d[a]+1&&l[ed[a][c]]){
		tx=dfs(to[ed[a][c]],min(b,l[ed[a][c]]));
		b-=tx;
		l[ed[a][c]]-=tx;
		l[ed[a][c]^1]+=tx;
		re+=tx;
		if(!b)return re;
	}
    return re;
}

void add(int a,int b,int c){
	ed[a].pb(to.size());
	to.pb(b);
	l.pb(c);
	ed[b].pb(to.size());
	to.pb(a);
	l.pb(0);
}

bool go(vector<int> a){
	if(edd.size()==m-1){
		F1(b,0,m){
			F1(c,b,m)ct[b][c]=cnt[b][c];
			i[b]=si[b]-1;
		}
		F1(b,0,edd.size()){
			if(ct[edd[b].first][edd[b].second])ct[edd[b].first][edd[b].second]--;
			else return 0;
		}
		ta=tb=0;
		F1(b,0,m){
			i[b]-=ct[b][b];
			if(i[b]<0)return 0;
			ta+=i[b];
		}
		F1(b,0,m)F1(c,b+1,m)tb+=ct[b][c];
		if(ta!=tb)return 0;		
		tot=m*(m+1)/2+2;
		ss=tot-2;
		tt=tot-1;
		F1(b,0,tot)ed[b].clear();
		to.clear();
		l.clear();
		ii.clear();
		F1(b,0,m)if(i[b])add(ss,b,i[b]);
		tb=m;
		F1(b,0,m)F1(c,b+1,m)if(ct[b][c]){
			ii.pb(make_pair(to.size(),make_pair(b,c)));
			add(b,tb,ct[b][c]);
			add(c,tb,ct[b][c]);
			add(tb,tt,ct[b][c]);
			tb++;
		}
		while(bfs())ta-=dfs(ss,INT_MAX);
		if(ta!=0)return 0;
		F1(b,0,edd.size())printf("%d %d\n",st[edd[b].first],st[edd[b].second]);		
		tb=m;
		F1(b,0,m)F1(c,0,ct[b][b]){
			si[b]--;
			printf("%d %d\n",st[b],st[b]+si[b]);
		}
		F1(b,0,ii.size()){
			tb=l[ii[b].first+1];
			tc=ii[b].second.first;
			td=ii[b].second.second;
			F1(c,0,tb){
				si[tc]--;
				printf("%d %d\n",st[td],st[tc]+si[tc]);
			}
			tb=l[ii[b].first+3];
			F1(c,0,tb){
				si[td]--;
				printf("%d %d\n",st[tc],st[td]+si[td]);
			}
		}
		return 1;
	}
	vector<int> b;
	b.clear();
	F1(c,0,a.size()){
		b.pb(a[c]);
		F1(d,(c==a.size()-1?0:a[c+1]),m)if(!used[d]){
			used[d]=1;
			b.pb(d);
			edd.pb(make_pair(min(a[c],d),max(a[c],d)));
			if(go(b))return 1;
			edd.pop_back();
			b.pop_back();
			used[d]=0;
		}
	}
	return 0;
}

int main(){
	used[0]=1;
	scanf("%d\n",&n);
	F1(a,0,6)if(n>=st[a])m++;
	si[m-1]=n-st[m-1]+1;
	//F1(a,0,m)printf("%d %d\n",st[a],si[a]);
	F1(a,1,n){
		ta=tb=tc=td=0;
		gets(x);
		while(x[ta]){
			if(x[ta]==' ')tb=ta;
			else if(tb)td++;
			else tc++;
			x[ta]=0;
			ta++;
		}
		if(tc>td)swap(tc,td);
		cnt[tc-1][td-1]++;
		//printf("%d %d\n",tc,td);
	}
	te.pb(0);
	if(!go(te))printf("-1\n");
	//system("pause");
	return 0;
}
