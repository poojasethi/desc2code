#include <iostream>
#include <iomanip>
#include <climits>
#include <stack>
#include <fstream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <string>
#include <vector>
#include <deque>
#include <queue>
#include <set>
#include <map>
#include <cassert>

#define FOR(i,n) for(int i=0,_n=n;i<_n;i++)
#define FORR(i,s,n) for(int i=s,_n=n;i<_n;i++)
#define mp make_pair
#define pb push_back
#define pii pair<int,int>
#define pli pair<ll,int>
#define vi vector<int>
#define fs first
#define sec second

#define maxn 200000

using namespace std;
typedef long long ll;

const ll MOD = 1000000007LL;

int n,sg;
int se[8][8];
int e[8][8];
vi grp[8];
int sefe[8];
char s1[8],s2[8];
vector <vector<pii> > trees;
vector <pii> tree;
int vis[8];

int lg(int st){
	int rt;
	for(rt=0;st;st/=10,rt++);
	return rt;
}

void dfs(int pz){
	vis[pz]=1;
	FOR(i,tree.size()){
		if(tree[i].fs==pz && !vis[tree[i].sec])dfs(tree[i].sec);
		if(tree[i].sec==pz && !vis[tree[i].fs])dfs(tree[i].fs);
	}
}

bool legit(){
	memset(vis,0,sizeof(vis));
	dfs(1);
	FORR(i,1,sg+1)if(!vis[i])return 0;
	return 1;
}

void gen_trees(){
	vector <pii> edge;
	FORR(i,1,sg+1)FORR(j,1,i)edge.pb(mp(j,i));
	FOR(i,(1<<edge.size()))if(__builtin_popcount(i)==sg-1){
		tree.clear();
		FOR(j,edge.size())
			if(i&(1<<j))tree.pb(edge[j]);
		if(legit())trees.pb(tree);
	}
}

bool dobar(){
	FOR(i,(1<<sg)){
		vi totry;
		FOR(j,sg)if(i&(1<<j))totry.pb(j+1);
		int stv=0,ste=0;
		FOR(j,totry.size())stv+=grp[totry[j]].size()-1;
		FOR(j,totry.size())FOR(k,totry.size())ste+=e[totry[j]][totry[k]];
		if(ste>stv)return 0;
	}
	return 1;
}

bool moze(int t){
	FOR(i,trees[t].size()){
		if(e[trees[t][i].fs][trees[t][i].sec]==0)return 0;
		e[trees[t][i].fs][trees[t][i].sec]--;
	}
	if(!dobar())return 0;
	FOR(i,trees[t].size())printf("%d %d\n",sefe[trees[t][i].fs],sefe[trees[t][i].sec]);
	FORR(i,1,sg+1)FORR(j,1,sg+1)while(e[i][j]){
		e[i][j]--;
		if(grp[i].size()>1){
			int zadnji=grp[i].back();
			grp[i].pop_back();
			if(dobar()){
				printf("%d %d\n",zadnji,sefe[j]);
				continue;
			}
			grp[i].pb(zadnji);
		}
		printf("%d %d\n",sefe[i],grp[j].back());
		grp[j].pop_back();
	}
	return 1;
}

int main(){
	scanf("%d",&n);
	FORR(i,1,n+1)grp[lg(i)].pb(i);
	memset(se,0,sizeof(se));
	FOR(i,n-1){
		scanf("%s",s1);
		scanf("%s",s2);
		int a1=strlen(s1),a2=strlen(s2);
		if(a1>a2)swap(a1,a2);
		se[a1][a2]++;
	}
	sg=lg(n);
	gen_trees();
	FORR(i,1,sg+1)sefe[i]=grp[i][0];
	FOR(i,trees.size()){
		FOR(j,sg+1)FOR(k,sg+1)e[j][k]=se[j][k];
		if(moze(i))return 0;
	}
	printf("-1\n");
	return 0;
}
