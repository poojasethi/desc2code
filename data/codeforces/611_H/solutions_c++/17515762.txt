#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <utility>
#include <cstring>
#include <bitset>
#include <string>
#include <vector>
#include <queue>
#include <map>
#include <set>
using namespace std;

typedef double db;
typedef long long LL;
typedef pair< int, int > PII;
typedef pair< LL, LL > PLL;
typedef pair< db, db > PDD;

const db dInf = 1E90;
const LL lInf = ( LL ) 1E16;
const int Inf = 0x23333333;
const int N = 200005, M = 7;

#define it iterator
#define rbg rbegin()
#define ren rend()
#define fdi( i, x ) for ( typeof( x.rbg ) i=x.rbg; i!=x.ren; ++i )
#define foi( i, x ) for ( typeof( x.begin() ) i=x.begin(); i!=x.end(); ++i )
#define fd( i, y, x ) for ( int i=( y )-1, LIM=x; i>=LIM; --i )
#define fo( i, x, y ) for ( int i=x, LIM=y; i<LIM; ++i )
#define mkp( A, B ) make_pair( A, B )
#define pub( x ) push_back( x )
#define pob( x ) pop_back( x )
#define puf( x ) push_front( x )
#define pof( x ) pop_front( x )
#define fi first
#define se second

vector < int > all[M];
vector < PII > f[M][M];
int w[M][M], sz[M];
int n, m;
PII e[N];

bool chk()
{
	fo ( i, 0, m ) if ( !sz[i] )
		fo ( j, 0, m ) if ( w[i][j] ) return 1;
	fo ( S, 1, ( 1<<m ) )
	{
		int node = 0, edge = 0;
		for ( int temp=S; temp; temp-=( temp & -temp ) )
		{
			int i = __builtin_ctz( temp & -temp );
			node += sz[i];
			for ( int T1=S; T1; T1-=( T1 & -T1 ) )
			{
				int j = __builtin_ctz( T1 & -T1 );
				if ( j>i ) break;
				edge += w[i][j];
			}
		}
		if ( node && node<=edge ) return 1;
	}
	return 0;
}

void preprocessing()
{
	scanf( "%d", &n );
	fo ( i, 0, n )
	{
		int x = i + 1, temp = x, ws = -1;
		do
		{
			++ws, temp /= 10;
		} while ( temp );
		all[ws].pub( x ), m = max( m, ws+1 );
	}
	fo ( i, 0, m ) sz[i] = all[i].size();
	char s[10], s1[10];
	fo ( i, 1, n )
	{
		scanf( "%s", s ), scanf( "%s", s1 );
		int x = strlen( s ) - 1, y = strlen( s1 ) - 1;
		++w[x][y], e[i] = mkp( x, y );
		if ( x!=y ) ++w[y][x];
	}
}

void solve()
{
	if ( chk() ) { printf( "-1" ); return; }
	fo ( Case, 1, n )
	{
		bool done = 0;
		fo ( i, 0, m ) 
		{
			fo ( j, 0, m ) if ( w[i][j] )
			{
				--w[i][j], --sz[i]; 
				if ( i!=j ) --w[j][i];
				if ( !chk() ) 
				{
					f[ min( i, j ) ][ max( i, j ) ].pub( mkp( all[i].back(), all[j][0] ) );
					all[i].pop_back(), done = 1; break;
				}
				++w[i][j], ++sz[i];
				if ( i!=j ) ++w[j][i];
			}
			if ( done ) break;
		}
		if ( !done ) break;
	}
	fo ( i, 1, n )
	{
		PII temp;
		if ( e[i].fi > e[i].se ) temp = f[ e[i].se ][ e[i].fi ].back();
		else temp = f[ e[i].fi ][ e[i].se ].back();
		if ( temp.fi > temp.se ) swap( temp.fi, temp.se );
		if ( e[i].fi > e[i].se ) printf( "%d %d\n", temp.se, temp.fi );
		else printf( "%d %d\n", temp.fi, temp.se );
		if ( e[i].fi > e[i].se ) f[ e[i].se ][ e[i].fi ].pop_back();
		else f[ e[i].fi ][ e[i].se ].pop_back();
	}
}

int main()
{
	/*freopen( "tree.in", "r", stdin );
	freopen( "tree.out", "w", stdout );*/

	preprocessing();
	solve();

	//fclose( stdin ), fclose( stdout );
	return 0;
}

