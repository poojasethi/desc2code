#include<stdio.h>
#include<algorithm>
#include<cstring>
#include<vector>
#define pb push_back
#define mk make_pair
#define N 400005
#define M 105
using namespace std;
typedef pair<int,int> Pair;
vector<Pair>ans[10][10];
char s1[105],s2[105];
int rest[M],p[M],q[M],cnt[M][M],F[M],A[M],B[M],ch[M],now[M];
int u[N],v[N],_,n,i,j,len,t,m;
struct MaxFlow{
	#define V 205
	#define E 10005
	int End[V],Go[E],Next[E],Value[E],f[V],Q[V];
	int S,T,cnt;
	MaxFlow(){cnt=1;}
	void add(int u,int v,int w){
		Go[++cnt]=v;Next[cnt]=End[u];Value[cnt]=w;End[u]=cnt;
		Go[++cnt]=u;Next[cnt]=End[v];Value[cnt]=0;End[v]=cnt;
  }
	int bfs(){
		for (int i=1;i<=T;i++) f[i]=-1;
		int h=0,t=1;Q[1]=S;f[S]=0;
		while (h<t){
			int x=Q[++h];if (x==T) return 1;
			for (int i=End[x],y;i;i=Next[i])
				if (f[y=Go[i]]==-1&&Value[i])
					f[y]=f[x]+1,Q[++t]=y;
		}return 0;
  }
  int dinic(int x,int sum){
  	if (x==T) return sum;int os=sum;
  	for (int i=End[x],y;i&&os;i=Next[i])
  		if (f[y=Go[i]]==f[x]+1&&Value[i]){
  			int now=dinic(y,min(os,Value[i]));
  			Value[i]-=now;Value[i^1]+=now;os-=now;
  		}
  	if (sum==os) f[x]=-1;return sum-os;
  }
  void Clear(){
  	for (int i=1;i<=T;i++) End[i]=0;cnt=1;
  }
}G;
int bit(int x){int s=0;for (;x;x/=10) s++;return s;}
void solve(){
	for (int i=1;i<=m;i++)
		if (ch[i]) cnt[A[i]][B[i]]--;
	G.S=m+_+1;G.T=G.S+1;
	for (int i=1;i<=m;i++){
		G.add(G.S,i,cnt[A[i]][B[i]]);
		G.add(i,m+A[i],cnt[A[i]][B[i]]);
		G.add(i,m+B[i],cnt[A[i]][B[i]]);
  }int need=0,sum=0;
	for (int i=1;i<=_;i++)
		G.add(m+i,G.T,rest[i]),need+=rest[i];
	while (G.bfs())
		sum+=G.dinic(G.S,1e9);
	if (sum<need){
	  for (int i=1;i<=m;i++)
		  if (ch[i]) cnt[A[i]][B[i]]++;
	  G.Clear();return;
  }for (int i=1;i<=m;i++)
  	if (ch[i]) ans[A[i]][B[i]].pb(mk(p[A[i]],p[B[i]]));
  for (int i=1;i<=_;i++) now[i]=p[i];
  for (int i=1;i<=m;i++){
  	for (int j=G.End[i];j;j=G.Next[j]){
  		int x=G.Go[j];
  		if (x==G.S) continue;x-=m;
  		int v=cnt[A[i]][B[i]]-G.Value[j];
  		while (v--)
				ans[A[i]][B[i]].pb(mk(++now[x],p[A[i]==x?B[i]:A[i]]));
    }
  }
  for (int i=1;i<=_;i++) now[i]=q[i]-cnt[i][i];
  for (int i=1;i<n;i++){
  	int x=u[i],y=v[i];
  	if (x==y) {printf("%d %d\n",p[x],++now[x]);continue;}
  	if (x>y) swap(x,y);
  	int ansx=ans[x][y].back().first;
  	int ansy=ans[x][y].back().second;
  	ans[x][y].pop_back();
  	if (bit(ansx)!=u[i]) swap(ansx,ansy);
  	printf("%d %d\n",ansx,ansy);
  }exit(0);
}
int get(int u){return F[u]==u?u:F[u]=get(F[u]);}
void DFS(int x){
	if (x>m){
		for (int i=1;i<=_;i++) F[i]=i;
		for (int i=1;i<=m;i++)
			if (ch[i]){
				int x=get(A[i]),y=get(B[i]);
				if (x==y||cnt[A[i]][B[i]]==0) return;F[x]=y;
		  }
		for (int i=2;i<=_;i++)
			if (get(i)!=get(1)) return;
		solve();return;
  }ch[x]=1;DFS(x+1);
  ch[x]=0;DFS(x+1);
}
int main(){
	scanf("%d",&n);
	for (i=1;i<n;i++){
		scanf("%s%s",&s1,&s2);
		u[i]=strlen(s1);v[i]=strlen(s2);
		len=max(len,u[i]);
		len=max(len,v[i]);
  }for (t=1;t<=n;t*=10) p[++_]=t,q[_]=t*10-1;
  q[_]=min(q[_],n);
  if (len>_) return puts("-1"),0;
	for (i=1;i<n;i++)
		cnt[min(u[i],v[i])][max(u[i],v[i])]++;
	for (i=1;i<_;i++)
		for (j=i+1;j<=_;j++)
			A[++m]=i,B[m]=j;
	for (i=1;i<=_;i++) 
		if ((rest[i]=q[i]-p[i]-cnt[i][i])<0) return puts("-1"),0;
	DFS(1);puts("-1");
}