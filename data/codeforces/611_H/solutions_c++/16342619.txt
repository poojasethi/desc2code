#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>

using namespace std;

#ifdef WIN32
	#define LL "%I64d"
#else
	#define LL "%lld"
#endif

#ifdef Lightning
	#define debug(...) printf(__VA_ARGS__)
	const int DEBUG_FLAG = 1;
#else
	#define debug(...)
	const int DEBUG_FLAG = 0;
#endif

#define DEBUG if (DEBUG_FLAG)
#define NDEBUG if (!DEBUG_FLAG)
#define print(__l) (DEBUG_FLAG ? printf(#__l" = "LL"\n", 1ll*(__l)) : 0)
#define eprint(...) fprintf(stderr, __VA_ARGS__)

#define IO_Able if (0)
#define OpenFile(NAME) freopen(NAME".in", "r", stdin), freopen(NAME".out", "w", stdout)
#define CloseFile() fclose(stdin), fclose(stdout)

#define reg register int
#define regll register long long
#define FOR(_i, _sta, _end) for (reg _i = (_sta), __end = (_end) + 1; _i < __end; ++_i)
#define REP(_i, _sta, _end) for (reg _i = (_sta), __end = (_end) - 1; _i > __end; --_i)
#define FORBY(_i, _sta, _end, _by) for (reg _i = (_sta), __end = (_end) + 1; _i < __end; _i += (_by))
#define REPBY(_i, _sta, _end, _by) for (reg _i = (_sta), __end = (_end) - 1; _i > __end; _i -= (_by))
#define JUMP(_i, _sta, _jump) for (reg _i = (_sta); _i > 0; _i = _jump[_i])

#define mset(_a, _b, _c) memset(_a, _b, ((_c) + 3) * sizeof(_a[0]))

#define gmax(_a, _b) ((_a) > (_b) ? (_a) : (_b))
#define gmin(_a, _b) ((_a) < (_b) ? (_a) : (_b))
#define cmax(_a, _b) (_a < (_b) ? _a = (_b) : 0)
#define cmin(_a, _b) (_a > (_b) ? _a = (_b) : 0)
#define positive(_a, _b) ((_a) < (_b) ? (_b) - (_a) : (_a) - (_b))

inline int read()
{
	register int aa, bb, ch;
	while (ch = getchar(), (ch < '0' || ch > '9') && ch != '-');
	ch == '-' ? (aa = 0, bb = 1) : (aa = ch - '0', bb = 0);
	while (ch = getchar(), ch >= '0' && ch <= '9')
		aa = (aa << 3) + (aa << 1) + ch - '0';
	return bb ? -aa : aa;
}

const int N = 500;
const int M = 1000;
const int inf = 1845794933;

namespace MAXFLOW
{
	int to[M], pre[M], flow[M], last[N], en = 1;
	int cur[N], dis[N], gap[N], sta, end;

	void clear()
	{
		memset(last, 0, sizeof last);
		en = 1;
	}

	inline void addedge(reg f, reg t, reg fl)
	{
		to[++en] = t;
		flow[en] = fl;
		pre[en] = last[f];
		last[f] = en;
		if (!(en & 1)) addedge(t, f, 0);
	}

	int sap(reg now, reg fl)
	{
		if (now == end) return fl;
		reg ret = 0, tmp, bak = last[now];
		JUMP (i, cur[now], pre)
		{
			cur[now] = i;
			if (flow[i] && dis[now] == dis[to[i]] + 1 && to[i] <= end)
			{
				tmp = sap(to[i], gmin(fl - ret, flow[i]));
				flow[i] -= tmp;
				flow[i ^ 1] += tmp;
				ret += tmp;
				if (ret == fl) return ret;
			}
		}
		cur[now] = bak;
		if (--gap[dis[now]] == 0) dis[sta] = end + 1;
		++gap[++dis[now]];
		return ret;
	}

	int maxflow(reg _s, reg _t)
	{
		sta = _s;
		end = _t;
		reg fl = 0;
		memset(gap, 0, sizeof gap);
		memset(dis, 0, sizeof dis);
		FOR (i, 1, end) cur[i] = last[i];
		gap[0] = end;
		while (dis[sta] <= end) fl += sap(sta, inf);
		return fl;
	}

}

namespace LightningWork
{
	// My Space

	using namespace MAXFLOW;

	int n, m, cnt[10][10], F[10], G[50], End;
	int star[7] = {0, 1, 10, 100, 1000, 10000, 100000};
	int tot[7] = {0, 1, 10, 100, 1000, 10000, 100000};
	int e[10][2], etot;

	char str[10];

	bool solve()
	{
		// debug("\n\n\n");
		clear();
		reg t = 0, sum = 0, S, T;
		FOR (i, 1, m)
		{
			FOR (j, i, m)
			{
				if (cnt[i][j])
				{
					G[++t] = cnt[i][j];
					addedge(m + t, i, cnt[i][j]);
					addedge(m + t, j, cnt[i][j]);
					// debug("%d %d - %d\n", i, j, cnt[i][j]);
				}
			}
		}
		S = m + t + 1;
		T = S + 1;
		FOR (i, 1, m)
		{
			addedge(i, T, F[i]);
			sum += F[i];
		}
		FOR (i, 1, t)
		{
			addedge(S, m + i, G[i]);
		}
		reg mf = maxflow(S, T);
		if (mf == sum)
		{
			FOR (i, 1, etot)
			{
				printf("%d %d\n", e[i][0], e[i][1]);
			}
			FOR (i, 1, t)
			{
				reg a = 0, b = 0, as = 0, bs = 0;
				JUMP (e, last[i + m], pre)
				{
					if (to[e] >= 1 && to[e] <= m)
					{
						if (a == 0)
						{
							a = to[e];
							as = flow[e ^ 1];
						} else
						{
							b = to[e];
							bs = flow[e ^ 1];
						}
					}
				}
				// debug("a : %d(%d) b : %d(%d)\n", a, as, b, bs);
				FOR (i, 1, as)
				{
					printf("%d %d\n", star[b], ++tot[a]);
				}
				FOR (j, 1, bs)
				{
					printf("%d %d\n", star[a], ++tot[b]);
				}
			}
			return true;
		}
		return false;
	}

	bool dfs(reg now)
	{
		if (now == End)
		{
			return solve();
		}
		FOR (i, 1, m)
		{
			if (now & (1 << (i - 1)))
			{
				FOR  (j, 1, m)
				{
					if (now & (1 << (j - 1)))
						continue;
					reg i2 = gmin(i, j), j2 = gmax(i, j);
					if (cnt[i2][j2])
					{
						--cnt[i2][j2];
						++etot;
						e[etot][0] = star[i];
						e[etot][1] = star[j];
						if (dfs(now | (1 << (j - 1))))
							return 1;
						--etot;
						++cnt[i2][j2];
					}
				}
			}
		}
		return 0;
	}

	void Main()
	{
		reg t = 1;
		n = read();
		while (n >= t)
		{
			End |= 1 << m;
			F[++m] = gmin(t * 10, n + 1) - t - 1;
			t = t * 10;
		}
		FOR (i, 1, n - 1)
		{
			scanf("%s", str);
			reg a = strlen(str);
			scanf("%s", str);
			reg b = strlen(str);
			if (a > b)
			{
				reg tmp = a;
				a = b;
				b = tmp;
			}
			++cnt[a][b];
		}
		if (dfs(1) == 0)
		{
			puts("-1");
		}
	}
}

int main()
{
	IO_Able OpenFile("drive");
	LightningWork::Main();
	IO_Able CloseFile();
	return 0;
}
