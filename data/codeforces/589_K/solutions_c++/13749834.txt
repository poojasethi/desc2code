#include <stdio.h>
#include <vector>
#include <algorithm>
#include <math.h>
#include <deque>
#define lli long long int
#define pb push_back
#define MAXN 100005
#define MAX_VAL 100005
#define INF 1e50
using namespace std;

struct task {
    int l;
    int idx;

    task() {}
    task(int l, int idx):l(l), idx(idx) {}
};

vector <task> v[MAXN];
lli r[MAXN];
deque <task> dq[MAXN];

bool comp (const task &a, const task &b) {
    return a.l < b.l || a.l == b.l && a.idx < b.idx;
}

int main(void) {
    int n;
    int l, t;

    scanf(" %d", &n);
    for (int i = 0; i < n; i++) {
        scanf(" %d %d", &l, &t);
        v[t].pb(task(l, i));
    }
    for (int i = 0; i < MAX_VAL; i++) {
        sort(v[i].begin(), v[i].end(), comp);
    }
    for (int i = 0; i < MAX_VAL; i++) {
        for (int j = 0; j < (int)v[i].size(); j++) {
            dq[i].pb(v[i][j]);
        }
    }

    lli timer = 0;
    int mint = 0;
    int step = (int)sqrt(MAX_VAL);
    for (int i = 0; i < n; i++) {
        while(mint < MAX_VAL && dq[mint].empty()) {
            mint++;
        }
        if (timer < mint) {
            timer = mint;
        }
        int pos = mint;
        int idx = dq[mint].front().idx;
        double mini = INF;
        for (lli j = mint; j < MAX_VAL && j <= mint + step && j <= timer; j++) {
            if (dq[j].empty()) {
                continue;
            }
            l = dq[j].front().l;
            lli aux = l - (timer - j) * (timer - j);
            if (aux < mini || aux == mini && dq[j].front().idx < idx) {
                mini = aux;
                pos = j;
                idx = dq[j].front().idx;
            }
        }
        r[idx] = timer + dq[pos].front().l;
        timer += dq[pos].front().l;
        dq[pos].pop_front();
    }
    for (int i = 0; i < n; i++) {
        if (i != 0) {
            printf(" ");
        }
        printf("%lld", r[i]);
    }
    return 0;
}
