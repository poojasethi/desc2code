#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<vector>
#include<set>
#include<map>
#include<stack>
#include<queue>
#include<list>
#include<string>
#include<cstring>
#include<climits>

using namespace std;

#define PB push_back
#define MP make_pair
#define F first
#define S second
#define ALL(x) (x).begin(),(x).end()
#define SIZE(x) (int)(x).size()
#define SORT(x) sort((x).begin(),(x).end())
#define CLEAR(tab) memset(tab, 0, sizeof(tab))
#define REP(x, n) for(int x = 0; x < (n); x++)
#define FOR(x, b, e) for(int x = (b); x <= (e); x++)
#define FORD(x, b, e) for(int x = (b); x >= (e); x--)
#define VAR(v, n) __typeof(n) v = (n)
#define FOREACH(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)
#define DEBUG(fmt, ...) fprintf(stderr, fmt, ##__VA_ARGS__)

const int MAX_BUF_SIZE = 16384;
char BUFOR[MAX_BUF_SIZE];
int BUF_SIZE, BUF_POS;
char ZZZ;
#define GET(ZZZ){ZZZ='a';if(BUF_POS<BUF_SIZE)ZZZ=BUFOR[BUF_POS++];\
else if(!feof(stdin)){BUF_SIZE=fread(BUFOR,1,MAX_BUF_SIZE,stdin);\
ZZZ=BUFOR[0];BUF_POS=1;}}
#define GI(WW){do{GET(ZZZ);}while(!isdigit(ZZZ));WW=ZZZ-'0';\
while(1){GET(ZZZ);if(!isdigit(ZZZ))break;WW=WW*10+(ZZZ-'0');}}
#define GC(WW){do{GET(ZZZ);}while(!isalpha(ZZZ));WW=ZZZ;}

//FAST IO

typedef long long int LL;
typedef pair<int, int> PII;
typedef vector<int> VI;

const int MXN = 100010;
const int C = 262144;
const LL INF = LLONG_MAX;
const int PIEPRZU = 2 * sqrt(100000);

priority_queue< PII >Q[MXN];
LL res[MXN];
int n;
int l[MXN], t[MXN];

void test() {
	scanf("%d", &n);

	FOR(i, 1, n) {
		scanf("%d %d", &l[i], &t[i]);
		Q[t[i]].push(MP(-l[i], -i) );		
	}
	
	LL czas = 0;
	LL iter = 0;
	while(iter < MXN) {
		while(iter < MXN && Q[iter].empty() )
			iter++;
		czas = max(czas, iter);
		if(iter >= MXN)
			break;

		LL pocz = iter;
		LL kon = min((LL)MXN - 1, min(iter + PIEPRZU, czas) );
		pair<LL, LL> bestVal = MP(INF, INF);

		FOR(j, pocz, kon) {
			if(Q[j].empty() )
				continue;
			pair<LL, LL> p2 = Q[j].top();
			p2 = MP(-p2.F, -p2.S);
			pair<LL, LL> val = MP(p2.F - (LL)(czas - j) * (czas - j), p2.S);
			if(val < bestVal)
				bestVal = val;
		}

		if(bestVal.F == INF)
			break;
		
		LL tmp = bestVal.S;
		Q[t[tmp]].pop();
		czas += l[tmp];
		res[tmp] = czas;
	}

	FOR(i, 1, n)
		printf("%lld ", res[i]);
	printf("\n");
}

int main() {
	int te = 1;
//	scanf("%d", &te);
	while(te--)
		test();
	return 0;
}

