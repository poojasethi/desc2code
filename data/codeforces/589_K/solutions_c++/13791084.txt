#include <cstdio>
#include <iostream>
#include <cstring>
#include <cctype>
#include <string>
#include <cmath>
#include <algorithm>
#include <vector>
#include <deque>
#include <set>
#include <map>
#include <bitset>
#include <queue>

using namespace std;

typedef long long ll;

#define sqr(x) (ll(x) * (x))
#define MP(x,y) (make_pair((x),(y)))

const ll mxn = 100006;
const ll mxt = 100000;
const ll MXL = 0x3f3f3f3f3f3f3f3fLL;

int N;
ll ans[mxn];
vector<pair<ll,ll> > d[mxt + 6];

void EXEC() {
	scanf("%d", &N);
	// N = 100000;
	
	for (int i = 1; i <= N; ++i) {
		int L, T;
		scanf("%d%d", &L, &T);
		// L = rand() % mxt + 1;
		// T = rand() % (mxt + 1);
		// cout << L << " " << T << endl;
		d[T].push_back(MP(L, i));
	}
	
	for (int i = 0; i <= mxt; ++i) {
		sort(d[i].begin(), d[i].end());
		reverse(d[i].begin(), d[i].end());
	}
	
	ll time = 0;
	ll p = 0;
	for (int i = 1; i <= N; ++i) {
		while (p <= mxt && d[p].empty())
			++p;
		if (time < p)
			time = p;
		pair<pair<ll,ll>, int> mn = MP(MP(MXL, MXL), 0);
		// CAM! sqr(time - j) 会爆ll, 所以用 min(time, 100000000) 作为替代值，这样找出的最小值位置仍与原值一致
		for (int j = p; j <= mxt && j <= time && 1 - sqr(min(time, 100000000LL) - j) <= mn.first.first; ++j) if (!d[j].empty())
			mn = min(mn, MP(MP(d[j].back().first - sqr(min(time, 100000000LL) - j), d[j].back().second), j));
		time += d[mn.second].back().first;
		ans[mn.first.second] = time;
		d[mn.second].pop_back();
	}
	
	for (ll i = 1; i <= N; ++i)
		printf("%I64d%c", ans[i], (i + 1 <= N ? ' ' : '\n'));
}

int main() {
	EXEC();
	return 0;
}