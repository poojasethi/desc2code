/*
 
 *************************
 Id  : Matrix.code
 Task:
 Date:
 **************************
 
 */

#include <bits/stdc++.h>
using namespace std;

/*------- Constants---- */

#define LL                      long long
#define ull                     unsigned long long
#define mod                     1000000007
#define MEMSET_INF              63
#define MEM_VAL                 1061109567
#define forn(i,n)               for( int i=0 ; i < n ; i++ )
#define mp(i,j)                 make_pair(i,j)
#define lop(i,a,b)              for( int i = (a) ; i < (b) ; i++)
#define pb(a)                   push_back((a))
#define all(x)                  (x).begin(),(x).end()
#define gc                      getchar_unlocked
#define PI                      acos(-1.0)
#define INF                     1<<29
#define EPS                     1e-9
#define Fr                      first
#define Sc                      second
#define Sz                      size()
#define lc                      ((n)<<1)
#define rc                      ((n)<<11)
#define db(x)                   cout << #x << " -> " << x << endl;
#define Di(n)                   int n;si(n)
#define Dii(a,b)                int a,b;si(a);si(b)
#define Diii(a,b,c)             int a,b,c;si(a);si(b);si(c)
#define Si(n)                   si(n)
#define Sii(a,b)                si(a);si(b)
#define Siii(a,b,c)             si(a);si(b);si(c)
#define min(a,b)                ((a)>(b) ? (b) : (a) )
#define max(a,b)                ((a)>(b) ? (a):(b))
/*---- short Cuts ------- */
#define ms(ara_name,value) memset(ara_name,value,sizeof(ara_name))
typedef pair<int, int> ii;
typedef vector<int > vi ;
/*------ template functions ------ */
#ifndef getchar_unlocked
#define getchar_unlocked getchar
#endif
template<class T> inline void si(T &x){register int c = gc();x = 0;int neg = 0;for(;((c<48 | c>57) && c != '-');c = gc());
      if(c=='-') {neg=1;c=gc();}for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}if(neg) x=-x;}template <class T> inline T bigmod(T p,T e,T M){LL ret = 1;for(; e > 0; e >>= 1){if(e & 1) ret = (ret * p) % M;p = (p * p) % M;} return (T)ret;}
template <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}
template <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}
void IN(){    freopen("in.txt","r",stdin); freopen("out.txt","w",stdout);}

/*************************** END OF TEMPLATE ****************************/
const int N = 2e5+5;
int Map[N], RevMap[N];
int n;
typedef pair<LL,LL> Pair;
vector<Pair> h[N];
queue<Pair> T[N];
LL ans[N];

int main()
{
      Si(n);
      for(int i= 0;i < n;i ++ ) {
            Dii(l,t);
            h[t].pb(mp(l,i));
      }
      for(int i=0;i<N;i++) sort(all(h[i]));
      for(int i=0;i<N;i++){
            forn(j,h[i].Sz) T[i].push(h[i][j]);
      }
      
      
      int MIN = 0;
      int cnt = 0;
      LL Time = 0;
      
      while(cnt < n){
            for(int j = MIN; ; j ++ ) {
                  if(T[j].Sz){
                        MIN = j;
                        Time = max(Time,MIN);
                        break;
                  }
            }
            int sqN = sqrt(200000);
            LL iM = (1LL << 62);
            int id = MIN;
            for(int k = 0; k <= sqN && MIN + k <= Time  &&  MIN + k < N ; k ++ ) {
                  if(T[MIN + k] .Sz){
                        LL cand = T[MIN+k].front().Fr - (Time - MIN - k) * (Time - MIN - k );
                        if(cand < iM ) {
                              iM = cand;
                              id = MIN+k;
                        }
                        else if(cand==iM ){
                              if(id==-1 || T[MIN+k].front().Sc < T[id].front().Sc) id = MIN + k;
                        }
                  }
            }
            //db(iM);
            int task = T[id].front().Sc;
            LL end = T[id].front().Fr;
            T[id].pop();
            Time += end;
            ans[task] = Time;
            cnt ++;
      }
      
      forn(i,n) printf("%lld " , ans[i]);
      
      
      
      return 0;
      
}
 	 	 		 				 		  	  	 	 	 	 			