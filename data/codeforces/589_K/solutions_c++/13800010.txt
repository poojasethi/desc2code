#include <cstdio>
#include <algorithm>
#include <vector>
#include <queue>

#define MAXN 100010

using namespace std;

struct task {
    
    int l, t, idx;

    task () {}

    task (int _l, int _t, int _idx) {
        l = _l;
        t = _t;
        idx = _idx;
    }

    friend bool operator < (const task &A, const task &B) {
        if (A.l == B.l) return A.idx < B.idx;
        return A.l < B.l;
    }

};

typedef long long llint;

const int offset = 350; // cca sqrt 10^5

int n, max_t;
llint sol[MAXN];

vector <task> v[MAXN];
queue <task> Q[MAXN];

bool _less(int x, int y, llint time) {
    task A = Q[x].front(), B = Q[y].front();
    llint v1 = (llint) A.l - (llint) (time - A.t) * (time - A.t);
    llint v2 = (llint) B.l - (llint) (time - B.t) * (time - B.t);
    if (v1 < v2) return true;
    if (v2 < v1) return false;
    return A.idx < B.idx;
}

int main(void) {

    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        int l, t; scanf("%d%d", &l, &t);
        task T = task(l, t, i);
        v[t].push_back(T);
        max_t = max(max_t, t);
    }

    for (int i = 0; i <= max_t; ++i) {
        if (v[i].empty()) continue;
        sort(v[i].begin(), v[i].end());
        for (int j = 0; j < (int) v[i].size(); ++j) 
            Q[i].push(v[i][j]);
    }

    llint time = 0;
    int ptr = 0;
    
    for (int i = 0; i < n; ++i) {
        
        while (Q[ptr].empty()) ++ptr;
        if (ptr > time) time = ptr;

        int pivot = -1;
        for (int j = ptr; j <= min((llint)ptr + offset, time) && j <= max_t; ++j) {
            if (Q[j].empty()) continue;
            if (pivot == -1) pivot = j;
            if (_less(j, pivot, time)) pivot = j;
        }

        sol[Q[pivot].front().idx] = time + (llint) Q[pivot].front().l;
        time += (llint) Q[pivot].front().l;
        Q[pivot].pop();
    }

    for (int i = 0; i < n; ++i)
        printf("%lld ", sol[i]);

    printf("\n");

    return 0;
        
}
