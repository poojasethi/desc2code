#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <queue>

using namespace std;

#ifdef WIN32
	#define LL "%I64d"
#else
	#define LL "%lld"
#endif

#ifdef Lightning
	#define debug(orz...) printf(orz)
	const int DEBUG = 1;
#else
	#define debug(...)
	const int DEBUG = 0;
#endif

#define file_able if (0)
#define setfile(pro_name) freopen(pro_name".in", "r", stdin), freopen(pro_name".out", "w", stdout)
#define closefile() fclose(stdin), fclose(stdout)

#define cmax(_x, _y) (_x < (_y) ? _x = _y : 0)
#define cmin(_x, _y) (_x > (_y) ? _x = _y : 0)
#define gmax(_x, _y) ((_x) > (_y) ? (_x) : (_y))
#define gmin(_x, _y) ((_x) < (_y) ? (_x) : (_y))

namespace defs
{
	// #define getc() (S == T && (T = (S = B) + fread(B, 1, 1 << 15, stdin), S == T) ? EOF : *S++)
	
	// char B[1 << 15], *S = B, *T = B;
	
	#define getc() getchar()

	template <class Type> Type read()
	{
		Type aa;
		int bb = 1, ch;
		while (ch = getc(), (ch < '0' || ch > '9') && ch != '-');
		ch == '-' ? aa = 0, bb = -1 : aa = ch - '0';
		while (ch = getc(), ch >= '0' && ch <= '9') aa = aa * 10 + ch - '0';
		return bb == 1 ? aa : -aa;
	}

	const unsigned int rand_x = 11309;
	const unsigned int rand_y = 1000000019;
	
	unsigned int rand_cur;

	unsigned int rand_int()
	{
		return rand_cur = rand_cur * rand_x + rand_y;
	}

	const int inf = 1071026353;
	const int mod = 1000000007;
	const int modx = 998244353;
}

namespace st
{
	int val[100010], key[400040], base;
	
	inline void build(register int n)
	{
		memset(key, 63, sizeof key);
		base = 1;
		while (base <= n) base <<= 1;
		for (register int i = 1; i <= n; ++i)
			key[i + base] = val[i];
		for (register int i = base - 1; i; --i)
			key[i] = min(key[i << 1], key[i << 1 | 1]);
	}
	
	inline void modify(register int p, register int k)
	{
		key[p += base] = k;
		for (p >>= 1; p; p >>= 1)
			key[p] = min(key[p << 1], key[p << 1 | 1]);
	}
	
	inline int query(register int l, register int r)
	{
		int ret = 99999999;
		l += base - 1;
		r += base + 1;
		while (l ^ r ^ 1)
		{
			if (!(l & 1)) cmin(ret, key[l ^ 1]);
			if (r & 1) cmin(ret, key[r ^ 1]);
			l >>= 1, r >>= 1;
		}
		return ret;
	}
}

namespace lightningwork
{
	// my space

	int (*read)() = defs::read<int>;

	struct P
	{
		int t, l, id, vis;
		
		bool operator <(register const P &p) const
		{
			if (t == p.t && l == p.l) return id < p.id;
			return t < p.t || (t == p.t && l < p.l);
		}
	};

	P p[100010];

	int n, right[100010], next[100010];
	
	long long ans[100010];
	
	inline long long calc(register long long a, register long long b, register long long c)
	{
		b -= c;
		return a - b * b;
	}

	int find(register int x)
	{
		return p[x].vis == 0 ? x : next[x] = find(next[x]);
	}

	void work()
	{
		n = read();
		for (register int i = 1; i <= n; ++i)
		{
			p[i].l = read();
			p[i].t = read();
			p[i].id = i;
		}
		sort(p + 1, p + n + 1);
		for (register int i = n; i >= 1; --i)
		{
			st::val[i] = p[i].l;
			if (i < n)
			{
				if (p[i].t != p[i + 1].t)
					right[i] = i;
				else right[i] = right[i + 1];
			} else right[i] = i;
			next[i] = i + 1;
		}
		st::build(n);
		register int cnt = n, l = 1, r = 0;
		register long long T = 0;
		while (cnt)
		{
			while (r <= n && p[r].t <= T) ++r;
			if (T <= 200000)
			{
				register long long nowmin = 9999999999999999ll;
				int minid = 0;
				for (int i = l; i < r; i = find(next[i]))
				{
					if (p[i].vis == 1) continue;
					if (i + 10 < r)
					{
						register int tmp = st::query(i, r - 1);
						if (calc(tmp, p[i].t, T) > nowmin)
						{
							break;
						}
					}
					register long long tmp = calc(p[i].l, p[i].t, T);
					if (tmp < nowmin || (tmp == nowmin && p[i].id < p[minid].id))
					{
						nowmin = tmp;
						minid = i;
					}
					i = right[i];
				}
				if (minid == 0)
				{
					++T;
				} else
				{
					T += p[minid].l;
					ans[p[minid].id] = T;
					st::modify(minid, 99999999);
					p[minid].vis = 1;
					--cnt;
				}
				while (l <= n && p[l].vis == 1) ++l;
			} else
			{
				while (l <= n && p[l].vis == 1) ++l;
				if (l > n) break;
				T += p[l].l;
				ans[p[l].id] = T;
				p[l].vis = 1;
				--cnt;
			}
		}
		for (int i = 1; i <= n; ++i)
		{
			printf("%lld ", ans[i]);
		}
		puts("");
	}
}

int main()
{
	file_able setfile("task");
	lightningwork::work();
	file_able closefile();
	return 0;
}

