#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <cmath>
#include <iostream>
#include <algorithm>
#include <vector>
#define rep(i,x,y) for(int i=x;i<=y;++i)
#define mk make_pair
#define N 420000
#define int64 long long
#define VI vector<int>
using namespace std;

const int64 INF=1000000;

struct obj{
	int l,t,id;
}a[N];
int64 ans[N],T;
VI E[N];
int num[N],n;
bool cmp(const obj &a,const obj &b){
	return mk(mk(a.t,-a.l), -a.id)<mk(mk(b.t,-b.l),-b.id);
}
int64 calc(int t){
	int tmpT=min(T,INF);
	int res=E[t][num[t]-1];
	return (a[res].l- ((int64)(tmpT-t)*(tmpT-t) ) );
}
int main(){
	scanf("%d",&n);
	rep(i,1,n)scanf("%d%d",&a[i].l,&a[i].t),a[i].id=i;
	sort(a+1,a+n+1,cmp);
	int limit=0,j=1;
	T=-1;
	for(;;){
		while(limit<=T && limit<=110000 && num[limit]==0)limit++;
		if(limit>100010)break;
		if(limit>T){
			T++;
		}else{
			int64 minn=calc(limit);
			int id=limit;
			rep(i,limit+1,T){
				if(-1-( (int64)(min(INF,T)-i)*( min(INF,T) -i)) > minn)break;
				if(num[i] && mk(calc(i),a[E[i][num[i]-1]].id)<mk(minn, a[E[id][num[id]-1]].id )){
					minn=calc(i);
					id=i;
				}
			}

			int tmp=E[id][num[id]-1];
			ans[a[tmp].id]= T+a[tmp].l;
			T+=a[tmp].l;
			num[id]--;
		}

		while(a[j].t<=T && j <= n){
			E[a[j].t].push_back(j);
			num[a[j].t]++;
			j++;
		}
	}
	rep(i,1,n)printf("%I64d ",ans[i]);
	puts("");
	return 0;
}
