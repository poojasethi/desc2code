#include <algorithm>
#include <bitset>
#include <cassert>
#include <cctype>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <string>
#include <utility>
#include <vector>
using namespace std;

#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define sz(x) (int((x).size()))
#define bit(x) (1 << (x))
#define cnt1(x) (__builtin_popcount(x))

template<class T>
inline void chkmax(T& x, T y) {
    if (x < y) x = y;
}

template<class T>
inline void chkmin(T& x, T y) {
    if (y < x) x = y;
}

typedef long long LL;
typedef double DB;
typedef pair<int, int> PII;
typedef vector<int> VI;

const int MX = 100005;
struct Data {
    int l, t, id;
} d[MX];

VI v[MX];
LL ans[MX];

inline LL sqr(LL x) {
    return x * x;
}
bool cmp(const Data &a, const Data &b) {
    if (a.l != b.l) return a.l > b.l;
    return a.id > b.id;
}

int main() {
//  freopen("in.txt", "r", stdin);
//  freopen("out.txt", "w", stdout);
    
    int n;
    int i, j, k;
    
    scanf("%d", &n);
    for (i = 1; i <= n; i++) {
        scanf("%d%d", &d[i].l, &d[i].t);
        d[i].id = i;
    }
    
    sort(d + 1, d + n + 1, cmp);
    for (i = 1; i <= n; i++) {
        v[d[i].t].pb(i);
    }
    
    for (i = 0; i < MX; i++) if (!v[i].empty()) break;
    int pos = i;
    LL cur = pos;
    
    for (i = 1; i <= n; i++) {
        int u = v[pos].back();
        if (cur < d[u].t) cur = d[u].t;
        LL rlt = d[u].l - sqr(d[u].t) + 2 * d[u].t * cur;
        
        for (k = pos + 1; ; k++) {
            if (k >= MX || k > cur) break;
            if (1 - sqr(k) + 2 * k * cur > rlt) break;
            if (v[k].empty()) continue;
            
            int vv = v[k].back();
            LL tp = d[vv].l - sqr(d[vv].t) + 2 * d[vv].t * cur;
            if (tp < rlt || tp == rlt && d[vv].id < d[u].id) {
                rlt = tp, u = vv;
            }
        }
        
        cur += d[u].l;
        ans[d[u].id] = cur;
        v[d[u].t].pop_back();
        while (pos < MX && v[pos].empty()) pos++;
    }
    
    for (i = 1; i <= n; i++) {
        if (i > 1) printf(" ");
        printf("%lld", ans[i]);
    }
    puts("");
    
    return 0;
}
