#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>

using namespace std;

const int MAXN = 500005;
const long double eps = 1e-7;
typedef long long LL;

long double G[MAXN],Gi[MAXN];
LL End[MAXN];
int Pos[MAXN * 20],Ld[MAXN],Ti[MAXN],Li[MAXN];
int T[MAXN],L[MAXN],Ord[MAXN],Refer[MAXN * 4],Num[MAXN * 4],N,cnt;

namespace Brute
{
	LL Ans[MAXN];

	long long sqr(int a)
	{
		return 1ll * a * a;
	}

	void Work()
	{
		for(int i = 1;i <= N;i ++)
			scanf("%d%d", &L[i], &T[i]);
		for(LL t = 0;;)
		{
			int c = 0;
			for(int i = 1;i <= N;i ++)
				if (T[i] <= t && !Ans[i]) c ++;
			if (!c)
			{
				t = (1 << 30);
				for(int i = 1;i <= N;i ++)
					if (!Ans[i])
						t = min(t,1ll * T[i]);
				if (t == (1 << 30)) break;
				continue;
			}
			int use = 0;
			long long val = 0;
			for(int i = 1;i <= N;i ++)
				if (!Ans[i] && T[i] <= t)
				{
					long long p = L[i] - sqr(T[i] - t);
					if (use == 0 || (p < val)) use = i,val = p;
				}
			t = t + L[use];
			Ans[use] = t;
		}
		for(int i = 1;i <= N;i ++)
			printf("%lld%c", Ans[i], i == N ? '\n' : ' ');
	}
}

bool cmp(int a,int b)
{
	return Ti[a] < Ti[b];
}

bool Comp(int a,int b,int c)
{
	long double v1 = (G[c] - G[b]) * (T[b] - T[a]),v2 = (G[b] - G[a]) * (T[c] - T[b]);
	if (T[b] - T[a] == T[c] - T[b]) return G[c] - G[b] > G[b] - G[a];
	return (v1 >= v2);
}

bool Com(int a,int b,LL lim)
{
	return (2 * lim * (T[b] - T[a]) > G[b] - G[a]);
}

void Build(int l,int r,int jd)
{
	Ld[jd] = ++ cnt;
	cnt += r - l;
	if (l == r) return;
	int mid = l + r >> 1;
	Build(l,mid,jd << 1),Build(mid + 1,r,jd << 1 | 1);
}

int Query(LL t)
{
	int l = 1,r = Num[1] - 1,tmp = Num[1];
	for(int mid;l <= r;)
	{
		mid = l + r >> 1;
		if (Com(Pos[Ld[1] + mid - 1],Pos[Ld[1] + mid],t)) r = mid - 1,tmp = mid; else
			l = mid + 1;
	}
	return Pos[Ld[1] + tmp - 1];
}

void Push_Back(int p,int jd)
{
	int &tot = Num[jd];
	while (tot > 1 && Comp(Pos[Ld[jd] + tot - 2],Pos[Ld[jd] + tot - 1],p)) tot --;
	Pos[Ld[jd] + (++ tot) - 1] = p;
}

void Merge(int jd,int j1,int j2)
{
	Num[jd] = Num[j1];
	for(int i = 1;i <= Num[j1];i ++) Pos[Ld[jd] + i - 1] = Pos[Ld[j1] + i - 1];
	for(int i = 1;i <= Num[j2];i ++) Push_Back(Pos[Ld[j2] + i - 1], jd);
}

void Push(int l,int r,int p,int jd)
{
	Push_Back(p,jd);
	if (l == r) return; else
	{
		int mid = l + r >> 1;
		if (p <= mid) Push(l,mid,p,jd << 1); else 
			Push(mid + 1,r,p,jd << 1 | 1);
	}
}

void Del(int l,int r,int p,int jd)
{
	if (l == r) Num[jd] = 0; else
	{
		int mid = l + r >> 1;
		if (p <= mid) Del(l,mid,p,jd << 1); else
			Del(mid + 1,r,p,jd << 1 | 1);
		Merge(jd,jd << 1,jd << 1 | 1);
	}
}

int main()
{
//	freopen("task.in","r",stdin),freopen("task.out","w",stdout);
	scanf("%d", &N);
	if (N <= 5000) {Brute::Work();return 0;}
	for(int i = 1;i <= N;i ++)
	{
		scanf("%d%d", &Li[i], &Ti[i]);
		Gi[i] = 1.0 * Ti[i] * Ti[i] - Li[i] - (i * eps);
		Ord[i] = i;
	}
	Build(1,N,1);
	sort(Ord + 1,Ord + N + 1,cmp);
	for(int i = 1;i <= N;i ++)
		L[i] = Li[Ord[i]],T[i] = Ti[Ord[i]],G[i] = Gi[Ord[i]];
	for(LL t = T[1],i = 1;;)
	{
		for(;i <= N && T[i] <= t;i ++) Push(1,N,i,1);
		if (!Num[1])
		{
			if (i > N) break;
			t = T[i];
			continue;
		}
		int v = Query(t);
		Del(1,N,v,1);
		t += L[v];
		End[Ord[v]] = t;
	}
	for(int i = 1;i <= N;i ++)
		printf("%I64d%c", End[i], i == N ? '\n' : ' ');
	return 0;
}

