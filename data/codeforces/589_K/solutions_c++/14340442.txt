#include<cstdio>
#include<cstring>
#include<iostream>
#include<vector>
#include<deque>
#include<string>
#include<algorithm>
using namespace std;

const int N = 100000 + 10;
const int B = 300;
const long long INF = 1000000000000000000LL;

vector<int> events;
deque<int> que[N / B + 1];
long long ret[N];
int tot, n, m;
int live[N];
int l[N], t[N];
int where[N];
long long x[N], y[N];

inline long long calcValue(const int &u, const long long &T)
{
	return x[u] * T + y[u];
}

int chooseBest(long long T)
{
	pair<long long, int> ret(INF, -1);
	for(int i = 0; i < m; ++ i) {
		for( ; que[i].size() > 1; ) {
			int u = que[i].back();
			int v = que[i][que[i].size() - 2];
			if (calcValue(u, T) > (calcValue(v, T))) {
				que[i].pop_back();
			} else {
				break;
			}
		}
		if (que[i].size()) {
			ret = min(ret, make_pair(calcValue(que[i].back(), T), que[i].back()));
		}
		if (que[i].size() > 1) {
			ret = min(ret, make_pair(calcValue(que[i][que[i].size() - 2], T), que[i][que[i].size() - 2]));
		}
	}
	return ret.second;
}

inline long long crossOp(const int &s, const int &p1, const int &p2)
{
	return (x[p1] - x[s]) * (y[p2] - y[s]) - (x[p2] - x[s]) * (y[p1] - y[s]);
}

void rebuild(int b)
{
	que[b].clear();
	for(int i = b * B; i < b * B + B && i < events.size(); ++ i) {
		int id = events[i];
		if (! live[id]) continue;
		if (que[b].size() && x[id] == x[que[b].back()] && y[id] == y[que[b].back()]) continue;
		for( ; que[b].size() > 1; ) {
			long long sign = crossOp(que[b][que[b].size() - 2], que[b].back(), id);
			if (sign < 0) {
				que[b].pop_back();
			} else if (sign == 0) {
				if (id < que[b].back()) {
					que[b].pop_back();
				} else if (que[b][que[b].size() - 2] < que[b].back()) {
					que[b].pop_back();
				} else {
					break;
				}
			} else {
				break;
			}
		}
		que[b].push_back(id);
	}
}

int cmp(const int &a, const int &b)
{
	if (x[a] != x[b]) return x[a] < x[b];
	if (y[a] != y[b]) return y[a] < y[b];
	return a < b;
}

void solve()
{
	cin >> n;
	for(int i = 0; i < n; ++ i) {
		scanf("%d%d", l + i, t + i);
		x[i] = 2 * t[i];
		y[i] = l[i] - (long long)t[i] * t[i];
		events.push_back(i);
	}
	sort(events.begin(), events.end(), cmp);

	long long T = 0;
	int ptr = 0;
	m = 0;
	tot = 0;
	for( ; ; ) {
		for( ; ptr < events.size() && t[events[ptr]] <= T; ++ ptr) {
			live[events[ptr]] = true;
			where[events[ptr]] = ptr / B;
			m = ptr / B + 1;
			rebuild(ptr / B);
			tot ++;
		}
		if (tot == 0) {
			if (ptr == events.size()) break;
			T = t[events[ptr]];
			continue;
		}
		int id = chooseBest(T);
		tot --;
		ret[id] = T + l[id];
		T += l[id];
		live[id] = false;
		rebuild(where[id]);
	}
	for(int i = 0; i < n; ++ i) {
		if (i) putchar(' ');
		printf("%I64d", ret[i]);
	}
	puts("");
}

int main()
{
	solve();
	return 0;
}