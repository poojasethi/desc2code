
# Accellerate, then keep speed
def time(a, v, s):

	# v = a*t
	# s = a*t*t/2
	t_accell = v / float(a)
	d_accell = a * t_accell * t_accell / 2.0
	d_res = 0
	if s < d_accell:
		#print s, d_accell
		d_accell = s
		# s = a*t*t/2
		t_accell = (2.0 * d_accell / a)**0.5
		d_res = 0
	else:
		d_res = s - d_accell
	
	
	t_res = d_res / float(v)
	return t_accell + t_res

def zada(n, a, d, data):
	last_t = 0
	data = sorted(data, lambda x, y: x[0] - y[0])
	#print data
	for x in xrange(n):
		t0, v = data[x]
		t = max(t0 + time(a, v, d), last_t)
		print t
		last_t = t

#"""
n, a, d = map(int, raw_input().split(" "))
data = []
for x in xrange(n):
	t0, v = map(int, raw_input().split(" "))
	data.append([t0, v])
	
"""
n, a, d = 3, 10, 10000
data = [
[0, 10], [5, 11], [1000, 1]
]

#n, a, d = 1, 2, 26
#data = [
#[28, 29]
#]
#"""

zada(n, a, d, data)
