#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<vector>
#include<queue>
#include<algorithm>
using namespace std;
const int INF=314000000;
const int N=100010;
struct num{num(int b=0):a(b){}int a;}cost[N],f[N][2];;
struct PQ{PQ(int a=0,int b=0):id(a),cnt(b){}int id,cnt;};
vector<int>q[N];
vector< vector<int> >e[N];
int n,m;
int cnt[N],alive[N],belong[N],vis[N],instack[N];
int head[N],list[N],next[N],tot;
bool operator<(num a,num b)
{
    if(a.a==-2)a.a=INF+1;
    if(b.a==-2)b.a=INF+1;
    return a.a<b.a;
}
num operator+(num a,num b)
{
    if(a.a==-2||b.a==-2)return -2;
    else return min(INF,a.a+b.a);
}
void add(int a,int b)
{
    tot++;
    list[tot]=b;
    next[tot]=head[a];
    head[a]=tot;
}
void Input()
{
    scanf("%d%d",&m,&n);
    int i,j,k,l;
    for(i=1;i<=m;i++)
    {
        scanf("%d%d",&belong[i],&k);
        while(k--)
        {
            scanf("%d",&l);
            q[i].push_back(l);
            add(l,i);
        }
        e[belong[i]].push_back(q[i]);
    }
}
bool operator<(PQ a,PQ b){return a.cnt>b.cnt;}
priority_queue<PQ>pq;
void build()
{
    int i,j,k,l;
    for(i=1;i<=m;i++)
        for(j=0;j<q[i].size();j++)
        if(q[i][j]>0)cnt[i]++;
        else cost[i]=cost[i]+1;
    for(i=1;i<=m;i++)
    if(cnt[i]==0)pq.push(PQ(i,cost[i].a));
    while(pq.size())
    {
        PQ t=pq.top();pq.pop();
        if(!alive[belong[t.id]])
        {
            alive[belong[t.id]]=1;
            f[belong[t.id]][0]=t.cnt;
            for(i=head[belong[t.id]];i;i=next[i])
            {
                cnt[list[i]]--;
                cost[list[i]]=cost[list[i]]+t.cnt;
                if(cnt[list[i]]==0)
                pq.push(PQ(list[i],cost[list[i]].a));
            }
        }
    }
}
num dfs2(int x)
{
    if(vis[x])return f[x][1];
    instack[x]=1;
    int i,j,k;
    num re;
    for(i=0;i<e[x].size();i++)
    {
        for(j=0;j<e[x][i].size();j++)
        if(e[x][i][j]>0&&!alive[e[x][i][j]])break;
        if(j<e[x][i].size())continue;
        re=0;
        for(j=0;j<e[x][i].size();j++)
        if(e[x][i][j]==-1)re=re+1;
        else if(instack[e[x][i][j]])re=-2;
        else re=re+dfs2(e[x][i][j]);
        if(f[x][1]<re)f[x][1]=re;
    }
    vis[x]=1;
    instack[x]=0;
    return f[x][1];
}
int main()
{
    Input();
    build();
    for(int i=1;i<=n;i++)
    if(!alive[i])puts("-1 -1");
    else printf("%d %d\n",f[i][0].a,dfs2(i).a);
    return 0;
}
