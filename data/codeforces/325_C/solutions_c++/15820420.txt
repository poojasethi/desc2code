#include <bits/stdc++.h>

using namespace std;

#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)

#define type(x) __typeof(x.begin())

#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair < int ,int > pii;

typedef long long ll;

const long long linf = 1e18+5;
int mod = (int) 1e9 + 7;
const int logN = 18;
const int inf = 1e9;
const int N = 1e6 + 5;

int qa[N], vvv[N], hh[N], start[N], low[N], T, dp[N], h[N], SP[N], n, m, x, y, z, root[N], k, in[N], val[N];
vector< int > bef[N], can[N], go[N];

int dfs(int node) {
	if(dp[node] != -1) return dp[node];
	start[node] = low[node] = ++T;
	dp[node] = 0;
	qa[node] = 2;
	int ttt = 0, asd = 0, sq = 0;
	foreach(it, can[node]) {
		int flag = 0;
		ll tt = vvv[*it];
		ttt = 0;
		foreach(it2, go[*it]) {
			if(!h[*it2]) {
			}
			else flag = 1;
		}
		if(flag) continue;
		foreach(it2, go[*it]) {
			if(qa[*it2] == 2) {
				ttt = 1;
				continue;
			}
			else {
				tt += dfs(*it2);
				if(dfs(*it2) == inf) {
					ttt = 1;
				}
			}
		}
		if(ttt == 1) { sq = 1; tt = inf; }
		else { asd = 1; dp[node] = max(dp[node], (int) min(314000000LL, tt)); }
	}
	if(sq) dp[node] = inf;
	qa[node] = 1;
	return dp[node];
}



int main() {

//	freopen("canavar.gir", "r", stdin);
//	freopen("canavar.cik", "w", stdout);

	scanf("%d %d", &m, &n);

	FOR(i, 1, m) {
		scanf("%d %d", &x, &k);
		root[i] = x;
		can[x].pb(i);
		FOR(j, 1, k) {
			scanf("%d", &x);
			if(x == -1) { val[i]++; ++vvv[i]; }
			else {
				go[i].pb(x);
				in[i]++;
				bef[x].pb(i);
			}
		}
	}

	priority_queue< pair< int , int > , vector< pair< int , int > >, greater< pair< int , int > > > pq;

	FOR(i, 1, m) {
		if(in[i] == 0) {
			pq.push(mp(val[i], root[i]));
		}
	}

	FOR(i, 1, n) SP[i] = inf;

	while(pq.size()) {
		int node = pq.top().nd;
		int cost = pq.top().st;
		pq.pop();
		if(hh[node]) continue;
		hh[node] = 1;
		SP[node] = cost;
		foreach(it, bef[node]) {
			val[*it] += cost;
			val[*it] = min(val[*it], 314000000);
			if(!--in[*it] && SP[root[*it]] > val[*it]) {
				pq.push(mp(SP[root[*it]] = val[*it], root[*it]));
			}
		}
	}

	memset(dp, -1, sizeof dp);

	FOR(i, 1, n)
		if(SP[i] == inf)
			h[i] = 1;

	FOR(i, 1, n)
		if(!h[i] && !qa[i]) 
			dfs(i);

	FOR(i, 1, n) {
		if(SP[i] == inf) { printf("-1 -1\n"); continue; }
		if(dp[i] == inf) dp[i] = -2;
		printf("%d %d\n", SP[i], dp[i]);
	}
}
