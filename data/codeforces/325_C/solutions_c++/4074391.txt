//#pragma comment(linker, "/STACK:134217728")

#include <iostream>
#include <sstream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <memory>
#include <cctype>
#include <cstring>
#include <vector>
#include <list>
#include <queue>
#include <deque>
#include <stack>
#include <map>
#include <set>
#include <algorithm>
#include <numeric>
using namespace std;

typedef long long Int;
typedef pair<int,int> PII;
typedef vector<int> VInt;

#define FOR(i, a, b) for(i = (a); i < (b); ++i)
#define RFOR(i, a, b) for(i = (a) - 1; i >= (b); --i)
#define CLEAR(a, b) memset(a, b, sizeof(a))
#define SIZE(a) int((a).size())
#define ALL(a) (a).begin(),(a).end()
#define PB push_back
#define MP make_pair

#define INF 314000000
#define MAX (1 << 18)

int A[MAX];
int B[MAX];
int C[MAX];
int D[MAX];
int R[MAX];
int Z[MAX];
int Min[MAX];
int Max[MAX];

VInt Splits[MAX];
VInt Edge2[MAX];

int main()
{
	int n, m;
	scanf("%d%d", &m, &n);

	int i, j;
	FOR(i, 0, m)
	{
		int a, b, c;
		scanf("%d%d", &a, &c);
		--a;

		A[i] = a;
		R[i] = 0;
		C[i] = 0;
		Splits[a].PB(i);

		FOR(j, 0, c)
		{
			scanf("%d", &b);
			if(b == -1)
				++R[i];
			else
			{
				--b;
				Edge2[b].PB(i);
				++C[i];
			}
		}
	}

	FOR(i, 0, m)
	{
		D[i] = C[i];
		Z[i] = R[i];
	}

	priority_queue<PII> Q;
	FOR(i, 0, m)
		if(D[i] == 0)
			Q.push(PII(-Z[i], A[i]));

	FOR(i, 0, n)
		Min[i] = -1;

	while(!Q.empty())
	{
		int a = Q.top().second;
		int r = -Q.top().first;
		Q.pop();
		if(Min[a] != -1)
			continue;

		Min[a] = r;
		FOR(i, 0, SIZE(Edge2[a]))
		{
			int b = Edge2[a][i];
			--D[b];
			Z[b] = min(INF, Z[b] + r);

			if(D[b] == 0)
				Q.push(PII(-Z[b], A[b]));
		}
	}

	FOR(i, 0, m)
		B[i] = (D[i] == 0 ? 0 : 1); 

	FOR(i, 0, n)
	{
		Max[i] = Min[i] == -1 ? -1 : -2;
		D[i] = 0;
		FOR(j, 0, SIZE(Splits[i]))
		{
			int a = Splits[i][j];
			if(B[a] == 0)
				D[i] += C[a];
		}
	}

	FOR(i, 0, m)
		Z[i] = R[i];

	FOR(i, 0, n)
		if(D[i] == 0)
			FOR(j, 0, SIZE(Splits[i]))
				if(B[ Splits[i][j] ] == 0)
					Q.push(PII(Z[ Splits[i][j] ], i));

	while(!Q.empty())
	{
		int a = Q.top().second;
		int r = Q.top().first;
		Q.pop();
		if(Max[a] != -2)
			continue;

		Max[a] = r;
		FOR(i, 0, SIZE(Edge2[a]))
		{
			int b = Edge2[a][i];
			if(B[b] != 0)
				continue;

			int c = A[b];
			--D[c];
			Z[b] = min(INF, Z[b] + r);

			if(D[c] == 0)
				FOR(j, 0, SIZE(Splits[c]))
					if(B[ Splits[c][j] ] == 0)
						Q.push(PII(Z[ Splits[c][j] ], c));
		}
	}

	FOR(i, 0, n)
	{
		printf("%d %d\n", Min[i], Max[i]);
	}

	return 0;
};
