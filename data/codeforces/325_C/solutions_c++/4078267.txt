#include <iostream>
#include <vector>
#include <queue>

#define G(x) min(x, 314000000)
#define GMAX(x, y) (x == -2 ? x : max(x, y))
#define Z(x) x.size()
#define data pair<int, int>
#define g first 
#define u second
#define mk make_pair
#define pb push_back
#define MAXN 100005
#define MAXM 300005

using namespace std;

int n, m, t, d[MAXN], mark[MAXN], gMin[MAXN], gMax[MAXN];
vector<int> a[MAXN];
struct rule
{
  int u, g, l, sumG;
  vector<int> v;
} r[MAXM];

int read()
{
  cin >> m >> n;
  for (int i = 0; i < m; i++)
  {
    int l;
    cin >> r[i].u >> l;
    for (int j = 0; j < l; j++)
    {
      int v;
      cin >> v;
      if (v < 0) r[i].g++; 
      else 
      {
        r[i].v.pb(v);
        a[v].pb(i);
      }
    }
  }  
}

int processSmallest()
{
  priority_queue<data> pq;
  for (int i = 0; i < m; i++)
    if (Z(r[i].v) == 0) pq.push(mk(-r[i].g, r[i].u));
    
  while (!pq.empty())
  {
    data p;
    p = pq.top();
    pq.pop();
    if (p.u == 9)
    {
      int i = 0;
    }
    
    if (!mark[p.u])
    {
      mark[p.u] = 1;
      gMin[p.u] = G(-p.g);
      for (int i = 0, j; i < Z(a[p.u]); i++)
      {
        j = a[p.u][i];
        r[j].l++;
        r[j].sumG = G(r[j].sumG + gMin[p.u]);
        if (r[j].l == Z(r[j].v))
          pq.push(mk(-G(r[j].sumG + r[j].g), r[j].u));
      }
    }
    
  }
}

int dfs(int u)
{
//  d[u] = l;
  mark[u] = 2;
  for (int i = 0; i < Z(a[u]); i++)
  {
    int p, sumG;
    p = a[u][i];
    sumG = 0;
    for (int j = 0; j < Z(r[p].v); j++)
    {
      int v = r[p].v[j];
      if (mark[v] == 2)
      {
        sumG = -2;
        break;
      }
      if (mark[v] == 1) dfs(v);
      sumG = GMAX(gMax[v], G(sumG + gMax[v]));
      if (sumG == -2) break;
    }
    sumG = GMAX(sumG, G(sumG + r[p].g));
    gMax[u] = GMAX(sumG, gMax[u]);
    if (gMax[u] == -2) break;
  }
  mark[u] = 3;
}

int processLargest()
{
  for (int i = 1; i <= n; i++) a[i].clear();
  for (int i = 0; i < m; i++) 
    if (r[i].l == Z(r[i].v)) a[r[i].u].pb(i);
    
  t = 1;
  for (int i = 1; i <= n; i++)
    if (mark[i] == 1) 
    {
      t++;
      dfs(i);
    }
}

int write()
{
  for (int i = 1; i <= n; i++) 
    if (mark[i]) 
      cout << gMin[i] << " " << gMax[i] << "\n";
    else
      cout << "-1 -1\n";
}

main()
{  
  read();
  processSmallest();
  processLargest();
  write();
  //system("pause");
}
