#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <vector>
#define maxn 1010

using namespace std;

int G[maxn][maxn];
vector<int> g[maxn];
vector<int> cid[maxn];
int id[maxn],cnt;
int stack[maxn],stn;
int low[maxn],Tm;
int n,m;
int dfs(int fx,int x){
	int mint;
	mint=low[x]=++Tm;
	stack[++stn]=x;
	int gn=int(g[x].size());
	for (int i=0;i<gn;i++){
		int v=g[x][i];
		if (v==fx) continue;
		if (!low[v]){
			dfs(x,v);
			mint=min(mint,low[v]);
		}else mint=min(mint,low[v]);
	}
	if (mint==low[x]){
		int k;
		cid[cnt].clear();
		do{
			k=stack[stn--];
			id[k]=cnt;
			cid[cnt].push_back(k);
		}while (k!=x);
		++cnt;
	}else low[x]=mint;
}
int st[maxn],aim[maxn*maxn],nxt[maxn*maxn],ln;
void in_edge(int x,int y){
//	printf("(%d,%d)\n",x,y);
	aim[ln]=y;
	nxt[ln]=st[x];
	st[x]=ln++;
}
int leave[maxn];
int q[maxn],tag[maxn];
vector< pair<int,int> > ans;
vector< int > b[maxn];
int N;
void Add(int x,int y){
	for (int i=0;i<cid[x].size();i++)
		for (int j=0;j<cid[y].size();j++){
			int xx=cid[x][i],yy=cid[y][j];
			if (!G[xx][yy]){
				ans.push_back(make_pair(xx+1,yy+1));
				return;
			}
		}
}
bool cmp(int x,int y){
	return b[x].size()>b[y].size();
}
void work(int root){
	int qn=1;
	q[0]=root;
	tag[root]=1;
	leave[root]=1;
	for (int p=0;p<qn;p++)
		for (int i=st[q[p]];i!=-1;i=nxt[i])
			if (!tag[aim[i]]){
				int v=aim[i];
				tag[v]=1;
				leave[v]=1;
				q[qn++]=v;
				leave[q[p]]=0;
			}
	for (int p=qn-1;p>=0;p--){
		int k=q[p];
		tag[k]=0;
		if (leave[k]){
			b[k].push_back(k);
		}else{
			b[k].clear();
			vector<int> child;
			child.clear();
			for (int i=st[k];i!=-1;i=nxt[i])
				if (!tag[aim[i]]) child.push_back(aim[i]);
			sort(child.begin(),child.end(),cmp);
			int cn=int(child.size());
			for (int i=0;i<cn;i++){
				int v=child[i];
//				if (k==2) printf("%d %d %d\n",v,b[v].size(),b[k].size());
				if (b[k].size()==0){
					for (int j=0;j<b[v].size();j++) b[k].push_back(b[v][j]);
				}else
				if (b[v].size()==1){
					if (b[k].size()==2){
						int x=b[k][1];
						b[k].pop_back();
						Add(b[v][0],x);
					}else{
						b[k].push_back(b[v][0]);
					}
				}else{
					int x=b[k][b[k].size()-1];
					b[k].pop_back();
					Add(x,b[v][0]);
					b[k].push_back(b[v][1]);
				}
//				if (k==2) printf("%d\n",b[k].size());
			}
			if (k==root){
				if (b[k].size()==1){
					int x=b[k][0];
					int flag=0;
					for (int i=0;i<cn;i++)
						if (child[i]==x) flag=1;
					if (flag){
						for (int i=0;i<cn;i++)
							if (child[i]!=x){
								Add(x,child[i]);
								break;
							}
					}else{
						Add(x,root);
					}
				}else
					Add(b[k][0],b[k][1]);
			}
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for (int i=0;i<m;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		--u,--v;
		g[u].push_back(v);
		g[v].push_back(u);
		G[u][v]=G[v][u]=1;
	}
	if (n==2){
		puts("-1");
		return 0;
	}
	dfs(-1,0);
	memset(st,-1,sizeof(st));
	ln=0;
	for (int i=0;i<n;i++)
		for (int j=0;j<int(g[i].size());j++){
			int k=g[i][j];
			if (id[i]!=id[k]) in_edge(id[i],id[k]);
		}
	N=cnt;
	if (N==1){
		puts("0");
		return 0;
	}
	if (N==2){
		puts("1");
		Add(0,1);
		printf("%d %d\n",ans[0].first,ans[0].second);
		return 0;
	}
	int root=-1;
	for (int i=0;i<N;i++){
		int k=0;
		for (int j=st[i];j!=-1;j=nxt[j]) ++k;
		if (k>1){
			root=i;
			break;
		}
	}
	work(root);
	printf("%d\n",ans.size());
	for (int i=0;i<ans.size();i++){
		pair<int,int> tmp=ans[i];
		printf("%d %d\n",tmp.first,tmp.second);
	}
	return 0;
}
