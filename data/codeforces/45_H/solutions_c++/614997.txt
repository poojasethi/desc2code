#include <map>
#include <set>
#include <cmath>
#include <stack>
#include <queue>
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
using namespace std;
#define li		long long
#define rep(i,to)	for(li i=0;i<((li)to);i++)
#define pb		push_back
#define sz(v)		((li)v.size())


#define MAX 12345
#define M 1000
vector<pair<li,li> > E[M];
bool used[M];
bool deleted[M];
bool base[M][M];
bool queued[M];
set<li> s;
vector<pair<li,li> > ans;
set<li> compact[M];
li n,m;
li dfs(li pos,li parent=-1){
	if(used[pos])	return queued[pos]?pos:-1;
	used[pos]=queued[pos]=true;
	
	rep(i,sz(E[pos]))if(i!=parent && E[pos][i].first!=-1){
		li tmp=dfs(E[pos][i].first,E[pos][i].second);
		if(tmp!=-1 && tmp!=pos){
			s.insert(pos);
			queued[pos]=0;
			return tmp;
		}
		if(tmp==pos){
			s.insert(pos);
			for(set<li>::iterator it=s.begin();it!=s.end();it++)rep(j,sz(E[*it])){
				if(*it==pos) continue;
				deleted[*it]=true;
				if(E[*it][j].first==-1) continue;
				E[E[*it][j].first][E[*it][j].second].first=-1;
				if(s.find(E[*it][j].first)==s.end()){
					E[E[*it][j].first][E[*it][j].second]=make_pair(pos,sz(E[pos]));
					E[pos].pb(make_pair(E[*it][j].first,E[*it][j].second));
				}
			}
			for(set<li>::iterator it0=s.begin();it0!=s.end();it0++){
				for(set<li>::iterator it1=compact[*it0].begin();it1!=compact[*it0].end();it1++){
					compact[pos].insert(*it1);
				}
			}
			s.clear();
		}
	}
	queued[pos]=0;
	return -1;
}

vector<li> v;
void cal(li pos,li parent=-1){
	used[pos]=true;
	vector<li> res0,res1;
	li cnt=(parent==-1)?0:1;
	rep(i,sz(E[pos]))if(E[pos][i].first!=-1 && E[pos][i].first!=parent){
		cal(E[pos][i].first,pos);
		li tmp=0;
		if(sz(v)==1){
			res0.pb(v[0]);
		}else{
			while(1<sz(res1) && 1<sz(v)){
				ans.pb(make_pair(res1.back(),v.back()));
				v.pop_back(); res1.pop_back();
			}
			rep(j,sz(v)) res1.pb(v[j]);
		}
		cnt++;
	}
	while(sz(res0) && 1<sz(res1)){
		ans.pb(make_pair(res0.back(),res1.back()));
		res0.pop_back();
		res1.pop_back();
	}
	v.clear();
	rep(i,sz(res0)) v.pb(res0[i]);
	rep(i,sz(res1)) v.pb(res1[i]);
	if(cnt<2) v.pb(pos);
	if(parent==-1 && v[0]!=pos){
		rep(j,sz(v)/2) ans.pb(make_pair(v[j*2],v[j*2+1]));
		if(sz(v)%2) ans.pb(make_pair(ans.back().first,v.back()));
	}
}

int main(){
	rep(i,M) deleted[i]=false;
	rep(i,M)rep(j,M) base[i][j]=false;
	rep(i,M) compact[i].insert(i);
	cin>>n>>m;
	rep(i,m){
		li a,b;
		cin>>a>>b;
		E[a-1].pb(make_pair(b-1,sz(E[b-1])));
		E[b-1].pb(make_pair(a-1,sz(E[a-1])-1));
		base[a-1][b-1]=base[b-1][a-1]=true;
	}
	rep(i,M) used[i]=queued[i]=false;
	rep(i,n)if(!used[i]) dfs(i);

	rep(i,M) used[i]=false;
	vector<li> top;
	rep(i,n)if(!used[i] && !deleted[i]){
		cal(i);
		top.pb(i);
	}
	if(1<sz(top))rep(i,sz(top)) ans.pb(make_pair(top[i],top[(i+1)%sz(top)]));
	

	rep(i,sz(ans)){
		bool ok=false;
		li j,k;
		set<li>::iterator it0,it1;
		for(it0=compact[ans[i].first].begin();it0!=compact[ans[i].first].end() && !ok;it0++){
			for(it1=compact[ans[i].second].begin();it1!=compact[ans[i].second].end() && !ok;it1++){
				if(!base[*it0][*it1]) ok=true;
			}
		}
		it0--,it1--;
		if(!ok){
			cout<<"-1"<<endl;
			return 0;
		}
		ans[i]=make_pair(*it0,*it1);
	}
	cout<<sz(ans)<<endl;
	rep(i,sz(ans)) cout<<ans[i].first+1<<" "<<ans[i].second+1<<endl;	
}
