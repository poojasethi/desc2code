#include<iostream>
#include<cstdio>
#include<fstream>
#include<sstream>
#include<algorithm>
#include<functional>
#include<iomanip>
#include<numeric>
#include<cassert>
#include<cstring>
#include<cmath>
#include<ctime>
#include<cctype>
#include<utility>
#include<vector>
#include<string>
#include<queue>
#include<stack>
#include<climits>
#include<set>
#include<map>
#include<cassert>
 
#define SIZE(X) ((int)(X.size()))
#define LENGTH(X) ((int)(X.length()))
#define MP(X,Y) make_pair(X,Y)
#define two(X) (1<<(X))
#define twoL(X) (((LL)(1))<<(X))
#define contain(S,X) (((S)&two(X))!=0)
#define containL(S,X) (((S)&twoL(X))!=0)
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))

#define FOR(i,n) for(int i=0;i<(n);i++)
#define REP(i,a,b) for(int i=(a);i<=(b);i++)

using namespace std;
typedef vector<int> VI;
typedef vector<string> VS;
typedef vector<pair<int,int> > VII;
typedef map<int,int> MII;
typedef map<string ,int > MSI;

typedef long long LL;
typedef unsigned long long ULL; 
 
template<class T> inline void checkmin(T &a,T b){if(b<a) a=b;}
template<class T> inline void checkmax(T &a,T b){if(b>a) a=b;}
template<class T> inline int countbit(T n){return (n==0)?0:(1+countbit(n&(n-1)));}
template<class T> inline T sqr(T x){return x*x;}
template<class T> inline T lowbit(T n){return n&(-n);}
template<class T> inline T gcd(T a,T b)
{if(a<0)return gcd(-a,b);if(b<0)return gcd(a,-b);return (b==0)?a:gcd(b,a%b);}

const double pi=acos(-1.0);
const double eps=(1e-1);
const int Dx[8]={-1,0,1,0,-1,1,1,-1};
const int Dy[8]={0,1,0,-1,1,1,-1,-1};
const double inf = 1e50;
const int mod = 123657 ;

typedef pair<int,int> PII;
const int MAXN = 1000 + 10;
const int MAXM = 1000000+10 ;


class Tgraph{
public:
	const static int Nx = 1000 ;
	const static int Mx = 200000+10 ;
	int dfn[ Nx ] , low[ Nx ] , symbol[Nx] ,bcc[ Nx ] , orz[ Mx ], mark , cbcc ;	
	void init( int N ){ for( int i = 0 ; i <= N ; i ++ ) head[ i ] = 0 ; tot = 1 ; }
	void add( int u, int v ){ dest[++tot] = v , next[ tot ] = head[ u ], head[ u ] = tot ; }
	void BCC( int n){
		fill( dfn , dfn+n+1 , -1 ) ;
		fill( low , low+n+1 , 0  ) ;
		mark = 0 ; dfs( 1 , 0 ) ;
		fill( dfn , dfn+n+1 , 0 );
		cbcc = 0 ;
		for( int i = 1 ; i <= n; i ++ ) if( !dfn[i] ){
			dfn[i] = 1;
			symbol[ ++cbcc ] = i ;
			bcc[ i ] = cbcc ;
			paint( i ) ;
		}
	}
	bool sevenkplus( PII* ans ,int cans){
		fill( orz , orz+tot+1 , 0 );
		for( int i = 1 ; i <= cans ; i ++ )find( ans[i].first , ans[i].second , 0 );
		for( int i = 2 ; i <= tot ; i ++ ) if( !orz[i] ) return false;
		return true;
	}
private:	
	int head[ Nx ] , dest[ Mx ] , next[ Mx ] ,tot;
	void dfs( int u , int fa ){
		low[u] = dfn[u] = mark ++ ;
		for( int i = head[u] ; i ; i = next[i] ){
			int v = dest[i] ;
			if( v == fa ) continue;
			if( dfn[v] == -1 ){
				dfs( v , u ) ;
				checkmin( low[u] , low[v] ) ;
				if( low[v] > dfn[u] )orz[i] = orz[i^1] = true;
			}else checkmin( low[u] , dfn[v] );
		}
	}
	void paint( int u ){
		for( int i = head[u] ; i ; i = next[i] )if( !orz[i] ){
			int v = dest[i] ;
			if( !dfn[v] ){
				dfn[v] = 1 ;
				bcc[v] = cbcc ;
				paint(v) ;
			}
		}
	}
	
	bool find( int u , int v , int fa ){
		if( u == v ) return true;
		for( int k = head[u] ; k  ; k = next[k] ){
			int nv = dest[k] ;
			if( nv == fa ) continue;
			if( find( nv , v , u ) ){
				orz[ k ] = orz[ k^1 ] = 1;
				return true;
			}
		}
		return false;
	}
	
};
void show( char* s ){ puts(s);}
Tgraph g , gn ;
bool con[Tgraph::Nx][Tgraph::Nx];
int degree[ Tgraph::Nx ];
int list[ Tgraph::Nx ] , clist;
PII ans[ Tgraph::Nx ] ; int cans;
int main(){
	srand( time(0) ) ;
	int n , m;
	scanf("%d%d",&n,&m);
	g.init( n ); 
	for( int i = 0 ; i < m ; i++ ){
		int u , v ;
		scanf("%d%d",&u,&v);
		if( con[u][v] ){
			puts("-1");
			return 0;
		}
		con[u][v] = con[v][u] = 1 ;
		g.add( u , v ) ;
		g.add( v , u ) ;
	}
	g.BCC( n );
	if( g.cbcc == 1 ){
		puts("0");
		return 0;
	}
	if( g.cbcc == 2 ){
		for( int i = 1 ; i <= n ; i ++ )for( int j = i+1 ; j <= n ; j ++ )
			if( g.bcc[i] != g.bcc[j] && !con[i][j] ){
				printf("1\n%d %d\n",i,j);
				return 0;
			}
		puts("-1");
		return 0;
	}
	gn.init( g.cbcc ) ;
	for( int i = 1 ; i <= n ; i ++ )for( int j = i+1 ; j <= n ; j ++ )
		if( g.bcc[i] != g.bcc[j] && con[i][j] ){
			gn.add( g.bcc[i] , g.bcc[j] );
			gn.add( g.bcc[j] , g.bcc[i] );
			++ degree[ g.bcc[i] ];
			++ degree[ g.bcc[j] ];
		}
		
	clist = 0 ;
	for( int i = 1 ; i <= g.cbcc ; i ++ )if( degree[i] == 1 ) list[ ++clist ] = i ;
	while( true ){
		random_shuffle( list+1, list+clist+1 );
		list[ clist+1 ] = list[1] ;
		cans = 0 ;
		for( int i = 1 ; i <= clist ; i += 2 )
			ans[ ++cans ] = MP( list[i] , list[i+1] ) ;
		if( gn.sevenkplus( ans , cans) ){
			printf("%d\n",cans);
			for( int i = 1 ; i <= cans ; i ++ )
				printf("%d %d\n",g.symbol[ans[i].first] , g.symbol[ans[i].second] );
			return 0 ;
		}
	} 	
}

