#include <cstdio>
#include <cstring>
#include <ctime>
#include <algorithm>
#include <cstdlib>
#include <iostream>
using namespace std;

const int M = 200005;
const int N = 1005;

struct Tgraph {
        int head[N];
        int dest[M], next[M];
        int tot;
        void add(int x, int y)
        {dest[++tot] = y; next[tot] = head[x]; head[x] = tot;}
} g, gn;

int list[N], low[N], dfn[N], symbol[N], bcc[N], degree[N];
bool vis[N * 2];
bool orz[M];
int tot = 1, n, m, clist, cbcc;
bool con[N][N];
pair<int, int> ans[M];
int cans;


template<class  T> inline void checkmin(T &a, const T &b)
{if (b < a) a = b;}

void dfs(int x, int d, int fa)
{
        low[x] = dfn[x] = d;
        for (int k = g.head[x]; k != 0; k = g.next[k]) {
                int u = g.dest[k];
                if (u == fa) continue;
                if (dfn[u] == -1) {
                        dfs(u, d + 1, x);
                        checkmin(low[x], low[u]);
                        if (low[u] > dfn[x]) orz[k] = orz[k ^ 1] = true;
                } else checkmin(low[x], dfn[u]);
        }
}

void paint(int x)
{
        for (int k = g.head[x]; k != 0; k = g.next[k]) if (!orz[k]) {
                int u = g.dest[k];
                if (!vis[u]) {
                        vis[u] = true;
                        bcc[u] = cbcc;
                        paint(u);
                }
        }
}

bool find(int x, int y, int fa)
{
        if (x == y) return true;
        for (int k = gn.head[x]; k != 0; k = gn.next[k]) {
                int u = gn.dest[k];
                if (u == fa) continue;
                if (find(u, y, x)) {
                        vis[k] = vis[k ^ 1] = true;
                        return true;
                }
        }
        return false;
}

bool sevenkplus()
{
        memset(vis, 0, sizeof(vis));
        for (int i = 1; i <= cans; ++i) find(ans[i].first, ans[i].second, 0);
        for (int i = 2; i <= gn.tot; ++i) if (!vis[i]) return false;
        return true;
}

int main()
{
        g.tot = gn.tot = 1;
        srand(time(0));
        //freopen("H.in", "r", stdin);
        scanf("%d%d", &n, &m);
        for (int i = 1; i <= m; ++i) {
                int x, y;
                scanf("%d%d", &x, &y);
                if (con[x][y]) {
                        printf("-1\n");
                        return 0;
                }
                con[x][y] = con[y][x] = true;
                g.add(x, y);
                g.add(y, x);
        }
        for (int i = 1; i <= n; ++i) dfn[i] = -1;
        dfs(1, 0, 0);
        for (int i = 1; i <= n; ++i) if (!vis[i]) {
                vis[i] = true;
                symbol[++cbcc] = i;
                bcc[i] = cbcc;
                paint(i);
        }
        if (cbcc == 1) {
                printf("0\n");
                return 0;
        }
        if (cbcc == 2) {
                for (int i = 1; i <= n; ++i) for (int j = 1; j <= n; ++j) if (bcc[i] == 1 && bcc[j] == 2 && !con[i][j]) {
                        printf("1\n%d %d\n", i, j);
                        return 0;
                }
                printf("-1\n");
                return 0;
        }
        for (int i = 1; i <= n; ++i) for (int j = i + 1; j <= n; ++j) if (bcc[i] != bcc[j] && con[i][j]) {
                gn.add(bcc[i], bcc[j]);
                gn.add(bcc[j], bcc[i]);
                ++degree[bcc[i]];
                ++degree[bcc[j]];
        }
        clist = 0;
        for (int i = 1; i <= cbcc; ++i) if (degree[i] == 1) list[++clist] = i;
        while (1) {
                random_shuffle(list + 1, list + clist + 1);
                list[clist + 1] = list[1];
                cans = 0;
                for (int i = 1; i <= clist; i += 2)
                        ans[++cans] = make_pair(list[i], list[i + 1]);
                if (sevenkplus()) {
                        printf("%d\n", cans);
                        for (int i = 1; i <= cans; ++i) printf("%d %d\n", symbol[ans[i].first], symbol[ans[i].second]);
                        return 0;
                }
        }
}