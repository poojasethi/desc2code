/*
ID: keyvank2
TASK: combo
LANG: C++
*/

#include <bits/stdc++.h>

#define ff first
#define ss second
#define pb push_back
#define mp make_pair
#define FOR(i,j,k) for(int i = j; i < (int)(k); i++)
#define FORV(i, v) FOR(i, 0, ((v).size()))
#define REP(i,j,k) for(int i = j; i >= (int)(k); i--)
#define setmax(i) const int maxn = (int) i;
#define setmod(i) const int MOD = (int) i;
#define all(a) a.begin(),a.end()
#define autodef(x,v) typeof(v) x = (v)
#define autoref(x,v) typeof(v)& x = (v)
#define forit(it, c) for (autodef(it, ((c).begin())); it != ((c).end()); ++it)

//typedef complex<double> Point;
//#define X real()
//#define Y imag()

using namespace std;

//ifstream fin("");
//ofstream fout("");
//#define cin fin
//#define cout fout

typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef pair<ld,ld> pdd;
typedef pair<pii,int> ppi;
typedef pair<pll,ll> ppl;
typedef pair<int,pii> pip;
typedef pair<ll,pll> plp;
typedef pair<pii,pii> ppp;

const int INF = (int) 2e9;
const ll INFL = (ll) 9e18;
const int MAXINT = ((~0) ^ (1 << 31));
const ll MAXLL = ((~0) ^ ((ll)1 << 63));

template<class T> inline T pow2(T a) { return a*a;}
template<class T> inline bool mineq(T& a, T b){return (a > b) ? (a=b, true) : false;}
template<class T> inline bool maxeq(T& a, T b){return (a < b) ? (a=b, true) : false;}

//srand (time(NULL));

bool debug = 0;

setmax(51);
const int maxm = 1001;

int d[maxn][maxn*maxm];

struct adam
{
    int mn, mx, id;
    adam()
    {
	mn = INF;
	mx = -INF;
    }
    inline bool can(int l, int r, int aid, int bid)
    {
	if( d[id][l-1] - d[id][r] > 0)
	    return true;
	
	bool canl = d[id][l]- d[id][l-1];
	bool canr = d[id][r] - d[id][r-1]; 
	bool canidl = aid > id;
	bool canidr = id > bid;

	if(l == r)
	{
	    return  canl && canidl && canidr;
	}

	if( canl && canidl)
	{
	    return true;
	}
	return canr && canidr;
    }
} num[maxn];

int adj[maxn][maxn], n, m, s1, s2, g1 , g2;

void floyd()
{
    FOR(k,1,n+1)
    {
	FOR(i,1,n+1)
	{
	    FOR(j,1,n+1)
	    {
		mineq(adj[i][j], adj[i][k] + adj[k][j]);
	    }
	}
    }
}

ll dp[maxn][maxn], odp[maxn][maxn];

int main()
{
    ios_base::sync_with_stdio(0);cin.tie(0);
    
    FOR(i,0,maxn)
	FOR(j,0,maxn)
	    adj[i][j] = INF/2 * (i != j);

    cin >> n >> m;
    FOR(i,0,m)
    {
	int a,b,w;
	cin >> a >> b >> w;
	adj[a][b] = w;
	adj[b][a] = w;
    }
    cin >> g1 >> g2 >> s1 >> s2;

    floyd();

    FOR(i,1,n+1)
    {
	num[i].id = i;
	FOR(j,1,n+1)
	{
	    if(adj[i][j] == 0)
		continue;

	    d[i][adj[i][j]]++;
	    maxeq(num[i].mx, adj[i][j]);
	    mineq(num[i].mn, adj[i][j]);
	}
	FOR(j,1,maxn*maxm)
	    d[i][j] += d[i][j-1];
    }

    ll ans = 0;

    FOR(goldid,1,n+1)
    {
	FOR(bronzeid,1,n+1)
	{
	    if(goldid == bronzeid)
		continue;

	    int goldmn = num[goldid].mn;
	    int bronzemx = num[bronzeid].mx;

	    if(goldmn > bronzemx || (goldmn == bronzemx && bronzeid < goldid))
		continue;

	    memset(dp, 0, sizeof(dp));
	    dp[0][0] = true;

	    FOR(i,1,n+1)
	    {
	    	memcpy(odp, dp, sizeof(dp));
		memset(dp, 0, sizeof(dp));

		if(i == goldid)
		{
		    FOR(goldsize,1,n)
		    {
			FOR(bronzesize,0,n)
			{
			    dp[goldsize][bronzesize] = odp[goldsize-1][bronzesize];
			}
		    }
		    continue;
		}

		if(i == bronzeid)
		{
		    FOR(goldsize,0,n+1)
		    {
			FOR(bronzesize,1,n+1)
			{
			    dp[goldsize][bronzesize] = odp[goldsize][bronzesize-1];
			}
		    }
		    continue;
		}
		
		FOR(goldsize,0,n+1)
		{
		    FOR(bronzesize,0,n+1)
		    {
			ll & ans = dp[goldsize][bronzesize];

			if(num[i].mn < goldmn || (num[i].mn == goldmn && i < goldid))
			    if(goldsize)
				ans += odp[goldsize-1][bronzesize];

			if(num[i].mx > bronzemx || (num[i].mx == bronzemx && i > bronzeid))
			    if(bronzesize)
				ans += odp[goldsize][bronzesize-1];

			if(num[i].can(bronzemx,goldmn,bronzeid,goldid))
			    ans += odp[goldsize][bronzesize];

		    }
		}
	    }

	    FOR(i,g1,g2+1)
		FOR(j,s1,s2+1)
		    ans += dp[i][n-j-i];
	}
    }
    cout << ans;
}
