#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;

const int MAXN=3055;
int par[MAXN];
int used[MAXN];
vector<int> station[MAXN];
int n,i,a,b;

int dfs(int x, int lvl)
{
	used[x]=lvl;//if it back to itself, then it's in the ringroad, thus at lvl;

	int tmp=0;
	int b=0;
	for(int a=0;a<(int)station[x].size();a++)
	{
		b=station[x][a];
		if(b==x||b==par[x])	continue;//avoid cycle at once ex: 1->2 then 2->1

		if(used[b]>0)	return used[b];//if visited, then reach ringroad, return the value
		
		par[b]=x;
		tmp=dfs(b,lvl+1);//if not, do recursive until we reach the ringroad

		if(tmp>0)	return tmp;
	}

	return 0;
}


int main()
{
	//input
	cin>>n;
	for(i=0;i<n;i++)
	{
		cin>>a>>b;
		station[a].push_back(b);
		station[b].push_back(a);
	}

	//use dfs to do
	for(i=1;i<=n;i++)
	{
		memset(used,0,sizeof(used));
		memset(par,0,sizeof(par));
		cout<<dfs(i,1)-1<<" ";
	}
	cout<<"\n";
	return 0;
}
