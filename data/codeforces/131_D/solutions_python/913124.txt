from collections import deque

def dfs(g):
    global pv,in_cycle

    wh = [False]*(len(g))
    for i in range(1, len(g)):
        if not wh[i]:
            stack = [i]
            wh[i] = True
            flag = False
            while len(stack) > 0:
                if flag:
                    stack.pop()
                    if len(stack) > 0:
                        k = stack[-1]
                    else:
                        break
                else:
                    k = stack[-1]
                flag = True
                for v in g[k]:
                    if not wh[v]:
                        if flag:
                            stack.append(v)
                            pv[v] = k
                            wh[v] = True
                            flag = False
                    elif pv[k] != v and pv[v] != k:
                        nv = k
                        while nv != v:
                            in_cycle[nv] = True
                            nv = pv[nv]
                        in_cycle[v] = True
                        return

n = int(raw_input().strip())
g = [[] for _ in range(n+1)]
pv = [-1]*(n+1)
sc = -1
ec = -1
in_cycle = [False]*(n+1)
wl = [-1]*(n+1)

for i in range(n):
    v1,v2 = [int(v) for v in raw_input().strip().split(' ')]
    g[v1].append(v2)
    g[v2].append(v1)


dfs(g)

q = deque()
for i in range(1, n+1):
    if in_cycle[i]:
        wl[i] = 0
        q.append(i)

while len(q) > 0:
    nv = q.popleft()
    for v in g[nv]:
        if wl[v] == -1:
            wl[v] = wl[nv] + 1
            q.append(v)

print ' '.join([str(_) for _ in wl[1:]])


