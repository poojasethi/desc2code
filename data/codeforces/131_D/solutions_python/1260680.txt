from collections import defaultdict
import sys

sys.setrecursionlimit(10000)

n = int(sys.stdin.readline())
edges = []
for i in range(n):
    edges.append([int(v) for v in sys.stdin.readline().split(' ')])

vertices = defaultdict(list)
for e in edges:
    vertices[e[0]].append(e[1])
    vertices[e[1]].append(e[0])
#print vertices

discovered = [False for i in range(len(vertices) + 1)]
processed = [False for i in range(len(vertices) + 1)]
parent = [-1 for i in range(len(vertices) + 1)]
distances = [10000 for i in range(len(vertices) + 1)]

def dfs(start):
    discovered[start] = True
    for v in vertices[start]:
        process_edge(start, v)
        if not discovered[v]:
            parent[v] = start
            dfs(v)
    processed[start] = True

def process_edge(u, v):
    if discovered[v] and not processed[v] and v != parent[u]:
        #print 'back edge: %s -> %s' % (u, v)
        cycle_v = u
        while cycle_v != v:
            distances[cycle_v] = 0
            cycle_v = parent[cycle_v]
        distances[v] = 0
    elif not discovered[v]:
        #print 'tree edge: %s -> %s' % (u, v)
        pass

dfs(1)

def fill_distances(v):
    for child in vertices[v]:
        if distances[child] <= distances[v]:
            continue
        else:
            distances[child] = distances[v] + 1
            fill_distances(child)

for v in range(1, len(vertices) + 1):
    if distances[v] == 0:
        fill_distances(v)

print ' '.join(str(d) for d in distances[1:])
