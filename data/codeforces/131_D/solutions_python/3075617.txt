
import sys;
import io;
import math;
import bisect as bs;
import heapq;
import re;
from collections import deque;

# IO Method #

def read_int() :
	return map(int, raw_input().split());

def read_string() :
	return raw_input().split();

def read_float() :
	return map(float, raw_input().split());

# End #

# Data Structures #

class LinkedList :

	def __init__(self) :
		self.head = Node(); # Always null
		self.tail = Node(); # Always null
		self.now = Node(); # Init it first #
		# Create link #
		self.head.next = self.now;
		self.tail.prev = self.now;
		self.now.prev = self.head;
		self.now.next = self.tail;

		# Create attrib #
		self.__first = True;
		self.size = 0;

		pass

	def next(self) :
		return self.now.next;

	def prev(self) :
		return self.now.prev;

	def __setNow(self, data) :
		self.now.data = data;
		self.__first = False;
		pass

	def addFirst(self, data) :
		if self.__first :
			self.__setNow(data); 
		else :
			newNode = Node(data, self.head, self.head.next);
			self.head.next = newNode;
			newNode.next.prev = newNode;
			self.size += 1;
		pass

	def addLast(self, data) :
		if self.__first :
			self.__setNow(data); 
		else :
			newNode = Node(data, self.tail.prev, self.tail);
			self.tail.prev = newNode;
			newNode.prev.next = newNode;
			self.size += 1;
		pass

	def addNext(self, data) :
		if self.__first :
			self.__setNow(data); 
		else :
			newNode = Node(data, self.now, self.now.next);
			self.now.next = newNode;
			newNode.next.prev = newNode;
			self.size += 1;
		pass

	def addPrev(self, data) :
		if self.__first :
			self.__setNow(data); 
		else :
			newNode = Node(data, self.now.prev, self.now);
			self.now.prev = newNode;
			newNode.prev.next = newNode;
			self.size += 1;
		pass

	def toList(self) :
		currNode = self.head.next;
		res = [];
		while (currNode != self.tail) :
			res.append(currNode.data);
			currNode = currNode.next;
			pass
		return res;

	def __str__(self) :
		return str(self.toList());

class Node :

	def __init__(self, data = None, prev=None, next=None) :
		self.prev = prev;
		self.next = next;
		self.data = data;
		pass

	def __str__(self) :
		return str(self.data)



# Sys Setting #
sys.setrecursionlimit(10**6);

# End Setting #

# Main Entry #
if __name__ == '__main__': 
	
	tc = input();

	graph = [[] for x in xrange(tc+1)];

	for ii in xrange(tc) : 
		a, b = read_int();
		graph[a].append(b);
		graph[b].append(a);
	pass

	incycle = set();
	prev = [-1 for _ in xrange(tc+1)];
	visited = [0 for _ in xrange(tc+1)];

	def fcycle(now) :
		visited[now] = 1;
		for ii in xrange(len(graph[now])) :
			next = graph[now][ii];

			if (visited[next]==0) :
				prev[next] = now;
				fcycle(next);
			elif (visited[next]==1) :
				
				if next != prev[now] :
					curr = now;
					incycle.add(next);
					while curr != next :
						incycle.add(curr);
						curr = prev[curr];
					pass
			else :
				pass
		visited[now] = 2;

	fcycle(1);
	dist = [0 for _ in xrange(tc+1)];
	visited = [False for _ in xrange(tc+1)];
	q = deque();
	for ii in incycle :
		visited[ii] = True;
		q.append(ii);

	while len(q) != 0 :
		now = q.pop();
		for ii in xrange(len(graph[now])) :
			next = graph[now][ii];
			if visited[next] == False :
				q.append(next);
				dist[next] = dist[now] + 1;
				visited[next] = True;
				pass


		pass

	print re.sub(r'[\[\],]','',str(dist[1:]));



# End #
