# http://codeforces.com/problemset/problem/199/D

from collections import defaultdict, deque
from sys import stdin, setrecursionlimit
# Et stack pythonil otsa ei saaks
setrecursionlimit(10000)

def readNums(single=False):
    if single:
        return int(stdin.readline())
    return [int(x) for x in stdin.readline().split()]

stations = readNums(True)
neighbors = defaultdict(set)

for _ in range(stations):
    a, b = readNums()
    neighbors[a].add(b)
    neighbors[b].add(a)

def dfs(node, previous):
    # return (circle-end, circle-start) or None (if no cicle this way)
    # print node, previous, neighbors[node]
    for child in neighbors[node]:
        if previous[node] == child:
            continue
        if child in previous:
            return (node, child)
        previous[child] = node
        subresult = dfs(child, previous)
        if subresult is not None:
            return subresult
    return None

previous = {1: None}
cycle_end, cycle_start = dfs(1, previous)

# backtrack and set the nodes in cycle to be the starting points of bfs
cycle_stations = [cycle_start]
node = cycle_end
while node != cycle_start:
    cycle_stations.append(node)
    node = previous[node]

# print cycle_stations

# Do a bfs
def bfs(nodes):
    queue = deque([(node, 0) for node in nodes])
    visited = set(nodes)
    distances = {}
    while len(queue) > 0:
        node, distance = queue.pop()
        distances[node] = distance
        for neighbor in neighbors[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.appendleft((neighbor, distance+1))
    return distances

distances = bfs(cycle_stations)
print(' '.join(str(distances[node]) for node in range(1, stations+1)))