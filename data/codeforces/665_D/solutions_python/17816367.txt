from itertools import product

def get_primes_fast(n):
    if n < 2:
        return []
    if n < 3:
        return [2]

    lmtbf = (n - 3) / 2

    buf = [True] * (lmtbf + 1)
    for i in xrange((int(n ** 0.5) - 3) / 2 + 1):
        if buf[i]:
            p = i + i + 3
            s = p * (i + 1) + i
            buf[s::p] = [False] * ((lmtbf - s) / p + 1)

    return set([2] + [i + i + 3 for i, v in enumerate(buf) if v])


def get_simple_sum_pair(simples, nums1, nums2):
    for num1, num2 in product(nums1, nums2):
        if num1 + num2 in simples:
            return num1, num2
    return None


def get_beautiful_subset(nums):
    simples = get_primes_fast(max(nums) * 2 + 1)
    ones_count = 0
    odds = []
    evens = []
    has_2 = False

    for num in nums:
        if num == 1:
            ones_count += 1
        elif num % 2 == 0:
            if num == 2:
                has_2 = True
            evens.append(num)
        else:
            odds.append(num)

    if ones_count:
        pair = get_simple_sum_pair(simples, [1], evens)
        if pair:
            return [1] * ones_count + [pair[1]]

        if ones_count > 1:
            return [1] * ones_count

    pair = get_simple_sum_pair(simples, odds, evens)
    if pair:
        return list(pair)

    if has_2:
        return [2]

    singles = list(set(odds).intersection(simples))

    if singles:
        return singles[:1]

    return nums[:1]


raw_input()
nums = map(int, raw_input().split())

result = get_beautiful_subset(nums)
print len(result)
print ' '.join(map(str, result))
