#include <cstdio>
#include <algorithm>
#include <vector>
#include <string.h>
#define x first
#define y second
#define pb push_back
#define mp make_pair
using namespace std;
typedef long long LL;
typedef double ld;
const int NMax = 11000,INF=100000000;
int N,M,g,sex[NMax],cost[NMax],nn,L;
struct edge {
 int num,len;
 edge *next,*inv;
}*G[NMax*2],pool[2000*10*2+10000*2+2000*2+10];
void Build(int x,int y,int z) {
 edge *p=&pool[L++],*q=&pool[L++];
 p->num=y;p->len=z;p->next=G[x];G[x]=p;
 q->num=x;q->len=0;q->next=G[y];G[y]=q;
 p->inv=q;q->inv=p;
}
int Q[NMax*2],level[NMax*2];
int makelevel() {
 memset(level,-1,sizeof(level));
 Q[0]=level[0]=0;
 for(int i=0,bot=1;i<bot;i++) {
  int x=Q[i];
  for(edge *p=G[x];p;p=p->next)if(p->len) {
   if(level[p->num]==-1) {
		level[p->num]=level[x]+1;
		Q[bot++]=p->num;
	}
  }
 }
 return level[nn]!=-1;
}
int Find(int a,int alpha) {
	if(a==nn)return alpha;
	int cnt=0,tmp;
	for(edge *p=G[a];p&&cnt<alpha;p=p->next)if(p->len&&level[p->num]==level[a]+1) {
		if(tmp=Find(p->num,min(alpha-cnt,p->len))) {
			p->len-=tmp;
			p->inv->len+=tmp;
			cnt+=tmp;
		}
	}
	if(cnt==0) level[a]=-1;
	return cnt;
}
int Dinic() {
 int ret=0,tmp;
 while(makelevel())
  while(tmp=Find(0,INF))ret+=tmp;
 return ret;
}
int main()
{
 scanf("%d%d%d",&N,&M,&g);
 nn=N+M+1;
 int ret=0;
 for(int i=1;i<=N;i++)scanf("%d",sex+i);
 for(int i=1;i<=N;i++){
  scanf("%d",cost+i);
  if(sex[i]==0)Build(0,i,cost[i]);
  else Build(i,nn,cost[i]); 
 }
 for(int i=1;i<=M;i++) {
  int x,y,z;
  scanf("%d%d%d",&x,&y,&z);
  ret+=y;
  for(int j=1;j<=z;j++) {
   int t;
   scanf("%d",&t);
   if(x==0)Build(N+i,t,INF);
   else Build(t,N+i,INF); 
  }
  int t;
  scanf("%d",&t);
  if(t)y+=g;
  if(x==0) Build(0,N+i,y);
  else Build(N+i,nn,y);
 }
 printf("%d",ret-Dinic());
 getchar();getchar();
 return 0;
}
