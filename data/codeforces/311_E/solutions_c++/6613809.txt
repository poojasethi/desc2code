#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<vector>
#include<queue>
using namespace std;
struct edge{
	edge*nex,*rev;
	int v,c;
};
#define M 500000
#define N 50001
struct dinic{
	edge E[M];
	edge*etp,*G[N],*cur[N];
	int S,T,dis[N];
	dinic(){etp=E;}
	void addedge(int u,int v,int c){
		etp->v=v;etp->c=c;etp->nex=G[u];etp->rev=etp+1;G[u]=etp++;
		etp->v=u;etp->c=0;etp->nex=G[v];etp->rev=etp-1;G[v]=etp++;
	}int dfs(int u,int a){
		if(a==0||u==T)return a;
		int F=0,FF;
		for(edge*&e=cur[u];e;e=e->nex)
			if(dis[e->v]==dis[u]+1&&e->c>0&&(FF=dfs(e->v,min(a,e->c)))){
				F+=FF;
				a-=FF;
				e->c-=FF;
				e->rev->c+=FF;
				if(!a)return F;
			}
		return F;
	}
	queue<int>Q;
	bool bfs(){
		memset(dis,-1,sizeof dis);
		memcpy(cur,G,sizeof G);
		for(Q.push(S),dis[S]=0;!Q.empty();Q.pop()){
			int u=Q.front();
			for(edge*e=G[u];e;e=e->nex)
				if(e->c>0&&dis[e->v]==-1){
					dis[e->v]=dis[u]+1;
					Q.push(e->v);
				}
		}return dis[T]!=-1;
	}int maxflow(){
		int ans=0;
		while(bfs()){
			ans+=dfs(S,~0U>>1);
		}return ans;
	}
}calc;
int n,m,g,sex[N],val[N],ans;
int main(){
	scanf("%d%d%d",&n,&m,&g);
	int S=n+m+1,T=S+1;
	calc.S=S;calc.T=T;
	for(int i=1;i<=n;i++)scanf("%d",&sex[i]);
	for(int i=1;i<=n;i++){
		scanf("%d",&val[i]);
		if(sex[i]==0)calc.addedge(S,i,val[i]);
		else calc.addedge(i,T,val[i]);
	}
	int tot=n;
	for(int i=1;i<=m;i++){
		int expect,w,k,isfriend;
		scanf("%d%d%d",&expect,&w,&k);
		ans+=w;
		tot++;
		while(k--){
			int x;
			scanf("%d",&x);
			if(expect)calc.addedge(x,tot,~0U>>1);
			else calc.addedge(tot,x,~0U>>1);
		}scanf("%d",&isfriend);
		if(isfriend)w+=g;
		if(expect)calc.addedge(tot,T,w);
		else calc.addedge(S,tot,w);
	}printf("%d\n",ans-calc.maxflow());
}
