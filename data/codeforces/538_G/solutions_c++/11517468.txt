#include <cstdio>
#include <iostream>
#include <cstdlib>
#include <cmath>
#include <cassert>
#include <cstring>
#include <algorithm>
#include <string>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <sstream>
using namespace std;
#pragma comment(linker, "/STACK:255000000")

typedef long long ll;

#define rep(i, a, b) for(i = (a); i < (b); ++i)
#define repb(i, a, b) for(i = (a) - 1; i >= (b); --i)
#define repd(i, a, b, d) for(i = (a); i < (b); i += (d))
#define repbd(i, a, b, d) for(i = (a) - 1; i >= (b); i -= (d))
#define reps(i, s) for(i = 0; (s)[i]; ++i)
#define repl(i, l) for(i = l.begin(); i != l.end(); ++i)

#define in(f, a) scanf("%"#f, &(a))

bool firstout = 1;

#define out(f, a) printf("%"#f, (a))
#define outf(f, a) printf((firstout) ? "%"#f : " %"#f, (a)), firstout = 0
#define nl printf("\n"), firstout = 1

#define all(x) (x).begin(),(x).end()
#define sqr(x) ((x) * (x))
#define mp make_pair

template<class T>
T &minn(T &a, T b)
{
    if(b < a) a = b;
    return a;
}

template<class T>
T &maxx(T &a, T b)
{
    if(a < b) a = b;
    return a;
}

#define inf 1012345678
#define eps 1e-9


#ifdef XDEBUG
#define mod 23
#else
#define mod 1000000007
#endif

int &madd(int &a, int b)
{
    a += b;
    if(a >= mod) a -= mod;
    return a;
}

int &msub(int &a, int b)
{
    a -= b;
    if(a < 0) a += mod;
    return a;
}

int &mmult(int &a, int b)
{
    return a = (ll)a * b % mod;
}

int mdiv(ll a, ll b, ll m)
{
    a = (a % m + m) % m;
    b = (b % m + m) % m;
    if(a % b == 0) return a / b;
    return (a + m * mdiv(-a, m, b)) / b;
}

#define N 2012345
#define M 1012

char DS[5] = "ULDR";
int DX[4] = {1, -1, -1, 1};
int DY[4] = {-1, -1, 1, 1};

int n, m, q;
int RX[N], RY[N];
ll X[N], Y[N], T[N];
pair<pair<ll, ll>, pair<ll, ll> > P[N];

bool bld(ll *X, int *R, ll x) {
    ll a1 = 0;
    int i, j;
    j = 0;
    rep (i, 0, n) {
        ll a2 = X[i] - T[i] / m * x;
        ll t2 = T[i] % m;
        for (; j < t2; ++j) {
            if (a2 > a1) R[j] = 1;
            else R[j] = -1;
            a1 += R[j];
        }
        if (a1 != a2) return 0;
        a1 = a2;
    }
    ll a2 = x;
    ll t2 = m;
    for (; j < t2; ++j) {
        if (a2 > a1) R[j] = 1;
        else R[j] = -1;
        a1 += R[j];
    }
    if (a1 != a2) return 0;
    return 1;
}

bool fnd(ll *X, int *R) {
    ll mn = -m;
    ll mx = m;
    ll a1 = 0;
    ll k1 = 0;
    ll t1 = 0;
    int i;
    rep (i, 0, n) {
        ll a2 = X[i];
        ll k2 = T[i] / m;
        ll t2 = T[i] % m;
        ll t = t2 - t1;
        if (k1 == k2) {
            if (abs(a1 - a2) > t) return 0;
        } else if (k2 > k1) {
            minn(mx, (t - a1 + a2) / (k2 - k1));
            maxx(mn, (-t - a1 + a2) / (k2 - k1));
        } else {
            maxx(mn, (t - a1 + a2) / (k2 - k1));
            minn(mx, (-t - a1 + a2) / (k2 - k1));
        }
        a1 = a2;
        k1 = k2;
        t1 = t2;
    }
    ll t = m - t1;
    maxx(mn, (a1 - t) / (k1 + 1));
    minn(mx, (a1 + t) / (k1 + 1));
    if (mn > mx) return 0;
    if (!bld(X, R, mn)) {
        if (mn == mx) return 0;
        return bld(X, R, mn + 1);
    }
    return 1;
}

int main()
{
#ifdef XDEBUG
    freopen("in.txt", "rt", stdin);
#else
#endif

    int i, j, k;
    char c;
    int a, d;

    int ts;
#if 0
	int tss;
	in(d, tss);
	rep(ts, 1, tss + 1)
#else
    for(ts = 1; in(d, n) > 0; ++ts)
#endif
    {
        in(d, m);
        rep (i, 0, n) {
            in(I64d, T[i]);
            in(I64d, X[i]);
            in(I64d, Y[i]);
            P[i] = mp(mp(T[i] % m, T[i]), mp(X[i] + Y[i], X[i] - Y[i]));
        }
        sort(P, P + n);
        rep (i, 0, n) T[i] = P[i].first.second, X[i] = P[i].second.first, Y[i] = P[i].second.second;
        bool res = 1;
        minn(res, fnd(X, RX));
        minn(res, fnd(Y, RY));
        if (!res) out(s, "NO"), nl;
        else {
            rep (i, 0, m) {
                rep (j, 0, 4) if (DX[j] == RX[i] && DY[j] == RY[i]) break;
                out(c, DS[j]);
            }
            nl;
        }
    }

    return 0;
}
