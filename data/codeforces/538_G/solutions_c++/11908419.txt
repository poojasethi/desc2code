#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pii pair<int,int>
#define pll pair<ll,ll>
#define pdd pair<double,double>
#define X first
#define Y second
#define REP(i,a) for(int i=0;i<a;++i)
#define REPP(i,a,b) for(int i=a;i<b;++i)
#define FILL(a,x) memset(a,x,sizeof(a))
#define	foreach( gg,itit )	for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )
#define	mp make_pair
#define	pb push_back
#define sz(a) int((a).size())
#define all(a)  a.begin(), a.end()
#define	debug(ccc)	cout << #ccc << " = " << ccc << endl;
#define present(c,x) ((c).find(x) != (c).end())
const double eps = 1e-8;
#define EQ(a,b) (fabs((a)-(b))<eps)
inline int max(int a,int b){return a<b?b:a;}
inline int min(int a,int b){return a>b?b:a;}
inline ll max(ll a,ll b){return a<b?b:a;}
inline ll min(ll a,ll b){return a>b?b:a;}
const int mod = 1e9+7;
const int N = 1e6+10;
const ll inf = 1e18;
ll fl(ll x, ll y) {
    if (x >= 0) return x / y;	return x / y - (x % y ? 1 : 0);
}
ll cl(ll x, ll y) {
    if (x >= 0) return (x + y - 1) / y;    return x / y;
}

ll X[2*N],Y[2*N],T[2*N];
ll n,l;
vector < pair<ll, pll> > G;

vector <int> solve(vector <ll> S){
	G.clear();
	vector <int> ans;
	REP(i,S.size()){
		if((S[i]+T[i])%2)	return ans;
		S[i]=(S[i]+T[i])/2;
		G.pb(mp(T[i]%l,mp(-(T[i]/l),S[i])));
		
	}
	G.pb(mp(0,mp(0,0)));
	G.pb(mp(l,mp(1,0)));
	sort(all(G));
/*	REP(i,G.size()){
		printf("%lld %lld %lld\n",G[i].X,G[i].Y.X,G[i].Y.Y);
	}
*/	ll L=0,R=l;
	REP(i,G.size()-1){
		ll d=G[i+1].X-G[i].X;
		ll a=G[i+1].Y.X-G[i].Y.X;
		ll b=G[i+1].Y.Y-G[i].Y.Y;
		ll lh=-b,rh=d-b;
		if(!a){
			if(lh>0 && rh<0)	return ans;
		}else{
			if(a<0){
				a=-a;
				swap(lh,rh);
				lh=-lh;rh=-rh;
			}
			R=min(R,fl(rh,a));
			L=max(L,cl(lh,a));
		}
//		printf("hi%lld %lld %lld\n",a,b,d);
	}
//	printf("%lld %lld\n",L,R);
	if(L>R)	return ans;
	int s=0;
	REP(i,G.size()){
		while(s<G[i].Y.Y+L*G[i].Y.X){
			ans.pb(1);s++;
		}
		while (ans.size() < G[i].X) ans.pb(0);
    
	}
	return ans;
}


int main(){
	
	scanf("%lld %lld",&n,&l);
	vector <ll> X1,X2;
	REP(i,n){
		scanf("%lld %lld %lld",&T[i],&X[i],&Y[i]);
		X1.pb(X[i]+Y[i]);X2.pb(X[i]-Y[i]);
	}
	vector <int > ans1 = solve(X1);
	vector <int > ans2 = solve(X2);
	if(!ans1.size() || !ans2.size()){
		printf("NO\n");
	}else{
		REP(i,l)	printf("%c","LDUR"[2 * ans1[i] + ans2[i]]);
		printf("\n");
	}

  return 0;
}
