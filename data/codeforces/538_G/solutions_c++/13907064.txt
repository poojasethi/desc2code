#include <set>
#include <map>
#include <cmath>
#include <ctime>
#include <cctype>
#include <cstdio>
#include <vector>
#include <cassert>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#define fi first
#define se second
#define mk make_pair
#define pb push_back
#define For(i,a,n)  for(int i=(a);i<=(n);i++)
#define Forn(i,a,n) for(int i=(a);i>=(n);i--)
using namespace std;
typedef long long ll;
typedef long double db;
const int N=200005;
const int L=2000005;

inline int IN(){
	char ch=getchar(); int f=1,x=0;
	while((ch<'0'||ch>'9')&&(ch!='-')) ch=getchar();
	if(ch=='-') f=-1,ch=getchar();
	while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	return x*f;
}

int n,l;
ll t[N],x[N],y[N],ans[2][L];
struct nod{
	ll r,x,t;
}b[N];

void fail() {puts("NO");exit(0);}

char Judge(ll x,ll y){
	if(x==1 && y==1)	return 'U';
	if(x==1 && y==-1)	return 'R';
	if(x==-1 && y==-1)	return 'D';
	if(x==-1 && y==1)	return 'L';
	return 'E';
}

inline int cmp(const nod &a,const nod &b){return a.r<b.r;}

bool C[5];
void work(ll *t,ll *a,ll *Ans){
	int N=0;
	For(i,1,n) b[++N]=(nod){t[i]%l,a[i],t[i]/l};
	b[++N]=(nod){0ll,0ll,0ll}; b[++N]=(nod){l,0ll,-1ll};
	sort(b+1,b+N+1,cmp);
	C[0]=C[1]=1; ll Tl=-l,Tr=l;
	For(i,1,N-1){
		ll dr=b[i+1].r-b[i].r,dx=b[i+1].x-b[i].x,dt=b[i+1].t-b[i].t;
		ll up=dx+dr,dn=dx-dr;
		if(dt&1) C[(up&1)^1]=0;else if(up&1) fail();
		if(dt==0)continue;
		if(dt<0) dt=-dt,up=-up,dn=-dn,swap(up,dn);
		if(up>=0) Tr=min(Tr,up/dt);else Tr=min(Tr,(up+1)/dt-1);
		if(dn>0) Tl=max(Tl,(dn-1)/dt+1);else Tl=max(Tl,dn/dt);
	}
	if(Tl>Tr || (!C[0] && !C[1])) fail();
	if(!C[Tl&1]) Tl++;
	if(Tl>Tr) fail();
	For(i,1,N-1){
		ll t=(b[i+1].x-b[i+1].t*Tl)-(b[i].x-b[i].t*Tl);
		For(j,b[i].r+1,b[i+1].r) Ans[j]=(t>0)?(1):(-1),t-=Ans[j];
	}
}

int main(){
	scanf("%d%d",&n,&l);
	For(i,1,n) scanf("%I64d%I64d%I64d",&t[i],&x[i],&y[i]);
	For(i,1,n){
		ll xx=x[i],yy=y[i];
		x[i]=yy+xx;
		y[i]=yy-xx;
	}
	work(t,x,ans[0]);
	work(t,y,ans[1]);
	For(i,1,l) putchar(Judge(ans[0][i],ans[1][i]));
	return 0;
}
