from functools import reduce

def scc(vertices, edges):
    identified = set()
    stack = []
    index = {}
    boundaries = []

    for v in vertices:
        if v not in index:
            to_do = [('VISIT', v)]
            while to_do:
                operation_type, v = to_do.pop()
                if operation_type == 'VISIT':
                    index[v] = len(stack)
                    stack.append(v)
                    boundaries.append(index[v])
                    to_do.append(('POSTVISIT', v))
                    to_do.extend(
                        reversed([('VISITEDGE', w) for w in edges[v]]))
                elif operation_type == 'VISITEDGE':
                    if v not in index:
                        to_do.append(('VISIT', v))
                    elif v not in identified:
                        while index[v] < boundaries[-1]:
                            boundaries.pop()
                else:
                    if boundaries[-1] == index[v]:
                        boundaries.pop()
                        scc = set(stack[index[v]:])
                        del stack[index[v]:]
                        identified.update(scc)
                        yield scc

def minc(C, s):
    m = 10**9
    for k in s:
        if C[k] < m:
            m = C[k]

    h = 0
    for k in s:
        if C[k] == m:
            h = h + 1
    return m, h

def main():
    n = int(raw_input())
    C = [int(i) for i in raw_input().strip().split(" ")]
    m = int(raw_input())

    R = { }
    for i in range(n):
        R[i] = []

    for k in range(m):
        s,t = [int(i) for i in raw_input().strip().split(" ")]
        R[s-1].append(t-1)
    
    res = 0
    pos = 1
    for L in scc(range(n), R):
        m, h = minc(C, L)
        res = res + m
        pos = pos * h % (10**9 + 7) 

    print res, pos

    return 0

if __name__ == "__main__":
    main()
