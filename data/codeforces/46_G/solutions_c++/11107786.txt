#include <iostream>
#include <vector>
#include <map>
#include <algorithm>
#include <cmath>
#include <cstdlib>

using namespace std;

typedef pair<int,int> point;

int prodvec(point p1,point p2)
{
  return p1.first*p2.second-p1.second*p2.first;
}

point operator+(point p1,point p2)
{
  return point(p1.first+p2.first,p1.second+p2.second);
}

point operator-(point p1,point p2)
{
  return point(p1.first-p2.first,p1.second-p2.second);
}

point q2(point p)
{
  return point(-p.first,p.second);
}

point q3(point p)
{
  return point(-p.first,-p.second);
}

point q4(point p)
{
  return point(p.first,-p.second);
}

int norm(point p)
{
  if (p.first*p.first+p.second*p.second>1000000000) {
    cout<<"pifia1"<<endl;
    exit(0);
  }
  return p.first*p.first+p.second*p.second;
}

bool compara(point p1,point p2)
{
  return norm(p1)<norm(p2);
}

bool comparaangulo(point p1,point p2)
{
  //if (p2.first==0 and p2.second==0) return false;
  //if (p1.first==0 and p1.second==0) return true;

  if ((p1.first==0 and p1.second==0) or (p2.first==0 and p2.second==0)) {
    cout<<"pifia2"<<endl;
    exit(0);
  }
  if (p1.second<0 or (p1.second==0 and p1.first<0)) {
    if (p2.second<0 or (p2.second==0 and p2.first<0))
      return prodvec(p1,p2)>0;
    else
      return true;
  } else if (p2.second<0 or (p2.second==0 and p2.first<0)) {
    return false;
  } else return prodvec(p1,p2)>0;

  //return atan2(p1.second,p1.first)<atan2(p2.second,p2.first);
}

vector<vector<point> > v;

bool camino(int iv,point p,vector<point> &sol)
{
  if (iv==-1) return p.first==0 and p.second==0;
  vector<point> &w=v[iv];
  for (int i=0;i<int(w.size());i++) {
    sol[iv]=w[i];
    if (camino(iv-1,p+w[i],sol)) return true;
    sol[iv]=q2(w[i]);
    if (camino(iv-1,p+q2(w[i]),sol)) return true;
    sol[iv]=q3(w[i]);
    if (camino(iv-1,p+q3(w[i]),sol)) return true;
    sol[iv]=q4(w[i]);
    if (camino(iv-1,p+q4(w[i]),sol)) return true;
  }
  return false;
}

vector<point> camino(int iv,point p)
{
  vector<point> sol(iv+1);
  if (not camino(iv,p,sol)) {
    cout<<"pifia3"<<endl;
    exit(0);
  }
  return sol;
}

int main()
{
  int n;
  cin>>n;
  int r=200;
  /*
  int r=1;
  while (r*r<=n) r++;
  r*=20;
  */
  map<int,vector<point> > mapa;
  for (int i=0;i<=r;i++)
    for (int j=0;j<=r;j++)
      if (i!=0 or j!=0)
	mapa[i*i+j*j].push_back(point(i,j));
  for (map<int,vector<point> >::iterator it=mapa.begin();it!=mapa.end();it++)
    v.push_back(it->second);
  int suma=0;
  int iimpar;
  int ipar;
  for (int i=0;i<n;i++) {
    suma+=norm(v[i][0]);
    if (norm(v[i][0])%2)
      iimpar=i;
    else
      ipar=i;
  }
  if (suma%2) {
    if (norm(v[n][0])%2)
      for (;ipar<n;ipar++)
	swap(v[ipar],v[ipar+1]);
    else
      for (;iimpar<n;iimpar++)
	swap(v[iimpar],v[iimpar+1]);
  }
  vector<point> sol;
  point p=v[n-1][0];
  sol.push_back(p);
  if (sol.back().first==0 and sol.back().second==0) {
    cout<<"pifia6"<<endl;
    exit(0);
  }
  {
    int i=n-2;
    for (;i>=7;i--) {
      vector<point> &w=v[i];
      vector<point> nextp;
      for (int j=0;j<int(w.size());j++) {
	nextp.push_back(p+w[j]);
	nextp.push_back(p+q2(w[j]));
	nextp.push_back(p+q3(w[j]));
	nextp.push_back(p+q4(w[j]));
      }
      sort(nextp.begin(),nextp.end(),compara);
      sol.push_back(nextp[0]-p);
      if (sol.back().first==0 and sol.back().second==0) {
	cout<<"pifia4"<<endl;
	exit(0);
      }
      p=nextp[0];
    }
    vector<point> solaux=camino(i,p);
    //cout<<int(sol.size())<<" "<<int(solaux.size())<<endl;
    for (int j=0;j<int(solaux.size());j++) {
      sol.push_back(solaux[j]);
      if (sol.back().first==0 and sol.back().second==0) {
	cout<<"pifia5"<<endl;
	exit(0);
      }
    }
  }
  /*
  for (int i=0;i<int(sol.size());i++)
    cout<<"("<<sol[i].first<<","<<sol[i].second<<")";
  cout<<endl;
  */
  for (int i=0;i<int(sol.size());i++) {
    if (sol[i].first==0 and sol[i].second==0) {
      cout<<"pifia7"<<endl;
      exit(0);
    }
  }
  
  sort(sol.begin(),sol.end(),comparaangulo);
  /*
  for (int i=0;i<n;i++)
    for (int j=i+1;j<n;j++)
      if (comparaangulo(sol[j],sol[i]))
	swap(sol[j],sol[i]);
  */
  p=point(0,0);
  cout<<"YES"<<endl;
  //cout<<p.first<<" "<<p.second<<endl;
  for (int i=0;i<int(sol.size());i++) {
    cout<<p.first<<" "<<p.second<<endl;
    p=p+sol[i];
  }
}
