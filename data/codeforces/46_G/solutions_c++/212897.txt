#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <string>
#include <cmath>
#include <climits>
#include <vector>
#include <map>
#include <set>
#include <iterator>
#include <utility>
#include <numeric>
#include <memory>
#include <stack>
#include <deque>
#include <queue>
#include <list>
#include <functional>
#include <iomanip>
#include <sstream>
#include <cctype>
#include <bitset>

#define X first
#define Y second
#define MAX(x, y) x = x > (y) ? x : (y)
#define MIN(x, y) x = x > (y) ? (y) : x
#define LOW(x) ((x) & -(x))
#define SQR(x) ((x) * (x))
#define REP(i, n) for (int i = 0; i < (n); ++i)
#define FOR(i, a, b) for (int i = (a); i < (b); ++i)
#define rFOR(i, b, a) for (int i = (b); i > (a); --i)
#define CLEAR(x) memset(x, 0, sizeof(x))
#define FILL(x, p) memset(x, p, sizeof(x))
#define COPY(x, y) memcpy(x, y, sizeof(x))
#define ALL(x) (x).begin(), (x).end()

using namespace std;

typedef long long ll;
typedef unsigned int ui;
typedef pair<int, int> PII;
typedef vector<PII> VPII;
typedef vector<int> VI;
typedef vector<string> VS;

const int INF = 0x3fffffff;
const ll _INF = 0x7ffffffffffffffll;
const double EPS = 1e-9;
const double PI = acos(-1.0);

template<class T, class INT>
inline T pow(T x, INT y)
{
	T res(1);
	for (T tt(x); y; y /= 2)
	{
		if (y & 1) res *= tt;
		tt *= tt;
	}
	return res;
}

template<class T, class INT>
inline T pow(T x, INT y, T p)
{
	T res(1);
	for (T tt(x); y; y /= 2)
	{
		if (y & 1) res = res * tt % p;
		tt = tt * tt % p;
	}
	return res;
}

int toInt(string s)
{
	int x = 0;
	istringstream sin(s);
	sin >> x;
	return x;
}

template<class T>
inline string toString(T x)
{
	ostringstream sout;
	sout << x;
	return sout.str();
}

template<class INT>
inline INT gcd(INT x, INT y)
{
	return y ? gcd(y, x % y) : x;
}

template<class INT>
inline int calc_bits(INT x)
{
	return x ? (x & 1) + calc_bits(x >> 1) : 0;
}

const int MAXD = 80000 + 10;
const int MAXM = 200 + 1;

int tmp, sumx, sumy, cnt, n;
VPII a;
bool check[MAXD];
struct Graph
{
	int head[MAXM], next[MAXD], vis[MAXD], tot;
	inline void add(int u, int v)
	{
		next[++tot] = head[u];
		vis[head[u] = tot] = v;
	}
} x, y;

inline int abs(PII a)
{
	return SQR(a.X) + SQR(a.Y);
}

inline bool cmp(PII a, PII b)
{
	return atan2(a.Y, a.X) < atan2(b.Y, b.X) - EPS;
}

inline bool _cmp(PII a, PII b)
{
	return abs(a) < abs(b);
}

int main(int argc, char* argv[])
{
	REP(i, MAXM)
		REP(j, MAXM)
		{
			tmp = abs(PII(i, j));
			if (!check[tmp]) check[tmp] = true, a.push_back(PII(i, j));
		}
	cin >> n;
	sort(ALL(a), _cmp);
	REP(i, n + 1) sumx += a[i].X, sumy += a[i].Y;
	if (sumx + sumy & 1)
	{
		sumx += a[n + 1].X, sumy += a[n + 1].Y;
		rFOR(i, n, 0)
			if (!(sumx - a[i].X & 1) && !(sumy - a[i].Y & 1))
			{
				swap(a[i], a[n + 1]);
				break;
			}
	}
	else if (sumx & 1)
		FOR(i, 1, n + 1)
			if (a[i].X + a[i].Y & 1)
			{
				swap(a[i].X, a[i].Y);
				break;
			}
	FOR(i, 1, n + 1)
		x.add(a[i].X, i), y.add(a[i].Y, i);
	rFOR(i, 200, 0)
		for (int j = x.head[i]; j; j = x.next[j])
			if (cnt > 0) a[x.vis[j]].X = -a[x.vis[j]].X, cnt -= i;
			else cnt += i;
	rFOR(i, 200, 0)
		for (int j = y.head[i]; j; j = y.next[j])
			if (cnt > 0) a[y.vis[j]].Y = -a[y.vis[j]].Y, cnt -= i;
			else cnt += i;
	sort(a.begin() + 1, a.begin() + n + 1, cmp);
	sumx = sumy = 0;
	cout << "YES" << endl;
	FOR(i, 1, n + 1)
	{
		cout << sumx << " " << sumy << endl;
		sumx += a[i].X, sumy += a[i].Y;
	}
}
