#include <cstdio>
#include <cstdlib>
#include <algorithm>
int n,a[200001];
struct inf{int v,f;}t[100001];
bool operator < (const inf& t1,const inf& t2)
{return t1.v<t2.v;}

struct fwt
{
	long long s[100001];
	inline int lb(int k){return k&(-k);}
	void modify(int ind,int v)
	{while(ind<=n){s[ind]+=v;ind+=lb(ind);}}
	long long getsum(int ind)
	{
		long long res=0;
		while(ind>=1){res+=s[ind];ind-=lb(ind);}
		return res;
	}
}tree1,tree2;
int main()
{
	long long k,now=0;
	scanf("%d%I64d",&n,&k);
	for(int i=1;i<=n;i++)
	{scanf("%d",&t[i].v);t[i].f=i;}
	std::sort(t+1,t+n+1);
	int j=0,v=-1;
	for(int i=1;i<=n;i++)
	{
		if(t[i].v>v){v=t[i].v;++j;}
		a[t[i].f]=j;
	}
	tree1.modify(a[1],1);
	for(int i=2;i<=n;i++)
	{
		now+=(long long)(i-1)-(tree1.getsum(a[i])+tree2.getsum(a[i]));
		tree2.modify(a[i],1);
	}
	int r=2;long long ans=0;
	if(now<=k)ans=(long long)(n)*(long long)(n-1)/2;
	else
	{
		for(int l=1;l<n;l++)
		{
			while(r<=n&&now>k)
			{
				now-=tree2.getsum(a[r]-1)+(l-tree1.getsum(a[r]));
				tree2.modify(a[r],-1);
				r++;
			}
			if(r<=n)ans+=n-r+1;
			else break;
			now+=(l-tree1.getsum(a[l+1]))+tree2.getsum(a[l+1]-1);
			tree1.modify(a[l+1],1);
			//printf("l=%d,r=%d\n",l,r);
		}

	}
	printf("%I64d\n",ans);
//	system("pause");
}
