#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

typedef long long ll;

int n;
ll Mod;

struct Matrix
{
	ll mat[6][6];
	Matrix operator*(const Matrix& m) const
	{
		Matrix tmp;
		for(int i=0;i<6;++i)
			for(int j=0;j<6;++j)
			{
				tmp.mat[i][j]=0;
				for(int k=0;k<6;++k)
					tmp.mat[i][j]+=mat[i][k]*m.mat[k][j];
				tmp.mat[i][j]=(tmp.mat[i][j]+10*Mod)%Mod;
			}
		return tmp;
	}
	Matrix pow(ll exp)
	{
		Matrix tmp;
		for(int i=0;i<6;++i)
			for(int j=0;j<6;++j)
				tmp.mat[i][j]=(i==j);
		Matrix base=*this;
		while(exp)
		{
			if(exp&1) tmp=tmp*base;
			base=base*base;
			exp>>=1;
		}
		return tmp;
	}
};

ll pm[6][6]={
	{2,1,1,1,0,0},
	{1,2,1,1,0,0},
	{1,0,1,0,0,0},
	{0,1,0,1,0,0},
	{1,1,1,1,1,0},
	{0,0,0,0,1,1},
};

int main()
{
	cin>>n;
	Mod=n;
	ll sx,sy,dx,dy,t;
	cin>>sx>>sy>>dx>>dy>>t;
	Matrix tmp;
	memcpy(tmp.mat,pm,sizeof(pm));
	tmp=tmp.pow(t);
	/*for(int i=0;i<6;++i)
	{
		for(int j=0;j<6;++j)
			cout<<tmp.mat[i][j]<<" ";
		cout<<endl;
	}*/
	ll x=sx*tmp.mat[0][0]+sy*tmp.mat[1][0]+dx*tmp.mat[2][0]+dy*tmp.mat[3][0]+tmp.mat[5][0];
	x=(x-1+100*Mod)%Mod+1;
	ll y=sx*tmp.mat[0][1]+sy*tmp.mat[1][1]+dx*tmp.mat[2][1]+dy*tmp.mat[3][1]+tmp.mat[5][1];
	y=(y-1+100*Mod)%Mod+1;
	cout<<x<<" "<<y<<endl;
}
