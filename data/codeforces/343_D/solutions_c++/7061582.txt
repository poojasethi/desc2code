// by zhj
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<vector>
#define N 510000
using namespace std;
vector <int> E[N];
int i,j,k,l,x,type,y,dfn[N],dfn2[N],tim,n,m;
struct seg_tree{
	int s[N*4],sign[N*4];
	void cover(int p,int l,int r,int x,int y,int k){
		if(x<=l && y>=r){
			s[p]=sign[p]=k;
			return;
		}
		int mid=l+r>>1;
		if(x<=mid)cover(p<<1,l,mid,x,y,k);
		if(y>mid)cover((p<<1)+1,mid+1,r,x,y,k);
		s[p]=max(s[p<<1],s[(p<<1)+1]);
	}
	int calc(int p,int l,int r,int x,int y){
		if(x<=l && y>=r)return s[p];
		int mid=l+r>>1,res=0;
		if(x<=mid)res=max(res,calc(p<<1,l,mid,x,y));
		if(y>mid)res=max(res,calc((p<<1)+1,mid+1,r,x,y));
		return max(sign[p],res);
	}
}T1,T2;	
void dfs(int x,int ff){
	dfn[x]=++tim;
	for(int i=E[x].size()-1;i>=0;--i)if(E[x][i]!=ff)
		dfs(E[x][i],x);
	dfn2[x]=tim;
}
int main(){
	scanf("%d",&n);
	for(i=1;i<n;++i){
		scanf("%d%d",&x,&y);
		E[x].push_back(y);
		E[y].push_back(x);
	}
	dfs(1,0);
	scanf("%d",&m);
	for(i=1;i<=m;++i){
		scanf("%d%d",&type,&x);
		if(type==1){
			T1.cover(1,1,n,dfn[x],dfn2[x],i);
		}
		if(type==2){
			T2.cover(1,1,n,dfn[x],dfn[x],i);
		}
		if(type==3){
			int v1=T1.calc(1,1,n,dfn[x],dfn[x]);
			int v2=T2.calc(1,1,n,dfn[x],dfn2[x]);
			if(v2>=v1)puts("0");
			else puts("1");
		}
	}
}
