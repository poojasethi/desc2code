#include<stdio.h>
#include<string.h>
#define yt eg[i].to
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1
const int N=500005;
int v[N],l[N],r[N],cnt,id;
bool mem[N];
	
struct Edge{
	int to,next;
}eg[N<<1];
	
void add(int x, int y){
	eg[cnt].to=y;
	eg[cnt].next=v[x];
	v[x]=cnt++;
}	
inline int max(int a,int b){
	return a>b?a:b;
}	
void dfs(int x){
	l[x]=++id;
	mem[x]=1;
	for(int i=v[x];i!=-1;i=eg[i].next)
		if(!mem[yt]) dfs(yt);
	r[x]=id;
}	
struct SegmentTree{
	int lz[N<<2],w[N<<2];
	void pushup(int rt){
		w[rt]=max(w[rt<<1],w[rt<<1|1]);
	}	
	void pushdown(int rt){
		if(lz[rt]!=0){
			lz[rt<<1]=lz[rt];
			lz[rt<<1|1]=lz[rt];
			w[rt<<1]=lz[rt];
			w[rt<<1|1]=lz[rt];
			lz[rt]=0;
		}
	}	
	void update(int L,int R,int c,int l,int r,int rt){
		if(L<=l&&r<=R){
			lz[rt]=w[rt]=c;
			return;
		}
		pushdown(rt);
		int m=(l+r)>>1;
		if(L<=m) update(L,R,c,lson);
		if(m<R) update(L,R,c,rson);
		pushup(rt);
	}	
	int query(int L,int R,int l,int r,int rt){
		if(L<=l&&r<=R) return w[rt];
		pushdown(rt);
		int m=(l+r)>>1,ret=0;
		if(L<=m) ret=max(ret,query(L,R,lson));
		if(m<R) ret=max(ret,query(L,R,rson));
		return ret;
	}
}A,B;
	
int main(){
	int i,j,n,m,k,x,y,op;
	scanf("%d",&n);
	memset(v,-1,4*(n+1));
	for(cnt=id=i=0;i<n-1;i++){
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1);
	scanf("%d",&m);
	for(i=1;i<=m;i++){
		scanf("%d%d",&op,&k);
		if(op==1) A.update(l[k],r[k],i,1,n,1);
		else if(op==2) B.update(l[k],l[k],i,1,n,1);
		else printf("%d\n",A.query(l[k],l[k],1,n,1)>B.query(l[k],r[k],1,n,1));
	}
	return 0;
}	