#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<set>
using namespace std;
const int N=5e5+10;
int head[N],now;
int fa[N],ll[N],rr[N],cnt;
set<int>Q;
void init(){
     memset(head,-1,sizeof(head));
     memset(rr,0,sizeof(rr));
     memset(ll,0,sizeof(ll));
     memset(fa,0,sizeof(fa));
     now=0;
     cnt=0;
}
struct Node{
  int v;
  int next;
}edge[N*2];
void add(int u,int v){
   edge[cnt].v=v;
   edge[cnt].next=head[u];
   head[u]=cnt++;
}
void DFS(int u,int f){
     ll[u]=rr[u]=++now;
     Q.insert(now);
     fa[u]=f;
     for(int i=head[u];i!=-1;i=edge[i].next){
        int v=edge[i].v;
        if(v!=f)
            DFS(v,u);
     }
     rr[u]=now;
}
int n,m,t1,t2;
int main(){
    while(~scanf("%d",&n)){
            init();
        for(int i=1;i<n;i++){
            scanf("%d%d",&t1,&t2);
            add(t1,t2);add(t2,t1);
        }
        DFS(1,0);
        scanf("%d",&m);
        for(int i=1;i<=m;i++){
            scanf("%d%d",&t1,&t2);
            if(t1==1){
                  bool flag=false;
                set<int>::iterator it=Q.lower_bound(ll[t2]);
                if(it==Q.end()||(*it)>rr[t2])
                   flag=true;
            Q.erase(Q.lower_bound(ll[t2]),Q.upper_bound(rr[t2]));
                if(!flag&&t2!=1)
                    Q.insert(ll[fa[t2]]);
            }
            else if(t1==2){
                Q.insert(ll[t2]);
            }
            else {
                set<int>::iterator it=Q.lower_bound(ll[t2]);
                if(it==Q.end()||(*it)>rr[t2])
                   printf("1\n");
                   else
                    printf("0\n");
            }
        }
    }
}
