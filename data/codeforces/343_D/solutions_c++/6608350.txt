#include <set>
#include <cmath>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
#define rep(i,a,b) for (int i=a;i<=b;++i)
#define dep(i,a,b) for (int i=a;i>=b;--i)
typedef long long ll;

const int nn=510000,INF=100000000;
vector<int> E[nn];
int l[nn],r[nn],ti,n;

void dfs(int x,int fa){
	l[x]=++ti;
	for (int i=0;i<E[x].size();++i)
	{
		if (E[x][i] == fa) continue;
		dfs(E[x][i],x);
	}
	r[x]=ti;
} 
void Init(){
	scanf("%d",&n);
	rep(i,1,n-1)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		E[u].push_back(v);
		E[v].push_back(u);
	}
	dfs(1,-1);
}
struct tree{
int a[nn*5],aa[nn*5];
void mark(int p,int x)
{
	if (!p) return;
	a[p]=max(a[p],x);aa[p]=max(x,aa[p]);
}
void push(int p)
{
	if (!p) return;
	if (aa[p])
	{
		mark(p<<1,aa[p]);
		mark((p<<1)+1,aa[p]);
		aa[p]=0; 
	}
}
void update(int p)
{
	if (!p) return;
	a[p]=max(a[p<<1],a[(p<<1)+1]);
}
void insert(int p,int l,int r,int x,int y,int z)
{
	if (y<l || r<x) return;
	if (x<=l && r<=y)
	{
		mark(p,z);
		return;
	}
	push(p);
	int mid=l+r>>1,lc=p<<1,rc=lc+1;
	insert(lc,l,mid,x,y,z);
	insert(rc,mid+1,r,x,y,z);
	update(p);
}
int query(int p,int l,int r,int x,int y)
{
	if (y<l || r<x) return 0;	
	if (x<=l && r<=y)
	{
		return a[p];
	}
	push(p);
	int mid=l+r>>1,lc=p<<1,rc=lc+1;
	return max(query(lc,l,mid,x,y),query(rc,mid+1,r,x,y));
}
} t1,t2;
void Work(){
	int m; scanf("%d",&m);
	rep(i,1,m)
	{
		int opt,x; scanf("%d%d",&opt,&x);
		if (opt == 1) t1.insert(1,1,n,l[x],r[x],i);
		else if (opt == 2) t2.insert(1,1,n,l[x],l[x],i);
		else printf("%d\n",t1.query(1,1,n,l[x],l[x])>t2.query(1,1,n,l[x],r[x]));
	}
}
int main()
{
	Init();
	Work();
	return 0;
}


