#include<bits/stdc++.h>
using namespace std;
const int N = 1 << 19;
vector <int> adj[N];
set <int> Empty;
int Left[N], Right[N], parent[N], T = 0;

void DFS(int v,int pa){
    bool flag = false;
    Left[v] = ++T;
    for(int i = 0; i < adj[v].size(); i++){
        int t = adj[v][i];
        if(t != pa){
            flag = true;
            parent[t] = v;
            DFS(t,v);
        }
    }
    Right[v] = ++T;
    if(!flag) Empty.insert(Left[v]);
}

int main(){
    //freopen("waterstation.inp", "r", stdin);
    //freopen("waterstation.out", "w", stdout);
    int n, q;
    scanf("%d",&n);
    for(int u, v, i = 0; i < n-1; i++){
        scanf("%d%d",&u,&v);
        --u,--v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    parent[0] = -1;
    DFS(0,-1);
    scanf("%d",&q);
    set<int>::iterator it;
    for(int c, v, i = 0; i < q; i++){
        scanf("%d%d",&c,&v);
        --v;
        switch(c){
            case 1:
            {
                if(parent[v] != -1){
                    it = Empty.lower_bound( Left[parent[v]] );
                    if(it != Empty.end() && (*it) <= Right[parent[v]]){
                        Empty.insert(Left[parent[v]]);
                    }
                }
                Empty.erase(Empty.lower_bound(Left[v]), Empty.upper_bound(Right[v]));
                break;
            }
            case 2:
            {
                Empty.insert( Left[v] );
                break;
            }
            case 3:
            {
                it = Empty.lower_bound( Left[v] );
                int res = 1;
                if(it != Empty.end() && (*it) <= Right[v]) res = 0;
                printf("%d\n", res);
            }
        }
    }
    return 0;
}
