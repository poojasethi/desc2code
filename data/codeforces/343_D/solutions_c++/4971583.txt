#include<iostream>
#include<cstdio>
#include<map>
#include<string.h>
using namespace std;

#define MAXN 501010

int L[MAXN],R[MAXN],data[MAXN<<3][2];

struct Node{
		int v;
		Node *next;
}space[MAXN<<1],*edge[MAXN];

int C,cnt;

void addedge(int x,int y) {
	Node *p=&space[C++];
	p->v=y; p->next=edge[x]; edge[x]=p;
}

void dfs(int x,int fa) {
	L[x]=++cnt;
	for (Node *p=edge[x]; p; p=p->next)
		if (p->v!=fa) dfs(p->v,x);
	R[x]=++cnt;
}

void pushup(int rt) {
	data[rt][1]=max(data[rt<<1][1],data[rt<<1|1][1]);
}

void pushdown(int rt) {
	data[rt<<1][0]=max(data[rt<<1][0],data[rt][0]);
	data[rt<<1|1][0]=max(data[rt<<1|1][0],data[rt][0]);
}

void update(int x,int y,int op,int v,int l,int r,int rt) {
	if (x<=l&&y>=r) {
		data[rt][op]=v; return;
	}
	pushdown(rt);
	int mid=(l+r)>>1;
	if (x<=mid) update(x,y,op,v,l,mid,rt<<1);
	if (y>mid) update(x,y,op,v,mid+1,r,rt<<1|1);
	pushup(rt);
}

int query(int x,int y,int op,int l,int r,int rt) {
	if (x<=l&&y>=r) return data[rt][op];
	pushdown(rt);
	int mid=(l+r)>>1;
	int ans=0;
	if (x<=mid) ans=max(ans,query(x,y,op,l,mid,rt<<1));
	if (y>mid) ans=max(ans,query(x,y,op,mid+1,r,rt<<1|1));
	pushup(rt);
	return ans;
}

int main(){
	int n,a,b,m,op,x;
	while (scanf("%d",&n)!=EOF) {
		cnt=C=0;
		for (int i=0;i<=n;i++) edge[i]=0;
		for (int i=1;i<n;i++) {
			scanf("%d%d",&a,&b);
			addedge(a,b);
			addedge(b,a);
		}
		dfs(1,0);
		memset(data,0,sizeof(data));
		scanf("%d",&m);
		int T=0;
		while (m--) {
			scanf("%d%d",&op,&x);
			if (op!=3){
				if (op==1) update(L[x],R[x],op-1,++T,1,cnt,1);
				else update(L[x],L[x],op-1,++T,1,cnt,1);
			}
			else {
				int t1=query(L[x],L[x],0,1,cnt,1);
				int t2=query(L[x],R[x],1,1,cnt,1);
				if (t1>t2) printf("1\n");
				else printf("0\n");
			}
		}
	}
	return 0;
}

 	 	 	 			   	  	   		 	 	