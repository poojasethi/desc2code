/*
Running with Obstacles
Tanat jiwapornkupt
24/03/16
*/
#include <stdio.h>
#include <queue>
#include <algorithm>
using namespace std;

int n;
int m;
int s;
int d;
int a[200001] = {-1};
int left = 0;
bool jump[200001];
bool land[200001];
int pre[200001];
queue<int> q;
int i;
int t;
void goback(int x){
	if(x>=1){
		goback(pre[x]-1);
	//	printf("x = %d\n",x);
		printf("RUN %d\n",a[pre[x]]-a[pre[x]-1]-2);
		printf("JUMP %d\n",a[x]-a[pre[x]]+2);
	}
}
int main(){
	scanf("%d%d%d%d",&n,&m,&s,&d);
	for(i=1;i<=n;i++) scanf("%d",&a[i]);
	sort(a+1,a+n+1);
	a[n+1] = m;
	if(a[1]-1>=s){
		jump[1] = 1;
		pre[1] = 1;
		if(d>1) land[1] = 1;
	}
	q.push(1);
	for(i=2;i<=n+1;i++){
		//check jump
		if(land[i-1] && a[i]-a[i-1]-2>=s) jump[i] = 1;
		
		q.push(i);
		//check land
		while(!q.empty()){
			t = q.front();
			if(a[i]-a[t]+2<=d && jump[t]){
				land[i] = 1;
				pre[i] = t;
			//	printf("pre %d = %d\n",i,t);
				break;
			}
			else{
				q.pop();
			}
		}
		
	}
	if(!land[n]) printf("IMPOSSIBLE");
	else{
		goback(n);
		if(m-a[n]-1>0) printf("RUN %d\n",m-a[n]-1);
	}
	return 0;
}
		 		 			   	   		        	  		