n,m,k = map(int, raw_input().split())

dots = []

grid = []

visited = [False]*n*m

for i in range(n):
    row = raw_input()
    grid.append(list(row))
    for j in range(m):
        if row[j] == '.':
            dots.append((i,j))

stack = []

order = []

def dfs(si,sj):
    global stack
    global visited
    global order
    stack = []
    stack.append((si,sj))
    total = 0
    def can_look_at(x,y):
        if not(0 <= x < n and 0 <= y < m):
            return False
        if visited[x*m+y]:
            return False
        if grid[x][y] != '.':
            return False
        return True
    while(stack != []):
        i, j = stack.pop()
        if(not can_look_at(i,j)):
            continue
        visited[i*m+j] = True
        order.append((i,j))
        total += 1
        motions = [(i+di, j+dj) for di,dj in [ (1, 0), (-1, 0), (0, 1), (0, -1)]]
        for i2,j2 in motions:
            if(can_look_at(i2,j2)):
                stack.append((i2, j2))
    return total

blocked_so_far = 0

"""
while(blocked_so_far < k):
    for i,j in dots:
        if(grid[i][j] != '.'):
            continue
        visited = [False]*n*m
        grid[i][j] = 'X'
        start = None
        for si in range(n):
            if start != None:
                break
            for sj in range(m):
                if grid[si][sj] == '.':
                    start = (si, sj)
                    break
        total = dfs(*start)
        if (len(dots) - blocked_so_far - 1 == total):
            blocked_so_far += 1
        else:
            grid[i][j] = '.'
        if blocked_so_far == k:
            break
"""

start = None
for si in range(n):
    if start != None:
        break
    for sj in range(m):
        if grid[si][sj] == '.':
            start = (si, sj)
            break
dfs(*start)

for _i in range(k):
    i,j = order.pop()
    grid[i][j] = 'X'

print '\n'.join(map(''.join, grid))
