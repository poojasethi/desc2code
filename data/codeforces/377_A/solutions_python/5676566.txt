import os,sys,string
###maze:377A http://codeforces.com/problemset/problem/377/A
#Pavel loves grid mazes. A grid maze is an n*m rectangle maze where each cell is either empty, or is a wall. You can go from one cell to another only if both cells are empty and have a common side.
#Pavel drew a grid maze with all empty cells forming a connected area. That is, you can go from any empty cell to any other one. Pavel doesn't like it when his maze has too little walls. He wants to turn exactly k empty cells into walls so that all the remaining cells still formed a connected area. Help him.

#Input
#The first line contains three integers n, m, k, where n and m are the maze's height and width, correspondingly, k is the number of walls Pavel wants to add and letter s represents the number of empty cells in the original maze.

#Output
#Print n lines containing m characters each: the new maze that fits Pavel's requirements. Mark the empty cells that you transformed into walls as "X", the other cells must be left without changes (that is, "." and "#").

##solve: first change all '.' as 'X', then we calculate the number of empty position we need to keep. Thus start from any non-wall position (originally) to reset 'X' as empty until the number of empty postion
##is reached.
def run():
    n,m,k = map(int, raw_input().split())
    maze = [list(string.replace(raw_input(), '.', 'X')) for i in range(n)]
    ##set up all empty positions as new wall 'X'
    
    numOfEmpty = n * m - k - sum(i.count('#') for i in maze)##number of empty position after the algorithm
    
    ###note that we can start from any point that was originally empty because in original maze, empty points are connected!!!
    ##find first originally empty position in maze
    i = 0
    sk = list()
    while numOfEmpty > 0:
        if 'X' in maze[i]:##first empty position
            j = maze[i].index('X')
            sk.append((i,j))
            maze[i][j] = '.'##set up the position as empty again
            numOfEmpty -= 1
            break
        i += 1

    ##dfs from (i,j)
    while numOfEmpty > 0:
        pos = sk.pop()
        i = pos[0]
        j = pos[1]
        for (x, y) in [(i,j-1), (i,j+1), (i-1,j), (i+1,j)]:
            if x<0 or y<0 or x>=n or y>=m or 'X'!=maze[x][y]:##get a valid 'X'
                continue
            maze[x][y] = '.'
            sk.append((x,y))
            numOfEmpty -= 1
            if 0 == numOfEmpty:
                break

    for i in range(n):
        maze[i] = "".join(maze[i])
        print maze[i]
    return
####################################################################################
run()
