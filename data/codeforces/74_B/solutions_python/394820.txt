import copy
debug = True
debug = False
cop = copy.deepcopy
if debug:
	f1 = open('input.txt','rU')
def readin():
	global debug
	if debug:
		return f1.readline()[0:-1]
	else:
		return raw_input()
(n, m, k) = [int(i) for i in readin().split()]
d = readin()
if d == 'to head':
	d = -1
else:
	d = 1
tr = [int(i) for i in readin()]

class State1:
	def __init__(self,t = 0,p = 0):
		self.t = t
		self.p = p
	def go(self,newp):
		self.t += 1
		if newp < 1:
			newp = 1
		elif newp > n:
			newp = n
		self.p = newp

class State2:
	def __init__(self,t = 0, p = 0, v = 0):
		self.t = t
		self.p = p
		self.v = v
	def go(self):
		self.t += 1
		self.p += self.v
		if self.p == n:
			self.v *= -1
		elif self.p == 1:
			self.v *= -1

p1 = State1(0, m)
p2 = State2(0, k, d)

def draw(p1, p2):
	global debug
	if not debug: return
	for i in range(1,n+1):
		if p1.p == i:
			c = 1
		elif p2.p == i:
			c = 2
		else:
			c = 0
		print c,'  ',
	print ''


end = False
t = 0
t0 = len(tr)
draw(p1,p2) # for debug
while (not end) and t < t0:
	t += 1
	# if the train is running
	if tr[t-1] == 0:
		if p1.p < p2.p:
			p1.go(p1.p-1)
		else:
			p1.go(p1.p+1)
	else: # the train is idle
		if p2.v == -1: # p2 go left
			p2t = cop(p2)
			p2t.go()
			if p2t.p == n:
				p1.go(1)
			else:
				p1.go(n)
		else:
			p2t = cop(p2)
			p2t.go()
			if p2t.p == 1:
				p1.go(n)
			else:
				p1.go(1)
	if tr[t-1] == 0 and p1.p == p2.p:
		end = True
	p2.go()
	draw(p1,p2) # for debug
	if p1.p == p2.p:
		end = True

if end:
	print 'Controller',t
else:
	print 'Stowaway'

