#define yuki(x, y) for(int i = x; i < (y); ++i)
#define yukj(x, y) for(int j = x; j < (y); ++j)
#define yukii(x, y) for(int i = x; i <= (y); ++i)
#define yukji(x, y) for(int j = x; j <= (y); ++i)
#define yuk(x, y, z) for(int x = y; x < (z); ++x)
#define yui(x, y, z) for(int x = y; x >= (z); --x)
#define sclr(x) memset(x, 0, sizeof(x))
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long lol;
struct snow
{
	int s;
	lol n;
	bool o;
	bool operator<(const snow &rhs) const{return n < rhs.n;}
}cir[300100];
int n, m, ini[300100];
lol t, shf;
void chg(const lol &x)
{
	if((shf = (shf+x)%n) < 0) shf += n;
}
void sread()
{
	scanf("%d%d%I64d", &n, &m, &t);
	lol t1;
	char t2[10];
	yuki(0, n)
	{
		scanf("%I64d%s", &t1, t2);
		cir[i] = (snow){i, t1, t2[0]=='R'};
	}
	sort(cir, cir+n);
	yuki(0, n)
		ini[i] = cir[i].s;
}
void solve()
{
	lol tt;
	yuki(0, n)
	{
		if(cir[i].o)
			cir[i].n += t;
		else
			cir[i].n -= t;
		if(cir[i].n > 0)tt = (cir[i].n-1)/m;
		if(cir[i].n <= 0)tt = cir[i].n/m-1;
		chg(tt);
		if((cir[i].n %= m) <= 0) cir[i].n += m;
	}
	sort(cir, cir+n);
}
bool cmp(const snow &lhs, const snow &rhs)
{
	return lhs.s < rhs.s;
}
void printans()
{
	int tt = (n-shf)%n;
	if(tt < 0) tt += n;
	yuki(0, n)
	{
		cir[i].s = ini[tt++];
		if(tt >= n) tt %= n;
	}
	sort(cir, cir+n, cmp);
	yuki(0, n) printf("%I64d ", cir[i].n);
	puts("");
}
int main(int argc, char **argv)
{
#ifdef snowoi
	freopen("in", "r", stdin);
	freopen("out", "w", stdout);
#endif
	sread();
	solve();
	printans();
	return 0;
}