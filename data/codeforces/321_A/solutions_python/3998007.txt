

def calc_cycle(steps):
	x = 0
	y = 0	
	
	for s in steps:		
		if s == 'L':
			x -= 1
		elif s == 'R':
			x += 1
		elif s == 'U':
			y += 1
		elif s == 'D':
			y -= 1
	
	return (x,y)

def test_steps(pos, steps, goal):
	extended_steps = ''
	for i in xrange(1000):
		extended_steps += steps
		
	x = pos[0]
	y = pos[1]
	
	if x==goal[0] and y == goal[1]:
		return True
		
	for s in extended_steps:		
		if s == 'L':
			x -= 1
		elif s == 'R':
			x += 1
		elif s == 'U':
			y += 1
		elif s == 'D':
			y -= 1
		if x==goal[0] and y == goal[1]:
			return True
	
	return False	

def is_inside(pos, wide_goal):
	if pos[0] >= wide_goal[0] and pos[1] <= wide_goal[1] and pos[0] <= wide_goal[2] and pos[1] >= wide_goal[3]:
		return True
	else:
		return False

if __name__ == '__main__':
	
	goal = [int(t) for t in raw_input().strip().split()]
	steps = raw_input().strip()
		
	cycle = calc_cycle(steps)
	
	#left, top, right, bottom
	wide_goal = [goal[0]-len(steps)*1000, goal[1]+len(steps)*1000, goal[0]+len(steps)*1000, goal[1]-len(steps)*1000]
	
	pos = [0,0]
	
	ans = False
	if is_inside(pos, wide_goal):
		ans = test_steps(pos, steps, goal)
	else:
		if (cycle[0] != 0 and goal[0]/cycle[0] < 0) or (cycle[1] != 0 and goal[1]/cycle[1] < 0):
			ans = False
		else:
			times = 10**9
			if cycle[0] != 0:
				times = goal[0]/cycle[0]
			if cycle[1] != 0:
				times = min(times, goal[1]/cycle[1])
			times -= min(times, 500)
			pos = [pos[0]+times*cycle[0], pos[1]+times*cycle[1]]
			if test_steps(pos, steps, goal):
				ans = True
	
	if ans:
		print 'Yes'
	else:
		print 'No'
	
	
		
		
		
		
		
				
	

