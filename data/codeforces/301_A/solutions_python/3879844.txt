from collections import deque
from itertools import dropwhile, ifilter
from operator import eq

def r():
    return map(int, raw_input().split())

def moves(n, low, high):
    for i in xrange(n+1):
        if i <= low and (n-i) <= high:
            yield (low-i+(n-i), high-(n-i)+i)

def dfs(n, pos):
    q, seen = deque([pos]), set([pos])
    while len(q):
        cur = q.popleft()
        (low, high) = cur
        if low == 0:
            return True
        for mk in moves(n, low, high):
            if mk not in seen:
                (low, high) = mk
                if low == 0:
                    return True
                q.append(mk)
                seen.add(mk)

def main():
    n = int(raw_input())
    a = r()

    low = len(filter(lambda k: k < 0, a))
    high = (2*n-1) - low

    mod = map(abs, a)
    if dfs(n, (low, high)):
        print sum(mod)
    else:
        print (sum(mod) - 2 * (min(mod)))

    return 0

if __name__ == "__main__":
    main()