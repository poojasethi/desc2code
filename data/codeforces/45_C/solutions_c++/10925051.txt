//29042015 0857 codeforces 45C
#include<stdio.h>
#include<stdlib.h>
#include<algorithm>
#include<queue>

using namespace std;

#define MX 200007

int skil[MX], pre[MX], post[MX];
bool flag[MX];
char s[MX];

struct data
{
    int l, r;
    data(){}
    data(int a, int b)
    {
        l=a;
        r=b;
    }
    bool operator<(const data& a)const
    {
        return abs(skil[l]-skil[r])==abs(skil[a.l]-skil[a.r])?(l>a.l):abs(skil[l]-skil[r])>abs(skil[a.l]-skil[a.r]);
    }
};

int main()
{
    int n, i, b, g;
    priority_queue<data> pq;
    scanf("%d", &n);
    getchar();
    scanf("%s", &s[1]);
    s[0]=s[1];
    s[n+1]=s[n];
    for(i=1, b=g=0; i<=n; i++)
    {
        scanf("%d", &skil[i]);
        pre[i]=i-1;
        post[i]=i+1;
        if(s[i]=='B')b++;
        else g++;
        if(s[i]^s[i-1])
        {
            pq.push(data(i-1, i));
        }
    }
    printf("%d\n", min(b, g));
    flag[0]=flag[n+1]=true;
    while(!pq.empty())
    {
        data u=pq.top();
        pq.pop();
        if(flag[u.l] || flag[u.r])continue;
        printf("%d %d\n", u.l, u.r);
        flag[u.l]=flag[u.r]=true;
        post[pre[u.l]]=post[u.r];
        pre[post[u.r]]=pre[u.l];
        if(!flag[pre[u.l]] && !flag[post[u.r]])
        {
            if(s[pre[u.l]]^s[post[u.r]])
            {
                pq.push(data(pre[u.l], post[u.r]));
            }
        }
    }
    return 0;
}
