#include<iostream>
#include<cstring>
#include<queue>
#include<cstdio>
#include<cmath>
using namespace std;
const int maxn=300005;
int L[maxn],R[maxn],skill[maxn];
char s[maxn];
int n;
bool vis[maxn];

struct node
{
   int u;
   int v;
   int c;
};

inline bool operator <(const node a,const node b)
{
  if(a.c^b.c)return a.c>b.c;
  else return a.u>b.u;
}
priority_queue<node>q;

int main()
{
  while(cin>>n)
  {
    while(!q.empty()) q.pop();
    cin>>s+1;
    node z;
    int num=0;
    for(int i=1;i<=n;i++)
    {
        L[i]=i-1;
        R[i]=i+1;
        if(s[i]=='B'){
            num +=1;
        }
    }
    num=min(num,n-num);
    for(int i=1;i<=n;i++)
      cin>>skill[i];
    for(int i=1;i<n;i++)
    {
        if(s[i] != s[i+1])
        {
            z.u=i;
            z.v=i+1;
            z.c=abs(skill[i]-skill[i+1]);
            q.push(z);
        }
    }
    printf("%d\n",num);
    memset(vis,0,sizeof(vis));
    while(num--)
    {
      while(!q.empty())
      {
        z=q.top();
        q.pop();
        if(!vis[z.u] && !vis[z.v])
          {
           printf("%d %d\n",z.u,z.v);
           vis[z.u]=1;
           vis[z.v]=1;
           break;
          }
      }
      int b=L[z.u];
      int t=R[z.v];
      R[b]=t;
      L[t]=b;
      z.u=b;
      z.v=t;
      z.c=abs(skill[b]-skill[t]);
      if(b>0 && t<=n && s[b]!=s[t])
        q.push(z);
    }
  }
  return 0;
}

 		  	  		   				 		 			   		