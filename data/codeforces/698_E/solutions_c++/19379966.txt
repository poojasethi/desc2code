#include<algorithm>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<ctime>
#include<deque>
#include<iterator>
#include<iostream>
#include<list>
#include<map>
#include<memory>
#include<queue>
#include<set>
#include<stack>
#include<string>
#include<vector>
#include<utility>
#include<bitset>
#define ll long long
const int Y=32000;
const int Day=86400;
const int Hour=3600;
using namespace std;

int Year[Y];
int m[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
int summ[13];

bool ly(int k){
     k+=1970-1;
     if(k%100==0) return (k%400==0);
     return (k&3)==0;
}

void init(){
     int i;
     Year[0]=0;
     for(i=1;i<Y;i++)
        if(ly(i)) Year[i]=Year[i-1]+366;
        else Year[i]=Year[i-1]+365;
     summ[0]=0;
     for(i=1;i<=12;i++)
         summ[i]=summ[i-1]+m[i];
}

struct node{
    int hour,min,sec,month,date,day,year;
    int calc_day(){
        int d=Year[year-1];
        d+=summ[month-1];
        if(month>2 && ly(year)) d++;
        d+=date;
        return (d%7+2)%7+1;
    }
}nxt;    
    

ll getsec(node t){
           int d=Year[t.year-1];
           d+=summ[t.month-1];
           if(t.month>2 && ly(t.year)) d++;
           d+=t.date-1;
           int s=t.hour*60*60+t.min*60+t.sec;
           return (ll)s+1LL*d*Day;
}

void next_days(node &c,int d){
     c.date+=d;
     if(c.month==2 && ly(c.year))
        if(c.date<=29) return;
     if(c.date<=m[c.month]) return;
     c.date-=m[c.month];
     if(c.month==2 && ly(c.year)) c.date--;
     c.month++;
     if(c.month<=12) return;
     c.month=1;
     c.year++;
}

void first_day(node &c,int d){
    int curday=c.calc_day();//cout<<curday<<endl;
    while(curday!=d)
    {  next_days(c,1);
       curday=c.calc_day();
    }
}

void set0(node &ans,node st){
     if(st.hour==-1) ans.hour=0; else ans.hour=st.hour;
     if(st.min==-1) ans.min=0; else ans.min=st.min;
     if(st.sec==-1) ans.sec=0; else ans.sec=st.sec;
}

bool ok(node &a,node b){
     if(a.min>-1 && a.min<b.min) return false;
     if(a.min>-1)
     {  if(a.min>b.min)
        {  if(a.sec==-1) a.sec=0;return true;}
        else
        {  if(a.sec>-1 && a.sec<=b.sec) return false;
           if(a.sec>-1) return true;
           if(b.sec==59) return false;
           else {a.sec=b.sec+1;return true;}
        }
     }
     else
     {  if(a.sec>b.sec)
        { a.min=b.min;return true;}
        if(a.sec==b.sec)
        {  if(b.min==59) return false;
           a.min=b.min+1;
           return true;
        }
        if(a.sec>-1)
        {  if(b.min==59) return false;
           a.min=b.min+1;
           return true;
        }
        if(b.sec==59)
        {  if(b.min==59) return false;
           a.min=b.min+1;
           a.sec=0;
           return true;
        }
        a.sec=b.sec+1;
        a.min=b.min;
        return true;
     }
}

bool checktime(node &a,node b){
     if(b.hour==23 && b.min==59 && b.sec==59) return false;
     if(a.hour>-1 && a.hour<b.hour) return false;
     if(a.hour>b.hour)
     {  if(a.min==-1) a.min=0;
        if(a.sec==-1) a.sec=0;
        return true;
     }
     if(a.hour==b.hour) return ok(a,b);
     if(ok(a,b))
     {  a.hour=b.hour;
        return true;
     }
     if(b.hour==23) return false;
     a.hour=b.hour+1;
     if(a.min==-1) a.min=0;
     if(a.sec==-1) a.sec=0;
     return true;
}
             
node check_mon(const node &c,const node &st){
        node ans;
        ans.year=c.year;
        ans.month=c.month;
        if(st.day==-1)
        {  if(st.date==-1)
           { ans.date=c.date;
             ans.hour=st.hour;ans.min=st.min;ans.sec=st.sec;
             if(checktime(ans,c)) return ans;
             next_days(ans,1);
             if(ans.month==c.month)
             {  set0(ans,st);return ans;}
             ans.year=c.year+1;
             if(st.month!=-1) ans.month=st.month; else ans.month=1;
             ans.date=1;
             set0(ans,st);return ans;
           }
           else
           {  if(st.date>c.date)
              { ans.date=st.date;
                while(ans.month==2 && st.date==29 && !ly(ans.year)) ans.year++;
                set0(ans,st);return ans;
              }
              else if(st.date==c.date)
              {  ans.date=c.date;
                 ans.hour=st.hour;ans.min=st.min;ans.sec=st.sec;
                 if(checktime(ans,c)) return ans;
              }
              ans.year=c.year+1;
              if(st.month!=-1) ans.month=c.month; else ans.month=1;
              ans.date=st.date;
              while(ans.month==2 && st.date==29 && !ly(ans.year)) ans.year++;
              set0(ans,st);
              return ans;
           }
        }
        else
        {   ans.date=c.date;
            first_day(ans,st.day);
            if(ans.month==c.month)
            {  if(ans.date==c.date)
               {  ans.hour=st.hour;ans.min=st.min;ans.sec=st.sec;
                  if(checktime(ans,c)) return ans;
                  next_days(ans,1);
                  first_day(ans,st.day);
                  if(ans.month==c.month)
                  {  set0(ans,st);return ans;}
               }
               if(ans.month==c.month)
               {  set0(ans,st);return ans;}
            }
            ans.year=c.year+1;
            if(st.month!=-1) ans.month=st.month; else ans.month=1;
            ans.date=1;
            first_day(ans,st.day);
            set0(ans,st);
            return ans;
        }
}    
    
node calc(const node &st,const node &c){
     node ans;
     if(st.month>c.month)
     {  ans.year=c.year;
        ans.month=st.month;
        if(st.day==-1)
        {  if(st.date==-1) ans.date=1;
           else{
                if(st.month==2 && st.date==29 && !ly(c.year) )
                  { while(!ly(ans.year)) ans.year++;}
                ans.date=st.date;
           }
           set0(ans,st);
           return ans;
        }
        else
        {  ans.date=1;
           first_day(ans,st.day);
           set0(ans,st);
           return ans;
        }     
     }
     else if(st.month<c.month && st.month>0)
     {  ans.year=c.year+1;
        ans.month=st.month;
        if(st.day==-1)
        {  if(st.date==-1) ans.date=1;
           else{ if(st.month==2 && st.date==29 && !ly(ans.year))
                 {  while(!ly(ans.year)) ans.year++;}
                 ans.date=st.date;
           }
           set0(ans,st);
           return ans;
        }
        else
        {  ans.date=1;
           first_day(ans,st.day);
           set0(ans,st);
           return ans;
        }
     }
     else if(st.month==c.month)
     {  return check_mon(c,st);  
     }
     else
     {  ans.month=c.month;
        ans=check_mon(c,st);
        if(ans.year==c.year) return ans;
        ans.month=c.month+1;
        ans.year=c.year;
        if(ans.month>12)
        { ans.month-=12;
          ans.year=c.year+1;
        }
        if(st.day==-1)
        {  if(st.date==-1)
           {  ans.date=1;
              set0(ans,st);
              return ans;
           }
           else
           {  while(true)
              {  if(ly(ans.year) && ans.month==2)
                 { if(st.date>29) ans.month++; else break;}  
                 else if(st.date>m[ans.month]) ans.month++;
                 else break;
                 if(ans.month>12) {ans.year++;ans.month=1;}
              }
              ans.date=st.date;
              set0(ans,st);
              return ans;
           }
        }
        else
        {   ans.date=1;
            first_day(ans,st.day);
            set0(ans,st);
            return ans;
        }
     }
}

int main(){
    node st,cur;
    scanf("%d%d%d%d%d%d",&st.sec,&st.min,&st.hour,&st.day,&st.date,&st.month);
    int n,i;
    init();
    scanf("%d",&n);
    ll t;
    while(n--)
    {  scanf("%I64d",&t);
       int d=(int)(t/(ll)Day);
       int q=t-1LL*d*Day;
       ++d;
       int cury=upper_bound(Year,Year+Y,d)-Year;
       int curd,curmon;
       d-=Year[cury-1];
       if(d>0)
       {  for(i=1;i<=12;i++)
          {   if(i!=2)
              {  if(d<=m[i]) break;
                 d-=m[i];
              }
              else
              {   int cur;
                  if(ly(cury)) cur=29; else cur=28;
                  if(d<=cur) break;
                  d-=cur;
              }
          }
          curd=d;curmon=i;
       }
       else
       {  curd=31;curmon=12;cury--;}
       int curhr=q/Hour;
       q=q-curhr*Hour;
       int curmin=q/60;
       int cursec=q-60*curmin;
       cur.year=cury;cur.min=curmin;cur.sec=cursec;cur.hour=curhr;
       cur.month=curmon;cur.date=curd;cur.day=cur.calc_day();
       //cout<<cury+1970-1<<' '<<curmon<<' '<<curd<<' '<<cur.day<<' '<<curhr<<' '<<curmin<<cursec<<endl;
       ll res;
       if(st.date!=-1 && st.day!=-1)
       {  node tmp=st;
          tmp.date=-1;
          nxt=calc(tmp,cur);
          //cout<<nxt.year+1970-1<<' '<<nxt.month<<' '<<nxt.date<<' '<<nxt.day<<' '<<nxt.hour<<' '<<nxt.min<<' '<<nxt.sec<<endl;
          res=getsec(nxt);
          tmp=st;tmp.day=-1;
          nxt=calc(tmp,cur);
          //cout<<nxt.year+1970-1<<' '<<nxt.month<<' '<<nxt.date<<' '<<nxt.day<<' '<<nxt.hour<<nxt.min<<nxt.sec<<endl;
          res=min(res,getsec(nxt));
         
       }
       else
       {  nxt=calc(st,cur);
      // cout<<nxt.year+1970-1<<' '<<nxt.month<<' '<<nxt.date<<' '<<nxt.day<<' '<<nxt.hour<<nxt.min<<nxt.sec<<endl;
          res=getsec(nxt);
       }
       printf("%I64d\n",res);
    }
    //system("pause");
    return 0;
}


		   	     									 		  	   	