#include <stdio.h>
#include <algorithm>
#include <assert.h>
#include <set>
#include <map>
#include <complex>
#include <iostream>
#include <time.h>
#include <stack>
#include <stdlib.h>
#include <memory.h>
#include <bitset>
#include <math.h>
#include <string>
#include <string.h>
#include <queue>
#include <vector>

using namespace std;

const int MaxN = 3e5 + 10;
const int MOD = 1e9 + 7;
const int INF = 1e9;

vector < pair < int, pair < int, int > > > queries;
vector < int > paired, add;
vector < long long > res;

const int S = 1000;

struct ConvexHullTrick {

  static const long double EPS = 1e-10;
  static const long long INF = 1LL << 62;

  struct Line {
    int type;
    long long k, b;
    long long val;
    long double xright;

    Line (long long _k = 0.0, long long _b = 0.0, long double _xright = INF, long long _val = 0.0, int _type = 0) :
      k(_k), b(_b), xright(_xright), val(_val), type(_type) {
    }

    Line (const Line &other) {
      type = other.type;
      k = other.k;
      b = other.b;
      xright = other.xright;
      val = other.val;
    }

    long long getValue(long long x) const {
      return k * x + b;
    }

    bool operator< (const Line &other) const {
      if (other.type == 0) {
        return k > other.k;
      }
      return other.val > xright;
    }

    bool operator== (const Line &other) const {
      return k == other.k && b == other.b;
    }
  };

  set < Line > lines;

  ConvexHullTrick() {
    lines.clear();
  }

  ConvexHullTrick(const ConvexHullTrick &other) {
    lines = other.lines;
  }

  bool parallel(const Line &a, const Line &b) {
    return a.k == b.k;
  }

  long double intersect(const Line &a, const Line &b) {
    return parallel(a, b) ? INF : 1.0 * (b.b - a.b) / (a.k - b.k);
  }

  bool bad(const Line &a, const Line &b, const Line &c) {
    return intersect(a, c) <= intersect(a, b);
  }

  bool bad(set < Line > :: iterator it) {
    set < Line > :: iterator pit = it, nit = it;
    if (pit != lines.begin()) {
      --pit;
      ++nit;
      if (nit != lines.end()) {
        return bad(*pit, *it, *nit);
      }
    }
    return false;
  }

  void relax(set < Line > :: iterator it) {
    set < Line > :: iterator nit = it;
    ++nit;
    if (nit == lines.end()) {
      return;
    }
    long double x = intersect(*it, *nit);
    Line temp = *it;
    lines.erase(it);
    temp.xright = x;
    lines.insert(temp);
  }

  void addLine(long long k, long long b) {
    k = -k;
    b = -b;
    Line curLine = Line(k, b);
    {
      set < Line > :: iterator it = lines.lower_bound(curLine);
      if (it != lines.end() && parallel(*it, curLine) == true) {
        if (it->b <= b) {
          return;
        }
        lines.erase(it);
      }
    }
    lines.insert(curLine);
    set < Line > :: iterator it = lines.lower_bound(curLine);
    if (bad(it) == true) {
      lines.erase(it);
      return;
    }
    while (true) {
      set < Line > :: iterator it = lines.lower_bound(curLine), pit = it;
      if (it == lines.begin()) {
        break;
      }
      --pit;
      if (bad(pit)) {
        lines.erase(pit);
      } else {
        break;
      }
    }
    while (true) {
      set < Line > :: iterator it = lines.lower_bound(curLine), nit = it;
      ++nit;
      if (nit == lines.end()) {
        break;
      }
      if (bad(nit)) {
        lines.erase(nit);
      } else {
        break;
      }
    }
    it = lines.lower_bound(curLine);
    relax(it);
    it = lines.lower_bound(curLine);
    if (it != lines.begin()) {
      --it;
      relax(it);
    }
  }

  long long getY(long long x) {
    if (lines.empty()) {
      return -INF;
    }
    Line temp = Line(0.0, 0.0, INF, x, 1);
    set < Line > :: iterator it = lines.lower_bound(temp);
    return -it->getValue(x);
  }

} conv[MaxN];

pair < int, int > y;
vector < pair < int, int > > z;
vector < pair < int, ConvexHullTrick > > old;

void addP(pair < int, int > f) {
  z.push_back(f);
  y.second++;
  if (z.size() % S == 0 && z.size() > 0) {
    old.push_back(make_pair(y.first, conv[y.first]));
    conv[y.first].lines.clear();
    for (int i = 1; i <= S; ++i){
      conv[y.first].addLine(z[z.size() - i].first, z[z.size() - i].second);
    }
    y.first++;
    y.second = 0;
  }
}

void solve(int l, int r, vector < int > add) {
  int m = (l + r) / 2;
  int ss = old.size();
  int zz = z.size();
  pair < int, int > yy = y;
  vector < int > nadd;
  for (int i = 0; i < (int)add.size(); ++i) {
    int ll = add[i], rr = paired[ll];
    if (rr <= l || ll > r) {
      continue;
    }
    if (ll <= l && r < rr) {
      addP(queries[ll].second);
      continue;
    }
    nadd.push_back(add[i]);
  }
  if (l == r) {
    if (queries[l].first == 3) {
      long long ress = -1LL << 62;
      for (int i = 0; i < y.first; ++i) {
        ress = max(ress, conv[i].getY(queries[l].second.first));
      }
      for (int i = 0; i < y.second; ++i) {
        ress = max(ress, 1LL * z[y.first * S + i].first * queries[l].second.first + z[y.first * S + i].second);
      }
      res[l] = ress;
    }
  } else {
    solve(l, (l + r) / 2, nadd);
    solve((l + r) / 2 + 1, r, nadd);
  }
  while (old.size() != ss) {
    conv[old.back().first] = old.back().second;
    old.pop_back();
  }
  while (z.size() != zz) {
    z.pop_back();
  }
  y = yy;
}

int main() {
//  freopen("input.txt", "r", stdin);
  int q;
  scanf("%d", &q);
  queries.resize(q);
  paired.resize(q);
  res.resize(q);
  for (int i = 0; i < q; ++i) {
    scanf("%d%d", &queries[i].first, &queries[i].second.first);
    if (queries[i].first == 1) {
      paired[i] = q;
      add.push_back(i);
      scanf("%d", &queries[i].second.second);
    }
    if (queries[i].first == 2) {
      queries[i].second.first--;
      paired[queries[i].second.first] = i;
    }
  }
  solve(0, q - 1, add);
  for (int i = 0; i < (int)res.size(); ++i) {
    if (queries[i].first == 3) {
      if (res[i] == -1LL << 62) {
        printf("EMPTY SET\n");
        continue;
      }
      printf("%lld\n", res[i]);
    }
  }
  return 0;
}
