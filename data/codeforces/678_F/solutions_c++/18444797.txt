#include<bits/stdc++.h>
#define N 1200010
#define LL long long
using namespace std;
inline void splay(LL &v){
	v=0;char c=0;LL p=1;
	while(c<'0' || c>'9'){if(c=='-')p=-1;c=getchar();}
	while(c>='0' && c<='9'){v=(v<<3)+(v<<1)+c-'0';c=getchar();}
	v*=p;
}
struct vec{
	LL x,y;
	friend LL operator^(const vec&a,const vec&b){
		return a.x*b.y-a.y*b.x;
	}
	friend LL operator*(const vec&a,const vec&b){
		return a.x*b.x+a.y*b.y;
	}
	friend bool operator<(const vec&a,const vec&b){
		if(a.x!=b.x)return a.x<b.x;
		return a.y<b.y;
	}
	friend vec operator-(const vec&a,const vec&b){
		return (vec){a.x-b.x,a.y-b.y};
	}
}p[N],st[N],tmp[N];
vector<vec>v[N<<2];
struct QR{
	LL x,y,ans;
	QR(){ans=-(1LL<<61);}
}q[N];
LL n,m,L[N],tot,top,ps[N],cnt;
bool flag[N],isq[N];
void insert(LL l,LL r,LL w,LL L,LL R,LL x){
	if(L<=l&&r<=R){
		v[w].push_back(p[x]);return;
	}
	LL mid=l+r>>1;
	if(L<=mid)insert(l,mid,w<<1,L,R,x);
	if(R>mid)insert(mid+1,r,w<<1|1,L,R,x);
}
void query(LL i){
	if(!top)return;
	vec tmp=(vec){q[i].x,q[i].y};
	LL l=1,r=top;
	while(r-l>=3){
		LL mid=l+(r-l)/3,mid2=r-(r-l)/3;
		if((tmp*st[mid])>(tmp*st[mid2]))r=mid2;
		else l=mid;
	}
	for(LL j=l;j<=r;j++){
		q[i].ans=max(q[i].ans,tmp*st[j]);
	}
}
void solve(LL x,LL l,LL r){
	LL mid=l+r>>1;
	if(l<r){
		solve(x<<1,l,mid);
		solve(x<<1|1,mid+1,r);
	}
	top=0;
	sort(v[x].begin(),v[x].end());
	for(LL i=0;i<v[x].size();i++){
		while(top>1&&((v[x][i]-st[top])^(st[top]-st[top-1]))<=0)top--;
		st[++top]=v[x][i];
	}
	for(LL i=l;i<=r;i++){
		if(isq[i]){
			query(i);
		}
	}
}
int main(){
	cin>>n;
	for(LL i=1;i<=n;i++){
		LL op,x,y;splay(op);
		if(op==1){
			splay(x),splay(y);
			p[++tot].x=x,p[tot].y=y,L[tot]=i;
			ps[i]=tot;cnt++;
		}
		if(op==2){
			splay(x);x=ps[x];
			insert(1,n,1,L[x],i,x);L[x]=0;cnt--;
		}
		if(op==3){
			splay(q[i].x),q[i].y=1;isq[i]=1;
			if(!cnt)flag[i]=1,q[i].x=q[i].y=isq[i]=0;
		}
	}
	for(LL i=1;i<=tot;i++){
		if(L[i]){
			insert(1,n,1,L[i],n,i);
		}
	}
	solve(1,1,n);
	for(LL i=1;i<=n;i++){
		if(flag[i])puts("EMPTY SET");
		if(isq[i]){
			printf("%I64d\n",q[i].ans);
		}
	}
}