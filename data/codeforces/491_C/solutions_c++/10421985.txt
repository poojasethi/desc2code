/**
 * 
 * @authors ZhuFengdaaa (ZhuFengdaaa@gmail.com)
 * @date    2015-03-24 12:32:13
 * @version $Id$
 */

 #include<iostream>
 #include<cstdio>
 #include<vector>
 #include<algorithm>
 #include<cstring>
 #include<cmath>
 using namespace std;

int n,k;
const int INF = 1<<30;
const int V = 52;
char str1[2000000],str2[2000000];
int g[V][V];
bool usex[V],usey[V];
int match[V],lx[V],ly[V];
int slack[V];
void init()
{
	//初始化松弛
	for (int i = 0; i < k; ++i)
	{
		slack[i]=INF;
	}
	//初始化匹配 match[j(左边节点序号)]=i(右边节点序号)
	memset(match,-1,sizeof(match));
	//初始化点标
	for (int i = 0; i < k; ++i)
	{
		lx[i]=0;
		ly[i]=0;
		for (int j = 0; j < k; ++j)
		{
			if(lx[i]<g[i][j])
				lx[i]=g[i][j];
		}
		
	}
}
bool path(int u)
{
	usex[u]=1;
	for (int v = 0; v < k; ++v)
	{
		//不在相等子图中，修改松弛函数slack[]
		if(lx[u]+ly[v]-g[u][v]>0)
		{
			slack[v]=min(slack[v],lx[u]+ly[v]-g[u][v]);
		}
		if(!usey[v]&&(lx[u]+ly[v]-g[u][v]==0)){
			usey[v]=1;
			if(match[v]==-1||path(match[v]))
			{
				match[v]=u;
				return true;
			}
		}
	}
	return false;
}
void solve()
{
	init();
	// 从0到k-1遍历是为了保证每个点都被完全匹配
	for (int i = 0; i < k; ++i)
	{
		//修改点标直到出现完全匹配为止
		while(1)
		{
			memset(usex,0,sizeof(usex));
			memset(usey,0,sizeof(usey));
			if(path(i))break;
			int d= INF;
			for (int i = 0; i < k; ++i)
			{
				d=min(d,slack[i]);
			}
			for (int i = 0; i < k; ++i)
			{
				if(usex[i])
					lx[i]-=d;
				if(usey[i])
					ly[i]+=d;
			}
		}
	}
	int res=0;
	for (int i = 0; i < k; ++i)
	{
		res+=g[match[i]][i];
	}
	printf("%d\n", res);
	int pt[52];
	for (int i = 0; i < k; ++i)
	{
		pt[match[i]]=i;
	}
	for (int i = 0; i < k; ++i)
	{
		printf("%c", pt[i]>=26?pt[i]-26+'A':pt[i]+'a');
	}
	printf("\n");
}
int main()
{
	while(cin>>n>>k)
	{
		memset(g,0,sizeof(g));
		cin>>str1>>str2;
		for (int i = 0; i < n; ++i)
		{
			int a,b;
			if('a'<=str1[i]&&str1[i]<='z'){
				a=str1[i]-'a';
			}
			else{
				a=str1[i]-'A'+26;
			}
			if('a'<=str2[i]&&str2[i]<='z'){
				b=str2[i]-'a';
			}
			else{
				b=str2[i]-'A'+26;
			}
			g[a][b]++;
		}
		solve();
	}
}