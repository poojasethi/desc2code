#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <queue>
#define int64 long long

using namespace std;
const int Maxn = (1 << 30);
char ch[2002000],ch2[2002000];
int n,K,v[110][110],s,t,dis[100100],a[100100],from[100100];
int head[110],next[100100],to[100100],val[100100],c[100100],who[100100],top = 1;
bool into[110];

int trans(char s)
{
	if (s >= 'a' && s <= 'z')  return s - 'a' + 1;
	else return s - 'A' + 1 + 26;
}
char ftrans(int z){
	z -= K;if (z <= 26)   return 'a' + z - 1;
	z -= 26;return 'A' + z - 1;
}
void link(int x,int y,int z,int w)
{
	next[++top] = head[x];  head[x] = top;  to[top] = y;  val[top] = z;  c[top] = w;  who[top] = x;
}
bool SPFA(int &cost)
{
	for (int i = 0;i <= t;i++)   dis[i] = -Maxn;
	queue <int> Q;   Q.push(s);   dis[s] = 0;a[s] = Maxn;
	while (!Q.empty())
		{
			int u = Q.front();   Q.pop();  into[u] = 0;
			for (int i = head[u],y;y = to[i],i;i = next[i])
				if (dis[u] + c[i] > dis[y] && val[i])
					{
						dis[y] = dis[u] + c[i];
						from[y] = i;  a[y] = min(a[u],val[i]);
						if (!into[y])    into[y] = 1,Q.push(y);
					}
		}
	if (dis[t] == -Maxn)    return false;
	int u = t;  cost += a[t] * dis[t];
	while (u != s)
		{
			val[from[u]] -= a[t];
			val[from[u] ^ 1] += a[t];
			u = who[from[u]];
		}
	return true;
}

int main()
{
	cin >> n >> K;   s = 0;  t = 2 * K + 1;
	scanf("%s %s",ch + 1,ch2 + 1);
	for (int i = 1;i <= n;i++)
		{
			int v1 = trans(ch[i]),v2 = trans(ch2[i]);
			v[v1][v2]++;
		}
	for (int i = 1;i <= K;i++)  {
		link(s,i,1,0);link(i,s,0,0);
		for (int j = 1;j <= K;j++)
			{
				link(i,j + K,1,v[i][j]),link(j + K,i,0,-v[i][j]);
			}
		link(i + K,t,1,0);link(t,i + K,0,0);
	}
	int cost = 0;
	while (SPFA(cost));
	cout << cost << endl;
	for (int i = 1;i <= K;i++)
		{
			for (int j = head[i],y;y = to[j],j;j = next[j])
				if (!val[j] && y != 0)
					{printf("%c",ftrans(y));break;}
		}
}
