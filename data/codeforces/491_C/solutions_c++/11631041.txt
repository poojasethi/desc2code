#include <iostream>
#include <cstring>
#include <vector>
#include <queue>
using namespace std;

const int
    MaxK = 53,
    MaxN = 2000005;

int N, K;
char A[MaxN];
char B[MaxN];

int id(char c) {
    return ('a' <= c && c <= 'z') ? c-'a' : c-'A'+26;
}

namespace KuhnMunkres
{
    const int MAX_N = 505;
    const int INF = 100000000;
    const int BASE = 1000;

    int n;
    int graph[MAX_N][MAX_N];
    bool usedX[MAX_N];
    bool usedY[MAX_N];
    int linkTo[MAX_N];
    int labelX[MAX_N];
    int labelY[MAX_N];

    bool findPath(int i)
    {
        usedX[i] = true;
        for (int j = 0; j < n; j++)
            if (!usedY[j] && labelX[i] + labelY[j] == graph[i][j] && linkTo[j] == -1)
            {
usedY[j] = true;
                linkTo[j] = i;
                return true;
            }
        for (int j = 0; j < n; j++)
            if (!usedY[j] && labelX[i] + labelY[j] == graph[i][j])
            {
                usedY[j] = true;
                if (linkTo[j] == -1 || findPath(linkTo[j]))
                {
                    linkTo[j] = i;
                    return true;
                }
            }
        return false;
    }

    int KuhnMunkres()
    {
        memset(linkTo, -1, sizeof(linkTo));
        memset(labelX, 0, sizeof(labelX));
        memset(labelY, 0, sizeof(labelY));

        for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            labelX[i] = max(labelX[i], graph[i][j]);

        for (int k = 0; k < n; k++)
            while (true)
            {
                memset(usedX, 0, sizeof(usedX));
                memset(usedY, 0, sizeof(usedY));
                if (findPath(k)) break;

                int delta = INF;
                for (int i = 0; i < n; i++)
                    if (usedX[i])
                        for (int j = 0; j < n; j++)
                            if (!usedY[j])
                                delta = min(delta, labelX[i] + labelY[j] - graph[i][j]);
if (delta == 0 || delta == INF) break;
                for (int i = 0; i < n; i++)
                    if (usedX[i])
                        labelX[i] -= delta;
                for (int i = 0; i < n; i++)
                    if (usedY[i])
                        labelY[i] += delta;
            }

        //for min weighted match
        //int minTotal = BASE * n;
        //for (int i = 0; i < n; i++)
            //minTotal -= labelX[i] + labelY[i];

        //for max weighted match
        int maxTotal = 0;
        for (int i = 0; i < n; i++)
            maxTotal += labelX[i] + labelY[i];

        //return minTotal;
        return maxTotal;
    }
};

int main() {

    cin.sync_with_stdio(false);
    
    cin >> N >> K;
    cin >> A;
    cin >> B;
    
    KuhnMunkres::n = K;
    for (int i = 0; i < N; i++) {
        int u = id(A[i]);
        int v = id(B[i]);
        KuhnMunkres::graph[u][v]++;
    }
    
    cout << KuhnMunkres::KuhnMunkres() << endl;
    
    int array[MaxK];
    
    for (int i = 0; i < K; i++) {
        array[KuhnMunkres::linkTo[i]] = i;
    }
    
    for (int i = 0; i < K; i++) {
        int b = array[i];
        if (b < 26)
             cout << (char)('a' + b);
        else cout << (char)('A' + b - 26);
    }
    cout << endl;
    
    return 0;
}