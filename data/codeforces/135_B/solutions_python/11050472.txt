import sys

sys.setrecursionlimit(10 ** 6)

def pyes_no(condition) :
  if condition :
    print ("YES")
  else :
    print ("NO")

def plist(a, s = ' ') :
  print (s.join(map(str, a)))

def rint() :
  return int(sys.stdin.readline())

def rints() :
  return map(int, sys.stdin.readline().split())

def rfield(n, m = None) :
  if m == None :
    m = n
  
  field = []
  for i in xrange(n) :
    chars = sys.stdin.readline().strip()
    assert(len(chars) == m)
    field.append(chars)
  return field

def pfield(field, separator = '') :
  print ('\n'.join(map(lambda x: separator.join(x), field)))

def check_field_equal(field, i, j, value) :
  if i >= 0 and i < len(field) and j >= 0 and j < len(field[i]) :
    return value == field[i][j]
  return None 

def digits(x, p) :
  digits = []
  while x > 0 :
    digits.append(x % p)
    x //= p
  return digits

def modpower(a, n, mod) :
  r = a ** (n % 2)
  if n > 1 :
    r *= modpower(a, n // 2, mod) ** 2
  return r % mod

def gcd(a, b) :
  if a > b :
    a, b = b, a
  
  while a > 0 :
    a, b = b % a, a

  return b

def vector_distance(a, b) :
  diff = vector_diff(a, b)
  
  return scalar_product(diff, diff) ** 0.5

def vector_inverse(v) :
  r = [-x for x in v]

  return tuple(r)

def vector_diff(a, b) :
  return vector_sum(a, vector_inverse(b))

def vector_sum(a, b) :
  r = [c1 + c2 for c1, c2 in zip(a, b)]
    
  return tuple(r)

def scalar_product(a, b) :
  r = 0
  for c1, c2 in zip(a, b) :
    r += c1 * c2

  return r

from itertools import permutations

points = []
for i in range(8) :
  points.append(tuple(rints()))

from itertools import permutations

def check_rectangle(points) :
  assert(len(points) == 4)

  A, B, C, D = points

  for A1, A2, A3, A4 in [
    (A, B, C, D),
    (A, C, B, D),
    (A, B, D, C),
    (A, C, D, B),
    (A, D, B, C),
    (A, D, C, B),
  ] :
    sides = (
      vector_diff(A1, A2),
      vector_diff(A2, A3),
      vector_diff(A3, A4),
      vector_diff(A4, A1),
    )
    if all(scalar_product(s1, s2) == 0 for s1, s2 in zip(sides, sides[1:])) :
       return True
  return False

def check_square(points) :
  if not check_rectangle(points) :
    return False
  A, B, C, D = points

  for A1, A2, A3, A4 in [
    (A, B, C, D),
    (A, C, B, D),
    (A, B, D, C),
    (A, C, D, B),
    (A, D, B, C),
    (A, D, C, B),
  ] :
    side_lengths = [
      (first[0] - next[0]) ** 2 + (first[1] - next[1]) ** 2 for first, next in zip([A1, A2, A3, A4], [A2, A3, A4, A1])
    ]
    if len(set(side_lengths)) == 1 :
      return True
    
  return False


found = False
for s in set([s for s in permutations([0] * 4 + [1] * 4)]) :
  square = [p for p, v in zip(points, s) if v == 0]
  rectangle = [p for p, v in zip(points, s) if v == 1]
  if check_square(square) and check_rectangle(rectangle) :
    print "YES"
    plist([index + 1 for index, v in enumerate(s) if v == 0])
    plist([index + 1 for index, v in enumerate(s) if v == 1])
    found = True
    break

if not found :
  print "NO"
