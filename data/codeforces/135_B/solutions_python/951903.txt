from itertools import permutations
import math

C=[]
for i in range(8):
    a,b=map(int,raw_input().split())
    C.append((a,b))
f= ''.join
A=map(f,permutations('01234567'))

def normalizeA (a):
    while a>180 :
        a -= 360
    while a< -180 :
        a += 360
    return a

def dif(a,b):
    return abs(normalizeA(a-b))
   
def deg(th):
    return th*180.0/math.pi
   
def v(a,b):
    return ( b[0]-a[0] , b[1]-a[1] )
   
def amod( a,b,c,d ):
    ab=v(a,b)
    th=math.atan2(ab[1],ab[0])
    cd=v(c,d)
    th2=math.atan2(cd[1],cd[0])
    ac=v(a,c)
    th3=math.atan2(ac[1],ac[0])
    bd=v(b,d)
    th4=math.atan2(bd[1],bd[0])
    return dif(deg(th),deg(th3)) == 90.0 and dif(deg(th2),deg(th4)) == 90.0

def r(a,b):
    return ( (a[0]-b[0])**2 + (a[1]-b[1])**2 ) ** 0.5

def mos(a,b,c,d):
    if r(a,b) == r(c,d) and r(a,c) == r(b,d):
        return True
    return False
   
def mor(a,b,c,d):
    if r(a,b) == r(c,d) == r(a,c) == r(b,d):
        return True
    return False

for x in A:
    if amod( C[int(x[0])],C[int(x[1])],C[int(x[2])],C[int(x[3])] ) and mor( C[int(x[0])],C[int(x[1])],C[int(x[2])],C[int(x[3])] ) and amod( C[int(x[4])],C[int(x[5])],C[int(x[6])],C[int(x[7])] ) and mos( C[int(x[4])],C[int(x[5])],C[int(x[6])],C[int(x[7])] ):
        print "YES"
        for i in range(4):
            print int(x[i])+1,
        print
        for i in range(4,8):
            print int(x[i])+1,
        exit()
print "NO"