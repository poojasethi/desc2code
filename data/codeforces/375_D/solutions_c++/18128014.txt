#include <bits/stdc++.h>
#define fi first
#define se second
#define mk make_pair
using namespace std;
typedef pair<int,int> ii;
typedef pair<ii,ii> iiII;
int n,q,s,cc,l,r,start[100005],end[100005],color[200005],c[100005];
int cnt[200005],res[200005],ans[100005];
vector <int> G[100005];
vector <iiII> query;
bool cmp(iiII x,iiII y){
    if (x.se.fi / s == y.se.fi / s) return x.se.se < y.se.se;
    return x.se.fi < y.se.fi;
}
void mkeuler(int u,int parent){
    cc++;   start[u] = cc;   color[cc] = c[u];
    for(int i=0;i<G[u].size();i++){
        int v = G[u][i];
        if (v == parent) continue;
        mkeuler(v,u);
    }
    cc++;   end[u] = cc;     color[cc] = c[u];
}
void sdadd(int pos){
    cnt[color[pos]] ++;
    res[cnt[color[pos]]] ++;
}
void sdremove(int pos){
    res[cnt[color[pos]]]--;
    cnt[color[pos]]--;
}
void update(int num){
    while(l < query[num].se.fi) sdremove(l),l++;
    while(l > query[num].se.fi) l--,sdadd(l);
    while(r < query[num].se.se) r++,sdadd(r);
    while(r > query[num].se.se) sdremove(r),r--;
    ans[query[num].fi.fi] = res[2*query[num].fi.se];
}
int main(){
    scanf("%d %d",&n,&q); s = sqrt(q); res[0] = n;
    for(int i=1;i<=n;i++) scanf("%d",&c[i]);
    for(int i=1;i<n;i++){int x,y;scanf("%d %d",&x,&y);G[x].push_back(y);G[y].push_back(x);}
    mkeuler(1,1);
    for(int i=1;i<=q;i++){int v,k;scanf("%d %d",&v,&k); query.push_back(mk(mk(i,k),mk(start[v],end[v])));}
    sort(query.begin(),query.end(),cmp);
    l = 1,r = 1,sdadd(1);
    for(int i=0;i<query.size();i++) update(i);
    for(int i=1;i<=q;i++) printf("%d\n",ans[i]);
}
