#include <iostream>
#include <algorithm>
#include <cmath>
#include <stdio.h>

#define MX 100005
#define rep(i, n) for (int i = 0; i < n; i ++)

using namespace std;

int N, M, n, rt;
int L[MX], R[MX], CNT;
int E[MX*2], head[MX*2], next[MX*2], C[MX], c[MX];
int tot[MX], sum[MX], rlt[MX];

struct Query {
	int id, v, k;
	bool operator < (const Query &A) const {
		if (L[v] / rt == L[A.v] / rt) {
			if (R[v] != R[A.v]) return R[v] < R[A.v];
			return L[v] < L[A.v];
		}
		return L[v] < L[A.v];
	}
}Q[MX];
		
int Dfs(int id, int pr) {
	c[CNT] = C[id];
	L[id] = CNT ++;
	int u;
	for (int i = head[id]; i; i = next[i]) {
		u = E[i];
		if (u == pr) continue;
		Dfs(u, id);
	}	
	R[id] = CNT - 1;
}

int main() {
	
	cin >> N >> M;
	rt = (int) sqrt(N);
	
	rep(i, N) scanf("%d", C + i);
	
	int x, y;
	rep(i, N - 1) {
		scanf("%d%d", &x, &y);
		x --, y --;
		next[++ n] = head[x]; head[x] = n; E[n] = y;
		next[++ n] = head[y]; head[y] = n; E[n] = x;
	}	
	
	Dfs(0, -1);
	
	rep(i, M) {
		scanf("%d%d", &x, &y);
		Q[i].id = i; Q[i].v = x - 1; Q[i].k = y;
	}
	
	sort(Q, Q + M);
	int st = 0, en = -1;
	int id;
	
	rep(i, N) C[i] = c[i];
	
	rep(i, M) {
		id = Q[i].v;	
		while (en < R[id]) ++ sum[++tot[C[++en]]];
		while (st > L[id]) ++ sum[++tot[C[--st]]];	
		while (en > R[id]) sum[tot[C[en --]] --] --;
		while (st < L[id]) sum[tot[C[st ++]] --] --;
		rlt[Q[i].id] = sum[Q[i].k];
	}
	
	rep(i, M) cout << rlt[i] << endl;
	return 0;
}
