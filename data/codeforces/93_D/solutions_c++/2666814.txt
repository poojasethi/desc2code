#include<cstdio>
#include<cstdlib>
#include<cstring>

using namespace std;

const long long mo=1000000007;

struct matrix
{
	long long z[10][10];
	matrix()
	{
		memset(z,0,sizeof(z));
	}
	matrix operator*(const matrix &a)const
	{
		matrix ans;
		for (int b=1;b<=9;b++)
			for (int c=1;c<=9;c++)
			   for (int d=1;d<=9;d++)
			   ans.z[c][d]=(ans.z[c][d]+z[c][b]*a.z[b][d])%mo;	   
		return ans;
	}
};

long long solve(long long v)
{
	if (!v) return 0ll;
	matrix m1,m2;
	for (int a=1;a<=8;a++)
		m1.z[1][a]=1;
	m1.z[1][9]=4;
	m2.z[1][5]=m2.z[1][6]=m2.z[1][9]=1;
	m2.z[2][7]=m2.z[2][8]=m2.z[2][9]=1;
	m2.z[3][5]=m2.z[3][6]=m2.z[3][9]=1;
	m2.z[4][7]=m2.z[4][8]=m2.z[4][9]=1;
	m2.z[5][1]=m2.z[5][9]=1;
	m2.z[6][3]=m2.z[6][4]=m2.z[6][9]=1;
	m2.z[7][2]=m2.z[7][9]=1;
	m2.z[8][3]=m2.z[8][4]=m2.z[8][9]=1;
	m2.z[9][9]=1;
	v--;
	while (v)
	{
		if (v&1) m1=m1*m2;
		m2=m2*m2;
		v>>=1;
	}
	return m1.z[1][9];
}

long long mul(long long a,long long b)
{
	long long ans=1;
	while (b)
	{
		if (b&1) ans=ans*a%mo;
		a=a*a%mo;
		b>>=1;
	}
	return ans;
}

int main()
{
	long long l,r;
	scanf("%I64d%I64d",&l,&r);
	printf("%I64d\n",(solve(r)-solve(l-1)+solve((r+1)>>1)-solve(l>>1)+mo+mo)*mul(2,mo-2)%mo);

	return 0;
}
