#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#define Rep(i, x, y) for (int i = x; i <= y; i ++)
#define Dwn(i, x, y) for (int i = x; i >= y; i --)
#define RepE(i, x) for(int i = pos[x]; i; i = g[i].nex)
using namespace std;
typedef long long LL;
const int mod = 1000000007, m = 16;
int L, R, ans; bool f0[6][6];
struct Matr
{
	LL a[m + 2][m + 2];
	Matr() { memset(a, 0, sizeof(a)); }
} p0;
Matr operator *(Matr x, Matr y) {
	Matr z;
	Rep(i, 1, m)
		Rep(k, 1, m)
			Rep(j, 1, m) (z.a[i][j] += x.a[i][k] * y.a[k][j]) %= mod;
	return z;
}
LL Calc(int n) {
	if (!n) return 0; n --;
	Matr q, p = p0; LL num = 0;
	Rep(i, 1, 16) q.a[i][i] = 1;
	// cout << n << " ";
	while (n) {
		if (n & 1) q = q * p;
		p = p * p, n >>= 1;
	}
	Rep(i, 1, 15) (num += q.a[i][16]) %= mod;
	// cout << num + 4<<endl;
	return num + 4;
}
int main()
{
	scanf ("%d%d", &L, &R);
	f0[0][2] = f0[2][0] = f0[1][3] = f0[3][1] = 1;
	Rep(i, 0, 3) {
		Rep(j, 0, 3) if (i != j && !f0[i][j]) {
			int x = i * 4 + j, y;
			Rep(k, 0, 3) if (j != k && !f0[j][k]) {
				if (!j && ((i == 1 && k == 3) || (i == 3 && k == 1))) continue ;
				y = j * 4 + k;
				p0.a[x][y] = 1;
				// cout << i <<" "<<j<<" "<<k<<endl;
			}
			p0.a[x][16] = 1; 
		}
	} p0.a[16][16] = 1;
	ans = (Calc(R) - Calc(L - 1) + Calc((R + 1) / 2) - Calc(L / 2) + 2LL * mod) % mod;
	printf("%I64d\n", (LL)ans * (mod + 1 >> 1) % mod);

	return 0;
}
