#include<cstdio>
#include<cstring>
#include<algorithm>
#define lim 1000000007
using namespace std;
struct matrix
{	long long m[7][7];
	matrix()
	{	memset(m,0,sizeof(m));
	}
};
int l,r;
matrix operator *(matrix &a,matrix &b)
{	int i,j,k;
	matrix c;
    for (i=0;i<=6;++i)
		for (j=0;j<=6;++j)
		{	for (k=0;k<=6;++k)
			{	c.m[i][j]+=a.m[i][k]*b.m[k][j]%lim;
				c.m[i][j] %= lim;
			}
        }
    return c;
}
matrix qp(matrix a, int n) {
    matrix c;
	int i,j;
    for (i=0;i<=6;++i) for (j=0;j<=6;++j) c.m[i][j] = (i == j) ? 1 : 0;
    while (n) {
        if (n & 1) c = c * a;
        a = a * a;
        n /= 2;
    }
    return c;
}

long long qp(long long a, int n) {
    long long ret = 1;
    while (n) {
        if (n & 1) ret = ret * a % lim;
        a = a * a % lim;
        n /= 2;
    }
    return ret;
}

int main()
{	int i;
    matrix a;
	scanf("%d%d",&l,&r);
    a.m[0][1]=a.m[0][3]=a.m[0][5]=1;
    a.m[2][1]=a.m[2][3]=a.m[2][4]=1;
    a.m[3][0]=a.m[3][2]=1;
    a.m[4][2]=1,a.m[5][0]=1;
    for (i=0;i<=6;++i)
		a.m[6][i] = 1;
    matrix rl = qp(a, l - 1);
    matrix rll = qp(a, l / 2);
    matrix rr = qp(a, r);
    matrix rrr = qp(a, (r + 1) / 2);
    long long ans = 0;
    for (i = 0; i < 4; i++) {
        ans += rr.m[6][i] - rl.m[6][i];
        ans += rrr.m[6][i] - rll.m[6][i];
    }
    ans %= lim;
    ans = ans * qp(2, lim - 2) % lim;
    printf("%lld\n",(ans + lim) % lim);
    return (0);
}

	  				   			 			 						