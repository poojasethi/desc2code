#include<cstdio>
#include<cstring>
#include<algorithm>
#define lim 1000000007
using namespace std;
struct matrix
{	long long a[10][10];
	matrix()
	{	memset(a,0,sizeof(a));
	}
};
int l,r;
matrix operator *(matrix &a,matrix &b)
{	int i,j,k;
	matrix c;
    for (i=0;i<=6;++i)
		for (j=0;j<=6;++j)
		{	for (k=0;k<=6;++k)
			{	c.a[i][j]+=a.a[i][k]*b.a[k][j]%lim;
				c.a[i][j]%=lim;
			}
        }
    return c;
}
matrix qp(matrix b,int e)
{	matrix t,ans;
	t=b;
    ans.a[0][0]=ans.a[1][1]=ans.a[2][2]=ans.a[3][3]=ans.a[4][4]=ans.a[5][5]=ans.a[6][6]=1;
    while (e)
    {	if (e&1)
			ans=ans*t;
        t=t*t;
        e>>=1;
    }
    return ans;
}
long long qp(long long b,int e)
{	long long t,ans;
	t=b,ans=1;
	while (e)
	{	if (e&1)
		{	ans*=t;
			ans%=lim;
		}
		t*=t;
		t%=lim;
		e>>=1;
	}
	return ans;
}
long long work()
{	matrix m0,m1,m2,m3,m4;
    long long ans=0;
    int i;
	m0.a[0][1]=m0.a[0][3]=m0.a[0][5]=1;
    m0.a[2][1]=m0.a[2][3]=m0.a[2][4]=1;
    m0.a[3][0]=m0.a[3][2]=1;
    m0.a[4][2]=1,m0.a[5][0]=1;
    for (i=0;i<=6;++i)
		m0.a[6][i]=1;
    m1=qp(m0,l-1);
    m2=qp(m0,l/2);
    m3=qp(m0,r);
    m4=qp(m0,(r+1)/2);
    for (i=0;i<4;++i)
    {	ans+=m3.a[6][i]-m1.a[6][i];
        ans+=m4.a[6][i]-m2.a[6][i];
		ans%=lim;
    }
    ans=ans*qp(2,lim-2)%lim;
    return ans+lim;
}
int main()
{	scanf("%d%d",&l,&r);
    printf("%lld\n",work()%lim);
    return (0);
}

			 	 					 	 				   	  	 	