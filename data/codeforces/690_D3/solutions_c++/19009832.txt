#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define mod 1000003

struct mat
{
	ll **a, len;
	mat(){}
	mat(ll n)
	{
		len = n;
		a = new ll*[len];
		for(ll i = 0; i < n; i++)		
			a[i] = new ll[len];
		for(ll i = 0; i < n; i++)
			for(ll k = 0; k < n; k++)
				a[i][k] = 0;
	}	
	mat operator*(mat ma)
	{
		mat ret(len);
		for(ll i = 0; i < len; i++)
			for(ll k = 0; k < len; k++)
				for(ll h = 0; h < len; h++)
					ret.a[i][k] = (ret.a[i][k] + a[i][h] * ma.a[h][k] % mod) % mod;
		return ret;
	}
};
mat pw(mat ma, ll k)
{
	ll len = ma.len;
	mat ret(len);	
	for(ll i = 0; i < len; i++)
		for(ll k = 0; k < len; k++)
			ret.a[i][k] = i == k;
	while(k)
	{
		if(k&1)
			ret = ret*ma;
		k >>= 1;
		ma = ma*ma;;
	}
	return ret;
}
ll *p;
ll power(ll n, ll k)
{
	ll ret = 1;
	while(k)
	{
		if(k&1)
			ret = ret*n % mod;
		k >>= 1;
		n = n*n % mod;
	}
	return ret;
}

int main()
{
	ll c, w, h, i, k, ans = 0;
	scanf("%I64d %I64d %I64d", &c, &w, &h);
	if(c <= w)
	{
		printf("%I64d", power(h + 1, c));
		return 0;
	}
	w++;
	mat ret(w);
	for(i = 0; i < w; i++)
	{
		ret.a[0][i] = 1;
		if(i < w - 1)
			ret.a[i + 1][i] = h;
	}
	p = new ll[w];
	for(i = 0; i < w; i++)
	{
		k = power(h, i);
		k = k*power(h + 1, max(0LL, w - i - 2)) % mod;
		p[i] = k;
	}
	mat ret2 = pw(ret, c - w + 1);
	for(i = 0; i < w; i++)
		for(k = 0; k < w; k++)
			ans = (ans + ret2.a[i][k]*p[k] % mod) % mod;
	printf("%I64d", ans);
	return 0;
}