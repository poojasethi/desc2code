#include <bits/stdc++.h>

using namespace std;

#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)

#define type(x) __typeof(x.begin())

#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair < int ,int > pii;

typedef long long ll;

const long long linf = 1e18+5;
int mod = (int) 1000003;
const int logN = 18;
const int inf = 1e9 + 9;
const int N = 2003;

int a[132], n, m, x, c, w, h;

class matrix {
public:
    vector< vector< int > > v;
    int n;
    matrix(int x) {
        n = x;
        v.resize(x + 1);
        FOR(i, 1, x)
            v[i].resize(x+1,0);
    }
    vector<int>& operator[](int x) { return v[x]; }
    matrix operator*(matrix y) {
        matrix ans(n);
        FOR(i, 1, n)
            FOR(j, 1, n)
                FOR(k, 1, n)
                    ans[i][j] = (ans[i][j] + (ll) v[i][k] * y[k][j]) % mod;
        return ans;
    }
};

matrix FE(matrix A, int c) {
    matrix ans(A.n);
    int n = A.n;
    FOR(i, 1, n)
        ans[i][i] = 1;
    while(c) {
        if(c & 1) ans = ans * A;
        A = A * A;
        c >>= 1;
    } return ans;
}

int main() {
    scanf("%d %d %d", &c, &w, &h);
    a[0] = 1;
    FOR(i, 1, w) {
        a[i] = a[i - 1] * (ll) (h) % mod;
    }
    matrix A(w+1);
    int sz = w + 1;
    FOR(i, 2, sz)
        A[i][i-1] = 1;
    A[1][1] = 1;
    FOR(i, 1, w) {
        A[1][i+1] = a[i];
    }
    A = FE(A, c);
    printf("%lld\n", (A[1][1] + A[1][2]) % mod);
}
