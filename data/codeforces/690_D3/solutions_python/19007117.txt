#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <string>
#include <sstream>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <ctime>

#define inf 0x3f3f3f3f
#define Inf 0x3FFFFFFFFFFFFFFFLL
#define rep(i, n) for (int i = 0; i < (n); ++i)
#define Rep(i, n) for (int i = 1; i <= (n); ++i)
#define clr(x, a) memset(x, (a), sizeof x)
using namespace std;
typedef long long ll;
ll const mod = 1000003LL;
int const N = 105;
struct Matrix {
  int n; ll a[N][N];
  Matrix(int _n = 0) {
    n = _n;
    clr(a, 0);
  }
  Matrix operator* (Matrix const &t) {
    Matrix r(n);
    rep(i, n) rep(j, n) if (a[i][j]) rep(k, n) {
      r.a[i][k] += a[i][j] * t.a[j][k];
			r.a[i][k] %= mod;
    }
    return r;
  }
  Matrix operator^ (ll m) {
    Matrix r(n); rep(i, n) r.a[i][i] = 1;
    Matrix s(*this);
    for (; m; m >>= 1) {
      if (m & 1) r = r * s;
      s = s * s;
    }
    return r;
  }
  void pr() {
    rep(i, n) rep(j, n) cout << a[i][j] << (j == n - 1 ? '\n' : ' ');
  }
} A, B, C;
ll f[N], g[N];
int main() {
	int c, w, h; scanf("%d%d%d", &c, &w, &h);
	f[0] = 1;
	Rep(i, w) f[i] = f[i - 1] * h % mod;
	g[0] = 1;
	Rep(i, w) {
		g[i] = g[i - 1];
		Rep(j, w) {
			if (i == j) {
				g[i] += f[j];
				if (g[i] >= mod) g[i] -= mod;
			} else if (i - j - 1 >= 0) {
				g[i] += g[i - j - 1] * f[j];
				g[i] %= mod;
			}
		}
	}
	A = Matrix(w + 1);
	rep(i, w + 1) A.a[0][i] = f[i];
	for (int i = 1; i < w + 1; ++i) {
		A.a[i][i - 1] = 1;
	}
	B = A^(c+1);
	cout << B.a[0][0] << endl;
	return 0;
}

