#include<bits/stdc++.h>
using namespace std;
const int N = 400004;
int n, m, c, x, y, t, idx, a[N], b[N], f[N], to[N], lazy[4*N];
vector<int> v[N];
long long sgt[4*N];

void build(int p, int x, int y) {
	if(x == y) {
		sgt[p] = (1LL << a[b[x]]);
		return;
	}
	build(p<<1, x, ((x+y)>>1));
	build((p<<1)+1, ((x+y)>>1)+1, y);
	sgt[p] = sgt[p<<1] | sgt[(p<<1)+1];
}

void update(int p, int x, int y, int i, int j, int v){
	if(lazy[p]) {
		sgt[p] = (1LL << lazy[p]);
		if(x != y) lazy[p<<1] = lazy[(p<<1)+1] = lazy[p];
		lazy[p] = 0;
	}
	if(i > y || j < x) return;
	if(i<=x && y<=j) {
		sgt[p] = (1LL << v);
		if(x != y) lazy[p<<1] = lazy[(p<<1)+1] = v;
		return;
	}
	update(p<<1, x, ((x+y)>>1), i, j, v);
	update((p<<1)+1, ((x+y)>>1)+1, y, i, j, v);
	sgt[p] = sgt[p<<1] | sgt[(p<<1)+1];
}

long long get(int p, int x, int y, int i, int j) {
	if(lazy[p]) {
		sgt[p] = (1LL << lazy[p]);
		if(x != y) lazy[p<<1] = lazy[(p<<1)+1] = lazy[p];
		lazy[p] = 0;
	}
	if(i > y || j < x) return 0;
	if(i <= x && y <= j) return sgt[p];
	return get(p<<1, x, ((x+y)>>1), i, j) | get((p<<1)+1, ((x+y)>>1)+1, y, i, j);
}

void dfs(int u, int p) {
	f[u] = idx;  b[idx++] = u;
	for(int i=0 ; i<(int)v[u].size() ; ++i)
		if(v[u][i] != p) dfs(v[u][i], u);
	to[u] = idx-1;
}

int main(int argc, char **argv) {
	scanf("%d%d", &n, &m);
	for(int i=1 ; i<=n ; ++i)  scanf("%d", a+i);
	for(int i=1; i<n ; ++i) {
		scanf("%d%d", &x, &y);
		v[x].push_back(y), v[y].push_back(x);
	}
	dfs(1, 0);
	build(1, 0, n-1);
	while(m--) {
		scanf("%d%d", &t, &x);
		if(t == 1) {
			scanf("%d", &c);
			update(1, 0, n-1, f[x], to[x], c);
		} else  printf("%d\n", __builtin_popcountll(get(1, 0, n-1, f[x], to[x])));
	}
	return 0;
}
