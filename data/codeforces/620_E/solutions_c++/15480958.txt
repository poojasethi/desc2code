#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
#define ls(p) (p<<1)
#define rs(p) ((p<<1)+1) 
#define N 400010
int head[2*N],last[2*N],p[N],e;
bool v[N];
int l[N],r[N],c[N],rev[N];
int time_order,n,m;
struct segment{
	int l,r,cov;
	long long val;
} t[N*5];
void add(int x,int y){
	head[++e]=y;
	last[e]=p[x];
	p[x]=e;
}
void dfs(int x){
	v[x]=true;
	l[x]=++time_order;
	rev[l[x]]=x;
	for(int j=p[x];j;j=last[j]){
		if(!v[head[j]])
			dfs(head[j]);
	}
	r[x]=time_order;
}
void update(int p,int y){
		t[p].cov=y;
		t[p].val=1LL<<y;
}
void spread(int p){
	if(t[p].cov){
		update(ls(p),t[p].cov);
		update(rs(p),t[p].cov);
		t[p].cov=0;
	}
}
void build(int p,int l,int r){
	t[p].l=l;t[p].r=r;
	if(l==r){
		t[p].val=1LL<<c[rev[l]];
		t[p].cov=0;
		return;
	}
	int mid=l+r>>1;
	build(ls(p),l,mid);
	build(rs(p),mid+1,r);
	t[p].val=t[ls(p)].val | t[rs(p)].val;
}
void change(int p,int l,int r,int y){
	if(l<=t[p].l && t[p].r<=r){
		update(p,y);
		return;
	}
	spread(p);
	int mid=(t[p].l+t[p].r)>>1;
	if(l<=mid) change(ls(p),l,r,y);
	if(mid<r) change(rs(p),l,r,y);
	t[p].val=t[ls(p)].val | t[rs(p)].val;
}
long long ask(int p,int l,int r){
	if(l<=t[p].l && t[p].r<=r){
		return t[p].val;
	}
	spread(p);
	long long ans=0;
	int mid=(t[p].l+t[p].r)>>1;
	if(l<=mid) ans|=ask(ls(p),l,r);
	if(mid<r) ans|=ask(rs(p),l,r);
	return ans;
}
int work(long long x){
	int ans=0;
	while(x){
		if(x&1) ans++;
		x/=2;
	}
	return ans;
}
int main(){
	//freopen("input.txt","r",stdin);
	int i,x,y,opt;
	cin>>n>>m;
	for(i=1;i<=n;i++) scanf("%d",c+i);
	for(i=1;i<n;i++){
		scanf("%d%d",&x,&y);
		add(x,y);
		add(y,x);
	}
	dfs(1);
	build(1,1,n);
	while(m--){
		scanf("%d",&opt);
		if(opt==1){
			scanf("%d%d",&x,&y);
			change(1,l[x],r[x],y);
		}
		else {
			scanf("%d",&x);
			printf("%d\n",work(ask(1,l[x],r[x])));
		}
	}
} 