#include<bits/stdc++.h>
using namespace std;

const int N = 400005;

typedef long long ll;

vector< int > g[N];

int seen[4 * N];
int col[4 * N];
int tin[4 * N];
int tout[4 * N];
int add[4 * N];

ll tree[4 * N];

int tt;

void dfs(int u,int par){
    tin[u] = ++tt;
    seen[tt] = u;
    for(int i=0;i<(int)g[u].size();i++){
        int v = g[u][i];
        if(v != par) dfs(v,u);
    }
    tout[u] = tt;
}

inline void merge(int x){
    tree[x] = tree[x + x] | tree[x + x + 1];
}

inline void lazy(int x){
    if(add[x] == 0) return ;
    tree[x + x] = tree[x + x + 1] = tree[x];
    add[x] = 0; add[x + x] = add[x + x + 1] = -1;
}

void build(int v,int l,int r){
    if(l == r){
        tree[v] = (1LL << col[seen[l]]);
        return ;
    }
    int md = (l + r) >> 1;
    build(2*v, l, md);
    build(2*v + 1, md + 1, r);
    merge(v);
}

void update(int v,int l,int r,int i,int j,ll cx){
    if(j < l || i > r) return ;
    if(l >= i && r <= j){
        tree[v] = cx;
        add[v] = -1;
        return ;
    }
    lazy(v);
    int md = (l + r) >> 1;
    update(2*v , l, md, i, j, cx);
    update(2*v + 1, md + 1, r, i, j, cx);
    merge(v);
}

ll get(int v,int l,int r,int i,int j){
    if(l > j || r < i) return 0;
    if(l >= i && r <= j) return tree[v];
    lazy(v);
    int md = (l + r) >> 1;
    ll p1 = get(2*v, l, md, i, j);
    ll p2 = get(2*v + 1, md + 1, r, i, j);
    merge(v);
    return (p1 | p2);
}

int main(){
    ios_base::sync_with_stdio(0); cin.tie(0);
    int n,q; cin >> n >> q;
    for(int i=1;i<=n;i++) cin >> col[i];
    for(int i=1;i<n;i++){
        int u,v; cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    dfs(1,-1);
    build(1,1,n);
    for(int i=1;i<=q;i++){
        int ty; cin >> ty;
        if(ty == 1){
            int v,cx; cin >> v >> cx;
            update(1,1,n,tin[v],tout[v],(1LL << cx));
        }else{
            int v; cin >> v;
            ll ans = get(1,1,n,tin[v],tout[v]);
            printf("%d\n",__builtin_popcountll(ans));
        }
    }
    return 0;
}
