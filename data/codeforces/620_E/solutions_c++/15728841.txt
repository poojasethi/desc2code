#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1
const int maxn=400010;
typedef long long ll;
ll c[maxn];
int used[maxn];
vector<int>G[maxn];
typedef struct edge{
	int l,r;
}edge;
edge E[maxn];
int var[maxn];
ll add[maxn<<2],sum[maxn<<2];
int time1=0;
void dfs(int v)
{
	E[v].l=++time1;
	var[time1]=c[v];
	used[v]=1;
	for(int i=0;i<G[v].size();i++)
	{
		int u=G[v][i];
		if(!used[u])dfs(u);
	}
	E[v].r=time1;
}
void pushup(int rt)
{
	sum[rt]=(sum[rt<<1]|sum[rt<<1|1]);
}
void pushdown(int rt)
{
	if(add[rt])
	{
		add[rt<<1]=add[rt<<1|1]=add[rt];
		sum[rt<<1]=sum[rt<<1|1]=(1ll<<add[rt]);
		add[rt]=0;
	}
}
void build(int l,int r,int rt)
{
	add[rt]=0;
	if(l==r){
		sum[rt]=(1ll<<(var[l]));
		return;
	}
	int m=(l+r)>>1;
	build(lson);
	build(rson);
	pushup(rt);
}
void updata(int L,int R,int sc,int l,int r,int rt)
{
	if(L<=l&&r<=R)
	{
		add[rt]=sc;
		sum[rt]=(1ll<<sc);
		return;
	}
	int m=(l+r)>>1;
	pushdown(rt);
	if(L<=m)updata(L,R,sc,lson);
	if(R>m)updata(L,R,sc,rson);
	pushup(rt);
}
ll query(int L,int R,int l,int r,int rt)
{
	if(L<=l&&r<=R)
	{
		return sum[rt];
	}
	pushdown(rt);
	int m=(l+r)>>1;
	ll ans=0;
	if(L<=m) ans|=query(L,R,lson);
	if(R>m) ans|=query(L,R,rson);
	return ans;
}
int solve(ll temp)
{
	int sum=0;
	while(temp){
		if(temp&1)sum++;
		temp>>=1;
	}
	return sum;
}
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%lld",&c[i]);
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		G[x].push_back(y);
		G[y].push_back(x);
	}
	dfs(1);
	build(1,n,1);
	for(int i=1;i<=m;i++)
	{
		int a,b;
		ll sc;
		scanf("%d%d",&a,&b);
		if(a==1){
			scanf("%lld",&sc);
			updata(E[b].l,E[b].r,sc,1,n,1);
		}
		else{
			ll ans=query(E[b].l,E[b].r,1,n,1);
			cout<<solve(ans)<<endl;
		}
	}
	return 0;
}