#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 400005;
ll st[4 * N], lazy[4 * N], v, c[N];
int s[N], e[N], o[N], t, n, m, x, y, id;
vector<int> g[N];

int dfs(int u, int p) {
	s[u] = e[u] = id++;
	o[id - 1] = u;
	for (int i = 0; i < (int) g[u].size(); ++i)
		if (g[u][i] != p)
			e[u] = dfs(g[u][i], u);
	return e[u];
}

void build(int p, int s, int e) {
	if (s == e) {
		st[p] = c[o[s]];
		return;
	}
	int mid = (s + e) >> 1;
	build(p << 1, s, mid);
	build((p << 1) + 1, mid + 1, e);
	st[p] = st[p << 1] | st[(p << 1) + 1];
}

inline void fix(int p, int s, int e) {
	if (lazy[p]) {
		st[p] = lazy[p];
		if (s != e) {
			lazy[p << 1] = lazy[p];
			lazy[(p << 1) + 1] = lazy[p];
		}
		lazy[p] = 0;
	}
}

void update(int p, int s, int e, int a, int b, ll val) {
	fix(p, s, e);
	if (b < s || e < a)
		return;
	if (a <= s && e <= b) {
		st[p] = val;
		if (s != e) {
			lazy[p << 1] = val;
			lazy[(p << 1) + 1] = val;
		}
		return;
	}
	int mid = (s + e) >> 1;
	update(p << 1, s, mid, a, b, val);
	update((p << 1) + 1, mid + 1, e, a, b, val);
	st[p] = st[p << 1] | st[(p << 1) + 1];
}

ll get(int p, int s, int e, int a, int b) {
	fix(p, s, e);
	if (b < s || e < a)
		return 0;
	if (a <= s && e <= b)
		return st[p];
	int mid = (s + e) >> 1;
	return get(p << 1, s, mid, a, b) | get((p << 1) + 1, mid + 1, e, a, b);
}

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 0; i < n; ++i) {
		scanf("%lld", c + i);
		c[i] = 1LL << c[i];
	}
	for (int i = 1; i < n; ++i) {
		scanf("%d%d", &x, &y);
		--x, --y;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	dfs(0, -1);
	build(1, 0, n - 1);
	while (m--) {
		scanf("%d%d", &t, &x);
		--x;
		if (t == 2) {
			printf("%d\n",
					(int) __builtin_popcountll(get(1, 0, n - 1, s[x], e[x])));
		} else {
			scanf("%lld", &v);
			v = 1LL << v;
			update(1, 0, n - 1, s[x], e[x], v);
		}
	}
	return 0;
}
