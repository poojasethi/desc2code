#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
const int N=600600;
ll st[N*5];
int in[N] , out[N] , cur=0 ;
int c[N];
int lazy[N*5];
int a[N*2];
int t , x, xx , n  , m ;
vector<ll> adj[N];

void dfs(int ver , int par){
cur++;
in[ver]=cur;
a[cur]=c[ver];

for(unsigned int i=0;i<adj[ver].size();i++){
    int nxt=adj[ver][i];
    if( nxt==par )continue;
    dfs(nxt,ver);
}
cur++;
a[cur]=c[ver];
out[ver]=cur;

}


void build(int node , int l , int r){

if( l == r ){ st[node]=1LL<<a[l]; return;}

int mid=(l+r)>>1;
build(node*2   ,  l   , mid );
build(node*2+1 ,mid+1 , r   );

st[node] = st[ node*2 ] | st[ node*2+1 ];

}

void push(int node ,int l , int r ){

if( lazy[node] !=0 ){

    st[node]=(1LL<<(lazy[node]));

    if( l != r ){

    lazy[node*2]   =lazy[node];
    lazy[node*2 +1]=lazy[node];

    }

    lazy[node]=0;
}
}

void change(int node ,  int l , int r , int s , int e ,int c ){
push( node , l , r );

if( r<s || l>e )return;
else if( s<=l && r<=e ){
lazy[node]=c;
push(node,l,r);
return;
}

int mid=(l+r)>>1;
change(node*2   , l , mid , s , e , c);
change(node*2 +1,mid+1, r , s , e , c);
st[node] = st[node*2] | st[node*2 +1] ;

}

ll query(int node , int l ,int r , int s , int e){
push(node,l,r);

if( e<l || r<s )return 0LL;

if( s<=l && r<=e )return st[node];

int mid=(l+r)>>1;
return query(node*2   ,  l  ,mid ,s,e) | query(node*2+1 ,mid+1, r  ,s,e);
}

int main()
{

scanf("%d %d",&n,&m);

for(int i=1;i<=n;i++) scanf("%d",&c[i]);

for(int i=0;i<n-1;i++){
   scanf("%d %d",&x,&xx);
   adj[x].push_back(xx);
   adj[xx].push_back(x);
}

dfs(1,1);
build(1,1,cur);

while(m--){
scanf("%d",&x);
if( x==1 ){
scanf("%d %d",&x,&xx);

change( 1 , 1 , cur , in[x] , out[x] , xx );


}else{
scanf("%d",&x);
ll ans = query( 1 , 1 , cur , in[x] , out[x] );
printf("%d\n",__builtin_popcountll(ans));
}


}
    return 0;
}
