#include <bits/stdc++.h>
using namespace std;
const int N = 4e5+3;
int c[N];
#define ll long long
ll tree[N*4];
int lazy[N*4];
void cons(int pos,int l,int r){
	if(l==r){
		tree[pos]= 1LL<<c[l];return;
	}
	int mid = (l+r)/2;
	cons(2*pos,l,mid);
	cons(2*pos+1,mid+1,r);
	tree[pos]= tree[2*pos]|tree[2*pos+1];
}
#define up(c) tree[pos]= 1LL<<c;if(a!=b){lazy[pos*2]=c,lazy[pos*2+1]=c;}
void upd(int pos,int a,int b,int l,int r,int c){
	if(lazy[pos]!=0){
		up(lazy[pos])
		lazy[pos]=0;
	}
	if(r<a || b<l)return;
	if(l<=a && b<=r){
		up(c)
		return;
	}
	int mid = (a+b)/2;
	upd(2*pos,a,mid,l,r,c);
	upd(2*pos+1,mid+1,b,l,r,c);
	tree[pos]= tree[pos*2+1] | tree[pos*2];
}
ll query(int pos,int a,int b,int l,int r){
	if(r<a || b<l )return 0;
	if(lazy[pos]!=0){
		up(lazy[pos])
		lazy[pos]=0;
	}
	if(l<=a && b<=r)return tree[pos];
	int mid = (a+b)/2;
	return query(2*pos,a,mid,l,r) | query(2*pos+1,mid+1,b,l,r);
}
int pp=0;
vector<int> adj[N];
int ord[N],to[N],tt[N];
void dfs(int x,int par=-1){
	int i;
	ord[x]= pp++;
	for(i=0;i<adj[x].size();++i){
		if(adj[x][i]!=par)
			dfs(adj[x][i],x);
	}
	to[x]= pp-1;
}
int main(){
	int a,b,y,n,m,i,j,ret;scanf("%d%d",&n,&m);
	for(i=1;i<=n;++i)scanf("%d",&c[i]);
	for(i=0;i<n-1;++i)
		scanf("%d%d",&a,&b),adj[a].push_back(b),adj[b].push_back(a);
	dfs(1);
	for(i=1;i<=n;++i)
		tt[ord[i]]=c[i];
	memcpy(c,tt,sizeof(c));
	cons(1,0,pp-1);ll q;
	for(i=0;i<m;++i){
		scanf("%d%d",&a,&b);
		if(a==1){
			scanf("%d",&y);
			upd(1,0,pp-1,ord[b],to[b],y);
		}
		else{
			ret=0;q= query(1,0,pp-1,ord[b],to[b]);
			for(j=1;j<=60;++j)
				if( q&(1LL<<j))++ret;
			printf("%d\n",ret);
		}
	}
}
