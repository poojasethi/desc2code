#define sd(n) scanf("%d",&n)
#define slld(n) scanf("%lld",&n)

#define pd(n) printf("%d",n)
#define plld(n) printf("%lld",n)
#define pdws(n) printf("%d ",(n))
#define pnl() printf("\n")

#define getmax(a,b) (((a)>(b))?(a):(b))

#include <cstdio>
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <map>
using namespace std;

typedef long long ll;
const int ZUIDA = 4e6+11;
ll segment[ZUIDA], lazy[ZUIDA];
int Search[ZUIDA], Find[ZUIDA], t, c[ZUIDA], k,v,cc,n,m;
vector <int> g[ZUIDA];
void dfs(int v, int p=-1)
{
	//cout<<v<<"\n";
	Search[v]=t++;
	for ( int u = 0; u < g[v].size(); ++u)
		if(g[v][u]!=p) dfs(g[v][u],v);
	Find[v] = t;
}
void shift(int ind)
{
	if(lazy[ind]) segment[ind*2+1]=segment[ind*2+2]=lazy[ind*2+1]=lazy[ind*2+2]=lazy[ind];
	lazy[ind]=0;
}
void uD(int L,int R, ll val, int B=0, int E=n, int ind=0)
{
	//cout<<B<<" "<<E<<endl;
	//cout<<"UPDATE"<<endl;
	//cout<<B<<" "<<E<<endl;

	if (R<=B or E<=L) { return ; }
	if (L<=B and E<=R) {segment[ind]=lazy[ind]=val; return ;}

	int ZHONG=B+E>>1;
	shift(ind);
	uD(L,R,val,B,ZHONG,ind*2+1) , uD(L,R,val,ZHONG,E,ind*2+2) ;
	segment[ind]=segment[ind*2+1]|segment[ind*2+2];
}
ll retrieve(int L, int R, int B=0, int E=n, int ind=0, int depth=0)
{
	//cout<<L<<" "<<R<<"\n";
	//cout<<"RETRIEVAL"<<endl;
	//cout<<B<<" "<<E<<" "<<depth<<endl;
	if(R<=B or E<=L) return 0;
	if(L<=B and E<=R) return segment[ind];
	int ZHONG=B+E>>1;
	shift(ind);
	return retrieve(L,R,B,ZHONG,ind*2+1,depth+1)|retrieve(L,R,ZHONG,E,ind*2+2) ;
}
int main() {
	//freopen("CF.in","r",stdin);
	ios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for (int i = 0; i < n; ++i) cin>>c[i];
	for (int i = 0,v,u; i < n-1; ++i) 
		cin>>v>>u, v--, u--, g[v].push_back(u), g[u].push_back(v);

	dfs(0);
	//cout<<"\n";
	for (int i=0;i<n;i++) uD(Search[i],Search[i]+1,1LL<<c[i]);
	while (m--)
	{
		cin>>k>>v,v--;
		if (k==1) cin>>cc,uD(Search[v],Find[v],1LL<<cc);
		else cout<<__builtin_popcountll(retrieve(Search[v],Find[v]))<<'\n';
	}

	return 0;
}