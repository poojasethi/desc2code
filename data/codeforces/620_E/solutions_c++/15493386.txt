#include<bits/stdc++.h>

#define ll long long

using namespace std;

const int Sz = 500000;
ll n , m , col[Sz];
struct lal{
	bool ch;
	ll val;
} t[Sz * 6 + 123];
vector<int> V , g[Sz];
ll sz = 0 , tout[Sz] , tin[Sz];

ll pow2(ll x){
	ll res = 1;
	while(x --)	res *= 2;
	return res;
}	

void dfs(int v , int p){
	tin[v] = ++ sz;
	V.push_back(v);
	for(int i = 0;i < g[v].size();i ++){
		int to = g[v][i];
		if(to != p)	dfs(to , v);
	}
	V.push_back(v);
	tout[v] = ++ sz; 
}
void push(int v , int tl , int tr){
	if(t[v].ch && tl < tr){
		t[v * 2 + 1] = t[v * 2] = t[v];
		t[v].ch = 0;
	}
}	
void build(int v , int tl , int tr){
	if(tl == tr){
		t[v].val = (pow2 (col[V[tl - 1]]));
		return;
	}
	int tmid = (tl + tr) / 2;
	build(v * 2 , tl , tmid);
	build(v * 2 + 1 ,tmid + 1, tr);
	t[v].val = t[v * 2].val | t[v * 2 + 1].val;
}
void upd(int v , int tl , int tr , int l , int r , int x){
	push(v , tl , tr);
	if(tl > r || tr < l)	return;
	if(l <= tl && tr <= r){
		t[v].ch = 1;
	   t[v].val = pow2(x);
		return;
	}
	push(v , tl , tr);
	int tmid = (tl + tr) / 2;
	upd(v * 2 , tl , tmid , l , r , x);
	upd(v * 2 + 1 , tmid + 1 , tr , l , r , x);
	t[v].val = t[v * 2].val | t[v * 2 + 1].val;
}
int calc(ll x){
	int res = 0;
	while(x){
		res += (x&1);
		x /= 2;
	}
	return res;	
}
ll get(int v , int tl , int tr , int l , int r){
	if(tl > r || tr < l)	return 0ll;
	if(l <= tl && tr <= r)
		return t[v].val;
	push(v , tl , tr);
	int tmid = (tl + tr) / 2;	
	return get(v * 2, tl , tmid , l , r) | get(v * 2 + 1 , tmid + 1 , tr , l , r);
}
int main()
{

	scanf("%d %d" , &n , &m);
	for(int i = 1;i <= n;i ++)	scanf("%d" , &col[i]);
	
	for(int i = 1;i < n;i ++){
		int x , y;	scanf ("%d%d" , &x , &y);
		g[x].push_back(y);
		g[y].push_back(x);
	}	
	dfs (1 , 1);
	build (1 , 1 , sz);
	
	while (m --){
		int type , v , c;
		scanf("%d %d" , &type , &v);
		if (type == 1){
			scanf("%d" , &c);
			upd(1 , 1 , sz , tin[v] , tout[v] , c);
		}	else {
			printf("%d\n" , calc(get(1 , 1 , sz , tin[v] , tout[v])));
		}
	}
	return 0;
}	