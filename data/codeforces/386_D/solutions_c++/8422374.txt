
//#include <GOD>

#include <iostream>
#include <cmath>
#include <algorithm>
#include <vector>
#include <string>
#include <set>
#include <queue>
#include <map>
#include <stack>
#include <deque>
#include <iomanip>
#include <fstream>

using namespace std;


typedef long long ll;

struct Rock{

    ll a, b, c;

    void update(ll A, ll B, ll C)
    {
        int t[3]={A, B, C};
        sort(t, t+3);
        a=t[0], b=t[1], c=t[2];
    }

};

const ll N=70+5;
string s[N];
bool mark[N][N][N];
ll dis[N][N][N];
ll n;
queue<pair<Rock, vector <pair<ll, ll> > > > q;


void push_bfs(ll a, ll b, ll c, vector<pair<ll, ll> > &v)
{
    for (int i=0; i<n; i++)
        if (i!=b && i!=c && s[i][a]==s[b][c])
        {
            Rock o;
            o.update(i, b, c);
            if (!mark[o.a][o.b][o.c] )
            {
                mark[o.a][o.b][o.c]=1;
                v.push_back(make_pair(a, i));
                q.push(make_pair(o, v));
                v.pop_back();
            }
        }
}


int main()
{
    cin >> n;

    Rock r;
    int a1, a2, a3;
    cin >> a1 >> a2 >> a3;
    r.update(--a1, --a2, --a3);

    for (int i=0; i<n; i++)
        cin >> s[i];
    Rock c;
    c.update(0, 1, 2);
    vector<pair<ll, ll> > v;
    q.push(make_pair(c, v));
    mark[0][1][2]=1;

    while (!q.empty())
    {
        Rock x=q.front().first;
        vector<pair<ll, ll> > path=q.front().second;
        q.pop();

        if (x.a==r.a && x.b==r.b && x.c==r.c)
        {
            cout << path.size() << endl;
            for (int i=path.size()-1; i>=0; i--)
                cout << path[i].second+1 << " " << path[i].first+1 << endl;
            return 0;
        }

        push_bfs(x.a, x.b, x.c, path);
        push_bfs(x.b, x.a, x.c, path);
        push_bfs(x.c, x.a, x.b, path);
    }

    cout << -1;

}
