#include <bits/stdc++.h>
using namespace std;

const int N = 75;
struct point
{
    int x,y,z;
    point(int x,int y,int z):x(x),y(y),z(z) {}
    point() {
        x = y = z = -1; 
    }
}pre[N][N][N];
queue<point> q;

char s[N][N];
int visit[N][N][N];
int n;
bool check(int x,int y,int z)
{
    int a[5];
    a[0] = x;
    a[1] = y;
    a[2] = z;
    sort(a,a + 3);
    return a[0] == 0 && a[1] == 1 && a[2] == 2;
}

void output(int x,int y,int z)
{
    if(pre[x][y][z].x == -1) return;
    output(pre[x][y][z].x,pre[x][y][z].y,pre[x][y][z].z);
    if(x != pre[x][y][z].x) cout << pre[x][y][z].x + 1 << " " << x + 1 << endl;
    if(y != pre[x][y][z].y) cout << pre[x][y][z].y + 1 << " " << y + 1 << endl;
    if(z != pre[x][y][z].z) cout << pre[x][y][z].z + 1 << " " << z + 1 << endl;
}

void bfs(int x,int y,int z)
{
    q.push(point(x,y,z));
    memset(visit,-1,sizeof(visit));
    visit[x][y][z] = 0;
    while(!q.empty()) {
        point p = q.front();
        q.pop();
        if(check(p.x,p.y,p.z)) {
            cout << visit[p.x][p.y][p.z] << endl;
            output(p.x,p.y,p.z);
            return;
        }
        for(int i = 0; i < n; i ++) {
            if(i == p.x) continue;
            if(i == p.y) continue;
            if(i == p.z) continue;
            if(visit[i][p.y][p.z] != -1) continue;
            if(s[i][p.x] != s[p.y][p.z]) continue;
            visit[i][p.y][p.z] = visit[p.x][p.y][p.z] + 1;
            pre[i][p.y][p.z] = p;
            q.push(point(i,p.y,p.z));
        }
        for(int i = 0; i < n; i ++) {
            if(i == p.x) continue;
            if(i == p.y) continue;
            if(i == p.z) continue;
            if(visit[p.x][i][p.z] != -1) continue;
            if(s[i][p.y] != s[p.x][p.z]) continue;
            visit[p.x][i][p.z] = visit[p.x][p.y][p.z] + 1;
            pre[p.x][i][p.z] = p;
            q.push(point(p.x,i,p.z));
        }        
        for(int i = 0; i < n; i ++) {
            if(i == p.x) continue;
            if(i == p.y) continue;
            if(i == p.z) continue;
            if(visit[p.x][p.y][i] != -1) continue;
            if(s[i][p.z] != s[p.x][p.y]) continue;
            visit[p.x][p.y][i] = visit[p.x][p.y][p.z] + 1;
            pre[p.x][p.y][i] = p;
            q.push(point(p.x,p.y,i));
        }             
    }
    cout << -1 << endl;
}

int main()
{
    int x,y,z;
    cin >> n;
    cin >> x >> y >> z;
    x --,y --;z --;
    for(int i = 0; i < n; i ++)
        cin >> s[i];
    bfs(x,y,z);
    return 0;
}

 	  	     	   				  		 	