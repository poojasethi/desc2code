#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <algorithm>
#include <cmath>
#include <set>
#include <map>
#include <cassert>
#include <cstring>
#include <queue>

#define big long long int
#define SZ(x) int(x.size())
#define InTheNameOfGod ios::sync_with_stdio(false); cin.tie(0);

using namespace std;

const int maxn = 1000 * 1000 + 121;
const int mod = 1000 * 1000 * 1000 + 7;

vector <int> adj[maxn];

int n, si, ti, num;
int g[100][100][100];
char c[100][100];
vector <pair <int, int> > ans;
int d[maxn];
bool mark[maxn];
int par[maxn];


struct pos {
	int f, s, t, id;
	pos(){};
	pos(int a, int b, int c){
		int k[3];
		k[0] = a, k[1] = b, k[2] = c;
		sort(k, k+3);
		f = k[0];
		s = k[1];
		t = k[2];
		id = num;
		g[f][s][t] = id;
	}
};

pos v[maxn];

int getid(int a, int b, int c) {
	int k[3];
	k[0] = a, k[1] = b, k[2] = c;
	sort(k, k+3);
	return g[k[0]][k[1]][k[2]];
}

void init() {
	for (int i = 1; i <= n; i++) {
		for (int j = i; j <= n; j++) {
			for (int k = j; k <= n; k++) {
				v[num] = pos(i, j, k);
				num++;
			}
		}
	}
}

bool can(int f, int t, int a, int b) {
	if (t == a || t == a || t == b) return 0;
	if (c[f][t] == c[a][b]) return 1;
	return 0;
}

void input() {
	InTheNameOfGod; 
	cin >> n;
	init();
	int a, b, d;
	cin >> a >> b >> d;
	si = getid(a, b, d);
	ti = getid(1, 2, 3);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> c[i][j];
		}
	}

	for (int i = 0; i < num; i++) {
		int f = v[i].f, s = v[i].s, t = v[i].t;
		for (int j = 1; j <= n; j++) {
			if (can(f, j, s, t)) adj[i].push_back(getid(j,s,t));
			if (can(s, j, f, t)) adj[i].push_back(getid(j,f,t));
			if (can(t, j, f, s)) adj[i].push_back(getid(j,f,s));
		}
	}

}

pair <int, int> diff(int A, int B) {

	int a[3], b[3];
	a[0] = v[A].f, a[1] = v[A].s, a[2] = v[A].t;
	b[0] = v[B].f, b[1] = v[B].s, b[2] = v[B].t;
 	
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			if (a[i] == b[j]) a[i] = b[j] = -1; 
		}
	}

	int q, w;
	for (int i = 0; i < 3; i++) {
		if (a[i] != -1) q = a[i];
		if (b[i] != -1) w = b[i];
	}
	return make_pair(w, q);
} 

void bfs(int si) {
	queue <int> q;
	mark[si] = 1;
	q.push(si);
	while (!q.empty()) {
		int f = q.front();
		q.pop();
		for (int i = 0; i < SZ(adj[f]); i++) {
			int u = adj[f][i];
			if (mark[u]) continue;
			d[u] = d[f]+1;
			q.push(u);
			par[u] = f;
			mark[u] = 1;
		}
	}
}

int main () {
	input();
	bfs(si);
	if (!mark[ti]) {
		cout << -1 << endl;
		return 0;
	}
	cout << d[ti] << endl;
	int p = ti;
	while (p != si) {
		ans.push_back(diff(p, par[p]));
		p = par[p];
	}

	for (int i = SZ(ans)-1; i >= 0; i--) cout << ans[i].first << " " << ans[i].second << endl;
	
}