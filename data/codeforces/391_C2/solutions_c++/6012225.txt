//Done by Mycroft Grey
//Fet per Ferran Alet

#include<iostream>
#include<cmath>
#include<iomanip>
#include<vector>
#include<map>
#include<queue>
#include<fstream>
#include<algorithm>
#include<string>
#include<stack>
#include<numeric>
#include<set>
#include<sstream>
#include<list>

#define INF 2147483647
#define LINF 1000000000000000000LL
#define EPS 1e-9
#define debug(x) //cerr << #x << " = " << x << endl
#define Debug(v) cerr << #v << " = "; for(ll wow=0;wow<v.size();++wow) cerr<<v[wow]<<' '; cerr<<endl
#define FOR(x,y) for(ll x=0;x<y;x++)
#define FORU(x,y) for(ll x=1;x<=y;x++)
#define RFOR(x,y) for(ll x=y-1;x>=0;--x)
using namespace std;


typedef long long ll;
typedef pair<ll,ll> PII;
typedef vector<ll> VI;
typedef vector<VI> VVI;
typedef vector<double> VD;
typedef vector<VD> VVD;
typedef vector<bool> VB;
typedef vector<VB> VVB;
typedef vector<string> VS;
typedef map<ll,ll> MII;
typedef MII::iterator iMII;
typedef vector<PII > VP;

ll result(){
  ll n,k;
  cin>>n>>k;
  --k;
  vector<PII> r(n);
  FOR(i,n) cin>>r[i].first>>r[i].second;
  sort(r.begin(),r.end());
  reverse(r.begin(),r.end());
  if(k>=n) return 0; //Too easy
  if(r[k].first>n) return -1; //Impossible
  ll p=r[k].first;
  debug(p);
  
  ll easy=LINF;
  vector<PII> v(n);
  FOR(i,n) {
    v[i].first=r[i].second;
    v[i].second=i;
  }
  sort(v.begin(),v.end());
  ll trivial=LINF;
  if(p+2<=n){
    trivial=0;
    FOR(i,p+2) trivial+=v[i].first;
  }
  
  ll supbet=0;
  ll suprd=0;
  FOR(i,n){
    if(r[i].first>p+1) ++supbet;
    if(r[i].first==p or r[i].first==p+1) ++suprd;
  }
  ll supneed=suprd-(k-supbet);
  ll supaltres=p+1-supneed;
  debug(supbet);
  debug(suprd);
  debug(supneed);
  debug(supaltres);
  if(supaltres>=0 && p+1<=n){
    easy=0;
    ll wins=0;
    ll i=0;
    for(;i<p+1;++i){
      if(supaltres<=0) break;
      ++wins;
      easy+=v[i].first;
      if(r[v[i].second].first!=p && r[v[i].second].first!=p+1) --supaltres;
    }  
    for(;i<n && wins<p+1;++i){
      if(r[v[i].second].first==p+1 or r[v[i].second].first==p){
        ++wins;
        easy+=v[i].first;
      }
    }
  }
  debug(easy);
  
  
  
  ll better=0;
  ll rd=0;
  FOR(i,n) {
    if(r[i].first==p or r[i].first==p-1) ++rd;
    if(r[i].first>p) ++better;
  }
  ll need= rd-(k-better);
  ll altres = p-need;
  debug(k);
  debug(better);
  debug(rd);
  debug(need);
  debug(altres);
  ll hard=LINF;
  if(altres>=0){
    hard=0;
    ll wins=0;
    ll i=0;
    for(;i<p;++i){
      if(altres<=0) break;
      ++wins;
      hard+=v[i].first;
      if(r[v[i].second].first!=p && r[v[i].second].first!=p-1) --altres;
    }  
    for(;i<n && wins<p;++i){
      if(r[v[i].second].first==p-1 or r[v[i].second].first==p){
        ++wins;
        hard+=v[i].first;
      }
    }
  }
  debug(hard);
  return min(trivial,min(hard,easy));
}

int main(){
  ios_base::sync_with_stdio(false);
  cout<<result()<<endl;
  //system("pause");
}
