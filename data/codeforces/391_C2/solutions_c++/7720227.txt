//#pragma comment(linker,"/STACK:100000000000,100000000000")

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <string>
#include <cstring>
#include <vector>
#include <cmath>
#include <map>
#include <stack>
#include <set>
#include <iomanip>
#include <queue>
#include <map>
#include <functional>
#include <list>
#include <sstream>
#include <ctime>
#include <climits>
#include <bitset>
#include <list>
#include <cassert>
#include <complex>

using namespace std;

/* Constants begin */
const long long inf = 2e18 + 7;
const long long mod = 1e9 + 7;
const double eps = 1e-9;
const double PI = 2*acos(0.0);
const double E = 2.71828;
/* Constants end */

/* Defines begin */
#define pb push_back
#define mp make_pair
#define ll long long
#define double long double
#define F first
#define S second
#define all(a) (a).begin(),(a).end()
#define forn(i, n) for (int (i)=0; (i)<(n); ++(i))
#define random (rand()<<16|rand())
#define sqr(x) (x)*(x)
#define base complex<double>
/* Defines end */

int n, m;
vector<int> g[200005];
pair<int, int> a[200005];
ll b[200005], sz;
int Left[200005], Right[200005];
vector<int> now, mid;

int main(void){
  #ifdef nobik
    freopen("input.txt", "rt", stdin);
    freopen("output.txt", "wt", stdout);
  #endif
  scanf("%d %d", &n, &m);
  for(int i = 1; i <= n; ++i){
    scanf("%d %d", &a[i].F, &a[i].S);
    g[a[i].F].pb(a[i].S);
    b[i] = a[i].S;
  }
  forn(i, 200005){
    sort(all(g[i]));
  }
  Left[0] = g[0].size();
  Right[200005] = 0;
  for(int i = 1; i < 200005; ++i){
    Left[i] = Left[i - 1] + g[i].size();
  }
  for(int i = 200004; i >= 0; --i){
    Right[i] = Right[i + 1] + g[i].size();
  }
  sort(b + 1, b + n + 1);
  sort(a + 1, a + n + 1);
  for(int i = 1; i <= n; ++i){
    b[i] += b[i - 1];
  }
  ll res = inf;
  for(int i = 0; i <= n; ++i){
    int higher = Right[i + 1];
    int lower = (i > 1 ? Left[i - 2] : 0);
    int prob = n - higher - lower;
    if(higher > m){
      continue;
    }
    if(higher + prob < m){
      res = min(res, b[i]);
    } else {
      int winner = prob - (m - higher - 1);
      ll score = 0;
      now.clear();
      mid.clear();
      forn(i, lower){
        now.pb(a[i + 1].S);
      }
      for(int i = lower + 1; i <= lower + prob; ++i){
        mid.pb(a[i].S);
      }
      for(int i = lower + prob + 1; i <= n; ++i){
        now.pb(a[i].S);
      }
      if(winner > mid.size() || winner < 0){
        continue;
      }
      sort(all(mid));
      reverse(all(mid));
      forn(i, winner){
        score += mid.back();
        mid.pop_back();
      }
      forn(i, mid.size()){
        now.pb(mid[i]);
      }
      sort(all(now));
      forn(j, i - winner){
        score += now[j];
      }
      res = min(res, score);
    }
  }
  if(res == inf){
    res = -1;
  }
  cout << res << "\n";
  return 0;
}
