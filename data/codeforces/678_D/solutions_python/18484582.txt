def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

def modexp ( g, u, p ):
   """computes s = (g ^ u) mod p
      args are base, exponent, modulus
      (see Bruce Schneier's book, _Applied Cryptography_ p. 244)"""
   s = 1
   while u != 0:
      if u & 1:
         s = (s * g)%p
      u >>= 1
      g = (g * g)%p;
   return s

A,B,n,x=map(int, raw_input().split())
magic=10**9+7
if A==1:
    print (x+n*B)%magic
else:
    An=modexp(A, n, magic)
    Annumerator=(An-1)%magic
    Adenominator=(A-1)%magic
    Adenominator=modinv(Adenominator, magic)
    print ((An*x) % magic+ (((Annumerator*Adenominator)%magic) *B )%magic)%magic