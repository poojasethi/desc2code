#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int MAXN = 505,MAXM = 2005;

typedef pair<int,int> P;
typedef pair<int,P> Pi;

Pi Q[MAXN * MAXN];
bool Bx[MAXN],By[MAXN];
int Lx[MAXN],Fa[MAXN],F[MAXN][MAXN],N,M;

namespace MaxFlow
{
	struct Node
	{
		int To,Next,Flow;
		Node(void){}
		Node(int a,int b,int c) : To(a),Next(b),Flow(c){}
	}E[MAXM * 2],Bak[MAXM * 2];
	
	int D[MAXN],Count[MAXN],Cur[MAXN],Final[MAXN],tot,S,T;
	
	void First()
	{
		tot = 1;
	}
	
	void Link(int u,int v,int f,int f1)
	{
		E[++ tot] = Node(v,Final[u],f),Final[u] = tot;
		E[++ tot] = Node(u,Final[v],f1),Final[v] = tot;
	}
	
	void Pre_Treat()
	{
		for(int i = 1;i <= tot;i ++) Bak[i] = E[i];
	}
	
	int Dfs(int Now,int Flow)
	{
		if (Now == T) return Flow;
		int Use = 0;
		for(int i = Cur[Now];i;i = E[i].Next)
		if (E[i].Flow > 0 && D[E[i].To] == D[Now] - 1)
		{
			int Tmp = Dfs(E[i].To,min(Flow - Use,E[i].Flow));
			Use += Tmp,E[i].Flow -= Tmp,E[i ^ 1].Flow += Tmp;
			if (Use == Flow || D[S] == N + 1) return Use;
		}
		Cur[Now] = Final[Now];
		if (!(-- Count[D[Now]])) D[S] = N + 1;
		++ Count[++ D[Now]];
		return Use;
	}
	
	int Get(int s,int t)
	{
		int Tmp = 0;
		S = s,T = t;
		for(int i = 1;i <= tot;i ++) E[i] = Bak[i];
		memset(D,0,sizeof D),memset(Count,0,sizeof Count),memset(Cur,0,sizeof Cur);
		Count[0] = N;
		while (D[S] < N + 1) Tmp += Dfs(S,1 << 30);
		return Tmp;
	}
}

int Get(int a) {return Fa[a] == a ? a : Fa[a] = Get(Fa[a]);}

int main()
{
	scanf("%d%d", &N, &M);
	MaxFlow::First();
	for(int i = 1;i <= M;i ++)
	{
		int u,v,c;
		scanf("%d%d%d", &u, &v, &c);
		MaxFlow::Link(u,v,c,c);
	}
	int tot = 0;
	MaxFlow::Pre_Treat();
	for(int i = 1;i <= N;i ++)
		for(int j = i + 1;j <= N;j ++)
		{
			int f = MaxFlow::Get(i,j);
			F[i][j] = f;
			Q[++ tot] = Pi(f,P(i,j));Q[++ tot] = Pi(f,P(j,i));
		}
	int Total = 0;
	for(int i = 1;i <= N;i ++) Fa[i] = i;
	sort(Q + 1,Q + tot + 1);
	for(int i = tot;i;i --)
	{
		int x = Q[i].second.first,y = Q[i].second.second;
		if (Bx[x] || By[y] || Get(x) == Get(y)) continue;
		Lx[x] = y;
		Fa[Get(y)] = Get(x);
		Bx[x] = 1,By[y] = 1;
		Total += Q[i].first;
	}
	printf("%d\n", Total);
	int fi = 0,cnt = 0;
	static int Stack[MAXN];
	for(int i = 1;i <= N;i ++) if (!By[i]) {fi = i;break;}
	Stack[++ cnt] = fi;
	while (fi)
	{
		if (Lx[fi]) Stack[++ cnt] = Lx[fi];
		fi = Lx[fi];
	}
	for(int i = 1;i <= cnt;i ++) printf("%d%c", Stack[i], i == cnt ? '\n' : ' ');
	return 0;
}