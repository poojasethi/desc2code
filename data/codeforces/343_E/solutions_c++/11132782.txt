#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
#define maxn 2200
#define maxm 11000
struct edges{
	int to,next,cap,c;
}edge[maxm*2];
int next[maxn],l;
#define inf 0x7fffffff
inline void addedge(int x,int y,int z){
	l++;
	edge[l*2]=(edges){y,next[x],z,z};next[x]=l*2;
	edge[l*2+1]=(edges){x,next[y],z,z};next[y]=l*2+1;
}
int h[maxn],gap[maxn],p[maxn],s,t;
int n;
int sap(int u,int flow){
	if (u==t) return flow;
	int cnt=0;
	for (int i=p[u];i;i=edge[i].next) 
		if (edge[i].cap&&h[edge[i].to]+1==h[u]) {
			int cur=sap(edge[i].to,min(flow-cnt,edge[i].cap));
			edge[i].cap-=cur;edge[i^1].cap+=cur;
			p[u]=i;
			if ((cnt+=cur)==flow) return flow;
		}
	if (!(--gap[h[u]])) h[s]=n;
	gap[++h[u]]++;p[u]=next[u];
	return cnt;
}
inline int maxflow(int s,int t){
	::s=s,::t=t;
	for (int i=1;i<=n;i++) p[i]=next[i];
	for (int i=1;i<=l*2+1;i++) edge[i].cap=edge[i].c;
	memset(h,0,sizeof(h));
	memset(gap,0,sizeof(gap));
	gap[0]=n;
	int flow=0;
	while (h[s]<n) flow+=sap(s,inf);
	return flow;
}
struct ii{
	int u,v,w;
};
vector<ii> q;
#define pb push_back
int ch[maxn][2];
inline int exist(int x) {
	if (!ch[x][0]) return 0;
	if (!ch[x][1]) return 1;
	return -1;
}
bool cmp(ii x,ii y) {return x.w>y.w;}
inline int check(int pre,int x) {
	while (x) {
		if (ch[x][0]==pre) pre=ch[x][1];
		else pre=ch[x][0];
		swap(pre,x);
	}
	return pre;
}
int main(){
	int m;
	scanf("%d%d",&n,&m);
	for (int i=1;i<=m;i++) {
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		addedge(u,v,w);
	}
	for (int i=1;i<=n;i++) 
		for (int j=i+1;j<=n;j++) q.pb((ii){i,j,maxflow(i,j)});
	sort(q.begin(),q.end(),cmp);
	int ans=0,cnt=0;
	for (int i=0;i<q.size();i++) {
		int x=exist(q[i].u),y=exist(q[i].v);
		if (x==-1||y==-1) continue;
		if (check(q[i].u,ch[q[i].u][x^1])==q[i].v) continue;
		ans+=q[i].w;cnt++;
		ch[q[i].u][x]=q[i].v,ch[q[i].v][y]=q[i].u;
		if (cnt==n-1) break;
	}
	printf("%d\n",ans);
	for (int i=1;i<=n;i++) {
		if (ch[i][1]!=0) continue;
		int x=i,pre=0;
		while (x) {
			printf("%d ",x);
			if (ch[x][0]==pre) pre=ch[x][1];
			else pre=ch[x][0];
			swap(x,pre);
		}
		break;
	}
	return 0;
}
