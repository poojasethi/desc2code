#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
using namespace std;

const int MaxN = 210, Inf = 10000000;
class Maxflow_Templete {
public:
	static const int MaxN = 210, MaxM = 2010, Inf = 100000000;
	int En[MaxN], Next[MaxM], Point[MaxM], F[MaxM], Tot, S, T, Store[MaxM], N;
	int Pl[MaxN], D[MaxN], Vd[MaxN];
	bool Mark[MaxN];
	
	void Init(int _N) {
		N = _N;
		memset(En, 0, sizeof(En));
		Tot = 1;
	}
	void Add(int X, int Y, int Flow) {
		Next[++Tot] = En[X];	En[X] = Tot;	Point[Tot] = Y;	Store[Tot] = F[Tot] = Flow;
		Next[++Tot] = En[Y];	En[Y] = Tot;	Point[Tot] = X;	Store[Tot] = F[Tot] = Flow;
	}
	void Restore() {	memcpy(F, Store, sizeof(F));	memset(Mark, 0, sizeof(Mark)); }
	
	int Sap(int Now, int Flow) {
		if (Now == T) return Flow;
		int Ret = 0, Tmp;
		for (int i = Pl[Now]; i; i = Next[i]) {
			if (F[i] && (D[Point[i]] + 1 == D[Now])) {
				Tmp = Sap(Point[i], min(Flow - Ret, F[i]));
				Ret += Tmp;
				F[i] -= Tmp;
				F[i ^ 1] += Tmp;
				if (Ret == Flow) return Ret;
			}
			Pl[Now] = i;
		}
		if (--Vd[D[Now]] == 0) D[S] = N + 1;
		Vd[++D[Now]]++;
		Pl[Now] = En[Now];
		return Ret;
	}
	
	int MaxFlow(int _S, int _T) {
		S = _S;	T = _T;
		memset(D, 0, sizeof(D));
		memset(Vd, 0, sizeof(Vd));
		Vd[0] = N;
		memcpy(Pl, En, sizeof(En));
		int Ret = 0;
		while (D[S] <= N) Ret += Sap(S, Inf);
		return Ret;
	}
	
	void Dfs(int Now) {
		Mark[Now] = 1;
		for (int i = En[Now]; i; i = Next[i])
			if (F[i] && !Mark[Point[i]]) Dfs(Point[i]);
	}
}	G;
int T, N, M, Cut[MaxN][MaxN], H[MaxN];

void GetCut(int L, int R) {
	if (L == R) return;
	G.Restore();
	int Now = G.MaxFlow(H[L], H[R]);
	G.Dfs(H[L]);
	for (int i = 1; i <= N; i++)
		for (int j = 1; j <= N; j++)
			if (G.Mark[i] ^ G.Mark[j])
				Cut[i][j] = min(Cut[i][j], Now);
	int Mid = L;
	for (int i = L; i <= R; i++)
		if (G.Mark[H[i]]) swap(H[i], H[Mid++]);
	GetCut(L, Mid - 1);
	GetCut(Mid, R);
}

void Solve() {
	memset(Cut, 63, sizeof(Cut));
	scanf("%d%d", &N, &M);
	G.Init(N);
	for (int i = 1, X, Y, Z; i <= M; i++) {
		scanf("%d%d%d", &X, &Y, &Z);
		G.Add(X, Y, Z);
	}
	for (int i = 1; i <= N; i++) H[i] = i;
	GetCut(1, N);
}

int Ans, Out[MaxN], OTot;
void GetAns(int L, int R) {
	if (L == R) {
		Out[++OTot] = H[L];
		return;
	}
	int Min = Inf, Pos = H[L];
	for (int i = L; i <= R; i++)
		for (int j = i + 1; j <= R; j++)
			if (Cut[H[i]][H[j]] < Min) {
				Min = Cut[H[i]][H[j]];
				Pos = i;
			}
	Ans += Min;
	int Mid = L + 1;
	swap(H[L], H[Pos]);
	for (int i = L + 1; i <= R; i++)
		if (Cut[H[L]][H[i]] != Min) swap(H[i], H[Mid++]);
	GetAns(L, Mid - 1);
	GetAns(Mid, R);
}

int main()
{
	Solve();
	for (int i = 1; i <= N; i++) H[i] = i;
	GetAns(1, N);
	cout << Ans << endl;
	for (int i = 1; i <= N; i++) printf("%d ", Out[i]); puts("");
	return 0;
}