#include <cmath>
#include <map>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <set>
#include <bitset>
#include <memory.h>
#include <functional>
#include <queue>
#include <fstream>
#include <ctime>
#include <deque>
#include <utility>
#include <stack>
#include <sstream>
#include <list>
#include <cctype> 
#include <numeric> 
using namespace std;

typedef long long LL;

typedef pair<int, int> Pii;
#define x first
#define y second
#define mp make_pair

const int MAXN = 200 + 10, MAXM = 2000 + 10, INF = 0x3f3f3f3f;

struct Graph
{
	int id, g, next;
}g[MAXM * 2], g1[MAXM * 2];
int n, m, st[MAXN], st1[MAXN], p[MAXN], dis[MAXN], num[MAXN], c[MAXN][MAXN];
bool ins[MAXN];

void Add(Graph *g, int *st, int tot, int x, int y, int z)
{
	g[tot].id = y, g[tot].g = z, g[tot].next = st[x], st[x] = tot;
}
void init()
{
	scanf("%d%d", &n, &m);
	memset(st1, -1, sizeof(st1));
	for (int i = 1; i <= m; ++i)
	{
		int x, y, z;
		scanf("%d%d%d", &x, &y, &z);
		Add(g1, st1, i * 2, x, y, z),
		Add(g1, st1, i * 2 + 1, y, x, z);
	}
}
int SAP(int x, int S, int T, int flow)
{
	if (x == T) return flow;
	int res = flow;
	for (int i = st[x]; i != -1; i = g[i].next)
		if (g[i].g > 0 && dis[x] == dis[g[i].id] + 1)
		{
			int F = SAP(g[i].id, S, T, min(res, g[i].g));
			g[i].g -= F, g[i ^ 1].g += F, res -= F;
			if (res <= 0)
				return flow;
		}
	--num[dis[x]];
	if (num[dis[x]] <= 0)
		dis[S] = n + 1;
	++dis[x];
	++num[dis[x]];
	return flow - res;
}
void DFS(int x)
{
	ins[x] = true;
	for (int i = st[x]; i != -1; i = g[i].next)
		if (!ins[g[i].id] && g[i].g > 0)
			DFS(g[i].id);
}
int Maxf(int S, int T)
{
	memcpy(g, g1, sizeof(g));
	memcpy(st, st1, sizeof(st));
	memset(num, 0, sizeof(num));
	memset(dis, 0, sizeof(dis));
	memset(ins, 0, sizeof(ins));
	int Tohka = 0;
	for (num[0] = n; dis[S] < n + 1; Tohka += SAP(S, S, T, INF));
	DFS(S);
	return Tohka;
}
void solve()
{
	memset(c, 0x3f, sizeof(c));
	for (int i = 1; i <= n; ++i)
		p[i] = 1;
	for (int i = 2; i <= n; ++i)
	{
		int Houki = Maxf(i, p[i]);
		for (int j = i + 1; j <= n; ++j)
			if (ins[j] && p[j] == p[i])
				p[j] = i;
		c[i][p[i]] = c[p[i]][i] = Houki;
		for (int j = 1; j < i; ++j)
			c[i][j] = c[j][i] = min(Houki, c[p[i]][j]);
	}
	memset(ins, 0, sizeof(ins));
	vector<int> Tohka;
	int Houki = 0;
	for (int x = 1; ; )
	{
		Tohka.push_back(x);
		ins[x] = true;
		int y = -1;
		for (int i = 1; i <= n; ++i)
			if (!ins[i] && (y == -1 || c[x][y] < c[x][i]))
				y = i;
		if (y == -1) break;
		Houki += c[x][y]; x = y;
	}
	cout << Houki << endl;
	for (int i = 0; i < (int)Tohka.size(); ++i)
		cout << Tohka[i] << " ";
	cout << endl;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout);
#endif
	init();
	solve();
	fclose(stdin);
	fclose(stdout);
	return 0;
}

