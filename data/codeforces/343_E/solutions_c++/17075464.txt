#include <bits/stdc++.h>
using namespace std;

const int INF = 0x3f3f3f3f;
const int MAXN = 203;
const int MAXM = 1003;

int n, m;

struct Edge {
  Edge* next;
  int dest, cap, t_cap;
};

Edge memory[MAXM * 2 + MAXN * 2];
Edge* curMemory = memory;
Edge* info[MAXN];
Edge* info2[MAXN];

Edge* oppe(const Edge* const x) {
  return memory + ((x - memory) ^ 1);
}

void insert(int u, int v, int c, Edge* info[]) {
  curMemory->dest = v;
  curMemory->t_cap = c;
  curMemory->next = info[u];
  info[u] = curMemory++;
}

int lev[MAXN], que[MAXN];

bool bfs(int S, int T) {
  int low = 0, high = 0;
  fill(lev, lev + n + 1, -1);
  lev[S] = 0;
  que[high++] = S;
  while (low < high) {
    int u = que[low++];
    for (Edge* pt = info[u]; pt; pt = pt->next) {
      int v = pt->dest;
      if (pt->cap && lev[v] == -1) {
        lev[v] = lev[u] + 1;
        que[high++] = v;
        if (v == T) return true; 
      }
    }
  }
  return false;
}

Edge* pre[MAXN];

int dfs(int u, int T, int f) {
  if (u == T) return f;
  int r = f;

  for (Edge* &pt = pre[u]; pt; pt = pt->next) {
    int v = pt->dest;
    if (pt->cap && lev[v] == lev[u] + 1) {
      int t = dfs(v, T, min(r, pt->cap));
      if (t) {
        pt->cap -= t;
        oppe(pt)->cap += t;
        r -= t;
        if (r == 0) return f;
      }
    }
  }
  
  return f - r;
}

int flows(int S, int T) {
  for (Edge* i = memory; i < curMemory; i++)
    i->cap = i->t_cap;
  int ret = 0;
  while (bfs(S, T)) {
    copy(info, info + n + 1, pre);
    ret += dfs(S, T, INF);
  }
  return ret;
}

Edge* findmin(int u) {
  Edge* ret = 0;
  for (Edge* pt = info2[u]; pt; pt = pt->next) {
    int v = pt->dest;
    if (pt->cap) {
      if (! ret || pt->t_cap < ret->t_cap)
        ret = pt;
      Edge* t = findmin(v);
      if (t && t->t_cap < ret->t_cap)
        ret = t;
    }
  }
  return ret;
}

void travel(int u) {
  Edge* p = findmin(u);
  if (! p) {
    printf("%d ", u);
    return;
  }
  p->cap = 0;
  travel(p->dest);
  travel(u);
}

int main() {
#ifndef ONLINE_JUDGE
  freopen("input.txt", "r", stdin);
  freopen("output.txt", "w", stdout);
#endif

  scanf("%d%d", &n, &m);
  for (int i = 0; i < m; i++) {
    int u, v, c;
    scanf("%d%d%d", &u, &v, &c);
    insert(u, v, c, info);
    insert(v, u, c, info);
  }

  static int fa[MAXN], cost[MAXN];
  for (int i = 2; i <= n; i++) fa[i] = 1;
  for (int i = 2; i <= n; i++) {
    cost[i] = flows(i, fa[i]);
    for (int j = i + 1; j <= n; j++)
      if (fa[j] == fa[i] && lev[j] != -1) {
        fa[j] = i;
      }
    //fprintf(stderr, "%d -> %d %d\n", fa[i], i, cost[i]);
    insert(fa[i], i, cost[i], info2);
  }

  printf("%d\n", accumulate(cost + 2, cost + n + 1, 0));
  for (Edge* pt = memory; pt < curMemory; pt++)
    pt->cap = 1;
  travel(1);
  printf("\n");

  return 0;
}
