#include<queue>
#include<vector>
#include<stdio.h>
#include<string.h>
#include<algorithm>
#define N 210
#define M 10000
using namespace std;
typedef long long ll;
int to[M],next[M],flow[M],head[N],ce;
int dis[N],S,T;
int n,m,X[M],Y[M],F[M];
int a[N],cnt;
queue<int>q;
bool BFS()
{
	memset(dis,0,sizeof(dis));
	dis[S]=1;
	q.push(S);
	int x,i;
	while(!q.empty())
	{
		x=q.front(),q.pop();
		for(i=head[x];i;i=next[i])
		{
			if(flow[i]&&dis[to[i]]==0)
			{
				dis[to[i]]=dis[x]+1;
				q.push(to[i]);
			}
		}
	}
	return dis[T]!=0;
}
int dfs(int x,int lim)
{
	if(x==T)	return lim;
	int i,ret,temp;
	for(i=head[x],ret=0;i;i=next[i])
	{
		if(flow[i]&&dis[to[i]]==dis[x]+1)
		{
			temp=dfs(to[i],min(lim-ret,flow[i]));
			ret+=temp;
			flow[i]-=temp,flow[i^1]+=temp;
			if(lim==ret)
				return ret;
		}
	}
	if(ret==0)	dis[x]=0;
	return ret;
}
void add(int x,int y,int fl)
{
	to[++ce]=y;
	flow[ce]=fl;
	next[ce]=head[x];
	head[x]=ce;
	to[++ce]=x;
	flow[ce]=fl;
	next[ce]=head[y];
	head[y]=ce;
}
int MinCut(int st,int en)
{
	ce=1;
	memset(head,0,sizeof(head));
	S=st,T=en;
	for(int i=1;i<=m;i++)
		add(X[i],Y[i],F[i]);
	int ret=0;
	while(BFS())
		ret+=dfs(S,0x3f3f3f3f);
	return ret;
}
int ans;
namespace Tree
{
	int next[N<<1],to[N<<1],val[N<<1],head[N],ce;
	bool ban[N];
	void add(int x,int y,int v)
	{
		to[++ce]=y;
		val[ce]=v;
		next[ce]=head[x];
		head[x]=ce;
		to[++ce]=x;
		val[ce]=v;
		next[ce]=head[y];
		head[y]=ce;
	}
	void dfs(int x,int pre,int &mi,int &a,int &b)
	{
		for(int i=head[x];i;i=next[i])
		{
			if(!ban[to[i]]&&to[i]!=pre)
			{
				dfs(to[i],x,mi,a,b);
				if(val[i]<mi)
					mi=val[i],a=x,b=to[i];
			}
		}
	}
	vector<int> slove(int x)
	{
		int mi=0x3f3f3f3f,a,b;
		dfs(x,0,mi,a,b);
		if(mi==0x3f3f3f3f)
		{
			vector<int>ret;
			ret.push_back(x);
			return ret;
		}
		ban[b]=1;
		vector<int> v1=slove(a);
		ban[b]=0;
		ban[a]=1;
		vector<int> v2=slove(b);
		ban[a]=0;
		for(vector<int>::iterator it=v2.begin();it!=v2.end();it++)
			v1.push_back(*it);
		return v1;
	}
}
void Build(int l,int r)
{
	if(l==r)	return ;
	int v=MinCut(a[l],a[r]),i,j;
	ans+=v;
//	printf("%d %d %d\n",a[l],a[r],v);
	for(i=l+1,j=l;i<=r;i++)
	{
		if(dis[a[i]]!=0)
			swap(a[++j],a[i]);
	}
	Tree::add(a[l],a[r],v);
	Build(l,j);
	Build(j+1,r);
}
int main()
{
	int i,j,k;
	scanf("%d%d",&n,&m);
	for(i=1;i<=m;i++)
		scanf("%d%d%d",X+i,Y+i,F+i);
	for(i=1;i<=n;i++)
		a[i]=i;
	Build(1,n);
	printf("%d\n",ans);
	vector<int> rec=Tree::slove(1);
	for(vector<int>::iterator it=rec.begin();it!=rec.end();it++)
		printf("%d ",*it);
	return 0;
}
