#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <cassert>
#include <sstream>
#include <numeric>
#include <climits>
#include <string>
#include <cctype>
#include <ctime>
#include <iomanip>
#include <cmath>
#include <vector>
#include <queue>
#include <list>
#include <map>
#include <set>
using namespace std;

#define foreach(e, x) for (__typeof((x).begin()) e = (x).begin(); e != (x).end(); ++e)

typedef long long int64; 

const int MAX_N = (int)1e6 + 10;

int n, m;

struct Node {
	int l, r;
	Node(int l, int r): l(l), r(r) {}
	int size() const {
		return l == 0 ? r - 1: r == n + 1 ? r - l - 1 : (r - l) / 2;
	}
	bool operator <(const Node &o) const {
		return size() > o.size() || size() == o.size() && l < o.l;
	}
};

int p[MAX_N];
set <Node> events;
set <int> cars;

int main() {
	scanf("%d%d", &n, &m);
	events.insert(Node(0, n + 1));
	cars.insert(0);
	cars.insert(n + 1);
	while (m--) {
		int ctrl, x;
		scanf("%d%d", &ctrl, &x);
		if (ctrl == 1) {
			Node t = *events.begin();
			events.erase(events.begin());
			p[x] = t.l == 0 ? 1 : t.r == n + 1 ? n : t.l + t.size();
			int u = *--cars.lower_bound(p[x]);
			int v = *cars.lower_bound(p[x]);
			cars.insert(p[x]);
			events.insert(Node(u, p[x]));
			events.insert(Node(p[x], v));
			printf("%d\n", p[x]);
		} else {
			cars.erase(p[x]);
			int u = *--cars.lower_bound(p[x]);
			int v = *cars.lower_bound(p[x]);
			events.erase(Node(u, p[x]));
			events.erase(Node(p[x], v));
			events.insert(Node(u, v));
		}
	}
}

