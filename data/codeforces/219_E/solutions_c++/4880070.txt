#include <cstring>
#include <set>
#include <vector>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <map>
#include <cstdio>
using namespace std;

const int maxn=1001000;
const int inf=1<<29;
typedef pair<int,int> PII;
typedef pair<int,PII> PIP;
#define F first
#define S second
#define MP make_pair

set<PIP> s;
int n,t,L[maxn],R[maxn],prk[maxn];
//L[i]数组存的是i点的左侧的端点是什么
//R[i]数组存的是i点的右侧的端点是什么
//存的线段是从0到n+1，多存左右端点
//PIP里存的是<线段长度的负数,<插入点的位置,插入后的线段右端点>>
PIP MK(int l,int r)
{
	if(l==0&&r==n+1)return MP(-(n+1),MP(1,n+1));
	if(l==0)return MP(-(r-1),MP(1,r));
	if(r==n+1)return MP(-(n-l),MP(n,n+1));
	return MP(-(r-l)/2,MP((r+l)/2,r));
}
int main()
{
	scanf("%d %d",&n,&t);
	s.insert(MK(0,n+1));
	L[n+1]=0;R[0]=n+1;
	while(t--)
	{
		int ty,id;
		scanf("%d %d",&ty,&id);
		if(ty==1)
		{
			PII bst=s.begin()->S;
			s.erase(s.begin());
			int r=bst.S,m=bst.F,l=L[r];
			printf("%d\n",prk[id]=m);
			L[m]=l;R[m]=r;//建立新的线段
			L[r]=m;R[l]=m;//l到m，m到r
			s.insert(MK(l,m));
			s.insert(MK(m,r));
		}else
		{
			int m=prk[id],l=L[m],r=R[m];
			R[l]=r;L[r]=l;
			s.erase(MK(l,m));
			s.erase(MK(m,r));
			s.insert(MK(l,r));
		}
	}
	return 0;
}
