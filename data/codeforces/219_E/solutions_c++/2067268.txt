#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#include <set>
using namespace std;

int n, m, op, id, p[1000005];

int cal(int x, int y){
	if (x == 1) return y - 1;
	if (y == n) return n - x;
	return (y - x) >> 1;
}

struct node{
	int x, y;
	bool operator < (node const &T) const{
		if (cal(x, y) != cal(T.x, T.y)) return cal(x, y) < cal(T.x, T.y);
		return x > T.x;
	};
};

node t;
priority_queue<node> Q;
set<int> S;
set<int>::iterator itr;

int prev(int x){
	itr = S.find(x);
	itr--;
	return *itr;
}

int next(int x){
	itr = S.find(x);
	itr++;
	return *itr;
}

int main(){
	scanf("%d%d", &n, &m);
	Q.push((node){1, n});
	S.insert(0), S.insert(n+1);

	while (m--){
		scanf("%d%d", &op, &id);
		if (op == 1){
			while (1){
				t = Q.top();
				Q.pop();
				if (*S.lower_bound(t.x) > t.y) break;
			}
			if (t.x == 1) p[id] = 1;
			else if (t.y == n) p[id] = n;
			else p[id] = t.x + (t.y - t.x) / 2;
			
			printf("%d\n", p[id]);
			S.insert(p[id]);
			Q.push((node){prev(p[id])+1, p[id]-1});
			Q.push((node){p[id]+1, next(p[id])-1});
		}
		else{
			Q.push((node){prev(p[id])+1, next(p[id])-1});
			S.erase(p[id]);
		}
	}
	return 0;
}
