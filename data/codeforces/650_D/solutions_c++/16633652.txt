#include <iostream>
#include <cstdio>
#include <algorithm>
#define MAXN 1000005
#define lc p<<1,l,mid
#define rc p<<1|1,mid+1,r
using namespace std;

int h[MAXN], n, m, tmp[MAXN<<1], cnt;
int Q[MAXN][2];

struct SGE
{
	int mv[MAXN<<2];
	void update(int p,int l,int r,int pos,int v)
	{
		mv[p]=max(mv[p],v);
		if(l==r)return;
		int mid=(l+r)>>1;
		if(pos<=mid)update(lc,pos,v);
		else update(rc,pos,v);
	}
	int query(int p,int l,int r,int ql,int qr)
	{
		if(ql<=l&&r<=qr)return mv[p];
		int mid=(l+r)>>1, ans=0;
		if(ql<=mid)ans=query(lc,ql,qr);
		if(mid<qr)ans=max(ans,query(rc,ql,qr));
		return ans;
	}
	int ask(int l,int r)
	{
		if(l>r)return 0;
		return query(1,1,cnt,l,r);
	}
}t1, t2;

struct node
{
	int v, next;
}edge[MAXN];
int adj[MAXN], pp;
void add(int u,int v)
{
	++pp;
	edge[pp].v=v, edge[pp].next=adj[u];
	adj[u]=pp;
}

int dp1[MAXN], dp2[MAXN], dp3[MAXN], dp4[MAXN], pos[MAXN];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&h[i]);
		tmp[++cnt]=h[i];
	}
	for(int i=1;i<=m;++i)
	{
		scanf("%d%d",&Q[i][0],&Q[i][1]);
		tmp[++cnt]=Q[i][1];
	}
	sort(tmp+1,tmp+cnt+1);cnt=unique(tmp+1,tmp+cnt+1)-tmp-1;
	
	for(int i=1;i<=n;++i)h[i]=lower_bound(tmp,tmp+cnt+1,h[i])-tmp;
	for(int i=1;i<=m;++i)
	{
		add(Q[i][0],i);
		Q[i][1]=lower_bound(tmp,tmp+cnt+1,Q[i][1])-tmp;
	}
	
	for(int i=1, v, x;i<=n;++i)
	{
		dp1[i]=t1.ask(1,h[i]-1)+1;
		for(int p=adj[i];p;p=edge[p].next)
		{
			v=edge[p].v, x=Q[v][1];
			dp3[v]=t1.ask(1,x-1)+1;
		}
		t1.update(1,1,cnt,h[i],dp1[i]);
	}
	reverse(h+1,h+n+1);
	for(int i=1, v, x;i<=n;++i)
	{
		dp2[i]=t2.ask(h[i]+1,cnt)+1;
		for(int p=adj[n-i+1];p;p=edge[p].next)
		{
			v=edge[p].v, x=Q[v][1];
			dp4[v]=t2.ask(x+1,cnt)+1;
		}
		t2.update(1,1,cnt,h[i],dp2[i]);
	}
	int res=0;
	for(int i=1;i<=n;++i)res=max(res,dp1[i]);
	for(int i=1;i<=n;++i)
		if(dp1[i]+dp2[n-i+1]-1==res)
			++pos[dp1[i]];
	for(int i=1, ans, x;i<=m;++i)
	{
		ans=res;
		x=Q[i][0];
		if(dp1[x]+dp2[n-x+1]-1==res&&pos[dp1[x]]==1)--ans;
		ans=max(ans,dp3[i]+dp4[i]-1);
		printf("%d\n",ans);
	}
	return 0;
}
	   		   	  	 		 	   	   		 			