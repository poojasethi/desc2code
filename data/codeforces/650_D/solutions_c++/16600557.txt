#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#define N 850005
#define M 8300005
#define L(__) (son[__][0])
#define R(__) (son[__][1])
#define LL long long
#define oo (1<<30)
using namespace std;
int n,m,h[N],a[N],b[N],w[N],lw,f[N],g[N],tr[N],ans,tag[N],c[N],lc,ct[N],mp[N];
int lowbit(int x){ return x&(-x);}
void modify(int x,int d){ while(x<=lw) tr[x]=max(tr[x],d),x+=lowbit(x);}
int query(int x){ int s=0; while(x) s=max(s,tr[x]),x-=lowbit(x); return s;}
struct cht{
	int son[M][2],Max[M],len;
	void clear(){ len=n+1;}
	void modify(int t,int c,int l,int r,int s,int x){
		int mid=(l+r)>>1,k=(s>mid);
		son[t][k^1]=son[c][k^1];
		Max[t]=max(Max[c],x);
		if(l==r) return ;
		son[t][k]=++len;
		if(!k) modify(L(t),L(c),l,mid,s,x);
		else modify(R(t),R(c),mid+1,r,s,x);
	  }
	int query(int t,int l,int r,int l1,int r1){
		int mid=(l+r)>>1,res=0;
		if(l>r1 || r<l1) return 0;
		if(l>=l1&&r<=r1) return Max[t];
		res=max(res,query(L(t),l , mid,l1,r1));
		res=max(res,query(R(t),mid+1,r,l1,r1));
		return res;
	  }
}LT,RT;
int main()
{
	int i,S1,S2;
	scanf("%d %d",&n,&m);
	for(i=1;i<=n;i++)
		scanf("%d",&h[i]),w[++lw]=h[i];
	for(i=1;i<=m;i++)
		scanf("%d %d",&a[i],&b[i]),w[++lw]=b[i];
	sort(w+1,w+lw+1);
	lw=unique(w+1,w+lw+1)-w-1;
	for(i=1;i<=n;i++)
		h[i]=lower_bound(w+1,w+lw+1,h[i])-w;
	for(i=1;i<=m;i++)
		b[i]=lower_bound(w+1,w+lw+1,b[i])-w;
	LT.clear();
	RT.clear();
	memset(tr,0,sizeof(tr));
	for(i=1;i<=n;i++){
		f[i]=query(h[i]-1)+1;
		modify(h[i],f[i]);
		LT.modify(i,i-1,1,lw,h[i],f[i]);
		ans=max(ans,f[i]);
	  }
	memset(tr,0,sizeof(tr));
	for(i=n;i>=1;i--){
		g[i]=query(lw-h[i])+1;
		modify(lw-h[i]+1,g[i]);
		RT.modify(i,i+1,1,lw,h[i],g[i]);
	  }
  for(i=1;i<=n;i++)
		if(f[i]+g[i]-1==ans)
			mp[f[i]]=i,ct[f[i]]++;
	for(i=1;i<=ans;i++)
		if(ct[i]==1) tag[mp[i]]=1;
	for(i=1;i<=m;i++){
		S1=LT.query(a[i]-1,1,lw,1, b[i]-1);
		S2=RT.query(a[i]+1,1,lw,b[i]+1,lw);
		printf("%d\n",max(S1+S2+1,ans-tag[a[i]]));
	  }
	return 0;
}
