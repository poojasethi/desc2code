#include<bits/stdc++.h>

using namespace std;

#define st first
#define nd second
#define mp make_pair
#define pb push_back
#define sol (root+root)
#define sag (root+root+1)
#define orta ((bas+son)/2)
#define ll long long
#define pii pair<int,int>
#define type(x) __typeof((x).begin())
#define foreach(it, x) for(type(x) it = (x).begin(); it != (x).end(); it++)

const int N=4e5+5;
const int mod=1e9+7;
const int inf=1e9+7;

int n,m,i,s,mx,ans,a,b,l;
int L[N],R[N],A[N],B[N],AA[N],hh[N],hh2[N];
int st[4*N];

pii C[N];

pair<pii,int> Q[N];

void update(int root,int bas,int son,int x,int v){
	if(bas>x or son<x)
		return;
	if(bas==son){
		st[root]=v;
		return;
	}
	update(sol,bas,orta,x,v);
	update(sag,orta+1,son,x,v);
	st[root]=max(st[sol],st[sag]);
}

int query(int root,int bas,int son,int x,int y){
	if(bas>y or son<x)
		return 0;
	if(x<=bas and son<=y)
		return st[root];
	return max(query(sol,bas,orta,x,y),query(sag,orta+1,son,x,y));
}

bool cmp(pair<pii,int> x,pair<pii,int> y){
	return x.st.nd<y.st.nd;
}

main(){

	scanf("%d %d",&n,&m);

	for(i=1 ; i<=n ; i++){
		scanf("%d",A+i);
		C[i].st=A[i];
		C[i].nd=i;
	}

	for(i=1 ; i<=n ; i++){
		L[i]=lower_bound(B,B+s,A[i])-B+1;
		if(L[i]-1==s)
			s++;
		B[L[i]-1]=A[i];
	}
	
	s=0;

	for(i=n ; i>=1 ; i--){
		R[i]=lower_bound(B,B+s,-A[i])-B+1;
		mx=max(mx,R[i]);
		if(R[i]-1==s)
			s++;
		B[R[i]-1]=-A[i];
	}

	for(i=1 ; i<=n ; i++)
		if(L[i]+R[i]-1==mx)
			hh[L[i]]++;

	for(i=1 ; i<=n ; i++)
		if(L[i]+R[i]-1==mx and hh[L[i]]==1)
			hh2[i]=1;

	for(i=1 ; i<=m ; i++){
		scanf("%d %d",&Q[i].st.st,&Q[i].st.nd);
		Q[i].nd=i;
	}

	sort(Q+1,Q+m+1,cmp);

	sort(C+1,C+n+1);

	l=1;

	for(i=1 ; i<=m ; i++){
		while(l<=n and C[l].st<Q[i].st.nd){
			update(1,1,n,C[l].nd,L[C[l].nd]);
			l++;
		}
		AA[Q[i].nd]+=query(1,1,n,1,Q[i].st.st-1);
	}

	memset(st,0,sizeof st);

	l=n;

	for(i=m ; i>=1 ; i--){
		while(l>=1 and C[l].st>Q[i].st.nd){
			update(1,1,n,C[l].nd,R[C[l].nd]);
			l--;
		}
		AA[Q[i].nd]+=query(1,1,n,Q[i].st.st+1,n)+1;
		if(!hh2[Q[i].st.st])
			AA[Q[i].nd]=max(AA[Q[i].nd],mx);
		else
			AA[Q[i].nd]=max(AA[Q[i].nd],mx-1);
	}

	for(i=1 ; i<=m ; i++)
		printf("%d\n",AA[i]);
}
