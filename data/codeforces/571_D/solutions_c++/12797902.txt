#include <bits/stdc++.h>

using namespace std;

#define fillchar(a, s) memset((a), (s), sizeof(a))
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define all(v) (v).begin(), (v).end()
#define rep(it, v) for (__typeof((v).begin()) it = (v).begin(); it != (v).end(); it++)
#define fi first
#define se second

typedef long long ll;
typedef pair<int, int> pii;
const int MAXN = 1 << 19;

struct query {
	char c;
	int x, y;
	ll ans;
	query *child;
	void read() {
		scanf(" %c %d", &c, &x);
		if (c == 'U' || c == 'M') {
			scanf("%d", &y);
		}
	}
};

int N, M;
query Q[2 * MAXN];

//binary tree
struct btree {
	int ch[2 * MAXN][2];	//children
	int lt[2 * MAXN], rt[2 * MAXN];	//left, right ranges for nodes. it is the actual id of nodes...
	int chpar[2 * MAXN];	//parent of the node
	int cnode;	//current node id: basically # of nodes
	int curn[MAXN];	//current node id for node
	int ord[MAXN], idx[MAXN];	//order array, index in order array
	int ufpar[MAXN];	//union find par
	void setchild (int cur, int dir, int x) {
		ch[cur][dir] = x;
		chpar[x] = cur;
	}
	int find (int x) {
		return x == ufpar[x] ? x : ufpar[x] = find(ufpar[x]);
	}
	void merge (int x, int y) {
		//returns the node
		x = find(x);
		y = find(y);
		if (x == y) {
			puts("BAD MERGE");
			exit(0);
		}
		ufpar[x] = y;
		curn[y] = chpar[curn[y]];
	}
	void reset() {
		for (int i = 1; i <= N; i++) {
			curn[i] = ufpar[i] = i;
		}
	}
} utree, mtree;	//tree for university, dorm

//inorder traversal
void inorder (btree &tr, int x, int &ptr) {
	if (x > N) {
		for (int i = 0; i < 2; i++) {
			inorder(tr, tr.ch[x][i], ptr);
		}
		tr.lt[x] = tr.lt[tr.ch[x][0]];
		tr.rt[x] = tr.rt[tr.ch[x][1]];
	} else {
		ptr++;
		tr.ord[ptr] = x;
		tr.idx[x] = ptr;
	}
}

void filter (char c, btree &tr) {
	tr.reset();
	for (int i = 1; i <= N; i++) {
		tr.lt[i] = tr.rt[i] = i;
	}

	//merge them
	int &ctr = tr.cnode;
	ctr = N;
	for (int i = 1; i <= M; i++) {
		if (Q[i].c != c) {
			//not this type
			continue;
		}
		int x = tr.find(Q[i].x), y = tr.find(Q[i].y);
		//merge x and y together
		ctr++;
		tr.setchild(ctr, 0, tr.curn[x]);
		tr.setchild(ctr, 1, tr.curn[y]);
		tr.merge(x, y);
	}

	int ptr = 0;
	for (int i = 1; i <= ctr; i++) {
		if (tr.chpar[i]) {
			continue;
		}
		//dfs this tree
		inorder(tr, i, ptr);
	}

	if (ptr != N) {
		printf("UHOH %d\n", ptr);
		exit(0);
	}
	/*puts("ORD:");
	for (int i = 1; i <= N; i++) {
		printf("%d ", tr.ord[i]);
	}
	puts("");*/
	tr.reset();
}

//new data structures!
int tree[2 * MAXN], lazy[2 * MAXN];	//last time of a raid. military
ll bit[MAXN];//university
vector<query> qbef[MAXN];	//do these queries before removal

void add (int cur, int v) {
	tree[cur] = v;
	lazy[cur] = v;
}

void down (int cur) {
	if (lazy[cur]) {
		add(2 * cur, lazy[cur]);
		add(2 * cur + 1, lazy[cur]);
		lazy[cur] = 0;
	}
}

void update (int a, int b, int v, int cur = 1, int l = 0, int r = MAXN) {
	if (r <= a || b <= l) {
		return;
	}
	if (a <= l && r <= b) {
		add(cur, v);
		return;
	}
	down(cur);
	int mid = (l + r) / 2;
	update(a, b, v, 2 * cur, l, mid);
	update(a, b, v, 2 * cur + 1, mid, r);
}

int qtree (int a, int cur = 1, int l = 0, int r = MAXN) {
	if (r == l + 1) {
		return tree[cur];
	}
	down(cur);
	int mid = (l + r) / 2;
	return a < mid ? qtree(a, 2 * cur, l, mid) : qtree(a, 2 * cur + 1, mid, r);
}

void upbit (int x, int v) {
	for (; x < MAXN; x += (x & -x)) {
		bit[x] += v;
	}
}

ll qubit (int x) {
	ll s = 0;
	for (; x; x &= x - 1) {
		s += bit[x];
	}
	return s;
}

int clc = clock();

void go (bool second) {
	query qu;
	for (int i = 1; i <= M; i++) {
		if (second) {
			rep(it, qbef[i]) {
				it->child->ans -= qubit(utree.idx[it->x]);
				// cerr << "subtr " << qubit(ix) << endl;
			}
		}
		char c = Q[i].c;
		int x = Q[i].x, y = Q[i].y;
		if (c == 'M') {
			//merge military
			mtree.merge(x, y);
		} else if (c == 'U') {
			//merge university
			utree.merge(x, y);
		} else if (c == 'A') {
			//move in dorms. just add ans for now
			int cn = utree.curn[utree.find(x)];	//current node
			int ltidx = utree.idx[utree.lt[cn]], rtidx = utree.idx[utree.rt[cn]];
			int sz = rtidx - ltidx + 1;
			//update BIT
			upbit(ltidx, sz);
			upbit(rtidx + 1, -sz);
		} else if (c == 'Z') {
			if (second) {
				continue;
			}
			//raid; update last raids
			int cn = mtree.curn[mtree.find(x)];
			int ltidx = mtree.idx[mtree.lt[cn]], rtidx = mtree.idx[mtree.rt[cn]];
			update(ltidx, rtidx + 1, i);
			// cerr << "UPDATE TREE " << ltidx << ' ' << rtidx + 1 << " as " << i << endl;
		} else {
			if (second) {
				//don't need to compute ans again
				printf("%lld\n", Q[i].ans);
			} else {
				//query. also find last raids
				Q[i].ans = qubit(utree.idx[x]);
				// cerr << "qtree " << mtree.idx[x] << " is " << qtree(mtree.idx[x]) << endl;
				int raid = qtree(mtree.idx[x]);
				qu.x = x;
				qu.child = Q + i;
				qbef[raid].push_back(qu);
			}
		}
	}
}

int main() {
	if (fopen("input.txt", "r")) {
		freopen("input.txt", "r", stdin);
	}
	scanf("%d %d", &N, &M);
	for (int i = 1; i <= M; i++) {
		Q[i].read();
	}
	//ok the merges

	filter('U', utree);	//university
	filter('M', mtree);	//military
	//ok produce the new queries...
	//do it again but update other answers...
	go(false);
	mtree.reset();
	utree.reset();
	fillchar(tree, 0);
	fillchar(lazy, 0);
	fillchar(bit, 0);
	go(true);
}
                                                                   