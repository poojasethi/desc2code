from sys import stdin

def bfs_ish(left, right, n, k):
  current = []
  next = []
  visited = set()

  water = 0
  currPos = 0
  current.append(('left', currPos))
  
  while (len(current) != 0):
    for tup in current:
      side = tup[0]
      currPos = tup[1]
      if (water >= n):
        return False;
      elif (currPos >= n):
        return True;
      else:
        #check if can just go to top
        if ((currPos+1 >= n) or (currPos+k >= n)):
          return True
        #find neighbors
        if (side == 'left'):
          if ((('left', currPos+1) not in visited) and (left[currPos + 1] != 'X')):
            visited.add(('left', currPos+1))
            next.append(('left', currPos+1))
          if ((('left', currPos-1) not in visited) and (left[currPos - 1] != 'X') and (currPos-1 > water)):
            visited.add(('left', currPos-1))
            next.append(('left', currPos-1))
          if ((('right', currPos+k) not in visited) and (right[currPos+k] != 'X')):
            visited.add(('right', currPos+k))
            next.append(('right', currPos+k))
        else:
          if ((('right', currPos+1) not in visited) and (right[currPos + 1] != 'X')):
            visited.add(('right', currPos+1))
            next.append(('right', currPos+1))
          if ((('right', currPos-1) not in visited) and (right[currPos-1] != 'X') and (currPos-1 > water)):
            visited.add(('right', currPos-1))
            next.append(('right', currPos-1))
          if ((('left', currPos+k) not in visited) and (left[currPos+k] != 'X')):
            visited.add(('left', currPos+k))
            next.append(('left', currPos+k))
    current = next
    next = []
    water += 1
  return False    

def main():
  info = stdin.readline().rstrip().split(' ')
  n = int(info[0])
  k = int(info[1])

  left = stdin.readline().rstrip()
  right = stdin.readline().rstrip()

  if (bfs_ish(left, right, n, k)):
    print 'YES'
  else:
    print 'NO'
  return

main()
