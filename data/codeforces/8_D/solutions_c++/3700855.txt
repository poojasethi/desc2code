#include<cstdio>
#include<algorithm>
#include<complex>
#include<cmath>
#define prec 1e-8
#define x real()
#define y imag()
using namespace std;
typedef complex<double> point;
point src,shop,dest;
double t1,t2;
void read(point& a)
{	double x1,y1;
	scanf("%lf%lf",&x1,&y1);
	a=point(x1,y1);
}
int judge(point a,double ra,point b,double rb,point c,double rc)
{	if (abs(c-a)<=ra&&abs(c-b)<=rb)
		return 1;
	point ang;
	double x1,y1;
	b-=a,c-=a;
	ang=point(b.x/abs(b),b.y/abs(b));
	c/=ang;
	x1=rb*rb-ra*ra;
	x1-=abs(b)*abs(b);
	x1/=-2*abs(b);
	y1=ra*ra-x1*x1;
	if (y1<-prec)
		return 0;
	y1=max(y1,0.0);
	y1=sqrt(y1);
	if (1e-7<abs(y1*y1+(x1-abs(b))*(x1-abs(b))-rb*rb))
		return 0;
	if (abs(c-point(x1,y1))<=rc+1e-12)
		return 1;
	if (abs(c-point(x1,-y1))<=rc+1e-12)
		return 1;
	return 0;
}
int check(point a,double ra,point b,double rb,point c,double rc)
{	if (ra<-prec||rb<-prec||rc<-prec)
		return 0;
	ra=max(ra,0.0);
	rb=max(rb,0.0);
	rc=max(rc,0.0);
	if (judge(b,rb,a,ra,c,rc))
		return 1;
	if (judge(a,ra,c,rc,b,rb))
		return 1;
	if (judge(c,rc,b,rb,a,ra))
		return 1;
	return 0;
}
double work()
{	double l,r,mid;
	t1+=abs(src-shop)+abs(shop-dest);
	t2+=abs(src-dest);
	if (abs(src-shop)+abs(shop-dest)<=t2)
		return min(t1,t2);
	l=0,r=min(t1,t2);
	while (prec<abs(l-r))
	{	mid=(l+r)/2;
		if (check(src,mid,dest,t2-mid,shop,t1-mid-abs(shop-dest)))
			l=mid;
		else r=mid;
	}
	return l;
}
int main()
{	scanf("%lf%lf",&t1,&t2);
	read(src);
	read(dest);
	read(shop);
	printf("%.6lf\n",work());
	return 0;
}

	 		 		   			  			 		  	  	