#include<iostream>
#include<cstdio>
#include<cmath>
#include<complex>
using namespace std;
struct data
{
    long double x,y,r;
} a[4];
long double t1,t2,k,l,o,p,ans;
const double eps=1e-12;
int n,m,i,j;
long double dis(data a,data b)
{
    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
long double sqr(long double x)
{
    return x*x;
}
bool js(int i,int j,int k)
{
    long double u,v,p,q,r,t,d;
    if(dis(a[i],a[j])>a[i].r+a[j].r+eps || dis(a[i],a[k])>a[i].r+a[k].r+eps || dis(a[j],a[k])>a[j].r+a[k].r+eps) return false;
    if(dis(a[i],a[j])<fabs(a[i].r-a[j].r)+eps) return true;
     d=dis(a[i],a[j]);
     u=(a[i].r*a[i].r+d*d-a[j].r*a[j].r)/(2*d);
     v=sqrt(a[i].r*a[i].r-u*u+eps);
     v=max(v,(long double)0.0);
     q=(a[j].x-a[i].x)/d;
     p=(a[j].y-a[i].y)/d;
     r=a[i].x+q*u;
     t=a[i].y+p*u;
     return sqrt((r+v*p-a[k].x)*(r+v*p-a[k].x)+(t-v*q-a[k].y)*(t-v*q-a[k].y))<a[k].r+eps ||
            sqrt((r-v*p-a[k].x)*(r-v*p-a[k].x)+(t+v*q-a[k].y)*(t+v*q-a[k].y))<a[k].r+eps;
}
    
bool pd(long double mid)
{
    a[1].r=mid;
    a[2].r=dis(a[1],a[2])-mid+t2;
    a[3].r=dis(a[1],a[3])-mid+t1;
    if(js(1,2,3)) return true;
    if(js(1,3,2)) return true;
    if(js(2,3,1)) return true;
    return false;
}
int main( )
{
    cin >> t1 >> t2;
    for(i=1;i<=3;i++) cin >> a[i].x >> a[i].y;
    k=0;l=min(dis(a[1],a[3])+dis(a[3],a[2])+t1,dis(a[1],a[2])+t2);
    if(l>=dis(a[1],a[3])+dis(a[3],a[2])) k=l;
    while(fabs(k-l)>eps)
    {
        long double mid=(k+l)/2;
        if(pd(mid)) k=mid;
        else l=mid;
    }
    double ans=(k+l)/2+eps;
    printf("%.8f\n",ans);
    cin >> n;
    return 0;
}
