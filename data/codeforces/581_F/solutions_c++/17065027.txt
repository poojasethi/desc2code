#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <string>
#include <math.h>
#include <stdlib.h>
#include <time.h>
using namespace std;
typedef long long ll;
const int INF = 0x3f3f3f3f;
const int MAXN=5050;

int n;
int head[MAXN],id;
int dp[MAXN][MAXN];
bool vis[MAXN];
int son[MAXN];//son[i]表示i节点的叶子节点个数
int in[MAXN];

struct sa
{
    int to;
    int next;
}tree[MAXN<<1];

void init()
{
    id=0;
    memset(head,-1,sizeof(head));
}

void addedge(int u,int v)
{
    tree[id].to=v;
    tree[id].next=head[u];
    head[u]=id++;
}

void dfs(int u,int pre)
{
    dp[u][0]=0;
    for(int i=head[u]; i!=-1; i=tree[i].next)
    {
        int v=tree[i].to;
        if (v==pre) continue;
        dfs(v,u);
        for(int j=son[u]; j>=0; j--)//删除u节点的叶子节点
           for(int k=son[v]; k>=0; k--)
              dp[u][j+k]=min(dp[u][j+k],dp[u][j]+dp[v][k]);
        son[u]+=son[v];
    }
    for(int i=0; i<=son[u]; i++)
        dp[u][i]=min(dp[u][i],dp[u][son[u]-i]+1);//删除u节点
}

int main()
{
    while(scanf("%d",&n)!=-1)
    {
        init();
        memset(in,0,sizeof(in));
        for(int i=1; i<n; i++)
        {
            int u,v;
            scanf("%d%d",&u,&v);
            addedge(u,v);
            addedge(v,u);
            in[u]++;
            in[v]++;
        }
        int root=1;
        for(int i=1; i<=n; i++)
        {
            if (in[i]==1) {son[i]=1;}
            else {son[i]=0;root=i;}
        }
        memset(dp,INF,sizeof(dp));
        dfs(root,0);
        printf("%d\n",dp[root][son[root]/2]);
    }
    return 0;
}

 	 		 				 	    						  	   	