#include<bits/stdc++.h>
using namespace std;
const int maxn=5010;
struct Ttree{
	struct Tedge{
		int son; Tedge *pre;
		void add(int s_,Tedge *p_){ son=s_,pre=p_; }
	}edge[maxn<<1],*pos[maxn];
	int tot;
	void add(int a,int b){ edge[++tot].add(b,pos[a]),pos[a]=edge+tot; }
	void clear(){ memset(pos,0,sizeof(pos)); }
}t;
int f[maxn][maxn][2];
int leaf[maxn],deg[maxn];
int n;

void tree_dp(int x,int fa){
	leaf[x]=0; memset(f[x],63,sizeof(f[x]));
	if(deg[x]==1)
		leaf[x]=1,f[x][1][1]=f[x][0][0]=0;
	else{
		static int g[maxn][2]; f[x][0][0]=f[x][0][1]=0;
		for(Ttree::Tedge *i=t.pos[x];i;i=i->pre)
			if(i->son!=fa) tree_dp(i->son,x);
		for(Ttree::Tedge *i=t.pos[x];i;i=i->pre){
			memset(g,63,sizeof(g));
			for(int k=leaf[x];k>=0;--k)
				for(int p=leaf[i->son],v0,v1;p>=0;--p){
					v0=f[x][k][0]+f[i->son][p][0];
					v1=f[x][k][0]+f[i->son][p][1]+1;
					g[k+p][0]=min(g[k+p][0],min(v0,v1));
					v0=f[x][k][1]+f[i->son][p][0]+1;
					v1=f[x][k][1]+f[i->son][p][1];
					g[k+p][1]=min(g[k+p][1],min(v0,v1));
				}
			memcpy(f[x],g,sizeof(g));
			leaf[x]+=leaf[i->son];
		}
	}
}
int main(){
	scanf("%d",&n); t.clear();
	memset(deg,0,sizeof(deg));
	for(int i=1,a,b;i<=n-1;++i){
		scanf("%d%d",&a,&b);
		t.add(a,b),t.add(b,a);
		++deg[a],++deg[b];
	}
	if(n==2){ puts("1"); return 0; }
	for(int x=1;x<=n;++x)
		if(deg[x]!=1){
			tree_dp(x,0); int c=leaf[x]>>1;
			printf("%d\n",min(f[x][c][0],f[x][c][1]));
			break;
		}
	return 0;
}

  	  	 	   	  	  			   				