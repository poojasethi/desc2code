#include <iostream>
#include <stdio.h>
#include <string.h>
#include <vector>
using namespace std;
const int maxn=5050,maxm=10010,inf=0x3f3f3f3f;
int n;
vector<int>edge[maxm];
void init()
{
    for(int i=0; i<=n; i++)
        edge[i].clear();
}
int dp[maxn][maxn],leaf[maxn];///dp[i][j]=k; 表示以i节点为根删除j个叶子需要的删除的最少的边为k
void dfs(int u,int pre)
{
     dp[u][0]=0;///不删除边时，最少步数是0
     for(int i=1; i<=n; i++)
        dp[u][i]=inf;///初始化为inf
    if(edge[u].size()==1)///叶子
    {
        leaf[u]=1;
        dp[u][1]=1;
       //return ;
    }
    int L=edge[u].size();


    for(int i=0; i<L; i++)
    {
        int v=edge[u][i];
        if(v==pre)continue;
        dfs(v,u);
        leaf[u]+=leaf[v];
        for(int j=leaf[u]; j>=0; j--)
            for(int k=0; k<=leaf[v]; k++)
                dp[u][j+k]=min(dp[u][j+k],dp[u][j]+dp[v][k]);
                ///减掉j+k个叶子，父亲u的j个叶子，儿子v的k个叶子
    }
    for(int i=0; i<=leaf[u]; i++)
        dp[u][i]=min(dp[u][i],dp[u][leaf[u]-i]+1);
}
int main()
{

    while(scanf("%d",&n)!=-1)
    {
        init();
        if(n==2)
        {
            printf("1\n");
          return 0;
        }
        memset(dp,0,sizeof(dp));
        memset(leaf,0,sizeof(leaf));
        for(int i=1; i<n; i++)
        {
            int u,v;
            scanf("%d%d",&u,&v);
            edge[u].push_back(v);
            edge[v].push_back(u);
        }
        int root=1;
        while(edge[root++].size()==1);///找到第一个f非叶子节点作为根节点
        dfs(root,0);
        printf("%d\n",dp[root][leaf[root]/2]);
    }
    return 0;
}

	 	 		  	 		 					  			  				 	