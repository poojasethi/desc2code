#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <vector>
#include <queue>
#include <stack>
#define fi first
#define se second
#define mp make_pair
#define pb push_back
using namespace std;
vector < int > d[5005],e[5005];
int dp[5005][2][5005],n,m,a,b,c,i,j,k,cnt[5005],root,leaf,size[5005],pre[5005][5005];
void dfs(int x,int pa){
     if(cnt[x]==1){
		 dp[x][0][0]=0;
		 dp[x][1][1]=0;   	
    	 size[x]=1;
    	 return ;
	 }
	 int i,j,k,t;
	 for(i=0;i<d[x].size();i++)
	 if(d[x][i]!=pa){
		 e[x].pb(d[x][i]);
		 dfs(d[x][i],x);
	 }
	 int lf=e[x].size();
	 for(i=1;i<=lf;i++)
	 for(j=0;j<=leaf;j++)
	 pre[i][j]=6000;
	 int sz=0;
	 for(i=0;i<e[x].size();i++){
		 int nd=e[x][i];
		 for(k=sz;k>=0;k--)
	     for(j=size[nd];j>=0;j--)
	     for(t=0;t<2;t++)
	     pre[i+1][k+j]=min(pre[i+1][k+j],(1^t)+pre[i][k]+dp[nd][t][j]);
	     sz+=size[nd];
     }
     for(i=0;i<=sz;i++)
     dp[x][1][i]=pre[lf][i];
     sz=0;
     for(i=1;i<=lf;i++)
	 for(j=0;j<=leaf;j++)
	 pre[i][j]=6000;
     for(i=0;i<e[x].size();i++){
		 int nd=e[x][i];
		 for(k=sz;k>=0;k--)
	     for(j=size[nd];j>=0;j--)
	     for(t=0;t<2;t++)
	     pre[i+1][k+j]=min(pre[i+1][k+j],(0^t)+pre[i][k]+dp[nd][t][j]);
	     sz+=size[nd];
     }
     size[x]=sz;
     for(i=0;i<=sz;i++)
     dp[x][0][i]=pre[lf][i];
}
int main(){
	scanf("%d",&n);
	for(i=1;i<n;i++){
		scanf("%d %d",&a,&b);
		d[a].pb(b);
		d[b].pb(a);
		cnt[a]+=1;
		cnt[b]+=1;
	}
	if(n==2){
		printf("1\n");
		return 0;
	}
	for(i=1;i<=n;i++)
	if(cnt[i]>1)
	root=i;
	else
	leaf++;
	for(i=1;i<=n;i++)
	for(j=0;j<=leaf/2;j++)
	dp[i][0][j]=dp[i][1][j]=6000;
	dfs(root,0);
	printf("%d\n",min(dp[root][0][leaf/2],dp[root][1][leaf/2]));
	return 0;
}
