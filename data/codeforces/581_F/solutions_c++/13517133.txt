#include <bits/stdc++.h>

using namespace std;

#define SZ(c) c.size()
#define PB push_back
#define VI vector<int>
#define FOR(i,a,b) for(int i=(int)(a);i<=(int)(b);++i)
#define REP(i,n) for(int i=0;i<(int)(n);++i)

const int INF=1000000007;

const int SIZE = 5005;

VI graph[SIZE];
int num[SIZE];
int dp[SIZE][2][SIZE];
int n, x, y, root;

void dfs(int x, int p=0)
{
    if(SZ(graph[x])==1)
    {
       dp[x][0][1]=0;
       dp[x][1][0]=0;
       num[x]=1;
       return;
    }

    dp[x][0][0]=dp[x][1][0]=0;

    REP(i, SZ(graph[x])){
      int y = graph[x][i];
      if(y == p)continue;
      dfs(y, x);
      for(int j=num[x]; j>=0; j--){
          REP(v1, 2){
              if(dp[x][v1][j] < INF){
                  int val = dp[x][v1][j];
                  dp[x][v1][j] = INF;
                  for(int k=0; k<=num[y]; k++){
                      REP(v2, 2){
                          if(dp[y][v2][k] < INF)
                            dp[x][v1][j+k] = min(dp[x][v1][j+k], val+dp[y][v2][k]+(v1^v2));
                        }
                    }
                }
            }
        }
        num[x]+=num[y];
    }
}
int main()
{
    scanf("%d", &n);
    if(n==2)
    {
        printf("%d", 1);
        return 0;
    }

    REP(i, SIZE) REP(j, 2) REP(k, SIZE) dp[i][j][k] = INF;

    FOR(i,1,n-1)
    {
        cin>>x>>y;
        graph[x].PB(y);
        graph[y].PB(x);
    }

    FOR(i,1,n)
    {
        if(SZ(graph[i])!=1) {root=i; break;}
    }

    dfs(root);

    printf("%d", min(dp[root][0][num[root]/2],dp[root][1][num[root]/2]));

    return 0;
}
