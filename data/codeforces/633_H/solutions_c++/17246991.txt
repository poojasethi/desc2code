#include<bits/stdc++.h>
using namespace std;
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define re(i,a,b) for(int i=(a);i<(b);i++)
#define repd(i,a,b) for(int i=(a);i>=(b);i--)
#define run(v) for(int k=head[v];k;k=e[k].ne)
//#define v e[k].t
#define ergomap(i,a) for(map<int,int>::iterator i=a.begin();i!=a.end();i++)
#define ergoset(i,a) for(set<int>::iterator i=a.begin();i!=a.end();i++)
#define ergo(i,a) for(int i=0;i<a.size();i++)
#define clr(a) memset(a,0,sizeof(a));
#define il inline
#define sz(a) ((int)s.size())
#define pb push_back 
#define w1 first
#define w2 second
#define addm(a,b,c) {a=a+b;if(a>=c)a-=c;}
typedef pair<int,int> pa;
typedef long long ll;typedef long double ld;typedef unsigned long long ull;
const int N=6e5+5,M=2e6+5,INF=1e9;
const ll linf=1e18;
const double eps=1e-8,pi=acos(-1);
il int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}
il int max(int a,int b,int c){if(b>a)a=b;if(c>a)a=c;return a;}il int max(int a,int b){if(a>b)return a;return b;}il int min(int a,int b){if(a>b)return b;return a;}
il void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}
il void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}
il void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}
il ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}
il ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)addm(ret,a,p);return ret;}
il void judge(){
	freopen("data.in","r",stdin);
	freopen("data.out","w",stdout);}
il void gen(){freopen("data.in","w",stdout);}
int n,m,bin[30]={1},mod;
int fib[N],seq[N];
int f0[N],f1[N],rev[N],num[N];
map<int,int>mp;
struct Q{int l,r,id;}q[N];int qq;
int tot=0,bsiz=200;
int cmp(const Q&a,const Q&b){
	if(a.l/bsiz==b.l/bsiz)return a.r<b.r;
	return a.l<b.l;
}
int cl,cr,cnt[N],ans[N],a[N];
#define ls (k<<1)
#define rs (k<<1|1)
void pushup(int k){
	num[k]=num[ls]+num[rs];
	if(num[ls]){
		f0[k]=(f0[ls]+1ll*fib[num[ls]-1]*f0[rs]+1ll*fib[num[ls]]*f1[rs])%mod;
		f1[k]=(f1[ls]+1ll*fib[num[ls]]*f0[rs]+1ll*fib[num[ls]+1]*f1[rs])%mod;
	}else{
		f0[k]=f0[rs];f1[k]=f1[rs];
	}
}
void build(int k,int l,int r){
	if(l==r){f0[k]=f1[k]=0;num[k]=0;return;}
	int mid=(l+r)>>1;
	build(ls,l,mid);build(rs,mid+1,r);
}
void update(int k,int l,int r,int x,int tg){
	if(l==r){f0[k]=0;f1[k]=tg*rev[l];num[k]=tg;return;}
	int mid=(l+r)>>1;
	if(x<=mid)update(ls,l,mid,x,tg);
		else update(rs,mid+1,r,x,tg);
	pushup(k);
}
void update(int id,int opt){
	if(cnt[id]==0&&opt==1)update(1,1,tot,id,1);
	if(cnt[id]==1&&opt==-1)update(1,1,tot,id,0);
	cnt[id]+=opt;
}
void solvel(int l){
	while(cl>l){cl--;update(a[cl],1);}
	while(cl<l){update(a[cl],-1);cl++;}
}
void solver(int r){
	while(cr<r){cr++;update(a[cr],1);}
	while(cr>r){update(a[cr],-1);cr--;}
}
int main(){
	read(n,mod);
	fib[0]=0,fib[1]=1%mod;
	rep(i,2,30010)fib[i]=(fib[i-1]+fib[i-2])%mod;
	rep(i,1,n){
		read(a[i]);
		mp[a[i]];
	}
	ergomap(i,mp)rev[i->w2=++tot]=(i->w1)%mod;
	rep(i,1,n)a[i]=mp[a[i]];
	read(qq);rep(i,1,qq)read(q[i].l,q[i].r),q[i].id=i;
	sort(q+1,q+1+qq,cmp);
	build(1,1,tot);
	cl=1,cr=0;
	rep(i,1,qq){
		//if(cl>q[i].r)solvel(q[i].l),solver(q[i].r);else 
		solver(q[i].r),solvel(q[i].l);
		ans[q[i].id]=f1[1];
	}
	rep(i,1,qq)printf("%d\n",ans[i]);
}
