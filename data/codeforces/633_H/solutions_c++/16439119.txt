#pragma comment(linker, "/STACK:1024000000,1024000000")
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath>
#include <ctime>
#include <iostream>
#include <vector>
#include <queue>
#include <iomanip>
#include <algorithm>
#include <set>
#include <map>
#include <bitset>
#define LL long long
#define ULL unsigned long long 
#define INF 1<<30 
#define Mod 1000000009
#define PII pair<int,int>
#define mk make_pair
#define Min(a,b) (a<b?a:b)
#define Max(a,b) (a<b?b:a) 
using namespace std; 
const double PI=acos(-1.0);
const double EPS=1e-12;

inline int read() {
	static char ch;
	bool sgn = false;
	while (ch = getchar(), ch < '0' || ch > '9') if (ch == '-') sgn = true;
	int res = ch - 48;
	while (ch = getchar(), ch >= '0' && ch <= '9') res = res * 10 + ch - 48;
	return sgn ? -res : res;
}

const int N=3e4+5;

int n,m,block;
int a[N],b[N],cnt[N],ans[N];

struct query {
	int l,r,id;
	bool operator < (query x) {
		if(l/block==(x.l)/block) 
			return r/block<(x.r/block);
		return l/block<x.l/block;
	}
}Q[N];

struct Tree {
	int s1,s2;
	int a11,a12,a21,a22;
	int l,r;
}tree[N*4];

void build(int k,int l,int r) {
	tree[k].a11=tree[k].a22=1;
	tree[k].l=l; tree[k].r=r;
	if(l==r) return;
	int mid=(l+r)>>1;
	build(k<<1,l,mid); build((k<<1)+1,mid+1,r);
}

void update(int k) {
	tree[k].s1=tree[k<<1].s1+tree[(k<<1)+1].s1*tree[k<<1].a11+tree[(k<<1)+1].s2*tree[k<<1].a12;
	tree[k].s2=tree[k<<1].s2+tree[(k<<1)+1].s1*tree[k<<1].a21+tree[(k<<1)+1].s2*tree[k<<1].a22;
	tree[k].a11=tree[k<<1].a11*tree[(k<<1)+1].a11+tree[k<<1].a12*tree[(k<<1)+1].a21;
	tree[k].a12=tree[k<<1].a11*tree[(k<<1)+1].a12+tree[k<<1].a12*tree[(k<<1)+1].a22;
	tree[k].a21=tree[k<<1].a21*tree[(k<<1)+1].a11+tree[k<<1].a22*tree[(k<<1)+1].a21;
	tree[k].a22=tree[k<<1].a21*tree[(k<<1)+1].a12+tree[k<<1].a22*tree[(k<<1)+1].a22;
	tree[k].s1%=m;	tree[k].s2%=m;
	tree[k].a11%=m;	tree[k].a12%=m;	tree[k].a21%=m;	tree[k].a22%=m;
}

void Ins(int k,int p,bool flag) {
	if(tree[k].l>p||tree[k].r<p) return;
	if(tree[k].l==tree[k].r) {
		if(flag) {
			tree[k].s1=b[p]*1; tree[k].s2=0;
			tree[k].a11=tree[k].a12=tree[k].a21=1; tree[k].a22=0;
		} else {
			tree[k].s1=tree[k].s2=0;
			tree[k].a11=tree[k].a22=1;
			tree[k].a12=tree[k].a21=0; 
		}
		return;
	}
	Ins(k<<1,p,flag); Ins((k<<1)+1,p,flag);
	update(k);
}

void add(int x) {
	x=a[x];
	if(cnt[x]==0) Ins(1,x,1);
	cnt[x]++;
}

void sub(int x) {
	x=a[x];
	if(cnt[x]==1) Ins(1,x,0);
	cnt[x]--;
}

int main() {
	n=read(),m=read();
	block=sqrt(n);
	for(int i=1;i<=n;i++) a[i]=b[i]=read();
	sort(b+1,b+1+n);
	int B=unique(b+1,b+1+n)-b;
	for(int i=1;i<=n;i++) {
		a[i]=lower_bound(b+1,b+B,a[i])-b;
	}
	B--;
	build(1,1,B);
	int q=read();
	for(int i=1;i<=q;i++) {
		scanf("%d%d",&Q[i].l,&Q[i].r);
		Q[i].id=i;
	}
	sort(Q+1,Q+1+q);
	int l=1,r=0;
	for(int i=1;i<=q;i++) {
		while(l<Q[i].l) sub(l),l++;
		while(l>Q[i].l) l--,add(l);
		while(r<Q[i].r) r++,add(r);
		while(r>Q[i].r) sub(r),r--;
		ans[Q[i].id]=tree[1].s1;
	}
	for(int i=1;i<=q;i++) printf("%d\n",ans[i]);
}
