#include<cstdio>
#include<iostream>
#include<string>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;

struct unit
{int l,r,num;
};
struct unit q[60010];

struct fib
{int x,y;
};
struct fib f1[60010],f2[60010];

struct node
{int now,size,s1,s2;
};
struct node t[300010];

int n,nq,mod,lim,x,y,nl,nr,tot;
int a[60010],b[60010],w[60010],sa[60010],f[60010];

fib operator +(fib A,fib B){return (fib){(A.x+B.x)%mod,(A.y+B.y)%mod};}
fib operator -(fib A,fib B){return (fib){(A.x-B.x)%mod,(A.y-B.y)%mod};}

bool cmp(unit A,unit B)
{if(A.l/lim!=B.l/lim) return A.l<B.l;
 if((A.l/lim)&1)
 	return A.r>B.r;
 else
 	return A.r<B.r;	
}

void update(int k,int p)
{int x,y;
 if(t[p].now==k) return;
 x=t[p].s1;
 y=t[p].s2;
 //cout<<k<<" "<<p<<" "<<t[p].now<<" "<<t[p].s1<<" "<<t[p].s2<<endl;
 if(t[p].now<k)
 {	t[p].s1=((long long)f1[k-t[p].now+1].x*x%mod+(long long)f1[k-t[p].now+1].y*y%mod)%mod;
 	t[p].s2=((long long)f1[k+2-t[p].now].x*x%mod+(long long)f1[k+2-t[p].now].y*y%mod)%mod;	
 }
 else
 {	t[p].s1=((long long)f2[2+t[p].now-k].x*x%mod+(long long)f2[2+t[p].now-k].y*y%mod)%mod;
 	t[p].s2=((long long)f2[1+t[p].now-k].x*x%mod+(long long)f2[1+t[p].now-k].y*y%mod)%mod;
 }
 //cout<<t[p].s1<<" "<<t[p].s2<<endl;
 t[p].now=k;
}

void change(int p,int l,int r,int k)
{if(l==r)
 {	if(y==-1)
		t[p].s1=t[p].s2=t[p].size=t[p].now=0;	
	else
	{	t[p].now=k+1;
		t[p].s1=(long long)sa[l]*f[k+1]%mod;
		t[p].s2=(long long)sa[l]*f[k+2]%mod;
		t[p].size=1;
	}
 	return;
 }
 if(x<=(l+r)/2)
 {	change(p*2,l,(l+r)/2,k);
 	update(k+t[p*2].size+1,p*2+1);
 }
 else
 {	change(p*2+1,(l+r)/2+1,r,k+t[p*2].size);
 	update(k+1,p*2);
 }
 //update(k+t[p*2].size+1,p*2+1);
 //update(k+1,p*2);
 t[p].size=t[p*2].size+t[p*2+1].size;
 t[p].now=k+1;
 t[p].s1=(t[p*2].s1+t[p*2+1].s1)%mod;
 t[p].s2=(t[p*2].s2+t[p*2+1].s2)%mod;
 //cout<<t[p*2].s1<<" "<<t[p*2].s2<<" "<<t[p*2+1].s1<<" "<<t[p*2+1].s2<<endl;
 //cout<<"## "<<p<<" "<<l<<" "<<r<<" "<<t[p].now<<" "<<t[p].s1<<" "<<t[p].s2<<endl;
}
 
void trans(int l,int r)
{int i;
 /*
 if(nl>r || nr<l)
 {	for(i=nl;i<=nr;i++)
 	{	x=a[i],y=-1;
 		change(1,1,n,0);
 	}
 	for(i=l;i<=r;i++)
 	{	x=a[i],y=1;
 		change(1,1,n,0);
 	}
 	nl=l;
 	nr=r;
 	return;
 }
 */
 //cout<<l<<" "<<r<<" "<<nl<<" "<<nr<<endl;
 while(nr<r)
 {	x=a[nr+1],y=1;
 	w[a[nr+1]]++;
	if(w[a[nr+1]]==1) change(1,1,n,0);
 	nr++;
 	//cout<<"now I "<<nl<<" "<<nr<<" "<<t[1].s1<<endl;
 }
 while(nl>l)
 {	x=a[nl-1],y=1;
 	w[a[nl-1]]++;
 	if(w[a[nl-1]]==1) change(1,1,n,0);
 	nl--;
 	//cout<<"now II "<<nl<<" "<<nr<<" "<<t[1].s1<<endl;
 }
 while(nr>r)
 {	x=a[nr],y=-1;
 	w[a[nr]]--;
 	if(w[a[nr]]==0) change(1,1,n,0);
 	nr--;
 	//cout<<"now III "<<nl<<" "<<nr<<" "<<t[1].s1<<endl;
 }
 while(nl<l)
 {	x=a[nl],y=-1;
 	w[a[nl]]--;
 	if(w[a[nl]]==0) change(1,1,n,0);
 	nl++;
 	//cout<<"now IIII "<<nl<<" "<<nr<<" "<<t[1].s1<<endl;
 }
}

int main()
{int i,j;
 
 scanf("%d%d",&n,&mod);
 lim=(int)sqrt(n);
 for(i=1;i<=n;i++)
 {	scanf("%d",&a[i]);
 	sa[++tot]=a[i];
 }
 sort(sa+1,sa+tot+1);
 for(i=1;i<=n;i++) a[i]=lower_bound(sa+1,sa+tot+1,a[i])-sa;
 scanf("%d",&nq);
 for(i=1;i<=nq;i++)
 {	scanf("%d%d",&q[i].l,&q[i].r);	
 	q[i].num=i;
 }
 sort(q+1,q+nq+1,cmp);
 f1[1]=(fib){1,0};
 f1[2]=(fib){0,1};
 for(i=3;i<=n+5;i++) f1[i]=f1[i-1]+f1[i-2];
 f2[1]=(fib){0,1};
 f2[2]=(fib){1,0};
 for(i=3;i<=n+5;i++) f2[i]=f2[i-2]-f2[i-1];
 f[1]=f[2]=1;
 for(i=3;i<=n+5;i++) f[i]=(f[i-1]+f[i-2])%mod;
 for(i=q[1].l;i<=q[1].r;i++)
 {	x=a[i],y=1;
 	w[a[i]]++;
 	if(w[a[i]]==1) change(1,1,n,0);
 }
 nl=q[1].l;
 nr=q[1].r;
 b[q[1].num]=t[1].s1;
 for(i=2;i<=nq;i++)
 {	trans(q[i].l,q[i].r);
 	b[q[i].num]=(t[1].s1+mod)%mod;
 }
 for(i=1;i<=nq;i++)
 	printf("%d\n",b[i]);
 return 0;
}