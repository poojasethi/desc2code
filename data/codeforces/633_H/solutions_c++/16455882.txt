#include<stdio.h>
#include<string.h>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=3E4+77;
const int sqrtmaxn=180;
const int INF=1E9+7;
const long long LINF=INF*1ll;
typedef int LL;

int N,M,A[maxn],Q;
LL F[maxn];

char _mem[100000007];
int _cnt;
inline void *alloc(size_t size){
	memset(_mem+_cnt,0,size);
	void *ret=_mem+_cnt;
	_cnt+=size;
	return ret;
}

struct SEG{
	SEG *ch[2];
	LL cur,past;
	int cnt,sz,m;
	void *operator new(size_t size){return alloc(size);}
	void rightmove(){
		if(this==NULL) return;
		LL t=(cur+past)%M;
		past=cur;cur=t;
		++m;
	}
	void leftmove(){
		if(this==NULL) return;
		LL t=(cur-past+M)%M;
		cur=past;past=t;
		--m;
	}
	inline void pass(){
		if(this==NULL) return;
		if(m>0){
			/*
			while(m--){
				if(ch[0]) ch[0]->rightmove();
				if(ch[1]) ch[1]->rightmove();
			}
			*/
			for(int i=0;i<2;++i) if(ch[i]){
				LL nc=(F[m+1]*ch[i]->cur+F[m]*ch[i]->past)%M;
				LL np=(F[m]*ch[i]->cur+F[m-1]*ch[i]->past)%M;
				//if(nc>LINF || true) nc%=M;
				//if(np>LINF || true) np%=M;
				ch[i]->cur=nc;ch[i]->past=np;
				ch[i]->m+=m;
			}
		}else if(m<0){
			/*
			while(m++){
				if(ch[0]) ch[0]->leftmove();
				if(ch[1]) ch[1]->leftmove();
			}
			*/
			m=-m;
			for(int i=0;i<2;++i) if(ch[i]){
				LL nc=(F[m]*ch[i]->past-F[m-1]*ch[i]->cur);
				int d=!(m&1);
				if(nc<0) nc=-nc,d=!d;
				nc%=M;
				if(d) nc=(M-nc);

				LL np=(F[m+1]*ch[i]->past-F[m]*ch[i]->cur);
				d=m&1;
				if(np<0) np=-np,d=!d;
				np%=M;
				if(d) np=M-np;

				ch[i]->cur=nc;ch[i]->past=np;
				ch[i]->m-=m;
			}
		}
		m=0;
	}
	inline void maintain(){
		if(this==NULL) return;
		cur=past=sz=0;
		if(ch[0]){
			cur=ch[0]->cur;
			past=ch[0]->past;
			sz=ch[0]->sz;
		}
		if(ch[1]){
			cur=cur+ch[1]->cur;
			past=past+ch[1]->past;
			sz=sz+ch[1]->sz;
			cur=cur>=M?cur-M:cur;
			past=past>=M?past-M:past;
			//sz=sz>=M?sz-M:sz;
		}
	}
}*tree=NULL;
bool segInsert(SEG *&tr,int L,int R,int p,int v,int kth){
	if(tr==NULL) tr=new SEG;
	if(L==R){
		++tr->cnt;
		if(tr->cnt>1) return false;
		//cerr<<"added num "<<p<<endl;
		tr->cur=(F[kth]*v)%M;
		tr->past=(F[kth-1]*v)%M;
		tr->sz=1;
		return true;
	}
	tr->pass();
	int M=L+((R-L)>>1);
	bool flag;
	if(p<=M){
		flag=segInsert(tr->ch[0],L,M,p,v,kth);
		if(flag) tr->ch[1]->rightmove();
	}else{
		flag=segInsert(tr->ch[1],M+1,R,p,v,kth+(tr->ch[0]?tr->ch[0]->sz:0));
	}
	tr->maintain();
	return flag;
}
bool segRemove(SEG *tr,int L,int R,int p){
	if(L==R){
		--tr->cnt;
		if(tr->cnt>0) return false;
		//cerr<<"removed num "<<p<<endl;
		tr->cur=tr->past=0;
		tr->sz=0;
		return true;
	}
	tr->pass();
	int M=L+((R-L)>>1);
	bool flag;
	if(p<=M){
		flag=segRemove(tr->ch[0],L,M,p);
		if(flag) tr->ch[1]->leftmove();
	}else{
		flag=segRemove(tr->ch[1],M+1,R,p);
	}
	tr->maintain();
	return flag;
}
void segClear(){
	tree=NULL;
	_cnt=0;
}

struct QUERY{
	int a,b,idx,ans;
	void read(int x){scanf("%d%d",&a,&b);idx=x;}
}queries[maxn];
bool by_a(QUERY x,QUERY y){return x.a<y.a;}
bool by_b(QUERY x,QUERY y){return x.b<y.b;}
bool by_idx(QUERY x,QUERY y){return x.idx<y.idx;}

void solve(int ql,int qr){
	segClear();
	sort(queries+ql,queries+qr,by_b);
	//cerr<<"init solving a:"<<queries[ql].a<<" b:"<<queries[ql].b<<endl;
	for(int i=queries[ql].a;i<=queries[ql].b;++i) segInsert(tree,1,INF,A[i],A[i]%M,1);
	queries[ql].ans=tree->cur;
	int l=queries[ql].a,r=queries[ql].b;
	for(int i=ql+1;i<qr;++i){
		//cerr<<"solving a:"<<queries[i].a<<" b:"<<queries[i].b<<endl;
		while(r<queries[i].b) segInsert(tree,1,INF,A[r+1],A[r+1]%M,1),++r;
		if(l<queries[i].a){
			while(l<queries[i].a) segRemove(tree,1,INF,A[l++]);
		}else if(l>queries[i].a){
			while(l>queries[i].a) segInsert(tree,1,INF,A[l-1],A[l-1]%M,1),--l;
		}
		queries[i].ans=tree->cur;
	}
}

void init(){
	F[1]=1;
	for(int i=2;i<maxn;++i) F[i]=(F[i-1]+F[i-2])%M;
}

int main(){
	//freopen("data.txt","r",stdin);
	scanf("%d%d",&N,&M);
	for(int i=1;i<=N;++i) scanf("%d",A+i);
	scanf("%d",&Q);
	for(int i=0;i<Q;++i) queries[i].read(i);
	init();

	sort(queries,queries+Q,by_a);
	int l=0,r=0;
	for(int i=1;i<=N;i+=sqrtmaxn){
		while(r<Q && queries[r].a<(i+sqrtmaxn)) ++r;
		solve(l,r);
		l=r;
	}
	sort(queries,queries+Q,by_idx);
	for(int i=0;i<Q;++i){
		//cerr<<"a:"<<queries[i].a<<" b:"<<queries[i].b<<endl;
		printf("%d\n",queries[i].ans);
	}
	//cerr<<"mem cnt:"<<_cnt<<endl;
}
