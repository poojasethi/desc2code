#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
using namespace std;

const int N = 400, L = 205;
const int Mod = 10007;
int n, m, l, ans, N24, N25, N26, S, dp[L][L][L];
char s[L];
struct Matrix {
    int a[N][N];
    inline Matrix operator * (const Matrix &rhs) {
        Matrix res; int tmp;
        for (int i = 1; i <= S; ++i)
            for (int j = 1; j <= S; ++j) {
                tmp = 0;
                for (int k = i; k <= j; ++k)
                    tmp = (tmp + a[i][k] * rhs.a[k][j]) % Mod;
                res.a[i][j] = tmp % Mod;
            }
        return res;
    }
} I, G, A, B;

inline int calc(const int &left, const int &right, const int &n24) {
    int &res = dp[left][right][n24];
    if (res != -1) return res;
    res = 0;
    if (left == right)
        res = n24 == 0;
    else if (s[left] == s[right]) {
        if (left + 1 == right)
            res = n24 == 0;
        else
            res = calc(left + 1, right - 1, n24);
    }
    else if (n24 > 0)
        res = calc(left + 1, right, n24 - 1) + calc(left, right - 1, n24 - 1);
    if (res >= Mod) res -= Mod;
    return res;
}

inline void Init() {
    for (int i = 1; i <= S; ++i)
        I.a[i][i] = 1;
    for (int i = 1; i <= N24; ++i)
        G.a[i][i] = 24;
    for (int i = N24 + 1; i <= N24 + N25; ++i)
        G.a[i][i] = 25;
    for (int i = N24 + N25 + 1; i <= S; ++i)
        G.a[i][i] = 26;
    for (int i = 1; i < N24 + N25; ++i)
        G.a[i][i + 1] = 1;
    for (int i = N24 + 1; i <= N24 + N25; ++i)
        G.a[i][i + N25] = 1;
}

inline void Pow(Matrix &res, Matrix x, int Exp) {
    res = I;
    for (; Exp > 0; Exp >>= 1) {
        if (Exp & 1) res = res * x;
        x = x * x;
    }
}

int main() {
    scanf("%s%d", s, &n);
    m = strlen(s);
    n += m;
    l = (n + 1) / 2;
    N24 = m - 1;
    N25 = (m + 1) / 2;
    N26 = N25;
    S = N24 + N25 + N26;
    Init();
    Pow(B, G, l - 1);
    A = B * G;
    memset(dp, -1, sizeof(dp));
    for (int n24 = 0; n24 <= N24; ++n24) {
        int n25 = (m - n24 + 1) >> 1;
        int n26 = l - n24 - n25;
        if (n26 < 0) continue;
        int ways = calc(0, m - 1, n24);
        ans = (ans + ways * A.a[N24 - n24 + 1][N24 + n25 + N25] % Mod) % Mod;
        if ((n & 1) && (m - n24 & 1 ^ 1))
            ans = (ans - ways * B.a[N24 - n24 + 1][N24 + n25] % Mod) % Mod;
    }
    ans %= Mod;
    if (ans < 0) ans += Mod;
    printf("%d\n", ans);
    return 0;
}
