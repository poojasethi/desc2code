#undef NDEBUG
#ifdef SU1
#define _GLIBCXX_DEBUG
#endif

#include <bits/stdc++.h>

#define forn(i, n) for (int i = 0; i < int(n); i++)
#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)
#define fore(i, l, r) for (int i = int(l); i < int(r); i++)
#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))
#define all(a) (a).begin(), (a).end()
#define sz(a) int((a).size())
#define pb(a) push_back(a)
#define mp(x, y) make_pair((x), (y))
#define x first
#define y second

using namespace std;

typedef long long li;
typedef long double ld;
typedef pair<int, int> pt;

template<typename X> inline X abs(const X& a) { return a < 0? -a: a; }
template<typename X> inline X sqr(const X& a) { return a * a; }

const int INF = int(1e9);
const li INF64 = li(1e18);
const ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;

const int K = 93, M = K * 5;

int n, m, k;
char a[K];
int num[150];
string g[K][4];
int gg[K][K];

inline bool read() {
    if (!(cin >> n >> m >> k)) return false;
    forn(i, k) {
        assert(scanf(" %c", &a[i]) == 1);
        num[int(a[i])] = i;
        forn(j, 4) {
            static char buf[K];
            assert(scanf("%s", buf) == 1);
            if (buf[0] == '~') g[i][j].clear();
            else g[i][j] = string(buf);
        }
    }
    forn(i, k)
        forn(j, 4)
            forn(k, sz(g[i][j]))
                gg[i][num[int(g[i][j][k])]] = 1;
    return true;
}

#ifdef SU1
//#define LOG
#endif

int szz;
int x[K];
vector<ld> z[M];

inline void print() {
#ifdef LOG
    cerr << setprecision(0) << fixed;
    forn(i, szz) {
        int b = 0;
        forn(j, sz(z[i]) - 1) {
            if (abs(z[i][j]) < EPS) continue;
            if (!b) b = 1;
            else cerr << "+ ";
            cerr << "x" << j + 1 << " * " << z[i][j] << ' ';
        }
        cerr << "= " << z[i].back() << endl;
    }
    cerr << endl;
#endif
}

void gauss() {
    forn(i, szz) assert(sz(z[i]) == k + 1);

    print();

    forn(i, k) {
        int idx = -1;
        fore(j, i, szz)
            if (idx == -1 || abs(z[idx][i]) < abs(z[j][i])) {
                idx = j;
                //break;
            }
        forn(j, sz(z[i])) swap(z[i][j], z[idx][j]);
        ld v = z[i][i];
        assert(abs(v) > 1e-3);
        forn(j, sz(z[i])) z[i][j] /= v;
        assert(abs(z[i][i] - 1) < 1e-3);

        forn(j, szz)
            if (j != i) {
                ld v = z[j][i];
                forn(k, sz(z[j])) z[j][k] -= v * z[i][k];
                assert(abs(z[j][i]) < 1e-3);
            }
    }
    
    print();

    forn(i, k) x[i] = int(z[i][k] + 0.5);
}

char tab[303][303];

inline void print2() {
    forn(i, n) {
        forn(j, m) putchar(tab[i][j]);
        puts("");
    }
}

inline void solve() {
    szz = 0;
    forn(i, 4) {
        vector<ld> cur(k + 1, 0);
        cur[k] = i % 2 ? n : m;
        forn(j, k)
            if (g[j][i].empty())
                cur[j] = +1;
        z[szz++] = cur;
    }

    forn(i, k)
        forn(j, 4) {
            if (g[i][j].empty()) continue;

            vector<ld> cur(k + 1, 0);
            vector<int> used(k, 0);
            queue<pt> q;
            q.push(mp(i, j));
            used[i] = 1;

            while (!q.empty()) {
                int v = q.front().x;
                int d = q.front().y;
                q.pop();
                cur[v] = ((d >> 1) & 1) ? -1 : +1;

                forn(k, sz(g[v][d])) {
                    int to = num[int(g[v][d][k])];
                    if (!used[to]) {
                        used[to] = 1;
                        q.push(mp(to, (d + 2) % 4));
                    }
                }
            }

            z[szz++] = cur;
        }

    gauss();

#ifdef LOG
    forn(i, k) cerr << x[i] << ' '; cerr << endl;
#endif

    set<pt> st;
    forn(i, n) forn(j, m) st.insert(mp(i, j));

    vector<int> used(k, 0);
    memset(tab, '.', sizeof(tab));
    while (!st.empty()) {
        int sx = st.begin()->x;
        int sy = st.begin()->y;
        st.erase(st.begin());
        int up = sx ? num[int(tab[sx - 1][sy])] : -1;
        int lf = sy ? num[int(tab[sx][sy - 1])] : -1;

        int f = 0;
        forn(i, k)
            if (!used[i]) {
                int ok = 1;
                if (up == -1) ok &= g[i][0].empty();
                else ok &= gg[i][up];
                if (lf == -1) ok &= g[i][3].empty();
                else ok &= gg[i][lf];
                if (ok) {
                    used[i] = 1;
                    forn(j, x[i])
                        forn(k, x[i]) {
                            tab[sx + j][sy + k] = a[i];
                            st.erase(mp(sx + j, sy + k));
                        }
                    f = 1;
                    break;
                }
            }
        assert(f);
        //print2();
    }

    print2();
}

int main() {
#ifdef SU1
    assert(freopen("input.txt", "rt", stdin));
    assert(freopen("output.txt", "wt", stdout));
#endif
    
    cout << setprecision(10) << fixed;
    cerr << setprecision(5) << fixed;

    while (read()) {
        solve();
        break;
    }
    //system("pause");
    return 0;
}