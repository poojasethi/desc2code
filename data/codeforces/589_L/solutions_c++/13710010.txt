#include <cstdio>
#include <iostream>
#include <cctype>
#include <cstring>
#include <string>
#include <cmath>
#include <algorithm>
#include <vector>
#include <deque>
#include <map>
#include <set>
#include <bitset>
#include <cassert>

using namespace std;

const int mxk = 96;

int N, M, K;
string T[mxk], R[mxk], B[mxk], L[mxk];
char C[mxk];
int tr[128];
bool v[mxk];

double Bottom[mxk][mxk], Right[mxk][mxk];
double a[mxk * 50][mxk]; // a[][0] * x0 + a[][1] * x1 + ... = xK
int al = 0;

double x[mxk];

const double Eps = 1e-6;
void solve(double a[][mxk], double ans[], int n, int m)
{
    static bool l[mxk];
    int res = 0;
    int r = 0;
    for(int i = 0; i < m; i ++)
        l[i] = false;
    for(int i = 0; i < m; i ++)
    {
        for(int j = r; j < n; j ++)
            if(fabs(a[j][i]) > Eps)
            {
                for(int k = i; k <= m; k ++)
                    swap(a[j][k], a[r][k]);
                break;
            }
        if(fabs(a[r][i]) < Eps)
        {
            res ++;
            continue;
        }
        for(int j = 0; j < n; j ++)
            if(j != r && fabs(a[j][i]) > Eps)
            {
                double tmp = a[j][i] / a[r][i];
                for(int k = i; k <= m; k ++)
                    a[j][k] -= tmp * a[r][k];
            }
        l[i] = true;
        r ++;
    }
    for(int i = 0; i < m; i ++)
        if(l[i])
            for(int j = 0; j < n; j ++)
                if(fabs(a[j][i]) > Eps)
                    ans[i] = a[j][m] / a[j][i];
}

char ans[306][306];

bool check(string &top, string &left) {
    if (top != "~")
        for (int i = 0; i < top.size(); ++i)
            if (!v[tr[top[i]]])
                return false;
    if (left != "~")
        for (int i = 0; i < left.size(); ++i)
            if (!v[tr[left[i]]])
                return false;
    return true;
}

void Equal(double p0[mxk], double p1[mxk]) { // p0 == p1
    for (int i = 0; i <= K; ++i)
        a[al][i] = p0[i] - p1[i];
    ++al;
}

void Equal(double p[mxk], double y) {
    for (int i = 0; i <= K; ++i)
        a[al][i] = p[i];
    a[al][K] = y;
    ++al;
}

void Equal(double p0[mxk], int t, double p1[mxk]) { // p0 + xt == p1
    for (int i = 0; i <= K; ++i)
        a[al][i] = p0[i] - p1[i];
    a[al][t] += 1.0;
    ++al;
}

void EXEC() {
    cin >> N >> M >> K;
    for (int i = 0; i < K; ++i) {
        cin >> C[i];
        tr[C[i]] = i;
        cin >> T[i] >> R[i] >> B[i] >> L[i];
        //cout << T[i] << R[i] << B[i] << L[i] << endl;
    }
    for (int i = 0; i < K; ++i) {
        for (int j = 0; j < K; ++j) if (!v[tr[C[j]]])
            if (check(T[j], L[j])) {
                v[tr[C[j]]] = true;
                
                // suan youxia jiao
                if (T[j] != "~") {
                    int t = tr[T[j][0]];
                    for (int k = 0; k <= K; ++k) // K : chang shu
                        Bottom[j][k] = Bottom[t][k];
                }
                Bottom[j][j] += 1.0;
                
                if (L[j] != "~") {
                    int t = tr[L[j][0]];
                    for (int k = 0; k <= K; ++k)
                        Right[j][k] = Right[t][k];
                }
                Right[j][j] += 1.0;
                
                // lie fang cheng...
                if (T[j] != "~")
                    for (int k = 1; k < T[j].size(); ++k)
                        Equal(Bottom[tr[T[j][0]]], Bottom[tr[T[j][k]]]);
                
                if (L[j] != "~")
                    for (int k = 1; k < L[j].size(); ++k)
                        Equal(Right[tr[L[j][0]]], Right[tr[L[j][k]]]);
                
                
                if (T[j] != "~" && L[j] != "~") {
                    // leftTop
                    int lT = -1;
                    bool P[mxk] = {};
                    for (int k = 0; k < T[j].size(); ++k)
                        P[tr[T[j][k]]] = true;
                    for (int k = 0; k < T[j].size(); ++k) {
                        int t = tr[T[j][k]];
                        if (R[t] != "~")
                            for (int u = 0; u < R[t].size(); ++u)
                                P[tr[R[t][u]]] = false;
                    }
                    for (int k = 0; k < T[j].size(); ++k)
                        if (P[tr[T[j][k]]]) {
                            lT = tr[T[j][k]];
                            break;
                        }
                    
                    // topLeft
                    int tL = -1;
                    memset(P, 0, sizeof P);
                    for (int k = 0; k < L[j].size(); ++k)
                        P[tr[L[j][k]]] = true;
                    for (int k = 0; k < L[j].size(); ++k) {
                        int t = tr[L[j][k]];
                        if (B[t] != "~")
                            for (int u = 0; u < B[t].size(); ++u)
                                P[tr[B[t][u]]] = false;
                    }
                    for (int k = 0; k < L[j].size(); ++k)
                        if (P[tr[L[j][k]]]) {
                            tL = tr[L[j][k]];
                            break;
                        }
                    
                    // assert lT != -1 && tL != -1
                    bool flag = true;
                    if (L[lT] != "~")
                        for (int k = 0; k < L[lT].size(); ++k)
                            if (tr[L[lT][k]] == tL) {
                                flag = false;
                                break;
                            }
                    if (T[tL] != "~")
                        for (int k = 0; k < T[tL].size(); ++k)
                            if (tr[T[tL][k]] == lT) {
                                flag = false;
                                break;
                            }
                    
                    if (flag) {
                        int P[mxk] = {};
                        int cor = -1;
                        for (int k = 0; k < T[tL].size(); ++k)
                            ++P[tr[T[tL][k]]];
                        for (int k = 0; k < L[lT].size(); ++k)
                            ++P[tr[L[lT][k]]];
                        for (int k = 0; k < K; ++k)
                            if (P[k] == 2) {
                                cor = k;
                                break;
                            }
                        Equal(Bottom[tr[T[j][0]]], Bottom[cor]);
                        Equal(Right[tr[L[j][0]]], Right[cor]);
                        
                        Equal(Bottom[lT], tL, Bottom[tL]);
                        Equal(Right[tL], lT, Right[lT]);
                    }
                }
                
                if (B[j] == "~")
                    Equal(Bottom[j], N);
                if (R[j] == "~")
                    Equal(Right[j], M);
                
                break;
            }
    }
    
    /*cout << "a : " << endl;
    for (int i = 0; i < al; ++i) {
        for (int j = 0; j <= K; ++j)
            cout << a[i][j] << ", ";
        cout << endl;
    }*/
    
    solve(a, x, al, K);
    
    /*cout << "x : " << endl;
    for (int i = 0; i < K; ++i)
        cout << x[i] << ", ";
    cout << endl;*/
    
    int sum = 0;
    
    for (int i = 0; i < K; ++i) {
        double bottom = 0.0;
        for (int j = 0; j < K; ++j)
            bottom += Bottom[i][j] * x[j];
        double top = bottom - x[i];
        int itop = round(top);
        
        double right = 0.0;
        for (int j = 0; j < K; ++j)
            right += Right[i][j] * x[j];
        double left = right - x[i];
        int ileft = round(left);
        int ix = round(x[i]);
        for (int j = 0; j < ix; ++j)
            for (int k = 0; k < ix; ++k)
                ans[itop + j][ileft + k] = C[i];
        sum += ix * ix;
    }
    
//  assert(sum == N * M);
    
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < M; ++j) {
            printf("%c", ans[i][j]);
            assert(ans[i][j] != 0);
        }
        printf("\n");
    }
}

int main() {
    EXEC();
    return 0;
}