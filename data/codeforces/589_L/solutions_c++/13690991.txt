#include <bits/stdc++.h>

using namespace std;

#define fr(a,b,c) for(int (a) = (b); (a) < (c); ++(a))
#define rp(a,b) fr(a,0,b)
#define fre(a,b) for(int a = adj[b]; ~a; a = ant[a])
#define cl(a,b) memset((a), (b), sizeof(a))
#define sc(a) scanf("%d", &a)
#define sc2(a,b) scanf("%d%d", &a, &b)
#define sc3(a,b,c) scanf("%d%d%d", &a, &b, &c)
#define scs(s) scanf("%s", s)
#define pri(x) printf("%d\n", x)

#define iter(a) __typeof((a).begin())
#define fore(a,b) for(iter(b) a = (b).begin(); a != (b).end(); ++a)

#define st first
#define nd second
#define mp make_pair
#define pb push_back

#define db(x) cerr << #x << " == " << x << endl
#define dbs(x) cerr << x << endl
#define _ << ", " <<

const int oo = 0x3f3f3f3f;

typedef long long ll;
typedef pair<int,int> pii;
typedef vector<int> vi;
typedef vector< vi > vii;

#define N 1009
#define R 5009

int cmp(double a, double b= 0) {
	if (fabs(a-b) <= 1e-8) return 0;
	return (a > b)? 1 : -1;
}

double mat[R][N], b[R], tam[N];

void printg(int n, int m) {
	rp(i, m) {
		rp(j, n+1) printf("%.2lf ", mat[i][j]);
		puts("");
	}
	puts("");
}

void gauss(int n, int m) {
	#define M(i,j) (mat[idx[i]][j])
	vi idx(m);
	rp(i, m) idx[i] = i;
	rp(i, m) mat[i][n] = b[i];
	
	int step = 0;
	rp(i, n) {
		//printg(n, m);
		int p = -1; double pivot = 1e-8;
		fr(j, step, m) 
			if (abs(M(j,i)) > abs(pivot)) {
				p = j;
				pivot = M(j,i);
			}
		
		if (p == -1) continue;
		swap(idx[step], idx[p]);
		rp(j, n+1) M(step,j) /= pivot;
		rp(j,m) if (step != j) {
			double w = M(j,i);
			rp(k, n+1) M(j,k) -= w*M(step,k);
		}
		step++;
	}
	//printg(n, m);
	//fr(i, step, m)
		//if (abs(M(i,n)) > 1e-8) puts("NO SOL");
	rp(i, n) tam[i] = M(i,n);
}

int m, n, k, id[N];
char grid[509][509], buf[N], symb[N];

vi adj[N][4];

int rc, pilha[N], top;

void dfs1(int v) {
	pilha[top++] = v;
	
	if (adj[v][1].size() == 0) {
		rp(i, k) mat[rc][i] = 0;
		rp(i, top) mat[rc][pilha[i]] = 1;
		b[rc] = n;
		rc++;
	} else {
		rp(i, adj[v][1].size())
			dfs1(adj[v][1][i]);
	}
	
	top--;
}

void dfs2(int v) {
	pilha[top++] = v;
	
	if (adj[v][2].size() == 0) {
		rp(i, k) mat[rc][i] = 0;
		rp(i, top) mat[rc][pilha[i]] = 1;
		b[rc] = m;
		rc++;
	} else {
		rp(i, adj[v][2].size())
			dfs2(adj[v][2][i]);
	}
	
	top--;
}

void equal(int x, int y) {
	rp(i, k) mat[rc][i] = 0;
	mat[rc][x] = 1;
	mat[rc][y] = -1;
	b[rc] = 0;
	rc++;
}

bool mark[N];

void print(int v, int y);

void itera(int y, vi left) {
	int len = left.size();
	set<int> cnj(left.begin(), left.end());
	
	while (len) {
		int w;
		rp(i, len) {
			w = left[i];
			bool up = 0;
			
			rp(j, adj[w][0].size()) 
				if (cnj.count(adj[w][0][j])) {
				up = 1; j = oo;
			}
			if (!up) {
				swap(left[i], left[len-1]);
				break;
			}
		}
		
		cnj.erase(w);
		len--;
		print(w, y);
	}
}

void print(int v, int y) {
	if (mark[v]) return;
	mark[v] = 1;
	
	int sz = round(tam[v]);
	int x = 0;
	while (grid[x][y]) x++;
	//db(v _ x _ y);
	fr(i, x, x+sz) fr(j, y, y+sz) grid[i][j] = symb[v];

	itera(y+sz, adj[v][1]);
}

int main() {
	while (sc3(m, n, k) == 3) {
		rp(i, k) {
			scs(buf);
			symb[i] = buf[0];
			id[buf[0]] = i;
			
			rp(j, 4) {
				scs(buf);
				int len = strlen(buf);
				if (len == 1 && buf[0] == 126) {
					len = 0;
				}
				
				adj[i][j] = vi(len);
				rp(l, len) {
					int v = (int) buf[l];
					adj[i][j][l] = v;
				}
			}
		}
		
		rp(i, k) rp(j, 4) rp(l, adj[i][j].size())
			adj[i][j][l] = id[adj[i][j][l]];
		
		rc = 0;
		top = 0;
		rp(i, k) {
			if (adj[i][3].size() == 0)
				dfs1(i);
			else if (adj[i][3].size() == 1) {
				int j = adj[i][3][0];
				if (adj[j][1].size() == 1) 
					equal(i, j);
			}
			
			if (adj[i][0].size() == 0)
				dfs2(i);
			else if (adj[i][0].size() == 1) {
				int j = adj[i][0][0];
				if (adj[j][2].size() == 1) 
					equal(i, j);
			}
		}
		
		gauss(k, rc);
		
		cl(mark, 0);
		cl(grid, 0);
		vi left;
		rp(i, k) 
			//db(symb[i] _ tam[i]);
			if (adj[i][3].size() == 0) left.pb(i);
		itera(0, left);
		
		rp(i, m) puts(grid[i]);
	}
	return 0;
}





































