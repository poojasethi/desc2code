#include <bits/stdc++.h>

#define F first
#define S second
#define pb push_back
#define mp make_pair
#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++i)
#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)
#define sz(a) ((int)(a).size())
#define all(a) (a).begin(),a.end()
#define pw(x) (1LL<<(x))

using namespace std;

typedef long long ll;
typedef double dbl;
typedef vector<int> vi;
typedef pair<int, int> pi;

const int inf = (int)1.01e9;
const dbl eps = 1e-9;

/* --- main part --- */

#define TASK "1"

const int N = 3010;


pi a[N];
set<int> S;

int d[N];

int R[N];
int L[N];

int to[N];
int cnt[N];

ll val = 0;
int c, k;

inline int f(int y)
{
    if (cnt[y] >= k) return (c - to[y]) * (y - L[y]);
    return 0;
}

void upd(int y)
{
    //eprintf("---------- UPD %d\n", y);
    if (d[y] == 0)
    {
        set<int>::iterator it = S.lower_bound(y);
        to[y] = y;
        //cnt[y] = 1;
        if (it != S.end())
        {
            R[y] = *it;

            int z = R[y];
            while (z < c && cnt[y] < k)
            {
                cnt[y] += d[z];
                if (cnt[y] >= k) break;
                z = R[z];
            }
            to[y] = z;
        }

        if (it != S.begin())
        {
            --it;
            L[y] = *it;
            R[L[y]] = y;

            int z = L[y];
            while (z >= 0)
            {
                if (cnt[z] >= k) break;
                to[z] = max(to[z], y);
                z = L[z];
            }
        }
    
        //eprintf("val = %I64d\n", val);
        val += f(y);
        //eprintf("val = %I64d\n", val);

        
        if (R[y] < c)
        {
            //eprintf("!! R[y] = %d\n", R[y]);
            val -= f(R[y]);
            //eprintf("- %d\n", f(R[y]));
            L[R[y]] = y;
            val += f(R[y]);
            //eprintf("+ %d\n", f(R[y]));
        }
        L[R[y]] = y;

        if (to[y] == c) to[y] = L[c];

        S.insert(y);

        //eprintf("!! val = %I64d\n", val);
    }        

    d[y]++;


    
    int z = y;
    while (z >= 0)
    {
        //eprintf("z = %d\n", z);
        if (to[z] < y) break;
        val -= f(z);
        cnt[z] += 1;
        val += f(z);

        if (to[z] < c)
        {
            if (cnt[z] - d[to[z]] >= k)
            {
                val -= f(z);
                cnt[z] -= d[to[z]];
                to[z] = L[to[z]];
                val += f(z);
            }
        }
        z = L[z];
    }

    //eprintf("val = %I64d\n", val);
    //forn(i, c + 1) eprintf("i = %d, L = %d, R = %d, d = %d, cnt = %d, to = %d, f = %d\n", i, L[i], R[i], d[i], cnt[i], to[i], f(i));

}




int main()
{
    #ifdef home
        assert(freopen(TASK".in", "r", stdin));
        assert(freopen(TASK".out", "w", stdout));
    #endif
    int r, n;
    scanf("%d%d%d%d", &r, &c, &n, &k);
    forn(i, n)
    {
        int x, y;
        scanf("%d%d", &x, &y);
        --x, --y;
        a[i] = mp(x, y);
    }
    sort(a, a + n);
    ll res = 0;
    for (int rst = 0; rst < r; ++rst)
    {
        int pos = 0;
        while (pos < n && a[pos].F < rst) pos++;

        val = 0;
        S.clear();
        forn(i, c + 1) R[i] = c;
        forn(i, c + 1) L[i] = -1;
        forn(i, c) d[i] = 0, to[i] = 0, cnt[i] = 0;
        
        for (int ren = rst; ren < r; ++ren)
        {
            while (pos < n && a[pos].F == ren)
            {
                upd(a[pos].S);
                pos++;
            }
            res += val;
            //eprintf("rst = %d, ren = %d, val = %I64d\n", rst, ren, val);
        }
    }
    printf("%I64d\n", res);



        
    #ifdef home
        eprintf("time = %d ms\n", (int)(clock() * 1000. / CLOCKS_PER_SEC));
    #endif
    return 0;
}