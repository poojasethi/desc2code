import copy


def dist(p1, p2):
    return ((p1[0] - p2[0]) * (p1[0] - p2[0]) +
            (p1[1] - p2[1]) * (p1[1] - p2[1]))


def check(p0, p1, p2, p3):
    d01 = dist(p0, p1)
    d02 = dist(p0, p2)
    d03 = dist(p0, p3)
    d12 = dist(p1, p2)
    d13 = dist(p1, p3)
    d23 = dist(p2, p3)

    if (d01 * d02 * d03 * d12 * d13 * d23) == 0:
        return False

    if d01 == d02:
        if d13 == d01 and d23 == d01 and d12 == d03:
            return True
    elif d01 == d03:
        if d12 == d01 and d23 == d01 and d13 == d02:
            return True
    elif d02 == d03:
        if d12 == d02 and d13 == d02 and d23 == d01:
            return True
    return False


def turn(p, order):
    price = 0
    a = [1] * 4
    for i in xrange(4):
        cur = order % 4
        order /= 4
        a[i] = cur

        price += cur

    if check(p[0][a[0]],
             p[1][a[1]],
             p[2][a[2]],
             p[3][a[3]]):
        return price
    else:
        return -1

def one_turn(p, cur, a, b):
    if cur == 2:
        p[0] = a - (-a + p[0])
        p[1] = b - (-b + p[1])
    elif cur == 1:
        x = p[0]
        y = p[1]
        p[0] = a - (y - b)
        p[1] = b + (x - a)
    elif cur == 3:
        x = p[0]
        y = p[1]
        p[0] = a + (y - b)
        p[1] = b - (x - a)


n = int(raw_input())
p = [[]] * 4
for i in xrange(n):
    for j in xrange(4):
        s = raw_input()
        p[j] = ([int(x) for x in s.split(' ')])

    # print p
    # turn(p, 3)
    # print p

    p1 = [[]] * 4
    for j in xrange(4):
        p1[j] = []
        for k in xrange(4):
            p1[j].append([p[j][0], p[j][1]])

    for j in xrange(4):
        for k in xrange(4):
            one_turn(p1[j][k], k, p[j][2], p[j][3])

    best_res = -1
    for j in xrange(256):
        res = turn(p1, j)
        if res != -1 and (best_res == -1 or res < best_res):
            # print p1
            # print res
            best_res = res

    print best_res