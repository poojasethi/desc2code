import cmath
nooftest=input()
square=[]
for i in range(nooftest):
    square.append([])
    for j in range(4):
        square[i].append([])
        data=map(int,raw_input().split())
        a=data[0]
        b=data[1]
        x=data[2]
        y=data[3]
        rotation1=[-b+x+y,a+y-x,x,y]
        rotation2=[(2*x)-a,(2*y)-b,x,y]
        rotation3=[b+x-y,-a+y+x,x,y]
        square[i][j].append(data)
        square[i][j].append(rotation1)
        square[i][j].append(rotation2)
        square[i][j].append(rotation3)
def distance(p1,p2):
    return cmath.sqrt((p1[0]-p2[0])*(p1[0]-p2[0])+(p1[1]-p2[1])*(p1[1]-p2[1])).real
def check(array):
    p1=array[0][:2]
    p2=array[1][:2]
    p3=array[2][:2]
    p4=array[3][:2]
    d=[]
    d.append(distance(p1,p2))
    d.append(distance(p1,p3))
    d.append(distance(p1,p4))
    d.append(distance(p2,p3))
    d.append(distance(p2,p4))
    d.append(distance(p3,p4))
    d.sort()
    if d[0]==d[1] and d[1]==d[2] and d[2]==d[3] and d[3]!=d[4] and d[4]==d[5]:
        return 1
    else:
        return 0
    
for i in range(nooftest):
    array=[0,0,0,0]
    kanu=[]
    minimum=-1
    for j in range(4):
        array[0]=square[i][0][j]
        for k in range(4):
            array[1]=square[i][1][k]
            for l in range(4):
                array[2]=square[i][2][l]
                for m in range(4):
                    array[3]=square[i][3][m]
                    ans=check(array)
                    if(ans==1 and (minimum==-1 or minimum>j+k+l+m)):
                        minimum=j+k+l+m
                        kanu=array
    print minimum
