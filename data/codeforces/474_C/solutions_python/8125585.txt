import sys
n = int(sys.stdin.readline())

class Point: 
    def __init__(self, pos):
        self.x = pos[0] 
        self.y = pos[1] 
        self.a = pos[2]
        self.b = pos[3]

    def rotate(self, k):
        for i in xrange(k):
            x = self.x
            y = self.y
            self.x = self.a + self.b - y
            self.y = self.b - self.a + x

    def __repr__(self):
        return "(%d %d %d %d)" % (self.x, self.y, self.a, self.b)
    @staticmethod
    def dist(this, that):
        return (this.x-that.x)**2 + (this.y-that.y)**2

    @staticmethod
    def check(pos):
        (a, b, c, d) = pos
        lengths = sorted([Point.dist(p[0], p[1]) for p in [(a, b), (a, c), (a, d), (b, c), (b, d), (c, d)]])
        return lengths[0] == lengths[3] and lengths[4] == lengths[5] and lengths[0]!=0

s = [0]*4
all_rotate = []
def thu(i):
    if i==4:
        all_rotate.append(s[:])
        return
    for j in xrange(4):
        s[i] = j
        thu(i+1)
thu(0)
#p = Point([-2, 1,0,0])
#print p
#p.rotate(1)
#print p

for i in xrange(n):
    coords = [
        map(int, sys.stdin.readline().split()),
        map(int, sys.stdin.readline().split()),
        map(int, sys.stdin.readline().split()),
        map(int, sys.stdin.readline().split())
    ]
    min_rot = 16
    for rot in all_rotate:
        res = []
        for i in xrange(4):
            c = Point(coords[i])
            r = rot[i]
            c.rotate(r)
            
            res.append(c)
        #print rot, coords, res
        if Point.check(res) and sum(rot)<min_rot:
            min_rot = sum(rot)
            #print '<----'
    if min_rot<16:
        print min_rot
    else: 
        print -1
