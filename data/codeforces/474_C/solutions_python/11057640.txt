import sys

sys.setrecursionlimit(10 ** 6)

def pyes_no(condition) :
  if condition :
    print ("YES")
  else :
    print ("NO")

def plist(a, s = ' ') :
  print (s.join(map(str, a)))

def rint() :
  return int(sys.stdin.readline())

def rints() :
  return map(int, sys.stdin.readline().split())

def rfield(n, m = None) :
  if m == None :
    m = n
  
  field = []
  for i in xrange(n) :
    chars = sys.stdin.readline().strip()
    assert(len(chars) == m)
    field.append(chars)
  return field

def pfield(field, separator = '') :
  print ('\n'.join(map(lambda x: separator.join(x), field)))

def check_field_equal(field, i, j, value) :
  if i >= 0 and i < len(field) and j >= 0 and j < len(field[i]) :
    return value == field[i][j]
  return None 

def digits(x, p) :
  digits = []
  while x > 0 :
    digits.append(x % p)
    x //= p
  return digits

def modpower(a, n, mod) :
  r = a ** (n % 2)
  if n > 1 :
    r *= modpower(a, n // 2, mod) ** 2
  return r % mod

def gcd(a, b) :
  if a > b :
    a, b = b, a
  
  while a > 0 :
    a, b = b % a, a

  return b

def vector_distance(a, b) :
  diff = vector_diff(a, b)
  
  return scalar_product(diff, diff) ** 0.5

def vector_inverse(v) :
  r = [-x for x in v]

  return tuple(r)

def vector_diff(a, b) :
  return vector_sum(a, vector_inverse(b))

def vector_sum(a, b) :
  r = [c1 + c2 for c1, c2 in zip(a, b)]
    
  return tuple(r)

def scalar_product(a, b) :
  return sum([c1 * c2 for c1, c2 in zip(a, b)])

def check_rectangle(points) :
  assert(len(points) == 4)

  A, B, C, _ = points

  for A1, A2, A3 in [
    (A, B, C),
    (A, C, B),
    (C, A, B),
  ] :
    a1 = vector_diff(A1, A2)
    a2 = vector_diff(A2, A3)

    if scalar_product(a1, a2) == 0 :
       return True

  return False

def check_square(points) :
  if not check_rectangle(points) :
    return False
  A, B, C, D = points

  sides = {}
  
  for A1, A2 in [
    (A, B),
    (A, C),
    (A, D),
    (B, C),
    (B, D),
    (C, D),
  ] :
    sides[(A1[0] - A2[0]) ** 2 + (A1[1] - A2[1]) ** 2] = 1

  return len(sides) == 2

from itertools import product

def min_rotates(rotates) :
  return sum(rotates)

class memoize:
  def __init__(self, function):
    self.function = function
    self.memoized = {}

  def __call__(self, *args):
    try:
      return self.memoized[args]
    except KeyError:
      self.memoized[args] = self.function(*args)
      return self.memoized[args]

@memoize
def rotate90(P, O, count = 1) :
  OP = vector_diff(P, O)

  if count == 3 :
    OP_rotated = (OP[1], -OP[0])
  elif count == 2 :
    OP_rotated = (-OP[0], -OP[1])
  elif count == 1 :
    OP_rotated = (-OP[1], OP[0])
    
  P_rotated = vector_sum(O, OP_rotated)
  return P_rotated

def rotate(krots, nora, r) :
  new_krots = []
  for k, n, count in zip(krots, nora, r) :
    if count > 0 :
      new_krots.append(rotate90(k, n, count))
    else :
      new_krots.append(k)
  
  return new_krots 

n = rint()

rotations = list(product([0, 1, 2, 3], repeat = 4))
rotations.sort(key = min_rotates)

for polk in range(n) :
  krots = []
  nora = []
  
  for i in range(4) :
    x, y, a, b = rints()
    krots.append((x, y))
    nora.append((a, b))

  min_rotates_polk = -1
  for r in rotations :
    new_krots = rotate(krots, nora, r)
    if len(set(new_krots)) == 4 and check_square(new_krots) :
      min_rotates_polk = min_rotates(r)
      break

  print min_rotates_polk
