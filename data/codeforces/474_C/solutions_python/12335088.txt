from itertools   import *
from collections import *
from operator    import *
from bisect      import *
from fractions   import *

Ii = lambda: map(int, raw_input().split())
Is = lambda: raw_input().split()
ri = raw_input

def rotate_once(x,y,a,b):
  return (a-y+b,b+x-a)

def all_rotations(x,y,a,b):
  l = [(x,y)]
  l.append(rotate_once(l[-1][0],l[-1][1],a,b))
  l.append(rotate_once(l[-1][0],l[-1][1],a,b))
  l.append(rotate_once(l[-1][0],l[-1][1],a,b))
  return l

def is_square(corners):
  if len(set(corners))<4: return False
  distances = set()
  for p1,p2 in combinations(corners,2):
    distances.add((p1[0]-p2[0])**2+(p1[1]-p2[1])**2)
  return len(distances)==2

def solve(reg):
  best_cost = 100
  for i,p1 in enumerate(all_rotations(*reg[0])):
    for j,p2 in enumerate(all_rotations(*reg[1])):
      for k,p3 in enumerate(all_rotations(*reg[2])):
        for l,p4 in enumerate(all_rotations(*reg[3])):
          if is_square([p1,p2,p3,p4]):
            if i+j+k+l<best_cost:
              # print [p1,p2,p3,p4]
              best_cost = min(best_cost, i+j+k+l)
  return best_cost if best_cost < 100 else -1

n = input()
for _ in xrange(n):
  reg = [Ii() for _ in xrange(4)]
  print solve(reg)