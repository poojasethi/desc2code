#include <cstdio>
#include <string>
#include <vector>
#include <algorithm>
#include <cmath>
#include <memory.h>
#include <set>
#include <map>
#include <queue>
#include <stack>

using namespace std;

#define p_len 4
const int p = 10000;
#define MAXL 1000/p_len

struct BigInteger
{
    int len;
    int dig[MAXL];

    BigInteger(int n = 0)
    {
        for (len = 0; n > 0; n /= p)
        {
            dig[len++] = n % p;
        }
    }

    bool read()
    {
        char s[p_len * MAXL];
        if (scanf("%s", &s) == -1)
        {
            return false;
        }

        int i, n = strlen(s), cur = 0, p = 1;
        len = 0;
        for (int i = 0; i < n; i++)
        {
            cur += (s[n-i-1]-'0') * p;
            p *= 10;
            if ((i + 1) % p_len == 0)
            {
                dig[len++] = cur;
                cur = 0;
                p = 1;
            }
        }

        if (cur > 0)
        {
            dig[len++] = cur;
        }

        return true;
    }

    void print() const
    {
        if (len == 0)
        {
            printf("0");
        }
        else
        {
            int i = len - 1;
            printf("%d", dig[i]);
            char s[10];
            sprintf(s, "%%0%dd", p_len);
            for (i--; i >= 0; i--)
            {
                printf(s, dig[i]);
            }
        }

        printf("\n");
    }

    BigInteger operator+ (const BigInteger &b) const
    {
        BigInteger s;
        int i, d = 0;
        int maxlen = len > b.len ? len : b.len;
        for (i = 0; i < maxlen; i++)
        {
            if (i < len)
            {
                d += dig[i];
            }

            if (i < b.len)
            {
                d += b.dig[i];
            }

            s.dig[i] = d % p;
            d /= p;
        }

        if (d > 0)
        {
            s.dig[i++] = d;
        }

        s.len = i;
        return s;
    }

    BigInteger operator* (const int b) const
    {
        BigInteger prod(0);
        if (b == 0)
        {
            return 0;
        }

        int i, d = 0;
        for (i = 0; i < len; i++)
        {
            d += dig[i] * b;
            prod.dig[i] = d % p;
            d /= p;
        }

        if (d > 0)
        {
            prod.dig[i++] = d;
        }

        prod.len = i;
        return prod;
    }

    bool operator== (const BigInteger &b) const
    {
        if (len != b.len)
        {
            return false;
        }

        for (int i = 0; i < len; i++)
        {
            if (dig[i] != b.dig[i])
            {
                return false;
            }
        }

        return true;
    }

};

#define N 666
BigInteger p12[N];

int main(void)
{
    p12[0] = BigInteger(1);
    for (int i = 1; i < N; i++)
        p12[i] = p12[i-1] * 12;

    BigInteger a;
    if (a.read())
    {
        bool found = false;
        int i,j,k;
        for (i = 0; i < N && !found; i++)
            for (j = 0; j <=i && !found; j++)
            {
                if (p12[i] + p12[j] == a)
                {
                    found = true;
                }
            }

        if (!found)
        {
            printf("NO\n");
            return 0;
        }

        i--, j--;
        printf("YES\n");
        printf("1\n%d\n", i + j + 1);
        printf("%d\n", (i + j) / 2);
        for (k = (i + j) / 2; k >= 0; k--)
        {
            if (k != i && k != j)
            {
                (p12[k] + p12[i + j - k]).print();
            }
        }
    }
    return 0;
}