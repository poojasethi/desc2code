#include <bits/stdc++.h>

#define	st first
#define	nd second
#define	mp make_pair
#define	pb push_back
#define	lli long long int
#define	all( gg )	gg.begin(),gg.end()
#define	foreach( gg,itit )	for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )
#define	FP( ii,aa,bb ) for( lli ii=aa;ii<=bb;ii++ )
#define	FM( ii,aa,bb ) for( lli ii=aa;ii>=bb;ii-- )
#define	debug(ccc)	cout << #ccc << " = " << ccc << endl;

#define	mod	1000000007LL

#define	nu( xx,yy )	( ((xx)-1)*n+(yy) )
#define	getx( xx )	( 1+(xx>n) )
#define	gety( xx )	( ((xx)-1)%n+1 )

using namespace std;

int	n,q;
char	arr[4][300000];

vector<int>	v[600000];

vector< pair< pair<int,int>,int > >	S[3][300000];

int	result[300000];

int	dp[2][700000];
queue< pair<int,int> >	Q;

void	solve( int bas,int son ){
	if( bas==son )	return;
	int	orta = (bas+son)/2;
	solve( bas,orta );
	solve( orta+1,son );
	FP( i,1,2 )
		FP( j,bas,son )
			dp[0][nu(i,j)] = dp[1][nu(i,j)] = mod;
	if( arr[1][orta]=='.' )	Q.push( mp( nu(1,orta),0 ) ),dp[0][nu(1,orta)] = 0;
	while( Q.size() ){
		int	x = Q.front().st;
		int	c = Q.front().nd;
		Q.pop();
		foreach( v[x],it )
			if( bas<=gety(*it) and gety(*it)<=son and dp[0][*it]==mod ){
				dp[0][*it] = c+1;
				Q.push( mp( *it,c+1 ) );
			}
	}
	if( arr[2][orta]=='.' )	Q.push( mp( nu(2,orta),0 ) ),dp[1][nu(2,orta)] = 0;
	while( Q.size() ){
		int	x = Q.front().st;
		int	c = Q.front().nd;
		Q.pop();
		foreach( v[x],it )
			if( bas<=gety(*it) and gety(*it)<=son and dp[1][*it]==mod ){
				dp[1][*it] = c+1;
				Q.push( mp( *it,c+1 ) );
			}
	}
	FP( i,1,2 )
		FP( j,bas,orta )
			foreach( S[i][j],it )
				if( it->st.st<=son )
					result[ it->nd ] = min( result[it->nd],min( dp[0][nu(i,j)]+dp[0][nu(it->st.nd,it->st.st)],dp[1][nu(i,j)]+dp[1][nu(it->st.nd,it->st.st)] ) );
}

int main(){
	cin >> n >> q;
	cin >> arr[1]+1 >> arr[2]+1;
	FP( i,1,2 )
		FP( j,1,n )
			FP( a,-1,1 )
				FP( b,-1,1 )
					if( (a==0)!=(b==0) and arr[i+a][j+b]=='.' ){
						v[ nu( i,j ) ].pb( nu( i+a,j+b ) );
					}
	FP( i,1,q )	result[i] = mod;
	FP( i,1,q ){
		int	x,y;
		cin >> x >> y;
		if( gety( x )==gety( y ) ){
			result[i] = (x!=y);
			continue;
		}
		if( gety( x )>gety( y ) )	swap( x,y );
		S[getx(x)][gety(x)].pb( mp( mp( gety(y),getx(y) ),i ) );
	}
	solve( 1,n );
	FP( i,1,q ){
		if( result[i]==mod )	result[i] = -1;
		cout << result[i] << endl;
	}
}
