#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

using namespace std;

typedef pair<int, int> PP;
typedef long long LL;
#define pb push_back
#define fr first
#define sc second

string s[2]; 
int p[200010], n, m;
int l[200010], r[200010], lx[200010], rx[200010], d[200010];
set<int> b;

int find(int* lst, int x){
	return lst[x] == x ? x : lst[x] = find(lst, lst[x]); 
}

int pos(int x){
	return x >= n ? x - n : x;
}
int main() {
	#ifdef _TEST_
	freopen("input.txt", "r", stdin);
	//freopen("out.txt", "w", stdout);
	#endif
	cin >> n >> m >> s[0] >> s[1];
	for (int i = 0; i < n; i ++) p[i] = (s[1][i] == '.') * 2 + (s[0][i] == '.');
	for (int i = 0; i < n; ) {
		int t = i;
		while (t < n && p[i] == p[t]) t ++;
		if (p[i] == 3) l[i] = r[t - 1] = 1;
		i = t;
	}
	int lp = 0, rp = 0;
	while (lp < n && rp < n) {
		while (lp < n && l[lp] == 0) lp ++;
		while (rp < n && r[rp] == 0) rp ++;
		if (lp >= n || rp >= n) continue;
		if (lp > 0 && rp < n - 1)
			if (p[lp - 1] == p[rp + 1] && (p[lp - 1] == 2 || p[lp - 1] == 1)) l[lp] = r[rp] = 0;
		lp ++; rp ++;
	}
	for (int i = 0; i < n; i ++) lx[i] = rx[i] = i;
	for (int i = 0; i < n - 1; i ++) {
		if (p[i] == p[i + 1] && p[i] == 3) {
			lx[i + 1] = i;
			rx[i] = i + 1;
		}
		if ((p[i] & p[i + 1]) == 0) b.insert(i); b.insert(n);
	}
	for (int i = 1; i < n; i ++) l[i] += l[i - 1];
	for (int i = 0; i < m; i ++) {
		int u, v; cin >> u >> v; u --; v --;
		if (pos(u) > pos(v)) swap(u, v);
		if (b.lower_bound(pos(u)) != b.lower_bound(pos(v))) {
			cout << - 1 << endl; continue;
		}
		if (p[pos(u)] == p[pos(v)] && p[pos(u)] == 3 && find(lx, pos(u)) == find(lx, pos(v))) {
			cout << pos(v) - pos(u) + ((u < n) ^ (v < n))<< endl; continue;
		}
		int tu, tv;
		int dt = 0;
		if (p[pos(u)] == 3) tu = 1 + find(rx, pos(u)), dt += (u < n) ^ (p[tu] == 1);
		else tu = pos(u);
		if (p[pos(v)] == 3) tv = find(lx, pos(v)) - 1, dt += (v < n) ^ (p[tv] == 1);
		else tv = pos(v);
		cout << pos(v) - pos(u) + dt + l[tv] - l[tu] << endl;;
	}
	return 0;
}
