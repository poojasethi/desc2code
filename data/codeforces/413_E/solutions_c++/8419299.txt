#include<bits/stdc++.h>
using namespace std;
#define re(i,A) for(int i=0;i<(int)A;i++)
#define mn 200011
#define ls (cur<<1)
#define rs (cur<<1|1)
template<class T>inline void R(T &xx){xx=0;char ch=getchar();bool F=0;while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();if(ch=='-')F=1,ch=getchar();while(ch>='0'&&ch<='9')xx=xx+xx+(xx<<3)+ch-48,ch=getchar();if(F)xx=-xx;}

char a[2][mn];int n,q;
struct nod{int a[2][2];nod(){a[0][0]=a[0][1]=a[1][0]=a[1][1]=1<<29;}}seg[mn<<3];
inline nod merge(nod a,nod b){
    nod c;
    re(i,2)re(j,2)re(k,2)
        c.a[i][j]=min(c.a[i][j],a.a[i][k]+b.a[k][j]+1);
    return c;
}
void build(int cur,int l,int r){
    if(l==r){
        re(i,2)re(j,2)if(a[i][l]=='.'&&a[j][l]=='.')
            seg[cur].a[i][j]=abs(i-j);
        return;
    }
    int mid=l+r>>1;
    build(ls,l,mid);build(rs,mid+1,r);
    seg[cur]=merge(seg[ls],seg[rs]);
}
nod que(int cur,int l,int r,int L,int R){
    if(l>=L&&r<=R)return seg[cur];
    int mid=l+r>>1;
    if(R<=mid)return que(ls,l,mid,L,R);
    if(L>mid)return que(rs,mid+1,r,L,R);
    return merge(que(ls,l,mid,L,mid),que(rs,mid+1,r,mid+1,R));
}
int main(){
    R(n);R(q); scanf("%s%s",a[0]+1,a[1]+1);
    build(1,1,n);
    for(int x,y,x1,y1,x2,y2;q--;){
        R(x);R(y);
        if(x>n)x1=1,y1=x-n;else x1=0,y1=x;
        if(y>n)x2=1,y2=y-n;else x2=0,y2=y;
        if(y1>y2)swap(x1,x2),swap(y1,y2);
        nod ans=que(1,1,n,y1,y2);
        printf("%d\n",(ans.a[x1][x2]>(n<<1))?-1:ans.a[x1][x2]);
    }
    return 0;
}