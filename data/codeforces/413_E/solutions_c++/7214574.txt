#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define INF (0x3f3f3f3f)
#define MID(l,r) (((l)+(r))>>1)
#define L(x) ((x)<<1)
#define R(x) (((x)<<1)+1)
using namespace std;
struct {int l,r,d[2][2];} tr[1000005];
int n,m,g[200005][2];
struct rec
{
    int d[2][2];
    rec(int _d[2][2])
    {
        for(int i=0;i<2;++i)
            for(int j=0;j<2;++j) d[i][j]=_d[i][j];
    }
    rec() {memset(d,0x3f,sizeof(d));}
};
void update(int x)
{
    if(tr[x].l==tr[x].r) return; int m=MID(tr[x].l,tr[x].r);
    for(int i=0;i<2;++i)
        for(int j=0;j<2;++j)
            for(int k=0;k<2;++k)
                if(g[m][k]&&g[m+1][k])
                    tr[x].d[i][j]=min(tr[x].d[i][j],tr[L(x)].d[i][k]+tr[R(x)].d[k][j]+1);
}
void build(int x,int l,int r)
{
    tr[x].l=l; tr[x].r=r;
    if(l==r)
        for(int i=0;i<2;++i)
            for(int j=0;j<2;++j) tr[x].d[i][j]=(g[l][i]&&g[l][j]?abs(i-j):INF);
    else
    {
        memset(tr[x].d,0x3f,sizeof(tr[x].d));
        build(L(x),l,MID(l,r)); build(R(x),MID(l,r)+1,r);
        update(x);
    }
}
rec query(int x,int l,int r)
{
    if(tr[x].l==l&&tr[x].r==r) return rec(tr[x].d);
    if(r<=MID(tr[x].l,tr[x].r)) return query(L(x),l,r);
    if(l>MID(tr[x].l,tr[x].r)) return query(R(x),l,r);
    rec s,a,b; int m=MID(tr[x].l,tr[x].r);
    a=query(L(x),l,m); b=query(R(x),m+1,r);
    for(int i=0;i<2;++i)
        for(int j=0;j<2;++j)
            for(int k=0;k<2;++k) if(g[m][k]&&g[m+1][k])
                s.d[i][j]=min(s.d[i][j],a.d[i][k]+b.d[k][j]+1);
    return s;
}
int main()
{
    scanf("%d%d",&n,&m); int x,y;
    for(int i=0;i<2;++i)
    {
        scanf("\n"); char c;
        for(int j=0;j<n;++j) {scanf("%c",&c); g[j][i]=(c=='.');}
    }
    build(1,0,n-1);
    while(m--)
    {
        scanf("%d%d",&x,&y); int z; --x; --y;
        if(x%n>y%n) swap(x,y);
        z=query(1,x%n,y%n).d[x>=n][y>=n];
        printf("%d\n",z==INF?-1:z);
    }
    return 0;
}
