#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#define EPS 1e-8
using namespace std;

struct vect{
	double x, y;
	vect(){}
	vect(double x, double y) : x(x), y(y){}
	vect operator + (vect const &T) const{return vect(x+T.x, y+T.y); }
	vect operator - (vect const &T) const{return vect(x-T.x, y-T.y); }
	vect operator * (double const &t) const{return vect(x*t, y*t); }
	double len(){return sqrt(x*x + y*y); }
};


struct vect3D{
	double x, y, z;
	vect3D(){}
	vect3D(double x, double y, double z) : x(x), y(y), z(z){};
	vect3D operator + (vect3D const &T) const{return vect3D(x+T.x, y+T.y, z+T.z); }
	vect3D operator - (vect3D const &T) const{return vect3D(x-T.x, y-T.y, z-T.z); }
	vect3D operator * (double const &t) const{return vect3D(x*t, y*t, z*t); }
	double operator % (vect3D const &T) const{return x*T.x + y*T.y + z*T.z; }
	vect3D operator ^ (vect3D const &T) const{return vect3D(y*T.z-z*T.y, z*T.x-x*T.z, x*T.y-y*T.x); }
	double len(){return sqrt(x*x + y*y + z*z); }
};

double CircumCenter(vect A, vect B, vect C, vect &P){
	double a1 = B.x-A.x, b1 = B.y-A.y, c1 = (a1*a1+b1*b1)/2;
	double a2 = C.x-A.x, b2 = C.y-A.y, c2 = (a2*a2+b2*b2)/2;
	double d = a1*b2-a2*b1;
	P.x = A.x + (c1*b2-c2*b1)/d;
	P.y = A.y + (a1*c2-a2*c1)/d;
	return (P-A).len();
}


double SBCircle(int n, int a, int b, int c, vect p[], vect &P){
	double r;
	vect cen;

	if (n < 0 || c != -1){
		if (a == -1) cen = vect(0, 0), r = 0;
		else if (b == -1) cen = p[a], r = 0;
		else if (c == -1) cen = (p[a] + p[b]) * .5, r = (p[b] - p[a]).len() / 2.;
		else r = CircumCenter(p[a], p[b], p[c], cen);
		P = cen;
		return r;
	}

	r = SBCircle(n-1, a, b, c, p, cen);
	if ((p[n]-cen).len() > r + EPS){
		if (a < 0) r = SBCircle(n-1, n, b, c, p, cen);
		else if (b < 0) r = SBCircle(n-1, a, n, c, p, cen);
		else r = SBCircle(n-1, a, b, n, p, cen);
	}
	P = cen;
	return r;
}

int n, m;
double px, py, pz;
vect3D p[1000], v0, v1, v2, vx, vy, vz, norm;
vect a[1000], P;


int main(){
	scanf("%d%d", &n, &m);
	for (int i=0; i<n; i++) scanf("%lf%lf%lf", &p[i].x, &p[i].y, &p[i].z);
	while (m--){
		scanf("%lf%lf%lf", &px, &py, &pz);
		
		v0 = vect3D(0., 0., 0.);
		if (fabs(px) > EPS){
			v1 = vect3D(-py/px, 1., 0.);
			v2 = vect3D(-pz/px, 0., 1.);
		}
		else if (fabs(py) > EPS){
			v1 = vect3D(1., -px/py, 0.);
			v2 = vect3D(0., -pz/py, 1.);
		}
		else if (fabs(pz) > EPS){
			v1 = vect3D(1., 0., -px/pz);
			v2 = vect3D(0., 1., -py/pz);
		}
		
		norm = (v2-v0) ^ (v1-v0);
		vx = v1 - v0;
		vz = norm;
		vy = vx ^ vz;
		vx = vx * (1. / vx.len());
		vy = vy * (1. / vy.len());
		
		for (int i=0; i<n; i++) a[i] = vect(p[i] % vx, p[i] % vy);
		for (int i=0; i<n; i++){
			int x, y;
			x = rand()%n;
			y = rand()%n;
			swap(a[x], a[y]);
		}
		printf("%.9f\n", SBCircle(n-1, -1, -1, -1, a, P));
	}
	return 0;
}



