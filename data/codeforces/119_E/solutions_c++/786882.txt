// #includes {{{
#include <algorithm>
#include <numeric>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <queue>
#include <deque>
#include <stack>
#include <set>
#include <map>
#include <cstdio>
#include <cstdlib>
#include <cctype>
#include <cassert>
#include <cstring>
#include <cmath>
#include <complex>
#include <functional>
using namespace std;
// }}}
// pre-written code {{{
#define REP(i,n) for(int i=0;i<(int)(n);++i)
#define RREP(i,a,b) for(int i=(int)(a);i<(int)(b);++i)
#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)
#define IFOR(i,it,c) for(__typeof((c).begin())it=(c).begin();it!=(c).end();++it,++i)
#define ALL(c) (c).begin(), (c).end()
#define MP make_pair
#define PB push_back
#define CLEAR(c,d) memset((c),(d),sizeof(c))
#define TO_STRING(VariableName) # VariableName
#define OUT(c) cout<<TO_STRING(c)<<"="<<(c)<<endl

typedef long long Int;
typedef unsigned long long uInt;
typedef long long ll;
typedef long double ld;

typedef pair<int,int> pii;

void rint(int &r){scanf("%d",&r);}
void rInt(Int &r){scanf("%lld",&r);}
void ruint(unsigned int &r){scanf("%u",&r);}
void ruInt(uInt &r){scanf("%llu",&r);}
typedef double number;

// }}}

const int N=1000, M=110;
int n,m;

int x[N],y[N],z[N];
number a,b,c;

number xx[N],yy[N];

//{{{ geometry components

typedef double number;
const number EPS = 1e-12;
typedef complex<number> P;
namespace std {
	bool operator < (const P& a, const P& b) {
		return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);
	}
}

//}}}

vector<P> v;

number calc(number x,number y){
	number ret=-1.0;
	REP(i,n)ret=max(ret,(xx[i]-x)*(xx[i]-x)+(yy[i]-y)*(yy[i]-y));
//	cout<<p<<" "<<ret<<endl;
	return ret;
}

const number INF=1.8e+4;

//{{{

number ternaryY(number x){
	number left=-INF,right=INF;
	while(right-left>EPS){
//		cout<<left<<" "<<right<<endl;
		number leftThird=left+(right-left)*0.45;
		number rightThird=left+(right-left)*0.55;
		
		number rLeft=calc(x,leftThird);
		number rRight=calc(x,rightThird);
		
		if(rLeft > rRight)
			left=leftThird;
		else
			right=rightThird;
	}
//	cout<<x<<" "<<(left+right)/2<<endl;
	return (left+right)*0.5;
}

number largestCoveringCircle(){
	number left=-INF,right=INF;
	while(right-left>EPS){
//				cout<<left<<" "<<right<<endl;
		number leftThird=left+(right-left)*0.45;
		number rightThird=left+(right-left)*0.55;

		number rLeft=calc(leftThird,ternaryY(leftThird));
		number rRight=calc(rightThird,ternaryY(rightThird));
//		cout<<rLeft<<" "<<rRight<<endl;

		if(rLeft>rRight)
			left=leftThird;
		else
			right=rightThird;
	}
	number x=(left+right)*0.5;
	number y=ternaryY(x);
	return calc(x,y);
}
//}}}

const double phi=(1+sqrt(5))/2;
const double resphi=(double)2-phi;

//{{{
double goldenSectionSearchY(const double X){
	double a=-INF,b=INF, c=(phi*a+b)/(phi+1.0);
	double fb=calc(X,b);
	for(;;){
		if(abs(c-a)<EPS*(abs(b)+abs(c)))break;
		double x;
		if(c-b>b-a)x=b+resphi*(c-b);
		else x=b-resphi*(b-a);
//		cout<<a<<" "<<b<<" "<<c<<" "<<x<<endl;
		double fx=calc(X,x);
		if(fx<fb){
			if(c-b>b-a)a=b,b=x;
			else c=b,b=x;
			fb=fx;
		}else{
			if(c-b>b-a)c=x;
			else a=x;
		}
	}
	return (c+a)/2;
}

double goldenSectionSearch(){
	double a=-INF,b=INF, c=(phi*a+b)/(phi+1.0);
	double gb=goldenSectionSearchY(b),fb=calc(b,gb);
	for(;;){
		if(abs(c-a)<EPS*(abs(b)+abs(c)))break;
		double x;
		if(c-b>b-a)x=b+resphi*(c-b);
		else x=b-resphi*(b-a);
//		cout<<a<<" "<<b<<" "<<c<<" "<<x<<endl;
		double gx=goldenSectionSearchY(x),fx=calc(x,gx);
		if(fx<fb){
			if(c-b>b-a)a=b,b=x;
			else c=b,b=x;
			fb=fx;
		}else{
			if(c-b>b-a)c=x;
			else a=x;
		}
	}
	double x=(c+a)/2;
//	cout<<x<<endl;
	double y=goldenSectionSearchY(x);
	return calc(x,y);
}

//}}}

void main2();

int main(){
	rint(n);rint(m);
	REP(i,n){
		rint(x[i]);
		rint(y[i]);
		rint(z[i]);
	}
	REP(i,m)main2();
	return 0;
}

void main2(){
	scanf("%lf%lf%lf",&a,&b,&c);
	number d=sqrt(a*a+b*b+c*c);
	a/=d;b/=d;c/=d;
	number x1,y1,z1,x2,y2,z2;
	if(abs(c)<EPS){
		x1=b;y1=-a;z1=0;
	}else{
		x1=c;y1=0;z1=-a;
	}
	vector<P> v;
	x2=y1*c-z1*b;y2=z1*a-x1*c;z2=x1*b-y1*a;
	number d1=sqrt(x1*x1+y1*y1+z1*z1),d2=sqrt(x2*x2+y2*y2+z2*z2);
	x1/=d1;y1/=d1;z1/=d1;x2/=d2;y2/=d2;z2/=d2;
	REP(i,n){
		xx[i]=x1*x[i]+y1*y[i]+z1*z[i];
		yy[i]=x2*x[i]+y2*y[i]+z2*z[i];
		//		cout<<xx[i]<<" "<<yy[i]<<endl;
	}
	if(n==1){
		printf("%.10lf\n",0.0);
		return;
	}
	/*
		for(number x=-10.0;x<10.0;x+=0.1){
		number y=ternaryY(x,v);
		cout<<x<<": "<<y<<" "<<calc(P(x,y),v)<<endl;
		}
		assert(false);
		*/
	//	return;
//	number c=largestCoveringCircle();
	number c=goldenSectionSearch();
	printf("%.10lf\n",sqrt(c));
	return;
}
