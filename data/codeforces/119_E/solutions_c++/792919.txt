#include <stdio.h>
#include <math.h>
#include <stdlib.h>

#define EPS 1E-8
#define MAXNUM 10005

namespace B{
    const double eps=1e-8;
    inline bool iszero(double x) { return fabs(x)<eps; }

    template <class T> void swap(T &a,T &b) {
        T t=a; a=b; b=t;
    }

    class Coor {
        public:
            double x,y;
            Coor() {}
            Coor(double xi,double yi) { x=xi; y=yi; }
            Coor& operator+=(const Coor &b) { x+=b.x; y+=b.y; return *this; }
            const Coor operator+(const Coor &b) const { return (Coor)*this+=b; }
            Coor& operator-=(const Coor &b) { x-=b.x; y-=b.y; return *this; }
            const Coor operator-(const Coor &b) const { return (Coor)*this-=b; }
            Coor& operator*=(const double b) { x*=b; y*=b; return *this; }
            const Coor operator*(const double b) const { return (Coor)*this*=b; }
            Coor& operator/=(const double b) { x/=b; y/=b; return *this; }
            const Coor operator/(const double b) const { return (Coor)*this/=b; }
            const double len2() const { return x*x+y*y; }
            const double len() const { return sqrt(len2()); }
    };

    class Circle {
        public:
            Coor o;
            double r;
            Circle() {}
            Circle(Coor oi,double ri) { o=oi, r=ri; }
            bool inside(Coor p) {
                return (p-o).len2()<=r*r+eps;
            }
    };

    int n;
    Coor p[MAXNUM];

    inline double dot(Coor a,Coor b) { return a.x*b.x+a.y*b.y; }
    inline double dot(Coor o,Coor a,Coor b) { return dot(a-o,b-o); }
    inline double cross(Coor a,Coor b) { return a.x*b.y-a.y*b.x; }
    inline double cross(Coor o,Coor a,Coor b) { return cross(a-o,b-o); }

    const Circle circumcircle(Coor a,Coor b,Coor c)
    {
        Circle cir;
        double fa,fb,fc,fd,fe,ff,dx,dy,dd;
        if(iszero(cross(a,b,c))) {
            if(dot(a,b,c)<=0) return Circle((b+c)/2,(b-c).len()/2);
            if(dot(b,c,a)<=0) return Circle((c+a)/2,(c-a).len()/2);
            if(dot(c,a,b)<=0) return Circle((a+b)/2,(a-b).len()/2);
        } else {
            fa=2*(a.x-b.x);
            fb=2*(a.y-b.y);
            fc=a.len2()-b.len2();
            fd=2*(a.x-c.x);
            fe=2*(a.y-c.y);
            ff=a.len2()-c.len2();
            dx=fc*fe-ff*fb;
            dy=fa*ff-fd*fc;
            dd=fa*fe-fd*fb;
            cir.o=Coor(dx/dd,dy/dd);
            cir.r=(a-cir.o).len();
            return cir;
        }
    }

    inline Circle mec(int fixed,int num)
    {
        int i;
        Circle cir;
        if(fixed==3) return circumcircle(p[0],p[1],p[2]);
        cir=circumcircle(p[0],p[0],p[1]);
        for(i=fixed;i<num;i++) {
            if(cir.inside(p[i])) continue;
            swap(p[i],p[fixed]);
            cir=mec(fixed+1,i+1);
        }
        return cir;
    }

    inline int bigrand() {
        return (rand()<<15)+rand();
    }
    inline void scramble() {
        int i;
        for(i=0;i<n/2;i++)
            swap(p[rand()%n],p[rand()%n]);
    }

    inline double min_radius() {
        if(n<=1) return 0.0;
        if(n==2) return (p[0]-p[1]).len()/2;
        scramble();
        return mec(0,n).r;
    }

};

inline int SG(double x){
    if(x>-EPS && x<EPS) return 0;
    return x>0?1:-1;
}

class PT3{ public:
    double x,y,z;
    PT3(){}
    PT3(double _x,double _y,double _z){
        x=_x; y=_y; z=_z;
    }
    void input(){
        scanf("%lf %lf %lf",&x,&y,&z);
    }
    PT3 operator^(const PT3& p) const{
        return PT3(y*p.z-z*p.y,z*p.x-x*p.z,x*p.y-y*p.x);
    }
    void nrom(){
        double d=sqrt(x*x+y*y+z*z);
        x/=d; y/=d; z/=d;
    }
};

PT3 pt3[1000];

int main(){
    int n,m,i,j,mm;
    PT3 p,a,b;
    scanf("%d %d",&n,&m);
    for(i=0;i<n;i++){
        pt3[i].input();
    }
    for(mm=0;mm<m;mm++){
        p.input();
        if(SG(p.y)==0){
            a=PT3(0,1,0);
        }else{
            a=PT3(0,p.z,-p.y);
        }
        b=(p^a);
        a.nrom();
        b.nrom();
        for(i=0;i<n;i++){
            B::p[i].x=a.x*pt3[i].x+a.y*pt3[i].y+a.z*pt3[i].z;
            B::p[i].y=b.x*pt3[i].x+b.y*pt3[i].y+b.z*pt3[i].z;
        }
        B::n=n;
        printf("%.8f\n",B::min_radius());
    }
    return 0;
}

