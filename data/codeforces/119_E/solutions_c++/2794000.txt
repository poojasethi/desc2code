#include<stdio.h>
#include<string.h>
#include<math.h>
#include<stdlib.h>
#include<time.h>
#include<iostream>
#include<algorithm>
#include<vector>
#include<set>
#include<map>
using namespace std;
#define X first
#define Y second
#define mp make_pair
#define pb push_back
#define eps 1e-8
#define inf 1e20
#define pi acos(-1.0)
#define maxn 1000010
#define mod 1000000007
int L;
struct mat
{
    double m[10][10];
    mat(){}
    mat operator *(mat b)
    {
        mat c;
        for(int i=0;i<L;i++)
            for(int j=0;j<L;j++)
                c.m[i][j]=0;
        for(int i=0;i<L;i++)
            for(int k=0;k<L;k++)
                if(m[i][k] != 0)
                {
                    for(int j=0;j<L;j++)
                        c.m[i][j]=c.m[i][j]+m[i][k]*b.m[k][j];
                }
        return c;
    }
}I;
int Sig(double a)
{
    return a<-eps?-1:(a>eps);
}
struct Tpoint
{
    double x,y,z;
    Tpoint(){}
    Tpoint(double x0,double y0,double z0):x(x0),y(y0),z(z0){}
    void in()
    {
        scanf("%lf%lf%lf",&x,&y,&z);
    }
    void out()
    {
        printf("%.4f %.4f %.4f\n",x,y,z);
    }
    Tpoint operator *(double h){
        return Tpoint(x*h,y*h,z*h);
    }
    Tpoint operator /(double h){
        return Tpoint(x/h,y/h,z/h);
    }
    double operator ^(Tpoint h){ //点乘
        return x*h.x+y*h.y+z*h.z;
    }
    Tpoint operator +(Tpoint h){
        return Tpoint(x+h.x,y+h.y,z+h.z);
    }
    Tpoint operator -(Tpoint h){
        return Tpoint(x-h.x,y-h.y,z-h.z);
    }
    Tpoint operator *(Tpoint b){ //叉乘
        return Tpoint(y*b.z-b.y*z, z*b.x-b.z*x, x*b.y-b.x*y);
    }
    double len()const{
        return sqrt(x*x+y*y+z*z);
    }
    Tpoint turnlen(double l)const {  //改变长度
        double r=l/len();
        return Tpoint(x*r,y*r,z*r);
    }
}p3[10010];
double dis(Tpoint a,Tpoint b)
{
    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
mat Get_mat(double x,double y,double z,double c,double s)
{
    mat A;
    double k=sqrt(x*x+y*y+z*z);
    x/=k;
    y/=k;
    z/=k;
    double xy,xz,yz,xx,yy,zz;
    xy=x*y;
    yz=y*z;
    xz=x*z;
    xx=x*x;
    yy=y*y;
    zz=z*z;

    A.m[0][0]=xx+(1-xx)*c;
    A.m[0][1]=xy*(1-c)-z*s;
    A.m[0][2]=xz*(1-c)+y*s;
    A.m[1][0]=xy*(1-c)+z*s;
    A.m[1][1]=yy+(1-yy)*c;
    A.m[1][2]=yz*(1-c)-x*s;
    A.m[2][0]=xz*(1-c)-y*s;
    A.m[2][1]=yz*(1-c)+x*s;
    A.m[2][2]=zz+(1-zz)*c;
    return A;
}
mat make_mat(double a,double b,double c,double d,double &add)
{
    mat A,B,C;
    add=d/sqrt(a*a+b*b+c*c);
    double x,y;
    if(a == 0 && b == 0)
        A=I;
    else
    {
        x=a;
        y=b;
        A=Get_mat(0,0,1,y/sqrt(x*x+y*y),x/sqrt(x*x+y*y));
    }
    x=sqrt(a*a+b*b);
    y=c;
    B=Get_mat(1,0,0,y/sqrt(x*x+y*y),x/sqrt(x*x+y*y));
    return B*A;
}
void rotate_to_plane(Tpoint p[],int n,double a,double b,double c,double d)
{
    double add;
    mat C=make_mat(a,b,c,d,add);
    for(int i=0;i<n;i++)
    {
        double x=p[i].x;
        double y=p[i].y;
        double z=p[i].z;
        p[i].x=C.m[0][0]*x+C.m[0][1]*y+C.m[0][2]*z;
        p[i].y=C.m[1][0]*x+C.m[1][1]*y+C.m[1][2]*z;
        p[i].z=C.m[2][0]*x+C.m[2][1]*y+C.m[2][2]*z;
        p[i].z-=add;
    }
}
Tpoint CircleCenter(Tpoint p0, Tpoint p1, Tpoint p2)
{
    double a1=p1.x-p0.x , b1=p1.y-p0.y , c1=(a1*a1+b1*b1) / 2 ;
    double a2=p2.x-p0.x , b2=p2.y-p0.y , c2=(a2*a2+b2*b2) / 2 ;
    double d = a1*b2 - a2*b1 ;
    Tpoint cp;
    cp.x = p0.x + ( c1*b2 - c2*b1 ) / d ;
    cp.y = p0.y + ( a1*c2 - a2*c1 ) / d ;
    return cp;

}
Tpoint Min_Cover_Circle(Tpoint p[],int n,double &r)//p是要覆盖的点集，n是个数，返回圆心，r是半径
{
   random_shuffle(p,p+n);
   Tpoint o=p[0];
   r=0;
   for(int i=1;i<n;i++)
   {
       if(Sig(dis(p[i],o)-r) <= 0)
           continue;
       o=p[i];
       r=0;
       for(int j=0;j<i;j++)
       {
           if(Sig(dis(p[j],o)-r) <= 0)
               continue;
           o.x=(p[i].x+p[j].x)/2;
           o.y=(p[i].y+p[j].y)/2;
           r=dis(o,p[j]);
           for(int k=0;k<j;k++)
           {
               if(Sig(dis(p[k],o)-r) <= 0)
                   continue;
               o=CircleCenter(p[i],p[j],p[k]);
               r=dis(o,p[k]);
           }
       }
   }
   return o;
}
Tpoint p[1010];
Tpoint mark[1010];
int main()
{
    srand(time(NULL));
    L=3;
    for(int i=0;i<3;i++)
        for(int j=0;j<3;j++)
        {
            if(i == j)
                I.m[i][j]=1;
            else
                I.m[i][j]=0;
        }
    int n,Q;
    scanf("%d %d",&n,&Q);
    for(int i=0;i<n;i++)
        p[i].in();
    for(int i=0;i<n;i++)
        mark[i]=p[i];
    while(Q--)
    {
        double a,b,c;
        scanf("%lf %lf %lf",&a,&b,&c);
        for(int i=0;i<n;i++)
            p[i]=mark[i];
        rotate_to_plane(p,n,a,b,c,0);
        double ans;
        Tpoint o=Min_Cover_Circle(p,n,ans);
        printf("%.12f\n",ans);
    }
    return 0;
}
