#include <algorithm>
#include <iostream>
#include <utility>
#include <cstring>
#include <cstdio>
#include <string>
#include <vector>
#include <bitset>
#include <queue>
#include <cmath>
#include <map>
#include <set>
#define PB push_back
#define MP make_pair
using namespace std;
typedef pair<int, int> PII;
typedef pair<int, double> PID;
typedef long long LL;

#define EPS (1e-8)

void PointMulMat(double p[4], double mat[4][4]) {
    double tmp[4] = {0.0, 0.0, 0.0, 0.0};
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 4; ++j) {
            tmp[i] += p[j] * mat[j][i];
        }
    }
    memcpy(p, tmp, sizeof(tmp));
}

void GetOVectorRolateMat(double mat[4][4],
                      double x, double y, double z,
                      double ang) {
    double c = cos(ang), s = sin(ang), t = 1-c, len = sqrt(x*x+y*y+z*z);
    x /= len, y /= len, z /= len;
    double tmp[4][4] = {
        (t*x*x + c  ), (t*x*y + s*z), (t*x*z - s*y), 0.0,
        (t*y*x - s*z), (t*y*y + c  ), (t*y*z + s*x), 0.0,
        (t*z*x + s*y), (t*z*y - s*x), (t*z*z + c  ), 0.0,
        0.0, 0.0, 0.0, 1.0
    };
    memcpy(mat, tmp, sizeof(tmp));
}

const int MAXN = 999, MAXM = 110, X = 0, Y = 1, Z = 2;
int n, m;
double sph[MAXN][4], pt[MAXN][4];
double plane[MAXM][4];

struct Point {
    double x, y;
} p[MAXN], tmp[MAXN];

struct Line {
    double A, B, C;
};

struct Circle {
    Point cent;
    double r;
};

Point Middle(Point A, Point B)
{
        Point res;
        res.x = (A.x + B.x) / 2.0;
        res.y = (A.y + B.y) / 2.0;
        return res;
}

double Dist(Point A, Point B)
{
        double res = sqrt( (A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y) );
        return res;
}

bool SamePoint(Point A, Point B){

        if (fabs(A.x - B.x) > EPS || fabs(A.y - B.y) > EPS) return false;
        return true;
}

bool Point_In_Circle(Point p, Circle c){

        if (Dist(p, c.cent) - EPS > c.r) return false;
        return true;
}

Point Inter(Line a, Line b)
{
        Point res;
        res.x = (a.B * b.C - b.B * a.C) / (a.A * b.B - b.A * a.B);
        res.y = (a.A * b.C - b.A * a.C) / (b.A * a.B - b.B * a.A);
        return res;
}

Line Build(Point A, Point B)
{
        Line res;
        res.A = A.y - B.y;
        res.B = B.x - A.x;
        res.C = A.x * B.y - B.x * A.y;
        return res;
}

Line Per(Line l, Point A)
{
        Line res;
        res.A = -l.B;
        res.B = l.A;
        res.C = -(res.A * A.x + res.B * A.y);
        return res;
}

Line Midper(Point A, Point B)
{
        Line res = Per(Build(A, B), Middle(A, B));
        return res;
}

Circle BuildCircle_ByThreePoint(Point p1, Point p2, Point p3){

        Circle res;
        res.cent = Inter(Midper(p1, p2), Midper(p1, p3));
        res.r = Dist(res.cent, p1);
        return res;
}

Circle Min_Circle_TwoPoint(Point *tmp_p, int n, Point p1, Point p2){

        Circle res;
        res.cent = Middle(p1, p2);
        res.r = Dist(p1, p2) / 2.0;
        for (int i = 0; i < n; i++){

                if (SamePoint(p1, tmp_p[i]) || SamePoint(p2, tmp_p[i])) continue;
                if (Point_In_Circle(tmp_p[i], res) == true) continue;
                res = BuildCircle_ByThreePoint(p1, p2, tmp_p[i]);
        }
        return res;
}

Circle Min_Circle_OnePoint(Point *tmp_p, int n, Point p1){

        Circle res;
        res.cent = p1;
        res.r = 0.0;
        for (int i = 0; i < n; i++){

                if (SamePoint(p1, tmp_p[i]) == true) continue;
                if (Point_In_Circle(tmp_p[i], res) == true) continue;
                res = Min_Circle_TwoPoint(tmp_p, i + 1, p1, tmp_p[i]);
        }
        return res;
}

Circle Min_Circle(Point *p, int n, Point *tmp_p){     //从这里传入点集

        for (int i = 0; i < n; i++)
                tmp_p[i] = p[i];
        for (int i = 0; i < n; i++){

                int a = rand() % n;
                int b = rand() % n;
                if (a < b) swap(tmp_p[a], tmp_p[b]);
        }

        Circle res;
        res.cent = tmp_p[0];
        res.r = 0.0;

        for (int i = 1; i < n; i++){

                if (Point_In_Circle(tmp_p[i], res) == true) continue;
                res = Min_Circle_OnePoint(tmp_p, i + 1, tmp_p[i]);
        }
        return res;
}

void Init() {}
void Read() {
    scanf("%d %d", &n, &m);

    for (int i = 0; i < n; ++i)
        for (int j = 0; j < 3; ++j)
            scanf("%lf", &sph[i][j]);

    for (int i = 0; i < m; ++i)
        for (int j = 0; j < 3; ++j)
            scanf("%lf", &plane[i][j]);
}

void Solve() {
    for (int i = 0; i < n; ++i) sph[i][3] = 1.0;
    for (int i = 0; i < m; ++i) {
        double a = plane[i][0], b = plane[i][1], c = plane[i][2];
        double x = b, y = -a, z = 0.0;
        double ang = acos(c / sqrt(a*a+b*b+c*c));
        double rolmat[4][4] = {
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0
        };
        if (fabs(x) < EPS && fabs(y) < EPS) ;
        else GetOVectorRolateMat(rolmat, x, y, z, ang);
        for (int j = 0; j < n; ++j) {
            memcpy(pt[j], sph[j], sizeof(pt[j]));
            PointMulMat(pt[j], rolmat);
            p[j].x = pt[j][X];
            p[j].y = pt[j][Y];
        }
        Circle cir = Min_Circle(p, n, tmp);
        printf("%.10lf\n", cir.r);
    }
}

int main() {
    Init();
    Read();
    Solve();
    return 0;
}
