#include <bits/stdc++.h>

#pragma comment(linker, "/STACK:102400000,102400000")
using namespace std;

#define LL long long
#define pii pair<int,int>
#define MP make_pair
#define ls i << 1
#define rs ls | 1
#define md (ll + rr >> 1)
#define lson ll, md, ls
#define rson md + 1, rr, rs
#define Pi acos(-1.0)
#define mod 1000000007
#define eps 1e-8
#define inf 0x3f3f3f3f
#define N 200010
#define M 200020

struct edge{
	int l, r, y, in;
	edge(int l = 0, int r = 0, int y = 0, int in = 0) : l(l), r(r), y(y), in(in) {}
	bool operator < (const edge &b) const {
		return y < b.y || y == b.y && in > b.in;
	}
};
edge e[N];
int san[N], cnt, n;
int sum[N<<2], vis[N<<2];
int haxi(int v){
	return lower_bound(san + 1, san + 1 + cnt, v) - san;
}
void push_up(int i, int ll, int rr){
	if(vis[i]) sum[i] = san[rr + 1] - san[ll];
	else if(ll == rr) sum[i] = 0;
	else sum[i] = sum[ls] + sum[rs];
}
void update(int l, int r, int v, int ll, int rr, int i){
	if(l == ll && r == rr){
		vis[i] += v;
		push_up(i, ll, rr);
		return ;
	}
	if(r <= md) update(l, r, v, lson);
	else if(l > md) update(l, r, v, rson);
	else update(l, md, v, lson), update(md + 1, r, v, rson);
	push_up(i, ll, rr);
}
int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i){
		 int x, y, xx, yy;
		 scanf("%d%d%d%d", &x, &y, &xx, &yy);
		 if(x > xx) swap(x, xx);
		 if(y > yy) swap(y, yy);
		 xx++, yy++;
		 san[++cnt] = x;
		 san[++cnt] = xx;
		 e[i] = edge(x, xx, y, 1);
		 e[i+n] = edge(x, xx, yy, -1);
	}
	sort(san + 1, san + 1 + cnt);
	cnt = unique(san + 1, san + 1 + cnt) - san - 1;
	int m = n << 1;
	sort(e + 1, e + m + 1);
	LL ans = 0;
	for(int i = 1; i < m; ++i){
		int l = haxi(e[i].l);
		int r = haxi(e[i].r) - 1;
		if(l <= r)
			update(l, r, e[i].in, 1, m, 1);
		ans += 1LL * (e[i+1].y - e[i].y) * sum[1];
	}
	printf("%I64d\n", ans);
	return 0;
}
 	  			  	 	 	 		  	  		  	  		