#include <bits/stdc++.h>
using namespace std;
const int N = 2e5+5;
long long tree[N*4],value[N*4];
vector<pair<pair<int,int>,pair<int,int> > >v;
#define mp make_pair
#define x first
#define y second
vector<int> Y;
void update(int pos,int l,int r,int x,int y,int u){
	if(y<=l || x>=r)return;
	if(l<=x && y<=r){
		tree[pos]+=u;return;
	}
	int mid= (x+y)/2;
	update(2*pos,l,r,x,mid,u);
	update(2*pos+1,l,r,mid,y,u);
	value[pos]= (tree[pos*2]>0 ? Y[mid]-Y[x] : value[pos*2]) + (tree[pos*2+1]>0 ? Y[y]-Y[mid] : value[pos*2+1]);
}
int main(){
	int a,b,c,d,n,i,j;cin>>n;
	for(i=0;i<n;++i){
		scanf("%d%d%d%d",&a,&b,&c,&d);
		if(a>c)swap(a,c);
		if(b>d)swap(b,d);
		v.push_back(mp(mp(a,1),mp(b,d+1)));
		v.push_back(mp(mp(c+1,-1),mp(b,d+1)));
		Y.push_back(b);Y.push_back(d+1);
	}
	sort(v.begin(),v.end());
	sort(Y.begin(),Y.end());
	Y.erase(unique(Y.begin(),Y.end()),Y.end());
	long long R=0;int l,r,prev=v[0].x.x,now;
	for(i=0;i<v.size();){
		now = v[i].x.x;
		R+=1LL*(now-prev)*(tree[1]>0 ? Y.back()-Y[0] : value[1]);
		while(i<v.size()&& v[i].x.x==now){
			l=lower_bound(Y.begin(),Y.end(),v[i].y.x)-Y.begin();
			r= lower_bound(Y.begin(),Y.end(),v[i].y.y)-Y.begin();
			update(1,l,r,0,Y.size()-1,v[i].x.y);
			++i;
		}
		prev= now;
	}
	cout<<R<<endl;
}
