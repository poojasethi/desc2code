#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

#define MID mid = ((l + r) >> 1)
#define ls root << 1
#define rs root << 1 | 1
#define lson l, mid, ls
#define rson mid + 1, r, rs

const int N = 200007;
struct Line {
	int xl, xr, y, val;
	Line() {}
	Line(int a, int b, int c, int d) : xl(a), xr(b), y(c), val(d) {}
	bool operator < (const Line &tt) const {return y < tt.y;}
}line[N];
int n, tot, x[N], lazy[N << 2];
long long sum[N << 2];

void Init() {
	tot = 0;
	memset(sum, 0, sizeof(sum));
	memset(lazy, 0, sizeof(lazy));
}

void GetData() {
	int i, x1, y1, x2, y2;
	scanf("%d", &n);
	for(i = 0; i < n; ++i) {
		scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
		if(x1 > x2) swap(x1, x2);
		if(y1 > y2) swap(y1, y2);
		x[tot++] = x1; x[tot++] = x2 + 1;
		line[i << 1] = Line(x1, x2 + 1, y1, 1);
		line[i << 1 | 1] = Line(x1, x2 + 1, y2 + 1, -1);
	}
}

void Update(int L, int R, int v, int l, int r, int root) {
	if(L <= l && r <= R) lazy[root] += v;
	else {
		int MID;
		if(L <= mid) Update(L, R, v, lson);
		if(R > mid) Update(L, R, v, rson);
	}
	if(lazy[root] != 0) sum[root] = x[r + 1] - x[l];
	else if(l != r) sum[root] = sum[ls] + sum[rs];
	else sum[root] = 0;
}

void Solve() {
	int i, l, r;
	long long ans = 0;
	sort(x, x + tot);
	tot = unique(x, x + tot) - x;
	sort(line, line + 2 * n);
	for(i = 0; i < 2 * n; ++i) {
		if(i != 0) ans += sum[1] * (line[i].y - line[i - 1].y);
		l = lower_bound(x, x + tot, line[i].xl) - x;
		r = lower_bound(x, x + tot, line[i].xr) - x;
		Update(l, r - 1, line[i].val, 0, tot - 1, 1);
	}
	printf("%lld\n", ans);
}

int main() {
	Init();
	GetData();
	Solve();
	return 0;
}