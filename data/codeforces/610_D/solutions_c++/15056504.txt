#include <iostream>
#include <algorithm>
#include <cstdio>
#include <string>
#include <cstring>
#include <map>
#define Rep(i, x, y) for (int i = x; i <= y; i ++)
#define Dwn(i, x, y) for (int i = x; i >= y; i --)
#define RepE(i, x) for (int i = pos[x]; i; i = g[i].nex)
using namespace std;
typedef long long LL;
typedef double DB;
const int N = 200005;
map<int, int> vx, v, sv;
struct arr { int ty, x, a, b; } a[N];
int n, p[N], X[N], m, x0, az, xz; LL ans;
bool cmp(arr x, arr y) { return (x.x == y.x) ? ((x.ty == y.ty) ? x.a < y.a : x.ty < y.ty) : x.x < y.x; }
int Qry(int x) { int y = 0; for (; x; x -= x & (-x)) y += p[x]; return y; }
void Add(int x, int y) { for (; x <= m; x += x & (-x)) p[x] += y; return ; }
int main()
{
	cin >> n; m = n * 2;
	Rep(i, 1, n) {
		int x1, x2, y1, y2;
		scanf ("%d%d%d%d", &x1, &y1, &x2, &y2);
		if (x1 > x2) swap(x1, x2);
		if (y1 > y2) swap(y1, y2);
		// ans += x2 + y2 - x1 - y1 + 1; cout << x <<" -"<<endl;cout << x<<" +"<<endl;
		if (x1 == x2) {
			a[++ az] = (arr) { 0, y1, x1, 0 }; 
			a[++ az] = (arr) { 2, y2, x1, 0 };
			X[++ xz] = x1;
		} else a[++ az] = (arr) { 1, y1, x1, x2 }, X[++ xz] = x1, X[++ xz] = x2;
	}
	sort(X + 1, X + xz + 1);
	Rep(i, 1, xz) { if (i == 1 || X[i] != X[i - 1]) x0 ++; vx[ X[i] ] = x0; }
	sort(a + 1, a + az + 1, cmp);
	int fl = 0, lb = -1, la = 0;
	Rep(i, 1, az) {
		 // cout << a[i].ty<<" "<<a[i].x<<" "<<a[i].a<<" "<<a[i].b<<endl;
		// a[i].a = vx[ a[i].a ];
		if (a[i].x != a[i - 1].x || a[i].ty != 1) {
			// cout << la <<" "<<lb<<endl;
			if (lb >= la) ans -= Qry(vx[lb]) - Qry(vx[la] - 1);
			fl = 0, ans += lb - la + 1, lb = -1, la = 0;
		}
		if (a[i].ty == 1) {
			if (!fl) la = a[i].a, lb = a[i].b, fl = 1;
			else if (a[i].a > lb) {
				ans -= Qry(vx[lb]) - Qry(vx[la] - 1);
				ans += lb - la + 1, lb = a[i].b, la = a[i].a;
			}
			else lb = max(lb, a[i].b);
		}
		else if (!a[i].ty) {
			v[ a[i].a ] ++;
			if (v[ a[i].a ] == 1) sv[ a[i].a ] = a[i].x, Add(vx[ a[i].a ], 1);
		}
		else {
			v[ a[i].a ] --;
			if (v[ a[i].a ] == 0) ans += a[i].x - sv[ a[i].a ] + 1, Add(vx[ a[i].a ], -1);
		}
		// cout << ans << endl;
	}
	if (lb >= la) ans -= Qry(vx[lb]) - Qry(vx[la] - 1);
	printf("%I64d\n", ans + lb - la + 1);

	return 0;
}
