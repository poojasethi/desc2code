//priority_queue
/*
* =.=
*/
#pragma comment(linker, "/STACK:102400000,102400000")
#include <iostream>
#include <map>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <vector>
#include <queue>
#include <stack>
#include <functional>
#include <set>
#include <cmath>
using namespace std;
#define IOS std::ios::sync_with_stdio (false);std::cin.tie(0)
#define pb push_back
#define PB pop_back
#define bk back()
#define fs first
#define se second
#define sq(x) ((x)*(x))
#define eps (1e-3)
#define INF (0x3f3f3f3f)
#define clr(x) memset((x),0,sizeof (x))
#define cp(a,b) memcpy((a),(b),sizeof (b))

typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> P;

const int maxn=1e6+3000;
struct seg{
	int l,r,h,x;
	seg(int l=0,int r=0,int h=0,int x=0):l(l),r(r),h(h),x(x){}
	bool operator < (const seg &C)const{
		return h<C.h;
	}
}A[maxn];
int n;
int dic[maxn],h;
int idx(int x){
	return lower_bound(dic,dic+h,x)-dic;
}
ll len[maxn],cov[maxn];
void update(int o,int a,int b,int l,int r,int x){
	if(l>=b||r<=a) return;
	if(r-l<=1){
		cov[o]+=x;
		if(cov[o]) len[o]=dic[r]-dic[l];
		else len[o]=0;
		return;
	}
	if(l>=a&&r<=b){
		cov[o]+=x;
		if(cov[o]>0) len[o]=dic[r]-dic[l];
		else len[o]=len[o<<1]+len[(o<<1)|1];
		return;
	}
	int mid=(l+r)>>1;
	update(o<<1,a,b,l,mid,x);
	update((o<<1)|1,a,b,mid,r,x);
	if(!cov[o]) len[o]=len[o<<1]+len[(o<<1)|1];
}
int main(){
	////freopen("/home/slyfc/CppFiles/in","r",stdin);
	cin>>n;
	for(int i=0;i<n;i++){
		int x1,y1,x2,y2;
		scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		if(x1>x2) swap(x1,x2),swap(y1,y2);
		if(y1>y2) swap(y1,y2),swap(x1,x2);
		dic[i]=x1,dic[i+n]=x2+1;
		A[i]=seg(x1,x2+1,y1,1);
		A[i+n]=seg(x1,x2+1,y2+1,-1);
	}
	sort(A,A+2*n);
	sort(dic,dic+n*2);
	h=unique(dic,dic+n*2)-dic;
	ll ans=0;
	ll last=-INF,L=0;
	for(int i=0;i<2*n;i++){
		ans+=L*(A[i].h-last);
		update(1,idx(A[i].l),idx(A[i].r),0,h,A[i].x);
		last=A[i].h;
		L=len[1];
	}
	cout<<ans<<endl;
	return 0;
}
 	 					   		  	  	  	        	