#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<queue>
#include<set>
#define N 110000
using namespace std;
int type;
struct bg{
	int l,k,id;
	friend bool operator <(const bg&a,const bg&b){
		return a.k>b.k || a.k==b.k && a.l<b.l;
	}
};
set <bg> S;
priority_queue <pair<int,int> >Q;
int pos[3][N*3],p[N*3],a[N],b[N],c[N],cnt,ans,tot,i,j,n;
bool flag[N*24];
typedef set<bg> :: iterator it;
bg mk(int l,int k,int id){
	bg res={l,k,id};
	return res;
}
int Find(int x){
	return lower_bound(p+1,p+tot+1,x)-p;
}
void add(int x,int y)	//f[1..x]=max(f[1..x],y)
{
	it t=S.lower_bound(mk(-1,y,-1)),t1,t2;
	if(t==S.end() || x<t->l)return;
	int l=t->l,tmp;
	t1=t;
	for(;;){
		t2=t1; t2++;
		if(t2==S.end())tmp=1e9;
		else tmp=(t2->l)-1;
		if(x>=tmp){
			flag[t1->id]=1;
			S.erase(t1);
			t1=t2;
		}else{
			flag[t1->id]=1;
			bg res1={l,y,++cnt},res2={x+1,t1->k,++cnt};
			S.erase(t1);
			S.insert(res1);
			S.insert(res2);
			Q.push(make_pair(-res1.l-res1.k,res1.id));
			Q.push(make_pair(-res2.l-res2.k,res2.id));
			return;
		}
	}
}
void init(){
	scanf("%d",&n);
	for(i=1;i<=n;++i)scanf("%d",&a[i]),p[++tot]=a[i];
	for(i=1;i<=n;++i)scanf("%d",&b[i]),p[++tot]=b[i];
	for(i=1;i<=n;++i)scanf("%d",&c[i]),p[++tot]=c[i];
	sort(p+1,p+tot+1);
	tot=unique(p+1,p+tot+1)-p-1;
	for(i=1;i<=n;++i){
		a[i]=Find(a[i]);
		b[i]=Find(b[i]);
		c[i]=Find(c[i]);
	}
	memset(pos,3,sizeof(pos));
	for(i=n;i>=1;--i){
		pos[0][a[i]]=i;
		pos[1][b[i]]=i;
		pos[2][c[i]]=i;
	}
}
int main(){
	init();
	S.insert(mk(0,0,++cnt));
	Q.push(make_pair(0,cnt));
	for(i=1;i<=tot;++i)if(pos[0][i]>1e6)add(pos[1][i]-1,pos[2][i]);
	while(flag[Q.top().second])Q.pop();
	ans=-Q.top().first+n;
	for(i=n;i>=1;--i){
		if(pos[0][a[i]]==i){
			add(pos[1][a[i]]-1,pos[2][a[i]]);
		}
		while(flag[Q.top().second])Q.pop();
		ans=min(ans,i-1-Q.top().first);
	}
	printf("%d\n",ans);
}
