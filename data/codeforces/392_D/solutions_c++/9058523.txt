#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<set>
#include<queue>
#define N 633333
#define For(i,l,r) for(int i=l;i<=r;i++)
using namespace std;
struct rec{int val,pos,type;}E[N];
struct point{int a,x,y;}P[N];
struct rzz{
    int x,y;
    bool operator < (const rzz &B)const{return x==B.x?y<B.y:x<B.x;}
};
bool cmp(const rec &i,const rec &j){return i.val<j.val;}
bool cmp1(const point &i,const point &j){return i.a>j.a;}
int n,tot,cnt,inf,ans,great[N];
set <rzz> S;
set <int> Q;
set <rzz> :: iterator it;
set <int> :: iterator jt;
void Add(rzz A,rzz B,int key){
    
    int val=A.x+B.y;
    if(A.x==n+1) return;
    if(B.y==n+1) return;
    
    if(key==1){
        great[val]++;
        if(great[val]==1) Q.insert(val);
    }
    else{
        great[val]--;
        if(great[val]==0) Q.erase(val); 
    }
    
}
void Modify(set<rzz>::iterator it,int key){
    rzz p=(rzz){0,0};
    rzz nxt,pre;
    if(it==S.begin()) pre=p;else pre=*--it,++it;
    if(++it==S.end()) nxt=p;else nxt=*it; --it;
    
    Add(pre,nxt,-key);
    Add(pre,*it,key);
    Add(*it,nxt,key);
    
    if(key==-1) S.erase(it);
}
int main(){
    
    scanf("%d",&n);
    For(i,1,n){int x; scanf("%d",&x); E[++tot]=(rec){x,i,0};}
    For(i,1,n){int x; scanf("%d",&x); E[++tot]=(rec){x,i,1};}
    For(i,1,n){int x; scanf("%d",&x); E[++tot]=(rec){x,i,2};}
    sort(E+1,E+1+tot,cmp);
    
    inf=n+1;
    for(int i=1,j=1;i<=tot;i=j){
        P[++cnt]=(point){inf,inf,inf};
        for(j=i;E[i].val==E[j].val;j++){
            if(E[j].type==0) P[cnt].a=min(P[cnt].a,E[j].pos);
            if(E[j].type==1) P[cnt].x=min(P[cnt].x,E[j].pos);
            if(E[j].type==2) P[cnt].y=min(P[cnt].y,E[j].pos);
        }
    }
    
    ans=2333333;
    
    sort(P+1,P+1+cnt,cmp1);
    if(P[1].a<=n) ans=P[1].a;
    
    rzz tmp;
    For(i,1,cnt){
        
        tmp=(rzz){P[i].x,P[i].y};
        rzz *now=&tmp;
        
        it=S.upper_bound(*now);
        if(it==S.end() || it->y < now->y){
            if(it!=S.begin()){
                it--;
                while(it->y <= now->y){
                    
                    if(it==S.begin()){Modify(it,-1); break;}
                    Modify(it--,-1);
                    
                }
            }
            
            S.insert(*now);
            Modify(S.lower_bound(*now),1);
        }
        
        jt=Q.upper_bound(0);
        if(P[i+1].a<=n&&jt!=Q.end())
        ans=min(ans,P[i+1].a+*jt);
    }
    
    printf("%d\n",ans);
    
}