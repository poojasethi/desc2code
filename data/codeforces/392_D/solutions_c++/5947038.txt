#include <algorithm>
#include <stdio.h>
#include <memory.h>
#include <queue>
#include <cmath>
#include <set>
#include <map>
#include <string.h>
#include <string>
#include <ctype.h>
#include <ctime>

using namespace std;

typedef long long INT;
typedef pair<int, int> pii;

#define beyond(r, c) (r<0 || c<0 || r>=R || c>=C)
#define NN 110000
#define inf 1000000000

struct triple{
	int a, b, c;
	triple(int a=0, int b=0, int c=0): a(a), b(b), c(c) {}
};

map<int, triple> M;
int n, res;
int a[NN], b[NN], c[NN];
set<pii> cur;
priority_queue<pii> Q;

void Insert(int a, int b) {
	set<pii>::iterator it=cur.lower_bound(pii(a, b));
	if (it!=cur.end() && b<=it->second) return;
	if (it!=cur.end()) Q.push(pii(-(a+it->second), a));
	it=cur.insert(pii(a, b)).first;
	while(it!=cur.begin()) {
		it--;
		if (it->second<=b) cur.erase(it++);
		else { it++; break; }
	}
	if (it!=cur.begin()) {
		it--;
		Q.push(pii(-(it->first+b), it->first));
	}
}

bool Check(pii p) {
	int cand=-p.first, i=p.second;
	set<pii>::iterator it=cur.lower_bound(pii(i, 0));
	if (it==cur.end() || it->first!=i) return false;
	it++;
	if (it==cur.end() || it->second!=cand-i) return false;
	return true;
}

int getBest() {
	while(!Q.empty()) {
		pii v=Q.top();
		if (Check(v)) return -v.first;
		Q.pop();
	}
	return inf;
}

int main() {
	map<int, triple>::iterator it;
	
	int i;
	
	scanf("%d", &n);
	for (i=0; i<n; i++) {
		scanf("%d", &a[i]);
		it=M.find(a[i]);
		if (it==M.end()) M[a[i]]=triple(i+1, inf, inf);
	}
	for (i=0; i<n; i++) {
		scanf("%d", &b[i]);
		it=M.find(b[i]);
		if (it==M.end()) M[b[i]]=triple(inf, i+1, inf);
		else it->second.b=min(it->second.b, i+1);
	}
	for (i=0; i<n; i++) {
		scanf("%d", &c[i]);
		it=M.find(c[i]);
		if (it==M.end()) M[c[i]]=triple(inf, inf, i+1);
		else it->second.c=min(it->second.c, i+1);
	}
	
	Insert(0, inf); Insert(inf, 0);
	for (it=M.begin(); it!=M.end(); it++) {
		if (it->second.a==inf) Insert(it->second.b, it->second.c);
	}
	res=inf;
	for (int i=n; i>=0; i--) {
		res=min(res, i+getBest());
		if (i) {
			it=M.find(a[i-1]);
			if (it->second.a==i) Insert(it->second.b, it->second.c);
		}
	}
	
	printf("%d\n", res);
	
	return 0;
}

