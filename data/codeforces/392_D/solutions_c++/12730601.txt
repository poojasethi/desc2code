#include<iostream>
#include<algorithm>
#include<set>
#include<cstdlib>
#include<cstdio>
#include<map>
using namespace std;
const int MaxN = 100000 + 10, INF = 0x3f3f3f3f;

struct Point
{
	int x, y;
	bool operator < (const Point &b) const {return x < b.x || (x == b.x && y < b.y);}
};

set<Point>s;


int sa, sb, sc, A[MaxN], B[MaxN], C[MaxN], n;

void init()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; ++i) scanf("%d", &A[i]);
	for(int i = 1; i <= n; ++i) scanf("%d", &B[i]);
	for(int i = 1; i <= n; ++i) scanf("%d", &C[i]);
}

int bb[MaxN * 3], cc[MaxN * 3], arr[MaxN * 3], sl;
bool vis[MaxN * 3], notLast[MaxN];

int erf(int v)
{
	int st = 0, en = sl + 1, mid;
	while(st + 1 < en)
	{
		mid = (st + en) >> 1;
		if(arr[mid] <= v) st = mid;
		else en = mid;
	}
	return st;
}

set<Point>::iterator it, pt;
multiset<int> heap;
multiset<int>::iterator msp;

int ipii;

void add(Point p)
{
	
	if(s.find(p) != s.end()) return;
	
	it = s.insert(p).first;
	
	int y1, y2;
	++it;y1 = it->y;
	if(it->y >= p.y)
	{
		--it;
		s.erase(it);
		return;
	}
	--it;--it;y2 = it->x;++it;
	msp = heap.find(y1 + y2);
	if(msp != heap.end())heap.erase(msp);
	else exit(1);
	for(--it; it->y <= p.y; )
	{
		pt = it;--pt;
		heap.erase(heap.find(pt->x + it->y));
		s.erase(it--);
	}
	heap.insert(it->x + p.y);
	++it;++it;
	heap.insert(p.x + it->y);
}

void build()
{
	for(int i = 1; i <= n; ++i) arr[++sl] = A[i];
	for(int i = 1; i <= n; ++i) arr[++sl] = B[i];
	for(int i = 1; i <= n; ++i) arr[++sl] = C[i];
	sort(arr + 1, arr + sl + 1);
	sl = unique(arr + 1, arr + sl + 1) - arr - 1;
	s.insert((Point){0, INF + 1});
	s.insert((Point){INF + 1, 0});
	heap.insert(0);
	for(int i = n; i >= 1; --i) bb[erf(B[i])] = i;
	for(int i = n; i >= 1; --i) cc[erf(C[i])] = i;
	int v;
	for(int i = 1; i <= n; ++i)
	{
		v = erf(A[i]);
		if(!vis[v]) vis[v] = true;
		else notLast[i] = true;
	}
	int xx, yy;
	for(int i = 1; i <= sl; ++i)
		if(!vis[i])
		{
			if(bb[i]) xx = bb[i];
			else xx = INF;
			if(cc[i]) yy = cc[i];
			else yy = INF;
			add((Point){xx, yy});
		}
}

void debug()
{/*
	printf("========%d========\n", ipii);
	for(multiset<int>::iterator i = heap.begin(); i != heap.end();
		 ++i)
		printf("%d\n", *i);
	
	for(it = s.begin(); it != s.end(); ++it)
		printf("%d %d\n", it->x, it->y);
		
	printf("===================\n");*/
}

void solve()
{
	int ans = INF, v, xx, yy;
	for(int i = n; i >= 0; --i)
	{
		v = (*heap.begin()) + i;
		if(v < ans) ans = v;
		if(i && !notLast[i])
		{
			v = erf(A[i]);
			if(bb[v]) xx = bb[v];
			else xx = INF;
			if(cc[v]) yy = cc[v];
			else yy = INF;
			ipii = i;
			debug();
			add((Point){xx, yy});
		}
	}
	printf("%d\n", ans);
}

int main()
{

	//freopen("a.in", "r", stdin);
	//freopen("a.ans", "w", stdout);
	
	init();
	
	build();
	
	solve();
	
	return 0;
}
