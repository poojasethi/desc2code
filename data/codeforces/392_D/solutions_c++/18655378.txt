#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <queue>
#include <ctime>
#include <set>
#ifdef WIN32
#define TAT "%I64d"
#else
#define TAT "%lld"
#endif 
#define int64 long long
#define wc(c) freopen(c".in","r",stdin);   freopen(c".out","w",stdout);
using namespace std;
const int Maxn = 1 << 30;
int n;
struct Node{
	int v,id,from;
}seq[1001000];
struct NNode{
	int v[4];
	void init(){v[1] = v[2] = v[3] = 3 * n;}
}whe[1001000];
struct NNNode{
	int x,y;
};
int a[4][100100],tot,cnt;
set<NNNode> F;
multiset <int> sum;

bool operator < (NNNode x,NNNode y){return x.x < y.x || (x.x == y.x && x.y < y.y);}
bool cmp1(Node x,Node y){return x.v < y.v;}
bool cmp(NNode x,NNode y){return x.v[1] > y.v[1];}
void insert(int x)
{
	set<NNNode> :: iterator s1,s2,s3;
	NNNode inwho = (NNNode){whe[x].v[2],whe[x].v[3]};
	F.insert(inwho);
	s1 = F.find(inwho);
	s3 = s1;    s3++;
	if ((*s3).x >= (*s1).x && (*s3).y >= (*s1).y)     {F.erase(inwho);return ;}
	s2 = s1;   s2--;  s3 = s1;   s3++;
	if (sum.find((*s3).y + (*s2).x) != sum.end())
		sum.erase(sum.find((*s3).y + (*s2).x));
	while (true)
		{
			s1 = F.find(inwho);
			s2 = s1;   s2--;
			if (!((*s2).x <= (*s1).x && (*s2).y <= (*s1).y))     break ;
			s3 = s2;   s3--;
			if (sum.find((*s2).y + (*s3).x) != sum.end())
				sum.erase(sum.find((*s2).y + (*s3).x));
			F.erase(s2); 
		}
	s1 = F.find(inwho);
	s3 = s1;   s3++;
	sum.insert((*s1).x + (*s3).y);
	s2 = s1;   s2--;
	sum.insert((*s2).x + (*s1).y);
}
void work()
{
	sort(whe + 1,whe + cnt + 1,cmp);
	F.insert((NNNode){3 * n + 2,0});   F.insert((NNNode){0,3 * n + 2});
	sum.insert(0);  
 	int l = 1,ans = Maxn;
	for (int u = n;u >= 0;u--)
		{
			while (whe[l].v[1] > u)   insert(l),l++;
			ans = min(ans,u + (*sum.begin()));
		}
	cout << ans;
}

int main()
{
	cin >> n;
	for (int i = 1;i <= n;i++)    scanf("%d",&a[1][i]),seq[++tot] = (Node){a[1][i],i,1};
	for (int i = 1;i <= n;i++)    scanf("%d",&a[2][i]),seq[++tot] = (Node){a[2][i],i,2};
	for (int i = 1;i <= n;i++)    scanf("%d",&a[3][i]),seq[++tot] = (Node){a[3][i],i,3};
	sort(seq + 1,seq + tot + 1,cmp1);
	a[seq[1].from][seq[1].id] = 1;   cnt++;
	whe[1].init();
	whe[cnt].v[seq[1].from] = min(whe[cnt].v[seq[1].from],seq[1].id);
	for (int i = 2;i <= tot;i++)
		{
			if (seq[i].v != seq[i - 1].v)   cnt++,whe[cnt].init();
			a[seq[i].from][seq[i].id] = cnt;
			whe[cnt].v[seq[i].from] = min(whe[cnt].v[seq[i].from],seq[i].id);
		}
	work();
}
  
