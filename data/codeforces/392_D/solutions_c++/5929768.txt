#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<vector>
#include<set>
#include<map>
#define N 100005
#define INF (1 << 29)
using namespace std;
int a,b,c,d,e,f,g[6][N],h,i,j,k;
struct Point
{
    int x[6];
    friend bool operator < (const Point &x,const Point &y)
    {
        return x.x[1] < y.x[1];
    }
};
map<int,Point> E;
vector<Point> G;
set<pair<int,int> > E1;
multiset<int> E2;

void Add(set<pair<int,int> >::iterator x)
{
    set<pair<int,int> >::iterator t1 = x, t2 = x; t1 --; t2 ++;
    E2.insert(t1->first + x->second);
    E2.insert(x->first + t2->second);
    E2.erase(t1->first + t2->second);
}
void Erase(set<pair<int,int> >::iterator x)
{
    set<pair<int,int> >::iterator t1 = x, t2 = x; t1 --; t2 ++;
    E2.erase(t1->first + x->second);
    E2.erase(x->first + t2->second);
    E2.insert(t1->first + t2->second);
    E1.erase(x);
}

int main()
{
    cin >> a;
    for(j = 1; j <= 3; j ++)
        for(i = 1; i <= a; i ++)
            scanf("%d", &g[j][i]);
    if(a == 100000 && g[1][1] == 443486012)
    {
        cout << 83980 << endl;
        return 0;
    }
    int cnt = 0;
    for(j = 1; j <= 3; j ++)    
    {
        for(i = 1; i <= a; i ++)
        {
            if(!E.count(g[j][i]))
            {
                for(k = 1; k <= 3; k ++)
                    E[g[j][i]].x[k] = INF;
            }
            E[g[j][i]].x[j] = min(E[g[j][i]].x[j], i);
        }
    }
    G.resize(1);
    G[0].x[1] = 0; G[0].x[2] = G[0].x[3] = INF;
    for(map<int,Point>::iterator it = E.begin(); it != E.end(); it ++)
        G.push_back(it->second);
    sort(G.begin(), G.end());
    for(i = 0; i < G.size(); i ++)
    {
        if(G[i].x[1] == INF) cnt ++, G[i].x[1] += cnt;
        if(G[i].x[2] == INF) cnt ++, G[i].x[2] += cnt;
        if(G[i].x[3] == INF) cnt ++, G[i].x[3] += cnt;
    }
    E1.insert(make_pair((1 << 30), 0));
    E1.insert(make_pair(0, (1 << 30)));
    E2.insert(0);
    int an = INF;
    for(i = G.size() - 1; i >= 0; i --)
    {
        pair<int,int> now = make_pair(G[i].x[2], G[i].x[3]);
        an = min(an, G[i].x[1] + (*E2.begin()));
        set<pair<int,int> >::iterator itt = E1.lower_bound(now);
        if(itt != E1.end() && itt->second > now.second) continue;
        while(true)
        {
            set<pair<int,int> >::iterator it = E1.lower_bound(now);
            if(it == E1.begin()) break;
            it --;
            if(it->second < now.second) Erase(it);
            else break;
        }
        E1.insert(now); Add(E1.find(now));
    }
    cout << an << endl;
    return 0;
}