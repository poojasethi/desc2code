#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define maxn 100010
#define ls (p << 1)
#define rs (p << 1) | 1
#define oo 0x3f3f3f3f
using namespace std;
void gn(int &x)
{
	x = 0; char ch = getchar();
	while (ch < '0' || ch > '9') ch = getchar();
	while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
}
int n, ans, a[maxn], b[maxn], c[maxn], val[maxn * 3], vt;
int e[maxn];
struct node{
	int u, v, w;
	node(){}
	node(int _u, int _v, int _w){u = _u; v = _v; w = _w;}
	bool operator < (const node &b) const
	{
		return u > b.u;
	}
}d[maxn * 3];
int cov[maxn * 4], mvl[maxn * 4], mans[maxn * 4], mi[maxn * 4];
void cover(int p, int v)
{
	cov[p] = v; mvl[p] = v; 
	mans[p] = mi[p] + v;
}
void down(int p)
{
	if (cov[p]){
		cover(ls, cov[p]); cover(rs, cov[p]); cov[p] = 0;
	}
}
void up(int p)
{
	mvl[p] = min(mvl[ls], mvl[rs]);
	mans[p] = min(mans[ls], mans[rs]);
}
int gpos(int p, int l, int r, int v)
{
	if (l == r) return mvl[p] < v ? l : oo;
	int mid = (l + r) >> 1; down(p);
	if (mvl[ls] < v) return gpos(ls, l, mid, v);
	return gpos(rs, mid + 1, r, v);
}
void modify(int p, int l, int r, int s, int t, int v)
{
	if (l == s && r == t){cover(p, v); return;}
	int mid = (l + r) >> 1; down(p);
	if (t <= mid) modify(ls, l, mid, s, t, v);
	if (s > mid) modify(rs, mid + 1, r, s, t, v);
	if (s <= mid && t > mid)
		modify(ls, l, mid, s, mid, v), modify(rs, mid + 1, r, mid + 1, t, v);
	up(p);
}
void build(int p, int l, int r)
{
	mi[p] = mans[p] = l;
	if (l == r) return;
	int mid = (l + r) >> 1;
	build(ls, l, mid); build(rs, mid + 1, r);
	up(p);
}
int main()
{
	gn(n);
	for (int i = 1; i <= n; ++ i)
		gn(a[i]), val[++ vt] = a[i];
	for (int i = 1; i <= n; ++ i)
		gn(b[i]), val[++ vt] = b[i];
	for (int i = 1; i <= n; ++ i)
		gn(c[i]), val[++ vt] = c[i];
	sort(val + 1, val + vt + 1);
	vt = unique(val + 1, val + vt + 1) - val - 1;
	for (int i = 1; i <= vt; ++ i) d[i] = node(n + 1, n + 1, oo);
	int pos;
	for (int i = 1; i <= n; ++ i){
		pos = lower_bound(val + 1, val + vt + 1, a[i]) - val;
		d[pos].u = min(d[pos].u, i);
		pos = lower_bound(val + 1, val + vt + 1, b[i]) - val;
		d[pos].v = min(d[pos].v, i);
		pos = lower_bound(val + 1, val + vt + 1, c[i]) - val;
		d[pos].w = min(d[pos].w, i);
	}
	sort(d + 1, d + vt + 1);
	int t = 1; ans = 3 * n;
	build(1, 0, n);
	for (int U = n; U >= 0; -- U){
		while (t <= vt && d[t].u > U){
			int pos = gpos(1, 0, n, d[t].w);
			if (pos <= d[t].v - 1) modify(1, 0, n, pos, d[t].v - 1, d[t].w);
			++ t;
		}
		ans = min(ans, mans[1] + U);
	}
	printf("%d\n", ans);
	return 0;
}

