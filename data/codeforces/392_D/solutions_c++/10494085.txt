#include <bits/stdc++.h>

using namespace std;

#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)

#define type(x) __typeof(x.begin())

#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair < int ,int > pii;

typedef long long ll;

const int inf = 1e9, mod = 1e9+7;
const int N = 3e5 + 5;

int aa[N], s, i, j, k, n, m, x, a[N], b[N], c[N], ans;

class node{
	public:
	int max,min,L;
	node(){ max = L = 0; min = 0;  }
} ST[4 * N];

int w[N+1], wa[N+1], wb[N+1], wc[N+1], h[N+1], cnt[N+1];

map< int , int > ww;

node merge(node l,node r,int bas,int son){ 
	node temp; temp.max = max(l.max, r.max); 
	temp.min = min(l.min, r.min);
	return temp;
}

void push(int k,int bas,int son){
	if(ST[k].L == 0) return ;
	ST[sol].L = ST[sag].L = ST[sol].max = ST[sag].max = ST[k].L;
	ST[sol].min = max(0,bas - 1) + ST[k].L; ST[sag].min = ST[k].L + orta;
	ST[k].L = 0;
}

node init(int k,int bas,int son){
	if(bas == son){ ST[k].max = 0; ST[k].L = 0; ST[k].min = max(bas-1,0); return ST[k]; }
	ST[k] = merge(init(sol,bas,orta),init(sag,orta+1,son),bas,son);
	return ST[k];
}

int query(int k,int bas,int son,int x){
	if(bas > x || son < x) return -inf;
	if(bas == son) return ST[k].max;
	push(k,bas,son);
	return max(query(sol,bas,orta,x),query(sag,orta+1,son,x));	
}

node update(int k,int bas,int son,int x,int y,int t){
	if(bas > y || son < x) return ST[k];
	if(x <= bas && son <= y){
		ST[k].L = t;
		ST[k].min = t + max(0,bas - 1); 
		ST[k].max = t; return ST[k];
	}
	push(k,bas,son);
	return ST[k] = merge(update(sol,bas,orta,x,y,t),update(sag,orta+1,son,x,y,t),bas,son);
}

int ask(){ return ST[1].min; }

void add(int x){
	int wh = wb[x];
	int in = w[wh];
	int l = 0, r = wh; int mid;
	while(l < r){
		mid = l + r >> 1;
		if(mid == l) mid++;
		if(query(1,0,N,wh-mid) <= in)
			l = mid;
		else r = mid - 1;
	}
	int leftmost = wh-l;
	if(query(1,0,N,wh-l) <= in) update(1,0,N,leftmost,wh,in);
}

int main(){
	
	scanf("%d",&n);

	FOR(i,1,3*n){ scanf("%d",&aa[i]); ww[aa[i]] = 1; }
	
	int s = 0;

	foreach(it,ww) it->nd = ++s;

	FOR(i,1,n){ x = ww[aa[i]]; h[x] = 1; if(!wa[x]) wa[x] = i; a[i] = x; } 
	FOR(i,1,n){ x = ww[aa[i+n]]; h[x] = 1; if(!wb[x]) wb[x] = i; b[i] = x; } 
	FOR(i,1,n){ x = ww[aa[i+n+n]]; h[x] = 1; if(!wc[x]) wc[x] = i; c[i] = x; } 

	s = 2 * n;

	FOR(i,1,N){ if(!wb[i]) continue; if(!wc[i]) wc[i] = 2 * n; w[wb[i]] = wc[i]; }
	FOR(i,1,N)  if(wc[i] && !wb[i]){ wb[i] = ++s; w[s] = wc[i]; }

	FOR(i,1,n) cnt[a[i]]++;

	init(1,0,N);
	
	FOR(i,1,N-1) if(!cnt[i] && h[i]){ add(i); }

	ans = ask() + n;

	ROF(i,n,0){
		
		ans = min(ans, ask() + i); 

		if(--cnt[a[i]] == 0){
			
			if(!wc[a[i]] && !wb[a[i]]) break;

			add(a[i]);

		}

	}

	cout << ans << endl;
	
    return 0;
}
