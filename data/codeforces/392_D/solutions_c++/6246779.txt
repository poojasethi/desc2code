#include<cstdio>
#include<set>
#include<algorithm>
using namespace std;
typedef long long ll;
typedef pair<int, int> pr;
#define rep(i,n) for (int i=0;i<n;++i)
#define mk make_pair
#define X first
#define Y second
const int N = 300005;
int n, m, ans, a[N], b[N], c[N], id[N], V[N], A[N], B[N], C[N];
multiset<int> res; set<pr> H;
bool cmp(const int i, const int j){ return A[i]>A[j]; }
void ins(pr z)
{
    set<pr> ::iterator l, i, r = H.lower_bound(z); if (r->Y >= z.Y) return;
    i = H.insert(z).X, l = i, --l, res.erase(res.find(l->X + r->Y)), res.insert(i->X + r->Y);
    while (l->Y < i->Y) r = l--, res.erase(res.find(l->X + r->Y)), H.erase(r);
    res.insert(l->X + i->Y);
}
int main()
{
    scanf("%d", &n);
    rep(i, n) scanf("%d", a + i), V[m++] = a[i];
    rep(i, n) scanf("%d", b + i), V[m++] = b[i];
    rep(i, n) scanf("%d", c + i), V[m++] = c[i];
    sort(V, V + m), m = unique(V, V + m) - V;
    rep(i, n) a[i] = lower_bound(V, V + m, a[i]) - V;
    rep(i, n) b[i] = lower_bound(V, V + m, b[i]) - V;
    rep(i, n) c[i] = lower_bound(V, V + m, c[i]) - V;
    rep(i, m) A[i] = B[i] = C[i] = 3 * n;
    rep(i, n) if (A[a[i]]>n) A[a[i]] = i + 1;
    rep(i, n) if (B[b[i]]>n) B[b[i]] = i + 1;
    rep(i, n) if (C[c[i]]>n) C[c[i]] = i + 1;
    rep(i, m + 1) id[i] = i; A[m] = 0, sort(id, id + m, cmp);
    H.insert(mk(0, 4 * n)), H.insert(mk(4 * n, 0)), res.insert(0), ans = A[*id];
    rep(i, m) ins(mk(B[id[i]], C[id[i]])), ans = min(ans, A[id[i + 1]] + *res.begin());
    printf("%d\n", ans); return 0;
}