#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <queue>
#include <set>
using namespace std;
#define rep(i, l, r) for (int i = l; i <= r; i++)
#define drep(i, r, l) for (int i = r; i >= l; i--)
typedef long long ll;
typedef pair<int, int>pii;
const int N = 1e5 + 8, M = 3e5 + 8, INF = 10 * N;
int n, m, a[N], b[N], c[N], d[M], flag[M], ans;
struct Node
{
    int x, y, p;
    Node(int _x = 0, int _y = 0, int _p = 0){x = _x; y = _y; p = _p;}
    bool operator < (const Node &b) const 
    {
        return x == b.x ? y < b.y : x < b.x;
    }
}coo[M];
struct Point
{
    int x, y, p1, p2;
    Point(){x = y = p1 = p2 = 0;}
    Point(int _x, int _y, int _p1, int _p2){x = _x; y = _y; p1 = _p1; p2 = _p2;}
    bool operator < (const Point &b) const 
    {
        return x + y > b.x + b.y;
    }
};
set<Node>bst;
set<Node>::iterator it, tmpit;
priority_queue<Point>q;
int POS(int x)
{
    return lower_bound(d + 1, d + m + 1, x) - d;
}
void Insert(Node A)
{
    if ((*bst.upper_bound(A)).y >= A.y) return;
    it = (--bst.lower_bound(A)); tmpit = it;
    while ((*it).y <= A.y) --tmpit, bst.erase(it), it = tmpit;
    q.push(Point((*it).x, A.y, (*it).p, A.p));
    it = bst.upper_bound(A);
    q.push(Point(A.x, (*it).y, A.p, (*it).p));
    //printf("(%d %d)\n", A.x, A.y);
    bst.insert(A);
}
bool check(Point A)
{
    if ((*bst.lower_bound(coo[A.p1])).p != A.p1 || (*bst.lower_bound(coo[A.p2])).p != A.p2) return 0;
    return ((*bst.upper_bound(coo[A.p1])).p == A.p2 && (*--bst.lower_bound(coo[A.p2])).p == A.p1);
}
int query()
{
    while (!check(q.top())) q.pop();
    return q.top().x + q.top().y;
}
void solve()
{
    rep(i, 1, n) flag[POS(a[i])]++;
    rep(i, 1, m) coo[i] = Node(INF, INF, i);
    rep(i, 1, n)
    {
        int p = POS(b[i]);
        coo[p].x = min(coo[p].x, i);
        p = POS(c[i]);
        coo[p].y = min(coo[p].y, i);
    }
    //rep(i, 1, m) printf("%d %d %d %d\n", i, d[i], coo[i].x, coo[i].y);
    bst.insert(coo[0] = Node(0, INF + 1, 0));
    bst.insert(coo[m + 1] = Node(INF + 1, 0, m + 1));
    q.push(Point(0, 0, 0, m + 1));
    rep(i, 1, m) if (!flag[i]) Insert(coo[i]);
    ans = 3 * n;
    drep(i, n, 0)
    {
        ans = min(ans, i + query());
        if (!i) break;
        int p = POS(a[i]);
        flag[p]--; 
        if (!flag[p])
        {
            if (coo[p].x <= n || coo[p].y <= n) Insert(coo[p]);
            else break;
        }
    }
    printf("%d\n", ans);
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    //freopen("output.txt", "w", stdout);
#endif
    scanf("%d", &n);
    rep(i, 1, n) scanf("%d", &a[i]), d[++m] = a[i];
    rep(i, 1, n) scanf("%d", &b[i]), d[++m] = b[i];
    rep(i, 1, n) scanf("%d", &c[i]), d[++m] = c[i];
    sort(d + 1, d + m + 1);
    m = unique(d + 1, d + m + 1) - d - 1;
    solve();
#ifndef ONLINE_JUDGE
    fclose(stdin); fclose(stdout);
#endif
    return 0;
}