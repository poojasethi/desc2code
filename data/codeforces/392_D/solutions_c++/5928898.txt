#include <cmath>
#include <map>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <set>
#include <bitset>
#include <memory.h>
#include <functional>
#include <queue>
#include <fstream>
#include <ctime>
#include <deque>
#include <utility>
#include <stack>
#include <sstream>
#include <list>
#include <cctype> 
#include <numeric> 
#include <iomanip>
using namespace std;
#define sqr(_) ((_)*(_))

typedef pair<int, int> Pii;
#define x first
#define y second
#define mp make_pair
#define pb push_back

typedef long long LL;

const int MAXN = 100000 * 3 + 10, INF = 0x3f3f3f0;

int n, N, x[MAXN], y[MAXN], z[MAXN], id[MAXN];
map<int, int> a, b, c;
multiset<int> r;
set<Pii> s;
set<int> app;

void C(int &x)
{
	if (!x) x = INF - 1;
}
bool cmp(int a, int b)
{
	return x[a] > x[b];
}
void Add(int i)
{
	set<Pii>::iterator it = s.lower_bound(mp(y[i], -z[i]));
	set<Pii>::iterator jt = it;
	--jt;
	if (-it -> y >= z[i]) return ;
	r.erase(r.lower_bound(-it -> y + jt -> x));
	set<Pii>::iterator kt = jt;
	for (; -jt -> y <= z[i]; )
	{
		kt = jt; --kt;
		r.erase(r.lower_bound(-jt -> y + kt -> x));
		s.erase(jt);
		jt = kt;
		if (kt == s.begin())
			break;
	}
	s.insert(mp(y[i], -z[i]));
	r.insert(y[i] - it -> y);
	r.insert(z[i] + jt -> x);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout);
#endif
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i)
	{
		int x;
		scanf("%d", &x); app.insert(x);
		if (a.find(x) == a.end())
			a[x] = i;
	}
	for (int i = 1; i <= n; ++i)
	{
		int x;
		scanf("%d", &x); app.insert(x);
		if (b.find(x) == b.end())
			b[x] = i;
	}
	for (int i = 1; i <= n; ++i)
	{
		int x;
		scanf("%d", &x); app.insert(x);
		if (c.find(x) == c.end())
			c[x] = i;
	}
	for (set<int>::iterator it = app.begin(); it != app.end(); ++it)
	{
		int t = *it;
		++N;
		x[N] = a[t], y[N] = b[t], z[N] = c[t];
		C(x[N]), C(y[N]), C(z[N]);
	}
	for (int i = 1; i <= N; ++i)
		id[i] = i;
	sort(id + 1, id + N + 1, cmp);
	int Tohka = x[id[1]];
	r.insert(INF + INF);
	s.insert(mp(0, -INF)), s.insert(mp(INF, 0));
	for (int i = 1; i <= N; ++i)
	{
		if (y[id[i]] == INF - 1 && z[id[i]] == INF - 1)
			break ;
		Add(id[i]);
		if (x[id[i]] != x[id[i + 1]])
			Tohka = min(Tohka, x[id[i + 1]] + *r.begin());
	}
	cout << Tohka << endl;
	fclose(stdin);
	fclose(stdout);
	return 0;
}
