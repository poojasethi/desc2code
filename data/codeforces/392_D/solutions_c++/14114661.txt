#include <stdio.h>
#include <algorithm>
#include <set>
using namespace std;
#define INF 1000000010
#define MAXN 100010
#define mk make_pair

set <pair<int,int> > pontos; //<x+y,y>
set <pair<int,int> > regioes;       // <x,y>    
pair<int,int> exc[3*MAXN];
set <pair<int,int> >::iterator it,it2;  
pair<int,pair<int,int> > lim[3*MAXN];   //<z,<x,y>>
pair<int,pair<int,int> > vet[3*MAXN];   //<valor,<vetor,posicao>>
int n,tam,resp=INF,yant,exc_ant,exc_at;

int main(){
    scanf("%d",&n);
    for(int i=0,aux;i<3*n;i++){
        scanf("%d",&aux);
        vet[i]=mk(aux,mk(i/n,i%n+1));
    }
    sort(vet,vet+3*n);
//  for(int i=0;i<3*n;i++){
//      printf("%d %d %d\n",vet[i].first,vet[i].second.first,vet[i].second.second);
//  }
    lim[0]=mk(INF,mk(INF,INF));
    
    if(vet[0].second.first==0) lim[0].first=vet[0].second.second;
    else if(vet[0].second.first==1) lim[0].second.first=vet[0].second.second;
    else lim[0].second.second=vet[0].second.second;
    
    for(int i=1;i<3*n;i++){
        if(vet[i].first!=vet[i-1].first){
            tam++;
            lim[tam]=mk(INF,mk(INF,INF));
        }
        if(vet[i].second.first==0) lim[tam].first = min( vet[i].second.second , lim[tam].first );
        else if(vet[i].second.first==1) lim[tam].second.first = min( vet[i].second.second , lim[tam].second.first );
        else lim[tam].second.second = min( vet[i].second.second , lim[tam].second.second );
    }
    tam++;
    sort(lim,lim+tam);
    pontos.insert(mk(0,0));
    regioes.insert(mk(0,INF+1));
    regioes.insert(mk(INF+1,0));
    resp=lim[tam-1].first;
    for(int i=tam-1;i>=0;i--){
        it=regioes.lower_bound(lim[i].second);
        yant=(*it).second;
        if((*it).second<lim[i].second.second){
            pontos.insert(mk(lim[i].second.first+yant,yant));
            it--;
            while((*it).second<=lim[i].second.second){
//              printf("%d %d\n",(*it).first,(*it).second);
                exc[exc_at]=(*it);
                exc_at++;
                pontos.erase(mk((*it).first+yant,yant));
                yant=(*it).second;
                it--;
            }
            pontos.erase(mk((*it).first+yant,yant));
            pontos.insert(mk((*it).first+lim[i].second.second,lim[i].second.second));
            for(;exc_ant<exc_at;exc_ant++){
                regioes.erase(exc[exc_ant]);
            }
            regioes.insert(lim[i].second);
        }
        it=pontos.begin();
        if(i!=0) resp=min(resp,lim[i-1].first+(*it).first);
        else resp=min(resp,(*it).first);
        
//          printf("\n%d\n",pontos.size());
//          printf("%d : %d %d %d\n",i,lim[i].first,lim[i].second.first,lim[i].second.second);
//          for(it2=pontos.begin();it2!=pontos.end();it2++){
//              printf("%d %d\n",it2->first-it2->second,it2->second);
//          }
//          printf("*%d %d -- %d\n",lim[i].first,(*it).first,resp);
    }
    printf("%d\n",resp);
    return 0;
}
            
            
