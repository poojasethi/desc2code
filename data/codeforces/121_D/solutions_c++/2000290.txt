# include <iostream>
# include <iomanip>
# include <algorithm>
# include <fstream>
# include <string>
# include <queue>
# include <vector>
# include <map>
# include <set>
# include <cstring>

# define PLL pair<long long,long long>
# define FF first
# define SS second
# define LL long long
# define PB push_back
using namespace std;
const int MAX_N=10*100*1000+10;
const LL INF=(1000000000LL)*(1000000000LL)+10;
LL N,K;
vector<LL> Lucky;
PLL seg[MAX_N];
LL R[MAX_N],L[MAX_N];
vector<PLL> Temp;
LL Ans[MAX_N];
LL Mul(LL A,LL B)
{
	if((long double)A <= (long double)INF/(long double)B)
	{
		LL S=A*B;
		if(S<0 || S>=INF)
				return INF;
		return S;
	}
	return INF;
}
void FillLucky()
{
	Lucky.PB(4);
	Lucky.PB(7);
	LL  prev=2;
	for(int i=0;i<17;i++)
	{
		LL SZ=(int)Lucky.size();
		for(int j=SZ-prev;j<SZ;j++)
			Lucky.PB(Lucky[j]*10LL+4LL),
			Lucky.PB(Lucky[j]*10LL+7LL);
		prev*=2;
	}
	sort(Lucky.begin(),Lucky.end());
}
void FillL()
{
	Temp.clear();
	LL C=0;
	memset(Ans,0,sizeof(Ans));
	for(int i=0;i<(int)Lucky.size();i++)
		Temp.PB(PLL(Lucky[i],i));
	for(int i=0;i<N;i++)
		Temp.PB(PLL(seg[i].SS,-1));
	sort(Temp.begin(),Temp.end());
	for(int i=0;i<(int)Temp.size();i++)
	{
		if(i!=0)
			Ans[i]=Ans[i-1]+Mul((Temp[i].FF-Temp[i-1].FF),C),
			Ans[i]=(Ans[i]>INF?INF:Ans[i]);
		if(Temp[i].SS==-1)
				C++;
		else
			L[Temp[i].SS]=Ans[i];
	}

}
void FillR()
{
	Temp.clear();
	LL C=0;
	memset(Ans,0,sizeof(Ans));
	for(int i=0;i<(int)Lucky.size();i++)
		Temp.PB(PLL(Lucky[i],-i));
	for(int i=0;i<N;i++)
		Temp.PB(PLL(seg[i].FF,1));
	sort(Temp.begin(),Temp.end());
	reverse(Temp.begin(),Temp.end());
	for(int i=0;i<(int)Temp.size();i++)
	{
		if(i!=0)
			Ans[i]=Ans[i-1]+Mul((Temp[i-1].FF-Temp[i].FF),C),
			Ans[i]=(Ans[i]>INF?INF:Ans[i]);
		if(Temp[i].SS==1)
				C++;
		else
			R[-Temp[i].SS]=Ans[i];
	}
}
int main()
{
	ios::sync_with_stdio(false);
	FillLucky();
	cin >> N >> K;	
	LL MNSEG=INF;
	for(int i=0;i<N;i++)
		cin >> seg[i].FF >> seg[i].SS,
		MNSEG=min(MNSEG,seg[i].SS-seg[i].FF+1);	
	FillR();
	FillL();
	int i=0,j=0;
	int Ans=0;
	while(j<(int)Lucky.size())
	{
		while(i<j && ((L[j]+R[i])>K || (Lucky[j]-Lucky[i]+1)>MNSEG ) ) i++;
		if((L[j]+R[i])<=K && (Lucky[j]-Lucky[i]+1)<=MNSEG) Ans=max(Ans,j-i+1);
		j++;
	}
	cout<<Ans<<endl;
	return 0;
}
	 		   	 	 		       	 	 		