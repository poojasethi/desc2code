#include <bits/stdc++.h>

using namespace std;

#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)

#define type(x) __typeof(x.begin())

#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair < long long , long long > pii;

typedef long long ll;

const long long linf = 2e18+5;
const int mod = (int) 1e9 + 7;
const int logN = 17;
const int inf = 1e9;
const int N = 580000;

#define int ll

int s, k, n, m, x, y, z, lucky[N], mx, ans;
pii a[200002];
double L[N], R[N];
vector< ll > l, r;

int ctr(int x, int y) {
    return (L[x] + R[y]) <= ::k;
}

inline void make(ll x) {
    if(x < 0) return ;
    if(x) lucky[++s] = x;
    if(x * 10.0 >= linf) return ; 
    make(x * 10LL + 7);
    make(x * 10LL + 4);
}

 main() {

    make(0);

	assert(N >= s);
	
    sort(lucky+1, lucky+s+1);

    scanf("%lld %lld",&n, &k);

    mx = linf;

    FOR(i, 1, n) {
        scanf("%lld %lld", &a[i].st, &a[i].nd);
        mx = min(mx, a[i].nd - a[i].st + 1);
        l.pb(a[i].st);
        r.pb(a[i].nd);
    }
    sort(l.begin(), l.end());
    sort(r.begin(), r.end());

    int j = n;
    double sum = 0;
    ROF(i, s, 1) {
        while(j > 0 && l[j-1] >= lucky[i]) { sum += l[--j]; }
        L[i] = sum - lucky[i] * (1.0*n-j);
    }
    j = -1;
    sum = 0;
    FOR(i, 1, s) {
        while(j + 1 < n && r[j+1] <= lucky[i]) sum += r[++j];
        R[i] = (1.0 * (j+1) * lucky[i]) - sum;
    }
    j = 0;
    FOR(i, 1, s) {
        while(lucky[j]-lucky[i]+1 > mx) j--;
        while(ctr(i, j+1) && lucky[j+1]-lucky[i]+1 <= mx && j+1 <= s) j++;
        ans = max(ans, j-i+1);
    }

	assert(ans <= mx);

    printf("%lld\n", ans);

 }
