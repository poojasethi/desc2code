#include<cstdio>
#include<cmath>
#include<cstring>
#include<vector>
#define rep(i,n) for(int i=0;i<n;i++)
#define pb push_back
#define eps 1e-10
#define border 1e8
#define inf 1e9
using namespace std;
struct edge{
	int to,cap,rev;
	double cost;
};
int n,S,T;
vector<edge> g[888];
int x[444],y[444];
bool vis[888];
double slk,ans;
inline double sqr(int x){
	return x*x*1.0;
}
inline double dist(int i,int j){
	return sqrt(sqr(x[i]-x[j])+sqr(y[i]-y[j]));
}
inline void add_edge(int from,int to,int cap,double cost){
	edge tmp;
	tmp.to=to;
	tmp.cap=cap;
	tmp.cost=cost;
	tmp.rev=g[to].size();
	g[from].pb(tmp);
	tmp.to=from;
	tmp.cap=0;
	tmp.cost=-cost;
	tmp.rev=g[from].size()-1;
	g[to].pb(tmp);
	return;
}
inline int dfs(int u,int m){
	if(u==T){
		ans+=slk*(m*1.0);
		return m;
	}
	vis[u]=1;
	int l=m;
	rep(i,g[u].size()){
		int v=g[u][i].to;
		int f=g[u][i].cap;
		if(!vis[v] && g[u][i].cost<eps && g[u][i].cost>-eps && f>0){
			f=dfs(v,m<f?m:f);
			l-=f;
			g[u][i].cap-=f;
			g[v][g[u][i].rev].cap+=f;
			if(!l)
				return m;
		}
	}
	return m-l;
}
inline bool modlable(){
	double mini=inf;
	rep(i,n)
		if(vis[i])
			rep(j,g[i].size())
				if(g[i][j].cap>0 && !vis[g[i][j].to]){
					double t=g[i][j].cost;
					if(t<mini)
						mini=t;
				}
	if(mini>border)
		return 0;
	rep(i,n)
		if(vis[i])
			rep(j,g[i].size()){
				g[i][j].cost-=mini;
				g[g[i][j].to][g[i][j].rev].cost+=mini;
			}
	slk+=mini;
	return 1;
}
inline void zkw(){
	int flow=n-1;
	n=T+1;
	while(1){
		while(1){
			memset(vis,0,sizeof(vis));
			int f=dfs(S,flow);
			flow-=f;
			if(!f)
				break;
		}
		if(!flow || !modlable())
			break;
	}
	if(flow)
		puts("-1");
	else
		printf("%.6lf\n",ans);
	return;
}
int main(){
	scanf("%d",&n);
	rep(i,n)
		scanf("%d%d",x+i,y+i);
	S=n<<1;
	T=S|1;
	rep(i,n){
		add_edge(S,i,1,0);
		add_edge(i+n,T,2,0);
		rep(j,n)
			if(y[i]<y[j])
				add_edge(i,j+n,1,dist(i,j));
	}
	zkw();
	return 0;
}
