#include <bits/stdc++.h>

using namespace std;

int dx[]={0, 0, 1, -1};
int dy[]={1, -1, 0, 0};

typedef pair<int, int> pii;
typedef long long INT;

template <class T> inline void smin(T &a, T b) {if (a>b) a=b;}
template <class T> inline void smax(T &a, T b) {if (a<b) a=b;}
#define NN 1111
#define inf 0x3f3f3f3f
#define sq(x) ((x)*(x))

int qf, qb, q[11111111];
int adj[NN][NN], cap[NN][NN], deg[NN], pre[NN];
double wei[NN][NN], dst[NN], x[NN], y[NN];
int make_edge(int u, int v, int c, double w) {
	adj[u][deg[u]++]=v;
	adj[v][deg[v]++]=u;
	wei[u][v]=w; wei[v][u]=-w;
	cap[u][v]=c;
}

int max_flow(int src, int tar, double &res) {
	int u, v, bot, flow=0, i;
	res=0;
	while (1) {
		for (i=0; i<=tar; i++) dst[i]=1e10;
		dst[src]=0;
		qf=qb=0;
		q[qb++]=src; 
		while (qf<qb) {
			u=q[qf++];
			for (i=0; i<deg[u]; i++) {
				v=adj[u][i];
				if (cap[u][v]<1) continue;
				if (dst[v]>dst[u]+wei[u][v]) {
					dst[v]=dst[u]+wei[u][v];
					pre[v]=u;
					q[qb++]=v;
				}
			}
		}
		if (dst[tar]>1e10-10) return flow;
		bot=inf;
		for (u=tar; u!=src; u=pre[u]) {
			bot=min(bot, cap[pre[u]][u]);
		}
		flow+=bot;
		res+=bot*dst[tar];
		for (u=tar; u!=src; u=pre[u]) {
			cap[pre[u]][u]-=bot;
			cap[u][pre[u]]+=bot;
		}
	}
}

double calc_d(int u, int v) {
	return sqrt(sq(x[u]-x[v])+sq(y[u]-y[v]));
}

int main() {
	
	int N, i, j, src, tar;
	double res;
	
	scanf("%d", &N);
	for (i=0; i<N; i++) scanf("%lf%lf", x+i, y+i);
	
	src=N*2; tar=src+1;
	
	for (i=0; i<N; i++) make_edge(src, i, 2, 0);
	
	for (i=0; i<N; i++) for (j=0; j<N; j++) {
		if (y[j]<y[i]) make_edge(i, j+N, 1, calc_d(i, j));
	}
	for (i=0; i<N; i++) make_edge(i+N, tar, 1, 0);
	
	if (max_flow(src, tar, res)==N-1) printf("%.10lf\n", res);
	else puts("-1");
	
	return 0;
}
        