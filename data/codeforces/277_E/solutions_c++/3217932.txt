#include <cmath>
#include <cstring>
#include <iostream>
#include <iomanip>
#include <algorithm>
#include <queue>
#include <vector>

using namespace std;

const double INF = 1000000000;

int N;
int X[802], Y[802];
int C[802][802], F[802][802];
vector<pair<int, double> > V[802];
int T[802];
double cost[802], result;
bool is[802];
queue<int> Q;

double getdist(int i1, int i2)
{
	return sqrt(pow(X[i1] - X[i2], 2) + pow(Y[i1] - Y[i2], 2));
}

bool findPath()
{
	memset(is, 0, sizeof(is));
	for (int i = 1; i <= 2 * N + 1; ++i)
		cost[i] = INF;
	
	cost[0] = 0;
	Q.push(0);
	is[0] = true;
	
	while (!Q.empty())
	{
		int now = Q.front();
		is[now] = false;
		
		for (vector<pair<int, double> >::iterator it = V[now].begin(); it != V[now].end(); ++it)
			if (F[now][it->first] < C[now][it->first] && cost[now] + it->second < cost[it->first])
			{
				cost[it->first] = cost[now] + it->second;
				T[it->first] = now;
				
				if (!is[it->first])
				{
					Q.push(it->first);
					is[it->first] = true;
				}
			}
		
		Q.pop();
	}
	
	if (cost[2 * N + 1] == INF) return false;
	
	result += cost[2 * N + 1];
	for (int now = 2 * N + 1; now != 0; now = T[now])
		++F[T[now]][now], --F[now][T[now]];
	
	return true;
}

int main()
{
	cin >> N;
	for (int i = 1; i <= N; ++i)
		cin >> X[i] >> Y[i];
	
	for (int i = 1; i <= N; ++i)
	{
		V[0].push_back(make_pair(i, 0));
		V[N + i].push_back(make_pair(2 * N + 1, 0));
		
		C[0][i] = 2;
		C[N + i][2 * N + 1] = 1;
		for (int j = 1; j <= N; ++j)
			if (Y[i] > Y[j])
			{
				C[i][N + j] = 1;
				V[i].push_back(make_pair(N + j, getdist(i, j)));
				V[N + j].push_back(make_pair(i, -getdist(i, j)));
			}
	}
	
	while (findPath());
	
	int without = 0;
	for (int i = 1; i <= N; ++i)
		if (F[N + i][2 * N + 1] == 0)
			++without;
	
	if (without > 1)
	{
		cout << -1 << '\n';
		return 0;
	}
	
	cout << fixed << setprecision(8) << result << '\n';
}
