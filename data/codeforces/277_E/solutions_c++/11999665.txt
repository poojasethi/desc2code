#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
typedef double dou;
const int N=1000;
const int M=5E5+5;
const int inf=1E8;
struct map{
    int x,y,c;
    dou w;
}A[M],a[M];
int n,m,fir[N],next[M],k=-1,x,y,s,t,pre[N],w;
dou f[N],ans;
bool o[N];
queue <int> q;

int comp(const map&a,const map&b)
{
    return a.y>b.y;
}

void add(int x,int y,int c,dou w)
{
//  printf("%d %d %d %.3f\n",x,y,c,w);
    k++; a[k].x=x; a[k].y=y; a[k].c=c; a[k].w=w; next[k]=fir[x]; fir[x]=k;
    swap(x,y);
    k++; a[k].x=x; a[k].y=y; a[k].c=0; a[k].w=-w; next[k]=fir[x]; fir[x]=k;
}

void spfa()
{
    while (1)
    {
        q.push(s);
        for (int i=0;i<=t;i++) f[i]=inf; f[s]=0; pre[s]=-1;
        while (!q.empty())
        {
            x=q.front(); q.pop(); o[x]=0;
            for (int i=fir[x];i!=-1;i=next[i]) if (a[i].c&&f[y=a[i].y]>f[x]+a[i].w)
            {
                f[y]=f[x]+a[i].w;
                pre[y]=i;
                if (!o[y]) { o[y]=1; q.push(y); }
            }
        }
        if (f[t]==f[0]) break;
        for (int i=pre[t];i!=-1;i=pre[a[i].x])
        {
            a[i].c--; a[i^1].c++;
            ans+=a[i].w;
        }
    }
    for (int i=fir[t];i!=-1;i=next[i]) if (a[i^1].c) ans=-1;
}

dou dis(int i,int j) 
{
    return sqrt((dou(A[i].x-A[j].x)*(A[i].x-A[j].x))+(A[i].y-A[j].y)*(A[i].y-A[j].y));
}

int main()
{
    memset(fir,-1,sizeof(fir));
    cin>>n; s=2*n+1; t=s+1;
    for (int i=1;i<=n;i++) scanf("%d%d",&A[i].x,&A[i].y);
    sort(A+1,A+n+1,comp);
    for (int i=1;i<=n;i++)
    {
        add(s,i,2,0); if (i!=1) add(i+n,t,1,0);
        for (int j=i+1;j<=n;j++) if (A[i].y>A[j].y) add(i,j+n,1,dis(i,j));
    }
    spfa();
    if (ans==-1) cout<<-1<<endl; else printf("%.7f\n",ans);
}



