//This is the painkiller...
#include <bits/stdc++.h>
using namespace std;
#define mem(a,v) memset(a,v,sizeof(a))
#define pb push_back
#define mp make_pair
#define sz(x) int((x).size())
#define x first
#define y second
#define all(a) (a).begin(),(a).end()
#define rep(i,n) for(int i=0;i<int(n);i++)
#define repi(i,a,n) for(int i=int(a);i<int(n);i++)
#define repe(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)

typedef long long ll;
typedef pair<int,int> pii;
typedef vector<int> vi;

const int maxNode=805;
double D[maxNode];
int parent[maxNode],n;
int R[maxNode][maxNode];
double cost[maxNode][maxNode];

int augment(int s,int t)
{
	fill(D,D+maxNode,1e13);
	priority_queue<pair<double,int> > Q;
	D[s]=0.0;
	Q.push(mp(-D[s],s));
	mem(parent,-1);
	while(!Q.empty())
	{
		int u=Q.top().y;
		double w=-Q.top().x;
		Q.pop();
		if(w>D[u])continue;
		if(u==t)break;
		rep(v,n)if(R[u][v]>0)
		{
			if(D[v]>D[u]+cost[u][v])
			{
				parent[v]=u;
				D[v]=D[u]+cost[u][v];
				Q.push(mp(-D[v],v));
			}
		}
	}
	int g=t;
	int f=INT_MAX;
	while(parent[g]!=-1)
	{
		f=min(f,R[parent[g]][g]);
		g=parent[g];
	}
	g=t;
	while(parent[g]!=-1)
	{
		R[parent[g]][g]-=f;
		R[g][parent[g]]+=f;
		cost[g][parent[g]]-=cost[parent[g]][g];
		g=parent[g];
	}
	if(f==INT_MAX)f=0;
	return f;
}

int flow(int s,int t,double &cst)
{
	cst=0;
	int flow=0,f=0;
	while((f=augment(s,t))!=0)
	{
		flow+=f;
		cst+=D[t];
	}
	return flow;
}

double dis(pii a,pii b)
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}

int main()
{
	//~ freopen("input.txt","r",stdin);
	std::ios_base::sync_with_stdio(false);
	cout.precision(20);
	cout.setf(ios::fixed);
	int m;
	cin>>m;
	vector<pii> p(m);
	rep(i,m)cin>>p[i].y>>p[i].x;
	sort(all(p));
	reverse(all(p));
	rep(i,m)rep(j,m)if(p[i].x>p[j].x)
	{
		R[i][m+j]=1;
		cost[i][j+m]=dis(p[i],p[j]);
	}
	int s=2*m,t=s+1;
	n=t+1;
	rep(i,m)
	{
		R[s][i]=2;
		cost[s][i]=0;
		R[i+m][t]=1;
		cost[i+m][t]=0;
	}
	double ans=0;
	int f=flow(s,t,ans);
	if(f!=m-1)ans=-1;
	cout<<ans;
	return 0;
}