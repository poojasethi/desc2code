#include <cstdio>
#include <vector>
#include <cmath>
#include <queue>
using namespace std;

#define N 802
#define INF 0x3f3f3f3f

int flow[N][N], cap[N][N], lim[N], id[N], pre[N];
double cost[N][N], dist[N];
vector<int> adj[N]; vector<double> wei[N];

int vet[N][2];

pair<double, int> maxFlowMinCost(int S, int T, int n)
{
	for (int i = 0; i < n; ++i)
		for (int j = 0; j < n; ++j)
			if (cap[i][j]) 
				adj[i].push_back(j), wei[i].push_back(cost[i][j]),
				adj[j].push_back(i), wei[j].push_back(-cost[i][j]);

	pair<double, int> res = make_pair(0, 0);
	
	while (1)
	{
		for (int i = 0; i < n; ++i)
		{
			dist[i] = lim[i] = INF;
			id[i] = 0; pre[i] = -1;
		}
		deque<int> que;
		dist[S] = 0;
		que.push_front(S);
		while (!que.empty())
		{
			int p = que.front();
			que.pop_front();
			id[p] = 2;
			for (int i = 0; i < adj[p].size(); ++i)
			{
				int v = adj[p][i];
				int f = cap[p][v]-flow[p][v];
				if (f)
				{
					double c = wei[p][i]+dist[p];
					if (c < dist[v])
					{
						dist[v] = c;
						que.push_back(v);
						if (id[i] == 0) que.push_back(v);
						else if (id[i] == 2) que.push_front(v);
						id[v] = 1;
						pre[v] = p;
						lim[v] = min(lim[p], f);
					}
				}
			}
		}
		if (dist[T] > INF-1) break;
		res.first += dist[T];
		int f = lim[T];
		res.second += f;
		for (int p = T; p != S; p = pre[p])
			flow[pre[p]][p] += f, flow[p][pre[p]] -= f;
	}
	
	return res;
}

int main()
{
	int n;
	scanf("%d", &n);
	
	for (int i = 0; i < n; ++i)
		scanf("%d%d", &vet[i][0], &vet[i][1]);
	
	for (int i = 0; i < n; ++i)
	{
		// in, cost is 0
		cap[0][i+2] = 2;
		// out, cost is 0
		cap[n+i+2][1] = 1;
	}
	
	for (int i = 0; i < n; ++i)
	{
		for (int j = 0; j < n; ++j) if (vet[i][1] > vet[j][1])
		{
			double dist = hypot(vet[i][0]-vet[j][0], vet[i][1]-vet[j][1]);
			cap[i+2][n+j+2] = 1;
			cost[i+2][n+j+2] = dist;
		}
	}
	
	pair<double, int> res = maxFlowMinCost(0, 1, 2*n+2);
	//printf("flow is %d\n", res.second);
	if (res.second < n-1) printf("-1\n");
	else printf("%.10lf\n", res.first);
}

