#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>
#define sqr(x) (x)*(x)
#define N 250000
#define inf 1000000000
#define For(i,l,r) for(int i=l;i<=r;i++)
using namespace std;
struct rec{int x,y;}E[N];
double dist(int i,int j){return sqrt( sqr(E[i].x-E[j].x) + sqr(E[i].y-E[j].y) );}
int n,S,T;
struct network{
    int next[N],son[N],ed[N],cap[N],q[N],from[N]; double co[N],dis[N];
    int cnt,st,en; bool inq[N];
    void link(int x,int y,int z,double c){
        next[++cnt]=son[x]; son[x]=cnt; ed[cnt]=y; cap[cnt]=z; co[cnt]=c;
        next[++cnt]=son[y]; son[y]=cnt; ed[cnt]=x; cap[cnt]=0; co[cnt]=-c;
    }
    bool SPFA(){
        st=en=0; For(i,1,T) dis[i]=inf;
        q[++en]=S; dis[S]=0;
        while(st<en){
            int u=q[++st]; inq[u]=0;
            for(int i=son[u];i;i=next[i]){
                int v=ed[i];
                if(dis[v]>dis[u]+co[i] && cap[i]){
                    dis[v]=dis[u]+co[i]; from[v]=i;
                    if(!inq[v]) q[++en]=v,inq[v]=1;
                }
            }
        }
        if(dis[T]>=inf) return 0;
        return 1;
    }
    void costflow(){
        double cost=0; int flow=0;
        while(SPFA()){
            int ret=inf;
            for(int now=T;now!=S;now=ed[now^1]){
                now=from[now],ret=min(ret,cap[now]);
            }
            for(int now=T;now!=S;now=ed[now^1]){
                now=from[now];
                cost+=ret*co[now];
                cap[now]-=ret;
                cap[now^1]+=ret;
            }
            flow+=ret;
        }
        if(flow==n-1) printf("%.8lf\n",cost);
        else printf("-1\n");
    }
}Network;
int main(){
    scanf("%d",&n); Network.cnt=1;
    For(i,1,n) scanf("%d%d",&E[i].x,&E[i].y);
    For(i,1,n) For(j,1,n) if(E[i].y>E[j].y) Network.link(i,j+n,1,dist(i,j));
    S=2*n+1; T=2*n+2;
    For(i,1,n) Network.link(S,i,2,0);
    For(i,1,n) Network.link(i+n,T,1,0);
    Network.costflow();
}