#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>
#include <cmath>
#define INF 1005
#define inf 0x0f0f0f0f
#define dinf 10e9

using namespace std;
struct EDGE {
    int i,c;    double d;
    EDGE *next,*ani;
}   *Edge[INF],*Path[INF],E[INF*INF];
struct DOT {
    int i,j;
}   Dot[INF];
int FLOW,Cnt;
double Dis[INF];
bool Inq[INF];
double Dist(double x1,double y1,double x2,double y2)
{
    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
void Add(int i,int j,int c,double d)
{
    E[++Cnt].i=j,E[Cnt].c=c,E[Cnt].d=d,E[Cnt].ani=&E[Cnt+1],
    E[Cnt].next=Edge[i],Edge[i]=&E[Cnt];
    E[++Cnt].i=i,E[Cnt].c=0,E[Cnt].d=-d,E[Cnt].ani=&E[Cnt-1],
    E[Cnt].next=Edge[j],Edge[j]=&E[Cnt];
}
int SPFA(int s,int end)
{
    int i,j; queue <int> q;
    for (i=0;i<INF;i++)
        Dis[i]=dinf;
    memset(Inq,true,sizeof(Inq));
    for (Dis[s]=0.0,Inq[s]=0,q.push(s);!q.empty();)
    {
        i=q.front(),q.pop(),Inq[i]=true;
        for (EDGE *p=Edge[i];p;p=p->next)
            if (p->c && Dis[j=p->i]>Dis[i]+p->d)
                if (Path[j]=p,Dis[j]=Dis[i]+p->d,Inq[j])
                    Inq[j]=0,q.push(j);
    }
    return (Dis[end]<inf);
}
double Min_cost_flow(int s,int end)
{
    int i,flow;
    double cost=0.0;
    while (SPFA(s,end))
    {
        for (flow=inf,i=end;i;i=Path[i]->ani->i) 
            flow=min(flow,Path[i]->c);
        for (cost+=Dis[end]*double(flow),i=end;i;i=Path[i]->ani->i)
            Path[i]->c-=flow,Path[i]->ani->c+=flow;
        FLOW+=flow;
    }
    return cost;
}
int main()
{
    int i,j,n;
    double ans;
    for (i=scanf("%d",&n);i<=n;i++)
        scanf("%d%d",&Dot[i].i,&Dot[i].j);
    for (i=1;i<=n;i++)
        for (j=1,Add(0,i,2,0.0),Add(i+n,801,1,0.0);j<=n;j++)
            if (Dot[i].j>Dot[j].j)
                Add(i,j+n,1,Dist(Dot[i].i,Dot[i].j,Dot[j].i,Dot[j].j));
    if (ans=Min_cost_flow(0,801),FLOW==n-1)
        printf("%.10f\n",ans);
    else puts("-1");
    return 0;
}
