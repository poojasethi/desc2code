#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>

using namespace std;

const double INF = 1e20;
const double eps = 1e-10;

int n,S,T;
int x[410],y[410];
struct Node{
	int v,c;double cost;
	Node *nxt,*twin;
}pool[1000100],*tail=pool,*g[810],*pre[810];
double d[810];
int flow[810];

inline double sqr(int x){return 1.0*x*x;}
inline void make_edge(int u,int v,int c,double cost){
	tail->v=v;tail->c=c;tail->cost=cost; tail->twin=tail+1;tail->nxt=g[u];g[u]=tail++;
	tail->v=u;tail->c=0;tail->cost=-cost;tail->twin=tail-1;tail->nxt=g[v];g[v]=tail++;
}
int spfa(){
	queue<int> q;
	static int inq[810];
	q.push(S);for(int i=1;i<=T;i++) d[i]=INF;
	memset(inq,0,sizeof(inq));inq[S]=1;
	memset(flow,0,sizeof(flow));flow[S]=0x3f3f3f3f;
	memset(pre,0,sizeof(pre));
	while(!q.empty()){
		int u=q.front();q.pop();inq[u]=0;
		for(Node *p=g[u];p;p=p->nxt) if(p->c>0 && p->cost+d[u]-d[p->v]<-eps){
			d[p->v]=p->cost+d[u];pre[p->v]=p;flow[p->v]=min(p->c,flow[u]);
			if(!inq[p->v]) q.push(p->v),inq[p->v]=1;
		}
	}
	return INF-d[T]>eps;
}
double aug(int &dt){
	double D=d[T]*flow[T];dt-=flow[T];
	for(Node *p=pre[T];p;p=pre[p->twin->v]) p->c-=flow[T],p->twin->c+=flow[T];
	return D;
}
double costFlow(int &dt){
	double res=0;dt=n;
	while(spfa()) res+=aug(dt);
	return res;
}
int main()
{
	scanf("%d",&n);S=0,T=n*2+1;
	for(int i=1;i<=n;i++) scanf("%d%d",&x[i],&y[i]),make_edge(S,i,1,0),make_edge(i+n,T,2,0);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(y[i]<y[j]) make_edge(i,j+n,1,sqrt(sqr(x[i]-x[j])+sqr(y[i]-y[j])));
	int flag=0;
	//if(n==400) return puts("-1"),0;
	double res=costFlow(flag);
	if(flag<=1) printf("%.15lf\n",res); else puts("-1");
	return 0;
}
