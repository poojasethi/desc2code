#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>
#include <set>
#include <map>

#define ps system("pause")
#define message printf("*\n")
#define pb push_back
#define X first
#define Y second
#define sqr(x) ((x)*(x))
#define REP(i,n) for (int i=1;i<=n;++i)

using namespace std;

const double INF=1e12;
const int MAXN=880;

struct EDGE{
	int s,e,w,next;double c;
}v[MAXN*MAXN];

double ans,d[MAXN];
int x[MAXN],y[MAXN];
int n,t=1;
int way[MAXN],first[MAXN],line[MAXN<<4];
bool boo[MAXN];

void Add(int x,int y,int water,double cost) {
	v[++t].s=x; v[t].e=y; v[t].w=water; v[t].c=cost;
	v[t].next=first[x]; first[x]=t;
	v[++t].s=y; v[t].e=x; v[t].c=-cost;
	v[t].next=first[y]; first[y]=t;
}

double Dist(int i,int j) {
	return sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
}

void spfa() {
	for (int l=1,r=1;l<=r;++l) {
		for (int p=first[line[l]];p;p=v[p].next)
			if ((v[p].w)&&(d[v[p].e]>d[line[l]]+v[p].c)) {
				d[v[p].e]=d[line[l]]+v[p].c;
				way[v[p].e]=p;
				if (!boo[v[p].e]) {
					line[++r]=v[p].e;
					boo[v[p].e]=true;
				}
			}
		boo[line[l]]=false;
	}
}

void ret(int k) {
	if (k) ret(v[way[k]].s);
	ans+=v[way[k]].c;
	--v[way[k]].w;
	++v[way[k]^1].w;
}

int main() {
	scanf("%d",&n);
	REP(i,n) scanf("%d%d",&x[i],&y[i]);
	REP(i,n) Add(0,i,2,0.0);
	REP(i,n) REP(j,n)
		if (y[i]>y[j]) Add(i,n+j,1,Dist(i,j));
	REP(i,n) Add(n+i,n+n+1,1,0.0);
	REP(i,n-1) {
		REP(i,n+n+1) d[i]=INF;
		memset(boo,0,sizeof boo);
		spfa();
		if (d[n+n+1]==INF) {
			puts("-1");
			return 0;
		} else
			ret(n+n+1);
	}
	printf("%.12lf\n",ans);
	return 0;
}
