import sys

def compute_min(i, trees, k):
    ctr = 0
    acts = []
    for j in range(len(trees)):
        new_h = trees[i] + (j-i) * k
        if new_h <= 0:
            return -1, []
        else:
            if trees[j] != new_h:
                ctr += 1
                diff = trees[j] - new_h
                if diff > 0:
                    acts.append("- " + str(j+1) + " " + str(diff))
                else:
                    acts.append("+ " + str(j+1) + " " + str(-diff))

    return ctr, acts



if __name__ == "__main__":
    line = sys.stdin.readline()
    items = line.split()
    n = int(items[0])
    k = int(items[1])
    line = sys.stdin.readline()
    trees = line.split()
    trees = [int(e) for e in trees]
    
    min_step = 1000000
    opti_acts = []
    # fix ith height
    for i in range(n):
        step, actions = compute_min(i, trees, k)
        if step >= 0 and step < min_step:
            min_step = step
            opti_acts = actions

    print min_step
    
    for act in opti_acts:
        print act
    
