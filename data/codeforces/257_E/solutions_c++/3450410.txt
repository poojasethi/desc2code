#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

typedef long long int lint;

int absolut(int x)
{
  if (x<0) return -x;
  return x;
}

const int limite=1000000;

int suma[limite];
vector<int> sale[limite];
vector<int> entra[limite];
int primero,tope;
int n,m;
int t[limite];
int s[limite];
int f[limite];
lint sol[limite];

int findfloorle(int pos)
{
  pos+=primero;
  for (;;) {
    if (pos%2==1 and suma[pos-1]>0) {
      pos--;
      break;
    }
    pos/=2;
  }
  while (pos<primero) {
    if (suma[2*pos+1]>0) pos=2*pos+1;
    else pos=2*pos;
  }
  return pos-primero;
}

int findfloorri(int pos)
{
  pos+=primero;
  for (;;) {
    if (pos%2==0 and suma[pos+1]>0) {
      pos++;
      break;
    }
    pos/=2;
  }
  while (pos<primero) {
    if (suma[2*pos]>0) pos=2*pos;
    else pos=2*pos+1;
  }
  return pos-primero;
}

int sumaantes(int pos)
{
  pos+=primero;
  int num=suma[pos];
  while (pos>1) {
    if (pos%2==1)
      num+=suma[pos-1];
    pos/=2;
  }
  return num;
}

void actualiza(int pos)
{
  pos+=primero;
  suma[pos]=int(entra[pos].size())+int(sale[pos].size());
  while (pos>1) {
    pos/=2;
    suma[pos]=suma[2*pos]+suma[2*pos+1];
  }
}

int main()
{
  ios_base::sync_with_stdio(false);
  cin>>n>>m;
  {
    int nn=m+1;
    primero=1;
    while (nn>0) {
      nn/=2;
      primero*=2;
    }
    tope=2*primero;
  }
  vector<pair<int,int> > elem;
  for (int i=1;i<=n;i++) {
    cin>>t[i]>>s[i]>>f[i];
    elem.push_back(pair<int,int> (t[i],i));
  }
  sort(elem.begin(),elem.end());
  int ielem=0;
  lint tiempo=1;
  int floor=1;
  while (suma[1]>0 or ielem<int(elem.size())) {
    while (ielem<int(elem.size()) and elem[ielem].first==tiempo) {
      int person=elem[ielem].second;
      int pos=s[person];
      entra[pos+primero].push_back(person);
      actualiza(pos);
      ielem++;
    }
    while ((sale[floor+primero].size())>0) {
      int person=sale[floor+primero].back();
      sale[floor+primero].pop_back();
      sol[person]=tiempo;
    }
    while ((entra[floor+primero].size())>0) {
      int person=entra[floor+primero].back();
      entra[floor+primero].pop_back();
      int pos=f[person];
      sale[pos+primero].push_back(person);
      actualiza(pos);
    }
    actualiza(floor);
    int debajo=sumaantes(floor);
    int encima=suma[1]-debajo;
    int treachfloor=2000000000;
    int goalfloor;
    int signo=0;
    if (encima>=debajo) {
      if (encima>0) {
	goalfloor=findfloorri(floor);
	treachfloor=absolut(floor-goalfloor);
	signo=1;
      }
    } else {
      goalfloor=findfloorle(floor);
      treachfloor=absolut(floor-goalfloor);
      signo=-1;
    }
    if (ielem<int(elem.size()) and elem[ielem].first-tiempo<treachfloor) {
      floor+=signo*(elem[ielem].first-tiempo);
      tiempo=elem[ielem].first;
    } else {
      tiempo+=treachfloor;
      floor=goalfloor;
    }
  }
  for (int i=1;i<=n;i++)
    cout<<sol[i]<<endl;
}
