#include <bits/stdc++.h>

using namespace std;

const int N = 100000;
struct person {
  int id, s, f, effect;
  long long t;
  bool operator<(const person &p) const {
    return t > p.t;
  }
};
set<int> waiting;
queue<person> flr[N + 1];
long long ans[N];
long long curT;
int curF = 1, curP;

int main() {
  waiting.insert(-1000000000);
  waiting.insert(1000000000);
  int n, m;
  scanf("%d %d", &n, &m);
  priority_queue<person> Q;
  person paklsdhfjkashfk; paklsdhfjkashfk.t = 1LL << 60;
  Q.push(paklsdhfjkashfk);
  for(int i = 0; i < n; ++i) {
    person p; p.id = i; p.effect = 0;
    scanf("%I64d %d %d", &p.t, &p.s, &p.f);
    Q.push(p);
  }
  while(Q.size() > 1 || waiting.size() > 2) {
    while(Q.top().t == curT) {
      person p = Q.top();
      if(p.s != curF) p.effect = (p.s > curF) * 2 - 1;
      curP += p.effect;
      flr[p.s].push(p);
      waiting.insert(p.s);
      Q.pop();
    }
    while(flr[curF].size()) {
      person &p = flr[curF].front();
      curP -= p.effect;
      if(curF == p.s) {
        p.effect = (p.f > curF) * 2 - 1;
        curP += p.effect;
        flr[p.f].push(p);
        waiting.insert(p.f);
      }else {
        ans[p.id] = curT;
      }
      flr[curF].pop();
    }
    waiting.erase(curF);
    int change = 0;
    if(waiting.size() != 2) change = (curP >= 0) * 2 - 1;
    set<int>::iterator it = waiting.lower_bound(curF);
    if(change == -1) --it;
    long long eArrive = abs(*it - curF) + curT;
    long long nxtTime = min(eArrive, Q.top().t);
    curF += (nxtTime - curT) * change;
    curT = nxtTime;
  }
  for(int i = 0; i < n; ++i)
    printf("%I64d\n", ans[i]);
  return 0;
}