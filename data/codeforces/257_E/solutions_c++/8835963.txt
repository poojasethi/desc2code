#include<cstdio>
#include<set>
#include<algorithm>
#define LL long long
#define PI pair<int,int>
#define FR first
#define SC second
#define MP make_pair
using namespace std;
const int inf=0x7fffffff;
struct event
{
	int t,s,f,id;
}E[100050];
set<PI> SIU,SID,SOU,SOD;
LL ans[100050];
int n,m;
bool cmp(event a,event b)
{
	return a.t<b.t;
}
int main()
{
	PI A;
	LL T;
	int i,cur,cnt,d,sU,sD,_T;
	scanf("%d%d",&n,&m);
	for (i=1;i<=n;i++)
	{
		scanf("%d%d%d",&E[i].t,&E[i].s,&E[i].f);
		E[i].id=i;
	}
	sort(E+1,E+n+1,cmp);
	T=0; cur=1; cnt=0; i=1;
	while (cnt<n)
	{
		sU=(SIU.size())+(SOU.size()); sD=(SID.size())+(SOD.size());
		if ((sU==0)&&(sD==0)) d=0;
		else if (sU>=sD) d=1;
		else d=-1;
		if (i<=n) _T=E[i].t-T;
		else _T=inf;
		if (d==1)
		{
			if (!SIU.empty()) _T=min(_T,SIU.begin()->FR-cur);
			if (!SOU.empty()) _T=min(_T,SOU.begin()->FR-cur);
		}
		else if (d==-1)
		{
			if (!SID.empty()) _T=min(_T,cur-SID.rbegin()->FR);
			if (!SOD.empty()) _T=min(_T,cur-SOD.rbegin()->FR);
		}
		T+=_T; cur+=d*_T;
		while ((i<=n)&&(E[i].t==T))
		{
			if (E[i].s>=cur) SOU.insert(MP(E[i].s,i));
			else SOD.insert(MP(E[i].s,i));
			i++;
		}
		while (!SOU.empty()&&(SOU.begin()->FR==cur))
		{
			A=*SOU.begin(); SOU.erase(A);
			if (E[A.SC].f>=cur) SIU.insert(MP(E[A.SC].f,A.SC));
			else SID.insert(MP(E[A.SC].f,A.SC));
		}
		while (!SOD.empty()&&(SOD.rbegin()->FR==cur))
		{
			A=*SOD.rbegin(); SOD.erase(A);
			if (E[A.SC].f>=cur) SIU.insert(MP(E[A.SC].f,A.SC));
			else SID.insert(MP(E[A.SC].f,A.SC));
		}
		while (!SIU.empty()&&(SIU.begin()->FR==cur))
		{
			A=*SIU.begin(); SIU.erase(A); cnt++; ans[E[A.SC].id]=T;
		}
		while (!SID.empty()&&(SID.rbegin()->FR==cur))
		{
			A=*SID.rbegin(); SID.erase(A); cnt++; ans[E[A.SC].id]=T;
		}
	}
	for (i=1;i<=n;i++) printf("%I64d\n",ans[i]);
	return 0;
}