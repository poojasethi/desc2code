#include <iostream>
#include <cstdio>
#include <sstream>
#include <string>
#include <cstring>
#include <cmath>
#include <vector>
#include <deque>
#include <queue>
#include <set>
#include <map>
#include <algorithm>

using namespace std;

#define pb push_back
#define MP make_pair
#define F first
#define S second
#define ll long long
#define PII pair<int,int>

struct Person {
	ll t;
	int s,f,i;
	void read(int idx) {
		scanf("%I64d%d%d",&t,&s,&f), i = idx;
	}
	bool operator < (const Person a) const {
		return t < a.t;
	}
	bool operator == (const Person a) const {
		return t == a.t && s == a.s && f == a.f && i == a.i;
	}
} P[100005];

int n,m,sz;
int itree[300005];
ll ans[100005];
vector< pair<int,int> > waitings[100005];
map<int,int> elevator;
map<int,int>::iterator it;
map< int,vector<int> > outs;

void update(int i,int x) {
	i=sz+i-1;
	while(i) itree[i]+=x,i>>=1;
}

int find(int s, int e) {
	if(s > e) return 0;

	int x=s+sz-1, y=e+sz-1;
	int ret=0;
	while(x<y) {
		if(x%2==1) ret+=itree[x],x++;
		if(y%2==0) ret+=itree[y],y--;
		x>>=1,y>>=1;
	} if(x==y) ret+=itree[x];
	return ret;
}

int main() {
#ifdef LOCAL
	freopen("in.txt","r",stdin);
#endif
	scanf("%d%d",&n,&m);
	for(sz=1;sz<m;sz<<=1);
	for(int i=0;i<n;++i) P[i].read(i);
	sort(P,P+n);

	int floor = 1, i = 0;
	ll time = 1;
	while(i < n || elevator.size()) {
		if(i < n) {
			if(P[i].s == floor)
				update(P[i].f,1),
				elevator[P[i].f]++,
				outs[P[i].f].push_back(P[i].i);
			else
				update(P[i].s,1),
				elevator[P[i].s]++,
				waitings[P[i].s].push_back(MP(P[i].f,P[i].i));
		} time = P[i].t;
		while((i == n - 1 || time < P[i + 1].t) && elevator.size()) {
			int up = find(floor + 1, m) + find(floor + 1, m);
			int dw = find(1, floor - 1) + find(1, floor - 1);
			int nxt_floor;
			if(up >= dw) {
				it = elevator.upper_bound(floor);
				nxt_floor = it->first;
			}
			else {
				it = elevator.lower_bound(floor), --it;
				nxt_floor = it->first;
			}

			if(i + 1 < n && time + abs(floor - nxt_floor) > P[i + 1].t) {
				if(up >= dw) 
					floor += abs(time - P[i + 1].t);
				else
					floor -= abs(time - P[i + 1].t);
				time = P[i + 1].t;
				goto NXT;
			}

			update(nxt_floor,-elevator[nxt_floor]);
			elevator[nxt_floor] = 0;
			for(int j=0;j<outs[nxt_floor].size();++j)
				ans[outs[nxt_floor][j]] = time + abs(floor - nxt_floor);
			for(int j=0;j<waitings[nxt_floor].size();++j)
				update(waitings[nxt_floor][j].F,1),
				elevator[waitings[nxt_floor][j].F]++,
				outs[waitings[nxt_floor][j].F].push_back(waitings[nxt_floor][j].S);
			if(elevator[nxt_floor] == 0) elevator.erase(nxt_floor);
			waitings[nxt_floor].clear();
			outs[nxt_floor].clear();
			time = time + abs(floor - nxt_floor);
			floor = nxt_floor;
		}
NXT:;
		if(i < n) ++i;
	}

	for(int i=0;i<n;++i) printf("%I64d\n",ans[i]);
	return 0;
}