#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <string>
#include <set>
using namespace std;
typedef long long LL;
const int Maxn=100005,inf=999999999+208;
int n,m;
LL arr_t[Maxn];

inline int get() {
	char ch;
	while (!isdigit(ch=getchar()));
	int v=ch-48;
	while (isdigit(ch=getchar())) v=v*10+ch-48;
	return v;
}

struct Person{
	int t,s,f,i;
	bool operator <(const Person &rhs)const{
		return t<rhs.t;
	}
}p[Maxn];

struct info{
	int pos,i;
	info(int pos,int i):pos(pos),i(i){}
	bool operator <(const info &rhs)const{
		return pos<rhs.pos||(pos==rhs.pos&&i<rhs.i);
	}
	bool operator >(const info &rhs)const{
		return pos>rhs.pos||(pos==rhs.pos&&i>rhs.i);
	}
};

class Elevator{
	LL cur_t;
	int pos,next;
	set <info>::iterator it;
	set <info,less<info> > wait_up,carry_up;
	set <info,greater<info> > wait_down,carry_down;
	void carry(int i) {
		if (p[i].f>pos) carry_up.insert(info(p[i].f,i));
		else carry_down.insert(info(p[i].f,i));
	}
	void wait(int i) {
		if (p[i].s>pos) wait_up.insert(info(p[i].s,i));
		else wait_down.insert(info(p[i].s,i));
	}
	public:
		void init() {
			cur_t=0; pos=1; next=1;
			for (int i=1;i<=n;i++) {
				p[i].t=get(); p[i].s=get();
				p[i].f=get(); p[i].i=i;
			}
			sort(p+1,p+n+1);
		}
		bool run() {
			for (;next<=n&&cur_t==p[next].t;next++)
				p[next].s==pos?carry(next):wait(next);
			while (!wait_up.empty()) {
				it=wait_up.begin();
				if (it->pos!=pos) break;
				carry(it->i);
				wait_up.erase(it);
			}
			while (!wait_down.empty()) {
				it=wait_down.begin();
				if (it->pos!=pos) break;
				carry(it->i);
				wait_down.erase(it);
			}
			while (!carry_up.empty()) {
				it=carry_up.begin();
				if (it->pos!=pos) break;
				arr_t[p[it->i].i]=cur_t;
				carry_up.erase(it);
			}
			while (!carry_down.empty()) {
				it=carry_down.begin();
				if (it->pos!=pos) break;
				arr_t[p[it->i].i]=cur_t;
				carry_down.erase(it);
			}
			int p_up=wait_up.size()+carry_up.size(),
				p_down=wait_down.size()+carry_down.size();
			if (next>n&&p_up==0&&p_down==0) return 0;
			if (p_up==0&&p_down==0) return cur_t=p[next].t,1;
			int step=inf;
			if (next<=n) step=min(step,int(p[next].t-cur_t));
			if (p_up>=p_down) {
				if (!wait_up.empty()) step=min(step,wait_up.begin()->pos-pos);
				if (!carry_up.empty()) step=min(step,carry_up.begin()->pos-pos);
				pos+=step;
			}
			else {
				if (!wait_down.empty()) step=min(step,pos-wait_down.begin()->pos);
				if (!carry_down.empty()) step=min(step,pos-carry_down.begin()->pos);
				pos-=step;
			}
			cur_t+=step;
		}
}T;

int main() {
	n=get(); m=get();
	T.init();
	while (T.run());
	for (int i=1;i<=n;i++) printf("%I64d\n",arr_t[i]);
	return 0;
}