#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
#include <cmath>
using namespace std;

typedef long long ll;
typedef pair<ll,ll> pll;
#define For(i,a,b) for(ll i = (a); i < (b); i++)
#define Dow(i,a,b) for(ll i = (a); i >= (b); i--)
#define pb push_back
#define mp make_pair
#define fi first
#define se second
const ll mod = 1e9+7;
const ll maxN = 1e5+10;

ll n, m;
ll t[maxN], s[maxN], f[maxN], tree[maxN], res[maxN];
vector<ll> wait[maxN], lift[maxN];
pll e[maxN];

ll get (ll x)
{
	x++;
	ll res = 0;
	for(; x > 0; x -= x & -x) res += tree[x];
	return res; 
}

void upd (ll x, ll val)
{
	x++;
	for(; x < 1e5+10; x += x & -x) tree[x] += val;
}

ll getU (ll x)
{
	ll cur = get(x);
	ll l = x, r = 1e5+9;
	while (l < r)
	{
		ll m = (l + r + 1) >> 1;
		if (get(m) == cur) l = m;
		else r = m - 1;
	}
	return l - x + 1;
}

ll getD (ll x)
{
	ll cur = get(x);
	ll l = 0, r = x;
	while (l < r)
	{
		ll m = (l + r) >> 1;
		if (get(m) == cur) r = m;
		else l = m + 1;
	}
	return x - r;
}

int main ()
{
	ios_base::sync_with_stdio(0);
	cin >> n >> m;
	For(i,0,n) cin >> t[i] >> s[i] >> f[i];
	For(i,0,n) e[i] = mp(t[i], i);
	sort(e,e+n);
	
	ll cur = 1;
	ll T = 0;
	ll waiting = n;
	ll lifted = 0;
	ll L = 0;
	while (waiting + lifted)
	{
		while (L < n && e[L].fi <= T)
		{
			wait[s[e[L].se]].pb(e[L].se);
			upd(s[e[L].se],1);
			L++;
		}
		
		For(i,0,lift[cur].size())
		{
			res[lift[cur][i]] = T;
			upd(cur,-1);
			lifted--;
		}
		lift[cur].clear();
		
		For(i,0,wait[cur].size())
		{
			lift[f[wait[cur][i]]].pb(wait[cur][i]);
			upd(cur,-1);
			upd(f[wait[cur][i]],1);
			waiting--;
			lifted++;
		}
		wait[cur].clear();
		
		ll sum1 = get(cur);
		ll sum2 = get(m) - sum1;
		
		ll dT = 1e9;
		if (L < n) dT = min(dT, e[L].fi - T);
		if (sum1 + sum2 > 0)
		{
			if (sum1 > sum2)
			{
				dT = min(dT, getD(cur));
				cur -= dT;
			}
			else
			{
				dT = min(dT, getU(cur));
				cur += dT;
			}
		}
		T += dT;
	}
	
	For(i,0,n) cout << res[i] << '\n';

	return 0;
}

