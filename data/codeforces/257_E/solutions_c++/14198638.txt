//enot.1.10
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <algorithm>
#include <cmath>
#include <vector>
#include <map>
#include <set>
#include <cassert>
#include <ctime>
#define fs first
#define sc second
#define pb push_back
#define mp make_pair
#define sz(a) ((int)a.size())
#define forit(it, v) for(typeof((v).begin()) it = (v).begin() ; it != (v).end() ; ++it)
#define forn(i, n) for(int i = 0 ; (i) < (n) ; ++(i))
#define forx(i, l, r) for(int i = l ; (i) < (r) ; ++(i))
#ifdef home
	#define eprintf(...) fprintf(stderr, __VA_ARGS__),fflush(stderr)
#else
	#define eprintf(...) {}
#endif
#ifdef WIN32
	#define I64 "%I64d"
#else
	#define I64 "%lld"
#endif
using namespace std;
typedef long long ll; typedef double ld; typedef pair<int, int> pi; typedef vector<int> vi;
const ld eps=1e-9; const int inf=(int)1e9;

/* --- main part --- */
#define TASK_NAME "a"
const int maxn = (int)1e5 + 10;
int tree[maxn];
inline int get(int x)
{
	x++;
	int res = 0;
	for(; x > 0 ; x -= x & -x) res += tree[x];
	return res;
}
inline void upd(int x, int dx)
{
	x++;
	for(; x < maxn ; x += x & -x) tree[x] += dx;
}
vi wait[maxn];
vi lift[maxn];
int t[maxn], s[maxn], f[maxn];
pi e[maxn];
ll res[maxn];
inline int getU(int x)
{
	int current = get(x);
	int l = x, r = maxn - 1;
	while(l < r)
	{
		int m = (l + r + 1) >> 1;
		if(get(m) == current) l = m;
		else r = m - 1;
	}
	return l - x + 1;
}
		 
inline int getD(int x)
{
	int current = get(x);
	int l = 0, r = x;
	while(l < r)
	{
		int m = (l + r) >> 1;
		if(get(m) == current) r = m;
		else l = m + 1;
	}
	return x - r;
}

int main()
{
	#ifdef home
		assert(freopen(TASK_NAME".in", "r", stdin));
		assert(freopen(TASK_NAME".out", "w", stdout));
	#endif
	int n, m;
	scanf("%d%d\n", &n, &m);
	forn(i, n) scanf("%d%d%d", &t[i], &s[i], &f[i]);
	forn(i, n) e[i] = mp(t[i], i);
	sort(e, e + n);
	int current = 1;
	ll T = 0;
	int waiting = n, lifted = 0;
	int L = 0;
	while(waiting + lifted)
	{                     
		while(L < n && e[L].fs <= T) wait[s[e[L].sc]].pb(e[L].sc), upd(s[e[L].sc], 1), L++;
		
		forn(i, sz(lift[current])) res[lift[current][i]] = T, upd(current, -1), lifted -= 1;
		lift[current].clear();
		forn(i, sz(wait[current])) lift[f[wait[current][i]]].pb(wait[current][i]), upd(current, -1), upd(f[wait[current][i]], 1), waiting -= 1, lifted += 1;
		wait[current].clear();

		int sum1 = get(current);
		int sum2 = get(m) - sum1;

		ll dT = inf;
		if(L < n) dT = min(dT, e[L].fs - T);
		if(sum1 + sum2 > 0)
		{
			if(sum1 > sum2)
			{
				dT = min(dT, (ll)getD(current));
				current -= dT;
			}
			else
			{
				dT = min(dT, (ll)getU(current));
				current += dT;
			}
    }
    T += dT;
	}
	forn(i, n) cout << res[i] << '\n';		
	#ifdef home
		eprintf("%d ms\n", (int)(clock()*1000.0/CLOCKS_PER_SEC));
	#endif
	return 0;
}