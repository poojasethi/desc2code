#include <bits/stdc++.h>

#define R "%d"
#define RL "%I64d"
#define RD "%lf"
#define W "%.8lf"

#define Max(x, y) ((x) > (y) ? (x) : (y))
#define Min(x, y) ((x) < (y) ? (x) : (y))
#define Set(x, y) memset(x, y, sizeof(x))
#define Cpy(x, y) memcpy(x, y, sizeof(y))
#define All(x) x.begin(), x.end()
#define Sqr(x) ((x) * (x))
#define Sz(x) ((LL)x.size())

#define Mk make_pair
#define Pb push_back
#define Pk pop_back
#define Fr first
#define Se second

#define FOR(x, l, r) for (LL x = (l), end = (r); x <= end; ++x)
#define ROF(x, l, r) for (LL x = (l), end = (r); x >= end; --x)
#define Edge(x, y) for (LL x = g[y]; x; x = nt[x])

#define Read(x) ((x) = Get())
#define Lowbit(x) ((x) & (-x))
using namespace std;

typedef int LL;
typedef long long ll;
typedef double LD;
typedef long double real;

typedef map <LL, LL> MI;
typedef pair <LL, LL> PI;
typedef set <LL> SI;
typedef vector <LL> VI;

inline LL Get() {
	LL res = 0, q = 1;
	char ch = getchar();
	while ((ch < '0' || ch > '9') && ch != '-') ch = getchar();
	if (ch == '-') q = -1, ch = getchar();
	while (ch >= '0' && ch <= '9') res = res * 10 + ch - '0', ch = getchar();
	return res * q;
}

const LD eps = 1e-12, pi = M_PI;
const LL oo = (LL)2e9, mod = (LL)1e9 + 7;
const ll INF = (ll)1e17;

const LL N = (LL)2e5, LG = 19;
typedef LL arr[N + 10];
typedef LL arre[2 * N + 10];

LL n, m, tot, j, k, rt, ans, st[2], sv[2], sc[4], tsc[3], ord[4], tord[3];
arr g, dep, deg, sz, f, h, l, son, ft, to[LG + 1];
arre pt, nt;
bool v[N + 10];

struct queue {
	arr v;
	LL f, r;
}q;

void Link(LL x, LL y) {
	pt[++tot] = y, nt[tot] = g[x], g[x] = tot;
	pt[++tot] = x, nt[tot] = g[y], g[y] = tot;
}

LL Find(LL x, LL y) {
	for (LL c = LG; c >= 0; --c)
		if ((1 << c) <= y) y -= (1 << c), x = to[c][x];
	return x;
}

void Go(LL x) {
	bool fx = h[st[0]], fy = h[st[1]];
	LL dx = 1 + (fx ? dep[h[st[0]]] - dep[st[0]] : l[st[0]] - 1), dy = fy ? dep[h[st[1]]] - dep[st[1]] : l[st[1]] - 1;
	if (fx && fy) return;
	else if (fx) {
		if (dy >= dx) return;
		LL dt = Find(st[0], dy);
		(f[x] += f[dt]) %= mod;
	}
	else if (fy) {
		if (dx >= dy) return;
		LL dt = Find(st[1], dx + 1);
		(f[x] += f[dt]) %= mod;
	}
	else {
		if (dx == dy) (f[x] += 1) %= mod;
		else {
			LL dt = dx > dy ? Find(st[0], dy) : Find(st[1], dx + 1);
			(f[x] += f[dt]) %= mod;
		}
	}
}

LL Total(LL x, LL y) {
	if ((sz[x] + sz[y]) & 1) return 0;
	if (!y) return f[x];

	bool fx = h[x], fy = h[y];
	LL dx = fx ? dep[h[x]] - dep[x] : l[x] - 1, dy = fy ? dep[h[y]] - dep[y] : l[y] - 1;
	if (fx && fy) return 0;
	else if (fx) {
		if (dy >= dx) return 0;
		LL dt = Find(x, dy + 1);
		return f[dt];
	}
	else if (fy) {
		if (dx >= dy) return 0;
		LL dt = Find(y, dx + 1);
		return f[dt];
	}
	else {
		if (dx == dy) return 1;
		else {
			LL dt = dx > dy ? Find(x, dy + 1) : Find(y, dx + 1);
			return f[dt];
		}
	}
}

LL Push(LL x, LL y, LL d) {
	LL cv = 0; sv[0] = sv[1] = 0;
	Edge (i, x) if (pt[i] != ft[x]) sv[cv++] = pt[i];
	if (!cv) return 0;
	if (cv == 1) return l[sv[0]] == d ? f[y] : 0;
	LL res = 0;
	if (l[sv[0]] == d) (res += Total(y, sv[1])) %= mod;
	if (l[sv[1]] == d) (res += Total(y, sv[0])) %= mod;
	return res;
}

void Dp(LL x) {
	st[0] = st[1] = 0;
	if (deg[x] == 2) {
		LL y = h[x];
		if (dep[y] - dep[x] > 1) (f[x] += f[son[son[x]]]) %= mod;
		if (!y) (f[x] += 1) %= mod;
		else {
			LL dt = dep[y] - dep[x], cnt = 0;
			if (dt * 2 >= sz[x]) return;
			Edge (i, y)
				if (pt[i] != ft[y]) st[cnt++] = pt[i];
			if (dt > 1) {
				if (l[st[0]] == dt - 1) (f[x] += f[st[1]]) %= mod;
				if (l[st[1]] == dt - 1) (f[x] += f[st[0]]) %= mod;
			}
			if (dt * 2 + 2 >= sz[x]) return;
			(f[x] += Push(st[0], st[1], dt)) %= mod;
			(f[x] += Push(st[1], st[0], dt)) %= mod;
		}
	}
	else {
		LL cnt = 0;
		Edge (i, x)
			if (pt[i] != ft[x]) st[cnt++] = pt[i];
		Go(x);
		swap(st[0], st[1]);
		Go(x);
	}
}

void Bfs() {
	q.v[1] = rt, q.f = q.r = 1, v[rt] = 1;
	for ( ; q.f <= q.r; ) {
		LL x = q.v[q.f++];
		Edge (i, x)
			if (!v[pt[i]]) q.v[++q.r] = pt[i], v[pt[i]] = 1, dep[pt[i]] = dep[x] + 1, ft[pt[i]] = x;
	}

	dep[0] = 2 * n + 10;
	ROF (i, q.r, 1) {
		LL x = q.v[i]; sz[x] = 1;
		l[x] = deg[x] == 1;
		Edge (i, x) if (pt[i] != ft[x]) {
			sz[x] += sz[pt[i]], h[x] = h[pt[i]], son[x] = pt[i], to[0][x] = pt[i];
			if (l[pt[i]]) l[x] = l[pt[i]] + 1;
		}
		if (deg[x] > 2) h[x] = x, l[x] = 0;
		FOR (j, 1, LG) to[j][x] = to[j - 1][to[j - 1][x]];
		if (x != rt && !(sz[x] & 1)) Dp(x);
	}
}

void Calc() {
	Bfs();

	LL cntx = 0;
	Edge (i, rt) sc[++cntx] = pt[i], ord[cntx] = cntx;
	do {
		LL cnty = 0;
		Edge (i, sc[ord[2]]) if (pt[i] != rt) tsc[++cnty] = pt[i];
		cnty = 2, tord[1] = 1, tord[2] = 2;
		if (!tsc[1] && !tsc[2]) {
			LL cx = Total(sc[ord[1]], 0), cy = Total(sc[ord[3]], 0);
			(ans += (ll)cx * (ll)cy % mod) %= mod;
			continue;
		}
		do {
			LL cx = Total(sc[ord[1]], tsc[tord[1]]), cy = Total(sc[ord[3]], tsc[tord[2]]);
			(ans += (ll)cx * (ll)cy % mod) %= mod;
		}while (next_permutation(tord + 1, tord + cnty + 1));
		tsc[1] = tsc[2] = 0;
	}while (next_permutation(ord + 1, ord + cntx + 1));
}

LL main() {
#ifndef ONLINE_JUDGE
	freopen("tree.in", "r", stdin);
	freopen("tree.out", "w", stdout);
#endif

	scanf(R "\n", &n);
	FOR (i, 1, (n << 1) - 1) {
		scanf(R R "\n", &j, &k), Link(j, k);
		++deg[j], ++deg[k];
		if (deg[j] > 3 || deg[k] > 3) return printf("0\n"), 0;
		else if (deg[j] == 3) rt = j; else if (deg[k] == 3) rt = k;
	}

	if (!rt) {
		if (n == 1) ans = 2;
		else ans = (2LL * (ll)n * (ll)n - 2LL * (ll)n + 4LL) % mod;
		return printf(R "\n", ans), 0;
	}

	//rt = 2;
	Calc();

	printf(R "\n", (ans << 1) % mod);
	return 0;
}
