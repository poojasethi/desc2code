#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <vector>
#include <string>
#include <cassert>
#include <ctime>

using namespace std;

#ifdef WIN32
	#define LLD "%I64d"
#else
	#define LLD "%lld"
#endif


typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<bool> vb;
typedef vector<vb> vvb;
typedef vector<ll> vll;
typedef vector<vll> vvll;

#define TASKNAME "text"
#define pb push_back
#define mp make_pair
#define EPS (1E-9)
#define INF ((int)1E9)
#define sqr(x) ((x) * (x))
#define eprintf(...) fprintf(stderr, __VA_ARGS__)
#define sz(x) ((int)(x).size())
      
const int MOD = 1e9 + 7;

inline void add(int &x, int toadd) {
	x += toadd;
	if (x >= MOD)
		x -= MOD;
}

vvi es1, es;
const int maxn = (int)2e5;
int next[maxn], g[maxn], szs[maxn];

int used[maxn], maxu;

void dfs(int v) {
	used[v] = maxu;
	int res = -1;
	szs[v] = 1;
	for (int it = 0; it < sz(es1[v]); it++) {
		int u = es1[v][it];
		if (used[u] == maxu)
			continue;
// 		eprintf("%d -> %d\n", v, u);
		g[u] = g[v] + 1;
		es[v].pb(u);
		dfs(u);
		res = next[u];
		szs[v] += szs[u];
	}
	next[v] = sz(es1[v]) == 3 ? v : res;
}

int solve_pair(int v1, int v2) ;

int mem[maxn];
int solve(int v) {
	assert(v != -1);
	if (szs[v] & 1)
		return 0;
	if (mem[v] != -1)
		return mem[v];
	
	int &res = mem[v];
	res = 0;
	
	if (sz(es[v]) == 2) {
		for (int it = 0; it < 2; it++) {
			int u = es[v][it];
			if (sz(es[u]) > 1)
				continue;
			int w = sz(es[u]) == 1 ? es[u][0] : -1;
			add(res, solve_pair(es[v][!it], w));
		}
	} else {
		assert(sz(es[v]) == 1);
		int w = next[v];
		if (w == -1) {
			res = szs[v] / 2;
		} else {
			assert(sz(es[w]) == 2);
			int ar[4] = {es[w][0], es[w][1]};
			sort(ar, ar + 2);
			do {
				if (next[ar[0]] == -1 && g[w] - g[v] - 1 >= szs[ar[0]])
					add(res, solve(ar[1]));
				ar[2] = sz(es[ar[0]]) >= 1 ? es[ar[0]][0] : -1;
				ar[3] = sz(es[ar[0]]) >= 2 ? es[ar[0]][1] : -1;
				
				sort(ar + 2, ar + 4);
				do {
					if (ar[2] == -1 || (next[ar[2]] == -1 && g[w] - g[v] >= szs[ar[2]]))
						add(res, solve_pair(ar[1], ar[3]));
				} while(next_permutation(ar + 2, ar + 4)) ;
			} while(next_permutation(ar, ar + 2)) ;
		}
	}
	
// 	eprintf("solve(%d) = %d\n", v, res);
	return res;
}

int solve_pair(int v1, int v2) {
// 	eprintf("solve_pair(%d, %d)\n", v1, v2);
	if (v1 == -1)
		return solve(v2);
	if (v2 == -1)
		return solve(v1);
	if ((szs[v1] + szs[v2]) & 1)
		return 0;
	
	if (sz(es[v1]) == 1 && sz(es[v2]) == 1)
		return solve_pair(es[v1][0], es[v2][0]);
	if (!sz(es[v1]) && !sz(es[v2]))
		return 1;
	if (sz(es[v1]) > 1 || sz(es[v2]) > 1)
		return 0;
	if (!sz(es[v1]))
		return solve(es[v2][0]);
	if (!sz(es[v2]))
		return solve(es[v1][0]);
	assert(0);
}

int solve_root(int v) {
	assert(sz(es[v]) == 3);
	int ar[5];
	ar[0] = es[v][0], ar[1] = es[v][1], ar[2] = es[v][2];
	sort(ar, ar + 3);
	int ans = 0;
	do {
		ar[3] = sz(es[ar[0]]) >= 1 ? es[ar[0]][0] : -1;
		ar[4] = sz(es[ar[0]]) >= 2 ? es[ar[0]][1] : -1;
		sort(ar + 3, ar + 5);
		do {
// 			printf("ar = %d, %d, %d, %d, %d\n", ar[0], ar[1], ar[2], ar[3], ar[4]);
// 			printf("solve_pair(%d, %d) = %d\n", ar[1], ar[3], solve_pair(ar[1], ar[3]));
// 			printf("solve_pair(%d, %d) = %d\n\n", ar[2], ar[4], solve_pair(ar[2], ar[4]));
			ans = (ans + (ll)solve_pair(ar[1], ar[3]) * solve_pair(ar[2], ar[4])) % MOD;
// 			printf("ans = %d\n", ans);
		} while(next_permutation(ar + 3, ar + 5)) ;
	} while(next_permutation(ar, ar + 3)) ;
	return (ans * 2) % MOD;
}

int main() {     
	#ifdef DEBUG
		freopen(TASKNAME".in", "r", stdin);
		freopen(TASKNAME".out", "w", stdout);
	#endif
	
	int n;
	while (scanf("%d", &n) >= 1) {
		es = vvi(2 * n);
		for (int i = 0; i < 2 * n - 1; i++) {
			int s, t;
			scanf("%d%d", &s, &t);
			--s, --t;
			es[s].pb(t), es[t].pb(s);
		}
		
		pii mxpr(-1, -1);
		for (int i = 0; i < 2 * n; i++) {
			mxpr = max(mxpr, mp(sz(es[i]), i));
		}
		
		if (mxpr.first > 3) {
			printf("0\n");
			continue;
		}
		
		if (n == 1) {
			printf("2\n");
			continue;
		}
		
		if (mxpr.first == 2) {
			printf("%d\n", (int)((2ll * n * n - 2 * n + 4) % MOD));
			continue;
		}
		
		memset(used, 0, sizeof(used));
		maxu = 0;
		
		es1 = es;
		es = vvi(2 * n);
		int root = mxpr.second;
		g[root] = 0;
		++maxu;
		dfs(root);
		
		memset(mem, -1, sizeof(mem));
// 		printf("solve(%d) = %d\n", 10, solve(10));
// 		exit(1);
// 		printf("solve_pair(%d, %d) = %d\n", 1, 4, solve_pair(1, 4));
// 		exit(1);
// 		for (int i = 0; i < 2 * n; i++)
// 			if (i != root)
// 				printf("solve(%d) = %d\n", i, solve(i));
		
		printf("%d\n", solve_root(root));
// 		break;
	}	
	return 0;
}
