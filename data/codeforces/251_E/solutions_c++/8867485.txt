//+-------------------------------------+
//|     By   qwer_zcc                   |
//|     Date 30/10/2014                 |
//+-------------------------------------+
#include <bits/stdc++.h>
#define INF ((~0U>>1)-3)
#define LLINF ((~0ULL>>1)-3)
#define LL long long
#define uLL unsigned long long
#define uint unsigned int
#define D double
#define LD long double
#define rep(i,a,b) for (int i=a;i<=b;i++)
#define drep(i,a,b) for (int i=a;i>=b;i--)
#define M(a) memset(a,0,sizeof(a));
#define pb push_back
#define mp make_pair
#define Pi M_PI
using namespace std;
template<class T> inline T min(T &a,T &b) {return a<b?a:b;}
template<class T> inline T max(T &a,T &b) {return a>b?a:b;}
template<class T> void read(T &x)
{
    char ch;
    while ((ch=getchar()) && !isdigit(ch));x=ch-'0';
    while ((ch=getchar()) && isdigit(ch)) x=x*10+ch-'0';
}
struct point
{
    int x,y;
    point() {}
    point(int _x,int _y) : x(_x),y(_y) {}
} ;
const int N=210000;
const LL Mod=1000000007;
vector<int> E[N];
int n,rd[N],fa[N],dep[N];
namespace Sub1
{
	//formula
	void work(int n)
	{
		LL nn=n;
		printf("%lld\n",(nn*nn/2-nn+4)%Mod);
	}
}
vector<int> son[N];
int size[N],Rd[N],FFl,Mrd[N];
LL Ans;
int Fl=0,rt,pos[N];
struct calc
{
	LL vis[N];
	map<pair<int,int>,LL> Hash;
	void Dfs(int x)
	{
		for (int i=0;i<son[x].size();i++)
		{
			printf("%d %d\n",x,son[x][i]);
			Dfs(son[x][i]);
		}
	}
	LL Num(int x)
	{
		if (x==rt) return 0;
		if (vis[x]) return vis[x];
		int X=x;
		if (size[x]&1) return 0;
		LL ans=0;
		if (pos[x]==0) return size[X]/2;
		int Len=dep[pos[x]]-dep[x];
		x=pos[x];
		int L=son[x][0],R=son[x][1];
		if (Mrd[L]<2 && Len>1 && (Len-1>=size[L]) && (Len+size[L]-1)%2==0)
			ans=(ans+Num(R))%Mod;
		if (Mrd[R]<2 && Len>1 && (Len-1>=size[R]) && (Len+size[R]-1)%2==0)
			ans=(ans+Num(L))%Mod;
		if (!rd[R])
		{
			if (Len%2==0) ans=(ans+Num(L))%Mod;
		}
		else if (rd[R]==1)
		{
			if (Mrd[son[R][0]]<2 && (size[son[R][0]])<=Len && (Len+size[son[R][0]])%2==0)
				ans=(ans+Num(L))%Mod;
			if (Len%2==0) ans=(ans+Num(L,son[R][0]))%Mod;
		}
		else
		{
			if (Mrd[son[R][0]]<2 && (size[son[R][0]])<=Len && (Len+size[son[R][0]])%2==0)
				ans=(ans+Num(L,son[R][1]))%Mod;
			if (Mrd[son[R][1]]<2 && (size[son[R][1]])<=Len && (Len+size[son[R][1]])%2==0)
				ans=(ans+Num(L,son[R][0]))%Mod;
		}
		
		swap(L,R);
		if (!rd[R])
		{
			if (Len%2==0) ans=(ans+Num(L))%Mod;
		}
		else if (rd[R]==1)
		{
			if (Mrd[son[R][0]]<2 && (size[son[R][0]])<=Len && (Len-(size[son[R][0]]))%2==0)
				ans=(ans+Num(L))%Mod;
			if (Len%2==0) ans=(ans+Num(L,son[R][0]))%Mod;
		}
		else
		{
			if (Mrd[son[R][0]]<2 && (size[son[R][0]])<=Len && (Len-(size[son[R][0]]))%2==0)
				ans=(ans+Num(L,son[R][1]))%Mod;
			if (Mrd[son[R][1]]<2 && (size[son[R][1]])<=Len && (Len-(size[son[R][1]]))%2==0)
				ans=(ans+Num(L,son[R][0]))%Mod;
		}
		return vis[X]=ans;
	}
	LL Num(int x,int y)
	{
		if (x>y) swap(x,y);
		if (Hash.count(mp(x,y))) return Hash[mp(x,y)];
		if ((size[x]+size[y])&1) return 0;
		if (rd[x]>1 || rd[y]>1) return 0;
		if (!rd[x] && !rd[y]) return 1;
		if (rd[x]==1 && !rd[y])
		{
			Hash[mp(x,y)]=Num(son[x][0]);
			return Hash[mp(x,y)];
		}
		if (!rd[x] && rd[y]==1)
		{
			Hash[mp(x,y)]=Num(son[y][0]);
			return Hash[mp(x,y)];
		}
		if (rd[x]==1 && rd[y]==1)
		{
			Hash[mp(x,y)]=Num(son[x][0],son[y][0]);
			return Hash[mp(x,y)];
		}
		assert(0);
	}
}C;
#define Num C.Num
void solve(int x,int y,int z)
{
	if (rd[z]==0) Ans=(Ans+Num(x)*Num(y))%Mod;
	if (rd[z]==1) Ans=(Ans+Num(x,son[z][0])*Num(y)+Num(y,son[z][0])*Num(x))%Mod;
	if (rd[z]==2) Ans=(Ans+Num(x,son[z][0])*Num(y,son[z][1])+Num(x,son[z][1])*Num(y,son[z][0]))%Mod;
}
void dfs(int w,int Fa)
{
	fa[w]=Fa;dep[w]=dep[Fa]+1;size[w]=1;
	for (int i=0;i<E[w].size();i++)
	if (E[w][i]!=Fa) son[w].pb(E[w][i]),rd[w]++,dfs(E[w][i],w),size[w]+=size[E[w][i]];
}
void ddfs(int w,int Fa)
{
	Mrd[w]=rd[w];
	if (rd[w]==2) pos[w]=w;
	for (int i=0;i<E[w].size();i++)
	if (E[w][i]!=Fa)
	{
		ddfs(E[w][i],w),Mrd[w]=max(Mrd[w],Mrd[E[w][i]]);
		if (!pos[w] && Mrd[E[w][i]]==2) pos[w]=pos[E[w][i]];
	}
}
int main()
{
	scanf("%d",&n);n<<=1;int x,y,mrd=0;
	rep(i,1,n-1)
	{
		scanf("%d%d",&x,&y);
		if (i==1 && x==1629) Fl=1;
		Rd[x]++,Rd[y]++,E[x].pb(y),E[y].pb(x);
		mrd=max(mrd,max(Rd[x],Rd[y]));
	}
	if (mrd>3) {puts("0");return 0;}
	if (mrd<3)
	{
		if (n==2) puts("2");
		else Sub1::work(n);
		return 0;
	}
	rep(i,1,n)
	if (Rd[i]==3) {rt=i;break;}
	dfs(rt,0);ddfs(rt,0);
	rep(i,1,n) Num(i);
	FFl=1;
	solve(E[rt][0],E[rt][1],E[rt][2]);
	solve(E[rt][0],E[rt][2],E[rt][1]);
	solve(E[rt][1],E[rt][2],E[rt][0]);
	printf("%lld\n",(Ans*4)%Mod);
}
