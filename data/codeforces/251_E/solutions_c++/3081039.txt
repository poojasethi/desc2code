#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;

const int maxn = 200010, maxd = 20;
const int key = 1000000007;

int add(int x, int y)
{
	return ((long long)x + y) % key;
}
int mul(int x, int y)
{
	return ((long long)x * y) % key;
}

int n;
int deg[maxn], size[maxn], maxdeg[maxn], maxalldeg;
vector<int> ga[maxn];

void insertedge(int x, int y)
{
	deg[x]++; deg[y]++;
	ga[x].push_back(y); ga[y].push_back(x);
	maxalldeg = max(maxalldeg, max(deg[x], deg[y]));
}

bool vis[maxn];
int pre[maxn], next[maxn], nextst[maxn][maxd], depth[maxn];
int dfsearch(int start = 1, int dep = 0, int _pre = 0)
{
	if (vis[start]) return 0;
	pre[start] = _pre;
	depth[start] = dep;
	vis[start] = true;
	size[start] = 1;
	maxdeg[start] = deg[start];
	next[start] = nextst[start][0] = start;
	for (vector<int>::iterator it = ga[start].begin(); it != ga[start].end(); it++)
		if (!vis[*it])
		{
			size[start] += dfsearch(*it, dep + 1, start);
			maxdeg[start] = max(maxdeg[start], maxdeg[*it]);
			if (deg[start] < 3) next[start] = next[*it], nextst[start][0] = *it;
		}
	if (deg[start] >= 3) next[start] = nextst[start][0] = start;
	for (int i = 1; i < maxd; i++) nextst[start][i] = nextst[nextst[start][i-1]][i-1];
	return size[start];
}

int movedown(int start, int k)
{
	if (depth[start] + k >= depth[next[start]]) return next[start];
	k += depth[start];
	for (int i = maxd - 1; i >= 0; i--)
		if (depth[nextst[start][i]] <= k) start = nextst[start][i];
	return start;
}

void getchild(int x, int& a, int& b)
{
	if (deg[x] == 1) a = b = 0;
	else if (deg[x] == 2)
	{
		b = 0;
		if (ga[x][0] == pre[x]) a = ga[x][1]; else a = ga[x][0];
	}
	else
	{
		if (ga[x][0] == pre[x]) a = ga[x][1], b = ga[x][2];
		else if (ga[x][1] == pre[x]) a = ga[x][0], b = ga[x][2];
		else a = ga[x][0], b = ga[x][1];
	}
}

int counting(int);

inline bool isodd(int x) { return x & 1; }

int count2(int x, int y)
{
	if (isodd(size[x] + size[y])) return 0;
	if (size[x] == size[y])
		if (maxdeg[x] <= 2 && maxdeg[y] <= 2) return 1;
		else return 0;
	if (size[x] < size[y]) swap(x, y);
	if (maxdeg[y] > 2) return 0;
	int t = movedown(x, size[y]);
	if (depth[t] - depth[x] < size[y]) return 0;
	return counting(t);
}

int count4(int lefts, int b, int c, int d)
{
	if (!isodd(size[c] + lefts) && maxdeg[c] <= 2 && size[c] <= lefts) return count2(b, d);
	else return 0;
}

int f[maxn];
bool calced[maxn];
int counting(int start)
{
	if (maxdeg[start] > 3 || size[start] & 1) return 0;
	else if (maxdeg[start] == 2) return size[start] / 2;
		
	if (calced[start]) return f[start];
	calced[start] = true;
	int &ret = f[start];
	f[start] = 0;
	
	int lefts = depth[next[start]] - depth[start];
	start = next[start];
	
	int pa, pb, pc, pd;
	getchild(start, pa, pb);
	getchild(pa, pc, pd);
	if (pc == 0 && pd == 0) ret = add(ret, counting(pb));
	else ret = add(ret, add(count4(lefts, pb, pc, pd), count4(lefts, pb, pd, pc)));
	getchild(pb, pc, pd);
	if (pc == 0 && pd == 0) ret = add(ret, counting(pa));
	else ret = add(ret, add(count4(lefts, pa, pc, pd), count4(lefts, pa, pd, pc)));
	
	ret = add(ret, count4(lefts - 1, 0, pa, pb));
	ret = add(ret, count4(lefts - 1, 0, pb, pa));
	
	return ret;
}

int case3()
{
	int st;
	for (st = 1; st <= n; st++) if (deg[st] == 3) break;
	dfsearch(st);
	int ret = 0;
	for (vector<int>::iterator it = ga[st].begin(); it != ga[st].end(); it++)
	{
		pre[st] = *it;
		int a, b, c, d;
		getchild(st, a, b);
		getchild(*it, c, d);
		ret = add(ret, mul(count2(a, c), count2(b, d)));
		if (c != d) ret = add(ret, mul(count2(a, d), count2(b, c)));
	}
	return mul(ret, 4);
}

int case2()
{
	if (n == 2) return 2;
	else if (n == 4) return 8;
	else return add(mul(mul(n / 2 - 2, n / 2 - 1), 2), mul(n, 2));
}

int main()
{
	scanf("%d", &n);
	n += n;
	for (int i = 1; i < n; i++)
	{
		int x, y;
		scanf("%d%d", &x, &y);
		insertedge(x, y);
	}
	
	if (maxalldeg > 3) printf("0\n");
	else if (maxalldeg == 3) printf("%d\n", case3());
	else printf("%d\n", case2());
	
	return 0;
}
