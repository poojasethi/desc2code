#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<cstring>
using namespace std;

#define N   200100
#define pb  push_back
#define ppb pop_back
#define Mod 1000000007
#define cal(a) ( (a==1)?2:((2LL*(n*n-n+2))%Mod) )

typedef long long LL;
int n, m, size[N], stra[N], ppi[N], ddep[N];
LL dp[N];
vector<int> nxt[N];

bool col[N];
void dfs(int p, int pr = -1){
    size[p] =1;
    int i=0;
    while(i<nxt[p].size()){
        int to = nxt[p][i];
        if(to == pr){
            swap(nxt[p][i], nxt[p].back());
            nxt[p].ppb();
            continue;
        }   
        dfs(to, p);
        size[p]+=size[to];  
        i++;
    }
    if(nxt[p].size() != 1) ppi[p]=p, ddep[p]=0;
    else                   ppi[p]=ppi[nxt[p][0]], ddep[p]=ddep[nxt[p][0]]+1;
    if(nxt[p].size() == 0) stra[p]=true;
    if(nxt[p].size() == 1 && stra[nxt[p][0]]==true) stra[p]=true;
}

LL solve();
LL solve(int p);
LL solve(int p1, int p2);

inline bool judge(int v){
    return stra[v];
}
LL solve(int p){
    if(dp[p]>=0) return dp[p];
    if(size[p]%2 == 1) return dp[p]=0;
    
    LL ans = 0LL;
    if(nxt[p].size() == 1){
        int pi=ppi[p], dep=ddep[p];
        if(nxt[pi].size() == 0) return dp[p] = size[p]/2;
        int v, av, sav;
        for(int i=0; i<2; i++){
            v = nxt[pi][i], av = nxt[pi][1-i];
            sav = nxt[av].size();
            if(sav == 0 && !dep) ans = (ans+solve(v))%Mod;
            if(sav == 1) {
                if(!dep) ans = (ans + solve(v, nxt[av][0]))%Mod;
                else if(size[av] == dep+1 && judge(av)) ans = (ans +solve(v))%Mod;  
            }
            if(sav == 2){
                int p1=nxt[av][0], p2=nxt[av][1];
                if(size[p1] == dep && judge(p1)) ans = (ans + solve(p2, v))%Mod;
                if(size[p2] == dep && judge(p2)) ans = (ans + solve(p1, v))%Mod;
            }
        }   
        for(int i=0; i<2; i++){
            v = nxt[pi][i], av = nxt[pi][1-i];
            sav = nxt[av].size();
            if(sav == 0 && dep == 2) ans = (ans + solve(v))%Mod;
            if(sav == 1 && judge(av) && dep == size[av]+1) ans = (ans + solve(v))%Mod;
        }
        int next=nxt[p][0];
        if(nxt[next].size() == 1)
        ans =(ans + solve(nxt[next][0]))%Mod;   
        return dp[p]=ans;
    }
    
    for(int i=0; i<2; i++){
        int v= nxt[p][i], av=nxt[p][1-i];
        if(nxt[av].size() == 0) ans = (ans + solve(v))%Mod;
        if(nxt[av].size() == 1) ans = (ans + solve(v, nxt[av][0]))%Mod;
    }
    return dp[p] = ans;
}
LL solve(int a, int b){
    if(nxt[a].size()>nxt[b].size()) swap(a,b);
    if(nxt[b].size() == 2) return 0LL;
    if(nxt[b].size() == 0) return 1LL;
    if(nxt[a].size() == 0) return solve(nxt[b][0]);
    return solve(nxt[a][0], nxt[b][0]);
}
LL solve(){
    int rot = -1;
    int cnt = 0;
    for(int i=0; i<m; i++){
        if(nxt[i].size() >= 4) return 0LL;
        if(nxt[i].size() == 3) rot = i, cnt++;  
    }
    if(rot == -1) return cal(n);
    dfs(rot);
    LL ans = 0LL;
    int ord[] = {0, 1, 2};
    int l, mi ,r;
    do{
            l = nxt[rot][ord[0]], mi = nxt[rot][ord[1]], r = nxt[rot][ord[2]];
            int sim = nxt[mi].size();
            if(sim == 0) ans = (ans + solve(l) * solve(r)) %Mod;
            if(sim == 1) {
                ans = (ans + solve(l) * solve(r, nxt[mi][0]))%Mod;
                ans = (ans + solve(r) * solve(l, nxt[mi][0]))%Mod;
            }
            if(sim == 2) {
                int sm1 = nxt[mi][0], sm2 = nxt[mi][1];
                ans = (ans + solve(l, sm1) * solve(r, sm2))%Mod;
                ans = (ans + solve(r, sm1) * solve(l, sm2))%Mod;
            }
    }while(next_permutation(ord, ord+3));
    return (2LL*ans)%Mod;
}
int main()
{
    scanf("%d", &n);
    m = 2*n;
    for(int i=0; i<m+10; i++)dp[i]=-1, stra[i] = 0;
    for(int i = 0; i<m-1; i++){
        int ad1 , ad2;
        scanf("%d%d", &ad1, &ad2);  ad1--, ad2--;
        nxt[ad1].pb(ad2), nxt[ad2].pb(ad1);
    }
    LL ans = solve();
    cout<<ans<<endl;
}