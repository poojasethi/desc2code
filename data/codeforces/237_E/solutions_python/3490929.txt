from heapq import heappush, heappop
from collections import namedtuple, Counter
MAX_V = 300
INF = 1 << 28
C = 26
Edge = namedtuple('Edge', 'to cap cost rev')
g = [[] for i in xrange(MAX_V)]


def add_edge(from_, to, cap, cost):
    g[from_].append(Edge(to, cap, cost, len(g[to])))
    g[to].append(Edge(from_, 0, -cost, len(g[from_]) - 1))


def min_cost_flow(s, t, flow):
    prev = [(0, 0)] * V
    h = [0] * V
    r = 0
    while flow > 0:
        d = [INF] * V
        pq = []
        heappush(pq, (0, s))
        d[s] = 0
        while pq:
            pd, v = heappop(pq)
            if pd > d[v]:
                continue
            for i, e in enumerate(g[v]):
                if e.cap > 0 and d[e.to] > d[v] + e.cost + h[v] - h[e.to]:
                    d[e.to] = d[v] + e.cost + h[v] - h[e.to]
                    prev[e.to] = (v, i)
                    heappush(pq, (d[e.to], e.to))
        if d[t] == INF:
            return -1
        for v in xrange(V):
            h[v] += d[v]
        f = flow
        v = t
        while v != s:
            v, i = prev[v]
            f = min(f, g[v][i].cap)
        flow -= f
        r += h[t] * f
        v = t
        while v != s:
            v, i = prev[v]
            e = g[v][i]
            g[v][i] = Edge(e.to, e.cap - f, e.cost, e.rev)
            re = g[e.to][e.rev]
            g[e.to][e.rev] = Edge(re.to, re.cap + f, re.cost, re.rev)
    return r


def solve():
    for k, v in Counter(t).items():
        add_edge(ord(k) - ord('a'), T, v, 0)
    for i, s in enumerate(ss):
        add_edge(S, C + i, a[i], 0)
        for k, v in Counter(s).items():
            add_edge(C + i, ord(k) - ord('a'), v, i + 1)
    return min_cost_flow(S, T, len(t))

if __name__ == '__main__':
    t = raw_input()
    n = input()
    ss, a = [], []
    for i in xrange(n):
        k, v = raw_input().split()
        ss.append(k)
        a.append(int(v))
    V = C + n + 2
    S = C + n
    T = S + 1
    print solve()
