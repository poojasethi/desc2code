#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int INF=2000000000;
const int M=10000;
int src,dest;
int T,head[M],dis[M],flow[M],n;
bool mark[M];
struct Edge{
	int to,cap,cost,nxt;
}edge[M<<2];
void add(int s,int t,int c,int cost){
	edge[T]=(Edge){t,c,cost,head[s]};
	head[s]=T++;
	edge[T]=(Edge){s,0,-cost,head[t]};
	head[t]=T++;
}
int Q[M<<4],pre[M],fa_edge[M];
bool SPFA(){
	for(int i=0;i<=dest;i++) mark[i]=0,dis[i]=INF;
	mark[src]=1;dis[src]=0;
	flow[src]=INF;
	int L=0,H=0;
	Q[H++]=src;
	while(L<H){
		int k=Q[L++];
		mark[k]=0;
		for(int i=head[k];~i;i=edge[i].nxt){
			int y=edge[i].to;
			if(edge[i].cap&&dis[y]>dis[k]+edge[i].cost){
				dis[y]=dis[k]+edge[i].cost;
				pre[y]=k;
				fa_edge[y]=i;
				flow[y]=min(flow[k],edge[i].cap);
				if(!mark[y]){
					mark[y]=1;
					Q[H++]=y;
				}
			}
		}
	}
	return (dis[dest]!=INF);
}
int min_cost(){
	int ans=0,x;
	while(SPFA()){
		ans+=dis[dest]*flow[dest];
		x=dest;
		while(x!=src){
			edge[fa_edge[x]].cap-=flow[dest];
			edge[fa_edge[x]^1].cap+=flow[dest];
			x=pre[x];
		}
	}
	bool f=1;
	for(int i=0;i<T;i++)
		if(edge[i].to==dest&&edge[i].cap!=0) f=0;
	if(f) return ans;
	else return -1;
}
char str[205];
int B[200];
int main(){
	for(int i='a';i<='z';i++)
		B[i]=i-'a'+2;
	scanf("%s",str);
	scanf("%d",&n);
	dest=27+n+2;
	for(int i=1;i<=dest;i++)
		head[i]=-1;
	for(int i=0;i<strlen(str);i++)
		add(B[str[i]],dest,1,0);
	src=1;
	int cnt=0;
	for(int i=1;i<=n;i++){
		int a;
		scanf("%s",str);
		scanf("%d",&a);
		add(src,27+i,a,0);
		for(int j=0;j<strlen(str);j++)
			add(27+i,B[str[j]],1,i);
	}
	printf("%d\n",min_cost());
	return 0;
}
	 				    		     	 	     	  	 	