#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<queue>
using namespace std;

const int MAXN=200;
const int INF=1000000;

int first[MAXN],next[20000],end[20000],w1[20000],w2[20000];
int s,t,tot=-1;
string T;

void add_edge(int x,int y,int s1,int s2){
	next[++tot]=first[x];
	first[x]=tot;
	end[tot]=y;
	w1[tot]=s1;
	w2[tot]=s2;
}

void add(int x,int y,int s1,int s2){
	add_edge(x,y,s1,s2);
	add_edge(y,x,0,-s2);
}

int check(const string &T,int a){
	int ans=0,len=T.size();
	for (int i=0; i<len; ++i)
		if (T[i]==a) ++ans;
	return ans;
}

int ans1=0,ans2=0;

namespace Flow{
	
	queue <int> q;
	int bo[MAXN],dis[MAXN],max_flow[MAXN],pre[MAXN],prd[MAXN];
	
	int value_flow(){
		for (int i=s; i<=t; ++i){
			bo[i]=0;
			dis[i]=INF;
			max_flow[i]=0;
		}
		q.push(s);
		dis[s]=0;
		max_flow[s]=INF;
		while (!q.empty()){
			int x=q.front();
			q.pop();
			bo[x]=0;
			for (int k=first[x]; k!=-1; k=next[k]){
				int l=end[k];
				if (w1[k]>0 && dis[l]>dis[x]+w2[k]){
					max_flow[l]=min(w1[k],max_flow[x]);
					pre[l]=x;  prd[l]=k;
					dis[l]=dis[x]+w2[k];
					if (!bo[l]) bo[l]=1,q.push(l);
				}
			}
		}
		return max_flow[t]>0;
	}
	
	void back_flow(){
		ans1+=max_flow[t];
		ans2+=dis[t]*max_flow[t];
		for (int x=t; x!=s; x=pre[x]){
			w1[prd[x]]-=max_flow[t];
			w1[prd[x]^1]+=max_flow[t];
		}
	}
}
 
int main(){
	int n;
	s=0;
	cin>>T;
	int len=T.size();
	memset(first,-1,sizeof(first));
	for (int i=0; i<26; ++i) add(s,i+1,check(T,i+'a'),0);
	scanf("%d",&n);
	t=26+n+1;
	for (int i=0; i<n; ++i){
		cin>>T;
		for (int j=0; j<26; ++j)
			add(j+1,26+i+1,check(T,j+'a'),0);
		int x;
		scanf("%d",&x);
		add(26+i+1,t,x,i+1);
	}
	while (Flow::value_flow()) Flow::back_flow();
	if (ans1<len) printf("-1\n");
	else printf("%d\n",ans2);
	return 0;
}


	 	  	 	  		 	 	 	 		 	