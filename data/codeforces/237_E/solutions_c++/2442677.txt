#include <iostream>
#include <queue>
#include <string>
#include <cstring>

using namespace std;

const int maxn = 101;
const int oo = ~0u>>1;

struct edge {
	int v,cap,cost;
	edge *next,*op;
	edge (int _v,int _cap,int _cost,edge *_next)
	: v(_v),cap(_cap),cost(_cost),next(_next) {}
};

string t, s[maxn];
int n, ans=0, a[maxn], d[maxn];
edge *E[maxn+30],*pre[maxn+30];
queue<int> q;
bool inq[maxn+30];

inline void add(int u,int v,int cap,int cost) {
	E[u]=new edge(v,cap,cost,E[u]);
	E[v]=new edge(u,0,-cost,E[v]);
	E[u]->op=E[v]; E[v]->op=E[u];
}

void build() {
	static int cnt[26];
	memset(cnt, 0, sizeof cnt);
	for (int i=0; i<t.size(); ++i)  ++cnt[t[i]-'a'];
	for (int i=0; i<26; ++i)
		if (cnt[i])  add(i+n+2,n+28,cnt[i],0);
	for (int i=1; i<=n; ++i) {
		add(1,i+1,a[i],i);
		memset(cnt,0,sizeof cnt);
		for (int j=0; j<s[i].size(); ++j)  ++cnt[s[i][j]-'a'];
		for (int j=0; j<26; ++j)
			if (cnt[j])  add(i+1,n+2+j,cnt[j],0);
	}
}

bool spfa() {
	for (int i=2; i<=n+28; ++i)  d[i]=oo;
	memset(inq,0,sizeof inq);
	d[1]=0;
	q.push(1); inq[1]=true;
	while(!q.empty()){
		int u=q.front();  q.pop(); inq[u]=false;
		for (edge *e=E[u];e;e=e->next)
			if (e->cap && d[u]+e->cost<d[e->v]){
				d[e->v]=d[u]+e->cost;
				pre[e->v]=e;
				if (!inq[e->v]) {
					q.push(e->v);  inq[e->v]=true;
				}
			}
	}
	return d[n+28]<oo;
}

int addflow() {
	int dt=oo,sum=0;
	for(edge *e=pre[n+28];e;e=pre[e->op->v]) {
		sum+=e->cost;
		if(dt>e->cap) dt=e->cap;
	}
	for(edge *e=pre[n+28];e;e=pre[e->op->v]) {
		e->cap-=dt; e->op->cap+=dt;
	}
	ans+=dt*sum;
	return dt;
}

int mincost_maxflow() {
	int ret=0;
	while (spfa())  ret+=addflow();
	return ret==t.size()? ans : -1;
}

int main() {
	cin >> t >> n;
	for (int i=1; i<=n; ++i)
		cin >> s[i] >> a[i];
	build();
	cout << mincost_maxflow() << endl;
	return 0;
}
