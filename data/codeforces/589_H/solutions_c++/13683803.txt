#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <cmath>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

struct node {
	node *next;
	int where;
} *first[50001], a[100001];
int n, m, k, l, cnt, dist[50001], w[50001], father[50001], c[50001], f[50001];
bool b[50001], p[50001];
vector<int> ans[50001];

inline void makelist(int x, int y) {
	a[++l].where = y; a[l].next = first[x];
	first[x] = &a[l];
}

int main() {
	scanf("%d%d%d", &n, &m, &k);
	memset(first, 0, sizeof(first)); l = 0;
	for (int i = 1; i <= m; i++) {
		int x, y;
		scanf("%d%d", &x, &y);
		makelist(x, y); makelist(y, x);
	}
	memset(p, 0, sizeof(p));
	memset(f, 0, sizeof(f));
	memset(father, 0, sizeof(father));
	for (int i = 1; i <= k; i++) {
		int x;
		scanf("%d", &x);
		p[x] = true; f[x] = x;
	}
	memset(b, false, sizeof(b)); cnt = 0;
	for (int i = 1; i <= n; i++)
		if (!b[i]) {
			b[i] = true; c[1] = i; int k = 1;
			for (int l = 1; l <= k; l++) {
				int m = c[l];
				for (node *x = first[m]; x; x = x->next) 
					if (!b[x->where]) 
						b[x->where] = true, c[++k] = x->where,
						father[x->where] = m;
			}
			for (int j = k; j; --j) {
				int m = c[j];
				for (node *x = first[m]; x; x = x->next)
					if (father[x->where] == m) 
						if (f[x->where]) 
							if (!f[m]) f[m] = f[x->where];
							else {
								ans[++cnt].clear();
								for (int y = f[x->where]; y != m; y = father[y])
									ans[cnt].push_back(y);
								ans[cnt].push_back(m);
								int len = 0;
								for (int y = f[m]; y != m; y = father[y])
									w[++len] = y;
								for (int y = len; y; --y) ans[cnt].push_back(w[y]);
								f[m] = 0;
							}
			}
		}
	printf("%d\n", cnt);
	for (int i = 1; i <= cnt; i++) {
		printf("%d", ans[i].size() - 1);
		for (int j = 0; j < ans[i].size(); j++) printf(" %d", ans[i][j]);
		printf("\n");
	}
}