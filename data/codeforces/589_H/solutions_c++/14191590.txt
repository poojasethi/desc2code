#pragma comment(linker, "/STACK:102400000,102400000")
#include <map>
#include <string>
#include <set>
#include <vector>
#include <cmath>
#include <queue>
#include <cstdio>
#include <cstring>
#include <utility>
#include <iostream>
#include <algorithm>
using namespace std;
const int maxn = 5e4 + 5;
struct edge{
	int to, next;
}e[maxn*2];
int head[maxn], fa[maxn], daan[maxn * 2], chang[maxn], cnt, ans, xian,dan;
bool isguan[maxn],vis[maxn];
inline void add_edge(int u,int v){
	e[cnt].to = v; e[cnt].next = head[u];	head[u] = cnt++;
	e[cnt].to = u; e[cnt].next = head[v];	head[v] = cnt++;
}

void print(int x, int gen){
	if (x != gen)print(fa[x], gen);
	daan[xian++] = x;
}

int dfs(int gen){
	int i, x[2], ge = 0;
	vis[gen] = true;
	for (i = head[gen]; i != -1; i = e[i].next){
		if (vis[e[i].to] == false){
			fa[e[i].to] = gen;
			x[ge] = dfs(e[i].to);
			if (x[ge] != 0)++ge;
		}
		if (ge == 2){
			while (x[0] != gen){
				daan[xian++] = x[0]; x[0] = fa[x[0]];
			}
			print(x[1], gen);
			chang[ans++] = xian - dan;
			dan = xian;
			ge = 0;
		}
	}
	if (isguan[gen]){
		x[ge] = gen;	ge++;
	}
	if (ge == 2){
		while (x[0] != gen){
			daan[xian++] = x[0]; x[0] = fa[x[0]];
		}
		print(x[1], gen);
		chang[ans++] = xian - dan;
		dan = xian;
		ge = 0;
	}
	if (ge == 1)return x[0];
	else return 0;
}
int main(void){
	int n, m, k,i,j,u,v;
	while (scanf("%d%d%d", &n, &m, &k) != EOF){
		memset(head, -1, sizeof(int)*(n + 1)); cnt = 0;
		for (i = 0; i < m; ++i){
			scanf("%d%d", &u, &v);
			add_edge(u, v);
		}
		memset(isguan, 0, sizeof(bool)*(n + 1));
		for (i = 0; i < k; ++i){
			scanf("%d", &u);	isguan[u] = true;
		}
		memset(vis, 0, sizeof(bool)*(n + 1));
		for (dan=xian=ans=0,i = 1; i <= n; ++i){
			if (vis[i] == false)dfs(i);
		}
		printf("%d\n", ans);
		for (i = dan = xian = 0; i < ans; ++i){
			printf("%d", chang[i] - 1);
			for (j = dan,xian=dan+chang[i]; j < xian; ++j){
				printf(" %d", daan[j]);
			}
			printf("\n"); dan = xian;
		}
	}
}








