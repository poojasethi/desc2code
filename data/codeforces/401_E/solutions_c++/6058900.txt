#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define maxn 100005
using namespace std;
long long i,j,k,l,n,m,s,an,sum,pp;
long long N,M,f[maxn],g[maxn],h[maxn],phi[maxn],u[maxn],p[maxn]; //f[n]为n的最小质因子，g[n]=f[n]^k，phi[n]为欧拉函数，u[n]为莫比乌斯函数，h[n]为一般积性函数 

void prime()
{
	u[1]=phi[1]=1,h[1]=(0); //1的时候特判 
	for (long long i=2; i<=N; i++)
	{
		if (!f[i]) p[++M]=i,f[i]=g[i]=i,phi[i]=i-1,u[i]=-1,h[i]=(0); //质数的时候特判 
		for (long long j=1,k; j<=M&&p[j]<=f[i]&&i*p[j]<=N; j++)
		{
			f[k=i*p[j]]=p[j];
			if (p[j]<f[i]) g[k]=p[j],phi[k]=phi[i]*phi[p[j]],u[k]=u[i]*u[p[j]],h[k]=h[i]*h[p[j]];
			else g[k]=g[i]*p[j],phi[k]=phi[i]*p[j],u[k]=0,h[k]=h[i/g[i]]*(0); /*质数次幂特判*/

	}
    }
}
long long calc(long long x,long long d,double R)
{
    if (x>R) return 0;
    long long y=int(sqrt(R*R-x*x)/d);
    y=min(y,m/d);
    if (!y) return 0;
    long long s=((m-d+1)+(m-y*d+1))*y/2%pp;
    return s*u[d];
}
long long work(double R)
{
    long long s=0;
    for (long long i=1;i<=n;i++)
    for (long long j=1;j*j<=i;j++)
    if (i%j==0)
    {
        s+=(n-i+1)*calc(i,j,R)%pp,s%=pp;
        if (j*j!=i) s+=(n-i+1)*calc(i,i/j,R)%pp,s%=pp;
    }
    return s;
}
int main()
{
    long long L,R;
    scanf("%I64d%I64d%I64d%I64d%I64d",&n,&m,&L,&R,&pp);
    //n++,m++;
    N=n;
    prime();
    an=work(R)*2;
    an-=work(L-1e-7)*2;
    an=(an%pp+pp)%pp;
    n++,m++;
    if ((1>=L)&&(l<=R)) an+=(n-1)*m+(m-1)*n,an%=pp;
    printf("%I64d\n",an);
    return 0;
}
