def validate_and_join(next, genom):
    for c, chunk in enumerate(genom):
        if next in chunk:
            return False

        # next is head of chunk
        if next[-1] in chunk:
            i = chunk.index(next[-1])
            for j in range(len(next) - 1, i - 1, -1):
                if chunk.startswith(next[-j:]):
                    next = next + chunk[j:]
                    genom.pop(c)
                    return validate_and_join(next, genom)

        # next is tail of chunk
        if next[0] in chunk:
            i = chunk.rindex(next[0])
            for j in range(len(next) - 1, i - 1, -1):
                if chunk.endswith(next[:j]):
                    next = chunk + next[j:]
                    genom.pop(c)
                    return validate_and_join(next, genom)

    genom.insert(0, next)
    return True

import sys
data = sys.stdin.read().split()
n = int(data.pop(0))
assert len(data) == n
data = sorted(data, key=len)
genom = [data.pop()]
while data:
    next = data.pop()
    validate_and_join(next, genom)
# final assemble
i = 0
while i < len(genom):
    next = genom.pop()
    if validate_and_join(next, genom):
        i = i + 1

sys.stdout.write(''.join(genom))