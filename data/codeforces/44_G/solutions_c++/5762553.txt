#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
#define N 120000
using namespace std;
int m,n,X[N],Y[N],idx[N],idy[N],ans[N],cnt,debug;
struct target{
	int x1,x2,y1,y2,h,id;
	void read(){
		scanf("%d%d%d%d%d",&x1,&x2,&y1,&y2,&h);
	}
}Q[N];
struct segtree{
	segtree *lch,*rch;
	int s;
	void renew(){
		s=m+1;
		if(lch)s=min(s,lch->s);
		if(rch)s=min(s,rch->s);
	}
	void change(int l,int r,int x,int k);
	int calc(int l,int r,int x,int y){
		int ans=m+1,mid=(l+r)/2;
		if(x<=l && y>=r)return s;
		if(x<=mid && lch)ans=min(ans,lch->calc(l,mid,x,y));
		if(y>mid && rch)ans=min(ans,rch->calc(mid+1,r,x,y));
		return ans;
	}
}st[18000000];
void segtree :: change(int l,int r,int x,int k){
	if(l==r){
		s=k;
		return;
	}
	int mid=(l+r)/2;
	if(x<=mid){
		if(!lch)lch=&st[++cnt];
		lch->change(l,mid,x,k);
	}else{
		if(!rch)rch=&st[++cnt];
		rch->change(mid+1,r,x,k);
	}
	renew();
}
struct Tree{
	Tree *lch,*rch;
	segtree *rt;
	Tree(){
		lch=rch=0;
		rt=&st[++cnt];
	}
	void change(int l,int r,int x,int y,int k){
		rt->change(1,m,y,k);
		if(l==r)return;
		int mid=(l+r)/2;
		if(x<=mid){
			if(!lch)lch=new Tree;
			lch->change(l,mid,x,y,k);
		}else{
			if(!rch)rch=new Tree;
			rch->change(mid+1,r,x,y,k);
		}
	}
	int calc(int l,int r,int x1,int x2,int y1,int y2){
		int ans=m+1,mid=(l+r)/2;
		if(x1<=l && x2>=r)return rt->calc(1,m,y1,y2);
		if(x1<=mid && lch)ans=min(ans,lch->calc(l,mid,x1,x2,y1,y2));
		if(x2>mid && rch)ans=min(ans,rch->calc(mid+1,r,x1,x2,y1,y2));
		return ans;
	}
}*T;
bool target_cmp(const target &a,const target &b){
	return a.h<b.h;
}
bool cmpx(const int &a,const int &b){
	return X[a]<X[b];
}
bool cmpy(const int &a,const int &b){
	return Y[a]<Y[b];
}
int main(){
	int i,tmp;
	scanf("%d",&n);
	for(i=1;i<=n;++i)Q[i].read(),Q[i].id=i;
	sort(Q+1,Q+n+1,target_cmp);
	scanf("%d",&m);
	for(i=1;i<=m;++i)scanf("%d%d",&X[i],&Y[i]),idx[i]=i,idy[i]=i;
	sort(idx+1,idx+m+1,cmpx);
	sort(idy+1,idy+m+1,cmpy);
	for(i=1;i<=n;++i){
		X[m+1]=Q[i].x1; Q[i].x1=lower_bound(idx+1,idx+m+1,m+1,cmpx)-idx;
		X[m+1]=Q[i].x2; Q[i].x2=upper_bound(idx+1,idx+m+1,m+1,cmpx)-idx-1;
		Y[m+1]=Q[i].y1; Q[i].y1=lower_bound(idy+1,idy+m+1,m+1,cmpy)-idy;
		Y[m+1]=Q[i].y2; Q[i].y2=upper_bound(idy+1,idy+m+1,m+1,cmpy)-idy-1;
	}
	for(i=1;i<=m;++i)X[idx[i]]=i,Y[idy[i]]=i;
	T=new Tree;
	for(i=1;i<=m;++i)T->change(1,m,X[i],Y[i],i);
	for(i=1;i<=n;++i){
		if(Q[i].x1>Q[i].x2 || Q[i].y1>Q[i].y2)continue;
		tmp=T->calc(1,m,Q[i].x1,Q[i].x2,Q[i].y1,Q[i].y2);
		if(tmp<=m){
			ans[tmp]=Q[i].id;
			T->change(1,m,X[tmp],Y[tmp],m+1);
		}
	}
		for(i=1;i<=m;++i)printf("%d\n",ans[i]);
}
