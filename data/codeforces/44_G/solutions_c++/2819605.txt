#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <set>
#include <map>
#include <cmath>
#include <sstream>
#include <iomanip>
#include <queue>
#include <ctime>
using namespace std;
template <class T> void checkmin(T &t,T x){if (x < t) t = x;}
template <class T> void checkmax(T &t,T x){if (x > t) t = x;}
template <class T> void _checkmin(T &t, T x){if (t == -1) t = x; if (x < t) t = x;}
template <class T> void _checkmax(T &t, T x){if (t == -1) t = x; if (x > t) t = x;}
typedef pair <int,int> PII;
typedef pair <double,double> PDD;
typedef long long lld;
#define foreach(it,v) for (__typeof((v).begin()) it = (v).begin();it != (v).end();it++)
#define DEBUG(a) cout << #a" = " << (a) << endl;
#define DEBUGARR(a, n) for (int i = 0; i < (n); i++) { cout << #a"[" << i << "] = " << (a)[i] << endl; }
const int N = 105555;
const int INF = 1000000000;
int n;
struct point {
	int x, y, id;
	point() {}
	point(int x, int y, int id):x(x),y(y),id(id){}
};

struct query {
	int xl, xr, yl, yr, z, id;
	query(int xl, int xr, int yl, int yr, int z, int id):xl(xl), xr(xr), yl(yl), yr(yr), z(z), id(id) {}
};
vector <query> Q;

bool _cmp(query a, query b) { return a.z < b.z; }
bool _cmp2(point a, point b) { return a.id < b.id; }

namespace {
	int pt;
	struct Node {
		bool div;
		int size;
		int minvalue;
		point element;
		Node *lc, *rc;

		void update() {
			if (lc && rc) {
				minvalue = min(lc->minvalue, rc->minvalue);
			} else {
				minvalue = size ? element.id : INF;
			}
		}
	}pool[N * 4], *root;

	bool cmpX(point a, point b) { return a.x < b.x || (a.x == b.x && a.y < b.y) || (a.x == b.x && a.y == b.y && a.id < b.id); }
	bool cmpY(point a, point b) { return a.y < b.y || (a.y == b.y && a.x < b.x) || (a.x == b.x && a.y == b.y && a.id < b.id); }
	bool cmp(point a, point b, bool div) { return div ? cmpY(a, b) : cmpX(a, b); }

	Node *build(point *a, int l, int r, bool div) {
		int mid = (l + r) / 2;
		nth_element(a + l, a + mid, a + r + 1, div ? cmpY : cmpX);
		Node *ret = &pool[pt++];
		ret->div = div;
		ret->size = r - l + 1;
		ret->element = a[mid];
		if (l != r) {
			ret->lc = build(a, l, mid, !div);
			ret->rc = build(a, mid + 1, r, !div);
		} else {
			ret->lc = ret->rc = NULL;
		}
		ret->update();
		return ret;
	}

	void remove(Node *p, const point o) {
		p->size--;
		if (p->lc && p->rc) {
			if (cmp(p->element, o, p->div)) {
				remove(p->rc, o);
			} else {
				remove(p->lc, o);
			}
		}
		p->update();
	}

	int getMin(Node *p, int xl, int xr, int yl, int yr) {
		if (!p || !p->size) return INF;
		if (xl == -INF && xr == INF && yl == -INF && yr == INF) return p->minvalue;
		if (!p->lc && !p->rc) {
		    return xl <= p->element.x && p->element.x <= xr && yl <= p->element.y && p->element.y <= yr ? p->element.id : INF;
		}
		if (!p->div) {
			int ret = INF;
			if (xl <= p->element.x)
				checkmin(ret, getMin(p->lc, xl, xr < p->element.x ? xr : INF, yl, yr));
			if (xr >= p->element.x)
				checkmin(ret, getMin(p->rc, xl > p->element.x ? xl : -INF, xr, yl, yr));
			return ret;
		} else {
			int ret = INF;
			if (yl <= p->element.y)
				checkmin(ret, getMin(p->lc, xl, xr, yl, yr < p->element.y ? yr : INF));
			if (yr >= p->element.y)
				checkmin(ret, getMin(p->rc, xl, xr, yl > p->element.y ? yl : -INF, yr));
			return ret;
		}
	}
}

point a[N];
int ans[N];

int main() {
//    freopen("in", "r", stdin);
	scanf("%d", &n);
	for (int i = 0; i < n; i++) {
		int xl, xr, yl, yr, z;
		scanf("%d%d%d%d%d", &xl, &xr, &yl, &yr, &z);
		Q.push_back(query(xl, xr, yl, yr, z, i + 1));
	}
	sort(Q.begin(), Q.end(), _cmp);
	scanf("%d", &n);
	for (int i = 0; i < n; i++) {
		int x, y;
		scanf("%d%d", &x, &y);
		a[i] = point(x, y, i + 1);
	}
	pt = 0;
	root = build(a, 0, n - 1, 0);
	sort(a, a + n, _cmp2);
	foreach (it, Q) {
//	    printf("%d\n", it->id);
		int ret = getMin(root, it->xl, it->xr, it->yl, it->yr);
		if (ret != INF) {
			ans[ret] = it->id;
			remove(root, a[ret - 1]);
		}
	}
	for (int i = 1; i <= n; i++) {
		printf("%d\n", ans[i]);
	}
	return 0;
}
