#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

using namespace std;

/*
 * */
#define MAXN 100100
#define INF 0x3f3f3f3f
struct POINT
{
	int x, y, id;
};
struct TARGET
{
	int x1, x2, y1, y2, z, id;
};
struct NODE
{
	int l, r, x, y, x1, x2, y1, y2, id, fa, h;
};
int N, M;
POINT P[MAXN];
TARGET T[MAXN];
NODE tree[MAXN];     //kd-tree
int root, tot, R[MAXN], ans;
bool used[MAXN];
bool cmp(const TARGET &t1, const TARGET &t2)
{
	return t1.z < t2.z;
}
bool xcmp(const POINT &t1, const POINT &t2)
{
	return t1.x < t2.x;
}
bool ycmp(const POINT &t1, const POINT &t2)
{
	return t1.y < t2.y;
}

void update(int rt)
{
	int ll = tree[rt].l, rr = tree[rt].r, mi = tree[tree[rt].h].id;
	if(used[mi])
		mi = INF, tree[rt].h = -1;
	if(!used[tree[rt].id] && tree[rt].id < mi)
		mi = tree[rt].id, tree[rt].h = rt;
	if(ll != -1 && tree[ll].h != -1 && tree[tree[ll].h].id < mi)
		mi = tree[tree[ll].h].id, tree[rt].h = tree[ll].h;
	if(rr != -1 && tree[rr].h != -1 && tree[tree[rr].h].id < mi)
		mi = tree[tree[rr].h].id, tree[rt].h = tree[rr].h;
}

void build(int &rt, int ll, int rr, int x1, int y1, int x2, int y2, int fa, int flag)
{
	if(ll > rr) return;
	int mid = (ll + rr) / 2, x, y;
	rt = tot++;
	tree[rt].fa = fa, tree[rt].l = tree[rt].r = -1, tree[rt].h = rt;
	tree[rt].x1 = x1, tree[rt].x2 = x2, tree[rt].y1 = y1, tree[rt].y2 = y2;
	if(flag)
	{
		nth_element(P + ll, P + mid, P + rr + 1, xcmp);
		tree[rt].id = P[mid].id, x = tree[rt].x = P[mid].x, y = tree[rt].y = P[mid].y;
		build(tree[rt].l, ll, mid - 1, x1, y1, x, y2, rt, 1 - flag);
		build(tree[rt].r, mid + 1, rr, x, y1, x2, y2, rt, 1 - flag);
	}
	else
	{
		nth_element(P + ll, P + mid, P + rr + 1, ycmp);
		tree[rt].id = P[mid].id, x = tree[rt].x = P[mid].x, y = tree[rt].y = P[mid].y;
		build(tree[rt].l, ll, mid - 1, x1, y1, x2, y, rt, 1 - flag);
		build(tree[rt].r, mid + 1, rr, x1, y, x2, y2, rt, 1 - flag);
	}
	update(rt);
	//cout<<rt<<" "<<tree[rt].l<<" "<<tree[rt].r<<" "<<tree[rt].id<<" "<<tree[rt].h<<endl;
	//cout<<tree[rt].x<<" "<<tree[rt].y<<endl;
	//cout<<tree[rt].x1<<" "<<tree[rt].y1<<" "<<tree[rt].x2<<" "<<tree[rt].y2<<endl;
	//cout<<endl;
	return;
}

void query(int rt, int x1, int y1, int x2, int y2, int &res)
{
	if(rt == -1 || x1 > tree[rt].x2 || x2 < tree[rt].x1 || y1 > tree[rt].y2 || y2 < tree[rt].y1) return;
    if(tree[rt].h == -1 || res != -1 && tree[res].id <= tree[tree[rt].h].id) return;

	if(x1 <= tree[rt].x1 && x2 >= tree[rt].x2 && y1 <= tree[rt].y1 && y2 >= tree[rt].y2)
    {
        if(res == -1 || tree[tree[rt].h].id < tree[res].id) res = tree[rt].h;
        return;
    }

	if(!used[tree[rt].id] && tree[rt].x >= x1 && tree[rt].x <= x2 && tree[rt].y >= y1 && tree[rt].y <= y2)
    {
        if(res == -1 || tree[rt].id < tree[res].id) res = rt;
    }
	query(tree[rt].l, x1, y1, x2, y2, res);
	query(tree[rt].r, x1, y1, x2, y2, res);
	return;
}

int main()
{
	//freopen("input.txt", "r", stdin);
	int x1, x2, y1, y2, x, y, z;
	scanf("%d", &N);
	for(int i = 0; i < N; i++)
	{
		scanf("%d%d%d%d%d", &T[i].x1, &T[i].x2, &T[i].y1, &T[i].y2, &T[i].z);
        T[i].id = i;
	}
	sort(T, T + N, cmp);
	scanf("%d", &M);
	x1 = y1 = INF, x2 = y2 = 0;
	for(int i = 0; i < M; i++)
	{
		scanf("%d%d", &P[i].x, &P[i].y);
        P[i].id = i;
		x1 = min(x1, P[i].x);
		x2 = max(x2, P[i].x);
		y1 = min(y1, P[i].y);
		y2 = max(y2, P[i].y);
	}
	//cout<<x1<<" "<<y1<<" "<<x2<<" "<<y2<<endl;
	tot = 0;
	build(root, 0, M - 1, x1, y1, x2, y2, -1, 0);
	memset(used, false, sizeof(used));
	memset(R, 0, sizeof(R));
	for(int i = 0; i < N; i++)
	{
        int res = -1;
		query(root, T[i].x1, T[i].y1, T[i].x2, T[i].y2, res);
		//cout<<res<<endl;
		if(res != -1)
		{
			used[tree[res].id] = true;
			R[tree[res].id] = T[i].id + 1;
			for(; res != -1; res = tree[res].fa)
				update(res);
		}
	}
	//cout<<endl;
	for(int i = 0; i < M; i++)
		printf("%d\n", R[i]);
	return 0;
}

