#include <stdio.h>
#include <string.h>
#include <algorithm>
#define maxn 100010

using namespace std;

struct target{
	int xl,xr,yl,yr,z,id;
	friend bool operator < (const target &a,const target &b){
		return a.z<b.z;
	}
	void read(){
		scanf("%d%d%d%d%d",&xl,&xr,&yl,&yr,&z);
	}
} a[maxn];

struct node{
	int x,y,id;
	friend bool operator < (const node &a,const node &b){
		return a.x<b.x;
	}
	void read(){
		scanf("%d%d",&x,&y);
	}
	void pr(){
		printf("%d %d id=%d\n",x,y,id);
	}
} b[maxn];

int idx[maxn];
int n,m;
inline bool cmp(int x,int y){
	return b[x].y<b[y].y;
}
inline int get_min(const int &x,const int &y){
	if (x==-1) return y;
	if (y==-1) return x;
	return b[x].id<b[y].id?x:y;
}
struct segment_tree{
	int n;
	int *x;
	int *pos;
	int *tree;
	void build(int p,int tl,int tr){
		if (tl==tr){
			tree[p]=idx[tl];
			return;
		}
		int m=(tl+tr)>>1;
		build(p<<1,tl,m);
		build((p<<1)+1,m+1,tr);
		tree[p]=get_min(tree[p<<1],tree[(p<<1)+1]);
	}
	void init(int st,int N){
		n=N;
		x=new int[N];
		pos=new int[N];
		for (int i=0;i<n;i++) idx[i]=st+i;
		sort(idx,idx+n,cmp);
		for (int i=0;i<n;i++) pos[idx[i]-st]=i;
		for (int i=0;i<n;i++) x[i]=b[idx[i]].y;
		tree=new int[N<<2];
		build(1,0,n-1);
	}
	int ask(int p,int tl,int tr,int l,int r){
		if (r<x[tl] || l>x[tr]) return -1;
		if (l<=x[tl] && x[tr]<=r){
			return tree[p];
		}
		int m=(tl+tr)>>1;
		return get_min(ask(p<<1,tl,m,l,r),ask((p<<1)+1,m+1,tr,l,r));
	}
	int find(int l,int r){
		return ask(1,0,n-1,l,r);
	}
	void DEL(int p,int tl,int tr,int k){
		if (tl==tr){
			tree[p]=-1;
			return;
		}
		int m=(tl+tr)>>1;
		if (k<=m) DEL(p<<1,tl,m,k);else DEL((p<<1)+1,m+1,tr,k);
		tree[p]=get_min(tree[p<<1],tree[(p<<1)+1]);
	}
	void del(int p){
		DEL(1,0,n-1,pos[p]);
	}
} tree[maxn<<2];

int ans[maxn];
int x[maxn],xn;

void init(int p,int tl,int tr){
	tree[p].init(tl,tr-tl+1);
	if (tl==tr) return;
	int m=(tl+tr)>>1;
	init(p<<1,tl,m);
	init((p<<1)+1,m+1,tr);
}
int XL,XR,YL,YR;
int find(int p,int tl,int tr,int l,int r){
	if (l>b[tr].x || r<b[tl].x) return -1;
	if (b[tl].x>=l && b[tr].x<=r){
		return tree[p].find(YL,YR);
	}
	int m=(tl+tr)>>1;
	return get_min(find(p<<1,tl,m,l,r),find((p<<1)+1,m+1,tr,l,r));
}
void del(int p,int tl,int tr,int k){
	tree[p].del(k-tl);
	if (tl==tr) return;
	int m=(tl+tr)>>1;
	if (k<=m) del(p<<1,tl,m,k);else del((p<<1)+1,m+1,tr,k);
}
void work(){
	b[m].id=m;
	xn=0;
	for (int i=0;i<m;i++) x[xn++]=b[i].x;
//	for (int i=0;i<m;i++) b[i].pr();
	init(1,0,m-1);
	memset(ans,-1,sizeof(ans));
	for (int i=0;i<n;i++){
		XL=a[i].xl;XR=a[i].xr;
		YL=a[i].yl;YR=a[i].yr;
		int x=find(1,0,m-1,XL,XR);
		if (x!=-1){
			ans[b[x].id]=a[i].id;
			del(1,0,m-1,x);
		}
	}
}

int main(){
	scanf("%d",&n);
	for (int i=0;i<n;i++) a[i].read();
	for (int i=0;i<n;i++) a[i].id=i;
	sort(a,a+n);

	scanf("%d",&m);
	for (int i=0;i<m;i++) b[i].read();
	for (int i=0;i<m;i++) b[i].id=i;
	sort(b,b+m);
	work();
	for (int i=0;i<m;i++) printf("%d\n",ans[i]+1);
	return 0;
}
