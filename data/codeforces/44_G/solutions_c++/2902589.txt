#include<iostream>
#include<fstream>
#include<sstream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<vector>
#include<map>
#include<cstring>
using namespace std;

#define FOR(I,A,B) for (int I=int(A);I<int(B);++I)
#define MEM(A,B) memset(A,B,sizeof(A))
#define CPY(A,B) memcpy(A,B,sizeof(B))
#define FIN(A) freopen(A, "r", stdin)
#define FOUT(A) freopen(A, "w", stdout)
typedef long long LL;
const int N(100010), INF(99999999);
int sort_key, n, m, b;
int pos[N], hit[N];
struct Query {
    int xl, xr, yl, yr, z, id;
    void get(int _id) {
        scanf("%d%d%d%d%d", &xl, &xr, &yl, &yr, &z);
        id = _id;
    }
    bool operator < (const Query &a) const {return z < a.z;}
}qu[N];
struct Point {
    int x[2];
    int id, minId;
    void get(int _id) {
        scanf("%d%d", &x[0], &x[1]);
        id = _id;
    }
    bool operator < (const Point &a) const {return x[sort_key] < a.x[sort_key];}
}p[N];
double sqr(double x) {
    return x * x;
}
struct KDTree {
    int split[N];
    void update(int l, int r) {
        int mid = (l + r) / 2;
        p[mid].minId = p[mid].id;
        if (l != mid) p[mid].minId = min(p[mid].minId, p[(l + mid - 1) / 2].minId);
        if (mid != r) p[mid].minId = min(p[mid].minId, p[(mid + 1 + r) / 2].minId);
    }
    int getSplit(int l, int r) {
        double val[2];
        MEM(val, 0);
        FOR(i, 0, 2) {
            double ave = 0;
            FOR(j, l, r + 1)
                ave += p[j].x[i];
            ave /= (r - l + 1);
            FOR(j, l, r + 1)
                val[i] += sqr(p[j].x[i] - ave);
        }
        return val[0] > val[1] ? 0 : 1;
    }
    void buildTree(int l, int r) {
        if (l > r) return;
        int mid = (l + r) / 2;
        sort_key = split[mid] = getSplit(l, r);
        nth_element(p + l, p + mid, p + r + 1);
        pos[p[mid].id] = mid;
        buildTree(l, mid - 1);
        buildTree(mid + 1, r);
        update(l, r);
    }
    void getBullet(int l, int r, int xl, int xr, int yl, int yr) {
        if (l > r || xl > xr || yl > yr) return;
        int mid = (l + r) / 2;
        if (xl == -INF && xr == INF && yl == -INF && yr == INF) b = min(b, p[mid].minId);
        if (xl <= p[mid].x[0] && p[mid].x[0] <= xr && yl <= p[mid].x[1] && p[mid].x[1] <= yr) b = min(b, p[mid].id);
        if (b <= p[mid].minId) return;
        if (split[mid]) {
            if (yl <= p[mid].x[1]) getBullet(l, mid - 1, xl, xr, yl, p[mid].x[1] <= yr ? INF : yr);
            if (p[mid].x[1] <= yr) getBullet(mid + 1, r, xl, xr, yl <= p[mid].x[1] ? -INF : yl, yr);
        }
        else {
            if (xl <= p[mid].x[0]) getBullet(l, mid - 1, xl, p[mid].x[0] <= xr ? INF : xr, yl, yr);
            if (p[mid].x[0] <= xr) getBullet(mid + 1, r, xl <= p[mid].x[0] ? -INF : xl, xr, yl, yr);
        }
    }
    void modify(int l, int r, int po) {
        int mid = (l + r) / 2;
        if (po < mid) modify(l, mid - 1, po);
        else if (po > mid) modify(mid + 1, r, po);
        else p[mid].id = m;
        update(l, r);
    }
}kd;
int main() {
    scanf("%d", &n);
    FOR(i, 0, n)
        qu[i].get(i);
    scanf("%d", &m);
    FOR(i, 0, m)
        p[i].get(i);
    kd.buildTree(0, m - 1);
    sort(qu, qu + n);
    MEM(hit, -1);
    FOR(i, 0, n) {
        b = m;
        kd.getBullet(0, m - 1, qu[i].xl, qu[i].xr, qu[i].yl, qu[i].yr);
        if (b < m) {
            hit[b] = qu[i].id;
            kd.modify(0, m - 1, pos[b]);
        }
    }
    FOR(i, 0, m)
        printf("%d\n", hit[i] + 1);
    return 0;
}
