/* ***********************************************
Author        :kuangbin
Created Time  :2014/9/6 12:01:49
File Name     :E:\2014ACM\专题学习\KD树\CF44G_2.cpp
************************************************ */

#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <string>
#include <math.h>
#include <stdlib.h>
#include <time.h>
using namespace std;
const int MAXN = 100010;
const int INF = 0x3f3f3f3f;
struct Point{
	int x,y,id;
	bool operator ==(const Point &b)const{
		return x == b.x && y == b.y && id == b.id;
	}
};
struct Node{
	Point e;
	Node *lc,*rc;
	bool div;
	int sub,cur;
	int size;
	bool exist;
	void push_up(){
		size = lc->size + rc->size + exist;
		sub = min(cur,min(lc->sub,rc->sub));
	}
}pool[MAXN],*root,*tail,*null;
inline bool cmpX(const Point &a,const Point &b){return a.x < b.x || (a.x == b.x && a.y < b.y) || (a.x == b.x && a.y == b.y && a.id < b.id);}
inline bool cmpY(const Point &a,const Point &b){return a.y < b.y || (a.y == b.y && a.x < b.x) || (a.y == b.y && a.x == b.x && a.id < b.id);}
inline bool cmp(const Point &a,const Point &b,bool div){return div?cmpY(a,b):cmpX(a,b);}
Node* build(Point *a,int l,int r,bool div){
	if(l >= r)return null;
	Node *p = tail++;
	p->div = div;
	int mid = (l+r)/2;
	nth_element(a+l,a+mid,a+r,div?cmpY:cmpX);
	p->e = a[mid];
	p->lc = build(a,l,mid,!div);
	p->rc = build(a,mid+1,r,!div);
	p->exist = 1;
	p->cur = p->e.id;
	p->push_up();
	return p;
}
void remove(Node *p,Point o){
	if(p->e == o){
		p->exist = 0;
		p->cur = INF;
		p->size--;
	}
	else {
		if(cmp(p->e,o,p->div))remove(p->rc,o);
		else remove(p->lc,o);
	}
	p->push_up();
}
int getMin(Node *p,int xl,int xr,int yl,int yr,int minx,int maxx,int miny,int maxy){
	if(p == null || p->size == 0)return INF;
	if(xl <= minx && xr >= maxx && yl <= miny && yr >= maxy)return p->sub;
	if(xl > maxx || xr < minx || yl > maxy || yr < miny)return INF;
	int ret = INF;
	if(p->e.x >= xl && p->e.x <= xr && p->e.y >= yl && p->e.y <= yr)
		ret = min(ret,p->cur);
	if(p->div){
		if(yl <= p->e.y)
			ret = min(ret,getMin(p->lc,xl,xr,yl,min(yr,p->e.y),minx,maxx,miny,min(maxy,p->e.y)));
		if(yr >= p->e.y)
			ret = min(ret,getMin(p->rc,xl,xr,max(yl,p->e.y),yr,minx,maxx,max(miny,p->e.y),maxy));
	}
	else {
		if(xl <= p->e.x)
			ret = min(ret,getMin(p->lc,xl,min(xr,p->e.x),yl,yr,minx,min(maxx,p->e.x),miny,maxy));
		if(xr >= p->e.x)
			ret = min(ret,getMin(p->rc,max(xl,p->e.x),xr,yl,yr,max(minx,p->e.x),maxx,miny,maxy));
	}
	return ret;
}
Point pp[MAXN],pp2[MAXN];
struct REC{
	int xl,xr,yl,yr,z;
	int id;
	void input(){
		scanf("%d%d%d%d%d",&xl,&xr,&yl,&yr,&z);
	}
	bool operator <(const REC &b)const{
		return z < b.z;
	}
}rec[MAXN];
int ans[MAXN];
int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);
    int n,m;
	while(scanf("%d",&n) == 1){
		for(int i = 0;i < n;i++){
			rec[i].input();
			rec[i].id = i+1;
		}
		sort(rec,rec+n);
		scanf("%d",&m);
		for(int i = 0;i < m;i++){
			scanf("%d%d",&pp[i].x,&pp[i].y);
			pp[i].id = i;
			pp2[i] = pp[i];//备份
		}
		tail = pool;
		null = tail++;
		null->size = 0;
		null->sub = null->cur = INF;
		null->lc = null->rc = null;
		root = build(pp,0,m,0);
		memset(ans,0,sizeof(ans));
		for(int i = 0;i < n;i++){
			int tmp = getMin(root,rec[i].xl,rec[i].xr,rec[i].yl,rec[i].yr,-INF,INF,-INF,INF);
			if(tmp == INF)continue;
			//cout<<tmp<<endl;
			ans[tmp] = rec[i].id;
			remove(root,pp2[tmp]);
		}
		for(int i = 0;i < m;i++)printf("%d\n",ans[i]);
	}
    return 0;
}
