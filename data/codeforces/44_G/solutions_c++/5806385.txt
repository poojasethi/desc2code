#include <cstdio>
#include <algorithm>
#define maxn 100005
using namespace std;

struct st
{
	int l,r,u,d,h,p;
	bool operator <(const st&B) const {return h<B.h;}
} a[maxn];
struct node
{
	node*l,*r,*f;
	int x,y,x1,y1,x2,y2,p,s;
	node(int _x=0,int _y=0,int _p=1e9) {x=x1=x2=_x,y=y1=y2=_y,l=r=0,s=p=_p;}
}*t,*root,*bg[maxn],*null;
struct point
{
	int x,y;
} b[maxn];
int N,M,G,L,R,U,D,ans[maxn],q[maxn];

bool cmpx(int x,int y) {return b[x].x<b[y].x;}
bool cmpy(int x,int y) {return b[x].y<b[y].y;}
void renew(node*p,node*q)
{
	if (q==null) return;
	p->x1=min(p->x1,q->x1),p->x2=max(p->x2,q->x2);
	p->y1=min(p->y1,q->y1),p->y2=max(p->y2,q->y2);
	p->s=min(p->s,q->s);
}

void init()
{
	scanf("%d",&N);
	for (int i=1; i<=N; i++) scanf("%d%d%d%d%d",&a[i].l,&a[i].r,&a[i].d,&a[i].u,&a[i].h),a[i].p=i;
	sort(a+1,a+N+1),scanf("%d",&M);
	for (int i=1; i<=M; i++) scanf("%d%d",&b[i].x,&b[i].y),q[i]=i;
	null=new node,t=new node[M*2],root=null;
}

void build(node*&p,int l,int r,bool k)
{
	if (p==null) p=t++;
	int mi=(l+r)>>1;
	nth_element(q+l,q+mi,q+r+1,k?cmpy:cmpx);
	*p=node(b[q[mi]].x,b[q[mi]].y,q[mi]),p->l=p->r=p->f=null,bg[q[mi]]=p;
	if (l<mi) build(p->l,l,mi-1,!k),p->l->f=p,renew(p,p->l);
	if (mi<r) build(p->r,mi+1,r,!k),p->r->f=p,renew(p,p->r);
}

void query(node*p)
{
	if (p==null||p->s>=G||L>p->x2||R<p->x1||D>p->y2||U<p->y1) return;
	if (L<=p->x1&&p->x2<=R&&D<=p->y1&&p->y2<=U) {G=min(G,p->s); return;}
	if (L<=p->x&&p->x<=R&&D<=p->y&&p->y<=U) G=min(G,p->p);
	if (p->l->s<p->r->s) query(p->l),query(p->r); else query(p->r),query(p->l);
}

void doit()
{
	build(root,1,M,0);
	for (int i=1; i<=N; i++)
	{
		G=1e9,L=a[i].l,R=a[i].r,U=a[i].u,D=a[i].d,query(root);
		if (G==1e9) continue;
		ans[G]=a[i].p,bg[G]->p=1e9;
		for (node*p=bg[G]; p!=null; p=p->f) p->x1=p->x2=p->x,p->y1=p->y2=p->y,p->s=p->p,renew(p,p->l),renew(p,p->r);
	}
	for (int i=1; i<=M; i++) printf("%d\n",ans[i]);
}

int main()
{
	init();
	doit();
	return 0;
}