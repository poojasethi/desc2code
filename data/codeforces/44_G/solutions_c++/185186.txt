#include <stdio.h>
#include <algorithm>
#include <map>
#include <vector>
#include <queue>
#include <ctime>
using namespace std;
typedef pair<int,int> pii;
#define debug(x) 
#define debug2(x) 
int n,m;
int X[100000],Y[100000];
int minX[100000],minY[100000];
int maxX[100000],maxY[100000];
int shot[100000];
pii rct[100000];
struct qdNode;
qdNode* rev[100000];

const int INF = 987654321;
map< pii,queue<int> > forLeaf;

#define ch0contain (x<=X[id] && X[id]<x+h && y<=Y[id] && Y[id]<y+h)
#define ch1contain (x+h<=X[id] && X[id]<x+len && y<=Y[id] && Y[id]<y+h)
#define ch2contain (x<=X[id] && X[id]<x+h && y+h<=Y[id] && Y[id]<y+len)
#define ch3contain (x+h<=X[id] && X[id]<x+len && y+h<=Y[id] && Y[id]<y+len)

int cBest;

struct qdNode
{
	int x,y,len,val;
	qdNode* child[4];
	qdNode* parent;

	qdNode(int a,int b,int c,qdNode* p)
		:x(a),y(b),len(c),parent(p),val(INF)
	{
		for (int q=0;q<4;++q) child[q] = 0;
	}
	virtual ~qdNode()
	{
		for (int q=0;q<4;++q) if (child[q]) delete child[q];
	}
	qdNode* getChild(const int& id)
	{
		if (child[id]) return child[id];
		return child[id] = new qdNode( x + (len>>1) * (id&1), y + (len>>1) * !!(id&2) , len>>1, this);
	}
	void pushNode(const int& id)
	{
		debug(printf("pushing node ... [%d,%d] + [%d]\n",x,y,len);)
		if (id<val)	val = id;
		if (len==1)	{rev[val]=this;return;}
		const int h = len >> 1;
		if (ch0contain) getChild(0)->pushNode(id);
		else if (ch1contain) getChild(1)->pushNode(id);
		else if (ch2contain) getChild(2)->pushNode(id);
		else getChild(3)->pushNode(id);
	}
	int getMinIndex(const int& id)
	{
		debug(printf("searching node ... [%d,%d] + [%d] With Val = %d\n",x,y,len,val);)
		if (val>=cBest) return INF;//no hope T.T

		if (len==1) return val;
		if (minX[id] <= x && x + len - 1 <= maxX[id] && minY[id] <= y && y + len - 1 <= maxY[id] ) return val;
		int ret = INF;
		for (int q=0;q<4;++q)
		{
			qdNode* n = child[q];
			if (!n) continue;
			if ( n->x <= maxX[id] && minX[id] <= n->x + n->len - 1  && n->y <= maxY[id] && minY[id] <= n->y + n->len - 1 )
			{
				int t = n->getMinIndex(id);
				if (ret>t) ret=t;
			}
		}
		if (ret<cBest) cBest = ret;
		return ret;
	}
	void remove(const int &id)
	{
		if (val!=id) return;
		if (len==1) 
		{
			queue<int>& Q = forLeaf[pii(x,y)];
			Q.pop();
			if (Q.empty()) val = INF;
			else {val = Q.front(); rev[val]=this;}
			debug(printf("remove val %d from [%d,%d] + [%d]",id,x,y,len);)
			debug(printf(" Qpop: %d\n",val);)
		}
		else
		{
			val = INF;
			for (int q=0;q<4;++q) 
			{
				if (!child[q]) continue;
				if (child[q]->val == id) child[q]->remove(id);
				val=min(val,child[q]->val);
			}
			debug(printf("remove val %d from [%d,%d] + [%d]",id,x,y,len);)
			debug(printf("Result: %d\n",val);)
		}
		if (parent) parent->remove(id);
	}
};
int main()
{
	qdNode* root = new qdNode(0,0,1<<24,NULL);
	scanf("%d",&n);
	for (int q=0;q<n;++q)
	{
		int z;
		scanf("%d %d %d %d %d",minX+q,maxX+q,minY+q,maxY+q,&z);
		rct[q].first = z;
		rct[q].second = q;
	}
	sort(rct,rct+n);
	scanf("%d",&m);
	for (int q=0;q<m;++q) scanf("%d %d",X+q,Y+q);
	debug2(clock_t pStart = clock();)
	for (int q=0;q<m;++q)
	{
		forLeaf[pii(X[q],Y[q])].push(q);
		root->pushNode(q);
		shot[q]=0;
	}
	debug2(fprintf(stderr,"...Pushing Time : %d msec\n",clock()-pStart);)
	debug2(int schTime=0;)
	debug2(int remTime=0;)
	for (int q=0;q<n;++q)
	{
		const int &id = rct[q].second;
		debug(printf("searching %d\n",q));
		debug2(clock_t gStart=clock();)
		cBest = INF;
		int ret = root->getMinIndex(id);
		debug2(schTime+=clock()-gStart;)
		if (ret>=INF) continue;
		shot[ret] = id+1;
		debug2(clock_t rStart=clock();)
		rev[ret]->remove(ret);
		debug2(remTime+=clock()-rStart;)
	}
	debug2(fprintf(stderr,"...Searching Time : %d msec\n",schTime));
	debug2(fprintf(stderr,"...Remove Time : %d msec\n",remTime));
	for (int q=0;q<m;++q) printf("%d\n",shot[q]);
	return 0;
}
