#include <cstdio>
#include<set>
#include <math.h>
#include <algorithm>
const int inf = 1e9;
using namespace std;
#define LL long long
#define MAX 500005
#define N 850
typedef pair<LL,int> pii;
LL a[MAX];
int ansl,ansr;
struct bucket{
    set<pii> num;
    LL b;
    inline void add(int l, int r, int val) {
        if (r - l + 1 == (int)num.size())b += val;
        else {
            for (int i = l; i <= r; i++)
            {
                num.erase({ a[i], i });
                a[i] += val;
                num.insert({ a[i], i });
            }//修改值的方法！
        }
    }
    inline void find(LL x){
        x-=b;
        set<pii>::iterator it=num.lower_bound({x,-inf});
        if (it == num.end() || (*it).first != x)return;
        ansl = min(ansl, (*it).second);
        it = num.upper_bound({ x, inf }); it--;
        ansr = max(ansr, (*it).second);
    }
}y[N];
int main(){
    int n,q;
    scanf("%d%d",&n,&q);
    int Block=N;
    for(int i=0;i<n;++i)scanf("%lld",&a[i]);
    int block=0;
    for (int i = 0; i < n; i += Block, block++)
        for (int j = 0; i + j < n && j < Block; j++)
            y[block].num.insert({ a[i + j],i + j });
    while(q--){
        int com;
        scanf("%d",&com);
        if(com==1){
            int l,r,x;
            scanf("%d%d%d",&l,&r,&x);
            l--;r--;
            for (int i = l / Block; i <= r / Block; i++)
                y[i].add(max(l, i*Block), min(r, i*Block + Block - 1), x);
        }
        else{
            scanf("%d",&com);
            ansl = inf, ansr = -inf;
            for (int i = 0; i < block; i++)
                y[i].find(com);
            if (ansr - ansl < 0)puts("-1");
            else printf("%d\n",ansr-ansl);
        }
    }
    return 0;
}
