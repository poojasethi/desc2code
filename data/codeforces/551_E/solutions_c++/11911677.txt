#include <algorithm>
#include <iostream>
using namespace std;
const int MAX = 500005;
const int SQRT = 750;
long long add[SQRT], a[MAX], b[MAX];
int n, q;
void recalc(int p)
{
	for (int i = p * SQRT; i < min(n, (p + 1) * SQRT); i++)
	{
		b[i] = a[i] + add[p];
		a[i] = b[i];
	}
	add[p] = 0;
	sort(b + p * SQRT, b + min(n, (p + 1) * SQRT));
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n >> q;
	for (int i = 0; i < n; i++)
	{
		cin >> a[i];
		b[i] = a[i];
	}
	for (int i = 0; i < n; i += SQRT)
		sort(b + i, b + min(n, i + SQRT));
	while (q--)
	{
		int t;
		cin >> t;
		if (t == 1)
		{
			int l, r, x;
			cin >> l >> r >> x;
			l--;
			if (l % SQRT != 0)
			{
				int t = l / SQRT;
				while (l % SQRT != 0 && l < r)
					a[l++] += x;
				recalc(t);
			}
			if (r % SQRT != 0)
			{
				int t = r / SQRT;
				while (r % SQRT != 0 && l < r)
					a[--r] += x;
				recalc(t);
			}
			while (l < r)
			{
				add[l / SQRT] += x;
				l += SQRT;
			}
		}
		else
		{
			int val;
			cin >> val;
			int idl = 0;
			while (true)
			{
				int pos = lower_bound(b + idl * SQRT, b + min((idl + 1) * SQRT, n), val - add[idl]) - b;
				if (pos < min((idl + 1) * SQRT, n) && b[pos] + add[idl] == val)
					break;
				idl++;
				if (idl * SQRT >= n)
				{
					idl--;
					break;
				}
			}
			recalc(idl);
			idl = idl * SQRT;
			while (idl < n && a[idl] != val)
				idl++;
			int idr = (n + SQRT - 1) / SQRT;
			while (true)
			{
				int pos = lower_bound(b + (idr - 1) * SQRT, b + min(idr * SQRT, n), val - add[idr - 1]) - b;
				if (pos < min(idr * SQRT, n) && b[pos] + add[idr - 1] == val)
					break;
				idr--;
				if (idr == 0)
				{
					idr++;
					break;
				}
			}
			recalc(idr - 1);
			idr = min(n, idr * SQRT) - 1;
			while (idr >= 0 && a[idr] != val)
				idr--;
			if (idl > idr)
				idl = idr + 1;
			cout << idr - idl << "\n";
		}
	}
	return 0;
}
