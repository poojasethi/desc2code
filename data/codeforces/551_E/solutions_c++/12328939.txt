#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>
#define fi first
#define se second
#define mp make_pair
#define ll long long 
using namespace std;
int n,q,i,j,k,l,tp,sqr,m,syc,a,r,val;
struct node{
	pair < ll , ll > e[1600];
	int l,r;
	ll lazy;
}d[850];
void update(){
	 int i,j,k;
	 scanf("%d %d %d",&l,&r,&val);
	 for(i=1;i<=m;i++){
		 if(d[i].r < l || d[i].l>r)
		 continue;
		 if(d[i].l>=l && d[i].r<=r){
			 d[i].lazy+=val;
			 continue;
		 }
		 for(j=d[i].l;j<=d[i].r;j++)
		 if(d[i].e[j-d[i].l+1].se>=l && d[i].e[j-d[i].l+1].se<=r)
		 d[i].e[j-d[i].l+1].fi+=val;
		 sort(d[i].e+1,d[i].e+d[i].r-d[i].l+2);	 
		 }		 
}
int query(){
	ll maxpos=0,minpos=1e9;
    int i,j,k,bas,son,orta;
    scanf("%d",&val);
    for(i=1;i<=m;i++){
		bas=1,son=d[i].r-d[i].l+1;
		ll lazy=d[i].lazy;
		while(bas<=son){
			orta=(bas+son)/2;
			if(d[i].e[orta].fi+lazy>val)
			son=orta-1;
			if(d[i].e[orta].fi+lazy<val)
			bas=orta+1;
			if(d[i].e[orta].fi+lazy==val){
				minpos=min(minpos,d[i].e[orta].se);
				son=orta-1;
			}	
		}
		bas=1,son=d[i].r-d[i].l+1;
		while(bas<=son){
			orta=(bas+son)/2;
			if(d[i].e[orta].fi+lazy>val)
			son=orta-1;
			if(d[i].e[orta].fi+lazy<val)
			bas=orta+1;
			if(d[i].e[orta].fi+lazy==val){
				maxpos=max(maxpos,d[i].e[orta].se);
				bas=orta+1;
			}	
		}
	}
	if(minpos<1e9)
	return maxpos-minpos;
	return -1;
}
int main(){
	scanf("%d %d",&n,&q);
	l=1;
	sqr=sqrt(n);
	for(i=1;i<=sqr;i++){
		d[++syc].l=l;
		d[syc].r=l+sqr-1;
		l+=sqr;
	}
	if(l<=n){
		d[++syc].l=l;
		d[syc].r=n;
	}
	m=syc;
	for(i=1;i<=m;i++){
	    for(j=d[i].l;j<=d[i].r;j++){
			scanf("%d",&a);
			d[i].e[j-d[i].l+1]=mp(a,j);
		}
		sort(d[i].e+1,d[i].e+d[i].r-d[i].l+2);
	}
	for(i=1;i<=q;i++){
		scanf("%d",&tp);
		if(tp==1)
		update();
		else
		printf("%d\n",query());
	}		
}
	
