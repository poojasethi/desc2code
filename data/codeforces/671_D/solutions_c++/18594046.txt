#include<bits/stdc++.h>
using namespace std;
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define re(i,a,b) for(int i=(a);i<(b);i++)
#define repd(i,a,b) for(int i=(a);i>=(b);i--)
#define run(v) for(int k=head[v];k;k=e[k].ne)
#define v e[k].t
#define ergomap(i,a) for(map<int,int>::iterator i=a.begin();i!=a.end();i++)
#define ergoset(i,a) for(set<int>::iterator i=a.begin();i!=a.end();i++)
#define ergo(i,a) for(int i=0;i<a.size();i++)
#define clr(a) memset(a,0,sizeof(a));
#define il inline
#define sz(a) ((int)a.size())
#define pb push_back 
#define w1 first
#define w2 second
#define sc scanf
#define pt printf
#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}
typedef pair<int,int> pa;
typedef long long ll;typedef long double ld;typedef unsigned long long ull;
const int N=3e5+5,M=9e6+5,INF=1e9,mod=1e9+7;
const ll linf=1e18;const double eps=1e-8,pi=acos(-1);
il int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}
il void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}
il void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}
il void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}
il int read(){int x;read(x);return x;}
il ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}
il ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}
il void judge(){
	freopen("data.in","r",stdin);
	freopen("data.out","w",stdout);}
il void gen(){freopen("data.in","w",stdout);}
int n,m,bin[30]={1},cnt;
struct edge{int t,ne;}e[N*2];
int head[N];
void adde(int a,int b){
	e[++cnt]=(edge){b,head[a]};head[a]=cnt;
	e[++cnt]=(edge){a,head[b]};head[b]=cnt;
}int a[N],b[N],c[N];
int dep[N],tot;
int ls[M],rs[M];ll tg[M];ll f[N],mn[M];
#define mid (l+r>>1)
void maketg(int k,ll val){mn[k]+=val;tg[k]+=val;}
void pd(int k){
	if(tg[k]){
		if(ls[k])maketg(ls[k],tg[k]);
		if(rs[k])maketg(rs[k],tg[k]);tg[k]=0;
	}
}int merge(int a,int b,int l,int r){
	if(!a)return b;if(!b)return a;int ret=++tot;
	mn[ret]=min(mn[a],mn[b]);
	if(l==r)return ret;
	pd(a);pd(b);
	ls[ret]=merge(ls[a],ls[b],l,mid);
	rs[ret]=merge(rs[a],rs[b],mid+1,r);
	return ret;
}
ll ask(int k,int l,int r,int x,int y){
	if(!k)return linf;
	if(x<=l&&r<=y)return mn[k];pd(k);ll ret=linf;
	if(x<=mid)gmin(ret,ask(ls[k],l,mid,x,y));
	if(y>mid)gmin(ret,ask(rs[k],mid+1,r,x,y));
	return ret;
}
void add(int k,int l,int r,int x,int y,ll val){
	if(!k)return;
	if(x<=l&&r<=y){maketg(k,val);return;}
	if(x<=mid)add(ls[k],l,mid,x,y,val);
	if(y>mid)add(rs[k],mid+1,r,x,y,val);
}
void modify(int&k,int l,int r,int x,ll val){
	if(!k)mn[k=++tot]=val;else gmin(mn[k],val);
	if(l==r)return;pd(k);
	if(x<=mid)modify(ls[k],l,mid,x,val);else
		modify(rs[k],mid+1,r,x,val);
}int rt[N];vector<int>link[N];
void ss(int k,int l,int r){
	if(!k)return;pd(k);
	pt("%d ",mn[k]);
	ss(ls[k],l,mid);
	ss(rs[k],mid+1,r);
}
void dfs(int x,int fa){
	ll sum=0;
	run(x)if(v!=fa){
		dep[v]=dep[x]+1;
		dfs(v,x);sum+=f[v];gmin(sum,linf);
	}run(x)if(v!=fa){
		add(rt[v],1,n,1,n,sum-f[v]);
		rt[x]=merge(rt[x],rt[v],1,n);
	}
	re(i,0,link[x].size()){
		int j=link[x][i];
		int p=dep[b[j]];
		ll q=c[j]+sum;
		modify(rt[x],1,n,p,q);
	}
	
	//ss(rt[x],1,n);puts("");
	if(x>1)f[x]=min(ask(rt[x],1,n,1,max(dep[x]-1,1)),linf);else f[x]=sum;
}
int main(){
	read(n,m);ll sum=0;
	re(i,1,n){
		int x,y;read(x,y);
		adde(x,y);
	}rep(i,1,m)read(a[i],b[i],c[i]),sum+=c[i];
	rep(i,1,m)link[a[i]].pb(i);
	dep[1]=1;dfs(1,0);
	if(f[1]<=sum)printf("%I64d\n",f[1]);else puts("-1");
}