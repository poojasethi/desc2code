#include<cstdio>
#include<vector>
#include<cstdlib>
#include<cstring>
#define rep(i,n) for(int i=0;i<n;i++)
#define pb push_back
using namespace std;
typedef long long huge_int;
const int N=300005;
const int SIZ=524288;
const huge_int inf=1e15;
const huge_int zero=0;
huge_int MIN(huge_int a,huge_int b){
	return a<b?a:b;
}
struct path{
	int low,hgh;
	huge_int cst;
}pth[N];
int id[N],r[N],par[N],l[N],have[N];
huge_int val[1200000],lazy[1200000],dp[N];
vector<int> g[N],add[N],del[N];
int n,m,clk;
inline int L(int u){
	return (u<<1)|1;
}
inline int R(int u){
	return u+1<<1;
}
inline void push_up(int u){
	val[u]=MIN(val[L(u)],val[R(u)]);
	return;
}
inline void push_down(int u){
	if(lazy[u]){
		int l=L(u);
		int r=R(u);
		lazy[l]+=lazy[u];
		lazy[r]+=lazy[u];
		val[l]+=lazy[u];
		val[r]+=lazy[u];
		lazy[u]=0;
	}
	return;
}
inline void modify(int a,int b,huge_int x,int l=0,int r=SIZ-1,int k=0){
	if(a<=l && r<=b){
		val[k]+=x;
		lazy[k]+=x;
//		printf("modify\t%d %d %I64d %d %d %d %I64d %I64d\n",a,b,x,l,r,k,val[k],lazy[k]);
		return;
	}
	if(a>r || b<l)
		return;
	push_down(k);
	int mid=l+r>>1;
	modify(a,b,x,l,mid,L(k));
	modify(a,b,x,mid+1,r,R(k));
	push_up(k);
	return;
}
inline void change(int u,huge_int x,int l=0,int r=SIZ-1,int k=0){
	if(l==r){
		val[k]=x;
//		printf("change\t%d %I64d %d %d %d %I64d\n",u,x,l,r,k,val[k]);
		return;
	}
	push_down(k);
	int mid=l+r>>1;
	if(mid>=u)
		change(u,x,l,mid,L(k));
	else
		change(u,x,mid+1,r,R(k));
	push_up(k);
	return;
}
inline huge_int query(int a,int b,int l=0,int r=SIZ-1,int k=0){
	if(a<=l && r<=b){
//		printf("query\t%d %d %d %d %d %I64d\n",a,b,l,r,k,val[k]);
		return val[k];
	}
	if(a>r || b<l)
		return inf;
	push_down(k);
	int mid=l+r>>1;
	huge_int ret=MIN(query(a,b,l,mid,L(k)),query(a,b,mid+1,r,R(k)));
	return ret;
}
void init(int u=0,int f=-1){
	par[u]=f;
	dp[u]=inf;
	l[u]=clk;
	rep(i,(int)add[u].size())
		id[add[u][i]]=clk++;
	r[u]=clk-1;
	rep(i,(int)g[u].size()){
		int v=g[u][i];
		if(v!=f){
			init(v,u);
			if(r[v]>r[u])
				r[u]=r[v];
		}
	}
	return;
}
void dfs(int u=0){
	huge_int tot=zero;
	rep(i,(int)g[u].size()){
		int v=g[u][i];
		if(v!=par[u]){
			dfs(v);
			tot+=dp[v];
			have[u]+=have[v];
		}
	}
	have[u]+=(int)add[u].size()-(int)del[u].size();
	if(u && !have[u]){
		puts("-1");
		exit(0);
	}
	if(!u){
		dp[u]=0;
		rep(i,(int)g[u].size())
			dp[u]+=dp[g[u][i]];
		return;
	}
	rep(i,(int)add[u].size()){
		path &e=pth[add[u][i]];
		change(id[add[u][i]],e.cst);
//		printf("%d %I64d\n",add[u][i],e.cst);
	}
	rep(i,(int)del[u].size())
		change(id[del[u][i]],inf);
	if(r[u]>=l[u])
		modify(l[u],r[u],tot);
	rep(i,(int)g[u].size()){
		int v=g[u][i];
		if(v!=par[u] && r[v]>=l[v])
			modify(l[v],r[v],-dp[v]);
	}
	if(r[u]>=l[u])
		dp[u]=query(l[u],r[u]);
//	printf("%d %I64d %d\n",u,dp[u],tot);
	return;
}
int main(){
	fill(val,val+1100000,inf);
	scanf("%d%d",&n,&m);
	rep(i,n-1){
		int x,y;
		scanf("%d%d",&x,&y);
		x--;
		y--;
		g[x].pb(y);
		g[y].pb(x);
	}
	rep(i,m){
		int x,y;
		huge_int c;
		scanf("%d%d%I64d",&x,&y,&c);
		x--;
		y--;
		add[x].pb(i);
		del[y].pb(i);
		pth[i].low=x;
		pth[i].hgh=y;
		pth[i].cst=c;
	}
	init();
//	rep(i,n){
//		printf("%d %d %d:\n",i,l[i],r[i]);
//		rep(j,(int)add[i].size())
//			printf("%d ",add[i][j]);
//		puts("");
//	}
	dfs();
	if(dp[0]==inf)
		puts("-1");
	else
		printf("%I64d\n",dp[0]);
	return 0;
}
			   	  	 	    	 	     	  	  	