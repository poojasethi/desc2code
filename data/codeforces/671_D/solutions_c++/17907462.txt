#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <vector>

using namespace std;

typedef long long ll;

const ll maxn = 3e5 + 1000;
const ll MAXNODE = 4 * maxn + 1000;
const ll INF = 4e14;

ll n, m;
ll tag[MAXNODE], tree[MAXNODE];

void pushDown(ll rt, ll l, ll r) {
    ll lrt = (rt << 1), rrt = lrt + 1, m = (l + r) / 2;
    if(tag[rt] == 0) {
        return;
    }
    ll key = tag[rt];
    tag[rt] = 0;
    tag[lrt] += key;
    tree[lrt] += key;

    tag[rrt] += key;
    tree[rrt] += key;

    tree[lrt] = min(INF, tree[lrt]);
    tag[lrt] = min(INF, tag[lrt]);
    tree[rrt] = min(INF, tree[rrt]);
    tag[rrt] = min(INF, tag[rrt]);
}
void pushUp(ll rt, ll l, ll r) {
    ll lrt = (rt << 1), rrt = lrt + 1, m = (l + r) / 2;
    tree[rt] = min(tree[lrt], tree[rrt]);
}

void update(ll pos, ll val, ll rt, ll l, ll r) {
    if(l == r) {
        tag[rt] = 0;
        tree[rt] = val;
        return;
    }
    pushDown(rt, l, r);
    ll lrt = (rt << 1), rrt = lrt + 1, m = (l + r) / 2;
    if(pos <= m) {
        update(pos, val, lrt, l, m);
    } else if(pos >= m + 1) {
        update(pos, val, rrt, m + 1, r);
    }
    pushUp(rt, l, r);
}

void update(ll L, ll R, ll val, ll rt, ll l, ll r) {
    if(L <= l && R >= r) {
        tag[rt] += val;
        tree[rt] += val;
        tag[rt] = min(INF, tag[rt]);
        tree[rt] = min(INF, tree[rt]);
        return;
    }
    pushDown(rt, l, r);
    ll lrt = (rt << 1), rrt = lrt + 1, m = (l + r) / 2;
    if(L <= m) {
        update(L, R, val, lrt, l, m);
    }
    if(R >= m + 1) {
        update(L, R, val, rrt, m + 1, r);
    }
    pushUp(rt, l, r);
}
ll query(ll L, ll R, ll rt, ll l, ll r) {
    if(L <= l && R >= r) {
        return tree[rt];
    } else {
        pushDown(rt, l, r);
        ll lrt = (rt << 1), rrt = lrt + 1, m = (l + r) / 2;
        ll ans = INF;
        if(L <= m) {
            ans = min(ans, query(L, R, lrt, l, m));
        }
        if(R >= m + 1) {
            ans = min(ans, query(L, R, rrt, m + 1, r));
        }
        return ans;
    }
}

ll a[maxn], b[maxn], no[maxn], c[maxn];
ll st[maxn], en[maxn];
vector<ll> G[maxn];
vector<ll> add[maxn], del[maxn];
ll f[maxn];
ll tot;
void dfs(ll u, ll fa) {
    st[u] = tot + 1;
    for(ll i = 0; i < add[u].size(); i++) {
        tot++;
        no[add[u][i]] = tot;
    }
    for(ll i = 0; i < G[u].size(); i++) {
        ll v = G[u][i];
        if(fa != v) {
            dfs(v, u);
        }
    }
    en[u] = tot;
}
void calcu(ll u, ll fa) {
    ll sum = 0;
    for(ll i = 0; i < G[u].size(); i++) {
        ll v = G[u][i];
        if(v != fa) {
            calcu(v, u);
            if(sum != 2 * INF) {
                sum += f[v];
                sum = min(sum, 2 * INF);
            }
        }
    }
    for(ll i = 0; i < add[u].size(); i++) {
        ll id = add[u][i];
        update(no[id], min(INF, c[id] + sum), 1, 1, m);
    }
    for(ll i = 0; i < del[u].size(); i++) {
        ll id = del[u][i];
        update(no[id], INF, 1, 1, m);
    }
    for(ll i = 0; i < G[u].size(); i++) {
        ll v = G[u][i];
        if(v != fa) {
            if(st[v] <= en[v])
                update(st[v], en[v], sum - f[v], 1, 1, m);
        }
    }
    if(st[u] <= en[u])
        f[u] = query(st[u], en[u], 1, 1, m);
    else {
        f[u] = INF;
    }
    f[u] = min(f[u], INF);
}
void solve() {
    tot = 0;
    dfs(1, 0);
    memset(tag, 0, sizeof(tag));
    memset(tree, 0, sizeof(tree));
    calcu(1, 0);
    ll ans = 0;
    for(ll i = 0; i < G[1].size(); i++) {
        ll v = G[1][i];
        ans += f[v];
    }
    if(ans >= INF) {
        printf("-1\n");
    } else {
        printf("%I64d\n", ans);
    }
}

int main() {
    //freopen("D.txt", "r", stdin);
    while(scanf("%I64d%I64d", &n, &m) != EOF) {
        for(ll i = 1; i <= n; i++) {
            G[i].clear();
            add[i].clear();
            del[i].clear();
        }
        for(ll i = 1; i <= n - 1; i++) {
            ll a, b;
            scanf("%I64d%I64d", &a, &b);
            G[a].push_back(b);
            G[b].push_back(a);
        }
        for(ll i = 1; i <= m; i++) {
            scanf("%I64d%I64d%I64d", &a[i], &b[i], &c[i]);
            add[a[i]].push_back(i);
            del[b[i]].push_back(i);
        }
        solve();
    }
    return 0;
}
