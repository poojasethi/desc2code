#include <bits/stdc++.h>

typedef long long Int64;

const Int64 N = 3e5 + 1000;
const Int64 INF = (1LL << 60);

Int64 n, m;
std::vector<Int64> edge[N];
Int64 cost[N];
std::vector<Int64> ep[N][2];
std::pair<Int64, Int64> range[N];
Int64 rank[N];
Int64 f[N];

struct SegmentTree {
	struct Node {
		Int64 minValue;
		Int64 delta;
	};
	Node tree[N << 2];
	
	void pushTag(Int64 root, Int64 left, Int64 right) {
		tree[root].minValue += tree[root].delta;
		if (left != right) {
			tree[root << 1].delta += tree[root].delta;
			tree[root << 1 | 1].delta += tree[root].delta;
		}
		tree[root].delta = 0;
	}
	
	void add(Int64 root, Int64 left, Int64 right, Int64 ql, Int64 qr, Int64 delta) {
		if (left > right) {
			return ;
		}
		pushTag(root, left, right);
		if (left == ql && right == qr) {
			tree[root].delta += delta;
			pushTag(root, left, right);
			return ;
		}
		Int64 mid = (left + right) >> 1;
		if (qr <= mid) {
			add(root << 1, left, mid, ql, qr, delta);
		} else if (ql > mid) {
			add(root << 1 | 1, mid + 1, right, ql, qr, delta);
		} else {
			add(root << 1, left, mid, ql, mid, delta);
			add(root << 1 | 1, mid + 1, right, mid + 1, qr, delta);
		}
		pushTag(root << 1, left, mid);
		pushTag(root << 1 | 1, mid + 1, right);
		tree[root].minValue = std::min(tree[root << 1].minValue, tree[root << 1 | 1].minValue);
	}
	
	Int64 getMin(Int64 root, Int64 left, Int64 right, Int64 ql, Int64 qr) {
		if (left > right) {
			return INF;
		}
		pushTag(root, left, right);
		if (left == ql && right == qr) {
			return tree[root].minValue;
		}
		Int64 mid = (left + right) >> 1;
		if (qr <= mid) {
			return getMin(root << 1, left, mid, ql, qr);
		} else if (ql > mid) {
			return getMin(root << 1 | 1, mid + 1, right, ql, qr);
		} else {
			Int64 result = getMin(root << 1, left, mid, ql, mid);
			result = std::min(result, getMin(root << 1 | 1, mid + 1, right, mid + 1, qr));
			return result;
		}
	}
};
SegmentTree st;

int uu[N], vv[N];

void init() {
	std::cin >> n >> m;
	for (Int64 i = 1; i <= n - 1; i ++) {
		Int64 u, v;
		scanf("%I64d%I64d", &u, &v);
		uu[i] = u;
		vv[i] = v;
		edge[u].push_back(v);
		edge[v].push_back(u);
	}
	for (Int64 i = 1; i <= m; i ++) {
		Int64 u, v;
		scanf("%I64d%I64d%I64d", &u, &v, &cost[i]);
		ep[u][0].push_back(i);
		ep[v][1].push_back(i);		
	}
}

void dfs(Int64 u, Int64 father) {
	static Int64 t = 0;
	
	range[u].first = t + 1;
	for (Int64 i = 0; i < (Int64)ep[u][0].size(); i ++) {
		rank[ep[u][0][i]] = ++t;
	}
	for (Int64 i = 0; i < (Int64)edge[u].size(); i ++) {
		Int64 v = edge[u][i];
		if (v == father) {
			continue;
		}
		dfs(v, u);
	}
	range[u].second = t;
}

void solve(Int64 u, Int64 father) {
	Int64 tmp = 0;
	for (Int64 i = 0; i < (Int64)edge[u].size(); i ++) {
		Int64 v = edge[u][i];
		if (v == father) {
			continue;
		}
		solve(v, u);
		tmp = std::min(tmp + f[v], INF);
	}
	if (u == 1) {
		f[u] = tmp;
		return ;
	}
	
	for (Int64 i = 0; i < (Int64)ep[u][0].size(); i ++) {
		Int64 t = ep[u][0][i];
		st.add(1, 1, m, rank[t], rank[t], tmp + cost[t]);
	}
	for (Int64 i = 0; i < (Int64)ep[u][1].size(); i ++) {
		Int64 t = ep[u][1][i];
		Int64 cur = st.getMin(1, 1, m, rank[t], rank[t]);
		st.add(1, 1, m, rank[t], rank[t], INF - cur);
	}
	for (Int64 i = 0; i < (Int64)edge[u].size(); i ++) {
		Int64 v = edge[u][i];
		if (v == father) {
			continue;
		}
		st.add(1, 1, m, range[v].first, range[v].second, tmp - f[v]);
	}
	
	if (range[u].first <= range[u].second) {
		f[u] = st.getMin(1, 1, m, range[u].first, range[u].second);
	} else {
		f[u] = INF;
		printf("-1\n");
		exit(0);
	}
}

void work() {
	dfs(1, 0);
	solve(1, 0);
	
	if (f[1] < INF) {
		std::cout << f[1] << std::endl;
	} else {
		std::cout << -1 << std::endl;
	}
}

int main() {
	//freopen("d.in", "r", stdin);
	
	init();
	work();
	
	return 0;
}