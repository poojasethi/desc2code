#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#include<vector>
#include<queue>
#include<cmath>
#define ll long long
#define ld long double
using namespace std;
const ll oo= 1e15;
const int maxn= 7e5,maxm= 3e6;
struct worker{
	int u,v,c;
}W[maxn];
struct node{
	ll v;
	int i;
	bool operator <(const node &a)const{
		return v>a.v;
	}
};
vector<int> g[maxn];
vector<int> U[maxn];
vector<int> V[maxn];
priority_queue<node> Q[maxn];
ll a[maxm],Z[maxm];
ll dp[maxn],sum[maxn];
int X[maxn][2],Y[maxn],b[maxn];
ll ans;
int n,m,i,j,x,y,z,tot,top,L,R,bl;
void dfs(int o,int fa){
	X[o][0]= ++tot;
	Y[tot]= o;
	int len= g[o].size(),i;
	for (i= 0;i<len;i++){
		int v= g[o][i];
		if (v==fa) continue;
		dfs(v,o);
	}
	X[o][1]= ++tot;
	Y[tot]= o;
}
void update(int o){
	a[o]= min(a[2*o]+Z[2*o],a[2*o+1]+Z[2*o+1]);
	a[o]= min(a[o],oo);
}
void build(int o,int l,int r){
	if (l+1==r){
		a[o]= oo;
		return;
	}
	int m= (l+r)>>1;
	build(2*o,l,m);
	build(2*o+1,m,r);
	update(o);
}
void pushdown(int o){
	Z[2*o]+= Z[o];
	Z[2*o+1]+= Z[o];
	Z[o]= 0;
}
void change(int o,int l,int r,int v){
	if (l+1==r){
		a[o]= oo;
		while (!Q[l].empty()&&b[Q[l].top().i])
			Q[l].pop();
		if (!Q[l].empty())
			a[o]= Q[l].top().v;
		return;
	}pushdown(o);
	int m= (l+r)>>1;
	if (v<m) change(2*o,l,m,v);
	else change(2*o+1,m,r,v);
	update(o);
}
void find(int o,int l,int r,int x,int y,ll &re){
	if (x<=l&&r<=y){
		re= min(re,a[o]+Z[o]);
		return;
	}
	pushdown(o);
	int m= (l+r)>>1;
	if (x<m) find(2*o,l,m,x,y,re);
	if (m<y) find(2*o+1,m,r,x,y,re);
	update(o);
}
void put(int o,int l,int r,int x,int y,ll v){
	if (x<=l&&r<=y){
		Z[o]+= v;
		return;
	}
	pushdown(o);
	int m= (l+r)>>1;
	if (x<m) put(2*o,l,m,x,y,v);
	if (m<y) put(2*o+1,m,r,x,y,v);
	update(o);
}
void get(int o,int fa){
	int len= g[o].size(),i;
	for (i= 0;i<len;i++){
		int v= g[o][i];
		if (v==fa) continue;
		get(v,o);
		if (!bl) return;
		sum[o]+= dp[v];
	}
	while ((len= U[o].size())){
		i= U[o][len-1];
		U[o].pop_back();
		Q[X[o][0]].push((node){W[i].c+sum[o],i});
	}
	change(1,L,R,X[o][0]);	
	if (o!=1)
		while ((len= V[o].size())){
			i= V[o][len-1];
			V[o].pop_back();
			b[i]= 1;
			change(1,L,R,X[W[i].u][0]);
		}
	len= g[o].size();
	for (i= 0;i<len;i++){
		int v= g[o][i];
		if (v==fa) continue;
		put(1,L,R,X[v][0],X[v][1]+1,sum[o]-dp[v]);
	}	
	dp[o]= oo;	
	find(1,L,R,X[o][0],X[o][1]+1,dp[o]);
	if (dp[o]==oo){
		bl= 0;
		return;
	}
}
int main()
{
#ifndef ONLINE_JUDGE	
	freopen("1.in","r",stdin);
	freopen("1.out","w",stdout);
#endif
	scanf("%d%d",&n, &m);
	for (i= 1;i<n;i++){
		scanf("%d%d",&x, &y);
		g[x].push_back(y);
		g[y].push_back(x);
	}
	for (i= 1;i<=m;i++){
		scanf("%d%d%d",&x, &y, &z);
		W[i]= (worker){x,y,z};
		U[x].push_back(i);
		V[y].push_back(i);
	}
	if (n==1){
		printf("0");
		return 0;
	}
	ans= oo;
	dfs(1,0);
	L= 1;R= tot+1;
	build(1,L,R);
	bl= 1;
	get(1,0);
	ans= dp[1];
	if (!bl) ans= -1;
	printf("%I64d",ans);
	return 0;
}
