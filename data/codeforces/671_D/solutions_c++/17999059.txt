#include <cmath>
#include <cstdio>
#include <vector>
#include <cstring>
#include <algorithm>

using namespace std;

#define pb push_back
#define mp make_pair
#define x first
#define y second

typedef vector<int> vi;
typedef pair<int,int> pii;
typedef vector<pii> vpii;
typedef long long ll;

const int N=300010;
int cnt;
int dep[N],root[N];
bool v[N];
ll dp[N];
vi e[N];
vpii b[N];

struct node
{
	ll delta,data;
	int lch,rch,dep,lim;
}h[N];

void update(int k,ll d)
{
	h[k].delta+=d;h[k].data+=d;
}

void pushdown(int k)
{
	if (h[k].delta)
	{
		update(h[k].lch,h[k].delta);
		update(h[k].rch,h[k].delta);
		h[k].delta=0;
	}
}

int merge(int x,int y)
{
	if (!x) return y;
	if (!y) return x;
	pushdown(x);pushdown(y);
	if (h[x].data>h[y].data) swap(x,y);
	h[x].rch=merge(h[x].rch,y);
	if (h[h[x].rch].dep>h[h[x].lch].dep) swap(h[x].lch,h[x].rch);
	h[x].dep=h[h[x].rch].dep+1;
	return x;
}

bool dfs(int k)
{
	v[k]=1;ll s=0;
	for (vi::iterator p=e[k].begin();p!=e[k].end();p++)
		if (!v[*p])
		{
			dep[*p]=dep[k]+1;
			if (!dfs(*p)) return 0;
			s+=dp[*p];
		}
	if (k==1) {dp[1]=s;return 1;}
	root[k]=0;
	for (vpii::iterator p=b[k].begin();p!=b[k].end();p++)
	{
		cnt++;
		h[cnt].lch=h[cnt].rch=h[cnt].dep=0;
		h[cnt].delta=0;h[cnt].data=s+p->y;h[cnt].lim=p->x;
		root[k]=merge(root[k],cnt);
	}
	for (vi::iterator p=e[k].begin();p!=e[k].end();p++)
		if (!v[*p])
		{
			update(root[*p],s-dp[*p]);
			root[k]=merge(root[k],root[*p]);
		}
	while (root[k]&&dep[h[root[k]].lim]>=dep[k])
	{
		pushdown(root[k]);
		root[k]=merge(h[root[k]].lch,h[root[k]].rch);
	}
	if (!root[k]) return 0;
	dp[k]=h[root[k]].data;
	v[k]=0;return 1;
}

int main()
{
	#ifndef ONLINE_JUDGE
		freopen("input.txt","r",stdin);
		freopen("output.txt","w",stdout);
	#endif
	int n,m;scanf("%d%d",&n,&m);
	for (int i=1;i<n;i++)
	{
		int x,y;scanf("%d%d",&x,&y);
		e[x].pb(y);e[y].pb(x);
	}
	for (int i=1;i<=m;i++)
	{
		int x,y,c;scanf("%d%d%d",&x,&y,&c);
		b[x].pb(mp(y,c));
	}
	h[0].dep=-1;dep[1]=0;
	if (!dfs(1)) puts("-1"); else printf("%I64d\n",dp[1]);
	return 0;
}
