#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
#include <vector>

#define MAXN 610000
#define lson(o) ch[o][0]
#define rson(o) ch[o][1]

using namespace std;

typedef long long int LL;

struct Heap
{
    int ch[MAXN][2],high[MAXN],anc[MAXN],nCount;
    LL val[MAXN],lazytag[MAXN];
    
    void add(int o,LL addv)
    {
        val[o]+=addv;
        lazytag[o]+=addv;
    }
    
    void pushdown(int o)
    {
        if(lazytag[o])
        {
            if(lson(o))
                add(lson(o),lazytag[o]);
            if(rson(o))
                add(rson(o),lazytag[o]);
            lazytag[o]=0;
        }
    }
    
    int newnode(LL v,int h)
    {
        nCount++;
        val[nCount]=v,high[nCount]=1,anc[nCount]=h;
        return nCount;
    }
    
    int Merge(int a,int b)
    {
        if(!a) return b;
        if(!b) return a;
        pushdown(a),pushdown(b);
        if(val[a]>val[b]) swap(a,b);
        rson(a)=Merge(rson(a),b);
        if(high[lson(a)]<high[rson(a)]) swap(lson(a),rson(a));
        high[a]=max(high[a],high[rson(a)]+1);
        return a;
    }
    
    int pop(int x)
    {
        pushdown(x);
        int tmp=Merge(lson(x),rson(x));
        lson(x)=rson(x)=0;
        return tmp;
    }
}heap;

int root[MAXN];

struct edge
{
    int u,v,next;
}edges[MAXN*2];

int head[MAXN],nCount=0;

void AddEdge(int U,int V)
{
    edges[++nCount].u=U;
    edges[nCount].v=V;
    edges[nCount].next=head[U];
    head[U]=nCount;
}

int depth[MAXN];

vector<pair<int,LL> >vec[MAXN];

void DFS(int u,int fa)
{
    LL sum=0;
    for(int p=head[u];p!=-1;p=edges[p].next)
    {
        int v=edges[p].v;
        if(v==fa) continue;
        DFS(v,u);
        while(root[v]&&depth[heap.anc[root[v]]]>depth[u]) root[v]=heap.pop(root[v]);
        sum+=heap.val[root[v]];
    }
    for(int i=0;i<vec[u].size();i++)
    {
        int v=vec[u][i].first;
        LL w=vec[u][i].second;
        int o=heap.newnode(sum+w,v);
        root[u]=heap.Merge(root[u],o);
    }
    for(int p=head[u];p!=-1;p=edges[p].next)
    {
        int v=edges[p].v;
        if(v==fa) continue;
        LL tmp=sum-heap.val[root[v]];
        heap.add(root[v],tmp);
        root[u]=heap.Merge(root[u],root[v]);
    }
}

int low[MAXN];
bool can=true;

void check(int u,int fa)
{
    bool flag=true;
    low[u]=depth[u]+1;
    for(int p=head[u];p!=-1;p=edges[p].next)
    {
        int v=edges[p].v;
        if(v==fa) continue;
        flag=false;
        depth[v]=depth[u]+1;
        check(v,u);
        low[u]=min(low[u],low[v]);
    }
    if(low[u]>depth[u]&&!flag)
        can=false;
    for(int i=0;i<vec[u].size();i++)
        low[u]=min(low[u],depth[vec[u][i].first]);
    if(low[u]>depth[u])
        can=false;
}

int n,m;

int main()
{
    memset(head,-1,sizeof(head));
    scanf("%d%d",&n,&m);
    for(int i=1;i<n;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        AddEdge(u,v);
        AddEdge(v,u);
    }
    for(int i=1;i<=m;i++)
    {
        int u,v;
        LL w;
        scanf("%d%d%I64d",&u,&v,&w);
        vec[u].push_back(make_pair(v,w));
    }
    if(n==1)
    {
        printf("0\n");
        return 0;
    }
    depth[1]=1;
    check(1,-1);
    if(!can)
    {
        printf("-1\n");
        return 0;
    }
    DFS(1,-1);
    while(root[1]&&depth[heap.anc[root[1]]]>depth[1]) root[1]=heap.pop(root[1]);
    printf("%I64d\n",heap.val[root[1]]);
    return 0;
}