#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <iostream>
#include <cmath>
#include <set>

using namespace std;

int nar;
int n, m;
int first[300100];
int next_e[600100];
int dest[600100];
set<pair<long long, int> > sets[300001];
long long ac[300100];
long long res[300100];
bool mark[300100];
int dfs_number[300100];

void add(int a, int b) {
	next_e[nar] = first[a];
	dest[nar] = b;
	first[a] = nar;
	nar++;
}

bool read() {
	scanf("%d%d", &n, &m);

	nar = 0;
	for (int i = 1; i <= n; i++) {
		first[i] = -1;
		ac[i] = 0;
		sets[i].clear();
		res[i] = -1;
		mark[i] = false;
		dfs_number[i] = -1;
	}

	for (int i = 1; i < n; i++) {
		int x, y;
		scanf("%d%d", &x, &y);
		add(x, y);
		add(y, x);
	}
	for (int i = 1; i <= m; i++) {
		int u, v, c;
		scanf("%d%d%d", &u, &v, &c);
		if (u != v) {
			sets[u].insert(pair<long long,int>(c, v));
		}
	}
	return true;
}

bool impossible;
int cc;
long long go(int node, int parent) {
	long long sum = 0;

	dfs_number[node] = cc++;

	int ar = first[node];
	int largest = -1;
	while (ar != -1) {
		int child = dest[ar];
		if (child != parent) {
			sum += go(child, node);
			if (largest == -1 || sets[largest].size() < sets[child].size()) {
				largest = child;
			}
		}
		ar = next_e[ar]; 
	}

	mark[node] = true;

	//printf("sum for %d = %lld\n", node, sum);
	if (largest != -1) {
		if (sets[node].size() >= sets[largest].size()) {
			largest = node;
			ac[node] = sum;
		} else {
			ac[node] = ac[largest] + sum - res[largest];	
		}

		ar = first[node];
		while (ar != -1) {
			int child = dest[ar];
			if (child != parent && child != largest) {
				for (set<pair<long long, int> >::iterator it = sets[child].begin(); it != sets[child].end(); it++) {
					if (mark[it->second]) continue;
					pair<long long, int> p = pair<long long, int>(it->first, it->second);
					p.first = p.first + ac[child] - ac[node] + sum - res[child];
					
					bool r = false;
					set<pair<long long, int> >::iterator it2 = sets[largest].insert(p).first;
					if (it2 != sets[largest].begin()) {
						set<pair<long long, int> >::iterator it3 = it2;
						it3--;
						if (dfs_number[it3->second] < dfs_number[it2->second]) {
							sets[largest].erase(it2);
							r = true;
						}
					}
					if (!r) {
						set<pair<long long, int> >::iterator it3 = it2;
						it3++;
						while (it3 != sets[largest].end() && dfs_number[it3->second] >= dfs_number[it2->second]) {
							set<pair<long long, int> >::iterator it4 = it3;
							it3++;
							sets[largest].erase(it4);
						}
					}

				}
				sets[child].clear();
			}
			ar = next_e[ar]; 
		}
		if (node != largest) {
			for (set<pair<long long, int> >::iterator it = sets[node].begin(); it != sets[node].end(); it++) {
				pair<long long, int> p = pair<long long, int>(it->first, it->second);
				p.first = p.first - ac[node] + sum;
				

				bool r = false;
				set<pair<long long, int> >::iterator it2 = sets[largest].insert(p).first;
				if (it2 != sets[largest].begin()) {
					set<pair<long long, int> >::iterator it3 = it2;
					it3--;
					if (dfs_number[it3->second] < dfs_number[it2->second]) {
						sets[largest].erase(it2);
						r = true;
					}
				}
				if (!r) {
					set<pair<long long, int> >::iterator it3 = it2;
					it3++;
					while (it3 != sets[largest].end() && dfs_number[it3->second] >= dfs_number[it2->second]) {
						set<pair<long long, int> >::iterator it4 = it3;
						it3++;
						sets[largest].erase(it4);
					}
				}
			}
			sets[node].clear();
		}
		sets[node] = sets[largest];
	}

	//printf("ac for %d = %lld\n", node, ac[node]);

	while (sets[node].size() > 0 && mark[sets[node].begin()->second] == true) {
		sets[node].erase(sets[node].begin());
	}

	if (node == 1) {
		res[node] = sum;
	} else if (sets[node].size() == 0) {
		impossible = true;
	} else {
		res[node] = sets[node].begin()->first + ac[node];
	}

	//printf("res[%d] = %lld\n", node, res[node]);
	
	return res[node];
}

void process() {
	impossible = false;
	cc = 0;
	long long res = go(1, -1);
	cout << (impossible ? -1 : res) << endl;
}

int main() {
	
	read();
	process();

	return 0;
}