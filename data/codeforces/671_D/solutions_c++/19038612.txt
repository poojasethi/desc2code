#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
#include <vector>

#define MAXN 610000
#define lson(o) ch[o][0]
#define rson(o) ch[o][1]

using namespace std;

typedef long long int LL;

struct Heap
{
	int ch[MAXN][2],high[MAXN],anc[MAXN],nCount;
	LL val[MAXN],addtag[MAXN];
	
	void add(int o,LL addv)
	{
		val[o]+=addv;
		addtag[o]+=addv;
	}
	
	void pushdown(int o)
	{
		if(addtag[o])
		{
			add(lson(o),addtag[o]);
			add(rson(o),addtag[o]);
			addtag[o]=0;
		}
	}
	
	int newnode(LL v,int fa)
	{
		nCount++;
		val[nCount]=v;
		anc[nCount]=fa;
		high[nCount]=1;
		return nCount;
	}
	
	int Merge(int a,int b)
	{
		if(!a||!b) return a+b;
		pushdown(a),pushdown(b);
		if(val[a]>val[b]) swap(a,b);
		rson(a)=Merge(rson(a),b);
		high[a]=max(high[a],high[rson(a)]+1);
		if(high[lson(a)]<high[rson(a)]) swap(lson(a),rson(a));
		return a;
	}
	
	int pop(int o)
	{
		pushdown(o);
		int tmp=Merge(lson(o),rson(o));
		lson(o)=rson(o)=0;
		return tmp;
	}
}heap;

int root[MAXN];

struct edge
{
	int u,v,next;
}edges[MAXN*2];

int head[MAXN],nCount=0;

void AddEdge(int U,int V)
{
	edges[++nCount].u=U;
	edges[nCount].v=V;
	edges[nCount].next=head[U];
	head[U]=nCount;
}

int depth[MAXN];
vector<pair<int,LL> >vec[MAXN];
LL nowv[MAXN];

void DFS(int u,int fa)
{
	LL sum=0;
	for(int p=head[u];p!=-1;p=edges[p].next)
	{
		int v=edges[p].v;
		if(v==fa) continue;
		DFS(v,u);
		while(root[v]&&depth[heap.anc[root[v]]]>depth[u])
			root[v]=heap.pop(root[v]);
		//printf("dbg2: %d %d %I64d\n",u,v,heap.val[root[v]]);
		sum+=heap.val[root[v]];
		nowv[v]=heap.val[root[v]];
	}
	//printf("dbg: %d %I64d\n",u,sum);
	for(int i=0;i<vec[u].size();i++)
	{
		int newo=heap.newnode(vec[u][i].second+sum,vec[u][i].first);
		//printf("dbg3: %d %I64d\n",newo,heap.val[newo]);
		root[u]=heap.Merge(newo,root[u]);
	}
	for(int p=head[u];p!=-1;p=edges[p].next)
	{
		int v=edges[p].v;
		if(v==fa) continue;
		heap.add(root[v],sum-nowv[v]);
		root[u]=heap.Merge(root[u],root[v]);
	}
}

bool flag=true;
int low[MAXN];

void check(int u,int fa)
{
	bool mark=true;
	low[u]=0x3f3f3f3f;
	for(int p=head[u];p!=-1;p=edges[p].next)
	{
		int v=edges[p].v;
		if(v==fa) continue;
		mark=false;
		depth[v]=depth[u]+1;
		check(v,u);
		low[u]=min(low[u],low[v]);
	}
	if(mark) low[u]=depth[u];
	if(low[u]>depth[u])
		flag=false;
	for(int i=0;i<vec[u].size();i++)
		low[u]=min(low[u],depth[vec[u][i].first]);
	if(low[u]>=depth[u]&&u!=1)
		flag=false;
}

int main()
{
	memset(head,-1,sizeof(head));
	int n,m;
	scanf("%d%d",&n,&m);
	if(n==1&&m==1)
	{
		printf("0\n");
		return 0;
	}
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		AddEdge(u,v);
		AddEdge(v,u);
	}
	for(int i=1;i<=m;i++)
	{
		int u,v;
		LL w;
		scanf("%d%d%I64d",&u,&v,&w);
		vec[u].push_back(make_pair(v,w));
	}
	depth[1]=1;
	check(1,-1);
	//for(int i=1;i<=n;i++)
	//	printf("%d ",low[i]);
	//printf("\n");
	if(!flag)
	{
		printf("-1\n");
		return 0;
	}
	DFS(1,-1);
	while(root[1]&&depth[heap.anc[root[1]]]>depth[1])
		root[1]=heap.pop(root[1]);
	printf("%I64d\n",heap.val[root[1]]);
	return 0;
}