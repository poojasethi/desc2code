#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>

#define MAXN 610000
#define lson(o) ch[o][0]
#define rson(o) ch[o][1]

using namespace std;

typedef long long int LL;

struct Heap
{
    int ch[MAXN][2],high[MAXN],anc[MAXN],nCount;
    LL val[MAXN],addtag[MAXN];
    
    void add(int o,LL addv)
    {
        val[o]+=addv;
        addtag[o]+=addv;
    }
    
    void pushdown(int o)
    {
        if(addtag[o])
        {
            if(lson(o))
                add(lson(o),addtag[o]);
            if(rson(o))
                add(rson(o),addtag[o]);
            addtag[o]=0;
        }
    }
    
    int newnode(LL v,int fa)
    {
        nCount++;
        val[nCount]=v;
        anc[nCount]=fa;
        high[nCount]=1;
        return nCount;
    }
    
    int Merge(int a,int b)
    {
        //printf("ddd %d %d\n",a,b);
        if(!a||!b) return a+b;
        pushdown(a),pushdown(b);
        if(val[a]>val[b])
            swap(a,b);
        rson(a)=Merge(rson(a),b);
        if(high[lson(a)]<high[rson(a)])
            swap(lson(a),rson(a));
        high[a]=max(high[a],high[rson(a)]+1);
        return a;
    }
    
    int pop(int a)
    {
        pushdown(a);
        return Merge(lson(a),rson(a));
    }
}heap;

struct edge
{
    int u,v,next;
    LL w;
}edges[MAXN*2],edges2[MAXN*2];

int head[MAXN],nCount=0;

void AddEdge(int U,int V)
{
    edges[++nCount].u=U;
    edges[nCount].v=V;
    edges[nCount].next=head[U];
    head[U]=nCount;
}

int head2[MAXN],nCount2=0;

void AddEdge2(int U,int V,LL W)
{
    edges2[++nCount2].u=U;
    edges2[nCount2].v=V;
    edges2[nCount2].w=W;
    edges2[nCount2].next=head2[U];
    head2[U]=nCount2;
}

int root[MAXN];
int depth[MAXN];

void DFS(int u,int fa)
{
    LL sum=0;
    for(int p=head[u];p!=-1;p=edges[p].next)
    {
        int v=edges[p].v;
        if(v==fa) continue;
        DFS(v,u);
        while(depth[heap.anc[root[v]]]>depth[u]) root[v]=heap.pop(root[v]);
        sum+=heap.val[root[v]];
    }
    for(int p=head[u];p!=-1;p=edges[p].next)
    {
        int v=edges[p].v;
        if(v==fa) continue;
        LL tmp=sum-heap.val[root[v]];
        heap.add(root[v],tmp);
        root[u]=heap.Merge(root[u],root[v]);
    }
    for(int p=head2[u];p!=-1;p=edges2[p].next)
    {
        int v=edges2[p].v;
        int o=heap.newnode(sum+edges2[p].w,v);
        root[u]=heap.Merge(root[u],o);
    }
    /*printf("=====DEBUG=====\n");
    for(int i=1;i<=heap.nCount;i++)
        printf("%d %d\n",heap.ch[i][0],heap.ch[i][1]);
    printf("===========\n");
    printf("\n");*/
}

int low[MAXN];

void check(int u,int fa)
{
    low[u]=depth[u]+1;
    bool flag=true;
    for(int p=head[u];p!=-1;p=edges[p].next)
    {
        int v=edges[p].v;
        if(v==fa) continue;
        flag=false;
        depth[v]=depth[u]+1;
        check(v,u);
        low[u]=min(low[u],low[v]);
    }
    if(low[u]>depth[u]&&!flag)
    {
        printf("-1\n");
        exit(0);
    }
    for(int p=head2[u];p!=-1;p=edges2[p].next)
    {
        int v=edges2[p].v;
        low[u]=min(low[u],depth[v]);
    }
    if(low[u]>depth[u])
    {
        printf("-1\n");
        exit(0);
    }
}

int main()
{
    memset(head,-1,sizeof(head));
    memset(head2,-1,sizeof(head2));
    int n,m;
    scanf("%d%d",&n,&m);
    if(n==1)
    {
        printf("0\n");
        return 0;
    }
    for(int i=1;i<n;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        if(u==v) continue;
        AddEdge(u,v);
        AddEdge(v,u);
    }
    for(int i=1;i<=m;i++)
    {
        int u,v,w;
        scanf("%d%d%d",&u,&v,&w);
        AddEdge2(u,v,w);
    }
    depth[1]=1;
    check(1,-1);
    DFS(1,-1);
    while(depth[heap.anc[root[1]]]>depth[1]) root[1]=heap.pop(root[1]);
    printf("%I64d\n",heap.val[root[1]]);
    return 0;
}