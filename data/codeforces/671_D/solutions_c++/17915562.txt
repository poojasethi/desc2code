#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
#define maxn 300005
#define ll long long
#define oo (ll)1e15
using namespace std;

int head[maxn],headi[maxn],heado[maxn],t[maxn * 4],v[maxn * 4],next[maxn * 4],sum;

int n,m;

ll f[maxn];

int fr[maxn],to[maxn],tim,id[maxn];

struct note{
	ll add,mi;
}tree[maxn * 4];

inline int Read(){
	int ret=0,ff=1;
	char c=getchar();
	while (c<'0' || c>'9') {
		if (c=='-') ff=-1;
		c=getchar();
	}
	while (c>='0' && c<='9') {
		ret=ret * 10 + c-'0';
		c=getchar();
	}
	return ret * ff;
}

void insert(int x,int y){
	t[++sum]=y;
	next[sum]=head[x];
	head[x]=sum;
}

void insert_i(int x,int y,int z){
	t[++sum]=y;
	v[sum]=z;
	next[sum]=headi[x];
	headi[x]=sum;
}

void insert_o(int x,int y,int z){
	t[++sum]=y;
	v[sum]=z;
	next[sum]=heado[x];
	heado[x]=sum;
}

void dfs(int x,int father){
	fr[x]=tim+1;
	for(int tmp=headi[x];tmp;tmp=next[tmp]) 
		id[t[tmp]]=++tim;
	for(int tmp=head[x];tmp;tmp=next[tmp]) {
		if (t[tmp]==father) continue;
		dfs(t[tmp],x);
	}
	to[x]=tim;
}

void build(int rt,int l,int r){
	if (l==r) {
		tree[rt].mi=oo;
		return;
	}
	int mid=(l+r) >> 1;
	build(rt << 1,l,mid);
	build(rt << 1 | 1,mid+1,r);
	tree[rt].mi=oo;
}

void change(int rt,int l,int r,int x,ll y){
	if (l==r) {
		tree[rt].mi=y+tree[rt].add;
		return;
	}
	int mid=(l+r) >> 1;
	if (x<=mid) change(rt << 1,l,mid,x,y);
	else change(rt << 1 | 1,mid+1,r,x,y);
	tree[rt].mi=min(oo,min(tree[rt << 1].mi,tree[rt << 1 | 1].mi)+tree[rt].add);
}

void add(int rt,int l,int r,int x,int y,ll z){
	if (l>y || r<x) return;
	if (l==x && r==y) {
		tree[rt].add+=z;
		tree[rt].add=min(tree[rt].add,oo);
		tree[rt].mi+=z;
		tree[rt].mi=min(tree[rt].mi,oo);
		return;
	}
	int mid=(l+r) >> 1;
	if (y<=mid) add(rt << 1,l,mid,x,y,z);
	else if (x>mid) add(rt << 1 | 1,mid+1,r,x,y,z);
	else {
		add(rt << 1,l,mid,x,mid,z);
		add(rt << 1 | 1,mid+1,r,mid+1,y,z);
	}
	tree[rt].mi=min(oo,min(tree[rt << 1].mi,tree[rt << 1 | 1].mi)+tree[rt].add);
}

ll askmi(int rt,int l,int r,int x,int y){
	if (l>y || r<x) return oo;
	if (l==x && r==y) return tree[rt].mi;
	int mid=(l+r) >> 1;
	if (y<=mid) return min(oo,askmi(rt << 1,l,mid,x,y)+tree[rt].add);
	else if (x>mid) return min(oo,askmi(rt << 1 | 1,mid+1,r,x,y)+tree[rt].add);
	else return min(oo,min(askmi(rt << 1,l,mid,x,mid),askmi(rt << 1 | 1,mid+1,r,mid+1,y))+tree[rt].add);
}

void dfs1(int x,int father) {
	ll tot=0;
	for(int tmp=head[x];tmp;tmp=next[tmp]) {
		if (t[tmp]==father) continue;
		dfs1(t[tmp],x);
		tot+=f[t[tmp]];
		tot=min(tot,oo);
	}
	if (x==1) {
		f[1]=tot;
		return;
	}
	for(int tmp=headi[x];tmp;tmp=next[tmp]) 
		change(1,1,m,id[t[tmp]],tot+v[tmp]);
	for(int tmp=heado[x];tmp;tmp=next[tmp])
		change(1,1,m,id[t[tmp]],oo);
	for(int tmp=head[x];tmp;tmp=next[tmp]) {
		if (t[tmp]==father) continue;
		add(1,1,m,fr[t[tmp]],to[t[tmp]],tot-f[t[tmp]]);
	}
	f[x]=askmi(1,1,m,fr[x],to[x]);
}

int main(){
	n=Read();
	m=Read();
	fo(i,1,n-1) {
		int x=Read(),y=Read();
		insert(x,y);
		insert(y,x);
	}
	fo(i,1,m) {
		int x=Read(),y=Read(),c=Read();
		insert_i(x,i,c);
		insert_o(y,i,c);
	}
	dfs(1,0);
	build(1,1,m);
	dfs1(1,0);
	ll ans=f[1];
	if (ans>=oo) ans=-1;
	printf("%I64d",ans);
	return 0;
}