#include <bits/stdc++.h>
#define FOR(i, l, r) for (int i = int(l); i < int(r); i++)
#define FST first
#define SCD second
#define modp 1000000007
#define MAXN 300113
#define INF 0x3f3f3f3f3f3f3f3fll
using namespace std;

typedef long long LL;
typedef unsigned int UI;

int N, M;
vector<int> G[MAXN], add[MAXN], del[MAXN];
int c[MAXN];
int start[MAXN], finish[MAXN];
LL seg[MAXN * 4], L[MAXN * 4];
int w[MAXN];
LL dp[MAXN];
void dfs(int v, int p, int &k)
{
    start[v] = k;
    if (v == 43426) {
        int asd = 1;
    }
    FOR(i, 0, add[v].size()) {
        w[add[v][i]] = k++;
    }
    FOR(i, 0, G[v].size()) {
        if (G[v][i] != p) {
            dfs(G[v][i], v, k);
        }
    }
    finish[v] = k - 1;
}
void update(int l, int r, int k, int a, int b, LL x)
{
    if (b < l || r < a || a > b) {
        return;
    }
    if (a <= l && r <= b) {
        L[k] = min(L[k] + x, INF);
        seg[k] = min(seg[k] + x, INF);
        return;
    }
    update(l, (l + r >> 1), (k << 1) + 1, a, b, x);
    update((l + r >> 1) + 1, r, (k << 1) + 2, a, b, x);
    seg[k] = min(INF, min(seg[(k << 1) + 1], seg[(k << 1) + 2]) + L[k]);
}
LL query(int l, int r, int k, int a, int b)
{
    if (b < l || r < a || a > b) {
        return INF;
    }
    if (a <= l && r <= b) {
        return seg[k];
    }
    return min(INF, min(query(l, l + r >> 1, (k << 1) + 1, a, b), query((l + r >> 1) + 1, r, (k << 1) + 2, a, b)) + L[k]);
}
LL solve(int x, int p)
{
    LL all = 0;
    FOR(i, 0, G[x].size()) {
        if (G[x][i] != p) {
            all += solve(G[x][i], x);
            all = min(all, INF);
        }
    }
    if (p == 0) {
        return all;
    }
    if (all == INF) {
        return INF;
    }
    FOR(i, 0, add[x].size()) {
        int &t = add[x][i];
        update(0, M - 1, 0, w[t], w[t], c[t] + all);
    }
    FOR(i, 0, del[x].size()) {
        int &t = del[x][i];
        update(0, M - 1, 0, w[t], w[t], INF);
    }
    FOR(i, 0, G[x].size()) {
        int &v = G[x][i];
        if (v == p) {
            continue;
        }
        update(0, M - 1, 0, start[v], finish[v], all - dp[v]);
    }
    dp[x] = query(0, M - 1, 0, start[x], finish[x]);
    return dp[x];
}
int main()
{
    scanf("%d%d", &N, &M);
    FOR(i, 1, N) {
        int u, v;
        scanf("%d%d", &u, &v);
        G[u].push_back(v);
        G[v].push_back(u);
    }
    FOR(i, 0, M) {
        int u, v;
        scanf("%d%d%d", &u, &v, &c[i]);
        add[u].push_back(i);
        del[v].push_back(i);
    }
    int k = 0;
    dfs(1, 0, k);
    LL res = solve(1, 0);
    if (res == INF) {
        res = -1;
    }
    printf("%I64d\n", res);
    return 0;
}
