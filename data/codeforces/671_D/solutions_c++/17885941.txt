#include<cstdio>
#include<cstring>
#include<vector>
#include<cstdlib>
#include<algorithm>
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define erp(i,a,b) for(int i=a;i>=b;--i)
#define mem(a) memset(a,0,sizeof a)
#define LL long long
using namespace std;
const int MAXN = 300005;

int N, M;
struct Ed {
	int to; Ed*nxt;
} Edges[MAXN*2], *ecnt=Edges, *adj[MAXN];
void adde(int a, int b)
{
	(++ecnt)->to=b;
	ecnt->nxt=adj[a];
	adj[a]=ecnt;
}

int fa[MAXN], dep[MAXN], tag[MAXN];
void dfs1(int u)
{
	dep[u]=dep[fa[u]]+1;
	for (Ed*p=adj[u]; p; p=p->nxt)
	{
		if (p->to==fa[u])continue;
		fa[p->to]=u, dfs1(p->to);
		if (tag[p->to]<=0) puts("-1"), exit(0);
		tag[u] += tag[p->to];
	}
}

struct item { int v; LL w; bool operator<(const item&b)const {return w<b.w;}};
vector<item> g[MAXN];
#define lch(a) tr[a].lch
#define rch(a) tr[a].rch
int ncnt;
struct Node {
	item val; LL tag;
	int lch, rch;
} tr[MAXN];
void uptag(int a, LL x)
{
	tr[a].val.w += x;
	tr[a].tag += x;
}
void pushdown(int a)
{
	if (!tr[a].tag) return;
	if (lch(a)) uptag(lch(a), tr[a].tag);
	if (rch(a)) uptag(rch(a), tr[a].tag);
	tr[a].tag = 0;
}
int merge(int a, int b)
{
	if (!a || !b) return a|b;
	pushdown(a), pushdown(b);
	if (tr[b].val < tr[a].val) swap(a, b);
	rch(a) = merge(rch(a), b);
	return swap(lch(a), rch(a)), a;
}
struct Heap
{
	int rt;
	void join(Heap&b) { rt = merge(rt, b.rt); }
	void pop() { pushdown(rt), rt = merge(lch(rt), rch(rt)); }
	item top() { return pushdown(rt), tr[rt].val; }
	void modify(LL x) { uptag(rt, x); }
	void push(item t)
	{
		tr[++ncnt] = (Node) {t, 0, 0, 0};
		rt = merge(rt, ncnt);
	}
} h[MAXN];

LL f[MAXN];
void dfs(int u)
{
	LL sum = 0;
	for (Ed*p=adj[u]; p; p=p->nxt)
		if (p->to!=fa[u])
		{
			dfs(p->to), sum += f[p->to];
			h[u].join(h[p->to]);
		}
	if (u==1) printf("%I64d\n", sum), exit(0);
	while (h[u].rt && dep[h[u].top().v] >= dep[u]) h[u].pop();
	for (vector<item>::iterator p = g[u].begin(); p!=g[u].end(); ++p)
		h[u].push((item){p->v, p->w});
	f[u] = sum + h[u].top().w;
	h[u].modify(sum - f[u]);
}

int main()
{
	scanf("%d%d", &N, &M);
	int u, v, w;
	rep(i, 2, N)
	{
		scanf("%d%d", &u, &v);
		adde(u, v), adde(v, u);
	}
	rep(i, 1, M)
	{
		scanf("%d%d%d", &u, &v, &w);
		tag[u]++, tag[v]--;
		if (u!=v) g[u].push_back((item){v, w});
	}
	dfs1(1);
	dfs(1);
	return 0;
}

 		 		 			 	 		      	   						