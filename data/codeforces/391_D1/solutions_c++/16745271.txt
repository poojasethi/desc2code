#include <iostream>
#include <set>
#include <algorithm>
#define x first
#define y second
using namespace std;

const int MAXN = 50001;
typedef pair<int, int> Range;
typedef pair<int, int> Query;
typedef pair<int, Range> Segment;

struct BIT {
    int sz; // Tree size
    int crd[MAXN]; // Coordinates
    int T[MAXN]; // Actual tree
    BIT(int Sz = 0): sz(Sz) { for (int i = 1; i <= sz; ++i) crd[i] = T[i] = 0; }
    void reset() { for (int i = 1; i <= sz; ++i) T[i] = 0; }
    int low(int x) { return lower_bound(crd + 1, crd + sz + 1, x) - crd; }
    int hi(int x) { return upper_bound(crd + 1, crd + sz + 1, x) - 1 - crd; }
    void up(int i, int v) { for (; i <= sz; i += i & (-i)) T[i] += v; }
    int get(int i) { int ans = 0; for (; i; i -= i & (-i)) ans += T[i]; return ans; }
    int get(int l, int r) { return get(r) - get(l - 1); }
};

int N, M;
Segment H[MAXN], V[MAXN];
BIT T;

bool check(int value) {
    T.reset();
    multiset<Query> In, Out;
    for (int i = 1; i <= N; ++i) {
        // Add vertical lines to set
        if (V[i].y.y - V[i].y.x < 2 * value) continue;
        In.insert(Query(V[i].y.x + value, i));
    }
    for (int i = 1; i <= M; ++i) {
        while (In.size() && In.begin()->x <= H[i].x) {
            int num = In.begin()->y; In.erase(In.begin());
            T.up(T.low(V[num].x), 1); Out.insert(Query(V[num].y.y - value + 1, num));
        }
        while (Out.size() && Out.begin()->x <= H[i].x) {
            int num = Out.begin()->y; Out.erase(Out.begin());
            T.up(T.low(V[num].x), -1);
        }
        if (H[i].y.y - H[i].y.x < 2 * value) continue;
        //cout << " at " << H[i].x << ' ' << T.get(T.low(H[i].y.x + value), T.hi(H[i].y.y - value)) << endl;
        if (T.get(T.low(H[i].y.x + value), T.hi(H[i].y.y - value)) > 0) return 1;
    }
    return 0;
}

int main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    cin >> N >> M;
    for (int i = 1; i <= N; ++i) cin >> V[i].x >> V[i].y.x >> V[i].y.y, V[i].y.y += V[i].y.x;
    for (int i = 1; i <= M; ++i) cin >> H[i].y.x >> H[i].x >> H[i].y.y, H[i].y.y += H[i].y.x;
    sort(H + 1, H + M + 1);
    T = BIT(N);
    for (int i = 1; i <= N; ++i) T.crd[i] = V[i].x; sort(T.crd + 1, T.crd + N + 1);
    int low = 1, hi = 1e9 + 1;
    while (low != hi) {
        int mid = (low + hi) >> 1;
        if (check(mid)) low = mid + 1; else hi = mid;
        //cout << mid << ' ' << check(mid) << endl;
    }
    cout << low - 1 << endl;
}
