#include<stdio.h>
#include<string.h>
#define fi first
#define se second
#include<vector>
#include<map>
#include<algorithm>
using namespace std;
#define M 500000
typedef pair<int,int> ii;
typedef pair<int,ii> II;
void minimize(int &a,int b){
	if( a > b ) a = b;
}
struct Fenwick_tree{
	int bit[M + 20];
	void init(){
		for(int i = 1 ; i <= M ; i++)	bit[i] = 1e9;
	}
	void update(int x,int v){
		for(; x <= M ; x+=x&(-x) ) minimize(bit[x],v);
	}
	int get(int x){
		int res = 1e9;
		for(; x > 0 ; x-=x&(-x) ) minimize(res,bit[x]);
		return res;
	}
};
Fenwick_tree tree;
map<int,int> last;
II q[M + 20];
int a[M + 20];
int ans[M + 20];
bool cmp(II a,II b){
	return (a.se.fi > b.se.fi);
}
int n,m;
void read(){
	scanf("%d %d",&n,&m);
	for(int i = 1 ; i <= n ; i++)	scanf("%d",&a[i]);
	for(int i = 1 ; i <= m ; i++){
			q[i].fi = i;
			scanf("%d %d",&q[i].se.fi,&q[i].se.se);
	}
}
void solve(){
	sort(q + 1 ,q + 1 + m,cmp);
	tree.init();
	int pos = n;
	for(int i = 1 ; i <= m ; i++){
		while(pos >= q[i].se.fi){
			if(last.find(a[pos]) != last.end()) tree.update(last[a[pos]] , last[a[pos]] - pos);
			last[a[pos]] = pos;
			pos--;
		}
		ans[q[i].fi] = tree.get(q[i].se.se);
	}
	for(int i = 1 ; i <= m ; i++)	printf("%d\n",ans[i] == 1e9 ? -1 : ans[i]);
}
main(){
//	freopen("test.inp","r",stdin);
	read();
	solve();
}
