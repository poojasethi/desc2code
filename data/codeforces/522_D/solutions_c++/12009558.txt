#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define fi first
#define se second
#define maxn 500005
using namespace std;
pair <int ,int > d[maxn];
pair < pair < int ,int >,int > q[maxn];
int i,j,k,l,n,m,pre[maxn],a,b,c,tree[4*maxn],res[maxn];
void update(int nd,int bas,int son,int l,int val){
	 if(l<bas || l>son)
	 return ;
	 if(bas==son){
		 tree[nd]=val;
		 return ;
	 }
	 int orta=(bas+son)/2;
	 update(2*nd,bas,orta,l,val);
	 update(2*nd+1,orta+1,son,l,val);
	 tree[nd]=min(tree[2*nd],tree[2*nd+1]);
}
int query(int nd,int bas,int son,int l,int r){
	if(l>son || r<bas)
	return 2*1e9;
	if(bas>=l && son<=r)
	return tree[nd];
	int orta=(bas+son)/2;
	return min(query(2*nd,bas,orta,l,r),query(2*nd+1,orta+1,son,l,r));
}
int main(){
	memset(tree,63,sizeof tree);
	scanf("%d %d",&n,&m);
	for(i=1;i<=n;i++){
		scanf("%d",&a);
		d[i]=make_pair(a,i);
	}
	sort(d+1,d+n+1);
	d[0].fi=2*1e9;
	for(i=1;i<=n;i++){
		if(d[i].fi!=d[i-1].fi)
		pre[d[i].se]=0;
		else
		pre[d[i].se]=d[i-1].se;
	}
	for(i=1;i<=m;i++){
		scanf("%d %d",&a,&b);
		q[i]=make_pair(make_pair(b,a),i);
	}
	q[0].fi.fi=0;
	sort(q+1,q+m+1);
	for(i=1;i<=m;i++){
		for(j=q[i-1].fi.fi+1;j<=q[i].fi.fi;j++)
		update(1,1,n,pre[j],j-pre[j]);
		int l=q[i].fi.se;
		int r=q[i].fi.fi;
		int num=q[i].se;
		int a=query(1,1,n,l,r);
		res[num]= a<1e9 ? a : -1;
	}	
	for(i=1;i<=m;i++)
	printf("%d\n",res[i]);
}
