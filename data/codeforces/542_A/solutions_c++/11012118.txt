#include <iostream>
#include <algorithm>
using namespace std;

typedef long long ll;
const int MAX = 2e5 + 1;
int n, m, maxVal;
struct NodeA{
    int id, lef, rig;
};
NodeA a[MAX];

bool cmpA(const NodeA& x, const NodeA& y){
    return x.lef < y.lef;
}

bool cmpAA(const NodeA& x, const NodeA& y){
    return x.rig < y.rig;
}

struct NodeB : public NodeA{
    ll val;
};
NodeB b[MAX];

bool cmpB(const NodeB& x, const NodeB& y){
    return x.lef < y.lef;
}

bool cmpBB(const NodeB& x, const NodeB& y){
    return x.rig < y.rig;
}

struct NodeIT{
    int pos;
    NodeIT *lef, *rig;
    NodeIT() : pos(0), lef(NULL), rig(NULL){}
};
NodeIT *it(NULL);

ll res;
int traA, traB;

void up(NodeIT *&root, const int& lef, const int& rig, const int& pos){
    if (root == NULL)
        root = new NodeIT;

    if (a[root->pos].rig - a[root->pos].lef < a[pos].rig - a[pos].lef)
        root->pos = pos;

    if (lef == rig){
        root->pos = pos;
        return;
    }

    int mid = (lef + rig) >> 1;
    if (a[pos].rig <= mid)
        up(root->lef, lef, mid, pos);
    else
        up(root->rig, mid + 1, rig, pos);
}

int get(NodeIT *&root, const int& lef, const int& rig, const int& u, const int& v){
    if (root == NULL)
        return 0;

    if (lef == u && rig == v)
        return root->pos;

    int mid = (lef + rig) >> 1;
    if (v <= mid)
        return get(root->lef, lef, mid, u, v);
    else
    if (u > mid)
        return get(root->rig, mid + 1, rig, u, v);
    else{
        int x = get(root->lef, lef, mid, u, mid);
        int y = get(root->rig, mid + 1, rig, mid + 1, v);
        return (a[x].rig - a[x].lef > a[y].rig - a[y].lef ? x : y);
    }
}

void remove(NodeIT *&root){
    if (root == NULL)
        return;
    remove(root->lef);
    remove(root->rig);
    delete root;
}

int main(){
    ios_base::sync_with_stdio(0);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i){
        a[i].id = i;
        cin >> a[i].lef >> a[i].rig;
        maxVal = max(maxVal, a[i].rig);
    }
    sort(a + 1, a + 1 + n, cmpA);

    for (int i = 1; i <= m; ++i){
        b[i].id = i;
        cin >> b[i].lef >> b[i].rig >> b[i].val;
        maxVal = max(maxVal, b[i].rig);
    }
    sort(b + 1, b + 1 + m, cmpB);

    int j = 1, k = 0, traK = 0;
    for (int i = 1; i <= m; ++i){
        while (j <= n && a[j].lef <= b[i].lef){
            if (k < a[j].rig){
                k = a[j].rig;
                traK = a[j].id;
            }
            ++j;
        }
        
        if (k > b[i].lef)
        if (res < b[i].val * (min(k, b[i].rig) - b[i].lef)){
            res = b[i].val * (min(k, b[i].rig) - b[i].lef);
            traA = traK;
            traB = b[i].id;
        }
    }

    j = n;
    for (int i = m; i >= 1; --i){
        while (j >= 1 && a[j].lef >= b[i].lef)
            up(it, 0, maxVal, j--);

        int pos = get(it, 0, maxVal, 0, b[i].rig);
        if (res < b[i].val * (a[pos].rig - a[pos].lef)){
            res = b[i].val * (a[pos].rig - a[pos].lef);
            traA = a[pos].id;
            traB = b[i].id;
        }
    }

    sort(a + 1, a + 1 + n, cmpAA);
    sort(b + 1, b + 1 + m, cmpBB);
    j = n; k = 2e9; traK = 0;
    for (int i = m; i >= 1; --i){
        while (j >= 1 && a[j].rig >= b[i].rig){
            if (k > a[j].lef){
                k = a[j].lef;
                traK = a[j].id;
            }
            --j;
        }

        if (k < b[i].rig)
        if (res < b[i].val * (b[i].rig - max(k, b[i].lef))){
            res = b[i].val * (b[i].rig - max(k, b[i].lef));
            traA = traK;
            traB = b[i].id;
        }
    }

    remove(it);

    cout << res;
    if (res)
        cout << endl << traA << ' ' << traB;

    return 0;
}