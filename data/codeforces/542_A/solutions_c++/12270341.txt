#include <stdio.h>
#include <algorithm>
using namespace std;
typedef long long LL;
#define M 200010
#define max(a, b) (a > b ? a : b)
#define min(a, b) (a > b ? b : a)

struct dat{
    int x, y, id;
    dat(int x = 0, int y = 0, int id = 0) : x(x), y(y), id(id) {}
} p[M], pp[M];

bool cmp(dat a, dat b){
    if(a.x != b.x) return a.x < b.x;
    return a.y < b.y;
}

int vis[M], mx[M][20], ID[M][20], n, Q;

void simple(){
    sort(pp + 1, pp + n + 1, cmp);
    int l = pp[1].x, r = pp[1].y, id = 1;
    for(int i = 2; i <= n; i++){
        if(pp[i].x >= l && pp[i].y <= r) vis[i] = 1;
        else if(pp[i].x <= l && r <= pp[i].y){
            vis[id] = 1; l = pp[i].x; r = pp[i].y;
        }
        else if(pp[i].x > l && pp[i].y > r){
            l = pp[i].x; r = pp[i].y;
        }
    }
    int cnt = 1;
    for(int i = 1; i <= n; i++) if(!vis[i]) p[cnt++] = pp[i];
    n = cnt - 1;
}

void RMQ(){
    for(int i = 1; i <= n; i++) mx[i][0] = p[i].y - p[i].x, ID[i][0] = p[i].id;
    for(int j = 1; j < 18; j++){
        if((1<<j) > n) break;
        for(int i = 1; i <= n - (1<<j) + 1; i++){
            mx[i][j] = max(mx[i][j-1], mx[i+(1<<(j-1))][j-1]);
            if(mx[i][j-1] < mx[i+(1<<(j-1))][j-1]) ID[i][j] = ID[i+(1<<(j-1))][j-1];
            else ID[i][j] = ID[i][j-1];
        }
    }
    return;
}

int num;

int query(int l, int r){
    int i;
    for(i = 1; i; i++) if((1<<i) > (r-l)) break;
    i--;
    if(mx[l][i] < mx[r-(1<<i)+1][i]) num = ID[r-(1<<i)+1][i];
    else num = ID[l][i];
    return max(mx[l][i], mx[r-(1<<i)+1][i]);
}

bool cmpx(dat a, dat b) {return a.x < b.x;}
bool cmpy(dat a, dat b) {return a.y < b.y;}

int main(){

    scanf("%d %d", &n, &Q);
    for(int i = 1; i <= n; i++){
        scanf("%d %d", &pp[i].x, &pp[i].y); pp[i].id = i;
    }
    simple(); RMQ();
    int x, y, l, r, c, id = -1, cha;
    LL ans = 0, tp;

    for(int i = 1; i <= Q; i++){
        LL tmp = ans;
        scanf("%d %d %d", &x, &y, &c);
        if(x >= p[n].y) continue;
        l = lower_bound(p + 1, p + n + 1, dat(x, 0, 0), cmpx) - p;
        r = upper_bound(p + 1, p + n + 1, dat(0, y, 0), cmpy) - p; r--;
        if(l <= r){
            tp = 1LL * c * query(l, r);

            if(ans < tp) {id = num; ans = tp;}
            if(l > 1){
                tp = 1LL * c * (p[l-1].y - x);
                if(ans < tp) ans = tp, id = p[l-1].id;
            }
            if(r < n){
                tp = 1LL * c * (y - p[r+1].x);
                if(ans < tp) ans = tp, id = p[r+1].id;
            }
        }
        else{
            if(l <= n){
                tp = 1LL * c * (y - p[l].x);
                if(ans < tp) ans = tp, id = p[l].id;
            }
            if(l > 1){
                tp = min(1LL * c * (p[l-1].y - x), 1LL * c * (y - x));
                if(ans < tp) ans = tp, id = p[l-1].id;
            }
        }

        if(ans > tmp) cha = i;
    }
    if(!ans) puts("0");
    else{
        printf("%I64d\n", ans);
        printf("%d %d\n", id, cha);
    }
    return 0;
}
