#include<stdio.h>
#include<algorithm>
using namespace std;
long long dir3,dir,dir2,maxi,dap,n,t,top,m,x,y,c,p,X[200010],Y[200010],pos,pos2,tree[2000010],P[200010],treepos[2000010];
struct data
{
    long long x,y,pos;
    bool operator<(const data&r)const
    {
        if(x==r.x) return y>r.y;
        return x<r.x;
    }
}a[200010];
data d[200010];
void update(int x,long long c)
{
    tree[x]=c; x/=2;
    while(x)
    {
        if(tree[x*2]>tree[x*2+1]) treepos[x]=treepos[x*2];
        else treepos[x]=treepos[x*2+1];
        tree[x]=max(tree[x*2],tree[x*2+1]);
        x/=2;
    }
}
long long query(int x,int y,int k,int s,int e)
{
    if(x>e || y<s) return 0;
    if(s<=x && y<=e) return tree[k];
    long long s1=query(x,(x+y)/2,k*2,s,e), s2=query((x+y)/2+1,y,k*2+1,s,e);
    if(maxi<s1) maxi=s1, dir3=P[treepos[k*2]];
    if(maxi<s2) maxi=s2, dir3=P[treepos[k*2+1]];
    return max(s1,s2);
}
int main()
{
    int i;
    scanf("%lld %lld",&n,&m);
    for(i=1;i<=n;i++)
    {
        scanf("%lld %lld",&a[i].x,&a[i].y); a[i].pos=i;
    }
    sort(a+1,a+n+1);
    for(i=1;i<=n;i++)
    {
        if(p<a[i].y){p=a[i].y, d[++top]=a[i];}
    }
    for(i=1;i<=top;i++)
    {
        X[i]=d[i].x; Y[i]=d[i].y; P[i]=d[i].pos;
    }
    for(t=1;t<=top;t*=2);
    for(i=t;i<=t*2-1;i++) treepos[i]=i-t+1;
    for(i=1;i<=top;i++) update(t+i-1,Y[i]-X[i]);
    for(i=1;i<=m;i++)
    {
        scanf("%lld %lld %lld",&x,&y,&c);
        pos=upper_bound(X+1,X+top+1,x)-X; pos--;
        if(pos!=0 && dap<c*(min(y,Y[pos])-x)){dap=c*(min(y,Y[pos])-x); dir=P[pos], dir2=i;}
        pos2=lower_bound(Y+1,Y+top+1,y)-Y;
        if(pos2!=top+1 && dap<c*(y-max(x,X[pos2]))){dap=c*(y-max(x,X[pos2])); dir=P[pos2]; dir2=i;}
        if(dap<c*(query(1,t,1,pos+1,pos2-1)))
        {
            maxi=0;
            dap=c*(query(1,t,1,pos+1,pos2-1));
            dir=dir3;
            dir2=i;
        }
    }
    printf("%lld\n",dap);
    if(dap==0) return 0;
    printf("%lld %lld",dir,dir2);
    return 0;
}
