#include <algorithm>
#include <iostream>
#include <cassert>
#include <climits>
#include <cstdlib>
#include <cstring>
#include <iomanip>
#include <numeric>
#include <cstdio>
#include <string>
#include <vector>
#include <cmath>
#include <ctime>
#include <queue>
#include <stack>
#include <map>
#include <set>

using namespace std;

#define F first
#define S second

#define endl '\n'

#define mp make_pair
#define pb push_back

#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define ROF(i, a, b) for(int i = a; i >= b; i--)

#define type(x) __typeof((x).begin())
#define foreach(i, x) for(type(x) i = (x).begin(); i != (x).end(); i++)

#define sol (root + root)
#define sag (root + root + 1)
#define orta ((bas + son) >> 1)

#define bit __builtin_popcount

#ifndef D
    #define dbg(x) 0
    #define dbgs(x) 0
#else
    #define dbg(x) cerr << (#x) << " --> " << (x) << endl
    #define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#endif

typedef long long ll;
typedef pair < int, int > pii;

const int inf = 1e9 + 5;
const ll linf = 1e18 + 5;

const int N = 2e5 + 5;

struct t{

	int x, y, sx, sy, power, num;
	pii ans;
	
	bool operator<(t other) const {
		return y < other.y;
	}

};

int n, m;
pii fen[N << 2];
t a[N], b[N];
vector < int > vals;

void up(int x, pii k) {

	for(; x; x -= x & (-x))
		fen[x] = max(fen[x], k);

}

pii get(int x) {

	pii mx = mp(0, 0);

	for(; x < (N << 2); x += x & (-x))
		mx = max(mx, fen[x]);

	return mx;

}

bool cmp(t x, t y) {
	return x.x < y.x;
}

int main () {
    
    ios :: sync_with_stdio(0);
 
	cin >> n >> m;

	FOR(i, 1, n) {
		cin >> a[i].x >> a[i].y;
		a[i].num = i;
		vals.pb(a[i].x);
		vals.pb(a[i].y);
	}

	FOR(i, 1, m) {
		cin >> b[i].x >> b[i].y >> b[i].power;
		b[i].num = i;
		vals.pb(b[i].x);
		vals.pb(b[i].y);
	}

	sort(a + 1, a + n + 1);
	sort(b + 1, b + m + 1);

	sort(vals.begin(), vals.end());
	vals.resize(unique(vals.begin(), vals.end()) - vals.begin());

	FOR(i, 1, n) {
		a[i].sx = upper_bound(vals.begin(), vals.end(), a[i].x) - vals.begin();
		a[i].sy = upper_bound(vals.begin(), vals.end(), a[i].y) - vals.begin();
	}
	
	FOR(i, 1, m) {
		b[i].sx = upper_bound(vals.begin(), vals.end(), b[i].x) - vals.begin();
		b[i].sy = upper_bound(vals.begin(), vals.end(), b[i].y) - vals.begin();
	}

	int j = 1;

	FOR(i, 1, m) {
		while(j <= n and a[j].y <= b[i].y) {
			up(a[j].sx, mp(a[j].y - a[j].x, a[j].num));
			j++;
		}
		b[i].ans = get(b[i].sx);
	}

	pii curmin = mp(inf, 0);
	j = n;

	ROF(i, m, 1) {
		while(j >= 1 and b[i].y <= a[j].y) {
			curmin = min(curmin, mp(a[j].x, a[j].num));
			j--;
		}
		b[i].ans = max(b[i].ans, mp(b[i].y - max(b[i].x, curmin.F), curmin.S));
	}
	
	sort(a + 1, a + n + 1, cmp);
	sort(b + 1, b + m + 1, cmp);

	pii curmax = mp(0, 0);
	j = 1;

	FOR(i, 1, m) {
		while(j <= n and a[j].x <= b[i].x) {
			curmax = max(curmax, mp(a[j].y, a[j].num));
			j++;
		}
		b[i].ans = max(b[i].ans, mp(min(b[i].y, curmax.F) - b[i].x, curmax.S));
	}

	int mxi, mxj;
	ll mx = 0;

	FOR(i, 1, m) {
		if((ll) b[i].ans.F * b[i].power > mx) {
			mx = (ll) b[i].ans.F * b[i].power;
			mxi = b[i].ans.S;
			mxj = b[i].num;
		}
	}

	cout << mx << endl;

	if(mx)
		cout << mxi << ' ' << mxj << endl;

    return 0;
    
}
