#pragma comment(linker, "/STACK:1024000000,1024000000") 
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <vector>
#include <map>
#include <queue>
#include <set>
#include <assert.h>
#define x first 
#define y second 
#define pb push_back 
#define mp make_pair 
#define vi vector<int> 
#define pii pair<int,int> 
#define ll long long 
#define ull unsigned long long 
#define inf 1000000007 
#define mod 1000000007 
#define all(x) x.begin(),x.end() 
#define N 200010
#define pi acos(-1.)
#define DBG(x) cerr<<#x<<"="<<x<<"\n"; 
#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++) 
using namespace std;

pii a[N];
struct node{
    int x,y,c;
}b[N];
int find(vi &v,int x){return lower_bound(all(v),x)-v.begin();}
struct node1{
    int x,y,t;
    bool operator <(const node1 &a)const{
        if(x!=a.x)return x<a.x;
        return t<a.t;
    }
};
bool cmp(node1 a,node1 b){
    if(a.x!=b.x)return a.x>b.x;
    return a.t<b.t;
}
bool cmp1(node1 a,node1 b){
    if(a.y!=b.y)return a.y>b.y;
    return a.t<b.t;
}
int t[N*16],c[N*16];
void build(int p,int l,int r){
    t[p]=-inf;
    if(l==r)return;
    int m=(l+r)>>1;
    build(p<<1,l,m);build(p<<1|1,m+1,r);
}
void upd(int p,int l,int r,int x,int v,int w){
    if(t[p]<v){t[p]=v,c[p]=w;}
    if(l==r)return;
    int m=(l+r)>>1;
    if(x<=m)upd(p<<1,l,m,x,v,w);
    else upd(p<<1|1,m+1,r,x,v,w);
}
pii query(int p,int l,int r,int x,int y){
    if(l==x&&r==y)return mp(t[p],c[p]);
    int m=(l+r)>>1;
    if(y<=m)return query(p<<1,l,m,x,y);
    if(x>m)return query(p<<1|1,m+1,r,x,y);
    pii a=query(p<<1,l,m,x,m),b=query(p<<1|1,m+1,r,m+1,y);
    if(a.x>=b.x)return a;
    return b;
}
ll ans[N];int res[N];
int main()
{
    int T,i,j,k,n,m;
    scanf("%d%d",&n,&m);
    vi v;
    for(i=0;i<n;i++){
        scanf("%d%d",&a[i].x,&a[i].y);
        v.pb(a[i].x),v.pb(a[i].y);
    }
    for(i=0;i<m;i++){
        scanf("%d%d%d",&b[i].x,&b[i].y,&b[i].c);
        v.pb(b[i].x),v.pb(b[i].y);
    }
    sort(all(v));
    v.erase(unique(all(v)),v.end());
    int M=v.size();
    vector<node1>e;
    for(i=0;i<n;i++){
        a[i].x=find(v,a[i].x);
        a[i].y=find(v,a[i].y);
        e.pb((node1){a[i].x,a[i].y,i});
    }
    for(i=0;i<m;i++){
        b[i].x=find(v,b[i].x);
        b[i].y=find(v,b[i].y);
        e.pb((node1){b[i].x,b[i].y,i+n});
    }
    sort(all(e));
    build(1,0,M-1);
    for(i=0;i<e.size();i++){
        int ty=e[i].t;
        if(ty<n){
            upd(1,0,M-1,e[i].y,v[e[i].y],ty);
        }
        else{
            pii q=query(1,0,M-1,e[i].x,M-1);
            j=e[i].t-n;
            if(q.x>-inf){
                k=min(q.x,v[b[j].y]);
                ans[j]=1LL*b[j].c*(k-v[b[j].x]);
                res[j]=q.y;
            }
        }
    }
    build(1,0,M-1);
    sort(all(e),cmp);
    for(i=0;i<e.size();i++){
        int ty=e[i].t;
        if(ty<n){
            upd(1,0,M-1,e[i].y,v[e[i].y]-v[e[i].x],ty);
        }
        else{
            pii q=query(1,0,M-1,e[i].x,e[i].y);
            j=e[i].t-n;
            if(q.x>-inf){
                ll tt=1LL*b[j].c*q.x;
                if(ans[j]<tt)ans[j]=tt,res[j]=q.y;
            }
        }
    }
    sort(all(e),cmp1);
    build(1,0,M-1);
    for(i=0;i<e.size();i++){
        int ty=e[i].t;
        if(ty<n){
            upd(1,0,M-1,e[i].x,-v[e[i].x],ty);
        }
        else{
            pii q=query(1,0,M-1,0,e[i].y);
            j=e[i].t-n;
            if(q.x>-inf){
                k=max(-q.x,v[b[j].x]);
                ll tt=1LL*b[j].c*(v[b[j].y]-k);
                if(ans[j]<tt)ans[j]=tt,res[j]=q.y;
            }
        }
    }
    ll A=0;pii B;
    for(i=0;i<m;i++){
        if(A<ans[i]){
            A=ans[i],B=mp(res[i],i);
        }
    }
    if(A==0)puts("0");
    else
    printf("%I64d\n%d %d\n",A,B.x+1,B.y+1);
    return 0;
}