#include<bits/stdc++.h>

using namespace std;

#define foreach(i, x)  for(type(x) i=x.begin() ; i != x.end() ; i++)
#define FOR(ii, aa, bb) for(int ii = aa ; ii <= bb ; ii++)
#define ROF(ii, aa, bb) for(int ii = aa ; ii >= bb ; ii--)

#define type(x) __typeof(x.begin())

#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair< int, int > pii;

typedef long long ll;
 
const int mod  = 1e9+7;
const ll  linf = 1e18;
const int inf  = 1e9;
const int N = 1e6+5;

int n, m, k, way, x, y, z, p[N];
pii a[N];
pair< pii , int > b[N];
vector< pii > v1[N], v2[N], e1[N], e2[N];
ll ans;
int F[6][N];
map< int , int > w, h;

int merge(int w,int x,int y) { return w == 1 ? min(x,y) : max(x,y); }

void update(int w,int x,int t) {
	if(w == 2 || w == 5 || w == 4) for(;x < N && x > 0 ; x += x & -x) F[w][x] = merge(w,F[w][x],t);
	else for(;x > 0;x -= x & -x) F[w][x] = merge(w,F[w][x],t);
}

int query(int w,int x) {
	int ans = ((w == 1) ? inf : 0);
	if(w == 2 || w == 5 || w == 4) for(;x > 0;x -= x & -x) ans = merge(w,F[w][x],ans);
	else for(;x < N && x > 0;x += x & -x) ans = merge(w,F[w][x],ans);
	return ans;
}

int main(){

	cin >> n >> m;

	FOR(i,1,n) { scanf("%d %d",&a[i].st,&a[i].nd); h[a[i].st] = h[a[i].nd] = true; }
	FOR(i,1,m) { scanf("%d %d %d",&b[i].st.st,&b[i].st.nd,&b[i].nd); h[b[i].st.st] = h[b[i].st.nd] = true; }

	int s = 0; foreach(it,h) { w[it->st] = ++s; p[s] = it->st; }

	FOR(i,1,N) F[1][i] = inf;

	FOR(i,1,n) {
		a[i].st = w[a[i].st];
		a[i].nd = w[a[i].nd];
		v1[a[i].st].pb(mp(a[i].nd,i));
		e1[a[i].nd].pb(mp(a[i].st,i));
	}
	
	FOR(i,1,m) { 
		b[i].st.st = w[b[i].st.st];
		b[i].st.nd = w[b[i].st.nd];
		v2[b[i].st.st].pb(mp(b[i].st.nd,i)); 
		e2[b[i].st.nd].pb(mp(b[i].st.st,i)); 
	}

	ll x = 0;

	ROF(i,s,1) {
		foreach(it,v1[i]) {
			update(1,it->st,i);
			update(2,it->st,p[it->st]-p[i]);
		}
		foreach(it,v2[i]) {
			x = query(1,it->st+1);
			if(x < it->st && ans < (ll)(p[it->st]-p[x]) * b[it->nd].nd) {
				ans = (ll)(p[it->st]-p[x]) * b[it->nd].nd;
				way = it->nd;	
			}
			x = query(2,it->st);
			if(ans < x * b[it->nd].nd) {
				ans = x * b[it->nd].nd;
				way = it->nd;	
			}
		}
	}

	FOR(i,1,s) {
		foreach(it,e1[i]) {
			update(3,it->st,p[i]-p[it->st]);
			update(4,it->st,i);
		} 
		foreach(it,v1[i]) update(5,i,it->st);
		foreach(it,e2[i]) {
			x = query(4,it->st);
			if(ans < (ll)(p[x]-p[it->st]) * b[it->nd].nd) {
				ans = (ll)(p[x]-p[it->st]) * b[it->nd].nd;
				way = it->nd;	
			}
			x = query(3,it->st);
			if(ans < x * b[it->nd].nd) {
				ans = x * b[it->nd].nd;
				way = it->nd;	
			}
			x = query(5,it->st);
			if(x >= i && b[it->nd].nd * (ll)(p[i] - p[it->st]) > ans) {
				ans = b[it->nd].nd * (ll)(p[i] - p[it->st]);
				way = it->nd;	
			} 
		}
	}
	
	cout << ans << endl;

	if(!ans) return 0;

	FOR(i,1,n) 
		if((p[min(b[way].st.nd,a[i].nd)] - (ll)p[max(a[i].st,b[way].st.st)])*b[way].nd == ans) {
			cout << i << ' ' << way << endl; 
			return 0;
		}

   return 0;
}
