/*
 * Problem : 
 * Author : Hwhitetooth
 * Date : 
 * Result :
 */

#include <iostream>
#include <sstream>
#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <cctype>
#include <cstring>
#include <string>
#include <vector>
#include <deque>
#include <queue>
#include <stack>
#include <list>
#include <map>
#include <set>
#include <algorithm>

using namespace std;

typedef long long LL;
typedef unsigned long long ULL;
typedef long double LD;

const int N = 200000 + 10;
const int INF = 1000000001;

struct Item {
	int l, r;
	int c;
	int id;

	int operator <(const Item &that) const {
		return l < that.l;
	}
} a[N + N], b[N];
map<int, int> h;
int tot;
int bit[N];
int n, m;
LL ansE;
int ansI;

void ins(int x, int u) {
	for (; x <= tot; x += x & -x) {
		bit[x] = max(bit[x], u);
	}
}

int ask(int x) {
	int ret = - INF;
	for (; x > 0; x -= x & -x) {
		ret = max(ret, bit[x]);
	}
	return ret;
}

void solve() {
	h.clear();
	tot = 0;
	for (int i = 0; i < n; ++i) {
		h[a[i].l] = 0;
	}
	h[INF] = 0;
	for (map<int, int>::iterator it = h.begin(); it != h.end(); ++it) {
		it->second = ++tot;
	}
	fill(bit + 1, bit + tot + 1, -INF);
	for (int i = 0; i < n; ++i) {
		ins(h[a[i].l], a[i].r);
	}
	for (int i = 0; i < m; ++i) {
		int tmp = ask(h.upper_bound(b[i].l)->second - 1);
		tmp = min(tmp, b[i].r) - b[i].l;
		if (1LL * tmp * b[i].c > ansE) {
			ansE = 1LL * tmp * b[i].c;
			ansI = i;
		}
	}
}

void transform(Item *a, int n) {
	for (int i = 0; i < n; ++i) {
		a[i].l = -a[i].l;
		a[i].r = -a[i].r;
		swap(a[i].l, a[i].r);
	}
}

LL calc(const Item &a, const Item &b) {
	int l = max(a.l, b.l), r = min(a.r, b.r), c = a.c + b.c;
	return 1LL * (r - l) * c;
}

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 0; i < n; ++i) {
		scanf("%d%d", &a[i].l, &a[i].r);
		a[i].id = i;
	}
	for (int i = 0; i < m; ++i) {
		scanf("%d%d%d", &b[i].l, &b[i].r, &b[i].c);
		b[i].id = i;
	}
	solve();
	transform(a, n);
	transform(b, m);
	solve();
	transform(a, n);
	transform(b, m);
	h.clear();
	tot = 0;
	for (int i = 0; i < n; ++i) {
		h[a[i].r] = 0;
	}
	h[INF] = 0;
	for (map<int, int>::iterator it = h.begin(); it != h.end(); ++it) {
		it->second = ++tot;
	}
	for (int i = 0; i < m; ++i) {
		a[n++] = b[i];
	}
	sort(a, a + n);
	for (int i = n - 1; i >= 0; --i) {
		if (!a[i].c) {
			ins(h[a[i].r], a[i].r - a[i].l);
		}
		else {
			int tmp = ask(h.upper_bound(a[i].r)->second - 1);
			if (1LL * tmp * a[i].c > ansE) {
				ansE = 1LL * tmp * a[i].c;
				ansI = a[i].id;
			}
		}
	}
	printf("%lld\n", ansE);
	if (ansE > 0) {
		for (int i = 0; i < n; ++i) {
			if (!a[i].c && calc(a[i], b[ansI]) == ansE) {
				printf("%d %d\n", a[i].id + 1, ansI + 1);
				break;
			}
		}
	}
	return 0;
}
