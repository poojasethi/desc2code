#include<stdio.h>
#include<string.h>
#include<algorithm>
#include<math.h>
#include<iostream>
#include<stdlib.h>
#include<set>
#include<map>
#include<queue>
#include<vector>
#define inf 1000000000
#define PI acos(-1.0)
#define lson(x) (x<<1)
#define rson(x) (x<<1|1)
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define drep(i,a,b) for(int i=a;i>=b;i--)
using namespace std;
typedef long long ll;
struct line{
	int x,y;
	int l,r,idx;
}l[200100];
bool cmpl(line x,line y){
	return  x.y<y.y;
}
struct ques{
	int x,y,val;
	int l,r,idx;
}q[200100];
bool cmpq(ques x,ques y){
	return  x.y<y.y;
}
int b[800200],bn;
int findx(int x){
	return lower_bound(b+1,b+1+bn,x)-b;
}
int H,M;
struct node{
	int maxlen,maxright,minleft;
}T[2200000];
void init(int n){
	H=0;
	for(int i=1;i<n+2;i<<=1)H++;
	M=1<<H;
	//printf("--%d %d\n",H,M);
	rep(i,1,(M<<1)-1)T[i].maxlen=0,T[i].maxright=0,T[i].minleft=inf;
}
void update(int l,int r,int x,int y){
	
	//printf("-->%d %d %d %d\n",l,r,x,y);
	for(int pos=l+M;pos>0;pos>>=1)
		T[pos].maxlen=max(T[pos].maxlen,y-x),
		T[pos].maxright=max(T[pos].maxright,y);
	for(int pos=r+M;pos>0;pos>>=1)
		T[pos].minleft=min(T[pos].minleft,x);
}
int query_len(int l,int r){
	int ans=-1;
	for(l=l+M-1,r=r+M+1;l^r^1;l>>=1,r>>=1){
		if(!(l&1))ans=max(T[l^1].maxlen,ans);
		if(r&1)ans=max(T[r^1].maxlen,ans);
	}
	return ans;
}
int query_right(int l,int r){
	int ans=-1;
	for(l=l+M-1,r=r+M+1;l^r^1;l>>=1,r>>=1){
		if(!(l&1))ans=max(T[l^1].maxright,ans);
		if(r&1)ans=max(T[r^1].maxright,ans);
	}
	return ans;
}
int query_left(int l,int r){
	int ans=inf;
	for(l=l+M-1,r=r+M+1;l^r^1;l>>=1,r>>=1){
		if(!(l&1))ans=min(T[l^1].minleft,ans);
		if(r&1)ans=min(T[r^1].minleft,ans);
	}
	return ans;
}
void debug(){
	rep(i,1,M*2-1)printf("T[%d]=%d  %d  %d\n",i,T[i].maxlen,T[i].maxright,T[i].minleft);
}
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	rep(i,1,n)scanf("%d%d",&l[i].x,&l[i].y),l[i].idx=i,b[++bn]=l[i].x,b[++bn]=l[i].y;
	rep(i,1,m)scanf("%d%d%d",&q[i].x,&q[i].y,&q[i].val),q[i].idx=i,b[++bn]=q[i].x,b[++bn]=q[i].y;
	sort(l+1,l+1+n,cmpl);
	sort(q+1,q+1+m,cmpq);
	sort(b+1,b+1+bn);
	bn=unique(b+1,b+1+bn)-b-1;
	init(bn);
	//rep(i,1,bn)printf("%d ",b[i]);
//	printf("\n");
	rep(i,1,n)l[i].l=findx(l[i].x),l[i].r=findx(l[i].y);
	rep(i,1,m)q[i].l=findx(q[i].x),q[i].r=findx(q[i].y);
	l[n+1].y=-1;
	q[m+1].y=-1;
	int p1=1,p2=1,ans_t,ans_v;
	ll ans=-1LL;
	rep(i,1,bn){
		while(l[p1].r==i){
			update(l[p1].l,l[p1].r,l[p1].x,l[p1].y);
			//debug();
			p1++;
		}
		while(q[p2].r==i){
			if(q[p2].l-1>=1){
				int r=min(query_right(1,q[p2].l-1),q[p2].y);
				if(1LL*(r-q[p2].x)*q[p2].val>ans){
					ans=1LL*(r-q[p2].x)*q[p2].val;
					ans_t=p2;
				}
			}
			int t=query_len(q[p2].l,q[p2].r);
			if(1LL*t*q[p2].val>ans){
				ans=1LL*t*q[p2].val;
				ans_t=p2;
			}
			p2++;
		}
	}
	rep(i,1,m){
		if(q[i].r+1<=bn){
				int l=max(query_left(q[i].r+1,bn),q[i].x);
				if(1LL*(q[i].y-l)*q[i].val>ans){
					
				
				//printf("-->%d\n",l);
					ans=1LL*(q[i].y-l)*q[i].val;
					ans_t=i;
				}
			}
	}
	
	if(ans>0){
		printf("%lld\n",ans);
		rep(i,1,n){
			int len=min(q[ans_t].y,l[i].y)-max(q[ans_t].x,l[i].x);
			if(1LL*len*q[ans_t].val==ans){
				printf("%d %d\n",l[i].idx,q[ans_t].idx);
				break;
			}	
		}		
	}
	else printf("%d\n",0);
	
	return 0;
}

 			    		  		 			  				 		 		