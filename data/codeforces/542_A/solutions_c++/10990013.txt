#include <cstdio>
#include <algorithm>
#define N 200005
#define M 1000005
#define LL long long
#define fi(a, b, c) for(int a = (b); a < (c); a++)
#define fd(a, b, c) for(int a = (b); a > (c); a--)
#define FI(a, b, c) for(int a = (b); a <= (c); a++)
#define FD(a, b, c) for(int a = (b); a >= (c); a--)
#define fe(a, b, c) for(int a = (b); a; a = c[a])
using namespace std;

int n, m, tl[M], otl[M], tr[M], otr[M], cor[M], p, bit[M], opt[M], ans2, ans3;
LL ans;
struct rec{
	int l, r, c, id;
	bool operator < (const rec &T) const{
		return l < T.l;
	}
} x[N], y[N];

bool cmp(rec a, rec b){
	return a.r < b.r;
}

void update(int x, int y, int z){
	for(int i = x; i <= p; i += i & -i){
		if(y > bit[i]){
			bit[i] = y;
			opt[i] = z;
		}
	}
}

int query(int x, int &c){
	int ret = 0;
	for(int i = x; i; i ^= i & -i){
		if(ret < bit[i]){
			ret = bit[i];
			c = opt[i];
		}
	}
	return ret;
}

int main(){
	scanf("%d %d", &n, &m);
	fi(i, 0, n){
		scanf("%d %d", &x[i].l, &x[i].r);
		x[i].id = i + 1;
		cor[p++] = x[i].l;
		cor[p++] = x[i].r;
	}
	fi(i, 0, m){
		scanf("%d %d %d", &y[i].l, &y[i].r, &y[i].c);
		y[i].id = i + 1;
		cor[p++] = y[i].l;
		cor[p++] = y[i].r;
	}
	
	sort(cor, cor + p);
	p = unique(cor, cor + p) - cor;
	
	sort(x, x + n, cmp);
	int ptr = n - 1;
	FD(i, p - 1, 0){
		if(i < p - 1){
			tr[i] = max(tr[i + 1] - cor[i + 1] + cor[i], 0);
			otr[i] = otr[i + 1];
		}
		
		while(ptr >= 0 && x[ptr].r >= cor[i]){
			if(tr[i] < cor[i] - x[ptr].l){
				tr[i] = cor[i] - x[ptr].l;
				otr[i] = x[ptr].id;
			}
			ptr--;
		}
	}
	
	sort(x, x + n);
	ptr = 0;
	fi(i, 0, p){
		if(i){
			tl[i] = max(tl[i - 1] - cor[i] + cor[i - 1], 0);
			otl[i] = otl[i - 1];
		}
		while(ptr < n && x[ptr].l <= cor[i]){
			if(tl[i] < x[ptr].r - cor[i]){
				tl[i] = x[ptr].r - cor[i];
				otl[i] = x[ptr].id;
			}
			ptr++;
		}
	}
	
	ptr = n - 1;
	sort(y, y + m);
	FD(i, m - 1, 0){
		while(ptr >= 0 && x[ptr].l >= y[i].l){
			int pos = lower_bound(cor, cor + p, x[ptr].r) - cor;
			update(pos + 1, x[ptr].r - x[ptr].l, x[ptr].id);
			ptr--;
		}
		
		int l = lower_bound(cor, cor + p, y[i].l) - cor;
		int r = lower_bound(cor, cor + p, y[i].r) - cor;
		
		int best = max(tl[l], tr[r]), choice;
		if(tl[l] > tr[r]) choice = otl[l];
		else choice = otr[r];
		
		//printf("%d %d %d %d %d\n", y[i].id, tl[l], tr[r], best, choice);
		
		int a, b;
		a = query(r + 1, b);
		if(a > best){
			best = a;
			choice = b;
		}
		
		best = min(best, y[i].r - y[i].l);
		
		if(ans < (LL) best * y[i].c){
			ans = (LL) best * y[i].c;
			ans2 = choice;
			ans3 = y[i].id;
		}
	}
	
	if(ans) printf("%I64d\n%d %d\n", ans, ans2, ans3);
	else puts("0");
	
	scanf("\n");
}
