#define N (1<<19)
#define INFP (1<<30)
#define LL long long
#define PII pair<int,int>
#define PLII pair<LL,PII>
#include <bits/stdc++.h>
using namespace std;

struct Node
{
	int l,r,id;

}p[N];

PLII res;
PII t[N<<2];
map<int,int> mp;
int n,m,c[N],cnt;

bool cmp1(Node f,Node g)
{
	if(f.l!=g.l) return f.l<g.l;
	return f.id<g.id;
}

bool cmp2(Node f,Node g)
{
	if(f.r!=g.r) return f.r>g.r;
	return f.id<g.id;
}

bool cmp3(Node f,Node g)
{
	if(f.r!=g.r) return f.r<g.r;
	return f.id<g.id;
}

void update(int x,int l,int r,int i,PII val)
{
	if(l==r)
		t[i]=val;
	else
	{
		int mid=(l+r)>>1;
		if(x<=mid)
			update(x,l,mid,i<<1,val);
		else
			update(x,mid+1,r,(i<<1)+1,val);
		t[i]=max(t[i<<1],t[(i<<1)+1]);
	}
}

PII query(int tl,int tr,int l,int r,int i)
{
	if(tl>r || tr<l) return PII(0,0);
	if(tl<=l && r<=tr) return t[i];

	int mid=(l+r)>>1;
	return max(query(tl,tr,l,mid,i<<1),query(tl,tr,mid+1,r,(i<<1)+1));
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		scanf("%d%d",&p[i].l,&p[i].r),p[i].id=i;
	for(int i=1;i<=m;i++)
		scanf("%d%d%d",&p[n+i].l,&p[n+i].r,c+i+n),p[i+n].id=i+n;

	sort(p+1,p+n+m+1,cmp1);
	for(int i=1;i<=n+m;i++)
		if(mp.find(p[i].l)==mp.end()) mp[p[i].l]=++cnt;


	PII x=PII(0,0),y=PII(INFP,0);
	for(int i=1;i<=n+m;i++)
		if(p[i].id<=n)
			x=max(x,PII(p[i].r,p[i].id));
		else if(x.second)
			res=max(res,PLII((LL)(min(x.first,p[i].r)-p[i].l)*c[p[i].id],PII(x.second,p[i].id-n)));

	sort(p+1,p+n+m+1,cmp2);
	for(int i=1;i<=n+m;i++)
		if(p[i].id<=n)
			y=min(y,PII(p[i].l,p[i].id));
		else if(y.second)
			res=max(res,PLII((LL)(p[i].r-max(y.first,p[i].l))*c[p[i].id],PII(y.second,p[i].id-n)));

	sort(p+1,p+n+m+1,cmp3);
	for(int i=1;i<=n+m;i++)
		if(p[i].id<=n)
			update(mp[p[i].l],1,cnt,1,PII(p[i].r-p[i].l,p[i].id));
		else
		{
			PII val=query(mp[p[i].l],cnt,1,cnt,1);
			res=max(res,PLII((LL)val.first*c[p[i].id],PII(val.second,p[i].id-n)));
		}

	cout<<res.first<<endl;
	if(res.first)
		cout<<res.second.first<<" "<<res.second.second<<endl;
	return 0;
}
