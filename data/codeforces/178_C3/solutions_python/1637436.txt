#include <cstdio>
#include <cstring>
#include <map>
#include <vector>
#include <algorithm>

using namespace std;

const int MAXN = 200000;

struct BIT {
	int n, sum;
	vector<int> a, c;

	// initialization
	inline void init(int _n) {
		n = _n;
		a = c = vector<int>(n + 1, 0);
	}

	// update value in position i to val
	inline void update(int i, int val) {
		val -= a[i];
		a[i] += val;
		sum += val;
		for (++i; i <= n; i += i & -i) {
			c[i] += val;
		}
	}

	// query a[0] + ... + a[i - 1]
	inline int query(int i) {
		int ret = 0;
		for (; i > 0; i &= i - 1) {
			ret += c[i];
		}
		return ret;
	}

	// query a[i] + ... + a[j - 1]
	inline int query(int i, int j) {
		return query(j) - query(i);
	}
};

int H, M, n;

int chainN;
int c1[MAXN], c2[MAXN];
vector<int> chain[MAXN];
BIT bit[MAXN];

int main() {
	scanf("%d%d%d", &H, &M, &n);
	chainN = 0;
	memset(c1, -1, sizeof(c1));
	for (int i = 0; i < H; ++i) {
		if (c1[i] == -1) {
			for (int j = i; c1[j] == -1; j = (j + M) % H) {
				c1[j] = chainN;
				c2[j] = (int)chain[chainN].size();
				chain[chainN].push_back(j);
			}
			++chainN;
		}
	}
	for (int i = 0; i < chainN; ++i) {
		bit[i].init((int)chain[i].size());
	}
	map<int, int> chainID, chainOffset;
	long long res = 0;
	for (int i = 0; i < n; ++i) {
		int id, hash;
		char buf[2];
		scanf("%s%d", buf, &id);
		if (buf[0] == '+') {
			scanf("%d", &hash);
			int cid = c1[hash], offset = c2[hash], sz = (int)chain[cid].size();
			int pl, pr;
			if (bit[cid].query(offset, sz) == sz - offset) {
				res += sz - offset;
				pl = 0;
				pr = offset;
			} else {
				pl = offset;
				pr = sz;
			}
			while (pl + 1 < pr) {
				int pm = pl + (pr - pl) / 2;
				if (bit[cid].query(pl, pm) == pm - pl) {
					res += pm - pl;
					pl = pm;
				} else {
					pr = pm;
				}
			}
			chainID[id] = cid;
			chainOffset[id] = pl;
			bit[chainID[id]].update(chainOffset[id], 1);
		} else {
			bit[chainID[id]].update(chainOffset[id], 0);
		}
	}
	printf("%I64d\n", res);
	return 0;
}
