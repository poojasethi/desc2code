def gcd(a, b):
    while b:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a // gcd(a, b) * b

def cal((f1, k1), (f2, k2)):
    if f1 > f2:
        f1, k1, f2, k2 = f2, k2, f1, k1
    A = (f1 - f2) % k2
    B = 0
    x1 = 0
    k11 = k1 % k2
    k1x1 = 0
    while k11 > 0 and B != A and k1x1 <= f1:
        if B < A:
            dx1 = (A - B) // k11
        else:
            dx1 = (A + k2 - B) // k11
        dx1 = max(dx1, 1)
        B = (B + k11 * dx1) % k2
        x1 += dx1
        k1x1 += k1 * dx1
    if A == B:
        f = f1 - k1x1
        if f <= 0:
            return (0, 1)
        k = lcm(k1, k2)
        return (f, k)
    else:
        return (0, 1)

def cals(fks):
    fk0 = None
    for fk in fks:
        if fk0 is None:
            fk0 = fk
        else:
            # print fk, fk0
            fk0 = cal(fk0, fk)
        if fk0[0] == 0:
            return fk0
    return fk0

def solve():
    n = int(raw_input())
    a = map(int, raw_input().split())
    chs = [[] for i in xrange(n)]
    for i in xrange(n-1):
        u, v = map(int, raw_input().split())
        u, v = u - 1, v - 1
        chs[u].append(v)
        chs[v].append(u)

    p = []
    stk = [0]
    vis = {0}
    chs1 = [[] for i in xrange(n)]
    while stk:
        u = stk.pop()
        p.append(u)
        for v in chs[u]:
            if not v in vis:
                stk.append(v)
                chs1[u].append(v)
                vis.add(v)
    chs = chs1
    p.reverse()

    ws = [0] * n
    for u in p:
        ws[u] = a[u] + sum(ws[v] for v in chs[u])

    fks = [None] * n
    for u in p:
        if not chs[u]:
            fks[u] = (a[u], 1)
        else:
            f, k = cals(fks[v] for v in chs[u])
            nc = len(chs[u])
            fks[u] = (a[u] + f * nc, k * nc)
    # print chs
    # print zip(a, fks)
    return ws[0] - fks[0][0]

print solve()
