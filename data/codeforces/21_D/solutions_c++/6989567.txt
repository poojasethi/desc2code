#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <iostream>
#include <map>
#include <set>
#include <math.h>
using namespace std;
#define ll int
#define inf 1000000007
#define N 16
int dis[N][N], n, m;
void floyd(){
	for(ll k = 0; k < n; k++)
		for(ll i = 0; i < n; i++)
			for(ll j = 0; j < n; j++)
				dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j]);
	for(ll i = 0; i < n; i++)dis[i][i] = 0;
}
int du[N], ans, dp[1<<N];//dp[i] 表示i状态移动
ll work(){
	ll i, j, k;
	for(i = 1; i < n; i++)
		if(du[i] && dis[0][i]==inf)return -1;

	ll all = (1<<n)-1;
	for(i = 0; i <= all; i++)	dp[i] = inf;
	dp[0] = 0;
	for(k = 0; k <= all; k++) 
	{
		for(i = 0; i < n; i++) //如果i这个点有边连接，但点0又走不到这个点，说明和这个点相连的边是走不到的，即图不连通
			if((du[i]&1) && (k&(1<<i)))break;
		if(i==n)dp[k] = 0;
		for(i = 0; i < n; i++)
			if((du[i]&1) && !(k&(1<<i)))
				for(j = i+1; j < n; j++)
					if((du[j]&1) && !(k&(1<<j)) && dis[i][j]<inf)
						dp[k|(1<<i)|(1<<j)] = min(dp[k|(1<<i)|(1<<j)],dp[k]+dis[i][j]);
	}
	if(dp[all]>=inf)return -1;
	return ans + dp[all];
}
int main(){
	ll i, j, u, v, w;
	while(cin>>n>>m){
		for(i=0;i<n;i++)for(j=0;j<n;j++)dis[i][j] = inf;
		memset(du, 0, sizeof du);
		ans = 0;
		while(m--){
			cin>>u>>v>>w; u--; v--;
			dis[u][v] = dis[v][u] = min(dis[u][v], w);
			du[u]++; du[v]++;
			ans += w;
		}
		floyd();
		cout<<work()<<endl;
	}
	return 0;
}
	 		 		  			    	 	  	