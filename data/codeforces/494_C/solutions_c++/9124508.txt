#include<cstdio>
#include<algorithm>
#include<cmath>
#define N 100005
#define M 5005
using namespace std;
struct arr{int l,r;double p;}a[M];
int f[N][18],mx[N],used[N],n,i,j,T,m,k;
double ans[M][M],tmp[M],ANS;
inline int ask(int x,int y)
{
  int len=(int)log2(y-x+1);
  return max(f[x][len],f[y-(1<<len)+1][len]);
}
inline int cmp(const arr &a,const arr &b){return a.r-a.l<b.r-b.l;}
int main()
{
  scanf("%d%d",&n,&m);
  for (i=1;i<=n;i++) scanf("%d",&f[i][0]);
  for (j=1;j<=17;j++)
    for (i=1;i<=n;i++)
      T=i+(1<<(j-1)),f[i][j]=max(f[i][j-1],(T<=n)?f[T][j-1]:0);
  for (i=1;i<=m;i++)
    scanf("%d%d%lf",&a[i].l,&a[i].r,&a[i].p);
  a[++m]=(arr){1,n,0};
  sort(a+1,a+m+1,cmp);
  for (i=1;i<=m;i++)
  {
    mx[i]=ask(a[i].l,a[i].r);
    for (k=0;k<=m;k++) tmp[k]=1.0;
    for (j=1;j<i;j++) 
      if (a[j].l>=a[i].l&&a[j].r<=a[i].r&&!used[j])
      {
        used[j]=1;
        for (k=0;k<=m;k++)
          if (mx[i]+k-mx[j]<=m) tmp[k]*=ans[j][mx[i]+k-mx[j]];
      }
    for (k=m;k;k--) 
      tmp[k]-=tmp[k-1];
    ans[i][0]=(1-a[i].p)*tmp[0];
    for (k=1;k<=m;k++) 
      ans[i][k]=ans[i][k-1]+tmp[k-1]*a[i].p+tmp[k]*(1-a[i].p);
    //ans[i][k-1]:加上k-1的期望(ans[i]实质是前缀和性质) 
    //tmp[k-1]*p[i]:由子树中得最大加k-1，且当前也加
    //tmp[k]*(1-p[i]): 由子树中得最大加k,且当前不加
  } 
  ANS=ans[m][0]*mx[m];
  for (i=1;i<=m;i++)
    ANS+=(ans[m][i]-ans[m][i-1])*(mx[m]+i);
  printf("%.10lf",ANS);
}
