#include<cstdio>
#include<iostream>
#include<vector>
#include<algorithm>
#include<cstring>
#include<cmath>
#define mod 1000000007
using namespace std;
int a[100005];
int n,q;
struct node
{
    int l,r;
    double p;
    node(int l=0,int r=0,double p=0):l(l),r(r),p(p) {}
    bool operator < (const node& a) const
    {
        if(l==a.l) return r>a.r;
        else return l<a.l;
    }
};
node f[5006];
vector<int> G[5006];
int dp[100005][20];
double pr[5006][5006];
int rmq()
{
    for(int i=1;i<=n;i++) dp[i][0]=a[i];
    for(int j=1;(1<<j)<=n;j++)
    for(int i=1;i+(1<<j)-1<=n;i++)
    dp[i][j]=max(dp[i][j-1],dp[i+(1<<(j-1))][j-1]);
}
int query(int L,int R)
{
    int k=0;
    while((1<<(k+1))<=R-L+1) k++;
    return max(dp[L][k],dp[R-(1<<k)+1][k]);
}
void dfs(int u)
{
    int mu=query(f[u].l,f[u].r);
    double pp=f[u].p;
    double t1[5007];
    for(int i=0;i<5002;i++) t1[i]=1;
    for(int i=0;i<G[u].size();i++)
    {
        int v=G[u][i];
        int mv=query(f[v].l,f[v].r);
        dfs(v);
        for(int j=0;j<=q;j++)
        {
            if(mu+j-mv>=q) continue;
            if(mu+j-mv>=0)
            t1[j]*=pr[v][mu+j-mv];
            else
            t1[j]=0;
        }
    }
    for(int i=1;i<=q;i++)
    pr[u][i]=(1-pp)*t1[i]+pp*t1[i-1];
    pr[u][0]=(1-pp)*t1[0];
}
main()
{
    scanf("%d%d",&n,&q);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int i=0;i<q;i++)
    scanf("%d%d%lf",&f[i].l,&f[i].r,&f[i].p);
    f[q]=node(1,n,0);
    sort(f,f+q+1);
    rmq();
    for(int i=1;i<=q;i++)
    for(int j=i-1;j>=0;j--)
    if(f[j].l<=f[i].l&&f[j].r>=f[i].r)
    {
        G[j].push_back(i);
        break;
    }
    dfs(0);
    double ans=0;
    int m0=query(1,n);
    for(int i=1;i<=q;i++)
    ans+=(pr[0][i]-pr[0][i-1])*(m0+i);
    ans+=pr[0][0]*m0;
    printf("%.8f\n",ans);
}
