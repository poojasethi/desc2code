#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<vector>
#define pb push_back
#define N 100100
#define QN 5010
using namespace std;
struct query{int l, r; double c;}Q[QN];
int f[N][18], A[N], Koe[N], fa[QN], mx[QN], n, q, i, j, k;
double a[QN][QN], ans;
vector<int> G[QN];
bool cmp(query a, query b)
{
    return (a.l == b.l ? a.r > b.r : a.l < b.l);
}
int Getfa(int x, int pre)
{
    fa[x] = pre;
    for (int i = x + 1; i <= q; i = Getfa(i, x))
        if (Q[i].l > Q[x].r) return i;
    return q + 1;
}
int Query(int l, int r)
{
    int x = Koe[r - l + 1];
    return max(f[l][x], f[r - (1 << x) + 1][x]);
}
void Pre()
{
    for (i = 1; i <= n; i++) f[i][0] = A[i];
    for (i = 1; i <= n; i++)
    {
        if (i == (1 << k)) k++;
        Koe[i] = k - 1;
    }
    for (i = 1; i <= 17; i++)
        for (j = 1; j + (1 << i) - 1 <= n; j++)
           f[j][i] = max(f[j][i - 1], f[j + (1 << (i - 1))][i - 1]);
    Q[++q] = (query){1, n, 0};
    sort(Q + 1, Q + q + 1, cmp);
    Getfa(1, 0);
    for (i = 1; i <= q; i++) G[fa[i]].pb(i);
    for (i = 1; i <= q; i++)
        mx[i] = Query(Q[i].l, Q[i].r);
}
double F(int x, int y)
{
    if (y < 0) return 0;
    if (y > q) return 1;
    if (a[x][y] >= 0) return a[x][y];
    int s = G[x].size(), i;
    double A1 = Q[x].c, A2 = 1 - Q[x].c;
    if (!y) A1 = 0;
    for (i = 0; i < s; i++)
    {
        int v = G[x][i];
        A1 *= F(v, mx[x] - mx[v] + y - 1);
        A2 *= F(v, mx[x] - mx[v] + y);
    }
    a[x][y] = A1 + A2;
    return a[x][y];
}
void Work()
{
    for (i = 0; i <= q; i++) 
        ans += (mx[1] + i) * (F(1, i) - F(1, i - 1));
    printf("%.8lf\n", ans);
}
int main()
{
    memset(a, -1, sizeof(a));
    scanf("%d%d", &n, &q);
    for (i = 1; i <= n; i++) scanf("%d", &A[i]);
    for (i = 1; i <= q; i++)
        scanf("%d%d%lf", &Q[i].l, &Q[i].r, &Q[i].c);
    Pre();
    Work();
    return 0;
}