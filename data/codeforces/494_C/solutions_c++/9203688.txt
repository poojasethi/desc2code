#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<vector>
#define N 200005
#define M 5006
#define LL long long
#define oo (1<<30)
using namespace std;
double f[M][M],ans=0; vector<int> G[M];
int n,q,a[N],st[18][N],mx[M]; bool g[M][M];
struct ran{ int l,r; double p; }A[M];
void prepare()
{
    int i,j;
    for(i=1;i<18;i++)
        for(j=1;j<=n;j++)
            st[i][j]=max(st[i-1][j],st[i-1][j+(1<<(i-1))]);
}
int RMQ(int l,int r)
{
    int t=(int)(log2(r-l+1));
    return max(st[t][l],st[t][r-(1<<t)+1]);
}
bool cmp(ran p,ran q){ return p.l<q.l||(p.l==q.l&&p.r>q.r);}
void build(int ll,int rr)
{
    int i,p=ll+1;
    if(ll==rr) return ;
    for(i=ll+1;i<=rr+1;i++)
        if(A[p].r<A[i].l||i>rr){
            G[ll].push_back(p);
            build(p,i-1),p=i;
          }
}
double dp(int t,int s)
{
  int i; if(s<0) return 0;
    double s1=A[t].p,s2=1-s1;
    if(s>q) return 1;
    if(g[t][s]) return f[t][s];
    for(i=0;i<G[t].size();i++){
        s1*=dp(G[t][i],mx[t]+s-mx[G[t][i]]-1);
        s2*=dp(G[t][i],mx[t]+s-mx[G[t][i]]);
      }
    if(s==0) s1=0;
    f[t][s]=s1+s2,g[t][s]=1;
    return f[t][s];
}
int main()
{
    int i;
    scanf("%d %d",&n,&q);
    memset(st,128,sizeof(st));
    for(i=1;i<=n;i++)
        scanf("%d",&a[i]),st[0][i]=a[i];
    prepare();
    for(i=1;i<=q;i++)
        scanf("%d %d %lf",&A[i].l,&A[i].r,&A[i].p);
    sort(A+1,A+q+1,cmp);
    A[0]=(ran){1,n,0};
    build(0,q);
    for(i=0;i<=q;i++)
        mx[i]=RMQ(A[i].l,A[i].r);
    for(i=0;i<=q;i++)
        ans+=(dp(0,i)-dp(0,i-1))*(mx[0]+i);
    printf("%.9lf",ans);
    return 0;
}
