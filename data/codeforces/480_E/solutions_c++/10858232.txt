#include<bits/stdc++.h>

using namespace std;

#define foreach(i, x)  for(type(x) i=x.begin() ; i != x.end() ; i++)
#define FOR(ii, aa, bb) for(int ii = aa ; ii <= bb ; ii++)
#define ROF(ii, aa, bb) for(int ii = aa ; ii >= bb ; ii--)

#define type(x) __typeof(x.begin())

#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair< int, int > pii;

typedef long long ll;
 
const int mod  = 1e9+7;
const ll  linf = 1e18;
const int inf  = 1e9;
const int N = 2e3+5;
const int logN = 10;

int LOG[N], i, j, k, n, m, b[N], ans[N], up[N][N], down[N][N], rmq1[N][logN+1], rmq2[N][logN+1];

char arr[N][N];

pii a[N];

void init(int x){
	
	FOR(i,1,n) up[i][x]   = ((arr[i][x] == 'X') ? i : up[i-1][x]);

	ROF(i,n,1) down[i][x] = ((arr[i][x] == 'X') ? i : down[i+1][x]);

}

int query(int x,int y){
	
	int t = LOG[y-x+1];
	
	int up = max(rmq1[x][t], rmq1[y-(1<<t)+1][t]);
	
	int down = min(rmq2[x][t], rmq2[y-(1<<t)+1][t]);

	return down - up - 1;

}

int calc(int i){
	
	FOR(j,1,m) rmq1[j][0] = up[i][j];
	
	FOR(j,1,m) rmq2[j][0] = down[i][j];
	
	FOR(k,1,logN) FOR(j,1,m) rmq1[j][k] = max(rmq1[j][k-1], rmq1[min(j+(1<<k-1),m)][k-1]);
	
	FOR(k,1,logN) FOR(j,1,m) rmq2[j][k] = min(rmq2[j][k-1], rmq2[min(j+(1<<k-1),m)][k-1]);
	
	int ans = 0, k = 1; 

	FOR(j,1,m){

		k = max(k, j);
		
		while(k < m && query(j,k+1) >= k+1-j+1) k++;
		
		ans = max(ans, min(k-j+1, query(j,k)));

	} 
	
	return ans;
}

int main(){
	
	scanf("%d %d %d",&n,&m,&k);
	
	FOR(i,1,n) FOR(j,1,m) scanf(" %c",&arr[i][j]);
	
	FOR(i,1,k){ scanf("%d %d",&a[i].st,&a[i].nd); arr[a[i].st][a[i].nd] = 'X'; }
	
	FOR(i,1,m) down[n+1][i] = n+1;
	
	FOR(i,1,m) init(i);
	
	FOR(i,1,N-1) LOG[i] = log2(i); 
	
	FOR(i,1,n) ans[k] = max(ans[k], calc(i));
	
	ROF(i,k-1,1){ 
		
		arr[a[i+1].st][a[i+1].nd] = '.'; init(a[i+1].nd);
	
		ans[i] = max(ans[i+1], calc(a[i+1].st));  

	}

	FOR(i,1,k) printf("%d\n",ans[i]);
	return 0;
}
