#include <cstdio>
#include <queue>
#include <algorithm>
#include <cassert>
#include <vector>
#include <set>
#define fru(j,n) for(int j=1;j<=n;++j)
#define tr(it,x) for(typeof(x.begin())it=x.begin();it!=x.end();++it)
#define x first
#define y second

using namespace std;
typedef pair<int,int> pii;
const int MAXN = 2005;

char S[MAXN][MAXN];
set<int> SET[MAXN];
int ret,n,m;
pii zap[MAXN];
int GG[MAXN][MAXN],DD[MAXN][MAXN];

struct okienko{
	int czas,d;
	okienko(int dlug){czas=0,d=dlug;}
	deque<pii> R;
	int add(int a){
		++czas;
		while(!R.empty() && R.back().x>=a) R.pop_back();
		R.push_back(pii(a,czas));
		if(R.front().y+d<=czas) R.pop_front();
		return R.front().x;
	}
};

bool jest_kwadrat(int poziom,int bok){
#define G GG[poziom]
#define D DD[poziom]
	if(bok>min(n,m)) return 0;
	//	printf("G:\n"); fru(i,m) printf("%d ",G[i]); printf("\n");
	//	printf("D:\n"); fru(i,m) printf("%d ",D[i]); printf("\n");
	okienko GORA(bok),DOL(bok);
	fru(i,bok-1) GORA.add(G[i]);
	fru(i,bok-1) DOL.add(D[i]);
	for(int i=bok;i<=m;++i) if(DOL.add(D[i])+GORA.add(G[i])>=bok) return 1;
	return 0;
}
int ans[MAXN];
int SP[MAXN][MAXN];
bool jest(int bok){
	bok--;
	fru(i,n-bok) fru(j,m-bok) if(SP[i+bok][j+bok]-SP[i-1][j+bok]-SP[i+bok][j-1]+SP[i-1][j-1]==0) return 1;
	return 0;
}
void gora(int i,int j){
	if(i==1) GG[i][j]=S[i][j]=='.'?1:0;
	else GG[i][j]=S[i][j]=='X'?0:1+GG[i-1][j];
}
void dol(int i,int j){
	if(i!=n) DD[i][j]=S[i+1][j]=='X'?0:1+DD[i+1][j];
}
int main()
{
	int k;
	scanf("%d%d%d",&n,&m,&k);
	fru(i,n) scanf("%s",S[i]+1);
	fru(i,k) scanf("%d%d",&zap[i].x,&zap[i].y);
	fru(i,k) S[zap[i].x][zap[i].y]='X';
	fru(i,n) fru(j,m) SP[i][j]=	(SP[i-1][j]+SP[i][j-1]-SP[i-1][j-1]+(S[i][j]=='X'));
	fru(i,n) fru(j,m) gora(i,j);
	for(int i=n-1;i>=0;--i) fru(j,m) dol(i,j);
	fru(i,n) while(jest_kwadrat(i,ret+1)) ++ret;
	for(int q=k;q>0;--q){
		ans[q]=ret;
		int x=zap[q].x,y=zap[q].y;
		S[x][y]='.';
		fru(i,n) gora(i,y);
		for(int i=n-1;i>=0;--i) dol(i,y);
		while(jest_kwadrat(x,ret+1)) ++ret;
	}
	fru(i,k) printf("%d\n",ans[i]);
	return 0; 
}
