#include <cstdio>
#include <algorithm>
#include <cassert>
#include <vector>
#include <set>
#define fru(j,n) for(int j=1;j<=n;++j)
#define tr(it,x) for(typeof(x.begin())it=x.begin();it!=x.end();++it)
#define x first
#define y second

using namespace std;
typedef pair<int,int> pii;
const int MAXN = 2005;

char S[MAXN][MAXN];
set<int> SET[MAXN];
int G[MAXN],D[MAXN],ret,n,m;
pii zap[MAXN];
bool jest_kwadrat(int bok){
	if(bok>min(n,m)) return 0;
	//	printf("G:\n"); fru(i,m) printf("%d ",G[i]); printf("\n");
	//	printf("D:\n"); fru(i,m) printf("%d ",D[i]); printf("\n");

	multiset<int> MG,MD;
	fru(i,bok) MG.insert(G[i]);
	fru(i,bok) MD.insert(D[i]);
	if(*MD.begin() + *MG.begin()>=bok) return 1;
	for(int i=bok+1;i<=m;++i){
		MD.erase(MD.find(D[i-bok]));
		MG.erase(MG.find(G[i-bok]));
		MD.insert(D[i]);
		MG.insert(G[i]);
		if(*MD.begin() + *MG.begin()>=bok) return 1;
	}

	return 0;
}
int ans[MAXN];
int SP[MAXN][MAXN];
bool jest(int bok){
	bok--;
	fru(i,n-bok) fru(j,m-bok) if(SP[i+bok][j+bok]-SP[i-1][j+bok]-SP[i+bok][j-1]+SP[i-1][j-1]==0) return 1;
	return 0;
}

int main()
{
	int k;
	scanf("%d%d%d",&n,&m,&k);
	fru(i,n) scanf("%s",S[i]+1);
	fru(i,k) scanf("%d%d",&zap[i].x,&zap[i].y);
	fru(i,k) S[zap[i].x][zap[i].y]='X';
	fru(i,n) fru(j,m) SP[i][j]=	(SP[i-1][j]+SP[i][j-1]-SP[i-1][j-1]+(S[i][j]=='X'));
	int kon=min(n,m)+1;
	while(ret+1<kon){
		int med=(ret+kon)/2;
		if(jest(med)) ret=med;
		else kon=med;
	}
	fru(i,m) SET[i].insert(0),SET[i].insert(n+1);
	fru(i,n) fru(j,m) if(S[i][j]=='X') SET[j].insert(i);

	for(int q=k;q>0;--q){
		ans[q]=ret;
		int x=zap[q].x,y=zap[q].y;
		SET[y].erase(x);
		fru(i,m) {
			typeof(SET[i].begin()) it=SET[i].lower_bound(x);
			if(*it>x) --it;
			G[i]=x-*it;
			++it;
			D[i]=*it-x-1;
		}
		while(jest_kwadrat(ret+1)) ++ret;
	}
	fru(i,k) printf("%d\n",ans[i]);
	return 0; 
}
