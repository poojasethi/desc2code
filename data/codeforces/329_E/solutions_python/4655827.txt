import sys

n = int(raw_input())
coordinates = []
xs = []
ys = []
for i in range(n):
  x, y = map(int, raw_input().split())
  coordinates.append(((x, i), (y, i)))
  xs.append((x, i))
  ys.append((y, i))

xs = sorted(xs)
ys = sorted(ys)

amt = [[0] * 2 for _ in range(2)]

medians = 0

for x, y in coordinates:
  if n % 2 and x == xs[n/2]:
    # median
    medians += 1
    continue
  if n % 2 and y == ys[n/2]:
    # median
    medians += 1
    continue
  amt[x < xs[n/2]][y < ys[n/2]] += 1

def CalcuHalf(arr):
  res = 0
  for a, _ in arr[len(arr)/2:]:
    res += a
  for a, _ in arr[:len(arr)/2]:
    res -= a
  return res

def PossibleAll():
  def CalculateMax(arr):
    woot = arr + arr
    woot = sorted(woot)
    return CalcuHalf(woot)
  print CalculateMax(xs) + CalculateMax(ys)
  sys.exit(0)

if amt[0][0] + amt[1][1] == 0 or amt[1][0] + amt[0][1] == 0:
  PossibleAll()
if medians == 2:
  PossibleAll()
if medians == 0:
  def Proc(arr):
    zs = sorted(arr + arr)
    zs[n-1], zs[n] = zs[n], zs[n-1]
    return CalcuHalf(zs)
  print max([Proc(xs) + CalcuHalf(sorted(ys+ys)),
             Proc(ys) + CalcuHalf(sorted(xs+xs))])
else:
  def Proc(arr):
    zs = sorted(arr + arr)
    zs[n-2], zs[n] = zs[n], zs[n-2]
    az = sorted(arr + arr)
    az[n-1], az[n+1] = az[n+1], az[n-1]
    return max([CalcuHalf(zs), CalcuHalf(az)])
  print max([Proc(xs) + CalcuHalf(sorted(ys+ys)),
             Proc(ys) + CalcuHalf(sorted(xs+xs))])