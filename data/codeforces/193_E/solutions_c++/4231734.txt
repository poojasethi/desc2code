#include<cstdio>
#include<cstring>
#include<algorithm>
#define lim 10000000000000LL
using namespace std;
struct matrix
{	long long num[5][5];
	matrix()
	{	memset(num,0,sizeof(num));
	}
};
matrix ft,unit;
long long next[1505];
long long cur[1505];
long long f[1505];
long long n;
long long mul(long long a,long long b)
{	long long p=(long double)a*b/lim;
	long long r=a*b-lim*p;
	if (r<0)
		r+=lim;
	return r;
}
matrix operator *(matrix& a,matrix& b)
{	long long i,j,k;
	matrix c;
	for (i=1;i<=2;++i)
		for (j=1;j<=2;++j)
			for (k=1;k<=2;++k)
			{	c.num[i][j]+=mul(a.num[i][k],b.num[k][j]);
				c.num[i][j]%=lim;
			}
	return c;
}
matrix qp(matrix b,long long e)
{	matrix ans,t;
	t=b,ans=unit;
	while (e)
	{	if (e&1)
			ans=ans*t;
		t=t*t;
		e>>=1;
	}
	return ans;
}
long long fib(long long n)
{	matrix f;
	if (n==0)
		return 0;
	if (n==1)
		return 1;
	f=qp(ft,n);
	return f.num[1][2]%lim;
}
long long work()
{	if (n==0)
		return 0;
	if (n==1)
		return 1;
	long long cnt,cnt1,i,j,k,cycle;
	cnt=0;
	f[0]=0,f[1]=1;
	for (i=2;i<1500;++i)
		f[i]=(f[i-1]+f[i-2])%lim;
	for (i=0;i<1500;++i)
		if (f[i]%1000==n%1000)
			cur[++cnt]=i;
	cycle=1500;
	for (i=10000;i<=lim;i*=10,cycle*=10)
	{	cnt1=0;
		for (j=0;j<=9;++j)
			for (k=1;k<=cnt;++k)
			{	long long t=fib(cycle*j+cur[k]);
				if (t%i==n%i)
					next[++cnt1]=cycle*j+cur[k];
			}
		cnt=cnt1;
		swap(cur,next);
	}
	if (cnt==0)
		return -1;
	return cur[1];
}
int main()
{	scanf("%I64d",&n);
	unit.num[1][1]=unit.num[2][2]=1;
	ft.num[1][2]=ft.num[2][1]=ft.num[2][2]=1;
	printf("%I64d\n",work());
	return 0;
}
	 					 	 	  	 		 	  	  	