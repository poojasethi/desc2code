#include<stdio.h>
#include<algorithm>
#include<deque>
using namespace std;
typedef long long ll;
const ll MOD=1e13;
ll x;
inline ll mul(ll a,ll b)
{
	ll ret=0;
	for(;b;b>>=(ll)1,a=a+a>=MOD?a+a-MOD:a+a)if(b&(ll)1)ret=ret+a>=MOD?ret+a-MOD:ret+a;
	return ret;
}
struct mat
{
	ll x11,x12,x21,x22;
	mat():x11(1),x12(0),x21(0),x22(1){}
	inline mat(ll _x11,ll _x12,ll _x21,ll _x22):x11(_x11),x12(_x12),x21(_x21),x22(_x22){}
	inline mat operator * (const mat &k2) const {return mat((mul(x11,k2.x11)+mul(x12,k2.x21))%MOD,(mul(x11,k2.x12)+mul(x12,k2.x22))%MOD,(mul(x21,k2.x11)+mul(x22,k2.x21))%MOD,(mul(x21,k2.x12)+mul(x22,k2.x22))%MOD);}
};
typedef pair<ll,ll> pll;
inline pll operator * (const mat &m,const pll &v){return make_pair((mul(m.x11,v.first)+mul(m.x12,v.second))%MOD,(mul(m.x21,v.first)+mul(m.x22,v.second))%MOD);}
mat step[20];
ll pow[20];
ll period[20];
int gap[20];
pll gen;
typedef pair<ll,pll> State;
typedef deque<State> deq;
typedef deq::iterator iter;
deq Q1,Q2;
#define pb push_back
#define mp make_pair
int main()
{
	scanf("%I64d",&x);
	step[0]=mat(0,1,1,1);
	pow[0]=1;for(int i=1;i<=13;i++)pow[i]=pow[i-1]*10;
	period[0]=1;
	gen=mp(0,1);
	for(int i=1;i<=13;i++)
	{
		pll t=gen;
		for(;;)
		{
			t=step[i-1]*t;
			period[i]+=period[i-1];
			gap[i-1]++;
			step[i]=step[i-1]*step[i];
			if((t.first-gen.first)%pow[i]==0&&(t.second-gen.second)%pow[i]==0)break;
		}
	}
	Q1.pb(mp(1,mp(0,1)));
	for(int i=1;i<=13;i++)
	{
		for(iter i=Q1.begin();i!=Q1.end();i++)if(i->second.second%MOD==x)return printf("%I64d\n",i->first),0;
		mat t;
		ll len=0;
		for(int j=0;j<gap[i-1];j++)
		{
			for(iter p=Q1.begin();p!=Q1.end();p++)
			{
				State ns=mp(p->first+len,t*p->second);
				if((ns.second.second-x)%pow[i]==0)Q2.pb(ns);
			}
			t=step[i-1]*t,len+=period[i-1];
		}
		Q1=Q2;
		Q2.clear();
	}
	for(iter i=Q1.begin();i!=Q1.end();i++)if(i->second.second%MOD==x)return printf("%I64d\n",i->first),0;
	puts("-1");
	return 0;
}
