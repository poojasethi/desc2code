#include  <bits/stdc++.h>
#define  i64  long long
#define  PB push_back
#define  MP make_pair
using  namespace  std;

vector<i64>  d;
int  f[2000];
i64  F,A[2][2][2],B[2][2];

i64  mul(i64  x,i64  y,i64  M){
	i64  res = 0;
	for  (; y; y >>= 1){
		if  (y&1){
			res += x;
			if  (res >= M)  res -=M;
		}
		x += x;
		if  (x >= M)  x -= M;
	}
	return  res;
}

void  work(i64  K,vector<i64>  &e,i64  M){
	if  (!K){
		if  (F % M == 0)  e.PB(0);
		return;
	}
	i64  tmp = K;
	K--;
	memset(A,0,sizeof(A));
	memset(B,0,sizeof(B));
	A[0][0][1] = A[0][1][0] = A[0][1][1] = 1;
	B[0][1] = 1;
	int  now = 0;
	for  (; K; K >>= 1,now ^= 1){
		memset(B[now^1],0,sizeof(B[now^1]));
		memset(A[now^1],0,sizeof(A[now^1]));
		if  (K&1){
			for  (int  i = 0;i < 2; i++)
				for  (int  j = 0;j < 2; j++){
					B[now^1][i] += mul(A[now][i][j],B[now][j],M);
					if  (B[now^1][i] >= M)  B[now^1][i] -= M;
				}
		}
		else  B[now^1][0] = B[now][0],B[now^1][1] = B[now][1];
		for  (int  i = 0;i < 2; i++)
			for  (int  j = 0;j < 2; j++)
				for  (int  k = 0;k < 2; k++){
					A[now^1][i][k] += mul(A[now][i][j],A[now][j][k],M);
					if  (A[now^1][i][k] >= M)  A[now^1][i][k] -= M;
				}
	}
	if  (B[now][1] == F % M)  e.PB(tmp);
}

int  main(){
	scanf("%I64d",&F);//
	f[0] = 0;f[1] = 1;
	if  (F % 1000 == 0)  d.PB(0);
	if  (F % 1000 == 1)  d.PB(1);
	for  (int  i = 2;i < 1500; i++){
		f[i] = (f[i-1] + f[i-2])%1000;
		if  (f[i] == F % 1000)  d.PB(i);
	}
	i64  M = 1000,MAX = 10000000000000LL;
	for  (;M < MAX && d.size() > 0;M *= 10){
		vector<i64>  e;
		for  (int  j = 0;j < 10; j++)
			for  (int  i = 0,ed = d.size();i < ed; i++)
				work(d[i]+M*j*3/2,e,M*10);
		d = e;
	}
	if  (d.size() == 0)  puts("-1");
	else  printf("%I64d\n",d[0]);//
    return 0;
}

 	  	 	   	  	  				  	 		   	