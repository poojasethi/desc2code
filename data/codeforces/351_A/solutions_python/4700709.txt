import sys
import os
#input.txt & output.txt
PARA_FROM_STD = True
IN_FILE = 'input.txt'
OUT_FILE = 'output.txt'

#--------- classic ---------
def gcd(a, b):
    #Greatest common divisor
    if a < b:
        return gcd(b, a)
    if b == 0:
        return a
    return gcd(b, a % b)

#Least common multiplie
lcm = lambda a, b: a * b / gcd(a, b)
#Fast pow
def fastPow(x, y):
    res = 1
    while y:
        if (y & 1):
            res *= x
        y = y >> 1
        if y == 0:
            break
        x *= x
    return res
    

#-------- data reading --------
read_int = lambda: int(datum.readline())
read_ints = lambda : map(int, datum.readline().split())
read_floats = lambda : map(float, datum.readline().split())
def read_ints_index(sort_reverse = True):
    dat = read_ints()
    x = []
    for _ in enumerate(dat):
        x.append(list(_))
    x.sort(reverse = sort_reverse, key = lambda x: x[1])
    return x

def read_intsN(n):
    res = []
    for _ in xrange(n):
        res.append(map(int, datum.readline().split()))
    return res

#read_words?
read_strs = lambda : map(str, datum.readline().split())
read_str = lambda: datum.readline().replace('\n', '').replace('\r', '')
#---------- graphs ----------



#----------- hat -----------
if len(sys.argv) > 1:
    datum = open(sys.argv[1], 'r')
else:
    datum = sys.stdin
#----------- dbg -----------
if os.environ.get('codeforces_debug', False):
    debug_mode = True
else:
    debug_mode = False

if debug_mode:
    def toStr(was):
        return '\n'.join(map(str, was))
    
    try:
        import colorama
        colorama.init()
        def dbg(*was):
            txt = str(was)
            print '\x1b[32;1m%s\x1b[0m' % toStr(was) # style ->> 32;1
            #print(colorama.Fore.GREEN + colorama.Fore. + txt + colorama.Style.RESET_ALL)
    except:
        def dbg(*was):
            print 'Debug:\t' + toStr(was)
else:
    def dbg(*was):
        pass


#----------------------------
def big(x):
    intt = int(x)
    if intt == x:
        return intt
    else:
        return intt+1
def small(x):
    intt = int(x)
    if intt == x:
        return intt
    else:
        return intt
def calc(data1, data2):
    summ1 = sum(data1) + sum(data2)
    data1 = map(big, data1)
    data2 = map(small, data2)
    summ2 = sum(data1) + sum(data2)
    return abs(summ1-summ2)
    
#----------- data -----------
'''
"10" => read_int()
"10 20 30" => read_ints()
"10 20 30
40 5 17" => read_intsN(2)
'''
if False:
    
    data = [4469.000, 6526.000, 4864.000, 9356.383, 7490.000, 995.896]
    data = [0.000, 0.500, 0.750, 1.000, 2.000, 3.000]
    data = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]
    data = [10.002, 20.001, 0.5, 0.55, 0.99, 0.88]
    print calc(data[:3], data[3:])
    print calc(data[3:], data[:3])
    print calc([data[0], data[1], data[4]], [data[2], data[3], data[5]])
    print calc([data[2], data[3], data[5]], [data[0], data[1], data[4]])
    print data
else:
    n = read_int()
    data = read_floats()

    cnt = 0
    data2 = []
    for x in data:
        intx = int(x)
        
        if intx == x:
            cnt += 1

        data2.append(intx)

    cnt2 = len(data) - cnt
    dbg("cnt = " + str(cnt) + " cnt2 = " + str(cnt2))

    if cnt2 % 2 == 0:
        from_ = cnt2/2 - cnt/2
        to_ = cnt2/2 + cnt/2
    else:
        if cnt >= cnt2:
            from_ = 0
            to_ = cnt2
        else:
            from_ = cnt2/2 - cnt/2
            to_ = cnt2 - from_
    
    need = int(round(sum(data)-sum(data2), 0))
    dbg(from_, to_, need)
    if need > to_:
        need = to_
    elif need < from_:
        need = from_
    
    res = abs(sum(data) - sum(data2)-need)
    print "%.3f" % res
    

#---------- solve ----------
#----------- end -----------
#dbg(vals)
dbg("cya")
