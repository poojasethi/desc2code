#include <iostream>
#include <iomanip>
#include <stdio.h>
#include <set>
#include <vector>
#include <map>
#include <cmath>
#include <algorithm>
#include <memory.h>
#include <string>
#include <sstream>
#include <cstdlib>
#include <ctime>
#include <cassert>

using namespace std;

typedef long long LL;
typedef pair<int,int> PII;

#define MP make_pair
#define PB push_back
#define FF first
#define SS second

#define FORN(i, n) for (int i = 0; i <  (int)(n); i++)
#define FOR1(i, n) for (int i = 1; i <= (int)(n); i++)
#define FORD(i, n) for (int i = (int)(n) - 1; i >= 0; i--)
#define FOREACH(i, c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

#define MOD 1000000007
#define INF 2000000000

const int MAXA = 1000010;
LL inv[MAXA], coeff[MAXA], comb[MAXA], cnt[MAXA], res;

int n, k, q, a;

void add(LL& x, LL y) {
    x += y;
    if (x >= MOD) x -= MOD;
}

void sub(LL& x, LL y) {
    x -= y;
    if (x < 0) x += MOD;
}

LL mul(LL x, LL y) {
    return (1LL * x * y) % MOD;
}

void update(int idx) {
    cnt[idx]++; LL newcomb;  // (c-1 choose k) -> (c choose k)

    if (cnt[idx] < k) {
        return;
    }
    else if (cnt[idx] == k) {
        newcomb = coeff[idx];
    }
    else {
        newcomb = mul(mul(comb[idx], cnt[idx]), inv[cnt[idx]-k]);
    }

    add(res, (newcomb - comb[idx] + MOD) % MOD);
    comb[idx] = newcomb;
}

int main() {
    inv[1] = 1; for (int i = 2; i < MAXA; i++) inv[i] = (MOD - (MOD/i) * inv[MOD%i] % MOD) % MOD;

    scanf("%d%d%d", &n, &k, &q);

    memset(coeff, 0, sizeof coeff);

    FOR1(i, MAXA-1) {
        add(coeff[i], i);
        for (int j = 2 * i; j < MAXA; j += i) sub(coeff[j], coeff[i]);
    }

    memset(comb, 0, sizeof comb); memset(cnt, 0, sizeof cnt); res = 0;

    FORN(i, n+q) {
        scanf("%d", &a);

        for (int j = 1; j * j <= a; j++) {
            if (a % j == 0) {
                update(j);
                if (j * j < a) update(a / j);
            }
        }

        if (i >= n) printf("%I64d\n", res);
    }

    return 0;
}
