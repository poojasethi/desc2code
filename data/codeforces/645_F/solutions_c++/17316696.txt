#include <stdio.h>
#include <string>
#include <string.h>
#include <queue>
#include <stack>
#include <map>
#include <iostream>
#include <stdlib.h>
#include <math.h>
#include <set>
#include <algorithm>
#define inf 0x3f3f3f3f
#define mem0(x , y)  memset(x , y , sizeof(x))
#define ll long long
#define REP(x , y)   for(int i=0;i<y;i++)
#define FOR(x , y)   for(int i=1;i<y;i++)
#define lowbit(x) (x & (-x))
#define read(x) scanf("%d",&x)
using namespace std ;
const int MOD = 1e9+7 ;
const int MAX = 1000050 ;
const int MAXN = 200050 ;
vector <int> divisor[MAX] ; /// 可以再nlgn内求出一切的预处理,就是用筛数法.
int n ,m ,k;
ll phi[MAX] ;
ll c[MAXN] ;
int use[MAX];
int num[MAX] ;
int A[MAXN];
ll qpow(ll a,ll b){
    if(b == 0) return 1 ;
    ll tmp = qpow(a , b/2) ;
    tmp = (tmp * tmp) % MOD ;
    if(b & 1){
        return a * tmp % MOD ;
    }
    return tmp % MOD ;
}
int precalu(){
    int i , j ;
    for(i=0;i<MAX;i++) phi[i] = i ;
    for(i=1;i<MAX;i++){
        for(j=i;j<MAX;j+=i){
            if(i != j) phi[j] -= phi[i] ;
            if(use[j]) {
                divisor[j].push_back(i) ;
            }
        }
    }
    c[k] = 1 ;
    for(i=k+1;i<MAXN ; i++){
        c[i] = c[i-1] * (i) % MOD * qpow(i-k , MOD - 2) % MOD ;
        c[i] %= MOD ;
    }
}
ll ans = 0 ;
int main(){
    mem0(A , 0) ;
    mem0(num , 0) ;
    mem0(use , 0) ;
    scanf("%d%d%d",&n,&k,&m) ;
    int i , j ;
    for(i = 1 ;i <= n + m ; i++){
        scanf("%d" ,&A[i]) ;
        use[A[i]] = 1 ;
    }
    precalu() ;
    for(i = 1 ;i <= n + m ; i++){
        int len = divisor[A[i]].size() ;
        for(j = 0 ; j < len ; j++){
            int d = divisor[A[i]][j] ;
            ans += (c[num[d]+1]+(MOD-c[num[d]]))%MOD * phi[d] % MOD ;
            num[d] ++  ;
        }
        if(i > n) cout << ans%MOD << endl ;
    }
}

