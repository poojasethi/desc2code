#pragma warning (disable:4996)
#include<cstdio>
#include<queue>
#include<string>
#include<algorithm>
#include<set>
#include<cstring>

using namespace std;
const int MAXN = 55;
typedef long long ll;

struct Node
{
	int sta,pos;
	string path;
	Node(string _path,int _sta,int _pos)
		:path(_path),sta(_sta),pos(_pos){}

	bool operator < (const Node & v) const
	{
		int len=path.size();
		int lenb=v.path.size();
		if(len!=lenb) return len>lenb;
		if(path<v.path) return false;
		if(path>v.path) return true;
		return pos<v.pos;
	}
};
int n,m,K;
int si,sj;
static int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};
char mat[MAXN][MAXN];
int visited[MAXN][MAXN];
set<ll> s;

void InputMat()
{
	for(int i=0;i<n;i++)
	{
		while(getchar()!='\n');
		for(int j=0;j<m;j++)
		{
			mat[i][j]=getchar();
			if(mat[i][j]=='S')
			{
				si=i;
				sj=j;
			}
		}
	}
}
int iCount(int x)
{
	int ret=0;
	for(;x;x&=x-1)
		ret++;
	return ret;
}
bool legal(int x,int y)
{
	return x>=0 && x<n && y>=0 && y<m && mat[x][y]!='S';
}
string Bfs()
{
	priority_queue<Node> q;

	memset(visited,0,sizeof(visited));
	s.clear();
	q.push(Node("",0,si*m+sj));
	s.insert(si*m+sj);
	while(!q.empty())
	{
		//printf("size=%d\n",q.size());
		Node u=q.top();
		q.pop();
		//printf("[%d,%d] %s\n",u.pos/m,u.pos%m,u.path.c_str());
		//if(u.path=="bc")
		//	system("pause");
		for(int k=0;k<4;k++)
		{
			int nx=u.pos/m+dir[k][0];
			int ny=u.pos%m+dir[k][1];
			if(legal(nx,ny)==false) continue;
			if(mat[nx][ny]=='T')
			{
				return u.path;
			}
			if(!( u.sta & (1<<(mat[nx][ny]-'a')) ) && iCount(u.sta)==K) continue;
			Node v=Node(u.path+mat[nx][ny],u.sta | (1<<(mat[nx][ny]-'a')),nx*m+ny);
			ll tmp=v.sta*10000+v.pos;
			if(s.find(tmp)!=s.end()) continue;
			if(visited[nx][ny] && (visited[nx][ny] & v.sta)==visited[nx][ny]) continue;
			visited[nx][ny]=v.sta;
			s.insert(tmp);
			q.push(v);
		}
	}
	return "-1";
}
int main()
{
	string Ans;
	while(~scanf("%d %d %d",&n,&m,&K))
	{
		InputMat();
		Ans=Bfs();
		printf("%s\n",Ans.c_str());
	}
	return 0;
}
 		  	  	 	 	  	     	