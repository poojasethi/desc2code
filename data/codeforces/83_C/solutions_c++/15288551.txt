#include <bits/stdc++.h>

using namespace std;

typedef pair<int,int> ii;
const int dx[]={1,-1,0,0}, dy[]={0,0,-1,1};
#define mp make_pair

struct data{
    int kc;
    string way;
    int mask;
    int here;
};

struct cmp{
    bool operator() (data a, data b) {
        return (a.kc>b.kc || (a.kc==b.kc && a.way>b.way));
    }
};

int n,m,k,stx,sty,enx,eny;
char a[100][100];
bool check[100][100];

int dis(int i, int j, int i1, int j1) {return abs(i-i1)+abs(j-j1);}
int cntbit(int t) {int res=0; for (int i=0; i<=27; ++i) res+=(t>>i&1); return res;}

string process()
{
    priority_queue <int, vector <data> , cmp> q;
    set <ii> s;
    data tmp;
    tmp.kc=dis(stx,sty,enx,eny); tmp.way=""; tmp.mask=0; tmp.here=stx*m+sty;
    q.push(tmp);
    while (!q.empty())
    {
        data u=q.top(); q.pop();
        if (s.count(mp(u.here,u.mask))) continue;
        s.insert(mp(u.here,u.mask));
        int x=(u.here-1)/m, y=(u.here-1)%m+1;
        for (int i=0; i<4; ++i)
        {
            int nx=x+dx[i], ny=y+dy[i];
            if (!check[nx][ny]) continue;
            if (nx==enx && ny==eny) return u.way;
            int next=u.mask|(1<<(a[nx][ny]-'a'));
            if (cntbit(next)<=k)
            {
                data tmp;
                tmp.kc=dis(nx,ny,enx,eny)+u.way.length(); tmp.way=u.way+a[nx][ny]; tmp.mask=next; tmp.here=nx*m+ny;
                q.push(tmp);
            }
        }
    }
    return "-1";
}

int main()
{
    cin >> n >> m >> k;
    for (int i=1; i<=n; ++i)
        for (int j=1; j<=m; ++j)
        {
            cin >> a[i][j];
            check[i][j]=(a[i][j]!='S');
            if (a[i][j]=='S') stx=i, sty=j;
            if (a[i][j]=='T') enx=i, eny=j;
        }
    cout << process();
}
