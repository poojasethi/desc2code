#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<string>
#include<queue>
#include<map>
#include<set>
#include<vector>
#include<cctype>
#include<cmath>
using namespace std;
const int N = 55;
int R,C,KK;
char ssG[N][N];
int stx,sty;
struct nodexx
{
    string str;
    int x,y,val;
    nodexx(string str00,int x00,int y00,int val00)
    {
        str=str00, x=x00, y=y00, val=val00;
    }
    bool operator<(const nodexx t)const
    {
        int lenaa=str.size(), lenbb=t.str.size();
        if(lenaa - lenbb)
            return lenaa > lenbb;
        return str > t.str;
    }
};
priority_queue<nodexx>QQ;
typedef pair<pair<int,int>, int> pii00;
set<pii00>SET;
int has[N][N];
int dirc[4][2]={{0,1},{0,-1},{1,0},{-1,0}};
bool Judge(int x)
{
    int cnt=0;
    while(x>0)
    {
        cnt += x%2;
        x >>= 1;
    }
    return cnt<=KK;
}
string BFS()
{
    SET.clear();
    memset(has, 0, sizeof has);
    while(QQ.size())
        QQ.pop();
    QQ.push(nodexx("", stx, sty, 0));
    SET.insert(make_pair(make_pair(stx,sty),0));
    int e,r,c,t;
    while(QQ.size())
    {
        nodexx XA=QQ.top();  QQ.pop();
        for(e=0; e < 4; e++)
        {
            r=XA.x+dirc[e][0], c=XA.y+dirc[e][1];
            if(r>=0 && r<R && c>=0 && c<C && ssG[r][c] != 'S')
            {
                if(ssG[r][c] == 'T')
                    return XA.str;
                t = XA.val|(1<<(ssG[r][c]-'a'));
                if(Judge(t) && SET.count(make_pair(make_pair(r,c),t))==0)
                {
                    if(has[r][c] && (has[r][c]&t)==has[r][c])
                        continue;
                    has[r][c] = t;
                    SET.insert(make_pair(make_pair(r,c),t));
                    QQ.push(nodexx(XA.str+ssG[r][c], r, c, t));
                }
            }
        }
    }
    return "-1" ;
}
void cyh()
{
    cout << BFS() << endl;
}
int main()
{
    int e,f;
    while(cin >> R >> C >> KK)
    {
        for(e=0; e < R; e++)
        {
            scanf("%s", ssG[e]);
            for(f=0; f < C; f++)
                if(ssG[e][f] == 'S')
                    stx=e, sty=f;
        }
        cyh();
    }
    return 0;
}
