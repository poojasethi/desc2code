    #include <stdio.h> 
    #include <math.h> 
    #include <queue> 
    #include <set> 
    #include <string> 
    #include <iostream> 
    using namespace std; 
    int bcount[1<<12]; 
    set<pair<int,int> >done; 
    string Map[60]; 
    int n,m,k; 
    int dx[]={-1,1,0,0}; 
    int dy[]={0,0,-1,1}; 
    int ex,ey; 
    int absval(int x) 
    { 
     return x<0?-x:x; 
    } 
int dist(int ax,int ay,int bx,int by) 
{ 
 return absval(ax-bx)+absval(ay-by); 
}
    struct pqitem 
    { 
      int x,y; 
      string S; //sµÄ³¤¶È¡£ 
      int mask; 
      bool operator<(const pqitem &b) const 
      { 
          if(S.size()+dist(x,y,ex,ey)==b.S.size()+dist(b.x,b.y,ex,ey) && S.compare(b.S)>0) 
           return S.compare(b.S)>0;//return 1;
          else return  S.size()+dist(x,y,ex,ey)>b.S.size()+dist(b.x,b.y,ex,ey);
     } 
}  ;
int getbcount(int m) 
{ 
   int ret=0; 
   while(m>0) 
   { 
   ret+=bcount[m&((1<<10)-1)];  m>>=10; 
   } 
   return ret; 
} 
int main() 
{ 

      for(int i=1;i<=(1<<10);i++) 
      bcount[i]=bcount[i/2]+(i&1?1:0);
    
      cin>>n>>m>>k; 
      for(int i=0;i<n;i++) 
      cin>>Map[i]; 

      int x,y; 
      for(int i=0;i<n;i++) 
        for(int j=0;j<m;j++) 
          { 
            if(Map[i][j]=='S') x=i,y=j; 
            if(Map[i][j]=='T') ex=i, ey=j; 
          } 
      priority_queue<pqitem> q; 
      q.push((pqitem){x,y,"",0}); 
      bool found=false; 
      while(!q.empty()) 
        { 
          pqitem cur=q.top(); 
          q.pop(); 
          if(cur.x==ex && cur.y==ey) 
            { 
                 cout<<cur.S<< endl; 
              found=true; 
              break; 
            } 

          if(done.find(make_pair(cur.x*m+cur.y,cur.mask))!=done.end()) continue; 
          done.insert(make_pair(cur.x*m+cur.y,cur.mask)); 
          for(int d=0;d<4;d++) 
            { 

              pqitem nxt=cur; 
              nxt.x += dx[d]; 
              nxt.y += dy[d]; 
              if(!(nxt.x>=0 && nxt.x<=n-1 && nxt.y>=0 && nxt.y<=m-1))  continue; 
              if(Map[nxt.x][nxt.y]!='T') 
             { 
                  nxt.mask|=(1<<(Map[nxt.x][nxt.y]-'a')); 
                    nxt.S+=Map[nxt.x][nxt.y];
                } 
               if(getbcount(nxt.mask)<=k) 
                q.push(nxt); 
            } 
        } 
   if(!found)printf("-1\n"); 
   //while(1);
   }

