#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <algorithm>
#include <string.h>
#include <cassert>
#include <math.h>
#include <vector>
#include <time.h>
#include <set>
#include <map>
#include <queue>
#define REP(i,n) for(int i=0, _n=(n); i<_n; i++)
#define REPD(i,n) for(int i=n-1; i>=0; i--)
#define FOR(i,a,b) for(int i=a,_b=(b); i<=_b; i++)
#define FORD(i,a,b) for(int i=a,_b=(b); i>=_b; i--)
#define FILL(x, v) memset(&x,v,sizeof(x))
#define DB(vari) cout<<#vari<<" = "<<vari<<endl;
#define x first
#define y second
#define mp make_pair
#define pb push_back

using namespace std;

typedef pair<int, int> pii;
typedef long long LL;

const int maxn = 51;
const int maxm = 51;
const int dx[4] = {0, 0, 1, -1};
const int dy[4] = {1, -1, 0, 0};

int n, m, k;
char c[maxn][maxm];
set<int> visited[maxn][maxm];
int sx, sy, tx, ty;
int first_mask[maxn][maxm];

struct position {
  int x, y, mask;
  string path;
  position(int x = 0, int y = 0, int mask = 0, string path = ""): x(x), y(y), mask(mask), path(path) {};
};

bool operator < (const position &A, const position &B) {
  if (A.path.length() == B.path.length())
    return (A.path > B.path);
  return (A.path.length() > B.path.length());
}

priority_queue <position> PQ;

bool valid(int x, int y) {
  return (x >= 0 && y >= 0 && x < n && y < m);
}
void go(int x, int y, int mask, string path) {
  if (c[x][y] != 'T') mask |= 1 << (c[x][y]-'a');
  if (__builtin_popcount(mask) > k) return;
  if (visited[x][y].find(mask) != visited[x][y].end()) return;
  if (first_mask[x][y] && ((first_mask[x][y] & mask) == first_mask[x][y])) return;
  first_mask[x][y] = mask;
  PQ.push(position(x, y, mask, path));
  visited[x][y].insert(mask);
}

int main() {
	//freopen("input.txt","r", stdin); freopen("output.txt","w", stdout);
  scanf("%d%d%d\n", &n, &m, &k);
  REP(i, n) {
    REP(j, m) {
      scanf("%c", &c[i][j]);
      if (c[i][j] == 'S') { sx = i; sy = j; }
    }
    scanf("\n");
  }
  PQ.push(position(sx, sy, 0, ""));
  while (!PQ.empty()) {
    position current = PQ.top(); PQ.pop();
    if (c[current.x][current.y] == 'T')
    {
      REP(i, current.path.length()-1)
        printf("%c", current.path[i]);
      printf("\n");
      return 0;
    }
    REP(k, 4) {
      tx = current.x + dx[k];
      ty = current.y + dy[k];
      if (!valid(tx, ty) || c[tx][ty] == 'S') continue;
      go(tx, ty, current.mask, current.path + c[tx][ty]);
    }
  }
  printf("-1\n");
	return 0;
}
