#include <cstdlib>
#include <cstdio>
#include <iostream>
#include <cstring>

using namespace std;

const int Fx[]={0,0,1,-1};
const int Fy[]={1,-1,0,0};

int N,M,K,TotHave;
char Map[60][60];
char CanUsed[15000][5];
int Tot,Sx,Sy,Tx,Ty;
char Tmp[5];
bool HAVE[300];
bool Vis[60][60];
int Qx[60*60],Qy[60*60];
int D[60][60];
string Path[60][60];

void DFS(int dep)
{
	if (dep>K)
	{
		++Tot;
		memcpy(CanUsed[Tot],Tmp,sizeof(Tmp));
		return ;
	}
	for (char x=Tmp[dep-1]+1;x<='z';++x)
		if (HAVE[x])
		{
			Tmp[dep]=x;
			HAVE[x]=false;
			DFS(dep+1);
			HAVE[x]=true;
		}
}

int main()
{
//	freopen("a.in","r",stdin);
	scanf("%d%d%d",&N,&M,&K);
	for (int i=1;i<=N;++i)
		scanf("%s",Map[i]+1);
	for (int i=1;i<=N;++i)
		for (int j=1;j<=M;++j)
		{
			if (!HAVE[Map[i][j]])	++TotHave;
			HAVE[Map[i][j]]=true;
			if (Map[i][j]=='S')
			{	Sx=i;Sy=j;	}
			if (Map[i][j]=='T')
			{	Tx=i;Ty=j;	}
		}
	K=min(K,TotHave-2);
	Tmp[0]='a'-1;
	DFS(1);
	int FAns=9999999;
	string SAns="-1 ";
	for (int i=1;i<=Tot;++i)
	{
		memset(HAVE,0,sizeof(HAVE));
		for (int j=1;j<=K;++j)
			HAVE[CanUsed[i][j]]=1;
		HAVE['S']=HAVE['T']=1;
		memset(D,63,sizeof(D));
		memset(Vis,0,sizeof(Vis));
		Path[Sx][Sy]="";
		D[Sx][Sy]=0;
		Qx[1]=Sx;Qy[1]=Sy;

		int S=0,E=1,X,Y;
		while (S<E)
		{
			++S;
			X=Qx[S];Y=Qy[S];
			
			for (int f=0;f<4;++f)
				if (HAVE[Map[X+Fx[f]][Y+Fy[f]]] &&
						(D[X+Fx[f]][Y+Fy[f]]>D[X][Y]+1||
						(D[X+Fx[f]][Y+Fy[f]]==D[X][Y]+1&&Path[X+Fx[f]][Y+Fy[f]]>Path[X][Y]+Map[X+Fx[f]][Y+Fy[f]])))
				{
					D[X+Fx[f]][Y+Fy[f]]=D[X][Y]+1;
					Path[X+Fx[f]][Y+Fy[f]]=Path[X][Y]+Map[X+Fx[f]][Y+Fy[f]];
					if (!Vis[X+Fx[f]][Y+Fy[f]])
					{
						Vis[X+Fx[f]][Y+Fy[f]]=true;
						++E;
						Qx[E]=X+Fx[f];
						Qy[E]=Y+Fy[f];
					}
				}
		}
		if (FAns>D[Tx][Ty]||(FAns==D[Tx][Ty]&&SAns>Path[Tx][Ty]))
		{
			FAns=D[Tx][Ty];
			SAns=Path[Tx][Ty];
		}
	}
	for (int i=0;i<SAns.size()-1;++i)
		cout<<SAns[i];
	cout<<endl;
}
