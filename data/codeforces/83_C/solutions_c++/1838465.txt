#include<cstdio>
#include<queue>
#include<cstring>
#include<map>
using namespace std;
#define mp make_pair 

int lx, ly, lk;
char maze[55][55];
map<pair<pair<int,int>,int>, bool> vis;
int sx, sy;
int ex, ey;
inline int ABS(int x){return x<0?-x:x;}
inline int h(int x, int y){return ABS(ex-x)+ABS(ey-y);}

struct S{
	int x, y, t, m;
	char path[2505]; 
	S(){}
	S(int _x, int _y, int _t, int _m, char tpath[]):
		x(_x), y(_y), t(_t), m(_m){
		strcpy(path, tpath);
	}
	
	friend bool operator< (const S& a, const S& b){
		int ha=h(a.x, a.y), hb=h(b.x, b.y);
		if(ha+a.t!=hb+b.t) return ha+a.t>hb+b.t;
		//if(a.t!=b.t) return a.t>b.t; 
		return strcmp(a.path, b.path)>0;
	}
};

int dir[4][2]={{1,0},{0,1},{0,-1},{-1,0}};
char path[2505];

inline int CB(int x){
	int cnt=0;
	while(x){
		x&=(x-1);
		cnt++;
	}
	return cnt;
}

char tpath[2505]; 
void bfs(){
	vis.clear();
	priority_queue<S> que;
	tpath[0]=0;
	que.push(S(sx, sy, 0, 0, tpath));
	while(!que.empty()){
		S u = que.top(); que.pop();
		if(vis[mp(mp(u.x, u.y),u.m)]) continue;
		vis[mp(mp(u.x, u.y),u.m)]=true;
	//	printf("%d %d %s\n",u.x,u.y,u.path);
	//	getchar();
		for(int i=0;i<4;i++){
			int vx = u.x+dir[i][0];
			int vy = u.y+dir[i][1];
			if(vx<0||vx>=lx) continue;
			if(vy<0||vy>=ly) continue;
			if(maze[vx][vy]=='S') continue;
			//printf("-- %d %d, %d %d: %d\n", vx, vy, ex, ey, h); 
			if(maze[vx][vy]=='T'){
				puts(u.path);
				return;
			}
			int mask = u.m;
			mask|=1<<(maze[vx][vy]-'a');
			if(CB(mask)>lk) continue;
			strcpy(tpath, u.path);
			int len = strlen(tpath);
			tpath[len]=maze[vx][vy];
			tpath[len+1]=0;
			//printf("== %d %d %s\n", vx, vy, tpath); 
			que.push(S(vx, vy, u.t+1, mask, tpath));
		}
	}
	puts("-1");
}

int main(){
	while(~scanf("%d%d%d",&lx, &ly, &lk)){
		for(int i=0;i<lx;i++){
			scanf("%s", maze[i]);
			for(int j=0;j<ly;j++){
				if(maze[i][j]=='S'){
					sx=i;
					sy=j;
				}else if(maze[i][j]=='T'){
					ex=i;
					ey=j;
				}
			}
		}
		bfs();
	}
}

     	 	 				 	   	 	 		