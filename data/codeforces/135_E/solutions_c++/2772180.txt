#include <iostream>
#include <algorithm>
using namespace std;

#define pow pow_NESC
#define fac fac_NESC

typedef long long LL;

const int N = int(1e6) + 50, P = int(1e9) + 7;

LL fac[N], rev[N], pow[N], revfac[N], w;
int k;

inline void inc (LL &x, LL y) { x = (x + y) % P; }
inline LL M (LL x, LL y) { return x * y % P; }
inline LL S (LL x) { return x * x % P; }
inline LL fpow (LL x, LL y)
{
	LL r(1);
	for (; y; y >>= 1, x = M(x, x)) if (y & 1) r = M(r, x);
	return r;
}

int main ()
{
	ios::sync_with_stdio(false);
	cin >> k >> w;
	rev[1] = 1;
	for (int i = 2; i <= k; ++i)
		rev[i] = ((-rev[P % i] * (P / i)) % P + P) % P;
	fac[0] = 1;
	for (int i = 1; i <= k; ++i) fac[i] = M(fac[i - 1], i);
	pow[0] = fpow(k, w);
	for (int i = 1; i <= k + 20; ++i) pow[i] = M(pow[i - 1], rev[k]);
	revfac[0] = 1;
	for (int i = 1; i <= k; ++i) revfac[i] = M(revfac[i - 1], rev[i]);
	LL res(0);
	for (int t = 1; t <= k; ++t)
	{
		if (t <= w - 1)
			inc(res, M(M(M(t, S(fac[k])), pow[t + 1]), S(revfac[k - t])));
		if (t > w - 1)
			inc(res, M(M(M(fac[k], w), fac[k - t + w - 1]), S(revfac[k - t])));
		if (t + 1 <= w - 1)
			inc(res, M(M(M(t, S(fac[k])), pow[t + 2]), M(revfac[k - t], revfac[k - t - 1])));
		if (t + 1 > w - 1)
			inc(res, M(M(M(fac[k], w - 1), fac[k - t + w - 2]), M(revfac[k - t], revfac[k - t - 1])));
	}
	cout << res << endl;
	return 0;
}

