#!/usr/bin/python

import math
from math import sin, cos

class BaseLine:
	pass

class Line(BaseLine):
	def __init__(self, k=0, b=0):
		self.k = float(k)
		self.b = float(b)
	def printme(self):
		print 'Line: k = %.5f, b = %.5f' % (self.k, self.b)

class VertLine(BaseLine):
	def __init__(self, x=0):
		self.x = x
	def printme(self):
		print 'VertLine: x = %.5f' % self.x
	
class Circle:
	def __init__(self, r=0, a=0, b=0):
		self.r = float(r)
		self.r2 = self.r ** 2
		self.x = float(a)
		self.y = float(b)
	#def get_y(self, x):
	def printme(self):
		print 'Circle: x = %.5f, y = %.5f, r = %.5f' % (self.x, self.y, self.r)

def fzero(n):
	#if -1e-8 < n < 1e-8:
		#print 'Zero:', n
	return -1e-8 < n < 1e-8

def fneg(n):
	return n < -1e-8

def solve_quadratic_2b(a, b, c):
	d = b * b - a * c
	if d < 0:
		return ()
	#if d == 0:
	if fzero(d):
		return (-b / a,)
	droot = math.sqrt(d)
	return (-b + droot) / a, (-b - droot) / a

def common_points_circle_line(cir, lin):
	if isinstance(lin, VertLine):
		b = -cir.y
		c = lin.x**2 - 2*cir.x*lin.x + cir.x**2 + cir.y**2 - cir.r2
		y = solve_quadratic_2b(1, b, c)
		points = len(y)
		if points == 2:
			return lin.x, y[0], lin.x, y[1]
		if points == 1:
			return lin.x, y[0]
		return ()
	a = 1 + lin.k * lin.k
	b = -cir.x + lin.k * lin.b - lin.k * cir.y
	c = cir.x**2 + lin.b**2 + cir.y**2 - cir.r**2 - 2*cir.y*lin.b
	x = solve_quadratic_2b(a, b, c)
	y = map(lambda s: lin.k * s + lin.b, x)
	points = len(x)
	if points == 2:
		return (x[0], y[0], x[1], y[1])
	if points == 1:
		return (x[0], y[0])
	return ()

def common_points_circles(c1, c2):
	d = math.sqrt((c2.x - c1.x)**2 + (c2.y - c1.y)**2)
	theta = math.atan2(c2.y - c1.y, c2.x - c1.x)

	x = -(c2.r2 - c1.r2 - d**2) / (2 * d)
	y_arg = c1.r2 - x**2
	if fneg(y_arg):
		# no common points
		return ()
	if fzero(y_arg):
		# one common point (circles_touching)
		return x * math.cos(theta) + c1.x, x * math.sin(theta) + c1.y
	y = math.sqrt(y_arg)
	t = math.atan2(y, x)
	r = math.sqrt(x**2 + y**2)
	return (r * cos(t + theta) + c1.x, # x1
			r * sin(t + theta) + c1.y, # y1
			r * cos(theta - t) + c1.x, # x2
			r * sin(theta - t) + c1.y) # y2

def common_points_lines(s1, s2):
	if isinstance(s2, VertLine):
		s1, s2 = s2, s1
	if isinstance(s1, VertLine):
		if isinstance(s2, VertLine):
			return ()
		y = s2.k * s1.x + s2.b
		return s1.x, y
	if s1.k == s2.k: return ()
	x = (s2.b - s1.b) / (s1.k - s2.k)
	y = s1.k * x + s1.b
	return x, y

def common_points(s1, s2):
	if isinstance(s1, BaseLine) and isinstance(s2, BaseLine):
		return common_points_lines(s1, s2)
	if isinstance(s1, Circle) and isinstance(s2, BaseLine):
		return common_points_circle_line(s1, s2)
	if isinstance(s1, BaseLine) and isinstance(s2, Circle):
		return common_points_circle_line(s2, s1)
	if isinstance(s1, Circle) and isinstance(s2, Circle):
		return common_points_circles(s1, s2)

x1, y1, r1 = raw_input().split(' ')
x2, y2, r2 = raw_input().split(' ')
x3, y3, r3 = raw_input().split(' ')
#x3, y3, r3 = (0,0,0)

x1, y1, r1 = map(float, (x1, y1, r1))
x2, y2, r2 = map(float, (x2, y2, r2))
x3, y3, r3 = map(float, (x3, y3, r3))

c1 = Circle(r1, x1, y1)
c2 = Circle(r2, x2, y2)
c3 = Circle(r3, x3, y3)

def equi_shape(x1, y1, r1, x2, y2, r2):
	r1s = r1**2
	r2s = r2**2
	r1mr2 = r1s - r2s
	if fzero(r1mr2):
		dx = x2 - x1
		dy = y2 - y1
		if fzero(dy):
			return VertLine((r1 * x2 + r2 * x1) / (r1 + r2))
		k = -dx / dy
		b = (x2**2 - x1**2 + y2**2 - y1**2) / (2 * dy)
		return Line(k, b)
	a = (r1s * x2 - r2s * x1) / r1mr2
	b = (r1s * y2 - r2s * y1) / r1mr2

	#rsq = r1s * r2s * (x1 * x2 * (-2 + x1 + x2)  +  y1 * y2 * (-2 + y1 + y2)) / r1mr2 ** 2
	rsq = r1s * r2s * ((x1 - x2) ** 2 + (y1 - y2) ** 2) / r1mr2 ** 2
	#print rsq

	r = math.sqrt(rsq)

	return Circle(r, a, b)

def merge_points(p1, p2, p3):
	p1 = map(lambda x: round(x, 7), p1)
	p2 = map(lambda x: round(x, 7), p2)
	p3 = map(lambda x: round(x, 7), p3)
	res = []
	for i in range(len(p1)):
		if i % 2: continue
		if p1[i] in p2[::2] and p1[i] in p3[::2] and p1[i+1] in p2[1::2] and p1[i+1] in p3[1::2]:
			res.append(p1[i])
			res.append(p1[i+1])
	return res

res1 = equi_shape(x2, y2, r2, x3, y3, r3)
res2 = equi_shape(x1, y1, r1, x3, y3, r3)
res3 = equi_shape(x1, y1, r1, x2, y2, r2)

pts1 = common_points(res2, res3)
pts2 = common_points(res1, res3)
pts3 = common_points(res1, res2)

#print pts1
#print pts2
#print pts3
pts = merge_points(pts1, pts2, pts3)

if not len(pts):
	#print 'no points'
	exit()

ratios = {}
for i in range(len(pts) / 2):
	x = pts[2*i]
	y = pts[2*i+1]
	d = math.hypot(x1 - x, y1 - y)
	rat = round(r1 / d, 7)
	ratios[str(rat)] = (x, y)

print '%.5f %.5f' % ratios[str(max(map(float, ratios.keys())))]

