from math import sqrt, asin


class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        return "({0.x:.2f}, {0.y:.2f})".format(self)

    @classmethod
    def midpoint(point_class, p, q):
        x = .5 * (p.x + q.x)
        y = .5 * (p.y + q.y)

        return point_class(x, y)

    @staticmethod
    def distance(p, q):
        dx = q.x - p.x
        dy = q.y - p.y

        return sqrt(dx**2 + dy**2)


class Line:
    def __str__(self):
        return "{0.A:.2f} x + {0.B:.2f} y + {0.C:.2f} = 0".format(self)
    
    @classmethod
    def from_two_points(line_class, p, q):
        self = line_class()
        
        self.A = q.y - p.y
        self.B = p.x - q.x
        self.C = -(self.A * p.x + self.B * p.y)

        return self

    @classmethod
    def from_line(line_class, A, B, C):
        self = line_class()

        self.A = A
        self.B = B
        self.C = C

        return self

    @classmethod
    def bisector(line_class, p, q):
        mid = Point.midpoint(p, q)
        line = line_class.from_two_points(p, q)

        return line.perpendicular_line(mid)

    def perpendicular_line(self, p):
        return Line.from_line(-self.B, self.A, self.B * p.x - self.A * p.y)

    def line_intersection(self, l2):
        den = self.A * l2.B - self.B * l2.A
        if den == 0:
            return 0, None

        x = (self.B * l2.C - self.C * l2.B) / den
        y = (self.C * l2.A - self.A * l2.C) / den

        return 1, Point(x, y)


class Circle:
    def __init__(self, x, y, r):
        self.c = Point(x, y)
        self.r = r

    def __str__(self):
        return "[{0.c!s}, {0.r:.2f}]".format(self)

    @classmethod
    def from_two_circles(circle_class, c1, c2):
        pc1, qc1 = c1.vertical_points()
        pc2, qc2 = c2.vertical_points()

        line_c1_c2 = Line.from_two_points(c1.c, c2.c)
        line_pc1_pc2 = Line.from_two_points(pc1, pc2)
        line_pc1_qc2 = Line.from_two_points(pc1, qc2)

        p = line_c1_c2.line_intersection(line_pc1_pc2)[1]
        q = line_c1_c2.line_intersection(line_pc1_qc2)[1]

        mid = Point.midpoint(p, q)
        r = Point.distance(p, mid)

        return circle_class(mid.x, mid.y, r)

    def vertical_points(self):
        p = Point(self.c.x, self.c.y + self.r)
        q = Point(self.c.x, self.c.y - self.r)

        return p, q

    def line_intersection(self, l):
        C = l.C + l.A * self.c.x + l.B * self.c.y
        norm = l.A**2 + l.B**2

        x = - l.A * C / norm
        y = - l.B * C / norm

        dist1 = sqrt(x**2 + y**2)
        
        if dist1 > self.r:
            return 0, None
        
        elif dist1 == self.r:
            x += self.c.x
            y += self.c.y

            return 1, Point(x, y)        

        dist2 = self.r**2 - C**2 / norm
        mult = sqrt(dist2 / norm)

        p = Point(x + l.B * mult + self.c.x, y - l.A * mult + self.c.y)
        q = Point(x - l.B * mult + self.c.x, y + l.A * mult + self.c.y)

        return 2, p, q

    def circle_intersection(self, c):
        xc = c.c.x - self.c.x
        yc = c.c.y - self.c.y

        A = -2 * xc
        B = -2 * yc
        C = xc**2 + yc**2 + self.r**2 - c.r**2

        line = Line.from_line(A, B, C)
        circle = Circle(0, 0, self.r)

        points = circle.line_intersection(line)

        if points[0] == 0:
            return 0, None

        elif points[0] == 1:
            return 1, Point(points[1].x + self.c.x, points[1].y + self.c.y)
        
        elif points[0] == 2:
            p, q = points[1:]
            return 2, Point(p.x + self.c.x, p.y + self.c.y), \
                      Point(q.x + self.c.x, q.y + self.c.y)




c1 = Circle(*map(float, raw_input().split()))
c2 = Circle(*map(float, raw_input().split()))
c3 = Circle(*map(float, raw_input().split()))


solution = None

if c1.r == c2.r:
    line_c1_c2 = Line.bisector(c1.c, c2.c)

    if c1.r == c3.r:
        line_c1_c3 = Line.bisector(c1.c, c3.c)
        points = line_c1_c3.line_intersection(line_c1_c2)

        if points[0] == 1:
            solution = points[1]
        
    else:
        circle_c1_c3 = Circle.from_two_circles(c1, c3)
        points = circle_c1_c3.line_intersection(line_c1_c2)

        if points[0] == 1:
            solution = points[1]
        elif points[0] == 2:
            solution = min(points[1], points[2], key=lambda x: Point.distance(x, c1.c))

else:
    circle_c1_c2 = Circle.from_two_circles(c1, c2)

    if c1.r == c3.r:
        line_c1_c3 = Line.bisector(c1.c, c3.c)
        points = circle_c1_c2.line_intersection(line_c1_c3)

        if points[0] == 1:
            solution = points[1]
        elif points[0] == 2:
            solution = min(points[1], points[2], key=lambda x: Point.distance(x, c1.c))

    else:
        circle_c1_c3 = Circle.from_two_circles(c1, c3)
        points = circle_c1_c2.circle_intersection(circle_c1_c3)

        if points[0] == 1:
            solution = points[1]
        elif points[0] == 2:
            solution = min(points[1], points[2], key=lambda x: Point.distance(x, c1.c))

if solution != None:
    print "%.6f %.6f" % (solution.x, solution.y)
