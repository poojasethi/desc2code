# here are the variables
n = 0
g = [[]] # containing the adjency list of graph
ans = []
mark = []
initV = []
destV = []
# end of variables

def dfs(x, odd, even, dist) :
    global g, ans, initV, destV, mark
    mark[x] = True
    cur = initV[x] ^ (even if dist % 2 == 0 else odd)
    if cur != destV[x] :
        ans.append(x)
        odd ^= dist % 2
        even ^= (1 - dist % 2)
    for i in range(0, len(g[x])) :
        u = g[x][i]
        if mark[u] == False :
            dfs(u, odd, even, dist + 1)

def bfs() :
    global g, ans, initV, destV, mark
    queue = [(0, 0, 0)]
    while queue :
        (cur, evens, odds) = queue[0]
        queue.pop(0)
        if initV[cur] ^ (evens % 2) != destV[cur] :
            ans.append(cur)
            evens ^= 1
        for i in range(0, len(g[cur])) :
            v = g[cur][i]
            if mark[v] == False :
                queue.append((v, odds, evens))
                mark[v] = True

def input() :
    global g, initV, destV, n
    [n] = map(int, raw_input().split())
    g = [[] for i in range(0, n)]
    for i in range(0, n - 1) :
        [u, v] = map(int, raw_input().split())
        u -= 1
        v -= 1
        g[u].append(v)
        g[v].append(u)
    initV = map(int, raw_input().split())
    destV = map(int, raw_input().split())


def main() :
    input()
    global mark, ans, n
    mark = [False for i in range(0, n)]
    #dfs(0, 0, 0, 0)
    bfs()
    print len(ans)
    for i in range(0, len(ans)) :
        print ans[i] + 1

main()
