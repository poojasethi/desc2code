#include <iostream>
#include <vector>

using namespace std;

const int limite=1000000;

struct tbloque {
  vector<pair<int,int> > nodoprof;
  int anyadeprof,minprof,maxprof,o;
  tbloque() {
    anyadeprof=0;
  }
};

//#include "alerta.h"
const int base=200;
//const int base=2;

int n,casos;
int nbloque=0;
tbloque bloque[limite];
int nodo2bloque[limite];
int nodo2pos[limite];
vector<int> ordenbloque;

void escribe()
{
  cout<<"bloques:";
  for (int o=0;o<int(ordenbloque.size());o++) {
    cout<<"[";
    tbloque &b=bloque[ordenbloque[o]];
    cout<<b.o<<";"<<b.anyadeprof<<";"<<b.minprof<<","<<b.maxprof<<";";
    for (int i=0;i<int(b.nodoprof.size());i++)
      cout<<"("<<b.nodoprof[i].first<<","<<b.nodoprof[i].second<<")";
    cout<<"]";
  }
  cout<<endl;
  cout<<"nodos:";
  for (int i=1;i<=n;i++)
    cout<<"("<<i<<","<<bloque[nodo2bloque[i]].o<<","<<nodo2pos[i]<<")";
  cout<<endl;
}

void calculaminimo(tbloque &b)
{
  b.minprof=1000000;
  b.maxprof=0;
  for (int i=0;i<int(b.nodoprof.size());i++) {
    b.minprof=min(b.minprof,b.nodoprof[i].second);
    b.maxprof=max(b.maxprof,b.nodoprof[i].second);
  }
}

void asignaposiciones(int ibloque)
{
  tbloque &b=bloque[ibloque];
  for (int i=0;i<int(b.nodoprof.size());i++) {
    nodo2bloque[b.nodoprof[i].first]=ibloque;
    nodo2pos[b.nodoprof[i].first]=i;
  }
}

void asignaordbloque()
{
  for (int o=0;o<int(ordenbloque.size());o++)
    bloque[ordenbloque[o]].o=o;
}

void limpiar(tbloque &b)
{
  if (b.anyadeprof==0) return;
  for (int i=0;i<int(b.nodoprof.size());i++)
    b.nodoprof[i].second+=b.anyadeprof;
  b.anyadeprof=0;
  calculaminimo(b);
}

void limpiar(int o)
{
  limpiar(bloque[ordenbloque[o]]);
}

void trocearbloque(int o,int pos)
{
  tbloque &b=bloque[ordenbloque[o]];
  if (pos==0 or pos==int(b.nodoprof.size())) return;
  limpiar(b);
  tbloque &nextb=bloque[nbloque];
  for (int i=pos;i<int(b.nodoprof.size());i++)
    nextb.nodoprof.push_back(b.nodoprof[i]);
  b.nodoprof.resize(pos);
  calculaminimo(b);
  calculaminimo(nextb);
  asignaposiciones(nbloque);
  ordenbloque.push_back(nbloque);
  for (int i=int(ordenbloque.size())-1;o+1<i;i--)
    swap(ordenbloque[i-1],ordenbloque[i]);
  nbloque++;
  asignaordbloque();
}

void revesarordenbloque(int i,int j)
{
  for (;i<j;i++,j--) swap(ordenbloque[i],ordenbloque[j]);
}

void moversegmento(int oini,int ofin,int ob)
{
  revesarordenbloque(oini,ofin);
  revesarordenbloque(ofin+1,ob);
  revesarordenbloque(oini,ob);
  asignaordbloque();
}

void anyadirprof(int oini,int ofin,int anyadeprof)
{
  for (int o=oini;o<=ofin;o++)
    bloque[ordenbloque[o]].anyadeprof+=anyadeprof;
}


int minimaprofentre(tbloque &b,int inf,int sup)
{
  if (inf>sup) return 1000000;
  limpiar(b);
  int minimo=b.nodoprof[inf].second;
  for (int i=inf+1;i<=sup;i++)
    minimo=min(minimo,b.nodoprof[i].second);
  return minimo;
}

int minimaprofentre(int oinf,int posinf,int osup,int possup)
{
  //cout<<"minimaprofentre "<<oinf<<" "<<posinf<<" "<<osup<<" "<<possup<<endl;
  tbloque &binf=bloque[ordenbloque[oinf]];
  tbloque &bsup=bloque[ordenbloque[osup]];
  if (oinf==osup)
    return minimaprofentre(binf,posinf,possup);
  int minimo=min(minimaprofentre(binf,posinf,int(binf.nodoprof.size())-1),
		 minimaprofentre(bsup,0,possup));
  for (int o=oinf+1;o<osup;o++)
    minimo=min(minimo,bloque[ordenbloque[o]].minprof+bloque[ordenbloque[o]].anyadeprof);
  return minimo;
}

int buscaexactprof(int o,int prof)
{
  tbloque &b=bloque[ordenbloque[o]];
  limpiar(b);
  for (int i=0;i<int(b.nodoprof.size());i++)
    if (b.nodoprof[i].second==prof)
      return b.nodoprof[i].first;
  return -1;
}

int buscaexactprof(int prof)
{
  int o=0;
  for (;o<int(ordenbloque.size()) and
	 bloque[ordenbloque[o]].maxprof+bloque[ordenbloque[o]].anyadeprof<prof;o++) ;
  return buscaexactprof(o,prof);
}

int buscaprofriseg(int o,int pos,int prof)
{
  tbloque &b=bloque[ordenbloque[o]];
  limpiar(b);
  for (int i=pos;i<int(b.nodoprof.size());i++)
    if (b.nodoprof[i].second<=prof)
      return i;
  return -1;
}

void buscaprofri(int o,int pos,int prof,int &oloc,int &posloc)
{
  posloc=buscaprofriseg(o,pos,prof);
  if (posloc!=-1) {
    oloc=o;
    return;
  }
  for (o++;o<int(ordenbloque.size()) and
	 prof<bloque[ordenbloque[o]].minprof+bloque[ordenbloque[o]].anyadeprof;o++) ;
  if (o==int(ordenbloque.size())) {
    oloc=posloc=-1;
    return;
  }
  oloc=o;
  posloc=buscaprofriseg(o,0,prof);
}

int buscaprofleseg(int o,int prof)
{
  tbloque &b=bloque[ordenbloque[o]];
  limpiar(b);
  for (int i=int(b.nodoprof.size())-1;i>=0;i--)
    if (b.nodoprof[i].second<=prof)
      return i;
  return -1;
}

void buscaprofle(int o,int prof,int &oloc,int &posloc)
{
  for (;o>=0 and
	 prof<bloque[ordenbloque[o]].minprof+bloque[ordenbloque[o]].anyadeprof;o--) ;
  //if (o<0) return -1;
  oloc=o;
  posloc=buscaprofleseg(o,prof);
}

void arreglarbase()
{
  int oant=0;
  for (int o=0;o<int(ordenbloque.size());o++) {
    tbloque &b=bloque[ordenbloque[o]];
    if (oant<o) {
      if (int(b.nodoprof.size())<base) {
	tbloque &bant=bloque[ordenbloque[oant]];
	limpiar(bant);
	limpiar(b);
	if (int(bant.nodoprof.size())+int(b.nodoprof.size())<=2*base) {
	  for (int i=0;i<int(b.nodoprof.size());i++) {
	    nodo2bloque[b.nodoprof[i].first]=ordenbloque[oant];
	    nodo2pos[b.nodoprof[i].first]=int(bant.nodoprof.size());
	    bant.nodoprof.push_back(b.nodoprof[i]);
	    bant.minprof=min(bant.minprof,b.nodoprof[i].second);
	    bant.maxprof=max(bant.maxprof,b.nodoprof[i].second);
	  }
	  while (int(b.nodoprof.size())>0) b.nodoprof=vector<pair<int,int> >();
	} else {
	  for (int i=0,j=int(b.nodoprof.size())-1;i<j;i++,j--)
	    swap(b.nodoprof[i],b.nodoprof[j]);
	  while (int(b.nodoprof.size())<int(bant.nodoprof.size())) {
	    b.nodoprof.push_back(bant.nodoprof.back());
	    bant.nodoprof.pop_back();
	  }
	  for (int i=0,j=int(b.nodoprof.size())-1;i<j;i++,j--)
	    swap(b.nodoprof[i],b.nodoprof[j]);
	  calculaminimo(bant);
	  calculaminimo(b);
	  asignaposiciones(ordenbloque[o]);
	  oant++;
	  ordenbloque[oant]=ordenbloque[o];
	}
      } else {
	oant++;
	ordenbloque[oant]=ordenbloque[o];
      }
    }
  }
  while (oant+1<int(ordenbloque.size())) ordenbloque.pop_back();
  asignaordbloque();
}

int distanciaentre(int u,int v)
{
  if (u==v) return 0;
  tbloque &bu=bloque[nodo2bloque[u]];
  tbloque &bv=bloque[nodo2bloque[v]];
  int ou=bu.o;
  int ov=bv.o;
  int posu=nodo2pos[u];
  int posv=nodo2pos[v];
  if (pair<int,int> (ou,posu)>pair<int,int> (ov,posv))
    return distanciaentre(v,u);
  int minimaprof=minimaprofentre(ou,posu+1,ov,posv);
  int profu=bu.nodoprof[posu].second+bu.anyadeprof;
  int profv=bv.nodoprof[posv].second+bv.anyadeprof;
  if (profu<minimaprof) return profv-profu;
  int profentre=minimaprof-1;
  return profu-profentre+profv-profentre;
}

void subirprofnodo(int u,int h)
{
  //cout<<"subirprofnodo "<<u<<" "<<h<<endl;
  trocearbloque(bloque[nodo2bloque[u]].o,nodo2pos[u]);
  tbloque &b=bloque[nodo2bloque[u]];
  int profu=b.anyadeprof+b.nodoprof[0].second;
  int oloc,posloc;
  buscaprofle(b.o-1,profu-h,oloc,posloc);
  trocearbloque(oloc,posloc+1);
  oloc++;
  int oloc2,posloc2;
  buscaprofri(b.o,nodo2pos[u]+1,profu,oloc2,posloc2);
  if (oloc2==-1) {
    anyadirprof(b.o,int(ordenbloque.size())-1,-(h-1));
    moversegmento(oloc,b.o-1,int(ordenbloque.size())-1);
    arreglarbase();
    return;
  }
  trocearbloque(oloc2,posloc2);
  if (posloc2!=0) oloc2++;
  //escribe();
  //cout<<"oloc "<<oloc<<" b.o "<<b.o<<" oloc2 "<<oloc2<<endl;
  anyadirprof(b.o,oloc2-1,-(h-1));
  //escribe();
  moversegmento(oloc,b.o-1,oloc2-1);
  //escribe();
  arreglarbase();
}

vector<int> g[limite];
vector<int> preorden;
int profundidad[limite];

void generapreordenreverso(int u,int prof)
{
  preorden.push_back(u);
  profundidad[u]=prof;
  vector<int> &ar=g[u];
  for (int i=int(ar.size())-1;i>=0;i--)
    generapreordenreverso(ar[i],prof+1);
}

int main()
{
  ios::sync_with_stdio(false);
  cin>>n>>casos;
  for (int u=1;u<=n;u++) {
    int m;
    cin>>m;
    for (int i=0;i<m;i++) {
      int v;
      cin>>v;
      g[u].push_back(v);
    }
  }
  generapreordenreverso(1,0);
  for (int i=0;i<int(preorden.size());i++) {
    int u=preorden[i];
    int profu=profundidad[u];
    if (int(ordenbloque.size())==0 or
	int(bloque[ordenbloque.back()].nodoprof.size())>3*base/2)
      ordenbloque.push_back(nbloque++);
    bloque[ordenbloque.back()].nodoprof.push_back(pair<int,int> (u,profu));
  }
  for (int o=0;o<int(ordenbloque.size());o++) {
    asignaposiciones(ordenbloque[o]);
    calculaminimo(bloque[ordenbloque[o]]);
  }
  asignaordbloque();
  for (int cas=0;cas<casos;cas++) {
    //cout<<endl<<"cas "<<cas<<endl;
    //escribe();
    int tipo;
    cin>>tipo;
    if (tipo==1) {
      int u,v;
      cin>>u>>v;
      cout<<distanciaentre(u,v)<<endl;
    } else if (tipo==2) {
      int u,h;
      cin>>u>>h;
      subirprofnodo(u,h);
    } else if (tipo==3) {
      int prof;
      cin>>prof;
      cout<<buscaexactprof(prof)<<endl;
    }
  }
}
