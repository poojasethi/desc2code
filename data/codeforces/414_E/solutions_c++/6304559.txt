#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#include<vector>
#define Ls son[x][0]
#define Rs son[x][1] 
#define E else
#define MAXN 200005
using namespace std ;
typedef long long LL ;

int N, M, R ;
int num[MAXN], son[MAXN][2], fa[MAXN] ;
int D[MAXN], U[MAXN], T[MAXN], V[MAXN] ;
int S[MAXN][2], W, P[MAXN] ;
vector<int> dn[MAXN];

void Ud(int x)
{
	T[x] = T[Ls]+T[Rs]+V[x] ;
	D[x] = min(D[Ls], D[Rs]+T[Ls]+V[x]) ;
	D[x] = min(D[x], T[Ls]+V[x]) ;
	U[x] = max(U[Ls], U[Rs]+T[Ls]+V[x]) ;
	U[x] = max(U[x], T[Ls]+V[x]) ;
}
void Ro(int x, int d)
{
	int t = fa[x] ;
	son[t][d^1] = son[x][d], fa[son[x][d]] = t ;
	if(fa[t]) son[fa[t]][son[fa[t]][1] == t] = x ;
	fa[x] = fa[t], fa[t] = x, son[x][d] = t ;
	Ud(t), Ud(x) ;
}
void Sp(int x, int to)
{
	int t, d1, d2 ;
	while((t=fa[x])-to)
	{
		if(fa[t] == to) Ro(x, son[t][0]==x) ;
		E if((d1=(son[fa[t]][0]==t))^(d2=(son[t][0]==x)))
			Ro(x, d2), Ro(x, d1) ; 
		E Ro(t, d1), Ro(x, d2) ;
	}
	R=to?R:x;
}
int Last(int x)
{
	Sp(x, 0) ;
	for(x = Ls; Rs; x = Rs) ;
	return x ;
}
int Next(int x)
{
	Sp(x, 0) ;
	for(x = Rs; Ls; x = Ls) ;
	return x ;
}
int De(int l, int r)
{
	int t, tl, tr, f ;
	tl = Last(l) ;
	tr = Next(r) ;
	if(!(tl+tr)) {return r ;}
	E if(!tl || !tr) 
	{
		f = (tr==0), tr += tl ;
		Sp(tr, 0), t = son[tr][f] ;
		son[tr][f] = fa[son[tr][f]] = 0, Ud(tr); 
		return t ;
	}
	Sp(tl, 0), Sp(tr, tl), t = son[tr][0] ;
	son[tr][0] = fa[son[tr][0]] = 0 ;
	Ud(tr), Ud(tl) ;
	return t ;
} 
void In(int x, int y)
{
	if(!x) {R = y; return ;}
	int t = Next(x) ;
	if(!t) Rs = y, fa[y] = x, Ud(x) ;
	E
	{
		Sp(t, x) ;
		son[t][0] = y, fa[y] = t ;
		Ud(t), Ud(x) ;
	}
	Sp(y, 0) ;
}
int Ask(int x, int k)
{
	for(k++;;) if(D[Rs]+T[Ls]+V[x] <= k && U[Rs]+T[Ls]+V[x] >= k)
		k -= T[Ls]+V[x], x = Rs ;
	E if(T[Ls]+V[x] == k)
		{Sp(x, 0);return x==S[num[x]][0]?num[x]:P[num[x]] ;}
	E x = Ls ;
}
int Dis(int x, int y)
{
	x = S[x][0], y = S[y][0] ;
	if(x == y) return 0 ;
	Sp(y, 0), Sp(x, y) ;
	if(x == son[y][1]) swap(x, y) ;
	Sp(y, 0), Sp(x, y) ;
	int t = min(T[Ls]+V[x], min(D[Rs]+T[Ls]+V[x], T[x]+V[y])) ;
	return T[Ls]+T[x]+V[x]+V[y]-t*2 ;
}
void Tr(int x, int h)
{
	int t = x ;
	x = S[x][0], Sp(x, 0) ;
	int par = Ask(Ls, T[Ls]+V[x]-h-1) ;
	P[t] = par ;
	t = De(S[t][0], S[t][1]) ;
	In(Last(S[par][1]), t) ;
}

void Dfs(int x)
{
	S[x][0] = ++W, num[W] = x ;
	V[W] = T[W] = D[W] = U[W] = 1, In(R, W) ;
	for(int i = 0; i < dn[x].size(); i ++)
		P[dn[x][i]] = x, Dfs(dn[x][i]) ;
	S[x][1] = ++W, num[W] = x ;
	V[W] = T[W] = D[W] = U[W] = -1, In(R, W) ;
}

int main()
{
	int i, j, t, get, type, fr, to ;
	scanf("%d %d", &N, &M) ;
	memset(D, 62, sizeof(D)) ;
	for(i = 0; i <= 200000; i ++)
		U[i] = -2*N-2, D[i] = 2*N+2 ;
	for(i = 1; i <= N; i ++)
	{
		scanf("%d", &j) ;
		while(j--) scanf("%d", &t), dn[i].push_back(t) ;
	}
	for(i = 1, Dfs(1); i <= M; i ++)
	{
		scanf("%d", &type) ;
		if(type == 1)
			scanf("%d %d", &fr, &to), printf("%d\n", Dis(fr, to)) ;
		E if(type == 2)
			scanf("%d %d", &fr, &to), Tr(fr, to) ;
		E scanf("%d", &fr), printf("%d\n", Ask(R, fr)) ;
	}
	return 0 ;
}
