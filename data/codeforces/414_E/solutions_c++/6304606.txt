#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#include<vector>
#define Ls son[x][0]
#define Rs son[x][1] 
#define E else
#define X 200005
#define I int
#define Sc(x) scanf("%d", &x) 
#define Pr(x) printf("%d\n", x) 
using namespace std ;
I N,M,R,num[X],son[X][2],fa[X] ;
I D[X],U[X],T[X],V[X],S[X][2],W,P[X] ;
vector<int> dn[X];
void Ud(I x)
{
	T[x]=T[Ls]+T[Rs]+V[x] ;
	D[x]=min(T[Ls]+V[x],min(D[Ls],D[Rs]+T[Ls]+V[x])) ;
	U[x]=max(T[Ls]+V[x],max(U[Ls],U[Rs]+T[Ls]+V[x])) ;
}
void Ro(I x, I d)
{
	I t = fa[x] ;
	son[t][d^1] = son[x][d], fa[son[x][d]] = t ;
	if(fa[t]) son[fa[t]][son[fa[t]][1] == t] = x ;
	fa[x] = fa[t], fa[t] = x, son[x][d] = t ;
	Ud(t), Ud(x) ;
}
void Sp(I x, I to)
{
	I t, d1, d2 ;
	while((t=fa[x])-to)
	{
		if(fa[t] == to) Ro(x, son[t][0]==x) ;
		E if((d1=(son[fa[t]][0]==t))^(d2=(son[t][0]==x)))
			Ro(x, d2), Ro(x, d1) ; 
		E Ro(t, d1), Ro(x, d2) ;
	}
	R=to?R:x;
}
I Last(I x)
{
	Sp(x, 0) ;
	for(x = Ls; Rs; x = Rs) ;
	return x ;
}
I Next(I x)
{
	Sp(x, 0) ;
	for(x = Rs; Ls; x = Ls) ;
	return x ;
}
I De(I l, I r)
{
	I t, tl, tr, f ;
	tl = Last(l) ;
	tr = Next(r) ;
	if(!(tl+tr)) {return r ;}
	E if(!tl || !tr) 
	{
		f = (tr==0), tr += tl ;
		Sp(tr, 0), t = son[tr][f] ;
		son[tr][f] = fa[son[tr][f]] = 0, Ud(tr); 
		return t ;
	}
	Sp(tl, 0), Sp(tr, tl), t = son[tr][0] ;
	son[tr][0] = fa[son[tr][0]] = 0 ;
	Ud(tr), Ud(tl) ;
	return t ;
} 
void In(I x, I y)
{
	if(!x) {R = y; return ;}
	I t = Next(x) ;
	if(!t) Rs = y, fa[y] = x, Ud(x) ;
	E
	{
		Sp(t, x) ;
		son[t][0] = y, fa[y] = t ;
		Ud(t), Ud(x) ;
	}
	Sp(y, 0) ;
}
I Ask(I x, I k)
{
	for(k++;;) if(D[Rs]+T[Ls]+V[x] <= k && U[Rs]+T[Ls]+V[x] >= k)
		k -= T[Ls]+V[x], x = Rs ;
	E if(T[Ls]+V[x] == k)
		{Sp(x, 0);return x==S[num[x]][0]?num[x]:P[num[x]] ;}
	E x = Ls ;
}
I Dis(I x, I y)
{
	x = S[x][0], y = S[y][0] ;
	if(x == y) return 0 ;
	Sp(y, 0), Sp(x, y) ;
	if(x == son[y][1]) swap(x, y) ;
	Sp(y, 0), Sp(x, y) ;
	I t = min(T[Ls]+V[x], min(D[Rs]+T[Ls]+V[x], T[x]+V[y])) ;
	return T[Ls]+T[x]+V[x]+V[y]-t*2 ;
}
void Tr(I x, I h)
{
	I t = x ;
	x = S[x][0], Sp(x, 0) ;
	I par = Ask(Ls, T[Ls]+V[x]-h-1) ;
	P[t] = par ;
	t = De(S[t][0], S[t][1]) ;
	In(Last(S[par][1]), t) ;
}
void Dfs(I x)
{
	S[x][0] = ++W, num[W] = x ;
	V[W] = T[W] = D[W] = U[W] = 1, In(R, W) ;
	for(I i = 0; i < dn[x].size(); i ++)
		P[dn[x][i]] = x, Dfs(dn[x][i]) ;
	S[x][1] = ++W, num[W] = x ;
	V[W] = T[W] = D[W] = U[W] = -1, In(R, W) ;
}
I main()
{
	I i,j,t,get,tp,fr,to;
	Sc(N), Sc(M) ;
	memset(D, 62, sizeof(D)) ;
	for(i = 0; i <= X-5; i ++)
		U[i]=-X,D[i]=X ;
	for(i = 1; i <= N&&Sc(j); i ++)
		while(j--) Sc(t), dn[i].push_back(t) ;
	for(i = 1, Dfs(1); i <= M&&Sc(tp); i ++)
		if(tp == 1) Sc(fr),Sc(to),Pr(Dis(fr, to)) ;
		E if(tp == 2) Sc(fr),Sc(to),Tr(fr, to) ;
		E Sc(fr),Pr(Ask(R, fr)) ;
	return 0 ;
}
