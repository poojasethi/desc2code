#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

#define V(x) (nil+x)

const int N = 1e5 + 5;

int to[N], next[N], end[N], cur[N], tms;
int fa[N], seq[N+N], n, m;

void adk(int x, int y)
{
	to[++tms] = y, next[tms] = end[x], end[x] = tms;
}

struct rc
{
	rc *c[2], *f;
	int dat, siz, sum;
	int mi, ma;
	
	void pup();
	int d();
	int root();
	void sc(rc *x, int d);
	
}nil[N+N], *rot;

int qMin(int x, int y){return x<y ? x:y;}
int qMax(int x, int y){return x>y ? x:y;}

void rc::pup()
{
	sum = c[0]->sum + c[1]->sum + dat;
	siz = c[0]->siz + c[1]->siz + 1;
	mi = qMin(c[0]->mi, c[0]->sum + qMin(0, c[1]->mi + dat) );
	ma = qMax(c[0]->ma, c[0]->sum + qMax(0, c[1]->ma + dat) );
}

int rc::d() { return f->c[1] == this; }
int rc::root() { return f == nil; }
void rc::sc(rc *x, int d){ (c[d]=x)->f = this; }

void zig(rc *x)
{
	int d = x->d();
	rc *p = x->f;
	p->sc( x->c[!d], d ), p->pup();
	if(p->root()) x->f = p->f; else p->f->sc(x, p->d());
	x->sc(p, !d);
}

void splay(rc *x)
{
	for(rc *y; !x->root(); )
	{	
		y = x->f;
		if(!y->root()) x->d() ^ y->d() ? zig(x) : zig(y);
		zig(x);
	}
	x->pup();
	rot = x;
}

int depth(int x) { return splay(V(x)), V(x)->c[0]->sum; }
int dfn(int x){ return splay(V(x)), V(x)->c[0]->siz; }

int lca(int x, int y)
{
	if(dfn(x) > dfn(y)) swap(x, y);
	splay(V(x)), V(x)->c[1]->f = nil, splay(V(y));
	int ret = depth(x) + qMin(0, qMin(V(y)->c[0]->mi, V(y)->c[0]->sum) + V(x)->dat) ;
	V(x)->sc(V(y), 1), rot = V(x), V(x)->pup();
	return ret;
}

int last(rc *x, int d)
{
	for(int s=0;;)
	{
		if(x->c[1]->ma + x->dat + x->c[0]->sum + s >= d
		&& x->c[1]->mi + x->dat + x->c[0]->sum + s <= d) s += x->c[0]->sum + x->dat, x = x->c[1];
		else if(x->c[0]->sum + s == d) return x - nil;
		else x = x->c[0];
	}
}

rc* pred(rc *x)
{
	rc *y = x->c[0]; for(; y->c[1]!=nil; y=y->c[1]);
	return splay(y), y;
}

rc* succ(rc *x)
{
	rc *y = x->c[1]; for(; y->c[0]!=nil; y=y->c[0]);
	return splay(y), y;
}

rc* empty(rc *x)
{
	rc *y = x; for(; y->c[1]!=nil; y=y->c[1]);
	return splay(y), y;
}

void ancester(int x, int d)
{
	int dep = depth(x) - d, v;
	splay(V(x));
	if(dep<0) {puts("WAWA"); return;}
	v = last(V(x)->c[0], dep);
	
	// CUT
	rc *rt = pred(V(x));
	rt->c[1]->f = nil;
	splay(V(x+n));
	rc *rta = succ(V(x+n));
	rc *cur = rta->c[0];
	rta->c[0] = nil, rt->sc(rta, 1);
	rta->pup(), rt->pup();
	
	// LINK
	splay(rt = V(v+n));
	rta = rt->c[0], rta->f = nil, rta = empty(rta);
	rta->sc(cur, 1), rta->pup();
	rt->sc(rta, 0), rt->pup(), rot = rt;
}

rc* construct(int l, int r, rc *f)
{
	if(l>r) return nil;
	int md = (l+r)>>1, x = seq[md];
	V(x)->dat = (x>n) ? -1 : 1;
	V(x)->f = f;
	V(x)->c[0] = construct(l, md-1, V(x));
	V(x)->c[1] = construct(md+1, r, V(x));
	return V(x)->pup(), V(x);
}

int main()
{
	scanf("%d%d", &n, &m);
	for(int i=1, x; i<=n; i++)
	{
		scanf("%d", &x);
		for(int j=1; j<=x; j++) scanf("%d", &cur[j]);
		for(int j=x; j; j--) adk(i, cur[j]);
	}
	
	V(0)->mi = N+N, V(0)->ma = -N-N;
	
	for(int i=1; i<=n; i++) cur[i] = end[i];
	seq[0] = seq[1] = 1;
	for(int x=1, p, v; x; )
	{
		p = cur[x], cur[x] = next[p];
		if(!p) { seq[++seq[0]] = x+n; x = fa[x]; continue; }
		v = to[p], fa[v] = x, seq[++seq[0]] = v, x = v;
	}
	
	rot = construct(1, seq[0], nil);
	
	for(int i=1, ty, a, b; i<=m; i++)
	{
		scanf("%d", &ty);
		if(ty == 1)
		{
			scanf("%d%d", &a, &b);
			if(a==b) puts("0");
			else printf("%d\n", depth(a+n) + depth(b+n) - lca(a+n,b+n) * 2);
		}
		else if(ty == 2) scanf("%d%d", &a, &b), ancester(a, b);
		else scanf("%d", &a), printf("%d\n", last(rot, a+1) - n);
	}
	
	return 0;
}
