#include <algorithm>
#include <vector>
#include <stdio.h>
#include <memory.h>
#include <string.h>

using namespace std;

typedef pair<int, int> pii;

#define x first
#define y second
#define mp(x, y) make_pair(x, y)
#define pb(x) push_back(x)
#define rep(i, n) for (i=0; i<n; i++)

#define NN 300010
#define inf 0x3f3f3f3f
#define lson x->ch[0]
#define rson x->ch[1]
#define ket (root->ch[1]->ch[0])

inline void smin(int &a, int b) { if (b<a) a=b; }
inline void smax(int &a, int b) { if (b>a) a=b; }

struct Node {
	Node *pre, *ch[2];
	int deep, mv, mxv, del, ver;
	int sz;
	
	void up() {
		sz=ch[0]->sz+ch[1]->sz+1;
		mv=mxv=deep; del=0;
		if (ch[0]->pre) smin(mv, ch[0]->mv), smax(mxv, ch[0]->mxv);
		if (ch[1]->pre) smin(mv, ch[1]->mv), smax(mxv, ch[1]->mxv);
	}
	void down() {
		if (del==0) return;
		if (ch[0]->pre) ch[0]->deep+=del, ch[0]->mv+=del, ch[0]->mxv+=del, ch[0]->del+=del;
		if (ch[1]->pre) ch[1]->deep+=del, ch[1]->mv+=del, ch[1]->mxv+=del, ch[1]->del+=del;
		del=0;
	}
};

struct Splaytree {
	int top;
	Node node[NN], *null, *root, *pre[NN], *post[NN];
	pii dfn[NN];
	
	void Rotate(Node *x, int c) {
		Node *y=x->pre;
		y->down(); x->down();
		y->ch[!c]=x->ch[c];
		if (x->ch[c]!=null) x->ch[c]->pre=y;
		x->pre=y->pre;
		if (y->pre!=null) y->pre->ch[y->pre->ch[1]==y]=x;
		x->ch[c]=y; y->pre=x;
		y->up();
	}
	
	void Splay(Node *x, Node *go) {
		x->down();
		while (x->pre!=go) {
			if (x->pre->pre==go) Rotate(x, x->pre->ch[0]==x);
			else {
				Node *y=x->pre, *z=y->pre;
				int f=z->ch[1]==y;
				if (y->ch[f]==x) Rotate(y, !f);
				else Rotate(x, f);
				Rotate(x, !f);
			}
		}
		x->up();
		if(go==null) root=x;
	}
	
	void RTO(int k, Node *go) {
		Node *x=root;
		while (lson->sz!=k) {
			x->down();
			if (lson->sz>k) x=lson;
			else {
				k-=lson->sz+1;
				x=rson;
			}
		}
		Splay(x, go);
	}
	
	Node *path[NN];
	int PTH(Node *x) {
		int k=0, i, j;
		while (x!=null) {
			path[k++]=x;
			x=x->pre;
		}
		j=0;
		for (i=k-1; i>=0; i--) {
			Node *x=path[i];
			x->down();
			if (i==0 || (i && rson==path[i-1])) j+=lson->sz+1;
		}
		
		return j;
	}
	
	Node *find(Node *x, int dp) {
		x->down();
		if (rson!=null && rson->mxv>=dp && rson->mv<=dp) return find(rson, dp);
		if (x->deep==dp) return x;
		return find(lson, dp);
	}
	
	Node *newnode(int c, Node *f) {
		Node *x=&node[++top];
		x->pre=f; lson=rson=null;
		x->sz=1; x->del=0;
		x->mv=x->mxv=x->deep=dfn[c].y;
		int u=dfn[c].x;
		if (u>0) {
			u=u-1; x->ver=u;
			pre[u]=x;
		} else {
			u=-u-1; x->ver=u;
			post[u]=x;
		}
		return x;
	}
	
	int N;
	
	Node *build(int l, int r, Node *f) {
		if (l>r) return null;
		int mid=(l+r)/2;
		Node *x=newnode(mid, f);
		lson=build(l, mid-1, x);
		rson=build(mid+1, r, x);
		x->up();
		return x;
	}
	
	void init() {
		null=&node[0];
		null->sz=0; null->pre=NULL; null->mxv=-inf;
		top=0;
		root=build(0, N-1, null);
	}
	
	void out(Node *x) {
		if (x==null) return ;
		x->down();
		out(lson);
		printf("(%d %d) ", x->ver, x->deep);
		out(rson);
	}
	
	vector<int> adj[NN];
	
	void dfs(int u, int dp=0) {
		dfn[N++]=mp(u+1, dp);
		int i, v, deg=adj[u].size();
		rep(i, deg) {
			v=adj[u][i];
			dfs(v, dp+1);
		}
		dfn[N++]=mp(-(u+1), dp);
	}
	
	void solve() {
		int n, m, i, j, k, u, v, l, r, dp, t, h;
		Node *x, *y;
		
		scanf("%d %d ", &n, &m);
		rep(i, n) {
			adj[i].clear();
			for (scanf("%d ", &k); k--; ) {
				scanf("%d ", &j);
		  		adj[i].pb(--j);
	  		}
		}
		N=0; dfs(0); init();
		while (m--) {
			scanf("%d ", &t);
			if (t==1) {
				scanf("%d %d ", &u, &v); u--; v--;
				l=PTH(pre[u])-1; r=PTH(pre[v])-1;
				if (l>r) swap(l, r);
				RTO(l, null); RTO(r+1, root);
				printf("%d\n", pre[u]->deep+pre[v]->deep-2*(ket->mv-1));
			} else if (t==2) {
				scanf("%d %d ", &u, &h); u--; h--;
				l=PTH(pre[u])-1; r=PTH(post[u])-1;
				RTO(l-1, null); RTO(r+1, root);
				x=ket; ket=null; x->down(); x->pre=null;
				root->ch[1]->up(); root->up();
				x->del-=h; x->mv-=h; x->mxv-=h; x->deep-=h;
				dp=x->mv-1;
				if (root->deep==dp) y=root;
				else y=find(root->ch[0], dp);
				k=y->ver;
				k=PTH(post[k])-1;
				RTO(k-1, null); RTO(k, root);
				ket=x; x->pre=root->ch[1];
				root->ch[1]->up(); root->up();
			} else {
				scanf("%d ", &k);
				x=find(root, k);
				printf("%d\n", x->ver+1);
			}
		}
	}
} spt;

int main() {
	spt.solve();
	
	return 0;
}

