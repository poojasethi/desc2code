#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;

inline void READ(int &x)
{
	static char c;
	x=0;
	do c=getchar(); while (c<'0' || c>'9');
	do x=x*10+c-48, c=getchar(); while (c>='0' && c<='9');
}

const int maxn=1e5+5;

struct NODE
{
	int min, max, self, delta, belong;
	NODE *l, *r, *father;
};

int N, M, depth[maxn], list[maxn*2], head[maxn], tail[maxn];
vector<int> son[maxn];
NODE f[maxn*2], *root;
// depth, list and son only affect in initialization.

inline void PUSH(NODE *x)
{
	if (x->l) x->l->min+=x->delta, x->l->max+=x->delta, x->l->self+=x->delta, x->l->delta+=x->delta;
	if (x->r) x->r->min+=x->delta, x->r->max+=x->delta, x->r->self+=x->delta, x->r->delta+=x->delta;
	x->delta=0;
}

inline void PULL(NODE *x)
{
	x->min=x->max=x->self;
	if (x->l) x->min=min(x->min,x->l->min), x->max=max(x->max,x->l->max);
	if (x->r) x->min=min(x->min,x->r->min), x->max=max(x->max,x->r->max); 
}

void Dfs(int x)
{
	static int DFN;
	list[++DFN]=x;
	head[x]=DFN;
	for (vector<int>::iterator i=son[x].begin();i!=son[x].end();i++)
	{
		depth[*i]=depth[x]+1;
		Dfs(*i);
		list[++DFN]=x;
	}
	tail[x]=DFN;
}

NODE *mkTree(int l, int r, NODE *last)
{
	if (l>r) return 0;
	int mid((l+r)>>1);
	f[mid].father=last;
	f[mid].min=f[mid].max=f[mid].self=depth[list[mid]];
	f[mid].belong=list[mid];
	f[mid].l=mkTree(l,mid-1,f+mid);
	f[mid].r=mkTree(mid+1,r,f+mid);
	PULL(f+mid);
	return f+mid;
}

void Init()
{
	for (int i=1;i<=N;i++)
	{
		int num;
		for (READ(num);num;num--)
		{
			int x;
			READ(x);
			son[i].push_back(x);
		}
	}
	depth[0]=-1;
	Dfs(1);
	root=mkTree(0,2*N,0);
}

inline void RR(NODE *x)
{
	NODE *tmp=x->l;
	if (x->father) if (x==x->father->l) x->father->l=tmp; else x->father->r=tmp;
	tmp->father=x->father;
	x->father=tmp;
	if (tmp->r) tmp->r->father=x;
	x->l=tmp->r;
	tmp->r=x;
	PULL(x), PULL(tmp);
}

inline void LR(NODE *x)
{
	NODE *tmp=x->r;
	if (x->father) if (x==x->father->l) x->father->l=tmp; else x->father->r=tmp;
	tmp->father=x->father;
	x->father=tmp;
	if (tmp->l) tmp->l->father=x;
	x->r=tmp->l;
	tmp->l=x;
	PULL(x), PULL(tmp);
}

void Splay(NODE *x, NODE *tml=0)
{
	while (x->father!=tml)
		if (x->father->father==tml)
		{
			PUSH(x->father), PUSH(x);
			if (x==x->father->l) RR(x->father); else LR(x->father);
		} else
		{
			PUSH(x->father->father), PUSH(x->father), PUSH(x);
			if (x==x->father->l && x->father==x->father->father->l)
				RR(x->father->father), RR(x->father);
			else
			if (x==x->father->l && x->father==x->father->father->r)
				RR(x->father), LR(x->father);
			else
			if (x==x->father->r && x->father==x->father->father->l)
				LR(x->father), RR(x->father);
			else
				LR(x->father->father), LR(x->father);
		}
	if (!tml) root=x;
}

NODE *findMin(NODE *x, int v)
{
	PUSH(x);
	if (x->r && x->r->min<=v) return findMin(x->r,v);
	if (x->self==v) return x;
	return findMin(x->l,v);
}

NODE *findMax(NODE *x, int v)
{
	PUSH(x);
	if (x->r && x->r->max>=v) return findMax(x->r,v);
	if (x->self==v) return x;
	return findMax(x->l,v);
}

NODE *LEFT(NODE *x) { while (x->l) x=x->l; return x; }
NODE *RIGHT(NODE *x) { while (x->r) x=x->r; return x; }

int main()
{
	READ(N), READ(M);
	Init();
	for (;M;M--)
	{
		int type, x, y;
		READ(type);
		switch (type)
		{
			NODE *front, *back, *tree;
			case 1:
				int d1, d2, d3;
				READ(x), READ(y);
				if (x==y) { printf("0\n"); continue; }
				Splay(f+head[x]), d1=f[head[x]].self;
				Splay(f+head[y]), d2=f[head[y]].self;
				Splay(f+head[x],f+head[y]);
				if (f+head[x]==f[head[y]].l) front=f+head[x]; else front=f+head[y];
				Splay(f+tail[y]), Splay(f+tail[x],f+tail[y]);
				if (f+tail[x]==f[tail[y]].l) back=f+tail[y]; else back=f+tail[x];
				Splay(front), front=RIGHT(front->l), Splay(front);
				Splay(back,front), back=LEFT(back->r), Splay(back,front);
				d3=back->l->min;
				printf("%d\n",d1+d2-2*d3);
				break;
			case 2:
				int ast, tmp;
				READ(x), READ(y);
				Splay(f+head[x]);
				ast=findMin(f[head[x]].l,f[head[x]].self-y)->belong;
				front=RIGHT(f[head[x]].l), Splay(front);
				Splay(f+tail[x],front);
				back=LEFT(f[tail[x]].r), Splay(back,front);
				if (f+tail[back->belong]==back) tail[back->belong]=front-f;
				tmp=back-f;
				back=LEFT(back->r), Splay(back,front);
				tree=back->l;
				tree->delta-=y-1, tree->min-=y-1, tree->max-=y-1, tree->self-=y-1;
				back->l=0, tree->father=0, PULL(back), PULL(front);
				Splay(f+tail[ast]), back=LEFT(f[tail[ast]].r), Splay(back,f+tail[ast]);
				back->l=tree, tree->father=back, PULL(back), PULL(f+tail[ast]);
				tail[ast]=tmp, f[tmp].belong=ast;
				break;
			case 3:
				READ(x);
				printf("%d\n",findMax(root,x)->belong);
		}
	}
	return 0;
}
