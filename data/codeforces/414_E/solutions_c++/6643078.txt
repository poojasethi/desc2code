#include <cstdlib>
#include <cctype>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <fstream>
#include <numeric>
#include <iomanip>
#include <bitset>
#include <list>
#include <stdexcept>
#include <functional>
#include <utility>
#include <ctime>
#include <cassert>
#include <complex>
using namespace std;
#define rep(i,a,n) for (int i=a;i<(int)n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
#define ACCU accumulate
#define TWO(x) (1<<(x))
#define TWOL(x) (1ll<<(x))
#define clr(a) memset(a,0,sizeof(a))
#define POSIN(x,y) (0<=(x)&&(x)<n&&0<=(y)&&(y)<m)
typedef vector<int> VI;
typedef vector<string> VS;
typedef vector<double> VD;
typedef long long ll;
typedef long double LD;
typedef pair<int,int> PII;
typedef pair<ll,ll> PLL;
typedef vector<ll> VL;
typedef vector<PII> VPII;
typedef complex<double> CD;
const int inf=0x20202020;
const ll mod=1000000007;
const double eps=1e-9;
const double pi=3.1415926535897932384626;
const int DX[]={1,0,-1,0},DY[]={0,1,0,-1};
ll powmod(ll a,ll b) {ll res=1;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll powmod(ll a,ll b,ll mod) {ll res=1;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}

int f[101000];
struct node {
	node *s[2],*f;
	int id,pv,sm,mind,maxd;
	void clear() { s[0]=s[1]=f=0;}
	bool dir() { return f->s[1]==this;}
	void setc(node *p,int d) { if (p) p->f=this; s[d]=p;}
	void push() {
	}
	void upd() {
		sm=0; mind=inf; maxd=-inf;
		if (s[0]) mind=min(mind,sm+s[0]->mind),maxd=max(maxd,sm+s[0]->maxd),sm+=s[0]->sm;
		mind=min(mind,sm+pv),maxd=max(maxd,sm+pv);sm+=pv;
		if (s[1]) mind=min(mind,sm+s[1]->mind),maxd=max(maxd,sm+s[1]->maxd),sm+=s[1]->sm;
	}
};
const int N=201000;
node pool[N],*cur=pool;
stack<node*> tra;
node *newnode() {
	if (!tra.empty()) {
		node *q=tra.top();
		tra.pop();
		return q;
	} else return cur++;
}
void dispose(node *x) { x->clear();tra.push(x);}

struct Splaytree {
	node *rt;
	void dfs_init(node *x) { if (x) { dfs_init(x->s[0]),dfs_init(x->s[1]);dispose(x);} }
	void init() { dfs_init(rt); rt=0;}
	void rot(node *x) {
		node *p=x->f;
		bool d=x->dir();
		if (p->f) p->f->setc(x,p->dir()); else x->f=p->f;
		p->setc(x->s[!d],d); x->setc(p,!d);
		if (p==rt) rt=x;
		p->upd();
	}
	void splay(node *x,node *f=NULL) {
		node *q=x; stack<node*> sta;
		while (1) { sta.push(q);if (!q->f) break; q=q->f; }
		while (!sta.empty()) sta.top()->push(),sta.pop();
		while (x->f!=f) {
			if (x->f->f==f) rot(x);
			else if (x->dir()==x->f->dir()) rot(x->f),rot(x);
			else rot(x),rot(x);
		}
		x->upd();
	}
	node *prev(node *x) {
		assert(x);
		splay(x);
		node *p=x->s[0];
		if (!p) return 0;
		while (p->s[1]) p=p->s[1];
		return p;
	}
	node *succ(node *x) {
		assert(x);
		splay(x);
		node *p=x->s[1];
		if (!p) return 0;
		while (p->s[0]) p=p->s[0];
		return p;
	}
	void insert(node *x,node *p) {
		splay(x);
		if (!x->s[1]) { x->setc(p,1);x->upd();}
		else {
			splay(succ(x),x);
			x->s[1]->setc(p,0);
			x->s[1]->upd(); x->upd();
		}
	}
	void insert(node *x) {
		if (!rt) rt=x;
		else { node *p=rt; while (p->s[1]) p=p->s[1]; p->setc(x,1);}
		splay(x);
	}
	node* extract(node *l,node *r) {
		node *pl=prev(l),*pr=succ(r);
		assert(pl); assert(pr);
		splay(pl);splay(pr,pl);
		node *p=pr->s[0];
		return p;
	}
	node* split(node *l,node *r) {
		node *p=extract(l,r);
		p->f->s[p->dir()]=0;
		p->f->upd();
		p->f=0;
		return p;
	}
	void dfs_debug(node *x) {
		if (x->s[0]) dfs_debug(x->s[0]);
		printf("%d %d\n",x->id,x->pv);
		if (x->s[1]) dfs_debug(x->s[1]);
	}
	void print() { puts("DEBUG");dfs_debug(rt); puts("");}
	int query(node *p,int dep) {
		int sm=(p->s[0]?p->s[0]->sm:0)+p->pv;
		if (p->s[1]&&sm+p->s[1]->mind<=dep&&sm+p->s[1]->maxd>=dep)
			return query(p->s[1],dep-sm);
		if (sm==dep) { if (p->pv==1) return p->id; else return f[p->id];}
		return query(p->s[0],dep);
	}
}T;

int n,q,u,v,ty;
VI s[N];
node *l[N],*r[N];
int getdep(int u) { T.splay(l[u]); return 1+(l[u]->s[0]?l[u]->s[0]->sm:0);}
int query(node *p,int dep) { T.splay(p); return T.query(T.rt->s[0],dep);}
int getf(int u,int dep) {
	if (dep==0) return u;
	else return query(l[u],getdep(u)-dep);
}
int lca(int u,int v) {
	if (u==1||v==1) return 1;
	if (u==v) return u;
	T.splay(l[u]);T.splay(l[v],l[u]);
	if (!(l[v]->dir())) swap(u,v);
	return getf(u,1-T.extract(l[u],l[v])->mind);
}
void dfs(int u) {
	l[u]=newnode();l[u]->id=u;l[u]->pv=1;
	T.insert(l[u]);
	rep(i,0,SZ(s[u])) dfs(s[u][i]);
	r[u]=newnode();r[u]->id=u;r[u]->pv=-1;
	T.insert(r[u]);
}

int main() {
	scanf("%d%d",&n,&q);
	rep(i,1,n+1) {
		scanf("%d",&u);
		rep(j,0,u) { scanf("%d",&v); s[i].pb(v); f[v]=i;}
	}
	dfs(1);
	rep(i,0,q) {
		scanf("%d",&ty);
		if (ty==1) {
			scanf("%d%d",&u,&v);
			int w=lca(u,v);
			printf("%d\n",getdep(u)+getdep(v)-2*getdep(w));
		} else if (ty==2) {
			scanf("%d%d",&u,&v);
			int w=getf(u,v); f[u]=w;
			node *p=T.split(l[u],r[u]);
			T.insert(T.prev(r[w]),p);
		} else {
			scanf("%d",&u);
			printf("%d\n",query(r[1],u+1));
		}
	}
}