#!/usr/bin/env python
#-*- coding:utf-8 -*-

from itertools import combinations, product

n = int(raw_input())
rmax = 0
lmin = 100000
intervals = []
for _ in xrange(n):
    l, r = map(int, raw_input().split())
    rmax = max(rmax, r)
    lmin = min(lmin, l)
    intervals.append((l, r))
INDS = range(len(intervals))


def prob_smaller_equal(ints, val):
    res = 1.0
    for l, r in ints:
        d = min(val + 1 - l, r + 1 - l)
        if d <= 0:
            return 0.0
        res *= float(d) / (r + 1 - l)
        if res == 0.0:
            return 0.0
    return res


def prob_smaller(ints, val):
    res = 1.0
    for l, r in ints:
        d = min(val - l, r + 1 - l)
        if d <= 0:
            return 0.0
        res *= float(d) / (r + 1 - l)
        if res == 0.0:
            return 0.0
    return res


def prob_greater(ints, val):
    res = 1.0
    for l, r in ints:
        d = min(r - val, r + 1 - l)
        if d <= 0:
            return 0.0
        res *= float(d) / (r + 1 - l)
        if res == 0.0:
            return 0.0
    return res


def prob_equal(ints, val):
    res = 1.0
    for l, r in ints:
        if not (l <= val <= r):
            return 0.0
        res *= 1.0 / (r + 1 - l)
    return res


def combos(ints, minn, maxn):
    for ntie in xrange(minn, maxn + 1):
        for c in combinations(ints, r=ntie):
            yield c


def prod(cache, inds, price):
    res = 1.0
    for i in inds:
        res *= cache[i][price]
        if res == 0.0:
            return 0.0
    return res


cache_smaller = [[0] * 10002 for _ in xrange(5)]
cache_smaller_equal = [[0] * 10002 for _ in xrange(5)]
cache_equal = [[0] * 10002 for _ in xrange(5)]
cache_greater = [[0] * 10002 for _ in xrange(5)]
for i, (l, r) in enumerate(intervals):
    for price in xrange(1, rmax + 1):
        cache_smaller[i][price] = prob_smaller([(l, r)], price)
        cache_smaller_equal[i][price] = prob_smaller_equal([(l, r)], price)
        cache_equal[i][price] = prob_equal([(l, r)], price)
        cache_greater[i][price] = prob_greater([(l, r)], price)

res = 0
for price in xrange(lmin, rmax + 1):
    # case 1: 1 larger  1+ equal  * smaller
    add2 = (
        prod(cache_smaller_equal, INDS, price)
        - prod(cache_smaller, INDS, price)
    )
    for ind1 in INDS:
        other = [i for i in INDS if i != ind1]
        pr_other_smaller = prod(cache_smaller, other, price)
        res += (
            price *
            cache_greater[ind1][price] *
            (
                prod(cache_smaller_equal, other, price) -
                pr_other_smaller
            )
        )
        add2 -= cache_equal[ind1][price] * pr_other_smaller

    # case 2: 0 larger  2+ equal  * smaller
    res += price * add2

print res
