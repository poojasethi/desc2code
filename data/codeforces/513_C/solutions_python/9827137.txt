#!/usr/bin/env python
#-*- coding:utf-8 -*-

from itertools import combinations, product

n = int(raw_input())
rmax = 0
intervals = []
for _ in xrange(n):
    l, r = map(int, raw_input().split())
    rmax = max(rmax, r)
    intervals.append((l, r))


def prob_smaller_equal(ints, val):
    res = 1.0
    for l, r in ints:
        d = min(val + 1 - l, r + 1 - l)
        if d <= 0:
            return 0.0
        res *= float(d) / (r + 1 - l)
        if res == 0.0:
            return 0.0
    return res


def prob_smaller(ints, val):
    res = 1.0
    for l, r in ints:
        d = min(val - l, r + 1 - l)
        if d <= 0:
            return 0.0
        res *= float(d) / (r + 1 - l)
        if res == 0.0:
            return 0.0
    return res


def prob_greater(ints, val):
    res = 1.0
    for l, r in ints:
        d = min(r - val, r + 1 - l)
        if d <= 0:
            return 0.0
        res *= float(d) / (r + 1 - l)
        if res == 0.0:
            return 0.0
    return res


def prob_equal(ints, val):
    res = 1.0
    for l, r in ints:
        if not (l <= val <= r):
            return 0.0
        res *= 1.0 / (r + 1 - l)
    return res


def combos(ints, minn, maxn):
    for ntie in xrange(minn, maxn + 1):
        for c in combinations(ints, r=ntie):
            yield c

cache_smaller = [[0] * 10002 for _ in xrange(5)]
cache_equal = [[0] * 10002 for _ in xrange(5)]
cache_greater = [[0] * 10002 for _ in xrange(5)]
for i, (l, r) in enumerate(intervals):
    for price in xrange(1, 10001):
        cache_smaller[i][price] = prob_smaller([(l, r)], price)
        cache_equal[i][price] = prob_equal([(l, r)], price)
        cache_greater[i][price] = prob_greater([(l, r)], price)
# print

INTINDS = range(len(intervals))


def prod(cache, inds, price):
    res = 1.0
    for i in inds:
        res *= cache[i][price]
        if res == 0.0:
            return 0.0
    return res

res = 0
# for price in xrange(1, rmax + 1):
#     # print price
#     for poses in product(range(3), repeat=len(intervals)):
#         # print poses
#         # 0 smaller 1 equal 2 greater
#         smaller = [i for i in INTINDS if poses[i] == 0]
#         equal = [i for i in INTINDS if poses[i] == 1]
#         greater = [i for i in INTINDS if poses[i] == 2]
#         if len(greater) > 1:
#             continue

#         add = 1.0
#         if len(greater) == 0:
#             if len(equal) <= 1:
#                 continue
#             add *= prod(cache_smaller, smaller, price)
#             add *= prod(cache_equal, equal, price)
#         else:
#             add *= prod(cache_smaller, smaller, price)
#             add *= prod(cache_equal, equal, price)
#             add *= cache_greater[greater[0]][price]
#         res += add * price
# print res
# quit()


for i_int1 in INTINDS:
    for i_ints2_tie in combos(INTINDS, 1, n - 1):
        if i_int1 in i_ints2_tie:
            continue
        i_other = [i for i in INTINDS if i not in i_ints2_tie and i != i_int1]

        for price in xrange(1, rmax + 1):
            add = (
                prod(cache_smaller, i_other, price) *
                prod(cache_equal, i_ints2_tie, price) *
                prod(cache_greater, [i_int1], price)
            )
            res += add * price

# print

for i_ints1_tie in combos(INTINDS, 2, n):
    i_other = [i for i in INTINDS if i not in i_ints1_tie]
    for price in xrange(1, rmax + 1):
        add = (
            prod(cache_smaller, i_other, price) *
            prod(cache_equal, i_ints1_tie, price)
        )
        res += add * price

print res
