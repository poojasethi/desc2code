#!/usr/bin/env python
#-*- coding:utf-8 -*-

from itertools import combinations, product

n = int(raw_input())
rmax = 0
intervals = []
for _ in xrange(n):
    l, r = map(int, raw_input().split())
    rmax = max(rmax, r)
    intervals.append((l, r))
INDS = range(len(intervals))


def prob_smaller_equal(ints, val):
    res = 1.0
    for l, r in ints:
        d = min(val + 1 - l, r + 1 - l)
        if d <= 0:
            return 0.0
        res *= float(d) / (r + 1 - l)
        if res == 0.0:
            return 0.0
    return res


def prob_smaller(ints, val):
    res = 1.0
    for l, r in ints:
        d = min(val - l, r + 1 - l)
        if d <= 0:
            return 0.0
        res *= float(d) / (r + 1 - l)
        if res == 0.0:
            return 0.0
    return res


def prob_greater(ints, val):
    res = 1.0
    for l, r in ints:
        d = min(r - val, r + 1 - l)
        if d <= 0:
            return 0.0
        res *= float(d) / (r + 1 - l)
        if res == 0.0:
            return 0.0
    return res


def prob_equal(ints, val):
    res = 1.0
    for l, r in ints:
        if not (l <= val <= r):
            return 0.0
        res *= 1.0 / (r + 1 - l)
    return res


def combos(ints, minn, maxn):
    for ntie in xrange(minn, maxn + 1):
        for c in combinations(ints, r=ntie):
            yield c


def prod(cache, inds, price):
    res = 1.0
    for i in inds:
        res *= cache[i][price]
        if res == 0.0:
            return 0.0
    return res


def all_splits2():
    for ind1 in INDS:
        other = [i for i in INDS if i != ind1]
        yield intervals[ind1], [intervals[i] for i in other]

res = 0
for price in xrange(1, rmax + 1):
    # case 1: 1 larger  1+ equal  * smaller
    for int, jnts in all_splits2():
        res += price * prob_greater([int], price) * (prob_smaller_equal(jnts, price) - prob_smaller(jnts, price))

    # case 2: 0 larger  2+ equal  * smaller
    for i in INDS:
        int = intervals[i]
        for j in xrange(i + 1, len(intervals)):
            jnt = intervals[j]
            smaller = [intervals[ii] for ii in xrange(j) if ii != i]
            smaller_equal = [intervals[ii] for ii in xrange(j + 1, len(intervals))]
            assert len(smaller) + len(smaller_equal) + 2 == len(intervals)
            res += (
                price *
                prob_equal([int, jnt], price) *
                prob_smaller(smaller, price) *
                prob_smaller_equal(smaller_equal, price)
            )

print res
