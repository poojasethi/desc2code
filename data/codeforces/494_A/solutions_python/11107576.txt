import sys
from collections import defaultdict, Counter
from itertools import permutations, combinations
from math import sin, cos, asin, acos, tan, atan, pi

sys.setrecursionlimit(10 ** 6)

def pyes_no(condition, yes = "YES", no = "NO", none = "-1") :
  if condition == None:
    print (none)
  elif condition :
    print (yes)
  else :
    print (no)

def plist(a, s = ' ') :
  print (s.join(map(str, a)))

def rint() :
  return int(sys.stdin.readline())

def rstr() :
  return sys.stdin.readline().strip()


def rints() :
  return map(int, sys.stdin.readline().split())

def rfield(n, m = None) :
  if m == None :
    m = n
  
  field = []
  for i in xrange(n) :
    chars = sys.stdin.readline().strip()
    assert(len(chars) == m)
    field.append(chars)
  return field

def pfield(field, separator = '') :
  print ('\n'.join(map(lambda x: separator.join(x), field)))

def check_field_equal(field, i, j, value) :
  if i >= 0 and i < len(field) and j >= 0 and j < len(field[i]) :
    return value == field[i][j]
  return None 

def digits(x, p) :
  digits = []
  while x > 0 :
    digits.append(x % p)
    x //= p
  return digits[::-1]

def undigits(x, p) :
  value = 0
  for d in x :
    value *= p
    value += d
  return value

def modpower(a, n, mod) :
  r = a ** (n % 2)
  if n > 1 :
    r *= modpower(a, n // 2, mod) ** 2
  return r % mod

def gcd(a, b) :
  if a > b :
    a, b = b, a
  
  while a > 0 :
    a, b = b % a, a

  return b

def vector_distance(a, b) :
  diff = vector_diff(a, b)
  
  return scalar_product(diff, diff) ** 0.5

def vector_inverse(v) :
  r = [-x for x in v]

  return tuple(r)

def vector_diff(a, b) :
  return vector_sum(a, vector_inverse(b))

def vector_sum(a, b) :
  r = [c1 + c2 for c1, c2 in zip(a, b)]
    
  return tuple(r)

def scalar_product(a, b) :
  r = 0
  for c1, c2 in zip(a, b) :
    r += c1 * c2

  return r

def check_rectangle(points) :
  assert(len(points) == 4)

  A, B, C, D = points

  for A1, A2, A3, A4 in [
    (A, B, C, D),
    (A, C, B, D),
    (A, B, D, C),
    (A, C, D, B),
    (A, D, B, C),
    (A, D, C, B),
  ] :
    sides = (
      vector_diff(A1, A2),
      vector_diff(A2, A3),
      vector_diff(A3, A4),
      vector_diff(A4, A1),
    )
    if all(scalar_product(s1, s2) == 0 for s1, s2 in zip(sides, sides[1:])) :
       return True
  return False

def check_square(points) :
  if not check_rectangle(points) :
    return False
  A, B, C, D = points

  for A1, A2, A3, A4 in [
    (A, B, C, D),
    (A, C, B, D),
    (A, B, D, C),
    (A, C, D, B),
    (A, D, B, C),
    (A, D, C, B),
  ] :
    side_lengths = [
      (first[0] - next[0]) ** 2 + (first[1] - next[1]) ** 2 for first, next in zip([A1, A2, A3, A4], [A2, A3, A4, A1])
    ]
    if len(set(side_lengths)) == 1 :
      return True
    
  return False

def check_right(p) :
  # Check if there are same points
  for a, b in [
    (p[0], p[1]),
    (p[0], p[2]),
    (p[1], p[2]),
  ] :
    if a[0] == b[0] and a[1] == b[1] :
      return False

  a, b, c = p
  a, b, c = vector_diff(a, b), vector_diff(b, c), vector_diff(c, a)   

  return scalar_product(a, b) * scalar_product(a, c) * scalar_product(b, c) == 0

def modmatrixproduct(a, b, mod) :
  n, m1 = len(a), len(a[0])
  m2, k = len(b), len(b[0])

  assert(m1 == m2)
  m = m1

  r = [[0] * k for i in range(n)]
  for i in range(n) :
    for j in range(k) :
      for l in range(m) :
        r[i][j] += a[i][l] * b[l][j]
      r[i][j] %= mod
  return r

def modmatrixpower(a, n, mod) :
  magic = 2
  for m in [2, 3, 5, 7] :
    if n % m == 0 :
      magic = m
      break

  r = None
  if n < magic : 
    r = a
    n -= 1
  else :
    s = modmatrixpower(a, n // magic, mod)
    r = s
    for i in range(magic - 1) :
      r = modmatrixproduct(r, s, mod)

  for i in range(n % magic) : 
    r = modmatrixproduct(r, a, mod)
  
  return r

s = rstr()
chars = Counter(s)
last = chars['('] - chars[')'] - chars['#']

if last < 0 :
  print -1
  exit(0)

count = 0
left = chars['#']
for c in s :
  if c == '(' :
    count += 1
  elif c == ')' :
    count -= 1
  elif c == '#' :
    if left == 1 :
      count -= last
    count -= 1
    left -= 1

  if count < 0 :
    print -1
    exit(0)


plist([1] * (chars['#'] - 1) + [last + 1], '\n')
