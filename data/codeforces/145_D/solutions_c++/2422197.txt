
// Codeforces Round #104 (Div. 1) D Lucky Pair

#include <algorithm>
#include <cstring>
#include <cstdio>
#include <vector>
#include <map>
#include <set>

using namespace std;

long long c[100003][5];
int a[100000];

int main() {
	int n;
	scanf("%d", &n);
	for (int i = 0; i < n; i ++) scanf("%d", &a[i]);
	
	vector<int> lucky;
	map< int, vector<int> > L;
	for (int i = 0; i < n; i ++) {
		int tmp = a[i];
		bool flag = true;
		while (tmp > 0) {
			if (tmp % 10 != 4 && tmp % 10 != 7) {
				flag = false;
				break;
			}
			tmp /= 10;
		}
		if (flag) {
			lucky.push_back(i);
			L[a[i]].push_back(i);
		}
	}
	
	memset(c, 0, sizeof(c));
	c[0][0] = 1;
	for (int i = 1; i <= n + 2; i ++) {
		c[i][0] = 1;
		for (int j = 1; j <= 4; j ++)
			c[i][j] = c[i - 1][j] + c[i - 1][j - 1];
	}
	long long ans = c[n + 2][4];
	int m = lucky.size();
	for (int i = 0; i < m - 1; i ++) {
		set<int> check, seq;
		long long sum = 0;
		seq.insert(lucky[i]);
		seq.insert(n);
		for (int j = i; j >= 0; j --) {
			if (check.find(a[lucky[j]]) == check.end()) {
				int tmp = a[lucky[j]];
				check.insert(tmp);
				for (int k = 0; k < L[tmp].size(); k ++)
					if (L[tmp][k] > lucky[i]) {
						set<int>::iterator p = seq.insert(L[tmp][k]).first;
						set<int>::iterator t1 = p, t2 = p;
						t1 --;
						t2 ++;
						if (t1 != seq.begin()) {
							sum += (long long)(*p - *t1) * (*t2 - *p) * (lucky[i + 1] - lucky[i]);
						} else {
							sum += (long long)(*t2 - *p) * (lucky[i + 1] - lucky[i] + 1) * (lucky[i + 1] - lucky[i]) / 2;
							sum += (long long)(*t2 - *p) * (*p - lucky[i + 1]) * (lucky[i + 1] - lucky[i]);
						}
					}
			}
			if (j > 0) {
				ans -= sum * (lucky[j] - lucky[j - 1]);
			} else {
				ans -= sum * (lucky[j] + 1);
			}
		}
	}
	
	printf("%I64d\n", ans);
	
	return 0;
}
