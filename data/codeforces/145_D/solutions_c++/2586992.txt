#include <cstdio>
#include <cstring>
#include <set>
#include <map>
#include <vector>
#include <algorithm>

using namespace std;

typedef long long LL;

const int maxn = 100010;
int n, cnt, lcnt, a[maxn], p[maxn], s[maxn];
bool add[1010];
LL ans;
set<int> S;
map<int, int> M;
vector<int> list[1010];

int main(){
	scanf("%d", &n);
	LL T[] = {n + 2, n + 1, n, n - 1};
	for (int i = 4; i > 1; i--) for (int j = 0; j < 4; j++) if (T[j] % i == 0){T[j] /= i; break;}
	ans = T[0] * T[1] * T[2] * T[3];
	for (int i = 1; i <= n; i++){
		scanf("%d", a + i);
		bool lucky = true; int num = a[i];
		while (num){
			if (num % 10 != 4 && num % 10 != 7){
				lucky = false;
				break;
			}
			num /= 10;
		}
		if (lucky){
			p[++cnt] = i;
			if (M.find(a[i]) == M.end()) M[a[i]] = lcnt++;
			list[M[a[i]]].push_back(i);
		}
	}
	p[++cnt] = n + 1;
	for (int i = 0; i < lcnt; i++) sort(list[i].begin(), list[i].end());

	for (int j = 1; j < cnt; j++){
		memset(add, false, sizeof(add));
		S.clear(); S.insert(0); S.insert(n + 1);
		for (int i = j; i; i--){
			int cur = M[a[p[i]]], k; LL ways_l = p[i], ways_r = p[j + 1] - p[j];
			if (add[cur]) continue;
			add[cur] = true;
			k = upper_bound(list[cur].begin(), list[cur].end(), p[j]) - list[cur].begin();
			int now = list[cur][k];
			set<int>::iterator r = S.lower_bound(now), l;
			for (; k < (int)list[cur].size(); k++){
				now = list[cur][k];
				while (*r < now) r++;
				l = r; --l;
				if (*l == 0) ans -= (now + now - p[j] - p[j + 1] + 1) * ways_r / 2 * (*r - now) * ways_l;
				else ans -= (now - *l) * (*r - now) * ways_l * ways_r;
				S.insert(now);
			}
		}
	}

	printf("%I64d\n", ans);
}
