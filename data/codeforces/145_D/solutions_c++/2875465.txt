// 补集 平衡树
// 補集合 平衡2分探索木(へいこうにぶんたんさくぎself-balancing binary search tree)

#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<set>
using namespace std;

void Get(int &T)
{
	char C;bool F=0;
	for(;C=getchar(),C<'0'||C>'9';)if(C=='-')F=1;
	for(T=C-'0';C=getchar(),C>='0'&&C<='9';T=T*10+C-'0');
	F&&(T=-T);
}

int A[100005];

bool Lucky(int X)
{
	for(;X;X/=10)
	{
		if(X%10!=4&&X%10!=7) return 0;
	}
	return 1;
}

int Pos[1005];
int N,M;

long long Ans;

void Init()
{
	Get(N);
	for(int i=1;i<=N;i++)
	{
		Get(A[i]);
		if(Lucky(A[i]))
		{
			Pos[++M]=i;
		}
		Ans+=(long long)(i-1)*(long long)(i+1)*(long long)(i)/6;
	}
}

int Next[1005];

set<int> Set;

int Visited[1005];
int Time;

void Work()
{
	for(int i=1;i<=M;i++)
		for(int j=i+1;j<=M;j++)
			if(A[Pos[i]]==A[Pos[j]])
			{
				Next[i]=j;
				break;
			}
	
	for(int i=1;i<=M;i++)
	{
		Time++;
		
		Set.clear();
		Set.insert(N+1);
		for(int j=i;j<=M;j++)
		{
			if(Visited[j]==Time) continue;
			
			set<int>::iterator p=Set.insert(Pos[j]).first;
			
			
			for(int k=Next[j];k;k=Next[k])
			{
				Visited[k]=Time;
				set<int>::iterator q=Set.insert(Pos[k]).first;
				set<int>::iterator Left=q;
				set<int>::iterator Right=Left;
				Right++;Left--;
				
				Ans-=((long long)(*q-*p+*Left+1-*p)*(long long)(*q-*Left)/2)*(long long)(*Right-*q)*(long long)(Pos[i]-Pos[i-1]);
			}
		}
	}
}

void Output()
{
	printf("%I64d\n",Ans);
}

int main()
{
	Init();
	Work();
	Output();
	return 0;
}