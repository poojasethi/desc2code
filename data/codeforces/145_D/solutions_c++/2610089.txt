#include<stdio.h>
#include<set>
#include<algorithm>
#include<tr1/unordered_map>
#include<tr1/unordered_set>
using namespace std;
using namespace tr1;
int getint()
{
	int ret=0;bool ok=false,neg=true;
	for(;;)
	{
		int c=getchar();
		if(c>='0'&&c<='9'){ret=(ret<<3)+ret+ret+c-'0',ok=true;if(c!='4'&&c!='7')neg=false;}
		else if(ok)return neg?ret:0;
	}
}
int n;
const int maxn=100010;
int a[maxn];
typedef long long ll;
ll sn[maxn],sn2[maxn],sn3[maxn];
unordered_map<int,int> M;
unordered_set<int> vis;
struct edge
{
	int v;
	edge *n;
};
edge EPool[maxn],*ep=EPool,*g[maxn];
inline void addedge(int u,int v)
{
	ep->v=v,ep->n=g[u],g[u]=ep++;
}
int nn,val[maxn];
ll ans;
set<int> S;
typedef set<int>::iterator iter;
typedef set<int>::reverse_iterator riter;
void work(int l)
{
	vis.clear();
	S.clear();
	S.insert(0);
	int L=val[l],m=val[l-1];
	S.insert(m+1);
	ll t=sn[m];
	for(int i=l;i<=nn;i++)
	{
		if(!vis.count(a[val[i]]))
		{
			vis.insert(a[val[i]]);
			for(edge *j=g[M[a[val[i]]]];j;j=j->n)if(j->v<=m)
			{
				int pos=j->v;
				if(S.count(pos))continue;
				S.insert(pos);
				iter p=S.find(pos),pl=p,pr=p;
				pl--,pr++;
				t-=sn[*pr-*pl-1];
				t+=sn[pos-*pl-1]+sn[*pr-pos-1];
			}
		}
		ans+=t*(L-m)*(val[i+1]-val[i]);
		riter p=S.rbegin();
		p++;
		int mm=*p;
		ans+=(sn2[m]-sn2[L]+(sn[L]-sn[m])*(mm+L)-(ll)mm*L*(L-m))*(val[i+1]-val[i]);
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)a[i]=getint();
	for(int i=1;i<=n;i++)sn[i]=sn[i-1]+i,sn2[i]=sn2[i-1]+(ll)i*i,sn3[i]=sn3[i-1]+(ll)i*i*i;
	for(int i=1;i<=n;i++)if(a[i])
	{
		int t=a[i];
		val[++nn]=i;
		if(!M[t])M[t]=nn;
		addedge(M[t],i);
	}
	val[nn+1]=n+1;
	for(int i=nn;i;i--)work(i);
	int last=n+1;
	for(int i=n;i;i--)if(a[i])last=i;
	else ans+=(ll)(last-i)*sn[i-1];
	printf("%I64d\n",ans);
	return 0;
}
