#include <bits/stdc++.h>
using namespace std;

int N,M,tx,ty,mx,my;
int maze [1000] [1000];
bool visited [4] [1000] [1000];
enum maze_type{
	UP = 1,RIGHT = 2,DOWN = 4,LEFT = 8
};
typedef pair< pair<int,int> , pair<int,int> > piiii;
int dx [] = {0,1,0,-1};
int dy [] = {-1,0,1,0};

int get_dir(char ch){
	switch(ch){
		case '+':
			return UP + RIGHT + DOWN + LEFT;
		case '-':
			return RIGHT + LEFT;
		case '|':
			return UP + DOWN;
		case '^':
			return UP;
		case '>':
			return RIGHT;
		case '<':
			return LEFT;
		case 'v':
			return DOWN;
		case 'L':
			return UP + RIGHT + DOWN;
		case 'R':
			return UP + DOWN + LEFT;
		case 'U':
			return RIGHT + DOWN + LEFT;
		case 'D':
			return UP + RIGHT + LEFT;
		case '*':
			return 0;
	}
}

bool in_range(int y,int x){
	return y >= 0 && y < N && x >= 0 && x < M;
}

int bfs()
{
	queue<piiii> q;
	q.push(piiii(make_pair(0,0),make_pair(ty,tx)));
	
	while(q.empty() != true){
		int y = q.front().second.first;
		int x = q.front().second.second;
		int cost = q.front().first.first;
		int turn = q.front().first.second;
		q.pop();
		
		if(visited [turn] [y] [x] == true){
			continue;
		}
		if(y == my && x == mx){
			return cost;
		}
		visited [turn] [y] [x] = true;
		
		for(int i = 0;i < 4;i++){
			int yy = y + dy [i],xx = x + dx [i];
			if(in_range(yy,xx)){
				if((maze [y] [x] & (1 << (i - turn + 4) % 4)) && (maze [yy] [xx] & (1 << (i - turn + 4 + 2) % 4))){
					q.push(piiii(make_pair(cost + 1,turn),make_pair(yy,xx)));
				}
			}
		}
		q.push(piiii(make_pair(cost + 1,(turn + 1) % 4),make_pair(y,x)));
	}
	
	return -1;
}

int main()
{
	char C;
	
	cin.tie(0);
	ios::sync_with_stdio(false);

	cin >> N >> M;
	for(int i = 0;i < N;i++){
		for(int j = 0;j < M;j++){
			cin >> C;
			maze [i] [j] = get_dir(C);
		}
	}
	cin >> ty >> tx;
	cin >> my >> mx;
	ty--,tx--,my--,mx--;
	
	cout << bfs() << endl;

	return 0;
}