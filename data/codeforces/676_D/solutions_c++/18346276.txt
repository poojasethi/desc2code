#include <bits/stdc++.h>
using namespace std;

int N,M;
int maze [1000] [1000];
bool visited [4] [1000] [1000];
int tx,ty,mx,my;
int dx [] = {0,1,0,-1};
int dy [] = {-1,0,1,0};

enum{
	UP = 1,RIGHT = 2,DOWN = 4,LEFT = 8
};

int get_num(char ch){
	switch(ch){
		case '+':
			return UP + RIGHT + DOWN + LEFT;
		case '-':
			return RIGHT + LEFT;
		case '|':
			return UP + DOWN;
		case '^':
			return UP;
		case '>':
			return RIGHT;
		case '<':
			return LEFT;
		case 'v':
			return DOWN;
		case 'L':
			return UP + RIGHT + DOWN;
		case 'R':
			return UP + DOWN + LEFT;
		case 'U':
			return RIGHT + DOWN + LEFT;
		case 'D':
			return UP + RIGHT + LEFT;
		case '*':
			return 0;
	}
}

bool in_range(int y,int x)
{
	return y >= 0 && y < N && x >= 0 && x < M;
}

int bfs()
{
	queue< pair<int,int> > q;
	q.push(make_pair(0,tx * 1000 + ty));
	
	while(q.empty() != true){
		int y = q.front().second % 1000;
		int x = (q.front().second / 1000) % 1000;
		int turn = q.front().second / 1000000;
		int cost = q.front().first;
		q.pop();
		
		if(visited [turn] [y] [x] == true){
			continue;
		}
		visited [turn] [y] [x] = true;
		if(y == my && x == mx){
			return cost;
		}
		
		for(int i = 0;i < 4;i++){
			int yy = y + dy [i],xx = x + dx [i];
			if(in_range(yy,xx)){
				if((maze [y] [x] & (1 << (i - turn + 4) % 4)) && maze [yy] [xx] & (1 << (i - turn + 4 + 2) % 4)){
					q.push(make_pair(cost + 1,turn * 1000000 + xx * 1000 + yy));
				}
			}
		}
		
		q.push(make_pair(cost + 1,((turn + 1) % 4) * 1000000 + x * 1000 + y));
	}
	
	return -1;
}

int main()
{
	cin.tie(0);
	ios::sync_with_stdio(false);

	cin >> N >> M;
	for(int i = 0;i < N;i++){
		for(int j = 0;j < M;j++){
			char C;
			cin >> C;
			maze [i] [j] = get_num(C);
		}
	}
	cin >> ty >> tx >> my >> mx;
	ty--,tx--,my--,mx--;
	
	cout << bfs() << endl;

	return 0;
}