#include <cstdio>
#include <algorithm>
using namespace std;
const int logN=32,M=(int)5e4+5;
int n,m,k,tk;
struct tree{
	int cov,s;
	tree *l,*r;
} mem[M*logN*3],*newtree=mem;
tree *root=newtree++;
int L,R,D;
void update(tree* cur,int beg,int end){
	if(cur->cov)
		cur->s=end^beg;
	else
		cur->s=(cur->l?cur->l->s:0)^(cur->r?cur->r->s:0);
}
void cover(tree* &cur,int beg,int end){
	if(R<=beg||L>=end) return;
	if(!cur) cur=newtree++;
	if(L<=beg&&R>=end)
		cur->cov+=D;
	else{
		int mid=beg+end>>1;
		cover(cur->l,beg,mid);
		cover(cur->r,mid,end);
	}
	update(cur,beg,end);
}
struct data{
	int x,l,r,d;
	bool operator < (const data &A) const{
		return x<A.x;
	}
} seq[M*2],*newdata=seq;

int main(){
	scanf("%d%d%d",&n,&m,&tk);
	for(k=0;(1<<k)<=tk;k++);
	k--;
	while(m--){
		int a,b,c,d; scanf("%d%d%d%d",&a,&b,&c,&d);
		a--,b--;
		*newdata++=(data){a,b,d, 1};
		*newdata++=(data){c,b,d,-1};
	}
	sort(seq,newdata);
	int ans=0;
	for(int i=0;i<newdata-seq;i++){
		if(i){
			int s=seq[i].x^seq[i-1].x,sum=0,now=root->s;
			s^=s>>1;
			now^=now>>1;
//			printf("i=%d x0=%d x1=%d s=%d now=%d\n",i,seq[i-1].x,seq[i].x,s,now);
			for(int j=29;j>=0;j--){
				if(now>>(j+1)&1)
					now^=3<<j;
				if(s>>j&1) sum^=now;
			}
			ans^=sum;
		}
		L=seq[i].l,R=seq[i].r,D=seq[i].d;
		cover(root,0,n);
	}
	for(int i=29;i>=k;i--){
		if(ans>>(i+1)&1)
			ans^=3<<i;
	}
	puts(ans?"Hamed":"Malek");
}
