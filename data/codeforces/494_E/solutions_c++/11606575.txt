#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<cstdlib>
#include<ctime>
#include<cassert>
#include<cctype>
#include<climits>
#include<bitset>
#include<deque>
#include<list>
#include<map>
#include<queue>
#include<set>
#include<stack>
#include<vector>
#include<complex>
#include<functional>
#include<utility>
#include<sstream>
#include<fstream>
using namespace std;

template<typename T>
inline bool maxit(T& a,const T& b) {
    if(a<b) {
        a=b;
        return true;
    }
    return false;
}

template<typename T>
inline bool minit(T& a,const T& b) {
    if(a>b) {
        a=b;
        return true;
    }
    return false;
}

typedef long long LL;

inline LL gint() {
    char c=getchar();
    int f=1;
    while(c<'0'||c>'9') {
        if(c=='-') {
            f=-1;
        }
        c=getchar();
    }
    LL a=c-'0';
    while((c=getchar())>='0'&&c<='9') {
        a=a*10+c-'0';
    }
    return a*f;
}

#define MP make_pair
#define PB push_back
#define fi first
#define se second
#define foreach(it,x) for(typeof((x).begin()) it=(x).begin(),_end_=(x).end();it!=_end_;++it)
#define REP(i,n) for(int i=0,_end_=(n);i<_end_;i++)
#define FOR(i,l,r) for(int i=(l),_end_=(r);i<=_end_;i++)
#define PER(i,r,l) for(int i=(r),_beg_=(l);i>=_beg_;i--)
#define Sz(x) (int((x).size()))
#define Al(x) (x).begin(),(x).end()
#define wa(x) cerr<<#x<<" "<<x<<endl
#define _Poi const Poi&
#define _Vec const Vec&
#define _Line const Line&
#define clr(x) memset((x),0,sizeof((x)))
#define low(x) ((x)&(-(x)))
#define Ret(x,y) if(x<y)return 1; else if(x>y)return 0

const int maxm=50010;

struct Event {
    int x,y1,y2,type;
    Event() {}
    Event(int x,int y1,int y2,int type):x(x),y1(y1),y2(y2),type(type) {}
    inline bool operator < (const Event& rhs) const {
        return x<rhs.x||(x==rhs.x&&type>rhs.type);
    }
};

Event ev[maxm<<1];
int vn,gbit;

struct Node *pit,*null;
struct Node {
    int s,a;
    Node* ch[2];
    inline Node() {
        ch[0]=ch[1]=null;
    }
    inline void* operator new(size_t) {
        return pit++;
    }
    inline void maintain(int l,int r) {
        if(a) {
            s=r^(l-1);
        } else {
            s=ch[0]->s^ch[1]->s;
        }
    }
}pool[3000000],*root;

inline void init_null() {
    pit=pool;
    null=new Node();
    null->s=0;
    null->ch[0]=null->ch[1]=null;
    root=null;
}

int ql,qr,val;
void update(Node*& o,int l,int r) {
    if(o==null) {
        o=new Node();
    }
    if(ql<=l&&r<=qr) {
        o->a+=val;
    } else {
        int mid=(l+r)>>1;
        if(ql<=mid) {
            update(o->ch[0],l,mid);
        }
        if(mid<qr) {
            update(o->ch[1],mid+1,r);
        }
    }
    o->maintain(l,r);
}

int SG;

inline void calc(int lx,int rx) {//xx有这么一个性质l xor (l+1) xor (l+2) xor ... xor r == r xor (l-1)xx没这个性质
    int xval=rx^(lx-1),yval=root->s;
    for(int i=0;i<30;i++) {
        int x=(xval>>i)&1,y=(yval>>i)&1;
        if(x&&y) {
            SG^=min(gbit,1<<i);
            if(i) {
                SG^=min(gbit,1<<(i-1));
            }
        }
    }
}

int n,m,mxk;

int main() {
    init_null();
    n=gint();
    m=gint();
    mxk=gint();
    for(gbit=1;gbit<=mxk;gbit<<=1);
    gbit>>=1;
    for(int i=0;i<m;i++) {
        int x1=gint(),y1=gint(),x2=gint(),y2=gint();
        ev[vn++]=Event(x1,y1,y2,1);
        ev[vn++]=Event(x2+1,y1,y2,-1);
    }
    sort(ev,ev+vn);
    for(int i=0;i<vn;i++) {
        if(i&&ev[i].x!=ev[i-1].x) {
            calc(ev[i-1].x,ev[i].x-1);//ev[i].x还没算进去
        }
        ql=ev[i].y1;
        qr=ev[i].y2;
        val=ev[i].type;
        update(root,1,n);
    }
    puts(SG?"Hamed":"Malek");
    return 0;
}

