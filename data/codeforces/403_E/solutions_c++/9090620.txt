#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
using namespace std;
int HEAD[1048576],tree[1048576][2],NEXT[16181005],E[16181005],chang[16181005],head[800005],next[800005],e[800005],L[800005],R[800005];
int rr,r,s[200005],S[200005],fa[400005][21],dp[400005],p[200005][2],X,Y,A[200005],B[200005],i,j,LG,n,Time,V[200005][2],o,O,cnt,q;
bool v[400005];
struct node {int x,y,z;} t[800005];
void add(int a,int b,int c)
{
    e[a]=c;
    next[a]=head[b];
    head[b]=a;
}
void dfs(int x,int y)
{
    L[x]=++Time;
    dp[x]=y;
    int now=head[x];
    while (now!=0)
    {
        if (!v[e[now]]) {v[e[now]]=true; fa[e[now]][0]=x;dfs(e[now],y+1);}
        now=next[now];
    }
    R[x]=Time;
}
int LCA(int a,int b)
{
    if (dp[a]<dp[b]) swap(a,b);
    if (dp[a]>dp[b])
    {
        int LG=int(log(dp[a]-dp[b])/log(2)+0.0000000001);
        for (int i=LG; i>=0; i--) if (dp[fa[a][i]]>=dp[b]) a=fa[a][i];
    }
    int LG=int(log(dp[a])/log(2)+0.0000000001);
    for (int i=LG; i>=0; i--) if (fa[a][i]!=fa[b][i]) {a=fa[a][i]; b=fa[b][i];}
    if (a==b) return a; else return fa[a][0];
}
int cmp(node i,node j) {return i.x>j.x;}
int CMP(int i,int j) {return i<j;}
void work(int root,int l,int r)
{
    if (tree[root][0]==l && tree[root][1]==r)
    {
        while (HEAD[root] && chang[HEAD[root]]<dp[Y])
        {
            if (V[E[HEAD[root]]][X^1]) HEAD[root]=NEXT[HEAD[root]]; else
            {
                S[++rr]=E[HEAD[root]];
                V[E[HEAD[root]]][X^1]=1;
                HEAD[root]=NEXT[HEAD[root]];
            }
        }
        return;
    }
    int mid=(tree[root][0]+tree[root][1])/2;
    if (l<=mid) work(root*2,l,min(mid,r));
    if (r>mid) work(root*2+1,max(mid+1,l),r);
}
void add2(int a,int b,int c,int d)
{
    E[a]=c;
    NEXT[a]=HEAD[b];
    HEAD[b]=a;
    chang[a]=d;
}
int main()
{
    scanf("%d",&n);
    for (i=1; i<=n; i++) p[i][0]=++cnt;
    for (i=1; i<=n; i++) p[i][1]=++cnt;
    for (i=2; i<=n; i++)
    {
        scanf("%d",&A[i]);
        add(++o,p[i][0],p[A[i]][0]);
        add(++o,p[A[i]][0],p[i][0]);
    }
    for (i=2; i<=n; i++)
    {
        scanf("%d",&B[i]);
        add(++o,p[i][1],p[B[i]][1]);
        add(++o,p[B[i]][1],p[i][1]);
    }
    for (i=1; i<=cnt; i++) v[i]=false; v[p[1][0]]=v[p[1][1]]=true;
    dfs(p[1][0],1); dfs(p[1][1],1);
    LG=int(log(n)/log(2)+0.000000001);
    for (i=1; i<=LG; i++)
      for (j=1; j<=cnt; j++) fa[j][i]=fa[fa[j][i-1]][i-1];
    o=0;
    for (i=2; i<=n; i++)
    {
        q=LCA(p[i][1],p[A[i]][1]);
        t[++o].x=dp[q]; t[o].y=p[i][1]; t[o].z=i-1;
        t[++o].x=dp[q]; t[o].y=p[A[i]][1]; t[o].z=i-1;
        q=LCA(p[i][0],p[B[i]][0]);
        t[++o].x=dp[q]; t[o].y=p[i][0]; t[o].z=i-1;
        t[++o].x=dp[q]; t[o].y=p[B[i]][0]; t[o].z=i-1;
    }
    sort(t+1,t+o+1,cmp);
    for (i=524288; i<1048576; i++) tree[i][0]=tree[i][1]=i;
    for (i=524287; i>=1; i--) {tree[i][0]=tree[i*2][0]; tree[i][1]=tree[i*2+1][1];}
    for (i=1; i<=o; i++)
    {
        q=524287+L[t[i].y];
        while (q)
        {
            add2(++O,q,t[i].z,t[i].x);
            q/=2;
        }
    }
    scanf("%d",&X); V[X][0]=1;
    r=1; s[1]=X; X=1;
    while (r)
    {
        X^=1;
        if (!X) printf("Blue\n"); else printf("Red\n");
        sort(s+1,s+r+1,CMP); printf("%d",s[1]);
        for (i=2; i<=r; i++) printf(" %d",s[i]); rr=0;
        printf("\n");
        for (i=1; i<=r; i++)
        {
            if (!X)
            {if (dp[p[A[s[i]+1]][0]]<dp[p[s[i]+1][0]]) Y=p[s[i]+1][0]; else Y=p[A[s[i]+1]][0]; } else
            {if (dp[p[B[s[i]+1]][1]]<dp[p[s[i]+1][1]]) Y=p[s[i]+1][1]; else Y=p[B[s[i]+1]][1];}
            work(1,L[Y]+524287,R[Y]+524287);
        }
        for (i=1; i<=rr; i++) s[i]=S[i];
        r=rr;
    }
    return 0;
}
