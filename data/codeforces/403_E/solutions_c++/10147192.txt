#include<cstdio>
#include<algorithm>
#include<vector>
#define pb push_back
#define N 800005
#define S 20000005
using namespace std;
int son[2][N],fa[2][N],f[2][N],pre[2][N],deep[2][N];
int heavy[2][N],top[2][N],tmp_id[N],id[N],b[2][N];
struct road{int go,next;}A[2][N],a[2][S];int End[2][N],end[2][N*2],Cnt[2],cnt[2];
int n,i,Times,x,y,now,j,o,p,q,node,tot;
inline void read(int &x)
{
  char ch=getchar();x=0;
  for (;ch<'0'||ch>'9';ch=getchar());
  for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';
}
#define son son[o]
#define f f[o]
#define A A[o]
#define top top[o]
#define heavy heavy[o]
#define deep deep[o]
#define a a[o]
#define b b[o]
#define pre pre[o]
#define cnt cnt[o]
#define Cnt Cnt[o]
#define End End[o]
#define end end[o]
inline void adda(int u,int v){a[++cnt]=(road){v,end[u]};end[u]=cnt;}
inline void addA(int u,int v){A[++Cnt]=(road){v,End[u]};End[u]=Cnt;}
void dfs1(int k)
{
  son[k]=1;
  for (int i=End[k];i;i=A[i].next)
  {
    int go=A[i].go;if (go==f[k]) continue;
    f[go]=k;deep[go]=deep[k]+1;dfs1(go);son[k]+=son[go];
    if (!heavy[k]||son[go]>son[heavy[k]]) heavy[k]=go;
  }
}
void dfs2(int k,int Num)
{
  top[k]=Num;pre[k]=++tot;
  if (heavy[k]) dfs2(heavy[k],Num);
  for (int i=End[k];i;i=A[i].next)
  {
    int go=A[i].go;
    if (go!=f[k]&&heavy[k]!=go) dfs2(go,go);
  }
}
void insert(int k,int l,int r)  //p~q insert node
{
  if (p<=l&&r<=q){adda(k,node);return;}
  int mid=(l+r)>>1;
  if (p<=mid) insert(k<<1,l,mid);
  if (q>mid) insert(k<<1|1,mid+1,r);
}
void ask(int k,int l,int r) 
{
  for (int i=end[k];i;i=a[i].next)
  {
    int t=a[i].go;o^=1;if (!b[t]) b[t]=1,tmp_id[++tmp_id[0]]=t;o^=1;
  }
  end[k]=0;
  if (l==r) return;int mid=(l+r)>>1;
  if (p<=mid) ask(k<<1,l,mid);else ask(k<<1|1,mid+1,r);
}
inline int Cut_tree(int x,int y)
{
  node=x;int LCA=0,LCAT,tx=x,ty=y;
  while (top[x]!=top[y])
  {
    if (deep[top[x]]<deep[top[y]]) swap(x,y);
    x=f[top[x]];
  }
  LCA=(deep[x]>deep[y])?y:x;LCAT=top[LCA];x=tx;y=ty;
  while (top[x]!=LCAT) p=pre[top[x]],q=pre[x],insert(1,1,n),x=f[top[x]];
  while (top[y]!=LCAT) p=pre[top[y]],q=pre[y],insert(1,1,n),y=f[top[y]];
  p=pre[LCA]+1;q=pre[x];if (p<=q) insert(1,1,n);q=pre[y];if (p<=q) insert(1,1,n);
}
void dfs3(int k)
{
  for (int i=End[k];i;i=A[i].next)
  {
    int go=A[i].go;if (go==f[k]) continue;
    o^=1;Cut_tree(go,k);o^=1;dfs3(go);
  }
} 
int main()
{
  read(n);o=0;
  for (i=2;i<=n;i++)
    read(x),addA(x,i),addA(i,x);
  o=1;
  for (i=2;i<=n;i++)
    read(x),addA(x,i),addA(i,x);
  o=0;dfs1(1);
  dfs2(1,1);tot=0;
  o=1;dfs1(1);dfs2(1,1);
  o=0;dfs3(1);
  o=1;dfs3(1);
  read(id[1]);id[0]=1;o=0;b[++id[1]]=1;
  while (true)
  {
    puts(o?"Red":"Blue");tmp_id[0]=0;
    sort(id+1,id+id[0]+1);
    for (i=1;i<=id[0];i++)
    {
      printf("%d ",id[i]-1);
      p=pre[id[i]];ask(1,1,n);
    }
    id[0]=tmp_id[0];o^=1;
    for (i=1;i<=id[0];i++) id[i]=tmp_id[i];
    puts("");if (!id[0]) break;
  }
}
