#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#include<vector>
#include<set>
#define pr pair<int, int>
#define mp make_pair
#define sd second
#define ft first
#define MAXN 200005	
#define MAXL 19
using namespace std ;

int N, M ;
struct road {
	int x, next ;
} ;
struct Tree {
	road r[MAXN] ;
	int st[MAXN], w ;
	int deep[MAXN], go[MAXN][MAXL] ;
	int show[MAXN][2], p[MAXN], pt ;
	int ql, qr, q1 ;	
	pr mn[MAXN*4], q2 ;
	set< pr > have[MAXN*4] ;
	
	void Dfs(int x, int fr)
	{
		int tmp, i ;
		deep[x] = deep[fr]+1 ;
		go[x][0] = fr ;
		for(i = 1; i <= 18; i ++)
			go[x][i] = go[go[x][i-1]][i-1] ;
		show[x][0] = ++pt, p[pt] = x ;
		for(i = st[x]; i; i = r[i].next)
			if((tmp=r[i].x) != fr)
				Dfs(tmp, x) ;
		show[x][1] = pt ;
	}
	int lca(int x, int y)
	{
		int i ;
		if(deep[x] < deep[y]) swap(x, y) ;
		for(i = 18; i >= 0; i --)
			if(deep[x]-(1<<i) >= deep[y])
				x = go[x][i] ;
		if(x == y) return x ;
		for(i = 18; i >= 0; i --)
			if(go[x][i] != go[y][i])
				x = go[x][i], y = go[y][i] ;
		return go[x][0] ;
	}
	void Trans(int now, int l, int r)
	{
		int mid = (l+r)/2 ;
		if(l == r) 
		{
			if(q1 == 1)	have[now].insert(q2) ;
			else have[now].erase(q2) ;
			if(have[now].empty()) mn[now] = mn[0] ;
			else mn[now] = *have[now].begin() ;
			return ;
		}
		if(ql <= mid) Trans(now*2, l, mid) ;
		else Trans(now*2+1, mid+1, r) ;
		mn[now] = min(mn[now*2], mn[now*2+1]) ; 
	}
	pr Ask(int now, int l, int r)
	{
		int mid = (l+r)/2 ;
		pr get = mn[0] ;	
		if(ql <= l && r <= qr)
			return mn[now] ;
		if(ql <= mid) get = min(get, Ask(now*2, l, mid)) ;
		if(qr > mid) get = min(get, Ask(now*2+1, mid+1, r)) ;
		return get ;
	}
	void add(int x, int y)
	{
		r[++w].x = y, r[w].next = st[x] ;
		st[x] = w ;
	}
	void Ins(int x, int y, int k, int flag)
	{
		int tmp = lca(x, y) ;
		ql = show[x][0], q1 = flag, q2 = mp(deep[tmp], k) ;
		Trans(1, 1, N) ;
		ql = show[y][0], q1 = flag, q2 = mp(deep[tmp], k) ;	
		Trans(1, 1, N) ;
	}
	pr Query(int x) 
	{
		ql = show[x][0], qr = show[x][1] ;
		return Ask(1, 1, N) ;
	}
} T[2] ;

bool cmp(int x,int y){return x>y;}
vector<int> del[2] ;
int flag, cnt ;
int main()
{
	int i, j, fr, to, tmp, get ;
	pr tp ;
	//freopen("1.in", "r", stdin) ;
	scanf("%d", &N) ;
	memset(T[0].mn, 62, sizeof(T[0].mn)) ;
	memset(T[1].mn, 62, sizeof(T[1].mn)) ;
	for(i = 2; i <= N; i ++)
		scanf("%d", &to), T[0].add(to, i) ;
	for(i = 2; i <= N; i ++)
		scanf("%d", &to), T[1].add(to, i) ;
	T[0].Dfs(1, 0), T[1].Dfs(1, 0) ;
	for(i = 1; i <= N; i ++)
	{
		T[0].Ins(i+1, T[1].go[i+1][0], i, 1) ;
		T[1].Ins(i+1, T[0].go[i+1][0], i, 1) ;
	}
	scanf("%d", &tmp), del[0].push_back(tmp) ;
	T[1].Ins(tmp+1, T[0].go[tmp+1][0], tmp, 0) ;
	for(cnt, flag = 1; flag; cnt ^= 1)
	{
		printf("%s\n", cnt?"Red":"Blue") ;
		flag = 0 ;
		sort(del[cnt].begin(), del[cnt].end(), cmp) ;
		del[cnt^1].resize(0) ;
		while(del[cnt].size())
		{
			tmp = del[cnt].back(), del[cnt].pop_back() ;
			fr = tmp+1, to = T[cnt].go[fr][0] ;
			if(T[cnt].deep[fr] < T[cnt].deep[to]) swap(fr, to) ;
			printf("%d ", tmp) ;
			while(true)
			{
				tp = T[cnt].Query(fr) ;
				if(tp.ft >= T[cnt].deep[fr]) break ;
				flag = 1, del[cnt^1].push_back(tmp=tp.sd) ;
				T[cnt].Ins(tmp+1, T[cnt^1].go[tmp+1][0], tmp, 0) ;
			}
		}
		printf("\n") ;
	}
	//system("pause") ;
	return 0 ;
}
