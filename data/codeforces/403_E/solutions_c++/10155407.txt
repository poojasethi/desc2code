#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

#define X   first
#define Y   second
#define n   800005
#define MK  make_pair
#define Pii pair<int,int>
#define CH  (ch=getchar())
#define For(i,a,b)  for(int i=a;i<=b;i++)

int     N,M,F[n],G[n];

int     IN(){
        int x=0,ch;
        for (;CH<'0'||ch>'9';);
        for (;ch>='0'&&ch<='9';CH)  (x*=10)+=ch-'0';
        return  x;
}

struct  Tree{
        int C,D,x[n],y[n],V[n],L[n],R[n],st[n],A[n][2],P[n][2];
        struct  Lin{int v,next;}E[n];
        vector<Pii>B[n];

        void    Link(int u,int v){
            E[++D]=(Lin){v,st[u]};  st[u]=D;
            E[++D]=(Lin){u,st[v]};  st[v]=D;
        }
        void    DFS(int u,int f){
            A[u][0]=++C;
            for (int i=st[u],v;i;i=E[i].next)
                if  ((v=E[i].v)^f)  DFS(v,u);   A[u][1]=C;
        }

        void    INS(int x,Pii t){
            for (x+=M;x;x>>=1)  B[x].push_back(t),R[x]++;
        }
        void    Work(int k,int a,int b){
            for (int t;L[k]<=R[k]&&B[k][L[k]].X<a;L[k]++)
                if  (!V[t=B[k][L[k]].Y])    V[t]=1,G[++*G]=t;
            for (int t;L[k]<=R[k]&&B[k][R[k]].X>b;R[k]--)
                if  (!V[t=B[k][R[k]].Y])    V[t]=1,G[++*G]=t;
        }
        void    Find(int a,int b){
            for (int l=M+a-1,r=M+b+1;l^r^1;l>>=1,r>>=1){
                if  (l&1^1) Work(l^1,a,b);
                if  (r&1)   Work(r^1,a,b);
            }
        }

        void    Pre(){
            For(i,1,N-1)    Link(x[i]=IN(),y[i]=i+1);   DFS(1,0);
            For(i,1,N-1)    P[i][0]=max(A[x[i]][0],A[y[i]][0]),
                            P[i][1]=min(A[x[i]][1],A[y[i]][1]);
        }
        void    Work(){
            For(i,1,N-1)    INS(x[i],MK(y[i],i)),INS(y[i],MK(x[i],i));
            For(i,1,M+N)    sort(B[i].begin(),B[i].end()),R[i]--;
        }
}T[2];

int     main(){
        for (N=IN(),M=1;M<=N+1;M<<=1);
        T[0].Pre(); T[1].Pre();
        For(w,0,1)  For(i,1,N-1)
            T[w].x[i]=T[w^1].A[T[w].x[i]][0],T[w].y[i]=T[w^1].A[T[w].y[i]][0];
        T[0].Work();T[1].Work();    T[0].V[F[*F=1]=IN()]=1;

        for (int w=0;*F;w^=1,*G=0){
            puts(w?"Red":"Blue");   sort(F+1,F+*F+1);
            For(i,1,*F) printf("%d ",F[i]); puts("");
            For(i,1,*F) T[w^1].Find(T[w].P[F[i]][0],T[w].P[F[i]][1]);
            *F=*G;      For(i,1,*F) F[i]=G[i];
        }
}