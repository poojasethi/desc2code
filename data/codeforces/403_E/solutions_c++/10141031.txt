#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

const int N=200005;

typedef pair<int,int> pii;

#define fi first
#define se second

int n;

int len;
pii seq[N],tmp[N];

typedef pair<int,bool> pib;
vector<int> memson[2][N];
vector<pib> memson2[2][N];
typedef vector<pib>::iterator pibiter;

struct tree{
	int L,R;
	int fa[N];
	vector<int> *son;
	vector<pib> *son2;
	pibiter head[N],tail[N];
	int ind,st[N],en[N],dfq[N];
	int mi[N*4],ma[N*4],vi[N*4],va[N*4];
	#define calcmi(u) (head[u]<tail[u]?head[u]->fi:N)
	#define calcma(u) (head[u]<tail[u]?(tail[u]-1)->fi:-N)
	void add1(int x,int y){
		fa[y]=x;
		son[x].push_back(y);
	}
	void add2(int x,int y){
		son2[x].push_back(pib(y,false));
	}
	void dfs(int u){
		st[u]=ind;
		for(vector<int>::iterator e=son[u].begin();e!=son[u].end();e++){
			int v=*e;
			dfs(v);
		}
		en[u]=++ind;
		dfq[ind]=u;
	}
	void update(int cur){
		if(vi[cur<<1]<vi[cur<<1|1])
			mi[cur]=mi[cur<<1],
			vi[cur]=vi[cur<<1];
		else
			mi[cur]=mi[cur<<1|1],
			vi[cur]=vi[cur<<1|1];
		if(va[cur<<1]>va[cur<<1|1])
			ma[cur]=ma[cur<<1],
			va[cur]=va[cur<<1];
		else
			ma[cur]=ma[cur<<1|1],
			va[cur]=va[cur<<1|1];
	}
	void build(int cur,int beg,int end){
		if(end-beg==1){
			mi[cur]=ma[cur]=dfq[end];
			vi[cur]=calcmi(dfq[end]);
			va[cur]=calcma(dfq[end]);
			return;
		}
		int mid=beg+end>>1;
		build(cur<<1,beg,mid);
		build(cur<<1|1,mid,end);
		update(cur);
	}
	pii querymi(int cur,int beg,int end){
		if(end<=L||beg>=R) return pii(0,N);
		if(L<=beg&&R>=end) return pii(mi[cur],vi[cur]);
		int mid=beg+end>>1;
		pii x=querymi(cur<<1,beg,mid),y=querymi(cur<<1|1,mid,end);
		if(x.se<y.se)
			return x;
		else
			return y;
	}
	pii queryma(int cur,int beg,int end){
		if(end<=L||beg>=R) return pii(0,-N);
		if(L<=beg&&R>=end) return pii(ma[cur],va[cur]);
		int mid=beg+end>>1;
		pii x=queryma(cur<<1,beg,mid),y=queryma(cur<<1|1,mid,end);
		if(x.se>y.se)
			return x;
		else
			return y;
	}
	void renew(int cur,int beg,int end){
		if(end-beg==1){
			vi[cur]=calcmi(mi[cur]);
			va[cur]=calcma(ma[cur]);
			return;
		}
		int mid=beg+end>>1;
		if(R<=mid)
			renew(cur<<1,beg,mid);
		else	
			renew(cur<<1|1,mid,end);
		update(cur);
	}
	void del(int x,int y){
		pibiter it=lower_bound(head[x],tail[x],pib(en[y],false));
		it->se=true;
		while(head[x]<tail[x]&&head[x]->se) head[x]++;
		while(head[x]<tail[x]&&(tail[x]-1)->se) tail[x]--;
		R=en[x];
		renew(1,0,n);
	}
	void init(){
		dfs(1);
		for(int i=0;i<=n;i++){
			for(pibiter it=son2[i].begin();it!=son2[i].end();it++) it->fi=en[it->fi];
			sort(son2[i].begin(),son2[i].end());
			head[i]=son2[i].begin();
			tail[i]=son2[i].end();
		}
		build(1,0,n);
	}
	void work(int x,int y){
		if(fa[y]==x) swap(x,y);
		while(true){
			L=st[x],R=en[x];
			int u=querymi(1,0,n).fi,v=calcmi(u);
			if(v>st[x]) break;
			v=dfq[v];
			seq[len++]=pii(u,v);
			del(u,v);
			del(v,u);
		}
		while(true){
			L=st[x],R=en[x];
			int u=queryma(1,0,n).fi,v=calcma(u);
			if(v<=en[x]) break;
			v=dfq[v];
			seq[len++]=pii(u,v);
			del(u,v);
			del(v,u);
		}
	}
} a[2];

int main(){
	a[0].son=memson[0];
	a[0].son2=memson2[0];
	a[1].son=memson[1];
	a[1].son2=memson2[1];
	scanf("%d",&n);
	for(int i=2;i<=n;i++){
		int x;
		scanf("%d",&x);
		a[0].add1(x,i);
		a[1].add2(x,i);
		a[1].add2(i,x);
	}
	for(int i=2;i<=n;i++){
		int x;
		scanf("%d",&x);
		a[1].add1(x,i);
		a[0].add2(x,i);
		a[0].add2(i,x);
	}
	a[0].init();
	a[1].init();
	int id; scanf("%d",&id); id++;
	seq[len++]=pii(id,a[0].fa[id]);
	a[1].del(seq[0].fi,seq[0].se);
	a[1].del(seq[0].se,seq[0].fi);
	int flag=0;
	while(len){
		int tmplen=len;
		memcpy(tmp,seq,sizeof(pii)*tmplen);
		len=0;
		for(int i=0;i<tmplen;i++)
			if(a[flag].fa[tmp[i].se]==tmp[i].fi) swap(tmp[i].fi,tmp[i].se);
		sort(tmp,tmp+tmplen);
		if(flag==0)
			puts("Blue");
		else
			puts("Red");
		for(int i=0;i<tmplen;i++)
			printf("%d%c",tmp[i].fi-1," \n"[i==tmplen-1]);
		for(int i=0;i<tmplen;i++)
			a[flag].work(tmp[i].fi,tmp[i].se);
		flag^=1;
	}
}