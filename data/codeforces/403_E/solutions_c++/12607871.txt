#include <algorithm>
#include <iostream>
#include <cassert>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <queue>
#include <map>
#include <set>

using namespace std;

#define type(x) __typeof((x).begin())
#define foreach(i, x) for(type(x) i = (x).begin(); i != (x).end(); i++)

typedef long long ll;
typedef pair < int, int > ii;

const int inf = 1e9 + 333;
const ll linf = 1e18 + 333;

const int N = 1 << 18;

class edge{ public:
    int x, y, id;
    edge() {
        x = y = id = 0;
    }
    edge(int _x, int _y, int _id) {
        x = _x, y = _y, id = _id;
    }
};

int n, sz;
bool h[2][N];
vector < int > del;
vector < int > v[2][N];
int vec[N], tm[2], st[2][N], nd[2][N], x[2][N], y[2][N], a[2][N];
edge e[N];

class node{ public:
    int ptr;
    vector < int > v;
    node() {
        ptr = 0;
        v.clear();
    }
    void add(int i) {
        v.push_back(i);
    }
    void del(int w, int l, int r) {
        while(ptr < v.size()) {
            int i = v.back();
            if(h[!w][i]) {
                v.pop_back();
                continue;
            }
            int x1 = st[w][x[!w][i]];
            int x2 = st[w][y[!w][i]];
            if((l <= x1 and x1 <= r) ^ (l <= x2 and x2 <= r)) {
                vec[sz++] = i;
                h[!w][i] = 1;
                v.pop_back();
            } else break;
        }
        while(ptr < v.size()) {
            int i = v[ptr];
            if(h[!w][i]) {
                ptr++;
                continue;
            }
            int x1 = st[w][x[!w][i]];
            int x2 = st[w][y[!w][i]];
            if((l <= x1 and x1 <= r) ^ (l <= x2 and x2 <= r)) {
                vec[sz++] = i;
                h[!w][i] = 1;
                ptr++;
            } else break;
        }
    }
};

class tree{ public:
    int id;
    node t[N << 1];
    void add(int x, int i) {
        //printf("id = %d x = %d i = %d\n", id, x, i);
        x += N;
        while(x >= 1) {
            t[x].add(i);
            x >>= 1;
        }
    }
    void del(int l, int r, int x, int y) {
        l += N;
        r += N;
        for(; l <= r; l >>= 1, r >>= 1) {
            if(l & 1)
                t[l++].del(id, x, y);
            if(~r & 1)
                t[r--].del(id, x, y);
        }
    }
}t[2][2];

void dfs(int w, int p, int x) {
    st[w][x] = ++tm[w];
    foreach(it, v[w][x]) {
        int u = *it;
        if(u != p)
            dfs(w, x, u);
    }
    nd[w][x] = tm[w];
}

bool cmpX(edge x, edge y) {
    return x.x < y.x;
}
bool cmpY(edge x, edge y) {
    return x.y < y.y;
}

int main () {
    
    t[0][0].id = t[0][1].id = 0;
    t[1][0].id = t[1][1].id = 1;
    
    scanf("%d", &n);
    
    for(int w = 0; w < 2; w++) {
        for(int i = 2; i <= n; i++) {
            x[w][i] = i;
            scanf("%d", y[w] + i);
            v[w][x[w][i]].push_back(y[w][i]);
            v[w][y[w][i]].push_back(x[w][i]);
        }
        dfs(w, -1, 1);
    }
    
    for(int w = 0; w < 2; w++) {
        for(int i = 2; i <= n; i++) {
            if(st[!w][x[w][i]] > st[!w][y[w][i]])
                swap(x[w][i], y[w][i]);
            e[i] = {st[!w][x[w][i]], st[!w][y[w][i]], i};
            //printf("w = %d i = %d st = %d nd = %d x = %d y = %d\n", w, i, e[i].x, e[i].y, x[w][i], y[w][i]);
        }
        sort(e + 2, e + n + 1, cmpX);
        for(int i = 2; i <= n; i++)
            t[!w][1].add(e[i].y, e[i].id);
        //puts("");
        sort(e + 2, e + n + 1, cmpY);
        for(int i = 2; i <= n; i++)
            t[!w][0].add(e[i].x, e[i].id);
    }
    
    int del_x = -1;
    bool col = 0;
    
    scanf("%d", &del_x);
    del_x++;
    
    del.push_back(del_x);
    
    while(del.size()) {
        puts(col ? "Red" : "Blue");
        sz = 0;
        foreach(it, del) {
            del_x = *it;
            printf("%d ", del_x - 1);
            h[col][del_x] = 1;
            int l = st[col][x[col][del_x]];
            int r = nd[col][x[col][del_x]];
            int l1 = st[col][y[col][del_x]];
            int r1 = nd[col][y[col][del_x]];
            if(l1 > l) {
                swap(l, l1);
                swap(r, r1);
            }
            //printf("l = %d r = %d\n", l, r);
            t[col][0].del(l, r, l, r);
            t[col][1].del(l, r, l, r);
        }
        puts("");
        col ^= 1;
        del.clear();
        sort(vec, vec + sz);
        for(int i = 0; i < sz; i++)
            del.push_back(vec[i]);
    }
    
    return 0;
    
}
