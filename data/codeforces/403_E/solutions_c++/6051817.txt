#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<fstream>
#include<map>
#include<ctime>
#include<set>
#include<queue>
#include<cmath>
#include<vector>
#include<bitset>
#include<functional>
#define x first
#define y second
#define mp make_pair
#define pb push_back
#define REP(i,l,r) for((i)=(l);(i)<=(r);++(i))
#define REP2(i,l,r) for((i)=(l);(i)!=(r);++(i))
using namespace std;

typedef long long LL;
typedef double ld;

const int MAX=200000+10;
const int NUM=23+10;

int n;

struct Tree
{
    vector< pair<int,int> > ne[MAX];
    int q[MAX],lab[MAX],ll[MAX],rr[MAX],top,deep[MAX];
    int p[NUM][MAX],link[MAX];

    int LCA(int u,int v)
    {
        if(deep[u]<deep[v])
            swap(u,v);
        int s=NUM-1;
        while(deep[u]!=deep[v])
        {
            while(s>0 && deep[ p[s][u] ]<deep[v])
                --s;
            u=p[s][u];
        }
        s=NUM-1;
        while(u!=v)
        {
            while(s>0 && p[s][u]==p[s][v])
                --s;
            u=p[s][u];
            v=p[s][v];
        }
        return u;
    }

    void dfs(int u,int fa)
    {
        int i,v;
        deep[u]=deep[fa]+1;
        p[0][u]=fa;

        q[++top]=u;
        ll[u]=top;
        REP2(i,0,(int)ne[u].size())
        {
            v=ne[u][i].x;
            if(v==fa)
                continue;
            lab[v]=ne[u][i].y;
            dfs(v,u);
        }
        rr[u]=top;
    }

    pair<int,int> mm[MAX*4];
    set< pair<int,int> > hash[MAX];
    int a[MAX],b[MAX],w[MAX];

    void build(int u,int l,int r)
    {
        if(l==r)
        {
            if(hash[l].size())
                mm[u]=*hash[l].begin();
            else mm[u]=mp(1e9,0);
        }
        else
        {
            int mid=(l+r)/2;
            build(u*2,l,mid);
            build(u*2+1,mid+1,r);
            mm[u]=min(mm[u*2+1],mm[u*2]);
        }
    }

    pair<int,int> ask(int u,int l,int r,int a,int b)
    {
        if(r<a || b<l)
            return mp(1e9,0);
        if(a<=l && r<=b)
            return mm[u];
        int mid=(l+r)/2;
        return min(ask(u*2,l,mid,a,b),ask(u*2+1,mid+1,r,a,b));
    }

    void del(int u,int l,int r,int a,pair<int,int> t)
    {
        if(l==r)
        {
            hash[l].erase(t);
            if(hash[l].size())
                mm[u]=*hash[l].begin();
            else mm[u]=mp(1e9,0);
        }
        else
        {
            int mid=(l+r)/2;
            if(a<=mid)
                del(u*2,l,mid,a,t);
            else
                del(u*2+1,mid+1,r,a,t);
            mm[u]=min(mm[u*2],mm[u*2+1]);
        }
    }

    void TreeRead()
    {
        int i;
        REP(i,2,n)
        {
            scanf("%d",&link[i]);
            ne[link[i]].pb(mp(i,i-1));
            ne[i].pb(mp(link[i],i-1));
        }
        deep[0]=0;
        top=0;
        dfs(1,0);

        for(int j=1;j<NUM;++j)
            REP(i,1,n)
                p[j][i]=p[j-1][ p[j-1][i] ];
    }

    void ins(int* father,int* lab)
    {
        int i;
        REP(i,2,n)
        {
            int u=lab[i];
            a[u]=i;
            b[u]=father[i];
            int lca=LCA(a[u],b[u]);
            w[u]=deep[lca];
            hash[ll[ a[u] ]].insert(mp(w[u],u));
            hash[ll[ b[u] ]].insert(mp(w[u],u));
        }
        build(1,1,n);
    }

    vector<int> get(vector<int> now)
    {
        int i;
        vector<int> ans;
        REP2(i,0,(int)now.size())
        {
            int l=now[i]+1;
            int r=link[ l ];
            if(deep[l]<deep[r])
                swap(l,r);
            pair<int,int> tmp;
            while((tmp=ask(1,1,n,ll[l],rr[l])).x<=deep[r])
            {
                int u=tmp.y;
                ans.pb(u);
                del(1,1,n,ll[a[u]],mp(w[u],u));
                del(1,1,n,ll[b[u]],mp(w[u],u));
            }
        }
        return ans;
    }
}t[2];

int main()
{
#ifndef ONLINE_JUDGE
    freopen("input.txt","r",stdin);freopen("output.txt","w",stdout);
#endif
    int i;
    scanf("%d",&n);
    REP2(i,0,2)
        t[i].TreeRead();
    REP2(i,0,2)
        t[i].ins(t[i^1].p[0],t[i^1].lab);
    int m;
    scanf("%d",&m);
    vector<int> s(1,m);
    for(i=0;s.size();++i)
    {
        if(i%2==0)
            printf("Blue\n");
        else printf("Red\n");
        sort(s.begin(),s.end());
        for(int j=0;j<(int)s.size();++j)
            printf("%d ",s[j]);
        printf("\n");
        s=t[i%2].get(s);
        for(int j=0;j<(int)s.size();++j)
            if(i%2==1 && s[j]==m)
                s.erase(s.begin()+j);
    }
    return 0;
}
