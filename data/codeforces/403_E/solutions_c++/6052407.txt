/*
 * temp.cpp
 *
 *  Created on: 2012-7-18
 *      Author: BSBandme
 */
//#pragma comment(linker, "/STACK:1024000000,1024000000")
#include <iostream>
#include <fstream>
#include <string.h>
#include <cstdio>
#include <algorithm>
#include <string>
#include <vector>
#include <queue>
#include <cassert>
#include <list>
#include <iomanip>
#include <math.h>
#include <deque>
#include <utility>
#include <map>
#include <set>
#include <bitset>
#include <numeric>
#include <climits>
#include <cctype>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <functional>
#include <sstream>

using namespace std;

#define mpr make_pair
typedef unsigned int ui;
typedef unsigned long long ull;
typedef long long ll;
typedef pair <int, int> pii;

#ifndef N
#define N 200100
#endif
vector <pii> init[2][N];
struct node {
	int deep, eno, no;
	node(int a = 0, int b = 0, int c = 0) :
		deep(a), eno(b), no(c) {}
	bool operator < (const node &a) const {
		return deep < a.deep;
	}
};
template <class t> struct segment_node{
	int be, en;
	t minv;
};
struct segment_tree{
	int l;
	segment_node <node> tree[N * 4];

	inline int gleft(int no) {return no << 1;}
	inline int gright(int no) {return (no << 1) + 1;}
	inline int gfa(int no) {return no >> 1;}
	inline segment_tree(){ l = 0; }

	void build(int no, int l, int r, vector <pii> *a){
		if(l > r) r = l;
		if(l == r){
			tree[no].be = tree[no].en = l;
			tree[no].minv = node(10000000, 0, l);
			if(a[l].size()) tree[no].minv = node(a[l][0].first, a[l][0].second, l);
			return;
		}
		tree[no].be = l; tree[no].en = r;
		int mid = (l + r) / 2;
		build(gleft(no), l, mid, a);
		build(gright(no), mid + 1, r, a);
		tree[no].minv = min(tree[gleft(no)].minv, tree[gright(no)].minv);
	}
	void down(int loc, int no, vector <pii> *a){
		if(loc <= tree[no].be && loc >= tree[no].en){
			tree[no].minv = node(100000000, 0, tree[no].be);
			a[loc].erase(a[loc].begin());
			if(a[loc].size()) tree[no].minv = node(a[loc][0].first, a[loc][0].second, tree[no].be);
			return;
		}
		int mid = (tree[no].be + tree[no].en) / 2;
		if(loc <= mid) down(loc, gleft(no), a);
		else down(loc, gright(no), a);
		tree[no].minv = min(tree[gleft(no)].minv, tree[gright(no)].minv);
	}
	node getmin(int l, int r, int no){
		if(l > r) return 0;
		if(l <= tree[no].be && r >= tree[no].en)
			return tree[no].minv;
		node ans = node(100000000, 0, -1);
		int mid = (tree[no].be + tree[no].en) / 2;
		if(r >= tree[no].be && l <= mid)
			ans = min(getmin(max(l, tree[no].be), min(r, mid), gleft(no)), ans);
		if(r >= mid + 1 && l <= tree[no].en)
			ans = min(getmin(max(l, mid + 1), min(r, tree[no].en), gright(no)), ans);
		return ans;
	}
} sgt[2];

const int maxn = N;
int fa[2][maxn][22], deep[2][maxn];
int n;
inline void initfa() {
	for(int t = 0; t < 2; t++)
		for(int i = 1; i <= 20; i++) {
			for(int j = 0; j < n; j++) {
				if(fa[t][j][i - 1] == -1) fa[t][j][i] = -1;
				else fa[t][j][i] = fa[t][fa[t][j][i - 1]][i - 1];
			}
		}
}
inline int getfa(int cate, int no, int l) {
	for(int i = 0; l; l >>= 1, i++)
		if(l & 1) no = fa[cate][no][i];
	return no;
}
inline int getlca(int cate, int a, int b) {
	if(deep[cate][a] > deep[cate][b]) swap(a, b);
	b = getfa(cate, b, deep[cate][b] - deep[cate][a]);
	if(b == a) return a;
	for(int i = 20; i >= 0; i--)
		if(fa[cate][a][i] != fa[cate][b][i]){
			a = fa[cate][a][i];
			b = fa[cate][b][i];
		}
	return fa[cate][a][0];
}

int range[2][maxn][2];
struct edge {
	int to, nxt;
} e[2][maxn * 2];
int le[2], head[2][maxn];
int arr[2][maxn], larr[2], loc[2][maxn];
int q[2][maxn], lq[2];
bool flag[2][maxn];

inline void addedge(int cate, int a, int b) {
	e[cate][le[cate]].to = b;
	e[cate][le[cate]].nxt = head[cate][a];
	head[cate][a] = le[cate]++;
}
void dfs(int cate, int no) {
	range[cate][no][0] = larr[cate];
	loc[cate][no] = larr[cate];
	arr[cate][larr[cate]++] = no;
	for(int i = head[cate][no]; i != -1; i = e[cate][i].nxt)
		if(e[cate][i].to != fa[cate][no][0]){
			fa[cate][e[cate][i].to][0] = no;
			deep[cate][e[cate][i].to] = deep[cate][no] + 1;
			dfs(cate, e[cate][i].to);
		}
	range[cate][no][1] = larr[cate] - 1;
}
inline int getpoint(int cate, int edgeno) {
	int a = e[cate][edgeno].to,
		b = e[cate][edgeno + 1].to;
	if(fa[cate][a][0] != b) a = b;
	return a;
}
inline void add(int cate, int no, int deep, int eno) {
	init[cate][loc[cate][no]].push_back(mpr(deep, eno));
}

int main(){
    ios_base::sync_with_stdio(0);
	memset(head, -1, sizeof(head));
	le[0] = le[1] = 0;
	scanf("%d", &n);
	for(int t = 0; t < 2; t++) {
		for(int i = 1; i < n; i++) {
			int no;
			scanf("%d", &no);
			no--;
			addedge(t, i, no);
			addedge(t, no, i);
		}
	}
	larr[0] = larr[1] = 0;
	fa[0][0][0] = fa[1][0][0] = -1;
	dfs(0, 0); dfs(1, 0);
	initfa();

 	for(int now = 0; now < 2; now++) {
		int nxt = 1 - now;
		for(int i = 0; i < le[now]; i += 2) {
			int a = e[now][i].to, b = e[now][i + 1].to;
			int rfa = getlca(nxt, a, b);
			add(nxt, a, deep[nxt][rfa], i / 2 + 1);
			add(nxt, b, deep[nxt][rfa], i / 2 + 1);
		}
		for(int i = 0; i < n; i++) sort(init[nxt][i].begin(), init[nxt][i].end());
		sgt[nxt].build(1, 0, n - 1, init[nxt]);
	}
	int edgeno;
	scanf("%d", &edgeno);
	flag[0][edgeno] = 1;
	q[0][lq[0]++] = edgeno;
	for(int now = 0, nxt = 1; lq[now]; swap(now, nxt)) {
		if(now & 1) puts("Red");
		else puts("Blue");
		for(int i = 0; i < lq[now]; i++) printf("%d ", q[now][i]);
		printf("\n");
		vector <pii> arr1;
		for(int i = 0; i < lq[now]; i++) {
			int k = getpoint(now, (q[now][i] - 1) * 2);
			node a;
			while((a = sgt[now].getmin(range[now][k][0], range[now][k][1], 1)).deep <= deep[now][k] - 1) {
				sgt[now].down(a.no, 1, init[now]);
				if(flag[nxt][a.eno] == 0) {
					flag[nxt][a.eno] = 1;
					arr1.push_back(mpr(a.deep, a.eno));
				}
			}
		}
		lq[nxt] = 0;
		for(int i = 0; i < (int)arr1.size(); i++)  q[nxt][lq[nxt]++] = arr1[i].second;
		sort(q[nxt], q[nxt] + lq[nxt]);
		lq[nxt] = unique(q[nxt], q[nxt] + lq[nxt]) - q[nxt];
	}

    return 0;
}

//'3 8 9 21 23 24 27 29 30 37 47 ...5 57 60 66 70 73 78 82 84 89 93'
//'3 8 9 21 23 24 27 29 30 37 47 ...      60 66 70 71 73 78 82 84 89 93 '




