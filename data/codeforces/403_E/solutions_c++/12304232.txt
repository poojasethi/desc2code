#include <bits/stdc++.h>

using namespace std;

#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)

#define type(x) __typeof(x.begin())

#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair < int ,int > pii;

typedef long long ll;

const long long linf = 1e18+5;
const int mod = (int) 1e9 + 7;
const int logN = 18;
const int inf = 1e9;
const int N = 2e5+5;

int h[2][N];
pii edges[2][N];
vector< int > g;
vector< pii > v[2][N];
vector< pii > ST[2][3 * N], l, r;
int L[2][3 * N], R[2][3 * N], n, m, x, y, t, p[2][N], start[2][N], finish[2][N], T[2], w[2][N], idx;

void merge(int q, int k) {
    vector< pii > &l = ST[q][sol], &r = ST[q][sag];
    int p1 = 0, p2 = 0;
    while(p1 < l.size() || p2 < r.size()) {
        if(p2 >= r.size() ||     p1 < l.size() && l[p1].st <= r[p2].st) { ST[q][k].pb(l[p1]); p1++; }
        else { ST[q][k].pb(r[p2]); p2++; }
    }
    R[q][k] = ST[q][k].size() - 1;
}

void init(int q, int k, int bas, int son) {
    if(bas == son) {
        int node = w[q][bas];
        vector< pii > t;
        foreach(it, v[1-q][node]) t.pb(mp(start[q][it->st], it->nd));
        sort(t.begin(), t.end());
        foreach(it, t) ST[q][k].pb(*it);
        R[q][k] = ST[q][k].size() - 1;
        return ;
    }
    init(q, sol, bas, orta);
    init(q, sag, orta + 1, son);
    merge(q, k);
}

void add(int q, int k, int bas, int son, int x, int y) {
    if(bas > y || son < x) return ;
    if(x <= bas && son <= y) {
        int &l = L[q][k], &r = R[q][k];
        while(l <= r && ST[q][k][l].st < x) {
            idx = ST[q][k][l].nd;
            if(!h[q][idx]) g.pb(idx);
            h[q][idx] = 1;
            l++;
        }
        while(r >= l && ST[q][k][r].st > y) {
            idx = ST[q][k][r].nd;
            if(!h[q][idx]) g.pb(idx);
            h[q][idx] = 1;
            r--;
        }
        return ;
    }
    add(q, sol, bas, orta, x, y);
    add(q, sag, orta + 1, son, x, y);
}

int dfs(int node, int root, int q) {
    start[q][node] = ++T[q];
    w[q][T[q]] = node;
    foreach(it, v[q][node])
        if(it->st != root)
            dfs(it->st, node, q);
    finish[q][node] = T[q];
}

int main() {

    scanf("%d", &n);

    FOR(q, 0, 1)
        FOR(i, 2, n) {
            scanf("%d", &p[q][i]);
            v[q][p[q][i]].pb(mp(i, i-1));
            v[q][i].pb(mp(p[q][i], i-1));
            edges[q][i-1] = mp(i, p[q][i]);
        }


    dfs(1, 0, 0);
    dfs(1, 0, 1);

    init(0, 1, 1, n);
    init(1, 1, 1, n);

    int t = 0;
    scanf("%d", &x);
    g.pb(x);
    printf("Blue\n%d\n",x);
    h[1][x] = 1;

    while(1) {
        vector< int > temp = g;
        g.clear();
        foreach(it, temp) {
            add(t, 1, 1, n, start[t][edges[t][*it].st], finish[t][edges[t][*it].st]);
        } t = 1 - t;
        if(!g.size()) break;
        if(t == 0) printf("Blue\n");
        else printf("Red\n"); sort(g.begin(), g.end());
        foreach(it, g) printf("%d ", *it); printf("\n");
    }

    return 0;
}
