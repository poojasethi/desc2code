#include <cstdlib>
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <vector>
#include <set>
#include <map>
#include <cstring>

using namespace std;

typedef long long LL;
typedef unsigned long long ULL;

#define SIZE(x) (int((x).size()))
#define rep(i,l,r) for (int i=(l); i<=(r); i++)
#define repd(i,r,l) for (int i=(r); i>=(l); i--)
#define rept(i,c) for (typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)

#ifndef ONLINE_JUDGE
#define debug(x) { cerr<<#x<<" = "<<(x)<<endl; }
#else
#define debug(x) {}
#endif

#define maxn 200010
#define INF 1000000000

struct node
{
	int left, right, mid, minv, minvi;
};

struct SegT
{
	node a[524288];
	
	void update(int i)
	{
		if (a[i*2].minv<a[i*2+1].minv)
		{
			a[i].minv=a[i*2].minv; a[i].minvi=a[i*2].minvi;
		}
		else
		{
			a[i].minv=a[i*2+1].minv; a[i].minvi=a[i*2+1].minvi;
		}
	}
	
	void build(int i, int bg, int ed)
	{
		a[i].left=bg; a[i].right=ed; a[i].mid=(bg+ed)/2;
		if (bg==ed) { a[i].minv=INF; a[i].minvi=bg; return; }
		build(i*2,bg,a[i].mid); build(i*2+1,a[i].mid+1,ed);
		update(i);
	}
	
	void serere(int i, int pl, int val)
	{
		if (a[i].left==a[i].right) { a[i].minv=val; a[i].minvi=a[i].left; return; }
		if (pl<=a[i].mid) serere(i*2,pl,val); else serere(i*2+1,pl,val);
		update(i);
	}
	
	pair<int,int> query(int i, int bg, int ed)
	{
		if (bg<=a[i].left && a[i].right<=ed) return make_pair(a[i].minv,a[i].minvi);
		if (ed<=a[i].mid) return query(i*2,bg,ed);
		if (a[i].mid<bg) return query(i*2+1,bg,ed);
		pair<int,int> t1=query(i*2,bg,ed), t2=query(i*2+1,bg,ed);
		if (t1.first<t2.first) return t1; else return t2;
	}
};
	
struct tree
{
	int n, tot;
	vector<int> e[maxn];
	int parent[maxn], depth[maxn], lg2[maxn], killed[maxn];
	int p[maxn][20], lbound[maxn], rbound[maxn], whom[maxn];
	SegT t;
	map< pair<int,int>, int> snum, sonum;
	vector< pair<int,int> > eo[maxn];
	int edge_o1[maxn], edge_o2[maxn];
	vector< pair<int,int> >::iterator iter[maxn];
	
	void dfs(int cur, int pre, int dep)
	{
		tot++; lbound[cur]=tot; whom[tot]=cur;
		depth[cur]=dep; p[cur][0]=pre; parent[cur]=pre;
		rep(i,1,lg2[dep]) p[cur][i]=p[p[cur][i-1]][i-1];
		rept(it,e[cur])
			if (*it!=pre)
				dfs(*it,cur,dep+1);
			
		rbound[cur]=tot;
	}
	
	int moveup(int x, int y)
	{
		while (y) x=p[x][lg2[y&-y]], y-=y&-y;
		return x;
	}
	
	int lca(int x, int y)
	{
		if (depth[x]>depth[y]) x=moveup(x,depth[x]-depth[y]); else y=moveup(y,depth[y]-depth[x]);
		repd(i,19,0)
			if (p[x][i]!=p[y][i])
			{
				x=p[x][i]; y=p[y][i];
			}
		if (x==y) return x; else return p[x][0];
	}
	
	void readin(int _n, int *d, int *od)
	{
		n=_n;
		rep(i,1,n-1)
		{
			int x=d[i], y=i+1;
			e[x].push_back(y); e[y].push_back(x);
			snum[make_pair(x,y)]=i;
			snum[make_pair(y,x)]=i;
		}
		
		lg2[1]=0; rep(i,2,maxn-1) lg2[i]=lg2[i/2]+1;
		tot=0;
		dfs(1,0,0);
		t.build(1,1,n);
		
		rep(i,1,n-1)
		{
			int x=od[i], y=i+1;
			sonum[make_pair(x,y)]=i;
			sonum[make_pair(y,x)]=i;
			int z=depth[lca(x,y)];
			eo[x].push_back(make_pair(z,i));
			eo[y].push_back(make_pair(z,i));
			edge_o1[i]=x; edge_o2[i]=y;
		}
		
		rep(i,1,n) eo[i].push_back(make_pair(INF,0));
		rep(i,1,n) sort(eo[i].begin(),eo[i].end());
		rep(i,1,n) t.serere(1,lbound[i],(eo[i].begin())->first);
		rep(i,1,n) iter[i]=eo[i].begin();
		memset(killed,0,sizeof killed);
	}
	
	void kill_edge(int x, int y)
	{
		killed[sonum[make_pair(x,y)]]=1;
	}
	
	void kill(int x, int y, vector< pair<int,int> > &ret)
	{
		if (parent[y]==x) swap(x,y);
		while (1)
		{
			pair<int,int> ts=t.query(1,lbound[x],rbound[x]);
			if (ts.first>=depth[x]) break;
			int where=whom[ts.second];
			int edge_id=iter[where]->second;
			if (!killed[edge_id])
			{
				killed[edge_id]=1;
				ret.push_back(make_pair(edge_o1[edge_id],edge_o2[edge_id]));
			}
			iter[where]++;
			t.serere(1,lbound[where],iter[where]->first);
		}
	}
	
};

tree blue, red;
int d1[maxn], d2[maxn];

void lemon()
{
	int n; scanf("%d",&n);
	rep(i,1,n-1) scanf("%d",&d1[i]);
	rep(i,1,n-1) scanf("%d",&d2[i]);
	int idx; scanf("%d",&idx);
	int x0=idx+1, y0=d1[idx];
	blue.readin(n,d1,d2);
	red.readin(n,d2,d1);
	red.kill_edge(x0,y0);
	
	int who=0;
	vector< pair<int,int> > cur, next;
	cur.push_back(make_pair(x0,y0));
	while (!cur.empty())
	{
		next.clear();
		if (who==0)
		{
			printf("Blue\n");
			vector<int> ans; ans.clear();
			rept(it,cur) ans.push_back(blue.snum[*it]);
			sort(ans.begin(),ans.end());
			rept(it,ans) printf("%d ",*it); printf("\n");
			rept(it,cur) blue.kill(it->first,it->second,next);
		}
		else
		{
			printf("Red\n");
			vector<int> ans; ans.clear();
			rept(it,cur) ans.push_back(red.snum[*it]);
			sort(ans.begin(),ans.end());
			rept(it,ans) printf("%d ",*it); printf("\n");
			rept(it,cur) red.kill(it->first,it->second,next);
		}
		swap(cur,next);
		who=1-who;
	}
}

int main()
{
	ios::sync_with_stdio(true);
	#ifndef ONLINE_JUDGE
		freopen("E.in","r",stdin);
	#endif
	lemon();
	return 0;
}

