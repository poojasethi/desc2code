#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <vector>
#include <map>
#include <cmath>
#include <queue>
using namespace std;

#define LL long long
#define mod 1000000007
#define eps 1e-8
#define MP make_pair
#define mxn 200005
#define mxe 400005

int n, cnt, cur, pre;
int first[mxn], vv[mxe], nxt[mxe], e;
vector<pair<int,int> > a[4][mxn];
vector<int> del[2];

struct Tree {
    int in[mxn], out[mxn];
    bool vis[mxn];
    vector<pair<int,int> > E;
}t[2];

struct SegTree {
    int ll[mxn << 2], rr[mxn << 2], id;
    vector<pair<int,int> > p[mxn << 2];
    void up( int x, int ls, int rs ) {
        int l = 0, r = 0;
        while( l < p[ls].size() && r < p[rs].size() ) {
            if( (id & 1) && p[ls][l] > p[rs][r] || !(id & 1) && p[ls][l] < p[rs][r] )
                p[x].push_back(p[ls][l++]);
            else p[x].push_back(p[rs][r++]);
        }
        while( l < p[ls].size() ) p[x].push_back(p[ls][l++]);
        while( r < p[rs].size() ) p[x].push_back(p[rs][r++]);
    }
    void build( int l, int r, int i ) {
        ll[i] = l, rr[i] = r;
        if( ll[i] == rr[i] ) {
            p[i] = a[id][l];
            sort(p[i].begin(), p[i].end());
            if(id & 1) reverse(p[i].begin(), p[i].end());
            return ;
        }
        int m = (ll[i] + rr[i]) >> 1, ls = i << 1, rs = ls | 1;
        build(l, m, ls); build(m + 1, r, rs);
        up(i, ls, rs);
    }
    void find( int l, int r, int i, int val ) {
        if( ll[i] == l && rr[i] == r ) {
            while( p[i].size() ) {
                pair<int,int> k = p[i].back();
                if( (id & 1) && k.first >= val || !(id & 1) && k.first <= val ) break;
                if( !t[id > 1].vis[k.second] ) {
                    del[cur].push_back(k.second);
                    t[id > 1].vis[k.second] = true;
                }
                p[i].pop_back();
            }
            return ;
        }
        int m = (ll[i] + rr[i]) >> 1, ls = i << 1, rs = ls | 1;
        if( r <= m ) find(l, r, ls, val);
        else if( l > m ) find(l, r, rs, val);
        else find(l, m, ls, val), find(m + 1, r, rs, val);
    }
}s[4];

void add( int u, int v ) {
    vv[e] = v; nxt[e] = first[u]; first[u] = e++;
}

void dfs( int x, int u, int p ) {
    t[x].in[u] = ++cnt;
    for( int i = first[u]; i != -1; i = nxt[i] ) {
        int v = vv[i];
        if( v == p ) continue;
        dfs(x, v, u);
    }
    t[x].out[u] = cnt;
}

void build( int x ) {
    int u;
    t[x].E.push_back(MP(0, 0));
    memset(first, -1, sizeof(first)); e = 0;
    for( int v = 2; v <= n; ++v ) {
        scanf( "%d", &u );
        add(u, v); add(v, u);
        t[x].E.push_back(MP(u, v));
    }
    cnt = 0;
    dfs(x, 1, -1);
}

void init() {
    int m;
    scanf( "%d", &n );
    build(0); build(1);
    for( int k = 0; k < 2; ++k ) {
        for( int i = 1; i < t[k].E.size(); ++i ) {
            int u = t[k].E[i].first, v = t[k].E[i].second;
            int p = min(t[k^1].in[u], t[k^1].in[v]);
            int q = max(t[k^1].in[u], t[k^1].in[v]);
            a[k * 2 + 0][p].push_back(MP(q, i));
            a[k * 2 + 1][q].push_back(MP(p, i));
        }
    }
    for( int i = 0; i < 4; ++i )
        s[i].build(1, n, 1);
    scanf( "%d", &m );
    t[0].vis[m] = true;
    del[0].push_back(m);
}

void solve() {
    cur = 1, pre = 0;
    while( del[pre].size() ) {
        if( pre == 0 ) puts( "Blue" );
        else puts( "Red" );
        sort(del[pre].begin(), del[pre].end());
        for( int i = 0; i < del[pre].size(); ++i )
            printf( "%d%c", del[pre][i], i + 1 == del[pre].size() ? '\n' : ' ' );
        del[cur].clear();
        for( int i = 0; i < del[pre].size(); ++i ) {
            int k = del[pre][i];
            int u = t[pre].E[k].first, v = t[pre].E[k].second;
            int l, r;
            if( t[pre].in[u] > t[pre].in[v] )
                l = t[pre].in[u], r = t[pre].out[u];
            else l = t[pre].in[v], r = t[pre].out[v];
            s[cur * 2 + 0].find(l, r, 1, r);
            s[cur * 2 + 1].find(l, r, 1, l);
        }
        pre = cur;
        cur = cur ^ 1;
    }
}

int main()
{
    for( int i = 0; i < 4; ++i ) s[i].id = i;
    init();
    solve();
    return 0;
}