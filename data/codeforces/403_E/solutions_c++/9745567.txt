#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

typedef pair<int, int> pii;

const int MAXN = 2e5 + 10;

struct Edge {
	Edge(int x = -1, int y = -1, int id = -1) 
		: x(x), y(y), id(id) {
	}
	int other(int tx) {
		return x + y - tx;
	}
	int x, y, id;
};

struct NodeV {
	NodeV(int st = -1, int en = -1, int id = -1) 
		: st(st), en(en), id(id) {
	}
	int st, en, id;
};

struct Graph {
	Graph() {
	}
// Storing Graph
	Edge edge[MAXN]; int cntEdge;
	vector<int> ng[MAXN];
	void addEdge(int x, int y) {
		int id = cntEdge++;
		ng[x].push_back(id);
		ng[y].push_back(id);
		edge[id] = Edge(x, y, id);
	}
// Dfs
	int dfsTime;
	int n;
	int stTime[MAXN], enTime[MAXN];
	void runDfs() {
		dfsTime = 0;
		dfs(0, -1);
	}
	void dfs(int x, int par) {
		stTime[x] = dfsTime++;
		for (int i = 0; i < ng[x].size(); i++) {
			int u = edge[ng[x][i]].other(x);
			if (u != par)
				dfs(u, x);
		}
		enTime[x] = dfsTime;
	}
	vector<int> delE(int eId) {
		int v = edge[eId].x;
		if (stTime[edge[eId].x] < stTime[edge[eId].y])
			v = edge[eId].y;
		int ql = stTime[v], qr = enTime[v];
		askRet.clear();
		if (ql)
			askSeg(ql, 0, ql, qr, 1, 0, n, 0);
		if (qr < n)
			askSeg(qr, ql, qr, n, 1, 0, n, 1);
		return askRet;
	}
// Segment Tree
	bool remEdge[MAXN];
	vector<NodeV> seg[2][MAXN * 4];
	void addSeg(int ql, int qr, const NodeV& nd, int x, int s, int e, int id) {
		if (ql <= s && e <= qr) {
			seg[id][x].push_back(nd);
			return;
		}
		int mid = (s + e) >> 1;
		if (ql < mid)
			addSeg(ql, qr, nd, x * 2, s, mid, id);
		if (qr > mid)
			addSeg(ql, qr, nd, x * 2 + 1, mid, e, id);
	}
	vector<int> askRet;
	void askSeg(int plc, int ql, int qm, int qr, int x, int s, int e, int sid) {
		while (seg[sid][x].size() > 0
				&& seg[sid][x].back().st >= ql && seg[sid][x].back().st < qm 
				&& seg[sid][x].back().en >= qm && seg[sid][x].back().en < qr) {
			int id = seg[sid][x].back().id;
			if (!remEdge[id]) {
				remEdge[id] = true;
				askRet.push_back(id);
			}
			seg[sid][x].pop_back();
		}
		if (e - s < 2)
			return;
		int mid = (s + e) >> 1;
		if (plc < mid)
			askSeg(plc, ql, qm, qr, x * 2, s, mid, sid);
		else
			askSeg(plc, ql, qm, qr, x * 2 + 1, mid, e, sid);
	}
} g[2];

bool compEn(NodeV x, NodeV y) {
	return x.en == y.en ? x.st < y.st : x.en > y.en;
}

bool compSt(NodeV x, NodeV y) {
	return x.st == y.st ? x.en > y.en : x.st < y.st;
}

int main() {
	ios::sync_with_stdio(false);
	int n;
	cin >> n;
	g[0].n = g[1].n = n;
	for (int o = 0; o < 2; o++) {
		for (int i = 0; i < n - 1; i++) {
			int x;
			cin >> x;
			x--;
			g[o].addEdge(x, i + 1);
		}
		g[o].runDfs();
	}
	for (int id = 0; id < 2; id++) {
		vector<NodeV> cur;
		for (int i = 0; i < n - 1; i++) {
			const Edge& e = g[id].edge[i];
			cur.push_back(NodeV(g[id ^ 1].stTime[e.x], g[id ^ 1].stTime[e.y], e.id));
			if (cur.back().st >= cur.back().en)
				swap(cur.back().st, cur.back().en);
		}
		sort(cur.begin(), cur.end(), compEn);
		for (int i = 0; i < cur.size(); i++)
			g[id ^ 1].addSeg(cur[i].st + 1, cur[i].en + 1, cur[i], 1, 0, n, 0);
		sort(cur.begin(), cur.end(), compSt);
		for (int i = 0; i < cur.size(); i++)
			g[id ^ 1].addSeg(cur[i].st + 1, cur[i].en + 1, cur[i], 1, 0, n, 1);
	}
	vector<int> curRem[2];
	{
		int id;
		cin >> id;
		id--;
		curRem[0].push_back(id);
		g[1].remEdge[id] = true;
	}
	int id = 0;
	while (!curRem[id].empty()) {
		cout << (id ? "Red" : "Blue") << '\n';
		for (int i = 0; i < curRem[id].size(); i++) {
			const Edge& e = g[id].edge[curRem[id][i]];
			cout << e.id + 1 << " ";
		}
		curRem[id ^ 1].clear();
		for (int i = 0; i < curRem[id].size(); i++) {
			const Edge& e = g[id].edge[curRem[id][i]];
			vector<int> tmp = g[id].delE(e.id);
			for (int j = 0; j < tmp.size(); j++)
				curRem[id ^ 1].push_back(tmp[j]);
		}
		cout << '\n';
		sort(curRem[id ^ 1].begin(), curRem[id ^ 1].end());
		id ^= 1;
	}
	return 0;
}
