#include<bits/stdc++.h>
using namespace std;
const int maxn=500010,maxm=500010,maxq=500010;
const int maxc=60,maxk=22;
struct edge{
    int u,v;
}a[maxm];
struct query{
    int idx,u,v,cor;
}b[maxq];
int pre[maxm],next[maxm];
int n,m,q,c;

void init(){
    scanf("%d%d%d%d",&n,&m,&c,&q);
    for(int i=1;i<=m;++i)
        scanf("%d%d",&a[i].u,&a[i].v);
    b[0]=(query){0,0,0,-1};
    for(int i=1;i<=q;++i){
        scanf("%d%d",&b[i].idx,&b[i].cor);
        b[i].u=a[b[i].idx].u,b[i].v=a[b[i].idx].v;
    }
    static int pos[maxn];
    for(int i=1;i<=m;++i)
        pos[i]=0;
    for(int i=1;i<=q;++i)
        pre[i]=pos[b[i].idx],pos[b[i].idx]=i;
    for(int i=1;i<=m;++i)
        pos[i]=q+1;
    for(int i=q;i>=1;--i)
        next[i]=pos[b[i].idx],pos[b[i].idx]=i;
/*  for(int i=1;i<=q;++i)
        printf("edge(%d):(%d,%d) oldcor=%d newcor=%d [%d,%d]\n",b[i].idx,b[i].u,b[i].v,b[pre[i]].cor,b[i].cor,pre[i],next[i]);*/
}

struct Tunion_find_set{
    struct event{
        int x,fa,cor,sz;
    };
    vector<event> t[maxk]; int now;
    int fa[maxn],cor[maxn],sz[maxn];

    void clear(){
        now=0;
        for(int i=1;i<=n;++i)
            fa[i]=i,cor[i]=0,sz[i]=1;
    }
/*  void print(){
        cout<<"now="<<now<<endl;
        for(int i=1;i<=n;++i)
            printf("i=%d fa=%d cor=%d sz=%d\n",i,fa[i],cor[i],sz[i]);
        for(int k=1;k<=now;++k,cout<<endl)
            for(int i=0;i<t[k].size();++i)
                printf("(x=%d,fa=%d,cor=%d,sz=%d) ",t[k][i].x,t[k][i].fa,t[k][i].cor,t[k][i].sz);
    }*/
    void newset(){ ++now; }
    void back(){
        for(int i=t[now].size()-1;i>=0;--i){//一定要倒循环!!!
            fa[t[now][i].x]=t[now][i].fa;
            cor[t[now][i].x]=t[now][i].cor;
            sz[t[now][i].x]=t[now][i].sz;
        }
        t[now--].clear();
    }

    int find(int x){
        if(fa[x]==x) return fa[x];
        int s=find(fa[x]);
        t[now].push_back((event){x,fa[x],cor[x],sz[x]});
        cor[x]^=cor[fa[x]]; return fa[x]=s;
    }
    bool link(int u,int v){
        int fx=find(u),fy=find(v);
        if(fx==fy) return cor[u]^cor[v];
        if(sz[fx]>sz[fy]) swap(fx,fy),swap(u,v);
        t[now].push_back((event){fx,fa[fx],cor[fx],sz[fx]});
        t[now].push_back((event){fy,fa[fy],cor[fy],sz[fy]});
        fa[fx]=fy,cor[fx]^=cor[u]^cor[v]^1;
        sz[fy]+=sz[fx],sz[fx]=0; return true;
    }
}ufs[maxc];
bool ans[maxm];
void solve(int l,int r){
    if(l==r){
        ufs[b[l].cor].newset();
        if(ufs[b[l].cor].link(b[l].u,b[l].v))
            ans[l]=true;
        else{
            ans[l]=false;
            next[pre[l]]=next[l],pre[next[l]]=pre[l];//remember
        }
        ufs[b[l].cor].back();
        return;
    }
    int mid=(l+r)/2;

    for(int i=1;i<=c;++i)
        ufs[i].newset();
    for(int i=mid+1;i<=r;++i)
        if(pre[i] && pre[i]<l)
            assert(ufs[b[pre[i]].cor].link(b[i].u,b[i].v));
    solve(l,mid);
    for(int i=1;i<=c;++i)
        ufs[i].back();

    for(int i=1;i<=c;++i)
        ufs[i].newset();
    for(int i=l;i<=mid;++i)if(next[i]>r){
        if(ans[i])
            assert(ufs[b[i].cor].link(b[i].u,b[i].v));
        else if(pre[i]) assert(ufs[b[pre[i]].cor].link(b[pre[i]].u,b[pre[i]].v));//remember
    }
    solve(mid+1,r);
    for(int i=1;i<=c;++i)
        ufs[i].back();
}

int main(){
    init();
    for(int i=1;i<=c;++i)
        ufs[i].clear();
    solve(1,q);
    for(int i=1;i<=q;++i)
        if(ans[i]) puts("YES"); else puts("NO");
    return 0;
}
