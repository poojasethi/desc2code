#include <bits/stdc++.h>

using namespace std;

#define type(x) __typeof((x).begin())
#define foreach(it, x) for(type(x) it = (x).begin(); it != (x).end(); it++)
#define next ___next

typedef long long ll;
typedef pair < int, int > ii;

const int inf = 1e9 + 333;
const ll linf = 1e18 + inf;

const int N = 5e5 + 5;
const int K = 50 + 5;

int n, m, k, q;
int x[N], y[N], e[N], c[N], last[N], next[N];

int ptr;

class info{ public:
	int time, x, bro, par, size;
	info make(int _time, int _x, int _bro, int _par, int _size) {
		time = _time;
		x = _x;
		bro = _bro;
		par = _par;
		size = _size;
		return *this;
	}
};

class persistent_dsu{ public:
	int bro[N], par[N], size[N];
	vector < info > revert;
	void init() {
		for(int i = 1; i <= n; i++) {
			par[i] = i;
			size[i] = 1;
		}
	}
	int group(int x) {
		if(x == par[x])
			return x;
		return group(par[x]);
	}	
	void merge(int x, int y) {
		ptr++;
		x = group(x);
		y = group(y);
		if(bro[x] == y)
			return;
		info help;
		revert.push_back(help.make(ptr, x, bro[x], par[x], size[x]));
		revert.push_back(help.make(ptr, y, bro[y], par[y], size[y]));
		int bx = bro[x];
		int by = bro[y];
		assert(x != by);
		assert(y != bx);
		if(bx) {
			revert.push_back(help.make(ptr, bx, bro[bx], par[bx], size[bx]));
		}
		if(by) {
			revert.push_back(help.make(ptr, by, bro[by], par[by], size[by]));
		}
		//while(x and size[x] < 0);
		if(size[x] > size[by]) {
			swap(x, by);
		}
		if(size[y] > size[bx]) {
			swap(y, bx);
		}
		if(x) {
			par[x] = by;
			size[by] += size[x];
		}
		if(y) {
			par[y] = bx;
			size[bx] += size[y];
		}
		bro[bx] = by;
		bro[by] = bx;
	}
	void get_back_to(int time) {
		while(revert.size() and revert.back().time > time) {
			int x = revert.back().x;
			bro[x] = revert.back().bro;
			par[x] = revert.back().par;
			size[x] = revert.back().size;
			revert.pop_back();
		}
	}
};

persistent_dsu dsu[K];

int avl[N];
vector < ii > qu[N << 2];

void update(int x, int l, int r, int x1, int x2, int edge, int color) {
	if(x2 < l or r < x1)
		return;
	if(x1 <= l and r <= x2) {
		qu[x].push_back(ii(edge, color));
		return;
	}
	int m = l + r >> 1;
	update(x + x, l, m, x1, x2, edge, color);
	update(x + x + 1, m + 1, r, x1, x2, edge, color);
}

void solve(int X, int L, int R) {
	int in_time = ptr;
	foreach(it, qu[X]) {
		int edge = it -> first;
		int color = it -> second;
		dsu[color].merge(x[edge], y[edge]);
	}
	if(L == R) {
		int edge = e[L];
		int color = c[L];
		if(dsu[color].group(x[edge]) == dsu[color].group(y[edge])) {
			puts("NO");
			if(avl[edge]) {
				update(1, 1, q, L + 1, next[L] - 1, edge, avl[edge]);
			}
		}
		else {
			puts("YES");
			update(1, 1, q, L + 1, next[L] - 1, edge, avl[edge] = color);
		}
		dsu[color].get_back_to(in_time);
		return;
	}
	int M = L + R >> 1;
	solve(X + X, L, M);
	solve(X + X + 1, M + 1, R);
	for(int i = 1; i <= k; i++) {
		dsu[i].get_back_to(in_time);
	}
}

int main() {

	scanf("%d %d %d %d", &n, &m, &k, &q);

	for(int i = 1; i <= m; i++) {
		scanf("%d %d", x + i, y + i);
	}

	for(int i = 1; i <= q; i++) {
		scanf("%d %d", e + i, c + i);
	}

	for(int i = 1; i <= m; i++) {
		last[i] = q + 1;
	}

	for(int i = q; i >= 1; i--) {
		next[i] = last[e[i]];
		last[e[i]] = i;
		//printf("next[%d] = %d\n", i, next[i]);
	}

	for(int i = 1; i <= k; i++) {
		dsu[i].init();
	}

	solve(1, 1, q);

	return 0;

}
