#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>

using namespace std;

#ifdef WIN32
	#define LL "%I64d"
#else
	#define LL "%lld"
#endif

#ifdef Lightning
	#define debug(...) printf(__VA_ARGS__)
	const int DEBUG_FLAG = 1;
#else
	#define debug(...)
	const int DEBUG_FLAG = 0;
#endif

#define DEBUG if (DEBUG_FLAG)
#define NDEBUG if (!DEBUG_FLAG)
#define print(__l) (DEBUG_FLAG ? printf(#__l" = "LL"\n", 1ll*(__l)) : 0)
#define eprint(...) fprintf(stderr, __VA_ARGS__)

#define IO_Able if (0)
#define OpenFile(NAME) freopen(NAME".in", "r", stdin), freopen(NAME".out", "w", stdout)
#define CloseFile() fclose(stdin), fclose(stdout)

#define reg register int
#define regll register long long
#define FOR(_i, _sta, _end) for (reg _i = (_sta), __end = (_end) + 1; _i < __end; ++_i)
#define REP(_i, _sta, _end) for (reg _i = (_sta), __end = (_end) - 1; _i > __end; --_i)
#define FORBY(_i, _sta, _end, _by) for (reg _i = (_sta), __end = (_end) + 1; _i < __end; _i += (_by))
#define REPBY(_i, _sta, _end, _by) for (reg _i = (_sta), __end = (_end) - 1; _i > __end; _i -= (_by))
#define JUMP(_i, _sta, _jump) for (reg _i = (_sta); _i > 0; _i = _jump[_i])

#define mset(_a, _b, _c) memset(_a, _b, ((_c) + 3) * sizeof(_a[0]))

#define gmax(_a, _b) ((_a) > (_b) ? (_a) : (_b))
#define gmin(_a, _b) ((_a) < (_b) ? (_a) : (_b))
#define cmax(_a, _b) (_a < (_b) ? _a = (_b) : 0)
#define cmin(_a, _b) (_a > (_b) ? _a = (_b) : 0)
#define positive(_a, _b) ((_a) < (_b) ? (_b) - (_a) : (_a) - (_b))

inline int read()
{
	register int aa, bb, ch;
	while (ch = getchar(), (ch < '0' || ch > '9') && ch != '-');
	ch == '-' ? (aa = 0, bb = 1) : (aa = ch - '0', bb = 0);
	while (ch = getchar(), ch >= '0' && ch <= '9')
		aa = (aa << 3) + (aa << 1) + ch - '0';
	return bb ? -aa : aa;
}

const int N = 500005;
const int K = 51;

struct P
{
	int r, e, col;
} p[N];

struct Q
{
	int e, col;
} add[N * 50];

int n, m, k, q, top, color[N], tot;
int edge[N][2], end[N], last[N << 2], pre[N * 50];

struct STACK
{
	int col, node;
} stack[N << 1];

struct DSU
{
	int father[N], col;
	char w[N], dep[N];

	int find(reg x)
	{
		return father[x] ? find(father[x]) : x;
	}

	int dist(reg x)
	{
		return father[x] ? dist(father[x]) ^ w[x] : 0;
	}

	void Union(reg a, reg b)
	{
		reg fa = find(a), fb = find(b);
		if (fa == fb) return;
		if (dep[fa] > dep[fb])
		{
			reg tmp = a; a = b; b = tmp;
			tmp = fa; fa = fb; fb = tmp;
		}
		if (dep[fa] == dep[fb])
		{
			stack[++top] = (STACK) {col, -fb};
			++dep[fb];
		}
		w[fa] = dist(a) ^ dist(b) ^ 1;
		father[fa] = fb;
		stack[++top] = (STACK) {col, fa};
		return;
	}
} d[K];

namespace LightningWork
{
	// My Space

	void restore(reg bottom)
	{
		reg x, y;
		while (top > bottom)
		{
			x = stack[top].col;
			y = stack[top].node;
			if (y > 0)
			{
				d[x].father[y] = 0;
				d[x].w[y] = 0;
			} else --d[x].dep[-y];
			--top;
		}
	}

	void insert(reg i, reg l, reg r, reg L, reg R, reg e)
	{
		if (L <= l && R >= r)
		{
			add[++tot] = (Q) {e, color[e]};
			pre[tot] = last[i];
			last[i] = tot;
			return;
		}
		reg mid = l + r >> 1;
		if (L <= mid) insert(i << 1, l, mid, L, R, e);
		if (R > mid) insert(i << 1 | 1, mid + 1, r, L, R, e);
	}

	void solve(reg i, reg l, reg r)
	{
		reg tmptop = top;
		JUMP (j, last[i], pre)
		{
			d[add[j].col].Union(edge[add[j].e][0], edge[add[j].e][1]);
		}
		if (l == r)
		{
			reg u = edge[p[l].e][0];
			reg v = edge[p[l].e][1];
			reg col = p[l].col;
			if (d[col].find(u) != d[col].find(v) || d[col].dist(u) != d[col].dist(v))
			{
				puts("YES");
				color[p[l].e] = col;
			} else
			{
				puts("NO");
			}
			if (l < q)
			{
				insert(1, 1, q, l + 1, p[l].r, p[l].e);
			}
		} else
		{
			reg mid = l + r >> 1;
			solve(i << 1, l, mid);
			solve(i << 1 | 1, mid + 1, r);
		}
		restore(tmptop);
	}

	void Main()
	{
		// debug("%d\n", sizeof d);
		n = read();
		m = read();
		k = read();
		q = read();
		FOR (i, 1, m)
		{
			edge[i][0] = read();
			edge[i][1] = read();
		}
		FOR (i, 1, q)
		{
			reg a = read();
			reg b = read();
			p[end[a]].r = i - 1;
			p[i] = (P) {q, a, b};
			end[a] = i;
		}
		FOR (i, 1, k)
		{
			d[i].col = i;
		}
		solve(1, 1, q);
	}
}

int main()
{
	IO_Able OpenFile("tmp");
	LightningWork::Main();
	IO_Able CloseFile();
	return 0;
}
