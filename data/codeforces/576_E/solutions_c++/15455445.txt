#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cstdlib>

using namespace std;

int leer()
{
  int x=0;
  int c;
  for (c=getchar();c<'0' or c>'9';c=getchar());
  for (;c>='0' and c<='9';c=getchar()) x=10*x+c-'0';
  return x;
}

const int limite=500001;
const int primero=1<<19;
const int tope=1<<20;

int n,m,k,q;
int au[tope],av[tope],ac[tope],qa[tope],qc[tope];
vector<int> va[tope];
vector<int> a2q[tope];

/*
void inserta(int pos0,int pos1,int ia)
{
  if (pos0>pos1) return;
  pos0+=primero;
  pos1+=primero;
  va[pos0].push_back(ia);
  if (pos0==pos1) return;
  va[pos1].push_back(ia);
  while (pos0+1<pos1) {
    if ((pos0&1)==0) va[pos0+1].push_back(ia);
    pos0>>=1;
    if ((pos1&1)==1) va[pos1-1].push_back(ia);
    pos1>>=1;
  }
}
*/

void inserta(int pos,int insertle,int insertri,int le,int ri,int ia)
{
  if (ri<=insertle or insertri<le) return;
  if (insertle<=le and ri-1<=insertri) {va[pos].push_back(ia);return;}
  int med=(le+ri)/2;
  inserta(2*pos,insertle,insertri,le,med,ia);
  inserta(2*pos+1,insertle,insertri,med,ri,ia);
}

int padre[51][limite];
int cambio[51][limite];
int cuantos[51][limite];

int nrep=0;
pair<int*,int> rep[40*limite];

void reparar(int antnrep)
{
  while (antnrep<nrep) {
    nrep--;
    *(rep[nrep].first)=rep[nrep].second;
  }
}

void asignar(int*x,int y)
{
  rep[nrep].first=x;
  rep[nrep].second=*x;
  nrep++;
  *x=y;
}

int computapadre(int u,int pad[limite],int cam[limite])
{
  if (pad[u]==0) return u;
  return computapadre(pad[u],pad,cam);
}

int computacambio(int u,int pad[limite],int cam[limite])
{
  if (pad[u]==0) return 0;
  return cam[u]^computacambio(pad[u],pad,cam);
}

void calcula(int pos)
{
  int antnrep=nrep;
  for (int i=0;i<int(va[pos].size());i++) {
    int ia=va[pos][i];
    int u=au[ia];
    int v=av[ia];
    int c=ac[ia];
    int (&pad)[limite]=padre[c];
    int (&cam)[limite]=cambio[c];
    int (&cuan)[limite]=cuantos[c];
    int idu=computapadre(u,pad,cam);
    int idv=computapadre(v,pad,cam);
    if (idu!=idv) {
      int camu=computacambio(u,pad,cam);
      int camv=computacambio(v,pad,cam);
      if (cuan[idu]<cuan[idv]) {
	asignar(&(pad[idu]),idv);
	asignar(&(cam[idu]),camu^camv^1);
	asignar(&(cuan[idv]),cuan[idu]+cuan[idv]);
      } else {
	asignar(&(pad[idv]),idu);
	asignar(&(cam[idv]),camu^camv^1);
	asignar(&(cuan[idu]),cuan[idu]+cuan[idv]);
      }
    }
  }
  int iq=pos-primero;
  if (pos<primero) {
    calcula(2*pos);
    calcula(2*pos+1);
  } else if (iq>q) {
    exit(0);
  } else if (iq>=1) {
    int ia=qa[iq];
    int u=au[ia];
    int v=av[ia];
    int &c=ac[ia];
    a2q[ia].pop_back();
    if (c!=qc[iq]) {
      int (&pad)[limite]=padre[qc[iq]];
      int (&cam)[limite]=cambio[qc[iq]];
      int idu=computapadre(u,pad,cam);
      int idv=computapadre(v,pad,cam);
      int cu=computacambio(u,pad,cam);
      int cv=computacambio(v,pad,cam);
      if (idu==idv and cu==cv) {
	//cout<<"NO"<<endl;
	//printf("NO\n");
	puts("NO");
	if (c>0)
	  inserta(1,iq+1,a2q[ia].back(),0,primero,ia);
	  //inserta(iq+1,a2q[ia].back(),ia);
      } else {
	//cout<<"YES"<<endl;
	//printf("YES\n");
	puts("YES");
	c=qc[iq];
	inserta(1,iq+1,a2q[ia].back(),0,primero,ia);
	//inserta(iq+1,a2q[ia].back(),ia);
      }
    } else {
      //cout<<"YES"<<endl;
      //printf("YES\n");
      puts("YES");
      inserta(1,iq+1,a2q[ia].back(),0,primero,ia);
      //inserta(iq+1,a2q[ia].back(),ia);
    }
  }
  reparar(antnrep);
}

int main()
{
  ios::sync_with_stdio(false);
  //cin>>n>>m>>k>>q;
  //scanf("%d%d%d%d",&n,&m,&k,&q);
  n=leer();m=leer();k=leer();q=leer();
  for (int c=1;c<=k;c++)
    for (int i=1;i<=n;i++)
      cuantos[c][i]=1;
  for (int i=1;i<=m;i++) {
    //cin>>au[i]>>av[i];
    //scanf("%d%d",&(au[i]),&(av[i]));
    au[i]=leer();av[i]=leer();
  }
  for (int i=1;i<=q;i++) {
    //cin>>qa[i]>>qc[i];
    //scanf("%d%d",&(qa[i]),&(qc[i]));
    qa[i]=leer();qc[i]=leer();
    a2q[qa[i]].push_back(i);
  }
  for (int i=1;i<=m;i++) {
    a2q[i].push_back(q+1);
    reverse(a2q[i].begin(),a2q[i].end());
  }
  calcula(1);
}
