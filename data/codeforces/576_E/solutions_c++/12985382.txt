#include <ctime>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <set>
#include <vector>
#include <utility>
using namespace std;

const int maxn = 500005;
const int maxk = 51;

int n, m, k, q, top, Time;
int fa[maxk][maxn << 1], sz[maxk][maxn << 1];
pair<int, int> edge[maxn], ask[maxn];
int oldcolor[maxn], nxt[maxn], occur[maxn];
bool ans[maxn];

struct changetype  {
    int t, c, x, y;
};

vector<changetype> changes, sizes;

struct edgetype  {
    int c, x, y;
};
vector<edgetype> addedge[maxn << 2];

int A(int x)  {
    return x * 2 - 1;
}

int B(int x)  {
    return x * 2;
}

int findfa(int c, int x)  {
    if (fa[c][x] == x) return x;
    return findfa(c, fa[c][x]);
}

void merge(int c, int x, int y) {
    x = findfa(c, x);
    y = findfa(c, y);
    if (x == y) return;
    if (sz[c][x] > sz[c][y]) swap(x, y);
    changes.push_back((changetype){Time, c, x, x});
    fa[c][x] = y;
    if (sz[c][y] == sz[c][x])  {
            sizes.push_back((changetype){Time, c, y, sz[c][y]});
            sz[c][y] ++;
    }
}

void modify(int cur, int l, int r, int ql, int qr, edgetype e)  {
    if (ql <= l && r <= qr)  {
        addedge[cur].push_back(e);
        return;
    }
    int md = (l + r) >> 1;
    if (ql <= md)  modify(cur * 2, l, md, ql, qr, e);
    if (qr > md)  modify(cur * 2 + 1, md + 1, r, ql, qr, e);
}

void solve(int cur, int l, int r)  {
    int curTime = ++ Time;
//  printf("solve(%d,%d,%d)\n",cur,l,r);
    for (int i = 0; i < (int)addedge[cur].size(); i ++)  {
        int x = addedge[cur][i].x;
        int y = addedge[cur][i].y;
        int c = addedge[cur][i].c;
        merge(c, A(x), B(y));
        merge(c, B(x), A(y));
    //  printf("add edge (c,x,y)=%d,%d,%d\n",c,x,y);
    }

    if (l == r)  {
        int x = edge[ask[l].first].first;
        int y = edge[ask[l].first].second;
        int newc = ask[l].second;
        int &oldc = oldcolor[ask[l].first];

        if (findfa(newc, A(x)) != findfa(newc, A(y)) 
            && findfa(newc, B(x)) != findfa(newc, B(y)))  { //valid
            oldc = newc;
            modify(1, 1, q, l + 1, nxt[l], (edgetype){newc, x, y});
            ans[l] = true;
        //  printf("valid q(%d,%d) edge(%d,%d)c=%d\n",l+1,nxt[l],x,y,newc);
        }else  {  //invalid
            modify(1, 1, q, l + 1, nxt[l], (edgetype){oldc, x, y});
            ans[l] = false;
        }
        
    }else  {
        solve(cur * 2, l, (l + r) >> 1);
        solve(cur * 2 + 1, ((l + r) >> 1) + 1, r);
    }

    while (!changes.empty() && changes.back().t == curTime)  { //recover 
        fa[changes.back().c][changes.back().x] = changes.back().y;
        changes.pop_back();
    }
    while (!sizes.empty() && sizes.back().t == curTime)  {
        sz[sizes.back().c][sizes.back().x] = sizes.back().y;
        sizes.pop_back();
    }
}

int main()  {
    srand(7);
    scanf("%d%d%d%d", &n, &m, &k, &q);
    for (int i = 1, a, b; i <= m; i ++)  {
        scanf("%d%d", &a, &b);
        edge[i] = make_pair(a, b);
    }
    for (int i = 1; i <= q; i ++)  {
        int e, c;
        scanf("%d%d", &e, &c);
        ask[i] = make_pair(e, c);
    }
    for (int i = 1; i <= m; i ++)
        occur[i] =  q + 1;
    for (int i = q; i > 0; i --)  { //appear [i, nxt[i]]
        nxt[i] = occur[ask[i].first] - 1;
        occur[ask[i].first] =i;
    }
    for (int i = 1; i <= m; i ++)
        oldcolor[i] = 0;
    for (int i = 0; i <= k; i ++)
        for (int j = 1; j <= 2 * n; j ++)
            fa[i][j] = j;
 
    Time = 0;
    top = 0;
    for (int i = 1; i <= 3 * q; i ++)
        addedge[i].clear();
    changes.clear();
    sizes.clear();
    solve(1, 1, q);
    for (int i = 1; i <= q; i ++)
        printf("%s\n", ans[i] ? "YES" : "NO");

    return 0;
}
