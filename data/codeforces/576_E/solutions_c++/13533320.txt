#include <bits/stdc++.h>

using namespace std;

#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)

#define type(x) __typeof(x.begin())

#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair < int ,int > pii;
typedef pair < pair< int, int >, int > piii;

typedef long long ll;

const long long linf = 1e18+5;
const int mod = (int) 1e9 + 7;
const int logN = 17;
const int inf = 1e9;
const int N = 5e5 + 5;

int curCOL[N], k, Q, n, m, x, next[N], H[N];
pii e[N], q[N];
vector< pii > ST[N << 2];

class info {
    public:
    vector< pair< int, pair< pii, pii > > > v;
    void add(int w, int a, int b, int c, int d) {
        v.pb(mp(w,mp(mp(a,b),mp(c,d))));
    }
};


class persistent_splay_DSU {
    public:
    vector< int > size, parent, match;
    persistent_splay_DSU() { 
        parent.resize(N, 0);
        size.resize(N, 1); 
        size[0] = 0;
        match.resize(N, 0);
        for(int i = 1; i < N; i++)
            parent[i] = i;
    }
    int findset(int x) { return x == parent[x] ? x : findset(parent[x]); }
    int CTR(int x, int y) {
        if(findset(x) == findset(y))
            return 0;
        return 1;
    }
    void merge(int x, int y, int w, info &V) {
        x = findset(x);
        y = findset(y);
        if(match[x] == y) return ;
        int a = match[x], b = match[y];
        V.add(w, x, parent[x], match[x], size[x]);
        V.add(w, y, parent[y], match[y], size[y]);
        if(a) V.add(w, a, parent[a], match[a], size[a]);
        if(b) V.add(w, b, parent[b], match[b], size[b]);
        if(size[b] >= size[x]) swap(x, b);
        if(size[a] >= size[y]) swap(y, a);
        if(b) {
			parent[b] = x;
   	    	size[x] += size[b];
		}
        if(a) {
			parent[a] = y;
			size[y] += size[a];
		}
		match[x] = y;
        match[y] = x;
    }
};

persistent_splay_DSU DSU[51];
    
void revert(info &V) {
   	reverse(V.v.begin(), V.v.end());
	foreach(it, V.v) {
        DSU[it->st].parent[it->nd.st.st] = it->nd.st.nd;
        DSU[it->st].match[it->nd.st.st] = it->nd.nd.st;
        DSU[it->st].size[it->nd.st.st] = it->nd.nd.nd;
    }   
    V.v.clear();
}

void update(int k, int bas, int son, int x, int y, int c, int cc) {
    if(bas > y || son < x) 
        return ;
    if(x <= bas && son <= y) {
        ST[k].pb(mp(c, cc));
        return ;
    }
    update(sol, bas, orta, x, y, c, cc);
    update(sag, orta+1, son, x, y, c, cc);
}  

void solve(int k, int bas, int son) {
    info V;
    foreach(it, ST[k]) {
        DSU[it->nd].merge(e[it->st].st, e[it->st].nd, it->nd, V); 
    }
    if(bas == son) {
        int x = e[q[bas].st].st, y = e[q[bas].st].nd, c = q[bas].nd;
        if(DSU[c].CTR(x, y)) {
            puts("YES");
            curCOL[q[bas].st] = c;
            update(1, 1, Q, bas + 1, next[bas] - 1, q[bas].st, curCOL[q[bas].st]);
        }   
        else {
            puts("NO");
            if(curCOL[q[bas].st]) update(1, 1, Q, bas + 1, next[bas] - 1, q[bas].st, curCOL[q[bas].st]);
        }
    }
    else {
        solve(sol, bas, orta);
        solve(sag, orta+1, son);        
    }
    revert(V);
}

int main() {
    scanf("%d %d %d %d", &n, &m, &k, &Q);
    for(int i = 1; i <= m; i++) {
        scanf("%d %d", &e[i].st, &e[i].nd);
    }
    for(int i = 1; i <= Q; i++) {
        scanf("%d %d", &q[i].st, &q[i].nd);
    }
    memset(H, 10, sizeof H);
    for(int i = Q; i >= 1; i--) {
        next[i] = H[q[i].st];
        H[q[i].st] = i; 
    }
    return solve(1, 1, Q), 0;
}
