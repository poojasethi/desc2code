#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <vector>
#include <utility>
#include <stack>
#include <queue>
#include <map>

const int maxn = 5e5 + 20, maxk = 55, logN = 20;
typedef int Array[maxn];
#define X first
#define Y second
#define L(x) ((x) << 1)
#define R(x) ((x) << 1 | 1)

int N, M, Q, K;
std::pair<int,int> op[maxn], edge[maxn];
std::pair<std::pair<int,int>,int> G[maxn * logN];
std::pair<int,int> end[maxn << 1];
int head[maxn << 2], pos[maxn], Gs, Es;
std::stack<std::pair<int*,int> > st;
int now[maxn];

struct DSU
{
	int fa[maxn], rank[maxn], g[maxn];
	
	int getv(int x)
	{
		int v = 0;
		while(fa[x])
		{
			v ^= g[x];
			x = fa[x];
		}
		return v;
	}
	int find(int x)
	{
		while(fa[x])
			x = fa[x];
		return x;
	}
	bool union_(int x,int y)
	{
		int u = find(x), v = find(y);
		
		if(u == v) return false;
		
		if(rank[u] > rank[v]) std::swap(u, v);
		if(rank[u] == rank[v]) st.push(std::make_pair(&rank[v], rank[v])), rank[v]++;
		
		st.push(std::make_pair(&g[u], g[u]));
		st.push(std::make_pair(&fa[u], fa[u]));
		g[u] = getv(x) ^ getv(y) ^ 1, fa[u] = v;
		
		return true;
	}
	
} D[maxk];

void add(int l,int r,std::pair<int,int> T,int ll,int rr,int s)
{
	if(l <= ll && rr <= r)
		G[++Gs] = std::make_pair(T, head[s]), head[s] = Gs;
	else
	{
		int mid = (ll + rr) >> 1;
		if(l <= mid) add(l, r, T, ll, mid, L(s));
		if(mid < r) add(l, r, T, mid + 1, rr, R(s));
	}
}
void init()
{
	int x, y;
	
	std::ios::sync_with_stdio(false);
	
	std::cin >> N >> M >> K >> Q;
    
	for(int i = 1; i <= M; i++)
	{
		std::cin >> x >> y;
		edge[i] = std::make_pair(x, y);
	}
    
	for(int i = 1; i <= Q; i++)
	{
		std::cin >> x >> y;
		op[i] = std::make_pair(x, y);
	}
	for(int i = 1; i <= M; i++)
	{
		end[i] = std::make_pair(Q, 0);
		pos[i] = i;
	}
	Es = M;
	
	for(int i = Q; i >= 1; i--)
	{
		end[++Es] = std::make_pair(i, pos[op[i].X]);
		pos[op[i].X] = Es;
	}
}
void solve(int l,int r,int s)
{
	int bot = st.size();
    
	for(int i = head[s]; i ; i = G[i].Y)
	{
		std::pair<int,int> p = G[i].X;
		D[p.Y].union_(edge[p.X].X, edge[p.X].Y);
	}
    
	if(l == r)
	{
		bool flag = false;
		int c = op[l].Y, t = op[l].X, u = edge[t].X, v = edge[t].Y;
		if(D[c].union_(u, v) || (D[c].getv(u) ^ D[c].getv(v))) flag = true, now[t] = op[l].Y;
		std::cout << (flag ? "YES" : "NO") << std::endl, pos[t] = end[pos[t]].Y;
		if(now[t] && l < end[pos[t]].X) add(l + 1, end[pos[t]].X, std::make_pair(t, now[t]), 1, Q, 1);
	}
	else
	{
		int mid = (l + r) >> 1;
		solve(l, mid, L(s));
		solve(mid + 1, r, R(s));
	}
    
	while(st.size() != bot)
	{
		*st.top().X = st.top().Y;
		st.pop();
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("input.txt","r",stdin);
	freopen("output.txt","w",stdout);
#endif  
    
	init();
    
	solve(1, Q, 1);
    
#ifndef ONLINE_JUDGE
	fclose(stdin);
	fclose(stdout);
#endif  
	return 0;
}