#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

#define n	500005
#define For(i,a,b)  for(int i=a,lim=b;i<=lim;i++)
#define Rep(i,a,b)  for(int i=a,lim=b;i>=lim;i--)

int		N,M,K,T;
int	 	X[n],Y[n],L[n],P[n],Q[n];
int	 	A[n],B[n],R[n],U[n],H[n];
int	 	G[n<<1],F[n<<1],D[n<<1],O[n<<1];

struct  Opt{
		int	 tot,x[n],y[n],z[n],o[n];
		void	INS(int a,int b,int c,int d)	{x[++tot]=a;y[tot]=b;z[tot]=c;o[tot]=d;}
}Mod[25];
vector<int>E[n<<2];

#define CH  (ch=getchar())
int	 	IN(){
		int x=0,ch;
		for (;CH<'0'||ch>'9';);
		for (;ch>='0'&&ch<='9';CH)  (x*=10)+=ch-'0';
		return  x;
}

int	 	Get(int dep,int u)  {
		Mod[dep].INS(u,F[u],D[u],O[u]);
		if  (F[u]==u)	return  u;
		int t=Get(dep,F[u]);	D[u]^=D[F[u]];
		return  F[u]=t;
}
void	Modify(int u,int l,int r,int x,int y,int k){
		if  (x<=l&&r<=y)	{
			E[u].push_back(k);  return;
		}	int Mid=l+r>>1;
		if  (x<=Mid)	Modify(u<<1,l,Mid,x,y,k);
		if  (y>Mid)	 Modify(u<<1|1,Mid+1,r,x,y,k);
}

void	Work(int dep,int u,int l,int r,int Ans){
		if  (l==r)  E[u].push_back(l);  Mod[dep].tot=0;
		For(i,1,E[u].size()){
			int x=P[E[u][i-1]],y=Q[E[u][i-1]],fx=Get(dep,x),fy=Get(dep,y);
			if  (fx!=fy){
				
				if  (O[fx]<O[fy])	F[fx]=fy,D[fx]=D[x]^D[y]^1; else
				if  (O[fx]>O[fy])	F[fy]=fx,D[fy]=D[x]^D[y]^1; else
					F[fx]=fy,D[fx]=D[x]^D[y]^1,O[fy]++;
			}	else	if  (D[x]^D[y]^1)	Ans=0;
		}

		if  (l==r)  {
			if  (Ans)	{
				puts("YES");
				if  (l<R[l])	Modify(1,1,T,l+1,R[l],l);
			}	else	{
				puts("NO"); U[H[l]]=U[l];
				if  (l<R[l]&&U[l])  Modify(1,1,T,l+1,R[l],U[l]);
			}
		}	else	{
			int Mid=l+r>>1;
			Work(dep+1,u<<1,l,Mid,Ans);
			Work(dep+1,u<<1|1,Mid+1,r,Ans);
		}

		Rep(i,Mod[dep].tot,1)	{
			F[Mod[dep].x[i]]=Mod[dep].y[i]; 
			D[Mod[dep].x[i]]=Mod[dep].z[i];
			O[Mod[dep].x[i]]=Mod[dep].o[i];
		}
}

int	 	main()  {
		N=IN(); M=IN(); K=IN(); T=IN();
		For(i,1,M)  X[i]=IN(),Y[i]=IN();
		For(i,1,T)  {
			A[i]=IN();  B[i]=IN()-1;
			G[++*G]=P[i]=B[i]*N+X[A[i]];
			G[++*G]=Q[i]=B[i]*N+Y[A[i]];
			if  (L[A[i]])	R[L[A[i]]]=i-1; U[i]=L[A[i]];	L[A[i]]=i;
		}
		For(i,1,M)  if  (L[i])  R[L[i]]=T;
		For(i,1,T)  if  (U[i])  H[U[i]]=i;

		sort(G+1,G+*G+1);	*G=unique(G+1,G+*G+1)-G-1;
		For(i,1,T)  P[i]=lower_bound(G+1,G+*G+1,P[i])-G,
					Q[i]=lower_bound(G+1,G+*G+1,Q[i])-G;
		For(i,1,*G) F[i]=i,D[i]=0,O[i]=1;
		Work(1,1,1,T,1);
}
