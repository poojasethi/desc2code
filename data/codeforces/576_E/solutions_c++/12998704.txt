#include <cmath>
#include <cstdio>
#include <cctype>
#include <cstdlib>
#include <climits>
#include <cstring>
#include <vector>
#include <string>
#include <iostream>
#include <cassert>
#include <algorithm>

using namespace std;

#define foreach(e,x) for(__typeof((x).begin()) e=(x).begin(); e!=(x).end(); ++e)

const int N = 500000;
const int M = 50;

int n, m, k, q;
int size[M][N], par[M][N], value[M][N];
int edges[N][2];
int qe[N], qc[N];
int lst[N], nxt[N];
int ans[N], color[N];
vector<pair<int, int> > insertEdges[N + N];
vector<pair<int*, int> > recoverVec;

pair<int, int> getRoot(int u, int c)
{
    int x = 0;
    for( ; u != par[c][u]; u = par[c][u]) 
        x ^= value[c][u];
    return make_pair(u, x);
}

int getId(int l, int r)
{
    return l + r | (l != r);
}

void insert(int l, int r, int a, int b, int c, int eid)
{
    if (b < l || r < a) return;
    if (a <= l && r <= b) {
        int id = getId(l, r);
        insertEdges[id].push_back(make_pair(c, eid));
        return;
    }
    int mid = (l + r) >> 1;
    insert(l, mid, a, b, c, eid);
    insert(mid + 1, r, a, b, c, eid);
}

void makeChange(int &mem, int value)
{
    recoverVec.push_back(make_pair(&mem, mem));
    mem = value;
}

void unionIt(int c, int eid)
{
    int u = edges[eid][0], v = edges[eid][1];
    pair<int, int> infoU = getRoot(u, c), infoV = getRoot(v, c);
    int fu = infoU.first, fv = infoV.first;
    if (fu == fv) {
        assert(infoU.second != infoV.second);
        return;
    }
    int nc = infoU.second ^ infoV.second ^ 1;
    if (size[c][fu] < size[c][fv]) {
        swap(fu, fv);
    }
    makeChange(par[c][fv], fu);
    makeChange(size[c][fu], size[c][fu] + size[c][fv]);
    makeChange(value[c][fv], nc);
}

void tranverse(int l, int r)
{
    //cout << "!! " << l << ' ' << r << endl;
    int curRecoverSize = recoverVec.size();
    int id = getId(l, r);
    foreach(it, insertEdges[id]) {
        int c = it->first, eid = it->second;
        unionIt(c, eid);
    }
    if (l == r) {
        int u = edges[qe[l]][0], v = edges[qe[l]][1];
        int c = qc[l];
        pair<int, int> infoU = getRoot(u, c);
        pair<int, int> infoV = getRoot(v, c);
        /*
        cout << l << ' ' << c << ' ' << infoU.first << ' ' << infoU.second << ' ' << infoV.first << ' ' << infoV.second << endl;
        cout << "in color " << c << endl;
        for(int i = 0; i < n; ++ i) {
            cout << "cur is " << i << " father is " << par[c][i] << endl;
        }
        */
        ans[l] = !(infoU.first == infoV.first && infoU.second == infoV.second);
        if (ans[l]) {
            color[qe[l]] = c;
        }
        //cout << "insert " << l + 1 << ' ' << nxt[l] - 1 << ' ' << color[qe[l]] << ' ' << qe[l] << endl;
        if (color[qe[l]] != -1) {
            insert(0, q - 1, l + 1, nxt[l] - 1, color[qe[l]], qe[l]);
        }
        //puts(ans[l] ? "YES" : "NO");
    } else {
        int mid = (l + r) >> 1;
        tranverse(l, mid);
        tranverse(mid + 1, r);
    }
    for( ; recoverVec.size() > curRecoverSize; ) {
        *recoverVec.back().first = recoverVec.back().second;
        recoverVec.pop_back();
    }
}

void solve()
{
    cin >> n >> m >> k >> q;
    for(int i = 0; i < m; ++ i) {
        scanf("%d%d", &edges[i][0], &edges[i][1]);
        edges[i][0] --; edges[i][1] --;
    }
    for(int i = 0; i < q; ++ i) {
        scanf("%d%d", qe + i, qc + i);
        qe[i] --; qc[i] --;
    }
    for(int i = 0; i < m; ++ i) {
        color[i] = -1;
        lst[i] = q;
    }
    for(int i = q - 1; i >= 0; -- i) {
        nxt[i] = lst[qe[i]];
        lst[qe[i]] = i;
    }

    for(int i = 0; i < k; ++ i) {
        for(int j = 0; j < n; ++ j) {
            par[i][j] = j;
            value[i][j] = 0;
            size[i][j] = 1;
        }
    }

    tranverse(0, q - 1);

    for(int i = 0; i < q; ++ i) {
        puts(ans[i] ? "YES" : "NO");
    }
}

int main()
{
    solve();
    return 0;
}