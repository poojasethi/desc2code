#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<fstream>
#include<map>
#include<ctime>
#include<set>
#include<queue>
#include<cmath>
#include<vector>
#include<bitset>
#include<functional>
#define x first
#define y second
#define mp make_pair
#define pb push_back
#define REP(i,l,r) for((i)=(l);(i)<=(r);++(i))
#define REP2(i,l,r) for((i)=(l);(i)!=(r);++(i))
using namespace std;

typedef long long LL;
typedef double ld;

const int MAX=400+10;
const int INF=1000000000;

int n,v[MAX],w[MAX];
int dp1[MAX][MAX],dp[MAX][MAX],dp2[MAX][MAX];
int hash1[MAX][MAX],hash[MAX][MAX],hash2[MAX][MAX];

int work3(int l,int r);
int work2(int l,int r);
int work(int l,int r);

int work3(int l,int r)
{
	if(hash1[l][r])
		return dp1[l][r];
	hash1[l][r]=1;
	if(l==r)
		return dp1[l][r]=0;
	dp1[l][r]=-INF;
	int flag=(r>=l?-1:1),j;
	for(j=r+flag;;j+=flag)
	{
		if(w[j]==w[r]-1)
		{
			int cc=work3(l,j);
			if(flag==-1)
				cc+=work(j+1,r-1);
			else cc+=work(r+1,j-1);
			dp1[l][r]=max(dp1[l][r],cc);
		}
		if(j==l)
			break;
	}
	return dp1[l][r];
}

int work2(int l,int r)
{
	if(hash2[l][r])
		return dp2[l][r];
	hash2[l][r]=1;
	int mid;
	dp2[l][r]=-INF;
	REP(mid,l,r)
		if(w[mid]>=w[l] && w[mid]>=w[r])
		{
			int len=w[mid]-w[l] + w[mid]-w[r] + 1;
			if(len>n)
				continue;
			dp2[l][r]=max(dp2[l][r],work3(l,mid)+work3(r,mid)+v[len]);
		}
	return dp2[l][r];
}

int work(int l,int r)
{
	if(l>r)
		return 0;
	if(hash[l][r])
		return dp[l][r];
	hash[l][r]=1;
	if(l==r)
		return dp[l][r]=v[1];
	dp[l][r]=work2(l,r);
	int mid;
	REP(mid,l,r-1)
		dp[l][r]=max(dp[l][r],work(l,mid)+work(mid+1,r));
	return dp[l][r];
}

int f[MAX];

int main()
{
#ifndef ONLINE_JUDGE
	freopen("input.txt","r",stdin);freopen("output.txt","w",stdout);
#endif
	int i,j;
	scanf("%d",&n);
	REP(i,1,n)
		scanf("%d",&v[i]);
	REP(i,1,n)
		cin>>w[i];
	f[0]=0;
	REP(i,1,n)
	{
		f[i]=f[i-1];
		REP(j,1,i)
			f[i]=max(f[i],f[j-1]+work(j,i));
	}
	cout<<f[n]<<endl;
	return 0;
}
