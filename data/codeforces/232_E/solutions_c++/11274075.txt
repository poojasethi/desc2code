#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<bitset>
#include<cmath>
#include<vector>
using namespace std;

const int maxn = 505;
const int maxq = 700005;
struct query{
    int x1, y1, x2, y2, id;
};
int n, m, nq;
char mp[maxn][maxn];
bitset<maxn> g[maxn][maxn], f[maxn][maxn];
vector<query> qq;
bool ans[maxq];
#define md (l + r >> 1)
void solve(int l,int r, vector<query> q){
    if (l > r) return;
    for (int i = md; i >= l; i --)
       for (int j = m; j >= 1; j --){
           g[i][j] = 0;
           if (mp[i][j] == '.'){
               if (i == md) g[i][j][j] = 1;
               else g[i][j] |= g[i + 1][j];
               if (j != m) g[i][j] |= g[i][j + 1];
           }
       }
    for (int i = md; i <= r; i ++)
       for (int j = 1; j <= m; j ++){
           f[i][j] = 0;
           if (mp[i][j] == '.'){
              if (i == md) f[i][j][j] = 1;
               else f[i][j] |= f[i - 1][j];
               if (j != 1) f[i][j] |= f[i][j - 1];
           }
       }
    //need to separate g & f!
    //'cuz they are different in the mid row
    vector<query> ql, qr;
    query t;
    for (vector<query>::iterator it = q.begin(); it != q.end(); it ++){
         t = *it;
         if (t.x1 > md) qr.push_back(t);
         else if (t.x2 < md) ql.push_back(t);
         else
             ans[t.id] = (g[t.x1][t.y1] & f[t.x2][t.y2]).any();  
    }
    solve(l, md - 1, ql);
    solve(md + 1, r, qr);
}
int main(){
//    freopen("E.in","r",stdin);
//    freopen("E.out","w",stdout);
    scanf("%d%d",&n,&m);
    for (int i = 1; i <= n; i ++)
      for (int j = 1; j <= m; j ++){
          char c = getchar();
          while (c != '.' && c != '#') c = getchar();
          mp[i][j] = c;
      }
    scanf("%d",&nq);
    for (int i = 1; i <= nq; i ++){
       query cur;
       scanf("%d%d%d%d",&cur.x1, &cur.y1, &cur.x2, &cur.y2);
       cur.id = i;
       qq.push_back(cur);
    }
    memset(ans, false, sizeof(ans));
    solve(1, n, qq);
    for (int i = 1; i <= nq; i ++) printf("%s\n", ans[i] ? "Yes" : "No");
    return 0;
}
