#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
#include<bitset>
using namespace std;
struct que{
	int x[3],y[3];
}a[601000];
bitset <510> f[510][510],g[510][510];
char s[510][510];
int ans[601000];
int n,m,q;
vector <int> ord;
void solve(int l,int r,vector <int> &ord){
	if (l > r) return;
	if (ord.size() == 0) return;
	int mid = (l+r) >> 1;
	for (int i = mid;i >= l;i--)
		for (int j = m;j >= 1;j--){
			f[i][j] = 0;
			if (s[i][j] == '.'){
				if (i == mid) f[i][j][j] = 1;
				else f[i][j] |= f[i+1][j];
				if (j != m) f[i][j] |= f[i][j+1];
			}
		}
	for (int i = mid ;i <= r;i++)
		for (int j = 1;j <= m;j++){
			g[i][j] = 0;
			if (s[i][j] == '.'){
				if (i == mid) g[i][j][j] = 1;
				else g[i][j] |= g[i-1][j];
				if (j != 1) g[i][j] |= g[i][j-1];
			}
		}
	vector <int> ordl,ordr;
	for (int i = 0;i < ord.size();i++){
		que now = a[ord[i]];
		if (now.x[1] <= mid && now.x[2] >= mid)
			ans[ord[i]] = ((f[now.x[1]][now.y[1]] & g[now.x[2]][now.y[2]]) != 0);
		else if (now.x[1] < mid && now.x[2] < mid)
			ordl.push_back(ord[i]);
		else if (now.x[1] > mid && now.x[2] > mid)
			ordr.push_back(ord[i]);
	}
	solve(l,mid-1,ordl);
	solve(mid+1,r,ordr);
}
int main(){
	//	freopen("a.in","r",stdin);
	//freopen("a.out","w",stdout);
	scanf("%d%d\n",&n,&m);
	for (int i = 1;i <= n;i++)
		scanf("%s\n",s[i] + 1);
	scanf("%d",&q);
	for (int i = 1;i <= q;i++)
		scanf("%d%d%d%d\n",&a[i].x[1],&a[i].y[1],&a[i].x[2],&a[i].y[2]);
	for (int i = 1;i <= q;i++)
		ord.push_back(i);
	solve(1,n,ord);
	for (int i = 1;i <= q;i++)
		printf(ans[i] > 0?"Yes\n":"No\n");
	return 0;
}
