#include <bits/stdc++.h>

using namespace std;

#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)

#define type(x) __typeof(x.begin())

#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair < int ,int > pii;

typedef long long ll;

typedef pair< pair< pii , pii > , int > splay_tree;

const int inf = 1e9, mod = 1e9+7;
const int N = 505;

int i, j, k, n, m, x, y, x2 ,y2, ans[1000000];

bitset< N > dp1[N][N], dp2[N][N];

char a[N][N];

vector< splay_tree > q;

void print(bitset<N> a){ FOR(i,0,2) cout << a[i]; cout << endl;}

void solve(int l,int r,vector< splay_tree > &q){

	if(l > r) return ;

	int mid = l + r >> 1;

	ROF(j,mid,l)
		ROF(i,n,1){
			dp1[i][j] = 0;
			if(a[i][j] != '.') continue;
			if(j == mid) dp1[i][j][i] = true;
			if(i < n) dp1[i][j] |= dp1[i+1][j];
			if(j < mid) dp1[i][j] |= dp1[i][j+1];
		}

	FOR(j,mid,r)
		FOR(i,1,n){
			dp2[i][j] = 0;
			if(a[i][j] != '.') continue;
			if(j == mid) dp2[i][j][i] = true;
			if(i > 1) dp2[i][j] |= dp2[i-1][j];
			if(j > mid) dp2[i][j] |= dp2[i][j-1];
		}
	
	vector< splay_tree > left, right;

	foreach(it,q){
	
		int y1 = it->st.st.nd;
		int y2 = it->st.nd.nd;
		
		if(y1 <= mid && mid <= y2) ans[it->nd] = (dp1[it->st.st.st][y1] & dp2[it->st.nd.st][y2]).count() >= 1;
		
		else if(mid > y2) left.pb(*it);
		
		else right.pb(*it);

	}
	
	solve(l,mid-1,left);
	solve(mid+1,r,right);

}

int main(){

	scanf("%d %d",&n,&m);

	FOR(i,1,n)
		FOR(j,1,m)
			scanf(" %c",&a[i][j]);
		
	
	scanf("%d",&k);
	
	FOR(i,1,k){
		
		scanf("%d %d %d %d",&x,&y,&x2,&y2);

		q.pb(mp(mp(mp(x,y),mp(x2,y2)),i));
		
	}
	
	solve(1,m,q);
	
	FOR(i,1,k)

		if(ans[i] == true) printf("Yes\n");

		else printf("No\n");

    return 0;
}
