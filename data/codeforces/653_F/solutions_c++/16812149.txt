#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>

const int maxn = 5e5 + 20;

int n;
char s[maxn];
int pre[maxn];
int tr[maxn << 2];
std::pair<int,int> all[maxn];
int c[maxn], sa[maxn], rank[maxn];
int height[maxn];

void build_sa(int m)
{
	static int t0[maxn], t1[maxn];
	int *x = t0, *y = t1;
	
	for(int i = 1; i <= m; i++) c[i] = 0;
	for(int i = 1; i <= n; i++) c[x[i] = s[i]]++;
	for(int i = 1; i <= m; i++) c[i] += c[i - 1];
	for(int i = n; i >= 1; i--) sa[c[x[i]]--] = i;
	
	for(int k = 1; k <= n; k <<= 1)
	{
		int p = 0;
		for(int i = 0; i < k; i++) y[++p] = n - i;
		for(int i = 1; i <= n; i++)
			if(sa[i] > k) y[++p] = sa[i] - k;
		
		for(int i = 1; i <= m; i++) c[i] = 0;
		for(int i = 1; i <= n; i++) c[x[y[i]]]++;
		for(int i = 1; i <= m; i++) c[i] += c[i - 1];
		for(int i = n; i >= 1; i--) sa[c[x[y[i]]]--] = y[i];
		
		std::swap(x, y);
		
		x[sa[p = 1]] = 1;
		
		for(int i = 2; i <= n; i++)
			x[sa[i]] = y[sa[i]] == y[sa[i - 1]] && sa[i] + k <= n && sa[i - 1] + k <= n && y[sa[i] + k] == y[sa[i - 1] + k] ? p : ++p;
			
		if(p == n) break;
		m = p;
	}
}
void build_height()
{
	int k = 0;
	
	for(int i = 1; i <= n; i++) rank[sa[i]] = i;
	for(int i = 1; i <= n; i++)
	{
		if(k != 0) k--;
		
		if(rank[i] == 1) continue;
		
		int j = sa[rank[i] - 1];
		while(s[j + k] == s[i + k]) k++;
		height[rank[i]] = k;
	}
}
void build_tree(int l,int r,int s)
{
	if(l == r)
	{
		tr[s] = pre[l];
		return;
	}
	
	int mid = (l + r) >> 1;
	
	build_tree(l, mid, s << 1);
	build_tree(mid + 1, r, s << 1 | 1);
	
	tr[s] = std::min(tr[s << 1], tr[s << 1 | 1]);
}
int query(int l,int r,int ll,int rr,int s)
{
	if(ll == l && rr == r) return tr[s];
	
	int mid = (ll + rr) >> 1;
	
	if(r <= mid) return query(l, r, ll, mid, s << 1);
	else if(l > mid) return query(l, r, mid + 1, rr, s << 1 | 1);
	else return std::min(query(l, mid, ll, mid, s << 1), query(mid + 1, r, mid + 1, rr, s << 1 | 1));
}
int main()
{
	scanf("%d", &n);
	scanf("%s", s + 1);
	
	build_sa(256);
	build_height();

	for(int i = 1; i <= n; i++)
	{
		pre[i] = pre[i - 1] + (s[i] == '(' ? 1 : -1);
		all[i] = std::make_pair(pre[i], i);
	}
	
	std::sort(all + 1, all + n + 1);
	
	build_tree(1, n, 1);
	
	long long ans = 0;
	
	for(int i = 1; i <= n; i++)
	{
		if(s[sa[i]] == ')') continue;
		
		int l = sa[i], r = n;
		int bs = pre[sa[i] - 1];
		
		if(query(sa[i], r, 1, n, 1) - bs >= 0) l = n;
		else
		{
			while(l + 1 != r)
			{
				int mid = (l + r) / 2;
				
				if(query(sa[i], mid, 1, n, 1) - bs >= 0) l = mid;
				else r = mid;
			}
		}
		
//		sa[i] + height[i] ~ l
		if(sa[i] + height[i] > l) continue;

		ans += std::lower_bound(all + 1, all + n + 1, std::make_pair(bs, l + 1)) - std::lower_bound(all + 1, all + n + 1, std::make_pair(bs, sa[i] + height[i]));
	}
	
	std::cout << ans;
	
	return 0;
}