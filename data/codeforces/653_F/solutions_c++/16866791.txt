#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define lowbit(a) ((a) & (-a))
#define maxn 1010000
#define intl long long
using namespace std;

struct Proc { int pos,val,mark; } proc[maxn << 1];
struct Ques { int a,b,pos; } ques[maxn];
struct node {
	node *f,*nex[3];
	int ml,pos,vis;
	node () { ml = pos = 0; }
} pool[maxn * 2],*tail, *head;

int N,st[maxn],sum[maxn],val[maxn],n,top,tp,tot;
intl ans;
char s[maxn];

void add(int ch,int len) {
	node *p = tail, *np = &pool[++tot];
	np -> ml = len; np -> pos = len;
	for (; p && !p -> nex[ch]; p = p -> f) p -> nex[ch] = np;
	tail = np;
	if (!p) np -> f = head;
	else {
		if (p -> nex[ch] -> ml == p -> ml + 1) np -> f = p -> nex[ch];
		else {
			node *q = p -> nex[ch], *just = &pool[++tot];
			*just = *q;
			just -> ml = p -> ml + 1;
			q -> f = np -> f = just;
			for (; p && p -> nex[ch] == q; p = p -> f) p -> nex[ch] = just;
		}
	}
}

void dfs(node *a) {
	a -> vis = 1;
	if (a -> pos) { ques[++top] = (Ques) { a -> f -> ml + 1, a -> ml, a -> pos }; }
	for (int i = 0; i < 2; i++)
		if (a -> nex[i] && !a -> nex[i] -> vis) dfs(a -> nex[i]);
}

void prepare(int L,int R,int val) {
	proc[++tp] = (Proc) { L - 1, val, -1 };
	proc[++tp] = (Proc) { R    , val,  1 };
	return;
}

bool cmp(const Ques &a, const Ques &b) {
	return (a.pos < b.pos);
}

bool pmc(const Proc &a, const Proc &b) {
	return (a.pos < b.pos);
}

int main() {
	scanf("%d",&n);
	head = tail = &pool[++tot];
	scanf("%s",s + 1);
	for (int i = 1; i <= n; i++)
		add(s[i] == '(' ? 0 : 1, i);
	sum[0] = n + 1; N = 2 * n + 1;
	for (int i = 1; i <= n; i++)
		sum[i] = sum[i - 1] + (s[i] == '(' ? -1 : 1);
	dfs(head);
	sort(ques + 1,ques + top + 1,cmp);
	int q = 1;
	memset(st,-1,sizeof(st));
	for (int i = N - n; i <= N; i += lowbit(i)) st[i] = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = N - sum[i] + 1; j <= N; j += lowbit(j)) st[j] = max(st[j],i);
		for (; q <= top && ques[q].pos < i; q++);
		for (; q <= top && ques[q].pos == i; q++) {
			int p = -1;
			for (int j = N - sum[i]; j; j -= lowbit(j)) p = max(p,st[j]);
			if (p >= i - ques[q].a) continue;
			prepare(max(p + 1, i - ques[q].b), i - ques[q].a, sum[i]);
		}
	}
	memset(st,0,sizeof(st));
	sort(proc + 1,proc + tp + 1,pmc);
	int p = 0;
	for (int i = 1; i <= tp; i++) {
		for (; p <= proc[i].pos; p++) val[sum[p]]++;
		ans += (intl) (val[proc[i].val] * proc[i].mark);
	}
	cout << ans << endl;
	return 0;
}