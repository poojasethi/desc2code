#include <iostream>
#include <cstdio>
#include <cmath>
#include <set>
#include <map>
#include <queue>
#include <cassert>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define Rep(i,a) for(int i = 0; i < a; i++)
#define rep(i,a,b) for(int i = a, _b = b; i <= _b; i++)
#define dep(i,a,b) for(int i = a; i >= b; i--)
#define ab(a) ((a) > 0 ? (a) : -(a))
#define mp(a,b) make_pair(a,b)
using namespace std;
typedef long long LL;
typedef unsigned long long uLL;
const int N = 2000010;
struct node{
	node *trans[2], *par;
	int l, p;
	bool end;
}T[N], *S = &T[0];
int tl = 0;
node *nn(){
	++tl; 
	T[tl].end = false, T[tl].l = 0, T[tl].p = -1;
	return &T[tl];
}
node *p = S, *nd[N];
void add(int x){
	node *w = p;
	p = nn(), nd[ p->l = w->l + 1 ] = p;
	for (; w && !(w->trans[x]); w = w->par) w->trans[x] = p;
	if (!w) p->par = S;
	else {
		node *q = w->trans[x];
		if (w->l + 1 == q->l) p->par = q;
		else{
			node *r = nn(); *r = *q, r->l = w->l + 1;
			p->par = q->par = r;
			for(; w && w->trans[x] == q; w = w->par) w->trans[x] = r;
		}
	}
}
char s[N];
int n;
int t[N], bin[4000000], mn[N][20];

void getmin(){
	bin[1] = 0;
	rep(i,1,20) 
		rep(j,(1 << i) + 1, (1 << (i + 1))) bin[j] = i;
	rep(i,1,n) mn[i][0] = t[i];
	rep(j,1,20) rep(i,1,n) if (i + (1 << (j - 1)) <= n) mn[i][j] = min(mn[i][j - 1], mn[i + (1 << (j - 1))][j - 1]);
}

int getmin(int a, int b){
	if (a > b) return N;
	assert(a > 0);
	int l = b - a + 1;
	return min(mn[a][bin[l]], mn[b - (1 << bin[l]) + 1][bin[l]]);
}

int find(int a, int t1){
	int x = a;
	dep(i,20,0) if (a + (1 << i) <= n + 1 && mn[a][i] >= t1) a += 1 << i;
	while (a > n || t[a] < t1) a--;
	return a;
}

typedef long long LL;
LL ans = 0;

struct qy{
	int f, a, d;
}q[N * 2];
int ql = 0;

void build(){
	rep(i,1,n){
		int p = n;
		for(node *x = nd[i]; x && x->par && x -> p == -1; x = x -> par)
			p -= x->l - x->par->l, x -> p = p;
	}
	rep(i,1,tl) {
		int t1 = t[T[i].p - T[i].par->l];
		if (getmin(T[i].p - T[i].par->l + 1, T[i].p) < t1) continue;
		int x;
		if (getmin(T[i].p + 1, T[i].p + T[i].l - T[i].par->l) < t1) 
			x = find(T[i].p + 1, t1);
		else x = T[i].p + T[i].l - T[i].par->l;
		//rep(j,T[i].p + 1, x) if (t[j] == t1) cout <<T[i].p - T[i].par->l + 1<<' '<<j<<' '<<i<<' '<<T[i].l<<endl;
		q[++ql] = (qy){-1, T[i].p, t1}, 
		q[++ql] = (qy){1, x, t1};
	}
}

bool operator < (const qy &a, const qy &b){
	return a.a < b.a;
}

int sum[N * 2];
int main(){
	scanf("%d",&n);
	scanf("%s",s + 1);
	dep(i,n,1) add(s[i] == '(' ? 0 : 1);
	rep(i,1,n) t[i] = t[i - 1] + (s[i] == '(' ? 1 : -1);
	getmin();
	build();
	sort(q + 1, q + ql + 1);
	int j = 1, tot = 0;
	rep(i,1,n){
		while (j <= ql && q[j].a < i) {
			ans += sum[q[j].d + n] * q[j].f;
			j++;
		}
		sum[t[i] + n]++;
	}
	while (j <= ql){
		ans += sum[q[j].d + n] * q[j].f;
		j++;
	}
	printf("%I64d\n",ans);
	return 0;
}