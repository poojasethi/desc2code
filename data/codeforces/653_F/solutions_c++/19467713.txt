#include <bits/stdc++.h>
using namespace std;

const int MAXN = 500005;
const int MAXL = 20;
int match[MAXN];
int p[MAXN][MAXL];
int all[MAXN];
int n;
char s[MAXN];
void buildSparse()
{
	memset(p, -1, sizeof(p));
	memset(all, 0, sizeof(all));
	for (int i = n-1; i >= 0; i--)
	{
		p[i][0] = match[i];
		if (match[i] != -1)
			all[i] = 1 + all[match[i] + 1];
		for (int j = 1; j < MAXL; j++)
		{
			if (p[i][j-1] == -1)
				break;
			p[i][j] = p[p[i][j-1]+1][j-1];
		}
	}
}

void buildMatch()
{
	memset(match, -1, sizeof(match));
	stack<int> st;
	for (int i = 0; i < n; i++)
		if (s[i] == '(')
			st.push(i);
		else if (!st.empty())
		{
			match[st.top()] = i;
			st.pop();
		}
}

struct SuffixArray {
  const int L;
  string s;
  vector<vector<int> > P;
  vector<pair<pair<int,int>,int> > M;

  SuffixArray(const string &s) : L(s.length()), s(s), P(1, vector<int>(L, 0)), M(L) {
    for (int i = 0; i < L; i++) P[0][i] = int(s[i]);
    for (int skip = 1, level = 1; skip < L; skip *= 2, level++) {
      P.push_back(vector<int>(L, 0));
      for (int i = 0; i < L; i++) 
	M[i] = make_pair(make_pair(P[level-1][i], i + skip < L ? P[level-1][i + skip] : -1000), i);
      sort(M.begin(), M.end());
      for (int i = 0; i < L; i++) 
	P[level][M[i].second] = (i > 0 && M[i].first == M[i-1].first) ? P[level][M[i-1].second] : i;
    }    
  }

  vector<int> GetSuffixArray() { return P.back(); }

  // returns the length of the longest common prefix of s[i...L-1] and s[j...L-1]
  int LongestCommonPrefix(int i, int j) {
    int len = 0;
    if (i == j) return L - i;
    for (int k = P.size() - 1; k >= 0 && i < L && j < L; k--) {
      if (P[k][i] == P[k][j]) {
	i += 1 << k;
	j += 1 << k;
	len += 1 << k;
      }
    }
    return len;
  }
};

int sa[MAXN];

long long solve()
{
	string S = string(s);
	SuffixArray SA(S);	
	vector<int> invSa = SA.GetSuffixArray();
	for (int i = 0; i < invSa.size(); i++)
		sa[invSa[i]] = i;
	long long res = 0;
	for (int i = 0; i < n; i++)
	{
		res += all[sa[i]];
		if (i)
		{
			int len = SA.LongestCommonPrefix(sa[i], sa[i-1]);
			int cur = sa[i];
			for (int j = MAXL - 1; j>=0 ; j--)
			{
				if (p[cur][j] == -1)
					continue;
				if (p[cur][j] - sa[i] + 1 <= len)
				{
					res -= (1<<j);
					cur = p[cur][j]+1;
				}
			}
//			cout<<i<<" "<<sa[i]<<" "<<cur<<endl;
		}
	}
	return res;
}

int main()
{
	scanf("%d", &n);
	scanf("%s", s);
	buildMatch();
	buildSparse();
	printf("%lld\n", solve());
}