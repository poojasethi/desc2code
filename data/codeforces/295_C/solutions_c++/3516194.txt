#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
#define rep(i,l,r) for(int i = l;i <= r;++ i)
using namespace std;
typedef long long ll;
const int Mod = 1000000007;
struct info{
       int x,y,p;
	   info(int _x,int _y,int _p):x(_x),y(_y),p(_p){};
};
queue<info> q;
int n,k,x,s1 = 0,s2 = 0;
ll c[55][55],f[55][55][3],g[55][55][3];

int main()
{
    scanf("%d%d",&n,&k);
	rep(i,1,n){
	   scanf("%d",&x);
	   if(x == 50) ++ s1;
	   else ++ s2;
	}
    rep(i,0,n) c[i][0] = 1;
	rep(i,1,n)
	 rep(j,1,i)
	    c[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % Mod;
	f[0][0][0] = g[0][0][0] = 1;
	q.push(info(0,0,0));
	while(!q.empty()){
	   int x = (q.front()).x,y = (q.front()).y,p = (q.front()).p,tmp = f[x][y][p],tmp1 = g[x][y][p],nx,ny,np;
	   q.pop();
	   if(!p) x = s1 - x,y = s2 - y;
	   rep(i,0,x)
		rep(j,(i == 0),y)
		if(i * 50 + j * 100 <= k){
		   if(!p){
		      nx = s1 - x + i; ny = s2 - y + j; np = 1;
		   }else{
		      nx = x - i; ny = y - j; np = 0;
		   }
		   if(!f[nx][ny][np]){
		      f[nx][ny][np] = tmp + 1; g[nx][ny][np] = tmp1 * c[x][i] % Mod * c[y][j] % Mod; q.push(info(nx,ny,np));
		   }else if(f[nx][ny][np] == tmp + 1) g[nx][ny][np] = (g[nx][ny][np] + (tmp1 * c[x][i] % Mod * c[y][j]) % Mod) % Mod;
		}
	}
	if(!f[s1][s2][1]) printf("-1\n0\n");
	else cout<<f[s1][s2][1] - 1<<endl<<g[s1][s2][1]<<endl;
	return 0;
}
