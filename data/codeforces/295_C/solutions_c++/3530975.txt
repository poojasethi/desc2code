#include <map>
#include <vector>
#include <string>
#include <cstdio>
#include <iostream>
#include <algorithm>
#define REP(i, n) for (int i = 0; i < int(n); ++i)
#define FOR(i, c) for (__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)
#define ALL(c) (c).begin(), (c).end()
using namespace std;
template<typename T> inline void checkMin(T& a, T b) { if (a > b) a = b; }
template<typename T> inline void checkMax(T& a, T b) { if (a < b) a = b; }

typedef pair<int, int> PII;
const int MAXN = 55;
const long long MOD = (long long)(1E9 + 7);

int N, K, X = 0, Y = 0;
map<PII, long long> dp[2];

int main() {
	static long long C[MAXN][MAXN];
	REP (i, MAXN) {
		REP (j, i + 1) {
			C[i][j] = j == 0 || j == i ? 1LL : (C[i - 1][j] + C[i - 1][j - 1]) % MOD;
		}
	}

	std::ios_base::sync_with_stdio(false);
	cin >> N >> K;
	K /= 50;
	REP (i, N) {
		int w;
		cin >> w;
		if (w == 50) {
			++X;
		} else {
			++Y;
		}
	}

	int cur = 0, pre = 1, ans = -1;
	dp[cur][make_pair(X, Y)] = 1LL;
	REP (i, 10 * N + 1) {
		swap(cur, pre);
		dp[cur].clear();
		FOR (iter, dp[pre]) {
			int xt = iter->first.first, yt = iter->first.second;
			long long o = iter->second;
			REP (dx, xt + 1) {
				REP (dy, yt + 1) {
					if (0 < dx + dy && dx + 2 * dy <= K) {
						(dp[cur][make_pair(X - xt + dx, Y - yt + dy)] += o * C[xt][dx] % MOD * C[yt][dy] % MOD) %= MOD;
					}
				}
			}
		}
		if (i % 2 == 0 && dp[cur].count(make_pair(X, Y)) != 0) {
			ans = i + 1;
			break;
		}
	}
	cout << ans << "\n" << dp[cur][make_pair(X, Y)] << "\n";
	return 0;
}
