//by watashi
#include<stdio.h>
#include<vector>
using namespace std;
vector<int>e[324],an;
bool dfs(int x,int y,int last){//y is target,, find way from leaf to root
    if(x==y)return 1;
    int i;
    for(i=0;i<e[x].size();i++){
        if(e[x][i]==last)continue;
        if(dfs(e[x][i],y,x)){//dun go back now,, deep down to target
            an.push_back(x);//倒轉記錄，最後是到葉的一步
            return 1;
        }
    }
    return 0;
}
int main(){
    int n,m,x,y,i;
    scanf("%d",&n);
    m=n-1;
    while(m--){//tree property 不由根找葉 由葉找根必然只有一條路
        scanf("%d%d",&x,&y);
        e[x].push_back(y);
        e[y].push_back(x);
    }
    y=1;
    an.push_back(1);//anspath,rt 1st
    while(scanf("%d",&x)!=EOF){//as there is only 1 way to visit one leaf
        dfs(x,y,0);
        y=x;
    }
    dfs(1,y,0);//a way to last leaf ((other than 1)
    if(an.size()!=2*n-1)puts("-1");//suitable for all tree travesal
    else{
        for(i=0;i<an.size();i++){
            if(i)putchar(' ');
            printf("%d",an[i]);
        }
        puts("");
    }
    return 0;
}
