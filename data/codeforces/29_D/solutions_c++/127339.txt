#include<iostream>
#include<vector>
#include<algorithm>
#include<utility>
#include<map>
#include<set>
#include<cmath>
#include<cstdio>
#include<sstream>
#include<string>
#include<queue>
#include<stack>
#include<cstdlib>
#include<cstring>

#define FRR(i,n) for(int i=0; i<(int) n; i++) 
#define mp make_pair
#define pb push_back

using namespace std;

vector<int> vv[301];
vector<int> lf;
vector<int> pth;
vector<int> pth1;

bool vis[301];
bool found;

void dfs(int a, int b, vector<int> pth);

int main()
{
	int n;
	cin>>n;

	FRR(i,n-1){
		int x,y;
		cin>>x>>y;
		vv[x].pb(y);
		vv[y].pb(x);
	}

	int lf1=0;
	for(int i=1; i<=n; i++){
		if(vv[i].size()==1 && i!=1) lf1++;
	}
//	cout<<"hi"<<lf1<<endl;
	FRR(i,lf1){
		int x;
		cin>>x;
		lf.pb(x);
	}
	lf.pb(1);
	pth1.pb(1);
	dfs(1,lf[0],pth);

	FRR(i,lf1){
		found=false;
		memset(vis, 0, sizeof(vis));
		dfs(lf[i], lf[i+1], pth);
	}

	if(pth1.size() != 2*n-1){
		cout<<"-1\n";
	}else{
		FRR(i,pth1.size()){
			cout<<pth1[i]<<" ";
		}
		cout<<endl;
	}

	return 0;
}

void dfs(int a, int b, vector<int> pth)
{
	vis[a]=true;
	if(a==b){
		found=true;
		FRR(i,pth.size())   pth1.pb(pth[i]);
		return;
	}
	
	FRR(i,vv[a].size()){
		if(found)  return;
		if(!vis[vv[a][i]]){
			pth.pb(vv[a][i]);
			dfs(vv[a][i],b,pth);
			pth.pop_back();
		}
	}
}
