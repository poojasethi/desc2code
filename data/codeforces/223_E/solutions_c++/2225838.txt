#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
#include<map>
#include<set>
using namespace std;

const int MAX=100000+10;
typedef double ld;
const ld INF=1e10;

int n,m,S;

struct point
{
	ld x,y;
	point(){}
	point(ld a,ld b){x=a;y=b;}
	void print()
	{
		printf("%lf %lf\n",x,y);
	}
};

ld operator / (const point& a,const point& b)
{
	return atan2(b.y-a.y,b.x-a.x);
}

ld operator < (const point& a,const point& b)
{
	if(a.x!=b.x)
		return a.x<b.x;
	else return a.y<b.y;
}

ld chaji(const point& s,const point& a,const point& b)
{
	return (a.x-s.x)*(b.y-s.y)-(a.y-s.y)*(b.x-s.x);
}

int ss[MAX],tt[MAX];
point d[MAX];

struct Edge
{
	int t;
	ld ang;
	Edge(){}
	Edge(int b,ld a)
	{
		t=b;
		ang=a;
	}
};

int operator < (const Edge& a,const Edge& b)
{
	if(a.ang!=b.ang)
		return a.ang<b.ang;
	return a.t<b.t;
}

int all[MAX];
set<Edge> link[MAX];
map<pair<int,int>,int> flow,sum;

void add(int a,int b)
{
	Edge k;
	k.t=b;k.ang=d[b]/d[a];
	flow[make_pair(a,b)]=0;
	link[a].insert(k);
}

int hash[MAX],fa[MAX];

int dfs(int u)
{
	hash[u]=1;
	int v,tot=1;
	set<Edge>::iterator it;
	for(it=link[u].begin();it!=link[u].end();++it)
	{
		if(!hash[v=it->t])
		{
			fa[v]=u;
			tot+=dfs(v);
		}
	}
	if(fa[u])
	{
		flow[make_pair(fa[u],u)]+=tot;
		flow[make_pair(u,fa[u])]-=tot;
	}
	return tot;
}

vector<int> cut;

int cal(int a,int b,int c)
{
	ld bb=d[b]/d[a],cc=d[c]/d[a];
	int ans=0;
	if(bb<cc)
		ans=sum[make_pair(a,c)]-sum[make_pair(a,b)]-flow[make_pair(a,c)];
	else 
		ans=all[a]-sum[make_pair(a,b)]+sum[make_pair(a,c)]-flow[make_pair(a,c)];
	return ans;
}

int work(vector<int> cut)
{
	int num=cut.size(),i,j,k,ans=0;
	ld s=0;
	for(i=0;i<num;++i)
	{
		j=(i+num-1)%num;
		s+=chaji(d[0],d[cut[i]],d[cut[j]]);
	}
	if(s<0)
		reverse(cut.begin(),cut.end());
	for(i=0;i<num;++i)
	{
		j=(i+num-1)%num;
		k=(i+num+1)%num;
		ans+=cal(cut[i],cut[j],cut[k]);
	}
	return ans+num;
}

int main()
{
#ifndef ONLINE_JUDGE
	freopen("input.txt","r",stdin);freopen("output.txt","w",stdout);
#endif
	int i,leftmost,Q,num,a;
	scanf("%d%d",&n,&m);
	for(i=1;i<=m;++i)
		scanf("%d%d",&ss[i],&tt[i]);		
	for(i=1;i<=n;++i)
		scanf("%lf%lf",&d[i].x,&d[i].y);
	S=n+1;
	d[S]=point(-INF,0);
	for(i=1;i<=m;++i)
	{
		add(ss[i],tt[i]);
		add(tt[i],ss[i]);
	}
	for(leftmost=1,i=2;i<=n;++i)
		if(d[i]<d[leftmost])
			leftmost=i;
	add(S,leftmost);
	add(leftmost,S);
	dfs(S);
	for(i=1;i<=n+1;++i)
	{
		set<Edge>::iterator it,la=link[i].end();
		for(it=link[i].begin();it!=link[i].end();++it)
		{
			all[i]+=(sum[make_pair(i,it->t)]=flow[make_pair(i,it->t)]);
//			printf("%d %d %d\n",i,it->t,flow[make_pair(i,it->t)]);
			if(it!=link[i].begin())
				sum[make_pair(i,it->t)]+=sum[make_pair(i,la->t)];
			la=it;
		}
	}

	scanf("%d",&Q);
	while(Q--)
	{
		cut.clear();
		scanf("%d",&num);
		for(i=1;i<=num;++i)
		{
			scanf("%d",&a);
			cut.push_back(a);
		}
		printf("%d\n",work(cut));
	}
	return 0;
}
