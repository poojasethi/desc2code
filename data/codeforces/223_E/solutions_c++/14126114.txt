#include <cstdio>
#include <cmath>
#include <algorithm>
#include <vector>
using namespace std;

typedef double db;
#define fi first
#define se second

const int N=(int)1e5+5;

int n,m,k;

struct node;
typedef pair<node*,int> edge;
struct node{
	db x,y;
	vector<edge> son;
	vector<int> sum;
	bool vis;
	void init();
	int dfs(node*);
	int calc(node*,node*);
} V[N],*a[N];

inline double cross(const node *a,const node *b){
	return a->x*b->y-a->y*b->x;
}

double X,Y;

bool cmp(const edge &a,const edge &b){
	return a.fi!=b.fi&&atan2(a.fi->y-Y,a.fi->x-X)<atan2(b.fi->y-Y,b.fi->x-X);
}

void node::init(){
	X=x; Y=y;
	sort(son.begin(),son.end(),cmp);
	sum.push_back(0);
	for(int i=0;i<(int)son.size();i++)
		sum.push_back(sum.back()+son[i].se);
}

int node::dfs(node *from){
	vis=true;
	int ans=1;
	for(vector<edge>::iterator e=son.begin();e!=son.end();e++){
		node *v=e->fi;
		if(v==from||v->vis) continue;
		int tmp=v->dfs(this);
		e->se-=tmp;
		ans+=tmp;
	}
	for(vector<edge>::iterator e=son.begin();e!=son.end();e++){
		node *v=e->fi;
		if(v==from)
			e->se+=ans;
	}
	return ans;
}

int node::calc(node *u,node *v){
	X=x; Y=y;
	int	l=lower_bound(son.begin(),son.end(),edge(u,0),cmp)-son.begin(),
		r=lower_bound(son.begin(),son.end(),edge(v,0),cmp)-son.begin();
	if(l<=r)
		return sum[r]-sum[l+1];
	else
		return sum.back()-sum[l+1]+sum[r];
}

int main(){
	scanf("%d%d",&n,&m);
	while(m--){
		int x,y; scanf("%d%d",&x,&y);
		V[x].son.push_back(edge(V+y,0));
		V[y].son.push_back(edge(V+x,0));
	}
	for(int i=1;i<=n;i++) scanf("%lf%lf",&V[i].x,&V[i].y);
	
	V[1].dfs(NULL);
	for(int i=1;i<=n;i++) V[i].init();
	
	int q; scanf("%d",&q);
	while(q--){
		scanf("%d",&k);
		for(int i=0;i<k;i++){
			int x; scanf("%d",&x);
			a[i]=V+x;
		}
		a[k]=a[0];
		double area=0;
		for(int i=0;i<k;i++) area+=cross(a[i],a[i+1]);
		if(area<0){
			area*=-1;
			reverse(a,a+k);
		}
		int ans=0;
		for(int i=0;i<k;i++)
			ans+=a[i]->calc(a[i==0?k-1:i-1],a[i+1==k?0:i+1]);
		if(ans<=0)
			ans+=n;
		printf("%d\n",ans);
	}
}
