/*
ID: keyvank2
TASK: combo
LANG: C++
*/

#include <bits/stdc++.h>

#define ff first
#define ss second
#define pb push_back
#define mp make_pair
#define FOR(i,j,k) for(int i = j; i < (int)(k); i++)
#define FORV(i, v) FOR(i, 0, ((v).size()))
#define REP(i,j,k) for(int i = j; i >= (int)(k); i--)
#define setmax(i) const int maxn = (int) i;
#define setmod(i) const int MOD = (int) i;
#define all(a) a.begin(),a.end()
#define autodef(x,v) typeof(v) x = (v)
#define autoref(x,v) typeof(v)& x = (v)
#define forit(it, c) for (autodef(it, ((c).begin())); it != ((c).end()); ++it)

//typedef complex<double> Point;
//#define X real()
//#define Y imag()

using namespace std;

//ifstream fin("");
//ofstream fout("");
//#define cin fin
//#define cout fout

typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef pair<ld,ld> pdd;
typedef pair<pii,int> ppi;
typedef pair<pll,ll> ppl;
typedef pair<int,pii> pip;
typedef pair<ll,pll> plp;
typedef pair<pii,pii> ppp;

const int INF = (int) 2e9;
const ll INFL = (ll) 9e18;
const int MAXINT = ((~0) ^ (1 << 31));
const ll MAXLL = ((~0) ^ ((ll)1 << 63));

template<class T> inline T pow2(T a) { return a*a;}
template<class T> inline bool mineq(T& a, T b){return (a > b) ? (a=b, true) : false;}
template<class T> inline bool maxeq(T& a, T b){return (a < b) ? (a=b, true) : false;}

//srand (time(NULL));

bool debug = 0;

setmax(1e5+10);

struct edge
{
    int x, flow;
    ld ang;
    edge(int a = 0)
    {
	x = a;
	flow = 0;
	ang = 0;
    }
    bool operator < (const edge& b) const
    {
	return ang < b.ang;
    }
};

int n,m,q;

pii pos[maxn];
vector<edge> adj[maxn];

bool visited[maxn];
int dfs(int v, int par)
{
    int ans = 0, pr = -1;
    visited[v] = true;

    FOR(i,0,adj[v].size())
    {
	int u = adj[v][i].x;
	if(u == par)
	{
	    pr = i;
	    continue;
	}
	
	if(!visited[u])
	    ans += adj[v][i].flow = dfs(u,v);
    }
    
    if(debug)
	cout << "dfs:  " << v << " " << pr << " " << ans << endl;

    if(pr != -1)
	adj[v][pr].flow = -ans+1;
    return ans-1;
}

void checkdfs()
{
    FOR(i,0,n+1)
    {
	cout << "flow: " << i << " : " << endl;
	FOR(j,0,adj[i].size())
	{
	    cout << adj[i][j].x << " " << adj[i][j].flow << endl;
	}
    }
}

map<int,int> getid[maxn];

void sortedge(int v)
{
    FOR(i,0,adj[v].size())
    {
	int u = adj[v][i].x;
	adj[v][i].ang = atan2(pos[u].ss - pos[v].ss, pos[u].ff - pos[v].ff);
    }

    sort(all(adj[v]));
    FOR(i,1,adj[v].size())
    {
	adj[v][i].flow += adj[v][i-1].flow;
    }

    FOR(i,0,adj[v].size())
    {
	if(debug)
	    cout << "id: " << v << " " << adj[v][i].x << " " << i << endl;
	getid[v][adj[v][i].x] = i;
    }

    if(debug)
    {
	cout << "ang : " << v << " : ";
	FOR(i,0,adj[v].size())
	    cout << adj[v][i].x << " ";
	cout << endl;
    }
}

ld area(vi &v)
{
    ld ans = 0;
    int n = v.size();
    FOR(i,0,n)
    {
	int x = v[i];
	int y = v[(i+1)%n];
	ans += (ll)(pos[x].ff + pos[y].ff) * (pos[y].ss - pos[x].ss);
    }
    return ans;
}

int range(int v, int l, int r)
{
    if(debug)
	cout << "range : " << v << " " << l << " "<< r << endl;
    if(l <= r)
    {
	return adj[v][r-1].flow - adj[v][l].flow;
    }
    else
    {
	return adj[v].back().flow - adj[v][l].flow + (r ? adj[v][r-1].flow : 0);
    }
    return 0;
}

int solve(vi &v)
{
    int n = v.size();
    int ans = 0;
    FOR(i,0,n)
    {
	int pr = (i-1+n)%n;
	int nx = (i+1)%n;

	if(debug)
	    cout << "solve " << v[i] << " " << v[pr] << " " << v[nx] << endl;

	ans += range(v[i],getid[v[i]][v[pr]],getid[v[i]][v[nx]]);
    }
    return ans;
}

int main()
{
    ios_base::sync_with_stdio(0);cin.tie(0);

    cin >> n >> m;
    FOR(i,0,m)
    {
	int a, b;
	cin >> a >> b;
	
	adj[a].pb(edge(b));
	adj[b].pb(edge(a));
    }

    FOR(i,1,n+1)
	cin >> pos[i].ff >> pos[i].ss;

    pos[0].ff = pos[0].ss = -INF;
    int v = min_element(pos+1, pos+n+1) - (pos);

    if(debug)
	cout << "min element : " << v << endl;

    adj[0].pb(edge(v));
    adj[v].pb(edge(0));

    dfs(0,-1);
    
    if(debug)
	checkdfs();

    FOR(i,0,n+1)
	sortedge(i);
    
    if(debug)
	checkdfs();

    cin >> q;
    FOR(i,0,q)
    {
	int sz;
	vi v;

	cin >> sz;
	FOR(j,0,sz)
	{
	    int a;
	    cin >> a;
	    v.pb(a);
	}

	if(debug)
	{
	    cout << "area : " << i << " " << area(v) << endl;
	}

	if(area(v) < 0)
	    reverse(all(v));
	
	cout << solve(v) << "\n";
    }
}
