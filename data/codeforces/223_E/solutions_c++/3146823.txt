#include<iostream>
#include<algorithm>
#include<vector>
#include<cmath>
using namespace std;
typedef long long ll;
typedef pair<int,int> PII;
typedef pair<int,double> PID;

struct Edge{
	int u,v,val;
	Edge(int u=0,int v=0,int val=0) : u(u) , v(v) , val(val) {}
};

#define X first
#define Y second
#define F first
#define S second
#define N(x) ((int)adj[x].size())
#define next(x) (x+1==k?0:x+1)
#define prev(x) (x==0?k-1:x-1)
#define E e[adj[v][i].F]
#define dif(x,y) p[x].Y - p[y].Y , p[x].X - p[y].X
#define PA(x) (lower_bound(adj[base].begin(),adj[base].end(),x,cmp)-adj[base].begin())

ll cross(PII a,PII b) { return (ll)a.X*b.Y - (ll)a.Y*b.X; }
PII operator-(PII a,PII b) { return PII(a.X-b.X,a.Y-b.Y); }

const int MAX = 100*1000+1;
const int INF = 1<<30;

vector<PID> adj[MAX+10];
vector<int> ps[MAX+10];
bool mrk[MAX+10];
Edge e[MAX+10];
PII p[MAX+10];
int a[MAX+10];
int n,m,q,k;
int head=0;
int base;

bool cmp(PID a,PID b) { return a.S < b.S; }

void input();
void query();
void init();

int main()
{
	input();
	init();
	cin >> q;
	for(int i=0; i<q; i++)
		query();
	return 0;
}

ll area()
{
	ll ret = 0;
	for(int i=0; i<k; i++)
	{
		ret += cross(p[a[i]],p[a[next(i)]]);
		//cerr << a[i] << " " << a[next(i)] << "   " << cross(p[a[i]],p[a[next(i)]]) << endl;
	}
	//cerr << ret << endl;
	return ret;
}

inline int flow(int i)
{
	//cerr << a[i] << " " << a[prev(i)] << " " << a[next(i)] << "      ";
	//cerr << N(a[i]) << "   ";
	base = a[i];
	int F = PA( PID( 0 , atan2( dif( a[prev(i)] , a[i] ) ) ) );
	int S = PA( PID( 0 , atan2( dif( a[next(i)] , a[i] ) ) ) );
	Edge FFF = e[adj[a[i]][F].F];
	Edge SSS = e[adj[a[i]][S].F];
	//cerr << FFF.u + FFF.v - a[i] << " " << SSS.u + SSS.v - a[i] << endl;
	if( S < F )
		return ps[a[i]][S] + ps[a[i]][N(a[i])] - ps[a[i]][F+1];
	else
		return ps[a[i]][S] - ps[a[i]][F+1];
}

void query()
{
	cin >> k;
	for(int i=0; i<k; i++)
		cin >> a[i] , a[i]--;
	if( area() < 0 )
	{
		reverse( a , a+k );
	//	cerr << "rev" << endl;
	}
	
	int sum = 0;
	for(int i=0; i<k; i++)
		sum += flow(i);
	
	cout << sum << endl;
}

int dfs(int v)
{
	//cerr << v << endl;
	mrk[v] = true;
	int ret = 1;
	for(int i=0; i<N(v); i++)
	{
		int u = E.u + E.v - v;
		if( !mrk[u] )
		{
			int tmp = dfs(u);
			ret += tmp;
			if( v == E.u )
				E.val += tmp;
			else
				E.val -= tmp;
		}
	}
	return ret;
}

void init()
{
	p[n] = PII(INF,INF);
	int mxp = 0;
	for(int i=1; i<n; i++)
		if( p[i] > p[mxp] )
			mxp = i;
	
	adj[n].push_back(PID(head,0));
	adj[mxp].push_back(PID(head,0));
	e[head++] = Edge(n,mxp);
	
	//cerr << mxp << endl;

	dfs(n);

	
	for(int i=0; i<n; i++)
	{
		for(int j=0; j<N(i); j++)
		{
			int u = e[adj[i][j].F].u + e[adj[i][j].F].v - i;
			adj[i][j].S = atan2( dif(u,i) );
		}
		sort( adj[i].begin() , adj[i].end() , cmp );
	}
	
	for(int i=0; i<n; i++)
	{
		ps[i].push_back(0);
	//	cerr << "#ver " << i << "  :  \n";
		for(int j=0; j<N(i); j++)
		{
			if( i == e[adj[i][j].F].u )
				ps[i].push_back(ps[i].back()-e[adj[i][j].F].val);
			else
				ps[i].push_back(ps[i].back()+e[adj[i][j].F].val);
		//	cerr << e[adj[i][j]].u + e[adj[i][j]].v - i << " " << e[adj[i][j]].val << " ";
	//		cerr << ps[i].back() << "\n";
		}
	//	cerr << endl;
	}
}

void input()
{
	ios::sync_with_stdio(false);
	cin >> n >> m;
	for(int i=0; i<m; i++)
	{
		int u,v;
		cin >> u >> v;
		u--; v--;
		adj[u].push_back(PID(head,0));
		adj[v].push_back(PID(head,0));
		e[head++] = Edge(u,v);
	}
	for(int i=0; i<n; i++)
		cin >> p[i].X >> p[i].Y;
}







