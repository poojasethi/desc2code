#include <cstdio>
#include <cstring>
#include <algorithm>
#define FOR(i,s,e) for (int i=(s); i<(e); i++)
#define FOE(i,s,e) for (int i=(s); i<=(e); i++)
#define FOD(i,s,e) for (int i=(s)-1; i>=(e); i--)
#define CLR(a,x) memset(a, x, sizeof(a))
#define EXP(i,l) for (int i=(l); i; i=qn[i])
#define LLD long long
#define N 100005
#define M 200005
using namespace std;

struct vect{
	int x, y, w, f;
	vect(){}
	vect(int x, int y, int f) : x(x), y(y), w(x < 0 || (!x && y < 0) ? 0 : 1), f(f){}
	bool operator < (vect const &T) const{
		if (w != T.w) return w < T.w;
		return x * 1LL * T.y > y * 1LL * T.x;
	};
};


int n, m, x, y, ed, t, cnt, len, ret;
int l[N], px[N], py[N], deg[N], vis[N], cyc[N], des[N];
int qd[M], qn[M], flow[M];
int *sum[N];
int MLC2[M];
vect MLC1[M], buf[N];
vect *adj[N];
LLD area;

void bd(int x, int y){
	qd[++ed] = y, qn[ed] = l[x], l[x] = ed;
}

void dfs(int x){
	vis[x] = 1;
	des[x] = 0;
	EXP(i,l[x]){
		if (vis[qd[i]]) continue;
		dfs(qd[i]);
		flow[i] = des[qd[i]] + 1;
		flow[i^1] = -flow[i];
		des[x] += flow[i];
	}
}

int locate(int x, int y){
	return lower_bound(adj[x], adj[x] + deg[x], vect(px[y] - px[x], py[y] - py[x], 0)) - adj[x];
}

int main(){
	scanf("%d%d", &n, &m);
	ed = 1;
	FOR(i,0,m){
		scanf("%d%d", &x, &y);
		x--, y--;
		bd(x, y), bd(y, x);
	}
	FOR(i,0,n) scanf("%d%d", &px[i], &py[i]);

	// find sink vertex
	t = 0;
	FOR(i,0,n){
		if (px[i] < px[t]) t = i;
	}

	// run flow
	dfs(t);

	// sort by polar & make partial sums
	cnt = 0;
	FOR(i,0,n){
		t = 0;
		EXP(j,l[i]) buf[t++] = vect(px[qd[j]] - px[i], py[qd[j]] - py[i], flow[j]);
		sort(buf, buf + t);

		deg[i] = t;
		adj[i] = &MLC1[cnt];
		sum[i] = &MLC2[cnt];
		cnt += t;
		FOR(j,0,t){
			adj[i][j] = buf[j];
			sum[i][j] = buf[j].f;
			if (j) sum[i][j] += sum[i][j-1];
		}
	}

	// process query
	scanf("%d", &m);
	while (m--){
		scanf("%d", &len);
		FOR(i,0,len) scanf("%d", &cyc[i]), cyc[i]--;
		cyc[len] = cyc[0];

		// reverse if clockwise
		area = 0;
		FOR(i,0,len) area += px[cyc[i]] * 1LL * py[cyc[i+1]] - px[cyc[i+1]] * 1LL * py[cyc[i]];
		if (area < 0) reverse(cyc, cyc + len), cyc[len] = cyc[0];

		ret = len;
		FOR(i,0,len){
			t = cyc[i];
			x = locate(t, cyc[(i+len-1)%len]);
			y = locate(t, cyc[i+1]);

			if (x >= y) ret += sum[t][x-1] - sum[t][y];
			else ret += sum[t][deg[t]-1] - sum[t][y] + (x ? sum[t][x-1] : 0);
		}
		printf("%d\n", ret);
	}
	return 0;
}
