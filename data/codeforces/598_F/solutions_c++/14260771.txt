#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;

typedef long long int ll;

typedef long double ldouble;

struct point {
  ll x,y;
  point() {
  }
  point(ll inx,ll iny) {
    x=inx;y=iny;
  }
};

point operator-(point p1,point p2)
{
  p1.x-=p2.x;
  p1.y-=p2.y;
  return p1;
}


ll prodvec(point p1,point p2)
{
  return p1.x*p2.y-p1.y*p2.x;
}

ll prodesc(point p1,point p2)
{
  return p1.x*p2.x+p1.y*p2.y;
}

point rotar(point a,point p)
{
  return point(prodesc(a,p),prodvec(a,p));
}

ldouble abs(point p)
{
  ldouble x=p.x;
  ldouble y=p.y;
  return sqrt(x*x+y*y);
}

ll leer()
{
  ldouble x;
  cin>>x;
  return round(x*100);
}

point leerpunto()
{
  ll x=leer();
  ll y=leer();
  return point(x,y);
}

int main()
{
  cout.setf(ios::fixed);
  cout.precision(10);
  int n,casos;
  cin>>n>>casos;
  vector<point> v(n);
  for (int i=0;i<n;i++)
    v[i]=leerpunto();
  for (int caso=0;caso<casos;caso++) {
    point p=leerpunto();
    point q=leerpunto();
    point d=q-p;
    ldouble modulod=abs(d);
    vector<point> w(n);
    vector<ldouble> xx(n),yy(n);
    for (int i=0;i<n;i++) {
      w[i]=rotar(d,v[i]-p);
      if (w[i].x!=0 or w[i].y!=0) {
	xx[i]=w[i].x;
	yy[i]=w[i].y;
      } else {
	xx[i]=yy[i]=0;
      }
    }
    /*
    cout<<"d "<<d.x<<","<<d.y<<" "<<modulod<<endl;
    for (int i=0;i<n;i++)
      cout<<"("<<w[i].x<<","<<w[i].y<<","<<xx[i]<<","<<yy[i]<<")"<<endl;
    */
    vector<pair<ldouble,int> > lista;
    for (int i=0;i<n;i++) {
      int nexti=(i+1)%n;
      int anti=(i-1+n)%n;
      point p=w[i];
      point antp=w[anti];
      point nextp=w[nexti];
      if ((p.y<0 and 0<nextp.y) or (nextp.y<0 and 0<p.y)) {
	ldouble x=xx[i];
	ldouble y=yy[i];
	ldouble nextx=xx[nexti];
	ldouble nexty=yy[nexti];
	lista.push_back(pair<ldouble,int> (x+(nextx-x)*abs(y)/abs(y-nexty),0));
	//cout<<"cruce "<<v[i].x<<" "<<v[i].y<<" "<<v[nexti].x<<" "<<v[nexti].y<<" "<<lista.back().first<<endl;
      } else if (p.y==0) {
	ldouble x=xx[i];
	if (antp.y<0) {
	  if (nextp.y>0) {
	    lista.push_back(pair<ldouble,int> (x,0));
	  } else if (nextp.y==0) {
	    lista.push_back(pair<ldouble,int> (x,-1));
	  }
	} else if (antp.y>0) {
	  if (nextp.y<0) {
	    lista.push_back(pair<ldouble,int> (x,0));
	  } else if (nextp.y==0) {
	    lista.push_back(pair<ldouble,int> (x,1));
	  }
	} else if (nextp.y<0) {
	  lista.push_back(pair<ldouble,int> (x,-1));
	} else if (nextp.y>0) {
	  lista.push_back(pair<ldouble,int> (x,1));
	}
      }
    }
    sort(lista.begin(),lista.end());
    bool dentro=false;
    ldouble antx;
    ldouble sol=0;
    for (int i=0;i<int(lista.size());i++) {
      ldouble x=lista[i].first;
      int s=lista[i].second;
      if (dentro) 
	sol+=x-antx;
      if (s==0) {
	dentro=not dentro;
      } else {
	sol+=lista[i+1].first-x;
	dentro=dentro xor (lista[i+1].second!=s);
	i++;
      }
      antx=lista[i].first;
    }
    //cout<<modulod<<endl;
    cout<<sol/(100.0*modulod)<<endl;
  }
}

