#include<iostream>
#include<vector>
#include<algorithm>
#include<cstdio>
#include<map>
#include<set>
#include<cstring>
#include<string>
#include<queue>
#include<cctype>
#include<functional>
#include<fstream>
#include<sstream>
#include<complex>
#include<cmath>
#include<cstdlib>

using namespace std;

#define EPS 1.0e-10
#define REP(i,n) for(int i=0;i<n;i++)
#define ALL(t) t.begin(),t.end()
#define FOR(it,c) for(__typeof((c).begin()) it = (c).begin();it != (c).end();++it)
#define ll long long
#define mp make_pair
#define pb push_back
#define F first
#define S second
const int SIZE=100100;
struct State{
	int y,x,cost,bit;
	vector< pair<int,int> > check;
};
bool operator<(const State&a,const State&b){
	return a.cost>b.cost;
}
bool visit[1<<7+1][128][128];
int dx[]={0,0,1,-1},dy[]={1,-1,0,0};
int main(){
	int n,m,k;
	while(cin>>n>>m>>k){
		int root[128][128];
		REP(i,n) REP(j,m) cin>>root[i][j];
		REP(i,1<<k) REP(j,n) REP(kk,m) visit[i][j][kk]=false;
		priority_queue<State>Q;
		int f[128][128]={0};
		bool ans[128][128]={0};
		REP(i,k){
			vector< pair<int,int> > ss;
			int x,y;
			cin>>y>>x;
			x--; y--;
			f[y][x]=i+1;
			ans[y][x]=true;
			Q.push((State){y,x,root[y][x],0,ss});
		}
		
		while(!Q.empty()){
			State b=Q.top(); Q.pop();
			
			if(f[b.y][b.x]!=0) if(! ( b.bit&(1<<(f[b.y][b.x]-1) ) ) ){
				b.bit+=( 1<<(f[b.y][b.x]-1) );
				FOR(it,b.check) visit[b.bit][(*it).F][(*it).S]=true;
				FOR(it,b.check){
					REP(i,4){
						int y=dy[i]+(*it).F,x=dx[i]+(*it).S,c;
						if(x<0 || y<0 || y==n || x==m || visit[b.bit][y][x]) continue;
						c=b.cost+root[y][x];
						Q.push((State){y,x,c,b.bit,b.check});
					}
				}
			}
		//	cout<<b.bit<<" "<<b.y<<" "<<b.x<<endl;
			if(visit[b.bit][b.y][b.x]) continue;
			visit[b.bit][b.y][b.x]=true;
			b.check.pb( mp(b.y,b.x) );
			if( b.bit==((1<<k)-1) ){
				cout<<b.cost<<endl;
				
				REP(i,b.check.size()) ans[b.check[i].F][b.check[i].S]=true;
				REP(i,n){
					REP(j,m){
						if(ans[i][j]) cout<<"X";
						else cout<<".";
					}
					cout<<endl;
				}
				break;
			}
			REP(i,4){
				int x=dx[i]+b.x,y=dy[i]+b.y,c;
				if(x<0 || y<0 || y==n || x==m || visit[b.bit][y][x] ) continue;
				c=b.cost+root[y][x];
				Q.push((State){y,x,c,b.bit,b.check});
			}
		}
		
	}
	return 0;
}
