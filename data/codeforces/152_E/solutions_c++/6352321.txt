#include <iostream>
#include <algorithm>
#include <set>
#include <string>
#include <vector>
#include <cmath>
using namespace std;


#define Size(s) ((int)s.size())
#define rep(i, n) for(int i=0; i<n; ++i)
#define Foreach(i, x) for (__typeof(x.begin()) i = x.begin(); i != x.end(); i++)
#define F first
#define S second

template<class P, class Q> inline void mmin(P &a, Q b) { if (b < a) a = b; }
template<class P, class Q> inline void mmax(P &a, Q b) { if (a < b) a = b; }

typedef long long LL;
typedef pair<int, int> pii;

const int MAXn = 200 + 5, MAXk = 7;
const int INF = 1e9;
int n, m, k;
int val[MAXn], imp[MAXk];
int dis[MAXn][MAXn];
int dp[1<<7][MAXn];
bool mark[MAXn];

void solve(int mask, int i)
{
	mark[i] = true;
	if((mask-1) & mask==0 && dp[mask][i]==val[i])
		return;
	
	for(int sub=(mask-1) & mask; sub; sub = (sub-1) & mask) {
		if(dp[mask][i] == dp[sub][i]+dp[mask ^ sub][i]-val[i]) {
			solve(sub, i);
			solve(mask ^ sub, i);
			return;
		}
	}

	if(i%m>0 && dp[mask][i-1]+val[i]==dp[mask][i]){ solve(mask, i-1); return;}
	if(i%m<m-1 && dp[mask][i+1]+val[i]==dp[mask][i]){ solve(mask, i+1); return;}
	if(i-m>=0 && dp[mask][i-m]+val[i]==dp[mask][i]){ solve(mask, i-m); return;}
	if(i+m<n && dp[mask][i+m]+val[i]==dp[mask][i]){ solve(mask, i+m); return;}
}

int main()
{
	ios_base::sync_with_stdio(false);

	cin >> n >> m >> k;
	n *= m;
	rep(i, n)
		cin >> val[i];

	rep(i, k) {
		int x, y;
		cin >> x >> y;
		--x; --y;
		imp[i] = x*m+y;
	}

	rep(i, n) rep(j, n) {
		if(i==j) {
			dis[i][j] = 0;
			continue;
		}

		dis[i][j] = INF;
		if(i/m==j/m && abs(i-j)==1)
			dis[i][j] = val[j];
		if(i%m==j%m && abs(i-j)==m)
			dis[i][j] = val[j];
	}	

	rep(z, n) rep(i, n) rep(j, n)
		mmin(dis[i][j], dis[i][z] + dis[z][j]);

	rep(i, 1<<k) rep(j, n)
		dp[i][j] = INF;
	rep(i, k) {
		dp[1<<i][imp[i]] = val[imp[i]];
	}

	for(int mask=1; mask<(1<<k); ++mask) {
		rep(i, n)
			for(int sub=(mask-1) & mask; sub; sub = (sub-1) & mask)
				mmin(dp[mask][i], dp[sub][i] + dp[mask ^ sub][i] - val[i]);
		rep(i, n)
			rep(j, n)
				mmin(dp[mask][i], dp[mask][j] + dis[j][i]);
	}

	int ans = INF, umask=(1<<k)-1, ui;
	rep(i, n)
		if(dp[(1<<k)-1][i] < ans) {
			ui = i;
			ans = dp[umask][ui];
		}

	cout << ans << endl;
//	return 0;
	solve(umask, ui);
	rep(i, n) {
		cout << (mark[i] ? 'X' : '.');
		if((i+1)%m==0)
			cout << endl;
	}

	return 0;
}

