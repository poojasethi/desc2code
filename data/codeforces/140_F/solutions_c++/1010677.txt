#include<iostream>
#include<algorithm>
#include<iomanip>
#include<tr1/unordered_set>
#include<set>
using namespace std;
using namespace std::tr1;
struct P{
	int x, y;
}p[200000];
set<pair<int ,int> > ans;
int n, k;
struct cmp{
	bool operator()(const P &lhs, const P &rhs){
		if(lhs.x==rhs.x) return lhs.y<rhs.y;
		return lhs.x<rhs.x;
	}
};
void check_and_add(int cx,int cy){
	if(ans.count(make_pair(cx,cy)))	// this point already exist.
		return;
	int sum = 0;
	int j=n-1;
	for(int i=0;i<n;++i){
		long long tx = (long long)cx - (p[i].x - cx);
		long long ty = (long long)cy - (p[i].y - cy);
		while(j>=0 && (p[j].x > tx || (p[j].x == tx && p[j].y > ty)))
			--j;
		if(j<0 || tx != p[j].x || ty != p[j].y){
			if(++sum > k)
				return;
		}
	}
	ans.insert(make_pair(cx,cy));
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>k;
	for(int i=0; i<n; ++i){
		cin>>p[i].x>>p[i].y;
		p[i].x*=2;
		p[i].y*=2;
	}
	if(k>=n){
		cout<<-1<<endl;
		return 0;
	}
	sort(p, p+n, cmp());
	for(int i=0;i<min(n,k+1);++i)
		for(int _j=0;_j<min(n,k+1);++_j){
			int j = n - _j - 1;
			check_and_add((p[i].x+p[j].x)/2, (p[i].y+p[j].y)/2);
		}
	cout<<ans.size()<<endl;
	cout<<setprecision(10);
	for(set<pair<int ,int> >::iterator i = ans.begin(); i!=ans.end(); ++i){
		cout<<i->first/2.<<' '<<i->second/2.<<endl;
	}
	return 0;
}
