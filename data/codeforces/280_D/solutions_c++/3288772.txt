#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<fstream>
#include<map>
#include<ctime>
#include<set>
#include<queue>
#include<cmath>
#include<vector>
#include<bitset>
#include<functional>
#define x first
#define y second
#define mp make_pair
#define pb push_back
#define REP(i,l,r) for((i)=(l);(i)<=(r);++(i))
#define REP2(i,l,r) for((i)=(l);(i)!=(r);++(i))
using namespace std;

typedef long long LL;
typedef double ld;

const int MAX=400000+10;

int n,m;
int a[MAX];

typedef pair<int,pair<int,int> > F;

F operator + (const F& a,const F& b)
{
	if(a.y.x==-1)return b;
	if(b.y.x==-1)return a;
	return mp(a.x+b.x,mp(a.y.x,b.y.y));
}

struct node
{
	F minl,minr,mins;
	F maxl,maxr,maxs;
	F all;
	int flag;
}tree[MAX];

node operator + (const node& a,const node& b)
{
	node c;
	c.minl=min(a.minl,a.all+b.minl);
	c.minr=min(b.minr,a.minr+b.all);
	c.mins=min( min(a.mins,b.mins) , a.minr+b.minl );

	c.maxl=max(a.maxl,a.all+b.maxl);
	c.maxr=max(b.maxr,a.maxr+b.all);
	c.maxs=max( max(a.maxs,b.maxs) , a.maxr+b.maxl );

	c.all=a.all+b.all;
	c.flag=1;
	return c;
}

void my_swap(F& a,F& b)
{
	a.x=-a.x;
	b.x=-b.x;
	swap(a,b);
}

void rev(node& u)
{
	my_swap(u.minl,u.maxl);
	my_swap(u.minr,u.maxr);
	my_swap(u.mins,u.maxs);
	u.all.x*=-1;
}

void lab_it(int u)
{
	tree[u].flag*=-1;
	rev(tree[u]);
}

void down(int u)
{
	if(tree[u].flag==-1)
	{
		tree[u].flag*=-1;
		lab_it(u*2);
		lab_it(u*2+1);
	}
}

node One(int l,int c)
{
	node t;
	t.minl=t.minr=t.mins=mp(c,mp(l,l));
	t.maxl=t.maxr=t.maxs=mp(c,mp(l,l));
	t.all=mp(c,mp(l,l));
	t.flag=1;
	return t;
}

void build(int u,int l,int r)
{
	if(l==r)
	{
		tree[u]=One(l,a[l]);
		return;
	}
	int mid=(l+r)/2;
	build(u*2,l,mid);
	build(u*2+1,mid+1,r);
	tree[u]=tree[u*2]+tree[u*2+1];
}

void revise(int u,int l,int r,int x,int a)
{
	if(l==r)
	{
		tree[u]=One(l,a);
		return;
	}
	int mid=(l+r)/2;
	down(u);
	if(x<=mid)revise(u*2,l,mid,x,a);
	else revise(u*2+1,mid+1,r,x,a);
	tree[u]=tree[u*2]+tree[u*2+1];
}

void put_rev(int u,int l,int r,int a,int b)
{
	if(b<l || r<a)return;
	if(a<=l && r<=b)
	{
		lab_it(u);
		return;
	}
	down(u);
	int mid=(l+r)/2;
	put_rev(u*2,l,mid,a,b);
	put_rev(u*2+1,mid+1,r,a,b);
	tree[u]=tree[u*2]+tree[u*2+1];
}

node ask(int u,int l,int r,int a,int b)
{
	if(b<l || r<a)return One(-1,0);
	if(a<=l && r<=b)
		return tree[u];
	down(u);
	int mid=(l+r)/2;
	return ask(u*2,l,mid,a,b)+ask(u*2+1,mid+1,r,a,b);
}

int main()
{
#ifndef ONLINE_JUDGE
	freopen("input.txt","r",stdin);freopen("output.txt","w",stdout);
#endif
	int i,j;
	scanf("%d",&n);
	REP(i,1,n)
		scanf("%d",&a[i]);
	build(1,1,n);
	scanf("%d",&m);
	int type,l,r,a;
	REP(i,1,m)
	{
		scanf("%d",&type);
		if(type)
		{
			scanf("%d%d%d",&l,&r,&a);
			int sum=0;
			vector< pair<int,int> > change;
			REP2(j,0,a)
			{
				node ans=ask(1,1,n,l,r);
				if(ans.maxs.x>0)
				{
					sum+=ans.maxs.x;
					put_rev(1,1,n,ans.maxs.y.x,ans.maxs.y.y);
					change.pb(ans.maxs.y);
				}
				else break;
			}
			printf("%d\n",sum);
			REP2(j,0,change.size())
				put_rev(1,1,n,change[j].x,change[j].y);
		}
		else
		{
			scanf("%d%d",&l,&a);
			revise(1,1,n,l,a);
		}
	}
	return 0;
}
