#include <set>
#include <map>
#include <queue>
#include <vector>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#define rep(i,a,b) for (int i=a;i<=b;++i)
#define dep(i,a,b) for (int i=a;i>=b;--i)
#define pb push_back
#define mp make_pair
using namespace std;

const int nn=510000;

struct arr {
	int l,r,x;
};
struct node {
	arr l,r,m,L,R,M;
	int s,rev,ll,rr;
} t[nn];
queue< pair<int,int> > Q;
int n;
void merge(node &z,node x,node y) {
	z.s=x.s+y.s;
	z.l=x.l;
	if (x.s+y.l.x>z.l.x) z.l.l=z.ll,z.l.r=y.l.r,z.l.x=x.s+y.l.x;
	z.r=y.r;
	if (y.s+x.r.x>z.r.x) z.r.r=z.rr,z.r.l=x.r.l,z.r.x=y.s+x.r.x;
	z.m=z.l;
	if (z.m.x<z.r.x) z.m=z.r;
	if (x.r.x+y.l.x>z.m.x) z.m.x=x.r.x+y.l.x,z.m.l=x.r.l,z.m.r=y.l.r;
	if (!z.m.l) z.m.l=y.ll;
	if (!z.m.r) z.m.r=x.rr;
	if (x.m.x>z.m.x) z.m=x.m;
	if (y.m.x>z.m.x) z.m=y.m;
	
	z.L=x.L;
	if (x.s+y.L.x<z.L.x) z.L.l=z.ll,z.L.r=y.L.r,z.L.x=x.s+y.L.x;
	z.R=y.R;
	if (y.s+x.R.x<z.R.x) z.R.r=z.rr,z.R.l=x.R.l,z.R.x=y.s+x.R.x;
	z.M=z.L;
	if (z.M.x>z.R.x) z.M=z.R;
	if (x.R.x+y.L.x<z.M.x) z.M.x=x.R.x+y.L.x,z.M.l=x.R.l,z.M.r=y.L.r;
	if (!z.M.l) z.M.l=y.ll;
	if (!z.M.r) z.M.r=x.rr;
	if (x.M.x<z.M.x) z.M=x.M;
	if (y.M.x<z.M.x) z.M=y.M;
}
void r(int &x) { x=-x; }
void mark(int p) {
	t[p].rev^=1;
	t[p].s=-t[p].s;
	swap(t[p].l,t[p].L); r(t[p].l.x);r(t[p].L.x);
	swap(t[p].r,t[p].R); r(t[p].r.x);r(t[p].R.x);
	swap(t[p].m,t[p].M); r(t[p].m.x);r(t[p].M.x);
}
void push(int p) {
	if (!t[p].rev) return;
	int lc=p<<1,rc=lc+1;
	t[p].rev=0;
	mark(lc); mark(rc);
}
void insert(int p,int l,int r,int x,int y) {
	if (l==r) {
		t[p].s=y;
		if (y>0) t[p].l=t[p].r=t[p].m=(arr){l,r,y};
		else t[p].l=t[p].r=t[p].m=(arr){0,0,0};
		if (y<0) t[p].L=t[p].R=t[p].M=(arr){l,r,y};
		else t[p].L=t[p].R=t[p].M=(arr){0,0,0};		
		return;
	}
	push(p);
	int mid=l+r>>1,lc=p<<1,rc=lc+1;
	if (x<=mid) insert(lc,l,mid,x,y);
	else insert(rc,mid+1,r,x,y);
	merge(t[p],t[lc],t[rc]);
}
node get(int p,int l,int r,int x,int y) {
	if (x==l && y==r) return t[p];
	int mid=l+r>>1,lc=p<<1,rc=lc+1; push(p);
	if (y<=mid) return get(lc,l,mid,x,y);
	else if (x>mid) return get(rc,mid+1,r,x,y);
	else {
		node tmp; tmp.ll=l; tmp.rr=r;
		node tmp1=get(lc,l,mid,x,mid),tmp2=get(rc,mid+1,r,mid+1,y);
		merge(tmp,tmp1,tmp2);
		return tmp;
	}
}
void change(int p,int l,int r,int x,int y) {
	if (y<l || r<x) return;
	if (x<=l && r<=y) { mark(p);return; }
	int mid=l+r>>1,lc=p<<1,rc=lc+1; push(p);
	change(lc,l,mid,x,y);
	change(rc,mid+1,r,x,y);
	merge(t[p],t[lc],t[rc]);
}
void build(int p,int l,int r) {
	int mid=l+r>>1,lc=p<<1,rc=lc+1;
	t[p].l=t[p].L=t[p].r=t[p].R=t[p].m=t[p].M=(arr){l,r,0};
	t[p].ll=l;t[p].rr=r;
	if (l==r) return;
	if (l<=mid) build(lc,l,mid);
	if (mid+1<=r) build(rc,mid+1,r);
}
int main() {
	int x,y,q,opt,ans,k;
	scanf("%d",&n);
	build(1,1,n);
	rep(i,1,n) 
	scanf("%d",&x),insert(1,1,n,i,x);
	scanf("%d",&q);
	while (q--) {
		scanf("%d",&opt);
		if (opt==0) scanf("%d%d",&x,&y),insert(1,1,n,x,y);
		else {
			scanf("%d%d%d",&x,&y,&k); ans=0;
			rep(i,1,k) {
				node temp=get(1,1,n,x,y);
				arr tmp=temp.m;
				if (tmp.x<0) break;
				ans+=tmp.x;
				change(1,1,n,tmp.l,tmp.r);
				Q.push(mp(tmp.l,tmp.r));
			}
			while (Q.size()) {
				pair<int,int> tmp=Q.front(); Q.pop();
				change(1,1,n,tmp.first,tmp.second);
			}
			printf("%d\n",ans);
		}
	}
	return 0;
}