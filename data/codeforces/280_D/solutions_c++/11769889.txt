#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 101000;

int a[N], n, m, lab[N * 4], rag[50][2];

struct node
{
	int b, s, lb, ls, rb, rs;
	int bl, br;
	int sl, sr;
	int lbp, lsp, rbp, rsp;
	int sum;

	void init(int x, int p)
	{
		sum = b = s = lb = ls = rb = rs = x;
		bl = br = sl = sr = lbp = lsp = rbp = rsp = p;
	}
	
	void flip(int x)
	{
		swap(bl, sl); swap(br, sr); swap(lbp, lsp); swap(rbp, rsp);
		b = -b; s = -s; swap(b, s);
		lb = -lb; ls = -ls; swap(lb, ls);
		rb = -rb; rs = -rs; swap(rb, rs);
		sum = -sum;
		lab[x] *= -1;
	}
} T[N * 4], get;

node upd(node x, node y)
{
	node z; z.init(0, 0);
	if (x.bl == 0) return y;
	z.b = x.b, z.bl = x.bl, z.br = x.br;
	if (y.b > z.b) z.b = y.b, z.bl = y.bl, z.br = y.br;
	if (x.rb + y.lb > z.b) z.b = x.rb + y.lb, z.bl = x.rbp, z.br = y.lbp;
	
	z.s = x.s, z.sl = x.sl, z.sr = x.sr;
	if (y.s < z.s) z.s = y.s, z.sl = y.sl, z.sr = y.sr;
	if (x.rs + y.ls < z.s) z.s = x.rs + y.ls, z.sl = x.rsp, z.sr = y.lsp;
	
	z.lb = x.lb; z.lbp = x.lbp;
	if (x.sum + y.lb > z.lb) z.lb = x.sum + y.lb, z.lbp = y.lbp;
	
	z.ls = x.ls; z.lsp = x.lsp;
	if (x.sum + y.ls < z.ls) z.ls = x.sum + y.ls, z.lsp = y.lsp;
	
	z.rb = y.rb; z.rbp = y.rbp;
	if (y.sum + x.rb > z.rb) z.rb = y.sum + x.rb, z.rbp = x.rbp;
	
	z.rs = y.rs; z.rsp = y.rsp;
	if (y.sum + x.rs < z.rs) z.rs = y.sum + x.rs, z.rsp = x.rsp;
	
	z.sum = x.sum + y.sum;
	return z;
}

void mkt(int x, int l, int r)
{
	lab[x] = 1;
	if (l == r)
	{
		T[x].init(a[l], l);
		return;
	}
	
	int mid = (l + r) >> 1;
	mkt(x + x, l, mid);
	mkt(x + x + 1, mid + 1, r);
	T[x] = upd(T[x + x], T[x + x + 1]);
}

void modi(int x, int l, int r, int p, int v)
{
	if (l == r)
	{
		T[x].init(v, p);
		return;
	}
	if (lab[x] == -1)
	{
		lab[x] = 1;
		T[x + x].flip(x + x);
		T[x + x + 1].flip(x + x + 1);
	}
	int mid = (l + r) >> 1;
	if (p <= mid) modi(x + x, l, mid, p, v); else modi(x + x + 1, mid + 1, r, p, v);
	T[x] = upd(T[x + x], T[x + x + 1]);
}

void getma(int x, int l, int r, int ql, int qr)
{
	ql = max(l, ql); qr = min(qr, r); if (ql > qr) return;
	if (ql == l && qr == r)
	{
		get = upd(get, T[x]);
		return;
	}
	if (lab[x] == -1)
	{
		lab[x] = 1;
		T[x + x].flip(x + x);
		T[x + x + 1].flip(x + x + 1);
	}
	
	int mid = (l + r) >> 1;
	getma(x + x, l, mid, ql, qr);
	getma(x + x + 1, mid + 1, r, ql, qr);
	T[x] = upd(T[x + x], T[x + x + 1]);
}

void flip(int x, int l, int r, int ql, int qr)
{
	ql = max(l, ql); qr = min(qr, r); if (ql > qr) return;
	if (ql == l && qr == r)
	{
		T[x].flip(x);
		return;
	}
	if (lab[x] == -1)
	{
		lab[x] = 1;
		T[x + x].flip(x + x);
		T[x + x + 1].flip(x + x + 1);
	}
	int mid = (l + r) >> 1;
	flip(x + x, l, mid, ql, qr);
	flip(x + x + 1, mid + 1, r, ql, qr);
	T[x] = upd(T[x + x], T[x + x + 1]);
}

int main()
{

	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
	mkt(1, 1, n);
	scanf("%d", &m);
	for (int i = 1; i <= m; i++)
	{
		int type, l, r, k;
		scanf("%d", &type);
		if (type == 0)
		{
			scanf("%d%d", &l, &k);
			modi(1, 1, n, l, k);
		} else 
		{
			int ans = 0, j;
			scanf("%d%d%d", &l, &r, &k);
			for (j = 1; j <= k; j++)
			{
				get.init(0, 0);
				getma(1, 1, n, l, r);
				if (get.b > 0) 
				{
					ans += get.b;
					rag[j][0] = get.bl;
					rag[j][1] = get.br;
					flip(1, 1, n, get.bl, get.br);
				} else break;
			}
			for (int jj = j - 1; jj; jj--) flip(1, 1, n, rag[jj][0], rag[jj][1]);
			printf("%d\n", ans);
		}
	}
	
	return 0;
}
