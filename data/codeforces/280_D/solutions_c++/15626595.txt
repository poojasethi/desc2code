#include <bits/stdc++.h>
#define ls rt << 1
#define rs rt << 1 | 1
#define lson ls, l, m
#define rson rs, m + 1, r
#define pii pair <int, int>
#define LL long long
#define xx first
#define yy second
using namespace std;

const int N = 100100, mod = 1e9 + 7;

struct P {
    int vl, vr, vm, s, pl, pr, l, r;
    P () {}
    P (int p, int x) { pl = pr = l = r = p; s = vl = vr = vm = x; }
};

P add (P a, P b) {
    P c;
    if (a.vm >= b.vm) c = a;
    else c = b;
    if (c.vm < a.vr + b.vl) c.vm = a.vr + b.vl, c.l = a.pr, c.r = b.pl;
    c.s = a.s + b.s;
    if (a.vl >= b.vl + a.s) c.vl = a.vl, c.pl = a.pl;
    else c.vl = b.vl + a.s, c.pl = b.pl;
    if (b.vr >= a.vr + b.s) c.vr = b.vr, c.pr = b.pr;
    else c.vr = a.vr + b.s, c.pr = a.pr;
    return c;
}

P mx[N << 2], mn[N << 2];
int lazy[N << 2], a[N];

void up (int rt) {
    mx[rt] = add (mx[ls], mx[rs]);
    mn[rt] = add (mn[ls], mn[rs]);
}

void down (int rt) {
    if (lazy[rt]) {
        lazy[ls] ^= 1;
        lazy[rs] ^= 1;
        swap (mx[ls], mn[ls]);
        swap (mx[rs], mn[rs]);
        lazy[rt] = 0;
    }
}

void build (int rt, int l, int r) {
    if (l == r) {
        mx[rt] = P (l, a[l]);
        mn[rt] = P (l, -a[l]);
        return;
    }
    int m = l + r >> 1;
    build (lson);
    build (rson);
    up (rt);
}

void updata (int rt, int l, int r, int p, int x)  {
    if (l == r) {
        mx[rt] = P (p, x);
        mn[rt] = P (p, -x);
        return;
    }
    down (rt);
    int m = l + r >> 1;
    if (p <= m) updata (lson, p, x);
    else updata (rson, p, x);
    up (rt);
}

void rev (int rt, int l, int r, int tl, int tr) {
    if (tl <= l && r <= tr) {
        swap (mx[rt], mn[rt]);
        lazy[rt] ^= 1;
        return;
    }
    down (rt);
    int m = l + r >> 1;
    if (tl <= m) rev (lson, tl, tr);
    if (m < tr) rev (rson, tl, tr);
    up (rt);
}

P query (int rt, int l, int r, int tl, int tr) {
//    cout << l << ' ' << r << ' ' << tl << ' ' << tr << endl;
    if (tl <= l && r <= tr) {
        return mx[rt];
    }
    down (rt);
    int m = l + r >> 1;
    if (tr <= m) return query (lson, tl, tr);
    else if (m < tl) return query (rson, tl, tr);
    else return add (query (lson, tl, m), query (rson, m + 1, tr));
}

int main () {
//    freopen ("out.txt", "r", stdin);
    int n, q;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        scanf ("%d", &a[i]);
    }
    build (1, 1, n);
    cin >> q;
    int k, l, r, x;
    pii t[30];
    while (q--) {
        scanf ("%d", &k);
        if (k) {
            scanf ("%d%d%d", &l, &r, &x);
            int res = 0, tn = 0;
            for (int i = 1; i <= x; i++) {
//                cout << l << ' ' << r << endl;
                P tmp = query (1, 1, n, l, r);
//                cout << i << endl;
                if (tmp.vm > 0) {
                    res += tmp.vm;
                    t[++tn] = pii (tmp.l, tmp.r);
//                    cout << tmp.l << ' ' << tmp.r << endl;
                    rev (1, 1, n, tmp.l, tmp.r);
                } else break;
            }
            printf ("%d\n", res);
            for (int i = 1; i <= tn; i++) rev (1, 1, n, t[i].xx, t[i].yy);
        } else {
            scanf ("%d%d", &l, &x);
            updata (1, 1, n, l, x);
        }
    }
}
	   				 	 			 		 			 		 	 		 	