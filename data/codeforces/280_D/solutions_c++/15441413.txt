#include <map>
#include <set>
#include <list>
#include <ctime>
#include <cmath>
#include <queue>
#include <stack>
#include <bitset>
#include <vector>
#include <cstdio>
#include <string>
#include <cstring>
#include <sstream>
#include <iomanip>
#include <cstdlib>
#include <iostream>
#include <algorithm>
using namespace std;
struct node {
	struct node1 {int l,r,s;} a[2];
	struct node2 {int s,n;} l[2],r[2];
	int s,t;
}f[400005],u[30];
int i,j,k,n,m,x,y,z,w,d[100005],v;
inline bool comp (int a,int b) {return w?a>b:a<b;}
inline void update (node &x,node y,node z) {
	x.s=y.s+z.s;
	int i;
	for (i=0;i<=1;i++) {
		w=i;
		x.l[i]=y.l[i];x.r[i]=z.r[i];
		if (comp(y.s+z.l[i].s,x.l[i].s)) x.l[i].s=y.s+z.l[i].s,x.l[i].n=z.l[i].n;
		if (comp(z.s+y.r[i].s,x.r[i].s)) x.r[i].s=z.s+y.r[i].s,x.r[i].n=y.r[i].n;
		if (comp(y.a[i].s,z.a[i].s)) x.a[i]=y.a[i]; else x.a[i]=z.a[i];
		if (comp(y.r[i].s+z.l[i].s,x.a[i].s)) x.a[i].s=y.r[i].s+z.l[i].s,
		x.a[i].l=y.r[i].n,x.a[i].r=z.l[i].n;
	}
}
inline void cover (node &x) {
	x.s*=-1,x.t^=1;
	swap(x.a[0],x.a[1]),swap(x.l[0],x.l[1]),swap(x.r[0],x.r[1]);
	int i;
	for (i=0;i<=1;i++) x.a[i].s*=-1,x.l[i].s*=-1,x.r[i].s*=-1;
}
inline void build (int q) {
	if (f[q].t) cover(f[q*2]),cover(f[q*2+1]);
	f[q].t=0;
}
inline void solve (node &x,int y,int z) {
	int i;
	x.s=y;
	for (i=0;i<=1;i++) {
		x.a[i].s=x.l[i].s=x.r[i].s=y;
		x.a[i].l=x.a[i].r=x.l[i].n=x.r[i].n=z;
	}
}
void add (int q,int x,int y) {
	int mid=(x+y)/2;
	if (x==y) {solve(f[q],d[x],x);return;}
	add(q*2,x,mid);add(q*2+1,mid+1,y);
	update(f[q],f[q*2],f[q*2+1]);
}
void work (int q,int x,int y,int k,int t) {
	int mid=(x+y)/2;
	if (x==y) {solve(f[q],t,x);return;}
	build(q);
	if (k<=mid) work(q*2,x,mid,k,t);else work(q*2+1,mid+1,y,k,t);
	update(f[q],f[q*2],f[q*2+1]);
}
void work (int q,int x,int y,int l,int r,int t) {
	int mid=(x+y)/2;
	if (l<=x && y<=r) {
		if (t>0) {
			if (u[t].s==1<<28) u[t]=f[q];
			else u[0]=u[t],update(u[t],u[0],f[q]);
		}
		else cover(f[q]);
		return;
	}
	build(q);
	if (l<=mid) work(q*2,x,mid,l,r,t);
	if (r>mid) work(q*2+1,mid+1,y,l,r,t);
	update(f[q],f[q*2],f[q*2+1]);
}
inline void read (int &x) {
	char p=getchar();int f=1;
	for (;p<'0' || p>'9';p=getchar()) if (p=='-') f=-1;
	for (x=0;p>='0' && p<='9';x=x*10+p-48,p=getchar());x*=f;
}
int main ( ) {
	read(n);
	for (i=1;i<=n;i++) read(d[i]);
	add(1,1,n);
	read(m);
	for (i=1;i<=m;i++) {
		read(k),read(x),read(y);
		if (k) {
			read(z);v=0;
			for (j=1;j<=z;j++) {
				u[j].s=1<<28;
				work(1,1,n,x,y,j);work(1,1,n,u[j].a[1].l,u[j].a[1].r,0);
				if (u[j].a[1].s>0) v+=u[j].a[1].s; else break;
			}
			for (j=min(j,z);j;j--) work(1,1,n,u[j].a[1].l,u[j].a[1].r,0);
			printf("%d\n",v);
		}
		else work(1,1,n,x,y);
	}
}
/*
Sample test(s)

input

9
9 -8 9 -1 -1 -1 9 -8 9
3
1 1 9 1
1 1 9 2
1 4 6 3

output

17
25
0

input

15
-4 8 -3 -10 10 4 -7 -7 0 -6 3 8 -10 7 2
15
1 3 9 2
1 6 12 1
0 6 5
0 10 -7
1 4 9 1
1 7 9 1
0 10 -3
1 4 10 2
1 3 13 2
1 4 11 2
0 15 -9
0 13 -9
0 11 -10
1 5 14 2
1 6 12 1

output

14
11
15
0
15
26
18
23
8
*/
