#include<bits/stdc++.h>
using namespace std;
const int maxn=100005,inf=0x3f3f3f3f;
int n,q,a[maxn];
void init(){
	scanf("%d",&n);
	for (int i=1;i<=n;++i) scanf("%d",&a[i]);
	scanf("%d",&q);
}
struct segment{
	static const int maxnode=200005;
	struct data{
		int l,r,v;
		inline void init(int x,int _v){l=r=x,v=_v;}
		inline bool operator >(const data &b)const{return v>b.v;}
		inline bool operator <(const data &b)const{return v<b.v;}
		inline data operator +(const data &b){return (data){l,b.r,v+b.v};}
	};
	struct node{
		node *c[2];bool rev;
		data sum,fmn,fmx,mn[2],mx[2];
		void init(int x,int v){
			sum.init(x,v),fmn.init(x,v),fmx.init(x,v);
			for (int k=0;k<2;++k) mn[k].init(x,v),mx[k].init(x,v);
		}
		//280d
		void update(node l,node r){
			sum=l.sum+r.sum;
			fmx=max(l.mx[1]+r.mx[0],max(l.fmx,r.fmx));
			fmn=min(l.mn[1]+r.mn[0],min(l.fmn,r.fmn));
			mx[0]=max(l.mx[0],l.sum+r.mx[0]);
			mx[1]=max(r.mx[1],l.mx[1]+r.sum);
			mn[0]=min(l.mn[0],l.sum+r.mn[0]);
			mn[1]=min(r.mn[1],l.mn[1]+r.sum);
		}
		void add_rev(){
			rev^=1,sum.v*=-1;
			swap(fmn,fmx),fmn.v*=-1,fmx.v*=-1;
			for (int k=0;k<2;++k)
				swap(mn[k],mx[k]),mn[k].v*=-1,mx[k].v*=-1;
		}
		void clear(){
			if (!rev) return;rev=0;
			c[0]->add_rev(),c[1]->add_rev();
		}
	}*root,*null,t[maxnode];
	int tot;
	node *newnode(){node *x=t+(++tot);x->c[0]=x->c[1]=null;return x;}
	void build(){tot=0,null=t,null->c[0]=null->c[1]=null,build(root,1,n);}
	void build(node *&p,int l,int r){
		p=newnode();int mid=(l+r)>>1;
		if (l==r){p->init(l,a[l]);return;}
		build(p->c[0],l,mid),build(p->c[1],mid+1,r);
		p->update(*p->c[0],*p->c[1]);
	}
	void modify(int x,int v){modify(root,1,n,x,v);}
	void modify(node *p,int l,int r,int x,int v){
		if (l==r){p->init(x,v);return;}
		int mid=(l+r)>>1;p->clear();
		if (x<=mid) modify(p->c[0],l,mid,x,v);
		else modify(p->c[1],mid+1,r,x,v);
		p->update(*p->c[0],*p->c[1]);
	}
	void reverse(int l,int r){reverse(root,1,n,l,r);}
	void reverse(node *p,int l,int r,int a,int b){
		if (l==a&&r==b){p->add_rev();return;}
		int mid=(l+r)>>1;p->clear();
		if (b<=mid) reverse(p->c[0],l,mid,a,b);
		else if (a>=mid+1) reverse(p->c[1],mid+1,r,a,b);
		else reverse(p->c[0],l,mid,a,mid),reverse(p->c[1],mid+1,r,mid+1,b);
		p->update(*p->c[0],*p->c[1]);
	}
	node query(int l,int r){return query(root,1,n,l,r);}
	node query(node *p,int l,int r,int a,int b){
		if (l==a&&r==b) return *p;
		int mid=(l+r)>>1;p->clear();
		if (b<=mid) return query(p->c[0],l,mid,a,b);
		else if (a>=mid+1) return query(p->c[1],mid+1,r,a,b);
		else{
			node res;
			res.update(query(p->c[0],l,mid,a,mid),query(p->c[1],mid+1,r,mid+1,b));
			return res;
		}
	}
}seg;
int query(int l,int r,int k){
	if (!k) return 0;
	segment::node res=seg.query(l,r);
	if (res.fmx.v<=0) return 0;
	seg.reverse(res.fmx.l,res.fmx.r);
	int t=res.fmx.v+query(l,r,k-1);
	seg.reverse(res.fmx.l,res.fmx.r);
	return t;
}
void work(){
	seg.build();
	for (int t,l,r,k,x,v,i=1;i<=q;++i){
		scanf("%d",&t);
		if (t) scanf("%d%d%d",&l,&r,&k),printf("%d\n",query(l,r,k));
		else scanf("%d%d",&x,&v),seg.modify(x,v);
	}
}
int main(){
	init();
	work();
	fclose(stdin);
	fclose(stdout);
	return 0;
}