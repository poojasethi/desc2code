#include <cstdio>
using namespace std;
const int N=100004,M=400004;
//1: max  0: min
struct rec {int l,r,v,lx,lv,rx,rv,sum;} s[2][M];
int n,m,a[N],pl[24],pr[24];
int qx,qv,ql,qr,sum[M];
bool rev[M];
bool chk(int x,int y,int b) {if (b) return (x>y); else return (x<y);}
void setv(int o,int x,int v)
{
	rev[o]=false; sum[o]=s[0][o].sum=s[1][o].sum=v;
	int k=(v<=0);
	s[k][o].l=s[k][o].r=s[k][o].v=s[k][o].lx=s[k][o].lv=s[k][o].rx=s[k][o].rv=0;
	k=1-k;
	s[k][o].l=s[k][o].r=s[k][o].lx=s[k][o].rx=x;
	s[k][o].v=s[k][o].lv=s[k][o].rv=v;
}
void reverse(int o)
{
	rev[o]=1-rev[o]; sum[o]=-sum[o];
	s[0][o].sum=s[1][o].sum=sum[o];
	for (int i=0;i<2;i++) s[i][o].v=-s[i][o].v,s[i][o].lv=-s[i][o].lv,s[i][o].rv=-s[i][o].rv;
	rec tmp=s[0][o]; s[0][o]=s[1][o]; s[1][o]=tmp;
}
void maintain(int o,int l,int r)
{
	sum[o]=sum[o*2]+sum[o*2+1];
	s[0][o].sum=s[1][o].sum=sum[o];
	int m=(l+r)/2;
	for (int i=0;i<2;i++)
	{
		rec &L=s[i][o*2],&R=s[i][o*2+1],&ret=s[i][o];
		ret.lx=L.lx; ret.lv=L.lv;
		int tv=L.sum,tx=m;
		if (R.lv!=0) tv+=R.lv,tx=R.lx;
		if (chk(tv,ret.lv,i)) ret.lv=tv,ret.lx=tx;
		ret.rx=R.rx; ret.rv=R.rv;
		tv=R.sum; tx=m+1;
		if (L.rv!=0) tv+=L.rv,tx=L.rx;
		if (chk(tv,ret.rv,i)) ret.rv=tv,ret.rx=tx;
		if (chk(R.v,L.v,i)) ret.l=R.l,ret.r=R.r,ret.v=R.v;
		else ret.l=L.l,ret.r=L.r,ret.v=L.v;
		int tl=0,tr=0; tv=0;
		if ((L.rv!=0)&&(R.lv!=0)) tl=L.rx,tr=R.lx,tv=L.rv+R.lv;
		else if (L.rv!=0) tl=L.rx,tr=m,tv=L.rv;
		else if (R.lv!=0) tl=m+1,tr=R.lx,tv=R.lv;
		if (chk(tv,ret.v,i)) ret.v=tv,ret.l=tl,ret.r=tr;
	}
}
void build(int o,int l,int r)
{
	if (l==r)
	{
		setv(o,l,a[l]);
		return;
	}
	int m=(l+r)/2;
	build(o*2,l,m); build(o*2+1,m+1,r);
	maintain(o,l,r);
}
void down(int o)
{
	if (!rev[o]) return;
	reverse(o*2); reverse(o*2+1);
	rev[o]=false;
}
void Reverse(int o,int l,int r)
{
	if ((ql<=l)&&(r<=qr)) {reverse(o); return;}
	int m=(l+r)/2; down(o);
	if (ql<=m) Reverse(o*2,l,m);
	if (m<qr) Reverse(o*2+1,m+1,r);
	maintain(o,l,r);
}
void update(int o,int l,int r)
{
	if (l==r) {setv(o,l,qv); return;}
	int m=(l+r)/2; down(o);
	if (qx<=m) update(o*2,l,m); else update(o*2+1,m+1,r);
	maintain(o,l,r);
}
rec query(int o,int l,int r)
{
	if ((ql<=l)&&(r<=qr)) return s[1][o];
	int m=(l+r)/2; down(o);
	if ((ql<=m)&&(qr>m))
	{
		rec L=query(o*2,l,m),R=query(o*2+1,m+1,r),ret;
		ret.lx=L.lx; ret.lv=L.lv;
		int tv=L.sum,tx=m;
		if (R.lv>0) tv+=R.lv,tx=R.lx;
		if (tv>ret.lv) ret.lv=tv,ret.lx=tx;
		ret.rx=R.rx; ret.rv=R.rv;
		tv=R.sum; tx=m+1;
		if (L.rv>0) tv+=L.rv,tx=L.rx;
		if (tv>ret.rv) ret.rv=tv,ret.rx=tx;
		if (R.v>L.v) ret.l=R.l,ret.r=R.r,ret.v=R.v;
		else ret.l=L.l,ret.r=L.r,ret.v=L.v;
		int tl=0,tr=0; tv=0;
		if ((L.rv>0)&&(R.lv>0)) tl=L.rx,tr=R.lx,tv=L.rv+R.lv;
		else if (L.rv>0) tl=L.rx,tr=m,tv=L.rv;
		else if (R.lv>0) tl=m+1,tr=R.lx,tv=R.lv;
		if (tv>ret.v) ret.v=tv,ret.l=tl,ret.r=tr;
		return ret;
	}
	if (ql<=m) return query(o*2,l,m);
	return query(o*2+1,m+1,r);
}
int main()
{
	int i,j; scanf("%d%",&n);
	for (i=1;i<=n;i++) scanf("%d",&a[i]);
	scanf("%d",&m);
	build(1,1,n);
	for (i=1;i<=m;i++)
	{
		int op,x,y,k; scanf("%d%d%d",&op,&x,&y);
		if (op)
		{
			scanf("%d",&k);
			int ans=0;
			for (j=1;j<=k;j++)
			{
				ql=x; qr=y;
				rec ret=query(1,1,n);
				if (ret.v<=0) break;
				ans+=ret.v;
				pl[j]=ret.l; pr[j]=ret.r;
				ql=ret.l; qr=ret.r;
				Reverse(1,1,n);
			}
			printf("%d\n",ans);
			for (k=1;k<j;k++) ql=pl[k],qr=pr[k],Reverse(1,1,n);
		}
		else qx=x,qv=y,update(1,1,n);
	}
	return 0;
}