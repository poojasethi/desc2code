#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<iostream>
using namespace std;
#define N 200005
int n,m,l[21],r[21],a[N];
struct node{
	node*c[2];
	bool rev;
	int sum,ls1,rs1,mv1,l1,r1,l2,r2,ls2,rs2,mv2,s1,s2,t1,t2;
	void setvalue(int x){
		sum=ls1=rs1=mv1=mv2=ls2=rs2=x;
	}void reverse(){
		rev^=1;
		sum*=-1;
		swap(ls1,ls2);swap(rs1,rs2);swap(mv1,mv2);swap(l1,l2);swap(r1,r2);swap(s1,s2);swap(t1,t2);
		ls1*=-1;rs1*=-1;ls2*=-1;rs2*=-1;mv1*=-1,mv2*=-1;
	}void maintain(){
		if(c[0]){
			sum=c[0]->sum+c[1]->sum;
			if(c[0]->ls1>c[0]->sum+c[1]->ls1){
				s1=c[0]->s1;
				ls1=c[0]->ls1;
			}else{
				s1=c[1]->s1;
				ls1=c[0]->sum+c[1]->ls1;
			}
			if(c[1]->rs1>c[1]->sum+c[0]->rs1){
				t1=c[1]->t1;
				rs1=c[1]->rs1;
			}else{
				t1=c[0]->t1;
				rs1=c[1]->sum+c[0]->rs1;
			}
			mv1=c[0]->mv1;l1=c[0]->l1;r1=c[0]->r1;
			if(c[1]->mv1>mv1){
				mv1=c[1]->mv1;l1=c[1]->l1;r1=c[1]->r1;
			}
			if(c[0]->rs1+c[1]->ls1>mv1){
				mv1=c[0]->rs1+c[1]->ls1;l1=c[0]->t1;r1=c[1]->s1;
			}
			if(c[0]->ls2<c[0]->sum+c[1]->ls2){
				s2=c[0]->s2;
				ls2=c[0]->ls2;
			}else{
				s2=c[1]->s2;
				ls2=c[0]->sum+c[1]->ls2;
			}
			if(c[1]->rs2<c[1]->sum+c[0]->rs2){
				t2=c[1]->t2;
				rs2=c[1]->rs2;
			}else{
				t2=c[0]->t2;
				rs2=c[1]->sum+c[0]->rs2;
			}
			mv2=c[0]->mv2;l2=c[0]->l2;r2=c[0]->r2;
			if(c[1]->mv2<mv2){
				mv2=c[1]->mv2;l2=c[1]->l2;r2=c[1]->r2;
			}
			if(c[0]->rs2+c[1]->ls2<mv2){
				mv2=c[0]->rs2+c[1]->ls2;l2=c[0]->t2;r2=c[1]->s2;
			}
		}
	}void push(){
		if(c[0]&&rev){
			c[0]->reverse();
			c[1]->reverse();
			rev=0;
		}
	}
}pool[N],*stp=pool,*root;
#define mid ((l+r)>>1)
node*build(int l,int r){
	node*o=stp++;
	if(l==r)o->setvalue(a[l]),o->l1=o->l2=o->r1=o->r2=o->s1=o->s2=o->t1=o->t2=l;
	else{
		o->c[0]=build(l,mid);
		o->c[1]=build(mid+1,r);
		o->maintain();
	}return o;
}
int ql,qr,qv;
void change(node*o,int l,int r){
	o->push();
	if(l==r)o->setvalue(qv);
	else{
		if(ql<=mid)change(o->c[0],l,mid);
		else change(o->c[1],mid+1,r);
		o->maintain();
	}
}void modify(node*o,int l,int r){
	o->push();
	if(l>=ql&&r<=qr)o->reverse();
	else{
		if(ql<=mid)modify(o->c[0],l,mid);
		if(qr>mid)modify(o->c[1],mid+1,r);
		o->maintain();
	}
}node query(node*o,int l,int r){
	o->push();
	if(l>=ql&&r<=qr)return *o;
	else{
		node tmp,x,y;
		if(ql<=mid){
			x=query(o->c[0],l,mid);
			if(qr>mid){
				y=query(o->c[1],mid+1,r);
				tmp.c[0]=&x;tmp.c[1]=&y;
				tmp.maintain();
				return tmp;
			}else return x;
		}else return query(o->c[1],mid+1,r);
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	root=build(1,n);
	scanf("%d",&m);
	while(m--){
		int k,ans=0,typ;
		scanf("%d",&typ);
		if(typ==1){
			scanf("%d%d%d",&ql,&qr,&k);
			l[0]=ql;r[0]=qr;
			for(int cnt=1;cnt<=k;cnt++){
				node tmp=query(root,1,n);
				if(tmp.mv1<=0){k=cnt-1;break;}
				ans+=tmp.mv1;
				ql=tmp.l1,qr=tmp.r1;
				l[cnt]=ql,r[cnt]=qr;
				modify(root,1,n);
				ql=l[0];qr=r[0];
			}
			printf("%d\n",ans);
			for(int cnt=1;cnt<=k;cnt++)
				ql=l[cnt],qr=r[cnt],modify(root,1,n);
		}else{
			scanf("%d%d",&ql,&qv);qr=ql;
			change(root,1,n);
		}
	}
}
