#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
#include<set>
#include<queue>
#include<vector>
#include<algorithm>
#include<cstdlib>
#include<map>

using namespace std;

const int maxn = 4100;

struct T{
	int x,y,w,mk;
	friend bool operator <(const T &a,const T &b){
		return a.y-a.x<b.y-b.x;
	}
}Cir[maxn],C1[maxn];

static int N,srt[maxn],ls,opt[maxn],lc;
static int F[maxn][maxn],L[maxn],come[maxn];
int main(){
	//freopen("39C.in","r",stdin);
	//freopen("39C.out","w",stdout);
	scanf("%d",&N);
	for (int i=1;i<=N;i++){
		int x,y;scanf("%d%d",&x,&y);
		Cir[i].x=x-y;Cir[i].y=x+y;
		srt[2*i-1]=x-y;srt[i*2]=x+y;
		Cir[i].mk=i;
	}
	sort(srt+1,srt+2*N+1);
	ls=unique(srt+1,srt+2*N+1)-srt;
	for (int i=1;i<=N;i++){
		Cir[i].x=lower_bound(srt+1,srt+ls,Cir[i].x)-srt;
		Cir[i].y=lower_bound(srt+1,srt+ls,Cir[i].y)-srt;
	}
	sort(Cir+1,Cir+N+1);lc=0;N++;Cir[N].x=1;Cir[N].y=ls;Cir[N].mk=N;
	for (int i=1;i<=N;i++){
		memset(opt,0,sizeof(opt));memset(come,0,sizeof(come));
		int best=0;
		for (int j=1;j<=lc;j++)
		if (C1[j].x>=Cir[i].x){
			for (int k=C1[j-1].x+1;k<=C1[j].x;k++)
			if (opt[k]<opt[k-1]){
				opt[k]=opt[k-1];
				come[k]=come[k-1];
			}
			if (opt[C1[j].y]<opt[C1[j].x]+C1[j].w){
				opt[C1[j].y]=opt[C1[j].x]+C1[j].w;
				come[C1[j].y]=j;
			}
		}
		int cm=0;
		for (int j=Cir[i].x;j<=Cir[i].y;j++)
		if (best<opt[j]){
			best=opt[j];
			cm=come[j];
		}
		best++;
		while (cm){
			for (int j=1;j<=L[C1[cm].mk];j++)
			F[Cir[i].mk][++L[Cir[i].mk]]=F[C1[cm].mk][j];
			cm=come[C1[cm].x];
		}
		F[Cir[i].mk][++L[Cir[i].mk]]=Cir[i].mk;
		C1[++lc]=Cir[i];C1[lc].w=best;
		for (int j=lc;j>1;j--)
		if (C1[j].x<C1[j-1].x) swap(C1[j],C1[j-1]);else break;
	}
	printf("%d\n",L[N]-1);
	sort(F[N]+1,F[N]+L[N]);L[N]--;
	for (int i=1;i<L[N];i++)
		printf("%d ",F[N][i]);
	printf("%d\n",F[N][L[N]]);
	return 0;
}

