#include <map>
#include <set>
#include <list>
#include <cmath>
#include <queue>
#include <stack>
#include <bitset>
#include <vector>
#include <cstdio>
#include <string>
#include <sstream>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
struct Tnode{
	int L,R,ID;
}P[2005],Q[2005];
int N,M,F[2005],G[2005],Pre[2005];
vector<int> Ans[2005];

inline bool comp(const Tnode &A,const Tnode &B)
{	return A.R!=B.R?A.R<B.R:A.L>B.L;	}

inline void Calc(int k)
{
	M=0;
	for (int i=0;i<=N;i++)
	if (i!=k && P[k].L<=P[i].L && P[i].R<=P[k].R)
		Q[++M]=P[i];
	int Best=0;
	for (int i=1;i<=M;i++) {
		F[i]=Pre[i]=0;
		for (int j=1;j<i;j++)
		if (Q[j].R<=Q[i].L && F[j]>F[i])
			F[i]=F[j],Pre[i]=j;
		F[i]+=G[Q[i].ID];
		if (F[i]>F[Best]) Best=i;
	}
	for (;Best;Best=Pre[Best]) {
		int j=Q[Best].ID;
		for (int i=0;i<Ans[j].size();i++)
			Ans[P[k].ID].push_back(Ans[j][i]);
	}
	if (P[k].ID) Ans[P[k].ID].push_back(P[k].ID);
	G[P[k].ID]=Ans[P[k].ID].size();
}

int main()
{
	scanf("%d",&N);
	for (int i=1,c,r;i<=N;i++) {
		scanf("%d%d",&c,&r);
		P[i].L=c-r;
		P[i].R=c+r;
		P[i].ID=i;
	}
	P[0].L=-2000000000;
	P[0].R=2000000000;
	sort(P,P+N+1,comp);
	for (int i=0;i<=N;i++)
		Calc(i);
	printf("%d\n",Ans[0].size());
	for (int i=0;i<Ans[0].size()-1;i++)
		printf("%d ",Ans[0][i]);
	printf("%d\n",Ans[0][Ans[0].size()-1]);
	return 0;
}
