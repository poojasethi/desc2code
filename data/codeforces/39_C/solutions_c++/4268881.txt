#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int t=2002;
typedef int pr [t<<1][t<<1];
pr res,lst;
struct cir{
    int x,y,num;
    bool operator <(const cir&a) const{
        return y<a.y || y==a.y && x>a.x;//end pt greedy
    }
    cir(){x=y=0;}
    cir(int a,int b){x=a,y=b;}
} c[t];
int p[t<<1];
bool pd=false;
int n;
bool cmax(int &a,int b){
    return b>a?a=b,1:0;
}
void getans(int l,int r){
//  printf("l:%d r:%d\n",l,r);//special cas [l][l+1] ,,cut at [l][l] and [l][l+1]
    if (res[l][r]==res[l][lst[l][r]]+res[lst[l][r]][r]+1 || res[l][r] && r-l==1){//a position in middle
//      printf("l:%d r:%d\n",l,r);
        printf(pd?" %d":"%d",lower_bound(c,c+n,cir(p[l],p[r]))->num+1);
        pd=true;
    }
    if (r-l!=1){
        getans(l,lst[l][r]);
        getans(lst[l][r],r);
    }
}
int main(){
    int i,a,b,j,cnt;
    scanf("%d",&n);
    for (i=cnt=0;i<n;i++){
        scanf("%d%d",&a,&b);
        p[cnt++]=c[i].x=a-b;//range ,,find longest sequence that don't intersect
        p[cnt++]=c[i].y=a+b;
        c[i].num=i;//discretization
    }
    sort(c,c+n);
    sort(p,p+cnt);
    cnt=unique(p,p+cnt)-p;//0- cnt-1
    memset(res,0,sizeof res);
    for (i=a=0;i<cnt;i++){
        for (j=0;j<i;j++) lst[j][i]=i-1,res[j][i]=res[j][i-1];//not use this ,,last recordpath
        for (;a<n && c[a].y==p[i];a++){//同結束的相同結果一起處理
            res[b=lower_bound(p,p+cnt,c[a].x)-p][i]++;//tangent ,, no
            for (j=b-1;j>=0;j--)
                if (cmax(res[j][i],res[j][b]+res[b][i])) lst[j][i]=b;//j 和i 的中間接在b
        }
    }
    printf("%d\n",res[0][cnt-1]);
    getans(0,cnt-1);
    puts("");
    return 0;
}
