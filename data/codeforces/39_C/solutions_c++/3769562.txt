#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;

const int maxn = 4005;

struct term {
	int pos, ord;

	term(int _pos, int _ord) : pos(_pos), ord(_ord) {}
};

bool operator < (const term& a, const term& b) {
	return a.pos < b.pos;
}

vector<int> pool;
int n, m;
int f[maxn][maxn], rec[maxn][maxn];
int r[maxn], c[maxn];
vector<term> g[maxn];
vector<int> ans;

void get_path(int a, int b) {
	if (a >= b) return ;

	for (int i = 0; i < g[a].size(); ++i) if (g[a][i].pos == b) ans.push_back(g[a][i].ord);

	if (rec[a][b] == 0 || rec[a][b] == b) return ;
	get_path(a, rec[a][b]); get_path(rec[a][b], b);
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) {
		scanf("%d%d", &r[i], &c[i]);
		pool.push_back(r[i] - c[i]);
		pool.push_back(r[i] + c[i]);
	}
	sort(pool.begin(), pool.end());
	pool.erase(unique(pool.begin(), pool.end()), pool.end());
	//for (int i = 0; i < pool.size(); ++i) printf("%d ", pool[i]); puts("");
	for (int i = 1; i <= n; ++i)
		g[lower_bound(pool.begin(), pool.end(), r[i] - c[i]) - pool.begin()].push_back(
		term(lower_bound(pool.begin(), pool.end(), r[i] + c[i]) - pool.begin(), i));

	m = pool.size();
	for (int i = 0; i < m; ++i) sort(g[i].begin(), g[i].end());
	for (int k = 0; k < m; ++k)
		for (int i = 0; i < m - k; ++i) {
			int cnt = 0, now = f[i + 1][i + k]; rec[i][i + k] = i + 1;
			for (int a = 0; a < g[i].size(); ++a) {
				if (g[i][a].pos > i + k) break;
				if (g[i][a].pos == i + k) cnt++;
				int tmp = f[i][g[i][a].pos] + f[g[i][a].pos][i + k];
				if (now < tmp) {
					now = tmp; rec[i][i + k] = g[i][a].pos;
				}
			}
			f[i][i + k] = now + cnt;
		}

	get_path(0, m - 1);

	printf("%d\n", ans.size()); sort(ans.begin(), ans.end());
	for (int i = 0; i < ans.size(); ++i) printf("%d%c", ans[i], i == ans.size() - 1 ? '\n' : ' ');

	return 0;
}
