using namespace std;
struct D{
    int l,r,i;
    
};
D d[10000];
#include<stdio.h>
#include<iostream>
#include<string.h>
#include<stdlib.h>
#include<algorithm>
#include<vector>
#define N 4020
using namespace std;
int n,x[N],y[N],a[N],g[N][N],f[N][N],s[N][N],t,p[2*N],w[N][N];

int Q(int x)
{
	return upper_bound(a,a+t,x)-a;
}
int F(int l,int r)
{
	if(~f[l][r])
		return f[l][r];
	if(l>r)
		return f[l][r]=0;
	f[l][r]=F(l+1,r);
	int* ww=w[l];
    int len=ww[0];
    for (int i=1;i<=len;i++)
        if (w[l][i]<r)
            
            if (F(l,ww[i])+F(ww[i],r)>f[l][r])
                f[l][r]=f[l][ww[i]]+f[ww[i]][r],s[l][r]=ww[i];
	return f[l][r]+=!!g[l][r];
}
int P(int l,int r){
    if (l>r)
        return 0;
    if (s[l][r]){
        P(l,s[l][r]);
        P(s[l][r],r);
    }else{
        P(l+1,r);
    }if (g[l][r])
        printf("%d ",g[l][r]);
}
int main(){
    int n;
    scanf("%d",&n);
   
    for (int i=0;i<n;i++){
        int c,r;
        scanf("%d%d",&c,&r);
        d[i].l=c-r;
        d[i].r=c+r;
        p[i*2]=c-r;
        p[i*2+1]=c+r;
    }
    sort(p,p+2*n);
    int t=unique(p,p+2*n)-p;
    for (int i=0;i<n;i++){
        d[i].l=upper_bound(p,p+t,d[i].l)-p-1;
        d[i].r=upper_bound(p,p+t,d[i].r)-p-1;
        w[d[i].l][0]++;
        w[d[i].l][w[d[i].l][0]]=d[i].r;
        g[d[i].l][d[i].r]=i+1;
    }
    memset(f,-1,sizeof(f));
    int ans=F(0,t-1);
    printf("%d\n",ans);
    P(0,t-1);
    return 0;
}