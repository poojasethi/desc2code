#include <cstdio>
#include <algorithm>
#include <vector>
#include <cassert>

using namespace std;

#define SZ(x) (int)(x.size())
const int N = 2000;
typedef pair<int, int> ii;
ii a[N << 1];
int b[N];
int c[N];
int dp[N * 2 + 1][N * 2 + 1];
vector<int> ans;

void path(int i, int j) {
  if (j - i < 2) return;
  if (dp[i][j] == dp[i][j - 1]) {
    path(i, j - 1);
  } else {
    int v = j - 1;
    ans.push_back(a[v].second);
    int u = b[a[v].second] ^ v;
    path(u + 1, v);
    path(i, u);
  }
}

struct cmp {
  bool operator ()(ii u, ii v) {
    if (u.first != v.first) {
      return u.first < v.first;
    }
    int x = (c[u.second] < u.first) ? 1 : -1;
    int y = (c[v.second] < v.first) ? 1 : -1;
    if (x != y) {
      return x > y;
    }
    if (x < 0) {
      return c[u.second] * 2 - u.first > c[v.second] * 2 - v.first;
    }
    return c[u.second] * 2 - u.first > c[v.second] * 2 - v.first;
  }
};

int main() {
  int n;
  scanf("%d", &n);
  for (int i = 0; i < n; ++i) {
    int r;
    scanf("%d%d", c + i, &r);
    a[i] = ii(c[i] - r, i);
    a[i + n] = ii(c[i] + r, i);
  }
  sort(a, a + n * 2, cmp());
  for (int i = 0; i < n * 2; ++i) {
    b[a[i].second] ^= i;
  }
  for (int i = 0; i < n * 2; ++i) dp[i][i] = 0;
  for (int i = 0; i < n * 2 - 1; ++i) dp[i][i + 1] = 0;
  for (int k = 2; k <= n * 2; ++k) {
    for (int i = 0; i + k <= n * 2; ++i) {
      dp[i][i + k] = dp[i][i + k - 1];
      int v = i + k - 1;
      int u = b[a[v].second] ^ v;
      if (c[a[v].second] < a[v].first && u >= i) {
        dp[i][i + k] = max(dp[i][i + k], dp[u + 1][v] + dp[i][u] + 1);
      }
    }
  }
  path(0, n * 2);
  printf("%d\n", SZ(ans));
  for (int i = 0; i < SZ(ans); ++i) {
    printf("%d ", ans[i] + 1);
  }
  puts("");
  return 0;
}
