#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
using namespace std;
typedef vector<int> Vec;
typedef Vec :: iterator vi;

const int N = 2005;
char s[N][N];
int n , tot , order[N] , root;
int Num[N<<1][3] , type[N<<1];
Vec E[N<<1];
bool Q[N<<1] , v[N];

void Init()
{
    scanf("%d",&n);
    fo(i,1,n) scanf("%s",s[i]+1);
}

//Num[x][0]->空 Num[x][1]->满 Num[x][2]->有但不满

void Dfs(int x)
{
    Num[x][0] = Num[x][1] = Num[x][2] = 0;
    if (x <= n)
    {
        if (v[x]) type[x] = 1;else type[x] = 0;
        Num[x][type[x]] ++;
        return;
    }
    
    bool f0 = 0 , f1 = 0;
    for(vi it = E[x].begin(); it != E[x].end(); it ++)
    {
        Dfs(*it);
        if (type[*it]) f1 = 1;
        if (!type[*it] || type[*it]==2) f0 = 1;
        Num[x][type[*it]]++;
    }
    if (f0 && !f1)  type[x] = 0;else
    if (f1 && !f0)  type[x] = 1;else
                    type[x] = 2;
}

bool Get(int x,Vec &Ed)
{
    if (Num[x][2] > 1) return 1;
    if (Q[x])
    {
        vi it = E[x].begin();
        if (Num[x][1] && type[*it] != 1 || !Num[x][1] && Num[x][2] && type[*it] != 2)
            reverse(E[x].begin() , E[x].end());
        it = E[x].begin();
        fo(i,1,Num[x][1])
        {
            if (type[*it] != 1) return 1;
            Ed.push_back(*it);
            it ++;
        }
        
        bool Fir = 1;
        for(; it != E[x].end(); it ++)
        {
            if (Fir && Num[x][2] && type[*it] != 2) return 1;
            if (type[*it] == 2)
            {
                Fir = 0;//
                if (Get(*it , Ed)) return 1;
            } else Ed.push_back(*it);
        }
        return 0;
    }
    else
    {
        if (Num[x][1])
        {
            int t1 = ++tot;
            for(vi it = E[x].begin(); it != E[x].end(); it ++)
                if (type[*it] == 1) E[t1].push_back(*it);
            if (E[t1].size() == 1) t1 = E[t1][0];
            Ed.push_back(t1);
        }
        
        for(vi it = E[x].begin(); it != E[x].end(); it ++)
            if (type[*it] == 2 && Get(*it , Ed)) return 1;
        
        if (Num[x][0])
        {
            int t2 = ++tot;
            for(vi it = E[x].begin(); it != E[x].end(); it++)
                if (!type[*it]) E[t2].push_back(*it);
            if (E[t2].size() == 1) t2 = E[t2][0];
            Ed.push_back(t2);
        }
        return 0;
    }
}

bool Getr(int x,Vec &Ed)
{
    int temp = Ed.size();
    if (Get(x , Ed)) return 1;
    reverse(Ed.begin() + temp , Ed.end());
    return 0;
}

bool Getl(int x,Vec &Ed)
{
    return Get(x , Ed);
}

bool Judge(int x)
{
    if (x <= n) return 0;
    if (Num[x][2] > 2) return 1;
    if (!Num[x][1] && !Num[x][2]) return 0;
    if (Num[x][1] + Num[x][2] == 1)
    {
        for(vi it = E[x].begin(); it != E[x].end(); it++)
        if (type[*it]) return Judge(*it);
    }
    
    Vec temp;
    temp.clear();
    if (Q[x])
    {
        bool Fir = 1 , End = 0;
        for(vi it = E[x].begin(); it != E[x].end(); it++)
        {
            if (type[*it] && End) return 1;
            if (!Fir && !type[*it]) End = 1;
            if (type[*it] == 2)
            {
                if (Fir) 
                    {
                        if (Getr(*it , temp)) return 1;
                    } else 
                        if (Getl(*it , temp)) return 1;
            } else temp.push_back(*it);
            if (type[*it]) Fir = 0;
        }
        E[x] = temp;
        return 0;
    }
    else
    {
        int t1 = ++tot; Q[t1] = 1;
        for(vi it = E[x].begin(); it != E[x].end(); it++)
        if (type[*it] == 2)
        {
            if (Getr(*it , E[t1])) return 1;
            break;
        }
        
        if (Num[x][1])
        {
            int t2 = ++tot;
            for(vi it = E[x].begin(); it != E[x].end(); it++)
            if (type[*it] == 1) E[t2].push_back(*it);
            if (E[t2].size() == 1) t2 = E[t2][0];
            E[t1].push_back(t2);
        }
        
        bool Fir = 1;
        for(vi it = E[x].begin(); it != E[x].end(); it++)
        if (type[*it] == 2)
        {
            if (Fir) Fir = 0;else
            {
                if (Getl(*it , E[t1])) return 1;
                break;
            }
        }
        if (E[t1].size() == 1) t1 = E[t1][0];
        temp.push_back(t1);
        for(vi it = E[x].begin(); it != E[x].end(); it++)
        if (!type[*it]) temp.push_back(*it);
        E[x] = temp;
        return 0;
    }
}

void Get_ans(int x)
{
    if (x <= n)
    {
        order[++tot] = x;
        return;
    }
    for(vi it = E[x].begin(); it != E[x].end(); it ++)
        Get_ans(*it);
}

void Dfs_draw(int x)
{
    printf("\n%d:",x);
    for(vi it = E[x].begin(); it != E[x].end(); it ++) printf("%d ",*it);
    for(vi it = E[x].begin(); it != E[x].end(); it ++) Dfs_draw(*it);
}

void Work()
{
    root = tot = n+1;
    fo(i,1,n) E[root].push_back(i);
    fo(i,1,n)
    {
        fo(j,1,n) v[j] = 0;
        fo(j,1,n) if (s[i][j] == '1') v[j] = 1;
        Dfs(root);
    //  printf("tc:%d\n",i);
    //  printf("type is:");
        //fo(i,1,tot) printf("%d is %d\n",i,type[i]); 
        if (Judge(root))
        {
            puts("NO");
            return;
        }
        
    //  Dfs_draw(root);
    //  printf("\n");
    }
    
    tot = 0;
    Get_ans(root);
    puts("YES");
    fo(i,1,n)
    {
        fo(j,1,n) printf("%c",s[i][order[j]]);
        printf("\n");
    }
    
}

int main()
{
    
    Init();
    Work();
    
    return 0;
}