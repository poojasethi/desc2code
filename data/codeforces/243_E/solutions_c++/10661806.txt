#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#define fo(i, a, b) for (i = a; i <= b; i++)
#define fd(i, a, b) for (i = a; i >= b; i--)
#define memcle(a) memset(a, 0, sizeof(a))
#define rep(i, v) for (it i = v.begin(); i != v.end(); i++)
using namespace std;


typedef vector<int> vec;
typedef vec::iterator it;
const int N = 2100, T = N * N;
int a[N][N], n, get[N], Q[T], type[T], num[T][3], tn, ans[N], root, cur, an;
bool fail;
vec son[T];

void read(int &x)
{
	char c = getchar();
	for (; c != '0' && c != '1'; ) c = getchar();
	x = c - '0';
}

void Init()
{
	int i;
	int j;
	
	scanf("%d", &n);
	fo(i, 1, n)
		fo(j, 1, n) 
			read(a[i][j]);
	
	tn = root = n + 1;
	
	fo(i, 1, n) son[root].push_back(i);
}

void maketype(int x)
{
	memcle(num[x]);
	if (x <= n)
	{
		type[x] = a[cur][x];
		return;
	}
	
	int bz0 = 1;
	int bz1 = 1;
	
	for (it i = son[x].begin(); i != son[x].end(); i++) 
	{
		maketype(*i);
		if (type[*i] != 0) bz0 = 0;
		if (type[*i] != 1) bz1 = 0;
		num[x][type[*i]]++;
	}
	
	if (bz0) type[x] = 0; else 
	if (bz1) type[x] = 1; else 
	type[x] = 2;
}

bool putl(int x, vec &g)
{
	if (num[x][2] > 1) return 1;
	if (Q[x])
	{
		if (num[x][1] && type[son[x][0]] != 1 || !num[x][1] && type[son[x][0]] != 2) 
			reverse(son[x].begin(), son[x].end());
		
		it j = son[x].begin();
		for (int i = 1; i <= num[x][1]; i++, j++) 
		{
			if (type[*j] != 1) return 1;
			g.push_back(*j);
		}
		
		if (num[x][2]) 
		{
			if (type[*j] != 2) return 1;
			if (putl(*j, g)) return 1;
			//g.push_back(*j);
			j++;
		}
		
		for (; j != son[x].end(); j++) g.push_back(*j);
	} else 
	{
		if (num[x][1])
		{
			int t1 = ++tn;
			for (it i = son[x].begin(); i != son[x].end(); i++)
				if (type[*i] == 1) son[t1].push_back(*i);
			if (son[t1].size() == 1) t1 = son[t1][0];
			g.push_back(t1);
		}
		
		for (it i = son[x].begin(); i != son[x].end(); i++)
			if (type[*i] == 2) 
			{
				if (putl(*i, g)) return 1;
				break;
			}
			
		if (num[x][0])
		{
			int t2 = ++tn;
			for (it i = son[x].begin(); i != son[x].end(); i++)
				if (type[*i] == 0) son[t2].push_back(*i);
			if (son[t2].size() == 1) t2 = son[t2][0];
			g.push_back(t2);
		}
	}
	return 0;
}

bool putr(int x, vec &g)
{
	int tmp = g.size();
	if (putl(x, g)) return 1;
	reverse(g.begin() + tmp, g.end());
	return 0;
}

bool range(int x)
{
	if (x <= n || num[x][1] + num[x][2] == 0) return 0; 
	if (num[x][2] > 2) return 1; // 三段不连续是非法的
	if (num[x][2] + num[x][1] == 1) // 只有一个非空儿子直接搞
		for (it i = son[x].begin(); i != son[x].end(); i++)
			if (type[*i]) return range(*i);
	
	vec g;
	if (Q[x]) // Q点
	{
		bool st = 0, en = 0;
		for (it i = son[x].begin(); i != son[x].end(); i++)
		{
			if (en && type[*i]) return 1; // 有多段
			if (st && type[*i] != 1) en = 1;
			if (!st && type[*i] == 2) if (putr(*i, g)) return 1;
			if (st && type[*i] == 2) if (putl(*i, g)) return 1;
			if (type[*i] != 2) g.push_back(*i);
			st |= type[*i];
		}
	} else
	{	
		int t1 = ++tn; Q[tn] = 1;
		for (it i = son[x].begin(); i != son[x].end(); i++)
			if (type[*i] == 2) 
			{
				if (putr(*i, son[t1])) return 1; else break;
			}
		
		if (num[x][1])
		{
			int t2 = ++tn; Q[tn] = 0;
			for(it i = son[x].begin(); i != son[x].end(); i++)
				if (type[*i] == 1) son[t2].push_back(*i);
			if (son[t2].size() == 1) t2 = son[t2][0];
			son[t1].push_back(t2);
		}
		
		bool st = 0;
		for(it i = son[x].begin(); i != son[x].end(); i++)
			if (type[*i] == 2) 
			{
				if (!st) st = 1; else
				if (putl(*i, son[t1])) return 1; else break;
			}
			
		if (son[t1].size() == 1) t1 = son[t1][0];
		g.push_back(t1);
		
		for(it i = son[x].begin(); i != son[x].end(); i++) if (type[*i] == 0) g.push_back(*i);
	}
	
	son[x] = g;
	return 0;
}

void makeorder(int x)
{
	if (x <= n)
	{
		ans[++an] = x;
		return;
	}
	for (it i = son[x].begin(); i != son[x].end(); i++) makeorder(*i);
}

void Work()
{
	for (int i = 1; i <= n; i++)
	{
		cur = i;
		//memcle(num);
		maketype(root);
		if (range(root)) {fail = 1; break;}
	}
	
	if (fail) puts("NO"); else 
	{
		puts("YES");
		makeorder(root);
		for (int i = 1; i <= n; i++)
		{
			for (int j = 1; j <= n; j++)
				printf("%d", a[i][ans[j]]);
			puts("");
		}
	}
}

int main()
{
	
	Init();
	Work();
	
	return 0;
}
