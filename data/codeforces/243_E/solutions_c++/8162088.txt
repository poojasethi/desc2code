/*
	Time : 0658Z 20141009
	Task : Codeforces 243E
	Tags : Data structures
	Stat : Coding
*/
#include <cstdio>
#include <cstring>
#include <iostream>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <utility>
#include <queue>
#include <functional>
#include <map>
#include <set>
#include <cmath>

#define fi first
#define se second
#define fo(i,a,b) for (int i = a; i <= b; i ++)
#define fd(i,a,b) for (int i = a; i >= b; i --)
#define fe(i,x,y) for (int i = x, y = lnk[i]; i; i = nxt[i], y = lnk[i])
#define mkp make_pair
#define pb push_back
#define Fill(x,y) memset(x,y,sizeof(x))
#define Cpy(x,y) memcpy(x,y,sizeof(x))
#define Bit(x,y) ((((x) >> (y)) & 1))
#define mit map<int,SI>::iterator
#define sit SI::iterator
#define SZ(x) ((int) (x).size() - 1)

using namespace std;
 
typedef long long LL;
typedef long double DB;
typedef pair <DB, DB> PD;
typedef pair <LL, LL> PLI;
typedef pair <PD, int> PDI;
typedef pair <int, int> PI;
typedef pair <int, PI> PII;
typedef pair <PI, PI> PIII;
typedef set <PI> SI;
typedef vector <int> VI;
typedef vector <VI> VII;
 
int Read()
{
    char c; while (c = getchar(), (c != '-') && (c < '0' || c > '9'));
    bool neg = (c == '-'); int ret = (neg ? 0 : c - 48);
    while (c = getchar(), c >= '0' && c <= '9') ret = ret * 10 + c - 48;
    return neg ? -ret : ret;
}

const int MAXN = 505;

VI rs, cs;
int N, cnt[MAXN], a[MAXN][MAXN], ans[MAXN], out[MAXN][MAXN];
char s[MAXN];
bool mk[MAXN];

void init()
{
	scanf("%d", &N);
	fo (i, 1, N)
	{
		scanf("%s", s + 1);
		fo (j, 1, N)
		{
			a[i][j] = s[j] - 48;
			cnt[i] += a[i][j];
		}
		cs.pb(i);
		if (cnt[i] && cnt[i] < N) rs.pb(i);
	}
}

bool Split(VII &cb, VII &cr, int K)
{
	int inc = 0;
	VII nb, nr;
	fo (i, 0, SZ(cb))
	{
		VI b[2];
		fo (j, 0, SZ(cb[i])) b[a[K][cb[i][j]]].pb(cb[i][j]);
		int flag = 1, sz = nb.size();
		if (!inc && i < SZ(cb))
		{
			if (b[0].size()) nb.pb(b[0]);
			if (b[1].size()) nb.pb(b[1]), inc = 1;
			flag ^= 1;
		} else
		{
			if (b[1].size())
			{
				if (inc == 2) // more than two
				{
					reverse(cb.begin(), cb.end() - 1);
					reverse(cr.begin(), cr.end() - 1);
					return 0;
				}
				nb.pb(b[1]);
			}
			if (b[0].size()) nb.pb(b[0]), inc = 2;
		}
		nr.resize(nb.size());
		if (b[0].size() && b[1].size()) // mix
		{
			int v = b[0].size() >= b[1].size();
			fo (j, 0, SZ(cr[i]))
			{
				int cc = 0, cd = cr[i][j];
				if (cd != K)
				{
					fo (k, 0, SZ(b[v])) cc += a[cd][b[v][k]];
					if (cc && cc != cnt[cd]) mk[cd] = 1;
					else if (cc == cnt[cd]) nr[sz + (v ^ flag)].pb(cd);
						else nr[sz + (v ^ flag ^ 1)].pb(cd);
				}
			}
		} else if (b[0].size() || b[1].size()) nr[nr.size() - 1] = cr[i];
		
		if (i == SZ(cb) && !b[0].size()) nr.pb(VI()), nb.pb(VI());
	}
	return cb = nb, cr = nr, 1;
}

bool Cut(VII &cb, VII &cr, VI &rs, int d)
{
	int K = rs[d]; swap(rs[d], rs.back()), rs.pop_back();
	
	if (Split(cb, cr, K)) return 1;
	return Split(cb, cr, K);
}

bool Solve(VI &rs, VI &cs, int st)
{
	// eliminate useless rows
	fo (i, 0, SZ(rs))
		if (mk[rs[i]] || cnt[rs[i]] == cs.size())
			swap(rs[i], rs.back()), rs.pop_back();
	if (!rs.size())
	{
		// all set
		fo (i, 0, SZ(cs)) ans[cs[i]] = st + i;
		return 1;
	};
	int most = 0;
	fo (i, 1, SZ(rs))
		if (cnt[rs[i]] > cnt[rs[most]]) most = i;
	VII cb, cr; cr.pb(rs), cb.pb(cs); mk[rs[most]] = 1;
	// cut the row with most ones
	if (!Cut(cb, cr, rs, most)) return 0;
	
	for (; rs.size(); )
	{
		int fin = -1;
		fo (i, 0, SZ(rs))
			if (mk[rs[i]]) { fin = i; break; }
		if (fin < 0) // nothing interferes the dividing to subtasks
		{
			fo (i, 0, SZ(cb))
			{
				if (!Solve(cr[i], cb[i], st)) return 0;
				st += cb[i].size();
			}
			return 1;
		} else
			if (!Cut(cb, cr, rs, fin)) return 0;
	}
	// all current rows cleared, subtasks
	fo (i, 0, SZ(cb))
	{
		if (!Solve(cr[i], cb[i], st)) return 0;
		st += cb[i].size();
	}
	return 1;
}

void work()
{
	if (Solve(rs, cs, 1))
	{
		puts("YES");
		fo (i, 1, N) fo (j, 1, N) out[i][ans[j]] = a[i][j];
		fo (i, 1, N)
		{
			fo (j, 1, N) printf("%d", out[i][j]);
			puts("");
		}
	} else puts("NO");
}

int main()
{
	init();
	work();
	return 0;
}