#include <cstdio>
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <string>
#include <set>
#include <map>
#include <ctime>
#include <cstring>
#include <cassert>
#include <bitset>
#include <sstream>
#include <queue>

using namespace std;

#define forn(i, n) for(int i = 0; i < (int)(n); i++)
#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)
#define pb push_back
#define mp make_pair
#define fs first
#define sc second
#define last(a) int(a.size() - 1)
#define all(a) a.begin(), a.end()
#define seta(a,x) memset (a, x, sizeof (a))
#define I (int)

typedef long long int64;
typedef pair <int, int> pii;
typedef long double ldb;

const long double eps = 1e-9;
const int inf = (1 << 30) - 1;
const int64 inf64 = ((int64)1 << 62) - 1;
const long double pi = 3.1415926535897932384626433832795;

template <class T> T sqr (T x) {return x * x;}
template <class T> T abs (T x) {return x < 0 ? -x : x;}

void no() {
    puts("NO");
    exit(0);
}

double rr = 0;

struct tree {
    vector<int> h, res, us, ord;
    vector<tree*> g;
    tree *lft, *rgt, *p;
    vector<vector<pair<int, tree*> > > e;

    void init() {
        e.resize(g.size());
        us.resize(g.size());
        lft = rgt = 0;
        forn(i, g.size())
            g[i]->init();
    }

    tree () {};

    tree(int n) {
        p = 0;
        forn(i, n) h.pb(i);
        forn(i, n) g.pb(new tree(i, this));
    }

    tree(int n, tree *pr) {
        p = pr;
        h.pb(n);
    }

    tree(const vector<tree*> & e, tree *p) : g(e), p(p) {
        h.clear();
        forn(i, g.size()) {
            g[i]->p = this;
            forn(j, g[i]->h.size())
                h.pb(g[i]->h[j]);
        }
    }

    int getNum(tree *v) {
        forn(i, g.size())
            if (g[i] == v) return i;
        return -1;  
    }

    void paintR(tree *v, tree *pv) {
        while (v != pv) {
            if (v->p->rgt != 0) return;
            v->p->rgt = v;
            v = v->p;
        }
    }

    void paintL(tree *v, tree *pv) {
        while (v != pv) {
            if (v->p->lft != 0) return;
            v->p->lft = v;
            v = v->p;
        }
    }

    void add(tree *pv, tree *pu, tree *v, tree *u) {
        int npv = getNum(pv);
        int npu = getNum(pu);

        e[npv].pb(mp(npu, u));  
        e[npu].pb(mp(npv, v));  
    }

    void dfs(int v, vector<int> &st) {
        st.pb(v);
        us[v] = 1;
        forn(i, e[v].size())
            if (!us[e[v][i].fs])
                dfs(e[v][i].fs, st);
    }

    vector<int> getOrder() {
        vector<int> st, en;
        if (lft != 0) {
            int v = getNum(lft);
            if (!us[v])
                dfs(v, st);
        }
        if (rgt != 0) {
            int v = getNum(rgt);
            if (!us[v])
                dfs(v, en);
        }
        forn(i, g.size()) {
            set<int> qwe;
            forn(j, e[i].size())
                qwe.insert(e[i][j].fs);
            if (!us[i] && qwe.size() == 1) 
                dfs(i, st);
        }
        forn(i, g.size()) {
            if (!us[i]) 
                dfs(i, st);
        }
        ford(i, en.size())
            st.pb(en[i]);
        return st;
    }

    void solve() {
        if (g.size() == 0) {
            res = h;
            return;
        }
        ord = getOrder();
        forn(i, ord.size() - 1) {
            int v = ord[i], u = ord[i+1];
            forn(j, e[v].size())
                if (e[v][j].fs == u) 
                    paintL(e[v][j].sc, this);
            forn(j, e[u].size())
                if (e[u][j].fs == v) 
                    paintR(e[u][j].sc, this);
        }
        forn(i, g.size())
            g[i]->solve();
        forn(i, ord.size())
            forn(j, g[ord[i]]->res.size())
                res.pb(g[ord[i]]->res[j]);
    }
};

typedef tree* ptree;

const int nmax = 600;

int n;
char a[nmax][nmax], b[nmax][nmax];
ptree root;
vector<ptree> tc;

bool update(ptree v, int idx) {
    if (v->g.size() == 0) {
        if (a[idx][v->h[0]] == '1') return 1;
        return 0;
    }
    vector<ptree> ng;
    bool done = 1;
    forn(i, v->g.size()) 
        if (update(v->g[i], idx)) 
            ng.pb(v->g[i]);
        else 
            done = 0;
    if (done) return 1;
    if (ng.size() <= 1) return 0;
    rr -= clock();
    int m = 0, j = 0;
    forn(i, v->g.size()) {
        while (j < ng.size() && v->g[i] == ng[j]) j ++, i ++;
        if (i < v->g.size()) v->g[m++] = v->g[i];
    }
    v->g.resize(m);
    v->g.pb(new tree(ng, v));
    rr += clock();
    return 0;
}

bool check() {
    forn(i, n) {
        int cnt = 0;
        forn(j, n - 1)
            if (b[i][j] == '0' && b[i][j+1] == '1')
                cnt ++;
        if (b[i][0] == '1') cnt ++;
        if (cnt > 1) return 0;
    }
    return 1;
}

ptree process (ptree v, int idx) {
    bool f1, f2;
    f1 = f2 = 1;
    forn(i, v->h.size()) {
        if (a[idx][v->h[i]] == '1') f1 = 0;
        if (a[idx][v->h[i]] == '0') f2 = 0;
    }
    if (f1) return 0;
    if (f2) return v;
    vector<pair<ptree, ptree> > tc;
    forn(i, v->g.size()) {
        ptree buf = process (v->g[i], idx);
        if (buf != 0) {
            tc.pb(mp(buf, v->g[i]));
        }
    }
    if (tc.size() == 1) return tc[0].fs;
    if (tc.size() == 2) {
        v->add(tc[0].sc, tc[1].sc, tc[0].fs, tc[1].fs);
        if (tc[0].fs == tc[0].sc) return tc[0].fs;
        if (tc[1].fs == tc[1].sc) return tc[1].sc;
        return 0;
    }
    if (tc.size() == 3) {
        if (tc[1].fs == tc[1].sc) swap(tc[0], tc[1]);
        if (tc[2].fs == tc[2].sc) swap(tc[0], tc[2]);
        if (tc[0].fs != tc[0].sc) no();
        v->add(tc[0].sc, tc[1].sc, tc[0].fs, tc[1].fs);
        v->add(tc[0].sc, tc[2].sc, tc[0].fs, tc[2].fs);
        return tc[0].fs;
    }
    if (tc.size() >= 4) no();
    return 0;
}

int main ()
{
//  freopen("input.txt", "rt", stdin);
//  freopen("output.txt", "wt", stdout);
    
    scanf("%d\n", &n);
    root = new tree(n);
    forn(i, n) {
        gets(a[i]);
        update(root, i);
    }

    root->init();
    forn(i, n) 
        process(root, i);

    root->solve();
    vector<int> res = root->res;
    forn(i, n)
        forn(j, n)
            b[i][j] = a[i][res[j]];
    if (!check()) no();
    puts("YES");
    forn(i, n) {
        forn(j, n) {    
            printf("%c", b[i][j]);
        }
        puts("");
    }
    return 0;
}
