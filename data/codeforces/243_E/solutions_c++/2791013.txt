#include <stdio.h>
#include <vector>
#include <algorithm>
using namespace std;

#define NUM (1000+100)

int n,cn;
vector<int> eg[NUM];
int list[NUM];
int pi[NUM];
int tr[NUM];
vector<int> RN[NUM];
int parent[NUM];
int u[NUM];

class Node{ public:
    int x,last,size;
    Node *pre,*next,*set,*sl,*sr,*p;
    void remove(){
	pre->next=next;
	next->pre=pre;
    }
    void moveToTail(){
	if(set->p!=this){
	    remove();
	    pre=set->p->pre; next=set->p;
	    pre->next=next->pre=set->p=this;
	}
    }
    Node* split();
};
Node c[NUM*2];
Node* Node::split(){
    if(p->pre==this || p==this){
	p=this;
	return 0;
    }
    c[cn].set=0;
    c[cn].pre=pre; c[cn].next=p;
    c[cn].sl=this; c[cn].sr=sr;
    c[cn].size=0;
    c[cn].last=last;
    c[cn].p=c+cn;
    sr->sl=c+cn;
    sr=c+cn;
    pre->next=c+cn;
    pre=p->pre;
    pre->next=this;
    p->pre=c+cn;
    p=this;
    for( Node *r=c[cn].next; r!=c+cn; r=r->next ){
	r->set=c+cn;
	c[cn].size++;
	size--;
    }
    cn++;
    return sr;
}
void initSet(Node &head){
    for( int i=0; i<n; i++ ){
	c[i].x=i;
	c[i].pre=i?c+i-1:c+n;
	c[i].next=c+i+1;
	c[i].set=c+n;
    }
    c[n].set=0;
    c[n].pre=c+n-1; c[n].next=c;
    c[n].sl=c[n].sr=&head;
    c[n].last=c[n].size=n;
    c[n].p=c+n;
    cn=n+1;
    head.sl=head.sr=c+n;
}
void lexbfs(){
    Node head;
    initSet(head);
    for( int i=0; i<n; i++ ){
	pi[i]=-1;
    }
    for( int i=n-1; i>=0; i-- ){
	Node *p=head.sl->pre;
	p->remove();
	if(p->set->pre==p->set){
	    p->set->sl->sr=p->set->sr;
	    p->set->sr->sl=p->set->sl;
	}
	int x=list[i]=p->x;
	pi[x]=i;
	for( int j=0; j<eg[x].size(); j++ ){
	    int y=eg[x][j];
	    if(pi[y]==-1) c[y].moveToTail();
	}
	for( int j=0; j<eg[x].size(); j++ ){
	    int y=eg[x][j];
	    if(pi[y]==-1) c[y].set->split();
	}
    }
}

bool cmpRN(int a,int b){
    return pi[a]>pi[b];
}

int isChordal(){ //RN(x)\parent(x) in RN(parent(x))
    for( int i=0; i<n; i++ ){
	RN[i].clear();
	u[i]=-1;
    }
    for( int i=0; i<n; i++ ){
	parent[i]=-1; 
	for( int j=0; j<eg[i].size(); j++ ){
	    int y=eg[i][j];
	    if(pi[y]>pi[i]){
		RN[y].push_back(i);
		if(parent[i]==-1 || pi[y]<pi[parent[i]]){
		    parent[i]=y;
		}
	    }
	}
    }
    for( int i=0; i<n; i++ ){
	sort(RN[i].begin(),RN[i].end(),cmpRN);
	for( int j=0; j<RN[i].size(); j++ ){
	    if(i!=parent[RN[i][j]] && u[parent[RN[i][j]]]!=i) return 0;
	    u[RN[i][j]]=i;
	}
    }
    return 1;
}

void transitive(){
    Node head;
    initSet(head);
    Node *p;
    while(1){
	Node *mp;
	int maxs=0;
	p=head.sl;
	while(p!=&head){
	    if(p->size>maxs){
		maxs=p->size;
		mp=p;
	    }
	    p=p->sl;
	}
	if(maxs==1) break;
	p=head.sl;
	while(p!=&head){
	    if(p->size*2<=p->last) break;
	    p=p->sl;
	}
	if(p!=&head){
	    for( Node *q=p->next; q!=p; q=q->next ){
		int x=q->x;
		for( int i=0; i<eg[x].size(); i++ ){
		    int y=eg[x][i];
		    if(c[y].set!=p) c[y].moveToTail();
		}
		for( Node *t=p->sl; t!=&head; t=t->sl ){
		    t->split();
		}
		for( Node *t=p->sr; t!=&head; t=t->sr ){
		    Node *r=t->split();
		    if(r){
			r->sl=t->sl; t->sr=r->sr;
			r->sr=t; t->sl=r;
			r->sl->sr=r; t->sr->sl=t;
		    }
		}
	    }
	    p->last=p->size;
	}else{
	    p=mp->next;
	    for( Node *q=mp->next->next; q!=mp; q=q->next ){
		if(pi[q->x]<pi[p->x]){
		    p=q;
		}
	    }
	    p->moveToTail();
	    mp->split()->last=1000000;
	}
    }
    p=head.sl;
    for( int i=n-1; i>=0; i--,p=p->sl ){
	tr[p->next->x]=i;
    }
}

char str[510];
unsigned int ss[1010][16];
int ma[1010][1010];

int main(){
    int N;
    scanf("%d",&N);
    for( int i=0; i<N; i++ ){
	scanf("%s",str);
	for( int j=0; j<N; j++ ){
	    if(str[j]=='1'){
		ss[i][j>>5]|=(1U<<(j&31));
	    }
	}
    }
    for( int i=0; i<N; i++ ){
	ss[i+N][i>>5]|=(1U<<(i&31));
    }
    n=N*2;
    for( int i=0; i<N; i++ ){
	for( int j=0; j<n; j++ ){
	    for( int k=0; k<16; k++ ){
		if(ss[i][k]&ss[j][k]){
		    ma[i][j]=ma[j][i]=1;
		    break;
		}
	    }
	}
    }
    for( int i=0; i<n; i++ ){
	for( int j=i+1; j<n; j++ ){
	    if(ma[i][j]){
		eg[i].push_back(j);
		eg[j].push_back(i);
	    }
	}
    }
    lexbfs();
    if(isChordal()){
	transitive();
	for( int i=0; i<N; i++ ){
	    int md=1000000;
	    int mi;
	    for( int j=0; j<N; j++ ){
		if(tr[j+N]<md){
		    md=tr[j+N];
		    mi=j;
		}
	    }
	    for( int j=0; j<N; j++ ){
		ma[j][i]=(ss[j][mi>>5]>>(mi&31))&1;
	    }
	    tr[N+mi]=10000000;
	}
	int flag=1;
	for( int i=0; i<N; i++ ){
	    int f=0;
	    if(ma[i][0]) f=1;
	    for( int j=1; j<N; j++ ){
		if(!ma[i][j-1] && ma[i][j]) f++;
	    }
	    if(f>1){
		flag=0;
		break;
	    }
	}
	if(flag){
	    puts("YES");
	    for( int i=0; i<N; i++ ){
		for( int j=0; j<N; j++ ){
		    printf("%d",ma[i][j]);
		}
		puts("");
	    }
	}else{
	    puts("NO");
	}
    }else{
	puts("NO");
    }
    return 0;
}