#include<bits/stdc++.h>
using namespace std;

namespace PQ{
	const int MAXN=510;
	const int P=-1,Q=-2,White=0,Gray=1,Black=2;
	
	struct node{
		int v;
		node *son,*bro;
		int c;
		node(){}
		node(int v,node *son,node *bro,int c):
			v(v),son(son),bro(bro),c(c){}
	};
	node pool[MAXN*4];int poolN;
	node *unused;
	void clear(){
		poolN=0;unused=0;
	}
	node *NEW(){
		if(unused){
			node *p=unused;
			unused=unused->bro;
			return p;
		}else
			return pool+(poolN++);
	}
	void DELETE(node *p){
		p->bro=unused;
		unused=p;
	}
	node *newSubtree(node *p,int pv){
		return p->bro ? new(NEW())node(pv,p,0,0) : p;
	}
	
	void print(node *p,int dep){
		for(int i=0;i<dep-1;++i)
			cerr<<"    ";
		if(dep)
			cerr<<"---|";
		if(p->v>=0)
			cerr<<p->v;
		else if(p->v==P)
			cerr<<"P";
		else if(p->v==Q)
			cerr<<"Q";
		cerr<<endl;
		for(node *s=p->son;s;s=s->bro)
			print(s,dep+1);
	}
	
	node **tail(node *p){			// p != NULL
		node **lst=0;
		for(;p;p=p->bro)lst=&p->bro;
		return lst;
	}
	void cat(node *p,node *q){*tail(p)=q;}
	
	node *reverseBro(node *p){
		node *prev=0,*succ;
		for(node *i=p;i;i=succ){
			succ=i->bro;
			i->bro=prev;
			prev=i;
		}
		return prev;
	}
	void reverse(node *p){p->son=reverseBro(p->son);}
	
	bool checkRight(node *p){
		int st=0;
		int cnt[3]={0,0,0};
		for(node *s=p->son;s;s=s->bro){
			int c=s->c;
			if(c<st)return 0;
			++cnt[c];
			st=c;
		}
		return cnt[Gray]<=1;
	}
	void alignRight(node *p){
		if(p->v==P){
			node *h=0;
			node **slst=&p->son;
			node **hlst=&h;
			for(node *s=p->son;s;s=s->bro){
				if(s->c==Gray)
					*hlst=s,hlst=&s->bro;
				else
					*slst=s,slst=&s->bro;
			}
			*slst=0;
			
			slst=&p->son;
			for(node *s=p->son;s;s=s->bro){
				if(s->c==Black)
					*hlst=s,hlst=&s->bro;
				else
					*slst=s,slst=&s->bro;
			}
			*slst=h;
			*hlst=0;
		}else{
			if(!checkRight(p))reverse(p);
		}
	}
	node *splitWhite(node *p){			// p != NULL
		for(node *s=p->son,**prev=&p->son;s;prev=&s->bro,s=s->bro)
			if(s->c!=White){*prev=0;return s;}
		return 0;
	}
	int cntNGray(node *p){
		int cnt=0;
		for(;p&&p->c==Gray;p=p->bro)++cnt;
		return cnt;
	}
	struct PQTree{
		int n;
		node *rt;
		void init(int n){
			this->n=n;
			rt=new(NEW())node(P,0,0,0);
			node **lst=&rt->son;
			for(int v=0;v<n;++v){
				*lst=new(NEW())node(v,0,0,0);
				lst=&(*lst)->bro;
			}
		}
		void permutationDfs(node *p,int *&out){
			for(node *s=p->son;s;s=s->bro){
				if(s->v>=0)*out++=s->v;
				else permutationDfs(s,out);
			}
		}
		void permutation(int *out){permutationDfs(rt,out);}
		
		void print(){PQ::print(rt,0);}
		
		char* insertS;
		void insertPreDfs(node *p){
			if(p->v>=0)p->c=(insertS[p->v]=='1' ? Black : White);
			else{
				int s0=0,s1=1;
				for(node *s=p->son;s;s=s->bro){
					insertPreDfs(s);
					s0|=s->c!=White;
					s1&=s->c==Black;
				}
				p->c=(s0 ? (s1 ? Black : Gray) : White);
			}
		}
		bool insertDfs(node *p){
			if(p->v>=0||p->c==White||p->c==Black)return 1;
			if(p->v==P){
				alignRight(p);
				node *h=splitWhite(p);
				if(!p->son){
					p->son=h;
					int nGray=cntNGray(h);
					if(nGray==0)return 1;
					else if(nGray==1){
						p->v=Q;
						node *np=h;
						node *nq=newSubtree(h->bro,P);
						nq->c=Black;
						p->son=np,np->bro=nq,nq->bro=0;
					}else if(nGray==2){
						p->v=Q;
						node *npl=h,*npr=h->bro;
						if(h->bro->bro){
							node *nq=newSubtree(h->bro->bro,P);
							nq->c=Black;
							p->son=npl,npl->bro=nq,nq->bro=npr,npr->bro=0;
						}else{
							p->son=npl,npl->bro=npr,npr->bro=0;
						}
					}
				}else{
					node *np=newSubtree(h,P);
					np->c=Gray;
//					PQ::print(h,0);
					np->bro=p->son;p->son=np;
					return insertDfs(np);
				}
			}
//			PQ::print(p,0);
			node *fs=0,*ls=0;
			for(node *s=p->son;s;s=s->bro)
				if(s->c!=White){
					if(!fs)fs=s;
					ls=s;
				}
			if(fs==ls){ // Only sole Gray/Black sons
				return insertDfs(fs);
			}
			for(node *s=fs->bro;s!=ls;s=s->bro)
				if(s->c!=Black)
					return 0;
			
			for(int ti=0;ti<2;++ti){ 
				if(ti==1){reverse(p);swap(fs,ls);}
				// reverse to solve ls and make ls Left
				while(fs->c!=Black){
//					PQ::print(fs,0);
					alignRight(fs);
					if(!checkRight(fs))
						return 0;
					node *h=splitWhite(fs);
					if(fs->v==P){
						int nGray=cntNGray(h);
						if(nGray==0){
							h=newSubtree(h,P);
							h->c=Black;
						}else // nGray<=1 as fs!=ls
							h->bro=h->bro ? newSubtree(h->bro,P):0;
					}else{
						if(fs->son){
							node *nfs=fs->son;
							while(nfs->bro)nfs=nfs->bro;
							nfs->bro=fs->bro;
							fs->bro=fs->son,fs->son=0;
							// fs will be deleted afterwards
							fs=nfs;
						}
					}
					cat(h,fs->bro);
					fs->bro=h;  // fs -> the White sons
					fs=fs->bro; // fs->bro -> a new Gray/Black node
				}
				if(ti==1){reverse(p);swap(fs,ls);}
			}
			for(node *s=p->son,**prev=&p->son;s;s=*prev){
				if(s->v<0){
					if(!s->son){
						*prev=s->bro;
						DELETE(s);
					}else if(!s->son->bro){ // only one child
						*prev=s->son,s->son->bro=s->bro;
						// should not change prev in order to change chain
						DELETE(s);
					}else
						prev=&s->bro;
				}else
					prev=&s->bro;
			}
			return 1;
		}
		bool insert(char *str){
			insertS=str;
			insertPreDfs(rt);
			bool ok=insertDfs(rt);
			
/*			cerr<<endl;
			cerr<<"insert:";
			for(int i=0;i<n;++i)if(str[i]=='1')cerr<<' '<<i;
			cerr<<endl;
			print();
*/			return ok;
		}
	};
}

const int maxn=510;
int n;

char s[maxn][maxn];
PQ::PQTree sv;
int res[maxn];

void solve(){
	PQ::clear();
	scanf("%d",&n);
	for(int i=0;i<n;++i)
		scanf("%s",s[i]);
	sv.init(n);
//	sv.print();
	for(int i=0;i<n;++i)if(!sv.insert(s[i])){
		puts("NO");return;
	}
	sv.permutation(res);
	puts("YES");
//	for(int j=0;j<n;++j)printf("%d ",res[j]);putchar('\n');
	for(int i=0;i<n;++i,putchar('\n'))
		for(int j=0;j<n;++j)
			printf("%c",s[i][res[j]]);
}

int main(){
//	freopen("in.txt","r",stdin);
//	freopen("out2.txt","w",stdout);
	solve();
	return 0;
}