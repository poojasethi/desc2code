#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
using namespace std;
#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)
#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)
#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)
#define pb push_back
const int maxn=2050;
bool pc=1;
int root,ndtot,n,cnt;
typedef vector<int> vi;
vi son[maxn];
char s[maxn];
int a[maxn][maxn],req[maxn],num[maxn][4],bel[maxn],Q[maxn],rk[maxn];
inline void dfs(int x){
	num[x][0]=num[x][1]=num[x][2]=0;
	if(x<=n){
		bel[x]=req[x];
		num[x][bel[x]]++;
		return;
	}
	int emp=1,ful=1;
	rep2(i,0,son[x].size()){
		dfs(son[x][i]);
		if(bel[son[x][i]])emp=0;
		if(bel[son[x][i]]!=1)ful=0;
		num[x][bel[son[x][i]]]++;
	}
	if(emp)bel[x]=0;
	else if(ful)bel[x]=1;
	else bel[x]=2;
}
inline int get(int x,vi &L){
	if(num[x][2]>1)return 0;
	if(Q[x]){
		if(num[x][1]&&bel[son[x][0]]!=1||!num[x][1]&&bel[son[x][0]]!=2)reverse(son[x].begin(),son[x].end());
		rep2(i,0,num[x][1]){
			if(bel[son[x][i]]!=1)return 0;
			L.pb(son[x][i]);
		}
		int k=num[x][1];
		if(num[x][2]&&bel[son[x][k]]!=2)return 0;
		if(num[x][2]){
			if(!get(son[x][k],L))return 0;
			k++;
		}
		rep2(i,k,son[x].size())L.pb(son[x][i]);
	}else{
		if(num[x][1]){
			int t1=++ndtot;
			rep2(i,0,son[x].size())if(bel[son[x][i]]==1)son[t1].pb(son[x][i]);
			if(son[t1].size()==1)t1=son[t1][0];L.pb(t1);
		}
		rep2(i,0,son[x].size())if(bel[son[x][i]]==2)if(!get(son[x][i],L))return 0;
		if(num[x][0]){
			int t2=++ndtot;
			rep2(i,0,son[x].size())if(!bel[son[x][i]])son[t2].pb(son[x][i]);
			if(son[t2].size()==1)t2=son[t2][0];L.pb(t2);
		}
	}
	return 1;
}
inline int getr(int x,vi &L){
	int sz=L.size();
	if(get(x,L)){
		reverse(L.begin()+sz,L.end());
		return 1;
	}
	return 0;
}
inline int getl(int x,vi &L){
	return get(x,L);
}
inline int calc(int x){
	if(x<=n)return 1;
	if(num[x][1]+num[x][2]==1)rep2(i,0,son[x].size())if(bel[son[x][i]])return calc(son[x][i]);
	if(num[x][2]>2)return 0;
	vi tmp;tmp.clear();
	if(Q[x]){
		int Nm=0,Ed=0;//Nm：是否出现过关键节点，Ed：关键节点排列是否结束
		rep2(i,0,son[x].size()){
			if(Ed&&bel[son[x][i]])return 0;
			if(Nm&&!bel[son[x][i]])Ed=1;
			if(bel[son[x][i]]==2){
				if(!Nm){
					if(!getr(son[x][i],tmp))return 0;
				}else if(!getl(son[x][i],tmp))return 0;
			}else tmp.pb(son[x][i]);
			if(bel[son[x][i]])Nm=1;
		}
	}else{
		int t1=++ndtot;Q[t1]=1;
		rep2(i,0,son[x].size())if(bel[son[x][i]]==2){
			if(!getr(son[x][i],son[t1]))return 0;
			break;
		}
		if(num[x][1]){
			int t2=++ndtot;
			rep2(i,0,son[x].size())if(bel[son[x][i]]==1)son[t2].pb(son[x][i]);
			if(son[t2].size()==1)t2=son[t2][0];son[t1].pb(t2);
		}
		int ars=0;//找到第二个2号节点 
		rep2(i,0,son[x].size())if(bel[son[x][i]]==2){
			if(!ars)ars=1;
			else if(!getl(son[x][i],son[t1]))return 0;
		}
		if(son[t1].size()==1)t1=son[t1][0];tmp.pb(t1);
		rep2(i,0,son[x].size())if(!bel[son[x][i]])tmp.pb(son[x][i]);
	}
	son[x]=tmp;
	return 1;
}
inline void getres(int x){
	if(x<=n){
		rk[++cnt]=x;
		return;
	}
	rep2(i,0,son[x].size())getres(son[x][i]);
}
int main(){
	scanf("%d",&n);
	root=ndtot=n+1;
	rep(i,1,n)son[root].pb(i);
	rep(i,1,n){
		scanf("%s",s);
		rep(j,1,n){
			req[j]=s[j-1]-'0';
			a[i][j]=req[j];
		}
		dfs(root);
		if(!calc(root)){
			pc=0;
			puts("NO");
			break;
		}
	}
	if(pc){
		puts("YES");
		getres(root);
		rep(i,1,n){
			rep(j,1,n)printf("%d",a[i][rk[j]]);
			puts("");
		}
	}
	return 0;
}