def get_primes(n):
  primes = []
  composite = set()
  for i in xrange(2, n + 1):
    if i not in composite:
      primes.append(i)
      composite.update(xrange(i * 2, n + 1, i))
  return primes
def bsearch(lst, n):
  l = 0
  r = len(lst)
  while l < r:
    m = (l + r) / 2
    if lst[m] < n:
      l = m + 1
    else: 
      r = m
  return l
def col(mat, i):
  return map(lambda r: r[i], mat)
#def dist(row):
  #def f(n):
    #return primes[bsearch(primes, n)] - n
  #return sum(map(f, row))
memo = dict()
def dist(n):
  if n in memo:
    return memo[n]
  res = primes[bsearch(primes, n)] - n
  memo[n] = res
  return res

primes = get_primes(100100)
[n, m] = map(int, raw_input().split())
mat = []
for i in xrange(n):
  row = map(int, raw_input().split())
  mat.append(row)
min_dist = 1000000000
dists = map(lambda r: map(lambda n: dist(n), r), mat)
for i in xrange(n):
  min_dist = min(min_dist, sum(dists[i]))
for j in xrange(m):
  min_dist = min(min_dist, sum(col(dists, j)))
print min_dist
