#! /Library/Frameworks/Python.framework/Versions/2.6/bin/python

inp = raw_input().split()

n = int(inp[0])
m = int(inp[1])

matrix = [[] for i in range(n)]

for i in range(n):
	inp = raw_input().split()
	for j in range(m):
		matrix[i] += [int(inp[j])]

def primesUpTo(n):
    primes = []
    marked = [False]*(n+1)
    for i in range(2, n+1):
        if not(marked[i]):
            primes += [i]
            for intToMark in range(i*i, n+1, i):
                marked[intToMark] = True
    return primes

def binSearchNext(OrdList,x):
	lInd = 0
	uInd = len(OrdList) - 1
	while uInd - lInd > 1:
		mInd = (lInd + uInd)/2
		if x <= OrdList[mInd]:
			uInd = mInd
		else:
			lInd = mInd
	if x <= OrdList[lInd]:
		return OrdList[lInd]
	else:
		return OrdList[uInd]

PrimeList = primesUpTo(100020)

opsNeeded = [[] for i in range(n)]

minOps = max(n,m) * 100030

for i in range(n):
	rowOpCount = 0
	for j in range(m):
		opsNeeded[i] += [binSearchNext(PrimeList,matrix[i][j]) - matrix[i][j]]
		rowOpCount += opsNeeded[i][j]
	if rowOpCount < minOps:
		minOps = rowOpCount

for j in range(m):
	colOpCount = 0
	for i in range(n):
		colOpCount += opsNeeded[i][j]
	if colOpCount < minOps:
		minOps = colOpCount

print minOps

