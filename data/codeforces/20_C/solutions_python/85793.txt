#!/usr/bin/env python
# -*- coding:utf-8 -*-
# TLE

from collections import defaultdict
from sys import stdin
import heapq

import gc; gc.disable()

INF = 100000000001

def get_shortest_path(n, edges):
    if not edges[1]: return [] #No path exists
    callback = run_dijkstra(n, edges)
    path = []
    if not callback[n]: return path
    node = n
    while node:
        path.append(node)
        node = callback[node]
    path.reverse()
    return path

def run_dijkstra(n, edges):
    dists = [INF] * (n+1)
    dists[1] = 0

    visited = [False] * (n+1)
    callback = [None] * (n+1)
    heap = [(0, 1)]
    
    while heap:
        acc_dist, node = heapq.heappop(heap)
        if node == n: return callback
        visited[node] = True
        for neighbor, dist in edges[node].iteritems():
            new_dist = acc_dist + dist
            d = dists[neighbor]
            if new_dist < d:
                dists[neighbor] = d = new_dist
                callback[neighbor] = node
            if not visited[neighbor]:
                heapq.heappush(heap, (d, neighbor))
    
    return callback
    
def get_input(m):
    edges = defaultdict(dict)
    for line in stdin:
        a, b, w = line.split(' ')
        if a == b: continue
        a, b, w = int(a), int(b), int(w)
        dist = edges[a].get(b, INF)
        if dist > w:
            edges[a][b] = edges[b][a] = w
    return edges 

if __name__ == '__main__':
    n, m = raw_input().split() # #vertices, #edges
    n, m = int(n), int(m)
    edges = get_input(m)
    path = get_shortest_path(n, edges)
    if not path:
        print -1
    else:
        print ' '.join(map(str, path))
