#include <stdio.h>
#include <vector>
#include <algorithm>

using namespace std;

#define KMAX 100000
#define NMAX 100000

struct imp{
	int id,t,i,b;
	double rate;
};

int a[KMAX+1];
vector<imp> vec[KMAX+1][4];
bool has_as[KMAX+1];
vector<imp> veca;

bool greater_compb(imp a,imp b){return a.b>b.b;}
bool greater_comp_rate(imp a,imp b){return a.rate>b.rate;}
bool compt(imp a,imp b){return a.t<b.t;}

int main(){
	int k,n,m;
	int l=0;
	double last;
	imp t;
	vector<imp>::iterator iti,mxiti;
	int i,j;

	scanf("%d%d%d",&k,&n,&m);
	getchar();
	for(i=1;i<=k;i++){
		scanf("%d",a+i);
		getchar();
	}
	for(i=1;i<=n;i++){
		scanf("%d%d%d",&t.t,&t.i,&t.b);
		getchar();
		t.id=i;
		if(t.t==1)has_as[t.i]=true;
		else l++;
		if(t.t==3)t.rate=t.b;
		vec[t.i][t.t].push_back(t);
	}

	for(i=1;i<=k;i++)if(has_as[i]){
		for(mxiti=iti=vec[i][1].begin();iti!=vec[i][1].end();iti++)
			if(iti->b>mxiti->b)mxiti=iti;
		if(mxiti->b<=a[i]){
			has_as[i]=false;
			continue;
		}
		mxiti->rate=mxiti->b/(double)a[i];
		mxiti->b-=a[i];
		vec[i][2].push_back(*mxiti);
	}

	for(i=1;i<=k;i++)sort(vec[i][2].begin(),vec[i][2].end(),greater_compb);
	for(i=1;i<=k;i++){
		last=a[i];
		for(iti=vec[i][2].begin();iti!=vec[i][2].end();iti++){
//			printf("%d %lf %d\n",iti->b,last,a[i]);
			iti->rate=(last+iti->b)/last;
			last+=iti->b;
			veca.push_back(*iti);
		}
	}

	for(i=1;i<=k;i++)
		for(iti=vec[i][3].begin();iti!=vec[i][3].end();iti++)
			veca.push_back(*iti);

	sort(veca.begin(),veca.end(),greater_comp_rate);

	for(i=1;i<=k;i++)if(has_as[i])l++;
	if(l>m)l=m;
	sort(veca.begin(),veca.begin()+l,compt);
	printf("%d\n",l);
	iti=veca.begin();
	for(i=1;i<=l;i++,iti++)printf("%d ",iti->id);
	return 0;
}

