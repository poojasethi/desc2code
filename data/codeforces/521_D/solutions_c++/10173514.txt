#include <algorithm>
#include <numeric>
#include <iostream>
#include <cassert>
#include <cstdio>
#include <cstring>
#include <queue>
#include <vector>

#define NMAX 100010

using namespace std;

typedef long long lli;

vector<pair<int,int> > inc[NMAX];
priority_queue<pair<double,int> > Q;

lli A[NMAX];

int N,M,K;

vector<pair<int,int> > mul;

int sel[NMAX];
int typ[NMAX];

void compute(){

	int k;

	while(M-- && !(Q.empty() && mul.empty())){

		k = Q.empty() ? -1 : Q.top().second;

		if(mul.empty() ||  (k >= 0 && Q.top().first >= mul.back().first)){
			A[k] += inc[k].back().first;
			sel[inc[k].back().second] = 1;
			inc[k].pop_back();
			Q.pop();

			if(!inc[k].empty()) Q.push(make_pair( (A[k]+inc[k].back().first)/(1.0*A[k]), k) );
			continue;
		}

		sel[mul.back().second] = 1;
		mul.pop_back();
	}

}

pair<int,int> typ1[NMAX];

int main(){
	int i,b,t;
	cin >> K >> N >> M;

	for(i =0 ; i < K; ++i) cin >> A[i];

	for(int idx = 0; idx < N; ++idx){
		cin >> t >> i >> b;

		typ[idx] = t;

		if(t == 3){
			mul.push_back(make_pair(b,idx));
			continue;
		}

		--i;
		if(t == 1){
			typ1[i] = max(typ1[i],make_pair(b-(int)A[i],idx));
			continue;
		}

		inc[i].push_back(make_pair(b,idx));
	}

	for(i = 0; i < K; ++i){
		if(!typ1[i].first) continue;
		inc[i].push_back(typ1[i]);
	}

	sort(mul.begin(),mul.end());
	for(i =0 ; i < K; ++i){
		if(inc[i].empty()) continue;
		sort(inc[i].begin(),inc[i].end());
		Q.push(make_pair( (A[i]+inc[i].back().first)/(1.0*A[i]), i));
	}

	compute();

	cout << accumulate(sel,sel+N,0) << '\n';
	for(i = 0; i < N; ++i){
		if(!sel[i] || typ[i] > 1) continue;
		cout << i+1 << ' ';
	}

	for(i = 0; i < N; ++i){
		if(!sel[i] || typ[i] != 2) continue;
		cout << i+1 << ' ';
	}

	for(i = 0; i < N; ++i){
		if(!sel[i] || typ[i] < 3) continue;
		cout << i+1 << ' ';
	}


	return 0;
}
