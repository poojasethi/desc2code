// 2015-03-04 17:01:04.573489 
#include <iostream>
#include <queue>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <cctype>
#include <algorithm>
#include <vector>
#include <set>
#include <map>
#include <iomanip>

using namespace std;

typedef long long LL;

#define REP(i, n) for (int i(0); i < (int) (n); i++)

const int N = 100005;
LL k, n, m, a[N], z[N];
LL t[N], p[N], b[N], o[N];
vector<pair<LL, LL> > E[N];

int cmp(int i, int j) {
	return t[i] < t[j];
}

int main() {
	cin >> k >> n >> m;
	REP(i, k) cin >> a[i];
	priority_queue<pair<double, int> > Q, P;
	REP(i, n) {
		cin >> t[i] >> p[i] >> b[i];
		p[i]--;
		if (t[i] == 1)
			z[p[i]] = max(z[p[i]], b[i]);
	}
	REP(i, n) 
	if (t[i] == 1) {
		if (z[p[i]] == b[i] && b[i] > a[p[i]]) {
			z[p[i]] = -1;
			E[p[i]].push_back(make_pair(b[i] - a[p[i]], i));
		}
	} else
	if (t[i] == 2) {
		E[p[i]].push_back(make_pair(b[i], i));
	} else
		P.push(make_pair(b[i] * 1.0, i));
	REP(i, k) {
		sort(E[i].begin(), E[i].end());
		reverse(E[i].begin(), E[i].end());
		if (!E[i].empty()) {
			o[i] = 1;
			Q.push(make_pair((a[i] + E[i][0].first + .0) / a[i], E[i][0].second));
		}
	}
	vector<int> ans;
	REP(c, m) {
		if (Q.empty() && P.empty()) break;
		if (Q.empty() || (!P.empty() && P.top().first > Q.top().first)) {
			ans.push_back(P.top().second);
			P.pop();
		} else {
			int i = Q.top().second;
			ans.push_back(i);
			Q.pop();
			int x = p[i];
			a[x] += E[x][o[x] - 1].first;
			if (o[x] < (int)E[x].size()) {
				Q.push(make_pair((a[x] + E[x][o[x]].first + .0) / a[x], E[x][o[x]].second));
				o[x]++;
			}
		}
	}
	sort(ans.begin(), ans.end(), cmp);
	cout << ans.size() << endl;
	REP(i, ans.size()) printf("%d%c", ans[i] + 1,  i == (int)ans.size() - 1 ? '\n' : ' ');
	return 0;
}
