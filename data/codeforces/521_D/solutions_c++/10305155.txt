#include <bits/stdc++.h>

using namespace std;

#define F first
#define S second

#define endl '\n'

#define mp make_pair
#define pb push_back

#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define ROF(i, a, b) for(int i = a; i >= b; i--)

#define type(x) __typeof((x).begin())
#define foreach(i, x) for(type(x) i = (x).begin(); i != (x).end(); i++)

#define sol (root + root)
#define sag (root + root + 1)
#define orta ((bas + son) >> 1)

#define bit __builtin_popcount

#ifndef D
	#define dbg(x) 0
	#define dbgs(x) 0
#else
	#define dbg(x) cerr << (#x) << " --> " << (x) << endl
	#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#endif

typedef long long ll;
typedef pair < int, int > pii;

const int inf = 1e9 + 5;
const ll linf = 1e18 + 5;

const int N = 1e5 + 5;

int k, n, m, c, x, y, a[N], type[N];

pii mx[N];

vector < int > ans;

vector < pair < double, int > > v, add[N], mul[N];

bool cmp(int x, int y) {

	return type[x] < type[y];

}

int main() {
	
	ios :: sync_with_stdio(0);

	cin >> k >> n >> m;

	FOR(i, 1, k)
		cin >> a[i];

	FOR(i, 1, n)
	{
		cin >> c >> x >> y;

		type[i] = c;

		if(c == 1)
			mx[x] = max(mx[x], mp(y, i));
		if(c == 2)
			add[x].pb(mp(y, i));
		if(c == 3)
			mul[x].pb(mp(y, i));
	}

	FOR(i, 1, k)
	{
		if(mx[i].F)
			add[i].pb(mp(mx[i].F - a[i], mx[i].S));

		sort(add[i].begin(), add[i].end());

		reverse(add[i].begin(), add[i].end());

		ll sum = a[i];

		foreach(it, add[i])
		{
			mul[i].pb(mp((double) (sum + it -> F) / sum, it -> S));

			sum += it -> F;
		}

		foreach(it, mul[i])
			v.pb(*it);
	}

	sort(v.begin(), v.end());

	reverse(v.begin(), v.end());

	int cnt = 0;

	foreach(it, v)
	{
		if(it -> F < 1 or cnt == m) break;

		ans.pb(it -> S);

		cnt++;
	}

	sort(ans.begin(), ans.end(), cmp);

	cout << ans.size() << endl;

	foreach(it, ans)
		cout << *it << ' ';

	cout << endl;

	return 0;

}
