#include<iostream>
#include<vector>
#include<algorithm>
#define f first
#define s second
#define mp make_pair
using namespace std;


int k, n, m, initial[100000], maxImprove[100000], improveInd[100000], p1, p2, p3, optype[100000];
vector<pair<int, int> > adds[100000];


bool oporder(int l, int r) {
	return optype[l] < optype[r];
}


//Format: (improvement, index)
vector<pair<double, int> > ops;
vector<int> choice;




int main() {
	cin.sync_with_stdio(false);
	
	cin >> k >> n >> m;
	
	for(int i=0;i<k;i++)
		cin >> initial[i], improveInd[i] = -1;
		
		
	for(int i=0;i<n;i++) {
		cin >> p1 >> p2 >> p3;
		
		
		optype[i] = p1;
		
		if(p1 == 1 && p3 > maxImprove[p2-1]) {
			maxImprove[p2-1] = p3;
			
			improveInd[p2-1] = i;
		}
		
		if(p1 == 2) {
			adds[p2-1].push_back(mp(p3, i));
		}
		
		if(p1 == 3)
			ops.push_back(mp(1.0*p3, i) );
	}
	
	
	for(int i=0;i<k;i++)
		if(maxImprove[i] > initial[i]) {
			adds[i].push_back( mp(maxImprove[i] - initial[i], improveInd[i]) );
		}
		
		
	
	for(int i=0;i<k;i++) {
		long long cval = initial[i];
		
		sort(adds[i].begin(), adds[i].end() );
		reverse(adds[i].begin(), adds[i].end() );
		
		for(int j=0;j<adds[i].size();j++) {
			ops.push_back(mp(1.0 * (cval + adds[i][j].f) / cval,  adds[i][j].s ) );
			
			cval += adds[i][j].f;
		}
	}
	
	
	//Finally add ops
	
	sort(ops.begin(), ops.end() );
	reverse(ops.begin(), ops.end() );
	
	
	for(int i=0;i<ops.size() && i < m;i++)
		choice.push_back(ops[i].s);
		
	
	sort(choice.begin(), choice.end(), oporder);
	
	
	cout << choice.size() << '\n';
	
	for(int i=0;i<choice.size();i++)
		cout << choice[i] + 1 << ' ';
		
	cout << '\n';
	
	
	return 0;
}



































