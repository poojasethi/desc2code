#include<iostream>
#include<cstdio>
#include<vector>
#include<map>
#include<algorithm>
#define PB push_back
#define MP make_pair

using namespace std;
typedef vector<int>::iterator Itv;
typedef multimap<int,int>::reverse_iterator rItm;
typedef long long int LL;
const int M=100005;
int k,n,m,a[M];
struct OP{
	int tp,pos,id;
	LL up,dn;
}op[M];

multimap<int,int> v[M][3];
vector<OP> vip;
bool cmp1(const OP op1,const OP op2){
	LL a=op1.up*op2.dn,b=op1.dn*op2.up;
	if(a<b) return 0;
	if(a==b) return op1.id<op2.id;
	return 1;
}
bool cmp2(const OP op1,const OP op2){
	if(op1.pos<op2.pos) return 1;
	else if(op1.pos==op2.pos){
		if(op1.tp<op2.tp) return 1;
		else if(op1.tp==op2.tp) return op1.id<op2.id;
		return 0;
	}
	return 0;
}

int main(){
	cin>>k>>n>>m;
	for(int i=0;i<k;++i) scanf("%d",a+i);
	for(int i=0,x,y,z;i<n;++i){
		scanf("%d %d %d",&x,&y,&z);
		v[y-1][x-1].insert(MP(z,i));
	}
	for(int i=0;i<k;++i){
		bool alin=1;
		int t=-1;
		if(!v[i][0].empty()){
			rItm itm=v[i][0].rbegin();
			t=itm->first-a[i];
			v[i][1].insert(MP(t,itm->second));
			alin=0;
		}
		LL sum=a[i];
		for(rItm itm=v[i][1].rbegin();itm!=v[i][1].rend();++itm){
			int add=itm->first;
			if(!alin&&add==t){
				alin=1;
				struct OP op={0,i,itm->second,add,sum};
				vip.PB(op);
			}
			else{
				struct OP op={1,i,itm->second,add,sum};
				vip.PB(op);
			}
			sum+=add;
		}
		for(rItm itm=v[i][2].rbegin();itm!=v[i][2].rend();++itm){
			struct OP op={2,i,itm->second,itm->first-1,1};
			vip.PB(op);
		}
	}
	sort(vip.begin(),vip.end(),cmp1);
	m=m>vip.size()?vip.size():m;
	for(int i=0;i<m;++i) if(vip[i].up<=0) m=i;
	sort(vip.begin(),vip.begin()+m,cmp2);
	cout<<m<<endl;
	if(m){
		cout<<vip[0].id+1;
		for(int i=1;i<m;++i){
			cout<<" "<<vip[i].id+1;
		}
		cout<<endl;
	}
}
