#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;

typedef long long LL;
const int N=100010;

struct Skill {
	int t,i,b,id;
	bool operator < (const Skill& rhs) const {
		return b>rhs.b;
	}
};

LL gcd(LL a,LL b) {
	while(b) {
		LL t=a%b;
		a=b;
		b=t;
	}
	return a;
}

struct Frac {
	LL num,den;
	int id,t;
	Frac(LL _num=0,LL _den=1,int id=0,int t=0):t(t),id(id) {
		LL g=gcd(_num,_den);
		num=_num/g;
		den=_den/g;
	}
	bool operator < (const Frac& rhs) const {
		return num*rhs.den>den*rhs.num;
	}
};

vector<Skill>assign[N],add[N];
vector<Frac>fracs;
int a[N];
int k,n,m;

int cmp_t(const Frac& a,const Frac& b) {
	return a.t<b.t;
}

int main() {
	scanf("%d%d%d",&k,&n,&m);
	for(int i=1;i<=k;i++) {
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=n;i++) {
		Skill tmp;
		tmp.id=i;
		scanf("%d%d%d",&tmp.t,&tmp.i,&tmp.b);
		if(tmp.t==1) {
			assign[tmp.i].push_back(tmp);
		} else if(tmp.t==2) {
			add[tmp.i].push_back(tmp);
		} else {
			fracs.push_back(Frac(tmp.b-1,1,tmp.id,tmp.t));
		}
	}
	for(int i=1;i<=k;i++) {
		if(!assign[i].empty()) {
			sort(assign[i].begin(),assign[i].end());
			Skill tmp=assign[i][0];
			if(tmp.b>a[tmp.i]) {
				tmp.b-=a[tmp.i];
				add[i].push_back(tmp);
			}
		}
		if(!add[i].empty()) {
			sort(add[i].begin(),add[i].end());
			LL pre=a[i];
			for(int j=0;j<add[i].size();j++) {
				Skill tmp=add[i][j];
				fracs.push_back(Frac(tmp.b,pre,tmp.id,tmp.t));
				pre+=tmp.b;
			}
		}
	}
	sort(fracs.begin(),fracs.end());
	int res=min(m,(int)fracs.size());
	printf("%d\n",res);
	sort(fracs.begin(),fracs.begin()+res,cmp_t);
	for(int i=0;i<res;i++) {
		printf("%d ",fracs[i].id);
	}
	return 0;
}