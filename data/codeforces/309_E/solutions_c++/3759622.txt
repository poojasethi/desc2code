// 二分 + 构造
// 二分探索 + コンストラクタ


//  有待证明
//  对于a, \forall{(i,j) \in S} |x_i-x-j| <= a
// 下述算法可以构造一组合法解 或者返回无解
//  增量 每次将一个元素加入到区间最后
//  1. 置排列边界 Bound[i] = +inf 即 x_i <= Bound[i]
//  2. 选择一个右边界最小的区间号，且加入后目前可能存在一个满足 Bound 条件的解
//  3. 若有选择执行 4， 否则返回无解
//  4. 更新其他位置的编号跳 2。

#include<cstdio>
#include<set>
#include<map>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<vector>
#include<cstdlib>
#include<complex>
using namespace std;

void Get(int &T)
{
	char C;bool F=0;
	for(;C=getchar(),C<'0'||C>'9';)if(C=='-')F=1;
	for(T=C-'0';C=getchar(),C>='0'&&C<='9';T=T*10+C-'0');
	F&&(T=-T);
}

int N;
int L[2005];
int R[2005];
bool G[2005][2005];


void Init()
{
	Get(N);
	for(int i=1;i<=N;i++)
	{
		Get(L[i]);Get(R[i]);
	}
	R[0]=0x3f3f3f3f;
	for(int i=1;i<=N;i++)
		for(int j=1;j<=N;j++)
			G[i][j]=((L[i]<=R[j])&&(L[j]<=R[i]));
	/*
	for(int i=1;i<=N;i++)
	{
		for(int j=1;j<=N;j++)
			printf("%d ",G[i][j]);
		puts("");
	}
	*/
}

int Rank[2005];
int Bound[2005];
bool Unavailable[2005];

int Cnt[2005];

bool Check(int X)
{
	memset(Rank,0,sizeof Rank);
	//memset(Bound,0x2f,sizeof Bound);
	for(int i=1;i<=N;i++)
		Bound[i]=N;
	memset(Unavailable,0,sizeof Unavailable);
	
	for(int i=1;i<=N;i++)
	{
		int Choose=0;
		for(int j=1;j<=N;j++)
			if(Unavailable[j]==0&&R[j]<R[Choose])
				Choose=j;
		
		Rank[Choose]=i;
		
//		printf("``` %d\n",Choose);
		
		Bound[Choose]=i;
		
		for(int j=1;j<=N;j++)
			if(G[Choose][j]&&Bound[j]>Bound[Choose]+X)
				Bound[j]=Bound[Choose]+X;
		/*
		printf("``` %d\n",Choose);
		
		
		for(int k=1;k<=N;k++)
			printf("%d ",Bound[k]);
		puts("");
		*/		
		
		memset(Cnt,0,sizeof Cnt);
		for(int j=1;j<=N;j++)
			Cnt[Bound[j]]++;
		for(int j=1;j<=N;j++)
			Cnt[j]+=Cnt[j-1];
		for(int j=1;j<=N;j++)
			if(Cnt[j]>j)
				return 0;
		
			
		int Low=0;
		for(int j=i+1;j<=N;j++)
			if(Cnt[j]==j)
			{
				Low=j;
				break;
			}
		
//		printf("%d\n",Low);
		
		for(int j=1;j<=N;j++)
			if(Rank[j]<=0&&Bound[j]<=Low)
				Unavailable[j]=0;
			else
				Unavailable[j]=1;
		/*
		for(int j=1;j<=N;j++)
			printf("``` %d ",Unavailable[j]);
		puts("");
		
		printf("%d\n",Low);	
		*/
		/*
		for(int j=1;j<=N;j++)
			printf("``` %d ",Cnt[j]);
		puts("");
		*/
		
//		Unavailable[Choose]=1;
			
//		printf("%d\n",Choose);
		
//		break;
	}
	
	return 1;
}

int Bin()
{
	for(int L=0,R=N,Mid;;)
	{
		if(L==R)
			return L;
		if(L+1==R)
		{
			if(Check(L)) return L;
			return R;
		}
		Mid=L+R;Mid>>=1;
		if(Check(Mid))
			R=Mid;
		else
			L=Mid;
	}
}

int Ans[2005];

void Work()
{
	int Ans1=Bin();
	Check(Ans1);
	for(int i=1;i<=N;i++)
		Ans[Rank[i]]=i;
	//printf("%d\n",Ans1);
}

void Output()
{
	for(int i=1;i<=N;i++)
		printf("%d ",Ans[i]);
	puts("");
	
}

int main()
{
	Init();
	Work();
	Output();
	return 0;
}