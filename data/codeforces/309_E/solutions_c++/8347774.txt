#include <cstdio>
#include <algorithm>

using namespace std;

const int N = 2020;

int n;

struct seg {
	int l, r, id;
} a[N];

bool G[N][N];
int mx[N], pos[N], need[N];

bool cmp_r(const seg& a, const seg& b) {
	return a.r < b.r;
}
int check_lim(int p) {
	int ret = n;
	for (int i = 1; i <= n; ++i) need[i] = 0;
	for (int i = 1; i <= n; ++i) if (!pos[i]) ++need[mx[i]];
	int tot = 0;
	for (int i = p; i <= n; ++i) {
		tot += need[i];
		if (tot > i - p + 1) return -1;
		if (tot == i - p + 1) ret = min(ret, i);
	}
	return ret;
}
bool check(int D, bool final = 0) {
	for (int i = 1; i <= n; ++i) {
		mx[i] = n;
		pos[i] = 0;
	}
	for (int foo = 1; foo <= n; ++foo) {
		int lim = check_lim(foo);
		if (lim == -1) return 0;
		int o = -1;
		for (int i = 1; i <= n; ++i)
			if (!pos[i] && mx[i] <= lim) {
				o = i;
				break;
			}
		pos[o] = foo;
		if (final) printf("%d ", a[o].id);
		for (int i = 1; i <= n; ++i)
			if (!pos[i] && G[o][i]) {
				mx[i] = min(mx[i], pos[o] + D);
			}
	}
	return 1;
}
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) {
		scanf("%d %d", &a[i].l, &a[i].r);
		a[i].id = i;
	}
	sort(a + 1, a + n + 1, cmp_r);
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j) {
			G[i][j] = !(a[i].r < a[j].l || a[i].l > a[j].r);
		}
	int ll = 1, rr = n - 1;
	while (ll < rr) {
		int mm = (ll + rr) >> 1;
		if (check(mm))
			rr = mm;
		else
			ll = mm + 1;
	}
	check(ll, 1);
}
