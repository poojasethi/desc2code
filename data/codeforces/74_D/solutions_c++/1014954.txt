#include <set>
#include <map>
#include <cstdio>
#include <iostream>
using namespace std;

int n, q;
map<int, int> ar;

void add(int i, int v) {
	for (; i <= n; ar[i] += v, i += (i & (-i)));
}
int sum(int i) {
	int s = 0;
	for (; i > 0; i -= (i & (-i))) {
		if (ar.find(i) != ar.end()) {
			s += ar[i];
		}
	}
	return s;
}
int sum(int a, int b) {
	return sum(b) - sum(a - 1);
}

struct Seg {
	int st, ed;
	Seg() {
	}
	Seg(int s, int e) :
			st(s), ed(e) {
	}

	bool operator <(const Seg& p) const {
		if (ed - st != p.ed - p.st) {
			return ed - st > p.ed - p.st;
		}
		return st > p.st;
	}
};

map<int, int> wh;
set<Seg> sg;
set<int> hk; //保存节点

int main() {
//	freopen("in.txt", "r", stdin);

	cin >> n >> q;
	hk.insert(0);
	hk.insert(n + 1);
	sg.insert(Seg(1, n));

	for (int i = 0; i < q; i++) {
		int p, a, b;
		cin >> p;
		if (!p) {
			cin >> a >> b;
			cout << sum(a, b) << endl;
		} else {
			if (!wh[p]) {
				set<Seg>::iterator it = sg.begin();
				int st = it->st, ed = it->ed;
				int m = (ed + st + 1) / 2;
				sg.erase(it);
				if (st <= m - 1) {
					sg.insert(Seg(st, m - 1));
				}
				if (m + 1 <= ed) {
					sg.insert(Seg(m + 1, ed));
				}
				add(m, 1);
				wh[p] = m;
				hk.insert(m);
			} else {
				int m = wh[p];
				set<int>::iterator it, L, R;
				R = L = it = hk.find(m);
				L--, R++;
				int st = *L + 1;
				int ed = *R - 1;
				if (st <= m - 1) {
					sg.erase(Seg(st, m - 1));
				}
				if (m + 1 <= ed) {
					sg.erase(Seg(m + 1, ed));
				}
				add(m, -1);
				hk.erase(it);
				sg.insert(Seg(st, ed));
				wh[p] = 0;
			}
		}
	}

	return 0;
}
