#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define inf 2000000000
struct segment
{
    int left,sz;
    bool operator <(const segment s) const
    {
        return (sz!=s.sz)? sz>s.sz : left > s.left ;
    }
};
int n,q,X,a,b,id=1;
set<segment>cur;
set<segment>:: iterator it;
set<int>SET;
set<int>:: iterator jt,kt;
map<int,int>T,on;
void up(int x,int y)
{
    for(; x<=n; x+=x&(-x)) T[x]+=y;
}
int read(int x)
{
    int ret=0;
    for(; x; x-=x&(-x)) if(T.count(x)) ret+=T[x];
    return ret;
}
void show()
{
    for(it=cur.begin(); it!=cur.end(); it++)cout<< it -> left <<" to "<< it -> sz -1 +it -> left<<endl;
    for(jt=SET.begin(); jt!=SET.end(); jt++)cout<<*jt<<" okay ?"<<endl;
}
void test()
{
    for(int i=1; i<=q; i++)
    {
        scanf("%d",&X);
        if(X==0)
        {
            scanf("%d %d",&a,&b);
           printf("%d\n",read(b)-read(a-1));
        }
        else
        {
            int W=on[X];
            if(W)
            {
                up(W,-1);
                kt=jt=SET.find(W);
                jt++,kt--;
                if(W-*kt-1>=1)cur.erase({*kt+1,W-*kt-1});
                if(*jt-W-1>=1)cur.erase({W+1,*jt-W-1});
                if(*jt-*kt-1>=1)cur.insert({*kt+1,*jt-*kt-1});
                SET.erase(W);
                on[X]=0;
            }
            else
            {
                segment s=*cur.begin();
                int point=s.left+s.sz/2;
                cur.erase(s);
                if(point-s.left>=1)cur.insert({s.left,point-s.left});
                if(s.left+s.sz-point-1>=1)cur.insert({point+1,s.left+s.sz-point-1});
                SET.insert(point);
                on[X]=point;
                up(point,1);
                //puts("here");
            }
            //show();
        }
    }
}
int main()
{
    scanf("%d %d",&n,&q);
    cur.insert({1,n}),SET.insert(0),SET.insert(n+1);
    test();
}

