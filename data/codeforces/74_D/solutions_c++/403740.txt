#include <cstdio>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
using namespace std;

#define INF 1000000010

struct Seg
{
  int l, r;
  Seg(){}
  Seg(int lt, int rt):l(lt),r(rt){}
  bool operator < (const Seg &p) const
  {
    return r-l > p.r-p.l || (r-l == p.r-p.l && r > p.r);
  }
};

struct Node
{
  int l, r, tot;
  Node *lef, *rig;
  Node(){}
  Node(int lt, int rt):l(lt),r(rt) 
  {
    lef = rig = NULL;
    tot = 0;
  }
  
  int cal(int x, int y) 
  {
    if (y < l || r < x) return 0;
    if (x <= l && r <= y)
      return tot;
    
    int mid = (l+r) >> 1;
    if (lef == NULL) lef = new Node(l, mid);
    if (rig == NULL) rig = new Node(mid+1, r);
    return lef->cal(x, y) + rig->cal(x, y);
  }

  void ins(int x, int add)
  {
    if (r < x || x < l) return;
    if (l == r) {
      tot += add;
      return;
    }
    
    int mid = (l+r) >> 1;
    if (lef == NULL) lef = new Node(l, mid);
    if (rig == NULL) rig = new Node(mid+1, r);
    lef->ins(x, add);
    rig->ins(x, add);
    tot = lef->tot + rig->tot;
  }
} tree(0, INF);

map<int, int> inpos;
set<Seg> heap;
set<int> pot;

int n, q;

void ins(int val)
{
  int x, y, mid;
  x = heap.begin()->l; 
  y = heap.begin()->r;
  heap.erase(heap.begin());
  mid = (x+y+1)/2;
  tree.ins(mid, 1);
  pot.insert(mid);
  if (x < mid)
    heap.insert( Seg(x, mid-1) );
  if (mid < y)
    heap.insert( Seg(mid+1, y) );

  inpos[val] = mid;
}

void del(int val)
{
  int x, y, mid;
  mid = inpos[val];
  inpos.erase(val);
  pot.erase(mid);
  
  y = *pot.lower_bound(mid);
  x = *(--pot.lower_bound(mid));
  
  if (x+1 < mid)
    heap.erase( Seg(x+1, mid-1) );
  if (mid < y-1)
    heap.erase( Seg(mid+1, y-1) );
  
  heap.insert( Seg(x+1, y-1) );
  tree.ins(mid, -1);
}

void solve()
{
  heap.insert( Seg(0, n-1) );
  pot.insert(-1);
  pot.insert(n);
  
  for (int val, x, y, mid, i = 0; i < q; ++i) {
    scanf("%d", &val);
    if (val) {
      if (inpos.count(val) == 0)
	ins(val);
      else
	del(val);
    } else {
      scanf("%d%d", &x, &y);
      printf("%d\n", tree.cal(x-1, y-1));
    }
    // for (set<Seg>::iterator it = heap.begin(); it != heap.end(); ++it)
    //   printf("x, y: %d %d\n", it->l, it->r);
    // puts("-------------------");
  }
}

int main()
{
  scanf("%d%d", &n, &q);
  solve();
  return 0;
}
