#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>

using namespace std;

const int MaxN = 300020;

struct Node
{
	int pre, cur;
	Node() {}
	Node(int p, int c) : pre(p), cur(c) {}	
};

bool operator < (const Node &a, const Node &b)
{
	if(a.cur - a.pre == b.cur - b.pre)	return a.cur > b.cur;
	return a.cur - a.pre > b.cur - b.pre;	
}

map <int, int> pos, idx;
int N, Q;
int tree[MaxN];
int S[MaxN], sn;
int com[MaxN][3];
set <Node> st;

int getID(int key)
{
	return upper_bound(S, S+sn, key) - S;	
}

void update(int k, int v)
{
	while(k <= sn)
	{
		tree[k] += v;
		k += k & -k;	
	}	
}

int read(int k)
{
	int ret = 0;
	while(k)
	{
		ret += tree[k];
		k -= k & -k;
	}	
	return ret;
}

int main()
{
	cin >> N >> Q;
	for(int i=0; i<Q; i++)
	{
		scanf("%d", &com[i][0]);
		if(!com[i][0])
		{
			scanf("%d %d", &com[i][1], &com[i][2]);
			S[sn++] = com[i][1];
			S[sn++] = com[i][2];
			S[sn++] = com[i][2] + 1;	
		}	
	}	
	S[sn++] = -1;
	sort(S, S+sn);
	sn = unique(S, S+sn) - S;
	st.insert(Node(0, N+1));
	st.insert(Node(0, 0));
	idx[N+1] = -1;
	idx[0] = -2;
	pos[-1] = N+1;
	pos[-2] = 0;
	for(int i=0; i<Q; i++)
	{
		if(!com[i][0])
		{
			printf("%d\n", read(getID(com[i][2])) - read(getID(com[i][1]-1)));	
		}
		else
		{
			int id = com[i][0];
			if(pos.find(id) != pos.end())
			{
				int y = pos[id];
				pos.erase(id);
				idx.erase(y);
				map <int, int> :: iterator it = idx.upper_bound(y);
				int z = it->first;
				int x = (--it)->first;
				st.erase(Node(x, y));
				st.erase(Node(y, z));
				st.insert(Node(x, z));	
				update(getID(y), -1);
			}
			else
			{
				Node u = *st.begin();
				st.erase(u);
				int x = u.pre, z = u.cur, y = (x + z + 1) / 2;
				pos[id] = y;
				idx[y] = id;
				st.insert(Node(x, y));
				st.insert(Node(y, z));	
				update(getID(y), 1);
			}
		}	
	}
	
//	while(1);
	return 0;	
}
