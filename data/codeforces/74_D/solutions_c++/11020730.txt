#include <bits/stdc++.h>

#define	st first
#define	nd second
#define	mp make_pair
#define	pb push_back
#define	lli long long int
#define	all( gg )	gg.begin(),gg.end()
#define	foreach( gg,itit )	for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )
#define	FP( ii,aa,bb ) for( lli ii=aa;ii<=bb;ii++ )
#define	FM( ii,aa,bb ) for( lli ii=aa;ii>=bb;ii-- )
#define	debug(ccc)	cout << #ccc << " = " << ccc << endl;

#define	mod	1000000007LL

#define	orta	(bas+son)/2

using namespace std;

class	data{
	public:
		int	maxi,pre,suf,size,start,S;
		data *sol,*sag;
		data(){
			maxi = pre = suf = size = start = S = 0;
			sol = sag = NULL;
		}
		data(int k,int s=1){
			maxi = pre = suf = (1-k)*s;
			size = s;
			start = 1;
			if( k==1 )	S = s;
			else	S = 0;
			sol = sag = NULL;
		}
};

typedef	data * NOD;

void	merge( NOD x,NOD a,NOD b,int X,int Y ){
	data	A,B;
	if( a==NULL )	A = data( 0,X );
	else	A = *a;
	if( b==NULL )	B = data( 0,Y );
	else	B = *b;
	x->size = A.size+B.size;
	x->S = A.S+B.S;
	x->pre = A.pre+B.pre*(A.pre==A.size);
	x->suf = B.suf+A.suf*(B.suf==B.size);
	x->maxi = max( max( A.maxi,B.maxi ),A.suf+B.pre );
	if( x->maxi==B.maxi )	x->start = B.start+A.size;
	else if( x->maxi==A.suf+B.pre )	x->start = A.size-A.suf+1;
	else	x->start = A.start;
}
data	merge( data a,data b ){
	data t;
	t.size = a.size+b.size;
	t.S = a.S+b.S;
	t.pre = a.pre+b.pre*(a.pre==a.size);
	t.suf = b.suf+a.suf*(b.suf==b.size);
	t.maxi = max( max( a.maxi,b.maxi ),a.suf+b.pre );
	if( t.maxi==b.maxi )	t.start = b.start+a.size;
	else if( t.maxi==a.suf+b.pre )	t.start = a.size-a.suf+1;
	else	t.start = a.start;
	return	t;
}

NOD	head;

void	update( NOD x,int bas,int son,int ind,int val ){
	if( bas==son ){
		*x = data( val,1 );
		return;
	}
	if( ind<=orta ){
		if( x->sol==NULL )	x->sol = new data( 0,orta-bas+1 );
		update( x->sol,bas,orta,ind,val );
		merge( x,x->sol,x->sag,orta-bas+1,son-orta );
	}
	else{
		if( x->sag==NULL )	x->sag = new data( 0,son-orta );
		update( x->sag,orta+1,son,ind,val );
		merge( x,x->sol,x->sag,orta-bas+1,son-orta );
	}
}
data	query( NOD x,int bas,int son,int a,int b ){
	if( son<a or b<bas )	return	data( 0,0 );
	if( x==NULL )	return	data( 0,max(0,min(b,son)-max(a,bas)+1) );
	if( a<=bas and son<=b )	return	*x;
	return	merge( query( x->sol,bas,orta,a,b ),query( x->sag,orta+1,son,a,b ) );
}

int	n,q;

map<int,int>	Map;

int main(){
	ios_base::sync_with_stdio(false);
	cin >> n >> q;
	head = new data;
	head->maxi = head->pre = head->suf = head->size = n;
	head->start = 1;
	while( q-- ){
		int	x;
		cin >> x;
		if( x==0 ){
			int	y;
			cin >> x >> y;
			cout << query( head,1,n,x,y ).S << endl;
			continue;
		}
		if( Map.count( x ) ){
			update( head,1,n,Map[x],0 );
			Map.erase( x );
		}
		else{
			Map[x] = head->start+head->maxi/2;
			//cout << head->start << " " << head->maxi << endl;
			update( head,1,n,Map[x],1 );
		}
		//FP( i,1,n )	cout << query( head,1,n,i,i ).S << " ";cout << endl;
	}
}
