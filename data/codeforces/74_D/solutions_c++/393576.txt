#include <iostream>
#include <algorithm>
#include <cstdio>
#include <set>
#include <map>
#include <string.h>
using namespace std;

struct node{
	int s,t,l;
	node(int a,int b){
		s=a;
		t=b;
		l=b-a;
	};
};
bool operator <(node a,node b){
	return (a.l>b.l||a.l==b.l&&a.s>b.s);
}
set<node> q;
set<int> lst;
map<int ,int> s;
map<int ,int> p;
int n,m;

int lowbit(int k){return k&-k;}

void add(int k,int c){
	for (int i=k;i<=n;i+=lowbit(i)) s[i]+=c;
}

int query(int k){
	int p=0;
	for (int i=k;i;i-=lowbit(i))
	 if (s.find(i)!=s.end()) p+=s[i];
	return p;
}
int main(){
	int p1,p2,p3,k;
//	set<node>::iterator l1,l2;
	set<int>::iterator l1,l2;
	node now(0,0);
	scanf("%d%d",&n,&m);
	
	s.clear();
	p.clear();
	q.clear();
	lst.clear();
	lst.insert(0);
	lst.insert(n+1);
	q.insert(node(1,n));
	while (m--){
		scanf("%d",&p1);
		if (!p1){
			scanf("%d%d",&p2,&p3);
			printf("%d\n",query(p3)-query(p2-1));
		}else{
			if (p[p1]==0){
				now=*q.begin();
				k=(now.s+now.t+1)>>1;
				p[p1]=k;
				q.erase(now);
				lst.insert(k);
				add(k,1);
				if (now.s<=k-1) q.insert(node(now.s,k-1));
				if (k+1<=now.t) q.insert(node(k+1,now.t));
			}else{
				int k=p[p1];
				l1=l2=lst.find(k);
				p3=*(--l1);
				p2=*(++l2);
				if (p3+1<=k-1) q.erase(node(p3+1,k-1));
                if (k+1<=p2-1) q.erase(node(k+1,p2-1));
                if (p3+1<=p2-1) q.insert(node(p3+1,p2-1));
                lst.erase(k);
                add(k,-1);
                p[p1]=0;
			}
		}
	}
	return 0;
}
				
