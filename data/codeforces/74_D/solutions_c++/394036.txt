#include <iostream>
#include <algorithm>
#include <vector>
#include <map>
#include <set>
#include <cstdio>

#define tr(cont, it) for( typeof((cont).begin()) it = (cont).begin(); it != (cont).end(); ++it)
#define tri(cont, it, i) int i=0; for( typeof((cont).begin()) it = (cont).begin(); it != (cont).end(); ++it, ++i)
#define be(b, e, i) for(typeof(b) i=(b); i!=(e); ++i)

#define mp(a, b) make_pair(a, b)
#define pb(x) push_back(x)

#define deb if(debug) cout

const bool debug = false;

using namespace std;

typedef vector<int> vi;
typedef pair<int, int> ii;
typedef vector<ii> vii;

template<class A, class B>
ostream& operator<<(ostream &out, const pair<A, B> &p) {
    out << '[' << p.first << ", " << p.second << ']';
    return out;
}

int n;
map<int, int> t;

int sum(int k) {
    int res = 0;
    for(; k>=0; k = (k & (k+1)) - 1)
        res += t[k];
    return res;
}

void add(int k, int a) {
    for(; k<n; k = (k | (k+1)) )
        t[k] += a;
}

int main()
{
    int q;
    cin >> n >> q;

    set< ii, greater< ii > > B;
    B.insert(mp(n, 0));

    map<int, int> ves;
    map<int, pair<int, int> > pn;

    for(int i=0; i<q; ++i) {
        int p,a,b;
        scanf("%d", &p);
        if(p == 0) {
            scanf("%d%d", &a, &b);
            if(a == 1)
                printf("%d\n", sum(b-1));
            else
                printf("%d\n", sum(b-1) - sum(a-2));
        } else {
            if(ves.count(p) == 0 || ves[p] == -1) {
                int l = B.begin()->second;
                int r = B.begin()->second + B.begin()->first - 1;
                int c = (l+r+1)/2;
                deb << "ves " << c << endl;
                B.erase(B.begin());
                B.insert(mp(c-l, l));
                B.insert(mp(r-c, c+1));

                if(l>=0) pn[l-1].second = c-1;
                if(r<n) pn[r+1].first = c+1;

                ves[p] = c;
                pn[c] = mp(l,r);

                add(c, 1);
            } else {
                int c = ves[p];
                int l = pn[c].first;
                int r = pn[c].second;
                ves[p] = -1;
                deb << "UNves " << c << ' ' << l << ' ' << r << endl;
                add(c, -1);
                B.erase(mp((c-1)-l+1, l));
                B.erase(mp(r-(c+1)+1, c+1));
                B.insert(mp(r-l+1, l));
                if(l>=0) pn[l-1].second = r;
                if(r<n) pn[r+1].first = l;
            }
        }
    }

    return 0;
}