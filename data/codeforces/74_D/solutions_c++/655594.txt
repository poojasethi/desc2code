#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <queue>
#include <cstring>
using namespace std;
typedef long long ll;

pair<int, int> typedef PII;
set<int> lst;
set<int>::iterator it;
map<int, int> pos;
map<int, int> BIT;
map<int, int>::iterator Mit;
struct State {
	int first, second;
	State(){};
	State(int _fir, int _sec): first(_fir), second(_sec) {}
	inline bool operator < (const State &t)const {
		if(second - first == t.second - t.first) return first > t.first;
		return second - first > t.second - t.first;
	}
	void print() {
		printf("first = %d second = %d\n", first, second);
	}
};
set<State> myset;

int n;
void modify(int p, int del) {
	while(p <= n) {
		BIT[p] += del;
		p += p &(-p);
	}
}
int query(int p) {
	int ret = 0;
	while(p) {
		ret += BIT[p];
		p -= p & (-p);
	}
	return ret;
}
int query(int s, int t) {
	return query(t) - query(s - 1);
}
int main() {
#ifndef ONLINE_JUDGE
	freopen("./source/in", "r", stdin);
#endif
	int i, j, k;
	int q, idx, s, t;
	State cur, buf;
	scanf("%d%d", &n, &q);
	lst.insert(0);
	lst.insert(n + 1);
	myset.insert(State(1, n));
	while(q --) {
		scanf("%d", &idx);
		if(idx == 0) {
			scanf("%d%d", &s, &t);
			printf("%d\n", query(s, t));
		}else {
			if(pos[idx] == 0) {
				cur = *myset.begin();
				//cur.print();
				int mid = (cur.first + cur.second + 1) >> 1;
				if(cur.first <= mid - 1) myset.insert(State(cur.first, mid - 1));
				if(mid + 1 <= cur.second) myset.insert(State(mid + 1, cur.second));
				myset.erase(cur);

				lst.insert(mid);
				pos[idx] = mid;
				modify(mid, 1);
			}else {
				set<int>::iterator pre, nxt;
				int loc = pos[idx];
				pos[idx] = 0;
				pre = nxt = lst.find(loc);

				int s = *(-- pre), t = *(++nxt);
				if(s + 1 <= loc - 1) myset.erase(State(s + 1, loc - 1));
				if(loc + 1 <= t - 1) myset.erase(State(loc + 1, t - 1));
				if(s + 1 <= t - 1) myset.insert(State(s + 1, t - 1));
				lst.erase(loc);
				modify(loc, -1);
			}
		}
//		puts("--------------");
//		for(set<State>::iterator sit = myset.begin(); sit != myset.end(); ++sit) {
//			printf("(%d, %d)\n", sit->first, sit->second);
//		}
	}
	return 0;
}

	 	     		   		   	 		 		