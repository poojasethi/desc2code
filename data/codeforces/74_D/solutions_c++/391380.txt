#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <set>
#include <map>

#define REP(AA,BB) for(int AA=0; AA<(BB); ++AA)
#define FOR(AA,BB,CC) for(int AA=(BB); AA<(CC); ++AA)
#define FC(AA,BB) for(__typeof((AA).begin()) BB=(AA).begin(); BB!=(AA).end(); ++BB)
#define SZ(AA) ((int)((AA).size()))
#define ALL(AA) (AA).begin(), (AA).end()
#define PB push_back
#define MP make_pair

using namespace std;

typedef vector<int> VI;
typedef pair<int, int> PII;
typedef long long LL;
typedef long double LD;

vector<PII> ev;
int cnt[1000100], MX;

void add(int a, int v) {
	while(a<=MX) {
		cnt[a]+=v;
		a+=(a&(-a));
	}
}

int get(int a) {
	int res=0;
	while(a>0) {
		res+=cnt[a];
		a-=(a&(-a));
	}
	return res;
}

int main(void) {
	int n; int q; scanf("%d%d", &n, &q);
	set<PII, greater<PII> > S;
	map<int, int> cur; set<int> zaj;
	S.insert(MP(n,1)); zaj.insert(0); zaj.insert(n+1);
	REP(i,q) {
		int x; scanf("%d", &x);
		if(x==0) {
			int a, b; scanf("%d%d", &a, &b);
			ev.PB(MP(a,b));
		}
		else {
			if(cur.find(x)==cur.end()) {
				int len=S.begin()->first;
				int y=S.begin()->second;
				int mid=y+(len/2);
				S.erase(S.begin());
				if(mid>y)
					S.insert(MP(mid-y,y));
				if(mid<y+len-1)
					S.insert(MP(y+len-1-mid,mid+1));
				ev.PB(MP(0,mid));
				cur[x]=mid; zaj.insert(mid);
				//printf("wiesza %d na %d\n", x, mid);
			}
			else {
				int g=cur[x]; ev.PB(MP(-1,g));
				set<int>::iterator it=zaj.find(g), jt=it, kt=it;
				--jt; ++kt;
				if(*jt<g-1)
					S.erase(MP(g-(*jt+1), *jt+1));
				if(*kt>g+1)
					S.erase(MP((*kt)-g-1, g+1));
				S.insert(MP((*kt)-(*jt)-1, (*jt)+1));
				zaj.erase(g); cur.erase(x);
				//printf("zdejmuje %d na %d\n", x, g);
			}
		}
	}
	map<int, int> ma;
	REP(i,SZ(ev)) {
		if(ev[i].first>0)
			ma[ev[i].first]=1;
		ma[ev[i].second]=1;
	}
	int M=1;
	FC(ma,it)
		ma[it->first]=M++;
	MX=M+1;
	REP(i,SZ(ev)) {
		if(ev[i].first==0)
			add(ma[ev[i].second], 1);
		else if(ev[i].first==-1)
			add(ma[ev[i].second], -1);
		else
			printf("%d\n", get(ma[ev[i].second])-get(ma[ev[i].first]-1));
	}
	return 0;
}
				
				
