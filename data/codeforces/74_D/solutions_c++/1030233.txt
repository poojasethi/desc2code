#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<map>
#include<set>
using namespace std;
struct Node{
        int st,ed; 
        Node(){} 
        Node(int _st,int _ed ):st(_st),ed(_ed){}
}now; 
inline bool operator <( const Node &a, const Node &b ){
        if(a.ed-a.st!=b.ed-b.st)return a.ed-a.st>b.ed-b.st;
        return a.st>b.st;
}
set<Node>q;
set<int>po;
set<int>::iterator it,jt;
map<int,int>BIT,pos;
int n,m,x,a,b;
void add(int x,int k)
{
    for(int i=x;i<=n;i+=i&-i)BIT[i]+=k;
} 
int Q(int x)
{
    int i=x,v=0; 
    for(;i;i-=i&-i) 
        if(BIT.find(i)!=BIT.end())v+=BIT[i]; 
    return v;
}
int Q(int a,int b)
{
    return Q(b)-Q(a-1);
}
int main()
{
    scanf("%d%d",&n,&m);
    q.insert(Node(1,n));
    po.insert(0);
    po.insert(n+1);
    for(;m;--m)
    {
        scanf("%d",&x); 
        if(!x)
        {
            scanf("%d%d",&a,&b); 
            printf("%d\n",Q(a,b)); 
        }
        else
        {
            if(!pos[x])
            {
                now=*q.begin();
                q.erase(now);
                int mid=(now.st+now.ed+1)/2;
                pos[x]=mid;
                po.insert(mid);
                add(mid,1);
                if(now.st<mid)q.insert(Node(now.st,mid-1));
                if(mid+1<=now.ed)q.insert(Node(mid+1,now.ed));
            }
            else
            {
                int pre,mid,nxt;
                mid=pos[x];
                it=jt=po.find(mid);
                pre=*--it;
                nxt=*++jt;
                if(pre+1<=mid-1)q.erase(Node(pre+1,mid-1)); 
                if(mid+1<=nxt-1)q.erase(Node(mid+1,nxt-1)); 
                if(pre+1<=nxt-1)q.insert(Node(pre+1,nxt-1)); 
                po.erase(mid);
                add(mid,-1); 
                pos[x]=0;        
            }
        } 
    }
    return 0; 
}
