#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>

using namespace std;

const int MaxN = 300020;

struct Node
{
	int cur, pre, nxt;
	Node() {}
	Node(int c, int p, int n) : cur(c), pre(p), nxt(n) {}	
};

bool operator < (const Node &a, const Node &b)
{
	if(a.cur - a.pre == b.cur - b.pre)	return a.cur > b.cur;
	return a.cur - a.pre > b.cur - b.pre;	
}

map <int, int> pos_to_id;
map <int, Node> id_to_pos;
int N, Q;
int tree[MaxN];
int S[MaxN], sn;
int com[MaxN][3];
set <Node> st;

int getID(int key)
{
	return upper_bound(S, S+sn, key) - S;	
}

void update(int k, int v)
{
	while(k <= sn)
	{
		tree[k] += v;
		k += k & -k;	
	}	
}

int read(int k)
{
	int ret = 0;
	while(k)
	{
		ret += tree[k];
		k -= k & -k;
	}	
	return ret;
}

int main()
{
	cin >> N >> Q;
	for(int i=0; i<Q; i++)
	{
		scanf("%d", &com[i][0]);
		if(!com[i][0])
		{
			scanf("%d %d", &com[i][1], &com[i][2]);
			S[sn++] = com[i][1];
			S[sn++] = com[i][2];
			S[sn++] = com[i][2] + 1;	
		}	
	}	
	S[sn++] = -1;
	sort(S, S+sn);
	sn = unique(S, S+sn) - S;
	st.insert(Node(N+1, 0, N+1));
	st.insert(Node(0, 0, N+1));
	pos_to_id[0] = -1;
	pos_to_id[N+1] = -2;
	id_to_pos[-1] = Node(0, 0, N+1);
	id_to_pos[-2] = Node(N+1, 0, N+1);
	for(int i=0; i<Q; i++)
	{
		if(!com[i][0])
		{
			printf("%d\n", read(getID(com[i][2])) - read(getID(com[i][1]-1)));	
		}
		else
		{
			if(id_to_pos.find(com[i][0]) != id_to_pos.end())
			{
				Node u = id_to_pos[com[i][0]];
				update(getID(u.cur), -1);
				id_to_pos.erase(com[i][0]);
				pos_to_id.erase(u.cur);
				st.erase(u);
				st.erase(id_to_pos[pos_to_id[u.pre]]);
				st.erase(id_to_pos[pos_to_id[u.nxt]]);
				id_to_pos[pos_to_id[u.pre]].nxt = u.nxt;
				id_to_pos[pos_to_id[u.nxt]].pre = u.pre;
				st.insert(id_to_pos[pos_to_id[u.pre]]);
				st.insert(id_to_pos[pos_to_id[u.nxt]]);
			}
			else
			{
				Node u = *st.begin();
				st.erase(u);
				st.erase(id_to_pos[pos_to_id[u.pre]]);
				Node v = Node((u.pre+u.cur+1)/2, u.pre, u.cur);
				update(getID(v.cur), 1);
				st.insert(v);
				id_to_pos[com[i][0]] = v;
				pos_to_id[v.cur] = com[i][0];
				id_to_pos[pos_to_id[v.pre]].nxt = v.cur;
				st.insert(id_to_pos[pos_to_id[v.pre]]);
				id_to_pos[pos_to_id[v.nxt]].pre = v.cur;
				st.insert(id_to_pos[pos_to_id[v.nxt]]);
			}	
		}	
	}
	
//	while(1);
	return 0;	
}
