import sys
from heapq import *
from random import random,seed
seed(7)
class Treap(object):
    def __init__(self,N):
        N+=1
        self.l = [0]*N
        self.r = [0]*N
        self.h = [0.]*N
        self.k = [0]*N
        self.n = [0]*N
	self.st = [0]*N
	self.sttop = 0
        self.top = 1
        self.root = 0
    def __trace(self,t):
        if not t: return "[]"
        return "[id=%d k=%d h=%.5f n=%d l=%s r=%s]"%(t,self.k[t],self.h[t],self.n[t],self.__trace(self.l[t]),self.__trace(self.r[t]))
    def __str__(self):
        return self.__trace(self.root)
    def update(self,t):	
	if not t: return
	self.n[t]=1+self.n[self.l[t]]+self.n[self.r[t]]
    def split(self,t,key):
	r,l=0,0		
	ll,rr,nn,kk=self.l,self.r,self.n,self.k
	st = self.st;top=self.sttop
	while t:
	    st[top]=t;top+=1	    
	    if key<kk[t]: ll[r]=t;r=t;t=ll[r]
	    else: rr[l]=t;l=t;t=rr[l]
	rr[l]=ll[r]=0
	self.sttop=top
	return rr[0],ll[0]
    def merge(self,t,l,r):
	if not l or not r: t = l or r
	elif self.h[l]>self.h[r]: self.r[l] = self.merge(self.r[l],self.r[l],r); t=l
	else: self.l[r]=self.merge(self.l[r],l,self.l[r]); t=r
	self.update(t)
	return t
    def __insert(self,t,it):
	if not t: return it
	p=0;st = self.st;top=0
	ll,rr,nn,kk=self.l,self.r,self.n,self.k
	ki=kk[it]
	while t and self.h[it]<=self.h[t]:
	    p = t;st[top]=t;top+=1
	    t = ll[t] if ki<kk[t] else rr[t]
	if p:
	    if ki<kk[p]:ll[p]=it
	    else: rr[p]=it
	else: self.root=it
	st[top]=it;top+=1;self.sttop=top	
	ll[it],rr[it]=self.split(t,ki)
	for t in xrange(self.sttop-1,-1,-1): tt=st[t];nn[tt]=1+nn[ll[tt]]+nn[rr[tt]]
	return self.root
    def insert(self,k):
	self.k[self.top]=k
	self.h[self.top]=random()
	self.root = self.__insert(self.root,self.top)
	self.top+=1
    def __remove(self,t,key):
	if self.k[t]==key: t=self.merge(t,self.l[t],self.r[t]);
	else:
	    if key<self.k[t]: self.l[t]=self.__remove(self.l[t],key)
	    else: self.r[t]=self.__remove(self.r[t],key)
	self.update(t)
	return t
    def remove(self,key):
	self.root = self.__remove(self.root,key)
    def count(self,key):
	r,t = 0,self.root
	while t:
	    if self.k[t]<=key:
		r += self.n[self.l[t]]+1
		t = self.r[t]
	    else:
		t = self.l[t]
	return r
    
n,q = map(int,raw_input().split())
rl = sys.stdin.readline
z = {}
l = {}
r = {}
t = Treap(q)
h = []
qq = 2*q+2
a = [True]*qq
b,e = [0]*qq,[0]*qq
ac = 0
def add(bb,ee):
    global b,e,h,ac
    if bb>=ee:
	l[ee]=r[bb-1]=0
	return
    b[ac]=bb
    e[ac]=ee
    r[bb-1]=l[ee]=ac
    heappush(h,(bb-ee,-ee,bb,ac))
    ac+=1
add (1,n+1)
for _ in xrange(q):
    p = rl()
    if p[0]=='0':
	_,i,j = map(int,p.split())
	print t.count(j)-t.count(i-1)
    else:
	i = int(p)
	if i in z:
	    m = z[i]
	    a[l[m]]=a[r[m]]=False
	    bb=b[l[m]] if l[m] else m
	    ee=e[r[m]] if r[m] else m+1
	    add(bb,ee)
	    t.remove(m)	    
	    del z[i]
	else:
	    while 1:
		_,ee,bb,n = heappop(h)
		if a[n]: break
	    m = (-ee+bb)/2
	    add(bb,m)
	    add(m+1,-ee)
	    z[i] = m
	    t.insert(m)