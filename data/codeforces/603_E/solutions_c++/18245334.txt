#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <vector>

#define PB push_back
#define VE std::vector<Edge>

#define REP(i, x, y) for (int i = x, _ = y; i <= _; ++ i)
#define rep(i, x, y) for (int i = x, _ = y; i >= _; -- i)

template <typename T> bool Chkmax(T &x, T y) { return x < y? x = y, true : false; }
template <typename T> bool Chkmin(T &x, T y) { return y < x? x = y, true : false; }

const int MAXN = 1e5 + 1e4, MAXM = 3e5 + 3e4, oo = 0x3f3f3f3f;

int n, m;
int ans[MAXM];

struct Edge
{
    int u, v, w, id;
    Edge() {}
    Edge(int u, int v, int w, int id):
        u(u), v(v), w(w), id(id) {}
    inline int Diff(int x)
    {
        if (u == x)
            return v;
        else if (v == x)
            return u;
        else
            return -1;
    }
    inline bool operator < (const Edge &e) const { return w < e.w; }
} G[MAXM];

struct Status
{
    int *pos, val;
    Status() {}
    Status(int *pos, int val): // get a new way to cancel the operation in Union-Find-Set.
        pos(pos), val(val) {}
    Status(int *pos):
        pos(pos), val(*pos) {}
    inline void Exec() { (*pos) = val; }
} st[MAXM * 5];

int sumodd;
int top;
int fa[MAXN];
int rank[MAXN];
int size[MAXN];

int Find(int x) { return x == fa[x]? x : Find(fa[x]); }

void Union(int u, int v)
{
    u = Find(u), v = Find(v);
    if (u == v)
        return ;
    
    if (rank[u] < rank[v])
        std::swap(u, v);
    if (rank[u] == rank[v]) {
        st[++ top] = Status(&rank[u]);
        ++ rank[u];
    }

    st[++ top] = Status(&fa[v]);
    st[++ top] = Status(&size[u]);
    if ((size[u] & 1) && (size[v] & 1)) {
	st[++ top] = Status(&sumodd);
	sumodd -= 2;
    }
    
    fa[v] = u;
    //printf("%d\n", sumodd);
    size[u] += size[v];
}

void Exec(int L, int R, int minans, int maxans, VE &E)
{
    if (L > R)
        return ;

    VE next;
    int M = (L + R) / 2, fr = top;
    ans[M] = maxans;
    for (int i = 0; i < E.size(); ++ i) {
        Edge &e = E[i];
        if (e.id < L && e.w < minans)
            Union(e.u, e.v);
        else if (e.id <= R && e.w < maxans)
            next.PB(e);
    }

    int back = top;
    for (int i = 0; i < E.size(); ++ i) {
        Edge &e = E[i];
        if (e.id <= M) {
            Union(e.u, e.v);
            if (sumodd == 0) {
                ans[M] = e.w;
                break;
            }
        }
    }

    rep (i, top, back + 1)
        st[i].Exec();
    top = back;

    Exec(L, M - 1, ans[M], maxans, next);
    Exec(M + 1, R, minans, ans[M], next);

    rep (i, top, fr + 1)
        st[i].Exec();
    top = fr;
}

VE edges;

void Solve()
{
    sumodd = n;
    REP (i, 1, n) {
        fa[i] = i;
        size[i] = 1; // don't forget this.
    }
    std::sort(edges.begin(), edges.end());
    Exec(1, m, 0, oo, edges);
    REP (i, 1, m) {
        printf("%d\n", ans[i] == oo? -1 : ans[i]);
    }
}

void Input()
{
    int u, v, w;
    scanf("%d%d", &n, &m);
    REP (i, 1, m) {
        scanf("%d%d%d", &u, &v, &w);
        edges.PB(Edge(u, v, w, i));
    }
}

int main()
{
    if (fopen("E.in", "r") != NULL) {
        freopen("E.in", "r", stdin);
        freopen("E.out", "w", stdout);
    }

    Input();
    Solve();

    return 0;
}
