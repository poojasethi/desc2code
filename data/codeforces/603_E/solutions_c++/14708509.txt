#include <bits/stdc++.h>

using namespace std;

#define lol long long
#define fi first
#define se second
#define pb push_back
#define sz(s) (lol)s.size()
#define must ios_base::sync_with_stdio(0)

#define inp(s) freopen(s, "r", stdin)
#define out(s) freopen(s, "w", stdout)

struct edge {
  int a, b, l, t;
  bool operator<(const edge e) const {
    return l != e.l ? l < e.l : t < e.t;
  }
};

struct node {
  int p, q;
  node() : p(-1), q(1) {}
};

const int MAXN = 100005;
const int MAXM = 300005;
int N, M, res[MAXM], ok;
edge E[MAXM], F[MAXM];

node n[MAXN];
stack<pair<node&,node> > ch;

int find(int a){
  if(n[a].p < 0) return a;
  ch.push({n[a], n[a]});
  n[a].p = find(n[a].p);
  return n[a].p;
}

void join(int a, int b){
  int u = find(a);
  int v = find(b);
  if(u == v) return;
  if(u > v) swap(u, v);
  ch.push({n[u], n[u]});
  ch.push({n[v], n[v]});
  n[u].p = v;
  n[v].q ^= n[u].q;
  ok += 2 * (!n[v].q && n[u].q);
}

void rollback(int t, int o){
  ok = o;
  for( ; ch.size() > t; ch.pop()){
    ch.top().first = ch.top().second;
  }
}

void solve(int l, int r, int lo){
  if(l >= r) return;
  int t = ch.size(), o = ok;
  int m = (l + r) / 2, k = lo;
  for(int i = l; i <= m; i++){
    if(E[i] < F[lo]) join(E[i].a, E[i].b);
  }
  solve(m + 1, r, lo);
  for( ; k < M; k++){
    if(F[k].t <= m) join(F[k].a, F[k].b);
    if(ok == N) break;
  }
  rollback(t, o);
  for(int i = lo; i <= k; i++){
    if(F[i].t < l) join(F[i].a, F[i].b);
  }
  solve(l, m, k);
  rollback(t, o);
  res[m] = F[k].l;
}

int main(){
  //inp("input.txt");
  scanf("%d %d", &N, &M);
  for(int i = 0; i < M; i++){
    int a, b, l;
    scanf("%d %d %d", &a, &b, &l);
    a -= 1, b -= 1;
    E[i] = {a, b, l, i};
    F[i] = {a, b, l, i};
  }
  F[M].l = -1;
  sort(F, F + M);
  solve(0, M, 0);
  for(int i = 0; i < M; i++){
    printf("%d\n", res[i]);
  }
}
