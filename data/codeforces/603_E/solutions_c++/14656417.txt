#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#define L(__) (son[__][0])
#define R(__) (son[__][1])
#define N 500005
#define PAIR pair<int,int>
#define LL long long
#define oo (1<<30)
#define TAT "%I64d"
using namespace std;
set<PAIR> S; set<PAIR> :: iterator it;
int n,m,a[N],f[N],son[N][2],Max[N],rev[N],w[N],lw,u[N],v[N],d[N],size[N],sum[N],cnt;
bool ok(int x){ return L(f[x])==x||R(f[x])==x;}
void update(int x)
{
    Max[x]=x,size[x]=(x<=n);
    if(a[Max[L(x)]]>a[Max[x]]) Max[x]=Max[L(x)];
    if(a[Max[R(x)]]>a[Max[x]]) Max[x]=Max[R(x)];
    size[x]+=size[L(x)]+size[R(x)]+sum[x];
}
void rot(int x){ swap(son[x][0],son[x][1]),rev[x]^=1;}
void push(int x)
{
    if(!rev[x]) return ;
    rot(L(x)),rot(R(x));
    rev[x]=0;
}
void rotate(int x)
{
    int fa=f[x],ff=f[fa],s,k=0;
    if(L(fa)==x) k=1; s=son[x][k],f[x]=ff;
    f[fa]=x,son[x][k]=fa,f[s]=fa,son[fa][k^1]=s;
    if(L(ff)==fa) son[ff][0]=x;
    else if(R(ff)==fa) son[ff][1]=x;
    update(fa),update(x);
}
void splay(int x)
{
    int i; lw=0;
    for(i=x;i;i=f[i]){
        w[++lw]=i;
        if(!ok(i)) break;
      }
    for(i=lw;i>=1;i--)
        push(w[i]);
    while(ok(x)) rotate(x);
}
int access(int x)
{
    int v=0;
    while(x){
        splay(x);
        sum[x]+=size[R(x)];
        sum[x]-=size[v];
        son[x][1]=v;
        update(x);
        v=x,x=f[x];
      }
    return v;
}
void evert(int x)
{
    access(x),splay(x),rot(x);
}
void link(int x,int y)
{
    evert(x),splay(x);
    f[x]=y,sum[y]+=size[x];
}
void cut(int x,int y)
{
    evert(x),access(y),splay(x);
    son[x][1]=f[y]=0, update(x);
}
int path(int x,int y)
{
    evert(x),access(y),splay(x);
    return Max[x];
}
int find(int x)
{
    access(x);
    splay(x);
    while(L(x)) x=L(x);
    return x;
}
void Link(int t)
{
    link(u[t],t+n);
    link(v[t],t+n);
    S.insert(PAIR(-a[t+n],t+n));
}
void Cut(int t)
{
    cut(u[t],t+n);
    cut(v[t],t+n);
    S.erase(PAIR(-a[t+n],t+n));
}
int SZ(int t)
{
    evert(t);
    return size[t];
}
bool Can(int t)
{
    Cut(t);
    if((SZ(u[t])&1)&&(SZ(v[t])&1)){
        Link(t); return false;
      }
    return true;
}
void Insert(int t)
{
    int zlr; a[t+n]=d[t];
    if(find(u[t])!=find(v[t])){
        if((SZ(u[t])&1)&&(SZ(v[t])&1)) cnt-=2;
        Link(t);
      }
    else{
        zlr=path(u[t],v[t])-n;
        if(d[zlr]>d[t])
        Cut(zlr),Link(t);
      }
    if(cnt){ printf("-1\n"); return ;}
    while(S.begin()!=S.end()){
        zlr = (*(S.begin())).second-n;
        if(!Can(zlr)) break;
      }
    zlr=-(*(S.begin())).first;
    printf("%d\n",zlr);
}
int main()
{
    int i;
    scanf("%d %d",&n,&m), cnt=n;
    for(i=1;i<=n;i++) size[i]=1;
    for(i=1;i<=m;i++){
        scanf("%d %d %d",&u[i],&v[i],&d[i]);
        Insert(i);
      }
    return 0;
}
