#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=100000+10;
const int maxm=200000+10;
struct Edge{
	int u,v;
	Edge(){}
	Edge(int u,int v): u(u),v(v){}
}e[maxn];
int n,odd,m;
int rub[maxn],rtop;
struct Heap{
    int q[maxn],num[maxn],back[maxn];
    int sz;
    inline void ex(int l,int r)
    {
        swap(q[l],q[r]);
		swap(back[l],back[r]);
        num[back[l]]=l;
		num[back[r]]=r;
    }
    inline void up(int now)
    {
		int next;
        while (now>1)
		{
			next=now>>1;
            if (q[now]<=q[next])
                break;
            ex(now,next);
            now=next;
		}
    }
    inline void down(int now)
    {
        while ((now<<1)<=sz)
		{
			int next=now<<1;
			if (next<sz&&q[next+1]>q[next])
                next++;
            if (q[now]>=q[next])
                break;
			ex(now,next);
			now=next; 
		}
    }
    inline void add(int x,int v)
    {
        q[++sz]=v;
		num[x]=sz;
		back[sz]=x;
		up(sz);
    }
    inline void del(int x)
    {
        int pos=num[x];
		ex(pos,sz--);
		down(pos),up(pos);
    }
}h;
struct LCT{
    int q[maxm],MAX[maxm];
    int sz[maxm],nsz[maxm];
    int st[maxn],top;
    int f[maxm],ch[maxm][2],rev[maxm];
    #define loc(x) (ch[f[x]][1]==x)
    void set(int x,int l,int c)
    {
        ch[x][l]=c;
        if (c)
            f[c]=x;
    }
    void push_up(int x)
    {
        MAX[x]=x;
        sz[x]=nsz[x]+(x<=n);
        for (int i=0;i<2;i++)
        {
            if (ch[x][i]&&q[MAX[ch[x][i]]]>q[MAX[x]])
                MAX[x]=MAX[ch[x][i]];
            sz[x]+=sz[ch[x][i]];
        }
    }
    void down(int x)
    {
        if (rev[x])
        {
            for (int i=0;i<2;i++)
                if (ch[x][i])
                    rev[ch[x][i]]^=1;
            swap(ch[x][0],ch[x][1]);
            rev[x]=0;
        }
    }
    inline bool isroot(int x)
	{
		return ch[f[x]][0]!=x&&ch[f[x]][1]!=x;
	}
    void rotate(int x)
    {
        int fa=f[x],ff=f[fa],l=loc(x);
        if (!isroot(fa))
            set(ff,loc(fa),x);
        f[x]=ff;
        set(fa,l,ch[x][l^1]);
        set(x,l^1,fa);
        push_up(fa);
    }
    void splay(int x)
    {
        st[top=1]=x;
        for (int px=x;!isroot(px);px=f[px])
            st[++top]=f[px];
        for (;top;top--)
            down(st[top]);
        while (!isroot(x))
        {
            int fa=f[x];
            if (!isroot(fa))
            {
                if (loc(x)==loc(fa))
                    rotate(fa);
                else
                    rotate(x);
            }
            rotate(x);
        }
        push_up(x);
    }
    void access(int x)
    {
        splay(x);
		nsz[x]+=sz[ch[x][1]];
		ch[x][1]=0;
        for (;f[x];) 
		{
            int u=f[x];
			splay(u);
            nsz[u]-=sz[x];
			nsz[u]+=sz[ch[u][1]];
            set(u,1,x);
			push_up(u);
            splay(x=u); 
		}
    }
    void beroot(int x)
    {
        access(x);
		splay(x);
		rev[x]^=1;
    }
    int root(int x)
    {
        access(x);
		splay(x);
        while (ch[x][0])
            x=ch[x][0];
        return x;
    }
    void cut(int loc,int x,int y)
    {
        beroot(loc); h.del(loc-n); rub[++rtop]=loc;
        access(x); splay(loc); f[ch[loc][1]]=0; ch[loc][1]=0;
        access(y); splay(loc); f[ch[loc][1]]=0; ch[loc][1]=0;
        access(x); splay(x);
        access(y); splay(y);
        if ((sz[x]&1)&&(sz[y]&1))
			odd+=2;
    }
    void link(int loc,int x,int y,int k)
    {
        access(x);splay(x);access(y);splay(y);
        if ((sz[x]&1)&&(sz[y]&1))
            odd-=2;
        q[loc]=k;
		e[loc-n]=Edge(x,y);
        h.add(loc-n,k);
        beroot(x);f[x]=loc;nsz[loc]+=sz[x];
        beroot(y);f[y]=loc;nsz[loc]+=sz[y];
    }
    void check(int x,int y,int k)
    {
        if (root(x)!=root(y))
        {
            beroot(x); beroot(y);
            link(rub[rtop--],x,y,k);
        }
        else
        {
            beroot(x); access(y); splay(y);
            int loc=MAX[y];
            if (q[loc]>k)
            {
                cut(loc,x,y);
                link(rub[rtop--],x,y,k);
            }
        }
    }
}tree;
inline int read()
{
    int x=0;
    char ch=getchar();
    while (ch<'0'||ch>'9')
        ch=getchar();
    while (ch>='0'&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x;
}
inline int solve()
{
    int loc;
    while (!odd)
    {
        loc=h.back[1];
        tree.cut(loc+n,e[loc].u,e[loc].v);
    }
    tree.link(rub[rtop--],e[loc].u,e[loc].v,h.q[h.num[loc]]);
    return h.q[h.num[loc]];
}
int main()
{
    odd=n=read();
	m=read();
    for (int i=1;i<=n;i++)
    {
        rub[++rtop]=n+i;
        tree.sz[i]=1;
    }
    for (int i=1,u,v,w;i<=m;i++)
    {
        u=read(),v=read(),w=read();
        tree.check(u,v,w);
        if (odd==0)
            printf("%d\n",solve());
        else
            puts("-1");
    }
    return 0;
}
	 		 		 		   		  		 			 	   	 	