#include <bits/stdc++.h>
using namespace std;

#define fru(j,n) for(int j=0; j<(n); ++j)
#define tr(it,v) for(typeof((v).begin()) it=(v).begin(); it!=(v).end(); ++it)
#define x first
#define y second
#define pb push_back
#define ALL(G) (G).begin(),(G).end()

typedef long long ll;
typedef double D;
typedef pair<int,int> pii;
typedef vector<int> vi;

const int inft = 1000000009;
const int MAXM = 300006;//10^6

int ans[MAXM];
#define cost x.x
#define nr x.y
#define va y.x
#define vb y.y
typedef pair<pii,pii> edge;
edge E[MAXM],E2[MAXM];

int REP[MAXM];
int par[MAXM];
int bad; //ile skladowych jest parzystych
int siz[MAXM];

vector<pair<int*,int> > hist; //adres, wartosc przed zmiana

void ustaw(int &gdzie,int co){
	if(gdzie!=co){
		hist.pb(make_pair(&gdzie,gdzie));
		gdzie=co;
	}
}

int find(int x){
	if(REP[x]!=x) ustaw(REP[x],find(REP[x])); //log!
	return REP[x];
}
void onion(int a,int b){ //czy scalam
	a=find(a);
	b=find(b);
	if(a==b) return;
	if(siz[a]<siz[b]) swap(a,b); //b do a
	ustaw(siz[a],siz[a]+siz[b]);
	if(par[b] && par[a]) ustaw(bad,bad-2);
	ustaw(par[a],par[a]^par[b]);
	ustaw(REP[b],a);
}
void cofnij(int h){
	while(hist.size()>h) {
		*(hist.back().x)=hist.back().y;
		hist.pop_back();
	}
}
int n;
void go(int l,int r,int lo,int hi){
	if(l>r) return;
//	printf("wchodze w (%d,%d,%d,%d) i teraz:\n",l,r,lo,hi);	fru(i,n) printf("%d-- %d, %d\n",i,find(i),par[find(i)]);
	//krawedzie < lo dla zapytan < l sa juz dodane
	int h=hist.size();
	//zapamietaj
	int m=(l+r)/2;
	int last=lo;
//	printf("teraz m = %d\n",m);
	for(int i=l;i<=m;++i) if(E2[i].cost<=E[lo].cost) onion(E2[i].va,E2[i].vb);
	for(int i=lo;i<=hi && bad;++i) if(E[i].nr<=m){
//		printf("teraz dodaje krawedz %d\n",i);
		onion(E[i].va,E[i].vb);
		last=i;
	}
	if(bad==0){ //dalo sie zrobic
		cofnij(h);
		ans[m]=E[last].cost;
//		printf("ans[%d] = %d (lat = %d)\n",m,ans[m],last);

		for(int i=l;i<=m;++i) if(E2[i].cost<=E[lo].cost) onion(E2[i].va,E2[i].vb);
		go(m+1,r,lo,last); //prawa strona
		cofnij(h);

		for(int i=lo;i<=last;++i) if(E[i].nr<=l) {
//			printf("%d %d %d %d:: teraz dodaje krawedz %d %d\n",l,r,lo,hi,E[i].va+1,E[i].vb+1);
			onion(E[i].va,E[i].vb);
		}
		go(l,m-1,last,hi); //lewa
		cofnij(h);
	}
	else{//nie da sie dla m zrobic
//		printf("bad = %d\n",bad);
		for(int i=l;i<=m;++i) {
			ans[i]=-1;
//			printf("ans[%d] = -1\n",i);
		}
		cofnij(h);
		for(int i=l;i<=m+1;++i) if(E2[i].cost<=E[lo].cost) onion(E2[i].va,E2[i].vb);
		go(m+1,r,lo,hi);
		cofnij(h);
	}
}
int main(){
	int m;
	scanf("%d%d",&n,&m);
	fru(i,m){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		--a;--b;
		E[i]=edge(pii(c,i),pii(a,b));
		E2[i]=E[i];
	}
	bad=n;
	fru(i,n) par[i]=1;
	fru(i,n) REP[i]=i;
	fru(i,n) siz[i]=1;
	sort(E,E+m);
	go(0,m-1,0,m-1);
	fru(i,m) printf("%d\n",ans[i]);
	return 0;
}
