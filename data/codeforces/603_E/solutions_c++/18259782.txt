#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <math.h>
#include <queue>
using namespace std;
const int maxn=400010;
int n,m,v[maxn],poi[maxn];
struct hh
{
    int fr,to,v;
}seg[maxn];
struct wtf
{int v,id;};
bool operator < (const wtf &a,const wtf &b)
{return a.v<b.v;}
struct wtf_queue
{
    priority_queue<wtf>heap;
    int del[maxn];
    void pop()
    {heap.pop();}
    void push(wtf x)
    {heap.push(x);}
    wtf top()
    {
        while(del[heap.top().id]==1)
            heap.pop();
        return heap.top();
    }
}mashiro;
int fa[maxn],mp[maxn],son[maxn][2],flip[maxn],sz[maxn],ex[maxn];
int st[maxn],top;
void print(int x)
{
    printf("%d: sz=%d ex=%d fa=%d son=(%d,%d)\n",x,sz[x],ex[x],fa[x],son[x][0],son[x][1]);
}
void zqf(int x)
{
    for(int i=1;i<=n+x;i++)
        print(i);
    printf("\n");
}
int isroot(int x)
{return (son[fa[x]][0]!=x)&&(son[fa[x]][1]!=x);}
int cmp(int a,int b)
{return v[a]>v[b]?a:b;}
void pushdown(int x)
{
    if(flip[x]==1)
    {
        swap(son[x][0],son[x][1]);
        flip[son[x][0]]^=1;
        flip[son[x][1]]^=1;
        flip[x]=0;
    }
}
void maintain(int x)
{
    mp[x]=cmp(x,cmp(mp[son[x][0]],mp[son[x][1]]));
    sz[x]=sz[son[x][0]]+sz[son[x][1]]+poi[x]+ex[x];
}
void rotate(int x,int d)
{
    int fx=fa[x],gfx=fa[fx];
    if(isroot(fx)==0)
        son[gfx][son[gfx][1]==fx]=x;
    fa[x]=gfx;
    fa[fx]=x;
    fa[son[x][d]]=fx;
    son[fx][d^1]=son[x][d];
    son[x][d]=fx;
    maintain(fx);
    maintain(x);
}
void splay_to_root(int x)
{
    top=0;
    st[++top]=x;
    for(int i=x;isroot(i)==0;i=fa[i])
        st[++top]=fa[i];
    while(top>0)
        pushdown(st[top--]);
    while(isroot(x)==0)
    {
        int &fx=fa[x];
        if(isroot(fx)==0)
        {
            int &gfx=fa[fx];
            if(((son[gfx][0]==fx)^(son[fx][0]==x))==1)
                rotate(x,son[fx][0]==x);
            else
                rotate(fx,son[gfx][0]==fx);
        }
        rotate(x,son[fx][0]==x);
    }
}
void access(int x)
{
    int fx=x;
    x=0;
    while(fx!=0)
    {
        splay_to_root(fx);
        ex[fx]=ex[fx]+sz[son[fx][1]]-sz[x];
        son[fx][1]=x;
        maintain(fx);
        x=fx;
        fx=fa[fx];
    }
}
void makeroot(int x)
{
    access(x);
    splay_to_root(x);
    flip[x]^=1;
}
int linked(int a,int b)
{
    makeroot(a);
    access(b);
    splay_to_root(b);
    return isroot(a)==0;
}
void link(int a,int b)
{
    makeroot(a);
    fa[a]=b;
    ex[b]+=sz[a];
}
void cut(int a,int b)
{
    makeroot(a);
//zqf(3);
    access(b);
//    zqf(3);
    splay_to_root(b);
//    zqf(3);
    son[b][0]=fa[a]=0;
    maintain(b);
}
int query(int a,int b)
{
    makeroot(a);
    access(b);
    splay_to_root(b);
    return mp[b];
}
int size(int x)
{
    access(x);
    return sz[x];
}
int main()
{
#ifdef sherco
    freopen("wtf.txt","r",stdin);
    freopen("a.txt","w",stdout);
#endif
    scanf("%d%d",&n,&m);
    int odd=n;
    for(int i=1;i<=n;i++)
        sz[i]=poi[i]=1;
    for(int i=1;i<=m;i++)
    {
        int fr,to,co;
        scanf("%d%d%d",&fr,&to,&co);
        seg[i]=(hh){fr,to,co};
        v[n+i]=co;
        if(linked(fr,to)==0)
        {
            link(fr,i+n);
            link(to,i+n);
            makeroot(i+n);
            if(size(fr)%2==1&&size(to)%2==1)
                odd-=2;
            mashiro.push((wtf){v[n+i],i});
        }
        else
        {
            int p=query(fr,to);
//            zqf(i);
            if(v[p]>co)
            {
                cut(seg[p-n].fr,p);
                // zqf(i);
                cut(seg[p-n].to,p);
                mashiro.del[p-n]=1;
                link(fr,i+n);
                link(to,i+n);
                mashiro.push((wtf){v[n+i],i});
            }
        }
        // zqf(i);
        if(odd==0)
        {
            while(1)
            {
                int p=mashiro.top().id;
                makeroot(p+n);
                if(size(seg[p].fr)%2==0&&size(seg[p].to)%2==0)
                {
                    cut(seg[p].fr,p+n);
                    cut(seg[p].to,p+n);
                    mashiro.del[p]=1;
                }
                else
                    break;
            }
            printf("%d\n",mashiro.top().v);
        }
        else
            printf("-1\n");
        // zqf(i);
    }
    return 0;
}

                          