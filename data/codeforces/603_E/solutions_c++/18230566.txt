#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
inline int read()
{
    int x=0;
    char ch=getchar();
    while (ch<'0'||ch>'9')
        ch=getchar();
    while (ch>='0'&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x;
}
const int MAXN=100000;
pair<int,int> e[MAXN+10];
int Q[MAXN+10];
int rub[MAXN+10],rtop;
int n,odd;
struct Heap{
    int q[MAXN+10],pos[MAXN+10],back[MAXN+10];
    int cnt;
    void sw(int l,int r)
    {
        swap(q[l],q[r]);
		swap(back[l],back[r]);
        pos[back[l]]=l;
		pos[back[r]]=r;
    }
    void up(int x)
    {
        while ((x>>1) && q[x]>q[x>>1])
		{
            sw(x,x>>1);
			x=x>>1; 
		}
    }
    void down(int x)
    {
        while ((x<<1)<=cnt)
		{
            int loc=((x<<1)==cnt || q[x<<1]>q[x<<1|1])?(x<<1):(x<<1|1);
            if (q[loc]>q[x])
			{
				sw(x,loc);
				x=loc; 
			}
            else
				break;
		}
    }
    void add(int x,int k)
    {
        q[++cnt]=k;
		pos[x]=cnt;
		back[cnt]=x;
		up(cnt);
    }
    void del(int x)
    {
        int loc=pos[x];
		sw(loc,cnt);
		cnt--;
		down(loc);
		up(loc);
    }
}h;
struct LCT{
    int q[(MAXN<<1)+10],MAX[(MAXN<<1)+10];
    int sz[(MAXN<<1)+10],nsz[(MAXN<<1)+10];
    int st[MAXN],top;
    int f[(MAXN<<1)+10],ch[(MAXN<<1)+10][2],rev[(MAXN<<1)+10];
    #define isroot(x) ((ch[f[x]][0]!=x) && (ch[f[x]][1]!=x))
    #define loc(x) (ch[f[x]][1]==x)
    void set(int x,int l,int c)
    {
        ch[x][l]=c;
        if (c)
            f[c]=x;
    }
    void update(int x)
    {
        MAX[x]=x;
        sz[x]=nsz[x]+(x<=n);
        for (int i=0;i<2;i++)
        {
            if (ch[x][i]&&q[MAX[ch[x][i]]]>q[MAX[x]])
                MAX[x]=MAX[ch[x][i]];
            sz[x]+=sz[ch[x][i]];
        }
    }
    void rotate(int x)
    {
        int fa=f[x],ff=f[fa],l=loc(x);
        if (!isroot(fa))
            set(ff,loc(fa),x);
        f[x]=ff;
        set(fa,l,ch[x][l^1]);
        set(x,l^1,fa);
        update(fa);
    }
    void down(int x)
    {
        if (rev[x])
        {
            for (int i=0;i<2;i++)
                if (ch[x][i])
                    rev[ch[x][i]]^=1;
            swap(ch[x][0],ch[x][1]);
            rev[x]=0;
        }
    }
    void splay(int x)
    {
        st[top=1]=x;
        for (int px=x;!isroot(px);px=f[px])
            st[++top]=f[px];
        for (;top;top--)
            down(st[top]);
        while (!isroot(x))
        {
            int fa=f[x];
            if (!isroot(fa))
            {
                if (loc(x)==loc(fa))
                    rotate(fa);
                else
                    rotate(x);
            }
            rotate(x);
        }
        update(x);
    }
    void access(int x)
    {
        splay(x);
		nsz[x]+=sz[ch[x][1]];
		ch[x][1]=0;
        for (;f[x];) 
		{
            int u=f[x];
			splay(u);
            nsz[u]-=sz[x];
			nsz[u]+=sz[ch[u][1]];
            set(u,1,x);
			update(u);
            splay(x=u); 
		}
    }
    void beroot(int x)
    {
        access(x);
		splay(x);
		rev[x]^=1;
    }
    int root(int x)
    {
        access(x);
		splay(x);
        while (ch[x][0])
            x=ch[x][0];
        return x;
    }
    void cut(int loc,int x,int y)
    {
        beroot(loc); h.del(loc-n); rub[++rtop]=loc;
        access(x); splay(loc); f[ch[loc][1]]=0; ch[loc][1]=0;
        access(y); splay(loc); f[ch[loc][1]]=0; ch[loc][1]=0;
        access(x); splay(x);
        access(y); splay(y);
        if ((sz[x]&1)&&(sz[y]&1))
			odd+=2;
    }
    void link(int loc,int x,int y,int k)
    {
        access(x);splay(x);access(y);splay(y);
        if ((sz[x]&1)&&(sz[y]&1))
            odd-=2;
        q[loc]=k;e[loc-n]=make_pair(x,y);
        h.add(loc-n,k);
        beroot(x);f[x]=loc;nsz[loc]+=sz[x];
        beroot(y);f[y]=loc;nsz[loc]+=sz[y];
    }
    void check(int x,int y,int k)
    {
        if (root(x)!=root(y))
        {
            beroot(x); beroot(y);
            link(rub[rtop--],x,y,k);
        }
        else
        {
            beroot(x); access(y); splay(y);
            int loc=MAX[y];
            if (q[loc]>k)
            {
                cut(loc,x,y);
                link(rub[rtop--],x,y,k);
            }
        }
    }
}tree;
int m;
inline int solve()
{
    int loc;
    while (odd==0)
    {
        loc=h.back[1];
        tree.cut(loc+n,e[loc].first,e[loc].second);
    }
    tree.link(rub[rtop--],e[loc].first,e[loc].second,h.q[h.pos[loc]]);
    return h.q[h.pos[loc]];
}
int main()
{
    odd=n=read(); m=read();
    for (int i=1;i<=n;i++)
    {
        rub[++rtop]=n+i;
        tree.sz[i]=1;
    }
    for (int i=1;i<=m;i++)
    {
        int x=read(),y=read(),k=read();
        tree.check(x,y,k);
        if (odd==0)
            printf("%d\n",solve());
        else
            puts("-1");
    }
    return 0;
}
   	 	 	 		 	 			   	  		   	