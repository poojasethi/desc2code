#include <bits/stdc++.h>
using namespace std;

#define fru(j,n) for(int j=0; j<(n); ++j)
#define tr(it,v) for(typeof((v).begin()) it=(v).begin(); it!=(v).end(); ++it)
#define x first
#define y second
#define pb push_back
#define ALL(V) (V).begin(),(V).end()
#if 0
	#define DEB printf
#else
	#define DEB(...)
#endif

typedef long long ll;
typedef double D;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef vector<int> vi;

const int inft = 1000000009;
const int MAXN = 1000006;//10^6

pii P[MAXN];
int L[MAXN];
int n,m;

vector<pii> X;
struct DSU{
	int n,odd;
	int size[MAXN],f[MAXN];
	vector<pair<int*,int> > changes;
	void init(int _n){
		n=_n;
		fru(i,n)f[i]=i;
		fru(i,n)size[i]=1;
		odd=n;
	}
	int _find(int x){
		while(x!=f[x])x=f[x];
		return x;
	}
	void set(int *a,int b){
		changes.pb(make_pair(a,*a));
		*a=b;
	}
	void _union(int a,int b){
		a=_find(a);b=_find(b);
		DEB("ab %d %d\n",a,b);
		if(a==b)return;
		if(size[a]<size[b])swap(a,b);
		set(f+b,a);
		set(&odd,odd+(-size[a]%2-size[b]%2+(size[a]+size[b])%2));
		set(size+a,size[a]+size[b]);
	}
	void unio(int w){DEB("union dla %d\n",w);_union(P[w].x,P[w].y);}
	void rollback(int tim){
		while(changes.size()>tim){
			*changes.back().x=changes.back().y;
			changes.pop_back();
		}
		DEB("rollback odd -%d\n",odd);
		fru(i,n)DEB("%d ",f[i]);DEB("\n");
	}
	int backup(){
		return changes.size();
	}
}T;

vi ANS;
void go(int l,int r,int lo,int hi){//interv[l,r] with values [lo,hi]
	DEB("szukam [%d,%d], wart [%d,%d]\n",l,r,lo,hi);
	DEB("sett odd -%d\n",T.odd);
	fru(i,n)DEB("%d ",T.f[i]);DEB("\n");
	if(l>r)return;
	int mi=(l+r)/2;
	int p0=T.backup();
	DEB("back %d\n",p0);
	for(int i=l;i<=mi;i++)if(L[i]<lo)T.unio(i);
	int j=lo;
	DEB("tanie\n");
	while(T.odd!=0 && j<=hi){
	//	DEB("odd -%d\n",T.odd);
	//	fru(i,n)DEB("%d ",T.f[i]);DEB("\n");
		if(X[j].y<=mi)T.unio(X[j].y);
		j++;
	}
	j--;
	int sklad=T.odd;
	DEB("j=%d, odd %d\n",j,T.odd);
	//undo changes needed to find j
	T.rollback(p0);

	if(sklad){
		//interval [l,mi] is bad
		for(int i=l;i<=mi;i++)ANS[i]=-1;
		DEB("ustawiam %d- %d na -1\n",l,mi);
		//check interval [mi+1,r]
		for(int i=l;i<=mi;i++)if(L[i]<lo)T.unio(i);
		go(mi+1,r,lo,hi);
		T.rollback(p0);
		return;
	}
	//answer for mi is j
	ANS[mi]=j;
	for(int i=lo;i<j;i++)if(X[i].y<l)T.unio(X[i].y);
	go(l,mi-1,j,hi);
	T.rollback(p0);
	for(int i=l;i<=mi;i++)if(L[i]<lo)T.unio(i);
	go(mi+1,r,lo,j);
	T.rollback(p0);
}
void solve() {
	scanf("%d%d",&n,&m);
	fru(i,m){
		scanf("%d%d%d",&P[i].x,&P[i].y,&L[i]);
		X.pb(pii(L[i],i));
	}
	fru(i,m){P[i].x--;P[i].y--;}
	ANS.resize(m);
	sort(ALL(X));
	fru(i,m)L[i]=lower_bound(ALL(X),pii(L[i],i))-X.begin();
	T.init(n);
	go(0,m-1,0,m-1);
	fru(i,m)if(ANS[i]!=-1)ANS[i]=X[ANS[i]].x;
	fru(i,m)printf("%d ",ANS[i]);
}

int main(){
	//freopen("input.in", "r", stdin);
	//freopen("output.out", "w", stdout);
	int t=1;//scanf("%d",&t);
	fru(i,t) solve();
	return 0;
}
