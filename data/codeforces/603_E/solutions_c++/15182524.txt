#include <bits/stdc++.h>
#define fi first
#define se second
#define mp make_pair
#define PII pair<int,int>
#define debug(...) fprintf(stderr, __VA_ARGS__)

const int N = 100009;
const int M = 300009;

int n, m;

struct Node { 
    Node *fa, *c[2];
    int size, sub, key, max;
    bool rev;

    Node() {
        fa = c[0] = c[1] = 0;
        size = sub = key = max = 0;
        rev = false;
    }
    
    inline void setc(Node *p, int d) {
        c[d] = p;
        if(p) p->fa = this;
    }
    
    inline bool d() {
        return fa->c[1] == this;
    }
    
    inline bool is_root() {
        return fa == 0 || (fa->c[0] != this && fa->c[1] != this);
    }

    inline void push_up() {
        size = (key==0)+sub, max = key;
        for(int i = 0; i < 2; ++i)
            if(c[i]) {
                size += c[i]->size;
                max = std::max(max, c[i]->max);
            }
    }
    
    inline void push_down() {
        if(rev) {
            for(int i = 0; i < 2; ++i)
                if(c[i])
                    c[i]->rev ^= true;
            std::swap(c[0], c[1]);
            rev = false;
        }
    }

    inline void rot() {
        Node *f = fa;int p = d();
        if(f->is_root()) fa = f->fa;
        else f->fa->setc(this, f->d());
        f->setc(c[p^1], p), setc(f, p^1);
        f->push_up();
    }
    
    inline void splay() {
        static int n;
        static Node* anc[N];
        n = 0, anc[n++] = this;
        for(Node *p = this; !p->is_root(); p = p->fa)
            anc[n++] = p->fa;
        while(n--) anc[n]->push_down();
        while(!is_root()) {
            if(!fa->is_root()) {
                if(fa->d() == d()) fa->rot();
                else rot();
            }
            rot();
        }
        push_up();
    }
    
    inline void access() {
        for(Node *p = this, *q = 0; p; q = p, p = p->fa) {
            p->splay();
            if(q) p->sub -= q->size;
            if(p->c[1]) p->sub += p->c[1]->size;
            p->setc(q, 1), p->push_up();
        }
    }

    inline void make_root() {
        access(), splay(), rev ^= true;
    }

    inline int get_size() {
        access(), splay();
        return size;
    }

    inline Node* find_root() {
        access(), splay();
        Node *ret = this;
        while(ret->c[0]) ret = ret->c[0];
        return ret;
    }

    inline Node* find_max() {
        Node *ret = c[0];
        while(ret->max != ret->key) {
            ret->push_down();
            if(ret->c[0] && ret->c[1]) {
                if(ret->c[0]->max > ret->c[1]->max) ret = ret->c[0];
                else ret = ret->c[1];
            }
            else if(ret->c[0]) ret = ret->c[0];
            else ret = ret->c[1];
        }
        return ret;
    }
}*node[N+M], pool[N+M];

int odd_cnt;

int u[M], v[M], l[M];

std::set<std::PII > s;

inline int id(Node *p) {
    return p-pool;
}

inline void link(Node *p, Node *q) {
    p->make_root(), p->fa = q;
    q->sub += p->size, q->push_up();
}

inline void link(int e) {
    Node *x = node[u[e]], *y = node[v[e]], *z = node[e+n];
    if((x->get_size()&1) && (y->get_size()&1)) odd_cnt -= 2;
    link(x, z), link(y, z);
    s.insert(std::mp(l[e], e));
}

inline void cut(Node *p, Node *q) {
    p->make_root(), q->access(), q->splay();
    q->c[0] = p->fa = 0, q->push_up();
}

inline void cut(int e) {
    Node *x = node[u[e]], *y = node[v[e]], *z = node[e+n];
    cut(x, z), cut(y, z);
    if((x->get_size()&1) && (y->get_size()&1)) odd_cnt += 2;
    s.erase(std::mp(l[e], e));
}

inline void init() {
    scanf("%d%d", &n, &m);
    odd_cnt = n;
    for(int i = 1; i <= n+m; ++i) {
        node[i] = &pool[i];
        node[i]->size = i<=n;
    }
}

inline void work(int e) {
    Node *x = node[u[e]], *y = node[v[e]], *z = node[e+n];
    if(x->find_root() == y->find_root()) {
        x->make_root(), y->access(), y->splay();
        if(y->max > z->max) {
            cut(id(y->find_max())-n);
            link(e);
        }
    }
    else link(e);
}

inline int get_ans() {
    int last;
    while(odd_cnt == 0)
        last = s.rbegin()->se, cut(last);
    link(last);
    return l[last];
}

inline void solve() {
    for(int i = 1; i <= m; ++i) {
        scanf("%d%d%d", u+i, v+i, l+i);
        node[i+n]->key = node[i+n]->max = l[i];
        work(i), printf("%d\n", odd_cnt?-1:get_ans());
    }
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif

    init();
    solve();
    
#ifndef ONLINE_JUDGE
    fclose(stdin);fclose(stdout);
#endif
    return 0;
}
