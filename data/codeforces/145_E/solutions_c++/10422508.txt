#include <bits/stdc++.h>

#define o ((b+e)/2)

using namespace std;

int N,M,ar[1100000],lazy[1100000*5];

struct node{
	int lo,hi,inc,dic;
	node( int a=0 , int b=0 , int c=0 , int d=0 ){ lo=a; hi=b; inc=c; dic=d; }
	friend node operator + ( const node &a , const node &b ){
		node nw;
		nw.lo=a.lo+b.lo; nw.hi=a.hi+b.hi;
		nw.inc=max( max( nw.lo , nw.hi ) , max( a.inc+b.hi , a.lo+b.inc ) );
		nw.dic=max( max( nw.lo , nw.hi ) , max( a.dic+b.lo , a.hi+b.dic ) );
		return nw;
	}
};

node seg[1100000*5];

node init( int k , int b , int e ){
	if( b == e ){
		if( ar[b] ) return seg[k]=node( 0 , 1 , 1 , 1 );
		return seg[k]=node( 1 , 0 , 1 , 1 );
	}
	return seg[k]=init( 2*k , b , o )+init( 2*k+1 , o+1 , e );
}

void relax( int k ){
	if( !lazy[k] ) return;
	lazy[2*k]^=1; lazy[2*k+1]^=1; lazy[k]=0;
}

node get( int k ){
	if( lazy[k] ) return node( seg[k].hi , seg[k].lo , seg[k].dic , seg[k].inc );
	return seg[k];
}

void upd( int k , int b , int e , int a1 , int a2 ){
	if( b > a2 || e < a1 ) return;
	if( a1 <= b && e <= a2 ){
		lazy[k]^=1;
		return;
	}
	relax( k );
	upd( 2*k , b , o , a1 , a2 );
	upd( 2*k+1 , o+1 , e , a1 , a2 );
	seg[k]=get( 2*k )+get( 2*k+1 );
}

int mx( node k ){
	return max( max( k.lo , k.hi ) , k.inc );
}

int main(){
	
	cin >> N >> M;
	
	for( int i=1,a ; i<=N ; i++ ){
		char c; scanf(" %c",&c);
		if( c == '7' ) ar[i]=1;
	}
	
	init( 1 , 1 , N );
	
	string s;
	while( M-- ){
		s.clear();
		cin >> s;
		if( s == "count" ){
			printf("%d\n",mx( get( 1 ) ));
		}else{
			int a,b; 	scanf(" %d %d",&a,&b);
			upd( 1 , 1 , N , a , b );
		}
	}
	
	return 0;
	
}
