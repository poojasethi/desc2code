#include <cstdio>
#include <algorithm>

using namespace std;

const int MAXN = 1000 * 1000 + 10;
int inc[4 * MAXN], dc[4 * MAXN], num[2][MAXN * 4], n, m, l, r;
bool rev[4 * MAXN];
char st[MAXN];

void merge(int cur)
{
	num[0][cur] = num[0][cur * 2] + num[0][cur * 2 + 1];
	num[1][cur] = num[1][cur * 2] + num[1][cur * 2 + 1];
	inc[cur] = max(inc[cur * 2] + num[1][cur * 2 + 1], num[0][cur * 2] + inc[cur * 2 + 1]);
	dc[cur] = max(num[1][cur * 2] + dc[cur * 2 + 1], dc[cur * 2] + num[0][cur * 2 + 1]);
}

void revNode(int cur)
{
	rev[cur] = !rev[cur];
	swap(num[0][cur], num[1][cur]);
	swap(dc[cur], inc[cur]);
}

void lazy(int cur)
{
	if (rev[cur])
	{
		rev[cur] = false;
		revNode(cur * 2);
		revNode(cur * 2 + 1);
	}
}

void reverse(int lo, int hi, int cur, int s, int e)
{
	if (lo == s && e == hi)
	{
		revNode(cur);
		return;
	}
	lazy(cur);
	int mid = (e + s) / 2;
	if (lo < mid)
		reverse(lo, min(mid, hi), cur * 2, s, mid);
	if (hi > mid)
		reverse(max(lo, mid), hi, cur * 2 + 1, mid, e);
	merge(cur);
}

void build(int cur, int s, int e)
{
	if (e - s < 2)
	{
		if (st[s] == '7') num[1][cur]++;
		else num[0][cur]++;
		dc[cur] = inc[cur] = 1;
		return;
	}
	int mid = (s + e) / 2;
	build(cur * 2, s, mid);
	build(cur * 2 + 1, mid, e);
	merge(cur);
}

int main()
{
	scanf("%d%d", &n, &m);
	scanf("%s", st);
	build(1, 0, n);
	for (int i = 0; i < m; i++)
	{
		scanf("%s", st);	
		if (st[0] == 's')
		{
			scanf("%d%d", &l, &r); l--;
			reverse(l, r, 1, 0, n);
		}
		else
			printf("%d\n", inc[1]);
	}
	return 0;
}
