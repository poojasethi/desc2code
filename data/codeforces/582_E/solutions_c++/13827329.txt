#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <limits>
#include <string>
#include <cassert>

using namespace std;
typedef long long LL;
typedef pair<int,int> pii;

#define forup(i,a,b) for(int i=a; i<b; ++i)
#define fordn(i,a,b) for(int i=a; i>b; --i)
#define rep(i,a) for(int i=0; i<a; ++i)

#define dforup(i,a,b) for(i=a; i<b; ++i)
#define dfordn(i,a,b) for(i=a; i>b; --i)
#define drep(i,a) for(i=0; i<a; ++i)

#define slenn(s,n) for(n=0; s[n]!=13 and s[n]!=0; ++n);s[n]=0

#define gi(x) scanf("%d",&x)
#define gl(x) cin>>x
#define gd(x) scanf("%lf",&x)
#define gs(x) scanf("%s",x)

#define pis(x) printf("%d ",x)
#define pin(x) printf("%d\n",x)
#define pls(x) cout<<x<<" "
#define pln(x) cout<<x<<"\n"
#define pds(x) printf("%.12f ",x)
#define pdn(x) printf("%.12f\n",x)
#define pnl() printf("\n")

#define fs first
#define sc second

#define pb push_back

const int inv=numeric_limits<int>::max();
const int minv=numeric_limits<int>::min();

const int max_n=500+5;
const int max_m=16+5;

const LL modref=1000000007ll;

int n,m;
char s[max_n+1];
pii t[max_m];
char l[8]={'a','A','b','B','c','C','d','D'};
int pcmask1[8]={0};

struct node
{
	char c;
	LL q[1<<(1<<4)];
	node *l,*r;
	node(){l=NULL; r=NULL; fill(q,q+(1<<(1<<4)),0ll);}
};

void treeify(node* curr, int l, int r)
{
	assert(l<=r);

	if(l==r)
	{
		curr->c=s[l];
		assert(s[l]!='(' and s[l]!=')');
	}
	else
	{
		assert(s[l]=='(');

		int ct=0;
		for(int i=l; i<=r; ++i)
		{
			if(s[i]=='(')
				++ct;
			else if(s[i]==')')
				--ct;

			if(ct==0)
			{
				assert(s[i+1]=='&' or s[i+1]=='|' or s[i+1]=='?');
				curr->c=s[i+1];
				curr->l=new node();
				curr->r=new node();
				treeify(curr->l,l+1,i-1);
				treeify(curr->r,i+3,r-1);

				return;
			}
		}
	}
}

LL ql[(1<<(1<<4))+5], qr[(1<<(1<<4))+5], qb[(1<<(1<<4))+5];

void copy(LL qs[], LL qt[])
{
	rep(mask1,(1<<(1<<4)))
		qt[mask1]=qs[mask1];
}

void comp_mul(LL qsl[], LL qsr[], LL qt[])
{
	rep(mask1,(1<<(1<<4)))
		qt[mask1]=(qsl[mask1]*qsr[mask1])%modref;
}

void aggregate(LL q[], int t, int p)
{
	//if(t==1 and p==0)
		//cerr<<"Here\n";
	for(int mask2=0; mask2<(1<<4); ++mask2)
		for(int mask1=0; mask1<(1<<(1<<4)); ++mask1)
		{
			if(((mask1>>mask2)&1)==p)
			{
				//if(t==1 and p==0/* and q[(mask1^(1<<mask2))]>0*/)
					//cerr<<"A: "<<p<<" "<<mask1<<" "<<(mask1^(1<<mask2))<<" "<<q[mask1]<<" "<<q[(mask1^(1<<mask2))]<<"\n";
				q[mask1]=(q[mask1]+t*q[(mask1^(1<<mask2))])%modref;
				//if(t==1 and p==0 and q[(mask1^(1<<mask2))]>0)
					//cerr<<"B: "<<p<<" "<<mask1<<" "<<(mask1^(1<<mask2))<<" "<<q[mask1]<<" "<<q[(mask1^(1<<mask2))]<<"\n";
				if(q[mask1]<0)
					q[mask1]+=modref;
			}
		}
}

void process(node *curr, int p)
{
	copy(curr->l->q,ql);
	//cerr<<"@ "<<p<<" "<<ql[pcmask1[1]]<<"\n";
	aggregate(ql,1,p);
	//cerr<<"@ "<<p<<" "<<ql[pcmask1[1]]<<" "<<ql[0]<<"\n";
	copy(curr->r->q,qr);
	aggregate(qr,1,p);

	comp_mul(ql,qr,qb);
	//rep(mask1,(1<<(1<<4)))
		//cerr<<mask1<<" "<<curr->q[mask1]<<"\n";
	//cerr<<p<<" "<<qb[((1<<(1<<4))-1)^pcmask1[1]]<<" "<<ql[((1<<(1<<4))-1)^pcmask1[1]]<<" "<<qr[((1<<(1<<4))-1)^pcmask1[1]]	<<"\n";
	//cerr<<p<<" "<<qb[0]<<" "<<ql[0]<<" "<<qr[0]<<" "<<ql[pcmask1[1]]<<" "<<qr[pcmask1[1]]<<"\n";
	aggregate(qb,-1,p);
	//cerr<<p<<" "<<qb[((1<<(1<<4))-1)^pcmask1[1]]<<"\n";
	//cerr<<p<<" "<<qb[0]<<"\n";
	rep(mask1,(1<<(1<<4)))
		curr->q[mask1]=(curr->q[mask1]+qb[mask1])%modref;
	//cerr<<p<<" "<<curr->q[((1<<(1<<4))-1)]<<"\n";
}

void process(node *curr)
{
	if(curr->l==NULL)
	{
		if(curr->c=='?')
		{
			rep(x,8)
				curr->q[pcmask1[x]]=1ll;
		}
		else
		{
			rep(x,8)
				if(curr->c==l[x])
				{
					curr->q[pcmask1[x]]=1ll;
					break;
				}
		}
	}
	else
	{
		process(curr->l);
		process(curr->r);

		if(curr->c=='&' or curr->c=='?')
			process(curr,0);
		if(curr->c=='|' or curr->c=='?')
			process(curr,1);
	}
}

int main()
{
	rep(x,8)
	{
		int up=('A'<=l[x] and l[x]<='D' ? 1 : 0);
		int ix; ix=(up ? (int)(l[x]-'A') : (int)(l[x]-'a'));

		pcmask1[x]=0;
		rep(mask2,1<<4)
		{
			if(((mask2>>ix)&1)==up)
			{
				pcmask1[x]+=(1<<mask2);
				//cerr<<l[x]<<" "<<ix<<" "<<up<<" :: "<<" "<<mask2<<"\n";
			}
		}
	}

	gs(s); slenn(s,n);
	node* head=new node();
	treeify(head,0,n-1);

	gi(m);
	rep(i,m)
	{
		int x[4],y;
		rep(b,4)
			gi(x[b]);
		gi(y);

		int mask=0;
		rep(b,4)
			mask+=(x[b]<<b);

		t[i]=pii(mask,y);
	}

	process(head);

	LL res=0ll;
	rep(mask1,(1<<(1<<4)))
	{
		bool valid=true;
		rep(i,m)
			if(((mask1>>t[i].fs)&1)!=t[i].sc)
			{
				valid=false;
				break;
			}

		if(valid)
			res=(res+head->q[mask1])%modref;
	}
	pln(res);

	return 0;
}