#include <cstdio>
#include <algorithm>
#include <vector>
#include <map>
#define N 30
#define M 700000
#define M2 2000000
#define INF 1000000000
#define LL long long
#define FI(a, b, c) for(int a = (b); a <= (c); a++)
#define fi(a, b, c) for(int a = (b); a < (c); a++)
#define FD(a, b, c) for(int a = (b); a >= (c); a--)
#define fd(a, b, c) for(int a = (b); a > (c); a--)
using namespace std;

int n, a[N], b[N], c[N], m, r[N], stx[M][N], sta[M], stb[M], stc[M], p;
int ans, AC1, AC2, mo, alist[N];
map<LL, int> q;
char opp[3][3] = {"MW", "LW", "LM"};

LL key(int x, int y){
	return (LL) x * INF + y;
}

void odp(int x){
	if(x == m){
		int ca = 0, cb = 0, cc = 0;
		++p;
		fi(i, 0, m){
			ca += a[i];
			cb += b[i];
			cc += c[i];
			if(!r[i]) ca -= a[i];
			else if(r[i] == 1) cb -= b[i];
			else cc -= c[i];
			stx[p][i] = r[i];
		}
		
		sta[p] = ca;
		stb[p] = cb;
		stc[p] = cc;
		
		int op = q[key(ca - cb, ca - cc)];
		//printf("set %d %d %d\n", ca - cb, ca - cc, op);
		if(!op || ca >= sta[op] && cb >= stb[op] && cc >= stc[op]) q[key(ca - cb, ca - cc)] = p;
		return;
	}
	
	FI(i, 0, 2){
		r[x] = i;
		odp(x + 1);
	}
}

void odp2(int x){
	if(x == m - 1){
		int ca = 0, cb = 0, cc = 0;
		FD(i, n - 1, m){
			ca += a[i];
			cb += b[i];
			cc += c[i];
			if(!r[i]) ca -= a[i];
			else if(r[i] == 1) cb -= b[i];
			else cc -= c[i];
		}
	//	puts("ok");
	//	printf("%d %d\n", cb - ca, cc - ca);
		int op = q[key(cb - ca, cc - ca)];
		//printf("get %d %d %d\n", cb - ca, cc - ca, op);
	//	puts("error");
		
		if(!op) return;
		if(sta[op] + ca > ans){
			ans = sta[op] + ca;
			AC1 = op;
			fi(i, m, n) alist[i] = r[i];
		}
		
		return;
	}
	
	FI(i, 0, 2){
		r[x] = i;
		odp2(x - 1);
	}
}

int main(){
	scanf("%d", &n);
	fi(i, 0, n) scanf("%d %d %d", &a[i], &b[i], &c[i]);
	m = n / 2;
	
	ans = -INF;
	
	odp(0);
	odp2(n - 1);
	
	if(ans <= -INF) puts("Impossible");
	else{
		fi(i, 0, m) printf("%s\n", opp[stx[AC1][i]]);
		fi(i, m, n) printf("%s\n", opp[alist[i]]);
	}
	
	scanf("\n");
}
