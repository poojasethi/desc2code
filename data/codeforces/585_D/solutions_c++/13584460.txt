#include <cstdio>

#define MOD 1000019
#define SIZE 3000000

int n, mid, num[30][3];
int Last[MOD], tot, A[SIZE], B[SIZE], C[SIZE], pre[SIZE];
long long F[SIZE];
char str[4][2] = {{'x','x'}, {'L','M'}, {'M', 'W'}, {'L', 'W'}};
long long ansK = -999999999ll, ansF, ansF2;

void dfs(int i, int a, int b, int c, long long f)
{
	if (i == mid)
	{
		int key = ((a - b) * 100 + c - b) % MOD;
		if (key < 0) key += MOD;
		for (int j = Last[key]; j; j = pre[j])
		{
			if (A[j] - a == B[j] - b && A[j] - a == C[j] - c)
			{
				if (A[j] < a)
				{
					A[j] = a;
					B[j] = b;
					C[j] = c;
				}
				return;
			}
		}
		tot++;
		A[tot] = a;
		B[tot] = b;
		C[tot] = c;
		pre[tot] = Last[key];
		Last[key] = tot;
		F[tot] = f;
		return;
	}
	i++;
	dfs(i, a + num[i][0], b + num[i][1], c, f * 10 + 1);
	dfs(i, a, b + num[i][1], c + num[i][2], f * 10 + 2);
	dfs(i, a + num[i][0], b, c + num[i][2], f * 10 + 3);
}

void dfs2(int i, int a, int b, int c, long long f)
{
	if (i == n)
	{
		int key = ((b - a) * 100 + b - c) % MOD;
		if (key < 0) key += MOD;
		for (int j = Last[key]; j; j = pre[j])
		{
			if (A[j] + a == B[j] + b && B[j] + b == C[j] + c)
			{
				if (A[j] + a > ansK)
				{
					ansK = A[j] + a;
					ansF = F[j];
					ansF2 = f;
				}
			}
		}
		return;
	}
	i++;
	dfs2(i, a + num[i][0], b + num[i][1], c, f * 10 + 1);
	dfs2(i, a, b + num[i][1], c + num[i][2], f * 10 + 2);
	dfs2(i, a + num[i][0], b, c + num[i][2], f * 10 + 3);
}

void print(long long X)
{
	long long x = 0;
	int t;
	while (X)
	{
		x = x * 10 + X % 10;
		X /= 10;
	}
	while (x)
	{
		t = x % 10;
		printf("%c%c\n", str[t][0], str[t][1]);
		x /= 10;
	}
}

int main()
{
	scanf("%d", &n);
	mid = n / 2 + 1;
	for (int i = 1; i <= n; i++)
		scanf("%d%d%d", &num[i][0], &num[i][1], &num[i][2]);
	dfs(0, 0, 0, 0, 0);
	dfs2(mid, 0, 0, 0, 0);
	if (ansK == -999999999ll) puts("Impossible");
	else
	{
		print(ansF);
		print(ansF2);
	}
}