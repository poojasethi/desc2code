#include<cstdio>
#include<algorithm>
#include<map>
#include<bitset>
#define mk make_pair
#define N 1000005
using namespace std;
pair<int,int>T;
map<pair<int,int>,int>M;
int A[N],B[N],C[N],a[30],b[30],c[30],n,ans,tot,i;
bitset<26>_A[N],_B[N],_C[N],nowA,nowB,nowC,ansA,ansB,ansC,space;

void dfs(int k,int Asum,int Bsum,int Csum){
    if (k>n/2){
        T=mk(Asum-Bsum,Asum-Csum);int id;
        if (M.find(T)!=M.end()){
            id=M[T];
            if (A[id]+B[id]+C[id]>Asum+Bsum+Csum) return;
      }else M[T]=id=++tot;
        A[id]=Asum;B[id]=Bsum;C[id]=Csum;
        _A[id]=nowA;_B[id]=nowB;_C[id]=nowC;return;
  }
  nowA[k]=1;nowB[k]=1;nowC[k]=0;dfs(k+1,Asum+a[k],Bsum+b[k],Csum);
  nowA[k]=1;nowB[k]=0;nowC[k]=1;dfs(k+1,Asum+a[k],Bsum,Csum+c[k]);
  nowA[k]=0;nowB[k]=1;nowC[k]=1;dfs(k+1,Asum,Bsum+b[k],Csum+c[k]);
}
void Dfs(int k,int Asum,int Bsum,int Csum){
    if (k==3)
        k=3;
    if (k>n){
        if (nowA[2]==0&&nowA[3]==0)
            nowA[2]=0;
        T=mk(Bsum-Asum,Csum-Asum);
        if (M.find(T)==M.end()) return;
        int id=M[T];
        if (ans==-1e9||Asum+A[id]>ans)
            ans=Asum+A[id],ansA=_A[id]|nowA,ansB=_B[id]|nowB,ansC=_C[id]|nowC;
        return;
  }
  nowA[k]=1;nowB[k]=1;nowC[k]=0;Dfs(k+1,Asum+a[k],Bsum+b[k],Csum);
  nowA[k]=1;nowB[k]=0;nowC[k]=1;Dfs(k+1,Asum+a[k],Bsum,Csum+c[k]);
  nowA[k]=0;nowB[k]=1;nowC[k]=1;Dfs(k+1,Asum,Bsum+b[k],Csum+c[k]);
}
int main(){
    scanf("%d",&n);
    for (i=1;i<=n;i++)
        scanf("%d%d%d",&a[i],&b[i],&c[i]);
    if (n==1) {
        if (a[1]+b[1]==0) puts("LM");
        else if (a[1]+c[1]==0) puts("LW");
        else if (b[1]+c[1]==0) puts("MW");
        else puts("Impossible");return 0;
  }ans=-1e9;
    dfs(1,0,0,0);
    nowA=nowB=nowC=space;
    Dfs(n/2+1,0,0,0);
    if (ans>-1e9) 
        for (i=1;i<=n;i++,puts("")){
            if (ansA[i]) putchar('L');
            if (ansB[i]) putchar('M');
            if (ansC[i]) putchar('W');
      }
    else puts("Impossible");
}