#include<bits/stdc++.h>
#define triple pair<int, pair<int, int> >
#define mt(x, y, z) make_pair(x, make_pair(y, z))
using namespace std;
int X[30][3];
int val[3];
int n;
string s;
char C[5];
map<triple, pair<int, string> > M;
int best = -1000000000;
string ans;
bool found;
void take(int i, int x, int y, int off) {
	val[x] += X[i][x];
	val[y] += X[i][y];
	s[2 * i - 2 * off] = C[x];
	s[2 * i + 1 - 2 * off] = C[y];
}
void leave(int i, int x, int y) {
	val[x] -= X[i][x];
	val[y] -= X[i][y];
}

void gen(int i) {
	if (i == n / 2) {

		int m = max(val[0], val[1]);
		m = max(m, val[2]);
		triple V = mt(m - val[0], m - val[1], m - val[2]);
		if (M.find(V) == M.end() || M[V].first < val[0])
			M[V] = make_pair(val[0], s);
		return;
	}
	take(i, 0, 1, 0);
	gen(i + 1);
	leave(i, 0, 1);

	take(i, 0, 2, 0);
	gen(i + 1);
	leave(i, 0, 2);

	take(i, 2, 1, 0);
	gen(i + 1);
	leave(i, 2, 1);
}

void solve(int i) {
//	cout << i << endl;
	//return;
	if (i == n) {
		int m = min(val[0], val[1]);
		m = min(m, val[2]);
		triple V = mt(val[0] - m, val[1] - m, val[2] - m);
		if (M.find(V) != M.end()) {
			int target = val[0] + M[V].first;
			if (target > best) {
				best = target;
				ans = M[V].second + s;
				found = true;
			}
		}
		return;
	}
	take(i, 0, 1, n / 2);
	solve(i + 1);
	leave(i, 0, 1);

	take(i, 0, 2, n / 2);
	solve(i + 1);
	leave(i, 0, 2);

	take(i, 2, 1, n / 2);
	solve(i + 1);
	leave(i, 2, 1);
}

int main() {
	ios::sync_with_stdio(false);
	cin >> n;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < 3; j++)
			cin >> X[i][j];
	C[0] = 'L';
	C[1] = 'M';
	C[2] = 'W';
	s = "";
	for (int i = 0; i < (n / 2) * 2; i++)
		s += "A";
	for (int i = 0; i < 3; i++)
		val[0] = 0;
	gen(0);
//	return 0;
	s = "";
	for (int i = 0; i < 2 * n - (n / 2) * 2; i++)
		s += "A";
	for (int i = 0; i < 3; i++)
		val[i] = 0;
	ans = "";

	solve(n / 2);

	if (!found)
		cout << "Impossible" << endl;
	else {
		for (int i = 0; i < n; i++)
			cout << ans[2 * i] << ans[2 * i + 1] << endl;
	}

	return 0;
}

