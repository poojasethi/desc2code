#include<bits/stdc++.h>
using namespace std;
const int maxn=26,inf=2147483647;
int n,half,ans=-inf,seq[maxn],w[maxn][3];
void init(){
	scanf("%d",&n);
	for (int i=1;i<=n;++i) scanf("%d%d%d",&w[i][0],&w[i][1],&w[i][2]);
}
struct Thash{
	static const int maxnode=600015,base=930077,mod=92329101;
	int tot,now[base],pre[maxnode],num[maxnode][3],data[maxnode][maxn>>1];
	void insert(int a[],int siz){
		memcpy(data[++tot],a,sizeof(int)*(siz+1));
		for (int i=1;i<=siz;++i)
			for (int k=0;k<3;++k)
				if (a[i]!=k) num[tot][k]+=w[i][k];
		int u=((num[tot][0]-num[tot][1]+num[tot][0]-num[tot][2])%mod+mod)%mod%base;
		pre[tot]=now[u];now[u]=tot;
	}
	void find(int a[],int siz){
		int tmp[3];memset(tmp,0,sizeof(tmp));
		for (int i=half+1;i<=half+siz;++i)
			for (int k=0;k<3;++k)
				if (a[i-half]!=k) tmp[k]+=w[i][k];
		int u=((tmp[1]-tmp[0]+tmp[2]-tmp[0])%mod+mod)%mod%base;
		for (int p=now[u];p;p=pre[p])
			if (num[p][0]-num[p][1]==tmp[1]-tmp[0]&&num[p][0]-num[p][2]==tmp[2]-tmp[0])
				if (num[p][0]+tmp[0]>ans){
					ans=num[p][0]+tmp[0];
					for (int i=1;i<=half;++i) seq[i]=data[p][i];
					for (int i=half+1;i<=half+siz;++i) seq[i]=a[i-half];
				}
	}
	/*
	令a，b，c为最终好感度
	折半爆枚，令前一半好感度为a1，b1，c1，后一半为a2，b2，c2。 
	要满足a1+a2=b1+b2=c1+c2。且a1+a2尽量大
	移项，a1-b1=b2-a2且a1-c1=c2-a2 
	满足a=b=c的最大的a1+a2。 
	*/
}hash;
int data[maxn];
void dfs(int cur,int tot,bool op){
	if (cur==tot+1){op?hash.insert(data,tot):hash.find(data,tot);return;}
	for (int i=0;i<3;++i){data[cur]=i;dfs(cur+1,tot,op);}
}
void work(){
	half=n/2;dfs(1,half,1);dfs(1,half+(n&1),0);
	if (ans==-inf){puts("Impossible");return;}
	for (int i=1;i<=n;++i){
		for (int k=0;k<3;++k)
			if (seq[i]!=k)
				switch (k){
					case 0:putchar('L');break;
					case 1:putchar('M');break;
					case 2:putchar('W');break;
				}
		putchar('\n');
	}
}
int main(){
	init();
	work();
	return 0;
}
   		      		 	 	 		 	 		 			