#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <map>
#define Rep(i, x, y) for (int i = x; i <= y; i ++)
#define Dwn(i, x, y) for (int i = x; i >= y; i --)
#define RepE(i, x) for(int i = pos[x]; i; i = g[i].nex)
using namespace std;
typedef long long LL;
map<pair<int, int>, int> m1;
const int N = 30, M = 2000000;
int n, a[N], b[N], c[N], n0, pz, p[M][15], c0[N], d[M], ans[N], a1;
void Dfs(int m, int x, int y, int z) {
	if (m == n0 + 1) {
		// cout << x <<" "<<y<<" "<<z<<endl;
		pair<int, int> c1 = make_pair<int, int> (y - x, z - y);
		if (!m1.count(c1) || d[ m1[c1] ] < x) {
			m1[c1] = ++ pz; d[pz] = x;
			Rep(i, 1, n0) {
				p[pz][i] = c0[i];
			}
		}
		return ;
	}
	c0[m] = 3, Dfs(m + 1, x + a[m], y + b[m], z);
	c0[m] = 2, Dfs(m + 1, x + a[m], y, z + c[m]);
	c0[m] = 1, Dfs(m + 1, x, y + b[m], z + c[m]);
}
void Find(int m, int x, int y, int z) {
	if (m == n + 1) {
		int yx = x - y, zy = y - z;
		pair<int, int> c1 = make_pair<int, int> (yx, zy);
		if (!m1.count(c1)) return ;
		int k = m1[c1];
		if (d[k] + x > a1) {
			a1 = d[k] + x;
			Rep(i, 1, n0) ans[i] = p[k][i];
			Rep(j, n0 + 1, n) ans[j] = c0[j];
		}
		return ;
	}
	c0[m] = 3, Find(m + 1, x + a[m], y + b[m], z);
	c0[m] = 2, Find(m + 1, x + a[m], y, z + c[m]);
	c0[m] = 1, Find(m + 1, x, y + b[m], z + c[m]);
}
int main()
{
	scanf ("%d", &n);
	a1 = -(1 << 30);
	Rep(i, 1, n) scanf ("%d%d%d", &a[i], &b[i], &c[i]);
	n0 = n / 2;
	Dfs(1, 0, 0, 0); // puts("fin");
	Find(n0 + 1, 0, 0, 0);
	if (a1 != -(1 << 30)) {
		Rep(i, 1, n) {
			if (ans[i] != 1) printf("L");
			if (ans[i] != 2) printf("M");
			if (ans[i] != 3) printf("W");
			puts("");
		}
	} else puts("Impossible");

	return 0;
}
