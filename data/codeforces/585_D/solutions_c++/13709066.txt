#include<bits/stdc++.h>
using namespace std;
typedef long long int64;
typedef pair<int,int> pii;
typedef pair<int,int64> pii64;
const int maxn=30,inf=~0u>>1;
int a[maxn],b[maxn],c[maxn],n,m;

int64 pw[maxn];
void init(){
	scanf("%d",&n),m=n>>1,pw[0]=1;
	for(int i=0;i<n;++i)
		scanf("%d%d%d",a+i,b+i,c+i);
	for(int i=1;i<=n;++i)
		pw[i]=pw[i-1]*3;
}

map<pii,pii64> f;
void dfs1(int dep,int sa,int sb,int sc,int64 code){
	if(dep==m){
		if(f.count(make_pair(sb-sa,sc-sa))){
			pii64 &v=f[make_pair(sb-sa,sc-sa)];
			pii64 now=make_pair(sa,code);
			if(now>v) v=now;
		}
		else f[make_pair(sb-sa,sc-sa)]=make_pair(sa,code);
		return;
	}
	dfs1(dep+1,sa+a[dep],sb+b[dep],sc,code);
	dfs1(dep+1,sa+a[dep],sb,sc+c[dep],code+pw[dep]);
	dfs1(dep+1,sa,sb+b[dep],sc+c[dep],code+2*pw[dep]);
}
pii64 dfs2(int dep,int sa,int sb,int sc,int64 code){
	if(dep==m-1){
		if(f.count(make_pair(sa-sb,sa-sc))){
			pii64 v=f[make_pair(sa-sb,sa-sc)];
			v.first+=sa,v.second+=code;
			return v;
		}
		return make_pair(-inf,-inf);
	}
	pii64 ans(-inf,-inf);
	ans=max(ans,dfs2(dep-1,sa+a[dep],sb+b[dep],sc,code));
	ans=max(ans,dfs2(dep-1,sa+a[dep],sb,sc+c[dep],code+pw[dep]));
	ans=max(ans,dfs2(dep-1,sa,sb+b[dep],sc+c[dep],code+2*pw[dep]));
	return ans;
}

void solve(){
	f.clear(),dfs1(0,0,0,0,0);
	pii64 ans=dfs2(n-1,0,0,0,0);
	if(ans.first==-inf) puts("Impossible");
	else{
		for(int i=0;i<n;++i,ans.second/=3)
			switch(ans.second%3){
				case 0: puts("LM"); break;
				case 1: puts("LW"); break;
				case 2: puts("MW"); break;
			}
	}
}

int main(){
	init();
	solve();
	return 0;
}

    	    		 	    		 	 		 	    	