#include <bits/stdc++.h>
using namespace std;
#define inf (1 << 30)
#define LL long long
#define FI "heros.i3"
#define FO "heros.o3"
int n, res;
LL mask;
vector<int> a, b, c;
vector<LL> pw3;

struct Val{
	int a, b, c;
	LL bit;
	Val(int a = 0, int b = 0, int c = 0, LL x = 0) : a(a), b(b), c(c), bit(x) {}
	bool operator < (const Val &p) const {
		if (a != p.a) return a < p.a;
		if (b != p.b) return b < p.b;
		return c > p.c;
	}
};
vector<Val> V;

void Build (int i, int x, int y, int z, LL bit) {
	if (i == n / 2) {
		V.push_back(Val(x - y, x - z, x + y + z, bit));
		return;
	}
	Build (i + 1, x, y + b[i], z + c[i], bit);
	Build (i + 1, x + a[i], y, z + c[i], bit + pw3[i]);
	Build (i + 1, x + a[i], y + b[i], z, bit + 2 * pw3[i]);
}

void Find(int i, int x, int y, int z, LL bit) {
	if (i == n) {
		int pos = lower_bound(V.begin(), V.end(), Val(y - x, z - x, inf, 0)) - V.begin();
		if (pos < V.size() && V[pos].a == y - x && V[pos].b == z - x) {
			if (res < V[pos].c + x + y + z) {
				res = V[pos].c + x + y + z;
				mask = bit + V[pos].bit;
			}
		}
		return;
	}
	Find (i + 1, x, y + b[i], z + c[i], bit);
	Find (i + 1, x + a[i], y, z + c[i], bit + pw3[i]);
	Find (i + 1, x + a[i], y + b[i], z, bit + 2 * pw3[i]);
}

main() {
	ios_base::sync_with_stdio(0), cin.tie(0);
	#ifndef ONLINE_JUDGE
	ifstream cin(FI);
	ofstream cout(FO);
	#endif // ONLINE_JUDGE
	cin >> n;
	pw3.resize(n); pw3[0] = 1;
    a.resize(n), b.resize(n), c.resize(n);
	for (int i = 0; i < n; i ++) {
		if (i) pw3[i] = pw3[i - 1] * 3;
		cin >> a[i] >> b[i] >> c[i];
	}
	Build(0, 0, 0, 0, 0);
	sort(V.begin(), V.end());
	mask = -1, res = -inf;
	Find(n / 2, 0, 0, 0, 0);
	if (mask < 0) cout << "Impossible\n";
	else {
		for (int i = 0; i < n; i ++) {
			int x = mask % 3;
			if (!x) cout << "MW\n";
			else if (x == 1) cout << "LW\n";
			else cout << "LM\n";
			mask /= 3;
		}
	}
	return 0;
}
