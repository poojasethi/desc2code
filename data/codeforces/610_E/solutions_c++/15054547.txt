#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <string>
#include <vector>
#include <stack>
#include <queue>
#include <set>
#include <map>
#include <sstream>
#include <complex>
#include <ctime>
#include <cassert>
#include <functional>

using namespace std;

typedef long long ll;
typedef vector<int> VI;
typedef pair<int, int> PII;

#define REP(i,s,t) for(int i=(s);i<(t);i++)
#define FILL(x,v) memset(x,v,sizeof(x))

const int INF = (int)1E9;
#define MAXN 200005

#define MAXSEG 1<<20
int N, M, K;
int val[MAXSEG][10][10], lz[MAXSEG], fst[MAXSEG], lst[MAXSEG];
char buf[MAXN];
void updateVal(int k) {
	int kl = 2 * k + 1, kr = 2 * k + 2;
	REP(i, 0, K) REP(j, 0, K) {
		val[k][i][j] = val[kl][i][j] + val[kr][i][j];
	}
	val[k][lst[kl]][fst[kr]]++;
	fst[k] = fst[kl];
	lst[k] = lst[kr];
}
void add(int k, int nl, int nr, int l, int r, int v);
void relax(int k, int nl, int nr){
	int nm = (nl + nr) >> 1;
	add(2 * k + 1, nl, nm, nl, nm, lz[k]);
	add(2 * k + 2, nm + 1, nr, nm + 1, nr, lz[k]);
	lz[k] = -1;
}
void build(int k, int nl, int nr) {
	lz[k] = -1;
	if (nl == nr) {
		fst[k] = lst[k] = buf[nl] - 'a';
		return;
	}
	int nm = (nl + nr) >> 1;
	build(2 * k + 1, nl, nm);
	build(2 * k + 2, nm + 1, nr);
	updateVal(k);
}
void add(int k, int nl, int nr, int l, int r, int v){
	if (r<nl || l>nr) return;
	if (l <= nl && nr <= r){
		fst[k] = lst[k] = v;
		REP(i, 0, K) REP(j, 0, K) val[k][i][j] = 0;
		val[k][v][v] = nr - nl;
		lz[k] = v;
		return;
	}
	if (lz[k] != -1) relax(k, nl, nr);
	int nm = (nl + nr) >> 1;
	add(2 * k + 1, nl, nm, l, r, v);
	add(2 * k + 2, nm + 1, nr, l, r, v);
	updateVal(k);
}
int cost[10][10];
int main() {
	cin >> N >> M >> K;
	scanf("%s", buf);
	build(0, 0, N - 1);
	/*
	REP(i, 0, K) {
		REP(j, 0, K) {
			printf("%c->%c cnt=%d\n", 'a' + i, 'a' + j, val[i][j][0]);
		}
	}
	*/
	while (M--) {
		int t, l, r;
		scanf("%d", &t);
		if (t == 1) {
			scanf("%d%d%s", &l, &r, buf); l--; r--;
			int c = buf[0] - 'a';
			add(0, 0, N - 1, l, r, c);
		} else {
			scanf("%s", buf);
			int n = strlen(buf);
			REP(i, 0, K) REP(j, 0, K) cost[i][j] = 0;
			REP(i, 0, n) REP(j, 0, i + 1) cost[buf[i] - 'a'][buf[j] - 'a']++;
			int ans = 0;
			REP(i, 0, K) {
				REP(j, 0, K) {
					//printf("%c->%c cnt=%d cost=%d\n", 'a' + i, 'a' + j, val[i][j][0], cost[i][j]);
					ans += val[0][i][j] * cost[i][j];
				}
			}
			printf("%d\n", ans + 1);
		}
	}
	return 0;
}
