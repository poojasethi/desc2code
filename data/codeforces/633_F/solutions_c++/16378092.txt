#include <bits/stdc++.h>

using namespace std;

#define pb push_back
#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)
#define endl '\n'
#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)
#define mp make_pair
#define nd second
#define st first
#define type(x) __typeof(x.begin())

typedef pair < int ,int > pii;

typedef long long ll;

const long long linf = 1e18+5;
const int mod = (int) 1e9 + 7;
const int logN = 17;
const int inf = 1e9;
const int N = 2e5 + 5;

int S, n, m, x, y, z, a[N], t, h[N];
ll bbb[N], rrr[N], aans, res[N], sum[N], mx_depth[N];
vector< int > v[N];

void dfs1(int node, int root) {
	ll mx = a[node], res = a[node];
	bbb[node] = a[node];
	mx_depth[node] = a[node];
	ll t1 = 0;
	foreach(it, v[node])
		if(*it != root && !h[*it]) {
			dfs1(*it, node);
			bbb[node] = max(bbb[node], bbb[*it]);
			aans = max(aans, bbb[*it] + t1);
			t1 = max(t1, bbb[*it]);
			res = max(res, mx_depth[*it] + mx);
			mx = max(mx, mx_depth[*it] + a[node]);
		}
	::res[node] = res;
	bbb[node] = max(bbb[node], res);
	mx_depth[node] = mx;
}

void dfs2(int node, int root, ll mmx, ll dd) {
	ll mx1 = 0, mx2 = 0;
	ll ttt = 0;
	aans = max(aans, mmx + bbb[node]);
	foreach(it, v[node])
		if(*it != root && !h[*it]) {
			ll t = mx_depth[*it];
			if(mx1 <= t) {
				mx2 = mx1;
			 	mx1 = t;
			}
			else if(mx2 < t)
				mx2 = t;
		}
	
	foreach(it, v[node])
		if(*it != root && !h[*it]) {
			ll ttt = mx1;
			if(mx_depth[*it] == ttt) ttt = mx2;
			aans = max(aans, mmx + ttt + bbb[*it] + a[node]);
		}

	ll t1 = 0, t2 = 0, t3 = 0, t4 = 0;
	// t1 >> tek path
	// t2 >> ikili
	// t3 >> tek path + ikili
	// t4 >> ikili + tek path
	foreach(it, v[node])
		if(*it != root && !h[*it]) {
			ll at = mx_depth[*it];
			ll bt = bbb[*it];
			aans = max(aans, t3 + mx_depth[*it] + a[node]);
			aans = max(aans, t4 + mx_depth[*it] + a[node]);
			t4 = max(t4, t2 + mx_depth[*it]);
			t3 = max(t3, t1 + bbb[*it]);
			t1 = max(t1, at);
			t2 = max(t2, bt);
		}
	
	aans = max(aans, max(max(t1, t2), max(t3, t4)));

	reverse(v[node].begin(), v[node].end());
	t1 = t2 = t3 = t4 = 0;

	foreach(it, v[node])
		if(*it != root && !h[*it]) {
			ll at = mx_depth[*it];
			ll bt = bbb[*it];
			aans = max(aans, t3 + mx_depth[*it] - a[node]);
			aans = max(aans, t4 + mx_depth[*it] - a[node]);
			t4 = max(t4, t2 + mx_depth[*it]);
			t3 = max(t3, t1 + bbb[*it]);
			t1 = max(t1, at);
			t2 = max(t2, bt);
		}

	foreach(it, v[node])
		if(*it != root && !h[*it]) {
			if(mx_depth[*it] == mx1) {
				dfs2(*it, node, max(mmx, mx2) + a[node], dd);
			}	
			else 
				dfs2(*it, node, max(mmx, mx1) + a[node], dd);
		}
}

int main() {

	scanf("%d", &n);

	FOR(i, 1, n) {
		scanf("%d", &a[i]);
	}

	FOR(i, 2, n) {
		scanf("%d %d" ,&x, &y);
		v[x].pb(y); v[y].pb(x);
	}

	dfs1(1, 0);
	dfs2(1, 0, 0, 0);
	
	dfs1(2, 0);
	dfs2(2, 0, 0, 0);

	cout << aans << endl;
}
