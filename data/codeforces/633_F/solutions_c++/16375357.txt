#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <string>
#include <vector>
#include <set>
#include <queue>
#include <map>
#include <iostream>
#include <cassert>

using namespace std;

#define fru(j,n) for(int j=0; j<(n); ++j)
#define tr(it,v) for(typeof((v).begin()) it=(v).begin(); it!=(v).end(); ++it)
#define x first
#define y second
#define pb push_back
#define ALL(G) (G).begin(),(G).end()

#define DEBUG
#ifdef DEBUG
	#define DEB printf
#else
	#define DEB(...)
#endif


typedef long long LL;
typedef pair<LL,LL> pii;
typedef vector<int> vi;

const int inft = 1000000009;
const int MAXN = 100006;//10^6
LL ret=0;
int A[MAXN];
LL K[MAXN][3];
#define TR tr(it,V[u])if(*it!=par)

vi V[MAXN];

void popraw(pii &a, LL x){
	if(a.x<x){
		a.y=a.x;
		a.x=x;
	}
	else if(a.y<x) a.y=x;
}

void go(int u, int par){
	pii r(0,0);
	TR  go(*it,u);
	K[u][0]=A[u];
	fru(o,2){
		LL j0=A[u],j2=0,j00=0,j02=0;
		TR{
			ret=max(ret,j02+K[*it][0]);
			ret=max(ret,j00+K[*it][2]);
			ret=max(ret,j0+K[*it][1]);
			ret=max(ret,j2+K[*it][2]);
			ret=max(ret,j0+K[*it][2]);

			K[u][1]=max(K[u][1],j0+K[*it][2]);
			K[u][1]=max(K[u][1],A[u]+K[*it][1]);

			j00=max(j00,j0+K[*it][0]);
			j02=max(j02,j0+K[*it][2]);
			j02=max(j02,j2+K[*it][0]+A[u]);
			j0=max(j0,K[*it][0]+A[u]);
			j2=max(j2,K[*it][2]);

			K[u][0]=max(K[u][0],j0);
			K[u][2]=max(K[u][2],j00);
			K[u][2]=max(K[u][2],K[*it][2]);
		}
		reverse(ALL(V[u]));
	}
	K[u][1]=max(K[u][1],K[u][2]);
	K[u][1]=max(K[u][1],K[u][0]);
	K[u][2]=max(K[u][2],K[u][0]);

	fru(i,3) ret=max(ret,K[u][i]);
//	printf("%d: %lld %lld %lld\n",u+1,K[u][0],K[u][1],K[u][2]);
}
int main(){
	int n;
	scanf("%d",&n);
	fru(i,n) scanf("%d",&A[i]);
	fru(i,n-1){
		int a,b;
		scanf("%d%d",&a,&b);
		--a;--b;
		V[a].pb(b);
		V[b].pb(a);
	}
	go(0,-1);
	printf("%lld\n",ret);
	return 0;
}

