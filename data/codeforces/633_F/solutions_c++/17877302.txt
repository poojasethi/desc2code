#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <ctime>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <vector>
#include <bitset>
#include <functional>
using namespace std;
const long long mod = 1e9 + 7;
const int maxn = 100005;
const int INF = 1 << 30;
inline int read ()
{
	int res, ok = 1;
	char ch;
	for (ch = getchar (); ch < '0' || ch > '9'; ch = getchar ())
	if (ch == '-')
	ok = -1;
	res = ch - '0';
	for (ch = getchar (); ch >= '0' && ch <= '9'; ch = getchar ())
	res = res * 10 + ch - '0';
	return res * ok;
}
long long dp[maxn][3][2], f[3][2];
int a[maxn], n, head[maxn], tol;
struct Edge
{
	int v, next;
}E[maxn * 2];
void add_edge(int u, int v)
{
	E[tol].v = v;
	E[tol].next = head[u];
	head[u] = tol++;
}
void cmax(long long &a, long long b)
{
	if(a < b) a = b;
}
void dfs(int u, int pre)
{
	for(int i = 0; i < 3; i++)
	for(int j = 0; j < 2; j++)
	dp[u][i][j] = -INF;
	dp[u][0][0] = 0;
	dp[u][0][1] = a[u];
	dp[u][1][0] = a[u];
	long long mx = -INF;
	for(int i = head[u]; ~i; i = E[i].next)
	{
		int v = E[i].v;
		if(v == pre)
		continue;
		dfs(v, u);
		memcpy(f, dp[u], sizeof (dp[u]));
        for(int j = 0; j < 3; j++)
		{
			for(int k = j; k >= 0; k--)
			{
				cmax(dp[u][j][0], f[j - k][0] + dp[v][k][0]);
				if(j - k - 1 >= 0)
				cmax(dp[u][j][0], f[j - k - 1][1] + dp[v][k][1]);
				cmax(dp[u][j][1], f[j - k][1] + dp[v][k][0]);
			}
			cmax(dp[u][j][1], dp[v][j][1] + a[u]);
			if(j == 1)
			cmax(dp[u][j][1], dp[v][j - 1][1] + mx + a[u]);
		}
		cmax(mx, dp[v][1][0]);
	}
}
int main()
{
	n = read();
	for(int i = 1; i <= n; i++)
    a[i] = read();
    memset (head, -1, sizeof (head));
	for(int i = 1; i < n; i++)
	{
		int u, v;
		u = read();
		v = read();
		add_edge(u, v);
		add_edge(v, u);
	}
	dfs(1, -1);
	printf ("%I64d\n", max (dp[1][2][0], dp[1][1][1]));
    return 0;
}
