#include<bits/stdc++.h>
		 
using namespace std;
#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define FORE(ii,aa,bb) for(int ii=aa;ii<bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)
#define type(x) __typeof(x.begin())

#define dbg(x) cerr << (#x) << " --> " << (x) << endl
#define y1 sdfsdfsdf
#define ll long long
#define pii pair<int,int>
#define mod 1000000007
#define N (int)(1e5+10)
#define mp make_pair
#define pb push_back
#define sd second
#define ft first
#define endll puts("")
#define endl '\n'
#define inf mod
#define ort ((sol+sag)/2)

// dp[node] [chain is including node] [path isn't including node];
ll dp[N][3][3],temp[3][3];
int n,a[N],x,y;
vector<int>V[N];
void dfs(int x, int root){
	foreach(it,V[x])
		if(*it != root){
			dfs(*it,x);
			memset(temp,0,sizeof temp);
			FOR(i,0,2)
				FOR(j,0,2)
					temp[i][j] = dp[x][i][j];
		    FOR(i,0,2)
				FOR(j,0,2)
					FOR(a,0,i)
						FOR(b,0,j)
							dp[x][i][j] = max(dp[x][i][j] , dp[*it][a][b] + temp[i-a][j-b]);
		}

	
	// we should add weight of node to chain because chain is must include the node 
	FOR(i,0,2)
		FOR(j,0,2)
			if(i)
				dp[x][i][j] += a[x];


	// we can convert two chain to one path
	dp[x][0][1] = max(dp[x][0][1] , dp[x][2][0]);
	dp[x][0][2] = max(dp[x][0][2] , dp[x][2][1]);
	
	// we can't send root two chain because paths in the answer mustn't cross
	dp[x][2][2] = dp[x][2][1] = dp[x][2][0] = 0;
}
int main(){
	cin >> n;
	FOR(i,1,n) scanf("%d",&a[i]);
	FORE(i,1,n){
		scanf("%d %d",&x,&y);
		V[x].pb(y);
		V[y].pb(x);
	}
	dfs(1,0);
	
	cout << dp[1][0][2] << endl;
}
