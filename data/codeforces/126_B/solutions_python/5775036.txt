# given a string s,
# exits one prefix of s equals to one suffix of s, and
# also equals to one of its obelix

def cal_pre(s):
	pre = {}
	prevalue=[]
	pre.setdefault(0,-1)
	prevalue.append(-1)
	j = -1
	for i in range(1,len(s),1):
		while j > -1 and s[i] != s[j + 1]:
			j = pre[j]      # This is the most important step
		if s[i] == s[j + 1]:
			j += 1
		pre.setdefault(i,j)
		prevalue.append(j)
	return pre,prevalue

def stat(pre,m):
	path = []
	i = m - 1
	while pre[i] != -1:
		path.append(pre[i])
		i = pre[i]
	# print path
	# path.append(pre[i])
	return path

def find(elem,findlist):
	for x in findlist:
		if elem == x:
			return True
	return False

if __name__ == '__main__':
	s = raw_input()
	m = len(s)
	pre,findmidfix = cal_pre(s)
	# findmidfix = [pair[1] for pair in pre.items()]
	findlist = findmidfix[:m - 1]
	findset=set(s)

	path = stat(pre,m)
	flag = -1
	# print findlist
	if len(findset) == 1:
		#psfix = len(s) - 3
		#flag = psfix
		if len(s) - 3 < 0: print "Just a legend"
		else: print s[:len(s)-2]
		# print flag
		# print findset
	else:
		for i in range(len(path)): # psfix means the string can be both prefix and suffix
			psfix = path[i]
			if i == 0 and find(psfix,findlist):
				flag = psfix
				break
			if i != 0:
				flag = psfix
				break
	
		if flag > -1:
			print s[:psfix + 1]
		else: print "Just a legend"




