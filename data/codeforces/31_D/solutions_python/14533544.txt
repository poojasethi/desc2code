from math import *
from Queue import *



class line(object):

    def __init__(self, x1, y1, x2, y2):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        self.ho = (y1 == y2)
        self.ve = (x1 == x2)

def cut(l):
    x1 = l.x1+1
    x2 = l.x2+1
    y1 = l.y1+1
    y2 = l.y2+1
    if l.ho:
        for j in range(x1,x2):
            nbr[y1-1][j].remove((y1,j))
            nbr[y1][j].remove((y1-1,j))
    else:
        for i in range(y1,y2):
            nbr[i][x1-1].remove((i,x1))
            nbr[i][x1].remove((i,x1-1))

l = map(int, raw_input().split())
W, H, n = l[0], l[1], l[2]

nbr = [[[] for j in range(W+2)] for i in range(H+2)]
marked = [[True for j in range(W+2)] for i in range(H+2)]
for i in range(1,H+1):
    for j in range(1,W+1):
        marked[i][j] = False
di = [[1,0],[-1,0],[0,1],[0,-1]]
for i in range(1,H+1):
    for j in range(1,W+1):
        for d in di:
            if not marked[i+d[0]][j+d[1]]:
                nbr[i][j].append((i+d[0],j+d[1]))
for i in range(n):
    l = map(int, raw_input().split())
    new = line(l[0], l[1], l[2], l[3])
    cut(new)
ans = []
for i in range(1,H+1):
    for j in range(1,W+1):
        if not marked[i][j]:
            size = 1
            marked[i][j] = True
            Q = [(i,j)]
            while len(Q) > 0:
                v = Q.pop()
                for t in nbr[v[0]][v[1]]:
                    if not marked[t[0]][t[1]]:
                        size += 1
                        marked[t[0]][t[1]] = True
                        Q.append(t)
            ans.append(size)
ans.sort()
print(' '.join(map(str, ans)))


"""def adm(intervals, k):
    size = len(intervals)
    if size <= 2:
        return True
    cur = 0
    nex = 1
    res = True
    while nex < size:
        if nex == k:
            nex += 1
        elif cur == k:
            cur = nex
            nex = cur + 1
        elif (intervals[cur][1] > intervals[nex][0]):
            res = False
            break
        else:
            cur = nex
            nex = cur + 1
    return res    


n = int(raw_input())
intervals = []
for i in range(n):
    l = map(int, raw_input().split())
    intervals.append((l[0],l[1],i+1))
intervals.sort()
ans = []
for i in range(n):
    if adm(intervals, i):
        ans.append(intervals[i][2])
ans.sort()
print(len(ans))
if len(ans)>0:
    print(' '.join(map(str, ans)))"""


"""l = map(int, raw_input().split())
n, m, k = l[0], l[1], l[2]

marked = [[True for j in range(m+1)] for i in range(n+1)]
nbr = [[[] for j in range(m+1)] for i in range(n+1)]
pictures = [0]
com = [[0 for j in range(m+1)] for i in range(n+1)]


M = []
for i in range(n):    
    M.append(raw_input())
for i in range(n):
    for j in range(m):
        if M[i][j] == '.':
            marked[i][j] = False
            for di in [(1,0), (-1,0), (0,1), (0,-1)]:
                if M[i+di[0]][j+di[1]] == '.':
                    nbr[i][j].append([di[0],di[1]])
c = 0
for i in range(n):
    for j in range(m):
        if not marked[i][j]:
            marked[i][j] = True
            c += 1
            com[i][j] = c
            pictures.append(0)
            Q = [(i,j)]
            while len(Q)>0:
                v = Q.pop()
                pictures[c] += 4 - len(nbr[v[0]][v[1]])
                for nr in nbr[v[0]][v[1]]:
                    if not marked[v[0]+nr[0]][v[1]+nr[1]]:
                        marked[v[0]+nr[0]][v[1]+nr[1]] = True
                        Q.append((v[0]+nr[0],v[1]+nr[1]))
                        com[v[0]+nr[0]][v[1]+nr[1]] = c
positions = []
for i in range(k):
    l = map(int, raw_input().split())
    positions.append([l[0]-1, l[1]-1])
for i in range(k):
    print(pictures[com[positions[i][0]][positions[i][1]]])"""



"""c = [[[1000000 for k in range(61)] for m in range(31)] for n in range(31)]
for n in range(31):
    for m in range(31):
        c[n][m][0] = 0
        c[n][m][n+m] = 0
for n in range(31):
    for k in range(n+1):
        c[n][1][k] = 1
        c[1][n][k] = 1
for n in range(2,31):
    for m in range(2,31):
        for k in range(min(n*m,50)):
            l = [1000000]
            for i in range(1,n):
                for t in range(k+1):
                    l.append(c[i][m][t]+c[n-i][m][k-t])
            for j in range(1,m):
                for t in range(k+1):
                    l.append(c[n][j][t]+c[n][m-j][k-t])
            c[n][m][k] = min(l)
print(c[2][2][1])"""
                    
