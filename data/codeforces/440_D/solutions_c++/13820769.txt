#include <bits/stdc++.h>

using namespace std;

#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)

#define type(x) __typeof(x.begin())

#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair < int ,int > pii;

typedef long long ll;

const long long linf = 1e18+5;
const int mod = (int) 1e9 + 7;
const int logN = 17;
const int inf = 1e9;
const int N = 402;

int t, cmf, n, m, x, y, z, sum[N], h[N], H[N][N], ans = inf, xx[N], yy[N];
vector< int > dp[N][N], v[N], g[N], gg[N];

void clear() {

	FOR(i, 1, n)
		FOR(j, 0, m) {
			dp[i][j].clear();
			dp[i][j].resize(g[i].size() + 2, -1);
		}
}

int prep(int node, int root = 0) {
	
	sum[node] = 1;
	
	foreach(it, v[node])
		if(*it != root && !h[*it]) {
			sum[node] += prep(*it, node);
		}

	return sum[node];
}

void make(int node, int root = 0) {
	
	foreach(it, v[node])
		if(*it != root) {
			make(*it, node);
			g[node].pb(*it);
		}
}

int find(int node, int S, int root = 0) {

	foreach(it, v[node])
		if(*it != root && !h[*it] && sum[*it] > S)
			return find(*it, S, node);

	return node;
}

int f(int node, int rem, int w) {

	if(w == g[node].size()) return (rem != 0) * inf;
	
	int &r = dp[node][rem][w];
	if(r != -1) return r;

	int go = g[node][w];
	r = f(node, rem, w + 1) + 1;
	if(h[go]) return r;
	FOR(i, 1, rem)
		r = min(r, f(go, i-1, 0) + f(node, rem - i, w+1));

	return r;
}

void print(int node, int rem, int w) {

	if(w == g[node].size()) return ;

	int &r = dp[node][rem][w];
	int go = g[node][w];

	if(f(node, rem, w + 1) + 1 == r) {
		print(node, rem, w+1);
		H[node][go] = 1;
		return ;
	}

	FOR(i, 1, rem)
		if(f(go, i-1, 0) + f(node, rem - i, w+1) == r) {
			print(go, i-1, 0);
			print(node, rem - i, w+1);
			return ;
		}
	
	assert(0);
}

void solve(int node) {

	FOR(i, 1, n) g[i].clear(); prep(node);
	h[node = find(t = node, sum[node] >> 1)] = 1; 
	
	if(sum[t] < m) return ;

	make(node); clear(); 

	if(f(node, m-1, 0) < ans) {
		FOR(i, 1, n) gg[i] = g[i];
		ans = f(node, m-1, 0);
		cmf = node;
	}
	
	foreach(it, v[node])
		if(!h[*it])
			solve(*it);
}



int main() {

	scanf("%d %d", &n, &m);

	FOR(i, 1, n-1) {
		scanf("%d %d", &x, &y);
		v[x].pb(y); v[y].pb(x);
		xx[i] = x; yy[i] = y;
	} 
	
	solve(1);

	FOR(i, 1, n) g[i] = gg[i];	

	memset(h, 0, sizeof h);
	clear(); ans = f(cmf, m-1, 0), print(cmf, m-1, 0);


	printf("%d\n", ans);
	FOR(i, 1, n)
		if(H[xx[i]][yy[i]] || H[yy[i]][xx[i]])
			printf("%d ", i); cout << endl;

	return 0;
}
