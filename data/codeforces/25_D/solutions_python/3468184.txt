def dfs(g,root):
    #returns cycles in this component + vertices of this component
    prev = {root:-1}
    q = [root]
    visited = {root:1}
    cycle_pairs = {}
    while len(q) > 0:
        v = q[-1]
        found_u = False
        for u in g[v]:
            if not visited.has_key(u):
                q.append(u)
                visited[u] = 1
                prev[u] = v
                found_u = True
                break
            elif u in q[:-2] and not cycle_pairs.has_key((v,u)):
                #cikel
                cycle_pairs[(v,u)] = 1
        if not found_u:
            q.pop()

    cycles = []
    for child,parent in cycle_pairs.keys():
        cycle = []
        v = child
        while v != parent:
            cycle.append(v)
            v = prev[v]
        cycle.append(v)
        cycles.append(cycle)
    return cycle_pairs,cycles,visited.keys()

n = int(raw_input())

g = {i:[] for i in range(1,n+1)}
for i in range(n-1):
    a,b = map(int,raw_input().split(" "))
    g[a].append(b)
    g[b].append(a)


v = g.keys()
rez = 0
add = []
remove = []
c = 0
prev_comp = []
while len(v) > 0:
    cycle_pairs,cycles,comp = dfs(g,v[0])
    for x in comp:
        v.remove(x)
    rez += len(cycles)
    remove.extend(cycle_pairs)
    if c != 0:
        add.append((prev_comp[0],comp[0]))
    prev_comp = comp
    c+=1

print len(add)
for i in range(len(add)):
    print "%d %d %d %d" % (remove[i][0],remove[i][1],add[i][0],add[i][1])
