#include <bits/stdc++.h>

using namespace std;

#define F first
#define S second

#define endl '\n'

#define mp make_pair
#define pb push_back

#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define ROF(i, a, b) for(int i = a; i >= b; i--)

#define type(x) __typeof((x).begin())
#define foreach(i, x) for(type(x) i = (x).begin(); i != (x).end(); i++)

#define sol (root + root)
#define sag (root + root + 1)
#define orta ((bas + son) >> 1)

#define bit __builtin_popcount

#ifndef D
	#define dbg(x) 0
	#define dbgs(x) 0
#else
	#define dbg(x) cerr << (#x) << " --> " << (x) << endl
	#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#endif

typedef long long ll;
typedef pair < int, int > pii;

const int inf = 1e9 + 5;
const ll linf = 1e18 + 5;

const int N = 1e5 + 5;
const int M = 10 + 1;
const int SQRT = 1000;
const int K = N / SQRT + 5;

int n, m, q, x, y, beg[K], end[K];
char c;
pii go[N][M];
char a[N][M];

void init(int x) {

	FOR(i, beg[x], end[x]) {
		FOR(j, 1, m)
			go[i][j] = mp(0, 0);

		FOR(j, 1, m) {
			if(a[i][j] == '^')
				if(i == beg[x])
					go[i][j] = mp(i - 1, j);
				else
					go[i][j] = go[i - 1][j];

			if(a[i][j] == '>' and a[i][j + 1] == '<') {
				go[i][j] = mp(-1, -1);
				go[i][j + 1] = mp(-1, -1);
			}
		}

		FOR(j, 1, m) {
			if(a[i][j] == '<')
				if(j == 1)
					go[i][j] = mp(i, j - 1);
				else
					go[i][j] = go[i][j - 1];
		}

		ROF(j, m, 1) {
			if(a[i][j] == '>')
				if(j == m)
					go[i][j] = mp(i, j + 1);
				else
					go[i][j] = go[i][j + 1];
		}
	}

}

int main() {
	
	cin >> n >> m >> q;

	FOR(i, 1, n)
		scanf("%s", a[i] + 1);

	FOR(i, 1, (n + SQRT - 1) / SQRT) {
		beg[i] = (i - 1) * SQRT + 1;
		end[i] = min(n, i * SQRT);
		init(i);
	}

	FOR(i, 1, q) {
		cin >> c >> x >> y;

		if(c == 'A') {
			while(x >= 1 and x <= n and y >= 1 and y <= m) {
				int p = go[x][y].F;
				int q = go[x][y].S;
				x = p;
				y = q;
			}
			cout << x << ' ' << y << endl;
		}
		else {
			cin >> c;
			a[x][y] = c;
			init((x - 1) / SQRT + 1);
		}
	}

	return 0;

}
