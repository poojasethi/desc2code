#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

#define INF ((int)(1e9+5))

int d[200005], v[200005], q[200005], qr, qw, f[200005][2]; bool b[200005];

int spfa(int n, int h[], int e[][4], int S, int T) {
	for (int i=0; i<n; ++i) d[i] = i == S ? 0 : INF;
	memset(v, 0, sizeof(v));
	v[S] = 1;
	qr = qw = 0;
	q[qw++] = S;
	memset(b, true, sizeof(b));
	b[S] = false;
	while (qr != qw) {
		int x = q[qr++];
		if (qr == 200005) qr = 0;
		b[x] = true;
		for (int i=h[x]; i!=-1; i=e[i][3]) {
			int y = e[i][0], z = e[i][1];
			if (d[x] + z < d[y]) {
				d[y] = d[x] + z;
				f[y][0] = x;
				f[y][1] = e[i][2];
				if (b[y]) {
//					if ((++v[y])>n) return -1;
					b[y] = false;
					q[qw++] = y;
					if (qw == 200005) qw = 0;
				}
			}
		}
	}
//	if (
	return d[T];
}

struct edge {
	int x, y, z, i;
}ed[100005];

int n, L, xi, di, ti, pi, m, s[200005], sw, h[200005], e[510000][4], ew;

void adde(int x, int y, int z, int i) {
//printf("%d %d %d %d\n", x, y, z, i);
	e[ew][0] = y;
	e[ew][1] = z;
	e[ew][2] = i;
	e[ew][3] = h[x];
	h[x] = ew++;
}

int main() {
	scanf("%d%d", &n, &L);
	m = 0;
	for (int i=0; i<n; ++i) {
		scanf("%d%d%d%d", &xi, &di, &ti, &pi);
		ed[m].x = xi - pi;
		ed[m].y = xi + di;
		ed[m].z = pi + ti;
		ed[m].i = i + 1;
		if (ed[m].x >= 0 && ti < di) m++;
	}
	sw = 0;
	for (int i=0; i<m; ++i) {
		s[sw++] = ed[i].x;
		s[sw++] = ed[i].y;
	}
	s[sw++] = 0;
	s[sw++] = L;
	sort(s, s+sw);
	sw = (int)(unique(s, s+sw) - s);
	memset(h, -1, sizeof(h));
	ew = 0;
	for (int i=1; i<sw; ++i) {
		adde(i-1, i, s[i]-s[i-1], -1);
		adde(i, i-1, s[i]-s[i-1], -1);
	}
	for (int i=0; i<m; ++i) {
		ed[i].x = (int)(lower_bound(s, s+sw, ed[i].x) - s);
		ed[i].y = (int)(lower_bound(s, s+sw, ed[i].y) - s);
		adde(ed[i].x, ed[i].y, ed[i].z, ed[i].i);
	}
	printf("%d\n", spfa(sw, h, e, 0, sw-1));
	qw = 0;
	for (int i=sw-1; i!=0; i=f[i][0]) {
		if (f[i][1] != -1) q[qw++] = f[i][1];
	}
	printf("%d\n", qw);
	for (int i=qw-1; i>=0; --i) {
		printf("%d%c", q[i], i==0?'\n':' ');
	}
	
	return 0;
}
