#include <cstdio>
#include <algorithm>
#include <cstring>
#include <queue>
#define N 100005
using namespace std;

struct ramp{
	int x, d, t, p;
	void read(){
		scanf("%d%d%d%d", &x, &d, &t, &p);
	}
};

struct node{
	int x, y, w;
	node(){}
	node(int x, int y, int w): x(x), y(y), w(w){}
	bool operator < (node const &T) const{return y > T.y;}
};

int n, m, L, st, ed, x, y, ret;
int u[N], f[N*2], v[N*2], p[N*2], l[N*2], qd[N*5], qn[N*5], ql[N*5], qz[N*5], qf[N*5];
ramp a[N];
node cur;
priority_queue<node> q;

void bd(int x, int y, int w, int z){
	qd[++ed] = y, ql[ed] = w, qn[ed] = l[x], l[x] = ed, qz[ed] = z, qf[ed] = x;
}

int main(){
	scanf("%d%d", &n, &L);
	m = 0;
	for (int i=0; i<n; i++){
		a[i].read();
		p[m++] = a[i].x - a[i].p;
		p[m++] = a[i].x + a[i].d;
	}
	p[m++] = 0;
	p[m++] = L;
	sort(p, p + m);

	// normal edge
	for (int i=0; i<m-1; i++)
	if (p[i] >= 0){
		bd(i, i+1, p[i+1] - p[i], 0);
		bd(i+1, i, p[i+1] - p[i], 0);
	}

	// fly edge
	for (int i=0; i<n; i++){
		if (a[i].p > a[i].x) continue;
		x = lower_bound(p, p+m, a[i].x - a[i].p) - p;
		y = lower_bound(p, p+m, a[i].x + a[i].d) - p;
		bd(x, y, a[i].t + a[i].p, i + 1);
	}
	
	for (int i=0; i<m; i++){
		if (p[i] == 0) st = i;
		if (p[i] == L) ed = i;
		v[i] = (1<<30);
	}

	q.push(node(st, 0, 0));
	while (!q.empty()){
		cur = q.top();
		q.pop();
		if (v[cur.x] != (1<<30)) continue;
		v[cur.x] = cur.y;
		f[cur.x] = cur.w;
		for (int i=l[cur.x]; i; i=qn[i]) q.push(node(qd[i], cur.y + ql[i], i));
	}

	printf("%d\n", v[ed]);
	x = ed;
	ret = 0;
	while (x != st){
		if (qz[f[x]]) u[ret++] = qz[f[x]];
		x = qf[f[x]];
	}
	printf("%d\n", ret);
	for (int i=ret-1; i>=0; i--) printf("%d%c", u[i], i ? ' ':'\n');
	return 0;
}
