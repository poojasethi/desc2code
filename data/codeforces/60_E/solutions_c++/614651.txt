#include <vector>
#include <iostream>
#include <numeric>

using namespace std;


#define all(v) (v).begin(), (v).end()
#define PB push_back
#define sz size()

typedef long long ll;
typedef vector < vector < ll > > matrix;


ll MOD;

vector <ll> b;
ll s0 = 0;

ll powmod(ll n, ll exp) {
    ll r = 1;
    ll a = (ll) n;
    while (exp) {
        if (exp & 1) {
            r = (r * a) % MOD;
        }
        a = (a * a) % MOD;
        exp >>= 1;
    }
    return r;
}

ll sum(ll i) {
    if (i < 1)
        return 0LL;
    ll r = 0;
    if (i & 1) {
        r = powmod(3, i - 1);
    }
    i >>= 1;
    return (r + (powmod(3, i) + 1) * sum(i) % MOD) % MOD;
}

ll s(ll i, ll x) {
    ll q = powmod(3, i);
    return (q * s0 % MOD - (ll) sum(i) % MOD * (b[0] + x) % MOD + MOD) % MOD;
}

matrix mult(matrix A, matrix B) {
    matrix C(2, vector < ll > (2));
    for (int i = 0; i < A.sz; ++i)
        for (int j = 0; j < B[0].sz; ++j)
            for (int k = 0; k < B.sz; ++k)
                C[i][j] = (C[i][j] + A[i][k] * B[k][j] % MOD) % MOD;
    return C;
}

ll fib(ll i) {
    if (i < 2)
        return max(i, 0LL);
    matrix M(2, vector < ll > (2));
    matrix I(2, vector < ll > (2));
    M[0][0] = M[0][1] = M[1][0] = 1LL;
    I[0][0] = I[1][1] = 1LL;
    ll exp = i - 1;
    matrix r = I;
    matrix a = M;
    while (exp) {
        if (exp & 1) {
            r = mult(r, a);
        }
        a = mult(a, a);
        exp >>= 1;
    }
    return r[0][0];
}

int main() {
    int n;
    ll x, y, r;
    cin >> n >> x >> y >> MOD;
    
    for (int i = 0; i < n; ++i) {
        cin >> r;
        b.PB(r);
        s0 = (r + s0) % MOD;
    }
    s0 = s(x, b[b.sz - 1]);
    if (b.sz == 1)
        cout << s0 << endl;
    else
        cout << s(y, (b[b.sz - 1] * fib(x + 1) % MOD+ b[b.sz - 2] * fib(x)) % MOD)<< endl;
    return 0;
}
