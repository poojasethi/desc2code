#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <map>
#include <set>
#include <algorithm>
#include <cmath>
#include <ctime>
#include <cstdlib>
#include <queue>

#define LL long long
#define mp(x, y) make_pair(x, y)
#define pb(x) push_back(x)
#define size(S) S.size()
#define PII pair<int, int>
#define PID pair<int, double>

using namespace std;

int n;
LL x, y, p, a, b, S, tmp;
struct matrix{LL data[2][2];} T;

inline matrix operator * (const matrix &a, const matrix &b){
	memset(T.data, 0, sizeof(T.data));
	T.data[0][0] = (a.data[0][0] * b.data[0][0] + a.data[0][1] * b.data[1][0]) % p;
	T.data[0][1] = (a.data[0][0] * b.data[0][1] + a.data[0][1] * b.data[1][1]) % p;
	T.data[1][0] = (a.data[1][0] * b.data[0][0] + a.data[1][1] * b.data[1][0]) % p;
	T.data[1][1] = (a.data[1][0] * b.data[0][1] + a.data[1][1] * b.data[1][1]) % p;
	return T;
}

inline matrix power(const matrix &o, LL e){
	if (e == 1) return o;
	matrix ret = power(o, e/2);
	ret = ret * ret;
	if (e%2) ret = ret * o;
	return ret;
}

inline LL MAX(LL a, LL b, LL e){
	if (e == 0) return b;
	matrix s;
	s.data[0][0] = 0; s.data[0][1] = s.data[1][0] = s.data[1][1] = 1;
	s = power(s, e);
	return (a * s.data[1][0] + b * s.data[1][1]) % p;
}

inline LL calc(LL s, LL e, LL m){
	if (e == 0) return s;
	matrix M;
	M.data[0][0] = 3; M.data[0][1] = 0; M.data[1][0] = -1; M.data[1][1] = 1;
	M = power(M, e);
	return (s * M.data[0][0] + m * M.data[1][0]) % p;
}

int main(){
	cin >> n >> x >> y >> p;
	cin >> a; S = a;
	if (n == 1){
		cout << a % p << endl;
		return 0;
	}
	for (int i = 1; i < n - 2; i++) cin >> tmp, S = (S + tmp) % p;
	if (n > 3) cin >> tmp >> b; else cin >> b, tmp = a;
	S = (S + b + tmp) % p;
	if (n == 2) S -= tmp;
	S = calc(S, x, (a + b) % p);
	b = MAX(tmp, b, x);
	LL ans = calc(S, y, (a + b) % p) % p;
	ans = (ans + p) % p;
	cout << ans << endl;
	return 0;
}
