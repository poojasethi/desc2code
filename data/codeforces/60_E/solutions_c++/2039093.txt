#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1000010;

typedef long long ll;

int n, p;
int a[N];
ll s0, sx, sy, x, y;

struct Matrix
{
    ll a[2][2];
    Matrix operator * (const Matrix &o) const
    {
        Matrix ret;
        memset(ret.a, 0, sizeof(ret.a));
        for(int i = 0; i < 2; ++i)
            for(int j = 0 ; j < 2; ++j)
                for(int k = 0; k < 2; ++k)
                    ret.a[i][j] = (ret.a[i][j] + a[i][k] * o.a[k][j] % p) % p;
        return ret;
    }
    void unit()
    {
        a[0][0] = a[1][1] = 1;
        a[1][0] = a[0][1] = 0;
    }
};
ll cal(int a0, int a1, ll it)
{
    Matrix o, s;
    o.unit();
    s.a[0][0] = s.a[0][1] = s.a[1][0] = 1, s.a[1][1] = 0;
    while(it)
    {
        if(it & 1) o = o * s;
        it >>= 1;
        s = s * s;
    }
    return (o.a[0][0] * a1 % p + o.a[0][1] * a0 % p) % p;
}
ll powMod(ll x, ll y)
{
    ll ret = 1;
    while(y)
    {
        if(y & 1) ret = (ret * x) % p;
        y >>= 1;
        x = x * x % p;
    }
    return ret;
}
ll powMod2(ll x,ll y)
{
    if(y == 0) return 1;
    ll ret = powMod2(x, y >> 1), tem = powMod(x, (y + 1) >> 1);
    if(y & 1)
        ret = (ret * tem % p + ret) % p;
    else
        ret = (ret * tem % p + ret - tem + p) % p;
    return ret;
}
int main()
{
//    freopen("in.txt", "r", stdin);
    cin >> n >> x >> y >> p;
    s0 = 0;
    for(int i = 0; i < n; ++i)
        cin >> a[i], s0 = (s0 + a[i]) % p;
    sx = x == 0 ? s0 : (powMod(3, x) * s0 % p - powMod2(3, x - 1) * (a[0] + a[n - 1]) % p + p) % p;
    ll down = a[0], up = cal(a[n - 2], a[n - 1], x);
    sy = y == 0 ? sx : (powMod(3, y) * sx % p - powMod2(3, y - 1) * (down + up) % p + p) % p;
    cout << sy << endl;
    return 0;
}
