#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<set>
#include<vector>
using namespace std;

typedef long long LL;

#define mp make_pair
#define pb push_back
const int maxn = 1000005;
int n;
int a[ maxn ];
LL x, y, p;

int powmod(LL a, LL b, int c){
	LL ret = 1 % c;
	while(b){
		if(b&0x1)ret=ret*a%c;
		a=a*a%c;
		b>>=1;
	}
	return ret;
}

LL g(LL x){
	if(x == 0) return 0;
	if(x == 1) return 1 % p;
	if(x % 2 == 1) {
		LL hf = g(x/2);
		return (hf + powmod(3, x/2,p) + powmod(3,x/2+1,p)*hf % p) % p;
	}
	return (powmod( 3, x-1, p) + g(x-1)) % p;
}
inline LL MOD(LL a){
	a %= p;
	if(a<0) a+=p;
	return a;
}
LL cal( LL a0, LL b0, LL t, LL s0){
	a0 %= p; b0 %= p; s0 %= p;
	//cout << a0 <<' '<< b0 <<' '<< t <<' '<<s0 << endl;
	LL c=a0+b0;
	return MOD(powmod( 3, t, p) * s0 % p - g(t) *c % p );
}

struct Mat{
	LL mat[2][2];
	Mat operator*(const Mat M){
		int i,j,k;
		Mat ret;
		for(int i=0;i<2;++i) for(int j=0;j<2;++j){
			ret.mat[i][j]=0;
			LL now = 0;
			for(int k=0;k<2;++k){
				now = (now + mat[i][k] * M.mat[k][j] % p) % p;
			}
			ret.mat[i][j] = now;
		}
		return ret;
	}
	Mat pow(LL k){
		-- k;
		Mat a=*this, ret = *this;
		while(k){
			if(k&1)ret=ret*a;
			a=a*a;
			k>>=1;
		}
		return ret;
	}
};
LL get_max(LL t){
	if(t == 0) return a[n-1]%p;
	if(t == 1) return (a[n-1] + a[n-2])%p;
	LL f0=a[n-1]%p;
	LL f1=(a[n-1] + a[n-2])%p;
	Mat m;
	m.mat[0][0] = m.mat[0][1] =m.mat[1][0] = 1 % p;
	m.mat[1][1]=0;
	m=m.pow( t-1);
	return (m.mat[0][0] * f1 % p  + m.mat[0][1] * f0 % p);
}
int main(){
	while(cin >> n ) {
		cin >> x >> y >> p;
		for(int i=0;i<n;++i) scanf("%d", a + i);
		if(n ==1){
			cout << a[0] %  p << endl;
			continue;
		}
		LL a0 = a[0], b0 = a[n - 1], s = 0;
		for(int i=0;i<n;++i) s += a[i];
		if(x){
			s=cal(a0,b0,x,s);
		}
		if(y){
			s=cal(a0,get_max(x),y,s);
		}
		cout << s << endl;
	}
    return 0;
}

	  				   	 	 	 	  	 				