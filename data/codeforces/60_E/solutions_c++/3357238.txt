#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <cassert>
#include <sstream>
#include <numeric>
#include <climits>
#include <string>
#include <cctype>
#include <ctime>
#include <iomanip>
#include <cmath>
#include <vector>
#include <queue>
#include <list>
#include <map>
#include <set>
using namespace std;

#define foreach(e, x) for (__typeof((x).begin()) e = (x).begin(); e != (x).end(); ++e)

typedef long long int64;

const int MAX_N = (int)1e6 + 10;

int n, mod;
int64 x, y;
int a[MAX_N];

struct Matrix {
	int c[2][2];
	Matrix() {
		c[0][0] = c[0][1] = c[1][0] = c[1][1] = 0;
	}
};

Matrix operator *(const Matrix &a, const Matrix &b) {
	Matrix c;
	for (int k = 0; k < 2; ++k) {
		for (int i = 0; i < 2; ++i) {
			for (int j = 0; j < 2; ++j) {
				c.c[i][j] = (c.c[i][j] + (int64)a.c[i][k] * b.c[k][j] % mod) % mod;
			}
		}
	}
	return c;
}

Matrix pow_mod(Matrix a, int64 b) {
	Matrix ret;
	ret.c[0][0] = ret.c[1][1] = 1;
	for (; b; b >>= 1, a = a * a) {
		if (b & 1) {
			ret = ret * a;
		}
	}
	return ret;
}

int calc() {
	Matrix tran_mat;
	tran_mat.c[0][0] = tran_mat.c[0][1] = tran_mat.c[1][0] = 1;
	tran_mat = pow_mod(tran_mat, x);
	return ((int64)tran_mat.c[0][0] * a[n - 1] + (int64)tran_mat.c[1][0] * a[n - 2]) % mod;
}

int main() {
	cin >> n >> x >> y >> mod;
	int s = 0;
	for (int i = 0; i < n; ++i) {
		scanf("%d", a + i);
		s = (s + a[i] % mod) % mod;
	}
	if (n == 1) {
		return printf("%d\n", a[0] % mod), 0;
	}
	Matrix tran_mat;
	tran_mat.c[0][1] = tran_mat.c[1][1] = 1;
	tran_mat.c[0][0] = 3;
	tran_mat = pow_mod(tran_mat, x);
	s = ((int64)s * tran_mat.c[0][0] - tran_mat.c[0][1] * 1LL * (a[0] + a[n - 1])) % mod;
	tran_mat.c[0][1] = tran_mat.c[1][1] = 1;
	tran_mat.c[0][0] = 3;
	tran_mat.c[1][0] = 0;
	tran_mat = pow_mod(tran_mat, y);
	s = ((int64)s * tran_mat.c[0][0] - tran_mat.c[0][1] * 1LL * (a[0] + calc())) % mod;
	printf("%d\n", (s + mod) % mod);
}

