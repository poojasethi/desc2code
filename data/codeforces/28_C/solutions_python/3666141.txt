import math


def fill_binomial():
    global n_students

    C = []

    for n in range(n_students + 1):
        C.append([0] * (n + 1))
        C[n][0] = C[n][n] = 1

    for n in range(1, n_students + 1):
        for k in range(1, n):
            C[n][k] = C[n-1][k] + C[n-1][k-1]

    return C


def ways_with(students_left, rooms_left):
    global C, baths_at, n_students, n_rooms, mem

    if (students_left, rooms_left) in mem:
        return mem[students_left, rooms_left]

    answer = [0] * (n_students + 1)

    if students_left == 0:
        answer[0] = 1
        mem[students_left, rooms_left] = answer
        return answer

    elif rooms_left == 1:
        room_queue = int(math.ceil(students_left / baths_at[0]))
        answer[room_queue] += 1
        mem[students_left, rooms_left] = answer
        return answer

    for taken in range(students_left, -1, -1):
        ways_left = ways_with(students_left - taken, rooms_left - 1)
        room_queue = int(math.ceil(taken / baths_at[rooms_left-1]))

        answer[room_queue] += C[students_left][taken] * sum(ways_left[:room_queue])        
        for n in range(room_queue, students_left + 1):
            answer[n] += C[students_left][taken] * ways_left[n]
        

    mem[students_left, rooms_left] = answer

    return answer


n_students, n_rooms = map(int, raw_input().split())
baths_at = map(float, raw_input().split())

mem = {}
C = fill_binomial()
answer = ways_with(n_students, n_rooms)

expected = 0
total_ways = float(sum(answer))

for n in range(1, n_students + 1):
    expected += n * answer[n] / total_ways
    

#print answer
print expected

