#include <cstdio>
#include <algorithm>
using namespace std;
const int mod = 95542721;
const int M = 1 << 18;
const int LP = 48;
long long sd[M*2][LP];
int lazy[M*2];
inline void relax(int p) {
	lazy[p] %= LP;
	if (lazy[p]) {
		rotate(sd[p], sd[p] + lazy[p], sd[p] + LP);
		if (p < M) {
			lazy[p*2] += lazy[p];
			lazy[p*2+1] += lazy[p];
		}
		lazy[p] = 0;
	}
}
inline void update(int p) {
	for (int i = 0; i < LP; i++) {
		sd[p][i] = (sd[p*2][i] + sd[p*2+1][i]) % mod;
	}
}
long long qs(int l, int r, int p, int L, int R) {
	relax(p);
	if (r <= L || R <= l) {
		return 0;
	}
	if (l <= L && R <= r) {
		return sd[p][0];
	}
	long long vl = qs(l, r, p*2, L, (L+R)/2);
	long long vr = qs(l, r, p*2+1, (L+R)/2, R);
	return (vl + vr) % mod;
}
void query(int l, int r, int p, int L, int R) {
	relax(p);
	if (r <= L || R <= l) {
		return;
	}
	if (l <= L && R <= r) {
		lazy[p]++;
		relax(p);
		return;
	}
	query(l, r, p*2, L, (L+R)/2);
	query(l, r, p*2+1, (L+R)/2, R);
	update(p);
}
int a[M];
void init(int p) {
	if (p < M) {
		init(p*2);
		init(p*2+1);
		update(p);
	} else {
		sd[p][0] = a[p-M];
		for (int i = 1; i < LP; i++) {
			sd[p][i] = sd[p][i-1] * sd[p][i-1] % mod * sd[p][i-1] % mod;
		}
	}
}
int main() {
	int N, T;
	scanf("%d", &N);
	for (int i = 0; i < N; i++) {
		scanf("%d", &a[i]);
	}
	init(1);
	scanf("%d", &T);
	for (int i = 0; i < T; i++) {
		int type, l, r;
		scanf("%d%d%d", &type, &l, &r);
		if (type == 1) {
			printf("%I64d\n", qs(--l, r, 1, 0, M));
		} else {
			query(--l, r, 1, 0, M);
		}
	}
	return 0;
}
