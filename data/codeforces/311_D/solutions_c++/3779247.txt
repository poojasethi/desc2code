#include<stdio.h>
#include<iostream>
#include<string.h>
#include<stdlib.h>
#include<algorithm>
#include<vector>
using namespace std;
#define fr(i,n)for(int i=0;i<n;i++)
#define fo(i,n)for(int i=1;i<=n;i++)
#define fe(i,n)for(__typeof(n.begin())i=n.begin();i!=n.end();i++)
const int p=95542721;
struct N
{
	int s[48],w;
}T[300000];
int v[300000];
#define P(l,r)(((l)+(r)-1)|((l)!=(r)-1))
void update(N *t,N *l,N *r)
{
	fr(i,48)
	{
		t->s[i]=l->s[(i+l->w)%48]+r->s[(i+r->w)%48];
		if(t->s[i]>=p)
			t->s[i]-=p;
	}
}
void put_w(N *t,int x)
{
	(t->w+=x)%=48;
}
void cg(int L,int R,int t,int l,int r)
{
	if(L<=l&&r<=R)
		return put_w(T+t,1);
	int m=(l+r+1)>>1,lc=P(l,m),rc=P(m,r);
	if(L<m)
		cg(L,R,lc,l,m);
	if(m<R)
		cg(L,R,rc,m,r);
	update(T+t,T+lc,T+rc);
}
void ___(N *t,int x)
{
	t->w=0,t->s[0]=v[x];
	fo(i,47)
		t->s[i]=(long long)t->s[i-1]*t->s[i-1]%p*t->s[i-1]%p;
}
void bd(int t,int l,int r)
{
	if(l+1==r)
		return ___(T+t,r);
	int m=(l+r+1)>>1,lc=P(l,m),rc=P(m,r);
	bd(lc,l,m);
	bd(rc,m,r);
	update(T+t,T+lc,T+rc);
}

int qy(int L,int R,int t,int l,int r,int w)
{
	if(L<=l&&r<=R)
		return T[t].s[(T[t].w+w)%48];
	int m=(l+r+1)>>1,lc=P(l,m),rc=P(m,r),re=0;
	w+=T[t].w;
	if(L<m)
		re+=qy(L,R,lc,l,m,w);
	if(m<R)
		re+=qy(L,R,rc,m,r,w);
	return re>=p?(re-p):re;
}
int main()
{
	int n,m;
	cin>>n;
	fo(i,n)
	{
		scanf("%d",v+i);
		v[i]%=p;
	}
	bd(P(0,n),0,n);
	cin>>m;
	for(;m--;)
	{
		int o,L,R;
		scanf("%d%d%d",&o,&L,&R);
		if(o==2)
			cg(L-1,R,P(0,n),0,n);
		else
			printf("%d\n",qy(L-1,R,P(0,n),0,n,0));
	}
	return 0; 
}