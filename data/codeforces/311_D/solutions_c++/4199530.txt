#include <iostream>
#include <cstdio>

using namespace std;

const int maxN = 100000+10, mod = 95542721, Cyc = 48;

int n, q, a[maxN];
long long ans;

long long add(long long x)
{
	while (x >= mod)
		x -= mod;
	return x;
}

struct Node
{
	int cnt;
	long long dp[Cyc];
};

struct Segment_Tree
{
	Node tree[3*maxN];
	void build(int v, int L, int R)
	{
		if (L == R)
		{
			tree[v].dp[0] = a[L];
			for (int i = 1 ; i < Cyc ; i++)
			{
				tree[v].dp[i] = 1;
				for (int j = 1 ; j <= 3 ; j++)
					tree[v].dp[i] = (tree[v].dp[i] * tree[v].dp[i-1]) % mod;
			}
			return;
		}
		int mid = (R+L) >> 1;
		build(2*v, L, mid);
		build(2*v+1, mid+1, R);
		for (int i = 0 ; i < Cyc ; i++)
			tree[v].dp[i] = add(tree[2*v].dp[i]+tree[2*v+1].dp[i]);
	}
	void update(int v, int L, int R, int l, int r)
	{
		if (l > r)
			return;
		if (L == l && R == r)
		{
			tree[v].cnt++;
			return;
		}
		int mid = (L+R) >> 1;
		update(2*v, L, mid, l, min(r, mid));
		update(2*v+1, mid+1, R, max(l, mid+1), r);
		for (int i = 0 ; i < Cyc ; i++)
			tree[v].dp[i] = add(tree[2*v].dp[(i+tree[2*v].cnt)%Cyc]+tree[2*v+1].dp[(i+tree[2*v+1].cnt)%Cyc]);
	}
	void query(int v, int L, int R, int l, int r, int carry)
	{
		if (l > r)
			return;
		if (L == l && R == r)
		{
			ans = add(ans + tree[v].dp[(tree[v].cnt+carry)%Cyc]);
			return;
		}
		carry += tree[v].cnt;
		int mid = (L+R) >> 1;
		query(2*v, L, mid, l, min(r, mid), carry);
		query(2*v+1, mid+1, R, max(l, mid+1), r, carry);
	}
} A;

int main()
{
	scanf("%d", &n);
	for (int i = 1 ; i <= n ; i++)
	{
		scanf("%d", a+i);
		a[i] %= mod;
	}
	A.build(1, 1, n);
	scanf("%d", &q);
	while (q--)
	{
		int t, l, r;
		scanf("%d%d%d", &t, &l, &r);
		if (t == 1)
		{
			ans = 0;
			A.query(1, 1, n, l, r, 0);
			printf("%lld\n", ans%mod);
		}
		else
			A.update(1, 1, n, l, r);
	}
	return 0;
}
