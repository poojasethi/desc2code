#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <cmath>
#include <ctime>
#include <map>
using namespace std;

const int P = 17239;
const int Q = 23917;
const int mdl = 10000001;

struct creature
{
  int pos, movedist, falldist, canup, parent;
  creature(int pos, int movedist, int falldist): pos(pos), movedist(movedist), falldist(falldist), canup(true), parent(-1) {}
  creature() {}
  int hash()
  {
    return (((pos * P + movedist) * P + falldist) * P + canup) * P + parent;
  }
};

struct state {
  creature creatures[3];
  int getmaxpos()
  {
    return max(max(creatures[0].pos, creatures[1].pos), creatures[2].pos);
  }
  bool is_busy(int x)
  {
    return (x <= 0) || (creatures[0].pos == x) || (creatures[1].pos == x) || (creatures[2].pos == x);
  }
  int hash()
  {
    int res = 0;
    for (int i = 0; i < 3; ++i)
      res = res * Q + creatures[i].hash();
    return res;
  }
};

int best;
bool used[mdl];

void go(state s)
{
  int hs = (s.hash() % mdl + mdl) % mdl;
  if (used[hs]) return;
  used[hs] = true;
  best = max(best, s.getmaxpos());
  for (int i = 0; i < 3; ++i)
    if (s.creatures[i].parent == -1)
      {
	int child = -1;
	for (int j = 0; j < 3; ++j)
	  if (s.creatures[j].parent == i)
	    {
	      child = j;
	      break;
	    }
	//move
	if (child == -1)
	  for (int j = -s.creatures[i].movedist; j <= s.creatures[i].movedist; ++j)
	    if (!s.is_busy(s.creatures[i].pos + j))
	      {
		state ns = s;
		ns.creatures[i].pos = s.creatures[i].pos + j;
		ns.creatures[i].movedist = 0;
		go(ns);
	      }
	//pick
	if (s.creatures[i].canup)
	  for (int j = 0; j < 3; ++j)
	    if ((s.creatures[j].parent == -1) && (abs(s.creatures[i].pos - s.creatures[j].pos) == 1))
	      {
		state ns = s;
		ns.creatures[j].parent = i;
		ns.creatures[j].pos = s.creatures[i].pos;
		ns.creatures[i].canup = false;
		go(ns);
	      }
	//fall
	if (child != -1)
	  for (int k = -s.creatures[i].falldist; k <= s.creatures[i].falldist; ++k)
	    if (!s.is_busy(s.creatures[i].pos + k))
	      {
		state ns = s;
		ns.creatures[child].parent = -1;
		ns.creatures[child].pos = s.creatures[i].pos + k;
		ns.creatures[i].falldist = 0;
		go(ns);
	      }
      }
}

int main()
{
  state s;
  for (int i = 0; i < 3; ++i)
    {
      int pos, md, fd;
      scanf("%d%d%d", &pos, &md, &fd);
      s.creatures[i] = creature(pos, md, fd);
    }
  best = 0;
  go(s);
  printf("%d\n", best);
  return 0;
}
