#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <cmath>
#include <ctime>
#include <map>
using namespace std;

const int P = 17239;
const int Q = 23917;
const int mdl = 30000001;

struct creature {
	int pos, movedist, falldist, canup, parent;
	creature(int pos, int movedist, int falldist): pos(pos), movedist(movedist), falldist(falldist), canup(true), parent(-1) {}
	creature() {}
	void print() {
		printf("[%d (%d, %d, %d) {%d}] ", pos, movedist, falldist, canup, parent);
	}
	int hash() {
		return ((((pos + 1) * P + movedist + 1) * P + falldist + 1) * P + canup + 1) * P + parent + 2;
	}
};

struct state {
	creature creatures[3];
	int getmaxpos() {
		return max(max(creatures[0].pos, creatures[1].pos), creatures[2].pos);
	}
	bool is_busy(int x) {
		return (x <= 0) || (creatures[0].pos == x) || (creatures[1].pos == x) || (creatures[2].pos == x);
	}
	void print() {
		for (int i = 0; i < 3; ++i)
			creatures[i].print();
		printf("\n");
	}
	int hash() {
		int res = 0;
		for (int i = 0; i < 3; ++i)
			res = res * Q + creatures[i].hash() + 1;
		return res;
	}
};

bool operator < (state a, state b) {
	return a.hash() < b.hash();
}

int best;
bool used[mdl];

void go(state s) {
	int hs = (s.hash() % mdl + mdl) % mdl;
	if (used[hs]) return;
	used[hs] = true;
	best = max(best, s.getmaxpos());
	for (int i = 0; i < 3; ++i)
		if (s.creatures[i].parent == -1) {
			int child = -1;
			for (int j = 0; j < 3; ++j)
				if (s.creatures[j].parent == i) {
					child = j;
					break;
				}
			//move
			if (child == -1)
				for (int j = -s.creatures[i].movedist; j <= s.creatures[i].movedist; ++j)
					if (!s.is_busy(s.creatures[i].pos + j)) {
						state ns = s;
						ns.creatures[i].pos = s.creatures[i].pos + j;
						ns.creatures[i].movedist = 0;
						go(ns);
					}
			//pick
			if (s.creatures[i].canup)
				for (int j = 0; j < 3; ++j)
					if ((s.creatures[j].parent == -1) && (abs(s.creatures[i].pos - s.creatures[j].pos) == 1)) {
						state ns = s;
						ns.creatures[j].parent = i;
						ns.creatures[j].pos = s.creatures[i].pos;
						ns.creatures[i].canup = false;
						go(ns);
					}
			//fall
			if (child != -1)
				for (int k = -s.creatures[i].falldist; k <= s.creatures[i].falldist; ++k)
					if (!s.is_busy(s.creatures[i].pos + k)) {
						state ns = s;
						ns.creatures[child].parent = -1;
						ns.creatures[child].pos = s.creatures[i].pos + k;
						ns.creatures[i].falldist = 0;
						go(ns);
					}
		}
}

int main() {
	double start = clock();
	state s;
	for (int i = 0; i < 3; ++i) {
		int pos, md, fd;
		scanf("%d%d%d", &pos, &md, &fd);
		s.creatures[i] = creature(pos, md, fd);
	}
	best = 0;
	go(s);
	printf("%d\n", best);
	fprintf(stderr, "%.2lf\n", (clock() - start) / CLOCKS_PER_SEC);
	return 0;
}