#include <stdio.h>
#include <math.h>
#include <algorithm>

using namespace std;

#define EPS 1E-6

inline int SG(double x) {
    if(x>-EPS && x<EPS) return 0;
    return x>0?1:-1;
}

class PT{
    public:
        double x,y;
        PT(){}
        PT(double _x,double _y) {
            x = _x; y = _y;
        }
        PT operator+(const PT& p) const {
            return PT(x+p.x,y+p.y);
        }
        PT operator-(const PT& p) const {
            return PT(x-p.x,y-p.y);
        }
        PT operator*(const double c) const {
            return PT(x*c,y*c);
        }
        PT operator/(const double c) const {
            return PT(x/c,y/c);
        }
};

PT pt[4][3];
PT qt[10];
double dist[10][10];
double c[4][3];
int list[4];
int u[4];
int maxd;

inline double dis(PT &p1,PT &p2) {
    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
}

inline void gen(PT p1,PT p2,double a,double b,PT &q1,PT &q2,PT &q3,PT &q4) {
    double c,d,z;
    PT o,g;
    c = dis(p1,p2);
    //printf("%.2f %.2f   %.2f %.2f   %.2f   %.2f\n",p1.x,p1.y,p2.x,p2.y,a,b);
    //printf("%.5f\n",z);
    if(SG(a+b-c)==0) {
        d = a;
        g = PT(0,0);
    }else {
        d = (a*a+c*c-b*b)/(c*2);
        z = sqrt(a*a-d*d);
        g = p2-p1;
        g = PT(g.y,-g.x)*(z/c);
    }
    o = (p2-p1)*(d/c)+p1;
    q1 = o+g;
    q2 = o-g;
    o = (p1-p2)*(d/c)+p2;
    q3 = o+g;
    q4 = o-g;
    /*printf("%.2f %.2f\n",q1.x,q1.y);
    printf("%.2f %.2f\n",q2.x,q2.y);
    printf("%.2f %.2f\n",q3.x,q3.y);
    printf("%.2f %.2f\n",q4.x,q4.y);*/
}

inline int add(PT p,int n) {
    int i;
    for( i=0; i<n; i++ ) {
        if(SG(qt[i].x-p.x)==0 && SG(qt[i].y-p.y)==0) return n;
    }
    qt[n] = p;
    for( i=0; i<n; i++ ) {
        dist[i][n] = dist[n][i] = dis(qt[i],p);
    }
    return n+1;
}

void dfs(int d,int n) {
    if(n>=maxd) return;
    int i,j,k,h,l,k1,k2,l1,l2,z,g;
    PT q1,q2,q3,q4,r1,r2,r3,r4,s1,s2,s3,s4;
    /*printf("%d  ",d);
      for( i=0; i<n; i++ ) {
      printf("(%.2f,%.2f) ",qt[i].x,qt[i].y);
      }
      puts("");*/
    if(d==4) {
        /*for( i=0; i<n; i++ ) {
            printf("(%.2f,%.2f) ",qt[i].x,qt[i].y);
        }
        puts("");*/
        maxd = n;
    }else {
        q1 = pt[d][1]-pt[d][0]+qt[0];
        q2 = pt[d][2]-pt[d][0]+qt[0];
        dfs(d+1,add(q1,add(q2,n)));
        for( i=0; i<n; i++ ) {
            for( j=i+1; j<n; j++ ) {
                for( k=0; k<3; k++ ) {
                    k1 = (k+1)%3;
                    k2 = (k+2)%3;
                    if(SG(dist[i][j]-c[d][k])==0) {
                        gen(qt[i],qt[j],c[d][k1],c[d][k2],q1,q2,q3,q4);
                        qt[n] = q1;
                        for( h=0; h<n; h++ ) {
                            dist[h][n] = dist[n][h] = dis(qt[h],qt[n]);
                        }
                        dfs(d+1,add(q1,n));
                        dfs(d+1,add(q2,n));
                        dfs(d+1,add(q3,n));
                        dfs(d+1,add(q4,n));
                    }
                    if(d==3) continue;
                    for( l=0; l<3; l++ ) {
                        l1 = (l+1)%3;
                        l2 = (l+2)%3;
                        if(SG(dist[i][j]-c[d][k]-c[d+1][l])<=0 && 
                                SG(c[d][k]-dist[i][j]-c[d+1][l])<=0 &&
                                SG(c[d+1][l]-c[d][k]-dist[i][j])<=0) {
                            //printf("@@@%.4f\n",dist[i][j]);
                            gen(qt[i],qt[j],c[d][k],c[d+1][l],q1,q2,q3,q4);
                            z = add(q1,n);
                            gen(qt[i],q1,c[d][k1],c[d][k2],r1,r2,r3,r4);
                            gen(qt[j],q1,c[d+1][l1],c[d+1][l2],s1,s2,s3,s4);
                            g = add(r1,z); dfs(d+2,add(s1,g)); dfs(d+2,add(s2,g)); dfs(d+2,add(s3,g)); dfs(d+2,add(s4,g)); 
                            g = add(r2,z); dfs(d+2,add(s1,g)); dfs(d+2,add(s2,g)); dfs(d+2,add(s3,g)); dfs(d+2,add(s4,g)); 
                            g = add(r3,z); dfs(d+2,add(s1,g)); dfs(d+2,add(s2,g)); dfs(d+2,add(s3,g)); dfs(d+2,add(s4,g)); 
                            g = add(r4,z); dfs(d+2,add(s1,g)); dfs(d+2,add(s2,g)); dfs(d+2,add(s3,g)); dfs(d+2,add(s4,g)); 
                            z = add(q2,n);
                            gen(qt[i],q2,c[d][k1],c[d][k2],r1,r2,r3,r4);
                            gen(qt[j],q2,c[d+1][l1],c[d+1][l2],s1,s2,s3,s4);
                            g = add(r1,z); dfs(d+2,add(s1,g)); dfs(d+2,add(s2,g)); dfs(d+2,add(s3,g)); dfs(d+2,add(s4,g)); 
                            g = add(r2,z); dfs(d+2,add(s1,g)); dfs(d+2,add(s2,g)); dfs(d+2,add(s3,g)); dfs(d+2,add(s4,g)); 
                            g = add(r3,z); dfs(d+2,add(s1,g)); dfs(d+2,add(s2,g)); dfs(d+2,add(s3,g)); dfs(d+2,add(s4,g)); 
                            g = add(r4,z); dfs(d+2,add(s1,g)); dfs(d+2,add(s2,g)); dfs(d+2,add(s3,g)); dfs(d+2,add(s4,g)); 
                            z = add(q3,n);
                            gen(qt[j],q3,c[d][k1],c[d][k2],r1,r2,r3,r4);
                            gen(qt[i],q3,c[d+1][l1],c[d+1][l2],s1,s2,s3,s4);
                            g = add(r1,z); dfs(d+2,add(s1,g)); dfs(d+2,add(s2,g)); dfs(d+2,add(s3,g)); dfs(d+2,add(s4,g)); 
                            g = add(r2,z); dfs(d+2,add(s1,g)); dfs(d+2,add(s2,g)); dfs(d+2,add(s3,g)); dfs(d+2,add(s4,g)); 
                            g = add(r3,z); dfs(d+2,add(s1,g)); dfs(d+2,add(s2,g)); dfs(d+2,add(s3,g)); dfs(d+2,add(s4,g)); 
                            g = add(r4,z); dfs(d+2,add(s1,g)); dfs(d+2,add(s2,g)); dfs(d+2,add(s3,g)); dfs(d+2,add(s4,g)); 
                            z = add(q4,n);
                            gen(qt[j],q4,c[d][k1],c[d][k2],r1,r2,r3,r4);
                            gen(qt[i],q4,c[d+1][l1],c[d+1][l2],s1,s2,s3,s4);
                            g = add(r1,z); dfs(d+2,add(s1,g)); dfs(d+2,add(s2,g)); dfs(d+2,add(s3,g)); dfs(d+2,add(s4,g)); 
                            g = add(r2,z); dfs(d+2,add(s1,g)); dfs(d+2,add(s2,g)); dfs(d+2,add(s3,g)); dfs(d+2,add(s4,g)); 
                            g = add(r3,z); dfs(d+2,add(s1,g)); dfs(d+2,add(s2,g)); dfs(d+2,add(s3,g)); dfs(d+2,add(s4,g)); 
                            g = add(r4,z); dfs(d+2,add(s1,g)); dfs(d+2,add(s2,g)); dfs(d+2,add(s3,g)); dfs(d+2,add(s4,g)); 
                        }
                    }
                }
            }
        }
    }
}

void per(int d) {
    int i,j;
    PT tmppt[4][3];
    double tmpc[4][3];
    if(d==4) {
        for( i=1; i<4; i++ ) {
            for( j=0; j<3; j++ ) {
                tmppt[i][j] = pt[i][j];
                tmpc[i][j] = c[i][j];
            }
        }
        for( i=1; i<4; i++ ) {
            for( j=0; j<3; j++ ) {
                pt[i][j] = tmppt[list[i]][j];
                c[i][j] = tmpc[list[i]][j];
            }
        }
        for( i=0; i<3; i++ ) {
            qt[i] = pt[0][i];
        }
        for( i=0; i<3; i++ ) {
            for( j=0; j<3; j++ ) {
                dist[i][j] = dis(qt[i],qt[j]);
            }
        }
        dfs(1,3);
        for( i=1; i<4; i++ ) {
            for( j=0; j<3; j++ ) {
                pt[i][j] = tmppt[i][j];
                c[i][j] = tmpc[i][j];
            }
        }
    }else {
        for( i=1; i<4; i++ ) {
            if(!u[i]) {
                u[i] = 1;
                list[d] = i;
                per(d+1);
                u[i] = 0;
            }
        }
    }
}

int main() {
    int i,j,k,h;
    double x,y;
    while(1) {
        for( i=0; i<4; i++ ) {
            if(scanf("%lf %lf %lf %lf %lf %lf",
                        &pt[i][0].x,&pt[i][0].y,&pt[i][1].x,&pt[i][1].y,&pt[i][2].x,&pt[i][2].y)!=6) return 0;
            c[i][0] = dis(pt[i][0],pt[i][1]);
            c[i][1] = dis(pt[i][1],pt[i][2]);
            c[i][2] = dis(pt[i][2],pt[i][0]);
            sort(c[i],c[i]+3);
        }
        maxd = 9;
        for( i=0; i<3; i++ ) {
            for( j=0; j<3; j++ ) {
                for( k=0; k<3; k++ ) {
                    for( h=0; h<3; h++ ) {
                        x = 0;
                        if(c[0][i]>x) x = c[0][i];
                        if(c[1][j]>x) x = c[1][j];
                        if(c[2][k]>x) x = c[2][k];
                        if(c[3][h]>x) x = c[3][h];
                        if(SG(x*2-(c[0][i]+c[1][j]+c[2][k]+c[3][h]))<=0) {
                            maxd = 8;
                            goto out;
                        }
                    }
                }
            }
        }
out:
        for( i=1; i<4; i++ ) {
            u[i] = 0;
        }
        per(1);
        printf("%d\n",maxd);
    }
    return 0;
}

