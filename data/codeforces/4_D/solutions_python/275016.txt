"""import resource
resource.setrlimit(resource.RLIMIT_STACK, (2**25,-1)) # increase stack size limit
sys.setrecursionlimit(10**4) # increase recursion size limit
"""

input_list = str( raw_input() ).split()
n = int( input_list[0] )
w = int( input_list[1] )
h = int( input_list[2] )

envelope_list = [] 
for i in range( n ):
    input_list = str( raw_input() ).split()
    ww = int( input_list[0] )
    hh = int( input_list[1] )
    
    if ( ww <= w )or( hh <= h ):
        continue
    
    envelope_list.append( [ww, hh, i+1 ] ) 
    
envelope_list.sort()
n = len( envelope_list )

d = [1] * n
trace = [-1] * n

maxc = 10**6

luu = [-1] * ( maxc + 1 ) 
c = [0] * ( maxc + 1 )

def update( val, vt, pos ):
    while vt <= maxc:
        if c[vt] < val:
            c[vt] = val
            luu[vt] = pos
            
        vt += vt & (vt ^ (vt-1))
    return

def calculate( vt ):
    res = 0
    pos = -1
    while vt > 0:
        if c[vt] > res:
            res = c[vt]
            pos = luu[vt]
            
        vt -= vt & ( vt^(vt-1) )
                   
    return pos

if ( n != 0 ):
    current_width = -1
    start = 1
    
    for i in range( n ):
        if envelope_list[i][0] > current_width:
            for j in range(start, i):
                update( d[j], envelope_list[j][1], j )
                
            current_width = envelope_list[i][0]
            start = i
            
        pos = calculate( envelope_list[i][1]-1 )
        if pos >= 0:
            d[i] = d[pos] + 1
            trace[i] = pos

    res = max( d )
    print res
    for i in range( n ):
        if d[i] == res:
            j = i
            ans = []
            while j >= 0:
                ans.append( envelope_list[j][2] )
                j = trace[j]
                
            ans.reverse()
            for x in ans:
                print x,
            break
    
else:
    print 0
