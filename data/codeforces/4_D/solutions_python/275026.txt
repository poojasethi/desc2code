import sys
import thread

sys.setrecursionlimit( 5100 )
thread.stack_size( 2**25 )

maxc = 10**6
luu = [-1] * ( maxc + 1 ) 
c = [0] * ( maxc + 1 )

input_list = str( raw_input() ).split()
n = int( input_list[0] )
w = int( input_list[1] )
h = int( input_list[2] )

envelope_list = [] 
for i in range( n ):
    input_list = str( raw_input() ).split()
    ww = int( input_list[0] )
    hh = int( input_list[1] )
    
    if ( ww > w )and( hh > h ):
        envelope_list.append( [ww, hh, i+1 ] ) 
    
envelope_list.sort()
n = len( envelope_list )
d = [1] * n
trace = [-1] * n

def update( val, vt, pos ):
    while vt <= maxc:
        if c[vt] < val:
            c[vt] = val
            luu[vt] = pos
            
        vt += vt & (vt ^ (vt-1))
    return

def calculate( vt ):
    res = 0
    pos = -1
    while vt:
        if c[vt] > res:
            res = c[vt]
            pos = luu[vt]
            
        vt -= vt & ( vt^(vt-1) )
                   
    return pos

def truy_vet( i ):
    if i < 0:
        return
    
    truy_vet( trace[i] )
    print envelope_list[i][2],
    return

if ( n != 0 ):
    current_width = -1
    start = 1
    
    for i in range( n ):
        if envelope_list[i][0] > current_width:
            for j in range(start, i):
                update( d[j], envelope_list[j][1], j )
                
            current_width = envelope_list[i][0]
            start = i
            
        pos = calculate( envelope_list[i][1]-1 )
        if pos >= 0:
            d[i] = d[pos] + 1
            trace[i] = pos

    res = max( d )
    print res
    for i in range( n ):
        if d[i] == res:
            #thread.struy_vet( i )
            truy_vet( i )
            break
    
else:
    print 0
