# 1 - ordena cada par de valores pra ver o primeiro ser o maior
# 2 - orderna lista dos pares pra que o maior retangulo venha primeiro na matriz
#     - Nesse caso o tamnho do meu retangulo eh o tamanho do primeiro do meu par mais a esquerda
# 3 - Fazer as combinacoes de colocar na matriz, se nenhuma der, retorna -1. Se der printa a matriz.
from math import sqrt

def sort(l):
	return sorted(l, reverse=True)

def sol():
	r1x, r1y, r2x, r2y, r3x, r3y = map(int, raw_input().split())
	l = {"A": sort((r1x, r1y)), "B": sort((r2x, r2y)), "C": sort((r3x, r3y))}

	squares = sorted(l.keys(), key=lambda x: l[x], reverse=True)
	l = sorted(l.values(), reverse=True)

	square = 0
	for i in l:
		square += i[0]*i[1]
	square = sqrt(square)
	if (square != int(square)):
		print "-1"
		return
		
	if (l[0][1] + l[1][1] + l[2][1] == l[0][0] and l[0][0] == l[1][0] == l[2][0]):
		print l[0][0]
		for i in range(l[0][0]):
			t = ""
			for j in range(l[0][1]):
				t += squares[0]
			for j in range(l[1][1]):
				t += squares[1]
			for j in range(l[2][1]):
				t += squares[2]
			print t
		return
	
	if (l[1][0] + l[2][1] == l[0][0] and \
		l[1][1] + l[0][1] ==  l[2][0] + l[0][1] == l[0][0]):
		l[2] = (l[2][1], l[2][0])
	elif (l[1][1] + l[2][0] == l[0][0] and \
		l[1][0] + l[0][1] ==  l[2][1] + l[0][1] == l[0][0]):
		l[1] = (l[1][1], l[1][0])
	elif (l[1][1] + l[2][1] == l[0][0] and \
		l[1][0] + l[0][1] ==  l[2][0] + l[0][1] == l[0][0]):
		l[1] = (l[1][1], l[1][0])
		l[2] = (l[2][1], l[2][0])
	
	if (l[1][1] == l[2][1] and l[0][1] + l[1][1] == l[0][0]):
		print l[0][0]
		for i in range(l[1][0]):
			t = ""
			for j in range(l[0][1]):
				t += squares[0]
			for j in range(l[1][1]):
				t += squares[1]
			print t
		for i in range(l[2][0]):
			t = ""
			for j in range(l[0][1]):
				t += squares[0]
			for j in range(l[2][1]):
				t += squares[2]
			print t
	else:
		print "-1"
		
sol()