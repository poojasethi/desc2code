import sys

sys.setrecursionlimit(1500)

global used 
global topsort
global adjacency_matrix
global n

def sign(x):
	if x == 0:
		return 0
	if x < 0:
		return -1
	return 1

def dfs(v):
	used[v] = True
	for i in range(0, n):
		if not used[i] and adjacency_matrix[v][i] == 1:
			dfs(i)
	topsort.append(v)

def try_me(n):
	if n > 0:
		try_me(n - 1)

def topological_sort():
	for i in range(0, n):
		if not used[i]:
			dfs(i)
	topsort.reverse()

def main():
	global used 
	global topsort
	global adjacency_matrix
	global n

	n, k = map(int, raw_input().split())
	matrix = [[0 for x in range(0, n)] for x in range(0, k)]
	for i in range(0, k):
		permutation = map(int, raw_input().split())
		for j in range(0, n):
			matrix[i][permutation[j] - 1] = j
	# build DAG
	adjacency_matrix = [[0 for x in range(0, n)] for x in range(0, n)]
	for i in range(0, n):
		for j in range(i + 1, n):
			s = sign(matrix[0][i] - matrix[0][j])
			ok = True
			for l in range(1, k):
				if sign(matrix[l][i] - matrix[l][j]) != s:
					ok = False
					break
			if ok:
				if s > 0:
					adjacency_matrix[j][i] = 1
				else:
					adjacency_matrix[i][j] = 1
	# topsort
	used = [False for x in range(0, n)]
	topsort = []
	topological_sort()
	# classic dp on toposorted graph
	res = 1
	dp = [1 for x in range(0, n)]
	for i in range(n - 1, -1, -1):
		for j in range(i + 1, n):
			if adjacency_matrix[topsort[i]][topsort[j]] == 1:
				dp[i] = max(dp[i], dp[j] + 1)
		res = max(res, dp[i])
	print res

main()
