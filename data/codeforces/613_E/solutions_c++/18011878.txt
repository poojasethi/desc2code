#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iostream>

#define LL long long
#define ULL unsigned long long

#define DEBUG(...) fprintf(stderr, __VA_ARGS__)
#define REP(i, x, y) for (int i = x, _ = y; i <= _; i ++)
#define rep(i, x, y) for (int i = x, _ = y; i >= _; i --)

template <typename T> bool Chkmax(T &x, T y) { return x < y? x = y, true : false; }
template <typename T> bool Chkmin(T &x, T y) { return y < x? x = y, true : false; }
template <typename T> void Readin(T &x)
{
    x = 0;
    int c = getchar(), k = 1;
    for (; '0' >  c || c >  '9'; c = getchar())
        if (c == '-')
            k = -1;
    for (; '0' <= c && c <= '9'; c = getchar())
        x = x * 10 + c - '0';
    x *= k;
}

const int MAXN = 2000 + 300, MOD = 1e9 + 7;

namespace Hash
{
    const ULL HASHVAL = 2333;
    ULL base[MAXN * 2];
    
    void Init()
    {
        base[0] = 1;
        REP (i, 1, MAXN * 2 - 1)
            base[i] = base[i - 1] * HASHVAL;
    }
    
    void Hash(char *s, ULL *a)
    {
        int N = strlen(s + 1);

        a[N] = s[N] - 'a' + 1;
        rep (i, N - 1, 1)
            a[i] = a[i + 1] * HASHVAL + s[i] - 'a' + 1;
    }

    void FHash(char *s, ULL *a)
    {
        int N = strlen(s + 1);

        a[1] = s[1] - 'a' + 1;
        REP (i, 2, N)
            a[i] = a[i - 1] * HASHVAL + s[i] - 'a' + 1;
    }
}

int n, m;
long long ans;
char mp[2][MAXN], s[MAXN];
ULL ha[2][MAXN], a[MAXN], fha[2][MAXN]; // hash
int ldp[2][MAXN][MAXN], udp[2][MAXN][MAXN];

template <typename T> void Mod(T &x) { x %= MOD; }

void Revel()
{
    REP (i, 1, n / 2) {
        std::swap(mp[0][i], mp[0][n - i + 1]);
        std::swap(mp[1][i], mp[1][n - i + 1]);
    }
}

bool super[2][MAXN][MAXN];

void Dp()
{
    memset(ldp, 0, sizeof(ldp));
    memset(udp, 0, sizeof(udp));
    memset(super, 0, sizeof(super));
    
    REP (i, 0, 1) REP (j, 1, n)
        ldp[i][j][1] = (mp[i][j] == s[1]);

    REP (i, 0, 1) REP (j, 0, n)
        ldp[i][j][0] = 1;
    
    REP (k, 2, m) REP (i, 1, n) REP (o, 0, 1) {
        if (mp[o][i] == s[k]) {
            Mod(ldp[o][i][k] = ldp[o][i - 1][k - 1] + udp[o][i - 1][k - 1] + super[o][i - 1][k - 1]);
            udp[o][i][k] = ldp[o ^ 1][i][k - 1];
            int p = i - k / 2 + 1;
            ULL base = Hash::base[k / 2];
            ULL hash1 = fha[o ^ 1][i] - fha[o ^ 1][p - 1] * base;
            ULL hash2 = (ha[o][p] - ha[o][i + 1] * base) * base;
            ULL hash3 = a[1] - a[k + 1] * base * base;
            if (k % 2 == 0 && k / 2 > 1 && hash1 + hash2 == hash3)
                super[o][i][k] = true;
            if (k == m)
                Mod(ans += (LL) ldp[o][i][k] + udp[o][i][k] * (m != 2));
        }
        /*
        if (mp[1][i] == s[k]) {
            Mod(ldp[1][i][k] = ldp[1][i - 1][k - 1] + udp[1][i - 1][k - 1] + super[1][i - 1][k - 1]);
            udp[1][i][k] = ldp[0][i][k - 1];
            int p = i - k / 2 + 1;
            ULL base = Hash::base[k / 2];
            ULL hash1 = fha[0][i] - fha[0][p - 1] * base;
            ULL hash2 = (ha[1][p] - ha[1][i + 1] * base) * base;
            ULL hash3 = a[1] - a[k + 1] * base * base;
            if (k % 2 == 0 && k / 2 > 1 && hash1 + hash2 == hash3)
                super[1][i][k] = true;
        }

        if (k == m)
            Mod(ans += (ldp[0][i][k] + ldp[1][i][k]) % MOD + (udp[0][i][k] + udp[1][i][k]) * (m != 2) % MOD);
        */
    }
}

void Solve()
{
    for (int k = (m == 2? 2 : 4); k <= m; k += 2)
        for (int i = 1; i + k / 2 - 1 <= n; i ++)
            for (int o = 0; o <= 1; o ++) {
                int p = i + k / 2 - 1;
                ULL base = Hash::base[k / 2];
                ULL hash1 = (fha[o ^ 1][p] - fha[o ^ 1][i - 1] * base) * base;
                ULL hash2 = ha[o][i] - ha[o][p + 1] * base;
                ULL hash3 = a[m - k + 1];
                if (hash1 + hash2 == hash3)
                    Mod(ans += ldp[o][i - 1][m - k] + udp[o][i - 1][m - k] + super[o][i - 1][m - k]);
            }
    /*
            {
                int p = i + k / 2 - 1;
                ULL base = Hash::base[k / 2];
                ULL hash1 = (fha[0][p] - fha[0][i - 1] * base) * base;
                ULL hash2 = ha[1][i] - ha[1][p + 1] * base;
                ULL hash3 = a[m - k + 1];
                if (hash1 + hash2 == hash3)
                    Mod(ans += ldp[1][i - 1][m - k] + udp[1][i - 1][m - k] + super[1][i - 1][m - k]);
            }
    */
    //printf("%d\n", ans);
}

void Case1()
{
    REP (i, 0, 1) REP (j, 1, n)
        if (mp[i][j] == s[1])
            ans ++;
    printf("%lld\n", ans);
}

void Init()
{
    n = strlen(mp[0] + 1);
    m = strlen(s + 1);

    Hash::Init();
    Hash::Hash(mp[0], ha[0]);
    Hash::Hash(mp[1], ha[1]);
    Hash::FHash(mp[0], fha[0]);
    Hash::FHash(mp[1], fha[1]);
    Hash::Hash(s, a);
}

int main()
{
    if (fopen("E.in", "r") != NULL) {
        freopen("E.in", "r", stdin);
        freopen("E.out", "w", stdout);
    }

    scanf("%s%s%s", mp[0] + 1, mp[1] + 1, s + 1);
    Init();
    if (m == 1)
        Case1();
    else {
        Dp();
        Solve();
        Revel();
        Init();
        Dp();
        if (m != 2)
	    Solve();
        printf("%lld\n", ans);
    }

    return 0;
}
