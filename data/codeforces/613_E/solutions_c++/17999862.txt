//被卡哈希！！！
#include<cmath>
#include<ctime>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<map>
#include<set>
#include<stack>
#include<queue>
#include<vector>
#include<iostream>
#include<algorithm>
#define x first
#define y second
typedef long long ll;
typedef unsigned long long ull;
typedef std::pair<int,int> pii;
template<typename T>inline T abs(T a){ return a<0?-a:a; }
template<typename T>inline T min(T a,T b){ return a<b?a:b; }
template<typename T>inline T max(T a,T b){ return a>b?a:b; }
template<typename T>inline void swap(T&a,T&b){ T t=a;a=b,b=t; }
template<typename T>inline bool umin(T&mn,T u){ return u<mn?mn=u,true:false; }
template<typename T>inline bool umax(T&mx,T u){ return u>mx?mx=u,true:false; }
template<typename T>inline void read(T&r)
{
	char c;r=0;bool flag=false;
	do c=getchar();while(c!='-'&&(c<'0'||c>'9'));
	if(c=='-')flag=true,c=getchar();
	do r=r*10+c-'0',
	   c=getchar();while(c>='0'&&c<='9');
	if(flag)r*=-1;
}
template<typename T>inline void read(T&r,T&s){ read(r),read(s); }
template<typename T>inline void read(T&r,T&s,T&t){ read(r),read(s),read(t); }
template<typename T>inline void read(T&r,T&s,T&t,T&u){ read(r),read(s),read(t),read(u); }
template<typename T>inline void write(T w,const char*c="")
{
	if(w==0)putchar('0');else{
	if(w<0)putchar('-'),w*=-1;
	static int s[21],top;top=0;
	while(w)s[top++]=w%10,w/=10;
	while(top--)putchar(s[top]+'0');
	}for(int i=0;c[i];i++)putchar(c[i]);
}
/**************************模板****************************
srt:2016 5 19 13:30
end:2016 5 20 13:27
nme:Puzzle Lover
src:cf round 339
agr:第一次被卡哈希！！！WA我一晚上,于是开成了ull,233
smr:aaea coda code;pppg ppgp p;☆tt tt tttt☆
**********************************************************/

const ull prime=233;
ull p[2002],ha[2002],hb[2002],hs[2002],ht[2002];
char a[2002],b[2002],s[2002],t[2002];
int dp[2][4][2002],n,l,xl;
void gethashed(char*s,ull*h,int n)
{
	for(int i=n;i>=0;i--)
		h[i]=h[i+1]+s[i]*p[n-i];
}
inline bool scmp(ull*a,int q,int r,ull*b,int s,int t)
{
	if(q<0||s<0||r>n||t>l)return false;
	ull idxa=(a[q]-a[r])*p[q];
	ull idxb=(b[s]-b[t])*p[s];
	return idxa==idxb;
}
int ans=0;const int mod=1e9+7;
inline void cut(int&x){ if(x>=mod)x-=mod; }
inline void fill(int&x){ if(x<0)x+=mod; }
void work()
{
	int i,j;
	bool cur=1,nxt=0;
	dp[0][0][0]=dp[0][1][0]=dp[0][2][0]=dp[0][3][0]=1;
	for(i=0;i<=n;i++)
	{
		cur^=1,nxt^=1;
			cut(ans+=dp[cur][0][l]),
			cut(ans+=dp[cur][1][l]),
			cut(ans+=dp[cur][2][l]),
			cut(ans+=dp[cur][3][l]);
		for(j=2;j<=xl;j++)
			if(!scmp(hb,i,i+j,ht,0,j))break;
			else if(scmp(ha,i,i+j,hs,l-j-j,l-j))
				cut(ans+=dp[cur][0][l-j-j]);
		for(j=2;j<=xl;j++)
			if(!scmp(ha,i,i+j,ht,0,j))break;
			else if(scmp(hb,i,i+j,hs,l-j-j,l-j))
				cut(ans+=dp[cur][1][l-j-j]);
		for(j=2;j<=xl;j++)
			if(!scmp(hb,i,i+j,hs,0,j))break;
			else if(scmp(ha,i,i+j,ht,l-j-j,l-j))
				cut(ans+=dp[cur][2][l-j-j]);
		for(j=2;j<=xl;j++)
			if(!scmp(ha,i,i+j,hs,0,j))break;
			else if(scmp(hb,i,i+j,ht,l-j-j,l-j))
				cut(ans+=dp[cur][3][l-j-j]);
		if(l%2==0)
		{
			if(scmp(ha,i-xl,i,hs,xl,l)
			&& scmp(hb,i-xl,i,ht,xl,l))
				fill(--ans);
			if(scmp(ha,i-xl,i,ht,xl,l)
			&& scmp(hb,i-xl,i,hs,xl,l))
				fill(--ans);
			if(xl!=1
			&& scmp(ha,i,i+xl,hs,0,xl)
			&& scmp(hb,i,i+xl,ht,0,xl))
				fill(--ans);
			if(xl!=1
			&& scmp(ha,i,i+xl,ht,0,xl)
			&& scmp(hb,i,i+xl,hs,0,xl))
				fill(--ans);
		}if(i==n)break;

		for(j=0;j<=l;j++)dp[nxt][0][j]=dp[nxt][1][j]=dp[nxt][2][j]=dp[nxt][3][j]=0;
		i++;
		for(j=0;j<=xl;j++)
		if(j!=1)
			if(!scmp(hb,i-j,i,ht,l-j,l))break;
			else if(scmp(ha,i-j,i,hs,j,j<<1))
				cut(++dp[nxt][0][j<<1]);
		for(j=0;j<=xl;j++)
		if(j!=1)
			if(!scmp(ha,i-j,i,ht,l-j,l))break;
			else if(scmp(hb,i-j,i,hs,j,j<<1))
				cut(++dp[nxt][1][j<<1]);
		for(j=0;j<=xl;j++)
		if(j!=1)
			if(!scmp(hb,i-j,i,hs,l-j,l))break;
			else if(scmp(ha,i-j,i,ht,j,j<<1))
				cut(++dp[nxt][2][j<<1]);
		for(j=0;j<=xl;j++)
		if(j!=1)
			if(!scmp(ha,i-j,i,hs,l-j,l))break;
			else if(scmp(hb,i-j,i,ht,j,j<<1))
				cut(++dp[nxt][3][j<<1]);
		i--;

		for(j=0;j<l;j++)
		if(dp[cur][0][j])
			if(a[i]==s[j])
			{
				cut(dp[nxt][0][j+1]+=dp[cur][0][j]);
				if(b[i]==s[j+1])
					cut(dp[nxt][1][j+2]+=dp[cur][0][j]);
			}
		for(j=0;j<l;j++)
		if(dp[cur][1][j])
			if(b[i]==s[j])
			{
				cut(dp[nxt][1][j+1]+=dp[cur][1][j]);
				if(a[i]==s[j+1])
					cut(dp[nxt][0][j+2]+=dp[cur][1][j]);
			}
		for(j=0;j<l;j++)
		if(dp[cur][2][j])
			if(a[i]==t[j])
			{
				cut(dp[nxt][2][j+1]+=dp[cur][2][j]);
				if(b[i]==t[j+1])
					cut(dp[nxt][3][j+2]+=dp[cur][2][j]);
			}
		for(j=0;j<l;j++)
		if(dp[cur][3][j])
			if(b[i]==t[j])
			{
				cut(dp[nxt][3][j+1]+=dp[cur][3][j]);
				if(a[i]==t[j+1])
					cut(dp[nxt][2][j+2]+=dp[cur][3][j]);
			}
	}
}
int main()
{
	scanf("%s%s%s",a,b,s);
	n=strlen(a),l=strlen(s),xl=l>>1;
	int maxl=max(n,l);p[maxl]=1;
	for(int i=maxl-1;i>=0;i--)p[i]=p[i+1]*prime;
	strcpy(t,s);
	std::reverse(t,t+l);
	gethashed(a,ha,maxl);
	gethashed(b,hb,maxl);
	gethashed(s,hs,maxl);
	gethashed(t,ht,maxl);
//	int q,r,s,t;
//	while(read(q,r,s,t),1)
//		puts(scmp(ha,q,r,hb,s,t)?"matched":"failed");
	work();
	if(l==1)ans>>=1;
	write(ans);
	return 0;
}
      