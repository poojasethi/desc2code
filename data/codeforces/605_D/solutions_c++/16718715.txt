#include <bits/stdc++.h>
#define type(x) __typeof(x.begin())
#define for_each(it , x) for( type(x)it = x.begin() ; it != x.end() ; it++ )
#define fi first
#define se second
using namespace std;

typedef pair < int , int > ii;

const int maxn = 2e5 + 5;

int n,aa[maxn],bb[maxn],cc[maxn],dd[maxn],back[maxn],s1,s2;

map < int , int > z1,z2;
queue < int > q;
set < ii > S[maxn << 2];
vector < ii > v[maxn];

void init( int k , int b , int e ){
	if( b == e ){
		for_each(it , v[b])
			S[k].insert(*it);
		return;
	}
	int m = (b + e) >> 1;
	int l = k + k , r = k + k + 1;
	init(l , b , m);
	init(r , m + 1 , e);
	for_each(it , S[l])	S[k].insert(*it);
	for_each(it , S[r])	S[k].insert(*it);
}

void erase( int k , int b , int e , int x , int y , int id ){
	if( b > x or e < x ) return;
	S[k].erase(S[k].find(ii(y , id)));
	if( b == e ) return;
	int m = (b + e) >> 1;
	erase(k + k , b , m , x , y , id);
	erase(k + k + 1 , m + 1 , e , x , y , id);
}

void update( int k , int b , int e , int x , int y , int id ){
	if( b > x ) return;
	if( e <= x ){
		while( !S[k].empty() and S[k].begin() -> fi <= y ){
			int go = S[k].begin() -> se;
			q.push(go);
			back[go] = id;
			erase(1 , 1 , s1 , aa[go] , bb[go] , go);
		}
		return;
	}
	int m = (b + e) >> 1;
	update(k + k , b , m , x , y , id);
	update(k + k + 1 , m + 1 , e , x , y , id);
}

int main(){
	
	scanf("%d",&n);
	
	z1[0] = z2[0] = 1;
	for( int i = 1 ; i <= n ; i++ ){
		scanf("%d%d%d%d",&aa[i],&bb[i],&cc[i],&dd[i]);
		z1[aa[i]] = z1[cc[i]] = 1;
		z2[bb[i]] = z2[dd[i]] = 1;
	}
	
	for_each(it , z1)	it -> se = ++s1;
	for_each(it , z2)	it -> se = ++s2;
	
	for( int i = 1 ; i <= n ; i++ ){
		aa[i] = z1[aa[i]];
		cc[i] = z1[cc[i]];
		bb[i] = z2[bb[i]];
		dd[i] = z2[dd[i]];
		if( aa[i] == 1 and bb[i] == 1 )
			q.push(i);
		else v[aa[i]].push_back(ii(bb[i] , i));
	}
	
	init(1 , 1 , s1);
	
	while( !q.empty() ){
		int node = q.front();
		q.pop();
		if( node == n ){
			stack < int > st;
			while( node ){
				st.push(node);
				node = back[node];
			}
			printf("%d\n",(int)st.size());
			while( !st.empty() ){
				printf("%d ",st.top());
				st.pop();
			}
			return 0;
		}
		update(1 , 1 , s1 , cc[node] , dd[node] , node);
	}
	
	printf("-1");
	
	return 0;
}
