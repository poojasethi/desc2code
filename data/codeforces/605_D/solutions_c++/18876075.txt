#include <bits/stdc++.h>

#pragma comment(linker, "/STACK:102400000,102400000")
using namespace std;

#define LL long long
#define pii pair<int,int>
#define MP make_pair
#define ls i << 1
#define rs ls | 1
#define md (ll + rr >> 1)
#define lson ll, md, ls
#define rson md + 1, rr, rs
#define Pi acos(-1.0)
#define mod 1000000007
#define eps 1e-10
#define inf 0x3f3f3f3f
#define N 300010
#define M 600020

struct node{
	int a, b, c, d;
	void input(){
		scanf("%d%d%d%d", &a, &b, &c, &d);
	}
}p[N];
struct point{
	int x, y, id;
	point(int x = 0, int y = 0, int id = 0) : x(x), y(y), id(id) {}
};
int n, cnt, san[M], dis[N], fa[N], ans[N], m;
set<pii > S[M];
set<pii >::iterator it, itt;
void update(int x, int y, int id, int n, bool flag = 1){
	if(flag)
		for(; x <= n; x += x & -x) S[x].insert(MP(y, id));
	else 
		for(; x <= n; x += x & -x) S[x].erase(MP(y, id));
}
vector<int> query(int x, int y, int n){
	vector<int> ret;
	for(; x > 0; x -= x & -x){
		it = S[x].upper_bound(MP(y, inf));
		for(itt = S[x].begin(); itt != it; ++itt){
			ret.push_back((*itt).second);
		}
	}
	return ret;
}
int haxi(int v){
	return lower_bound(san + 1, san + 1 + cnt, v) - san;
}
int main(){
	scanf("%d", &n);
	cnt = 0;
	for(int i = 1; i <= n; ++i){
		p[i].input();
		san[++cnt] = p[i].a;
		san[++cnt] = p[i].b;
		san[++cnt] = p[i].c;
		san[++cnt] = p[i].d;
	}
	san[++cnt] = 0;
	sort(san + 1, san + 1 + cnt);
	cnt = unique(san + 1, san + 1 + cnt) - san - 1;
	for(int i = 1; i <= n; ++i){
		p[i].a = haxi(p[i].a);
		p[i].b = haxi(p[i].b);
		p[i].c = haxi(p[i].c);
		p[i].d = haxi(p[i].d);
	}
	m = cnt + 2;
	for(int i = 1; i <= n; ++i){
		update(p[i].a, p[i].b, i, m);
	}
	memset(dis, -1, sizeof dis);
	memset(fa, -1, sizeof fa);
	queue<point> q;
	q.push(point(1, 1, 0));
	dis[0] = 0;
	while(!q.empty()){
		point tmp = q.front(); q.pop();
		int x = tmp.x, y = tmp.y, id = tmp.id;
		vector<int> ret = query(x, y, m);
		for(int i = 0; i < ret.size(); ++i){
			int j = ret[i];
			dis[j] = dis[id] + 1;
			fa[j] = id;
			q.push(point(p[j].c, p[j].d, j));
		}
		for(int i = 0; i < ret.size(); ++i){
			int j = ret[i];
			update(p[j].a, p[j].b, j, m, 0);
		}

	}
	printf("%d\n", dis[n]);
	if(dis[n] != -1){
		int cur = n, tot = 0;
		while(cur != 0){
			ans[++tot]= cur;
			cur = fa[cur];
		}
		for(int i = tot; i > 0; --i)
			printf("%d ", ans[i]);
		puts("");
	}
	return 0;
}
