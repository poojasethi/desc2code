#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
using namespace std;

#define maxn 200020

struct sre{
	int pF,pS,idx;
	sre(){}
	sre(int pF,int pS,int idx):pF(pF),pS(pS),idx(idx){}
	bool operator<(const sre&a)const{return(pF<a.pF||(pF==a.pF&&pS<a.pS));}
}srt[maxn];

struct event{
	int l,r,idx,mu;
	event(){}
	event(int l,int r,int idx,int mu):l(l),r(r),idx(idx),mu(mu){}
};

vector<event>v[maxn];
int n,i,a[maxn],lex[maxn],classes,Log[maxn],m,x,y,ans[maxn],sorted[maxn],cp,C[22][maxn],lexpos[maxn],le,ri,mid,rmq[22][maxn],j,fwt[maxn],mm;

int fu(int k){
	while(k>mm)k-=mm;
	return k;
}

void first_iter(){
	for(i=1;i<=mm;i++)srt[i]=sre(a[i],a[i],i);
	sort(srt+1,srt+mm+1);
	classes=1;
	for(i=1;i<=mm;i++){
		if(i>1&&(srt[i].pF!=srt[i-1].pF||srt[i].pS!=srt[i-1].pS))++classes;
		lex[srt[i].idx]=C[0][srt[i].idx]=classes;
	}
}

void next_iter(int k){
	++cp;
	for(i=1;i<=mm;i++)srt[i]=sre(lex[i],lex[fu(i+k/2)],i);
	sort(srt+1,srt+mm+1);
	classes=0;
	for(i=1;i<=mm;i++){
		if(i>1&&(srt[i].pF!=srt[i-1].pF||srt[i].pS!=srt[i-1].pS))++classes;
		lex[srt[i].idx]=C[cp][srt[i].idx]=classes;
	}
}

int loglcp(int a,int b){
	int j,rt=0;
	for(j=19;j+1;j--)if((a+(1<<j))-1<=mm&&(b+(1<<j))-1<=mm&&C[j][a]==C[j][b]){
		rt+=(1<<j);
		a+=(1<<j);
		b+=(1<<j);
	}
	return rt;
}

void suffix_array(){
	for(int i=2;i<=mm;i++)Log[i]=1+Log[i/2];
	first_iter();
	for(int i=1;i<=Log[mm]+1;i++)next_iter(1<<i);
	for(int i=1;i<=mm;i++){
		sorted[i]=srt[i].idx;
		lexpos[sorted[i]]=i;
	}
	for(int i=1;i<mm;i++)rmq[0][i]=loglcp(sorted[i],sorted[i+1]);
	for(int i=1;i<=Log[mm];i++)for(j=1;j<=mm-(1<<i)+1;j++)rmq[i][j]=min(rmq[i-1][j],rmq[i-1][j+(1<<(i-1))]);
}

int getlcp(int l,int r){
	if(l>r)return 1000000000;
	return min(rmq[Log[r-l+1]][l],rmq[Log[r-l+1]][r-(1<<Log[r-l+1])+1]);
}

void add_query(int x,int y,int l,int r){
	if(x>y||l>r)return;
	v[x-1].push_back(event(l,r,i,-1));
	v[y].push_back(event(l,r,i,1));
}

void modify(int j,int x){
	for(;j<=mm;j=(j|(j-1))+1)fwt[j]+=x;
}

int query(int j){
	int rt=0;
	for(;j;j&=(j-1))rt+=fwt[j];
	return rt;
}

int main (int argc, char * const argv[]) {
//	freopen("in.txt","r",stdin);
	scanf("%d",&n);
	for(i=1;i<=n;i++)scanf("%d",&a[i]);
	for(i=1;i<n;i++)a[i]-=a[i+1];
	for(i=1;i<n;i++)a[n-1+i]=-a[i];
	a[mm=n*2-1]=-1000000001;
	suffix_array();
	scanf("%d",&m);
	for(i=1;i<=m;i++){
		scanf("%d%d",&x,&y);
		if(x==y)ans[i]=n-1;else{
			//forward
			if(lexpos[x+n-1]<=mm){
				le=lexpos[x+n-1];ri=mm;
				while(le<ri){
					mid=(le+ri+1)/2;
					if(getlcp(lexpos[x+n-1],mid-1)>=y-x)le=mid;else ri=mid-1;
				}
				add_query(lexpos[x+n-1],le,y+1,n-(y-x));
				add_query(lexpos[x+n-1],le,1,x-(y-x)-1);
			}
			//backward
			if(lexpos[x+n-1]>1){
				le=1,ri=lexpos[x+n-1];
				while(le<ri){
					mid=(le+ri)/2;
					if(getlcp(mid,lexpos[x+n-1]-1)>=y-x)ri=mid;else le=mid+1;
				}
				add_query(le,lexpos[x+n-1]-1,y+1,n-(y-x));
				add_query(le,lexpos[x+n-1]-1,1,x-(y-x)-1);
			}
		}
	}
	for(i=1;i<=mm;i++){
		modify(sorted[i],1);
		for(j=0;j<v[i].size();j++)ans[v[i][j].idx]+=(query(v[i][j].r)-query(v[i][j].l-1))*v[i][j].mu;
	}
	for(i=1;i<=m;i++)printf("%d\n",ans[i]);
    return 0;
}
