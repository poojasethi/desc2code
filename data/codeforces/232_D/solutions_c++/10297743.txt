#include <bits/stdc++.h>

#define	st first
#define	nd second
#define	mp make_pair
#define	pb push_back
#define	lli long long int
#define	all( gg )	gg.begin(),gg.end()
#define	foreach( gg,itit )	for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )
#define	FP( ii,aa,bb ) for( lli ii=aa;ii<=bb;ii++ )
#define	FM( ii,aa,bb ) for( lli ii=aa;ii>=bb;ii-- )
#define	debug(ccc)	cout << #ccc << " = " << ccc << endl;

#define	mod	1000000007LL
using namespace std;

int	n,m,N,arr[800000];
int	s[800000],g[800000];

int	sira[800000],lcp[800000][21],LOG[800000];
pair<pair<int,int>,int>	SUF[800000];

void	suffix_array(){
	FP( i,1,N )	SUF[i] = mp( mp( s[i],0 ),i );
	sort( SUF+1,SUF+N+1 );
	for( int k=1;k<=N;k*=2 ){
		FP( i,1,N )	sira[SUF[i].nd] = sira[SUF[i-1].nd]+(SUF[i].st!=SUF[i-1].st);
		FP( i,1,N )	SUF[i] = mp( mp( sira[i],sira[i+k] ),i );
		sort( SUF+1,SUF+N+1 );
	}
	FP( i,1,N )	sira[SUF[i].nd] = i;
	int	h=0;
	FP( i,1,N ){
		if( sira[i]==N )	continue;
		while( s[i+h]==s[SUF[sira[i]+1].nd+h] )	h++;
		lcp[sira[i]][0] = h;
		if( h )	h--;
	}
	FP( k,1,19 )
		FP( i,1,N ){
			if( i+(1<<k)>N )	lcp[i][k] = lcp[i][k-1];
			else	lcp[i][k] = min( lcp[i][k-1],lcp[i+(1<<k-1)][k-1] );
		}
	FP( i,1,19 )	LOG[1<<i]++;
	FP( i,1,N+5 )	LOG[i] += LOG[i-1];
	/*cout << endl;
	FP( i,1,N ){
		cout << g[SUF[i].nd] << " ------> ";
		FP( j,SUF[i].nd,N )
			cout << s[j] << " ";
		cout << "          " << lcp[i];
		cout << endl;
	}*/
}

#define	ortak	(bas+son)/2
#define	sol		root*2,bas,ortak
#define	sag		root*2+1,ortak+1,son

vector<int>	kd[1600000];
void	init( int root,int bas,int son ){
	if( bas==son ){
		if( g[SUF[bas].nd]==2 )	kd[root].pb( SUF[bas].nd-n );
		return;
	}
	init( sol );
	init( sag );
	kd[root].resize( kd[root*2].size()+kd[root*2+1].size() );
	merge( all(kd[root*2]),all(kd[root*2+1]),kd[root].begin() );
}
int	query( int root,int bas,int son,int x,int y,int a,int b ){
	if( a>b )	return	0;
	if( son<x or y<bas )	return	0;
	if( x<=bas and son<=y )	return	!kd[root].size() ? 0 : upper_bound( all(kd[root]),b )-lower_bound( all(kd[root]),a );
	return	query( sol,x,y,a,b )+query( sag,x,y,a,b );
}

int	Query( int l,int r ){
	if( l==r )	return	N-SUF[l].nd+1;
	if( l>r )	swap( l,r );
	r--;
	int	loG = LOG[r-l+1];
	return	min( lcp[l][loG],lcp[r-(1<<loG)+1][loG] );
}

int main(){
	scanf("%d",&n);
	FP( i,1,n )
		scanf("%d",arr+i);

	FP( i,1,n-1 ){
		s[i] = arr[i+1]-arr[i];
		g[i] = 1;
	}
	s[n] = -mod;
	FP( i,1,n-1 ){
		s[i+n] = arr[i]-arr[i+1];
		g[i+n] = 2;
	}

	N = 2*n-1;
	suffix_array();
	init( 1,1,N );
	scanf("%d",&m);
	FP( i,1,m ){
		int	x,y,l,r,bas,son,orta,u;
		scanf("%d %d",&x,&y);
		u = y-x+1;
		if( x==y ){
			printf("%d\n",n-1);
			continue;
		}
		bas = 1;
		son = sira[x];
		while( bas<son ){
			orta = (bas+son)/2;
			if( Query( orta,sira[x] )>=u-1 )	son = orta;
			else	bas = orta+1;
		}
		l = bas;
		bas = sira[x];
		son = N;
		while( bas<son ){
			orta = (bas+son)/2+1;
			if( Query( sira[x],orta )>=u-1 )	bas = orta;
			else	son = orta-1;
		}
		r = bas;
		if( l>r ){
			puts("0");
			continue;
		}
		printf("%d\n",query( 1,1,N,l,r,1,x-u )+query( 1,1,N,l,r,y+1,n-u+1 ));
	}
}
