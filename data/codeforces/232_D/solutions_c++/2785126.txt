#include <cstdio>
#include <algorithm>
#include <utility>
#include <cstring>
#define X first
#define Y second
using namespace std;

const int maxn=200200,INF=199;
int rank[maxn],sa[maxn],h[maxn],rr[maxn<<1],ww[maxn],ss[maxn],pp[maxn];
int st[maxn][20],quc[maxn],root[maxn];
int n,m,l,r,x,y,ansl,ansr,pppp,delta,a[maxn],sum[maxn];
struct SSS{int l,r,m,s,son[2];} t[maxn<<4];
pair<int,int> b[maxn];

void Ready() {
	--n;
	for (int i=n;i;--i) a[i]-=a[i-1];
	a[n+1]=-INF;
	for (int i=1;i<=n;++i) a[n+i+1]=-a[i];
	for (int i=1;i<=n+n+1;++i) b[i]=make_pair(a[i],i);
	sort(b+1,b+n+n+2);
	int now=0,last=0;
	for (int i=1;i<=n+n+1;++i) {
		if (last!=b[i].X) ++now;
		last=b[i].X; a[b[i].Y]=now;
	}
}

void Work_SA(int n,int m) {
	int i,c;
	for (i=1;i<=n;++i) rank[i]=a[i];
	for (c=1;c<=n;c<<=1) {
		for (i=1;i<=n;++i) rr[i]=rank[i];
		for (i=0;i<=m;++i) ss[i]=0;
		for (i=1;i<=n;++i) ++ss[rr[i+c]];
		for (i=1;i<=m;++i) ss[i]+=ss[i-1];
		for (i=1;i<=n;++i) pp[ss[rr[i+c]]--]=i;
		for (i=0;i<=m;++i) ss[i]=0,ww[i]=-1;
		for (i=1;i<=n;++i) ++ss[rr[i]];
		for (i=1;i<=m;++i) ss[i]+=ss[i-1];
		for (i=n;i;--i) {
			if (ww[rr[pp[i]]]!=rr[pp[i]+c]) --ss[rr[pp[i]]];
			ww[rr[pp[i]]]=rr[pp[i]+c];
			rank[pp[i]]=ss[rr[pp[i]]]+1;
		}
	}
	for (i=1;i<=n;++i) sa[rank[i]]=i;
}

void Work_ST() {
	memset(st,127,sizeof(st));
	for (int i=1;i<=n+n+1;++i) st[i][0]=0;
	for (int i=1;i<=n+n+1;++i)
		for (int j=max(h[rank[i-1]]-1,1);a[sa[rank[i]-1]+j-1]==a[i+j-1];++j)
			st[rank[i]][0]=h[rank[i]]=j;
	int now=0;
	for (int i=1;i<=n+n+1;++i) {
		quc[i]=quc[i-1];
		if (i==(1<<(now+1))) ++now,++quc[i];
	}
	for (int i=1;i<=quc[n+n+1];++i)
		for (int j=1;j<=n+n+1;++j) {
			if (j+(1<<i)-1>n+n+1) break;
			st[j][i]=min(st[j][i-1],st[j+(1<<(i-1))][i-1]);
		}
}

void Work_Divide() {
	ansl=ansr=rank[x];
	for (int i=(1<<20),j=20;i;i>>=1,--j)
		if ((ansl-i>0)&&(st[ansl-i+1][j]>y-x)) ansl-=i;
	for (int i=(1<<20),j=20;i;i>>=1,--j)
		if ((ansr+i<=n+n+1)&&(st[ansr+1][j]>y-x)) ansr+=i;
}

void Build(int &p,int l,int r) {
	if (!p) p=++pppp;
	t[p].l=l; t[p].r=r;
	t[p].m=(l+r)>>1;
	if (l!=r) {
		Build(t[p].son[0],l,t[p].m);
		Build(t[p].son[1],t[p].m+1,r);
	}
}

void Modify(int &p,int k) {
	++pppp;
	t[pppp].l=t[p].l; t[pppp].r=t[p].r;
	t[pppp].m=t[p].m;
	t[pppp].son[0]=t[p].son[0]; t[pppp].son[1]=t[p].son[1];
	p=pppp;
	if (t[p].l==t[p].r) t[p].s=1;
	else {
		if (k<=t[p].m) Modify(t[p].son[0],k);
		else Modify(t[p].son[1],k);
		t[p].s=t[t[p].son[0]].s+t[t[p].son[1]].s;
	}
}

void Query(int p,int pp) {
	if ((l<=t[p].l)&&(t[p].r<=r)) delta+=t[p].s-t[pp].s;
	else {
		if (l<=t[p].m) Query(t[p].son[0],t[pp].son[0]);
		if (r>t[p].m) Query(t[p].son[1],t[pp].son[1]);
	}
}

int main() {
	scanf("%d",&n);
	for (int i=0;i<n;++i) scanf("%d",&a[i]);
	Ready();
	Work_SA(n+n+1,n+n+1);
	Work_ST();
	for (int i=1;i<=n+n+1;++i) sum[i]=(sa[i]>n+1);
	for (int i=1;i<=n+n+1;++i) sum[i]+=sum[i-1];
	Build(root[0],1,n+n+1);
	for (int i=1;i<=n+n+1;++i) {
		root[i]=root[i-1];
		if (sa[i]>n+1) Modify(root[i],sa[i]-n-1);
	}
	scanf("%d",&m);
	for (;m;--m) {
		scanf("%d %d",&x,&y);
		if (x==y) {printf("%d\n",n);continue;}
		--y; delta=0;
		Work_Divide();
		l=max(x+x-y-1,1); r=y+1;
		Query(root[ansr],root[ansl-1]);
		printf("%d\n",sum[ansr]-sum[ansl-1]-delta);
	}
	return 0;
}

