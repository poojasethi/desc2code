#include<stdio.h>
#include<tr1/unordered_map>
using namespace std;
using namespace tr1;
typedef unordered_map<int,int> map;
int getint()
{
	int ret=0;bool ok=false;
	for(;;)
	{
		int c=getchar();
		if(c>='0'&&c<='9')ret=(ret<<3)+ret+ret+c-'0',ok=true;
		else if(ok)return ret;
	}
}
const int maxn=200010;
int S[maxn];
map trans[maxn*2];
int val[maxn*2],fail[maxn*2];
int sn=1;
int s2a[maxn],a2s[2*maxn];
int n;
int sam_append(int p,int x)
{
	int np=++sn;
	val[np]=val[p]+1;
	while(p&&!trans[p].count(x))trans[p][x]=np,p=fail[p];
	if(!p)fail[np]=1;
	else
	{
		int q=trans[p][x];
		if(val[q]==val[p]+1)fail[np]=q;
		else
		{
			int nq=++sn;
			trans[nq]=trans[q];
			val[nq]=val[p]+1;
			fail[nq]=fail[q];
			fail[q]=fail[np]=nq;
			while(p&&trans[p][x]==q)trans[p][x]=nq,p=fail[p];
		}
	}
	return np;
}
struct edge
{
	int v;
	edge *n;
};
edge EPool[maxn*2],*g[maxn*2],*ep=EPool;
inline void addedge(int u,int v)
{
	ep->v=v,ep->n=g[u],g[u]=ep++;
}
int fa[maxn*2][18],d[maxn*2],log2[maxn*2];
int dnl[maxn*2],dnr[maxn*2],nn,dn[maxn*2];
void dfs(int u,int f)
{
	dnl[u]=++nn;
	dn[nn]=u;
	d[u]=d[f]+1;
	fa[u][0]=f;
	for(int i=1;i<=log2[d[u]];i++)fa[u][i]=fa[fa[u][i-1]][i-1];
	for(edge *i=g[u];i;i=i->n)dfs(i->v,u);
	dnr[u]=nn;
}
struct Tnode
{
	int s,S;
	Tnode *l,*r;
	Tnode();
};
Tnode *tp;
Tnode::Tnode():r(tp){tp=this;}
inline Tnode* newnode()
{
	if(!tp)new Tnode[10000];
	Tnode *ret=tp;
	return tp=tp->r,ret;
}
inline Tnode* getnew(int x)
{
	Tnode *ret=newnode();
	return ret->s=1,ret->S=x,ret;
}
inline Tnode* getnew(Tnode *a,Tnode *b)
{
	Tnode *ret=newnode();
	return ret->s=a->s+b->s,ret->S=a->S+b->S,ret->l=a,ret->r=b,ret;
}
Tnode* build(int n)
{
	return n==1?getnew(0):getnew(build(n>>1),build(n-(n>>1)));
}
Tnode *T[maxn*2];
Tnode* inc(Tnode *R,int i)
{
	if(R->s==1)return getnew(R->S+1);
	if(i<=R->l->s)return getnew(inc(R->l,i),R->r);
	return getnew(R->l,inc(R->r,i-R->l->s));
}
int sum(Tnode *R,int l,int r)
{
	if(l==1&&r==R->s)return R->S;
	if(r<=R->l->s)return sum(R->l,l,r);
	if(l>R->l->s)return sum(R->r,l-R->l->s,r-R->l->s);
	return sum(R->l,l,R->l->s)+sum(R->r,1,r-R->l->s);
}
inline int _sum(Tnode *R,int l,int r)
{
	return l>r?0:sum(R,l,r);
}
int getsuf(int i,int len)
{
	int u=s2a[i];
	for(i=log2[d[u]];i>=0;i--)
	{
		int v=fa[u][i];
		if(v&&val[v]>=len)u=v;
	}
	return u;
}
int main()
{
	n=getint();
	for(int i=1;i<=n;i++)S[i]=getint();
	for(int i=n;i;i--)S[i]-=S[i-1];
	S[1]=S[n+1]=~0U>>1;
	for(int i=1;i<=n;i++)S[i+n+1]=-S[i];
	s2a[0]=1;
	for(int i=1;i<=n+n+1;i++)s2a[i]=sam_append(s2a[i-1],S[i]),a2s[s2a[i]]=i;
	for(int i=2;i<=sn;i++)addedge(fail[i],i);
	log2[0]=-1;for(int i=2;i<=sn;i++)log2[i]=log2[i-1]+(i==(i&-i));
	d[0]=-1,dfs(1,0);
	T[0]=build(n);
	for(int i=1;i<=sn;i++)
	{
		T[i]=T[i-1];
		int u=dn[i];
		if(a2s[u]&&a2s[u]<=n)T[i]=inc(T[i],a2s[u]);
	}
	int Q=getint();
	while(Q--)
	{
		int l=getint(),r=getint();
		int len=r-l+1;
		int u=getsuf(n+r+1,len-1);
		int L=dnl[u]-1,R=dnr[u];
		printf("%d\n",_sum(T[R],r+len,n)-_sum(T[L],r+len,n)+_sum(T[R],1,l-1)-_sum(T[L],1,l-1));
	}
	return 0;
}
