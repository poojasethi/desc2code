#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <cmath>
#include <climits>
#include <algorithm>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <cassert>
#include <vector>
#define all(x) x.begin() , x.end()
#define fi first
#define se second
#define pb push_back
#define umax( x , y ) x = max( x , (y) )
#define umin( x , y ) x = min( x , (y) )
#define For( i , a ) for(int i=1;i<=a;i++)
#define ort (b+s)/2
#define y2 asrwjaelkf
#define y1 asseopirwjaelkf

using namespace std;

const int maxn = 200020;
const int maxx = 10000;
const int MOd = 1e9+7;
const int K = 750;

typedef long long Lint;
typedef double db;
typedef pair<int,int> ii;
typedef pair<int,ii> iii;

struct node {
	int fi, se, n;
	friend bool operator < ( const node &a, const node &b ) {
		if( a.fi == b.fi ) return a.se < b.se;
		return a.fi < b.fi;
	}
}ar[maxn];

int a, rank[maxn], lcp[maxn], n;
int segment2[maxn*3];
vector <int> segment[maxn*3];
int s[maxn];

int find( int l, int r ) {
	int t = 1e9;
	//~ printf("%d %d ==> ",l,r);
	for(l+=n-1,r+=n-1;l<=r;l=(l+1)>>1, r=(r-1)>>1) {
		if( l&1 ) umin( t, segment2[l] );
		if( ~r&1 ) umin( t, segment2[r] );
	}
	//~ printf("%d\n",t);
	return t;
}

int look( int k, int l, int r ) {
	if( l > r ) return 0;
	return upper_bound( all( segment[k] ), r ) - lower_bound( all( segment[k] ), l );
}

int main() {
	
	scanf("%d",&a);
	
	for(int i=1,h,back=0;i<=a;i++) {
		scanf("%d",&h);
		if( back ) ar[i-1].fi = h - back, ar[i-1].n = i-1, s[i-1] = h - back;
		back = h;
	}
	ar[a].fi = -1e9;
	s[a] = -1e9;
	for(int i=1;i<a;i++)
		ar[a+i].fi = -ar[i].fi, ar[a+i].n = a+i, s[a+i] = -ar[i].fi;
	s[a+a] = -1e9;
	//~ for(int i=1;i<a+a;i++)
		//~ printf("asdasD %d\n",s[i]);
	for(int k=0;1;k++) {
		
		sort( ar+1, ar+a+a );
		
		for(int i=1;i<a+a;) {
			int j=i;
			while( j < a+a && ar[j].fi == ar[i].fi && ar[j].se == ar[i].se ) rank[ar[j].n] = i, j++;
			i = j;
		}
		if( (1<<k) > a+a-1 ) break;
		
		for(int i=1;i<a+a;i++) {
			ar[i].fi = rank[ar[i].n];
			ar[i].se = rank[min(ar[i].n+(1<<k),a+a)];
			//~ ar[i].n = i;
		}
	}
	
	n = 1;
	while( n < a+a ) n <<= 1;
	
	for(int i=1,p=0;i<a+a;i++) {
		for(int j=ar[rank[i]+1].n;i+p < a+a && j+p < a+a && s[i+p] == s[j+p];p++);
		//~ printf("asdasd %d %d -- %d\n",i,ar[rank[i]+1],p);
		segment2[rank[i]+n-1] = p;
		if( p ) p--;
	}
		//~ for(int i=1;i<a+a;i++)
			//~ printf("%d  %d--| %d |--  %d\n",ar[i].n,rank[ar[i].n],s[ar[i].n],segment2[i+n-1]);
	
	
	for(int i=1;i<a+a;i++)
		segment[i+n-1].pb( ar[i].n );
	
	for(int k=n-1;k>=1;k--) {
		for(int i=0;i<segment[k+k].size();i++) segment[k].pb( segment[k+k][i] );
		for(int i=0;i<segment[k+k+1].size();i++) segment[k].pb( segment[k+k+1][i] );
		sort( all( segment[k] ) );
	}
	
	for(int i=n-1;i>=1;i--)
		segment2[i] = min( segment2[i+i], segment2[i+i+1] );
	
	int q;
	scanf("%d",&q);
	
	while( q-- ) {
		
		int x, y;
		scanf("%d %d",&x,&y);
		if( x == y ) {
			printf("%d\n",a-1);
			continue;
		}
		//~ printf("asdasd %d\n",rank[x]);
		int l = rank[x], r = rank[x];
		for(int k=17;k>=0;k--)
			if( l-(1<<k) > 0 && find(l-(1<<k),rank[x]-1) >= y-x ) l -= 1<<k;
		for(int k=17;k>=0;k--)
			if( r+(1<<k) < a+a && find(rank[x],r+(1<<k)-1) >= y-x ) r += 1<<k;
		int t = 0;
		//~ printf("- (%d %d) - %d %d , %d %d\n",l,r,a,a+x-(y-x+1),a+y+1,n);
		for(l+=n-1,r+=n-1;l<=r;l=(l+1)>>1, r=(r-1)>>1) {
			if( l&1 ) t += look( l, a, a+x-(y-x+1) ) + look( l, a+y+1, n );
			if( ~r&1 ) t += look( r, a, a+x-(y-x+1) ) + look( r, a+y+1, n );
		}
		printf("%d\n",t);
	}
	
	return 0;
}
