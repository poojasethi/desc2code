#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#define maxn 200010
using namespace std;
int n,v[maxn];
int rank[maxn],Sa[maxn],height[maxn];
int Log[maxn],F[maxn][20];
int root[maxn],lc[maxn*20],rc[maxn*20],size[maxn*20],tot;
int New_Node(int a,int b,int p)
{
	tot++;
	lc[tot]=a,rc[tot]=b,size[tot]=size[p]+1;
	return tot;
}
int Insert(int p,int l,int r,int v)
{
	if(l==r)
		return New_Node(0,0,p);
	int mid=(l+r)>>1;
	if(v<=mid)
		return New_Node(Insert(lc[p],l,mid,v),rc[p],p);
	else
		return New_Node(lc[p],Insert(rc[p],mid+1,r,v),p);
}
int Query(int p,int l,int r,int x,int y)
{
	if(x>y||p==0)
		return 0;
	if(l==x&&r==y)
		return size[p];
	int mid=(l+r)>>1;
	if(y<=mid)
		return Query(lc[p],l,mid,x,y);
	else if(mid<x)
		return Query(rc[p],mid+1,r,x,y);
	else
		return Query(lc[p],l,mid,x,mid)+Query(rc[p],mid+1,r,mid+1,y);
}
void read()
{
	static int a[maxn],b[maxn];
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%d",&a[i]);
	int cnt=0;
	for(int i=2;i<=n;++i)
		v[++cnt]=a[i]-a[i-1];
	for(int i=2;i<=n;++i)
		v[++cnt]=a[i-1]-a[i];
	n=cnt;
	for(int i=1;i<=cnt;++i)
		b[i]=v[i];
	sort(b+1,b+n+1);
	cnt=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++)
		v[i]=lower_bound(b+1,b+cnt+1,v[i])-b;
}
void sort(int *a,int *b,int *c,int n,int m)
{
	static int sum[maxn];
	for(int i=0;i<=m;++i)
		sum[i]=0;
	for(int i=1;i<=n;++i)
		sum[c[a[i]]]++;
	for(int i=1;i<=m;++i)
		sum[i]+=sum[i-1];
	for(int i=n;i>=1;--i)
		b[sum[c[a[i]]]--]=a[i];
}
void make_Sa()
{
	static int x[maxn],y[maxn];
	for(int i=1;i<=n;++i)
		x[i]=v[i],rank[i]=i;
	sort(rank,Sa,x,n,200000);
	rank[Sa[1]]=1;
	for(int i=2;i<=n;++i)
		rank[Sa[i]]=rank[Sa[i-1]]+(v[Sa[i]]!=v[Sa[i-1]]);
	for(int i=1;i<=n;i<<=1)
	{
		for(int j=1;j<=n;++j)
			Sa[j]=j,x[j]=rank[j],y[j]=j+i<=n?rank[j+i]:0;
		sort(Sa,rank,y,n,n),sort(rank,Sa,x,n,n);
		rank[Sa[1]]=1;
		for(int j=2;j<=n;++j)
			rank[Sa[j]]=rank[Sa[j-1]]+(x[Sa[j]]!=x[Sa[j-1]]||y[Sa[j]]!=y[Sa[j-1]]);
		if(rank[Sa[n]]==n)
			return ;
	}
}
void make_height()
{
	for(int i=1,j=0;i<=n;++i)
	{
		if(j>0)
			--j;
		if(rank[i]!=1)
			while(v[i+j]==v[Sa[rank[i]-1]+j])
				++j;
		height[rank[i]]=j;
	}
	for(int i=1;i<=n;++i)
		root[i]=Insert(root[i-1],1,n,Sa[i]);
}
int RMQ(int l,int r)
{
	int h=Log[r-l+1];
	return min(F[l][h],F[r-(1<<h)+1][h]);
}
void ST()
{
	for(int i=2;i<=n;++i)
		Log[i]=Log[i-1]+(i-(i&-i)==0);
	for(int i=1;i<=n;++i)
		F[i][0]=height[i];
	for(int j=1;j<=Log[n];++j)
		for(int i=1;i<=n-(1<<j)+1;++i)
			F[i][j]=min(F[i][j-1],F[i+(1<<(j-1))][j-1]);
}
int binary1(int l,int r,int p,int s)
{
	while(l<r)
	{
		int mid=(l+r)>>1;
		RMQ(mid+1,p)<s?l=mid+1:r=mid;
	}
	return l;
}
int binary2(int l,int r,int p,int s)
{
	while(l<r)
	{
		int mid=(l+r)>>1;
		RMQ(p+1,mid)>=s?l=mid+1:r=mid;
	}
	return l-1;
}
int Query(int l,int r)
{
	if(l==r)
		return n/2;
	--r;
	int Len=r-l+1,p=rank[l];
	int L=binary1(1,p,p,Len),R=binary2(p+1,n+1,p,Len);
	int sum=0;
	sum=sum+Query(root[R],1,n,n/2+1,n/2+l-Len-1)-Query(root[L-1],1,n,n/2+1,n/2+l-Len-1);
	sum=sum+Query(root[R],1,n,n/2+r+2,n-Len+1)-Query(root[L-1],1,n,n/2+r+2,n-Len+1);
	return sum;
}
void Query()
{
	int q;
	scanf("%d",&q);
	for(int i=1,l,r;i<=q;++i)
	{
		scanf("%d %d",&l,&r);
		printf("%d\n",Query(l,r));
	}
}
int main()
{
	read();
	make_Sa();
	make_height();
	ST();
	Query();
	return 0;
}
		 		       									 	  	