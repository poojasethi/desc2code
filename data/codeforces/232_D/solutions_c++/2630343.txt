#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstdlib>
#include <cmath>
#include <cstring>
using namespace std;

struct QUES { int l,r,len,lin,cod; }ques[101000];
struct bb { int l,r; } bor[101000];
int a[201000],b[201000],sa[201000],rank[201000],s1[201000],t1[201000],r[201000],h[201000],g[201000][20],ans[101000],n,m,q,tot;

struct BIT {
	int t[201000];
	void insert(int x,int y){ for (;x<=n+n;x+=x&(-x)) t[x]+=y; }
	int query(int x) { int ret=0;for (;x;x-=x&(-x)) ret+=t[x];return ret; }
}T;

bool cmp1(int x,int y){ return rank[x]<rank[y]; }

void SA()
{	
	int nn=n+n-1;
	for (int i=1;i<=nn;i++) rank[i]=a[i];
	for (int i=0;i<=nn;i++) sa[i]=i;
	sort(&sa[1],&sa[nn+1],cmp1);
	int rk=1;
	for (int i=2;i<=nn;i++) if (rank[sa[i]]>rank[sa[i-1]]) rk++;
	for (int len=1;rk<nn;len*=2)
	{
		int cnt=0;
		for (int i=nn-len+1;i<=nn;i++) t1[++cnt]=i;
		for (int i=1;i<=nn;i++) if (sa[i]>len) t1[++cnt]=sa[i]-len;
		for (int i=1;i<=nn;i++) s1[i]=0;
		for (int i=1;i<=nn;i++) s1[rank[t1[i]]]++;
		for (int i=1;i<=nn;i++) s1[i]+=s1[i-1];
		for (int i=nn;i>=1;i--) sa[s1[rank[t1[i]]]--]=t1[i];
		r[sa[1]]=rk=1;
		for (int i=2;i<=nn;i++) 
		{
			if (rank[sa[i]]!=rank[sa[i-1]] || rank[sa[i]+len]!=rank[sa[i-1]+len]) rk++; 
			r[sa[i]]=rk;
		}
		memcpy(rank,r,sizeof(r));
	}
	int L=0;
	for (int i=1;i<=nn;i++)
	{
		if (L>0) L--;
		while (a[i+L]==a[sa[rank[i]-1]+L]) L++;
		h[rank[i]]=L;
	}
}

void RMQ_pre()
{
	h[1]=n+n-1;
	for (int i=1;i<=n+n-1;i++) g[i][0]=h[i];
	for (int j=1;(1<<j)<=n+n-1;j++)
	{
		for (int i=1;i<=n+n-1-(1<<(j-1));i++)
		{
			g[i][j]=min(g[i][j-1],g[i+(1<<(j-1))][j-1]);
		}
	}
}

int RMQ_query(int l,int r)
{
	int t=floor(log(r-l+1)/log(2));
	return min(g[l][t],g[r-(1<<t)+1][t]);
}

void findpos(int x,int p,int reqL)
{
	int Left=1,Right=p,ret=p;
	while (Left<=Right)
	{
		int mid=(Left+Right)/2;
		if (RMQ_query(mid+1,p)>=reqL) ret=mid,Right=mid-1;
		else Left=mid+1;
	}
	bor[x].l=ret;
	Left=p+1;Right=n+n-1;ret=p;
	while (Left<=Right)
	{
		int mid=(Left+Right)/2;
		if (RMQ_query(p+1,mid)>=reqL) ret=mid,Left=mid+1;
		else Right=mid-1;
	}
	bor[x].r=ret;	
}

bool cmp(QUES A,QUES B) { return A.lin<B.lin; }

int main()
{
	//freopen("in","r",stdin);
	
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&b[i]);
	for (int i=1;i<n;i++) a[i]=b[i+1]-b[i],a[i+n]=-a[i];
	a[n]=2000000000;
	memcpy(b,a,sizeof(a));
	sort(&b[1],&b[n+n]);
	tot=unique(&b[1],&b[n+n])-&b[1];
	for (int i=1;i<n+n;i++) a[i]=lower_bound(&b[1],&b[tot+1],a[i])-&b[0];
	SA();RMQ_pre();
	scanf("%d",&q);
	for (int i=1;i<=q;i++)
	{
		scanf("%d%d",&ques[i].l,&ques[i].r);
		ques[i].cod=i;
		if (ques[i].l==ques[i].r) ans[i]=n-1;
		else 
		{
			ques[i].r--;
			ques[i].len=ques[i].r-ques[i].l+1;
			ques[i].lin=ques[i].l-ques[i].len-1;
			findpos(i,rank[ques[i].l+n],ques[i].r-ques[i].l+1);
		}
	}
	sort(&ques[1],&ques[q+1],cmp);
	int j=1;
	while (ques[j].lin<=0) j++;
	for (int i=1;i<=n;i++)
	{
		T.insert(rank[i],1);
		while (j<=q && ques[j].lin==i) ans[ques[j].cod]+=T.query(bor[ques[j].cod].r)-T.query(bor[ques[j].cod].l-1),j++;
	}
	for (int i=1;i<=q;i++) ques[i].lin=(ques[i].len==0)?n+2:ques[i].r+2;
	sort(&ques[1],&ques[q+1],cmp);
	memset(T.t,0,sizeof(T.t));
	j=q;
	while (ques[j].lin>n) j--;
	for (int i=n;i>=1;i--)
	{
		T.insert(rank[i],1);
		while (j>0 && ques[j].lin==i) ans[ques[j].cod]+=T.query(bor[ques[j].cod].r)-T.query(bor[ques[j].cod].l-1),j--;
	}
	for (int i=1;i<=q;i++) printf("%d\n",ans[i]);
	
	return 0;
}