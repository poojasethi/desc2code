#include <bits/stdc++.h>
using namespace std;
#define MAXN 100005
int m,Q;
int h[MAXN];
pair<int,int*>b[MAXN<<1];
int t;
struct Node
{
	int val;
	int l,r;
}tr[MAXN*20<<2];
int tot,root[MAXN<<1];
void Update(int val,int l,int r,int &rt)
{
	tr[++tot]=tr[rt];
	rt=tot;
	tr[rt].val++;
	if(l==r) return;
	int mid=(l+r)>>1;
	if(val<=mid) Update(val,l,mid,tr[rt].l);
	else Update(val,mid+1,r,tr[rt].r);
}
int Query(int val,int l,int r,int L,int R)
{
	if(val<l) return tr[R].val-tr[L].val;
	int mid=(l+r)>>1;
	return Query(val,mid+1,r,tr[L].r,tr[R].r)+(val<mid?Query(val,l,mid,tr[L].l,tr[R].l):0);
}
int lg[MAXN<<1];
int s[MAXN<<1];
int sa[MAXN<<1];
int val[MAXN<<1];
int q[MAXN<<1];
int cnt[MAXN<<1];
int newval[MAXN<<1];
int rank[MAXN<<1];
int height[MAXN<<1];
int rmq[MAXN<<1][20];
int len;
bool Is_same(int a,int b,int hl)
	{return val[a]==val[b]&&((a+hl>=len&&b+hl>=len)||(a+hl<len&&b+hl<len&&val[a+hl]==val[b+hl]));}
void Get_sa()
{
	int lim=200005;
	len=m<<1;
	int i,j,k;
	for(i=0;i<lim;i++)cnt[i]=0;
	for(i=0;i<len;i++)cnt[val[i]=s[i]]++;
	for(i=1;i<lim;i++)cnt[i]+=cnt[i-1];
	for(i=len-1;~i;i--)sa[--cnt[val[i]]]=i;
	int d,hl,h;
	for(d=1;;d++)
	{
		hl=1<<(d-1),h=0;
		for(i=0;i<len;i++)if(sa[i]+hl>=len) q[h++]=sa[i];
		for(i=0;i<len;i++)if(sa[i]>=hl) q[h++]=sa[i]-hl;
		for(i=0;i<lim;i++)cnt[i]=0;
		for(i=0;i<len;i++)cnt[val[q[i]]]++;
		for(i=1;i<lim;i++)cnt[i]+=cnt[i-1];
		for(i=len-1;~i;i--)sa[--cnt[val[q[i]]]]=q[i];
		for(lim=0,i=0;i<len;lim++)
		{
			for(j=i;j<len&&Is_same(sa[j],sa[j+1],hl);j++);
			for(k=i,i=j+1;k<=j;k++)newval[sa[k]]=lim;
		}
		for(i=0;i<len;i++)val[i]=newval[i];
		if(lim==len) break;
	}
	for(i=0;i<len;i++)rank[sa[i]]=i;
	k=0;
	for(i=0;i<len;i++)
	{
		k=k?k-1:0;
		if(rank[i]) for(j=sa[rank[i]-1];s[i+k]==s[j+k];k++);
		height[rank[i]]=k;
	}
	lg[1]=0;
	for(int i=2;i<=200005;i++)
		lg[i]=lg[i>>1]+1;
	for(int i=0;i<len;i++)
		rmq[i][0]=height[i];
	for(int j=1;(1<<j)<=len;j++)
		for(int i=0;i+(1<<j)-1<len;i++)
			rmq[i][j]=min(rmq[i][j-1],rmq[i+(1<<(j-1))][j-1]);
	for(int i=0;i<len;i++)
	{
		if(i) root[i]=root[i-1];
		Update(sa[i],1,MAXN<<1,root[i]);
	}
}
int Ask(int l,int r)
{
	int len=lg[r-l+1];
	return min(rmq[l][len],rmq[r-(1<<len)+1][len]);
}
int Get_ans(int l,int k)
{
	if(!k) return m-1;
	int L=rank[l],R=rank[l];
	int ll=1,rr=m*2-rank[l],mid;
	while(ll<=rr)
	{
		mid=(ll+rr)>>1;
		if(Ask(rank[l]+1,rank[l]+mid)>=k)
			R=rank[l]+mid,ll=mid+1;
		else rr=mid-1;
	}
	ll=1,rr=rank[l];
	while(ll<=rr)
	{
		mid=(ll+rr)>>1;
		if(Ask(rank[l]-mid+1,rank[l])>=k)
			L=rank[l]-mid,ll=mid+1;
		else rr=mid-1;
	}
	return Query(m-1,1,MAXN<<1,root[L-1],root[R])-Query(m+max(l-k,0)-1,1,MAXN<<1,root[L-1],root[R])+Query(m+l+k,1,MAXN<<1,root[L-1],root[R]);
}
int main()
{
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
		scanf("%d",h+i);
	s[0]=0,b[0]=make_pair(s[0],s+0);
	for(int i=2;i<=m;i++)
		s[i-1]=h[i]-h[i-1]+100001,b[i-1]=make_pair(s[i-1],s+i-1);
	s[m]=0,b[m]=make_pair(s[m],s+m);
	for(int i=2;i<=m;i++)
		s[m+i-1]=h[i-1]-h[i]+100001,b[m+i-1]=make_pair(s[m+i-1],s+m+i-1);
	sort(b,b+m*2);
	for(int i=0;i<m*2;i++)
	{
		if(!i||b[i].first!=b[i-1].first) t++;
		*b[i].second=t;
	}
	Get_sa();
	scanf("%d",&Q);
	for(int l,r,i=1;i<=Q;i++)
	{
		scanf("%d%d",&l,&r);
		int ans=Get_ans(l,r-l);
		printf("%d\n",ans);
	}
	return 0;
}