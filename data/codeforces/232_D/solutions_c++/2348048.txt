#include <cstdio>
#include <cstring>
#include <algorithm>
#define FOR(i,s,e) for (int i=(s); i<(e); i++)
#define FOE(i,s,e) for (int i=(s); i<=(e); i++)
#define FOD(i,s,e) for (int i=(s)-1; i>=(e); i--)
#define CLR(a,x) memset(a, x, sizeof(a))
#define EXP(i,l) for (int i=(l); i; i=qn[i])
#define N 200005
using namespace std;

struct node{
	int x, y, l, *a, *b;
};

node T[N<<2];
int MLC[N * 20];

int n, m, t, x, y, nq, mcnt;
int rk, ht, lo, hi, flo, fhi;
int a[N], b[N], c[N], buf[N];
int cnt[N], SA[N], SA2[N], R[N], R2[N], h[N];
int ST[N][20];

void SuffixArray(int n, int s[], int R[], int SA[], int h[]){
	memset(cnt, 0, sizeof(cnt));
	s[n] = 0;
	for (int i=0; i<n; i++) cnt[s[i]]++;
	for (int i=1; i<=n; i++) cnt[i] += cnt[i-1];
	for (int i=0; i<n; i++) SA[--cnt[s[i]]] = i;
	R[SA[0]] = 0;
	R[n] = -1;
	for (int i=1; i<n; i++) R[SA[i]] = R[SA[i-1]] + (s[SA[i]] != s[SA[i-1]]);

	for (int k=1; k<=n; k<<=1){
		for (int i=0; i<n; i++) cnt[R[SA[i]]] = i+1;
		for (int i=n-1; i>=0; i--)
			if (SA[i] >= k) SA2[--cnt[R[SA[i]-k]]] = SA[i]-k;
		for (int i=n-k; i<n; i++) SA2[--cnt[R[i]]] = i;

		R2[SA2[0]] = 0;
		for (int i=1; i<n; i++)
			R2[SA2[i]] = R2[SA2[i-1]] + (R[SA2[i]] != R[SA2[i-1]] || R[SA2[i]+k] != R[SA2[i-1]+k]);

		for (int i=0; i<n; i++) R[i] = R2[i], SA[i] = SA2[i];
	}

	/* h[x] = LCP(s[SA[x]], s[SA[x+1]]) */
	for (int i=0, x=0; i<n; i++){
		if (R[i] == n-1) h[R[i]] = x = 0;
		else{
			if (x > 0) x--;
			int y = SA[R[i]+1];
			while (i + x < n && y + x < n && s[i+x] == s[y+x]) x++;
			h[R[i]] = x;
		}
	}
}

void build(int n){
	for (int i=0; i<n; i++) ST[i][0] = h[i]; 
	for (int j=1; (1<<j)<=n; j++)
		for (int i=0; i+(1<<j)-1<n; i++) ST[i][j] = min(ST[i][j-1], ST[i+(1<<(j-1))][j-1]); 
}

int rmq(int x, int y){
	int t; 
	for (t=0; (1<<(t+1))<=(y-x+1); t++); 
	return min(ST[x][t], ST[y-(1<<t)+1][t]); 
}


void build(int d, int x, int y){
	T[d].x = x, T[d].y = y;
	if (x != y){
		build(d<<1, x, (x+y)/2);
		build(1+(d<<1), (x+y)/2+1, y);
	}

	int sz = 0;
	for (int i=x; i<=y; i++){
		if (SA[i] >= n) buf[sz++] = SA[i];
	}
	sort(buf, buf + sz);

	T[d].l = sz;
	T[d].a = MLC + mcnt, mcnt += sz;
	for (int i=0; i<sz; i++) T[d].a[i] = buf[i];
}

int query(int d, int x, int y, int lo, int hi){
	if (lo > hi) return 0;
	if (y < T[d].x || x > T[d].y) return 0;

	if (x <= T[d].x && y >= T[d].y){
		hi = upper_bound(T[d].a, T[d].a + T[d].l, hi) - T[d].a - 1;
		lo = lower_bound(T[d].a, T[d].a + T[d].l, lo) - T[d].a;
		return hi - lo + 1;
	}

	return query(d<<1, x, y, lo, hi) + query(1+(d<<1), x, y, lo, hi);
}

int main(){
	scanf("%d", &n);
	FOR(i,0,n) scanf("%d", &a[i]);

	m = 0;
	FOR(i,0,n-1) b[m++] = a[i+1] - a[i];
	b[m++] = -(1<<30);
	FOR(i,0,n-1) b[m++] = a[i] - a[i+1];

	FOR(i,0,m) buf[i] = b[i];
	sort(buf, buf + m);
	t = unique(buf, buf + m) - buf;
	FOR(i,0,m) b[i] = (lower_bound(buf, buf + t, b[i]) - buf) + 1;

	SuffixArray(m, b, R, SA, h);
	build(m - 1);

	mcnt = 0;
	build(1, 0, m-1);

	scanf("%d", &nq);
	while (nq--){
		scanf("%d%d", &x, &y), x--, y--;
		if (x == y){
			printf("%d\n", n - 1);
			continue;
		}

		// so rank[x]
		// height range y - x + 1
		// good at [n, flo], [fhi, m-1]
		rk = R[x];
		ht = y - x;
		lo = hi = rk;
		
		flo = x + x + n - y - 1;
		fhi = y + n + 1;

		// find lo
		for (int i=0, j=rk-1, k; j>=i;){
			k = (i + j) >> 1;
			if (rmq(k, rk - 1) >= ht) lo = k, j = k - 1;
			else i = k + 1;
		}

		// find hi
		for (int i=rk+1, j=m-1, k; j>=i;){
			k = (i + j) >> 1;
			if (rmq(rk, k - 1) >= ht) hi = k, i = k + 1;
			else j = k - 1;
		}

		printf("%d\n", query(1, lo, hi, n, flo) + query(1, lo, hi, fhi, m - 1));
	}

	return 0;
}
