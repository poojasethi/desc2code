#include<cstdio>
#include<iostream>
#include<cstring>
#include<vector>
#include<stack>
using namespace std ;

const int MAXM = 1e6 + 5 ;
char ch[MAXM], *p ;
int m, num, ans = 0 ; //num记录标签的序号
//记录标签
struct node{
    long long val ; //记录标签
    vector<int> inTag ; //记录此标签后面的嵌在该标签里面的标签序号
}tags[MAXM];
vector<long long>   que ;
//
bool judge(char ch){
    if( ch >= 'a' && ch <= 'z' )    return true ;
    return false ;
} 
//hash
long long hash(char* &s){
    long long res = 0 ;
    while( judge(*s) ){
        res = 27*res + (*s-'a'+1) ;
        s++ ;
    }   
    return res ;
}
//表示现在是BHTML中的第x个标签，查询的BCSS的第y个标签
void cal(int x, int y ){
    if( y < que.size() && tags[x].val == que[y] )   y++ ;
    if( que.size() == y && tags[x].val == que[que.size()-1] )   ans++ ;
    for( int i = 0; i < tags[x].inTag.size(); i++ )
        cal(tags[x].inTag[i],y) ;
}
//
int main(){
   // freopen("1234.in","r",stdin) ;
    fgets(ch,sizeof(ch),stdin) ;
    stack<int>  s ; //如果一个标签还没有找到其结束标签则进站，找到则出站
    while( !s.empty() ) s.pop() ;
    s.push(0) ;
    for( p = ch; *p; p++ ){
        if( *p == '<' ) p++ ;
        if( *p == '/' ){ //找到结束标签
            s.pop() ; //
            while( *p != '>' )  p++ ;
        }
        else{//未找到
            tags[s.top()].inTag.push_back(++num) ;
            tags[num].val = hash(p) ;
            s.push(num) ;
            if( *p == '/' ) s.pop(), p++ ;  //对于单个标签
        }
    }

    scanf("%d\n",&m) ;
    while( m-- ){
        fgets(ch,sizeof(ch),stdin) ;
        que.clear() ;
        for( p = ch; *p; p++ ){
            que.push_back(hash(p)) ;
        }   
        ans = 0 ;
        cal(0,0) ;
        printf("%d\n",ans) ;
    }
    return 0 ;
}















