#include <iostream>
#include <list>
#include <vector>
#include <sstream>
#include <map>

using namespace std;

struct element
{
	element* parent;
	list<element*> nested;
	string name;
	~element()
	{
		while(!nested.empty())
		{
			delete nested.front();
			nested.pop_front();
		}
	}
};

size_t process(element* current, const string& src, size_t index)
{
	while(index < src.size())
	{
		if(src[index + 1] == '/')
		{
			while(src[index] != '>')
				index++;
			return index + 1;
		}
		element* child = new element();
		size_t endInd = index;
		while(src[endInd] != '>')
			++endInd;
		if(src[endInd - 1] == '/')
			child->name = src.substr(index + 1, endInd - index - 2);
		else
			child->name = src.substr(index + 1, endInd - index - 1);
		child->parent = current;
		current->nested.push_front(child);
		if(src[endInd - 1] != '/' && index + 1 < src.size())
			index = process(child, src, endInd + 1);
		else
			index = endInd + 1;
	}
	return index;
}

int dfs(element* from, const vector<string>& query, unsigned index)
{
	int ret = 0;
	if(query[index] == from->name)
	{
		if(index < query.size() - 1)
			index++;
		else
			ret = 1;
	}
	std::list<element*>::iterator listend = from->nested.end();
	for(std::list<element*>::iterator i = from->nested.begin(); i != listend; ++i)
		ret += dfs(*i, query, index);
	return ret;
}

int main()
{
	string source;
	cin >> source;
	element* root = new element();
	root->parent = NULL;
	root->name = "$ROOT";
	process(root, source, 0);
	int m;
	cin >> m;
	cin.getline(NULL, 0);
	for(int i = 0; i < m; ++i)
	{
		char q[3000];
		cin.getline(q, 3000);
		istringstream istr(q);
		vector<string> query;
		while(true)
		{
			string tmp;
			istr >> tmp;
			if(tmp == "")
				break;
			query.push_back(tmp);
		}
		cout << dfs(root, query, 0) << endl;
	}
	delete root;
	return 0;
}