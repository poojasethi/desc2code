#include <cstdio>
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <algorithm>

using namespace std;

char s[1111111];

struct Tag {
    string name;
    vector<int> entries;
};

int tags;
Tag t[500000];

string getName(char* s, int &p, bool &closed) {
    p++;
    string name = "";
    while (s[p]>='a' && s[p]<='z') {
        name += s[p];
        p++;
    }
    if (s[p]=='/') {
        closed = true;
        p++;
    }
    else
        closed = false;
    p++;
    return name;
}

bool isCloseTag(char* s, int &p) {
    if (s[p+1]!='/')
        return false;
    while (s[p] != '>')
        p++;
    p++;
    return true;
}


int parse(char* s, int &p) {
    bool closed = false;
    int n = tags;
    tags++;
    t[n].name = getName(s, p, closed);
    if (!closed)
        while (!isCloseTag(s, p))
            t[n].entries.push_back(parse(s, p));
    return n;
}

vector<string> v;
int pos;
int ans;

void dfs(int k) {
    if (pos+1 >= v.size() && t[k].name == v[v.size()-1])
        ans++;
    int prev = pos;
    if (pos < v.size() && t[k].name == v[pos])
        pos++;
    for (int i=0; i<t[k].entries.size(); i++)
        dfs(t[k].entries[i]);
    pos = prev;
}

int main() {
//	freopen ("input.txt", "r", stdin);
//	freopen ("output.txt", "w", stdout);
    scanf("%s", s);
    tags = 1;
    t[0].name = "ROOT";
    int p = 0;
    while (s[p] > '\0')
        t[0].entries.push_back(parse(s, p));
    int kt;
    cin >> kt;
    string buf;
    getline(cin, buf);
    for (int nt=0; nt<kt; nt++) {
        getline(cin, buf);
        buf += " ";
        v.clear();
        string cur = "";
        for (int i=0; i<buf.length(); i++) {
            if (buf[i]>='a' && buf[i]<='z')
                cur += buf[i];
            else {
                if (cur.length() > 0)
                    v.push_back(cur);
                cur = "";
            }
        }
        pos = 0;
        ans = 0;
        dfs(0);
        cout << ans << endl;
    }
	return 0;
}
