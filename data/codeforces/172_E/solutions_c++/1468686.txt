#include <cassert>
#include <cstdio>
#include <map>
#include <string>
#include <vector>

using namespace std;

#define sz(v) ((int)((v).size()))
#define forn(i,n) for (int i = 0; i < (n); i++)
typedef long long LL;

#define INPUTN 1000004
#define N 250250
#define P1 366239
int n;
vector<int> a[N], w[N];
int parent[N];
char input[INPUTN];

map<LL, int> hashes;
int get_str(int l, int r, bool create) {
    LL h = 0;
    for (int i = l; i < r; i++) h = h*P1 + input[i];
    if (hashes.count(h)) return hashes[h];
    return create ? (hashes[h] = sz(hashes)) : -1;
}

void parse() {
    int cur = 0;
    parent[0] = -1;
    n = 1;
    for (int i = 0; input[i];) {
        // assert(input[i] == '<');
        int j = i + 1;
        while (input[j] != '>') j++;
        // assert(input[j] == '>');
        if (input[i+1] == '/') {
            cur = parent[cur];
        } else if (input[j-1] == '/') {
            int z = get_str(i+1, j-1, 1);
            a[cur].push_back(n);
            w[cur].push_back(z);
            parent[n] = cur;
            n++;
        } else {
            int z = get_str(i+1, j, 1);
            a[cur].push_back(n);
            w[cur].push_back(z);
            parent[n] = cur;
            cur = n;
            n++;
        }
        i = j + 1;
    }
}

int q[204], len, answer;
void dfs(int v, int cur) {
    if (cur == len) answer++, cur--;
    for (int i = 0, l = sz(a[v]); i < l; i++)
        dfs(a[v][i], cur + (w[v][i] == q[cur]));
}

int main() {
    gets(input);
    parse();
    int __;
    scanf("%d\n", &__);
    forn(_, __) {
        gets(input);
        bool shit = false;
        len = 0;
        for (int i = 0;;) {
            while (input[i] == ' ') i++;
            if (!input[i]) break;
            int j = i+1;
            while (input[j] && input[j] != ' ') j++;
            q[len++] = get_str(i, j, 0);
            if (q[len-1] < 0) { shit = true; break; }
            i = j;
        }
        if (shit) { printf("0\n"); continue; }
        answer = 0;
        dfs(0, 0);
        printf("%d\n", answer);
    }
    return 0;
}

