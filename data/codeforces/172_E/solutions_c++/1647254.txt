#include<iostream>
#include<vector>
#include<sstream>
#include<algorithm>
#include<numeric>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<complex>
#include<set>
#include<map>
#include<queue>
#include<cassert>

using namespace std;

#define rep(i,n) for(int i=0;i<n;i++)
#define rp(i,c) rep(i,(c).size())
#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)
#define pb push_back
#define mp make_pair
#define all(c) (c).begin(),(c).end()
#define dbg(x) cerr<<#x<<" = "<<(x)<<endl

typedef vector<int> vi;
typedef vector<string> vs;
typedef pair<int,int> pi;
typedef unsigned long long ll;

inline ll hash(const string &s){
	ll res = 0;
	rep(i, s.size()) res *= 29, res += s[i] - 'a' + 1;
	return res;
}

struct T{
	string name;
	vector<T*> cld;
	ll h;
	T(const string &s){
		name = s;
		h = hash(s);
	}
};
int n, pos;
string in, next;

bool getnext(){
	if(pos >= in.size()) return 0;
	next.clear();
	for(; ; ){
		next.pb(in[pos]);
		if(in[pos++] == '>') break;
	}
	return 1;
}
T* term(){
	if(next[next.size() - 2] == '/'){
		return new T(next.substr(1, next.size() - 3));
	}
	string tag = next.substr(1, next.size() - 2);
	T* res = new T(tag);
	
	for(; ; ){
		getnext();
		if(next[1] == '/'
			&& next.substr(2, next.size() - 3) == tag) break;
		res->cld.pb(term());
	}
	return res;
}

void run()
{
	cin >> in;
	T *t = new T("_");
	while(getnext()){
		t->cld.pb(term());
	}
	t->h = 28;
	
	cin >> n;
	string s;
	getline(cin, s);
	rep(i, n){
		getline(cin, s);
		stringstream ss(s);
		vector<ll> hs;
		while(ss >> s) hs.pb(hash(s));
		
		queue<pair<int, T*> > q;
		q.push(mp(0, t));
		int ans = 0;
		while(!q.empty()){
			int m = q.front().first;
			T *t = q.front().second;
			q.pop();
			if(m < hs.size() && t->h == hs[m]) m++;
			if(m == hs.size() && t->h == hs[m-1]) ans++;
			rep(i, t->cld.size()) q.push(mp(m, t->cld[i]));
		}
		cout << ans << endl;
	}
}

int main()
{
	run();
}
