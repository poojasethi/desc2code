
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <stack>
#include <sstream>

using namespace std;

const int maxn = 1000001;
typedef long long LL;
struct node_t {
	LL hash;
	vector<int> child;
} node[maxn];
char buf[maxn], buf2[64];
int q, cnt;
stack<int> stk;

int dfs(int n, int pos, const vector<LL> &v) {
	int ret = 0;
	if (pos <= v.size()) {
		if (pos < v.size() && v[pos] == node[n].hash) {
			for (vector<int>::iterator it = node[n].child.begin(); it != node[n].child.end(); ++it) {
				ret += dfs(*it, pos + 1, v);
			}
		} else {
			for (vector<int>::iterator it = node[n].child.begin(); it != node[n].child.end(); ++it) {
				ret += dfs(*it, pos, v);
			}
		}
	}
	return ret + (v.size() <= pos + 1 && *v.rbegin() == node[n].hash);
}

int main() {
	scanf("%s", buf);
	int l = strlen(buf);
	stk.push(0);
	for (int i = 0; i < l; ) {
		int type = 1;
		++i;
		if (buf[i] == '/') type = 2, ++i;
		LL hash = 0;
		while (isalpha(buf[i])) hash = hash * 27 + buf[i++] - 'a' + 1;
		if (buf[i] == '/') type = 3, ++i;
		++i;
		if (type == 1) {
			++cnt;
			node[cnt].hash = hash;
			node[stk.top()].child.push_back(cnt);
			stk.push(cnt);
		} else if (type == 2) {
			stk.pop();
		} else {
			++cnt;
			node[cnt].hash = hash;
			node[stk.top()].child.push_back(cnt);
		}
	}
	scanf("%d\n", &q);
	while (q--) {
		gets(buf);
		stringstream ss(buf);
		vector<LL> ele;
		while (ss >> buf2) {
			l = strlen(buf2);
			LL hash = 0;
			for (int i = 0; i < l; ++i) {
				hash = hash * 27 + buf2[i] - 'a' + 1;
			}
			ele.push_back(hash);
		}
		printf("%d\n", dfs(0, 0, ele));
	}
	return 0;
}
