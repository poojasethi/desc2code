#include <algorithm>
#include <bitset>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <vector>
#define maxn 1000005
using namespace std;

string info[maxn];
vector<int> adj[maxn];
int par[maxn],reach[maxn],num = 1,ret;
vector<string> query;

int create(int node,string store) {
  string _store = "";
  int slash = -1;
  for (int i = 0; i < store.size(); i++) if (store[i] != '/') _store += store[i]; else {
    if (!i) slash = 0; else slash = 1;
  }
  if (slash == 0) return par[node];
  info[num++] = _store;
  adj[node].push_back(num - 1);
  par[num - 1] = node;
  return (slash < 0) ? (num - 1) : node;
}

void TagSpliting() {
  string tag;
  cin >> tag;
  vector<string> fragment;

  int node = 0;
  string store = "";
  for (int i = 0; i < tag.size(); i++) {
    if (tag[i] == '<' || tag[i] == '>') {
      if (!store.empty()) node = create(node,store);
      store.clear();
    }
    else store += tag[i];
  }
}

void DFS(int u) {
  if (reach[u] == query.size() - 1 && info[u] == query[query.size() - 1]) ret++;
  if (reach[u] < query.size() - 1 && info[u] == query[reach[u]]) reach[u]++;
  for (int i = 0; i < adj[u].size(); i++) {
    reach[adj[u][i]] = reach[u];
    DFS(adj[u][i]);
  }
}

int answer(vector<string> query) {
  ret = 0;
  DFS(0);
  return ret;
}

int main() {
  TagSpliting();
  int Q;
  scanf("%d\n", &Q);
  while (Q--) {
    char ch[5005];
    gets(ch);
    query.clear();
    string store = "";
    for (int i = 0; i < strlen(ch); i++)
      if ('a' <= ch[i] && ch[i] <= 'z') store += ch[i]; else if (!store.empty()) {
        query.push_back(store);
	store.clear();
      }
    if (!store.empty()) query.push_back(store);
    ret = 0;
    DFS(0);
    printf("%d\n", ret);
  }
}
