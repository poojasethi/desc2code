#include <cstdio>
#include <map>
#include <string>
#include <cctype>
#include <vector>
#include <sstream>
#include <deque>
#include <cstring>
using namespace std;

map<string,int> m;
int m_count=0;
char s[1000001];

int get_id(string a)
{
	map<string,int>::iterator it = m.find(a);
	if (it!=m.end())
		return it->second;
	m[a] = ++m_count;
	return m_count;
}

struct node
{
	int id;
	vector<node*> childs;
	node() {}
	node(int id)
	{
		this->id = id;
	}
};

node nodes[1000000];
int nodes_cnt = 0;
node *new_node(int id)
{
	nodes[nodes_cnt] = node(id);
	return &nodes[nodes_cnt++];
}

bool solve()
{
	if (scanf("%s",s)==EOF)
		return false;
	node root = node(0);
	deque<node*> d;
	d.push_back(&root);
	for (int i=0;s[i];++i)
	{
		if (s[i+1]=='/')
		{
			for (;s[i]!='>';++i);
			d.pop_back();
		}
		else
		{
			int j;
			string ss;
			for (j=i+1;isalpha(s[j]);++j)
				ss += s[j];
			int id = get_id(ss);
			node *tmp = new_node(id);
			d.back()->childs.push_back(tmp);
			if (s[j]=='/')
				j++;
			else
				d.push_back(tmp);
			i = j;
		}
	}
	int m;
	scanf("%d",&m);
	char xs[3000];
	gets(xs);
	for (int i=0;i<m;++i)
	{
		gets(xs);
		stringstream ss(ios_base::in|ios_base::out);
		ss << xs;
		vector<int> query;
		string x;
		while (ss>>x)
			query.push_back(get_id(x));
		deque<pair<node*,int> > d;
		d.push_back(make_pair(&root,0));
		int ans=0,cnts = 0;
		vector<node*> cnt(query.size());
		while (!d.empty())
		{
			node *cur_node = d.back().first;
			if (d.back().second==0)
			{
				if (cnts == query.size()-1 && query[cnts]==cur_node->id)
					ans++;
				if (cnts<query.size()-1 && query[cnts]==cur_node->id)
					cnt[cnts++] = cur_node;
			}
			if (d.back().second<cur_node->childs.size())
				d.push_back(make_pair(cur_node->childs[d.back().second++],0));
			else
			{
				if (cur_node == cnt[cnts-1])
					cnts--;
				d.pop_back();
			}
		}
		printf("%d\n",ans);
	}
	printf("\n");
	return true;
}

int main()
{
#ifndef ONLINE_JUDGE
	freopen("input.txt","r",stdin);
	while (solve());
#endif
	solve();
	return 0;
}
