#include <iostream>
#include <sstream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <string>
#include <queue>
#include <stack>
#include <map>
#include <set>

#define MAX 1048576

using namespace std;
FILE *in; FILE *out;

char buff[MAX];
char a[MAX]; int n;
int b[256]; int m;

int nxtIdx = 0, curIdx, where = 0;
map <string, int> q;

int tree[MAX];
vector <int> v[MAX];

void parseHtml()
{
	stack < int > s;

	s.push(where);
	tree[where++] = nxtIdx++;

	for (int i = 0; i < n; i++)
	{
		string tag;
		for (i = i + 1; i < n && a[i] != '>'; i++)
			tag += a[i];
		
		// Self closing tag
		if (tag[tag.size() - 1] == '/')
		{
			tag.resize(tag.size() - 1);
			if (q.find(tag) == q.end())
				q[tag] = curIdx = nxtIdx++;
			else curIdx = q[tag];
			
			v[s.top()].push_back(where);
			tree[where++] = curIdx;
		}
		// Closing tag
		else if (tag[0] == '/')
			s.pop();
		// Opening tag
		else
		{
			if (q.find(tag) == q.end())
				q[tag] = curIdx = nxtIdx++;
			else curIdx = q[tag];
			
			v[s.top()].push_back(where); s.push(where);
			tree[where++] = curIdx;
		}
	}
	s.pop();
}

int recurse(int idx, int at)
{
	if (at >= m)
		return 1;
	
	int ans = 0;
	for (int i = 0; i < (int)v[idx].size(); i++)
	{
		if (tree[v[idx][i]] != b[at])
			ans += recurse(v[idx][i], at);
		else
		{
			if (at == m - 1)
				ans += recurse(v[idx][i], at) + 1;
			else
				ans += recurse(v[idx][i], at + 1);
		}
	}
	return ans;
}

int main(void)
{
	in = stdin; out = stdout;
//	in = fopen("E.in", "rt"); out = fopen("E.out", "wt");
	
	fscanf(in, "%s", a); n = (int)strlen(a);
	parseHtml();
	
	int numQueries;
	fscanf(in, "%d", &numQueries);
	fgets(buff, MAX, in);
	for (int i = 0; i < numQueries; i++)
	{
		m = 0;
		fgets(buff, MAX, in);
		stringstream ss(buff);
		string s;
		while (ss >> s)
			b[m++] = q[s];
		fprintf(out, "%d\n", recurse(0, 0));
	}
	return 0;
}
