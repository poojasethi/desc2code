#include <cstdio>
#include <cstring>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

struct Node {
	int fa;
	vector <pair <long long, int> > v;
	Node(int fa = -1) : fa(fa) {
		v.clear();
	}
};

int N;
Node P[1000000];
char buf[1000001], s[1000001];

void build() {
	scanf("%s", buf);
	int len = strlen(buf);
	N = 0;
	P[N++] = Node();
	int pos = 0;
	for (int i = 0, j; i < len; ) {
		j = i + 1;
		bool isClose = buf[j] == '/';
		isClose && ++j;
		for (i = j; i < len && buf[i] != '/' && buf[i] != '>'; ++i);
		if (buf[i] == '/') {
			buf[i] = '\0';
			long long hash = 0;
			for (int k = j; k < i; ++k) {
				hash = hash * 27 + buf[k] - 'a' + 1;
			}
			P[N] = Node(pos);
			P[pos].v.push_back(make_pair(hash, N++));
			i += 2;
		} else {
			if (isClose) {
				pos = P[pos].fa;
			} else {
				buf[i] = '\0';
				long long hash = 0;
				for (int k = j; k < i; ++k) {
					hash = hash * 27 + buf[k] - 'a' + 1;
				}
				P[N] = Node(pos);
				P[pos].v.push_back(make_pair(hash, N));
				pos = N++;
			}
			++i;
		}
	}
}

void dfs(int u) {
	for (vector <pair <long long, int> >::const_iterator i = P[u].v.begin(); i != P[u].v.end(); ++i) {
		dfs(i->second);
	}
}

int n;
long long last;
vector <long long> v;

int gao(int u, int match) {
	int ret = 0;
	for (vector <pair <long long, int> >::const_iterator i = P[u].v.begin(); i != P[u].v.end(); ++i) {
		if (match == n && i->first == last) {
			++ret;
		}
		if (match < n && i->first == v[match]) {
			ret += gao(i->second, match + 1);
		} else {
			ret += gao(i->second, match);
		}
	}
	return ret;
}

int gao() {
	last = v.back();
	v.pop_back();
	n = (int)v.size();
	return gao(0, 0);
}

int main() {
	int m;
	build();
	dfs(0);
	scanf("%d", &m);
	gets(buf);
	for (int i = 0; i < m; ++i) {
		gets(buf);
		int len = strlen(buf);
		v.clear();
		for (int j = 0; j < len; ++j) {
			int k = j;
			long long hash = 0;
			for (; k < len && buf[k] != ' '; hash = hash * 27 + buf[k++] - 'a' + 1);
			v.push_back(hash);
			j = k;
		}
		printf("%d\n", gao());
	}
	return 0;
}
