#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<fstream>
#include<map>
#include<ctime>
#include<set>
#include<queue>
#include<cmath>
#include<vector>
#include<bitset>
#include<functional>
#define x first
#define y second
#define mp make_pair
#define pb push_back
#define REP(i,l,r) for((i)=(l);(i)<=(r);++(i))
#define REP2(i,l,r) for((i)=(l);(i)!=(r);++(i))
using namespace std;

typedef long long LL;
typedef double ld;

const int MAX=200000+10;
const LL INF=(LL)1e17;

int n,b;

struct Arrow
{
	int h,l,r,num;
	int kind;
	Arrow(int a,int b,int c,int d,int e):h(a),l(b),r(c),num(d),kind(e){}
	Arrow(){}
};

int Meet(Arrow a,Arrow b)
{
	if(b.l>b.r)
		swap(b.l,b.r);
	if(a.kind==b.kind)
	{
		if(a.r>=b.l && a.r<=b.r)
			return 0;
		return min(abs(a.r-b.l),abs(a.r-b.r));
	}
	else
		return abs(b.h-a.r);
}

int Go(Arrow a,Arrow b)//从a的终点走向b的终点
{
	if(a.kind==b.kind)
	{
		if(a.r<a.l)
		{
			a.r*=-1;
			a.l*=-1;
			b.l*=-1;
			b.r*=-1;
		}
		if(b.l<b.r && b.r<a.r)
			return -1;
		if(b.l>b.r && b.l<a.r)
			return -1;
		return abs(b.r-a.r);
	}
	else
		return abs(b.h-a.r)+abs(b.r-a.h);
}

int operator < (const Arrow& a,const Arrow& b)
{
	if(a.h!=b.h)
		return a.h<b.h;
	else if(a.l!=b.l)
		return a.l<b.l;
	else if(a.r!=b.r)
		return a.r<b.r;
	else return a.num<b.num;
}

vector<Arrow> X,Y;
int next[MAX];
pair<int,int> be[MAX];

vector< pair< pair<int,int> ,int > > Add;
set< pair<int,int> > hash;

void GetX(vector<Arrow> X,vector<Arrow> Y,int next[MAX])
{
	int i;
	int numX=X.size();
	int numY=Y.size();
	Add.clear();
	REP2(i,0,numY)
	{
		int a=Y[i].l;
		int b=Y[i].r;
		if(a>b)
			swap(a,b);
		Add.pb( mp( mp( a ,1) , i ) );
		Add.pb( mp( mp( b+1 ,-1) , i ) );
	}
	sort(Add.begin(),Add.end());
	sort(X.begin(),X.end());
	int j=0;
	hash.clear();

	REP2(i,0,numX)
	{
		for(;j<(int)Add.size() && Add[j].x.x<=X[i].h;++j)
		{
			int lab=Add[j].y;
			if(Add[j].x.y==-1)
				hash.erase( mp( Y[lab].h,lab ) );
			else
				hash.insert( mp( Y[lab].h,lab ) );
		}
		int u=X[i].num;
		next[u]=-1;
		if(X[i].r<X[i].l)
		{
			set< pair<int,int> >::iterator it=hash.lower_bound( mp( X[i].r+1 , 0 ) );
			if(it==hash.begin())
				;
			else
			{
				--it;
				if(Y[it->y].h<=X[i].r)
					next[ u ] = Y[it->y].num;
			}
		}
		else
		{
			set< pair<int,int> >::iterator it=hash.lower_bound( mp( X[i].r , 0 ) );
			if(it!=hash.end())
				next[ u ] = Y[it->y].num;
		}
	}
}

void BuildSame(vector<Arrow> X,int next[MAX])
{
	int i,j;
	sort(X.begin(),X.end());
	for(i=0;i<(int)X.size();)
	{
		int u=X[i].h;
		vector< Arrow > now;
		for(;X[i].h==u;++i)
			now.pb(X[i]);
		REP2(j,0,(int)now.size())
		{
			int u=now[j].num;
			next[u]=-1;
			if(now[j].r>now[j].l && j+1<(int)now.size())
				next[u]=now[j+1].num;
			if(now[j].r<now[j].l && j)
				next[u]=now[j-1].num;
		}
	}
}

int tmp1[MAX],tmp2[MAX];

Arrow back(int num)
{
	if(be[num].x)
		return Y[be[num].y];
	else return X[be[num].y];
}

void get(vector<Arrow> X,vector<Arrow> Y,int next[MAX])
{
	int i;
	memset(tmp1,-1,sizeof tmp1);
	memset(tmp2,-1,sizeof tmp2);
	GetX(X,Y,tmp1);
	BuildSame(X,tmp2);
	REP2(i,0,(int)X.size())
	{
		int u=X[i].num;
		next[u]=-1;
		if(tmp1[u]==-1 || tmp2[u]==-1)
		{
			if(tmp1[u]!=-1)
				next[u]=tmp1[u];
			else next[u]=tmp2[u];
		}
		else
		{
			int Time1=Meet(X[i],back(tmp1[u]));
			int Time2=Meet(X[i],back(tmp2[u]));
			if(Time1<Time2)
				next[u]=tmp1[u];
			else
				next[u]=tmp2[u];
		}
	}
}

vector< pair<  pair<int,int> , int > > Zhangai[MAX];

void FindNext(vector<Arrow> go,vector<Arrow> X,vector<Arrow> Y,int next[MAX])
{
	int i;
	GetX(go,Y,next);
	REP(i,0,b)
		Zhangai[i].clear();
	REP2(i,0,(int) X.size())
	{
		int a=X[i].l;
		int b=X[i].r;
		if(a>b)
			swap(a,b);
		Zhangai[ X[i].h ].pb( mp( mp(a,b) ,X[i].num ) );
	}
	REP(i,0,b)
		sort(Zhangai[i].begin(),Zhangai[i].end());

	REP2(i,0,(int)go.size())
	{
		vector< pair< pair<int,int> ,int  > >::iterator it; 
		int h=go[i].h;
		int a=go[i].l;
		int b=go[i].r;
		int u=go[i].num;
		it=lower_bound(Zhangai[h].begin(),Zhangai[h].end(), mp( mp(b+1,0) , 0 ) );
		int ne=-1;
		if(b>a)
		{
			if(it!=Zhangai[h].begin())
			{
				--it;
				if(it->x.y>=b)
					;
				else ++it;
			}
			if(it!=Zhangai[h].end())
				ne=it->y;
		}
		else
		{
			if(it==Zhangai[h].begin())
				;
			else
				--it;
			if(it!=Zhangai[h].end())
				if(it->x.x<=b)
					ne=it->y;
		}
		if(ne!=-1)
		{
			if(next[u]==-1)
				next[u]=ne;
			else
			{
				int Time1=Meet(go[i],back(next[u]));
				int Time2=Meet(go[i],back(ne));
				if(Time1>Time2)
					next[u]=ne;
			}
		}
	}
}

const int MAX_Dep=52;

LL length[MAX][MAX_Dep+1];
int To[MAX][MAX_Dep+1];

LL d[MAX];
char dir_a[4]={'U','D','L','R'};
int walk[4][2]={{0,1},{0,-1},{-1,0},{1,0}};
int First_to[MAX],Dir[MAX];
vector<Arrow> Sx,Sy;

pair<LL,LL> Expand( Arrow now ,LL d )
{
	int flag=(now.r>now.l?1:-1);
	if(now.kind==0)
		return mp(now.h,now.r+d*flag);
	else 
		return mp(now.r+d*flag,now.h);
}

pair<LL,LL> Expand2(Arrow now,Arrow ne,LL d)
{
	LL c=Meet(now,ne);
	if(d<=c)
		return Expand(now,d);
	d-=c;
	if(ne.l<ne.r)
		--ne.l;
	else ++ne.l;
	if(now.kind!=ne.kind)
		return Expand( Arrow(ne.h,ne.l,now.h,0,ne.kind) ,d );
	else
	{
		pair<LL,LL> t=Expand(now,c);
		LL u;
		if(ne.kind==0)
			u=t.y;
		else u=t.x;
		return Expand( Arrow(ne.h,ne.l,u,0,ne.kind) , d);
	}
}

int main()
{
#ifndef ONLINE_JUDGE
	freopen("input.txt","r",stdin);freopen("output.txt","w",stdout);
#endif
	int i,j;
	scanf("%d%d",&n,&b);
	REP(i,1,n)
	{
		int x0,y0,x1,y1;
		scanf("%d%d%d%d",&x0,&y0,&x1,&y1);
		if(x0==x1)
		{
			X.pb(Arrow(x0,y0,y1,i,0));
			be[i]=mp(0,X.size()-1);
		}
		else
		{
			Y.pb(Arrow(y0,x0,x1,i,1));
			be[i]=mp(1,Y.size()-1);
		}
	}
	get(X,Y,next);
	get(Y,X,next);
	REP(i,1,n)
		if(next[i]!=-1)
		{
			To[i][0]=next[i];
			length[i][0]=Go(back(i),back(next[i]));
		}
		else
		{
			To[i][0]=i;
			length[i][0]=INF;
		}
	REP2(j,1,MAX_Dep)
		REP(i,1,n)
		{
			int last=To[i][j-1];
			To[i][j]=To[ last ] [j-1];
			length[i][j] = min( INF, length[i][j-1] + length[ last ][j-1] );
		}
	int Q;
	scanf("%d",&Q);
	REP(i,1,Q)
	{
		int x,y;
		char dir;
		cin>>x>>y>>dir>>d[i];
		REP2(j,0,4)
			if(dir_a[j]==dir)
			{
				int nx=x-walk[j][0];
				int ny=y-walk[j][1];
				Dir[i]=j;
				if(nx==x)
					Sx.pb(Arrow(nx,ny,y,i,0));
				else Sy.pb(Arrow(ny,nx,x,i,1));
				break;
			}
	}
	FindNext(Sy,Y,X,First_to);
	FindNext(Sx,X,Y,First_to);
	int vx=0,vy=0;
	REP(i,1,Q)
	{
		Arrow now;
		if(vx<(int)Sx.size() && (vy==(int)Sy.size() || Sy[vy].num>Sx[vx].num))
			now=Sx[vx++];
		else now=Sy[vy++];
		LL need=( First_to[i]==-1?INF: Go( now, back(First_to[i])) );
		pair<LL,LL> ans(-1,-1);
		if(First_to[i]==-1)
			ans=Expand(now,d[i]);
		else if(need>=d[i])
			ans=Expand2(now,back(First_to[i]),d[i]);
		else
		{
			d[i]-=need;
			int u=First_to[i];
			for(int s=MAX_Dep-1;s>=0;)
			{
				for(;s>=0 && length[u][s]>d[i];--s)
					;
				if(s==-1)
					break;
				d[i]-=length[u][s];
				u=To[u][s];
			}
			if(next[u]==-1)
				ans=Expand(back(u),d[i]);
			else
				ans=Expand2(back(u),back(next[u]),d[i]);
		}
		ans.x=max( min(ans.x,(LL)b) , 0LL );
		ans.y=max( min(ans.y,(LL)b) , 0LL );
		cout<<ans.x<<" "<<ans.y<<endl;
	}
	return 0;
}
