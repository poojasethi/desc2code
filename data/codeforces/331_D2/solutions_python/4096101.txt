#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<map>
#include<queue>
#include<stack>
using namespace std;
#define M 1007
#define N 15
#define mod 1000000007
#define ll long long
#define ls p<<1
#define rs p<<1|1
//#pragma comment(linker,"/STACK:1024000000,1024000000")

int bel[M][M], vis[M][M];
int mp[M][M];
int tox[M][M], toy[M][M];
ll step[M][M];
struct Node
{
        int x1, y1, x2, y2;
        int d;
}arr[M];
int dir[4][2] = { {0, -1}, {0, 1}, {-1, 0}, {1, 0} };
int n, b;
bool inside( int x, int y )
{
        return x >= 0 && y >= 0 && x <= b && y <= b;
}

int main()
{
      // freopen( "a.in", "r", stdin );
        cin>>n>>b;
        int xx, yy, dx, dy;
        ll t;
        char s[5];
        for( int i = 1; i <= n; ++i ){
                scanf( "%d%d%d%d", &arr[i].x1, &arr[i].y1, &arr[i].x2, &arr[i].y2 );
                if( arr[i].y1 > arr[i].y2 ) arr[i].d = 0;
                if( arr[i].y1 < arr[i].y2 ) arr[i].d = 1;
                if( arr[i].x1 > arr[i].x2 ) arr[i].d = 2;
                if( arr[i].x1 < arr[i].x2 ) arr[i].d = 3;

                for( int x = min( arr[i].x1, arr[i].x2 ); x <= max( arr[i].x1, arr[i].x2 ); ++x )
                        for( int y = min( arr[i].y1, arr[i].y2 ); y <= max( arr[i].y1, arr[i].y2 ); ++y ) bel[x][y] = i;
        }

        for( int i = 1; i <= n; ++i ){
                dx = dir[arr[i].d][0];
                dy = dir[arr[i].d][1];

                xx = arr[i].x2 + dx;
                yy = arr[i].y2 + dy;

                while( inside( xx, yy ) && !bel[xx][yy] ) xx += dx, yy += dy;

                for( int x = min( arr[i].x1, arr[i].x2 ); x <= max( arr[i].x1, arr[i].x2 ); ++x )
                        for( int y = min( arr[i].y1, arr[i].y2 ); y <= max( arr[i].y1, arr[i].y2 ); ++y )
                                tox[x][y] = xx, toy[x][y] = yy;
        }

        int m;
        cin>>m;
        int haha = 1;
        while( m-- ){
                scanf( "%d%d%s", &xx, &yy, s );
                cin>>t;
                ++haha;
                switch( s[0] ){
                        case 'D': dx = dir[0][0], dy = dir[0][1]; break;
                        case 'U': dx = dir[1][0], dy = dir[1][1]; break;
                        case 'L': dx = dir[2][0], dy = dir[2][1]; break;
                        case 'R': dx = dir[3][0], dy = dir[3][1]; break;
                }

                while( inside( xx, yy ) && !bel[xx][yy] && t ) xx += dx, yy += dy, --t;
                if( !inside( xx, yy ) ){
                        xx -= dx, yy -= dy;
                        printf( "%d %d\n", xx, yy );
                        continue;
                }
                if( !t ){
                        printf( "%d %d\n", xx, yy );
                        continue;
                }

                int tx, ty;
                //memset( step, -1, sizeof(step) );
                while( t ){
                        if( !inside( xx, yy ) ) break;
                        tx = tox[xx][yy];
                        ty = toy[xx][yy];
                        if( vis[xx][yy] == haha )
                                t %= step[xx][yy] - t;
                        else step[xx][yy] = t, vis[xx][yy] = haha;

                        dx = dy = 0;
                        if( tx > xx ) dx = 1;
                        if( tx < xx ) dx = -1;
                        if( ty > yy ) dy = 1;
                        if( ty < yy ) dy = -1;

                        if( abs( tx-xx ) + abs( ty-yy ) < t ){
                                t -= abs( tx-xx ) + abs( ty-yy );
                                xx = tx, yy = ty;
                        }
                        else break;
                }
                if( inside( xx, yy ) ){
                        xx += t * dx;
                        yy += t * dy;
                }
                if( xx < 0 ) xx = 0;
                if( yy < 0 ) yy = 0;
                if( xx > b ) xx = b;
                if( yy > b ) yy = b;
                printf( "%d %d\n", xx, yy );
        }
}












