#pragma comment(linker, "/STACK:512000000")

#include <set>
#include <map>
#include <list>
#include <stack>
#include <queue>
#include <ctime>
#include <math.h>
#include <vector>
#include <string>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <string.h>
#include <algorithm>
#include <sstream>

using namespace std;

// #define eprintf(...) fprintf(stderr, __VA_ARGS__)
#define X first
#define Y second
#define pb push_back
#define mp make_pair
#define sqr(x) ((x)*(x))
//#define foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)

const double PI = acos(-1.0);
const int INF = 1000000000;
const int MOD = 1000000007;

struct position {
	short x, y;
	char direction;
	position () {}
	position (short x, short y, char direction) : x(x), y(y), direction(direction) {}
};

int sgn (int x) {
	if (x < 0) return -1;
	if (x > 0) return +1;
	return 0;
}

const int N = 1002;

int main() {
	int _start = clock();

//#define ONLINE_JUDGE

#ifndef ONLINE_JUDGE
    freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);
#else
#define taskname "domino-covering-2"
	//freopen(taskname".in","r",stdin);
    //freopen(taskname".out","w",stdout);
#endif


	int n, b; cin >> n >> b;

	int dx[] = {0,  0, -1, 1};
	int dy[] = {1, -1,  0, 0};

	map<char, int> directions;
	directions['U'] = 0;
	directions['D'] = 1;
	directions['L'] = 2;
	directions['R'] = 3;

	position to[N][N][4][2];

	char arrows[N][N];
	memset(arrows, -1, sizeof(arrows));

	int x0, y0, x1, y1;
	for (int i = 0; i < n; ++i) {
		scanf("%d %d %d %d", &x0, &y0, &x1, &y1);

		int cx = sgn(x1 - x0);
		int cy = sgn(y1 - y0);
		int dir = 0;

		for (int j = 0; j < 4; ++j) {
			if (dx[j] == cx && dy[j] == cy) {
				dir = j;
				break;
			}
		}

		do {
			arrows[x0][y0] = dir;
			x0 += cx;
			y0 += cy;
		} while (!(x0 == x1 && y0 == y1));
		arrows[x0][y0] = dir;
	}

	for (int i = 0; i <= b; ++i) {
		for (int j = 0; j <= b; ++j) {
			for (int dir = 0; dir < 4; ++dir) {

				int tdir = dir;
				if (arrows[i][j] != -1) tdir = arrows[i][j];

				int nx = i + dx[tdir], ny = j + dy[tdir];
				if (nx < 0 || nx > b || ny < 0 || ny > b) {
					to[i][j][dir][0] = position(i, j, tdir);
					continue;
				}

				to[i][j][dir][0] = position(nx, ny, tdir);
			}
		}
	}

	int q, x, y, dir;
	long long t[100005];
	position at_q[100005];
	cin >> q;
	for (int i = 0; i < q; ++i) {
		scanf("%d %d %c", &x, &y, &dir);
		cin >> t[i];

		at_q[i].x = x;
		at_q[i].y = y;
		at_q[i].direction = directions[dir];

		if (t[i] % 2 == 1) {
			at_q[i] = to[at_q[i].x][at_q[i].y][at_q[i].direction][0];
		}
	}

	int prev = 0, next = 1;
	
	for (int step = 1; step <= 55; ++step) {
		for (int i = 0; i <= b; ++i) {
			for (int j = 0; j <= b; ++j) {			
					for (int dir = 0; dir < 4; ++dir) {
						position p1 = to[i][j][dir][prev];
						to[i][j][dir][next] = to[p1.x][p1.y][p1.direction][prev];
					}
			}
		}

		for (int i = 0; i < q; ++i) {
			if (t[i] & (1ll << step))
				at_q[i] = to[at_q[i].x][at_q[i].y][at_q[i].direction][next];
		}
		swap(next, prev);
	}

	for (int i = 0; i < q; ++i) {
		printf("%d %d\n", at_q[i].x, at_q[i].y);
	}

	

	
	cerr << endl << endl << "Time: " << (double)(clock() - _start) / CLOCKS_PER_SEC << endl;

	return 0;
}