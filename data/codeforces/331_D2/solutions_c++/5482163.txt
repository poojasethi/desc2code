#include <cstdio>
#include <algorithm>
#include <string.h>
#include <vector>
#include <map>
#include <iostream>
#define x first
#define left left1
#define y second
#define mp make_pair
#define pb push_back
#define ABS(a) ((a)>0?(a):(-(a)))
using namespace std;
typedef long long LL;
typedef double ld;
typedef pair<int,int> pii;
typedef pair<LL,LL> pll;
const int NMax=201000,MMax=200;
struct node {
	int k,lazy;
}T[NMax*4];
void insert(int a,int b,int c,int x,int y,int p) {
	if(a>b) swap(a,b);
	if(a==x&&b==y) {
		T[p].k=T[p].lazy=c;
		return ;
	}
	if(T[p].lazy) {
		T[p*2].k=T[p*2].lazy=T[p*2+1].k=T[p*2+1].lazy=T[p].lazy;
		T[p].lazy=0;
	}
	int mid=(x+y)>>1;
	if(b<=mid) insert(a,b,c,x,mid,p*2);
	else if(a>mid) insert(a,b,c,mid+1,y,p*2+1);
	else insert(a,mid,c,x,mid,p*2),insert(mid+1,b,c,mid+1,y,p*2+1);
}
int calc(int a,int x,int y,int p) {
	if(x==y)
		return T[p].k;
	if(T[p].lazy) {
		T[p*2].k=T[p*2].lazy=T[p*2+1].k=T[p*2+1].lazy=T[p].lazy;
		T[p].lazy=0;
	}
	int mid=(x+y)>>1;
	if(a<=mid) return calc(a,x,mid,p*2);
	else return calc(a,mid+1,y,p*2+1);
}
int min(LL a,int b){return min(a,(LL)b);}
int max(LL a,int b){return max(a,(LL)b);}
int M,N,nn,o[NMax],o1[NMax];
pii G[NMax];
int G0[NMax];
pair<pii,pii> point[NMax];
pair<LL,int> query[NMax];
pair<pii,int> P[NMax];
vector<pair<pii,int> >S[10][NMax];
vector<pii> S1[10][NMax];
vector<pii> A[10][NMax];
pair<int,LL> jump[NMax][55];
int main()
{
	scanf("%d%d",&N,&M);
	M++;
	for(int i=1;i<=N;i++) {
		int x1,y1,x2,y2;
		scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		swap(x1,y1);swap(x2,y2);
		x1++;y1++;x2++;y2++;
		if(x1==x2) {
			P[++nn]=mp(mp(y1,y2),x1);
			point[nn]=mp(mp(x1,y1),mp(x2,y2));
			S[0][x1].pb(mp(mp(y1,y2),nn));
			S[1][x1].pb(mp(mp(y1,y2),nn));
			if(y1<y2)A[2][y2].pb(mp(x1,nn)),o1[nn]=o[nn]=2;
			else A[3][y2].pb(mp(x1,nn)),o1[nn]=o[nn]=3;
		}else {
			P[++nn]=mp(mp(x1,x2),y1);
			point[nn]=mp(mp(x1,y1),mp(x2,y2));
			S[2][y1].pb(mp(mp(x1,x2),nn));
			S[3][y1].pb(mp(mp(x1,x2),nn));
			if(x1<x2)A[0][x2].pb(mp(y1,nn)),o1[nn]=o[nn]=0;
			else A[1][x2].pb(mp(y1,nn)),o1[nn]=o[nn]=1;
		}
		//U:x+ D:x- L:y- R:y+
	}
	int Q;
	scanf("%d",&Q);
	for(int i=1;i<=Q;i++) {
		int x,y;
		char buf[5];
		LL t;
		scanf("%d%d%s%lld",&x,&y,buf,&t);
		swap(x,y);
		x++;y++;
		nn++;
		point[nn]=mp(mp(x,y),mp(x,y));
		if(buf[0]=='U')A[0][x].pb(mp(y,nn)),S1[0][x].pb(mp(y,nn)),S1[1][y].pb(mp(x,nn)),o1[nn]=o[nn]=0;
		if(buf[0]=='D')A[1][x].pb(mp(y,nn)),S1[0][x].pb(mp(y,nn)),S1[1][y].pb(mp(x,nn)),o1[nn]=o[nn]=1;
		if(buf[0]=='R')A[2][y].pb(mp(x,nn)),S1[1][y].pb(mp(x,nn)),S1[0][x].pb(mp(y,nn)),o1[nn]=o[nn]=2;
		if(buf[0]=='L')A[3][y].pb(mp(x,nn)),S1[1][y].pb(mp(x,nn)),S1[0][x].pb(mp(y,nn)),o1[nn]=o[nn]=3;
		query[i]=mp(t,nn);
	}
	memset(G0,-1,sizeof(G0));
	for(int I=0;I<2;I++) {
		int i1=(I==0)?0:2;
		for(int i=1;i<=M;i++) if(S[i1][i].size()&&S1[I][i].size()){
			sort(S1[I][i].begin(),S1[I][i].end());
			sort(S[i1][i].begin(),S[i1][i].end());
			int p=-1;
			for(int j=0;j<S1[I][i].size();j++) {
				while(p+1<S[i1][i].size() && min(S[i1][i][p+1].x.y,S[i1][i][p+1].x.x)<=S1[I][i][j].x)p++;
				if(p!=-1&&(S[i1][i][p].x.x-S1[I][i][j].x)*(S[i1][i][p].x.y-S1[I][i][j].x)<=0) {
					G[S1[I][i][j].y]=mp(S[i1][i][p].y,ABS(S1[I][i][j].x-S[i1][i][p].x.y));
					G0[S1[I][i][j].y]=min(G[S1[I][i][j].y].y,ABS(S1[I][i][j].x-S[i1][i][p].x.x));
					o[S1[I][i][j].y]=-1;o1[S1[I][i][j].y]=o1[S[i1][i][p].y];
				}
				if(I==0) {
					if(o[S1[I][i][j].y]==2&&p+1<S[i1][i].size())G[S1[I][i][j].y]=mp(S[i1][i][p+1].y,ABS(S1[I][i][j].x-S[i1][i][p+1].x.y))
,G0[S1[I][i][j].y]=min(G[S1[I][i][j].y].y,ABS(S1[I][i][j].x-S[i1][i][p+1].x.x));
					else if(p!=-1&&o[S1[I][i][j].y]==3)G[S1[I][i][j].y]=mp(S[i1][i][p].y,ABS(S1[I][i][j].x-S[i1][i][p].x.y)),
G0[S1[I][i][j].y]=min(G[S1[I][i][j].y].y,ABS(S1[I][i][j].x-S[i1][i][p].x.x));
				}else {
					if(o[S1[I][i][j].y]==1&&p!=-1)G[S1[I][i][j].y]=mp(S[i1][i][p].y,ABS(S1[I][i][j].x-S[i1][i][p].x.y)),
G0[S1[I][i][j].y]=min(G[S1[I][i][j].y].y,ABS(S1[I][i][j].x-S[i1][i][p].x.x));
					else if(o[S1[I][i][j].y]==0&&p+1<S[i1][i].size())G[S1[I][i][j].y]=mp(S[i1][i][p+1].y,ABS(S1[I][i][j].x-S[i1][i][p+1].x.y)),
G0[S1[I][i][j].y]=min(G[S1[I][i][j].y].y,ABS(S1[I][i][j].x-S[i1][i][p+1].x.x));
				}
			}
		}
	}
	//if(N==7&&M==11)
	//printf("%d %d\n",G[464].x,G[464].y);
	for(int I=0;I<4;I++) {
		memset(T,0,sizeof(T));
		for(int i=1;i<=M;i++) {
			int i1=(I&1)?i:(M-i+1);
			//当I为偶数时，倒着扫描
			//I=0或1时，沿x走
			sort(S1[I][i1].begin(),S1[I][i1].end());
			sort(S[I][i1].begin(),S[I][i1].end());
			for(int j=0;j<S[I][i1].size();j++){
				int a=S[I][i1][j].x.x,b=S[I][i1][j].x.y;
				insert(a,b,S[I][i1][j].y,1,M,1);
				if(a<b&&j!=S[I][i1].size()-1&&(G0[S[I][i1][j].y]==-1||G0[S[I][i1][j].y]>min(ABS(S[I][i1][j+1].x.y-b),ABS(S[I][i1][j+1].x.x-b)))) G[S[I][i1][j].y]=mp(S[I][i1][j+1].y,ABS(S[I][i1][j+1].x.y-b)),
G0[S[I][i1][j].y]=min(G[S[I][i1][j].y].y,ABS(S[I][i1][j+1].x.x-b));
				else if(b<a&&j!=0&&(G0[S[I][i1][j].y]==-1||G0[S[I][i1][j].y]>min(ABS(S[I][i1][j-1].x.y-b),ABS(S[I][i1][j-1].x.x-b)))) G[S[I][i1][j].y]=mp(S[I][i1][j-1].y,ABS(S[I][i1][j-1].x.y-b)),
G0[S[I][i1][j].y]=min(G[S[I][i1][j].y].y,ABS(S[I][i1][j-1].x.x-b));
			}
			for(int j=0;j<A[I][i1].size();j++) {
				int ret=calc(A[I][i1][j].x,1,M,1);
				int dist=ABS(i1-P[ret].y)+ABS(A[I][i1][j].x-P[ret].x.y),dist1=ABS(i1-P[ret].y);
				if(ret&&o[A[I][i1][j].y]==o1[A[I][i1][j].y]&&((!G[A[I][i1][j].y].x)||(G[A[I][i1][j].y].x&&(G0[A[I][i1][j].y]==-1||G0[A[I][i1][j].y]>dist1))))G[A[I][i1][j].y]=mp(ret,dist),G0[A[I][i1][j].y]=dist1;
			}
		}		
	}
	for(int i=1;i<=nn;i++)jump[i][0]=G[i];
	for(int i=1;i<=51;i++) {
		for(int j=1;j<=nn;j++) {
			if(!jump[j][i-1].x) continue;
			jump[j][i]=mp(jump[jump[j][i-1].x][i-1].x,jump[jump[j][i-1].x][i-1].y+jump[j][i-1].y);
			if(jump[j][i].y>1000000000000000LL) jump[j][i].y=1000000000000001LL;
		}
	}
	for(int i=1;i<=Q;i++) {
		int a=query[i].y;
		LL k=query[i].x;
		for(int j=50;j>=0;j--){ 
			while(jump[a][j].x&&k>=jump[a][j].y) {
				k-=jump[a][j].y;
				a=jump[a][j].x;
			}
		}
		if(k==0) {
			printf("%d %d\n",point[a].y.y-1,point[a].y.x-1);
			continue;
		}
		int b=G[a].x;
		if(b==0) {
			if(o1[a]==0||o1[a]==1) {
				if(o1[a]==0)printf("%d %d\n",point[a].x.y-1,min((LL)point[a].y.x+k,M)-1);
				else printf("%d %d\n",point[a].x.y-1,max((LL)point[a].y.x-k,1)-1);
			}else {
				if(o1[a]==2)printf("%d %d\n",min((LL)point[a].y.y+k,M)-1,point[a].x.x-1);
				else printf("%d %d\n",max((LL)point[a].y.y-k,1)-1,point[a].x.x-1);
			}
		}else {
			int x1=point[a].y.y,y1=point[a].y.x;
			if(o1[a]==0||o1[a]==1) {
				if(point[b].x.y==point[b].y.y) {
					if(point[a].y.x<point[b].y.x)printf("%d %lld\n",point[a].y.y-1,point[a].y.x+k-1);
					else printf("%d %lld\n",point[a].y.y-1,point[a].y.x-k-1);
				}else {
					if(ABS(point[b].y.x-point[a].y.x)>=k){
						if(point[a].y.x<point[b].y.x)printf("%d %lld\n",point[a].y.y-1,point[a].y.x+k-1);
						else printf("%d %lld\n",point[a].y.y-1,point[a].y.x-k-1);
					}else {
						k-=ABS(point[a].y.x-point[b].y.x);
						y1=point[b].y.x;
						if(point[b].y.y<point[b].x.y) x1-=k;
						else x1+=k;
						printf("%d %d\n",x1-1,y1-1);
					}	
				}
			}else {
				if(point[b].x.x==point[b].y.x) {
					if(point[a].y.y<point[b].y.y)printf("%lld %d\n",point[a].y.y+k-1,point[a].y.x-1);
					else printf("%lld %d\n",point[a].y.y-k-1,point[a].y.x-1);
				}else {
					if(ABS(point[b].y.y-point[a].y.y)>=k){
						if(point[a].y.y<point[b].y.y)printf("%lld %d\n",point[a].y.y+k-1,point[a].y.x-1);
						else printf("%lld %d\n",point[a].y.y-k-1,point[a].y.x-1);
					}else {
						k-=ABS(point[a].y.y-point[b].y.y);
						x1=point[b].y.y;
						if(point[b].y.x<point[b].x.x) y1-=k;
						else y1+=k;
						printf("%d %d\n",x1-1,y1-1);
					}	
				}
			}
		}
	}
	return 0;
}
