#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <utility>
#define MAXN 1005

using namespace std;

struct coord
{
	int x, y, dir;
};

struct node
{
	int cycle, cyclepos;
	int len;
	int visited;
};

int main ()
{
	int N, B;
	scanf("%d %d",&N,&B);
	static struct node a[MAXN][MAXN][4];
	static int d[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};
	int x, y, dir;
	static int ch[MAXN][MAXN];
	for (x = 0; x <= B; x++)
	{
		for (y = 0; y <= B; y++)
		{
			ch[x][y] = -1;
			for (dir = 0; dir < 4; dir++)
			{
				a[x][y][dir].visited = -1;
			}
		}
	}
	static struct coord q[MAXN*MAXN*4];
	int X0, Y0, X1, Y1;
	int i, temp;
	for (i = 0; i < N; i++)
	{
		scanf("%d %d %d %d",&X0,&Y0,&X1,&Y1);
		int ndir = -1;
		if (X0 == X1)
		{
			if (Y0 < Y1) ndir = 0;
			else ndir = 1;
		}
		else
		{
			if (X0 < X1) ndir = 3;
			else ndir = 2;
		}
		if (X0 > X1) { temp = X0; X0 = X1; X1 = temp; }
		if (Y0 > Y1) { temp = Y0; Y0 = Y1; Y1 = temp; }
		if (X0 == X1)
		{
			x = X0;
			for (y = Y0; y <= Y1; y++)
			{
				ch[x][y] = ndir;
			}
		}
		else
		{
			y = Y0;
			for (x = X0; x <= X1; x++)
			{
				ch[x][y] = ndir;
			}
		}
	}

	static int cycles[MAXN*MAXN*4][2];
	int cyclesc = 0;

	int qw, z, st;
	qw = 0;
	int x7, y7, dir7;
	for (x7 = 0; x7 <= B; x7++)
	{
		for (y7 = 0; y7 <= B; y7++)
		{
			for (dir7 = 0; dir7 < 4; dir7++)
			{
				if (a[x7][y7][dir7].visited == -1)
				{
					x = x7; y = y7; dir = dir7;
					st = qw;
					while (1)
					{
						//printf("%d %d %d\n",x,y,dir);
						if (a[x][y][dir].visited == -2)
						{
							int cycle, cyclepos, len;
							cycle = a[x][y][dir].cycle;
							cyclepos = a[x][y][dir].cyclepos;
							len = a[x][y][dir].len;
							for (z = qw-1; z >= st; z--)
							{
								a[q[z].x][q[z].y][q[z].dir].cycle = cycle;
								a[q[z].x][q[z].y][q[z].dir].cyclepos = cyclepos;
								len++;
								a[q[z].x][q[z].y][q[z].dir].len = len;
								a[q[z].x][q[z].y][q[z].dir].visited = -2;
							}
							break;
						}
						else if (a[x][y][dir].visited != -1)
						{
							int cycle, cyclepos, len;
							len = qw - a[x][y][dir].visited;
							cycles[cyclesc][0] = a[x][y][dir].visited;
							cycles[cyclesc][1] = qw;
							cycle = cyclesc;
							cyclepos = len;
							len = 0;
							int saved = a[x][y][dir].visited;
							cyclesc++;
							//printf("%d %d\n",qw,a[x][y][dir].visited);
							for (z = qw-1; z >= saved; z--)
							{
								a[q[z].x][q[z].y][q[z].dir].cycle = cycle;
								cyclepos--;
								a[q[z].x][q[z].y][q[z].dir].cyclepos = cyclepos;
								a[q[z].x][q[z].y][q[z].dir].len = 0;
								a[q[z].x][q[z].y][q[z].dir].visited = -2;
							}
							for (z = saved-1; z >= st; z--)
							{
								a[q[z].x][q[z].y][q[z].dir].cycle = cycle;
								a[q[z].x][q[z].y][q[z].dir].cyclepos = cyclepos;
								len++;
								a[q[z].x][q[z].y][q[z].dir].len = len;
								a[q[z].x][q[z].y][q[z].dir].visited = -2;
							}
							break;
						}
						a[x][y][dir].visited = qw;
						q[qw].x = x;
						q[qw].y = y;
						q[qw].dir = dir;
						qw++;
						if (ch[x][y] != -1) dir = ch[x][y];
						x += d[dir][0];
						y += d[dir][1];
						if ((x < 0) || (x > B) || (y < 0) || (y > B))
						{
							x -= d[dir][0];
							y -= d[dir][1];
						}
					}
				}
			}
		}
	}
/*
	for (x = 0; x <= B; x++)
	{
		for (y = 0; y <= B; y++)
		{
			for (dir = 0; dir < 4; dir++)
			{
				printf("a[%d][%d][%d] = (visited, cycle, cyclepos, len) = (%d, %d, %d, %d)\n",x,y,dir,a[x][y][dir].visited,a[x][y][dir].cycle,a[x][y][dir].cyclepos,a[x][y][dir].len);
			}
		}
	}
*/
	int Q;
	scanf("%d",&Q);
	int iQ;
	for (iQ = 0; iQ < Q; iQ++)
	{
		long long T;
		char c;
		scanf("%d %d %c %I64i",&x,&y,&c,&T);
		if (c == 'U') dir = 0;
		else if (c == 'D') dir = 1;
		else if (c == 'L') dir = 2;
		else dir = 3;
		if (T < (long long)(a[x][y][dir].len))
		{
			while (1)
			{
				if (T == 0LL) break;
				if (ch[x][y] != -1) dir = ch[x][y];
				x += d[dir][0];
				y += d[dir][1];
				T--;
			}
			printf("%d %d\n",x,y);
		}
		else
		{
			T -= (long long)(a[x][y][dir].len);
			int clen = cycles[a[x][y][dir].cycle][1] - cycles[a[x][y][dir].cycle][0];
			T %= (long long)(clen);
			int pos = cycles[a[x][y][dir].cycle][0] + ((a[x][y][dir].cyclepos + (int)(T)) % clen);
			printf("%d %d\n",q[pos].x,q[pos].y);
		}
	}
	return 0;
}