#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<deque>
#define N 100001
#define pb push_back
#define pf push_front
using namespace std;
deque<int> D[320];
int p, n, q, i, la, A[320][N], s[N];
int In(int x) {return (x - 1) / p + 1;}
int count(int x) {return x - In(x) * p + p - 1;}
void Make_block()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d", &s[i]);
	p = (int) pow(n, 0.618);
	for (int i = 1; i <= n; i++)
	{
		A[In(i)][s[i]]++;
		D[In(i)].pb(s[i]);
	}
}
inline void Updata(int l, int r)
{
	int kl = In(l), kr = In(r), cl = count(l), cr = count(r);
	int xl = D[kl][count(l)], xr = D[kr][count(r)];
	
	D[kl].insert(D[kl].begin() + cl, xr);
	A[kl][xr]++;
	if (kl == kr) cr++;
	D[kr].erase(D[kr].begin() + cr);
	A[kr][xr]--;

	for (int i = kl; i < kr; i++)
	{
		int x = D[i].back();
		D[i].pop_back(), A[i][x]--;
		D[i + 1].pf(x), A[i + 1][x]++;
	}
}
inline int Query(int l, int r, int k)
{
	int kl = In(l), kr = In(r), sum = 0;
	if (kl == kr)
	{
		for (int i = count(l); i <= count(r); i++)
			if (D[kl][i] == k) sum++;
		return sum;
	}
	
	for (int i = kl + 1; i < kr; i++)
		sum += A[i][k];
	for (int i = count(l); i < D[kl].size(); i++)
		if (D[kl][i] == k) sum++;
	for (int i = 0; i <= count(r); i++)
		if (D[kr][i] == k) sum++;
	return sum;
}
void work(int &x) {x = (x + la - 1) % n + 1;}
int main()
{
	Make_block();
	scanf("%d", &q);
	la = 0;
	int ty, l, r, k;
	for (i = 1; i <= q; i++)
	{
		scanf("%d%d%d", &ty, &l, &r);
		work(l), work(r);
		if (l > r) swap(l, r);
		if (ty == 1) Updata(l, r);
		else {
			scanf("%d", &k);
			work(k);
			la = Query(l, r, k);
			printf("%d\n", la);
		}
	}
	return 0;
}