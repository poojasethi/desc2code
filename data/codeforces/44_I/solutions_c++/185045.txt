#include <map>
#include <set>
#include <list>
#include <cmath>
#include <queue>
#include <stack>
#include <bitset>
#include <vector>
#include <cstdio>
#include <string>
#include <sstream>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int Ans[] = { 1 , 1 , 2 , 5 , 15 , 52 , 203 , 877 , 4140 , 21147 , 115975 } ;
struct Tnode{
	int T ;
	vector<int> A[11] ;
};
int N , S[2] ;
Tnode P[2][120000] ;

int main()
{
	scanf( "%d" , &N ) ;
	printf( "%d\n" , Ans[N] ) ;
	S[0] = 1 ;
	P[0][0].T = 1 ;
	P[0][0].A[0].push_back( 0 ) ;
	for ( int i = 1 ; i < N ; i ++ ) {
		int U = ( i - 1 ) & 1 ;
		int V = i & 1 ;
		memset( P[V] , 0 , sizeof( P[V] ) ) ;
		S[V] = 0 ;
		for ( int j = 0 ; j < S[U] ; j ++ ) {
			if ( j & 1 ) {
				for ( int k =P[U][j].T ; k >= 0 ; k -- ) {
					P[U][j].A[k].push_back( i ) ;
					P[V][S[V]].T = max( k + 1 , P[U][j].T ) ;
					for ( int l = 0 ; l < max( k + 1 , P[U][j].T ) ; l ++ )
						P[V][S[V]].A[l] = P[U][j].A[l] ;
					S[V] ++ ;
					P[U][j].A[k].pop_back();
				}
			} else {
				for ( int k = 0 ; k <= P[U][j].T ; k ++ ) {
					P[U][j].A[k].push_back( i ) ;
					P[V][S[V]].T = max( k + 1 , P[U][j].T ) ;
					for ( int l = 0 ; l < max( k + 1 , P[U][j].T ) ; l ++ )
						P[V][S[V]].A[l] = P[U][j].A[l] ;
					S[V] ++ ;
					P[U][j].A[k].pop_back();
				}
			}
		}
	}
	int V = ( N - 1 ) & 1 ;
	for ( int i = 0 ; i < S[V] ; i ++ ) {
		for ( int j = 0 ; j < P[V][i].T ; j ++ ) {
			if ( j ) printf( "," ) ;
			printf( "{" ) ;
			for ( int k = 0 ; k < P[V][i].A[j].size() ; k ++ ) {
				if ( k ) printf( "," ) ;
				printf( "%d" , P[V][i].A[j][k] + 1 ) ;
			}
			printf( "}" ) ;
		}
		printf( "\n" ) ;
	}
	return 0 ;
}
