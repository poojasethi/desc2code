#!/usr/bin/python

import sys
from math import *
from bisect import *

def prefixsum(c):
    prefixs = [c[0]]
    for _c in c[1:]:
        prefixs.append(_c + prefixs[-1])
    return prefixs

def Ni(): return tuple(map(int, sys.stdin.readline().split()))
def Nil(): return map(int, sys.stdin.readline().split())

n, m = Ni()
a = Nil()
b = Nil()

# Looking for min(a) >= max(b)

a.sort()
b.sort()

pa = prefixsum(a)
pb = prefixsum(b)

def acost(mx):
    k = bisect_right(a, mx)
    costa = 0 if k == 0 else mx * k - pa[k-1]
    return costa

def acost2(mx):
    k = bisect_right(a, mx)
    if k == 0:
        costa = 0  # all already larger
    elif k == n:
        costa = mx * k - pa[k-1]
    else:
        costa = mx * k - pa[k-1]
    return costa

def bcost(mx):
    k = bisect_right(b, mx)
    if k == 0:
        costb = pb[-1] - mx * m
    elif k == m:
        costb = 0
    else:
        costb = pb[-1] - pb[k-1] - mx * (m - k)

    return costb

def ternarySearch(f, v, left, right):
    while True:
        leftThird = left + (right - left) / 3
        rightThird = left + (right - left) * 2 / 3

        if right - left <= 5:
            return min((f(v[i]), v[i]) for i in range(left, right+1))[1]
 
        if f(v[leftThird]) > f(v[rightThird]):
            left = leftThird
        else:
            right = rightThird

def findf(balance):
    return acost(balance) + bcost(balance)

c = a + b
c.sort()

v = ternarySearch(findf, c, 0, len(c) - 1)
print findf(v)

