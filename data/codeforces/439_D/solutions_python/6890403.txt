#from __future__ import division;
from bisect import *;
import sys;
from math import *;
from fractions import *;
from itertools import *;
import io;
import re;

INF = 987654321987654321987654321;

def readint(delimiter=' ') :
    return map(int, raw_input().split(delimiter));

def readstr(delimiter=' ') :
    return raw_input().split(delimiter);

def readfloat(delimiter=' ') :
    return map(float, raw_input().split(delimiter));

def index(a, x):
    'Locate the leftmost value exactly equal to x'
    i = bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i
    raise ValueError

def find_lt(a, x):
    'Find rightmost value less than x'
    i = bisect_left(a, x)
    if i:
        return a[i-1]
    raise ValueError

def find_le(a, x):
    'Find rightmost value less than or equal to x'
    i = bisect_right(a, x)
    if i:
        return a[i-1]
    raise ValueError

def find_gt(a, x):
    'Find leftmost value greater than x'
    i = bisect_right(a, x)
    if i != len(a):
        return a[i]
    raise ValueError

def find_ge(a, x):
    'Find leftmost item greater than or equal to x'
    i = bisect_left(a, x)
    if i != len(a):
        return a[i]
    raise ValueError

def bin_search(a, x, left, right) :

    while left<=right :
        mid = (left + right)//2;

        if a[mid] == x :
            return mid;
        elif a[mid] < x :
            left = mid + 1;
        elif a[mid] > x :
            right = mid - 1;

        pass

    return -1;
    pass

def printf(format, *args):
    """Format args with the first argument as format string, and write.
    Return the last arg, or format itself if there are no args."""
    sys.stdout.write(str(format) % args)
    pass

if __name__ == '__main__':

    n, m = readint();
    a = sorted(readint());
    b = sorted(readint());

    dpa = [a[0]];
    dpb = [b[0]];
    for ii in xrange(1, len(a)) :
        dpa.append(dpa[-1]+a[ii]);
        pass

    for ii in xrange(1, len(b)) :
        dpb.append(dpb[-1]+b[ii]);
        pass

    # search target #
    left = 0;
    right = max(a[-1], b[-1]);
    # func #
    def numop(target) :

        #print "TARGET", target;
        idx = bisect_left(a, target);
        needopa, needopb = 0, 0;
        if idx-1 == -1 :
            pass
        else :
            needopa += target*(idx) - dpa[idx-1];
            pass
        #print "ARR A",idx;
        idx = bisect_left(b, target);
        needopb += (dpb[-1] - (dpb[idx-1] if idx !=0 else 0)) - target * (len(b)-idx);

        #print "ARR B",idx;
        #print "COST", needopa, needopb;
        return needopa+needopb;

        """
        needop = 0;
        for ii in xrange(len(a)) :
            needop += max(target - a[ii], 0);
        for ii in xrange(len(b)) :
            needop += max(b[ii] - target, 0);
        return needop;
        """
        pass
    # end func #
    """
    for ii in xrange(left, right+1) :
        abc = numop(ii);
        print ii, abc;
    """

    # ternary search #
    minneed = INF;
    while True :
        leftthird = (2*left + right)/3;
        rightthird = (left + 2*right)/3;
        #leftthird = left + (right - left)/3;
        #rightthird = left + (right - left)*2/3;

        if right - left <= 2 :
            for ii in xrange(left, right+1) :
                minneed = min(minneed, numop(ii));
            break;

        leftneed = numop(leftthird);
        rightneed = numop(rightthird);
        minneed = min(minneed, leftneed, rightneed);
        #print left, right, leftthird, rightthird, leftneed, rightneed;
        if leftneed < rightneed :
            right = rightthird;
        else :
            left = leftthird;
            pass

        pass
    print minneed;
