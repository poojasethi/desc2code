#include <cstdio>
#include <map>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;
map<int, vector<int> > v;
int par[1000010];
int val[1000010];
int find(int x) {
	return par[x] == x ? x : (par[x] = find(par[x]));
}
void merge(int x, int y) {
	x = find(x), y = find(y);
	if (x == y) return;
	par[y] = x;
	val[x] += val[y];
}
int dx[4] = {-1, 1, 0, 0};
int dy[4] = {0, 0, -1, 1};
int a[1010][1010];
long long ans[1010][1010];
int done[1010][1010];
int main() {
	int n, m;
	long long k;
	scanf("%d%d%I64d", &n, &m, &k);
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			scanf("%d", &a[i][j]);
			int x = i * m + j;
			v[-a[i][j]].push_back(x);
			val[x] = 1;
			par[x] = x;
		}
	}
	for (map<int, vector<int> >::iterator it = v.begin(); it != v.end(); it++) {
		int t = -it->first, sz = 0, tz;
		for (int i = 0; i < it->second.size(); i++) {
			int z = it->second[i], x = z / m, y = z % m;
			for (int d = 0; d < 4; d++) {
				int nx = x + dx[d], ny = y + dy[d];
				if (0 <= nx && nx < n && 0 <= ny && ny < m && a[x][y] <= a[nx][ny]) {
					int nz = nx * m + ny;
					merge(z, nz);
				}
			}
			z = find(z);
			if (sz < val[z]) {
				sz = val[z];
				tz = z;
			}
		}
		if (k % t == 0 && (long long)sz * t >= k) {
			puts("YES");
			long long r = k / t;
			queue<int> q;
			q.push(tz);
			while (q.size()) {
				int z = q.front();
				q.pop();
				int x = z / m, y = z % m;
				done[x][y] = 1;
				if (r) {
					ans[x][y] = t;
					--r;
				}
				for (int d = 0; d < 4; d++) {
					int nx = x + dx[d], ny = y + dy[d];
					if (0 <= nx && nx < n && 0 <= ny && ny < m && find(nx * m + ny) == find(tz) && !done[nx][ny]) {
						done[nx][ny] = 1;
						q.push(nx * m + ny);
					}
				}
			}
			for (int i = 0; i < n; i++) {
				for (int j = 0; j < m; j++) {
					printf("%I64d ", ans[i][j]);
				}
				puts("");
			}
			return 0;
		}
	}
	puts("NO");
	return 0;
}
