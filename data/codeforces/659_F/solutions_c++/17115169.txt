#include <bits/stdc++.h>
#define mp make_pair
#define LL long long
using namespace std;
int sz[1000010];
int p[1000010];
int find(int x){
	if(x==p[x]) return x;
	return p[x] = find(p[x]);
}
void join(int x, int y){
	int xroot = find(x), yroot = find(y);
	p[xroot] = yroot;
}
int A[1010][1010];
bool v[1010][1010];
pair<int,int> value[1000010];
int r, c;
LL k;
int movx[] = {1,-1,0,0};
int movy[] = {0,0,1,-1};
void dfs(int x, int y, int val){
	v[x][y] = true;
	for(int i=0; i<4; i++){
		int nx = x + movx[i],
			ny = y + movy[i];
		if(nx<0 || nx>=r || ny<0 || ny>=c) continue;
		if(A[nx][ny]<val) continue;
		if(A[nx][ny] > val || (A[nx][ny]==val && !v[nx][ny])) {
			if(find(x*c + y) == find(nx*c + ny)) continue;
			int sz1 = sz[find(x*c + y)], sz2 = sz[find(nx*c + ny)];
			join(x*c + y, nx*c + ny);
			sz[find(x*c + y)] = sz1 + sz2;
		}
		if(v[nx][ny]) continue;
		dfs(nx,ny,val);
	}
}
int SOL[1010][1010];
void dfs2(int x, int y, int& req, int& val){
	v[x][y] = true;
	SOL[x][y] = val;
	req--;
	for(int i=0; i<4 && req; i++){
		int nx = x + movx[i],
			ny = y + movy[i];
		if(nx < 0 || nx>=r || ny<0 || ny>=c) continue;
		if(A[nx][ny] < val) continue;
		if(v[nx][ny]) continue;
		dfs2(nx, ny, req, val);
	}
}
void solution(int x, int y, int& req){
	memset(v, false, sizeof(v));
	dfs2(x,y,req, A[x][y]);
	for(int i=0; i<r; i++){
		for(int j=0; j<c; j++){
			printf("%d ", SOL[i][j]);
		}
		printf("\n");
	}
}
int main(){
	scanf("%d %d %I64d", &r, &c, &k);
	for(int i=0; i<r*c; i++){ p[i] = i; sz[i] = 1;}
	for(int i=0; i<r; i++){
		for(int j=0; j<c; j++){
			scanf("%d", &A[i][j]);
			value[i*c + j] = mp(A[i][j], i*c + j);
		}
	}
	sort(value, value+r*c);
	for(int i=r*c-1; i>=0; i--){
		int val = value[i].first;
		LL req = k/(LL)val;
		if((LL)val*req < k) req++;
		int x = value[i].second/c, y = value[i].second%c;
		if(v[x][y]) continue;
		dfs(x,y,val);
		if((LL)val*req == k && sz[find(value[i].second)] >= req){
			printf("YES\n");
			int R = (int)req;
			solution(x,y,R);
			//printf("%d\n", R);
			return 0;
		}
	}
	printf("NO\n");
	return 0;
}