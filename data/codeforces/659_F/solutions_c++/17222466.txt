#include <cstdio>
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
const int N=1010;
struct A{
	int v,x,y;
	bool operator<(const A& a)const{
		return v<a.v;
	}
}p[N*N];
int d[4][2]={{0,1},{0,-1},{1,0},{-1,0}};
int a[N][N],s[N*N],v[N*N];
int T[N*N],mn[N*N],sum[N*N],used[N*N];
int findr(int x){
	if(T[x]==-1) return x;
	else return T[x]=findr(T[x]);
}
long long alsum;
int n,m,goal;
void dfs(int x,int y){
	v[(x-1)*m+y]=1;alsum--;
	if(alsum==0) return;
	int i,dx,dy,ds;
	for(i=0;i<4;i++){
		dx=x+d[i][0];dy=y+d[i][1];ds=(dx-1)*m+dy;
		if(1<=dx&&dx<=n&&1<=dy&&dy<=m&&!v[ds]&&findr(ds)==goal)
			dfs(dx,dy);
		if(alsum==0) return;
	}
}
int main(){
	//freopen("659F.in","r",stdin);
	//freopen("659F.out","w",stdout);
	int i,j,k,len=0,ps,p1,q1,dx,dy,ds;
	long long kk;
	cin>>n>>m>>kk;
	for(i=1;i<=n;i++)
	    for(j=1;j<=m;j++){
	    	scanf("%d",&a[i][j]);
	    	if(kk%a[i][j]==0) s[++len]=a[i][j];
	    }
	sort(s+1,s+len+1);
	len=unique(s+1,s+len+1)-s-1;
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
			p[(i-1)*m+j]=(A){a[i][j],i,j};
	sort(p+1,p+n*m+1);
	for(i=1;i<=n*m;i++) sum[i]=1;
	j=n*m;
	memset(T,-1,sizeof(T));
	for(i=len;i>=1;i--){
		while(j>=1&&p[j].v>=s[i]){
			ps=(p[j].x-1)*m+p[j].y;
			mn[ps]=p[j].v;
			used[ps]=1;
			for(k=0;k<4;k++){
				dx=p[j].x+d[k][0];dy=p[j].y+d[k][1];
				if(1<=dx&&dx<=n&&1<=dy&&dy<=m){
				    ds=(dx-1)*m+dy;
				    if(!used[ds]) continue;
				    p1=findr(ps);q1=findr(ds);
				    if(p1!=q1) T[p1]=q1,sum[q1]+=sum[p1],mn[q1]=min(mn[q1],mn[p1]);
				}
			}
			p1=findr(ps);
			if(mn[p1]==s[i]&&sum[p1]>=kk/s[i]) break;
			j--;
		}
		if(j>=1&&p[j].v>=s[i]) break;
	}
	if(i==0) printf("NO");
	else{
		printf("YES\n");
		alsum=kk/mn[p1];goal=p1;
		for(i=1;i<=n;i++){
		    for(j=1;j<=m;j++)
		        if(findr((i-1)*m+j)==p1&&a[i][j]==mn[p1]) break;
		    if(j<=m) break;
		}
		dfs(i,j);
		for(i=1;i<=n*m;i++){
		    if(v[i]) printf("%d ",mn[p1]);
		    else printf("0 ");
		    if(i%m==0) printf("\n");
		}
	}
	return 0;
}

