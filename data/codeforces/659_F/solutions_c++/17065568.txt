#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <climits>
#include <cstdlib>
#include <queue>
#include <map>
using namespace std ;

typedef pair<int, int> pii;

const int inf = 0x3f3f3f3f ;

inline int read() 
{
    int x = 0 , f = 1 ; char ch = getchar() ;
    for ( ; ch < '0' || ch > '9' ; ch = getchar() ) if ( ch == '-' ) f = -1 ;
    for ( ; ch >= '0' && ch <= '9' ; ch = getchar() ) x = x * 10 + ch - '0' ;
    return x * f ;
}

inline long long lread() {
	long long x = 0, f = 1; char ch = getchar();
	for (; ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') f = -1;
	for (; ch >= '0' && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';
	return x * f;
}

int n, m, xx, yy;
long long k;
int a[1005][1005];
struct tmp {
	int w, x, y;
}sta[1000005];
int top;

int dx[4] = {1, 0, 0, -1};
int dy[4] = {0, 1, -1, 0};

long long cnt = 0; int last, clo;
bool cmp(tmp x, tmp y) {return x.w < y.w;}
int vis[1005][1005];

bool dfs(int x, int y) {
	vis[x][y] = clo;
	cnt += last;
	if (cnt == k) return true;
	bool ret = false;
	for (int i = 0; i < 4; i++) {
		if (vis[x + dx[i]][y + dy[i]] != clo && a[x + dx[i]][y + dy[i]] >= last) {
			ret |= dfs(x + dx[i], y + dy[i]);
			if (ret) break;
		}
	}
	return ret;
}

int main() {
	n = read(), m = read(), k = lread();
	for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) {
		a[i][j] = read();
		if (k % a[i][j] == 0) sta[++top] = (tmp) {a[i][j], i, j};
	}
	sort(sta + 1, sta + 1 + top, cmp);
	for (int i = 1; i <= top; i++) {
		int x = sta[i].x, y = sta[i].y;
		last = sta[i].w;
		clo++;
		if (vis[x][y] && last == sta[i - 1].w) continue;
		cnt = 0;
		if (dfs(x, y)) {
			printf("YES\n");
			for (xx = 1; xx <= n; xx++) {
				for (yy = 1; yy <= m; yy++) {
					printf("%d ", vis[xx][yy] == clo ? last : 0);
				}
				printf("\n");
			}
			return 0;
		}
	}
	printf("NO\n");
	return 0;
}
