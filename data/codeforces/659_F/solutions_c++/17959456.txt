#include <algorithm>
#include <iostream> 
#include <cstring>
#include <cstdio>
using namespace std;
typedef long long ll;
int grid[1003][1003];
int vst[1003][1003];
ll k,n,m;
int dx[4]={0,1,0,-1};
int dy[4]={1,0,-1,0};
struct D{
	int i,j;
	int var;
	friend bool operator <(D a,D b){
		return a.var<b.var;
	}
}can[1000006];
bool dfs(int i,int j,int v,ll &tot)
{
	bool ret=0;
	vst[i][j]=v;
	tot+=can[v].var;
	if(tot == k)return 1;
	for(int c=0;c<4;c++){
		int x=i+dx[c];
		int y=j+dy[c];
		if(grid[x][y]>=can[v].var && vst[x][y]<v)ret|=dfs(x,y,v,tot);
		if(ret)return 1;
	}
	return ret;
}
int main()
{
	scanf("%d%d%I64d",&n,&m,&k);
	memset(grid,0,sizeof grid);
	int ds=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%d",&grid[i][j]);
			if(k%grid[i][j] == 0){
				can[ds].i=i;
				can[ds].j=j;
				can[ds++].var=grid[i][j];
			}
		}
	}
	memset(vst,0,sizeof vst);
	can[0].var=0;
	sort(can+1,can+ds);
	for(int i=1;i<ds;i++){
		ll tot=0;
		int t=vst[can[i].i][can[i].j];
		if(can[t].var==can[i].var)continue;
		if(dfs(can[i].i,can[i].j,i,tot)){
			printf("YES\n");
			for(int x=1;x<=n;x++){
				for(int y=1;y<=m;y++){
					if(vst[x][y] == i)printf("%d ",can[i].var);
					else printf("0 ");
				}
				printf("\n");
			}
			return 0;
		}
	}
	printf("NO\n");
	return 0;
}