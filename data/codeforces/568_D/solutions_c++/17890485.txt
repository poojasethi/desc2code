#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
using namespace std;
const double eps=1e-8;
struct Point{
    double x, y;
    Point(){}
    Point(double x, double y):x(x),y(y){}
};
struct Line{
    double a,b,c;
    int id;
    Line(double a=0, double b=0, double c=0, int id=0):a(a),b(b),c(c),id(id){}
};
struct Node{
	int x,y;
	Node(){}
	Node(int x,int y): x(x),y(y){}
}ans[10];
vector<Line>L;
inline int dcmp(double x)
{
    if (fabs(x)<eps)
		return 0;
    return x<0 ? -1:1;
}
bool inter(Line L1, Line L2, Point &tot)
{
    double a1 = L1.a, b1 = L1.b, c1 = L1.c,
           a2 = L2.a, b2 = L2.b, c2 = L2.c;
    if(dcmp(a1*b2-a2*b1) == 0) return false; //è¿™ç§æƒ…å†µä¸å­˜åœ¨
    tot = Point( (b1*c2-c1*b2)/(a1*b2-b1*a2),
               (a1*c2-c1*a2)/(b1*a2-a1*b2) );
    return true;
}
int main()
{
    int i,j,k,m,n,pos;
    scanf("%d %d",&n,&k);
	double a, b, c;
    L.clear();
	for(i=1; i<=n; i++)
	{
		scanf("%lf%lf%lf",&a,&b,&c);
		L.push_back(Line(a,b,c,i));
	}
	int tot = 0;
	bool exis=1;
	while(!L.empty())
	{
		if (k>=L.size())
		{
			ans[++tot]=Node(L[L.size()-1].id,-1);
			L.pop_back();
			continue;
		}
		Point tp;
		for (pos=1;pos<=500;pos++)
		{
			int a=rand()%L.size(),b=rand()%L.size();
			if (!inter(L[a],L[b],tp))
				continue;
			int sz=0;
			for (int j=0;j<L.size();j++)
			{
				Line &u=L[j];
				if (dcmp(tp.x*u.a+tp.y*u.b+u.c)==0)
					sz++;
			}
			if (sz*k>=L.size())
			{
				ans[++tot]=Node(L[a].id,L[b].id);
				break;
			}
		}
		if (pos>500)
		{
			exis=0;
			break;
		}
		for (int j=L.size()-1; j>=0; j--)
		{
			Line u=L[j];
			if (dcmp(tp.x*u.a+tp.y*u.b+u.c)==0)
			{
				swap(L[j],L[L.size()-1]);
				L.pop_back();
			}
		}
		k--;
    }
	if (!exis)
		puts("NO");
	else
	{
		puts("YES");
		printf("%d\n",tot);
		for (int i=1;i<=tot;i++)
			printf("%d %d\n",ans[i].x,ans[i].y);
    }
    return 0;
}
 				     	     	   		   				 	