#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <set>
#include <queue>
#include <map>
#include <list>
#include <cmath>
#include <algorithm>
using namespace std;
#define dprint(v) cerr << #v"=" << v << endl //;)
#define forr(i,a,b) for(int i=(a); i<(b); i++)
#define forn(i,n) forr(i,0,n)
#define dforn(i,n) for(int i=n-1; i>=0; i--)
#define forall(it,v) for(typeof(v.begin()) it=v.begin();it!=v.end();++it)
#define sz(c) ((int)c.size())
#define zero(v) memset(v, 0, sizeof(v))
#define pb push_back
#define fst first
#define snd second
#define INF 1e9
#define EPS 1e-9
typedef long long ll;
typedef pair<int,int> ii;

struct pto {
	double x,y;
	pto(double x=0, double y=0) : x(x), y(y) {}
};
bool operator==(const pto& a, const pto& b) { return fabs(a.x-b.x) < EPS && fabs(a.y-b.y) < EPS; }


int n,k;
ll A[100010],B[100010],C[100010];
vector< ii > ans;

bool intersec(int i, int j, pto& r) {
	double disc = A[i]*B[j] - A[j]*B[i];
	if (fabs(disc) < EPS) return false;
	r = pto( (C[i]*B[j]-C[j]*B[i]) / disc , (A[i]*C[j]-A[j]*C[i]) / disc  );
	return true;
}

bool bt(int p,const list<int> B1,const list< ii > B2) {
	if (p==n) {
		forall(it,B1) ans.pb( ii(*it,-2)  );
		forall(it,B2) ans.pb(*it);
		return true;
	}
	pto a1, a2; 
	forall(it,B2) 	
		if ( intersec(it->fst,it->snd,a1) && intersec(it->fst,p,a2) && a1==a2 ) return bt(p+1,B1,B2);
	
	if (sz(B1) + sz(B2) < k) {
		list<int> B1p = B1; B1p.pb(p);
		if (bt(p+1,B1p,B2)) return true;
	}
	forall(it,B1) if (intersec(p,*it,a1)) {
		list<int> B1p = B1; list<int>::iterator jt; for(jt=B1p.begin();jt!=B1p.end() && *jt!=*it;++jt); B1p.erase(jt);
		list<ii> B2p = B2; B2p.pb(ii(p,*it));
		if (bt(p+1,B1p,B2p)) return true;
	}
	return false;
}

int main() {
	//~ freopen("in1", "r", stdin);
	ios::sync_with_stdio(false);
	while(cin >> n >> k){ 
		forn(i,n) cin >> A[i] >> B[i] >> C[i];
		cout << (bt(0,list<int>(),list< ii >())?"YES\n":"NO\n");
		if (sz(ans)) {
			cout << sz(ans) << endl; 
			forn(i,sz(ans))
				cout << ans[i].fst+1 << ' ' << ans[i].snd+1 << endl; 
		}
		ans.clear();
	}
	return 0;
}
