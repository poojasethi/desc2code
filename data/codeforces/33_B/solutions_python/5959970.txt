start, end, n = raw_input(), raw_input(), int(raw_input())
if len(start) != len(end):	# early out if lengths don't match
	print -1; exit()
# populate initial moves
moves = [[0 if i == j else 50001 for i in range(26)] for j in range(26)]

def num(a):
	return ord(a) - ord('a')

def char(a):
	return chr(a + ord('a'))

# get the additional moves
for _ in range(n):
	a, b, w = raw_input().split()
	if int(w) < moves[num(a)][num(b)]:
		moves[num(a)][num(b)] = int(w)

# check for any transitive paths (iteration order matters! [Floyd-Warshall])
for c in range(26):
	for b in range(26):
		for a in range(26):
			if moves[a][c] + moves[c][b] < moves[a][b]:
				moves[a][b] = moves[a][c] + moves[c][b]

# run through the strings
out = str(); cost = 0
for s, e in zip(map(num, start), map(num, end)):
	if moves[s][e] < moves[e][s]:
		ch, co = e, moves[s][e]
	else:
		ch, co = s, moves[e][s]
	for c in range(26):
		if moves[s][c] + moves[e][c] < co:
			ch, co = c, moves[s][c] + moves[e][c]
	if co > 50000:
		print -1; exit()
	cost += co
	out += char(ch)
print cost
print out
