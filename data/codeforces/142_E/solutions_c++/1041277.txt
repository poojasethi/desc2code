#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
#include <set>
#include <vector>
#include <cmath>
#include <cassert>
#include <cstdlib>
#include <map>
#include <queue>
#include <deque>
#include <bitset>

#define y0 y63475625
#define y1 y28435
#define j0 jfd0sf
#define j1 je90ue0
#define sqr(x) ((x)*(x))
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define re return
#define sz(x) ((int)(x).size())
#define all(x) (x).begin(), (x).end()
#define rep(i, n) for (int i = 0; i < (n); i++)
#define rrep(i, n) for (int i = (n) - 1; i >= 0; i--)
#define sqrt(x) (sqrt(abs(x)))
#define fill(a, x) memset(a, x, sizeof(a))

using namespace std;

typedef vector <int> vi;
typedef vector <vi> vvi;
typedef long long ll;
typedef long double ld;
typedef pair <int, int> ii;
typedef vector <ii> vii;
typedef double D;
typedef pair <ll, ll> pll;
typedef vector <string> vs;

template <class T> T abs(const T a) {
    return a > 0 ? a : -a;
}

const double PI = 2.0 * acos(1.0);

const ld eps = 1e-12;

ld alpha;

int n;
int m;

ld dist(ld ra, ld rb, ld angle) {
    if (abs(ra) < eps) {
        re rb * alpha;
    }
    if (abs(rb) < eps) {
        re ra * alpha;
    }
    if (fabs(angle) < eps)
        re abs(rb - ra) * alpha;
    ld co = rb * sin(angle / alpha);
    ld si = (ra - rb * cos(angle / alpha));
    ld q = sqrt(sqr(co) + sqr(si));
    co /= q; si /= q;
    //ld f0 = alpha * atan2(si, co);
    ld tmp = tan(angle / alpha), tg = si / co;
    re abs(alpha * ra * (co * (tmp - tg) / (1.0 + tmp * tg) + si));
}

int main()
{
    ld r, h;
    cin >> r >> h;
    ld xa, ya, za, xb, yb, zb;
    cin >> xa >> ya >> za;
    cin >> xb >> yb >> zb;
    if (abs(zb) < eps && abs(za) < eps) {
        printf("%.10lf\n", (D)sqrt(sqr(xb - xa) + sqr(yb - ya)));
        re 0;
    }
    if (abs(zb) < eps) {
        swap(xa, xb);
        swap(ya, yb);
        swap(za, zb);
    }
    
    
    alpha = sqrt(1.0 + sqr(h / r));
    if (abs(za) > eps && abs(zb) > eps) {
        ld ra = sqrt(sqr(xa) + sqr(ya));
        ld rb = sqrt(sqr(xb) + sqr(yb));
        ld angle = -1.0;
        if (abs(ra) > eps && abs(rb) > eps)
            angle = acos((xa * xb + ya * yb) / ra / rb);
        ld ans = dist(ra, rb, angle);
        ld fans1 = -1, fans2 = -1;
        rep(i, 1) {
            ld L1 = -M_PI / 20, R1 = M_PI / 20.0;
            ld L2 = -M_PI / 20, R2 = M_PI / 20.0;
            n = 1780;
            rep(j, n) {
                ld f1 = L1 + (R1 - L1) * j / (ld)n;
                rep(k, n) {
                    ld f2 = L2 + (R2 - L2) * k / (ld)n;
                    ld tmp = r * sqrt(2.0 - 2.0 * cos(angle + f1 - f2)) + dist(r, ra, f1) + dist(r, rb, f2);
                    if (tmp < ans) {
                        ans = tmp;
                        fans1 = f1;
                        fans2 = f2;
                    }
                }
            }
            ld d = R1 - L1;
            L1 = fans1 - d / 2.0 * 0.99;
            L2 = fans2 - d / 2.0 * 0.99;
            R1 = fans1 + d / 2.0 * 0.99;
            R2 = fans2 + d / 2.0 * 0.99;
        }
        printf("%.10lf\n", (D)ans);
        re 0;
    } else {
        //todo
        ld L = 0.0, R = 2.0 * M_PI;
        ld ans = 1e20;
        ld fans = -1;
        ld rb = sqrt(sqr(xb) + sqr(yb));
        rep(i, 200) {
            rep(j, 1000) {
                double f = L + (R - L) / 100.0 * j;
                ld x = r * cos(f);
                ld y = r * sin(f);
                ld angle = -1.0;
                if (abs(rb) > eps)
                    angle = acos((x * xb + y * yb) / rb / r);
                ld tmp = sqrt(sqr(xa - x) + sqr(ya - y)) + dist(r, rb, angle);
                if (tmp < ans) {
                    ans = tmp;
                    fans = f;
                }
            }
            ld d = R - L;
            L = fans - d / 2.0 * 0.9;
            R = fans + d / 2.0 * 0.9;
        }
        printf("%.10lf\n", (D)ans);
    }
    return 0;
}
