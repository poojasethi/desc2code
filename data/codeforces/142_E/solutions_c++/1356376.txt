//ÒÛ ÍÀÐÊÎÌÀÍ ×ÒÎ ËÈ ×ÈÒÀÒÜ ÝÒÎ

#include <algorithm>
#include <functional>
#include <numeric>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <cassert>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <bitset>
#include <sstream>
 
using namespace std;

#define forn(i, n) for(int i = 0; i < int(n); ++i)
#define for1(i, n) for(int i = 1; i <= int(n); ++i)
#define ford(i, n) for(int i = int(n) - 1; i >= 0; --i)
#define fore(i, l, r) for(int i = int(l); i < int(r); ++i)
#define sz(v) int((v).size())
#define all(v) (v).begin(), (v).end()
#define pb push_back
#define X first
#define Y second

typedef long long li;
typedef long double ld;
typedef pair<ld, ld> pt;

template<typename T> T abs(T a) { return a < 0 ? -a : a; }
template<typename T> T sqr(T a) { return a*a; }

const int INF = (int)1e9;
const ld EPS = 1e-13;
const ld PI = 3.1415926535897932384626433832795;

const int MAGIC = 10;
const int ITER = 50;

struct pt3{
    ld X, Y, Z;

    pt3(){ X = Y = Z = 0; }
    pt3(const ld& X, const ld& Y, const ld& Z) : X(X), Y(Y), Z(Z){}
};

inline ld dist(const pt3& a, const pt3& b){
    return sqrtl(sqr(a.X - b.X) + sqr(a.Y - b.Y) + sqr(a.Z - b.Z));
}

inline ld dist2(const pt3& a, const pt3& b){
    return (sqr(a.X - b.X) + sqr(a.Y - b.Y) + sqr(a.Z - b.Z));
}

inline ld leng(const pt3& a){
    return sqrtl(a.X*a.X + a.Y*a.Y + a.Z*a.Z);
}
    
inline pt3 operator - (const pt3& a, const pt3& b){
    return pt3(a.X - b.X, a.Y - b.Y, a.Z - b.Z);
}

inline pt3 norm(const pt3& a, const ld& nln){
    ld ln = leng(a);
    return pt3(a.X * (nln / ln), a.Y * (nln / ln), a.Z * (nln / ln));
}

inline ld distAng(const ld& a, const ld& b){
    if(a > b)
        return min(a - b, b + 2*PI - a);
    else
        return min(b - a, a + 2*PI - b);
}

ld h, r;
pt3 a, b, ap, bp, t;
ld aa, ba, ard, brd, ad, bd, ar, br, trd;

inline pt3 getPoint(const ld& ang){
    return pt3(r*cos(ang), r*sin(ang), 0);
}

inline pt3 project(const pt3& a){
    pt3 v = norm(a - t, sqrtl(sqr(a.Z) + dist2(a, t) - sqr(h - a.Z)));
    return pt3(a.X + v.X, a.Y + v.Y, a.Z + v.Z);
}

inline ld distCon(const ld& z1, const ld& z2, ld ang){
    /*
    if(z1 > z2)
        return distCon(z2, z1, ang);

    if(abs(z2 - h) < EPS){
        return trd * (h - z1) / h;
    }
    */

    while(ang < 0)
        ang += 2*PI;
    while(ang > 2*PI)
        ang -= 2*PI;
    ang *= r / trd;

    pt a(trd * (h - z1) / h, 0);
    ld r2 = trd * (h - z2) / h;
    pt b(r2 * cos(ang), r2 * sin(ang));

    return sqrtl(sqr(a.X - b.X) + sqr(a.Y - b.Y));
}

inline ld distCon(const pt3& a, const pt3& b){
    ld dif = atan2(a.Y, a.X) - atan2(b.Y, b.X);
    while(dif < 0)
        dif += 2*PI;
    while(dif > 2*PI)
        dif -= 2*PI;

    //cerr << dif << " " << dif * nang << endl;

    return min(distCon(a.Z, b.Z, dif), distCon(a.Z, b.Z, (2*PI - dif)));
}
                         
ld solve2(const pt3& ca){
    if(abs(b.Z) < EPS)
        return dist(ca, b);

    int curMagic = (a.Z < EPS) ? (MAGIC * MAGIC) : (MAGIC);

    ld d = 2*PI / curMagic;

    ld ans = 1e100;

    forn(i, curMagic){
        ld lf = i*d;
        ld rg = i*d + d;

        forn(j, ITER){
            ld d = (rg - lf) / 3;
            ld ml = lf + d;
            ld mr = rg - d;

            pt3 pl = getPoint(ml), pr = getPoint(mr);

            if(dist(ca, pl) + min(distCon(0, b.Z, ml - ba), distCon(0, b.Z, ba - ml)) > dist(ca, pr) + min(distCon(0, b.Z, mr - ba), distCon(0, b.Z, ba - mr))){  
                lf = ml;
            }else{
                rg = mr;
            }
        }
        

        ans = min(ans, dist(ca, getPoint(lf)) + min(distCon(0, b.Z, lf - ba), distCon(0, b.Z, ba - lf)));
    }

    return ans;
}
    
ld solve1(){
    if(abs(a.Z) < EPS)
        return solve2(a);

    ld d = 2*PI / MAGIC;

    ld ans = 1e100;

    forn(i, MAGIC){
        ld lf = i*d;
        ld rg = i*d + d;

        forn(j, ITER){
            ld d = (rg - lf) / 3;
            ld ml = lf + d;
            ld mr = rg - d;

            pt3 pl = getPoint(ml), pr = getPoint(mr);

            if(min(distCon(0, a.Z, ml - aa), distCon(0, a.Z, aa - ml)) + solve2(pl) > min(distCon(0, a.Z, mr - aa), distCon(0, a.Z, aa - mr)) + solve2(pr)){  
                lf = ml;
            }else{
                rg = mr;
            }
        }

        ans = min(ans, min(distCon(0, a.Z, lf - aa), distCon(0, a.Z, aa - lf)) + solve2(getPoint(lf)));
    }

    return ans;
}

int main(){
    #ifndef ONLINE_JUDGE
        freopen("input.txt", "rt", stdin);
        //freopen("output.txt", "wt", stdout);
    #endif

    cout.precision(10);
    cout << fixed;

    cin >> r >> h >> a.X >> a.Y >> a.Z >> b.X >> b.Y >> b.Z;

    if(b.Z < EPS)
        swap(a, b);

    t = pt3(0, 0, h);
    trd = sqrtl(r*r + h*h);


    if(a.Z < EPS && b.Z < EPS){
        cout << dist(a, b) << endl;
        return 0;
    }

    if(a.X < EPS && a.Y < EPS && abs(a.Z - h) < EPS){
        if(b.Z < EPS){
            cout << trd + r - dist(b, pt3(0, 0, 0)) << endl;
        }else{
            cout << dist(a, b) << endl;
        }

        return 0;
    }

    if(b.X < EPS && b.Y < EPS && abs(b.Z - h) < EPS){
        if(a.Z < EPS){
            cout << trd + r - dist(a, pt3(0, 0, 0)) << endl;
        }else{
            cout << dist(a, b) << endl;
        }
        return 0;
    }


    if(abs(a.Z) > EPS){ 
        ap = project(a);
        ad = dist(a, ap);
        ard = sqrtl(r*r + h*h) / h * (h - a.Z);
        aa = atan2(ap.Y, ap.X);
        while(aa < 0)
            aa += 2*PI;
        ar = sqrtl(dist2(a, t) - sqr(h - a.Z));
    }

    if(abs(b.Z) > EPS){
        bp = project(b);
        bd = dist(b, ap);
        brd = sqrtl(r*r + h*h) / h * (h - b.Z);
        ba = atan2(bp.Y, bp.X);
        while(ba < 0)
            ba += 2*PI;
        br = sqrtl(dist2(b, t) - sqr(h - b.Z));
    }

    ld conDist = 1e100;

    if(abs(a.Z) > EPS && abs(b.Z) > EPS){
        conDist = distCon(a, b);
    }

    //cerr << clock() << endl;

    cout << min(conDist,solve1()) << endl;

    cerr << clock() << endl;

    return 0;
}
