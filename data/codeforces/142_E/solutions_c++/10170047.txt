#include <iostream>
#include <cmath>
#include <cstdlib>

using namespace std;

double error=1e-9;

double r,h,lado,perimetro;

struct point {
  double x,y,z;
  point() {
  }
  point(double inx,double iny,double inz) {
    x=inx;y=iny;z=inz;
  }
};

point operator-(point p1,point p2)
{
  p1.x-=p2.x;
  p1.y-=p2.y;
  p1.z-=p2.z;
  return p1;
}

point rotar(point p,double a)
{
  point nextp=p;
  nextp.x=p.x*cos(a)-p.y*sin(a);
  nextp.y=p.x*sin(a)+p.y*cos(a);
  return nextp;
}

double cuad(double x)
{
  return x*x;
}

double abs(point p)
{
  return sqrt(cuad(p.x)+cuad(p.y)+cuad(p.z));
}

point p1,pp1;
point p2,pp2;

point obtenpp(double a)
{
  double arg=a*r/lado;
  return point(lado*cos(arg),lado*sin(arg),0);
}

double distap1(double a)
{
  return abs(pp1-obtenpp(a));
}

double distap2(double a)
{
  return abs(pp2-obtenpp(a));
}

int divisor=500;

double buscar1(double a1,double a2)
{
  if (abs(a1-a2)<error) return distap1(a1)+abs(p2-point(r*cos(a1),r*sin(a1),0));
  int imin=0;
  double solmin=distap1(a1)+abs(p2-point(r*cos(a1),r*sin(a1),0));
  for (int i=0;i<=divisor;i++) {
    double a=(a1*(divisor-i)+a2*i)/divisor;
    double solact=distap1(a)+abs(p2-point(r*cos(a),r*sin(a),0));
    if (solact<solmin) {
      imin=i;
      solmin=solact;
    }
  }
  int i1=max(0,imin-1);
  int i2=min(divisor,imin+1);
  return buscar1((a1*(divisor-i1)+a2*i1)/divisor,
		 (a1*(divisor-i2)+a2*i2)/divisor);
  //return solmin;
  /*
  int iinf=max(imin-1,0);
  int isup=min(imin+1,100);
  return buscar1(p2,a1*(100-iinf)+a2*iinf,a1*(100-isup),a2*isup);
  */
}

double buscar2(double a1inf,double a1sup,double a2inf,double a2sup)
{
  int imin=0,jmin=0;
  double solmin=distap1(a1inf)+distap2(a2inf)+
     abs(point(r*cos(a1inf),r*sin(a1inf),0)-point(r*cos(a2inf),r*sin(a2inf),0));
  if (abs(a1inf-a1sup)<error and abs(a2inf-a2sup)<error)
    return solmin;
  for (int i=0;i<=divisor;i++) {
    for (int j=0;j<=divisor;j++) {
      double aa1=(a1inf*(divisor-i)+a1sup*i)/divisor;
      double aa2=(a2inf*(divisor-j)+a2sup*j)/divisor;
      if (aa1<=aa2) {
	double solact=distap1(aa1)+distap2(aa2)+
	  abs(point(r*cos(aa1),r*sin(aa1),0)-point(r*cos(aa2),r*sin(aa2),0));
	if (solact<solmin) {
	  imin=i;
	  jmin=j;
	  solmin=solact;
	}
      }
    }
  }
  int i1=max(0,imin-1);
  int i2=min(divisor,imin+1);
  int j1=max(0,jmin-1);
  int j2=min(divisor,jmin+1);
  return buscar2((a1inf*(divisor-i1)+a1sup*i1)/divisor,
		 (a1inf*(divisor-i2)+a1sup*i2)/divisor,
		 (a2inf*(divisor-j1)+a2sup*j1)/divisor,
		 (a2inf*(divisor-j2)+a2sup*j2)/divisor);
  //return solmin;
}

int main()
{
  cout.setf(ios::fixed);
  cout.precision(10);
  cin>>r>>h>>p1.x>>p1.y>>p1.z>>p2.x>>p2.y>>p2.z;
  lado=sqrt(cuad(r)+cuad(h));
  perimetro=2*M_PI*r;
  if (p1.z<error and p2.z<error) {
    cout<<abs(p1-p2)<<endl;
    exit(0);
  }
  if (p1.z<p2.z) swap(p1,p2);
  if (p1.z>h-error) {
    if (p2.z<error)
      cout<<r-sqrt(cuad(p2.x)+cuad(p2.y))+abs(p1-point(r,0,0))<<endl;
    else
      cout<<abs(p1-p2)<<endl;
    exit(0);
  }
  double a=atan2(p1.y,p1.x);
  p1=rotar(p1,-a);
  p2=rotar(p2,-a);
  if (p2.y<0) p2.y=-p2.y;
  double a1=0;
  if (abs(p2-point(0,0,0))<error) {
    cout<<r+abs(p1-point(r,0,0))<<endl;
    exit(0);
  }
  double a2=atan2(p2.y,p2.x);
  if (a2<0) a2=-a2;
  pp1=point(abs(point(0,0,h)-p1),0,0);
  double lenp2=abs(point(0,0,h)-p2);
  double aa2=a2*r/lado;
  pp2=point(lenp2*cos(aa2),lenp2*sin(aa2),0);
  if (pp2.y<0) pp2.y=-pp2.y;
  double sol;
  if (p2.z<error) {
    sol=buscar1(a1,a2);
  } else {
    sol=min(abs(pp1-pp2),buscar2(a1,a2,a1,a2));
  }
  cout<<sol<<endl;
}
