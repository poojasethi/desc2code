#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<stdio.h>
#include<algorithm>
#include<cmath>
#include<map>
#include<queue>
#include<bitset>
#include<stack>
using namespace std;


#pragma comment(linker, "/STACK:1024000000,1024000000")
#define inf 0x3f3f3f3f
#define eps 1e-9
#define pii pair<int,int>
#define MP make_pair
#define LL  long long
#define ULL unsigned long long 
#define N ( 1000000 + 10 )
#define M ( 2000000 + 10)
#define mod  10007

int read() {
	char c;
	while((c=getchar()) && !('0' <= c && c <= '9'));
	int x = c - '0';
	while((c=getchar()) && '0' <= c && c <= '9') x = x * 10 + c - '0';
	return x;
}
int wa[N], wb[N], wx[N], wv[N];

int cmp ( int * r, int a, int b, int l )
{
    return r[a+l] == r[b+l] && r[a] == r[b] ;
}

void da ( char *r, int *sa, int n, int m )
{
    int *x = wa, *y = wb, *t;
    int i, j, k, p;
    for( i = 0; i < m; ++i ) wx[i] = 0;
    for( i = 0; i < n; ++i ) ++wx[x[i] = r[i]];
    for( i = 1; i < m; ++i ) wx[i] += wx[i-1];
    for( i = n-1; i >= 0; --i ) sa[--wx[x[i]]] = i;
    for( j = 1, p = 1; p < n; j *= 2, m = p ) {
        for( p = 0, i = n - j; i < n; ++i ) y[p++] = i;
        for( i = 0; i < n; ++i ) if( sa[i] >= j ) y[p++] = sa[i] - j;
        for( i = 0; i < n; ++i ) wv[i] = x[y[i]];
        for( i = 0; i < m; ++i ) wx[i] = 0;
        for( i = 0; i < n; ++i ) ++wx[wv[i]];
        for( i = 1; i < m; ++i ) wx[i] += wx[i-1];
        for( i = n-1; i >= 0; --i ) sa[--wx[wv[i]]] = y[i];
        for( t = x, x = y, y = t, p = 1, x[sa[0]] = 0, i = 1; i < n; ++i )
            x[sa[i]] = cmp ( y, sa[i-1], sa[i], j ) ? p - 1 : p ++ ;
    }
}

int Rank[N], sa[N], height[N];
void calheight ( char *r, int n )
{
    int i , j , k = 0;
    for( i = 1; i <= n; ++i ) Rank[sa[i]] = i;
    for( i = 0; i < n; height[Rank[i++]] = k )
        for( k ? k -- : 0, j = sa[Rank[i]-1]; r[i+k] == r[j+k]; k++ );
}

int dp[N][30];

void rmq_init( int n )
{
    int m = floor( log( n * 1.0 ) / log( 2.0 ) );
    for( int i = 1; i <= n; ++i ) dp[i][0] = height[i];
    for( int i = 1; i <= m; ++i ) {
        for( int j = 1; j <= n; ++j ) {
            dp[j][i] = dp[j][i-1];
            if( j + ( 1 << ( i - 1 ) ) <= n )
                dp[j][i] = min ( dp[j][i], dp[j+(1<<(i-1))][i-1] );
        }
    }
}

int fst[N], vv[M], nxt[M], e;

char s[N], t[N];
int len;
int fa[N], son[N], sz[N], tid[N], dep[N], tp[N], downid[N],upid[N], dc;
int ted[N];
vector<int> path[N];
int pnum;
int rmq ( int l, int r )
{
	if(l == r) return len-l;
    l = Rank[l], r = Rank[r];
    if( l > r ) swap ( l, r );
    ++l;
    int m = floor ( log ( r - l + 1.0 ) / log ( 2.0 ));
    return min( dp[l][m], dp[r-(1<<m)+1][m] );
}

void init(int n) {
	for(int i = 0; i <= n; ++i)
		fst[i] = -1;
	e = 0;
	dc = 0;
	pnum = 0;
}

void add(int u, int v) {
	vv[e] = v, nxt[e] = fst[u], fst[u] = e++;
}

void dfs1(int u, int p) {
	fa[u] = p;
	dep[u] = dep[p]+1;
	sz[u] = 1;
	son[u] = 0;
	int mx = 0;
	for(int i = fst[u]; ~i; i = nxt[i]) {
		int v = vv[i];
		if(v == p) continue;
		dfs1(v, u);
		sz[u] += sz[v];
		if(sz[v] > mx) {
			mx = sz[v];
			son[u] = v;
		}
	}
}

void dfs2(int u, int ans) {
	tid[u] = ++dc;
	tp[u] = ans;

	path[pnum].push_back(u);
	if(son[u])
		dfs2(son[u], ans);
	for(int i = fst[u]; ~i; i = nxt[i]) {
		int v = vv[i];
		if(v == fa[u] || v == son[u]) continue;
		pnum++;
		dfs2(v, v);
	}
	ted[u] = dc;
}

void get_t() {
	for(int i = 0; i <= pnum; ++i) {
		int sz = path[i].size();
		for(int j = 0; j < sz; ++j) {
			t[len++] = s[path[i][j]];
			downid[path[i][j]] = len-1;
		}
		for(int j = sz-1; j >= 0; --j) {
			t[len++] = s[path[i][j]];
			upid[path[i][j]] = len-1;
		}
	}
}


int que[2][N], ll[2], qt[N], lt;

bool judge(int u,int v) {
	return tid[u] <= tid[v] && tid[v] <= ted[u];
}

void gao(int u, int v, int k) {
	ll[k] = 0;
	lt = 0;
	int &len = ll[k];
	while(!judge(tp[u], v)) {
		que[k][len++] = upid[u];
		que[k][len++] = upid[tp[u]];
		u = fa[tp[u]];
	}
	while(!judge(tp[v], u)) {
		qt[lt++] = downid[v];
		qt[lt++] = downid[tp[v]];
		v = fa[tp[v]];
	}
	if(judge(u, v)) {
		qt[lt++] = downid[v];
		qt[lt++] = downid[u];
	}
	else {
		que[k][len++] = upid[u];
		que[k][len++] = upid[v];
	}
	for(int i = lt-1; i >= 0; --i)
		que[k][len++] = qt[i];
}

int get() {
	int ans = 0;
	int a, b, c, d, lena, lenb, rm;
	rm = lena = lenb = 0;
	int tmp=0;
	for(int i = -2, j = -2; i < ll[0] && j < ll[1];) {
		if(tmp >= lena) {
			i += 2;
			if(i == ll[0]) return ans;
			a = que[0][i], b = que[0][i+1];
			lena = b - a + 1;
		}
		else a += tmp, lena -= tmp;
		if(tmp >= lenb) {
			j += 2;
			if(j == ll[1]) return ans;
			c = que[1][j], d = que[1][j+1];
			lenb = d - c +  1;
		}
		else c += tmp, lenb -= tmp;
		rm = rmq(a, c);
		if(rm == 0) return ans;
		tmp = min(min(rm, lena), lenb);
		ans += tmp;
	}
	return ans;
}


void debug(int n) {
	for(int i = 1; i <= n; ++i)
		printf("u %d tp %d dep %d upid %d downid %d\n", i, tp[i], dep[i], upid[i], downid[i]);
	printf("pnum %d\n", pnum);
	for(int i = 0; i <= pnum; ++i) {
		int sz = path[i].size(); 
		printf("i %d :", i);
		for(int j = 0; j < sz; ++j) 
			printf(" %d ", path[i][j]);
		puts("");
	}
	printf("len %d\n", len);
	printf("t %s\n", t);
}

void debug2() {
	puts("que0 ");
	for(int i = 0; i < ll[0]; ++i)
		printf(" %d ", que[0][i]);
	puts("\nque1 ");
	for(int i = 0; i < ll[1]; ++i)
		printf(" %d ", que[1][i]);

	puts("");
}
int main() {
	int n,m;
	n = read();
	scanf("%s", s+1);
	init(n);
	int u,v;
	for(int i = 1; i < n; ++i) {
		u = read();
		v = read();
		add(u, v), add(v, u);
	}
	dfs1(1, 0);
	len = 0;
	dfs2(1, 1);
	get_t();

	t[len] = 0;
	da(t, sa, len+1, 130);
	calheight(t, len);	
	rmq_init(len);

	m = read();
	for(int i = 0; i < m; ++i) {
		int a, b, c, d;
		a = read(); b = read(); c = read(); d = read();
		gao(a, b, 0);
		gao(c, d, 1);
		printf("%d\n", get());
	}
}