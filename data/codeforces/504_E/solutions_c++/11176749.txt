#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <cmath>
using namespace std;

const long long mod = 1000000007;

struct Edge {
	int y;
	Edge *next;
};

long long val[300010],hash[300010],exhash[300010];
Edge *b[300010];
int son[300010],bl[300010],fa[300010],pl[300010],f[300010],deep[300010];
bool v[300010];
char s[300010];
int sz;

void addedge(int x,int y) {
	Edge *p = new Edge;
	p->y = y;
	p->next = b[x];
	b[x] = p;
}

void dfs1(int x) {
	v[x] = son[x] = 1;
	for (Edge *i = b[x]; i != NULL; i = i->next)
		if (! v[i->y]) {
			fa[i->y] = x;
			dfs1(i->y);
			son[x] += son[i->y];
		}
}

void dfs2(int x,int chain) {
	pl[x] = ++sz;
	f[pl[x]] = pl[fa[x]];
	exhash[pl[x]] = hash[pl[x]] = s[x] - 'a';
	bl[pl[x]] = chain;
	deep[pl[x]] = deep[pl[fa[x]]] + 1;
	int k = 0;
	for (Edge *i = b[x]; i != NULL; i = i->next)
		if (i->y != fa[x] && son[k] < son[i->y])
			k = i->y;
	if (! k)
		return;
	dfs2(k,chain);
	for (Edge *i = b[x]; i != NULL; i = i->next)
		if (i->y != fa[x] && k != i->y)
			dfs2(i->y,sz + 1);
}

void find(int x,int y,vector<pair<int,int> > &q) {
	vector<pair<int,int> > tmp;
	int xx = bl[x],yy = bl[y];
	for (;;) {
		if (xx == yy) {
			q.push_back(make_pair(x,y));
			break;
		}
		if (deep[xx] > deep[yy]) {
			q.push_back(make_pair(x,xx));
			xx = bl[x = f[xx]];
		}
		else {
			tmp.push_back(make_pair(yy,y));
			yy = bl[y = f[yy]];
		}
	}
	if (tmp.size())
		for (int i = tmp.size() - 1; i >= 0; i--)
			q.push_back(tmp[i]);
}

int sign(int x) {
	return x < 0?-1:1;
}

unsigned long long gethash(int l,int r) {
	return l <= r?((hash[l] - hash[r + 1] * val[r - l + 1]) % mod + mod) % mod:((exhash[l] - exhash[r - 1] * val[l - r + 1]) % mod + mod) % mod;
}

int lcp(int x,int xx,int y,int yy,int len) {
	if (gethash(x,x) != gethash(y,y))
		return 0;
	int l = 1;
	for (int r = len; l < r;) {
		int mid = (l + r) / 2;
		if (gethash(x,x + mid * xx - xx) != gethash(y,y + mid * yy - yy))
			r = mid;
		else
			if (l + 1 == r)
				if (gethash(x,x + r * xx - xx) == gethash(y,y + r * yy - yy))
					l = r;
				else
					r = l;
			else
				l = mid;
	}
	return l;
}

int main() {
	val[0] = 1;
	for (int i = 1; i <= 300000; i++)
		val[i] = val[i - 1] * 1145143 % mod;
	int n;
	scanf("%d%s",&n,s + 1);
	for (int i = 1; i < n; i++) {
		int x,y;
		scanf("%d%d",&x,&y);
		addedge(x,y);
		addedge(y,x);
	}
	dfs1(1);
	dfs2(1,1);
	for (int i = n; i >= 1; i--)
		hash[i] = (hash[i + 1] * 1145143 + hash[i]) % mod;
	for (int i = 1; i <= n; i++)
		exhash[i] = (exhash[i - 1] * 1145143 + exhash[i]) % mod;
	int m;
	scanf("%d",&m);
	for (; m--;) {
		int a,b,c,d;
		scanf("%d%d%d%d",&a,&b,&c,&d);
		a = pl[a];
		b = pl[b];
		c = pl[c];
		d = pl[d];
		vector<pair<int,int> > p,q;
		find(a,b,p);
		find(c,d,q);
		int ans = 0;
		for (int i = 0,j = 0; i < p.size() && j < q.size();) {
			int mn = min(abs(p[i].second - p[i].first),abs(q[j].second - q[j].first)) + 1;
			int k1 = sign(p[i].second - p[i].first),k2 = sign(q[j].second - q[j].first);
			int k = lcp(p[i].first,k1,q[j].first,k2,mn);
			ans += k;
			if (k != mn)
				break;
			if (abs(p[i].second - p[i].first) + 1 == k)
				i++;
			else
				p[i].first += k1 * k;
			if (abs(q[j].second - q[j].first) + 1 == k)
				j++;
			else
				q[j].first += k2 * k;
		}
		printf("%d\n",ans);
	}
	return 0;
}

