#include <algorithm>
#include <iostream>
#include <cassert>
#include <climits>
#include <cstdlib>
#include <cstring>
#include <iomanip>
#include <numeric>
#include <cstdio>
#include <string>
#include <vector>
#include <cmath>
#include <ctime>
#include <queue>
#include <stack>
#include <map>
#include <set>

using namespace std;

#define F first
#define S second

#define endl '\n'

#define mp make_pair
#define pb push_back

#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define ROF(i, a, b) for(int i = a; i >= b; i--)

#define type(x) __typeof((x).begin())
#define foreach(i, x) for(type(x) i = (x).begin(); i != (x).end(); i++)

#define sol (root + root)
#define sag (root + root + 1)
#define orta ((bas + son) >> 1)

#define bit __builtin_popcount

#ifndef D
    #define dbg(x) 0
    #define dbgs(x) 0
#else
    #define dbg(x) cerr << (#x) << " --> " << (x) << endl
    #define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#endif

#define time _time

typedef long long ll;
typedef pair < int, int > pii;

const int inf = 1e9 + 5;
const ll linf = 1e18 + 5;

const int N = 3e5 + 5;
const int LOG = 19;

int n, m, x, y, time;
vector < int > v[N];
pii vc[2][N];
int sz[2];
int lca[LOG][N], dep[N];
int child[N], start[N], node[N], head[N], tail[N];
int suf[N << 1], order[N << 1], mylog[N << 1], lcp[LOG + 1][N << 1];
pii C[N << 1];
char s[N], a[N << 1];

inline void dfs(int root = 0, int x = 1, int d = 1) {

	child[x] = 1;
	lca[0][x] = root;
	dep[x] = d;

	FOR(i, 1, LOG - 1)
		lca[i][x] = lca[i - 1][lca[i - 1][x]];

	foreach(it, v[x])
		if(*it != root) {
			dfs(x, *it, d + 1);
			child[x] += child[*it];
		}

}

inline void dfs2(int root = 0, int x = 1, int h = 1) {

	head[x] = h;
	tail[h] = x;
	start[x] = ++time;
	node[time] = x;
	a[time] = a[2 * n - time + 1] = s[x];

	int mx = -1;

	foreach(it, v[x])
		if(*it != root)
			mx = max(mx, child[*it]);

	foreach(it, v[x])
		if(*it != root and child[*it] == mx) {
			dfs2(x, *it, h);
			break;
		}

	foreach(it, v[x])
		if(*it != root) {
			if(child[*it] == mx) {
				mx = -1;
				continue;
			}
			dfs2(x, *it, *it);
		}

}

int get(int x, int y) {

	if(dep[x] < dep[y])
		swap(x, y);

	ROF(i, LOG - 1, 0)
		if(dep[x] - (1 << i) >= dep[y])
			x = lca[i][x];

	if(x == y)
		return x;

	ROF(i, LOG - 1, 0)
		if(lca[i][x] != lca[i][y]) {
			x = lca[i][x];
			y = lca[i][y];
		}

	return lca[0][x];

}

int get_lcp(int x, int y) {

	x = suf[x];
	y = suf[y];

	if(x == y)
		return 2 * n - order[x] + 1;

	if(x > y)
		swap(x, y);

	x++;

	int t = mylog[y - x + 1];

	return min(lcp[t][x], lcp[t][y - (1 << t) + 1]);

}

void get_vec(bool w, int a, int b, int x) {

	sz[w] = 0;

	while(dep[a] >= dep[x]) {
		int go = head[a];
		if(dep[x] > dep[go])
			go = x;
		vc[w][sz[w]++] = mp(2 * n - start[a] + 1, dep[a] - dep[go] + 1);
		a = lca[0][go];
	}

	int st = sz[w];

	while(dep[b] > dep[x]) {
		int go = head[b];
		if(dep[x] >= dep[go])
			go = node[start[x] + 1];
		vc[w][sz[w]++] = mp(start[go], dep[b] - dep[go] + 1);
		b = lca[0][go];
	}

	reverse(vc[w] + st, vc[w] + sz[w]);

}

int get_lcp(int a, int b, int x, int c, int d, int y) {

	get_vec(0, a, b, x);
	get_vec(1, c, d, y);

	int i = 0, j = 0;

	int ans = 0;

	while(i < sz[0] and j < sz[1]) {
		int res = get_lcp(vc[0][i].F, vc[1][j].F);
		if(res < vc[0][i].S and res < vc[1][j].S)
			return ans + res;
		if(vc[0][i].S == vc[1][j].S) {
			ans += vc[0][i].S;
			i++;
			j++;
			continue;
		}
		if(vc[0][i].S < vc[1][j].S) {
			ans += vc[0][i].S;
			vc[1][j].S -= vc[0][i].S;
			vc[1][j].F += vc[0][i].S;
			i++;
		}
		else {
			ans += vc[1][j].S;
			vc[0][i].S -= vc[1][j].S;
			vc[0][i].F += vc[1][j].S;
			j++;
		}
	}

	return ans;

}

bool cmp(int x, int y) {
	return C[x] < C[y];
}

int main () {
    
	cin >> n;

	scanf("%s", s + 1);

	FOR(i, 2, n) {
		scanf("%d %d", &x, &y);
		v[x].pb(y);
		v[y].pb(x);
	}

	dfs();
	dfs2();

	FOR(i, 1, 2 * n)
		suf[i] = a[i];

	FOR(i, 1, 2 * n)
		order[i] = i;

	FOR(i, 1, LOG + 2) {
		FOR(j, 1, 2 * n)
			C[j] = mp(suf[j], j + (1 << i - 1) <= 2 * n ? suf[j + (1 << i - 1)] : 0);
		sort(order + 1, order + 2 * n + 1, cmp);
		FOR(i, 1, 2 * n)
			suf[order[i]] = suf[order[i - 1]] + (C[order[i]] != C[order[i - 1]]);
	}

	int j = 0;

	FOR(i, 1, 2 * n) {
		if(suf[i] == 1)
			continue;
		while(i + j <= 2 * n and order[suf[i] - 1] + j <= 2 * n and a[i + j] == a[order[suf[i] - 1] + j])
			j++;
		lcp[0][suf[i]] = j;
		if(j)
			j--;
	}

	FOR(i, 2, 2 * n)
		mylog[i] = mylog[i >> 1] + 1;

	FOR(i, 1, LOG)
		FOR(j, 1, 2 * n)
			if(j + (1 << i) - 1 <= 2 * n)
				lcp[i][j] = min(lcp[i - 1][j], lcp[i - 1][j + (1 << i - 1)]);

	cin >> m;

	FOR(i, 1, m) {
		int a, b, c, d;
		scanf("%d %d %d %d", &a, &b, &c, &d);
		x = get(a, b);
		y = get(c, d);
		printf("%d\n", get_lcp(a, b, x, c, d, y));
	}

    return 0;
    
}
