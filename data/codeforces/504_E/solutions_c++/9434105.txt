#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <queue>
#include <map>
#include <set>
#include <vector>
#include <string>
#include <stack>
#include <bitset>
#define INF 0x3f3f3f3f
#define eps 1e-8
#define FI first
#define SE second
using namespace std;
typedef long long LL;
const int maxn=3e5+5;

inline void R(int &x) {
  char c; bool sign = false;
  for (c = getchar(); c<'0' || c>'9'; c = getchar()) if (c=='-') sign = true;
  for (x = 0; c>='0' && c<='9'; c = getchar()) x = x*10+c-'0';
  sign && (x=-x);
}

int wa[maxn*2],wb[maxn*2],wv[maxn*2],wd[maxn*2];
inline int cmp(int *r,int a,int b,int l)
{return r[a]==r[b]&&r[a+l]==r[b+l];}
void da(int *r,int *sa,int n,int m)
{
    int i,j,p,*x=wa,*y=wb,*t;
    for(i=0;i<m;i++) wd[i]=0;
    for(i=0;i<n;i++) wd[x[i]=r[i]]++;
    for(i=1;i<m;i++) wd[i]+=wd[i-1];
    for(i=n-1;i>=0;i--) sa[--wd[x[i]]]=i;
    for(j=1,p=1;p<n;j*=2,m=p)
    {
        for(p=0,i=n-j;i<n;i++) y[p++]=i;
        for(i=0;i<n;i++) if(sa[i]>=j) y[p++]=sa[i]-j;
        for(i=0;i<n;i++) wv[i]=x[y[i]];
        for(i=0;i<m;i++) wd[i]=0;
        for(i=0;i<n;i++) wd[wv[i]]++;
        for(i=1;i<m;i++) wd[i]+=wd[i-1];
        for(i=n-1;i>=0;i--) sa[--wd[wv[i]]]=y[i];
        for(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i<n;i++)
            x[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;
    }
    return;
}

int rank[maxn*2],height[maxn*2];
int sa[maxn*2],data[maxn*2];
void calheight(int *r,int *sa,int n)
{
    int i,j,k=0;
    for(i=1;i<=n;i++) rank[sa[i]]=i;
    for(i=0;i<n;height[rank[i++]]=k)
    for(k?k--:0,j=sa[rank[i]-1];r[i+k]==r[j+k];k++);
    return;
}

int head[maxn];
struct Edge
{
    int next,to;
}ed[maxn*2];
int n,ecnt;
char str[maxn];

inline void addedge(int u,int v)
{
    ed[ecnt].next=head[u];
    ed[ecnt].to=v;
    head[u]=ecnt++;
}

int dep[maxn],fa[maxn][20],sz[maxn],son[maxn];
int tid[maxn],top[maxn],label=0;
void dfs1(int u,int father,int depth)
{
    fa[u][0]=father; dep[u]=depth;
    son[u]=0; sz[u]=1;
    for(int i=1;i<20;++i) fa[u][i]=fa[fa[u][i-1]][i-1];
    int maxsize=0;
    for(int e=head[u];~e;e=ed[e].next)
    {
        int v=ed[e].to;
        if(v==father) continue;
        dfs1(v,u,depth+1);
        sz[u]+=sz[v];
        if(sz[v]>maxsize)
        {
            maxsize=sz[v];
            son[u]=v;
        }
    }
}

void dfs2(int u,int ancestor)
{
    data[label]=str[u];
    tid[u]=label++;
    top[u]=ancestor;
    if(son[u]) dfs2(son[u],ancestor);
    for(int e=head[u];~e;e=ed[e].next)
    {
        int v=ed[e].to;
        if(v==son[u]||v==fa[u][0]) continue;
        dfs2(v,v);
    }
}

int Lg[maxn*2],minx[maxn*2][20];
void initRMQ(int num)
{
	Lg[1]=0;
    for(int i=2;i<=num;++i) Lg[i]=Lg[i>>1]+1;
	for(int j = 1; j < 20; ++j)
		for(int i = 1; i <= num; ++i)
			if(i + (1 << j) - 1 <= num)
				minx[i][j] = min(minx[i][j - 1], minx[i + (1 << (j - 1))][j - 1]);
}

inline int lcp(int l,int r)
{
    int t=Lg[r-l+1];
    return min(minx[l][t],minx[r-(1<<t)+1][t]);
}

inline int lca(int u,int v)
{
    if(dep[u]<dep[v]) swap(u,v);
    for(int i=19;i>=0;--i) if(dep[fa[u][i]]>=dep[v]) u=fa[u][i];
    if(u==v) return u;
    for(int i=19;i>=0;--i) if(fa[u][i]^fa[v][i]) u=fa[u][i],v=fa[v][i];
    return fa[u][0];
}

inline void get_path(int u,int v,pair <int,int> *p,int &cnt)
{
    int A=lca(u,v);
    int f=top[u];
    while(f!=top[A])
    {
        p[cnt++]=make_pair(n-tid[u]+n,dep[u]-dep[f]+1);
        u=fa[f][0]; f=top[u];
    }
    p[cnt++]=make_pair(n-tid[u]+n,dep[u]-dep[A]+1);
    int now=cnt;
    f=top[v];
    while(f!=top[A])
    {
        int len=dep[v]-dep[f]+1;
        p[cnt++]=make_pair(tid[v]-len+1,len);
        v=fa[f][0]; f=top[v];
    }
    if(v!=A)
    {
        int len=dep[v]-dep[A];
        p[cnt++]=make_pair(tid[v]-len+1,len);
    }
    reverse(p+now,p+cnt);
}

pair <int,int> p1[maxn],p2[maxn];
int main()
{
    memset(head,-1,sizeof(head));
    scanf("%d%s",&n,str+1);
    for(int u,v,i=1;i<n;++i)
    {
        R(u); R(v);
        addedge(u,v);
        addedge(v,u);
    }
    dfs1(1,1,0); dfs2(1,1);
    data[n]='#';
    for(int i=n-1;i>=0;--i) data[n+n-i]=data[i];
    data[n+n+1]=0;
    da(data,sa,n+n+2,128);
    calheight(data,sa,n+n+1);
    for(int i=1;i<=n+n+1;++i) minx[i][0]=height[i];
    initRMQ(n+n+1);
    int m; R(m);
    while(m--)
    {
        int a,b,c,d;
        R(a); R(b); R(c); R(d);
        int c1=0,c2=0,ans=0;
        get_path(a,b,p1,c1);
        get_path(c,d,p2,c2);
        for(int i=0,j=0;i<c1&&j<c2;)
        {
            int l=rank[p1[i].FI],r=rank[p2[j].FI];
            int L=min(p1[i].SE,p2[j].SE);
            if(l>r) swap(l,r);
            if(l+1<=r) L=min(L,lcp(l+1,r));
            if(!L) break;
            ans+=L;
            p1[i].FI+=L; p2[j].FI+=L;
            p1[i].SE-=L; p2[j].SE-=L;
            if(!p1[i].SE) ++i;
            if(!p2[j].SE) ++j;
        }
        printf("%d\n",ans);
    }
    return 0;
}
