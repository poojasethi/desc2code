//By Lin
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <map>
#include <set>
#include <bitset>
#include <cmath>
#include <string>
#include <cstdlib>
#include <vector>

#define X first
#define Y second
#define mp make_pair
#define sqr(x) ((x) * (x))
#define Rep(i, n) for(int i = 0; i<(n); i++)
#define foreach(it, n) for(__typeof(n.begin()) it = n.begin(); it != n.end(); it++)

using namespace std;
typedef long long LL;
typedef pair<int, int> pii;

#define esp 1e-8
#define N 300010

int n;
char label[N];

struct Edge {
    int to;
    Edge *next;
};
struct Graph {
    int ecnt;
    Edge *mat[N], edges[N*2];
    void clear() {
        ecnt = 0;
        memset(mat, 0, sizeof mat);
    }
    void link(int x, int y) {
        edges[ecnt].to = y;
        edges[ecnt].next = mat[x];
        mat[x] = &edges[ecnt++];
        swap(x, y);
        edges[ecnt].to = y;
        edges[ecnt].next = mat[x];
        mat[x] = &edges[ecnt++];
    }

    int fa[N], dev[N], top[N], size[N], son[N];
    int pos[N], atPos[N], depth;
    void dfsA(int x) {
        size[x] = 1;
        son[x] = -1;
        for (Edge *p = mat[x]; p; p = p->next) {
            int to = p->to;
            if (to == fa[x]) continue;
            fa[to] = x;
            dev[to] = dev[x] + 1;
            dfsA(to);
            if (son[x] == -1 || size[to] > size[son[x]])
                son[x] = to;
            size[x] += size[to];
        }
    }
    void dfsB(int x, int tp) {
        top[x] = tp;
        atPos[pos[x] = depth++] = x;
        if (son[x] != -1) dfsB(son[x], tp);
        for (Edge *p = mat[x]; p; p = p->next) {
            int to = p->to;
            if (to == fa[x] || to == son[x]) continue;
            dfsB(to, to);
        }
    }
    void build() {
        fa[1] = -1; dev[1] = 0;
        dfsA(1);
        depth = 0;
        dfsB(1, 1);
    }
    vector<pii> getSeq(int u, int v) {
        vector<pii> L, R;
        while (top[u] != top[v]) {
            if (dev[top[u]] > dev[top[v]]) {
                L.push_back(mp(2*n-1-pos[u], dev[u] - dev[top[u]] + 1));
                u = fa[top[u]];
            }
            else {
                R.push_back(mp(pos[top[v]], dev[v] - dev[top[v]] + 1));
                v = fa[top[v]];
            }
        }
        if (dev[u] >= dev[v]) {
            L.push_back(mp(2*n-1-pos[u], dev[u] - dev[v] + 1));
        }
        else 
            R.push_back(mp(pos[u], dev[v] - dev[u] + 1));
        while (!R.empty()) {
            L.push_back(R.back());
            R.pop_back();
        }
        return L;
    }
}tree;

char *_str;
bool cmp(int x, int y) { 
    return _str[x] < _str[y]; 
}

inline int sv(int n, int *rk, int k) { return k < n ? rk[k] + 1 : 0; }

void suffix_array(char *str, int *sa, int *ht, int *rk, int *h) {
    int i, j, t, k, n = strlen(str);

    for (i = 0; i < n; i++) sa[i] = i;
    _str = str; sort(sa, sa + n, cmp);

    for (i = j = 0; i < n; i = j)
        while (j < n && str[sa[i]] == str[sa[j]])
            rk[sa[j++]] = i;

    for (k = 1; k <= n; k <<= 1) {
        for (i = 0; i <= n; i++) h[i] = 0;
        for (i = 0; i < n; i++) h[sv(n, rk, i + k)]++;
        for (i = 1; i <= n; i++) h[i] += h[i - 1];
        for (i = n - 1; i >= 0; i--) ht[--h[sv(n, rk, i + k)]] = i;

        for (i = 0; i < n; i++) h[i] = 0;
        for (i = 0; i < n; i++) h[rk[sa[i]]]++;
        for (i = 1; i < n; i++) h[i] += h[i - 1];
        for (i = n - 1; i >= 0; i--) sa[--h[rk[ht[i]]]] = ht[i];

        for (i = j = 0; i < n; i = j)
            while (j < n && rk[sa[i]] == rk[sa[j]] && sv(n, rk, sa[i] + k) == sv(n, rk, sa[j] + k))
                ht[sa[j++]] = i;
//      swap(ht, rk);
        for (i = 0; i < n; i++) swap(ht[i], rk[i]);
    }

    for (i = 0; i < n; i++) {
        if (rk[i] == n - 1) {
            h[i] = 0;
            continue;
        }
        k = sa[rk[i] + 1];
        t = (!i || h[i - 1] <= 1) ? 0 : h[i - 1] - 1;
        for (; str[i + t] == str[k + t]; t++);
        h[i] = t;
    }
    for (i = 0; i < n; i++)
        ht[i] = h[sa[i]];
}

char s[N*2];
int sa[N*2], ht[N*2], rk[N*2], h[N*2];
int Log[N*2], mi[N*2][24];
void buildRmq(int *val, int n) {
    Log[1] = 0;
    for (int i = 2; i <= n; i++)
        Log[i] = (1<<Log[i-1]+1) <= i ? Log[i-1] + 1 : Log[i-1];
    for (int i = 0; i < n; i++) mi[i][0] = val[i];
    for (int j = 1; (1<<j) <=n; j++)
        for (int i = 0; i + (1<<j) - 1 < n; i++) 
            mi[i][j] = min(mi[i][j-1], mi[i+(1<<j-1)][j-1]);
}
int  askRmq(int pos1, int pos2) {
    if (pos1 == pos2) return 2 * n - pos1;
    pos1 = rk[pos1];
    pos2 = rk[pos2];
    if (pos1 > pos2) swap(pos1, pos2);
    pos2 --;
    int j = Log[pos2 - pos1 + 1];
    return min(mi[pos1][j], mi[pos2 - (1<<j) + 1][j]);
}
int main() {
    scanf("%d", &n);
    scanf("%s", label);
    tree.clear();
    Rep(i, n - 1) {
        int x, y;
        scanf("%d%d", &x, &y);
        tree.link(x, y);
    }
    tree.build();
    Rep(i, n) s[tree.pos[i+1]] = label[i];
    Rep(i, n) s[2*n-1-i] = s[i];
    s[2*n] = 0;
    int nn = strlen(s);
    suffix_array(s, sa, ht, rk, h);
    buildRmq(ht, 2 * n);
    int m;
    scanf("%d", &m);
    while (m --) {
        int u1, v1, u2, v2;
        scanf("%d%d%d%d", &u1, &v1, &u2, &v2);
        vector<pii> seq1 = tree.getSeq(u1, v1);
        vector<pii> seq2 = tree.getSeq(u2, v2);
        int ans = 0, i = 0, j = 0;
        while (i < seq1.size() && j < seq2.size()) {
            int len = askRmq(seq1[i].X, seq2[j].X);
            len = min(len, min(seq1[i].Y, seq2[j].Y));
            ans += len;
            if (len < seq1[i].Y && len < seq2[j].Y) break;
            if (len == seq1[i].Y) i++;
            else {
                seq1[i].Y -= len;
                seq1[i].X += len;
            }
            if (len == seq2[j].Y) j++;
            else {
                seq2[j].Y -= len;
                seq2[j].X += len;
            }
        }
        printf("%d\n", ans);
    }
    return 0;
}
