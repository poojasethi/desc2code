#include<bits/stdc++.h>

using namespace std;

#define foreach(i, x)  for(type(x) i=x.begin() ; i != x.end() ; i++)
#define FOR(ii, aa, bb) for(int ii = aa ; ii <= bb ; ii++)
#define ROF(ii, aa, bb) for(int ii = aa ; ii >= bb ; ii--)

#define type(x) __typeof(x.begin())

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair< int, int > pii;

typedef long long ll;
 
const int mod  = 1e9+7;
const ll  linf = 1e18;
const int inf  = 1e9;
const int N = 1e6+5;
const int logN = 20;

int lcp[N][logN+1], sorted[N], suff[N], ac[N], T, depth[N], s, L[N], a, b, c, d, rmq[N][logN+1], num[N], w[N], i, j, k, n, m, arr[N];

pair< pii , int > C[N];

int LOG[N], q[N], P[N], start[N], down[N], lca[N][logN+1], sum[N], head[N], root[N], x, y, z;

char val[N]; 

vector< int > v[N];   

vector< pii > temp;

int prepare(int node,int last) { sum[node] = 1; foreach(it,v[node]) if(*it != last) sum[node] += prepare(*it, node); return sum[node]; }

int dfs(int node,int last,int head) {
	start[node] = ++T; ::q[T] = node; lca[node][0] = last;
	depth[node] = depth[last] + 1; ::temp.pb(mp(depth[node],node)); root[node] = last;
	int temp = 0; down[node] = node; ::head[node] = head;
	foreach(it,v[node]) if(*it != last && sum[temp] <= sum[*it]) temp = *it;
	if(temp) down[node] = dfs(temp,node,head);
	foreach(it,v[node]) if(*it != last && temp != *it) dfs(*it, node, *it);
	return down[node];
}

void eulerian(int node,int last) {
	rmq[++s][0] = num[node]; ac[node] = s;
	foreach(it,v[node]) {
		if(*it == last) continue;
		eulerian(*it, node);
		rmq[++s][0] = num[node];
	}
}

int get_lca(int x,int y){
	x = ac[x]; y = ac[y];
	if(x > y) swap(x,y);
	int t = LOG[y-x+1]; 
	return w[min(rmq[x][t], rmq[y-(1<<t)+1][t])];
}

int take(int x,int y) {
}

int get_lcp(int x,int y){
	x = suff[x]; y = suff[y];
	if(x == y) return inf;
	if(x > y) swap(x,y); x++;
	int t = LOG[y-x+1]; 
	return min(lcp[x][t], lcp[y-(1<<t)+1][t]);
	
}

vector< pii > pre_calc(int x,int y) {
	
	vector< pii > t1, t2;
	
	int l = get_lca(x,y);

	while(depth[x] > depth[l]) {
		int a1 = start[x];
		int a2 = start[head[x]];
		if(depth[head[x]] <= depth[l]) a2 = start[l] + 1;
		t1.pb(mp(2*n-a1+1,2*n-a2+1));
		x = root[q[a2]];
	}	
	
	while(depth[y] >= depth[l]) {
		int a2 = start[y];
		int a1 = start[head[y]];
		if(depth[q[a1]] < depth[l]) a1 = start[l];
		t2.pb(mp(a1,a2));
		y = root[q[a1]];
	}
	
	ROF(i,(int)t2.size()-1,0) t1.pb(t2[i]);

	return t1; 
}

int solve(int a,int b,int c,int d) {
	int all = 0; vector< pii > t1 = pre_calc(a,b), t2 = pre_calc(c,d);
	vector< pair< pii , pii > > t3;
	int i = 0, j = 0, l1 = t1[0].st, l2 = t2[0].st;
	t1.pb(mp(inf,inf)); t2.pb(mp(inf,inf));
	while(i < (int)t1.size()-1 && j < (int)t2.size()-1) {
		int l = min(t1[i].nd - l1 + 1, t2[j].nd - l2 + 1);
		t3.pb(mp(mp(l1,l1+l-1),mp(l2,l2+l-1)));
		l1 += l; l2 += l;
		if(l1 > t1[i].nd) { l1 = t1[++i].st; }
		if(l2 > t2[j].nd) { l2 = t2[++j].st; }
	}
	
	foreach(it,t3) {
		if(get_lcp(it->st.st,it->nd.st) >= it->st.nd - it->st.st + 1) all += it->st.nd - it->st.st + 1;
		else return all + get_lcp(it->st.st,it->nd.st);
	} 

	return all;
}

int main(){

	FOR(i,1,N-1) LOG[i] = log2(i);

	scanf("%d %s",&n,val+1);

	FOR(i,2,n) {
		scanf("%d %d",&x,&y);
		v[x].pb(y);
		v[y].pb(x);
	}

	prepare(1,0); dfs(1,0,1); 
	
	sort(temp.begin(),temp.end());
	
	int c = 0; 
	
	foreach(it,temp) { num[it->nd] = ++c; w[c] = it->nd; }
	
	eulerian(1,0);
	
	FOR(j,1,logN) FOR(i,1,s) rmq[i][j] = min(rmq[i][j-1], rmq[min(s,i+(1<<j-1))][j-1]);
	FOR(j,1,logN) FOR(i,1,n) lca[i][j] = lca[lca[i][j-1]][j-1];

	FOR(i,1,n) arr[start[i]] = val[i] - 'a' + 1;
	FOR(i,n+1,2*n) arr[i] = arr[2 * n - i + 1];
	FOR(i,1,2*n) suff[i] = arr[i];

	C[0].st = mp(-1,-1);

	FOR(i,1,logN){
		FOR(j,1,2*n) C[j] = mp(mp(suff[j],suff[min(2*n+1,j+(1<<i-1))]),j);
		sort(C+1,C+2*n+1);
		FOR(j,1,n*2) suff[C[j].nd] = suff[C[j-1].nd] + (C[j-1].st != C[j].st);
	}

	FOR(i,1,2*n) sorted[suff[i]] = i;

	int j = 0;

	FOR(i,1,2*n) {
		if(suff[i] == 1) continue;
		while(i + j <= 2 * n && sorted[suff[i]-1] + j <= 2*n && arr[i + j] == arr[sorted[suff[i]-1]+j]) j++;	
		lcp[suff[i]][0] = j;
		if(j) j--;
	}

	FOR(j,1,logN) FOR(i,1,2*n) lcp[i][j] = min(lcp[i][j-1],lcp[min(2*n,i+(1<<j-1))][j-1]);

	scanf("%d",&m);

	FOR(i,1,m) {
		scanf("%d %d %d %d",&a,&b,&c,&d);
		printf("%d\n",solve(a,b,c,d));
	}

   return 0;
}
