#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
#include <conio.h>
using namespace std;
const int maxn = 3e5 + 500;
const long long p1 = 175447;
const long long p2 = 350899;
const long long mod1 = 1e9 + 7;
const long long mod2 = 1e9 + 9;
typedef pair<long long ,long long>dl;
typedef pair<int,int>dii;
long long pow_p1[maxn] , pow_p2[maxn];
struct Edge{int v,nxt;};
Edge e[maxn*2];
char val[maxn],XC[maxn];
int head[maxn],tot=0,dfs_clock,top[maxn],son[maxn],deep[maxn],lca[maxn][22],idx[maxn],n;
vector<dii>v1,v2;
dl T1Hash[maxn],T2Hash[maxn];

//用失眠去反省
//爱凝结成泪的轨迹
//不断为难自己想借遗憾进化自己

void init_myhash()
{
	T1Hash[0].first = T1Hash[0].second = 0 ; T2Hash[n+1].first = T2Hash[n+1].second = 0;
	for(int i = 1 ; i <= n ; ++ i)
	{
		T1Hash[i].first = T1Hash[i-1].first * p1 + XC[i],T1Hash[i].second = T1Hash[i-1].second * p2 + XC[i];
		if(T1Hash[i].first >= mod1) T1Hash[i].first %= mod1;
		if(T1Hash[i].second >= mod2) T1Hash[i].second %= mod2;
	}
	for(int i = n ; i >= 1 ; -- i)
	{
		T2Hash[i].first = T2Hash[i+1].first * p1 + XC[i],T2Hash[i].second = T2Hash[i+1].second * p2 + XC[i];
		if(T2Hash[i].first >= mod1) T2Hash[i].first %= mod1;
		if(T2Hash[i].second >= mod2) T2Hash[i].second %= mod2;
	}
}

dl query_s1(int L,int R)
{
	dl res;
	res.first = (T1Hash[R].first - (T1Hash[L-1].first*pow_p1[R-L+1])%mod1 + mod1)%mod1;
	res.second= (T1Hash[R].second- (T1Hash[L-1].second*pow_p2[R-L+1])%mod2 + mod2)%mod2;
	return res;
}

dl query_s2(int L,int R)
{
	dl res;
	res.first = (T2Hash[L].first - (T2Hash[R+1].first*pow_p1[R-L+1])%mod1 + mod1)%mod1;
	res.second= (T2Hash[L].second- (T2Hash[R+1].second*pow_p2[R-L+1])%mod2 + mod2)%mod2;
	return res;
}

void addedge(int u,int v) {e[tot].v=v,e[tot].nxt=head[u],head[u]=tot++;}

int dfs1(int u)
{
	int mz = 0 , res = 1;
	for(int i = head[u] ; ~i ; i = e[i].nxt)
	{
		int v = e[i].v;
		if(v==lca[u][0]) continue;
		deep[v] = deep[u] + 1 , lca[v][0] = u ;
		int t = dfs1(v);
		if(t > mz)
		{
			mz = t;
			son[u] = v;
		}
		res += t;
	}
	return res;
}

void dfs2(int u,int tp)
{
	top[u] = tp , idx[u] = ++dfs_clock ; XC[dfs_clock] = val[u];
	if(son[u]) dfs2(son[u],tp);
	for(int i = head[u] ; ~i ; i = e[i].nxt)
	{
		int v = e[i].v;
		if(v==son[u] || v==lca[u][0]) continue;
		dfs2(v,v);
	}
}

int QueryLCA(int u ,int v)
{
	if(deep[u] < deep[v]) swap(u,v);
	for(int i = 19 ; i >= 0 ; -- i) if(deep[u] - (1<<i) >= deep[v]) u = lca[u][i];
	if(u == v) return u;
    for(int i = 19 ; i >= 0 ; -- i) if(lca[u][i] != lca[v][i]) u = lca[u][i] , v = lca[v][i];
    return lca[u][0];
}

inline bool equal_or_not(const dl & x,const dl & y){return x.first == y.first && x.second == y.second;}

void chuli(int a,int b,vector<dii>&vi)
{
	int lc = QueryLCA(a,b);
	while(top[a] != top[lc])
	{
		vi.push_back(make_pair(idx[a],idx[top[a]]));
		a = lca[top[a]][0];
	}
	vi.push_back(make_pair(idx[a],idx[lc]));
	vector<dii>temp;
	while(top[b] != top[lc])
	{
		temp.push_back(make_pair(idx[top[b]],idx[b]));
		b = lca[top[b]][0];
	}
	reverse(temp.begin(),temp.end());
	if(b != lc) vi.push_back(make_pair(idx[lc]+1,idx[b]));
	vi.insert(vi.end(),temp.begin(),temp.end());
}

inline int my_plus(const dl & x,const int add)
{
	if(x.second > x.first) return x.first + add;
	else return x.first-add;
}

//落叶堆积了好几层
//而我踩过青春
//听见
//谁在泪雨纷纷
int solve()
{
	int ed1 = v1.size() , ed2 = v2.size() , cur1 = 0 , cur2 = 0 , ans = 0 , add1 = 0 ,add2 = 0;
	while(cur1 != ed1 && cur2 != ed2)
	{
		int start1 = my_plus(v1[cur1],add1) , start2 = my_plus(v2[cur2],add2) ;
		int end1 = v1[cur1].second , end2 = v2[cur2].second;
		int newadd = min( abs(end1 - start1) , abs(end2 - start2) ) + 1;
		int L = 0 , R = newadd;
		int f1 = 0;
		dl Lres,Rres;
		int s1,e1,s2,e2;
		if(v1[cur1].second > v1[cur1].first)
		{
			s1 = start1,e1 = start1+newadd-1;
			Lres = query_s1(s1,e1);
		}
		else
		{
			s1 = start1 - newadd+1 , e1 = start1;
			Lres = query_s2(s1,e1);
		}
		if(v2[cur2].second > v2[cur2].first) 
		{
			s2 = start2,e2 = start2+newadd-1;
			Rres = query_s1(s2,e2);
		}
		else
		{
			s2 = start2 - newadd+1 , e2 = start2;
			Rres = query_s2(s2,e2);
		}
		if(equal_or_not(Lres,Rres))
		{
			L = newadd;
			f1 = 1;
		}
		if(f1 == 0)
		{
				while(L < R)
				{
					int mid = L+((R-L+1)>>1);
					dl Lres,Rres;
					int s1,e1,s2,e2;
					if(v1[cur1].second > v1[cur1].first)
					{
						s1 = start1,e1 = start1+mid-1;
						Lres = query_s1(s1,e1);
					}
					else
					{
						s1 = start1 - mid+1 , e1 = start1;
						Lres = query_s2(s1,e1);
					}
					if(v2[cur2].second > v2[cur2].first) 
					{
						s2 = start2,e2 = start2+mid-1;
						Rres = query_s1(s2,e2);
					}
					else
					{
						s2 = start2 - mid+1 , e2 = start2;
						Rres = query_s2(s2,e2);
					}
					if(equal_or_not(Lres,Rres)) L = mid;
					else R = mid - 1;
				}
		}
		ans += L;
		if(L != newadd) return ans;
		add1 += newadd , add2+= newadd;
		if(add1 == abs(v1[cur1].first - v1[cur1].second)+1) add1 = 0 , cur1++;
		if(add2 == abs(v2[cur2].first - v2[cur2].second)+1) add2 = 0 , cur2++;
	}
	return ans;
}


//园中花瓣落地了断了过去
//而我酝酿情绪举杯引醉意
//烛火摇曳 皆因风起
int main(int argc,char * argv[])
{
	memset(head,-1,sizeof(head));
	scanf("%d",&n);scanf("%s",val+1);
	for(int i = 1 ; i < n ; ++ i)
	{
		int u , v;
		scanf("%d%d",&u,&v);
		addedge(u,v);addedge(v,u);
	}
	pow_p1[0] = pow_p2[0] = 1;
	for(int i = 1 ; i <= n+1 ; ++ i)
	{
		pow_p1[i] = pow_p1[i-1] * p1 , pow_p2[i] = pow_p2[i-1] * p2;
		if(pow_p1[i] >= mod1) pow_p1[i] %= mod1;
		if(pow_p2[i] >= mod2) pow_p2[i] %= mod2;
	}
	dfs1(1);dfs2(1,1);
	init_myhash();
    for(int j = 1 ; j <= 19 ; ++ j)
    	for(int i = 1 ; i <= n ; ++ i)
    		if(lca[i][j-1])
    			lca[i][j]=lca[lca[i][j-1]][j-1];
    int Q;scanf("%d",&Q);
	while(Q--)
	{
		int a , b , c , d;
		scanf("%d%d%d%d",&a,&b,&c,&d);
		v1.clear();v2.clear();
		chuli(a,b,v1);chuli(c,d,v2);
		printf("%d\n",solve());
	}
	return 0;
}
		  		   	 	 	 							    	 		