#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int MAX_N = 300000;

int nodes[MAX_N + 10], nxt[MAX_N * 2 + 10], to[MAX_N * 2 + 10], en, n;
char data[MAX_N + 10];

inline void addEdge(int f, int t){
	++ en;
	to[en] = t;
	nxt[en] = nodes[f];
	nodes[f] = en;
}

inline void readInt(int& a){
	a = 0;
	int c;
	do
		c = getchar();
	while(c < '0' || c > '9');
	do{
		a = a * 10 - '0' + c;
		c = getchar();
	} while(c >= '0' && c <= '9');
};

int father[MAX_N + 10], dep[MAX_N + 10];
int size[MAX_N + 10], son[MAX_N + 10];

void dfs(int cur){
	size[cur] = 1;
	for(int e = nodes[cur]; e; e = nxt[e]){
		if(to[e] == father[cur])
			continue;
		dep[to[e]] = dep[cur] + 1;
		father[to[e]] = cur;
		dfs(to[e]);
		size[cur] += size[to[e]];
		if(size[to[e]] > size[son[cur]])
			son[cur] = to[e];
	}
}

int c;
int S[MAX_N * 4 + 10];
int top[MAX_N + 10], idDown[MAX_N + 10], idUp[MAX_N + 10];
int sn;

void split(int cur, int _top){
	top[cur] = _top;
	S[++ sn] = data[cur];
	idDown[cur] = sn;
	if(son[cur])
		split(son[cur], _top);
	else
		S[++ sn] = ++ c;
	for(int e = nodes[cur]; e; e = nxt[e]){
		if(to[e] == father[cur] || to[e] == son[cur])
			continue;
		split(to[e], to[e]);
	}
}

int sa[MAX_N * 4 + 10], rank[MAX_N * 4 + 10], y[MAX_N * 4 + 10],
	trank[MAX_N * 4 + 10];
int H[MAX_N * 4 + 10][21], cnt[MAX_N * 4 + 10];
int low[MAX_N * 4 + 10];

inline int get(int p){
	if(p > sn)
		return 0;
	return rank[p];
}

void buildSA(){
	memset(cnt, 0, sizeof(cnt));
	for(int i = 1; i <= sn; i ++)
		++ cnt[S[i]];
	for(int i = 1; i <= (MAX_N << 2); i ++)
		cnt[i] += cnt[i - 1];
	for(int i = sn; i >= 1; i --)
		sa[cnt[S[i]] --] = i;
	rank[sa[1]] = 1;
	for(int i = 2; i <= sn; i ++)
		rank[sa[i]] = rank[sa[i - 1]] + (S[sa[i]] != S[sa[i - 1]]);
	for(int gap = 1; gap < sn; gap <<= 1){
		memset(cnt, 0, sizeof(cnt));
		for(int i = 1; i <= sn; i ++)
			++ cnt[get(i + gap)];
		for(int i = 1; i <= sn; i ++)
			cnt[i] += cnt[i - 1];
		for(int i = sn; i >= 1; i --)
			y[cnt[get(i + gap)] --] = i;
		memset(cnt, 0, sizeof(cnt));
		for(int i = 1; i <= sn; i ++)
			++ cnt[rank[i]];
		for(int i = 1; i <= sn; i ++)
			cnt[i] += cnt[i - 1];
		for(int i = sn; i >= 1; i --)
			sa[cnt[rank[y[i]]] --] = y[i];
		trank[sa[1]] = 1;
		for(int i = 2; i <= sn; i ++)
			trank[sa[i]] = trank[sa[i - 1]] + (rank[sa[i]] != rank[sa[i - 1]] || get(sa[i] + gap) != get(sa[i - 1] + gap));
		for(int i = 1; i <= sn; i ++)
			rank[i] = trank[i];
	}
}

void buildH(){
	int h = 0;
	for(int i = 1; i <= sn; i ++){
		if(h)
			-- h;
		if(rank[i] == sn)
			continue;
		while(i + h <= sn && sa[rank[i] + 1] + h <= sn && S[i + h] == S[sa[rank[i] + 1] + h])
			++ h;
		H[rank[i]][0] = h;
	}
	for(int i = 0; i < 20; i ++)
		for(int j = 1; j + (1 << (i + 1)) - 1 <= sn; j ++)
			H[j][i + 1] = min(H[j][i], H[j + (1 << i)][i]);
	memset(low, -1, sizeof(low));
	for(int i = 0; (1 << i) <= sn; i ++)
		low[1 << i] = i;
	for(int i = 1; i <= sn; i ++)
		if(low[i] == -1)
			low[i] = low[i - 1];
}

inline int query(int l, int r){
	int len = r - l + 1;
	return min(H[l][low[len]], H[r - (1 << low[len]) + 1][low[len]]);
}

struct Seg{
	int pos, len;
};

Seg seq[2][110];
int cn[2], sp[2];
Seg tmp[110];

void findChain(int a, int b, int tar){
	int tn = 0;
	cn[tar] = 0;
	while(top[a] != top[b]){
		if(dep[top[a]] > dep[top[b]]){
			++ cn[tar];
			seq[tar][cn[tar]] = (Seg){idUp[a], idUp[top[a]] - idUp[a] + 1};
//			seq[tar][cn[tar]].pos = idUp[a];
//			seq[tar][cn[tar]].len = idUp[top[a]] - idUp[a] + 1;
			a = father[top[a]];
		} else{
			++ tn;
			tmp[tn] = (Seg){idDown[top[b]], idDown[b] - idDown[top[b]] + 1};
			b = father[top[b]];
		}
	}
	if(dep[a] > dep[b]){
		++ cn[tar];
		seq[tar][cn[tar]] = (Seg){idUp[a], idUp[b] - idUp[a] + 1};
	} else{
		++ tn;
		tmp[tn] = (Seg){idDown[a], idDown[b] - idDown[a] + 1};
	}
	while(tn > 0)
		seq[tar][++ cn[tar]] = tmp[tn --];
}

int main(){
#ifndef ONLINE_JUDGE
	freopen("test.in", "r", stdin);
	freopen("test.out", "w", stdout);
#endif
	scanf("%d%s", &n, data + 1);
	for(int i = 1; i < n; i ++){
		int a, b;
		readInt(a); readInt(b);
		addEdge(a, b);
		addEdge(b, a);
	}
	dfs(1);
	c = S[1] = 300;
	sn = 1;
	split(1, 1);
	for(int i = 1; i <= sn; i ++)
		S[sn + i] = S[sn - i + 1];
	for(int i = 1; i <= sn; i ++)
		if(S[sn + i] >= 300)
			S[sn + i] = ++ c;
	for(int i = 1; i <= n; i ++)
		idUp[i] = sn + sn - idDown[i] + 1;
	sn <<= 1;
/*	for(int i = 1; i <= sn; i ++){
		if(S[i] >= 300)
			printf("%d ", S[i]);
		else
			putchar(S[i]);
	}
	putchar('\n');*/
	buildSA();
	buildH();
/*	for(int i = 1; i <= sn; i ++)
		printf("%d ", sa[i]);
	printf("\n");
	for(int i = 1; i < sn; i ++)
		printf("%d ", H[i][0]);
	printf("\n");*/
	int qn;
	readInt(qn);
	while(qn --){
		int f1, t1, f2, t2;
		readInt(f1); readInt(t1); readInt(f2); readInt(t2);
		findChain(f1, t1, 0);
		findChain(f2, t2, 1);
/*		for(int i = 1; i <= cn[0]; i ++)
			printf("%d %d, ", seq[0][i].pos, seq[0][i].len);
		printf("\n");
		for(int i = 1; i <= cn[1]; i ++)
			printf("%d %d, ", seq[1][i].pos, seq[1][i].len);
		printf("\n");*/
		int ans = 0;
		sp[0] = sp[1] = 1;
		while(sp[0] <= cn[0] && sp[1] <= cn[1]){
			int p1 = seq[0][sp[0]].pos, p2 = seq[1][sp[1]].pos;
			if(rank[p1] > rank[p2])
				swap(p1, p2);
			int lcp = 0x3f3f3f3f;
			if(p1 != p2)
				lcp = query(rank[p1], rank[p2] - 1);
			lcp = min(lcp, min(seq[0][sp[0]].len, seq[1][sp[1]].len));
			seq[0][sp[0]].pos += lcp;
			seq[0][sp[0]].len -= lcp;
			seq[1][sp[1]].pos += lcp;
			seq[1][sp[1]].len -= lcp;
			ans += lcp;
			if(seq[0][sp[0]].len && seq[1][sp[1]].len)
				break;
			if(seq[0][sp[0]].len == 0)
				++ sp[0];
			if(seq[1][sp[1]].len == 0)
				++ sp[1];
		}
		printf("%d\n", ans);
	}

	return 0;
}


