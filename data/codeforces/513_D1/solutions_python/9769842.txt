#!/usr/bin/env python
#-*- coding:utf-8 -*-

import sys
import math
import random
import operator
from fractions import Fraction, gcd
from decimal import Decimal, getcontext
from itertools import product, permutations, combinations
from collections import deque, defaultdict, Counter

MOD = 10**9 + 7
INF = float("+inf")


def die():
    print "IMPOSSIBLE"
    quit()


n, c = map(int, raw_input().split())
#lefts = defaultdict(set)
#rights = defaultdict(set)
max_left = defaultdict(lambda: 0)
max_right = defaultdict(lambda: 0)
min_left = defaultdict(lambda: INF)
min_right = defaultdict(lambda: INF)

mins = defaultdict(lambda: INF)
for i in xrange(c):
    a, b, dir = raw_input().split()
    a = int(a)
    b = int(b)
    if a >= b:
        die()

    if dir == "LEFT":
        #lefts[a].add(b)
        max_left[a] = max(max_left[a], b)
        min_left[a] = min(min_left[a], b)
    else:
        #rights[a].add(b)
        max_right[a] = max(max_right[a], b)
        min_right[a] = min(min_right[a], b)

root = 1
tree_left = {}
tree_right = {}
#print max_left
#print max_right


def recurse(node, min_to_drop, max_to_drop):
    global top
    # print "rec", node, "min", min_to_drop, "mx", max_to_drop, "|", top, max_left[node], max_right[node]
    if min_to_drop <= top:
        die()

    need_left = bool(max_left[node])
    if need_left:
        min_to_left = min(min_to_drop, min_left[node])
        max_to_left = max_left[node]
        if min_to_left <= top:
            die()

        top = tree_left[node] = top + 1
        if min_to_left == top:
            min_to_left += 1

        # print "  ", node, "left"
        recurse(top, min_to_left, max_to_left)

    need_right = bool(max_right[node]) or top < max_to_drop
    if need_right:
        min_to_right = min(top + 1, min_right[node])
        max_to_right = max(max_to_drop, max_right[node])
        if min_to_right <= top:
            die()

        top = tree_right[node] = top + 1
        if min_to_right == top:
            min_to_right += 1

        # print "  ", node, "right"
        recurse(top, min_to_right, max_to_right)


def visit(node):
    left = tree_left.get(node, None)
    right = tree_right.get(node, None)
    if left:
        visit(left)
    print node,
    if right:
        visit(right)

top = 1
recurse(top, 2, n)
visit(1)

quit()



has_left = defaultdict(lambda: False)
has_right = defaultdict(lambda: False)
parents = defaultdict(set)
children = defaultdict(set)

n, c = map(int, raw_input().split())
for i in xrange(c):
    a, b, dir = raw_input().split()
    if a >= b:
        die()
    if dir == "LEFT":
        maxes[a] = max(maxes[a], b)
        has_left[a] = True
    else:
        mins[a] = min(mins[a], b)
        has_right[a] = True

    if maxes[a] >= mins[a]:
        die()

    parents[b] += parents[a]
    parents[b].add(a)

    children[a].add(b)
    for par in parents[a]:
        children[par].add(b)

root = 1
left = {}
right = {}


# def recursive(node, ):
#     if not children[node]:
#         return (
#     if has_left[node]:
#         left = min(children[node])
#         children[node].remove(left)


