#include <stdio.h>
#include <vector>

#define MAX_N 100005
#define RIGHT 131072
#define SIZE 262155

int M, N, Pre;
int Ans[MAX_N], L[MAX_N], R[MAX_N];
using namespace std;
vector<int> E[MAX_N], Q[MAX_N];

class T
{
public:
    int count[SIZE], used[SIZE];
    int getCount();
    void update(int l, int r, int v, int n, int a, int b);
} Tree;

void T::update(int l, int r, int v, int n, int a, int b)
{
    if(a > r || b < l)
        return;
    if(a >= l && b <= r)
        count[n] += v;
    else
    {
        int mid = (a + b) / 2;
        update(l, r, v, 2*n, a, mid);
        update(l, r, v, 2*n + 1, mid + 1, b);
    }

    if(count[n] > 0)
        used[n] = b - a + 1;
    else
        used[n] = a == b ? 0 : used[2*n] + used[2*n + 1];
}

void in()
{
    scanf("%d %d", &N, &M);

    for(int i = 1; i < N; i++)
    {
        int a, b;
        scanf("%d %d", &a, &b);
        E[a].push_back(b);
        E[b].push_back(a);
    }

    for(int i = 0; i < M; i++)
    {
        int a, b;
        scanf("%d %d", &a, &b);
        Q[a].push_back(a);
        Q[a].push_back(b);
        Q[b].push_back(a);
        Q[b].push_back(b);
    }
}

void dfs(int n, int p)
{
    L[n] = ++Pre;

    for(int i = 0; i < E[n].size(); i++)
        if(E[n][i] != p)
            dfs(E[n][i], n);

    R[n] = Pre;
}

void dfs2(int n, int p)
{
    for(int i = 0; i < Q[n].size(); i++)
        Tree.update(L[ Q[n][i] ], R[ Q[n][i] ], 1, 1, 1, RIGHT);

    Ans[n] = max(Tree.used[1] - 1, 0);

    for(int i = 0; i < E[n].size(); i++)
        if(E[n][i] != p)
            dfs2(E[n][i], n);

    for(int i = 0; i < Q[n].size(); i++)
        Tree.update(L[ Q[n][i] ], R[ Q[n][i] ], -1, 1, 1, RIGHT);
}

int main()
{
    in();
    dfs(1, 0);
    dfs2(1, 0);

    for(int i = 1; i <= N; i++)
        printf("%d ", Ans[i]);

    return 0;
}
