#include <bits/stdc++.h>
#define fi first
#define se second
#define m ((b+s)>>1)
#define umax(a,b) a=max(a,b)
#define umin(a,b) a=min(a,b)

using namespace std;

typedef long long lint;
typedef pair <lint,lint> ii;
typedef vector <lint> vi;
typedef vector <ii> vii;

const lint maxn=1e5+20;

struct segment{
	lint seg[4*maxn],lazy[4*maxn];
	
	lint f(lint k,lint b,lint s){
		if(lazy[k]) return s-b+1;
		return seg[k];
	}
	
	lint upd(lint k,lint b,lint s,lint x,lint y,lint add){
		if(x<=b && s<=y){
			lazy[k]+=add;
			return f(k,b,s);
		}
		
		if(s<x || b>y) return f(k,b,s);
		
		seg[k]=upd(2*k,b,m,x,y,add)+upd(2*k+1,m+1,s,x,y,add);
		return f(k,b,s);
	}
}asd;

lint N,M,d[maxn],f[maxn],ans[maxn],tme;
vii v[maxn];
vi komsu[maxn];

void cal(lint node,lint dad){
	d[node]=++tme;
	
	for(lint i=0;i<komsu[node].size();i++)
		if(komsu[node][i]!=dad)
			cal(komsu[node][i],node);
	
	f[node]=tme;
}

void dfs(lint node,lint dad){
	for(lint i=0;i<v[node].size();i++)
		asd.upd(1,1,N,v[node][i].fi,v[node][i].se,1);
	
	ans[node]=max(0ll,asd.f(1,1,N)-1);
	
	for(lint i=0;i<komsu[node].size();i++)
		if(komsu[node][i]!=dad)
			dfs(komsu[node][i],node);
		
	for(lint i=0;i<v[node].size();i++)
		asd.upd(1,1,N,v[node][i].fi,v[node][i].se,-1);
}

int main(){
	scanf("%lld %lld",&N,&M);
	
	for(lint i=1;i<N;i++){
		lint a,b;
		scanf("%lld %lld",&a,&b);

		komsu[a].push_back(b);
		komsu[b].push_back(a);
	}
	
	cal(1,0);

	for(lint i=1;i<=M;i++){
		lint a,b;
		scanf("%lld %lld",&a,&b);
		
		v[a].push_back(ii(d[b],f[b]));
		v[b].push_back(ii(d[a],f[a]));
		v[b].push_back(ii(d[b],f[b]));
		v[a].push_back(ii(d[a],f[a]));
	}
	
	dfs(1,0);
	
	for(lint i=1;i<=N;i++)
		printf("%lld ",ans[i]);
	puts("");
	
	return 0;
}
