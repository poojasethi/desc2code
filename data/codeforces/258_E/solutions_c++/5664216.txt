#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<vector>
#define N 200005
#define M N*2
#define lt (x<<1)
#define rt ((x<<1)^1)
using namespace std;
int n,m,st[N],en[N],did;
int ans[N],cnt,hd[N];
vector<int> q[N];
bool vis[N];
struct node{
	int l,r,sum,lazy;
}T[N<<3];
struct edg{
	int v,nxt;
}E[M];
void init(){
	cnt=did=0;
	memset(hd,-1,sizeof(hd));
	memset(vis,0,sizeof(vis));
}
void adde(int u,int v){
	E[++cnt].v=v;
	E[cnt].nxt=hd[u];
	hd[u]=cnt;
}
void dfs(int u,int fa){
	int v;
	vis[u]=true;
	st[u]=++did;
	for(int i=hd[u];~i;i=E[i].nxt){
		v=E[i].v;
		if(!vis[v])dfs(v,u);
	}
	en[u]=did;
}
void bt(int x,int l,int r){
	T[x].l=l,T[x].r=r;T[x].lazy=T[x].sum=0;
	if(l==r)return;
	else{
		int m=(l+r)>>1;
		bt(lt,l,m);
		bt(rt,m+1,r);
	}
}
void upd(int x,int l,int r,int v){
	if(T[x].l==l&&T[x].r==r){
		T[x].lazy+=v;
		if(T[x].lazy)T[x].sum=T[x].r-T[x].l+1;//pt involved
		else{
			if(T[x].l==T[x].r)T[x].sum=0;
			else T[x].sum=T[lt].sum+T[rt].sum;
		}
		return;
	}
	int m=(T[x].l+T[x].r)>>1;
	if(r<=m)upd(lt,l,r,v);
	else if(l>m)upd(rt,l,r,v);
	else{
		upd(lt,l,m,v);
		upd(rt,m+1,r,v);
	}
	if(T[x].lazy)T[x].sum=T[x].r-T[x].l+1;
	else{
		if(T[x].r==T[x].l)T[x].sum=0;
		else T[x].sum=T[lt].sum+T[rt].sum;
	}
}
void fk(int u,int fa){
	int v;
	for(int i=0;i<q[u].size();++i)upd(1,st[q[u][i]],en[q[u][i]],1);
	ans[u]=T[1].sum;
	if(ans[u])--ans[u];
	for(int i=hd[u];~i;i=E[i].nxt){
		if((v=E[i].v)!=fa)fk(v,u);
	}
	//recover
	for(int i=0;i<q[u].size();++i)upd(1,st[q[u][i]],en[q[u][i]],-1);

}
int main(){
	int x,y;
	init();
	scanf("%d%d",&n,&m);
	for(int i=1;i<n;++i){
		scanf("%d%d",&x,&y);
		adde(x,y);
		adde(y,x);
	}
	dfs(1,-1);
	while(m--){
		scanf("%d%d",&x,&y);
		q[x].push_back(y);
		q[x].push_back(x);
		q[y].push_back(y);
		q[y].push_back(x);
	}
	bt(1,1,n);
	fk(1,-1);
	for(int i=1;i<=n;++i)printf("%d%c",ans[i],i==n?'\n':' ');
	return 0;
}

 	  	       	 	 						 	 	