#include <cstdio>
#include <vector>
#define REP(i,n) for (int (i)=1;(i)<=(n);++(i))
#define fe(i,p) for (__typeof(p.begin()) i=p.begin();i!=p.end();++i)
using namespace std;

const int maxn=200020;
struct AAA{int s,e,next;} v[maxn<<1];
struct SSS{int l,r,m,ti,su;} t[maxn<<3];
int n,m,x,y,tt,ans[maxn],first[maxn],a[maxn<<1],f[maxn][2];
vector<int> ask[maxn];

void Add(int x,int y) {
	v[++tt].s=x; v[tt].e=y;
	v[tt].next=first[x]; first[x]=tt;
}

void Dfs(int k,int father) {
	a[++a[0]]=k; f[k][0]=a[0];
	for (int p=first[k];p;p=v[p].next)
		if (v[p].e!=father) Dfs(v[p].e,k);
	a[++a[0]]=k; f[k][1]=a[0];
}

void Build(int p,int l,int r) {
	t[p].l=l; t[p].r=r;
	t[p].m=(l+r)>>1;
	if (t[p].l==t[p].r) return;
	Build(p<<1,l,t[p].m);
	Build((p<<1)+1,t[p].m+1,r);
}

void Update(int p) {
	if (t[p].ti) t[p].su=t[p].r-t[p].l+1;
	else t[p].su=t[p<<1].su+t[(p<<1)+1].su;
}

void Modify(int p,int l,int r,int de) {
	if ((l<=t[p].l)&&(t[p].r<=r)) {t[p].ti+=de;Update(p);}
	else {
		if (l<=t[p].m) Modify(p<<1,l,r,de);
		if (r>t[p].m) Modify((p<<1)+1,l,r,de);
		Update(p);
	}
}

bool Self(int p,int k) {
	if (t[p].ti) return true;
	if (t[p].l==t[p].r) return false;
	if (k<=t[p].m) return Self(p<<1,k);
	if (k>t[p].m) return Self((p<<1)+1,k);
}

int main() {
	scanf("%d%d",&n,&m);
	REP(i,n-1) scanf("%d%d",&x,&y),Add(x,y),Add(y,x);
	Dfs(1,0);
	Build(1,1,n+n);
	REP(i,m) {
		scanf("%d%d",&x,&y);
		ask[x].push_back(y);
		ask[y].push_back(x);
	}
	REP(i,n)
		if (ask[i].begin()!=ask[i].end()) ask[i].push_back(i);
	REP(i,n+n)
		if (f[a[i]][1]==i)
			fe(j,ask[a[i]]) Modify(1,f[*j][0],f[*j][1],-1);
		else {
			fe(j,ask[a[i]]) Modify(1,f[*j][0],f[*j][1],1);
			ans[a[i]]=t[1].su>>1;
			if (Self(1,i)) --ans[a[i]];
		}
	REP(i,n) printf("%d ",ans[i]);
	return 0;
}
