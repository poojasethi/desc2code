#include<cstdio>
#include<vector>
using namespace std;
#define tree int t,int l,int r
#define left t*2,l,mid
#define right t*2+1,mid+1,r
#define M int mid=(l+r)/2
#define pr pair<int,int>
#define mk make_pair
#define pb push_back
#define X first
#define Y second
#define N 100005
vector<int > ed[N];
vector<pr > e[N];
int a[N*4],c[N*4],d[N],L[N],R[N],ans[N],n,m,x,y,len,v;
void dfs(int x,int last)
{
    d[++len]=x,L[x]=len;
    for (int i = 0 ; i < ed[x].size();i++)
    {
        int y = ed[x][i];
        if (y-last) dfs(y,x);
    }
    R[x]=len;
}
void build(tree){a[t]=r-l+1; if (l==r) return; M; build(left),build(right);}
void add(tree,int ll,int rr)
{
    if (l==ll && r==rr){c[t]+=v,a[t]=c[t]?0:r-l?a[t*2]+a[t*2+1]:1; return;} M;
    if (rr<=mid) add(left,ll,rr); else if (ll>mid) add(right,ll,rr);
    else add(left,ll,mid),add(right,mid+1,rr); a[t]=c[t]?0:a[t*2]+a[t*2+1];
}
int main()
{
    //freopen("tree.inp","r",stdin);
    //freopen("tree.out","w",stdout);
    scanf("%d%d",&n,&m);
    for (int i=1;i<n;i++) scanf("%d%d",&x,&y),ed[x].pb(y),ed[y].pb(x);
    dfs(1,0); build(1,1,n);
    for (int i=1;i<=m;i++) scanf("%d%d",&x,&y),
        e[L[x]].pb(mk(x,y)),e[R[x]+1].pb(mk(x,-y)),
        e[L[y]].pb(mk(x,y)),e[R[y]+1].pb(mk(x,-y));
    for (int i=1;i<=n;i++){
        for (int li = 0; li < e[i].size();li++){
            pr j = e[i][li];
            v=1; if (j.Y<0) j.Y*=-1,v=-1;
            add(1,1,n,L[j.X],R[j.X]),add(1,1,n,L[j.Y],R[j.Y]);
            }
        v=1,add(1,1,n,i,i),ans[d[i]]+=n-a[1]-1,v=-1,add(1,1,n,i,i);
        }
    for (int i=1;i<=n;i++) printf("%d%s",ans[i],i<n?" ":"\n"); return 0;
}
