#include<cstdio>
#include<vector>
#include<algorithm>
#define N 200005
using namespace std;
vector<int>Q[N];
struct arr{int go,next;}A[N];
struct tree{int l,r,sum,cnt;}a[N*4];
int L[N],R[N],f[N],end[N],n,m,x,y,i,ans[N],tot,z,cnt;
inline void add(int u,int v){A[++cnt]=(arr){v,end[u]};end[u]=cnt;}
void dfs(int k,int fa)
{
  int go;L[k]=++tot;
  for (int i=end[k];i;i=A[i].next)
    if ((go=A[i].go)!=fa) dfs(go,k);
  R[k]=tot;
}
void build(int k,int l,int r)
{
  a[k].l=l;a[k].r=r;a[k].cnt=a[k].sum=0;
  if (l==r) return;int mid=(l+r)>>1;
  if (l<=mid) build(k<<1,l,mid);
  if (r>mid) build(k<<1|1,mid+1,r);
}
void update(int k,int S)
{
  if (x<=a[k].l&&a[k].r<=y)
  {
    a[k].cnt+=S;
    if (a[k].cnt>0) a[k].sum=a[k].r-a[k].l+1;
    else a[k].sum=a[k<<1].sum+a[k<<1|1].sum;
    return;
  }
  int mid=(a[k].l+a[k].r)>>1;
  if (x<=mid) update(k<<1,S);
  if (y>mid) update(k<<1|1,S);
  if (a[k].cnt>0) a[k].sum=a[k].r-a[k].l+1;
  else a[k].sum=a[k<<1].sum+a[k<<1|1].sum;
}
void find(int k,int fa)
{
  int go;
  for (int i=0;i<Q[k].size();i++)
    go=Q[k][i],x=L[go],y=R[go],update(1,1);
  ans[k]=a[1].sum;
  for (int i=end[k];i;i=A[i].next)
    if ((go=A[i].go)!=fa)
      find(go,k);
  for (int i=0;i<Q[k].size();i++)
    go=Q[k][i],x=L[go],y=R[go],update(1,-1);
}
int main()
{
  scanf("%d%d",&n,&m);
  for (i=1;i<n;i++)
    scanf("%d%d",&x,&y),add(x,y),add(y,x);
  dfs(1,-1);build(1,1,n);
  for (i=1;i<=m;i++)
  {
    scanf("%d%d",&x,&y);
    Q[x].push_back(y),Q[y].push_back(x);
    Q[x].push_back(x),Q[y].push_back(y);
  }
  find(1,-1);
  for (i=1;i<=n;i++)
    printf("%d ",max(ans[i]-1,0));
  return 0;
}
