from collections import defaultdict
import sys

def isNeighbor(road1, road2):
    if (road1[1] - road2[1]) * (road1[0] - road2[0]) <= 0:
        return False
    if (road1[1] - road2[0]) * (road2[1] - road1[0]) > 0:
            #print road1, road2
            #print (road1[1] - road2[0]) * (road2[1] - road1[0])
            return True
    return False

roads = {}
repeat = {}     #uncolored --> colored
edge = defaultdict(list)
def construct_graph(nowIndex):
    nowRoad = sorted(map(int, raw_input().split()))
    neighbors = []
    for prevIndex, prevRd in roads.items():
        # check overlap
        if nowRoad == prevRd:
            repeat[nowIndex] = prevIndex
            return
        if isNeighbor(prevRd, nowRoad):
            neighbors.append(prevIndex)
    roads[nowIndex] = nowRoad
    for n in neighbors:
        edge[nowIndex].append(n)
        edge[n].append(nowIndex)

if __name__ == "__main__":
    # initilaize
    cityNum, roadNum = map(int, raw_input().split()) 
    for i in range(roadNum):
        construct_graph(i)
    #print edge

    output = {}
    notAssigned = roads.keys()
    while(notAssigned != []):
        nowID = notAssigned.pop()
        nowNeighbor = edge[nowID]
        # for root case.
        if nowID not in output.keys():
            output[nowID] = 1   
        nowGroup = output[nowID]
        for n in nowNeighbor:
            if n in output.keys():
                if output[n] == output[nowID]:
                    print "Impossible"
                    sys.exit()
            else:
                output[n] = 1 - nowGroup  
                notAssigned.remove(n)
                notAssigned.append(n)
                
    # handle redundant roads.
    for rd in repeat.keys():
        output[rd] = output[repeat[rd]]
    output_str = []
    for i in range(roadNum):
        if output[i] == 1:
            output_str.append("i")
        else:
            output_str.append('o')
    print "".join(output_str)

    


