#include <cstdio>
#include <iostream>
#include <cmath>
#include <sstream>
#include <vector>
#include <map>
#include <set>
#include <complex>
#include <algorithm>
#include <functional>
#include <fstream>
#include <numeric>
#include <string>
#include <valarray>
#include <deque>
#define int long long

using namespace std;

typedef pair<int,int> Pair;

template<class t>
ostream & operator << (ostream & tout,const vector<t> &s){
  tout<<'[';
  for (int i=0;i<s.size();i++)
    if (i+1 == s.size())
      tout<<s[i];
    else
      tout<<s[i]<<',';
  tout<<']';
  return(tout);
}

template<class A,class B,class C>
struct tuple{
  A x;
  B y;
  C z;
  bool operator < (const tuple &s)const{
	if (x!=s.x) return(x < s.x);
	if (y!=s.y) return(y < s.y);
	return(z < s.z);
  }
  tuple(A a,B b,C c){
	x=a;
	y=b;
	z=c;
  }
};

template <class Type,class Int=unsigned int,Int End=250000,Type Default=0>
class add_sum_tree{
  class node{
  public:
    Type Itself,Itschilds;
    node *next[2];
    node(){ Itself=0,Itschilds=0; next[0]=next[1]=0;
    }
    node* child(int s){
      if (!next[s]) next[s]=new node();
      return(next[s]);
    }
  }*root;
public:
  add_sum_tree(){ root=new node(); root->Itself=Default;
  }
  void add(Int where,const Type &s){
    Int A=0,B=End;
    node *temp=root;
    Int Mid;
    while (B>where){
      temp->Itschilds+=(where-A+1)*s;
      Mid=(A+B)/2;
      if (Mid >= where){
	temp=temp->child(0);
	B=Mid;
      }else{
	temp->child(0)->Itself+=s;
	temp=temp->child(1);
	A=Mid+1;
      }
    }
    temp->Itself+=s;
  }
  void add(Int a,Int b,const Type &s){
    add(b,s);
    if (a) add(a-1,Type(0)-s);
  }
  Type sum(Int where){
    Int A=0,B=End,Mid;
    Type ans=0;
    node *temp=root;
    while (B>where){
      ans+=temp->Itself*(where-A+1);
      Mid=(A+B)/2;
      if (Mid >= where){
	temp=temp->child(0);
	B=Mid;
      }else{
	if (temp->next[0])
	  ans+=(temp->next[0]->Itself)*(Mid-A+1)+temp->next[0]->Itschilds;
	temp=temp->child(1);
	A=Mid+1;
      }
    }
    ans+=temp->Itschilds+temp->Itself*(B-A+1);
    return(ans);
  }
  Type sum(Int a,Int b){
    if (a) return(sum(b)-sum(a-1));
    return(sum(b));
  }
};

typedef tuple<int,int,int> triple;

const int MAX_N=200000+20;

vector<int> e[MAX_N],w[MAX_N];
vector<int> mai,cycle,glo;
bool mark[MAX_N],isCycle[MAX_N];
int n,start[MAX_N],end[MAX_N];
vector<triple> add;

void dfs(int s,int t){
  mark[s]=true;
  glo.push_back(s);
  start[s]=glo.size()-1;
  for (int i=0;i<e[s].size();i++)
    if (!mark[e[s][i]] && !isCycle[e[s][i]])
      dfs(e[s][i],w[s][i]);
  end[s]=glo.size()-1;
  if (t){
    add.push_back(triple(0,start[s]-1,t*(end[s]-start[s]+1)));
    add.push_back(triple(end[s]+1,n-1,t*(end[s]-start[s]+1)));
    add.push_back(triple(start[s],end[s],t*(n-(end[s]-start[s]+1))));
  }
}

void find_cycle(int s){
  if (cycle.size())
    return;
  mai.push_back(s);
  mark[s]=true;

  for (int i=0;i<e[s].size();i++){
    if (cycle.size())
      return;
    if (mark[e[s][i]]){
      if (e[s][i] != mai[mai.size()-2]){
	while (mai.size()){
	  cycle.push_back(mai.back());
	  mai.pop_back();
	  if (cycle.back() == e[s][i])
	    break;
	}
	return;
      }
    }else
      find_cycle(e[s][i]);
  }
  mai.pop_back();
}

vector<int> d,zarib;

vector<int> rev(vector<int> s){
  reverse(s.begin(),s.end());
  return(s);
}

int rev(int s){
  return(d.size()-s-1);
}

struct S1{
  vector<int> sum;
  S1(vector<int> a){
    sum.push_back(a[0]);
    for (int i=1;i<a.size();i++)
      sum.push_back(sum.back()+a[i]);
  }
  int get(int s,int t){
    if (s == 0)
      s = sum.size()-1;
    else
      s--;
    if (t == 0)
      t = sum.size()-1;
    else
      t--;
    if (s > t)
      return(sum[t]+sum.back()-sum[s]);
    else
      return(sum[t]-sum[s]);
  }
};

const int N4=400;

int getSum(const vector<int> &a,int x,int y){
  if (x == 0)
    return(a[y]);
  else
    return(a[y]-a[x-1]);
}

struct S2{
  vector<int> A,B;
  vector<int> g,p,q;
  S2(vector<int> a,vector<int> b){
    A=a;
    B=b;
    p.push_back(B[0]);
    for (int i=1;i<b.size();i++)
      p.push_back(p.back()+B[i]);
    q.push_back(A[0]);
    for (int i=1;i<A.size();i++)
      q.push_back(q.back()+A[i]);
    int ad=0;
    g.push_back(0);
    for (int i=1;i<A.size();i++)
      g.push_back(g.back()+q[i-1]*b[i]);
  }
  int get(int a,int b){
    if (a == 0)
      return(g[b]);
    if (a <= b)
      return(getSum(g,a,b)-q[a-1]*getSum(p,a,b));
    return(get(a,A.size()-1)+get(0,b)+getSum(q,a,B.size()-1)*getSum(p,0,b));
  }
};

vector<int> prev(vector<int> s){
  for (int i=s.size()-1;i>0;i--)
    swap(s[i],s[i-1]);
  return(s);
}

vector<int> cal(){
  S1 s1(d);
  S2 s2(d,zarib);
  S2 s3(rev(prev(d)),rev(zarib));
  vector<int> result;
  int pointer=0;
  int all=accumulate(d.begin(),d.end(),0ll);
  for (int i=0;i<d.size();i++){
    while ((pointer+1)%d.size() != i && s1.get(i,(pointer+1)%d.size()) <= all/2)
      pointer=(pointer+1)%d.size();
    result.push_back(s2.get(i,pointer)+s3.get(rev(i),rev((pointer+1)%d.size())));
//     cout<<i<<' '<<pointer<<' '<<s2.get(i,pointer)<<' '<<s3.get(rev(i),rev((pointer+1)%d.size()))<<endl;
    if (i == pointer)
      pointer=(pointer+1)%d.size();
  }
//   cout<<d<<' '<<zarib<<endl;
//   cout<<result<<endl;
  return(result);
}

#undef int
int main(){
#define int long long
  ios_base::sync_with_stdio(false) ;
  cin>>n;
  for (int i=1;i<=n;i++){
    int a,b,c;
    cin>>a>>b>>c;
    e[a].push_back(b);
    w[a].push_back(c);
    e[b].push_back(a);
    w[b].push_back(c);
  }
  
  find_cycle(1);
  fill(mark+1,mark+n+1,false);
  for (int i=0;i<cycle.size();i++)
    isCycle[cycle[i]]=true;
  for (int i=0;i<cycle.size();i++)
    dfs(cycle[i],0);

//   cout<<glo<<endl;
//   for (int i=0;i<add.size();i++)
//     cout<<add[i].x<<' '<<add[i].y<<' '<<add[i].z<<endl;
  map<Pair,int> mp;
  for (int i=1;i<=n;i++)
    for (int j=0;j<e[i].size();j++)
      mp[Pair(i,e[i][j])]=w[i][j];
  
  for (int i=0;i<cycle.size();i++){
    d.push_back(mp[Pair(cycle[i],cycle[(i+1)%cycle.size()])]);
    zarib.push_back(end[cycle[i]]-start[cycle[i]]+1);
  }
  vector<int> result=cal();
  for (int i=0;i<result.size();i++)
    add.push_back(triple(start[cycle[i]],end[cycle[i]],result[i]));
//   for (int i=0;i<add.size();i++)
//     cout<<add[i].x<<' '<<add[i].y<<' '<<add[i].z<<endl;
  
  add_sum_tree<int> mai;
  for (int i=0;i<add.size();i++)
    mai.add(add[i].x,add[i].y,add[i].z);
  vector<int> ret(n+1);
  for (int i=0;i<glo.size();i++)
    ret[glo[i]]=mai.sum(i,i);
  for (int i=1;i<=n;i++)
    cout<<ret[i]<<' ';
  cout<<endl;
}
