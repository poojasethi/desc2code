#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <string>
#include <cmath>
#include <climits>
#include <vector>
#include <map>
#include <set>
#include <iterator>
#include <utility>
#include <numeric>
#include <memory>
#include <stack>
#include <deque>
#include <queue>
#include <list>
#include <functional>
#include <iomanip>
#include <sstream>
#include <cctype>
#include <bitset>

#define X first
#define Y second
#define MAX(x, y) x = x > (y) ? x : (y)
#define MIN(x, y) x = x > (y) ? (y) : x
#define LOW(x) ((x) & -(x))
#define SQR(x) ((x) * (x))
#define REP(i, n) for (int i = 0; i < (n); ++i)
#define FOR(i, a, b) for (int i = (a); i < (b); ++i)
#define rFOR(i, b, a) for (int i = (b); i > (a); --i)
#define CLEAR(x) memset(x, 0, sizeof(x))
#define FILL(x, p) memset(x, p, sizeof(x))
#define COPY(x, y) memcpy(x, y, sizeof(x))
#define ALL(x) (x).begin(), (x).end()

using namespace std;

typedef long long ll;
typedef unsigned int ui;
typedef pair<int, int> PII;
typedef vector<PII> VPII;
typedef vector<int> VI;
typedef vector<string> VS;

const int INF = 0x3fffffff;
const ll _INF = 0x7ffffffffffffffll;
const double EPS = 1e-9;
const double PI = acos(-1.0);

template<class T, class INT>
inline T pow(T x, INT y)
{
	T res(1);
	for (T tt(x); y; y /= 2)
	{
		if (y & 1) res *= tt;
		tt *= tt;
	}
	return res;
}

template<class T, class INT>
inline T pow(T x, INT y, T p)
{
	T res(1);
	for (T tt(x); y; y /= 2)
	{
		if (y & 1) res = res * tt % p;
		tt = tt * tt % p;
	}
	return res;
}

int toInt(string s)
{
	int x = 0;
	istringstream sin(s);
	sin >> x;
	return x;
}

template<class T>
inline string toString(T x)
{
	ostringstream sout;
	sout << x;
	return sout.str();
}

template<class INT>
inline INT gcd(INT x, INT y)
{
	return y ? gcd(y, x % y) : x;
}

template<class INT>
inline int calc_bits(INT x)
{
	return x ? (x & 1) + calc_bits(x >> 1) : 0;
}

const int MAXN = 200000 + 10;
const int MAXM = 400000 + 10;

int n, tot, tt, u, v, c, sum, it, tmpl, tmpr, zf[MAXN], t;
int len[MAXM], slen[MAXM], prt[MAXM], head[MAXN], next[MAXM], vis[MAXM], cost[MAXM];
ll cnt[MAXN], ans[MAXN], _ans, f[MAXN];
bool check[MAXN];

int root(int x)
{
	return zf[x] ? zf[x] = root(zf[x]) : x;
}

inline void add (int u, int v, int c)
{
	next[++tot] = head[u];
	vis[head[u] = tot] = v;
	cost[tot] = c;
}

inline bool dfs(int x, int fat)
{
	check[x] = true;
	for (int i = head[x], k; i; i = next[i])
		if (!check[k = vis[i]] && dfs(k, x) || k == t && fat != t)
		{
			len[tt] = cost[i];
			prt[tt++] = k;
			return true;
		}
	return false;
}

ll calc(int x)
{
	ll res = 0;
	cnt[x] = 1;
	check[x] = true;
	for (int i = head[x], k; i; i = next[i])
		if (!check[k = vis[i]]) res += calc(k) + cost[i] * cnt[k], cnt[x] += cnt[k];
	return f[x] = res;
}

void _calc(int x, ll S, int fat, int path)
{
	ans[x] += f[x];
	if (fat) ans[x] = ans[fat] - (2 * cnt[x] - n) * cost[path];
	check[x] = true;
	for (int i = head[x], k; i; i = next[i])
		if (!check[k = vis[i]]) _calc(k, S, x, i);
}

int main(int argc, char* argv[])
{
	cin >> n;
	REP(i, n) cin >> u >> v >> c, add(u, v, c), add(v, u, c);
	FOR(i, 1, n + 1)
		for (int j = head[i]; j; j = next[j])
		{
			if (vis[j] > i) continue;
			u = root(i), v = root(vis[j]);
			if (u == v) t = i;
			else zf[u] = v;
		}
	dfs(t, 0);
	CLEAR(check);
	REP(i, tt) check[prt[i]] = true;
	REP(i, tt) calc(prt[i]);
	memcpy(prt + tt, prt, tt * sizeof(*prt));
	memcpy(len + tt, len, tt * sizeof(*len));
	partial_sum(len, len + tt + tt, slen);
	sum = slen[tt - 1];
	it = tt;
	rFOR(i, tt - 1, 0)
	{
		if (slen[i - 1] > sum - slen[i - 1]) it = i, tmpr += cnt[prt[i]];
		else tmpl += cnt[prt[i]];
		_ans += cnt[prt[i]] * min(slen[i - 1], sum - slen[i - 1]);
	}
	tmpr += cnt[prt[0]];
	ans[prt[0]] = _ans;
	FOR(i, 1, tt)
	{
		_ans += (tmpr - tmpl) * len[i - 1];
		while (it < tt + i && 2 * (slen[it - 1] - slen[i - 1]) < sum)
		{
			_ans -= (sum - 2 * (slen[it - 1] - slen[i - 1])) * cnt[prt[it]];
			tmpl += cnt[prt[it]], tmpr -= cnt[prt[it++]];
		}
		tmpl -= cnt[prt[i]], tmpr += cnt[prt[i]];
		ans[prt[i]] = _ans;
	}
	sum = 0;
	REP(i, tt) sum += f[prt[i]];
	REP(i, tt) ans[prt[i]] += sum - f[prt[i]];
	CLEAR(check);
	REP(i, tt) check[prt[i]] = true;
	REP(i, tt) _calc(prt[i], ans[prt[i]], 0, 0);
	FOR(i, 1, n + 1) cout << ans[i] << " ";
}
