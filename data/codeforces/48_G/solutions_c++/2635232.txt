#include <cstdio>
#include <vector>
#include <queue>
#include <map>
#include <algorithm>

using namespace std;

typedef struct {
    vector <int> next;
    vector <int> t;
    bool onCycle;
    int size;
} planet;

typedef struct {
    vector <int> child;
    vector <int> t;
    vector <int> size;
    vector <long long> weight;
    long long total_weight;
    int total_size;
    int dp;
} cycle_planet;

int n, m;

planet p[300000];
bool found[300000];
int prev[300000];
int prev2[300000];
long long ans[300000];
bool use[300000];
int cycle_total = 0;
long long tree_total = 0;
map <pair <int, int>, int>  weight;

bool made_cycle = false;
vector <int> cycle;
cycle_planet cp[300000];


int dist[300000]; /* least distance from i to a point on the cycle */

long long cycle_dist (int i, int j)
{
    if (i == j) return 0;
    if (j < i) return cycle_dist (j, i);
    return min(cp[j].dp - cp[i].dp, cycle_total - (cp[j].dp - cp[i].dp));
}

long long right_dist (int i, int j)
{
    if (i == j) return 0;
    int d = cp[j].dp - cp[i].dp + cycle_total;
    return d % cycle_total;
}

long long left_dist (int i, int j)
{
    if (i == j) return 0;
    int d = cp[i].dp - cp[j].dp + cycle_total;
    return d % cycle_total;
}

void compute(int v, int parent)
{
    ans[v] = ans[parent] + weight[make_pair(v, parent)] * (n - 2 * (p[v].size));
    // printf("ans %d: %d\n", v, ans[v]);
    for (int i = 0; i < p[v].next.size(); i++)
    {
        int w = p[v].next[i];
        if (w == parent) continue;
        compute(w, v);
    }
}

void get_cycle(int v, int before)
{
    if (made_cycle) return;
    if (!found[v])
    {
        found[v] = true;
        for (int i = 0; i < p[v].next.size(); i++)
        {
            int w = p[v].next[i];
            if (w == before) continue;
            prev[w] = v;
            get_cycle(w, v);
        }
    }
    else
    {
        p[v].onCycle = true;
        cycle.push_back(v);
        
        int a = prev[v];
        while (a != v)
        {
            cycle.push_back(a);
            p[a].onCycle = true;
            a = prev[a];
        }
        made_cycle = true;
    }
}

int tree_size(int v, int parent)
{
    int sum = 1;
    for (int i = 0; i < p[v].next.size(); i++)
    {
        int w = p[v].next[i];
        if (w == parent) continue;
        sum += tree_size(w, v);
    }
    p[v].size = sum;
    return sum;
}

long long tree_weight(int v, int parent)
{
    long long sum = dist[v];
    for (int i = 0; i < p[v].next.size(); i++)
    {
        int w = p[v].next[i];
        if (w == parent) continue;
        sum += tree_weight(w, v);
    }
    return sum;
}

void Dijkstra (int v)
{
    dist[v] = 0;
    priority_queue < pair <int, int> > pq;
    pq.push(make_pair(-0, v));
    while (!pq.empty())
    {
        pair <int, int> next = pq.top();
        int w = next.second;
        pq.pop();
        
        if (use[w]) continue;
        use[w] = true;
        for (int i = 0; i < p[w].next.size(); i++)
        {
            int u = p[w].next[i];
            if (p[u].onCycle || use[u]) continue;
            dist[u] = min(dist[u], dist[w] + p[w].t[i]);
            pq.push(make_pair(-dist[u], u));
        }
    }
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
    {
        int a, b, t;
        scanf("%d %d %d", &a, &b, &t);
        p[a].next.push_back(b);
        p[b].next.push_back(a);
        p[a].t.push_back(t);
        p[b].t.push_back(t);
        weight[make_pair(a, b)] = t;
        weight[make_pair(b, a)] = t;
        // printf("%d %d %d\n", a, b, weight[make_pair(b, a)]);
        
        found[i] = false;
        p[i].onCycle = false;
        prev[i] = -1;
        prev2[i] = -1;
        dist[i] = (int) 1e9;
        use[i] = false;
        ans[i] = 0;
    }
    get_cycle(1, -1);
    m = cycle.size();
    // printf("cycle:\n");
    int curdp = 0;
    for (int i = 0; i < cycle.size(); i++)
    {
        // printf(" %d\n", cycle[i]);
        Dijkstra(cycle[i]);
        if (i != 0)
        {
            curdp += weight[make_pair(cycle[i], cycle[i - 1])];
            // printf("%d %d %d\n", cycle[i], cycle[i - 1], weight[make_pair(cycle[i], cycle[i - 1])]);
        }
        cp[i].total_size = 1;
        cp[i].total_weight = 0;
        cp[i].dp = curdp;
        for (int j = 0; j < p[cycle[i]].next.size(); j++)
        {
            if (p[p[cycle[i]].next[j]].onCycle)
            {
                continue;
            }
            cp[i].child.push_back(p[cycle[i]].next[j]);
            cp[i].t.push_back(p[cycle[i]].t[j]);
            cp[i].size.push_back(tree_size(p[cycle[i]].next[j], cycle[i]));
            cp[i].weight.push_back(tree_weight(p[cycle[i]].next[j], cycle[i]));
            cp[i].total_size += cp[i].size[cp[i].size.size() - 1];
            cp[i].total_weight += cp[i].weight[cp[i].weight.size() - 1];
        }
        // printf("size: %d\n", cp[i].total_size);
        // printf("total_weight: %I64d\n", cp[i].total_weight);
        // printf("dp: %d\n", cp[i].dp);
        tree_total += cp[i].total_weight;
    }
    cycle_total = curdp + weight[make_pair(cycle[0], *(cycle.end() - 1))];
    // printf("\n");
    // printf("distance\n");
    /* for (int i = 1; i <= n; i++)
    {
        printf("%d %d\n", i, dist[i]);
    } */
    // printf("cycle total: %d\n", cycle_total);
    // printf("tree total: %I64d\n", tree_total);
    /* for (int i = 0; i < cycle.size(); i++)
    {
        for (int j = 0; j < cycle.size(); j++)
        {
            printf("dist %d %d: %d\n", cycle[i], cycle[j], cycle_dist(i, j));
        }
    } */
    int left = 0;
    int right = 0;
    int index = 0;
    ans[cycle[0]] = tree_total;
    for (int i = 0; i < cycle.size(); i++)
    {
        if (i == 0)
        {
            left += cp[i].total_size;
        }
        else if (right_dist(0, i) < left_dist(0, i))
        {
            right += cp[i].total_size;
            index = i;
        }
        else
        {
            left += cp[i].total_size;
        }
        ans[cycle[0]] += cp[i].total_size * cycle_dist(0, i);
    }
    // printf("ans %d: %I64d\n", cycle[0], ans[cycle[0]]);
    // printf("%d %d %d\n", left, right, index);
    for (int i = 1; i < m; i++)
    {
        if (index == i - 1)
        {
            int swap = right;
            right = left;
            left = swap;
            ans[cycle[i]] = tree_total;
            for (int j = 0; j < m; j++)
            {
                ans[cycle[i]] += cp[j].total_size * cycle_dist(i, j);
            }
        }
        else
        {
            int t = weight[make_pair(cycle[i - 1], cycle[i])];
            ans[cycle[i]] = ans[cycle[i - 1]] + (left - right) * t;
            while (right_dist(i, (index + 1) % m) < left_dist(i, (index + 1) % m))
            {
                index = (index + 1) % m;
                right += cp[index].total_size;
                left  -= cp[index].total_size;
                ans[cycle[i]] -= (left_dist(i, index) - right_dist(i, index)) * cp[index].total_size;
            }
        } 
        right -= cp[i].total_size;
        left += cp[i].total_size;
        // printf("ans %d: %I64d\n", cycle[i], ans[cycle[i]]);
        // printf("%d %d %d\n", left, right, index);
    }
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < cp[i].child.size(); j++)
        {
            compute(cp[i].child[j], cycle[i]);
        }
    }
    for (int i = 1; i <= n; i++)
    {
        printf("%I64d ", ans[i]);
    }
    fflush(stdin);
    getchar();
}
