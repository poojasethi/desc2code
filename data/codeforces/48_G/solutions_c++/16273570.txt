#include <bits/stdc++.h>

using namespace std;

#define pb push_back
#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)
#define endl '\n'
#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)
#define mp make_pair
#define nd second
#define st first
#define type(x) __typeof(x.begin())

typedef pair < int ,int > pii;

typedef long long ll;

const long long linf = 1e18+5;
const int mod = (int) 1e9 + 7;
const int logN = 17;
const int inf = 1e9;
const int N = 2e5 + 5;

int in[N], n, x, y, z, size[N], h[N];
ll ddd[N], ans[N]; 
pii next[N], prev[N];
vector< pii > v[N];

void go(int node, int root) {
	size[node] = 1;
	foreach(it, v[node]) {
		if(!h[it->st] && root != it->st) {
			go(it->st, node);
			size[node] += size[it->st];
			ddd[node] += ddd[it->st] + size[it->st] * (ll) it->nd;
		}
	}
}

void doit(int node, int root, ll ans, int size) {
	::ans[node] = ans + ddd[node];
	foreach(it, v[node])
		if(!h[it->st] && it->st != root) {
			doit(it->st,node,ans+(size+::size[node]-::size[it->st])*(ll)it->nd+(ddd[node]-ddd[it->st]-::size[it->st]*(ll)it->nd),size+(::size[node]-::size[it->st]));
		}
}


int main() {

	scanf("%d", &n);

	FOR(i, 1, n) {
		scanf("%d %d %d", &x, &y, &z);
		v[x].pb(mp(y, z));
		v[y].pb(mp(x, z));
		in[x]++, in[y]++;
	}

	queue< int > q;
	FOR(i, 1, n)
		if(1 == in[i])
			q.push(i);

	FOR(i, 1, n) h[i] = 1;

	while(!q.empty()) {
		int node = q.front();
		h[node] = 0;
		q.pop();
		foreach(it, v[node])
			if(1 == --in[it->st]) {
				q.push(it->st);
			}
	}	
	
	int start = 1;
	
	FOR(i, 1, n) {
		if(h[i]) {
			go(i, 0);			
			start = i;
		}
	}

	int sss = start, bef = 0;
	ll ball = 0, sall = 0, all = 0;

	while(1) {
		int go = 0;
		foreach(it, v[start])
			if(h[it->st] && it->st != bef) {
				prev[it->st] = mp(start, it->nd);
				next[start] = *it;
				bef = start;
				start = it->st;
				all += it->nd;
				break;
			}
		sall += size[start];
		ball += ddd[start];
		if(start == sss) break;
	}
	
	ll ans = 0, opt = start, node = start, dist = 0, sum = 0;

	while(1) {
		if(next[node].st == start) { node = start; break; }
		dist += next[node].nd;
		ans += dist * size[next[node].st];
		node = next[node].st;
	} dist = 0;

	while(1) {
		while((prev[opt].nd + dist) * 2 <= all) {
			sum += size[prev[opt].st];
			dist += prev[opt].nd;
			ans -= size[prev[opt].st] * (ll) (all - 2 * dist);
			opt = prev[opt].st;
		}
		doit(node, 0, ans + ball - ddd[node], n - size[node]);
		ans += (n - sum) * (ll) prev[node].nd;
		ans -= (sum) * (ll) prev[node].nd;
		sum -= size[prev[node].st];
		dist -= prev[node].nd;
		node = prev[node].st;
		if(node == start) break;
	}

	FOR(i, 1, n) {
		printf("%lld ", :: ans[i]);
	} printf("\n");

	return 0;
}
