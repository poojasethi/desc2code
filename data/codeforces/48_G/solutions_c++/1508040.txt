#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>
using namespace std;

const int maxn = 200000 + 10;
int n;
int deg[maxn];
bool onCircle[maxn];
bool visit[maxn];
struct edge {
	int t, c;
	edge (int _t, int _c):
		t(_t), c(_c){}
};
vector<edge> E[maxn];
typedef vector<edge>::iterator vet;
typedef long long int64;
int size[maxn];
int64 ans[maxn], w[maxn];

void dfs(int x) {
	visit[x] = true, size[x] = 1, w[x] = 0;
	for (vet e = E[x].begin(); e != E[x].end(); ++e)
		if (!onCircle[e->t] && !visit[e->t]) {
			dfs(e->t);
			size[x] += size[e->t];
			w[x] += e->c * size[e->t] + w[e->t];
		}
}

void findCircle() {
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i) {
		int s, t, c;
		scanf("%d%d%d", &s, &t, &c);
		E[s].push_back(edge(t, c));
		E[t].push_back(edge(s, c));
		++deg[s];
		++deg[t];
	}
	static int q[maxn], r = 0;
	for (int i = 1; i <= n; ++i)
		if (deg[i] == 1)
			q[r++] = i;
	memset(onCircle, 1, sizeof(onCircle));
	memset(visit, 0, sizeof(visit));
	for (int i = 0; i < r; ++i) {
		int x = q[i];
		onCircle[x] = false;
		visit[x] = true;
		for (vet e = E[x].begin(); e != E[x].end(); ++e)
			if (!visit[e->t]) {
				--deg[e->t];
				if (deg[e->t] == 1)
					q[r++] = e->t;
			}
	}
	memset(visit, 0, sizeof(visit));
	for (int i = 1; i <= n; ++i)
		if (onCircle[i])
			dfs(i);
}

void getWeight() {
	vector<int> cur(1, 0), Len(1, 0);
	memset(visit, 0, sizeof(visit));
	int sumDist = 0, m;
	for (int i = 1, j; i <= n; ++i)
		if (onCircle[i]) {
			cur.push_back(i);
			visit[i] = true;
			for (j = i; ;) {
				bool flag = false;
				for (vet e = E[j].begin(); e != E[j].end(); ++e)
					if (onCircle[e->t] && !visit[e->t]) {
						cur.push_back(e->t);
						Len.push_back(e->c);
						sumDist += e->c;
						visit[j = e->t] = true;
						flag = true;
						break;
					}
				if (!flag)
					break;
			}
			for (vet e = E[j].begin(); e != E[j].end(); ++e)
				if (e->t == i) {
					sumDist += e->c;
					Len.push_back(e->c);
					break;
				}
			break;
		}
	m = cur.size() - 1;
	#define NEXT(i) (i == m ? 1 : i + 1)
	int64 value = 0;
	int i = 1, j = 1, k, nowSize = 0, nowDist = 0, temp;
	for (temp = 0; temp + Len[j] < sumDist - (temp + Len[j]); ++j)
		temp += Len[j];
	nowSize = size[cur[1]];
	for (k = 2; k <= j; ++k) {
		nowDist += Len[k - 1];
		nowSize += size[cur[k]];
	}
	for (k = 1, temp = 0; k <= m; ++k) {
		temp += Len[k - 1];
		value += min(temp, sumDist - temp) * size[cur[k]] + w[cur[k]];
	}
	ans[cur[1]] = value;
	for (i = 2; i <= m; ++i) {
		nowDist -= Len[i - 1];
		nowSize -= size[cur[i - 1]];
		value -= nowSize * Len[i - 1];
		value += (n - nowSize) * Len[i - 1];
		for (; nowDist + Len[j] < sumDist - (nowDist + Len[j]); j = NEXT(j)) {
			nowSize += size[cur[NEXT(j)]];
			nowDist += Len[j];
			value += nowDist * size[cur[NEXT(j)]];
			value -= (sumDist - nowDist) * size[cur[NEXT(j)]];
		}
		ans[cur[i]] = value;
	}
}

void dfs(int x, int64 v) {
	visit[x] = true;
	ans[x] = v;
	for (vet e = E[x].begin(); e != E[x].end(); ++e)
		if (!onCircle[e->t] && !visit[e->t])
			dfs(e->t, v - size[e->t] * e->c + (n - size[e->t]) * e->c);
}

void getAnswer() {
	memset(visit, 0, sizeof(visit));
	for (int i = 1; i <= n; ++i)
		if (onCircle[i])
			dfs(i, ans[i]);
	for (int i = 1; i <= n; ++i)
		printf("%I64d%c", ans[i], i < n ? ' ' : '\n');
}

int main() {
	//freopen("x.in", "r", stdin);
	findCircle();
	getWeight();
	getAnswer();
}
