#include<stdio.h>
#include<iostream>
#include<queue>
#include<stack>
#include<list>
#include<vector>
#include<map>
#include<set>
#include<cmath>
#include<string.h>
#include<algorithm>
#define SF scanf
#define S1(a) SF("%d",&a);
#define S2(a,b) SF("%d%d",&a,&b);
#define S3(a,b,c) SF("%d%d%d",&a,&b,&c);
#define PF printf
#define P1(a) PF("%d ",a);
#define P2(a,b) PF("%d %d ",a,b);
#define P3(a,b,c) PF("%d %d %d ",a,b,c);
#define EL PF("\n");
#define PII pair<int,int>
#define MII map<int,int>
#define LL long long
#define MP make_pair
#define IB push_back
#define IF push_front
#define DB pop_back()
#define DF pop_front()
#define FI first
#define SC second
#define QT Q.top()
#define QF Q.front()
#define QB Q.back()
#define QS Q.size()
#define ST S.top()
#define SS S.size()
using namespace std;

int i,n,m,l,r,mid,ml=0,chk,ans=0;
struct line{
    int x,y,l;
    bool operator <(line z)const{
        return y<z.y;
    }
}v[50005],h[50005];
struct event{
    int x,y;
    int t;//1-in 2-out
    bool operator <(event z)const{
        if(y!=z.y){
            return y>z.y;
        }
        else{
            return t>z.t;
        }
    }
}t;
set<int> S;
priority_queue<event> Q;

int isExist(int len){
    while(!Q.empty()){
        Q.pop();
    }
    S.clear();
    for(i=1;i<=n;i++){
        if(v[i].l>=2*len){
            t.x=v[i].x;
            t.y=v[i].y+len;
            t.t=1;
            Q.push(t);
            t.y=v[i].y+v[i].l-len;
            t.t=2;
            Q.push(t);
        }
    }
    for(i=1;i<=m;i++){
        if(h[i].l<2*len){
            continue;
        }
        while( !Q.empty() and ( QT.y<h[i].y or (QT.y==h[i].y and QT.t==1) ) ){
            if(QT.t==1){
                S.insert(QT.x);
            }
            else{
                S.erase(QT.x);
            }
            Q.pop();
        }
        if( S.lower_bound(h[i].x+len) != S.upper_bound(h[i].x+h[i].l-len) ){
            return 1;
        }
    }
    return 0;
}

int main(){
    S2(n,m);
    for(i=1;i<=n;i++){
        S3(v[i].x,v[i].y,v[i].l);
        ml=max(ml,v[i].l/2);
    }
    for(i=1;i<=m;i++){
        S3(h[i].x,h[i].y,h[i].l);
        ml=max(ml,h[i].l/2);
    }
    sort(h+1,h+m+1);
    l=1; r=ml;
    while(l<=r){
        mid=(l+r)/2;
        if(isExist(mid)){
            l=mid+1;
            ans=max(ans,mid);
        }
        else{
            r=mid-1;
        }
    }
    P1(ans);
    return 0;
}
