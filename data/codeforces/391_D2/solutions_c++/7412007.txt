/*
    Author: Zhouxing Shi
    Created on Aug 9, 2014
*/
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <queue>
#include <set>
#include <cstdlib>
#include <ctime>
#include <map>
#include <string>
#include <stack>
#include <complex>
#include <bitset>
#include <iostream>
#include <iomanip>
#define rep(i, a, b) for (int i = (a); i <= (b); ++i)
#define drep(i, a, b) for (int i = (a); i >= (b); --i)
#define REP(i, a, b) for (int i = (a); i < (b); ++i)
#define pb(x) push_back(x)
#define mp(x, y) (make_pair(x, y))
#define clr(x) memset(x, 0, sizeof(x))
#define xx first
#define yy second

using namespace std;

typedef long long ll;
typedef long long llu;
typedef unsigned long long ull;
typedef long double ld;
typedef pair<int, int> pii;
typedef complex<double> cdb;
const int inf = ~0U >> 1;
const ll INF = ~0ULL >> 1;;
const double pi = acos(-1.0);
template <class T> inline T sqr(T a) { return a * a; }
template <class T> inline void read(T &n)
{
    char c;
	for (c = getchar(); !(c >= '0' && c <= '9'); c = getchar()); n = c - '0';
    for (c = getchar(); c >= '0' && c <= '9'; c = getchar()) n = n * 10 + c - '0';
}
int pw(int base, int n, int mo)
{
	if (n == 0) return 1;
	if (n == 1) return base;
	int tmp = pw(base, n >> 1, mo);
	tmp = (ll)tmp * tmp % mo;
	if (n & 1) tmp = (ll)tmp * base % mo;
	return tmp;
}
struct point
{
	int x, y;
	point(){}
	point(int _x, int _y) : x(_x), y(_y) {}
} ;

//***************************

const int maxn = 200000;

int N;

struct seg
{
	int c, x, y;
	seg(){}
	seg(int _c, int _x, int _y) : c(_c), x(_x), y(_y) {}
} ;

struct event
{
	int Time, id, ty;
	event(){}
	event(int _Time, int _id, int _ty) : Time(_Time), id(_id), ty(_ty) {}
} ;

struct line
{
	int x1, y1, x2, y2;
	line(){}
	line(int _x1, int _y1, int _x2, int _y2) : x1(_x1), y1(_y1), x2(_x2), y2(_y2) {}
} ;

namespace Cross
{
	seg a[maxn];
	event e[maxn * 2];
	line A[maxn], B[maxn];
	int n1, n2, n;
	set<pair<int, int> > S;
	
	bool cmp(const event &a, const event &b)
	{
		return (a.Time < b.Time) || (a.Time == b.Time && a.ty < b.ty);
	}
	
	int check(int K)
	{
		 n = 0;
		 rep(i, 1, n1) e[++n] = event(A[i].x1, i, 2);
		 rep(i, 1, n2)
		 	if (B[i].x1 + K <= B[i].x2 - K) 
			{
				e[++n] = event(B[i].x1 + K, i, 1);
		 		e[++n] = event(B[i].x2 - K, i, 3);
		 	}
		 sort(e + 1, e + n + 1, cmp);
		 S.clear();
		 rep(i, 1, n)
		 	if (e[i].ty == 2)
		 	{
		 		set<pair<int, int> > :: iterator itr = S.lower_bound(mp(A[e[i].id].y1 + K, 0));
		 		if (itr == S.end()) continue;
		 		if ((*itr).xx <= A[e[i].id].y2 - K) return 1;
		 	}
		 	else if (e[i].ty == 1)
		 	{
		 		S.insert(mp(B[e[i].id].y1, e[i].id));
		 	}
		 	else
		 	{
		 		set<pair<int, int> > :: iterator itr = S.find(mp(B[e[i].id].y1, e[i].id));
		 		S.erase(itr);
		 	}
		return 0;
	}
	
	int main()
	{
		scanf("%d%d", &n1, &n2);
		rep(i, 1, n1)
		{
			int x, y, l;
			scanf("%d%d%d", &x, &y, &l);
			A[i] = line(x, y, x, y + l);
		}
		rep(i, 1, n2)
		{
			int x, y, l;
			scanf("%d%d%d", &x, &y, &l);
			B[i] = line(x, y, x + l, y);
		}
		/*scanf("%d", &N);
		rep(i, 1, N)
		{
			int x1, y1, x2, y2;
			scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
			if (x1 == x2)
			{
				if (y1 > y2) swap(y1, y2);
				A[++n1] = line(x1, y1, x2, y2);
			}
			else 
			{
				if (x1 > x2) swap(x1, x2);
				B[++n2] = line(x1, y1, x2, y2);
			}
		}
		*/
		int l = 0, r = 1000000000;
		while (l + 1 < r)
		{
			int m = l + r >> 1;
			if (check(m)) l = m;
			else r = m - 1;
		}
		if (check(r)) l = r;
		if (!check(l) || l == 0) puts("0");//puts("Human intelligence is really terrible");
		else printf("%d\n", l);
	}
}

int main()
{    

	Cross::main();
	return 0;
}
