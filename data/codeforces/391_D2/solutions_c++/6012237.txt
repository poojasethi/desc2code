//Done by Mycroft Grey
//Fet per Ferran Alet

#include<iostream>
#include<cmath>
#include<iomanip>
#include<vector>
#include<map>
#include<queue>
#include<fstream>
#include<algorithm>
#include<string>
#include<stack>
#include<numeric>
#include<set>
#include<sstream>
#include<list>

#define INF 2147483647
#define LINF 1000000000000000000LL
#define EPS 1e-9
#define debug(x) cerr << #x << " = " << x << endl
#define Debug(v) cerr << #v << " = "; for(int wow=0;wow<v.size();++wow) cerr<<v[wow]<<' '; cerr<<endl
#define FOR(x,y) for(int x=0;x<y;x++)
#define FORU(x,y) for(int x=1;x<=y;x++)
#define RFOR(x,y) for(int x=y-1;x>=0;--x)
using namespace std;


typedef long long ll;
typedef pair<int,int> PII;
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef vector<double> VD;
typedef vector<VD> VVD;
typedef vector<bool> VB;
typedef vector<VB> VVB;
typedef vector<string> VS;
typedef map<int,int> MII;
typedef MII::iterator iMII;
typedef vector<PII > VP;

struct Event{
  int x;
  int yn; //North
  int ys; //South
  int tipus;
};

bool operator <(const Event &a, const Event &b){
  if(a.x!=b.x) return a.x<b.x;
  else return a.tipus<b.tipus;
}

vector<Event> v;

int main(){
  ios_base::sync_with_stdio(false);
  int n,m;
  cin>>n>>m;
  VI xv(n), yv(n), lv(n);
  VI xh(m), yh(m), lh(m);
  FOR(i,n) cin>>xv[i]>>yv[i]>>lv[i];
  FOR(i,m) cin>>xh[i]>>yh[i]>>lh[i];
  int low=0,high=1e9;
  while(high-low>1){
    int mig=(high+low)>>1;
    v.clear();
    FOR(i,n){
      if(lv[i]>=2*mig){
        Event e;
        e.yn=yv[i]+lv[i]-mig;
        e.ys=yv[i]+mig;
        e.x=xv[i];
        e.tipus=1;
        v.push_back(e);
      }
    }
    FOR(i,m){
      if(lh[i]>=2*mig){
        Event e;
        e.yn=yh[i];
        e.x = xh[i]+mig;
        e.tipus=0;
        v.push_back(e);
        e.x= xh[i]+lh[i]-mig;
	e.tipus=2;
        v.push_back(e);
      }
    }
  //  debug(v.size());
    sort(v.begin(),v.end());
    int vs=v.size();
    multiset <int> S;
    multiset <int>::iterator it;
    bool trobat=false;
    FOR(i,vs){
    //  cerr<<v[i].tipus<<": "<<v[i].x<<' '<<v[i].yn<<' '<<v[i].ys<<endl;
      if(v[i].tipus==0) S.insert(v[i].yn);
      if(v[i].tipus==1){
	it = S.lower_bound(v[i].ys); //Busco el punt de mínima alçada amb alçada mínim yn
        if (it != S.end()){
          if ((*it) <= v[i].yn) { //Si existeix i és menor a ys, xoquen!
            trobat = true;
            break;
          }
	}
      }
      if(v[i].tipus==2) S.erase(v[i].yn);
    }
    if(trobat) low=mig;
    else high=mig;
  }
  cout<<low<<endl;
}