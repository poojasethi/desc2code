#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
using namespace std;

struct point
{
	int x, y, type, query; //0 = H open, 1 = V open, 2 = V close, 3 = H close

	point(int x, int y, int type, int query)
		: x(x), y(y), type(type), query(query) { }

	bool operator<(point const& p) const
	{
		if (x == p.x)
			return type < p.type;
		return x < p.x;
	}
};

int N, M;
int V[50005][3];
int H[50005][3];

bool possible(int len)
{
	vector<point> P;
	for (int i = 0; i < N; i++)
	{
		if (2*len > V[i][2])
			continue;

		P.push_back(point(V[i][0], V[i][1]+len, 1, -1));
		P.push_back(point(V[i][0], V[i][1]+V[i][2]-len, 2, V[i][1]+len));
	}
	for (int i = 0; i < M; i++)
	{
		if (2*len > H[i][2])
			continue;

		P.push_back(point(H[i][0]+len, H[i][1], 0, -1));
		P.push_back(point(H[i][0]+H[i][2]-len, H[i][1], 3, -1));
	}

	sort(P.begin(), P.end());

	multiset<pair<int, int> > bst;
	for (int i = 0; i < P.size(); i++)
	{
		point cur = P[i];
		if (cur.type == 0)
			bst.insert(make_pair(cur.y, 1));
		else if (cur.type == 3)
			bst.erase(make_pair(cur.y, 1));
		else if (cur.type == 1)
			bst.insert(make_pair(cur.y, 0));
		else
		{
			multiset<pair<int, int> >::iterator it = bst.find(make_pair(cur.query, 0));
			it++;
			if (it != bst.end() && (*it).first <= cur.y)
				return true;
			bst.erase(--it);
		}
	}

	return false;
}

int main()
{
	cin >> N >> M;
	for (int i = 0; i < N; i++)
		cin >> V[i][0] >> V[i][1] >> V[i][2];
	for (int i = 0; i < M; i++)
		cin >> H[i][0] >> H[i][1] >> H[i][2];

	int lo = 0, hi = 50000000;
	while (lo < hi)
	{
		int mid = lo + (hi-lo+1)/2;
		if (possible(mid))
			lo = mid;
		else
			hi = mid - 1;
	}

	cout << lo << "\n";

	return 0;
}