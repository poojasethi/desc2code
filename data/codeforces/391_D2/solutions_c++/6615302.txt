#include <algorithm>
#include <iostream>
#include <sstream>
#include <cassert>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <string>
#include <vector>
#include <bitset>
#include <queue>
#include <stack>
#include <cmath>
#include <deque>
#include <ctime>
#include <list>
#include <set>
#include <map>
//zlb//

using namespace std;

typedef long long     LL;
typedef pair<LL,LL> pii;

double PI  = acos(-1);
double EPS = 1e-7;
LL INF    = 1000000000;
LL MOD    = 1000000007;
LL MAXINT = 2147483647;
LL INFLL   = 1000000000000000000LL;
LL MAXLL   = 9223372036854775807LL;

#define fi            first
#define se            second
#define mp            make_pair
#define pb            push_back
#define SIZE(a)       (LL)a.size()
#define MIN(a, b)     (a) = min((a), (b))
#define MAX(a, b)     (a) = max((a), (b))
#define input(in)     freopen(in,"r",stdin)
#define output(out)   freopen(out,"w",stdout)
#define RESET(a, b)   memset(a,b,sizeof(a))
#define FOR(a, b, c)  for (LL (a)=(b); (a)<=(c); (a)++)
#define FORD(a, b, c) for (LL (a)=(b); (a)>=(c); (a)--)
#define FORIT(a, b)   for (__typeof((b).begin()) a=(b).begin(); a!=(b).end(); a++)

LL mx[8] = {-1,1,0,0,-1,-1,1,1};
LL my[8] = {0,0,-1,1,-1,1,-1,1};

// ------------ //

struct node
{
	LL maks;
	node *l,*r;
};

pair<pii,LL> p[50005];
pair<pii,LL> q[50005];

node *root;

void clear(node *&cur=root)
{
	if (cur == NULL) return;
	clear(cur->l);
	clear(cur->r);
	delete cur;
}

LL val(node *cur)
{
	if (cur == NULL) return 0;
	else return cur->maks;
}

void update(LL p,LL v,node *&cur=root,LL l=0,LL r=2000000001)
{
	//if (l == 0 && r == 2*INF+1) cout << "upd " << p-(INF+1) << " " << v-(INF+1) << endl;
	if (cur == NULL)
	{
		cur = new node;
		cur->l = NULL;
		cur->r = NULL;
		cur->maks = 0;
	}
	if (l == r)
	{
		MAX(cur->maks,v);
		return; 
	}
	LL m = ((LL)l+(LL)r)/(LL)2;
	if (p <= m) update(p,v,cur->l,l,m);
	else update(p,v,cur->r,m+1,r);
	cur->maks = max(val(cur->l),val(cur->r));
}

LL query(LL fl,LL fr,node *cur=root,LL l=0,LL r=2000000001)
{
	//if (l == 0 && r == 2*INF+1) cout << "que " << fl-(INF+1) << " " << fr-(INF+1) << endl;
	if (fl > r || fr < l || fl > fr) return 0;
	if (cur == NULL) return 0;
	if (fl <= l && r <= fr)
	{
		return cur->maks;
	}
	LL m = ((LL)l+(LL)r)/(LL)2;
	return max(query(fl,fr,cur->l,l,m),query(fl,fr,cur->r,m+1,r));
}

int main()
{
	LL n,m;
	scanf("%I64d%I64d",&n,&m);
	FOR(a,1,n)
	{
		scanf("%I64d%I64d%I64d",&p[a].fi.fi,&p[a].fi.se,&p[a].se);
		p[a].fi.fi+=(INF+1);
		p[a].fi.se+=(INF+1);
	}
	sort(p+1,p+n+1);
	FOR(a,1,m)
	{
		scanf("%I64d%I64d%I64d",&q[a].fi.fi,&q[a].fi.se,&q[a].se);
		q[a].fi.fi+=(INF+1);
		q[a].fi.se+=(INF+1);
	}
	sort(q+1,q+m+1);
	LL l = 1;
	LL r = INF;
	LL ans = 0;
	while(l <= r)
	{
		LL mid = (l+r)/2;
		bool valid = 0;
		LL it = 1;
		root = NULL;
		FOR(b,1,n)
		{
			//cout << "yow " << q[it].fi.fi-(INF+1) << " " << mid << " " << p[b].fi.fi-(INF+1) << endl;
			while(it <= m && q[it].fi.fi+mid <= p[b].fi.fi)
			{
				update(q[it].fi.se,q[it].fi.fi+q[it].se);
				it++;
			}
			valid |= (query(p[b].fi.se+mid,p[b].fi.se+p[b].se-mid) >= p[b].fi.fi+mid);
		}
		clear();
		if (valid)
		{
			MAX(ans,mid);
			l = mid+1;
		}
		else r = mid-1;
	}
	printf("%I64d\n",ans);
}
