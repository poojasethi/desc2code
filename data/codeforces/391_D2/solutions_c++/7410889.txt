#include <cstdio>
#include <algorithm>
using namespace std;

int n, cnt;

struct seg
{
	int x1, y1, x2, y2, ly1, ly2;
} s[100005];

struct num
{
	int val, belong;
} nm[200005];

struct node
{
	node *lc, *rc;
	int l, r, mx;
	bool clear;
} *root;

bool cmp(seg s1, seg s2)
{
	return min(s1.x1, s1.x2) < min(s2.x1, s2.x2);
}

bool cmpnm(num n1, num n2)
{
	return n1.val < n2.val;
}

void build (node *&cur, int l, int r)
{
	cur = new node;
	cur->l = l;
	cur->r = r;
	cur->mx = -1000000000;
	cur->clear = false;
	if (l == r)
	{
		cur->lc = cur->rc = NULL;
		return;
	}
	int mid = (l + r) >> 1;
	build(cur->lc, l, mid);
	build(cur->rc, mid + 1, r);
}

void pushdown(node *cur)
{
	if (cur->clear)
	{
		cur->lc->clear = true;
		cur->rc->clear = true;
		cur->lc->mx = -1000000000;
		cur->rc->mx = -1000000000;
		cur->clear = false;
	}
}

int query(node *cur, int l, int r)
{
	if (l > r) return -1000000000;
	if (l == cur->l && r == cur->r)	return cur->mx;
	pushdown(cur);
	int mid = (cur->l + cur->r) / 2;
	if (r <= mid) return query(cur->lc, l, r);
	if (l > mid) return query(cur->rc, l, r);
	return max(query(cur->lc, l, mid) , query(cur->rc, mid + 1, r));
}

int notlarger(int x)
{
	int l = 0, r = cnt + 1, mid;
	nm[0].val = -1000000000;
	while (l + 1 < r)
	{
		mid = (l + r) >> 1;
		if (nm[mid].val <= x) l = mid;
		else r = mid;
	}
	return l;
}

int less(int x)
{
	int l = 0, r = cnt + 1, mid;
	nm[0].val = -1000000000;
	while (l + 1 < r)
	{
		mid = (l + r) >> 1;
		if (nm[mid].val < x) l = mid;
		else r = mid;
	}
	return l;
}

void add(int pos, int val, node *cur)
{
	if (cur->l == cur->r)
	{
		cur->mx = max(cur->mx, val);
		return;
	}
	pushdown(cur);
	int mid = (cur->l + cur->r) >> 1;
	if (pos <= mid) add (pos, val,cur->lc);
	else  add (pos, val,cur->rc);
	cur->mx = max(cur->lc->mx, cur->rc->mx);
}

int m;

int main()
{
	//freopen("cross.in", "r", stdin);
	//freopen("cross.out", "w", stdout);
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n + m; i++)
	{
		int x, y, l;
		scanf("%d%d%d", &x, &y, &l);
		if (i <= n)
		{
			s[i].x1 = s[i].x2 = x;
			s[i].y1 = y; s[i].y2 = y + l;
		}
		else
		{
			s[i].x1 = x; s[i].x2 = x + l;
			s[i].y1 = s[i].y2 = y;
		}
		//if (s[i].x1 > s[i].x2) swap(s[i].x1, s[i].x2);
		//if (s[i].y1 > s[i].y2) swap(s[i].y1, s[i].y2);
	}
	n += m;
	sort(s + 1, s + n + 1, cmp);
	for (int i = 1; i <= n; i++)
	{
		s[i].ly1 = 0;
		nm[i * 2 - 1].val = s[i].y1; nm[i * 2 - 1].belong = i;
		nm[i * 2].val = s[i].y2; nm[i * 2].belong = i;
	}
	sort(nm + 1, nm + 2 * n + 1, cmpnm);
	for (int i = 1; i <= 2 * n; i++)
	{
		if (i == 1 || nm[i].val != nm[i - 1].val) cnt++;
		nm[cnt] = nm[i];
		if (s[nm[i].belong].ly1 == 0) s[nm[i].belong].ly1 = cnt;
		else s[nm[i].belong].ly2 = cnt;
	}
	build(root, 1, cnt);
	int l = 0, r = 1000000000, mid;
	s[n + 1].x1 = 1000000000;
	while (l + 1 < r)
	{
		mid = (l + r) >> 1;
		root->clear = true;
		root->mx = -1000000000;
		bool can = false;
		int lpoint = 0, rpoint = 1;
		for (;;)
		{
			do
			{
				lpoint++;
				if (lpoint > n)	break;
			}
			while (s[lpoint].x1 == s[lpoint].x2);
			while (s[rpoint].x1 < s[lpoint].x1 + mid)
			{
				if (s[rpoint].x1 == s[rpoint].x2)
				{
					int tmp = query(root, less(s[rpoint].y1 + mid) + 1,
					notlarger(s[rpoint].y2 - mid));
					if (tmp >= s[rpoint].x1 + mid)
					{
						can = true;
						break;
					}
				}
				rpoint++;
				if (rpoint > n) break;
			}
			if (can) break;
			if (lpoint > n || rpoint > n) break;
			add(s[lpoint].ly1, s[lpoint].x2, root);
		}
		if (can) l = mid;
		else r = mid;
	}
	printf("%d\n", l);
}
