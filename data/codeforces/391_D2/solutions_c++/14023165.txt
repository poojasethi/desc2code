#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pii pair<int,int>
#define pll pair<ll,ll>
#define pdd pair<double,double>
#define X first
#define Y second
#define REP(i,a) for(int i=0;i<a;++i)
#define REPP(i,a,b) for(int i=a;i<b;++i)
#define FILL(a,x) memset(a,x,sizeof(a))
#define	foreach( gg,itit )	for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )
#define	mp make_pair
#define	pb push_back

inline int max(int a,int b){return a<b?b:a;}
inline int min(int a,int b){return a>b?b:a;}
inline ll max(ll a,ll b){return a<b?b:a;}
inline ll min(ll a,ll b){return a>b?b:a;}
const int mod = 1e9+7;
const int N = 1e6+10;
const ll INF = 1e18;

//#define DEBUG

#ifdef DEBUG
#define dprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)
#else
#define dprintf(fmt,...)
#endif

pair<pii,int> H[N],V[N];
pair<pii,pll> up[N];
pll arr[N];
int pl[N];
ll tree[6*N];
int n,m;
void upd(int C,int S,int E,int s,ll v){
  if(s<S||s>E) return;
  if(s==S&&s==E){
    tree[C]=v;
    return;
  }
  int m=(S+E)/2;
  upd(C*2,S,m,s,v); upd(C*2+1,m+1,E,s,v);
  tree[C]=min(tree[C*2],tree[C*2+1]);
}
ll q(int C,int S,int E,int s, int e){
  if(s>E||e<S) return INF;
  if(s<=S&&E<=e){
    return tree[C];
  }
  int m=(S+E)/2;
  return min(q(C*2,S,m,s,e),q(C*2+1,m+1,E,s,e));
}
int calc(int t){
  if(t==0) return 1;
  int h=0,h1=0;

  REP(i,n){
     int x,y1,y2; x=V[i].X.X,y1=V[i].X.Y;y2=y1+V[i].Y;
     y1+=t; y2-=t;
     if(y1<=y2){
       up[h++]=mp(mp(y1,-1),mp(y1,i));
       up[h++]=mp(mp(y2,1),mp(INF,i));
  //     printf("g%d %d %d %d\n",t,x,y1,y2);
     }
     arr[i]=mp(x,i);
  }
  REP(i,m){
    int y,x1,x2; x1=H[i].X.X;y=H[i].X.Y;x2=x1+H[i].Y;
    x1+=t;x2-=t;
    if(x1<=x2){
      up[h++]=mp(mp(y,0),mp(x1,x2));
    //  printf("gh%d %d %d %d\n",t,y,x1,x2);
    }
  }
  REP(i,6*n+6) tree[i]=INF;
  sort(arr,arr+n);
  sort(up,up+h);
  REP(i,n) pl[arr[i].Y]=i;
  REP(i,h){
    if(up[i].X.Y==0){
      int x1=upper_bound(arr,arr+n,mp(up[i].Y.X,-(ll)mod))-arr,x2=upper_bound(arr,arr+n,mp(up[i].Y.Y,(ll)mod))-arr;
      if(x2==0) continue;x2--;
      ll y=q(1,0,n,x1,x2);
      if(y<=up[i].X.X) return 1;
  //    printf("gh%d %lld %d %d\n",t,y,x1,x2);
    }else{
      upd(1,0,n,pl[up[i].Y.Y],up[i].Y.X);
//      printf("x\n");
    }
  }
  return 0;
}
int main(){
  scanf("%d%d",&n,&m);

  REP(i,n){
    scanf("%d%d%d",&V[i].X.X,&V[i].X.Y,&V[i].Y);
  }
  REP(i,m){
    scanf("%d%d%d",&H[i].X.X,&H[i].X.Y,&H[i].Y);
  }
  int l=0,r=mod;
  while(l<r){
    int m=(l+r)/2;
    if(calc(m+1)) l=m+1;
    else r=m;
  }
  printf("%d\n",l);
  return 0;
}
