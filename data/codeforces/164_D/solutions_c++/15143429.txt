#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <vector>
using namespace std;
const int maxn=1100;
typedef vector<int> vecI;
int n,K,m,D[maxn*maxn];
struct Tpnt{
	int x,y;
}A[maxn];

inline int sqr(int x){return x*x;}
inline int dist(const Tpnt &a,const Tpnt &b){
	return sqr(a.x-b.x)+sqr(a.y-b.y);
}

namespace Ninit{
	void init(){
		int i,j;
		scanf("%d%d",&n,&K);
		for(i=1;i<=n;++i)
			scanf("%d%d",&A[i].x,&A[i].y);
		for(i=1;i<n;++i)
		for(j=i+1;j<=n;++j)
			D[m++]=dist(A[i],A[j]);
		sort(D,D+m),m=unique(D,D+m)-D;
	}
}

namespace Nsolve{
	namespace Ncheck{
		int U[maxn];vecI E[maxn];
		bool dfs(int x,int R){
			int i,k;vecI::iterator p;
			if(x>n)return true;
			if(E[x].empty() || U[x]<=n)return dfs(x+1,R);
			{
				for(k=0,p=E[x].begin();p!=E[x].end();++p)
					k+=(U[*p]==n+1?(U[*p]=x,1):0);
				if(R>=k && dfs(x+1,R-k))return true;
				for(p=E[x].begin();p!=E[x].end();++p)
					U[*p]==x?U[*p]=n+1:0;
				if(k<2)return false;
			}
			{
				U[x]=x;if(R && dfs(x+1,R-1))return true;U[x]=n+1;
			}
			return false;
		}
		bool Chk(int Lmt){
			int i,j;
			for(i=1;i<=n;++i)E[i].clear(),U[i]=n+1;
			for(i=1;i<n;++i)
			for(j=i+1;j<=n;++j)
				if(dist(A[i],A[j])>Lmt)E[i].push_back(j);
			return dfs(1,K);
		}
	}
	using Ncheck::Chk;
	void solve(){
		int i,l,r,mid;
		for(l=-1,r=m-1;l+1<r;Chk(D[mid])?r=mid:l=mid)mid=l+r>>1;
		for(Chk(D[r]),i=1;i<=n;++i)
			if(Ncheck::U[i]<=n)printf("%d ",i),--K;
		for(i=1;K && i<=n;++i)
			if(Ncheck::U[i]>n)printf("%d ",i),--K;
		printf("\n");
	}
}

int main(){
	//freopen("A.in","r",stdin);
	Ninit::init();
	Nsolve::solve();
	return 0;
}
