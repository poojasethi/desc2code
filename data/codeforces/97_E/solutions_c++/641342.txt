#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>

using namespace std;

#define MAXN 200010
#define MAXM 400010

struct Edge {
	int v;
	Edge *link;
}edge[MAXM * 2], *adj[MAXN], *tree[MAXN * 2];

int totE, con, root, currT, top, top1;
int totCut, totBi;
int dep[MAXN], deps[MAXN], num[MAXN], dfn[MAXN], lowlink[MAXN], cut[MAXN], bi[MAXN], color[MAXN];
int temp[MAXN], st1[MAXN], st2[MAXN], st3[MAXN], st4[MAXN], f[MAXN * 2];
int used[MAXN * 2], odd[MAXN * 2];
int fa[MAXN][20];
int LOG[MAXN];

void addEdge(int u, int v) {
	Edge *p = &edge[totE++];
	p->v = v; p->link = adj[u]; adj[u] = p;
}

void addTree(int u, int v) {
//	printf("%d %d\n", u, v);
	Edge *p = &edge[totE++];
	p->v = v; p->link = tree[u]; tree[u] = p;
}

void dfs(int u, int pre) {
	dep[u] = dep[pre] + 1;
	dfn[u] = lowlink[u] = ++currT;
	num[u] = con;
	Edge *p = adj[u];
	int cnt = 0;
	bool flag = false;
	while(p) {
		if(!dfn[p->v]) {
			++cnt;
			dfs(p->v, u);
			lowlink[u] = min(lowlink[u], lowlink[p->v]);
			if(lowlink[p->v] >= dfn[u]) flag = true;
		}
		else if(p->v != pre)
			lowlink[u] = min(lowlink[u], dfn[p->v]);
		p = p->link;
	}
	if(flag && (u != root || cnt > 1)) cut[u] = ++totCut;
}

bool dfs2(int u) {
	Edge *p = adj[u];
	while(p) {
		if(bi[p->v] == totBi) {
			if(color[p->v] == -1) {
				color[p->v] = !color[u];
				if(!dfs2(p->v)) return false;
			}
			else if(color[p->v] == color[u]) return false;
		}
		p = p->link;
	}
	return true;
}

void solve() {
	++totBi;
	int cnt = 0;
	for(int i = 0; i < top1; ++i) {
		int u = st3[i], v = st4[i];
		bi[u] = totBi;
		bi[v] = totBi;
		color[u] = color[v] = -1;
		if(cut[u]) temp[cnt++] = cut[u];
		if(cut[v]) temp[cnt++] = cut[v];
	}

	sort(temp, temp + cnt);
	for(int i = 0; i < cnt; ++i)
		if(i == 0 || temp[i] != temp[i - 1]) {
			addTree(temp[i], totCut + totBi);
			addTree(totCut + totBi, temp[i]);
		}

	color[st3[0]] = 0;
	odd[totBi] = !dfs2(st3[0]);
}

void dfs1(int u, int pre) {
	dfn[u] = lowlink[u] = ++currT;
	Edge *p = adj[u];
	while(p) {
		if(!dfn[p->v]) {
			st1[top] = u;
			st2[top++] = p->v;
			dfs1(p->v, u);
			lowlink[u] = min(lowlink[u], lowlink[p->v]);
			if(lowlink[p->v] >= dfn[u]) {
				top1 = 0;
				while(true) {
					--top;
					st3[top1] = st1[top];
					st4[top1++] = st2[top];
					if(st1[top] == u && st2[top] == p->v) break;
				}
				solve();
			}
		}
		else {
			if(dfn[u] > dfn[p->v] && p->v != pre) {
				st1[top] = u;
				st2[top++] = p->v;
			}
			if(p->v != pre) lowlink[u] = min(lowlink[u], dfn[p->v]);
		}
		p = p->link;
	}
}

void dfs3(int u, int pre) {
	deps[u] = deps[pre] + 1;
	used[u] = true;
	fa[u][0] = pre;
	if(u <= totCut) f[u] = 0;
	else f[u] = odd[u - totCut];
	f[u] += f[pre];
	Edge *p = tree[u];
	while(p) {
		if(!used[p->v]) dfs3(p->v, u);
		p = p->link;
	}
}


int LCA(int u, int v) {
    if(deps[u] < deps[v]) swap(u, v);
    int diff = deps[u] - deps[v];
    for(int i = 0; diff; ++i, diff >>= 1)
        if(diff & 1) u = fa[u][i];
    if(u == v) return u;

    int t = 19;
    for(int i = t; i >= 0; --i) {
        if(fa[u][i] != fa[v][i]) {
            u = fa[u][i];
            v = fa[v][i];
        }
    }
    return fa[u][0];
}

int main() {
	LOG[1] = 0;
	for(int i = 2; i < MAXN; ++i)
		LOG[i] = (LOG[i] >> 1) + 1;
	int n, m;
	scanf("%d%d", &n, &m);
	for(int i = 0; i < m; ++i) {
		int u, v;
		scanf("%d%d", &u, &v);
		addEdge(u, v);
		addEdge(v, u);
	}

	dep[0] = -1;
	for(int i = 1; i <= n; ++i)
		if(!dfn[i]) {
			root = i;
			dfs(i, 0);
			++con;
		}

	currT = 0;
	memset(dfn, 0, sizeof(dfn));

	for(int i = 1; i <= n; ++i)
		if(!dfn[i]) dfs1(i, 0);

	for(int i = 1; i <= totCut + totBi; ++i)
		if(!used[i]) dfs3(i, 0);

	for(int l = 1; (1 << l) <= totCut + totBi; ++l)
		for(int i = 1; i <= totCut + totBi; ++i)
			if(fa[i][l - 1] != 0) fa[i][l] = fa[fa[i][l - 1]][l - 1];

//	for(int i = 1; i <= totCut + totBi; ++i) printf("%d ", f[i]); puts("");
	int q;
	scanf("%d", &q);
	for(int i = 0; i < q; ++i) {
		int u, v;
		scanf("%d%d", &u, &v);
		if(u == v || num[u] != num[v])
			puts("No");
		else {
			int x, y;
			if(cut[u]) x = cut[u];
			else x = totCut + bi[u];
			if(cut[v]) y = cut[v];
			else y = totCut + bi[v];
			int lca = LCA(x, y);
			int sum = f[x] + f[y] - 2 * f[fa[lca][0]];
//			printf("%d %d %d\n", x, y, lca);
//			printf("%d\n", sum);
			if(sum > 0) puts("Yes");
			else if((dep[u] + dep[v]) % 2 == 0) puts("No");
			else puts("Yes");
		}
	}
	return 0;
}
