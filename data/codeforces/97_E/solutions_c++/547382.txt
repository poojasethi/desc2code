#include <stdio.h>
#include <vector>
#include <algorithm>
using namespace std;
#define MAX 100000+11

vector< int > lst[ MAX ];
vector< int > odd[ MAX ];

int n, m, q;
int gnum[ MAX ], gg;

pair<int,int> stack[ MAX ];

int rt[ MAX ];
int ro[ MAX ];
int mi[ MAX ];
int lv[ MAX ];
int upodd[ MAX ];
int oecount[ MAX ];
int ppp[ MAX ][ 20 ];

int head;
void dfs(int x){
	int root_count = 0, root_odd = 0;

	ppp[x][0] = -1;
	lv[x] = 0;
	gnum[x] = gg;
	head = 0;
	stack[head++] = make_pair(x, 0);

	while(head > 0){
		pair<int, int>& now = stack[head-1];
		int& who = now.first;
		int& sec = now.second;
		if(sec >= lst[who].size()){
			// TODO : return value
			if(head >= 2){
				pair<int, int>& rec = stack[head-2];
				int& bef = rec.first;
				int& bsc = rec.second;
				if( mi[bef] == rt[who] ){
					mi[bef] = 0;
					odd[bef][bsc - 1] = ro[who]; // change
				} else {
					rt[bef] += rt[who] - mi[bef];
					ro[bef] |= ro[who];
					mi[bef] = 0;
					odd[bef][bsc - 1] = -1; // not change but used
				}
				if(head == 2) root_odd |= ro[who];
			}
			head --;
			continue;
		}
		int nxt = lst[who][sec];
		if(gnum[nxt] == 0){
			lv[nxt] = lv[who] + 1;
			ppp[nxt][0] = who;
			gnum[nxt] = gg;
			if(head == 1) root_count ++;
			stack[head++] = make_pair(nxt, 0);
		} else if(lv[nxt] < lv[who]-1) { // back edge
			mi[nxt] ++;
			rt[who] ++;

			if( (lv[nxt] - lv[who])%2 == 0 ){ // odd cycle
				ro[who] = 1;
			}
		}
		sec ++;
	}

	oecount[x] = 0;
	upodd[x] = (root_count == 1 && root_odd == 1)?1:0;

	head = 0;
	stack[head++] = make_pair(x, 0);

	while(head > 0){
		pair<int, int>& now = stack[head-1];
		int& who = now.first;
		int& sec = now.second;
		if(sec >= lst[who].size()){
			head --;
			continue;
		}
		int nxt = lst[who][sec];
		if(odd[who][sec] != -2){
			if(odd[who][sec] == -1) odd[who][sec] = upodd[who];

			upodd[nxt] = odd[who][sec];
			oecount[nxt] = oecount[who] + odd[who][sec];
			stack[head++] = make_pair(nxt, 0);
		}
		sec ++;
	}
}
void pre_process(){
	gg = 1;
	int i, j;
	for(i=0;i<n;i++){
		if(gnum[i] == 0){
			dfs(i);
			gg++;
		}
	}
	
	for(j=1;j<20;j++){
		for(i=0;i<n;i++){
			int x = ppp[i][j-1];
			if(x != -1){
				ppp[i][j] = ppp[x][j-1];
			} else {
				ppp[i][j] = -1;
			}
		}
	}
}
int get_same_parent(int x,int y){
	int i, dif;
	if(lv[x] > lv[y]) return get_same_parent(y, x);
	if(lv[x] < lv[y]){
		dif = lv[y] - lv[x];
		for(i=19;i>=0;i--){
			if( (1 << i) <= dif ) {
				y = ppp[y][i];
				dif -= (1 << i);
			}
		}
	}
	if(x == y) return x;
	for(i=19;i>=0;i--){
		if(ppp[x][i] != ppp[y][i]){
			x = ppp[x][i]; y = ppp[y][i];
		}
	}
	return ppp[x][0];
}
bool isleaderpair(int x, int y){
	if( gnum[x] != gnum[y] ) return false; // not same group
	int dif = lv[x] - lv[y];
	if(dif < 0) dif = -dif;
	if( dif % 2 == 1 ) return true; // level dif is odd

	int p = get_same_parent(x, y);

	return (oecount[x] + oecount[y] - oecount[p] * 2 > 0) ;
}
int main(){
//	freopen("test.txt","w",stdout);
//	freopen("output.txt","r",stdin);
	scanf("%d %d",&n,&m);
	int x, y;
	int i;
	for(i=0;i<m;i++){
		scanf("%d %d",&x,&y);
		x--;y--;
		lst[x].push_back(y);
		odd[x].push_back(-2);

		lst[y].push_back(x);
		odd[y].push_back(-2);
	}
	pre_process();
	scanf("%d",&q);
	for(i=0;i<q;i++){
		scanf("%d %d",&x,&y);
		x--; y--;
		printf("%s\n", isleaderpair(x,y) ? "Yes" : "No");
	}
	return 0;
}
/*
#include <algorithm>
#include <stdio.h>
using namespace std;
int dom[28][2];
int cnt[28];
char dat[100];

int num(char x){
	if('a' <=x && x <= 'z') return x - 'a';
	return x - 'A' + 26;
}
int main(){
//	freopen("input.txt","r",stdin);
//	freopen("output.txt","w",stdout);
	int i, j, c;
	c = 0;
	for(i=0;i<=6;i++){
		for(j=i;j<=6;j++){
			dom[c][0] = i;
			dom[c][1] = j;
			cnt[c] = 0;
			c++;
		}
	}
	int n, m;
	scanf("%d %d",&n,&m);
	printf("10080\n");
	for(i=0;i<n;i++){
		scanf("%s", dat);
		for(j=0;j<m;j++){
			if(dat[j] != '.'){
				int x = num(dat[j]);
				printf("%d",dom[x][ cnt[x] ]);
				cnt[x] ++;
			}	
			else printf(".");
		}
		printf("\n");
	}
	return 0;
}

*/