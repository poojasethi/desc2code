#include <bits/stdc++.h>

using namespace std;

#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)

#define type(x) __typeof(x.begin())

#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair < int ,int > pii;

typedef long long ll;

const long long linf = 1e18+5;
const int mod = (int) 1e9 + 7;
const int logN = 18;
const int inf = 1e9;
const int N = 2e5+5;

int q, n, m, x, y, z, root[N], lca[logN+1][N], depth[N], odd[N], f[N], up[N], sum[N];
vector< int > v[N];

int findset(int x) {
    return f[x] = (f[x] == x ? x : findset(f[x]));
}

int LCA(int x, int y) {
    if(depth[x] < depth[y])
        swap(x, y);
    int diff = depth[x] - depth[y];
    FOR(i, 0, logN)
        if(diff & (1 << i))
            x = lca[i][x];
    if(x == y) return x;
    ROF(i, logN, 0)
        if(lca[i][x] != lca[i][y])
            x = lca[i][x],
            y = lca[i][y];
    return lca[0][x] * (lca[0][x] == lca[0][y]);
}

void dfs(int node) {
    foreach(it, v[node]) {
        int to = *it;
        if(!depth[to]) {
            root[to] = lca[0][to] = node;
            depth[to] = depth[node] + 1;
            dfs(to);
        }
        else if(depth[node] - 1 > depth[to]) {
            int w = findset(node);
            up[node] = max(up[node], depth[node] - depth[to] - 1);
            if((depth[node] - depth[to]) % 2 == 0)
                    odd[node] = 1;
        }
    }
}

int dfs2(int node) {
    int t = up[node];
    foreach(it, v[node]) {
        int to = *it;
        if(depth[to] - 1 == depth[node]) {
            int xx = dfs2(to);
            if(xx > 0)
                f[to] = node;
            t = max(t, xx-1);
        }
    }
    return t;
}

void dfs3(int node){
    foreach(it, v[node]) {
        int to = *it;
        if(depth[to] - 1 == depth[node]){
            sum[to]+=sum[node];
            dfs3(to);
        }
    }
}

int main() {

    scanf("%d %d", &n, &m);

    FOR(i, 1, m) {
        scanf("%d %d", &x, &y);
        v[x].pb(y);
        v[y].pb(x);
    }

    FOR(i, 1, n) f[i] = i;

    FOR(i, 1, n) {
        if(depth[i]) continue;
        depth[i] = 1;
        dfs(i); dfs2(i);
    }

    FOR(i, 1, n)
        odd[findset(i)] |= odd[i];

    FOR(i, 1, n)
        sum[i] = odd[i] |= odd[findset(i)];

    FOR(i, 1, n)
        if(depth[i] == 1)
            dfs3(i);

    FOR(j, 1, logN)
        FOR(i, 1, n)
            lca[j][i] = lca[j-1][lca[j-1][i]];

    scanf("%d", &q);

    FOR(i, 1, q) {
        scanf("%d %d", &x, &y);
        int t = LCA(x, y);
        if(!t || (depth[x] + depth[y]) % 2 == 0 && sum[x] + sum[y] - 2 * sum[t] == 0)
            printf("No\n");
        else printf("Yes\n");
    }

    return 0;
}
