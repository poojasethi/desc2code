class ProbB:

    def calculate(self, n, t1, t2, k, speeds):
        res = []
        ind = 1
        for speed in speeds:
            res.append((ind, self._get_max_height(t1, t2, k, speed[0], speed[1])))
            ind += 1
        self._sort(res)
        self._round(res)
        return res

    def _sort(self, heights):
        def compare(height1, height2):
            comp1 = cmp(height1[1], height2[1])
            if comp1 != 0:
                return -comp1
            return cmp(height1[0], height2[0])
        heights.sort(compare)

    def _round(self, heights):
        for id, height in enumerate(heights):
            heights[id] = (heights[id][0], '%0.2f' %  heights[id][1])

    def _get_max_height(self, t1, t2, k, a, b):
        return max(
            self._get_height(t1, t2, k, a, b),
            self._get_height(t1, t2, k, b, a)
        )

    def _get_height(self, t1, t2, k, a, b):
        return ((a*t1) * ((100-k) / 100.0)) + (b*t2)


if __name__ == '__main__':
    nums = map(int, raw_input('').split())
    speeds = []
    for i in xrange(nums[0]):
        speed = map(int, raw_input('').split())
        speeds.append((speed[0], speed[1]))
    res = ProbB().calculate(nums[0], nums[1], nums[2], nums[3], speeds)
    for r in res:
        print '%s %s' % (r[0], r[1])