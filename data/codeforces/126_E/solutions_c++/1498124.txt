#pragma warning(disable:4786)
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<ctime>
#include<assert.h>

#include<cmath>
#include<iostream>
#include<fstream>

#include<string>
#include<vector>
#include<queue>
#include<map>
#include<algorithm>
#include<set>
#include<sstream>
#include<stack>

using namespace std;

#define MAX(a,b) ((a)>(b) ? (a) : (b))
#define min(a,b) ((a)<(b) ? (a) : (b))
#define EPS 1e-9
#define asdf exit(0);












#define MAX_V 350
vector<long> Edge[ MAX_V+7];
long Row,Col;// Row will b left side and col will b in rght side
long nEdge,nVertex;

bool Visit[ MAX_V+7];

//after matching spouse of 'i'  is M[i] ( i think  :S im not sure  )
long M[ MAX_V+7];


void ini()
{
    memset(M,0,sizeof(M));
    memset(Visit,0,sizeof(Visit));
    int i;
    for(i=0;i<(MAX_V+7);i++)
    {
        Edge[i].clear();
    }
}

bool Match( long u)
{
    if( Visit[u]) return false;
    Visit[u] =true;
    long i;
    for( i=0;i<Edge[u].size();i++)
    {
        long v =Edge[u][i];
        if( !M[v]){
            M[u] =v;
            M[v] =u;
            return true;
        }
        else if( Match( M[v]))
        {
            M[u] =v;
            M[v] =u;
            return true;
        }
    }
    return false;
}


int BMatch()
{
    memset( &M[1],0,sizeof(long)*nVertex);
    long i;
    for( i=1;i<=Row;i++)
    {
        if( M[i]) continue;
        memset( &Visit[1],0,sizeof(bool)*( Row+Col));
        Match( i);
    }
    int ret=0;
    int j=Row+1;
    for(i=1;i<=Row;i++)
    {
        if(M[i])
        {
            ret++;
            //sts[ co[i-1] ].push_back(ro[M[i]-Row-1]);
        }
        else
        {
       //     while(M[j]) j++;
         //   sts[ co[i-1] ].push_back(ro[j-Row-1]);
        }
    }
    return ret;
}





















int mat[500][500];

int vis[10][10];
char grid[10][10];


int ans;



vector<int> taken(10);

vector <pair<int,int> >O1(28);
vector<int> O2(28);


vector< pair<int,int> > save1(28);
vector< int > save2(28);



int pt[155][155];

string cols[100];


string dic[12];
int dic_cnt[12];

int dx[2]={0,1};
int dy[2]={1,0};



map< vector<int>,int > mp;



vector<int> sts[10];

int glo=0;

void get()
{

    int i,sum=0,mn,j;
    if(mp[taken]) return;
    mp[taken]=1;

    vector<int> co,ro;




    for(i=0;i<10;i++)
    {
        mn=min(taken[i],dic_cnt[i]);

        //for(j=0;j<mn;j++) sts[i].push_back(i);
        for(j=0;j<dic_cnt[i]-mn;j++)
        {
            ro.push_back(i);
        }
        for(j=0;j<taken[i]-mn;j++)
        {
            co.push_back(i);
        }
        sum+=2*mn;
    }





    ini();

    Col=co.size();
    Row=ro.size();
    nVertex=Col+Row;

    if( (sum+min(Col,Row)) <= ans   ) return;





    for(i=0;i<Row;i++)
    for(j=0;j<Col;j++)
    {
        if(pt[ co[j] ][ ro[i] ])
        {
            Edge[i+1].push_back(j+1+Row);
            Edge[j+1+Row].push_back(i+1);

        }
    }








    sum+=BMatch();

    //if(glo==223)asdf
    if(sum<=ans) return;




    /*if(sum==40)
    {



        for(i=0;i<Row;i++) cout<<" "<<ro[i];
        cout<<endl;
        for(i=0;i<Col;i++) cout<<" "<<co[i];
        cout<<endl;


        for(i=1;i<=Row;i++) cout<<i<<" "<<M[i]-Row<<endl;
        cout<<endl;
    }*/


    ans=sum;
    save1=O1;
    save2=O2;

    for(i=0;i<10;i++) sts[i].clear();
    for(i=0;i<10;i++)
    {
        mn=min(taken[i],dic_cnt[i]);
        for(j=0;j<mn;j++) sts[i].push_back(i);
    }



    j=1;
    for(i=Row+1;i<=nVertex;i++)
    {
        if(M[i])
        {
            sts[ co[i-1-Row] ].push_back(ro[M[i]-1]);

            /*if(ans==40)
            {
                cout<<co[i-1-Row]<<" "<<ro[M[i]-1]<<endl;
            }*/
        }
        else
        {
            while(M[j]) j++;
            sts[ co[i-1-Row] ].push_back(ro[j-1]);
            j++;
        }
    }
    return;
}


void bttk(int x,int y,int cnt)
{
    int i,X,Y,j;
    if(x>=7)
    {
        get();
        return;
    }




    if(y>=8)
    {
        bttk(x+1,0,cnt);
        return;
    }



    if(vis[x][y])
    {
        bttk(x,y+1,cnt);
        return;
    }

    vis[x][y]=1;
    for(i=0;i<2;i++)
    {
        X=x+dx[i];
        Y=y+dy[i];
        if(x>=0 && X<7 && Y>=0 && Y<8 && !vis[X][Y])
        {
            vis[X][Y]=1;

            O1[cnt].first=x;
            O1[cnt].second=y;
            O2[cnt]=i;

            taken[mat[ grid[x][y] ][ grid[X][Y] ]]++;

            bttk(x,y+1,cnt+1);
            taken[mat[ grid[x][y] ][ grid[X][Y] ]]--;
            vis[X][Y]=0;
        }
    }
    vis[x][y]=0;
}







int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);





    int i,j,k,l;

    dic[0]="BY";
    dic[1]="BW";
    dic[2]="BR";
    dic[3]="BB";
    dic[4]="RY";
    dic[5]="RW";
    dic[6]="RR";
    dic[7]="WY";
    dic[8]="WW";
    dic[9]="YY";


    for(i=0;i<10;i++)
    {
        mat[ dic[i][0] ][ dic[i][1] ]=i;
        mat[ dic[i][1] ][ dic[i][0] ]=i;
    }




    for(i=0;i<10;i++)
    for(j=0;j<10;j++)
    {
        int ok=0;
        for(k=0;k<2;k++)
        for(l=0;l<2;l++)
        {
            if(dic[i][k]==dic[j][l]) ok=1;
        }
        pt[i][j]=ok;


       // cout<<i<<" "<<j<<" "<<pt[i][j]<<endl;
    }

    //asdf







    for(i=0;i<7;i++) scanf("%s",grid[i]);
    for(i=0;i<10;i++)  scanf("%d",&dic_cnt[i]);


    ans=-1;
    bttk(0,0,0);




    printf("%d\n",ans);

    char out[100][100];
    for(i=0;i<20;i++)
    for(j=0;j<20;j++)
    out[i][j]='.';



    int x,y,X,Y,val;


    int ca1=0,ca2=0,ca0=0;


    for(i=0;i<28;i++)
    {
       // cout<<i<<endl;



        x=save1[i].first;
        y=save1[i].second;
        X=x;
        Y=y;

        if(save2[i]==0)
        {
            Y=y+1;
            out[ 2*save1[i].first  ][ 2*save1[i].second+1 ]  ='-';
        }
        else
        {
            X=x+1;
            out[ 2*save1[i].first+1  ][ 2*save1[i].second ]  ='|';
        }

        val=mat[ grid[x][y] ][grid[X][Y]];

        j=sts[val].back();
        sts[val].pop_back();


        int c1=0,c2=0;



        if(grid[x][y]==dic[j][0]) c1++;
        if(grid[X][Y]==dic[j][1]) c1++;

        if(grid[x][y]==dic[j][1]) c2++;
        if(grid[X][Y]==dic[j][0]) c2++;


        if(c1>c2)
        {
            if(c1==1)ca1++;
            else if(c1==2) ca2++;
            else ca0++;


            grid[x][y]=dic[j][0];
            grid[X][Y]=dic[j][1];
        }
        else
        {
            if(c2==1)ca1++;
            else if(c2==2) ca2++;
            else ca0++;


            grid[x][y]=dic[j][1];
            grid[X][Y]=dic[j][0];
        }

    }

    //cout<<ca1<<" "<<ca2<<" "<<ca0<<endl;
    //cout<<"asdf";





    for(i=0;i<7;i++)
    for(j=0;j<8;j++)
    {
        out[2*i][2*j]=grid[i][j];
    }



    for(i=0;i<13;i++)
    {
        for(j=0;j<15;j++) printf("%c",out[i][j]);
        printf("\n");
    }








    return 0;
}
