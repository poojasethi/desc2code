#include <iostream>
#include <stdio.h>
#include <map>
#include <algorithm>
#include <list>
#include <string.h>
using namespace std;

struct _flow{
#define oo 1e9
	int src, dst;
	int nedge;
	int point[500], fnet[500], next[500], cap[500], cost[500];
	int head[500], dist[500], work[500];
	void clear(){
		memset(head, -1, sizeof(head));
		nedge=result=0;
	}
	inline void addedge(int u, int v, int c, int w){
		point[nedge]=v; fnet[nedge]=0; cap[nedge]=c; cost[nedge]=w; next[nedge]=head[u];
		head[u]=nedge++;
		point[nedge]=u; fnet[nedge]=0; cap[nedge]=0; cost[nedge]=-w; next[nedge]=head[v];
		head[v]=nedge++;
	}
	int np, in[500], pre[500], fc[500];
	int result;
	void spfa(){
		fill(dist, dist+np, 1e8);
		dist[src]=0;
		fc[src]=1e8;
		list<int> Q;
		Q.push_back(src);
		memset(in, 0, sizeof(in));
		while(!Q.empty()){
			int u=Q.front(); Q.pop_front();
			in[u]=0;
			for(int i=head[u]; i>=0; i=next[i])
				if(fnet[i]<cap[i] && dist[point[i]]>dist[u]+cost[i]){
					dist[point[i]]=dist[u]+cost[i];
					pre[point[i]]=i;
					fc[point[i]]=min(fc[u], cap[i]-fnet[i]);
					if(!in[point[i]]){
						in[point[i]]=1;
						if(!Q.empty() && dist[point[i]]<=dist[Q.front()])
							Q.push_front(point[i]);
						else Q.push_back(point[i]);
					}
				}
		}
	}
	int Q[500];
	bool dinic_bfs(){
		memset(dist, -1, sizeof(dist));
		dist[src]=0;
		int sizeQ=0;
		Q[sizeQ++]=src;
		for(int cl=0; cl<sizeQ; cl++)
			for(int k=Q[cl], i=head[k]; i>=0; i=next[i])
				if((abs(point[i]-k)!=10 || i<40) && abs(cost[i])!=2&&fnet[i]<cap[i] && dist[point[i]]==-1){
					dist[point[i]]=dist[k]+1;
					Q[sizeQ++]=point[i];
				}
		return dist[dst]>=0;
	}
	int dinic_dfs(int x, int exp){
		if(x==dst) return exp;
		for(int &i=work[x]; i>=0; i=next[i]){
			int v=point[i], tmp;
			if(dist[v]==dist[x]+1 && (abs(x-point[i])!=10 || i<40) &&abs(cost[i])!=2&&fnet[i]<cap[i] && (tmp=dinic_dfs(v, min(exp, cap[i]-fnet[i])))>0){
				fnet[i]+=tmp;
				fnet[i^1]-=tmp;
				return tmp;
			}
		}
		return 0;
	}
	int dinic_flow(){
		int ret=0;
		while(dinic_bfs()){
			for(int i=0; i<=dst; i++) work[i]=head[i];
			while(1){
				int delta=dinic_dfs(src, 1e8);
				if(delta==0) break;
				ret+=delta;
			}
		}
		return ret;
	}
	int maxflow(){
		memset(dist, 0, sizeof(dist));
		result=0;
		do{
			spfa();
			if(dist[dst]<1e8){
				int f=fc[dst];
				for(int i=dst; i!=src; i=point[pre[i]^1]){
					result+=f*cost[pre[i]];
					fnet[pre[i]]+=f;
					fnet[pre[i]^1]-=f;
				}
			}
		}while(dist[dst]<1e8);
		return result;
	}
}flow;

char pill[11][3]={
	"","BY", "BW", "BR", "BB", "RY", "RW", "RR", "WY", "WW", "YY"
};
char mp[10][10];
struct A{
	int a[10][10];
};
A  sub, type;
int mm=0;
pair<int, int> next(int x, int y){
	if(y==7)
		return make_pair(x+1, 0);
	return make_pair(x, y+1);
}
int code(char a, char b){
	if(a>b) swap(a, b);
	if(a=='B'){
		if(b=='Y') return 1;
		if(b=='W') return 2;
		if(b=='R') return 3;
		return 4;
	}
	if(a=='R'){
		if(b=='Y') return 5;
		if(b=='W') return 6;
		if(b=='R') return 7;
	}
	if(a=='W'){
		if(b=='Y') return 8;
		return 9;
	}
	return 10;
}
char dir[2][2]={{1, 0}, {0, 1}};
int num[15];
int mis[11][11];
int bn[15];
char ans[20][20];
int mat[20][20];
map<long long, int> hash;
const int cs=1e9+7;
void solve(){
	long long id=0, b=1;for(int i=1; i<=10; i++, b*=cs) id+=bn[i]*b;
	if(hash.find(id)!=hash.end()) return;
	hash[id]=1;
	fill(flow.fnet, flow.fnet+flow.nedge, 0);
	int tmp=0;
	int result=0;
	for(int i=1; i<=10; i++)
	{
		int j=min(bn[i], num[i]);
		//if(!j) continue;
		flow.fnet[(i-1)*2]+=j;
		flow.fnet[(i-1)*2+1]-=j;
		flow.fnet[40+((i-1)*10+(i-1))*2]+=j;
		flow.fnet[40+((i-1)*10+(i-1))*2+1]-=j;
		flow.fnet[(i-1)*2+20]+=j;
		flow.fnet[(i-1)*2+21]-=j;
		tmp+=j+j; if(bn[i]>j) tmp+=bn[i]-j; result+=j+j;
	}
	if(tmp<=mm) return;
	//int result=56-flow.maxflow();
	//if(result==12) 
		//bool chk=1;
	int ff=flow.dinic_flow();
	result+=ff;
	if(result>mm){
		mm=result;
		//cout<<mm<<endl;
		int tot[11]={0}, use[11]={0};
		for(int i=1; i<=10; i++) for(int j=1; j<=10; j++)
			mat[i][j]=flow.fnet[40+((i-1)*10+(j-1))*2],tot[j]+=mat[i][j], use[i]+=mat[i][j];
		for(int j=1; j<=10; j++) if(tot[j]<bn[j]){
			for(int i=1; i<=10 && tot[j]<bn[j]; i++) if(use[i]<num[i]) {
				int a=min(bn[j]-tot[j], num[i]-use[i]);
				mat[i][j]+=a, tot[j]+=a, use[i]+=a;
			}
		}
		memset(ans, '.', sizeof(ans));
		for(int i=0; i<7; i++) for(int j=0; j<8; j++) if(sub.a[i][j]==0 || sub.a[i][j]==2){
			int t=sub.a[i][j];
			if(t==2) ans[i*2+1][j*2+2]='-';
			else ans[i*2+2][j*2+1]='|';
			for(int k=1; k<=10; k++) if(mat[k][type.a[i][j]]){
				mat[k][type.a[i][j]]--;
				if(((pill[k][0]!=mp[i][j])+(pill[k][1]!=mp[i+dir[t/2][0]][j+dir[t/2][1]])) < ((pill[k][1]!=mp[i][j])+(pill[k][0]!=mp[i+dir[t/2][0]][j+dir[t/2][1]]))){
					ans[i+i+1][j+j+1]=pill[k][0], ans[(i+dir[t/2][0])*2+1][(j+dir[t/2][1])*2+1]=pill[k][1];
				}else{
					ans[i+i+1][j+j+1]=pill[k][1], ans[(i+dir[t/2][0])*2+1][(j+dir[t/2][1])*2+1]=pill[k][0];
				}
				break;
			}
		}
		//for(int i=1; i<=13; i++){
		//	for(int j=1; j<=15; j++)
		//		printf("%c", ans[i][j]);
		//	printf("\n");
		//}
	}
}
int step=0;
void dfs(int x, int y){
	if(x==7){
		//step++; cout<<step<<"\n";
		solve();
		return;
	}
	if(sub.a[x][y]!=-1){
		dfs(next(x, y).first, next(x, y).second);
	}else{
		if(y+1<8 && sub.a[x][y+1]==-1){
			sub.a[x][y+1]=3;
			sub.a[x][y]=2;
			type.a[x][y+1]=type.a[x][y]=code(mp[x][y], mp[x][y+1]);
			bn[type.a[x][y+1]]++;
			flow.cap[code(mp[x][y], mp[x][y+1])*2+18]++;
			dfs(next(x, y).first, next(x, y).second);
			flow.cap[code(mp[x][y], mp[x][y+1])*2+18]--;
			bn[type.a[x][y+1]]--;
			sub.a[x][y]=-1;
			sub.a[x][y+1]=-1;
		}
		if(x+1<7 && sub.a[x+1][y]==-1){
			sub.a[x][y]=0;
			sub.a[x+1][y]=1;
			type.a[x][y]=type.a[x+1][y]=code(mp[x][y], mp[x+1][y]);
			bn[type.a[x][y]]++;
			flow.cap[code(mp[x][y], mp[x+1][y])*2+18]++;
			dfs(next(x, y).first, next(x, y).second);
			flow.cap[code(mp[x][y], mp[x+1][y])*2+18]--;
			bn[type.a[x][y]]--;
			sub.a[x][y]=-1;
			sub.a[x+1][y]=-1;
		}
	}
}
int main(){
	for(int i=0; i<7; i++)
		scanf(" %s", mp[i]);
	memset(sub.a, -1, sizeof(sub.a));
	for(int i=1; i<=10; i++) cin>>num[i];
	for(int i=1; i<=10; i++) for(int j=1; j<=10; j++){
		mis[i][j]=min((pill[i][0]!=pill[j][0])+(pill[i][1]!=pill[j][1]), (pill[i][0]!=pill[j][1])+(pill[i][1]!=pill[j][0]));
	}
	flow.clear(); flow.np=22; flow.src=0; flow.dst=21;
	for(int i=1; i<=10; i++) flow.addedge(0, i, num[i], 0);
	for(int i=1; i<=10; i++) flow.addedge(i+10, 21, 0, 0);
	for(int i=1; i<=10; i++) for(int j=1; j<=10; j++)
		flow.addedge(i, j+10, 1e8, mis[i][j]);
	mm=-1;
	dfs(0, 0);
	printf("%d\n", mm);
	for(int i=1; i<=13; i++){
		for(int j=1; j<=15; j++)
			printf("%c", ans[i][j]);
		printf("\n");
	}
	return 0;
}