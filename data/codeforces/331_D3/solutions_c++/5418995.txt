#include <vector>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <set>
using namespace std;

typedef pair<int, int> Pii;
#define x first
#define y second
#define mp make_pair
#define pb push_back

typedef long long LL;
typedef pair<Pii, Pii> Arrow;
typedef set<Pii>::iterator sit;
const int d[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

const int MAXN = 100000 * 5 + 10, MAXL = 51;

Arrow a[MAXN];
Pii p[MAXN];
int dir[MAXN];
int f[MAXN], fa[MAXN][MAXL], n, b, q, N;
LL dist[MAXN][MAXL], t[MAXN];
char str[10];
int ID[300];

void Build()
{
	static bool app[MAXN];
	memset(app, 0, sizeof(app));
	set<Pii> s;
	vector<Pii> v;
	for (int i = 1; i <= n; ++i)
		v.pb(mp(a[i].x.x, i)), v.pb(mp(a[i].y.x, i));
	for (int i = 1; i <= q; ++i)
		if (dir[i] == 2)
			v.pb(mp(p[i].x, i + n));
	sort(v.begin(), v.end());
	v.erase(unique(v.begin(), v.end()), v.end());
	for (int i = 0; i < (int)v.size(); ++i)
		if (v[i].y > n)
			s.insert(mp(p[v[i].y - n].y, v[i].y));
		else
		{
			int yl = min(a[v[i].y].x.y, a[v[i].y].y.y), yr = max(a[v[i].y].x.y, a[v[i].y].y.y);
			sit l = s.lower_bound(mp(yl, 0));
			for (sit it = l; it != s.end() && it -> x <= yr; l = it, ++it, s.erase(l))
				f[it -> y] = v[i].y;
			if (app[v[i].y] && v[i].x == a[v[i].y].y.x)
				s.insert(mp(a[v[i].y].x.y, v[i].y));
			app[v[i].y] = true;
		}
	s.clear();
}
void S(Pii &a, bool f) {
	if (!f)
		swap(a.x, a.y);
	else
	a.x = -a.x;
}
void U(bool f)
{
	for (int i = 1; i <= n; ++i)
		S(a[i].x, f), S(a[i].y, f);
	for (int i = 1; i <= q; ++i)
		S(p[i], f), dir[i] ^= (1 + !f);
}
void Build_G()
{
	Build();
	U(1);
	Build();
	U(1);
}
vector<Pii> Xc[MAXN], Yc[MAXN];
void Add(vector<Pii> &v, int a, int b, int id)
{
	v.pb(mp(min(a, b), -id)), v.pb(mp(max(a, b), id));
}
int Find(vector<Pii> &v, int x)
{
	int id = upper_bound(v.begin(), v.end(), mp(x, 0)) - v.begin() - 1;
	if (id < 0 || id >= (int)v.size() || v[id].y > 0 && x > v[id].x) return 0;
	return abs(v[id].y);
}
int Dis(Pii a, Pii b) {
	return abs(a.x - b.x) + abs(a.y - b.y);
}
Pii stp(int i)
{
	if (i <= n) return a[i].y;
	return p[i - n];
}
LL Dis(int x, int y)
{
	if (!y) return (LL)1e16;
	return Dis(stp(x), a[y].y);
}
void init()
{
	ID['U'] = 0, ID['D'] = 1, ID['R'] = 2, ID['L'] = 3;
	scanf("%d%d", &n, &b);
	for (int i = 1; i <= n; ++i)
	{
		scanf("%d%d%d%d", &a[i].x.x, &a[i].x.y, &a[i].y.x, &a[i].y.y);
		if (a[i].x.x == a[i].y.x)
			Add(Xc[a[i].x.x], a[i].x.y, a[i].y.y, i);
		else
		Add(Yc[a[i].x.y], a[i].x.x, a[i].y.x, i);
	}
	for (int i = 0; i <= b; ++i)
		sort(Xc[i].begin(), Xc[i].end()), sort(Yc[i].begin(), Yc[i].end());
	scanf("%d", &q);
	for (int i = 1; i <= q; ++i)
	{
		scanf("%d%d%s%I64d", &p[i].x, &p[i].y, str, &t[i + n]);
		dir[i] = ID[str[0]];
	}
	Build_G();
	U(0);
	Build_G();
	U(0);
	for (int i = n + q; i >= n + 1; --i)
		dir[i] = dir[i - n];
	for (int i = 1; i <= n; ++i)
		if (a[i].x.x == a[i].y.x)
			dir[i] = (a[i].y.y < a[i].x.y);
		else
		dir[i] = 2 ^ (a[i].y.x < a[i].x.x);
	for (int i = 1; i <= q; ++i)
	{
		int nex = Find(Xc[p[i].x], p[i].y) + Find(Yc[p[i].y], p[i].x);
		if (nex)
			f[n + i] = nex, dir[i + n] = dir[nex];
	}
	N = n + q;
	for (int i = 1; i <= N; ++i)
		fa[i][0] = f[i],
		dist[i][0] = Dis(i, f[i]);
	for (int j = 1; j <= 50; ++j)
		for (int i = 1; i <= N; ++i)
			fa[i][j] = fa[fa[i][j - 1]][j - 1],
			dist[i][j] = dist[i][j - 1] + dist[fa[i][j - 1]][j - 1],
			dist[i][j] = (dist[i][j] > (LL)1e16) ? (LL)1e16 : dist[i][j];
}
void solve()
{
	for (int i = n + 1; i <= n + q; ++i)
	{
		int x = i;
		for (int j = 50; j >= 0; --j)
			if (dist[x][j] <= t[i])
				t[i] -= dist[x][j], x = fa[x][j];
		LL px = 0, py = 0;
		if (!fa[x][0])
			px = (LL)stp(x).x + t[i] * d[dir[x]][0], py = (LL)stp(x).y + t[i] * d[dir[x]][1];
		else
		{
			int y = fa[x][0];
			int D = (d[dir[x]][0]) ? abs(stp(x).x - stp(y).x) : abs(stp(x).y - stp(y).y);
			if (D >= t[i])
				px = (LL)stp(x).x + t[i] * d[dir[x]][0], py = (LL)stp(x).y + t[i] * d[dir[x]][1];
			else
			{
				D = dist[x][0] - t[i];
				px = (LL)stp(y).x + D * d[dir[y]][0] * -1, py = (LL)stp(y).y + D * d[dir[y]][1] * -1;
			}
		}
		px = max(0ll, px), px = min((LL)b, px);
		py = max(0ll, py), py = min((LL)b, py);
		printf("%I64d %I64d\n", px, py);
	}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout);
#endif
	init();
	solve();
	fclose(stdin);
	fclose(stdout);
	return 0;
}
