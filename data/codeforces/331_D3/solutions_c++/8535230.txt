#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

typedef long long ll;

const int N = 100005;
const ll inf = (ll)2e15;

#define fo(i , st , en) for (int i = st; i <= en; i++)
#define fd(i , st , en) for (int i = st; i >= en; i--)
#define Me(x , y) memset(x , y , sizeof(x))
#define Abs(x) ((x) > 0 ? (x) : -(x))
#define P(x , y) (x + y | x != y)

struct _six{
    int a , b , c , d , e , v;
}a[N + N];

struct _two{
    int a; ll b;
}To[N + N][50];

bool operator < (const _six &x , const _six &y){
	if (x.v == y.v) return x.e < y.e;
	return x.v < y.v;
}

int b , n , l1 , l2 , q;
int t[N + N];
ll len[N];

void Change(int l , int r , int st , int en , int v){
    int x = P(l , r);
    if (st <= l && r <= en){
        t[x] = v; return;
    }
    int mid = l + r >> 1;
    if (t[x]){
        t[P(l , mid)] = t[x];
        t[P(mid + 1 , r)] = t[x];
        t[x] = 0;
    }
    if (st <= mid)
        Change(l , mid , st , en , v);
    if (en > mid)
        Change(mid + 1 , r , st , en , v);
}

int Find(int l , int r , int p){
    int x = P(l , r);
    if (t[x] || l == r) return t[x];
    int mid = l + r >> 1;
    return p <= mid ? Find(l , mid , p) : Find(mid + 1 , r , p);
}

void Init(){
    scanf("%d%d" , &n , &b); int x0 , y0 , x1 , y1;
    fo (i , 1 , n){
        scanf("%d%d%d%d" , &x0 , &y0 , &x1 , &y1);
        a[i] = (_six){x0 , y0 , x1 , y1 , i , 0};
    }
	char ch; scanf("%d" , &q);
	fo (i , 1 , q){
		scanf("%d%d %c%I64d" , &x0 , &y0 , &ch , len + i);
		a[n + i] = (_six){x0 , y0 , x0 , y0 , n + i , 0};
		if (ch == 'L') ++a[n + i].a;
		if (ch == 'R') --a[n + i].a;
		if (ch == 'U') --a[n + i].b;
		if (ch == 'D') ++a[n + i].b;
	}
	fo (i , 1 , n + q) a[i].v = a[i].c > a[i].a ? a[i].a : a[i].c;
    sort(a + 1 , a + n + q + 1);
    fo (i , 1 , n + q)
        if (a[i].a > a[i].c)
            To[a[i].e][0].a = Find(0 , b , a[i].b);
		else
			if (a[i].e <= n)
				if (a[i].a == a[i].c)
					Change(0 , b , min(a[i].b , a[i].d) , max(a[i].b , a[i].d) , a[i].e);
				else
					Change(0 , b , a[i].b , a[i].b , a[i].e);
	fo (i , 1 , n + q) a[i].v = a[i].c < a[i].a ? -a[i].a : -a[i].c;
    Me(t , 0); sort(a + 1 , a + n + q + 1);
    fo (i , 1 , n + q)
        if (a[i].a < a[i].c)
            To[a[i].e][0].a = Find(0 , b , a[i].b);
		else
			if (a[i].e <= n)
				if (a[i].a == a[i].c)
					Change(0 , b , min(a[i].b , a[i].d) , max(a[i].b , a[i].d) , a[i].e);
				else
					Change(0 , b , a[i].b , a[i].b , a[i].e);
	fo (i , 1 , n + q) a[i].v = a[i].d > a[i].b ? a[i].b : a[i].d;
    Me(t , 0); sort(a + 1 , a + n + q + 1);
    fo (i , 1 , n + q)
        if (a[i].b > a[i].d)
            To[a[i].e][0].a = Find(0 , b , a[i].c);
		else
			if (a[i].e <= n)
				if (a[i].b == a[i].d)
					Change(0 , b , min(a[i].a , a[i].c) , max(a[i].a , a[i].c) , a[i].e);
				else
					Change(0 , b , a[i].a , a[i].a , a[i].e);
	fo (i , 1 , n + q) a[i].v = a[i].d < a[i].b ? -a[i].b : -a[i].d;
    Me(t , 0); sort(a + 1 , a + n + q + 1);
    fo (i , 1 , n + q)   
        if (a[i].b < a[i].d)
            To[a[i].e][0].a = Find(0 , b , a[i].c);
		else
			if (a[i].e <= n)
				if (a[i].b == a[i].d)
					Change(0 , b , min(a[i].a , a[i].c) , max(a[i].a , a[i].c) , a[i].e);
				else
					Change(0 , b , a[i].a , a[i].a , a[i].e);
	fo (i , 1 , n + q) a[i].v = a[i].e;
	sort(a + 1 , a + n + q + 1);
	fo (i , 1 , n + q){
		int x = To[i][0].a;
		if (x) To[i][0].b = Abs(a[i].c - a[x].c) + Abs(a[i].d - a[x].d);
	}
    fo (i , 0 , 48)
        fo (j , 1 , n + q)
            if (To[j][i].a){
				To[j][i + 1].a = To[To[j][i].a][i].a;
                To[j][i + 1].b = To[j][i].b + To[To[j][i].a][i].b;
				if (To[j][i + 1].b > inf) To[j][i + 1].b = inf;
            }
}

void Work(){
	fo (i , n + 1 , n + q){
		int x = i; ll Len = len[x - n];
		fd (j , 49 , 0)
			if (To[x][j].a && To[x][j].b <= Len){
				Len -= To[x][j].b; x = To[x][j].a;
			}
		ll curx = a[x].c , cury = a[x].d;
		if (To[x][0].a){
			int y = To[x][0].a; ll num = 0;
			if (a[x].a != a[x].c){
				if (a[x].c < a[y].c) curx += num = min(Len , a[y].c - curx);
				if (a[x].c > a[y].c) curx -= num = min(Len , curx - a[y].c);
			}
			if (a[x].b != a[x].d){
				if (a[x].d < a[y].d) cury += num = min(Len , a[y].d - cury);
				if (a[x].d > a[y].d) cury -= num = min(Len , cury - a[y].d);
			}
			Len -= num; x = y;
		}
		if (a[x].a < a[x].c) curx += Len;
		if (a[x].a > a[x].c) curx -= Len;
		if (a[x].b < a[x].d) cury += Len;
		if (a[x].b > a[x].d) cury -= Len;
		if (curx < 0) curx = 0;
		if (curx > b) curx = b;
		if (cury < 0) cury = 0;
		if (cury > b) cury = b;
		printf("%I64d %I64d\n" , curx , cury);
	}
}

int main(){
    Init();
    Work();
    return 0;
}
