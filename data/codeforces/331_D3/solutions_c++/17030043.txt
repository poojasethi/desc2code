#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define N 100005
#define inf 10000000000000000ll
#define lson l,mid,rt<<1
#define rson mid+1,r,rt<<1|1
int n,m,Q;
char s[3];
struct node{int x,y,xx,yy,d,id;}q[N<<1];
ll T[N];
bool cmp1(const node &a,const node &b){if(max(a.x,a.xx)==max(b.x,b.xx)) return a.id<b.id;return max(a.x,a.xx)>max(b.x,b.xx);}
bool cmp2(const node &a,const node &b){if(min(a.x,a.xx)==min(b.x,b.xx)) return a.id<b.id;return min(a.x,a.xx)<min(b.x,b.xx);}
bool cmp3(const node &a,const node &b){if(max(a.y,a.yy)==max(b.y,b.yy)) return a.id<b.id;return max(a.y,a.yy)>max(b.y,b.yy);}
bool cmp4(const node &a,const node &b){if(min(a.y,a.yy)==min(b.y,b.yy)) return a.id<b.id;return min(a.y,a.yy)<min(b.y,b.yy);}
bool cmp5(const node &a,const node &b){return a.id<b.id;}
int f[N<<2];
void pushdown(int rt)
{
	if(f[rt])
	{
		f[rt<<1]=f[rt<<1|1]=f[rt];
		f[rt]=0;
	}
}
void update(int l,int r,int rt,int L,int R,int x)
{
	if(L==l&&R==r) {f[rt]=x;return;}
	int mid=(l+r)>>1;
	pushdown(rt);
	if(R<=mid) update(lson,L,R,x);
	else if(L>mid) update(rson,L,R,x);
	else update(lson,L,mid,x),update(rson,mid+1,R,x);
}
int get_pos(int l,int r,int rt,int p)
{
	if(l==r) return f[rt];
	pushdown(rt);
	int mid=(l+r)>>1;
	if(p<=mid) return get_pos(lson,p);
	else return get_pos(rson,p);
}
int nxt[N][65],to[N];
int dx[4]={0,1,0,-1};
int dy[4]={1,0,-1,0};
ll tim[N][65];
void solve()
{
	for(int i=1;i<=n;i++)
	{
		if(nxt[i][0])  tim[i][0]=abs(q[nxt[i][0]].yy-q[i].yy)+abs(q[nxt[i][0]].xx-q[i].xx);
		else if(q[i].d==0) tim[i][0]=m-q[i].yy;
		else if(q[i].d==2) tim[i][0]=q[i].yy;
		else if(q[i].d==1) tim[i][0]=m-q[i].xx;
		else if(q[i].d==3) tim[i][0]=q[i].xx;
	} 
	for(int j=1;j<=60;j++) 
	{
		for(int i=1;i<=n;i++) 
		{
			nxt[i][j]=nxt[nxt[i][j-1]][j-1];
			tim[i][j]=min(inf,tim[i][j-1]+tim[nxt[i][j-1]][j-1]);
		}
	}
}
bool on(int a,int b,int x,int y,int xx,int yy)
{
	if(x>xx) swap(x,xx);if(y>yy) swap(y,yy);
	return x<=a&&a<=xx&&y<=b&&b<=yy;
}
int main()
{
	//freopen("tt.in","r",stdin);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d%d",&q[i].x,&q[i].y,&q[i].xx,&q[i].yy);
		q[i].id=i;
		if(q[i].x==q[i].xx) q[i].d=(q[i].y<q[i].yy)?0:2;
		else q[i].d=(q[i].x<q[i].xx)?1:3;
	}
	cin>>Q;
	for(int i=1;i<=Q;i++)
	{
		scanf("%d%d%s%I64d",&q[i+n].xx,&q[i+n].yy,s,&T[i]);
		q[i+n].id=i+n;q[i+n].x=q[i+n].xx,q[i+n].y=q[i+n].yy;
		if(s[0]=='U') q[i+n].d=0;if(s[0]=='D') q[i+n].d=2; 
		if(s[0]=='R') q[i+n].d=1;if(s[0]=='L') q[i+n].d=3; 
	}
	sort(q+1,q+n+Q+1,cmp1);memset(f,0,sizeof(f));
	for(int i=1;i<=n+Q;i++) 
	{
		if(q[i].d==1) 
		{
			if(q[i].id>n) to[q[i].id-n]=get_pos(0,m,1,q[i].yy);
			else nxt[q[i].id][0]=get_pos(0,m,1,q[i].yy);
		}
		if(q[i].id<=n) update(0,m,1,min(q[i].y,q[i].yy),max(q[i].y,q[i].yy),q[i].id);
	}
	sort(q+1,q+n+Q+1,cmp2);memset(f,0,sizeof(f));
	for(int i=1;i<=n+Q;i++) 
	{
		if(q[i].d==3) 
		{
			if(q[i].id>n) to[q[i].id-n]=get_pos(0,m,1,q[i].yy);
			else nxt[q[i].id][0]=get_pos(0,m,1,q[i].yy);
		}
		if(q[i].id<=n) update(0,m,1,min(q[i].y,q[i].yy),max(q[i].y,q[i].yy),q[i].id);
	}
	sort(q+1,q+n+Q+1,cmp3);memset(f,0,sizeof(f));
	for(int i=1;i<=n+Q;i++) 
	{
		if(q[i].d==0) 
		{
			if(q[i].id>n) to[q[i].id-n]=get_pos(0,m,1,q[i].xx);
			else nxt[q[i].id][0]=get_pos(0,m,1,q[i].xx);
		}
		if(q[i].id<=n) update(0,m,1,min(q[i].x,q[i].xx),max(q[i].x,q[i].xx),q[i].id);
	}
	sort(q+1,q+n+Q+1,cmp4);memset(f,0,sizeof(f));
	for(int i=1;i<=n+Q;i++) 
	{
		if(q[i].d==2) 
		{
			if(q[i].id>n) to[q[i].id-n]=get_pos(0,m,1,q[i].xx);
			else nxt[q[i].id][0]=get_pos(0,m,1,q[i].xx);
		}
		if(q[i].id<=n) update(0,m,1,min(q[i].x,q[i].xx),max(q[i].x,q[i].xx),q[i].id);
	}
	sort(q+1,q+n+Q+1,cmp5);
	solve();
	for(int dis,dis2,i=1;i<=Q;i++) 
	{
		if(to[i])
		{
			if(on(q[i+n].x,q[i+n].y,q[to[i]].x,q[to[i]].y,q[to[i]].xx,q[to[i]].yy)) 
				q[i+n].d=q[to[i]].d;
			dis=abs(q[i+n].xx-q[to[i]].xx)+abs(q[i+n].yy-q[to[i]].yy);
			if(dis>=T[i])
			{
				if(q[i+n].d==0||q[i+n].d==2) dis2=abs(q[i+n].yy-q[to[i]].yy);
				else dis2=abs(q[i+n].xx-q[to[i]].xx);
				if(dis2>=T[i]) printf("%I64d %I64d\n",max(0ll,min((ll)m,q[i+n].xx+dx[q[i+n].d]*T[i])),
							  max(0ll,min((ll)m,q[i+n].yy+dy[q[i+n].d]*T[i])));
				else 
				{
					T[i]-=dis2;
					if(q[i+n].d==0||q[i+n].d==2) q[i+n].yy=q[to[i]].yy;
					else q[i+n].xx=q[to[i]].xx;
					printf("%I64d %I64d\n",max(0ll,min((ll)m,q[i+n].xx+dx[q[to[i]].d]*T[i])),
							  max(0ll,min((ll)m,q[i+n].yy+dy[q[to[i]].d]*T[i])));
				}
			} 
			else
			{
				T[i]-=dis;ll pre=T[i];
				int pos=to[i];
				for(int j=60;j>=0;j--)
				if(tim[pos][j]<=T[i]) 
				{
					T[i]-=tim[pos][j];
					pos=nxt[pos][j];
				}
				if(!pos)
				{
					pos=to[i];T[i]=pre;
					for(int j=60;j>=0;j--)
					if(tim[pos][j]<=T[i]&&nxt[pos][j]) 
					{
						T[i]-=tim[pos][j];
						pos=nxt[pos][j];
					}
					printf("%I64d %I64d\n",max(0ll,min((ll)m,q[pos].xx+dx[q[pos].d]*T[i])),
									  max(0ll,min((ll)m,q[pos].yy+dy[q[pos].d]*T[i])));
				}
				else
				{
					if(nxt[pos][0])
					{
						if(q[pos].d==0||q[pos].d==2) dis2=abs(q[pos].yy-q[nxt[pos][0]].yy);
						else dis2=abs(q[pos].xx-q[nxt[pos][0]].xx);
					} 
					else dis2=0x3f3f3f3f;
					if(dis2>=T[i]) printf("%I64d %I64d\n",max(0ll,min((ll)m,q[pos].xx+dx[q[pos].d]*T[i])),
									  max(0ll,min((ll)m,q[pos].yy+dy[q[pos].d]*T[i])));
					else 
					{
						int tx=q[pos].xx,ty=q[pos].yy;T[i]-=dis2;
						if(q[pos].d==0||q[pos].d==2) ty=q[nxt[pos][0]].yy;
						else tx=q[nxt[pos][0]].xx;
						printf("%I64d %I64d\n",max(0ll,min((ll)m,tx+dx[q[nxt[pos][0]].d]*T[i])),
									  max(0ll,min((ll)m,ty+dy[q[nxt[pos][0]].d]*T[i])));
					}
				}
			}
		}
		else printf("%I64d %I64d\n",max(0ll,min((ll)m,q[i+n].xx+dx[q[i+n].d]*T[i])),
							  max(0ll,min((ll)m,q[i+n].yy+dy[q[i+n].d]*T[i])));
	}
}

