#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <vector>
#include <set>
#define N 200010
#define int64 long long
#define mk(x,y) make_pair(x,y)
#define fi first
#define se second
#define For(i,x,y) for (i=x;i<=y;i++)
using namespace std;
struct res {
	int x,y,z;
} xun[N],arr[N];
int i,j,k,n,m,K,t,TY,num;
int fa[N][20],id[N],tr[N*4],f[N],Id[N],Se[N],dep[N];
int64 ti[N],len[N][20],sum[N];
vector<pair<int,int64> > c[N],hu[N];
set<pair<int,int> > Set[N];
typedef set<pair<int,int> >::iterator w1;

struct wen {
	int x,y,ty,di,id;
	inline void read() {
		char p[3];
		scanf("%d%d%s",&x,&y,p);
		if (p[0]=='U'||p[0]=='D') ty=1;
		else ty=2;
		if (p[0]=='U'||p[0]=='R') di=1;
		else di=-1;
		id=i;
	}
} b[N],q[N],w[N];

struct ww {
	int x,l,r,di,ty;
	inline void read() {
		int x1,y1,x2,y2;
		scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
		if (x1==x2) {
			x=x1,ty=1;
			l=y1,r=y2;
		} else {
			x=y1,ty=2;
			l=x1,r=x2;
		}
		if (l>r) swap(l,r),di=-1;
		else di=1;
		if (ty==1) y2+=di;
		else x2+=di;
		b[++t]=(wen){x2,y2,ty,di,-i};
		w[i]=(wen){x1,y1,ty,di};
	}
} a[N];

inline bool cc(const wen &A,const wen &B) {
	if (TY==1) return A.y>B.y;
	if (TY==2) return A.y<B.y;
}
inline bool cc1(const int &A,const int &B) {
	if (TY==1) return a[A].x>a[B].x;
	if (TY==2) return a[A].x<a[B].x;
}
void cover(int q,int x,int y,int l,int r,int k) {
	if (l<=x&&y<=r) {
		tr[q]=k;
		return;
	}
	int mid=(x+y)/2;
	if (l<=mid) cover(q*2,x,mid,l,r,k);
	if (mid<r) cover(q*2+1,mid+1,y,l,r,k);
}
int cal(int q,int x,int y,int k) {
	if (x==y) return tr[q];
	int mid=(x+y)/2,an=tr[q],re;
	if (k<=mid) re=cal(q*2,x,mid,k);
	else re=cal(q*2+1,mid+1,y,k);
	return max(an,re);
}
inline void get(wen O,int x,int Ty) {
	int s1,s2;
	s1=s2=0;
	if (!Ty) {
		if (!x) s1=m-O.y;
		else if (a[x].ty==1) s1=max(O.y,a[x].l)-O.y,
			s2=a[x].di>0?max(O.y-a[x].l,0):a[x].r-max(O.y,a[x].l);
		else s1=a[x].x-O.y,s2=abs(O.x-(a[x].di>0?a[x].l:a[x].r));
	} else {
		if (!x) s1=O.y;
		else if (a[x].ty==1) s1=O.y-min(O.y,a[x].r),
			s2=a[x].di>0?min(a[x].r,O.y)-a[x].l:max(a[x].r-O.y,0);
		else s1=O.y-a[x].x,s2=abs(O.x-(a[x].di>0?a[x].l:a[x].r));
	}
	int A=O.id;
	if (A>0) xun[A]=(res){x,s1,s2};
	else arr[-A]=(res){x,s1+a[-A].r-a[-A].l+1,s2};
}
inline void work() {
	//^ ty=1,di=1 -> ty=2,di=1
	For(i,0,m) Set[i].clear();
	int s=0;
	For(i,1,n) if (a[i].ty==1) {
		Set[a[i].x].insert(mk(a[i].l,i));
		Set[a[i].x].insert(mk(a[i].r,i));
	} else id[++s]=i;
	{//^
		memset(tr,0,sizeof(tr));
		TY=1;
		sort(b+1,b+t+1,cc);
		sort(id+1,id+s+1,cc1);
		j=1;
		For(i,1,t) if (b[i].ty==1&&b[i].di==1) {
			wen O=b[i];
			for (;j<=s;j++) {
				int A=id[j];
				if (a[A].x<O.y) break;
				cover(1,0,m,a[A].l,a[A].r,j);
			}
			int ans=0;
			{
				w1 A=Set[O.x].lower_bound(mk(O.y,0));
				if (A!=Set[O.x].end()) ans=A->se;
			}
			{
				int A=id[cal(1,0,m,O.x)];
				if (!ans||A&&a[A].x<a[ans].l) ans=A;
			}
			get(O,ans,0);
		}
	}
	{//v
		memset(tr,0,sizeof(tr));
		TY=2;
		sort(b+1,b+t+1,cc);
		sort(id+1,id+s+1,cc1);
		j=1;
		For(i,1,t) if (b[i].ty==1&&b[i].di==-1) {
			wen O=b[i];
			for (;j<=s;j++) {
				int A=id[j];
				if (a[A].x>O.y) break;
				cover(1,0,m,a[A].l,a[A].r,j);
			}
			int ans=0;
			{
				w1 A=Set[O.x].lower_bound(mk(O.y,N));
				if (A!=Set[O.x].begin()) ans=(--A)->se;
			}
			{
				int A=id[cal(1,0,m,O.x)];
				if (!ans||A&&a[A].x>a[ans].r) ans=A;
			}
			get(O,ans,1);
		}
	}
}
void dfs(int x) {
	res A=arr[x];
	int B=A.x;
	if (!B) {
		hu[num].push_back(mk(x,0));
		return;
	}
	f[x]=1;
	if (f[B]==1) {
		int s=0;
		for (k=x;;) {
			s++;
			Id[k]=num; Se[k]=s;
			sum[num]+=len[k][0];
			hu[num].push_back(mk(k,sum[num]));
			k=arr[k].x;
			if (k==x) break;
		}
	} else dfs(B);
}
void Dfs(int x) {
	int i,j;
	f[x]=1;
	for (i=0;i<c[x].size();i++) {
		int A=c[x][i].fi;
		if (Id[x]&&Id[x]==Id[A]) continue;
		dep[A]=dep[x]+1;
		fa[A][0]=x;
		For(j,1,19) {
			fa[A][j]=fa[fa[A][j-1]][j-1];
			len[A][j]=len[A][j-1]+len[fa[A][j-1]][j-1];
		}
		Dfs(A);
	}
}
inline void Work() {
	For(i,1,n) {
		res A=arr[i];
		if (A.x) {
			int L=arr[A.x].y-arr[i].z;
			c[A.x].push_back(mk(i,L));
			len[i][0]=L;
		}
	}
	For(i,1,n) if (!f[i]) {
		num++;
		dfs(i);
		for (j=0;j<hu[num].size();j++) {
			int A=hu[num][j].fi;
			Dfs(A);
		}
	}
}
inline void print(wen A,int64 ti) {
	int64 x=A.x,y=A.y;
	if (A.ty==1) y+=ti*A.di;
	else x+=ti*A.di;
	if (x<0) x=0;
	if (y<0) y=0;
	if (x>m) x=m;
	if (y>m) y=m;
	printf("%d %d\n",(int)x,(int)y);
}
inline void suan() {
	For(i,1,K) {
		res A=xun[i];
		int64 tim=ti[i];
		if (!A.x||tim<=A.y) print(q[i],tim);
		else {
			tim-=A.y-A.z;
			int B=A.x;
			if (tim<=arr[B].y) {
				print(w[B],tim);
				continue;
			}
			tim-=arr[B].y;
			for (j=19;j>=0;j--) if (fa[B][j]&&tim>=len[B][j]) {
				tim-=len[B][j];
				B=fa[B][j];
			}
			if (Id[B]) {
				int C=Id[B];
				tim%=sum[C];
				int D=Se[B]-1,nn=hu[C].size();
				int64 st=!D?0:hu[C][D-1].se;
				if (tim>=hu[C][nn-1].se-st) {
					tim-=hu[C][nn-1].se-st;
					D=0;
				}
				st=!D?0:hu[C][D-1].se;
				int l=D,r=nn-1,mid;
				for (;l<=r;) {
					mid=(l+r)/2;
					if (hu[C][mid].se-st<=tim) l=mid+1;
					else r=mid-1;
				}
				if (l) tim-=hu[C][l-1].se-st;
				B=hu[C][l].fi;
			}
			if (arr[B].x) tim+=arr[B].z,B=arr[B].x;
			else tim+=arr[B].y;
			print(w[B],tim);
		}
	}
}
int main() {
	//freopen("331d.in","r",stdin);
	scanf("%d%d",&n,&m);
	For(i,1,n) a[i].read();
	scanf("%d",&K);
	For(i,1,K) b[++t].read(),scanf("%I64d",&ti[i]),q[i]=b[t];
	For(i,1,t) b[i].ty=3-b[i].ty,swap(b[i].x,b[i].y);
	For(i,1,n) a[i].ty=3-a[i].ty;
	work();
	For(i,1,t) b[i].ty=3-b[i].ty,swap(b[i].x,b[i].y);
	For(i,1,n) a[i].ty=3-a[i].ty;
	work();
	Work();
	suan();
	return 0;
}