#include <stdio.h>
#include <algorithm>

#define if if (
#define then )
#define do )
#define for for (
#define while while (
#define switch switch (
#define begin {
#define end }

char ch;

template <class T>
inline void read(T &x)
begin
	x=0;ch=getchar();
	while ch<=32 do ch=getchar();
	while ch>32 do begin
		x=x*10+ch-48;ch=getchar();
	end;
end;

#define int64 long long

#define INF 11000000000000000LL

template <class T>
inline T max(T a,T b)
begin
	return a>b?a:b;
end;

template <class T>
inline T min(T a,T b)
begin
	return a<b?a:b;
end;

inline int sgn(int x)
begin
	return x<0?-1:(x>0);
end;

inline int abs(int x)
begin
	return x<0?-x:x;
end;

#define MAXN 200005

int n,m,q;

struct segnode begin
	segnode *l,*r;
	int x;
end;

segnode _seg[MAXN*19*4],*rootU[MAXN],*rootD[MAXN],*rootL[MAXN],*rootR[MAXN],*stot=_seg,*root0;

inline segnode * build(int L,int R)
begin
	segnode *ret=++stot;
	if L!=R then begin
		int mid=(L+R)>>1;
		ret->l=build(L,mid);
		ret->r=build(mid+1,R);
	end;
	return ret;
end;

inline segnode * newsegnode(segnode a)
begin
	*++stot=a;
	return stot;
end;

inline segnode * cover(segnode *a,int l,int r,int x,int L,int R)
begin
	if l==L && r==R then begin
		return newsegnode((segnode){a->l,a->r,x});
	end;
	int mid=(L+R)>>1;
	if r<=mid then begin
		return newsegnode((segnode){cover(a->l,l,r,x,L,mid),a->r,a->x});
	end else if l>mid then begin
		return newsegnode((segnode){a->l,cover(a->r,l,r,x,mid+1,R),a->x});
	end else begin
		return newsegnode((segnode){cover(a->l,l,mid,x,L,mid),cover(a->r,mid+1,r,x,mid+1,R),a->x});
	end;
end;

inline int query(segnode *a,int pos,int L,int R)
begin
	if L==R then return a->x;
	int mid=(L+R)>>1;
	return max(a->x,pos<=mid?query(a->l,pos,L,mid):query(a->r,pos,mid+1,R));
end;

int pt[MAXN*2][60];
int64 dist[MAXN*2][60];
char _dir[MAXN*2];
int _cnt[MAXN*2];

struct Arrow begin
	int x1,y1,x2,y2,id;
end;

inline bool cmpx(const Arrow &a,const Arrow &b)
begin
	return a.x1<b.x1 || (a.x1==b.x1 && a.y1<b.y1);
end;

inline bool cmpy(const Arrow &a,const Arrow &b)
begin
	return a.y1<b.y1 || (a.y1==b.y1 && a.x1<b.x1);
end;

Arrow a[MAXN],a1[MAXN],a2[MAXN];
int n1,n2;

int arrU[MAXN],arrD[MAXN],arrL[MAXN],arrR[MAXN];
int *aUD[MAXN],*aLR[MAXN];
int lUD[MAXN],lLR[MAXN];

inline void build_seg()
begin
	std::sort(a1+1,a1+n1+1,cmpy);
	std::sort(a2+1,a2+n2+1,cmpx);
	int i,j,cnt;
	cnt=0;
	segnode *root=root0;
	for i=0,j=1;i<=m;i++ do begin
		aUD[i]=arrD+cnt;
		while j<=n1 && a1[j].y1==i do begin
			arrD[++cnt]=a1[j].id;
			++lUD[i];
			root=cover(root,min(a1[j].x1,a1[j].x2),max(a1[j].x1,a1[j].x2),cnt,0,m);
			++j;
		end;
		rootD[i]=root;
	end;
	cnt=0;root=root0;
	for i=m,j=n1;i>=0;i-- do begin
		while j>=1 && a1[j].y1==i do begin
			arrU[++cnt]=a1[j].id;
			root=cover(root,min(a1[j].x1,a1[j].x2),max(a1[j].x1,a1[j].x2),cnt,0,m);
			--j;
		end;
		rootU[i]=root;
	end;
	cnt=0;root=root0;
	for i=0,j=1;i<=m;i++ do begin
		aLR[i]=arrL+cnt;
		while j<=n2 && a2[j].x1==i do begin
			arrL[++cnt]=a2[j].id;
			++lLR[i];
			root=cover(root,min(a2[j].y1,a2[j].y2),max(a2[j].y1,a2[j].y2),cnt,0,m);
			++j;
		end;
		rootL[i]=root;
	end;
	cnt=0;root=root0;
	for i=m,j=n2;i>=0;i-- do begin
		while j>=1 && a2[j].x1==i do begin
			arrR[++cnt]=a2[j].id;
			root=cover(root,min(a2[j].y1,a2[j].y2),max(a2[j].y1,a2[j].y2),cnt,0,m);
			--j;
		end;
		rootR[i]=root;
	end;
end;

inline int get_next_arrow(int x,int y,char dir)
begin
	switch dir do begin
		case 'U':
			return arrU[query(rootU[y],x,0,m)];
		case 'D':
			return arrD[query(rootD[y],x,0,m)];
		case 'L':
			return arrL[query(rootL[x],y,0,m)];
		case 'R':
			return arrR[query(rootR[x],y,0,m)];
	end;
end;

inline char get_direction(int x,int y)
begin
	return x?x>0?'R':'L':y>0?'U':'D';
end;

inline int get_dist(int x,int y,char dir,int id)
begin
	switch dir do begin
		case 'U':
			return id?a[id].y1-y:m-y;
		case 'D':
			return id?y-a[id].y1:y;
		case 'L':
			return id?x-a[id].x1:x;
		case 'R':
			return id?a[id].x1-x:m-x;
	end;
end;

inline int get_dist_2(int x,int y,char dir,int id)
begin
	switch dir do begin
		case 'U':
		case 'D':
			return abs(a[id].x2-x);
		case 'L':
		case 'R':
			return abs(a[id].y2-y);
	end;
end;

inline void walk(int x,int y,char dir,int dist,int &X,int &Y)
begin
	switch dir do begin
		case 'U':
			X=x;
			Y=y+dist;
			break;
		case 'D':
			X=x;
			Y=y-dist;
			break;
		case 'L':
			X=x-dist;
			Y=y;
			break;
		case 'R':
			X=x+dist;
			Y=y;
			break;
		default:
			X=x;
			Y=y;
			break;
	end;
end;

inline void find_arrow_U(int x,int y,int &X,int &Y,int &D,int &id)  // Y >= y
begin
	int *A=aLR[x];
	int n=lLR[x];
	if !n || a[A[n]].y2<y then return;
	int l=1,r=n;
	while l<r do begin
		int mid=(l+r)>>1;
		if a[A[mid]].y2<y then l=mid+1; else r=mid;
	end;
	id=A[l];
	D=a[A[l]].y2-y;
	X=x;Y=a[A[l]].y2;
end;

inline void find_arrow_D(int x,int y,int &X,int &Y,int &D,int &id)  // Y <= y
begin
	int *A=aLR[x];
	int n=lLR[x];
	if !n || a[A[1]].y2>y then return;
	int l=1,r=n;
	while l<r do begin
		int mid=(l+r+1)>>1;
		if a[A[mid]].y2>y then r=mid-1; else l=mid;
	end;
	id=A[l];
	D=y-a[A[l]].y2;
	X=x;Y=a[A[l]].y2;
end;

inline void find_arrow_L(int x,int y,int &X,int &Y,int &D,int &id)  // X <= x
begin
	int *A=aUD[y];
	int n=lUD[y];
	if !n || a[A[1]].x2>x then return;
	int l=1,r=n;
	while l<r do begin
		int mid=(l+r+1)>>1;
		if a[A[mid]].x2>x then r=mid-1; else l=mid;
	end;
	id=A[l];
	D=x-a[A[l]].x2;
	Y=y;X=a[A[l]].x2;
end;

inline void find_arrow_R(int x,int y,int &X,int &Y,int &D,int &id)  // X >= x
begin
	int *A=aUD[y];
	int n=lUD[y];
	if !n || a[A[n]].x2<x then return;
	int l=1,r=n;
	while l<r do begin
		int mid=(l+r)>>1;
		if a[A[mid]].x2<x then l=mid+1; else r=mid;
	end;
	id=A[l];
	D=a[A[l]].x2-x;
	Y=y;X=a[A[l]].x2;
end;

inline void get_next_arrow(int x,int y,char dir,int &X,int &Y,int &D,int &id)
begin
	id=0;
	switch dir do begin
		case 'U':
			find_arrow_U(x,y+1,X,Y,D,id);
			break;
		case 'D':
			find_arrow_D(x,y-1,X,Y,D,id);
			break;
		case 'L':
			find_arrow_L(x-1,y,X,Y,D,id);
			break;
		case 'R':
			find_arrow_R(x+1,y,X,Y,D,id);
			break;
	end;
	++D;
end;

inline void init()
begin
	build_seg();
	int i,j;
	for i=1;i<=n;i++ do begin
		_dir[i]=get_direction(a[i].x2-a[i].x1,a[i].y2-a[i].y1);
	end;
	for i=1;i<=n;i++ do begin
		char d=get_direction(a[i].x2-a[i].x1,a[i].y2-a[i].y1);
		int id=get_next_arrow(a[i].x2,a[i].y2,d);
		int id2,X,Y,D;
		get_next_arrow(a[i].x2,a[i].y2,d,X,Y,D,id2);
		if !id then begin
			pt[i][0]=i+n;
			dist[i][0]=get_dist(a[i].x2,a[i].y2,d,0);
			pt[i+n][0]=i+n;
			dist[i+n][0]=1;
		end else begin
			pt[i][0]=i+n;
			pt[i+n][0]=id;
			dist[i+n][0]=get_dist_2(a[i].x2,a[i].y2,d,id);
			dist[i][0]=get_dist(a[i].x2,a[i].y2,d,id);
			_dir[i+n]=_dir[id];
		end;
		
		int xx,yy;
		walk(a[i].x2,a[i].y2,d,dist[i][0],xx,yy);
		a[i+n].x2=xx;a[i+n].y2=yy;
		
		if id2 && D<dist[i][0] then begin
			pt[i][0]=id2;
			dist[i][0]=D;
		end;
	end;
	for i=1;i<=58;i++ do begin
		for j=1;j<=n+n;j++ do begin
			if _cnt[j]<i-1 then continue;
			int p=pt[j][i-1];
			if _cnt[p]<i-1 then continue;
			pt[j][i]=pt[p][i-1];
			if (dist[j][i]=dist[j][i-1]+dist[p][i-1])<=INF then begin
				_cnt[j]=i;
			end;
		end;
	end;
end;

inline int get_arrow(int x,int y)
begin
	int t=arrU[query(rootU[y],x,0,m)];
	if t && a[t].y1==y then return t;
	t=arrL[query(rootL[x],y,0,m)];
	if t && a[t].x1==x then return t;
	return 0;
end;

inline void query(int x,int y,char dir,int64 dist,int &X,int &Y)
begin
	int id;
	if !(id=get_arrow(x,y)) then begin
		id=get_next_arrow(x,y,dir);
		int XX,YY,id2,D;
		get_next_arrow(x,y,dir,XX,YY,D,id2);
		if id2 && (!id || D<get_dist(x,y,dir,id)) then begin
			if dist<=D then begin
				walk(x,y,dir,dist,X,Y);
				return;
			end else begin
				dist-=D;
				id=id2;
			end;
		end else begin
			if !id then begin
				switch dir do begin
					case 'U':
						X=x;
						Y=y+min(1LL*m-y,dist);
						break;
					case 'D':
						X=x;
						Y=y-min(1LL*y,dist);
						break;
					case 'L':
						X=x-min(1LL*x,dist);
						Y=y;
						break;
					case 'R':
						X=x+min(1LL*m-x,dist);
						Y=y;
						break;
				end;
				return;
			end;
			int d1=get_dist(x,y,dir,id);
			if dist<=d1 then begin
				walk(x,y,dir,dist,X,Y);
				return;
			end;
			dist-=d1;
			int d2=get_dist_2(x,y,dir,id);
			walk(x,y,dir,d1,x,y);
			dir=get_direction(a[id].x2-a[id].x1,a[id].y2-a[id].y1);
			if dist<=d2 then begin
				walk(x,y,dir,dist,X,Y);
				return;
			end;
			dist-=d2;
		end;
	end else begin
		dir=get_direction(a[id].x2-a[id].x1,a[id].y2-a[id].y1);
		int D=abs(x-a[id].x2)+abs(y-a[id].y2);
		if dist<=D then begin
			walk(x,y,dir,dist,X,Y);
			return;
		end else begin
			dist-=D;
		end;
	end;
	int cnt=_cnt[id];
	int i;
	for i=cnt;i>=0;i-- do begin
		if i>_cnt[id] then continue;
		if ::dist[id][i]<=dist then begin
			dist-=::dist[id][i];
			id=pt[id][i];
		end;
	end;
	walk(a[id].x2,a[id].y2,_dir[id],dist,X,Y);
end;

int main()
begin
	read(n);read(m);
	root0=build(0,m);
	int i;
	for i=1;i<=n;i++ do begin
		int x1,y1,x2,y2;
		read(x1);read(y1);read(x2);read(y2);
		a[i]=(Arrow){x1,y1,x2,y2,i};
		if y1==y2 then begin
			a1[++n1]=(Arrow){x1,y1,x2,y2,i};
		end else begin
			a2[++n2]=(Arrow){x1,y1,x2,y2,i};
		end;
	end;
	init();
	read(q);
	for i=1;i<=q;i++ do begin
		int x,y;
		char dir;
		int64 dist;
		read(x);read(y);
		ch=getchar();
		while ch<=32 do ch=getchar();
		dir=ch;
		read(dist);
		int X,Y;
		query(x,y,dir,dist,X,Y);
		printf("%d %d\n",X,Y);
	end;
end