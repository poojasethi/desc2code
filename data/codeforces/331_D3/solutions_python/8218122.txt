/*
	Time : 0806Z 20141013
	Task : Codeforces 331D
	Tags : Data Structure
	Stat : Coding
*/
#include <cstdio>
#include <cstring>
#include <iostream>
#include <cstdlib>
#include <algorithm>
#include <vector>
#include <utility>
#include <queue>
#include <functional>
#include <map>
#include <set>
#include <cmath>
#include <numeric>

#define fi first
#define se second
#define fo(i,a,b) for (int i = a; i <= b; i ++)
#define fd(i,a,b) for (int i = a; i >= b; i --)
#define fe(i,x,y) for (int i = x, y = lnk[i]; i; i = nxt[i], y = lnk[i])
#define mkp make_pair
#define pb push_back
#define Fill(x,y) memset(x,y,sizeof(x))
#define Cpy(x,y) memcpy(x,y,sizeof(x))
#define Bit(x,y) ((((x) >> (y)) & 1))
#define mit map<int,SI>::iterator
#define sit SI::iterator

using namespace std;
 
typedef long long LL;
typedef long double DB;
typedef pair <DB, DB> PD;
typedef pair <LL, LL> PLI;
typedef pair <PD, int> PDI;
typedef pair <int, int> PI;
typedef pair <int, PI> PII;
typedef pair <PI, PI> PIII;
typedef set <PI> SI;
typedef vector <int> VI;
 
LL Read()
{
    char c; while (c = getchar(), (c != '-') && (c < '0' || c > '9'));
    bool neg = (c == '-'); LL ret = (neg ? 0 : c - 48);
    while (c = getchar(), c >= '0' && c <= '9') ret = ret * 10 + c - 48;
    return neg ? -ret : ret;
}

const int MAXN = 100005, dx[4] = {-1, 0, 1, 0}, dy[4] = {0, -1, 0, 1};

struct Query
{
	int x, y, d;
	LL s;
} b[MAXN];

struct Event
{
	int x, y1, y2, id;
} c[MAXN * 3];
PIII a[MAXN];
int N, M, B, n, m, t[1 << 18], dir[MAXN];

int nxt[MAXN], wi[MAXN], att[MAXN], atd[MAXN], atc[MAXN];

int top, ti, bel[MAXN], dfn[MAXN], low[MAXN], stk[MAXN];
bool instack[MAXN], mark[MAXN];

VI atp[MAXN], ata[MAXN], cyc[MAXN];

LL sum[MAXN], tocyc[MAXN], cb[MAXN];

PI ans[MAXN];

int clen, cno[MAXN * 2], loc[MAXN];
LL cs[MAXN * 2];

int GetDir(int x1, int y1, int x2, int y2)
{
	if (x1 > x2) return 0;
	if (x1 < x2) return 2;
	return y1 > y2 ? 1 : 3;
}

void init()
{
	scanf("%d%d", &N, &B);
	fo (i, 1, N)
	{
		int x1 = Read(), y1 = Read(), x2 = Read(), y2 = Read();
		a[i].fi = mkp(x1, y1), a[i].se = mkp(x2, y2), dir[i] = GetDir(x1, y1, x2, y2);
	}
	// input data
	scanf("%d", &M);
	fo (i, 1, M)
	{
		b[i].x = Read(), b[i].y = Read();
		char dir; while (dir = getchar(), (dir != 'L') && (dir != 'D') && (dir != 'R') && (dir != 'U'));
		int tp;
		if (dir == 'L') tp = 0;
		if (dir == 'D') tp = 1;
		if (dir == 'R') tp = 2;
		if (dir == 'U') tp = 3;
		b[i].d = tp, b[i].s = Read();
	}
}

PI Rotate90(PI x) { return mkp(x.se, B - x.fi); }

bool cmp(Event x, Event y) { return mkp(x.x, x.id) < mkp(y.x, y.id); }

void Mod(int id, int l, int r, int gl, int gr, int v)
{
	if (gl <= l && r <= gr) { t[id] = v; return; }
	if (t[id]) t[id+id] = t[id+id+1] = t[id], t[id] = 0;
	int mid = (l + r) >> 1;
	if (gl <= mid) Mod(id+id, l, mid, gl, gr, v);
	if (gr > mid) Mod(id+id+1, mid+1, r, gl, gr, v);
}

int Query(int id, int l, int r, int x)
{
	if (l == r) return t[id];
	if (t[id]) t[id+id] = t[id+id+1] = t[id], t[id] = 0;
	int mid = (l + r) >> 1;
	return x <= mid ? Query(id+id, l, mid, x) : Query(id+id+1, mid+1, r, x);
}

void DFS(int x)
{
	dfn[x] = low[x] = ++ ti, stk[++ top] = x, instack[x] = 1;
	if (nxt[x] >= 0)
		if (!dfn[nxt[x]]) DFS(nxt[x]), low[x] = min(low[x], low[nxt[x]]);
			else if (instack[nxt[x]]) low[x] = min(low[x], dfn[nxt[x]]);
	
	if (dfn[x] == low[x])
	{
		for (++ m; stk[top + 1] != x; bel[stk[top]] = m, cyc[m].pb(stk[top]), instack[stk[top --]] = 0);
		reverse(cyc[m].begin(), cyc[m].end());
	}
}

PI Cal(int x1, int y1, int x2, int y2, int d, int s)
{
	if (d & 1)
	{
		// vertical
		if (abs(y1 - y2) < s)
		{
			s -= abs(y1 - y2);
			return x1 < x2 ? mkp(x1 + s, y2) : mkp(x1 - s, y2);
		} else return mkp(x1 + dx[d] * s, y1 + dy[d] * s);
	} else
	{
		// horizontal
		if (abs(x1 - x2) < s)
		{
			s -= abs(x1 - x2);
			return y1 < y2 ? mkp(x2, y1 + s) : mkp(x2, y1 - s);
		} else return mkp(x1 + dx[d] * s, y1 + dy[d] * s);
	}
}

void Solve(int x)
{
	stk[++ top] = x, cb[top] = tocyc[x];
	// solve queries that attaches to node x
	fo (i, 0, (int) atp[x].size() - 1)
	{
		int y = atp[x][i];
		if (atd[y] >= b[y].s)
		{
			// before entering the tree
			if (x)
				ans[y] = Cal(b[y].x, b[y].y, a[x].se.fi, a[x].se.se, b[y].d, b[y].s);
			else
			{
				//if (b[y].s == atd[y]) -- b[y].s;
				ans[y] = mkp(b[y].x + dx[b[y].d] * b[y].s, b[y].y + dy[b[y].d] * b[y].s);
			}
		} else
		{
			b[y].s -= atd[y];
			// has entered the tree
			if (b[y].s >= tocyc[x])
			{
				// entered top cycle
				b[y].s -= tocyc[x];
				if (!clen)
				{
					if (top > 1)
					{
						int z = stk[2];
						if (dir[z] == 0) ans[y] = mkp(0, a[z].fi.se);
						if (dir[z] == 2) ans[y] = mkp(B, a[z].fi.se);
						if (dir[z] == 1) ans[y] = mkp(a[z].fi.fi, 0);
						if (dir[z] == 3) ans[y] = mkp(a[z].fi.fi, B);
					} else
					{
						if (b[y].d == 0) ans[y] = mkp(0, b[y].y);
						if (b[y].d == 2) ans[y] = mkp(B, b[y].y);
						if (b[y].d == 1) ans[y] = mkp(b[y].x, 0);
						if (b[y].d == 3) ans[y] = mkp(b[y].x, B);
					}
				} else
				{
					b[y].s %= cs[clen + 1];
					int po = upper_bound(cs + loc[atc[x]], cs + loc[atc[x]] + clen, cs[loc[atc[x]]] + b[y].s) - cs - 1;
					ans[y] = Cal(a[cno[po]].se.fi, a[cno[po]].se.se, a[cno[po+1]].se.fi, a[cno[po+1]].se.se, dir[cno[po]], b[y].s - cs[po] + cs[loc[atc[x]]]);
				}
			} else
			{
				// on the path to the cycle
				// binary search
				int po = lower_bound(cb + 1, cb + top + 1, cb[top] - b[y].s) - cb;
				if (stk[po-1]) ans[y] = Cal(a[stk[po]].se.fi, a[stk[po]].se.se, a[stk[po-1]].se.fi, a[stk[po-1]].se.se, dir[stk[po]], b[y].s - cb[top] + cb[po]);
					else ans[y] = mkp(a[stk[po]].se.fi + dx[dir[stk[po]]] * (b[y].s - cb[top] + cb[po]), a[stk[po]].se.se + dy[dir[stk[po]]] * (b[y].s - cb[top] + cb[po]));
			}
		}
	}
	// pass it to subtrees
	fo (i, 0, (int) ata[x].size() - 1)
	{
		int y = ata[x][i];
		if (bel[x] != bel[y])
		{
			atc[y] = atc[x], tocyc[y] = tocyc[x] + wi[y];
			Solve(y);
		}
	}
	-- top;
}

int Dist(PI x, PI y) { return abs(x.fi - y.fi) + abs(x.se - y.se); }

void work()
{
	// find the adjacent node
	fo (d, 0, 3)
	{
		n = 0;
		fo (i, 1, N)
		{
			c[++ n].x = min(a[i].fi.fi, a[i].se.fi), c[n].id = i;
			/*if (a[i].fi.se == a[i].se.se) c[n].y1 = c[n].y2 = a[i].fi.se;
				else if  (a[i].fi.se < a[i].se.se) c[n].y1 = a[i].fi.se, c[n].y2 = a[i].se.se - 1;
					else c[n].y1 = a[i].se.se + 1, c[n].y2 = a[i].fi.se;*/
			c[n].y1 = min(a[i].fi.se, a[i].se.se), c[n].y2 = max(a[i].fi.se, a[i].se.se);
					
			if (c[n].y1 == c[n].y2 && a[i].fi.fi > a[i].se.fi)
				// query for this arrow
				c[++ n].x = a[i].se.fi, c[n].y1 = c[n].y2 = a[i].fi.se, c[n].id = -i;
		}
		fo (i, 1, M) if (b[i].d == d && !mark[i])
			c[++ n].x = b[i].x, c[n].y1 = c[n].y2 = b[i].y, c[n].id = i + N;
			
		sort(c + 1, c + n + 1, cmp);
		
		// clear
		Fill(t, 0);
		
		fo (i, 1, n)
			if (c[i].id < 0) // query for arrow
			{
				int x = Query(1, 0, B, c[i].y1);
				nxt[-c[i].id] = x, ata[x].pb(-c[i].id);
				wi[-c[i].id] = x ? Dist(a[x].se, a[-c[i].id].se) : a[-c[i].id].se.fi;
				//Mod(1, 0, B, c[i].y1, c[i].y2, -c[i].id);
			} else
			{
				if (c[i].id > N)
				{
					int x = Query(1, 0, B, c[i].y1), y = c[i].id - N; mark[y] = 1;
					if (x && min(a[x].fi.fi, a[x].se.fi) <= b[y].x && b[y].x <= max(a[x].fi.fi, a[x].se.fi)) b[y].d = dir[x];
					att[y] = x, atp[x].pb(y);
					atd[y] = x ? Dist(a[x].se, mkp(b[y].x, b[y].y)) : b[y].x;
				} else
					Mod(1, 0, B, c[i].y1, c[i].y2, c[i].id);
			}
		
		// rotate anticlockwise
		fo (i, 1, N)
			a[i].fi = Rotate90(a[i].fi), a[i].se = Rotate90(a[i].se);
		
		fo (i, 1, M)
		{
			PI tmp = Rotate90(mkp(b[i].x, b[i].y));
			b[i].x = tmp.fi, b[i].y = tmp.se;
		}
	}
	
	// SCC
	nxt[0] = -1, Fill(stk, -1);
	fo (i, 1, N) if (!dfn[i])
		DFS(i);
		
	// process on those cycles
	top = 0, Solve(0);
	
	fo (i, 1, m) if (cyc[i].size() > 1)
	{
		clen = cyc[i].size();
		fo (j, 0, clen - 1)
			atc[cyc[i][j]] = cno[j + 1] = cno[j + clen + 1] = cyc[i][j], loc[cyc[i][j]] = j + 1;
		
		fo (j, 1, 2 * clen)
			cs[j] = cs[j - 1] + wi[cno[j - 1]];
			
		fo (j, 0, clen - 1)
			Solve(cyc[i][j]);
	}
	
	fo (i, 1, M) printf("%d %d\n", ans[i].fi, ans[i].se);
}

int main()
{
	init();
	work();
	return 0;
}
