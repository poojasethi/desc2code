#include <cstdio>
const int mod = 1000000007;
struct M { long long a[83][83]; };
long long comb[42][42];
long long v[83];
int sz;
M mul(M a, M b) {
	M c;
	for (int i = 0; i < sz; i++) {
		for (int j = 0; j < sz; j++) {
			long long t = 0;
			for (int k = 0; k < sz; k++) {
				t += a.a[i][k] * b.a[k][j];
				t %= mod;
			}
			c.a[i][j] = t;
		}
	}
	return c;
}
M pow(M a, long long n) {
	if (n == 1) {
		return a;
	}
	M res = pow(a, n/2);
	res = mul(res, res);
	if (n & 1) {
		res = mul(res, a);
	}
	return res;
}
int main() {
	long long n, res = 0;
	int k;
	scanf("%I64d%d", &n, &k);
	if (n == 1) {
		printf("1\n");
		return 0;
	} else if (n == 2) {
		long long t = 1 << (k + 1);
		printf("%I64d\n", (1 + t) % mod);
		return 0;
	}
	M a, b;
	comb[0][0] = 1;
	for (int i = 1; i <= 40; i++) {
		for (int j = 1; j < i; j++) {
			comb[i][j] = (comb[i-1][j] + comb[i-1][j-1]) % mod;
		}
		comb[i][0] = comb[i][i] = 1;
	} 
	int K = k + 1;
	sz = K + K + 1;
	for (int i = 0; i < K; i++) {
		a.a[i][i+K] = 1;
		for (int j = 0; j <= i; j++) {
			a.a[i+K][j] = (1ll << (i-j)) % mod * comb[i][j] % mod;
			a.a[i+K][j+K] = comb[i][j] % mod;
		}
		v[i] = 1;
		v[i+K] = (1ll << (i+1)) % mod;
	}
	for (int i = 0; i < K+K; i++) {
		a.a[K+K][i] = a.a[K+K-1][i];
	}
	a.a[K+K][K+K] = 1;
	v[K+K] = (v[K-1] + v[K+K-1]) % mod;
	b = pow(a, n-2);
	for (int i = 0; i < sz; i++) {
		res += b.a[K+K][i] * v[i] % mod;
		res %= mod;
	}
	printf("%I64d\n", res);
	return 0;
}
