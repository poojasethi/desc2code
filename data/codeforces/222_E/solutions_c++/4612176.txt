#include <bits/stdc++.h>

#define st first
#define nd second
#define mp make_pair
#define lli long long int
#define FP( ii,aa,bb ) for( int ii=aa;ii<=bb;ii++ )
#define FM( ii,aa,bb ) for( int ii=aa;ii>=bb;ii-- )
#define mod 1000000007LL
using namespace std;

class matris{
	public:
		lli n,a[100][100];
		matris(){ memset(a,0,sizeof a); }
		matris(int t){ fill( a[0],a[95]+95,1LL ); }
}birim,A(1);

matris operator*( matris A,matris B ){
	matris temp;
	temp.n = A.n;
	FP( i,1,temp.n )
	FP( j,1,temp.n )
	FP( k,1,temp.n )
		temp.a[i][j] = ( temp.a[i][j]+A.a[i][k]*B.a[k][j] )%mod;
	return temp;
}

matris operator^( matris A,lli k ){
	if( !k ) return birim;
	matris t=A^(k/2);
	if( k&1 ) return t*t*A;
	return t*t;
}

int main(){

	lli n,m,k,i,j;
	char a,b;
	cin >> n >> m >> k;
	A.n = m+1;
	birim.n = m+1;
	FP( i,1,m+1 )
		A.a[i][1] = 0,birim.a[i][i]=1;
	
	while(k--){
		cin >> a >> b;
		if( 'a'<=a ) i = a-'a'+2;
		else		 i = a-'A'+28;
		if( 'a'<=b ) j = b-'a'+2;
		else		 j = b-'A'+28;
		A.a[i][j] = 0;
	}
	A = A^n;
	lli res = 0;
	FP( i,1,m+1 ) res = (res+A.a[1][i])%mod;
	cout << res << endl;

}
