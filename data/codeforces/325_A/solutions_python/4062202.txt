from collections import Counter
from itertools import cycle, product as prod, permutations as perm, combinations as comb, combinations_with_replacement as combr
from sys import stdin, stdout
read_ints = lambda: map(int, raw_input().split())
read_floats = lambda: map(float, raw_input().split())

def area(p):
    return (p[1][0]-p[0][0]) * (p[1][1]-p[0][1])

def inside(p, r):
    return r[0][0]<p[0]<r[1][0] and r[0][1]<p[1]<r[1][1]

def seg_touch(a1, a2, b1, b2):
    if a2<=b1 or b2<=a1:
        return False
    return True

def touch(a, b):
    if inside(a[0], b) or inside(a[1], b) or inside(b[0], a) or inside(b[1], a):
        return True

    if a[0][0]==b[0][0] or a[1][0]==b[1][0]:
        if seg_touch(a[0][1], a[1][1], b[0][1], b[1][1]):
            return True

    if a[0][1]==b[0][1] or a[1][1]==b[1][1]:
        if seg_touch(a[0][0], a[1][0], b[0][0], b[1][0]):
            return True

    return False

def main():
    n = input()
    r = []
    for i in range(n):
        p = read_ints()
        r.append([p[0:2], p[2:4]])

    x_min = min(min(p[0][0], p[1][0]) for p in r)
    x_max = max(max(p[0][0], p[1][0]) for p in r)
    y_min = min(min(p[0][1], p[1][1]) for p in r)
    y_max = max(max(p[0][1], p[1][1]) for p in r)

    s_area = (x_max - x_min) * (y_max - y_min)
    s_r = sum(area(p) for p in r)
    if s_area != s_r:
        print 'NO'
        return
    if x_max - x_min != y_max - y_min:
        print 'NO'
        return

    """
    for i, j in comb(range(n), 2):
        if touch(r[i], r[j]):
            print 'NO'
            return
    """
    print 'YES'

if __name__ == '__main__':
    main()
