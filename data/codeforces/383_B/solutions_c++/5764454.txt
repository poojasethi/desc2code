#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <string>
#define REP(i,n) for (int i = 1; i <= (n); ++i)
#define FOR(i,a,b) for (int i = (a); i <= (b); ++i)
#define ROF(i,a,b) for (int i = (a); i >= (b); --i)
#define FEC(p,u) for (edge *p = head[u]; p; p = p->nxt)
using namespace std;
typedef long long LL;
void read(int &x){
	char ch = getchar(); while (ch < '0' || ch > '9') ch = getchar();
	for (x = 0; ch >= '0' && ch <= '9'; ch = getchar()) x = x*10+ch-48;
}

int n, m;
struct point{
	int x, y;
}a[110000];
bool operator<(point u, point v){ return u.x < v.x || u.x == v.x && u.y < v.y; }
int b[300000], lb, c[300000], lc;
int main(){
	read(n); read(m);
	REP(i,m){ read(a[i].x); read(a[i].y); }
	sort(a+1, a+m+1);
	int p = 1, i = 1;
	b[1] = b[2] = 1; lb = 2; b[3] = b[4] = n+1;
	while (p <= m){
		if (i < a[p].x){
			c[1] = b[1], c[2] = n, lc = 2;
			i = a[p].x;
		}else{
			lc = 0;
			int q(1), L(1), R(a[p].y-1);
			while (p <= m && a[p].x == i){
				while (q <= lb && b[q+1] < L) q += 2;
				if (b[q] <= R && L <= R) c[++lc] = max(L, b[q]), c[++lc] = R;
				L = a[p].y+1, R = a[p+1].y-1;
				++p; if (a[p].x != i) R = n;
			}
			while (q <= lb && b[q+1] < L) q += 2;
			if (b[q] <= R && L <= R) c[++lc] = max(L, b[q]), c[++lc] = R;
			++i;
		}
		lb = lc; REP(i,lb) b[i] = c[i]; b[lb+1] = b[lb+2] = n+1;
	}
	if (lb && (i <= n || b[lb] == n)) printf("%d\n", 2*n-2); else printf("-1\n");
	return 0;
}
