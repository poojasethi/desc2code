#include <cstdio>
#include <cstring>
#include <algorithm>
#include <set>
#define FOR(i,s,e) for (int i=(s); i<(e); i++)
#define FOE(i,s,e) for (int i=(s); i<=(e); i++)
#define N 100005
using namespace std;

struct datX{
	int x, y, id;
	bool operator < (datX const &T) const{return x == T.x ? y < T.y : x < T.x;}
};

struct datY{
	int x, y, id;
	bool operator < (datY const &T) const{return y == T.y ? x > T.x : y > T.y;}
};

int n, m, sol, v[N];
datX a[N];
set<datX> X;
set<datY> Y;

void dfs(int id){
	if (v[id]) return;
	v[id] = 1;
	int x = a[id].x, y = a[id].y;
	set<datX>::iterator itr;
	if (x == n || y == 1) sol = 1;
	FOE(i,-1,1) FOE(j,-1,1){
		itr = X.find((datX){x + i, y + j});
		if (itr != X.end()) dfs(itr->id);
	}
	
	itr = X.upper_bound((datX){x, y});
	if (itr != X.end() && itr->x == x) dfs(itr->id);
	itr = X.lower_bound((datX){x + 1, y});
	if (itr != X.end() && itr->x == x + 1) dfs(itr->id);

	{	set<datY>::iterator itr;
		itr = Y.upper_bound((datY){x, y});
		if (itr != Y.end() && itr->y == y) dfs(itr->id);
		itr = Y.lower_bound((datY){x, y - 1});
		if (itr != Y.end() && itr->y == y - 1) dfs(itr->id);
	}
}

int main(){
	scanf("%d%d", &n, &m);
	FOR(i,0,m){
		scanf("%d%d", &a[i].x, &a[i].y);
		a[i].id = i;
		X.insert(a[i]);
		Y.insert((datY){a[i].x, a[i].y, a[i].id});
	}
	
	FOR(i,0,m) if (!v[i]){
		if (a[i].x == 1 || a[i].y == n){
			dfs(i);
		}
	}
	
	printf("%d\n", sol ? -1 : n + n - 2);
	return 0;
}
