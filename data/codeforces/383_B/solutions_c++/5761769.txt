#include<cstdio>
#include<queue>
#include<map>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;

const int MAXN = 100005;
int n, m;
map<int, map<int,int> > grid1, grid2;
pair<int,int> po[MAXN];
queue<int> q;
bool vis[MAXN];
typedef map<int,int>::iterator it;
int main(){
    
    scanf("%d%d",&n,&m);
    int a,b;
    for (int i = 1; i <= m; i ++){
        scanf("%d%d",&a,&b);
        grid1[a][b] = i;
        grid2[b][-a] = i;
        po[i] = make_pair(a,b);
    }
    memset(vis,0,sizeof(vis));
    while (!q.empty()) q.pop();
    for (int i = 1; i <= m; i ++){
        if (po[i].second ==  n|| po[i].first == 1){
            q.push(i);
            vis[i] = 1;
        }
    }
    while (!q.empty()){
        int x = po[q.front()].first, y = po[q.front()].second;
        q.pop();
        if (x == n || y == 1){
            printf("-1\n");
            return 0;
        }
        if (grid1.count(x+1)){
            it nxt = grid1[x+1].lower_bound(y-1); //!y
            if (nxt != grid1[x+1].end() && !vis[nxt->second]){
                vis[nxt->second] = 1;
                q.push(nxt->second);
            }
        }
        if (grid2.count(y-1)){
            it nxt = grid2[y-1].lower_bound(-x-1);
            if (nxt != grid2[y-1].end() && !vis[nxt->second]){
                vis[nxt->second] = 1;
                q.push(nxt->second);
            }
        }
    }
    printf("%d\n",(n-1) * 2);
    return 0;
}
