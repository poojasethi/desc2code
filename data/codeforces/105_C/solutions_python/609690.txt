def better(a, b):
    for i in xrange(len(a)):
        if a[i] < b[i]:
            return False
    return True
related = lambda x, y: 'w' in x and 'g' in y or 'm' in x and 'sen' in y or 'b' in x and 'ph' in y
n = int(raw_input())
weps, arms, orbs = [],[],[]
sumSize = 0
ind = {}
itemlist, naslist = [], []
for i in xrange(n):
    ss = raw_input().split()
    name,typ = ss[0], ss[1]
    atk,dfn,res,siz = (int(ss[i]) for i in xrange(2, len(ss)))
    itemlist.append((name, atk, dfn, res, siz, typ))
    if 'wea' in typ:weps.append((name, atk, dfn, res, siz, typ))
    elif 'arm' in typ: arms.append((name, atk, dfn, res, siz, typ))
    else: orbs.append((name, atk, dfn, res, siz, typ))
    ind[name] = i
    sumSize += siz
nas = int(raw_input())
glads,sents,phys = [],[],[]
belong = [0] * n
ppl = [[] for i in xrange(n)]
used = [False] * nas
for i in xrange(nas):
    ss = raw_input().split()
    name,typ,val,item = ss[0], ss[1], int(ss[2]), ss[3]
    naslist.append((name,typ,val,item))
#    print item, ind[item]
    ppl[ind[item]].append(name)
    if related(itemlist[ind[item]][5], typ):
        belong[ind[item]] += val
    if 'gla' in typ:
        glads.append((val, name, i))
    elif 'sen' in typ:
        sents.append((val, name, i))
    else: 
        phys.append((val, name, i))
glads = sorted(glads, reverse=True)
sents.sort(reverse=True)
phys.sort(reverse=True)
sumG = [0] * len(glads)
if len(glads): sumG[0] = glads[0][0]
for i in xrange(1, len(glads)): sumG[i] = sumG[i - 1] + glads[i][0]
sumS = [0] * len(sents)
if len(sents): sumS[0] = sents[0][0]
for i in xrange(1, len(sents)): sumS[i] = sumS[i - 1] + sents[i][0]
sumP = [0] * len(phys)
if len(phys): sumP[0] = phys[0][0]
for i in xrange(1, len(phys)): sumP[i] = sumP[i - 1] + phys[i][0]
solVal = [-1, -1, -1]
sol = [-1, -1, -1]
for i in xrange(len(weps)):
    for j in xrange(len(arms)):
        for k in xrange(len(orbs)):
            w,a,o = weps[i], arms[j], orbs[k]
            if nas >= sumSize:
                newVal = [w[1] + belong[ind[w[0]]], a[2] + belong[ind[a[0]]], o[3] + belong[ind[o[0]]]]
                if better(newVal, solVal):
                    solVal = newVal
                    sol = [ind[w[0]], ind[a[0]], ind[o[0]]]
                continue
            atk, dfn, res = w[1], a[2], o[3]
            if len(glads): atk += sumG[min(len(sumG), w[4]) - 1]
            if len(sents): dfn += sumS[min(len(sumS), a[4]) - 1]
            if len(phys): res += sumP[min(len(sumP), o[4]) - 1]
            newVal = [atk, dfn, res]
            if better(newVal, solVal):
                solVal = newVal
                sol = [i, j, k]
if nas >= sumSize:
    w,a,o = itemlist[sol[0]], itemlist[sol[1]], itemlist[sol[2]]
    print w[0], w[4], ' '.join(ppl[sol[0]])
    print a[0], a[4], ' '.join(ppl[sol[1]])
    print o[0], o[4], ' '.join(ppl[sol[2]])
else:
    w,a,o = weps[sol[0]], arms[sol[1]], orbs[sol[2]]
    inW, inA, inO = [], [], []
    for i in xrange(min(len(sumG), w[4])):
        inW.append(glads[i][1])
        used[glads[i][2]] = True
    for i in xrange(min(len(sumS), a[4])):
        inA.append(sents[i][1])
        used[sents[i][2]] = True
    for i in xrange(min(len(sumP), o[4])):
        inO.append(phys[i][1])
        used[phys[i][2]] = True
    for shakhs in [i for i in xrange(len(naslist)) if not used[i]]:
        if len(inW) < w[4]: inW.append(naslist[shakhs][0])
        elif len(inA) < a[4]: inA.append(naslist[shakhs][0])
        elif len(inO) < o[4]: inO.append(naslist[shakhs][0])
        
    print w[0], len(inW), ' '.join(inW)
    print a[0], len(inA), ' '.join(inA)
    print o[0], len(inO), ' '.join(inO)
