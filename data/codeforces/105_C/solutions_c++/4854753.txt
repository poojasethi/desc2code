#include <iostream>
#include <cstdio>
#include <vector>
#include <map>
#include <algorithm>

using namespace std;

struct item{
	string type, name;
	int atk, def, res, size;
	void read(){
		 cin >> name >> type >> atk >> def >> res >> size;
	}
};

struct resident{
	string name, type ,belong;
	int strength;
	void read(){
		cin >> name >> type >> strength >> belong;
	}
};

vector<item> weapon, armor, orb;
vector<resident> atk, def, res;
map<string, vector<resident> > keep;

int N, M;

bool greater1 (resident x, resident y){
	return x.strength > y.strength;
}
int sum(const vector<resident>& v, const std::string &a){
	int S = 0;
	for (int i = 0; i < v.size(); i++)
		if (v[i].type == a) 
			S += v[i].strength;
	return S;
}
bool sortatk (item x, item y){
	int Sx = x.atk + sum(keep[x.name],"gladiator"), Sy = y.atk + sum(keep[y.name],"gladiator");
	return Sx > Sy;
}
bool sortdef (item x, item y){
	int Sx = x.def + sum(keep[x.name],"sentry"), Sy = y.def + sum(keep[y.name],"sentry");
	return Sx > Sy;
}

bool sortres (item x, item y){
	int Sx = x.res + sum(keep[x.name],"physician"), Sy = y.res + sum(keep[y.name],"physician");
	return Sx > Sy;
}

void sort1(){
	sort(weapon.begin(), weapon.end(), sortatk);
	sort(armor.begin(), armor.end(), sortdef);
	sort(orb.begin(), orb.end(), sortres);
}

void sort2(){
	sort(atk.begin(), atk.end(), greater1);
	sort(def.begin(), def.end(), greater1);
	sort(res.begin(), res.end(), greater1);
}

void prepare(const vector<item> &s, const vector<resident> &t){
	for (int i = 0; i < s.size(); i++){
		keep[s[i].name].clear();
		for (int j = 0; j < min(s[i].size,(int)t.size()); j++)
			keep[s[i].name].push_back (t[j]);
	}
}
void solve2(){
	sort2();
	prepare(weapon,atk);
	prepare(armor,def);
	prepare(orb,res);
	sort1();
	string _weapon(weapon[0].name), _aromr(armor[0].name), _orb(orb[0].name);
	map<string, int> used;
	for (int i = 0; i < keep[_weapon].size(); i++ )
		used[keep[_weapon][i].name] = 1;
	for (int i = 0; i < keep[_orb].size(); i++ )
		used[keep[_orb][i].name] = 1;
	for (int i = 0; i < keep[_aromr].size(); i++ )
		used[keep[_aromr][i].name] = 1;

	vector <resident> unu;
	for (int i = 0; i < atk.size(); i++ )
		if (!used[atk[i].name]) 
			unu.push_back(atk[i]);
	for (int i = 0; i < def.size(); i++ )
		if (!used[def[i].name]) 
			unu.push_back(def[i]);
	for (int i = 0; i < res.size(); i++ )
		if (!used[res[i].name]) 
			unu.push_back(res[i]);

	int ii = 0;

	int x = weapon[0].size - keep[_weapon].size();
	for (int i = 0; i < x && ii < unu.size(); i++ )
		keep[ _weapon ].push_back(unu[ii++]);

	int y = armor[0].size - keep[ _aromr ].size();
	for (int i = 0; i < y && ii < unu.size(); i++ )
		keep[_aromr].push_back(unu[ii++]);

	int z  = orb[0].size - keep[ _orb ].size();
	for (int i = 0; i < z && ii < unu.size(); i++ )
		keep[_orb].push_back(unu[ii++]);
}

int main(){
	// freopen("C.in","r",stdin);
	scanf("%d",&N);
	int sum = 0;
	for (int i = 0; i < N; i++ ){
		item tmp;
		tmp.read();
		sum += tmp.size;
		if (tmp.type == "weapon")
			weapon.push_back(tmp);
		else if (tmp.type == "armor")
			armor.push_back(tmp);
		else 
			orb.push_back(tmp);
	}

	scanf("%d",&M);
	for (int i = 0; i < M; i++ ){
		resident tmp;
		tmp.read();
		if (tmp.type == "gladiator")
			atk.push_back (tmp);
		else if (tmp.type == "sentry")
			def.push_back (tmp);
		else 
			res.push_back (tmp);
		keep[tmp.belong].push_back(tmp);
	}
	(sum == M)?(sort1()):(solve2());
	cout << weapon[0].name << " " << keep[weapon[0].name].size();
	for (int i = 0; i < keep[weapon[0].name].size(); i++ )
		cout << " " << keep[weapon[0].name][i].name;
	cout << "\n";
	cout << armor[0].name << " " <<  keep[armor[0].name].size();
	for (int i = 0; i < keep[armor[0].name].size(); i++ )
		cout << " " << keep[armor[0].name][i].name;
	cout << "\n";
	cout << orb[0].name << " " << keep[orb[0].name].size();
	for (int i = 0; i < keep[ orb[0].name ].size(); i++ )
		cout << " " << keep[ orb[0].name ][i].name;
	cout << "\n";
}