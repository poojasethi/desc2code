#include <cstdio>
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include <map>
#include <cassert>
using namespace std;

int get_class(string cls) {
	if (cls == "weapon")
		return 0;
	if (cls == "armor")
		return 1;
	assert(cls == "orb");
	return 2;
}

int get_type(string cls) {
	if (cls == "gladiator")
		return 0;
	if (cls == "sentry")
		return 1;
	assert(cls == "physician");
	return 2;
}

struct triple {
	string name;
	int param, size;
	triple(){}
	triple(string name, int param, int size): name(name), param(param), size(size) {}
};

vector <triple> items[3];
vector < pair<int, string> > sub[3];
map <string, int> num, gsum, gcl;
map < string, vector <string> > own;
map < string, bool > used;

int main() {
	int n, sum = 0, p[3], size, k;
	cin >> n;
	for (int i = 0; i < n; ++i) {
		string name, cls;
		cin >> name >> cls >> p[0] >> p[1] >> p[2] >> size;
		gcl[name] = get_class(cls), gsum[name] = 0, own[name].clear();
		items[get_class(cls)].push_back(triple(name, p[get_class(cls)], size));
		gsum[name] += p[get_class(cls)];
		sum += size;
	}
	cin >> k;
	for (int i = 0; i < k; ++i) {
		string name, type, home;
		int bonus;
		cin >> name >> type >> bonus >> home;
		if (get_type(type) == gcl[home]) gsum[home] += bonus;
		own[home].push_back(name);
		sub[get_type(type)].push_back(make_pair(bonus, name));
	}
	bool bad = (k == sum);
	string best_name[3];
	vector <string> best_own[3];
	int best_size[3];
	for (int i = 0; i < 3; ++i) {
		sort(sub[i].rbegin(), sub[i].rend());
		string best = "";
		gsum[best] = -1;
		int bcnt = 0;
		for (int j = 0; j < items[i].size(); ++j) {
			if (!bad) {
				string name = items[i][j].name;
				gsum[name] = items[i][j].param;
				for (int k = 0; k < min((int) sub[i].size(), items[i][j].size); ++k)
					gsum[name] = gsum[name] + sub[i][k].first;
			}
			if (gsum[items[i][j].name] > gsum[best])
				best = items[i][j].name, bcnt = items[i][j].size;
		}
		best_name[i] = best;
		if (bad) {
			for (int j = 0; j < own[best].size(); ++j)
				best_own[i].push_back(own[best][j]);
			best_size[i] = own[best].size();
		} else {
			best_size[i] = bcnt;
			for (int j = 0; j < min(bcnt, (int) sub[i].size()); ++j) {
				best_own[i].push_back(sub[i][j].second);
				used[sub[i][j].second] = true;
			}
		}
	}
	if (!bad) {
		for (int i = 0; i < 3; ++i)
			for (int j = 0; j < sub[i].size(); ++j)
				if (!used[sub[i][j].second])
					for (int k = 0; k < 3; ++k)
						if (best_size[k] > best_own[k].size()) {
							best_own[k].push_back(sub[i][j].second);
							used[sub[i][j].second] = true;
							break;
						}
	}
	for (int i = 0; i < 3; ++i) {
		cout << best_name[i] << " " << best_own[i].size();
		for (int j =0 ; j < best_own[i].size(); ++j)
			cout << " " << best_own[i][j];
		cout << endl;
	}
	return 0;
}