#include <iostream>
#include <cstdlib>
#include <math.h>
#include <cstdio>
#include <map>
#include <vector>
#include <algorithm>

#define REP(i, n) for(int i=0, _n=(n); i<_n; i++)

using namespace std;

int n, k;

struct bonus
{
  int type;
  string name;
  int val[3];
};

int g;

struct comp
{
  bool operator()(const bonus &A, const bonus &B)
  {
    int pos = g;
    while (pos < 3 && A.val[pos] == B.val[pos])
      pos++;
    if (pos == g)
      return A.val[pos] > B.val[pos];
    else
    if (pos < 3)
      return A.val[pos] <= B.val[pos];
    return 0;
  }
};

struct item
{
  int type;
  string name;
  int val[3];
  int size;
  vector<bonus> B;
};

vector<item> IT;
vector<bonus> Bonus;
map<string, bool> used;

int main()
{
  //freopen("input.txt", "r", stdin);
  //freopen("output.txt", "w", stdout);
  scanf("%d", &n);
  REP(i, n)
  {
    item it;
    int p[3], size;
    string Class;
    cin >> it.name >> Class;
    scanf("%d%d%d%d", &it.val[0], &it.val[1], &it.val[2], &it.size);
    if (Class == "weapon")
      it.type = 0;
    if (Class == "armor")
      it.type = 1;
    if (Class == "orb")
      it.type = 2;
    IT.push_back(it);
  }
  scanf("%d", &k);
  REP(i, k)
  {
    bonus bn;
    string Class, home;
    int bon;
    cin >> bn.name >> Class >> bon >> home;
    if (Class == "gladiator")
      bn.type = 0;
    if (Class == "sentry")
      bn.type = 1;
    if (Class == "physician")
      bn.type = 2;
    REP(j, 3)
      bn.val[j] = 0;
    bn.val[bn.type] = bon;
    REP(j, n)
    {
      if (IT[j].name == home)
      {
        IT[j].B.push_back(bn);
        break;
      }
    }
    Bonus.push_back(bn);
  }
  bool flag = 0;
  REP(i, n)
  {
    if (IT[i].size != IT[i].B.size())
    {
      flag = 1;
      break;
    }
  }
  if (flag == 0)
  {
    item bt[3];
    REP(i, 3)
      bt[i].val[i] = -100000000;
    REP(j, 3)
    {
      int bestpar = -10000000;
      //for(int i=(n-1); i>=0; i--)
      REP(i, n)
      {
        if (IT[i].type == j)
        {
          int par = IT[i].val[j];
          REP(r, IT[i].B.size())
            par += IT[i].B[r].val[j];
          
          if (par > bestpar)
          {
            bt[j] = IT[i];
            bestpar = par;
          }
        }
      }
    }
    REP(i, 3)
    {
      cout << bt[i].name << " " << bt[i].B.size();
      REP(j, bt[i].B.size())
      {
        cout << " " << bt[i].B[j].name;
      }
      cout << endl;
    }
  }
  else
  {
    REP(j, 3)
    {
      g = j;
      vector<bonus> bestb;
      bestb.clear();
      int bestnum = -1;
      int bestpar = -1;
      //for(int i=(n-1); i>=0; i--)
      REP(i, n)
      {
        if (IT[i].type == j)
        {
          int par = IT[i].val[j];
          int sz = IT[i].size;
          vector<bonus> tempb;
          tempb.clear();
          sort(Bonus.begin(), Bonus.end(), comp());
          REP(r, k)
          {
            if (sz && !used[Bonus[r].name] && Bonus[r].type <= j)
            {
              used[Bonus[r].name] = 1;
              par += Bonus[r].val[j];
              tempb.push_back(Bonus[r]);
              sz--;
            }
          }
          if (par > bestpar)
          {
            bestpar = par;
            bestnum = i;
            bestb.clear();
            REP(r, tempb.size())
              bestb.push_back(tempb[r]);
          }
          REP(r, tempb.size())
            used[tempb[r].name] = 0;
        }
      }
      cout << IT[bestnum].name << " " << bestb.size();
      REP(i, bestb.size())
      {
        cout << " " << bestb[i].name;
        used[bestb[i].name] = 1;
      }
      cout << endl;
    }
  }
  return 0;
}
