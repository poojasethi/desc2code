#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <cstring>

using namespace std;

#define SZ(X) ((int)(X.size()))
#define REP(I,N) for (int I = 0; I < (N); ++I)
#define MP(X,Y) make_pair((X),(Y))
#define PB push_back
#define ALL(X) X.begin(), X.end()
template <typename T> inline bool checkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }

map<string, int> wid, rid;
string wname[110], rname[1100];

int inc[1100], val[110], wtype[1100], rtype[1100], sz[1100], loc[1100], cnt[1100];
vector<int> item[3], res[3];
bool used[1100];
pair<int, int> best[3];
vector<int> ans[110];


inline int get_wtype(const string &s) {
    if (s == "weapon") return 0;
    if (s == "armor") return 1;
    return 2; 
}

inline int get_rtype(const string &s) {
    if (s == "gladiator") return 0;
    if (s == "sentry") return 1;
    return 2;
}

inline bool cmp_val(const int &l, const int &r) {
    return val[l] > val[r];
}

inline bool cmp_inc(const int &l, const int &r) {
    return inc[l] > inc[r];
}

int main() {
    int N, M;
    cin >> N;
    REP(i, N) {
        string type;
        int atk, def, res;
        cin >> wname[i] >> type >> atk >> def >> res >> sz[i];
        wid[wname[i]] = i;
        int tmp;
        item[tmp = wtype[i] = get_wtype(type)].PB(i);
        if (tmp == 0) {
            val[i] = atk;
        } else if (tmp == 1) {
            val[i] = def;
        } else {
            val[i] = res;
        }
    }
    cin >> M;
    REP(i, M) {
        string type, locname;
        cin >> rname[i] >> type >> inc[i] >> locname;
        loc[i] = wid[locname];
        cnt[loc[i]]++;
        res[rtype[i] = get_rtype(type)].PB(i);
    }
    bool found = false;
    REP(i, N) {
        if (cnt[i] < sz[i]) {
            found = true;
            break;
        }
    }
    if (found) {
        REP(i, 3) {
            sort(ALL(res[i]), cmp_inc);
        }
        REP(i, N) {
            ans[i].clear();
        }
        memset(used, false, sizeof(bool) * M);
        REP(type, 3) {
            best[type] = MP(-1, -1);
            REP(i, SZ(item[type])) {
                int sum = val[item[type][i]];
                for (int j = 0; j < SZ(res[type]) && j < sz[item[type][i]]; ++j) {
                    sum += inc[res[type][j]];
                }
                checkmax(best[type], MP(sum, item[type][i]));
            }
            for (int j = 0; j < SZ(res[type]) && j < sz[best[type].second]; ++j) {
                ans[best[type].second].PB(res[type][j]);
                used[res[type][j]] = true;
            }
        }
        REP(i, M) {
            if (!used[i]) {
                REP(j, N) {
                    if (SZ(ans[j]) < sz[j]) {
                        ans[j].PB(i);
                        break;
                    }
                }
            }
        }
        REP(i, 3) {
            cout << wname[best[i].second] << " " << SZ(ans[best[i].second]);
            REP(j, SZ(ans[best[i].second])) {
                cout << " " << rname[ans[best[i].second][j]];
            }
            cout << endl;
        }
    } else {
        REP(i, 3) {
            REP(j, SZ(res[i])) {
                if (wtype[loc[res[i][j]]] == i) {
                    val[loc[res[i][j]]] += inc[res[i][j]];
                }
            }
        }
        REP(type, 3) {
            sort(ALL(item[type]), cmp_val);
            cout << wname[item[type][0]] << " " << cnt[item[type][0]];
            REP(i, 3) {
                REP(j, SZ(res[i])) {
                    if (loc[res[i][j]] == item[type][0])
                        cout << " " << rname[res[i][j]];
                }
            }
            cout << endl;
        }
    }
    return 0;
}
