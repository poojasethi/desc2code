//By Lin
#include<cstdio>
#include<cstring>
#include<vector>
#include<queue>
#include<algorithm>

#define X first
#define Y second
using namespace std;

struct  Item{
    int  num[3],size,now;
    queue<pair<int,int> > que;
    char name[100];
    void init(char s[]){
        scanf("%s%s%d%d%d%d", name , s , &num[0],&num[1],&num[2],&size );
        now = 0;
    }
};
vector<Item> items[3];
struct  Resident{
    int add,x,y;
    char name[105];
    void init(char s[]){
        char belong[105];
        scanf("%s%s%d%s", name , s, &add, belong );
        for ( x = 0; x<3; x++)
            for ( y = 0; y<items[x].size(); y++) 
                if ( strcmp(items[x][y].name,belong) == 0 ){
                    items[x][y].now ++;
                    return;
                }
    }
};
bool cmp(const Resident& a, const Resident &b ){
    return a.add > b.add;
}
vector<Resident> data[3];
int     sum[10005];
int     used[3],out[3];

int     main(){
    int n,m;
    scanf("%d", &n );
    for (int i = 0; i<n; i++ ) {
        char s[105];
        Item tmp;
        tmp.init(s);
        if ( s[0] == 'w' ) items[0].push_back(tmp);
        else if ( s[0] == 'a' ) items[1].push_back(tmp);
        else items[2].push_back(tmp);
    }
    scanf("%d", &m );
    for (int i = 0; i<m; i++ ) {
        char s[105];
        Resident tmp;
        tmp.init(s);
        int k = 0; 
        if ( s[0] == 's' ) k = 1;
        else if ( s[0] == 'p' ) k = 2; 
        data[k].push_back(tmp);
    }
    bool flag = false;
    for (int i = 0; i<3; i++) for (int j = 0; j<items[i].size(); j++)
        if ( items[i][j].now < items[i][j].size ) flag = true;
    if ( flag ) {
        for (int i = 0; i<3; i++) 
            for (int j = 0; j<items[i].size(); j++) {
                items[i][j].now = 0;
                while ( !items[i][j].que.empty() ) items[i][j].que.pop();
            }
        for (int i = 0; i<3; i++) {
            sort( data[i].begin() , data[i].end(), cmp );
            sum[0] = 0; 
            for (int j = 0; j<data[i].size(); j++) sum[j+1] = sum[j]+data[i][j].add;
            int ans = 0,cnt = data[i].size(); 
            for (int k = 1; k<items[i].size(); k++ )
                if ( items[i][k].num[i]+sum[min(items[i][k].size,cnt)] >
                     items[i][ans].num[i]+sum[min(items[i][ans].size,cnt)]  ) ans = k;
            for (int k = 0; k<items[i].size(); k++ )
                items[i][k].now = 0; 
            used[i] = items[i][ans].now = min(items[i][ans].size,cnt);
            for (int k = 0; k<used[i]; k++) {
                items[i][ans].que.push(make_pair(i,k));
            }
            out[i] = ans;
        }
        for (int i = 0,g=0,h=0; i<3; i++){
            while ( used[i]<data[i].size() ){
                while ( items[g][h].now == items[g][h].size ){
                    h++;
                    if ( items[g].size() == h ) g++ , h = 0; 
                }
//              printf("%s %s\n", items[g][h].name , data[i][used[i]].name );
                items[g][h].now++;
                items[g][h].que.push(make_pair(i,used[i]++));
            }
        }
    }
    else {
        for (int i = 0; i<3; i++) 
            for (int j = 0; j<data[i].size(); j++) 
            {
                if ( data[i][j].x == i )
                    items[i][data[i][j].y].num[i] += data[i][j].add;
                items[data[i][j].x][data[i][j].y].que.push(make_pair(i,j));
            }
        for (int i = 0; i<3; i++){
            out[i] = 0; 
            for (int k = 1; k<items[i].size(); k++)
                if ( items[i][k].num[i] > items[i][out[i]].num[i] ) out[i] = k;
        }
    }
    for (int i = 0; i<3; i++){
        printf("%s %d", items[i][out[i]].name , items[i][out[i]].que.size() );
        while ( !items[i][out[i]].que.empty() ){
            printf(" %s", data[items[i][out[i]].que.front().X][items[i][out[i]].que.front().Y].name );
            items[i][out[i]].que.pop();
        }
        puts("");
    }
}
