#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <ctime>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <algorithm>
#include <stack>
#include <list>
#include <queue>
#include <map>
#include <set>
#include <cassert>
using namespace std;

#define present(c,x) (find(c.begin(),c.end(),x) != (c).end())
#define traverse(v,it) for (typeof(v.begin()) it=v.begin();it!=v.end();it++)
template<class A, class B> A cvt(B x) { stringstream ss; ss<<x; A y; ss>>y; return y; }
typedef long long int64;

typedef struct {
	string name;
	int c;
	int p[3];
	int size;
	int room;
} item;

typedef struct {
	string name;
	int c;
	int bonus;
	string home;
} resident;

int n,k;
map<string, item> items;
map<string, vector<string> > itres;
map<string, resident> residents;

int main() {
	cin >> n;
	for (int i=0;i<n;i++) {
		string name,c;
		int a,d,r,s;
		cin >> name >> c >> a >> d >> r >> s;
		if (c=="weapon") items[name]=(item){name,0,{a,d,r},s,s};
		if (c=="armor") items[name]=(item){name,1,{a,d,r},s,s};
		if (c=="orb") items[name]=(item){name,2,{a,d,r},s,s};
	}
	cin >> k;
	for (int i=0;i<k;i++) {
		string name,c,home;
		int b;
		cin >> name >> c >> b >> home;
		if (c=="gladiator") residents[name]=(resident){name,0,b,home};
		if (c=="sentry") residents[name]=(resident){name,1,b,home};
		if (c=="physician") residents[name]=(resident){name,2,b,home};
		items[home].room--;
		itres[home].push_back(name);
	}
	int move=0;
	traverse(items,it) if (it->second.room>0) move=1;

	if (!move) {
		vector<pair<int,pair<int,string> > > v;
		traverse(items,it) {
			string name=it->first;
			int cl=it->second.c;
			int val=it->second.p[cl];
			traverse(itres[name],itr) {
				if (residents[*itr].c==cl) val+=residents[*itr].bonus;
			}
			v.push_back(make_pair(cl,make_pair(-val,name)));
		}

		sort(v.begin(),v.end());
		int i=0;
		for (int t=0;t<3;t++) {
			while (v[i].first!=t) i++;
			string name = v[i].second.second;
			cout << name << " " << itres[name].size();
			traverse(itres[name],itr) cout << " " << *itr;
			cout << endl;
		}

	} else {
		vector<pair<int,string> > r[3];
		traverse(residents,itr) {
			r[itr->second.c].push_back(make_pair(itr->second.bonus, itr->first));
		}
		int sum[3][1005];
		for (int t=0;t<3;t++) {
			sort(r[t].begin(),r[t].end());
			reverse(r[t].begin(),r[t].end());
			sum[t][0]=0;
			for (int i=1;i<=r[t].size();i++) {
				sum[t][i]=sum[t][i-1]+r[t][i-1].first;
			}
		}
		pair<int,pair<int,int> > best=make_pair(-1,make_pair(-1,-1));
		pair<string, vector<string> > out[3];
		set<string> used;
		traverse(items,it0) if (it0->second.c==0)
		traverse(items,it1) if (it1->second.c==1)
		traverse(items,it2) if (it2->second.c==2) {
			int sz0=min(it0->second.size,(int)r[0].size());
			int sz1=min(it1->second.size,(int)r[1].size());
			int sz2=min(it2->second.size,(int)r[2].size());
			pair<int,pair<int,int> > rez = make_pair(it0->second.p[0]+sum[0][sz0],
										   make_pair(it1->second.p[1]+sum[1][sz1],
													 it2->second.p[2]+sum[2][sz2]));
			if (rez>best) {
				best=rez;
				used.clear();
				vector<string> x0,x1,x2;
				for (int i=0;i<sz0;i++) { x0.push_back(r[0][i].second); used.insert(r[0][i].second); }
				for (int i=0;i<sz1;i++) { x1.push_back(r[1][i].second); used.insert(r[1][i].second); }
				for (int i=0;i<sz2;i++) { x2.push_back(r[2][i].second); used.insert(r[2][i].second); }
				out[0]=make_pair(it0->first,x0);
				out[1]=make_pair(it1->first,x1);
				out[2]=make_pair(it2->first,x2);
			}
		}
		for (int t=0;t<3;t++) {
			traverse(residents,itr) {
				if (out[t].second.size()==items[out[t].first].size) break;
				if (used.count(itr->first)==0) {
					out[t].second.push_back(itr->first);
					used.insert(itr->first);
				}
			}
			cout << out[t].first << " " << out[t].second.size();
			for (int i=0;i<out[t].second.size();i++) cout << " " << out[t].second[i];
			cout << endl;
		}
	}
    return 0;
}

