n = input()
d = map(int, raw_input().split())
f = []
b = []

tree = {}
s = 0
i = 0
any_nz = 0
while i < n:
	s += d[i]
	any_nz = 1 if d[i] else any_nz
	if s in tree:
		prev = tree[s]
		tree[s] = i
		op = f[prev][0]
		op += i - prev - 1
		f.append((op, f[prev][1]))
	else:
		tree[s] = i
		f.append((0, 0 if any_nz == 0 else i + 1))
	i += 1

tree.clear()
s = 0
i = n - 1
any_nz = 0
while i >= 0:
	s += d[i]
	any_nz = 1 if d[i] else any_nz
	if s in tree:
		prev = tree[s]
		tree[s] = i
		op = b[n - prev - 1][0]
		op += prev - i - 1
		b.append((op, b[n - prev - 1][1]))
	else:
		tree[s] = i
		b.append((0, 0 if any_nz == 0 else n - i))
	i -= 1
b.reverse()
b.append((0,0))

min_op = n - 1
i = 0
while i < n:
	op = f[i][0] + b[i + 1][0]
	if f[i][1]:
		op += f[i][1] - 1
		op += b[i + 1][1] if b[i + 1][1] else 0
	else:
		op += b[i + 1][1] - 1 if b[i + 1][1] else 0
	min_op = op if op < min_op else min_op
	i += 1

print min_op

    	    		   	  	  	 			 	 	