#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int ORG=-1e9-2;
const int maxk=301;
const int maxn=100000+10;
struct Node{
    int x,y;
    int val;
    Node(){}
    Node(long long x,long long y,int val): x(x),y(y),val(val){}
    bool operator < (const Node& tmp)const
    {
        if (x!=tmp.x)
            return x<tmp.x;
        return y<tmp.y;
    }
}p[maxn<<1];
int n,K,sz,uni,lim;
long long ans[maxn];
int cnt[maxn*maxk],hash[maxn*maxk];
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while (ch<'0'||ch>'9')
    {
        if (ch=='-')
            f=-1;
        ch=getchar();
    }
    while (ch>='0'&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}
int main()
{
    if (fopen("D.in","r")!=NULL)
    {
        freopen("D.in","r",stdin);
        freopen("D.out","w",stdout);
    }
    n=read(),K=read();
    for (int i=1,x,y;i<=n;i++)
    {
        x=read(),y=read();
        p[i*2-1]=Node(x,y,1);
        p[i*2]=Node(x+K,y,-1);
        for (int j=0;j<K;j++)
            hash[++sz]=y+j;
    }
    lim=n<<1;
    sort(hash+1,hash+sz+1);
    uni=unique(hash+1,hash+sz+1)-hash-1;
    sort(p+1,p+lim+1);
    for (int i=1;i<=lim;i++)
        p[i].y=lower_bound(hash+1,hash+uni+1,p[i].y)-hash;
    for (int i=1;i<=sz;i++)
        hash[i]=ORG;
    for (int i=1,x,y,val;i<=lim;i++)
    {
        x=p[i].x,y=p[i].y;
        val=p[i].val;
        for (int k=0;k<K;k++)
        {
            if (hash[y+k]!=ORG)
                ans[cnt[y+k]]+=x-hash[y+k];
            cnt[y+k]+=val;
            hash[y+k]=x;
        }
    }
    for (int i=1;i<=n;i++)
        printf("%I64d ",ans[i]);
    return 0;
}

                                                                                                                        