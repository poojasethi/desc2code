//my magic will tear you apart!
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
#include <cstdlib>
#include <map>
#include <set>
using namespace std;
#define mp make_pair
#define pb push_back
#define ff first
#define ss second
typedef long long ll;
typedef pair<int, int> pii;
typedef pair<int, pii> pip;

const int N = 100100, K = 305;

int n, k, val[2*N];
ll ans[N];
pip upd[2*N];
map<int, int> id;
int xv[2*N];
set<int> s;

int main() {
  if(fopen("D.in","r")) freopen("D.in","r",stdin);
  
  cin >> n >> k;

  for(int x,y,i = 0; i < n; i++) {
    scanf("%d %d", &x, &y);
    upd[2*i] = (mp(y+k, mp(x-k+1,1)));
    upd[2*i + 1] = (mp(y, mp(x-k+1,-1)));
    s.insert(x-k+1);
    s.insert(x+1);
  }
  int idx = 0;
  for(typeof(s.begin()) it  = s.begin(); it != s.end(); it++) {
    xv[idx++] = *it;
  }

  for(int i = 0; i < idx; i++) {
    id[xv[i]] = i;
  }
  sort(upd, upd + 2*n);

  
  for(int i = 2*n - 1; i >= 0; i--) {
    //cout << upd[i].ff << " " << upd[i].ss.ff << " " << upd[i].ss.ss << endl;
    int curx = upd[i].ss.ff;
    int curi = id[curx];
    while(curi + 1 < idx && xv[curi] < upd[i].ss.ff + k) {
      ll ydist = upd[i].ff - upd[0].ff + 1;
      ans[val[curi]] -= ydist * (xv[curi+1] - xv[curi]);
      val[curi] += upd[i].ss.ss;
      ans[val[curi]] += ydist * (xv[curi+1] - xv[curi]);
      curi++;
    }
  }

  for(int i = 1; i <= n; i++) {
    printf("%I64d ", ans[i]);
  }
  
  return 0;
}