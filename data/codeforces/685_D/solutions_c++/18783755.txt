#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <map>
#define Rep(i, x, y) for (int i = x; i <= y; i ++)
#define Dwn(i, x, y) for (int i = x; i >= y; i --)
#define RepE(i, x) for (int i = pos[x]; i; i = g[i].nex)
#define v g[i].x
using namespace std;
typedef long long ll;
typedef double db;
const int N = 210000, mod = 1000007;
int n, m, q, m1[N * 150]; ll s[N];
struct arr { int x, y, t; } a[N], b[N];
// a.x == b.x ? a.t > b.t 
bool cmpx(arr a, arr b) { return a.x < b.x; }
bool cmpy(arr a, arr b) { return a.y < b.y; }
void insert(int i) {
	int x = b[i].x, y = b[i].y;
	a[++ q] = (arr) { x, y, 1 };
	a[++ q] = (arr) { x + m, y, -1 };
}
int main()
{
	scanf ("%d%d", &n, &m);
	Rep(i, 1, n) {
		scanf ("%d%d", &b[i].x, &b[i].y);
	}
	sort(b + 1, b + n + 1, cmpy);
	Rep(t, 1, n) {
		int y0 = b[t].y - m;
		q = 0, insert(t);
		while (t < n && b[t + 1].y - b[t].y <= m) insert(++ t);
		sort(a + 1, a + q + 1, cmpx);
		Rep(i, 1, q) {
			int x = a[i].x, y = a[i].y - y0, t = a[i].t;
			Rep(j, y - m + 1, y) {
				if (t > 0) {
					int k = ++ m1[j];
					s[k - 1] += x, s[k] -= x;
				} else {
					int k = m1[j] --;
					s[k] += x; s[k - 1] -= x;
				}
			}
		}
	}
	Rep(i, 1, n) printf("%I64d ", s[i]);

	return 0;
}
