#include <bits/stdc++.h>
#define FOR(i, l, r) for (int i = int(l); i < int(r); i++)
#define STRUCT3(NAME, v1, v2, v3, name) typedef struct NAME \
        {   \
            int v1, v2, v3; \
            NAME(int v1 = 0, int v2 = 0, int v3 = 0) : v1(v1), v2(v2), v3(v3) {} \
            bool operator < (NAME& other) \
            {   \
                if (this -> v1 != other.v1) return this -> v1 < other.v1;   \
                if (this -> v2 != other.v2) return this -> v2 < other.v2;   \
                if (this -> v3 != other.v3) return this -> v3 < other.v3;   \
            }   \
        }name
#define FST first
#define SCD second
#define modp 1000000007
#define EPS 1e-7
#define MAXN 100013
using namespace std;
typedef long long LL;
typedef unsigned int UI;

STRUCT3(POINT, x, y, v, P);
int N, K;

P pt[MAXN * 3];
LL ans[MAXN];
int tmpans[MAXN * 2];
int num[MAXN * 2];
int mapy[MAXN * 2];
int loc[MAXN * 2];
bool cmpx(const P& a, const P& b)
{
    return a.x < b.x;
}
bool cmpy(const P& a, const P& b)
{
    return a.y < b.y;
}
void solve(int k, int x)
{
    int y = pt[k].y;
    int S = 0;
    while (y >= 0 && mapy[pt[k].y] - mapy[y] < K) {
        S += num[y--];
    }
    y++;
    int up = pt[k].y;
    int down = y;
    while (down <= pt[k].y) {
        ans[S] += (LL)(mapy[up + 1] - mapy[up]) * (x - loc[up]);
        loc[up] = x;
        up++;
        S += num[up];
        while (mapy[up] - mapy[down] >= K) {
            S -= num[down++];
        }
    }
}
int main()
{
    scanf("%d%d", &N, &K);
//    N = 100000;
//    K = 300;
    srand(time(0));
    FOR(i, 0, N) {
        scanf("%d%d", &pt[i].x, &pt[i].y);
//        pt[i].x = (rand() << 16) + rand();
//        pt[i].y = (rand() << 16) + rand();
        pt[i + N].x = pt[i].x + K;
        pt[i + N].y = pt[i].y;
        pt[i].v = 1;
        pt[i + N].v = -1;
        pt[i + 2 * N].y = pt[i].y + K;
    }
    sort(pt, pt + 3 * N, cmpy);
    int k = 0;
    int last = pt[0].y;
    mapy[0] = pt[0].y;
    FOR(i, 0, 3 * N) {
        if (pt[i].y > last) {
            k++;
            mapy[k] = pt[i].y;
            last = pt[i].y;
        }
        pt[i].y = k;
    }
    mapy[k + 1] = 0x7fffffff;
    k = 3 * N;
    FOR(i, 0, 2 * N) {
        while (pt[i].v == 0) {
            pt[i] = pt[--k];
        }
    }
    sort(pt, pt + 2 * N, cmpx);
    k = 0;
    last = pt[0].x;
    int head = 0;
    FOR(i, 0, 2 * N) {
        if (pt[i].x > last) {
            k++;
            last = pt[i].x;
            FOR(j, head, i) {
                num[pt[j].y] += pt[j].v;
            }
            head = i;
        }
        solve(i, pt[i].x);
    }
    FOR(i, 1, N + 1) {
        printf("%I64d%c", ans[i], " \n"[i == N]);
    }
    return 0;
}
