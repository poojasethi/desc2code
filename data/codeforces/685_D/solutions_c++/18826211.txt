#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <vector>

#define i64 long long

#define REP(i, x, y) for (int i = (x), _ = (y); i < _; ++ i)
#define rep(i, x, y) for (int i = (y) - 1, _ = (x); i >= _; -- i)

template <typename T> inline bool Chkmax(T &x, T y) { return x < y? x = y, true : false; }
template <typename T> inline bool Chkmin(T &x, T y) { return y < x? x = y, true : false; }

namespace Main
{
    const int MAXN = 1e5 + 1e4, oo = 0x3f3f3f3f, MAXNK = 3e7 + 1;

    int n;
    int k;
    
    struct Point
    {
        int x, y;
        Point(int x = 0, int y = 0):
            x(x), y(y) {}
    } a[MAXN];

    struct Status
    {
        int fr, to;
        int x;
        int con;
        
        Status(int x = 0, int fr = 0, int to = 0, int con = 0):
            x(x), fr(fr), to(to), con(con) {}
        
        inline bool operator < (const Status &a) const { return x < a.x; }
    } s[MAXN * 2];

    int tots;
    int tsz;
    int tong[MAXNK];

    i64 ans[MAXN];

    void Solve()
    {
        REP (i, 0, n)
	    REP (j, 0, k)
		tong[tsz ++] = a[i].y + j;

	std::sort(tong, tong + tsz);
	tsz = std::unique(tong, tong + tsz) - tong;

	REP (i, 0, n)
	    a[i].y = std::lower_bound(tong, tong + tsz, a[i].y) - tong;

	REP (i, 0, n) {
	    s[tots ++] = Status(a[i].x + 0, a[i].y, a[i].y + k, +1);
	    s[tots ++] = Status(a[i].x + k, a[i].y, a[i].y + k, -1);
	}

	std::sort(s, s + tots);


	int *sumv = tong;
	static int last[MAXNK];

	memset(sumv, 0x3f, sizeof(tong));
	
	REP (i, 0, tots) {
	    REP (j, s[i].fr, s[i].to) {
		if (sumv[j] == oo)
		    sumv[j] = 0;
		else
		    ans[sumv[j]] += s[i].x - last[j];

		last[j] = s[i].x;
		sumv[j] += s[i].con;
	    }
	}

	REP (i, 1, n + 1)
	    printf("%lld ", ans[i]);
    }
    
    void Input()
    {
        int x, y;
        scanf("%d%d", &n, &k);
        REP (i, 0, n) {
            scanf("%d%d", &x, &y);
            a[i] = Point(x, y);
        }
    }
    
    void Exec()
    {
        Input();
        Solve();
    }
}

int main()
{
    if (fopen("D.in", "r") != NULL) {
        freopen("D.in", "r", stdin);
        freopen("D.out", "w", stdout);
    }

    Main::Exec();

    return 0;
}
