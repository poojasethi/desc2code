#include <stdio.h>
#include <iostream>
#include <algorithm>
using namespace std;
const int INF = 1<<29;
struct abc{
    int left, right, capacity, cost;
}edge[12345];

int n, k, x, e = 0, cost[50], p[50];

void addEdge(int a, int b, int c, int d)
{
    edge[e].left = a; edge[e].right = b; edge[e].capacity = c; edge[e].cost = d;
    e++;
    edge[e].left = b; edge[e].right = a; edge[e].capacity = 0; edge[e].cost = -d;
    e++;
}

bool getPath(int s, int t)
{
    for(int i = 0; i < n; i++)
        cost[i] = INF;
    cost[s] = 0;
    bool upd = true;
    for(int it = 1; upd && it < n; it++)
        for(int i = upd = 0; i < e; i++)
            if(edge[i].capacity > 0 && cost[edge[i].left] < INF && cost[edge[i].right] > cost[edge[i].left] + edge[i].cost)
            {
                cost[edge[i].right] = cost[edge[i].left] + edge[i].cost;
                p[edge[i].right] = i;
                upd = true;
            }
    return cost[t] < INF;
}

int minCostMaxFlow(int s, int t)
{
    int MaxFlow = 0, MinCost = 0, flow;
    while(getPath(s, t))
    {
        MinCost += cost[t];
        if(MinCost > k)
            return MaxFlow;
        flow=INF;
        for(int c = t; c !=s; c = edge[p[c]].left)
        {
            flow = min(flow, edge[p[c]].capacity);
            if(edge[p[c]].cost != 0)
                flow = 1;
        }
        for(int c = t; c != s; c = edge[p[c]].left)
        {
            edge[p[c]].capacity -= flow;
            edge[p[c]^1].capacity += flow;
        }
        MaxFlow += flow;
    }
    return MaxFlow;
}

int main()
{
    cin >> n >> k;
    for(int i = 0; i < n; i++)
        for(int j = 0; j < n; j++)
        {
            cin >> x;
            if (x)
            {
                addEdge(i, j, x, 0);
                addEdge(i, j, INF, 1);
            }
        }
    cout << minCostMaxFlow(0, n - 1);
}
