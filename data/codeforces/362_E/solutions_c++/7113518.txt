#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>

using namespace std;

const int MaxN = 10010;
const int INF = 0x3f3f3f3f;

struct Node{
	int v,c,cost;
	Node *next,*twin;
}pool[MaxN],*g[55],*tail=pool,*pre[55];
int d[55],flow[55];
int n,k;

void make_edge(int u,int v,int c,int cost){
	tail->v=v;tail->c=c;tail->cost=cost; tail->twin=tail+1;tail->next=g[u];g[u]=tail++;
	tail->v=u;tail->c=0;tail->cost=-cost;tail->twin=tail-1;tail->next=g[v];g[v]=tail++;
}

int spfa(){
	queue<int> q;
	static int inq[55];
	memset(d,0x3f,sizeof(d));d[1]=0;
	memset(flow,0,sizeof(flow));flow[1]=INF;
	memset(inq,0,sizeof(inq));inq[1]=1;
	memset(pre,0,sizeof(pre));q.push(1);
	while(!q.empty()){
		int u=q.front();q.pop();inq[u]=0;
		for(Node *p=g[u];p;p=p->next) if(p->c>0 && p->cost+d[u]<d[p->v]){
			d[p->v]=p->cost+d[u];pre[p->v]=p;flow[p->v]=min(flow[u],p->c);
			if(!inq[p->v]) inq[p->v]=1,q.push(p->v);
		}
	}
	return d[n]<INF;
}
int aug(int &res){
	if(1LL*flow[n]*d[n]>k) {res+=k/d[n];return 0;}
	k-=flow[n]*d[n];res+=flow[n];
	for(Node *p=pre[n];p;p=pre[p->twin->v]) p->c-=flow[n],p->twin->c+=flow[n];
	return 1;
}
int costFlow(){
	int res=0;
	while(spfa()) if(!aug(res)) break;
	return res;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			int c;scanf("%d",&c);
			if(c && i<n) make_edge(i,j,c,0),make_edge(i,j,INF,1);
		}
	printf("%d\n",costFlow());
	return 0;
}
