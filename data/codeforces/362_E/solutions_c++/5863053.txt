#include <bits/stdc++.h>
using namespace std;

const int E = 50010;
const int oo = 1000000000;
const int N = 110;

struct edge
{
	int next,v,flow,cost;
}e[E];

int head[N],cnt;
queue<int> q;

void addedge(int u,int v,int flow,int cost)
{
	e[cnt].v = v;
	e[cnt].flow = flow;
	e[cnt].cost = cost;
	e[cnt].next = head[u];
	head[u] = cnt ++;
}

void addEdge(int u,int v,int flow,int cost)
{
	addedge(u,v,flow,cost);
	addedge(v,u,0, -cost);
}

int S,T;

void init(int n)
{
	int c[N][N];
    S = 0,T = n + 1;
    cnt = 0;
    memset(head,-1,sizeof(head));
    addEdge(S,1,oo,0);
    addEdge(n,T,oo,0);
    for(int i = 1; i <= n; i ++) {
        for(int j = 1; j <= n; j ++) {
            scanf("%d",&c[i][j]);
            if(c[i][j]) {
                addEdge(i,j,c[i][j],0);
                addEdge(i,j,oo,1);
            }
            
        }
    }
}

int dis[N],cc[N],visit[N],pre[N],dd[N];

int spfa()
{
	fill(dis,dis + T + 1, oo);
	dis[S] = 0;
	pre[S] = -1;
	q.push(S);
	while(!q.empty()) {
		int u = q.front();
		q.pop();
		visit[u] = 0;
		for(int i = head[u]; i != -1; i = e[i].next) {
			if(e[i].flow > 0 && dis[e[i].v] > dis[u] + e[i].cost) {
				dis[e[i].v] = dis[u] + e[i].cost;
				pre[e[i].v] = u;
				cc[e[i].v] = i;
				dd[e[i].v] = e[i].cost;
				if(!visit[e[i].v]) {
					q.push(e[i].v);
					visit[e[i].v] = 1;
				}
			}
		}
	}
	return dis[T] != oo;
}

int argument(int &m)
{
	int aug = oo;
	int u,v;
	int ans = 0;
	for(u = pre[v = T]; v != S; v = u, u = pre[v])
		if(e[cc[v]].flow < aug) aug = e[cc[v]].flow;
	for(u = pre[v = T]; v != S; v = u, u = pre[v]) {
		e[cc[v]].flow -= aug;
		e[cc[v] ^ 1].flow += aug;
	}
    if((long long)dis[T] * aug > m) {
        ans = m / dis[T];
        m = -1;
    }
    else {
        ans =  aug;
        m -= dis[T] * aug;
    }
    //cout << dis[T] << " " << aug << endl;
	return ans;
}

void mcmf(int m) 
{
	int ans = 0;
	memset(visit,0,sizeof(visit));
	while(spfa() && m >= 0) ans += argument(m);
	printf("%d\n",ans);
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
	init(n);
	mcmf(m);
	return 0;
}




		  			  	   			     	 	