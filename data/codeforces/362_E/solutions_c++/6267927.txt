#include <iostream>
#include <cstdlib>
#include <cstring>
#include <string>
#include <vector>
#include <utility>
#include <algorithm>
#include <cmath>
#include <queue>
#define INF 1000000000

using namespace std;

struct edge {
	int a,b,cap,cost;
	edge() {}
	edge(int a, int b, int cap, int cost) : a(a), b(b), cap(cap), cost(cost) {}
};

int n,k;
vector<edge> E;
vector<int> e[51];
int d[51],prev[51];
queue<int> q;
bool inq[51];

void addEdge(int a, int b, int cap, int cost) {
	e[a].push_back(E.size());
	E.push_back(edge(a,b,cap,cost));
	e[b].push_back(E.size());
	E.push_back(edge(b,a,0,-cost));
}

void spfa() {
	for (int i = 0; i < n; i++) d[i] = INF;
	d[0] = 0;
	q.push(0);
	while (!q.empty()) {
		int a = q.front();
		q.pop();
		inq[a] = 0;
		for (int i = 0; i < e[a].size(); i++) {
			int b = E[e[a][i]].b, cost = E[e[a][i]].cost;
			if (E[e[a][i]].cap > 0 && d[a] + cost < d[b]) {
				d[b] = d[a] + cost;
				prev[b] = e[a][i];
				if (!inq[b]) {
					q.push(b);
					inq[b] = 1;
				}
			}
		}
	}
}

int calcFlow() {
	int totFlow = 0, totCost = 0;
	while (1) {
		spfa();
		if (d[n-1] == INF) break;
		
		int cap = (d[n-1] == 0 ? INF : (k-totCost)/d[n-1]);
		if (cap == 0) break;
		for (int i = n-1; i != 0; i = E[prev[i]].a) {
			cap = min(cap,E[prev[i]].cap);
		}
		for (int i = n-1; i != 0; i = E[prev[i]].a) {
			E[prev[i]].cap -= cap;
			E[prev[i]^1].cap += cap;
		}
		totFlow += cap;
		totCost += cap*d[n-1];
	}
	return totFlow;
}

int main() {
	cin >> n >> k;
	for (int i = 0; i < n; i++) {
		for (int j = 0,m; j < n; j++) {
			cin >> m;
			if (m) {
				addEdge(i,j,m,0);
				addEdge(i,j,INF,1);
			}
		}
	}
	cout << calcFlow() << '\n';
}