#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#define pb push_back
#define mp make_pair
#define fi first
#define se second 
#define eps 1e-8
#define mo 1000000007
#define inf 168430090
using namespace std;
typedef long long LL;
int n,k,tot=1,ans,sum,flag=1,st,en;
int p[105],d[105],q[10005];
int b[50005],c[50005],e[50005],h[105],w[50005],pre[50005];

void Add(int x,int y,int z,int l){
    b[++tot]=y; c[tot]=z; w[tot]=l; e[tot]=h[x]; h[x]=tot;
    b[++tot]=x; c[tot]=0; w[tot]=-l; e[tot]=h[y];h[y]=tot;
}

int Spfa()
{
    for (int i=0;i<n;i++)p[i]=0;
    for (int i=0;i<n;i++)d[i]=inf;
    int l=0,r=1;
    p[st]=1; d[st]=0; q[1]=st;
    while (l<r)
    {
        l++; p[q[l]]=0;
        for (int go=h[q[l]];go;go=e[go])
        if (c[go]&&d[b[go]]>d[q[l]]+w[go])
        {
            d[b[go]]=d[q[l]]+w[go]; 
            pre[b[go]]=go;
            if (p[b[go]]==0)
            {
                p[b[go]]=1;
                q[++r]=b[go];
            }
        }
    }
    return d[en]<inf;
}

void Push_flow()
{
    int flow=inf;
    for (int go=en;go!=st;go=b[pre[go]^1])
        flow=min(flow,c[pre[go]]);
    if ((LL)sum+(LL)flow*(LL)d[en]<=(LL)k){
        sum+=flow*d[en]; ans+=flow;} 
    else {
            ans+=(k-sum)/d[en]; flag=0; return;}
    for (int go=en;go!=st;go=b[pre[go]^1])
        c[pre[go]]-=flow,c[pre[go]^1]+=flow;
}

int main(){
    scanf("%d%d",&n,&k);
    int x;
    for (int i=0;i<n;i++)
        for (int j=0;j<n;j++){
            scanf("%d",&x);
            if (x){
                Add(i,j,x,0);
                Add(i,j,inf,1);
            }
        }
    st=0; en=n-1;
    while (flag&&Spfa()) Push_flow();
    printf("%d",ans);
    return 0;
}
