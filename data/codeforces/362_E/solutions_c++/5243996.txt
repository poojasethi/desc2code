#include <cstdio>
#include <algorithm>
#include <vector>
#include <queue>
#include <string.h>
#define x first
#define y second
#define pb push_back
#define mp make_pair
using namespace std;
typedef long long LL;
typedef double ld;
typedef pair<int,int> pii;
const int NMax=100;
int N,K,D[NMax],D1[NMax],inq[NMax],pre[NMax];
pii P[NMax];
queue<int>Q;
vector<pii>G[NMax];
int main()
{
	scanf("%d%d",&N,&K);
	for(int i=1;i<=N;i++) {
		for(int j=1;j<=N;j++) {
			int x;
			scanf("%d",&x);
			if(x) G[i].pb(mp(j,x));
		}
	}
	int ret=0;
	while(1){
	memset(D,-1,sizeof(D));
	memset(pre,-1,sizeof(pre));
	Q.push(1);D[1]=0;
	while(!Q.empty()) {
		int x=Q.front();Q.pop();inq[x]=0;
		for(int i=0;i<G[x].size();i++) if(G[x][i].y&&(D[G[x][i].x]==-1||D[G[x][i].x]>D[x]+1)){
			D[G[x][i].x]=D[x]+1;
			pre[G[x][i].x]=x;
			P[G[x][i].x]=mp(x,i);
			if(!inq[G[x][i].x]){
				inq[G[x][i].x]=1;
				Q.push(G[x][i].x);
			}
		}
	}
	if(D[N]==-1) break;
	//ret+=D[N];
	int p=N,minn=100000000;
	while(pre[p]!=-1) {
		pii x=P[p];
		minn=min(minn,G[x.x][x.y].y);
		p=pre[p];	
	}
	p=N;
	ret+=minn;
	while(pre[p]!=-1) {
		pii x=P[p];
		G[x.x][x.y].y-=minn;
		p=pre[p];
	}
	}
	while(1) {
	memset(D,-1,sizeof(D));
	memset(pre,-1,sizeof(pre));
	Q.push(1);D[1]=0;
	while(!Q.empty()) {
		int x=Q.front();Q.pop();inq[x]=0;
		for(int i=0;i<G[x].size();i++) if(G[x][i].y&&(D[G[x][i].x]==-1||D[G[x][i].x]>D[x])){
			D[G[x][i].x]=D[x];
			pre[G[x][i].x]=x;
			P[G[x][i].x]=mp(x,i);
			if(!inq[G[x][i].x]){
				inq[G[x][i].x]=1;
				Q.push(G[x][i].x);
			}
		}else if(G[x][i].y==0&&(D[G[x][i].x]==-1||D[G[x][i].x]>D[x]+1)) {
			D[G[x][i].x]=D[x]+1;
			pre[G[x][i].x]=x;
			P[G[x][i].x]=mp(x,i);
			if(!inq[G[x][i].x]) {
				inq[G[x][i].x]=1;
				Q.push(G[x][i].x);
			}
		}
	}
	if(D[N]==-1||K<D[N]) break;
	ret++;
	K-=D[N];
	int p=N;
	while(pre[p]!=-1) {
		pii x=P[p];
		if(G[x.x][x.y].y)G[x.x][x.y].y--;
		p=pre[p];	
	}	
	}
	printf("%d\n",ret);
	getchar();getchar();
	return 0;
}
