#include <stdio.h>
#include <string.h>
#include <deque>

#define MMAX 10005
#define NMAX 55
#define infmax 0x7fffffff

using namespace std;

int N, K;

struct Edge {
  int v;
  int cap;
  int cost;
  int next;
};
int head[NMAX];
Edge es[MMAX];
int en;

int d[NMAX];
int pre[NMAX];
bool b[NMAX];
int prei[NMAX];

void Add(int u, int v, int cap, int cost) {
  Edge* p = &es[en];
  p->v = v;
  p->cap = cap;
  p->cost = cost;
  p->next = head[u];
  head[u] = en++;

  p = &es[en];
  p->v = u;
  p->cap = 0;
  p->cost = -cost;
  p->next = head[v];
  head[v] = en++;
}

bool SPFA() {
  int i;
  memset(b, 0, sizeof(b));
  for (i = 1; i <= N; ++i) {
    d[i] = infmax;
  }

  deque<int> q;
  d[1] = 0;
  b[1] = true;
  q.push_back(1);
  while (!q.empty()) {
    int u = q.front();
    q.pop_front();
    b[u] = false;

    for (int i = head[u]; i != -1; i = es[i].next) {
      Edge* p = &es[i];
      int v = p->v;
      int cap = p->cap;
      int cost = p->cost;

      if (cap && d[u] + cost < d[v]) {
        d[v] = d[u] + cost;
        pre[v] = u;
        prei[v] = i;
        if (!b[v]) {
          b[v] = true;
          q.push_back(v);
        }
      }
    }
  }

  return d[N] != infmax;
}

int main() {
  int i, j;
  scanf("%d%d", &N, &K);
  memset(head, 0xff, sizeof(head));
  en = 0;

  for (i = 1; i <= N; ++i) {
    for (j = 1; j <= N; ++j) {
      int c;
      scanf("%d", &c);
      if (c != 0) {
        Add(i, j, c, 0);
        Add(i, j, infmax, 1);
      }
    }
  }

  int flow = 0;
  while (SPFA()) {
    int f = infmax;
    for (int i = N; i != 1; i = pre[i]) {
      f = min(f, es[prei[i]].cap);
    }
    for (int i = N; i != 1; i = pre[i]) {
      es[prei[i]].cap -= f;
      es[prei[i]^1].cap += f;
    }

    if (1ll * f * d[N] <= K) {
      K -= f * d[N];
      flow += f;
    } else {
      flow += K / d[N];
      break;
    }
  }
  printf("%d\n", flow);

  return 0;
}