#include <stdio.h>
#include <algorithm>
using namespace std;
const int oo=1<<29;
struct edge{
    int u,v,cap,cost;
}E[10240];
int n,k,x,e,cost[50],p[50];
void addEdge(int a,int b,int c,int d){
    E[e].u=a;E[e].v=b;E[e].cap=c;E[e].cost=d;
    ++e;
    E[e].u=b;E[e].v=a;E[e].cap=0;E[e].cost=-d;
    ++e;
}
bool getPath(int src,int sink){
    for(int i=0;i<n;++i)
        cost[i]=oo;
    cost[src]=0;
    bool upd=true;
    for(int it=1;upd && it<n;++it)
        for(int i=upd=0;i<e;++i)
            if(E[i].cap>0 && cost[E[i].u]<oo && cost[E[i].v]>cost[E[i].u]+E[i].cost){
                cost[E[i].v]=cost[E[i].u]+E[i].cost;
                p[E[i].v]=i;
                upd=true;
            }
    return cost[sink]<oo;
}
int minCostMaxFlow(int src,int sink){
    int MaxFlow=0,MinCost=0,flow;
    while(getPath(src,sink)){
        MinCost+=cost[sink];
        if(MinCost>k)
            return MaxFlow;
        flow=oo;
        for(int c=sink;c!=src;c=E[p[c]].u){
            flow=min(flow,E[p[c]].cap);
            if(E[p[c]].cost!=0)
                flow=1;
        }
        for(int c=sink;c!=src;c=E[p[c]].u){
            E[p[c]].cap-=flow;
            E[p[c]^1].cap+=flow;
        }
        MaxFlow+=flow;
    }
    return MaxFlow;
}
int main()
{
    scanf("%d%d",&n,&k);
    for(int i=0;i<n;++i)
        for(int j=0;j<n;++j){
            scanf("%d",&x);
            if(x){
                addEdge(i,j,x,0);
                addEdge(i,j,oo,1);
            }
        }
    printf("%d\n",minCostMaxFlow(0,n-1));
    return 0;
}