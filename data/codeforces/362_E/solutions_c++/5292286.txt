#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<set>

using namespace std;

const int maxn = 55,maxm = 1010;
int maxflow,n,m,c[maxn][maxn],q[maxn];
int d[maxn][maxn],sp[maxn],pre[maxn];
bool vis[maxn],pip[maxn][maxn];

struct vt
{
	int i,sp;
	inline vt (int a,int b):i(a),sp(b) {}
};

inline bool operator <  (const vt& a,const vt& b)
{
	return a.sp==b.sp ? a.i<b.i : a.sp<b.sp;
}

inline bool operator == (const vt& a,const vt& b)
{
	return a.i == b.i && a.sp == b.sp;
}

set<vt> H;
typedef set<vt>::iterator it;

bool bfs()
{
	int i,j,h,t;
	q[h=t=1] = 1;
	memset(vis,0,sizeof(vis));
	vis[1] = true;
	while (h<=t)
	{
		i = q[h++];
		for (j=1; j<=n; j++) if (c[i][j] && !vis[j])
		{
			vis[j] = true;
			q[++t] = j;
			pre[j] = i;
			if (j==n) return true;
		}
	}
	return false;
}

void add_flow()
{
	int i,f = 0x7FFFFFFF;
	for (i=n; i!=1; i=pre[i])
		f = min(f,c[pre[i]][i]);
	maxflow += f;
	for (i=n; i!=1; i=pre[i])
	{
		c[pre[i]][i] -= f;
		c[i][pre[i]] += f;
	}
}

void EK()
{
	maxflow = 0;
	while (bfs())
		add_flow();
}

void dij()
{
	int i,j,k; it ti,tj;
	H.clear();
	sp[1] = 0; for (i=2; i<=n; i++) sp[i] = 0x3FFFFFFF;
	for (i=1; i<=n; i++) H.insert(vt(i,sp[i]));
	for (i=1; i<=n; i++)
	{
		ti = H.begin();
		if (ti->i == n) return;
		j = ti->i;
		for (k=1; k<=n; k++)
			if (sp[j]+d[j][k] < sp[k])
			{
				pre[k] = j;
				tj = H.find(vt(k,sp[k]));
				H.erase(tj);
				sp[k] = sp[j]+d[j][k];
				H.insert(vt(k,sp[k]));
			}
		H.erase(ti);
	}
}

int main()
{
	int i,j,k,t;
	scanf("%d%d",&n,&m);
	for (i=1; i<=n; i++)
		for (j=1; j<=n; j++)
		{ 	
			scanf("%d",&c[i][j]);
			pip[i][j] = (bool)c[i][j];
		}
	EK();
	for (i=1; i<=n; i++)
		for (j=1; j<=n; j++)
			if (pip[i][j]) d[i][j] = c[i][j] ? 0 : 1;
			else d[i][j] = 0x3FFFFFFF;
	while (m>0)
	{
		dij();
		if (sp[n] > m) break;
		m -= sp[n];
		maxflow++;
		for (i=n; i!=1; i=pre[i])
			if (c[pre[i]][i])
			{
				c[pre[i]][i]--;
				if (!c[pre[i]][i]) d[pre[i]][i] = 1;
			}
	}
	printf("%d\n",maxflow);
	return 0;
}
