#include <set>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iostream>
using namespace std;
int n, m, maxCost, D[60], Q[10000], ans, P[60];
int List[60], To[100000], Cap[100000], Cost[100000], Next[100000];
bool B[60];

void addEdge(int u, int v, int cap, int cost)
{
	To[m] = v; Cap[m] = cap; Cost[m] = cost;
	Next[m] = List[u]; List[u] = m ++;
	To[m] = u; Cap[m] = 0; Cost[m] = -cost;
	Next[m] = List[v]; List[v] = m ++;
}

bool Extended_Path(int S, int T)
{
	memset(D, 2, sizeof(D));
	memset(B, false, sizeof(B));
	int Head = 0, Tail = 0;
	Q[Tail ++] = S;
	B[S] = true;
	D[S] = 0;
	while (Head < Tail) {
		int u = Q[Head ++];
		B[u] = false;
		for (int i = List[u]; i != -1; i = Next[i])
		if (Cap[i] > 0 && D[u] + Cost[i] < D[To[i]]) {
			D[To[i]] = D[u] + Cost[i];
			P[To[i]] = i;
			if (B[To[i]] == false) {
				B[To[i]] = true;
				Q[Tail ++] = To[i];
			}
		}
	}
	if (D[T] > maxCost) {
		return false;
	}
	int flow = 100000;
	for (int i = T; i != S; i = To[P[i] ^ 1]) {
		flow = min(flow, Cap[P[i]]);
	}
	if (flow * D[T] > maxCost) {
		flow = maxCost / D[T];
	}
	maxCost -= flow * D[T];
	ans += flow;
	for (int i = T; i != S; i = To[P[i] ^ 1]) {
		Cap[P[i]] -= flow;
		Cap[P[i] ^ 1] += flow;
	}
	return true;
}

int main(int argv, char* argc[])
{
	memset(List, -1, sizeof(List));
	scanf("%d%d", &n, &maxCost);
	for (int i = 1; i <= n; i ++) {
		for (int j = 1; j <= n; j ++) {
			int x ;
			scanf("%d", &x);
			if (x > 0) {
				addEdge(i, j, x, 0);
				addEdge(i, j, maxCost, 1);
			}
		}
	}
	while (Extended_Path(1, n));
	printf("%d\n", ans);
	return 0;
}
