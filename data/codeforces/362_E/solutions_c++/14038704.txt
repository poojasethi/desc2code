#include<cstdio>
#include<algorithm>
#define N 51
using namespace std;
const int INF=2000000000;
int f[N],q[N],flag[N],pre[N],a[N][N],can[N][N];
int n,m,i,j,x,ans;
inline int bfs()
{
  for (int i=1;i<=n;i++) f[i]=-1;
  int h=0,t=1;q[1]=1;f[1]=0;
  while (h<t)
  {
    int k=q[++h],go;if (k==n) return 1;
    for (int i=1;i<=n;i++)
      if (f[i]==-1&&a[k][i])
        f[i]=f[k]+1,q[++t]=i;
  }
  return 0;
}
int dinic(int k,int sum)
{
  if (k==n) return sum;int os=sum;
  for (int i=1;i<=n&&os;i++)  
    if (f[i]==f[k]+1&&a[k][i])
    {
      int flow=dinic(i,min(os,a[k][i]));
      a[k][i]-=flow;a[i][k]+=flow;os-=flow;
    }
  if (os==sum) f[k]=-1;
  return sum-os;
}
inline int DP()
{
  int h=0,t=1;q[1]=n;flag[n]=0;f[n]=0;
  for (int i=0;i<n;i++) f[i]=INF,flag[i]=0;
  for (int i=1;i<=n;i++)
  {
    int k=0;
    for (int j=1;j<=n;j++)
      if (!flag[j]&&f[j]<f[k]) k=j;
    if (!k) break;flag[k]=1;
    for (int j=1;j<=n;j++)
      if (can[j][k]&&f[k]+(a[j][k]==0)<f[j])
        f[j]=f[k]+(a[j][k]==0),pre[j]=k;
  }
  if (f[1]==INF||f[1]>m) return 1;
  for (int x=1;x<n;x=pre[x])
    if (a[x][pre[x]]>0) a[x][pre[x]]--;
  m-=f[1];ans++;return 0;
}
int main()
{
  scanf("%d%d",&n,&m);
  for (i=1;i<=n;i++)
    for (j=1;j<=n;j++)
    {
      scanf("%d",&a[i][j]);
      can[i][j]=(a[i][j]>0);
    }
  while (bfs())
    ans+=dinic(1,INF);
  for (;m>0;)
    if (DP()) break;
  printf("%d\n",ans);
}
