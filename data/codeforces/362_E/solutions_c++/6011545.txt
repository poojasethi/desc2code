//This is the painkiller...
#include <bits/stdc++.h>
using namespace std;
#define mem(a,v) memset(a,v,sizeof(a))
#define pb push_back
#define mp make_pair
#define sz(x) int((x).size())
#define x first
#define y second
#define all(a) (a).begin(),(a).end()
#define rep(i,n) for(int i=0;i<int(n);i++)
#define repi(i,a,n) for(int i=int(a);i<int(n);i++)
#define repe(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)

typedef long long ll;
typedef pair<int,int> pii;
typedef vector<int> vi;

const int maxNode=55;
int R[maxNode][maxNode];
int W[maxNode][maxNode];
int C[maxNode][maxNode];
int n,parent[maxNode];

int augment(int &k)
{
	queue<int> Q;
	vector<int> D(n,INT_MAX/2);
	Q.push(0);
	mem(parent,-1);
	D[0]=0;
	while(!Q.empty())
	{
		int u=Q.front();
		Q.pop();
		rep(v,n)if(C[u][v]>0)
		{
			if(R[u][v]>0)
			{
				if(D[v]>D[u])
				{
					parent[v]=u;
					D[v]=D[u];
					Q.push(v);
				}
			}
			//~ if(!(n==34 && k==470))
			if(D[v]>D[u]+1)
			{
				parent[v]=u;
				D[v]=D[u]+1;
				Q.push(v);
			}
		}
	}
	int g=n-1;
	int f=INT_MAX;
	int c=D[g];
	while(parent[g]!=-1)
	{
		if(D[g]==D[parent[g]]+1)f=min(f,INT_MAX);
		else f=min(f,R[parent[g]][g]);
		g=parent[g];
	}
	//~ if(n==34 && k==470)cout<<c<<" "<<f<<" ";
	if(c>0)
	{
		f=min(f,k/c);
		k-=1ll*c*f;
	}
	g=n-1;
	while(parent[g]!=-1)
	{
		if(D[g]!=D[parent[g]]+1)
		{
			R[parent[g]][g]-=f;
			R[g][parent[g]]+=f;
		}
		g=parent[g];
	}
	return f;
}

int flow(int k)
{
	int ret=0,f;
	rep(i,n)rep(j,n)
	{
		R[i][j]=C[i][j];
	}
	while((f=augment(k))>0)
	{
		ret+=f;
	}
	return ret;
}

int main()
{
	//~ freopen("input.txt","r",stdin);
	std::ios_base::sync_with_stdio(false);
	int k;
	cin>>n>>k;
	rep(i,n)rep(j,n)cin>>C[i][j];
	int ans=flow(k);
	cout<<ans;
	return 0;
}