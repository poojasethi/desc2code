#include <map>
#include <set>
#include <cmath>
#include <stack>
#include <queue>
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
using namespace std;
#define li		long long
#define rep(i,to)	for(li i=0;i<((li)to);i++)
#define pb		push_back
#define sz(v)		((li)v.size())

#define MAX 185 
#define INF 1<<30
int n,k,D[MAX],center[MAX],min_sub[MAX],sub_cent[MAX];
int dis[MAX][MAX],dp[MAX][MAX];
vector<int> adj[MAX];

void dist_dfs(int orig,int num,int par,int d){
	dis[orig][num]=d;
	rep(i,sz(adj[num]))if(adj[num][i]!=par) dist_dfs(orig,adj[num][i],num,d+1);
}

void solve(int num,int par){
	rep(i,sz(adj[num]))if(adj[num][i]!=par) solve(adj[num][i],num);
	rep(cent,n){
		dp[num][cent]=D[dis[num][cent]];
		rep(i,sz(adj[num])){
			int next=adj[num][i];
			if(next!=par) dp[num][cent]+=min(dp[next][cent],min_sub[next]+k);
		}
	}
	min_sub[num]=INF;
	rep(i,n){
		if(dis[i][num]<dis[i][par]+1 && dp[num][i]<min_sub[num]){
			min_sub[num]=dp[num][i];
			sub_cent[num]=i;
		}
	}
}

void appoint(int num,int par,int cent){
	center[num]=cent;
	rep(i,sz(adj[num])){
		int next=adj[num][i];
		if(next!=par)	appoint(next,num,dp[next][cent]<min_sub[next]+k?cent:sub_cent[next]);
	}
}

int main(){
	scanf("%d%d",&n,&k);
	D[0]=0;
	rep(i,n-1) scanf("%d",&D[i+1]);
	for(int i=1,a,b;i<n;i++){
		scanf("%d%d",&a,&b);
		a--; b--;
		adj[a].pb(b);
		adj[b].pb(a);
	}
	rep(i,n) dist_dfs(i,i,-1,0);
	solve(0,-1);
	int best=-1;
	rep(i,n)if(best==-1 || dp[0][i]<dp[0][best]) best=i;
	printf("%d\n",dp[0][best]+k);
	appoint(0,-1,best);
	rep(i,n)	printf("%d%c",center[i]+1,i<n-1?' ':'\n');
}
