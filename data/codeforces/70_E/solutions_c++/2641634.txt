/*
Author: LJQ
PROG: Codeforces #64 E. Information Reform
DATE: 2012.11.25
*/
#include <cstdio>

using namespace std;

const int maxn = 185;

int f[maxn][maxn];//f[i][j]: minimum cost for subtree i when i appointed with j
int best[maxn];//best choice
int d[maxn][maxn];
int c[maxn];//c[i]: cost with length i
int ans[maxn];
int n, extra, ret;

void init()
{
	scanf("%d%d", &n, &extra);
	for (int i = 1; i < n; i ++) scanf("%d", &c[i]);
	int u, v;
	for (int i = 1; i < n; i ++){
		scanf("%d%d", &u, &v);
		d[u][v] = d[v][u] = 1;
	}
}

void dfs_len(int t, int src, int lat)//calc distance
{
	d[src][t] = d[src][lat] + 1;
	if (!lat) d[src][t] = 0;
	for (int i = 1; i <= n; i ++)
		if (d[t][i] == 1 && i != lat) dfs_len(i, src, t);
}

int Fmin(int x, int y){
	return x < y ? x : y;
}

void solve(int t, int lat)
{
	for (int i = 1; i <= n; i ++)
		f[t][i] = c[d[t][i]] + extra;
	for (int i = 1; i <= n; i ++)
		if (d[t][i] == 1 && i != lat){
			solve(i, t);
			for (int j = 1; j <= n; j ++)
				f[t][j] += Fmin(f[i][best[i]], f[i][j] - extra);
		}
	best[t] = 1;
	for (int i = 1; i <= n; i ++)
		if (f[t][i] < f[t][best[t]]) best[t] = i;
}

void check(int t, int lat, int ord)
{
	ans[t] = ord;
	for (int i = 1; i <= n; i ++)
		if (d[t][i] == 1 && i != lat)
			check(i, t, f[i][ord] - extra < f[i][best[i]] ? ord : best[i]);
}

void work()
{
	for (int i = 1; i <= n; i ++) dfs_len(i, i, 0);
	solve(1, 0);
	ret = f[1][best[1]];
	check(1, 0, best[1]);
}

void print()
{
	printf("%d\n", ret);
	for (int i = 1; i <= n; i ++)
		printf("%d%c", ans[i], i == n ? '\n' : ' ');
}

int main()
{
	init();
	work();
	print();
	return 0;
}
