#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<vector>
//#include<windows.h>
#define mod 1000000007
#define MAXN 100005
using namespace std ;
typedef long long LL ;

int N, K ;
int p[MAXN], vis[MAXN], rk[MAXN], num[MAXN] ;
int mx, now, get[MAXN], val[MAXN] ;
LL sum, tot = 1;
LL pw[MAXN], pos[MAXN], at[MAXN] ;
vector<int> have, rest, th ;
vector< LL > f[MAXN] ;

int id(int x){return min(2, x-1) ;}
LL ksm(LL x, LL t)
{
	LL tmp = 1 ;
	for(t; t; t >>= 1, x = x*x%mod)
		if(t&1) tmp = tmp*x%mod ;
	return tmp ;
}
LL C(LL x, LL y)
{
	return pw[x]*pos[y]%mod*pos[x-y]%mod ;
}

LL Work()
{
	int i, j, n ;
	have = th ;
	LL tmp = tot ;
	
	sort(have.begin(), have.end()) ;
	now = max(mx, id(have.back())) ;
	
	have.push_back(1), have.push_back(2) ;
	sort(have.begin(), have.end()) ;
	
 	for(i = 0, n = -1; i < have.size(); i ++)
		if(i == 0 || have[i] != have[i-1])
			have[++n] = have[i], val[n] = 1 ;
		else val[n] ++ ;
	val[0] --, val[1] --, have.resize(n+1) ;
	for(i = 0; i <= n; i ++)
		tmp = tmp*at[have[i]]%mod*(now<2?1:f[have[i]][get[have[i]]+val[i]])%mod ;
	return tmp ;
}

void Dfs(int x)
{
	if(x == rest.size())
	{
		LL i, tmp = Work() ;
		for(i = 0; i < th.size(); i ++)
			tmp = tmp*pw[num[i]-1]%mod ;
		sum = (sum+tmp)%mod ;
		return ;
	}
	th.push_back(rest[x]), num[th.size()-1] = 1 ;
	Dfs(x+1) ;
	th.pop_back() ;
	int i = th.size() ;
	for(i = 0; i < th.size(); i ++)
	{
		th[i] += rest[x], num[i] ++ ;
		Dfs(x+1) ;
		th[i] -= rest[x], num[i] -- ;
	}
}

int main()
{
	int i, j, tmp ;
	//freopen("1.in", "r", stdin) ;
	scanf("%d %d", &N, &K) ;
	for(i = 1, pw[0] = 1; i <= N; i ++)
		pw[i] = pw[i-1]*i%mod, pos[i] = ksm(pw[i], mod-2) ;
	for(i = 1; i <= N; i ++)
	{
		f[i].push_back(1) ;
		f[i].push_back(i) ;
		for(j = 2; i*j <= N; j ++)
		{
			f[i].push_back(0) ;
			f[i][j] = (f[i][j-2]*(j-1)%mod+f[i][j-1])%mod*i%mod ;
		}
	}
	for(i = 1; i <= N; i ++)
		scanf("%d", &p[i]), rk[p[i]] = i ;
	for(i = 1; i <= N; i ++)
		if(!p[i])
		{
			for(j = i, tmp = 1; rk[j]; vis[j] = 1, j = rk[j], tmp ++) 
				i ++, i -- ;
			vis[j] = 1, rest.push_back(tmp) ;
		}
	for(i = 1; i <= N; i ++)
		if(p[i] && !vis[i])
		{
			for(j = i, tmp = 0; !vis[j]; vis[j] = 1, j = p[j], tmp ++) ;
			get[tmp] ++, mx = max(mx,id(tmp)) ;
		}
	for(i = 1; i <= N+1; i ++)
		if(get[i]) 
		{
			if(mx == 2) at[i] = f[i][get[i]] ;
			else at[i] = 1 ;
			tot = tot*at[i]%mod ;
			at[i] = ksm(at[i], mod-2) ;
		}
		else at[i] = 1 ;
	if(rest.size()) Dfs(0) ;
	else sum = tot ;
	printf("%I64d\n", sum) ;
	//Sleep(2000) ;
	//system("pause") ;
	return 0 ;
}
