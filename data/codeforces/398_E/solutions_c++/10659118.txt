#include <cstdio>
#include <cassert>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <cctype>
#include <climits>
#include <string>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <set>
#include <map>
#include <list>
#include <queue>
#include <stack>
#include <vector>
#define pb push_back
typedef long long LL;
typedef long double LD;
typedef double DB;
using namespace std;

const int MAXN = 100009;
const int MOD = 1e9+7;

int n, k;
int p[MAXN];
int hash[MAXN];
int vis[MAXN];

int chain[MAXN];
vector<int> a[MAXN], inva[MAXN];

int scir[MAXN];
int scir2[4];
int preans;
int top;
int len[MAXN];
int num[MAXN];
int ans;

void read_int(int &x)
{
	char c;	
	int f = 1;x = 0;
	while(!isdigit(c=getchar()) && c != '-');
	if(c == '-') f = -1;
	else x = c-'0';
	while(isdigit(c=getchar())) x = x*10+c-'0';
	x *= f;
}

void init()
{
	read_int(n), read_int(k);
	for(int i = 1; i <= n; ++i)
	{
		read_int(p[i]);
		hash[p[i]] = 1;
	}
}

int powermod(int a, int b, int m)
{
	int re = 1, base = a;
	while(b)
	{
		if(b&1) re = (LL)re*base%m;
		base = (LL)base*base%m;
		b >>= 1;	
	}
	return re;
}

#define inv(a, b) (powermod(a, b-2, b))

void work_a()
{
	for(int i = 1; i <= n; ++i)
	{
		a[i].pb(1);
		inva[i].pb(1);
		for(int j = 1; i*j <= n; ++j)
		{
			int tmp = (LL)a[i][j-1]*i%MOD;
			if(j >= 2)
				tmp = (tmp+(LL)a[i][j-2]*(j-1)%MOD*i)%MOD;
			a[i].pb(tmp);
			inva[i].pb(inv(tmp, MOD));
		}
	}
}

void find_chain()
{
	int tot = 0;
	for(int i = 1; i <= n; ++i)
		if(!hash[i])
		{
			int now = i, l = 0;
			while(now)
			{
				vis[now] = 1;
				now = p[now];
				++l;
			}
			chain[tot++] = l;
		}
}

void find_cir()
{
	for(int i = 1; i <= n; ++i)
		if(!vis[i])
		{
			int now = i, l = 1;
			while(true)
			{
				vis[now] = 1;
				if(p[now] == i) break;
				now = p[now];
				l++;
			}
			++scir[l];
			++scir2[min(l, 3)];
		}
}

void pre_dp()
{
	preans = 1;
	for(int i = 1; i <= n; ++i)
		preans = (LL)preans*a[i][scir[i]]%MOD;
}

void calc(int arrange)
{
	int tmp = preans;
	for(int i = 1; i <= top; ++i)
	{
		int l = len[i];
		tmp = (LL)tmp*inva[l][scir[l]]%MOD;
		scir[l]++, scir2[min(l, 3)]++;
		tmp = (LL)tmp*a[l][scir[l]]%MOD;
	}
	if(scir2[3])
		arrange = (LL)arrange*tmp%MOD;
	ans = (ans+arrange)%MOD;
	for(int i = 1; i <= top; ++i)
	{
		int l = len[i];
		scir[l]--, scir2[min(l, 3)]--;
	}
}

void dfs(int now, int arrange)
{
	if(now == k)
	{
		calc(arrange);
		return ;	
	}
	len[++top] = chain[now];
	num[top] = 1;
	dfs(now+1, arrange);
	num[top--] = 0;
	for(int i = 1; i <= top; ++i)
	{
		len[i] += chain[now];
		num[i]++;
		dfs(now+1, (LL)arrange*(num[i]-1)%MOD);	
		num[i]--;
		len[i] -= chain[now];
	}
}

void work()
{
	work_a();
	find_chain();
	find_cir();
	pre_dp();
	dfs(0, 1);
}

void print()
{
	printf("%d\n", ans);	
}

int main()
{
	//freopen("Permutation.in", "r", stdin);
	//freopen("Permutation.out", "w", stdout);
	
	init();
	work();
	print();
	
	//fclose(stdin);
	//fclose(stdout);
	return 0;
}

