// 160E
#include <cstdio>
#include <algorithm>
using namespace std;

struct node{
    int x, y, t, i;
    bool operator < (const node &t) const {
        return (x<t.x) || ((x==t.x) && (i<t.i));
    }
}a[200005];

struct tree{
    int x, y, m, i, ma;
}t[530000];

int n, m, nm, s[200005], w, ans[100005];

void build(int z, int x, int y) {
    t[z].x = x;
    t[z].y = y;
    t[z].m = (x+y)>>1;
    t[z].i = t[z].ma = -1;
    if (x<y) {
        build((z<<1)+1, x, t[z].m);
        build((z<<1)+2, t[z].m+1, y);
    }
}

void ins(int z, int x, int ma, int i) {
    t[z].ma = max(t[z].ma, ma);
    if ((t[z].x == x) && (x == t[z].y)) 
        t[z].i = i;
    else if (x <= t[z].m) 
        ins((z<<1)+1, x, ma, i);
    else 
        ins((z<<1)+2, x, ma, i);
}

int sea(int z, int x, int y, int aiy) {
    int ret = -1;
    if(t[z].ma < aiy) return -1;
    if(t[z].x == t[z].y) return t[z].i;
    if(x <= t[z].m) 
        ret = sea((z<<1)+1, x, min(y, t[z].m), aiy);
    if(ret>=0) return ret;
    if(t[z].m < y)
        ret = sea((z<<1)+2, max(t[z].m+1, x), y, aiy);
    return ret;
}

int main() {
    scanf("%d%d", &n, &m);
    nm = n+m;
    for (int i=0; i<nm; i++) {
        scanf("%d%d%d", &a[i].x, &a[i].y, &a[i].t);    // all t are distinct
        a[i].i = i+1;
        s[i] = a[i].t;
    }
    sort(a, a+nm);
    sort(s, s+nm);
    w = (int) (unique(s, s+nm) - s);
    build(0, 0, w-1);
    for (int i=0; i<nm; i++) {
        a[i].t = (int) (lower_bound(s, s+w, a[i].t) - s);
        if (a[i].i<=n) 
            ins(0, a[i].t, a[i].y, a[i].i);
        else 
            ans[a[i].i-n] = sea(0, a[i].t, w-1, a[i].y);
    }
    for (int i=1; i<=m; i++) {
        if (i!=1) printf(" ");
        printf("%d", ans[i]);
    }
    printf("\n");
    return 0;
}