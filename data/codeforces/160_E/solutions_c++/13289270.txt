#include <stdio.h>
#include <iostream>
#include <algorithm>
#include <set>
#include <vector>

using namespace std;

const int MAXN = (int)1e5;

int tt[2 * MAXN];
vector < int > tunq;
pair < pair < int, int >, pair < int, int > > p[2 * MAXN];
pair < int, int> tree[8 * MAXN];
int sol[MAXN];

pair < int, int > add(int l, int r, int i, int t, pair < int, int > tp) {
	if (l > t || r < t) return tree[i];
	if (l == r) return tree[i] = tp;

	int mid = l + (r - l) / 2;
	return tree[i] = max(add(l, mid, 2 * i + 1, t, tp), add(mid + 1, r, 2 * i + 2, t, tp));
}

pair < int, int > query(int l, int r, int i, int t, int f) {
	if (t > r || tree[i].first < f) return make_pair(-1, -1);
	if (l == r) return tree[i];

	int mid = l + (r - l) / 2;
	pair < int, int > tmp = query(l, mid, 2 * i + 1, t, f);
	if (tmp.first >= f) return tmp;

	tmp = query(mid + 1, r, 2 * i + 2, t, f);
	if (tmp.first >= f) return tmp;

	return make_pair(-1, -1);
}

int main(void) {
	int n, m;
	scanf("%d %d", &n, &m);

	for (int i = 0; i < n; i++) {
		int _s, _f, _t;
		scanf("%d %d %d", &_s, &_f, &_t);
		p[i] = make_pair(make_pair(_s - 1, 0), make_pair(_f - 1, i + 1));
		tunq.push_back(_t);
		tt[i] = _t;
	}

	for (int i = 0; i < m; i++) {
		int _l, _r, _b;
		scanf("%d %d %d", &_l, &_r, &_b);
		p[n + i] = make_pair(make_pair(_l - 1, 1), make_pair(_r - 1, i + n + 1));
		tunq.push_back(_b);
		tt[n + i] = _b;
	}

	sort(p, p + n + m);
	sort(tunq.begin(), tunq.end());
	tunq.resize(unique(tunq.begin(), tunq.end()) - tunq.begin());

	for (int i = 0; i < n + m; i++) {
		tt[i] = lower_bound(tunq.begin(), tunq.end(), tt[i]) - tunq.begin();
	}
	int k = tunq.size();

	for (int i = 0; i < n + m; i++) {
		if (!p[i].first.second) {
			add(0, k - 1, 0, tt[p[i].second.second - 1], p[i].second);
		} else {
			sol[p[i].second.second - n - 1] = query(0, k - 1, 0, tt[p[i].second.second - 1], p[i].second.first).second;
		}
	}

	for (int i = 0; i < m; i++) {
		printf("%d ", sol[i]);
	}
	printf("\n");

    return 0;
}
