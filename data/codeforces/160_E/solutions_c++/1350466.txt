#include <cstdio>
#include <cstring>
#include <set>
#include <algorithm>
#define MaxN 100010
#define oo 1234567890
#define MP make_pair
using namespace std;

struct Seg
{
    int a, b, t, id;
    bool operator < (const Seg &a) const
    {
        if (b == a.b) return id < a.id;
        return b > a.b;
    }
}s[2*MaxN];
int nv, v[2*MaxN], ans[MaxN];
set <pair<int, int> > st[2*MaxN];

void update(int x, int id)
{
    for (; x <= nv; x += x&-x)
        st[x].insert(MP(s[id].t, s[id].id));
}

int query(int x, int v)
{
    pair <int, int> ret = MP(oo, -2);
    for (; x; x -= x&-x)
    {
        set<pair<int, int> > :: iterator it = st[x].lower_bound(MP(v, 0));
        if (it != st[x].end()) ret = min(ret, *it);
    }
    return ret.second;
}

int main()
{
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n+m; ++i)
    {
        scanf("%d%d%d", &s[i].a, &s[i].b, &s[i].t);
        s[i].id = i; v[i] = s[i].a;
    }
    sort(s, s+n+m);
    sort(v, v+n+m);
    nv = unique(v, v+n+m) - v;
    for (int i = 0; i < n+m; ++i)
    {
        int p = lower_bound(v, v+nv, s[i].a) - v + 1;
        if (s[i].id < n) update(p, i);
        else ans[s[i].id-n] = query(p, s[i].t)+1;
    }
    for (int i = 0; i < m; ++i) printf("%d%c", ans[i], i+1==m?'\n':' ');
    return 0;
}
