#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1
const int maxn  =  222222;
int rmax[maxn<<2];
int id[maxn<<2];
int n,m;
struct seg{
     int l,r,t,id;
     seg(){};
     bool operator < (const seg cmp) const{//排序的精彩之处
         return (l<cmp.l || l==cmp.l&&id<cmp.id);//保证相同出发点时汽车排在人的前面
     }//在人以后出现的车都是出发点大于等于乘客的，保证没有以后的车可以载走乘客，即能载走乘客的车都在前面
}a[maxn*2];
int max(int a,int b){
    return  a>b?a:b;
}
void update(int pos,int rval,int idx,int l,int r,int rt){
    if(l==r){
        rmax[rt]=rval;
        id[rt]=idx;
        return ;
    }
    int  m=(l+r)>>1;
    if(m>=pos) update(pos,rval,idx,lson);
    else update(pos,rval,idx,rson);
    rmax[rt]=max(rmax[rt<<1],rmax[rt<<1|1]);
}
int query(int pos,int rval,int l,int r,int rt){//在满足条件的情况下找出发时间尽可能早的车 
    if(rmax[rt]<rval) return -1;
    if(l==r) return id[rt]; //l>=u，为叶子节点，表明前面肯定有一辆车在u以后出发  rmax>=val 
    int ret=-1;
    int m=(l+r)>>1;
    if(m>=pos){//车的出发时间越小越好 
        ret=query(pos,rval,lson);
        if(ret>0) return ret;
    }
    return query(pos,rval,rson);//左子树找不到可以接的车，转向右子树
}
int tt[maxn*2];
int ans[maxn*2];
int main(){
    int i,j,k;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n+m;i++){
        scanf("%d%d%d",&a[i].l,&a[i].r,&a[i].t);
        a[i].id=i;
        tt[i]=a[i].t;
    }
    sort(a+1,a+n+m+1);
    sort(tt+1,tt+n+m+1);
    for(i=1;i<=n+m;i++){
        int pos=lower_bound(tt+1,tt+n+m+1,a[i].t)-tt;
        if(a[i].id<=n) update(pos,a[i].r,a[i].id,1,n+m,1);
        else ans[a[i].id-n]=query(pos,a[i].r,1,n+m,1);
    }
    for(i=1;i<=m;i++) printf("%d ",ans[i]);
    return 0;
}