#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<vector>
#define x first
#define y second
#define mp make_pair



using namespace std;

typedef vector<pair<int,int> > VII;
const int inf=2139062143;
int n,m,L,R,T;

pair<pair<int,int>,pair<int,int> >a[100001];
struct seg
{
	VII ele;
	seg* ch[2];
	int l,r;
	void build(int lb,int rb)
	{
		l=lb,r=rb;
		ele.clear();
		for(int i=l;i<=r;++i)ele.push_back(mp(a[i].y.x,-a[i].y.y));
		sort(ele.begin(),ele.end());
		for(int i=0;i<r-l+1;++i)ele[i].y=-ele[i].y;
		for(int i=1;i<r-l+1;++i)if(ele[i].y<=ele[i-1].y)ele[i]=ele[i-1];
		ele.erase(unique(ele.begin(),ele.end()),ele.end());
		if(l==r)return;
		ch[0]=new seg;
		ch[1]=new seg;
		ch[0]->build(lb,(lb+rb)/2);
		ch[1]->build((lb+rb)/2+1,rb);
	}
	int can()
	{
		VII::iterator tmp=upper_bound(ele.begin(),ele.end(),mp(L,inf));
		if(tmp==ele.begin())return 0;
		tmp--;
		if(tmp->y<R)return 0;
		if(l==r)return l;
		int ret=ch[0]->can();
		if(ret!=0)return ret;
		return ch[1]->can();
	}
	int find()
	{
		if(T==l)return can(); 
		if(T>(l+r)/2)return ch[1]->find();
		int tmp=ch[0]->find();
		if(tmp!=0)return tmp;
		return ch[1]->can();
	}
}*root;

int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m;
    a[0].x.y=-1;
    for(int i=1;i<=n;++i)cin>>a[i].y.x>>a[i].y.y>>a[i].x.x,a[i].x.y=i;
    sort(a+1,a+n+1);
    root=new seg;
    root->build(1,n);
    for(int i=1,la,lb,lm;i<=m;++i)
	{
		cin>>L>>R>>T;
		for(la=1,lb=n,lm=(la+lb)/2;la<lb;lm=(la+lb)/2)if(a[lm].x.x<T)la=lm+1;else lb=lm;
		if(a[lm].x.x<T)cout<<-1<<endl;else
		T=lm,cout<<a[root->find()].x.y<<' ';
	}
    return 0;
}
