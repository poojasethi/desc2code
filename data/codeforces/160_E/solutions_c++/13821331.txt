#include<bits/stdc++.h>

using namespace std;

#define st first
#define nd second
#define mp make_pair
#define pb push_back
#define sol (root+root)
#define sag (root+root+1)
#define orta (bas+son>>1)
#define pii pair<int,int>

const int N=1e5+5;
const int mod=1e9+7;
const int inf=1e9+7;

int n,m,x,w,i,q;
int ans[N<<3],tme[N<<3];

pii st[N<<3];

pair<pii,pii > A[N<<3];

pii update(int root,int bas,int son,int x,int v,int v2){
	if(bas>x or son<x)
		return st[root];

	if(bas==son){
		st[root].st=v;
		st[root].nd=v2;
		return st[root];
	}

	pii t1=update(sol,bas,orta,x,v,v2);
	pii t2=update(sag,orta+1,son,x,v,v2);

	if(t1.st>t2.st)
		return st[root]=t1;
	return st[root]=t2;
}

int query(int root,int bas,int son,int x,int v){
	if(st[root].st<v)
		return -1;

	if(bas==son)
		return st[root].nd;
	
	if(x<=orta){
		int t=query(sol,bas,orta,x,v);
		if(t>0)
			return t;
	}

	return query(sag,orta+1,son,x,v);
}

main(){

	scanf("%d %d",&n,&m);

	for(i=1 ; i<=n+m ; i++){
		scanf("%d %d %d",&A[i].st.st,&A[i].nd.st,&A[i].nd.nd);
		A[i].st.nd=i;
		tme[++q]=A[i].nd.nd;
	}
	
	sort(A+1,A+n+m+1);

	sort(tme+1,tme+1+q);

	for(i=1 ; i<=n+m ; i++){
		int temp=lower_bound(tme+1,tme+1+q,A[i].nd.nd)-tme;
		if(A[i].st.nd<=n)
			update(1,1,n+m,temp,A[i].nd.st,A[i].st.nd);
		else 
			ans[A[i].st.nd-n]=query(1,1,n+m,temp,A[i].nd.st);
	}

	for(i=1 ; i<=m ; i++)
		printf("%d ",ans[i]);
}
