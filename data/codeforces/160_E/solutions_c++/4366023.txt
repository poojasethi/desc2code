#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1
#define havemid int m=(l+r)>>1
#define left (rt<<1)
#define right (rt<<1|1)
#define clr(x) memset(x,0,sizeof(x))
const int maxn=250000;
int sum[maxn<<2];
int id[maxn<<2];
void pushup(int rt){
    sum[rt]=max(sum[left],sum[right]);
}
void update(int pos,int val,int number,int l,int r,int rt){
   if(l==r){
        sum[rt]=val;
        id[rt]=number;
        return ;
    }
    havemid;
    if(m>=pos) update(pos,val,number,lson);
    else update(pos,val,number,rson);
    pushup(rt);
}
int query(int pos,int val,int l,int r,int rt){
    if(sum[rt]<val)return -1;
    if(l==r)return id[rt];
    int res=-1;
    havemid;
    if(m>=pos){
        res=query(pos,val,lson);
        if(res>0) return res;
    }
    return query(pos,val,rson);
}
struct node{
    int l,r,ti,id;
}q[250000];
int cmp(struct node a,struct node b){
    if(a.l==b.l)return a.id<b.id;
    return a.l<b.l;
}
int t[250000];
int res[250000];
int n,m;
int main(){
    int i;
    while(scanf("%d%d",&n,&m)!=EOF){
        for(i=1;i<=n+m;i++){
            scanf("%d%d%d",&q[i].l,&q[i].r,&q[i].ti);
            q[i].id=i;
            t[i]=q[i].ti;
        }
        sort(q,q+n+m+1,cmp);
        sort(t,t+m+n+1);
        for(i=1;i<=m+n;i++){
            int pos=lower_bound(t+1,t+n+m+1,q[i].ti)-t;
            if(q[i].id<=n) update(pos,q[i].r,q[i].id,1,n+m,1);
            else res[q[i].id-n]=query(pos,q[i].r,1,n+m,1);
        }
     for(i=1;i<=m;i++)printf("%d ",res[i]);
    }
    return 0;
}
