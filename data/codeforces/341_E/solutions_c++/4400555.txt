#include<cstdio>
#define swap(x,y) t=x,x=y,y=t
#define set(x) ans1[++m]=p1,ans2[m]=x,a[x]-=a[p1],a[p1]<<=1 // source minus,,dest(p1)X2
int i,j,n,m,t,p1,p2,p3,a[1001],ans1[100000],ans2[100000];
int main()
{
    /*
     *http://codeforces.com/blog/entry/8755

     留意tutorial example
     為了使b=Aq+r,,要拆b變成原來/r的餘數->新a((smaller than original A)
     要二進制拆分
     留意拆到最後B仍大於A,,滿足move的前題Ai<=Aj,,,
     而C最最大的永遠不會變負
     * */
    scanf("%d",&n);
    for(i=1;i<=n;scanf("%d",a+i++));
    for(p2=1,p3=2,i=3;i<=n;++i)
        for(p1=i;;){
            if(a[p1]>a[p2])swap(p1,p2); 
            if(a[p2]>a[p3])swap(p2,p3);
            if(a[p1]>a[p2])swap(p1,p2);//a[p1]<a[p2]<a[p3]
            if(a[p1]==0)break;
            for(j=a[p2]/a[p1];j;j>>=1)if(j&1)set(p2);else set(p3);//dump from p2/3 to p1
            //back to loop to rearrange to reduce problem size
        }
    if((a[p1]==0)+(a[p2]==0)+(a[p3]==0)!=1)//only one of which=0,,,,
        puts("-1");
    else
        for(printf("%d\n",m),i=1;i<=m;++i)printf("%d %d\n",ans1[i],ans2[i]);
    return 0;
}
