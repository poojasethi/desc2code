#include <map>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
using namespace std;

#define n   200005
#define MK  make_pair
#define PA  pair<int,int>
#define For(i,a,b)  for(int i=a;i<=b;i++)

int     N,M,Q,A[n],B[n],X[n],Y[n];
bool    Vis[n];

void    End()   {puts("No");exit(0);}

namespace   Plan{
        int     C,D,S[n],st[n],Low[n],Dfn[n],Bel[n];
        struct  Lin{int v,next;}E[n*2];
        bool    V[n];

        void    Link(int u,int v){
            E[++D]=(Lin){v,st[u]};  st[u]=D;
            E[++D]=(Lin){u,st[v]};  st[v]=D;
        }
        void    Tarjan(int u,int f){
            V[S[++*S]=u]=1; Low[u]=Dfn[u]=++C;
            for (int i=st[u],v;i;i=E[i].next)
            if  (i!=f){
                if  (!Dfn[v=E[i].v])    Tarjan(v,i^1),Low[u]=min(Low[u],Low[v]);
                    else    if  (V[v])  Low[u]=min(Low[u],Low[v]);
            }
            if  (Low[u]==Dfn[u]){
                ++*Bel;
                do {
                    V[S[*S]]=0; Bel[S[*S]]=*Bel;
                }   while   (S[(*S)--]!=u);
            }
        }
        void    Main(){
            scanf("%d%d%d",&N,&M,&Q);   D=1;
            For(i,1,M)  scanf("%d%d",&X[i],&Y[i]),Link(X[i],Y[i]);
            For(i,1,N)  if  (!Dfn[i])   Tarjan(i,0);
            For(i,1,M)  X[i]=Bel[X[i]],Y[i]=Bel[Y[i]];
        }
};

namespace   Tree{
        int     D,st[n],Dep[n],F[20][n];
        struct  Lin{int v,next;}E[n*2];
        bool    V[n];
        map<PA,int>G;

        void    Link(int u,int v){
            E[++D]=(Lin){v,st[u]};  st[u]=D;
            E[++D]=(Lin){u,st[v]};  st[v]=D;
        }
        void    DFS(int u,int f){
            Dep[u]=Dep[F[0][u]=f]+1;    V[u]=1;
            for (int i=st[u],v;i;i=E[i].next)
                if  ((v=E[i].v)^f)  DFS(v,u);
        }

        int     LCA(int u,int v){
            if  (Dep[u]>Dep[v]) swap(u,v);
            for (int i=17,d=Dep[v]-Dep[u];i+1;i--)
                if  ((1<<i)&d)  v=F[i][v];
            if  (u==v)  return  u;
            for (int i=17;i+1;i--)
                if  (F[i][u]!=F[i][v])  u=F[i][u],v=F[i][v];
            return  F[0][u];
        }
        void    check(int u,int f){
            for (int i=st[u],v;i;i=E[i].next)
                if  ((v=E[i].v)^f)  check(v,u),A[u]+=A[v],B[u]+=B[v];
            if  (A[u]&&B[u])    End();  Vis[u]=1;
        }

        void    Main()  {
            For(i,1,M)  if  (X[i]!=Y[i]&&!G.count(MK(X[i],Y[i])))
                Link(X[i],Y[i]),G[MK(X[i],Y[i])]=G[MK(Y[i],X[i])]=1;
            For(i,1,N)  if  (!V[i]) DFS(i,0);
            For(i,1,17) For(j,1,N)  F[i][j]=F[i-1][F[i-1][j]];
        }
};

int     main(){
        Plan::Main();   Tree::Main();
        for (int u,v,w;Q--;){
            scanf("%d%d",&u,&v);
            u=Plan::Bel[u]; v=Plan::Bel[v]; w=Tree::LCA(u,v);
            if  (!w)    End();  A[u]++;A[w]--;  B[v]++;B[w]--;
        }
        For(i,1,N)  if  (!Vis[i])   Tree::check(i,0);
        puts("Yes");
}