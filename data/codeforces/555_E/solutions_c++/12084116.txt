#include<cstdio>
#include<algorithm>
#include<vector>
#define GO {puts("No");return 0;}
#define N 200005
using namespace std;
vector<int>a[N],A[N];pair<int,int>S[N];
int f[N],dfn[N],low[N],color[N],deep[N],x[N],y[N],F[N][19];
int now_color,Return,n,m,Q,u,v,step,i,j,t;
int get(int u){return f[u]==u?u:f[u]=get(f[u]);}
void dfs(int k,int fa)
{
	dfn[k]=low[k]=++step;
	for (int i=0,x;i<a[k].size();i++)
	{
		if ((x=a[k][i])==fa) {fa=-1;continue;}
		if (dfn[x]) {low[k]=min(low[k],dfn[x]);continue;}
		dfs(x,k),low[k]=min(low[k],low[x]);
		if (low[x]<=dfn[k]) //b[k][i]=1;
		f[get(x)]=get(k);
  }
}
void link(int k)
{
	color[k]=now_color;
	for (int i=1;i<=18;i++)
		F[k][i]=F[F[k][i-1]][i-1];
	for (int i=0;i<A[k].size();i++)
		if (!color[A[k][i]]) 
			deep[A[k][i]]=deep[k]+1,
			F[A[k][i]][0]=k,link(A[k][i]);
}
int LCA(int x,int y)
{
	if (deep[x]<deep[y]) swap(x,y);
	int d=deep[x]-deep[y];
	for (int i=18;i>=0;i--)
		if ((d>>i)&1) x=F[x][i];
	if (x==y) return x;
	for (int i=18;i>=0;i--)
		if (F[x][i]!=F[y][i]) x=F[x][i],y=F[y][i];
	return F[x][0];
}
pair<int,int> calc(int k)
{
	pair<int,int>res=S[k],tmp;dfn[k]=1;
	for (int i=0;i<A[k].size();i++)
		if (!dfn[A[k][i]])
		{
			tmp=calc(A[k][i]);
			res.first=max(res.first,tmp.first);
			res.second=max(res.second,tmp.second);
	  }
	if (res.first>0&&res.second>0) Return=1;
	return make_pair(res.first-1,res.second-1);
}
int main()
{
	scanf("%d%d%d",&n,&m,&Q);
	for (i=1;i<=m;i++)
	{
		scanf("%d%d",&x[i],&y[i]);
		a[x[i]].push_back(y[i]);
		a[y[i]].push_back(x[i]);
  }
  for (i=1;i<=n;i++) f[i]=i;
  for (i=1;i<=n;i++)
  	if (!dfn[i]) dfs(i,0);
  for (i=1;i<=m;i++)
  	if (get(x[i])!=get(y[i])) 
  		A[f[x[i]]].push_back(f[y[i]]),
  		A[f[y[i]]].push_back(f[x[i]]);
  for (i=1;i<=n;i++)
		if (!color[i]&&f[i]==i) 
			++now_color,link(1);
  for (i=1;i<=Q;i++)
  {
  	scanf("%d%d",&u,&v);u=get(u);v=get(v);
  	if (color[u]!=color[v]) GO t=LCA(u,v);
		S[u].first=max(S[u].first,deep[u]-deep[t]);
		S[v].second=max(S[v].second,deep[v]-deep[t]);
  }
  for (i=1;i<=n;i++) dfn[i]=0;
  for (i=1;i<=n&&!Return;i++)
  	if (!dfn[i]&&f[i]==i)
  		calc(i);
  if (Return) GO puts("Yes");
}