#include <bits/stdc++.h>

#define mp make_pair
#define st first
#define nd second
#define pb push_back

using namespace std;

typedef long long ll;
typedef pair< ll,ll > pll;
typedef pair< int,int > pii;

const int N = 200000, LOGN = 19;

int n, m, k, q, tin[N+5], low[N+5], timer, bcc[N+5], anc[N+5][LOGN], dep[N+5], up[N+5], down[N+5];
bool h[N+5];
stack<int> cur;
vector<pii> v[N+5];
vector<int> tree[N+5], roots;
set<pii> edges;

void dfs(int ed, int dad, int node) {
	tin[node] = low[node] = ++timer;

	int to, sz = v[node].size();

	for (int i = 0; i < sz; i++) {
		if (v[node][i].nd == ed)
			continue;
		
		to = v[node][i].st;

		if (tin[to])
			low[node] = min(low[node], tin[to]);
		else {
			dfs(v[node][i].nd, node, to);

			low[node] = min(low[node], low[to]);
		}
	}

	cur.push(node);

	if (low[node] > tin[dad]) {
		++k;

		while (!cur.empty() && low[cur.top()] > tin[dad]) {
			bcc[cur.top()] = k;
			cur.pop();
		}
	}
}

void tree_dfs(int dad, int node) {
	anc[node][0] = dad;
	dep[node] = dep[dad] + 1;

	int to, sz = tree[node].size();

	for (int i = 0; i < sz; i++) {
		to = tree[node][i];

		if (to != dad)
			tree_dfs(node, to);
	}
}

int lca(int a, int b) {
	if (dep[a] < dep[b])
		swap(a, b);

	int diff = dep[a] - dep[b];

	for (int i = 0; i < LOGN; i++) {
		if (diff & (1 << i))
			a = anc[a][i];
	}

	if (a == b)
		return a;

	for (int i = LOGN-1; i >= 0; i--) {
		if (anc[a][i] != anc[b][i])
			a = anc[a][i], b = anc[b][i];
	}

	return anc[a][0];
}

void calc(int dad, int node) {
	h[node] = true;

	int to, sz = tree[node].size();

	for (int i = 0; i < sz; i++) {
		to = tree[node][i];

		if (to != dad)
			calc(node, to);
	}

	up[dad] += up[node];
	down[dad] += down[node];
}

int main()
{
	int x, y;

	scanf("%d %d %d", &n, &m, &q);

	for (int i = 1; i <= m; i++) {
		scanf("%d %d", &x, &y);

		v[x].pb(mp(y, i));
		v[y].pb(mp(x, i));
	}
	
	for (int i = 1; i <= n; i++) {
		if (tin[i] == 0)
			dfs(0, 0, i);
	}

	for (int i = 1; i <= n; i++) {
		for (int j = 0; j < v[i].size(); j++) {
			if (bcc[i] != bcc[v[i][j].st])
				edges.insert(mp(bcc[i], bcc[v[i][j].st]));
		}
	}

	for (set<pii> :: iterator it = edges.begin(); it != edges.end(); it++) {
		tree[it->st].pb(it->nd);
	}

	for (int i = 1; i <= k; i++) {
		if (dep[i] == 0)
			tree_dfs(0, i);
	}

	for (int i = 1; i < LOGN; i++) {
		for (int j = 1; j <= k; j++)
			anc[j][i] = anc[anc[j][i-1]][i-1];
	}

	for (int i = 1; i <= q; i++) {
		scanf("%d %d", &x, &y);

		x = bcc[x];
		y = bcc[y];

		int l = lca(x, y);
		
		up[x]++;
		up[l]--;

		down[y]++;
		down[l]--;
	}

	for (int i = 1; i <= k; i++) {
		if (!h[i])
			calc(0, i);
	}

	for (int i = 1; i <= k; i++) {
		if (up[i] && down[i]) {
			puts("No");
			return 0;
		}
	}

	puts("Yes");
	
	return 0;
}
