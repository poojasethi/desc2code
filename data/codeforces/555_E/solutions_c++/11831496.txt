#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define N 400100
using namespace std;
typedef int arr[N];
arr V, nxt, p, dfn, s, in, low, bel, vis, f[18], d, h, a, b, st, dsu;
int cnt, tim, t, n, m, q, i, ed, j;
inline int gi() {
    int s = 0; char c = getchar();
    while (c < '0' || c > '9') c = getchar();
    while (c >= '0' && c <= '9') s = s * 10 + c - '0', c = getchar();
    return s;
}
void add(int u, int v) {
    V[++ed] = v, nxt[ed] = p[u], p[u] = ed;
}
void dfs(int x, int fa) {
    dfn[x] = low[x] = ++tim;
    in[x] = 1, s[++t] = x;
    for (int i = p[x]; i != -1; i = nxt[i]) {
        int v = V[i];
        if (i == fa) continue;
        if (!dfn[v]) dfs(v, i ^ 1), low[x] = min(low[x], low[v]);
        else if (in[v]) low[x] = min(low[x], dfn[v]);
    }
    if (low[x] != dfn[x]) return;
    ++cnt; 
    while (s[t] != x) {
        int u = s[t--]; in[u] = 0, bel[u] = cnt;
    }
    in[s[t]] = 0, bel[s[t]] = cnt, t--;
}
void tree(int x) {
    vis[x] = tim;
    for (int i = p[x]; i != -1; i = nxt[i]) {
        if (vis[V[i]]) continue;
        f[0][V[i]] = x, d[V[i]] = d[x] + 1, tree(V[i]);
    }
}
int lca(int u, int v) {
    if (d[u] < d[v]) swap(u, v);
    for (int i = 17; i >= 0; i--)
        if (d[f[i][u]] >= d[v]) u = f[i][u];
    if (u == v) return u;
    for (int i = 17; i >= 0; i--)
        if (f[i][u] != f[i][v]) u = f[i][u], v = f[i][v];
    return f[0][u];
}
int find(int x) {
    return (dsu[x] == x ? x : dsu[x] = find(dsu[x]));
}
int main() {
    ed = 1, memset(p, -1, sizeof(p));
    n = gi(), m = gi(), q = gi();
    for (i = 1; i <= m; i++) {
        int u = gi(), v = gi();
        add(u, v), add(v, u), a[i] = u, b[i] = v;
    }
    for (i = 1; i <= n; i++) if (!dfn[i]) dfs(i, -1);
    for (i = 1; i <= q; i++) s[i] = gi(), st[i] = gi();
    n = cnt, tim = ed = 0, memset(p, -1, sizeof(p));
    for (i = 1; i <= m; i++) {
        int x = bel[a[i]], y = bel[b[i]];
        if (x == y) continue;
        add(x, y), add(y, x);
    }
    for (i = 1; i <= n; i++)
        if (!vis[i]) d[i] = 1, ++tim, tree(i);
    for (i = 1; i <= q; i++)
        if (vis[bel[s[i]]] != vis[bel[st[i]]]) {puts("NO"); return 0;}
    for (i = 1; i <= 17; i++)
        for (j = 1; j <= n; j++)
            f[i][j] = f[i - 1][f[i - 1][j]];
    for (i = 1; i <= n; i++) dsu[i] = i;
    for (i = 1; i <= q; i++) {
        int x = bel[s[i]], y = bel[st[i]], z = lca(x, y);
        while (d[x] > d[z]) {
            if (dsu[x] == x) h[x] |= 1, dsu[x] = find(f[0][x]);
            x = find(x);
        }
    }
    for (i = 1; i <= n; i++) dsu[i] = i;
    for (i = 1; i <= q; i++) {
        int x = bel[s[i]], y = bel[st[i]], z = lca(x, y);
        while (d[y] > d[z]) {
            if (dsu[y] == y) h[y] |= 2, dsu[y] = find(f[0][y]);
            y = find(y);
        }
    }
    for (i = 1; i <= n; i++)
        if (h[i] == 3) {puts("NO"); return 0;}
    puts("YES");
    return 0;
}