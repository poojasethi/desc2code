#include<bits/stdc++.h>
#define mp make_pair
using namespace std;

const int N = 200005;
int n, m, q, a, b;
int p[N], T[N], idx[N], low[N], L[2*N], E[2*N], H[N], sp[2*N][19], id, dfs = 1;
vector<pair<int, int> >g[N];
vector<int> tree[N];
pair<int, int> ud[N];
bool br[N], vis[N];

int find(int x, int *p) {
	if(x == p[x]) return x;
	return p[x] = find(p[x], p);
}

void tarjan(int u) {
	low[u] = idx[u] = dfs++;
	for(int i=0 ; i<(int)g[u].size() ; ++i) {
		int v = g[u][i].first;
		if(idx[v] == 0)  {
			p[v] = u;
			tarjan(v);
			if(low[v] > idx[u])
				br[g[u][i].second] = 1;
			low[u] = min(low[u], low[v]);
		} else if(v != p[u])
			low[u] = min(low[u], idx[v]);
	}
}

void DFS(int u, int depth) {
	H[u] = id;
	E[id] = u;
	L[id++] = depth;
	vis[u] = 1;
	for(int i=0 ; i<(int)tree[u].size() ; ++i)  {
		if(vis[tree[u][i]]) continue;
		DFS(tree[u][i], depth+1);
		E[id] = u;
		L[id++] = depth;
	}
}

pair<int, int> calc(int u)  {
	vis[u] = 1;
	for(int i=0 ; i<(int)tree[u].size() ; ++i) {
		if(vis[tree[u][i]]) continue;
		pair<int, int> x = calc(tree[u][i]);
		if(x.first && x.second) {
			puts("No");
			exit(0);
		}
		ud[u].first += x.first;
		ud[u].second += x.second;
	}
	return ud[u];
}

int LCA(int i, int j) {
	if(i > j) swap(i, j);
	int k = j - i + 1;
	int l = 0;
	while((1<<l) <= k) ++l;
	--l;
	if(L[sp[i][l]] <= L[sp[j - (1<<l) + 1][l]])
		return E[sp[i][l]];
	return E[sp[j - (1<<l) + 1][l]];
}

int main(int argc, char **argv) {
#ifndef ONLINE_JUDGE
	freopen("a.in", "r", stdin);
#endif
	scanf("%d%d%d", &n, &m, &q);
	for(int i=0 ; i<m ; ++i) {
		scanf("%d%d", &a, &b);
		--a, --b;
		g[a].push_back(mp(b, i));
		g[b].push_back(mp(a, i));
	}
	memset(H, -1, sizeof H);
	for(int i=0 ; i<n ; ++i)
		if(idx[i] == 0)
			tarjan(i);
	for(int i=0 ; i<n ; ++i)
		p[i] = i;
	for(int i=0 ; i<n ; ++i)
		for(int j=0 ; j<(int)g[i].size() ; ++j) {
			if(br[g[i][j].second]) continue;
			a = find(i, p);
			b = find(g[i][j].first, p);
			if(a != b)
				p[a] = b;
		}
	for(int i=0 ; i<n ; ++i)
		T[i] = p[i];
	for(int i=0 ; i<n ; ++i)
		for(int j=0 ; j<(int)g[i].size() ; ++j)
			if(br[g[i][j].second]) {
				a = find(i, p);
				b = find(g[i][j].first, p);
				if(a != b) {
					T[find(a, T)] = find(b, T);
					tree[a].push_back(b);
				}
			}
	for(int i=0 ; i<n ; ++i)
		if(T[i] == i)  {
			tree[i].push_back(n);
			tree[n].push_back(i);
		}
	DFS(n, 0);
	for(int i=0 ; i<2*n ; ++i)
		sp[i][0] = i;
	for(int j=1 ; (1<<j) <= n+n ; ++j)
		for(int i=0 ; i+(1<<j) <= n+n ; ++i)
			if(L[sp[i][j-1]] <= L[sp[i+(1<<(j-1))][j-1]])
				sp[i][j] = sp[i][j-1];
			else
				sp[i][j] = sp[i+(1<<(j-1))][j-1];


	while(q--) {
		scanf("%d%d", &a, &b);
		--a, --b;
		a = find(a, p), b = find(b, p);
		if(a == b) continue;
		int c = LCA(H[a], H[b]);

		if(c == n)
			return puts("No"), 0;
		++ud[a].first;
		--ud[c].first;
		++ud[b].second;
		--ud[c].second;
	}
	memset(vis, 0, sizeof vis);
	calc(n);
	puts("Yes");
	return 0;
}
