//In the name of God
#include <bits/stdc++.h>
#define F first
#define S second
#define ll long long
#define pb push_back
using namespace std;
const int mod = 1000 * 1000 * 1000 + 7;
typedef pair < int , int > pii;

const int maxn = 1000 * 100 * 2 + 10;
vector< pii > adj[maxn];
int mark[maxn];
int par[maxn][21];
int d[maxn];
int n , m , q;
int up[maxn];
vector< pii >vv[maxn];
inline void DFS( int v , int t )
{
    mark[v] = t;
    for(int i=0;i<adj[v].size();++i)    {
        int u = adj[v][i].F;
        if( mark[u] == 0 )
            DFS( u , t );
    }
}

inline void Dfs( int v , int p )
{
    for(int i=1;i<21;++i)
        par[v][i] = par[ par[v][i-1] ][i-1];
    for(int i=0;i<adj[v].size();++i)    {
        int u = adj[v][i].F;
        if( u!=p && par[u][0]==0 )  {
            par[u][0] = v;
            d[u] = d[v]+1;
            Dfs( u , p );
        }
    }
}

inline pii P_E( int fi , int se )
{
    if( d[fi] > d[se] )
        return P_E( se , fi );
    for(int i=20;i>=0;--i)
        if( d[par[se][i]] > d[fi] )
            se = par[se][i];
    return pii( par[se][0] , fi );
}

inline int PAR( int fi , int se )
{
    if( d[fi] != d[se] )    {
        pii P = P_E( fi , se );
        return PAR( P.F , P.S );
    }
    if( fi == se )
        return fi;
    for(int i=20;i>=0;--i)
        if( par[fi][i] != par[se][i] )
            fi = par[fi][i] , se = par[se][i];
    return par[fi][0];
}

inline pii dfs( int v , int t )
{
    up[v] = d[v];
    mark[v] = 1 ;
    pii ret = pii( n+1 , n+1 );
    for(int i=0;i<adj[v].size();++i)    {
        int u = adj[v][i].F;
        if(mark[u]==0)  {
            pii T = dfs( u , adj[v][i].S );
            up[v] = min( up[v] , up[u] );
            ret.F = min( ret.F , T.F ) , ret.S = min( ret.S , T.S );
        }
        else
            if( adj[v][i].S != t )
                up[v] = min( up[v] , d[ adj[v][i].F ] );
    }
    for(int i=0;i<vv[v].size();++i)
        if( vv[v][i].S == 2 )
            ret.S = min( ret.S , d[vv[v][i].F] );
        else
            ret.F = min( ret.F , d[vv[v][i].F] );

    if( up[v] >= d[v] && ret.F<d[v] && ret.S<d[v] ) {
        cout << "NO" << endl;
        exit(0);
    }
    return ret;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin >> n >> m >> q;
    for(int i=1;i<=m;++i)   {
        int fi , se ;
        cin >> fi >> se;
        adj[fi].pb({se,i});
        adj[se].pb({fi,i});
    }
    int cnt = 0 ;
    for(int i=1;i<=n;++i)   {
        if( mark[i] == 0 )
            DFS( i , ++cnt );
    }

    for(int i=1;i<=n;++i)
        if(par[i][0] == 0)
            Dfs( i , i );

    while( q --> 0 )    {
        int fi , se;
        cin >> fi >> se;
        if( mark[fi] != mark[se] )  {
            cout << "NO" << endl;
            return 0;
        }
        int dad = PAR( fi , se );
        vv[fi].pb( { dad , 1 } );
        vv[se].pb( { dad , 2 } );
    }
    memset( mark , 0 , sizeof mark );
    for(int i=1;i<=n;++i)   {
        if(mark[i] == 0)
            dfs( i , 0 );
    }

    cout << "YES" << endl;

    return 0;
}
