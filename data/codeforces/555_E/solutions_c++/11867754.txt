#include <cstdlib>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <queue>
#include <cmath>
#include <stack>
#include <map>
#include <set>
#include <deque>
#include <cstring>
#include <functional>
#include <climits>
#include <list>

#define F1(x,y,z) for(int x=y;x<z;x++)
#define F2(x,y,z) for(int x=y;x<=z;x++)
#define F3(x,y,z) for(int x=y;x>z;x--)
#define F4(x,y,z) for(int x=y;x>=z;x--)
#define W(x) while(x-->0)
#define SI(x) scanf("%d",&x)
#define pb push_back
#define LL long long

#define MAX 200005

#define f(c,d) ((1<<(c))*(d))

using namespace std;

struct w{
	int a,b;
} ww[MAX],www[MAX];
int wi,wwi;

int n,m,q;
int par1[MAX];
int rank[MAX];
int depth[MAX];
int newpar[MAX];
int root[MAX];
int no,i;
int start[MAX],end[MAX];
int par2[MAX];
int par_edge_i[MAX];
vector<pair<int,bool> > edge1[MAX];
vector<int> edge2[MAX];
vector<char> edge2_m[MAX];
int ta,tb;

int find(int a){
	return a==par1[a]?a:par1[a]=find(par1[a]);
}

int dfs1(int a,int b,int d){
	if(depth[a])return depth[a];
	depth[a]=d;
	int re=INT_MAX;
	F1(c,0,edge1[a].size())if(edge1[a][c].first!=b){
		int to=edge1[a][c].second?ww[edge1[a][c].first].a:ww[edge1[a][c].first].b;
		int t=dfs1(to,edge1[a][c].first,d+1);
		if(t!=INT_MAX){
			re=min(re,t);
			ta=find(a);
			tb=find(to);
			if(ta==tb)continue;
			if(rank[ta]<rank[tb])par1[ta]=tb;
			else if(rank[ta]>rank[tb])par1[tb]=ta;
			else{
				par1[tb]=ta;
				rank[ta]++;
			}
		}
	}
	if(re==d)return INT_MAX;
	else return re;
}

void dfs2(int a,int b,int c){
	root[a]=b;
	par2[a]=c;
	start[a]=++i;
	F1(d,0,edge2[a].size())if(edge2[a][d]!=c){
		if(root[edge2[a][d]]!=0)while(true){}
		dfs2(edge2[a][d],b,a);
		par_edge_i[edge2[a][d]]=d;
	}
	end[a]=++i;
}

bool path(int a,int b,char c){
	if(start[a]<=b&&b<=end[a])return 0;
	if(edge2_m[par2[a]][par_edge_i[a]]==3-c)return 1;
	if(edge2_m[par2[a]][par_edge_i[a]]==0){
		edge2_m[par2[a]][par_edge_i[a]]=c;
		return path(par2[a],b,c);
	}
	return 0;
}

int main(){
	SI(n);
	F2(a,1,n)par1[a]=a;
	SI(m);
	SI(q);
	F1(a,0,m){
		SI(ta);
		SI(tb);
		edge1[ta].pb(make_pair(wi,0));
		edge1[tb].pb(make_pair(wi,1));
		ww[wi].a=ta;
		ww[wi].b=tb;
		wi++;
	}
	F2(a,1,n)dfs1(a,-1,1);
	F2(a,1,n){
		if(newpar[find(a)]==0)newpar[par1[a]]=++no;
		newpar[a]=newpar[par1[a]];
		//printf(" %d %d\n",a,newpar[a]);
	}
	F1(a,0,m)if(newpar[ww[a].a]!=newpar[ww[a].b]){
		www[wwi].a=newpar[ww[a].a];
		www[wwi].b=newpar[ww[a].b];
		wwi++;
		edge2[newpar[ww[a].a]].pb(newpar[ww[a].b]);
		edge2[newpar[ww[a].b]].pb(newpar[ww[a].a]);
		edge2_m[newpar[ww[a].a]].pb(0);
		edge2_m[newpar[ww[a].b]].pb(0);
	}
	F2(a,1,no)if(root[a]==0)dfs2(a,a,-1);
	W(q){
		SI(ta);
		SI(tb);
		ta=newpar[ta];
		tb=newpar[tb];
		if(root[ta]!=root[tb]||(path(ta,start[tb],1)|path(tb,start[ta],2))){
			printf("No\n");
			return 0;
		}
	}
	printf("Yes\n");
	//system("pause");
    return 0;
}
