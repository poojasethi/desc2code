#include <stdio.h>
#include <vector>
#include <stdlib.h>

using namespace std;

#define min(a, b) ((a) < (b) ? (a) : (b))
#define max(a, b) ((a) > (b) ? (a) : (b))

struct sEdge {
    int u, v;
    bool bridge, backedge;
} e[200009];

vector<int> neigh[200009];

int S[200009];
int T[200009];
int LCA[200009];
int par[200009];

int Find(int i) {
    if (i == par[i]) return i;
    return par[i] = Find(par[i]);
}
void Union(int i, int j) {
    par[Find(i)] = Find(j);
}

vector<int> qq[200009];

int depth[200009];
int up[200009];
int comp[200009];

void DFS1(int v, int prev, int d, int cc)
{
    for (int i = 0; i < qq[v].size(); i++) {
        int u = S[ qq[v][i] ];
        if (u == v)
            u = T[ qq[v][i] ];
        LCA[ qq[v][i] ] = Find(u);
    }


    comp[v] = cc;

    depth[v] = d;
    up[v] = d;

    for (int i = 0; i < neigh[v].size(); i++) {
        int id = neigh[v][i];
        int u = (e[id].v == v ? e[id].u : e[id].v);

        if (!depth[u]) {
            DFS1(u, id, d+1, cc);
            Union(u, v);
            if (up[u] > depth[v])
                e[id].bridge = true;
            up[v] = min(up[v], up[u]);
        }
        else if (id != prev) {
            up[v] = min(up[v], depth[u]);
            e[id].backedge = true;
        }
    }
}


int a1[200009];
int a2[200009];

void DFS2(int v, int p)
{
    for (int i = 0; i < neigh[v].size(); i++) {
        int id = neigh[v][i];
        int u = (e[id].v == v ? e[id].u : e[id].v);

        if (e[id].backedge) continue;
        if (u == p) continue;

        DFS2(u, v);
        a1[v] += a1[u];
        a2[v] += a2[u];

        if (e[id].bridge && a1[u] && a2[u]) {
            printf("No");
            exit(0);
        }
    }
}

int main()
{
    int n, m, q;
    scanf("%d %d %d", &n, &m, &q);

    for (int i = 1; i <= m; i++) {
        scanf("%d %d", &e[i].u, &e[i].v);
        neigh[e[i].u].push_back(i);
        neigh[e[i].v].push_back(i);
    }

    for (int i = 0; i < q; i++) {
        scanf("%d %d", &S[i], &T[i]);
        qq[ S[i] ].push_back(i);
        qq[ T[i] ].push_back(i);
    }

    for (int v = 1; v <= n; v++) par[v] = v;

    for (int v = 1; v <= n; v++) if (!depth[v]) DFS1(v, -1, 1, v);

    for (int i = 0; i < q; i++) {
        int s = S[i];
        int t = T[i];
        if (comp[s] != comp[t]) {
            printf("No");
            return 0;
        }
        int p = LCA[i];
        a1[s]++;
        a1[p]--;
        a2[t]++;
        a2[p]--;
    }

    DFS2(1, -1);
    printf("Yes");
}
