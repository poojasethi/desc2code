#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long LL;
#define inf 999999999
#define INF 1000000000000000005ll
const int NN=100111;
int val[NN<<1],pre[NN<<1],son[NN<<1][4],dp[NN<<1][4];
int TTT,last,len,bit;
LL n;
bool vt[NN<<1];
char s[NN];
void samadd(int x)
{
	int end=++TTT,p=last;
	last=end;
	val[end]=val[p]+1;
	for (;p!=-1&&!son[p][x];p=pre[p]) son[p][x]=end;
	if (p==-1) {pre[end]=0;return;}
	int q=son[p][x];
	if (val[q]==val[p]+1) {pre[end]=q;return;}
	int nq=++TTT;
	val[nq]=val[p]+1;
	pre[nq]=pre[q];
	pre[q]=pre[end]=nq;
	memcpy(son[nq],son[q],sizeof(son[q]));
	for (;p!=-1&&son[p][x]==q;p=pre[p]) son[p][x]=nq;
}
void dfs(int v)
{
	vt[v]=true;
	for (int i=0;i<4;i++) dp[v][i]=inf;
	for (int i=0;i<4;i++)
		if (son[v][i])
		{
			if (!vt[son[v][i]]) dfs(son[v][i]);
			for (int k=0;k<4;k++)
				dp[v][k]=min(dp[v][k],dp[son[v][i]][k]+1);
		}
		else dp[v][i]=1;
}
struct matrix
{
	LL qq[4][4];
	LL * operator [](int x) {return qq[x];}
	matrix()
	{
		for (int i=0;i<4;i++)
			for (int j=0;j<4;j++) qq[i][j]=INF;
	}
	friend matrix operator *(matrix a,matrix b)
	{
		matrix c;
		for (int i=0;i<4;i++)
			for (int j=0;j<4;j++)
				for (int k=0;k<4;k++)
					c[i][j]=min(c[i][j],a[i][k]+b[k][j]);
		return c;
	}
	inline bool check()
	{
		for (int i=0;i<4;i++)
			for (int j=0;j<4;j++)
				if (qq[i][j]<n) return true;
		return false;
	}
} f[71],now;
int main()
{
	//freopen("1.in","r",stdin);freopen("1.out","w",stdout);
	scanf("%I64d\n%s",&n,s+1);
	len=strlen(s+1);
	pre[0]=-1;
	int i,j;
	for (i=1;i<=len;i++) samadd(s[i]-'A');
	dfs(0);
	for (i=0;i<4;i++)
		for (j=0;j<4;j++) f[0][i][j]=dp[son[0][i]][j];
	for (bit=1;(1ll<<bit)<=n;bit++)
		f[bit]=f[bit-1]*f[bit-1];
	LL ans=0;
	for (i=0;i<4;i++) now[i][i]=0;
	for (i=bit;i>=0;i--)
		if ((now*f[i]).check())
		{
			now=now*f[i];
			ans|=1ll<<i;
		}
	printf("%I64d\n",ans+1);
	return 0;
}