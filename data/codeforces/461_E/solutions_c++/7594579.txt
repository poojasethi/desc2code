#include <iostream>
#include <sstream>
#include <fstream>
#include <string>
#include <vector>
#include <deque>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <algorithm>
#include <functional>
#include <utility>
#include <bitset>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstdio>

using namespace std;

#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)
#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)

typedef long long ll;
#define INF (1ll<<60)

char buf[100010];
int N;
int a[100010];
int four[20];
bool found[(1<<20)];
int graph[4][4];

void check(int d){
    int i,j;
    
    REP(i,four[d]) found[i] = false;
    
    REP(i,N-d+1){
        int tmp = 0;
        REP(j,d) tmp = tmp * 4 + a[i+j];
        found[tmp] = true;
    }
    
    REP(i,four[d]) if(!found[i]){
        int s = i / four[d-1];
        int t = i % 4;
        graph[s][t] = min(graph[s][t], d-1);
    }
}

struct matrix {ll a[4][4];};

matrix prod(matrix A, matrix B){
    matrix C;
    int i,j,k;
    REP(i,4) REP(j,4) C.a[i][j] = INF;
    REP(i,4) REP(j,4) REP(k,4) C.a[i][k] = min(C.a[i][k], A.a[i][j] + B.a[j][k]);
    return C;
}

ll shortest_path(ll K){
    int i,j;
    
    matrix A;
    REP(i,4) REP(j,4) A.a[i][j] = graph[i][j];
    matrix O;
    REP(i,4) REP(j,4) O.a[i][j] = 0;
    
    REP(i,60){
        if(K&(1ll<<i)) O = prod(O, A);
        A = prod(A, A);
    }
    
    ll ans = INF;
    REP(i,4) REP(j,4) ans = min(ans, O.a[i][j]);
    return ans;
}

int main(void){
    int i,j;
    
    ll X;
    cin >> X;
    scanf("%s", buf);
    while(buf[N] != '\0'){
        a[N] = buf[N] - 'A';
        N++;
    }
    
    REP(i,16) four[i] = (1<<(2*i));
    
    REP(i,4) REP(j,4) graph[i][j] = 10;
    for(i=2;i<=10;i++) check(i);
    
    // REP(i,4) REP(j,4) cout << i << ' ' << j << ' ' << graph[i][j] << endl;
    // REP(i,10) cout << i << ' ' << shortest_path(i) << endl;
    
    // find max k s.t. (shortest k-path) <= (X-1) and return k+1
    ll low = 0, high = (1ll<<60);
    while(high - low > 1){
        ll mid = (low + high) / 2;
        ll tmp = shortest_path(mid);
        if(tmp <= X-1) low = mid; else high = mid;
    }
    
    cout << low + 1 << endl;
    
    return 0;
}
