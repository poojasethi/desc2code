/* Template the Final Chapter Light --- Fimbulvetr version 0.1 */
/* In this blizzard, I will find peace. */
# define LOCAL
# include <cstring>
# include <cstdio>
# include <algorithm>
# include <vector>
# include <string>
# include <set>
# include <map>
using namespace std;
# define REP( i, n ) for ( int i = 1; i <= n; i ++ )
# define REP_0( i, n ) for ( int i = 0; i < n; i ++ )
# define REP_0N( i, n ) for ( int i = 0; i <= n; i ++ )
# define REP_S( i, ss ) for ( char *i = ss; *i; i ++ )
# define REP_G( i, u ) for ( int i = pos[ u ]; i; i = g[ i ].frt )
# define FOR( i, a, b ) for ( int i = a; i <= b; i ++ )
# define DWN( i, a, b ) for ( int i = b; i >= a; i -- )
# define RST( a ) memset ( a, 0, sizeof ( a ) )
# define CLR( a, x ) memset ( a, x, sizeof ( a ) )
# define CPY( a, b ) memcpy ( a, b, sizeof ( a ) )
typedef long long LL;
const int inf = 1 << 30;
const LL lnf = 1LL << 62;
# define SS 100010
struct matrix
{
	LL a[ 5 ][ 5 ];
matrix () { REP ( i, 4 ) REP ( j, 4 ) a[ i ][ j ] = lnf; }
matrix operator* ( const matrix b )
{
	matrix ret;
	REP ( i, 4 ) REP ( k, 4 ) REP ( j, 4 ) ret.a[ i ][ j ] = min ( ret.a[ i ][ j ], a[ i ][ k ] + b.a[ k ][ j ] );
	return ret;
}
} g[ 70 ];
struct samnode { int ch[ 5 ], par, l; samnode() { CLR ( ch, -1 ); } } sam[ 2 * SS ];
LL n; 
int lst, ssz, dep[ SS * 2 ], q[ SS * 2 ], head, tail, l;
char s[ SS ];
# define u sam[ x ]
# define v u.ch[ c ]
# define w sam[ z ]
# define r sam[ y ]
# define vn sam[ v ]
void AddChar ( int c )
{
    int x = lst, z = ++ ssz; lst = z, w.l = u.l + 1;
	for ( ; x != -1 && v == -1; x = u.par ) v = z;
	if ( x == -1 ) w.par = 0;
	else if ( u.l + 1 == vn.l ) w.par = v;
	else
	{
		int tv = v, y = ++ ssz;
		CPY ( r.ch, vn.ch ), r.par = vn.par, r.l = u.l + 1, vn.par = w.par = y;
		for ( ; x != -1 && v == tv; x = u.par ) v = y;
	}
}
void BFS ( int sc )
{
	int x = 0; RST ( dep );
	dep[ q[ head = tail = 1 ] = u.ch[ sc ] ] = 1;
	while ( head <= tail )
	{
		x = q[ head ++ ];
		REP ( c, 4 )
		{
			if ( v == -1 ) { if ( !g[ 0 ].a[ sc ][ c ] ) g[ 0 ].a[ sc ][ c ] = dep[ x ]; }
			else if ( !dep[ v ] ) dep[ q[ ++ tail ] = v ] = dep[ x ] + 1;
		}
	}
}
void Init ()
{
	RST ( g[ 0 ].a ), scanf ( "%I64d%s", &n, s ), l = strlen ( s ), sam[ 0 ].par = -1;
	REP_0 ( i, l ) AddChar ( s[ i ] - 'A' + 1 );
	REP ( i, 4 ) BFS ( i );
	REP ( i, 62 ) g[ i ] = g[ i - 1 ] * g[ i - 1 ];
}
bool Check ( LL p )
{
	matrix a; RST ( a.a ); LL mn = lnf;
	REP_0 ( i, 62 ) if ( ( 1LL << i ) & p ) a = a * g[ i ];
	REP ( i, 4 ) REP ( j, 4 ) mn = min ( mn, a.a[ i ][ j ] );
	return mn < n;
}
# undef r
int main ()
{
	Init ();
	LL l = 0, r = LL(1e18);
	for ( ; l < r; )
	{
		LL mid = ( l + r ) / 2;
		if ( Check ( mid ) ) l = mid + 1;
		else r = mid;
	}
	printf ( "%I64d\n", l );
	return 0;
}