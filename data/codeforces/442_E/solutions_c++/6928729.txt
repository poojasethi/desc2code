#include <cmath>
#include <map>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <set>
#include <bitset>
#include <memory.h>
#include <functional>
#include <queue>
#include <fstream>
#include <ctime>
#include <deque>
#include <utility>
#include <stack>
#include <sstream>
#include <list>
#include <cctype> 
#include <numeric> 
#include <iomanip>
#include <assert.h>
using namespace std;
#define sqr(_) ((_)*(_))

typedef long double ld;
typedef pair<int, int> Pii;
typedef pair<ld, ld> P;
#define x first
#define y second
#define mp make_pair
#define pb push_back

typedef long long LL;

P operator +(const P &a, const P &b) {
	return mp(a.x + b.x, a.y + b.y);
}
P operator -(const P &a, const P &b) {
	return mp(a.x - b.x, a.y - b.y);
}
P operator *(const P &a, ld k) {
	return mp(a.x * k, a.y * k);
}
P operator /(const P &a, ld k) {
	return mp(a.x / k, a.y / k);
}
ld dot(const P &a, const P &b) {
	return a.x * b.x + a.y * b.y;
}
ld det(const P &a, const P &b) {
	return a.x * b.y - b.x * a.y;
}
ld len2(const P &a) {
	return a.x * a.x + a.y * a.y;
}
ld len(const P &a) {
	return sqrt(len2(a));
}
ld At(const P &a) {
	return atan2(a.y, a.x);
}
const ld EPS = 1E-10;

P intersect(const P &a, const P &b, const P &c, const P &d)
{
	ld k1 = det(b - a, c - a), k2 = det(b - a, d - a);
	if (fabs(k1 - k2) < EPS)
		return mp(-1, -1);
	return (d * k1 - c * k2) / (k1 - k2);
}

const int MAXN = 1000 + 10;

struct HP
{
	P x, v;
	ld agl;
	int id;
	HP() {}
	HP(P x, P v, int id): x(x), v(v), id(id) {
		agl = atan2(v.y, v.x);
	}
	bool operator <(const HP &b) const {
			return agl < b.agl;
	}
	void Print() {
		cout << x.x << " " << x.y << " " << x.x + v.x << " " << x.y + v.y << endl;
	}
}h[MAXN];
//det(HP.v, A - HP.x) > 0, A is on the halfplane

map<Pii, int> t;
int n, N, W, H, tot;
P p[MAXN];
bool ml[MAXN];

void init()
{
	scanf("%d%d%d", &W, &H, &N);
	for (int i = 1; i <= N; ++i)
	{
		Pii w;
		cin >> w.x >> w.y;
		++t[w];
	}
	for (map<Pii, int>::iterator it = t.begin(); it != t.end(); ++it)
		p[++n] = it -> x, ml[n] = it -> y > 1;
//	for (int i = 1; i <= n; ++i)
//		cout << p[i].x << " " << p[i].y << " " << ml[i] << endl;
}
ld Count(int l, int r, int w, int id)
{
	if (ml[h[w].id] || !h[w].id) return 0;
	static int head, tail, que[MAXN];
	static P b[MAXN];
	head = 1, tail = 1, que[1] = l;
	for (int i = l + 1; ; ++i)
	{
		if (i > tot) i = 1;
		if (i == w) continue ;
//		cout << i << endl;
		while (head < tail && det(h[i].v, b[tail - 1] - h[i].x) < EPS) --tail;
		while (head < tail && det(h[i].v, b[head] - h[i].x) < EPS) ++head;
		que[++tail] = i;
		if (head < tail && fabs(h[que[tail - 1]].agl - h[i].agl) < EPS)
		{
			--tail;
			if (det(h[que[tail]].v, h[i].x - h[que[tail]].x) > 0)
				que[tail] = i;
		}
		if (head < tail)
			b[tail - 1] = intersect(h[que[tail - 1]].x, h[que[tail - 1]].x + h[que[tail - 1]].v, h[que[tail]].x, h[que[tail]].x + h[que[tail]].v);
		if (i == r) break;
	}
	ld Ririchiyo = 0;
	for (int i = head; i < tail; ++i)
	{
		if (b[i] != P(-1, -1) && b[i].x >= 0 && b[i].x <= (ld)W && b[i].y >= 0 && b[i].y <= (ld)H)
			Ririchiyo = max(Ririchiyo, len(b[i] - p[id]));
//		cout << b[i].x << " " << b[i].y << endl;
	}
//	cout << fixed << Ririchiyo << "A" << endl;
	return Ririchiyo;
}
ld Calc(int id)
{
	tot = 0;
	h[++tot] = HP(P(0, 0), P(W, 0), 0);
	h[++tot] = HP(P(W, 0), P(0, H), 0);
	h[++tot] = HP(P(W, H), P(-W, 0), 0);
	h[++tot] = HP(P(0, H), P(0, -H), 0);
	for (int i = 1; i <= n; ++i)
		if (i != id)
		{
			P v = p[i] - p[id], o = p[id] + v * 0.5;
			swap(v.x, v.y); v.x = -v.x;
			h[++tot] = HP(o, v, i);
		}
	
	sort(h + 1, h + tot + 1);
	static int head, tail, que[MAXN];
	static P b[MAXN];
	head = tail = 1, que[1] = 1;
	for (int i = 2; i <= tot; ++i)
	{
		while (head < tail && det(h[i].v, b[tail - 1] - h[i].x) < EPS) --tail;
		while (head < tail && det(h[i].v, b[head] - h[i].x) < EPS) ++head;
		que[++tail] = i;
		if (head < tail && fabs(h[que[tail - 1]].agl - h[i].agl) < EPS)
		{
			--tail;
			if (det(h[que[tail]].v, h[i].x - h[que[tail]].x) > 0)
				que[tail] = i;
		}
		if (head < tail)
			b[tail - 1] = intersect(h[que[tail - 1]].x, h[que[tail - 1]].x + h[que[tail - 1]].v, h[que[tail]].x, h[que[tail]].x + h[que[tail]].v);
	}
	while (head < tail && det(h[que[head]].v, b[tail - 1] - h[que[head]].x) < 0)
		--tail;
	b[tail] = intersect(h[que[head]].x, h[que[head]].x + h[que[head]].v, h[que[tail]].x, h[que[tail]].x + h[que[tail]].v);
//	for (int i = head; i <= tail; ++i)
//		cout << b[i].x << " " << b[i].y << endl;
//	cout << endl;
	
	ld Ririchiyo = 0;
	if (ml[id])
	{
		for (int i = head; i <= tail; ++i)
			Ririchiyo = max(Ririchiyo, len(b[i] - p[id]));
	}
	int m = tail - head + 1;
	for (int i = 1, j = head; i <= m; ++i, ++j)
		que[i] = que[j];
	for (int i = 1; i + 2 <= m; ++i)
		Ririchiyo = max(Ririchiyo, Count(que[i], que[i + 2], que[i + 1], id));
	Ririchiyo = max(Ririchiyo, Count(que[m - 1], que[1], que[m], id));
	Ririchiyo = max(Ririchiyo, Count(que[m], que[2], que[1], id));
//	cout << fixed << Ririchiyo << endl;
	return Ririchiyo;
}
void solve()
{
	ld Tohka = 0;
	cout << setprecision(10);
	for (int i = 1; i <= n; ++i)
		Tohka = max(Tohka, Calc(i));
	cout << fixed << Tohka << endl;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout);
#endif
	
	init();
	solve();
	
	fclose(stdin);
	fclose(stdout);
	return 0;
}
