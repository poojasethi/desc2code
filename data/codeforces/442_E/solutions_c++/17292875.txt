#include<cstdio>
#include<iostream> 
#include<algorithm>
#include<cstring>
#include<set>
#include<map>
#include<cmath>
#include<vector>
#include<queue>
using namespace std;
typedef unsigned long long ull; 
typedef long long ll;
typedef unsigned int uint; 
#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)
#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)
#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)
#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])
#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])
#define ms(x,y) memset(x,y,sizeof x)
#define ls (x<<1)
#define rs (x<<1|1)
#define w1 first
#define w2 second
#define mp make_pair
#define pa pair<int,int>
#define pb push_back
#define ins insert
#define lowbit(x) ((x)&(-x))
template<class T>inline void rread(T&num){
	num=0;T f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();
	num*=f;
}
inline int getgcd(int x,int y){if(!x)return y;return getgcd(y%x,x);}
inline ll getlcm(int x,int y){return (ll)x/getgcd(x,y)*y;}
inline ll getgcd(ll x,ll y){if(!x)return y;return getgcd(y%x,x);}
inline ll getlcm(ll x,ll y){return x/getgcd(x,y)*y;}
inline int power(int x,int k,int p){int res=1;for(;k;k>>=1,x=(ll)x*x%p)if(k&1)res=(ll)res*x%p;return res;}
//********************************head*************************************
#define sqr(x) (x)*(x)
#define eps 1e-10
const int maxn=2005;
struct point{
	double x,y;
	inline point(){x=y=0;}
	inline point(double _x,double _y){x=_x;y=_y;}
	inline friend bool operator!=(point a,point b){return a.x!=b.x||a.y!=b.y;}
	inline friend double dis(point a,point b){return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));}
}p[maxn];
int w,h,n,cnt,tot;
double dist[maxn][maxn];
pair<double,int>q[maxn];
const double pi=acos(-1.0);
inline void insert(double l,double r,int flag=1){
	if(l<-pi)cnt+=flag,l+=pi*2;
	if(r>pi)cnt+=flag,r-=pi*2;
	q[++tot]=mp(l,flag);
	q[++tot]=mp(r,-flag);
}
inline bool check(int x,double r){
	tot=cnt=0;
	point tmp=p[x];
	if(r>tmp.x){
		double a=-pi,t=acos(tmp.x/r);
		insert(a-t,a+t,2);
	}
	if(r>tmp.y){
		double a=-pi/2,t=acos(tmp.y/r);
		insert(a-t,a+t,2);
	}
	if(r>w-tmp.x){
		double a=0,t=acos((w-tmp.x)/r);
		insert(a-t,a+t,2);
	}
	if(r>h-tmp.y){
		double a=pi/2,t=acos((h-tmp.y)/r);
		insert(a-t,a+t,2);
	}
	rep(i,1,n)if(i!=x&&p[i]!=p[x]){
		double d=dist[i][x];
		if(r+r>d){
			double a=atan2(p[i].y-tmp.y,p[i].x-tmp.x),t=acos(d/2/r);
			insert(a-t,a+t);
		}
	}
	sort(q+1,q+tot+1);
	if(cnt<=1)return 1;
	rep(i,1,tot){
		if(cnt<=1)return 1;
		cnt+=q[i].w2;
	}
	return 0;
}
int main(){
	rread(w);rread(h);rread(n);
	rep(i,1,n)rread(p[i].x),rread(p[i].y);
	random_shuffle(p+1,p+n+1);
	rep(i,1,n)rep(j,1,n)dist[i][j]=dis(p[i],p[j]);
	double lim=dis(point(0,0),point(w,h)),ans=0;
	rep(i,1,n){
		if(check(i,ans+eps)){
			double l=ans,r=lim;
			rep(t,1,60){
				double m=(l+r)/2;
				if(check(i,m))l=m;
				else r=m;
			}
			ans=l;
		}
	}
	printf("%.12f\n",ans);
	return 0;
}