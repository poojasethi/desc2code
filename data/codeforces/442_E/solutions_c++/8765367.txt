#include <algorithm>
#include <iostream>
#include <iomanip>
#include <complex>
#include <cstring>
#include <cstdlib>
#include <string>
#include <vector>
#include <cstdio>
#include <cmath>
#include <queue>
#include <stack>
#include <map>
#include <set>
#include <time.h>
#define int_bit_count __builtin_popcount
#define ll_bit_count  __builtin_popcountll
#define gcd  __gcd
#define pb push_back
#define mp make_pair
#define REP(i, n) for( (i) = 0; (i) < (int)(n);(i) ++)
using namespace std;
//#pragma comment(linker,"/STACK:102400000,102400000")

typedef long long ll;
const int MAXN = 1005;
const double EPS = 1e-11;
const double  PI = acos(-1.);

struct intersection
{
    double angle;
    int flag;
};

bool comp(const intersection &x, const intersection &y)
{
    if (x.angle != y.angle) {
        return x.angle < y.angle;
    }
    return x.flag > y.flag;
}

struct point
{
    double x, y;
};

intersection p[MAXN * 6];
point q[MAXN];
int len, n;
double f[MAXN][MAXN], w, h;

void add1(double l, double r, int flag)
{
    ++ len;
    p[len].angle = l, p[len].flag = flag;
    ++ len;
    p[len].angle = r + EPS, p[len].flag = -flag;
}

void add(double x,double y,int flag){
    if(x < - PI) {
        add1(x + 2 * PI, PI, flag);
        x = - PI;
    }
    if( y > PI)
    {
        add1(- PI, y - 2 * PI, flag);
        y = PI;
    }
    add1(x,y,flag);
}
/*
bool check(int a, long double r)
{
    len = 1;
    double v;
    if (q[a].x < r) {
        v = acos(q[a].x / r);
        add(- PI - v, - PI + v, 2);
    }
    if (q[a].x + r > w) {
        v = acos((w - q[a].x) / r);
        add( - v,  + v, 2);
    }
    if (q[a].y < r) {
        v = acos(q[a].y / r);
        add(- PI / 2. - v, - PI / 2. + v, 2);
    }
    if (q[a].y + r > h) {
        v = acos((h - q[a].y) / r);
        add(PI / 2 - v, PI / 2. + v, 2);
    }
    for (int i = 0; i < n; ++ i) {
        if (i == a) continue;
        double l = sqrt((q[i].x - q[a].x) * (q[i].x - q[a].x) + (q[i].y - q[a].y) * (q[i].y - q[a].y));
        if (l - 2 * r > EPS && fabs(l) < EPS) {
            continue;
        }
        add(f[a][i] - acos(l / 2 / r), f[a][i] + acos(l / 2 / r), 1);
    }
    p[0].angle = -PI, p[0].flag =0;
    sort(p + 1, p + len + 1, comp);
    p[len].angle = PI, p[len].flag = 0;
    len ++;
    int sum = 0;
    sum += p[0].flag;
    for (int i = 1; i < len; ++ i) {
        if (sum <= 1 && (p[i].angle - p[i - 1].angle >= EPS)) {
            return true;
        }
        sum += p[i].flag;
    }
    return false;
}
*/

bool check(int i,double mid){
    len=0;
    for(int j = 0; j < n; ++ j)
    {
        if (j != i) {
            double l = sqrt((q[i].x - q[j].x) * (q[i].x - q[j].x) + (q[i].y - q[j].y) * (q[i].y - q[j].y));
            if (l < 2 * mid && fabs(l) > EPS) {
                add(f[i][j] - acos(l / 2 / mid), f[i][j] + acos(l / 2 / mid), 1);
            }
        }
    }
    if(q[i].y-mid<0){
        double d=acos(q[i].y/mid);
        add(-PI/2-d,-PI/2+d,2);
    }
    if(q[i].y+mid>h){
        double d=acos((h-q[i].y)/mid);
        add(PI/2-d,PI/2+d,2);
    }
    if(q[i].x-mid<0){
        double d=acos(q[i].x/mid);
        add(-PI-d,-PI+d,2);
    }
    if(q[i].x+mid>w){
        double d=acos((w-q[i].x)/mid);
        add(0-d,0+d,2);
    }
    //
    sort(p+1,p+len+1,comp);
    p[++len].angle = PI, p[len].flag = 0;
    int sum=0;
    p[0].angle=-PI;
    for(int j = 1; j <= len; ++j){
        if(p[j].angle>p[j-1].angle+EPS && sum<=1)return 1;
        sum+=p[j].flag;
    }
    return 0;
}

double d[MAXN];

double get(double x, double y)
{
    for (int i = 0; i < n; ++ i) {
        d[i] = sqrt((x - q[i].x) * (x - q[i].x) + (y - q[i].y) * (y - q[i].y));
    }
    sort(d, d + n);
    return d[1];
}

int MAIN()
{
    cin >> w >> h >> n;
    for (int i = 0; i < n; ++ i) {
        cin >> q[i].x >> q[i].y;
    }
    random_shuffle(q, q + n);
    for (int i = 0; i < n; ++ i) {
        for (int j = 0; j < n; ++ j) {
            f[i][j] = atan2(q[j].y - q[i].y, q[j].x - q[i].x);
        }
    }
    double ans = 0;
    ans = max(ans, get(0, 0));
    ans = max(ans, get(w, 0));
    ans = max(ans, get(0, h));
    ans = max(ans, get(w, h));
    //cout << ans << endl;
    for (int i = 0; i < n; ++ i) {
        if (check(i, ans + 1e-9)) {
            double l = ans, r = sqrt(w * w + h * h);
            for (int j = 0; j < 50; ++ j) {
                double mid = (l + r) / 2.;
                if (check(i, mid)) {
                    l = mid;
                }
                else
                {
                    r = mid;
                }
            }
            ans = (l + r) / 2.;
        }
    }
    cout << ans << endl;
    return 0;
}

int main()
{
    ios :: sync_with_stdio(false);
    cout << fixed << setprecision(18);
    return MAIN();
}