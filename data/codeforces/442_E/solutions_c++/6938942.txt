#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <map>
#include <iostream>
#include <set>
#include <queue>
#include <stack>
#include <ctime>
#define zero(x) (((x)>0?(x):-(x))<eps)
//#include <bits/stdc++.h>
#define mem(a,b) memset((a),(b),sizeof((a)))
#define lld long long
#define INF 0x3f3f3f3f
#define eps 1e-9

using namespace std;

const double pi = acos(-1.0);

struct point{
    double x, y;
    point(double x = 0, double y = 0): x(x), y(y) {};
    point operator +(const point &I) const {
        return point(x + I.x, y + I.y);
    }
    point operator -(const point &I) const {
        return point(x - I.x, y - I.y);
    }
    point operator /(const double &I) const {
        return point(x / I, y / I);
    }
    double len() {
        return sqrt(x * x + y * y);
    }
    bool operator ==(const point &I) const {
        return fabs(x - I.x) < eps && fabs(y - I.y) < eps;
    }
}num[1009];

int n;
int id[1009];
double dis[1009][1009];
double w, h;
double ag[1009][1009];
double ss[8009];
int p[8009];
int top;
int cnt;

double normal(double &a) {
    while(a < -pi) a += 2 * pi;
    while(a > pi) a -= 2 * pi;
}

void add(double l, double r) {
    normal(l);
    normal(r);
    ss[top++] = l;
    ss[top++] = r;
    if(l > r) cnt++;
}

bool cmp(int a, int b) {
    return fabs(ss[a] - ss[b]) > eps ? ss[a] < ss[b] : (a & 1) < (b & 1);
}

bool check(int a, double m) {
    top = 0;
    double agl;
    cnt = 0;
//    ss[top++] = -pi;
//    ss[top++] = pi;
    if(num[a].x - m < 0) {
        agl = acos(num[a].x / m);
        add(pi - agl, pi + agl);
        add(pi - agl, pi + agl);
    }
    if(num[a].x + m > w) {
        agl = acos((w - num[a].x) / m);
        add(-agl, agl);
        add(-agl, agl);
    }
    if(num[a].y - m < 0) {
        agl = acos(num[a].y / m);
        add(-pi / 2 - agl, pi * 3 / 2 + agl);
        add(-pi / 2 - agl, pi * 3 / 2 + agl);
    }
    if(num[a].y + m > h) {
        agl = acos((h - num[a].y) / m);
        add(pi / 2 - agl, pi / 2 + agl);
        add(pi / 2 - agl, pi / 2 + agl);
    }
    for(int i = 0; i < n; i++) {
        if(i == a || num[i] == num[a] || dis[i][a] > 2 * m || dis[i][a] < eps) continue;
        agl = acos(dis[a][i] / 2 / m);
        add(ag[a][i] - agl, ag[a][i] + agl);
    }
//    printf("%d\n", top);
    for(int i = 0; i < top; i++) p[i] = i;
    sort(p, p + top, cmp);
    if(cnt <= 1) return true;
    for(int i = 0; i < top; i++) {
        cnt += ((p[i] & 1)) ? -1 : 1;
        if(cnt <= 1) return true;
    }
    return false;
}

int MAIN() {
    scanf("%lf%lf%d", &w, &h, &n);
    for(int i = 0; i < n; i++) {
        scanf("%lf%lf", &num[i].x, &num[i].y);
    }
    for(int i = 0; i < n; i++) {
        id[i] = i;
    }
    random_shuffle(id, id + n);
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            if(i != j) {
                dis[i][j] = (num[i] - num[j]).len();
                ag[i][j] = atan2(num[j].y - num[i].y, num[j].x - num[i].x);
            }
        }
    }
    double m = 0;
    double up = sqrt(w * w + h * h);
    for(int i = 0; i < n; i++) if(check(id[i], m + m * eps)) {
        double l = m, r = 2e6;
        while(r - l > eps) {
            double mid = (l + r) / 2;
            if(check(id[i], mid)) {
                l = mid;
            } else {
                r = mid;
            }
        }
        m = l;
    }
    printf("%.15lf\n", m);
    return 0;
}


int main() {
#ifdef LOCAL_TEST
    freopen("F:/ACMData.txt","r",stdin);
//    freopen("F:/out1.txt","w",stdout);
#endif
//    int cases;
//    scanf("%d", &cases);
//    int cc = 1;
//    while(~scanf("%d", &n)) {
////        printf("Ca, se #%d: ", cc++);
        MAIN();
//    }
    return 0;
}
