/*
	build the voronoi graph
*/
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
#define MAX_N 1000
#define sqr(x) ((x) * (x))
using namespace std;

const double eps = 1e-9;
const double INF = 1e15;

struct CNode
{
	double x, y;

	CNode(){}
}p[MAX_N + 10], pp[MAX_N + 10];

int n, cnt, w, h, weight[MAX_N + 10];
double x[MAX_N + 10], y[MAX_N + 10], ox[MAX_N + 10], oy[MAX_N + 10],
	xx[MAX_N + 10], yy[MAX_N + 10];

bool cmp(const CNode& a, const CNode& b)
{
	return (a.x < b.x - eps) || (abs(a.x - b.x) < eps && a.y < b.y);
}

double dist(double x1, double y1, double x2, double y2)
{
	return sqr(x1 - x2) + sqr(y1 - y2);
}

/*
	the dominant area of a specified point
*/
void cut(int &cnt, double aa, double bb, double cc)
{
	x[cnt] = x[0]; y[cnt] = y[0];
	int ncnt = 0;
	for (int i = 0; i < cnt; ++i)
	{
		double z = x[i] * aa + y[i] * bb + cc;

		/*
			points which stand by the side of the specified point
		*/
		if (z < eps)
		{
			xx[ncnt] = x[i];
			yy[ncnt] = y[i];
			++ncnt;
		}
		double zn = x[i + 1] * aa + y[i + 1] * bb + cc;

		/*
			cut the border of the old dominant area
		*/
		if (z < -eps && zn > eps || z > eps && zn < -eps)
		{
			double a = y[i + 1] - y[i];
			double b = x[i] - x[i + 1];
			double c = -a * x[i] - b * y[i];
			double d = a * bb - aa * b;
			xx[ncnt] = (b * cc - bb * c) / d;
			yy[ncnt] = -(a * cc - aa * c) / d;
			++ncnt;
		}
	}

	/*
		get the new dominant area
	*/
	cnt = ncnt;
	for (int i = 0; i < cnt; ++i)
	{
		x[i] = xx[i];
		y[i] = yy[i];
	}
}

int main()
{
	//freopen("5.in", "r", stdin);
	//freopen("5.out", "w", stdout);
	scanf("%d%d%d", &w, &h, &n);
	for (int i = 0; i < n; ++i)
	{
		scanf("%lf%lf", &p[i].x, &p[i].y);
	}
	sort(p, p + n, cmp);
	int nn = 1;
	weight[0] = 1;
	for (int i = 1; i < n; ++i)
	{
		if (abs(p[i].x - p[i - 1].x) < eps 
			&& abs(p[i].y - p[i - 1].y) < eps)
		{
			++weight[nn - 1];
			continue;
		}
		weight[nn] = 1;
		p[nn++] = p[i];
	}
	n = nn;
	double ans = 0;
	for (int st = 0; st < n; ++st)
	{
		cnt = 4;
		x[0] = 0; y[0] = 0;
		x[1] = w; y[1] = 0;
		x[2] = w; y[2] = h;
		x[3] = 0; y[3] = h;
		for (int i = 0; i < n; ++i)
		{
			if (i == st) continue;
			double aa = p[i].x - p[st].x;
			double bb = p[i].y - p[st].y;
			double cc = -aa * (p[i].x + p[st].x) / 2
					-bb * (p[i].y + p[st].y) / 2;
			cut(cnt, aa, bb, cc);
		}

		/*
			case 1: the point can not be ignored, so the voronoi
				graph will not change
		*/
		if (weight[st] >= 2)
		{	
			for (int i = 0; i < cnt; ++i)
			{
				double tmp = dist(p[st].x, p[st].y, x[i], y[i]);
				if (tmp > ans)
				{
					ans = tmp;
				}
			}
			continue;
		}

		/*
			case 2: the point can be ignored, so part of the voronoi
				graph should be rebuild
		*/
		x[cnt] = x[0];
		y[cnt] = y[0];
		int m = 0;

		/*
			find neighbors of that point.
		*/
		for (int i = 0; i < cnt; ++i)
		{
			double xm = (x[i] + x[i + 1]) / 2;
			double ym = (y[i] + y[i + 1]) / 2;
			double mn = INF;
			int u = 0;
			for (int j = 0; j < n; ++j)
			{
				if (j == st) continue;
				double tmp = dist(p[j].x, p[j].y, xm, ym);
				if (tmp < mn)
				{
					mn = tmp;
					u = j;
				}
			}
			pp[m++] = p[u];
		}

		int ocnt = cnt;
		for (int i = 0; i < cnt; ++i)
		{
			ox[i] = x[i];
			oy[i] = y[i];
		}

		/*
			as the point can be ignored, its original area
			will be divided up by its neighbors.
		*/
		for (int i = 0; i < m; ++i)
		{
			for (int j = 0; j < m; ++j)
			{
				if (dist(pp[i].x, pp[i].y, pp[j].x, pp[j].y) < eps)
				{
					continue;
				}
				double aa = pp[j].x - pp[i].x;
				double bb = pp[j].y - pp[i].y;
				double cc = -aa * (pp[i].x + pp[j].x) / 2
						- bb * (pp[i].y + pp[j].y) / 2;
				cut(cnt, aa, bb, cc);
			}
			for (int j = 0; j < cnt; ++j)
			{
				double tmp = dist(pp[i].x, pp[i].y, x[j], y[j]);
				if (ans < tmp)
				{
					ans = tmp;
				}
			}
	
			cnt = ocnt;
			for (int j = 0; j < cnt; ++j)
			{
				x[j] = ox[j];
				y[j] = oy[j];
			}
		}
	}
	printf("%.12lf\n", sqrt(ans));
	return 0;
}
/*
	for any voronoi graph, there are at most O(nlogn) 
	crossover points on the border.
	
	for all the points v:
		in case 1: it takes O(n * dv) times, where dv denotes 
				the number of neighbors of point v
		in case 2: it takes O(n * dv + dv ^ 2) times.
	since sigma(dv) = n, we can estimate the complexity of this algorithm:
		in case 1: it takes at most O(n * sigma(dv)) = O(n ^ 2 * logn)
				times
		in case 2: it takes at most O(n * sigma(dv) + sigma(dv) ^ 2) =
				O(n ^ 2 * (logn) ^ 2) times

	This algorithm has a great perfomance since the data was made randomly. 
*/
