#include <bits/stdc++.h>

using namespace std;

#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)

#define type(x) __typeof(x.begin())

#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair < int ,int > pii;

typedef long long ll;

const long long linf = 1e18+5;
int mod = (int) 1e9 + 7;
const int logN = 18;
const int inf = 1e9 + 9;
const int N = 4e5 + 5;

int l, r, s, n, ans[N], a[N], ok[N];
multiset< int > small, big;
ll sum;

void rev() {
    swap(l, r);
    s = n - s + 1;
    FOR(i, 1, n) a[i] = -a[i];
    reverse(a + 1, a + n + 1);
    FOR(i, 1, n) ans[i] = n - ans[i] + 1;
}

void make(int s, int f) {
    int left = max(0, l - (s - 1) - (n - f));
    int use = l - left, u1 = 0, u2 = 0;
    if(s > 1) { u1++; use--; }
    if(f < n) { u2++; use--; }
    if(use && s > 2) {
        int g = min(use, s - 2);
        u1 += g; use -= g;
    }
    if(use && f < n - 1) {
        int g = min(use, n - f - 1);
        u2 += g; use -= g;
    }
    priority_queue< pii, vector< pii >, greater< pii > > q;
    FOR(i, s + 2, f - 1)
        q.push(mp(2 * (a[i] - a[i - 1]), i));
    memset(ok, 0, sizeof ok);
    while(left--) {
        int t = q.top().nd;
        q.pop();
        ok[t] = 3;
    }
    int w = 0;
    ans[++w] = s;

    ROF(i, u1, 1)
        ans[++w] = i;

    FOR(i, u1 + 1, s - 1)
        ans[++w] = i;

    FOR(i, s+1, f-1) {
        int t = i + 1;
        if(ok[t] == 3) {
            while(ok[t] == 3) t++; t--;
            ROF(j, t, i) ans[++w] = j;
            i = t;
        }
        else {
            ans[++w] = i;
        }
    }
    FOR(i, f + u2, n)
        ans[++w] = i;
    ROF(i, f + u2 - 1, f)
        ans[++w] = i;
}

void add(int x) {
    if(!small.size()) big.insert(x);
    else if(x >= *small.rbegin()) big.insert(x);
    else { sum += x; small.insert(x); }
}

ll get() {
    pair< ll, int > ans = mp(linf, 0);
    /// o - o - o - s - o - o - f - o - o ///
    ///   2   2   2   1   1   1   2   2   ///
    multiset< int > S;
    ll cur = 2ll * (a[s] - a[1]);
    int last = 0;
    sum = 0;
    small.clear();
    big.clear();
    FOR(f, s + 1, n) {
        if(f > s + 2) add(2LL * (a[f - 1] - a[f - 2]));
        if((s != 1) + (f != n) > l || (s > 1 && r == 0)) continue;
        int left = max(0, l - (s - 1) - (n - f));
        ll nv = (2ll * a[n] - a[s] - a[f]) + cur;
        if(left > small.size() + big.size()) continue;
        while(small.size() < left) { sum += *big.begin(); small.insert(*big.begin()); big.erase(big.begin()); }
        while(small.size() > left) { sum -= *small.rbegin(); big.insert(*small.rbegin()); small.erase(small.find(*small.rbegin())); }
        ans = min(ans, mp(nv + sum, f));
    }
    if(ans.st < linf) make(s, ans.nd);
    return ans.st;
}

int main() {
    scanf("%d %d %d", &n, &l, &s);
    r = n - l - 1;
    FOR(i, 1, n)
        scanf("%d", &a[i]);
    ll l = get();
    rev();
    ll r = get();
    rev();
    if(l >= linf && r >= linf) puts("-1");
    else {
        if(l < r) {
            get();
            printf("%lld\n", l);
            FOR(i, 2, n)
                printf("%d%c", ans[i], " \n"[i == n]);
        }
        else {
            printf("%lld\n", r);
            FOR(i, 2, n)
                printf("%d%c", ans[i], " \n"[i == n]);
        }
    }
}
