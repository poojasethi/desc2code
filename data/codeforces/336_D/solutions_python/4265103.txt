import operator as op
def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m
        
def ncr(n, r):
    r = min(r, n-r)
    if r == 0: return 1
    numer = reduce(op.mul, xrange(n, n-r, -1))
    denom = reduce(op.mul, xrange(1, r+1))
    return numer//denom

N,M,G = map(int, raw_input().split())
def q(n):
	return ncr(n+M, M)

mod = 1000000007
r = [0] * (N+M+1)
r[1] = 1;
for i in range(2, N+M+1):
	r[i] = (mod - (mod/i) * r[mod%i] % mod) % mod;
binom = 1
#~ print "done"

def f(n):
	global binom 
	n -= 1
	sign = 1 if (n%2 == 0) else -1
	res = 0
	k = 0
	
	while k <= n:		
		res = (res + sign * binom) % mod	
		binom = (binom * (k+M+1) * r[k+1]) % mod
		
		sign *= -1
		k += 1
	if M == 1:
		res += (-1 if (n%2 == 0) else 1)
	return res
	
if M == 0:
	print int(G == (N+1)%2)
	raise SystemExit

		
if G == 1:
	print f(N)
else:
	print (-f(N)+binom+mod) % mod
