#include <set>
#include <map>
#include <cmath>
#include <cstdio>
#include <string>
#include <vector>
#include <cstring>
#include <cstdlib>
#include <utility>
#include <iostream>
#include <algorithm>
#define LL long long
#define pi 3.1415926535897932384626433 
#define sqr(a) ((a)*(a))

using namespace std;

struct node
{
    int over, x, y, z;
    
    void construct(int Over, int X, int Y, int Z)
    {
        over = Over, x = X, y = Y, z = Z;
    }
    
    int operator == (const node &o) const
    {
        return o.x == x && o.y == y && o.z == z && o.over == over;
    }      
};

struct edge
{
    node To;
    int w, a, b, c;
};

const int inf = 1000000000;

edge pre[2][10][10][10];
vector<edge> adj[2][10][10][10];
vector<node> q;
string s[4], ans[4], a;
int cur, d[2][10][10][10], u[2][10][10][10];

void add(int over, int x, int y, int z, int Nover, int Nx, int Ny, int Nz, int w, int a, int b, int c)
{
    node cur; cur.construct(Nover, Nx, Ny, Nz);
    edge v;
    v.To = cur;
    v.w = w, v.a = a, v.b = b, v.c = c;
    adj[over][x][y][z].push_back(v);
}

void make(int over, int x, int y, int z)
{
    if (x + y + z == 0) return ;
    for (int a = 0; a <= 9; a ++)
        for (int b = 0; b <= 9; b ++)
        {
            int c = (a + b + over) % 10, Nx = x, Ny = y, Nz = z;
            int Nover = (a + b + over) / 10, w = 3;
            if (x == 0 && a) continue;
            if (y == 0 && b) continue;
            if (x > 1 && s[1][x - 2] - 48 == a)
                Nx --, w --;
            if (y > 1 && s[2][y - 2] - 48 == b)
                Ny --, w --;
            if (z && s[3][z - 1] - 48 == c)
                Nz --, w --;
            if (x == 0 && a == 0) w --;
            if (y == 0 && b == 0) w --;
            for (int dx = 0; dx < 2; dx ++)
                for (int dy = 0; dy < 2; dy ++)
                    if ((dx == 0 || Nx == 1) && (dy == 0 || Ny == 1))
                        add(over, x, y, z, Nover, Nx - dx, Ny - dy, Nz, w, a, b, c);
            //haha
        }
}            

void spfa(node st)
{
    //init queue
    q.clear();
    q.push_back(st);
    //init dis
    for (int over = 0; over < 2; over ++)
        for (int x = 0; x <= s[1].size() + 1; x ++)
            for (int y = 0; y <= s[2].size() + 1; y ++)
                for (int z = 0; z <= s[3].size(); z ++)
                    d[over][x][y][z] = inf;
    d[st.over][st.x][st.y][st.z] = 0;
    memset(u, 0, sizeof(u));
    for (int f = 0; f < q.size(); f ++)
    {
        node cur = q[f];
        int over = cur.over, x = cur.x, y = cur.y, z = cur.z;
        u[over][x][y][z] = 0;
        for (int i = 0; i < adj[over][x][y][z].size(); i ++)
        {
            node v = adj[over][x][y][z][i].To;
            if (d[over][x][y][z] + adj[over][x][y][z][i].w < d[v.over][v.x][v.y][v.z])
            {
                d[v.over][v.x][v.y][v.z] = d[over][x][y][z] + adj[over][x][y][z][i].w;
                edge &r = pre[v.over][v.x][v.y][v.z];
                r = adj[over][x][y][z][i];
                r.To = cur;
                if (! u[v.over][v.x][v.y][v.z])
                {
                    u[v.over][v.x][v.y][v.z] = 1;
                    q.push_back(v);
                }
            }
        }
    }
}

void print(int x)
{
    for (int i = 0; i < ans[x].size(); i ++)
        if (ans[x][i] != '0')
        {
            for (int j = i; j < ans[x].size(); j ++)
                cout << ans[x][j];
            break;
        }
    //haha
}

int main()
{
#ifndef ONLINE_JUDGE
    freopen("a.in", "r", stdin);
    freopen("a.out", "w", stdout);
#endif
    cin >> a;
    for (int i = 1; i <= 3; i ++)
        s[i] = "";
    cur = 1;
    for (int i = 0; i < a.size(); i ++)
        if (isdigit(a[i]))
            s[cur] += a[i]; else cur ++;
    for (int over = 0; over < 2; over ++)
        for (int x = 0; x <= s[1].size() + 1; x ++)
            for (int y = 0; y <= s[2].size() + 1; y ++)    
                for (int z = 0; z <= s[3].size(); z ++)
                    make(over, x, y, z);
    //spfa
    node st, en; 
    st.construct(0, s[1].size() + 1, s[2].size() + 1, s[3].size());
    spfa(st);
    //
    en.x = en.y = en.z = 0;
    if (d[0][0][0][0] < d[1][0][0][0] + 1)
        en.over = 0; else en.over = 1;
    for (int i = 1; i <= 3; i ++)
        ans[i] = "";
    if (en.over)
        ans[3] = "1";
    while (! (en == st))
    {
        edge cur = pre[en.over][en.x][en.y][en.z];
        ans[1] += char(cur.a + 48);
        ans[2] += char(cur.b + 48);
        ans[3] += char(cur.c + 48);
        en = cur.To;
    }
    print(1); cout << "+";
    print(2); cout << "=";
    print(3); cout << endl;
    return 0;
}
