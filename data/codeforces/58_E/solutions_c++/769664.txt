/*

source : code forces #54(div.2) problem E

author : ASEMBL

date : 2011.10.15 1:00


*/

#include <cstdio>

#define len1 11
#define len2 1000
#define min(a,b) ( (a) < (b) ? (a) : (b) )
#define oo 1000000000
int f[len1][len1][len1][2] ;
int a[len1] , b[len1] , c[len1] ;
struct turn
{
    long long a , b , c ;
    long long e1 , e2 , e3 ;
}g[len1][len1][len1][2] ;

void get( int x[] , int l )
{
    int i = len1 - 1 ;
    
    do
    {
        x[i] = l % 10 ;
        l /= 10 ;
        i-- , x[0] ++;
    }while(l);
    x[i] = x[i-1] = oo ;
}

int main()
{
    int i , j , k , l ;
    int ni , nj , nk , nl , x , y , cost ;
    int ans , F;
    turn *G ;
    
    scanf("%d+%d=%d",&i,&j,&k);
    get(a,i);
    get(b,j);
    get(c,k);
    
    for ( i = 0 ; i <= 1+a[0] ; ++i )
        for ( j = 0 ; j <= 1+b[0] ; ++j )
            for ( k = 0 ; k <= 1+c[0] ; ++k )
                f[i][j][k][0] = f[i][j][k][1] = oo ;
    f[0][0][0][0] = 0 ;
    g[0][0][0][0] = (struct turn){ 0 , 0 , 0 , 1 , 1 , 1 };
    for ( i = 0 ; i <= 1+a[0] ; ++i )
        for ( j = 0 ; j <= 1+b[0] ; ++j )
            for ( k = 0 ; k <= c[0] ; ++k )
                for ( l = 0 ; l <= 1 ; ++l )
                if ( f[i][j][k][l] != oo )
                {
                    if ( i == a[0] && f[i+1][j][k][l] > f[i][j][k][l] )
                    {
                        f[i+1][j][k][l] = f[i][j][k][l] ;
                        g[i+1][j][k][l] = g[i][j][k][l] ;
                    }
                    if ( j == b[0] && f[i][j+1][k][l] > f[i][j][k][l] )
                    {
                        f[i][j+1][k][l] = f[i][j][k][l] ;
                        g[i][j+1][k][l] = g[i][j][k][l] ;
                    }
                    
                    for ( x = 0 ; x <= ( i <= a[0] ? 9 : 0 ) ; ++x )
                    {
                        for ( y = 0 ; y <= ( j <= b[0] ? 9 : 0  ) ; ++y )
                        {
                            ni = i , nj = j , nk = k ;
                            if ( x == a[len1-i-1] && i <= a[0] ) ni ++ ;
                            if ( y == b[len1-j-1] && j <= b[0] ) nj ++ ;
                            if ( (x+y+l) % 10 == c[len1-k-1] ) nk ++ ;
                            nl = ( (x+y+l) >= 10 ) ;
                            
                            cost = 1 + ( i <= a[0] ) + ( j <= b[0] ) ;
                            
                            if ( f[ni][nj][nk][nl] > f[i][j][k][l] + cost )
                            {
                                f[ni][nj][nk][nl] = f[i][j][k][l] + cost ;
                                G = &g[ni][nj][nk][nl] ;
                                g[ni][nj][nk][nl] = g[i][j][k][l] ;
                                
                                G->a += G->e1 * x ;
                                G->b += G->e2 * y ;
                                G->c += G->e3 * (x+y+l % 10) ;
                                
                                G->e1 *= 10 ;
                                G->e2 *= 10 ;
                                G->e3 *= 10 ;
                            }
                        }
                    }
                }
    G = &g[a[0]+1][b[0]+1][c[0]][0];
    F = f[a[0]+1][b[0]+1][c[0]][0];
    printf("%I64d+%I64d=%I64d\n",G->a,G->b,G->a+G->b);
    return 0;
}
/*
Sample test(s)
Input

323+123=287

Answer

323+12553=12876

*/
