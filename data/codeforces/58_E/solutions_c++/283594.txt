#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int codifica(int ia,int ib,int ic,int carry)
{
  return ia*1000+ib*100+ic*10+carry;
}

int descia(int codi)
{
  return codi/1000;
}
int descib(int codi)
{
  return (codi/100)%10;
}

int descic(int codi)
{
  return (codi/10)%10;
}

int desccarry(int codi)
{
  return codi%10;
}

struct elem {
  int codi;
  int cost;
};

bool operator<(elem e1,elem e2)
{
  return e1.cost>e2.cost;
}

vector<int> passaadigits(int x)
{
  vector<int> v;
  while (x>0) {
    v.push_back(x%10);
    x/=10;
  }
  return v;
}


struct triple {
  int digit;
  int nexti;
  int cost;
};

vector<triple> computatriple(vector<int> &v,int i)
{
  vector<triple> r;
  triple t;
  if (i<int(v.size())) {
    t.digit=v[i];
    t.nexti=i+1;
    t.cost=0;
    if (t.nexti<int(v.size())) {
      r.push_back(t);
    } else {
      t.nexti=8;
      r.push_back(t);
      t.nexti=9;
      r.push_back(t);
    }
    for (int val=0;val<10;val++) {
      t.digit=val;
      t.nexti=i;
      t.cost=1;
      r.push_back(t);
    }
  } else if (i==8) {
    t.digit=0;
    t.nexti=9;
    t.cost=0;
    r.push_back(t);
    for (int val=0;val<10;val++) {
      t.digit=val;
      t.nexti=i;
      t.cost=1;
      r.push_back(t);
    }    
  } else {
    t.digit=0;
    t.nexti=9;
    t.cost=0;
    r.push_back(t);
  }
  return r;
}

bool codifinal(int codi)
{
  int ia,ib,ic,carry;
  ia=descia(codi);ib=descib(codi);ic=descic(codi);carry=desccarry(codi);
  return ia==9 and ib==9 and ic==9 and carry==0;
}

int codifcodifinal()
{
  return codifica(9,9,9,0);
}

typedef long long int lint;

int main()
{
  int a,b,c;
  char aux1,aux2;
  cin>>a>>aux1>>b>>aux2>>c;
  vector<int> va=passaadigits(a);
  vector<int> vb=passaadigits(b);
  vector<int> vc=passaadigits(c);

  elem e;
  int carry=0;
  int ia=0;int ib=0;int ic=0;
  e.codi=codifica(ia,ib,ic,carry);
  e.cost=0;
  priority_queue<elem> q;
  q.push(e);
  vector<int> costcalculat(10000,-1);
  vector<int> anterior(10000);
  vector<int> digita(10000,-1);
  vector<int> digitb(10000,-1);
  vector<int> digitc(10000,-1);
  costcalculat[e.codi]=0;
  while (not q.empty()) {
    e=q.top();
    q.pop();
    int codi=e.codi;
    int cost=e.cost;
    //cout<<"Entrem "<<codi<<endl;
    if (codifinal(codi)) break;
    if (cost==costcalculat[codi]) {
      ia=descia(codi);ib=descib(codi);ic=descic(codi);carry=desccarry(codi);
      //cout<<"Tractant "<<ia<<","<<ib<<","<<ic<<","<<carry<<endl;
      //cout<<"Tractant "<<codi<<endl;
      vector<triple> ta=computatriple(va,ia);
      vector<triple> tb=computatriple(vb,ib);
      vector<triple> tc=computatriple(vc,ic);
      for (int ita=0;ita<int(ta.size());ita++) {
	for (int itb=0;itb<int(tb.size());itb++) {
	  for (int itc=0;itc<int(tc.size());itc++) {
	    int da=ta[ita].digit;
	    int db=tb[itb].digit;
	    int dc=tc[itc].digit;
	    int nextia=ta[ita].nexti;
	    int nextib=tb[itb].nexti;
	    int nextic=tc[itc].nexti;
	    int costa=ta[ita].cost;
	    int costb=tb[itb].cost;
	    int costc=tc[itc].cost;
	    if ((da+db+carry)%10==dc) {
	      int nextcarry=(da+db+carry)/10;
	      int nextcodi=codifica(nextia,nextib,nextic,nextcarry);
	      int nextcost=cost+costa+costb+costc;
	      if (costcalculat[nextcodi]==-1 or
		  costcalculat[nextcodi]>nextcost) {
		//cout<<"Cost["<<nextcodi<<"]="<<nextcost<<endl;
		costcalculat[nextcodi]=nextcost;
		anterior[nextcodi]=codi;
		digita[nextcodi]=da;
		digitb[nextcodi]=db;
		digitc[nextcodi]=dc;
		elem nexte;
		nexte.codi=nextcodi;
		nexte.cost=nextcost;
		q.push(nexte);
	      }
	    }
	  }
	}
      }
    }
  }
  int index=codifcodifinal();
  //cout<<index<<endl;
  lint aa=0;
  lint bb=0;
  lint cc=0;
  while (index!=0) {
    aa=aa*10+digita[index];
    bb=bb*10+digitb[index];
    cc=cc*10+digitc[index];
    index=anterior[index];
  }
  cout<<aa<<"+"<<bb<<"="<<cc<<endl;
}



