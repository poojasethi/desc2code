#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cassert>
#include <map>
#include <set>
#include <vector>
#include <string>
#include <iostream>
#include <cmath>
#include <ctime>
#include <algorithm>
#include <queue>
#include <stack>
#include <deque>

using namespace std;

#define dbg(x) cerr << #x << " = " << x << endl
#define deb(x) cerr << #x << " = " << x << endl
#define all(c) (c).begin(),(c).end()
#define pb push_back
#define sz(c) (int)(c).size()          
#define mp make_pair
#define forn(i,n) for(int i=0;i<(int)n;i++)
#define X first
#define Y second

typedef long long int64;
typedef long double ld;

int a,b,c,la,lb,lc;
char A[12],B[12],C[12];
char d;

map<int,int>was;
map<int,int>to;
map<int,pair<pair<int,int>,int> >tr;
             

inline int pcalc(int da, int la, char *A, int i, int &add)
{
  if (da==la)
    {
      if (i==0)
        add--;
      return da;
    }
  if (A[da]==i)
  {
    add--;
    return da+1;
  }
  return da;
}

inline int zcalc(int da, int la, int za, int i, int &add)
{
  if (da==la)
  {
    if (i>0)
    {
      add+=za;
      return 0;
    }
    return za+1;
  }
  return 0;
}

inline int hash(int &da, int &db, int &dc, int &p, int &za, int &zb, int &zc,int last)
{return (zc+(zb+(za+(p+(dc+(db+da*20)*20)*2)*20)*20)*20)*2+last;}

inline void dehash(int h, int &da, int &db, int &dc, int &p, int &za, int &zb, int &zc, int &ok)
{
  ok=h%2;
  h/=2;
  zc=h%20;
  h/=20;
  zb=h%20;
  h/=20;
  za=h%20;
  h/=20;
  p=h%2;
  h/=2;
  dc=h%20;
  h/=20;
  db=h%20;
  h/=20;
  da=h%20;
  h/=20;
}

int get_ans(int da, int db, int dc, int p, int za, int zb, int zc, bool last)
{      
  if (da==la && db==lb && dc==lc && p==0)
    return 0;


  int key=hash(da,db,dc,p,za,zb,zc,last);
//  deb(key);
  assert(key>=0);
  if (was.count(key))
    return was[key];

  int best=1<<30;
  forn(i,10)
    forn(j,10)
      {
        int k=((i+j+p)%10);
        int add=3;

        int nda = pcalc(da,la,A,i,add);
        int ndb = pcalc(db,lb,B,j,add);
        int ndc = pcalc(dc,lc,C,k,add);

        int np = (i+j+p)>=10?1:0;

        int nza = zcalc(da,la,za,i,add);
        int nzb = zcalc(db,lb,zb,j,add);
        int nzc = zcalc(dc,lc,zc,k,add);

        
        bool ok = true;
        if (nda==da && ndb==db && ndc==dc)
          ok=false;

//        ok |= nza>za && nzb>zb;


        if (!last && !ok) 
          continue;

        int g = get_ans(nda,ndb,ndc,np,
                        nza,nzb,nzc,ok);

        if (best>g+add)
          {
            best=g+add;
            to[key]=hash(nda,ndb,ndc,np,
                         nza,nzb,nzc,ok);
            tr[key]=mp(mp(i,j),k);
          }
      }

  return was[key]=best;
}


void to_char(int a, int &la, char*A)
{
  while (a>0)
  {
    A[la++]=a%10;
    a/=10;
  }
}
int main()
{
  cin>>a>>d>>b>>d>>c;
//  cerr<<a<<" "<<b<<" "<<c<<endl;

  to_char(a,la,A);
  to_char(b,lb,B);
  to_char(c,lc,C);
//  cerr<<la<<" "<<lb<<" "<<lc<<endl;

  get_ans(0,0,0,0,0,0,0,true);
  deb(get_ans(0,0,0,0,0,0,0,true));
  int da=0,db=0,dc=0,p=0,za=0,zb=0,zc=0,ok=true;
  int64 aa=0,bb=0,cc=0,t=1;
  while (!(da==la && db==lb && dc==lc && p==0))
  {
     int h=hash(da,db,dc,p,za,zb,zc,ok);
     aa=aa+t*tr[h].X.X;
     bb=bb+t*tr[h].X.Y;
     cc=cc+t*tr[h].Y;
     t*=10;
     int g = to[h];
     dehash(g,da,db,dc,p,za,zb,zc,ok);
  }
  printf("%I64d+%I64d=%I64d\n",aa,bb,cc);
  return 0;
}
