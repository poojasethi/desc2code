#include <algorithm>
#include <iostream>
#include <valarray>
#include <iomanip>
#include <fstream>
#include <sstream>
#include <cstdlib>
#include <cstring>
#include <cassert>
#include <numeric>
#include <complex>
#include <cstdio>
#include <string>
#include <vector>
#include <bitset>
#include <ctime>
#include <cmath>
#include <queue>
#include <stack>
#include <deque>
#include <map>
#include <set>

using namespace std;

#define FOREACH(i, c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)
#define FOR(i, a, n) for (int i = (a); i < int(n); ++i)
#define error(x) cout << #x << " = " << (x) << endl;
#define all(n) (n).begin(), (n).end()
#define Size(n) ((int)(n).size())
#define mk make_pair
#define pb push_back
#define F first
#define S second
#define X real()
#define Y imag()

typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
typedef complex<double> point;

template <class P, class Q> void smin(P &a, Q b) { if (b < a) a = b; }
template <class P, class Q> void smax(P &a, Q b) { if (b > a) a = b; }
template <class T> bool by_second(T a, T b) { return a.S < b.S; }

const int LEN = 9, CAR = 3;

struct answer {
	basic_string<int> a, b, c;
	void print(basic_string<int> a) {
		reverse(all(a));
		FOREACH(it, a) cout << *it;
	}
	void print() {
		print(a); cout << "+";
		print(b); cout << "=";
		print(c); cout << endl;
	}
} ans[LEN][LEN][LEN][CAR][3];

void add(answer &p, const answer &q, int a, int b, int c) {
	p.a = q.a; if (a != -1) p.a += a;
	p.b = q.b; if (b != -1) p.b += b;
	p.c = q.c; if (c != -1) p.c += c;
}

int d1[LEN], d2[LEN], d3[LEN], l1, l2, l3;
int dp[LEN][LEN][LEN][CAR][3];
bool mark[LEN][LEN][LEN][CAR][3];

int main() {
	ios::sync_with_stdio(false);
	memset(d1, -1, sizeof d1);
	memset(d2, -1, sizeof d2);
	memset(d3, -1, sizeof d3);
	int a, b, c; char del;
	cin >> a >> del >> b >> del >> c;
	while (a) d1[l1++] = a%10, a /= 10;
	while (b) d2[l2++] = b%10, b /= 10;
	while (c) d3[l3++] = c%10, c /= 10;
	memset(dp, 63, sizeof dp);
	dp[0][0][0][0][0] = 0;
	while (1) {
		int best = -1;
		int x = -1, y = -1, z = -1, car = -1, sleep = -1;
		FOR(i, 0, l1+1) FOR(j, 0, l2+1) FOR(k, 0, l3+1) FOR(l, 0, CAR) FOR(m, 0, 3) if (!mark[i][j][k][l][m] && (best == -1 || best > dp[i][j][k][l][m])) {
			best = dp[i][j][k][l][m];
			x = i, y = j, z = k, car = l, sleep = m;
		}
		if (best == -1) break;
		mark[x][y][z][car][sleep] = true;
		if (sleep == 0) {
			if (d1[x] == -1 && dp[x][y][z][car][1] > dp[x][y][z][car][0]) dp[x][y][z][car][1] = dp[x][y][z][car][0], ans[x][y][z][car][1] = ans[x][y][z][car][0];
			if (d2[y] == -1 && dp[x][y][z][car][2] > dp[x][y][z][car][0]) dp[x][y][z][car][2] = dp[x][y][z][car][0], ans[x][y][z][car][2] = ans[x][y][z][car][0];
		}
		if (d1[x] == -1 && d2[y] == -1 && car == d3[z] && d3[z+1] == -1 && dp[x][y][z][car][sleep] < dp[l1][l2][l3][0][sleep]) {
			dp[l1][l2][l3][0][sleep] = dp[x][y][z][car][sleep];
			add(ans[l1][l2][l3][0][sleep], ans[x][y][z][car][sleep], -1, -1, car);
		}
		if (d1[x] == -1 && d2[y] == -1 && d3[z] == -1 && car > 0 && dp[x][y][z][car][sleep] < dp[l1][l2][l3][0][sleep]) {
			dp[l1][l2][l3][0][sleep] = dp[x][y][z][car][sleep];
			add(ans[l1][l2][l3][0][sleep], ans[x][y][z][car][sleep], -1, -1, car);
		}
		FOR(a, 0, 10) FOR(b, 0, 10) {
			if (sleep == 1 && a) continue;
			if (sleep == 2 && b) continue;
			int c = (a+b+car)%10;
			int nx = d1[x]==a?x+1:x;
			int ny = d2[y]==b?y+1:y;
			int nz = d3[z]==c?z+1:z;
			int ncar = (a+b+car)/10;
			int cost = int(nx==x)+int(ny==y)+int(nz==z)-int(sleep>0);
			if (dp[x][y][z][car][sleep]+cost < dp[nx][ny][nz][ncar][sleep]) {
				dp[nx][ny][nz][ncar][sleep] = dp[x][y][z][car][sleep]+cost;
				add(ans[nx][ny][nz][ncar][sleep], ans[x][y][z][car][sleep], sleep!=1?a:-1, sleep!=2?b:-1, c);
			}
		}
	}
	int mn = 0;
	FOR(i, 1, 3) if (dp[l1][l2][l3][0][i] < dp[l1][l2][l3][0][mn]) mn = i;
	ans[l1][l2][l3][0][mn].print();
	return 0;
}

