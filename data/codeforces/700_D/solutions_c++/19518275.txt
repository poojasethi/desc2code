#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cmath>
using namespace std;
const int N = 100000, M = 100000, K = 700;
struct sp {
  int q;
  sp *w;
  int id;
  sp(int q, sp *w, int id) :
    q(q), w(w), id(id) {
  }
};
int a[N];
int s1[M], s2[M], sId[M];
sp *a1[N];
int sum[100001], res[M];
void qs(int q, int w) {
  int e = q, r = w, t = s1[q + ((w - q) >> 2)];
  do {
    while (s1[e] < t) e++;
    while (s1[r] > t) r--;
    if (e <= r) {
      swap(s1[e], s1[r]);
      swap(s2[e], s2[r]);
      swap(sId[e], sId[r]);
      e++; r--;
    }
  } while (e <= r);
  if (q < r) qs(q, r);
  if (e < w) qs(e, w);
}

int lRes;

int myLog[100001];

int d[20][2000], d1[20];

void add2(int w) {
  int c = myLog[w];
  d[c][d1[c]] = w;
  d1[c]++;
}

int f[100001], id[100001];
int h1[100001], t;

int h[K];

int fast_add_grup(int e, int r) {
  while (r > 1) {
    add2(e);
    r--;
    if (r > 1) {
      if ((r & 1) == 1) {
        add2(e);
      }
      r >>= 1;
      e <<= 1;
      lRes += e * r;
    } else {
      break;
    }
  }
  if (r) {
    add2(e);
  }
}

void get_all() {
  int w;
  for (w = 1; w < t; w++) {
    int e = h1[w], r = f[h1[w]];
    if (e < K) {
      h[e] += r;
    } else {
      fast_add_grup(e, r);
    }
  }
}
void qs2(int q, int w, int *a) {
  int e = q, r = w, t = a[q + ((w - q) >> 1)];
  do {
    while (a[e] < t) e++;
    while (a[r] > t) r--;
    if (e <= r) {
      swap(a[e], a[r]);
      e++; r--;
    }
  } while (e <= r);
  if (q < r) qs2(q, r, a);
  if (e < w) qs2(e, w, a);
}
int calc() {
  int e, r, c;
  lRes = 0;
  for (e = 0; e < 19; e++) {
    d1[e] = 0;
  }
  for (e = 1; e < K; e++) {
    h[e] = 0;
  }
  
  get_all();
  
  e = 1;
  while (1) {
    while ((e < K) && (h[e] == 0)) {
      e++;
    }
    if (e == K) {
      break;
    }
    if (h[e] > 1) {
      lRes += (h[e] - (h[e] & 1)) * e;
      if (e + e < K) {
        h[e + e] += h[e] >> 1;
      } else {
        fast_add_grup(e + e, h[e] >> 1);
      }
      h[e] &= 1;
    }
    if (h[e]) {
      r = e;
      h[e] = 0;
      while ((e < K) && (h[e] == 0)) {
        e++;
      }
      if (e == K) {
        add2(r);
        break;
      } else {
        h[e]--;
        r += e;
        lRes += r;
        if (r < K) {
          h[r]++;
        } else {
          add2(r);
        }
      }
    }
    
  }
  
  
  for (e = 0; e < 19; e++) {
    if (d1[e] > 1) {
      qs2(0, d1[e] - 1, d[e]);
      lRes += d[e][1] + d[e][0];
      add2(d[e][1] + d[e][0]);
      c = d1[e] - 1;
      while ((c > 1) && (d[e][c - 1] > d[e][c])) {
        swap(d[e][c - 1], d[e][c]);
        c--;
      }
    }
    if (d1[e] < 2) {
      r = 1;
    } else {
      r = 3;
    }
    for (; r < d1[e]; r += 2) {
      lRes += d[e][r] + d[e][r - 1];
      add2(d[e][r] + d[e][r - 1]);
    }
    if (r - 1 < d1[e]) {
      for (c = e + 1; c < 19; c++) {
        if (d1[c] != 0) {
          break;
        }
      }
      if (c == 19) {
        break;
      }
      d[c][d1[c]] = d[e][r - 1];
      d1[c]++;
    }
  }
  return lRes;
}

void del(int w) {
  f[w]--;
  if (f[w] == 0) {
    swap(h1[id[w]], h1[t - 1]);
    id[h1[id[w]]] = id[w];
    t--;
  }
}
void add(int w) {
  f[w]++;
  if (f[w] == 1) {
    h1[t] = w;
    id[w] = t;
    t++;
  }
}
void upd(int w, int t) {
  del(sum[w]);
  sum[w] += t;
  add(sum[w]);
}

int main() {
  #ifdef Vlad_kv
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
  #endif // Vlad_kv
  int q, w, e, r, numQ, sq, c;
  t = 1;
  id[0] = 0;
  h1[0] = 0;
  f[0] = 1<<30;
  
  r = 0;
  for (w = 1; w < 100001; w++) {
    if (1<<r <= w) {
      r++;
    }
    myLog[w] = r;
  }
  
  scanf("%d", &q);
  for (w = 0; w < q; w++) {
    scanf("%d", &a[w]);
  }
  
  scanf("%d", &numQ);
  for (w = 0; w < numQ; w++) {
    scanf("%d%d", &s1[w], &s2[w]);
    s1[w]--;
    s2[w]--;
    sId[w] = w;
  }
  qs(0, numQ - 1);
  sq = (int)sqrt(q);
  
  c = 0;
  
  for (w = 0; w < q; w += sq) {
    for (e = w; e < q; e++) {
      a1[e] = 0;
    }
    for (e = 1; e < 100001; e++) {
      f[e] = 0;
      sum[e] = 0;
    }
    t = 1;
    
    while ((c < numQ) && (s1[c] < w + sq)) {
      a1[s2[c]] = new sp(s1[c], a1[s2[c]], sId[c]);
      c++;
    }
    r = w;
    
    for (e = w; e < q; e++) {
      upd(a[e], 1);
      for (sp *v = a1[e]; v; v = v->w) {
        while (v->q < r) {
          r--;
          upd(a[r], 1);
        }
        while (v->q > r) {
          upd(a[r], -1);
          r++;
        }
        res[v->id] = calc();
      }
    }
    
  }
  
  for (w = 0; w < numQ; w++) {
    printf("%d\n", res[w]);
  }
  return 0;
}