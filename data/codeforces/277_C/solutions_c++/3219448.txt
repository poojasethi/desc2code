#include <cstdio>
#include <cstring>
#include <algorithm>
#define FOR(i,s,e) for (int i=(s); i<(e); i++)
#define FOE(i,s,e) for (int i=(s); i<=(e); i++)
#define FOD(i,s,e) for (int i=(s)-1; i>=(e); i--)
#define CLR(a,x) memset(a, x, sizeof(a))
#define EXP(i,l) for (int i=(l); i; i=qn[i])
#define LLD long long
#define N 200005
using namespace std;

struct seg{
	int w, x, y;
	bool operator < (seg const &T) const{return w == T.w ? x < T.x : w < T.w;}
};

struct dat{
	int x, y;
	bool operator < (dat const &T) const{return x < T.x;}
};

int n, m, d, move, h, v, x1, y1, x2, y2, sg;
seg H[N], V[N];
dat D[N];
int b[N], mx, pos, dir, tar, ret;

int SG(seg a[], int n, int L, int W, int d){
	int t, ret = 0, lo, hi;
	sort(a, a + n);

	for (int i=0, j=0; i<n; i=j){
		while (j < n && a[i].w == a[j].w) ++j;
		t = W;
		lo = 0;
		hi = -1;
		FOR(k,i,j){
			if (a[k].x <= hi) hi = max(hi, a[k].y);
			else{
				t -= (hi - lo + 1);
				lo = a[k].x, hi = a[k].y;
			}
		}
		t -= (hi - lo + 1);

		if ((sg ^ t) <= t){
			tar = sg ^ t;
			pos = a[i].w;
			dir = d;
		}

		ret ^= t;
	}

	FOR(i,0,n) b[i] = a[i].w;
	sort(b, b + n);
	n = unique(b, b + n) - b;
	t = L - 1 - n;

	if (t & 1) ret ^= W;

	if (t && (sg ^ W) <= W){
		tar = sg ^ W;
	    FOR(i,1,n) if (b[i] != b[i-1] + 1) pos = b[i-1] + 1;
	    if (b[0] > 1) pos = 1;
	    if (b[n-1] < L-1) pos = L-1;
	    dir = d;
	}

	return ret;
}

int Length(dat D[], int d, int L, int H){
	int ret = H - L + 1, x, y;
	int lo = 0, hi = -1;
	if (L > H) return 0;
	FOR(i,0,d){
		if (D[i].y < L) continue;
		x = max(D[i].x, L);
		y = D[i].y;
		if (x <= hi) hi = max(hi, y);
		else{
			ret -= (hi - lo + 1);
			lo = x, hi = y;
		}
	}
	ret -= (hi - lo + 1);
	return ret;
}

int main(){
	scanf("%d%d%d", &n, &m, &move);
	while (move--){
		scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
		if (x1 == x2){
			if (y1 > y2) swap(y1, y2);
			H[h++] = (seg){x1, y1+1, y2};
		}
		else{
			if (x1 > x2) swap(x1, x2);
			V[v++] = (seg){y1, x1+1, x2};
		}
	}

	sg = SG(H, h, n, m, 0) ^ SG(V, v, m, n, 1);
	if (!sg) puts("SECOND");
	else{
		puts("FIRST");
		SG(H, h, n, m, 0);
		SG(V, v, m, n, 1);

		if (dir == 0){
			FOR(i,0,h) if (H[i].w == pos) D[d++] = (dat){H[i].x, H[i].y};
			sort(D, D + d);

			for (int i=1, j=m+1, k, l; j>=i;){
				k = (i + j) >> 1;
				l = Length(D, d, k, m);
				if (l == tar){
					ret = k;
					break;
				}
				if (l > tar) i = k + 1;
				if (l < tar) j = k - 1;
			}
			printf("%d %d %d %d\n", pos, 0, pos, ret - 1);
		}

		if (dir == 1){
			FOR(i,0,v) if (V[i].w == pos) D[d++] = (dat){V[i].x, V[i].y};
			sort(D, D + d);

			for (int i=1, j=n+1, k, l; j>=i;){
				k = (i + j) >> 1;
				l = Length(D, d, k, n);
				if (l == tar){
					ret = k;
					break;
				}
				if (l > tar) i = k + 1;
				if (l < tar) j = k - 1;
			}
			printf("%d %d %d %d\n", 0, pos, ret - 1, pos);
		}
	}
	return 0;
}
