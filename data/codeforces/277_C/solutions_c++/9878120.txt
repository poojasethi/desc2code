#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<map>
#define N 12000005
#define inf 1000000005
#define For(i,l,r) for(int i=l;i<=r;i++)
#define Dor(i,r,l) for(int i=r;i>=l;i--)
using namespace std;
int ll,rr,data[N],lc[N],rc[N],ret,tot;
void Modify(int &t,int l,int r){
    if(!t) t=++tot,data[t]=r-l+1;
    if(data[t]==0) return;
    if(ll<=l&&r<=rr){data[t]=0; return;}
    int mid=(l+r)>>1;
    if(ll<=mid) Modify(lc[t],l,mid);
    if(rr>mid) Modify(rc[t],mid+1,r);
    
    int numl=data[lc[t]]; if(lc[t]==0) numl=mid-l+1;
    int numr=data[rc[t]]; if(rc[t]==0) numr=r-mid;
    data[t]=numl+numr;
}
void Query(int t,int l,int r,int K){
    if(K<0) return;
    if(!data[t]&&t) return;
    if(l==r){
        if( K == data[t]+(t==0) ){
            if(ret<=inf) printf("%d %d %d %d\n",ret,0,ret,l);
            else printf("%d %d %d %d\n",0,ret-inf,l,ret-inf);
            exit(0);
        }
        return;
    }
    int mid=(l+r)>>1;
    int numl=data[lc[t]]; if(lc[t]==0) numl=mid-l+1;
    int numr=data[rc[t]]; if(rc[t]==0) numr=r-mid;
    if(K>numl+numr) return;
    if(K<=numl) Query(lc[t],l,mid,K);
    else Query(rc[t],mid+1,r,K-numl);
}

map <int,int> Root;
int n,m,K,E[N],Ans; bool calc[N];
int main(){
    scanf("%d%d%d",&n,&m,&K);
    For(i,1,K){
        int x1,y1,x2,y2;
        scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
        
        if(x1>x2) swap(x1,x2);
        if(y1>y2) swap(y1,y2);
        
        if(x1==x2){
            E[i]=x1; y1++;
            ll=y1,rr=y2,Modify(Root[x1],1,m);
            continue;
        }
        if(y1==y2){
            E[i]=y1=y1+inf; x1++;
            ll=x1,rr=x2,Modify(Root[y1],1,n);
        }
    }
    int sn=n-1;
    int sm=m-1;
    For(i,1,K){
        int t=Root[E[i]];
        if(calc[t]) continue; calc[t]=1;
        if(E[i]<=inf) Ans^=data[t],sn--;
        else Ans^=data[t],sm--;
    }
    if(sn&1) Ans^=m;
    if(sm&1) Ans^=n;
    
    if(Ans==0){printf("SECOND\n"); return 0;}
    
    printf("FIRST\n");
    For(i,1,K){
        int t=Root[E[i]]; ret=E[i];
        int need=data[t]-(Ans^data[t]);
        if(E[i]<=inf) Query(t,1,m,need);
        else Query(t,1,n,need);
    }
    for(ret=1;ret<=K+1;ret++){
        if(ret<n){
            int need=m-(Ans^m);
            if(!Root[ret]) Query(0,1,m,need);
        }
        if(ret<m){
            ret+=inf;
            int need=n-(Ans^n);
            if(!Root[ret]) Query(0,1,n,need);
            ret-=inf;
        }
    }
}