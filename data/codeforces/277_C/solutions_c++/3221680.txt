#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <map>
using namespace std;
#define FOR(i,a,b) for(int i=(a); i<(b); ++i)
#define REP(i,n) FOR(i,1,(n)+1)
typedef vector<int> vi;
#define pb push_back
typedef pair<int,int> pii;
#define mp make_pair
#define st first
#define nd second
typedef long long ll;
#define INF 1000000001
#define sz size()
#define VAR(n,v) typeof(v) n=(v)
#define ALL(t) t.begin(),t.end()
#define SC(a) scanf("%d", &a)
#define GET(a) int a; SC(a)
#define ISDEBUG 1
#define dprintf(...) if(ISDEBUG) {printf("\033[31m"); printf(__VA_ARGS__); printf("\033[0m");}
template <class It> void dptab(It b, It e, const char* f="%d ") {if(ISDEBUG) {for(It it=b; it!=e; ++it) dprintf(f, *it); dprintf("\n"); }}


typedef pair<int, pair<int,int> > cut;
vector<cut>hor,ver;
map<pair<int,bool>,int> heaps;
int res;
int maximum;

void add(int x) {
	if(x<=0) return;
//	printf("xoring %d\n",x);
	res^=x;
}

void print_chosen(cut c, bool vertical) {
	printf("%d %d %d %d\n",
		vertical ? c.st : c.nd.st,
		vertical ? c.nd.st : c.st,
		vertical ? c.st : c.nd.nd,
		vertical ? c.nd.nd : c.st);
}

void get_xor(vector<cut> &cuts, int width, int height, bool vertical) {
	sort(ALL(cuts));
	cuts.pb(mp(height,mp(-1,-1)));
	reverse(ALL(cuts));
	int j = cuts.size()-1;
	for(int i = 1; i<height; ++i) {
		int last = 0, sum=0;
		while(cuts[j].st == i) {
			sum+=(max(0,cuts[j].nd.st-last));
			last = max(last,cuts[j].nd.nd);
			--j;
		}
		sum+=width-last;
		heaps[mp(i,vertical)] = sum;
		add(sum);
		i+=(max(0,cuts[j].st-i-2)/2)*2;
	}
}

bool try_to_choose(int row, int end, int length, bool vertical) {
	int heap = heaps[mp(row,vertical)];
	int k = heap - (res ^ heap);
//	printf("%d %d %d %d %d %d %d %d\n",row,end,length,vertical,k,heap,res,res ^ heap);

	if(k >= 0 && length >= k) {
		print_chosen(mp(row, mp(0, end-length+k)), vertical);
		return true;
	} else return false;
}

bool choose(const vector<cut> &cuts, int width, int height, bool vertical) {
	int j = cuts.size()-1;
	for(int i = 1; i<height; ++i) {
		int last = 0, sum=0;
		while(cuts[j].st == i) {
			int length = cuts[j].nd.st-last;
			sum+=max(0,length);
			if(try_to_choose(i,last+length,sum,vertical)) return true;
			last = max(last,cuts[j].nd.nd);
			--j;
		}
		sum+=width-last;
		if(try_to_choose(i,width,sum,vertical)) return true;
		i+=(max(0,cuts[j].st-i-2)/2)*2;
	}
	return false;
}

int main() {
	GET(n);
	GET(m);
	GET(k);
	FOR(i,0,k) {
		GET(x1);
		GET(y1);
		GET(x2);
		GET(y2);
		if(x2<x1) swap(x1,x2);
		if(y2<y1) swap(y1,y2);
		if(x1==x2)
			ver.pb(mp(x1,mp(y1,y2)));
		if(y1==y2)
			hor.pb(mp(y1,mp(x1,x2)));
	}

	get_xor(ver, m, n, true);
	get_xor(hor, n, m, false);


	printf("%s\n",res ? "FIRST" : "SECOND");
	if(res) {
		choose(ver, m, n, true) ||
		choose(hor, n, m, false);
	}
	return 0;
}

