#include<ctime>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

char QAQ; bool fff;
template<class T>inline void Read(T &k){while(((QAQ=getchar())<'0'||QAQ>'9')&&QAQ!='-');fff=QAQ=='-';k=fff?0:QAQ-'0';while((QAQ=getchar())>='0'&&QAQ<='9')k=k*10+QAQ-'0';if(fff)k=-k;}

char SS[50]; int SS_ing = 0;
template<class T>inline void Write(T k){if(k==0)putchar('0');if(k<0)putchar('-'),k=-k;while(k)SS[++SS_ing]=k%10+'0',k/=10;while(SS_ing)putchar(SS[SS_ing--]);putchar(' ');}

#define REPi(a, b) for(register int i = a, edi = b; i <= edi; i ++)
#define REPj(a, b) for(register int j = a, edj = b; j <= edj; j ++)
#define REPk(a, b) for(register int k = a, edk = b; k <= edk; k ++)
#define uREPi(a, b) for(register int i = a, edi = b; i >= edi; i --)
#define uREPj(a, b) for(register int j = a, edj = b; j >= edj; j --)
#define uREPk(a, b) for(register int k = a, edk = b; k >= edk; k --)
typedef long long LL;

template<class T>inline void Chkmin(T &a, T b){a = a < b ? a : b;}
template<class T>inline void Chkmax(T &a, T b){a = a > b ? a : b;}

inline void in(){freopen("input.txt", "r", stdin); freopen("output.txt", "w", stdout);}
inline void out(){fclose(stdin); fclose(stdout);}

const int MAXN = 100004;

int N;
char S[MAXN];

inline void Init(){
    scanf("%s", S + 1);
    N = strlen(S + 1);
}

int tree[2][MAXN << 2];

inline void Updata(int *tree, int idx, int l, int r, int k, bool add){
    if(l == r){
        if(add)
            tree[k] = l;
        else
            tree[k] = 1000000000;
        return ;
    }
    register int mid = (l + r) >> 1;
    if(idx <= mid) Updata(tree, idx, l, mid, k << 1, add);
    else Updata(tree, idx, mid + 1, r, k << 1 | 1, add);
    tree[k] = min(tree[k << 1], tree[k << 1 | 1]);
}

inline int Ask(int *tree, int L, int R, int l, int r, int k){
    if(L <= l && r <= R) return tree[k];
    register int mid = (l + r) >> 1;
    if(R <= mid) return Ask(tree, L, R, l, mid, k << 1);
    if(L > mid) return Ask(tree, L, R, mid + 1, r, k << 1 | 1);
    return min(Ask(tree, L, R, l, mid, k << 1), Ask(tree, L, R, mid + 1, r, k << 1 | 1));
}

int Stack[MAXN];
int top = 0;
int ans = 0;
int cnt[2] = {0};
int t[2];

inline void Solve(){
    bool p;
    memset(tree, 0x3f, sizeof(tree));
    REPi(1, N){
        Updata(tree[S[i] == 'R'], i, 1, N, 1, true);
        cnt[S[i] == 'R'] ++;
    }
    if(cnt[0] == cnt[1] + 1) p = 0;
    else if(cnt[1] == cnt[0] + 1) p = 1;
    else p = S[1] == 'R';
    t[p] = Ask(tree[p], 1, N, 1, N, 1);
    while(Ask(tree[0], 1, N, 1, N, 1) < MAXN || Ask(tree[1], 1, N, 1, N, 1) < MAXN){
        if(t[p] > MAXN){
            t[p] = Ask(tree[p], 1, N, 1, N, 1);
            t[p ^ 1] = Ask(tree[p ^ 1], t[p], N, 1, N, 1);
        }
        else{
            t[p ^ 1] = Ask(tree[p ^ 1], t[p], N, 1, N, 1);
            if(t[p ^ 1] < MAXN){
                if(Ask(tree[p], t[p ^ 1], N, 1, N, 1) > MAXN)
                    if(Ask(tree[p ^ 1], 1, N, 1, N, 1) < Ask(tree[p], 1, N, 1, N, 1))
                        t[p ^ 1] = Ask(tree[p ^ 1], 1, N, 1, N, 1);
            }
            else
                t[p ^ 1] = Ask(tree[p ^ 1], 1, N, 1, N, 1);
        }
        Stack[++ top] = t[p];
        Updata(tree[p], t[p], 1, N, 1, false);
        p ^= 1;
    }
    REPi(2, top) ans += Stack[i] < Stack[i - 1];
    cout << ans << endl;
    REPi(1, N)
        Write(Stack[i]);
}

int main(){
#ifndef ONLINE_JUDGE
    in();
#endif

    Init();
    Solve();

#ifndef ONLINE_JUDGE
    out();
#endif
    return 0;
}
