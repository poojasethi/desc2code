#include<stdio.h>
#include<string.h>
#include<algorithm>
#include<utility>
#include<vector>
#include<list>
#include<queue>
#include<set>
#include<map>
using namespace std;
#define NSIZ 1000010
#define MSIZ 1000010
#define inf 1010580540
#define mxint 2147483647
#define mxll 9223372036854775807LL
#define prime15 1000000000000037LL
#define prime16 10000000000000061LL
#define mod 1000000007LL
#define F first
#define S second
#define itt ::iterator
#define MAXPQ(T) priority_queue<T>
#define MINPQ(T) priority_queue<T,vector<T>,greater<T> >
#define ab(x) ((x)<0?-(x):(x))
typedef pair<int,int> pii;
typedef pair<long long,int> pli;
typedef pair<long long,long long> pll;
typedef pair<double,double> pdd;
typedef pair<int,pair<int,int> > pip;
typedef pair<pair<int,int>,pair<int,int> > ppp;

int n, m, o, re=0, re2=0;
long long res=0;
char a[NSIZ], b[NSIZ];
bool chk[NSIZ];
int nx[2][NSIZ];
vector<int> ans[NSIZ], fin, typ[2][2];
int finds(int cc, int d){
    if(chk[d]==0)return d;
    return nx[cc][d]=finds(cc,nx[cc][d]);
}
int main(){
    int i, j, k, l;
    long long ll=0, rr=mxll, mid;
    scanf("%s", a);
    n=strlen(a);
    if(n==1){printf("0\n1");return 0;}
    a[n]=0;
    k=0;
    for(i=0; i<n; i++){
        if(a[i]=='L')k--;
        else k++;
    }
    if(k>0)for(i=0; i<n; i++){if(a[i]=='L')a[i]='R';else a[i]='L';}
    int d[2]={n,n};
    for(i=n-1; i>=0; i--){
        if(a[i]=='L')a[i]=0;
        else a[i]=1;
        nx[0][i]=d[0];
        nx[1][i]=d[1];
        d[a[i]]=i;
    }
    k=0;
    for(i=0; i<n; i++){
        if(chk[i]==1)continue;
        j=i;
        while(j!=n){
            if(chk[j]==0)ans[k].push_back(j);
            chk[j]=1;
            j=finds(1-a[j],j);
        }
        typ[a[ans[k].front()]][a[ans[k].back()]].push_back(k);
        k++;
    }
//    for(i=0; i<k; i++){
//        for(j=0; j<ans[i].size(); j++){
//            printf("%d ", ans[i][j]);
//        }printf("\n");
//    }
    printf("%d\n", k-1);
    //RR LL
    for(i=0,j=0; i<typ[0][0].size() && j<typ[1][1].size(); i++,j++){
        for(k=0; k<ans[typ[0][0][i]].size(); k++){
            fin.push_back(ans[typ[0][0][i]][k]);
        }
        for(k=0; k<ans[typ[1][1][i]].size(); k++){
            fin.push_back(ans[typ[1][1][i]][k]);
        }
    }
    if(i<typ[0][0].size()){
        for(k=0; k<ans[typ[0][0][i]].size(); k++){
            fin.push_back(ans[typ[0][0][i]][k]);
        }
    }
    //RL LR
    if(fin.size()==0)k=1-a[0];
    else k=a[fin.back()];
    for(i=0; i<typ[1-k][k].size(); i++){
        for(j=0; j<ans[typ[1-k][k][i]].size(); j++){
            fin.push_back(ans[typ[1-k][k][i]][j]);
        }
    }
    for(j=0; j<typ[k][1-k].size(); j++){
        if(fin.size()==0 || ans[typ[k][1-k][j]].back()>fin.back()){
            fin.push_back(ans[typ[k][1-k][j]].back());
            for(i=0; i<ans[typ[k][1-k][j]].size()-1; i++){
                fin.push_back(ans[typ[k][1-k][j]][i]);
            }
        }
        else{
            l=fin.back();fin.pop_back();
            for(i=0; i<ans[typ[k][1-k][j]].size(); i++){
                fin.push_back(ans[typ[k][1-k][j]][i]);
            }
            fin.push_back(l);
        }
    }
    for(i=fin.size()==n?0:1; i<fin.size(); i++){
        if(fin[i]==n)continue;
        printf("%d ", fin[i]+1);
    }
    return 0;
}

