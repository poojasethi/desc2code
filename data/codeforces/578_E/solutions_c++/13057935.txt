#include <bits/stdc++.h>
using namespace std;
#define vi vector<int>
#define pii pair<int,int>
#define x first
#define y second
#define pb push_back
#define mp make_pair
#define ll long long 
#define inf 1000000007
#define mod 1000000007
#define N 100005
#define DBG(x) cerr<<(#x)<<"="<<x<<endl;
#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)

template <class T> inline void Max(T &a,T b){if(a<b)a=b;}
template <class T> inline void Min(T &a,T b){if(a>b)a=b;}

char s[N];
int n;
struct node{
    int f[N],n;
    void init(int m){
        n=m;
        for(int i=0;i<=n;i++)f[i]=0;
    }
    void upd(int x,int v){
        while(x<=n)f[x]+=v,x+=x&-x;
    }
    int query(int x){
        int ans=0;
        while(x>0)ans+=f[x],x-=x&-x;
        return ans;
    }
    int query(int x,int k){
        if(k==1){
            int l=x+1,r=n,y=query(x);
            while(l<=r){
                int m=(l+r)>>1;
                if(query(m)-y>0)r=m-1;
                else l=m+1;
            }
            return r+1;
        }
        else{
            int l=1,r=x-1;
            while(l<=r){
                int m=(l+r)>>1;
                if(query(m)>0)r=m-1;
                else l=m+1;
            }
            return r+1;
        }
    }
}T[2];
vector<vi>res;
int solve(deque<int> &v){
    int i,pos=0,ans=0,j;
    for(i=0;i<2;i++)T[i].init(n);
    for(i=1;i<=n;i++)T[s[i]].upd(i,1);
    int cnt=n,sz=-1,cur;
    res.clear();
    while(cnt){
        int x=T[0].query(n,0),y=T[1].query(n,0);
        if(x<y)cur=0,pos=x;
        else cur=1,pos=y;
        //cerr<<pos<<" "<<cur<<"\n";
        res.pb(vi());++sz;
        while(1){
            cnt--;res[sz].pb(pos);T[cur].upd(pos,-1);
            x=T[1-cur].query(pos,1);
            if(x<1||x>n)break;
            pos=x;cur=1-cur;
        }
    }
    vi g[2][2];int a[2][2]={0};
    for(i=0;i<=sz;i++){
        int x=s[res[i][0]],y=s[res[i].back()];
        a[x][y]++,g[x][y].pb(i);
    }
    int st,ed,k;
    for(i=0;i<2;i++)
        for(j=0;j<2;j++){
            a[i][j]=g[i][j].size();
            //DBG(a[i][j])
        }
    bool found=false;
    for(i=0;i<2&&!found;i++)
        for(j=0;j<2;j++)if(a[i][j]){
            int x=g[i][j][--a[i][j]];
            for(k=0;k<res[x].size();k++)v.pb(res[x][k]);
            found=true;st=i,ed=j;break;
        }
   // DBG(st)DBG(ed)DBG(sz)

    while(a[0][0]+a[0][1]+a[1][0]+a[1][1]>0){
        bool ok=0;
        for(i=0;i<2&&!ok;i++)if(a[i][1-st]){
            int x=g[i][1-st][--a[i][1-st]];
            for(j=res[x].size()-1;j>=0;j--)v.push_front(res[x][j]);
            st=s[res[x][0]];ok=1;break;
        }
        //DBG(ok)
        if(ok)continue;
        for(i=0;i<2&&!ok;i++)if(a[1-ed][i]){
            int x=g[1-ed][i][--a[1-ed][i]];
            for(j=0;j<res[x].size();j++)v.pb(res[x][j]);
            ed=s[res[x][j-1]];ok=1;break;
        }
    }
    return ans=res.size()-1;
}
int main(){
    int i,j,k,m=0;
    scanf("%s",s+1);n=strlen(s+1);
    for(i=1;i<=n;i++)s[i]=(s[i]=='L'?0:1);
    for(i=1;i<=n;i++)m+=(s[i]==0);
    deque<int>ret;
    int ans=solve(ret);
    printf("%d\n",ans);
    for(i=0;i<n;i++)printf("%d ",ret[i]);
    puts("");
    return 0;
}