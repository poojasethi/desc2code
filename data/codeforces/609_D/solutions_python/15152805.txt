n,m,k,s=map(int, raw_input().split())

dollar=map(int, raw_input().split())
pound=map(int, raw_input().split())

forDollars=[]
forPounds=[]
for i in xrange(m):
    t,c=map(int, raw_input().split())
    if t==1:
        forDollars.append([c,i])
    else:
        forPounds.append([c,i])

def prepro(gadgeds):
    gadgeds.sort()
    aggregated=[0]*(len(gadgeds)+1)
    for i in xrange(1, len(aggregated)):
        aggregated[i]=aggregated[i-1]+gadgeds[i-1][0]
    return aggregated; 
        
aggDollars=prepro(forDollars)
aggPounds=prepro(forPounds)


bestChangeDollar=[dollar[0], 0]
bestChangePound=[pound[0], 0]

import bisect
def best_buy(aggregated, maxValue):
    dN=bisect.bisect_right(aggregated, maxValue)
    return dN-1
    
def getCosts(costs, n, exchangeRate):
    m=len(costs)
    taken=0 if n==0 else costs[n-1][0]
    next=2**60 if n==m else costs[n][0]
    return (taken*exchangeRate, next*exchangeRate)
 
#it would be easy if we could recalculate the costs in s and resort the values - just take the minimal ones
# we dont have time for that, so try to find the last gadgeds in dollars and pfound with binary search   
def find_best_pair():

    n_d=0;
    n_p=best_buy(aggPounds, s/bestChangePound[0])
     
    low_d=0
    up_d=min(len(aggDollars), best_buy(aggDollars, s/bestChangeDollar[0])+1)
    
    while(low_d+1<up_d):
        middle=(low_d+up_d)/2
        costGadgeds=aggDollars[middle]*bestChangeDollar[0]
        if(costGadgeds>s):
            up_d=middle
        else:
            maxPound=(s-costGadgeds)/bestChangePound[0]
            p_middle=best_buy(aggPounds, maxPound)
            
            d_taken, d_next=getCosts(forDollars,  middle, bestChangeDollar[0])
            p_taken, p_next=getCosts(forPounds, p_middle, bestChangePound[0])     
            
            if d_taken<=p_next:
                low_d=middle
                n_p=p_middle
                n_d=middle
            else:
                up_d=middle
                 
    return (n_d, n_p)

def print_result(enumerated, n_d, day):
    for i in range(n_d):
        print enumerated[i][1]+1, day
        
def print_result_and_exit(n_d, n_p, n):
    print max(bestChangeDollar[1]+1, bestChangePound[1]+1)
    print_result(forDollars, min(n_d, n), bestChangeDollar[1]+1)
    print_result(forPounds, min(n_p, n-n_d), bestChangePound[1]+1)
    exit(0)

n_d, n_p=find_best_pair() 

if(n_d+n_p>=k):
    print_result_and_exit(n_d, n_p, k)
    
for i  in range(1, n):
    bestChangeDollar=min(bestChangeDollar, [dollar[i], i])
    bestChangePound=min(bestChangePound, [pound[i], i])
    if bestChangePound[1]==i or bestChangeDollar[1]==i:
        n_d, n_p=find_best_pair()
        if(n_d+n_p>=k):
            print_result_and_exit(n_d, n_p, k)
      
# cannot be achieved:
print -1  