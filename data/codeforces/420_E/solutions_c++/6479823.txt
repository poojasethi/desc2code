#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#define MAX 20000
#define PI 3.141592653589793
#define FOR(i, n) for (int i = 0; i < (n); ++i)
#define TR(it, c) for (typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)
using namespace std;

const double EPS = 1.0e-8;
const double MPI = 3.141592653589793L;
const double TAU = MPI * 2;

typedef pair<double, bool> bound;
int n, d, n_bounds;
bound sweep[MAX * 100];

static inline void add(const double& s, const double& e) {
  sweep[n_bounds++] = bound(s - EPS, true);
  sweep[n_bounds++] = bound(e + EPS, false);
}

int main() {
  scanf("%d%d", &n, &d);
  int dd = d * d;
  FOR (i, n) {
    int px, py, pr;
    scanf("%d%d%d", &px, &py, &pr);

    int DD = px * px + py * py;
    int pr2 = pr * pr;
    double D = sqrtl(DD);
    int ks = max(1, (int) floor((D - pr) / d));
    int ke = (int) ceil((D + pr) / d);

    for (int k = ks; k <= ke; ++k) {
      int kkdd = k * k * dd;
      int kkddDDpr = kkdd - DD - pr2;
      int prD2 = 2 * pr * D;
      if (kkddDDpr >= -prD2 && kkddDDpr <= prD2) {
        double t0 = atan2l(py, px);
        double dt = acosl((kkdd + DD - pr2) / (2 * k * d * D));
        double t1 = t0 - dt, t2 = t0 + dt;
        if (t1 + EPS < -PI) t1 += TAU;
        if (t2 > PI + EPS) t2 -= TAU;
        if (t1 < t2 + EPS) add(t1, t2);
        else add(t1, MPI), add(-MPI, t2);
      }
    }
  }

  sort(sweep, sweep + n_bounds);
  int maxf = 0, f = 0;
  FOR (i, n_bounds) {
    f += sweep[i].second ? 1 : -1;
    if (f > maxf) maxf = f;
  }

  printf("%d\n", maxf);

  return 0;
}
