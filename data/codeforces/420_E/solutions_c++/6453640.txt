#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <string>
#define REP(i,n) for (int i=1;i<=(n);++i)
#define FOR(i,a,b) for (int i=(a);i<=(b);++i)
#define ROF(i,a,b) for (int i=(a);i>=(b);--i)
#define FEC(p,u) for (edge*p=head[u];p;p=p->nxt)
using namespace std;
typedef long long LL;
double pi = 3.1415926535897932384626433832795;

int n, d, ans;
struct circle{
	int x, y, r;
	int d;
}a[30000];
struct abc{
	double arg; int tp;
}q[1000000];
int lq;
bool operator<(abc x, abc y){ return x.arg < y.arg || x.arg == y.arg && x.tp > y.tp; }

int main(){
	scanf("%d%d", &n, &d);
	REP(i,n){
		scanf("%d%d%d", &a[i].x, &a[i].y, &a[i].r);
		a[i].d = a[i].x*a[i].x+a[i].y*a[i].y;
	}
	int t(0);
	for (int i = d; i <= 15000; i += d){
		REP(j,n) if ((i+a[j].r)*(i+a[j].r) >= a[j].d && (i-a[j].r)*(i-a[j].r) <= a[j].d){
			double theta = atan2(a[j].y, a[j].x), dlt = acos((a[j].d+i*i-a[j].r*a[j].r)/(2*i*sqrt(a[j].d)));
			q[++lq].arg = theta-dlt, q[lq].tp = 1;
			if (q[lq].arg < -pi){  q[lq].arg += 2*pi; ++t; }
			q[++lq].arg = theta+dlt, q[lq].tp = -1;
			if (q[lq].arg > pi){ q[lq].arg -= 2*pi; ++t; }
		}
	}
	sort(q+1, q+lq+1);
	ans = t;
	REP(i,lq){ t += q[i].tp; ans = max(ans, t); }
	printf("%d\n", ans);
	return 0;
}

