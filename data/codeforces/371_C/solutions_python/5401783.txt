from Queue import * # Queue, LifoQueue, PriorityQueue
from bisect import * #bisect, insort
from datetime import * 
from collections import * #deque, Counter,OrderedDict,defaultdict
import calendar
import heapq
import math
import copy
import itertools
myread = lambda : map(int,raw_input().split())

def can_make(x,one_need,now,price,r):
    now_need = [one_need[i]*x for i in range(3)]
    now_need = [max(0,now_need[i] - now[i]) for i in range(3)]
    
    sum_price = 0
    for i in range(3):
        sum_price += now_need[i] * price[i]
        
    if sum_price <= r:
        return True
    else:
        return False


def solver():
    humburger = raw_input()
    
    one_need = [0,0,0]
    one_need[0] = humburger.count("B")
    one_need[1] = humburger.count("S")
    one_need[2] = humburger.count("C")
    
    now = myread()
    price = myread()
    r = input()

    up = 10 ** 20
    lp = 0

    while up != lp:
        mid = (up + lp) / 2 + 1
        
        if can_make(mid,one_need,now,price,r):
            lp = mid
        else:
            up = mid-1
        #print lp,up
    print up

        




if __name__ == "__main__":
    solver()
    
