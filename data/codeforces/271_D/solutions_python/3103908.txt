s = raw_input()
good = map(int, raw_input())
K = int(raw_input())

def build_sa(s, calHeight=True):
    # s: they input string 
    # return: (sa, height) if calHeight = True;
    #         only sa if calHeight = False.
    n = len(s)
    P = [[0] * n, [0] * n]
    L = [None] * n
    for i in xrange(n):
        P[0][i] = ord(s[i])
    s1 = 0
    s2 = 1
    cnt = 1
    finish = False
    while not finish:
        for i in xrange(n):
            if i + cnt < n:
                w = P[s1][i + cnt]
            else:
                w = -1
            L[i] = (P[s1][i], w, i)
        L.sort()
        # print cnt, [(p, w, s[i:]) for p, w, i in L]
        finish = True
        for i in xrange(n):
            if i > 0 and L[i][:-1] == L[i-1][:-1]:
                P[s2][L[i][-1]] = P[s2][L[i-1][-1]]
                finish = False
            else:
                P[s2][L[i][-1]] = i
        s1, s2 = s2, s1
        cnt *= 2
    if not calHeight: return [x[-1] for x in L]
    # cal height
    H = [0] * n
    k = 0
    for i in xrange(n):
        if P[s1][i] > 0:
            j = L[P[s1][i]-1][-1]
            while i + k < n and j + k < n and s[i + k] == s[j + k]:
                k += 1
            H[P[s1][i]] = k
        if k: k -= 1
    return [x[-1] for x in L], H 

def solve(s, good, K):
    n = len(s)
    ans = 0
    sa, h = build_sa(s, True)
    pos = [None] * n
    for i, x in enumerate(sa):
        pos[x] = i
    for i in xrange(n):
        bad = 0
        # p.print_('^')
        for j in xrange(i + 1, n + 1):
            # s[i:j]
            c = ord(s[j-1]) - ord('a')
            if not good[c]:
                bad += 1
                if bad > K: break
            if h[pos[i]] < j - i:
                # print 'word:', s[i:j], 'pos:', pos[i], (i, j), h[i]
                ans += 1
    return ans
print solve(s, good, K)
