

inputs = raw_input().split()

nodes = int(inputs[0])
edges = int(inputs[1])

graph = []
for k in range(nodes):
	graph.append([])

for k in range(edges):
	e = raw_input().split()
	left = int(e[0])-1
	right = int(e[1])-1
	#print "l = " + str(left) + "  r = " + str(right)

	#append necessary stuff
	graph[left].append(right)
	graph[right].append(left)

#print graph


#check cycle, but also needs to be minimal cycle
#how much would it cost to find all the 3-cycles? 
cycles = []
#print graph

#for every edge, check every vertex and see if it contains the components of the edge
for k in range(len(graph)):
	for j in graph[k]:
		#edge of k,j 
		#do they have a common vertex? 
		for m in graph[k]:
			#is this value in next row?
			if m in graph[j]:
				#add a set of three
				cycles.append([k,j,m])


#for every node, get length 
lens = []
for k in range(len(graph)):
	lens.append(len(graph[k]))

#print lens

cycleLens = []
for k in range(len(cycles)):
	cycleLens.append(lens[cycles[k][0]] + lens[cycles[k][1]] + lens[cycles[k][2]] - 6)

#get min lens
if len(cycleLens) == 0:
	print -1
else:
	print min(cycleLens)
		











  	     		 		    	  		  			   	