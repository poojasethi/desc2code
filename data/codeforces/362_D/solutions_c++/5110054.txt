# include<stdio.h>
# include<string.h>
# include<algorithm>
# include<queue>
using namespace std;
const int maxn=100005;
int fa[maxn];
long long size[maxn];
int findfa(int x)
{
	return x==fa[x] ? x : fa[x]=findfa(fa[x]);
}
class hh
{
	public:
	long p; long long size;
	hh(long P=0,long long S=0)
	{
		p=P; size=S;
	}
	bool operator < (const hh & w) const
	{
		return size>w.size;
	}
};
priority_queue<hh> Q;
int main()
{
	int n,m,p,q; scanf("%d%d%d%d",&n,&m,&p,&q);
	int i,j,k;long long u;
	for (i=1;i<=n;i++) fa[i]=i;
	memset(size,0,sizeof(size));
	for (i=1;i<=m;i++)
	{
		scanf("%d%d%d",&j,&k,&u);
		j=findfa(j); k=findfa(k);
		if (j!=k)
		{
		    fa[j]=k;
		    size[k]+=size[j];
		}
		size[k]+=u;
	}
	while (!Q.empty()) Q.pop();
	for (i=1;i<=n;i++)
	    if (fa[i]==i)
	        Q.push(hh(i,size[i]));
    if (Q.size()<q || Q.size()-q>p || Q.size()==n && p>0 && q==n)
    {
    	puts("NO");
    	return 0;
    }
    puts("YES");
    while (Q.size()>q && p>0)
    {
    	hh x,y;
    	while (1)
    	{
	    	x=Q.top(); Q.pop();
	    	if (size[x.p]==x.size)
	    	    break;
	    }
	    while (1)
	    {
    		y=Q.top(); Q.pop();
    		if (size[y.p]==y.size)
    		    break;
    	}
    	fa[x.p]=y.p;
    	y.size=size[y.p]+=size[x.p]+min(1000000000ll,size[x.p]+size[y.p]+1);
    	                                 
    	Q.push(y);
    	p--;
    	printf("%d %d\n",x.p,y.p);
    }
    for (i=1;i<=n;i++)
        if (fa[i]!=i)
            while (p>0)
            {
            	p--;
            	printf("%d %d\n",i,fa[i]);
            }
    return 0;
}
