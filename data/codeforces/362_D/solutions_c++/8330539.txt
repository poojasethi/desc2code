#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<queue>
using namespace std;
const int maxn=100010;
typedef long long int64;
struct Tufset{
	int fa[maxn];
	void clear(int n){ for(int i=1;i<=n;++i) fa[i]=i; }
	int find(int x){ return fa[x]==x?x:fa[x]=find(fa[x]); }
	void merge(int x,int y){ fa[find(x)]=find(y); }
}ufset;
int n,m,rd,blk;

int64 v[maxn];
void init(){
	scanf("%d%d%d%d",&n,&m,&rd,&blk);
	ufset.clear(n); memset(v,0,sizeof(v));
	for(int i=1;i<=m;++i){
		int a,b,c; scanf("%d%d%d",&a,&b,&c);
		v[a]+=c,ufset.merge(a,b);
	}
	for(int i=1;i<=n;++i)
		if(ufset.find(i)!=i) v[ufset.find(i)]+=v[i],v[i]=0;
}

typedef pair<int64,int> PII;
typedef priority_queue< PII,vector<PII>,greater<PII> > minheap;
minheap heap; int apr[maxn];
void solve(){
	heap=minheap(); int have=0;
	for(int i=1;i<=n;++i)
		if(ufset.find(i)==i) heap.push(make_pair(v[i],i)),++have;
	if(have-blk>rd || have<blk){ puts("NO"); return; }
	if(have==n && blk==n){ rd?puts("NO"):puts("YES"); return; }
	puts("YES");
	for(int i=have;i>blk;--i,--rd){
		PII x=heap.top(); heap.pop();
		PII y=heap.top(); heap.pop();
		printf("%d %d\n",ufset.find(x.second),ufset.find(y.second));
		ufset.merge(x.second,y.second);
		heap.push(make_pair((x.first+y.first)*2+1,ufset.find(x.second)));
	}
	memset(apr,0,sizeof(apr));
	for(int i=1;i<=n;++i)
		if(apr[ufset.find(i)]){
			while(rd--) printf("%d %d\n",apr[ufset.find(i)],i);
			break;
		}
		else apr[ufset.find(i)]=i;
}

int main(){
	init();
	solve();
	return 0;
}

 	 	  			  	   		  			 	 						