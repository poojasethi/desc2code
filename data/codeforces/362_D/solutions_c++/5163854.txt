#include <bits/stdc++.h>
using namespace std;

const int N = 111111;
typedef long long LL;
int n, m, p, q;

struct MFS {
	int fa[N], c;
	LL sum[N];
	void init(int n) { for (int i = 1; i <= n; i++) fa[i] = i, sum[i] = 0; c = n; }
	int find(int x) { return fa[x] = fa[x] == x ? x : find(fa[x]); }
	bool same(int x, int y) { return find(x) == find(y); }
	void merge(int x, int y, int d) {
		int fx = find(x), fy = find(y);
		if (fx == fy) sum[fx] += d;
		else {
			fa[fx] = fy;
			sum[fy] += sum[fx] + d;
			c--;
		}
	}
} mfs;

typedef pair<LL, int> PLI;
int X[N], Y[N];
#define x first
#define y second
const int UB = 1000000000;

bool work() {
	if (mfs.c < q) return 0;
	if (q == n && p) return 0;
	if (mfs.c - p > q) return 0;
	set<PLI> region;
	for (int i = 1; i <= n; i++) {
		int fi = mfs.find(i);
		region.insert(PLI(mfs.sum[fi], fi));
		//cout << mfs.sum[fi] << ' ' << fi << endl;
	}
	int tt = 0;
	while (region.size() > q) {
		PLI t1 = *region.begin();
		region.erase(t1);
		PLI t2 = *region.begin();
		region.erase(t2);
		X[tt] = t1.y, Y[tt++] = t2.y;
		region.insert(PLI(min((LL) UB, t1.x + t2.x + 1) + t1.x + t2.x, t1.y));
		mfs.merge(t1.y, t2.y, (int) min((LL) UB, t1.x + t2.x + 1));
	}
	if (tt < p) for (int i = 1; i <= n; i++) if (mfs.fa[i] != i) {
		while (tt < p) X[tt] = i, Y[tt++] = mfs.fa[i];
		break;
	}
	return 1;
}

int main() {
	while (cin >> n >> m >> p >> q) {
		mfs.init(n);
		int x, y, d;
		for (int i = 0; i < m; i++) {
			cin >> x >> y >> d;
			mfs.merge(x, y, d);
		}
		if (work()) {
			cout << "YES" << endl;
			for (int i = 0; i < p; i++) cout << X[i] << ' ' << Y[i] << endl;
		} else cout << "NO" << endl;
	}
	return 0;
}
