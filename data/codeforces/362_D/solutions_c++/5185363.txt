#include <algorithm>
#include <iostream>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <string>
#include <math.h>
#include <vector>
#include <queue>
#include <stack>
#include <cmath>
#include <list>
#include <set>
#include <map>
using namespace std;

#define N  100010
#define ALL(x)     x.begin(),x.end()
#define CLR(x,a)   memset(x,a,sizeof(x))
typedef long long 	 ll;
typedef pair<ll,int> PI;
const int INF    = 0x3fffffff;
const int MOD    = 100000007;
const double EPS = 1e-7;

int par[N];
ll sum[N];

priority_queue<PI, vector<PI>, greater<PI> > que;

void init(int n)
{
	for(int i=1;i<=n;i++)
		par[i]=i,sum[i]=0;
}

int find(int x)
{
	return x==par[x]?x:par[x]=find(par[x]);
}

void merge(int x,int y)
{
	x=find(x);
	y=find(y);
	if(x==y) return ;
	par[x]=y;
	sum[y]+=sum[x];
}
PI p1,p2;
int main()
{
	int n,m,p,q,u,v,len;
	scanf("%d%d%d%d",&n,&m,&p,&q);
	init(n);
	while(m--){
		scanf("%d%d%d",&u,&v,&len);
		sum[find(u)]+=len;
		merge(u,v);
	}
	int cnt=0;
	for(int i=1;i<=n;i++) if(par[i]==i){
	   	cnt++;
		que.push((PI){sum[i],i});
	}
	if( (cnt==n && p && q==n) || cnt-q<0 || p<cnt-q) puts("NO");
	else{
		puts("YES");
		m=cnt-q;
		p-=m;
		while(m--){
			p1=que.top(); que.pop();
			p2=que.top(); que.pop();
			printf("%d %d\n",p1.second,p2.second);
			ll val=p1.first+p2.first+min(1000000000ll,p1.first+p2.first+1);
			que.push((PI){val,p1.second});
		}
		if(!p1.second && !p2.second) p1.second=u, p2.second=v;
		while(p--) printf("%d %d\n",p1.second,p2.second);
	}
	return 0;			
}
