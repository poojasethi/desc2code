#include <cstdio>
#include <queue>
#include <algorithm>
#include <utility>
#define REP(i,n) for (int i=1;i<=n;++i)
using namespace std;

const int BIG=1000000000;

const int MAXN=100010;
priority_queue< pair<int,int> > pq;
int n,m,p,q,x,y,z,lastx,lasty,top;
int next[MAXN];
int pri[MAXN];
int ans[MAXN][2];

int Find(int k) {
	if (next[k]!=k) next[k]=Find(next[k]);
	return next[k];
}

void Test(int x,int y) {
	lastx=x;
	lasty=y;
}

int main() {
	scanf("%d%d%d%d",&n,&m,&p,&q);
	int pp=p;
	REP(i,n) next[i]=i;
	REP(i,m) {
		scanf("%d%d%d",&x,&y,&z);
		Test(x,y);
		x=Find(x); y=Find(y);
		if (x!=y) pri[x]=min(BIG,pri[y]+pri[x]);
		next[y]=x;
		pri[x]=min(BIG,pri[x]+z);
	}
	REP(i,n) if (next[i]==i)
		pq.push(make_pair(-pri[i],i));
	while ((pq.size()>q)&&(p)) {
		pair<int,int> tmp1=pq.top(); pq.pop(); tmp1.first=-tmp1.first;
		pair<int,int> tmp2=pq.top(); pq.pop(); tmp2.first=-tmp2.first;
		tmp1.first=min(BIG,tmp1.first+tmp2.first);
		tmp1.first=min(BIG,tmp1.first+tmp1.first+1);
		tmp1.first=-tmp1.first;
		pq.push(tmp1);
		ans[++top][0]=tmp1.second;
		ans[top][1]=tmp2.second;
		Test(tmp1.second,tmp2.second);
		--p;
	}
	if (pq.size()!=q) puts("NO"); else
	if ((p)&&(!lastx)) puts("NO"); else {
		REP(i,p) {
			ans[++top][0]=lastx;
			ans[top][1]=lasty;
		}
		puts("YES");
		REP(i,pp) printf("%d %d\n",ans[i][0],ans[i][1]);
	}
	return 0;
}

