#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <algorithm>

using namespace std;

template <class TAT>
inline void read(TAT &a)
{
	static char cc;
	static bool f;
	while ((cc = getchar()) != '-' && (cc < '0' || cc > '9'));
	if (cc == '-') f = 1, a = 0;
	else f = 0, a = cc - '0';
	while ((cc = getchar()) >= '0' && cc <= '9') a = a * 10 + cc - '0';
	if (f) a = -a;
}
template <class TAT>
inline void write(TAT a)
{
	static char cc[27];
	static int ct;
	if (a == 0) {
		putchar('0');
		return;
	}
	if (a < 0) {
		a = -a;
		putchar('-');
	}
	ct = 0;
	while (a) cc[++ct] = a % 10 + '0', a /= 10;
	while (ct) putchar(cc[ct--]);
}
template <class TAT>
inline void Ckmin(TAT &a, const TAT &b)
{
	if (a > b) a = b;
}
template <class TAT>
inline void Ckmax(TAT &a, const TAT &b)
{
	if (a < b) a = b;
}
void begin()
{
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);
}
void end()
{
	fclose(stdin);
	fclose(stdout);
}

const int maxn = 1e5+5;
const int maxm = 89;
const int maxc = 29;
const int maxs = 115;

int n, m, Len;
int P[maxn];
char S[maxn], Sc[maxm][maxs];
long long Cnt[maxm][maxc];
int Sum[maxm][maxs][maxc], Initial[maxs][maxc];

void Init()
{
    scanf("%s", S + 1);
    Len = strlen(S + 1);
    read(n), read(m);
    for (int i = 1; i <= Len; ++i) {
        S[i] -= 'a' - 1;
    }
    for (int i = 1; i <= Len; ++i) {
        for (int j = 1; j <= 26; ++j) {
            Initial[i][j] = Initial[i - 1][j] + (S[i] == j);
        }
    }
    bool No = 0;
    for (int i = 1; i <= n; ++i) {
        read(P[i]);
        if ((1LL << (i - 1)) * (double)Len > 4e18) {
            No = 1;
        }
        if (!No) {
            P[i] %= (1LL << (i - 1)) * Len;
        }
    }
}

void Prepare()
{
    int total = Len, Nt, N;
    static char t1[maxn], t2[maxn];
    char *x, *y;
    bool spill = 0;
    x = t1;
    y = t2;
    for (int i = 1; i <= Len; ++i) {
        ++Cnt[0][S[i]];
    }
    for (int i = 1; i <= 60; ++i) {
        for (int j = 1; j <= 26; ++j) {
            Cnt[i][j] = Cnt[i - 1][j] * 2;
        }
    }
    memcpy(x, S, sizeof(char) * (total + 3));
    reverse(x + 1, x + 1 + total);
    for (int i = 0; i <= 60; ++i) {
        N = min(total, 101);
        for (int j = 1; j <= N; ++j) {
            Sc[i][j] = x[j];
        }
        for (int j = 1; j <= N; ++j) {
            for (int k = 1; k <= 26; ++k) {
                Sum[i][j][k] = Sum[i][j - 1][k] + (Sc[i][j] == k);
            }
        }
        if (spill == 0) {
            Nt = 0;
            for (int j = P[i + 1] + 1; j <= total; ++j) {
                y[++Nt] = x[j];
            }
            for (int j = 1; j <= P[i + 1]; ++j) {
                y[++Nt] = x[j];
            }
            for (int j = 1; j <= total; ++j) {
                y[++Nt] = x[j];
            }
            total = Nt;
            swap(x, y);
            if (total >= 8192) {
                spill = 1;
            }
        }
        else {
            Nt = 0;
            for (int j = P[i + 1] + 1; j <= total; ++j) {
                y[++Nt] = x[j];
            }
            total = Nt;
            swap(x, y);
        }
    }
}

long long Getans(long long L, long long R, int ch, int p)
{
    long long mid;
    mid = (1LL << (p - 1)) * Len;
    if (p == 0) {
        return Initial[R][ch] - Initial[L - 1][ch];
    }
    if (R <= mid) {
        return Getans(L, R, ch, p - 1);
    }
    else if (L > mid) {
        long long St = 0;
        L = (L - P[p] - 1 + mid) % mid + 1;
        R = (R - P[p] - 1 + mid) % mid + 1;
        if (R >= L) St = Getans(L, R, ch, p - 1);
        else {
            St = Getans(1, R, ch, p - 1) + Sum[p - 1][mid - L + 1][ch];
        }
        return St;
    }
    else {
        long long St = 0;        
        if (R - mid <= P[p]) {
            R -= mid;
            St = Getans(L, mid, ch, p - 1) + Sum[p - 1][P[p]][ch] - Sum[p - 1][P[p] - R][ch];
            return St;
        }
        St += Sum[p - 1][P[p]][ch];
        St += Cnt[p - 1][ch];
        if (-L + 1 + R - P[p] < mid) {
            St -= Getans(R - mid - P[p] + 1, L - 1, ch, p - 1);
        }
        else if (-L + 1 + R - P[p] > mid) {
            St += Getans(L, R - mid - P[p], ch, p - 1);
        }
        return St;
    }
}

void Solve()
{
    char ch;
    long long l, r;
    for (int i = 1; i <= m; ++i) {
        read(l), read(r);
        while ((ch = getchar()) < 'a' || ch > 'z'); 
        write(Getans(l, r, ch - 'a' + 1, max(0, (int)log2(r / (double)Len)) + 1));
        putchar('\n');
    }
}

int main()
{
	
    Init();
    Prepare();
    Solve();
	
	return 0;
}
