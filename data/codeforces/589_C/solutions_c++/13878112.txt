#include <algorithm>
#include <bitset>
#include <deque>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <vector>

#define fst first
#define snd second
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define clr( a , v ) memset( a , v , sizeof(a) )
#define pb push_back
#define mp make_pair
#define sz size()
#define FORN( i , s , n ) for( int i = s ; i < (int)(n) ; i++ )
#define FOR( i , n ) FORN( i , 0 , n )
#define FORIT(i,x) for( typeof x.begin() i = x.begin() ; i != x.end() ; i++ )
#define trace(x)    cout << #x << ": " << x << endl;
#define trace2(x, y) cout << #x << ": " << x << " | " << #y << ": " << y << endl;
#define trace3(x, y, z) cout << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl;
#define read ios::sync_with_stdio(false)

using namespace std;

typedef long long int64;
typedef vector <int64> vi;
typedef pair <int64,int64> ii;
typedef vector <ii> vii;
typedef vector <string> vs;


vi tam;
int64 finD[100005];
int64 iniD[100005];

int64 cont0[2000005][30];
int64 cont [100005][30];
vi rot;

int64 c;

inline int64 f (int64 T){

    int64 day = upper_bound(all(tam),T) - tam.begin();

    if ( day==0 ) return cont0[T][c];

    if ( T==tam[day]-1 ) return cont[day][c];
    T -= tam[day-1];
    int64 ans = cont[day-1][c];

    if (T<rot[day]){
        ans+= (cont0[iniD[day] + T ][c] - cont0[iniD[day]-1][c] );
    }
    else {
        ans+= (cont0[finD[day]       ][c] - cont0[iniD[day]-1][c] );
        T-=rot[day];
        ans+=f (T);
    }
    return ans;
}


int main(){
    read;
    string s,t;
    cin>>s;
    clr(cont0,0);
    clr(cont,0);
    clr(iniD,0);
    clr(finD,0);

    int64 N,M,l,r;
    cin>>N>>M;
    rot.pb(0);
    FOR(i,N) {
        cin>>l;
        if ( s.sz<100000 ) {
            l%=s.sz;
            t = s.substr(s.sz-l,-1);
            t+= s.substr(0,s.sz-t.sz);
            s = s+t;
        }
        else rot.pb(l);
    }
    N = rot.sz;


    cont0[0][s[0]-'a'] = 1;

    FORN(i,1,s.sz){
        FOR(j,26) cont0[i][j] = cont0[i-1][j];
        cont0[i][s[i]-'a']++;
    }
    //trace(0);
    int64 cnt = 0;
    tam.pb(s.sz);
    while ( tam[cnt] <= 1000000000000000000LL ) tam.pb(tam[cnt++]*2LL);

    FOR(i,cnt)
            FOR(j,26){
                if (i==0) cont[i][j] = cont0[s.sz-1][j];
                else cont[i][j] = cont[i-1][j]*2LL;
            }
    int64 fin = s.sz-1;

    FORN(i,1,N){
        finD[i] = fin;
        iniD[i] = fin - rot[i] + 1;
        fin = iniD[i]-1;
    }
    char C;
    FOR(i,M){
        cin>>l>>r>>C;
        l--;r--;
        c = C-'a';
        if (l!=0)cout<<f(r) - f (l-1)<<endl;
        else     cout<<f(r)<<endl;
    }
    return 0;
}
