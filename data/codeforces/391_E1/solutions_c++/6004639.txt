#include <iostream>
#include <fstream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <ctime>
#include <string>
#include <vector>
#include <deque>
#include <queue>
#include <set>
#include <stack>
#include <map>
#include <climits>
#include <cassert>

#define FOR(i,n) for(int i=0,_n=n;i<_n;i++)
#define FORD(i,n) for(int i=n;i>=0;i--)
#define FORR(i,s,n) for(int i=s,_n=n;i<_n;i++)
#define FORRD(i,n,s) for(int i=n,_s=s;i>=_s;i--)
#define mp make_pair
#define pb push_back
#define pii pair<int,int>
#define pli pair<ll,int>
#define vi vector<int>
#define fs first
#define sec second

#define maxn 100000
using namespace std;
typedef long long ll;

int n[3];
vi tree[3][maxn];
ll S[3][maxn],sts[3][maxn],mxx[3],sum[3];


ll fsubtree(int x,int y,int t){
	sts[t][x] = 1;
	FOR(i,tree[t][x].size())
		if(tree[t][x][i] != y)
			sts[t][x] += fsubtree(tree[t][x][i],x,t);
	return sts[t][x];
}

ll fsum(int x,int y,int t){
	S[t][x] = 0LL;
	FOR(i,tree[t][x].size())
		if(tree[t][x][i] != y)
			S[t][x] += fsum(tree[t][x][i],x,t);
	return S[t][x] + sts[t][x];	
}

void fsum2(int x,int y,int t,ll up,ll upcnt){
	FOR(i,tree[t][x].size())
		if(tree[t][x][i] != y){
			ll toadd = up + S[t][x] - S[t][tree[t][x][i]] - sts[t][tree[t][x][i]];
			toadd += sts[t][x] - sts[t][tree[t][x][i]] + upcnt;
			fsum2(tree[t][x][i],x,t,toadd,upcnt + sts[t][x] - sts[t][tree[t][x][i]]);
		}
	S[t][x] += up;
	mxx[t] = max(mxx[t],S[t][x]);
	sum[t] += S[t][x];
}

ll ANS = 0LL;

void funder(int x,int y,int t,int oth,ll d){
	// calc value
	ll val = n[t] * mxx[(t + 1) % 3] + n[t] * n[(t + 1) % 3] + n[(t + 1) % 3] * S[t][oth];
	val += n[t] * mxx[(t + 2) % 3] + n[t] * n[(t + 2) % 3] + n[(t + 2) % 3] * S[t][x];
	val += n[(t + 1) % 3] *  mxx[(t + 2) % 3] + n[(t + 1) % 3] * n[(t + 2) % 3] * (d + 2LL);
	val += n[(t + 2) % 3] * mxx[(t + 1) % 3];
	
	ANS = max(ANS,val);
	FOR(i,tree[t][x].size())
		if(tree[t][x][i] != y)
			funder(tree[t][x][i],x,t,oth,d + 1);
}
void fmain(int x,int y,int t){ // main pair
	funder(x,-1,t,x,0);
	FOR(i,tree[t][x].size())
		if(tree[t][x][i] != y)
			fmain(tree[t][x][i],x,t);
}

int main(){
	FOR(i,3) cin>>n[i];
	FOR(i,3)
		FOR(j,n[i] - 1){
			int u,v;
			cin>>u>>v;
			u--;v--;
			tree[i][u].pb(v);
			tree[i][v].pb(u);
		}
	FOR(i,3){
		fsubtree(0,-1,i);
		fsum(0,-1,i);
		fsum2(0,-1,i,0,0);
	}
	
	FOR(i,3)
		fmain(0,-1,i);
	cout<<ANS + (sum[0] + sum[1] + sum[2]) / 2<<"\n";
	return 0;
}
