#include <iostream>
#include <vector>
using namespace std;

typedef long long ll;
typedef vector<int> vi;

int N[3];
vector<vi> G[3];

int C; // current tree
ll Up[3][1001], Down[3][1001], Dist[3][1001], Mx[3];
int L[3][1001], Child[3][1001]; int par[3][1001][11];
void dfs_down(int v) {
    for (int i = 0; i < 10; ++i) par[C][v][i + 1] = par[C][par[C][v][i]][i];
    Down[C][v] = 0; Child[C][v] = 1;
    for (int i = 0; i < (int)G[C][v].size(); ++i) {
        int u = G[C][v][i]; if (Child[C][u]) continue;
        par[C][u][0] = v; L[C][u] = L[C][v] + 1;
        dfs_down(u); Child[C][v] += Child[C][u]; Down[C][v] += Down[C][u] + Child[C][u];
    }
}
void dfs_up(int v) {
    if (v == 1) Up[C][v] = 0;
    Mx[C] = max(Mx[C], Down[C][v] + Up[C][v]);
    Dist[C][v] = Up[C][v] + Down[C][v];
    for (int i = 0; i < (int)G[C][v].size(); ++i) {
        int u = G[C][v][i]; if (par[C][v][0] == u) continue;
        Up[C][u] = Up[C][v] + Down[C][v] - Down[C][u] + (N[C] - 2 * Child[C][u]); dfs_up(u);
    }
}
int lca(int C, int u, int v) {
    if (L[C][u] > L[C][v]) swap(u, v);
    for (int i = 10; i >= 0; --i) if (L[C][v] - (1 << i) >= L[C][u]) v = par[C][v][i];
    for (int i = 10; i >= 0; --i) if (par[C][v][i] != par[C][u][i]) {
        u = par[C][u][i], v = par[C][v][i];
    }
    return (u == v ? u : par[C][u][0]);
}
int distance(int C, int u, int v) {
    return L[C][u] + L[C][v] - 2 * L[C][lca(C, u, v)];
}

int main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    ll sum = 0;
    for (int tree = 0; tree < 3; ++tree) cin >> N[tree];
    for (int tree = 0; tree < 3; ++tree) {
        G[tree].assign(N[tree] + 1, vi());
        int u, v;
        for (int i = 1; i < N[tree]; ++i) {
            cin >> u >> v; G[tree][u].push_back(v); G[tree][v].push_back(u);
        }
        C = tree; L[C][1] = 1; dfs_down(1); dfs_up(1);
        for (int i = 1; i <= N[tree]; ++i) sum += Dist[C][i];
    }
    sum /= 2; sum += 1LL * N[0] * N[1] + 1LL * N[1] * N[2] + 1LL * N[2] * N[0];
    ll ans = 0;
    for (int mid = 0; mid < 3; ++mid) {
        int L = (mid + 2) % 3, R = (mid + 1) % 3;
        for (int i = 1; i <= N[mid]; ++i) for (int j = 1; j <= N[mid]; ++j) {
            ll val = 0;
            val += Mx[L] * N[mid] + Dist[mid][i] * N[L];
            val += Mx[R] * (N[L] + N[mid]);
            val += (Dist[mid][j] + (distance(mid, i, j) + 1LL) * N[L] + Mx[L]) * N[R];
            //cout << mid << ' ' << i << ' ' << j << ' ' << val << endl;
            ans = max(ans, val);
        }
    }
    cout << ans + sum << endl;
}
