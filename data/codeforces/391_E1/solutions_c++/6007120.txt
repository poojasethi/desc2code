//tonynater - CodeForces 2014

#include <algorithm>
#include <assert.h>
#include <bitset>
#include <cassert>
#include <climits>
#include <cmath>
#include <complex>
#include <ctime>
#include <ctype.h>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <math.h>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <vector>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

using namespace std;

#define sz(x) ((int) x.size())

typedef long double ld;
typedef long long ll;
typedef pair<int, int> pii;

const double pi = acos(-1);
const double tau = 2*pi;
const double epsilon = 1e-9;

const ll INF = (1LL)<<60;

const int MAX_N = 100100;

int N[3];

vector<int> adj[3][MAX_N];

vector<int> children[3][MAX_N];
void root(int tree, int u, int parent)
{
    for(int i = 0; i < sz(adj[tree][u]); i++)
        if(adj[tree][u][i] != parent)
        {
            children[tree][u].push_back(adj[tree][u][i]);
            root(tree, adj[tree][u][i], u);
        }
}

ll sz[3][MAX_N];
void compsz(int tree, int u)
{
    sz[tree][u] = 1;
    for(int i = 0; i < sz(children[tree][u]); i++)
    {
        compsz(tree, children[tree][u][i]);
        sz[tree][u] += sz[tree][children[tree][u][i]];
    }
}

ll subS[3][MAX_N];
void compsubS(int tree, int u)
{
    for(int i = 0; i < sz(children[tree][u]); i++)
    {
        compsubS(tree, children[tree][u][i]);
        subS[tree][u] += subS[tree][children[tree][u][i]]+sz[tree][children[tree][u][i]];
    }
}

ll S[3][MAX_N];
ll mxS[3];
void compS(int tree, int u, ll pS)
{
    S[tree][u] = pS + subS[tree][u];
    mxS[tree] = max(S[tree][u], mxS[tree]);
    for(int i = 0; i < sz(children[tree][u]); i++)
        compS(tree, children[tree][u][i],
              pS+subS[tree][u]-(subS[tree][children[tree][u][i]]+sz[tree][children[tree][u][i]])+N[tree]-sz[tree][children[tree][u][i]]);
}

ll subSDN[3][MAX_N];
void compsubSDN(int tree, int u)
{
    subSDN[tree][u] = S[tree][u];
    for(int i = 0; i < sz(children[tree][u]); i++)
    {
        compsubSDN(tree, children[tree][u][i]);
        subSDN[tree][u] = max(subSDN[tree][children[tree][u][i]]+N[(tree+1)%3], subSDN[tree][u]);
    }
}

ll SDN[3][MAX_N];
void compSDN(int tree, int u, ll pSDN)
{
    SDN[tree][u] = max(subSDN[tree][u], pSDN);
    
    ll mx1 = -INF, idx1 = -1, mx2 = -INF, idx2 = -1;
    for(int i = 0; i < sz(children[tree][u]); i++)
        if(subSDN[tree][children[tree][u][i]] > mx1)
        {
            mx2 = mx1;
            idx2 = idx1;
            mx1 = subSDN[tree][children[tree][u][i]];
            idx1 = i;
        }else if(subSDN[tree][children[tree][u][i]] > mx2)
        {
            mx2 = subSDN[tree][children[tree][u][i]];
            idx2 = i;
        }
    
    pSDN = max(pSDN, S[tree][u]);
    for(int i = 0; i < sz(children[tree][u]); i++)
        if(i != idx1) compSDN(tree, children[tree][u][i], max(pSDN, mx1+N[(tree+1)%3])+N[(tree+1)%3]);
        else if(idx2 != -1) compSDN(tree, children[tree][u][i], max(pSDN, mx2+N[(tree+1)%3])+N[(tree+1)%3]);
        else compSDN(tree, children[tree][u][i], pSDN+N[(tree+1)%3]);
}

ll inside[3];
void compinside(int tree, int u)
{
    inside[tree] += (N[tree]-sz[tree][u])*sz[tree][u];
    for(int i = 0; i < sz(children[tree][u]); i++)
        compinside(tree, children[tree][u][i]);
}

int main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(NULL);
    
    for(int i = 0; i < 3; i++)
        cin >> N[i];
    
    for(int i = 0; i < 3; i++)
        for(int j = 0; j < N[i]-1; j++)
        {
            int u, v;
            cin >> u >> v;
            --u; --v;
            
            adj[i][u].push_back(v);
            adj[i][v].push_back(u);
        }
    
    for(int i = 0; i < 3; i++)
    {
        root(i, 0, -1);
        compsz(i, 0);
        compsubS(i, 0);
        compS(i, 0, 0);
        compsubSDN(i, 0);
        compSDN(i, 0, -INF);
        compinside(i, 0);
    }
    
    ll maxDist = 0;
    for(int i = 0; i < 3; i++)
        for(int j = 0; j < N[i]; j++)
        {
            ll n1 = N[(i+1)%3], n2 = N[i], n3 = N[(i+2)%3];
            ll s1 = mxS[(i+1)%3], s2 = S[i][j], s3 = mxS[(i+2)%3];
            
            ll curDist = inside[0] + inside[1] + inside[2] + n1*(n2+n3) + s1*(n2+n3) + s2*n1 + n3*(n1+n2) + s3*(n2+n1) + n3*SDN[i][j];
            maxDist = max(curDist, maxDist);
        }
    
    cout << maxDist << '\n';
    
    return 0;
}