#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <iostream>
#include <map>

using namespace std;

#define MAXN 100500

#define mp make_pair
#define fi first
#define se second

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pii;
typedef pair<ll, int>  pli;
typedef pair< int, pii > piii;
typedef multimap<ll, int> mmli;
typedef map< pii, ll > mpi;

struct tree {
    int n;
    ll  mn_const;
    ll  n1_const;
    ll  n2_const;
    ll  sx;
    ll  total;
    vi  g[MAXN];
    int sum[MAXN];
    ll  s[MAXN];
    int parent[MAXN];
    vector<piii> e;
    mmli pc[MAXN];
    mpi ans;

    void consts(ll a, ll b, ll c) {
        mn_const = a; 
        n1_const = b;
        n2_const = c;
    }
    
    void init();
    void calc_sum(int x, int from);
    int  get_sum(int x, int y);
    void make_edge_list();
    void make_steps();
    ll   get_min(int x, int from);
    void calc_s(int x, int from);
    ll   get_vertex_price(int x);    
} t[3];

ll INF;

void tree::init() {
    for(int i=0; i<n-1; ++i) {
        int x, y;
        scanf("%i %i", &x, &y);
        g[x].push_back(y);
        g[y].push_back(x);
    }
    calc_sum(1, -1);    
    parent[1] = 0;

    make_edge_list();
    make_steps();


    calc_s(1, -1);
    //for(int i=1; i<=n; ++i)  cout << "s[" << i << "] = " << s[i] << endl;

    sx = 0;
    for(int i=1; i<=n; ++i) {
        //s[i] = 0;
        //for(int j=0; j<g[i].size(); ++j) s[i] += ans[ mp(i, j) ];
        //cout << i << "  gets " << s[i] << endl;
        total += s[i];
        sx = max(sx, s[i]);
    }
    total /= 2;
}


void tree::calc_sum(int x, int from) {
    parent[x] = from;
    sum[x] = 1;
    for(int i=0; i<g[x].size(); ++i) 
        if (g[x][i] != from) {
            calc_sum(g[x][i], x);
            sum[x] += sum[ g[x][i] ];
            s[x] += s[g[x][i]] + sum[ g[x][i] ];
        }
    //printf("x=%i, parent=%i, sum=%i\n", x, parent[x], sum[x]);
}

void tree::calc_s(int x, int from) {
    for(int i=0; i<g[x].size(); ++i) {
        int y = g[x][i];
        if (y == from) continue;
        s[y] = s[x] - get_sum(x, y) + get_sum(y, x);
        calc_s(y, x);        
    }
}

int tree::get_sum(int x, int y) {
    if (parent[y] == x) return sum[y];
    return n - sum[x];
}

void tree::make_edge_list() {
    for(int i=1; i<=n; ++i) 
        for(int j=0; j<g[i].size(); ++j) {
            int y = g[i][j];
            int z = get_sum(i, y);
            //printf("edge %i %i, sum=%i\n", i, y, z);
            e.push_back( mp(z, mp(i, y) ) );
        }

    sort(e.begin(), e.end());
}

void tree::make_steps() {
    for(int i=0; i<e.size(); ++i) {
        int x = e[i].se.fi;
        int y = e[i].se.se;

        ll value;
        value = mn_const + (get_sum(y, x) - get_sum(x, y))*n2_const;

        //cout << x << " " << y << " += " << value << " get_min=" << get_min(y, x) << endl;

        value += get_min(y, x);

        pc[x].insert( mp(-value, y) );
        ans[ mp(x, y) ] = value;
    }
}

ll tree::get_min(int x, int from) {
    if (pc[x].size() == 0) return 0;
    ll res = 0;
    pli q = *pc[x].begin();
    
    if (q.se == from) {
        pc[x].erase( pc[x].begin() );
        if (pc[x].size() > 0) {
            pli w = *pc[x].begin();
            res = min(w.fi, res);
        }
        pc[x].insert( q );
    } else {
        res = min(q.fi, res);
    }

    return -res;
}

ll tree::get_vertex_price(int x) {
    if (n==1) return 0;
    ll res = s[x]*n1_const + s[x]*n2_const;
    pli q = *pc[x].begin();
    res += -q.fi;
    return res;
}

ll tryit(tree &t1, tree &t2, tree &t3) {
    ll ans = t1.total + t2.total + t3.total;
    ans += t1.n*(t2.n + t3.n) + t2.n*(t1.n + t3.n);
    ans += t1.sx*(t2.n + t3.n) + t2.sx*(t1.n + t3.n);
    
    ll tmp = INF;

    for(int i=1; i<=t3.n; ++i) {
        ll tmp2 = t3.get_vertex_price(i);
        tmp = max(tmp, tmp2);        
    }

    ans += tmp;

    return ans;
}

int main() {
  
    ll ans = 0;
    INF = 1000000000;
    INF = -INF*INF;
    scanf("%i %i %i", &t[0].n, &t[1].n, &t[2].n);
    t[0].consts( (ll)t[1].n * (ll)t[2].n, t[1].n, t[2].n);
    t[1].consts( (ll)t[0].n * (ll)t[2].n, t[0].n, t[2].n);
    t[2].consts( (ll)t[0].n * (ll)t[1].n, t[0].n, t[1].n);

    for(int i=0; i<3; ++i) t[i].init();

    ans = max(ans, tryit(t[0], t[1], t[2]) );
    ans = max(ans, tryit(t[0], t[2], t[1]) );
    ans = max(ans, tryit(t[1], t[2], t[0]) );

    cout << ans << endl;
}