#include <iostream>
#include <fstream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <ctime>
#include <string>
#include <vector>
#include <deque>
#include <queue>
#include <set>
#include <stack>
#include <map>
#include <climits>
#include <cassert>

#define FOR(i,n) for(int i=0,_n=n;i<_n;i++)
#define FORD(i,n) for(int i=n;i>=0;i--)
#define FORR(i,s,n) for(int i=s,_n=n;i<_n;i++)
#define FORRD(i,n,s) for(int i=n,_s=s;i>=_s;i--)
#define mp make_pair
#define pb push_back
#define pii pair<int,int>
#define pli pair<ll,int>
#define vi vector<int>
#define fs first
#define sec second

#define maxn 100000
using namespace std;
typedef long long ll;

int n[3];
vi tree[3][maxn];
ll S[3][maxn],sts[3][maxn],mxx[3],sum[3];


ll fsubtree(int x,int y,int t){
	sts[t][x] = 1;
	FOR(i,tree[t][x].size())
		if(tree[t][x][i] != y)
			sts[t][x] += fsubtree(tree[t][x][i],x,t);
	return sts[t][x];
}

ll fsum(int x,int y,int t){
	S[t][x] = 0LL;
	FOR(i,tree[t][x].size())
		if(tree[t][x][i] != y)
			S[t][x] += fsum(tree[t][x][i],x,t);
	return S[t][x] + sts[t][x];	
}

void fsum2(int x,int y,int t,ll up,ll upcnt){
	FOR(i,tree[t][x].size())
		if(tree[t][x][i] != y){
			ll toadd = up + S[t][x] - S[t][tree[t][x][i]] - sts[t][tree[t][x][i]];
			toadd += sts[t][x] - sts[t][tree[t][x][i]] + upcnt;
			fsum2(tree[t][x][i],x,t,toadd,upcnt + sts[t][x] - sts[t][tree[t][x][i]]);
		}
	S[t][x] += up;
	mxx[t] = max(mxx[t],S[t][x]);
	sum[t] += S[t][x];
}

ll ANS = 0LL;
/*
void funder(int x,int y,int t,int oth,ll d){
	// calc value
	ll val = n[t] * mxx[(t + 1) % 3] + n[t] * n[(t + 1) % 3] + n[(t + 1) % 3] * S[t][oth];
	val += n[t] * mxx[(t + 2) % 3] + n[t] * n[(t + 2) % 3] + n[(t + 2) % 3] * S[t][x];
	val += n[(t + 1) % 3] *  mxx[(t + 2) % 3] + n[(t + 1) % 3] * n[(t + 2) % 3] * (d + 2LL);
	val += n[(t + 2) % 3] * mxx[(t + 1) % 3];
	
	ANS = max(ANS,val);
	FOR(i,tree[t][x].size())
		if(tree[t][x][i] != y)
			funder(tree[t][x][i],x,t,oth,d + 1);
}
void fmain(int x,int y,int t){ // main pair
	funder(x,-1,t,x,0);
	FOR(i,tree[t][x].size())
		if(tree[t][x][i] != y)
			fmain(tree[t][x][i],x,t);
}
*/

pair<ll,int> mfx[3][maxn][2];
ll rmx[3][maxn];
ll fbestsub(int x,int y,int t,ll k){
	ll bscore = S[t][x] * n[(t + 2) % 3] + 2 * k;
	mfx[t][x][0] = mfx[t][x][1] = mp(bscore,x);
	FOR(i,tree[t][x].size())
		if(tree[t][x][i] != y){
			pair<ll,int> tmp = mp(fbestsub(tree[t][x][i],x,t,k),tree[t][x][i]);
			if(tmp > mfx[t][x][0]){
				swap(mfx[t][x][0],mfx[t][x][1]);
				mfx[t][x][0] = tmp;
			}
			else if(tmp > mfx[t][x][1])
				mfx[t][x][1] = tmp;
		}
	return mfx[t][x][0].fs + k;
}
void pushbestsub(int x,int y,int t,ll bst,ll k){
	FOR(i,tree[t][x].size())
		if(tree[t][x][i] != y){
			if(mfx[t][x][0].sec != tree[t][x][i])
				pushbestsub(tree[t][x][i],x,t,max(bst,mfx[t][x][0].fs) + k,k);
			else
				pushbestsub(tree[t][x][i],x,t,max(bst,mfx[t][x][1].fs) + k,k);
		}
	rmx[t][x] = max(bst,mfx[t][x][0].fs);
}
void calcAns(int x,int y,int t){
	FOR(i,tree[t][x].size())
		if(tree[t][x][i] != y)
			calcAns(tree[t][x][i],x,t);
	ll val = n[t] * mxx[(t + 1) % 3] + n[t] * n[(t + 1) % 3] + n[(t + 1) % 3] * S[t][x];
	val += n[t] * mxx[(t + 2) % 3] + n[t] * n[(t + 2) % 3];
	val += n[(t + 1) % 3] *  mxx[(t + 2) % 3];
	val += n[(t + 2) % 3] * mxx[(t + 1) % 3];
	val += rmx[t][x];
	ANS = max(ANS,val);
}	

int main(){
	FOR(i,3) cin>>n[i];
	FOR(i,3)
		FOR(j,n[i] - 1){
			int u,v;
			cin>>u>>v;
			u--;v--;
			tree[i][u].pb(v);
			tree[i][v].pb(u);
		}
	FOR(i,3){
		fsubtree(0,-1,i);
		fsum(0,-1,i);
		fsum2(0,-1,i,0,0);
	}
	
	FOR(i,3){
		ll kk = n[(i + 1) % 3] * n[(i + 2) % 3];
		fbestsub(0,-1,i,kk);
		pushbestsub(0,-1,i,-1000000000000LL,kk);
		calcAns(0,-1,i);
	}
	cout<<ANS + (sum[0] + sum[1] + sum[2]) / 2<<"\n";
	return 0;
}
