#include <bits/stdc++.h>
using namespace std;

#define int long long
#define ll long long 
#define ff(i, a, b) for(int i = a; i <= b; i++)
#define fo(i, a, b) for(int i = a; i < b; i++)
#define fod(i, a, b) for(int i = a; i >= b; i--)
#define pb push_back
#define mp make_pair
#define fi first
#define se second

const int INF = 1e9, N = 100010;
const ll INFL = 1e18;

typedef pair <int, int> ii;
typedef vector <ll> vi;
typedef vector <ii> vii;

ll ans;
struct tree {
	int n; ll S;
	vector <vi> G; vi nChild, h, d, par;
	tree() { n = 0; nChild.clear(); h.clear(); d.clear(); par.clear(); G = vector <vi> (); }
	tree(int x) { n = x; G.assign(n + 1, vi()); nChild.assign(n + 1, 0); h.assign(n + 1, 0); d.assign(n + 1, 0); par.assign(n + 1, 0); }
	bool vis[N];
	void dfs(int u) {
		vis[u] = 1; nChild[u] = 1;
		fo(i, 0, G[u].size()) {
			int v = G[u][i]; if (vis[v]) continue;
			h[v] = h[u] + 1; par[v] = u; dfs(v); nChild[u] += nChild[v]; 
			S += 1LL * nChild[v] * (n - nChild[v]);
		}
	}
	void calc(int u) {
		vis[u] = 1; 
		fo(i, 0, G[u].size()) {
			int v = G[u][i]; if (vis[v]) continue;
			d[v] = d[u] - nChild[v] + (n - nChild[v]);
			calc(v);
		}
	}
	void prep() {
		dfs(1); memset(vis, 0, sizeof vis);
		ff(i, 1, n) d[1] += h[i];
		calc(1);
	}
	void init() {
		ff(i, 1, n-1) { int u, v; cin >> u >> v; G[u].pb(v); G[v].pb(u); }
	}
} t[4];
bool vis[N];
ll f[N], g[N];
ll r;
void get(int u) {
	vis[u] = 1; 
	fo(i, 0, (int)t[2].G[u].size()) {
		int v = t[2].G[u][i]; if (vis[v]) continue;
		get(v); f[u] = max(f[u], f[v]); g[u] = max(g[u], g[v]);
	}
	ll co = 2LL * t[2].h[u] * t[1].n * t[3].n;
	int p = 0, q = 0; 
	fo(i, 0, t[2].G[u].size()) {
		int v = t[2].G[u][i]; if (v == t[2].par[u]) continue;
		if (f[p] < f[v]) p = v;
	}
	fo(i, 0, t[2].G[u].size()) {
		int v = t[2].G[u][i]; if (v == t[2].par[u] || v == p) continue;
		if (g[q] < g[v]) q = v;
	}
	r = max(r, f[p] + g[q] - co);

	int p1 = 0, q1 = 0;
	fo(i, 0, t[2].G[u].size()) {
		int v = t[2].G[u][i]; if (v == t[2].par[u]) continue;
		if (g[p1] < g[v]) p1 = v;
	}
	fo(i, 0, t[2].G[u].size()) {
		int v = t[2].G[u][i]; if (v == t[2].par[u] || v == p1) continue;
		if (f[q1] < f[v]) q1 = v;
	}
	r = max(r, g[p1] + f[q1] - co);

	r = max(r, t[2].d[u] * (t[1].n + t[3].n));
	r = max(r, t[2].d[u] * t[1].n + 1LL * t[1].n * t[3].n * t[2].h[u] + g[p1] - co);
	r = max(r, f[p] + t[2].d[u] * t[3].n + 1LL * t[1].n * t[3].n * t[2].h[u] - co);

	f[u] = max(f[u], t[2].d[u] * t[1].n + 1LL * t[1].n * t[3].n * t[2].h[u]);
	g[u] = max(g[u], t[2].d[u] * t[3].n + 1LL * t[1].n * t[3].n * t[2].h[u]);
}

void solve() {
	ll res = t[1].S + t[2].S + t[3].S + 1LL * t[1].n * t[2].n + 1LL * t[2].n * t[3].n + 2LL * t[1].n * t[3].n;
	ll mx = 0; ff(i, 1, t[1].n) mx = max(mx, t[1].d[i]); res += mx * (t[2].n + t[3].n);
	mx = 0; ff(i, 1, t[3].n) mx = max(mx, t[3].d[i]); res += mx * (t[1].n + t[2].n);
	r = 0;
	memset(vis, 0, sizeof vis); memset(f, 0LL, sizeof f); memset(g, 0, sizeof g);
	get(1);
	res += r;
	ans = max(ans, res);
}

main() {
	ios_base::sync_with_stdio(false);
	ff(i, 1, 3) { int x; cin >> x; t[i] = tree(x); }
	ff(i, 1, 3) {
		int n = t[i].n;
		t[i].init(); t[i].prep();
	}
	solve();
	swap(t[2], t[3]); solve();
	swap(t[1], t[2]); solve();
	cout << ans << endl;
}