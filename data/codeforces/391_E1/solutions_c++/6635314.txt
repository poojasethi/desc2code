#include <algorithm>
#include <iostream>
#include <sstream>
#include <cassert>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <string>
#include <vector>
#include <bitset>
#include <queue>
#include <stack>
#include <cmath>
#include <deque>
#include <ctime>
#include <list>
#include <set>
#include <map>
//zlb//

using namespace std;

typedef long long     LL;
typedef pair<int,int> pii;

double PI  = acos(-1);
double EPS = 1e-7;
int INF    = 1000000000;
int MOD    = 1000000007;
int MAXINT = 2147483647;
LL INFLL   = 1000000000000000000LL;
LL MAXLL   = 9223372036854775807LL;

#define fi            first
#define se            second
#define mp            make_pair
#define pb            push_back
#define SIZE(a)       (int)a.size()
#define MIN(a, b)     (a) = min((a), (b))
#define MAX(a, b)     (a) = max((a), (b))
#define input(in)     freopen(in,"r",stdin)
#define output(out)   freopen(out,"w",stdout)
#define RESET(a, b)   memset(a,b,sizeof(a))
#define FOR(a, b, c)  for (int (a)=(b); (a)<=(c); (a)++)
#define FORD(a, b, c) for (int (a)=(b); (a)>=(c); (a)--)
#define FORIT(a, b)   for (__typeof((b).begin()) a=(b).begin(); a!=(b).end(); a++)

int mx[8] = {-1,1,0,0,-1,-1,1,1};
int my[8] = {0,0,-1,1,-1,1,-1,1};

// ------------ //

int n[3];
int m[3];
int tot;
vector<int> adj[3][200005];
vector<int> adj3[3][200005];
vector<int> adj2[3][200005];
LL dp[3][200005][8];
map<int,pair<int,LL> > dp2[3][200005];
int sz[3][200005];
LL maxi[3];

void traverse(int id,int k,int par)
{
	sz[id][k] = 1;
	FOR(a,0,SIZE(adj[id][k])-1)
	{
		if (adj[id][k][a] == par) continue;
		adj3[id][k].pb(adj[id][k][a]);
		//cout << "id " << id << " " << k << " " << adj[id][k][a] << endl;
		traverse(id,adj[id][k][a],k);
		sz[id][k] += sz[id][adj[id][k][a]];
	}
}

void rebuild(int id,int k)
{
	int ls = k; 
	FOR(a,0,SIZE(adj3[id][k])-1)
	{
		int v = adj3[id][k][a];
		adj2[id][ls].pb(v);
		rebuild(id,v);
		adj2[id][ls].pb(++m[id]);
		ls = m[id];
	}
}

pair<int,LL> precalc(int id,int k,int par)
{
	if (dp2[id][k].count(par)) return dp2[id][k][par];
	pair<int,LL> &ret = dp2[id][k][par];
	ret.fi = 1;
	FOR(a,0,SIZE(adj[id][k])-1)
	{
		if (adj[id][k][a] == par) continue;
		ret.fi += precalc(id,adj[id][k][a],k).fi;
		ret.se += precalc(id,adj[id][k][a],k).se;
	}
	ret.se += ret.fi*(tot-ret.fi);
	return ret;
}

pair<int,LL> calc(int id,int k,int par)
{
	if (dp2[id][k].count(par)) return dp2[id][k][par];
	pair<int,LL> &ret = dp2[id][k][par];
	if (par)
	{
		pair<int,LL> tmp = calc(id,k,0);
		tmp.se -= tmp.fi*(tot-tmp.fi);
		tmp.fi -= calc(id,par,k).fi;
		tmp.se -= calc(id,par,k).se;
		tmp.se += tmp.fi*(tot-tmp.fi);
		ret = tmp;
		//ret.se += ret.se+ret.fi*(tot-ret.fi);
	}
	else
	{
		ret.fi = 1;
		FOR(a,0,SIZE(adj[id][k])-1)
		{
			if (adj[id][k][a] == par) continue;
			ret.fi += calc(id,adj[id][k][a],k).fi;
			ret.se += calc(id,adj[id][k][a],k).se;
		}
		ret.se += ret.fi*(tot-ret.fi);
	}
	//cout << id << " " << k << " " << par << " " << ret.fi << " " << ret.se << endl;
	return ret;
}

LL go(int id,int k,int mask)
{
	if (dp[id][k][mask] != -1) return dp[id][k][mask];
	LL &ret = dp[id][k][mask];
	int sze = sz[id][k];
	FOR(a,0,2)
	{
		if (mask & (1 << a)) sze += n[a];
	}
	ret = 0;
	if (n[id] >= k) ret = (LL)sze*(LL)(tot-sze);
	vector<int> child;
	FOR(a,0,SIZE(adj2[id][k])-1)
	{
		child.pb(adj2[id][k][a]);
	}

	if (SIZE(child) == 0)
	{
		FOR(a,0,2)
		{
			if (mask & (1 << a)) ret += maxi[a];
		}
	}
	if (SIZE(child) == 1)
	{
		LL maks = 0;
		FOR(mask2,0,(1 << 3)-1)
		{
			if ((mask2&mask) == mask2)
			{
				int mask3 = mask^mask2;
				LL cur = 0;
				FOR(a,0,2)
				{
					if (mask2 & (1 << a)) cur += maxi[a];
				}
				//if (id == 0 && k == 1) cout << "YAYYYY " << mask << " " << mask2 << " " << mask3 << " " << mask4 << " " << cur+go(id,adj2[id][k][0],mask3)+go(id,adj2[id][k][1],mask4) << endl;
				MAX(maks,cur+go(id,child[0],mask3));
			}
		}
		ret += maks;
	}
	if (SIZE(child) == 2)
	{
		LL maks = 0;
		FOR(mask2,0,(1 << 3)-1)
		{
			if ((mask2&mask) == mask2)
			{
				int res = mask^mask2;
				FOR(mask3,0,(1 << 3)-1)
				{
					if ((mask3&res) == mask3)
					{
						int mask4 = res^mask3;
						LL cur = 0;
						FOR(a,0,2)
						{
							if (mask2 & (1 << a)) cur += maxi[a];
						}
						//if (id == 0 && k == 1) cout << "YAYYYY " << mask << " " << mask2 << " " << mask3 << " " << mask4 << " " << cur+go(id,adj2[id][k][0],mask3)+go(id,adj2[id][k][1],mask4) << endl;
						MAX(maks,cur+go(id,child[0],mask3)+go(id,child[1],mask4));
					}
				}
			}
		}
		ret += maks;
	}
	//cout << "yaw " << id << " " << k << " " << mask << " -> " << ret << endl;
	return ret;
}

int val[3][200005];

pii cl(int id,int u)
{
	//cout << id << " " << u << endl;
	pii lol = mp(val[id][u],0);
	FOR(a,0,SIZE(adj3[id][u])-1)
	{
		pii tmp = cl(id,adj3[id][u][a]);
		lol.fi += tmp.fi;
		lol.se += tmp.se;
	}
	lol.se += (lol.fi)*(tot-lol.fi);
	return lol;
}

int main()
{
	FOR(a,0,2) scanf("%d",&n[a]);
	tot = n[0]+n[1]+n[2];
	m[0] = n[0];
	m[1] = n[1];
	m[2] = n[2];
	FOR(a,0,2)
	{
		FOR(b,1,n[a]-1)
		{
			int u,v;
			scanf("%d%d",&u,&v);
			adj[a][u].pb(v);
			adj[a][v].pb(u);
		}
	}
	int root = 1;
	FOR(a,0,2)
	{
		traverse(a,root,0);
		rebuild(a,root);
		precalc(a,1,0);
		FOR(b,1,n[a])
		{
			MAX(maxi[a],calc(a,b,0).se);
		}
		//cout << "YO " << a << " " << maxi[a] << endl;
	}
	//return 0;
	RESET(dp,-1);
	LL maks = 0;
	FOR(a,0,2)
	{
		MAX(maks,go(a,1,7^(1 << a)));
	}
	cout << maks << endl;
}
