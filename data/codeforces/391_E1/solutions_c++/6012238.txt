//Done by Mycroft Grey
//Fet per Ferran Alet

#include<iostream>
#include<cmath>
#include<iomanip>
#include<vector>
#include<map>
#include<queue>
#include<fstream>
#include<algorithm>
#include<string>
#include<stack>
#include<numeric>
#include<set>
#include<sstream>
#include<list>

#define INF 2147483647
#define LINF 1000000000000000000LL
#define EPS 1e-9
#define debug(x)// cerr << #x << " = " << x << endl
#define Debug(v) //cerr << #v << " = "; for(ll wow=0;wow<v.size();++wow) cerr<<v[wow]<<' '; cerr<<endl
#define FOR(x,y) for(ll x=0;x<y;x++)
#define FORU(x,y) for(ll x=1;x<=y;x++)
#define RFOR(x,y) for(ll x=y-1;x>=0;--x)
using namespace std;


typedef long long ll;
typedef pair<ll,ll> PII;
typedef vector<ll> VI;
typedef vector<VI> VVI;
typedef vector<double> VD;
typedef vector<VD> VVD;
typedef vector<bool> VB;
typedef vector<VB> VVB;
typedef vector<string> VS;
typedef map<ll,ll> MII;
typedef MII::iterator iMII;
typedef vector<PII > VP;

void fem_una_cosa(VVI &v, VVI &A){
  ll n=v.size();
  A = VVI (n, VI(n,2*n));
  FOR(i,n){
    queue<ll> q;
    (n,2*n);
    A[i][i]=0;
    q.push(i);
    while(!q.empty()){
      ll p=q.front();
      ll t=A[i][p]+1;
      q.pop();
      FOR(j,v[p].size()){
        if(t<A[i][v[p][j]]){
          A[i][v[p][j]]=t;
          q.push(v[p][j]);
        }
      }
    }
  }
}

int main(){
//   ios_base::sync_with_stdio(false);
  ios_base::sync_with_stdio(false);
   ll a,b,c;
  cin>>a>>b>>c;
    VVI v(a);
    ll x,y;
    FOR(i,a-1){
      cin>>x>>y;
      --x; --y;
      v[x].push_back(y);
      v[y].push_back(x);
    }
    VVI A;
    fem_una_cosa(v,A);
    
    v=VVI (b);
    FOR(i,b-1){
      cin>>x>>y;
      --x; --y;
      v[x].push_back(y);
      v[y].push_back(x);
    }
    VVI B;
    fem_una_cosa(v,B);
    
    v=VVI (c);
    FOR(i,c-1){
      cin>>x>>y;
      --x; --y;
      v[x].push_back(y);
      v[y].push_back(x);
    }
    VVI C;
    fem_una_cosa(v,C);
  //  cerr<<"llernal"<<endl;
    ll res=0;
    FOR(i,a){
      for(ll j=i+1;j<a;++j) res+=A[i][j]; 
    }
    FOR(i,b){
      for(ll j=i+1;j<b;++j) res+=B[i][j]; 
    }
    FOR(i,c){
      for(ll j=i+1;j<c;++j) res+=C[i][j]; 
    }
    //Worst root
    ll ra,rb,rc,worst,wa,wb,wc;
    VI SA(a),SB(b),SC(c);
    ra=0;
    worst=0;
    FOR(i,a) worst+=A[0][i];
    FOR(i,a){
      ll act=0;
      FOR(j,a) act+=A[i][j];
      SA[i]=act;
      if(worst<act){
        ra=i;
        worst=act;
      }
    }
    wa=worst;
    rb=0;
    worst=0;
    FOR(i,b) worst+=B[0][i];
    FOR(i,b){
      ll act=0;
      FOR(j,b) act+=B[i][j];
      SB[i]=act;
      if(worst<act){
        rb=i;
        worst=act;
      }
    }
    wb=worst;
    rc=0;
    worst=0;
    FOR(i,c) worst+=C[0][i];
    FOR(i,c){
      ll act=0;
      FOR(j,c) act+=C[i][j];
      SC[i]=act;
      if(worst<act){
        rc=i;
        worst=act;
      }
    }
    wc=worst;
    ll best=0;
    //A al mig
    FOR(i,a){
      FOR(j,a){
        ll act=0;
        act+=a*b+a*wb+b*SA[i]; //B->A
        act+=c*a+a*wc+c*SA[j]; //C->A
        act+=b*wc+c*wb+b*c*(2+A[i][j]);//B->C
      //  cerr<<i<<' '<<j<<' '<<act<<endl;
        best=max(best,act);
      }
    }
    debug(best);
    //B al mig
    FOR(i,b){
      FOR(j,b){
        ll act=0;
        act+=a*b+b*wa+a*SB[i]; //A->B
        act+=c*b+b*wc+c*SB[j]; //C->B
        act+=a*wc+c*wa+a*c*(2+B[i][j]);//A->C
        best=max(best,act);
       // cerr<<i<<' '<<j<<' '<<act<<endl;
      }
    }
    debug(best);
    //C al mig
    FOR(i,c){
      FOR(j,c){
        ll act=0;
        act+=a*c+c*wa+a*SC[i]; //A->C
        act+=c*b+c*wb+b*SC[j]; //B->C
        act+=b*wa+a*wb+a*b*(2+C[i][j]);//A->B
        best=max(best,act);
//        cerr<<i<<' '<<j<<' '<<act<<endl;
      }
    }
    Debug(SA);
    Debug(SB);
    Debug(SC);
    debug(best);
    debug(res);
    debug(wa);
    debug(wb);
    debug(wc);
    cout<<res+best<<endl;
    //system("pause");
}
