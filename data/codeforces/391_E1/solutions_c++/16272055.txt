#include <bits/stdc++.h>
using namespace std;

#define st first
#define nd second
#define mp make_pair
#define space << " " <<
#define END << endl
#define pb push_back
#define fo(i,n) for(int i = 0; i<n; ++i)
#define ff(i,n) for(int i = 1; i<n; ++i)
#define int long long

typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<int,pii> pi;
typedef long long ll;
typedef pair<int,ll> pil;
typedef pair<ll,int> pli;
typedef pair<ll,ll> pll;
typedef pair<ll,pll> pl;
typedef vector<pil>vil;

const int N = 1e5 + 1000;

vector<int> b1[N] , b2[N] , b3[N];

struct tree{
    int n;
    vi board[N];
    int pa[N];
    int h[N];
    ll sum[N];
    pair<pli,pli> su1[N];
    pair<pli,pli> su2[N];
    ll S = 0;
    ll ans = 0;
    ll mx = 0;
    int child[N];
    int u,v;
    void lu(int uu, int vv) { u = uu; v = vv; if(u < v) swap(u,v); }
    void dfs1(int U, int parent)
    {
        ll ans = 0;
        pa[U] = parent;
        child[U] = 0;
        h[U] =h[parent] + 1;
        for(int x=0; x<board[U].size(); ++x)
        {
            int V = board[U][x];
            if(V == parent) continue;
            dfs1(V,U);
            child[U] += child[V] + 1;
            ans += sum[V];
        }
        ans += 1LL * child[U];
        sum[U] = ans;
    }
    void dfs2(int U, int parent)
    {
        //cout << U space sum[U] space child[U] << endl;
        if(U != 1) sum[U] = sum[U] + 1LL * ( n - child[U] - 1) + sum[parent] - sum[U] - 1LL * (child[U] + 1);
        S += sum[U];
        //cout << U space sum[U] << endl;
        mx = max(mx,sum[U]);
        for(int x=0; x<board[U].size(); ++x)
        {
            int V = board[U][x];
            if(V == parent) continue;
            dfs2(V,U);
        }
    }
    void dfs3(int U,int parent)
    {
        bool oo = 0;
        su1[U].st.st = sum[U] * u  + 1LL * u * v * h[U]; su1[U].st.nd = U;
        su1[U].nd.st = 0;
        su2[U].st.st = sum[U] * v  + 1LL * u * v * h[U]; su2[U].st.nd = U;
        su2[U].nd.st = 0;
        ans = max( ans , su1[U].st.st + su2[U].st.st - 2LL * u * v * h[U]);
        for(int x=0; x<board[U].size(); ++x)
        {
            int V = board[U][x];
            if(V == parent) continue;
            dfs3(V,U); oo = 1;
            if(su1[U].st.st < su1[V].st.st) { su1[U].nd = su1[U].st; su1[U].st = su1[V].st; }
            else if( su1[U].nd.st < su1[V].st.st ) { su1[U].nd = su1[V].st; }
            if(su2[U].st.st < su2[V].st.st) { su2[U].nd = su2[U].st; su2[U].st = su2[V].st; }
            else if( su2[U].nd.st < su2[V].st.st ) { su2[U].nd = su2[V].st; }
        }
        //if(oo) cout << su1[U].st.st space su1[U].st.nd space su1[U].nd.st space su1[U].nd.nd << endl;
        ans = max(ans ,max(su1[U].st.st + su2[U].nd.st - 2LL * u * v * h[U],su1[U].nd.st + su2[U].st.st - 2LL * u * v * h[U]));
        if(su1[U].st.nd != su2[U].st.nd) ans = max(ans ,su1[U].st.st + su2[U].st.st - 2LL * u * v * h[U]);
        if(su1[U].nd.nd != su2[U].nd.nd) ans = max(ans ,su1[U].nd.st + su2[U].nd.st - 2LL * u * v * h[U]);
    }
    void work1() {
        dfs1(1,1); dfs2(1,1); S /= 2;
    }
    ll work2() {
        dfs3(1,1);// cout << ans space "thanhdz" << endl;
         return ans;
    }

}a[4];

long long ans = 0;
main()
{
    //freopen("test.txt","r",stdin);
    ios_base::sync_with_stdio(false); cin.tie(0);
    ff(i,4) cin >> a[i].n;
    ff(i,4) ff(j,a[i].n) { int u,v; cin >> u >> v; a[i].board[u].pb(v); a[i].board[v].pb(u); }
    a[1].lu(a[2].n,a[3].n);
    a[2].lu(a[1].n,a[3].n);
    a[3].lu(a[2].n,a[1].n);
    ff(i,4) { a[i].work1(); }
    //a[1].work1();
    ll ans = 0;
    //cout << a[1].S space a[2].S space a[3].S space a[1].mx space a[2].mx space a[3].mx << endl;
    ans = max(ans,a[1].work2() + a[1].S + a[2].S + a[3].S + 2LL * a[1].u * a[1].v + 1LL * a[1].u * a[1].n + 1LL * a[1].v * a[1].n + 1LL * a[2].mx * (a[1].n+a[3].n) + 1LL * a[3].mx * (a[1].n + a[2].n));
    //cout << ans << endl;
    ans = max(ans,a[2].work2() + a[1].S + a[2].S + a[3].S + 2LL * a[2].u * a[2].v + 1LL * a[2].u * a[2].n + 1LL * a[2].v * a[2].n + 1LL * a[1].mx * (a[2].n+a[3].n) + 1LL * a[3].mx * (a[1].n + a[2].n));
    //cout << ans << endl;
    ans = max(ans,a[3].work2() + a[1].S + a[2].S + a[3].S + 2LL * a[3].u * a[3].v + 1LL * a[3].u * a[3].n + 1LL * a[3].v * a[3].n + 1LL * a[1].mx * (a[2].n+a[3].n) + 1LL * a[2].mx * (a[1].n + a[3].n));
    cout << ans << endl;
}
