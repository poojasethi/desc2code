#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std;
struct pt{double x,y;} w1,w2,m1,m2,p,v,p_,m;
double eps=1e-8;
pt operator +(pt a,pt b){return (pt){a.x+b.x,a.y+b.y};}
pt operator -(pt a,pt b){return (pt){a.x-b.x,a.y-b.y};}
double sqr(double a){return a*a;}
double XJ(pt a,pt b,pt c){
	return (b.x-a.x)*(c.y-a.y)-(c.x-a.x)*(b.y-a.y);
}
double dist(pt a,pt b){
	return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));
}
bool line(pt a,pt b,pt c){
	return fabs(dist(a,c)+dist(b,c)-dist(a,b))<eps;
}
pt inter(pt a,pt b,pt c,pt d){
	double t1=XJ(a,c,b),t2=XJ(a,b,d);
	return (pt){(c.x*t2+d.x*t1)/(t1+t2),(c.y*t2+d.y*t1)/(t1+t2)};
}
bool cross(pt a,pt b,pt c,pt d,int k){
	if(!k&&line(a,b,c)&&line(a,b,d)) return 0;
	if(line(a,b,c)||line(a,b,d)||line(c,d,a)||line(c,d,b)) return 1;
	return XJ(a,c,b)*XJ(a,b,d)>eps&&XJ(c,a,d)*XJ(c,d,b)>eps;
}
pt turn(pt a,double th){
	return (pt){a.x*cos(th)-a.y*sin(th),a.x*sin(th)+a.y*cos(th)};
}
pt oppo(pt c,pt a,pt b){
	pt h=inter(a,b,c,c+turn(b-a,acos(-1.0)/2));
	return h+(h-c);
}
int main(){
    //freopen("AC.in","r",stdin);
    //freopen("AC.out","w",stdout);
	cin>>v.x>>v.y>>p.x>>p.y>>w1.x>>w1.y>>w2.x>>w2.y>>m1.x>>m1.y>>m2.x>>m2.y;
	if(!cross(v,p,w1,w2,1)&&!cross(v,p,m1,m2,0))return puts("YES"),0;
	p_=oppo(p,m1,m2);
	if(cross(v,p_,m1,m2,0)){
		m=inter(v,p_,m1,m2);
		if(!cross(p,m,w1,w2,1)&&!cross(m,v,w1,w2,1))return puts("YES"),0;
	}
	return puts("NO"),0;
}
