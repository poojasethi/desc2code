#include<cstdio>
#include<cmath>
#include<algorithm>
#define eps 1e-9
using namespace std;
struct node
{
	double x,y;
}V,P,V0,P0;
struct segment
{
	double x1,y1,x2,y2;
}mir,wal;
struct line
{
	double k,b;
};
inline segment makeseg(node x,node y)
{
	return (segment){x.x,x.y,y.x,y.y};
}
inline line makeline(segment x)
{
	line t;
	t.k=(x.y1-x.y2)/(x.x1-x.x2);
	t.b=x.y1-t.k*x.x1;
	return t;
}
inline node makenode(line x,line y)
{
	node t;
	t.x=(y.b-x.b)/(x.k-y.k);
	t.y=x.k*t.x+x.b;
	return t;
}
inline bool on(node x,line y)
{
	return fabs(y.k*x.x+y.b-x.y)<eps;
}
inline double cross(double x1,double y1,double x2,double y2)
{
	return x1*y2-x2*y1;
}
inline bool cross(segment x,segment y)
{
	double t1=cross(y.x1-x.x1,y.y1-x.y1,x.x2-x.x1,x.y2-x.y1);
	double t2=cross(y.x2-x.x1,y.y2-x.y1,x.x2-x.x1,x.y2-x.y1);
	if(fabs(t1)<eps&&fabs(t2)<eps)
	{
		if(fabs(x.x1-x.x2)<eps)
			return x.y1+eps>=min(y.y1,y.y2)&&x.y1-eps<=max(y.y1,y.y2)||
				   y.y1+eps>=min(x.y1,x.y2)&&y.y1-eps<=max(x.y1,x.y2);
		else
			return x.x1+eps>=min(y.x1,y.x2)&&x.x1-eps<=max(y.x1,y.x2)||
				   y.x1+eps>=min(x.x1,x.x2)&&y.x1-eps<=max(x.x1,x.x2);
	}
	if(fabs(t1)>eps&&fabs(t2)>eps&&t1*t2>0)
		return 0;
	t1=cross(x.x1-y.x1,x.y1-y.y1,y.x2-y.x1,y.y2-y.y1);
	t2=cross(x.x2-y.x1,x.y2-y.y1,y.x2-y.x1,y.y2-y.y1);
	if(fabs(t1)>eps&&fabs(t2)>eps&&t1*t2>0)
		return 0;
	return 1;
}
inline node work(node x,segment y)
{
	if(fabs(y.x1-y.x2)<eps)
		return (node){2*y.x1-x.x,x.y};
	if(fabs(y.y1-y.y2)<eps)
		return (node){x.x,2*y.y1-x.y};
	line t1=makeline(y);
	if(on(x,t1))
		return x;
	line t2=(line){-1.0/t1.k,1.0/t1.k*x.x+x.y};
	node t=makenode(t1,t2);
	return (node){t.x*2-x.x,t.y*2-x.y};
}
int main()
{
	int i,j;
	scanf("%lf%lf%lf%lf",&V.x,&V.y,&P.x,&P.y);
	scanf("%lf%lf%lf%lf",&wal.x1,&wal.y1,&wal.x2,&wal.y2);
	scanf("%lf%lf%lf%lf",&mir.x1,&mir.y1,&mir.x2,&mir.y2);
	if(!cross(makeseg(V,P),mir)&&!cross(makeseg(V,P),wal))
	{
		puts("YES");
		return 0;
	}
	P0=work(P,mir);
	if((fabs(V.x-P0.x)>eps||fabs(V.y-P0.y)>eps)&&cross(makeseg(V,P0),mir)&&!cross(makeseg(V,P0),wal))
	{
		V0=work(V,mir);
		if((fabs(P.x-V0.x)>eps||fabs(P.y-V0.y)>eps)&&cross(makeseg(P,V0),mir)&&!cross(makeseg(P,V0),wal))
		{
			puts("YES");
			return 0;
		}
	}
	puts("NO");
	return 0;
}