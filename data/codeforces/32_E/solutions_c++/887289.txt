#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;

typedef double PTYPE;

class Point {
	public:
		PTYPE x, y;
		Point(PTYPE _x=0, PTYPE _y=0){x=_x;y=_y;}
		PTYPE operator^(const Point &p) {return x*p.y-y*p.x;}
		PTYPE operator*(const Point &p) {return x*p.x+y*p.y;}
		Point operator*(PTYPE k) { return Point(x*k, y*k); }
		Point operator+(const Point &p) { return Point(x+p.x, y+p.y);}
		Point rotate90() {return Point(-y, x);}
		Point operator-(const Point &p) {return Point(x-p.x, y-p.y);}
		Point mirror(Point A, Point B) {
			return *this + (B-A).rotate90()*(2.*((B-*this)^(A-*this))/((B-A).len2()));
		}
		void read() { scanf("%lf%lf", &x, &y); }
		PTYPE len2() { return x*x+y*y; }
};

inline int sgn(PTYPE x) { return x<0?-1:x>0?1:0;}

PTYPE cross(Point A, Point B) {
	return A^B;
}
const double eps = 1e-12;
bool online(Point A, Point B, Point P) {
	return (fabs(cross(A-P,B-P))<eps && (P-A)*(P-B)<=0);
}

bool intersect(Point A, Point B, Point C, Point D) {

	if(fabs(cross(D-A,C-A))<eps && fabs(cross(D-B,C-B))<eps) {
		return online(A,B,C) || online(A,B,D) || online(C,D,A) || online(C,D,B);
	}

	if(fabs(cross(D-A,C-A))<eps) return (A-D)*(A-C)<=0;
	if(fabs(cross(D-B,C-B))<eps) return (B-D)*(B-C)<=0;
	if(fabs(cross(A-C,B-C))<eps) return (C-A)*(C-B)<=0;
	if(fabs(cross(A-D,B-D))<eps) return (D-A)*(D-B)<=0;
	
	return
		sgn(cross(D-A,C-A))!=sgn(cross(D-B,C-B)) &&
		sgn(cross(A-C,B-C))!=sgn(cross(A-D,B-D));
}

Point icc(Point A, Point B, Point C, Point D) {
	double f1 = cross(A-C, B-C);
	double f2 = cross(B-D, A-D);
	return C + (D-C) * (f1/(f1+f2));
}

int main(void) {
	Point V, P, w1, w2, m1, m2;
	V.read(); P.read(); w1.read(); w2.read(); m1.read(); m2.read();
	if(online(V,P,m1) && online(V,P,m2)) {
		if(online(V,P,w1) || online(V,P,w2)) { puts("NO"); }
		else puts("YES");
		return 0;
	}
	//printf("HERE!\n");
	if(!intersect(V,P,w1,w2) && !intersect(V,P,m1,m2)) {
		//printf("HEE!!!");
		puts("YES"); return 0;
	}
	if(fabs(cross(P-m1, m1-m2))<eps) {
		puts("NO"); return 0;
	}
	Point MP = P.mirror(m1, m2);
	Point Mw1 = w1.mirror(m1, m2);
	Point Mw2 = w2.mirror(m1, m2);
//	printf("(%lf %lf\n", MP.x, MP.y);
	if(intersect(V,MP,m1,m2)) {
		Point CP = icc(V,MP,m1,m2);
		if(!intersect(V,CP,w1,w2) && !intersect(CP,MP,Mw1,Mw2) && !intersect(CP,P,w1,w2)) {
			puts("YES"); return 0;
		}
	}
	puts("NO");
	return 0;
}
