// In the name of God

#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstring>
#include <string>
#include <set>
#include <map>
#include <complex>
#include <cmath>
#include <fstream>
#include <iomanip>
#include <deque>
#define pf push_front
#define pb push_back
#define x real()
#define y imag()

using namespace std;

typedef long long ll;
typedef double ld;
typedef complex<ld> point;
typedef pair<ll,ll> pii;
typedef pair<pii,int> ppii;

point v,p;
point m[2],w[2];

inline bool meet(point p1,point p2,point q1,point q2,bool w)
{
  p2 -= p1 , q1 -= p1 , q2 -= p1;
  q1 /= p2 , q2 /= p2;
  
  if(q1.y > q2.y)
    swap(q1,q2);
  
  if(q1.y > 0.0 || q2.y < 0.0)
    return false;

  if(q1.y == q2.y && q1.y == 0.0){
    if(w == 0)
      return false;
    else if( (q1.x >= 0.0 && q1.x <= 1.0) || (q2.x >= 0.0 && q2.x <= 1.0) )
      return true;
    else
      return false;
  }

  ld X = ( (q2.y) * (q1.x - q2.x) ) / (q2.y - q1.y) + q2.x;

  if(X >= 0.0 && X <= 1.0)
    return true;
  return false;
}

inline void bad()
{
  cout << "NO" << endl;
  exit(0);
}

inline void good()
{
  cout << "YES" << endl;
  exit(0);
}

inline void solve()
{
  v -= m[0] ,  p -= m[0] , w[0] -= m[0] , w[1] -= m[0] , m[1] -= m[0];
  v /= m[1] ,  p /= m[1] , w[0] /= m[1] , w[1] /= m[1];

  if( (v.y >= 0 && p.y <= 0) || (v.y <= 0 && p.y >= 0) )
    bad();

  ld X = (v.x*p.y+v.y*p.x) / (v.y + p.y);

  if(X >= 0.0 && X <= 1.0)
    if(!meet(point(X,0),v,w[0],w[1],1) && !meet(point(X,0),p,w[0],w[1],1) )
      good();
  bad();
}

int main()
{
  ios_base::sync_with_stdio(false);

  cin >> v.x >> v.y >> p.x >> p.y;
  for(int i=0;i<2;++i)
    cin >> w[i].x >> w[i].y;
  for(int i=0;i<2;++i)
    cin >> m[i].x >> m[i].y;

  if(!meet(v,p,w[0],w[1],1) && !meet(v,p,m[0],m[1],0) )
    good();
  else
    solve();

  return 0;
}
