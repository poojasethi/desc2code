#include <cstdio>
#include <algorithm>
#include <cstdlib>

#define good(u) (vis[u][0] && vis[u][1])

using namespace std;

const int N = 1010, M = 5050;
const int INF = 1e9;

int n, m, d[N], vis[N][2];

struct edge
{
	int to, nx;
} ee[M * 2];
int eq[N], en = 1;

void link(int u, int v)
{
	ee[++en] = (edge) {v, eq[u]}, eq[u] = en;
}
void dfs(int u, int ty)
{
	vis[u][ty] = 1;
	for (int j = eq[u], v; v = ee[j].to, j; j = ee[j].nx)
		if ((j & 1) == ty && !vis[v][ty])
		{
			dfs(v, ty);
		}
}
bool relax(int &a, int b)
{
	if (b < INF - 1 && b < a) return a = b, 1;
	return 0;
}
void fail()
{
	puts("No");
	exit(0);
}
int main()
{
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= m; ++i)
	{
		int u, v;
		scanf("%d %d", &u, &v);
		link(u, v), link(v, u);
	}
	dfs(1, 0);
	dfs(n, 1);
	for (int i = 1; i <= n; ++i)
		d[i] = i == 1 ? 0 : INF;
	for (int i = 1; i <= n + 1; ++i)
		for (int e = 2; e <= en; e += 2)
		{
			int u = ee[e ^ 1].to, v = ee[e].to;
			if (good(u) && good(v))
			{
				relax(d[v], d[u] + 2);
				relax(d[u], d[v] - 1);
			}
		}
	for (int e = 2; e <= en; e += 2)
	{
		int u = ee[e ^ 1].to, v = ee[e].to;
		if (good(u) && good(v))
		{
			if (relax(d[v], d[u] + 2)) fail();
			if (relax(d[u], d[v] - 1)) fail();
		}
	}
	puts("Yes");
	for (int e = 2; e <= en; e += 2)
	{
		int u = ee[e ^ 1].to, v = ee[e].to;
		if (good(u) && good(v))
			printf("%d\n", d[v] - d[u]);
		else
			printf("1\n");
	}
}
