#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<iostream>
#include<vector>

#define pb push_back
#define mp make_pair
#define ft first
#define sc second

using namespace std;
typedef pair< long long,long long > pll;

vector< pll > g[4];
int st[4],mid[4];

void out(pll a)
{
    printf("(%I64d,%I64d)\n",a.ft,a.sc);
}

pll operator +(pll a,pll b)
{
    return mp(a.ft+b.ft,a.sc+b.sc);
}

pll operator -(pll a,pll b)
{
    return mp(a.ft-b.ft,a.sc-b.sc);
}

long long cross(pll a,pll b)
{
    return a.ft*b.sc-a.sc*b.ft;
}

int cal_next(int idx,int pos)
{
    return (pos+1)%g[idx].size();
}

int cal_st(int idx)
{
    st[idx]=0;
    for(int i=0;i<g[idx].size();i++)
        if(g[idx][i]<g[idx][st[idx]])
            st[idx]=i;
    return st[idx];
}
int cal_mid(int idx)
{
    mid[idx]=0;
    for(int i=0;i<g[idx].size();i++)
        if(g[idx][i]>g[idx][mid[idx]])
            mid[idx]=i;
    return mid[idx];
}

void make()
{
    pll now,next;
    int idx,pos[3];
    for(int i=0;i<3;i++)
        pos[i]=cal_st(i);
    g[3].clear();
    now=mp(0,0);
    for(int i=0;i<3;i++)
        now=now+g[i][pos[i]];
    g[3].pb(now);
    while(1){
        idx=0;
        now=g[0][cal_next(0,pos[0])]-g[0][pos[0]];
        for(int i=1;i<3;i++){
            next=g[i][cal_next(i,pos[i])]-g[i][pos[i]];
            if(cross(next,now)>0){
                idx=i;
                now=next;
            }
        }
        pos[idx]=cal_next(idx,pos[idx]);
        now=mp(0,0);
        for(int i=0;i<3;i++)
            now=now+g[i][pos[i]];
        if(now==g[3][0])
            break;
        if(now.ft==g[3][0].ft&&now.sc==g[3][0].sc)
            break;
        g[3].pb(now);
    }
    st[3]=cal_st(3);
    mid[3]=cal_mid(3);
}       

int bs(pll a,int st3,int n,bool flag)
{
    int mmid,l=0,r=n-1;
    while(l<r){
        mmid=(l+r)/2;
        if(!flag){
            if(g[3][(st3+mmid+1)%g[3].size()]<=a)
                l=mmid+1;
            else
                r=mmid;
        }
        else{
            if(g[3][(st3+mmid+1)%g[3].size()]>=a)
                l=mmid+1;
            else
                r=mmid;
        }
    }
    return (st3+l+g[3].size())%g[3].size();
}
bool judge(pll a)
{
    if(a.ft<g[3][st[3]].ft||a.ft>g[3][mid[3]].ft)
        return false;
    int idx;
    if(st[3]<mid[3])
        idx=bs(a,st[3],mid[3]-st[3],0);
    else
        idx=bs(a,st[3],mid[3]+g[3].size()-st[3],0);
    if(cross(g[3][cal_next(3,idx)]-g[3][idx],a-g[3][idx])<0)
        return false;
    
    if(st[3]<mid[3])
        idx=bs(a,mid[3],st[3]+g[3].size()-mid[3],1);
    else
        idx=bs(a,mid[3],st[3],1);
    if(cross(g[3][cal_next(3,idx)]-g[3][idx],a-g[3][idx])<0)
        return false;
    
    return true;
}
int main()
{
    //freopen("b.txt","r",stdin);
    int q,n,x,y;
    for(int i=0;i<3;i++){
        g[i].clear();
        scanf("%d",&n);
        for(int j=0;j<n;j++){
            scanf("%d%d",&x,&y);
            g[i].pb(mp(x,y));
        }
    }
    make();
    scanf("%d",&q);
    while(q--){
        scanf("%d%d",&x,&y);
        x*=3;
        y*=3;
        if(judge(mp(x,y)))
            puts("YES");
        else
            puts("NO");
    }
    //while(1);
    return 0;
}

 	        						 	 		  	