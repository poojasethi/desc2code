#include <cstdio>
#include <algorithm>
#include <map>
#include <numeric>
#include <set>
#include <string>
#include <vector>
using namespace std;

#define REP(i, n) for (int i = 0, _n = (n); i < _n; ++i)
#define FOR(i, a, b) for (int i = (a), _n = (b); i <= _n; ++i)
#define FORD(i, a, b) for (int i = (a), _n = (b); i >= _n; --i)
#define FORE(it, c) for(__typeof((c).begin()) it = (c).begin(); it != (c).end(); ++it)
#define ALL(c) (c).begin(), (c).end()
#define PB push_back
#define MP make_pair
#define FI first
#define SE second

typedef long long LL;
typedef pair<int,int> PII;
typedef vector<int> VI;

const int INF = 1000000000;

const int NMAX = 50000;

struct point {
	int x, y;
	point() { }
	point(int x, int y): x(x), y(y) { }
	point& operator +=(const point& rhs) {
		x += rhs.x;
		y += rhs.y;
		return *this;
	}
	point& operator *=(int t) {
		x *= t;
		y *= t;
		return *this;
	}
};
inline point operator +(const point& p1, const point& p2) {
	return point(p1.x+p2.x, p1.y+p2.y);
}
inline point operator -(const point& p1, const point& p2) {
	return point(p1.x-p2.x, p1.y-p2.y);
}
inline LL cross(const point& p1, const point& p2) {
	return 1LL*p1.x*p2.y - 1LL*p1.y*p2.x;
}
inline LL cross(const point& p0, const point& p1, const point& p2) {
	return cross(p1-p0, p2-p0);
}
enum { LEFT, RIGHT, STRAIGHT };
inline int ccw(const point& p0, const point& p1, const point& p2) {
	LL res = cross(p0, p1, p2);
	return res > 0 ? LEFT : (res < 0 ? RIGHT : STRAIGHT);
}
inline bool operator <(const point& p1, const point& p2) {
	bool small1 = p1.y > 0 || (p1.y == 0 && p1.x > 0),
		small2 = p2.y > 0 || (p2.y == 0 && p2.x > 0);
	if (small1 != small2) return small1;
	return cross(p1, p2) > 0;
}

int NS;
point sides[3*NMAX], T[3*NMAX];

bool in_polygon(const point& P) {
//printf("in_polygon(%d, %d)\n", P.x, P.y);
	int left = 1, right = NS-1;
	if (ccw(T[0], T[1], P) == RIGHT || ccw(T[0], T[NS-1], P) == LEFT)
		return false;
	while (left+1 < right) {
		int mid = (left+right)/2;
		if (ccw(T[0], T[mid], P) == LEFT)
			left = mid;
		else right = mid;
	}
//printf("left=%d right=%d, T[left]=(%d, %d), T[right]=(%d, %d), P=(%d, %d)\n", left, right, T[left].x, T[left].y, T[right].x, T[right].y, P.x, P.y);
	return ccw(T[left], T[right], P) != RIGHT;
}

int main() {
	point pmin(0, 0);
	REP(i, 3) {
		int N;
		point p0, pcurmin, pcur, pnext;
		scanf("%d%d%d", &N, &p0.x, &p0.y);
		pcurmin = pcur = p0;
		REP(j, N-1) {
			scanf("%d%d", &pnext.x, &pnext.y);
			if (pnext.y < pcurmin.y || (pnext.y == pcurmin.y && pnext.x < pcurmin.x))
				pcurmin = pnext;
			sides[NS++] = pnext-pcur;
			pcur = pnext;
		}
		sides[NS++] = p0-pcur;
		pmin += pcurmin;
	}
	
	sort(sides, sides+NS);
//REP(i, NS) printf("(%d %d)\n", sides[i].x, sides[i].y);
	T[0] = pmin;
	FOR(i, 1, NS-1) T[i] = T[i-1] + sides[i-1];
	int pr = NS-1, cur = 0, ne = 1, ind = 0;
	do {
		if (ccw(T[pr], T[cur], T[ne]) != STRAIGHT) {
			T[ind++] = T[cur];
			pr = cur;
		}
		cur = ne;
		ne = (ne < NS-1 ? ne+1 : 0);
	} while (cur != 0);
	NS = ind;
	
//REP(i, NS) printf("(%d, %d)\n", T[i].x, T[i].y);
	
	int M;
	scanf("%d", &M);
	REP(i, M) {
		point P;
		scanf("%d%d", &P.x, &P.y);
		P *= 3;
		printf("%s\n", in_polygon(P) ? "YES" : "NO");
	}
}
