#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <deque>
#include <queue>
#include <set>
#include <map>
#include <algorithm>
#include <functional>
#include <utility>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstdio>

using namespace std;

#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)
#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)

typedef long long ll;
struct point {ll x,y;};
#define _abs(x) ((x)>0?(x):-(x))

int n[3],N;
point A[3][50010],B[150010];
int start[3],pos[3];

ll area(point &P, point &Q, point &R){
    return (Q.x - P.x) * (R.y - P.y) - (Q.y - P.y) * (R.x - P.x);
}

ll inprod(point &O, point &P, point &Q){
    return (P.x - O.x) * (Q.x - O.x) + (P.y - O.y) * (Q.y - O.y);
}

bool on(point &A, point &B, point &P){
    if(area(A,B,P) != 0) return false;
    if(inprod(A,B,P) >= 0 && inprod(B,A,P) >= 0) return true;
    return false;
}

bool inside(point &A, point &B, point &C, point &P){
    ll sa = _abs(area(P,B,C));
    ll sb = _abs(area(P,C,A));
    ll sc = _abs(area(P,A,B));
    ll s = _abs(area(A,B,C));
    if(sa != 0 && sb != 0 && sc != 0 && s == sa + sb + sc) return true;
    if(on(A,B,P) || on(B,C,P) || on(C,A,P)) return true;
    return false;
}

bool add(point P){
    if(N >= 2 && area(B[N-2],B[N-1],P) == 0) N--;
    B[N] = P; N++;
}

void calc(void){
    int i,j;
    
    REP(i,3){
        int tmp = 0;
        REP(j,n[i]) if(A[i][j].x > A[i][tmp].x || (A[i][j].x == A[i][tmp].x && A[i][j].y < A[i][tmp].y)) tmp = j;
        start[i] = tmp;
    }
    
    while(pos[0] < n[0] || pos[1] < n[1] || pos[2] < n[2]){
        int p = (start[0] + pos[0]) % n[0], p2 = (start[0] + pos[0] + 1) % n[0];
        int q = (start[1] + pos[1]) % n[1], q2 = (start[1] + pos[1] + 1) % n[1];
        int r = (start[2] + pos[2]) % n[2], r2 = (start[2] + pos[2] + 1) % n[2];
        
        point P = {A[0][p].x + A[1][q].x + A[2][r].x, B[N].y = A[0][p].y + A[1][q].y + A[2][r].y};
        add(P);
        
        int next = -1;
        ll dx = 0, dy = 0;
        
        REP(i,3) if(pos[i] < n[i]){
            ll dx2 = 0, dy2 = 0;
            if(i == 0) {dx2 = A[0][p2].x - A[0][p].x; dy2 = A[0][p2].y - A[0][p].y;}
            if(i == 1) {dx2 = A[1][q2].x - A[1][q].x; dy2 = A[1][q2].y - A[1][q].y;}
            if(i == 2) {dx2 = A[2][r2].x - A[2][r].x; dy2 = A[2][r2].y - A[2][r].y;}
            
            int sign = ((dx < 0 || (dx == 0 && dy > 0)) ? 0 : 1);
            int sign2 = ((dx2 < 0 || (dx2 == 0 && dy2 > 0)) ? 0 : 1);
            
            bool good = false;
            if(next == -1) good = true;
            if(sign2 < sign) good = true;
            if(sign == sign2){
                ll s = dx * dy2 - dx2 * dy;
                if(s < 0) good = true;
            }
            
            if(good){
                next = i;
                dx = dx2; dy = dy2;
            }
        }
        
        pos[next]++;
    }
}

bool func(int x, int y){
    int i;
    
    point P = {3ll * x, 3ll * y};
    if(area(B[0],B[1],P) < 0) return false;
    if(area(B[0],B[N-1],P) > 0) return false;
    
    int low = 1, high = N-1;
    while(high-low > 1){
        int mid = (high + low) / 2;
        if(area(B[0],B[mid],P) >= 0) low = mid; else high = mid;
    }
    
//  cout << P.x << ' ' << P.y << ' ' << low << ' ' << high << endl;
    
    return inside(B[0],B[low],B[high],P);
}

int main(void){
    int Q,i,j,x,y,tmp;
    
    REP(i,3){
        scanf("%d",&n[i]);
        REP(j,n[i]){
            scanf("%d",&tmp); A[i][j].x = tmp;
            scanf("%d",&tmp); A[i][j].y = tmp;
        }
    }
    
    calc();
    
//  cout << N << endl;
//  REP(i,N) cout << B[i].x << ' ' << B[i].y << endl;
    
    scanf("%d",&Q);
    REP(i,Q){
        scanf("%d%d",&x,&y);
        bool ans = func(x,y);
        if(ans) printf("YES\n"); else printf("NO\n");
    }
    
    return 0;
}
