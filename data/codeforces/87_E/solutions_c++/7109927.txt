#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef long double ld;

struct point{
  ll x, y;
  point() : x(0), y(0) {}
  point(ll x, ll y) : x(x), y(y) {}
  point operator+(point p){ return point(x + p.x, y + p.y); }
  point operator-(point p){ return point(x - p.x, y - p.y); }
  point operator*(ll a){ return point(x * a, y * a); }
  point operator/(ll a){ return point(x / a, y / a); }
  bool operator<(const point p) const { return y == p.y ? x < p.x : y > p.y; }
  ld arg(){ return atan2(ld(y), ld(x)); }
};

ll cross(point a, point b){
  return a.x * b.y - a.y * b.x;
}

ll ccw(point a, point b, point c){
  return cross(a - b, a - c);
}

const int INF = 1000000000;
const int MAXN = 50005;
const int MAXM = 100005;
int n[3], m, t = 0, pos[3] = {}, x;
point p[3][MAXN], q[3 * MAXN], lh[3 * MAXN], rh[3 * MAXN];
pair<point,int> a[MAXM];
bool res[MAXM];
double th[3];

int main(){
  for(int i = 0; i < 3; i++){
    int k = 0;
    cin >> n[i];
    t += n[i];
    for(int j = 0; j < n[i]; j++){
      cin >> p[i][j].x >> p[i][j].y;
      p[i][j] = p[i][j];
      if(p[i][j] < p[i][k]) k = j;
    }
    rotate(p[i], p[i] + k, p[i] + n[i]);
    p[i][n[i]] = p[i][0];
  }
  q[0] = p[0][0] + p[1][0] + p[2][0];
  for(int i = 0; i < t; i++){
    int k = 0;
    for(int j = 0; j < 3; j++){
      if(pos[j] < n[j]) th[j] = (p[j][pos[j] + 1] - p[j][pos[j]]).arg();
      else th[j] = INF;
      if(th[j] < th[k]) k = j;
      point d = p[j][pos[j] + 1] - p[j][pos[j]];
    }
    point d = p[k][pos[k] + 1] - p[k][pos[k]];
    q[i + 1] = q[i] + p[k][pos[k] + 1] - p[k][pos[k]];
    pos[k]++;
  }
  for(int i = 0; i < t; i++){
    if((q[i + 1] - q[i]).y > 0){
      x = i + 1;
      reverse(q, q + x);
      break;
    }
  }
  for(int i = 0; i < x; i++) lh[i] = q[i];
  bool b = 0;
  rh[0] = lh[0];
  for(int i = x; i <= t; i++) rh[i - x + 1] = q[i];

  cin >> m;
  for(int i = 0; i < m; i++){
    cin >> a[i].first.x >> a[i].first.y;
    a[i].second = i;
  }
  sort(a, a + m);
  reverse(a, a + m);
  int l = 1, r = 1, ll = x, rl = t + 2 - x;
  for(int i = 0; i < m; i++){
    point c = a[i].first * 3;
    while(l + 1 < ll && c.y >= lh[l].y) l++;
    while(r + 1 < rl && c.y > rh[r].y) r++;
    if(c.y < lh[0].y || c.y > lh[l].y) res[a[i].second] = 0;
    else if(c.x < min(lh[l - 1].x, lh[l].x) || max(rh[r - 1].x, rh[r].x) < c.x) res[a[i].second] = 0;
    else res[a[i].second] = (ccw(lh[l], lh[l - 1], c) >= 0 && ccw(rh[r], rh[r - 1], c) <= 0);
  }
  for(int i = 0; i < m; i++) cout << (res[i] ? "YES\n" : "NO\n");
}
