#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;

typedef long double db;

const db inf=(db)1./0;

const int N=50005;

int tot,p;

struct vec{
	db x,y;
	vec(){
	}
	vec(db _x,db _y):x(_x),y(_y){
	}
	friend vec operator + (const vec &a,const vec &b){
		return vec(a.x+b.x,a.y+b.y);
	}
	friend vec operator - (const vec &a,const vec &b){
		return vec(a.x-b.x,a.y-b.y);
	}
	db atan2() const{
		return ::atan2(y,x);
	}
} O,a[N*3],b[N*3];

db cross(const vec &a,const vec &b){
	return a.x*b.y-a.y*b.x;
}

bool cmpang(const vec &a,const vec &b){
	return a.atan2()<b.atan2();
}

bool cmpy_l(const vec &a,const vec &b){
	return a.y<b.y;
}

bool cmpy_g(const vec &a,const vec &b){
	return a.y>b.y;
}

vec getvec(){
	double x,y; scanf("%lf%lf",&x,&y);
	return vec((db)x,(db)y);
}

void putvec(const vec &a){
	printf("(%lf,%lf)",(double)a.x,(double)a.y);
}

db xul=+inf,xur=-inf,xdl=+inf,xdr=-inf;

bool check(vec P){
	if(P.y>a[0].y||P.y<a[p].y) return false;
	if(P.y==a[0].y)
		return P.x>=xul&&P.x<=xur;
	if(P.y==a[p].y)
		return P.x>=xdl&&P.x<=xdr;
	int loc=upper_bound(a,a+p,P,cmpy_g)-a-1;
	if(cross(b[loc],P-a[loc])<0) return false;
	loc=upper_bound(a+p,a+tot,P,cmpy_l)-a-1;
	if(cross(b[loc],P-a[loc])<0) return false;
	return true;
}


int main(){
	for(int _=0;_<3;_++){
		int n; scanf("%d",&n);
		int p=0;
		for(int i=0;i<n;i++){
			a[i]=getvec();
			if(a[i].y>a[p].y||a[i].y==a[p].y&&a[i].x<a[p].x) p=i;
		}
		for(int i=0;i<p;i++) a[n+i]=a[i];
		for(int i=0;i<n;i++) a[i]=a[i+p];
		O=O+a[0];
		a[n]=a[0];
		for(int i=0;i<n;i++) b[tot+i]=a[i+1]-a[i];
		inplace_merge(b,b+tot,b+tot+n,cmpang);
		tot+=n;
	}
	a[0]=O;
	for(int i=0;i<tot;i++) a[i+1]=a[i]+b[i];
	for(p=0;b[p].atan2()<=0;p++);
	for(int i=0;i<tot;i++){
		if(a[i].y==a[0].y){
			xul=min(xul,a[i].x);
			xur=max(xur,a[i].x);
		}
		if(a[i].y==a[p].y){
			xdl=min(xdl,a[i].x);
			xdr=max(xdr,a[i].x);
		}
	}
	int q; scanf("%d",&q);
	while(q--){
		vec P=getvec(); P.x*=3; P.y*=3;
		puts(check(P)?"YES":"NO");
	}
}