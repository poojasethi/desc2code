#include <cstdio>
#include <cstring>
#include <vector>
#include <utility>
#include <algorithm>
using namespace std;

typedef long long I64;

struct Point {
  I64 x,y;
  
  Point() {}
  Point(int x,int y):x(x),y(y) {}

  Point& operator+=(Point p) {
    x+=p.x;
    y+=p.y;
    return *this;
  }
  Point& operator-=(Point p) {
    x-=p.x;
    y-=p.y;
    return *this;
  }

  friend Point operator+(const Point& p,const Point &q) {
    Point r=p;
    r+=q;
    return r;
  }
  friend Point operator-(const Point& p,const Point &q) {
    Point r=p;
    r-=q;
    return r;
  }
};

I64 CrossProduct(const Point& p, const Point& q) {
  return p.x*q.y-p.y*q.x;
}

int GetQuadrant(const Point& p) {
  if(p.x>0 && p.y>=0) return 1;
  if(p.x<=0 && p.y>0) return 2;
  if(p.x<0 && p.y<=0) return 3;
  return 4;
}

bool LessAngle(const Point& p,const Point& q) {
  int q_p=GetQuadrant(p),q_q=GetQuadrant(q);
  if(q_p!=q_q) return q_p<q_q;
  return CrossProduct(p,q)>0;
}

struct Convex {
  int n;
  vector<Point> p;

  void Read() {
    scanf("%d",&n);
    p.resize(n+1);
    int x,y;
    for(int i=0;i<n;++i) {
      scanf("%d%d",&x,&y);
      p[i].x=x;
      p[i].y=y;
    }
    p[n]=p[0];
    Normalize();
  }

  void Normalize() {
    Point first;
    int k=-1;

    for(int i=0;i<n;++i) {
      Point v=p[i+1]-p[i];
      if(i==0 || LessAngle(v,first)) {
        first=v;
        k=i;
      }
    }

    rotate(p.begin(),p.begin()+k,p.begin()+n); 
    p[n]=p[0];
  }

  void CleanDup() {
    vector<Point> d(n+1);
    int tail=1;
    d[0]=p[0],d[1]=p[1];

    Point prev=d[1]-d[0];
    for(int i=2;i<=n;++i) {
      Point v=p[i]-d[tail];
      if(CrossProduct(prev,v)==0) d[tail]=p[i];
      else d[++tail]=p[i];
      prev=d[tail]-d[tail-1];
    }
    d.resize(tail+1);
    n=tail;
    p=d;
  }

  bool Contains(const Point &q) const {
    int low=1,high=n-1;
    Point v=q-p[0];
    if(v.x==0 && v.y==0) return true;

    while(low<=high) {
      int mid=(low+high)>>1;
      if(LessAngle(p[mid]-p[0],v)) low=mid+1; else high=mid-1;
    }

    if(high==0 && !LessAngle(v,p[1]-p[0])) high=1;
    if(high==n-1) return !LessAngle(p[high]-p[0],v);
    return CrossProduct(p[high]-q,p[high+1]-q)>=0;
  }
};

void Combine(const Convex& P, const Convex& Q, Convex& R) {
  R.n=P.n+Q.n;
  R.p.resize(R.n+1);
  R.p[0]=Point(0,0);
  Point minR=R.p[0];

  int iP=0,iQ=0,iR=0;
  Point vP=P.p[1]-P.p[0],vQ=Q.p[1]-Q.p[0];
  Point minP(P.p[0].x,P.p[0].y);
  Point minQ(Q.p[0].x,Q.p[0].y);

  while(iP<P.n || iQ<Q.n) {
    bool moveP;
    if(iP==P.n) moveP=0;
    else if(iQ==Q.n) moveP=1;
    else moveP=LessAngle(vP,vQ);

    ++iR;
    if(moveP) {
      R.p[iR]=R.p[iR-1]+vP;
      ++iP;
      minP.x=min(minP.x,P.p[iP].x);
      minP.y=min(minP.y,P.p[iP].y);
      vP=P.p[iP+1]-P.p[iP];
    } else {
      R.p[iR]=R.p[iR-1]+vQ;
      ++iQ;
      minQ.x=min(minQ.x,Q.p[iQ].x);
      minQ.y=min(minQ.y,Q.p[iQ].y);
      vQ=Q.p[iQ+1]-Q.p[iQ];
    }

    minR.x=min(minR.x,R.p[iR].x);
    minR.y=min(minR.y,R.p[iR].y);
  }

  Point t=minP+minQ;
  for(int i=0;i<R.n;++i) {
    R.p[i]-=minR;
    R.p[i]+=t;
  }
  R.p[R.n]=R.p[0];
  R.CleanDup();
}

Convex a;

void PreCom() {
  Convex b,c;
  
  a.Read();
  for(int i=0;i<2;++i) {
    b.Read();
    Combine(a,b,c);
    a=c;
  }
}

void Solve() {
  Point p;
  int n;
  int x,y;
  scanf("%d",&n);
  while(n--) {
    scanf("%d%d",&x,&y);
    p.x=x,p.y=y;
    p.x*=3;p.y*=3;
    if(a.Contains(p)) printf("YES\n"); else printf("NO\n");
  }
}

int main() {
  PreCom();
  Solve();

  return 0;
}
