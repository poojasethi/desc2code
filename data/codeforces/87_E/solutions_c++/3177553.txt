#pragma comment (linker, "/STACK:1073741824")
#define _USE_MATH_DEFINES
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <iostream>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <deque>
#include <vector>
#include <string>
#include <bitset>
#include <complex>

using namespace std;

#define SZ(x) (int((x).size()))
#define FOR(i, a, b) for(int (i) = (a); (i) <= (b); ++(i))
#define ROF(i, a, b) for(int (i) = (a); (i) >= (b); --(i))
#define REP(i, n) for (int (i) = 0; (i) < (n); ++(i))
#define REPD(i, n) for (int (i) = (n); (i)--; )
#define FE(i, a) for (int (i) = 0; (i) < (int((a).size())); ++(i))
#define MEM(a, val) memset((a), val, sizeof(a))
#define INF 1000000000
#define LLINF 1000000000000000000LL
#define PB push_back
#define PPB pop_back
#define ALL(c) (c).begin(), (c).end()
#define SQR(a) ((a)*(a))
#define MP(a,b) make_pair((a), (b))
#define XX first
#define YY second

typedef vector<int> vint;
typedef vector<long long> vLL;
typedef double dbl;
typedef long double ldbl;
typedef vector<pair<int, int> > vpii;
typedef long long LL;
typedef pair<int, int> pii;

const int nmax = 150100;

int n[3];
pii a[3][nmax/3];
pii b[nmax];
pii start[3];

LL mult(const pii& a, const pii& b) {
  return LL(a.XX)*b.YY - LL(a.YY)*b.XX;
}

pii& operator-=(pii& a, const pii& b) {
  a.XX -= b.XX;
  a.YY -= b.YY;
  return a;
}

pii operator-(pii a, const pii& b) {
  return a -= b;
}

pii& operator+=(pii& a, const pii& b) {
  a.XX += b.XX;
  a.YY += b.YY;
  return a;
}

pii operator+(pii a, const pii& b) {
  return a += b;
}

int all;

inline bool check(int x, int y) {
  pii rel = MP(x, y) - b[0];
  if (rel.XX < 0) return false;
  if (mult(rel, b[1] - b[0]) > 0 || mult(b[all - 1] - b[0], rel) > 0) return false;

  int l = 0, r = all - 1;
  while(l + 1 < r) {
    int mid = (l + r)/2;
    if (mult(rel, b[mid] - b[0]) > 0) {
      r = mid;
    } else {
      l = mid;
    }
  }
  return mult(b[l] - MP(x, y), b[r] - MP(x, y)) >= 0;
}

int main() {
#ifdef    CENADAR_DEBUG
  freopen("input.txt", "r", stdin);
//  freopen("output.txt", "w", stdout);
//  freopen("errput.txt", "w", stderr);
#else  // CENADAR_DEBUG
//  freopen("input.txt", "r", stdin);
//  freopen("output.txt", "w", stdout);
#endif // CENADAR_DEBUG

  REP(t, 3) {
    scanf("%d", n + t);
    int pos = 0;
    REP(i, n[t]) {
      scanf("%d%d", &a[t][i].XX, &a[t][i].YY);
      if (a[t][i] < a[t][pos]) pos = i;
    }
    rotate(a[t], a[t] + pos, a[t] + n[t]);

    start[t] = a[t][0];
    REP(i, n[t]) {
      if (i != n[t] - 1) a[t][i] = a[t][i + 1] - a[t][i];
    }
    a[t][n[t] - 1] = start[t] - a[t][n[t] - 1];
  }

  int p[3] = {};
  while(p[0] < n[0] || p[1] < n[1] || p[2] < n[2]) {
    int curmin = -1;
    REP(t, 3) if (p[t] < n[t]) {
      if (curmin == -1 || mult(a[t][p[t]], a[curmin][p[curmin]]) > 0) {
        curmin = t;
      }
    }
    if (all > 0 && mult(b[all - 1], a[curmin][p[curmin]]) == 0) {
      b[all - 1] += a[curmin][p[curmin]++];
    } else {
      b[all++] = a[curmin][p[curmin]++];
    }
  }
  pii tot = start[0] + start[1] + start[2];

  pii cur = tot, tmp;
  REP(i, all) {
    tmp = b[i];
    b[i] = cur;
    cur += tmp;
//    printf("%d %d\n", b[i].XX, b[i].YY);
  }

  int m;
  scanf("%d", &m);
  while(m--) {
    int x, y;
    scanf("%d%d", &x, &y);
    printf(check(3*x, 3*y) ? "YES\n" : "NO\n");
  }

  return 0;
}
