//87E Hewr
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <vector>
#include <queue>
#include <iomanip>
#include <set>
#include <map>
#include <bitset>
using namespace std;
#define fo(i,a,b) for (int i = a; i <= b; ++i)
#define fd(i,a,b) for (int i = a; i >= b; --i)
#define fe(i,x) for (int i = g[x], y = E[i].y; i; i = E[i].l, y = E[i].y)
#define forall(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); ++i)
#define pb push_back
#define SIZE(x) ((int) (x).size())
#define MP make_pair
#define fi first
#define se second
#define UNIQUE(x) x.resize(unique(x.begin(), x.end()) - x.begin())
#define clr(a,x) memset(&a, x, sizeof(a))
#define move(a,b) memcpy(&b, &a, sizeof(a))
#define Plus(a,b) (((LL) (a) + (b)) % mo)
#define Minus(a,b) ((((LL) (a) - (b) ) % mo + mo) % mo)
#define Mul(a,b) ((LL) (a) * (b) % mo)
#define updmin(a,b) (a = min(a, b))
#define updmax(a,b) (a = max(a, b))
#define sqr(x) ((LL) (x) * (x))

typedef long long LL;
typedef long double LD;
typedef pair<int, int> PII;
typedef vector<int> VI;

const double eps = 1e-10;
const int oo = ~0u >> 2, mo = (int) 1e9 + 7;
const int mn = 300000;

struct po{
	int x, y;
	po(){ x = y = 0; }
	po(int _x, int _y){ x = _x, y = _y; }
	void readin(){ scanf("%d%d", &x, &y); }
	bool operator < (const po &p){ return x < p.x || (x == p.x && y < p.y); }
	po operator + (const po &p){ return po(x + p.x, y + p.y); }
	po operator - (const po &p){ return po(x - p.x, y - p.y); }
	po operator * (int d){ return po(x * d, y * d); }
};

LL det(po a, po b, po c){
	return (LL) (b.x - a.x) * (c.y - a.y) - (LL) (c.x - a.x) * (b.y - a.y);
}

LL dis(po a, po b){
	return sqr(a.x - b.x) + sqr(a.y - b.y);
}

po plb;

bool cmp(const po &a, const po &b){
	LL t = det(plb, a, b);
	return t > 0 || (!t && dis(plb, a) > dis(plb, b));
}

struct CH{
	po P[mn];
	int n;
	void ins(po p){ P[n++] = p; }
	void readin(){
		scanf("%d", &n);
		fo (i, 0, n - 1) P[i].readin();
	}
	bool Contain(po o){
		LL t = det(P[0], P[1], o);
		if (t < 0 || (!t && dis(P[0], o) > dis(P[0], P[1]))) return 0;
		t = det(P[0], P[n - 1], o);
		if (t > 0 || (!t && dis(P[0], o) > dis(P[0], P[n - 1]))) return 0;
		int l = 1, r = n - 2, w = 0;
		while (l <= r){
			int m = (l + r) / 2;
			po p = P[m];
			LL t = det(P[0], P[m], o);
			if (t >= 0) w = m, l = m + 1;
			else r = m - 1;
		}
		l = w, r = (l + 1) % n;
		po p1 = P[l], p2 = P[r];
		t = det(p1, p2, o);
		return t >= 0;
	}
	void ConvexHull(){
		fo (i, 1, n - 1) if (P[i] < P[0]) swap(P[0], P[i]);
		plb = P[0];
		sort(P + 1, P + n, cmp);
		int r = 1;
		fo (i, 2, n - 1) if (det(P[0], P[r], P[i])){
			while (r && det(P[r - 1], P[r], P[i]) <= 0) --r;
			P[++r] = P[i];
		}
		n = r + 1;
	}
} Q[5];

void mrg(CH &A, CH &B, CH &C){
	C.n = 0;
	int l = 0, r = 0;
	do {
		int nl = (l + 1) % A.n, nr = (r + 1) % B.n;
		po O = A.P[l] + B.P[r], P1 = A.P[l] + B.P[nr], P2 = A.P[nl] + B.P[r];
		LL t = det(O, P1, P2);
		if (t > 0 || (!t && dis(O, P1) > dis(O, P2))) 
			C.ins(P1), r = nr;
		else	C.ins(P2), l = nl;
	} while (l || r);
	C.ConvexHull();
}

int main(){
	fo (i, 0, 2) Q[i].readin(), Q[i].ConvexHull();
	mrg(Q[0], Q[1], Q[3]);
	mrg(Q[2], Q[3], Q[4]);
	int Ca;
	scanf("%d", &Ca);
	while (Ca--){
		po p;
		p.readin();
		p = p * 3;
		bool flag = Q[4].Contain(p);
		if (flag) printf("YES\n");
		else printf("NO\n");
	}
}
