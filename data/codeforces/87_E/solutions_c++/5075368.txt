#include<cstdio>
#include<algorithm>
#include<vector>
#include<cmath>
#include<map>
using namespace std;
struct point{
    long long x,y;
    point(){ x = y = 0;}
    point(long long _x,long long _y){ x = _x, y = _y; }
    void read(){ scanf("%I64d%I64d",&x,&y); }
    point operator + (const point& p) const { return point(x+p.x,y+p.y); }
    point operator - (const point& p) const { return point(x-p.x,y-p.y); }
    
};
int n;
vector <point> V[4];
map<long long,long long> upper,lower;
point offset(vector<point> X){
    point res = X[0];
    for(int i=0;i<X.size();i++)
        res.x = min(X[i].x,res.x), res.y = min(X[i].y,res.y);
    return res;
}
void diff(vector <point>&p, vector<pair<double,point> >&res){
    int n = p.size();
    for(int i=0;i<p.size();i++){
        point d = p[(i+1)%n]-p[i];
        res.push_back(make_pair(atan2(d.y,d.x),d));
    }
}
bool cmp(pair<double,point> i,pair<double,point> j){ return i.first<j.first; }
vector <point> minkowskisum( vector<point> A,vector<point> B){
    vector <point> res;
    vector <pair<double,point> > sv;
    point off = offset(A) + offset(B);
    diff(A,sv);
    diff(B,sv);
    sort(sv.begin(),sv.end(),cmp);
    for(int i=0;i<sv.size();i++)
        res.push_back(sv[i].second);
    for(int i=1;i<sv.size();i++)
        res[i] = res[i] + res[i-1];
    off = off - offset(res);
    for(int i=0;i<sv.size();i++)
        res[i] = res[i] + off;
    return res;
}
long long cross(point p1,point p2,point p3){
    return (p2.x-p1.x)*(p3.y-p1.y) - (p3.x-p1.x)*(p2.y-p1.y);
}
void erase_right(map<long long,long long>& hull,map<long long,long long>::iterator it){
    while(true){
        map<long long,long long>::iterator nxt = it; nxt++;
        if(nxt == hull.end()) break;
        map<long long,long long>::iterator nnxt = nxt; nnxt++;
        if(nnxt == hull.end()) break;
        if(cross(point(it->first,it->second),point(nnxt->first,nnxt->second),point(nxt->first,nxt->second)) > 0) return;
        hull.erase(nxt);
    }
}
void erase_left(map<long long,long long>& hull,map<long long,long long>::iterator it){
    while(true){
        if(it == hull.begin()) break;
        map<long long,long long>::iterator nxt = it; nxt--;
        if(nxt == hull.begin()) break;
        map<long long,long long>::iterator nnxt = nxt; nnxt--;
        if(cross(point(nnxt->first,nnxt->second),point(it->first,it->second),point(nxt->first,nxt->second)) > 0) return;
        hull.erase(nxt);
    }
}
bool is_upper(map<long long,long long>& hull,long long x,long long y,bool insert){
    bool res = false;
    if(hull.empty()) res = true;
    else{
        double minx = hull.begin()->first,maxx = (--hull.end())->first;
        if(minx > x || maxx < x) res = true;
        else if(minx == x){
            res = (hull.begin()->second < y);
        }
        else if(maxx == x)
            res = ((--hull.end())->second < y);
        else{
            map<long long,long long>::iterator it = hull.lower_bound(x);
            if(it->first == x)
                res = ((it->second) < y);
            else{
                map<long long,long long>::iterator pre = it;
                pre--;
                long long sv = cross(point(pre->first,pre->second),point(it->first,it->second),point(x,y));
                res = (sv > 0ll);
            }
        }
    }
    if(insert && res){
        hull[x] = y;
        erase_left(hull,hull.find(x));
        erase_right(hull,hull.find(x));
    }
    return res;
}
int main(){
    for(int i=0;i<3;i++){
        scanf("%d",&n);
        V[i].resize(n);
        for(int j=0;j<n;j++)    
            V[i][j].read();
    }
    V[3] = minkowskisum(V[0], minkowskisum(V[1],V[2]));
    for(int i=0;i<V[3].size();i++){
        is_upper(upper,V[3][i].x,V[3][i].y,1);
        is_upper(lower,V[3][i].x,-V[3][i].y,1);
    }
    scanf("%d",&n);
    point o;
    for(int i=0;i<n;i++){
        o.read(); o.x *= 3; o.y *= 3;
        if(is_upper(upper,o.x,o.y,0) || is_upper(lower,o.x,-o.y,0)) printf("NO\n");
        else printf("YES\n");
    }
        
    return 0;
}