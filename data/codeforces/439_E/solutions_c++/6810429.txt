#include <bits/stdc++.h>
using namespace std;

typedef long long LL;

const int N = 100005;
const int P = 1000000007;
inline LL add(LL a, LL b) { return (a + b) % P; }
inline LL mul(LL a, LL b) { return (a * b) % P; }

LL fact[N], mu[N];

void init() {
	fact[0] = 1;
	for(int i = 1; i < N; ++i) {
		fact[i] = mul(fact[i-1], i);
	}
	mu[1] = -1;
	for (int i = 1; i < N; ++i) {
		mu[i] = -mu[i];
		for (int j = i << 1; j < N; j += i) {
			mu[j] += mu[i];
		}
	}
}
LL power(LL x, LL n) {
	LL y = 1;
	for (; n; n >>= 1, x = mul(x, x))
		if (n & 1) y = mul(y, x);
	return y;
}
LL mod_inv(LL x) {
	return power(x, P - 2);
}
LL mod_comb(int n, int k) {
	if(n < 0 || k < 0 || n < k) return 0;
	return mul(fact[n], mod_inv(mul(fact[k], fact[n-k])));
}

int main() {
	init();
	int T; scanf("%d", &T);
	while (T--) {
		int n, m; scanf("%d%d", &n, &m);
		int g = 0;
		for (int i = 1; i * i <= n; ++i) {
			if (n % i) continue;
			int j = n / i;
			if (mu[i] > 0) g = add(g,     mod_comb(j-1, m-1));
			if (mu[i] < 0) g = add(g, P - mod_comb(j-1, m-1));
			if (j != i) {
				if (mu[j] > 0) g = add(g,     mod_comb(i-1, m-1));
				if (mu[j] < 0) g = add(g, P - mod_comb(i-1, m-1));
			}
		}
		printf("%d\n", g);
	}
}
