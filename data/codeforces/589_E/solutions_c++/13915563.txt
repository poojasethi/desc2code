//pb_ds NOI template 20150710
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cassert>
#include <cmath>
#include <vector>
#include <set>
#include <utility>
#include <queue>
#define For(i, a, b) for(register int i = a, ___u = b; i <= ___u; ++i)
#define ForDown(i, a, b) for(register int i = b, ___d = a; i >= ___d; --i)
#define Iter(iter, vec) for(RG typeof(vec.begin()) iter = vec.begin(), __d = vec.d(); iter != __d; ++iter)
#define cmax(i, j) ((i) < (j) ? (i) = (j) : (i))
#define cmin(i, j) ((i) > (j) ? (i) = (j) : (i))
#define dmax(i, j) ((j) < (i) ? (i) : (j))
#define dmin(i, j) ((i) < (j) ? (i) : (j))
#define ddel(i, j) ((i) > (j) ? (i) - (j) : (j) - (i))
#define dabs(i) ((i) > 0 ? (i) : -(i))
#define dsqr(x) ((x) * (x))
#define lowbit(i) ((i) & -(i))

#include <bitset>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/priority_queue.hpp>
#include <ext/pb_ds/tree_policy.hpp>

namespace io
{
	const int MAXBUF = 1 << 22;
	char B[MAXBUF], *S = B, *T = B;
	#define getc() (S == T && (T = (S = B) + fread(B, 1, MAXBUF, stdin), S == T) ? 0 : *S++)
	#define fastcall __attribute__((optimize("-O3")))
	template<class Type> inline Type read()
	{
		register Type aa = 0;
		register bool bb = 0;
		register char ch, *S = io::S, *T = io::T;
		for(ch = getc(); (ch < '0' || ch > '9') && ch != '-'; ch = getc())
			;
		for(ch == '-' ? bb = 1 : aa = ch - '0', ch = getc(); '0' <= ch && ch <= '9'; ch = getc())
			aa += (aa << 3) + aa + ch - '0';
		io::S = S, io::T = T;
		return bb ? -aa : aa; 
	}
	int (*F)() = read<int>;
	
	template<> inline double read()
	{
		register double aa = 0, bb;
		register bool cc = 0;
		register char ch;
		register char *S = io::S, *T = io::T;
		for(ch = getc(); (ch < '0' || ch > '9') && ch != '-'; ch = getc())
			;
		for(ch == '-' ? cc = 1 : aa = ch - '0', ch = getc(); '0' <= ch && ch <= '9'; ch = getc())
			aa = aa * 10 + ch - '0';
		if(ch == '.')
		{
			bb = 1;
			while(ch = getc(), ch >= '0' && ch <= '9')
				aa += (bb *= 0.1) * (ch - '0');
		}
		io::S = S, io::T = T;
		return cc ? -aa : aa;
	}
	
	char buff[MAXBUF], *iter = buff;
	template<class T>inline void P(register T x, register char ch = '\n')
	{
		static int stack[110];
		register int O = 0;
		register char *iter = io::iter;
		if(!x)*iter++ = '0';
		else
		{
			(x < 0) ? x = -x, *iter++ = '-' : 1;
			for(; x; x /= 10)
				stack[++O] = x % 10;
			for(; O; *iter++ = '0' + stack[O--])
				;
		}
		*iter++ = ch, io::iter = iter;
	}

	inline int gets(register char *o)
	{
		register char *str = o, ch = getc();
		register char *S = io::S, *T = io::T;
		for(; ch == ' ' || ch == '\n' || ch == '\r' || !ch; ch = getc())
			;
		for(; ch != ' ' && ch != '\n' && ch != '\r' && ch; ch = getc())
			*str++ = ch;
		*str = 0;
		io::S = S, io::T = T;
		return str - o;
	}

	inline char get_a()
	{
		register char ch = getc();
		while(ch < 'a' || 'z' < ch) ch = getc();
		//puts("1");
		return ch;
	}
	
	inline void putc(register char ch) {*iter++ = ch;}
	
	inline void output() {fwrite(buff, 1, iter - buff, stdout), iter = buff;}
}


#define RG register
#define set_file(FILE) freopen(FILE ".in", "r", stdin), freopen(FILE ".out", "w", stdout)
#define close_file() fclose(stdin), fclose(stdout)
//#include <ext/pb_ds/priority_queue.hpp>
//#include <stdarg.h>


namespace pb_ds
{
	using io::P;	
	
	char str_buff[3000010];
	char *str[50010];
	
	namespace Task1
	{
		int cnt[50010];
		bool pre[50010];
		inline void solve(RG int n, RG int m)
		{
			RG long long ans = 0;
			For(i, 0, n - 1)
				str[i] = str[i + 1] + 1;
			for(int u=0;u<m;u++){
				for(int i=0;i<n;i++){
				    cnt[i]=0;
				    pre[i]=true;
				}
				for(int d=u;d<m;d++){
				    int cur=0;
				    //cout<<u<<" "<<d<<endl;
				    for(int i=0;i<n;i++){
				        cnt[i]+=str[i][d]=='('?1:-1;
				        pre[i]&=cnt[i]>=0;
				        if(pre[i]&&cnt[i]==0){
				            ++cur;
				            ans+=cur;
				        }else{
				            cur=0;
				        }
				        //cout<<"i="<<i<<" "<<cur<<endl;
				    }

				}
			}
			P(ans);
		}
	}
	
	namespace Task2
	{		
		int cnt[50010];
		int active[50010];
		int f[50010], g[50010], h[50010];
		inline void solve(RG int n, RG int m)
		{
			For(i, 0, n - 1)
				str[i] = str[i + 1] + 1;
			RG long long ans = 0;
			For(u, 0, n - 1) For(d, u, n - 1)
			{
				cnt[m] = 0;
				ForDown(i, 0, m - 1)
					cnt[i] = cnt[i + 1] + (str[d][i] == ')' ? 1 : -1);
				RG int size = 1;
				active[0]=m;
				    f[m]=m+1;
				    for(RG int i=m-1;i>=0;i--)
				    {
				        while(size&&cnt[active[size-1]]>cnt[i])
				        {
				            --size;
				        }
				        if(u==d)
				        {
				            g[i]=!size||cnt[active[size-1]]<cnt[i]?m+1:active[size-1];
				            active[size++]=i;
				            continue;
				        }
				        if(size)
				        {
				            if(f[i]==m+1||cnt[active[size-1]]<cnt[i])
				            {
				                g[i]=m+1;
				            }else
				            {
				                while(f[i]<m+1&&size&&cnt[active[size-1]]==cnt[i]&&f[i]!=active[size-1])
				                {
				                    if(f[i]<active[size-1])
				                    {
				                        f[i]=f[f[i]];
				                    }else
				                    {
				                        --size;
				                    }
				                }
				                if(f[i]<m+1&&size&&cnt[active[size-1]]==cnt[i])
				                {
				                    g[i]=f[i];
				                }
				                else
				                {
				                    g[i]=m+1;
				                }
				            }
				        }
				        else
				        {
				            g[i]=m+1;
				        }
				        active[size++]=i;
				    }
				    h[m+1]=-1;
				    for(RG int i=m-1;i>=0;i--)
				    {
				        f[i]=g[i];
				        h[i]=1+h[f[i]];
				        ans+=h[i];
				    }
			}
			P(ans);
		}
	}
	
	inline void main()
	{
		RG int (*F)() = io::F;
		RG int n = F(), m = F();
		For(i, 1, n)
		{
			str[i] = str_buff + (m + 10) * (i - 1);
			io::gets(str[i] + 1);			
		}
		//For(i, 1, n) puts(str[i] + 1);
		if(m <= 1500) return Task1::solve(n, m);
		else return Task2::solve(n, m);
	}	
}

int main()
{
	//set_file("graph");
	pb_ds::main();
	io::output();
	close_file();
}
/*
1
3 3 3
1 2
1 3
3 2

1
8 9 8
1 2
1 7
2 3
2 5
3 4
5 6
7 8
6 4
8 4

*/
