#include <bits/stdc++.h>

using namespace std;

#define F first
#define S second

#define endl '\n'

#define mp make_pair
#define pb push_back

#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define ROF(i, a, b) for(int i = a; i >= b; i--)

#define type(x) __typeof((x).begin())
#define foreach(i, x) for(type(x) i = (x).begin(); i != (x).end(); i++)

#define sol (root + root)
#define sag (root + root + 1)
#define orta ((bas + son) >> 1)

#define bit __builtin_popcount

#ifndef D
	#define dbg(x) 0
	#define dbgs(x) 0
#else
	#define dbg(x) cerr << (#x) << " --> " << (x) << endl
	#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#endif

typedef long long ll;
typedef pair < int, int > pii;

const int inf = 1e9 + 5;
const ll linf = 1e18 + 5;

const int N = 2000 + 5;

int n, m, x, y;
pii a[N], b[N], kd[(N * 3) << 2];
vector < pair < pii, int > > vx, vy, vnx, vny;
map < int, int > M;

bool cmp(pair < pii, int > x, pair < pii, int > y) {
	if(x.S != y.S)
		return x.S < y.S;
	return x < y;
}

bool cmp2(pair < pii, int > x, pair < pii, int > y) {
	return x.S < y.S;
}

pii merge(pii x, pii y) {
	pii t;
	if(x.F > y.F) {
		t.F = x.F;
		t.S = max(x.S, y.F);
	}
	else {
		t.F = y.F;
		t.S = max(y.S, x.F);
	}
	return t;
}

pii init(int root, int bas, int son) {
	if(bas == son) return kd[root] = mp(-inf, -inf);
	return kd[root] = merge(init(sol, bas, orta), init(sag, orta + 1, son));
}

pii update(int root, int bas, int son, int x, int k) {
	if(son < x or x < bas) return kd[root];
	if(x <= bas and son <= x) return kd[root] = mp(k, -inf);
	return kd[root] = merge(update(sol, bas, orta, x, k), update(sag, orta + 1, son, x, k));
}

pii query(int root, int bas, int son, int x, int y) {
	if(son < x or y < bas or y < x) return mp(-inf, -inf);
	if(x <= bas and son <= y) return kd[root];
	return merge(query(sol, bas, orta, x, y), query(sag, orta + 1, son, x, y));
}

bool f(int x) {

	x *= 2;

	vx.clear();
	vy.clear();
	vnx.clear();
	vny.clear();

	FOR(i, 1, n) vx.pb(mp(mp(a[i].S - x, a[i].S + x), a[i].F));
	FOR(i, 1, m) vy.pb(mp(mp(b[i].F - x, b[i].F + x), b[i].S));

	sort(vx.begin(), vx.end(), cmp);
	sort(vy.begin(), vy.end(), cmp);

	FOR(i, 0, (int) vx.size() - 1) {
		int j = i, last = vx[i].F.S;
		while(j < vx.size() and vx[i].S == vx[j].S and last >= vx[j].F.F) {
			last = vx[j].F.S;
			j++;
		}
		j--;
		vnx.pb(mp(mp(vx[i].F.F, vx[j].F.S), vx[i].S));
		i = j;
	}
	FOR(i, 0, (int) vy.size() - 1) {
		int j = i, last = vy[i].F.S;
		while(j < vy.size() and vy[i].S == vy[j].S and last >= vy[j].F.F) {
			last = vy[j].F.S;
			j++;
		}
		j--;
		vny.pb(mp(mp(vy[i].F.F, vy[j].F.S), vy[i].S));
		i = j;
	}

	swap(vx, vnx);
	swap(vy, vny);

	sort(vx.begin(), vx.end(), cmp2);
	sort(vy.begin(), vy.end());
	
	M.clear();

	foreach(it, vx) {
		M[it -> F.F] = 1;
		M[it -> F.S] = 1;
	}

	foreach(it, vy)
		M[it -> S] = 1;

	int cur = 0;

	foreach(it, M)
		it -> S = ++cur;

	init(1, 1, cur);

	int j = 0;

	FOR(i, 0, (int) vx.size() - 1) {
		while(j < vy.size() and vy[j].F.F <= vx[i].S) {
			update(1, 1, cur, M[vy[j].S], vy[j].F.S);
			j++;
		}
		FOR(j, i + 1, (int) vx.size() - 1)
			if(query(1, 1, cur, M[max(vx[i].F.F, vx[j].F.F)], M[min(vx[i].F.S, vx[j].F.S)]).S >= vx[j].S)
				return 1;
	}

	return 0;

}

int main() {
	
	ios :: sync_with_stdio(0);

	cin >> n >> m;

	FOR(i, 1, n) {
		cin >> x >> y;
		a[i].F = x + y;
		a[i].S = x - y;
	}

	FOR(i, 1, m) {
		cin >> x >> y;
		b[i].F = x + y;
		b[i].S = x - y;
	}

	int l = 0, r = 1000000;

	if(!f(r)) {
		cout << "Poor Sereja!" << endl;
		return 0;
	}

	while(l < r) {
		int m = l + r >> 1;
		if(f(m))
			r = m;
		else
			l = m + 1;
	}

	cout << l << endl;

	return 0;

}
