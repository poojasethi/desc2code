#include <iostream>
#include <fstream>
#include <vector>
#include <set>
#include <map>
#include <algorithm>
#include <cstdlib>
#include <cstring>
#include <string>
#include <queue>
#include <cmath>
#include <cstdio>
#include <ctime>
#include <complex>
#include <iomanip>
#include <climits>
#include <deque>
#include <limits>
#include <sstream>

using namespace std;

#define FOREACH(i, c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)
#define FR(i, n) for(int i=0; i<(n); ++i)
#define FRE(i, n) for(int i=0; i<=(n); ++i)
#define FOR(i, x, y) for(int i=(x); i<(y); ++i)
#define FORE(i, x, y) for(int i=(x); i<=(y); ++i)
#define REV(i, x, y) for(int i=x; i>=y; --i)
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define X real()
#define Y imag()
#define N(x) (int)(x).size()
#define ALL(v) v.begin(), v.end()
#define SORT(v) sort(ALL(v))
#define UNIQUE(x) x.resize(unique(ALL(x)) - x.begin())
#define SPA << ' ' <<
#define SHOW(x) #x << " = " << (x)
#define ERR(x) cerr << SHOW(x) << endl;

template <class P, class Q> void mmin(P &a, const Q &b) { if (b < a) a = b; } 
template <class P, class Q> void mmax(P &a, const Q &b) { if (b > a) a = b; }
template <class P> P GCD(P a, P b)
{
	if(a<b)
		swap(a, b);
	P c;
	while(b) {
		c = a%b; a = b; b = c;
	}
	return a;
}

typedef pair<double, double> pdd;
typedef pair<int, int> pii;
typedef pair<pii, int> ppi;
typedef pair<int, pii> pip;
typedef complex<double> point;
typedef long long LL;
typedef unsigned long long ULL;

const int MAXn = 2000;
int n, m;
pii a[MAXn],b[MAXn];
vector<pip> vc1, vc2;
bool mark[MAXn][MAXn];

bool cmp(const pii &a, const pii &b) { return a.S != b.S ? a.S < b.S : a.F < b.F;}

inline bool coincide(const pip &a, const pip &b){ return b.S.F<=a.F && a.F<=b.S.S && a.S.F<=b.F && b.F<=a.S.S;}

inline bool check(int x)
{
	vc1.clear(); vc2.clear();
	FR(i, n)
		fill_n(mark[i], n, 0);

	for(int i=0; i<n;) {
		int j = i+1;
		while(j<n && a[j].F==a[i].F && a[j-1].S+2*x >= a[j].S-2*x)
			++j;
		vc1.PB(MP(a[i].F, MP(a[i].S-2*x, a[j-1].S+2*x)));
		i = j;
	}
	for(int i=0; i<m;) {
		int j = i+1;
		while(j<m && b[j].S==b[i].S && b[j-1].F+2*x >= b[j].F-2*x)
			++j;
		vc2.PB(MP(b[i].S, MP(b[i].F-2*x, b[j-1].F+2*x)));
		i = j;
	}

/*	FR(i, N(vc1))
		cerr << vc1[i].F << ' ' << vc1[i].S.F << ' ' << vc1[i].S.S << " , ";
	cerr << endl;
	FR(i, N(vc2))
		cerr << vc2[i].F << ' ' << vc2[i].S.F << ' ' << vc2[i].S.S << " , ";
	cerr << endl;*/

	FR(j, N(vc2)) {
//		ERR(j);
		vector<int> vc;
		FR(i, N(vc1))
			if(coincide(vc1[i], vc2[j])) {
//				ERR(i);
				vc.PB(i);
			}
		FR(i, N(vc)) FOR(j, i+1, N(vc))
			if(mark[vc[i]][vc[j]])
				return true;
			else
				mark[vc[i]][vc[j]] = 1;
	}
	return false;
}

inline int BS()
{
	int s = -1, e = 2e6;
	if(!check(e))
		return -1;
	
	while(s+1<e) {
		int mid = s + e >> 1;
		if(check(mid))
			e = mid;
		else
			s = mid;
	}

	return e;
}

int main()
{
	ios_base::sync_with_stdio(false);
	
	cin >> n >> m;
	FR(i, n) {
		int x, y;
		cin >> x >> y;
		a[i] = pii(x+y, x-y);
	}
	FR(i, m) {
		int x, y;
		cin >> x >> y;
		b[i] = pii(x+y, x-y);
	}
	sort(a, a+n);
	sort(b, b+m, cmp);

	int ans = BS();
//	int ans = check(1);
	if(ans==-1)
		cout << "Poor Sereja!" << endl;
	else
		cout << ans << endl;

	return 0;
}
