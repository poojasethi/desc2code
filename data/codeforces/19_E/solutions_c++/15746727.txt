#include<bits/stdc++.h>
#define For(i,x,y) for(int i = x;i <= y; ++i)
using namespace std;
const int maxn = 20000 + 10; 
int N,M;
int edge_cnt,fir[maxn],nxt[maxn],to[maxn];
void add_edge(int u,int v){nxt[++edge_cnt] = fir[u];fir[u] = edge_cnt;to[edge_cnt] = v;}
int f[maxn],c[maxn];//c数组代表该边存在于几个奇圈中 
int odd_cnt,dfn[maxn];//dfs sequence
bool vis[maxn];//is visit
void brush(int o,int fa)
{
	vis[o] = true;
	for(int u = fir[o]; u;u = nxt[u])
	{
		int &v = to[u];
		if(v == fa || dfn[v] > dfn[o])continue;
		
		if(vis[v])//为真说明为偶环
			if((dfn[o]^dfn[v])&1)
			{
				f[o]--;f[v]++;
			}
			else 
			{
				f[o]++;f[v]--;
				c[u] = 1;odd_cnt++;
			}
		else
		{
			dfn[v] = dfn[o] + 1;brush(v,o);
			f[o] += f[v];c[u] = f[v];
		}
		//将奇环中按顺序遍历玩的点++，再将点权附在边权上，若一条边为多条奇圈的
		//上的边，则可以让其边权 = 点权，
		//对于出现的偶圈，再其起点打上标记 -- 后，会与奇圈相抵消 
	}
}
int main()
{
	scanf("%d%d",&N,&M);
	For(i,1,M)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		add_edge(u,v);
		add_edge(v,u);
	}
	For(i,1,N)
		if(!vis[i])brush(i,0);
	if(!odd_cnt)
	{
		printf("%d\n",M);
		For(i,1,M)
			printf(i == 1? "%d":" %d",i);
	}
	else
	{
		int tot = 0;
        For(i,1,M*2) 
			if (c[i]==odd_cnt) 
				f[++tot]=(i+1)/2;
        printf("%d\n",tot);
        For(i,1,tot) printf("%d ",f[i]);
	}
	puts("");
	return 0;
}
  					 	     	 		 						  	  	