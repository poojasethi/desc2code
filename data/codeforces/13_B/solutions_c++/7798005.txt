#include<cstdio>
#include<algorithm>
#include<vector>
#include<cmath>
#include<cstring>
const int N=100010;
using namespace std;
double EPS = 1e-6;
int per[6][3]={{0,1,2},{0,2,1},{1,0,2},{1,2,0},{2,0,1},{2,1,0}};
char tmp[N];
struct pt{
	double x, y;
	pt(double _x=0,double _y=0):x(_x),y(_y){}
	double operator*(pt A){
		return x*A.x+y*A.y;
	}
	double operator^(pt A){
		return x*A.y-y*A.x;
	}
	void read(){
		scanf("%lf %lf",&x,&y);
	}
	void print(){
		printf("%lf %lf\n",x,y);
	}
	pt operator-(pt A){
		return pt(x-A.x,y-A.y);
	}
	pt operator+(pt A){
		return pt(x+A.x,y+A.y);
	}
	pt operator*(double A){
		return pt(x*A,y*A);
	}
	double len(){
		return sqrt((*this)*(*this));
	}
};
pt x[3],y[3];
/*
inline PT l2p(PT a,PT b,PT c,PT d) {
    PT v=d-c;
    if(abs(v^(b-a))<EPS)return PT(Magic,Magic);
    LD t=(v^(c-a))/(v^(b-a));
    return a+(b-a)*t;
}*/

bool eq(double x){
	return abs(x)<EPS;
}

bool inter2(int i,int j, pt& now){
	pt a=x[i],b=y[i],c=x[j],d=y[j];
	pt v=d-c;
	if(abs(v^(b-a))<EPS)return false;
	double t=(v^(c-a))/(v^(b-a));
	if(eq(t-1) || eq(t-0)){
		now = a+(b-a)*t;
		return true;
	}
	else return false;
}
bool inter(int i,int j, pt& now){
	pt a=x[i],b=y[i],c=x[j],d=y[j];
	pt v=d-c;
	if(abs(v^(b-a))<EPS)return false;
	double t=(v^(c-a))/(v^(b-a));
	if(t>-EPS && t<1+EPS){
		now = a+(b-a)*t;
		return true;
	}
	else return false;
}


int n;
int main(){
	int n;
	int T;
	scanf("%d",&T);
	while(T--){
		bool w=false;
		for(int i=0;i<3;i++){x[i].read();y[i].read();}
		for(int i=0;i<6;i++){
			int a=per[i][0],b=per[i][1],c=per[i][2];
			pt top,l,r;
			if(inter2(a,b,top) && inter2(b,a,top)
			&& inter(b,c,l)   && inter2(c,b,l)
			&& inter2(c,a,r)   && inter(a,c,r)){
				pt rr= r-top;
				pt ll= l-top;
				if(rr*ll>-EPS){
					double b1=(l-x[b]).len(),b2=(l-y[b]).len();
					double a1=(r-x[a]).len(),a2=(r-y[a]).len();
					if(4*a1+EPS > a2 && 4*a2+EPS > a1 
					&& 4*b1+EPS > b2 && 4*b2+EPS > b1){
						w=true;
					}

				}

			}
		
		
		}
		if(w)puts("YES");
		else puts("NO");
	}
}
