#include <iostream>
#include <algorithm>
#include <complex>
#include <cmath>
#include <cstdio>
using namespace std;
static const double EPS = 1e-9;

typedef complex<double> point;
struct line { point p, q; };

double point_on_line(const point& p, const line& a)
{
	point f = (p-a.p) / (a.q-a.p);
	return abs(f.imag())>EPS ? -1 : f.real();
}

bool isA(const line& a, const line& b, const line& c)
{
	// "first" and "second" have common endpoint
	if( a.p != b.p )
		return false;

	// the angle between them is in 0 to 90
	double ag = abs( arg( (a.q-a.p)/(b.q-b.p) ) );
	if( ag > atan2(1.0,0.0)+EPS )
		return false;

	// "third" connects two points on "first" and "second" in >1:4
	double p1 = point_on_line(c.p, a);
	double p2 = point_on_line(c.q, b);
	if( p1<0.2-EPS || 0.8+EPS<p1 )
		return false;
	if( p2<0.2-EPS || 0.8+EPS<p2 )
		return false;

	return true;
}

bool tryAllSwap(line a, line b, line c)
{
	// try all endpoint ordering
	for(int i=0; i<8; ++i)
	{
		if( isA(a,b,c) )
			return true;
		if(i%1==0) swap(a.p, a.q);
		if(i%2==0) swap(b.p, b.q);
		if(i%4==0) swap(c.p, c.q);
	}
	return false;
}

bool tryAllPerm( line ls[3] )
{
	// try all permutation of "first", "second", and "third"
	int ix[] = {0,1,2};
	do
		if( tryAllSwap( ls[ix[0]], ls[ix[1]], ls[ix[2]] ) )
			return true;
	while( next_permutation(&ix[0], &ix[3]) );
	return false;
}

int main()
{
	int t; { cin >> t; }

	while( t --> 0 )
	{
		line ls[3];
		for(int i=0; i<3; ++i)
		{
			double x1, y1, x2, y2;
			scanf("%lf%lf%lf%lf",&x1,&y1,&x2,&y2);
			ls[i].p = point(x1,y1);
			ls[i].q = point(x2,y2);
		}
		cout << (tryAllPerm(ls) ? "YES" : "NO") << endl;
	}
}
