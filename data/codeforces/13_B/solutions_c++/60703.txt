#include <stdio.h>
#include <complex>
using namespace std;
#define rep(i, n) for(int i=0; i<(int)(n); i++)

typedef complex<double> P;
double cross(const P& a, const P& b) { return imag(conj(a)*b); }
double dot(const P& a, const P& b) { return real(conj(a)*b); }

int ccw(P a, P b, P c) {
    b -= a; c -= a;
    if(cross(b, c)>0) return +1;
    if(cross(b, c)<0) return -1;
    if(dot(b, c)<0)   return +2;
    if(norm(b)<norm(c)) return -2;
    return 0;
}

P s[3][2];
bool is_a(int a, int b, int c) {
    rep(i, 2) {
        if(ccw(s[a][0], s[a][1], s[c][i])==0
            && ccw(s[b][0], s[b][1], s[c][1-i])==0
        ) {
            double ra = sqrt(norm(s[c][i]-s[a][0])/norm(s[a][1]-s[a][0]));
            double rb = sqrt(norm(s[c][1-i]-s[b][0])/norm(s[b][1]-s[b][0]));
            if(0.20<=ra && ra<=0.80 && 0.20<=rb && rb<=0.80) return true;
        }
    }
    return false;
}

int main() {
    int t;
    scanf("%d", &t);
    rep(q, t) {
        rep(i, 3) rep(j, 2) {
            int a, b;
            scanf("%d%d", &a, &b);
            s[i][j] = P(a, b);
        }
        rep(i, 3) rep(j, 3) if(i!=j) rep(id, 2) rep(jd, 2) {
            if(s[i][id]==s[j][jd]
                && dot(s[i][1-id]-s[i][id], s[j][1-jd]-s[j][jd])>=0
                && is_a(i, j, 3-i-j)) {
                printf("YES\n");
                goto next;
            }
        }
        printf("NO\n");
    next:;
    }
    return 0;
}

