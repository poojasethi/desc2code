#include <iostream>
#include <cmath>
#include <vector>
#include <map>
#include <set>
#include <queue>
#include <algorithm>
#include <string>
#include <sstream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cassert>
#include <ctime>
#include <cctype>

using namespace std;
typedef long long int64;
const int inf = 0x3f3f3f3f;
typedef double real;
const real eps = 1e-6;
typedef pair<int,int> pip;
#define Eo(x) { cerr << #x << " = " << (x) << endl; }

struct point{
	int x,y;
	point(){}
	point(int x_,int y_):x(x_),y(y_){}
	point(const point& t):x(t.x),y(t.y){}
	bool operator==(const point& t)const{
		return x == t.x && y == t.y;
	}
}a[3][2];

point operator-(const point& a, const point& b){
	return point(a.x-b.x,a.y-b.y);
}

int64 scal(const point& a, const point& b){
	return int64(a.x)*int64(b.x)+int64(a.y)*int64(b.y);
}
int64 vect(point  d, point v){
	int64 z = int64(d.x)*int64(v.y)-int64(d.y)*int64(v.x);
	return z;
}

bool good(const point& a, point p1, point p2){
	point d(p2-p1);
	point v(a-p1);
	int64 z = vect(d,v);
	if (z) return false;
	if (d.x > 0 && v.x < 0) return false;
	if (d.y > 0 && v.y < 0) return false;
	if (d.x < 0 && v.x > 0) return false;
	if (d.y < 0 && v.y > 0) return false;
	int64 l1 = scal(d,d);
	int64 l2 = scal(v,v);
	real r1 = sqrt(real(l1));
	real r2 = sqrt(real(l2));
	bool res = r2 > 0.2*r1-eps && r2 < 0.8*r1+eps;
	return res;
}

int main(){
	int T; scanf("%d",&T);
	for (int _ = 0; _ < T; _++){
		for (int i = 0; i < 3; i++){
			cin >> a[i][0].x >> a[i][0].y >> a[i][1].x >> a[i][1].y;
		}
		bool ok = false;
		for (int i = 0; i <3 ;i++){
			for (int j = i+1; j < 3; j++){
				for (int k = 0; k < 2; k++)
					for (int q = 0; q < 2; q++){
						if (a[i][k] == a[j][q]){
							point d1(a[i][1-k]-a[i][k]);
							point d2(a[j][1-q]-a[j][q]);
							if (scal(d1,d2) >= 0 && vect(d1,d2) != 0){
								int z = 0;
								for (;z == i || z == j;z++);
								if (good(a[z][0],a[i][0],a[i][1]) && good(a[z][1],a[j][0],a[j][1])) ok = true;
								if (good(a[z][1],a[i][0],a[i][1]) && good(a[z][0],a[j][0],a[j][1])) ok = true;
							}
						}
					}
			}
		}
		puts(!ok ? "NO" : "YES");
	}
	return 0;
}

