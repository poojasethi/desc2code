#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const double eps=1e-10;
typedef long long LL;
struct point {
	LL x,y;
	friend bool operator == (point a,point b)
	{
		return a.x==b.x && a.y==b.y;
	}
	friend LL dot(point a,point b,point c)
	{
		return (b.x-a.x)*(c.x-a.x)+(b.y-a.y)*(c.y-a.y);
	}
	friend LL cross(point a,point b,point c)
	{
		return (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);
	}
	friend bool operator < (point a, point b)
	{
		return a.x==b.x?a.y<b.y:a.x<b.x;
	}
} p[5];
struct seg {
	point l,r;
	friend bool same_point(seg a,seg b)
	{
		return a.l==b.l||a.r==b.r||a.l==b.r||a.r==b.l;
	}
} rec[3],a,b,c;

bool calc(seg a,seg b,seg c)
{
	if (!same_point(a,b)) return 0;
	
	// same point
	
	p[0]=a.l,p[1]=a.r,p[2]=b.l,p[3]=b.r;
	sort(p,p+4);
	point t;
	for (LL i=1; i<4; i++) 
		if (p[i]==p[i-1]) t=p[i-1];
	if (unique(p,p+4)-p!=3) return 0;
	for (LL i=0; i<3; i++) 
		if (p[i]==t) 
			swap(p[i],p[0]);
	if (dot(p[0],p[1],p[2])<0) return 0;
	
	// 90 degrees
	
	if (cross(a.l,a.r,c.l)) swap(c.l,c.r);
	if (cross(a.l,a.r,c.l)||cross(b.l,b.r,c.r)) return 0;
	LL A=dot(a.l,a.r,a.r), B=dot(a.l,a.r,c.l);
	if (B*5<A || B*5>A*4) return 0;
	A=dot(b.l,b.r,b.r), B=dot(b.l,b.r,c.r);
	if (B*5<A || B*5>A*4) return 0;
	
	// 1/4's check
	
	return 1;
}

LL test;
int main()
{
	for (scanf("%I64d",&test);test;test--)
	{
		for (LL i=0; i<3; i++) 
			scanf("%I64d%I64d%I64d%I64d",&rec[i].l.x,&rec[i].l.y,&rec[i].r.x,&rec[i].r.y);
		a=rec[0],b=rec[1],c=rec[2];
		puts(calc(a,b,c)||calc(a,c,b)||calc(b,c,a)?"YES":"NO");
	}
}