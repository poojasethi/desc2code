#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>
#include <complex>
#include <cmath>
#include <cstdio>
using namespace std;
typedef complex<double> point;
static const double EPS = 1e-9;

struct line
{
	point p, q;
};

double pon(const line& a, const point& p)
{
	point v = p - a.p;
	point u = a.q - a.p;
	point f = v/u;
	if( abs(f.imag())>EPS )
		return -1;
	return f.real();
}

bool isA_(const line& a, const line& b, const line& c)
{
	if( a.p != b.p )
		return false;
	double ag = arg( (a.q-a.p) / (b.q-b.p) );
	if( abs(ag) > M_PI/2+EPS )
		return false;

	double p1 = pon(a, c.p);
	double p2 = pon(b, c.q);
	if( p1<0.2-EPS || 0.8+EPS<p1 )
		return false;
	if( p2<0.2-EPS || 0.8+EPS<p2 )
		return false;

	return true;
}

bool isA(const line& a, const line& b, const line& c)
{
	line aa, bb, cc;
	for(int i=0; i<8; ++i)
	{
		aa.p = i&1 ? a.p : a.q;
		aa.q = i&1 ? a.q : a.p;
		bb.p = i&2 ? b.p : b.q;
		bb.q = i&2 ? b.q : b.p;
		cc.p = i&4 ? c.p : c.q;
		cc.q = i&4 ? c.q : c.p;
		if( isA_(aa,bb,cc) )
			return true;
	}
	return false;
}

int main()
{
	int t;
	cin >> t;
	while(t--)
	{
		line ls[3];
		for(int i=0; i<3; ++i)
		{
			double x1, y1, x2, y2;
//			scanf("%lf%lf%lf%lf",&x1,&y1,&x2,&y2);
			cin >> x1 >> y1 >> x2 >> y2;
			ls[i].p = point(x1,y1);
			ls[i].q = point(x2,y2);
		}

		if( isA(ls[0], ls[1], ls[2])
		 || isA(ls[0], ls[2], ls[1])
		 || isA(ls[1], ls[0], ls[2])
		 || isA(ls[1], ls[2], ls[0])
		 || isA(ls[2], ls[0], ls[1])
		 || isA(ls[2], ls[1], ls[0]) )
			cout << "YES" << endl;
		else
			cout << "NO" << endl;
	}
}
