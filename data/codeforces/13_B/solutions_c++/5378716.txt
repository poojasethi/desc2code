// in the name of god

#include<iostream>
#include<algorithm>
#include<complex>
#include<vector>
#include<cmath>

#define X real()
#define Y imag()

using namespace std;

typedef long long ll;
typedef complex<ll> point;

ll t;

double x1,x2,y3,y2;

point p[5][5];

ll operator % (const point &a,const point &b){
	point c=conj(a)*b;
	return c.X;
}

ll operator | (const point &a,const point &b){
	point c=conj(a)*b;
	return c.Y;
}

bool OK(point a,point b,point c){
	if(c.X<b.X)
		swap(b,c);
	if(((a-b)|(a-c)) == 0 && a.X>=b.X && a.X<=c.X)
		return true;
	return false;
}

double L(point a,point b){
	return sqrt((a.X-b.X)*(a.X-b.X)+(a.Y-b.Y)*(a.Y-b.Y));
}

int main(){
	ios::sync_with_stdio(false);
	cin>>t;
	while(t--){	
		for(int j=0;j<3;j++)
			for(int k=0;k<2;k++)
				cin>>p[j][k].X>>p[j][k].Y;
		for(int i=0;i<3;i++){
			for(int j=i+1;j<3;j++){
				for(int u=0;u<2;u++){
					for(int r=0;r<2;r++){
						if(p[i][0]==p[j][0] && ((p[i][1]-p[i][0]) | (p[j][1]-p[j][0])) !=0 && ((p[i][1]-p[i][0]) % (p[j][1]-p[j][0])) >= 0 ){
							int x;
							bool mark[3]={};
							mark[i]=true;
							mark[j]=true;
							for(int o=0;o<3;o++)
								if(!mark[o])
									x=o;
							for(int o=0;o<2;o++){
								if( OK(p[x][0],p[i][0],p[i][1]) && OK(p[x][1],p[j][0],p[j][1])){
									x1=L(p[x][0],p[i][0]);
									y3=L(p[x][0],p[i][1]);
									x2=L(p[x][1],p[j][0]);
									y2=L(p[x][1],p[j][1]);
									if(x1>y3)
										swap(x1,y3);
									if(x2>y2)
										swap(x2,y2);
									if((x1/y3) >= 0.25 && (x2/y2) >= 0.25 ){
										cout<<"YES"<<endl;
										goto abc;
									}
								}
								swap(p[x][0],p[x][1]);
							}
						}		
						swap(p[j][0],p[j][1]);
					}
					swap(p[i][0],p[i][1]);
				}
			}
		}
		cout<<"NO"<<endl;
		abc:;
	}
	return 0;
}
