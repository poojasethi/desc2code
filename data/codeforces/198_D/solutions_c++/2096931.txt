#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

#define rep(I,L,R) for(int I=L;I<=R;++I)
#define repd(I,R,L) for(int I=R;I>=L;--I)

const int N = 55;

typedef int cube[N][N][N];

cube M[N];

void viewLayer (cube X, int n, int x, int y, int z)
{
	if (x != -1)
		rep(y, 1, n) rep(z, 1, n)
			printf("%d%c", X[x][y][z], " \n"[z == n]);
	if (y != -1)
		rep(x, 1, n) rep(z, 1, n)
			printf("%d%c", X[x][y][z], " \n"[z == n]);
	if (z != -1)
		rep(x, 1, n) rep(y, 1, n)
			printf("%d%c", X[x][y][z], " \n"[y == n]);
}

//expand : n->n+1
//1:(1,1,1) n^3:(1,1,n)
void expandEven (int n, cube S, cube T) // n % 2==0
{
	int cp = 0;
	memcpy(T, S, sizeof(cube));
	// Top layer N * N
	rep(y, 1, n)
		if (y & 1) rep(x, 1, n) T[x][y][0] = cp--;
		else repd(x, n, 1) T[x][y][0] = cp--;
	// Front Layer N * (N+1)
	cp = n * n * n + 1;
	rep(x, 1, n)
		if (x & 1) repd(z, n, 0) T[x][0][z] = cp++;
		else rep(z, 0, n) T[x][0][z] = cp++;
	// Right Layer (N+1) * (N+1)
	rep(y, 0, n)
		if (!(y & 1)) repd(z, n, 0) T[n + 1][y][z] = cp++;
		else rep(z, 0, n) T[n + 1][y][z] = cp++;
	// Rotate the cube
	static cube Q;
	rep(x, 1, n + 1) rep(y, 0, n) rep(z, 0, n)
		Q[n + 1 - y][z + 1][x] = T[x][y][z];
	// Relabel the cube
	int delta = (n + 1) * (n + 1) * (n + 1) - --cp;
	rep(x, 1, n + 1) rep(y, 1, n + 1) rep(z, 1, n + 1)
		Q[x][y][z] += delta;
	memcpy(T, Q, sizeof(cube));
}

void expandOdd (int n, cube S, cube T) // n % 2 == 1
{
	int cp = 0;
	memcpy(T, S, sizeof(cube));
	// Top Layer N * N
	rep(y, 1, n - 2)
		if (y & 1) rep(x, 1, n) T[x][y][0] = cp--;
		else repd(x, n, 1) T[x][y][0] = cp--;
	repd(x, n, 1)
		if (x & 1) T[x][n - 1][0] = cp--, T[x][n][0] = cp--;
		else T[x][n][0] = cp--, T[x][n - 1][0] = cp--;
	// Front Layer N * (N+1)
	cp = n * n * n + 1;
	rep(x, 1, n)
		if (x & 1) repd(z, n, 0) T[x][0][z] = cp++;
		else rep(z, 0, n) T[x][0][z] = cp++;
	// Right Layer (N+1) * (N+1)
	rep(y, 0, n)
		if (!(y & 1)) rep(z, 0, n) T[n + 1][y][z] = cp++;
		else repd(z, n, 0) T[n + 1][y][z] = cp++;
	// Rotate the cube
	static cube Q;
	rep(x, 1, n + 1) rep(y, 0, n) rep(z, 0, n)
		Q[n + 1 - y][z + 1][x] = T[x][y][z];
	// Relabel the cube
	int delta = (n + 1) * (n + 1) * (n + 1) - --cp;
	rep(x, 1, n + 1) rep(y, 1, n + 1) rep(z, 1, n + 1)
		Q[x][y][z] += delta;
	memcpy(T, Q, sizeof(cube));
}

int main ()
{
	int n; scanf("%d", &n);
	if (n == 1) { puts("1"); return 0; }
	M[2][1][1][1] = 1; M[2][2][1][1] = 2;
	M[2][1][2][1] = 4; M[2][2][2][1] = 3;
	M[2][1][2][2] = 5; M[2][2][2][2] = 6;
	M[2][1][1][2] = 8; M[2][2][1][2] = 7;
	for (int i = 2; i < n; ++i)
		if (i & 1) expandOdd(i, M[i], M[i + 1]);
		else expandEven(i, M[i], M[i + 1]);
	rep(i, 1, n) viewLayer(M[n], n, -1, -1, i), puts("");
	return 0;
}

