#include <map>
#include <set>
#include <cmath>
#include <stack>
#include <queue>
#include <string>
#include <vector>
#include <bitset>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <iostream>
#include <algorithm>
//#include <sys/time.h>
using namespace std;
#define li        long long int
#define rep(i,to) for(li i=0;i<((li)(to));++i)
#define pb        push_back
#define sz(v)     ((li)(v).size())
#define bit(n)    (1ll<<(li)(n))
#define all(vec)  (vec).begin(),(vec).end()
#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)
#define MP        make_pair
#define F         first
#define S         second


#define MAX 55
li cnt = 1;
li ans[MAX][MAX][MAX];
li n;
li x, y, z;

li dx[] = {0,1,0,0,-1,0};
li dy[] = {0,0,-1,0,0,1};
li dz[] = {-1,0,0,1,0,0};

li tri(li n)
{
	return n * n * n;
}

void SET()
{
	if(ans[x][y][z] != -1) return;
	ans[x][y][z] = cnt++;
}

pair<li, pair<li, li> > get(set<pair<li, pair<li, li> > > s, li sx, li sy, li sz)
{
	pair<pair<li, li>, pair<li, pair<li, li> > > best;
	best = MP(MP(-1, -1), MP(-1, MP(-1, -1)));
	rep(dir, 6){
		li xx = x + dx[dir];
		li yy = y + dy[dir];
		li zz = z + dz[dir];
		if(s.find(MP(xx, MP(yy, zz))) == s.end()) continue;
		li d0 = max(abs(sx - xx), max(sy - yy, sz - zz));
		li d1 = abs(sx - xx) + abs(sy - yy) + abs(sz - zz);
		best = max(best, MP(MP(d0, d1), MP(xx, MP(yy, zz))));
	}
	return best.S;
}

void getNext(li &x, li &y, li &z, li dir)
{
	x += dx[dir];
	y += dy[dir];
	z += dz[dir];
}

int main()
{
	memset(ans, -1, sizeof(ans));
	cin >> n;
	x = 0;
	y = n - 2;
	z = n - 2;
	
	if(n == 1){
		cout << 1 << endl;
		return 0;
	}
	
	SET();
	for(li t = 0; t < n - 2; t++){
		if(t % 2){
		
			for(int turn = 0; t <= x; x--, turn++){
				SET();
				if(turn % 2){
					while(t <= --z) SET();
					z = t;
					while(++y <= n - 2) SET();
					y = n - 2;
				}else{
					while(t <= --y) SET();
					y = t;
					while(++z <= n - 2) SET();
					z = n - 2;
				}
			}
			x++;
			
while(true){
	pair<pair<li, li>, pair<li, pair<li, li> > > best;
	best = MP(MP(-1, -1), MP(-1, MP(-1, -1)));
	rep(dir, 6){
		li xx = x + dx[dir];
		li yy = y + dy[dir];
		li zz = z + dz[dir];
		if(zz < t + 1 || n - 1 <= zz) continue;
		if(yy < t + 1 || n - 1 <= yy) continue;
		if(xx != x) continue;
		if(ans[xx][yy][zz] != -1) continue;
		li d0 = max(abs(x - xx), max((n - 1) - yy, (n - 1) - zz));
		li d1 = abs(x - xx) + abs((n - 1) - yy) + abs((n - 1) - zz);
		best = max(best, MP(MP(d0, d1), MP(xx, MP(yy, zz))));
	}
	if(best.F.F == -1) break;
	x = best.S.F;
	y = best.S.S.F;
	z = best.S.S.S;
	SET();
}


			
			
			
		}else{

			for(int turn = 0; t <= z; z--, turn++){
				SET();
				if(turn % 2){
					while(t <= --x) SET();
					x = t;
					while(++y <= n - 2) SET();
					y = n - 2;
				}else{
					while(t <= --y) SET();
					y = t;
					while(++x <= n - 2) SET();
					x = n - 2;
				}
			}
			z++;
			
			
while(true){
	pair<pair<li, li>, pair<li, pair<li, li> > > best;
	best = MP(MP(-1, -1), MP(-1, MP(-1, -1)));
	rep(dir, 6){
		li xx = x + dx[dir];
		li yy = y + dy[dir];
		li zz = z + dz[dir];
		if(xx < t + 1 || n - 1 <= xx) continue;
		if(yy < t + 1 || n - 1 <= yy) continue;
		if(zz != z) continue;
		if(ans[xx][yy][zz] != -1) continue;
		li d0 = max(abs((n - 1) - xx), max((n - 1) - yy, z - zz));
		li d1 = abs((n - 1) - xx) + abs((n - 1) - yy) + abs(z - zz);
		best = max(best, MP(MP(d0, d1), MP(xx, MP(yy, zz))));
	}
	if(best.F.F == -1) break;
	x = best.S.F;
	y = best.S.S.F;
	z = best.S.S.S;
	SET();
}


			
			
		}

		if(t % 2) x++;
		else z++;
		SET();
		
	}
	
	x++;
	SET();
	y++;
	SET();
	z++;
	SET();
	y--;
	SET();
	x--;
	SET();
	y++;
	SET();
	
	li dir = 0;
	
	while(cnt <= tri(n)){
		li next_dir = (dir + 1) % 6;
		{
			getNext(x, y, z, next_dir);
			if(0 <= x && x < n)
			if(0 <= y && y < n)
			if(0 <= z && z < n)
			if(x == n - 1 || y == n - 1 || z == n - 1)
			if(ans[x][y][z] == -1)
				dir = next_dir;
			getNext(x, y, z, (next_dir + 3) % 6);
		}
		getNext(x, y, z, dir);
		SET();
	}
	
	rep(i, n){
		rep(j, n){
			rep(k, n) printf("%d ", (int)ans[i][j][k]);
			printf("\n");
		}
		printf("\n");
	}
}
