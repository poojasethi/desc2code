#include <stdio.h>
#include <algorithm>

using namespace std;


const int maxn = 100010*4;

int val[maxn];
int tree[maxn][2];

int low[maxn];
int high[maxn];

struct NODE
{
	int v, i;
	bool operator < (const NODE &o) const
	{
		return v<o.v;
	}
} num[maxn];

int parent[maxn];
int n, k, t;

double e[maxn], ans[maxn];

void DFS(int x)
{
	if (tree[x][0]==0 && tree[x][1]==0)
	{
		low[x]=high[x]=val[x];
		return;
	}
	if ( val[tree[x][0]] > val[tree[x][1]])
		swap(tree[x][0], tree[x][1]);
	DFS(tree[x][0]);
	DFS(tree[x][1]);
	low[x] = low[ tree[x][0] ];
	high[x] = high[ tree[x][1] ];
}

void solve(int x, long long s, int num)
{
	if (tree[x][0]==0 && tree[x][1]==0)
	{
		e[x] = (double) s / (double) num;
		return;
	}
	solve( tree[x][0], s+low[ tree[x][1] ], num+1);
	solve( tree[x][1], s+high[ tree[x][0] ], num+1);
}

void put(int x, int maxnum)
{
	if (tree[x][0]==0 && tree[x][1]==0)
	{
		while (num[t].v<maxnum && t<k)
			ans[num[t++].i] = e[x];
		return;
	}
	put( tree[x][0], val[x]);
	put( tree[x][1], maxnum);
}

int main()
{
	int i, p, root;
	scanf("%d", &n);
	for (i=1; i<=n; i++)
	{
		scanf("%d%d", &p, &val[i]);
		parent[i]=p;
		if (p==-1) root=i;
		if (tree[p][0]==0) tree[p][0]=i;
		else tree[p][1]=i;
	}
	DFS(root);
	solve(root, 0, 0);
	scanf("%d", &k);
	for (i=0; i<k; i++)
	{
	  scanf("%d", &num[i].v);
	  num[i].i = i;
	}
	sort(num, num+k);
	t=0;
	put(root, 0x7fffffff);
	for (i=0; i<k; i++)
	  printf("%.12lf\n", ans[i]);
	return 0;
}
/*
7
-1 8
1 4
1 12
2 2
2 6
3 10
3 14
16
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16




3
-1 5
1 3
1 7
6
1
2
4
6
8
9

*/