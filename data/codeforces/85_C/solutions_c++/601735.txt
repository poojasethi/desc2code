#include <cstdio>
#include <iostream>
#include <algorithm>

#define fi first
#define se second
using namespace std;

const int MAXN = 100010;

typedef pair<int,int> II;

int n,degree[MAXN],m;
double mark[MAXN],dn[MAXN][3],dp[MAXN];
II ar[MAXN],node[MAXN];
bool leaf[MAXN];

void g(int p,int k){
	
	dn[p][0]=dn[p][1]=mark[p];
	degree[p]=k;
	if(ar[p].fi)
	{
		g(ar[p].fi,k+1);
		g(ar[p].se,k+1);
		
		dn[p][0]=dn[ar[p].fi][0];
		dn[p][1]=dn[ar[p].se][1];
	}
}

void f(int p)
{
	dp[ar[p].fi]=dp[p]+dn[ar[p].se][0];
	dp[ar[p].se]=dp[p]+dn[ar[p].fi][1];
	leaf[p]=true;
	
	if(ar[p].fi){
		leaf[p]=false;
		f(ar[p].fi);
		f(ar[p].se);
    }
}

int main(){
	
	int a,b,root;
	
	cin >> n ;
	
	for(int i=1;i<=n;i++)
	{
		cin >> a >> b;
		
		mark[i]=b;
		node[i]=II(b,i);
		
		if(a==-1)
			root=i;
		else if(!ar[a].fi)
			ar[a].fi=i;
		else
			ar[a].se=i;
	}
	
	for(int i=1;i<=n;i++)
		if(ar[i].fi && mark[ar[i].fi]>mark[ar[i].se])
			swap(ar[i].fi,ar[i].se);
	
	g(root,0);
		
	f(root);
	
	sort(node+1,node+n+1);
	
	cin >> m ;
	
	for(int i=1,v;i<=m;i++)
	{
		cin >> v;
		
		int tmp = lower_bound(node+1,node+n+1,II(v,0))-node;
		
		if(leaf[node[tmp].se]==false || tmp == n+1)	tmp--;
		
		printf("%.20lf\n",dp[node[tmp].se]/degree[node[tmp].se]);
	}
	
	return 0;
}
