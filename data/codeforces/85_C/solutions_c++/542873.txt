#include <map>
#include <set>
#include <cmath>
#include <stack>
#include <queue>
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
using namespace std;
#define li		long long
#define rep(i,to)	for(li i=0;i<((li)to);i++)
#define pb		push_back
#define sz(v)		((li)v.size())


#define MAX 100005
li L[MAX];
li R[MAX];
li n;
li maxi[MAX];
li mini[MAX];
li num[MAX];
vector<li> edge[MAX];
vector<pair<li,double> > ans;
void dfs(li pos){
	if(sz(edge[pos])){
		dfs(edge[pos][0]);
		dfs(edge[pos][1]);
		mini[pos]=R[edge[pos][0]];
		maxi[pos]=L[edge[pos][1]];
		L[pos]=L[edge[pos][0]];
		R[pos]=R[edge[pos][1]];
	}else{
		L[pos]=R[pos]=mini[pos]=maxi[pos]=num[pos];
	}
}

void cal(li pos,li r,double sum,double depth){
	if(sz(edge[pos])){
		cal(edge[pos][0],num[pos]-1,sum+maxi[pos],depth+1);
		cal(edge[pos][1],r,sum+mini[pos],depth+1);
	}else{
		ans.pb(make_pair(r,sum/depth));
	}
}
		

int main(){
	cin>>n;
	li root=0;
	rep(i,n){
		li a,b;
		cin>>a>>b;
		num[i]=b;
		if(a==-1) root=i;
		else edge[a-1].pb(i);
	}
	rep(i,MAX)if(sz(edge[i])&&num[edge[i][1]]<num[edge[i][0]])swap(edge[i][0],edge[i][1]);
	dfs(root);
	cal(root,1000000005,0,0);
	sort(ans.begin(),ans.end());
	cin>>n;
	rep(i,n){
		li tmp;
		cin>>tmp;
		printf("%.20lf\n",lower_bound(ans.begin(),ans.end(),make_pair(tmp,0.0))->second);
	}
}
