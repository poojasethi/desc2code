#include<cstdio>
#include<vector>
#include<algorithm>

#define rep(i,n) for(int i=0;i<(n);i++)

using namespace std;

typedef pair<int,int> pii;

int n,key[100000];
vector<int> tree[100000];

int l_min[100000],l_max[100000],r_min[100000],r_max[100000];

void dfs1(int u){
	if(tree[u].empty()){
		l_min[u]=l_max[u]=r_min[u]=r_max[u]=key[u];
		return;
	}

	int vl=tree[u][0]; dfs1(vl);
	int vr=tree[u][1]; dfs1(vr);

	l_min[u]=l_min[vl];
	l_max[u]=r_max[vl];
	r_min[u]=l_min[vr];
	r_max[u]=r_max[vr];
}

double ex[100000];

void dfs2(int u,double sum,int m){
	if(tree[u].empty()){
		ex[u]=sum/m;
		return;
	}

	int vl=tree[u][0]; dfs2(vl,sum+r_min[u],m+1);
	int vr=tree[u][1]; dfs2(vr,sum+l_max[u],m+1);
}

int main(){
	int root;
	scanf("%d",&n);
	rep(u,n){
		int p; scanf("%d%d",&p,key+u); p--;
		if(p==-2) root=u;
		else{
			tree[p].push_back(u);
			if(tree[p].size()==2){
				int &v1=tree[p][0],&v2=tree[p][1];
				if(key[v1]>key[v2]) swap(v1,v2);
			}
		}
	}

	dfs1(root);
	dfs2(root,0,0);

	static pii order[100000];
	rep(u,n) order[u]=make_pair(key[u],u);
	sort(order,order+n);

	int q; scanf("%d",&q);
	while(q--){
		int k; scanf("%d",&k);
		pii *p=lower_bound(order,order+n,make_pair(k,-1));
		if(p==order+n || !tree[p->second].empty()) p--;

		printf("%.15f\n",ex[p->second]);
	}

	return 0;
}
