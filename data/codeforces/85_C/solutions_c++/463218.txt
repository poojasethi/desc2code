#include <algorithm>
#include <cstring>
#include <cstdio>

using namespace std;

const int MAXN = 100000;

int n, tree[MAXN][2], t_val[MAXN], root;
int h[MAXN];
double l_val[MAXN], r_val[MAXN], av[MAXN];
pair<int, int> z[MAXN];
int r[MAXN];

void dfs1(int u, int cur_h)
{
	h[u] = cur_h;

	if (tree[u][0] == -1)
	{
		l_val[u] = t_val[u]; r_val[u] = t_val[u];
		return;
	}

	dfs1(tree[u][0], cur_h+1);
	dfs1(tree[u][1], cur_h+1);

	l_val[u] = l_val[tree[u][0]]; r_val[u] = r_val[tree[u][1]];
}

void dfs2(int u)
{
	if (tree[u][0] == -1)
	{
		return;
	}

	av[tree[u][0]] += (av[u] + l_val[tree[u][1]]);
	av[tree[u][1]] += (av[u] + r_val[tree[u][0]]);

	dfs2(tree[u][0]);
	dfs2(tree[u][1]);
}

void solve()
{
	dfs1(root, 1);
	dfs2(root);

	for (int i = 0; i < n; ++i)
	{
		z[i] = make_pair(t_val[i], i);
	}

	sort(&z[0], &z[n]);

	for (int i = 0; i < n; ++i)
	{
		r[i] = z[i].first;
	}

	int nq;
	scanf("%d", &nq);

	for (int q = 0; q < nq; ++q)
	{
		int cur;
		scanf("%d", &cur);

		int t = lower_bound(&r[0], &r[n], cur) - &r[0];
		if (t == n || tree[z[t].second][0] != -1) --t;

		printf("%.10lf\n", av[z[t].second] / (h[z[t].second] - 1));
	}
}

int main()
{
//	freopen("input.txt", "r", stdin);

	memset(tree, -1, sizeof(tree));
	
	scanf("%d", &n);
	for (int i = 0; i < n; ++i)
	{
		int p, v;
		scanf("%d%d", &p, &v);
		t_val[i] = v;

		if (p == -1) { root = i; continue; }
		if (tree[p-1][0] == -1) tree[p-1][0] = i; else tree[p-1][1] = i;
	}

	for (int u = 0; u < n; ++u)
		if (tree[u][0] != -1 && t_val[tree[u][0]] > t_val[tree[u][1]])
			swap(tree[u][0], tree[u][1]);

	solve();

	return 0;
}
