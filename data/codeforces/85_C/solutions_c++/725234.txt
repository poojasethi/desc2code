#include <map>
#include <set>
#include <cmath>
#include <stack>
#include <queue>
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <iostream>
#include <algorithm>
using namespace std;
#define li       	long long int
#define rep(i,to)	for(li i=0;i<((li)(to));i++)
#define pb       	push_back
#define sz(v)    	((li)v.size())
#define bit(n)   	(1ll<<(li)(n))


#define MAX 100005
li LEFT[MAX],RIGHT[MAX];
li maxi[MAX],mini[MAX];
li num[MAX];
vector<li> E[MAX];
vector<pair<li,double> > ans;

void make(li pos){
	if(sz(E[pos])){
		make(E[pos][0]);
		make(E[pos][1]);
		maxi[pos]=maxi[E[pos][1]];
		mini[pos]=mini[E[pos][0]];
		LEFT[pos]=maxi[E[pos][0]];
		RIGHT[pos]=mini[E[pos][1]];
	}else{
		mini[pos]=maxi[pos]=LEFT[pos]=RIGHT[pos]=num[pos];
	}
}

void dfs(li pos,li r,double sum,double depth){
	if(sz(E[pos])){
		dfs(E[pos][0],num[pos],RIGHT[pos]+sum,depth+1);
		dfs(E[pos][1],r,LEFT[pos]+sum,depth+1);
		return;
	}
	ans.pb(make_pair(max(r,num[pos]),sum/depth));
}
		
int main(){
	li n,root;
	cin>>n;
	rep(i,n){
		li a,b;
		cin>>a>>num[i];
		if(a==-1) root=i;
		else E[a-1].pb(i);
	}
	rep(i,n)if(sz(E[i])&&num[E[i][1]]<num[E[i][0]]) swap(E[i][0],E[i][1]);
	make(root);
	dfs(root,bit(60),0,0);
	sort(ans.begin(),ans.end());
	cin>>n;
	rep(i,n){
		li tmp;
		cin>>tmp;
		vector<pair<li,double> >::iterator it;
		it=lower_bound(ans.begin(),ans.end(),make_pair(tmp,0.0));
		if(it==ans.end()) it--;
		printf("%0.20lf\n",it->second);
	}
}
