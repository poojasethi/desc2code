#include <bits/stdc++.h>

using namespace std;

#define ALL(c) c.begin(), c.end()
#define SZ(x) ((int)(x).size())
#define MP make_pair

#define DB(x) cerr << __LINE__ << ": " << #x << " = " << x << endl;
#define LEFT(x) 2*x+1
#define RIGHT(x) 2*x+2

typedef long long int64;
typedef unsigned long long uint64;
typedef complex<double> point;
typedef vector<point> polygon;
typedef pair<int, int> pii;
typedef vector<int> vi;

const int INF = 1 << 30;
const double EPS = 1e-7;

/*
  UH++
  Universidad de La Habana
*/

map< string, vector<int> > pos;
map< pair<string,string>, int > memo;

string s;

void build()
{
	for(int i = 0; i < (int)s.length(); i++)
	{
		for(int k = 1; i + k <= (int)s.length() && k <= 4; k++)
			pos[s.substr(i,k)].push_back(i);
	}
}

int solve(vector<int> &posa, vector<int> &posb, string &a, string &b)
{
	if( memo[MP(a,b)] ) return memo[MP(a,b)];

	int na = a.length();
	int nb = b.length();

	int best = INF;
	int j = 0;
	for(int i = 0; i < (int)posa.size() && j < (int)posb.size(); i++)
	{
		while(j < (int)posb.size() && posb[j] < posa[i])
			j++;
		if(j < (int)posb.size())
		{
			int r = max(posb[j] + nb - 1,posa[i] + na - 1);
			int l = posa[i];
			best = min(best,r - l + 1);
		}
	}
	return memo[MP(a,b)] = best;
}

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	cin >> s;

	build();

	int q; cin >> q;

	for(int i = 0; i < q; i++)
	{
		string a,b; cin >> a >> b;
		int ans = min(solve(pos[a],pos[b],a,b),
					  solve(pos[b],pos[a],b,a));

		if(ans < INF) cout << ans << endl;
		else cout << -1 << endl;
	}

    return 0;
}
