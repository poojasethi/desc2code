#include <functional>
#include <algorithm>
#include <iostream>
#include <numeric>
#include <cassert>
#include <cstdlib>
#include <string>
#include <cstring>
#include <cstdio>
#include <vector>
#include <ctime>
#include <queue>
#include <set>
#include <map>
using namespace std;

#define rep(i,a,b) for (int i = a; i <= b; ++i)
#define dep(i,a,b) for (int i = a; i >= b; --i)

int f[5010][5010],g[5010][5010],w[5010][5010];
bool a[5010][5010];
int L;
char S[5010];

int cal(int x, int y) {
	if (x>L||y>L) return 0;
	if (f[x][y] >= 0) return f[x][y];
	int ans = 0;
//	ans = max(cal(x+1,y), cal(x,y+1));
	if (S[x] == S[y]) ans = max(ans, cal(x+1,y+1)+1);
	return f[x][y] = ans;
}
int findk(int x, int y) {
	int l = y-x;
	if (y+l-1 > L) return -1;
	int z = cal(x,y);
	if (z >= l) return y+l;
	if (S[x+z]<S[y+z]) return y+l;
	return y+l+1;
}
#define M 1000000007 
int main() {
	scanf("%s", S+1);
	S[0] = '0';
	L = strlen(S+1);
	memset(f,-1,sizeof(f));
	memset(w,0x7f,sizeof(w));
	int inf=1<<30,ans2=inf;
	g[1][2]=w[1][2]=1;
	rep(i,2,L)
	rep(j,1,i-1) {
		if (S[j] == '0'||!g[j][i]) continue;
		
		int k = findk(j,i);
		if (S[i]=='1'&&S[j]=='1'&&k>0) {
			g[i][k]=(g[i][k]+g[j][i])%M;
			if (w[j][i]<inf)
			w[i][k]=min(w[i][k],w[j][i]+1);
		}
		g[j][i+1]=(g[j][i+1]+g[j][i])%M;		
		w[j][i+1]=min(w[j][i+1],w[j][i]);
	}
	int ans1=0;
	rep(i,1,L) if (S[i]=='1') ans1=(ans1+g[i][L+1])%M;
	dep(i,L,1) {
		if (!g[i][L+1]) continue;
		if (L-i>20) {
			if (ans2<inf) break;
			ans2=0;
			rep(t,i,L) ans2=(ans2*2+S[t]-'0')%M;
			ans2=(ans2+w[i][L+1])%M;
			break;
		}
		else
		{
			int _=0;
			rep(t,i,L) _=(_*2+S[t]-'0')%M;
			ans2=min(ans2,_+w[i][L+1]);
		}
	}
	printf("%d\n%d\n",ans1,ans2);
	return 0;
}