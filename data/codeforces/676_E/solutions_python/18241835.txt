def f(n,k,p,q_count):
    yourTurn = ((n+1) - q_count) % 2 == 1
    if k == 0:
        if p[0] == '?' and yourTurn:
            return "Yes"
        if p[0] == 0:
            return "Yes"
        if p[0] == '?' and not yourTurn:
            return "No"
        if p[0] != 0:
            return "No"
    if (n % 2 == 0) and (q_count > 0):
        return "No"
    if (n % 2 == 1) and (q_count > 0):
        return "Yes"
    #last case: everything is filled up
    

    primes = [218657,394787,407789]
    #plug k into polynomial and do multipication and addition mod p lololol
    #al thought of this 
    for prime in primes:
        x = k % prime
        exponents =[1]

        for i in xrange(1,n+1):
            exponents.append((x * exponents[i-1]) % prime)

        r = 0
        x = k % prime
        for i in xrange(n+1):
            r += (p[i] * exponents[i])

        if r % prime != 0:
            return "No"
    return "Yes"

            



def run():
    s = []
    i = 0
    for line in iter(raw_input, ''):
        s.append(line)
        if i == 0:
            t = (s[0]).split(' ')
            n = int(t[0])
            k = int(t[1])
        if i == n+1:
            break
        i += 1



    def g(c):
        if c != '?':
            return int(c)
        else:
            return '?'
    p = map(g, s[1:])
    q_count = len(filter(lambda x : x == '?', p))

    print f(n,k,p,q_count)
run()
