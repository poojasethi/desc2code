#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <ctime>
#include <cassert>
#include <cctype>
#include <algorithm>
#include <set>
#include <vector>
#include <map>
#include <stack>
#include <queue>
#include <string>
#define Lson Ls, L, mid
#define Rson Rs, mid+1, R
#define mkp make_pair
using namespace std;
typedef long long ll;

const int N = 50;
const int dx[4] = {0, -1, 0, 1};
const int dy[4] = {1, 0, -1, 0};
int n, m, male, female, node, sign;
int id[N+5][N+5], dis[N*N+5][N*N+5];
ll wei[N*N+5][N*N+5];
bool valid[N*N+5];
char g[N+5][N+5];
queue<pair<int, int> > que;
struct People{
    int x, y;
    ll c;
    inline void input(){
        scanf("%d %d %I64d", &x, &y, &c);
    }
}p[N*N*2+5];
inline bool inside(int x, int y){
    return x>0&&y>0&&x<=n&&y<=m;
}
inline void bfs(int sx, int sy){
    int so = id[sx][sy];
    if (dis[so][so] != -1) return;
    while (!que.empty()) que.pop();
    que.push(mkp(sx, sy));
    dis[so][so] = 0;
    while (!que.empty()){
        int x = que.front().first;
        int y = que.front().second;
        int o = id[x][y];
        que.pop();
        for (int k=0; k<4; k++){
            int tx = x+dx[k];
            int ty = y+dy[k];
            int to = id[tx][ty];
            if (inside(tx, ty) && valid[to] && dis[so][to]==-1){
                dis[so][to] = dis[so][o] + 1;
                que.push(mkp(tx, ty));
            }
        }
    }
}
struct Dinic{
    #define fN 2000
    #define fM 1000000
    queue<int> que;
    int n, src, sink, total, inf;
    int now[fN], pre[fM], son[fM];
    int cur[fN], st[fN], dist[fN], p[fN];
    long long res[fM];
    inline void con(int a, int b, long long f){
        pre[++total] = now[a]; now[a] = total; son[total] = b; res[total] = f;
        pre[++total] = now[b]; now[b] = total; son[total] = a; res[total] = 0;
    }
    void init(){
        total = 1;
        memset(now, 0, sizeof(now));
        inf = 2139062143;
    }
    bool bfs(){
        memcpy(cur, now, sizeof(now));
        while (!que.empty()) que.pop();
        memset(dist, 0x7f, sizeof(dist));// inf = dist[0];
        que.push(src); dist[src] = 0;
        while (!que.empty()){
            int u = que.front(); que.pop();
            for (int tmp=now[u]; tmp; tmp=pre[tmp]){
                int v = son[tmp];
                if (res[tmp]>0 && dist[v] == inf){
                    dist[v] = dist[u]+1;
                    if (v == sink) return true;
                    que.push(v);
                }
            }
        }
        return false;
    }
    int dfs(){
        ll ret = 0;
        int top = 0;
        memcpy(cur, now, sizeof(now));
        st[++top] = src;
        while (top){
            int u = st[top];
            if (u != sink){
                int tmp;
                for (tmp=cur[u]; tmp; tmp=pre[tmp])
                    if (res[tmp] && dist[son[tmp]] == dist[u]+1) break;
                if (tmp){
                    st[++top] = son[tmp]; cur[u] = p[top] = tmp;
                } else {
                    --top; dist[u] = inf;
                }
            }
            else{
                ll delta = inf;
                for (int i=top; i>=2; i--)
                    delta = min(delta, res[p[i]]);
                for (int i=top; i>=2; i--){
                    res[p[i]] -= delta;
                    res[p[i]^1] += delta;
                    if (!res[p[i]]) top = i-1;
                }
                ret += delta;
            }
        }
        return ret;
    }
    ll maxflow(){
        ll ret = 0;
        while (bfs()) ret += dfs();
        return ret;
    }
}mf;
inline bool check(ll mid){
    mf.init();
    mf.src = 0;
    mf.sink = node+sign+sign+1;
    for (int i=1; i+i<=node; i++){
        mf.con(mf.src, i, 1);
        for (int j=1; j<=sign; j++) if (wei[i][j]!=-1 && wei[i][j]<=mid){
            mf.con(i, node+j, 1);
        }
    }
    for (int i=1; i<=sign; i++){
        mf.con(node+i, node+sign+i, 1);
    }
    for (int i=node/2+1; i<=node; i++){
        for (int j=1; j<=sign; j++) if (wei[i][j]!=-1 && wei[i][j]<=mid){
            mf.con(node+sign+j, i, 1);
        }
        mf.con(i, mf.sink, 1);
    }
    ll ans = mf.maxflow();
//    printf("\t ans = %I64d\n", ans);
    return ans>=node/2;
}
int main(){
    scanf("%d %d", &n, &m);
    scanf("%d %d", &male, &female);
    for (int i=1; i<=n; i++)
        scanf("%s", g[i]+1);
    sign = 0;
    for (int i=1; i<=n; i++)
        for (int j=1; j<=m; j++)
            id[i][j] = ++sign;
    for (int i=1; i<=n; i++)
        for (int j=1; j<=m; j++) if (g[i][j] == '#')
            valid[id[i][j]] = 0;
            else valid[id[i][j]] = 1;
    node = 0;
    p[++node].input();
    for (int i=1; i<=male; i++)
        p[++node].input();
    for (int i=1; i<=female; i++)
        p[++node].input();
    if (male == female+1){
        swap(p[1], p[1+male]);
        female ++;
    } else
    if (male == female-1){
        male++;
    } else
    if (male != female-1){
        puts("-1");
        return 0;
    }
    memset(dis, 0xff, sizeof(dis));
    for (int i=1; i<=node; i++){
        bfs(p[i].x, p[i].y);
        int o = id[p[i].x][p[i].y];
        for (int j=1; j<=sign; j++){
            wei[i][j] = -1;
            if (dis[o][j]!=-1)
                wei[i][j] = p[i].c*dis[o][j];
        }
    }
    ll L = 0, R = 1000000000000000ll;
    bool nosol = 1;
    while (L <= R){
        ll mid = (L+R)/2;
        if (check(mid)){
            R = mid-1;
            nosol = 0;
        }
        else L = mid+1;
    }
    if (nosol) puts("-1");
    else printf("%I64d\n", R+1);
    return 0;
}
