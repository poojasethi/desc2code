#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
using namespace std;
#define rep(i, l, r) for (int i = l; i <= r; i++)
#define drep(i, r, l) for (int i = r; i >= l; i--)
typedef long long ll;
const int N = 23, INF = 123456789, E = N * N * N * N * N;
const int TOT = N * N * 10;
int n, m, W, M, s, t, tot, head[TOT], d[TOT], h[TOT];
char Map[N][N];
int f[N * N][N * N];
int tx[4] = {1, -1, 0, 0};
int ty[4] = {0, 0, 1, -1};
struct Point
{
    int x, y, v;
}P[N * N * 2];
struct Node
{
    int next, node, flow;
}e[E << 1];
inline void add(int x, int y, int z)
{
    e[++tot].next = head[x], head[x] = tot, e[tot].node = y, e[tot].flow = z;
    e[++tot].next = head[y], head[y] = tot, e[tot].node = x, e[tot].flow = 0;
}
int map(int x, int y)
{
    return (x - 1) * m + y;
}
bool BFS()
{
    int l = 1, r = 1;
    memset(d, 0, sizeof(d));
    h[1] = s; d[s] = 1;
    while (l <= r)
    {
        int u = h[l++];
        for (int i = head[u], v; v = e[i].node, i; i = e[i].next)
        if (e[i].flow > 0 && !d[v])
        {
            d[v] = d[u] + 1;
            h[++r] = v;
        }
    }
    return (d[t]);
}
int dinic(int u, int flow)
{
    if (u == t) return flow;
    int mem = flow;
    for (int i = head[u], v; v = e[i].node, i; i = e[i].next)
    if (e[i].flow > 0 && d[v] == d[u] + 1)
    {
        int tmp = dinic(v, min(flow, e[i].flow));
        flow -= tmp; e[i].flow -= tmp; e[i ^ 1].flow += tmp;
        if (!flow) break;
    }
    if (mem == flow) d[u] = -1;
    return mem - flow;
}
bool check(ll ans)
{
    memset(e, 0, sizeof(e));
    memset(head, 0, sizeof(head));
    tot = 1; s = M + W + n * m * 2 + 1; t = s + 1;
    rep(i, 1, M) add(s, i, 1);
    rep(i, 1, W) add(i + M, t, 1);
    rep(i, 1, n)
        rep(j, 1, m)
        if (Map[i][j] == '.')
            add(map(i, j) + W + M, map(i, j) + W + M + n * m, 1);
    rep(i, 1, M)
        rep(x, 1, n)
            rep(y, 1, m)
            if (f[map(x, y)][map(P[i].x, P[i].y)] < INF &&  
            (ll)f[map(x, y)][map(P[i].x, P[i].y)] * P[i].v <= ans)
            add(i, map(x, y) + W + M, 1);
    rep(i, M + 1, M + W)
        rep(x, 1, n)
            rep(y, 1, m)
            if (f[map(x, y)][map(P[i].x, P[i].y)] < INF && 
            (ll)f[map(x, y)][map(P[i].x, P[i].y)] * P[i].v <= ans)
            add(map(x, y)  + W + M + n * m, i, 1);
    int cnt = 0;
    while (BFS() == 1)
    {
        cnt += dinic(s, INF);
    }
    return cnt == M;
}
void solve()
{
    int flag = 0;
    if (M <= W) M++, flag = 1; 
    else if (W < M) W++, flag = 2;
    if (M != W) {printf("-1\n"); return;}
    rep(i, 1, n) scanf("%s", Map[i] + 1); 
    rep(i, 1, M + W) scanf("%d%d%d", &P[i].x, &P[i].y, &P[i].v);
    if (flag == 2) swap(P[W + 1], P[1]);
    
    rep(i, 1, n * m)
        rep(j, 1, n * m) f[i][j] = INF;
    rep(i, 1, n * m) f[i][i] = 0;
    
    rep(i, 1, n)
        rep(j, 1, m)
        if (Map[i][j] == '.')
            rep(k, 0, 3)
            if (Map[i + tx[k]][j + ty[k]] == '.')
            {
                f[map(i, j)][map(i + tx[k], j + ty[k])] = 1;
            }

                
    rep(k, 1, n * m)
        rep(i, 1, n * m)
            rep(j, 1, n * m)
            f[i][j] = min(f[i][j], f[i][k] + f[k][j]);
 
    ll l = 0, r = (ll)n * m * 1000000000;
    while (l <= r)
    {
        ll mid = l + r >> 1;
        if (check(mid)) r = mid - 1;
        else l = mid + 1;
    }
    if (check(l)) printf("%I64d\n", l);
    else printf("-1\n");
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("input.txt","r",stdin);
    //freopen("output.txt","w",stdout);
#endif
    scanf("%d%d%d%d", &n, &m, &M, &W);
    solve();
#ifndef ONLINE_JUDGE
    fclose(stdin); fclose(stdout);
#endif
    return 0;
}