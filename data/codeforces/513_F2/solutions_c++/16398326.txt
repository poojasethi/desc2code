#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
typedef long long LL;
const int N=25;
const int M=2000000;
const LL INF=1e12;
struct Edge{
	int v,c,next;	
	Edge(){}
	Edge(int v,int c,int next):v(v),c(c),next(next){}
}edge[M];
struct Point
{
	int x,y,dis;
	Point(){}
	Point(int x,int y,int dis):x(x),y(y),dis(dis){}
}way[N][N][N*N];
queue<pair<int,int> > q;
char ch[N][N];
int xx[2][N*N],yy[2][N*N],speed[2][N*N],p[M],edn;
int n,m,num[2],num_tot,dis[N][N],S,T,bh_in[N][N],bh_out[N][N],bh[2][N*N],dist[M],val[N][N];
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};
void addedge(int u,int v,int c)
{
	edge[edn]=Edge(v,c,p[u]);
	p[u]=edn++;
	edge[edn]=Edge(u,0,p[v]);
	p[v]=edn++;
}
int bfs()
{
	static queue<int> q;
	while (!q.empty()) q.pop();
	for(int i=1;i<=T;i++)
		dist[i]=-1;
	dist[S]=0;
	q.push(S);
	while (!q.empty())
	{
		int cur=q.front();
		q.pop();
		for (int i=p[cur];i!=-1;i=edge[i].next)
		{
			int x=edge[i].v;
			if (dist[x]==-1&&edge[i].c>0)
			{
				dist[x]=dist[cur]+1;
				q.push(x);
			}
		}
	}
	return dist[T]!=-1;
}
int dfs(int a,int now)
{
	if (a==T) return(now);
	int r=0;
	for (int i=p[a];(~i)&&r<now;i=edge[i].next)
	{
		int x=edge[i].v;
		if (edge[i].c>0&&dist[x]==dist[a]+1)
		{
			int y=min(edge[i].c,now-r);
			y=dfs(x,y);
			r+=y;
			edge[i].c-=y;
			edge[i^1].c+=y;
		}
	}
	if (!r) dist[a]=-2;
	return r;
}
bool check(LL mid)
{
	for(int i=1;i<=T;i++) p[i]=-1;
	edn=0;
	for(int i=1;i<=num_tot;i++)
	{
		addedge(S,bh[0][i],1);
		addedge(bh[1][i],T,1);
	}
	for(int i=0;i<n;i++)
	for(int j=1;j<=m;j++)
		addedge(bh_in[i][j],bh_out[i][j],1);
	for(int i=1;i<=num_tot;i++)
	{
		int x=xx[0][i];
		int y=yy[0][i];
		LL v=speed[0][i];
		for(int j=1;j<=val[x][y];j++)
		{
			if(v * way[x][y][j].dis>mid) break;
			addedge(bh[0][i],bh_in[way[x][y][j].x][way[x][y][j].y],1);
		}
	}
	for(int i=1;i<=num_tot;i++)
	{
		int x=xx[1][i];
		int y=yy[1][i];
		LL v=speed[1][i];
		for(int j=1;j<=val[x][y];j++)
		{
			if(v * way[x][y][j].dis>mid) break;
			addedge(bh_out[way[x][y][j].x][way[x][y][j].y],bh[1][i],1);
		}
	}
	int tot=0,t;
	while (bfs())
	{
		while (t=dfs(S,num_tot))
			tot+=t;
	}
	return tot==num_tot;
}
int main()
{
	cin>>n>>m>>num[0]>>num[1];
	if(abs(num[0]-num[1])!=1)
	{
		puts("-1");
		return 0;
	}
	for(int i=0;i<n;i++)
		scanf("%s",ch[i]+1);
	num_tot=max(num[0],num[1]);
	if(num[0]<num[1])
	{
		num[0]=1;
		num[1]=0;
		scanf("%d%d%d",&xx[0][1],&yy[0][1],&speed[0][1]);
	}else
	{
		num[0]=0;
		num[1]=1;
		scanf("%d%d%d",&xx[1][1],&yy[1][1],&speed[1][1]);
	}
	for(int i=0;i<2;i++)
	while (num[i]<num_tot)
	{
		num[i]++;
		scanf("%d%d%d",&xx[i][num[i]],&yy[i][num[i]],&speed[i][num[i]]);
	}
	for(int i=1;i<=num_tot;i++)
	{
		xx[0][i]--;
		xx[1][i]--;
	}
	for(int i=0;i<n;i++)
	for(int j=1;j<=m;j++)
	if(ch[i][j]=='.')
	{
		for(int ii=0;ii<n;ii++)
		for(int jj=1;jj<=m;jj++)
			dis[ii][jj]=-1;
		dis[i][j]=0;
		q.push(make_pair(i,j));
		while (!q.empty())
		{
			int x=(q.front()).first;
			int y=(q.front()).second;
			q.pop();
			int tmp=dis[x][y];
			way[i][j][++val[i][j]]=Point(x,y,tmp);
			for(int dir=0;dir<4;dir++)
			{
				x+=dx[dir];
				y+=dy[dir];
				if(x>=0 && x<n && y>0 && y<=m && ch[x][y]=='.' && dis[x][y]==-1)
				{
					dis[x][y]=tmp+1;
					q.push(make_pair(x,y));
				}
				x-=dx[dir];
				y-=dy[dir];
			}
		}
	}
	LL ans=INF;
	LL l=0,r=INF;
	for(int i=0;i<n;i++)
	for(int j=1;j<=m;j++)
	{
		bh_in[i][j]=i * m + j;
		bh_out[i][j]=bh_in[i][j]+n*m;
	}
	for(int i=1;i<=num_tot;i++)
	{
		bh[0][i]=2 * n * m + i;
		bh[1][i]=2 * n * m + num_tot + i;
	}
	S=2 * n * m + 2 * num_tot + 1;
	T=S+1;
	while (l<=r)
	{
		LL mid=(l+r)/2;
		if(check(mid))
		{
			ans=mid;
			r=mid-1;
		}else l=mid+1;
	}
	if(ans==INF) ans=-1;
	cout<<ans<<endl;
}