#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std ;

#define N 30 + 10
#define L 500 + 10
#define M 5000 + 10
#define K 1000000 + 10
typedef long long ll ;
const int inf = 0x7FFFFFFF ;
struct Note {
	int x , y , t ;
} C1[L] , C2[L] , boss ;

int fx[4][2] = { {0,1} , {1,0} , {0,-1} , {-1,0} } ;
int Node[2*K] , Next[2*K] , C[2*K] , Head[2*M] , tot = 1 ;
int h[2*M] , vh[2*M] , di[2*M] ;
char map[N][N] ;
int Pos[N][N] ;
ll Dist[L][L] ;
int S , T , a , b ;
int n , m , NM , Num , avl ;
ll ans = -1 , last = -1 ;

bool pd( int x , int y ) {
	return !( x < 1 || y < 1 || x > n || y > m || map[x][y] == '#' ) ;
}

void link( int u , int v , int w ) {
	Node[++tot] = v , Next[tot] = Head[u] , C[tot] = w , Head[u] = tot ;
	Node[++tot] = u , Next[tot] = Head[v] , C[tot] = 0 , Head[v] = tot ;
}

int SAP( int x , int aug ) {
	int use = 0 ;
	if ( x == T ) return aug ;
     	for (int p = di[x] ; p ; p = Next[p] ) {
		if ( h[x] != h[Node[p]] + 1 || !C[p] ) continue ;
		di[x] = p ;
		int ret = SAP( Node[p] , min( aug - use , C[p] ) ) ;
		C[p] -= ret ;
		C[p ^ 1] += ret ;
		use += ret ;
		if ( h[S] > NM || aug - use == 0 ) return use ;
       	}
       	if ( -- vh[h[x]] == 0 ) {
		h[S] = NM + 1 ;
		return use ;
       	}
	h[x] ++ ;
	vh[h[x]] ++ ;
	di[x] = Head[x] ;
	return use ;
}

bool Check( ll st ) {
	tot = 1 ;
	int flow = 0 ;
	for (int i = S ; i <= T ; i ++ ) Head[i] = h[i] = vh[i] = 0 ;
	for (int i = 1 ; i <= Num ; i ++ ) {
		if ( Dist[i][i] ) continue ;
		link( i + a + b , i + a + b + Num , 1 ) ;
	}
	for (int i = 1 ; i <= a ; i ++ ) {
		link( S , i , 1 ) ;
		int now = Pos[C1[i].x][C1[i].y] ;
		ll d = st / C1[i].t ;
		for (int j = 1 ; j <= Num ; j ++ ) {
			if ( Dist[now][j] <= d ) link( i , j + a + b , 1 ) ;
		}
	}
	for (int i = 1 ; i <= b ; i ++ ) {
		link( i + a , T , 1 ) ;
		int now = Pos[C2[i].x][C2[i].y] ;
		ll d = st / C2[i].t ;
		for (int j = 1 ; j <= Num ; j ++ ) {
			if ( Dist[now][j] <= d ) link( j + a + b + Num , i + a , 1 ) ;
		}
	}
	NM = T + 1 ;
	memcpy( di , Head , sizeof(Head) ) ;
	vh[0] = NM ;
	while ( h[S] <= NM ) flow += SAP( S , inf ) ;
	return flow == a ;
}

void Solve() {
	ll l = 0 , r = 1e13 ;
	while ( l <= r ) {
		ll mid = (l + r) / 2 ;
		if ( Check( mid ) ) ans = mid , r = mid - 1 ;
		else l = mid + 1 ;
	}
}

int main() {
	//freopen( "hide.in" , "r" , stdin ) ;
	//freopen( "hide.out" , "w" , stdout ) ;
	scanf( "%d%d%d%d" , &n , &m , &a , &b ) ;
	for (int i = 1 ; i <= n * m ; i ++ ) {
		for (int j = 1 ; j <= n * m ; j ++ ) {
			Dist[i][j] = 1e15 ;
		}
	}
	for (int i = 1 ; i <= n ; i ++ ) {
		scanf( "\n" ) ;
		for (int j = 1 ; j <= m ; j ++ ) {
			scanf( "%c" , &map[i][j] ) ;
			Pos[i][j] = ++ Num ;
			if ( map[i][j] != '#' ) Dist[Num][Num] = 0 , avl ++ ;
		}
	}
	for (int i = 1 ; i <= n ; i ++ ) {
		for (int j = 1 ; j <= m ; j ++ ) {
			if ( map[i][j] == '#' ) continue ;
			for (int k = 0 ; k < 4 ; k ++ ) {
				int x = i + fx[k][0] ;
				int y = j + fx[k][1] ;
				if ( !pd( x , y ) ) continue ;
				Dist[Pos[i][j]][Pos[x][y]] = 1 ;
			}
		}
	}
	for (int k = 1 ; k <= Num ; k ++ ) {
		if ( Dist[k][k] ) continue ;
		for (int i = 1 ; i <= Num ; i ++ ) {
			if ( Dist[i][i] ) continue ;
			for (int j = 1 ; j <= Num ; j ++ ) {
				if ( Dist[j][j] ) continue ;
				Dist[i][j] = min( Dist[i][j] , Dist[i][k] + Dist[k][j] ) ;
			}
		}
	}
	scanf( "%d%d%d" , &boss.x , &boss.y , &boss.t ) ;
	for (int i = 1 ; i <= a ; i ++ )
		scanf( "%d%d%d" , &C1[i].x , &C1[i].y , &C1[i].t ) ;
	for (int i = 1 ; i <= b ; i ++ )
		scanf( "%d%d%d" , &C2[i].x , &C2[i].y , &C2[i].t ) ;
	if ( a > b ) {
		swap( a , b ) ;
		swap( C1 , C2 ) ;
	}
	if ( a + 1 != b || b > avl ) { printf( "-1\n" ) ; return 0 ; }
	a ++ ;
	C1[a] = boss ;
	S = 0 , T = a + b + n * m * 2 + 1 ;
	Solve() ;
	printf( "%I64d\n" , ans ) ;
	return 0 ;
}
