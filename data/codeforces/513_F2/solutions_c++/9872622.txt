#include <iostream>
#include <cstring>
#include <queue>

using namespace std;

typedef long long ll;

const int MAXN = 25, MAXF = MAXN * MAXN * 2, INF = 1e9;

struct P {
	P() {
	}
	int x, y, type, w;
} p[MAXF];

char tab[MAXN][MAXN];

int dis[MAXN][MAXN][MAXN][MAXN], dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
int n, m, mal, fem;

const int MAXM = 3e6 + 10, MAXG = MAXN * MAXN * 4;

int to[MAXM], head[MAXG], prev[MAXM], cap[MAXM];

int cntE;
void addE(int x, int y) {
//	cerr << " addE " << x << " " << y << endl;
	int e1 = cntE++, e2 = cntE++;
	to[e1] = y, prev[e1] = head[x], head[x] = e1, cap[e1] = 1;
	to[e2] = x, prev[e2] = head[y], head[y] = e2, cap[e2] = 0;
}

queue<int> q;
int dep[MAXG];

bool bfs(int src, int snk) {
	memset(dep, -1, sizeof dep);
	q.push(src);
	dep[src] = 0;
	while (!q.empty()) {
		int cur = q.front();
//		cerr << " bfs " << cur << endl;
		q.pop();
		for (int e = head[cur]; e != -1; e = prev[e]) {
			int u = to[e];
			if (cap[e] && dep[u] == -1) {
				dep[u] = dep[cur] + 1;
				q.push(u);
			}
		}
	}
	return dep[snk] != -1;
}

int pos[MAXG];

int dfs(int x, int mxF, int snk) {
	if (x == snk || !mxF)
		return mxF;
	int ret = 0;
	for (int &e = pos[x]; e != -1; e = prev[e]) {
		int u = to[e];
		if (dep[x] + 1 == dep[u] && cap[e]) {
			int tmp = dfs(u, min(mxF, cap[e]), snk);
			ret += tmp;
			mxF -= tmp;
			cap[e] -= tmp;
			cap[e ^ 1] += tmp;
		}
		if (mxF == 0)
			break;
	}
	return ret;
}

bool check(ll mxD) {
	memset(head, -1, sizeof head);
	cntE = 0;
	int shift = mal + fem + 1;
	int src = shift + n * m * 2;
	int snk = src + 1;
	for (int i = 0; i <= mal + fem; i++) {
		for (int x1 = 0; x1 < n; x1++)
			for (int y1 = 0; y1 < m; y1++)
				if (dis[p[i].x][p[i].y][x1][y1] != INF && 1ll * dis[p[i].x][p[i].y][x1][y1] * p[i].w <= mxD) {
//					cerr << i << " reaches " << x1 << " " << y1 << endl;
					if (p[i].type)
						addE(i, shift + 2 * (x1 * m + y1));
					else
						addE(shift + 2 * (x1 * m + y1) + 1, i);
				}
		if (p[i].type)
			addE(src, i);
		else
			addE(i, snk);
	}
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			if (tab[i][j] == '.')
				addE(shift + 2 * (i * m + j), shift + 2 * (i * m + j) + 1);
	int ans = 0;
	while(bfs(src, snk)) {
//		cerr << " good bfs " << ans << endl;
		for (int i = 0; i <= snk; i++)
			pos[i] = head[i];
		ans += dfs(src, INF, snk);
	}
//	cerr << " check " << mxD << " " << ans << endl;
	return ans == max(mal, fem);
}

int main() {
	cin >> n >> m >> mal >> fem;
	if (max(mal, fem) - min(mal, fem) != 1) {
		cout << -1 << endl;
		return 0;
	}
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			cin >> tab[i][j];
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			for (int k = 0; k < n; k++)
				for (int l = 0; l < m; l++)
					dis[i][j][k][l] = INF;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			if (tab[i][j] == '.')
				dis[i][j][i][j] = 0;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			for (int k = 0; k < 4; k++) {
				int nx = i + dx[k], ny = j + dy[k];
				if (nx >= 0 && ny >= 0 && nx < n && ny < m && tab[i][j] == '.' && tab[nx][ny] == '.')
					dis[i][j][nx][ny] = 1;
			}
	for (int x1 = 0; x1 < n; x1++)
		for (int y1 = 0; y1 < m; y1++)
			for (int x2 = 0; x2 < n; x2++)
				for (int y2 = 0; y2 < m; y2++)
					for (int x3 = 0; x3 < n; x3++)
						for (int y3 = 0; y3 < m; y3++)
							dis[x2][y2][x3][y3] = min(dis[x2][y2][x3][y3], 
									dis[x2][y2][x1][y1] + dis[x1][y1][x3][y3]);
	for (int i = 0; i <= mal + fem; i++) {
		cin >> p[i].x >> p[i].y >> p[i].w; p[i].x--, p[i].y--;
		if (i >= 1 && i <= mal)
			p[i].type = 0;
		else if (i > mal && i <= mal + fem)
			p[i].type = 1;
		else
			p[i].type = mal < fem ? 0 : 1;
//		cerr << " type " << p[i].type << endl;
	}
	ll mxHi = 1e12;
	ll lo = -1, hi = mxHi;
	while (hi - lo > 1) {
		ll mid = (lo + hi) >> 1;
//		cerr << lo << " " << hi << " " << mid << endl;
		if (check(mid))
			hi = mid;
		else
			lo = mid;
//		{int _; cin >> _;}
	}
//	cerr << hi << " " << mxHi << endl;
	if (hi == mxHi)
		cout << -1 << endl;
	else
		cout << hi << endl;
	return 0;
}
