#include <iostream>
#include <sstream>
#include <fstream>
#include <string>
#include <vector>
#include <deque>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <algorithm>
#include <functional>
#include <utility>
#include <bitset>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstdio>

using namespace std;

#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)
#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)

typedef long long ll;
#define INF (1<<29)

typedef int F;
#define F_INF (1<<29)
#define MAXV 10000
#define MAXE 1000000 // E*2!

F cap[MAXE],flow[MAXE];
int to[MAXE],_prev[MAXE],last[MAXV],used[MAXV],level[MAXV];

struct MaxFlow{
    int V,E;

    MaxFlow(int n){
        int i;
        V = n; E = 0;
        REP(i,V) last[i] = -1;
    }

    void add_edge(int x, int y, F f){
        cap[E] = f; flow[E] = 0; to[E] = y; _prev[E] = last[x]; last[x] = E; E++;
        cap[E] = 0; flow[E] = 0; to[E] = x; _prev[E] = last[y]; last[y] = E; E++;
    }

    bool bfs(int s, int t){
        int i;
        REP(i,V) level[i] = -1;
        queue <int> q;
        q.push(s); level[s] = 0;
        while(!q.empty()){
            int x = q.front(); q.pop();
            for(i=last[x];i>=0;i=_prev[i]) if(level[to[i]] == -1 && cap[i] > flow[i]) {q.push(to[i]); level[to[i]] = level[x] + 1;}
        }
        return (level[t] != -1);
    }

    F dfs(int v, int t, F f){
        int i;
        if(v == t) return f;
        for(i=used[v];i>=0;used[v]=i=_prev[i]) if(level[to[i]] > level[v] && cap[i] > flow[i]){
            F tmp = dfs(to[i],t,min(f,cap[i]-flow[i]));
            if(tmp > 0) {flow[i] += tmp; flow[i^1] -= tmp; return tmp;}
        }
        return 0;
    }

    F maxflow(int s, int t){
        int i;
        while(bfs(s,t)){
            REP(i,V) used[i] = last[i];
            while(dfs(s,t,F_INF) != 0);
        }
        F ans = 0;
        for(i=last[s];i>=0;i=_prev[i]) ans += flow[i];
        return ans;
    }

};

int dx[] = {1,-1,0,0}, dy[] = {0,0,1,-1};

int X,Y;
string board[30];
int dist[30][30][30][30];

int A,B;
int cx,cy,ct;
int ax[500],ay[500],at[500];
int bx[500],by[500],bt[500];

queue <int> q;

void bfs(int s, int t){
    int i,j;
    
    REP(i,X) REP(j,Y) dist[s][t][i][j] = INF;
    if(board[s][t] == '#') return;
    
    dist[s][t][s][t] = 0;
    q.push(s); q.push(t);
    
    while(!q.empty()){
        int x = q.front(); q.pop(); int y = q.front(); q.pop();
        REP(i,4){
            int x2 = x + dx[i], y2 = y + dy[i];
            if(x2 >= 0 && x2 < X && y2 >= 0 && y2 < Y && board[x2][y2] != '#' && dist[s][t][x2][y2] == INF){
                dist[s][t][x2][y2] = dist[s][t][x][y] + 1;
                q.push(x2); q.push(y2);
            }
        }
    }
}

bool check(ll T){
    int i,j,k;
    
    MaxFlow mf(A + A + 2 * (X * Y) + 2);
    int V = A + A + 2 * (X * Y) + 2;
    REP(i,A) mf.add_edge(V-2, i, 1);
    REP(i,A) mf.add_edge(A+i, V-1, 1);
    REP(i,X*Y) mf.add_edge(A+A+i, A+A+X*Y+i, 1);
    REP(i,A) REP(j,X) REP(k,Y){
        int d = dist[ax[i]][ay[i]][j][k];
        if(d != INF && (ll)d * at[i] <= T) mf.add_edge(i, A+A+j*Y+k, 1);
    }
    REP(i,A) REP(j,X) REP(k,Y){
        int d = dist[bx[i]][by[i]][j][k];
        if(d != INF && (ll)d * bt[i] <= T) mf.add_edge(A+A+X*Y+j*Y+k, A+i, 1);
    }
    
    int f = mf.maxflow(V-2, V-1);
    return (f == A);
}

int main(void){
    int i,j;
    
    cin >> X >> Y >> A >> B;
    REP(i,X) cin >> board[i];
    REP(i,X) REP(j,Y) bfs(i, j);
    
    cin >> cx >> cy >> ct;
    REP(i,A) cin >> ax[i] >> ay[i] >> at[i];
    REP(i,B) cin >> bx[i] >> by[i] >> bt[i];
    
    cx--; cy--;
    REP(i,A) {ax[i]--; ay[i]--;}
    REP(i,B) {bx[i]--; by[i]--;}
    
    if(A < B){
        ax[A] = cx; ay[A] = cy; at[A] = ct; A++;
    } else {
        bx[B] = cx; by[B] = cy; bt[B] = ct; B++;
    }
    
    if(A != B){
        cout << -1 << endl;
        return 0;
    }
    
    ll low = -1, high = (1ll<<40);
    while(high - low > 1){
        ll mid = (low + high) / 2;
        if(check(mid)) high = mid; else low = mid;
    }
    
    if(high == (1ll<<40)) high = -1;
    
    cout << high << endl;
    
    return 0;
}
