#include <algorithm>
#include <bitset>
#include <cctype>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <iomanip>
#include <iostream>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <vector>
using namespace std;

#define SIZE(v) ((int)(v).size())
#define CLEAR(v) memset((v),0,sizeof(v))
#define BEGIN(v) ((v).begin())
#define END(v) ((v).end())
#define ALL(v) BEGIN(v),END(v)
#define SORT(v) sort(ALL(v))
#define UNIQUE(v) SORT(v);(v).erase(unique(ALL(v)),END(v))
#define INDEX(v,x) lower_bound(ALL(v),x)-BEGIN(v)

#define FOR(i,l,r) for(int i=(l);i<(r);i++)
#define FOREACH(i,v) for(typeof((v).begin()) i=(v).begin();i!=(v).end();i++)
#define PRINTLF(l,v) cout<<setprecision(l)<<fixed<<v

template<int MAXNODE, int MAXEDGE, typename T = int, T INF = 1012345678> struct Dinic {
  struct Edge {
    int pnt, nxt;
    T cap;

    Edge() {}

    Edge(int pnt, int nxt, T cap): pnt(pnt), nxt(nxt), cap(cap)  {}
  };

  int N, M, source, sink, start[MAXNODE];
  T value[MAXNODE], res;
  bool mark[MAXNODE];
  Edge edge[MAXEDGE << 1];

  void init(int n) {
    N = n;
    M = 0;
    res = 0;
    memset(start, 0xFF, sizeof(int) * N);
  }

  void addEdge(int x, int y, T z) {
    edge[M] = Edge(y, start[x], z);
    start[x] = M++;
    edge[M] = Edge(x, start[y], 0);
    start[y] = M++;
  }

  void reset() {
    res = 0;
    for (int i = 0; i < M; i += 2) {
      edge[i].cap += edge[i ^ 1].cap;
      edge[i ^ 1].cap = 0;
    }
  }

  int level[MAXNODE];

  void BFS() {
    int open, closed, L[MAXNODE];
    memset(level, 0xFF, sizeof(int) * N);
    level[source] = 0;
    L[0] = source;
    open = -1;
    closed = 0;
    int now;
    while (open < closed && level[sink] == -1) {
      now = L[++open];
      int i = start[now];
      while (i != -1) {
        if (edge[i].cap && level[edge[i].pnt] == -1) {
          level[edge[i].pnt] = level[now] + 1;
          L[++closed] = edge[i].pnt;
        }
        i = edge[i].nxt;
      }
    }
  }

  int startnow[MAXNODE], last[MAXNODE];

  T maxflow(int source, int sink) {
    this->source = source;
    this->sink = sink;
    T delta;
    while (true) {
      BFS();
      if (level[sink] == -1) break;
      memset(value, 0, sizeof(T) * N);
      value[source] = INF;
      for (int i = 0; i < N; i++) mark[i] = true;
      memcpy(startnow, start, sizeof(int) * N);
      int now = source;
      while (true) {
        int i = startnow[now];
        while (i != -1) {
          if (edge[i].cap && level[now] + 1 == level[edge[i].pnt] && mark[edge[i].pnt]) {
            last[edge[i].pnt] = i;
            value[edge[i].pnt] = min(edge[i].cap, value[now]);
            startnow[now] = i;
            now = edge[i].pnt;
            break;
          }
          i = edge[i].nxt;
        }
        if (i == -1) {
          mark[now] = false;
          if (now == source) break;
          now = edge[last[now] ^ 1].pnt;
        } else if (now == sink) {
          delta = value[sink];
          res += delta;
          int i = sink, tmp;
          while (i != source) {
            value[i] -= delta;
            edge[last[i]].cap -= delta;
            tmp = last[i] ^ 1;
            if (value[i] == 0) now = edge[tmp].pnt;
            edge[tmp].cap += delta;
            i = edge[tmp].pnt;
          }
        }
      }
    }
    return res;
  }
};

const int MAXN = 32;
const int MAXM = 512;
const int INF = 1012345678;
const int DX[4] = {0, 0, 1, -1};
const int DY[4] = {1, -1, 0, 0};

int n, m, males, females, cells;
char mat[MAXN][MAXN];
int idx[MAXN][MAXN], dist[MAXM][MAXM];
vector<pair<int, long long> > male, female;

bool isValid(int x, int y) {
  return 0 <= x && x < n && 0 <= y && y < m;
}

void init() {
  FOR(i, 0, cells) {
    FOR(j, 0, cells) dist[i][j] = INF;
    dist[i][i] = 0;
  }
  FOR(x0, 0, n) FOR(y0, 0, m) if (idx[x0][y0] != -1) {
    FOR(dir, 0, 4) {
      int x1 = x0 + DX[dir], y1 = y0 + DY[dir];
      if (isValid(x1, y1) && idx[x1][y1] != -1) {
        dist[idx[x0][y0]][idx[x1][y1]] = 1;
      }
    }
  }
  FOR(k, 0, cells) FOR(i, 0, cells) FOR(j, 0, cells) {
    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
  }
}

void readIn(vector<pair<int, long long> > &v) {
  int r, c, t; scanf("%d%d%d", &r, &c, &t); r--; c--;
  v.push_back(make_pair(idx[r][c], t));
}

Dinic<1 + MAXM * 4 + 1, MAXM + MAXM * MAXM + MAXM + MAXM * MAXM + MAXM> dinic;

int MALE(int x) { return x; }
int INCELL(int x) { return males + x; }
int OUTCELL(int x) { return males + cells + x; }
int FEMALE(int x) { return males + (cells << 1) + x; }

bool isValid(long long t) {
  int SOURCE = males + (cells << 1) + females, SINK = SOURCE + 1;
  dinic.init(SINK + 1);
  FOR(i, 0, males) dinic.addEdge(SOURCE, MALE(i), 1);
  FOR(i, 0, males) FOR(j, 0, cells) if (dist[male[i].first][j] != INF && dist[male[i].first][j] * male[i].second <= t) {
    dinic.addEdge(MALE(i), INCELL(j), 1);
  }
  FOR(i, 0, cells) dinic.addEdge(INCELL(i), OUTCELL(i), 1);
  FOR(i, 0, cells) FOR(j, 0, females) if (dist[i][female[j].first] != INF && dist[i][female[j].first] * female[j].second <= t) {
    dinic.addEdge(OUTCELL(i), FEMALE(j), 1);
  }
  FOR(i, 0, females) dinic.addEdge(FEMALE(i), SINK, 1);
  return dinic.maxflow(SOURCE, SINK) == males;
}

vector<long long> candidates;

long long calc() {
  if (abs(males - females) != 1) return -1;
  if (males < females) readIn(male);
  else readIn(female);
  FOR(i, 0, males) readIn(male);
  FOR(i, 0, females) readIn(female);
  males = females = SIZE(male);
  FOR(i, 0, males) FOR(j, 0, cells) {
    int idx = male[i].first;
    if (dist[idx][j] != INF) {
      candidates.push_back(dist[idx][j] * male[i].second);
    }
  }
  FOR(i, 0, females) FOR(j, 0, cells) {
    int idx = female[i].first;
    if (dist[idx][j] != INF) {
      candidates.push_back(dist[idx][j] * female[i].second);
    }
  }
  UNIQUE(candidates);
  int lower = 0, upper = SIZE(candidates) - 1;
  long long res = -1;
  while (lower <= upper) {
    int medium = (lower + upper) >> 1;
    if (isValid(candidates[medium])) {
      res = candidates[medium];
      upper = medium - 1;
    } else {
      lower = medium + 1;
    }
  }
  return res;
}

int main() {
  scanf("%d%d%d%d", &n, &m, &males, &females);
  FOR(i, 0, n) scanf("%s", mat[i]);
  memset(idx, 0xFF, sizeof(idx));
  cells = 0;
  FOR(i, 0, n) FOR(j, 0, m) if (mat[i][j] != '#') {
    idx[i][j] = cells++;
  }
  init();
  cout << calc() << endl;
  return 0;
}
