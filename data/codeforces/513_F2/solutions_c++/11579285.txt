#include <queue>
#include <stdio.h>
#include <algorithm>
#include <memory.h>
using namespace std;
#define M 25
typedef long long ll;


int w, h;
int n;
char s[M][M];
int dx[] = {-1, 1, 0, 0};
int dy[] = {0, 0, -1, 1};
int x[M*M], y[M*M], t[M*M];
int X[M*M], Y[M*M], T[M*M];
int flag[M][M], tot;
int chk[M][M], chkn;

int sink;

void End() {
	puts("-1");
	exit(0);
}

void input() {
	int na = 0, nb = 0;
	int nn, mm;
	scanf("%d %d %d %d", &w, &h, &nn, &mm);
	for (int i = 1; i <= w; i++)
		scanf("%s", s[i] + 1);
	for (int i = 1; i <= w; i++) for (int j = 1; j <= h; j++) if (s[i][j] != '#')
		flag[i][j] = ++tot;
	if (nn == mm) End();
	if (nn > mm + 1 || mm > nn + 1) End();
	if (nn == mm - 1) {
		scanf("%d %d %d", &x[1], &y[1], &t[1]);
		na++;
	} else {
		scanf("%d %d %d", &X[1], &Y[1], &T[1]);
		nb++;
	}
	for (int i = 1; i <= nn; i++) {
		++na;
		scanf("%d %d %d", &x[na], &y[na], &t[na]);
	}
	for (int i = 1; i <= mm; i++) {
		++nb;
		scanf("%d %d %d", &X[nb], &Y[nb], &T[nb]);
	}
	n = na;

	for (int i = 0; i <= w + 1; i++) for (int j = 0; j <= h + 1; j++) if (!i || !j || i > w || j > h || s[i][j] == '#') {
		chk[i][j] = 1e8;
	}
	sink = n + tot + tot + n + 1;
}

const int Maxn = 41000;
const int Maxm = 4000010;
const int inf = 0x3f3f3f3f;

struct ZKW_flow{
	int st, ed, ecnt, n;
	int head[Maxn];
	int cap[Maxm], cost[Maxm], to[Maxm], next[Maxm];

	void init(){
		memset(head, -1, sizeof(head));
		ecnt = 2;
	}

	void add(int u, int v, int cc, int ww){
		cap[ecnt] = cc; cost[ecnt] = ww; to[ecnt] = v;
		next[ecnt] = head[u]; head[u] = ecnt++;
		cap[ecnt] = 0; cost[ecnt] = -ww; to[ecnt] = u;
		next[ecnt] = head[v]; head[v] = ecnt++;
	}

	int dis[Maxn];

	void SPFA(){
		for(int i = 0; i <= n; ++i) dis[i] = inf;
		priority_queue<pair<int, int> > Q;
		dis[st] = 0;
		Q.push(make_pair(0, st));
		while(!Q.empty()){
			int u = Q.top().second, d = -Q.top().first;
			Q.pop();
			if(dis[u] != d) continue;
			for(int p = head[u]; p!=-1; p = next[p]){
				int&v = to[p];
				if(cap[p] && dis[v] > d + cost[p]){
					dis[v] = d + cost[p];
					Q.push(make_pair(-dis[v], v));
				}
			}
		}
		for(int i = 0; i <= n; ++i) dis[i] = dis[ed] - dis[i];
	}

	int minCost, maxFlow;
	bool use[Maxn];

	int add_flow(int u, int flow){
		if(u == ed){
			maxFlow += flow;
			minCost += dis[st] * flow;
			return flow;
		}
		use[u] = true;
		int now = flow;
		for(int p = head[u]; p!=-1; p = next[p]){
			int&v = to[p];
			if(cap[p] && !use[v] && dis[u] == dis[v] + cost[p]){
				int tmp = add_flow(v, min(now, cap[p]));
				cap[p] -= tmp;
				cap[p^1] += tmp;
				now -= tmp;
				if(!now) break;
			}
		}
		return flow - now;
	}

	bool modify_label(){
		int d = inf;
		for(int u = 0; u <= n; ++u) if(use[u])
			for(int p = head[u]; p!=-1; p = next[p]){
				int&v = to[p];
				if(cap[p] && !use[v]) d = min(d, dis[v] + cost[p] - dis[u]);
			}
		if(d == inf) return false;
		for(int i = 0; i <= n; ++i) if(use[i]) dis[i] += d;
		return true;
	}

	int ZKW(int ss, int tt, int nn){
		st = ss, ed = tt, n = nn;
		minCost = maxFlow = 0;
		SPFA();
		while(true){
			while(true){
				for(int i = 0; i <= n; ++i) use[i] = 0;
				if(!add_flow(st, inf)) break;
			}
			if(!modify_label()) break;
		}
		return maxFlow;
	}
} G;


int q[M * M * 2], st, en;
int d[M][M];
void prepare(int id, int x, int y, int t, ll dis) {
	st = en = 0;
	chk[x][y] = ++chkn;
	q[++en] = x;
	q[++en] = y;
	d[x][y] = 0;
	dis /= t;
	if (dis > 1ll * w * h) t = w * h;
	else t = dis;
	int X, Y, i;
	while (st < en) {
		x = q[++st], y = q[++st];
		if (id <= n) G.add(id, n + flag[x][y], 1, 0);
		else G.add(n + tot + flag[x][y], id, 1, 0);
		if (d[x][y] == t) continue;
		for (i = 0; i < 4; i++) {
			X = x + dx[i], Y = y + dy[i];
			if (chk[X][Y] >= chkn) continue;
			chk[X][Y] = chkn;
			q[++en] = X;
			q[++en] = Y;
			d[X][Y] = d[x][y] + 1;
		}
	}
}

bool ok(ll dis) {
	G.init();
	for (int i = 1; i <= n; i++) {
		prepare(i, x[i], y[i], t[i], dis);
	}
	for (int j = 1; j <= n; j++) {
		prepare(j + tot + tot + n, X[j], Y[j], T[j], dis);
	}
	for (int i = 1; i <= tot; i++)
		G.add(n + i, n + tot + i, 1, 0);
	for (int i = 1; i <= n; i++)
		G.add(0, i, 1, 0);
	for (int i = 1; i <= n; i++)
		G.add(n + tot + tot + i, sink, 1, 0);
	int max_flow = G.ZKW(0, sink, sink+1);
	return max_flow == n;
}

void solve() {
	ll mn = 0, mx = 1e12;
	if (ok(mn)) {
		puts("0");
		return;
	}
	if (!ok(mx)) {
		End();
	}
	while (mn < mx - 1) {
		ll mid = (mn + mx) / 2;
		if (ok(mid))
			mx = mid;
		else
			mn = mid;
	}
	printf("%I64d\n", mx);
}

int main() {
//	freopen("F.in", "r", stdin);
	input();
	solve();
	return 0;
}
