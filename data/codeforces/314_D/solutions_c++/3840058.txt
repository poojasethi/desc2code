#include <stdio.h>
#include <memory.h>
#include <algorithm>

using namespace std;

typedef long long INT;
typedef pair<INT, INT> pll;

#define NN 110000
#define INF 3000000000LL

pll p[NN];
int N;
INT rmax[NN], rmin[NN], bmax[NN], bmin[NN];

bool possible(INT d) {
    
    int i, j;
    INT ma, mi;
    
    for (i=0; i<N; i++) {
        j=upper_bound(p, p+N, pll(p[i].first+d, INF))-p;
        ma=-INF; mi=INF;
        if (i) ma=max(ma, rmax[i-1]), mi=min(mi, rmin[i-1]);
        if (j<N) ma=max(ma, bmax[j]), mi=min(mi, bmin[j]);
        if (ma-mi<=d) return true;
    }
    
    return false;
}

int main() {


    int i, a, b;
    INT high, low, mid;
    
    scanf("%d", &N);
    
    for (i=0; i<N; i++) {
        scanf("%d%d", &a, &b);
        p[i]=pll(a+b, a-b);
    }
    
    sort(p, p+N);
    
    rmax[0]=rmin[0]=p[0].second;
    for (i=1; i<N; i++) {
        rmax[i]=max(rmax[i-1], p[i].second);
        rmin[i]=min(rmin[i-1], p[i].second);
    }
    
    bmax[N-1]=bmin[N-1]=p[N-1].second;
    for (i=N-2; i>=0; i--) {
        bmax[i]=max(bmax[i+1], p[i].second);
        bmin[i]=min(bmin[i+1], p[i].second);
    }
    
    high=INF; low=0;
    
    while (high>low+1) {
        mid=(high+low)/2;
        if (possible(mid)) high=mid;
        else low=mid;
    }
    
    if (possible(low)) printf("%lf\n", low/2.0);
    else printf("%lf\n", high/2.0);
    
    return 0;
}