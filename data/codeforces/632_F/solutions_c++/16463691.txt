#include<bits/stdc++.h>

#define FI(i,a,b) for(int i=(a);i<=(b);i++)
#define FD(i,a,b) for(int i=(a);i>=(b);i--)

#define PII pair<int,int>
#define mp make_pair
#define fi first
#define se second

using namespace std;

int n,s[2505][2505],rt;
bool gg;

struct ed{
  int a,b,c;
  bool operator<(const ed &k) const{
    return c<k.c;
  }
};

int par[2505];

vector<ed> E;
vector<PII> V[2505];

int f(int x){
  if(par[x]==x) return x;
  else return par[x]=f(par[x]);
}

void dfs(int id,int prev,int cc){
  if(s[rt][id]!=cc) gg=true;
  if(gg) return;
  FI(i,0,(int)V[id].size()-1){
    PII to=V[id][i];
    if(to.fi==prev) continue;
    dfs(to.fi,id,max(cc,to.se));
  }
  return;
}
int main(){
  scanf("%d",&n);
  FI(i,1,n) FI(j,1,n) scanf("%d",&s[i][j]);
  FI(i,1,n) FI(j,i,n){
    if(s[i][j]!=s[j][i] || (i==j && s[i][j])){
      printf("NOT MAGIC\n");
      return 0;
    }
    if(i<j) E.push_back((ed){i,j,s[i][j]});
  }
  //we have a symmetric matrix with s[i][i]=0 now, what next?
  //solution: MST!
  sort(E.begin(),E.end());
  FI(i,1,n) par[i]=i;
  FI(i,0,(int)E.size()-1){
    int l=E[i].a,r=E[i].b;
    int pl=f(l),pr=f(r);
    if(pl==pr) continue;
    par[pl]=pr;
    V[l].push_back(mp(r,E[i].c));
    V[r].push_back(mp(l,E[i].c));
  }
  FI(i,1,n) rt=i,dfs(i,-1,0);
  if(gg) printf("NOT MAGIC\n");
  else printf("MAGIC\n");
  return 0;
}