//最小生成树 
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <string>
#include <vector>
using namespace std;
const int N=2510;
int n, g[N][N], len;
int fa[N*N];
int vis[N][N], dis[N][N];
struct node{
	int num, x, y;
	friend bool operator < (const node n1, const node n2){
		return n1.num<n2.num;
	}
}nod[N*N/2];
vector<int>vec[N];
int find(int x){
	return fa[x]=(x==fa[x]?fa[x]:find(fa[x]));
}
void Kruskal(){
	int cnt=0;
	memset(vis, 0, sizeof(vis));
	for(int i=0; i<len; i++){
		if(cnt==n-1) break;
		int ui=find(nod[i].x), vi=find(nod[i].y);
		if(ui==vi) continue;
		fa[vi]=ui;
		vec[nod[i].x].push_back(nod[i].y);
		vec[nod[i].y].push_back(nod[i].x);
		vis[nod[i].x][nod[i].y]=vis[nod[i].y][nod[i].x]=1;
		cnt++;
	}
}
void dfs(int u, int uu, int p, int maxn){
	for(int i=0; i<vec[u].size(); i++){
		int v=vec[u][i];
		if(v!=uu && vis[u][v]==1){
			maxn = max(maxn, g[u][v]);
			dis[p][v]=dis[v][p]=max(maxn, dis[p][v]);
			dfs(v, u, p, maxn);
		}
	}
}
int main()
{
	len=0;
	scanf("%d", &n);
	for(int i=0; i<n; i++) vec[i].clear();
	for(int i=0; i<n; i++){
		for(int j=0; j<n; j++){
			scanf("%d", &g[i][j]);
			if(i<j){
				nod[len].num=g[i][j], nod[len].x=i, nod[len].y=j, len++;
			}
		}
	}
	for(int i=0; i<n; i++){
		for(int j=i; j<n; j++){
			if(g[i][j]!=g[j][i] || (i==j&&g[i][j])){
				cout<<"NOT MAGIC"<<endl;return 0;
			}
		}
	}
	sort(nod, nod+len);
	for(int i=0; i<n; i++) fa[i]=i;
	Kruskal();
	for(int i=0; i<n; i++){
		dfs(i, -1, i, 0);
	}
	for(int i=0; i<n; i++){
		for(int j=i+1; j<n; j++){
			if(g[i][j]!=dis[i][j]) {
				cout<<"NOT MAGIC"<<endl;return 0;
			}
		}
	}
	cout<<"MAGIC"<<endl;
	return 0;
}
			 	 	  	 	 			 		 	  			   	