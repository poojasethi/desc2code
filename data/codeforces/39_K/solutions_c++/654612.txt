#include <map>
#include <set>
#include <cmath>
#include <stack>
#include <queue>
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
#include <unistd.h>
#include  <sys/time.h>
#include <iomanip>
using namespace std;
#define li		 long long int
#define rep(i,to)	for(li i=0;i<((li)to);i++)
#define pb		push_back
#define sz(v)		((li)v.size())


struct P{
	li x0,y0,x1,y1;
};

int main(){
	vector< P > point;
	li n,m,k;
	cin>>n>>m>>k;
	vector<string> mp(n);
	vector<li> vx,vy;
	rep(i,n) cin>>mp[i];
	rep(i,n)rep(j,m)if(mp[i][j]=='*'){
		li x1=i,y1=j;
		while(x1<n && mp[x1][j]=='*') x1++;
		while(y1<m && mp[i][y1]=='*') y1++;
		point.pb((P){i,j,x1-1,y1-1});
		for(li k=i;k<x1;k++)for(li l=j;l<y1;l++) mp[k][l]='.';
		vx.pb(i);
		vx.pb(x1-1);
	}
	sort(vx.begin(),vx.end());
	vx.erase(unique(vx.begin(),vx.end()),vx.end());
	li res=0;
	for(li num=1;num<=3;num++){
		for(li right=0;right<sz(vx);right++)for(li left=0;left<=right;left++){
			vector<pair<pair<li,li>,li> > vy;
			rep(i,sz(point))if(vx[left]<=point[i].x1 && point[i].x0<=vx[right]){
				li p=(point[i].x0<vx[left]||vx[right]<point[i].x1)?1000:1;
				vy.pb(make_pair(make_pair(point[i].y0,p),point[i].x0));
				vy.pb(make_pair(make_pair(point[i].y1,0),point[i].x1));
			}
			sort(vy.begin(),vy.end());
			li sum=0,ok=0,l=0,r=0;
			bool flag=true;
//cout<<"start:"<<vx[left]<<" "<<vx[right]<<endl;
//rep(i,sz(vy)) cout<<vy[i].first.first<<" "<<vy[i].first.second<<" "<<vy[i].second<<endl;
			while(flag){
//cout<<sum<<" "<<ok<<endl;
				if(sum==0){
					if(ok==num){
						li top=vy[l].first.first-((l==0)?-1:vy[l-1].first.first);
						li bottom=((r==sz(vy))?m:vy[r].first.first)-vy[r-1].first.first;
						li left_space=vx[left]-((left==0)?-1:vx[left-1]);
						li right_space=((right+1==sz(vx))?n:vx[right+1])-vx[right];
//cout<<vy[r].first.first<<","<<vy[r-1].first.first<<" "<<l<<","<<r<<endl;
//cout<<top<<" "<<bottom<<" "<<left_space<<" "<<right_space<<endl;
						res+=top*bottom*right_space*left_space;
					}
				}
				if(ok<num){
			 		if(r==sz(vy)){
						flag=false;
						break;
					}
					do{
						if(vy[r].first.second==0) sum--;
						else sum++;
						ok+=vy[r++].first.second;
					}while(r!=sz(vy) && (vy[r].first.first==vy[r-1].first.first || sum!=0));
				}else{
					do{
						if(vy[l].first.second==0) sum++;
						else sum--;
						ok-=vy[l++].first.second;
					}while(l!=sz(vy) && (vy[l].first.first==vy[l-1].first.first || sum!=0));
				}
			}
//cout<<vx[left]<<" "<<vx[right]<<" "<<res<<endl;
		}
	}
	cout<<res<<endl;
}
