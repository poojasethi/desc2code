#include <iostream>
#include <fstream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <ctime>
#include <algorithm>
#include <map>
#include <queue>
#include <vector>
using namespace std;

int n, m, xx, number, dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};
int x[1000050], need[1050][1050];
pair <int, int> Q[1000050];
pair <pair <int, int>, int> up[1000050], down[1000050];
pair <pair <int, int>, pair <int, int> > object[105];
bool solve[105], visited[1050][1050];
char data[1050][1050];

int Rand()
{
    return (rand() << 15) | rand();
}

void BFS(int x, int y)
{
int  low, high, dir, i;
pair <int, int> newq;
     
     visited[x][y] = true;
     Q[low = high = 0] = make_pair(x, y);
     while (low <= high)
     {
           for (dir = 0; dir < 4; dir++)
           {
               newq = make_pair(Q[low].first + dx[dir], 
                                Q[low].second + dy[dir]);
               if (newq.first < 1 || newq.first > n ||
                   newq.second < 1 || newq.second > m ||
                   visited[newq.first][newq.second] ||
                   data[newq.first][newq.second] != '*')
               {
                   continue;
               }
               visited[newq.first][newq.second] = true;
               Q[++high] = newq;
           }
           low++;
     }
     
     number++;
     object[number].first = object[number].second = Q[0];
     for (i = 1; i <= high; i++)
     {
         object[number].first = min(object[number].first, Q[i]);
         object[number].second = max(object[number].second, Q[i]);
     }
     
     return;
}

long long Solve(pair <pair <int, int>, pair <int, int> > r)
{
int  i, j, current, one, numberup, numberdown;
bool stop;
pair <int, int> area, origin;
pair <pair <int, int>, pair <int, int> > temp;
long long answer;
     
     for (i = 1; i <= number; i++)
     if  (!solve[i])
     {
         temp.first.first = max(object[i].first.first, r.first.first);
         temp.first.second = max(object[i].first.second, r.first.second);
         temp.second.first = min(object[i].second.first, r.second.first);
         temp.second.second = min(object[i].second.second, r.second.second);
         if (temp.first.first <= temp.second.first &&
             temp.first.second <= temp.second.second)
         {
             return 0;
         }
     }
     
     origin = make_pair(1, m);
     
     for (i = 1; i <= number; i++)
     if  (!solve[i])
     {
         if (max(r.first.first, object[i].first.first) <= 
             min(object[i].second.first, r.second.first))
         {
             if (object[i].second.second < r.first.second)
             {
                origin.first = max(origin.first, object[i].second.second + 1);
             }  else
             {
                origin.second = min(origin.second, object[i].first.second - 1);
             }
         }
     }
     
     area = origin;
     current = r.first.first;
     numberup = 0;
     
     for (i = xx; i >= 1; i--)
     if  (x[i] < current)
     {
         up[++numberup] = make_pair(area, current - x[i]);
         current = x[i];
         stop = false;
         for (j = 1; j <= need[i][0]; j++)
         if  (object[need[i][j]].second.second < r.first.second)
         {
             area.first = max(area.first, object[need[i][j]].second.second + 1);
         }   else
         if  (r.second.second < object[need[i][j]].first.second)
         {
             area.second = min(area.second, object[need[i][j]].first.second - 1);
         }   else
         {
             stop = true;
             break;
         }
         if  (stop)
         {
             break;
         }
     }
     for (i = j = 1; i < numberup; i++)
     if  (up[i + 1].first != up[j].first)
     {
         up[++j] = up[i + 1];
     }   else
     {
         up[j].second += up[i + 1].second;
     }
     numberup = j;
     
     area = origin;
     current = r.second.first;
     numberdown = 0;
     
     for (i = 1; i <= xx; i++)
     if  (x[i] > current)
     {
         down[++numberdown] = make_pair(area, x[i] - current);
         current = x[i];
         stop = false;
         for (j = 1; j <= need[i][0]; j++)
         if  (object[need[i][j]].second.second < r.first.second)
         {
             area.first = max(area.first, object[need[i][j]].second.second + 1);
         }   else
         if  (r.second.second < object[need[i][j]].first.second)
         {
             area.second = min(area.second, object[need[i][j]].first.second - 1);
         }   else
         {
             stop = true;
             break;
         }
         if  (stop)
         {
             break;
         }
     }
     for (i = j = 1; i < numberdown; i++)
     if  (down[i + 1].first != down[j].first)
     {
         down[++j] = down[i + 1];
     }   else
     {
         down[j].second += down[i + 1].second;
     }
     numberdown = j;
     
     answer = 0;
     
     for (i = 1; i <= numberup; i++)
     {
         for (j = 1; j <= numberdown; j++)
         {
             one = (r.first.second - max(up[i].first.first, down[j].first.first) + 1) *
                   (min(up[i].first.second, down[j].first.second) - r.second.second + 1);
             answer += 1ll * one * up[i].second * down[j].second;
         }
     }
     
     return answer;
}

int main()
{
int i, j, k;
pair <pair <int, int>, pair <int, int> > temp;
long long answer;
    
//    freopen("k.in", "r", stdin);
//    freopen("k.out", "w", stdout);
    
    srand((unsigned) time (0));
    
    scanf("%d%d%d\n", &n, &m, &k);
    for (i = 1; i <= n; i++)
    {
        for (j = 1; j <= m; j++)
        {
            scanf("%c", &data[i][j]);
        }
        scanf("\n");
    }
    
    for (i = 1; i <= n; i++)
    {
        for (j = 1; j <= m; j++)
        if  (data[i][j] == '*' && !visited[i][j])
        {
            BFS(i, j);
        }
    }
    
    for (i = 1; i <= number; i++)
    {
        x[++xx] = object[i].first.first;
        x[++xx] = object[i].first.first - 1;
        x[++xx] = object[i].second.first;
        x[++xx] = object[i].second.first + 1;
    }
    x[++xx] = 0;
    x[++xx] = n + 1;
    
    sort(x + 1, x + xx + 1);
    for (i = j = 1; i < xx; i++)
    if  (x[i + 1] != x[j])
    {
        x[++j] = x[i + 1];
    }
    xx = j;
    
    for (i = 1; i <= xx; i++)
    {
        for (j = 1; j <= number; j++)
        if  (object[j].first.first <= x[i] &&
             x[i] <= object[j].second.first)
        {
             need[i][++need[i][0]] = j;
        }
    }
    
    answer = 0;
    
    for (i = 1; i <= number; i++)
    {
        solve[i] = true;
        answer += Solve(object[i]);
        solve[i] = false;
    }
    
    for (i = 1; i < number; i++)
    {
        for (j = i + 1; j <= number; j++)
        {
            temp.first.first = min(object[i].first.first, object[j].first.first);
            temp.first.second = min(object[i].first.second, object[j].first.second);
            temp.second.first = max(object[i].second.first, object[j].second.first);
            temp.second.second = max(object[i].second.second, object[j].second.second);
            solve[i] = solve[j] = true;
            answer += Solve(temp);
            solve[i] = solve[j] = false;
        }
    }
    
    for (i = 1; i < number - 1; i++)
    {
        for (j = i + 1; j < number; j++)
        {
            for (k = j + 1; k <= number; k++)
            {
                temp.first.first = min(object[i].first.first, 
                                   min(object[j].first.first, object[k].first.first));
                temp.first.second = min(object[i].first.second, 
                                    min(object[j].first.second, object[k].first.second));
                temp.second.first = max(object[i].second.first, 
                                    max(object[j].second.first, object[k].second.first));
                temp.second.second = max(object[i].second.second, 
                                     max(object[j].second.second, object[k].second.second));
                solve[i] = solve[j] = solve[k] = true;
                answer += Solve(temp);
                solve[i] = solve[j] = solve[k] = false;
            }
        }
    }
    
    printf("%I64d\n", answer);
    
    return 0;
}
