#include <iostream>
#include <algorithm>
#include <memory.h>
#include <stdio.h>
#include <math.h>
#include <cmath>

#define MAXK 100
#define MAXN 1010
#define VC 10000000
#define For(i, a, b) for (int i = a; i <= b; i++)

using namespace std;

typedef struct _Object{
	int x1, y1, x2, y2;
} Object;

typedef struct _Line{
	int x;
	int belong;
	int kind;
} Line;

typedef struct _Segment{
	int left, right, nCoveredObject;	
} Segment;

const int hang[4] = {-1, 0, 1, 0};
	  int cot[4] = {0, 1, 0, -1};
	  
Object *List;
Object *savedList;
Line *ListLine, *savedListLine;
Segment *ListSegment, *savedListSegment;
int m, n, k, nListSegment;
long long res;
char **table;

void getInput(){
	scanf("%d%d%d\n", &m, &n, &k);
	table = new char*[m + 1];
	For(i, 0, m - 1){
		table[i] = new char[n + 1];
		gets(table[i]);
	}
}

void DFS(int i, int j){
	//cout << i <<" " << j << endl;
	table[i][j] = '.';
	List->x1 = min(List->x1, i);
	List->x2 = max(List->x2, i);
	List->y1 = min(List->y1, j);
	List->y2 = max(List->y2, j);
	
	For (t, 0, 3){
		int x = i + hang[t];
		int y = j + cot[t];
		if (0 <= x && x < m && 0 <= y && y < n)
			if (table[x][y] == '*') 
				DFS(x, y);
	}
}

void buildList(){
	List = (Object*)malloc(sizeof(Object) * MAXK);
	ListLine = (Line*)malloc(sizeof(Line) * MAXK * 2);
	savedList = List;
	savedListLine = ListLine;
	int count = 0;
	
	For (i, 0, m - 1)
	For (j, 0, n - 1)
		if (table[i][j] == '*'){
			List->x1 = VC;
			List->x2 = -VC;
			List->y1 = VC;
			List->y2 = -VC;
			
			DFS(i, j);
			
			ListLine->belong = count;
			ListLine->kind = 0;
			ListLine->x = List->y1;
			++ListLine;
			
			ListLine->belong = count;
			ListLine->kind = 1;
			ListLine->x = List->y2;
			
			++count;
			++ListLine;
			++List;
		}
	ListLine = savedListLine;
	List = savedList;
}

int cmp(Line a, Line b){
	return (a.x < b.x ||(a.x == b.x && a.kind < b.kind));	
}
void sortListLine(){
	sort(ListLine, ListLine + 2 * k, cmp);
}

int cutStrip(Line a, int up, int down){
	return (!(List[a.belong].x2 < up || List[a.belong].x1 > down));
}

int belongToStrip(Line a, int up, int down){
	return ((List[a.belong].x1 >= up) && (List[a.belong].x2 <= down));
}

long long pre(int j){
	if (j == 0) 
		return ((long long)(ListSegment[j].left + 1));
	else 
		return ((long long)(ListSegment[j].left - ListSegment[j - 1].right));
}

long long next(int i){
	if (i == nListSegment - 1)
		return ((long long)(n - 1 - ListSegment[i].right + 1));
	else 
		return ((long long)(ListSegment[i + 1].left - ListSegment[i].right));
}

void Solve(int up, int down){
	int nTempObject;
	For (i, 0, nListSegment - 1){
		nTempObject = 0;
		for (int j = i; j >= max(0, i - 2); j--){
			nTempObject += ListSegment[j].nCoveredObject; 
			if (nTempObject > 3) break;
			res += pre(j) * next(i);	
		}
	};
}
void solve(int up, int down){
	int nCurrentObject = 0;
	nListSegment = 0;
	ListSegment[nListSegment].nCoveredObject = 0;
	For (i, 0, 2 * k - 1)
		if (cutStrip(ListLine[i], up, down)){
			if ( ListLine[i].kind == 0)	{
				if (nCurrentObject == 0){
					ListSegment[nListSegment].left = ListLine[i].x;
				}
				++nCurrentObject;
				//if (up == 0 and down ==0 ) printf("%d\n", belongToStrip(ListLine[i], up, down));
				if (belongToStrip(ListLine[i], up, down))
					ListSegment[nListSegment].nCoveredObject++;
				else
					ListSegment[nListSegment].nCoveredObject += VC;
			}
			else{
				--nCurrentObject;
				if (nCurrentObject == 0){
					ListSegment[nListSegment].right = ListLine[i].x;
					nListSegment++;
					ListSegment[nListSegment].nCoveredObject = 0;
				}
			}
		}	
	//printf("=> %d\n", nListSegment);
	//For (i, 0, nListSegment - 1) printf("%d %d %d\n", ListSegment[i].left, ListSegment[i].right, ListSegment[i].nCoveredObject);
	Solve(up, down);
}

int main(){
	//freopen("in.txt", "r", stdin);
	getInput();
	buildList();
	sortListLine();
	res = 0;
	ListSegment = (Segment*) malloc(sizeof(Segment) * MAXK);
	savedListSegment = ListSegment;
	For (i, 0, m - 1)
	For (j, i, m - 1)
		{
			solve(i, j);
		//	printf("-> %d %d %lld\n", i, j, res);
		}
	printf("%I64d", res);
	//fclose(stdin);
	return 0;
}
