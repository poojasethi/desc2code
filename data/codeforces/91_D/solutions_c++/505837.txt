#include <iostream>
#include <algorithm>
#include <vector>
#include <cmath>
#include <cstdio>
#include <string>
#include <stack>
#include <queue>
#include <set>
#include <map>
#include <string.h>
#include <cassert>

using namespace std;

#define GI ({int t;scanf("%d",&t);t;})
#define FOR(i,a,b) for(int i=a;i<b;i++)
#define REP(i,n) FOR(i,0,n)
#define pb push_back
#define sz size()
#define INF (int)1e9
#define EPS LD(1e-9)
#define DINF LD(1e50)

typedef long long LL;
typedef vector<int> VI;
typedef vector<string> VS;
typedef vector<vector<int> > VVI;
typedef pair<int,int> PII;
typedef double LD;

const int mn=100005;
int n, a[mn];
int ans=0, ans2=0;
VVI comp;
bool seen[mn];
VVI mod[5];

void print(VI & cur,int l,int r){
	ans2++;
	printf("%d\n",r-l);
	FOR(i,l,r)	printf("%d ",cur[i]+1);printf("\n");
	FOR(i,l+1,r)	printf("%d ",cur[i]+1);printf("%d ",cur[l]+1);printf("\n");	
}

void print(const VI & cur,int l1,int r1,int l2,int r2){
	ans2++;
	printf("%d\n",r2-l1);
	FOR(i,l1,r2)	printf("%d ",cur[i]+1);printf("\n");
	FOR(i,l1+1,r1)	printf("%d ",cur[i]+1);printf("%d ",cur[l1]+1);
	FOR(i,l2+1,r2)	printf("%d ",cur[i]+1);printf("%d ",cur[l2]+1);
	printf("\n");		
}

int main(){
	
//	freopen("inp.txt","r",stdin);
//	freopen("out.txt","w",stdout);
	
	n=GI;
	REP(i,n)	a[i]=GI-1;
	REP(i,n)	if(!seen[i]){
		VI v;
		int j=i;
		do{
			seen[j]=1;
			v.pb(j);
			j=a[j];
		}while(j!=i);	
		comp.pb(v);
	}
	REP(i,comp.sz){
		int v=comp[i].sz;
		while(v>=6)	v-=4, ans++;
		if(v==5)	v=0, ans++;
		mod[v].pb(comp[i]);	
	}
	ans+=mod[4].sz;
	if(mod[2].sz>mod[3].sz){
		ans+=mod[3].sz;
		int rem=mod[2].sz-mod[3].sz;
		ans+=(rem+1)/2;
	}
	else{
		int rem=mod[3].sz-mod[2].sz;
		ans+=mod[2].sz;
		ans+=rem/3*2;
		ans+=rem%3;
	}
	printf("%d\n",ans);
	
	REP(t,5)	REP(i,mod[t].sz){
		VI cur=mod[t][i];
		int v=cur.sz;
		while(v>=6){
			print(cur,v-5,v);
			v-=4;	
		}	
		if(v==5){
			print(cur,v-5,v);	
			v=0;
		}
		mod[t][i]=cur;
	}
	
	REP(i,mod[4].sz){
		VI cur=mod[4][i];
		print(cur,0,4);
	}
	
	if(mod[2].sz>mod[3].sz){
		REP(i,mod[3].sz){
			VI cur=mod[3][i];
			VI cur1=mod[2][i];
			VI r;
			r.pb(cur[0]);r.pb(cur[1]);r.pb(cur[2]);
			r.pb(cur1[0]);r.pb(cur1[1]);
			print(r,0,3,3,5);
		}
		FOR(i,mod[3].sz,mod[2].sz){
			if(i+1==mod[2].sz)	print(mod[2][i],0,2);
			else{
				VI r;
				r.pb(mod[2][i][0]);r.pb(mod[2][i][1]);
				r.pb(mod[2][i+1][0]);r.pb(mod[2][i+1][1]);
				print(r,0,2,2,4);
				i++;	
			}
		}
	}
	else{
		REP(i,mod[2].sz){
			VI cur=mod[3][i];
			VI cur1=mod[2][i];
			VI r;
			r.pb(cur[0]);r.pb(cur[1]);r.pb(cur[2]);
			r.pb(cur1[0]);r.pb(cur1[1]);
			print(r,0,3,3,5);
		}	
		FOR(i,mod[2].sz,mod[3].sz){
			if(i+2>=mod[3].sz)	print(mod[3][i],0,3);
			else{
				VI r;
				r.pb(mod[3][i][0]);r.pb(mod[3][i][1]);r.pb(mod[3][i][2]);
				r.pb(mod[3][i+1][0]);r.pb(mod[3][i+1][1]);
				i++;
				print(r,0,3,3,5);
				r.clear();
				r.pb(mod[3][i+1][0]);r.pb(mod[3][i+1][1]);r.pb(mod[3][i+1][2]);
				r.pb(mod[3][i][0]);r.pb(mod[3][i][2]);
				print(r,0,3,3,5);
				i++;	
			}
		}
	}

//	while(1);
	return 0;
}
