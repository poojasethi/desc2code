#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <queue>
#include <map>
#include <set>
#include <utility>
#include <numeric>
#include <algorithm>
using namespace std;
#ifdef DEBUGRUN
#define LOG(a) (cerr<<__LINE__<<": "#a" = "<<(a)<<endl)
#define DBG(...) (__VA_ARGS__)
#else
#define LOG(...) ((void)0)
#define DBG(...) ((void)0)
#endif
#define rep(i, n) for(int i=0; i<(int)(n); i++)
#define mp make_pair
#define foreach(it, c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); it++)
typedef long long Int;
#define INF (MY_INFINITY)
#define MOD (YOUR_MODULUS)

struct unionset {
    int ud[400000];
    void init() { memset(ud, -1, sizeof(ud)); }
    int root(int x) { return ud[x]<0 ? x : ud[x]=root(ud[x]); }
    int size(int x) { return -ud[root(x)]; }
    bool same(int x, int y) { return root(x)==root(y); }
    bool set(int x, int y) {
        x=root(x); y=root(y);
        if(x!=y) {
            if(ud[y]<ud[x]) std::swap(x, y);
            ud[x]+=ud[y]; ud[y]=x;
        }
        return x!=y;
    }
} un;

int n, a[400000];

int m, b[10], c[10], r[10];

void add(int x, int k) {
    rep(i, k) {
        r[i] = x;
        x = a[x];
    }
    a[r[0]] = a[r[k-1]];
    for(int i=1; i<k; i++) a[r[i]] = r[i];
    rep(i, k) {
        b[m+i] = r[i];
        c[m+i] = r[(i+1)%k];
    }
    m += k;
}

int qn, qm[400000], qb[400000][5], qc[400000][5];

void out() {
    qm[qn] = m;
    rep(i, m) qb[qn][i] = b[i];
    rep(i, m) qc[qn][i] = c[i];
    qn++;
    //printf("%d\n", m);
    //rep(i, m) printf("%d%c", b[i]+1, i<m-1 ? ' ' : '\n');
    //rep(i, m) printf("%d%c", c[i]+1, i<m-1 ? ' ' : '\n');
    m = 0;
}

int main() {
    scanf("%d", &n);
    rep(i, n) scanf("%d", a+i);
    rep(i, n) a[i]--;
    un.init();
    rep(i, n) un.set(i, a[i]);
    vector<int> v[5];
    rep(i, n) if(un.root(i)==i) {
        int s = un.size(i);
        while(s>=5) {
            add(i, 5);
            out();
            s -= 4;
        }
        v[s].push_back(i);
    }
    rep(i, n) LOG(a[i]+1);
    while(v[3].size()) {
        add(v[3].back(), 3);
        v[3].pop_back();
        if(v[2].size()) {
            add(v[2].back(), 2);
            v[2].pop_back();
        }
        else if(v[3].size()) {
            v[2].push_back(v[3].back());
            add(v[3].back(), 2);
            v[3].pop_back();
        }
        out();
    }
    while(v[2].size()) {
        add(v[2].back(), 2);
        v[2].pop_back();
        if(v[2].size()) {
            add(v[2].back(), 2);
            v[2].pop_back();
        }
        out();
    }
    while(v[4].size()) {
        add(v[4].back(), 4);
        v[4].pop_back();
        out();
    }
    rep(i, n) LOG(a[i]+1);
    printf("%d\n", qn);
    rep(k, qn) {
        printf("%d\n", qm[k]);
        rep(i, qm[k]) printf("%d%c", qb[k][i]+1, i<qm[k]-1 ? ' ' : '\n');
        rep(i, qm[k]) printf("%d%c", qc[k][i]+1, i<qm[k]-1 ? ' ' : '\n');
    }
    return 0;
}

