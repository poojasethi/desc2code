#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <set>
#include <vector>
#include <queue>
#include <stack>
#define VI vector<int>
#define pb push_back
#define dedge(g,a,b) g[a].pb(b)
const int MAXN = 210*210;
using namespace std;
VI g[MAXN];
VI dag[MAXN];
int n, m, q;
char M[210][210];
int movx[10], movy[10];
bool vis[MAXN];
bool stacked[MAXN];
bool cycle1[MAXN], cycle2[MAXN];
int low[MAXN], indexes[MAXN], belongs[MAXN], val[MAXN];
int ind, scc;
stack<int> s;
set<int> adj[MAXN];
void tarjan(int node){
    vis[node] = true;
    low[node] = indexes[node] = ind++;
    stacked[node] = true; s.push(node);
    for(int i=0; i<(int)g[node].size(); i++){
        int next = g[node][i];
        if(!vis[next]){
            tarjan(next);
            low[node] = min(low[node], low[next]);
        }else if(stacked[next]){
            low[node] = min(low[node], indexes[next]);
        }
    }
    if(low[node] == indexes[node]){
        val[scc] = 0;
        while(true){
            int cur = s.top(); s.pop(); stacked[cur] = false;
            belongs[cur] = scc;
            int x = cur/m, y = cur%m;
            val[scc] |= (1<<(int)(M[x][y] - '0'));
            cycle2[scc] |= cycle1[cur];
            if(cur==node) break;
            cycle2[scc] = true;
        }
        scc++;
    }
}       
char S[1000010];
int dig[1000010];
bool dfs(int pos, int node){
    if(cycle2[node]){
        for(; pos>=0 && (dig[pos] & val[node]) == dig[pos]; pos--);
        if(pos<0) return true;
    }
    if(val[node] == (1<<(S[pos]-'0'))) pos--;
    if(pos<0) return true;
    bool ans = false;
    for(int i=0; i<(int)dag[node].size() && !ans; i++){
        int next = dag[node][i];
        ans |= dfs(pos, next);
    }
    return ans;
}
void solve(){
    int l = strlen(S);
    dig[l] = 0;
    bool ans = false;
    for(int i=l-1; i>=0; i--) dig[i] = dig[i+1] | (1<<(S[i]-'0'));
    for(int i=0; i<scc && !ans; i++) if(cycle2[i]) ans |= dfs(l-1, i);
    printf("%s\n", ans ? "YES" : "NO");
}
int main(){
    //freopen("input.in", "r", stdin);
    scanf("%d %d %d", &n, &m, &q);
    for(int i=0; i<n; i++) scanf("%s", M[i]);
    for(int i=0; i<10; i++) scanf("%d %d", &movx[i], &movy[i]);
    for(int i=0; i<n; i++){
        for(int j=0; j<m; j++){
            int p = M[i][j]-'0';
            int nx = i + movx[p], ny = j + movy[p];
            if(nx<0 || nx>=n || ny<0 || ny>=m){
                cycle1[i*m + j] = true;
                continue;
            }
            dedge(g, nx*m + ny, i*m + j);
        }
    }
    ind = 0; scc = 0;
    memset(val, 0, sizeof(val));
    for(int i=0; i<n*m; i++){
        if(!vis[i]) tarjan(i);
    }
    for(int i=0; i<n*m; i++){
        int cur = belongs[i];
        for(int j=0; j<(int)g[i].size(); j++){
            int next = belongs[g[i][j]];
            if(cur==next) continue;
            if(adj[cur].count(next)!=0) continue;
            adj[cur].insert(next);
            dedge(dag, cur, next);
        }
    }
    for(int i=0; i<q; i++){
        scanf("%s", S);
        solve();
    }
    return 0;
}
