#!/usr/bin/python
from collections import deque

class Node:
	def __init__(self, left, right):
		self.left  = left
		self.right = right

n = int(raw_input())
a = map(lambda x: int(x), raw_input().split())
maxLen = max(a)
lenTable = {x: 0 for x in range(1, maxLen+1)}
for x in a:
	lenTable[x] += 1

prev = []
for i in range(maxLen, 0, -1):
	leaves = []
	for j in range(lenTable[i]):
		leaves.append(Node(None, None))
	nodes = prev + leaves
	num = len(nodes)
	if num > 2**i:
		print "NO"
		exit(0)
	prev = []
	for j in range(num/2):
		internalNode = Node(nodes[2*j], nodes[2*j+1])
		prev.append(internalNode)
	if num%2 == 1:
		internalNode = Node(nodes[num-1], None)
		prev.append(internalNode)

assert(len(prev) == 1)

output = {x: [] for x in range(1, maxLen+1)}

class QueueKey:
	def __init__(self, node, d, s):
		self.node = node
		self.d    = d
		self.s    = s

def bfs(t):
	queue = deque()
	queue.append(QueueKey(t, 0, ''))
	while len(queue) > 0:
		k = queue.popleft()
		node, d, s = k.node, k.d, k.s
		if node.left == None and node.right == None:
			output[d].append(s)
			continue
		if node.left:
			queue.append(QueueKey(node.left, d+1, s+'0'))
		if node.right:
			queue.append(QueueKey(node.right, d+1, s+'1'))


bfs(prev[0])
print "YES"
for x in a:
	assert(len(output[x]) > 0)
	print output[x].pop()
