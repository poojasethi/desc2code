
class TrieNode(object):

	ALPHABET_SIZE=26

	def __init__(self,value=None):
		self.value=value
		self.children=[None for i in xrange(TrieNode.ALPHABET_SIZE)]
		self.count=0
		self.is_final=0
		

	@staticmethod
	def get_char_index(char):
		return ord(char)-ord('a')

	def insert(self,string):	

		n=len(string)

		if len(string)==0:
			#pensar en lanzar un error
			return

		node=self
		node.count+=1

		for level in xrange(n):
			char_index=TrieNode.get_char_index(string[level])
			
			if node.children[char_index] is None:#if character not in trie insert it				
				node.children[char_index]=TrieNode(char_index)
			node=node.children[char_index]
			node.count+=1
		node.is_final=1


	def search(self,string):

		n=len(string)

		if len(string)==0:
			return None

		current=self

		for level in xrange(n):
			char_index=TrieNode.get_char_index(string[level])

			node=current.children[char_index]
			if node is None:return None
			current=node
		return current

	def delete(self,string):
		pass

	#pythpn special methods

	def __contains__(self,string):
		node=self.search(string)
		if node is None:return False				
		return node.is_final

	def __len__(self):
		return self.count

	def __str__(self):

		def to_char(trie_node):
			if trie_node:
				if not trie_node.value is None:return chr(trie_node.value+97)
				else:return "R"
			else:return "$"
		res=to_char(self)
		res+=":"
		res+=(" ".join(map(to_char,self.children)))
		res+="\n"
		for children in self.children:
			if children:res+= str(children)
		return res
	def __repr__(self):
		if self:
				if not self.value is None:return chr(self.value+97)
				else:return "R"
		else:return "$"

def first_win(trie):

	Q=[]
	Q.append(trie)	
	trie.is_winning=False
	trie.can_loose=False
	trie.child_index=0
	n=0
	last=None
	# import ipdb;ipdb.set_trace()
	while Q:
		curr=Q[len(Q)-1]
		if curr.child_index>0:			
			#use child information as feedback
			if curr.children[curr.child_index-1]:				
				child=curr.children[curr.child_index-1]				
				if not child.is_winning:
					curr.is_winning=True					
				if not child.can_loose:
					curr.can_loose=True

		#has not processed child
		if curr.child_index<TrieNode.ALPHABET_SIZE:
			current=curr.children[curr.child_index]
			if current:
				current.child_index=0
				current.is_winning=False

				if current.is_final :current.can_loose=True
				else:current.can_loose=False				
				Q.append(current)				
			curr.child_index+=1#child processed
		else:
			# ipdb.set_trace()
			curr=Q.pop()
			#proccessing node			
			
	return trie.is_winning,trie.can_loose






		
	
	




import sys

def main1():
	# inName='input.txt'
	inName=''
	outName=''


	if inName is not '' :
		sys.stdin=open(inName,'r')


	if outName is not '':
		sys.stdout=open(outName,'w')

	n,k=map(int,raw_input().strip().split())
	trie=TrieNode()
	for i in xrange(n):
		trie.insert(raw_input().strip())

	can_win,can_loose=first_win(trie)
	
	if can_win:
		if can_loose:print 'First'
		elif k%2==0:print 'Second'
		else:print 'First'
	else:
		print 'Second'





def add_to_trie(trie,word):
	#trie a dictionary		
	node=trie
	for letter in word:
		next=node.get(letter)
		if next is None:
			next={}			
			node[letter]=next
		node=next

def solve(trie):

	if len(trie):
		win,loose=False,False
		#process childrens
		for child in trie.itervalues():
			solve(child)
			if 'win' not in child:
				win=True
			if 'loose' not in child:
				loose=True
		if win:trie['win']=True
		if loose:trie['loose']=True
	else:		
		trie['loose']=0










def main():
	# sys.stdin=open("input.txt",'r')
	n,k=map(int,raw_input().strip().split())
	trie={}
	
	for i in xrange(n):
		add_to_trie(trie,raw_input().strip())
	solve(trie)
	
	if 'win' in trie:
		if 'loose' in trie:print 'First'
		elif k%2==0:print 'Second'
		else:print 'First'
	else:
		print 'Second'

	



main()