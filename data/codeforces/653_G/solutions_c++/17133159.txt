#include <iostream>
#include <vector>
#include <cmath>
#include <map>

using namespace std;

typedef long long int ll;

ll modulo=1e9+7;

void anyade(ll &a,ll b)
{
  a=(a+b)%modulo;
}

const int limite=300001;

ll eleva(ll b,ll e)
{
  if (e==0) return 1;
  if (e%2==0) return eleva(b*b%modulo,e/2);
  return b*eleva(b*b%modulo,e/2)%modulo;
}

ll inverso(ll x)
{
  return eleva(x,modulo-2);
}

int esprimo[limite];
int factor[limite];
vector<int> veces[limite];

void generaveces(int x)
{
  while (x>1) {
    int ap=0;
    int f=factor[x];
    while (factor[x]==f) {
      x/=f;
      ap++;
    }
    veces[f].push_back(ap);
  }
}

ll fact[limite];
ll factinv[limite];

ll combi(int n,int k)
{
  return fact[n]*factinv[n-k]%modulo*factinv[k]%modulo;
}

ll calcula(int n1,int n2)
{
  int mini=min(n1,n2);
  ll mem1=0;
  for (int i1=n1;i1>=mini;i1--)
    anyade(mem1,combi(n1,i1));
  ll mem2=0;
  for (int i2=n2;i2>=mini;i2--)
    anyade(mem2,combi(n2,i2));
  ll sol=0;
  for (int i=mini;i>=0;i--) {
    anyade(sol,(combi(n1,i)*mem2+combi(n2,i)*mem1-combi(n1,i)*combi(n2,i))%modulo*i);
    if (i>0) {
      anyade(mem1,combi(n1,i-1));
      anyade(mem2,combi(n2,i-1));
    }
  }
  return sol;
}

ll memoria[limite];
int calculado[limite];

ll calculamem(int n1,int n2)
{
  int mini=min(n1,n2);
  ll &mem=memoria[mini];
  if (calculado[mini]) return mem;
  calculado[mini]=1;
  mem=calcula(n1,n2);
  return mem;
}


int n;

int main()
{
  ios::sync_with_stdio(false);
  for (int i=2;i<limite;i++)
    esprimo[i]=1;
  for (int i=2;i<limite;i++) {
    if (esprimo[i]) {
      factor[i]=i;
      for (int j=i+i;j<limite;j+=i) {
	esprimo[j]=0;
	factor[j]=i;
      }
    }
  }
  fact[0]=factinv[0]=1;
  for (int i=1;i<limite;i++) {
    fact[i]=fact[i-1]*i%modulo;
    factinv[i]=inverso(fact[i]);
  }
  cin>>n;
  for (int i=0;i<n;i++) {
    int x;
    cin>>x;
    generaveces(x);
  }
  ll sol=0;
  for (int p=0;p<limite;p++) {
    if (int(veces[p].size())>0) {
      vector<int> &v=veces[p];
      map<int,int> mapa;
      for (int i=0;i<int(v.size());i++)
	mapa[v[i]]++;
      if (int(v.size())<n) mapa[0]=n-int(v.size());
      vector<pair<int,int> > w;
      for (map<int,int>::iterator it=mapa.begin();it!=mapa.end();it++)
	w.push_back(pair<int,int> (it->first,it->second));
      int n1=0;
      for (int i=0;i<int(w.size())-1;i++) {
	pair<int,int> &p1=w[i];
	n1+=p1.second;
	pair<int,int> &p2=w[i+1];
	anyade(sol,(p2.first-p1.first)*calculamem(n1,n-n1));
      }
    }
  }
  cout<<sol<<endl;
}
