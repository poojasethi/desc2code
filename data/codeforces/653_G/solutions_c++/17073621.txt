#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
#include<queue>
#include<map>
#include<set>
using namespace std;
typedef long long ll;
const int mod=1e9+7;
const int maxn=3e5+5;
int n,minp[maxn],wk[maxn],rest[maxn];
vector<int> v;vector<pair<int,int> >prim;
int powmod(int a,int n)
{
	if(n==0) return 1;
	int sq=powmod(a,n/2);
	sq=((ll)sq*sq)%mod;if(n%2==0) return sq;
	return ((ll)sq*a)%mod;
}
int power[maxn],pre[maxn],fac[maxn],infac[maxn];
int newton(int a,int b)
{
	if(b>a) return 0;
	int x=((ll)fac[a]*infac[b])%mod;
	return ((ll)x*infac[a-b])%mod;
}
int rob(int n1,int n2)
{
	if(n1==n2) return 0;
	int ns=pre[n2-1];
	int ujm=(n1==0?0:pre[n1-1]);
	return (ns+(mod-ujm))%mod;
}
int main()
{
	for(int i=1;i<300005;i++) minp[i]=i;
	for(int i=2;i<300001;i++) 
		if(minp[i]==i)
			for(ll j=(ll)i*i;j<=300000;j+=i) minp[j]=i;
	rest[1]=1;
	for(int i=2;i<300001;i++)
	{
		int p=minp[i],wy=0,mask=i;
		while(mask%p==0) {mask=mask/p;wy++;}
		rest[i]=mask;wk[i]=wy;
	}
	scanf("%d",&n);
	for(int i=0;i<n;i++){int a;scanf("%d",&a);v.push_back(a);}
	fac[1]=1;
	for(int i=2;i<=n;i++) fac[i]=((ll)fac[i-1]*i)%mod;
	infac[1]=1;
	for(int i=2;i<=n;i++) infac[i]=powmod(fac[i],mod-2);
	for(int i=0;i<n;i++)
	{
		int x=v[i];
		while(x!=1)
		{
			int p=minp[x],wy=wk[x];
			prim.push_back(make_pair(p,wy));
			x=rest[x];
		}		
	}
	power[0]=(mod+1-powmod(2,n-1))%mod;
	pre[0]=power[0];
	for(int i=1;i<n;i++)
	{
		power[i]=(power[i-1]+newton(n,i))%mod;
		pre[i]=(pre[i-1]+power[i])%mod;
	}
	sort(prim.begin(),prim.end());
	int ans=0,i=0,p=prim[0].first,dupa[20];
	for(int i=0;i<20;i++) dupa[i]=0;
	while(i<prim.size())
	{
		if(prim[i].first==p) {dupa[prim[i].second]++;i++;}
		else 
		{
			int sum=0;
			for(int j=0;j<20;j++) sum+=dupa[j];
			dupa[0]=n-sum;int act=0;
			for(int j=0;j<20;j++)
			{
				ans+=((ll)j*rob(act,act+dupa[j]))%mod;
				ans%=mod;act=act+dupa[j];
			}
			for(int j=0;j<20;j++) dupa[j]=0;
			p=prim[i].first;dupa[prim[i].second]++;i++;
		}
	}
	int sum=0;
	for(int j=0;j<20;j++) sum+=dupa[j];
	dupa[0]=n-sum;int act=0;
	for(int j=0;j<20;j++)
	{
		ans+=((ll)j*rob(act,act+dupa[j]))%mod;
				ans%=mod;act=act+dupa[j];
	}

	printf("%d\n",ans);
	
 	return 0;
}

