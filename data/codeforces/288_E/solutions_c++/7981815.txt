#include <bits/stdc++.h>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define SZ(x) ((int)(x).size())
#define fi first
#define se second
typedef vector<int> VI;
typedef long long ll;
typedef pair<int,int> PII;
const ll mod=1000000007;
ll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
// head

const int N=101000;
ll pw2[N],pw10[N],pw4[N],pw7[N],sp[N],sum[N],ret[N];
string l,r;
ll calc(ll s,int w) {
	return (s*s%mod*(pw2[w]-1)+(2*sp[w]-pw4[w]-pw7[w])%mod*s+sum[w])%mod;
}
void precalc() {
	pw2[0]=pw10[0]=1;
	rep(i,1,100010) {
		pw2[i]=pw2[i-1]*2%mod;
		pw10[i]=pw10[i-1]*10%mod;
		pw4[i]=(pw4[i-1]*10+4)%mod;
		pw7[i]=(pw7[i-1]*10+7)%mod;
		sp[i]=(sp[i-1]*2+11*pw10[i-1]%mod*pw2[i-1])%mod;
		sum[i]=(calc(4*pw10[i-1]%mod,i-1)+calc(7*pw10[i-1]%mod,i-1)+
			(4*pw10[i-1]+pw7[i-1])%mod*((7*pw10[i-1]+pw4[i-1])%mod))%mod;
		ret[i]=(sum[i]+ret[i-1]+pw4[i]*pw7[i-1])%mod;
	}
}
ll getr(VI R) {
	reverse(all(R));
	ll ans=ret[SZ(R)-1],pv=pw7[SZ(R)-1],pre=0;
	per(i,0,SZ(R)) {
		if (R[i]==0) continue;
		else if (R[i]==1) pre=(pre+4*pw10[i])%mod;
		else {
			ans=(ans+pv*(pre+pw4[i+1])+calc((pre+4*pw10[i])%mod,i))%mod;
			pv=(pre+4*pw10[i]+pw7[i])%mod; pre=(pre+7*pw10[i])%mod;
		}
	}
	return ans;
}
VI L,R;
int main() {
	precalc();
	cin>>l>>r;
	L.pb(0);
	rep(i,0,SZ(l)) if (l[i]>='7') L.pb(2); else if (l[i]>='4') L.pb(1); else L.pb(0);
	per(i,0,SZ(L)) if (L[i]==2) L[i]=0; else { L[i]++;break;}
	if (!L[0]) L.erase(L.begin());
	R.pb(0);
	rep(i,0,SZ(l)) if (r[i]>='7') R.pb(2); else if (r[i]>='4') R.pb(1); else R.pb(0);
	per(i,0,SZ(R)) if (R[i]==2) R[i]=0; else { R[i]++;break;}
	if (!R[0]) R.erase(R.begin());
	printf("%I64d\n",((getr(R)-getr(L))%mod+mod)%mod);
	
}
