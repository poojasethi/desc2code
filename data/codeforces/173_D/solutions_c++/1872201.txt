#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <string>
#include <cstring>
#include <vector>
#include <map>
#include <set>
#include <queue>
#include <ctime>
#include <sstream>
#include <cmath>

using namespace std;

#define MP make_pair
#define PB push_back

const int maxN = 100000 + 10;
vector <int> G[maxN], can, all[2];
queue <int> Q;
int n = 0, m = 0, a1, a2;
int vis[maxN], deg[maxN], __connect[maxN], color[maxN];

void ins(int a, int b) {
	G[a].PB(b);
}
void fillColor(int total) {
	int __count = 0;
	for (int i = 0; i < all[0].size(); i++) {
		if (vis[all[0][i]]) continue;
		__count++;
		vis[all[0][i]] = total;
		if (__count == 3) __count  = 0, ++total;
	}
	for (int i = 0; i < all[1].size(); i++) {
		if (vis[all[1][i]]) continue;
		__count++;
		vis[all[1][i]] = total;
		if (__count == 3) __count  = 0, ++total;
	}
}
void print() {
	for (int i = 1; i <= n; i++)
		printf("%d ", vis[i]);
	puts("");
}
int main() {
	scanf("%d%d", &n, &m);
	for (int i = 0; i < m; i++) {
		scanf("%d%d", &a1, &a2);
		ins(a1, a2);
		ins(a2, a1);
		deg[a1]++, deg[a2]++;
	}
	memset(color, -1, sizeof color);
	for (int s = 1; s <= n; s++)
		if (color[s] == -1) {
			while (!Q.empty()) Q.pop();
			Q.push(s); color[s] = 0;
			all[0].PB(s);
			while (!Q.empty()) {
				int x = Q.front(); Q.pop();
				for (int i = 0; i < G[x].size(); i++)
					if (color[G[x][i]] == -1) {
						Q.push(G[x][i]);
						color[G[x][i]] = (color[x] ^ 1);
						all[color[G[x][i]]].PB(G[x][i]);
					}
			}
		}
	if (all[0].size() % 3 == 0) {
		puts("YES");
		fillColor(1);
		print();
	} else {
		if (all[0].size() % 3 == 2) swap(all[0], all[1]);
		for (int i = 0; i < all[0].size(); i++)
			if (all[1].size() - deg[all[0][i]] >= 2) {
				puts("YES");
				vis[all[0][i]] = 1;
				memset(__connect, 0, sizeof __connect);
				for (int j = 0; j < G[all[0][i]].size(); j++)
					__connect[G[all[0][i]][j]] = 1;
				int need = 2;
				for (int j = 0; j < all[1].size(); j++)
					if (!__connect[all[1][j]]) {
						need--;
						vis[all[1][j]] = 1;
						if (need == 0) break;
					}
				fillColor(2);
				print();
				return 0;
			}
		for (int i = 0; i < all[1].size(); i++)
			if (all[0].size() - deg[all[1][i]] >= 2)
				can.PB(all[1][i]);
		if (can.size() >= 2) {
			puts("YES");
			for (int i = 0; i < 2; i++) {
				int tmp = can[i];
				vis[tmp] = i + 1;
				memset(__connect, 0, sizeof __connect);
				for (int j = 0; j < G[tmp].size(); j++)
					__connect[G[tmp][j]] = 1;
				int need = 2;
				for (int j = 0; j < all[0].size(); j++)
					if (!__connect[all[0][j]]) {
						need--;
						vis[all[0][j]] = i + 1;
						if (need == 0) break;
					}
			}
			fillColor(3);
			print();
		} else puts("NO");
	}
    return 0;
}
