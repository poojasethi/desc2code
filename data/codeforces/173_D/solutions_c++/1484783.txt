#include <algorithm>
#include <cstdio>
#include <cstring>
#include <vector>

using namespace std;

const int MAXN = 300000;

int n, m;
vector<int> g[MAXN];

int n1, n2, nr = 0;
bool good[MAXN];
int bank1[MAXN], bank2[MAXN];
int answer[MAXN];

void easy()
{
  int l = 0;

  for (int i = 0; i < n1; ++i) {
    if (good[bank1[i]]) {
      if (l == 0) { ++nr; l = 2; } else { --l; }
      answer[bank1[i]] = nr;
    }
  }

  for (int i = 0; i < n2; ++i) {
    if (good[bank2[i]]) {
      if (l == 0) { ++nr; l = 2; } else { --l; }
      answer[bank2[i]] = nr;
    }
  }
}

bool mark[MAXN];

void dfs(int u, int parity)
{
  mark[u] = true;
  if (parity) bank1[n1++] = u; else bank2[n2++] = u;

  for (int e = 0; e < g[u].size(); ++e)
    if (!mark[g[u][e]]) dfs(g[u][e], 1 - parity);
}

bool part1(int bc[], int bother[], int nc)
{
  int nother = n - nc;

  for (int i = 0; i < nc; ++i) {
    if (g[bc[i]].size() >= nother - 1) continue;

    sort(g[bc[i]].begin(), g[bc[i]].end());
    ++nr; answer[bc[i]] = nr; good[bc[i]] = false;

    int l = 2;
    for (int j = 0; j < nother; ++j)
      if (!binary_search(g[bc[i]].begin(), g[bc[i]].end(), bother[j])) {
         answer[bother[j]] = nr;  good[bother[j]] = false;
        --l; if (l == 0) break;
      }

    return true;
  }

  return false;
}

bool part2(int bc[], int bother[], int nc)
{
  int nother = n - nc, q = 2;

  for (int i = 0; i < nc; ++i) {
    if (g[bc[i]].size() >= nother - 1) continue;

    sort(g[bc[i]].begin(), g[bc[i]].end());
    ++nr; answer[bc[i]] = nr; good[bc[i]] = false;

    int l = 2;
    for (int j = 0; j < nother; ++j)
      if (!binary_search(g[bc[i]].begin(), g[bc[i]].end(), bother[j])) {
         answer[bother[j]] = nr; good[bother[j]] = false;
         --l; if (l == 0) break;
      }

    printf("\n");
    --q; if (q == 0) return true;
  }

  return false;
}

int main()
{
  scanf("%d%d", &n, &m);

  for (int i = 0; i < m; ++i) {
    int a, b;
    scanf("%d%d", &a, &b);

    --a; --b;
    g[a].push_back(b);
    g[b].push_back(a);
  }

  memset(mark, 0, sizeof(mark));
  memset(good, 1, sizeof(good));

  for (int i = 0; i < n; ++i)
    if (!mark[i]) dfs(i, 0);

  if (n1%3 == 1) {
    if (!part1(bank1, bank2, n1) && !part2(bank2, bank1, n2)) { printf("NO\n"); return 0; }
  } else if (n1%3 == 2) {
    if (!part1(bank2, bank1, n2) && !part2(bank1, bank2, n1)) { printf("NO\n"); return 0; }
  }

  printf("YES\n");
  easy();

  for (int i = 0; i < n; ++i) printf("%d ", answer[i]);

  return 0;
}
