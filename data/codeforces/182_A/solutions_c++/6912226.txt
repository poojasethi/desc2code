#include <cstdio>
#include <algorithm>
#include <vector>
#include <cmath>
#include <cstdlib>
#include <queue>
#include <utility>
#define INFD 1000000000000.0
#define INFI 2000000000
using namespace std;
int a,b,ax,ay,bx,by,n;
vector<int> adjlist[1005];
int px1[1005],py1[1005],px2[1005],py2[1005];
int dist[1005];
bool visited[1005];
queue<int> q;
double ans = INFD;
double distpline(int px, int py, int x1, int y1, int x2, int y2) {
	if (x1==x2) {
		if (py>y2) return hypot(py-y2,px-x1);
		else if (py<y1) return hypot(y1-py,px-x1);
		else return abs(px-x1);
	} else {
		if (px>x2) return hypot(px-x2,py-y1);
		else if (px<x1) return hypot(x1-px,py-y1);
		else return abs(py-y1);
	}
}
double distlineline(int ax1,int ay1,int ax2,int ay2,int bx1,int by1,int bx2,int by2) {
	return min(min(min(distpline(ax1,ay1,bx1,by1,bx2,by2),distpline(ax2,ay2,bx1,by1,bx2,by2)),distpline(bx1,by1,ax1,ay1,ax2,ay2)),distpline(bx2,by2,ax1,ay1,ax2,ay2));
}
int main() {
	double d;
	scanf("%d%d%d%d%d%d%d",&a,&b,&ax,&ay,&bx,&by,&n);
	for (int i = 0; i < n; i++) {
		scanf("%d%d%d%d",&px1[i],&py1[i],&px2[i],&py2[i]);
		if (px1[i]==px2[i]) {
			int t1=max(py1[i],py2[i]);
			int t2=min(py1[i],py2[i]);
			py1[i] = t2;
			py2[i] = t1;
		} else {
			int t1=max(px1[i],px2[i]);
			int t2=min(px1[i],px2[i]);
			px1[i] = t2;
			px2[i] = t1;
		}
	}
	for (int i = 0; i < n+2; i++) dist[i]=INFI;
	for (int i = 0; i < n; i++) {
		for (int j = i+1; j < n; j++) {
			double d = distlineline(px1[i],py1[i],px2[i],py2[i],px1[j],py1[j],px2[j],py2[j]);
			if (d<=(double)a) {
			adjlist[i].push_back(j);
				adjlist[j].push_back(i);
			}
		}
	}
	for (int i = 0; i < n; i++) {
		double d = distpline(ax,ay,px1[i],py1[i],px2[i],py2[i]);
		if (d<=(double)a) {
			adjlist[i].push_back(n);
			adjlist[n].push_back(i);
		}
	}
	double t = hypot(ax-bx,ay-by);
	if (t<=(double)a) {
		printf("%lf\n", t);
		return 0;
	}
	dist[n] = 0;
	q.push(n);
	while(!q.empty()) {
		int v = q.front();
		q.pop();
		visited[v] = true;
		for(vector<int>::iterator it=adjlist[v].begin();it!=adjlist[v].end();++it) {
			if (!visited[*it]) {
				if (dist[*it] > dist[v]+1) {
					dist[*it]=dist[v]+1;
					q.push(*it);
				}
			}
		}
	}
	for (int i = 0; i < n; i++) {
		double d = distpline(bx,by,px1[i],py1[i],px2[i],py2[i]);
		if (d<=(double)a && dist[i]<INFI) {
			ans = min(ans,d+(double)(a+b)*(double)dist[i]);
		}
	}
	if (ans>=INFD-1.0) printf("-1\n");
	else printf("%lf\n", ans);
}