#include <iostream>
#include <cstdio>
#include <cmath>
#include <string.h>
using namespace std;

#define EPS 1e-8
#define INF 1e20

struct CPoint
{
	double x,y;
};

double dis(CPoint a, CPoint b)
{
	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}

double min(double a, double b)
{
	return a<b?a:b;
}

double cross(CPoint a, CPoint b, CPoint c)
{
	return (b.x-a.x)*(c.y-b.y)-(b.y-a.y)*(c.x-b.x);
}

double dot(CPoint a, CPoint b, CPoint c)
{
	return (b.x-a.x)*(c.x-b.x)+(b.y-a.y)*(c.y-b.y);
}

double ptoline(CPoint c, CPoint a, CPoint b)
{
	return fabs(cross(c,a,b))/dis(a,b);
}

double ptoseg(CPoint c, CPoint a, CPoint b)
{
	if (dot(c,a,b)<EPS && dot(c,b,a)<EPS ) return ptoline(c,a,b);
	else return min(dis(c,a),dis(c,b));
}

bool intersect(CPoint a, CPoint b, CPoint c, CPoint d)
{
	return ( cross(a,b,c)*cross(a,b,d)<0 &&  cross(c,a,b)*cross(d,a,b)<0 );
}

double min(double a, double b, double c, double d)
{
	double ans=INF;
	if (a<ans) ans=a;
	if (b<ans) ans=b;
	if (c<ans) ans=c;
	if (d<ans) ans=d;
	return ans;
}

double segtoseg(CPoint a, CPoint b, CPoint c, CPoint d)
{
	//if (intersect(a,b,c,d)) return 0;
	return min( ptoseg(a,c,d),ptoseg(b,c,d), ptoseg(c,a,b), ptoseg(d,a,b) ) ;
}


double a,b,map[1200][1200],d[1200],mn;
CPoint s,t,hz[10000],hy[10000];
int m,n,mni;
bool flag[10000];


int main()
{
	cin>>a>>b;
	cin>>s.x>>s.y>>t.x>>t.y;
	cin>>n;
	for (int i=0;i<n;i++) cin>>hz[i].x>>hz[i].y>>hy[i].x>>hy[i].y;
	for (int i=0;i<n;i++)
	{
		for (int j=0;j<i;j++)
			map[i][j]=map[j][i]=segtoseg(hz[i],hy[i],hz[j],hy[j]);
		map[i][i]=0;
	}
	for (int i=0;i<n;i++) map[n][i]=ptoseg(s,hz[i],hy[i]);
	for (int i=0;i<n;i++) map[i][n+1]=ptoseg(t,hz[i],hy[i]);
	map[n][n+1]=dis(s,t);
	memset(d,0x7f,sizeof(d));
	memset(flag,0,sizeof(flag));
	d[n]=0;
	while (1)
	{
		mn=INF;
		for (int i=0;i<n+2;i++)
			if ( flag[i]==false && d[i]<mn ) { mn=d[i]; mni=i; }
		if (mn==INF) break;
		flag[mni]=true;
		for (int i=0;i<n+1;i++)
			if ( flag[i]==false && map[mni][i]<=a && d[i]>d[mni]+a+b) d[i]=d[mni]+a+b;
		if ( flag[n+1]==false && map[mni][n+1]<=a && d[n+1]>d[mni]+map[mni][n+1]) d[n+1]=d[mni]+map[mni][n+1];
		if (flag[n+1]==true) break;
	}
	if (flag[n+1]==false) cout<<-1<<endl; else cout<<d[n+1]<<endl;
	//system("pause");
	return 0;
}