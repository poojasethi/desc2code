#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
const int N = 1005;
const int M = 1e9 + 7;

int n, g[N][N];
char s[N];
int zero[4][N<<1][N];
double lgrow[N][N], lgcol[N][N], lgup[N << 1][N], lgdown[N << 1][N];

int main() {
	scanf("%d", &n);
	for (int i = 0; i < n; ++i) {
		scanf("%s", s);
		for (int j = 0; j < n; ++j) {
			g[i][j] = s[j] - '0';
			zero[0][i][j] = (j ? zero[0][i][j-1] : 0) + (g[i][j] == 0);
			zero[1][i][j] = (i ? zero[1][i-1][j] : 0) + (g[i][j] == 0);
			zero[2][i+j][i] = (i ? zero[2][i+j][i-1] : 0) + (g[i][j] == 0);
			zero[3][i-j+n][i] = (i ? zero[3][i-j+n][i-1] : 0) + (g[i][j] == 0);
			double val = g[i][j] == 0 ? 0.0 : log(g[i][j]);
			lgrow[i][j] = (j ? lgrow[i][j-1] : 0.0) + val;
			lgcol[i][j] = (i ? lgcol[i-1][j] : 0.0) + val;
			lgup[i+j][i]= (i ? lgup[i+j][i-1] : 0.0) + val;
			lgdown[i-j+n][i] = (i ? lgdown[i-j+n][i-1] : 0.0) + val;
		}
	}
	// cout << prod(tree[2][4], 1, 3) << endl;
	// search maximum per node
	double lgmax = -1;
	int ansi=0, ansj=0, ansm=0, anst=0;
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			if (g[i][j] == 0) continue;
			int L = 0; // this only
			int nR = min(min(i, n-i-1), min(j, n-j-1));
			// cout << i << ' ' << j << ' ' << nR << endl;
			int R = nR;
			while (L < R) {
				int m = (L + R) / 2 + 1;
				// first cross
				int fcross = zero[0][i][j+m]-(j-m-1>=0 ? zero[0][i][j-m-1] : 0)
					+ zero[1][i+m][j] - (i-m-1>=0 ? zero[1][i-m-1][j] : 0);
				// int fcross = zero[0][i][j+m] - (j-m-1 >= 0 ? zero[0][i][j-m-1] : 0.0) + zero[1][i+m][j] - (i-m-1 >= 0 ? lgcol[i-m-1][j] : 0.0);
				// ll fcross = prod(tree[0][i], j-m, j+m) * prod(tree[1][j], i-m, i-1) % M * prod(tree[1][j], i+1, i+m) % M;
				if (fcross == 0) L = m;
				else R = m-1;
			}
			{
				int m = L;
				double f = lgrow[i][j+m] - lgrow[i][j] + (j >= 0 ? lgrow[i][j-1] : 0.0) - (j-m-1 >= 0 ? lgrow[i][j-m-1] : 0.0) + lgcol[i+m][j] - (i-m-1 >= 0 ? lgcol[i-m-1][j] : 0.0);
				if (f > lgmax) {
					lgmax = f;
					ansi = i;
					ansj = j;
					ansm = m;
					anst = 0;
				}
			}
			L = 0;
			R = nR;
			while (L < R) {
				int m = (L + R) / 2 + 1;
				// second cross
				int scross = zero[2][i+j][i+m] - (i-m-1>=0 ? zero[2][i+j][i-m-1] : 0)
					+ zero[3][i-j+n][i+m] - (i-m-1>=0 ? zero[3][i-j+n][i-m-1] : 0);
				// ll scross = prod(tree[2][i+j], j-m, j+m)
				//	* prod(tree[3][i-j+n], j-m, j-1) % M
				//	* prod(tree[3][i-j+n], j+1, j+m) % M;
				if (scross == 0) L = m;
				else R = m-1;
			}
			{
				int m = L;
				double f = lgup[i+j][i+m] - lgup[i+j][i]
					+ (i-1 >= 0 ? lgup[i+j][i-1] : 0.0) - (i-m-1 >= 0 ? lgup[i+j][i-m-1] : 0.0)
					+ lgdown[i-j+n][i+m] - (i-m-1 >= 0 ? lgdown[i-j+n][i-m-1] : 0.0);
				// f = lgup[i+j][j+m] - (j-m-1 >= 0 ? lgup[i+j][j-m-1] : 0.0);
				// cout << i << ' ' << j << ' ' << m << ' ' << scross << ' ' << f << ' ' << pow(2.71828, f) << endl;
				if (f > lgmax) {
					lgmax = f;
					ansi = i;
					ansj = j;
					ansm = m;
					anst = 1;
				}
			}
		}
	}
	// cout << ansi << ' ' << ansj << ' ' << ansm << ' ' << anst << endl;
	long long ans = g[ansi][ansj];
	if (anst == 0) {
		// row col
		for (int k = 1; k <= ansm; ++k) {
			ans = (ans * g[ansi-k][ansj] % M * g[ansi+k][ansj] % M);
			ans = (ans * g[ansi][ansj-k] % M * g[ansi][ansj+k] % M);
		}
	} else {
		// dia
		for (int k = 1; k <= ansm; ++k) {
			ans = (ans * g[ansi-k][ansj-k] % M);
			ans = (ans * g[ansi-k][ansj+k] % M);
			ans = (ans * g[ansi+k][ansj-k] % M);
			ans = (ans * g[ansi+k][ansj+k] % M);
		}
	}
	cout << ans << endl;
}

