#include <bits/stdc++.h>
#define inf 0x3f3f3f3f
#define Inf 0x3FFFFFFFFFFFFFFFLL
#define rep(i, n) for (int i = 0; i < (n); ++i)
#define Rep(i, n) for (int i = 1; i <= (n); ++i)
#define FOR(i, c) for(__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)
#define clr(x, a) memset(x, (a), sizeof x)
#define RD(x) scanf("%d", &x)
#define PB push_back
#define MP make_pair
using namespace std;
typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;
ll const mod = 1000000007LL;
int const N = 1010;
char s[N][N];
int a[N][N];
int c[4][8][N][N];
int const dir[8][2] = { 0, -1, -1, -1, -1, 0, -1, 1, 0, 1, 1, 1, 1, 0, 1, -1 };
ll ans, mc2, mc3; double mx;
double const lg2 = log(2.f);
double const lg3 = log(3.f);
void upd(ll c2, ll c3) {
	double t = lg2 * c2 + lg3 * c3;
	if (t > mx) {
		mx = t;
		mc2 = c2;
		mc3 = c3;
	}
}

int main() {
	int n; scanf("%d", &n);
	rep(i, n) scanf(" %s", s[i]);
	rep(i, n) rep(j, n) a[i][j] = s[i][j] - '0';
	bool nonZero = 0;
	rep(i, n) rep(j, n) nonZero |= (a[i][j] != 0);
	if (!nonZero) {
		puts("0");
		return 0;
	}
	
	Rep(g, 3) rep(k, 4) rep(i, n) rep(j, n) if (a[i][j] > 0) {
		int tx = i + dir[k][0], ty = j + dir[k][1];
		c[g][k][i][j] = (a[i][j] == g);
		if (tx >= 0 && tx < n && ty >= 0 && ty < n) {
			if (a[tx][ty] != 0) {
				c[g][k][i][j] += c[g][k][tx][ty];
			}
		}
	}
	Rep(g, 3) for (int k = 4; k < 8; ++k) 
		for (int i = n - 1; i >= 0; --i) for (int j = n - 1; j >= 0; --j) if (a[i][j] > 0) {
			int tx = i + dir[k][0], ty = j + dir[k][1];
			c[g][k][i][j] = (a[i][j] == g);
			if (tx >= 0 && tx < n && ty >= 0 && ty < n) {
				if (a[tx][ty] != 0) {
					c[g][k][i][j] += c[g][k][tx][ty];
				}
			}
		}

	ans = 0;
	rep(i, n) rep(j, n) if (a[i][j] > 0) {
		int sz = inf;
		for (int k = 0; k < 8; k += 2) {
			sz = min(sz, c[1][k][i][j] + c[2][k][i][j] + c[3][k][i][j]);
		}
		int cc[4]; rep(k, 4) cc[k] = 0;
		for (int k = 0; k < 8; k += 2) {
			Rep(l, 3) {
				cc[l] += c[l][k][i][j];
				if (i + sz * dir[k][0] >= 0 && i + sz * dir[k][0] < n &&
						j + sz * dir[k][1] >= 0 && j + sz * dir[k][1] < n) {
					cc[l] -= c[l][k][i + sz * dir[k][0]][j + sz * dir[k][1]];
				}
				cc[l] -= (a[i][j] == l);
			}
		}
		cc[a[i][j]]++;
		upd(cc[2], cc[3]);
		
		sz = inf;
		for (int k = 1; k < 8; k += 2) {
			sz = min(sz, c[1][k][i][j] + c[2][k][i][j] + c[3][k][i][j]);			
		}
		rep(k, 4) cc[k] = 0;
		for (int k = 1; k < 8; k += 2) {
			Rep(l, 3) {
				cc[l] += c[l][k][i][j];
				int tx = i + sz * dir[k][0];
				int ty = j + sz * dir[k][1];
				if (tx >= 0 && tx < n && ty >= 0 && ty < n) {
					cc[l] -= c[l][k][tx][ty];
				}
				cc[l] -= (a[i][j] == l);
			}
		}
		cc[a[i][j]]++;
		upd(cc[2], cc[3]);
	}	
	ll ret = 1;
	rep(i, mc2) ret = ret * 2 % mod;
	rep(i, mc3) ret = ret * 3 % mod;
	printf("%I64d\n", ret);
	return 0;
}


