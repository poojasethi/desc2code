//#pragma comment(linker, "/STACK:102400000,102400000") 
#pragma warning(disable:4996)
#include <fstream>
#include <iostream>
#include <functional>
#include <algorithm>
#include <cstring>
#include <vector>
#include <string>
#include <cstdio>
#include <cmath>
#include <queue>
#include <stack>
#include <deque>
#include <set>
#include <map>
using namespace std;
typedef long long ll;

#define LL_INF 0x3fffffffffffffff
#define INF 9999999
#define mem(a, b) memset(a, b, sizeof(a))
#define pper(i,n,m) for(int i = n;i >= m; i--)
#define repp(i, n, m) for (int i = n; i <= m; i++)
#define rep(i, n, m) for (int i = n; i < m; i++)
#define sa(n) scanf("%d", &(n))
#define mp make_pair
#define ff first
#define ss second
#define pb push_back

const int maxn = 1005;
const ll mod = 1e9 + 7;
const double PI = acos(-1.0);

int dx[8] = { 0,-1,-1,-1  ,1,1,0,1 };
int dy[8] = { -1,-1,0,1,  0,-1,1,1 };

int n;
char tmp[maxn];
int val[maxn][maxn];
double logv[maxn][maxn];
int len[8][maxn][maxn];
double dp[8][maxn][maxn];

void solve()
{
	int i, j, k;

	double lg2 = log(2.0);
	double lg3 = log(3.0);

	sa(n);
	repp(i, 1, n)
	{
		scanf("%s", tmp + 1);
		repp(j, 1, n)
		{
			val[i][j] = tmp[j] - '0';
			if (val[i][j] == 2)
			{
				logv[i][j] = lg2;
			}
			else if (val[i][j] == 3)
			{
				logv[i][j] = lg3;
			}
		}
	}
	mem(len, 0);
	mem(dp, 0);

	int dir;
	for (dir = 0; dir < 4; dir++)
	{
		for (i = 1; i <= n; i++)
		{
			for (j = 1; j <= n; j++)
			{
				if (val[i][j])
				{
					int nx = i + dx[dir];
					int ny = j + dy[dir];
					len[dir][i][j] = len[dir][nx][ny] + 1;
					dp[dir][i][j] = dp[dir][nx][ny] + logv[i][j];
				}
			}
		}
	}
	for (dir = 4; dir < 8; dir++)
	{
		for (i = n; i >= 1; i--)
		{
			for (j = n; j >= 1; j--)
			{
				if (val[i][j])
				{
					int nx = i + dx[dir];
					int ny = j + dy[dir];
					len[dir][i][j] = len[dir][nx][ny] + 1;
					dp[dir][i][j] = dp[dir][nx][ny] + logv[i][j];
				}
			}
		}
	}

	double res = -1;
	int resx = 0, resy = 0, reslen = 0, d = 0;
	for (i = 1; i <= n; i++)
	{
		for (j = 1; j <= n; j++)
		{
			if (val[i][j])
			{
				int tmp = n + 5;
				for (k = 0; k < 8; k += 2)
				{
					tmp = min(tmp, len[k][i][j]);
				}
				double ans = 0;
				for (k = 0; k < 8; k += 2)
				{
					int nx = i + (tmp)*dx[k];
					int ny = j + (tmp)*dy[k];
					ans += dp[k][i][j] - dp[k][nx][ny];
				}
				if (val[i][j] == 2)
				{
					ans -= 3 * lg2;
				}
				else if (val[i][j] == 3)
				{
					ans -= 3 * lg3;
				}
				if (ans > res)
				{
					res = ans;
					resx = i;
					resy = j;
					reslen = tmp;
					d = 0;
				}
				//减掉重复的本身
				tmp = n + 5;
				for (k = 1; k < 8; k += 2)
				{
					tmp = min(tmp, len[k][i][j]);
				}

				ans = 0;
				for (k = 1; k < 8; k += 2)
				{
					int nx = i + (tmp)*dx[k];
					int ny = j + (tmp)*dy[k];
					ans += dp[k][i][j] - dp[k][nx][ny];
				}
				if (val[i][j] == 2)
				{
					ans -= 3 * lg2;
				}
				else if (val[i][j] == 3)
				{
					ans -= 3 * lg3;
				}
				if (ans > res)
				{
					res = ans;
					resx = i;
					resy = j;
					reslen = tmp;
					d = 1;
				}
			}
		}
	}
	if (res < 0)
	{
		printf("0\n");
	}
	else
	{
		ll r = 1;
		for (k = d; k < 8; k += 2)
		{
			for (j = 2; j <= reslen; j++)
			{
				int nx = resx + (j - 1)*dx[k];
				int ny = resy + (j - 1)*dy[k];
				r *= val[nx][ny];
				r %= mod;
			}
		}
		r *= val[resx][resy];
		r %= mod;
		printf("%lld\n", r);
	}
}

int main()
{
#ifndef ONLINE_JUDGE
	freopen("i.txt", "r", stdin);
	freopen("o.txt", "w", stdout);
#endif
	solve();
	return 0;
}