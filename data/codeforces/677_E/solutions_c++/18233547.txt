#include <bits/stdc++.h>

#define FOR(i,a,b) for (int i=(a),_b=(b);i<=_b;i++)
#define DOW(i,a,b) for (int i=(a),_b=(b);i>=_b;i--)
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define N 1010

using namespace std;

typedef pair<int, int> PII;
typedef long long LL;
typedef unsigned long long ULL;

const int base = 1e9 + 7;

struct node{
	int x, y;
	node operator + (node t){return (node){x + t.x, y + t.y};}
	node operator - (node t){return (node){x - t.x, y - t.y};}	
	node operator * (int t){return (node){x * t, y * t};}
	bool operator >= (node t){
		if (x >= t.x && y >= t.y) return true;
		if (x <= t.x && y <= t.y) return false;
		if (x > t.x){
			int a = x - t.x, b = t.y - y;
			return log(2) * a > log(3) * b;
		}
		else{
			int a = y - t.y, b = t.x - x;
			return log(3) * a > log(2) * b;
		}
	}
	void print(){printf("%d %d\n",x,y);}
} sr[N][N], sc[N][N], sm[N][N], sa[N][N], a[N][N];

int l[N][N], r[N][N], u[N][N], d[N][N], lu[N][N], ld[N][N], ru[N][N], rd[N][N];
char s[N][N];
int n, m;

bool check(){
	FOR(i,1,n) FOR(j,1,n) 
			if (s[i][j] != '0') return true;
	return false;
}

void input(){
	scanf("%d",&n);
	FOR(i,1,n)
		scanf("%s",s[i]+1);
}

void init(){
	FOR(i,1,n){
		FOR(j,1,n){
			a[i][j].x = (s[i][j] == '2');
			a[i][j].y = (s[i][j] == '3');
			if (s[i][j] == '0') continue;
			l[i][j] = l[i][j-1] + 1;
			u[i][j] = u[i-1][j] + 1;
			lu[i][j] = lu[i-1][j-1] + 1;
			ru[i][j] = ru[i-1][j+1] + 1;
			sr[i][j] = sr[i][j-1] + a[i][j];
			sc[i][j] = sc[i-1][j] + a[i][j];
			sm[i][j] = sm[i-1][j-1] + a[i][j];
			sa[i][j] = sa[i-1][j+1] + a[i][j];
		}
		DOW(j,n,1)
			if (s[i][j] != '0') r[i][j] = r[i][j+1] + 1;
	}
	
	DOW(i,n,1) FOR(j,1,n) if (s[i][j] != '0'){
		d[i][j] = d[i+1][j] + 1;
		ld[i][j] = ld[i+1][j-1] + 1;
		rd[i][j] = rd[i+1][j+1] + 1;
	}
}

void solve(){
}

LL pw(int x, int k){
	LL res = 1;
	LL a = x; int b = k;
	for(; b; b>>=1, a = a * a % base)
		if (b & 1) res = res * a % base;
	return res;
}

void output(){
	node res = (node){0, 0};
	FOR(i,1,n) FOR(j,1,n) if (s[i][j] != '0'){
		int t; node tmp;
		t = min(min(l[i][j], r[i][j]), min(u[i][j], d[i][j]));
		tmp = sr[i][j+t-1] - sr[i][j-t] + sc[i+t-1][j] - sc[i-t][j] - a[i][j];
		if (tmp >= res) res = tmp;
		t = min(min(lu[i][j], ld[i][j]), min(ru[i][j], rd[i][j]));
		tmp = sm[i+t-1][j+t-1] - sm[i-t][j-t] + sa[i+t-1][j-t+1] - sa[i-t][j+t] - a[i][j];
		if (tmp >= res) res = tmp;
	}
	printf("%I64d",pw(2, res.x) * pw(3, res.y) % base);
}

int main(){
	//freopen("input.inp","r",stdin);
	//freopen("output.out","w",stdout);
	input();
	if (!check()){printf("0");return 0;}
	init();
	solve();
	output();
	return 0;
}