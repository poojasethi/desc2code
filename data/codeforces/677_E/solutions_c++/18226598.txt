#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>

using namespace std;

int n,ii,jj,mx,ans_i,ans_j,ans_type,ans_mx;
char s[1005][1005];
int cnt[1005][1005][8];//0~7分别代表左，左上，正上，右上；右，右下，正下，左下；cnt[i][j][k]表示点(i,j)开始在k方向上能走多远
double sum[1005][1005][4];//0~4分别代表左，左上，正上，右上；sum[i][j][k]表示点(i,j)开始在k方向走到头时，每一点对应的log的和
double lg[5],tmp,ans;
long long res;

const int dr[8]={0,-1,-1,-1,0,1,1,1};
const int dc[8]={-1,-1,0,1,1,1,0,-1};
const long long MOD=1e9+7;

int main() {
    lg[0]=lg[1]=0;
    lg[2]=log(2.0);
    lg[3]=log(3.0);
    while(1==scanf("%d",&n)) {
        memset(cnt,0,sizeof(cnt));
        memset(sum,0,sizeof(sum));
        for(int i=1;i<=n;++i) {
            scanf("%s",&s[i][1]);
        }
        for(int i=1;i<=n;++i) {
            for(int j=1;j<=n;++j) {
                if(s[i][j]!='0') {
                    for(int k=0;k<4;++k) {//0~3的方向从左上角开始更新
                        cnt[i][j][k]=cnt[i+dr[k]][j+dc[k]][k]+1;
                        sum[i][j][k]=sum[i+dr[k]][j+dc[k]][k]+lg[s[i][j]-'0'];
                    }
                }
                ii=n-i+1;
                jj=n-j+1;
                if(s[ii][jj]!='0') {
                    for(int k=4;k<8;++k) {//4~7的方向从右下角开始更新
                        cnt[ii][jj][k]=cnt[ii+dr[k]][jj+dc[k]][k]+1;
                    }
                }
            }
        }

        ans=ans_mx=ans_type=0;
        ans_i=ans_j=1;
        for(int i=1;i<=n;++i) {
            for(int j=1;j<=n;++j) {
                if(s[i][j]!='0') {
                    mx=min(min(cnt[i][j][0],cnt[i][j][2]),min(cnt[i][j][4],cnt[i][j][6]));//正着十字能延伸的最大
                    tmp=sum[i][j+mx-1][0]-sum[i][j-mx][0]+sum[i+mx-1][j][2]-sum[i-mx][j][2]-lg[s[i][j]-'0'];
                    if(ans<tmp) {
                        ans=tmp;
                        ans_i=i;
                        ans_j=j;
                        ans_type=0;
                        ans_mx=mx;
                    }
                    mx=min(min(cnt[i][j][1],cnt[i][j][3]),min(cnt[i][j][5],cnt[i][j][7]));//斜着十字能延伸的最大
                    tmp=sum[i+mx-1][j+mx-1][1]-sum[i-mx][j-mx][1]+sum[i+mx-1][j-mx+1][3]-sum[i-mx][j+mx][3]-lg[s[i][j]-'0'];
                    if(ans<tmp) {
                        ans=tmp;
                        ans_i=i;
                        ans_j=j;
                        ans_type=1;
                        ans_mx=mx;
                    }
                }
            }
        }

        res=s[ans_i][ans_j]-'0';
        for(int k=0;k<=6;k+=2) {
            for(int l=1;l<ans_mx;++l) {
                res=(res*(s[ans_i+l*dr[ans_type+k]][ans_j+l*dc[ans_type+k]]-'0'))%MOD;
            }
        }
        printf("%I64d\n",res);
    }
    return 0;
}
