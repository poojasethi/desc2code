#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
const int N=1005,Mod=1e9+7;
int n;
char s[N][N];
int up[N][N],dn[N][N],lt[N][N],rt[N][N];
int lp[N][N],rp[N][N],ln[N][N],rn[N][N];
ll qpow(ll a,int b){
	ll c=1;
	while(b){
		if(b&1) c=c*a%Mod;
		if(b>>=1) a=a*a%Mod;
	}
	return c;
}
const double dt=1.584962500721156;
struct Data{
	int a[4];
	void clear(){memset(a,0,sizeof a);}
	Data operator + (const Data &rhs) const {
		Data c;
		c.clear();
		for(int i=1;i<4;i++) c.a[i]=a[i]+rhs.a[i];
		return c;
	}
	bool operator < (const Data &rhs) const {
		if(a[0]) return 1;
		if(rhs.a[0]) return 0;
		if(a[2]<rhs.a[2]){
			if(a[3]<=rhs.a[3]) return 1;
			return (a[3]-rhs.a[3])*dt<rhs.a[2]-a[2];
		}
		else if(a[2]==rhs.a[2]) return a[3]<rhs.a[3];
		if(rhs.a[3]<a[3]) return 0;
		return a[2]-rhs.a[2]<(rhs.a[3]-a[3])*dt;
	}
};
struct SegT{
	Data p[N<<2];int n;
	void B(int t,int l,int r,int *b){
		if(l==r){
			for(int i=0;i<4;i++){
				if(b[l]==i) p[t].a[i]=1;
				else p[t].a[i]=0;
			}
			return;
		}
		int mid=(l+r)>>1;
		B(t<<1,l,mid,b);B(t<<1|1,mid+1,r,b);
		p[t]=p[t<<1]+p[t<<1|1];
	}
	Data Q(int t,int l,int r,int ql,int qr){
		if(ql<=l && r<=qr) return p[t];
		int mid=(l+r)>>1;
		if(qr<=mid) return Q(t<<1,l,mid,ql,qr);
		if(mid<ql) return Q(t<<1|1,mid+1,r,ql,qr);
		return Q(t<<1,l,mid,ql,qr)+Q(t<<1|1,mid+1,r,ql,qr);
	}
	void Build(int n,int *a){this->n=n;B(1,1,n,a);}
	Data Query(int l,int r){return Q(1,1,n,l,r);}
}R[N],C[N],D[N<<1][2];
void Init(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%s",s[i]+1);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(s[i][j]=='0') up[i][j]=lt[i][j]=lp[i][j]=0;
			else{
				up[i][j]=up[i-1][j]+1;
				lt[i][j]=lt[i][j-1]+1;
				lp[i][j]=lp[i-1][j-1]+1;
			}
		}
		for(int j=n;j;j--){
			if(s[i][j]=='0') rt[i][j]=rp[i][j]=0;
			else{
				rt[i][j]=rt[i][j+1]+1;
				rp[i][j]=rp[i-1][j+1]+1;
			}
		}
	}
	for(int i=n;i;i--){
		for(int j=1;j<=n;j++){
			if(s[i][j]=='0') dn[i][j]=ln[i][j]=0;
			else{
				dn[i][j]=dn[i+1][j]+1;
				ln[i][j]=ln[i+1][j-1]+1;
			}
		}
		for(int j=n;j;j--){
			if(s[i][j]=='0') rn[i][j]=0;
			else rn[i][j]=rn[i+1][j+1]+1;
		}
	}
	static int c[N];
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++) c[j]=s[i][j]-'0';
		R[i].Build(n,c);
	}
	for(int j=1;j<=n;j++){
		for(int i=1;i<=n;i++) c[i]=s[i][j]-'0';
		C[j].Build(n,c);
	}
	int m=(n<<1)-1;
	for(int i=1,k;i<=m;i++){
		k=n-abs(n-i);
		for(int j=1,x=i<n?1:i-n+1,y=x+n-i;j<=k;j++) c[j]=s[x++][y++]-'0';
		D[i][0].Build(k,c);
		for(int j=1,x=i<n?1:i-n+1,y=i+1-x;j<=k;j++) c[j]=s[x++][y--]-'0';
		D[i][1].Build(k,c);
	}
}
int min(int a,int b,int c,int d){return min(min(a,b),min(c,d));}
int main(){
	Init();
	Data mx;
	mx.clear();
	mx.a[0]=1;
	for(int i=1,k;i<=n;i++){
		for(int j=1;j<=n;j++){
			static Data t;
			k=min(up[i][j],dn[i][j],lt[i][j],rt[i][j]);
			if(!k) continue;
			t=R[i].Query(j-k+1,j+k-1)+C[j].Query(i-k+1,i+k-1);
			t.a[s[i][j]-'0']--;
			mx=max(mx,t);
			k=min(lp[i][j],rp[i][j],ln[i][j],rn[i][j]);
			int l0,r0,l1,r1;
			if(i<j) l0=i-k+1,r0=i+k-1;
			else l0=j-k+1,r0=j+k-1;
			if(i+j-1<n) l1=i-k+1,r1=i+k-1;
			else l1=(n-j+1)-k+1,r1=(n-j+1)+k-1;
			t=D[i-j+n][0].Query(l0,r0)+D[i+j-1][1].Query(l1,r1);
			t.a[s[i][j]-'0']--;
			mx=max(mx,t);
		}
	}
	ll ans=1;
	for(int i=0;i<4;i++) (ans*=qpow(i,mx.a[i]))%=Mod;
	printf("%I64d\n",ans);
	return 0;
}
	         		    		   						   	