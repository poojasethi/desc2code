#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <string>
#include <sstream>
#include <cmath>
#include <stdio.h>
#include <iomanip>
#include <queue>
#include <map>
#include <fstream>
#include <cstring>

//#define cin fin
//#define cout fout

#define pb push_back
#define mp make_pair
#define f1 first
#define f2 second
#define X first
#define Y second
#define Size(n) ((int)(n).size())
#define Foreach(i, x) for (__typeof(x.begin()) i = x.begin(); i != x.end(); i++)

using namespace std;

typedef long long LL;
typedef pair <int, int> PII; 

const int maxN = 40 + 5;

//vector <PII> ax;
//vector <PII> ay;

int dx[] = {1, 0, -1, 0};
int dy[] = {0, 1, 0, -1};

int w[maxN][maxN];
bool mark[maxN][maxN][maxN];
vector <pair <PII, int> > path;
int n, b;

bool solve(int x, int y, int dir)
{
	mark[x][y][dir] = 1;
	path.pb(mp(mp(x, y), dir));
	x += dx[dir]; y += dy[dir];
	if (w[x][y] != dir && w[x][y] != -1)	
		dir = w[x][y];
	if (mark[x][y][dir])
	{
		path.pb(mp(mp(x, y), dir));
		return true;
	}
	if (x > b || x < 0 || y > b || y < 0)
		return false;
	return solve(x, y, dir);
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin >> n >> b;
	for (int i = 0; i <= b; i++)
		for (int j = 0; j <= b; j++)
			w[i][j] = -1;
	for (int i = 0; i < n; i++)
	{
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;	
		int dir = 0;
		if (x1 == x2)
		{
			if (y2 > y1)
				dir = 1;
			else
				dir = 3;
			for (int i = min(y1, y2); i <= max(y1, y2); i++)
				w[x1][i] = dir;
		}
		else
		{
			if (x2 > x1)
				dir = 0;
			else
				dir = 2;
			for (int i = min(x1, x2); i <= max(x1, x2); i++)
				w[i][y1] = dir;
		}
	}
	int q;
	cin >> q;
	while (q--)
	{
		memset(mark, 0, sizeof(mark));

		int x, y; char c; LL time;
		cin >> x >> y >> c >> time;
		int dir = 0;
		if (c == 'U')
			dir = 1;
		else if (c == 'L')
			dir = 2;
		else if (c == 'D')
			dir = 3;
		if (w[x][y] != dir && w[x][y] != -1)	
			dir = w[x][y];
//		cerr << dir << endl;
		int ind = 0;
		if (solve(x, y, dir))
		{
			LL i;
			for (i = 0; i < Size(path) - 1; i++)
				if (path[i] == path.back())
					break;
			if (time <= i)
				ind = time;
			else
				ind = i + (time - i) % (Size(path) - i - 1);
		}
		else
			ind = min((LL)Size(path) - 1, time);
//		cerr << path[1].f1.X << " " << path[1].f1.Y << endl;
		cout << path[ind].f1.X << " " << path[ind].f1.Y << endl;
		path.clear();

	}
	return 0;
}

