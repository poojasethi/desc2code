m , k = map (int , raw_input ().split ())
dp = [[-1 for col in range (65)] for row in range (65)]
bit = [0] * 65
def dfs (l , c , lim) :
    if l < 0 : return 1 if c == k else 0
    if lim == 0 and dp[l][c] != -1 : return dp[l][c]
    ret , up = 0 , (bit[l] + 1) if lim else 2
    for i in range (up) : ret += dfs (l - 1 , c + i , lim and i == (up - 1))
    if lim == 0 : dp[l][c] = ret
    return ret
def gao (m) :
    l = 0
    while m > 0 : bit[l] , m , l = m % 2 , m / 2 , l + 1
    return dfs (l - 1 , 0 , True)
low , high = 1 , int (1e18 + 5)
while low <= high :
    mid = (low + high) >> 1
    t = gao (mid * 2) - gao (mid)
    if t >= m : ans , high = mid , mid - 1
    else : low = mid + 1
print ans