
dp = [[[[-1 for x in xrange(2)] for x in xrange(2)] for x in xrange(66)] for x in xrange(66)]

def dfs(pos,bit,up,down,L,R):
    # print pos, bit, up, down

    if pos == -1 and bit == 0:
        return 1;
    if pos == -1:
        return 0;
    if dp[pos][bit][up][down] != -1:
        return dp[pos][bit][up][down]
    l = 0
    r = 1

    if down and (L & (1 << pos)) > 0 : 
        l = 1
    if up and (R & (1 << pos)) == 0:
        r = 0
    ss = 0
    for i in range(l,r+1):
        ss += dfs(pos-1,bit-i,up and (i == r),down and (i == l),L,R)
    dp[pos][bit][up][down] = ss
    return ss

def check(n,k):
    L = n + 1
    R = 2 * n
    # print L,R
    
    return dfs(63,k,1,1,L,R)


data = map(int, raw_input().split())

M = data[0]
k = data[1]

l = 1
r = 1000000000000000000

# print M
# print check(7,3)
# print check(4,2)


while l < r - 1:
    dp = [[[[-1 for x in xrange(2)] for x in xrange(2)] for x in xrange(66)] for x in xrange(66)]
    m = (l + r) / 2
    if check(m,k) < M:
        l = m
    else:
        r = m
        
dp = [[[[-1 for x in xrange(2)] for x in xrange(2)] for x in xrange(66)] for x in xrange(66)]
# print l,r

if check(l,k) == M:
    print l
else:
    print r
