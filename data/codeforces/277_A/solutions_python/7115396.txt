class DisjointSets:
	def __init__(self, n, relation=None, presets=None):
		self.data = [-1] * n
		self.used = [False] * n
		if relation is not None:
			for i,j in relation:
				self.union(i,j)
		elif presets is not None:
			for s in presets:
				el = s.pop() # works for both list and set
				self.used[el] = True
				for el2 in s:
					self.union(el,el2)
	def union(self, a, b):
		self.used[a], self.used[b] = True, True
		a = self.root(a)
		b = self.root(b)
		if a == b:
			return None
		a,b = self.data[a] <= self.data[b] and (a,b) or (b,a)
		if self.data[a] == self.data[b]:
			self.data[a] -= 1
		self.data[b] = a
	def root(self, x):
		path = [x]
		while self.data[x] >= 0:
			x = self.data[x]
			path.append(x)
		for n in path[:-1]:
			self.data[n] = x
		return x
	def nsets(self):
		return sum(1 for i,x in enumerate(self.data) if x<0 and self.used[i])

n,k = [int(c) for c in raw_input().split()]
r = [[int(c) for c in raw_input().split()] for i in xrange(n)]
ds = DisjointSets(k+1,presets=[R[1:] for R in r if R[0]])
print sum(1 for R in r if R[0]==0) + max(ds.nsets() - 1,0)