#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
#include<algorithm>
using namespace std;
typedef long long ll;
#define rep(i,n) for (int i=0;i<n;++i)
#define mk make_pair
const int N=100005;
int a[N],b[N],c[N],p[N],q[N],ans[N],n,m,s;
deque<int> Q; priority_queue<pair<int,int> > H;
bool cmpa(const int i,const int j){return a[i]>a[j];}
bool cmpb(const int i,const int j){return b[i]>b[j];}
bool work(int Lim)
{
	int j=0,sum=s; Q.clear(); while (!H.empty()) H.pop();
	rep(i,m){
		while (j<n && b[q[j]]>=a[p[i]]) H.push(mk(-c[q[j]],q[j])),++j;
		if (H.empty() && Q.empty()) return 0;
		if (Q.empty()){
			int x=H.top().second; sum+=H.top().first; H.pop();
			rep(k,Lim) Q.push_back(x);
			if (sum<0) return 0;
		}
		ans[p[i]]=Q.front(),Q.pop_front();
	}
	return 1;
}
int main()
{
	scanf("%d%d%d",&n,&m,&s);
	rep(i,m) scanf("%d",a+i),p[i]=i; sort(p,p+m,cmpa);
	rep(i,n) scanf("%d",b+i),q[i]=i; sort(q,q+n,cmpb);
	rep(i,n) scanf("%d",c+i);
	int l=1,r=m,mid; if (!work(r)) return puts("NO"),0;
	while (l<r) mid=l+r>>1,work(mid)?r=mid:l=mid+1;
	work(l),puts("YES");
	rep(i,m) printf("%d ",ans[i]+1);
	return 0;
}
