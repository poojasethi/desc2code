//加了个启发式才过啊，不然TLE.... 
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<stdio.h>
#include<algorithm>
#include<map>
#include<cmath>
#include<vector>
#include<set>
using namespace std;
struct edge
{
    int id1,id2,w;
};
edge e[55];
int adj[55][55];
int deg[55];
const int s_mod=10007;
long long big_mod=(long long)10000007*(long long)1000007;
struct has
{
   long long key;
   vector<int>w;
};
has hs[s_mod][107],now,nw;
int num[s_mod],fac[110000];
int tn,n,m,ans,mod=1000000007;
int rev[110000];
bool lnk[55];
has find(long long state)
{
     int i,j,s,p,q,la;
     la=(int)(state%s_mod);
     for(i=0;i<num[la];i++)
     {
        if(hs[la][i].key==state)
            return hs[la][i];
     }
}
void dfs(int id,long long state,bool vis[],int list[],int &cnt_list)
{
     int i,j,s,p,q,ip;
     vis[id]=true;
     list[cnt_list++]=id;
     for(i=0;i<deg[id];i++)
     {
         ip=adj[id][i];
         if(!vis[ip]&&(state&(1LL<<ip)))
            dfs(ip,state,vis,list,cnt_list);
     }
}
void merge(has &gift,has now)
{
     int i,j,s,p,q,siz=gift.w.size();
     for(i=siz+(int)(now.w.size())-2;i>=siz;i--)
         gift.w.push_back(0);
     for(i=(int)(gift.w.size())-1;i>=0;i--)
     {
         if(gift.w[i]==0)
            continue;
         for(j=(int)(now.w.size())-1;j>=0;j--)
         {
             if(now.w[j]==0)
             {
                 if(j==0)
                    gift.w[i]=0;
                 continue;
             }
             if(j==0)
                 gift.w[i]=(int)((long long)gift.w[i]*(long long)now.w[j]%mod);
             else
             {
                 gift.w[i+j]+=(int)((long long)gift.w[i]*(long long)now.w[j]%mod);
                 gift.w[i+j]%=mod;
             }
         }
     }
}
void comb(has &gift,has now)
{
     int i,j,s,p,q;
     for(i=0;i<now.w.size();i++)
     {
        if(i<gift.w.size())
          gift.w[i]=(gift.w[i]+now.w[i])%mod;
        else
            gift.w.push_back(now.w[i]);
     }
}
void solve(long long state)
{
     int i,j,s,p,q,id,la,ps,id1,id2;
     has nw,now;
     bool need;
     long long  nstate;
     la=(int)(state%s_mod);
     for(i=0;i<num[la];i++)
     {
         if(hs[la][i].key==state)
             return;
     }
     hs[la][num[la]].w.clear();
     hs[la][num[la]].w.push_back(1);
     hs[la][num[la]].key=state;
     nw=hs[la][num[la]];
     ps=num[la];
     num[la]++;
     bool vis[55];
     int list[51],cnt_list;
     for(i=0;i<m;i++)
        vis[i]=false;
     need=false;
     for(i=0;i<m;i++)
     {
        if(state&(1LL<<i))
        {
            if(!vis[i])
            {
               cnt_list=0;
               dfs(i,state,vis,list,cnt_list);
               nstate=0;
               for(j=0;j<cnt_list;j++)
                  nstate|=((long long)1<<(long long)list[j]);
               if(nstate!=state)
               { 
                   solve(nstate);
                   now=find(nstate);
                   merge(hs[la][ps],now);
               }
               else
               {
                   need=true;
                   break;
               }
            }
        }
     }
     if(need)
     {
         int in=1000000000,ip,nc;
         for(i=0;i<cnt_list;i++)
         {
             ip=list[i];
             id1=e[ip].id1;
             id2=e[ip].id2;
             nc=0;
             for(j=0;j<m;j++)
             {
                if(state&(1LL<<j))
                {
                    if(e[j].id1==e[ip].id1)
                       nc++;
                    else if(e[j].id2==e[ip].id2)
                       nc++;
                }
             }
             if(in>nc)
             {
                 in=nc;
                 id=ip;
             }
         }
         nstate=state^(1LL<<id);
         solve(nstate);
         now=find(nstate);
         merge(hs[la][ps],now);
         for(i=0;i<m;i++)
         {
             if(nstate&(1LL<<i))
             {
                 if(e[i].id1==e[id].id1||e[i].id2==e[id].id2)
                    nstate^=(1LL<<i); 
             }
         }
         solve(nstate);
         now=find(nstate);
         merge(nw,now);
         now.w.clear();
         now.w.push_back(0);
         now.w.push_back(e[id].w-1);
         if(now.w[1]<0)
            now.w[1]+=mod;
         merge(nw,now);
         comb(hs[la][ps],nw);
     }
}
int main()
{
    int u,v,w,i,j,s,p,q;
    long long ans;
    has now;
    scanf("%d%d",&n,&m);
    memset(deg,0,sizeof(deg));
    fac[0]=1;
    for(i=1;i<=n;i++)
       fac[i]=(int)((long long)fac[i-1]*(long long)i%mod);
    for(i=0;i<m;i++)
    {
       scanf("%d%d%d",&u,&v,&w);
       u--;
       v--;
       e[i].id1=u;
       e[i].id2=v;
       e[i].w=w;
    }
    memset(deg,0,sizeof(deg));
    for(i=0;i<m;i++)
       for(j=0;j<m;j++)
       {
          if(j==i)
             continue;
          if(e[i].id1==e[j].id1||e[i].id2==e[j].id1||e[i].id1==e[j].id2||e[i].id2==e[j].id2)
             adj[i][deg[i]++]=j;
       }
    memset(num,0,sizeof(num));
    memset(lnk,false,sizeof(lnk));
    solve((1LL<<m)-1);
    now=find((1LL<<m)-1);
    ans=0;
    for(i=0;i<now.w.size();i++)
    {
        ans+=(int)((long long)now.w[i]*(long long)fac[n-i]%mod);
        ans%=mod;
    }
    printf("%d\n",ans);
   // system("pause");
    return 0;
}
	 			    		  		 						 	 						