#include<cstdio>
#include<cstring>
#include<algorithm>
#define INF 1e9
using namespace std;
const int maxn=201;
int read()
{
	int x=0,f=1;
	char ch=getchar();
	while (ch<'0'||ch>'9')
	{
		if (ch=='-')
			f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}
int n,m,num,cnt;
int a[maxn][maxn],b[maxn][maxn],S[maxn],T[maxn];
int ans[maxn],dp[maxn],vis[maxn],p[maxn][maxn];
int dfs(int u,int v)
{
	if (vis[u]==cnt)
		return dp[u];
	vis[u]=cnt;
	int Ans=-1;
	for (int i=1;i<=n;i++)
		if (a[u][i]==1&&a[u][i]+a[i][v]==a[u][v])
			Ans=max(Ans,dfs(i,v));
	if (Ans<0)
		Ans=INF;
	dp[u]=min(ans[u]+1,Ans);//取ans[] 
	return dp[u];
}
int main()
{
	int u,v;
	n=read(),m=read(),S[0]=read(),T[0]=read();
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			if (i!=j)
				a[i][j]=INF;
	for (int i=1;i<=m;i++)
	{
		u=read(),v=read();
		a[u][v]=1;
	}
	for (int k=1;k<=n;k++)//Floyd 
		for (int i=1;i<=n;i++)
			for (int j=1;j<=n;j++)
				a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
	num=read();
	for (int i=1;i<=num;i++)//找有向图每条公交线路最短路“割点” 
	{
		S[i]=read(),T[i]=read();
		for (int j=1;j<=n;j++)
			if (a[S[i]][j]<INF&&a[S[i]][j]+a[j][T[i]]==a[S[i]][T[i]])//S[i]与j有路径即可 
				b[i][a[S[i]][j]]++;
		for (int j=1;j<=n;j++)
			if (a[S[i]][j]<INF&&a[S[i]][j]+a[j][T[i]]==a[S[i]][T[i]]&&b[i][a[S[i]][j]]==1)
				p[i][j]=1;
	}
	for (int i=1;i<=n;i++)
		ans[i]=INF;
	ans[T[0]]=0;
	while (1)
	{
		bool find=0;//bool进来，否则循环后不会更新 
		for (int i=1;i<=num;i++)
			for (int j=1;j<=n;j++)
				if (p[i][j])
				{
					cnt++;
					int tmp=dfs(j,T[i]);
					if (tmp<ans[j])
					{
						ans[j]=tmp;
						find=1;
					}
				}
		if (!find)
			break;
	}
	if (ans[S[0]]<INF)//答案在S[0] 
		printf("%d\n",ans[S[0]]);
	else
		printf("-1\n");
	return 0;
}
      