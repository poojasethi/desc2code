#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#define M 100010

using namespace std;

struct Edge {
	int x, y, id;
};

struct UnionFindSet {
	int father[1001];
	void init(int n) {
		for(int i = 1; i <= n; ++i) {
			father[i] = i;
		}
	}
	int find(int x) {
		return x == father[x]? x: father[x] = find(father[x]);
	}
	bool unionSet(int x, int y) {
		int rx = find(x), ry = find(y);
		if(rx != ry) {
			father[ry] = rx;
			return true;
		} else {
			return false;
		}
	}
}Sufs, Mufs;

int main()
{
	int n, m;
	while(cin >> n >> m) {
		vector <Edge> Sedge, Medge;
		Edge edge;
		char type[2];
		for(int i = 0; i < m; ++i) {
			cin >> edge.x >> edge.y >> type;
			edge.id = i + 1;
			if (type[0] == 'S') {
				Sedge.push_back(edge);
			} else {
				Medge.push_back(edge);
			}
		}
		if(n % 2 == 0) {
			cout << "-1" << endl;
			continue;
		}
		vector <int> ans;
		Sufs.init(n), Mufs.init(n);
		for(int i = 0; i < Sedge.size(); ++i) {
			Sufs.unionSet(Sedge[i].x, Sedge[i].y);
		}
		for(int i = 0; i < Medge.size(); ++i) {
			if(Sufs.unionSet(Medge[i].x, Medge[i].y)) {
				Mufs.unionSet(Medge[i].x, Medge[i].y);
				ans.push_back(Medge[i].id);
			}
		}
		for(int i = 0; i < Medge.size() && ans.size() < (n - 1) / 2; ++i) {
			if(Mufs.unionSet(Medge[i].x, Medge[i].y)) {
				ans.push_back(Medge[i].id);
			}
		}
		if(ans.size() != (n - 1) / 2) {
			puts("-1");
			continue;
		}
		for(int i = 0; i < Sedge.size(); ++i) {
			if(Mufs.unionSet(Sedge[i].x, Sedge[i].y)) {
				ans.push_back(Sedge[i].id);
			}
		}
		if(ans.size() == n - 1) {
			cout << ans.size() << endl;
			for(int i = 0; i < ans.size(); ++i) {
				cout << ans[i] << ' ';
			}
			cout << endl;
		} else {
			cout << "-1" << endl;
		}
	}
	return 0;
}
