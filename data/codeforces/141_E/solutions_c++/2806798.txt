#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<utility>
#include<queue>
#define REP(x,y,z) for(int x=y;x<=z;x++)
#define FORD(x,y,z) for(int x=y;x>=z;x--)
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define M 1005
using namespace std;

struct edge{int s,t,id;}read;
int father[M],ans[M*100],n,m,pos,s[M*100],t[M*100];
char tmp[50];
vector<edge> in[2];
inline int find(int x){return father[x]==x?x:father[x]=find(father[x]);}
inline void uni(int x,int y){father[find(x)]=find(y);}

bool work()
{
	if(!(n&1))return false;
	
	REP(i,0,(int)in[0].size()-1)uni(in[0][i].s,in[0][i].t);
	REP(i,0,(int)in[1].size()-1)
	{
		if(pos>=n/2)break;
		if(find(in[1][i].s) != find(in[1][i].t))
		{
			uni(in[1][i].s,in[1][i].t);
			ans[pos++]=in[1][i].id;
		}
	}
	
	REP(i,1,n)father[i]=i;
	REP(i,0,pos-1)uni(s[ans[i]],t[ans[i]]);
	REP(i,0,(int)in[1].size()-1)
	{
		if(pos>=n/2)break;
		if(find(in[1][i].s) != find(in[1][i].t))
		{
			uni(in[1][i].s,in[1][i].t);
			ans[pos++]=in[1][i].id;
		}
	}
	
	if(pos!=n/2)return false;
	
	REP(i,0,(int)in[0].size()-1)
		if(find(in[0][i].s) != find(in[0][i].t))
		{
			uni(in[0][i].s,in[0][i].t);
			ans[pos++]=in[0][i].id;
		}
	
	if(pos!=n-1)return false;
	return true;
}
int main()
{
	while(~scanf("%d %d",&n,&m))
	{
		pos=0;
		REP(i,1,n)father[i]=i;
		REP(i,1,m)
		{
			scanf("%d %d",&s[i],&t[i]);
			scanf("%s",tmp);
			read.s=s[i];
			read.t=t[i];
			read.id=i;
			if(tmp[0]=='S')in[0].PB(read);
			else in[1].PB(read);
		}
		
		if(work())
		{
			printf("%d\n",pos);
			REP(i,0,pos-1)
			{
				if(i)putchar(' ');
				printf("%d",ans[i]);
			}
			puts("");
		}
		else puts("-1");
	}
	return 0;
}
