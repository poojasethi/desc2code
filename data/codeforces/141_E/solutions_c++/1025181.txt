/*
	比赛看错题了...
	其实就是求出第一个人必须清理的有那些...
	然后再随便清理一些...
	剩下交给第二个人...
	正确性还是很显然的...反证一下就好了...
*/
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
using namespace std;
#define rpt(i,l,r) for(register int i=(l);i<=(r);++i)
#define scan(p,x) for(typeof x p=x;p;p=p->l)
#define iter(p,x) for(typeof x.begin() p=x.begin();p!=x.end();++p)
const int maxn=1100,maxm=110000;
int n,m,m1,m2;

struct Tedge{
	int a,b,w;
	inline void build(int a1,int a2,int a3){a=a1,b=a2,w=a3;}
}E1[maxm],E2[maxm];

struct Tfind{
	int f[maxn];
	inline void build(int n){rpt(i,0,n)f[i]=i;}
	inline int find(int x){return x!=f[x]?f[x]=find(f[x]):x;}
	inline void insert(int x,int y){f[find(x)]=find(y);}
}fnd;

namespace Ninit{
	void init(){
		int a1,a2;char a3[2];cin>>n>>m;
		rpt(i,0,m-1){
			scanf("%d%d%s",&a1,&a2,a3);--a1,--a2;
			*a3=='S'?E1[m1++].build(a1,a2,i+1):E2[m2++].build(a1,a2,i+1);
		}
	}
}

namespace Nsolve{
	int Ans,ans[maxm];
	bool use[maxm];
	void solve(){
		if(~n&1){cout<<"-1"<<endl;return;}
		fnd.build(n);
		for(int i=0;i<m2;++i)fnd.insert(E2[i].a,E2[i].b);
		for(int i=0;i<m1;++i)
		if(fnd.find(E1[i].a)!=fnd.find(E1[i].b)){
			fnd.insert(E1[i].a,E1[i].b);
			ans[Ans++]=E1[i].w,use[i]=true;
		}
		fnd.build(n);
		for(int i=0;i<m1;++i)if(use[i])fnd.insert(E1[i].a,E1[i].b);
		for(int i=0;Ans<(n-1)/2 && i<m1;++i)
		if(fnd.find(E1[i].a)!=fnd.find(E1[i].b)){
			fnd.insert(E1[i].a,E1[i].b);
			ans[Ans++]=E1[i].w;
		}
		if(Ans!=(n-1)/2){cout<<"-1"<<endl;return;}
		for(int i=0;i<m2;++i)
		if(fnd.find(E2[i].a)!=fnd.find(E2[i].b)){
			fnd.insert(E2[i].a,E2[i].b);
			ans[Ans++]=E2[i].w;
		}
		if(Ans!=n-1){cout<<"-1"<<endl;return;}
		cout<<Ans<<endl;
		rpt(i,0,Ans-1)printf("%d ",ans[i]);cout<<endl;
	}
}

int main(){
	//freopen("love.in","r",stdin);
	Ninit::init();
	Nsolve::solve();
	return 0;
}
