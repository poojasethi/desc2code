#include <stdio.h>
#include <algorithm>
#include <vector>
#include <queue>
#include <deque>
#include <stack>
#include <set>
#include <map>
#include <string>
#include <assert.h>
#include <math.h>
#include <string.h>
using namespace std;
typedef vector<int> VI;
typedef pair<int,int> PII;
typedef vector<PII> VPII;
typedef long long ll;
#define FOREACH(it,vec) for(typeof((vec).begin()) it = (vec).begin(); it != (vec).end(); it++)
#define MOD(a,b) (((a)%(b)+(b))%(b))
#define REP(i,n) for (int i = 0; i < (n); i++)

int H, M, N;
int G, MM;
vector<set<int> > se;
map<int,PII> ma;

int ggt(int a, int b) {
	while(b) {
		a %= b;
		swap(a,b);
	}
	return a;
}

int main() {
	scanf("%d%d%d ", &H, &M, &N);
	G = ggt(H,M);
	MM = -1;
	REP(i,H/G)
		if ((ll)i*(M/G)%(H/G) == 1)
			MM = i;
	assert(MM != -1);
	se.resize(G);
	REP(i,G)
		REP(j,H/G)
			se[i].insert(j);
	ll erg = 0;
	REP(runde,N) {
		char c;
		int id;
		scanf("%c %d ", &c, &id);
		if (c == '-') {
			const PII &p = ma[id];
			se[p.first].insert(p.second);
		} else {
			int ha;
			scanf("%d ", &ha);
			int m = ha%G;
			int w = (ll)(ha/G)*MM%(H/G);
			set<int>::iterator it = se[m].lower_bound(w);
			if (it == se[m].end())
				it = se[m].begin();
			assert(it != se[m].end());
			int k = *it;
			erg += (k >= w ? k-w : H/G-w+k);
			se[m].erase(it);
			ma[id] = PII(m,k);
		}
	}
	printf("%I64d\n", erg);
	return 0;
}
