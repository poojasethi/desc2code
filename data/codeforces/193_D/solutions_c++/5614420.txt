#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <iostream>
using namespace std;
enum {MAXN = 300010,MAXT = MAXN * 2};
typedef pair<int,int> pii;
struct Tres
{
  pii minv,prev;
  static pii merge(const pii&a,const pii&b)
  {
    return a.first == b.first ? pii(a.first,a.second + b.second) : min(a,b);
  }
  Tres() : minv(MAXN,0),prev(MAXN,0) {}
  void operator()(const Tres &a,const Tres &b)
  {
    if (a.minv.first == b.minv.first)
      {
    minv = merge(a.minv,b.minv);
    prev = merge(a.prev,b.prev);
      }
    else
      {
    if (a.minv.first < b.minv.first)
      {
        minv = a.minv;
        prev = merge(a.prev,b.minv);
      }
    else
      {
        minv = b.minv;
        prev = merge(b.prev,a.minv);        
      }
      }
  }
  void operator += (const int &v)
  {
    minv.first += v;
    prev.first += v;
  }
  void print()
  {
    printf("%d %d %d %d\n",minv.first,minv.second,prev.first,prev.second);
  }
};
#define Loc(L,R) (((L) + (R)) | ((L) != (R)))
Tres mval[MAXT];
int delta[MAXT];
void update(int l,int r,int s,int v)
{
  if (s <= l)
    {
      delta[Loc(l,r)] += v;
      mval[Loc(l,r)] += v;
    }
  else
    {
      int mid = (l + r) >> 1;
      if (s <= mid) update(l,mid,s,v);
      update(mid + 1,r,s,v);
      mval[Loc(l,r)](mval[Loc(l,mid)],mval[Loc(mid + 1,r)]);
      mval[Loc(l,r)] += delta[Loc(l,r)];
    }
}
void setv(int l,int r,int pos)
{
  if (l < r)
    {
      int mid = (l + r) >> 1;
      if (pos <= mid) setv(l,mid,pos);
      else setv(mid + 1,r,pos);
      mval[Loc(l,r)](mval[Loc(l,mid)],mval[Loc(mid + 1,r)]);
      mval[Loc(l,r)] += delta[Loc(l,r)];
    }
}
int num[MAXN],pos[MAXN];
int main()
{
  int n;
  scanf("%d",&n);
  
  for(int i = 0;i < n;i++)
    {
      scanf("%d",&num[i]);
      --num[i];
      pos[num[i]] = i;
    }
  memset(delta,0,sizeof(delta));
  long long ans = 0;
  for(int i = n-1;i >= 0;i--)
    {
      mval[Loc(i,i)].minv = pii(0,1);
      setv(0,n - 1,i);
      update(0,n - 1,i,1);
      if (pos[i] != 0 && num[pos[i] - 1] > i) update(0,n - 1,num[pos[i] - 1],-1);
      if (pos[i] != n - 1 && num[pos[i] + 1] > i) update(0,n - 1,num[pos[i] + 1],-1);
   
      ans += mval[Loc(0,n-1)].minv.second + mval[Loc(0,n-1)].prev.second - 1;
    }
  cout << ans << endl;
  return 0;
}