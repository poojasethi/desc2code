#include<cstdio>
#include<algorithm>
#define fo(i,a,b) for(i=a;i<=b;++i)
using namespace std;
typedef long long LL;
const int mn=301000,inf=1<<30;
struct node{int v1,v2,s1,s2,s;}f[mn*4],now;
int n,m,i,j,k,l,r;
int w[mn],d[mn];
LL ans;
node operator +(node a,node b)
{
    node res;
    b.s1+=a.s,b.s2+=a.s;
    res.s1=min(a.s1,b.s1);
    res.s=a.s+b.s;
    res.s2=inf;
    res.v1=res.v2=0;
    if(a.s1>res.s1)res.s2=min(res.s2,a.s1);
    if(b.s1>res.s1)res.s2=min(res.s2,b.s1);
    if(a.s2>res.s1)res.s2=min(res.s2,a.s2);
    if(b.s2>res.s1)res.s2=min(res.s2,b.s2);
    if(a.s1==res.s1)res.v1+=a.v1;
    if(b.s1==res.s1)res.v1+=b.v1;
    if(a.s1==res.s2)res.v2+=a.v1;
    if(b.s1==res.s2)res.v2+=b.v1;
    if(a.s2==res.s2)res.v2+=a.v2;
    if(b.s2==res.s2)res.v2+=b.v2;
    return res;
}
void build(int p,int l,int r)
{
    if(l==r)
    {
        f[p].s1=0,f[p].s2=inf;
        f[p].v1=1,f[p].v2=0;
        f[p].s=0;
        return;
    }
    int m=(l+r)/2;
    if(l<=m)build(p+p,l,m);
    if(r>m)build(p+p+1,m+1,r);
    f[p]=f[p+p]+f[p+p+1];
}
void add(int p,int l,int r,int k,int v)
{
    if(l==r)
    {
        f[p].s+=v,f[p].s1+=v,f[p].s2+=v;
        return;
    }
    int m=(l+r)/2;
    if(k<=m)add(p+p,l,m,k,v);
    else add(p+p+1,m+1,r,k,v);
    f[p]=f[p+p]+f[p+p+1];
}
node query(int p,int l,int r,int k)
{
    if(k>=r)return f[p];
    int m=(l+r)/2;
    if(k<=m)return query(p+p,l,m,k);
    else return f[p+p]+query(p+p+1,m+1,r,k);
}
void cover(int l,int r,int v)
{
    if(l>n||r<1)return;
    add(1,1,n,l,v);
    if(r<n)add(1,1,n,r+1,-v);
}
int main()
{
    scanf("%d",&n);
    fo(i,1,n)scanf("%d",w+i),d[w[i]]=i;
    w[0]=w[n+1]=inf;
    build(1,1,n);
    fo(i,1,n)
    {
        cover(1,i,1);
        l=w[d[i]-1]>i?0:w[d[i]-1];
        r=w[d[i]+1]>i?0:w[d[i]+1];
        if(l)cover(1,l,-1);
        if(r)cover(1,r,-1);
        now=query(1,1,n,i);
        if(now.s1<=2)ans+=now.v1;
        if(now.s2<=2)ans+=now.v2;
    }
    ans-=n;
    printf("%I64d\n",ans);
    return 0;
}