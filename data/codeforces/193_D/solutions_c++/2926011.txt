#include<cstdio>
#define tree int t,int l,int r
#define left t*2,l,mid
#define right t*2+1,mid+1,r
#define M int mid=l+r>>1
#define N 300005
int n,ll,rr,A,a[N],b[N],d[N<<2],m[N<<2],f[N<<2],s[N<<2];
long long ans;
void update(int t)
{
	int L=t*2,R=L+1; m[t]=m[L]<m[R]?m[L]:m[R]; f[t]=f[L]*(m[t]==m[L])+f[R]*(m[t]==m[R]);
	s[t]=s[L]*(m[t]==m[L])+s[R]*(m[t]==m[R])+f[L]*(m[t]+1==m[L])+f[R]*(m[t]+1==m[R]);
}
void build(tree){if (l==r) f[t]=r-l+1; else {M; build(left),build(right);}}
void down(int t,int A){d[t]=0,d[t*2]+=A,d[t*2+1]+=A,m[t*2]+=A,m[t*2+1]+=A;}
void add(tree,int A)
{
	if (l>rr || r<ll) return; if (ll<=l && r<=rr){m[t]+=A,d[t]+=A; return;}
	M; if (d[t]) down(t,d[t]); add(left,A),add(right,A),update(t);
}
int query(tree,int x)
{
	if (l>x) return 0; if (r<=x) return s[t]*(m[t]<=1)+f[t]*(m[t]<=2);
	M; if (d[t]) down(t,d[t]); return query(left,x)+query(right,x);
}
#define Add(l,r,A) ll=l,rr=r,add(1,1,n,A)
int main()
{
	scanf("%d",&n),build(1,1,n);
	for (int i=1;i<=n;i++) scanf("%d",&a[i]),b[a[i]]=i;
	for (int i=1;i<=n;i++){
		int x=a[b[i]-1],y=a[b[i]+1]; Add(1,i,1);
		if (x && x<i) Add(1,x,-1); if (y && y<i) Add(1,y,-1);
		ans+=query(1,1,n,i-1);
		}
	printf("%I64d\n",ans); return 0;
}
