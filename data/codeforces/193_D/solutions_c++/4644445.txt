#include<cstdio>
#include<algorithm>
using namespace std;
#define sz  300010
#define root 1,1,n
#define lson who<<1,l,mid
#define rson who<<1|1,mid+1,r

struct node{
    int mval, lazy, s[2];
}nt[sz<<2];

inline void update(int who,int lazy)
{
    nt[who].lazy+=lazy;
    nt[who].mval+=lazy;
}

inline void push_down(int who)
{
    if(nt[who].lazy)
    {
        update(who<<1,nt[who].lazy);
        update(who<<1|1,nt[who].lazy);
        nt[who].lazy = 0;
    }
}

inline void gain(int who,int from)
{
    if(nt[who].mval==nt[from].mval)
    {
        nt[who].s[0] += nt[from].s[0];
        nt[who].s[1] += nt[from].s[1];
    }
    else if(nt[who].mval+1==nt[from].mval)
    {
        nt[who].s[1] += nt[from].s[0];
    }
}

inline void push_up(int who)
{
    nt[who].mval = min(nt[who<<1].mval,nt[who<<1|1].mval);
    nt[who].s[0] = nt[who].s[1] = 0;
    gain(who,who<<1);gain(who,who<<1|1);
}

void insert(int L,int R,int add,int who,int l,int r)
{
    if(L<=l&&R>=r)
    {
        update(who,add);
        return;
    }
    push_down(who);
    int mid = (l+r)/2;
    if(L<=mid)insert(L,R,add,who<<1,l,mid);
    if(R>mid)insert(L,R,add,who<<1|1,mid+1,r);
    push_up(who);
}

int query(int L,int R,int who,int l,int r)
{
    if(L<=l&&R>=r)
    {
        return nt[who].mval==1?nt[who].s[0]+nt[who].s[1]:
                nt[who].mval==2?nt[who].s[0]:0;
    }
    push_down(who);
    int mid = (l+r)/2;
    int ret = 0;
    if(L<=mid)ret+=query(L,R,who<<1,l,mid);
    if(R>mid)ret+=query(L,R,who<<1|1,mid+1,r);
    return ret;
}

void build(int who,int l,int r)
{
    nt[who].s[0] = r - l + 1;
    nt[who].s[1] = 0;
    nt[who].mval = 0;
    nt[who].lazy = 0;
    if(l==r)return;
    int mid = (l+r)/2;
    build(who<<1,l,mid);
    build(who<<1|1,mid+1,r);
}

int num[sz],pos[sz];
int main()
{
    int n;scanf("%d",&n);
    for(int i = 1; i <= n; i ++)
    {
        scanf("%d",num+i);
        pos[ num[i] ] = i;
    }
    build(root);
    long long ret = 0;
    for(int i = 1; i <= n; i ++)
    {
        insert(1,i,1,root);
        if(pos[i] > 1&&i>num[pos[i]-1])insert(1,num[pos[i]-1],-1,root);
        if(pos[i] < n&&i>num[pos[i]+1])insert(1,num[pos[i]+1],-1,root);
        ret += query(1,i,root) - 1;
    }
    printf("%I64d\n",ret);
}
