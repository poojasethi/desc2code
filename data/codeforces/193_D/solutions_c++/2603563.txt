#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>

using namespace std;

#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1

const int maxn=300010;
const int INF=0x3f3f3f3f;

int col[maxn<<2|1],z[maxn],p[maxn],n;

struct node
{
	int v1,v2,c1,c2;
	node(){}
	node(int a,int b,int c,int d)
	{
		v1=a;c1=b;v2=c;c2=d;
	}
	node operator+(const int &a)const
	{
		return node(v1+a,c1,v2+a,c2);
	}
	node operator+(const node &a)const
	{
		pair<int,int> z[5];
		z[1]=make_pair(v1,c1);
		z[2]=make_pair(v2,c2);
		z[3]=make_pair(a.v1,a.c1);
		z[4]=make_pair(a.v2,a.c2);
		sort(z+1,z+4+1);
		int p=1;
		for (int b=2;b<=4;b++)
			if (z[b].first!=z[b-1].first)
			{
				p++;
				z[p]=z[b];
			}
			else z[p].second+=z[b].second;
		return node(z[1].first,z[1].second,z[2].first,z[2].second);
	}
}y[maxn<<2|1];

void update(int rt)
{
	y[rt]=y[rt<<1]+y[rt<<1|1];
}

void push_col(int rt)
{
	if (col[rt])
	{
		col[rt<<1]+=col[rt];
		col[rt<<1|1]+=col[rt];
		y[rt<<1]=y[rt<<1]+col[rt];
		y[rt<<1|1]=y[rt<<1|1]+col[rt];
		col[rt]=0;
	}
}

void buildtree(int l,int r,int rt)
{
	if (l==r)
	{
		y[rt]=node(0,1,INF,0);
		col[rt]=0;
		return;
	}
	int m=(l+r)>>1;
	buildtree(lson);
	buildtree(rson);
	update(rt);
}

void changetree(int l,int r,int rt,int nowl,int nowr,int delta)
{
	if (nowl<=l && r<=nowr)
	{
		col[rt]+=delta;
		y[rt]=y[rt]+delta;
		return;
	}
	push_col(rt);
	int m=(l+r)>>1;
	if (nowl<=m) changetree(lson,nowl,nowr,delta);
	if (m<nowr) changetree(rson,nowl,nowr,delta);
	update(rt);
}

int query(int l,int r,int rt,int nowl,int nowr)
{
	if (nowl<=l && r<=nowr) return (y[rt].v1<=2)*y[rt].c1+(y[rt].v2<=2)*y[rt].c2;
	int m=(l+r)>>1;
	int ans1=0,ans2=0;
	if (nowl<=m) ans1=query(lson,nowl,nowr);
	if (m<nowr) ans2=query(rson,nowl,nowr);
	return ans1+ans2;
}

int main()
{
	scanf("%d",&n);
	for (int a=1;a<=n;a++)
	{
		scanf("%d",&z[a]);
		p[z[a]]=a;
	}
	buildtree(1,n,1);
	long long ans=0;
	for (int a=n;a>=1;a--)
	{
		int nowp=p[a];
		int s[3];
		if (nowp+1<=n && z[nowp+1]>a) s[1]=z[nowp+1];
		else s[1]=n+1;
		if (nowp>=2 && z[nowp-1]>a) s[2]=z[nowp-1];
		else s[2]=n+1;
		sort(s+1,s+3);
		changetree(1,n,1,a,s[1]-1,1);
		if (s[2]<=n) changetree(1,n,1,s[2],n,-1);
		ans+=query(1,n,1,a,n)-1;
	}
	printf("%I64d\n",ans);

	return 0;
}
