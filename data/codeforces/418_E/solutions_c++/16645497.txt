#include <bits/stdc++.h>

using namespace std;

#define pb push_back
#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)
#define endl '\n'
#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)
#define mp make_pair
#define nd second
#define st first
#define type(x) __typeof(x.begin())

typedef pair < int ,int > pii;

typedef long long ll;

const long long linf = 1e18+5;
const int mod = (int) 1e9 + 7;
const int logN = 17;
const int inf = 1e9;
const int N = 2e5 + 5;
const int sq = 505;

int x, y, m, t, w[N], S, s, belong[N], n, a[N], start[N], finish[N], cnt[206][N], F[206][N];
map< int , int > H;

int que(int x, int y) {
	int ans = 0;
	for(; y < N; y += y & -y)
		ans += F[x][y];
	return ans;
}

int upd(int x, int y, int z) {
	for(; y > 0; y -= y & -y)
		F[x][y] += z;
}

int down(int &x) {
	if(H[x]) return x = H[x];
	H[x] = ++s; w[s] = x;
	return x = H[x];
}

int main() {

	scanf("%d", &n);

	int last = 1;

	FOR(i, 1, n) {
		scanf("%d", &a[i]); down(a[i]);
		if(i == n || i % sq == 0) {
			start[++S] = last;
			finish[S] = i;
			FOR(j, last, i) belong[j] = S;
			last = i + 1;
		}
	}

	FOR(i, 1, S) {
		FOR(j, 1, finish[i]) cnt[i][a[j]]++;
		FOR(j, 1, s) upd(i, cnt[i][j], 1);
	}

	scanf("%d", &m);

	FOR(i, 1, m) {
		scanf("%d %d %d", &t, &x, &y);
		if(t == 2) {
			if(x == 1) printf("%d\n", w[a[y]]);
			else {
				int ans = cnt[belong[y] - 1][a[y]];
				FOR(i, start[belong[y]], y) ans += a[i] == a[y];
				if(x % 2 == 0) { printf("%d\n", ans); continue; }
				int res = 0, c = belong[y];
				FOR(j, y + 1, finish[c]) { upd(c, cnt[c][a[j]], -1); cnt[c][a[j]]--; upd(c, cnt[c][a[j]], +1); }
				printf("%d\n", que(belong[y], ans));	
				FOR(j, y + 1, finish[c]) { upd(c, cnt[c][a[j]], -1); cnt[c][a[j]]++; upd(c, cnt[c][a[j]], +1); }
			}
		} 
		else {
			swap(x, y); 
			down(y); int c = belong[x];
			FOR(j, c, S) { upd(j, cnt[j][a[x]], -1); cnt[j][a[x]]--; upd(j, cnt[j][a[x]], +1); } a[x] = y;
			FOR(j, c, S) { upd(j, cnt[j][a[x]], -1); cnt[j][a[x]]++; upd(j, cnt[j][a[x]], +1); } a[x] = y;
		}
	}

	return 0;
}
