#include<bits/stdc++.h>
		 
using namespace std;
#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)
#define type(x) __typeof(x.begin())

#define dbg(x) cerr << (#x) << " --> " << (x) << endl
#define y1 sdfsdfsdf
#define int long long
#define pii pair<int,int>
#define mod 1000000007
#define N (int)(2e5+10)
#define mp make_pair
#define pb push_back
#define sd second
#define ft first
#define endll puts("")
#define endl '\n'
#define inf mod
#define left hasan
#define ort ((sol+sag)/2)
int n,d,s,c[N],f[N],l[N],var,yok,self,left,sum,ans,ans2,pos,pos2;
vector<pii >V,V2;
pii mx;
main(){
	cin >> n >> d >> s;
	FOR(i,1,n){
		scanf("%lld %lld %lld",&c[i],&f[i],&l[i]);
		if(c[i]){
			sum += c[i];
			var++;
			if(l[i] >= d)
				V.pb(mp(f[i],i));		
		}
		else{
			yok++;
			if(l[i] >= d){
				ans2 += f[i];
				V2.pb(mp(f[i],i));
			}
		}
	}
	sort(V.begin(),V.end());
	sort(V2.begin(),V2.end());
	
	pos = (int)V2.size()-1;
	pos2 = V2.size();
	while(ans2 > s and pos >= 0){
		ans2 -= V2[pos].ft;
		pos--;
		pos2--;
	}	
	mx = mp(pos2,-ans2);
	for(int i=0;i<V.size();i++){
		ans += V[i].ft;
		if(ans > s) break;
		left = sum - var + (i+1);	 
		self = yok - left;
		while(pos >= 0 and (ans + ans2 > s or pos2 > self)){
			ans2 -= f[V2[pos].sd];
			pos--;
			pos2--;
		}
		if(ans + ans2 > s) continue;
		mx = max(mx , mp(var + pos2 + min(left , yok - pos2) , -(ans + ans2)));
	}
	printf("%lld %lld\n",mx.ft,-mx.sd);
	return 0;
}
