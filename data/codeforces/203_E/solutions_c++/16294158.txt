#include<bits/stdc++.h>

using namespace std;

#define st first
#define nd second
#define mp make_pair
#define pb push_back
#define sol (root+root)
#define sag (root+root+1)
#define orta ((bas+son)/2)
#define ll long long
#define pii pair<int,int>
#define type(x) __typeof((x).begin())
#define foreach(it, x) for(type(x) it = (x).begin(); it != (x).end(); it++)
#define int ll

const int N=1e5+5;
const int mod=1e9+7;
const int inf=1e9+7;

int n,d,S,i,zero,notzero,sumc,cost,cost2,p,k,capacity,self,mx,mincost=INT_MAX;
int c[N],f[N],l[N];

vector<pii > v,v2;

main(){

	scanf("%lld %lld %lld",&n,&d,&S);

	for(i=1 ; i<=n ; i++){
		scanf("%lld %lld %lld",c+i,f+i,l+i);
		if(c[i]>0 and l[i]>=d)
			v.pb(mp(f[i],i));
		if(c[i]>0){
			sumc+=c[i];
			notzero++;
		}
		else {
			zero++;
			if(l[i]>=d){
				v2.pb(mp(f[i],i));
				cost2+=f[i];
			}
		}
	}

	sort(v.begin(),v.end());
	sort(v2.begin(),v2.end());

	p=(int)v2.size()-1;
	k=v2.size();

	while(cost2>S and p>=0){
		cost2-=v2[p].st;
		p--;
		k--;
	}

	mx=k;
	mincost=cost2;

	for(i=0 ; i<v.size() ; i++){
		cost+=v[i].st;
		if(cost>S)
			break;
		capacity=sumc-notzero+i+1;
		self=zero-capacity;
		// SELF AZALIYOR
		while((k>self or cost+cost2>S) and p>=0){
			cost2-=f[v2[p].nd];
			p--;
			k--;
		}
		if(cost+cost2>S)
			continue;
		if(notzero+k+min(capacity,zero-k)>mx){
			mx=notzero+k+min(capacity,zero-k);
			mincost=cost+cost2;
		}
		if(notzero+k+min(capacity,zero-k)==mx)
			mincost=min(mincost,cost+cost2);
	}

	printf("%lld %lld",mx,mincost);
}