#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
typedef long long ll;
struct bot{
	ll c,f,l;
	bool operator<(const bot &t)const{
		return f<t.f;
	}
};
int main(){
	ll n,m,d,s;
	cin >> n >> d >> s;
	vector<bot> carry,solo;
	ll csum = 0;
	for(ll i = 0; i < n; ++i){
		bot t;
		cin >> t.c >> t.f >> t.l;
		if(t.l<d)
			t.f=s+1;
		if(t.c==0)
			solo.push_back(t);
		else{
			carry.push_back(t);
			csum+=t.c;
		}
	}
	sort(carry.begin(),carry.end());
	sort(solo.begin(),solo.end());
	n=carry.size(),m=solo.size();
	vector<ll> ssum(m+1);
	for(ll i = 1; i <= m; ++i){
		ssum[i]=ssum[i-1]+solo[i-1].f;
	}
	ll best_num, best_fuel;
	{//if we take no carries:
		ll t = upper_bound(ssum.begin(),ssum.end(),s)-ssum.begin()-1;
		best_num = t;
		best_fuel = ssum[t];
	}
	ll cost = 0;
	for(ll i = 0; i < n; ++i){
		cost+=carry[i].f;
		if(s-cost<0)
			break;
		ll can_carry = csum-(n-(i+1));
		if(can_carry>=m){
			if(best_num<n+m){
				best_num=n+m;
				best_fuel=cost;
			}
			best_fuel=min(best_fuel,cost);
			continue;
		}
		ll lo=0,hi=m-can_carry,mid;
		while(lo<hi){
			mid=(lo+hi+1)/2;
			if(ssum[mid]<=s-cost)
				lo=mid;
			else
				hi=mid-1;
		}
		ll t=lo;
		ll cur_num = n+can_carry+t;
		ll cur_cost = cost+ssum[t];
		if(cur_num>best_num){
			best_num=cur_num;
			best_fuel=cur_cost;
		}
		if(cur_num==best_num){
			best_fuel=min(best_fuel,cur_cost);
		}
	}
	cout << best_num << ' ' << best_fuel << '\n';
}
