#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <algorithm>

using namespace std;

typedef long long ll;

const int MaxN = 100005;
const int oo = 0x3F3F3F3F;

struct Node {
	int c, f, l;
	Node() { }
	Node(int c, int f, int l) : c(c), f(f), l(l) { }
} node[MaxN];
int N, d, S;
int s[MaxN], p[MaxN];

bool comp(const Node& lhs, const Node& rhs) {
	if (lhs.f > S || lhs.l < d) return false;
	if (rhs.f > S || rhs.l < d) return true;
	if (lhs.c == 0 && rhs.c != 0 || lhs.c != 0 && rhs.c == 0) return lhs.c == 0;
	return lhs.f < rhs.f;
}

int main() {
	int c, f, l;
	int sum, sc;
	int mx, mn;
	
	while (scanf("%d%d%d", &N, &d, &S) == 3) {
		for (int i = 0; i < N; i++) {
			scanf("%d%d%d", &c, &f, &l);
			node[i] = Node(c, f, l);
		}
		sort(node, node + N, comp);
		s[N] = 0;
		for (int i = N - 1; i >= 0; i--)
			if (node[i].c > 0) s[i] = min(N, s[i + 1] + node[i].c);
			else s[i] = s[i + 1];
		sum = sc = 0;
		mx = mn = 0;
		p[0] = 0;
		for (int i = 0, j = 0; i < N; i++) {
			if (node[i].l < d) break;
			if (node[i].c == 0) {
				if (i == j && p[j] + node[i].f <= S) {
					p[j + 1] = p[j] + node[j].f;
					j++;
					if (mx < j) {
						mx = j;
						mn = p[j];
					}
				}
				continue;
			}
			if (S - sum >= node[i].f) {
				sum += node[i].f;
				while (j && sum + p[j] > S) j--;
				sc += node[i].c + 1;
				int temp = min(N, sc + s[i + 1]);
				int cnt = min(j, N - temp);
				if (mx < temp + cnt || (mx == temp + cnt && mn > sum + p[cnt])) {
					mx = temp + cnt;
					mn = sum + p[cnt];
				}
			} else {
				break;
			}
		}
		printf("%d %d\n", mx, mn);
	}
	
	return 0;
}

			 			     	   	 	 	     	