# class DJ_SET:
#     D = []
#     MEMBERSHIP = {}
#
#
#     def add_to_set(self, x):
#         self.D.append(set([x]))
#         self.MEMBERSHIP[x] = len(self.D) - 1
#
#     def create_set(self, x):
#         return set([x])
#
#     def find_set(self, x):
#         idx = -1
#         if x in self.MEMBERSHIP:
#             idx = self.MEMBERSHIP[x]
#         return idx
#
#     def merge_set(self, x,y):
#         x_i = self.find_set(x)
#         if x_i == -1:
#             x_set =  self.create_set(x)
#         else:
#             x_set = set(self.D[x_i])
#             self.D[x_i] = None
#             del self.MEMBERSHIP[x]
#
#         y_i = self.find_set(y)
#         if y_i == -1:
#             y_set = self.create_set(y)
#         else:
#             y_set = set(self.D[y_i])
#             self.D[y_i] = None
#             del self.MEMBERSHIP[y]
#
#         x_set.update(y_set)
#         self.D.append(set(x_set))
#         self.update_membership(x_set, len(self.D) - 1)
#
#     def update_membership(self, s, membership):
#         for e in s:
#             self.MEMBERSHIP[e] = membership
#
#
# dj_set = DJ_SET()

G = [[0 for i in range(5)] for j in range(5)]

m = input()
for i in range(m):
    v = map(int, raw_input().split())
    G[v[0]-1][v[1]-1] = 1
    G[v[1]-1][v[0]-1] = 1

S = [sum(G[i]) for i in range(5)]
if any(x >= 3 or x <= 1 for x in S):
    print "WIN"
else:
    print "FAIL"