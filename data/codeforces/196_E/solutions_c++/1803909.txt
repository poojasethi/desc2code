#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
#include<vector>
#include<algorithm>
#define N 100009
#define ll long long
using namespace std;

struct edge{int v,w;edge *nxt;}E[N<<1],*Adj[N],*cur;
struct edge2{int u,v;ll w;}EE[N<<1];
struct state{int v;ll c;};
struct cmp{bool operator ()(const state &a,const state &b){return a.c>b.c;}};

int n,m,K;
int pot[N],anc[N],f[N];
ll d[N];

bool cmp2(const edge2 &a,const edge2 &b){return a.w<b.w;}
void addedge(int u,int v,int w){cur->v=v,cur->w=w,cur->nxt=Adj[u],Adj[u]=cur++;}
int find(int a){return a==anc[a]?a:anc[a]=find(anc[a]);}
void init_anc(){for(int i=0;i<=n;i++) anc[i]=i;}
bool union_set(int a,int b){a=find(a),b=find(b);if(a==b) return false;anc[a]=b;return true;}

void dij(){
    state p,t;
    priority_queue<state,vector<state>,cmp> Q;
    memset(d,-1,sizeof(d));
    for(int i=1;i<=n;i++)
        if(pot[i])
            p.v=f[i]=i,p.c=d[i]=0,Q.push(p);
    while(!Q.empty()){
        p=Q.top();
        Q.pop();
        if(p.c!=d[p.v]) continue;
        for(edge *i=Adj[p.v];i;i=i->nxt)
            if(d[i->v]==-1||p.c+i->w<d[i->v]){
                f[t.v=i->v]=f[p.v];
                t.c=d[i->v]=p.c+i->w;
                Q.push(t);
            }
    }
}

int main(){    
    cur=E;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        addedge(a,b,c);
        addedge(b,a,c);
    }    
    scanf("%d",&K);
    for(int i=1,t;i<=K;i++) scanf("%d",&t),pot[t]=1;
    dij();
    int cnt=0;
    for(int i=1;i<=n;i++)
        for(edge *j=Adj[i];j;j=j->nxt)
            if(f[i]!=f[j->v])
                EE[cnt].u=f[i],EE[cnt].v=f[j->v],EE[cnt++].w=d[i]+d[j->v]+j->w;
    sort(EE,EE+cnt,cmp2);
    ll ans=d[1];
    init_anc();
    for(int i=0,c=K-1;c&&i<cnt;i++)
        if(union_set(EE[i].u,EE[i].v))
            c--,ans+=EE[i].w;
    cout<<ans<<endl;
    return 0;
}
