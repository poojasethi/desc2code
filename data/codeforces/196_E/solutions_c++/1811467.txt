#include <cstdio>
#include <vector>
#include <queue>
#include <algorithm>
#include <climits>

using namespace std;

typedef long long int64;

struct Edge {
  int x, y;
  int64 z;
};

const int N = 100000 + 10;
const int M = 100000 + 10;

Edge e[M], ee[M];
vector<pair<int, int64> > a[N];
int64 d[N];
int root[N];
int f[N];

bool operator <(const Edge& a, const Edge& b) {
  return a.z < b.z;
}

int find(int x) {
  if (f[x] != x) f[x] = find(f[x]);
  return f[x];
}

int main() {
  int n, m;
  scanf("%d%d", &n, &m);
  for (int i = 0; i < m; ++i) {
    int x, y, z;
    scanf("%d%d%d", &x, &y, &z);
    --x; --y;
    a[x].push_back(make_pair(y, z));
    a[y].push_back(make_pair(x, z));
    e[i].x = x; e[i].y = y; e[i].z = z;
  }
  priority_queue<pair<int64, int>, vector<pair<int64, int> >, greater<pair<int64, int> > > q;
  int nn;
  scanf("%d", &nn);
  fill(d, d + n, LLONG_MAX);
  while (nn--) {
    int x;
    scanf("%d", &x);
    --x;
    root[x] = x;
    d[x] = 0;
    q.push(make_pair(d[x], x));
  }
  while (!q.empty()) {
    int64 dd = q.top().first;
    int v = q.top().second;
    q.pop();
    if (dd != d[v]) continue;
    for (vector<pair<int, int64> >::iterator it = a[v].begin(); it != a[v].end(); ++it) {
      int u = it->first;
      int64 cost = it->second;
      if (d[u] > d[v] + cost) {
        d[u] = d[v] + cost;
        root[u] = root[v];
        q.push(make_pair(d[u], u));
      }
    }
  }
  for (int i = 0; i < m; ++i) {
    ee[i].x = root[e[i].x];
    ee[i].y = root[e[i].y];
    ee[i].z = d[e[i].x] + d[e[i].y] + e[i].z;
  }
  int64 ret = d[0];
  for (int i = 0; i < n; ++i) {
    f[i] = i;
  }
  sort(ee, ee + m);
  for (int i = 0; i < m; ++i) {
    int rx = find(ee[i].x);
    int ry = find(ee[i].y);
    if (rx == ry) continue;
    f[ry] = rx;
    ret += ee[i].z;
  }
  printf("%I64d\n", ret);
  return 0;
}
