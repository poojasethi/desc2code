#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <queue>
#define N 200010
#define int64 long long
#define For(i,x,y) for (i=x;i<=y;i++)
using namespace std;
struct ww {
	int64 a,id;
	inline bool operator < (const ww &A) const {
		return a>A.a;
	}
};
struct w {
	int64 z;
	int x,y;
} c[N];
int i,j,k,n,m,x,y,t,z,K,v;
int a[N],b[N],next[N],head[N],fr[N],F[N],h[N];
int64 gg[N];
priority_queue<ww> q;
int64 an;
inline void add(int x,int y,int z) {
	a[++t]=y,b[t]=z,next[t]=head[x],head[x]=t;
	a[++t]=x,b[t]=z,next[t]=head[y],head[y]=t;
}
inline void into(int x,int y,int64 z) {
	if (x==y) return;
	c[++t]=(w){z,x,y};
}
inline bool cc1(const w &a,const w &b) {
	return a.z<b.z;
}
int get(int x) {
	return h[x]==x?x:h[x]=get(h[x]);
}
int main() {
	scanf("%d%d",&n,&m);
	For(i,1,m) {
		scanf("%d%d%d",&x,&y,&z);
		add(x,y,z);
	}
	scanf("%d",&K);
	memset(gg,120,sizeof(gg));
	For(i,1,K) {
		scanf("%d",&x);
		gg[x]=0;
		q.push((ww){0ll,x});
		fr[x]=x;
	}
	t=0;
	for (;q.size();) {
		ww A=q.top();
		q.pop();
		if (F[A.id]) continue;
		F[A.id]=1;
		for (v=head[A.id];v;v=next[v]) {
			int B=a[v];
			if (gg[B]<=gg[A.id]+b[v]) into(fr[B],fr[A.id],gg[B]+gg[A.id]+b[v]);
			else {
				gg[B]=gg[A.id]+b[v];
				fr[B]=fr[A.id];
				q.push((ww){gg[B],B});
			}
		}
	}
	sort(c+1,c+t+1,cc1);
	For(i,1,n) h[i]=i;
	For(i,1,t) if (get(c[i].x)!=get(c[i].y)) {
		h[get(c[i].x)]=get(c[i].y);
		an+=c[i].z;
	}
	printf("%I64d\n",an+gg[1]);
	return 0;
}
