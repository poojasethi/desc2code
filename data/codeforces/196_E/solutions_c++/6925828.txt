#include<cstdio>
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<queue>
#define mk make_pair
using namespace std;
long long i,j,k,l,n,m,s,an,sum,tot,K;
const long long N=210000;
long long e[N],next[N],go[N],v[N];
long long be[N],fa[N],f[N];
//priority_queue <pair<long long,int>> q;
priority_queue <pair<long long,int> > q;
bool ff[N];
class arr
{
	public:
		long long x,y,v;
}a[N*10];
long long get(long long x)
{
	if(fa[x]==x) return x;
	fa[x]=get(fa[x]);
	return fa[x];
}
void add(long long x,long long y,long long z)
{
	tot++;e[tot]=y;next[tot]=go[x];go[x]=tot;v[tot]=z;
}
bool com(const arr &o,const arr &p)
{
	return o.v<p.v;
}
int main()
{
	scanf("%I64d%I64d",&n,&m);
	for (long long i=1;i<=m;i++)
	{
		long long x,y,z;
		scanf("%I64d%I64d%I64d",&x,&y,&z);
		add(x,y,z);
		add(y,x,z);
	}
	scanf("%I64d",&K);
	
	memset(f,2,sizeof(f));
	for (long long i=1;i<=K;i++)
	{
		long long x;
		scanf("%I64d",&x);
		f[x]=0;
		q.push(mk(0,x));
		be[x]=x;
		fa[x]=x;
	}
	tot=0;
	while (!q.empty())
	{
		long long x=q.top().second;
		q.pop();
		if (ff[x]) continue;
		ff[x]=1;
		for (long long p=go[x];p;p=next[p])
		{
			long long y=e[p];
			if ((be[y])&&(be[y]!=be[x])) 
			{
				tot++;
				a[tot].x=be[x];a[tot].y=be[y];a[tot].v=f[x]+f[y]+v[p];
			}	
			if (f[x]+v[p]<f[y])
			{
				//q.push_back(mk(f[y],y));;
				f[y]=f[x]+v[p];
				be[y]=be[x];
				q.push(mk(-f[y],y));
			}
		}
	}
	sort(&a[1],&a[tot+1],com);
	for (long long i=1;i<=tot;i++)
	{
		long long x=get(a[i].x);
		long long y=get(a[i].y);
		if (x!=y)
		{
			fa[x]=y;
			an+=a[i].v;
		}
	}
	printf("%I64d\n",an+f[1]);
	return 0;
}
		
