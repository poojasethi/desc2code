#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
#define N 100005
using namespace std;
typedef __int64 ll;

const ll inf = 1ll << 60;
int pre[N], fa[N], f[N];
int n, m, cnt;
ll dist[N];
struct edge{
    int u, v, w, next;
}e[N * 2];
struct node{
    int u;
    ll w;
    bool operator< (const node &x) const{
        return w > x.w;
    }
};
priority_queue<node> q;

void addedge(int u, int v, int w){
    e[cnt].u = u;e[cnt].v = v;e[cnt].w = w;
    e[cnt].next = pre[u];pre[u] = cnt ++;
}

node maken(int u, ll w){
    node ret;
    ret.u = u;ret.w = w;
    return ret;
}

void bfs(){
    for(int i = 1;i <= n;i ++)dist[i] = inf;
    int num;scanf("%d", &num);
    for(int i = 0;i < num;i ++){
        int x;scanf("%d", &x);
        fa[x] = x;
        dist[x] = 0;q.push(maken(x, 0));
    }
    while(!q.empty()){
        node u = q.top();q.pop();
        for(int i = pre[u.u];i != -1;i = e[i].next){
            int v = e[i].v;
            ll w = e[i].w + dist[u.u];
            if(dist[v] > w){
                dist[v] = w;
                fa[v] = fa[u.u];
                q.push(maken(v, w));
            }
        }
    }
}

int find(int x){
    if(x != f[x])f[x] = find(f[x]);
    return f[x];
}

bool cmp(edge x, edge y){
    return (dist[x.u] + dist[x.v] + x.w) < (dist[y.u] + dist[y.v] + y.w);
}

int main(){
    scanf("%d%d", &n, &m);
    cnt = 0;
    for(int i = 0;i <= n;i ++){
        fa[i] = i;pre[i] = -1;f[i] = i;
    }
    for(int i = 0;i < m;i ++){
        int u, v, w;scanf("%d%d%d", &u, &v, &w);
        addedge(u, v, w);
        addedge(v, u, w);
    }
    bfs();
    ll cost = 0;
    sort(e, e + cnt, cmp);
    for(int i = 0;i < cnt;i ++){
        int x = find(fa[e[i].u]);
        int y = find(fa[e[i].v]);
        //cout<<e[i].u<<' '<<e[i].v<<' '<<x<<' '<<y<<endl;
        if(x != y){
            cost += e[i].w + dist[e[i].u] + dist[e[i].v];
            f[x] = f[y];
        }
    }
    printf("%I64d\n", cost + dist[1]);
    return 0;
}

 				 		    	  	   	 			  	