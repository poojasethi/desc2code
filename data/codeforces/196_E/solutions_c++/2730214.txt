//By Lin
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<iostream>
#define maxn 100055
using namespace std;
typedef long long LL;

int     ecnt;
struct  Edge{
    int to,x;
    LL  w;
    Edge *next;
}*mat[maxn],edges[maxn*2];
bool    cmp( const Edge &a , const Edge &b){
    return a.w < b.w;
}
void    link(int x,int to ,int w ){
    edges[ecnt].to = to;
    edges[ecnt].x  = x;
    edges[ecnt].w  = w;
    edges[ecnt].next = mat[x];
    mat[x] = &edges[ecnt++];
}

int     v[maxn],p[maxn],n,m;
LL      d[maxn];
bool    in_que[maxn];
queue<int> que;

bool    check(LL &x,LL y){
    if ( x == -1 || x>y ) { x = y; return true; }
    return false;
}
int     Find(int x){
    if ( p[x] != x ) p[x] = Find(p[x]);
    return p[x];
}
int     main(){
    int x,y,w;
    scanf("%d%d", &n, &m );
    while ( m -- ) {
        scanf("%d%d%d", &x, &y , &w );
        link( x , y , w );
        link( y , x , w );
    }
    scanf("%d", &m );
    memset( d, -1 , sizeof(d) );
    while ( m -- ) {
        scanf("%d", &x );
        v[x] = x , d[x] = 0;
        que.push(x); in_que[x] = true;
    }
    while ( !que.empty() ) {
        int i = que.front(); que.pop();
        in_que[i] = false;
        for ( Edge *p = mat[i]; p ; p = p->next ){
            int to = p->to;
            if ( check(d[to],d[i]+p->w) ){
                v[to] = v[i];
                if ( !in_que[to] ) 
                    in_que[to] = true,que.push(to);
            }
        }
    }
    for (int i = 0; i<ecnt/2; i++) {
        edges[i] = edges[i*2];
        edges[i].w+= d[edges[i].to] + d[edges[i].x];
    }
    ecnt /= 2;
    sort( edges , edges+ecnt , cmp );
    for (int i = 1; i<=n; i++) p[i] = i; 
    LL ans = d[1];
    for (int i = 0; i<ecnt; i++){
        if ( Find(v[edges[i].to]) != Find(v[edges[i].x]) ) {
            ans += edges[i].w;
            p[Find(v[edges[i].to])] = Find(v[edges[i].x]);
        }
    }
    cout<<ans<<endl;
    return 0;
}
