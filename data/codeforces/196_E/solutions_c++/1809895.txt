#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
#define FOR(i,s,e) for (int i=(s); i<(e); i++)
#define FOE(i,s,e) for (int i=(s); i<=(e); i++)
#define FOD(i,s,e) for (int i=(s)-1; i>=(e); i--)
#define CLR(a,x) memset(a, x, sizeof(a))
#define EXP(i,l) for (int i=(l); i; i=qn[i])
#define LLD long long
#define N 100005
#define M 200005
using namespace std;

struct node{
	int x;
	LLD s;
	bool operator < (node const &T) const{return s > T.s;}
};

int n, m, ed, x, y, w;
int par[N], l[N], u[N], p[N], port[N];
int qd[M], qn[M], qw[M];
LLD v[N];
priority_queue<node> q;

void bd(int x, int y, int w){
	qd[++ed] = y, qn[ed] = l[x], l[x] = ed, qw[ed] = w;
}

void Dijkstra(){
	CLR(u, 0);
	CLR(v, 127);
	FOR(i,0,m){
		q.push((node){port[i], 0});
		v[port[i]] = 0;
		p[port[i]] = port[i];
	}
	
	while (!q.empty()){
		node cur = q.top();
		q.pop();
		if (u[cur.x]) continue;
		u[cur.x] = 1;
		EXP(i,l[cur.x])
		if (cur.s + qw[i] < v[qd[i]]){
			v[qd[i]] = cur.s + qw[i];
			p[qd[i]] = p[cur.x];
			q.push((node){qd[i], v[qd[i]]});
		}
	}
}

struct edge{
	int x, y;
	LLD s;
	bool operator < (edge const &T) const{return s < T.s;}
};

edge a[M];

int find(int x){
	if (x == par[x]) return x;
	return par[x] = find(par[x]);
}

LLD Kruskal(){
	int cnt = 0;
	FOE(i,1,n)
	EXP(j,l[i])
	a[cnt++] = (edge){p[i], p[qd[j]], v[i] + v[qd[j]] + qw[j]};
	sort(a, a + cnt);
	
	FOR(i,0,m) par[port[i]] = port[i];
	int x, y;
	LLD ret = 0;
	FOR(i,0,cnt){
		x = find(a[i].x);
		y = find(a[i].y);
		if (x == y) continue;
		ret += a[i].s;
		par[x] = y;
	}
	
	return ret + v[1];
}

int main(){
	scanf("%d%d", &n, &m);
	while (m--) scanf("%d%d%d", &x, &y, &w), bd(x, y, w), bd(y, x, w);
	scanf("%d", &m);
	FOR(i,0,m) scanf("%d", &port[i]);
	Dijkstra();
	printf("%I64d\n", Kruskal());
	return 0;
}
