#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>
#include<ctime>
#include<algorithm>
#include<vector>
#include<map>
#include<queue>

#define N 100005
#define LL long long 
#define INF (1ll<<60)
#define UINT unsigned int
#define MAX(a,b) ((a)>(b)?(a):(b))
#define MIN(a,b) ((a)>(b)?(b):(a))
#define sqr(x) ((x)*(x))
#define EPS 1e-8
#define MOD 1000000007
#define L(x) (x*2+1)
#define R(x) (x*2+2)

using namespace std;
struct Edge{
	int u,v;
	LL w;
	bool operator<(const Edge&a)const
	{
		return w<a.w;
	}
}ed[N];
struct node{
	int v;
	LL w;
	bool operator<(const node&a)const
	{
		return w>a.w;
	}
};
int n,m;
int root[N],parent[N];
LL dis[N];
bool flag[N];
vector<node>mp[N];
vector<Edge>e;
priority_queue<node>que;
void init()
{
	int i,j,k;
	node p;
	scanf("%d%d",&n,&m);
	for(i=0;i<m;i++)
	{
		cin>>j>>p.v>>p.w;
		mp[j].push_back(p);
		swap(j,p.v);
		mp[j].push_back(p);
	}
	scanf("%d",&j);
	for(i=0;i<j;i++)
	{
		scanf("%d",&k);
		flag[k]=1;
	}
}
void dijkstra()
{
	int i,j;
	node p;
	for(i=1;i<=n;i++)
	{
		dis[i]=flag[i]?0:INF;
		root[i]=i;
		if(flag[i])
		{
			p.v=i;
			p.w=0;
			que.push(p);
		}
	}
	while(!que.empty())
	{
		i=que.top().v;
		que.pop();
		for(j=0;j<mp[i].size();j++)
			if(dis[mp[i][j].v]>dis[i]+mp[i][j].w)
			{
				dis[mp[i][j].v]=dis[i]+mp[i][j].w;
				p.v=mp[i][j].v;p.w=dis[mp[i][j].v];
				root[p.v]=root[i];
				que.push(p);
			}
	}

}
int find(int x)
{
	if(x!=parent[x])
		parent[x]=find(parent[x]);
	return parent[x];
}
void solve()
{
	int i,j,k;
	LL ans=0;
	Edge p;
	for(i=1;i<=n;i++)
	{
		for(j=0;j<mp[i].size();j++)
		{
			p.u=root[i];
			p.v=root[mp[i][j].v];
			p.w=dis[i]+dis[mp[i][j].v]+mp[i][j].w;
			e.push_back(p);
		}
		parent[i]=i;
	}
	sort(e.begin(),e.end());
	ans=dis[1];
	for(k=0;k<e.size();k++)
	{
		i=find(e[k].u);
		j=find(e[k].v);
		if(i!=j)
			ans+=e[k].w,parent[i]=j;
	}
	cout<<ans<<endl;
}
int main()
{
	init();
	dijkstra();
	solve();
	return 0;
}
