#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<vector>
#include<cmath>
#include<algorithm>
#include<iomanip>
#include<set>
#include<map>
#include<fstream>
#include<queue>
#include<deque>
#include<utility>
#include<cstring>
#define pb push_back
#define mkp make_pair
#define X first
#define Y second
#define foR(i,a,b) for(int(i)=int(a);int(i)<int(b);++i)
typedef long long ll;
#define pii pair<long long,long long>
using namespace std;
const ll maxn=200010,inf=1e18;
vector<ll> adj[maxn],c[maxn];
vector<pair<ll,pii> > v,e;
set<pii> st;
ll p[maxn],d[maxn];
bool mark[maxn];
int find(int x){
	if(p[x]==x)
		return x;
	return p[x]=find(p[x]);
}
void un(int a,int b){
	p[find(a)]=find(b);
}
int main(){
	fill(d,d+maxn,inf);
	int n,m,k;
	cin>>n>>m;
	foR(i,0,m){
		int u,v,cst;
		cin>>u>>v>>cst;u--;v--;
		adj[u].pb(v);c[u].pb(cst);
		adj[v].pb(u);c[v].pb(cst);
		e.pb(mkp(cst,mkp(u,v)));
	}
	cin>>k;
	foR(i,0,k){
		int u;
		cin>>u;u--;
		p[u]=u;
		d[u]=0;
		mark[u]=true;
		foR(j,0,adj[u].size()){
			int next=adj[u][j];
			if(d[next]>c[u][j]){
				d[next]=c[u][j];
				p[next]=u;
			}
		}
	}
	foR(i,0,n)
		if(!mark[i])
			st.insert(mkp(d[i],i));
	while(!st.empty()){
		int x=st.begin()->Y,r=st.begin()->X;st.erase(*(st.begin()));
		mark[x]=true;
		foR(i,0,adj[x].size()){
			int next=adj[x][i];
			if(!mark[next]){
				if(d[next]>d[x]+c[x][i]){
					st.erase(mkp(d[next],next));
					d[next]=d[x]+c[x][i];
					st.insert(mkp(d[next],next));
					p[next]=x;
				}
			}
		}
	}
	foR(i,0,e.size()){
		int x=e[i].Y.X,y=e[i].Y.Y;
		if(find(x)!=find(y))
			v.pb(mkp(d[x]+d[y]+e[i].X,mkp(find(x),find(y))));
	}
	sort(v.begin(),v.end());
	ll t=0,w=0,ans=d[0];
	while(t<k-1){
		ll x=v[w].Y.X,y=v[w].Y.Y,r=v[w].X;
		if(find(x)!=find(y)){
			t++;
			un(x,y);
			ans+=r;
		}
		w++;
	}
	cout<<ans<<endl;
	return 0;
}
