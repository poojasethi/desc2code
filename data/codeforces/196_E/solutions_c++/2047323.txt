#include <iostream>
#include <vector>
#include <cstdio>
#include <cstring>
#include <set>
#include <algorithm>
#define mp make_pair
#define pb push_back
typedef long long ll;

using namespace std;
typedef pair<int,int> pii;
const int maxN=100000+5;
const ll INF=(1ll<<61);
int n,e,k,a[maxN],par[maxN];
ll d[maxN],ans;
vector<int> adj[maxN],w[maxN];
inline void dij(){
	for(int i=0 ; i<n ; i++)
		d[i]=INF;
	for(int i=0 ; i<k ; i++)
		d[a[i]]=0,par[a[i]]=i;
	set< pair<ll,int> > st;
	for(int i=0 ; i<n ; i++)
		st.insert(mp(d[i],i));
	while(!st.empty()){
		int r=st.begin()->second;
		st.erase(st.begin());
		for(int i=0 ; i<adj[r].size() ; i++){
			int tmp=adj[r][i];
			if(d[tmp]>d[r]+w[r][i]){
				st.erase(mp(d[tmp],tmp));
				d[tmp]=d[r]+w[r][i],par[tmp]=par[r];
				st.insert(mp(d[tmp],tmp));
			}
		}
	}
}
inline int root(int x){
	return (par[x]!=x)?par[x]=root(par[x]):x;
}
inline void kruskal(){
	vector< pair< ll , pii > > edge;
	for(int i=0 ; i<n ; i++)
		for(int j=0 ; j<adj[i].size() ; j++)
			if(par[i]!=par[adj[i][j]])
				edge.pb(mp(d[i]+d[adj[i][j]]+w[i][j],mp(par[i],par[adj[i][j]])));
	for(int i=0 ; i<k ; i++)
		par[i]=i;
	sort(edge.begin(),edge.end());
	for(int i=0 ; i<edge.size() ; i++){
		int tmp1=root(edge[i].second.first),tmp2=root(edge[i].second.second);
		if(tmp1!=tmp2)
			par[tmp1]=tmp2,ans+=edge[i].first;
	}
}

int main(){
	scanf("%d%d",&n,&e);
	for(int i=0 ; i<e ; i++){
		int u,v,c;
		scanf("%d%d%d",&u,&v,&c);
		u--,v--;
		adj[u].pb(v),w[u].pb(c);
		adj[v].pb(u),w[v].pb(c);
	}
	scanf("%d",&k);
	for(int i=0 ; i<k ; i++){
		scanf("%d",&a[i]);
		a[i]--;
	}
	dij();
	kruskal();
	printf("%I64d",ans+d[0]);
	return 0;
}
