#include <bits/stdc++.h>

using namespace std;

#define pb push_back
#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)
#define endl '\n'
#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)
#define mp make_pair
#define nd second
#define st first
#define type(x) __typeof(x.begin())

typedef pair < int ,int > pii;

typedef long long ll;

const long long linf = 1e18+5;
const int mod = (int) 1e9 + 7;
const int logN = 17;
const int inf = 1e9;
const int N = 2e5 + 5;

int k, cur[N], n, x, y, z, t, q, p, ok[N], ans, depth[N];
vector< int > col[N], T[N], v[N], g[N], nds[N];
set< int > S[N];
map< int, int > imp[N], root[N];

void dfs(int node, int root) {
	vector< int > gen;
	foreach(it, col[node]) {
		S[node].insert(*it);
		ok[*it] = 1;
		gen.pb(*it);
	}
	depth[node] = depth[root] + 1;
	foreach(it, v[node]) {
		if(*it == root) continue;
		dfs(*it, node);
		if(S[*it].size() > S[node].size()) swap(S[*it], S[node]);
		while(S[*it].size()) {
			if(S[node].find(*S[*it].begin()) != S[node].end()) {
				ok[*S[*it].begin()] = 1;
				gen.pb(*S[*it].begin());
			}
			S[node].insert(*S[*it].begin());
			S[*it].erase(S[*it].begin());
		}
	}
	sort(gen.begin(), gen.end());
	gen.resize(unique(gen.begin(), gen.end()) - gen.begin());
	foreach(it, gen) nds[*it].pb(node);
	foreach(it, gen) ok[*it] = 0;
	T[node] = gen;
}

void dfs2(int node, int root) {
	vector< pii > rec;
	foreach(it, T[node]) { 
		::root[*it][node] = cur[*it];
	} 
	foreach(it, T[node]) {
		rec.pb(mp(*it, cur[*it]));
		cur[*it] = node;
	} 
	foreach(it, v[node]) {
		if(*it == root) continue;
		dfs2(*it, node);	
	}	
	foreach(it, rec) {
		cur[it->st] = it->nd;
	} 
}

int solve(int node, int rt) {
	int f = 0, t = 0, tt = 0;
	int flg = imp[rt].find(node) != imp[rt].end();
	foreach(it, g[node]) {
		f = solve(*it, rt);
		if(f != -1) {
			f += depth[*it] - depth[node];
			if(!flg) { tt = f; t++; }
			if(flg) {
				if(f == 1) { ans = -inf; return -1; }
				ans++; 
			}
		}
	}
	if(flg) return 0;
	if(t > 1) { ans++; return -1; }
	if(t == 1) return tt;
	return -1;
}

int main() {

	scanf("%d", &n);

	FOR(i, 2, n) {
		scanf("%d %d", &x, &y);
		v[x].pb(y);
		v[y].pb(x);
	}	

	scanf("%d", &q);

	FOR(i, 1, q) {
		scanf("%d", &k);
		FOR(j, 1, k) {
			scanf("%d", &x);
			col[x].pb(i);
			imp[i][x] = 1;
		}
	}
	
	dfs(1, 0);
	dfs2(1, 0);

	FOR(i, 1, q) {
		vector< int > qqq;
		foreach(it, nds[i])	{
			int rt = root[i][*it];
			g[rt].pb(*it);
			qqq.pb(*it);
			qqq.pb(rt);
		}
		ans = 0;
		solve(0, i);
		if(ans < 0) ans = -1;
		printf("%d\n", ans);
		foreach(it, qqq)
			g[*it].clear();
	}

	return 0;
}
