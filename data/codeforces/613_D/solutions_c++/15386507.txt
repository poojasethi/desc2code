

#include<iostream>
#include<set>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<map>
#include<vector>
using namespace std;

const int N = 100000 + 10;
const int LOG = 20;

int n;
vector<int> adj[N];
int order[N], tot;
int depth[N], father[N][LOG];
int mark[N], f[N];
int parent[N];

void dfs(int u)
{
	order[u] = tot ++;
	for(int e = 0; e < adj[u].size(); ++ e) {
		int v = adj[u][e];
		if (v == father[u][0]) continue;
		depth[v] = depth[u] + 1;
		father[v][0] = u;
		dfs(v);
	}
}

int jump(int u, int d)
{
	for(int i = 0; d; d >>= 1, ++ i) {
		if (d & 1) {
			u = father[u][i];
		}
	}
	return u;
}

int getLCA(int u, int v)
{
	if (depth[u] < depth[v]) swap(u, v);
	u = jump(u, depth[u] - depth[v]);
	if (u == v) return u;
	for(int i = LOG - 1; i >= 0; -- i) {
		if (father[u][i] != father[v][i]) {
			u = father[u][i];
			v = father[v][i];
		}
	}
	return father[u][0];
}

int cmp(const int &a, const int &b)
{
	return order[a] < order[b];
}

void query()
{
	int m;
	scanf("%d", &m);
	vector<int> ps;
	for(int i = 0; i < m; ++ i) {
		int u;
		scanf("%d", &u);
		--u;
		ps.push_back(u);
		mark[u] = true;
	}
	for(int i = 0; i < m; ++ i) {
		int u = ps[i];
		if (father[u][0] != u && mark[father[u][0]]) {
			for(int j = 0; j < m; ++ j) {
				int u = ps[j];
				mark[u] = false;
			}
			printf("-1\n");
			return;
		}
	}

	sort(ps.begin(), ps.end(), cmp);
	for(int i = 1; i < m; ++ i) {
		ps.push_back(getLCA(ps[i], ps[i - 1]));
	}
	sort(ps.begin(), ps.end(), cmp);
	ps.erase(unique(ps.begin(), ps.end()), ps.end());

	vector<int> chain;
	parent[ps[0]] = -1;
	chain.push_back(ps[0]);

	for(int i = 1; i < ps.size(); ++ i) {
		int u = ps[i];
		int lca = getLCA(chain.back(), u);
		for( ; depth[chain.back()] > depth[lca]; ) chain.pop_back();
		parent[u] = chain.back();
		chain.push_back(u);
	}

	int ret = 0;
	for(int i = 0; i < ps.size(); ++ i) {
		f[ps[i]] = mark[ps[i]];
	}
	for(int i = (int)ps.size() - 1; i >= 0; -- i) {
		int u = ps[i];
		if (mark[u]) {
			if (parent[u] >= 0 && mark[parent[u]]) {
				++ ret;
				f[u] = 0;
			}
		} else {
			int tmp = f[u];
			if (parent[u] >= 0) {
				tmp += mark[parent[u]];
			}
			if (tmp >= 2) {
				++ ret;
				f[u] = 0;
			}
		}
		if (parent[u] >= 0) {
			f[parent[u]] += f[u];
		}
	}

	printf("%d\n", ret);

	for(int i = 0; i < ps.size(); ++ i) {
		int u = ps[i];
		mark[u] = false;
	}
}

void solve()
{
	cin >> n;
	for(int i = 0; i < n - 1; ++ i) {
		int u, v;
		scanf("%d%d", &u, &v);
		--u, --v;
		adj[u].push_back(v);
		adj[v].push_back(u);
	}
	father[0][0] = -1;
	dfs(0);
	father[0][0] = 0;
	for(int i = 1; i < LOG; ++ i) {
		for(int j = 0; j < n; ++ j) {
			father[j][i] = father[father[j][i - 1]][i - 1];
		}
	}

	int q;
	cin >> q;
	for( ; q --; ) {
		query();
	}
}

int main()
{
	solve();
	return 0;
}
