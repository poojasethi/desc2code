#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
#include"vector"
#include"queue"
#include"stack"
#include"list"
#include"set"
#include"map"
#define LL long long
#define PII pair<int,int>
#define PPI pair<PII,int>
#define PIP pair<int,PII>
#define PPP pair<PII,PII>
#define X first
#define Y second
#define INF 1000000000
#define FOR(a,b,c) for(int a=b;a<=c;a++)
#define FO_(a,b,c) for(int a=b;a>=c;a--)
#define REP(i,u,v) for(int i=H[u],v=to[i];i;i=nxt[i],v=to[i])
using namespace std;
const int N = 200100;

int H[N],to[N],nxt[N],e;
void addedge(int t,int v) {
	e++, to[e]=v, nxt[e]=H[t], H[t]=e;
	e++, to[e]=t, nxt[e]=H[v], H[v]=e;
}
int fa[N],dep[N],size[N],son[N];
void init_(int u,int f) {
	fa[u]=f;
	dep[u]=dep[f]+1;
	size[u]=1;
	REP(i,u,v) if(v!=f) {
		init_(v,u);
		size[u]+=size[v];
		if(size[v]>size[son[u]])
			son[u]=v;
	}
}
int id[N],end[N],tp[N],cnt;
void Build(int u,int top) {
	tp[u]=top;
	id[u]=++cnt;
	if(son[u])
		Build(son[u],top);
	REP(i,u,v) if(v!=fa[u]&&v!=son[u]) {
		Build(v,v);
	}
	end[u]=cnt+1;
}
int Lca(int u,int v) {
	while(tp[u]!=tp[v]) {
		if(dep[tp[u]]<dep[tp[v]]) swap(u,v);
		u=fa[tp[u]];
	}
	return dep[u]<dep[v]? u: v;
}

bool judge_fa(int u,int v) {
	return id[u]<=id[v]&&end[v]<=end[u];
}
bool cmp(int x,int y) {
	return id[x]<id[y];
}
vector<int> ch[N];
int val[N],imp[N],pow[N];
int dp0[N],dp1[N];
void get_ans(int k) {
	int n=(int)ch[k].size()-1;
	FOR(i,0,n) get_ans(ch[k][i]);
	if(imp[k]) {
		FOR(i,0,n) dp0[k]+=dp1[ch[k][i]];
		dp1[k]=dp0[k]+1;
	} else {
		int res=0;
		FOR(i,0,n) res+=dp1[ch[k][i]];
		int ans=1;
		FOR(i,0,n) ans+=dp0[ch[k][i]];
		int dec=0;
		FOR(i,0,n) dec=max(dec,dp1[ch[k][i]]-dp0[ch[k][i]]);
		dp0[k]=min(ans,res-dec);
		dp1[k]=min(ans,res);
	}
}
void solve() {
	//read
	int _;
	cin>>_;
	FOR(i,1,_) scanf("%d",val+i);
	FOR(i,1,_) imp[val[i]]=1;
	//judge_invalid
	FOR(i,1,_) if(imp[fa[val[i]]]) {
		FOR(j,1,_) imp[val[j]]=0;
		puts("-1");
		return;
	}
	//get_node
	FOR(i,1,_) pow[i]=val[i];
	sort(val+1,val+_+1,cmp);
	FOR(i,1,_-1) val[_+i]=Lca(val[i],val[i+1]);
	sort(val+1,val+_+_,cmp);
	int __=unique(val+1,val+_+_)-val-1;
	//get_tree
	stack<int> s;
	s.push(val[1]);
	FOR(i,2,__) {
		while(!judge_fa(s.top(),val[i])) s.pop();
		ch[s.top()].push_back(val[i]);
		s.push(val[i]);
	}
	//get_ans
	get_ans(val[1]);
	cout<<dp0[val[1]]<<endl;
	//clear
	FOR(i,1,__) ch[val[i]].clear();
	FOR(i,1,__) dp0[val[i]]=dp1[val[i]]=0;
	FOR(i,1,_) imp[pow[i]]=0;
}
int main() {
	int n;
	cin>>n;
	FOR(i,2,n) {
		int t,v;
		scanf("%d%d",&t,&v);
		addedge(t,v);
	}
	int m;
	cin>>m;
	init_(1,0);
	Build(1,1);
	while(m--)
		solve();
	return 0;
}