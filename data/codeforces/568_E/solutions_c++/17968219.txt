#include <cstdio>
#include <algorithm>
#include <iostream>
#include <vector>

#define vi std::vector<int>
#define pb push_back

#define DEBUG(...) fprintf(stderr, __VA_ARGS__)
#define REP(i, x, y) for (int i = x, _ = y; i <= _; i ++)
#define rep(i, x, y) for (int i = x, _ = y; i >= _; i --)

template <typename T> bool Chkmax(T &x, T y) { return x < y? x = y, true : false; }
template <typename T> bool Chkmin(T &x, T y) { return y < x? x = y, true : false; }
template <typename T> void Readin(T &x)
{
    x = 0;
    int c = getchar(), k = 1;
    for (; '0' >  c || c >  '9'; c = getchar())
        if (c == '-')
            k = -1;
    for (; '0' <= c && c <= '9'; c = getchar())
        x = x * 10 + c - '0';
    x *= k;
}

const int MAXN = 1e5 + 1e3, MAXM = MAXN, oo = 0x3f3f3f3f;

int n, m;
int a[MAXN], b[MAXM], g[MAXN], ans[MAXN];
int last[MAXN], pos[MAXN];
int best[MAXN];
int used[MAXM];
vi s[MAXN];

void Print()
{
    int p = 0, lastans = -1;
    
    REP (i, 1, n)
        if (best[i] > best[p])
            p = i;

    rep (i, n, 1) {
        if (a[i] != -1) {
            ans[i] = a[i];
            
            if (p == i) {
                lastans = ans[i], p = last[i];
                best[p] = best[i] - 1;
            }
            
        } else {
            if (p != i)
                ans[i] = -1;
            else {
                if (best[i] == 1) {
                    ans[i] = b[1];
                    used[1] = true; // Don't forget this 'used[...] = true';
                    p = 0;
                    continue;
                }
                
                int j, p0;
                const vi &tmp = s[best[i] - 1];
                for (j = 0; j < tmp.size(); j ++) {
                    if (tmp[j] >= i)
                        continue;
                    
                    p0 = std::upper_bound(b + 1, b + m + 1, a[tmp[j]]) - b;
                    if (p0 != m + 1 && (lastans == -1 || b[p0] < lastans)) {
                        ans[i] = b[p0];
                        used[p0] = true;
                        break;
                    }
                }
                
                if (j != tmp.size()) {
                    lastans = ans[i], p = tmp[j];
                    continue;
                }

                p0 = lastans == -1? m : (std::lower_bound(b + 1, b + m + 1, lastans) - b - 1);
                ans[i] = b[p0];
                used[p0] = true;

                lastans = ans[i];
                do
                    -- p;
                while (a[p] != -1);
                best[p] = best[i] - 1;
            }
         }
    }

    p = 1;
    
    //REP (i, 1, n)
    //  printf(i == n? "%d\n" : "%d ", best[i]);
    
    
    REP (i, 1, n)
        if (ans[i] == -1) {
            while (used[p])
                p ++;
            ans[i] = b[p];
            used[p] = true; // Again.
        }
    
    REP (i, 1, n)
        printf(i == n? "%d\n" : "%d ", ans[i]);
}

void Solve()
{
    g[0] = 0;
    REP (i, 1, n)
        g[i] = oo;

    REP (i, 1, n) {
        if (a[i] != -1) {
            int p = std::lower_bound(g, g + n + 1, a[i]) - g;
            last[i] = pos[p - 1];
            g[p] = a[i];
            pos[p] = i;
            best[i] = p;
            s[p].pb(i);
        } else {
            int p = n;
            while (g[p - 1] >= b[m])
                p --;
            best[i] = p; // best[i] should be gotten there;
            rep (j, m, 1) {
                while (g[p - 1] >= b[j])
                    p --;
                g[p] = b[j];
                pos[p] = i;
            }
            // printf("best %d: %d\n", i, p);
        }
    }
}

void Init()
{
    Readin(n);
    REP (i, 1, n)
        Readin(a[i]);

    Readin(m);
    REP (i, 1, m)
        Readin(b[i]);

    std::sort(b + 1, b + m + 1);
}

int main()
{
    if (fopen("E.in", "r") != NULL) {
        freopen("E.in", "r", stdin);
        freopen("E.out", "w", stdout);
    }

    Init();
    Solve();
    Print();
    
    return 0;
}

                                                                                                                                                                                                                                                                                    