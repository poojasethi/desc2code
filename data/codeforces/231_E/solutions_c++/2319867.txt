#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <map>
#include <set>
#include <list>
#include <vector>
#include <queue>
#include <string>
using namespace std;

#define FOR(i,a,b) for (int i = a; i < b; ++i)
#define LL long long
#define U unsigned
#define V vector
#define VI V <int>
#define VVI V <VI>
#define pb(x) push_back(x)
#define sz size()
#define IT iterator
#define PII pair <int, int>
#define mp make_pair
#define x first
#define y second
template <class T>
T sqr (T x) {return x*x;}

list <int> a[100000];
list <int> b[100000];
int col[100000];
int ccol[100000];
char z[100000];
int kcol = 0;
int st [100000], sts = 0;

void dfs (int v, int p)
{
	st[sts++] = v;
	z[v] = 0;
	for (list<int>::IT it = a[v].begin(); it!= a[v].end(); ++it)
	{
		int i = *it;
		if (i == p) continue;
		if (z[i] == 0)
		{
			for (int j = sts - 1; st[j] != i; --j)
				col[st[j]] = kcol;
			col[i] = kcol++;
		}
		if (z[i] == 1) dfs(i,v);
	}
	sts--;
	z[v] = 2;
}

int pt[100000];
int ko[100000];
int hh[100000];

void dfs2 (int v, int p)
{
	pt[v] = p;
	ko[v] = (ccol[v] > 1);
	if (p != -1) ko[v] += ko[p], hh[v] = hh[p] + 1;
	else hh[v] = 0;
	
	for (list<int>::IT it = b[v].begin(); it != b[v].end(); ++it)
		if (*it != p) dfs2(*it,v);
}

int mod = 1000000007;

int powr(int x, int n)
{
	LL r = 1, b = x;
	while(n)
	{
		if (n&1) r *= b;
		b *= b;
		r %= mod;
		b %= mod;
		n>>=1;
	}
	return int(r%mod);
}

int lca(int x, int y)
{
	int h1 = hh[x];
	int h2 = hh[y];
	while (h1 < h2)
		y = pt[y], --h2;
	while (h2 < h1)
		x = pt[x], --h1;
	while (x != y)
		x = pt[x], y = pt[y];
	return x;
}

int main()
{
	int n,m,x,y;
	cin >> n >> m;
	FOR(i,0,m)
	{
		cin >> x >> y;
		--x, --y;
		a[x].pb(y);
		a[y].pb(x);
	}
	FOR(i,0,n) z[i] = 1;
	FOR(i,0,n) col[i] = -1, ccol[i] = 0;
	FOR(i,0,n) if (z[i] == 1) dfs(i, -5);
	FOR(i,0,n) if (col[i] == -1) col[i]=kcol++;
	FOR(i,0,n) ccol[col[i]]++;
	
	FOR(i,0,n)
		for (list <int>::IT it = a[i].begin(); it != a[i].end(); ++it)
			if (col[i] != col[*it])
			{
				b[col[i]].pb(col[*it]);
			}
	dfs2(0, -1);
	
	int k;
	cin >> k;
	FOR(i,0,k)
	{
		cin >> x >> y;
		x = col[x - 1], y = col[y - 1];
		int p = 0;
		int l = lca(x,y);
		p = ko[x] + ko[y] - 2*ko[l] + (ccol[l] > 1);
		
		cout << powr(2,p) << endl;
	}
	return 0;
}
