#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <cmath>
#include <vector>
#include <cstdlib>
#include <utility>
#include <memory.h>
#include <cassert>
#include <iterator>
#include <bitset>
#include <iomanip>
#include <complex>
#include <queue>
#include <ctime>
#include <deque>
#include <stack>
#include <set>
#include <map>
 
using namespace std;
 
#define pb push_back
#define mp make_pair
#define F first
#define S second

const int INF = (int)2e9;
const int N = 300 * 300 + 2;

int dist(int a, int b, int c, int d) {
	return abs(a - c) + abs(b - d);
}

int n, m, p;
vector<int> tt;
vector<int> f[N];
vector< pair<int, int> > g[N];

int main() {
	srand(time(NULL));
	scanf("%d%d%d", &n, &m, &p);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			int val;
			scanf("%d", &val);
			g[val].pb(mp(i, j));
			f[val].pb(INF);
		}
	}
	for (int i = 0; i <= p; i++) {
		random_shuffle(g[i].begin(), g[i].end());
	}
	vector< pair<int, int> > pt;
	for (int i = 0; i < (int)g[1].size(); i++) {
		f[1][i] = dist(1, 1, g[1][i].F, g[1][i].S);
		pt.pb(mp(f[1][i], i));
	}
	sort(pt.begin(), pt.end());
	for (int i = 0; i < (int)g[1].size(); i++) {
		tt.pb(pt[i].S);
	}
	for (int i = 2; i <= p; i++) {
		for (int j2 = 0; j2 < (int)g[i].size(); j2++) {
			int len = min((int)g[i - 1].size(), 2 * (n + m));
			for (int ii = 0; ii < len; ii++) {
				int j1 = tt[ii];
				if (f[i - 1][j1] > f[i][j2]) {
					break;
				}
				f[i][j2] = min(f[i][j2], f[i - 1][j1] + dist(g[i][j2].F, g[i][j2].S, g[i - 1][j1].F, g[i - 1][j1].S));
			}
		}
		tt.clear();
		vector< pair<int, int> > ttt;
		for (int j = 0; j < (int)g[i].size(); j++) {
			ttt.pb(mp(f[i][j], j));
		}
		sort(ttt.begin(), ttt.end());
		for (int j = 0; j < ttt.size(); j++) {
			tt.pb(ttt[j].S);
		}
	}
	printf("%d\n", f[p][0]);
	return 0;
}