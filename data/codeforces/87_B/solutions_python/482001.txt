#!/usr/bin/env python2
# -*- coding: utf-8 -*-
import sys
input = sys.stdin
output = sys.stdout

TYPEDEF = 1
TYPEOF = 2

ERRTYPE = -1

VOID = 'void'

def parse_declaration(decl):
    type_shift = 0
    s = decl
    sp = s.rstrip('*')
    type_shift += len(s) - len(sp)
    sa = sp.lstrip('&')
    type_shift -= len(sp) - len(sa)
    symbol = sa
    return (symbol,type_shift)

def typeof(decl,symbols):
    symbol,type_shift = parse_declaration(decl)
    if symbol == VOID:
        if type_shift < 0:
            return ERRTYPE
        else:
            return type_shift
    elif symbol in symbols:
        type = symbols[symbol]
        if type < 0:
            return ERRTYPE
        elif type + type_shift < 0:
            return ERRTYPE
        else:
            return type + type_shift
    else:
        return ERRTYPE

def apply_typedef(decl,name,symbols):
    symbols[name] = typeof(decl,symbols)

def solve(operators):
    types_resolved = []
    symbols = {} # name => type
#    i = 0
    for op in operators:
#        i += 1
#        print i,'::','='*60
#        print ':: Processing:', op
        op_type = op[0]
        if op_type == TYPEDEF:
            apply_typedef(op[1], op[2], symbols)
        elif op_type == TYPEOF:
            type = typeof(op[1], symbols)
            types_resolved.append(type)
#        print symbols
    return types_resolved

n = int(input.readline())
assert 1<=n and n<=100

operators = []
for i in range(n):
    S = [s.strip() for s in input.readline().split(' ')]
    op = S[0]
    if op == 'typedef':
        assert len(S) == 3
        operators.append((TYPEDEF,S[1],S[2]))
    elif op == 'typeof':
        assert len(S) == 2
        operators.append((TYPEOF,S[1]))
    else:
        assert False, 'Invalid operator'

types = solve(operators)

def format_type(t):
    if t<0:
        return 'errtype'
    else:
        return 'void' + '*'*t

for t in types:
    output.write('%s\n' % format_type(t))
