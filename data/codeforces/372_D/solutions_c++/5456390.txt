#include<bits/stdc++.h>
using namespace std;

#define pb push_back
#define mp make_pair
#define fr first
#define sc second

const int Maxn=1e5+5;
int n,k,jmp[20][Maxn],dep[Maxn],intime[Maxn],tot=0;
vector<int> edge[Maxn];
set< pair<int,int> > tree;

int liftup(int v,int d)
{
	for(int i=19;i>=0;i--)
	  if(dep[jmp[i][v]]>=d)
		v=jmp[i][v];
	return v;
}

int getLca(int v,int u)
{
	if(dep[v]<dep[u])
	  swap(v,u);
	v=liftup(v,dep[u]);
	if(u==v)
	  return v;
	for(int i=19;i>=0;i--)
	  if(jmp[i][v]!=jmp[i][u])
		v=jmp[i][v],u=jmp[i][u];
	return jmp[0][v];
}

void dfs(int v,int fa)
{
	intime[v]=++tot;
	if(v==fa)
	{
		jmp[0][v]=v;
		dep[v]=0;
	}
	else dep[v]=dep[fa]+1,jmp[0][v]=fa;
	for(int i=1;i<20;i++)
	  jmp[i][v]=jmp[i-1][jmp[i-1][v]];
	int sz=edge[v].size();
	for(int i=0;i<sz;i++)
	  if(edge[v][i]!=fa)
		dfs(edge[v][i],v);
}

int cal(int v)
{
	if(tree.empty())
	  return 1;
	int root=getLca(tree.begin()->sc,tree.rbegin()->sc);
	if(getLca(v,root)!=root)
	  return dep[v]+dep[root]-2*dep[getLca(v,root)];
	else
	{
		typeof(tree.begin()) it=tree.lower_bound(mp(intime[v],v));
		if(it!=tree.end()&&getLca(v,it->sc)==v)
		  return 0;
		int ret=n;
		if(it!=tree.end())
		  ret=min(ret,dep[v]-dep[getLca(v,it->sc)]);
		if(it!=tree.begin())
		{
			it--;
			ret=min(ret,dep[v]-dep[getLca(v,it->sc)]);
		}
		return ret;
	}
}

int main()
{
	scanf("%d%d",&n,&k);
	for(int i=0;i<n-1;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		edge[u].pb(v);
		edge[v].pb(u);
	}
	dfs(1,1);
	
	int ans=1,curs=0;
	for(int l=1,r=1;l<=n;l++)
	{
		while(r<=n)
		{
			if(curs+cal(r)<=k)
			{
				curs+=cal(r);
				tree.insert(mp(intime[r],r));
			    r++;
			}
			else
			  break;
		}
		ans=max(ans,r-l);
		tree.erase(mp(intime[l],l));
		curs-=cal(l);
	}

	printf("%d\n",ans);
	return 0;
}
