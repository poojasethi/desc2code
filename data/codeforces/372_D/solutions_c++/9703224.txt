#include <iostream>
#include <vector>
#include <set>

using namespace std;

typedef set<int>::iterator sit;

const int MAXN = 1e5 + 10, MAXLG = 20;

vector<int> ng[MAXN];

int stTime[MAXN], par[MAXLG][MAXN], d[MAXN], timeV[MAXN];

int dfsTime;
void dfs(int x, int p, int depth) {
	stTime[x] = dfsTime++;
	timeV[stTime[x]] = x;
	par[0][x] = p;
	d[x] = depth;
	for (int i = 0; i < ng[x].size(); i++) {
		int u = ng[x][i];
		if (u != p)
			dfs(u, x, depth + 1);
	}
}

int getPar(int x, int k) {
	for (int i = 0; x != -1 && i < MAXLG; i++)
		if (k & (1 << i))
			x = par[i][x];
	return x;
}

int getLca(int x, int y) {
	if (d[x] > d[y])
		swap(x, y);
	y = getPar(y, d[y] - d[x]);
	if (x == y)
		return x;
	for (int i = MAXLG - 1; i >= 0; i--)
		if (par[i][x] != par[i][y])
			x = par[i][x], y = par[i][y];
	return par[0][x];
}

int getDist(int x, int y) {
	return d[x] + d[y] - 2 * d[getLca(x, y)];
}

set<int> avs;

int treeSize;
void adjust(int x, bool add) {
	x = stTime[x];
	if (add)
		avs.insert(x);
	sit nx = avs.lower_bound(x);
	sit prv = nx;
	nx++;
	if (nx == avs.end())
		nx = avs.begin();
	if (prv == avs.begin())
		prv = avs.end();
	prv--;
	if (!add)
		avs.erase(x);
	int u = timeV[*prv], v = timeV[*nx]; x = timeV[x];
	int delta = getDist(x, u) + getDist(x, v) - getDist(v, u);
	delta /= 2;
	treeSize += add ? delta : -delta;
}

int main() {
	int n, k;
	cin >> n >> k;
	for (int i = 0; i < n - 1; i++) {
		int a, b;
		cin >> a >> b;
		a--; b--;
		ng[a].push_back(b);
		ng[b].push_back(a);
	}
	dfs(0, -1, 0);
	for (int j = 1; j < MAXLG; j++)
		for (int i = 0; i < n; i++)
			par[j][i] = par[j - 1][i] == -1 ? -1 : par[j - 1][par[j - 1][i]];
	int r = 0, ans = 0;
	for (int l = 0; l < n; l++) {
		while (r < n && treeSize < k)
			adjust(r, true), r++;
		if (treeSize >= k)
			adjust(r - 1, false), r--;
		ans = max(ans, r - l);
		adjust(l, false);
	}
	cout << ans << endl;
	return 0;
}
