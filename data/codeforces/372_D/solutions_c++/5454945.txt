#include <cstdio>
#include <algorithm>
#include <vector>
#include <set>
#include <cmath>
using namespace std;

const int N = 1e5 +7;

int n, k, lg;
int lv[N], f[N], nn;
int p[20][N + N];
vector <int> adj[N];


struct cmp {
  bool operator () (const int &a, const int &b) const {
    return f[a] < f[b];
  }
};

set <int, cmp> s;

inline void dfs(int u, int par = 0) {
  p[0][++nn] = u;
  f[u] = nn;
  lv[u] = lv[par] + 1;
  for (int i = 0; i < adj[u].size(); i++) {
    int v = adj[u][i];
    if (v != par) {
      dfs(v, u);
      p[0][++nn] = u;
    }
  }
}

inline int lca(int u, int v) {
  if (f[u] > f[v]) return lca(v, u);
  u = f[u], v = f[v];
  int k = log(v - u + 1) / log(2);
  return lv[p[k][u]] < lv[p[k][v - (1 << k) + 1]]
    ? p[k][u]
    : p[k][v - (1 << k) + 1];
}

inline int cal(int u) {
  int l, r;
  set <int> :: iterator it = s.lower_bound(u);
  if (it == s.end() || it == s.begin()) r = *s.begin(), l = *--s.end();
  else r = *it, l = *--it;
  return lv[u] - lv[lca(u, l)] - lv[lca(u, r)] + lv[lca(l, r)];
}

int main() {
  scanf("%d %d", &n, &k);
  for (lg = 1; 1 << lg <= 2 * n; lg++); lg--;
  for (int i = 1; i < n; i++) {
    int u, v;
    scanf("%d %d", &u, &v);
    adj[u].push_back(v);
    adj[v].push_back(u);
  }
  dfs(1);
  
  for (int k = 0; k < lg; k++) 
    for (int i = 1; i <= nn; i++) 
      p[k + 1][i] = i + (1 << k) <= nn and lv[p[k][i + (1 << k)]] < lv[p[k][i]]
	? p[k][i + (1 << k)]
	: p[k][i];
  
  s.insert(1), s.insert(2);
  int cnt = lv[1] + lv[2] - 2 * lv[lca(1, 2)] + 1;
  int ans = cnt <= k? 2: 1;
  int l = 1, r = 3;
  while (r <= n) {
    cnt += cal(r);
    s.insert(r);
    while (l <= r - 2 && cnt > k) {
      s.erase(l);
      cnt -= cal(l);
      l++;
    }
    if (cnt <= k) ans = max(ans, r - l + 1);
    r++;
  }
  printf("%d\n", ans);
}
