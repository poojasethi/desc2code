#include <cstdio>
#include <cstring>
#include <algorithm>
#include <set>

using namespace std;

const int MaxN = 100010;

struct Node{
	int v;
	Node *next;
}*g[MaxN],pool[MaxN*2],*tail=pool;
int n,k;
int num[MaxN],por[MaxN],fa[MaxN],last;
int h[MaxN],f[20][MaxN];
int sum=0;
set<int> base;

void make_edge(int u,int v){
	tail->v=v;tail->next=g[u];g[u]=tail++;
	tail->v=u;tail->next=g[v];g[v]=tail++;
}
void dfs(int u,int father){
	f[0][u]=fa[por[num[u]=++last]=u]=father;
	for(Node *p=g[u];p;p=p->next) if(!num[p->v]) h[p->v]=h[u]+1,dfs(p->v,u);
}
int lca(int u,int v){
	if(h[u]<h[v]) swap(u,v);
	for(int k=h[u]-h[v],j=19;j>=0;j--) if(k&(1<<j)) u=f[j][u];
	if(u==v) return u;
	for(int j=19;fa[u]!=fa[v];u=f[j][u],v=f[j][v])
		for(;j && f[j][u]==f[j][v];j--);
	return fa[u];
}
void modify(int u,int t){
	set<int> :: iterator p=base.lower_bound(num[u]);
	if(*p==num[u]) base.erase(p),p=base.lower_bound(num[u]);
	if(base.empty()){if(t) base.insert(num[u]);return;}
	int r=por[p==base.end() ? *base.begin() : *p];
	int l=por[p==base.begin() ? *--base.end() : *--p];
	int dt=h[u]-h[lca(l,u)]-h[lca(r,u)]+h[lca(l,r)];
	if(t) sum+=dt,base.insert(num[u]); else sum-=dt;
}
int check(int p){
	sum=0;base.clear();
	for(int i=1;i<p;i++) modify(i,1);
	for(int i=p;i<=n;i++){
		modify(i,1);
		if(sum<k) return 1;
		modify(i-p+1,0);
	}
	return 0;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<n;i++){
		int a,b;scanf("%d%d",&a,&b);
		make_edge(a,b);
	}
	dfs(1,0);por[num[n+1]=n+1]=n+1;
	for(int i=1;i<20;i++)
		for(int j=1;j<=n;j++)
			f[i][j]=f[i-1][f[i-1][j]];
	int l=1,r=n+1;
	while(l+1<r){
		int mid=l+r >> 1;
		if(check(mid)) l=mid; else r=mid;
	}
	printf("%d\n",l);
	return 0;
}
