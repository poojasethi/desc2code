#include <set>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#define S (t.begin())
#define E (Dt = t.end(), --Dt)
#define element set <int, compare> :: iterator 
using namespace std;

typedef int arr32[200010];

arr32 c, next, g, d, st;
int f[200010][20];
int n, k, sz, size, ap = 1, dE;

struct compare  {
	bool operator () (const int &a, const int &b)  {
		return st[a] < st[b];
	}
};
set <int, compare> t;
set <int, compare> :: iterator At, Bt, Ct, Dt;

void link(int x, int y)  {
	c[++ap] = y, next[ap] = g[x], g[x] = ap;
	c[++ap] = x, next[ap] = g[y], g[y] = ap;
}
int lca(int x, int y)  {
	if (x == y)  return x;
	if (d[x] < d[y])  swap(x, y);
	for (int i = 18; i >= 0; --i)
		if (((d[x] - d[y]) >> i) & 1)
			x = f[x][i];
	if (x == y)  return x;
	for (int i = 18; i >= 0; --i)
		if (f[x][i] != f[y][i])
			x = f[x][i], y = f[y][i];
	return f[x][0];
}
void dfs(int z, int ft)  {
	f[z][0] = ft;  d[z] = d[ft] + 1;  st[z] = ++dE;
	for (int i = 0; f[z][i]; ++i)
		f[z][i + 1] = f[f[z][i]][i];
	for (int x = g[z]; x; x = next[x])
		if (c[x] != ft)  dfs(c[x], z);
}
int dist(int z)  {
	if (sz == 1)  return 1;
	Bt = At = t.find(z);
	if (At == S)  ++Bt, Ct = E;
	else  if (At == E)  --Bt, Ct = S;
	else  Bt = S, Ct = E;
	int x = lca(*Bt, *Ct), y, D = n;  Bt = At;
	if (At != S)  y = lca(*(--Bt), *At), D = min(D, max(d[z] - d[y], 0) + max(d[x] - d[y], 0)), ++Bt;
	if (At != E)  y = lca(*(++Bt), *At), D = min(D, max(d[z] - d[y], 0) + max(d[x] - d[y], 0)), --Bt;
	return D;
}
int main()  {
	//freopen("D.in", "r", stdin);
	//freopen("D.out", "w", stdout);

	int x, y;
	
	scanf("%d %d", &n, &k);
	for (int i = 2; i <= n; ++i)  {
		scanf("%d %d", &x, &y);
		link(x, y);
	}
	dfs(1, 0);

	int He = 1, ans = 0;
	for (int i = 1; i <= n; ++i)  {
	  t.insert(i);  ++sz;
		size += dist(i);

		while (size > k)  {
			size -= dist(He);
			t.erase(He++);  --sz;
		}
		ans = max(ans, sz);
	}

	printf("%d\n", ans);
}
