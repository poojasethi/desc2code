#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <string>
#include <cstring>
#include <vector>
#include <cassert>
#include <map>
using namespace std;

int INF = 1000000000;
typedef long long LL;

#define rep(a,n) for (int (a)=0;(a)<(n);++(a))
#define forn(a,b,c) for (int (a)=(b);(a)<=(c);++(a))
#define reset(a,b) memset(a,b,sizeof(a))
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define all(v) v.begin(),v.end()

LL bit[1000010][2];
vector<int> angka;
map<int,int> pos;
int n,q,data[100010];
pair<int,pair<LL,int> > query[100010];

void BITupdate(int x,LL y,int type)
{
	for (;x < (int)angka.size(); x += (x & -x))
		bit[x][type] += y;
}

LL BITquery(int x,int type)
{
	LL res = 0;
	for (;x > 0; x -= (x & -x))
		res += bit[x][type];
	return res;
}

int main()
{
	scanf("%d %d",&n,&q);
	rep(i,n)
	{
		scanf("%d",&data[i]);
		angka.pb(data[i]);
	}
	rep(i,q)
	{
		scanf("%d",&query[i].fi);
		if (query[i].fi == 1)
		{
			scanf("%d %d",&query[i].se.fi,&query[i].se.se);
			--query[i].se.fi;
			angka.pb(query[i].se.se);
		} else scanf("%I64d",&query[i].se.fi);
	}
	angka.pb(-1);
	sort(all(angka));
	angka.erase(unique(all(angka)),angka.end());
	rep(i,angka.size()) pos[angka[i]] = i;
	rep(i,n)
	{
		BITupdate(pos[data[i]],data[i],0);
		BITupdate(pos[data[i]],1,1);
	}
	//rep(i,4) printf("%d\n",BITquery(i,1));
	rep(i,q)
	{
		if (query[i].fi == 1)
		{
			LL hapus = data[query[i].se.fi];
			BITupdate(pos[hapus],-hapus,0);
			BITupdate(pos[hapus],-1,1);
			BITupdate(pos[query[i].se.se],query[i].se.se,0);
			BITupdate(pos[query[i].se.se],1,1);
			data[query[i].se.fi] = query[i].se.se;
		} else
		{
			double L = 0;
			double R = 1e15;
			double res = -1;
			while (R - L > 1e-5)
			{
				double M = (L + R) / 2;
				//printf("%d %.9lf %.9lf %.9lf\n",i,L,M,R);
				LL temp = (LL)floor(M);
				int x = upper_bound(all(angka),temp) - angka.begin() - 1;
				LL tot = BITquery(x,0);
				int ada = BITquery(x,1);
				//printf("%.2lf %lld %lld %d %d\n",M,ada,tot,temp,x);
				if (M * ada - tot >= query[i].se.fi)
				{
					res = M;
					R = M;
				} else L = M;
			}
			printf("%.6lf\n",res);
		}
	}
	return 0;
}













