#include <algorithm>
#include <string>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <cassert>
#include <queue>
#include <cstdlib>
#include <set>
#include <map>
#include <stack>
#include <cmath>
#include <ctime>

#define st first
#define nd second
#define mp make_pair
#define pb push_back
#define lli long long int
#define all( gg )	gg.begin(),gg.end()
#define foreach( gg,itit )	for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )
#define FP( ii,aa,bb ) for( int ii=aa;ii<=bb;ii++ )
#define FM( ii,aa,bb ) for( int ii=aa;ii>=bb;ii-- )

using namespace std;

class fenwick{
	public:
		lli F[300000];
		fenwick(){
			memset( F,0,sizeof F );
		}
		void update( int x,lli val ){
			while( x<=250000 ){
				F[x] += val;
				x += x&-x;
			}
		}
		lli query( int x ){
			lli res=0;
			while( x ){
				res += F[x];
				x -= x&-x;
			}
			return res;
		}
}A,S;

int n,m;
lli arr[200000];
map<lli,int>	yer;
pair< lli,pair<lli,lli> >	q[200000];

int f( double x ){
	x -= 1e-8;
	x = ceil(x);
	return yer.lower_bound( (lli)x ) -> nd;
}
 
int main(){

	cin >> n >> m;
	FP( i,1,n ){
		scanf("%lld",arr+i);
		yer[arr[i]]=1;
	}
	FP( i,1,m ){
		scanf("%lld",&q[i].st);
		if( q[i].st==1 ){
			scanf("%lld %lld",&q[i].nd.st,&q[i].nd.nd);
			yer[q[i].nd.nd] = 1;
		}
		else
			scanf("%lld",&q[i].nd.st);
	}
	
	int ind=0;
	foreach( yer,it )
		it->nd = ++ind;
		
	yer[ 1e18 ] = ++ind;
	
	FP( i,1,n )
		A.update( f( arr[i] ),arr[i] ),
		S.update( f( arr[i] ),1 );	
	
	FP( i,1,m ){
		if( q[i].st==1 ){
			A.update( f( arr[q[i].nd.st] ),-arr[q[i].nd.st] ),
			S.update( f( arr[q[i].nd.st] ),-1 );
			arr[q[i].nd.st] = q[i].nd.nd;
			A.update( f( arr[q[i].nd.st] ),arr[q[i].nd.st] ),
			S.update( f( arr[q[i].nd.st] ),1 );
		}
		else{
			double bas=0.0,son=1e18,orta;
			FP( iteration,1,200 ){
				orta = ( bas+son )/2;
				if( orta*S.query( f(orta)-1 )-A.query( f(orta)-1 )>=q[i].nd.st )	son = orta;
				else	bas = orta;
			}
			printf("%.12lf\n",bas);
		}
	}

}
