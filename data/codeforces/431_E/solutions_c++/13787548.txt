#include<bits/stdc++.h>

using namespace std;

#define st first
#define nd second
#define mp make_pair
#define pb push_back
#define sol (root+root)
#define sag (root+root+1)
#define orta ((bas+son)/2)
#define ll long long
#define pii pair<int,ll>
#define int ll

const int N=1e5+5;
const int mod=1e9+7;
const int inf=1e9+7;

int n,q,i,type,p,x,j;
int A[N];

int v;

double bas,son,ort;

class node{
	public:
		int ct;
		int sum;
		node *l,*r;
		node(){
			ct=sum=0;
			l=r=NULL;
		}
};

typedef node* pnode;

pnode root,e;

pnode merge(pnode &root,pnode x,pnode y){
	root->ct=x->ct+y->ct;
	root->sum=x->sum+y->sum;
}

pnode update(pnode &root,int bas,int son,int x,int v){
	if(root==NULL)
		root=new node;
	if(bas>x or son<x)
		return root;
	if(bas==son){
		root->ct+=v;
		root->sum+=v*bas;
		return root;
	}
	merge(root,update(root->l,bas,orta,x,v),update(root->r,orta+1,son,x,v));
	return root;
}

pii query(pnode root,int bas,int son,int x,int y){
	if(bas>y or son<x or root==NULL)
		return mp(0,0);
	if(x<=bas and son<=y)
		return mp(root->ct,root->sum);
	pii a,b;
	a=query(root->l,bas,orta,x,y);
	b=query(root->r,orta+1,son,x,y);
	return mp(a.st+b.st,a.nd+b.nd);
}

bool ok(double x){
	pii t=query(root,0,inf,0,x);
	if(x*t.st-t.nd<=v+0.0000001)
		return true;
	return false;
}

main(){

	scanf("%lld %lld",&n,&q);

	for(i=1 ; i<=n ; i++){
		scanf("%lld",A+i);
		update(root,0,inf,A[i],1);
	}

	for(i=1 ; i<=q ; i++){
		scanf("%lld",&type);
		if(type==1){
			scanf("%lld %lld",&p,&x);
			update(root,0,inf,A[p],-1);
			A[p]=x;
			update(root,0,inf,A[p],1);
		}
		else {
			scanf("%lld",&v);
			bas=0;
			son=1e18;
			for(j=1 ; j<=75 ; j++){
				ort=(bas+son)/2.0;
				if(ok(ort))
					bas=ort;
				else son=ort;
			}
			printf("%.10lf\n",bas);
		}
	}

}
