#include<stdio.h>
#include<string.h>
#include<algorithm>
#include<tr1/unordered_map>
using namespace std;
using namespace tr1;
int getint()
{
	int ret=0;bool ok=false;
	for(;;)
	{
		int c=getchar();
		if(c>='0'&&c<='9')ret=(ret<<3)+ret+ret+c-'0',ok=true;
		else if(ok)return ret;
	}
}
const int maxn=100010;
int n,L,R;
struct edge
{
	int v,w;
	edge *n;
};
edge EPool[2*maxn],*ep=EPool,*g[maxn];
inline void addedge(int u,int v,int w)
{
	ep->v=v,ep->w=w,ep->n=g[u],g[u]=ep++;
}
int val[maxn],nn;
unordered_map<int,int> mval;
void LSH()
{
	sort(val+1,val+n);
	int t=1;
	for(int i=2;i<n;i++)if(val[i]!=val[t])val[++t]=val[i];
	nn=t;
	for(int i=1;i<=nn;i++)mval[val[i]]=i;
	for(edge *i=EPool;i!=ep;i++)i->w=mval[i->w];
}
const int ninf=0x9f9f9f9f;
typedef pair<int,int> pii;
namespace Seg
{
	int n;
	int M;
	int T[1<<18],Ti[1<<18];
	void reset()
	{
		M=1;
		while(M-2<n)M<<=1;
		memset(T,0x9f,(M+M)*sizeof(int));
	}
	inline void modify(int i,int x,int xx)
	{
		i++;
		for(i+=M;i;i>>=1)if(T[i]<x)T[i]=x,Ti[i]=xx;
	}
	inline pii query(int l,int r)
	{
		l++,r++;
		if(l<1)l=1;
		if(l>r)return make_pair(ninf,0);
		int ret=ninf,reti=0;
		for(l+=M-1,r+=M+1;l^r^1;l>>=1,r>>=1)
		{
			if((~l&1)&&ret<T[l+1])ret=T[l+1],reti=Ti[l+1];
			if((r&1)&&ret<T[r-1])ret=T[r-1],reti=Ti[r-1];;
		}
		return make_pair(ret,reti);
	}
};
int sz[maxn],ms[maxn];
bool done[maxn];
void dfss(int u,int fa)//calc size
{
	sz[u]=1;
	ms[u]=0;
	for(edge *i=g[u];i;i=i->n)if(i->v!=fa&&!done[i->v])
	{
		dfss(i->v,u),sz[u]+=sz[i->v];
		if(sz[i->v]>ms[u])ms[u]=sz[i->v];
	}
}
int Pool[maxn],*beg[maxn],ln[maxn];
int base,ansu,ansv;
int dw[maxn],d[maxn];
void dfsd(int u,int fa,int *&p)//calc depth
{
	d[u]=d[fa]+1;
	*p++=u;
	for(edge *i=g[u];i;i=i->n)if(i->v!=fa&&!done[i->v])dw[i->v]=dw[u]+(i->w>=base?1:-1),dfsd(i->v,u,p);
}
bool work(int u,int n)
{
	done[u]=true;
	Seg::n=n;
	Seg::reset();
	Seg::modify(0,0,u);
	int *p=Pool;
	d[u]=0;
	for(edge *i=g[u];i;i=i->n)if(!done[i->v])
	{
		int v=i->v;
		beg[v]=p;
		dw[v]=i->w>=base?1:-1;
		dfsd(v,u,p);
		ln[v]=p-beg[v];
	}
	for(edge *i=g[u];i;i=i->n)if(!done[i->v])
	{
		int v=i->v;
		for(int i=0;i<ln[v];i++)
		{
			int k=beg[v][i];
			pii t=Seg::query(L-d[k],min(R-d[k],n));
			if(dw[k]+t.first>=0)return ansu=k,ansv=t.second,1;
		}
		for(int i=0;i<ln[v];i++)
		{
			int k=beg[v][i];
			Seg::modify(d[k],dw[k],k);
		}
	}
	for(edge *i=g[u];i;i=i->n)if(!done[i->v])
	{
		int v=i->v;
		dfss(v,u);
		for(int i=0;i<ln[v];i++)
		{
			int k=beg[v][i];
			int ts=max(ms[k],ln[v]-sz[k]);
			if(ts+ts<=ln[v])
			{
				if(work(k,ln[v]))return 1;
				break;
			}
		}
	}
	return 0;
}
bool check(int x)
{
	memset(done,0,sizeof(done));
	base=x;
	dfss(1,0);
	for(int i=1;i<=n;i++)
	{
		int ts=max(ms[i],n-sz[i]);
		if(ts+ts<=n)return work(i,n);
	}
}
int main()
{
	n=getint(),L=getint(),R=getint();
	for(int i=1;i<n;i++)
	{
		int u=getint(),v=getint(),w=getint();
		addedge(u,v,w);
		addedge(v,u,w);
		val[++nn]=w;
	}
	LSH();
	int l=1,r=nn+1;
	while(l+1!=r)
	{
		int mid=(l+r)>>1;
		if(check(mid))l=mid;
		else r=mid;
	}
	check(l);
	printf("%d %d\n",ansu,ansv);
	return 0;
}
