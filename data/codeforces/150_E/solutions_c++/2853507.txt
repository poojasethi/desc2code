#include <vector>
#include <cstdio>
#include <set>
#include <map>
#include <algorithm>
#include <cstdlib>
#include <sstream>
#include <numeric>
#include <queue>
#include <iostream>
#include <string>
#include <cstring>
#include <utility>
#define sz(a) ((int)(a).size())
#define pb push_back
#define mk make_pair
#define fi first
#define se second
#define Rep(i,j,k) for (int i=(j); i<=(k); i++)
#define Repd(i,j,k) for (int i=(j); i>=(k); i--)
#define ALL(c) (c).begin(),(c).end()
#define TR(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define SUM(a) accumulate(all(a),string())
#define online1
#define RAND ((rand()<<15)+rand())
using namespace std;
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef pair<int,int> II;
typedef long long LL;

const int N=100000+10;

int n, L, R, AnsX, AnsY, AnsL, size[N];
pair<int,II> Edge[N];
vector<II> E[N];
bool dead[N];

void build_tree(int x, int fa){
	size[x]=1;
	TR(E[x],e)
		if (e->fi!=fa && !dead[e->fi]){
			build_tree(e->fi,x);
			size[x]+=size[e->fi];
		}
}

void find_root(int x, int fa, int tot, int &root){
	bool flag=1;
	TR(E[x],e)
		if (e->fi!=fa && !dead[e->fi]){
			find_root(e->fi,x,tot,root);
			if (size[e->fi]*2>tot)
				flag=0;
		}
	if ( (tot-size[x])*2 > tot )
		flag=0;
	if (flag)
		root=x;
}

int q[N];

II operator+(const II &a, int b){
	return mk(a.fi+b, a.se);
}

void UpdateAns(int L, int X, int Y){
	if (L>AnsL){
		AnsL=L;
		AnsX=X;
		AnsY=Y;
	}
}

vector<II> g, f;

void dfs(int x, int fa, int dep, int val){
	if (dep>sz(g)-1) g.pb(mk(-(1<<30),-1));
	g[dep]=max(g[dep],mk(val,x));
	TR(E[x],e)
		if (e->fi!=fa && !dead[e->fi])
			dfs(e->fi, x, dep+1, val+e->se);
}

void divide(int x){
	int root=-1;
	build_tree(x,0);
	find_root(x,0,size[x],root);
	x=root;
	
	f.clear(); f.pb(mk(0,root));
	TR(E[root],e)if(!dead[e->fi]){
		g.clear(); g.pb(mk(-(1<<30),-1));
		dfs(e->fi,root,1,e->se);
		int head=1,tail=0,cur=0;
		Repd(i,sz(g)-1,0){
			while(cur<=R-i && cur<sz(f)){
				while(head<=tail && f[q[tail]].fi<=f[cur].fi)
					tail--;
				q[++tail]=cur++;
			}
			while(head<=tail && q[head]<L-i) head++;
			if (head<=tail)
				UpdateAns(g[i].fi+f[q[head]].fi, g[i].se, f[q[head]].se);
		}
		Rep(i,0,sz(g)-1){
			if (i>sz(f)-1) f.pb(mk(-(1<<30),-1));
			f[i]=max(f[i],g[i]);
		}
	}
			
	dead[root]=1;
	TR(E[root],e) if (!dead[e->fi])
		divide(e->fi);
}

int solve(int lambda){
	Rep(i,1,n) E[i].clear(), dead[i]=0;
	Rep(i,1,n-1){
		int w=(Edge[i].fi>=Edge[lambda].fi)?1:-1;
		E[Edge[i].se.fi].pb(mk(Edge[i].se.se,w));
		E[Edge[i].se.se].pb(mk(Edge[i].se.fi,w));
	}
	AnsL=-(1<<30);
	divide(1);
	return AnsL;
}

int main(){
	
	cin>>n>>L>>R;
	
	Rep(i,1,n-1)
		scanf("%d%d%d",&Edge[i].se.fi,&Edge[i].se.se,&Edge[i].fi);
		
	sort(Edge+1,Edge+n);
	
	int l=1, r=n-1;
	while(l<r){
		int mid=(l+r)/2+1;
		if (solve(mid)>=0)
			l=mid;
		else
			r=mid-1;
	}
	
	solve(l);
	cout<<AnsX<<" "<<AnsY<<endl;

    return 0;
}
