#include<cstdio>
#include<cstring>
#include<ctime>
#include<algorithm>
using namespace std;
#define to ed[p]
#define each(x) for (int p=son[x];p;p=next[p])
#define add(x,y,z) ed[++l]=y,data[l]=z,next[l]=son[x],son[x]=l
#define N 200005
int v[N],son[N],ed[N],data[N],next[N],s[N],f[N],g[N],f0[N],g0[N],q[N];
int n,l,r,mid,x,y,z,V,L,R,S,T,O,ans,flag,heavy[N],fat[N]; bool b[N];
void cnt(int x,int fa){s[x]=1; each(x) if (to!=fa) cnt(to,x),s[x]+=s[to];}
void find(int x,int fa,int d,int c)
{
	if (b[x]) return; if (c>g[d]) g[d]=c,flag?g0[d]=x:0;
	each(x) if (fa!=to) find(to,x,d+1,c+(data[p]<V?-1:1));
}
int divide(int &x)
{
	int y=0; s[x]=1;
	each(x) {s[x]+=s[to]; if (!y || s[to]>s[y]) y=to;}
	if (s[y]>s[x]/2) s[x]-=s[y],x=y,divide(x);
}
void updata(int &n)
{
	int j=0,h=1,t=0,m=0; while (g[m+1]>-N) m++;
	for (int i=m;i && i>=L-n;i--) if (g[i]>-m){
		while (j+i<=R && j<=n){while (h<=t && f[j]>f[q[t]]) t--; q[++t]=j++;}
		while (h<=t && q[h]+i<L) h++;
		if (h<=t && g[i]+f[q[h]]>=0) {ans=1,S=f0[q[h]],T=g0[i]; return;}
		}
	n=max(n,m); for (int i=1;i<=m;i++) if (g[i]>f[i]) f[i]=g[i],flag?f0[i]=g0[i]:0;
}
void Clear(int *f){while (*f>-N) *f=-N,f++;}
void work(int x)
{
	if (ans) return; int len=0,lim; Clear(f); f0[f[0]=0]=x; b[x]=1; 
	each(x) if (!ans) Clear(g+1),find(to,x,1,data[p]<V?-1:1),updata(len);
	for (int p=heavy[x];p;p=fat[p]) work(p);
}
int pre(int x)
{
	divide(x); s[x]=0; int y;
	each(x) if (s[to]) y=pre(to),fat[y]=heavy[x],heavy[x]=y;
	return x;
}
int main()
{
	scanf("%d%d%d",&n,&L,&R),f[n+1]=g[n+1]=-N*5; int t1=clock();
	for (int i=1;i<n;i++) scanf("%d%d%d",&x,&y,&z),v[r++]=z,add(x,y,z),add(y,x,z);
	sort(v,v+r),l=0,cnt(1,0),O=pre(1);
	while (l+1<r)mid=(l+r)/2,V=v[mid],ans=0,work(O),ans?l=mid:r=mid,memset(b,0,sizeof(b));
	flag=1,V=v[l],ans=0,work(O); printf("%d %d\n",S,T); return 0;
}
