#include<cstdio>
#include<algorithm>
using namespace std;

#define long long long

#define l(x) ((x) * 2 + 1)
#define r(x) (l(x) + 1)

const int MAX_T = 1 << 18;

struct Line{
  int m, c;
  double x;
  int idx;
  Line(){}
  Line(int m, int c, int idx, double x):
    m(m), c(c), idx(idx), x(x) 
  {}
  bool operator < (const Line &o) const{
    return m != o.m? m < o.m: c < o.c;
  }
};

struct Node{
  Line *s;
  int n;
  int f, l;
};
  
int n, q;
Node a[MAX_T];

inline double intersect(Line& a, Line& b){
  return (double)(a.c - b.c) / (double)(b.m - a.m);
}

inline void push(Node& x, Line& l){
  for(; x.n and intersect(x.s[x.n - 1], l) <= x.s[x.n - 1].x; x.n--); 
  x.s[x.n++] = Line(l.m, l.c, l.idx, x.n? intersect(x.s[x.n - 1], l): 0.0);
}

inline void init_tree(int x, int f, int l){
  a[x].s = new Line[l - f];
  a[x].f = f, a[x].l = l;
  if(l - f == 1){
    int m, c;
    scanf("%d %d", &c, &m);
    a[x].s[a[x].n++] = Line(m, c, f + 1, 0.0);
    return;
  }
  init_tree(l(x), f, f + l >> 1);
  init_tree(r(x), f + l >> 1, l);
  int i1 = 0, i2 = 0;
  for(; i1 < a[l(x)].n and i2 < a[r(x)].n; ){
    if(a[l(x)].s[i1] < a[r(x)].s[i2]){
      push(a[x], a[l(x)].s[i1++]);
    }
    else if(a[r(x)].s[i2] < a[l(x)].s[i1]){
      push(a[x], a[r(x)].s[i2++]);
    }
    else{
      push(a[x], a[l(x)].s[i1++]);
      i2++;
    }
  }
  for(; i1 < a[l(x)].n; push(a[x], a[l(x)].s[i1++]));
  for(; i2 < a[r(x)].n; push(a[x], a[r(x)].s[i2++]));
} 

#define pli pair<long, int>

inline bool time_cmp(Line a, Line b){
  return a.x < b.x;
}

inline pli query(int x, int f, int l, int t){
  if(l <= a[x].f or f >= a[x].l){
    return pli(-1, 0);
  }
  if(a[x].f >= f and a[x].l <= l){
    Line *it = upper_bound(a[x].s, a[x].s + a[x].n, Line(0, 0, 0, t), time_cmp); it--;
    return pli((long)it->m * t + it->c, it->idx);
  }
  return max(query(l(x), f, l, t), query(r(x), f, l, t));
}

int main(){
  scanf("%d %d", &n, &q);
  init_tree(0, 0, n);
  for(; q--; ){
    int f, l, t;
    scanf("%d %d %d", &f, &l, &t);
    printf("%d\n", query(0, f - 1, l, t).second);
  }
}
