#include<cstdio>
#include<vector>
#include<algorithm>

using namespace std;

#define MN 100001
#define NN MN<<3
#define MD(a,b) (((a)+(b))/2)
#define LC(k) (k<<1)
#define RC(k) ((k<<1)+1)

typedef long long lld;

int AA[MN],BB[MN];
int N,M,a,b,c;

class LT{
	private:
		struct Node{
			int a,b,o;
			Node( int _a, int _b, int _o){a=_a;b=_b;o=_o;}
			bool operator<( const Node &B) const{
				return b<B.b;
			}
		};
		vector<Node> S[NN];
		int C[NN];
		double Calc( Node A, Node B){
			return double(A.a-B.a)/(B.b-A.b);
		}
		lld ll,rr,ttt;
		lld max,maxs;
		void find2( int k){
			int l=0,r=C[k]-2,t=-1,mid;
			while (l<=r){
				mid=MD(l,r);
				if (Calc(S[k][mid],S[k][mid+1])<ttt) t=mid,l=mid+1;
				else r=mid-1;
			}
			lld x;
			if ((x=((lld)S[k][t+1].a+(lld)S[k][t+1].b*ttt))>max) max=x,maxs=S[k][t+1].o;
		}
		void find( int k, int l, int r){
			if (r<ll||l>rr) return ;
			if (ll<=l&&rr>=r){
				find2(k);
				return ;
			}
			find(LC(k),l,MD(l,r));
			find(RC(k),MD(l,r)+1,r);
		}
	public:
		vector<Node> A;
		void init( int k, int l, int r){
			if (l==r) S[k].push_back(Node(AA[l],BB[l],l)),C[k]=1;
			else {
				init(LC(k),l,MD(l,r));
				init(RC(k),MD(l,r)+1,r);
				A.clear();
				for (int i=0;i<C[LC(k)];i++) A.push_back(S[LC(k)][i]);
				for (int i=0;i<C[RC(k)];i++) A.push_back(S[RC(k)][i]);
				sort(A.begin(),A.end());
				S[k].resize(A.size(),Node(0,0,0));
				S[k][0]=A[0];C[k]=1;
				for (int i=1;i<A.size();i++){
					while (A[i].a>=S[k][C[k]-1].a&&C[k]>0) C[k]--;
					++C[k];
					S[k][C[k]-1]=A[i];
					while (C[k]>2&&Calc(S[k][C[k]-1-1],S[k][C[k]-1])<Calc(S[k][C[k]-1-2],S[k][C[k]-1-1])) C[k]--,S[k][C[k]-1]=S[k][C[k]];
				}
			}
		}
		void findd( int _l, int _r, int _t){
			max=0;maxs=0;
			ll=_l;rr=_r;ttt=_t;
			find(1,1,N);
			printf("%d\n",maxs);
		}
} T;

int main(){
	scanf("%d%d",&N,&M);
	for (int i=1;i<=N;i++) scanf("%d%d",AA+i,BB+i);
	T.init(1,1,N);
	while (M--){
		scanf("%d%d%d",&a,&b,&c);
		T.findd(a,b,c);
	}
}
