#include<cstdio>
#include<vector>
#include<iostream>
#include<algorithm>
#define pb push_back
using namespace std;
struct point{
    double x,y;int d;
}p[100010];
vector<int>w[400010];
int n,m;
bool cmp(point a,point b){return a.x<b.x||a.x==b.x&&a.y<b.y;}
double crossx(point a,point b){
    return (b.y-a.y)/(a.x-b.x);
}
double crossy(point a,point b){
    return crossx(a,b)*a.x+a.y;
}
void build(int t,int l,int r){
    int mid=(l+r)>>1,si=r-l+1,num;
    vector<point>pi,use;
    vector<int>v;
    for(int i=l;i<=r;++i)pi.pb(p[i]);
    sort(pi.begin(),pi.end(),cmp);
    for(int i=0;i<si;++i){
        while(!use.empty()&&pi[i].y>=use.back().y)use.pop_back();
        use.pb(pi[i]);
    }
    for(int i=0;i<(int)use.size();++i){
        while(v.size()>1){
            num=v.size()-1;
            if(crossy(use[v[num-1]],use[v[num]])<crossx(use[v[num-1]],use[v[num]])*use[i].x+use[i].y)v.pop_back();
            else break;
        }
        v.pb(i);
    }
    for(int i=0;i<(int)v.size();++i)w[t].pb(use[v[i]].d);
    if(l==r)return;
    build(t<<1,l,mid);
    build((t<<1)+1,mid+1,r);
}
int solve(int t,int l,int r,int x,int y,int ti){
    if(l>y||r<x)return -1;
    if(x<=l&&r<=y){
        int ll=1,rr=w[t].size()-1,mid,tmp;
        if(rr==0)return w[t][0];
        if(ti<=crossx(p[w[t][0]],p[w[t][1]]))return w[t][0];
        while(ll<=rr){
            mid=(ll+rr)>>1;
            if(ti>=crossx(p[w[t][mid-1]],p[w[t][mid]]))ll=(tmp=mid)+1;
            else rr=mid-1;
        }
        return w[t][tmp];
    }
    int mid=(l+r)>>1,h1,h2;
    h1=solve(t<<1,l,mid,x,y,ti);
    h2=solve((t<<1)+1,mid+1,r,x,y,ti);
    if(h1==-1)return h2;
    if(h2==-1)return h1;
    if(p[h1].x*ti+p[h1].y>p[h2].x*ti+p[h2].y)return h1;
    else return h2;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i){
        scanf("%lf%lf",&p[i].y,&p[i].x);p[i].d=i;
    }
    build(1,1,n);
    for(int i=1,l,r,x;i<=m;++i){
        scanf("%d%d%d",&l,&r,&x);
        printf("%d\n",solve(1,1,n,l,r,x));
    }
    return 0;
}
