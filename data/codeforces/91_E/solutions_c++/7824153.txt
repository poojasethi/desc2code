#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <vector>
#define int64 long long
#define N 100010
#define For(i,x,y) for (i=x;i<=y;i++)
using namespace std;
struct ww {
	int64 k,b;
	int id;
	inline ww operator - (const ww &A) {
		return (ww){k-A.k,b-A.b};
	}
	inline int64 operator * (const ww &A) {
		return k*A.b-b*A.k;
	}
	inline int64 cal(int64 x) const {
		return k*x+b;
	}
} a[N];
int i,j,k,n,m,x,y,z,re;
int g[N];
int64 an;
vector<ww> tr[N*4];
inline bool cc1(const ww &a,const ww &b) {
	return a.k<b.k||a.k==b.k&&a.b<b.b;
}
inline bool pan(ww A,ww B,ww C) {
	return (B-C)*(A-C)>=0;
}
inline void Do(vector<ww> &b,int x,int y) {
	vector<ww> c;
	int i,r=0;
	For(i,x,y) c.push_back(a[i]);
	sort(c.begin(),c.end(),cc1);
	for (i=0;i<c.size();i++) {
		ww A=c[i];
		for (;r>1;r--) {
			ww B=c[g[r]],C=c[g[r-1]];
			if (!pan(A,B,C)) break;
		}
		g[++r]=i;
	}
	For(i,1,r) b.push_back(c[g[i]]);
}
void build(int q,int x,int y) {
	Do(tr[q],x,y);
	if (x==y) return;
	int mid=(x+y)/2;
	build(q*2,x,mid);
	build(q*2+1,mid+1,y);
}
inline void Do(const vector<ww> &A,int64 x) {
	int l=0,r=A.size()-1,mid1,mid2,i;
	for (;l+2<r;) {
		mid1=(r-l)/3+l,mid2=(r-l)/3*2+l;
		if (A[mid1].cal(x)>A[mid2].cal(x)) r=mid2;
		else l=mid1;
	}
	For(i,l,r) {
		int64 B=A[i].cal(x);
		if (B>an) an=B,re=A[i].id;
	}
}
void cal(int q,int x,int y,int l,int r) {
	if (l<=x&&y<=r) {
		Do(tr[q],z);
		return;
	}
	int mid=(x+y)/2;
	if (l<=mid) cal(q*2,x,mid,l,r);
	if (mid<r) cal(q*2+1,mid+1,y,l,r);
}
int main() {
	scanf("%d%d",&n,&m);
	For(i,1,n) scanf("%I64d%I64d",&a[i].b,&a[i].k),a[i].id=i;
	build(1,1,n);
	For(i,1,m) {
		scanf("%d%d%d",&x,&y,&z);
		an=0;
		cal(1,1,n,x,y);
		printf("%d\n",re);
	}
	return 0;
}
