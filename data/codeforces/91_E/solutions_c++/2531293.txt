#include <iostream> 
#include <iomanip>
#include <string>
#include <vector>
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <cmath>

using namespace std;

#define FOR(x, a, b) for (int x = (a); x < int(b); x++)
#define all(x) (x).begin(), (x).end()
#define pb push_back
#define X first
#define Y second
#define Size(x) (int((x).size()))
typedef long long ll;
typedef pair<ll, ll> pll;

const int MAXN = 101*1000;
const int MAXG = 1000;

bool active[MAXN];
int sz, n;
ll A[MAXN], B[MAXN];
int active_cnt[MAXG], best[MAXG];
ll best_expire[MAXG];

ll get_balance(int t, int x) {
	return A[x] + t*B[x];
}

pll get_group_balance(int t, int g) {
	if (t < best_expire[g]) return pll(get_balance(t, best[g]), best[g]);
	int beg = g*sz;
	int end = min(n, beg+sz);
	pll res(-1e18, -1e18);
	FOR(i, beg, end) if (active[i]) {
		pll tmp(get_balance(t, i), i);
		if (tmp > res) {
			best[g] = i;
			res = tmp;
		}
	}
	best_expire[g] = 1e18;
	int y = best[g];
	FOR(x, beg, end) if (active[x] && B[x] > B[y]) {
		ll tmp = (A[y]-A[x])/(B[x]-B[y]);
		best_expire[g] = min(best_expire[g], tmp);
	}
	return res;
}

int main() {
	memset(best, -1, sizeof best);
	int m;
	cin >> n >> m;
	n++;
	sz = sqrt(n);
	FOR(k, 1, n) {
		cin >> A[k] >> B[k];
		int g = k/sz;
		best_expire[g] = 0;
		best[g] = -1;
		if (!active[k]) active_cnt[g]++;
		active[k] = true;
		//FOR(i, 0, 10) cout << get_balance(i, k) << " "; cout << endl;
	}
	vector<pair<pll, pll> > Q;
	FOR(i, 0, m) {
		int a, b, t;
		cin >> a >> b >> t;
		Q.pb(make_pair(pll(t, i), pll(a, b)));
	}
	sort(all(Q));
	FOR(i, 0, m) {
		int ok = 0;
		pll res(-1e18, -1e18);
		int t = Q[i].X.X, a = Q[i].Y.X, b = Q[i].Y.Y;
		swap(Q[i].X.X, Q[i].X.Y);
		if (a > b) swap(a, b);
		while (a%sz && a <= b) {
			if (active[a]) res = max(res, pll(get_balance(t, a), a)), ok++;
			a++;
		}
		while (a+sz-1 <= b) {
			ok += active_cnt[a/sz];
			res = max(res, get_group_balance(t, a/sz));
			a += sz;
		}
		while (a <= b) {
			if (active[a]) res = max(res, pll(get_balance(t, a), a)), ok++;
			a++;
		}
		Q[i].X.Y = res.Y;
	}
	sort(all(Q));
	FOR(i, 0, m) cout << Q[i].X.Y << endl;
	return 0;
}

