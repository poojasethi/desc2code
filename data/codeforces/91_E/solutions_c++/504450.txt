//Solution by Ali-Amir Aldan
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <cmath>
#include <map>
#include <set>

using namespace std;

#define K 334
#define N 200000

int n, Q, l, r, t, best;
int a[N], b[N], block[N], mod[N];
vector <int> v[N/K+1], q[N/K+1], vv[N/K+1];

bool comp (const int i, const int j)
{
	if (b[i]!=b[j]) return b[i]<b[j];
	return a[i]<a[j];
}

inline bool better (int i, int j)
{
 	return a[j]>=a[i]&&b[j]>=b[i];
}

void proc (int u)
{
	sort (v[u].begin (), v[u].end (), comp);
	vv[u].clear (); q[u].clear ();

	for (int it = 0, moment, ii, jj; it < v[u].size (); it++)
	{
		for (; vv[u].size () && better (vv[u].back (), v[u][it]); vv[u].pop_back (), q[u].pop_back ());

		for (; vv[u].size ();)
		{
			ii = vv[u].back (); jj = v[u][it];
			moment = (0LL+a[ii]-a[jj]+b[jj]-b[ii]-1)/(b[jj]-b[ii]);
			if (moment <= q[u].back ())
			{
				q[u].pop_back ();
				vv[u].pop_back ();
			}
			else
				break;
		}

		if (vv[u].size ())
		{
			ii = vv[u].back (); jj = v[u][it];
			moment = (0LL+a[ii]-a[jj]+b[jj]-b[ii]-1)/(b[jj]-b[ii]);
			q[u].push_back (moment);
        }
        else
			q[u].push_back (0);
		vv[u].push_back (v[u][it]);
	}

	v[u] = vv[u];
}

int main ()
{
	scanf ("%d%d", &n, &Q);
	for (int i = 0; i < n; i++)
		scanf ("%d%d", &a[i], &b[i]);
	for (int i = 0; i < n; i++)
		block[i] = i/K,
		mod[i] = i%K,
		v[block[i]].push_back (i);
	for (int i = 0; i < n; i+=K)
		proc (block[i]);

	for (int i = 0; i < Q; i++)
	{
	 	scanf ("%d%d%d", &l, &r, &t); l--; r--;
	 	best = l;
	 	for (; l<=r && mod[l]; l++)
	 		if (a[l]+1LL*b[l]*t > a[best]+1LL*b[best]*t)
	 			best = l;
	 	for (int p, v; l+K <= r; l+=K)
	 	{
			p = lower_bound (q[block[l]].begin (), q[block[l]].end (), t+1)-q[block[l]].begin()-1;
			if (p>=0)
			{
			 	v = ::v[block[l]][p];
			 	if (a[best]+1LL*b[best]*t < a[v]+1LL*b[v]*t)
			 		best = v;
			}
	 	}
	 	for (; l<=r; l++)
	 		if (a[l]+1LL*b[l]*t > a[best]+1LL*b[best]*t)
	 			best = l;

	 	printf ("%d\n", best+1);
	}

	return 0;
}
