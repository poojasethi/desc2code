#include<stdio.h>
#include<algorithm>
using namespace std;
#define maxn 111111
struct treenode{int l,r,lF,rF,head;}tree[maxn*4];
pair<int,int>F[maxn*20],q[maxn];
int n,m,i,j,L[maxn],R[maxn],T[maxn],inf=2000000000,a[maxn],b[maxn],c[maxn],d[maxn],sz,ai,ret,ans[maxn];
int cross(int x,int y){
	if(a[x]<=a[y])return 0;else
	if(b[x]==b[y])return inf;else return ((a[x]-b[x])-(a[y]-b[y])-1)/(b[y]-b[x]);
}
void init(int pos,int l,int r){
	int i,hL,hR,mid=(l+r)/2;
	tree[pos].l=l,tree[pos].r=r;
	if(l<r){		
		init(pos+pos,l,mid);
		init(pos+pos+1,mid+1,r);
		hL=l,hR=mid+1;
		for(i=l;i<=r;i++)if(hL==mid+1||(hR!=r+1&&b[c[hL]]>b[c[hR]]))d[i]=c[hR++];else d[i]=c[hL++];
		for(i=l;i<=r;i++)c[i]=d[i];
	}
	tree[pos].lF=tree[pos].rF=tree[pos].head=++sz;F[sz]=make_pair(c[l],0);
	for(i=l+1;i<=r;i++){
		while(tree[pos].lF<=tree[pos].rF&&cross(F[sz].first,c[i])<=F[sz].second){--sz,--tree[pos].rF;}
		if(tree[pos].lF>tree[pos].rF){
			F[++sz]=make_pair(c[i],0);
			tree[pos].rF=sz;
		}else F[++sz]=make_pair(c[i],cross(F[tree[pos].rF].first,c[i]));tree[pos].rF=sz;
	}
}
void query(int pos,int l,int r,int t){
	if(tree[pos].l==l&&tree[pos].r==r){
		while(tree[pos].head<tree[pos].rF&&F[tree[pos].head+1].second<=t)++tree[pos].head;
		int k=F[tree[pos].head].first;
		if(ret==0||(long long)a[ret]+(long long)t*(long long)b[ret]<(long long)a[k]+(long long)t*(long long)b[k])ret=k;
	}else{
		if(l<=min(r,tree[pos+pos].r))query(pos+pos,l,min(r,tree[pos+pos].r),t);
		if(max(l,tree[pos+pos+1].l)<=r)query(pos+pos+1,max(tree[pos+pos+1].l,l),r,t);
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++){scanf("%d%d",&a[i],&b[i]);c[i]=i;}
	init(1,1,n);
	for(i=1;i<=m;i++){
		scanf("%d%d%d",&L[i],&R[i],&T[i]);
		q[i]=make_pair(T[i],i);
	}
	sort(q+1,q+m+1);
	for(i=1;i<=m;i++){
		ai=q[i].second;ret=0;
		query(1,L[ai],R[ai],T[ai]);
		ans[ai]=ret;
	}
	for(i=1;i<=m;i++)printf("%d\n",ans[i]);
	return 0;
}