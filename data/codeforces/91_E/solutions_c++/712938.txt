#include <map>
#include <set>
#include <cmath>
#include <stack>
#include <queue>
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <bitset>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <iostream>
#include <algorithm>
using namespace std;
#define li       	long long int
#define rep(i,to)	for(li i=0;i<((li)(to));i++)
#define pb       	push_back
#define sz(v)    	((li)v.size())
#define bit(n)   	(1ll<<(li)(n))

#define MAX 100005
#define MP make_pair
#define x first
#define y second
li n,m,N=1,a[MAX],b[MAX],l[MAX],r[MAX],t[MAX];
vector<pair<pair<li,li>,li> > st[MAX*4];

void init(li left,li right,li num){
	if(left+1<right){
		li mid=(left+right)/2;
		init(left,mid,num*2);
		init(mid,right,num*2+1);
	}
	vector<pair<pair<li,li>,li> > vec,v(right-left);
	for(li i=left;i<min(n,right);i++) vec.pb(MP(MP(a[i],b[i]),i));
	sort(vec.begin(),vec.end());
	li pos=0;
	rep(i,sz(vec)){
		while((0<pos && v[pos-1].x.y<=vec[i].x.y) || 1<pos){
			if(!(v[pos-1].x.y<=vec[i].x.y)){
				li t0=v[pos-1].x.y-vec[i].x.y,t1=vec[i].x.x-v[pos-1].x.x;
				if(v[pos-2].x.x*t0+v[pos-2].x.y*t1<v[pos-1].x.x*t0+v[pos-1].x.y*t1) break;
			}
			pos--;
		}
		v[pos++]=vec[i];
	}
	rep(i,pos) st[num].pb(v[i]);
}


li search(li left,li right,li LEFT,li RIGHT,li v,li time){
	if(right<=LEFT || RIGHT<=left) return -1;
	if(LEFT<=left && right<=RIGHT){
		li res=0;
		li low=0,high=sz(st[v]);
		while(low+1<high){
			li mid=(low+high)/2;
			li tl=a[st[v][mid-1].y]+b[st[v][mid-1].y]*time;
			li th=a[st[v][mid].y]+b[st[v][mid].y]*time;
			if(tl<th) low=mid;
			else high=mid;
		}
		return st[v][low].y;
	}
	li mid=(left+right)/2;
	li res0=search(left,mid,LEFT,RIGHT,v*2,time);
	li res1=search(mid,right,LEFT,RIGHT,v*2+1,time);
	if(res0==-1) return res1;
	if(res1==-1) return res0;
	if(a[res0]+b[res0]*time<a[res1]+b[res1]*time) return res1;
	return res0;
}

int main(){
	cin>>n>>m;
	rep(i,n) cin>>a[i]>>b[i];
	rep(i,m) cin>>l[i]>>r[i]>>t[i];
	while(N<n) N*=2;
	init(0,N,1);
	rep(i,m) cout<<search(0,N,l[i]-1,r[i],1,t[i])+1<<endl;;
}
