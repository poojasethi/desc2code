# -*- coding: utf-8 -*-

import bisect


def read_int():
    return int(raw_input())


def read_int_list():
    return map(int, raw_input().split())


if __name__ == '__main__':
    n = read_int()
    p = read_int_list()
    s = read_int_list()
    need = [0] * n
    for i, v in enumerate(s):
        need[v - 1] = i

    has = [0] * n
    for i, v in enumerate(p):
        p[i] = need[v - 1]
        has[need[v - 1]] = i

    cost = 0
    swaps = 0
    history = []

    def swap(i, j):
        global cost, swaps
        has[p[i]], has[p[j]] = has[p[j]], has[p[i]]
        p[i], p[j] = p[j], p[i]
        swaps += 1
        cost += abs(i - j)
        history.append((i, j))

    for i in xrange(n - 1, 0, -1):
        v = p[i]
        if v < i:
            if has[i] >= v:
                swap(i, has[i])
            else:
                steps = [has[i]]
                hi = 0
                for j in xrange(has[i] + 1, i + 1):
                    if p[j] > steps[hi - 1]:
                        continue
                    pos = bisect.bisect_left(steps, p[j], hi=hi) + 1
                    if pos == len(steps):
                        steps.append(j)
                    else:
                        steps[pos] = j
                    hi = pos + 1

                for j, step in enumerate(steps):
                    if j == hi - 1:
                        break
                    swap(step, steps[j + 1])

    print cost
    print swaps
    for i, j in history:
        print i + 1, j + 1
