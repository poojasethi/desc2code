
def sol1(): #wrong solution
	global n, p1, p2, di, di2
	swaps = []
	cost = 0
	flag = True
	while flag:
		flag = False
		for i in range(n-1):
			if di[p1[i]] > di[p1[i+1]]:
				temp = p1[i]
				p1[i] = p1[i+1]
				p1[i+1] = p1[i]
				cost += 1
				swaps.append( (i,i+1) )
				flag = True


def sol2():
	global n, p1, p2, di, di2, cost, swap
	flag = True
	while flag:
		flag = False
		for i in range(0,n):
			if di[p1[i]] != i:
				#print i
				#print p1
				#print di
				flag = True
				k = di2[i]
				for j in xrange(i, k):
					if di[p1[j]] >= k:
						#print k,j
						cost += k-j
						swap.append((k,j))
						di2[i] = j
						di2[di[p1[j]]] = k
						temp = p1[k]
						p1[k] = p1[j]
						p1[j] = temp
						break
				break

n = int(raw_input())
p1 = [int(x) for x in raw_input().split()]
p2 = [int(x) for x in raw_input().split()]
di = {k:p2.index(k) for k in p1} #where should I be ultimately located?
di2 = {k:p1.index(p2[k]) for k in range(0,n)} #where is the guy who should ultimately come here?
cost = 0
swap = []
#print di
#print di2

sol2()
print cost
print len(swap)
for i in swap:
	print i[0]+1, i[1]+1







