#include <bits/stdc++.h>

#define	st first
#define	nd second
#define	mp make_pair
#define	pb push_back
#define	lli long long int
#define	all( gg )	gg.begin(),gg.end()
#define	foreach( gg,itit )	for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )
#define	FP( ii,aa,bb ) for( lli ii=aa;ii<=bb;ii++ )
#define	FM( ii,aa,bb ) for( lli ii=aa;ii>=bb;ii-- )
#define	debug(ccc)	cout << #ccc << " = " << ccc << endl;

#define	mod	1000000007LL

#define	orta	(bas+son)/2
#define	sol		root*2,bas,orta
#define	sag		root*2+1,orta+1,son

using namespace std;

#define	line	pair<int,int>
#define	m	st
#define	n	nd

double	lineIntersection( line a,line b ){
	return	(1.0*a.n-b.n)/(1.0*b.m-a.m);
}

class	Trick{
	public:
		deque< line >	Q;
		void	init( vector< line > v ){
			reverse( all(v) );
			Q.clear();
			foreach( v,it ){
				if( Q.size() and Q.back().m==it->m )
					Q.pop_back();
				while( Q.size()>=2 and lineIntersection( *it,Q.back() )<lineIntersection( *it,Q[Q.size()-2] ) )	Q.pop_back();
				Q.push_back( *it );
			}
		}
		lli	query( int x ){
			static	int	p=-mod;
			assert( x>=p );
			p = x;
			while( Q.size()>1 and Q[0].m*x+Q[0].n>Q[1].m*x+Q[1].n )	Q.pop_front();
			assert( Q.size() );
			return	x*Q[0].m+Q[0].n;
		}
}kd[300000];

int	n,m;
lli	a[100005],sum[100005];

pair< pair<int,int>,int >	que[100005];
int	result[100005];

bool	cmp( pair< pair<int,int>,int > a,pair< pair<int,int>,int > b ){
	return	a.st.st-a.st.nd<b.st.st-b.st.nd;
}

vector< pair<int,int> >	v[300000];
void	init( int root,int bas,int son ){
	if( bas==son ){
		v[root].pb( mp( a[bas],bas*a[bas]-sum[bas] ) );
		kd[root].init( v[root] );
		return;
	}
	init( sol );
	init( sag );
	v[root].resize( v[root*2].size()+v[root*2+1].size() );
	merge( all(v[root*2]),all(v[root*2+1]),v[root].begin() );
	kd[root].init( v[root] );
}

lli	query( int root,int bas,int son,int x,int y,int ki ){
	if( son<x or y<bas )	return	mod*mod;
	if( x<=bas and son<=y )	return	kd[root].query( ki );
	return	min( query( sol,x,y,ki ),query( sag,x,y,ki ) );
}

int main(){
	ios_base::sync_with_stdio(false);
	cin >> n;
	FP( i,1,n ){
		cin >> a[i];
		sum[i] = sum[i-1]+a[i];
	}
	cin >> m;
	FP( i,1,m ){
		cin >> que[i].st.st >> que[i].st.nd;
		que[i].nd = i;
	}
	sort( que+1,que+m+1,cmp );
	init( 1,1,n );
	FP( i,1,m )
		result[ que[i].nd ] = query( 1,1,n,max(que[i].st.nd-que[i].st.st+1,1),que[i].st.nd,que[i].st.st-que[i].st.nd )+sum[que[i].st.nd];
	FP( i,1,m )
		cout << result[i] << endl;
}
