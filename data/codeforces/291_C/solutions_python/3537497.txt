from itertools import groupby

def ipstr_to_bitstr(ip):
    return ''.join(map(lambda part: bin(int(part))[2:].zfill(8), ip.split('.')))

def bitstr_to_ipstr(ip):
    return '.'.join(map(lambda part_id: str(int('0b' + ip[part_id * 8: (part_id + 1) * 8], 2)), range(4)))

def get_mask(ips, network_count):
    ips = map(ipstr_to_bitstr, ips)
    ips.sort()
    
    for mask_eye in range(31):
        network_found = sum(1 for key, group in groupby(ips, key=lambda ip: ip[:mask_eye + 1]))
        if network_found == network_count:
            return bitstr_to_ipstr('1' * (mask_eye + 1) + '0' * (31 - mask_eye))
        if network_found > network_count:
            return '-1'
    return '-1'

def main():
    ip_count, network_count = map(int, raw_input().split())
    ips = []
    for unused in range(ip_count):
        ips.append(raw_input())
    print get_mask(ips, network_count)

if __name__ == '__main__':
    main()
