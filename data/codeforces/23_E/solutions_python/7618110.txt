'''
Created on Aug 18, 2014

@author: dstarer
'''

##if a/b > c /d then put (a, b) before (c, d)
def cmp((a, b), (c, d)):
	if b*c < a*d:
		return 1;
	return -1;

def DFS(p, fa):
	sonp = [];

	for q in to[p]:
		if q!=fa:
			DFS(q, p);
			sonp.append((ans[q][0], ans[q][1]));
	sonp.sort(cmp);
	tmp = 1;
	##first case: cut all the edges connected with p
	##caculate f[]
	for v in sonp:
		tmp = tmp * v[0];
	ans[p] = (tmp, tmp);
	now = tmp;
	maxv = ans[p][0];

	##second case: cut several edges connected with p
	i = 1;
	for v in sonp:
		now = now/v[0] * v[1];
		maxv = max(maxv, now * (i + 1))
		i += 1;
	##third case: only save one edges and cut the others

	for q in to[p]:
		if q!=fa:
			sonq = [];
			for j in range(size[q]):
				if to[q][j] != p:
					sonq.append((ans[to[q][j]][0], ans[to[q][j]][1]));
			sonq.sort(cmp);
			now = ans[p][1]/ans[q][0] * ans[q][1];
			i = 1;
			for v in sonq:
				now = now /v[0] * v[1];
				maxv = max(maxv, now * (i + 2));
				i += 1;

	ans[p] = (maxv, ans[p][1]);

n = input();


##(h[i], f[i]) h[i] the answer, f[i] = product of h[j], j is the son of i
ans = [(1,1) for i in range(1, n + 2)];

##edge
to = [[] for i in range(1, n + 2)];
##count(son of i)
size = [0 for i in range(1, n + 2)];
##read data
for i in range(1, n):
	a, b = map(int, raw_input().split());
	to[a].append(b);
	to[b].append(a);
	size[a] += 1;
	size[b] += 1;

DFS(1, -1);
print ans[1][0];