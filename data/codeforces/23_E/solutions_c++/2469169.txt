//CF-23-E Tree
#include<cstdio>
#include<vector>
#include<cstring>
#define ll long long
#define N 701
#define sz 100000000
#define pb push_back
#define rep(i,n) for(int i=0;i<n;i++)
#define For(i,n) for(int i=1;i<=n;i++)
#define repD(i,n) for(int i=n-1;i>=0;i--)
#define ForD(i,n) for(int i=n;i;i--)
using namespace std;
struct bint
{
	ll a[40];
	bint(int x=0){memset(a,0,sizeof(a));a[0]=1;a[1]=x;}
	ll & operator [](int k) {return a[k];}
	const ll & operator [](int k) const {return a[k];}
	bint operator *(const bint &b)
	{
		if(b[0]*b[1]==1) return *this;
		bint c;
		For(i,a[0])
		    For(j,b[0])
		        c[i+j-1]+=a[i]*b[j];
		c[0]=a[0]+b[0]-1;
		For(i,c[0])
		    if (c[i]>=sz)
		    {
				c[i+1]+=c[i]/sz;
				c[i]%=sz;
			}
		if (c[c[0]+1]) c[0]++;
		return c;
	}
	bool operator <(const bint &b)
	{
		if (a[0]!=b[0]) return a[0]<b[0];
		ForD(i,a[0])
		    if (a[i]!=b[i]) return a[i]<b[i];
		return 0;
	}
	void print()
	{
		printf("%d",a[a[0]]);
		ForD(i,a[0]-1) printf("%.8d",a[i]);
		puts("");
	}
}f[N][N];

bint max(bint &a,bint b)
{
	return (a<b?b:a);
}
int n,u,v,s[N];
vector <int> ch[N];

void dfs(int x,int fa)
{
	f[x][1]=bint(1);
	s[x]=1;
	rep(pt,ch[x].size())
	{
		int v=ch[x][pt];
		if (v==fa) continue;
		dfs(v,x);
		ForD(i,s[x])
			repD(j,s[v]+1)
			    f[x][i+j]=max(f[x][i+j],f[x][i]*f[v][j]);

		s[x]+=s[v];
	}
	f[x][0]=bint(s[x]);
	For(i,s[x])
		f[x][0]=max(f[x][0],f[x][i]*bint(i));
}
int main()
{
	scanf("%d",&n);
	rep(i,n-1)
	{
		scanf("%d%d",&u,&v);
		ch[u].pb(v);
		ch[v].pb(u);
	}
	dfs(1,0);
	f[1][0].print();
}
