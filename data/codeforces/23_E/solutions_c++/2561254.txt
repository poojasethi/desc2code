#include <vector>
#include <cstdio>
#include <set>
#include <map>
#include <algorithm>
#include <cstdlib>
#include <sstream>
#include <numeric>
#include <queue>
#include <iostream>
#include <string>
#include <cstring>
#include <utility>
#define sz(a) ((int)(a).size())
#define pb push_back
#define mk make_pair
#define fi first
#define se second
#define Rep(i,j,k) for (int i=(j); i<=(k); i++)
#define Repd(i,j,k) for (int i=(j); i>=(k); i--)
#define ALL(c) (c).begin(),(c).end()
#define TR(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define SUM(a) accumulate(all(a),string())
#define online1
#define RAND ((rand()<<15)+rand())
using namespace std;
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef pair<int,int> II;
typedef long long LL;

const int N=710;
const int base=1000;

struct INT{
	int len;
	int a[50];
	
	INT(int x=0){
		memset(a,0,sizeof a); len=0;
		if (x==0) len=1; else
			while(x)
				a[++len]=x%base, x/=base;
	}
	
	void print(){
		Repd(i,len,1) if (i==len) printf("%d",a[i]); else printf("%03d",a[i]);
		cout<<endl;
	}
};

bool operator<(const INT &x, const INT &y){
	if (x.len<y.len) return 1;
	if (x.len>y.len) return 0;
	Repd(i,x.len,1){
		if (x.a[i]<y.a[i])return 1;
		if (x.a[i]>y.a[i])return 0;
	}
	return 0;
}

INT operator*(const INT &x, const INT &y){
	INT z;
	Rep(i,1,x.len)
		Rep(j,1,y.len)
			z.a[i+j-1]+=x.a[i]*y.a[j];
	z.len=x.len+y.len-1;
	Rep(i,1,z.len)
		z.a[i+1]+=z.a[i]/base,
		z.a[i]%=base;
	if (z.a[z.len+1]) z.len++;
	while(z.len>1 && !z.a[z.len]) z.len--;
	return z;
}

int n, size[N];
VI E[N];
INT f[N][N];

void dfs(int x, int fa){
	f[x][0]=INT(1); f[x][1]=INT(1);
	size[x]=1;
	TR(E[x],y)
		if (*y!=fa){
			dfs(*y,x);
			Repd(i,size[x],0)
				Repd(j,size[*y],0)
					f[x][i+j]=max(f[x][i+j], f[x][i]*f[*y][j]);
			size[x]+=size[*y];
		}
	Repd(i,size[x],0)
		f[x][0]=max(f[x][0],f[x][i]*i);
}

int main(){

	
	cin>>n;
	Rep(i,1,n-1){
		int x,y;
		scanf("%d%d",&x,&y);
		E[x].pb(y);
		E[y].pb(x);
	}
	
	dfs(1,0);
	
	f[1][0].print();

    return 0;
}
