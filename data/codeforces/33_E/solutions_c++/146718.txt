#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <string>
#include <cmath>
#include <climits>
#include <vector>
#include <map>
#include <set>
#include <iterator>
#include <utility>
#include <numeric>
#include <memory>
#include <stack>
#include <deque>
#include <queue>
#include <list>
#include <functional>
#include <iomanip>
#include <sstream>
#include <cctype>
#include <bitset>

#define X first
#define Y second
#define MAX(x, y) x = x > (y) ? x : (y)
#define MIN(x, y) x = x > (y) ? (y) : x
#define LOW(x) ((x) & -(x))
#define SQR(x) ((x) * (x))
#define REP(i, n) for (int i = 0; i < (n); ++i)
#define FOR(i, a, b) for (int i = (a); i < (b); ++i)
#define rFOR(i, b, a) for (int i = (b); i > (a); --i)
#define CLEAR(x) memset(x, 0, sizeof(x))
#define FILL(x, p) memset(x, p, sizeof(x))
#define COPY(x, y) memcpy(x, y, sizeof(x))
#define ALL(x) (x).begin(), (x).end()

using namespace std;

typedef long long ll;
typedef unsigned int ui;
typedef pair<int, int> PII;
typedef vector<PII> VPII;
typedef vector<int> VI;
typedef vector<string> VS;

const int INF = 0x3fffffff;
const ll _INF = 0x7ffffffffffffffll;
const double EPS = 1e-9;
const double PI = acos(-1.0);

template<class T, class INT>
inline T pow(T x, INT y)
{
	T res(1);
	for (T tt(x); y; y /= 2)
	{
		if (y & 1) res *= tt;
		tt *= tt;
	}
	return res;
}

template<class T, class INT>
inline T pow(T x, INT y, T p)
{
	T res(1);
	for (T tt(x); y; y /= 2)
	{
		if (y & 1) res = res * tt % p;
		tt = tt * tt % p;
	}
	return res;
}

int toInt(string s)
{
	int x = 0;
	istringstream sin(s);
	sin >> x;
	return x;
}

template<class T>
inline string toString(T x)
{
	ostringstream sout;
	sout << x;
	return sout.str();
}

template<class INT>
inline INT gcd(INT x, INT y)
{
	return y ? gcd(y, x % y) : x;
}

template<class INT>
inline int calc_bits(INT x)
{
	return x ? (x & 1) + calc_bits(x >> 1) : 0;
}

const int MAXN = 100 + 10;
const int MAXM = 24 * 60 * 30 + 10;

int n, m, k, tot, f[MAXN][MAXM], r, u, p, b[4][2], g[MAXN][MAXM];
string a[MAXN], s, st;
map<string, int> aa;
struct Node
{
	int c, v, t, p;
} c[MAXN];

inline bool cmp(Node a, Node b)
{
	return a.t < b.t;
}

int change(string s)
{
	return toInt(s.substr(0, 2)) * 60 + toInt(s.substr(3, 2));
}

void _change(int x, int& d, string& t)
{
	d = (x - 1) / tot + 1;
	x = (x - 1) % tot + 1;
	REP(i, 4)
		if (b[i][0] < x) x += b[i][1] - b[i][0] + 1;
	t = toString((x - 1) / 60) + ":" + toString((x - 1) % 60);
	if (t.find(':') == 1) t = "0" + t;
	if (t.size() == 4) t.insert(3, "0");
}

void prt(int n, int m, int x)
{
	if (n)
		if (g[n][m] == 2)
		{
			prt(n - 1, m - c[n - 1].c, x + 1);
			int d1, d2;
			string t1, t2;
			_change(m - c[n - 1].c + 1, d1, t1);
			_change(m, d2, t2);
			cout << c[n - 1].p << " " << d1 << " " << t1 << " " << d2 << " " << t2 << endl;
		}
		else if (g[n][m] == 0)
			prt(n - 1, m, x);
		else
			prt(n, m - 1, x);
	else
		cout << x << endl;
}

int main(int argc, char* argv[])
{
	cin >> m >> n >> k;
	REP(i, m) cin >> a[i];
	REP(i, m)
	{
		cin >> u;
		aa[a[i]] = u;
	}
	tot = 24 * 60;
	REP(i, 4)
	{
		cin >> s;
		b[i][0] = change(s.substr(0, 5));
		b[i][1] = change(s.substr(6, 5));
		tot -= b[i][1] - b[i][0] + 1;
	}
	REP(i, n)
	{
		cin >> s >> r >> st >> c[i].v;
		c[i].c = aa.count(s) ? aa[s] : INF / 10;
		p = change(st);
		REP(j, 4)
			if (b[j][0] <= p && p <= b[j][1]) p = b[j][0];
		c[i].t = r * tot - tot + p;
		REP(j, 4)
			if (b[j][1] < p) c[i].t -= b[j][1] - b[j][0] + 1;
		c[i].p = i + 1;
	}
	sort(c, c + n, cmp);
	REP(i, n + 1)
		REP(j, tot * k + 1)
		{
			if (i < n && j + c[i].c <= c[i].t && f[i][j] + c[i].v > f[i + 1][j + c[i].c])
			{
				f[i + 1][j + c[i].c] = f[i][j] + c[i].v;
				g[i + 1][j + c[i].c] = 2;
			}
			if (f[i][j] > f[i + 1][j])
			{
				f[i + 1][j] = f[i][j];
				g[i + 1][j] = 0;
			}
			if (f[i][j] > f[i][j + 1])
			{
				f[i][j + 1] = f[i][j];
				g[i][j + 1] = 1;
			}
		}
	cout << f[n][tot * k] << endl;
	prt(n, tot * k, 0);
}
