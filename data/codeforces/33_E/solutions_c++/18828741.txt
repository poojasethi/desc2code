#include <bits/stdc++.h>
using namespace std;

struct Student
{
    int dur, bytime, pay, index;
};

const int MAXN = 105;
const int MAXTIMEMINS = 50000;
int n, m, tdays, mt1, mtall;
map<string ,int> slist;
int stime[MAXN];
int schedule[4][2];
int dp[MAXTIMEMINS];
int path[MAXTIMEMINS][MAXN];
int pre[MAXTIMEMINS];
int ansarr[MAXN][2];
int anslen;
int helplist[MAXN];
int paylist[MAXN];
Student stus[MAXN];

bool comp(Student a, Student b)
{
    return a.bytime < b.bytime || a.bytime == b.bytime && a.pay > b.pay;
}

int TimeDiff(int a, int b)
{
    return a / 100 * 60 + a % 100 - b / 100 * 60 - b % 100;
}

void ConverTimeToInt(char *timest, int *a)
{
    a[0] = (timest[0] - '0') * 1000 + (timest[1] - '0') * 100 + (timest[3] - '0') * 10 + (timest[4] - '0') * 1;
    a[1] = (timest[6] - '0') * 1000 + (timest[7] - '0') * 100 + (timest[9] - '0') * 10 + (timest[10] - '0') * 1;

    return;
}

int CalcMaxTime()
{
    int ret = 0;

    ret += TimeDiff(schedule[0][0], 0);
    for(int i = 0; i < 3; i ++)
        ret += TimeDiff(schedule[i + 1][0], schedule[i][1]) - 1;
    ret += TimeDiff(2359, schedule[3][1]);
    return ret;
}

int CalcTimeInDay(int t)
{
    int ret = 0;

    if(t >= schedule[0][0])
        ret += TimeDiff(schedule[0][0], 0);
    else
    {
        ret += TimeDiff(t, 0) + 1;
        return ret;
    }

    for(int i = 0; i < 3; i ++)
    if(t >= schedule[i + 1][0])
        ret += TimeDiff(schedule[i + 1][0], schedule[i][1]) - 1;
    else
    {
        ret += max(TimeDiff(t, schedule[i][1]), 0);
        return ret;
    }

    ret += max(TimeDiff(t, schedule[3][1]), 0);

    return ret;
}

int ConvertTimeByDelta(int starttime, int delta)
{
    return (starttime / 100 + (starttime % 100 + delta) / 60) * 100 + (starttime % 100 + delta) % 60;
}

int IntToTime(int t)
{
    int sum = 0, ret;

    if(TimeDiff(schedule[0][0], 0) >= t)
    {
        ret = ConvertTimeByDelta(0, t - 1);
        return ret;
    }
    else
        sum += TimeDiff(schedule[0][0], 0);

    for(int i = 0; i < 3; i ++)
    if(sum + TimeDiff(schedule[i + 1][0], schedule[i][1]) - 1 < t)
        sum += TimeDiff(schedule[i + 1][0], schedule[i][1]) - 1;
    else
    {
        ret = ConvertTimeByDelta(schedule[i][1], t - sum);
        return ret;
    }

    ret = ConvertTimeByDelta(schedule[3][1], t - sum);

    return ret;
}

int CalcMinutes(int day, char *t)
{
    int t0 = (t[0] - '0') * 1000 + (t[1] - '0') * 100 + (t[3] - '0') * 10 + (t[4] - '0');

    return (day - 1) * mt1 + CalcTimeInDay(t0 - 1);
}

void PrintTime(int t)
{
    printf(" %d", (t - 1) / mt1 + 1);
    int s = IntToTime((t - 1) % mt1 + 1);
    printf(" %02d:%02d", s / 100, s % 100);

    return;
}

int main()
{
    char st[40], st0[40], st1[40];
    int ans, ansk;

    // freopen("D:\\1.in", "r", stdin);
    // freopen("D:\\1.out", "w", stdout);

    scanf("%d%d%d", &m, &n, &tdays);
    for(int i = 0; i < m; i ++)
        scanf("%s", st), slist[st] = i;
    for(int i = 0; i < m; i ++)
        scanf("%d", &(stime[i]));

    for(int i = 0; i < 4; i ++)
        scanf("%s", st), ConverTimeToInt(st, schedule[i]);

    mt1 = CalcMaxTime();
    mtall = mt1 * tdays;

    ans = 0; ansk = 0;
    for(int i = 0; i < n; i ++)
    {
        int byday, pay, sindex, dur, bytime;
        scanf("%s%d%s%d", st0, &byday, st1, &pay);
        if(slist.find(st0) == slist.end())
        {
            stus[i].index = -1;
            continue;
        }
        sindex = slist[st0];
        dur = stime[sindex];
        bytime = CalcMinutes(byday, st1);
        helplist[i + 1] = dur;
        paylist[i + 1] = pay;

        stus[i].bytime = bytime;
        stus[i].dur = dur;
        stus[i].index = i + 1;
        stus[i].pay = pay;
    }

    sort(stus, stus + n, comp);

    for(int i = 1; i < MAXTIMEMINS; i ++)
        dp[i] = -1;
    dp[0] = 0;
    path[0][0] = 0;

    for(int i = 0; i < n; i ++)
    {
        if(stus[i].index == -1)
            continue;
        for(int j = stus[i].bytime; j >= stus[i].dur; j --)
        if(dp[j - stus[i].dur] != -1 && dp[j - stus[i].dur] + stus[i].pay > dp[j])
        {
            dp[j] = dp[j - stus[i].dur] + stus[i].pay, pre[j] = stus[i].index;
            for(int k = 1; k <= path[j - stus[i].dur][0]; k ++)
                path[j][k] = path[j - stus[i].dur][k];
            path[j][0] = path[j - stus[i].dur][0] + 1;
            path[j][path[j][0]] = stus[i].index;
            if(dp[j] > ans)
                ans = dp[j], ansk = j;
        }
    }


    printf("%d\n", ans);
    int flag = ansk;
    for(int i = path[ansk][0]; i >= 1; i --)
    {
        ans -= paylist[path[ansk][i]];
        ansarr[anslen][0] = path[ansk][i];
        flag = flag - helplist[path[ansk][i]];
        ansarr[anslen][1] = flag + 1;
        anslen ++;
    }
    printf("%d\n", anslen);
    for(int i = anslen - 1; i >= 0; i --)
    {
        printf("%d", ansarr[i][0]);
        PrintTime(ansarr[i][1]);
        PrintTime(ansarr[i][1] + helplist[ansarr[i][0]] - 1);
        printf("\n");
    }

	return 0;
}
