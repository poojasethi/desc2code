#include<iostream>
#include<fstream>
#include<sstream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<vector>
#include<map>
#include<cstring>
using namespace std;

#define FOR(I,A,B) for (int I=int(A);I<int(B);++I)
#define MEM(A,B) memset(A,B,sizeof(A));
#define CPY(A,B) memcpy(A,B,sizeof(B));
typedef __int64 LL;
const int K(100010), L(1000010);
int n, k, si, m, t;
bool bo[K];
int po[K];
int fail[L], be[L], en[L], c[L], q[L], bro[L], son[L];
int g[L][26];
char s[L];
int low(int x) {return x & -x;}
void add(int x, int v)
{
     for (; x <= si; x += low(x)) c[x] += v;
}
int sum(int x)
{
    int ret(0);
    for (; x; x -= low(x)) ret += c[x];
	return ret;
}
void dfs(int x)
{
     be[x] = ++m;
     for (int p = son[x]; p; p = bro[p]) dfs(p);
	 en[x] = m + 1;
}
int main()
{
    //freopen("in.txt", "r", stdin);
	scanf("%d%d", &n, &k);
	si = 1;
	FOR(i, 0, k) {
	   scanf("%s", s);
	   int len = strlen(s), p(1);
	   FOR(j, 0, len) {
	      if (g[p][s[j] - 'a'] == 0) g[p][s[j] - 'a'] = ++si;
		  p = g[p][s[j] - 'a'];
	   }
	   bo[i] = 1;
	   po[i] = p;
	}
	FOR(i, 0, 26) 
	   if (g[1][i]) {
	      q[t++] = g[1][i];
		  fail[q[t - 1]] = 1;
	   }
	   else g[1][i] = 1;
	FOR(h, 0, t) 
	   FOR(i, 0, 26)
	      if (g[q[h]][i]) {
		     q[t++] = g[q[h]][i];
			 fail[q[t - 1]] = g[fail[q[h]]][i];
		  }
		  else g[q[h]][i] = g[fail[q[h]]][i];
	FOR(i, 2, si + 1) {
	   bro[i] = son[fail[i]];
	   son[fail[i]] = i;
	}
	dfs(1);
	FOR(i, 0, k) {
	   add(be[po[i]], 1);
	   add(en[po[i]], -1);
	}
	for (; n; --n) {
	    scanf("%s", s);
		int len = strlen(s + 1);
		if (s[0] == '?') {
           LL ans = 0;
		   for (int i = 1, p = 1; i <= len; ++i) {
		       p = g[p][s[i] - 'a'];
			   ans += sum(be[p]);
		   }
		   printf("%I64d\n", ans);
		}
		else {
		     int num = 0;
			 FOR(i, 1, len + 1)
			    num = num * 10 + s[i] - '0';
			 --num;
			 if (s[0] == '+' && !bo[num]) {
                bo[num] = 1;
			    add(be[po[num]], 1); add(en[po[num]], -1);
			 }
			 else if (s[0] == '-' && bo[num]) {
                  bo[num] = 0;
			      add(be[po[num]], -1); add(en[po[num]], 1);
			 }
		}
	}
	return 0;
}
