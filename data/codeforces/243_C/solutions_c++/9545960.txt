#include <stdio.h>
#include <algorithm>

char ch;
inline void read(int &x)
{
	x=0;ch=getchar();
	while (ch<=32) ch=getchar();
	while (ch>32) x=x*10+ch-48,ch=getchar();
}

const int dx[4]={0,1,0,-1};
const int dy[4]={1,0,-1,0};

#define INF 0x3f3f3f3f

#define MAXN 1005

int n;
int m;
int mx,my;
int x1[MAXN],y1[MAXN],x2[MAXN],y2[MAXN];
int _x[MAXN*2],_y[MAXN*2];
bool a[MAXN*2][MAXN*2];
bool visit[MAXN*2][MAXN*2];

inline void add(int x,int y)
{
	_x[++m]=x,_y[m]=y;
}

inline int find(int *a,int x,int m)
{
	int l=1,r=m;
	while (l<r) {
		int mid=(l+r+1)>>1;
		if (a[mid]>x) r=mid-1; else l=mid;
	}
	return l;
}

inline void cover(int x1,int y1,int x2,int y2)
{
	x1=find(_x,x1,mx);x2=find(_x,x2,mx);
	y1=find(_y,y1,my);y2=find(_y,y2,my);
	if (x1>x2) std::swap(x1,x2);
	if (y1>y2) std::swap(y1,y2);
	int i,j;
	for (i=x1;i<=x2;i++) {
		for (j=y1;j<=y2;j++) a[i][j]=1;
	}
}

int l1[MAXN*2*MAXN*2],l2[MAXN*2*MAXN*2];

inline void solve()
{
	std::sort(_x+1,_x+m+1);
	std::sort(_y+1,_y+m+1);
	int i,j;
	mx=1;
	for (i=2;i<=m;i++) {
		if (_x[i]!=_x[mx]) _x[++mx]=_x[i];
	}
	my=1;
	for (i=2;i<=m;i++) {
		if (_y[i]!=_y[my]) _y[++my]=_y[i];
	}
	cover(0,0,0,0);
	for (i=1;i<=n;i++) {
		cover(x1[i],y1[i],x2[i],y2[i]);
	}
	int s=0,t=1;
	visit[1][1]=1;
	l1[1]=1;l2[1]=1;
	while (s<t) {
		int x=l1[++s],y=l2[s];
		for (i=0;i<4;i++) {
			int nx=x+dx[i],ny=y+dy[i];
			if (nx<1 || nx>mx || ny<1 || ny>my) continue;
			if (a[nx][ny] || visit[nx][ny]) continue;
			visit[nx][ny]=1;
			l1[++t]=nx,l2[t]=ny;
		}
	}
	long long ans=0;
	for (i=1;i<mx;i++) {
		for (j=1;j<my;j++) {
			if (!visit[i][j]) {
				ans+=(1LL*_x[i+1]-_x[i])*(1LL*_y[j+1]-_y[j]);
			}
		}
	}
	printf("%I64d\n",ans);
}

int main()
{
	read(n);
	int i;
	int x=0,y=0;
	add(x,y);
	add(x+1,y+1);
	add(-INF,-INF);
	add(INF,INF);
	for (i=1;i<=n;i++) {
		char ch=getchar();
		while (ch<=32) ch=getchar();
		int d;
		read(d);
		int dx=ch=='U'?-d:ch=='D'?d:0;
		int dy=ch=='L'?-d:ch=='R'?d:0;
		x1[i]=x;y1[i]=y;x2[i]=x+dx;y2[i]=y+dy;
		x+=dx;y+=dy;
		add(x,y);
		add(x+1,y+1);
	}
	solve();
}
  				    	  	  		 		 		 				 	