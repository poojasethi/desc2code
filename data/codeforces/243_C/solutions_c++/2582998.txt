#include <cstdio>
#include <cstring>
#include <cctype>
#include <cmath>
#include <stack>
#include <string>
#include <algorithm>
#include <vector>
#include <map>
#include <set>
#include <queue>
using namespace std;
#define INF 0x3f3f3f3f
#define REP(i,n) for(int64 i=0; i<(n); i++)
typedef long long int64;

int64 x[1010],y[1010];
int64 us[3010][3010];
vector<int64> xs, ys;

void fill(int64 x1, int64 y1, int64 x2, int64 y2) {
	x1=lower_bound(xs.begin(),xs.end(),x1)-xs.begin();
	x2=lower_bound(xs.begin(),xs.end(),x2)-xs.begin();
	y1=lower_bound(ys.begin(),ys.end(),y1)-ys.begin();
	y2=lower_bound(ys.begin(),ys.end(),y2)-ys.begin();

	if (x1>x2) swap(x1,x2);
	if (y1>y2) swap(y1,y2);

	for (int64 i=x1;i<=x2;i++)
		for (int64 j=y1;j<=y2;j++)
			us[i][j]=1;
}

int64 u[]={-1,0,0,1}, v[]={0,-1,1,0};

void dfs(int64 x, int64 y) {
	if (x<0 || y<0 || x>=xs.size() || y>=ys.size() || us[x][y]) return;
	us[x][y]=2;
	
	REP(k,4)
		dfs(x+u[k],y+v[k]);
}

int main() {
	int64 n;

	while (scanf("%I64d",&n)==1) {
		int64 cx=0, cy=0,p;
		char c;
		xs.clear();
		ys.clear();
		
		REP(i,n+1) {
			REP(k,3) {
				xs.push_back(cx+k-1);
				ys.push_back(cy+k-1);
			}
			if (i==n) break;
			
			scanf(" %c %I64d",&c,&p);
			if (c=='R') cx+=p;
			if (c=='L') cx-=p;
			if (c=='U') cy-=p;
			if (c=='D') cy+=p;
			x[i+1]=cx; y[i+1]=cy;
		}

		sort(xs.begin(),xs.end());
		sort(ys.begin(),ys.end());

		xs.erase(unique(xs.begin(),xs.end()),xs.end());
		ys.erase(unique(ys.begin(),ys.end()),ys.end());

		memset(us,0,sizeof(us));
		REP(i,n)
			fill(x[i],y[i],x[i+1],y[i+1]);

		dfs(0,0);

		int64 res=0;
		REP(i,xs.size()-1)
			REP(j,ys.size()-1)
				if (us[i][j]<2) res+=(xs[i+1]-xs[i])*(ys[j+1]-ys[j]);

		printf("%I64d\n",res);
	}
	return 0;
}
