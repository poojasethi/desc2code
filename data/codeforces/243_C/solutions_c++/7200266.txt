#include <stdio.h>
#include <algorithm>
#define N 3010

using namespace std;

typedef __int64 INT;
const INT inf = 10000000001L;
INT stox[N];
INT stoy[N];
bool vis[N][N];
bool can[N][N];
int cx, cy;
INT x[N], y[N], xx[N], yy[N];
int dx[] = {0, 1, 0, -1};
int dy[] = {1, 0, -1, 0};

int Direct(char c) {
	if (c == 'U') return 0;
	if (c == 'R') return 1;
	if (c == 'D') return 2;
	return 3;
}

void DFS(int sx, int sy) {
	vis[sx][sy] = 1;
	for (int i = 0; i < 4; i ++) {
		int ex = sx + dx[i];
		int ey = sy + dy[i];
		if (ex < 0 || ex >= cx || ey < 0 || ey >= cy) continue;
		if (can[ex][ey]) continue;
		if (vis[ex][ey]) continue;
		DFS(ex, ey);
	}
}

int main() {
	int n;
//	freopen ("C.in", "r", stdin);
	scanf("%d", &n);
	cx = cy = 0;
	INT ans = 0;
	stox[cx ++] = 0; stox[cx ++] = 1; stox[cx ++] = -inf, stox[cx ++] = inf;
	stoy[cy ++] = 0; stoy[cy ++] = 1; stoy[cy ++] = -inf, stoy[cy ++] = inf;
	INT sx = 0, sy = 0;
	for (int i = 0; i < n; i ++) {
		char s[10];
		int d;
		scanf("%s %d", s, &d);
		int dir = Direct(s[0]);
		x[i] = sx, y[i] = sy;
		sx += d * dx[dir], sy += d * dy[dir];
		stox[cx ++] = sx, stoy[cy ++] = sy;
		stox[cx ++] = sx + 1, stoy[cy ++] = sy + 1;
		xx[i] = sx, yy[i] = sy;
	}
	sort(stox, stox + cx);
	sort(stoy, stoy + cy);
	cx = unique(stox, stox + cx) - stox;
	cy = unique(stoy, stoy + cy) - stoy;
	for (int i = 0; i < n; i ++) {
		int ax = lower_bound(stox, stox + cx, x[i]) - stox;
		int ay = lower_bound(stoy, stoy + cy, y[i]) - stoy;
		int bx = lower_bound(stox, stox + cx, xx[i]) - stox;
		int by = lower_bound(stoy, stoy + cy, yy[i]) - stoy;
		if (ax > bx) ax ^= bx ^= ax ^= bx;
		if (ay > by) ay ^= by ^= ay ^= by;
		for (int j = ax; j <= bx; j ++)
			for (int k = ay; k <= by; k ++)
				can[j][k] = 1;
	}
	DFS(0, 0);
	for (int i = 0; i < cx - 1; i ++)
		for (int j = 0; j < cy - 1; j ++) if (!vis[i][j]) {
			sx = stox[i], sy = stoy[j];
			INT ex, ey;
			ex = stox[i + 1];
			ey = stoy[j + 1];
			ans += (ex - sx) * (ey - sy);
		}
	printf("%I64d\n", ans);


}
