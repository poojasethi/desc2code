#include <iostream>
#include <map>
#include <set>
#include <queue>
#include <deque>

using namespace std;

struct pos {
	int a;
	int b;
};

pos makePos(int a, int b)
{
	pos p;
	p.a = a;
	p.b = b;
	return p;
}

int deg[501];
int neighbors[501][501];
int prev[501][501][2];
bool checked[501][501];

int main()
{
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b;
		cin >> a >> b;
		neighbors[a][deg[a]++] = b;
		neighbors[b][deg[b]++] = a;
	}
	queue<pos> queue;
	queue.push(makePos(1, n));
	bool breakout = false;
	prev[1][n][0] = prev[1][n][1] = -1;
	while (!queue.empty()) {
		pos p = queue.front();
		queue.pop();
		for (int i = 0; i < deg[p.a]; i++) {
			int a = neighbors[p.a][i];
			if (checked[a][p.b]) {
				continue;
			}
			checked[a][p.b] = true;
			for (int j = 0; j < deg[p.b]; j++) {
				int b = neighbors[p.b][j];
				if (a == b) {
					continue;
				}
				if (prev[a][b][0] == 0) {
					prev[a][b][0] = p.a;
					prev[a][b][1] = p.b;
					queue.push(makePos(a,b));
				}
				if (a == n && b == 1) {
					breakout = true;
					break;
				}
			}
			if (breakout) break;
		}
		if (breakout) break;
	}

	if (breakout) {
		deque<int> asteps;
		deque<int> bsteps;
		pos p = makePos(n, 1);
		while (1) {
			if (prev[p.a][p.b][0] == -1) {
				asteps.push_front(p.a);
				bsteps.push_front(p.b);
				break;
			}
			asteps.push_front(p.a);
			bsteps.push_front(p.b);
			p = makePos(prev[p.a][p.b][0], prev[p.a][p.b][1]);
		}
		int sz = asteps.size();
		cout << sz - 1 << endl;
		for (int i = 0; i < sz; i++) {
			cout << asteps[i] << " ";
		}
		cout << endl;
		for (int i = 0; i < sz; i++) {
			cout << bsteps[i] << " ";
		}
		cout << endl;
	}
	else {
		cout << -1 << endl;
	}

	return 0;
}
