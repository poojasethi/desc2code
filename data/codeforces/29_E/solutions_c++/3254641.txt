//By Lin
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<set>
#include<map>
#include<queue>

#define sqr(x) ((x)*(x))
#define Rep(i,n) for(int i = 0; i<n; i++)
#define foreach(i,n) for( __typeof(n.begin()) i = n.begin(); i!=n.end(); i++)
#define X first
#define Y second
#define mp(x,y) make_pair(x,y)

using namespace std;
typedef long long LL;
typedef pair<int,int> pii;

#define N 505
#define M 10010
int		ecnt;
struct	Edge{
	int to;
	Edge *next;
}*mat[N],edges[M*2];
void	link(int x,int to){
	edges[ecnt].to = to;
	edges[ecnt].next = mat[x];
	mat[x] = &edges[ecnt++];
}

queue<pii> 	que;
int		n,m,dis[501][501];
pii		from[501][501];
bool	mark[501][501];

int		solve(){
	que.push( mp(1,n) );
	while ( !que.empty() ) {
		int x = que.front().X , y = que.front().Y;
		que.pop();
		for ( Edge *p1 = mat[x]; p1 ; p1 = p1->next ){
			if ( mark[p1->to][y] ) continue;
			mark[p1->to][y] = true;
			for ( Edge *p2 = mat[y]; p2 ; p2 = p2->next ){
				int g = p1->to , h = p2->to;
				if ( dis[g][h]!=-1 || g == h ) continue;
				dis[g][h] = dis[x][y]+1;
				que.push( mp(g,h) );
				from[g][h] = mp(x,y);
				if ( g == n && h == 1 ) return dis[g][h];
			}
		}
	}
	return -1;
}

void	writ(int x,int y,int t){
	if ( dis[x][y] ) writ( from[x][y].X , from[x][y].Y , t );
	printf(dis[x][y]?" %d":"%d" , t?y:x );
}

int		main(){
	scanf("%d%d", &n, &m );
	while ( m -- ) {
		int x,y;
		scanf("%d%d", &x, &y );
		link( x , y );
		link( y , x );
	}
	memset( dis , -1 , sizeof(dis) );
	dis[1][n] = 0;
	printf("%d\n" , solve() );
	if ( dis[n][1] == -1 ) return 0;
	writ(n,1,0);
	puts("");
	writ(n,1,1);
	puts("");
	return 0;
}
