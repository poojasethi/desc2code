#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>

using namespace std;

int n, m;
vector<vector<int> > G;

int state[505][505][2];
struct State {
  int a, b, who;
  State(){};
  State(int _a, int _b, int _who) {a = _a; b = _b; who = _who;}
};
int main() {
  cin >> n >> m;
  G.resize(n+5);
  while (m--) {
    int a, b;
    cin >> a >> b;
    G[a].push_back(b);
    G[b].push_back(a);
  }
  queue<State> Q;
  Q.push(State(1, n, 0));
  state[1][n][0] = 1;
    int found = 0;
    State final;
  while (!Q.empty()) {
    State X = Q.front(); Q.pop(); 
    if (X.a == n && X.b == 1 && X.who == 0) {
      found = 1; final = X; break;
    }
    
    // try next move
    for (int i = 0; i < G[X.a].size(); ++i) {
      // legala
      if (X.who == 1 && G[X.a][i] == X.b) continue;
      // nevisitata
      if (state[X.b][G[X.a][i]][X.who^1]) continue;
      state[X.b][G[X.a][i]][X.who^1] = X.a;
      Q.push(State(X.b, G[X.a][i], X.who^1));
    }
  }

  if (found) {
    vector<int> sol[2];
    while (1) {
      sol[final.who^1].push_back(final.b);
      if (final.a == 1 && final.b == n && final.who == 0) break;
      int fr = state[final.a][final.b][final.who];
      final.who^=1;
      swap(final.a, final.b);
      final.a = fr;
    }
    cout << sol[0].size() << '\n';
    sol[0].push_back(1);
    for (int j = 0; j < 2; ++j)
    for (int i = sol[j].size() - 1; i >= 0; --i) {
      cout << sol[j][i];
      if (i != 0) cout << " ";
      else cout << "\n";
    }
  } else {
    cout << "-1\n";
  }
  return 0;
}
