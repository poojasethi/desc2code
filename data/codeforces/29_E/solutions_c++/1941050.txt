#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<vector>
//#include<cmath>
#include<algorithm>
#include<iomanip>
//#include<set>
//#include<map>
//#include<fstream>
#include<queue>
//#include<deque>
//#include<utility>
#include<cstring>
#define pb push_back
#define mkp make_pair
#define X first
#define Y second
#define pii pair<int,int>
#define foR(i,a,b) for(int(i)=int(a);int(i)<int(b);++i)
#define state pair<pair<int,int>,int> 
typedef long long ll;
using namespace std;
const ll maxn=510,inf=1e12;
vector<int> adj[maxn],ans[3];
state p[maxn][maxn][2];
int l[maxn][maxn][2];
bool mark[maxn][maxn][2];
queue<state > q;
void show(state pr){
	int x=pr.X.X,y=pr.X.Y,t=pr.Y;
	if(x==-1&y==-1)
		return;
	show(p[x][y][t]);
	if(!t){
		ans[0].pb(x);
		ans[1].pb(y);
	}
}
int main(){
	int n,m;
	cin>>n>>m;
	foR(i,0,m){
		int u,v;
		cin>>u>>v;u--;v--;
		adj[u].pb(v);
		adj[v].pb(u);
	}
	foR(i,0,maxn)
		foR(j,0,maxn)
		p[i][j][0]=p[i][j][1]=mkp(mkp(-1,-1),0);
	mark[0][n-1][0]=true;q.push(mkp(mkp(0,n-1),0));
	while(!q.empty()){
		state pr=q.front();q.pop();
		int x=pr.X.X,y=pr.X.Y,t=pr.Y;
		if(t){
			foR(i,0,adj[y].size()){
				int next=adj[y][i];
				if(!mark[x][next][1-t]&&next!=x){
					p[x][next][1-t]=mkp(mkp(x,y),t);
					l[x][next][1-t]=l[x][y][1];
					mark[x][next][1-t]=true;
					q.push(mkp(mkp(x,next),1-t));
				}
			}
		}
		else{
			foR(i,0,adj[x].size()){
				int next=adj[x][i];
				if(!mark[next][y][1-t]){
					p[next][y][1-t]=mkp(mkp(x,y),t);
					l[next][y][1-t]=l[x][y][0]+1;
					mark[next][y][1-t]=true;
					q.push(mkp(mkp(next,y),1-t));
				}
			}
		}
	}
	show(mkp(mkp(n-1,0),0));
	if(ans[0].size()==1)
		cout<<-1<<endl;
	else{
		cout<<l[n-1][0][0]<<endl;
		foR(i,0,2){
			foR(j,0,ans[i].size())
				cout<<ans[i][j]+1<<' ';
			cout<<endl;
		}
	}
	return 0;
}

