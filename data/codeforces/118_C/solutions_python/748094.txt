r = lambda: raw_input().strip()

def find_min(d):
    new_num = list(num)
    current_count = counts[d]
    distance = 1
    ordd = ord(d)
    cost = 0
    while True:
        for i,c in enumerate(new_num):
            if ord(c)-ordd == distance:
                new_num[i] = d
                current_count += 1
                cost += distance
                if current_count == k:
                    return (cost,''.join(new_num))
        new_num = new_num[::-1]
        for i,c in enumerate(new_num):
            if ord(c)-ordd == -distance:
                new_num[i] = d
                current_count += 1
                cost += distance
                if current_count == k:
                    return (cost,''.join(new_num[::-1]))
        new_num = new_num[::-1]
        distance += 1


n,k = map(int,r().split())
num = r()

digits = set(list(num))
counts = dict.fromkeys(digits,0)
for c in num:
    counts[c] += 1
if max(counts.values()) >= k:
    print 0
    print num
else:
    possible = [find_min(d) for d in digits]
    cost,new_num = min(possible)
    print cost
    print new_num
