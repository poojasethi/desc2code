#include <stdio.h>
#include <vector>
#include <algorithm>
#include <utility>
using namespace std;

typedef pair <int, int> pii;
typedef long long ll;
const int MAX = 2e3 + 1;
int n, m, cnt;
pii pos[3];
ll a[MAX], sumA, b[MAX], sumB, res;

struct Node{
	ll val;
	int i, j;
	Node(const ll& val, const int& i, const int& j) : val(val), i(i), j(j) {}
};
vector <Node> twoA, twoB;
bool cmp(const Node& x, const Node& y){
	return x.val < y.val;
}

int main(){
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i){
		scanf("%lld", a + i);
		sumA += a[i];
		for (int j = 1; j < i; ++j)
			twoA.push_back(Node(a[j] + a[i], j, i));
	}

	scanf("%d", &m);
	for (int i = 1; i <= m; ++i){
		scanf("%lld", b + i);
		sumB += b[i];
		for (int j = 1; j < i; ++j)
			twoB.push_back(Node(b[j] + b[i], j, i));
	}

	res = abs(sumA - sumB);
	cnt = 0;

	for (int i = 1; i <= n; ++i)
	for (int j = 1; j <= m; ++j)
	if (res > abs(sumA - sumB - 2 * a[i] + 2 * b[j])){
		res = abs(sumA - sumB - 2 * a[i] + 2 * b[j]);
		pos[cnt = 1] = pii(i, j);
	}

	sort(twoA.begin(), twoA.end(), cmp);

	for (int j = 0; j < twoB.size(); ++j){
		int lef = 0, rig = twoA.size() - 1;
		while (lef <= rig){
			int mid = (lef + rig) >> 1;
			ll tmp = sumA - sumB - 2 * twoA[mid].val + 2 * twoB[j].val;
			if (res > abs(tmp)){
				res = abs(tmp);
				cnt = 2;
				pos[1] = pii(twoA[mid].i, twoB[j].i);
				pos[2] = pii(twoA[mid].j, twoB[j].j);
			}
			if (tmp < 0)
				rig = mid - 1;
			else

				lef = mid + 1;
		}
	}

	printf("%lld\n%d\n", res, cnt);
	for (int i = 1; i <= cnt; ++i)
		printf("%d %d\n", pos[i].first, pos[i].second);

	return 0;
}