#include <stdio.h>
#include <algorithm>
#include <memory.h>
#include <vector>
using namespace std;
#define M 510

struct dat{
	int in, out, s, w, v;
	dat (int in = 0, int out = 0, int s = 0, int w = 0, int v = 0) : in(in), out(out), s(s), w(w), v(v) {}
} p[M];

bool cmp(dat a, dat b){
	if(a.out != b.out) return a.out < b.out;
	return a.in > b.in;
}

int g[M<<1], f[M][M<<1], n, S;
vector <int> E[M<<1];

int main(){
//	freopen("D.in", "r", stdin);
    scanf("%d %d", &n, &S);
    for (int i = 1; i <= n; i++) scanf("%d %d %d %d %d", &p[i].in, &p[i].out, &p[i].w, &p[i].s, &p[i].v);
    p[n+1] = dat(0, 2*n, S, 0, 0); n++;
    sort(p + 1, p + n + 1, cmp);
    for (int i = 1; i <= n; i++) E[p[i].out].push_back(i);

    for (int i = 1; i <= n; i++) {
		int en = min(S, p[i].w + p[i].s);
		for (int w = p[i].w; w <= en; w++) {
			for (int t = p[i].in; t <= p[i].out; t++) g[t] = 0;
			for (int t = p[i].in; t <= p[i].out; t++) {
				for (int u = 0; u < E[t].size(); u++){
					int j = E[t][u];
					if (p[j].in >= p[i].in && j < i) g[t] = max(g[p[j].in] + f[j][w-p[i].w], g[t]);
				}
				if (t > p[i].in) g[t] = max(g[t], g[t-1]);
			}
			f[i][w] = g[p[i].out] + p[i].v;
			if (w > p[i].w) f[i][w] = max(f[i][w], f[i][w-1]);
		}
		for (int w = en + 1; w <= S; w++) f[i][w] = f[i][en];
	}
    printf("%d\n", f[n][S]);
}
