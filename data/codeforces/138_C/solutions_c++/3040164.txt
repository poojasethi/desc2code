#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <vector>
#include <string>
#include <queue>
#include <stack>
#include <map>
#include <set>
#include <list>
#include <iomanip>

using namespace std;
int n,m;
struct TREE
{
  int pos;
  bool flag;
  int p;
}p[2000010];
int tnum;
int gl[101];
struct MOGU
{
  int pos;
  double v;
}b[100010];
bool cmp1(const TREE &aa,const TREE  &bb)
{
  return aa.pos<bb.pos;
}
bool cmp2(const MOGU &aa,const MOGU & bb)
{
  return aa.pos<bb.pos;
}
int main()
{
  scanf("%d%d",&n,&m);
  TREE temp;
  int a,h;
  int l,r;
  for(int i=1;i<=n;i++)
  {
    scanf("%d%d%d%d",&a,&h,&l,&r);
    temp.pos=a-h;
    temp.p=l;
    temp.flag=1;
    p[tnum++]=temp;

    temp.pos=a;
    temp.p=l;
    temp.flag=0;
    p[tnum++]=temp;

    temp.pos=a+1;
    temp.p=r;
    temp.flag=1;
    p[tnum++]=temp;

    temp.pos+=h;
    temp.p=r;
    temp.flag=0;
    p[tnum++]=temp;
  }
  sort(p,p+tnum,cmp1);
  for(int i=0;i<m;i++)
    scanf("%d%lf",&b[i].pos,&b[i].v);
  sort(b,b+m,cmp2);
  int now=0;
  bool flag;
  double ans=0.0,die=0.0,alive=1.0;
  for(int i=0;i<m;i++)
  {
      while(now<=tnum && b[i].pos>=p[now].pos)
      {
        if(p[now].flag)
          gl[p[now].p]++;
        else
          gl[p[now].p]--;
          now++;
      }
      alive=1.0;
      for(int j=0;j<=100;j++)
        alive*=pow((100-j)/100.0,gl[j]);
      ans+=b[i].v*alive;
  }
  printf("%.5lf\n",ans);
  return 0;
}
