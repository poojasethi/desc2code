# -*- coding: cp1251 -*-
k=[int(j) for j in raw_input("").split()]

n =k[0]  #1
m =k[1]  #2 

i1 =k[2]  #1  
j1 =k[3]  #2 

a =k[4]  #1  вверх вниз  | 
b =k[5]  #2  влево вправо  <= =>

# oops! нужно прооверить, находится ли конфета сразу в нужной позиции))
if (j1==1 and i1 ==1) or (i1==n and j1==1) or (i1==1 and j1==m) or (i1==n and j1==m):
    print("0")

else:
    # неявный баг: поле по горизонтали или вертикали должно быть больше на 1, чем шаг
    # во избежание такого

    if n<=a or m<=b:
        print("Poor Inna and pony!")
    else:

        # проверка возможности дойти до каждой вершины (их 4) без учета корректности
        c=[0]*4

        # 1,1
        if (i1-1)%a ==0 and (j1-1)%b ==0:
           if (abs(i1-1)//a + abs(j1-1)//b)%2 == 0:
                c[0]=max(abs(i1-1)//a, abs(j1-1)//b)

        # n,1  leviy nizhniy
        if (i1-n)%a ==0 and (j1-1)%b ==0:
            if (abs(i1-n)//a + abs(j1-1)//b)%2 == 0:
                c[1]=max(abs(i1-n)//a, abs(j1-1)//b)
            
        # 1,m  leviy nizhniy
        if (i1-1)%a ==0 and (j1-m)%b ==0:
            if (abs(i1-1)//a + abs(j1-m)//b)%2 == 0:
                c[2]=max(abs(i1-1)//a, abs(j1-m)//b)

        # n,m  leviy nizhniy
        if (i1-n)%a ==0 and (j1-m)%b ==0:
            if (abs(i1-n)//a + abs(j1-m)//b)%2 == 0:
                c[3]=max(abs(i1-n)//a, abs(j1-m)//b)



        if c.count(0)==4:
            print("Poor Inna and pony!")
        else:
            c=set(c)
            c.discard(0)
            
            print(min(c))




