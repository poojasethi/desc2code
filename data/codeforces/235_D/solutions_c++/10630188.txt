#include<cstdio>
#include<cstring>
#include<algorithm>
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
#define ms(x,y) memset(x,y,sizeof(x))
using namespace std;

const int N = 3005;
bool flag[N] , v[N];
int n;
int adj[N<<1] , next[N<<1] , g[N] , tot;
int stack[N] , stn , kai;
double ans;

void ins(int x,int y)
{
    adj[++tot]=y; next[tot]=g[x]; g[x]=tot;
}

void find_h(int x,int fa)
{
    v[x] = 0;
    for(int p=g[x];p;p=next[p])
    if (v[adj[p]])
    {
        stack[++stn]=adj[p];
        find_h(adj[p],p);
        if (tot) return;
        stack[stn--]=-1;
    }
    else
    if ((p^1) != fa && stn>0)
        while (stack[stn+1] != adj[p])
        flag[stack[stn--]]=1 , tot++;
}

void Init()
{
    scanf("%d",&n);
    int x,y;
    tot = 1;
    fo(i,1,n)
    {
        scanf("%d%d",&x,&y);
        ins(x,y); ins(y,x);
    }
    
    ms(stack,255);
    ms(v,1);
    stack[stn=1]=1;
    tot=0;
    find_h(1,0);
}

//x当前点，a距离开始点距离,c环上走的点数
void dfs(int x,int a,int c)
{
    double temp = ans;
    if (x != kai)
    {
        if (tot==2 || c<=1)
        {
            ans += 1 / double(a);
        }
        else
        {
            ans += 1 / double(a);
            ans += 1 / double(a-c+tot-c+2);
            ans -= 1 / double(a+tot-c);
        }
    }
    v[x]=0;
    for(int p=g[x];p;p=next[p])
    if (v[adj[p]])
        if (flag[adj[p]]) dfs(adj[p],a+1,c+1);
        else    dfs(adj[p],a+1,c);
        
}

void Work()
{
    ans = 0;
    fo(i,0,n-1)
    {
        ans++;
        kai = i;
        ms(v,1);
        if (!flag[i]) dfs(i,1,0);
        else dfs(i,1,1);
    }
    printf("%.11lf\n",ans);
}

int main()
{
    
    Init();
    Work();
    
    return 0;
}