#include <bits/stdc++.h>
using namespace std;
#define pb push_back
#define X first
#define Y second
#define Sz size()
#define spa <<" "
#define lin <<endl
#define mp make_pair
#define foreach(i, x) for(__typeof((x).begin()) i = (x).begin(); i != (x).end(); i ++)
#define Say(x) cerr << #x << " = " << x << endl
#define For(i, n) for(int i = 0; i < (n); i++)
#define All(x) ((x).begin(), (x).end())
typedef long long ll;
typedef vector <int> vint;
typedef pair <int,int> pii;

const int M = 3000 + 4, Inf = 1e9 + 10;

vint adj[M];
int d[M], par[M], mk[M], dor, ded[M];
double ans;

void dfs(int v, int dad)
{
	if (dad != -1) d[v] = d[dad] + 1;
	mk[v] = 1;
	par[v] = dad;
	For (i, adj[v].Sz)
	{
		int u = adj[v][i];
		if (!mk[u]) dfs(u, v);
		else if (u != dad && d[u] < d[v]) {
			dor = 1;
			int w = v;
			while(w != u)
			{
				mk[w] = 2;
				w = par[w];
				dor++;
			}
		}
	}
}

void dfs2(int v, int dad)
{
	ded[v] = ded[dad];
	if (mk[v] == 2) ded[v]++;
	//cout << v spa << mk[v] spa << ded[v] lin;
	mk[v] = 3;
	ans += 1.0 / (d[v] + 1.0);
	if (ded[v]) ans += 1.0 / (d[v] - 2.0 * ded[v] + dor + 1.0) - 1.0 / (d[v] - ded[v] + dor);
	For (i, adj[v].Sz)
	{
		int u = adj[v][i];
		if (mk[u] < 3) dfs2(u, v);
	}
}

int main()
{
	ios::sync_with_stdio(false);
	int n;
	cin >> n;
	For (i, n)
	{
		int x, y;
		cin >> x >> y;
		adj[x].pb(y);
		adj[y].pb(x);
	}
	For (i, n)
	{
		memset(mk, 0, sizeof mk);
		memset(d, 0, sizeof d);
		memset(ded, 0, sizeof ded);
		memset(par, 0, sizeof par);
		dor = 0;
		dfs(i, -1);
		dfs2(i, -1);
		//cout << setprecision(8) << ans lin; 
	}
	cout << setprecision(8) << fixed << ans lin; 
	return 0;
}
