#include <fstream>
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;
const int N = 3005;

#define fo( i, x, y ) for ( int i=x; i<y; ++i )
#define pb( x ) push_back( x )

vector < int > e[N], seq;
int Belong[N], Dep[N];
bool Cycle[N], Done[N];
int n, m;
double Res;

void dfs_info( int Rt, int x, int Fa, int _D )
{
	Belong[x] = Rt, Dep[x] = _D;
	fo ( j, 0, e[x].size() )
	{
		if ( e[x][j]==Fa || Cycle[ e[x][j] ] ) continue;
		dfs_info( Rt, e[x][j], x, _D + 1 );
	}
}

int dfs( int x, int fa )
{
	if ( Cycle[x] ) return x;
	Cycle[x] = 1;
	fo ( j, 0, e[x].size() )
	{
		if ( e[x][j]==fa ) continue;
		int tmp = dfs( e[x][j], x );
		if ( tmp==-1 ) continue;
		if ( tmp==-2 ) { Cycle[x] = 0; return -2; }
		if ( tmp>=0 ) 
		{ 
			seq.pb( x ); 
			if ( tmp==x ) return -2;
			return tmp; 
		}
	}
	Cycle[x] = 0;
	return -1;
}

void preprocessing()
{
	int x, y;
	ios :: sync_with_stdio( 0 );
	cin >> n;
	fo ( i, 0, n ) 
	{
		cin >> x >> y;
		e[x].pb( y ), e[y].pb( x );
	}
	dfs( 0, -1 ), m = seq.size();
	fo ( i, 0, m ) dfs_info( seq[i], seq[i], -1, 0 );
}

void dfs_ans( int Rt, int x, int Len )
{
	Done[x] = 1;
	if ( Belong[x]!=Belong[Rt] ) 
	{
		int X = Dep[x] + Dep[Rt] + 2, Y = Len + 1 - X;
		int Z = m - Y - 2;
		Res += ( 1.0 / ( X+Y ) + 1.0 / ( X+Z ) - 1.0 / ( X+Y+Z ) );
	} 
	else Res += ( 1.0 / ( Len+1 ) );
	fo ( j, 0, e[x].size() ) if ( !Done[ e[x][j] ] )
		dfs_ans( Rt, e[x][j], Len + 1 );
}

void solve()
{
	fo ( i, 0, n ) 
	{
		fill( Done, Done + n, 0 );
		dfs_ans( i, i, 0 );
	}
	cout.precision( 20 );
	cout << Res << endl;
} 

int main()
{
	preprocessing();
	solve();
	return 0;
}
