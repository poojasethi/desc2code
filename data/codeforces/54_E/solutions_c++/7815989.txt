#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#define sqr(x) ((x)*(x))
using namespace std;
const double pi=acos(-1.0);
const double eps=1e-8;
const int MAXN=100000;
int sgn(double x)
{
	return x<-eps?-1:x>eps;
}
struct point//注意重点 弱逼!!
{
	double x,y;
	point() {}
	point(double a,double b): x(a),y(b) {}
	void read()
	{
	    scanf("%lf%lf",&x,&y);
	}
	void show()
	{
	    printf("(%lf,%lf)\n",x,y);
	}
	point operator + (const point &b) const
	{
		return point(x+b.x,y+b.y);
	}
	point operator - (const point &b) const
	{
		return point(x-b.x,y-b.y);
	}
    point operator * (const double &b) const
	{
		return point(x*b,y*b);
	}
    point operator / (const double &b) const
	{
		return point(x/b,y/b);
	}
    bool operator == (const point &b) const
	{
		return (sgn(y-b.y)==0&&sgn(x-b.x)==0);
	}
	bool operator < (const point &b) const
    {
        if(sgn(y-b.y)==0)
        return x<b.x;
        return y<b.y;
    }
    double operator * (const point &b) const
	{
		return x*b.x+y*b.y;
	}
	double X (const point &b) const
	{
		return x*b.y-y*b.x;
	}
    point rot (const double &ta) const
	{
	    return point(cos(ta)*x-sin(ta)*y,sin(ta)*x+cos(ta)*y);
	}
    point rot90 () const
	{
	    return point(-y,x);
	}
   	point unit()
	{
	    return point(x,y)/len();
	}
	double dis (const point &b) const
	{
	    return sqrt(fabs(sqr(x-b.x)+sqr(y-b.y)));
	}
    double dis2 (const point &b) const
	{
	    return fabs(sqr(x-b.x)+sqr(y-b.y));
	}
	double len() const
	{
		return sqrt(x*x+y*y);
	}
    double len2() const
	{
		return x*x+y*y;
	}
};
struct polygon
{
	point p[MAXN];
	int n;
    void grahanm(polygon &ans)
    {
        sort(p,p+n);
        ans.p[0]=p[0];ans.p[1]=p[1];
        int now=2;
        for(int i=2;i<n;i++)
        {
            while(now>1&&sgn((ans.p[now-1]-p[i]).X(ans.p[now-2]-p[i]))>=0)now--;
            ans.p[now++]=p[i];
        }
        int top=now;
        for(int i=n-2;i>=0;i--)
        {
            while(now>top&&sgn((ans.p[now-1]-p[i]).X(ans.p[now-2]-p[i]))>=0)now--;
            ans.p[now++]=p[i];
        }
        ans.n=--now;
		n=ans.n;
		for(int i=0;i<ans.n;i++)p[i]=ans.p[i];
    }
    double cal(int l,int r)
    {
        double ans=0;
        if(l<=r)
        for(int i=l;i<r;i++)ans+=p[i].X(p[i+1]);
        else
        {
            for(int i=l;i<n;i++)ans+=p[i].X(p[i+1]);
            for(int i=0;i<r;i++)ans+=p[i].X(p[i+1]);
        }
        ans+=p[r].X(p[l]);
        return fabs(ans/2);
    }
};
double solve(polygon &a)
{
    double ans=1e20;
    int l=1,r=1;
    a.p[a.n]=a.p[0];
    for(int i=0;i<a.n;i++)
    {
        point vec=(a.p[i+1]-a.p[i]).unit();
        while(sgn((a.p[(r+1)%a.n]-a.p[i])*vec-(a.p[r%a.n]-a.p[i])*vec)>=0)r++;
        while(l<r||sgn((a.p[(l+1)%a.n]-a.p[i])*vec-(a.p[l%a.n]-a.p[i])*vec)<=0)l++;
       // printf("%d %d %d\n",i,l,r);
        double s=-a.cal((i+1)%a.n,r%a.n);
        double L=fabs((a.p[r%a.n]-a.p[i+1])*vec);
        s+=fabs((a.p[r%a.n]-a.p[i+1]).X(vec))/2*L;
        ans=min(ans,s);
        s=-a.cal(l%a.n,i%a.n);
        L=fabs((a.p[l%a.n]-a.p[i])*vec);
        s+=fabs((a.p[l%a.n]-a.p[i]).X(vec))/2*L;
       // printf("%.2f\n",s);
        ans=min(ans,s);
    }
    return ans;
}
polygon p,tmp;
int main()
{
    while(~scanf("%d",&p.n))
    {
        for(int i=0;i<p.n;i++)p.p[i].read();
        p.grahanm(tmp);
        printf("%.10f\n",solve(p));
    }
}

 			   	  						 										