#include <cctype>
#include <climits>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <bitset>
#include <complex>
#include <deque>
#include <iostream>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <string>
#include <vector>
using namespace std;
typedef long long llong;
typedef pair<int,int> ii;
typedef pair<int,string> is;
typedef pair<string,int> si;
typedef pair<double,double> dd;
#define spc putchar(32)
#define edl putchar(10)
#define sz(x) ((int)(x).size())
#define mp(a,b) make_pair((a),(b))
#define all(x) (x).begin(),(x).end()
#define see(x) cout<<"[DEBUG] "#x" = "<<x<<endl
#define loop(i,n) for(int i=0;i<(n);++i)
#define each(i,x) for(typeof((x).begin()) i=(x).begin();i!=(x).end();++i)
struct iii{int a,b,c;iii(){}iii(int a,int b,int c):a(a),b(b),c(c){}
bool operator<(const iii&e)const{return a<e.a||a==e.a&&(b<e.b||b==e.b&&c<e.c);}};
template<typename T>T sq(const T&x){return x*x;}
template<typename T>void minl(T&a,const T&b){if(a>b)a=b;}
template<typename T>void maxl(T&a,const T&b){if(a<b)a=b;}
template<typename T>void operator+=(vector<T>&a,const T&x){a.push_back(x);}
template<typename T>void operator+=(set<T>&a,const T&x){a.insert(x);}
template<typename T>bool operator&(const set<T>&a,const T&x){return a.find(x)!=a.end();}
template<typename A,typename B>istream&operator>>(istream&i,pair<A,B>&v){return i>>v.first>>v.second;}
ii operator+(const ii&a,const ii&b){return ii(a.first+b.first,a.second+b.second);}
ii operator-(const ii&a,const ii&b){return ii(a.first-b.first,a.second-b.second);}
template<typename T>void usort(vector<T>&a){sort(all(a));a.erase(unique(all(a)),a.end());}
template<typename T>int index(const vector<T>&a,const T&x){return lower_bound(all(a),x)-a.begin();}
template<typename T>T gcd(T a,T b){while(b){T t=a%b;a=b;b=t;}return a;}
llong cross(const ii&a,const ii&b){return (llong)a.first*b.second-(llong)b.first*a.second;}
llong dot(const ii&a,const ii&b){return (llong)a.first*b.first+(llong)a.second*b.second;}
int bitcnt(unsigned x){return __builtin_popcount(x);}
int bitlow(unsigned x){return __builtin_ffs(x);}

#define PV(i,n) ((i)>0?(i)-1:(n)-1)
#define NX(i,n) ((i)+1<(n)?(i)+1:0)

const double APS = 1e-10;
const double EPS = 1e-7;
const double PI = acos(-1.0);

inline int sgn(double x) { return x < -EPS ? -1 : x > EPS; }

struct Point {
    double x, y;
    Point() {}
    Point(const double & x, const double & y) : x(x), y(y) {}
    bool operator == (const Point & rs) const {
        return sgn(x - rs.x) == 0 && sgn(y - rs.y) == 0;
    }
    bool operator < (const Point & rs) const {
        return x + EPS < rs.x || x < rs.x + EPS && y + EPS < rs.y;
    }
    Point operator + (const Point & rhs) const { return Point(x + rhs.x, y + rhs.y); }
    Point operator - (const Point & rhs) const { return Point(x - rhs.x, y - rhs.y); }
    Point operator * (const double & k) const { return Point(x * k, y * k); }
    Point operator / (const double & k) const { return Point(x / k, y / k); }
    double len2() const { return x * x + y * y; }
    double len() const { return sqrt(len2()); }
    Point to(const double & k) const { return  (*this) * (k / len()); }
    Point turn_left() { return Point(-y, x); }
    Point turn_right() { return Point(y, -x); }
    bool read() { return scanf("%lf%lf", &x, &y) != EOF; }
    void print() { printf("%.2f %.2f\n", x, y); }
};

inline double cross(Point p1, Point p2) {
    return p1.x * p2.y - p2.x * p1.y;
}
inline double dot(Point p1, Point p2) {
    return p1.x * p2.x + p1.y * p2.y;
}
bool inter(Point a, Point b, Point c, Point d, Point & x) {
    double s1 = cross(b - a, c - a);
    double s2 = cross(b - a, d - a);
    if (sgn(s2 - s1) == 0) return false;
    x = Point(c.x * s2 - d.x * s1, c.y * s2 - d.y * s1) / (s2 - s1);
    return true;
}
Point foot(Point p, Point s1, Point s2) {
    Point t;
    inter(p, p + (s2 - s1).turn_left(), s1, s2, t);
    return t;
}
double area_triangle(Point p1, Point p2, Point p3) {
    return fabs(cross(p1-p3, p2-p3)) / 2;
}


int n;
Point p[50000];
double burn(){
    Point x;
    int a=0;
    int b=1;
    Point r=(p[b]-p[a]).turn_right();
    int u=1,v=NX(u,n);
    double s=0;
    while(cross(r,p[v]-p[u])>EPS){
        s+=area_triangle(p[b],p[u],p[v]);
        u=v;
        v=NX(u,n);
    }
    inter(p[a],p[b],p[u],p[u]+r,x);
    //x.print();
    double ret=area_triangle(p[b],p[u],x)-s;
    //see(ret);
    //printf("%d %d %d %d %f\n",a,b,u,v,s);
    while(1){
        s-=area_triangle(p[b],p[NX(b,n)],p[u]);
        a=b;
        b=NX(a,n);
        if(a==0)break;
        r=(p[b]-p[a]).turn_right();
        while(cross(r,p[v]-p[u])>EPS){
            s+=area_triangle(p[b],p[u],p[v]);
            u=v;
            v=NX(u,n);
        }
        
        inter(p[a],p[b],p[u],p[u]+r,x);
        double d=area_triangle(p[b],p[u],x)-s;
        //printf("%d %d %d %d %f %f\n",a,b,u,v,s,d);
        minl(ret,d);
    }
    return ret;
}
void york(){
    scanf("%d",&n);
    loop(i,n)p[i].read();
    if(cross(p[1]-p[0],p[2]-p[0])>0)reverse(p,p+n);
    double s1=burn();
    loop(i,n)p[i].y=-p[i].y;
    reverse(p,p+n);
    double s2=burn();
    double ans=min(s1,s2);
    printf("%.10f",ans);
}
int main(){
    ios_base::sync_with_stdio(false);
#ifndef ONLINE_JUDGE
    freopen("1.in","r",stdin);
    freopen("1.out","w",stdout);
    int ck=clock();
#endif
    york();
#ifndef ONLINE_JUDGE
    printf("\n=====\nUsed: %d ms",clock()-ck);
#endif
    return 0;
}
