#include <cstdlib>
#include <cctype>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <map>
#include <set>
#include <queue>
#include <bitset>
using namespace std;

const double eps = 1e-8;
const double inf = 1e6;
const int maxP = 44444 * 2;
const double PI = acos(-1.0);

inline double sqr(double d) {
	return d * d;
}
inline int dcmp(double d) {
	if ( fabs(d) < eps ) return 0;
	return d > eps ? 1 : -1;
}

struct Point {
	double x , y;
	Point() {
	}
	Point(const double &_x, const double &_y) :
	x(_x), y(_y) {
	}
	bool operator ==(const Point &p) const {
		return ( dcmp(x - p.x) == 0 && dcmp(y - p.y) == 0 );
	}
	bool operator <(const Point &p) const {
		return y + eps < p.y || ( y < p.y + eps && x + eps < p.x );
	}
	Point operator +(const Point &p) const {
		return Point(x + p.x, y + p.y);
	}
	Point operator -(const Point &p) const {
		return Point(x - p.x, y - p.y);
	}
	Point operator *(const double &k) const {
		return Point(x * k, y * k);
	}
	Point operator /(const double &k) const {
		return Point(x / k, y / k);
	}
	double operator *(const Point &p) const {
		return x * p.y - y * p.x;
	}
	double operator /(const Point &p) const {
		return x * p.x + y * p.y;
	}
	double len2() {
		return x * x + y * y;
	}
	double len() {
		return sqrt(x * x + y * y);
	}
	Point scale(const double &k) {
		return dcmp(len2()) ? ( *this ) * ( k / len() ) : ( *this );
	}
	Point turnLeft() {
		return Point(-y, x);
	}
	Point turnRight() {
		return Point(y, -x);
	}
	int input() {
		return scanf("%lf%lf", &x, &y);
	}
	void output() {
		printf("%.2lf %.2lf\n", x + eps, y + eps);
	}

	double Distance(Point p) {
		return sqrt(sqr(p.x - x) + sqr(p.y - y));
	}

	Point rotate(const Point &p, double angle, double k = 1) {
		Point vec = ( *this ) - p;
		double Cos(cos(angle) * k) , Sin(sin(angle) * k);
		return p + Point(vec.x * Cos - vec.y * Sin, vec.x * Sin + vec.y * Cos);
	}
}pp[maxP];

double dis(Point a,Point b,Point c) {
	return fabs((b - a) * (c - a)) / a.Distance(b);
}
double sum[maxP];
int n;
double solve() {
	for (int i = 1 ; i <= n ; i ++) {
		if ((pp[i+1] - pp[i]) / (pp[i+1] - pp[i+2]) >= 0) return 0;
	}
	for (int i = 1 ; i <= 2*n ; i ++) {
		sum[i] = sum[i-1] + (pp[i] * pp[i+1]) * 0.5;
	}
	double minarea = 1e20;
	for (int a = 1 , b = 2 , c = 3; a <= n ; a ++ , b ++ ) {
		Point d = pp[b] + (pp[b] - pp[a]).turnRight();
		while ( (pp[b] - pp[a]) / (pp[b] - pp[c+1]) <= 0 
			&& dis(d , pp[b] , pp[c+1]) >= dis(d , pp[b] , pp[c])) c ++;
		double totarea = dis(d , pp[b] , pp[c]) * dis(pp[a] , pp[b] , pp[c])/2;
		double realarea = totarea - fabs(sum[c-1] - sum[b-1] + (pp[c] * pp[b]) * 0.5);
		if (realarea < minarea) {
			minarea = realarea;
		}
	}
	return minarea;
}
int main() {
	cin >> n;
	for (int i = 1 ; i <= n ; i ++) {
		pp[i].input();
		pp[i+n] = pp[i];
	}
	pp[1+n*2] = pp[1];
	double ans = solve();
	for (int a = 1 , b = 2 * n + 1 ; a < b ; a ++ , b--) {
		swap(pp[a] , pp[b]);
	}
	ans = min(ans , solve());
	printf("%.10lf\n",ans);
	return 0;
}