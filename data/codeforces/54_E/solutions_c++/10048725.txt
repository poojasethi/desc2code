#include <algorithm>
#include <iostream>
#include <complex>
#include <iomanip>
#define X real()
#define Y imag()
using namespace std;
typedef complex<double> point;
const int MAX = 40005;
point p[MAX * 2];
double cross(point A, point B)
{
	return A.X * B.Y - A.Y * B.X;
}
double dot(point A, point B)
{
	return A.X * B.X + A.Y * B.Y;
}
int main()
{
	ios::sync_with_stdio(false);
	int n;
	cin >> n;
	for (int i = 0; i < n; i++)
		cin >> p[i].X >> p[i].Y;
	double area = 0.0;
	for (int i = 0; i < n; i++)
		area += cross(p[i], p[(i + 1) % n]);
	if (area < 0.0)
		reverse(p, p + n);
	for (int i = n; i < 2 * n; i++)
		p[i] = p[i - n];
	int pos = 0;
	area = 0.0;
	double ans = 1e18;
	for (int i = 0; i < n; i++)
	{
		while (pos + 1 < 2 * n && dot(p[i + 1] - p[i], p[pos] - p[i]) < dot(p[i + 1] - p[i], p[pos + 1] - p[i]))
		{
			area += cross(p[pos] - p[i], p[pos + 1] - p[i]);
			pos++;
		}
		point AB = p[i + 1] - p[i];
		point P = p[pos] - p[i];
		AB /= abs(AB);
		double alpha = dot(AB, P);
		P = p[i] + alpha * AB;
		ans = min(ans, cross(P - p[i], p[pos] - p[i]) - area);
		area -= cross(p[i + 1] - p[i], p[pos] - p[i]);
	}
	pos = n - 1;
	area = 0.0;
	while (pos > 0 && dot(p[n] - p[n -  1], p[pos] - p[n - 1]) >= dot(p[n] - p[n - 1], p[pos - 1] - p[n - 1]))
	{
		pos--;
		area += cross(p[pos + 1] - p[pos], p[n] - p[pos]);
	}
	for (int i = n - 1; i < 2 * n - 1; i++)
	{
		while (dot(p[i + 1] - p[i], p[pos] - p[i]) > dot(p[i + 1] - p[i], p[pos + 1] - p[i]))
		{
			area -= cross(p[pos + 1] - p[pos], p[i + 1] - p[pos]);
			pos++;
		}
		point AB = p[i + 1] - p[i];
		point P = p[pos] - p[i];
		AB /= abs(AB);
		double alpha = dot(AB, P);
		P = p[i] + alpha * AB;
		ans = min(ans, cross(P - p[pos], p[i + 1] - p[pos]) - area);
		area += cross(p[i + 1] - p[pos], p[i + 2] - p[pos]);
	}
	cout << setprecision(9) << fixed << ans * 0.5 << endl;
	return 0;
}
