#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <cctype>
#include <numeric>
#include <queue>
#define FOR(i,s,e) for(int i=(s);i<(int)(e);i++)
#define FOE(i,s,e) for(int i=(s);i<=(int)(e);i++)
#define CLR(s) memset(s,0,sizeof(s))
#define PB push_back
using namespace std;
typedef long long LL;
typedef pair<int,int> pii;
typedef vector<int> vi;
#define x first
#define y second

const double EPS=1e-9, INF=1e50;
#define flt(x,y) ((x)<(y)-EPS)
#define fgt(x,y) flt(y,x)
#define fle(x,y) !fgt(x,y)
#define fge(x,y) !flt(x,y)
#define feq(x,y) (fabs((x)-(y))<EPS)

struct P{
    double x, y;
    P(){ }
    P(double x,double y):x(x),y(y){ }
    void eat(){ scanf("%lf%lf",&x,&y); }
    P operator+(const P &p)const{ return P(x+p.x, y+p.y); }
    P operator-(const P &p)const{ return P(x-p.x, y-p.y); }
    P operator*(double k){ return P(x*k, y*k); }
    double operator*(P p){ return x*p.x + y*p.y; }
    double operator^(P p){ return x*p.y - y*p.x; }
    double mag2() { return x*x+y*y; }
    double mag(){ return sqrt(mag2()); }
    bool operator<(const P &p)const {
        if (feq(x,p.x)) return flt(y,p.y);
        return flt(x,p.x);
    }
    bool operator==(const P &p)const {
        return feq(x,p.x) && feq(y,p.y);
    }
    P rot(){ return P(-y,x); }
    P rot(double the) {
        return P(x*cos(the)-y*sin(the), x*sin(the)+y*cos(the));
    }
    P nor(){
        if (feq(mag(),0))       return *this;
        return *this*(1./mag());
    }
    void out() { printf("%f %f\n", x, y); }
};

const int N=40360*5;
int n;
P p[N], q[N];
double ang(P u,P v){ return atan2(u^v,u*v); }

int main() {
    scanf("%d", &n);
    FOR(i,0,n) p[i].eat();
    double area=0;
    FOR(i,0,n) area+=p[i]^p[(i+1)%n];
    if(flt(area,0)) reverse(p,p+n);
    FOR(i,0,n) p[n+i]=p[n*2+i]=p[i];
    double ans=INF;
    FOE(i,1,n) {
        if( fge((p[i-1]-p[i])*(p[i+1]-p[i]),0) ) {
            puts("0");
            return 0;
        }
    }
    if(feq(ans,INF))
    FOR(iter,0,2)
    {
        P last=p[1];
        double cur=0;
        int e=2;
        double gt=0;
        FOR(i,0,n) {
            P x=(p[i+1]-p[i]).nor();
            P start=last;

            cur+=start^p[e-1];
            last=p[e-1];
            while(e<i+1+n) {
                double dot=(p[e]-p[i+1])*x;
                if(fle(dot,gt)) break;
                gt=dot;
                cur+=last^p[e];
                last=p[e];
                ++e;
            }

            P cor=p[i+1]+x*gt;
            cur+=p[e-1]^cor;
            cur+=cor^start;

            ans=min(ans,-cur/2);

            // minus
            P v=(p[i+2]-p[i+1]).nor();
            double alp=ang(x,v);
            last=p[i+1]+v*(gt/cos(alp));
            cur-=(last-p[i+1])^(cor-last);

            gt=(p[e-1]-p[i+2])*v;
        }
        reverse(p,p+n*2);
        FOR(i,0,n*2) p[i].y*=-1;
    }
    printf("%.20f\n", ans);
}
