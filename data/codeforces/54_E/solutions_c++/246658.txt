#include <list>
#include <map>
#include <set>
#include <stack>
#include <queue>
#include <algorithm>
#include <sstream>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <climits>
#include <cfloat>
#include <numeric>

using namespace std;

const int oo = 0x3f3f3f3f;
const double eps = 1e-9;

typedef long long ll;
typedef unsigned long long ull;
typedef vector<int> vi;
typedef vector<string> vs;
typedef pair<int, int> pii;

#define sz(c) int((c).size())
#define all(c) (c).begin(), (c).end()
#define FOR(i,a,b) for (int i = (a); i < (b); i++)
#define FORD(i,a,b) for (int i = int(b)-1; i >= (a); i--)
#define FORIT(i,c) for (__typeof__((c).begin()) i = (c).begin(); i != (c).end(); i++)

struct Point {
	double x, y;
	Point(double x=0, ll y=0) : x(x), y(y) {}
};

struct Line {
    double A, B, C;
    Line(double a=1, double b=1, double c=0) : A(a), B(b), C(c) {}
};

int N;
Point poly[100000];
double ar[100000];

Line getLine(Point p0, Point p1) {
    double a = p1.y - p0.y, b = p0.x - p1.x;
    return Line(a, b, a * p0.x + b * p0.y);
}
 
Line getPerpendicularLine(Line line, Point p) {
    return Line(-line.B, line.A, -line.B * p.x + line.A * p.y);
}
 
bool intersectLineLine(Line a, Line b, Point *s) {
    double det = a.A * b.B - b.A * a.B;
    if (abs(det) < eps) return false;
    s->x = (a.C * b.B - b.C * a.B) / det;
    s->y = (a.A * b.C - b.A * a.C) / det;
    return true;
}

double cross(Point a, Point b) {
	return a.x * b.y - b.x * a.y;
}

double getarea(int a, int b, int c) {
	Line l = getLine(poly[a], poly[b]);
	Line l2 = getPerpendicularLine(l, poly[c]);
	Point s;
	intersectLineLine(l, l2, &s);
	double res = cross(poly[c], s) + cross(s, poly[b]);
	if (c > b) {
		res += ar[c] - ar[b];
	} else {
		res += ar[N] - ar[b] + ar[c];
	}
	return abs(res)/2.0;
}

double calc() {
	ar[0] = 0;
	double A = 0;
    for (int i = 1; i <= N; i++) {
        A += poly[i-1].x * poly[i%N].y - poly[i%N].x * poly[i-1].y;
		ar[i] = A;
    }
	int p = 1;
	double res = DBL_MAX;
	FOR(i, 0, N) {
		int a = i, b = (i + 1) % N;
		double dx = poly[b].x - poly[a].x, dy = poly[b].y - poly[a].y;
		int pp = (p + 1) % N;
		while (dx * poly[pp].x + dy * poly[pp].y > dx * poly[p].x + dy * poly[p].y + eps) {
			p = pp;
			pp = (p + 1) % N;
		}
		if (p == b) return 0;
		res = min(res, getarea(a, b, p));
	}
	return res;
}

int main() {
	cin >> N;
	FOR(i, 0, N) cin >> poly[i].x >> poly[i].y;
	double res = calc();
	reverse(poly, poly + N);
	res = min(res, calc());
	printf("%.10lf\n", res);
	return 0;
}
