#include<iostream>
#include<complex>
#include<algorithm>
#include<iomanip>

using namespace std;

#define double long double
#define pnt complex<double>
#define X real()
#define Y imag()
#define cross(a, b) imag(conj((a)) * (b))
#define dot(a, b) real(conj((a)) * (b))
#define EPS 1e-12
#define Z(x) (abs(x) < EPS ? 0. : (x))

const int N = 40100;

int n, flag = 1;
double ans = 1e18, sum;
pnt inp[N], ei, E;

int main () {
    ios_base::sync_with_stdio(0);
    cin >> n;
    for (int i = 0; i < n; ++i) 
        cin >> inp[i].X >> inp[i].Y;
    if (cross(inp[1] - inp[0], inp[2] - inp[1]) < 0) 
        reverse(inp, inp + n);

    for (int i = 0; i < n; ++i) {
        ei = inp[(i + 1) % n] - inp[i];
        while (dot(ei, inp[flag] - inp[i]) < dot(ei, inp[(flag + 1) % n] - inp[i])) {
            sum += abs(cross(inp[flag] - inp[i], inp[(flag + 1) % n] - inp[i])) / 2.;
            ++flag;
            flag %= n;
        }
        ei /= abs(ei);
        double alpha = dot(ei, inp[flag] - inp[i]);
        E = inp[i] + alpha * ei;
        double res = (abs(cross(E - inp[i], inp[flag] - E)) / 2.) - sum;
        ans = min(res, ans);
        sum -= abs(cross(inp[(i + 1) % n] - inp[i], inp[flag] - inp[i])) / 2.;
    }

    sum = 0;
    flag = 0;
    while (dot(inp[1] - inp[0], inp[flag] - inp[0]) > dot(inp[1] - inp[0], inp[(flag - 1 + n) % n] - inp[0])) {
        flag--;
        flag += n;
        flag %= n;
        sum += abs(cross(inp[flag] - inp[1], inp[(flag + 1) % n] - inp[1])) / 2.;
    }

    for (int i = 0; i < n; ++i) {
        ei = inp[(i + 1) % n] - inp[i];
        while (dot(ei, inp[flag] - inp[i]) > dot(ei, inp[(flag + 1) % n] - inp[i])) {
            sum -= abs(cross(inp[flag] - inp[(i + 1) % n], inp[(flag + 1) % n] - inp[(i + 1) % n])) / 2.;
            ++flag;
            flag %= n;
        }
        ei /= abs(ei);
        double alpha = dot(ei, inp[flag] - inp[i]);
        E = inp[i] + alpha * ei;
        double res = (abs(cross(E - inp[(i + 1) % n], inp[flag] - E)) / 2.) - sum;
        ans = min(res, ans);
        sum += abs(cross(inp[(i + 2) % n] - inp[(i + 1) % n], inp[flag] - inp[(i + 1) % n])) / 2.;
    }

    cout << setprecision(7) << fixed;
    cout << Z(ans) << endl;
    return 0;
}
