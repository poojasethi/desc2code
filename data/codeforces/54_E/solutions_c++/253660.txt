#include <iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <vector>
#include <cmath>
#include <cstdlib>
using namespace std;

#define EPS (1e-9)

struct Point{
    double x, y;
    Point(){}
    Point(double a, double b){x = a; y = b;}
    Point operator -(Point B){
        return Point(x - B.x, y - B.y);
    }
};

struct Line{

    /* Ax + By + C = 0 */
    double A, B, C;
    Line(){}
    Line(Point P, Point Q){
        A = P.y - Q.y;
        B = Q.x - P.x;
        C = P.x * Q.y - Q.x * P.y;
    }
    Line Ver(Point P){
        Line res;
        res.A = -B;
        res.B = A;
        res.C = -(res.A * P.x + res.B * P.y);
        return res;
    }
    Point Inter(Line a){
        Point res;
        res.x = (B * a.C - a.B * C) / (A * a.B - a.A * B);
        res.y = (A * a.C - a.A * C) / (a.A * B - a.B * A);
        return res;
    }
};
int n;
vector <Point> p;

double Cp(Point A, Point B){
    return A.x * B.y - A.y * B.x;
}

double Dp(Point A, Point B){
    return A.x * B.x + A.y * B.y;
}

Point Vec(int i){
    return p[i + 1] - p[i];
}

double Area(Point A, Point B, Point C){

    return fabs(A.x * B.y - A.y * B.x + B.x * C.y - B.y * C.x + C.x * A.y - C.y * A.x) / 2.0;
}

double ans = 1e20;

int Mak(){

    double area;
    int i, j = 0;
    for (i = 0; i < n; i++){
        if (j == i){
            area = Area(p[i], p[i + 1], p[i + 2]);
            j++;
        }
        if (j == i + 1 && Dp(Vec(i), Vec(j)) < EPS){
            puts("0.0000000000000000000");
            exit(0);
        }
        while (Dp(Vec(i), Vec(j + 1)) > -EPS){
            area += Area(p[i], p[j + 1], p[j + 2]);
            j++;
        }
        Point C = Line(p[i], p[i + 1]).Ver(p[j + 1]).Inter(Line(p[i], p[i + 1]));
        double tri = Area(p[i], p[j + 1], C);
        if (ans > tri - area) ans = tri - area;
        area -= Area(p[i], p[i + 1], p[j + 1]);
    }
    return 0;
}

int main() {

    scanf("%d", &n);
    for (int i = 0; i < n; i++){
        double a, b;
        scanf("%lf %lf", &a, &b);
        p.push_back(Point(a, b));
    }

    if (Cp(p[1] - p[0], p[2] - p[0]) < 0) reverse(p.begin(), p.end());
    for (int i = 0; i < n; i++) p.push_back(p[i]);

    Mak();
    for (int i = 0; i < 2 * n; i++){
        p[i].x = -p[i].x;
    }
    reverse(p.begin(), p.end());
    Mak();
    printf("%.10f\n", ans);
    return 0;
}
