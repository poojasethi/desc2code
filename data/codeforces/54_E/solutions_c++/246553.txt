//#pragma comment(linker, "/stack:16777216")
#include<cmath>
#include<vector>
#include<deque>
#include<list>
#include<set>
#include<map>
#include<numeric>
#include<iostream>
#include<sstream>
#include<algorithm>
#include<cstdio>
#include<iostream>
#include<cstring>

using namespace std;

#define sz(X) ((int)(X).size())
#define pb push_back
#define mp make_pair
#define X first
#define Y second
#define all(X) (X).begin(),(X).end()
#define FOR(i, a, n) for(int i=(a), __ ## i=(n); i<__ ## i; i++)
#define REP(I,N) FOR(I,0,N)
#define PR(X) cout<<#X<<" = "<<(X)<<" "
#define PRL cout<<endl
#define PRV(X) {cout<<#X<<" = {";REP(__prv,sz(X)-1)cout<<(X)[__prv]<<",";if(sz(X))cout<<*(X).end();cout<<"}"<<endl;}

template<class T> ostream &operator<<(ostream &os, vector<T> &vec)
{
  os<<'{';
  REP(i, sz(vec)){
    os<<vec[i];
    if (i+1!=sz(vec)) os<<',';
  }
  os<<'}';
  return os;
}

template<class T1, class T2> ostream &operator<<(ostream &os, pair<T1, T2> &par)
{
  os<<'('<<par.X<<','<<par.Y<<')';
  return os;
}

typedef long long lint;
typedef vector<int> VI;
typedef pair<int,int> PII;
typedef pair<lint,lint> PLL;
typedef pair<double, double> PDD;

PII a[88*1000];
PDD d[88*1000];

lint scal(int i, int j){
    PLL p = mp(a[i+1].X - a[i].X, a[i+1].Y - a[i].Y);
    PLL q = mp(a[j+1].X - a[j].X, a[j+1].Y - a[j].Y);
    return p.X*q.X+p.Y*q.Y;
}

double operator*(PDD p, PDD q){
    return p.X * q.Y - p.Y * q.X;
}

PDD operator-(PDD p, PDD q){
    return PDD(p.X - q.X, p.Y - q.Y);
}

double operator,(PDD p, PDD q){
    return p.X * q.X + p.Y * q.Y;
}

int main(){
    int n;
    scanf("%d", &n);
    REP(i, n){
        scanf("%d%d", &a[i].X, &a[i].Y);
    }

    copy(a, a + n, a + n);
    REP(i, n){
        if(scal(i, i + 1) <= 0){
            printf("0\n");
            return 0;
        }
    }

    double ans = 1e100;
    REP(iii, 2){
        copy(a, a + 2 * n, d);
        int ind = 0;
        double sum = 0;
        REP(i, n){
            //main logic here
            while(scal(i, ind) > 0){
                sum += d[ind] * d[ind + 1];
                ++ind;
            }
            sum -= d[i] * d[i + 1];
            PDD u = d[i + 1] - d[i];
            PDD v = d[ind] - d[i + 1];
            double s1 = u * v * (u, v) / (u, u);
            double s2 = sum + d[ind] * d[i + 1];
            double ans1 = (abs(s1) - abs(s2)) / 2;
            ans = min(ans, ans1);
        }
        reverse(a, a + 2 * n);
    }
    printf("%.8lf\n", ans);
    return 0;
}
