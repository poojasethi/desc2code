#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pii pair<int,int>
#define pll pair<ll,ll>
#define pdd pair<double,double>
#define X first
#define Y second
#define REP(i,a) for(int i=0;i<a;++i)
#define REPP(i,a,b) for(int i=a;i<b;++i)
#define FILL(a,x) memset(a,x,sizeof(a))
#define	foreach( gg,itit )	for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )
#define	mp make_pair
#define	pb push_back

inline int max(int a,int b){return a<b?b:a;}
inline int min(int a,int b){return a>b?b:a;}
inline ll max(ll a,ll b){return a<b?b:a;}
inline ll min(ll a,ll b){return a>b?b:a;}
const int mod = 1e9+7;
const int N = 1e6+10;
const ll INF = 1e18;

int arr[N];
vector<pii > c[N];
pii qu[N];
pll tree[12*100000];
void upd(int C,int S,int E,int s,int v){
  if(s<S||s>E) return;
  tree[C].X+=v; tree[C].Y++;
  if(s==S&&s==E) return;
  int m=(S+E)>>1,g=C<<1;
  upd(g,S,m,s,v);upd(g+1,m+1,E,s,v);
}
int q(int C,int S,int E,int v,ll su){
  if(su>tree[C].X-v*tree[C].Y) return -1;
  if(S==E) return S;
  int m=(S+E)>>1,g=C<<1;
  if(su<=tree[g].X-v*tree[g].Y) return q(g,S,m,v,su);
  su-=(tree[g].X-v*tree[g].Y);
  return q(g+1,m+1,E,v,su);
}
int ans[N];
int main(){
  int n,m,x; scanf("%d%d",&n,&m);
  REP(i,m){
    int x;
    scanf("%d",&x);
    c[x].pb(mp(0,i));
  }
  REP(i,n){
    scanf("%d%d",&qu[i].X,&qu[i].Y);
    c[qu[i].X].pb(mp(1,i));
  }
  for(int i=N-1;i>=0;i--){
    REP(j,c[i].size()){
      if(c[i][j].X==0){
        upd(1,0,m-1,c[i][j].Y,i);
      }else{
        ans[c[i][j].Y]=q(1,0,m-1,i,qu[c[i][j].Y].Y);
      }
    }
  }
  REP(i,n){
    printf("%d ",ans[i]+1);
  }
  printf("\n");
  return 0;
}
