#include <bits/stdc++.h>

#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define pii pair < int,int > 
#define maxn 200005
#define int long long 
using namespace std;
int n,m,a,b,c,i,j,k,ans[maxn],it;
struct segment_tree{
	int sum,on;
};
pii d[maxn];
pair < pii,int > e[maxn];
segment_tree tree[4*maxn];
void update(int nd,int bas,int son,int l,int val){
	 if(l>son or l<bas)
	 return ;
	 if(bas==son){
		tree[nd].sum=val;
		tree[nd].on=1;
		return ;
	 }
	 int orta=(bas+son)/2;
	 update(2*nd,bas,orta,l,val);
	 update(2*nd+1,orta+1,son,l,val);
	 tree[nd].sum=(tree[2*nd].sum+tree[2*nd+1].sum);
	 tree[nd].on=(tree[2*nd].on+tree[2*nd+1].on);
}
int find(int nd,int bas,int son,int l,int val){
	int cur=(tree[nd].sum-tree[nd].on*l);
	if(cur < val)
	return 0;
	if(bas==son)
	return bas;
	cur=(tree[2*nd].sum-tree[2*nd].on*l);
	int orta=(bas+son)/2;
	if(cur >= val)
	return find(2*nd,bas,orta,l,val);
	return find(2*nd+1,orta+1,son,l,val-cur);
}
main(){
	scanf("%lld %lld",&n,&m);
	swap(n,m);
	for(i=1;i<=n;i++){
		scanf("%lld",&a);
		d[i]=mp(a,i);
	}
	for(i=1;i<=m;i++){
		scanf("%lld %lld",&a,&b);
		e[i]=mp(mp(a,b),i);
	}
	for(i=1;i<=4*n;i++)
	tree[i].sum=tree[i].on=0;
	sort(d+1,d+n+1);
	reverse(d+1,d+n+1);
	sort(e+1,e+m+1);
	reverse(e+1,e+m+1);
	it=1;
	for(i=1;i<=m;i++){
		while(d[it].fi >= e[i].fi.fi and it<=n){
			update(1,1,n,d[it].se,d[it].fi);
			it++;
		}
		ans[e[i].se]=find(1,1,n,e[i].fi.fi,e[i].fi.se);
	}
	for(i=1;i<=m;i++)
	printf("%lld ",ans[i]);
	puts("");
	return 0;
}
