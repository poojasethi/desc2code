#include<cstdio>
#include<algorithm>
#include<cmath>
#include<deque>
#include<vector>
using namespace std;

const int MAX = 200100;

long long tree_sum[MAX];
int tree_cnt[MAX], n, m;

void fadd(int i, int inc_sum, int inc_cnt) {
	for (;i<=m;i|=i+1) {
		tree_sum[i] += inc_sum;
		tree_cnt[i] += inc_cnt;
	}
}

long long fsum(int r, int d) {
	long long sum = 0;
	for (;r>0;r=(r&(r+1))-1)
		sum += tree_sum[r] - tree_cnt[r] * d;
	return sum;
}

int main() {
	scanf("%d%d",&n,&m);
	deque<pair<int, int> > tp(m);
	for (int i=0;i<m;++i) {
		scanf("%d",&tp[i].first);
		tp[i].second = i+1;
		fadd(i+1, tp[i].first, 1);
	}
	sort(tp.begin(), tp.end());
	vector<pair<pair<int, int>, int> > p(n);
	for (int i=0;i<n;++i) {
		scanf("%d%d",&p[i].first.first,&p[i].first.second);
		p[i].second = i;
	}
	sort(p.begin(), p.end());
	vector<int> res(n);
	for (int i=0;i<n;++i) {
		while (!tp.empty() && tp.front().first <= p[i].first.first) {
			fadd(tp.front().second, -tp.front().first, -1);
			tp.pop_front();
		}
		if (fsum(m, p[i].first.first) < p[i].first.second) {
			res[p[i].second] = 0;
			continue;
		}
		int l=0, r=m;
		while (r > l+1) {
			int mid = (l+r)/2;
			if (fsum(mid, p[i].first.first) >= p[i].first.second)
				r = mid;
			else
				l = mid;
		}
		res[p[i].second] = r;
	}
	for (int i=0;i<n;++i)
		printf("%d ", res[i]);
	return 0;
}
