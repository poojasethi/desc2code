nb = [0, 0, 1, 1, 2, 1, 5, 1, 8, 4, 17, 1, 38, 1, 65, 19, 128, 1, 284, 1, 518, 67, 1025, 1, 2168, 16, 4097, 256, 8198, 1, 16907, 1, 32768, 1027, 65537, 79, 133088, 1, 262145, 4099, 524408, 1, 1056731, 1, 2097158, 16636, 4194305, 1, 8421248, 64, 16777712, 65539, 33554438, 1, 67239680, 1039, 134217848, 262147, 268435457, 1, 537396698]

def estP(n):
	l = len(n)
	for k in range(1, l):
		if l % k == 0:
			if n == n[:k] * (l / k):
				return True
	return False

def nbPGT(n, niv=0):
	vn = int(n, 2)
	l = len(n)
	if l == 1:
		return 0
	s = 0
	for k in range(1, l):
		if l % k == 0:
	#		if(niv == 0):
				#print(l, k, n, s, nbPGT(n[:k], niv+1))
			s += (1 << k) - 1 - int(n[:k], 2) - nbPGT(n[:k], niv+1)
			if not estP(n[:k]) and int(n[:k] * (l / k), 2) > vn:
				s += 1
	#			if(niv == 0):
					#print n[:k] * (l / k), n, k, 'PLUS UN'
	#print 'valeur pour', n, s
	return s

def f(l, r):
#	nb = [0] * 61
#	for i in range(1, 61):
#		for k in range(1, i):
#			if i % k == 0:
#				nb[i] += (1 << (k - 1)) - nb[k]
#				if i == 6:
#					print(nb[i], (1 << (k - 1)) - nb[k])
	a = bin(l - 1)[2:]
	b = bin(r)[2:]
	#for k in range(1, min):
	#	if min % k == 0:
	s = nbPGT(a)
	#print(s)
	for i in range(len(a) + 1, len(b) + 1):
		#print(s, i, nb[i])
		s += nb[i]
	#print(nbPGT(b))
	return s - nbPGT(b)

if __name__ == '__main__':
	l, r = [int(_) for _ in raw_input().split()]
	print(f(l, r))