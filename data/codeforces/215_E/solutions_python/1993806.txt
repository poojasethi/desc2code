from itertools import combinations
from fractions import gcd
plains = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]
table = {'0':'0000', '1':'0001', '2':'0010', '3':'0011', '4':'0100', '5':'0101', 
         '6':'0110', '7':'0111','8':'1000', '9':'1001', 'a':'1010', 
         'b':'1011', 'c':'1100','d':'1101', 'e':'1110', 'f':'1111'}

def binary_string(num):
    return ''.join(table[c] for c in '{0:x}'.format(num)).lstrip('0')

def count_periodic(ln):
    ps = [p for p in plains if ln % p == 0]
    res = 0
    for p in ps:
        d = ln/p
        res += 2**(d-1)
    for p, q in combinations(ps, 2):
        d = gcd(ln/p, ln/q)
        res -= 2**(d-1)
    for p, q, r in combinations(ps, 3):
        d = gcd(gcd(ln/p, ln/q), ln/r)
        res += 2**(d-1)
    return res

l, r = [int(i) for i in raw_input().split()]
lstr = binary_string(l)
rstr = binary_string(r)
#print lstr, rstr
#print len(lstr), len(rstr)
res = 0
for i in xrange(len(lstr)+1, len(rstr)):
    res+=count_periodic(i)

def _lcheck(s, j, div):
    res = 0
    p = 1
    while True:
        q = s[p:div].find('0')
        if q == -1: break
        res += 2**(div-(p+q)-1)
        p += q+1
    for k in xrange(1, j):
        if s[0:div] > s[div*k:div*(k+1)]:
            return res+1
        elif s[0:div] == s[div*k:div*(k+1)]:
            continue
        else:
            return res
    return res+1

def count_periodic_l(s):
    ln = len(s)
    ps = [p for p in plains if ln % p == 0]
    res = 0
    for p in ps:
        d = ln/p
        res += _lcheck(s, p, d)
    for p, q in combinations(ps, 2):
        d = gcd(ln/p, ln/q)
        res -= _lcheck(s, ln/d, d)
    for p, q, r in combinations(ps, 3):
        d = gcd(gcd(ln/p, ln/q), ln/r)
        res += _lcheck(s, ln/d, d)
    return res

def _rcheck(s, j, div, eq=True):
    res = 0
    p = 1
    while True:
        q = s[p:div].find('1')
        if q == -1: break
        res += 2**(div-(p+q)-1)
        p += q+1
    for k in xrange(1, j):
        if s[0:div] < s[div*k:div*(k+1)]: 
            return res+1
        elif s[0:div] == s[div*k:div*(k+1)]: 
            continue
        else:
            return res
    return res+(1 if eq else 0)

def count_periodic_r(s, eq=True):
    ln = len(s)
    ps = [p for p in plains if ln % p == 0]
    res = 0
    for p in ps:
        d = ln/p
        res += _rcheck(s, p, d, eq)
    for p, q in combinations(ps, 2):
        d = gcd(ln/p, ln/q)
        res -= _rcheck(s, ln/d, d, eq)
    for p, q, r in combinations(ps, 3):
        d = gcd(gcd(ln/p, ln/q), ln/r)
        res += _rcheck(s, ln/d, d, eq)
    return res

if len(lstr) == len(rstr):
    res += count_periodic_r(rstr)
    res -= count_periodic_r(lstr, False)
else:
    res += count_periodic_l(lstr)
    res += count_periodic_r(rstr)
print res


"""
log = set()
def _check_p(x):
    s = binary_string(x)
    for j in xrange(1, len(s)+1):
        div, mod = divmod(len(s), j)
        if mod == 0 and len(s) >= div*2:
            for k in xrange(1, j):
                if s[0:div] != s[div*k:div*(k+1)]:
                    break
            else:
                return s
    return ''

ct = 0
for i in xrange(l, r+1):
    r = _check_p(i)
    if r:
        log.add(r)
        ct+=1
print ct
print log
"""
