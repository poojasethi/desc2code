#!/usr/bin/python
import sys
import re
from collections import deque

def input_numbers():
    return [int(n) for n in raw_input().split()]

n, b = input_numbers()

class Query:
    def __init__(self, index, ti, di):
        self.index = index
        self.ti = ti
        self.di = di

class Server:
    def __init__(self, max_queue_len):
        self.max_queue_len = max_queue_len
        self.queue = deque()
        self.processed = [] # pairs: (id, time or -1)
        self.current_query = None
        self.time_started = 0 # When the current query started being processed

    def finish_current_query(self):
        if self.current_query == None:
            return
        end_time = self.time_started + self.current_query.di
        self.processed += [(self.current_query.index, end_time)]
        if len(self.queue) > 0:
            self.current_query = self.queue.popleft()
            self.time_started = end_time
        else:
            self.current_query = None

    def process(self, query):
        while self.current_query != None and query.ti >= self.time_started + self.current_query.di:
             self.finish_current_query() # First the execution of the current query should be finished
        if self.current_query != None: # Gets queued or dropped.
            if len(self.queue) < self.max_queue_len:
                self.queue.append(query)
            else:
                self.processed += [(query.index, -1)]
        else:
            self.time_started = query.ti
            self.current_query = query

server = Server(b)
for i in xrange(n):
    ti, di = input_numbers()
    query = Query(i, ti, di)
    server.process(query)
        
inf = 200 * 1000 * 10**9 * 9
fake_query = Query(n, inf, inf)
server.process(fake_query)

processed = server.processed
processed.sort(key = lambda x: x[0]) # Sort by index.

for q in processed:
    print q[1]
