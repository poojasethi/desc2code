#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string.h>
#include<algorithm>
#include<vector>
#define ll __int64
#define inf 1ll << 60;
using namespace std;

const int maxn=40000;

int match[maxn],sa[maxn],sb[maxn],ra[maxn],rb[maxn];

struct node
{
    int id;
    ll h;
    bool operator <(const node& temp) const
    {
        if(h==temp.h) return id<temp.id;
        return h<temp.h;
    }
}a[maxn],b[maxn];




struct Matrix
{
    ll x[3][3];
    Matrix ()
    {
        for(int i=0;i<3;i++)
            for(int j=0;j<3;j++)
            x[i][j]=-inf;
    }

}tree[maxn<<2];


Matrix operator *(const Matrix &a,const Matrix &b)
{
    Matrix temp;
    for(int k=0;k<3;k++)
    for(int i=0;i<3;i++)
        for(int j=0;j<3;j++)
        {
            temp.x[i][j]=max(temp.x[i][j],a.x[i][k]+b.x[k][j]);
        }
    return temp;
}

ll cost(int x,int y)
{

    int ida=sa[x];
    int idb=sb[y];
//    if(x==4 && y==4) cout<<x<<" "<<y<<" "<<ida<<" "<<idb<<" "<<match[ida]<<endl;
    if(match[ida]==idb)
        return -inf;
    return a[x].h*b[y].h;
}

int n;
void init(int rt,int pos)//2,0,1;1,2,0
{
    tree[rt].x[0][0]=cost(pos,pos);
    if(pos+1<=n)
    {
    tree[rt].x[0][1]=cost(pos,pos+1)+cost(pos+1,pos);
    if(pos+2<=n)
    {
    tree[rt].x[0][2]=max(cost(pos,pos+2)+cost(pos+1,pos)+cost(pos+2,pos+1),cost(pos,pos+1)+cost(pos+1,pos+2)+cost(pos+2,pos));
    }
    }
    tree[rt].x[1][0]=0ll;
    tree[rt].x[2][1]=0ll;
}


void build(int rt,int l,int r)
{
    if(l==r)
    {
//        cout<<l<<endl;
        init(rt,l);
//        for(int i=0;i<3;i++)
//        {
//            for(int j=0;j<3;j++)
//            cout<<tree[rt].x[i][j]<<" ";
//            cout<<endl;
//        }
        return;
    }
    int mid=(l+r)>>1;
    build(rt<<1,l,mid);
    build(rt<<1|1,mid+1,r);
    tree[rt]=tree[rt<<1]*tree[rt<<1|1];
}


void update(int rt,int l,int r,int L,int R)
{
    for(int i=0;i<3;i++)
        for(int j=0;j<3;j++)
        tree[rt].x[i][j]=-inf;
    if(l==r)
        {init(rt,l);
//        cout<<"-----------------------"<<l<<endl;
//        for(int i=0;i<3;i++)
//        {
//
//
//            for(int j=0;j<3;j++)
//         cout<<tree[rt].x[i][j]<<" ";
//         cout<<endl;

//        }
    return;}
    int mid=(l+r)>>1;
    if(L<=mid) update(rt<<1,l,mid,L,R);
    if(R>=mid+1) update(rt<<1|1,mid+1,r,L,R);
    tree[rt]=tree[rt<<1]*tree[rt<<1|1];
}


int main()
{
    int q;
//    freopen("in.txt","r",stdin);
    while(scanf("%d%d",&n,&q)!=EOF)
    {
        for(int i=1;i<=n;i++)
            scanf("%I64d",&a[i].h),a[i].id=i;
        for(int i=1;i<=n;i++)
            scanf("%I64d",&b[i].h),b[i].id=i;
        sort(a+1,a+n+1);
        sort(b+1,b+n+1);
        for(int i=1;i<=n;i++)
            sa[i]=a[i].id,sb[i]=b[i].id,ra[a[i].id]=i,rb[b[i].id]=i;//sa为实际编号
        for(int i=1;i<=n;i++)
            match[i]=i;
        build(1,1,n);
//        printf("%I64d\n",tree[1].x[0][0]);
        for(int i=1;i<=q;i++)
        {
//            cout<<"q。。。。。。。。。。。。。。。。。。"<<endl;
           int xx,yy;
           scanf("%d%d",&xx,&yy);
//           cout<<xx<<" "<<yy<<" "<<match[xx]<<" "<<match[yy]<<endl;
           swap(match[xx],match[yy]);
//              cout<<xx<<" "<<yy<<" "<<match[xx]<<" "<<match[yy]<<endl;
           update(1,1,n,max(1,ra[xx]-2),ra[xx]);
           update(1,1,n,max(1,ra[yy]-2),ra[yy]);
           printf("%I64d\n",tree[1].x[0][0]);
        }

    }
}
