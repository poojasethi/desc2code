//0:00am - 
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#include <utility>
#include <set>
#include <queue>
#include <map>
using namespace std;

typedef long long ll;
const ll inf = 1ll << 61;
const int maxn = 30000 + 10;
struct matrix  {
	ll a[3][3];
	void init()  {
		for (int i = 0; i < 3; i ++)
			for (int j = 0; j < 3; j ++)
				a[i][j] = -inf;
	}
	matrix operator *(const matrix &o) const {
		matrix ret; 
		ret.init();
		for (int i = 0; i < 3; i ++)
			for (int j = 0; j < 3; j ++) {
				for (int k = 0; k < 3; k ++)
					if (a[i][k] != -inf && o.a[k][j] != -inf)  ret.a[i][j] = max(ret.a[i][j], a[i][k] + o.a[k][j]);
			}
		return ret;
	}

}zero, mat[maxn << 2];

int n, q;
int nowpos[maxn], to[maxn], tmp[maxn];
pair<int, int> w[maxn], h[maxn];

#define lson (cur << 1)
#define rson ((cur << 1) | 1)
#define md ((l + r) >> 1)

void recalc(int cur, int pos) {
	for (int i = 0; i < 3; i ++)
		for (int j = 0; j < 3; j ++)
			mat[cur].a[i][j] = -inf;
	mat[cur].a[0][1] = 0;
	mat[cur].a[1][2] = 0;
	//mat[0][0] v1
	if (to[pos] != pos)  mat[cur].a[0][0] = 1ll * w[pos].first * h[pos].first;
	//mat[1][0] v2
	if (pos - 1 >= 1 && to[pos] != pos - 1 && to[pos - 1] != pos)
		mat[cur].a[1][0] = 1ll * w[pos].first * h[pos - 1].first + 1ll * w[pos - 1].first * h[pos].first;
	//mat[2][0] v3
	if (pos - 2 >= 1 && to[pos] != pos - 1 && to[pos - 1] != pos - 2 && to[pos - 2] != pos)  {
		mat[cur].a[2][0] = max(mat[cur].a[2][0], 1ll * w[pos].first * h[pos - 1].first
												 + 1ll * w[pos - 1].first * h[pos - 2].first
												 + 1ll * w[pos - 2].first * h[pos].first);
	}
	if (pos - 2 >= 1 && to[pos] != pos - 2 && to[pos - 1] != pos && to[pos - 2] != pos - 1)  {
		mat[cur].a[2][0] = max(mat[cur].a[2][0], 1ll * w[pos].first * h[pos - 2].first 
												+ 1ll * w[pos - 1].first * h[pos].first
												+ 1ll * w[pos - 2].first * h[pos - 1].first);
	}
}

void build(int cur, int l, int r)  {
	if (l == r)  {
		recalc(cur, l);
		return;
	}
	build(lson, l, md);
	build(rson, md + 1, r);
	mat[cur] = mat[lson] * mat[rson];
}

void modify(int cur, int l, int r, int ql, int qr)  {
	if (ql <= l && r <= qr)  {
		if (l == r)  recalc(cur, l);
		else  {
			modify(lson, l, md, ql, qr);
			modify(rson, md + 1, r, ql, qr);
			mat[cur] = mat[lson] * mat[rson];
		}
		return;
	}
	if (ql <= md)  modify(lson, l, md, ql, qr);
	if (qr > md) modify(rson, md + 1, r, ql, qr);
	mat[cur] = mat[lson] * mat[rson];
}

int main()  {
	scanf("%d%d", &n, &q);
	for (int i = 1; i <= n; i ++)  
		scanf("%d", &w[i].first), w[i].second = i;
	for (int i = 1; i <= n; i ++)
		scanf("%d", &h[i].first), h[i].second = i;
	sort(w + 1, w + 1 + n);
	sort(h + 1, h + 1 + n);
	for (int i = 1; i <= n; i ++)
		nowpos[w[i].second] = i;
	for (int i = 1; i <= n; i ++)
		tmp[h[i].second] = i;
	for (int i = 1; i <= n; i ++)
		to[i] = tmp[w[i].second];
	//set zero maxtrix
	for (int i = 0; i < 3; i ++)
		for (int j = 0; j < 3; j ++)
			zero.a[i][j] = inf;
	zero.a[0][0] = 0;

	build(1, 1, n);
	while (q --)  {
		int a, b;
		scanf("%d%d", &a, &b);
		a = nowpos[a], b = nowpos[b];
		swap(to[a], to[b]);
		modify(1, 1, n, max(1, a - 2), min(n, a + 2));
		modify(1, 1, n, max(1, b - 2), min(n, b + 2));
		modify(1, 1, n, max(1, to[a] - 2), min(n, to[a] + 2));
		modify(1, 1, n, max(1, to[b] - 2), min(n, to[b] + 2));
		matrix ans = zero * mat[1];
		printf("%I64d\n", ans.a[0][0]);
	}
	return 0;
}