inp = raw_input().split()
n,s = int(inp[0]), int(inp[1])
from math import sqrt,fabs

def comparator(a,b):
    dist_one = sqrt(a[0]**2 + a[1]**2)
    dist_two = sqrt(b[0]**2 + b[1]**2)
    if dist_one > dist_two: return 1
    elif dist_one < dist_two: return -1
    else: return 0

def distance_function(x,y): return sqrt(x**2 + y**2)

#maps distance from center 
population = {}
cords = []
max_radius = 0
max_popil = 0
for x in range(n):
    inp = raw_input().split()
    x,y,k = int(inp[0]), int(inp[1]), int(inp[2])
    population[(x,y)] = k
    max_popil += k
    cords.append((x,y))
    d = sqrt(x**2 + y**2)
    if d > max_radius: max_radius = d

reqd_pop = 10**6 - s
cords.sort(comparator)

##def binary_search_radius(cords, lo, hi, reqd_pop):
##    print lo,hi
##    if fabs(hi - lo) < 10**(-6):
##        dist = 0
##        pop = 0
##        for x in range(len(cords)):
##            dist = distance_function(cords[x][0], cords[x][1])
##            print "dist is ", dist, " and hi is",hi
##            if dist > hi: break
##            else: pop += population[cords[x]]
##        if pop < reqd_pop: return -1
##        else: return dist
##    else:
##        pop = 0
##        for x in range(len(cords)):
##            dist = distance_function(cords[x][0], cords[x][1])
##            print "dist is ", dist, " and hi is",hi
##            if dist > hi: break
##            else: pop += population[cords[x]]
##        
##        print "--"
##        if pop >= reqd_pop:
##            v = binary_search_radius(cords, lo, (lo + hi)/2.0, reqd_pop)
##            if v == -1: return dist
##            else: return v
##        else:
##            v = binary_search_radius(cords, (lo + hi)/2.0, hi, reqd_pop)
##            if v == -1: return dist
##            else: return v
##
##
##if max_popil < reqd_pop: print -1
##else: print binary_search_radius(cords, 0, max_radius, reqd_pop)


def popX(cords,x):
    #returns population till xth element
    s = 0
    for x in range(x + 1):
        s += population[(cords[x][0], cords[x][1])]
    return s



def binPop(cords, lo, hi, reqd_pop):
    
    
    if lo >= hi: return distance_function(cords[hi][0], cords[hi][1])
    elif lo + 1 == hi:
        if popX(cords, lo) >= reqd_pop: return distance_function(cords[lo][0], cords[lo][1])
        else: return distance_function(cords[hi][0], cords[hi][1])
    else:
        mid = (lo + hi)/2
        nowPop = popX(cords, mid)
        if nowPop > reqd_pop: return binPop(cords, lo, mid, reqd_pop)
        else: return binPop(cords, mid, hi, reqd_pop)


if popX(cords, len(cords) - 1) < reqd_pop: print -1
else: print binPop(cords, 0, len(cords) - 1, reqd_pop)

