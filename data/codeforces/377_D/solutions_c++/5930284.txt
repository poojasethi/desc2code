#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
using namespace std;
typedef pair<int,int> pr;
#define rep(i,n) for (int i=1;i<=n;++i)
#define mk make_pair
#define pb push_back
#define x first
#define y second
#define tree int t,int l,int r
#define left t*2,l,mid
#define right t*2+1,mid+1,r
#define M int mid=l+r>>1
const int N=300000;
int c[N*4+5],l[N+5],r[N+5],v[N+5],n,cnt,L,R; pr m[N*4+5],ans,res; vector<pr> a[N+5]; vector<int> b[N+5];
void build(tree)
{
	if (l==r) m[t]=mk(0,l);
	else{M; build(left),build(right),m[t]=max(m[t*2],m[t*2+1]);}
}
void renew(int t,int d){m[t]=mk(m[t].x+d,m[t].y),c[t]+=d;}
void down(int t){renew(t*2,c[t]),renew(t*2+1,c[t]),c[t]=0;}
pr query(tree,int ll,int rr)
{
	if (l==ll && r==rr) return m[t];
	if (c[t]) down(t); M;
	if (rr<=mid) return query(left,ll,rr);
	if (ll>mid) return query(right,ll,rr);
	return max(query(left,ll,mid),query(right,mid+1,rr));
}
void modify(tree,int ll,int rr,int d)
{
	if (l==ll && r==rr){renew(t,d); return;}
	if (c[t]) down(t); M;
	if (rr<=mid) modify(left,ll,rr,d);
	else if (ll>mid) modify(right,ll,rr,d);
	else modify(left,ll,mid,d),modify(right,mid+1,rr,d);
	m[t]=max(m[t*2],m[t*2+1]);
}
int main()
{
	scanf("%d",&n);
	rep(i,n) scanf("%d%d%d",l+i,v+i,r+i),a[l[i]].pb(mk(v[i],r[i])),b[v[i]].pb(r[i]);
	build(1,1,N);
	rep(i,N) if (!a[i].empty() || !b[i].empty()){
		rep(j,a[i].size()) modify(1,1,N,a[i][j-1].x,a[i][j-1].y,1);
		pr res=query(1,1,N,i,N); if (res>ans) ans=res,L=i;
		rep(j,b[i].size()) modify(1,1,N,i,b[i][j-1],-1);
	}
	printf("%d\n",ans.x); R=ans.y;
	rep(i,n) if (l[i]<=L && L<=v[i] && v[i]<=R && R<=r[i]) printf("%d ",i);
	return 0;
}
