#include<bits/stdc++.h>
		 
using namespace std;
#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define FORE(ii,aa,bb) for(int ii=aa;ii<bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)
#define type(x) __typeof(x.begin())

#define dbg(x) cerr << (#x) << " --> " << (x) << endl
#define y1 sdfsdfsdf
#define ll long long
#define pii pair<int,int>
#define mod 1000000007
#define N (int)(3e5+10)
#define mp make_pair
#define pb push_back
#define sd second
#define ft first
#define endll puts("")
#define endl '\n'
#define inf mod
#define ort ((sol+sag)/2)
int l[N],r[N],v[N],n;
vector<pii>start[N],endd[N];
pair<int,pii >ans;
class node{
	public:
		int add,R,mx;
}St[4*N];
node merge(node a,node b);

node init(int v,int sol,int sag){
	if(sol == sag){St[v].R = sol;return St[v];}
	return St[v] = merge(init(2*v,sol,ort) , init(2*v+1,ort+1,sag));
}
node upd(int v,int sol,int sag,int l,int r,int x){
	if(sol > r or sag < l) return St[v];
	if(l <= sol and sag <= r){St[v].add += x;St[v].mx+=x;return St[v];}
	int asalak = St[v].add;
	St[v] = merge(upd(2*v,sol,ort,l,r,x) , upd(2*v+1,ort+1,sag,l,r,x));
	St[v].mx += St[v].add = asalak;
	return St[v];
}
node merge(node a,node b){
	node t; t.add = 0;
	if(a.mx > b.mx){ t.R = a.R;t.mx=a.mx; }
	else { t.R = b.R; t.mx = b.mx; }
	return t;
}
pii que(){return mp(St[1].mx,St[1].R);}
int main(){
	cin >> n;
	FOR(i,1,n){
		scanf("%d %d %d",&l[i],&v[i],&r[i]);
		start[l[i]].pb(mp(v[i],r[i]));
		endd[v[i]].pb(mp(v[i],r[i]));
	}
	init(1,1,N);
	FOR(i,1,N-1){
		foreach(j,start[i]) upd(1,1,N,j->ft,j->sd,1);
		ans = max(ans, mp(que().ft,mp(i,que().sd)));
		foreach(j,endd[i]) upd(1,1,N,j->ft,j->sd,-1);
	}
	cout << ans.ft << endl;
	FOR(i,1,n)	if(l[i] <= ans.sd.ft and ans.sd.ft <= v[i] and v[i] <= ans.sd.sd and ans.sd.sd <= r[i]) printf("%d ",i);
}
