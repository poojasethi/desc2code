#include <bits/stdc++.h>

using namespace std;

#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)

#define type(x) __typeof(x.begin())

#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair < int ,int > pii;

typedef long long ll;

const int inf = 1e9, mod = 1e9+7;
const int N = 3e5+5;

int val[N], l[N], r[N], i, j, k, n, m;

pair< int , pii > ans;

vector< pii > start[N], end[N];

class node{
	public:
	int add, max, w;
} ST[4 * N];

node merge(int add, node x,node y){
	node temp; temp.add = add;
	if(x.max > y.max) temp.w = x.w, temp.max = x.max + add;
	else temp.w = y.w, temp.max = y.max + add;
	return temp;
}

node update(int k,int bas,int son,int x,int y,int t){
	if(bas > y || son < x) return ST[k];
	if(x <= bas && son <= y){ ST[k].add += t; ST[k].max += t; return ST[k]; } 
	return ST[k] = merge(ST[k].add,update(sol,bas,orta,x,y,t), update(sag,orta+1,son,x,y,t));	
}

node init(int k,int bas,int son){
	if(bas == son){ ST[k].w = bas; return ST[k]; } 
	return ST[k] = merge(ST[k].add,init(sol,bas,orta), init(sag,orta+1,son));	
}

pii query(){ return mp(ST[1].max,ST[1].w); }

int main(){
		
	scanf("%d",&n);

	FOR(i,1,n){
		scanf("%d %d %d",&l[i],&val[i],&r[i]);
		start[l[i]].pb(mp(val[i],r[i]));
		end[val[i]].pb(mp(val[i],r[i]));
	}
	
	init(1,1,N);

	FOR(i,1,N-1){
		foreach(it,start[i]) update(1,1,N,it->st,it->nd,1);
		ans = max(ans,mp(query().st,mp(i,query().nd)));
		foreach(it,end[i]) update(1,1,N,it->st,it->nd,-1); 
	}

	cout << ans.st << endl;

	FOR(i,1,n) if(l[i] <= ans.nd.st && ans.nd.st <= val[i] && val[i] <= ans.nd.nd && ans.nd.nd <= r[i]) cout << i << ' ';

	cout << endl;

    return 0;
}
