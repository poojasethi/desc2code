#include <cstdio>
#include <vector>
#include <set>
#include <cstring>
#include <algorithm>
using namespace std;
#define N 200100
int n, m, A[N], my[N<<2];
set<int> a[N];
char s[10];

struct node {
    char op;
    int x, y;
} q[N];

int idx(int v) {
    return lower_bound(A, A+m, v) - A + 1;
}

void update(int x, int L, int R, int rt) {
    if (L == R) {
        if (a[x].size() == 0) my[rt] = 0;
        else my[rt] = *a[x].rbegin();
        return ;
    }
    int Mid = (L + R) >> 1;
    if (x <= Mid) update(x, L, Mid, rt<<1);
    else update(x, Mid+1, R, rt<<1|1);
    my[rt] = max(my[rt<<1], my[rt<<1|1]);
}
int query(int x, int y, int L, int R, int rt) {
    if (L == R) {
        if (my[rt] > y && x < L) return L;
        return 0;
    }

    int Mid = (L + R) >> 1;
    int t = 0;
    if (x < Mid && my[rt<<1] > y) t = query(x, y, L, Mid, rt<<1);
    if (t == 0 && my[rt<<1|1] > y) t = query(x, y, Mid+1, R, rt<<1|1);
    return t;
}
int main() {
    scanf("%d", &n);
    m = 0;
    for (int i=0; i<n; i++) {
        scanf(" %s%d%d", s, &q[i].x, &q[i].y);
        q[i].op = s[0];
        A[m++] = q[i].x;
        a[i].clear();
    }
    a[n].clear();

    sort(A, A+m);
    m = unique(A, A+m) - A;

    memset(my, 0, sizeof(my));
    int x, y;
    for (int i=0; i<n; i++) {
        x = idx(q[i].x), y = q[i].y;

        if (q[i].op == 'a') {
            a[x].insert(y);
            update(x, 1, n, 1);
        } else if (q[i].op == 'r') {
            a[x].erase(y);
            update(x, 1, n, 1);
        } else {
            int t = query(x, y, 1, n, 1);
            if (t) printf("%d %d\n", A[t-1], *a[t].upper_bound(y));
            else puts("-1");
        }
    }

    return 0;
}
