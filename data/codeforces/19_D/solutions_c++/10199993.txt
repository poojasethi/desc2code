#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
#include<set>
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
#define MAX 220000
#define ls rt<<1
#define rs ls|1
#define m (l+r)>>1

int sum[MAX << 2];
int pos[MAX];
set<int>y[MAX];
struct
{
	char str[10];
	int x, y;
}tg[MAX];
void uprt(int rt)
{
	sum[rt] = max(sum[ls], sum[rs]);
}
void build(int l, int r, int rt)
{
	if (l == r)
	{
		sum[rt] =-1;
		return;
	}
	int mid = m;
	build(l, mid, ls);
	build(mid + 1, r, rs);
	uprt(rt);
}

void updata(int p, int l, int r, int rt)
{
	if (l == r)
	{
		if (!y[p].empty())
			sum[rt] = *(--y[p].end());
		else
			sum[rt] = -1;
		return;
	}
	int mid = m;
	if (p <= mid)
		updata(p, l, mid, ls);
	else
		updata(p, mid + 1, r, rs);
	uprt(rt);
}

int query(int L, int p, int l, int r, int rt)
{
	if (sum[rt]<p)return -1;
	if (l == r)
		return l;
	int ans = -1;
	int mid = m;
	if (sum[ls] > p&&mid > L)
		ans = query(L, p, l, mid, ls);
	if (ans == -1 && sum[rs] > p&&r > L)
		ans = query(L, p, mid + 1, r, rs);
	return ans;
}
int main()
{
	int n;
	scanf("%d%*c", &n);
	for (int i = 0; i < n; i++)
	{
		scanf("%s%d%d", tg[i].str, &tg[i].x, &tg[i].y);
		pos[i] = tg[i].x;
	}
	sort(pos, pos + n);
	int cnt = unique(pos, pos + n)-pos;
	build(0, cnt - 1, 1);
	for (int i = 0; i < n; i++)
	{
		int cur = lower_bound(pos, pos + cnt, tg[i].x) - pos;
		if (tg[i].str[0] == 'a')
		{
			y[cur].insert(tg[i].y);
			updata(cur, 0, cnt - 1, 1);
		}
		else
		if (tg[i].str[0] == 'f')
		{
			cur = query(cur, tg[i].y, 0, cnt - 1, 1);
			if (cur == -1)
				puts("-1");
			else
				printf("%d %d\n", pos[cur], *y[cur].upper_bound(tg[i].y));
		}
		else
		{
			y[cur].erase(tg[i].y);
			updata(cur, 0, cnt - 1, 1);
		}
	}
}
 	  				  				  	  	   	 			 	