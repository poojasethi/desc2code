#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <vector>
using namespace std;
typedef long long LL;
const int N=100005,M=2000000010,Ding=1000000005;
struct sl{
	int l,r;
}q[N];
struct csl{
	int lson,rson;
	vector<int> c;
}tree[5000005];
int n,m,z,x,y,fa[N],num,node,root,L,R,p,o;
inline int findfather(int l)
{return (fa[l]==l?l:fa[l]=findfather(fa[l]));}
inline void hb(int x,int y){
	p=findfather(x);o=findfather(y);
	if (p!=o){
		fa[p]=o;
		q[o].l=min(q[o].l,q[p].l);
		q[o].r=max(q[o].r,q[p].r);
	}
}
inline void merge(int &now,LL l,LL r,int x){
	if (now==0) return;
	while (tree[now].c.size()>0){
		hb(tree[now].c[tree[now].c.size()-1],num);
		tree[now].c.pop_back();
	}
	if (l==r) return;
	LL mid=(l+r)>>1LL;
	if (x<=mid) merge(tree[now].lson,l,mid,x);
	else merge(tree[now].rson,mid+1,r,x);
}
inline void ins(int &now,LL l,LL r,int x,int y){
	if (now==0) now=++node;
	if (x<=l && r<=y){
		tree[now].c.push_back(num);
		return;
	}
	LL mid=(l+r)>>1LL;
	if (x<=mid) ins(tree[now].lson,l,mid,x,y);
	if (y>mid) ins(tree[now].rson,mid+1,r,x,y);
}
int main(){
	//freopen("cf319E.in","r",stdin);freopen("cf319E.out","w",stdout);
	scanf("%d",&n);
	node=num=0;
	for (int i=1;i<=n;++i) {
		scanf("%d%d%d",&z,&x,&y);
		if (z==1){
			++num;
			L=q[num].l=x+Ding;R=q[num].r=y+Ding;
			fa[num]=num;
			merge(root,1,M,L);
			merge(root,1,M,R);
			if (L+1<=R-1) ins(root,1,M,q[num].l+1,q[num].r-1);
		}
		else{
			p=findfather(x);o=findfather(y);
			if (p==o || (q[x].l>q[o].l && q[x].l<q[o].r) || (q[x].r>q[o].l && q[x].r<q[o].r)) printf("YES\n");
			else printf("NO\n");
		}
	}
}