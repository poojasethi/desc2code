#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cctype>
#include <string>
#include <cstring>
#include <ctime>
#include <string.h>

using namespace std;
#define mid (l+ ((r-l)>>1))

const int maxn = 1e5+100;
const int COS = 1000000000;
int X[maxn],Y[maxn],T,S;
template<typename T> bool checkmin(T& a,T b) { if(a>b) { a = b; return true; } return false; }
template<typename T> bool checkmax(T& a,T b) { if(a<b) { a = b; return true; } return false; }
#define BUG puts("here!!")

struct Node{
  int rt,l,r;
  vector<int> q;
  Node(){
    q.clear();
  }
}p[maxn*50];

int fa[maxn];

int Find(int x) { return x ==fa[x]?x:fa[x] = Find(fa[x]);}

void Union(int rt,int l,int r,int x){
  if(!rt) return;

  for(int i=0;i<(int)p[rt].q.size();i++) { 
    int I = p[rt].q[i]; 
    checkmin(X[T],X[Find(I)]); 
    checkmax(Y[T],Y[Find(I)]);  
    fa[Find(I)] = T; 
  }
  p[rt].q.clear();

  if(l==r) return;
  if(x<=mid) Union(p[rt].l,l,mid,x);
  else Union(p[rt].r,mid+1,r,x);
  return;
}

void Cover(int &rt,int l,int r,int L,int R){
  if(!rt) rt = ++S;

  if(l==L && r == R){
    p[rt].q.push_back(T);
    return;
  }
  if(R<=mid) Cover(p[rt].l,l,mid,L,R);
  else if(L>mid) Cover(p[rt].r,mid+1,r,L,R);
  else { Cover(p[rt].l,l,mid,L,mid); Cover(p[rt].r,mid+1,r,mid+1,R); }
}

int main()
{
  int n,t,l,r,rt=0 ;
  scanf("%d",&n);
  while(n--){
    scanf("%d %d %d",&t,&l,&r);
    if(t == 1){
      l += COS +1 , r += COS+1; 
      X[++T] = l,Y[T] = r; fa[T] = T;

      Union(rt,1,2*COS+1,l); Union(rt,1,2*COS+1,r);
      if(X[T] < Y[T]-1) Cover(rt,1,2*COS+1,X[T]+1,Y[T]-1);
    }
    else {
      l = Find(l);
      r = Find(r);
      if(l==r||(X[l] > X[r] && X[l] < Y[r]) || ( Y[l] > X[r] && Y[l] < Y[r])) printf("YES\n");
      else printf("NO\n");
    }
  }
}