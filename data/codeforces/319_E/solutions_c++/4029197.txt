#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
const int N = 101013;
vector<int> key[N*4];
int L[N],R[N],pre[N],ops[N],xs[N],ys[N],lnk[N+N];
int n,m,cnt;
int fat(int r) {
    if (pre[r] == 0 || pre[r] == r) return r;
    else return pre[r] = fat(pre[r]);
}
void touch(int p, int l, int r, int x, int k) {
    for (int i = 0; i < key[p].size(); ++i) 
        if (fat(key[p][i]) == key[p][i]) {
            pre[key[p][i]] = k;
            L[k] = min(L[k], L[key[p][i]]);
            R[k] = max(R[k], R[key[p][i]]);
        }
    key[p].clear();
    if (l < r) {
        int mid = (l + r) >> 1;
        if (x <= mid) touch(p + p, l, mid, x, k);
        else touch(p + p + 1, mid + 1, r, x, k);
    }
}
void cover(int p, int l, int r, int x, int y, int k) {
    if (l >= x && r <= y) {
        key[p].push_back(k);
        return ;
    }
    int mid = (l + r) >> 1;
    if (x <= mid) cover(p + p, l, mid, x, y, k);
    if (y > mid) cover(p + p + 1, mid + 1, r, x, y, k);
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        scanf("%d%d%d", ops + i, xs + i, ys + i);
        if (ops[i] == 1) {
            lnk[++m] = xs[i];
            lnk[++m] = ys[i];
        }
    }
    sort(lnk + 1, lnk + m + 1);
    m = unique(lnk + 1, lnk + m + 1) - lnk - 1;
    for (int xt,yt,i = 1; i <= n; ++i) {
        if (ops[i] == 1) {
            xt = lower_bound(lnk + 1, lnk + m + 1, xs[i]) - lnk;
            yt = lower_bound(lnk + 1, lnk + m + 1, ys[i]) - lnk;
            L[++cnt] = xt;
            R[cnt] = yt;
            touch(1, 1, m, xt, cnt);
            touch(1, 1, m, yt, cnt);
            if (L[cnt] + 1 < R[cnt]) cover(1, 1, m, L[cnt] + 1, R[cnt] - 1, cnt);
        } else {
            xt = fat(xs[i]), yt = fat(ys[i]);
            if (xt != yt) {
                puts(L[xt] >= L[yt] && R[xt] <= R[yt] ? "YES" : "NO");
            } else puts("YES");
        }
    }
    return 0;
}
