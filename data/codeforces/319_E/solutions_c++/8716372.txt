#include<vector>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int N = 100005 , inf = (int)1e9;

#define fo(i , st , en) for (int i = st; i <= en; i++)
#define Auto(x , y) __typeof(y) x = y
#define Fe(x , y) for (Auto(x , y.begin()); x != y.end(); x++)
#define Me(x , y) memset(x , y , sizeof(x))

struct _node{
	int l , r;
	vector<int> a;
}t[N * 40];

struct _two{
	int a , b;
}a[N];

int n , tot , root , m;
int fa[N];

int Get(int x){
	return fa[x] ? fa[x] = Get(fa[x]) : x;
}

void Update(int x , int y){
	fa[y] = x; a[x].a = min(a[x].a , a[y].a); a[x].b = max(a[y].b , a[x].b);
}

void Calc(int &x , int l , int r , int pos){
	if (!x) return;
	Fe (i , t[x].a)
		if (Get(*i) != m)
			Update(m , Get(*i));
	t[x].a.clear();
	int mid = (l + r - 1) / 2;
	if (pos <= mid)
		Calc(t[x].l , l , mid , pos);
	else
		Calc(t[x].r , mid + 1 , r , pos);
}

void Change(int &x , int l , int r , int st , int en){
	if (!x)	x = ++tot;
	if (st <= l && r <= en){
		t[x].a.push_back(m); return;
	}
	int mid = (l + r - 1) / 2;
	if (st <= mid) Change(t[x].l , l , mid , st , en);
	if (mid < en) Change(t[x].r , mid + 1 , r , st , en);
}

int main(){
	scanf("%d" , &n); int type , x , y;
	fo (i , 1 , n){
		scanf("%d%d%d" , &type , &x , &y);
		if (type == 1){
			a[++m] = (_two){x , y};
			Calc(root , -inf , inf , x);
			Calc(root , -inf , inf , y);
			if (a[m].a + 1 < a[m].b) Change(root , -inf , inf , a[m].a + 1 , a[m].b - 1);
		}
		else{
			x = Get(x); y = Get(y);
			if (x == y || a[y].a < a[x].a && a[x].a < a[y].b || a[y].a < a[x].b && a[x].b < a[y].b)
				puts("YES");
			else
				puts("NO");
		}
	}
	return 0;
}
