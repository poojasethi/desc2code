#include <bits/stdc++.h>
using namespace std;

#define N 200010
struct que{
    int op,x,y;
}q[N];
int n,bin[N],cnt,id;map<int,int>M;
int F[N],cur,ml[N],mr[N],tot,seq[N],vis[N];

int gf(int x){
    return (F[x] == x) ? x : (F[x] = gf(F[x]));
}
vector <int> s[N << 2];

#define ls (x << 1)
#define rs (x << 1 | 1)

void find(int pos,int l,int r,int x){
    while(!s[x].empty()){
        int y = s[x].back();
        s[x].pop_back();
        if(!vis[y]) vis[y] = 1, seq[++ tot] = y;
    }
    if(l == r)  return;
    int mid = (l + r) >> 1;
    if(pos <= mid)  find(pos,l,mid,ls);
    else        find(pos,mid + 1,r,rs);
}
void cover(int ql,int qr,int v,int l,int r,int x){
    if(ql <= l && r <= qr){
        s[x].push_back(v);
        return;
    }
    int mid = (l + r) >> 1;
    if(ql <= mid)   cover(ql,qr,v,l,mid,ls);
    if(mid < qr)    cover(ql,qr,v,mid + 1,r,rs);
}
void add(int l,int r){
    tot = 0;
    find(l,1,cnt,1);
    find(r,1,cnt,1);
    ++ cur;
    F[cur] = cur,ml[cur]=l,mr[cur]=r;
    for(int i = 1;i <= tot;i ++){
        ml[cur] = min(ml[cur], ml[seq[i]]);
        mr[cur] = max(mr[cur], mr[seq[i]]);
        F[gf(seq[i])] = cur;
    }
    if(ml[cur] + 1 <= mr[cur] - 1)  cover(ml[cur] + 1,mr[cur] - 1,cur,1,cnt,1);
}
int main(){
    scanf("%d",&n);
    register int i;
    for(i = 1;i <= n;i ++){
        scanf("%d%d%d",&q[i].op,&q[i].x,&q[i].y);
        if(q[i].op&1)   bin[++ cnt] = q[i].x, bin[++ cnt] = q[i].y;
    }
    sort(bin + 1,bin + cnt + 1);
    for(bin[0]=-1<<30,i=1;i<=cnt;++i)if(bin[i]!=bin[i-1])M[bin[i]]=++id;
    for(int i = 1;i <= n;i ++){
        if(q[i].op == 1)    q[i].x = M[q[i].x], q[i].y = M[q[i].y];
        if(q[i].op == 1)    add(q[i].x,q[i].y);
        else{
            int x = gf(q[i].x), y = gf(q[i].y);
            if(x == y || mr[x] > ml[y] && mr[x] < mr[y] || ml[x] > ml[y] && ml[x] < mr[y])  printf("YES\n");
            else    printf("NO\n");
        }
    }
    return 0;
}