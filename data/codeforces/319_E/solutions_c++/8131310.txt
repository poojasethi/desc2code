#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
#define x first
#define y second

const int maxn = 100008, infi = (int)1e9 + 1;
int Q, t[maxn], f[maxn], rk[maxn], ml[maxn], mr[maxn], n, tot, cnt, cur;
pair<int, int> a[maxn];


int Father(int x) 
	{return x == f[x] ? x : (f[x] = Father(f[x]));}

inline void Link(int x, int y) {
	x = Father(x); y = Father(y);
	if (rk[x] < rk[y]) swap(x, y);
	f[y] = x;
	rk[x] += rk[x] == rk[y];
	ml[x] = min(ml[x], ml[y]);
	mr[x] = max(mr[x], mr[y]);
}

struct SegmentTree {
	struct Node {
		Node *l, *r; vector<int> v;

		Node() {l = r = 0;}
	} *rt;

	void Cover(Node *&x, int s, int t, int d, int l = -infi, int r = infi) {
		if (x == NULL) x = new Node(); 
		if (s <= l && t >= r) 
			{x->v.push_back(d); return ;}
		int m = l + r >> 1;
		if (s <= m) Cover(x->l, s, t, d, l, m);
		if (m < t) Cover(x->r, s, t, d, m + 1, r);
	}

	void Query(Node *x, int pos, int d, int l = -infi, int r = infi) {
		if (x == NULL) return ;
		while (!x->v.empty()) {
			int k = x->v.back();
			x->v.pop_back();
			Link(k, d);
		}
		if (l == r) return ;
		int m = l + r >> 1;
		if (pos <= m) Query(x->l, pos, d, l, m);
		else Query(x->r, pos, d, m + 1, r);
	}
} T;

int main(void) {
	scanf("%d", &Q); n = Q;
	for (int i = 1; i <= Q; i++) {
		int k, x, y; scanf("%d%d%d", &k, &x, &y);
		if (k == 1) {
			ml[++tot] = x; mr[tot] = y; f[tot] = tot;
			a[tot] = make_pair(x, y); rk[tot] = 0;
			T.Query(T.rt, x, tot); T.Query(T.rt, y, tot);
			T.Cover(T.rt, ml[Father(tot)] + 1, mr[Father(tot)] - 1, Father(tot));
		}
		else {
			y = Father(y);
			if (Father(x) == y || ml[y] <= a[x].x && a[x].y < mr[y])
				printf("YES\n");
			else printf("NO\n");
		}
	}
	return 0;
}
