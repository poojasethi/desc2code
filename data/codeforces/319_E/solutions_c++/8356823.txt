#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
#include<string>
#include<set>
#define LL long long
#define fi first
#define se second
#define MP make_pair
#define PII pair<int,int>
#define PIII pair<int,PII>
#define lc (p<<1)
#define rc ((p<<1)+1)
#define mid ((l+r)>>1)
using namespace std;
struct DSU
{
	int fa,l,r;
}f[100010];
PIII p[100010];
int m,x,y,z,c[200010],tot,now;
PII I[100010];
void read(int &x)
{
	char ch=getchar();int mark=1;for(;ch!='-'&&(ch<'0'||ch>'9');ch=getchar());if (ch=='-') mark=-1,ch=getchar();
	for(x=0;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-48;x*=mark;
}
DSU find(int x){return (f[x].fa==x)?f[x]:f[x]=find(f[x].fa);}
void Union(int x,int y)
{
	int u=find(x).fa,v=find(y).fa;
	if (u==v) return;
	f[v].fa=u;
	f[u].l=min(f[u].l,f[v].l);
	f[u].r=max(f[u].r,f[v].r);
}
struct seg_tre
{
	vector<int> tr[800010];
	void Getunion(int p,int l,int r,int x)
	{
		for(int i=0;i<tr[p].size();i++) Union(now,tr[p][i]);
		tr[p].clear();
		if (l==r-1) return;
		if (x+1<=mid) Getunion(lc,l,mid,x);
		else Getunion(rc,mid,r,x);
	}
	void Cover(int p,int l,int r,int a,int b)
	{
		if (l==a&&r==b) {tr[p].push_back(now);return;}
		if (b<=mid) Cover(lc,l,mid,a,b);
		else if (a>=mid) Cover(rc,mid,r,a,b);
		else
		{
			Cover(lc,l,mid,a,mid);Cover(rc,mid,r,mid,b);
		}
	}
}T; 
int main()
{
	read(m);
	for(int i=1;i<=m;i++)
	{
		read(x);read(y);read(z);p[i]=MP(x,MP(y,z));
		if (x==1) c[++tot]=y,c[++tot]=z;
	}
	sort(c+1,c+tot+1);
	tot=unique(c+1,c+tot+1)-(c+1);
	now=0;
	for(int i=1;i<=m;i++)
	{
		int x=p[i].se.fi,y=p[i].se.se;
		if (p[i].fi==1)
		{
			x=lower_bound(c+1,c+tot+1,x)-c;y=lower_bound(c+1,c+tot+1,y)-c;
			I[++now]=MP(x,y);
			f[now].fa=now;f[now].l=x;f[now].r=y;
			T.Getunion(1,1,tot+1,x);T.Getunion(1,1,tot+1,y);
			if (f[now].l+1<=f[now].r-1) T.Cover(1,1,tot+1,f[now].l+1,f[now].r); 
		}
		else
		{
			if (find(x).fa==find(y).fa||(f[y].l<=I[x].fi&&I[x].se<=f[y].r)) printf("YES\n");else printf("NO\n");
		}
	}
	return 0;
}
