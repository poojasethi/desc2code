#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<set>
#include<map>
#include<queue>
#include<cmath>
#define X first
#define Y second
#define fo(i,n) for(int i=0;i<n;i++)
#define fr(i,n) for(int i=1;i<=n;i++)
#define pb push_back
#define lson l,mid,rt<<1
#define rson mid+1,r,rt<<1|1

using namespace std;

typedef long long ll;

const int mod=(int)1e9+7;

struct Event{
	int t,a,b;
}e[101000];

int T[201000],m,n,cnt;
int L[101000],R[101000];
int p[101000];

int find(int x){
	if(x!=p[x]) p[x]=find(p[x]);
	return p[x];
}

int minL[201000<<2],maxR[201000<<2];
vector<int>seg[201000<<2];

void query(int l,int r,int rt,int x){
	for(int i=0;i<seg[rt].size();i++){
		L[cnt]=min(L[cnt],L[seg[rt][i]]);
		R[cnt]=max(R[cnt],R[seg[rt][i]]);
		p[find(seg[rt][i])]=cnt;
	}
	seg[rt].clear();
	if(l==r) return;
	int mid=l+r>>1;
	if(x<=mid) query(lson,x);
	else query(rson,x);
}

void update(int L,int R,int l,int r,int rt){
	if(L>R) return;
	if(L<=l&&r<=R){
		seg[rt].pb(cnt);
		return;
	}
	int mid=l+r>>1;
	if(L<=mid) update(L,R,lson);
	if(mid<R) update(L,R,rson);
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d%d",&e[i].t,&e[i].a,&e[i].b);
		if(e[i].t==1){
			T[++m]=e[i].a;
			T[++m]=e[i].b;
		}
	}
	sort(T+1,T+m+1);
	m=unique(T+1,T+m+1)-T-1;
	for(int i=1;i<=n;i++){
		if(e[i].t==1){
			cnt++;p[cnt]=cnt;
			int pl=lower_bound(T+1,T+m+1,e[i].a)-T;
			int pr=lower_bound(T+1,T+m+1,e[i].b)-T;
			L[cnt]=pl,R[cnt]=pr;
			query(1,m,1,pl);
			query(1,m,1,pr);
			update(L[cnt]+1,R[cnt]-1,1,m,1);
		}
		else{
			int fa=find(e[i].a);
			int fb=find(e[i].b);
			if(fa==fb||L[fb]<=L[fa]&&R[fa]<=R[fb])
				puts("YES");
			else puts("NO");
		}
	}
	return 0;
}
