#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <string>
#include <vector>
using namespace std;
int n, m, i, j, k, x, y, z, task;
int cnt, root;
const int INF = 1000000000;

int getint() {
	int ret = 0, p = 1;
	char ch = getchar();
	while ( ( ch < '0' || ch > '9' ) && ch != '-' ) ch = getchar();
	if ( ch == '-' ) ch = getchar(), p = -1;
	while ( ch >= '0' && ch <= '9' ) {
		ret = ret * 10 + ch - '0';
		ch = getchar();
	}
	return ret * p;
}

struct Point {
	int x, y;
} a[ 200010 ];

struct Node {
	int lc, rc;
	vector < int > v;
} t[ 120010 * 40 ];
int nodecnt;

int f[ 200010 ];
int find( int x ) {
	return x == f[ x ] ? x : f[ x ] = find( f[ x ] );
}

void Merge( int x, int y ) {
	a[ x ].x = min( a[ x ].x, a[ y ].x );
	a[ x ].y = max( a[ x ].y, a[ y ].y );
}

void Modify( int o, int l, int r, int k ) {
	if ( !o ) return;
	int i;
	for ( i = 0; i < t[ o ].v.size(); i++ ) {
		int tar = t[ o ].v[ i ];
		Merge( cnt, find( tar ) );
		f[ find( tar ) ] = cnt;
	}

	t[ o ].v.clear();
	if ( l == r ) return;
	int mid = ( l + r ) / 2;
	if ( mid == r ) mid--;
	if ( k <= mid ) Modify( t[ o ].lc, l, mid, k );
	else Modify( t[ o ].rc, mid + 1, r, k );
}

void build( int &o, int l, int r, int x, int y ) {
	if ( !o ) o = ++nodecnt;
	if ( x <= l && y >= r ) { t[ o ].v.push_back( cnt ); return; }
	int mid = ( l + r ) / 2;
	if ( mid == r ) mid--;
	if ( x <= mid ) build( t[ o ].lc, l, mid, x, y );
	if ( mid < y ) build( t[ o ].rc, mid + 1, r, x, y );
}

int main()
{
	n = getint();
	while ( n-- ) {
		task = getint(), x = getint(), y = getint();
		if ( task == 1 ) {
			a[ ++cnt ] = ( Point ){ x, y };
			f[ cnt ] = cnt;
			Modify( root, -INF, INF, x );
			Modify( root, -INF, INF, y );
			if ( a[ cnt ].x + 1 < a[ cnt ].y ) build( root, -INF, INF,a[ cnt ].x + 1, a[ cnt ].y - 1 );
		}
		else {
			x = find( x ), y = find( y );
			if ( x == y || a[ x ].x > a[ y ].x && a[ x ].x < a[ y ].y || a[ x ].y > a[ y ].x && a[ x ].y < a[ y ].y ) puts( "YES" );
			else puts( "NO" );
		}
	}
	return 0;
}