#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <deque>

#define REP(AA,BB) for(AA=0; AA<(BB); ++AA)
#define FOR(AA,BB,CC) for(AA=(BB); AA<(CC); ++AA)
#define FC(AA,BB) for(typeof(AA.begin()) BB=AA.begin(); BB!=AA.end(); ++BB)
#define SZ(AA) ((int)(AA.size()))
#define ALL(AA) (AA).begin(), (AA).end()
#define PB push_back
#define MP(AA,BB) make_pair((AA), (BB))

#define INF 100000000000000000LL

using namespace std;

typedef vector<int> VI;
typedef pair<int, int> PII;

long long c[1010][1010], d[1010][1010], sum[1010][1010], mn[1010][1010];
int us[1010][1010], BASE=1024;
int N, M, A, B;

long long suma(int x, int y) {
	long long res=sum[x+A-1][y+B-1];
	if(x>0)
		res-=sum[x-1][y+B-1];
	if(y>0)
		res-=sum[x+A-1][y-1];
	if(x>0 && y>0)
		res+=sum[x-1][y-1];
	return res;
}

int main(void) {
	int i, j, k, l;
	scanf("%d%d%d%d", &N, &M, &A, &B);
	REP(i,N) {
		REP(j,M)
			scanf("%I64d", &c[i][j]);
	}
	REP(i,N) {
		REP(j,M) {
			sum[i][j]=c[i][j];
			if(i>0)
				sum[i][j]+=sum[i-1][j];
			if(j>0)
				sum[i][j]+=sum[i][j-1];
			if(i>0 && j>0)
				sum[i][j]-=sum[i-1][j-1];
		}
	}
	REP(j,M) {
		deque<pair<long long, int> > cur;
		for(i=N-1; i>=0; --i) {
			while(!cur.empty() && cur.back().first>c[i][j])
				cur.pop_back();
			cur.push_back(MP(c[i][j],i));
			if(cur.front().second==i+A)
				cur.pop_front();
			d[i][j]=cur.front().first;
		}
	}
	REP(i,N) {
		deque<pair<long long, int> > cur;
		for(j=M-1; j>=0; --j) {
			while(!cur.empty() && cur.back().first>d[i][j])
				cur.pop_back();
			cur.push_back(MP(d[i][j],j));
			if(cur.front().second==j+B)
				cur.pop_front();
			mn[i][j]=cur.front().first;
		}
	} 
	vector<pair<long long, PII> > P;
	REP(i,N-A+1) {
		REP(j,M-B+1)
			P.PB(MP(suma(i,j)-mn[i][j]*A*B, MP(i,j)));
	}  
	sort(ALL(P)); vector<pair<long long, PII> > res;
	REP(i,SZ(P)) {
		int a=P[i].second.first, b=P[i].second.second;
		if(!us[a][b]) {
			FOR(j,max(0,a-A+1),a+A) {
				FOR(k,max(0,b-B+1),b+B)
					us[j][k]=1;
			}
			//printf("S %I64d %I64d\n", g, suma(a,b));
			res.PB(P[i]);
		}
	}
	printf("%d\n", SZ(res));
	REP(i,SZ(res))
		printf("%d %d %I64d\n", res[i].second.first+1, res[i].second.second+1, res[i].first);
	return 0;
}
	
