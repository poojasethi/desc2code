#include <cstdio>
#include <iostream>
#include <algorithm>
#include <queue>
#define turn(i) (((i)&1)?(i)+1:(i)-1)
#define oo 2000000000
using namespace std;

 int e[5000005]={0};
 int last[5000005]={0};
 int value[5000005]={0};
int  now[5000005]={0};
int  cap[5000005]={0};
int totm=0;

struct case1
{
 int s,t,v;
 int num;
}task[2005]={0};


void addedge(int x,int y,int c,int v)
{
 e[++totm]=y;
 last[totm]=now[x];
 now[x]=totm;
 value[totm]=v;
 cap[totm]=c;

 e[++totm]=x;
 last[totm]=now[y];
 now[y]=totm;
 value[totm]=-v;
 cap[totm]=0;
}

bool cmp(case1 a,case1 b)
{
 return a.s<b.s;
}

int dist[5005]={0};
int up[5005]={0};
int edge[5005]={0};
int hash[5005]={0};
queue<int> Q;

bool spfa(int n)
{

 int i,x;
 int maxflow=oo;

 for(i=1;i<=n;i++)
   {
      dist[i]=-oo;
      hash[i]=0;
   }
   dist[n-1]=0;
   hash[n-1]=1;
 Q.push(n-1);

 while(!Q.empty())
   {

    x=Q.front();
    Q.pop();
    hash[x]=0;

    for(i=now[x];i;i=last[i])
      if(cap[i]>0&&dist[x]+value[i]>dist[e[i]])
       {
          dist[e[i]]=dist[x]+value[i];
          up[e[i]]=x;
         edge[e[i]]=i;

        if(!hash[e[i]])
         {
             hash[e[i]]=1;
             Q.push(e[i]);


         }
       }
   }
 if(dist[n]==-oo) return false;
 
 for(i=n;i!=n-1;i=up[i])  if(cap[edge[i]]<maxflow) maxflow=cap[edge[i]];


 for(i=n;i!=n-1;i=up[i])
   {

    cap[edge[i]]-=maxflow;
    cap[turn(edge[i])]+=maxflow;
   }

 return true;
}

int ans[2005]={0};

int main()
{
 int n,k,i,j;

 scanf("%d%d",&n,&k);

 for(i=1;i<=n;i++)
   {
    scanf("%d%d%d",&task[i].s,&task[i].t,&task[i].v);
    task[i].t+=task[i].s-1;
    task[i].num=i;
   }

 sort(task+1,task+n+1,cmp);

 for(i=1;i<=n;i++)
   {
    addedge(i,i+n,1,task[i].v);
    addedge(i+n,2*n+2,1,0);
   }

 addedge(n,2*n+2,k,0);

 for(i=1;i<n;i++)
   {
    addedge(i,i+1,k,0);

    for(j=i+1;j<=n;j++)
      if(task[i].t<task[j].s)
       {
        addedge(i+n,j,1,0);
        break;
       }
   }

 addedge(2*n+1,1,k,0);

 for(;spfa(2*n+2););

 for(i=1;i<=n;i++)
   {
    for(j=now[i];j;j=last[j])
      if(e[j]==n+i)
       if(cap[j]==0)
        ans[task[i].num]=1;
   }

 for(i=1;i<=n;i++)
   printf("%d ",ans[i]);

 return 0;
}
