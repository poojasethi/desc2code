#include <cstdio>
#include <algorithm>
#include <vector>

using std::vector;

const int INF = 1000000000;

struct Cell{
	int s,c,t,id;
	bool operator < (const Cell &q) const {
		return s < q.s || s == q.s && t < q.t;
	}
};

vector < Cell > cells;
vector < int > edgeFrom, edgeTo, edgeValue, edgeCost, from, edge;

void addEdge(int fromEdge, int toEdge, int value, int cost){
	for(int i = 0; i < 2; i++){
		edgeTo.push_back(toEdge);
		edgeFrom.push_back(fromEdge);
		edgeValue[edgeTo.size() - 1] = value;
		edgeCost.push_back(cost);
		std::swap(fromEdge, toEdge);
		value = 0;
		cost *= -1;
	}
	
}

void createGraph(int n, int S, int T){
	for(int i = 0; i < n; i++){
		addEdge(S, i << 1, INF, 0);
		addEdge((i << 1) + 1, T, INF, 0);
	}
	for(int i = 0; i < n; i++){
		int t2 = cells[i].id << 1;
		addEdge(cells[i].id << 1, (cells[i].id << 1) + 1, 1, -cells[i].c);
	}
	std::sort(cells.begin(), cells.begin() + n);
	for(int i = 0; i < n; i++){
		if (i != n - 1){
			addEdge(cells[i].id << 1, cells[i + 1].id << 1, INF, 0);
		}
		for(int j = i + 1; j < n; j++){
			if(cells[i].s + cells[i].t - 1 < cells[j].s){
				addEdge((cells[i].id << 1) + 1, cells[j].id << 1, INF, 0);
				break;
			}
		}
	}
}
bool find_path(int n, int S, int T){
	int count = edgeTo.size();
	vector < int > d(T + 1, INF);
	d[S] = 0;
	for(int i = 0; i <= T; i++){
		bool flag = false;
		for(int j = 0; j < count; j++)
			if(edgeValue[j] && d[edgeTo[j]] > d[edgeFrom[j]] + edgeCost[j]){
				d[edgeTo[j]] = d[edgeFrom[j]] + edgeCost[j];
				from[edgeTo[j]] = edgeFrom[j];
				edge[edgeTo[j]] = j;
				flag = true;
			}
		if(!flag)
			break;
	}
	return d[T] != INF;
}

int main(){
	//freopen("1.txt", "r", stdin);
	int n, k;
	scanf("%d%d",&n,&k);
	int S = n << 1, T = (n << 1) + 1;
	int N = T + 1;
	edge.resize(N);
	from.resize(N);
	edgeValue.resize(N * N);
	for(int i = 0; i < n; i++){
		Cell cell;
		scanf("%d%d%d", &cell.s, &cell.t, &cell.c);
		cell.id = i;
		cells.push_back(cell);
	}
	createGraph(n, S, T);
	while(find_path(n, S, T)){
		for(int v = T; v != S; v = from[v]){
			--edgeValue[edge[v]];
			++edgeValue[edge[v] ^ 1];
		}
		if (!(--k))
			break;
	}
	
	for(int i = n << 2; i < 6 * n; i += 2)
		printf("%d ", !edgeValue[i]);
	return 0;
}