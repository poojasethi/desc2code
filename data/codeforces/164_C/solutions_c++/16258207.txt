#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long LL;
const LL maxn=3e3+100;
const LL INF=1e9;
vector<LL> H;
LL n,k,s[maxn],t[maxn],c[maxn],i,h[maxn],line[maxn],o,m,S,T;
struct Edge{
	LL from,to,cap,flow,cost;
};
vector<Edge>edges;
vector<LL> G[maxn];
LL inq[maxn];
LL d[maxn];
LL p[maxn];
LL a[maxn];
void AddEdge(LL from,LL to,LL cap,LL cost){
	edges.push_back((Edge){from,to,cap,0,cost});
	edges.push_back((Edge){to,from,0,0,-cost});
	m=edges.size();
	G[from].push_back(m-2);
	G[to].push_back(m-1);
}
bool BellmanFord(LL &flow,LL &cost){
	for(LL i=0;i<maxn;++i)d[i]=INF;
	memset(inq,0,sizeof(inq));
	d[S]=0;inq[S]=1;p[S]=0;a[S]=INF;
	queue<LL>Q;
	Q.push(S);
	while(!Q.empty()){
		LL u=Q.front();Q.pop();
		inq[u]=0;
		for(LL i=0;i<G[u].size();++i){
			Edge &e=edges[G[u][i]];
			if(e.cap>e.flow&&d[e.to]>d[u]+e.cost){
				d[e.to]=d[u]+e.cost;
				p[e.to]=G[u][i];
				a[e.to]=min(a[u],e.cap-e.flow);
				if(!inq[e.to]){
					Q.push(e.to);
					inq[e.to]=1;
				}
			}
		}
	}
	if(d[T]==INF)return 0;
	flow+=a[T];
	cost+=d[T]*a[T];
	LL u=T;
	while(u!=S){
		edges[p[u]].flow+=a[T];
		edges[p[u]^1].flow-=a[T];
		u=edges[p[u]].from;
	}
	return 1;
}
int main(){
	LL i;
	scanf("%I64d%I64d",&n,&k);
	for(i=0;i<n;++i){
		 scanf("%I64d%I64d%I64d",&s[i],&t[i],&c[i]);
		 h[o++]=s[i];
		 h[o++]=s[i]+t[i];
	}
	sort(h,h+o);
	for(i=0;i<o;++i){
		if(i&&h[i]==h[i-1])continue;
		H.push_back(h[i]);
		AddEdge((int)H.size()-1,(int)H.size(),k,0);
	}
	T=H.size();S=T+1;
	AddEdge(S,0,k,0);
	for(i=0;i<n;++i){
		t[i]=lower_bound(H.begin(),H.end(),s[i]+t[i])-H.begin();
		s[i]=lower_bound(H.begin(),H.end(),s[i])-H.begin();
		AddEdge(s[i],t[i],1,-c[i]);
		line[i]=edges.size()-2;
	}
	LL flow=0,cost=0;
	while(BellmanFord(flow,cost));
	for(i=0;i<n;++i){
		printf("%I64d ",edges[line[i]].flow);
	}
	return 0;
}
   				 		    	  	  		     	 	