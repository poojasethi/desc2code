#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

using namespace std;

const int MaxN =2200;
const int INF = 0x3f3f3f3f;

struct Node{
	int v,c,cost,num;
	Node *nxt,*twin;
}*g[MaxN],pool[MaxN*10],*TAIL=pool,*pre[MaxN];

int n,k,S,T;
int list[MaxN],tail;
int op[MaxN],ed[MaxN],c[MaxN],flag[MaxN];
int d[MaxN],flow[MaxN];

inline int mapping(int t){return lower_bound(list+1,list+tail+1,t)-list;}
inline void make_edge(int u,int v,int c,int cost,int num=0){
	TAIL->v=v;TAIL->c=c;TAIL->cost=cost; TAIL->num=num;TAIL->twin=TAIL+1;TAIL->nxt=g[u];g[u]=TAIL++;
	TAIL->v=u;TAIL->c=0;TAIL->cost=-cost;TAIL->num=0;  TAIL->twin=TAIL-1;TAIL->nxt=g[v];g[v]=TAIL++;	
}

int spfa(){
	static int inq[MaxN];
	queue<int> q;
	memset(d,0x3f,sizeof(d));d[S]=0;
	memset(flow,0,sizeof(flow));flow[S]=INF;
	memset(pre,0,sizeof(pre));
	q.push(S);inq[S]=1;
	while(!q.empty()){
		int u=q.front();q.pop();inq[u]=0;
		for(Node *p=g[u];p;p=p->nxt) if(p->c && p->cost+d[u]<d[p->v]){
			d[p->v]=d[u]+p->cost;flow[p->v]=min(flow[u],p->c);pre[p->v]=p;
			if(!inq[p->v]) q.push(p->v),inq[p->v]=1;
		}
	}
	return d[T]<INF;
}
int aug(){
	int dt=flow[T]*d[T];
	for(Node *p=pre[T];p;p=pre[p->twin->v]) p->c-=flow[T],p->twin->c+=flow[T];
	return dt;
}
int costFlow(){
	int res=0;
	while(spfa()) res+=aug();
	return res;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%d%d%d",&op[i],&ed[i],&c[i]);
		ed[i]+=op[i];list[++tail]=op[i];list[++tail]=ed[i];
	}
	sort(list+1,list+tail+1);
	tail=unique(list+1,list+tail+1)-list-1;
	S=0,T=tail+1;
	make_edge(S,1,k,0);
	for(int i=1;i<=tail;i++) make_edge(i,i+1,INF,0);
	for(int i=1;i<=n;i++) op[i]=mapping(op[i]),ed[i]=mapping(ed[i]),make_edge(op[i],ed[i],1,-c[i],i);
	costFlow();
	for(Node *p=pool;p<TAIL;p++) if(p->num && !p->c) flag[p->num]=1;
	for(int i=1;i<=n;i++) printf("%d ",flag[i]);puts("");
	return 0;
}
