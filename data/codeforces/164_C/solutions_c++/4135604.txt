#include<bits/stdc++.h>
using namespace std;

#define TR(v,i) for(__typeof((v).begin())i=(v).begin();i!=(v).end();++i)
#define all(x) (x).begin(), (x).end()
const int N = 1000, V = 2*N+2, E = 3*N+1, INF = 0x3f3f3f3f;
int a[N], b[N], taskIdx[N], c[N], n, m, k, lim[2*E], cost[2*E], flow[2*E], d[V];
pair<int, int> trace[V];
bool inqueue[V];
vector<pair<int, int> > g[V];

void enter() {
	cin >> n >> k;
	for(int i = 0; i < n; ++i)
		cin >> a[i] >> b[i] >> c[i];
}

void add(int u, int v, int lim, int cost) {
	g[u].push_back(make_pair(v, m));
	g[v].push_back(make_pair(u, m+1));
	::lim[m] = lim; ::lim[m+1] = 0;
	::cost[m] = cost; ::cost[m+1] = -cost;
	m += 2;
}

void construct() {
	vector<pair<int, int> > task;
	for(int i = 0; i < n; ++i) {
		b[i] += a[i];
		task.push_back(make_pair(a[i], i));
		task.push_back(make_pair(b[i], i-n));
	}
	sort(all(task));
	add(0, 1, k, 0); add(task.size(), task.size()+1, k, 0);
	TR(task, i) {
		if(i->second >= 0) {
			taskIdx[i->second] = m;
			pair<int, int> p (b[i->second], i->second-n);
			add(i - task.begin() + 1, lower_bound(all(task), p) - task.begin() + 1, 1, -c[i->second]);
		}
		if(i != task.begin()) add(i - task.begin(), i - task.begin() + 1, k, 0);
	}
}

void mincost(int s, int t) {
	while(true) {
		memset(d, 0x3f, sizeof d); d[s] = 0; trace[s] = make_pair(-1, -1);
		queue<int> q; q.push(s); inqueue[s] = true;
		while(!q.empty()) {
			int u = q.front(); q.pop(); inqueue[u] = false;
			TR(g[u], it) {
				int v = it->first, id = it->second;
				if(lim[id] - flow[id] <= 0) continue;
				if(d[v] > d[u] + cost[id]) {
					d[v] = d[u] + cost[id];
					trace[v] = make_pair(u, id);
					if(!inqueue[v]) q.push(v), inqueue[v] = true;
				}
			}
		}
		if(d[t] == INF) break;
		int delta = INF;
		for(int v = t; trace[v].first != -1; v = trace[v].first)
			delta = min(delta, lim[trace[v].second] - flow[trace[v].second]);
		for(int v = t; trace[v].first != -1; v = trace[v].first) {
			flow[trace[v].second] += delta;
			flow[trace[v].second ^ 1] -= delta;
		}
	}
}

void print() {
	for(int i = 0; i < n; ++i)
		cout << (flow[taskIdx[i]] > 0 ? 1 : 0) << ' ';
	cout << '\n';
}

int main() {
	ios::sync_with_stdio(false);
	enter();
	construct();
	mincost(0, 2*n+1);
	print();
	return 0;
}
