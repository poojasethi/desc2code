
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <set>
#include <map>
using namespace std;
template <class T> void checkmin(T &t,T x){if (x < t) t = x;}
template <class T> void checkmax(T &t,T x){if (x > t) t = x;}


const int N=30005;
const int INF=1000000000;
struct edge{int x,y,c,w;edge *next,*op;}*ls[N],*fa[N],g[1000000];
int vs,vt,cost,e;
int d[N],Q[N],v[N];

void addedge(int x,int y,int c,int w){
     edge *p=&g[++e];
     edge *q=&g[++e];
     p->x=x; p->y=y; p->c=c; p->w= w; p->next=ls[x]; ls[x]=p; p->op=q;
     q->x=y; q->y=x; q->c=0; q->w=-w; q->next=ls[y]; ls[y]=q; q->op=p;
}

bool spfa(){
     int head=0,tail=1;
     for (int i=vs;i<=vt;i++){
         d[i]=-INF;
         v[i]=0;
     }
     d[vs]=0; v[vs]=1; Q[1]=vs;
     while (head!=tail){
           head++; if (head>=N) head=0;
           for (edge *t=ls[Q[head]];t;t=t->next)
             if (t->c && d[t->x]+t->w>d[t->y]){
               d[t->y]=d[t->x]+t->w;
               fa[t->y]=t;
               if (!v[t->y]){
                 v[t->y]=1;
                 tail++; if (tail>=N) tail=0;
                 Q[tail]=t->y;
               }
             }
           v[Q[head]]=0;
     }
     if (d[vt]<=0) return false;
     return true;
}

void change(){
     int nf=INF;
     for (int i=vt;i!=vs;i=fa[i]->x)
       if (fa[i]->c<nf) nf=fa[i]->c;
     cost+=nf*d[vt];
     for (int i=vt;i!=vs;i=fa[i]->x){
         fa[i]->c-=nf;
         fa[i]->op->c+=nf;
     }
}

void MCMF(){
     cost=0;
     while (spfa()) change();
}


int n,k;
set <int> Set;
struct Node{
	int st,ed;
	int w;
}a[N];

map <int,int> Ref;

int main(){
	scanf("%d%d",&n,&k);
	for (int i=1;i<=n;i++){
		scanf("%d%d%d",&a[i].st,&a[i].ed,&a[i].w);
		a[i].ed = a[i].st + a[i].ed;
		Set.insert(a[i].st);
		Set.insert(a[i].ed);
	}
	Set.insert(0);
	Set.insert(INF*2+2);
	int cnt = 0;
	for (set <int>::iterator it = Set.begin() ; it != Set.end() ; it++){
		Ref[*it] = ++cnt;
	}
	for (int i=1;i<cnt;i++)
		addedge(i,i+1,k,0);
	int save = e;
	for (int i=1;i<=n;i++){
		addedge(Ref[a[i].st],Ref[a[i].ed],1,a[i].w);
	}
	vs = 1; vt = cnt;
	MCMF();
//	printf("%d\n",cost);
	for (int i=1;i<=n;i++)
		printf("%d ",g[save+i*2].c);
}
