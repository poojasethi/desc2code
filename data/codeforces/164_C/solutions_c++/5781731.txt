#include <iostream>
#include <cstdlib>
#include <cstring>
#include <string>
#include <vector>
#include <utility>
#include <algorithm>
#include <cmath>
#include <queue>
#define INF 2000000100

using namespace std;

struct task {
	int s,e,c,id;
	bool operator<(const task& a) const {
		if (s != a.s) return s < a.s;
		return e < a.e;
	}
};

struct edge {
	int a,b,flow,cap,cost;
	edge(int a, int b, int flow, int cap, int cost) : a(a), b(b), flow(flow), cap(cap), cost(cost) {}
};

int n,k;
task t[1010];
vector<edge> E;
vector<int> g[1010];
int dist[1010],pree[1010];
priority_queue<pair<int,int> > pq;
int id[1010];

void addEdge(int a, int b, int cap, int cost) {
	g[a].push_back(E.size());
	E.push_back(edge(a,b,0,cap,cost));
	g[b].push_back(E.size());
	E.push_back(edge(b,a,0,0,-cost));
}

bool calcFlow() {
	for (int i = 1; i <= n+1; i++) dist[i] = INF;
	dist[0] = 0;
	pq.push(make_pair(0,0));
	while (!pq.empty()) {
		int d = -pq.top().first, a = pq.top().second;
		pq.pop();
		for (int i = 0; i < g[a].size(); i++) {
			int e = g[a][i];
			if (E[e].flow < E[e].cap && dist[a] + E[e].cost < dist[E[e].b]) {
				dist[E[e].b] = dist[a] + E[e].cost;
				pree[E[e].b] = e;
				pq.push(make_pair(-dist[E[e].b],E[e].b));
			}
		}
	}
	if (dist[n+1] == INF) return false;
	for (int v = n+1;v;) {
		int e = pree[v];
		E[e].flow++;
		E[e^1].flow--;
		v = E[e].a;
	}
	return true;
}

int main() {
	cin >> n >> k;
	t[0].s = 0;
	for (int i = 1; i <= n; i++) {
		cin >> t[i].s >> t[i].e >> t[i].c;
		t[i].e += t[i].s;
		t[i].id = i;
	}
	sort(t+1,t+n+1);
	t[n+1].s = INF;
	//for (int i = 0; i <= n; i++) cout << i << ": " << t[i].s << ' ' << t[i].e << endl;
	
	addEdge(0,1,k,0);
	for (int i = 1; i <= n; i++) {
		addEdge(i,i+1,INF,0);
		int l = i, r = n+1, mid;
		while (r-l > 1) {
			mid = (l+r)/2;
			if (t[mid].s >= t[i].e) r = mid;
			else l = mid;
		}
		id[t[i].id] = E.size();
		addEdge(i,r,1,-t[i].c);
	}
	while (calcFlow());
	for (int i = 1; i <= n; i++)
		cout << E[id[i]].flow << ' ';
}