#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
#define N 100005
#define M 5462617
#define inf 0x3f3f3f3f3f3f3f3fll
#define ll long long
#define add(u,v,w) e[++cnt]=(edge){v,head[0][u],w};head[0][u]=cnt;e[++cnt]=(edge){u,head[1][v],w};head[1][v]=cnt
using namespace std;
struct edge{
	ll to,next,w;
}e[N<<1];
struct road{
	ll u,v,w;
}l[N];
struct qnode{
	ll v,c;
	bool operator <(const qnode &r)const{
		return c>r.c;
	}
};
ll n,m,s,t,u,v,w,d[2][N],cnt,head[2][N],b[2][N],path[2][N];
void dijkstra(int f){
	int i,j,k,pr=f?t:s;
	for(i=1;i<=n;i++)d[f][i]=inf;
	priority_queue<qnode> q;
	d[f][pr]=0;
	q.push((qnode){pr,0});
	path[f][pr]=1;
	while(!q.empty()){
		qnode u=q.top();
		q.pop();
		if(b[f][u.v])continue;
		b[f][pr=u.v]=1;
		for(j=head[f][pr];j;j=e[j].next){
			k=e[j].to;
			if(d[f][pr]+e[j].w==d[f][k])
				path[f][k]=(path[f][k]+path[f][pr])%M;
			else if(d[f][pr]+e[j].w<d[f][k]){
				d[f][k]=d[f][pr]+e[j].w;
				q.push((qnode){k,d[f][k]});
				path[f][k]=path[f][pr];
			}
		}
	}
}
int main() {
	int i,j;
	cin>>n>>m>>s>>t;
	for(i=1;i<=m;i++){
		scanf("%lld%lld%lld",&u,&v,&w);
		add(u,v,w);
		l[i]=(road){u,v,w};
	}
	dijkstra(0);
	dijkstra(1);
	for(i=1;i<=m;i++)
	{
		u=l[i].u;
		v=l[i].v;
		w=l[i].w;
		if(d[0][u]+d[1][v]+w==d[0][t]){
			if(path[0][u]*path[1][v]%M==path[0][t])
				puts("YES");
			else if(w>1)
				puts("CAN 1");
			else puts("NO");
		}
		else if(d[0][u]+d[1][v]+1<d[0][t])
			printf("CAN %lld\n",d[0][u]+d[1][v]+w-d[0][t]+1);
		else 
			puts("NO");
	}
}
		    	   	 	      	    	 	