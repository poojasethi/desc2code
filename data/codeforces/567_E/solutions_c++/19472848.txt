#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <vector>
#include <queue>
#define M 100005
#define ll long long
using namespace std;
struct kxj{
	int t;
	ll v;
	bool operator <(const kxj &a)const{
		return v>a.v;
	}
};
struct node{
	int a,b,c;
}S[M];
vector<kxj>edge[2][M],E[M];
priority_queue<kxj>Q;
int n,dfn[M],low[M],tot;
ll dis[2][M];
bool mark[M];
void dfs(int x,int f){
	dfn[x]=low[x]=++tot;
	for(int i=0;i<E[x].size();i++){
		int y=E[x][i].t;
		int id=E[x][i].v;
		if(id==f)continue;
		if(!dfn[y]){
			dfs(y,id);
			if(low[y]>dfn[x])mark[id]=1;
			low[x]=min(low[x],low[y]);
		}else low[x]=min(low[x],dfn[y]);
	}
}
void dijkstra(int s,ll dist[],vector<kxj>a[]){
	for(int i=1;i<=n;i++){
		mark[i]=0;
		dist[i]=1LL<<60;
	}dist[s]=0;
	Q.push((kxj){s,0});
	while(!Q.empty()){
		kxj now=Q.top();Q.pop();
		int x=now.t;
		if(mark[x])continue;
		mark[x]=1;
		for(int i=0;i<a[x].size();i++){
			int y=a[x][i].t;
			int v=a[x][i].v;
			if(dist[y]>dist[x]+v){
				dist[y]=dist[x]+v;
				Q.push((kxj){y,dist[y]});
			}
		}
	}
}
int main(){
	int m,s,t,i,j,a,b,c;
	scanf("%d %d %d %d",&n,&m,&s,&t);
	for(i=1;i<=m;i++){
		scanf("%d %d %d",&a,&b,&c);
		edge[0][a].push_back((kxj){b,c});
		edge[1][b].push_back((kxj){a,c});
		S[i]=(node){a,b,c};
	}
	dijkstra(s,dis[0],edge[0]);
	dijkstra(t,dis[1],edge[1]);
	for(i=1;i<=m;i++){
		a=S[i].a,b=S[i].b,c=S[i].c;
		ll x=dis[0][t]-dis[0][a]-dis[1][b];
		if(x==c)E[a].push_back((kxj){b,i}),E[b].push_back((kxj){a,i});
	}memset(mark,0,sizeof(mark));
	dfs(s,0);
	for(i=1;i<=m;i++){
		a=S[i].a,b=S[i].b,c=S[i].c;
		ll x=dis[0][t]-dis[0][a]-dis[1][b];
		if(x==c&&mark[i])puts("YES");
		else if(x<=1)puts("NO");
		else printf("CAN %d\n",c-x+1);
	}
	return 0;
}
