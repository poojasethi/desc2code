#include <bits/stdc++.h>
#define fi first
#define se second

using namespace std;

typedef long long int lint;
typedef pair <lint,lint> ii;
typedef pair <ii,lint> iii;
typedef vector <ii> vi;
typedef vector <vi> vii;

const lint maxn=1e5+20;

lint N,M,S,T,mark[maxn],mark2[maxn],ans[maxn];
bool used[maxn];
vii komsu(maxn),tkomsu(maxn);
vector <iii> v,asd;

void SP(lint node,vii komsu){
	for(lint i=1;i<=N;i++)
		mark[i]=1e18 , used[i]=0;
	
	priority_queue < ii , vector < ii > , greater <ii> > heap;
	
	heap.push(ii(0,node));
	
	while(!heap.empty()){
		ii a=heap.top();
		heap.pop();
		
		if(used[a.se]) continue;
		
		mark[a.se]=a.fi;
		used[a.se]=1;
		
		for(lint i=0;i<komsu[a.se].size();i++){
			ii &x=komsu[a.se][i];
			if(used[x.fi]) continue;
			heap.push(ii(a.fi+x.se,x.fi));
		}
	}
}

int main(){
	scanf("%lld %lld %lld %lld",&N,&M,&S,&T);
	
	for(lint i=1;i<=M;i++){
		lint a,b,c;
		scanf("%lld %lld %lld",&a,&b,&c);
		komsu[a].push_back(ii(b,c));
		tkomsu[b].push_back(ii(a,c));
		v.push_back(iii(ii(a,b),c));
	}
	
	SP(T,tkomsu);
	for(lint i=1;i<=N;i++)
		mark2[i]=mark[i];
	SP(S,komsu);
	
	for(lint i=0;i<M;i++)
		if(mark[v[i].fi.fi]+v[i].se+mark2[v[i].fi.se]==mark[T])
			asd.push_back(iii(ii(mark[v[i].fi.fi] , mark[v[i].fi.fi]+v[i].se),i));
	
	sort(asd.begin(),asd.end());

	for(lint i=0,mx=0;i<asd.size();i++){
		if(asd[i].fi.fi>=mx)
			ans[asd[i].se]++;
		
		mx=max(mx,asd[i].fi.se);
		
		if(i==asd.size()-1 || (asd[i].fi.se >= asd[i+1].fi.fi && asd[i].fi.fi!=asd[i+1].fi.fi))
			ans[asd[i].se]++;
		
		if(!i || asd[i].fi.fi!=asd[i-1].fi.fi)
			ans[asd[i].se]++;
	}
	
	for(lint i=0;i<M;i++){
		if(ans[i]==3)
			printf("YES\n");
		
		else if(mark[T]-mark[v[i].fi.fi]-mark2[v[i].fi.se]-1 >= 1)
			printf("CAN %lld\n",v[i].se-(mark[T]-mark[v[i].fi.fi]-mark2[v[i].fi.se]-1));
		
		else
			printf("NO\n");
	}
	
	return 0;
}
