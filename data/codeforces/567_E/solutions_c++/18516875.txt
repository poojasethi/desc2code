#include<bits/stdc++.h>
using namespace std;
#define ll long long
typedef pair<ll,ll> ii;
typedef pair<ii,ll> iii;
#define st first
#define nd second
const ll oo=1e14;
const int N=1e5+5;
bool visit[N];
map <iii,ll> mp;
ll n,m,s,t,cnt=1,num[N],low[N],d[N],c[N];
vector <ii> G[5][N];
vector <iii> nG[N];
vector <iii> edge;
bool br[N];

void dij(ll s,ll d[],int wh) {
    priority_queue <ii, vector<ii>, greater<ii> > pq;
    ll i, u, v, du, uv;
    for (i=1; i<=n; i++) d[i] = oo;
    d[s] = 0; pq.push(ii(0, s));
    while (!pq.empty()) {
        u=pq.top().nd;
        du=pq.top().st;
        pq.pop();
        if (du!=d[u]) continue;
        for (i=0; i<G[wh][u].size(); i++) {
            v=G[wh][u][i].nd;
            uv=G[wh][u][i].st;
            if (d[v]>du+uv) {
                d[v]=du+uv;
                pq.push(ii(d[v], v));
            }
        }
    }
}

void khopcau(ll u,ll par) {
    low[u]=num[u]=cnt++;
    for(ll i=0;i<nG[u].size();i++) {
        ll v=nG[u][i].st.st; if(v==par) continue;
        ll index=nG[u][i].st.nd,w=nG[u][i].nd;
        if(num[v]) low[u]=min(low[u],num[v]);
        else {
            khopcau(v,u); low[u]=min(low[u],low[v]);
            if(low[v]>=num[v] && mp[iii(ii(u,v),w)]<=1)  br[index]=1;
        }
    }
}

 main() {
    cin>>n>>m>>s>>t;
    for(ll i=1;i<=m;i++) {
        ll u,v,w; cin>>u>>v>>w;
        G[1][u].push_back(ii(w,v));
        G[2][v].push_back(ii(w,u));
        edge.push_back(iii(ii(u,v),w));
    }
    dij(s,d,1); dij(t,c,2);
    for(ll i=0;i<edge.size();i++ ) {
         ll u=edge[i].st.st,v=edge[i].st.nd,w=edge[i].nd;
         mp[iii(ii(u,v),w)]++;
    }
    for(ll i=0;i<edge.size();i++) {
        ll u=edge[i].st.st,v=edge[i].st.nd,w=edge[i].nd;
        if(d[u]+w+c[v]<=d[t]) {
            nG[u].push_back(iii(ii(v,i),w));
            nG[v].push_back(iii(ii(u,i),w));
        }
    }
    khopcau(s,s);
    for(ll i=0;i<edge.size();i++) {
        if(br[i]) { cout<<"YES"<<endl; continue; }
        ll u=edge[i].st.st,v=edge[i].st.nd,w=edge[i].nd;
        if(d[u]+c[v]>=d[t] || d[t]-(d[u]+c[v])-1<=0 ) cout<<"NO"<<endl;
        else cout<<"CAN "<<w-(d[t]-(d[u]+c[v])-1)<<endl;
    }
}
