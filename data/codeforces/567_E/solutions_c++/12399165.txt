#include <bits/stdc++.h>
#define ft first
#define sd second
#define pb push_back
#define ool 2000000000000000LL
#define oo 1e9+7

using namespace std;

typedef pair <long long,long long> ii;
typedef pair <long long,ii> iii;

const int N_=100010;

vector <iii> v[2][N_];
vector <ii> vi[N_];
long long d[2][N_],z[N_],x[N_],y[N_],st[2],ans[N_],mn;
int n,m,cnt=1,num[N_],par[N_],low[N_],bridge=0;
bool tf[N_]={false};

void dfs(int u, int p = -1){
    num[u]=low[u]=cnt;
    cnt++;
    for (int i=0;i<vi[u].size();++i){
        long long c=vi[u][i].ft;
        long long b=vi[u][i].sd;
        if (b==p)   continue;
        if (num[c]) low[u] = min(low[u], num[c]);
        else {
            dfs(c, b);
            if (low[c] >= num[c]) tf[b] = 1;
            low[u] = min(low[u], low[c]);
        }
    }
}

void dijkstra(int t){
    for (int i=0;i<=n;++i){
        d[t][i]=ool;
    }
    long long u,f,du,uf;
    d[t][st[t]]=0LL;
    priority_queue <ii , vector <ii> , greater <ii> > pq;
    pq.push(ii(0LL,st[t]));
    while (!pq.empty()){
        u=pq.top().sd;
        du=pq.top().ft;
        pq.pop();
        if (du!=d[t][u])   continue;
        for (int i=0;i<v[t][u].size();++i){
            f=v[t][u][i].sd.ft;
            uf=v[t][u][i].ft;
            if (du+uf<d[t][f]){
                d[t][f]=du+uf;
                pq.push(ii(d[t][f],f));
            }
        }
    }
}

int main(){
    ios_base::sync_with_stdio(false);
//    freopen("INP.inp","r",stdin);
//    freopen("OUT.out","w",stdout);
    cin>>n>>m>>st[0]>>st[1];
    for (int i=0;i<m;++i){
        cin>>x[i]>>y[i]>>z[i];
        v[0][x[i]].pb(iii(z[i],ii(y[i],i)));
        v[1][y[i]].pb(iii(z[i],ii(x[i],i)));
    }
    dijkstra(0);
    dijkstra(1);
    mn=d[0][st[1]];
    for (int i=0;i<m;++i){
        long long res=d[0][x[i]]+d[1][y[i]]+z[i];
        if (res==mn){
            vi[x[i]].pb(ii(y[i],i));
            vi[y[i]].pb(ii(x[i],i));
        }
    }
    dfs(st[0]);
    for (int i=0;i<m;++i){
        if (tf[i] && d[0][x[i]]+d[1][y[i]]+z[i]==mn){
            cout<<"YES"<<endl;
        }
        else {
            long long res=mn-(d[0][x[i]]+d[1][y[i]]+1);
            if (res<1)  cout<<"NO"<<endl;
            else cout<<"CAN "<<z[i]-res<<endl;
        }
    }
}