#include <bits/stdc++.h>
#define ii pair< long long, int>
#define gt first
#define cs second

using namespace std;

typedef long long LL;

const int MAXN = 100005;
const int MAXM = 100005;
const LL MAX = 1e14;
const int MOD = 1e8 + 7;

int n, m, s, t;
LL d[3][MAXN], f[3][MAXN];

vector< ii> c[MAXN];

struct cmp{
    bool operator()(const ii &a,const ii &b)
    { return a.gt > b.gt; }
};

priority_queue< ii, vector<ii>, cmp> qu;

struct data{
    int f, l, w;
} a[MAXM];



void Dijkstra(int S, int type)
{
    fill ( d[type] + 1, d[type] + n + 1, MAX);

    d[type][S] = 0;
    f[type][S] = 1;

    qu.push( ii( 0, S));
    while(qu.size())
    {
        ii u = qu.top();
        qu.pop();
        if (d[type][u.cs] < u.gt) continue;
        if (c[u.cs].size())
            for(int i = 0; i < c[u.cs].size(); i ++)
        {
            ii v = c[u.cs][i];
            LL new_road = d[type][u.cs] + v.gt;
            if (d[type][v.cs] == new_road) f[type][v.cs] = (f[type][v.cs] + f[type][u.cs]) % MOD;
            if (d[type][v.cs] > new_road)
            {
                d[type][v.cs] = new_road;
                qu.push( ii( d[type][v.cs], v.cs));
                f[type][v.cs] = f[type][u.cs];
            }
        }
    }
}
void Change()
{
    for(int u = 1; u <= n; u ++) c[u].clear();
    for(int i = 1; i <= m; i ++) c[a[i].l].push_back( ii( a[i].w, a[i].f));
}
int main()
{

    scanf("%d %d %d %d", &n, &m, &s, &t);

    for(int i = 1; i <= m; i ++)
    {
        int u, v, C;
        scanf("%d %d %d", &u, &v, &C);
        c[u].push_back( ii( C, v));
        a[i].f = u;
        a[i].l = v;
        a[i].w = C;
    }

    Dijkstra( s, 1);

    LL Short_path = d[1][t];

    Change();
    Dijkstra( t, 2);

    for(int i = 1; i <= m; i ++)
    {
        int u = a[i].f, v = a[i].l, C = a[i].w;
        LL uv = d[1][u] + d[2][v] + 1ll * C;
        if (uv == Short_path && (f[1][u] * f[2][v]) % MOD == f[1][t]) {printf("YES\n");continue;}
        if (uv - Short_path + 1 < 1ll * C) printf("CAN %d\n", uv - Short_path + 1);
        else printf("NO\n");
    }
    return 0;
}
