
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10, M=1e5+10, mo0=1e9+7, mo1=99999991;
typedef long long ll;
const ll oo=0x3f3f3f3f3f3f3f3fll;
typedef pair<ll, int> pli;
#define mkpii(a, b) make_pair<ll, int> (a, b)
ll d[2][N];
int n, m, S, T, X[M], Y[M], W[M], ihead[2][N], cnt[2], ok[M], way[2][2][N];
struct E {
	int next, to, w;
}e[2][M];
void add(int x, int y, int w, int f) {
	e[f][++cnt[f]]=(E){ihead[f][x], y, w}; ihead[f][x]=cnt[f];
}
priority_queue<pli, vector<pli>, greater<pli> > q;
void dij(int s, ll *d, int f) {
	static int vis[N];
	memset(vis, 0, sizeof(int)*(n+1));
	memset(d, 0x3f, sizeof(ll)*(n+1));
	d[s]=0;
	way[f][0][s]=1;
	way[f][1][s]=1;
	q.push(mkpii(0, s));
	while(q.size()) {
		int x=q.top().second;
		q.pop();
		if(vis[x]) {
			continue;
		}
		vis[x]=1;
		for(int i=ihead[f][x]; i; i=e[f][i].next) {
			int y=e[f][i].to;
			if(d[y]>d[x]+e[f][i].w) {
				d[y]=d[x]+e[f][i].w;
				way[f][0][y]=way[f][0][x];
				way[f][1][y]=way[f][1][x];
				q.push(mkpii(d[y], y));
			}
			else if(d[y]==d[x]+e[f][i].w) {
				(way[f][0][y]+=way[f][0][x])%=mo0;
				(way[f][1][y]+=way[f][1][x])%=mo1;
			}
		}
	}
}
int main() {
	scanf("%d%d%d%d", &n, &m, &S, &T);
	for(int i=1; i<=m; ++i) {
		scanf("%d%d%d", &X[i], &Y[i], &W[i]);
		add(X[i], Y[i], W[i], 0);
		add(Y[i], X[i], W[i], 1);
	}
	dij(S, d[0], 0);
	dij(T, d[1], 1);
	for(int i=1; i<=m; ++i) {
		int u=X[i], v=Y[i];
		if(d[0][T]==d[0][u]+d[1][v]+e[0][i].w && 1ll*way[0][0][u]*way[1][0][v]%mo0==way[0][0][T] && 1ll*way[0][1][u]*way[1][1][v]%mo1==way[0][1][T]) {
			puts("YES");
		}
		else if(d[0][u]!=oo && d[1][v]!=oo && d[0][T]>d[0][u]+d[1][v]+1) {
			printf("CAN %I64d\n", d[0][u]+d[1][v]+W[i]-d[0][T]+1);
		}
		else {
			puts("NO");
		}
	}
	return 0;
}
