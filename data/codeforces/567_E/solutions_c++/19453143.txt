#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>

#define P1 524287
#define P2 131071
#define N 200010
#define p E[i].x
#define INF 0x3f3f3f3f3f3f3f3fLL
#define LL long long

using namespace std;

struct Edge{
	int x,y,v;
}E0[N];

struct edge{
	int x,to,v;
}E[N];

int g[N],f1[2][N],f2[2][N],ind[N],totE;
LL dis[2][N];
queue<int> q;
deque<int> Q;

void ade(int x,int y,int v){
	E[++totE]=(edge){y,g[x],v}; g[x]=totE;
}

int n,m,S,T;
bool flag[N];

int add(int a,int b,int P){
	if(a+b>=P) return a+b-P;
	return a+b;
}

void spfa(int t){
	for(int i=1;i<=n;i++) dis[t][i]=INF;
	Q.push_back(S); dis[t][S]=0; flag[S]=1;
	while(!Q.empty()){
		int x=Q.front(); Q.pop_front();
		flag[x]=0;
		for(int i=g[x];i;i=E[i].to)
			if(dis[t][p]>dis[t][x]+(LL)E[i].v){
				dis[t][p]=dis[t][x]+(LL)E[i].v;
				if(!flag[p]){
					flag[p]=1;
					if(dis[p]<dis[Q.front()]) Q.push_front(p);
					else Q.push_back(p);
				}
			}
	}
	f1[t][S]=f2[t][S]=1;
	memset(ind,0,sizeof(ind));
	for(int x=1;x<=n;x++){
		for(int i=g[x];i;i=E[i].to)
			if(dis[t][p]==dis[t][x]+(LL)E[i].v) ind[p]++;
	}
	q.push(S);
	while(!q.empty()){
		int x=q.front(); q.pop();
		for(int i=g[x];i;i=E[i].to)
			if(dis[t][p]==dis[t][x]+(LL)E[i].v){
				f1[t][p]=add(f1[t][p],f1[t][x],P1);
				f2[t][p]=add(f2[t][p],f2[t][x],P2);
				if((--ind[p])==0) q.push(p);
			}
	}
}

int main(){
	scanf("%d%d%d%d",&n,&m,&S,&T);
	for(int i=1,x,y,v;i<=m;i++){
		scanf("%d%d%d",&x,&y,&v);
		E0[i]=(Edge){x,y,v};
		ade(x,y,v);
	}
	spfa(0);
	memset(g,0,sizeof(g));
	totE=0;
	for(int i=1;i<=m;i++) ade(E0[i].y,E0[i].x,E0[i].v);
	swap(S,T);
	spfa(1);
	swap(S,T);
	for(int i=1;i<=m;i++){
		if(dis[0][E0[i].x]+dis[1][E0[i].y]+(LL)E0[i].v == dis[0][T]
		&& f1[0][E0[i].x]*(LL)f1[1][E0[i].y]%(LL)P1 == (LL)f1[0][T]
			&& f2[0][E0[i].x]*(LL)f2[1][E0[i].y]%(LL)P2 == (LL)f2[0][T])
			puts("YES");
		else{
			LL tmp=dis[0][E0[i].x]+dis[1][E0[i].y];
			if(tmp+1LL>=dis[0][T]) puts("NO");
			else printf("CAN %I64d\n",(LL)E[i].v-dis[0][T]+tmp+1LL);
		}
	}
	return 0;
}
   		  				 				     							  	