#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <queue>
#include <cmath>
#include <algorithm>
#include <stack>
#include <functional>
#include <map>
#include <vector>
#include <set>

using namespace std;
const long long INF = 1000000000000000000LL;
const int MAX_V = 100000 + 5;
const int MAX_E = 100000 + 5;
const int MOD = 1000776999;
long long sways[MAX_V], tways[MAX_V];
long long dist_s[MAX_V], dist_t[MAX_V];

struct Edge
{
	int from, to, cost;
	Edge(int from = 0, int to = 0, int cost = 0):from(from), to(to), cost(cost){}
};

Edge edges[MAX_E];
vector<Edge> G1[MAX_V];
vector<Edge> G2[MAX_V];
typedef pair<long long, int> P; //first是最短距离， second是定点的编号
int n, m, s, t;

void dijkstra(vector<Edge> G[MAX_V], int s, long long d[], long long ways[])
{
	int V = n + 1;
	priority_queue<P, vector<P>, greater<P> > que;
	fill(d, d + V, INF);
	d[s] = 0;
	ways[s] = 1;
	que.push(P(0, s));

	while(!que.empty()) {
		P p = que.top(); que.pop();
		int v = p.second;
		if(p.first > d[v]) continue;
		for(int i = 0; i < G[v].size(); i++) {
			Edge e = G[v][i];
			if(d[e.to] == d[v] + e.cost) {
				ways[e.to] =(ways[e.to] + ways[v]) % MOD;
			}
			else if(d[e.to] > d[v] + e.cost) {
				d[e.to] = d[v] + e.cost;
				ways[e.to] = ways[v];
				que.push(P(d[e.to], e.to));
			}
		}
	}
}
int main()
{
	scanf("%d%d%d%d", &n, &m, &s, &t);
	for(int i = 0; i < m; i++) {
		int u, v, c;
		scanf("%d%d%d", &u, &v, &c);
		edges[i] = Edge(u, v, c);
		G1[u].push_back(edges[i]);
		G2[v].push_back(Edge(v, u, c));
	}

	dijkstra(G1, s, dist_s, sways);
	dijkstra(G2, t, dist_t, tways);

	for(int i = 0; i < m; i++) {
		Edge e = edges[i];
		int u = e.from, v = e.to;
		if(dist_s[u] + dist_t[v] + e.cost == dist_s[t]) {
			if((sways[u]*tways[v])%MOD == sways[t]) {
				printf("YES\n");
			} else if(e.cost > 1) {
				printf("CAN 1\n");
			} else {
				printf("NO\n");
			}
		} else {
			long long tmp = dist_s[u] + dist_t[v] + e.cost - dist_s[t] + 1;
			if(e.cost - tmp > 0) {
				printf("CAN %I64d\n", tmp);
			} else {
				printf("NO\n");
			}

		}
	}
	return 0;
}

 	  				 			 		 		 		  					  	