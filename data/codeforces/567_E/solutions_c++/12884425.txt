#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
#include <queue>
using namespace std;
int n,m1,s,t;
const long long mol=119999827;
const int maxn=100005;
const long long inf=1e13;
struct Edge
{
    int s,t;
    long long w;
    Edge(int u,int v,long long t):s(u),t(v),w(t){}
};
struct HeapNode{
    long long d;
	int u;
    bool operator < (const HeapNode & rhs)const{
        return d>rhs.d;
    }
};
struct Dijkstra{
    int m;
    vector<Edge> edges[2];
    vector<int> G[2][maxn];
    long long d[2][maxn];
    long long num[2][maxn];

    void Addedge(int s,int t,int d){
        edges[0].push_back(Edge(s,t,d));
        m=edges[0].size();
        G[0][s].push_back(m-1);
        edges[1].push_back(Edge(t,s,d));
        m=edges[1].size();
        G[1][t].push_back(m-1);
    }
    void dijkstra(int c,int s){
        memset(num[c],0,sizeof num[c]);
        num[c][s]=1;
        priority_queue<HeapNode> Q;
        for(int i=0;i<=n;i++)d[c][i]=inf;
        d[c][s]=0;
        Q.push((HeapNode){0,s});
        while(!Q.empty()){
            HeapNode x=Q.top();
            Q.pop();
            int u=x.u;
            if(x.d>d[c][u])continue;
            for(int i=0;i<G[c][u].size();i++){
                Edge &e=edges[c][G[c][u][i]];
                if(d[c][e.t]>d[c][u]+e.w){
                    d[c][e.t]=d[c][u]+e.w;
                    num[c][e.t]=num[c][u];
                    Q.push((HeapNode){d[c][e.t],e.t});
                }
                else if(d[c][e.t]==d[c][u]+e.w){
                    num[c][e.t]=(num[c][e.t]+num[c][u])%mol;
                }
            }
        }
    }
};
int main()
{
    while(~scanf("%d %d %d %d",&n,&m1,&s,&t))
    {
        Dijkstra d;
        int u,v;
        long long w;
        while(m1--){
            scanf("%d %d %I64d",&u,&v,&w);
            d.Addedge(u,v,w);
        }
        d.dijkstra(0,s);
        d.dijkstra(1,t);
        for(int i=0;i<d.edges[0].size();i++){
            Edge &e=d.edges[0][i];
            long long d1=d.d[0][e.s];
            long long d2=d.d[1][e.t];
            if((d2+e.w+d1==d.d[0][t])&&((d.num[0][e.s]*d.num[1][e.t])%mol==d.num[0][t]))printf("YES\n");
            else if(d1+d2+1<d.d[0][t])printf("CAN %I64d\n",d1+d2+e.w-d.d[0][t]+1);
            else printf("NO\n");
        }
    }
    return 0;
}
 	 		  	  				 					      	 	