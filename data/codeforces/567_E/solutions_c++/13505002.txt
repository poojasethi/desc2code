#include<bits/stdc++.h>

using namespace std;

#define st first
#define nd second
#define mp make_pair
#define pb push_back
#define sol (root+root)
#define sag (root+root+1)
#define orta ((bas+son)/2)
#define ll long long
#define pii pair<int,int>
#define int ll

const int N=1e5+5;
const int mod=1e9+7;

int n,m,s,t,x,y,z,i,sum,q;
int SP[2][N],bridge[N];

priority_queue<pii > PQ;

vector<pii > V[2][N];

vector<pair<pii,int> > v;

map<int,int> in,out;

void sp(int a,int b,int t){
	
	while(!PQ.empty())
		PQ.pop();

	PQ.push(mp(0,a));

	int x,val,i,bek=0;

	while(!PQ.empty()){
		
		x=PQ.top().nd;
		val=-PQ.top().st;
		PQ.pop();

		if(SP[t][x]!=SP[0][N-1] or (x==a and bek))
			continue;

		SP[t][x]=val;
		bek=1;
		
		if(x==b)
			return;

		for(i=0 ; i<V[t][x].size() ; i++)
			if(SP[t][V[t][x][i].st]==SP[0][N-1])
				PQ.push(mp(-val-V[t][x][i].nd,V[t][x][i].st));
	}

}

main(){

	scanf("%lld %lld %lld %lld",&n,&m,&s,&t);

	for(i=1 ; i<=m ; i++){
		scanf("%lld %lld %lld",&x,&y,&z);
		v.pb(mp(mp(x,y),z));
		V[0][x].pb(mp(y,z));
		V[1][y].pb(mp(x,z));
	}

	memset(SP,63,sizeof SP);

	sp(s,t,0);
	sp(t,s,1);

	for(i=0 ; i<m ; i++){
		x=v[i].st.st;
		y=v[i].st.nd;
		z=v[i].nd;
		if(SP[0][x]+z+SP[1][y]==SP[0][t]){
			q++;
			in[SP[0][x]]++;
			out[SP[0][y]]++;
		}
	}

	map<int,int>::iterator it;

	for(it=out.begin() ; it!=out.end() ; it++)
		sum=it->second+=sum;

	sum=0;

	map<int,int>::reverse_iterator it2;

	for(it2=in.rbegin() ; it2!=in.rend() ; it2++)
		sum=it2->second+=sum;

	for(i=0 ; i<m ; i++){
		x=v[i].st.st;
		y=v[i].st.nd;
		z=v[i].nd;
		if(SP[0][x]+SP[1][y]+z==SP[0][t] and out[SP[0][x]]+in[SP[0][y]]+1==q)
			bridge[i]=1;
	}
	

	for(i=0 ; i<m ; i++){
		x=v[i].st.st;
		y=v[i].st.nd;
		z=v[i].nd;
		if(bridge[i])
			puts("YES");
		else if(SP[0][x]+SP[1][y]+1<SP[0][t])
			printf("CAN %lld\n",z-(SP[0][t]-SP[0][x]-SP[1][y])+1);
		else
			puts("NO");
	}

}
