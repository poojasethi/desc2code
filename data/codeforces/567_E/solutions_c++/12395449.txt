#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
#define pb push_back
#define mp make_pair
#define fi first
#define se second
#define INF 0x3f3f3f3f3f3f3f3fLL
#define MOD1 1000776999LL
#define MOD2 1000000009LL
#define MAX 100005

ll cnts1[MAX], cnts2[MAX], cntt1[MAX], cntt2[MAX];
ll dists[MAX], distt[MAX];
vector< pair<int, ll> > g1[MAX], g2[MAX];
int n, m, s, t;
pair< pair<int, int>, ll> edge[MAX];

void dijkstra(int st, ll *dist, ll *cnt1, ll *cnt2, vector< pair<int, ll> > *g)
{
	set< pair<ll, int> > heap;
	for(int i=0; i<n; ++i) dist[i] = INF, cnt1[i] = cnt2[i] = 0;

	dist[st] = 0; 
	cnt1[st] = 1; cnt2[st] = 0;
	heap.insert(mp(dist[st], st));
	while(!heap.empty())
	{
		int u = heap.begin()->se;
		heap.erase(heap.begin());
		for(int i=0; i<(int)g[u].size(); ++i)
		{
			int v = g[u][i].fi;
			ll w = g[u][i].se;
			if(dist[v] > dist[u] + w)
			{
				heap.erase(mp(dist[v], v));
				dist[v] = dist[u] + w;
				cnt1[v] = cnt1[u]; cnt2[v] = cnt2[u];
				heap.insert(mp(dist[v], v));
			}
			else if(dist[v] == dist[u] + w)
			{
				cnt1[v] = (cnt1[v] + cnt1[u]) % MOD1;
				cnt2[v] = (cnt2[v] + cnt2[u]) % MOD2;
			}
		}
	}
}

int main()
{
	scanf("%d %d %d %d", &n, &m, &s, &t);
	--s; --t;
	for(int i=0; i<m; ++i)
	{
		int u, v, w;
		scanf("%d %d %d", &u, &v, &w);
		--u; --v;
		g1[u].pb(mp(v, w));
		g2[v].pb(mp(u, w));
		edge[i] = mp(mp(u, v), w);
	}

	dijkstra(s, dists, cnts1, cnts2, g1);
	dijkstra(t, distt, cntt1, cntt2, g2);

	for(int i=0; i<m; ++i)
	{
		int u = edge[i].fi.fi, v = edge[i].fi.se;
		ll w = edge[i].se;
		if(dists[u] + w + distt[v] == dists[t])
		{
			ll cnt1 = (cnts1[u] * cntt1[v]) % MOD1;
			ll cnt2 = (cnts2[u] * cntt2[v]) % MOD1;
			if(cnt1 == cnts1[t] && cnt2 == cnts2[t]) puts("YES");
			else if(w > 1) puts("CAN 1");
			else puts("NO");
		}
		else if(w > 1 && dists[u] + 1 + distt[v] < dists[t]) 
			cout << "CAN " << w - (dists[t] - dists[u] - distt[v] - 1) << endl;
		else puts("NO");
	}

	return 0;
}
