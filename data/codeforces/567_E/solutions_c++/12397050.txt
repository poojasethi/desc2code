#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <string>
#include <vector>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>

using namespace std;

typedef long long LL;

const int maxn = 233333;
const long long inf = 1e13;

vector<pair<int, long long> > g[maxn], ag[maxn];
long long d[maxn], ad[maxn];
priority_queue<pair<long long, int> > heap;

vector<int> tg[maxn];
int dfn[maxn], low[maxn], DFN;
bool p[maxn];

int n;

pair<pair<int, int>, long long> e[maxn];

void dijkstra(int S, vector<pair<int, long long> > g[], long long d[]){
	for (int i = 1; i <= n; ++i)
		d[i] = inf;
	d[S] = 0;
	while (!heap.empty()) heap.pop();
	heap.push(make_pair(0, S));
	for (int cnt = 0; !heap.empty() && cnt < n; ){
		int u = heap.top().second;
		long long w = -heap.top().first;
		heap.pop();
		if (w > d[u]) continue;
		++cnt;
		for (int i = 0; i < (int)g[u].size(); ++i)
			if (d[g[u][i].first] > d[u] + g[u][i].second){
				d[g[u][i].first] = d[u] + g[u][i].second;
				heap.push(make_pair(-d[g[u][i].first], g[u][i].first));
			}
	}
	return ;
}

int tarjan(int u, int fa){
	if (dfn[u]) return dfn[u];
	dfn[u] = low[u] = ++DFN;
	for (int i = 0; i < (int)tg[u].size(); ++i)
		if (tg[u][i] != fa){
			int v = e[tg[u][i]].first.first + e[tg[u][i]].first.second - u;
			low[u] = min(low[u], tarjan(v, tg[u][i]));
		}
	if (dfn[u] == low[u]) p[fa] = 1;
	return low[u];
}

int main(){
	int m, s, t;
	scanf("%d%d", &n, &m);
	scanf("%d%d", &s, &t);
	for (int i = 1; i <= m; ++i){
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		g[u].push_back(make_pair(v, w));
		ag[v].push_back(make_pair(u, w));
		e[i] = make_pair(make_pair(u, v), w);
	}
	dijkstra(s, g, d);
	dijkstra(t, ag, ad);
	for (int i = 1; i <= m; ++i)
		if (d[e[i].first.first] + ad[e[i].first.second] + e[i].second == d[t]){
			tg[e[i].first.first].push_back(i);
			tg[e[i].first.second].push_back(i);
		}
	tarjan(s, -1);
	for (int i = 1; i <= m; ++i){
		if (p[i]) printf("YES\n");
		else{
			long long w = d[e[i].first.first] + ad[e[i].first.second];
			if (d[t] - 1LL - w > 0) printf("CAN %d\n", (int)(e[i].second - (d[t] - 1 - w)));
			else printf("NO\n");
		}
	}
	return 0;
}
