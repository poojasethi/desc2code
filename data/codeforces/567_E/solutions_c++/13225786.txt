#include<iostream>
#include<math.h>
#include<algorithm>
#include<stdio.h>
#include<map>
#include<vector>
#include<set>
#include<iomanip>
#define F first
#define S second
#define P system("PAUSE");
#define H return 0;
#define pb push_back
#define MOD 1000000005
using namespace std;
const long long A=100000000000000LL,N=228228;

vector<pair<long long,long long> > a[2][N];
long long ot,ku,t[2][N*4],d[2][N],e[2][N],i,j,n,m;

struct rebro{
    long long x,y,c;
} b[N];

void modi(long long v,long long l,long long r,long long g,long long h){
    if(l==r){t[0][v]=h,t[1][v]=g;return;}
    long long mid=(l+r)/2;
    if(g<=mid)modi(v*2,l,mid,g,h);else modi(v*2+1,mid+1,r,g,h);
    if(t[0][v*2]>t[0][v*2+1])t[0][v]=t[0][v*2+1],t[1][v]=t[1][v*2+1];else t[0][v]=t[0][v*2],t[1][v]=t[1][v*2];
}

void deik(long long q,long long v){
    long long o,po,k=n,i,j;
    for(i=0;i<n;i++)d[q][i]=A,modi(1,1,n,i+1,A);
    d[q][v]=0,e[q][v]=1,modi(1,1,n,v+1,0);
    while(k--){
        o=t[0][1],po=t[1][1]-1;
        if(o==A)return;
        modi(1,1,n,po+1,A);
        for(i=0;i<a[q][po].size();i++)if(d[q][a[q][po][i].F]>d[q][po]+a[q][po][i].S){
            modi(1,1,n,a[q][po][i].F+1,d[q][po]+a[q][po][i].S);
            e[q][a[q][po][i].F]=e[q][po];
            d[q][a[q][po][i].F]=d[q][po]+a[q][po][i].S;
        }else if(d[q][a[q][po][i].F]==d[q][po]+a[q][po][i].S){
            e[q][a[q][po][i].F]+=e[q][po];
            e[q][a[q][po][i].F]%=MOD;
        }
    }
}

int main(){
    scanf("%d%d%d%d",&n,&m,&ot,&ku);
    ot--,ku--;
    for(i=0;i<m;i++){
        scanf("%d%d%d",&b[i].x,&b[i].y,&b[i].c);
        b[i].x--,b[i].y--;
        a[0][b[i].x].pb(make_pair(b[i].y,b[i].c));
        a[1][b[i].y].pb(make_pair(b[i].x,b[i].c));
    }
    deik(0,ot);
    deik(1,ku);
    for(i=0;i<m;i++){
        long long x=b[i].x,y=b[i].y,c=b[i].c;
        if(d[0][x]+d[1][y]+c==d[0][ku] && (e[0][x]*e[1][y])%MOD==e[0][ku])puts("YES");else
        if((d[0][x]+d[1][y]+1)<d[0][ku])printf("CAN %lld\n",(d[0][x]+d[1][y]+c)-d[0][ku]+1);else puts("NO");
    }
}
