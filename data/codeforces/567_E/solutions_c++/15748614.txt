#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+5;
const int mod = 987654321;
#define x first
#define y second
#define ll long long
#define mp make_pair
vector<pair<int,int> > ad[N],rad[N];
vector<pair<pair<int,int>,int> >edge;
ll sdist[N],tdist[N],sway[N],tway[N];
void dijk(int s,int t,ll dis[],ll way[],vector<pair<int,int> > adj[]){
	fill_n(dis,N,1e18);
	priority_queue<pair<ll,int>,vector<pair<ll,int> >,greater<pair<ll,int> > >q;
	way[s]= 1;
	dis[s]=0;
	q.push(mp(0,s));
	ll w,c;int v,u,i;
	while(!q.empty()){
		w= q.top().x,v= q.top().y;q.pop();
		if(dis[v]!=w)continue;
		if(v==t)continue;
		for(i=0;i<adj[v].size();++i){
			u= adj[v][i].x;c=adj[v][i].y;
			if(dis[u]>=w+c){
				if(dis[u]==w+c){
					way[u]= (way[u]+way[v])%mod;
				}
				else{
					dis[u]=w+c;
					way[u]=way[v];
					q.push(mp(w+c,u));
				}
			}
		}
	}
}
int main(){
	int n,m,i,j,s,t,a,b,w;cin>>n>>m>>s>>t;
	for(i=0;i<m;++i){
		cin>>a>>b>>w;
		ad[a].push_back(mp(b,w));
		rad[b].push_back(mp(a,w));
		edge.push_back(mp(mp(a,b),w));
	}
	dijk(s,t,sdist,sway,ad);
	dijk(t,s,tdist,tway,rad);
	ll mini = sdist[t],k;
	for(i=0;i<m;++i){
		a= edge[i].x.x,b=edge[i].x.y,w=edge[i].y;
		if(sdist[a]+w+tdist[b]==mini && (sway[a]*tway[b])%mod== sway[t])
			printf("YES\n");
		else{
			k = mini-1-sdist[a]-tdist[b];
			if(k>0){
				printf("CAN %d\n",(int)(w-k));
			}
			else
				printf("NO\n");
		}
	}
}
