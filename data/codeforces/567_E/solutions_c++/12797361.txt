#include <cstdio>

#include <iostream>

#include <cmath>

#include <algorithm>

#include <cstring>

#include <queue>

#include <vector>

#include <map>



using namespace std;



typedef long long LL;


int n,m,s,t,x,y,w;
vector<pair<int,int> > g1[100005],g2[100005];
LL d1[100005],d2[100005];
LL f1[100005],f2[100005];
bool flag[100005];
const LL mod=1000776999;
struct Edge
{
	int x,y,w;
}e[100005];
priority_queue<pair<LL,int>,vector<pair<LL,int> >,greater<pair<LL,int> > > q;
struct Node
{
	int id;
	LL x;
}tt[100005];
bool cmp(Node a,Node b)
{
	return a.x<b.x;
}
void work(LL dis[],vector<pair<int,int> > g[],LL f[],int s)

{
	for (int i=1;i<=n;++i) dis[i]=1e18;
	dis[s]=0;
	for (int i=1;i<=n;++i) f[i]=0;
	f[s]=1;
	while (!q.empty()) q.pop();
	q.push(make_pair(0,s));
	while (!q.empty())
	{
		pair<LL,int> dq=q.top();
		q.pop();
		int x=dq.second;
		if (dis[x]<dq.first) continue;
		for (int i=0;i<g[x].size();++i)
		{
			int y=g[x][i].first,w=g[x][i].second;
			if (dis[y]>dis[x]+w)
			{
				dis[y]=dis[x]+w;
				f[y]=f[x];
				q.push(make_pair(dis[y],y));
			}
			else if (dis[y]==dis[x]+w)
				f[y]=(f[y]+f[x])%mod;
		}
	}
}
int main()

{
	scanf("%d%d",&n,&m);
	scanf("%d%d",&s,&t);
	for (int i=1;i<=m;++i)
	{
		scanf("%d%d%d",&x,&y,&w);
		g1[x].push_back(make_pair(y,w));
		g2[y].push_back(make_pair(x,w));		
		e[i].x=x;e[i].y=y;e[i].w=w;
	}
	work(d1,g1,f1,s);
	work(d2,g2,f2,t);
	for (int i=1;i<=m;++i)
	{
		if (d1[e[i].x]+e[i].w+d2[e[i].y]==d1[t]&&(f1[e[i].x]*f2[e[i].y]%mod==f1[t]))
		{
			printf("YES\n");
			continue;
		}
		if (d1[t]-d1[e[i].x]-d2[e[i].y]-1>0)
			printf("CAN %d\n",e[i].w-(d1[t]-d1[e[i].x]-d2[e[i].y]-1));
		else 
			printf("NO\n");
	}

	return 0;

}