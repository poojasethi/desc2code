#include <cstdio>
#include <cstring>
#include <queue>
#include <vector>
using namespace std;

typedef pair<long long, int> p;

const int maxn = 100010;
const long long INF = 1e12;
const long long mod = 1e9+13;

int n, m, s, t, u, v;
long long w;

struct edge {
	int from, to;
	long long cost;
	edge(int from, int to, long long cost): from(from), to(to), cost(cost) {}
};

struct dijkstra {
	long long c[2][maxn], d[2][maxn];
	vector <edge> es[2];
	vector <int> G[2][maxn];
	void addedge(int u, int v, long long w) {
		G[0][u].push_back(es[0].size());
		es[0].push_back(edge(u, v, w));
		G[1][v].push_back(es[1].size());
		es[1].push_back(edge(v, u, w));
	}
	void solve(int o, int s) {
		memset(c[o], 0, sizeof(c[o]));		
		c[o][s]=1;
		for(int i=1; i <= n; i++) d[o][i]=INF;		
		d[o][s]=0;		
		priority_queue < p, vector<p>, greater<p> > pq;
		pq.push(p(0, s));		
		while(!pq.empty()) {					
			p node=pq.top();
			pq.pop();
			int u=node.second;		
			long long dist=node.first; 
			if(dist>d[o][u]) continue;
			for(int i=0; i<G[o][u].size(); i++) {
				edge& e=es[o][G[o][u][i]];
				if(d[o][e.to] == dist+e.cost) c[o][e.to]=(c[o][e.to]+c[o][u])%mod; 
				if(d[o][e.to]>dist+e.cost) {
					c[o][e.to]=c[o][u];
					d[o][e.to]=dist+e.cost;
					pq.push(p(d[o][e.to], e.to));
				}
			}
		}		
	}
}d;

int main() {
	scanf("%d%d%d%d", &n, &m, &s, &t);
	for(int i=0; i<m; i++) {
		scanf("%d%d%I64d", &u, &v, &w);
		d.addedge(u, v, w);	
	}
	d.solve(0, s);
	d.solve(1, t);
	for(int i=0; i<m; i++) {
		edge& e=d.es[0][i];
		u=e.from, v=e.to, w=e.cost;
		long long d1=d.d[0][u], d2=d.d[1][v], dt=d.d[0][t]; 
		long long c1=d.c[0][u], c2=d.c[1][v], ct=d.c[0][t];
		if(d1+d2+w == dt && (c1*c2)%mod == ct) puts("YES");
		else {
			long long exp=dt-d1-d2-1;
			if(exp<1 || w == 1) puts("NO");
			else printf("CAN %I64d\n", w-exp);
		}
	}
	return 0;
}
 	 	  			 	  						 			     		