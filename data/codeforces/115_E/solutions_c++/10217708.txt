#include <bits/stdc++.h>
typedef long long LL;
#define rep(i,n) for(int i = 0;i < n;i ++)
#define lc o<<1
#define rc o<<1|1
#define lson l,m,lc
#define rson m+1,r,rc

const int N = 200010;
LL max[N << 2], add[N << 2];
void update(int l, int r, int o, int L, int R, LL val) {
	if(L <= l && r <= R) {
		add[o] += val;
		max[o] += val;
	} else {
		int m = l + r >> 1;
		if(add[o]) {
			add[lc] += add[o];
			add[rc] += add[o];
			max[lc] += add[o];
			max[rc] += add[o];
			add[o] = 0;
		}
		if(L <= m)	update(lson, L, R, val);
		if(R >  m)	update(rson, L, R, val);
		max[o] = std::max(max[lc], max[rc]);
	}
}
LL dp[N];
int cost[N];
struct Node {
	int l, r, p;
	void read() {
		scanf("%d%d%d", &l, &r, &p);
	}
	bool operator<(const Node &A)const{
		return r < A.r;
	}
}ly[N];
int main() {
	int n, m;	
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i ++)
		scanf("%d", cost + i);
	rep(i, m)
		ly[i].read();
	std::sort(ly, ly + m);
	for(int i = 1, j = 0; i <= n; i ++) {
		update(0, n, 1, 0, i - 1, -cost[i]);
		while(j < m && ly[j].r == i) {
			update(0, n, 1, 0, ly[j].l - 1, ly[j].p);
			j ++;
		}
		dp[i] = std::max(dp[i - 1], max[1]);
		update(0, n, 1, i, i, dp[i]);
	}
	printf("%I64d\n", dp[n]);
	return 0;
}

