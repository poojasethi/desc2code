#include <iostream>
#include <math.h>
#include <algorithm>
#include <stdio.h>
#include <map>
#include <vector>
#include <set>
#include <iomanip>
using namespace std;
const long long MaxLL = (long long)1e18;
const int MaxInt = (int)1e9, MaxN = (int)2e5 + 228, MaxM = (int)1e9 + 1;

pair<int, long long> q;
pair<int, long long> ans[MaxN];
multiset<pair<int, int> > List;
map<int, int> name;
int x, k, y, i, j, n, m;

struct LR {
    int l;
    int r;
    long long a;
} New;

vector<LR> t;

void modi(int v, int l, int r, int pl, int pr) {
    if(l == r) {
        t[v].a = pr;
        return;
    }

    if(!t[v].l) {
        t[v].l = t.size();
        t.push_back(New);
    }

    if(!t[v].r) {
        t[v].r = t.size();
        t.push_back(New);
    }

    int mid = (l + r) / 2;
    if(pl <= mid) {
        modi(t[v].l, l, mid, pl, pr);
    } else {
        modi(t[v].r, mid + 1, r, pl, pr);
    }
    t[v].a = max(t[t[v].l].a, t[t[v].r].a);
}

pair<int, long long> get(int v, int l, int r, int a) {
    if(l == r) {
        return make_pair(l, t[v].a);
    }

    if(!t[v].l) {
        t[v].l = t.size();
        t.push_back(New);
    }

    if(!t[v].r) {
        t[v].r = t.size();
        t.push_back(New);
    }

    int mid = (l + r) / 2;
    if(t[t[v].l].a >= a) {
        return get(t[v].l, l, mid, a);
    }
    if(t[t[v].r].a >= a) {
        return get(t[v].r, mid + 1, r, a);
    }

    return make_pair(-1, -1);
}

int main(){
//  freopen(".in", "r", stdin);
//  freopen(".out", "w", stdout);

    t.push_back(New);

    cin >> n >> m;
    for(i = 0; i < n; i++) {
        scanf("%d%d", &x, &y);
        x++;
        name[x] = i;
        ans[i].second = y;
        modi(0, 1, MaxM, x, x + y);
    }

    for(i = 0; i < m; i++) {
        scanf("%d%d", &x, &y);
        x++;

        q = get(0, 1, MaxM, x);
        if(q.first == -1 || q.first > x) {
            List.insert(make_pair(x, y));
            continue;
        }

        k = 1;
        q.second += y;
        while(List.size()) {
            multiset<pair<int, int> > :: iterator it = List.lower_bound(make_pair(q.first, 0));
            if(it == List.end() || (*it).first > q.second) {
                    break;
            }

            q.second += (*it).second;
            List.erase(it);
            k++;
        }

        ans[name[q.first]].first += k;
        ans[name[q.first]].second = q.second - q.first;
        modi(0, 1, MaxM, q.first, q.second);
    }

    for(i = 0; i < n; i++) {
        printf("%d ", ans[i].first);
        printf("%lld\n", ans[i].second);
    }
}
