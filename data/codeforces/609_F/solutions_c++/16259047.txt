#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int>pii;
#define left first
#define len second
#define ll long long
#define mx 200005
#define inf LLONG_MAX
#define INF 2000000000
struct frog
{
    ll left,right,i;
    bool operator<(const frog f) const
    {
        return (right!=f.right)?right<f.right : left>f.left;
    }
};
multiset<frog> cur;
multiset<frog>:: iterator it;
multiset<pii>uneaten;
multiset<pii>:: iterator jt;
int eaten[mx],n,m,p,b;
ll length[mx],total;
frog F[mx];
void eat(frog &f,pii mosq)
{
    //cout<<"frog with initial "<<f.left<<" to "<<f.right<<" is eating "<<mosq.left<<" "<<mosq.len<<endl;
    eaten[f.i]++;
    length[f.i]+=mosq.len;
    f.right+=mosq.len;
}
void del_unnessesary_segments(frog &f)
{
    cur.insert(f);
    it = cur.lower_bound(f);
    if(it!=cur.begin())it--;
    vector<frog>del_cur;
    while(it -> left > f.left)
    {
        del_cur.push_back(*it);
        if(it==cur.begin())break;
        it--;
    }
    for(int i=0; i<del_cur.size(); i++)cur.erase(del_cur[i]);
}
bool cmp(frog a,frog b)
{
    return a.left<b.left;
}
void build()
{
    sort(F+1,F+n+1,cmp);
    cur.insert(F[1]);
    for(int i=2; i<=n; i++)if(F[i].right>cur.rbegin() -> right)cur.insert(F[i]);
    frog infinite;
    infinite.right=inf,infinite.left=INF+2,infinite.i=INF+2;
    cur.insert(infinite);
}
void show()
{
    for(it=cur.begin(); it!=cur.end(); it++)
        cout<<it -> left <<" to "<<it -> right <<endl;
    for(jt=uneaten.begin(); jt!=uneaten.end(); jt++)
        cout<<"on "<<jt -> left <<" with size of "<<jt -> len<<endl;
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1; i<=n; i++)scanf("%I64d %I64d",&F[i].left,&length[i]),F[i].right=length[i]+F[i].left,F[i].i=i;
    build();
    for(int i=1; i<=m; i++)
    {
        scanf("%d %d",&p,&b);
        uneaten.insert({p,b});
        frog f=*cur.lower_bound({INF,p});
        if(p<f.left)continue;
        jt=uneaten.lower_bound({p,0});
        vector<pii> del_uneaten;
        cur.erase(f);
        while(jt != uneaten.end() && jt -> left <= f.right)eat(f, *jt),del_uneaten.push_back(*jt),jt++;
        for(int i=0; i<del_uneaten.size(); i++)uneaten.erase(del_uneaten[i]);
        del_unnessesary_segments(f);
        //show();
    }
    for(int i=1; i<=n; i++)printf("%d %I64d\n",eaten[i],length[i]);

}
