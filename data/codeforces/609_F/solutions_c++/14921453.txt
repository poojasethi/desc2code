#include <iostream>
#include <iomanip>
#include <climits>
#include <stack>
#include <fstream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <string>
#include <vector>
#include <deque>
#include <queue>
#include <set>
#include <map>
#include <cassert>

#define FOR(i,n) for(int i=0,_n=n;i<_n;i++)
#define FORR(i,s,n) for(int i=s,_n=n;i<_n;i++)
#define mp make_pair
#define pb push_back
#define pii pair<int,int>
#define pli pair<ll,int>
#define vi vector<int>
#define fs first
#define sec second

#define maxn 200000

using namespace std;
typedef long long ll;

const ll MOD = 1000000007LL;

pair<ll,ll> stree[maxn*4+10];
pair <pii,int> f[maxn+10];
pii ctr[maxn+10];
int n,q;

void build(int poz, int l, int d){
	if(l==d){
		stree[poz]=f[l].fs;
		ctr[f[l].sec]=mp(poz,0);
		return;
	}
	int s=(l+d)/2;
	build(poz*2,l,s);
	build(poz*2+1,s+1,d);
	stree[poz]=mp(stree[poz*2].fs,max(stree[poz*2].sec,stree[poz*2+1].sec));
}

bool add(int poz, int l, int d, int p, int m){
	if(p<stree[poz].fs || p>stree[poz].sec)return 0;
	if(l==d){
		stree[poz].sec+=m;
		ctr[f[l].sec].sec++;
		return 1;
	}
	bool success;
	int s=(l+d)/2;
	if(stree[poz*2].sec>=p)success=add(poz*2,l,s,p,m);
	else success=add(poz*2+1,s+1,d,p,m);
	stree[poz].sec=max(stree[poz*2].sec,stree[poz*2+1].sec);
	return success;
}

int main(){
	scanf("%d%d",&n,&q);
	FOR(i,n){
		int a,b;
		scanf("%d%d",&a,&b);
		f[i]=mp(mp(a,a+b),i);
	}
	sort(f,f+n);
	build(1,0,n-1);
	map <pii,int> unused;
	FOR(i,q){
		int a,b;
		scanf("%d%d",&a,&b);
		bool success=add(1,0,n-1,a,b);
		if(!success){
			unused[mp(a,b)]++;
			continue;
		}
		while(success){
			map<pii,int>::iterator it=unused.lower_bound(mp(a,0));
			if(it==unused.end())break;
			success=add(1,0,n-1,it->fs.fs,it->fs.sec);
			if(success)it->sec--;
			if(it->sec<=0)unused.erase(it);
		}
	}
	FOR(i,n)printf("%d %lld\n",ctr[i].sec,stree[ctr[i].fs].sec-stree[ctr[i].fs].fs);
	return 0;
}
