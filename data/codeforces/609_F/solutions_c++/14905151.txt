#include <bits/stdc++.h>
using namespace std;

typedef long long int64;
typedef pair <int, int64> par;
const int MAX = 2e5 + 5;
int n, m, k, fenw[MAX], sz[MAX], t[MAX], p[MAX];
bool lazy[4 * MAX];
par tree[4 * MAX], s[MAX];

struct data {
	int x, v, id;

	bool operator < (const data &p) const {
		return x < p.x;
	}
} a[MAX], b[MAX];

void update(int x) {
	int tm = sz[x];
	for(; x <= n; x += x & -x)
		fenw[x] = max(fenw[x], tm);
}

int query(int x) {
	if(x < 1)
		return 0;

	int mx = 0;
	for(; x > 0; x -= x & -x)
		mx = max(fenw[x], mx);

	return mx;
}

void prop(int x, int f) {
	tree[x] = make_pair(0, 0);

	if(f == 1) {
		lazy[2 * x] |= lazy[x];
		lazy[2 * x + 1] |= lazy[x];
	}

	lazy[x] = 0;
}

par merge(const par &a, const par &b) {
	par c;
	c.first = a.first + b.first;
	c.second = a.second + b.second;
	return c;
}

void upd1(int x, int st, int nd, int a, int b) {
	if(lazy[x])
		prop(x, st != nd);

	if(st > b || nd < a)
		return;

	if(st >= a && nd <= b) {
		lazy[x] = 1;
		prop(x, st != nd);
		return;
	}

	int mid = (st + nd) >> 1;

	upd1(2 * x, st, mid, a, b);
	upd1(2 * x + 1, mid + 1, nd, a, b);

	tree[x] = merge(tree[2 * x], tree[2 * x + 1]);
}

void upd2(int x, int st, int nd, int p, int v) {
	if(lazy[x])
		prop(x, st != nd);

	if(st > p || nd < p)
		return;

	if(st == nd) {
		tree[x].first++;
		tree[x].second += v;
		return;
	}

	int mid = (st + nd) >> 1;

	upd2(2 * x, st, mid, p, v);
	upd2(2 * x + 1, mid + 1, nd, p, v);

	tree[x] = merge(tree[2 * x], tree[2 * x + 1]);
}

par query(int x, int st, int nd, int a, int b) {
	if(lazy[x])
		prop(x, st != nd);

	if(st > b || nd < a)
		return make_pair(0, 0);

	if(st >= a && nd <= b)
		return tree[x];

	int mid = (st + nd) >> 1;

	par left = query(2 * x, st, mid, a, b);
	par right = query(2 * x + 1, mid + 1, nd, a, b);

	return merge(left, right);
}

int main() {
	//ios_base::sync_with_stdio(0);
	//cin.tie(0);

	//freopen("a.in", "r", stdin);
	//freopen("a.out", "w", stdout);

	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++) {
		scanf("%d%d", &a[i].x, &a[i].v);
		a[i].id = i;
	}

	sort(a + 1, a + n + 1);
	for(int i = 1; i <= n; i++) {
		sz[i] = a[i].x + a[i].v;
		s[a[i].id].second = a[i].v;
		update(i);
	}

	for(int i = 1; i <= m; i++) {
		scanf("%d%d", &b[i].x, &b[i].v);
		t[i] = b[i].x;
	}

	sort(t + 1, t + m + 1);
	p[++k] = t[1];

	for(int i = 2; i <= m; i++)
		if(t[i] != t[i - 1])
			p[++k] = t[i];

	for(int i = 1; i <= m; i++) {
		int x = b[i].x, tm = b[i].v;

		int st = 1, nd = n;
		while(st <= nd) {
			int mid = (st + nd) >> 1;

			if(query(mid) >= x)
				nd = mid - 1;

			else st = mid + 1;
		}

		int pos = lower_bound(p + 1, p + k + 1, x) - p;
		upd2(1, 1, k, pos, tm);

		if(st <= n) {
			int l = lower_bound(p + 1, p + k + 1, a[st].x) - p;

			if(l == k + 1)
				continue;

			while(1) {
				int u = upper_bound(p + 1, p + k + 1, sz[st]) - p - 1;

				if(u == 0 || l > u)
					break;

				par q = query(1, 1, k, l, u);

				if(q.first == 0)
					break;

				if(sz[st] <= p[k])
					sz[st] += q.second;

				s[a[st].id].first += q.first;
				s[a[st].id].second += q.second;
				upd1(1, 1, k, l, u);
			}

			update(st);
		}
	}

	for(int i = 1; i <= n; i++)
		printf("%d %I64d\n", s[i].first, s[i].second);

	return 0;
}
