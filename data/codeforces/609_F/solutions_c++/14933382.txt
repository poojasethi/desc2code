#include<stdio.h>
#include<algorithm>
#include<set>
#define X first
#define Y second
#define mk make_pair
#define N 200005
using namespace std;
typedef long long LL;
struct data{
    int x,id;long can;
    friend int operator < (const data &a,const data &b){
        if (a.can!=b.can) return a.can<b.can;
        return a.id<b.id;
  }
}a[N];set<data>S;set<data>::iterator it;
typedef pair<int,int> Pair;
multiset<Pair>Q;set<Pair>::iterator id;
int num[N],x,y,n,m,i,p;LL ans[N];
inline int cmpx(const data &a,const data &b){return a.x<b.x||a.x==b.x&&a.can>b.can;}
void Insert(data now){
    if (!S.empty())
        if (now.can<=(*(--S.end())).can) return;
    S.insert(now);
}
void adjust(){
    int len=(*S.begin()).x;
    while (!Q.empty()&&(*Q.begin()).X<len)
        Q.erase(Q.begin());
    data now=*it,_now=*it;S.erase(it);
    ans[now.id]+=y;num[now.id]++;now.can+=y;
    while (!Q.empty()){
        id=Q.lower_bound(mk(x,y));
        if (id==Q.end()) break;Pair tmp=*id;
        if (tmp.X>now.can) break;
        Q.erase(id);ans[now.id]+=tmp.Y;
        num[now.id]++;now.can+=tmp.Y;
  }while (!S.empty()){
        it=S.lower_bound(_now);
        if (it==S.end()) break;
        if ((*it).can>now.can) break;
        S.erase(it);
  }S.insert(now);
}
int main(){
    scanf("%d%d",&n,&m);
    for (i=1;i<=n;i++)
        scanf("%d%d",&a[i].x,&a[i].can),
        ans[a[i].id=i]=a[i].can,a[i].can+=a[i].x;
    sort(a+1,a+n+1,cmpx);
    for (i=1;i<=n;i++)
        Insert(a[i]);
    for (i=1;i<=m;i++){
        scanf("%d%d",&x,&y);
        it=S.lower_bound((data){0,0,x});
        if (it==S.end()||(*it).x>x) Q.insert(mk(x,y));else adjust();
  }for (i=1;i<=n;i++)
    printf("%d %I64d\n",num[i],ans[i]);
}