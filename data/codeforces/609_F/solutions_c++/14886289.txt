#include <cstring>
#include <set>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>

using namespace std;

#define ull long long 

#define x first
#define y second
#define mp make_pair
#define pii pair<int,int> 
#define pli pair<ull,int>

#define Max(a,b) ((a)>(b)?(a):(b)) 

const int MAXN=200000;

int B[MAXN+10],bt;
int A[MAXN+10],at;

struct FROG
{
    int x,y,id; 
}fr[MAXN+10];

void buildA()
{
    sort(B+1,B+bt+1);
    for (int i=1;i<=bt;i++) {
        A[++at]=B[i]; int j=i;
        while (j<bt && B[j+1]==A[at]) j++;
        i=j; }
    return ;
}

int find(int x)
{
    if (x<A[1]) return -1;
    int l=1,r=at,ret=-1;
    while (l<=r) {
        int mid=(l+r)>>1;
        if (A[mid]<=x) { ret=mid; l=mid+1; }
        else r=mid-1; }
    return ret;
}

struct Segtree
{
    ull ri[(MAXN<<3)+10];
    
    void build(int x,int l,int r)
    {
        if (l==r) { ri[x]=fr[l].x+fr[l].y; return ; }
        int mid=(l+r)>>1;
        build(x<<1,l,mid); build(x<<1|1,mid+1,r);
        
        ri[x]=Max(ri[x<<1],ri[x<<1|1]);
        return ;
    }
    
    int query(int x,int l,int r,int ll,int rr,ull k)
    {
        if (ri[x]<k) return -1;
        if (l==r) return l; 
        int mid=(l+r)>>1;
        
        if (rr<=mid) return query(x<<1,l,mid,ll,rr,k);
        else if (ll<=mid) {
            int lans=query(x<<1,l,mid,ll,mid,k);
            if (lans==-1) return query(x<<1|1,mid+1,r,mid+1,rr,k);
            else return lans; }
        else return query(x<<1|1,mid+1,r,mid+1,rr,k);
    }
    
    void modify(int x,int l,int r,int p,ull k)
    {
        if (l==r) { ri[x]+=k; return ; }
        int mid=(l+r)>>1;
        
        if (p<=mid) modify(x<<1,l,mid,p,k);
        else modify(x<<1|1,mid+1,r,p,k);
        
        ri[x]=Max(ri[x<<1],ri[x<<1|1]);
        return ;
    }
}tr;

int n,m;

bool cmp(FROG l,FROG r) { return l.x<r.x; } 

int pos[MAXN+10];
int ans1[MAXN+10];

ull ans2[MAXN+10];

multiset<pli> s;

void init()
{
    cin>>n>>m;
    for (int i=1;i<=n;i++) {
        scanf("%d%d",&fr[i].x,&fr[i].y); fr[i].id=i;
        pos[i]=fr[i].x; B[++bt]=fr[i].x; ans2[i]=fr[i].y; }
    
    sort(fr+1,fr+n+1,cmp);
    buildA();
    tr.build(1,1,n);
    
    while (m--) {
        int p,b,locp; scanf("%d%d",&p,&b);
        locp=find(p);
        if (locp==-1) continue; 
        
        int mod=tr.query(1,1,n,1,locp,p);
        if (mod!=-1) {
            ans1[fr[mod].id]++;
            ans2[fr[mod].id]+=b;
            ull pp=ans2[fr[mod].id]-b+pos[fr[mod].id];
            tr.modify(1,1,n,mod,b);
            
            multiset<pli>::iterator it=s.lower_bound(mp(pp,0));
            for (;(*it).x<=pos[fr[mod].id]+ans2[fr[mod].id] && it!=s.end();) {
                ans1[fr[mod].id]++;
                ans2[fr[mod].id]+=(*it).y;
                tr.modify(1,1,n,mod,(*it).y);
                multiset<pli>::iterator nxt=it; ++nxt;
                s.erase(it); it=nxt; } }
        else s.insert(mp(p,b)); }
            
    for (int i=1;i<=n;i++)
        printf("%d %I64d\n",ans1[i],ans2[i]);
    
    return ;
}

int main()
{
    init();
    return 0; 
} 