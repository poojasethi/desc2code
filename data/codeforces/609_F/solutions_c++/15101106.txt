#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pii pair<int,int>
#define pll pair<ll,ll>
#define pdd pair<double,double>
#define X first
#define Y second
#define REP(i,a) for(int i=0;i<a;++i)
#define REPP(i,a,b) for(int i=a;i<b;++i)
#define FILL(a,x) memset(a,x,sizeof(a))
#define	foreach( gg,itit )	for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )
#define	mp make_pair
#define	pb push_back

inline int max(int a,int b){return a<b?b:a;}
inline int min(int a,int b){return a>b?b:a;}
inline ll max(ll a,ll b){return a<b?b:a;}
inline ll min(ll a,ll b){return a>b?b:a;}
const int mod = 1e9+7;
const int N = 1e6+10;
const ll INF = 1e18;

//#define DEBUG

#ifdef DEBUG
#define dprintf(fmt,...) fprintf(stderr,fmt,__VA_ARGS__)
#else
#define dprintf(fmt,...)
#endif

int tree[6*N],lazy[6*N],ce[6*N];
pll ans[N];
pll mos[N];
pair<pll,int> fr[N];
vector<ll>  pos;
void upd(int C,int S,int E,int s,int e,int v){
  if(lazy[C]){
    if(tree[C]==0) tree[C]=lazy[C];
    tree[C]=min(lazy[C],tree[C]);
    if(lazy[C*2]==0)lazy[C*2]=lazy[C];
    if(lazy[C*2+1]==0)lazy[C*2+1]=lazy[C];lazy[C*2+1]=min(lazy[C*2+1],lazy[C]);
     lazy[C*2]=min(lazy[C*2],lazy[C]);
     lazy[C]=0;
  }
  if(s>E||e<S) return;
  if(s<=S&&E<=e){
    if(tree[C]==0) tree[C]=v;
    tree[C]=min(tree[C],v); if(lazy[C]==0) lazy[C]=v; lazy[C]=min(v,lazy[C]); return;
  }
  int m=(S+E)>>1;
  upd(C*2,S,m,s,e,v); upd(C*2+1,m+1,E,s,e,v);
  tree[C]=max(tree[C*2],tree[C*2+1]);
//  ce[C]=min(ce[C*2],ce[2*C+1]);
}
int q(int C,int S,int E,int v){
  if(lazy[C]){
    if(tree[C]==0) tree[C]=lazy[C];
    tree[C]=min(lazy[C],tree[C]); lazy[C*2]=lazy[C*2+1]=lazy[C]; lazy[C]=0;
  }
//  if(tree[C]==0) return
  if(ce[C]<=v) return -1;
  if(S==E) return S;
  int m=(S+E)>>1;
  int x=q(C*2,S,m,v);
  if(x==-1) return q(C*2+1,m+1,E,v); else return x;
}
int q2(int C,int S,int E,int s){
  if(lazy[C]){
    if(tree[C]==0) tree[C]=lazy[C];
    tree[C]=min(lazy[C],tree[C]);
    if(lazy[C*2]==0)lazy[C*2]=lazy[C];
    if(lazy[C*2+1]==0)lazy[C*2+1]=lazy[C];lazy[C*2+1]=min(lazy[C*2+1],lazy[C]);
     lazy[C*2]=min(lazy[C*2],lazy[C]);
     lazy[C]=0;
  }
  if(s>E||s<S) return 0;
  if(S==E) return tree[C];
  int m=(S+E)>>1;
  return max(q2(C*2,S,m,s),q2(C*2+1,m+1,E,s));
}
map<ll,pll> M;
vector<ll> pd;
pll ze[N];
int main(){
  int n,m; scanf("%d%d",&n,&m);
  REP(i,n){
    ll x,y; scanf("%lld%lld",&x,&y);
     pos.pb(x); fr[i].X=mp(x,y); fr[i].Y=i;
  }
  REP(i,6*N) ce[i]=mod;
  sort(fr,fr+n);
  REP(i,m){
    ll x,y; scanf("%lld%lld",&x,&y);
    mos[i]=mp(x,y);
    pos.pb(x);
  }
  sort(pos.begin(),pos.end());
  pos.resize(unique(pos.begin(),pos.end())-pos.begin());
  int tot=pos.size();
  for(int i=n-1;i>=0;i--){
    int b=lower_bound(pos.begin(),pos.end(),fr[i].X.X)-pos.begin(),e=lower_bound(pos.begin(),pos.end(),fr[i].X.X+fr[i].X.Y)-pos.begin();

    ans[i].X=fr[i].X.Y;
    if(e<pos.size()&&pos[e]>fr[i].X.X+fr[i].X.Y) e--;
  //  printf("m%d %d %d\n",tot,b,e);
    if(b<=e) upd(1,0,tot,b,e,i+1);
  }
  REP(i,m){
    int b=lower_bound(pos.begin(),pos.end(),mos[i].X)-pos.begin();
    int as=q2(1,0,tot,b);
  //  printf("%d %d\n",b,as);
    if(as==0){
      M[mos[i].X].X++; M[mos[i].X].Y+=mos[i].Y;
    }else{
      int b=lower_bound(pos.begin(),pos.end(),fr[as-1].X.X)-pos.begin(); pd.clear();
      ans[as-1].Y++;
      ll cur=ans[as-1].X+mos[i].Y;
      map<ll,pll>:: iterator it1=M.lower_bound(fr[as-1].X.X);
      while(it1!=M.end()&&it1->X<=fr[as-1].X.X+cur){
        ans[as-1].Y+=it1->Y.X;
        cur+=it1->Y.Y;
        pd.pb(it1->X);
        it1++;
      }
      ans[as-1].X=cur;
      REP(j,pd.size()) M.erase(pd[j]);
      int e=lower_bound(pos.begin(),pos.end(),fr[as-1].X.X+cur)-pos.begin();
      if(e<pos.size()&&pos[e]>fr[as-1].X.X+cur) e--;
//      printf("z%d %d %d \n",as,b,e);
      if(b!=-1&&b<=e) upd(1,0,tot,b,e,as);
    }
  }
  REP(i,n) ze[fr[i].Y]=ans[i];
  REP(i,n) printf("%lld %lld\n",ze[i].Y,ze[i].X);
  return 0;
}
