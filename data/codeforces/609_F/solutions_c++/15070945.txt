#include <bits/stdc++.h>

template<class T>
inline void read(T &x) {
    char c;int f = 1;x = 0;
    while(((c=getchar()) < '0' || c > '9') && c != '-');
    if(c == '-') f = -1;else x = c-'0';
    while((c=getchar()) >= '0' && c <= '9') x = x*10+c-'0';
    x *= f;
}

int OutN;
char Out[20];

template<class T>
inline void write(T x) {
    if(x < 0) putchar('-'), x = -x;
    if(x) {
        OutN = 0;
        while(x) {
            Out[OutN++] = x%10+'0';
            x /= 10;
        }
        while(OutN--)
            putchar(Out[OutN]);
    }
    else putchar('0');
}

const int N = 2e5+9;

int n, m;
int val[N];
int id[N];

struct Data {
	int id, x;
	long long l;
	
	Data() {id = x = l = 0;}
	Data(int _id, int _x, long long _l):id(_id), x(_x), l(_l) {}
	
	inline friend bool operator < (const Data &p, const Data &q) {
		return p.x < q.x;	
	}
}p[N], tree[N<<2];

std::multiset<std::pair<long long,int> > s;

int cnt[N];
long long len[N];

inline void init() {
	read(n), read(m);
	for(int i = 1; i <= n; ++i) {
		int x, t;
		read(x), read(t);
		p[i] = Data(i, x, t);
		len[i] = t;
	}
}

inline int cmp(const Data &p, const Data &q) {
	return p.x+p.l < q.x+q.l;	
}

inline void update(int x) {
	tree[x] = tree[x<<1|cmp(tree[x<<1], tree[x<<1|1])];
}

void build(int x, int l, int r) {
	if(l == r) {
		tree[x] = p[l];
		return ; 
	}
	int mid = (l+r)>>1;
	build(x<<1, l, mid);
	build(x<<1|1, mid+1, r);
	update(x);
}

Data find(int x, int l, int r, int val) {
	if(l == r) return tree[x];
	int mid = (l+r)>>1;
	if(val <= p[mid].x) return find(x<<1, l, mid, val);
	else {
		if(tree[x<<1].x+tree[x<<1].l >= val) return find(x<<1, l, mid, val);
		else return find(x<<1|1, mid+1, r, val);
	}
}

void modify(int x, int l, int r, int pos) {
	if(l == r) {
		tree[x].l = len[tree[x].id];
		return ;	
	}
	int mid = (l+r)>>1;
	if(pos <= mid) modify(x<<1, l, mid, pos);
	else modify(x<<1|1, mid+1, r, pos);
	update(x);
}	

inline void solve() {
	std::sort(p+1, p+n+1);
	for(int i = 1; i <= n; ++i)
		val[i] = p[i].x, id[p[i].id] = i;
	build(1, 1, n);	
	while(m--) {
		int p, b;
		read(p), read(b);
		s.insert(std::make_pair(p, b));
		Data g = find(1, 1, n, p);
		if(g.x <= p && g.x+g.l >= p) {
			len[g.id] += b, cnt[g.id]++;
			modify(1, 1, n, id[g.id]);
			s.erase(s.lower_bound(std::make_pair(p, b)));
			while(s.size()) {
				std::multiset<std::pair<long long,int> >::iterator it = s.lower_bound(std::make_pair(g.x, 0));
				if(it == s.end()) break;
				p = it->first, b = it->second;
				if(g.x+len[g.id] >= p) {
					len[g.id] += b, cnt[g.id]++;
					modify(1, 1, n, id[g.id]);
					s.erase(it);
				}
				else break;
			}
		}
	}
	for(int i = 1; i <= n; ++i)
		write(cnt[i]), putchar(' '), write(len[i]), putchar('\n');
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif

	init();
	solve();

#ifndef ONLINE_JUDGE
    fclose(stdin);fclose(stdout);
#endif
    return 0;
}
