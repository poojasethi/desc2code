#include<map>
#include<set>
#include<cmath>
#include<ctime>
#include<stack>
#include<queue>
#include<cstdio>
#include<cctype>
#include<string>
#include<vector>
#include<cstring>
#include<iomanip>
#include<iostream>
#include<algorithm>
#include<functional>
#define fuck(x) cout<<"["<<x<<"]"
#define FIN freopen("input.txt","r",stdin)
#define FOUT freopen("output.txt","w+",stdout)
using namespace std;
typedef long long LL;
typedef pair<int, int>PII;

const int MX = 2e5 + 5;
const int mod = 1e9 + 7;
const int INF = 0x3f3f3f3f;
#define lson l,m,rt<<1
#define rson m+1,r,rt<<1|1

int rear, n, m;
int ans[MX]; LL tong[MX];
LL A[MX], B[MX], MAX[MX << 2];
PII mos[MX];

struct Data {
    int id;
    LL ti, xi;
    bool operator<(const Data &P) const {
        return xi < P.xi;
    }
} flog[MX];
void push_up(int rt) {
    MAX[rt] = max(MAX[rt << 1], MAX[rt << 1 | 1]);
}
void build(int l, int r, int rt) {
    if(l == r) {
        MAX[rt] = A[l];
        return;
    }
    int m = (l + r) >> 1;
    build(lson);
    build(rson);
    push_up(rt);
}
void update(int x, LL d, int l, int r, int rt) {
    if(l == r) {
        MAX[rt] += d;
        return;
    }
    int m = (l + r) >> 1;
    if(x <= m) update(x, d, lson);
    else update(x, d, rson);
    push_up(rt);
}
LL query(int L, int R, int l, int r, int rt) {
    if(L <= l && r <= R) {
        return MAX[rt];
    }
    LL ret = 0;
    int m = (l + r) >> 1;
    if(L <= m) ret = max(ret, query(L, R, lson));
    if(R > m) ret = max(ret, query(L, R, rson));
    return ret;
}
int solve(LL pj) {
    int l = 1, m, r = upper_bound(B + 1, B + 1 + rear, pj) - B - 1;
    if(r == 0 || query(1, r, 1, n, 1) < pj) return -1;
    while(l <= r) {
        m = (l + r) >> 1;
        if(query(1, m, 1, n, 1) >= pj) r = m - 1;
        else l = m + 1;
    }
    return r + 1;
}

int main() {
    //FIN;
    while(~scanf("%d%d", &n, &m)) {
        rear = 0;
        memset(ans, 0, sizeof(ans));
        for(int i = 1; i <= n; i++) {
            scanf("%I64d%I64d", &flog[i].xi, &flog[i].ti);
            flog[i].id = i;
        }
        sort(flog + 1, flog + n + 1);
        for(int i = 1; i <= n; i++) {
            A[i] = flog[i].xi + flog[i].ti;
            B[++rear] = flog[i].xi;
        }
        build(1, n, 1);

        for(int i = 1; i <= m; i++) {
            scanf("%d%d", &mos[i].first, &mos[i].second);
        }

        multiset<PII>w;
        for(int i = 1; i <= m; i++) {
            int pos = solve(mos[i].first);
            if(pos != -1) {
                ans[flog[pos].id]++;
                flog[pos].ti += mos[i].second;
                update(pos, mos[i].second, 1, n, 1);
                LL r = flog[pos].xi + flog[pos].ti;

                multiset<PII>::iterator t = w.lower_bound(PII(flog[pos].xi, 0)), nxt;
                while(!w.empty()) {
                    if(t == w.end() || r < t->first) break;

                    r += t->second;
                    ans[flog[pos].id]++;
                    flog[pos].ti += t->second;
                    update(pos, t->second, 1, n, 1);
                    nxt = t; nxt++;
                    w.erase(t);
                    t = nxt;
                }
            } else w.insert(mos[i]);
        }

        for(int i = 1; i <= n; i++) {
            tong[flog[i].id] = flog[i].ti;
        }
        for(int i = 1; i <= n; i++) {
            printf("%d %I64d\n", ans[i], tong[i]);
        }
    }
    return 0;
}
