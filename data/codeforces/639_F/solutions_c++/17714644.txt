#include <bits/stdc++.h>

using std::vector;
using std::pair;
using std::make_pair;

#define SZ(x) (int)(x).size()
#define pb push_back

template<class T>inline void chkmax(T &x, const T &y) {if(x < y) x = y;}
template<class T>inline void chkmin(T &x, const T &y) {if(x > y) x = y;}

template<class T>
inline void read(T &x) {
    char c;int f = 1;x = 0;
    while(((c=getchar()) < '0' || c > '9') && c != '-');
    if(c == '-') f = -1;else x = c-'0';
    while((c=getchar()) >= '0' && c <= '9') x= x*10+c-'0';
    x *= f;
}
int outn;
char out[(int)1e7];
template<class T>
inline void write(T x) {
    if(x < 0) out[outn++] = '-', x = -x;
    if(x) {
        static int tmpn;
        static char tmp[20];
        tmpn = 0;
        while(x) tmp[tmpn++] = x%10, x /= 10;
        while(tmpn) out[outn++] = tmp[--tmpn];
    }
    else out[outn++] = '0';
}

const int N = 3e5, M = 2*N;
const int LOG = 19;

int n, m, qn;
struct edge {
    int u, v;
    edge() {u = v = 0;}
    edge(int _u, int _v):u(_u), v(_v) {}
}e[M+9];
struct graph {
    int sz, head[N+9], to[M+9], ne[M+9];
    int all[M+9], alln;
    graph() {
        sz = 1, alln = 0, memset(head, 0, sizeof head);
    }
    inline void clear() {
        sz = 1;
        while(alln) head[all[alln--]] = 0;
    }
    inline void addedge(int u, int v) {
        all[++alln] = u, all[++alln] = v;
        to[sz] = v, ne[sz] = head[u], head[u] = sz++;
        to[sz] = u, ne[sz] = head[v], head[v] = sz++;
    }
}g, h, r;

int dfn[N+9], low[N+9], tot;
int st[N+9], stn, bel[N+9], sn;
bool inst[N+9];

#define inv(x) ((((x)-1)^1)+1)

void dfs(int now, int fe) {
    dfn[now] = low[now] = ++tot;
    inst[now] = true, st[++stn] = now;
    for(int i = g.head[now], to; i; i = g.ne[i])
        if(i != inv(fe)) {
            if(!dfn[to = g.to[i]]) {
                dfs(to, i);
                chkmin(low[now], low[to]);
            }
            else chkmin(low[now], dfn[to]);
        }
    if(dfn[now] == low[now]) {
        ++sn;
        int cur;
        do {
            cur = st[stn--];
            bel[cur] = sn;
            inst[cur] = false;
        }while(cur != now);
    }
}

int dfsp[N+9], dfspn;
int f[N+9][LOG];
int com[N+9], comn;
int dep[N+9];

void dfs2(int now, int fa) {
    dfsp[now] = ++dfspn, com[now] = comn;
    for(int i = h.head[now], to; i; i = h.ne[i])
        if((to = h.to[i]) != fa) {
            f[to][0] = now;
            dep[to] = dep[now]+1;
            dfs2(to, now);
        }
}

inline void prelca() {
    for(int j = 1; j < LOG; ++j)
        for(int i = 1; i <= n; ++i)
            f[i][j] = f[f[i][j-1]][j-1];
}

inline int up(int x, int y) {
    int i = 0;
    while(y) {
        if(y&1) x = f[x][i];
        i++, y >>= 1;
    }
    return x;
}

inline int getlca(int u, int v) {
    if(dep[u] > dep[v]) std::swap(u, v);
    if(dep[u] < dep[v]) v = up(v, dep[v]-dep[u]);
    while(u != v) {
        for(int i = LOG-1; i >= 0; --i)
            if(f[u][i] != f[v][i])
                u = f[u][i], v = f[v][i];
        if(f[u][0] == f[v][0])
            u = v = f[u][0];
    }
    return u;
}

int R;

inline void rotate(int &x) {
    x = (x+R)%n;
    if(!x) x = n;
}

int x[N+9];
edge y[M+9];
int all[N+M+9], alln;
int alll[N+9], allln;

inline bool cmp1(const int &a, const int &b) {
    return com[a] < com[b];
}

inline bool cmp2(const int &a, const int &b) {
    return dfsp[a] < dfsp[b];
}

int pos[N+9];

void dfs3(int now, int fe) {
    dfn[now] = low[now] = ++tot;
    st[++stn] = now, inst[now] = true;
    for(int i = r.head[now], to; i; i = r.ne[i])
        if(i != inv(fe)) {
            if(!dfn[to = r.to[i]]) {
                dfs3(to, i);
                chkmin(low[now], low[to]);
            }
            else chkmin(low[now], dfn[to]);
        }
    if(dfn[now] == low[now]) {
        ++sn;
        int cur;
        do {
            cur = st[stn--];
            pos[cur] = sn;
            inst[cur] = false;
        }while(cur != now);
    }
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("639F.in", "r", stdin);
    freopen("639F.out", "w", stdout);
#endif
    
    read(n), read(m), read(qn);
    for(int i = 1; i <= m; ++i) {
        int u, v;
        read(u), read(v);
        g.addedge(u, v);
        e[i] = edge(u, v);
    }
    for(int i = 1; i <= n; ++i)
        if(!dfn[i])
            dfs(i, 0);
    /*
    for(int i = 1; i <= n; ++i)
        printf("bel[%d]=%d%c", i, bel[i], i==n?'\n':' ');
    */
    for(int i = 1; i <= m; ++i)
        if(bel[e[i].u] != bel[e[i].v])
            h.addedge(bel[e[i].u], bel[e[i].v]);
    dep[0] = -1;
    for(int i = 1; i <= sn; ++i)
        if(!dfsp[i])
            ++comn, dfspn = 0, dfs2(i, 0);
    /*
    for(int i = 1; i <= sn; ++i)
        printf("[%d]=(%d,%d)%c", i, dfsp[i], com[i], i==sn?'\n':' ');
    */
    prelca();
    while(qn--) {
        int tn, tm;
        read(tn), read(tm);
        alln = 0;
        for(int i = 1; i <= tn; ++i) {
            read(x[i]), rotate(x[i]), x[i] = bel[x[i]], all[++alln] = x[i];
            //printf("%d%c", x[i], i==tn?'\n':' ');
        }
        for(int i = 1; i <= tm; ++i) {
            int u, v;
            read(u), read(v);
            rotate(u), rotate(v);
            u = bel[u], v = bel[v];
            //printf("%d %d\n", u, v);
            y[i] = edge(u, v);
            all[++alln] = u;
            all[++alln] = v;
        }
        std::sort(all+1, all+alln+1);
        alln = std::unique(all+1, all+alln+1)-all-1;
        r.clear(), allln = 0;
        std::sort(all+1, all+alln+1, cmp1);
        for(int i = 1; i <= alln; ++i) {
            int j = i;
            while(j < alln && com[all[j+1]] == com[all[i]]) ++j;
            std::sort(all+i, all+j+1, cmp2);
            stn = 0;
            for(int k = i; k <= j; ++k) {
                if(!stn) st[++stn] = all[k];
                else {
                    int lca = getlca(st[stn], all[k]);
                    for(int last = 0; dep[st[stn]] >= dep[lca];) {
                        if(last) r.addedge(st[stn], last);
                        last = st[stn];
                        if(dep[st[stn]] > dep[lca]) {
                            if(dep[st[stn-1]] < dep[lca]) r.addedge(lca, st[stn]);
                            st[stn--] = 0;
                        }
                        else break;
                    }
                    if(st[stn] != lca) {
                        st[++stn] = lca;
                        alll[++allln] = lca;
                    }
                    st[++stn] = all[k];
                }
                alll[++allln] = all[k];
            }
            int last = 0;
            while(stn) {
                if(last) r.addedge(st[stn], last);
                last = st[stn];
                st[stn--] = 0;
            }
            i = j;
        }
        for(int i = 1; i <= tm; ++i)
            r.addedge(y[i].u, y[i].v);
        /*
        for(int i = 1; i <= allln; ++i) {
            printf("%d:", alll[i]);
            for(int j = r.head[alll[i]]; j; j = r.ne[j])
                printf(" %d", r.to[j]);
            putchar('\n');
        }
        */
        for(int i = 1; i <= allln; ++i)
            dfn[alll[i]] = low[alll[i]] = 0;
        tot = sn = stn = 0;
        for(int i = 1; i <= allln; ++i)
            if(!dfn[alll[i]])
                dfs3(alll[i], 0);
        //printf("%d\n", R);
        bool flag = true;
        int val = pos[x[1]];
        for(int i = 2; i <= tn; ++i)
            if(pos[x[i]] != val) {
                flag = false;
                break;
            }
        static int cnt;cnt++;
        if(flag) puts("YES"), (R += cnt) %= n;
        else puts("NO");
    }

#ifndef ONLINE_JUDGE
    fclose(stdin);fclose(stdout);
#endif
    return 0;
}
