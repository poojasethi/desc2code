#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cctype>
#include<ctime>
#include<cstdlib>
#include<string>
#include<queue>
#include<cmath>
#include<set>
#include<map>
#include<bitset>
#include<vector>
#define Rep(x,a,b) for (int x=a;x<=(int)b;x++)
#define Drp(x,a,b) for (int x=a;x>=(int)b;x--)
#define Cross(x,a) for (int x=Hd[a];~x;x=Nx[x])
#define ll long long
#define INF (1<<29)
#define PII pair<int,int>
#define PDD pair<double,double>
#define mk(a,b) make_pair(a,b)
#define fr first
#define sc second
using namespace std;
inline ll Rd(){
	ll x=0;int ch=getchar(),f=1;
	while (!isdigit(ch)&&(ch!='-')&&(ch!=EOF)) ch=getchar();
	if (ch=='-'){f=-1;ch=getchar();}
	while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}
inline void Rt(ll x){
	if (x<0) putchar('-'),x=-x;
	if (x>=10) Rt(x/10),putchar(x%10+'0');
		else putchar(x+'0');
}
const int N=300005;
int GetFa(int *Fa,int x){return x==Fa[x]?x:Fa[x]=GetFa(Fa,Fa[x]);}
map<int,int>Ex[N];
struct Tree{
	int Cnt,To[N<<1],Nx[N<<1],Hd[N];
	int Tt,Nk[N],Ks,Dfn[N];
	int Sz[N],Tp[N],De[N],Fa[N];
	Tree(){Tt=Cnt=0;memset(Hd,-1,sizeof Hd);}
	void AddEdge(int u,int v){
		To[Cnt]=v;Nx[Cnt]=Hd[u];Hd[u]=Cnt++;
		To[Cnt]=u;Nx[Cnt]=Hd[v];Hd[v]=Cnt++;
	}
	void Dfs(int u){
		Nk[u]=Ks,Dfn[u]=++Tt;
		Sz[u]=1,De[u]=De[Fa[u]]+1;
		int v;
		Cross(i,u){
			if ((v=To[i])==Fa[u]) continue;
			if (!Dfn[v]){
				Fa[v]=u;
				Dfs(v);
				Sz[u]+=Sz[v];
			}
		}
	}
	void Dfs(int u,int Top){
		Tp[u]=Top;
		int v,Son=0;
		Cross(i,u){
			if ((v=To[i])==Fa[u]) continue;
			if (Sz[v]>Sz[Son]) Son=v;
		}
		if (!Son) return;
		Dfs(Son,Top);
		Cross(i,u){
			if ((v=To[i])==Fa[u]||v==Son) continue;
			Dfs(v,v);
		}
	}
	int LCA(int x,int y){
		while (Tp[x]!=Tp[y]){
			if (De[Tp[x]]<De[Tp[y]]) y=Fa[Tp[y]];
				else x=Fa[Tp[x]];
		}
		return De[x]<De[y]?x:y;
	}
}T;
struct Graph{
	int Cnt,To[N<<2],Nx[N<<2],Hd[N];
	int Nd[N],Tm,Bel[N],Dfn[N],Low[N];
	Graph(){Tm=0;memset(Hd,-1,sizeof Hd);}
	void AddEdge(int u,int v){
		To[Cnt]=v;Nx[Cnt]=Hd[u];Hd[u]=Cnt++;
	}
	void PutIn(int u){Nd[++*Nd]=u;}
	void Clear(){
		Rep(i,1,*Nd) Hd[Nd[i]]=-1,Dfn[Nd[i]]=Low[Nd[i]]=0;
		Cnt=*Nd=Tm=0;
	}
	void Dfs(int u,int F){
		Dfn[u]=Low[u]=++Tm;
		int v;
		Cross(i,u){
			if ((v=To[i])==F){F=0;continue;}
			if (Dfn[v]) Low[u]=min(Low[u],Dfn[v]);
				else Dfs(v,u),Low[u]=min(Low[u],Low[v]);
			if (Low[v]<=Dfn[u]) Bel[GetFa(Bel,v)]=GetFa(Bel,u);
		}
	}
	void Tarjan(){
		Rep(i,1,*Nd) Bel[Nd[i]]=Nd[i];
		Rep(i,1,*Nd) if (!Dfn[Nd[i]]) Dfs(Nd[i],0);
		Rep(i,1,*Nd) GetFa(Bel,Nd[i]);
	}
	void MakeTree(){
		for (int i=0;i<=Cnt;i+=2){
			int v=Bel[To[i]],u=Bel[To[i^1]];
			if (u==v) continue;
			if (u>v) swap(u,v);
			if (!Ex[u][v]) T.AddEdge(u,v),Ex[u][v]=1;
		}
	}
}G,Sol;
int n,m,q;
int u[N],v[N],Bo[N],Ver[N<<2];
bool cmp(const int a,const int b){return T.Dfn[a]<T.Dfn[b];}
ll Yes;
int Rot(int x){return (Yes+x-1)%n+1;}
int main(){
	n=Rd(),m=Rd(),q=Rd();
	Rep(i,1,m){
		int u=Rd(),v=Rd();
		G.AddEdge(u,v),G.AddEdge(v,u);
	}
	Rep(i,1,n) G.PutIn(i);
	G.Tarjan();
	G.MakeTree();
	Rep(i,1,n) if (G.Bel[i]==i&&!T.Nk[i]) T.Ks++,T.Dfs(i);
	Rep(i,1,n) if (G.Bel[i]==i&&!T.Tp[i]) T.Dfs(i,i);
	Rep(Nq,1,q){
		*Ver=*Bo=0;
		int Tn=Rd(),Tm=Rd();
		Rep(i,1,Tn) Ver[++*Ver]=Bo[++*Bo]=G.Bel[Rot(Rd())];
		Rep(i,1,Tm) Ver[++*Ver]=u[i]=G.Bel[Rot(Rd())],Ver[++*Ver]=v[i]=G.Bel[Rot(Rd())];
		sort(Ver+1,Ver+*Ver+1,cmp);
		int Tmp=*Ver=unique(Ver+1,Ver+*Ver+1)-Ver-1;
		Rep(i,1,Tmp-1) if (T.Nk[Ver[i]]==T.Nk[Ver[i+1]]) Ver[++*Ver]=T.LCA(Ver[i],Ver[i+1]); 
		sort(Ver+1,Ver+*Ver+1,cmp);
		*Ver=unique(Ver+1,Ver+*Ver+1)-Ver-1;
		Rep(i,2,*Ver) if (T.Nk[Ver[i]]==T.Nk[Ver[i-1]]){
			Tmp=T.LCA(Ver[i],Ver[i-1]);
			Sol.AddEdge(Tmp,Ver[i]),Sol.AddEdge(Ver[i],Tmp);
		}
		Rep(i,1,Tm) if (u[i]!=v[i]) Sol.AddEdge(u[i],v[i]),Sol.AddEdge(v[i],u[i]);
		Rep(i,1,*Ver) Sol.PutIn(Ver[i]);
		Sol.Tarjan();
		bool F=1;
		Rep(i,1,Tn-1) if (Sol.Bel[Bo[i]]!=Sol.Bel[Bo[i+1]]){F=0;break;}
		if (F) puts("YES"),Yes+=Nq;else puts("NO");
		Sol.Clear(); 
	}
}
