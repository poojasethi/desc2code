#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>

using namespace std;

const int MAXN = 600005;

namespace Circle_Tree
{
	int Dfn[MAXN],Low[MAXN];
	int Final[MAXN],To[MAXN],Next[MAXN],Stack[MAXN],Bel[MAXN],tot = 1,cnt,top,all;

	void Link(int u,int v)
	{
		To[++ tot] = v,Next[tot] = Final[u],Final[u] = tot;
		To[++ tot] = u,Next[tot] = Final[v],Final[v] = tot;
	}

	void Dfs(int Now,int Pre)
	{
		Dfn[Now] = Low[Now] = ++ cnt;
		Stack[++ top] = Now;
		for(int i = Final[Now];i;i = Next[i])
			if ((i ^ 1) != Pre)
			{
				if (Dfn[To[i]]) Low[Now] = min(Low[Now],Dfn[To[i]]); else
					Dfs(To[i],i),Low[Now] = min(Low[Now],Low[To[i]]);
			}
		if (Dfn[Now] == Low[Now])
		{
			++ all;
			for(;Stack[top] != Now;top --) Bel[Stack[top]] = all;
			top --;Bel[Now] = all;
		}
	}

	void Clear(int n)
	{
		for(int i = 1;i <= n;i ++) Final[i] = Dfn[i] = Low[i] = Bel[i] = 0;
		cnt = 0;
		tot = 1;
	}

	int Work(int *A,int N)
	{
		for(int i = 1;i <= N;i ++)
			if (!Dfn[i]) Dfs(i,0);
		for(int i = 1;i <= N;i ++) A[i] = Bel[i];
		return all;
	}

	int Work(vector<int> Lk[],int *A,int N)
	{
		int all = Work(A,N);		
		for(int i = 1;i <= N;i ++)
			for(int j = Final[i];j;j = Next[j])
				if (Bel[i] != Bel[To[j]]) Lk[Bel[i]].push_back(Bel[To[j]]);
		return all;
	}
}

vector<int> Lk[MAXN];
int Bel[MAXN],Fa[MAXN][19],Root[MAXN],Deep[MAXN],Dfn[MAXN],N,M,Q,C,cnt;

bool cmp(int a,int b)
{
	return Dfn[a] < Dfn[b];
}

void Dfs(int Now,int Pre)
{
	Fa[Now][0] = Pre,Deep[Now] = Deep[Pre] + 1,Root[Now] = Root[Pre],Dfn[Now] = ++ cnt;
	for(int i = 1;i < 19;i ++) Fa[Now][i] = Fa[Fa[Now][i - 1]][i - 1];
	for(int i = 0;i < Lk[Now].size();i ++)
		if (Lk[Now][i] != Pre && !Root[Lk[Now][i]]) Dfs(Lk[Now][i],Now);
}

int LCA(int u,int v)
{
	if (Root[u] != Root[v]) return 0;
	if (Deep[u] > Deep[v]) swap(u,v);
	for(int i = 18;i + 1;i --)
		if (Deep[Fa[v][i]] >= Deep[u]) v = Fa[v][i];
	if (u == v) return u;
	for(int i = 18;i + 1;i --)
		if (Fa[v][i] != Fa[u][i]) v = Fa[v][i],u = Fa[u][i];
	return Fa[u][0];
}

int Get_Num(int r)
{
	int x;
	scanf("%d", &x);
	x = (x + r) % N;
	if (!x) x = N;
	return x;
}

int main()
{
	//freopen("data.in","r",stdin),freopen("data.out","w",stdout);
	scanf("%d%d%d", &N, &M, &Q);
	for(int i = 1,u,v;i <= M;i ++)
	{
		scanf("%d%d", &u, &v);
		Circle_Tree::Link(u,v);
	}
	C = Circle_Tree::Work(Lk,Bel,N);
	for(int i = 1;i <= C;i ++) 
		if (!Root[i]) Root[0] = i,Dfs(i,0),Root[0] = 0;
	for(int i = 1,r = 0;i <= Q;i ++)
	{
		static map<int,int> Tag;
		static int S[MAXN],E[MAXN][2];
		static vector<int> Main;
		Tag.clear(),Main.clear();
		int n,m;
		scanf("%d%d", &n, &m);
		for(int j = 1,x;j <= n;j ++)
		{
			x = Get_Num(r);
			S[j] = x;
			Main.push_back(Bel[x]);
		}
		for(int j = 1,u,v;j <= m;j ++)
		{
			u = Get_Num(r),v = Get_Num(r);
			Main.push_back(Bel[u]),Main.push_back(Bel[v]);
			E[j][0] = Bel[u],E[j][1] = Bel[v];
		}
		sort(Main.begin(),Main.end(),cmp);
		int c = Main.size();
		for(int j = 0;j + 1 < c;j ++)
		{
			int u = Main[j],v = Main[j + 1];
			if (Root[u] != Root[v]) continue;
			Main.push_back(LCA(u,v));
		}
		c = 0;
		sort(Main.begin(),Main.end(),cmp);
		int num = Main.size();
		for(int j = 0;j < num;j ++) if (!Tag[Main[j]]) Tag[Main[j]] = ++ c;
		Circle_Tree::Clear(c);
		static int Stack[MAXN];
		int top = 0;
		for(int j = 0;j < num;j ++)
		{
			if (j && Main[j] == Main[j - 1]) continue;
			for(;top && LCA(Main[j],Stack[top]) != Stack[top];top --);
			if (top)
				Circle_Tree::Link(Tag[Stack[top]],Tag[Main[j]]);
			Stack[++ top] = Main[j];
		}
		for(int j = 1;j <= m;j ++)
			Circle_Tree::Link(Tag[E[j][0]],Tag[E[j][1]]);
		static int Cir[MAXN];
		Circle_Tree::Work(Cir,c);
		bool ok = 1;
		int u = Cir[Tag[Bel[S[1]]]];
		for(int j = 2;j <= n;j ++)
			if (u != Cir[Tag[Bel[S[j]]]]) {ok = 0;break;}
		if (ok) printf("YES\n"),r = (r + i - 1) % N + 1; else
			printf("NO\n");
	}
	return 0;
}
