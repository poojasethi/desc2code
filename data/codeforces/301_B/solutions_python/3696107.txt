#!/usr/bin/env python
# -*- coding: UTF-8 -*-

import sys
from collections import deque

DEBUG = 0
UPPER = 10 ** 8

def ReadIn():
    data = [int(x) for x in sys.stdin.read().split()]
    offset = 0
    while offset < len(data):
        n, d = data[offset : offset + 2]
        offset += 2
        a = [0] + data[offset : offset + n - 2] + [0]
        offset += n - 2
        pos = [tuple(data[idx : idx + 2]) for idx in xrange(offset, offset + 2 * n, 2)]
        offset += 2 * n
        yield d, a, pos

def SPFA(init, unit, inc, pos):

    def dist(a, b):
        return sum(abs(x1 - x2) for x1, x2 in zip(a, b))

    n = len(inc)
    d = {0 : init}
    inQueue = set([0])
    queue = deque([0])
    while len(queue):
        v = queue.popleft()
        inQueue.remove(v)
        remain = d[v]
        if DEBUG:
            print 'v =', v
            print 'd =', d
        for nv in xrange(n):
            if v == nv: continue
            used = unit * dist(pos[v], pos[nv])
            fill = inc[nv]
            if remain < used: continue
            nd = remain - used + fill
            if nv not in d or nd > d[nv]:
                d[nv] = nd
                if nv == n - 1: return True
                if nv not in inQueue:
                    inQueue.add(nv)
                    queue.append(nv)
    return False

def Solve(unit, inc, pos):
    if DEBUG:
        print 'unit =', unit
        print 'inc =', inc
        print 'pos =', pos
    l, r = 0, UPPER
    while l < r:
        mid = (l + r) >> 1
        if DEBUG:
            print l, mid, r
        if SPFA(mid, unit, inc, pos):
            r = mid
        else:
            l = mid + 1
    print l

if __name__ == '__main__':
    for unit, inc, pos in ReadIn():
        Solve(unit, inc, pos)
