//In the name of God
//...
#include <iostream>
#include <map>
using namespace std;

typedef pair<int, int> point;
#define X first
#define Y second
typedef map<int, int> hull;
typedef hull::iterator IT;
point operator-(point p, point q) { return point(p.X - q.X, p.Y - q.Y); }
long long cross(point p, point q) { return 1ll * p.X * q.Y - 1ll * p.Y * q.X; }

int n, q;
hull bot, top;

inline bool under(hull &h, point p) {
	IT fit = h.lower_bound(p.X);
	if (fit == h.end())
		return false;
	if (fit-> X == p.X)
		return p.Y <= fit-> Y;
	if (fit == h.begin())
		return false;
	IT sit = fit; fit--;
	return cross(p - *fit, *sit - *fit) >= 0;
}
void add(hull &h, point p) {
	if (under(h, p))
		return;
	IT fit = h.lower_bound(p.X);
	while (fit != h.end()) {
		IT sit = fit; sit++;
		if (sit != h.end() && cross(*fit - p, *sit - p) >= 0) {
			h.erase(fit);
			fit = sit;
		}
		else
			break;
	}
	IT sit = h.lower_bound(p.X);
	while (sit != h.begin()) {
		IT fit = --sit;
		if (fit == h.begin())
			break;
		fit--;
		if (cross(*sit - *fit, p - *fit) >= 0) {
			h.erase(sit);
			sit = h.lower_bound(p.X);
		}
	}
	h[p.X] = p.Y;
}
int main() {
	ios_base::sync_with_stdio(false);
	cin >> q;
	while (q--) {
		int x, y, t;
		cin >> t >> x >> y;
		if (t == 1) {
			add(top, point(x, y));
			add(bot, point(x, -y));
		}
		else
			cout << (under(top, point(x, y)) && under(bot, point(x, -y))? "YES": "NO") << '\n';
	}
	return 0;
}
