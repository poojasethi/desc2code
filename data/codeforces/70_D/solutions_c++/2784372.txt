#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<complex>
#include<map>
using namespace std;
#define mp make_pair
#define pb push_back
#define lb lower_bound
#define ub upper_bound
#define se second
#define fi first
typedef long long ll;
typedef complex<ll> pt;
typedef map<int,pt> ppt;
typedef ppt::iterator iter;
ppt upper,lower;
ll cross(pt c1,pt c2){
    return (conj(c1)*c2).imag();
}
bool check(ppt &H,int x,int y){
	if(!H.size())
        return 0;
	if(x<H.begin()->se.real()||x>H.rbegin()->se.real())
        return 0;
	if(H.count(x))
        return H[x].imag()<=y;
	pt p=pt(x,y);
	iter r=H.lb(x),l=r;
    l--;
	return cross(r->se-l->se,p-l->se)>=0;
}
void add(ppt &H,int x,int y){
	pt p=pt(x,y);
	H[x]=p;
	iter pos=H.find(x),i,j;
	i=pos;i--;j=i;j--;
	for(;pos!=H.begin()&&i!=H.begin();i=j,j=i,j--)
		if(cross(i->se-j->se,p-j->se)<=0)H.erase(i);
		else break;
	i=pos;i++;j=i;j++;
	for(;i!=H.end()&&j!=H.end();i=j,j=i,j++)
		if(cross(i->se-p,j->se-p)<=0)H.erase(i);
		else break;
}
int main(){
    //freopen("AC.in","r",stdin);
    //freopen("AC.out","w",stdout);
    int n;
	scanf("%d",&n);
	while(n--){
		int opt,x,y;
		scanf("%d%d%d",&opt,&x,&y);
		if(opt==1){
			if(!check(lower,x,y))add(lower,x,y);
			if(!check(upper,x,-y))add(upper,x,-y);
		}
		else{
			bool ret=check(lower,x,y)&&check(upper,x,-y);
			puts(ret?"YES":"NO");
		}
	}
	return 0;
}
