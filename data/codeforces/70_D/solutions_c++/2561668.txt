#include<stdio.h>
#include<complex>
#include<map>
using namespace std;
int n;
typedef long long ll;
typedef complex<ll> point;
typedef map<int,point> hull;
typedef hull::iterator iter;
inline ll cross(const point &c1,const point &c2){return (conj(c1)*c2).imag();}
bool checkin(hull &H,int x,int y)
{
	if(!H.size())return 0;
	if(x<H.begin()->second.real()||x>H.rbegin()->second.real())return 0;
	if(H.count(x))return H[x].imag()<=y;
	point p=point(x,y);
	iter r=H.lower_bound(x),l=r;l--;
	return cross(r->second-l->second,p-l->second)>=0;
}
void add(hull &H,int x,int y)
{
	point p=point(x,y);
	H[x]=p;
	iter pos=H.find(x),i,j;
	for(i=pos,i--,j=i,j--;pos!=H.begin()&&i!=H.begin();i=j,j=i,j--)
		if(cross(i->second-j->second,p-j->second)<=0)H.erase(i);
		else break;
	for(i=pos,i++,j=i,j++;i!=H.end()&&j!=H.end();i=j,j=i,j++)
		if(cross(i->second-p,j->second-p)<=0)H.erase(i);
		else break;
}
hull upper,lower;
int main()
{
	scanf("%d",&n);
	while(n--)
	{
		int cmd,x,y;
		scanf("%d%d%d",&cmd,&x,&y);
		if(cmd==1)
		{
			if(!checkin(lower,x,y))add(lower,x,y);
			if(!checkin(upper,x,-y))add(upper,x,-y);
		}
		else
		{
			bool ret=checkin(lower,x,y)&&checkin(upper,x,-y);
			puts(ret?"YES":"NO");
		}
	}
	return 0;
}
