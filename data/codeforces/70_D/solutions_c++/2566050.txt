#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <map>
using namespace std;

int m,n,j,k,l,i,o,p,__t,kind,x,y;

typedef pair<int,int> pint;
typedef long long LL;
typedef map<int,int>::iterator ite;
map <int,int> M[2];

char ch;
void read(int &a){
	scanf("%d",&a);
}

LL xj(LL x1,LL y1,LL x2,LL y2,LL x3,LL y3){
	return (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);
}

inline int X(ite a){
	return (*a).first;
}

inline int Y(ite a){
	return (*a).second;
}

bool in(int _x,int _y,int tag){
	if (M[tag].size() == 0) return 0;
	if (_x < X(M[tag].begin()) || _x > (*M[tag].rbegin()).first) return 0;
	if (M[tag].count(_x)) return _y >= M[tag][_x];
	ite temp = M[tag].lower_bound(_x);
	ite nex = temp; -- temp;
	return xj(X(temp),Y(temp),_x,_y,X(nex),Y(nex)) <= 0;
}

void add(int _x,int _y,int tag){
	M[tag][_x] = _y;
	ite now = M[tag].lower_bound(_x),i,j;
	if (now != M[tag].begin()){
		for (i = now,i --;i != M[tag].begin();){
			j = i,-- j;
			if (xj(X(j),Y(j),X(i),Y(i),X(now),Y(now)) > 0) break;
			swap(i,j);
			M[tag].erase(j);
		}
	}
	for (i = now,i ++;i != M[tag].end();){
			j = i,++ j;
			if (j == M[tag].end()) break;
			if (xj(X(now),Y(now),X(i),Y(i),X(j),Y(j)) > 0) break;
			swap(i,j);
			M[tag].erase(j);
		}
}

int main(){
	read(m);
	for (;m --;){
		read(kind),read(x),read(y);
		if (kind == 1){
			if (!in(x,y,0)) add(x,y,0);
			if (!in(x,-y,1)) add(x,-y,1);
		} else {
			if (in(x,y,0) && in(x,-y,1)) printf("YES\n"); else printf("NO\n");
		}
	}
}
