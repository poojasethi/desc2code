#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <complex>
#include <map>
using namespace std;
#define x real()
#define y imag()
 
typedef complex<int> point;
 
long long cross(const point&a,const point&b){
    return (long long)a.x*b.y-(long long)a.y*b.x;
}
 
long long cross(const point&a,const point&b,const point&c){
    return cross(b-a,c-a);
}
 
map<double,point>p;
typedef map<double,point>::iterator iter;
 
iter next(iter a){
    if(++a==p.end())return p.begin();
    else return a;
}
 
iter last(iter a){
    if(a==p.begin())a=p.end();
    return --a;
}
 
template<class T>
void work(const point&a,iter i,const T&pre,const long long&f){
    iter k=pre(i);
    while(f*cross(a,i->second,k->second)>=0){
        p.erase(i);
        i=k;
        k=pre(i);
    }
}
 
double arg(const point&a){
    return atan2(a.y,a.x);
}
 
int main(){
    point a,b,c,d; int n, cmd; long long t;
    cin>>n>>cmd>>a.x>>a.y>>cmd>>b.x>>b.y>>cmd>>c.x>>c.y;
    d=a+b+c; a+=a+a-d; b+=b+b-d; c+=c+c-d;
    p[arg(a)]=a; p[arg(b)]=b; p[arg(c)]=c;
    for(n -= 3; n; --n){
        scanf("%d%d%d",&cmd, &a.x, &a.y); a+=a+a-d;
        iter i=last(p.lower_bound(arg(a))),j=next(i);
        t = cross(j->second,i->second,a);
        if (cmd == 1) {
            if (t > 0) {
                work(a,i,last,1);
                work(a,j,next,-1);
                p[arg(a)] = a;
            }
        } else puts(t > 0 ? "NO" : "YES");
    }
}
