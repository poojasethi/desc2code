#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
#define f first
#define s second
using namespace std;
typedef long long LL;
typedef pair<int,int> PI;
typedef map<int,int> MI;
typedef MI::iterator MII;
MI t,b;
LL cp(const PI &x,const PI &y,const PI &z){
	return (LL)(x.f-z.f)*(y.s-z.s)-(LL)(x.s-z.s)*(y.f-z.f);
}
bool askt(const PI &x){
	MII i=t.lower_bound(x.f);
	if(i==t.end())return 0;
	if((*i).f==x.f)return x.s<=(*i).s;
	if(i==t.begin())return 0;
	MII j=i--;
	return cp(x,*j,*i)>=0;
}
bool askb(const PI &x){
	MII i=b.lower_bound(x.f);
	if(i==b.end())return 0;
	if((*i).f==x.f)return x.s>=(*i).s;
	if(i==b.begin())return 0;
	MII j=i--;
	return cp(x,*j,*i)<=0;
}
void addt(const PI &x){
	t[x.f]=x.s;
	MII i=t.upper_bound(x.f);
	if(i!=t.end())
		for(MII j=i++;i!=t.end();j=i++)
			if(cp(*i,*j,x)<=0)t.erase(j);else break;
	i=t.find(x.f);
	if(i!=t.begin()){
		MII j=--i;
		for(;j!=t.begin();){
			i=j--;
			if(cp(*i,*j,x)<=0)t.erase(i);else break;
		}
	}
}
void addb(const PI &x){
	b[x.f]=x.s;
	MII i=b.upper_bound(x.f);
	if(i!=b.end())
		for(MII j=i++;i!=b.end();j=i++)
			if(cp(*i,*j,x)>=0)b.erase(j);else break;
	i=b.find(x.f);
	if(i!=b.begin()){
		MII j=--i;
		for(;j!=b.begin();){
			i=j--;
			if(cp(*i,*j,x)>=0)b.erase(i);else break;
		}
	}
}

int main(){
	int n;scanf("%d",&n);
	for(int i=1;i<=n;++i){
		int mk;PI x;
		scanf("%d%d%d",&mk,&x.f,&x.s);
		bool ft=askt(x),fb=askb(x);
		if(mk==1){
			if(!ft)addt(x);
			if(!fb)addb(x);
		}
		else puts(ft&&fb?"YES":"NO");
	}
	return 0;
}
