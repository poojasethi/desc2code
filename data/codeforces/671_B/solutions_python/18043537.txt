def read():
  return map(int, raw_input().split())
def main():
  n, k = read()
  cs = read()
  cs.sort()
  su = [cs[0]]
  for i in range(1, len(cs)):
    su.append(cs[i] + su[i - 1])
  div, rem = divmod(su[-1], n)
  sk, cnt = 0, 0
  for i in range(n):
    if cs[i] > div:
      sk += cs[i] - div
      cnt += 1
  sk -= min(cnt, rem)
  if sk <= k:
    print int(bool(rem))
    return

  l, r = cs[0], cs[-1]
  maxv = bin_search(l, r, lambda m: check_max(cs, su, k, m))[1] + 1
  minv = bin_search(cs[0], maxv, lambda m: check_min(cs, su, k, m))[0] - 1
  print maxv - minv

def check_min(cs, su, k, m):
  idx = upper_bound(cs, m)
  cost = m * idx - (su[idx - 1] if idx else 0)
  if cost <= k:
    return True
  else:
    return False

def bin_search(l, r, f):
  while l <= r:
    m = (l + r) >> 1
    if f(m):
      l = m + 1
    else:
      r = m - 1
  return l, r

def lower_bound(xs, x):
  l, r = bin_search(0, len(xs) - 1, lambda m: xs[m] < x)
  return l

def upper_bound(xs, x):
  l, r = bin_search(0, len(xs) - 1, lambda m: xs[m] <= x)
  return l

def check_max(cs, su, k, m):
  idx = upper_bound(cs, m)
  cost = su[-1] - (su[idx - 1] if idx else 0) - m * (len(cs) - idx)
  if cost > k:
    return True
  else:
    return False


if __name__ == '__main__':
  main()