#include <cmath>
#include <cstdio>
#include <algorithm>

using namespace std;

typedef long double ldb;

const int N = 1610;

int n, T;

struct cp {
	ldb s, t;
} dp[N];

struct problem {
	int a0, a1, t0, t1; double p;
	void init() {
		scanf("%d %d %d %d %lf", &a0, &a1, &t0, &t1, &p);
	}
	cp join0(cp o) {
		return (cp) {o.s + a0, o.t + t0};
	}
	cp join1(cp o, int T) {
		return (cp) {o.s + a0 + a1 * (1.0 - p), p * (t0 + o.t) + (1.0 - p) * (T + t0 + t1)};
	}
} pro[N];

bool cmp_pro(const problem& a, const problem& b) {
	return a.p * a.t1 * (1.0 - b.p) < b.p * b.t1 * (1.0 - a.p);
}
void update(cp &a, cp b) {
	if (fabs(a.s - b.s) < 1e-8) {
		if (a.t > b.t) a = b;
	} else {
		if (a.s < b.s) a = b;
	}
}
int main() {
	scanf("%d %d", &n, &T);
	for (int i = 1; i <= n; ++i) {
		pro[i].init();
	}
	sort(pro + 1, pro + n + 1, cmp_pro);

	for (int i = 1; i <= n; ++i) {
		int t0 = pro[i].t0, t1 = t0 + pro[i].t1;
		for (int x = T; x >= 0; --x) {
			if (x + t0 <= T)
				update(dp[x + t0], pro[i].join0(dp[x]));
			if (x + t1 <= T)
				update(dp[x + t1], pro[i].join1(dp[x], x));
		}
	}
	for (int x = 1; x <= T; ++x) {
		update(dp[x], dp[x - 1]);
	}
	printf("%.12lf %.12lf\n", (double)dp[T].s, (double)dp[T].t);
}
