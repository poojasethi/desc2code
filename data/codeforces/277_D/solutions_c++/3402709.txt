#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;

typedef long double LD;

#define Px first
#define Py second
typedef pair<int, int> ipar;

const int N = 1024, T = 1700;
const LD eps = 1e-8;

struct restype {
	LD v, t;
	void update (restype b) {
		if (b.v > v) v = b.v, t = b.t;
		else if (abs(b.v - v) < eps && b.t < t) t = b.t;
	}
} f[N][T];
int n, maxt;

struct item { ipar s, t; LD p; LD v; } I[N];
bool operator< (const item &a, const item &b) {
	return a.v < b.v;
}

int main () {
#ifdef LOCAL
	freopen("in", "r", stdin);
#endif
	scanf("%d%d", &n, &maxt);
	for (int i = 1; i <= n; ++i) {
		double d;
		scanf("%d%d%d%d%lf", &I[i].s.Px, &I[i].s.Py, &I[i].t.Px, &I[i].t.Py, &d);
		I[i].p = d;
		if (d == 1) I[i].v = 1e300;
		else I[i].v = I[i].t.Py * d / (1 - d);
	}
	sort(I + 1, I + 1 + n);
	for (int i = 1; i <= n; ++i) {
		for (int j = 0; j <= maxt; ++j) {
			f[i + 1][j].update(f[i][j]);
			if (j + I[i].t.Px <= maxt)
				f[i + 1][j + I[i].t.Px].update((restype){
							f[i][j].v + I[i].s.Px, 
							f[i][j].t + I[i].t.Px
						});
			if (j + I[i].t.Px + I[i].t.Py <= maxt)
				f[i + 1][j + I[i].t.Px + I[i].t.Py].update((restype){
							f[i][j].v + I[i].s.Px + (1 - I[i].p) * I[i].s.Py,
							I[i].p * (I[i].t.Px + f[i][j].t) + (1 - I[i].p) * (I[i].t.Px + j + I[i].t.Py)
						});
		}
	}
	restype res; res.v = 0; res.t = 0;
	for (int j = 0; j <= maxt; ++j) res.update(f[n + 1][j]);
	printf("%.12f %.12f\n", double(res.v), double(res.t));
	return 0;
}

