#include <iostream>
#include <algorithm>
#include <cstring>
#include <climits>
#include <string>
#include <vector>
#include <queue>
#include <set>
#include <cmath>
#include <cstdio>
#include <cassert>
#define EPS 1e-8
using namespace std;
struct prob {
	long long ss,ls;
	int st,lt;
	double f;
} P[1005];
bool cmp(prob a,prob b) {
	return a.lt*a.f*(1-b.f) < b.lt*b.f*(1-a.f);
}
long long dps[1005][1565];
double dpt[1005][1565];
int main() {
	int N,T;
	scanf("%d%d",&N,&T);
	for(int i=1;i<=N;++i) {
		scanf("%I64d%I64d%d%d%lf",&P[i].ss,&P[i].ls,&P[i].st,&P[i].lt,&P[i].f);
		P[i].ss *= 1000000;
	}
	sort(P+1,P+N+1,cmp);
	for(int i=1;i<=N;++i) {
		int f = int(P[i].f*1000000 + 0.5);
		for(int t=1;t<=T;++t) {
			dps[i][t] = dps[i-1][t];
			dpt[i][t] = dpt[i-1][t];
			if(P[i].st > t) continue;
			// case 1: only small
			long long ns = dps[i-1][t-P[i].st]+P[i].ss;
			double nt = dpt[i-1][t-P[i].st];
			if(dps[i][t] == ns) {
				dpt[i][t] = max(dpt[i][t],nt);
			}
			else if(dps[i][t] < ns) {
				dps[i][t] = ns;
				dpt[i][t] = nt;
			}
			if(P[i].st+P[i].lt > t) continue;
			// case 2: small+large
			ns = dps[i-1][t-P[i].st-P[i].lt]+P[i].ss+P[i].ls*(1000000-f);
			nt = (dpt[i-1][t-P[i].st-P[i].lt]+P[i].lt)*P[i].f;
			if(dps[i][t] == ns) {
				dpt[i][t] = max(dpt[i][t],nt);
			}
			else if(dps[i][t] < ns) {
				dps[i][t] = ns;
				dpt[i][t] = nt;
			}
		}
	}
	double bestt = T-dpt[N][T];
	for(int t=0;t<=T;++t) {
		if(dps[N][t] == dps[N][T]) bestt = min(bestt,t-dpt[N][t]);
	}
	printf("%.9lf %.9lf\n",dps[N][T]/1000000.0,bestt);
}
