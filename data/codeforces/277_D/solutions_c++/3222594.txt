#include<iostream>
#include<iomanip>
#include<sstream>
#include<vector>
#include<algorithm>
#include<set>
#include<map>
#include<queue>
#include<complex>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cassert>
using namespace std;

#define rep(i,n) for(int i=0;i<(int)n;i++)
#define each(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)
#define pb push_back
#define mp make_pair
#define all(c) c.begin(),c.end()
#define dbg(x) cerr<<__LINE__<<": "<<#x<<" = "<<(x)<<endl

typedef long double ld;
typedef long long ll;
const int inf=(int)1e9;
const ld EPS=1e-12, INF=1e12;

struct P{
	int ss, sl, ts, tl;
	ld p;
	P(int a, int b, int c, int d, ld e):ss(a), sl(b), ts(c), tl(d), p(e){}
	bool operator<(const P &o)const{
		return (tl + o.tl) * o.p + tl * (1 - o.p) * p
		< (tl + o.tl) * p + o.tl * (1 - p) * o.p;
	}
};
int n, t;
pair<ld, ld> dp[1600];

void update(pair<ld, ld> &a, ld x, ld y){
	if(a.first + EPS < x) a = mp(x, y);
	if(abs(a.first - x) < EPS && y + EPS < a.second) a = mp(x, y);
}

int main(){
	cin >> n >> t;
	vector<P> prob;
	rep(i, n){
		int ss, sl, ts, tl;
		ld p;
		cin >> ss >> sl >> ts >> tl >> p;
		prob.pb(P(ss, sl, ts, tl, 1 - p));
	}
	sort(all(prob));
	
	rep(i, n) for(int j = t; j >= 0; j--){
		int ss = prob[i].ss, sl = prob[i].sl;
		int ts = prob[i].ts, tl = prob[i].tl;
		ld p = prob[i].p;
		
		int nj = j + ts;
		if(nj <= t) update(dp[nj], dp[j].first + ss, dp[j].second + ts);
		
		nj = j + ts + tl;
		ld na = dp[j].first, nb = dp[j].second;
		na += ss + p * sl;
		nb = (ts + nb) * (1 - p) + nj * p;
		
		if(nj <= t) update(dp[nj], na, nb);
	}
	pair<ld, ld> ans = mp(0, 0);
	rep(i, t + 1) update(ans, dp[i].first, dp[i].second);
	cout << fixed << setprecision(20) << ans.first << " " << ans.second << endl;
	
	return 0;
}
