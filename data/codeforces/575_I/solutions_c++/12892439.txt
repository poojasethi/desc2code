#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

#define n   100005
#define For(i,a,b)  for(int i=a;i<=b;i++)

int     N,Q,T[4],C[n],Ans[n];
struct  Nod{int k,x,y,z;}A[n],B[n],G[4][n];

#define CH  (ch=getchar())
int     IN(){
        int x=0,ch;
        for (;CH<'0'||ch>'9';);
        for (;ch>='0'&&ch<='9';CH)  (x*=10)+=ch-'0';
        return  x;
}

inline  bool    Cmpz(int a,int b)   {return a<b;}
void    Work3(int l,int r)  {
        if  (l>=r)  return; int Mid=l+r>>1,t=0;
        For(i,l,Mid)    if  (!B[i].k)   C[++t]=B[i].z;
        sort(C+1,C+t+1,Cmpz);
        For(i,Mid+1,r)  if  (B[i].k)    Ans[B[i].k]+=upper_bound(C+1,C+t+1,B[i].z)-C-1;
        Work3(l,Mid);   Work3(Mid+1,r);
}

inline  bool    Cmpy(const Nod&a,const Nod&b)   {return a.y<b.y||a.y==b.y&&a.k<b.k;}
void    Work2(int l,int r){
        if  (l>=r)  return; int Mid=l+r>>1,t=0;
        For(i,l,Mid)    if  (!A[i].k)   B[++t]=A[i];
        For(i,Mid+1,r)  if  (A[i].k)    B[++t]=A[i];
        sort(B+1,B+t+1,Cmpy);   Work3(1,t);
        Work2(l,Mid);   Work2(Mid+1,r);
}

inline  bool    Cmpx(const Nod&a,const Nod&b)   {return a.x<b.x||a.x==b.x&&a.k<b.k;}
void    Work1(int k,int l,int r){
        if  (l>=r)  return; int Mid=l+r>>1,t=0;
        For(i,l,Mid)    if  (!G[k][i].k)A[++t]=G[k][i];
        For(i,Mid+1,r)  if  (G[k][i].k) A[++t]=G[k][i];
        sort(A+1,A+t+1,Cmpx);   Work2(1,t);
        Work1(k,l,Mid); Work1(k,Mid+1,r);
}

int     main(){
        N=IN(); Q=IN();
        For(i,1,Q){
            int k=IN();
            if  (k==1)  {
                int d=IN(),x=IN(),y=IN(),l=IN();
                if  (d==1)  G[0][++T[0]]=(Nod){0,x,y,-x-y-l};
                if  (d==2)  G[1][++T[1]]=(Nod){0,x,-y,y-x-l};
                if  (d==3)  G[2][++T[2]]=(Nod){0,-x,y,x-y-l};
                if  (d==4)  G[3][++T[3]]=(Nod){0,-x,-y,x+y-l};    Ans[i]=-1;
            }   else    {
                int x=IN(),y=IN();
                G[0][++T[0]]=(Nod){i,x,y,-x-y};
                G[1][++T[1]]=(Nod){i,x,-y,y-x};
                G[2][++T[2]]=(Nod){i,-x,y,x-y};
                G[3][++T[3]]=(Nod){i,-x,-y,x+y};
            }
        }
        For(i,0,3)  Work1(i,1,T[i]);
        For(i,1,Q)  if  (Ans[i]!=-1)    printf("%d\n",Ans[i]);
}