def f(p, d):
    return hp[p] / d + 1 if hp[p] >= 0 else 0

def dfs(p, cur_step):
    global ans_step
    if cur_step >= ans_step:
        return
    if p == n - 3:
        d = max(f(p, b), f(p + 1, a), f(p + 2, b))
        cur_step += d
        if cur_step < ans_step:
            hit[p] += d
            global ans
            ans_step = cur_step
            ans = hit[:]
            hit[p] -= d
        return

    lo = f(p, b)
    hi = max(lo, f(p + 1, a))
    for i in xrange(lo, hi + 1):
        hp[p] -= i * b
        hp[p + 1] -= i * a
        hp[p + 2] -= i * b
        hit[p] += i
        dfs(p + 1, cur_step + i)
        hp[p] += i * b
        hp[p + 1] += i * a
        hp[p + 2] += i * b
        hit[p] -= i

n, a, b = map(int, raw_input().split())
hp = map(int, raw_input().split())
hit = [0] * (n - 1)
ans_step = 10 ** 9
dfs(0, 0)

print ans_step
for i in xrange(len(ans)):
    print (str(i + 2) + ' ') * ans[i],
