// Problem : cf 300 H
// Author : Leo Yu

#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

using namespace std;
typedef long long LL;

#define link Link
#define next Next
#define elif else if

inline int read()
{
	int x = 0; char ch = getchar(); bool positive = 1;
	for (; !isdigit(ch); ch = getchar())	if (ch == '-')	positive = 0;
	for (; isdigit(ch); ch = getchar())	x = x * 10 + ch - '0';
	return positive ? x : -x;
}

int color[100005];
int lx, rx, ly, ry;
int l[100005], r[100005];
int Sl, Sr;
vector<int> edge[100005];
int N, M;

void	quit()
{
	cout << "IMPOSSIBLE" << endl;
	exit(0);
}

void	DFS(int x, int c)
{
	color[x] = c;
	if (c == 1)
	{
		lx = max(lx, l[x]);
		rx = min(rx, r[x]);
	}
	if (c == 2)
	{
		ly = max(ly, l[x]);
		ry = min(ry, r[x]);
	}
	for (int i = 0; i < edge[x].size(); ++ i)
	{
		int y = edge[x][i];
		if (color[y])
		{
			if (color[y] == color[x])
			{
				cout << "IMPOSSIBLE" << endl;
				exit(0);
			}
		}
		else
			DFS(y, 3 - c);
	}
}

int firstc[100005];

void	final(int l, int r)
{
	if (l > r)	swap(l, r);
	memset(color, 0, sizeof(color));
	for (int i = 1; i <= N; ++ i)	if (!color[i])
	{
		lx = 0, rx = Sr, ly = 0, ry = Sr;
		DFS(i, 1);
		if (lx <= l && l <= rx && ly <= r && r <= ry)
		{
			firstc[i] = 1;
		}
		else
		{
			firstc[i] = 2;
		}
	}
	memset(color, 0, sizeof(color));
	for (int i = 1; i <= N; ++ i)	if (!color[i])
		DFS(i, firstc[i]);
	printf("POSSIBLE\n");
	printf("%d %d\n", l, r);
	for (int i = 1; i <= N; ++ i)	printf("%d", color[i]);
	cout << endl;
	exit(0);
}

void	check(int Lx, int Rx, int Ly, int Ry)
{
	if (Lx > Rx)	return;
	if (Ly > Ry)	return;
	int l = Lx + Ly, r = Rx + Ry;
	l = max(l, Sl);
	r = min(r, Sr);
	if (l > r)	return;
	int s = l;
	if (s - Lx >= Ly && s - Lx <= Ry)
	{
		final(Lx, s - Lx);
	}
	if (s - Rx >= Ly && s - Rx <= Ry)
	{
		final(Rx, s - Rx);
	}
	if (s - Ly >= Lx && s - Ly <= Rx)
	{
		final(s - Ly, Ly);
	}
	if (s - Ry >= Lx && s - Ry <= Rx)
	{
		final(s - Ry, Ry);
	}
}

vector< pair<int, int> > a;
pair<int, int> b[100005], c[100005];

int main()
{
#ifndef ONLINE_JUDGE
	freopen("a.in", "r", stdin);
	//freopen("a.out", "w", stdout);
#endif

	Sl = read(), Sr = read();
	N = read(), M = read();
	for (int i = 1; i <= N; ++ i)	l[i] = read(), r[i] = read();
	for (int i = 1; i <= M; ++ i)
	{
		int x = read(), y = read();
		edge[x].push_back(y), edge[y].push_back(x);
	}
	int Lx = 0, Rx = Sr, Ly = 0, Ry = Sr;
	for (int i = 1; i <= N; ++ i)	if (!color[i])
	{
		lx = 0, rx = Sr, ly = 0, ry = Sr;
		DFS(i, 1);
		if (lx > rx)	quit();
		if (ly > ry)	quit();
		if (lx > ly)
			swap(lx, ly), swap(rx, ry);
		if (ry < rx)
		{
			Lx = max(Lx, lx);
			Rx = min(Rx, rx);
			Ly = max(Ly, lx);
			Ry = min(Ry, rx);
			a.push_back(make_pair(ly, ry));
		}
		else
		{
			Lx = max(Lx, lx);
			Rx = min(Rx, rx);
			Ly = max(Ly, ly);
			Ry = min(Ry, ry);
		}
	}
	a.push_back(make_pair(-1, -1));
	sort(a.begin(), a.end());
	int n = a.size() - 1;
	b[0] = make_pair(0, Sr);
	c[n + 1] = make_pair(0, Sr);
	for (int i = 1; i <= n; ++ i)
	{
		b[i].first = max(b[i - 1].first, a[i].first);
		b[i].second = min(b[i - 1].second, a[i].second);
	}
	for (int i = n; i; -- i)
	{
		c[i].first = max(c[i + 1].first, a[i].first);
		c[i].second = min(c[i + 1].second, a[i].second);
	}
	for (int i = 0; i <= n; ++ i)
	{
		int lx = max(Lx, b[i].first), rx = min(Rx, b[i].second);
		int ly = max(Ly, c[i + 1].first), ry = min(Ry, c[i + 1].second);
		check(lx, rx, ly, ry);
	}
	quit();

	return 0;
}