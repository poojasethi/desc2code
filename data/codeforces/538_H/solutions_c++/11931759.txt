#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pii pair<int,int>
#define pll pair<ll,ll>
#define pdd pair<double,double>
#define X first
#define Y second
#define REP(i,a) for(int i=0;i<a;++i)
#define REPP(i,a,b) for(int i=a;i<b;++i)
#define FILL(a,x) memset(a,x,sizeof(a))
#define	foreach( gg,itit )	for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )
#define	mp make_pair
#define	pb push_back
#define sz(a) int((a).size())
#define all(a)  a.begin(), a.end()
#define	debug(ccc)	cout << #ccc << " = " << ccc << endl;
#define present(c,x) ((c).find(x) != (c).end())
const double eps = 1e-8;
#define EQ(a,b) (fabs((a)-(b))<eps)
inline int max(int a,int b){return a<b?b:a;}
inline int min(int a,int b){return a>b?b:a;}
inline ll max(ll a,ll b){return a<b?b:a;}
inline ll min(ll a,ll b){return a>b?b:a;}
const int mod = 1e9+7;
const int N = 1e5+10;
const ll inf = 1e18;
const int MAXT=N;
ll fl(ll x, ll y) {
    if (x >= 0) return x / y;	return x / y - (x % y ? 1 : 0);
}
ll cl(ll x, ll y) {
    if (x >= 0) return (x + y - 1) / y;    return x / y;
}
int L[N],R[N];
pii conf[N];
set <int> S;
vector <int> V,fG[20*N],rG[20*N],ord;
int vis[20*N],comp[20*N];

void dfs_ord(int i){
	if(vis[i])	return;
	vis[i]=1;
	REP(j,fG[i].size())	dfs_ord(fG[i][j]);
	ord.pb(i);
}

void addEdge(int u,int v){
	//printf("%d %d\n",u,v);
	fG[u].pb(v);
	fG[v^1].pb(u^1);
	rG[v].pb(u);
	rG[u^1].pb(v^1);
}

void dfs_mark(int v, int c) {
    if (vis[v]) return;
    vis[v] = 1;
    comp[v] = c;
    REP(j,rG[v].size()) dfs_mark(rG[v][j], c);
}

int val(int i){
	return comp[i]>comp[i+1];
}

int main(){
	int t,T;
	scanf("%d %d",&t,&T);
	int n,m;scanf("%d %d",&n,&m);
	REP(i,n)	scanf("%d %d",&L[i],&R[i]);
	REP(i,m){
		scanf("%d %d",&conf[i].X,&conf[i].Y);
		conf[i].X--;conf[i].Y--;
	}
	S.insert(0);
	S.insert(t);
	S.insert(T);
	REP(i,n){
		if(L[i]<T)
			S.insert(L[i]);
		else if(L[i]>T){
			printf("IMPOSSIBLE\n");return 0;
		}
		if(R[i]<T)
			S.insert(R[i]);
		if(L[i]<t)	S.insert(t-L[i]);
		if(R[i]<t)	S.insert(t-R[i]);
	}
	foreach(S,it){
		V.pb(*it);
	}
/*	 for(int i=0;i<V.size();i++){
        printf("%d ",V[i]);
    }
    printf("\n");
*/	S.clear();


	int K = V.size();
    int off1 = 0, off2 = 2 * K, off3 = 4 * K;
    //int V1 = off3 + 2 * N;
   // assert(V <= MAXT);
    int j = K - 1;
    REP(i, K - 1) {
        addEdge(off1 + 2 * i, off1 + 2 * (i + 1));
        addEdge(off2 + 2 * i, off2 + 2 * (i + 1));
    }
    REP(i, K - 1) {
        while (j >= 0 && V[i + 1] + V[j] > T) --j;
        if (j < 0) break;
        addEdge(off1 + 2 * i + 1, off2 + 2 * j);
        addEdge(off2 + 2 * i + 1, off1 + 2 * j);
    }
    addEdge(off1 + 2 * K - 1, off1 + 2 * K - 2);
    addEdge(off2 + 2 * K - 1, off2 + 2 * K - 2);
    j = K - 1;
    REP(i, K) {
        while (j >= 0 && V[i] + V[j] >= t) --j;
        if (j < 0) break;
//        cerr << v[i] << " => !" << v[j] << '\n';
        addEdge(off1 + 2 * i, off2 + 2 * j + 1);
        addEdge(off2 + 2 * i, off1 + 2 * j + 1);
    }
    REP(i, n) {
        int j = (upper_bound(all(V), R[i]) - V.begin()) - 1;
        assert(j >= 0);
//        cerr << "p" << i << " => " << v[j] << '\n';
        addEdge(off3 + 2 * i, off1 + 2 * j);
        addEdge(off3 + 2 * i + 1, off2 + 2 * j);

        j = (lower_bound(all(V), L[i]) - V.begin()) - 1;
        if (j < 0) continue;
//        cerr << "!p" << i << " => !" << v[j] << '\n';
        addEdge(off3 + 2 * i, off1 + 2 * j + 1);
        addEdge(off3 + 2 * i + 1, off2 + 2 * j + 1);
    }
    REP(i, m) {
        int x = conf[i].X, y = conf[i].Y;
        addEdge(off3 + 2 * x, off3 + 2 * y + 1);
        addEdge(off3 + 2 * x + 1, off3 + 2 * y);
    }


	int V1=off3+2*n;
	REP(i,V1){
			dfs_ord(i);
	}
	reverse(all(ord));
	memset(vis,0,sizeof(vis));
	int cc=1;
	REP(i,ord.size()){
//		printf("%d ",ord[i]);
		if(vis[ord[i]])	continue;
		dfs_mark(ord[i],cc++);
	}
//	printf("\n");

	bool ok= true;
	REP(i,V1/2)	ok &= (comp[2*i]!=comp[2*i+1]);
	if(!ok){
		printf("IMPOSSIBLE\n");return 0;
	}
	printf("POSSIBLE\n");
	int A=0,B=0;
	REP(i,K){
		if(val(off1+2*i)==1){
			A=V[i];break;
		}
	}
	REP(i,K){
		if(val(off2+2*i)==1){
			B=V[i];break;
		}
	}
	printf("%d %d\n",A,B);
	REP(i,n){
		if(val(off3+2*i)==1){
			printf("1");
		}else	printf("2");
	}
	printf("\n");
  return 0;
}
