#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <vector>
using namespace std;

#define maxN 100050
#define maxM 100050
#define maxtot (maxN * 9 * 2)
#define maxedge (maxN * 30)

int t, T, N, M;
int L[maxN], R[maxN];
struct Tconflict {int x, y;} Conf[maxM];
int que[maxtot];

namespace two_sat
{
    int N, now, H[maxtot];
    struct Tedge
    {
        int id, nxt;
    } edge[maxedge * 2];
    bool ans[maxtot];
    
    int other(int x)
    {
        return (x <= N) ? (x + N) : (x - N);
    }
    
    void init(int _N)
    {
        N = _N;
        now = 0;
    }
    void add(int a, int b)
    {
        ++now;
        edge[now].id = b;
        edge[now].nxt = H[a];
        H[a] = now;
        
        //printf("%d --> %d\n", a, b);
    }
    void addedge(int i, int f, int j, int g)
    {
        add(i + f*N, j + g*N);
        add(j + (g^1) * N, i + (f^1) * N);
        
        //printf("%d,%d --> %d,%d\n", i, f, j, g);
    }
    
    bool vis[maxtot];
    int nowt, nows, T[maxtot], cmp[maxtot];
    /*void dfs(int now)
    {
        if (vis[now]) return ;
        vis[now] = true;
        for (int tmp = H[now]; tmp; tmp = edge[tmp].nxt) dfs(edge[tmp].id);
        T[++nowt] = now;
    }*/
    
    /*void rdfs(int now)
    {
        if (cmp[now]) return;
        cmp[now] = nows;
        for (int tmp = H[other(now)]; tmp; tmp = edge[tmp].nxt) 
            rdfs(other(edge[tmp].id));
    }*/
    
    int st[maxtot], it[maxtot];
    void dfs(int x)
    {
        int top = 1;
        st[1] = x;
        it[1] = H[ x ];
        while (top)
        {
            int now = st[top], &tmp = it[top];
            vis[now] = true;
            if (tmp == 0) { T[++nowt] = now; --top; continue;}
            int id = edge[tmp].id;
            tmp = edge[tmp].nxt;
            if (vis[id]) continue;
            st[ ++ top] = id;
            it[top] = H[ id ];
        }
    }
    
    void rdfs(int x)
    {
        int top = 1;
        st[1] = x;
        it[1] = H[ other(x) ];
        while (top)
        {
            int now = st[top], &tmp = it[top];
            cmp[now] = nows;
            if (tmp == 0) { --top; continue; }
            int id = other(edge[tmp].id);
            tmp = edge[tmp].nxt;
            if (cmp[id]) continue;
            ++top;
            st[top] = id;
            it[top] = H[ other(id) ];
        }
    }
    
    bool work()
    {
        memset(vis, false, sizeof(vis));
        nowt = 0;
        for (int i = 1; i <= N+N; ++i) if (!vis[i]) dfs(i);
        memset(cmp, 0, sizeof(cmp));
        nows = 0;
        for (int i = N+N; i >= 1; --i)
            if (cmp[ T[i] ] == 0) { ++nows; rdfs(T[i]); }
        for (int i = 1; i <= N; ++i)
            if (cmp[i] == cmp[i+N]) return false;
        for (int i = 1; i <= N; ++i)
            ans[i] = (cmp[i] < cmp[i+N]);
        return true;
    }
    
    bool ask(int x) {return ans[x];}
}

int main()
{
    scanf("%d%d%d%d", &t, &T, &N, &M);
    for (int i=1; i<=N; ++i) scanf("%d%d", L+i, R+i);
    for (int i=1; i<=M; ++i) scanf("%d%d", &Conf[i].x, &Conf[i].y);
    
    int ztot = 0;
    que[ ++ztot ] = 0;
    que[ ++ztot ] = t;
    que[ ++ztot ] = T;
    for (int i=1; i<=N; ++i)
    {
        que[ ++ztot ] = (L[i]);
        que[ ++ztot ] = (R[i]);
        if (L[i] < t) que[ ++ztot ] = (t - L[i]);
        if (R[i] < t) que[ ++ztot ] = (t - R[i]);
    }
    
    sort(que+1, que+ztot+1);
    ztot = unique(que+1, que+ztot+1) - que - 1;
    
    two_sat :: init(ztot * 2 + N);
    #define z(i,j) ((j) + (i)*ztot)
    #define w(i) ((i) + ztot*2)
    for (int i = 1; i < ztot; ++i)
    {
        two_sat :: addedge( z(0,i), 1, z(0,i+1), 1 );
        two_sat :: addedge( z(1,i), 1, z(1,i+1), 1 );
    }
    for (int i = 1, j = ztot; i <= ztot; ++i)
    {
        if (que[i] >= t) break;
        while ( j && que[j] >= t-que[i] ) --j;
        two_sat :: addedge( z(0,i), 1, z(1,j), 0 );
        two_sat :: addedge( z(1,i), 1, z(0,j), 0 );
    }
    for (int i = 1, j = ztot; i <= ztot; ++i)
    {
        if (que[i] >= T) 
        {
            two_sat :: addedge( z(0,i), 0, z(0,i), 1 );
            two_sat :: addedge( z(1,i), 0, z(1,i), 1 );
            continue;
        }
        while ( j && que[j] > T - que[i+1]) --j;
        two_sat :: addedge( z(0,i), 0, z(1,j), 1 );
        two_sat :: addedge( z(1,i), 0, z(0,j), 1 );
    }
    for (int i=1; i <= N; ++i)
    {
        int idL = lower_bound(que+1, que+ztot+1, L[i]) - que - 1,
            idR = lower_bound(que+1, que+ztot+1, R[i]) - que;
        if (idL > 0) 
        {
            two_sat :: addedge( w(i), 1, z(0, idL), 0 );
            two_sat :: addedge( w(i), 0, z(1, idL), 0 );
        }
        two_sat :: addedge( w(i), 1, z(0, idR), 1);
        two_sat :: addedge( w(i), 0, z(1, idR), 1);
    }
    for (int i=1; i <= M; ++i) 
    {
        int x = Conf[i].x, y = Conf[i].y;
        two_sat :: addedge( w(x), 1, w(y), 0 );
        two_sat :: addedge( w(x), 0, w(y), 1 );
    }
    
    if (!two_sat :: work()) puts("IMPOSSIBLE");
        else
        {
            puts("POSSIBLE");
            int n0 = 1, n1 = 1;
            while (! two_sat :: ask( z(0,n0))) ++n0;
            while (! two_sat :: ask( z(1,n1))) ++n1;
            n0 = que[n0];
            n1 = que[n1];
            printf("%d %d\n", n0, n1);
            for (int i=1; i<=N; ++i) putchar(2 - two_sat :: ask(w(i)) + '0');
            putchar('\n');
            //for (int i=1; i <= ztot; ++i) putchar(two_sat :: ask(z(0,i)) + '0');
        }
    
    return 0;
}