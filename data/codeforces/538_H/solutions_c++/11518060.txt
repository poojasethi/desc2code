#include <cstdio>
#include <iostream>
#include <cstdlib>
#include <cmath>
#include <cassert>
#include <cstring>
#include <algorithm>
#include <string>
#include <vector>
#include <list>
#include <set>
#include <map>
#include <sstream>
using namespace std;
#pragma comment(linker, "/STACK:255000000")

typedef long long ll;

#define rep(i, a, b) for(i = (a); i < (b); ++i)
#define repb(i, a, b) for(i = (a) - 1; i >= (b); --i)
#define repd(i, a, b, d) for(i = (a); i < (b); i += (d))
#define repbd(i, a, b, d) for(i = (a) - 1; i >= (b); i -= (d))
#define reps(i, s) for(i = 0; (s)[i]; ++i)
#define repl(i, l) for(i = l.begin(); i != l.end(); ++i)

#define in(f, a) scanf("%"#f, &(a))

bool firstout = 1;

#define out(f, a) printf("%"#f, (a))
#define outf(f, a) printf((firstout) ? "%"#f : " %"#f, (a)), firstout = 0
#define nl printf("\n"), firstout = 1

#define all(x) (x).begin(),(x).end()
#define sqr(x) ((x) * (x))
#define mp make_pair

template<class T>
T &minn(T &a, T b)
{
    if(b < a) a = b;
    return a;
}

template<class T>
T &maxx(T &a, T b)
{
    if(a < b) a = b;
    return a;
}

#define inf 1012345678
#define eps 1e-9


#ifdef XDEBUG
#define mod 23
#else
#define mod 1000000007
#endif

int &madd(int &a, int b)
{
    a += b;
    if(a >= mod) a -= mod;
    return a;
}

int &msub(int &a, int b)
{
    a -= b;
    if(a < 0) a += mod;
    return a;
}

int &mmult(int &a, int b)
{
    return a = (ll)a * b % mod;
}

int mdiv(ll a, ll b, ll m)
{
    a = (a % m + m) % m;
    b = (b % m + m) % m;
    if(a % b == 0) return a / b;
    return (a + m * mdiv(-a, m, b)) / b;
}

#define N 101234
#define M 1012

int n, m, q;
vector<int> A[N];
int L[N], R[N];
int B[N];
int P[N];
int PP[N];
pair<pair<pair<int, int>, pair<int, int> >, int>  Q[N], QQ[N];
int U[N];

int mn, mx;
int mnn, mxx;

bool dfs(int i, int p, int b) {
    B[i] = b;
    P[i] = p;
    if (b) {
        maxx(mnn, L[i]);
        minn(mxx, R[i]);
    } else {
        maxx(mn, L[i]);
        minn(mx, R[i]);
    }
    int j, k;
    rep (k, 0, A[i].size()) {
        j = A[i][k];
        if (B[j] < 0) dfs(j, p, !b);
        if (B[j] == B[i]) return 0;
    }
    return 1;
}

int main()
{
#ifdef XDEBUG
    freopen("in.txt", "rt", stdin);
#else
#endif

    int i, j, k;
    char c;
    int a, d;
    int t, tt;

    int ts;
#if 0
	int tss;
	in(d, tss);
	rep(ts, 1, tss + 1)
#else
    for(ts = 1; in(d, t) > 0; ++ts)
#endif
    {
        in(d, tt);
        in(d, n); in(d, m);
        rep (i, 0, n) A[i].clear();
        rep (i, 0, n) in(d, L[i]), in(d, R[i]);
        rep (k, 0, m) {
            in(d, i); in(d, j);
            --i; --j;
            A[i].push_back(j);
            A[j].push_back(i);
        }
        rep (i, 0, n) B[i] = -1, P[i] = i, PP[i] = U[i] = 0;
        m = 0;
        rep (i, 0, n) if (B[i] < 0) {
                mn = mnn = 0;
                mx = mxx = tt;
                if (!dfs(i, i, 0)) break;
                if (mn > mx || mnn > mxx) break;
                Q[m++] = mp(mp(mp(mn, mx), mp(mnn, mxx)), i);
            }
        if (i < n) out(s, "IMPOSSIBLE"), nl;
        else {
            rep (i, 0, m) if (Q[i].first.first.first <= Q[i].first.second.first && Q[i].first.second.second <= Q[i].first.first.second) {
                    swap(Q[i].first.first, Q[i].first.second);
                    PP[Q[i].second] ^= 1;
                }
            rep (i, 0, m) {
                QQ[i] = Q[i];
                swap(QQ[i].first.first.first, QQ[i].first.first.second);
                swap(QQ[i].first.second.first, QQ[i].first.second.second);
            }
            sort(Q, Q + m);
            sort(QQ, QQ + m);
            reverse(QQ, QQ + m);
            int l1 = 0, l2 = 0;
            int r1 = tt, r2 = tt;
            rep (i, 0, m) if (!U[Q[i].second] && Q[i].first.first.first <= Q[i].first.second.first &&
                        Q[i].first.first.second <= Q[i].first.second.second) {
                    U[Q[i].second] = 1;
                    maxx(l1, Q[i].first.first.first);
                    minn(r1, Q[i].first.first.second);
                    maxx(l2, Q[i].first.second.first);
                    minn(r2, Q[i].first.second.second);
                }
            rep (i, 0, m) if (!U[Q[i].second] && Q[i].first.first.first >= Q[i].first.second.first &&
                              Q[i].first.first.second >= Q[i].first.second.second) {
                    U[Q[i].second] = 1;
                    PP[Q[i].second] ^= 1;
                    maxx(l2, Q[i].first.first.first);
                    minn(r2, Q[i].first.first.second);
                    maxx(l1, Q[i].first.second.first);
                    minn(r1, Q[i].first.second.second);
                }
            rep (i, 0, m) if (!U[Q[i].second]) break;
            rep (j, 0, m) if (!U[QQ[j].second]) break;
            for (; i < m || j < m;) {
                int p = 0;
                if (Q[i].first.first.first > tt - QQ[j].first.first.first) p = 1;
                if (p == 0 && Q[i].first.first.first > r1) p = 1;
                if (p && QQ[j].first.first.first < l2) p = 0;
                if (p) {
                    U[QQ[j].second] = 1;
                    PP[QQ[j].second] ^= 1;
                    maxx(l2, QQ[j].first.first.second);
                    minn(r2, QQ[j].first.first.first);
                    maxx(l1, QQ[j].first.second.second);
                    minn(r1, QQ[j].first.second.first);
                } else {
                    U[Q[i].second] = 1;
                    maxx(l1, Q[i].first.first.first);
                    minn(r1, Q[i].first.first.second);
                    maxx(l2, Q[i].first.second.first);
                    minn(r2, Q[i].first.second.second);
                }
                rep (i, i, m) if (!U[Q[i].second]) break;
                rep (j, j, m) if (!U[QQ[j].second]) break;
            }
            if (l1 > r1 || l2 > r2 || l1 + l2 > tt || r1 + r2 < t) out(s, "IMPOSSIBLE"), nl;
            else {
                out(s, "POSSIBLE"), nl;
                int a = l1;
                int b = l2;
                if (a + b < t) b = t - a;
                if (b > r2) a += b - r2, b = r2;
                outf(d, a); outf(d, b); nl;
                rep (i, 0, n) out(d, (B[i] ^ PP[P[i]]) + 1);
                nl;
            }
        }
    }

    return 0;
}
