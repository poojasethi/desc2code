#include <cstdio>
#include <cstring>
#include <deque>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>

using namespace std;

typedef pair<int, int> pii;

const int N = 1010;

const int dx[] = {1, -1, 0, 0};
const int dy[] = {0, 0, 1, -1};

int n, m, a[N][N];
int sx, sy;
int flag[N][N];

inline bool in_range(int x, int y){
    return x >= 1 and x <= n and y >= 1 and y <= m;
}
inline bool can(int x, int y, int xx, int yy, int target){
    if(x > xx) swap(x, xx);
    if(y > yy) swap(y, yy);
    return a[xx][yy] - a[x - 1][yy] - a[xx][y - 1] + a[x - 1][y - 1] == target;
}
bool check(int step){
    int odd_cnt = 0;
    int sum = 2;
    queue<pii> Q;
    Q.push(make_pair(sx, sy));
    flag[sx][sy] = step;
    while(Q.size()){
        int x = Q.front().first, y = Q.front().second;
        Q.pop();
        int cnt = 0;
        for(int i = 0; i < 4; ++i){
            int ox = x + dx[i] * step, oy = y + dy[i] * step;
            // cout << ox << ' ' << oy << endl;
            if(!in_range(ox, oy)) continue;
            if(!can(ox, oy, x, y, step + 1)) continue;
            sum += step - 1;
            cnt ++;
            
            if(flag[ox][oy] != step){
                flag[ox][oy] = step;
                Q.push(make_pair(ox, oy));
                sum += 2;
            }
        }
        if(cnt & 1) odd_cnt ++;
    }
    if(sum != a[n][m] * 2) return false;
    if(odd_cnt != 0 and odd_cnt != 2) return false;
    
    return true;
}
int main() {
    scanf("%d %d", &n, &m);
    sx = sy = -1;
    for(int i = 1; i <= n; ++i)
        for(int j = 1; j <= m; ++j){
            scanf("%d", &a[i][j]);
            if(a[i][j] == 1 and sx == -1) sx = i, sy = j;
            a[i][j] += a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1];
        }
    if(a[n][m] == 1){
        puts("-1");
        return 0;
    }
    memset(flag, -1, sizeof(flag));
    bool find_ans = false;
    for(int i = 2; i <= n; ++i)
        if(check(i)) find_ans = 1, printf("%d ", i);
    if(!find_ans) puts("-1");
    return 0;
}