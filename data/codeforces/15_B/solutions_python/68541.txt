#!/usr/bin/env python
# -*- coding:utf-8 -*-
#

from math import fabs

def readint(): return int(raw_input())
def readfloat(): return float(raw_input())
def readarray(N, foo):
        res = []
        for _ in xrange(N):
                res.append(foo())
        return res
def readlinearray(foo): return map(foo, raw_input().split())

def is_inside_board(n, m, (x, y)):
    return  0 <= x < n and  0 <= y < m

X = 0
Y = 1

#def n_cells(n, m, x1, y1, x2, y2):
#    board = [ [False for x in xrange(n)] for y in xrange(m)]
#    
#    l1, l2 = (y1, x1), (y2, x2) #BUG was here <---
#    l1, l2 = (x1, y1), (x2, y2)
#    
#    minx = min(l1[X], l2[X])
#    miny = min(l1[Y], l2[Y])
#    
#    l1 = l1[X] - minx, l1[Y] - miny
#    l2 = l2[X] - minx, l2[Y] - miny
#    
#    for y in xrange(m):
#        for x in xrange(n):
#            if not is_inside_board(n, m, (x+l1[X], y+l1[Y])) or not is_inside_board(n, m, (x+l2[X], y+l2[Y])):
#                break
#            board[y + l1[Y]][x + l1[X]] = True
#            board[y + l2[Y]][x + l2[X]] = True
#    
#    r = 0
#    for y in xrange(m):
#        for x in xrange(n):
#            if not board[y][x]:
#                r += 1
#
#    return r

abs = lambda v : int(fabs(v))

def get_max_right_move(n, m, p):
    return n - p[X]

def get_max_bottom_move(n, m, p):
    return m - p[Y]

def get_rect_move(n, m, cp, op):
    ptl = p_top_left = (cp[X] - min(cp[X], op[X]) + 1, cp[Y] - min(cp[Y], op[Y]) + 1)
    pbr = p_bottom_right = (cp[X] + min(get_max_right_move(n, m, cp), get_max_right_move(n, m, op)), cp[Y] + min(get_max_bottom_move(n, m, cp), get_max_bottom_move(n, m, op)))
    return (ptl, pbr)

def get_total_area(n, m):
    return n * m

def get_intersect_rect((ptl1, pbr1), (ptl2, pbr2)):
    
    projXaxis1 = ptl1[X], pbr1[X]
    projXaxis2 = ptl2[X], pbr2[X]
    projXaxis1, projXaxis2 = sorted((projXaxis1, projXaxis2)) 
    overlap_x = projXaxis2[0] <= projXaxis1[1]

    projYaxis1 = ptl1[Y], pbr1[Y]
    projYaxis2 = ptl2[Y], pbr2[Y]
    projYaxis1, projYaxis2 = sorted((projYaxis1, projYaxis2)) 
    overlap_y = projYaxis2[0] <= projYaxis1[1]
    
    if not overlap_x or not overlap_y: return None
    
    ptl = projXaxis2[0], projYaxis2[0]
    pbr = projXaxis1[1], projYaxis1[1]

    return ptl, pbr 

assert get_intersect_rect(((1,2),(3,4)), ((5,1),(6,8))) is None
assert get_intersect_rect(((5,1),(6,8)), ((1,2),(3,4))) is None

def get_area(rect):
    if rect is None: return 0
    ptl, pbr = rect
    return (pbr[X] - ptl[X] + 1) * (pbr[Y] - ptl[Y] + 1)

def n_cells(n, m, x1, y1, x2, y2):

    p1 = (x1, y1)
    p2 = (x2, y2)
    
    p1, p2 = sorted((p1, p2))
    
    rect_move_p1 = get_rect_move(n, m, p1, p2)
    rect_move_p2 = get_rect_move(n, m, p2, p1)
    
    total_area = get_total_area(n, m)
    intersect_rect = get_intersect_rect(rect_move_p1, rect_move_p2)
    return total_area - (get_area(rect_move_p1) + get_area(rect_move_p1) - get_area(intersect_rect))

#You are to find the amount of cells of the field on which the chocolate can't be melted in the given conditions.
if __name__ == '__main__':
    t = readint()
    
    for _ in xrange(t):
        n, m, x1, y1, x2, y2 = readlinearray(int)
        print n_cells(n, m, x1, y1, x2, y2)