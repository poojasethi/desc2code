#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
using namespace std;
#define NN (26+26+10)
#define N (NN*NN)
#define M 400010
vector<int> graph[N];
int toVertex(char c)
{
	if(c>='a'&&c<='z')return c-'a';
	if(c>='A'&&c<='Z')return c-'A'+26;
	return c-'0'+26*2;
}
char toChar(int v)
{
	if(v>=26*2)return '0'+v-26*2;
	if(v>=26)return 'A'+v-26;
	return 'a'+v;
}
int indeg[N],outdeg[N];
int ans[M];
int anscnt=0;
void dfs(int u)
{
	//使用出度来判重,保证下次DFS的时候不会继续DFS下一层
	while(outdeg[u])dfs(graph[u][--outdeg[u]]);
	ans[anscnt++]=u%NN;
}
int main()
{
	int n;
	cin>>n;
	int baks;
	for(int i=0;i<n;i++)
	{
		string s;
		cin>>s;
		int a=toVertex(s[0]),
			b=toVertex(s[1]),
			c=toVertex(s[2]);
		int u=a*NN+b,
			v=b*NN+c;
		baks=u;
		graph[u].push_back(v);
		outdeg[u]++;
		indeg[v]++;
	}
	int s=-1,t=-1;
	for(int i=0;i<N;i++)
	{
		switch(outdeg[i]-indeg[i])
		{
			case 1:
				if(~s)goto fail;
				s=i;
				break;
			case -1:
				if(~t)goto fail;
				t=i;
			case 0:
				break;
			default:
				goto fail;
		}
	}
	if(!~s)s=baks;
	dfs(s);
	ans[anscnt++]=s/NN;
	if(anscnt==n+2)
	{
		cout<<"YES"<<endl;
		for(int i=anscnt-1;~i;i--)cout<<toChar(ans[i]);
		cout<<endl;
		return 0;
	}
fail:
	cout<<"NO"<<endl;
	return 0;
}