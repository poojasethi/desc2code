#! /Library/Frameworks/Python.framework/Versions/Current/bin/python

P = 1000000007

def eGCD(a,b):
	r = a % b
	if r == 0:
		return [b,1,1 - a/b]
	else:
		nextIter = eGCD(b,r)
		return [nextIter[0],nextIter[2],nextIter[1] - nextIter[2]*(a/b)]

def invModP(x):
	return eGCD(P,x)[2] % P

inp = raw_input().split()

n = int(inp[0])
m = int(inp[1])

switchedOn = [int(inp) for inp in raw_input().split()]

switchedOn = sorted(switchedOn)
switchedOn = [0] + switchedOn + [n+1]

offSegments = []
sumSegments = 0
curLight = -1

for nextLight in switchedOn:
	if not(nextLight == curLight + 1):
		offSegments += [nextLight - curLight - 1]
		sumSegments += nextLight - curLight - 1
	curLight = nextLight

skipFirst = (switchedOn[1] != 1)
skipLast = (switchedOn[m] != n)

numWays = 1

for i in range(1,sumSegments+1):
	numWays *= i
	numWays %= P

for i in range(sumSegments - len(offSegments)):
	numWays *= 2
	numWays %= P

if (skipFirst):
	for i in range(offSegments[0] - 1):
		numWays *= invModP(2)
		numWays %= P

if (skipLast):
	for i in range(offSegments[-1] - 1):
		numWays *= invModP(2)
		numWays %= P

for a in offSegments:
	for i in range(1,a+1):
		numWays *= invModP(i)
		numWays %= P

print numWays
