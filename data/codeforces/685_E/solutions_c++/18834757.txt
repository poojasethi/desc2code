#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iostream>
#include <vector>

#define i64 long long

#define REP(i, x, y) for (int i = (x), _ = (y); i < _; ++ i)
#define rep(i, x, y) for (int i = (y) - 1, _ = (x); i >= _; -- i)

template <typename T> inline bool Chkmax(T &x, T y) { return x < y? x = y, true : false; }
template <typename T> inline bool Chkmin(T &x, T y) { return y < x? x = y, true : false; }

namespace Main
{
    const int MAXN = 1e3 + 1e2, MAXM = 2e5 + 2e4, MAXQ = 2e5 + 2e4;

    int n, m, q;

    std::vector<int> to[MAXM];

    int ans[MAXQ];
    int dis[MAXN][MAXN];
    
    struct Edge
    {
        int u, v;
        Edge(int u = 0, int v = 0):
            u(u), v(v) {}
    } G[MAXM];

    struct Query
    {
        int l, r, s, t, id;
        Query() {}
        Query(int l, int r, int s, int t, int id):
            l(l), r(r), s(s), t(t), id(id) {}
    } Q[MAXQ];

    void Update(int u, int v, int w)
    {
        dis[u][v] = dis[v][u] = w;
        REP (i, 1, n + 1)
            dis[u][i] = dis[v][i] = std::min(dis[u][i], dis[v][i]);
    }
    
    void Solve()
    {
        rep (i, 1, m + 1) {
            Update(G[i].u, G[i].v, i);
            REP (j, 0, to[i].size()) {
                int s = to[i][j];
                ans[Q[s].id] = (dis[Q[s].s][Q[s].t] <= Q[s].r);
            }
        }

        REP (i, 0, q)
            puts(ans[i]? "Yes" : "No");
    }
    
    void Input()
    {
        int u, v;
        int l, r, s, t;
        
        scanf("%d%d%d", &n, &m, &q);
        
        REP (i, 1, m + 1) {
            scanf("%d%d", &u, &v);
            G[i] = Edge(u, v);
        }

        REP (i, 0, q) {
            scanf("%d%d%d%d", &l, &r, &s, &t);
            Q[i] = Query(l, r, s, t, i);
            to[l].push_back(i);
        }
    }

    void Init()
    {
        memset(dis, 0x3f, sizeof(dis));
    }
    
    void Exec()
    {
        Init();
        Input();
        Solve();
    }
}

int main()
{
    if (fopen("E.in", "r") != NULL) {
        freopen("E.in", "r", stdin);
        freopen("E.out", "w", stdout);
    }

    Main::Exec();

    return 0;
}
