#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
#define x first
#define y second
#define mp make_pair
#define  REP(i, j, k) for(int i = (j); i <= (k); ++i)
#define REPD(i, j, k) for(int i = (j); i >= (k); --i)

const int maxn = 1100;
const int maxm = 200100;

int n, m, Q;
pair<int,int> E[maxm];
struct ques
{
	int id, l, r, s, t;
	ques(int id=0,int l=0,int r=0,int s=0,int t=0):id(id),l(l),r(r),s(s),t(t){}
	bool operator <(const ques a) const
	{
		return l < a.l;
	}
}que[maxm];

void init()
{
	scanf("%d%d%d", &n, &m, &Q);
	REP(i,1,m)
		scanf("%d%d", &E[i].x, &E[i].y);
	REP(i,1,Q)
	{
		int l,r,s,t;
		scanf("%d%d%d%d",&l,&r,&s,&t);
		que[i]=ques(i,l,r,s,t);
	}
	sort(que+1,que+Q+1);
}

int last[maxn][maxn];
int ans[maxm];
void solve()
{
	int cnt = Q;
	REP(i,1,n)
		REP(j,1,n)
			last[i][j] = m+1;
	REPD(i,m,1)
	{
		int u = E[i].x, v = E[i].y;
		last[u][v] = last[v][u] = i;
		REP(t,1,n)
			if(last[u][t] < last[v][t]) last[v][t] = last[u][t];
			else last[u][t] = last[v][t];
		while(cnt && que[cnt].l == i)
		{
			if(last[que[cnt].s][que[cnt].t] <= que[cnt].r) ans[que[cnt].id] = 1;
			else ans[que[cnt].id] = 0;
			--cnt;
		}
	}
	REP(i,1,Q)
		printf("%s\n",ans[i]?"Yes":"No");
}

int main()
{
	init();
	solve();
	return 0;
}
