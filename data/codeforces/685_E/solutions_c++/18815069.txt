#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <bitset>
#include <vector>
#define Rep(i, x, y) for (int i = x; i <= y; i ++)
#define Dwn(i, x, y) for (int i = x; i >= y; i --)
#define ql bl[i][ tl[i] ]
#define qr br[i][ tr[i] ]
using namespace std;
typedef long long ll;
typedef double db;
const int M = 1002, N = 200005, mod = 1000000007;
int n, m, q, S[N], T[N], eu[N], ev[N], tl[N], tr[N], sl[N], sr[N], ans[N];
struct query { int x, n; };
bool operator< (query a, query b) { return a.x < b.x; }
bool cmp(query x, query y) { return y < x; }
vector<query> bl[N], br[N];
bitset<M> dp[M], p[N];
void solve(int l, int r) {
	if (l > r) return ;
	int d = (l + r) >> 1;
	Dwn(i, d, l) {
		dp[ eu[i] ] = dp[ ev[i] ] = dp[ eu[i] ] | dp[ ev[i] ];
		while (tl[i] < sl[i] && ql.x >= d) {
			p[ql.n] = dp[ S[ql.n] ];
			tl[i] ++;
		}
	}
	Rep(x, l, d) {
		int i = eu[x]; dp[i].reset(), dp[i][i] = 1;
		i = ev[x]; dp[i].reset(), dp[i][i] = 1;
	}
	Rep(i, d, r) {
		dp[ eu[i] ] = dp[ ev[i] ] = dp[ eu[i] ] | dp[ ev[i] ];
		while (tr[i] < sr[i] && qr.x <= d) {
			ans[qr.n] = !((p[qr.n] & dp[ T[qr.n] ]).none());
			tr[i] ++;
		}
	}
	Rep(x, d, r) {
		int i = eu[x]; dp[i].reset(), dp[i][i] = 1;
		i = ev[x]; dp[i].reset(), dp[i][i] = 1;
	}
	solve(l, d - 1); solve(d + 1, r);
}
int main()
{
	scanf ("%d%d%d", &n, &m, &q);
	Rep(i, 1, m) {
		scanf ("%d%d", &eu[i], &ev[i]);
	}
	Rep(i, 1, q) {
		int l, r;
		scanf ("%d%d%d%d", &l, &r, &S[i], &T[i]);
		// if (l == r) ans[i] = S[i] == T[i];
		bl[l].push_back( (query) { r, i } );
		br[r].push_back( (query) { l, i } );
	}
	Rep(i, 1, m) {
		sl[i] = bl[i].size();
		sort(bl[i].begin(), bl[i].end(), cmp);
		sr[i] = br[i].size();
		sort(br[i].begin(), br[i].end());
	}
	Rep(i, 1, n) {
		dp[i].reset(); dp[i][i] = 1;
	}
	// cout << dp[1] << endl;
	solve(1, m);
	Rep(i, 1, q) {
		puts( ans[i] ? "Yes" : "No" );
	}
	return 0;
}
