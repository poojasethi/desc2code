#include <bits/stdc++.h>
//Damned if I don't do everything it takes, damned if I don't take what I want.

using namespace std;

typedef long long ll;
typedef pair<int, int> pii;

const int MAXN = 1e5 + 100;

int cnt[26], seg[26][4 * MAXN], flag[26][4 * MAXN];

inline void relax(int seg[], int flag[], int x, int xl, int xr){
	if (flag[x] == -1) return;
	int mid = (xl + xr) / 2, l = 2 * x, r = l + 1;
	seg[l] = flag[x] * (mid - xl);
	seg[r] = flag[x] * (xr - mid);
	flag[l] = flag[r] = flag[x];
	flag[x] = -1;
}

void upd(int seg[], int flag[], int x, int xl, int xr, int ql, int qr, int q){
	if (xl >= qr || xr <= ql)  return;

	if (xl >= ql && xr <= qr){
		seg[x] = (xr - xl) * q;
		flag[x] = q;
		return;
	}

	relax(seg, flag, x, xl, xr);

	int mid = (xl + xr) / 2, l = 2 * x, r = l + 1;
	upd(seg, flag, l, xl, mid, ql, qr, q);
	upd(seg, flag, r, mid, xr, ql, qr, q);
	seg[x] = seg[l] + seg[r];
}

int get(int seg[], int flag[], int x, int xl, int xr, int ql, int qr){
	if (xl >= qr || xr <= ql) return 0;
	if (xl >= ql && xr <= qr) return seg[x];

	relax(seg, flag, x, xl, xr);

	int mid = (xl + xr) / 2, l = 2 * x, r = l + 1;
	return get(seg, flag, l, xl, mid, ql, qr) + get(seg, flag, r, mid, xr, ql, qr);
}

int n, m; 
char s[MAXN];

int main(){
	FILE *fin = fopen("input.txt", "r"), *fout = fopen("output.txt", "w");

	memset(flag, -1, sizeof flag);

	fscanf(fin, "%d%d%s", &n, &m, s);
	for (int i = 0; i < n; i++)
		upd(seg[ s[i] - 'a' ], flag[ s[i] - 'a' ], 1, 0, n, i, i + 1, 1);


	while( m-- ){
		int l, r; fscanf(fin, "%d%d", &l, &r); l--;

		int odd = 0, ind = 0;
		for (int j = 0; j < 26; j++){
			cnt[j] = get( seg[j], flag[j], 1, 0, n, l, r );
			if (cnt[j] % 2){
				odd++;
				ind = j;
			}
		}

		if (odd > 1) continue;

		for (int i = 0; i < 26; i++) if (cnt[i])
			upd(seg[i], flag[i], 1, 0, n, l, r, 0);

		int ql = 0, qr = r - l;
		
		for (int i = 0; i < 26; i++){
			int sz = cnt[i] / 2;
			if (!sz) continue;

			upd(seg[i], flag[i], 1, 0, n, l + ql, l + ql + sz, 1);
			upd(seg[i], flag[i], 1, 0, n, l + qr - sz, l + qr, 1);
			ql += sz;
			qr -= sz;
		}

		if(odd)
			upd(seg[ind], flag[ind], 1, 0, n, l + ql, l + ql + 1, 1);
	}

	for (int i = 0; i < n; i++)
		for (int j = 0; j < 26; j++)
			if (get( seg[j], flag[j], 1, 0, n, i, i + 1) ){
				s[i] = char(j + 'a');
				break;
			}

	s[n] = '\0';
	fprintf(fout, "%s", s);
}
