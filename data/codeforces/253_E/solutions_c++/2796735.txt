//By momo
#include<queue>
#include<cstdio>
#include<vector>
#include<algorithm>

#define N 50010
#define PB push_back
#define LL long long
#define INF 1000000000
#define SZ(x) (LL)((x).size())

using namespace std;

LL n, t, bst, unkid, p[N], ans[N], pnt[N];
struct task{ LL t, s, p, i; }a[N];
bool comp(task x, task y){ return x.t < y.t; }
bool operator<(task x, task y){ return x.p < y.p; }

vector<LL> canp;
priority_queue<task> que;

void solve(LL v){
	LL prv, now;
	a[unkid].p = v;
	que.push(a[0]);
	for(LL i = 1; i < n; i++){
		prv = a[i-1].t, now = a[i].t;
		while(!que.empty() && now > prv){
			task x = que.top(); que.pop();
			if(x.s-(now-prv) <= 0){
				prv += x.s;
				ans[x.i] = prv;
			}
			else{
				x.s -= (now-prv);
				prv = now, que.push(x);
			}
		}
		que.push(a[i]);
	}
	prv = a[n-1].t;
	while(!que.empty()){
		prv += que.top().s;
		ans[que.top().i] = prv; que.pop();
	}
}

int main(){
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);
	scanf("%I64d", &n);
	for(LL i = 0; i < n; i++){
		scanf("%I64d%I64d%I64d", &a[i].t, &a[i].s, &a[i].p);
		p[i] = a[i].p; a[i].i = i;
	}scanf("%I64d", &t);
	sort(p, p+n); sort(a, a+n, comp);
	for(LL i = 0; i < n; i++) if(a[i].p == -1) unkid = i;

	if(p[0] != -1 && p[0] != 1) canp.PB(p[0]-1);
	for(LL i = 1; i < n; i++)
		if(p[i] != -1 && p[i] != p[i-1]+1) canp.PB(p[i]-1);
	if(p[n-1] != -1 && p[n-1] != INF) canp.PB(p[n-1]+1);

	LL lb = 0, rb = SZ(canp);
	while(lb != rb-1){
		LL mid = (lb + rb) / 2;
		solve(canp[mid]);
		if(ans[a[unkid].i] >= t){
			lb = bst = mid;
			for(LL i = 0; i < n; i++) pnt[i] = ans[i];
		}
		else rb = mid;
	}
	printf("%I64d\n", canp[bst]);
	for(LL i = 0; i < n; i++) printf("%I64d%c", pnt[i], i == n-1?'\n':' ');
}
