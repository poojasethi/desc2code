#include<cstdio>
#include<algorithm>
#include<set>
#define long long long
#define N 200005
using namespace std;
struct data{
  int t,s,p,id;
  friend int operator < (const data &a,const data &b){return a.p>b.p;}
}a[N],b[N];set<data>Q;
int c[N],n,l,r,mid,id,i;long ans[N],T;
int cmp(const data &a,const data &b){
  return a.t<b.t||a.t==b.t&&a.p>b.p;
}
int calc(int x){
  //前x个数中有几个不合法 
  if (x>c[n-1]) return n-1;
  return upper_bound(c+1,c+n,x)-c-1;
}
int Find(int t){
  //第t个数是多少 
  int l=1,r=1e9;
  while (l<r){
    int mid=(l+r)>>1;
    int can=mid-calc(mid);
    if (can<t) l=mid+1;else r=mid;
  }return l;
}
int check(){
  for (int i=1;i<=n;i++) a[i]=b[i];
  a[n].p=Find(mid);
  sort(a+1,a+n+1,cmp);Q.clear();
  Q.insert(a[1]);data now;
  for (int i=2;i<=n;i++){
    long rest=a[i].t-a[i-1].t;
    while (!Q.empty()&&rest){
      now=*Q.begin();Q.erase(Q.begin());
      if (now.s>rest) now.s-=rest,rest=0,Q.insert(now);
      else rest-=now.s,ans[now.id]=a[i].t-rest;
    }Q.insert(a[i]);
  }long last=a[n].t;
  while (!Q.empty()){
    now=*Q.begin();Q.erase(Q.begin());
    ans[now.id]=last+now.s;
    last+=now.s;
  }return ans[id]<=T;
}
int main(){
    freopen("input.txt","r",stdin);
    freopen("output.txt","w",stdout);
  scanf("%d",&n);
  for (i=1;i<=n;i++)
    scanf("%d%d%d",&b[i].t,&b[i].s,&b[i].p),b[i].id=i;
  for (i=1;i<=n;i++)
    if (b[i].p==-1) id=i;
  swap(b[id],b[n]);
  for (i=1;i<n;i++) c[i]=b[i].p;
  sort(c+1,c+n);
  scanf("%I64d",&T);l=1;r=1e9-n+1;
  while (l<r){
    mid=(l+r)>>1;
    if (check()) r=mid;else l=mid+1;
  }mid=l;check();printf("%d\n",Find(l));
  for (i=1;i<=n;i++)
    printf("%I64d ",ans[i]);
}