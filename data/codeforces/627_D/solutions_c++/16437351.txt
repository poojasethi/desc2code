#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 200000 + 10;

struct Data
{
	int wen, lst, tp;
	Data() {}
	Data(int wen, int lst, int tp) : wen(wen), lst(lst), tp(tp) {}
	Data operator * (const Data &that) const {
		Data ret;
		if (that.tp) {
			ret = *this;
			ret.wen += that.wen;
			return ret;
		} else {
			ret.tp = 0;
			ret.wen = wen;
			ret.lst = max(lst, that.value());
			return ret;
		}
	}
	Data operator + (const Data &that) const {
		Data ret;
		ret.tp = tp && that.tp;
		ret.wen = wen + that.wen;
		ret.lst = max(lst, that.lst);
		return ret;
	}
	int value() const {
		return wen + lst;
	}
};

int n, k;
int a[N];
vector<int> adj[N];
int father[N];
int order[N], tot;
Data down[N], up[N];

void dfs(int u, int f)
{
	order[tot ++] = u;
	father[u] = f;
	for(int e = 0; e < adj[u].size(); ++ e) {
		int v = adj[u][e];
		if (v == f) continue;
		dfs(v, u);
	}
}

int children[N];
Data sqn[N];

int checkOk(int x)
{
	for(int i = n - 1; i >= 0; -- i) {
		int u = order[i];
		if (a[u] < x) {
			down[u] = Data(0, 0, 0);
		} else {
			down[u] = Data(1, 0, 1);
			for(int e = 0; e < adj[u].size(); ++ e) {
				int v = adj[u][e];
				if (v == father[u]) continue;
				down[u] = down[u] * down[v];
			}
		} 
	}
	if (a[0] < x) {
		up[0] = Data(0, 0, 0);
	} else {
		up[0] = Data(0, 0, 1);
	}
	for(int _ = 0; _ < n; ++ _) {
		int u = order[_];
		if (a[u] < x) {
			for(int e = 0; e < adj[u].size(); ++ e) {
				int v = adj[u][e];
				if (v == father[u]) continue;
				up[v] = Data(0, 0, 0);
			}
		} else {
			if ((down[u] * up[u]).value() >= k) {
				return true;
			}
			int cnt = 0;
			for(int e = 0; e < adj[u].size(); ++ e) {
				int v = adj[u][e];
				if (v == father[u]) continue;
				children[cnt ++] = v;
			}
			sqn[cnt] = Data(0, 0, 1);
			for(int i = cnt - 1; i >= 0; -- i) {
				sqn[i] = sqn[i + 1] * down[children[i]];
			}
			Data cur = Data(0, 0, 1);
			for(int i = 0; i < cnt; ++ i) {
				int v = children[i];
				if (a[v] < x) {
					up[v] = Data(0, 0, 0);
				} else {
					up[v] = (cur + sqn[i + 1]) * up[u];
					up[v].wen ++;
				}
				cur = cur * down[v];
			} 
		}
	}
	return false;
}

void solve()
{
	cin >> n >> k;
	for(int i = 0; i < n; ++ i) {
		scanf("%d", a + i);
	}
	for(int i = 0; i < n - 1; i ++) {
		int u, v;
		scanf("%d%d", &u, &v);
		--u, --v;
		adj[u].push_back(v);
		adj[v].push_back(u);
	}
	dfs(0, -1);
	int l = 0, r = 1000000 + 10, mid;
	for( ; l + 1 < r; ) {
		mid = (l + r) >> 1;
		if (checkOk(mid)) {
			l = mid;
		} else {
			r = mid;
		}
	}
	cout << l << endl;
}

int main()
{
	solve();
	return 0;
}
