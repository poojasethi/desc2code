#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

struct edge {
	int to,next;
} e[400005];
int n,k,num,head[200005],a[200005],f[200005],g[200005],h[200005],g_node[200005],ans,maxa,size[200005];
bool ok[200005];
inline void insert(int u,int v) {
	e[++num].to=v; e[num].next=head[u]; head[u]=num;
	e[++num].to=u; e[num].next=head[v]; head[v]=num;
}
void dfs(int now,int fa) {
	size[now]=1;
	int s=0,maxc=0,secc=0,id=0;
	for (int i=head[now];i;i=e[i].next) if (e[i].to!=fa) {
		dfs(e[i].to,now);
		size[now]+=size[e[i].to];
		if (ok[e[i].to]) {
			int ch=f[e[i].to]+g[e[i].to]+1;
			if (ch==size[e[i].to]) s+=ch;
			else if (ch>maxc) secc=maxc,maxc=ch,id=e[i].to;
			else if (ch>secc) secc=ch;
		}
	}
	if (ok[now]) {
		f[now]=s; g[now]=maxc; h[now]=secc; g_node[now]=id;
	}
}
void work(int now,int fa,int out) {
	if (ok[now]) {
		if (out==n-size[now]) f[now]+=out;
		else {
			if (out>g[now]) h[now]=g[now],g[now]=out,g_node[now]=fa;
			else if (out>h[now]) h[now]=out;
		}
		num=max(num,f[now]+g[now]+1);
		if (num>=k) return;
	}
	for (int i=head[now];i;i=e[i].next) if (e[i].to!=fa) {
		if (!ok[now]) work(e[i].to,now,0);
		else {
			if (ok[e[i].to]&&f[e[i].to]+g[e[i].to]+1==size[e[i].to]) work(e[i].to,now,f[now]-size[e[i].to]+g[now]+1);
			else if (e[i].to==g_node[now]) work(e[i].to,now,f[now]+h[now]+1);
			else work(e[i].to,now,f[now]+g[now]+1);
		}
	}
}
inline bool check(int x) {
	for (int i=1;i<=n;i++) ok[i]=a[i]>=x;
	memset(f,0,sizeof(f));
	memset(g,0,sizeof(g));
	memset(h,0,sizeof(h));
	dfs(1,0);
	num=0;
	work(1,0,0);
	return num>=k;
}
int main() {
	scanf("%d%d",&n,&k);
	for (int i=1;i<=n;i++) {
		scanf("%d",&a[i]);
		maxa=max(maxa,a[i]);
	}
	for (int i=1;i<n;i++) {
		int u,v;
		scanf("%d%d",&u,&v);
		insert(u,v);
	}
	int l=1,r=maxa;
	while (l<=r) {
		int mid=(l+r)>>1;
		if (check(mid)) ans=mid,l=mid+1; else r=mid-1;
	}
	printf("%d\n",ans);
	return 0;
}
