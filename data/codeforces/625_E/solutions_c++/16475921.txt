#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <bitset>
//#pragma comment(linker, "/STACK:1024000000,1024000000")

using namespace std;

#define ll long long
#define SZ(x) ((int)(x).size()) 
#define ALL(v) (v).begin(), (v).end()
#define foreach(i, v) for (__typeof((v).begin()) i = (v).begin(); i != (v).end(); ++ i)
#define reveach(i, v) for (__typeof((v).rbegin()) i = (v).rbegin(); i != (v).rend(); ++ i) 
#define REP(i,a,n) for ( int i=a; i<int(n); i++ )
#define FOR(i,a,n) for ( int i=n-1; i>= int(a);i-- )
#define lson rt<<1, L, m
#define rson rt<<1|1, m, R
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
#define mp(x, y) make_pair(x, y)
#define pb(x) push_back(x)
#define fi first
#define se second
const int maxn = 1e5 + 7;
const int INF = 0x3f3f3f3f;
int n, m;
struct Node{
    int p, d;
    int id;
    int up, down;
    bool operator < (const Node & t) const{
        return p < t.p;
    }
}a[maxn];
int id[maxn];
set<pii> st;
int work(int i, int j){
    int d = ((a[id[j]].p - a[id[i]].p) % m + m) % m;
    int s = a[id[i]].d - a[id[j]].d;
    if(i < j){
        if(a[id[i]].d >= d) return 1;
        if(a[id[i]].d <= a[id[j]].d) return INF;
        return (d - a[id[j]].d - 1) / s + 1;
    }
    else{
        if(a[id[i]].d <= a[id[j]].d) return INF;
        return (d - 1) / s + 1;
    }
}
int main(){
#ifdef ac
	freopen("in.txt","r",stdin);
#endif
	//freopen("out.txt","w",stdout);
    scanf("%d%d", &n, &m);
    REP(i, 0, n){
        scanf("%d%d", &a[i].p, &a[i].d);
        a[i].id = i + 1;
    }
    sort(a, a + n);
    REP(i, 0, n){
        id[a[i].id] = i;
        a[i].up = (i - 1 + n) % n;
        a[i].down = (i + 1) % n;
    } 
    REP(i, 0, n){
        st.insert(mp(work(a[i].id, a[a[i].down].id), a[i].id));
        //printf("%d %d\n", i, work(a[a[i].up].id, a[i].id));
    }
    //cout<<"-------------"<<endl;
    //for(set<pii> :: iterator it = st.begin(); it != st.end(); it ++) printf("%d %d\n", id[(*it).se], (*it).fi);
    while(!st.empty()){
        pii t = *st.begin();
        int p = t.fi, q = t.se;
        //int v = work(q, a[a[id[q]].down].id);
        int v = 0;
        st.erase(st.begin());
        st.erase(mp(work(a[a[id[q]].up].id, q), a[a[id[q]].up].id));
        //printf("%d %d %d\n", q, v, p);
        if(a[id[q]].id == -1 || a[a[id[q]].down].id == -1) continue;
        /*
        if(v != p){
            st.insert(mp(v, q));
            continue;
        }
        */
        if(p == INF){
            continue;
        }
        int x = id[q], y = a[x].down;
        a[y].id = -1;
        a[x].down = a[y].down;
        y = a[y].down;
        a[y].up = x;
        a[x].p = (a[x].p + p) % m;
        //a[x].p = (a[x].p + p * a[x].d) % m;
        //a[y].p = (a[y].p + p * a[y].d) % m;
        a[x].d --;
        v = work(a[x].id, a[y].id);
        st.insert(mp(v, a[x].id));
        x = a[x].up, y = a[y].up;
        v = work(a[x].id, a[y].id);
        st.insert(mp(v, a[x].id));
    }
    int sum = 0;
    REP(i, 0, n) if(a[i].id != -1) sum ++;
    printf("%d\n", sum);
    REP(i, 0, n) if(a[i].id != -1) printf("%d\n", a[i].id);
    return 0;
}
