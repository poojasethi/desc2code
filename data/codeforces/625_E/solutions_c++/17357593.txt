#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<set>
#include<cmath>
#include<algorithm>
#define pb push_back
#define f first
#define s second
#define mp make_pair
#define INF (int)(1e9 + 11)
using namespace std;
struct spos {
    int pos, id;
};
struct frogs {
    int event, id;
    frogs(int s1, int s2) {
        event = s1;
        id = s2;
    }
};
int n, m;
const int maxn = 100100;
int a[maxn];
int p[maxn];
spos pp[maxn];
int nxt[maxn];
int prv[maxn];
bool operator<(const frogs &lhs, const frogs &rhs) {
    if (lhs.event < rhs.event || (lhs.event == rhs.event && (lhs.id < rhs.id))) {
        return true;
    } 
    return false;
}
set<frogs> st;
bool cmd(spos a, spos b) {
    return a.pos < b.pos;
}
int calc(int i, int j) {
    if (i == j) {
        return INF;
    }
    int d = (p[j] - p[i] + m) % m;   
    int s = a[i] - a[j];
    if (i > j) {
        d = (d + a[j]) % m;
    }
    if (a[i] >= d) {
        return 1;
    }
    if (a[i] <= a[j]) {
        return INF;
    }
    return (d - a[j] + s - 1) / s;
}
int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        cin >> p[i] >> a[i];
        p[i]--;
        pp[i].pos = p[i];
        pp[i].id = i;
    }
    sort(pp, pp + n, cmd);
    for (int i = 0; i < n; i++) {
        nxt[pp[i].id] = pp[(i + 1) % n].id;
        prv[pp[(i + 1) % n].id] = pp[i].id;
    }
    for (int i = 0; i < n; i++) {
        st.insert(frogs(calc(i, nxt[i]), i));
    }
    while (!st.empty()) {
        if (st.size() == 1) break; 
        set<frogs>::iterator it = st.begin();
        if ((it -> event) == INF) {
            break;
        }
        frogs tmp = frogs((it -> event), (it -> id));
        st.erase(it);
        st.erase(frogs(calc(nxt[tmp.id], nxt[nxt[tmp.id]]), nxt[tmp.id]));
        if (nxt[tmp.id] != prv[tmp.id]) {
            st.erase(frogs(calc(prv[tmp.id], tmp.id), prv[tmp.id]));
        }
        p[tmp.id] += tmp.event;
        if (a[tmp.id] > 0) a[tmp.id]--;
        nxt[tmp.id] = nxt[nxt[tmp.id]];
        prv[nxt[tmp.id]] = tmp.id;
        if (prv[tmp.id] != tmp.id) {
            st.insert(frogs(calc(prv[tmp.id], tmp.id), prv[tmp.id]));
        }    
        st.insert(frogs(calc(tmp.id, nxt[tmp.id]), tmp.id)); 
    }
    cout << st.size() << endl;
    for (set<frogs>::iterator it = st.begin(); it != st.end(); it++) {
        cout << (it -> id) + 1 << " ";
    }
    cout << endl;
    return 0;
}
