#include<bits/stdc++.h>
#define N 1505
#define M 10000005
using namespace std;char s[M];
int fail[M],son[M][2],g[M],Link[M],Q[M],dfn[N];
int st[N],ed[N],T[N][N],b[N][N],out[N],id[N],vis[N];
int ans[N],tot=1,n,i,j,Case,ch;
void Insert(int st,int ed,int id){
    int p=1;
    for (int i=st;i<=ed;i++){
        int &t=son[p][s[i]-'a'];
        if (!t) p=t=++tot;else p=t;
  }Link[p]=id;
}
void Auto(){
    int h=0,t=0;
    for (int i=0;i<2;i++)
        if (!son[1][i]) son[1][i]=1;else fail[Q[++t]=son[1][i]]=1;
    while (h<t){
        int k=Q[++h];g[k]=Link[fail[k]]?fail[k]:g[fail[k]];
        for (int i=0;i<2;i++)   
            if (!son[k][i]) son[k][i]=son[fail[k]][i];
            else fail[Q[++t]=son[k][i]]=son[fail[k]][i];
  }
}
void Make(int st,int ed,int id){
    int p=1;
    for (int i=st;i<=ed;i++){
        p=son[p][s[i]-'a'];
        if (Link[p]) b[id][Link[p]]=1;
        for (int t=g[p];t&&dfn[Link[t]]!=id;t=g[t])
            b[id][Link[t]]=1,dfn[Link[t]]=id;
  }b[id][id]=0;
}
int DFS(int x){
    for (int i=1;i<=n;i++)
        if (b[x][i]&&vis[i]!=Case){
            vis[i]=Case;
            if (!id[i]||DFS(id[i]))
                return id[i]=x,1;
    }return 0;
}
//T[x][0]　一定是选这个点或者以上的点（所有这个点连出去的点及以下都不能选） 
//T[x][1]  一定是选这个点以上的点（这个点不选） 
void Path(int x,int y){
    if (T[x][y]) return;T[x][y]=1;
    if (y==1&&id[x]) Path(id[x],0);
    if (!y) for (int i=1;i<=n;i++)
        if (b[x][i]) Path(i,1);
}
int main(){
    scanf("%d",&n);
    for (i=1;i<=n;i++){
        st[i]=ed[i-1]+1;
        scanf("%s",s+st[i]);
        ed[i]=st[i]+strlen(s+st[i])-1;
        Insert(st[i],ed[i],i);
  }Auto();
  for (i=1;i<=n;i++)
    Make(st[i],ed[i],i);
    for (i=1;i<=n;i++)
        ++Case,DFS(i);
    for (i=1;i<=n;i++)
        if (id[i]) out[id[i]]=i;
    for (i=1;i<=n;i++)
        if (!out[i]) Path(i,0);
    for (i=1;i<=n;i++){
        ch=0;
        if (out[i]) ch|=!T[i][0];
        if (id[i])  ch|=T[i][1];
        if (!ch) ans[++*ans]=i;
  }printf("%d\n",*ans);
    for (i=1;i<=*ans;i++)
        printf("%d ",ans[i]);
}