#include<bits/stdc++.h>
using namespace std;
const int maxn=755;
const int maxm=10000005;
int n;
int st[maxn],len[maxn];
char s[maxm];
//二分图最大基数匹配
struct BPM
{
    int n,m;//左右顶点个数
    bitset<maxn> G[maxn];//邻接表
    int left[maxn];//left[i]为右边第i个点的匹配点编号，-1表示不存在
    bool T[maxn];//T[i]为右边第i个点是否已标记

    int right[maxn];//求最小覆盖用
    bool S[maxn];//求最小覆盖用

    int usex[maxn],usey[maxn],vis[maxn];//求最大独立用

    void init(int n,int m)
    {
        this->n=n;this->m=m;
        for(int i=0;i<n;i++)G[i].reset();

        memset(usex,0,sizeof(usex));
        memset(usey,0,sizeof(usey));
        memset(vis,0,sizeof(vis));
    }

    void floyd()
    {
        for(int k=0;k<n;k++)
            for(int i=0;i<n;i++)if(G[i][k])G[i]|=G[k];
    }

    bool match(int u)
    {
        S[u]=true;
        for(int v=0;v<n;v++)if(G[u][v])
        {
            if(!T[v])
            {
                T[v]=true;
                if(left[v]==-1||match(left[v]))
                {
                    left[v]=u;
                    right[u]=v;
                    return true;
                }
            }
        }
        return false;
    }

    //求最大匹配
    int solve()
    {
        memset(left,-1,sizeof(left));
        memset(right,-1,sizeof(right));
        int ans=0;
        for(int u=0;u<n;u++)//从左边结点u开始增广
        {
            memset(S,0,sizeof(S));
            memset(T,0,sizeof(T));
            if(match(u))ans++;
        }
        return ans;
    }

    //求最小覆盖。X和Y为最小覆盖中的点集
    int mincover(vector<int>& X,vector<int>& Y)
    {
        int ans = solve();
        memset(S,0,sizeof(S));
        memset(T,0,sizeof(T));
        for(int u=0;u<n;u++)if(right[u]==-1)match(u);//从所有X未盖点出发增广
        for(int u=0;u<n;u++)if(!S[u])X.push_back(u);//X中的未标记点
        for(int v=0;v<m;v++)if(T[v])Y.push_back(v);//Y中的已标记点
        return ans;
    }

    //求最大（点）独立集
    int maxindependent()
    {
        for(int i=0;i<n;i++)if(~right[i])usex[i]=1;
        while(1)
        {
            bool flag=0;
            for(int i=0;i<n;i++)if(!vis[i]&&!usex[i])
            {
                flag=1;vis[i]=1;
                for(int j=0;j<n;j++)if(G[i][j])
                    if(usey[j]==0)
                    {
                        usey[j]=1;
                        if(left[j]!=-1)usex[left[j]]=0;
                    }
            }
            if(!flag)break;
        }
        int ans=0,flag=0;
        for(int i=0;i<n;i++)if(!usex[i]&&!usey[i])ans++;
        printf("%d\n",ans);
        for(int i=0;i<n;i++)
            if(!usex[i]&&!usey[i])
            {
                if(!flag)flag=1;
                else printf(" ");
                printf("%d",i+1);
            }
        printf("\n");
    }
}solver;
const int MAXNODE=10000005;
const int SIGMA_SIZE=2;
struct AhoCorasickAutomata
{
    int ch[MAXNODE][SIGMA_SIZE];
    int f[MAXNODE];//fail函数
    int val[MAXNODE];//每个字符串的结尾结点都有一个非0的val
    int last[MAXNODE];//输出链表的下一个结点
    int sz;

    void init()
    {
        val[0]=-1;
        sz=1;
        memset(ch[0],0,sizeof(ch[0]));
    }

    //字符c的编号
    int idx(char c){return c-'a';}//这是SIGMA_SIZE=26的时候

    //插入字符串。v必须非0
    void insert(char *s,int n,int v)
    {
        int u=0;
        for(int i=0;i<n;i++)
        {
            int c=idx(s[i]);
            if(!ch[u][c])
            {
                memset(ch[sz],0,sizeof(ch[sz]));
                val[sz]=-1;
                ch[u][c]=sz++;
            }
            u=ch[u][c];
        }
        if(val[u]!=-1)solver.G[v][val[u]]=solver.G[val[u]][v]=1;
        val[u]=v;
    }

    // 在T中找模板
    int find(char* T,int n,int v)
    {
        int j=0;//当前结点编号，初始为根结点
        for(int i=0;i<n;i++)//文本串当前指针
        {
            int c=idx(T[i]);
            j=ch[j][c];
            if(i==n-1&&val[f[j]]!=-1)solver.G[val[f[j]]][v]=1;
            if(i<n-1&&val[j]!=-1)solver.G[val[j]][v]=1;
        }
    }

    //计算fail函数
    void getFail()
    {
        queue<int> q;
        f[0]=0;
        //初始化队列
        for(int c=0;c<SIGMA_SIZE;c++)
        {
            int u=ch[0][c];
            if(ch[0][c]){f[u]=0;q.push(u);}
        }
        //按BFS顺序计算fail
        while(!q.empty())
        {
            int r=q.front();q.pop();
            if(val[r]==-1)val[r]=val[f[r]];
            for(int c=0;c<SIGMA_SIZE;c++)
            {
                int u=ch[r][c];
                if(!u){ch[r][c]=ch[f[r]][c];continue;}//可以改成if(!u){ch[r][c]=ch[f[r]][c];continue;},find函数里的while(j&&!ch[j][c])j=f[j];就可以去掉
                q.push(u);
                int v=f[r];
                f[u]=ch[v][c];
            }
        }
    }
}ac;

int main()
{
//    freopen("input.txt","r",stdin);
    while(scanf("%d",&n)==1)
    {
        ac.init();
        solver.init(n,n);
        st[0]=0;
        for(int i=0;i<n;i++)
        {
            scanf("%s",s+st[i]);
            len[i]=strlen(s+st[i]);
            ac.insert(s+st[i],len[i],i);
            st[i+1]=st[i]+len[i];
        }
        ac.getFail();
        for(int i=0;i<n;i++)ac.find(s+st[i],len[i],i);
        solver.floyd();
        solver.solve();
        solver.maxindependent();
    }
    return 0;
}

