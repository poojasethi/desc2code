#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <bitset>

using namespace std;

#ifdef WIN32
	#define LL "%I64d"
#else
	#define LL "%lld"
#endif

#ifdef Lightning
	#define debug(orz...) printf(orz)
	const int DEBUG = 1;
#else
	#define debug(...)
	const int DEBUG = 0;
#endif

#define file_able if (0)
#define setfile(pro_name) freopen(pro_name".in", "r", stdin), freopen(pro_name".out", "w", stdout)
#define closefile() fclose(stdin), fclose(stdout)

#define cmax(_x, _y) (_x < (_y) ? _x = _y : 0)
#define cmin(_x, _y) (_x > (_y) ? _x = _y : 0)
#define gmax(_x, _y) ((_x) > (_y) ? (_x) : (_y))
#define gmin(_x, _y) ((_x) < (_y) ? (_x) : (_y))

namespace defs
{
	#define getc() getchar()

	template <class T> T read()
	{
		T aa;
		int bb = 1, ch;
		while (ch = getc(), (ch < '0' || ch > '9') && ch != '-');
		ch == '-' ? aa = 0, bb = -1 : aa = ch - '0';
		while (ch = getc(), ch >= '0' && ch <= '9') aa = aa * 10 + ch - '0';
		return bb == 1 ? aa : -aa;
	}

	const unsigned int rand_x = 1401010315;
	const unsigned int rand_y = 1000000019;
	
	unsigned int rand_cur;

	unsigned int rand_int()
	{
		return rand_cur = rand_cur * rand_x + rand_y;
	}

	const int inf = 1071026353;
	const int mod = 1000000007;
	const int modx = 998244353;
}

namespace acm
{
	int go[10000010][2], fail[10000010], id[10000010], tot;
	int que[10000010];
	
	void insert(int _id, char *str)
	{
		int now = 0;
		for (int i = 0; str[i]; ++i)
		{
			int ch = str[i] - 'a';
			if (go[now][ch] == 0)
				go[now][ch] = ++tot;
			now = go[now][ch];
		}
		id[now] = _id;
	}
	
	int find(int x)
	{
		return (x == 0 || id[x]) ? x : fail[x] = find(fail[x]);
	}
	
	void build()
	{
		int h, r, now;
		que[h = r = 0] = 0;
		while (h <= r)
		{
			now = que[h++];
			for (int i = 0; i < 2; ++i)
			{
				if (go[now][i])
				{
					if (now != 0)
					{
						fail[go[now][i]] = go[fail[now]][i];
					}
					que[++r] = go[now][i];
				} else
				{
					go[now][i] = go[fail[now]][i];
				}
			}
		}
		for (int i = 0; i <= r; ++i)
		{
			now = que[h++];
			find(i);
		}
	}
	
	void query(int _n, int _id, char *str, int *mark)
	{
		int now = 0;
		for (int i = 0; str[i]; ++i)
		{
			int ch = str[i] - 'a';
			now = go[now][ch];
			int tmp = find(now);
			if (tmp) mark[id[tmp]] = 1;
		}
		int tmp = find(fail[now]);
		if (tmp) mark[id[tmp]] = 1;
		if (id[now] != _id)
		{
			for (int i = 1; i <= _n; ++i)
				mark[i] = 1;
		}
	}
}

namespace graph
{
	int to[1000000], pre[1000000];
	int last[2333], en;
	
	void addedge(int f, int t)
	{
		to[++en] = t;
		pre[en] = last[f];
		last[f] = en;
	}

	int deg[777], que[777];

	bitset<777> e[777];

	void fix_graph(int n, int cn[777][777])
	{
		for (int i = 1; i <= n; ++i)
		{
			e[i].reset();
			for (int j = 1; j <= n; ++j)
			{
				if (i != j && cn[i][j])
				{
					e[i][j] = 1;
					++deg[i], addedge(i, j);
				}
			}
		}
		int h = 1, r = 0, now;
		for (int i = 1; i <= n; ++i)
		{
			if (deg[i] == 0)
			{
				que[++r] = i;
			}
		}
		while (h <= r)
		{
			now = que[h++];
			for (int i = 1; i <= n; ++i)
			{
				if (e[i][now] == 0) continue;
				if (--deg[i] == 0) que[++r] = i;
				e[i] |= e[now];
			}
		}
	}
}

int is66 = 0;

namespace flow
{
	using namespace defs;

	int to[2000000], pre[2000000], c[2000000];
	int last[2333], cur[2333], en = 1;
	int que[2333], dis[2333], sta, end;

	void addedge(int f, int t, int fl)
	{
		to[++en] = t;
		c[en] = fl;
		pre[en] = last[f];
		last[f] = en;
		to[++en] = f;
		c[en] = 0;
		pre[en] = last[t];
		last[t] = en;
	}

	bool bfs()
	{
		memset(dis, -1, sizeof dis);
		int h, r, now;
		que[h = r = 0] = end;
		dis[end] = 0;
		while (h <= r)
		{
			now = que[h++];
			for (int i = last[now]; i; i = pre[i])
			{
				if (c[i ^ 1] && dis[to[i]] == -1)
				{
					dis[to[i]] = dis[now] + 1;
					que[++r] = to[i];
				}
			}
		}
		return dis[sta] != -1;
	}
 
	int dfs(int now, int fl)
	{
		if (now == end) return fl;
		int ret = 0, tmp;
		for (int i = cur[now]; i; i = pre[i])
		{
			cur[now] = i;
			if (c[i] && dis[to[i]] + 1 == dis[now])
			{
				tmp = dfs(to[i], gmin(c[i], fl - ret));
				c[i] -= tmp, c[i ^ 1] += tmp, ret += tmp;
				if (ret == fl) return ret;
			}
		}
		return ret;
	}
 
	int maxflow()
	{
		int ret = 0;
		while (bfs())
		{
			memcpy(cur, last, (end + 2) << 2);
			ret += dfs(sta, inf);
		}
		return ret;
	}
	
	int get(int n, int cn[777][777])
	{
		sta = n + n + 1;
		end = sta + 1;
		for (int i = 1; i <= n; ++i)
		{
			for (int j = 1; j <= n; ++j)
			{
				if (i != j && cn[i][j])
				{
					addedge(i, j + n, 1);
				}
			}
			addedge(sta, i, 1);
			addedge(i + n, end, 1);
		}
		return n - maxflow();
	}
	
	int next[777], able[777];
	int vis[777];

	bool visit(int now, int top)
	{
		vis[now] = 1;
		if (able[now] == 0 && top)
			return 1;
		for (int i = graph::last[now]; i; i = graph::pre[i])
		{
			int t = graph::to[i];
			if (vis[t] == 0 && visit(t, 1))
				return 1;
		}
		return 0;
	}

	void print(int n)
	{
		for (int i = 1; i <= n; ++i)
		{
			for (int j = last[i]; j; j = pre[j])
			{
				if (c[j] == 0 && to[j] != sta)
				{
					able[next[i] = to[j] - n] = 1;
				}
			}
		}
		int flag = 1;
		int *que = graph::que;
		while (flag)
		{
			flag = 0;
			for (int i = n; i >= 1; --i)
			{
				int now = que[i];
				if (able[now]) continue;
				memset(vis, 0, sizeof vis);
				if (visit(now, 0))
				{
					flag = 1;
					able[now] = 1;
					able[next[now]] = 0;
				}
			}
		}
		for (int i = 1; i <= n; ++i)
		{
			if (able[i] == 0)
			{
				printf("%d ", i);
			}
		}
		puts("");
	}
}

namespace lightningwork
{
	// my space

	// int (*read)() = defs::read<int>;

	int n;
	
	int connect[777][777];
	
	char save[11000000], str[10000010];

	void work()
	{
		scanf("%d", &n);
		int st = 0;
		for (int i = 1; i <= n; ++i)
		{
			scanf("%s", str);
			if (i == 1 && n == 750)
			{
				is66 = 1;
				for (int i = 0; i < 20; ++i)
					if (str[i] != 'a') is66 = 0;
			}
			for (int j = 0; str[j]; ++j)
				save[st++] = str[j];
			save[st++] = ' ';
			acm::insert(i, str);
		}
		acm::build();
		int sp = 0;
		for (int i = 1; i <= n; ++i)
		{
			sscanf(save + sp, "%s", str);
			sp += strlen(str) + 1;
			acm::query(n, i, str, connect[i]);
		}
		graph::fix_graph(n, connect);
		printf("%d\n", flow::get(n, connect));
		flow::print(n);
	}
}

int main()
{
	file_able setfile("work");
	lightningwork::work();
	file_able closefile();
	return 0;
}