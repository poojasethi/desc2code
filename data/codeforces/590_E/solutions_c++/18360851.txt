#include <cstdio>
#include <algorithm>
#include <cstring>
#include <iostream>
#include <queue>

#define REP(i, x, y) for (int i = x, _ = y; i <= _; ++ i)
#define rep(i, x, y) for (int i = x, _ = y; i >= _; -- i)

template <typename T> bool Chkmax(T &x, T y) { return x < y? x = y, true : false; }
template <typename T> bool Chkmin(T &x, T y) { return y < x? x = y, true : false; }

const int MAXL = 1e7 + 1e3, MAXN = 750 + 100;

int n;
char s[MAXL];
int pos[MAXN];
int g[MAXN][MAXN];

namespace Trie
{
    const int MAXSIZE = 1e5 + 1e4, MAXCH = 2;
    int size;
    int val[MAXL];
    int f[MAXL];
    int ch[MAXL][2];
    int last[MAXL];

    inline int Idx(char x) { return x - 'a'; }
    
    void Insert(char *s, int w)
    {
        int u = 0, len = strlen(s);
        REP (i, 0, len - 1) {
            int &v = ch[u][Idx(s[i])];
            if (!v)
                v = ++ size;
            u = v;
            if (i == len - 1)
                val[u] = w;
        }
    }

    void GetFail()
    {
        std::queue<int> q;
        REP (i, 0, MAXCH - 1)
            if (ch[0][i])
                q.push(ch[0][i]);

        while (!q.empty()) {
            int u = q.front();
            q.pop();
            REP (c, 0, MAXCH - 1) {
                int &v = ch[u][c];
                if (!v)
                    v = ch[f[u]][c];
                else {
                    q.push(v);
                    int j = f[u];
                    while (j && !ch[j][c])
                        j = f[j];
                    f[v] = ch[j][c];
                    last[v] = val[f[v]]? f[v] : last[f[v]];
                }
            }
        }
    }
}

namespace Hungary
{
    int cur;
    int G[MAXN * 2][MAXN * 2];
    int flag[MAXN * 2];
    int match[MAXN * 2];

    bool Dfs(int u)
    {
        static int vis[MAXN * 2];

        REP (i, n + 1, n * 2) {
            if (!G[u][i] || vis[i] == cur)
                continue;
            vis[i] = cur;
            if (!match[i] || Dfs(match[i])) {
                match[i] = u;
                return true;
            }
        }

        return false;
    }

    void Dfs0(int u)
    {
        if (flag[u])
            return ;
        flag[u] = true;
        REP (i, n + 1, n * 2)
            if (G[u][i]) {
                flag[i] = true;
                Dfs0(match[i]);
            }
    }
    
    int Exec()
    {
        static int no[MAXN];
        
        int tot = 0;
        
        REP (i, 1, n) REP (j, 1, n)
            if (i != j && g[i][j])
                G[i][j + n] = true;
                
        REP (i, 1, n) {
            ++ cur;
            if (Dfs(i))
                ++ tot;
            else
                no[i] = true;
        }

        REP (i, 1, n)
            if (no[i])
                Dfs0(i);

        return tot;
    }
}

void Solve()
{
    {
        using namespace Trie;
        GetFail();
        REP (i, 1, n) {
            int u = 0;
            REP (j, pos[i], pos[i + 1] - 1) {
                u = ch[u][Idx(s[j])];
                int k = val[u]? u : last[u];
                while (k) {
                    if (g[i][val[k]])
                        break;
                    if (val[k])
                        g[i][val[k]] = true;
                    k = f[k];
                }
            }
        }
    }

    printf("%d\n", n - Hungary::Exec());
    
    REP (i, 1, n)
        if (Hungary::flag[i] && !Hungary::flag[i + n])
            printf("%d ", i);
    puts("");
}

void Input()
{
    scanf("%d", &n);
    REP (i, 1, n) {
        scanf("%s", s + pos[i]);
        Trie::Insert(s + pos[i], i);
        pos[i + 1] = pos[i] + strlen(s + pos[i]);
    }
}

int main()
{
    if (fopen("E.in", "r") != NULL) {
        freopen("E.in", "r", stdin);
        freopen("E.out", "w", stdout);
    }

    Input();
    Solve();

    return 0;
}