#include <bits/stdc++.h>
using namespace std;

#define fru(j,n) for(int j=0; j<(n); ++j)
#define tr(it,v) for(typeof((v).begin()) it=(v).begin(); it!=(v).end(); ++it)
#define x first
#define y second
#define pb push_back
#define ALL(G) (G).begin(),(G).end()

#define DEBUG
#ifdef DEBUG
#define DEB printf
#else
#define DEB(...)
#endif


typedef long long ll;
typedef long long LL;
typedef pair<int,int> pii;
typedef vector<int> vi;

const int inft = 1000000009;
const int MAXN = 753;//10^6
const int MAXSUM=10000007;
string S[MAXN];
char input[MAXSUM];
int H[MAXN];
int per[MAXN];
bool bad[MAXN];

bool cmp(const int &a, const int &b){
	if(S[a].size()!=S[b].size()) return S[a].size()<S[b].size();
	return a<b;
}
struct node{
	node *M[2];
	int koniec;
	node *hop;
	node *suf;
	node(){
		fru(i,2) M[i]=NULL;
		koniec=-1;
		hop=suf=NULL;
	}
	bool add(unsigned int q,string &SS,int nr){
		if(q==SS.size()) {
			if(koniec!=-1) return 0;
			koniec=nr;
			return 1;
		}
		else{
			//			printf("z %s dorzucam literke %c\n",SS.c_str(),SS[q]);
			if(M[SS[q]]==NULL) M[SS[q]]=new node();
			return M[SS[q]]->add(q+1,SS,nr);
		}
	}
};
node *Q[MAXSUM]; int qs;
void aho_corasic(node *POCZ){
	qs=0;
	Q[qs++]=POCZ;
	fru(i,qs){
		node *T=Q[i];
		fru(j,2) if(T->M[j]){
			node *C=T->suf;
			while(C!=POCZ && C->M[j]==NULL) C=C->suf;
			if(i && C->M[j]) C=C->M[j];
			T->M[j]->suf=C;
			if(C->koniec!=-1) T->M[j]->hop=C;
			else T->M[j]->hop=C->hop;
			Q[qs++]=T->M[j];
		}
	}
}
bitset<MAXN> SAS[MAXN];

namespace TM{ //Turbo Matching O(nm)
	//-----------------te ustawiamy przed uzyciem------------------
	const int MAXN = 1505;  //musi zmiescic c+d
	vector<int> V[MAXN];   //wystarczy tylko od chlopcow
	int c,d;               //chlopcy 0..c-1, dziewczyny: c..c+d-1
	//-----------------te sa wynikowe------------------------------
	int M[MAXN];           //z kim jest skojarzony lub -1 jak z nikim
	//----------------te sa pomocniczne-----------------------------
	bool odw[MAXN];
	queue<int> Q;
	inline bool dfs(int u)
	{
		odw[u]=1;
		Q.push(u);
		tr(it,V[u]) if((M[*it]==-1) || (!odw[M[*it]] && dfs(M[*it])))
		{
			M[u]=*it;
			M[*it]=u;
			return 1;
		}
		return 0;
	}//to do zbioru niezaleznego / pokrycia wierzch
	vi IS,VC;bool TT[MAXN];
	void d2(int u){
		if(TT[u]) return;
		TT[u]=1; tr(it,V[u]) TT[*it]=1,d2(M[*it]);}
	int matching() //zwraca rozmiar matchingu
	{
//		fru(i,c) tr(it,V[i]) printf("%d -- %d\n",i,*it);
		fru(i,c) odw[i]=0;
		fru(i,c+d) M[i]=-1;
		bool czy=1;
		while(czy)
		{
			for(czy=0;!Q.empty();Q.pop()) odw[Q.front()]=0;
			fru(i,c) if(M[i]==-1 && !odw[i]) czy|=dfs(i);
		}
		int ret=0;
		fru(i,c) if(M[i]!=-1) ++ret;
		if(1){ //zbior niezal / pokrycie wierzcholkowe
			fru(i,c+d) TT[i]=0;
			fru(i,c) if(M[i]==-1) d2(i);
			fru(i,c) if(TT[i]==1) IS.pb(i);
			fru(i,d) if(TT[i+c]==0)IS.pb(i+c);
		}
		return ret;
	}
}

int main(){
	int n;
	scanf("%d",&n);
	fru(i,n){
		scanf("%s",input);
		S[i]=string(input);
		tr(it,S[i]) *it-='a';
		H[i]=123;
		tr(it,S[i]) H[i]=(H[i]*41311LL+*it)%1000000123;
	}
	fru(i,n) SAS[i][i]=1;
	fru(i,n) per[i]=i;
	sort(per,per+n,cmp);
	node * D=new node();
	D->suf=D->hop=D;
	fru(i,n) if(D->add(0,S[per[i]],per[i])==0) bad[per[i]]=1;
	aho_corasic(D);
	fru(i,n)if(!bad[i]){
		int u=per[i];
		node *E=D;
		tr(it,S[u]){
			while(E!=D && E->M[*it]==NULL) E=E->suf;
			if(E->M[*it]) E=E->M[*it];
			if(E->hop->koniec!=-1) SAS[u][E->hop->koniec]=1;
			if(E->koniec!=-1) SAS[u][E->koniec]=1;
		}
		fru(j,n) if(SAS[u][j]) SAS[u]|=SAS[j];
	}
	vi OK;
	fru(i,n) if(!bad[i]) OK.pb(i);
	int m=OK.size();
	TM::c=TM::d=m;
	fru(i,m) fru(j,m) if(i!=j && SAS[OK[i]][OK[j]]) 
	{
		TM::V[i].pb(j+m);
//		printf("%s ma jako podslowo %s\n",S[OK[i]].c_str(),S[OK[j]].c_str());
	}
	TM::matching();
	vi ANS;
	fru(i,m) if(binary_search(ALL(TM::IS),i) && binary_search(ALL(TM::IS),i+n)) ANS.pb(OK[i]);
	printf("%lu\n",ANS.size());
	tr(it,ANS) printf("%d ",*it+1);
	printf("\n");
	return 0;
}
