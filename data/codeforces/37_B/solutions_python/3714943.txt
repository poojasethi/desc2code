#!/usr/bin/python
import sys
import math
import heapq

class PQ(object):
    def __init__(self, initial=None, key=lambda x:x):
        self.key = key
        if initial:
            self._data = [(key(item), item) for item in initial]
            heapq.heapify(self._data)
        else:
            self._data = []

    def push(self, item):
        heapq.heappush(self._data, (self.key(item), item))

    def pop(self):
        return heapq.heappop(self._data)[1]

    def empty(self):
        return len(self._data) == 0

    def size(self):
        return len(self._data)

class Spell:
	def __init__(self, pwr, dmg, num):
		self.pwr = pwr
		self.dmg = dmg
		self.num = num

N, hpmax, reg = map(lambda x: int(x), raw_input().split())
spells = [[] for i in range(101)]
for i in range(N):
	pwr, dmg = map(lambda x: int(x), raw_input().split())
	spells[pwr].append(Spell(pwr,dmg,i+1))

if sum(map(lambda x: x.dmg, spells[100])) <= reg:
	print "NO"
	exit(0)

queue = PQ(None, lambda x: -x.dmg)
for s in spells[100]:
	queue.push(s)

print "YES"
hp = hpmax
damage = 0
t = -1
castedSpells = []
thres = 100
while True:
	t += 1
	thres_old = thres
	hp = min(hpmax, hp - damage + reg)
	if hp <= 0:
		break
	thres = int(math.ceil(100.*hp/hpmax))
	for i in range(thres, thres_old, 1):
		for sp in spells[i]:
			queue.push(sp)
	if queue.empty():
		continue
	s = queue.pop()
	castedSpells.append((t, s.num))
	damage += s.dmg

print t, len(castedSpells)
for csp in castedSpells:
	print csp[0], csp[1]
