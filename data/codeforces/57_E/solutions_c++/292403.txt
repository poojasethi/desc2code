/*
 * Author: OpenLegend
 * Created Time:  2011-2-20 17:26:10
 * File Name: et.cpp
 */
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <queue>
#include <vector>
using namespace std;
typedef long long LL;
const LL MOD = 1000000007;
const int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};
const int dy[] = {1,  2, 2, 1, -1, -2, -2, -1};
const int maxn = 1005;
const int MID = 500;
const LL TM = 125;
int vis[maxn][maxn], num[maxn];
bool g[maxn][maxn];
int cal(LL k){
    queue<pair<int,int> > que;
    memset(vis, -1, sizeof(vis));
    memset(num, 0, sizeof(num));
    que.push(make_pair(500, 500));
    vis[500][500] = 0;
    num[0]++;
    int tk = min(k, TM);
    while(!que.empty()){
        pair<int,int> q = que.front(); que.pop();
        if(vis[q.first][q.second] == tk) break;
        for(int i = 0; i < 8; i ++){
            int tx = q.first + dx[i], ty = q.second + dy[i];
            if(g[tx][ty] || vis[tx][ty] != -1) continue;
            vis[tx][ty] = vis[q.first][q.second] + 1;
            num[vis[tx][ty]] ++;
            que.push(make_pair(tx,ty));
        }
    }
    LL ret = 0;
    for(int i = 0; i <= tk; i ++) ret = (ret + num[i])%MOD;
    if(k == tk) return ret;
    k -= tk;
    ret = (ret + k%MOD*num[tk]) % MOD;
    LL tn = num[tk]-num[tk-1];
    k %= MOD;
    LL ts = k*(k+1)%MOD;
    if(ts%2 == 0) ts /= 2;
    else ts = (ts+MOD)/2;
    ts = ts*tn % MOD;
    
    ret = (ret+ts)%MOD;
    return ret;
}
int main() {
    LL k, n;
    while(scanf("%I64d%I64d\n", &k, &n) != EOF){
        memset(g, false, sizeof(g));
        for(int i = 0; i < n; i ++){
            int x, y;
            scanf("%d%d", &x, &y);
            g[x+MID][y+MID] = true;
        }
        printf("%d\n", cal(k));
    }
    return 0;
}

