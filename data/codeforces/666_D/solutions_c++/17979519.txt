#include <cstdio>
#include <cstring>
#include <algorithm>
#define INF (1 << 30)
using namespace std;

const int X[5] = { 0, 1, -1, 0, 0 };
const int Y[5] = { 0, 0,  0, 1, -1};

struct point { int x,y; } dot[5],d[5],ans[5];
int p[5],dir[5],done[5];
int T;

// 1 2
// 3 4

bool Judge(int M) {
	int Lx1, Rx1, Lx2, Rx2, Ly1, Ly2, Ry1, Ry2, l,r;

	l = -INF; r = INF;
	Lx1 = -INF; Rx1 = INF;
	int L, R;
	L = d[1].x; R = d[1].x + X[dir[1]] * M;
	if (L > R) swap(L, R);
	Lx1 = max(Lx1, L); Rx1 = min(Rx1, R);

	L = d[3].x; R = d[3].x + X[dir[3]] * M;
	if (L > R) swap(L, R);
	Lx1 = max(Lx1, L); Rx1 = min(Rx1, R);
	if (Lx1 > Rx1) return false;

	Lx2 = -INF; Rx2 = INF;
	L = d[2].x; R = d[2].x + X[dir[2]] * M;
	if (L > R) swap(L, R);
	Lx2 = max(Lx2, L); Rx2 = min(Rx2, R);

	L = d[4].x; R = d[4].x + X[dir[4]] * M;
	if (L > R) swap(L, R);
	Lx2 = max(Lx2, L); Rx2 = min(Rx2, R);
	if (Lx2 > Rx2) return false;

	r = min(r,Rx2 - Lx1);
	l = max(l,Lx2 - Rx1); l = max(l,0);
	if (r < l) return false;

	Ly1 = -INF; Ry1 = INF;
	L = d[3].y; R = d[3].y + Y[dir[3]] * M;
	if (L > R) swap(L, R);
	Ly1 = max(Ly1, L); Ry1 = min(Ry1, R);

	L = d[4].y; R = d[4].y + Y[dir[4]] * M;
	if (L > R) swap(L, R);
	Ly1 = max(Ly1, L); Ry1 = min(Ry1, R);
	if (Ly1 > Ry1) return false;
	

	Ly2 = -INF; Ry2 = INF;
	L = d[1].y; R = d[1].y + Y[dir[1]] * M;
	if (L > R) swap(L, R);
	Ly2 = max(Ly2, L); Ry2 = min(Ry2, R);

	L = d[2].y; R = d[2].y + Y[dir[2]] * M;
	if (L > R) swap(L, R);
	Ly2 = max(Ly2, L); Ry2 = min(Ry2, R);
	if (Ly2 > Ry2) return false;	

	r = min(r,Ry2 - Ly1);
	l = max(l,Ly2 - Ry1); l = max(l,0);

	if (r < l) return false;
	int x1,x2,y1,y2;
	x1 = Lx1; x2 = x1 + l;
	if (x2 < Lx2) x1 += (Lx2 - x2), x2 = Lx2;
	y1 = Ly1; y2 = y1 + l;
	if (y2 < Ly2) y1 += (Ly2 - y2), y2 = Ly2;
	ans[1] = (point) { x1, y2 };
	ans[2] = (point) { x2, y2 };
	ans[3] = (point) { x1, y1 };
	ans[4] = (point) { x2, y1 };
	return true;
}

bool dfs_direct(int u,int M) {
	if (u > 4) return Judge(M);
	for (int i = 1; i <= 4; i++) {
		dir[u] = i;
		if (dfs_direct(u + 1,M)) return true;
	}
	return false;
}

bool dfs_permutation(int u,int M) {
	if (u > 4) {
		for (int i = 1; i <= 4; i++) d[p[i]] = dot[i];
		return dfs_direct(1, M);
	}
	for (int i = 1; i <= 4; i++) {
		if (done[i]) continue;
		p[u] = i; done[i] = 1;
		if (dfs_permutation(u + 1,M)) return true;
		done[i] = 0;
	}
	return false;
}

bool judge(int M) {
	memset(done,0,sizeof(done));
	return (dfs_permutation(1,M));
}

int main() {
	for (scanf("%d",&T); T; T--) {
		for (int i = 1; i <= 4; i++) scanf("%d %d",&dot[i].x,&dot[i].y);
		int L = 0, R = (1 << 30);
		judge(0);
		if (!judge(R)) { printf("-1\n"); continue; }		
		while (L < R) {
			if (judge((L + R) >> 1))  R = (L + R) >> 1;
			else L = (L + R + 1) >> 1;
		}
		judge(L);
		printf("%d\n",L);
		for (int i = 1; i <= 4; i++) printf("%d %d\n",ans[p[i]].x,ans[p[i]].y);
	}
	return 0;
}