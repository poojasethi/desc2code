# C. Watto and Mechanism

modprime = 1e9 + 7
mulprime = 4 
strs = {}

def strhash(s):
	ans = 0
	for ch in s:
		ans = (ans * mulprime + (ord(ch) - 96)) % modprime # only x in 'abc' allowed ie small letters
	return ans

def querycheck(query):
	queryhash = strhash(query)
	powerup = 1;
	for i in xrange(len(query) - 1, -1, -1):
		if query[i] == 'a':
			hashed = (queryhash + powerup) % modprime
			if hashed in strs:
				if query[:i] + 'b' + query[i+1:] in strs[hashed]:
					return 1

			hashed = (queryhash + 2 * powerup) % modprime
			if hashed in strs:
				if query[:i] + 'c' + query[i+1:] in strs[hashed]:
					return 1

		elif query[i] == 'b':
			hashed = (queryhash - powerup) % modprime
			if hashed in strs:
				if query[:i] + 'a' + query[i+1:] in strs[hashed]:
					return 1

			hashed = (queryhash + powerup) % modprime
			if hashed in strs:
				if query[:i] + 'c' + query[i+1:] in strs[hashed]:
					return 1

		else: # query[i] == 'c'
			hashed = (queryhash - 2 * powerup) % modprime
			if hashed in strs:
				if query[:i] + 'a' + query[i+1:] in strs[hashed]:
					return 1

			hashed = (queryhash - powerup) % modprime
			if hashed in strs:
				if query[:i] + 'b' + query[i+1:] in strs[hashed]:
					return 1

		powerup = (powerup * mulprime) % modprime
	return 0

def inputs():
	global strs, strhashes
	N, M = map(int, raw_input().split())
	for _ in xrange(N):
		inpstr = raw_input()
		hashed = strhash(inpstr)
		if hashed in strs:
			strs[hashed].append(inpstr)
		else:
			strs[hashed] = [inpstr]

	for _ in xrange(M):
		if querycheck(raw_input()):
			print 'YES'
		else:
			print 'NO'

inputs()