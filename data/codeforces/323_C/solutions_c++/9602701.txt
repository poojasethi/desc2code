#include <cstdio>
#include <algorithm>
using namespace std;

const int N=(int)1e6+5,logN=21;

int n,L,R,a[N],p[N],q[N];

struct tree{
	tree *l,*r;
	int s;
} mem[N*logN],*newtree=mem;

tree *f[N];

tree* insert(tree *tmp,int beg,int end){
	tree *cur=newtree++;
	if(tmp) *cur=*tmp;
	cur->s++;
	if(end-beg==1) return cur;
	int mid=beg+end>>1;
	if(R<=mid)
		cur->l=insert(cur->l,beg,mid);
	else
		cur->r=insert(cur->r,mid,end);
	return cur;
}

int query(tree *cur,int beg,int end){
	if(!cur||end<=L||beg>=R) return 0;
	if(L<=beg&&R>=end) return cur->s;
	int mid=beg+end>>1;
	return query(cur->l,beg,mid)+query(cur->r,mid,end);
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&p[i]);
	for(int i=1;i<=n;i++){
		int x; scanf("%d",&x);
		q[x]=i;
	}
	for(int i=1;i<=n;i++) a[i]=q[p[i]];
	for(int i=1;i<=n;i++){
		R=a[i];
		f[i]=insert(f[i-1],0,n);
	}
	int m; scanf("%d",&m);
	int ans=0;
	while(m--){
		int a,b,c,d;
		scanf("%d%d%d%d",&a,&b,&c,&d);
		a=(a-1+ans)%n+1;
		b=(b-1+ans)%n+1;
		c=(c-1+ans)%n+1;
		d=(d-1+ans)%n+1;
		if(a>b) swap(a,b);
		if(c>d) swap(c,d);
		a--;
		c--;
		L=c;
		R=d;
		printf("%d\n",ans=query(f[b],0,n)-query(f[a],0,n));
		ans++;
	}
}
