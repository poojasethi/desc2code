#include<bits/stdc++.h>

#define FOR(a,b,c) for(int a=b;a<=c;a++)
#define ROF(a,b,c) for(int a=b;a>=c;a--)
#define pb push_back
#define mp make_pair
#define inf 2000000000
#define f first
#define s second
#define sqr(a) ((a)*(a))
#define ll long long
#define pii pair<int,int>
#define pdd pair<double,double>
#define foreach(itit,gg) for(typeof(gg.begin())itit=gg.begin();itit!=gg.end();itit++)
#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl
#define y1 mydegisken
using namespace std;

int N,M,W;
struct segment{
	ll ST[16000005],Kd[16000005];
	ll update(int node,int bas,int son,int x,int y,ll val){
		
		if(x>son or y<bas) return ST[node];
		if(x<=bas and son<=y){
			Kd[node] += val;
			return ST[node] += val*(son-bas+1);
		}
		int md = (bas+son) >> 1;
		return ST[node] = Kd[node]*(son-bas+1) + update(2*node,bas,md,x,y,val) + update(2*node+1,md+1,son,x,y,val);
	}
	ll query(int node,int bas,int son,int x,int y){
		if(x>son or y<bas) return 0;
		if(x<=bas and son<=y)
			return ST[node];
		int md = bas + son >> 1;
		return query(2*node,bas,md,x,y) + query(2*node+1,md+1,son,x,y) + Kd[node] * max(0,min(son,y) - max(bas,x) + 1);
	}
};
segment X,Y;
int main()
{
	int cmd,x1,y1,x2,y2;
	ll v;
	scanf("%d %d %d",&N,&M,&W);
	FOR(i,1,W){
		scanf("%d",&cmd);
		if(cmd == 1){ //sorgu 	
			scanf("%d %d %d %d",&x1,&y1,&x2,&y2);
			printf("%lld\n",Y.query(1,1,M,y1,y2) - X.query(1,1,N,1,x1-1) - X.query(1,1,N,x2+1,N));
		}
		if(cmd == 0){
			scanf("%d %d %d %d %lld",&x1,&y1,&x2,&y2,&v);
			X.update(1,1,N,x1,x2,v*(y2-y1+1));
			Y.update(1,1,M,y1,y2,v*(x2-x1+1));
		}
	}
	return 0;
}
