#include<bits/stdc++.h>
using namespace std;
int const maxn = 4e6+10;
int n, m, q;
struct node{
	long long soma, lazy;
} seg[2][4*maxn];
void refresh(int idx, int i, int j, int id){
	if(!seg[id][idx].lazy) return;
	int left=idx*2, right=left+1;
	if(i != j){
		seg[id][left].lazy += seg[id][idx].lazy;
		seg[id][right].lazy += seg[id][idx].lazy;
	}
	seg[id][idx].soma += (j-i+1)*seg[id][idx].lazy;
	seg[id][idx].lazy = 0;
}
void update(int idx, int i, int j, int ini, int fim, long long val, int id){
	refresh(idx,i,j,id);
	if(i > j || j < ini || fim < i) return;
	if(ini <= i && j <= fim){
		seg[id][idx].lazy += val;
		refresh(idx,i,j,id);
		return;
	}
	int mid=(i+j)/2, left=idx*2, right=left+1;
	update(left,i,mid,ini,fim,val,id), update(right,mid+1,j,ini,fim,val,id);
	seg[id][idx].soma = seg[id][left].soma + seg[id][right].soma;
}
long long query(int idx, int i, int j, int ini, int fim, int id){
	refresh(idx,i,j,id);
	if(i > j || j < ini || fim < i || fim < ini) return 0;
	if(ini <= i && j <= fim) return seg[id][idx].soma;
	int mid=(i+j)/2, left=idx*2, right=left+1;
	return query(left,i,mid,ini,fim,id) + query(right,mid+1,j,ini,fim,id);
}
int main(){
	scanf("%d%d%d",&n,&m,&q);
	for(int i = 1; i <= q; i++){
		int type, x1, x2, y1, y2, X, Y;
		long long val;
		scanf("%d%d%d%d%d",&type,&y1,&x1,&y2,&x2);
		if(type == 0){
			scanf("%I64d",&val);
			update(1,1,n,y1,y2,val*(x2-x1+1),0);
			update(1,1,m,x1,x2,val*(y2-y1+1),1);
		}
		if(type == 1){
			long long ans = 0;
			ans += query(1,1,n,y1,y2,0);
			ans -= (query(1,1,m,1,x1-1,1) + query(1,1,m,x2+1,m,1));
			printf("%I64d\n",ans);
		} 
	}
}
