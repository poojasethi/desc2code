#include <iostream>
#include <cstdlib>
#include <vector>
#include <algorithm>
#include <set>
#define pb push_back
using namespace std;
const int M = 100 * 1000 +5;
vector <int> adj[M], ls[M], la[M], ans;
int s[M], d[M], f[M], now = 0;

int dfs(int v,int de)
{
	la[de].pb(v);
	d[v] = de;
	s[v] = now++;
	ls[de].pb(s[v]);
	for(int i = 0; i<adj[v].size(); i++)
		dfs(adj[v][i], de + 1);
	f[v] = now;
}

int jad(int v, int p)
{
	if(d[v]<=p)
		return -1;
	return lower_bound(ls[ d[v] - p ].begin(),ls[ d[v] - p ].end(), s[v])-ls[d[v]-p].begin () - 1;
}

/*bool cmp(int a, int b)
{
	return s[jad(a,p)]<s[jad(b,p)];
}*/

int main()
{
	int n;
	cin >> n;
	for(int i = 1; i<n+1; i++)
	{
		int x;
		cin >> x;
		adj[x].pb(i);
	}
	dfs(0,0);
	int m;
	cin >> m;
	for(int i = 0; i<m; i++)
	{
		int v,p;
		cin >> v >> p;
		if(jad(v,p) == -1)
		{
			cout << 0 << " ";
			continue;
		}
		int u = jad(v, p);
		vector<int>::iterator low = lower_bound(ls[d[v]].begin(), ls[d[v]].end(), s[la[d[v]-p][u]]);
		vector<int>::iterator up = lower_bound(ls[d[v]].begin(), ls[d[v]].end(), f[la[d[v]-p][u]]);
		cout << up - low - 1 << " ";
	}
	return 0;
}
