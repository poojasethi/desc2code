#include<cstdio>
#include<vector>
#include<algorithm>
#define N 200005
using namespace std;
int f[N][21],L[N],R[N],deep[N],pre[N];
int tot,root,i,A,B,P,Q,n,m,x,y,j,k;
vector<int>a[N],b[N];
void dfs(int k)
{
  L[k]=++tot;
  pre[tot]=k;
  for (int i=0;i<a[k].size();i++)
  {
    int go=a[k][i];if (go==f[k][0]) continue;
    deep[go]=deep[k]+1;
    f[go][0]=k;
    dfs(go);
  }
  R[k]=++tot;
  pre[tot]=k;
}
inline int get(int x,int k)
{
  for (int i=20;i>=0;i--)
    if ((k>>i)&1) x=f[x][i];
  return x;
}
int main()
{
  scanf("%d",&n);root=n+1;
  for (i=1;i<=n;i++)
  {
    scanf("%d",&x);
    if (!x) x=root;
    a[x].push_back(i);
  }
  deep[root]=1;dfs(root);
  for (j=1;j<=20;j++)
    for (i=1;i<=n;i++)
      f[i][j]=f[f[i][j-1]][j-1];
  for (i=1;i<=tot;i++)
    b[deep[pre[i]]].push_back(i);
  scanf("%d",&m);
  while (m--)
  {
    scanf("%d%d",&x,&k);
    y=deep[x];x=get(x,k);
    if (x==0||x==root) {puts("0");continue;}
    P=L[x];Q=R[x];
    A=lower_bound(b[y].begin(),b[y].end(),P)-b[y].begin();
    B=upper_bound(b[y].begin(),b[y].end(),Q)-(b[y].begin()+1);
    printf("%d\n",(B-A)>>1);
  }
}
