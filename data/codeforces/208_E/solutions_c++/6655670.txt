#include <cstdio>
#include <algorithm>
#include <vector>
#include <set>
using namespace std;

const int N = 100500;

vector<int> v[N], root;
vector<int> lvl1[N], lvl2[N];
int start[N], finish[N], d[N], now;

void dfs(int s) {
	start[s] = now++;
	lvl1[d[s]].push_back(start[s]);
	lvl2[d[s]].push_back(s);
	for(int i = 0; i < v[s].size(); i ++) {
		d[ v[s][i] ] = d[s] + 1;
		dfs(v[s][i]);
	}
	finish[s] = now;
}
int main() {
	int n;
	scanf("%d", &n);
	for(int i = 0, a; i < n; i ++) {
		scanf("%d", &a);
		if(a != 0) v[a-1].push_back(i);
		else root.push_back(i);
		
	}
	for(int i = 0; i < root.size(); i ++) {
		dfs(root[i]);
	}
	int Q, v, p;
	scanf("%d", &Q);
	while(Q-- > 0) {
		scanf("%d%d", &v, &p);
		v--;
		
		if(d[v] -p < 0) {
			puts("0");
			continue;
		}
		
		int ind = lower_bound(lvl1[d[v] - p].begin(), lvl1[d[v] - p].end(), start[v]) - lvl1[d[v] - p].begin() - 1;
		int y = lvl2[d[v] - p][ind];
        int ind2 = lower_bound(lvl1[d[v]].begin(), lvl1[d[v]].end(), finish[y]) - lower_bound(lvl1[d[v]].begin(), lvl1[d[v]].end(), start[y]) - 1;
        printf("%d\n", ind2);
	}
	return 0;
}
		  		 	   			 			 	 		 	