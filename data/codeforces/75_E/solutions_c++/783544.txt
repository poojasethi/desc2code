#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
#define eps 1e-8
#define pw(x) ((x)*(x))
struct P
{
    double x,y;
    int id;
    P (double x=0,double y=0) :x(x) ,y(y) {}
    P operator -(const P & b)
    {
        return P (x-b.x,y-b.y);
    }
    double operator * (const P & b)
    {
        return x*b.y-y*b.x;
    }
}p[60],s,t;
int sgn(double x)
{
    return x<-eps?-1:x>eps;
}
P LLI(P a,P b,P c,P d)
{
	P ret;
    double t1=(b-a)*(d-a),t2=(b-a)*(c-a);
    ret.x=(t1*c.x-t2*d.x)/(t1-t2);
    ret.y=(t1*c.y-t2*d.y)/(t1-t2);
    return ret;
}
double PPD(P a,P b)
{
    return sqrt(pw(a.x-b.x)+pw(a.y-b.y));
}
double d[60][60];
int vst[60],n;
int findmin()
{
    int id=-1;
    for(int i=0;i<n;i++){
        if(!vst[i]) {
            if(id==-1||d[id][n-2]>d[i][n-2]) id=i;
        }
    }
    if(id+1) vst[id]=1;
    return id;
}
int main()
{
    scanf("%lf%lf%lf%lf",&s.x,&s.y,&t.x,&t.y);
    scanf("%d",&n);
    for(int i=0;i<n;i++)
        scanf("%lf%lf",&p[i].x,&p[i].y);
    p[n]=p[0];
    int c=0;
    memset(d,-1,sizeof(d));
    memset(vst,0,sizeof(vst));
    int f=-1,r=-1;
    P w[2];
    for(int i=0;i<n;i++){
        if((sgn((t-s)*(p[i]-s)) * sgn( (t-s)*(p[i+1]-s)) <0 ||
            sgn((t-s)*(p[i]-s))==0)&&
            sgn((t-s)*(p[i]-p[i+1]))) {
            P ret=LLI(s,t,p[i],p[i+1]);
            if(f==-1) { f=i , w[0]=ret;}
            else if(r==-1) { r=i; w[1]=ret;}
        }
    }
    if(r==-1||PPD(w[0],s)+PPD(w[0],t)>PPD(s,t)+eps) { printf("%.10f\n",PPD(s,t)); return 0; }
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            d[i][j]=PPD(p[i],p[j]);
            if(abs(i-j)>1&&abs(i-j)!=n-1) d[i][j]*=2;
            d[j][i]=d[i][j];
        }
        d[i][n]=PPD(p[i],w[0]);
        if(i!=f&&i!=(f+1)%n) d[i][n]*=2;
        d[i][n+1]=PPD(p[i],w[1]);
        if(i!=r&&i!=(r+1)%n) d[i][n+1]*=2;
        d[n][i]=d[i][n], d[n+1][i]=d[i][n+1];
    }
    d[n][n]=d[n+1][n+1]=0;
    d[n+1][n]=d[n][n+1]=2*PPD(w[0],w[1]);
    n+=2;
    while(1) {
        int id=findmin();
        if(id==-1) break;
        for(int i=0;i<n;i++){
            if(!vst[i]){
                double tmp=d[i][id]+d[id][n-2];
                if(d[i][n-2]>tmp) d[i][n-2]=tmp;
            }
        }
    }

    double add=min(PPD(s,w[0]),PPD(s,w[1]))+min(PPD(t,w[0]),PPD(t,w[1]));
    printf("%.10f\n",d[n-1][n-2]+add);
}


/***
 1 7 6 7
4
4 2 4 12
3 12 3 2

-1 0 2 0
4
0 0 1 0 1 1 0 1
***/


			 		 	 		 		 	 		   	 		