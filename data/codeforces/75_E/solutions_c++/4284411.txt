#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<map>

using namespace std;

#define N 35
#define ERROR 1e-7

int dcmp(double x)
{
    if(fabs(x)<ERROR)
        return 0;
    return x>ERROR ? 1 : -1;
}

struct node
{
    double x,y;
    node operator + (node B)    {return (node){x+B.x,y+B.y};}
    node operator - (node B)    {return (node){x-B.x,y-B.y};}
    node operator * (double z)      {return (node){x*z,y*z};}
    bool operator == (node B)   {return dcmp(x-B.x)==0&&dcmp(y-B.y)==0;}
    friend bool operator < (const node &a,const node &b)
    {
        return a.x<b.x;
    }
}point[N],cross[3];

map<node ,int >Q;

node st,ed;
int n,hb[4];
double sum=0;

typedef node vector;

vector k[N];

double XX(node x,node y)
{
    return x.x*y.y-x.y*y.x;
}

node get_X(node x,vector xy,node y,vector yy)
{
    vector k=x-y;
    double t=XX(yy,k)/XX(xy,yy);
    return x+xy*t;
}

double dis(node x,node y)
{
    double k=y.x-x.x;
    double k1=y.y-x.y;
    return sqrt(k*k+k1*k1);
}

void init()
{
    scanf("%lf%lf%lf%lf",&st.x,&st.y,&ed.x,&ed.y);
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%lf%lf",&point[i].x,&point[i].y);
}

bool check(node x,node y,node z)
{
    if(x==y) return true;
    if(x==z) return false;
    if(dcmp((x.x-y.x)*(x.x-z.x))<=0&&dcmp((x.y-y.y)*(x.y-z.y))<=0)
        return true;
    return false;
}

void work()
{
    point[n+1]=point[1];
    for(int i=1;i<=n;i++)
        sum+=dis(point[i],point[i+1]);
    for(int i=2;i<=n+1;i++)
        k[i]=point[i]-point[i-1];
    int cnt=0;
    node cross[8];
    for(int i=2;i<=n+1;i++)
    {
        node kk=get_X(point[i-1],k[i],st,ed-st);
        if(check(kk,point[i],point[i-1])&&check(kk,st,ed))
            if(Q.count(kk)==0) 
                cross[++cnt]=kk,hb[cnt]=i,Q[kk]=cnt;
    }
    if(cnt==1||cnt==0)
    {
        printf("%.8lf\n",dis(st,ed));
        exit(0);
    }
    hb[1]=(hb[1]-1)%n+1;
    hb[2]=(hb[2]-1)%n+1;
    if(hb[1]>hb[2])
        swap(hb[1],hb[2]),swap(cross[1],cross[2]);
    double summm=0;
    summm+=dis(cross[1],point[hb[1]]);
    summm+=dis(cross[2],point[hb[2]-1]);
    for(int i=hb[1]+1;i<hb[2];i++)
        summm+=dis(point[i],point[i-1]);
    summm=min(sum-summm,summm);
    double kk=0;
    kk=min(summm,dis(cross[1],cross[2])*2);
    double kkk=0;
    kkk=min(dis(st,cross[1])+dis(cross[2],ed),dis(st,cross[2])+dis(ed,cross[1]));
    printf("%.8lf\n",kkk+kk);
}

int main()
{
    init();
    work();
    return 0;
}