#include <cstdio>
#include <cstring>
#include <complex>
#include <algorithm>
#include <vector>
#include <cmath>
using namespace std;

#define ESP 1e-6
#define dot(a,b) ((conj(a)*(b)).real())
#define cross(a,b) ((conj(a)*(b)).imag())
#define X real()
#define Y imag()
typedef complex<double> Point;

vector<Point> hull;
Point start, end;
int n;

void init()
{
  int x, y;
  scanf("%d%d", &x, &y);
  start = Point(x, y);
  scanf("%d%d", &x, &y);
  end = Point(x, y);
  
  scanf("%d", &n);
  for (int i = 0; i < n; ++i) {
    scanf("%d%d", &x, &y);
    hull.push_back(Point(x, y));
  }
}

int sgn(double x) {
  if (fabs(x) < ESP) return 0;
  return x < 0 ? -1 : 1;
}

bool inLine(Point a, Point b, Point p) {
  return sgn(cross(a-p, b-p)) == 0;
}

bool inRay(Point a, Point b, Point p) {
  return inLine(a, b, p) && sgn(dot(p-a,b-a)) >= 0;
}

bool inSegment(Point a, Point b, Point p) {
  return inRay(a, b, p) && inRay(b, a, p);
}

bool crossPoint(Point a, Point b, Point c, Point d, Point &p) {
  double d1 = cross(c-a, b-a);
  double d2 = cross(d-a, b-a);
  if (sgn(d1)*sgn(d2) == 1) return 0;
  d1 = fabs(d1);
  d2 = fabs(d2);
  if (sgn(d1+d2) == 0) return 0;
  
  p = (d1*d+d2*c)/(d1+d2);
  //  printf("%lf %lf\n", p.X, p.Y);
  
  return inSegment(a,b,p) && inSegment(c,d,p);
}

double dist(Point a, Point b) {
  return hypot(a.X-b.X, a.Y-b.Y);
}

bool equ(Point a, Point b) {
  return sgn(a.X-b.X) == 0 && sgn(a.Y-b.Y) == 0;
}

double pert(Point a, int i, Point b, int j, int det)
{
  double len = 0.0;
  len = dist(a, hull[i]) + dist(b, hull[j]);
  for (; i != j; i = (i+det+n)%n)
    len += dist(hull[i], hull[(i+det+n)%n]);

  return len;
}

double solve(Point start, Point end)
{
  Point ipot[2], p;
  int eg[2], tot = 0;
  for (int j, i = 0; i < hull.size(); ++i) 
    if (crossPoint(start, end, hull[i], hull[(i+1)%n], p)) {
      for (j = 0; j < tot; ++j)
	if (equ(ipot[j], p)) break;
      if (j == tot) {
	eg[tot] = (i+1)%n;
	ipot[tot++] = p;
      }
    }

  if (tot < 2) return dist(start, end);
  for (int i = 0; i < n; ++i)
    if ((equ(hull[i], ipot[0]) && equ(hull[(i+1)%n], ipot[1])) || (equ(hull[i], ipot[1]) && equ(hull[(i+1)%n], ipot[0]))) 
      return dist(start, end);
  
  if (dist(ipot[0], start) > dist(ipot[1], start))
    swap(start, end);
  
  double ans = 0.0, cur = 1e100;
  ans = dist(start, ipot[0]) + dist(end, ipot[1]);
  cur = min(cur, 2*dist(ipot[0], ipot[1]));
  cur = min(cur, pert(ipot[0], eg[0], ipot[1], (eg[1]-1+n)%n, 1));
  cur = min(cur, pert(ipot[0], (eg[0]-1+n)%n, ipot[1], eg[1], -1));
  
  return ans + cur;
}

int main()
{
  init();
  printf("%.6lf\n", solve(start, end));
  return 0;
}

