#include<cstdio>
#include<cmath>
#include<algorithm>
#define prec 1e-9
#define next(x) (x==n?1:x+1)
using namespace std;
struct point
{   double x,y;
    point(double x=0,double y=0):x(x),y(y) {}
};
point p[105];
point itp[5];
point src,dest;
int r[5];
int n,m;
double ans;
inline point operator -(point a,point b)
{   return point(a.x-b.x,a.y-b.y);
}
inline double cp(point a,point b)
{   return a.x*b.y-b.x*a.y;
}
inline double dist(point a,point b)
{   return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}
void inter(int p,point a,point b,point c,point d)
{   double t1,t2,t3,t4;
    t1=cp(c-a,b-a),t2=cp(b-a,d-a),t3=cp(a-c,d-c),t4=cp(d-c,b-c);
    if (fabs(t1)<prec&&fabs(t2)<prec) 
        return ;
    if (fabs(dist(a,c)+dist(b,c)-dist(a,b))<prec) 
    {   itp[m]=c,r[m++]=p; 
        return ;
    }
    if (t1*t2>prec&&t3*t4>prec)
    {   itp[m].x=(t1*d.x+t2*c.x)/(t1+t2);
        itp[m].y=(t1*d.y+t2*c.y)/(t1+t2);
        r[m++]=p;
        return ;
    }
}
double calc(int st,int ed,int src,int dest)
{   double res;
    int i;
    if (ed==1)
        ed=n;
    else --ed;
    res=dist(itp[src],p[st]);
    for (i=st;i!=ed;i=next(i))
        res+=dist(p[i],p[next(i)]);
    return res+dist(p[ed],itp[dest]);
}
double work()
{   int i;
    p[0]=p[n];
    for (i=1;i<=n;++i)
        inter(i,src,dest,p[i-1],p[i]);
    if (m>1)
    {   if (dist(src,itp[0])>dist(src,itp[1]))
            swap(itp[0],itp[1]),swap(r[0],r[1]);
        ans=min(calc(r[0],r[1],0,1),calc(r[1],r[0],1,0));
        ans=min(ans,dist(itp[0],itp[1])*2);
        ans+=dist(src,itp[0])+dist(itp[1],dest);
    }
    else ans=dist(src,dest);
    return ans;
}
int main()
{   int i;
    scanf("%lf%lf%lf%lf",&src.x,&src.y,&dest.x,&dest.y);
    scanf("%d",&n);
    for (i=1;i<=n;i++)
        scanf("%lf%lf",&p[i].x,&p[i].y);
    printf("%.10lf\n",work());
    return 0;
}
