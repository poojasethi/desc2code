#include <iostream>
#include <cmath>
#include <iomanip>

typedef double ld;

using namespace std;

#define mp make_pair
#define fi first
#define se second

template <class T>
struct PT {
    T x, y;
    PT() {x = 0, y = 0;}
    PT(T xx, T yy) {x = xx, y = yy;}
    template <class T2>
    PT(PT <T2> b) {x = b.x, y = b.y;}
    PT operator-(PT b) {
        return PT(x - b.x, y - b.y);
    }
    bool operator<(PT b) {
        return mp(x, y) < mp(b.x, b.y);
    }
    ld dist() {return hypot(x, y);}
};

ld cp(PT <int> a, PT <int> b) {
    return a.x * b.y - b.x * a.y;
}

istream & operator>>(istream &in, PT<int> &p) {
    in >> p.x >> p.y;
    return in;
}

int sign(int n) {
    return n == 0 ? 0 : abs(n) / n;
}

pair < int, PT <ld> > intersect(PT <int> a, PT <int> b, PT <int> c, PT <int> d) {
    int cp1 = cp(c - a, b - a), cp2 = cp(d - a, b - a),
        cp3 = cp(a - c, d - c), cp4 = cp(b - c, d - c);
    if (cp(b - a, d - c) == 0 || cp1 == 0)
        return mp(-1, PT <ld>());
    if (sign(cp1) != sign(cp2) && sign(cp3) != sign(cp4)) {
        int a1 = a.y - b.y, b1 = b.x - a.x, a2 = c.y - d.y, b2 = d.x - c.x;
        int c1 = -(a1 * a.x + b1 * a.y), c2 = -(a2 * c.x + b2 * c.y);
        ld dv = a1 * b2 - b1 * a2;
        return mp(0, PT <ld> ((b1 * c2 - b2 * c1) / dv, (a2 * c1 - a1 * c2) / dv));
    }
    else
        return mp(-1, PT <ld>());
}

int main()
{
    cout << fixed << setprecision(6);
    PT <int> s, f, p[50];
    int n;
    cin >> s >> f;
    cin >> n;
    for (int i = 0; i < n; i++)
        cin >> p[i];
    ld perim = 0;
    pair < int, PT <ld> > i1, i2;
    i1.fi = i2.fi = -1;
    for (int i = 0; i < n; i++) {
        perim += (p[i] - p[(i + 1) % n]).dist();
        if (i1.fi == -1) {
            i1 = intersect(s, f, p[i], p[(i + 1) % n]);
            if (i1.fi == 0)
                i1.fi = i;
        }
        else
        if (i2.fi == -1) {
            i2 = intersect(s, f, p[i], p[(i + 1) % n]);
            if (i2.fi == 0)
                i2.fi = i;
        }
    }
    ld way = (s - f).dist();
    if (i2.fi > -1) {
        ld through = (i1.se - i2.se).dist();
        way -= through;
        ld half1 = (i1.se - PT <ld> (p[(i1.fi + 1) % n])).dist() + (i2.se - PT <ld> (p[i2.fi])).dist();
        for (int i = (i1.fi + 1) % n; i != i2.fi; i = (i + 1) % n)
            half1 += (p[i] - p[(i + 1) % n]).dist();
        ld half2 = perim - half1;
        way += min(min(half1, half2), through * 2);
    }
    cout << way;
    return 0;
}
