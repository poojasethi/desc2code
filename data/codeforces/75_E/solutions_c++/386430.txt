#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#define EPS 1e-9
#define FOR(i,s,e) for (int i=(s); i<(int)(e); i++)
#define FOE(i,s,e) for (int i=(s); i<=(int)(e); i++)
using namespace std;

struct vect{
	double x,y;
	vect(){}
	vect(double x,double y):x(x),y(y){}
	vect operator + (vect const &T) const{return vect(x+T.x,y+T.y);}
	vect operator - (vect const &T) const{return vect(x-T.x,y-T.y);}
	vect operator * (double const &t) const{return vect(x*t,y*t);}
	double operator % (vect const &T) const{return x*T.x+y*T.y;}
	double operator ^ (vect const &T) const{return x*T.y-y*T.x;}
	double len(){return sqrt(x*x+y*y);}
	void get(){scanf("%lf%lf",&x,&y);}
}	p[105];

vect st,ed,pp[2],Pt,p0,p1;
int n,pe[2],cnt;
double ret,base;

int SegInt(vect L1,vect L2,vect S1,vect S2,vect &P){
	vect T;
	double u;
	if (fabs((L2-L1)^(S2-S1))<EPS) return 0;
	T=(S2-S1);
	u=((S1-L1)^T)/((L2-L1)^T);
	if (u<EPS||u>1+EPS) return 0;
	T=(L2-L1);
	u=((L1-S1)^T)/((S2-S1)^T);
	if (u<-EPS||u>1+EPS) return 0;
	P=S1+(S2-S1)*u;
	return 1;
}


int main(){

	st.get();
	ed.get();
	scanf("%d", &n);
	FOR(i,0,n) p[i].get();
	p[n] = p[0];
	
	
	FOR(i,0,n){
		if (SegInt(p[i],p[i+1],st,ed,Pt)){
			pe[cnt] = i;
			pp[cnt] = Pt;
			cnt++;
		}
	}
	
	if (cnt<2) printf("%f\n",(ed-st).len()+1e-11);
	else if (cnt==2){
		p0 = pp[0];
		p1 = pp[1];
		if (fabs( (ed-st).len() - (st-p0).len() - (p1-p0).len() - (ed-p1).len() )>EPS){
			swap(pp[0],pp[1]);
			swap(pe[0],pe[1]);
		}
		
		ret = (ed-st).len() + (p1-p0).len();
		base = (ed-st).len() - (p1-p0).len();;
		//anti
		double len = (pp[0]-p[pe[0]+1]).len() + (pp[1]-p[pe[1]]).len();
		for (int i=(pe[0]+1)%n; i!=pe[1]; i=(i+1)%n) len += (p[i+1]-p[i]).len();
		ret = min(ret, len + base);
		
		//cloc
		len = (pp[1]-p[pe[1]+1]).len() + (pp[0]-p[pe[0]]).len();
		for (int i=(pe[1]+1)%n; i!=pe[0]; i=(i+1)%n) len += (p[i+1]-p[i]).len();
		ret = min(ret, len + base);

		printf("%f\n",ret+1e-11);
	}
	
	return 0;
}

