#include <iostream>
#include <vector>
#include <complex>
#include <cmath>
#include <cstdlib>

using namespace std;

typedef complex<double> point;

double prodvec(point p1,point p2)
{
  return imag(conj(p1)*p2);
}

double prodesc(point p1,point p2)
{
  return real(conj(p1)*p2);
}

point llegir()
{
  double x,y;
  cin>>x>>y;
  return point(x,y);
}

double absolut(double x)
{
  if (x<0) return -x;
  return x;
}

double error=0.00000001;

bool paralelos(point v1,point v2)
{
  return absolut(prodvec(v1,v2))<error;
}

point corte(point &p1,point &v1,point &p2,point &v2)
{
  return p1+(prodvec(p2-p1,v2)/prodvec(v1,v2))*v1;
}

bool haycorte(point &p1,point &v1,point &c)
{
  return prodesc(c-p1,v1)>=-error and prodesc(c-p1,v1)<prodesc(v1,v1)-error;
}

int main()
{
  cout.setf(ios::fixed);
  cout.precision(10);
  point p1,pend;
  p1=llegir();
  pend=llegir();
  point v1=pend-p1;
  int n;
  cin>>n;
  vector<point> p(n);
  for (int i=0;i<n;i++)
    p[i]=llegir();
  vector<point> c(n);
  vector<bool> hayc(n,false);
  int numc=0;
  for (int i=0;i<n;i++) {
    point p2=p[i];
    point v2=p[(i+1)%n]-p[i];
    if (paralelos(v1,v2)) {
      if (paralelos(v1,p2-p1)) {
	cout<<abs(v1)<<endl;
	exit(0);
      }
    } else {
      c[i]=corte(p2,v2,p1,v1);
      hayc[i]=haycorte(p1,v1,c[i]) and haycorte(p2,v2,c[i]);
      numc+=hayc[i];
      //cout<<hayc[i]<<" "<<c[i]<<endl;
    }
  }
  if (numc<=1) {
    cout<<abs(v1)<<endl;
    exit(0);
  }
  int i1=0;
  while (not hayc[i1]) i1++;
  double dist1=abs(p[(i1+1)%n]-c[i1]);
  double dist2=abs(c[i1]-p[i1]);
  point c1=c[i1];
  int i2=(i1+1)%n;
  while (not hayc[i2]) {
    dist1+=abs(p[(i2+1)%n]-p[i2]);
    i2=(i2+1)%n;
  }
  dist1+=abs(c[i2]-p[i2]);
  dist2+=abs(p[(i2+1)%n]-c[i2]);
  point c2=c[i2];
  i2=(i2+1)%n;
  while (i2!=i1) {
    dist2+=abs(p[(i2+1)%n]-p[i2]);
    i2=(i2+1)%n;
  }
  if (abs(c1-p1)>abs(c2-p1)) swap(c1,c2);
  cout<<min(min(abs(c1-p1)+abs(pend-c2)+2.0*abs(c2-c1),
		abs(c1-p1)+abs(pend-c2)+dist1),
	    abs(c1-p1)+abs(pend-c2)+dist2)<<endl;
}



