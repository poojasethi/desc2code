
// Codeforces Beta Round #67 (Div. 2) E Ship's Shortest Path

#include <algorithm>
#include <cstdio>
#include <cmath>

using namespace std;

const double eps = 1e-8;

struct point {
	double x, y;
	point(double _x = 0, double _y = 0) : x(_x), y(_y) {}
	void read() {
		scanf("%lf%lf", &x, &y);
	}
};

point polygon[30];

int sign(double x) {
	if (fabs(x) < eps) return 0;
	return (x > 0) ? 1 : -1;
}

double cross(const point &a, const point &b, const point &c, const point &d) {
	return (b.x - a.x) * (d.y - c.y) - (b.y - a.y) * (d.x - c.x);
}

double dist(const point &a, const point &b) {
	return hypot(a.x - b.x, a.y - b.y);
}

pair<point, bool> getIntersection(const point &a, const point &b, const point &c, const point &d) {
	if (sign(cross(a, b, c, d)) == 0) return make_pair(point(0, 0), false);
	double a1 = b.x - a.x, b1 = c.x - d.x, c1 = c.x - a.x;
	double a2 = b.y - a.y, b2 = c.y - d.y, c2 = c.y - a.y;
	double tmp = a1 * b2 - a2 * b1;
	double x = (c1 * b2 - c2 * b1) / tmp;
	double y = (c2 * a1 - c1 * a2) / tmp;
	if (sign(x) >= 0 && sign(x - 1) < 0 && sign(y) >= 0 && sign(y - 1) < 0) {
		return make_pair(point(a.x + x * (b.x - a.x), a.y + x * (b.y - a.y)), true);
	} else {
		return make_pair(point(0, 0), false);
	}
}

int main() {
	//freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);
	
	point start, end;
	start.read();
	end.read();
	
	int n;
	scanf("%d", &n);
	for (int i = 0; i < n; i ++)
		polygon[i].read();
	
	int flag = 0;
	point a, b;
	int la, lb;
	for (int i = 0; i < n; i ++) {
		pair<point, bool> tmp = getIntersection(start, end, polygon[i], polygon[(i + 1) % n]);
		if (tmp.second) {
			if (flag == 0) {
				a = tmp.first;
				la = i;
			} else {
				b = tmp.first;
				lb = i;
			}
			flag ++;
		}
	}
	
	if (flag < 2) {
		printf("%.10lf\n", dist(start, end));
		return 0;
	}
	
	if (sign(dist(start, a) - dist(start, b)) > 0) {
		swap(a, b);
		swap(la, lb);
	}
	double ans = dist(start, a) + dist(a, b) * 2 + dist(b, end);
	
	double s1 = dist(start, a) + dist(a, polygon[(la + 1) % n]);
	for (int i = (la + 1) % n; i != lb; i = (i + 1) % n)
		s1 += dist(polygon[i], polygon[(i + 1) % n]);
	s1 += dist(polygon[lb], b) + dist(b, end);
	ans = min(ans, s1);
	
	double s2 = dist(start, a) + dist(a, polygon[la]);
	for (int i = la; i != (lb + 1) % n; i = (i + n - 1) % n)
		s2 += dist(polygon[i], polygon[(i + n - 1) % n]);
	s2 += dist(polygon[(lb + 1) % n], b) + dist(b, end);
	ans = min(ans, s2);
	
	printf("%.10lf\n", ans);
	
	return 0;
}
