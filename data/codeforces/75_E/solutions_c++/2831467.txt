#include <vector>
#include <cstdio>
#include <set>
#include <map>
#include <algorithm>
#include <cstdlib>
#include <sstream>
#include <numeric>
#include <queue>
#include <iostream>
#include <string>
#include <cstring>
#include <utility>
#define sz(a) ((int)(a).size())
#define pb push_back
#define mk make_pair
#define fi first
#define se second
#define Rep(i,j,k) for (int i=(j); i<=(k); i++)
#define Repd(i,j,k) for (int i=(j); i>=(k); i--)
#define ALL(c) (c).begin(),(c).end()
#define TR(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define SUM(a) accumulate(all(a),string())
#define online1
#define RAND ((rand()<<15)+rand())
using namespace std;
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef pair<int,int> II;
typedef long long LL;

#include <cmath>

const int N=1000;
const double eps=1e-12;

int sign(double x){
	if (x<-eps) return -1;
	return x>eps;
}

template<class T>
	T sqr(T a){ return a*a; }

struct Tpoint{
	double x, y;
	
	Tpoint(double _x=0.0, double _y=0.0):
		x(_x), y(_y){}
		
	void read(){
		cin>>x>>y;
	}
	
	Tpoint operator+(const Tpoint &b)const{
		return Tpoint(x+b.x, y+b.y);
	}
	
	Tpoint operator-(const Tpoint &b)const{
		return Tpoint(x-b.x, y-b.y);
	}
	
	double operator*(const Tpoint &b)const{
		return x*b.y - y*b.x;
	}
	
} S, T, p[N];

double dis(Tpoint a, Tpoint b){
	return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));
}

int n;

void cross(Tpoint a, Tpoint b, Tpoint c, Tpoint d, vector<pair<Tpoint,int> > &s, int id){
	double
		s1=(c-a)*(b-a),
		s2=(d-a)*(b-a),
		s3=(a-d)*(c-d),
		s4=(b-d)*(c-d);
	if ( sign(s1*s2)<=0 && sign(s3*s4)<=0 );else return;
	Tpoint p;
	p.x=(a.x*s4-b.x*s3)/(s4-s3);
	p.y=(a.y*s4-b.y*s3)/(s4-s3);
	TR(s,q)
		if ( !sign(p.x-q->fi.x) && !sign(p.y-q->fi.y) )
			return;
	s.pb(mk(p,id));
}

int main(){
	
	S.read(); T.read();
	
	cin>>n;
	Rep(i,1,n) p[i].read();
	p[n+1]=p[1];
	
	vector<pair<Tpoint,int> > aa;
	Rep(i,1,n)
		cross(S,T,p[i],p[i+1],aa,i);
	int cnt[3]={0,0,0};
	Rep(i,1,n)
		cnt[sign((T-S)*(p[i]-S))+1]++;

	if (sz(aa)<2 || cnt[0]==0 || cnt[2]==0)
		return printf("%.7lf\n",dis(S,T)), 0;
	
	Tpoint S1=aa[0].fi, T1=aa[1].fi;
	int id0=aa[0].se, id1=aa[1].se;
	
	if (dis(S1,S)>dis(T1,S)) swap(S1,T1), swap(id0, id1);
	
	double ans=dis(S,S1)+dis(T1,T)+2*dis(S1,T1), tmp=0.0, tot=0.0;
	
	Rep(i,1,n) tot+=dis(p[i], p[i+1]);
	
	Tpoint now;
	for(now=S1; id0!=id1; id0=id0%n+1){
		tmp+=dis(now, p[id0+1]);
		now=p[id0+1];
	}
	tmp+=dis(now,T1);
	
	printf("%.7lf\n",min(ans, min(tmp, tot-tmp)+dis(S,S1)+dis(T1,T) ));
		
    return 0;
}
