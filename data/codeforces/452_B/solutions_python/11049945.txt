import sys

sys.setrecursionlimit(10 ** 6)

def pyes_no(condition) :
  if condition :
    print ("YES")
  else :
    print ("NO")

def plist(a, s = ' ') :
  print (s.join(map(str, a)))

def rint() :
  return int(sys.stdin.readline())

def rints() :
  return map(int, sys.stdin.readline().split())

def rfield(n, m = None) :
  if m == None :
    m = n
  
  field = []
  for i in xrange(n) :
    chars = sys.stdin.readline().strip()
    assert(len(chars) == m)
    field.append(chars)
  return field

def pfield(field, separator = '') :
  print ('\n'.join(map(lambda x: separator.join(x), field)))

def check_field_equal(field, i, j, value) :
  if i >= 0 and i < len(field) and j >= 0 and j < len(field[i]) :
    return value == field[i][j]
  return None 

def digits(x, p) :
  digits = []
  while x > 0 :
    digits.append(x % p)
    x //= p
  return digits

def modpower(a, n, mod) :
  r = a ** (n % 2)
  if n > 1 :
    r *= modpower(a, n // 2, mod) ** 2
  return r % mod

def gcd(a, b) :
  if a > b :
    a, b = b, a
  
  while a > 0 :
    a, b = b % a, a

  return b

def vector_distance(a, b) :
  diff = vector_diff(a, b)
  
  return scalar_product(diff, diff) ** 0.5

def vector_inverse(v) :
  r = [-x for x in v]

  return tuple(r)

def vector_diff(a, b) :
  return vector_sum(a, vector_inverse(b))

def vector_sum(a, b) :
  r = [c1 + c2 for c1, c2 in zip(a, b)]
    
  return tuple(r)

def scalar_product(a, b) :
  r = 0
  for c1, c2 in zip(a, b) :
    r += c1 * c2

  return r

from itertools import permutations

n, m = rints()
assert((n + 1) * (m + 1) >= 4)

def best_order(points) :
  orders = []
  for ordered_points in permutations(points) :
    r = 0
    for first, second in zip(ordered_points, ordered_points[1:]) :
      r += vector_distance(first, second)
    orders.append((r, ordered_points))
  return max(orders)

variants = []

if n >= 3 :
  variants.append((
    (0, 0),
    (1, 0),
    (n, 0),
    (n - 1, 0),
  ))

if m >= 3 :
  variants.append((
    (0, 0),
    (0, 1),
    (0, m),
    (0, m - 1),
  ))

if n >= 1 and m >= 1 :
  variants.append((
    (0, 0),
    (0, m),
    (n, 0),
    (n, m),
  ))
  variants.append((
    (0, 0),
    (0, 1),
    (n, m),
    (n - 1, m),
  ))
  variants.append((
    (0, 0),
    (0, 1),
    (n, m),
    (n, m - 1),
  ))
  variants.append((
    (0, 0),
    (1, 0),
    (n, m),
    (n, m - 1),
  ))
  variants.append((
    (0, 0),
    (1, 0),
    (n, m),
    (n - 1, m),
  ))
  

orders = [best_order(v) for v in variants]
best = max(orders)[1]

for x, y in best :
  print x, y 
