import math

n, m = map(int, raw_input().split())

def near(P):
  return [(P[0]+dx, P[1]+dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1]]

def inside(P):
  return 0<=P[0]<=n and 0<=P[1]<=m

def score(P):
  if not P:
    return 0

  for i in range(len(P)):
    for j in range(i+1, len(P)):
      if P[i][0] == P[j][0] and P[i][1]==P[j][1]:
        return 0

  for i in range(len(P)):
    if not (0 <= P[i][0] <= n and 0<=P[i][1]<=m):
      return 0

  ans = 0
  for i in range(len(P)-1):
    dx = P[i+1][0] - P[i][0]
    dy = P[i+1][1] - P[i][1]
    ans += math.sqrt(dx*dx + dy*dy)
  return ans

A = near([0, 0]) + near([n, 0]) + near([0, m]) + near([n, m])
A = filter(inside, A)

best_set = None
for i in range(len(A)):
  for j in range(len(A)):
    for k in range(len(A)):
      for l in range(len(A)):
        cand = [A[i], A[j], A[k], A[l]]
        myscore = score(cand)
        if myscore > score(best_set):
          best_set = cand

print "%d %d\n%d %d\n%d %d\n%d %d" % (
    best_set[0][0], best_set[0][1],
    best_set[1][0], best_set[1][1],
    best_set[2][0], best_set[2][1],
    best_set[3][0], best_set[3][1])
