#include <cstdlib>
#include <cctype>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <fstream>
#include <numeric>
#include <iomanip>
#include <bitset>
#include <list>
#include <stdexcept>
#include <functional>
#include <utility>
#include <ctime>
#include <cassert>
#include <complex>
using namespace std;
#define rep(i,a,n) for (int i=a;i<(int)n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
#define ACCU accumulate
#define TWO(x) (1<<(x))
#define TWOL(x) (1ll<<(x))
#define clr(a) memset(a,0,sizeof(a))
#define POSIN(x,y) (0<=(x)&&(x)<n&&0<=(y)&&(y)<m)
#define PRINTC(x) printf("Case #%d: %d\n",++__,x)
typedef vector<int> VI;
typedef vector<string> VS;
typedef vector<double> VD;
typedef long long ll;
typedef long double LD;
typedef pair<int,int> PII;
typedef pair<ll,ll> PLL;
typedef vector<ll> VL;
typedef vector<PII> VPII;
typedef complex<double> CD;
const int inf=0x20202020;
const ll mod=1000000007;
const double eps=1e-9;
const double pi=3.1415926535897932384626;
const int DX[]={1,0,-1,0},DY[]={0,1,0,-1};
ll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll powmod(ll a,ll b,ll mod) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}
// head
typedef pair<ll,int> PLI;

void upd(PLI &u,PLI v) { if (u<v) u=v;}
const int N=301000;
ll ans;
struct tree {
	int n,maxp,u,v;
	int q[N],f[N],vis[N],sz[N],ms[N];
	VI e[N];
	ll dp[N],sump,v1,v2,ans;
	PLI u1,u2,pu1,pu2;
	PII ansp;
	void add(int u,int v) { e[u].pb(v),e[v].pb(u);}
	void input() {
		rep(i,1,n) scanf("%d%d",&u,&v),add(u,v);
	}
	void dfs1(int u,int p,int dep) {
		dp[1]+=dep;
		sz[u]=1;
		rep(j,0,SZ(e[u])) {
			int v=e[u][j];
			if (v==p) continue;
			dfs1(v,u,dep+1);
			sz[u]+=sz[v];
		}
	}
	void dfs2(int u,int p) {
		rep(j,0,SZ(e[u])) {
			int v=e[u][j];
			if (v==p) continue;
			dp[v]=dp[u]+n-sz[v]*2;
			dfs2(v,u);
		}
	}
	void precalc() {
		dfs1(1,0,0);
		dfs2(1,0);
		maxp=1;
		sump=0;
		rep(i,1,n+1) {
			if (dp[i]>=dp[maxp]) maxp=i;
			sump+=dp[i];
		}
	}
	void clear() {
		rep(i,1,n+1) e[i].clear();
		dp[1]=n=0;
	}
	int find(int u) {
		int t=1;q[0]=u;f[u]=-1;
		rep(i,0,t) {
			u=q[i];
			rep(j,0,e[u].size()) {
				int v=e[u][j];
				if (!vis[v]&&v!=f[u]) f[q[t++]=v]=u;
			}
			ms[q[i]]=0;
			sz[q[i]]=1;
		}
		for (int i=t-1;i>=0;i--) {
			ms[q[i]]=max(ms[q[i]],t-sz[q[i]]);
			if (ms[q[i]]*2<=t) return q[i];
			sz[f[q[i]]]+=sz[q[i]];
			ms[f[q[i]]]=max(ms[f[q[i]]],sz[q[i]]);
		}
		return 0;
	}
	void dfs3(int u,int f,int dep) {
		upd(u1,mp(dp[u]*v1+dep*v1*v2,u));
		upd(u2,mp(dp[u]*v2+dep*v1*v2,u));
		rep(i,0,SZ(e[u])) {
			int v=e[u][i];
			if (v==f||vis[v]) continue;
			dfs3(v,u,dep+1);
		}
	}
	void dfs(int u) {
		u=find(u);
		vis[u]=1;
		pu1=mp(dp[u]*v1,u);
		pu2=mp(dp[u]*v2,u);
		rep(i,0,SZ(e[u])) {
			int v=e[u][i];
			if (vis[v]) continue;
			u1=mp(dp[u]*v1,u);
			u2=mp(dp[u]*v2,u);
			dfs3(v,u,1);
			if (pu1.fi+u2.fi>ans) ans=pu1.fi+u2.fi,ansp=mp(pu1.se,u2.se);
			if (pu2.fi+u1.fi>ans) ans=pu2.fi+u1.fi,ansp=mp(u1.se,pu2.se);
			upd(pu1,u1);
			upd(pu2,u2);
		}
		rep(i,0,SZ(e[u])) {
			int v=e[u][i];
			if (vis[v]) continue;
			dfs(v);
		}
	}
	PII solve(int p1,int p2) {
		v1=p1;v2=p2;
		ans=dp[1]*(p1+p2);
		ansp=mp(1,1);
		dfs(1);
		return ansp;
	}
}t[3],T;
void calc(int p1,int p2,int p3) {
	PII pr=t[p1].solve(t[p2].n,t[p3].n);
	T.clear();
	rep(i,1,t[p1].n+1) rep(j,0,SZ(t[p1].e[i])) {
		T.e[i+T.n].pb(t[p1].e[i][j]+T.n);
	}
	T.n+=t[p1].n;
	rep(i,1,t[p2].n+1) rep(j,0,SZ(t[p2].e[i])) {
		T.e[i+T.n].pb(t[p2].e[i][j]+T.n);
	}
	T.n+=t[p2].n;
	rep(i,1,t[p3].n+1) rep(j,0,SZ(t[p3].e[i])) {
		T.e[i+T.n].pb(t[p3].e[i][j]+T.n);
	}
	T.n+=t[p3].n;
	T.add(pr.fi,t[p2].maxp+t[p1].n);
	T.add(pr.se,t[p3].maxp+t[p1].n+t[p2].n);
	T.precalc();
	ans=max(ans,T.sump);
}
int main() {
	rep(i,0,3) scanf("%d",&t[i].n);
	rep(i,0,3) t[i].input(),t[i].precalc();
	calc(0,1,2);
	calc(1,0,2);
	calc(2,0,1);
	printf("%I64d\n",ans/2);
}
