#include <iostream>
#include <sstream>
#include <fstream>
#include <string>
#include <vector>
#include <deque>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <algorithm>
#include <functional>
#include <utility>
#include <bitset>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstdio>

using namespace std;

#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)
#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)

typedef long long ll;

vector <int> graph[100010];
ll sum[100010];
ll depth[100010];
ll cnt[100010];
ll dp1[100010],dp2[100010];
ll P,Q,BEST;

void dfs3(int p, int x){
    int i;
    
    BEST = max(BEST, sum[x] * (P + Q));
    
    dp1[x] = dp2[x] = 0;
    
    REP(i,graph[x].size()){
        int y = graph[x][i];
        if(y != p){
            dfs3(x, y);
            dp1[x] = max(dp1[x], dp1[y] + P);
            dp2[x] = max(dp2[x], dp2[y] + Q);
            BEST = max(BEST, P * sum[x] + Q * dp1[x]);
            BEST = max(BEST, Q * sum[x] + P * dp2[x]);
        }
    }
    
    vector <pair <ll, ll> > v;
    REP(i,graph[x].size()){
        int y = graph[x][i];
        if(y != p) v.push_back(make_pair(P * (dp2[y] + Q), Q * (dp1[y] + P)));
    }
    
    int sz = v.size();
    if(sz >= 2){
        int p = 0, q = 0;
        REP(i,sz) if(v[i].first > v[p].first) p = i;
        REP(i,sz) if(v[i].second > v[q].second) q = i;
        REP(i,sz) if(p != i) BEST = max(BEST, v[p].first + v[i].second);
        REP(i,sz) if(q != i) BEST = max(BEST, v[i].first + v[q].second);
    }
    
//  cout << x << endl;
//  REP(i,sz) cout << v[i].first << ' ' << v[i].second << ' ';
//  cout << endl;
    
    dp1[x] = max(dp1[x], sum[x]);
    dp2[x] = max(dp2[x], sum[x]);
    
    // cout << x << ' ' << dp1[x] << ' ' << dp2[x] << endl;
    // BEST = max(BEST, dp1[x] * Q + dp2[x] * P);
}

void dfs(int p, int x, int d){
    depth[x] = d;
    cnt[x] = 1;
    int i;
    REP(i,graph[x].size()){
        int y = graph[x][i];
        if(y != p){
            dfs(x, y, d+1);
            cnt[x] += cnt[y];
        }
    }
}

ll n;

void dfs2(int p, int x, ll s){
    sum[x] = s;
    int i;
    REP(i,graph[x].size()){
        int y = graph[x][i];
        if(y != p){
            dfs2(x, y, s + n - 2 * cnt[y]);
        }
    }
}

pair <ll, pair <ll, ll> > func(int N, int A, int B){
    int i,j;
    
    REP(i,N) graph[i].clear();
    REP(i,N-1){
        int a,b;
        scanf("%d%d", &a, &b);
        a--; b--;
        graph[a].push_back(b);
        graph[b].push_back(a);
    }
    
    n = N;
    P = A; Q = B; BEST = 0;
    dfs(-1, 0, 0);
    
    REP(i,N) sum[i] = 0;
    REP(i,N) sum[0] += depth[i];
    dfs2(-1, 0, sum[0]);
    
    ll ans1 = 0;
    REP(i,N) ans1 += sum[i];
    ans1 /= 2;
    
    ll ans2 = 0;
    REP(i,N) ans2 = max(ans2, sum[i]);
    
    dfs3(-1, 0);
    ll ans3 = BEST;
    
    // cout << ans1 << ' ' << ans2 << ' ' << ans3 << ' ' << dp1[1] << ' ' << dp2[1] << endl;
    
    // cout << ans1 << ' ' << ans2 << ' ' << ans3 << endl;
    
    return make_pair(ans1, make_pair(ans2, ans3));
}

int main(void){
    ll A,B,C;
    ll X,Y,Z,X2,Y2,Z2;
    ll ans = 0;
    
    cin >> A >> B >> C;
    pair <ll, pair <ll, ll> > p = func((int)A, (int)B, (int)C);
    ans += p.first;
    X = p.second.first;
    X2 = p.second.second;
    p = func((int)B, (int)C, (int)A);
    ans += p.first;
    Y = p.second.first;
    Y2 = p.second.second;
    p = func((int)C, (int)A, (int)B);
    ans += p.first;
    Z = p.second.first;
    Z2 = p.second.second;
    
    ll tmp1 = A * (Y + Z + B + C) + 2 * B * C + C * Y + B * Z + X2;
    ll tmp2 = B * (Z + X + C + A) + 2 * C * A + A * Z + C * X + Y2;
    ll tmp3 = C * (X + Y + A + B) + 2 * A * B + B * X + A * Y + Z2;
    cout << max(tmp1, max(tmp2, tmp3)) + ans << endl;
    
    return 0;
}
