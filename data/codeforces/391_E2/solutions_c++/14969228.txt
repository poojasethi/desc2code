#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#define each(u) for (int e=head[u],v=li[e].v;e;e=li[e].la,v=li[e].v)
#define N 300010
#define LL long long
using namespace std;
int m;
int head[N],cnt_li;
struct LI {int la,v;}li[N<<1];
void add(int a,int b) {li[++cnt_li]=(LI){head[a],b}; head[a]=cnt_li;}
int size[N],fa[N];
LL f[N],h[N],down[N];
pair<LL,LL> g[N];
struct Tree {
	int n,C,first;
	LL sum;	
	void dfs1(int u) {
		size[u]=1;
		each(u) if (v!=fa[u]) {
			fa[v]=u;
			dfs1(v);
			sum+=(LL)size[v]*(n-size[v]);
			size[u]+=size[v];
			f[u]+=f[v]+size[v];
		}
	}
	void dfs2(int u) {
		each(u) if (v!=fa[u]) {
			down[v]=down[u]+f[u]-(f[v]+size[v])+n-size[v];
			dfs2(v);
		}
	}
	void run(int s) {
		first=s+1;
		m+=n;
		for (int i=1,a,b;i<n;++i) scanf("%d%d",&a,&b),a+=s,b+=s,add(a,b),add(b,a);
		fa[s+1]=0;
		dfs1(s+1);
		dfs2(s+1);
		C=s+1;
		
		for (int i=s+1;i<=m;++i) {f[i]+=down[i]; if (f[i]>f[C]) C=i;}
	}
}T[4];

LL sum,ans;
int A,B;
void update(pair<LL,LL> &a,LL b) {
	if (b>a.first) a.second=a.first,a.first=b;
	else if (b>a.second) a.second=b;
}
void dfs1(int u) {
	g[u]=make_pair(B*f[u],0);
	each(u) if (v!=fa[u]) {
		fa[v]=u;
		dfs1(v);
		update(g[u],g[v].first+(LL)A*B);
	}
	sum=max(sum,f[u]*A+g[u].first);
}
void dfs2(int u) {
	sum=max(sum,f[u]*A+h[u]);
	each(u) if (v!=fa[u]) {
		h[v] = g[u].first==g[v].first+(LL)A*B? g[u].second:g[u].first;
		h[v]=max(h[v],h[u]);
		h[v]+=(LL)A*B;
		dfs2(v);
	}
}
void run(int a,int b,int c) {
	sum=0;
	fa[T[b].first]=0;
	A=T[a].n,B=T[c].n;
	dfs1(T[b].first);
	dfs2(T[b].first);
	ans=max(ans,(f[T[a].C]+T[a].n)*(T[b].n+T[c].n)+(f[T[c].C]+T[c].n)*(T[a].n+T[b].n)+sum);
}

int main()
{
//	freopen("trees.in","r",stdin);
//	freopen("trees.out","w",stdout);
while (scanf("%d%d%d",&T[1].n,&T[2].n,&T[3].n)==3) {
	memset(head,0,sizeof(head)); cnt_li=0; ans=0; m=0;
	T[1].run(0),T[2].run(T[1].n),T[3].run(T[1].n+T[2].n);

	run(1,2,3);
	run(1,3,2);
	run(2,1,3);
	printf("%I64d\n",ans+T[1].sum+T[2].sum+T[3].sum);

}
	return 0;
}
