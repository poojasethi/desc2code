#include<cstdio>
#include<cstring>
#include<algorithm>
#include<set>
#include<vector>
#include<map>
#include<queue>
#include<string>
#include<bitset>
#include<iomanip>
#include<iostream>
#include<cmath>
using namespace std;
#define rep(i,x,y) for(i=x;i<=y;i++)
#define _rep(i,x,y) for(i=x;i>=y;i--)
#define REP(i,x,y) for(int i=(x);i<=(y);i++)
#define _REP(i,x,y) for(int i=(x);i>=(y);i--)
#define CL(S,x) memset(S,x,sizeof(S))
#define CP(S1,S2) memcpy(S1,S2,sizeof(S2))
#define ALL(x,S) for(x=S.begin();x!=S.end();x++)
#define pb push_back
#define IN insert
#define ER erase
#define BE begin()
#define ED end() 
#define LB lower_bound
#define UB upper_bound
#define mp make_pair
#define fi first
#define se second
#define upmin(x,y) x=min(x,y)
#define upmax(x,y) x=max(x,y)
#define COUT(S,x) cout<<fixed<<setprecision(x)<<S<<endl
template<class T> inline void read(T&x){bool fu=0;char c;for(c=getchar();c<=32;c=getchar());if(c=='-')fu=1,c=getchar();for(x=0;c>32;c=getchar())x=x*10+c-'0';if(fu)x=-x;};
template<class T> inline void read(T&x,T&y){read(x);read(y);}
template<class T> inline void read(T&x,T&y,T&z){read(x);read(y);read(z);}
inline char getc(){char c;for(c=getchar();c<=32;c=getchar());return c;}

typedef long long ll;
typedef long double ld;
typedef pair<ll,ll> pii;

const int N=200010;
const ll INF=ll(1e18);
ll n[4],n1,n2,n3,S1,S3,i,j,k,ans,rest,best;
struct graph
{
	ll n,i,j,k,l,p,maxS,tot;
	ll edge,e[N<<1],b[N<<1],fir[N];
	ll S[N],szt[N],sz[N],fa[N];
	ll st[N],dep[N];
	pii key[N],key2[N];
	
	void add(int x,int y){e[++edge]=y;b[edge]=fir[x];fir[x]=edge;}
	void dfs(int i,int f){
		sz[i]=1;fa[i]=f;
		for(int u,k=fir[i];u=e[k],k;k=b[k])if(u!=f)
		dfs(u,i),sz[i]+=sz[u],szt[i]+=szt[u]+sz[u];
	}
	void dfs2(int i,ll s){
		S[i]=s;
		for(int u,k=fir[i];u=e[k],k;k=b[k])if(u!=fa[i])
		dfs2(u,s+(n-sz[u])-sz[u]);
	}
	void init(ll n0){
		n=n0;
		int x,y;
		rep(i,1,n-1)read(x,y),add(x,y),add(y,x);
		dfs(1,0);
        dfs2(1,szt[1]);
		rep(i,1,n)tot+=(n-sz[i])*sz[i];
		rep(i,1,n)upmax(maxS,S[i]);
	}
	
	pii A(pii a){return mp(a.fi+n1*n3,a.se);}
	pii C(pii a,ll t){return mp(a.fi,t);}
	void upd(int i,pii u)
    {
        if(u.se==key[i].se)upmax(key[i],u);
        else if(u>=key[i])key2[i]=key[i],key[i]=u;else if(u>=key2[i])key2[i]=u;
    }
	void go(int i,int f)
	{
		dep[i]=dep[f]+1;
		key[i]=mp(S[i]*n3,i);key2[i]=mp(-INF,i);
		for(int k=fir[i];k;k=b[k])if(e[k]!=f)
        {
            go(e[k],i);
            upd(i,C(A(key[e[k]]),e[k]));
            upd(i,C(A(key2[e[k]]),e[k]));
        }
	}
	void tour(int i,pii p)
	{
        upmax(rest,n1*S[i]+max(p,key[i]).fi);
        pii tt;
        for(int u,k=fir[i];u=e[k],k;k=b[k])if(u!=fa[i])
        {
            if(u==key[i].se)tt=A(max(p,key2[i]));
            else tt=A(max(p,key[i]));
            tour(e[k],tt);
        }
    }
	void _solve(){
		int R,i,j,k;
		dep[0]=-1;
		rep(R,1,n){
			go(R,0);
			rep(i,1,n)
			upmax(rest,S[R]*n1+S[i]*n3+n1*n3*dep[i]);
		}
	}
	void solve(){
        go(1,0);
        tour(1,mp(0,0));
    }
}G[4];
int main()
{
    //freopen("a.in","r",stdin);freopen("a.out","w",stdout);
	int i,j,k;
	rep(i,1,3)read(n[i]);
	rep(i,1,3)
    G[i].init(n[i]);
	rep(i,1,3)rep(j,1,3)rep(k,1,3)if(i!=j&&i!=k&&j!=k){
		S1=G[i].maxS;n1=G[i].n;
		S3=G[k].maxS;n3=G[k].n;
		n2=G[j].n;
		ans=G[1].tot+G[2].tot+G[3].tot;
		ans+=n2*(n1+n3)+n1*S3+n3*S1+n2*(S1+S3)+2*n1*n3;
		rest=0;
		G[j].solve();
		upmax(best,ans+rest);
	}
	cout<<best<<endl;
    return 0;
}
