#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <queue>
#include <string>
#include <sstream>
#include <iostream>
#include <set>
#include <map>
#include <cassert>
#include <bitset>

#define REP(AA,BB) for(int AA=0; AA<(BB); ++AA)
#define FOR(AA,BB,CC) for(int AA=(BB); AA<(CC); ++AA)
#define FC(AA,BB) for(__typeof((AA).begin()) BB=(AA).begin(); BB!=(AA).end(); ++BB)
#define SZ(AA) ((int)((AA).size()))
#define ALL(AA) (AA).begin(), (AA).end()
#define PB push_back
#define MP make_pair

using namespace std;

typedef vector<int> VI;
typedef pair<int, int> PII;
typedef long long LL;
typedef long double LD;

const int MAXN = 150, MAXM = 100000;
typedef bitset<MAXN> bset;

bset W[MAXN + 10];
bset cur[MAXN + 10], tmp[MAXN + 10], final[MAXN + 10];
char buf[MAXN + 10], seq[MAXM + 10];

int main(void) {
    int n, m, K; scanf("%d%d%d", &n, &m, &K);
    REP (i, n) {
        scanf("%s", buf);
        REP (j, m) {
            if (buf[j] == '#') {
                W[i][j] = 1;
            } else {
                cur[i][j] = 1;
                if (buf[j] == 'E') {
                    final[i][j] = 1;
                }
            }
        }
    }
    scanf("%s", seq);
    REP (f, K + 1) {
        bool ok = true;
        REP (i, n) {
            if (cur[i] != final[i]) {
                ok = false;
            }
        }
        /*
        REP (i, n) {
            cerr << cur[i] << endl;
        }
        cerr << endl;*/
        if (ok) {
            printf("%d\n", f);
            return 0;
        }
        if (f == K) {
            break;
        }
        REP (i, n) {
            tmp[i].reset();
        }
        if (seq[f] == 'R') {
            REP (i, n) {
                bset w = cur[i] & (W[i] >> 1);
                tmp[i] = ((cur[i] ^ w) << 1) | w;
            }
        } else if (seq[f] == 'L') {
            REP (i, n) {
                bset w = cur[i] & (W[i] << 1);
                tmp[i] = ((cur[i] ^ w) >> 1) | w;
            }
        } else if (seq[f] == 'U') {
            FOR (i, 1, n) {
                bset w = cur[i] & (W[i - 1]);
                tmp[i] |= w;
                tmp[i - 1] |= (cur[i] ^ w);
            }
        } else if (seq[f] == 'D') {
            REP (i, n - 1) {
                bset w = cur[i] & (W[i + 1]);
                tmp[i] |= w;
                tmp[i + 1] |= (cur[i] ^ w);
            }
        }
        REP (i, n) {
            cur[i] = tmp[i];
        }
    }
    printf("%d\n", -1);
    return 0;
}


