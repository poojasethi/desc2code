#include <cstdio>
#include <cstring>
#include <algorithm>
#include <bitset>
using namespace std;
char s[100005];
int n, m, k;
int work(){
	bitset<23000> a, b, c, e;
	for(int i = 0; i < n; i++)
	{
		scanf("%s", s);
		for(int j = 0; j < m; j++)
		{
			(s[j]=='#'?b:a).set(i*m+j);
			(s[j]=='E'?e.set(i*m+j):0);
		}
	}
	scanf("%s", s);
	c = a;
	for(int i = 0; i < k; i++)
	{
		if(c==e)return i;
		if(s[i]=='U') c = ((c>>m)&a) | (c&(b<<m));
		if(s[i]=='L') c = ((c>>1)&a) | (c&(b<<1));
		if(s[i]=='D') c = ((c<<m)&a) | (c&(b>>m));
		if(s[i]=='R') c = ((c<<1)&a) | (c&(b>>1));
	}
	if(c==e)return k;
	return -1;
}
int main(){
	int i, j;
	while (~scanf("%d %d %d", &n, &m, &k)){
		printf("%d\n", work());
	}
	return 0;
}




/*
#include <cstdio>
#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;
typedef long long ll;
const int N = 50005;
#define L(x) (x<<1)
#define R(x) (x<<1|1)
#define Lson(x) tree[x].l
#define Rson(x) tree[x].r
#define Oldsum(x) tree[x].oldsum
#define Nowsum(x) tree[x].nowsum
inline int Mid(int x, int y){return (x+y)>>1;}
struct node{
int l, r;
int oldsum, nowsum;
}tree[N<<2];
void build(int l, int r, int id){
Lson(id) = l; Rson(id) = r;
Oldsum(id) = Nowsum(id) = 0;
if(l == r)return ;
int mid = Mid(l, r);
build(1, mid, L(id));
build(mid+1, r, R(id));
}




int n, m, a[N];
struct Q{
int l, r, ans, num;
}q[N];
bool cmp(Q x, Q y){return x.r < y.r;}
bool cmp(Q x, Q y){return x.num < y.num;}
void input(){
for(int i = 1; i <= n; i++)scanf("%d",&a[i]);
scanf("%d",&m);
for(int i = 1; i<= m; i++)scanf("%d %d",&q[i].l, &q[i].r), q[i].num = i;
sort(q+1, q+m+1);
}
int main() {
while (~scanf("%d",&n)) {
input();
build(1, n, 1);

}
return 0;
}
/**/
		   	  		 	 	    				  	