from collections import Counter, namedtuple
from operator import itemgetter
from itertools import groupby

Stat = namedtuple('Stat', ['start', 'end', 'counts'])

def fill_combinations(depth):
    combinations = [Stat(start='1', end='1', counts=Counter('1')), Stat(start='2', end='2', counts=Counter('2'))]
    for index in range(depth - 2):
        combination = Stat(start=combinations[-2].start,
             end=combinations[-1].end,
             counts=combinations[-2].counts + combinations[-1].counts
        )
        combination.counts[(combinations[-2].end, combinations[-1].start)] += 1
        combinations.append(combination)
    return combinations

def string_combinations(size):
    if size == 1:
        yield ('A', 0)
        yield ('B', 0)
        yield ('C', 0)
    else:
        for ac_root_count in range(size - 2 + 1):
            for order in [1,-1]:
                for previous in ['A', 'C']:
                    corpus = ['B'] * (size - 2)
                    indexes = range(ac_root_count) if order == 1 else range(size - 2 - 1,size - 2 - 1 - ac_root_count, -1)
                    for index in indexes:
                        corpus[index] = 'A' if previous == 'C' else 'C'
                        previous = corpus[index]
                    for first_letter in ['A', 'B', 'C']:
                        for last_letter in ['A', 'B', 'C']:
                            result = [first_letter] + corpus + [last_letter]
                            result = ''.join(result)
                            ac_count = result.count('AC')
                            yield (result, ac_count)

def uniq_combinations(size):
    found = set()
    for combination, ac_count in string_combinations(size):
        key = tuple((combination[0], combination[-1], ac_count))
        if key not in found:
            found.add(key)
            yield combination, ac_count

def find_solution(stat, counts, size_s1, size_s2):
    s1_combinations = list(uniq_combinations(size_s1))
    s2_combinations = list(uniq_combinations(size_s2))
    for s1, s1_ac in s1_combinations:
        for s2, s2_ac in s2_combinations:
            value = 0
            value += stat.counts['1'] * s1_ac
            value += stat.counts['2'] * s2_ac
            value += stat.counts[('1', '2')] * int(s1[-1] == 'A' and s2[0] == 'C')
            value += stat.counts[('2', '1')] * int(s2[-1] == 'A' and s1[0] == 'C')
            value += stat.counts[('2', '2')] * int(s2[-1] == 'A' and s2[0] == 'C')
            if value == counts:
                return [s1, s2]
    return None

def compose_letter(depth, counts, size_s1, size_s2):
    combinations = fill_combinations(depth)    
    solution = find_solution(combinations[-1], counts, size_s1, size_s2)
    return solution if solution is not None else ['Happy new year!']

def main():
    depth, counts, size_s1, size_s2 = map(int, raw_input().split())
    for x in compose_letter(depth, counts, size_s1, size_s2):
        print x

if __name__ == '__main__':
    main()
