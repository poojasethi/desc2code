#include <bits/stdc++.h>
using namespace std;

const int MAX = 100100;

vector< vector<int> > g, t;

int tree[MAX], depth[MAX];
int N,q, root, v1, v2, v, val, dist;

void dfs(int v, int d, int num, int p) {
	tree[v]=num;
	depth[v]=d;
	t[num].push_back(0);
	for(int i = 0;i<g[v].size();i++) {
		int to=g[v][i];
		
		if (to==p) continue;
		d++; dfs(g[v][i],d,num,v);
	}
	return;
}

void add(int p, int v, int num) {
	for (int i=p; i<t[num].size(); i+=(i&(-i)))
		t[num][i]+=v;
	return;
}

int query(int p, int num) {
	int res=0;
	for (int i=p; i>0; i-=(i&(-i)))
		res+=t[num][i];
	return res;
}

void construct() {
	g.resize(N);
	for(int i = 0;i<N-1;i++) {
		scanf("%d%d",&v1,&v2);
		v1--; v2--;
		
		g[v1].push_back(v2);
		g[v2].push_back(v1);
	}

	t.resize(g[0].size()+1);
	root=0;

	for(int i = 0;i<g[0].size();i++) {
		t[i].push_back(0);
		dfs(g[0][i],1,i,0);
	}

	t[t.size()-1].resize(N+10);
	
	return;
}

void solve() {
	for(int i = 0;i<q;i++) {
		int ty;
		scanf("%d",&ty);
		if (ty==0) {
			scanf("%d%d%d",&v,&val,&dist);
			v--;
			if (v==0) {
				root+=val;
				add(1,val,t.size()-1);
				add(dist+1,-val,t.size()-1);
			} else {
				if (dist>=depth[v]) {
					int left=dist-depth[v];
					root+=val;
					add(1,val,t.size()-1);
					add(left+1,-val,t.size()-1);
					add(left+1,val,tree[v]);
					add(depth[v]+dist+1,-val,tree[v]);
				} else {
					add(depth[v]-dist,val,tree[v]);
					add(depth[v]+dist+1,-val,tree[v]);
				}
			}
		} else {
			scanf("%d",&v); v--;

			if (v==0) printf("%d\n",root);
			else {
				int res=query(depth[v],tree[v])+query(depth[v],t.size()-1);
				printf("%d\n",res);
			}
		}
	}
	return;
}

int main() {
	scanf("%d%d",&N,&q);
	construct();
	solve();
	return 0;
}