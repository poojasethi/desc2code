#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
#define N 100011

int bit[2][N], head[N], tail[N], name[N], dist[N], n, z, D;
vector<int> adj[N];

int query(int x, int* bit)
{
	int r = 0;
	while (x)
	{
		r += bit[x];
		x -= x&-x;
	}
	return r;
}

void update(int x, int v, int* bit)
{
	while (x < N)
	{
		bit[x] += v;
		x += x&-x;
	}
}

void dfs(int p, int h, int d)
{
	if (name[p]) return;
	D = max(D, d);
	name[p] = z++;
	head[p] = h;
	dist[p] = d;
	for (int i = 0; i < adj[p].size(); ++i)
		dfs(adj[p][i], h, d+1);
}

int main()
{
	int q, t, v, x, d;
	scanf("%d%d", &n, &q);
	for (int i = 0; i < n-1; ++i)
	{
		int a, b; scanf("%d%d", &a, &b);
		adj[a].push_back(b);
		adj[b].push_back(a);
	}
	z = 2;
	name[1] = head[1] = 1;
	for (int i = 0; i < adj[1].size(); ++i)
	{
		int u = adj[1][i];
		dfs(u, z, 1);
		tail[name[u]] = z-1;
	}
	++D;
	while (q--)
	{
		scanf("%d", &t);
		if (t == 0)
		{
			scanf("%d%d%d", &v, &x, &d);
			// starting from node one
			int g = d-dist[v];
			if (g >= 0) update(max(1, D-g), x, bit[0]);
			// residual
			if (g >= 0) 
			{
				int cob = head[v]+g;
				if (cob <= tail[head[v]]) 
				{
					update(cob, x, bit[1]);
					update(min(tail[head[v]]+1, name[v]+d+1), -x, bit[1]);
				}
			}
			else 
			{
				update(name[v]-d, x, bit[1]);
				update(min(tail[head[v]]+1, name[v]+d+1), -x, bit[1]);
			}
		}
		else
		{
			scanf("%d", &v);
			int resa = query(D-dist[v], bit[0]);
			int resb = query(name[v], bit[1]);
			printf("%d\n", resa+resb);
			
		}
	}
}
