#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
typedef double db;
typedef pair<int,int> pii;
const int N=(int)1e5+5;
int n,q,r,cnt,val,l[N],t[N],s[N];
void add(int *t,int x,int d){
	for(;x;x-=x&-x) t[x]+=d;
}
int query(int *t,int x){
	int s=0; for(;x<=n;x+=x&-x) s+=t[x]; return s;
}
struct node;
struct edge{
	node *ed;
	edge *next;
} E[N<<1],*newE=E;
struct node{
	edge *son;
	bool vis;
	int r,loc;
} V[N];
int main(){
	scanf("%d%d",&n,&q);
	for(int i=1;i<n;i++){
		int u,v; scanf("%d%d",&u,&v);
		*newE=(edge){V+v,V[u].son},V[u].son=newE++;
		*newE=(edge){V+u,V[v].son},V[v].son=newE++;
	}
	V[1].vis=1;
	for(edge *ee=V[1].son;ee;ee=ee->next){
		++r;
		node *u=ee->ed;
		while(1){
			u->r=r;
			u->loc=++cnt;
			u->vis=1;
			if(!u->son->next) break;
			for(edge *e=u->son;e;e=e->next) if(!e->ed->vis)
				u=e->ed;
		}
		l[r]=cnt;
	}
	while(q--){
		int type,v; scanf("%d%d",&type,&v);
		if(type==0){
			int x,d; scanf("%d%d",&x,&d);
			add(t,min(V[v].loc+d,l[V[v].r]),x);
			add(t,max(V[v].loc-d-1,l[V[v].r-1]),-x);
			if(V[v].loc-d<=l[V[v].r-1]){
				val+=x;
				add(s,d-(V[v].loc-l[V[v].r-1]),x);
				add(t,l[V[v].r-1],x);
				add(t,min(l[V[v].r-1]+d-(V[v].loc-l[V[v].r-1]),l[V[v].r]),-x);
			}
		}
		else{
			printf("%d\n",v==1?val:query(t,V[v].loc)+query(s,V[v].loc-l[V[v].r-1]));
		}
	}
	scanf("\n");
}
