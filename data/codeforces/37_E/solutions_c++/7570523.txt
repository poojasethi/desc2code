#include <iostream>
#include <fstream>
#include <sstream>
#include <ctime>
#include <cmath>
#include <cctype>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cassert>
#include <algorithm>
#include <string>
#include <set>
#include <map>
#include <queue>
#include <stack>

using namespace std;

#define REP(i, n) for(int i(0); (i)<(int)(n); i++)

int n, m;
string s[55];
int d[55 * 55];
int dx[4] = {0, 0, -1, 1};
int dy[4] = {-1, 1, 0, 0};
int Q[55 * 55 * 2], head, tail;

int bfs(int sss) {
	memset(d, 0, sizeof(d));
	head = tail = 52 * 52;
	Q[tail++] = sss;
	d[sss] = 1;
	while (head != tail) {
		int i = Q[head++];
		int x = i / m;
		int y = i % m;
		REP(k, 4) {
			int xx = x + dx[k];
			int yy = y + dy[k];
			int ii = xx * m + yy;
			if (xx < 0 || xx >= n || yy < 0 || yy >= m || d[ii]) continue;
			//	printf("%d %d , %d %d %d %d %d , %c, %c\n", n, m, d[i], x, y, xx, yy, s[x][y], s[xx][yy]);
			if (s[x][y] == s[xx][yy]) {
				d[ii] = d[i];
				Q[--head] = ii;
			} else {
				d[ii] = d[i] + 1;
				Q[tail++] = ii;
			}
		}
	}
	int tmp = 0;
	REP(i, n) REP(j, m) {
		int t = i * m + j;
		if (s[i][j] == 'W')
			tmp = max(tmp, d[t] - 1);
		else
			tmp = max(tmp, d[t]);
	}
	return tmp;
}

int main() {
	cin >> n >> m;
	REP(i, n) cin >> s[i];
	int ans = 1e9;
	REP(i, n) REP(j, m) 
		ans = min(ans, bfs(i * m + j));
	cout << ans << endl;
}
	 	   		   	 			 				 		 	