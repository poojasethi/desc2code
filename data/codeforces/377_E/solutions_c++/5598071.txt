#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#include<queue>
#define INF 0x7fffffffffffffffLL 
#define MAXN 200005
#define Ask(xx, yy) (((xx)%(yy)==0)?(xx)/(yy):(xx)/(yy)+1)
typedef long long LL ;
using namespace std ;

struct state {
	LL l, r, k ;
} q[MAXN] ;
struct Build {
	LL val, cost ;
	void init() {scanf("%I64d %I64d", &val, &cost) ;}
	bool operator < (Build b) const {
		if(cost != b.cost) return cost < b.cost ;
		else return val > b.val ;
	}
} B[MAXN] ;

LL N, S ;
LL T[MAXN], rest[MAXN] ;
LL ans ;

pair<LL, LL> calc(LL b, LL a)
{
	LL tmp = max(0LL, B[b].cost-rest[a]) ;
	tmp = Ask(tmp, B[a].val) ;
	return make_pair(T[a]+tmp, -(tmp*B[a].val+rest[a]-B[b].cost)) ;
}

int main()
{
    int i, j, l, r, mid ;
    int in, get, f1, r1, sum ;
    pair<LL, LL> tmp ;
    scanf("%I64d %I64d", &N, &S) ;
    for(i = 1; i <= N; i ++)
    	B[i].init() ;
    sort(B+1, B+1+N) ;
    for(i = 1, j = 0; i <= N; i ++)
    	if(B[i].val > B[j].val) B[++j] = B[i] ;
    N = j ;
    
    f1 = 0, r1 = 1 ;
    T[1] = 0, rest[1] = 0, q[r1] = (state){2, N, 1} ;
    ans = Ask(S, B[1].val) ;
    for(i = 2; i <= N; i ++)
    {
        if(q[f1].r < i) f1 ++ ;
        else q[f1].l = i ;
        tmp = calc(i, q[f1].k) ;
        T[i] = tmp.first, rest[i] = -tmp.second ;
        ans = min(ans, T[i]+Ask(S-rest[i], B[i].val)) ;
        while(f1 <= r1)
        {
                if(calc(q[r1].l, i) <= calc(q[r1].l, q[r1].k)) r1 -- ;
                else break ;
        } in = r1 ;// 最后一个起点比I优的
        if(in < f1) get = q[f1].l ;
        else
        {
            q[in].r = N ;
            l = q[in].l, r = q[in].r ;
            while(l <= r)
            {
                mid = (l+r)/2 ;
                if(calc(mid, i) > calc(mid, q[in].k))
                    l = mid+1 ;
                else r = mid-1 ;
            } get = l ; // 第一个I优的 
            if(get > N) continue ;
        }
        if(r1 >= f1) q[r1].r = get-1 ;
        q[++r1] = (state){get, N, i} ;
    }
    printf("%I64d\n", ans) ;
    //system("pause") ;
    return 0 ;
}
