#include <map>
#include <cstdio>
#include <algorithm>
#define fr first
#define se second
#define D(_,__) ((_)/(__) + ((_)%(__) != 0))
#define F(_) D(pr[i].se - B[_], K[_])
#define G(_) (K[_] * F(_) + B[_] - pr[i].se)
using namespace std;

typedef long long LL;
typedef LL arr64[200020];

int n, tn, tS, qS = 1;
pair<int,LL> pr[200020];
arr64 pX, pY, K, B;

int main()
{
     LL s;
     scanf("%d%I64d", &n, &s);
     for (int i = 1; i <= n; i ++)
	  scanf("%d%d", &pr[i].fr, &pr[i].se);
     sort(pr+1, pr+n+1);
     pr[++n] = make_pair((int)1e9, s);
     for (int i = 1; i <= n; i ++)
	  if (i == 1 || pr[i].fr > pr[i-1].fr) {
	       while (tn > 0 && pr[i].se <= pr[tn].se) tn --;
	       pr[++tn] = pr[i];
	  }
     
     K[tS = 1] = pr[1].fr;
     for (int i = 2; i <= tn; i ++) {
	  qS = min(qS, tS);
	  while (qS < tS && (F(qS+1) < F(qS) || F(qS+1) == F(qS) && G(qS+1) >= G(qS))) qS ++;
	  LL cX = F(qS), cK = pr[i].fr;
	  LL cY = G(qS), cB = cY - cK * cX;
	  if (i == tn) printf("%I64d\n", cX);
	  
	  while (tS > 1 && cK * pX[tS-1] + cB >= pY[tS-1]) tS --;
	  K[++tS] = cK, B[tS] = cB;
	  pX[tS-1] = D((B[tS-1]-B[tS]), (K[tS]-K[tS-1]));
	  pY[tS-1] = cK * pX[tS-1] + cB;
     }
}
