#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<vector>
#include<set>
#include<map>
#include<queue>
#include<stack>
#include<ctime>
#include<cctype>
#define rep(i,n) for(int i=0; i<n; i++)
#define per(i,n) for(int i=n-1; i>=0; i--)
#define clr(a,h) memset(a, (h), sizeof(a))
#define foreach(e,x) for(__typeof(x.begin()) e=x.begin(); e!=x.end(); e++)
#define all(x) x.begin(), x.end()
#define pb push_back
#define mp make_pair
#define de(x) cout<<#x<<"="<<x<<endl
using namespace std;

typedef long long ll;
typedef long double ld;
typedef pair<int ,int > pi;
typedef pair< int , pi > pii;

const int maxn= 222222, inf=~0U>>1;

struct building {
    ll v, c;
    void read() { cin >> v >> c; }
    bool operator < (const building & o) const {return c < o.c || (c == o.c && v > o.v) ; }
} B[maxn];

struct line {
    ll k, b;
    line () {}
    line (ll _k, ll _b) : k(_k), b(_b) {}
    ll Solve(ll val) { // k * x + b >= val
        ll _a = val - b, _b = k ;
        if ( _a % _b ==0 ) return _a / _b; else return _a/_b + 1;
    }
    ll f(ll x) {return k * x + b; }
};

inline ll intersection( line a, line b) {
    ll _a = a.b - b.b, _b = b.k - a.k ;
    if ( _a % _b ==0 ) return _a / _b; else return _a/_b + 1;
}

ll s, X[maxn];
int n , top = 0;
line S[maxn];

bool ok(ll x, ll _s) {
    if (x > X[top-1] ) return x >= S[top].Solve(_s);
    int pos = lower_bound(X+1, X+top, x) - X; if(X[pos] == x) pos ++;
    return x >= S[pos].Solve(_s);
}

ll solve(ll _s) {
    ll l = 0, r = _s, mid ;
    while ( l + 1 < r) {
        mid = (l + r) >> 1;
        if ( ok (mid, _s ) ) r = mid ; else l = mid;
    }
    
    return r;
}
int main(){
    
    
    cin >> n >> s;
    rep (i, n) B[i].read();
    sort(B, B+n);
    
    int tmp_n = n, maxv = 0;  n = 0;
    rep (i, tmp_n) {
        if (maxv >= B[i].v) continue;
        maxv = B[i].v;
        B[n++] = B[i];
    }
    
    S[ ++top ] = line(B[0].v, -B[0].c); // actually B[0].c == 0
    
    ll i1, i2;
    for (int i = 1 ; i < n; ++ i) {
        ll x0 = solve(B[i].c) , p = lower_bound(X+1, X+top, x0) - X , y0 = S[p+(X[p]==x0)].k * x0 + S[p+(X[p]==x0)].b - B[i].c;
        line tmp (B[i].v, y0 - x0 * B[i].v);
        
        while (top >= 2 && (((i1= intersection(tmp, S[top])) <= (i2 = intersection(S[top], S[top-1])) || (i1 == i2 && tmp.f(i1) >= S[top].f(i1) )) )) -- top;
        S[ ++top ] = tmp; X[ top - 1] = intersection(S[top], S[top-1]);
    }
    
    cout << solve(s) << endl ;
    return 0;
}