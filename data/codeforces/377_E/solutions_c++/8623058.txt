#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;

typedef long long int ll;

int n;
ll s;

const int limite=1000000;

ll t[limite],d[limite],p[limite];
int i0=0,i1=0;

ll frac(ll a,ll b)
{
  return a/b+(a%b!=0);
}

int main()
{
  ios::sync_with_stdio(false);
  cin>>n>>s;
  vector<pair<ll,ll> > v(n);
  for (int i=0;i<n;i++) {
    cin>>v[i].second>>v[i].first;
  }
  sort(v.begin(),v.end());
  {
    vector<pair<ll,ll> > nextv;
    nextv.push_back(v[0]);
    for (int i=1;i<int(v.size());i++) {
      if (nextv.back().first==v[i].first)
	nextv.back().second=v[i].second;
      else if (nextv.back().second<v[i].second)
	nextv.push_back(v[i]);
    }
    v=nextv;
  }
  int i=0;
  while (i<int(v.size()) and v[i].first==0) {
    p[0]=v[i].second;
    i++;
  }
  ll sol=frac(s,p[0]);
  for (;i<int(v.size());i++) {
    ll newc=v[i].first;
    ll newp=v[i].second;
    //while (i0<i1 and d[i0+1]<newc) i0++;
    ll tp;
    ll dp;
    for (;;) {
      if (d[i0]>=newc) {
	tp=t[i0];
	dp=d[i0]-newc;
	break;
      } else {
	tp=t[i0]+frac(newc-d[i0],p[i0]);
	dp=(tp-t[i0])*p[i0]+d[i0]-newc;
	if (i0<i1 and t[i0+1]<=tp) i0++;
	else break;
      }
    }
    if (dp<=s)
      sol=min(sol,tp+frac(s-dp,newp));
    else
      sol=min(sol,tp);
    for (;;) {
      ll difd=d[i1]-(dp+newp*(t[i1]-tp));
      if (tp<=t[i1] and difd<=0) {
	i1--;
	continue;
      }
      ll tbar=frac(difd,newp-p[i1]);
      i1++;
      t[i1]=t[i1-1]+tbar;
      d[i1]=dp+(t[i1]-tp)*newp;
      p[i1]=newp;
      if (d[i1]>s) {
      //if (t[i1]-tp>(s-dp)/newp) {
	i1--;
	break;
      }
      //sol=min(sol,t[i1]+frac(s-d[i1],p[i1]));
      break;
    }
  }
  cout<<sol<<endl;
}
