#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long LL;
#define MN 200005

LL s;
int n;
struct cookie
{
    LL k,b;
    friend bool operator < (const cookie &a,const cookie &b)
    {
        return (a.k==b.k ? a.b>b.b : a.k<b.k);
    }
}ck[MN];

LL K[MN],B[MN];

int I;
inline LL Div(LL x,LL y) {return x/y+((x%y)>0);}
inline LL Time(int x)//对于第x条直线 ，至少用多少时间达到ck[i].b 
{
    return Div((ck[I].b-B[x]),K[x]);
}
inline LL G(int x) 
{
    return K[x]*Time(x)+B[x]-ck[I].b;
}

LL px[MN],py[MN];//与前一条线的交点 用来维护凸包 

int main()
{
    cin>>n>>s;
    for(int i=1;i<=n;++i) scanf("%I64d%I64d",&ck[i].k,&ck[i].b);
    sort(ck+1,ck+n+1);
    ck[++n]=(cookie){1ll<<30,s};
    int m=0;
    for(int i=1;i<=n;++i)
    {
        while(m && ck[m].b>=ck[i].b) --m;
        ck[++m]=ck[i];
    }
    n=m;
    
    //k递增 b递增
    int head=1,tail=1; K[1]=ck[1].k;
    for(int i=2;i<=n;++i)
    {
        I=i;
        while(head<tail && (Time(head)>Time(head+1) || (Time(head)==Time(head+1) && G(head)<=G(head+1)) ) )
            ++head;
        LL nowx=Time(head),nowy=G(head);
        LL nowk=ck[i].k,nowb=nowy-nowx*nowk;
        if(i==n)
        {
            printf("%I64d\n",nowx); return 0;
        }
        /*
        while(head<tail &&
        (double)(B[tail]-B[tail-1])/(double)(K[tail-1]-K[tail])>=(double)(nowb-B[tail])/(double)(K[tail-1]-nowk))
            --tail;
            */
        while(head<tail && nowk*px[tail]+nowb>=py[tail]) --tail;
        ++tail; K[tail]=nowk,B[tail]=nowb;
        px[tail]=Div(B[tail-1]-B[tail],K[tail]-K[tail-1]),py[tail]=px[tail]*K[tail]+B[tail];
    }
    
    
    return 0;
}
