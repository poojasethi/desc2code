#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

typedef long long int64;

int n, len, q, h, mid, prep, i;
int64 ss, kk, bb, S, ans, k[210000], b[210000], start[210000];

struct aa {
	int64 v, c;
} a[210000];

bool cmp(aa a, aa b) {
	if (a.c != b.c)	return a.c < b.c;
	return a.v > b.v;
}

int64 get(int x, int64 S) {
	int64 X = int64(ceil(1.0 * (S - b[x]) / k[x]));
	return max(X, start[x]);
}

int64 cross(int x, int y) {
	return int64(ceil(1.0 * (b[y] - b[x]) / (k[x] - k[y])));
}

void ins(int64 ss, int64 kk, int64 bb) {
	len++;
	start[len] = ss;
	k[len] = kk;
	b[len] = bb;
	ans = min(ans, get(len, S));
}

int main() {
	scanf("%d%I64d", &n, &S);
	for (i = 1; i <= n; i++)	scanf("%I64d%I64d", &a[i].v, &a[i].c);
	sort(a + 1, a + n + 1, cmp);
	ans = 1000000000000000000LL;
	ins(0, a[1].v, 0);
	prep = 1;
	for (i = 2; i <= n; i++)
	if (a[i].v > a[prep].v) {
		q = 0; h = len - 1;
		while (q < h - 1) {
			mid = (q + h) / 2;
			if (k[mid] * (start[mid + 1] - 1) + b[mid] >= a[i].c)	h = mid;
			else	q = mid;
		}
		if (k[h] * (start[h + 1] - 1) + b[h] < a[i].c)	h = len;
		ss = get(h, a[i].c);
		kk = a[i].v;
		bb = k[h] * ss + b[h] - a[i].c - a[i].v * ss;
		while (ss <= start[len] && k[len] * start[len] + b[len] <= kk * start[len] + bb)	len--;
		ins(ss, kk, bb);
		start[len] = max(start[len], cross(len, len - 1));
		prep = i;
	}
	printf("%I64d\n", ans);
}
