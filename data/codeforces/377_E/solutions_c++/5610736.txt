#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cctype>
#define maxn 200010
#define Div(a,b) ((a)/(b)+((a)%(b)!=0))
#define F(x) Div(cookie[i].b-b[x],k[x])
#define G(x) (k[x]*F(x)+b[x]-cookie[i].b)
using namespace std;
typedef long long LL;
struct Node
{
    int k;
    LL b;
    Node() {}
    Node(int k,LL b): k(k),b(b) {}
    friend bool operator < (const Node &a,const Node &b)
    {
        return a.k<b.k||(a.k==b.k&&a.b>b.b);
    }
}cookie[maxn];
template<class T>
void Read(T &digit)
{
    digit=0;
    char c;
    for(c=getchar();!isdigit(c);c=getchar());
    for(;isdigit(c);digit=digit*10+c-'0',c=getchar());
}
int n;
LL s;
void read()
{
    Read(n),Read(s);
    for(int i=1;i<=n;++i)
        Read(cookie[i].k),Read(cookie[i].b);
    sort(cookie+1,cookie+n+1);
    cookie[++n]=Node(1<<30,s);
    int m=0;
    for(int i=1;i<=n;++i)
    {
        while(m&&cookie[m].b>=cookie[i].b)
            --m;
        cookie[++m]=cookie[i];
    }
    n=m;
}
LL Dp()
{
    static LL k[maxn],b[maxn],px[maxn],py[maxn];
    int front=1,rear=1;
    k[rear]=cookie[1].k;
    for(int i=2;i<=n;++i)
    {
        while(front<rear&&(F(front+1)<F(front)||(F(front+1)==F(front)&&G(front+1)>=G(front))))
            ++front;
        LL nowx=F(front),nowk=cookie[i].k;
        LL nowy=G(front),nowb=nowy-nowk*nowx;
        if(i==n)
            return nowx;
        while(rear>front&&nowk*px[rear-1]+nowb>=py[rear-1])
            --rear;
        ++rear;
        k[rear]=nowk,b[rear]=nowb;
        px[rear-1]=Div((b[rear-1]-b[rear]),(k[rear]-k[rear-1])),py[rear-1]=k[rear]*px[rear-1]+b[rear];
    }
}
int main()
{
    read();
    cout<<Dp()<<endl;
    return 0;
}
