# -*- coding: utf-8 -*-

# import pdb
import sys
import random

def analyse_lines(lines):
	m = str_to_int(lines[0])
	contact = []
	for i in range(m):
		# print lines[i+1]
		contact.append([int(x) for x in list(lines[i+1].strip())])
	goal = str_to_int_list(lines[m + 1])

	undecided_row = range(m)
	select_result = {}

	return contact, undecided_row, select_result, goal	

def solve(lines):
	original_lines = list(lines)

	contact, undecided_row, select_result, goal = analyse_lines(lines)

	while True:
		action = decide(contact, undecided_row, select_result, goal)
		if action == 'continue':
			continue
		elif action == 'error':
			lines = list(original_lines)
			contact, undecided_row, select_result, goal = analyse_lines(lines)
			continue
		elif action == 'solved':
			select_result_list = [str(i + 1) for i in select_result if select_result[i]]
			return str(len(select_result_list)) + '\n' + ' '.join(select_result_list)



def decide(contact, undecided_row, select_result, goal):
	if not 0 in goal:
		# solved!
		for x in undecided_row:
			select_result[x] = False
		return 'solved'

	# certain
	for column in range(len(goal)):
		if goal[column] == 0:
			# choose some row
			possible_row_num = 0
			for row in undecided_row:
				if contact[row][column] == 1:
					possible_row_num += 1
			if possible_row_num == 1:
				# only one choice
				for row in undecided_row:
					if contact[row][column] == 1:
						# undate
						# print 'about to select row' + str(row) + 'to satisfy column' + str(column)
						decide_row_and_update(contact, undecided_row, select_result, goal, row)
						return 'continue'
					else:
						continue
			else:
				# many choice
				continue
		elif goal[column] == 1:
			# not choose some row
			possible_row_num = 0
			for row in undecided_row:
				if contact[row][column] == 1:
					possible_row_num += 1

			if possible_row_num == 1:
				# only one choice - not choose this row
				for row in undecided_row:
					if contact[row][column] == 1:
						# print 'about not to select row' + str(row) + 'to satisfy column' + str(column)
						decide_row_and_update(contact, undecided_row, select_result, goal, row, if_choose = False)
						return 'continue'
			else:
				continue
		else:
			# can't decide yet 
			continue

	# uncertain
	for column in range(len(goal)):
		if goal[column] == 0:
			possible_row = [row for row in undecided_row if contact[row][column] == 1]
			if len(possible_row) == 0:
				# print 'error'
				return 'error'
			row = random.choice(possible_row)
			# undate
			# print 'guess. about to select row' + str(row) + 'to satisfy column' + str(column)
			decide_row_and_update(contact, undecided_row, select_result, goal, row)			
			return 'continue'
		else:
			continue

def decide_row_and_update(contact, undecided_row, select_result, goal, row, if_choose = True):
	undecided_row.remove(row)
	select_result[row] = if_choose
	if if_choose:
		for i in range(len(goal)):
			goal[i] -= contact[row][i]

def main():

	lines = sys.stdin.readlines()
	print solve(lines)

# --------------------------------------------

def str_to_int(s):
	return int(s.strip())

def str_to_int_list(s):
	return [int(x) for x in s.strip().split()]

if __name__ == '__main__':
	main()



