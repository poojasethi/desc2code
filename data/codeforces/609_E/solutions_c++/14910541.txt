#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
struct edge{
	int a,b,v,n;
}e[210001];
struct edge2{
	int t,next,v;
}g[410001];
ll mc,ans[210001];
bool v[210001];
int h[210001],dep[210001],fa[210001],lca[210001][21],i,j,k,n,m,f[210001],lv[210001][21],tot;
void addedge(int x,int y,int z){
	g[++tot].t=y;g[tot].next=h[x];h[x]=tot;g[tot].v=z;
	g[++tot].t=x;g[tot].next=h[y];h[y]=tot;g[tot].v=z;
}
bool cmp(edge a,edge b){
	return a.v<b.v;
}
int getfa(int x){
	return (f[x])?f[x]=getfa(f[x]):x;
}
bool merge(int x,int y){
	int i=getfa(x),j=getfa(y);
	if (i==j) return 0;
	f[j]=i;return 1;
}
void dfs(int x){
	int i;
	for (i=1;lca[x][i-1];i++) lca[x][i]=lca[lca[x][i-1]][i-1],lv[x][i]=max(lv[x][i-1],lv[lca[x][i-1]][i-1]);
	for (i=h[x];i;i=g[i].next)
	 if (lca[x][0]!=g[i].t) lca[g[i].t][0]=x,lv[g[i].t][0]=g[i].v,dep[g[i].t]=dep[x]+1,dfs(g[i].t);
}
int getlca(int x,int y){
	int i;
	if (dep[x]>dep[y]) swap(x,y);
	for (i=20;dep[y]>dep[x];y=lca[y][i])
	 for (;dep[lca[y][i]]<dep[x];i--);
	for (i=20;x!=y;x=lca[x][i],y=lca[y][i])
	 for (;i&&lca[x][i]==lca[y][i];i--);
	return x;
}
int query(int x,int d){
	int i,res=0;
	for (i=20;d;x=lca[x][i],d-=(1<<i)){
		for (;(1<<i)>d;i--);
		res=max(res,lv[x][i]);
	}
	return res;
}
int work(int x,int y){
	int k=getlca(x,y);
	return max(query(x,dep[x]-dep[k]),query(y,dep[y]-dep[k]));
}
int main(){
	scanf("%d%d",&n,&m);memset(f,0,sizeof(f));memset(h,0,sizeof(h));memset(lca,0,sizeof(lca));memset(lv,0,sizeof(lv));
	for (i=1;i<=m;i++) scanf("%d%d%d",&e[i].a,&e[i].b,&e[i].v),e[i].n=i;
	sort(e+1,e+1+m,cmp);
	for (i=1,k=mc=0;k<n-1;i++)
	 if (merge(e[i].a,e[i].b)){
		addedge(e[i].a,e[i].b,e[i].v);mc+=e[i].v;k++;v[e[i].n]=1;
	 }else v[e[i].n]=0;
	dep[1]=1;dep[0]=0;dfs(1);
	for (i=1;i<=m;i++){
		if (v[e[i].n]) ans[e[i].n]=mc;else ans[e[i].n]=mc-work(e[i].a,e[i].b)+e[i].v;
	}
	for (i=1;i<=m;i++) printf("%I64d\n",ans[i]);
	return 0;
}