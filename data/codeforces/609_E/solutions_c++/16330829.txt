#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 2*100000+1000;
const int K = 20;
struct node{
	int u,v,c,next;
	int x,y;
	friend bool operator<(const node&a,const node&b){
		return a.c<b.c;
	}
}edge[N*2],s[N],t[N];
int fa[N][K],l[N][K],h[N],head[N],f[N];
int tot;int n,m;
int find(int x){
	if(x!=f[x])
	f[x]=find(f[x]);
	return f[x];
}
void init(){
	memset(h,0,sizeof(h));
	memset(head,-1,sizeof(head));
	tot = 0;
	for(int i=1;i<=n;i++)f[i]=i;
}
void addedge(int u,int v,int c){
	 edge[tot].u=u;
	 edge[tot].v=v;
	 edge[tot].c=c;
	 edge[tot].next=head[u];
	 head[u]=tot++;
}
void dfs(int x,int father,int len){
	 h[x]=h[father]+1;
	 fa[x][0]=father;
	 l[x][0]=len;
//	 cout<<x<<" "<<father<<" "<<len<<" "<<l[3][0]<<endl;
	 for(int i=1;i<K;i++){
	 	fa[x][i]=fa[fa[x][i-1]][i-1];
	 	l[x][i]=max(l[x][i-1],l[fa[x][i-1]][i-1]);
	 }
//	 cout<<l[3][0]<<endl;
	 for(int i=head[x];i!=-1;i=edge[i].next){
	 	int v=edge[i].v;int c=edge[i].c;
	 	if(v!=father)dfs(v,x,c);
	 }
}
int cal(int u,int v){
	if(h[u]<h[v])swap(u,v);
	int ans=0;
	for(int i=K-1;i>=0;i--){
	    if(h[fa[u][i]]>=h[v]){
	       ans=max(ans,l[u][i]);
	       u=fa[u][i];
		}
	}
	for(int i=K-1;i>=0;i--){
		if(fa[u][i]!=fa[v][i]){
		   ans=max(ans,l[u][i]);
		   ans=max(ans,l[v][i]);
		   u=fa[u][i];
		   v=fa[v][i];
		}
	} 
	if(u!=v){
		ans=max(ans,l[u][0]);
		ans=max(ans,l[v][0]);
	}
	return ans;
}
int main(){
    while(~scanf("%d%d",&n,&m)){
	    init();
		for(int i=0;i<m;i++){
	    	scanf("%d%d%d",&s[i].x,&s[i].y,&s[i].c);
	    	t[i].x=s[i].x;t[i].y=s[i].y;t[i].c=s[i].c;
		}
		sort(s,s+m);
		long long ans=0;int cnt=0;
		for(int i=0;i<m;i++){
			int fx,fy;
			fx=find(s[i].x);
			fy=find(s[i].y);
			if(fx==fy)continue;
			f[fx]=fy;cnt++;ans+=s[i].c;
			addedge(s[i].x,s[i].y,s[i].c);
	    	addedge(s[i].y,s[i].x,s[i].c);
			if(cnt==n-1)break;
		}
		dfs(1,1,0);
//		cout<<l[1][0]<<" "<<l[3][0]<<endl;
		for(int i=0;i<m;i++){
			printf("%lld\n",t[i].c+ans-cal(t[i].x,t[i].y));
		}
	} 
    return 0; 
} 
							 	  				 		 	 	  	  		 	