#include <bits/stdc++.h>
using namespace std;
#define M 200100
typedef long long ll;
int n;
int m;
struct edge{
	int x, y, w, id;
	edge(int x = 0, int y = 0, int w = 0, int id = 0) : x(x), y(y), w(w), id(id){};
}e[M];
bool operator<(edge a, edge b) {return a.w < b.w;}
vector<int> v[M], w[M];

int fa[20][M], dep[M];
int mx[20][M];
ll sum;

void input() {
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= m; i++) scanf("%d %d %d", &e[i].x, &e[i].y, &e[i].w), e[i].id = i;
	sort(e + 1, e + m + 1);
}

int r[M];
int find_root(int u) {
	if (r[u] == u) return u;
	return r[u] = find_root(r[u]);
}
void make_tree() {
	for (int i = 1; i <= n; i++) r[i] = i;
	for (int i = 1; i <= m; i++) {
		int x = find_root(e[i].x);
		int y = find_root(e[i].y);
		if (x == y) continue;
		sum += e[i].w;
		r[y] = x;
		v[e[i].x].push_back(e[i].y);
		w[e[i].x].push_back(e[i].w);
		v[e[i].y].push_back(e[i].x);
		w[e[i].y].push_back(e[i].w);
	}
}

void dfs(int x) {
	for (int j = 1; j < 20; j++) fa[j][x] = fa[j-1][fa[j-1][x]], mx[j][x] = max(mx[j-1][x], mx[j-1][fa[j-1][x]]);
	for (int y, i = 0; i < v[x].size(); i++) {
		y = v[x][i];
		if (y == fa[0][x]) continue;
		dep[y] = dep[x] + 1;
		fa[0][y] = x;
		mx[0][y] = w[x][i];
		dfs(y);
	}
}

ll solve(int x, int y, int w) {
	if (dep[x] > dep[y]) swap(x, y);
	if (fa[0][y] == x) return sum;
	int maxw = 0;
	for (int i = 19; i >= 0; i--) if (dep[y] >= dep[x] + (1<<i)) {
		maxw = max(maxw, mx[i][y]);
		y = fa[i][y];
	}
	if (x == y) return sum - maxw + w;
	for (int i = 19; i >= 0; i--) if (fa[i][x] != fa[i][y]) {
		maxw = max(maxw, mx[i][x]);
		maxw = max(maxw, mx[i][y]);
		x = fa[i][x];
		y = fa[i][y];
	}
	maxw = max(maxw, max(mx[0][x], mx[0][y]));
	return sum - maxw + w;
}

ll ans[M];
int main() {
	//freopen("Edu3_E1.in", "r", stdin);
	input();
	make_tree();
	dfs(1);
	for (int i = 1; i <= m; i++) ans[e[i].id] = solve(e[i].x, e[i].y, e[i].w);
	for (int i = 1; i <= m; i++) printf("%I64d\n", ans[i]);
	return 0;
}
