#include <iostream>
#include <fstream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <map>
using namespace std;

const int maxN = 5000005;
char str[maxN];
int n, K;
int f[maxN], g[maxN*2];
int kmp1[maxN], kmp2[maxN], selfkmp[maxN];
int Next[maxN];
int ans[maxN];
int arrs, arr[maxN];
int Chop[maxN], Cut[maxN];

void Readln(){
	scanf( "%s", str );
	scanf( "%d\n", &K );
	n = strlen(str);
	for (int i=1; i<=n; i++) f[i] = str[i-1] - 96;
	for (int i=1; i<=n; i++) g[i] = f[n-i+1];
}

void Mini_Cut(bool ok){
	for (int i=1; i<=n+1; i++) Next[i] = 0;
	int p1 = 1, p2 = 2;
	for (;;){
		if (p1 == n + 1) break;
		int i = 0;
		while (g[p1 + i] == g[p2 + i]) i++;
		if (g[p1 + i] < g[p2 + i]){
			p2 = p2 + i + 1;
			continue;
		}
		int tmp = p2 - p1;
		int End = p1 + i;
		bool flag = (p2 + i == n+1);
		if (ok || flag) Next[p2] = p1;
		while (p1 + tmp <= End){
			p1 += tmp;
			if (ok || flag) Next[p1 + tmp] = p1;
		}
		p1 += tmp;
		p2 = p1 + 1;
	}
}

void ext_kmp(int *A, int *B, int *kmp){
	for (int i=1; i<=n; i++) selfkmp[i] = 0;
	for (int i=1; i<n; i++)
	if (A[i+1] == A[i]) selfkmp[2]++;
		else break;
	int maxi = 2, maxL = selfkmp[2]+1;
	for (int i=3; i<=n; i++){
		int now;
		if (i > maxL) now = 0;
			else now = min(selfkmp[i-maxi+1], maxL - i + 1);
		while (A[i+now] == A[1+now] && i+now <= n) now++;
		if (i + now - 1 > maxL){
			maxL = i + now - 1;
			maxi = i;
		}
		selfkmp[i] = now;
	}
	kmp[1] = 0;
	while (A[1+kmp[1]] == B[1+kmp[1]] && 1+kmp[1] <= n) kmp[1]++;
	maxi = 1; maxL = kmp[1];
	for (int i=2; i<=n; i++){
		int now;
		if (i > maxL) now = 0;
			else now = min(selfkmp[i-maxi+1], maxL - i + 1);
		while (A[1+now] == B[i+now] && i+now <= n) now ++;
		if (i + now - 1 > maxL){
			maxL = i + now - 1;
			maxi = i;
		}
		kmp[i] = now;
	}
}

void Forward_Reversal(){
	ext_kmp(g, f, kmp1);
	ext_kmp(g, g, kmp2);
	int Best = 1;
	for (int i=2; i<n; i++){
		int Len1 = i - Best;
		if (kmp1[Best+1] < Len1){
			if (g[kmp1[Best+1]+1] < f[Best+1+kmp1[Best+1]]) continue;
			Best = i; continue;
		}
		int Len2 = n - i;
		if (kmp2[Len1+1] < Len2){
			if (g[1+kmp2[Len1+1]] < g[Len1+1+kmp2[Len1+1]]) Best = i;
			continue;
		}
	}
	bool flag = 0;
	for (int i=Best+1; i<=n; i++){
		if (g[i-Best] < ans[i]) {flag = 1; break;}
		if (g[i-Best] > ans[i]) break;
	}
	if (flag) for (int i=Best+1; i<=n; i++) ans[i] = g[i-Best];
}

void Reversal_Reversal(){
	for (int i=1; i<=n; i++) g[i + n] = g[i];
	int p1 = 1, p2 = 2;
	for (;;){
		if (p2 > n) break;
		int i = 0;
		while (g[p1 + i] == g[p2 + i] && i<=n) i++;
		if (i > n) break;
		if (g[p1 + i] < g[p2 + i]){
			p2 = p2 + i + 1;
			continue;
		}
		p1 += i + 1;
		p2 = p1 + 1;
	}
	
	bool flag = 0;
	for (int i=1; i<=n; i++){
		if (ans[i] > g[p1+i-1]) {flag = 1; break;}
		if (ans[i] < g[p1+i-1]) break;
	}
	if (flag) for (int i=1; i<=n; i++) ans[i] = g[p1+i-1];
	for (int i=1; i<=n; i++) g[i+n] = 0;
}

void Reversal_Forward(){
	Mini_Cut(0);
	int arrs = 1;
	arr[0] = n+1;
	arr[1] = Next[n+1];
	for (int i=Next[arr[1]]; i!=0; i=Next[i]){
//		bool flag = 1;
//		for (int j=arr[arrs], k=i; j<arr[arrs-1]; j++, k++)
//			if (g[j] != g[k]) {flag = false; break;}
//		if (!flag) break;
		arr[++arrs] = i;
	}
	for (int i=0; i<=arrs; i++) arr[i] = n-arr[i]+1;
	int Best = arr[1];
	for (int i=2; i<=arrs; i++){
		int now = arr[i];
		bool flag = 0;
		for (int j=Best+1, k = now - Best; j<=now; j++, k--){
			if (f[j] < f[k]) {flag = 1; break;}
			if (f[j] > f[k]) break;
		}
		if (flag) break;
		Best = now;
	}
	for (int i=1; i<Best-i+1; i++) swap(f[i], f[Best-i+1]);
	bool flag = 0;
	for (int i=1; i<=n; i++){
		if (f[i] < ans[i]) {flag = 1; break;}
		if (f[i] > ans[i]) break;
	}
	if (flag) for (int i=1; i<=n; i++) ans[i] = f[i];
}

void Solve(){
	if (n == 1){
		printf( "%c\n", f[1] + 96 );
		return;
	}
	if (K == 1){
		bool flag = 0;
		for (int i=1; i<=n; i++){
			if (g[i] < f[i]) {flag = 1; break;}
			if (f[i] < g[i]) break;
		}
		if (!flag){
			for (int i=1; i<=n; i++) printf( "%c", f[i] + 96 );
		}else for (int i=1; i<=n; i++) printf( "%c", g[i] + 96 );
		return;
	}
	Mini_Cut(1);
	int tot = 0, Rest = K, Cuts = 0;
	for (int i = Next[n + 1]; i != 0; i = Next[i]){
		tot ++;
		Chop[tot] = n - i + 1;
		bool flag = 1;
		if (Chop[tot] - Chop[tot-1] != Chop[tot-1] - Chop[tot-2]) flag = 0;
		if (flag){
			for (int j=Chop[tot], k=Chop[tot-1]; j>Chop[tot-1]; j--, k--)
				if (f[j] != f[k]) {flag = 0; break;}
		}
		if (!flag){
			if (Chop[tot] - Chop[tot-1] != 1 || Chop[tot-1] - Chop[tot-2] != 1)
				Rest --;
			Cut[++Cuts] = n - i + 1;
		}else Cut[Cuts] = Chop[tot];
		if (Rest == 1){
			tot--;
			Cuts--;
			break;
		}
	}
	Cut[0] = 0;
	for (int i=1; i<=Cuts; i++){
		for (int j=Cut[i]; j>Cut[i-1]; j--) printf( "%c", f[j]+96 );
	}
	
	int tn = n;
	n = n - Cut[Cuts];
	
	if (n == 1){
		printf( "%c", f[tn] + 96 );
		return;
	}
	if (n == 0) return;
	
	for (int i=1; i<=n; i++) g[n-i+1] = f[i] = f[Cut[Cuts]+i];
	for (int i=n+1; i<=tn; i++) f[i] = g[i] = 0;
	
	for (int i=1; i<=n; i++) ans[i] = f[i];
	Forward_Reversal();
	Reversal_Reversal();
	Reversal_Forward();
	for (int i=1; i<=n; i++) printf( "%c", ans[i]+96 );
	printf( "\n" );
}

int main(){
	Readln();
	Solve();
	return 0;
}