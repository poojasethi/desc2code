# dfs and get the max depth and the node of this depth
def dfs(n, used):
    global adj
    used[n] = 1
    maxDep = -1
    maxDepNode = n
    for i in adj[n]:
        if i not in used:
            dep, node = dfs(i, used)
            if dep > maxDep:
                maxDep = dep
                maxDepNode = node
    return maxDep + 1, maxDepNode

#get the diameter of the tree that contains n
#note that one end of the diameter must be the node of max depth in the tree
def getDiameter(n):
    #first dfs on n and find the node with max depth
    dep, n = dfs(n, dict())
    #then dfs on this node and find the max depth
    dep, n = dfs(n, dict())
    #the diameter of the tree is the 2nd max depth
    return dep

n = int(raw_input())
path = []
adj = [set() for i in xrange(n + 1)]
for i in xrange(n - 1):
    path.append(map(int, raw_input().split()))
    adj[path[-1][0]].add(path[-1][1])
    adj[path[-1][1]].add(path[-1][0])

res = 0
#the graph has n nodes and n - 1 edges, so it's a tree
#break the tree into 2 trees on each edge, and calc the diameter
for p in path:
    adj[p[0]].remove(p[1])
    adj[p[1]].remove(p[0])
    len1 = getDiameter(p[0])
    len2 = getDiameter(p[1])
    res = max(res, len1 * len2)
    adj[p[0]].add(p[1])
    adj[p[1]].add(p[0])

print res