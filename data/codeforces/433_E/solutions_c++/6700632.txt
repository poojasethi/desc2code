#include<cstdio>
#include<cstring>
#include<queue>

using namespace std;

const int MOD = 1000000000 + 7;

int n, bas, lim;

int go[210][22];
int trie[210][22], tn;
int upper[210], lower[210], val[210], str[210];
int fail[210];
int bound[210];
int f[2][210][210][510];

queue<int> q;

inline int min(int a, int b) { return a < b ? a : b; }

int work(){
	int p = 200;
	while(p >= 0 && !bound[p]){
		-- p;
	}
	if(p < 0)
		return 0;
	memset(f, 0, sizeof(f));
	f[0][0][0][0] = 1;
	int ans = 0;
	for(int i = 0; i <= p; i ++){
		for(int j = 0; j <= tn; j ++){
			for(int k = 0; k < 2; k ++){
				for(int v = 0; v <= lim; v ++){
					if(!f[k][i][j][v])
						continue;
					for(int fil = 0; fil < bas; fil ++){
						int& nxt = f[(fil == bound[i] && k) || fil > bound[i]][i + 1][go[j][fil]][min(lim + 1, v + val[go[j][fil]])];
						nxt += f[k][i][j][v];
						if(nxt >= MOD)
							nxt -= MOD;
						if(fil && v + val[go[j][fil]] <= lim && (!((fil == bound[i] && k) || fil > bound[i]) || i < p)){
							ans += f[k][i][j][v];
							if(ans >= MOD)
								ans -= MOD;
						}
					}
				}
			}
		}
	}
	return ans;
}

void mminus(){
	for(int i = 0; i <= 200; i ++){
		-- bound[i];
		if(bound[i] >= 0)
			break;
		bound[i] += bas;
	}
}

int main(){
	scanf("%d%d%d", &n, &bas, &lim);
	int len, lenl, lenr;
	scanf("%d", &lenl);
	for(int i = lenl - 1; i >= 0; i --)
		scanf("%d", lower + i);
	scanf("%d", &lenr);
	for(int i = lenr - 1; i >= 0; i --)
		scanf("%d", upper + i);
	while(n --){
		scanf("%d", &len);
		for(int i = len; i >= 1; i --)
			scanf("%d", str + i);
		int cur = 0;
		for(int i = 1; i <= len; i ++){
			if(!trie[cur][str[i]])
				trie[cur][str[i]] = ++ tn;
			cur = trie[cur][str[i]];
		}
		int v;
		scanf("%d", &v);
		val[cur] += v;
	}
	q.push(0);
	while(!q.empty()){
		int cur = q.front();
		q.pop();
		for(int i = 0; i < bas; i ++){
			if(trie[cur][i]){
				go[cur][i] = trie[cur][i];
				int ff;
				for(ff = fail[cur]; ff && !trie[ff][i]; ff = fail[ff]);
				if(ff == cur)
					fail[trie[cur][i]] = 0;
				else
					fail[trie[cur][i]] = trie[ff][i];
				val[trie[cur][i]] += val[fail[trie[cur][i]]];
				q.push(trie[cur][i]);
			} else{
				int ff;
				for(ff = fail[cur]; ff && !trie[ff][i]; ff = fail[ff]);
				go[cur][i] = trie[ff][i];
			}
		}
	}
	for(int i = 200; i >= 0; i --)
		bound[i] = upper[i];
	int ans = work();
	for(int i = 200; i >= 0; i --)
		bound[i] = lower[i];
	mminus();
	ans -= work();
	if(ans < 0)
		ans += MOD;
	printf("%d\n", ans);

	return 0;
}



