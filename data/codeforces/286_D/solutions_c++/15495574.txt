#include <map>
#include <set>
#include <list>
#include <ctime>
#include <cmath>
#include <queue>
#include <stack>
#include <bitset>
#include <vector>
#include <cstdio>
#include <string>
#include <cstring>
#include <sstream>
#include <iomanip>
#include <cstdlib>
#include <iostream>
#include <algorithm>
using namespace std;
struct node {
	int d,i;
}t[400005];
struct wall {
	int l,r,t;
}f[200005];
int comp (const node &a,const node &b) {
	if (a.i==b.i) return a.d>b.d;
	return a.i<b.i;
}
multiset<int> c;
node r[1000005];
int a[400005],d[400005];
int main ( ) {
	int n,m,i,q,s=0,w=0,g=0,ans=0;
	scanf("%d%d",&m,&n);
	d[s++]=0;
	for (i=1;i<=n;i++) {
		scanf("%d%d%d",&f[i].l,&f[i].r,&f[i].t);
		d[s++]=f[i].l;d[s++]=f[i].r;
	}
	sort(d,d+s);
	s=unique(d,d+s)-d-1;
	for (i=1;i<=n;i++) {
		int l,r;
		l=lower_bound(d,d+1+s,f[i].l)-d;
		r=lower_bound(d,d+1+s,f[i].r)-d;
		t[++g]=(node){f[i].t+1,l};
		t[++g]=(node){-f[i].t-1,r};
	}
	sort(t+1,t+1+g,comp);
	q=1;
	for (i=0;i<s;i++) {
		while (q<=g && t[q].i==i) {
			if (t[q].d<0) {
				multiset<int>::iterator it=c.find(-t[q].d-1);
				c.erase(it);
			}
			else c.insert(t[q].d-1);
			q++;
		}
		if (!c.empty()) a[i+1]=*c.begin(); else a[i+1]=-1;
	}
	for (i=1;i<=m;i++) {
		int q;
		scanf("%d",&q);
		r[++w]=(node){2,q};
		if (i>1 && r[w].i<=r[w-1].i) return 0;
	}
	for (i=1;i<=s;i++) {
		if (~a[i]) {
			r[++w]=(node){1,a[i]-d[i]};
			r[++w]=(node){-1,a[i]-d[i-1]};
		}
	}
	sort(r+1,r+1+w,comp);
	q=0;
	for (i=1;i<=w;i++) {
		ans+=q*(r[i].i-r[i-1].i);
		if (r[i].d==2) printf("%d\n",ans); else q+=r[i].d;
	}
	return 0;
}
/*
Sample test(s)

input

2 2
1 4 3
3 6 5
0 1

output

2
4

input

3 3
0 3 4
0 1 2
2 4 0
1 3 4

output

2
4
4
*/
