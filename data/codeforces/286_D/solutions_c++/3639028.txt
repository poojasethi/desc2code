#include<cstdio>
#include<algorithm>
#define fo(i,a,b) for(i=a;i<=b;++i)
using namespace std;
typedef long long LL;
const int mn=201000;
int n,Q,tot,lt;
int L[mn],R[mn];
int h[mn],s[mn],pos[mn],tt=0;
LL sl[mn],sr[mn];
struct eva{int l,t,d;}e[mn*2];
bool cmp(eva a,eva b)
{
    return a.l<b.l||(a.l==b.l&&a.t<b.t);
}
eva Eva(int l,int t,int d)
{
    eva res;
    res.l=l,res.t=t,res.d=d;
    return res;
}
int rank(int v){return lower_bound(pos+1,pos+1+lt,v)-pos;}
bool cmph(int i,int j){return i>j;}
int main()
{
    scanf("%d%d",&Q,&n);
    int i,j,k;
    tot=0;
    fo(i,1,n)
    {
        int li,ri,ti;
        scanf("%d%d%d",&li,&ri,&ti);
        e[i+i-1]=Eva(li,ti,1);
        e[i+i]=Eva(ri,ti,-1);
        pos[i]=ti;
    }
    sort(e+1,e+1+n+n,cmp);
    sort(pos+1,pos+1+n);
    lt=unique(pos+1,pos+1+n)-pos-1;
    k=-1;
    tot=0;
    fo(i,1,n+n)
    {
        j=e[i].l;
        while(tt>0&&s[rank(h[1])]==0)
        {
            pop_heap(h+1,h+1+tt,cmph);
            --tt;
        }
        if(j!=k&&tt>0)
        {
            int t=h[1];
            ++tot;
            L[tot]=t-j;
            R[tot]=t-k;
        }
        k=j;
        if(e[i].d==1)
        {
            h[++tt]=e[i].t;
            push_heap(h+1,h+1+tt,cmph);
        }
        s[rank(e[i].t)]+=e[i].d;
    }
    sort(L+1,L+1+tot);
    sort(R+1,R+1+tot);
    fo(i,1,tot)sl[i]=sl[i-1]+L[i];
    fo(i,1,tot)sr[i]=sr[i-1]+R[i];
    while(Q--)
    {
        scanf("%d",&i);
        j=lower_bound(L+1,L+1+tot,i)-L-1;
        k=lower_bound(R+1,R+1+tot,i)-R-1;
        LL res=(LL)(i)*j-sl[j]+sr[k]-(LL)(i)*k;
        printf("%I64d\n",res);
    }
    return 0;
}