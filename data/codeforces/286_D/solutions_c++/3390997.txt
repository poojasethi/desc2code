#include <cstdio>
#include <algorithm>
#include <map>
using	namespace	std;
typedef	long long	ll;
const	ll	maxn = 110000;
ll	n, m, last, tp1, tp2, lq, n11, d11;
ll	qq[maxn], ans[maxn];
map	<ll, ll>	mp1;
map	<ll, ll>::iterator	itr1, itr2;
struct	block
{
	ll	lf, ri, t;
	void	scan1()	{scanf("%I64d%I64d%I64d", &lf, &ri, &t);}
}	a[maxn];
bool	operator<(block a, block b)	{return a.t < b.t;}
struct	things
{
	ll	pos, typ, delta;
	things()	{}
	things(ll p, ll t, ll d):pos(p), typ(t), delta(d)	{}
}	q[maxn * 5];
bool	operator<(things a, things b)
{
	return a.pos < b.pos;
}
inline	void	gain(ll l, ll r)
{
	q[++lq] = things(l, 1, 1);
	q[++lq] = things(r, 1, -1);
}
int	main()
{
//	freopen("d.in", "r", stdin);
//	freopen("d.out", "w", stdout);
	scanf("%I64d%I64d", &n, &m);
	for (ll i=1; i<=m; i++) a[i].scan1();
	for (ll i=1; i<=n; i++) scanf("%d", &qq[i]);
	sort(a + 1, a + m + 1);
	mp1.clear();
	lq = 0;
	for (ll i=1; i<=m; i++)
	{
		itr1 = mp1.lower_bound(a[i].lf);
		last = a[i].lf;
		if (itr1 != mp1.begin())
		{
			itr2 = itr1;
			itr2--;
			if (itr2->second > last) {last = itr2->second; a[i].lf = itr2->first; itr1 = itr2;}
		}
		while (itr1->first < a[i].ri && itr1 != mp1.end())
		{
			tp1 = itr1->first;
			tp2 = itr1->second;
			if (tp1 > last) gain(a[i].t - tp1, a[i].t - last);
			last = tp2;
			itr1++;
			mp1.erase(tp1);
		}
		if (last < a[i].ri) gain(a[i].t - a[i].ri, a[i].t - last), last = a[i].ri;
		mp1[a[i].lf] = last;
	}
	for (ll i=1; i<=n; i++) q[++lq] = things(qq[i], 2, i);
	sort(q + 1, q + lq + 1);
	n11 = 0, d11 = 0, last = 0;
	for (ll i=1; i<=lq; i++)
	{
		n11 -= d11 * (last - q[i].pos);
		last = q[i].pos;
		if (q[i].typ == 1) d11 += q[i].delta;
		else	ans[q[i].delta] = n11;
	}
	for (ll i=1; i<=n; i++) printf("%I64d\n", ans[i]);
	return 0;
}