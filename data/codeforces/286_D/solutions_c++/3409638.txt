#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#define FOR(i,s,e) for (int i=(s); i<(e); i++)
#define FOE(i,s,e) for (int i=(s); i<=(e); i++)
#define FOD(i,s,e) for (int i=(s)-1; i>=(e); i--)
#define CLR(a,x) memset(a, x, sizeof(a))
#define EXP(i,l) for (int i=(l); i; i=qn[i])
#define N 200005
using namespace std;

struct dat{
	int x, y, t;
	bool operator < (dat const &T) const{return x < T.x;}
};

struct node{
	int y, t;
	bool operator < (node const &T) const{return t > T.t;}
};

int n, m, t, t2, T, cnt, sum;
int evt[N], ret[N];
dat a[N], b[N+N], c[N];
priority_queue<node> q;
long long dec;

void add(int x, int y, int t){
	int l = y - x;
	b[t2++] = (dat){t - x - l, 0, 1<<30};
	b[t2++] = (dat){t - x, l, t - x - l};
}

int main(){
	scanf("%d%d", &m, &n);
	FOR(i,0,n){
		scanf("%d%d%d", &a[i].x, &a[i].y, &a[i].t);
		evt[t++] = a[i].x;
		evt[t++] = a[i].y;
	}
	sort(evt, evt + t);
	T = unique(evt, evt + t) - evt;
	sort(a, a + n);
	t = 0;
	FOR(i,0,T-1){
		while (t < n && a[t].x == evt[i]) q.push((node){a[t].y, a[t].t}), ++t;
		while (!q.empty() && q.top().y <= evt[i]) q.pop();
		if (!q.empty()) add(evt[i], evt[i+1], q.top().t);
	}
	
	sort(b, b + t2);
	FOR(i,0,m) scanf("%d", &c[i].x), c[i].y = i;
	sort(c, c + m);
	
	t = 0;
	FOR(i,0,m){
		while (t < t2 && b[t].x <= c[i].x){
			if (b[t].t == (1<<30)) ++cnt, dec += b[t].x;
			else --cnt, dec -= b[t].t, sum += b[t].y;
			++t;
		}
		ret[c[i].y] = sum + cnt * 1LL * c[i].x - dec;
	}
	
	FOR(i,0,m) printf("%d\n", ret[i]);
	return 0;
}
