#include<cstdio>
#include<set>
#include<algorithm>
using namespace std;
const int inf=0x3f3f3f3f;
struct wall
{
	int l,r,t;
	const bool operator<(wall a) const
	{
		return (l<a.l)||((l==a.l)&&(t<a.t));
	}
}W[100050];
struct event
{
	int t,w,q;
}E[700050];
set<wall>::iterator T[300050];
set<wall> S1,S2;
int n,m,tot;
bool cmpw(wall a,wall b)
{
	return a.t>b.t;
}
bool cmpe(event a,event b)
{
	return (a.t<b.t)||((a.t==b.t)&&(a.w<b.w));
}
wall w(int l,int r,int t)
{
	wall a;
	a.l=l; a.r=r; a.t=t;
	return a;
}
int main()
{
	set<wall>::iterator t1,t2,t3;
	int i,j,x,M,ans;
	scanf("%d%d",&n,&m);
	for (i=1;i<=m;i++) scanf("%d%d%d",&W[i].l,&W[i].r,&W[i].t);
	sort(W+1,W+m+1,cmpw);
	S1.insert(w(-1,1000000001,1000000001));
	for (i=1;i<=m;i++)
	{
		t1=S1.lower_bound(w(W[i].l,W[i].l,inf));
		if (t1!=S1.begin()) t1--;
		t2=S1.upper_bound(w(W[i].r,W[i].r,-inf)); tot=0;
		for (t3=t1;t3!=t2;t3++)
			if ((W[i].l<t3->r)&&(t3->l<W[i].r))
			{
				tot++; T[tot]=t3;
				if (W[i].l>t3->l) S2.insert(w(t3->l,W[i].l,t3->t));
				if (W[i].r<t3->r) S2.insert(w(W[i].r,t3->r,t3->t));
			}
		for (j=1;j<=tot;j++) S1.erase(T[j]);
		for (t3=S2.begin();t3!=S2.end();t3++) S1.insert(*t3);
		S1.insert(W[i]); S2.clear();
	}
	tot=0;
	for (t3=S1.begin();t3!=S1.end();t3++)
		if (t3->t<=1000000000)
		{
			tot++; E[tot].t=t3->t-t3->r; E[tot].w=1; E[tot].q=1;
			tot++; E[tot].t=t3->t-t3->l; E[tot].w=1; E[tot].q=-1;
		}
	for (i=1;i<=n;i++)
	{
		scanf("%d",&x);
		tot++; E[tot].t=x; E[tot].w=0;
	}
	sort(E+1,E+tot+1,cmpe);
	ans=0; M=0;
	for (i=1;i<=tot;i++)
	{
		if (i>1) ans+=M*(E[i].t-E[i-1].t);
		if (E[i].w) M+=E[i].q;
		else printf("%d\n",ans);
	}
	return 0;
}