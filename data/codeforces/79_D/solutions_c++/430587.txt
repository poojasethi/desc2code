#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <cmath>
#include <cassert>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;

#define PROBLEM "d"

#define SIZE(__c) (int)(__c).size()
#define SHIFT(__b) (1<<(__b))

const int INF=1000008;

int main() {
#ifdef LAPTOP
  freopen(PROBLEM".in", "r", stdin);
#endif
  int i, j, m, n, N, P, F;
  scanf("%d %d %d", &N, &P, &F);
  vector<int> pp;
  vector<int> fl;
  vector< vector<int> > mx;
  m=0;
  for (i=0; i<P; i++) {
    scanf("%d", &n);
    if (m==0)
      pp.push_back(n-1);
    else if (m+1!=n) {
      pp.push_back(m);
      pp.push_back(n-1);
    }
    m=n;
  }
  pp.push_back(m);
  P=SIZE(pp);
  fl.resize(F);
  for (i=0; i<F; i++)
    scanf("%d", &fl[i]);
  mx.resize(P, vector<int>(P));
  for (i=0; i<P; i++) {
    queue<int> qe;
    qe.push(pp[i]);
    vector<int> dt(N+1, INF);
    dt[pp[i]]=0;
    while (!qe.empty()) {
      n=qe.front();
      qe.pop();
      for (j=0; j<F; j++) {
        if (n-fl[j]>=0 && dt[n-fl[j]]==INF) {
          qe.push(n-fl[j]);
          dt[n-fl[j]]=dt[n]+1;
        }
        if (n+fl[j]<=N && dt[n+fl[j]]==INF) {
          qe.push(n+fl[j]);
          dt[n+fl[j]]=dt[n]+1;
        }
      }
    }
    for (j=0; j<P; j++)
      mx[i][j]=dt[pp[j]];
  }
  vector<int> dp(SHIFT(P), INF);
  dp[SHIFT(P)-1]=0;
  for (m=SHIFT(P)-1; m>0; m--) {
    for (i=0; (m&SHIFT(i))==0; i++)
      ;
    for (j=i+1; m>=SHIFT(j); j++)
      if (m&SHIFT(j))
        dp[m^SHIFT(j)^SHIFT(i)]=min(dp[m^SHIFT(j)^SHIFT(i)], dp[m]+mx[i][j]);
  }
  printf("%d\n", dp[0]==INF ? -1 : dp[0]);
  return 0;
}
