#include<cstdio>
#include<deque>
#include<algorithm>

using namespace std;

const int MAX_N = 10005;
const int MAX_K = 25;
const int MAX_B = (1 << 20) + 5;
const int MAX_L = 105;

const int INF = -1u / 4;

int n, k, l;
int pos[MAX_K];
int w[MAX_K][MAX_K];
int dp[MAX_B];
int a[MAX_L];
bool is_target[MAX_N];
int dis[MAX_N];
deque<int> q;

int main(){
  scanf("%d %d %d", &n, &k, &l);
  for(; k --> 0; ){
    int x;
    scanf("%d", &x);
    is_target[x] = true;
  }
  k = 0;
  for(int i = 0; i <= n; i++){
    if(is_target[i] != is_target[i + 1]){
      pos[k++] = i;
    }
  }
  for(int i = 0; i < l; i++){
    scanf("%d", a + i);
  }
  fill(&w[0][0], &w[k][k], INF);
  for(int i = 0; i < k; i++){
    q.clear();
    fill(dis, dis + n + 1, INF);
    q.push_back(pos[i]);
    dis[pos[i]] = 0;
    for(; not q.empty(); q.pop_front()){
      int u = q.front();
      for(int j = 0; j < l; j++){
	for(int dir = -1; dir <= 1; dir += 2){
	  int v = u + dir * a[j];
	  if(v >= 0 and v <= n and dis[v] == INF){
	    dis[v] = dis[u] + 1;
	    q.push_back(v);
	  }
	}
      }
    }
    for(int j = 0; j < k; j++){
      w[i][j] = dis[pos[j]];
    }
  }
  fill(dp, dp + (1 << k), INF);
  dp[0] = 0;
  for(int s = 0; s < (1 << k) - 1; s++){
    for(int i = 0; i < k; i++) if(not (s & (1 << i))){
	for(int j = 0; j < k; j++) if(not (s & (1 << j)) and i != j){
	    int &next = dp[s | (1 << i) | (1 << j)];
	    next = min(next, dp[s] + w[i][j]);
	  }
      }
  }
  printf("%d\n", dp[(1 << k) - 1] == INF? -1: dp[(1 << k) - 1]);
}
