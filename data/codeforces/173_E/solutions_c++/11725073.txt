#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<map>
using namespace std;
int n,k,tmp[100005],q,ans[100005];
map<int,int> M,ML,MR;
struct ppl{
  int r,a,reL,reR,v;
  bool operator<(const ppl & k) const{
    return r>k.r;
  }
}arr[100005];
int fr(int val){
  int l=0,r=n+1,m;
  while(r-l>1) tmp[m=(l+r)>>1]>=val?r=m:l=m;
  return r;
}
int fl(int val){
  int l=0,r=n+1,m;
  while(r-l>1) tmp[m=(l+r)>>1]<=val?l=m:r=m;
  return l;
}
struct query{
  int a,b,l,r,id,lim;
  bool operator<(const query & k) const{
    return lim>k.lim;
  }
}que[100005];

int seg[292929],seg2[292929];
void upd(int id,int l,int r,int p){
  seg[id]++;
  if(l==r) return;
  int m=(l+r)>>1;
  if(m>=p) upd(id*2,l,m,p);
  else upd(id*2+1,m+1,r,p);
  return;
}
int query(int id,int l,int r,int L,int R){
  if(L>r || l>R) return 0;
  if(L<=l && r<=R) return seg[id];
  int m=(l+r)>>1;
  return query(id*2,l,m,L,R)+query(id*2+1,m+1,r,L,R);
}
void upd2(int id,int l,int r,int p,int v){
  if(l==r){
    seg2[id]=max(seg2[id],v);
    return;
  }
  int m=(l+r)>>1;
  if(p<=m) upd2(id*2,l,m,p,v);
  else upd2(id*2+1,m+1,r,p,v);
  seg2[id]=max(seg2[id*2],seg2[id*2+1]);
  return;
}
int query2(int id,int l,int r,int L,int R){
  if(L>r || l>R) return 0;
  if(L<=l && r<=R) return seg2[id];
  int m=(l+r)>>1;
  return max(query2(id*2,l,m,L,R),query2(id*2+1,m+1,r,L,R));
}
int main(){
  scanf("%d %d",&n,&k);
  for(int i=1;i<=n;i++) scanf("%d",&arr[i].r);
  for(int i=1;i<=n;i++) scanf("%d",&arr[i].a),tmp[i]=arr[i].a;
  sort(tmp+1,tmp+n+1);
  for(int i=1;i<=n;i++){
    if(M.count(tmp[i])==0){
      M[tmp[i]]=i;
      ML[tmp[i]]=fr(tmp[i]-k);
      MR[tmp[i]]=fl(tmp[i]+k);
    }
  }
  for(int i=1;i<=n;i++){
    arr[i].reL=ML[arr[i].a];
    arr[i].reR=MR[arr[i].a];
    arr[i].a=M[arr[i].a];
  }
  scanf("%d",&q);
  for(int i=1;i<=q;i++){
    scanf("%d %d",&que[i].a,&que[i].b);
    que[i].l=max(arr[que[i].a].reL,arr[que[i].b].reL);
    que[i].r=min(arr[que[i].a].reR,arr[que[i].b].reR);
    que[i].id=i;
    que[i].lim=max(arr[que[i].a].r,arr[que[i].b].r);
  }
  
  sort(arr+1,arr+n+1);
  sort(que+1,que+q+1);
  
  memset(seg,0,sizeof(seg));
  memset(seg2,0,sizeof(seg2));

  for(int i=n;i>=1;i--){
    int pos=i-1;
    while(pos>0 && arr[pos].r==arr[pos+1].r) pos--;
    pos++;
    for(int j=pos;j<=i;j++) upd(1,1,n,arr[j].a);
    for(int j=pos;j<=i;j++) arr[j].v=query(1,1,n,arr[j].reL,arr[j].reR);
    i=pos;
  }
  
  int pos=1;
  for(int i=1;i<=q;i++){
    while(pos<=n && arr[pos].r>=que[i].lim){
      upd2(1,1,n,arr[pos].a,arr[pos].v);
      pos++;
    }
    if(que[i].l>que[i].r) ans[que[i].id]=-1;
    else ans[que[i].id]=query2(1,1,n,que[i].l,que[i].r);
  }
  for(int i=1;i<=q;i++){
    if(ans[i]<2) ans[i]=-1;
    printf("%d\n",ans[i]);
  }
  return 0;
}