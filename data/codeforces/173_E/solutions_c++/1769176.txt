#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cassert>
#include <vector>
#include <algorithm>

using namespace std;

const int MaxN = 500005;
const int MaxS = MaxN * 4;

struct Node {
	int x, y;
	int id, L, R;
	bool operator<(const Node& other) const { return y < other.y; }
} node[MaxN], query[MaxN];
int ax[MaxN], top;
int tr[MaxN], N, K, M;
int ret[MaxN], cnt[MaxN];
vector<pair<int, pair<int, int> > > vt;

int getID(int x) {
	return lower_bound(ax, ax + top, x) - ax + 1;
}

struct Seg {
	int L, R, mx;
} seg[MaxS];

void init(int k, int L, int R) {
	seg[k].L = L;
	seg[k].R = R;
	seg[k].mx = -1;
	if (L == R) {
		return;
	}
	int mid = (L + R) >> 1;
	init(k << 1, L, mid);
	init(k << 1 | 1, mid + 1, R);
}

void add(int k, int idx, int v) {
	if (seg[k].L > idx || seg[k].R < idx) return;
	if (seg[k].L == seg[k].R) {
		seg[k].mx = max(seg[k].mx, v);
		return;
	}
	add(k << 1, idx, v);
	add(k << 1 | 1, idx, v);
	seg[k].mx = max(seg[k << 1].mx, seg[k << 1 | 1].mx);
}

int read(int k, int L, int R) {
	if (L > R || seg[k].L > R || seg[k].R < L) return -1;
	if (seg[k].L >= L && seg[k].R <= R) return seg[k].mx;
	return max(read(k << 1, L, R), read(k << 1 | 1, L, R));
}

void add(int k, int v) {
	while (k <= top) {
		tr[k] += v;
		k += k & -k;
	}
}

int read(int k) {
	int ret = 0;
	while (k) {
		ret += tr[k];
		k -= k & -k;
	}
	return ret;
}

int main() {
	while (scanf("%d%d", &N, &K) == 2) {
		top = 0;
		vt.clear();
		for (int i = 0; i < N; i++)
			scanf("%d", &node[i].y);
		for (int i = 0; i < N; i++) {
			scanf("%d", &node[i].x);
			ax[top++] = node[i].x;
			ax[top++] = node[i].x - K;
			ax[top++] = node[i].x + K;
		}
		scanf("%d", &M);
		for (int i = 0; i < M; i++) {
			int u, v;
			scanf("%d%d", &u, &v);
			u--;
			v--;
			query[i].y = max(node[u].y, node[v].y);
			query[i].L = max(node[u].x, node[v].x) - K;
			query[i].R = min(node[u].x, node[v].x) + K;
			query[i].id = i;
			ax[top++] = query[i].L;
			ax[top++] = query[i].R;
		}
		sort(ax, ax + top);
		top = unique(ax, ax + top) - ax;
		sort(node, node + N);
		sort(query, query + M);
		memset(tr, 0, sizeof(tr));
		init(1, 1, top);
		for (int i = 0, j; i < N; i = j) {
			j = i;
			while (j < N && node[i].y == node[j].y) j++;
			for (int k = i; k < j; k++) add(getID(node[k].x), 1);
			for (int k = i; k < j; k++) vt.push_back(make_pair(node[k].y, make_pair(getID(node[k].x), max(ret[getID(node[k].x)], read(getID(node[k].x + K)) - read(getID(node[k].x - K) - 1)))));
		}
		sort(vt.begin(), vt.end());
		for (int i = N - 1, j = M - 1; j >= 0;) {
			if (i >= 0 && vt[i].first >= query[j].y) {
				add(1, vt[i].second.first, vt[i].second.second);
				i--;
			} else {
				ret[query[j].id] = read(1, getID(query[j].L), getID(query[j].R));
				j--;
			}
		}
		for (int i = 0; i < M; i++)
			printf("%d\n", ret[i]);
	}
	return 0;
}

