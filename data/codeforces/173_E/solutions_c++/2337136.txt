#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn = 101011;
const int M = 262144;

struct node {int r,a,l;}c[maxn];
bool cmp(const node a, const node b) {return a.r < b.r;}
struct query {int x,y,r,l;}q[maxn];
bool qcmp(const query a, const query b) {return a.r < b.r;}
bool qcmp2(const query a, const query b) {return a.l < b.l;}
/*---------------------------------------------------------------------------*/
class tree {
      public :
             tree() {flash();N = M>> 1;}
             void flash();
             void ins(int x, int k);
             int sum(int l, int r);
             int max_(int l, int r);
      private :
              int s[M],d[M]; // s : sum , d : max
              int ret, N;
};
void tree:: flash() {
     fill(s, s + M, 0);
     fill(d, d + M, -1);
}
void tree:: ins(int x, int k) {
     for (x +=N; x; x>>= 1) {
         s[x] += k;
         d[x] = max(d[x], k);
     }
}
int tree:: sum(int l, int r) {
    for (l+=N-1,r+=N+1,ret = 0; l^r^1; l>>=1,r>>=1) {
        if (~l & 1) ret += s[l ^ 1];
        if (r & 1) ret += s[r ^ 1];
    }
    return ret;
}
int tree:: max_(int l, int r) {
    if (l > r) return -1;
    for (l+=N-1,r+=N+1,ret = -1; l^r^1; l>>=1,r>>=1) {
        if (~l & 1) ret = max(ret, d[l^1]);
        if (r & 1) ret = max(ret, d[r^1]);
    }
    return ret;
}
/*---------------------------------------------------------------------------*/
tree T;
int f[maxn],ls[maxn],lsn,n,k,Q;

void lisan() {
     for (int i = 1; i <= n; ++i) ls[i] = c[i].a;
     sort(ls + 1, ls + n + 1);
     lsn = unique(ls + 1, ls + n + 1) - ls-1;
}
int site(int x) {
    return lower_bound(ls + 1, ls + lsn + 1, x) - ls;
}
int rsite(int x) {
    return upper_bound(ls + 1, ls + lsn + 1, x) - ls - 1;
}

int main() {
    //freopen("camp.in", "r", stdin);freopen("camp.out", "w", stdout);
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; ++i) scanf("%d", &c[i].r);
    for (int i = 1; i <= n; ++i) scanf("%d", &c[i].a);
    for (int i = 1; i <= n; ++i) c[i].l = i;
    scanf("%d", &Q);
    for (int i = 1,x1,y1; i <= Q; ++i) {
        scanf("%d%d", &x1, &y1);
        q[i].x = max(c[x1].a-k, c[y1].a-k);
        q[i].y = min(c[x1].a+k, c[y1].a+k);
        q[i].r = max(c[x1].r, c[y1].r);
        q[i].l = i;
    }
    
    lisan();
    sort(c + 1, c + n + 1, cmp);
    c[n+1].r = c[n].r+1;
    for (int i = 1,j = 1; i <= n; ++i) {
        for (;c[j].r <= c[i].r; ++j) T.ins(site(c[j].a), 1);
        f[i] = T.sum(site(c[i].a - k), rsite(c[i].a + k) );
    }
    
    T.flash();
    sort(q + 1, q + Q + 1, qcmp);
    for (int i = Q,j = n; i; --i) {
        for (;c[j].r >= q[i].r;--j) T.ins(site(c[j].a), f[j]);
        if (q[i].x <= q[i].y) q[i].r = T.max_(site(q[i].x), rsite(q[i].y) );
        else q[i].r = -1;
    }
    
    sort(q + 1, q + Q + 1, qcmp2);
    for (int i = 1; i <= Q; ++i) printf("%d\n", q[i].r);
    return 0;
}
