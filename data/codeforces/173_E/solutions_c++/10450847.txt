#include <bits/stdc++.h>

using namespace std;

#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)

#define type(x) __typeof(x.begin())

#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair < int ,int > pii;

typedef long long ll;

const int inf = 1e9, mod = 1e9+7;
const int N = 4e5+5;

int w[N], x, y, z, size[N], ST[4 * N], F[N],i ,j, k, n, m, ans[N];

pair< pii , int > a[N];

map< int , vector< pii > > U;
map< int , vector< pair< pii , int > > > q;
map< int ,int > h;

int que(int x,int y){
	int sum = 0; x--;
	for(;y > 0;y -= y&-y) sum += F[y];
	for(;x > 0;x -= x&-x) sum -= F[x];
	return sum;	
}

void upd(int x){ for(;x && x < N; x+=x&-x) F[x]++;}

int query(int k,int bas,int son,int x,int y){
	if(bas > y || son < x) return -1;
	if(x <= bas && son <= y) return ST[k];
	return max(query(sol,bas,orta,x,y),query(sag,orta+1,son,x,y));
}

int update(int k,int bas,int son,int x,int t){
	if(bas > x || son < x) return ST[k];
	if(x <= bas && son <= x) return ST[k] = max(ST[k],t);
	return ST[k] = max(update(sol,bas,orta,x,t),update(sag,orta+1,son,x,t));
}

int main(){
	
	memset(ST,-1,sizeof ST);

	scanf("%d %d",&n,&k);

	FOR(i,1,n) scanf("%d",&a[i].st.st);
	FOR(i,1,n){ scanf("%d",&a[i].st.nd); a[i].nd = i; h[a[i].st.nd] = h[a[i].st.nd-k] = h[a[i].st.nd+k] = 1;  }

	int s = 0;

	sort(a+1,a+n+1);

	FOR(i,1,n) w[a[i].nd] = i;

	foreach(it,h) it->nd = ++s;

	int j = 1;

	FOR(i,1,n){
		while(j <= n && a[j].st.st <= a[i].st.st){ upd(h[a[j].st.nd]); j++; }
		size[i] = que(h[a[i].st.nd-k],h[a[i].st.nd+k]);
		U[a[i].st.st].pb(mp(a[i].st.nd,size[i]));
	}

	scanf("%d",&m);

	FOR(i,1,m){
		scanf("%d %d",&x,&y);
		if(w[x] < w[y]) swap(x,y);
		if(a[w[x]].st.nd < a[w[y]].st.nd) q[a[w[x]].st.st].pb(mp(mp(a[w[x]].st.nd,a[w[y]].st.nd),i)); 
		else q[a[w[x]].st.st].pb(mp(mp(a[w[y]].st.nd,a[w[x]].st.nd),i)); 
	}

	for(map< int , vector< pii > > :: reverse_iterator it = U.rbegin(); it != U.rend() ; it++){
		foreach(it2,it->nd) update(1,1,N,h[it2->st],it2->nd);
		foreach(it2,q[it->st]) ans[it2->nd] = query(1,1,N,h[it2->st.nd-k],h[it2->st.st+k]);
	}

	FOR(i,1,m) printf("%d\n",ans[i]);

    return 0;
}
