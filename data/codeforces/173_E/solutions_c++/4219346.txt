//In the name of God
#include <algorithm>
#include <iostream>
using namespace std;

const int N = 1e5 + 2;

struct pii {
	int name, first, second;
} q[N];

int n, m, k, ans[N], a[N], t[4 * N], adr[N], age[N], grp[N], u[N], v[N], r[N], per[N], tmp[N], f[N];

bool by_r(int x, int y) { return r[x] < r[y]; }
bool by_second_r(pii x, pii y) { return r[x.second] < r[y.second]; }
bool by_a(int x, int y) { return a[x] < a[y]; }
void insert(int m) {
	m++;
	int b = m & -m;
	while (m <= n) {
		f[m]++;
		while (m & b) {
			m &= ~b;
			b <<= 1;
		}
		m |= b;
	}
}
void segment_insert(int n, int b, int e, int x, int k) {
	if (b == e) {
		t[n] = k;
		return;
	}
	int l = n << 1, r = l | 1, m = b + e >> 1;
	if (x <= m)
		segment_insert(l, b, m, x, k);
	else
		segment_insert(r, m + 1, e, x, k);
	t[n] = max(t[l], t[r]);
}
int query(int m) {
	m++;
	int res = 0;
	while (m) {
		res += f[m];
		m -= m & -m;
	}
	return res;
}
int segment_query(int n, int b, int e, int u, int v) {
	if (e < u || v < b)
		return -1;
	if (u <= b && e <= v)
		return t[n];
	int l = n << 1, r = l | 1, m = b + e >> 1;
	return max(segment_query(l, b, m, u, v), segment_query(r, m + 1, e, u, v));
}
int main() {
	ios_base::sync_with_stdio(false);
	cin >> n >> k;
	for (int i = 0; i < n; i++)
		per[i] = i;
	for (int i = 0; i < n; i++)
		cin >> r[i];
	for (int i = 0; i < n; i++) {
		cin >> a[i];
		tmp[i] = a[i];
	}
	sort(tmp, tmp + n);
	for (int i = 0; i < n; i++) {
		u[i] = lower_bound(tmp, tmp + n, a[i] - k) - tmp;
		v[i] = upper_bound(tmp, tmp + n, a[i] + k) - 1 - tmp;
	}
	sort(per, per + n, by_a);
	for (int i = 0; i < n; i++)
		age[per[i]] = i;
	sort(per, per + n, by_r);
	int p1 = 0, p2 = 0;
	while (p1 < n) {
		while (p2 < n && r[per[p1]] == r[per[p2]]) {
			insert(age[per[p2]]);
			p2++;
		}
		while (p1 < p2) {
			grp[per[p1]] = query(v[per[p1]]) - query(u[per[p1]] - 1);
			p1++;
		}
	}
	cin >> m;
	for (int i = 0; i < m; i++) {
		cin >> q[i].first >> q[i].second;
		q[i].first--, q[i].second--;
		q[i].name = i;
		if (r[q[i].first] > r[q[i].second])
			swap(q[i].first, q[i].second);
	}
	sort(q, q + m, by_second_r);
	fill(t, t + 4 * n + 2, -1);
	for (int i = m - 1, p = n - 1; i >= 0; i--) {
//		cerr << q[i].first + 1 << ' ' << q[i].second + 1 << ' ' << q[i].name + 1 << '\n';
		while (p >= 0 && r[per[p]] >= r[q[i].second]) {
			segment_insert(1, 0, n - 1, age[per[p]], grp[per[p]]);
//			cerr << "now " << per[p] + 1 << " is in\n"; 
			p--;
		}
		int b = max(u[q[i].second], u[q[i].first]), e = min(v[q[i].first], v[q[i].second]);
//		if (!q[i].name)
//			cerr << tmp[b] << ' ' << tmp[e] << '\n';
		if (b > e)
			ans[q[i].name] = -1;
		else {
			ans[q[i].name] = segment_query(1, 0, n - 1, b, e);
//			if (ans[q[i].name] == -1)
//				cerr << "YES!\n";
		}
//		cerr << q[i].name + 1 << ":" << ans[q[i].name] << '\n';
	}
	for (int i = 0; i < m; i++)
		cout << ans[i] << '\n';
	return 0;
}
