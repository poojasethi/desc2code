#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>

#define REP(AA,BB) for(int AA=0; AA<(BB); ++AA)
#define FOR(AA,BB,CC) for(int AA=(BB); AA<(CC); ++AA)
#define FC(AA,BB) for(__typeof((AA).begin()) BB=(AA).begin(); BB!=(AA).end(); ++BB)
#define SZ(AA) ((int)((AA).size()))
#define ALL(AA) (AA).begin(), (AA).end()
#define PB push_back
#define MP make_pair

using namespace std;

typedef vector<int> VI;
typedef pair<int, int> PII;
typedef long long LL;
typedef long double LD;

const int MAXN = 100010, MAXD = 1000100;
int r[MAXN], a[MAXN], g[MAXN];
map<int, int> ma;

int cnt[MAXD], MX;

int get(int b) {
    int res = 0;
    while (b > 0) {
        res += cnt[b];
        b -= (b & (-b));
    }
    return res;
}

void add(int b) {
    while (b <= MX) {
        ++cnt[b];
        b += (b & (-b));
    }
}

int mx[1 << 20], BASE;

void dod(int x, int v) {
    x += BASE;
    while (x > 0) {
        mx[x] = max(mx[x], v);
        x >>= 1;
    }
};

int wez(int x, int y) {
    x += BASE; y += BASE;
    int res = max(mx[x], mx[y]);
    while ((x >> 1) != (y >> 1)) {
        if (x % 2 == 0)
            res = max(res, mx[x + 1]);
        if (y % 2 == 1)
            res = max(res, mx[y - 1]);
        x >>= 1;
        y >>= 1;
    }
    return res;
}

int wyn[MAXN]; PII q[MAXN];

int cmp(int x, int y) {
    return max(r[q[x].first], r[q[x].second]) < max(r[q[y].first], r[q[y].second]);
}

int main(void) {
    int n, K; scanf("%d%d", &n, &K);
    REP (i, n)
        scanf("%d", &r[i]);
    REP (i, n)
        scanf("%d", &a[i]);
    REP (i, n) {
        ma[a[i]] = 1;
        ma[a[i] - K] = 1;
        ma[a[i] + K] = 1;
    }
    int M = 1;
    FC (ma, it)
        ma[it->first] = M++;
    vector<PII> v;
    REP (i, n)
        v.PB(MP(r[i], i));
    sort(ALL(v));
    MX = M;
    for (int i = 0; i < n; ) {
        int lim;
        for (lim = i; lim < n && v[i].first == v[lim].first; ++lim);
        FOR (j, i, lim) {
            int k = v[j].second;
            add(ma[a[k]]);
        }
        FOR (j, i, lim) {
            int k = v[j].second;
            g[k] = get(ma[a[k] + K]) - get(ma[a[k] - K] - 1);
            //printf("%d -> %d %d\n", k, ma[a[k] + K], ma[a[k] - K]);
        }
        i = lim;
    }
    //REP (i, n)
      //  printf("%d ", g[i]); puts("");
    int Q; scanf("%d", &Q);
    REP (i, Q) {
        scanf("%d%d", &q[i].first, &q[i].second);
        --q[i].first; --q[i].second;
        if (a[q[i].first] > a[q[i].second])
            swap(q[i].first, q[i].second);
    }
    for (BASE = 1; BASE < MX; BASE <<= 1);
    VI kol;
    REP (i, Q)
        kol.PB(i);
    sort(ALL(kol), cmp);
    for (int i = Q - 1; i >= 0; --i) {
        int x = kol[i];
        while (!v.empty() && v.back().first >= max(r[q[x].first], r[q[x].second])) {
            dod(ma[a[v.back().second]], g[v.back().second]);
            v.pop_back();
        }
        if (a[q[x].second] - K <= a[q[x].first] + K)
            wyn[x] = wez(ma[a[q[x].second] - K], ma[a[q[x].first] + K]);
        else
            wyn[x] = -1;
    }
    REP (i, Q) {
        if (wyn[i] == 0)
            wyn[i] = -1;
        printf("%d\n", wyn[i]);
    }
    return 0;
}

