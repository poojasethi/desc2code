#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<ctime>
#include<cctype>
#include<algorithm>
#include<string>
#include<queue>
#include<vector>
#include<iomanip>
using namespace std;
#define clr(f,x) memset(f,x,sizeof f)
#define rep(it,a,b) for(int it=a;it<=b;++it)
#define _rep(it,a,b) for(int it=a;it>=b;--it)
#define vrep(it,a) for(int it=a;it--;)
#define LL long long
#define PII pair<int,int>
#define X first
#define Y second
#define mp make_pair
#define pb push_back
#define lb lower_bound
#define tree x,int l,int r
#define M int mid=l+r>>1
const int inf=1000000000;
const int MaxN=100010;
const int MaxL=5000010;
const int MaxS=5000010;
int n,k;
int r[MaxN],a[MaxN],fr[MaxN],num[MaxN],p[MaxN];
PII b[MaxN];
int le[MaxL],ri[MaxL],s[MaxL],root=0,tt=0;
void ins(int &tree,int y){
	if(!x)x=++tt;
	++s[x];
	if(l==r)return; M;
	if(y>mid)ins(ri[x],mid+1,r,y);else ins(le[x],l,mid,y);
}
int query(int tree,int _l,int _r){
	if(!x)return 0;
	if(l==_l&&r==_r)return s[x]; M;
	if(_l>mid)return query(ri[x],mid+1,r,_l,_r);
	else if(_r<=mid)return query(le[x],l,mid,_l,_r);
		else return query(le[x],l,mid,_l,mid)+query(ri[x],mid+1,r,mid+1,_r);
}
int tl[MaxS],tr[MaxS],pk[MaxS],rt[MaxN],pt=0;
inline int node(int l,int r,int s){
	tl[++pt]=l,tr[pt]=r,pk[pt]=s;
	return pt;
}
int change(int tree,int y,int z){
	if(l==r)return node(0,0,max(pk[x],z)); M;
	if(y>mid)return node(tl[x],change(tr[x],mid+1,r,y,z),max(pk[x],z));
		else return node(change(tl[x],l,mid,y,z),tr[x],max(pk[x],z));
}
int solve(int tree,int _l,int _r){
	if(!x)return 0;
	if(l==_l&&r==_r)return pk[x]; M;
	if(_l>mid)return solve(tr[x],mid+1,r,_l,_r);
	else if(_r<=mid)return solve(tl[x],l,mid,_l,_r);
		else return max(solve(tl[x],l,mid,_l,mid),solve(tr[x],mid+1,r,mid+1,_r));
}
int main(){
	cin>>n>>k;
	rep(i,1,n)scanf("%d",r+i),b[i].X=r[i],b[i].Y=i;
	rep(i,1,n)scanf("%d",a+i);
	sort(b+1,b+n+1);
	//rep(i,1,n)cout<<b[i].X<<" "<<b[i].Y<<endl;
	rep(i,1,n)p[b[i].Y]=i;
	for(int i=1,j;i<=n;i=j+1){
		for(j=i;j<n&&b[j+1].X==b[j].X;++j);
		rep(z,i,j)fr[z]=i,ins(root,1,inf,a[b[z].Y]);
		rep(z,i,j)num[z]=query(root,1,inf,max(1,a[b[z].Y]-k),min(a[b[z].Y]+k,inf));
		//cout<<i<<" "<<j<<endl;
	}
	//rep(i,1,n)printf("i=%d %d %d\n",i,a[b[i].Y],num[i]);
	rt[n+1]=0;
	_rep(i,n,1)rt[i]=change(rt[i+1],1,inf,a[b[i].Y],num[i]);
	int T,x,y,ax,ay;cin>>T;
	while(T--){
		scanf("%d%d",&x,&y),ax=a[x],ay=a[y],x=p[x],y=p[y];
		if(x>y)swap(x,y);
		if(ax>ay)swap(ax,ay);
		int ans=solve(rt[fr[y]],1,inf,ay-k,ax+k);
		//if(ans<=1)printf("-1\n");else printf("%d\n",ans);
		printf("%d\n",ans<=1?-1:ans);
	}
	//cout<<tt<<" "<<pt<<endl;
	return 0;
}
