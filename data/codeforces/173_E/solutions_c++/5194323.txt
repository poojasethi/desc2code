// in the name of god

#include<iostream>
#include<cstring>
#include<vector>
#include<cstdio>
#include<map>
#include<algorithm>
#include<utility>
#include<cstring>

#define PB push_back
#define PII pair<ll,ll>
#define S second
#define F first
#define MP make_pair

typedef long long ll;

using namespace std;

const int maxn=1000*100+100;

ll k,m,n,r[maxn],a[maxn],c[maxn],ans[maxn],d[maxn][2],l,t[maxn],maxx[4*maxn];

pair<PII,ll >rm[maxn],am[maxn];

pair<PII,PII>q[maxn];

PII b[maxn];

struct fen{
	ll tree[maxn];
	fen(){
		memset(tree,0,sizeof tree);
	}
	ll C(ll x){
		ll ret=0;
		for(;x>0;x-=x&(-x))
			ret+=tree[x];
		return ret;
	}
	ll sum(ll i,ll j){
		return C(j)-C(i-1);
	}
	void update(ll x,ll val){
		for(;x<maxn;x+=x&(-x))
			tree[x]+=val;
	}
};

void update(ll x,ll val,ll l=1,ll r=n,ll cnt=1){
	if(x<l || r<x)
		return;
	if(l==r){
		maxx[cnt]=val;
		return;
	}
	ll med=(l+r)/2;
	update(x,val,l,med,2*cnt);
	update(x,val,med+1,r,2*cnt+1);
	maxx[cnt]=max(maxx[2*cnt],maxx[2*cnt+1]);
}

ll f_max(ll x,ll y,ll l=1,ll r=n,ll cnt=1){
	if(y<l || r<x)
		return 0;
	if(x<=l && r<=y)
		return maxx[cnt];
	ll med=(l+r)/2;
	return max(f_max(x,y,l,med,2*cnt),f_max(x,y,med+1,r,2*cnt+1));
}

PII help(ll i){
	ll x=q[i].S.F,y=q[i].S.S;
	x=c[x];
	y=c[y];
	if(x>y)
		swap(x,y);
	ll u1=max(d[x][0],d[y][0]);
	ll u2=min(d[x][1],d[y][1]);
	if(u2<u1)
		return MP(-1,-1);
	return MP(u1,u2);
}

fen f;

int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		cin>>r[i];
	for(int i=1;i<=n;i++)
		cin>>a[i];
	cin>>m;
	for(int i=1;i<=m;i++){
		ll x,y;
		cin>>x>>y;
		q[i]=MP(MP(max(r[x],r[y]),i),MP(x,y));
	}
	for(int i=1;i<=n;i++){
		am[i]=MP(MP(a[i],r[i]),i);
		rm[i]=MP(MP(r[i],a[i]),i);
	}
	sort(am+1,am+n+1);
	sort(rm+1,rm+n+1);
	sort(a+1,a+n+1);
	sort(q+1,q+m+1);
	for(int i=1;i<=n;i++){
		ll x=am[i].S;
		ll k1=lower_bound(a+1,a+n+1,a[i]-k)-a;
		ll k2=upper_bound(a+1,a+n+1,a[i]+k)-a;
		k2--;
		d[i][0]=k1;
		d[i][1]=k2;
		c[x]=i;
	}
	l=1;
	for(int i=1;i<=n;){
		while(rm[i+1].F.F==rm[i].F.F){
			ll x1=rm[i].S;
			ll x2=c[x1];
			f.update(x2,1);
			i++;
		}
		ll x1=rm[i].S;
		ll x2=c[x1];
		f.update(x2,1);
		for(int j=l;j<=i;j++){
			ll x1=rm[j].S;
			ll x2=c[x1];
			t[x2]=f.sum(d[x2][0],d[x2][1]);	
		}
		i++;
		l=i;
	}
	l=n;
	for(int i=m;i>=1;i--){
		while(rm[l].F.F >= q[i].F.F){
			ll x1=rm[l].S;
			ll x2=c[x1];
			update(x2,t[x2]);
			l--;
		}	
		PII h=help(i);
		if(h.F==-1)
			ans[q[i].F.S]=-1;
		else
			ans[q[i].F.S]=f_max(h.F,h.S);
		if(!ans[q[i].F.S])
			ans[q[i].F.S]=-1;
	}
	for(int i=1;i<=m;i++)
		cout<<ans[i]<<endl;
	return 0;
}
