#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>

using namespace std;

const int N=100012,inf=2147483647;
int n,k,m,a,b,ans[N],x[N],tot=0,past[N];
struct man{int a,b,id,k;} w[N];
struct ask{int x,id,lb,rb;} q[N];
inline bool operator < (man a,man b)
  {
    return a.a<b.a;
  }
inline bool operator < (ask a,ask b)
  {
    return a.x<b.x;
  }
struct BIT
  {
    int c[N];
    inline int lowbit(int k) {return k&(-k);}
    inline void insert(int k,int t)
      {
        while (k<=tot) c[k]=c[k]+t,k+=lowbit(k);
      }
    inline int sum(int k)
      {
        int ans=0;while (k) ans=ans+c[k],k-=lowbit(k);
        return ans;
      }
  } B;
int find(int k)
  {
    int l=1,r=tot,mid,ans=0;
    while (l<=r)
      {
        mid=(l+r)>>1;
        if (past[mid]<=k) ans=mid,l=mid+1;else r=mid-1;
      }
    return ans;
  }
struct Xnode
  {
    Xnode *lch,*rch;
    int l,r,Max;
    inline void update(){Max=max(lch->Max,rch->Max);}
    inline void insert(int k,int x)
      {
        if (l==r) {Max=max(Max,x);return;}
        int mid=(l+r)>>1;
        if (k<=mid) lch->insert(k,x);else rch->insert(k,x);
        update();
      }
    inline int ask(int left,int right)
      {
        if (left>right) return 0;
        if (left<=l && right>=r) return Max;
        int mid=(l+r)>>1,ans=-inf;
        if (left<=mid) ans=max(ans,lch->ask(left,right));
        if (right>mid) ans=max(ans,rch->ask(left,right));
        return ans;
      }
  } X[N*2],*P=X,*root;
inline void build(Xnode *&node,int left,int right)
  {
    node=P++;node->l=left;node->r=right;
    int mid=(left+right)>>1;
    if (left==right) {node->Max=0;return;}
    build(node->lch,left,mid);
    build(node->rch,mid+1,right);
    node->update();
  }
int main()
  {
    scanf("%d%d",&n,&k);
    for (int i=1;i<=n;++i) scanf("%d",&w[i].a);
    for (int i=1;i<=n;++i) scanf("%d",&w[i].b),x[i]=w[i].b;
    for (int i=1;i<=n;++i) w[i].id=i;
    scanf("%d",&m);
    for (int i=1;i<=m;++i) 
      {
        scanf("%d%d",&a,&b);
        q[i].x=max(w[a].a,w[b].a),q[i].id=i;
        q[i].lb=w[a].b;q[i].rb=w[b].b;
        if (q[i].lb>q[i].rb) swap(q[i].lb,q[i].rb);
      }
    sort(x+1,x+n+1);x[0]=-inf;
    for (int i=1;i<=n;++i)
      if (x[i]!=x[i-1]) past[++tot]=x[i];
    sort(w+1,w+n+1);
    sort(q+1,q+m+1);
    int j;
    for (int i=1;i<=n;i=++j) 
      {
        for (j=i;j<n && w[j+1].a==w[j].a;++j);
        for (int l=i;l<=j;++l) B.insert(find(w[l].b),1);
        for (int l=i;l<=j;++l) w[l].k=B.sum(find(w[l].b+k))-B.sum(find(w[l].b-k-1));
      }
    build(root,1,tot);
    int t=n;
    for (int i=m;i;--i)
      {
        while (q[i].x<=w[t].a) root->insert(find(w[t].b),w[t].k),--t;
        ans[q[i].id]=root->ask(find(q[i].rb-k-1)+1,find(q[i].lb+k));
      }
    for (int i=1;i<=m;++i) 
      if (ans[i]>=2) printf("%d\n",ans[i]);else puts("-1");
  }
    
    
    
    