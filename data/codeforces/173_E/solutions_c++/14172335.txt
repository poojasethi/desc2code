#include<cstdio>
#include<utility>
#include<algorithm>
#define lb lower_bound
#define ub upper_bound
#define fi first
#define se second
#define fo(i,a,b) for(i=a;i<=b;++i)
using namespace std;
typedef pair<int,int> node;
const int mn=101000;
int n,m,i,j,k,x,y,la,K;
node a[mn];
int T[mn*4],ans[mn],f[mn],v[mn],xs[mn],L;
struct pro{int x,y,t,d;}q[mn];
bool cmp(pro a,pro b){return a.t>b.t;}
void add(int p)
{
    for(;p<=L;p+=p&(-p))++f[p];
}
int sum(int p)
{
    int res=0;
    for(;p;p-=p&(-p))res+=f[p];
    return res;
}
int query(int p,int l,int r,int x,int y)
{
    if(x>y)return 0;
    if(x<=l&&y>=r)return T[p];
    int m=(l+r)/2;
    int t1=0,t2=0;
    if(x<=m)t1=query(p+p,l,m,x,y);
    if(y>m)t2=query(p+p+1,m+1,r,x,y);
    return max(t1,t2);
}
void ins(int p,int l,int r,int k,int v)
{
    T[p]=max(T[p],v);
    if(l==r)return;
    int m=(l+r)/2;
    if(k<=m)ins(p+p,l,m,k,v);
    else ins(p+p+1,m+1,r,k,v);
}
int main()
{
    scanf("%d%d",&n,&K);
    fo(i,1,n)scanf("%d",&a[i].fi);
    fo(i,1,n)scanf("%d",&a[i].se),xs[i]=a[i].se;
    sort(xs+1,xs+1+n),L=unique(xs+1,xs+1+n)-xs-1;
    scanf("%d",&m);
    fo(i,1,m)
    {
        scanf("%d%d",&j,&k);
        q[i].t=max(a[j].fi,a[k].fi);
        q[i].x=max(a[j].se,a[k].se)-K;
        q[i].y=min(a[j].se,a[k].se)+K;
        q[i].d=i;
    }
    sort(a+1,a+1+n);
    j=0;
    fo(i,1,n)
    {
        for(;j<n&&a[j+1].fi<=a[i].fi;)
        {
            ++j,k=lb(xs+1,xs+1+L,a[j].se)-xs;
            add(k);
        }
        x=lb(xs+1,xs+1+L,a[i].se-K)-xs;
        y=ub(xs+1,xs+1+L,a[i].se+K)-xs-1;
        v[i]=sum(y)-sum(x-1);
    }
    sort(q+1,q+1+m,cmp);
    j=n+1;
    fo(i,1,m)
    {
        for(;j&&a[j-1].fi>=q[i].t;)
        {
            --j,k=lb(xs+1,xs+1+L,a[j].se)-xs;
            ins(1,1,n,k,v[j]);
        }
        x=lb(xs+1,xs+1+L,q[i].x)-xs;
        y=ub(xs+1,xs+1+L,q[i].y)-xs-1;
        ans[q[i].d]=query(1,1,n,x,y);
    }
    fo(i,1,m)
        if(ans[i]==0)printf("-1\n");
        else printf("%d\n",ans[i]);
    return 0;
}
