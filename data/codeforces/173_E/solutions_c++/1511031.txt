#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

int n,q,rng,mm[100010],x[100010],tot[100010],s[100010],N;

int Min(int a,int b){return a<b?a:b;}

int Max(int a,int b){return a<b?b:a;}

struct peo
{
	int r,a,o;
	bool operator <(peo y) const
	{
		return r<y.r;
	}
} p[100010];

struct tt
{
	int l,r,mx;
	tt *c[2];
	tt(){}
	tt(int L,int R){l=L; r=R; mx=-1; c[0]=c[1]=0;}
	tt *insert(int p,int key)
	{
		tt *res; res=new tt(l,r);
		res->mx=Max(key,mx);
		if (l==r) return res;
		int mid=(l+r)/2;
		if (!c[0]) c[0]=new tt(l,mid);
		if (!c[1]) c[1]=new tt(mid+1,r);
		res->c[0]=c[0]; res->c[1]=c[1];
		if (p<=mid) res->c[0]=c[0]->insert(p,key);
		else res->c[1]=c[1]->insert(p,key);
		return res;
	}
	int ask(int L,int R)
	{
		int res=-1;
		if (L>R) return -1;
		if (l>=L && r<=R) return mx;
		int mid=(l+r)/2;
		if (c[0] && L<=mid) res=Max(res,c[0]->ask(L,R));
		if (c[1] && R>mid) res=Max(res,c[1]->ask(L,R));
		return res;
	}
}*seg[100010];

void add(int x)
{
	for (;x<=n;x+=(x & (-x)))
		tot[x]++;
}

int count(int x)
{
	if (!x) return 0;
	int res=0;
	for (;x;x-=(x & (-x))) res+=tot[x];
	return res;
}

int main()
{
//	freopen("173.in","r",stdin); freopen("173.out","w",stdout);
	scanf("%d%d",&n,&rng);
	for (int i=0;i<n;i++) scanf("%d",&p[i].r);
	for (int i=0;i<n;i++) scanf("%d",&p[i].a),p[i].o=i,x[i]=p[i].a;
	sort(x,x+n);
	N=unique(x,x+n)-x;
	sort(p,p+n);
	for (int i=0;i<n;i++) s[p[i].o]=i;
	for (int i=0;i<n;)
	{
		int j; for (j=i;j<n && p[j].r==p[i].r;j++) add(lower_bound(x,x+N,p[j].a)-x+1);
		for (int k=i;k<j;k++) 
		{
			mm[k]=count(upper_bound(x,x+N,p[k].a+rng)-x)-count(lower_bound(x,x+N,p[k].a-rng)-x);
//			if (k==46) printf("%d %d %d\n",lower_bound(x,x+n,p[j].a)-x+1,upper_bound(x,x+N,p[k].a+rng)-x,lower_bound(x,x+N,p[k].a-rng)-x);
		}
		i=j;
	}
//	for (int i=0;i<n;i++) printf("%d:%d\n",i,mm[i]);
	seg[n]=new tt(0,100000);
	for (int i=n-1;i>=0;i--)
		seg[i]=seg[i+1]->insert(lower_bound(x,x+N,p[i].a)-x,mm[i]);
	scanf("%d",&q);
	while (q--)
	{
//		puts("----------------------------");
		int xi,yi,mr,L,R;
		scanf("%d%d",&xi,&yi); xi--; yi--;
		xi=s[xi]; yi=s[yi];
		mr=Max(p[xi].r,p[yi].r);
		L=lower_bound(x,x+N,Max(p[xi].a,p[yi].a)-rng)-x;
		R=upper_bound(x,x+N,Min(p[xi].a,p[yi].a)+rng)-x-1;
//		printf("%d L:%d R:%d\n",lower_bound(p,p+n,(peo){mr,0,0})-p,L,R);
		printf("%d\n",seg[lower_bound(p,p+n,(peo){mr,0,0})-p]->ask(L,R));
	}
	return 0;
}
