#include <cstdio>
#include <cstring>
#include <algorithm>
#include <ctime>
#include <iostream>
using namespace std;

typedef unsigned int USN;
typedef long long LL;
typedef unsigned long long ULL;

#define rep(i,l,r) for (int i=(l); i<=(r); i++)
#define repd(i,r,l) for (int i=(r); i>=(l); i--)

#define maxn 100010

struct Index
{
	int n; int a[maxn];
	Index() { n=0; }
	void clear() 
	{ 
		n=0; 
	}
	void add(int x) 
	{ 
		a[++n]=x; 
	}
	void doit() 
	{ 
		sort(a+1,a+n+1); 
		n=unique(a+1,a+n+1)-(a+1); 
	}
	int ceiling(int v)	//find the maximum i that a[i]<=v
	{
		int x=lower_bound(a+1,a+n+1,v)-a;
		if (x>n || a[x]!=v) x--;
		return x;
	}
	int floor(int v) 		//find the minimum i that a[i]>=v
	{
		return lower_bound(a+1,a+n+1,v)-a;
	}
	int find(int v) 		//find v
	{
		return lower_bound(a+1,a+n+1,v)-a;
	}
};

Index Yi;

struct atype
{
	int r,y,where;
};

int cmpr(const atype &a, const atype &b)
{
	return a.r<b.r;
}

atype person[maxn];

struct BIT
{
	int n, a[maxn];
	void clear(int _n) { n=_n; memset(a,0,sizeof a); }
	void serere(int x, int y) { while (x<=n) a[x]+=y, x+=(x&(-x)); }
	int query(int x) { int res=0; while (x) res+=a[x], x-=(x&(-x)); return res; }
	int query(int l, int r) { return query(r)-query(l-1); }
};
BIT ta;

int where[maxn];

struct qtype
{
	int x1,x2,where;
};
qtype q[maxn];

int cmpx2(const qtype &a, const qtype &b)
{
	return a.x2>b.x2;
}

int final[maxn];

struct BITmax
{
	int n, a[maxn], d[maxn];
	void clear(int _n) { n=_n; memset(a,0,sizeof a); memset(d,0,sizeof d); }
	void serere(int x, int y) { d[x]=max(d[x],y); while (x<=n) a[x]=max(a[x],y), x+=(x&(-x)); }
	int query(int l, int r) 
	{
		int res=0;
		while (r>=l)
			if (r-(r&(-r))+1>=l)
				res=max(res,a[r]), r-=(r&(-r));
			else  res=max(res,d[r]), r--;
		return res;
	}
};
BITmax tb;

int w[maxn];

void lemon()
{
	int n,kallow; scanf("%d%d",&n,&kallow);
	rep(i,1,n) scanf("%d",&person[i].r);
	Yi.clear(); rep(i,1,n) scanf("%d",&person[i].y), Yi.add(person[i].y); Yi.doit();
	rep(i,1,n) person[i].where=i; 
	sort(person+1,person+n+1,cmpr);
	rep(i,1,n) where[person[i].where]=i;
	ta.clear(Yi.n);
	rep(i,1,n)
	{
		ta.serere(Yi.find(person[i].y),1);
		w[i]=ta.query(Yi.floor(person[i].y-kallow),Yi.ceiling(person[i].y+kallow));
	}
	int qa; scanf("%d",&qa);
	rep(i,1,qa) scanf("%d%d",&q[i].x1,&q[i].x2), q[i].x1=where[q[i].x1], q[i].x2=where[q[i].x2], q[i].where=i;
	rep(i,1,qa) if (q[i].x1>q[i].x2) swap(q[i].x1,q[i].x2);
	sort(q+1,q+qa+1,cmpx2);
	
	tb.clear(Yi.n);
	int cur=1;
	repd(i,n,1)
	{
		tb.serere(Yi.find(person[i].y),w[i]);
		while (cur<=qa && q[cur].x2==i)
		{
			int l=Yi.floor(max(person[q[cur].x1].y,person[q[cur].x2].y)-kallow);
			int r=Yi.ceiling(min(person[q[cur].x1].y,person[q[cur].x2].y)+kallow);
			if (l>r) 	
				final[q[cur].where]=-1;
			else  final[q[cur].where]=tb.query(l,r);
			cur++;
		}
	}
	rep(i,1,qa) if (!final[i]) final[i]=-1;
	rep(i,1,qa) printf("%d\n",final[i]);
}

int main()
{
	ios::sync_with_stdio(true);
	#ifndef ONLINE_JUDGE
		freopen("173E.in","r",stdin);
	#endif
	lemon();
	return 0;
}