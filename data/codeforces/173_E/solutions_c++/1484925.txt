#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#include <map>
using namespace std;
int n, k;
//seg tree
int p[500005];
void ins(int x, int L, int R, int where, int value) {
	if(L==R) {p[x]=max(p[x], value);return;}
	int M=(L+R)/2;
	if(where<=M) ins(x*2, L, M, where, value);
	else ins(x*2+1, M+1, R, where, value);
	p[x] = max(p[x*2], p[x*2+1]);
}
int qry(int x, int L, int R, int ll, int rr) {
	int ret=-1;
	if(ll<=L && rr>=R) return p[x];
	int M=(L+R)/2;
	if(ll<=M) ret=max(ret, qry(x*2, L, M, ll, rr));
	if(rr>M) ret=max(ret, qry(x*2+1, M+1, R, ll, rr));
	return ret;
}

int r[100005], a[100005], pos[100005];
int srt[100005], srta[100005];
int cover[100005];
map<int, int> ages;
int m=0;

bool cmpr(int x, int y) { return r[x]<r[y]; }
bool cmpa(int x, int y) { return a[x]<a[y]; }

int BIT[100005];
void add(int x, int v) {
	while(x<=m) {
		BIT[x]+=v;
		x += (x&-x);
	}
}
int BITask(int x) {
	int ret=0;
	while(x>0) {
		ret += BIT[x];
		x -= (x&-x);
	}
	return ret;
}
int ask(int age) {
	int ret=0;
	map<int, int>::iterator it = ages.upper_bound(age+k);
	--it;
	ret += BITask(it->second);
	it = ages.lower_bound(age-k);
	if(it != ages.begin()) {
		--it;
		ret -= BITask(it->second);
	}
	return ret;
}

class Query{
	public:
		int A, B, Rmax, qid;
		Query(){}
		Query(int _A, int _B, int _Rmax, int _qid) {
			A=_A; B=_B; Rmax=_Rmax; qid=_qid;
		}
		bool operator<(const Query &Q) const{
			return Rmax > Q.Rmax;
		}
} q[100005];

int ans[100005];
int main(void) {
	scanf("%d%d", &n, &k);
	for(int i=1;i<=n;i++) scanf("%d", &r[i]);
	for(int i=1;i<=n;i++) scanf("%d", &a[i]);
	for(int i=1;i<=n;i++) srt[i] = srta[i] = i;
	for(int i=1;i<=n;i++) ages[a[i]] = 0;
	sort(srt+1, srt+n+1, cmpr);
	
	for(map<int, int>::iterator it=ages.begin(); it!=ages.end();it++) it->second=++m;
	for(int ii=1,jj=1;ii<=n;ii=jj) {
		for(jj=ii;jj<=n && r[srt[ii]]==r[srt[jj]];jj++) add(ages[a[srt[jj]]], 1);
		for(jj=ii;jj<=n && r[srt[ii]]==r[srt[jj]];jj++) cover[jj] = ask(a[srt[jj]]);
	}
	memset(ans, -1, sizeof(ans));
	memset(p, -1, sizeof(p));
	int qq, qs=0;
	scanf("%d", &qq);
	for(int i=0;i<qq;i++) {
		int A, B;
		scanf("%d%d", &A, &B);
		q[i] = Query(A, B, max(r[A], r[B]), i);
	}
	sort(q, q+qq);
	for(int ii=n,jj=n;ii>=1;ii=jj) {
		for(jj=ii;jj>=1 && r[srt[ii]]==r[srt[jj]];jj--) ins(1, 1, m, ages[a[srt[jj]]], cover[jj]);
		while(qs<qq && q[qs].Rmax>=r[srt[ii]]) {
			int aA=a[q[qs].A], aB=a[q[qs].B]; if(aA>aB) swap(aA, aB);
			map<int, int>::iterator it=ages.upper_bound(aA+k);
			map<int, int>::iterator it2=ages.lower_bound(aB-k);
			--it;
			int qL=it2->second, qR=it->second;
			if(qL>qR) { qs++; continue; }
			ans[q[qs].qid] = qry(1, 1, m, qL, qR);
			qs++;
		}
	}
	for(int i=0;i<qq;i++)
		printf("%d\n", ans[i]);

	return 0;
}
