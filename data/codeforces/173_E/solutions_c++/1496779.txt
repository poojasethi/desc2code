#include <cstdio>
#include <cstdlib>
#include <cassert>
#include <cctype>
#include <ctime>
#include <cstring>
#include <cmath>
#include <string>
#include <map>
#include <set>
#include <iostream>
#include <map>
#include <sstream>
#include <algorithm>
#include <vector>
#define mp make_pair
#define pb push_back
#define fs first
#define sc second
#define sz(a) ((int) (a).size())
#define get_size(a) ((a) ? ((a)->size) : 0)
#define get_max(a) ((a) ? ((a)->max) : -1)
#define taskname "e"
using namespace std;

const int N = (int) 1e5;
int x[N], y[N], p[N], r[N], a[N], q[N], res[N], ans[N], m, n, k;

int cmp_r(int i, int j) {
	return r[i] < r[j];
}

int cmp_max_r(int i, int j) {
	return max(r[x[i]], r[y[i]]) < max(r[x[j]], r[y[j]]);
}

struct node {
	node *l, *r;
	int x, y, value, max, size;
	node(int x, int value): l(0), r(0), x(x), y((rand() << 16) | rand()), value(value), max(value), size(1) {}
};

void update(node *t) {
	t->max = max(t->value, max(get_max(t->l), get_max(t->r)));
	t->size = 1 + get_size(t->l) + get_size(t->r);
}

void split(node *t, int x, node *&l, node *&r) {
	if (!t) {
		l = 0;
		r = 0;
		return;
	}
	if (t->x <= x) {
		split(t->r, x, t->r, r);
		l = t;
	} else {
		split(t->l, x, l, t->l);
		r = t;
	}
	update(t);
}

node* merge(node *l, node *r) {
	if (!l) return r;
	if (!r) return l;
	if (l->y < r->y) {
		l->r = merge(l->r, r);
		update(l);
		return l;
	} else {
		r->l = merge(l, r->l);
		update(r);
		return r;
	}
}

void insert(node *&root, node *t) {
	if (!root || (root->y > t->y)) {
		split(root, t->x, t->l, t->r);
		root = t;
	} else if (root->x < t->x)
		insert(root->r, t);
	else
		insert(root->l, t);
	update(root);
}

int main() {
	//freopen(taskname".in", "r", stdin);
	//freopen(taskname".out", "w", stdout);
	scanf("%d%d", &n, &k);
	for (int i = 0; i < n; ++i) {
		scanf("%d", &r[i]);
		p[i] = i;
	}
	for (int i = 0; i < n; ++i)
		scanf("%d", &a[i]);
	sort(p, p + n, cmp_r);
	node * root = 0, *left, *right;
	for (int i = 0; i < n; ++i) {
		insert(root, new node(a[p[i]], 0));
		split(root, a[p[i]] - k - 1, left, root);
		split(root, a[p[i]] + k, root, right);
		res[p[i]] = get_size(root);
		root = merge(merge(left, root), right);
	}
	scanf("%d", &m);
	for (int i = 0; i < m; ++i) {
		scanf("%d%d", &x[i], &y[i]);
		--x[i], --y[i];
		q[i] = i;
	}
	sort(q, q + m, cmp_max_r);
	int j = n - 1;
	root = 0;
	for (int i = m - 1; i >= 0; --i) {
		while ((j > 0) && (r[p[j]] >= max(r[x[q[i]]], r[y[q[i]]]))) {
			insert(root, new node(a[p[j]], res[p[j]]));
			--j;
		}
		split(root, max(a[x[q[i]]] - k, a[y[q[i]]] - k) - 1, left, root);
		split(root, min(a[x[q[i]]] + k, a[y[q[i]]] + k), root, right);
		ans[q[i]] = get_max(root);
		root = merge(merge(left, root), right);
	}
	for (int i = 0; i < m; ++i)
		printf("%d\n", ans[i]);
	return 0;
}