// In the name of Allah

#include <bits/stdc++.h>
using namespace std;

#define dbg(x) cerr << #x << " = " << (x) << endl;
#define FOR(i,a,b) for (int i = (a); i < (b); i ++)
#define rep(i,n) for (int i = 0; i < (n); i ++)
#define repd(i,n) for (int i = (n); i >= 0; i --)
#define PI 3.14159265358979323846
#define pb push_back
#define mp make_pair
#define X first
#define Y second

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;

const int max_n = 100*1000;
int rsp [max_n], age [max_n], tmp_r [max_n];
pii tmp [max_n];
vector <int> tree1 [4*max_n+13];
vector <pii> tree2 [4*max_n+13];
int best [4*max_n+13];
int pos [max_n];

void make1 (int root, int start, int endd)
{
	FOR (i, start, endd+1)
		tree1 [root].pb (rsp[i]);
	if ( start == endd )
		return;
	sort (tree1[root].begin(), tree1[root].end());
	int mid = start+endd>>1;
	make1 (root<<1, start, mid);
	make1 ((root<<1)|1, mid+1, endd);
}

int get1 (int root, int start, int endd, int l, int r, const int &Max)
{
	if ( l > r )
		return 0;
	if ( start == l && endd == r )
		return upper_bound (tree1[root].begin(), tree1[root].end(), Max) - tree1 [root].begin();
	int mid = start+endd>>1;
	return get1 (root<<1, start, mid, l, min(mid, r), Max) + get1 ((root<<1)|1, mid+1, endd, max(mid+1, l), r, Max);
}

void make2 (int root, int start, int endd)
{
	FOR (i, start, endd+1)
		tree2[root].pb (mp(rsp[i], best[i]));
	if ( start == endd )
		return;
	sort (tree2[root].begin(), tree2[root].end());
	for (int i = int(tree2[root].size())-2; i >= 0; i --)
		tree2[root][i].Y = max (tree2[root][i+1].Y, tree2[root][i].Y);
	int mid = start+endd>>1;
	make2 (root<<1, start, mid);
	make2 ((root<<1)|1, mid+1, endd);
}

int get2 (int root, int start, int endd, int l, int r, const int &Min)
{
	if ( l > r )
		return 0;
	if ( start == l && endd == r )
	{
		int i = lower_bound (tree2[root].begin(), tree2[root].end(), mp(Min, -1)) - tree2[root].begin();
		return i < tree2[root].size() ? tree2[root][i].Y : 0;
	}
	int mid = start+endd>>1;
	return max (get2(root<<1, start, mid, l, min(mid, r), Min), get2((root<<1)|1, mid+1, endd, max(mid+1, l), r, Min));
}

int main()
{
	int n, k;
	scanf ("%d%d", &n, &k);
	rep (i, n)
		scanf ("%d", &rsp[i]);
	rep (i, n)
		scanf ("%d", &age[i]);
		
	rep (i, n)
	{
		tmp [i].X = age[i];
		tmp [i].Y = i;
	}
	sort (tmp, tmp+n);
	rep (i, n)
		tmp_r[i] = rsp[i];
	rep (i, n)
	{
		age[i] = tmp [i].X;
		rsp[i] = tmp_r [tmp[i].Y];
		pos [tmp[i].Y] = i;
	}
	
	make1 (1, 0, n-1);
	rep (i, n)
	{
		int l = lower_bound (age, age+n, age[i]-k) - age;
		int r = upper_bound (age, age+n, age[i]+k) - age - 1; 	
		best[i] = get1 (1, 0, n-1, l, r, rsp[i]);
	}
	make2 (1, 0, n-1);
	
	int q;
	scanf ("%d", &q);
	while ( q -- )
	{
		int x, y;
		scanf ("%d%d", &x, &y);
		x --, y --;
		x = pos[x], y = pos[y];
		if ( x > y )
			swap (x, y);
			
		int l = lower_bound (age, age+n, age[y]-k) - age;
		int r = upper_bound (age, age+n, age[x]+k) - age - 1;
		int res = get2 (1, 0, n-1, l, r, max(rsp[x], rsp[y]));
		res -= (res == 0);
		printf ("%d\n", res);
	}
	
	return 0;
}
