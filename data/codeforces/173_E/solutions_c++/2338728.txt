#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<string>
#include<cstdlib>
#include<functional>
#include<iostream>
#define fo(i,a,b) for(i=a;i<=b;i++)
#define fd(i,a,b) for(i=a;i>=b;i--)
#define MP(a,b) make_pair(a,b)
#define clr(x,y) memset(x,y,sizeof x)
#define fi first
#define se second
#define sqr(z) ((z)*(z))
using namespace std;
typedef pair<int,int> PII;
const int oo=1047483647,maxn=110000,N=131072;
int n,i,j,k,m,ls[maxn],ge,f[maxn],x,y,ans[maxn];
struct node
{
	int r,a;
}a[maxn];
struct nod
{
	int x,y,w,v;
}q[maxn];
struct tree
{
	int tr[2*N+10],kind;
	void updata(int &a,int &v,int &kind)
	{
		if (kind==1) a+=v;
		else a=max(a,v);
	}
	void add(int x,int v)
	{
		if (x==ge+1)return;
		x+=N;
		updata(tr[x],v,kind);
		for (;x=x/2;) updata(tr[x],v,kind); //read!
	}
	int ask(int l,int r)
	{
		if (l>r) return 0;
		int tmp=0;
		for(l+=N,r+=N;l<=r;l=(l+1)/2,r=(r-1)/2)
		{
			if (l&1) updata(tmp,tr[l],kind);     //һ��&
			if (~r&1) updata(tmp,tr[r],kind);
		}
		return tmp;
	}
}T;
bool cmp(const node &a,const node &b) {return a.r<b.r;}
bool cmp2(const nod &a,const nod &b) {return a.v>b.v;}
int lb(int x) {return lower_bound(ls+1,ls+ge+1,x)-ls;}
int ub(int x) {return upper_bound(ls+1,ls+ge+1,x)-ls;}
int main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	scanf("%d%d",&n,&k);
	fo(i,1,n) scanf("%d",&a[i].r);  //д����%d��
	fo(i,1,n) scanf("%d",&a[i].a),ls[i]=a[i].a;
	scanf("%d",&m);
	sort(ls+1,ls+n+1);
	ge=unique(ls+1,ls+n+1)-(ls+1);
	fo(i,1,m)
	{
		scanf("%d%d",&x,&y);
		q[i].x=lb(max(a[x].a-k,a[y].a-k));
		q[i].y=ub(min(a[x].a+k,a[y].a+k))-1;
		q[i].v=max(a[x].r,a[y].r);
		q[i].w=i;
	}
	sort(a+1,a+n+1,cmp);
	j=1;
	clr(T.tr,0);T.kind=1;
	fo(i,1,n)
	{
		while (a[j].r<=a[i].r && j<=n) T.add(lb(a[j].a),1),j++;
		f[i]=T.ask(lb(a[i].a-k),ub(a[i].a+k)-1);
	}
	clr(T.tr,0);T.kind=2;
	sort(q+1,q+m+1,cmp2);
	j=n;
	fo(i,1,m)
	{
		if (q[i].x>q[i].y) ans[q[i].w]=-1;
		else
		{
			while (a[j].r>=q[i].v && j) T.add(lb(a[j].a),f[j]),j--;
			ans[q[i].w]=T.ask(q[i].x,q[i].y);  //�����������q[i].x=q[i].y���޽�
			if (!ans[q[i].w]) ans[q[i].w]=-1;
		}
	}
	fo(i,1,m) printf("%d\n",ans[i]);
	return 0;
}
