#include <cstdio>
#include <iostream>
#include <set>
#include <map>
#include <algorithm>
#include <cmath>
using namespace std;
const int N=100012;
int n,m,ans[N],num,l,r,pos[N],q,qq,sum[N],sun[N];
map<int ,int> M;
set<int> S;
typedef set<int>::iterator it;
struct point
{
	int x,y,num;
	inline bool operator < (const point &A)const {return x==A.x?y<A.y:x<A.x;}
}a[N];
struct point1
{
	int x,y,num;
	inline bool operator < (const point1 &A)const {return max(a[pos[x]].x,a[pos[y]].x)<max(a[pos[A.x]].x,a[pos[A.y]].x);}
}b[N];
struct Bit
{
	int c[N];
	inline void insert(int k)
	{
		for(;k<=num;k+=(k & -k)) ++c[k];
	}
	inline int calc(int k)
	{
		int ans=0;
		for(;k;k-=(k & -k)) ans+=c[k];
		return ans;
	}
}CR;
struct Xnode
{
    Xnode *lch,*rch;
    int l,r,Max;
    inline void update(){Max=max(lch->Max,rch->Max);}
    inline void change(int now,int x)
	{
		if (l==r) {Max=max(x,Max);return;}
		int mid=(l+r)>>1;
        if (now<=mid) lch->change(now,x);
        if (now>mid) rch->change(now,x);
        update();
	}
    inline int ask(int left,int right)
	{
		if (left<=l && right>=r) return Max;
        int mid=(l+r)>>1,ans=-1;
        if (left<=mid) ans=max(ans,lch->ask(left,right));
        if (right>mid) ans=max(ans,rch->ask(left,right));
        return ans;
	}
} X[N*2],*P=X,*root;
inline void build(Xnode *&node,int left,int right)
{
	node=P++;node->l=left;node->r=right;
    int mid=(left+right)>>1;
    if (left==right) {node->Max=-1;return;}
    build(node->lch,left,mid);
    build(node->rch,mid+1,right);
    node->update();
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
		scanf("%d",&a[i].x),a[i].num=i;
	for(int i=1;i<=n;++i)
		scanf("%d",&a[i].y),
		S.insert(a[i].y);
	it p=S.begin();
	for(int i=1;p!=S.end();++p,++i)
		M[*p]=i,num=i;
	sort(a+1,a+n+1);
	for(int i=1;i<=n;++i) pos[a[i].num]=i;
	for(int i=1;i<=n;)
	{
		int j;
		for(j=i+1;j<=n&&a[j].x==a[i].x;++j);
		for(int k=i;k<j;++k)
			CR.insert(M[a[k].y]);
		for(int k=i;k<j;++k)
		{
			p=S.lower_bound(a[k].y-m);l=M[*p];
			p=S.lower_bound(a[k].y+m);
			if (p==S.end() || (*p)>a[k].y+m) --p;r=M[*p];
			ans[k]=CR.calc(r)-CR.calc(l-1);	
		}
		i=j;
	}
	scanf("%d",&q);qq=q;
	for(int i=1;i<=q;++i)
		scanf("%d%d",&b[i].x,&b[i].y),b[i].num=i;
	sort(b+1,b+q+1);
//	for(int i=1;i<=q;++i)
	//	printf("%d %d\n",b[i].x,b[i].y);
	//printf("aa\n");
	build(root,1,num);
	for(int i=n;q;)
	{
		int j=i;
		int x=pos[b[q].x],y=pos[b[q].y];
		while (j && a[j].x>=max(a[x].x,a[y].x)) --j;
		for(int k=i;k>j;--k)
			root->change(M[a[k].y],ans[k]);
		int mmin=max(a[x].y,a[y].y)-m,mmax=min(a[x].y,a[y].y)+m;
		if (mmin>mmax) sum[q]=-1;
		else
		{
			p=S.lower_bound(mmin);l=M[*p];
			p=S.lower_bound(mmax);
			if (p==S.end() || (*p)>mmax) --p;
			r=M[*p];
			sum[q]=root->ask(l,r);	
		}
		//printf("%d %d %d %d %d %d %d\n",q,x,y,l,r,b[q].num,sum[q]);
		i=j;
		--q;
	}
	for(int i=1;i<=qq;++i)
		sun[b[i].num]=sum[i];
	for(int i=1;i<=qq;++i)
		printf("%d\n",sun[i]);
}