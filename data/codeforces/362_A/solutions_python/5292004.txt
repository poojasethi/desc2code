import collections


def bfs(d, p):
    q = collections.deque()
    x, y = p
    q.append((x, y, 0))
    wh = set()
    wh.add((x, y, 0))
    while q:
        x, y, k = q.popleft()
        if x+2 < 8 and y+2 < 8 and (x+2, y+2, k+1) not in wh and k+1 < 64:
            yield x+2, y+2, k+1
            q.append((x+2, y+2, k+1))
            wh.add((x+2, y+2, k+1))
        if x-2 >= 0 and y-2 >= 0 and (x-2, y-2, k+1) not in wh and k+1 < 64:
            yield x-2, y-2, k+1
            q.append((x-2, y-2, k+1))
            wh.add((x-2, y-2, k+1))
        if x+2 < 8 and y-2 >= 0 and (x+2, y-2, k+1) not in wh and k+1 < 64:
            yield x+2, y-2, k+1
            q.append((x+2, y-2, k+1))
            wh.add((x+2, y-2, k+1))
        if x-2 >= 0 and y+2 < 8 and (x-2, y+2, k+1) not in wh and k+1 < 64:
            yield x-2, y+2, k+1
            q.append((x-2, y+2, k+1))
            wh.add((x-2, y+2, k+1))


def solve(d):
    k1 = None
    k2 = None
    for i in range(8):
        for j in range(8):
            if d[i][j] == 'K':
                if k1 is None:
                    k1 = (i, j)
                else:
                    k2 = (i, j)
    k1c = set()
    k2c = set()
    k1c.add(k1)
    k2c.add(k2)
    for c in bfs(d, k1):
        if d[c[0]][c[1]] != '#':
            k1c.add(c)

    for c in bfs(d, k2):
        if d[c[0]][c[1]] != '#':
            k2c.add(c)
    if k2c & k1c:
        return 'YES'
    else:
        return 'NO'

t = int(raw_input())


for i in xrange(t):
    d = []
    for j in xrange(8):
        d.append(raw_input().strip())
    if i != t-1:
        raw_input()
    print solve(d)
