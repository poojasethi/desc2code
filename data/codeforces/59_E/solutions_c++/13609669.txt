#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <vector>
#include <map>
#include <set>
#include <queue>
#define inf 2123456789
#define MAX_N 3000 
using namespace std;

int n, m, k;
vector<int> graph[MAX_N+1];
map<pair<int, int>, set<int> > mp;
int d[MAX_N+1][MAX_N+1];
int pi[MAX_N+1][MAX_N+1];

void printpath(int a, int b)
{
	if(a!=-1)
	{
		printpath(pi[a][b], a);
		printf(" %d", b);
	}else
		printf("1");
}

int main() 
{
	int i, j;
	int l, r, a, b, c;
	pair<int, int> p;
	scanf("%d%d%d", &n, &m, &k);
	fill(d[1], d[n+1], inf); 
	
	for(i=0; i<m; i++)
	{
		scanf("%d%d", &l, &r);
		graph[l].push_back(r);
		graph[r].push_back(l);
	}
	
	for(i=0; i<k; i++)
	{
		scanf("%d%d%d", &a, &b, &c);
		p.first=a;
		p.second=b;
		mp[p].insert(c);
	}
	
	queue<pair<int, int> > q;
	for(vector<int>::iterator it=graph[1].begin(); it!=graph[1].end(); it++)
	{
		d[1][*it]=1;
		pi[1][*it]=-1;
		p.first=1;
		p.second=*it;
		q.push(p);
	}
	
	graph[1].clear();
	while(!q.empty())
	{
		p=q.front();
		q.pop();
		set<int> &s = mp[p];
		a=p.first;
		b=p.second;
		for(vector<int>::iterator it=graph[b].begin(); it!=graph[b].end();)
		{
			if(s.count(*it)>0)
			{
				it++;
			}else
			{
				d[b][*it]=d[a][b]+1;
				pi[b][*it]=a;
				p.first=b;
				p.second=*it;
				q.push(p);
				it=graph[b].erase(it);
			}
		}
	}
	
	int mind=inf;
	int minindex=0;
	for(i=1; i<=n; i++)
	{
		if(d[i][n]<mind)
		{
			mind=d[i][n];
			minindex=i;
		}
	}
	if(!minindex)
	{
		printf("-1");
	}else
	{
		printf("%d\n", mind);
		printpath(minindex, n);
	}
	
	return 0;
}
	  	   	 		  		 	 		 	 			   	