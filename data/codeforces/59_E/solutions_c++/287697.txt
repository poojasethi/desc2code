//Solution by Ali-Amir Aldan
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <cmath>
#include <map>
#include <set>

using namespace std;

#define INF 1000000000
#define N 3003
#define M 99999

typedef pair <int, pair <int, int> > pii;
int n, m, k, u, v, t, ba, bb, bc, res, pred;
int h[N], ne[M], to[M], from[N*N], q[N*N];
int head[N][N], dp[N][N];
pii pi;
set <pii> ban;

void newedge (int u, int v)
{
 	to[t] = v;
 	ne[t] = h[u];
 	h[u] = t++;
}

void refresh (pii &p, int &a, int &b, int &c)
{
	p.first = a;
	p.second.first = b;
	p.second.second = c;
}

void out (int u, int v)
{
 	if (!v) return;
 	out (head[u][v], u);
 	printf ("%d ", v);
}

int main ()
{
	scanf ("%d%d%d", &n, &m, &k);

	memset (h, -1, sizeof (h));
	for (; m--;)
	{
		scanf ("%d%d", &u, &v);
		newedge (u, v);
		newedge (v, u);
	}

	for (; k--;)
	{
		scanf ("%d%d%d", &ba, &bb, &bc);
		refresh (pi, ba, bb, bc);
		ban.insert (pi);
	}

	q[0] = 1; from[0] = 0; res = INF;
	memset (dp, -1, sizeof (dp));
	dp[0][1] = 0;

	for (int l = 0, r = 1; l < r; l++)
	{
	 	if (q[l] == n && res > dp[from[l]][n])
	 		res = dp[from[l]][n],
	 		pred = from[l];

	 	for (int j = h[q[l]]; j != -1; j = ne[j])
	 	{
	 	 	refresh (pi, from[l], q[l], to[j]);

	 	 	if (ban.count (pi) || dp[q[l]][to[j]] >= 0) continue;

	 	 	dp[q[l]][to[j]] = dp[from[l]][q[l]] + 1;
	 	 	head[q[l]][to[j]] = from[l];
	 	 	q[r] = to[j]; from[r++] = q[l];
	 	}
	}

	if (res == INF)
		puts ("-1");
	else
		printf ("%d\n", res),
		out (pred, n),
		puts ("");

	return 0;
}
