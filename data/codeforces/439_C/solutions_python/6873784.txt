from __future__ import division;
from bisect import *;
import sys;
from math import *;
from fractions import *;
from itertools import *;
import io;
import re;

INF = 987654321987654321987654321;

def readint(delimiter=' ') :
    return map(int, raw_input().split(delimiter));

def readstr(delimiter=' ') :
    return raw_input().split(delimiter);

def readfloat(delimiter=' ') :
    return map(float, raw_input().split(delimiter));

def index(a, x):
    'Locate the leftmost value exactly equal to x'
    i = bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i
    raise ValueError

def find_lt(a, x):
    'Find rightmost value less than x'
    i = bisect_left(a, x)
    if i:
        return a[i-1]
    raise ValueError

def find_le(a, x):
    'Find rightmost value less than or equal to x'
    i = bisect_right(a, x)
    if i:
        return a[i-1]
    raise ValueError

def find_gt(a, x):
    'Find leftmost value greater than x'
    i = bisect_right(a, x)
    if i != len(a):
        return a[i]
    raise ValueError

def find_ge(a, x):
    'Find leftmost item greater than or equal to x'
    i = bisect_left(a, x)
    if i != len(a):
        return a[i]
    raise ValueError

def bin_search(a, x, left, right) :

    while left<=right :
        mid = (left + right)//2;

        if a[mid] == x :
            return mid;
        elif a[mid] < x :
            left = mid + 1;
        elif a[mid] > x :
            right = mid - 1;

        pass

    return -1;
    pass

def printf(format, *args):
    """Format args with the first argument as format string, and write.
    Return the last arg, or format itself if there are no args."""
    sys.stdout.write(str(format) % args)
    pass

if __name__ == '__main__':

    n, k, p = readint();
    a = readint();
    a_odd = [];
    a_even = [];
    for a_item in a :
        if a_item % 2 == 0 :
            a_even.append(a_item);
        else :
            a_odd.append(a_item);
            pass
        pass
    need_even = p;
    need_odd = k-p;

    if need_odd > len(a_odd) :
        print "NO";
    elif len(a_odd) % 2 != need_odd % 2 :
        print "NO";
    elif need_even > ((len(a_odd) - need_odd) / 2 + len(a_even)) :
        print "NO"
    else :
        print "YES";

        part = [[] for _ in xrange(k)];
        idx = 0;
        while (need_even > 0) :
            if  len(a_even) > 0 :
                part[idx].append(a_even.pop());
            else :
                part[idx].append(a_odd.pop());
                part[idx].append(a_odd.pop());
                pass
                
            idx+=1;
            need_even -= 1;
            pass

        while (need_odd > 0) :
            part[idx].append(a_odd.pop());
            idx+=1;
            need_odd -= 1;
            pass

        while (len(a_even) > 0) :
            part[idx-1].append(a_even.pop());

        while (len(a_odd) > 0) :
            part[idx-1].append(a_odd.pop());

        for ii in xrange(k) :
            print len(part[ii]), ' '.join(map(str, part[ii]));

        pass

    pass
