#include <cstdio>
#include <cstring>
#include <map>
#include <vector>
#include <algorithm>

struct Shoe
{
  int cost, size, index;
} s[100000];
inline bool operator<(const Shoe& lhs, const Shoe& rhs)
{ return lhs.cost > rhs.cost; }
int n, m, cnt, choose[100000], chosen[100000];
long long ans;
std::vector<int> g[100000];
bool dfs(const int x)
{
  for (std::vector<int>::iterator beg = g[x].begin(), end = g[x].end();
      beg != end; ++beg)
  {
    if (choose[*beg] == x)
      continue;
    if (choose[*beg] == -1 || dfs(choose[*beg]))
    {
      choose[*beg] = x;
      chosen[x] = *beg;
      return true;
    }
  }
  return false;
}
int main()
{
  memset(choose, 255, sizeof(choose));
  memset(chosen, 255, sizeof(chosen));
  scanf("%d", &n);
  std::map<int, int> sz;
  for (int i = 0; i < n; ++i)
  {
    scanf("%d%d", &s[i].cost, &s[i].size);
    s[i].index = i;
  }
  std::sort(s, s+n);
  for (int i = 0; i < n; ++i)
    sz[s[i].size] = i;
  
  scanf("%d", &m);
  for (int i = 0, money, size; i < m; ++i)
  {
    scanf("%d%d", &money, &size);
    std::map<int, int>::iterator iter;
#define PROCESS(size) \
    if ((iter = sz.find(size)) != sz.end() && s[iter->second].cost <= money)\
      g[iter->second].push_back(i);
    PROCESS(size+1)
    PROCESS(size)
  }

  for (int i = 0; i < n; ++i)
    if (dfs(i))
    {
      ans += s[i].cost;
      ++cnt;
    }
  printf("%I64d\n%d\n", ans, cnt);
  for (int i = 0; i < n; ++i)
    if (chosen[i] != -1 && choose[chosen[i]] == i)
      printf("%d %d\n", chosen[i]+1, s[i].index+1);
}
