# include<iostream>
# include<cstdio>
# include<vector>
# include<algorithm>
# include<cstring>
using namespace std;
const int N = 100000+10;
vector<int>g[N];
int match[N],n,m,num=0;
bool vis[N];
struct node
{
    int w,s,id;
}p[N];

bool comp(node a,node b)
{
     return a.s<b.s;
   // else return a.w<b.w;
}

bool comp1(node a,node b)
{
    return a.w>b.w;
}

inline bool dfs(int u)
{
    int len = g[u].size();
    for(int i=0;i<len;++i)
    {
        int v = g[u][i];
        if(!vis[v])
        {
            vis[v] = true;
            if(!match[v] || dfs(match[v]))
            {
                match[v] = u;
                return true;
            }
        }
    }
    return false;
}

int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;++i)
    {
        scanf("%d %d",&p[i].w,&p[i].s);
        p[i].id = i+1;
    }
    sort(p,p+n,comp);
    scanf("%d",&m);
    for(int i=0;i<m;++i)
    {
        node q;
        scanf("%d %d",&q.w,&q.s);
        //q.s-- ;
        int j = lower_bound(p,p+n,q,comp)-p; //q.s++;
        for(;j<n && (q.s == p[j].s || q.s == p[j].s -1 );j++)
        {
            if(q.w>=p[j].w)
                g[p[j].id].push_back(i+1);
        }
    }
    sort(p,p+n,comp1);
    memset(match,0,sizeof(match));
    __int64 ans = 0;
    for(int i=0;i<n;++i)
    {
        memset(vis,false,sizeof(vis));
        if(dfs(p[i].id))
        {
            ans+=p[i].w;
            num++;
        }
    }
    printf("%I64d\n%d\n",ans,num);
    for(int i=1;i<=m;++i)
        if(match[i]) printf("%d %d\n",i,match[i]);
    return 0;
}
