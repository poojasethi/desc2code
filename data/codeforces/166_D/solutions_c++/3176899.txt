# include<iostream>
# include<cstdio>
# include<vector>
# include<algorithm>
# include<cstring>
using namespace std;
const int N = 100000+10;
vector<int>g[N];
__int64 ans = 0;
int match[N],n,m,num=0;
bool vis[N];
struct node
{
    int w,s,id;
    bool operator<(const node &rh)const
    {
        if(s!=rh.s) return s<rh.s;
        else return w<rh.w;
    }
}p[N];

bool comp(node a,node b)
{
     return a.s<b.s;
   // else return a.w<b.w;
}

bool comp1(node a,node b)
{
    return a.w>b.w;
}

bool dfs(int u)
{
    int len = g[u].size();
    for(int i=0;i<len;++i)
    {
        int v = g[u][i];
        if(!vis[v])
        {
            vis[v] = true;
            if(dfs(match[v]) || !match[v])
            {
                match[v] = u;
                return true;
            }
        }
    }
    return false;
}

void max_match()
{
    sort(p,p+n,comp1);
    memset(match,0,sizeof(match));
    for(int i=1;i<=n;++i)
    {
        memset(vis,false,sizeof(vis));
        if(dfs(p[i-1].id))
        {
            ans+=(__int64)p[i-1].w;
            num++;
        }
    }
}

int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;++i)
    {
        scanf("%d %d",&p[i].w,&p[i].s);
        p[i].id = i+1;
    }
    sort(p,p+n);
    scanf("%d",&m);
    for(int i=0;i<m;++i)
    {
        node q;
        scanf("%d %d",&q.w,&q.s);
        //q.s-- ;
        int j = lower_bound(p,p+n,q,comp)-p; //q.s++;
        while(j<n && (q.s == p[j].s || q.s == p[j].s -1 ))
        {
            if(q.w>=p[j].w)
                g[p[j].id].push_back(i+1);
            j++;
        }
    }
    max_match();
    cout<<ans<<endl;
    cout<<num<<endl;
    for(int i=1;i<=m;++i)
        if(match[i]) printf("%d %d\n",i,match[i]);
    return 0;
}
