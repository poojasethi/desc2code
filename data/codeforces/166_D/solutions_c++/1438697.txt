//CF113D; Shoe Store; Bipartite Graph - Hungary
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <vector>
#define N 100000
using namespace std;

typedef long long ll;
struct obj
{
	int s, c, n;
	obj()
	{ s = c = 0; }
	obj(int price, int size, int num = 0)
	{ c = price, s = size, n = num; }
}a[N + 1], c;
vector <int> q[N + 1];
int n, m, i, j, p[N + 1], k = 0, x, y;
ll ans = 0;
bool v[N + 1];

inline bool cmp(obj a, obj b)
{ return a.s < b.s; }
inline bool cmp2(obj a, obj b)
{ return a.c > b.c; }

bool find(int s)
{
	int i, x;
	for (i = 0; i < q[s].size(); ++i)
		if (!v[x = q[s][i]])
		{
			v[x] = true;
			if (!p[x] || find(p[x]))
			{
				p[x] = s;
				return true;
			}
		}
	return false;
}

int main()
{
	scanf("%d", &n);
	for (i = 1; i <= n; ++i) scanf("%d%d", &x, &y), a[i] = obj(x, y, i);
	sort(a + 1, a + n + 1, cmp);
	scanf("%d", &m);
	for (i = 1; i <= m; ++i)
	{
		scanf("%d%d", &x, &y);
		c = obj(x, y);
		for (j = lower_bound(a + 1, a + n + 1, c, cmp) - a; c.s + 1 == a[j].s || c.s == a[j].s; ++j)
			if (c.c >= a[j].c) q[a[j].n].push_back(i);
	}
	sort(a + 1, a + n + 1, cmp2);
	for (i = 1; i <= n; ++i)
	{
		memset(v, 0, sizeof v);
		if (find(a[i].n)) ++k, ans += (ll)a[i].c;
	}
	printf("%I64d\n%d\n", ans, k);
	for (i = 1; i <= m; ++i)
		if (p[i]) printf("%d %d\n", i, p[i]);
	return 0;
}
