#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
using namespace std;

const int maxn = 100005;
const int INF = 1<<27;

struct node
{
    int price, size, id;
} p [maxn];

int n, m;
int d[maxn], l[maxn];
vector<int> adj[maxn];
int mt[maxn], v[maxn];

bool cmp(node a, node b)
{
	return a.price > b.price;
}

bool dfs(int u, int ind)
{
	if (v[u] == ind)
		return false;
	v[u] = ind;
	for (int i = 0; i < adj[u].size(); i++)
	{
		if (mt[adj[u][i]] == -1 || dfs(mt[adj[u][i]], ind))
		{
			mt[adj[u][i]] = u;
			return true;
		}
	}
	return false;
}
int main() {
	scanf ("%d", &n);
	for (int i = 0; i < n; i++)
	{
		scanf ("%d %d", &p[i].price, &p[i].size);
		p[i].id = i;
	}
	scanf ("%d", &m);
	for (int i = 0; i < m; i++)
		scanf ("%d %d", &d[i], &l[i]);
	sort(p, p + n, cmp);
	map<int, int> f;
	for (int i = 0; i < n; i++)
		f[p[i].size] = i;
	for (int i = 0; i < m; i++)
	{
		if (f.find(l[i]) != f.end() && d[i] >= p[f[l[i]]].price)
		{
				adj[f[l[i]]].push_back(i);
		}
		if (f.find(l[i] + 1) != f.end() && d[i] >= p[f[l[i] + 1]].price)
		{
				adj[f[l[i] + 1]].push_back(i);
		}
	}
	memset(mt, -1, sizeof(mt));
	memset(v, -1, sizeof(v));
	int num = 0;
    long long ans = 0;
	for (int i = 0; i < n; i++)
		if (dfs(i, i))
        {
            ans += p[i].price;
            num++;
        }
    cout << ans << endl;
    cout << num << endl;
	for (int i = 0; i < m; i++)
	{
		if (mt[i] > -1)
            cout << i + 1 << " " << p[mt[i]].id + 1 << endl;
	}
}
