#include<bits/stdc++.h>
#define M 300005
#define C 18
using namespace std;
int rank[M + 5] , gap , lcp[M + 5] , rem[M + 5] , n , pos[M + 5] , rmq[M + 5][C + 1] , lg[M + 5];
int c1[M + 5] , c2[M + 5] , c3[M + 5];
int all[M + 5] , mod = 1e9 + 7;
string s1 , s2 , s3 , s;
bool cmp(int x,int y){
	if(rank[x] == rank[y]){
		x += (1<<gap) ; y += (1<<gap);
		if(x <= n && y <= n)	return (rank[x] < rank[y]);
		return (x > y);
	}
	return (rank[x] < rank[y]);
} 
void buildSA(){
	for(int i = 1 ; i <= n ; i++)	rank[i] = (int) s[i - 1];
	for(int i = 1 ; i <= n ; i++)	pos[i] = i;
	for( ;; gap++){
		sort(pos + 1 , pos + 1 + n , cmp);
		int m = 0;
		for(int i = 1 ; i <= n ; i++){
			if(i == 1 || cmp(pos[i - 1] , pos[i])) m++;
			rem[pos[i]] = m;
		}
		for(int i = 1 ; i <= n ; i++)	rank[i] = rem[i];
		if(m == n)	break;
	}
	sort(pos + 1 , pos + 1 + n , cmp);
}
void build_lcp(){
	int l = 0;
	for(int i = 1 ; i <= n ; i++){
		if(rank[i] == n)	continue;
		int j = pos[rank[i] + 1];
		while(i + l - 1 <= n && j + l - 1 <= n && s[i + l - 1] == s[j + l - 1]) l++;
		lcp[rank[i]] = l;
		if(l > 0)	l--;
	}
}
void prepare(){
	for(int i = 1 ; i <= n ; i++){
		if(pos[i] > s1.size() + s2.size() + 2)	c3[i]++;
		else if(pos[i] > s1.size() + 1)	c2[i]++;
		else c1[i]++;
		c3[i] += c3[i - 1]; c2[i] += c2[i - 1] ; c1[i] += c1[i - 1];
	}
	for(int i = 1 ; i <= n ; i++){
		while((1<<lg[i]) <= i)	lg[i]++;
		lg[i]--;
	}
	for(int i = 1 ; i < n ; i++)	rmq[i][0] = i;
	for(int x = 1 ; (1<<x) < n ; x++)
		for(int i = 1 ; i + (1<<x) - 1 < n ; i++)
			if(lcp[rmq[i][x - 1]] <= lcp[rmq[i + (1<<(x - 1))][x - 1]])	rmq[i][x] = rmq[i][x - 1];
			else rmq[i][x] = rmq[i + (1<<(x - 1))][x - 1];
}
int cal(int x,int y){
	int k = lg[y - x + 1];
	if(lcp[rmq[x][k]] <= lcp[rmq[y - (1<<k) + 1][k]])	return rmq[x][k];
	return rmq[y - (1<<k) + 1][k];
}
void solve(int l,int r,int t){
	if(l == r || l > r || l < 1 || r > n) return;
	int mid = (cal(l , r - 1));
	if(lcp[mid] >= t){
		int ret =  1ll*(c1[r] - c1[l - 1])*(c2[r] - c2[l - 1])*(c3[r] - c3[l - 1])%mod;
		all[lcp[mid] + 1] = (all[lcp[mid] + 1] - ret + mod)%mod;
		all[t + 1] = (all[t + 1] + ret)%mod;
	} 
	solve(l , mid , lcp[mid]); solve(mid + 1 , r , lcp[mid]);
}
main(){
//	freopen("test.inp","r",stdin);
	cin>>s1>>s2>>s3;
	s = s1 + "@" + s2 + "$" + s3;
	n = s.size();
	buildSA();
	build_lcp();
	prepare();
	solve(1 , n , 0);
	for(int i = 1 ; i <= min (min(s1.size() , s2.size()) , s3.size()) ; i++){
		all[i] = (all[i] + all[i - 1])%mod;
		printf("%d ",all[i]);
	}
}