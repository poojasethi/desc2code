#include <algorithm>
#include <iostream>
#include <cassert>
#include <climits>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <string>
#include <vector>
#include <cmath>
#include <ctime>
#include <queue>
#include <stack>
#include <map>

using namespace std;


#define rofeach(i,x) for(type(x)i=x.rbegin();i!=x.rend();i++)
#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)
#define type(x) __typeof(x.begin())
#define pii pair< int,int >
#define mod 1000000007
#define inf 1000000000
#define ll long long
#define pb push_back
#define mp make_pair
#define nd second
#define st first
#define endl '\n'

const int N = 1e6+5;
const int logN = 20;
const int MAX = 1e9+5;

int lcp[N],suff[N],val[N][4],i,j,k,n,m,root[N],sorted[N],belong[N];

vector< pair< int , pii > > g;

pair< pii , int > C[N];

stack< int > S;

ll ans;

string str1,str2,str3,str;

int findset(int x){ return root[x] = root[x] == x ? x : findset(root[x]); }

int main(){
	
	cin >> str1 >> str2 >> str3;

	int s1 = str1.size();
	int s2 = str2.size();
	int s3 = str3.size();

	str = ' ' + str1 + '#' + str2 + '#' + str3;

	n = str.size()-1;

	int wh = 1;

	FOR(i,1,n) if(str[i] == '&' || str[i] == '#') wh++; else belong[i] = wh;

	FOR(i,1,n) suff[i] = str[i];

	FOR(j,1,logN){
		
		FOR(i,1,n) C[i] = mp(mp(suff[i],suff[min(i+(1<<j-1),n+1)]),i);
	
		sort(C+1,C+n+1);

		FOR(i,1,n) suff[C[i].nd] = suff[C[i-1].nd] + (C[i].st != C[i-1].st);

	}

	FOR(i,1,n) sorted[suff[i]] = i;

	int j = 0;

	FOR(i,1,n){
		
		if(suff[i] == 1) continue;

		while(i + j <= n && sorted[suff[i]-1]+j <= n && str[sorted[suff[i]-1]+j] == str[i+j]) j++;

		lcp[suff[i]] = j;

		if(j) j--;
		
	}

	FOR(i,1,n){
		
		root[i] = i;
		
		val[i][belong[i]] = 1;

		if(i > 1) g.pb(mp(lcp[i],mp(sorted[i-1],sorted[i])));
		
	}

	g.pb(mp(inf,mp(-1,-1)));

	sort(g.rbegin(),g.rend());

	int last = 1;

	int m = min(s1,min(s2,s3));

	ROF(i,m,1){

		while(last < n && g[last].st >= i){
			
			int x = findset(g[last].nd.st);
			int y = findset(g[last].nd.nd);

			last++;

			if(x == y) continue;

			root[y] = x;

			ans -= (ll)val[x][1] * val[x][2] * val[x][3] + (ll)val[y][1] * val[y][2] * val[y][3];
	
			val[x][1] += val[y][1];	
			val[x][2] += val[y][2];	
			val[x][3] += val[y][3];	
			
			ans += (ll)val[x][1] * val[x][2] * val[x][3];

		}

		S.push(ans%mod);

	}

	while(!S.empty()){ cout << S.top() << ' '; S.pop(); }

    return 0;
}
