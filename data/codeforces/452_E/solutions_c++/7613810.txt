#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#include<string>
#include<iostream>
#include<vector>
#define mod 1000000007
#define MAXN 300005
using namespace std ;
typedef long long LL ;

int len, ml ;
LL pre[MAXN], ans ;
string ss, ts ;

int idx(char c)
{
	if(c >= 'a' && c <= 'z') return c-'a' ;
	if(c == '$') return 26 ;
	return 27 ;
}
struct node {
	node *son[28], *fa ;
	LL mx, mn, vis ;
	LL c[3] ;
	vector<node*> down ;
	node(int mx=0):mx(mx) {memset(son, 0, sizeof(son)), fa = 0, mn = vis = c[0] = c[1] = c[2] = 0 ;}
} ;
struct Sam {
	node *p, *q, *np, *nq ;
	node *root, *end ;
	void Clear() {root = end = new node(0), root->mn = 0 ;}
	void Insert(char c, int at)
	{
		int tmp = idx(c) ;
		p = end, end->son[tmp] = new node(end->mx+1) ;
		end = end->son[tmp], end->c[at] = 1 ;
		for(p=p->fa; p && !p->son[tmp]; p=p->fa) 
			p->son[tmp] = end ;
		if(!p) {end->fa = root; return ;}
		q = p->son[tmp] ;
		if(q->mx == p->mx+1)
			{end->fa = q; return ;}
		nq = new node(p->mx+1) ;
		nq->fa = q->fa, q->fa = end->fa = nq ;
		memcpy(nq->son, q->son, sizeof(q->son)) ;
		for(p; p && p->son[tmp] == q; p = p->fa)
			p->son[tmp] = nq ;
	}
} S ;
void Pre_dfs(node* x)
{
	if(x->vis) return ;
	x->vis = 1 ;
	node* tmp = x->fa ;
	tmp->down.push_back(x) ;
	x->mn = tmp->mx+1 ;
	for(int i = 0; i < 28; i ++)
		if(x->son[i])
			Pre_dfs(x->son[i]) ;
}
void Dfs(node* x)
{
	int i ;
	LL get, sum ;
	node* tmp ;
	for(i = 0; i < x->down.size(); i ++)
	{
		tmp = x->down[i] ;
		Dfs(tmp) ;
		x->c[0] += tmp->c[0] ;
		x->c[1] += tmp->c[1] ;
		x->c[2] += tmp->c[2] ;
	}
	sum = x->c[0]*x->c[1]%mod*x->c[2]%mod ;
	pre[x->mn] = (pre[x->mn]+sum)%mod ;
	pre[x->mx+1] = (pre[x->mx+1]-sum+mod)%mod ;
}

int main()
{
	int i, j ;
	//freopen("1.in", "r", stdin) ;
	//freopen("1.out", "w", stdout) ;
	S.Clear() ;
	cin >> ss ;
	len = ss.length(), ml = len ;
	for(i = 0; i < len; i ++)
		S.Insert(ss[i], 0) ;
	S.Insert('$', 0) ;
	cin >> ss ;
	len = ss.length(), ml = min(ml, len) ;
	for(i = 0; i < len; i ++)
		S.Insert(ss[i], 1) ;
	S.Insert('%', 1) ;
	cin >> ss ;
	len = ss.length(), ml = min(ml, len) ;
	for(i = 0; i < len; i ++)
		S.Insert(ss[i], 2) ;
	for(i = 0; i < 28; i ++)
		if(S.root->son[i])
			Pre_dfs(S.root->son[i]) ;
	Dfs(S.root) ;
	for(i = 1; i <= ml; i ++)
	{
		pre[i] = (pre[i]+pre[i-1])%mod ;
		printf("%d ", pre[i]) ;
	}
	//system("pause") ;
	return 0 ;
}
