#include <cmath>
#include <map>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <set>
#include <bitset>
#include <memory.h>
#include <functional>
#include <queue>
#include <fstream>
#include <ctime>
#include <deque>
#include <utility>
#include <stack>
#include <sstream>
#include <list>
#include <cctype> 
#include <numeric> 
#include <iomanip>
#include <assert.h>
using namespace std;
#define sqr(_) ((_)*(_))

typedef pair<int, int> Pii;
#define x first
#define y second
#define mp make_pair
#define pb push_back

typedef long long LL;

const int MAXN = 100000 * 3 * 2 + 10, L = 27, MOD = (int)1e9 + 7;

struct State
{
	int len, num[3], fa, tr[L];
	State(): len(0), fa(0) {
		memset(num, 0, sizeof(num));
		memset(tr, 0, sizeof(tr));
	}
	State(int len, int fa): len(len), fa(fa) {
		memset(num, 0, sizeof(num));
		memset(tr, 0, sizeof(tr));
	}
}SAM[MAXN];

int n, m = MAXN, Tohka[MAXN], tot;
char str[MAXN], a[MAXN];
vector<int> l[MAXN];

int Build(int pre, int id, int bel)
{
	int cp = ++tot;
	SAM[cp] = State(SAM[pre].len + 1, 1);
	if (bel >= 0)
		++SAM[cp].num[bel];
	for (; pre && !SAM[pre].tr[id]; SAM[pre].tr[id] = cp, pre = SAM[pre].fa);
	if (pre)
		if (SAM[pre].len + 1 == SAM[SAM[pre].tr[id]].len)
			SAM[cp].fa = SAM[pre].tr[id];
		else
		{
			int tp = SAM[pre].tr[id];
			SAM[++tot] = State(SAM[pre].len + 1, SAM[tp].fa);
			memcpy(SAM[tot].tr, SAM[tp].tr, sizeof(SAM[tp].tr));
			SAM[cp].fa = SAM[tp].fa = tot;
			for (; pre && SAM[pre].tr[id] == tp; SAM[pre].tr[id] = tot, pre = SAM[pre].fa);
		}
	return cp;
}
int lowbit(int x) {
	return x & -x;
}
void Add(int *f, int x, int d)
{
	for (; x <= m; f[x] = (f[x] + d) % MOD, x += lowbit(x));
}
int Gets(int *f, int x)
{
	int Tohka = 0;
	for (; x; Tohka = (Tohka + f[x]) % MOD, x -= lowbit(x));
	return Tohka;
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout);
#endif
	
	int p = 1;
	tot = 1;
	for (int i = 0; i < 3; ++i)
	{
		scanf("%s", str + 1);
		n = strlen(str + 1);
		m = min(m, n);
		for (int j = 1; j <= n; ++j)
			p = Build(p, str[j] - 'a', i);
		p = Build(p, 26, -1);
	}
	for (int i = 1; i <= tot; ++i)
		l[SAM[i].len].pb(i);
	for (int i = MAXN - 1; i >= 0; --i)
		for (int j = 0; j < (int)l[i].size(); ++j)
			for (int k = 0; k < 3; ++k)
				SAM[SAM[l[i][j]].fa].num[k] += SAM[l[i][j]].num[k];
	for (int i = 1; i <= tot; ++i)
	{
		int d = (LL)SAM[i].num[0] * SAM[i].num[1] * SAM[i].num[2] % MOD;
		if (d)
			Add(Tohka, SAM[SAM[i].fa].len + 1, d),
			Add(Tohka, SAM[i].len + 1, MOD - d);
	}
	for (int i = 1; i <= m; ++i)
		printf("%d ", Gets(Tohka, i));
	puts("");
	
	fclose(stdin);
	fclose(stdout);
	return 0;
}
