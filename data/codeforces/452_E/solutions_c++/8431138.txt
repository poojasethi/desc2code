#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cstdlib>
#include <cmath>
#define For(i,a,n) for(int i=(a);i<=(n);i++)
#define limit 600005
#define mo 1000000007
using namespace std;

int Ch='z'-'a'+1,ts,prets,L=210000000;
int ord[limit],t[limit];
int s[limit];
long long Tre[limit];

void Add(int x,long long y){
	if(x>L)return;
	if(!x)return;
	Tre[x]+=y;
	Tre[x]%=mo;	
}

struct SAM
{
	int dex,last,root;
	int tree[limit][30],pre[limit],col[limit];
	int sz[5][limit],step[limit],ok[limit];
	void init()
	{
		memset(tree,0,sizeof(tree));
		memset(pre,0,sizeof(pre));
		memset(sz,0,sizeof(sz));
		memset(step,0,sizeof(step));
		memset(ok,0,sizeof(ok));
		memset(col,0,sizeof(col));
		dex=last=root=1;
	}
	void expend(int x,int color)
	{
		int p,q=last,skydec=(++dex);
		step[skydec]=step[q]+1;
		col[skydec]=color;
		for(p=q;p&&!tree[p][x];p=pre[p])
			tree[p][x]=skydec;
		if(!p)pre[skydec]=1;
		else
		{
			int gt=tree[p][x];
			if(step[p]+1==step[gt])pre[skydec]=gt;
			else
			{
				int nq=(++dex);
				col[nq]=col[gt];
				pre[nq]=pre[gt];
				pre[gt]=pre[skydec]=nq;
				step[nq]=step[p]+1;
				memcpy(tree[nq],tree[gt],sizeof(tree[gt]));
				for(int z=p;z&&tree[z][x]==gt;z=pre[z])
					tree[z][x]=nq;
			}
		}last=skydec;
	}
	void findtop()
	{
		for(int i=1;i<=dex;i++)t[step[i]]++;
		for(int i=1;i<=dex;i++)t[i]+=t[i-1];
		for(int i=1;i<=dex;i++)
			ord[t[step[i]]--]=i;
	}
	void getrightsize()
	{
		int lv=1;
		for(int i=1,p=1;i<=ts;i++)
		{
			p=tree[p][s[i]];
			if(s[i]==26) lv++;
			sz[lv][p]++;
		}
		for(int i=dex;i;i--){
			int mm=ord[i];
			if(!pre[mm])continue;
			For(j,1,3) sz[j][pre[mm]]+=sz[j][mm];
		}
	}
	long long count(int x){
		long long rs=1;
		For(j,1,3) rs=(1ll*rs*sz[j][x])%mo;
		return rs;
	}
	void work(){
		For(i,1,dex)
		if(col[i]==1){
			long long t=count(i);
			Add(step[pre[i]]+1,t);
			Add(step[i]+1,-t);
		}
	}
}sam;

int main(){
	sam.init();
	char ch=getchar();
	int lv=1;
	while(ch!=-1){
		if(ch>='a'&&ch<='z')sam.expend(ch-'a',lv),s[++ts]=ch-'a';
		else{
			if(lv<=2)sam.expend(26,0);
			L=min(L,ts-prets);s[++ts]=26;
			prets=ts;
			++lv;
			if(lv>3)break;
		}
		ch=getchar();
	}--ts;
	sam.findtop();
	sam.getrightsize();
	sam.work();
	For(i,1,L) Tre[i]=(Tre[i]+Tre[i-1])%mo;
	For(i,1,L) if(Tre[i]<0) Tre[i]+=mo;
	For(i,1,L)printf("%I64d ",Tre[i]);
}
