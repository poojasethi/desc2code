#include <stdio.h>
#include <algorithm>

using namespace std;

const int maxn = 100010;

struct Tpoint{ 
	long long x, y;
}a[maxn+1], b[maxn+1];

int m, n, xltop;
int xl[maxn+1];
bool minwin;

void init() {
	int i, j;
	scanf("%d%d",&m,&n);
	scanf("%d%d",&i,&j);
	for (i=1; i<=m; ++i) scanf("%lld%lld",&b[i].x,&b[i].y);
	for (i=1; i<=n; ++i) scanf("%lld%lld",&a[i].x,&a[i].y);
}

long long jl(struct Tpoint &a, struct Tpoint &b) {
	return ((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
}

int cj(struct Tpoint &p0, struct Tpoint &p1, struct Tpoint &p2) {
	long long t;
	t = (p1.x - p0.x) * (p2.y - p0.y) - (p1.y - p0.y) * (p2.x - p0.x);
	// printf("%d * %d - %d * %d\n",(p1.x - p0.x) , (p2.y - p0.y) , (p1.y - p0.y) , (p2.x - p0.x));
	if (t > 0) return 1;
	if (t == 0) return 0;
	if (t < 0) return -1;
}

bool bj(int x, int y) {
	int t;
	t = cj(a[xl[1]], a[x], a[y]);
	if (t > 0) return true;
	if (t < 0) return false;
	return jl(a[xl[1]], a[x]) < jl(a[xl[1]], a[y]);
}

void work() {
	int yzd = 1, xzd = 1;
	int start, stop, mid, r;
	int i, j, k, t;
	for (i=1; i<=n; ++i) {
		if (a[i].y > a[yzd].y) yzd = i;
		if (a[i].x > a[xzd].x) xzd = i;
	}
	a[n+1].x=a[yzd].x; a[n+1].y=a[xzd].y;
	xltop=1;
	xl[1]=n+1;
	for (i=1; i<=n; ++i) 
		if ((a[i].x>a[n+1].x)||(a[i].y>a[n+1].y))
			xl[++xltop]=i;
	// printf("xltop=%d\n",xltop);
	if (xltop >= 3) {
		sort(xl+2,xl+xltop+1, bj);
		j = 3;
		for (i=4; i<=xltop; ++i) {
			while ((j - 1 >= 1) && (cj(a[xl[j-1]],a[xl[j]],a[xl[i]]) < 0))
				--j;
			xl[++j] = xl[i];
		}
		xltop = j;
	}
	xl[xltop+1]=xl[xltop];
	for (i=1; i<=xltop; ++i) {
		// printf("(%lld %lld)\n",a[xl[i]].x,a[xl[i]].y);
	}

	minwin = true;
	for (i=1; i<=m; ++i) {
		if (xltop < 3) {
			if ((b[i].x < a[yzd].x) && (b[i].y < a[xzd].y)) continue;
			else {
				minwin = false;
				break;
			}
		}

		if ((b[i].x <= a[yzd].x) && (b[i].y >= a[yzd].y)) {
			minwin = false;
			break;
		}
		if ((b[i].y <= a[xzd].y) && (b[i].x >= a[xzd].x)) {
			minwin = false;
			break;
		}

		if (b[i].x < a[yzd].x) continue;
		if (b[i].y < a[xzd].y) continue;

		if ((b[i].x == a[yzd].x) && (b[i].y == a[xzd].y)) continue;
		
		start = 2;
		stop = xltop - 1;
		while (start <= stop) {
			mid = (start + stop) / 2;
			t = cj(a[xl[1]], a[xl[mid]], b[i]);
			if (t >= 0) {
				r = mid;
				start = mid + 1;
			} else stop = mid - 1;
		}
		// printf("[%d %d]\n",b[1].x,b[1].y);
		// printf("(%lld %lld), cj=%d\n",a[xl[r]].x,a[xl[r]].y,cj(b[i], a[xl[r]], a[xl[r+1]]));

		if (cj(b[i], a[xl[r]], a[xl[r+1]]) <= 0) {
			minwin = false;
			break;
		}
			
				
	}
}

void output() {
	if (minwin) printf("Min\n");
	else printf("Max\n");
}

int main() {
	// freopen("G.in", "r", stdin);
	init();
	work();
	output();
	return 0;
}