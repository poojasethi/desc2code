#include <iostream>
#include <sstream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <vector>

typedef long long Int64;

const Int64 N = 1e5 + 10;

Int64 n, m;
struct Point {
    Int64 x, y;
    
    Point(){}
    Point(Int64 x, Int64 y):x(x), y(y) {}
    
    void read() {
        int x, y;
        scanf("%d%d", &x, &y);
        this->x = x;
        this->y = y;
    }
    
    friend bool operator < (const Point &x, const Point &y) {
        return std::make_pair(x.x, x.y) < std::make_pair(y.x, y.y);
    }
    
    friend Point operator + (const Point &x, const Point &y) {
        return Point(x.x + y.x, x.y + y.y);
    }
    
    friend Point operator - (const Point &x, const Point &y) {
        return Point(x.x - y.x, x.y - y.y);
    }
    
    friend Int64 operator * (const Point &x, const Point &y) {
        return x.x * y.x + x.y * y.y;
    }
    
    friend Int64 operator ^ (const Point &x, const Point &y) {
        return x.x * y.y - x.y * y.x;
    }
};
Point point[2][N];

void init() {
    std::cin >> n >> m;
    point[0][0].read();
    for (Int64 i = 1; i <= n; i ++) {
        point[0][i].read();
    }
    for (Int64 i = 1; i <= m; i ++) {
        point[1][i].read();
    }
}

bool on_left(Point p, Point p1, Point p2) {
    return ((p2 - p1) ^ (p - p1)) >= 0;
}

void get_convex_hull(std::vector<Point> &p, std::vector<Point> &ch) {
    ch.clear();
    
    sort(p.begin(), p.end());
    
    for (Int64 i = 0; i < (Int64)p.size(); i ++) {
        while ((Int64)ch.size() >= 2) {
            Point p1 = ch[(Int64)ch.size() - 1];
            Point p2 = ch[(Int64)ch.size() - 2];
            if (on_left(p1, p[i], p2)) {
                ch.pop_back();
            } else {
                break;
            }
        }
        ch.push_back(p[i]);
    }
}

void work() {
    static std::vector<Point> tmp;
    tmp.clear();
    
    Int64 max_x = -1, max_y = -1;
    for (Int64 i = 1; i <= m; i ++) {
        tmp.push_back(point[1][i]);
        max_x = std::max(max_x, point[1][i].x);
        max_y = std::max(max_y, point[1][i].y);
    }
    tmp.push_back(Point(0, max_y));
    
    static std::vector<Point> ch;
    get_convex_hull(tmp, ch);

    std::sort(point[0] + 1, point[0] + n + 1);
    
    Int64 cur = 0;
    for (Int64 i = 1; i <= n; i ++) {
        if (point[0][i].x >= max_x || point[0][i].y >= max_y) {
            printf("Max\n");
            return ;
        }
        while (cur < (Int64)ch.size() && point[0][i].x > ch[cur].x) {
            cur ++;
        }
        if (cur != 0 && cur < (Int64)ch.size() && on_left(point[0][i], ch[cur - 1], ch[cur])) {
            printf("Max\n");
            return ;
        }
    }
    printf("Min\n");
}

int main() {
    //freopen("G.in", "r", stdin);
    
    init();
    work();
    
    return 0;
}