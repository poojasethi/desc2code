from __future__ import division
import sys
from itertools import chain, izip_longest

def read_ints(itr):
    return map(int, next(itr).split(' '))

def read_pairs(itr, n):
    for i in xrange(n):
        yield read_ints(itr)

def convex_hull(pairs):
    sorted_pairs = sorted(pairs)
    begin_pad, end_pad = get_pads(sorted_pairs)

    convex_hull_pairs = [begin_pad, sorted_pairs[0]]

    for pair in sorted_pairs[1:]:
        # If the middle point is dominated by the two surrounding points,
        # it's not needed, so delete it
        while (len(convex_hull_pairs) >= 2 and
               point_below_line(convex_hull_pairs[-2], pair, convex_hull_pairs[-1], strict=False)):
            del[convex_hull_pairs[-1]]

        convex_hull_pairs.append(pair)

    convex_hull_pairs.append(end_pad)
    return convex_hull_pairs

def get_pads(pairs):
    pairs = list(pairs)
    first_x, first_y = pairs[0]
    last_x, last_y = pairs[-1]

    return [0, first_y], [last_x, 0]

def pad_pairs(pairs):
    begin_pad, end_pad = get_pads(pairs)
    return chain([begin_pad], pairs, [end_pad])

def point_above_line(p1, p2, p, strict=True):
    '''
    Returns true if p is above the line segment p1, p2. p_x must
    be between p_1x and p_2x.

    If strict=True, then the point must be strictly above the line.
    Otherwise, a point on the line will return True.
    '''
    p_x, p_y = p
    a = p2[0] - p[0]
    b = p[0] - p1[0]

    extrapolated_y = a * p1[1] + b * p2[1]
    point_y = (a + b) * p_y

    if strict:
        return point_y > extrapolated_y
    else:
        return point_y >= extrapolated_y

def point_below_line(p1, p2, p, strict=True):
    return not point_above_line(p1, p2, p, not strict)

def any_dominates(dominator, dominated):
    def advance(left, right):
        return (right, next(dominated))

    # I'll need to access the same elements more than once
    dominated = iter(dominated)

    # Start with the furthest left (smallest x) two (potentially) dominated pairs,
    # then gradualy work right as needed
    dominated_left = next(dominated)
    dominated_right = next(dominated)

    # For each pair in the (potential) dominator, check whether it dominates
    for dominator_current in dominator:
        # print 'Examining max pair ({}, {})'.format(*dominator_current)
        # Shift dominated window until the two line up
        while dominator_current[0] >= dominated_right[0]:
            try:
                dominated_left, dominated_right = advance(dominated_left, dominated_right)
            except StopIteration:
                # dominated can't catch up to dominator
                # print "Min can't get that far right. Returning True"
                return True

        # print "Min surrounding points: {} and {}".format(tuple(dominated_left), tuple(dominated_right))

        # Now dominated_left_x <= dominator_current_x <= dominated_right_x
        # Need to find the linear combination of left_x and right_x that will be equal to
        # current_x and see if that same combination of left_y and right_y is greater than
        # or less than current_y

        if point_above_line(dominator_current, dominated_left, dominated_right, strict=False):
            return True

    # Got through the loop and can't dominate? Must not be a winner
    # print "never dominated. returning false."
    return False


if __name__ == '__main__':
    n, m = read_ints(sys.stdin)
    x, y = read_ints(sys.stdin)

    max_pairs = sorted(read_pairs(sys.stdin, n))
    # print 'Read max pairs: {}'.format(max_pairs)
    min_pairs = convex_hull(read_pairs(sys.stdin, m))
    # print 'Read min pairs: {}'.format(min_pairs)

    if any_dominates(max_pairs, min_pairs):
        print "Max"
    else:
        print "Min"
