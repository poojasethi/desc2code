numq = int(raw_input().strip())
intervals = ['blah']

class interval:
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.neighbors = []
    def canmoveto(self, other):
        return (other.x < self.x and self.x < other.y) or (other.x < self.y and self.y < other.y)
    def connected(self, index, intervals):
        q = self.neighbors[:]
        seen = {}
        while len(q) > 0:
            curr = q.pop(0)
            seen[curr] = True
            if curr == index:
                return True
            else:
                for n in intervals[curr].neighbors:
                    if n not in q and n not in seen:
                        q.append(n)
        return False
            
for l in range(numq):
    type, f, s = [int(i) for i in raw_input().strip().split()]
    if type == 1:
        intervals.append(interval(f, s))
        for i in range(1, len(intervals)-1):
            if intervals[i].canmoveto(intervals[-1]):
                intervals[i].neighbors.append(len(intervals)-1)
            if intervals[-1].canmoveto(intervals[i]):
                intervals[-1].neighbors.append(i)
    else:
        print "YES" if intervals[f].connected(s, intervals) else "NO"