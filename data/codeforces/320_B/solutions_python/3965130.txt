n = int(raw_input())

class Node(object):
    def __init__(self, a, b, edges=None):
        if not edges: edges = []
        self.a, self.b, self.edges = a, b, edges
    def __str__(self):
        return '('+str(self.a)+','+str(self.b)+')'
    def __repr__(self):
        return '('+str(self.a)+','+str(self.b)+')'

def dfs(start, end, visited):
    visited.add(start)

    if start == end:
        return True

    if not start.edges:
        return False

    for node in start.edges:
        if node not in visited:
            if dfs(node, end, visited):
                return True

    return False

node_dict = {}
num_added = 1

for _ in xrange(n):
    c, x, y = map(int, raw_input().strip().split())
    if c == 1: # add interval
        node = Node(x, y)
        for _, other_node in node_dict.iteritems():
            if (other_node.a < x < other_node.b) or (other_node.a < y < other_node.b):
                node.edges.append(other_node)
            if (x < other_node.a < y) or (x < other_node.b < y):
                other_node.edges.append(node)
        node_dict[num_added] = node
        num_added += 1
    else: # search for interval
        if dfs(node_dict[x], node_dict[y], set([])):
            print 'YES'
        else:
            print 'NO'

'''
{1: (1,5), 2: (5,11), 3: (2,9)}
[(1,5), (2,9), (5,11), (2,9)]


1,5,4,3

5,11,6,8

2,9,7,5.5


        (1,5) (4)
        /
    (2, 9) (7)


(3,4)

        (5, 11) (6)

'''
