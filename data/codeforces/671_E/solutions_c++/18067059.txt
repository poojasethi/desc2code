#include <stdio.h>
#define LL __int64
LL seg[400000][7];
LL inf=(1LL<<62)-1LL;
int edgeN,qN,n,ans,layer,best;
LL k;
int q[200000],head[200000],edge[200000][2],pt[200000];
LL a[200000],b[200000],gap[200000],tau[200000];
void calc_ans(int,int,int,LL);
LL calc_rh(int,int,int,LL);
LL max(LL a,LL b){
    return a>=b?a:b;
}
LL min(LL a,LL b){
    return a<=b?a:b;
}
void recoup(int l,int r,int p){
    if(l-r){
        seg[p*2+1][6]+=seg[p][6];
        seg[p*2+1][1]+=seg[p][6];
        seg[p*2+1][2]-=seg[p][6];
        seg[p*2+1][5]+=seg[p][6];
        seg[p*2+2][6]+=seg[p][6];
        seg[p*2+2][1]+=seg[p][6];
        seg[p*2+2][2]-=seg[p][6];
        seg[p*2+2][5]+=seg[p][6];
    }
    seg[p][6]=0;
    return;
}
LL getans(int l,int r,int p,int lb,int rb,LL &ls){
    if(l==lb&&r==rb){
        calc_ans(l,r,p,ls);
        if(seg[p][4]+k>=0){
	        if(l-r){
		        int m=(lb+rb)/2;
    		    LL tmpls=max(ls,seg[p*2+1][1]);
	    	    getans(m+1,r,p*2+2,m+1,r,tmpls);
	    	    if(best<m){
	    	        tmpls=ls;
	    	        getans(l,m,p*2+1,l,m,tmpls);
	    	    }
			}else{
			    best=max(best,l);
			}
		}
        ls=max(ls,seg[p][1]);
        return seg[p][4];
    }else{
        recoup(lb,rb,p);
        int m=(lb+rb)/2;
        if(r<=m) return getans(l,r,p*2+1,lb,m,ls);
        else if(l>m) return getans(l,r,p*2+2,m+1,rb,ls);
        else{
            LL tmp=getans(l,m,p*2+1,lb,m,ls);
			tmp=max(tmp,getans(m+1,r,p*2+2,m+1,rb,ls));
			return tmp;
        }
    }
}
int gettot(int l,int r,int p){
	if(l==r){
		return l;
	}else{
		recoup(l,r,p);
		int m=(l+r)/2;
		if(seg[p*2+2][5]>k) return gettot(l,m,p*2+1);
		else return gettot(m+1,r,p*2+2);
	}
}
void addseg(int l,int r,int p,int lb,int rb,LL v){
    if(l==lb&&r==rb){
        seg[p][6]+=v;
        seg[p][1]+=v;
        seg[p][2]-=v;
        seg[p][5]+=v;
    }else{
        recoup(lb,rb,p);
        int m=(lb+rb)/2;
        if(r<=m){
            addseg(l,r,p*2+1,lb,m,v);
        }else if(l>m){
            addseg(l,r,p*2+2,m+1,rb,v);
        }else{
            addseg(l,m,p*2+1,lb,m,v);
            addseg(m+1,r,p*2+2,m+1,rb,v);
        }
        seg[p][1]=max(seg[p*2+1][1],seg[p*2+2][1]);
        seg[p][5]=min(seg[p*2+1][5],seg[p*2+2][5]);
        seg[p][2]=calc_rh(m+1,rb,p*2+2,seg[p*2+1][1]);
    }
    return;
}
void dfs(int x){
    int bound,m,y,i;
    LL ls;
    if(~pt[x]) addseg(pt[x]-1,(1<<layer)-1,0,0,(1<<layer)-1,-gap[x]);
    bound=gettot(0,(1<<layer)-1,0)+1;
    bound=min(bound,n-1);
    bound=max(x,bound);
    ls=-inf,best=x;
    getans(x,bound,0,0,(1<<layer)-1,ls);
    ans=max(ans,best-x+1);
    for(i=head[x];~i;i=edge[i][1]) dfs(edge[i][0]);
    if(~pt[x]) addseg(pt[x]-1,n-1,0,0,(1<<layer)-1,gap[x]);
    return;
}
void calc_ans(int l,int r,int p,LL ls){
    if(l==r){
    	seg[p][4]=seg[p][0]-ls;
    }else{
        recoup(l,r,p);
        int m=(l+r)/2;
        if(ls>=seg[p*2+1][1]){
            calc_ans(m+1,r,p*2+2,ls);
            seg[p][4]=max(seg[p*2+1][0]-ls,seg[p*2+2][4]);
        }else{
            calc_ans(l,m,p*2+1,ls);
            seg[p][4]=max(seg[p*2+1][4],seg[p*2+2][2]);
        }
    }
    return;
}
LL calc_rh(int l,int r,int p,LL ls){
    if(l==r){
        return seg[p][0]-ls;
    }else{
        recoup(l,r,p);
        int m=(l+r)/2;
        if(ls>=seg[p*2+1][1]){
            return max(seg[p*2+1][0]-ls,calc_rh(m+1,r,p*2+2,ls));
        }else{
            return max(seg[p][2],calc_rh(l,m,p*2+1,ls));
        }
    }
}
void merge_seg(int l,int r,int p){
    if(l==r){
        return;
    }
    int m=(l+r)/2;
    merge_seg(l,m,p*2+1);
    merge_seg(m+1,r,p*2+2);
    seg[p][0]=max(seg[p*2+1][0],seg[p*2+2][0]);
    seg[p][1]=max(seg[p*2+1][1],seg[p*2+2][1]);
    seg[p][5]=min(seg[p*2+1][5],seg[p*2+2][5]);
    seg[p][6]=0;
    seg[p][2]=calc_rh(m+1,r,p*2+2,seg[p*2+1][1]);
    return;
}
void create_seg(){
    //0 tau
    //1 fuel
    //2 righthalf
    //3 leftside
    //4 ans
    //5 tot
    //6 delay
    int i,j;
    for(i=0;i<n;i++){
        j=(1<<layer)-1+i;
        seg[j][0]=tau[i];
        seg[j][1]=tau[i];
        seg[j][5]=0;
        seg[j][6]=0;
    }
    seg[j][4]=seg[j][0]+inf;
    merge_seg(0,(1<<layer)-1,0);
    return;
}
void addedge(int u,int v){
    pt[v]=u;
    edge[edgeN][0]=v;
    edge[edgeN][1]=head[u];
    head[u]=edgeN++;
    return;
}
int main(){
	int i;
    scanf("%d%I64d",&n,&k);
    for(layer=0;(1<<layer)<n;layer++);
    for(i=0;i<n-1;i++) scanf("%I64d",b+i);
    for(i=0;i<n;i++) scanf("%I64d",a+i);
    tau[0]=a[0];
    for(i=1;i<n;i++) tau[i]=tau[i-1]+a[i]-b[i-1];
    qN=0,edgeN=0;
    for(i=0;i<n;i++) head[i]=-1,pt[i]=-1;
    for(i=0;i<n-1;i++){
        q[qN++]=i;
        gap[q[qN-1]]=a[i]-b[i];
        while(qN&&gap[q[qN-1]]<0){
            addedge(i+1,q[--qN]);
            if(qN) gap[q[qN-1]]+=gap[q[qN]];
        }
    }
    create_seg();
    ans=1;
    for(i=n-1;i>=0;i--){
        if(pt[i]==-1) dfs(i);
    }
    printf("%d\n",ans);
    return 0;
}