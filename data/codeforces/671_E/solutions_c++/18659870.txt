#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <map>
#include <set>
#include <vector>
using namespace std;

#define LY(p) freopen (p".in", "r", stdin); freopen (p".out", "w", stdout)
#define dbl double
#define ll long long
#define ld long double
#ifdef WIN32
#define LLD "%I64d"
#else
#define LLD "%lld"
#endif
#define PII pair<int, int>

const int N = 1e5 + 10;
const ll inf = 1e15;

int n, K, w[N], g[N], val[N], stk[N], top, p, ans = 1;
ll s[N], pre[N], md, sum;

#define ls(o) ((o) << 1)
#define rs(o) (ls (o) | 1)

struct node {
	ll md, ms, mv, rv, add;

	node(): md(-inf), ms(-inf), mv(-inf), rv(-inf), add(0) {}
} a[N * 4];

void add (int o, ll d) {
	a[o].md += d, a[o].mv -= d, a[o].rv -= d, a[o].add += d;
}

void push (int o) {
	if (a[o].add) {
		add (ls (o), a[o].add);
		add (rs (o), a[o].add);
		a[o].add = 0;
	}
}

ll calc (int o, int l, int r, ll x) {
	if (l == r)
		return a[o].ms - x;
	push (o);
	int mid (l + r >> 1);
	if (x < a[ls (o)].md)
		return max (calc (ls (o), l, mid, x), a[o].rv);
	else
		return max (calc (rs (o), mid + 1, r, x), a[ls (o)].ms - x);
}

void update (int o, int l, int r) {
	int mid (l + r >> 1);
	a[o].md = max (a[ls (o)].md, a[rs (o)].md);
	a[o].ms = max (a[ls (o)].ms, a[rs (o)].ms);
	a[o].rv = calc (rs (o), mid + 1, r, a[ls (o)].md);
	a[o].mv = max (a[ls (o)].mv, a[o].rv);
}

void modify (int o, int l, int r, int L, int R, int d) {
	if (R < l || r < L) return;
	if (L <= l && r <= R)
		return add (o, d);
	push (o);
	int mid (l + r >> 1);
	modify (ls (o), l, mid, L, R, d);
	modify (rs (o), mid + 1, r, L, R, d);
	update (o, l, r);
}

void modify (int o, int l, int r, int x) {
	if (l == r)
		return (void) (a[o].md = a[o].ms = s[l], a[o].mv = 0);
	push (o);
	int mid (l + r >> 1);
	if (x <= mid)
		modify (ls (o), l, mid, x);
	else
		modify (rs (o), mid + 1, r, x);
	update (o, l, r);
}

int query (int o, int l, int r, int L, int R) {
	if (o == 1)	md = -inf;
	if (R < l || r < L) return -1;
	if (l == r) return l;
	push (o);
	int mid (l + r >> 1);
	if (L > mid || (R > mid && calc (rs (o), mid + 1, r, max (md, a[ls (o)].md)) >= -K))
		return md = max (a[ls (o)].md, md), query (rs (o), mid + 1, r, L, R);
	else
		return query (ls (o), l, mid, L, R);
}

int get() {
	if (! top) return n;
	int l = 0, r = top;
	for (int mid; mid = l + r + 1 >> 1, l < r;)
		if (sum - pre[mid - 1] > K)
			l = mid;
		else
			r = mid - 1;
	return l? stk[l] : n;
}

int main()
{
#ifndef ONLINE_JUDGE
	LY("E");
#endif
	scanf ("%d %d", &n, &K);
	for (int i = 1; i < n; i++) scanf ("%d", w + i);
	for (int i = 1; i <= n; i++) scanf ("%d", g + i);
	for (int i = 1; i <= n; i++)
		s[i] = s[i - 1] + g[i] - w[i - 1];

	for (int i = n, d; i >= 1; i--) {
		modify (1, 1, n, i);
		if (i < n)
			if ((d = g[i] - w[i]) > 0)
				for (int t; d && top; top--) {
					t = min (d, val[top]);
					d -= t, val[top] -= t;
					modify (1, 1, n, stk[top], n, -t);
					if (val[top]) break;
				}
			else if (d < 0)
				stk[++ top] = i, val[top] = -d, modify (1, 1, n, i, n, -d);
		sum = pre[top] = pre[top - 1] + val[top];
		if (i < n)
			ans = max (query (1, 1, n, i, get()) - i + 1, ans);
	}
	printf ("%d", ans);
	return 0;
}
