#include <iostream>
#include <iomanip>
#include <cstring>
#include <string>
#include <algorithm>
#include <queue>
#include <map>
#include <deque>
#include <set>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <fstream>

#define pb push_back
#define mp make_pair
#define F first
#define S second

#define foreach(i, c) for (typeof(c.begin()) i = c.begin(); i != c.end(); ++i)

#ifndef LOCAL
#define cerr if(0)cerr
#endif

using namespace std;

typedef long long ll;
typedef pair<int, int> pii;
typedef vector<int> vi;
typedef long double ld;

const int INF = int(1e9);
const ll INFll = 1ll * INF * INF;
const int MOD = 1000000007;
const int N = 100005;

vector<pii> g[N];

int main() {
    cin.tie(0);
    ios_base::sync_with_stdio(0);
#ifdef LOCAL
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif // LOCAL
    int n, m;
    scanf("%d %d", &n, &m);
    for (int i = 0; i < m; ++i) {
        int x, y, len;
        scanf("%d %d %d", &x, &y, &len);\
        g[x].pb(mp(y, len));
        g[y].pb(mp(x, len));
    }
    vector<pii> d(n, mp(INF, INF));
    d[0] = mp(0, 0);
    vi p(n, -1);
    priority_queue<pair<pii, int> > q;
    q.push(mp(mp(0, 0), 0));
    vi rnk(n);
    int rnk_ = 0;
    while (!q.empty()) {
        int v = q.top().S;
        int k = -q.top().F.F;
        int c = -q.top().F.S;
        q.pop();
        if (d[v] != mp(k, c))
            continue;
        rnk[v] = rnk_++;
        for (int i = 0; i < g[v].size(); ++i) {
            int to = g[v][i].F;
            int len = g[v][i].S;
            if (d[to].F > k + 1 || d[to].F == k + 1 && d[to].S > len) {
                d[to] = mp(k + 1, len);
                q.push(mp(mp(-(k + 1), -(len)), to));
                p[to] = v;
            }
        }
    }
    vi ans;
    vi num;
    vi anc(n, -1);
    {
        queue<int> q;
        q.push(n - 1);
        anc[n - 1] = 0;
        while (!q.empty()) {
            int v = q.front();
            q.pop();
            for (int i = 0; i < g[v].size(); ++i)
                if (g[v][i].S == 0 && anc[g[v][i].F] == -1) {
                    anc[g[v][i].F] = v;
                    q.push(g[v][i].F);
                }
        }
    }
    int cur = n - 1;
    for (int i = 0; i < n - 1; ++i)
        if (anc[i] != -1) {
            if (d[cur].F > d[i].F || d[cur].F == d[i].F && d[cur].S > d[i].S || d[cur].F == d[i].F && d[cur].S == d[i].S && rnk[cur] > rnk[i])
                cur = i;
        }
    int cur_ = cur;
    while (cur != 0) {
        ans.pb(cur);
        num.pb(d[cur].S);
        cur = p[cur];
    }
    ans.pb(0);
    reverse(ans.begin(), ans.end());
    cur = cur_;
    while (cur != n - 1) {
        cur = anc[cur];
        ans.pb(cur);
    }
    for (int i = 0; i < num.size(); ++i)
        printf("%d", num[i]);
    if (num.empty())
        printf("0");
    printf("\n");
    printf("%d\n", ans.size());
    for (int i = 0; i < ans.size(); ++i)
        printf("%d ", ans[i]);
    cerr << "\nTIME = " << clock() << "\n";
    return 0;
}

