#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <cmath>
#include <vector>
#include <queue>
#define ul unsigned long long
#define fi first
#define se second;

using namespace std;

const int maxn = 1e5 + 5;

bool used[maxn], can[maxn];
int pb[maxn];
int dist_zero[maxn];
int p[maxn], num[maxn], p1[maxn];
vector < vector <pair <int, int> > > sp;
vector <vector <int> > zero;
int n, m;

void bfs_from_last() {
	queue <int> q;
	q.push(n - 1);
	dist_zero[n - 1] = 0;
	p1[n - 1] = n - 1;
	can[n - 1] = true;
	while (!q.empty()) {
		int now = q.front();
		q.pop();
		for (int i = 0; i < zero[now].size(); i++) {
			int nxt = zero[now][i];
			if (can[nxt])
				continue;
			can[nxt] = true;
			dist_zero[nxt] = dist_zero[now] + 1;
			q.push(nxt);
			p1[nxt] = now;
		}
	}
}

struct edge {
	int x, y, z;
	edge(int _x, int _y, int _z) {
		x = _x;
		y = _y;
		z = _z;
	}
	edge() {}
};

bool cmp(edge a, edge b) {
	if (a.z != b.z)
		return a.z < b.z;
	return num[a.x] < num[b.x];

}

bool cmp1(edge a, edge b) {
	if (a.z != b.z)
		return a.z < b.z;
	if (num[a.x] != num[b.x])
		return num[a.x] < num[b.x];
	return dist_zero[a.y] < dist_zero[b.y];
}

vector <int> ans;
vector <int> val;
int r[maxn];

void restore_path(int v) {
	if (v == 0) {
		ans.push_back(v);
		return;
	}
	val.push_back(r[v]);
	restore_path(p[v]);
	ans.push_back(v);
}

void restore_path_zero(int v) {
	if (v == n - 1) {
		ans.push_back(n - 1);
		return;
	}
	ans.push_back(v);
	restore_path_zero(p1[v]);
}

void main_bfs() {
	vector <int> q;
	q.push_back(0);
	num[0] = 0;
	used[0] = 0;
	bool flag = false;
	vector <edge> c;
	while (!flag) {
		vector <edge> e;
		for (int i = 0; i < q.size(); i++) {
			int nxt = q[i];
			for (int j = 0; j < sp[nxt].size(); j++) {
				e.push_back(edge(nxt, sp[nxt][j].fi, sp[nxt][j].second));
			}
		}
		sort(e.begin(), e.end(), cmp);
		q.clear();
	
		for (int i = 0; i < e.size(); i++) {
			if (used[e[i].y])
				continue;
			q.push_back(e[i].y);
			num[e[i].y] = i;
			r[e[i].y] = e[i].z;
			p[e[i].y] = e[i].x;
			used[e[i].y] = true;
			if (can[e[i].y]) {
				flag = true;
				c.push_back(e[i]);
			}
		}
	}
	sort(c.begin(), c.end(), cmp1);
	restore_path(c[0].y);
	if (c[0].y != n - 1) {
		restore_path_zero(p1[c[0].y]);
	}
}
int main() {

	//freopen("testbrain.in", "r", stdin);
	//freopen("testbrain.out", "w", stdout);
	scanf("%d %d", &n, &m);
	sp.resize(n);
	zero.resize(n);
	for (int i = 0; i < m; i++) {
		int x, y, z;
		scanf("%d %d %d", &x, &y, &z);
		sp[x].push_back(make_pair(y, z));
		sp[y].push_back(make_pair(x, z));
		if (z == 0) {
			zero[x].push_back(y);
			zero[y].push_back(x);
		}
	}

	bfs_from_last();
	main_bfs();
	for (int i = 0; i < val.size(); i++) {
		printf("%d", val[i]);
	}
	printf("\n");
	printf("%d\n", ans.size());;
	for (int i = 0; i < ans.size(); i++){
		printf("%d ", ans[i]);
	}

	//system("Pause");
	return 0;
}