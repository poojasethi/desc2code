#include <cstdio>
#include <cstring>
#include <queue>

using namespace std;

#define MAXN 100000

int N;
vector<int> L[MAXN],W[MAXN];

struct node{
    int pos,dist;
    
    node(){}
    node(int _pos, int _dist):
        pos(_pos),dist(_dist){}
};

int dist[MAXN];
bool is_end[MAXN];

int bfs(){
    memset(dist,-1,sizeof dist);
    queue<node> Q;
    int D = -1;
    
    Q.push(node(0,0));
    dist[0] = 0;
    
    while(!Q.empty()){
        node cur = Q.front();
        Q.pop();
        
        if(is_end[cur.pos] && (D == -1 || dist[cur.pos] < D))
            D = dist[cur.pos];
        
        for(int i = 0;i < L[cur.pos].size();++i){
            int to = L[cur.pos][i];
            
            if(dist[to] == -1 || dist[to] > cur.dist + 1){
                Q.push(node(to,cur.dist + 1));
                dist[to] = cur.dist + 1;
            }
        }
    }
    
    for(int i = 0;i < N;++i)
        if(is_end[i])
            dist[i] = D;
    
    return D;
}

vector<int> v,v2;
queue<int> Q;
bool visited[MAXN];
int dig[MAXN],parent[MAXN];

int main(){
    int M;
    scanf("%d %d",&N,&M);
    
    for(int i = 0,u,v,w;i < M;++i){
        scanf("%d %d %d",&u,&v,&w);
        L[u].push_back(v);
        W[u].push_back(w);
        L[v].push_back(u);
        W[v].push_back(w);
    }
    
    Q.push(N - 1);
    visited[N - 1] = true;
    
    while(!Q.empty()){
        int cur = Q.front();
        Q.pop();
        v.push_back(cur);
        is_end[cur] = true;
        
        for(int i = 0;i < L[cur].size();++i){
            int to = L[cur][i];
            
            if(!visited[to] && W[cur][i] == 0){
                visited[to] = true;
                parent[to] = cur;
                Q.push(to);
            }
        }
    }
    
    int D = bfs();
    
    for(int d = D;d > 0;--d){
        int best = 9;
        
        for(int i = 0;i < v.size();++i){
            int cur = v[i];
            
            for(int j = 0;j < L[cur].size();++j){
                int to = L[cur][j];
                if(dist[to] == d - 1)
                    best = min(best,W[cur][j]);
            }
        }
    
        dig[d - 1] = best;
        v2.clear();
        
        for(int i = 0;i < v.size();++i){
            int cur = v[i];
            
            for(int j = 0;j < L[cur].size();++j){
                int to = L[cur][j];
                if(!visited[to] && dist[to] == d - 1 && W[cur][j] == best){
                    visited[to] = true;
                    parent[to] = cur;
                    v2.push_back(to);
                }
            }
        }
        
        v = v2;
    }
    
    if(D > 0){
        for(int i = D - 1;i >= 0;--i)
            printf("%d",dig[i]);
        printf("\n");
    }else printf("0\n");
    
    v.clear();
    int cur = 0;
    
    while(cur != N - 1){
        v.push_back(cur);
        cur = parent[cur];
    }
    
    printf("%d\n",(int)v.size() + 1);
    for(int i = 0;i < v.size();++i){
        if(i) printf(" ");
        printf("%d",v[i]);
    }
    printf(" %d\n",N - 1);
    
    return 0;
}