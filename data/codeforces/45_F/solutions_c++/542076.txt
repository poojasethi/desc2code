#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;

int n,m;

struct node
{
    int g,w,m,step;
    node(){}
    node(int _g,int _w,int _m,int _step)
        {
            g = _g;
            w = _w;
            m = _m;
            step = _step;
        }
};

queue<node> Q;

bool visit[100][100][2];

bool check(int g,int w)
{
    if (g == 0) return true;
    if (g < w)  return false;
    return true;
}

void updata(int g,int w,int m,int step)
{
    if (visit[g][w][m] == false)
    {
        Q.push(node(g,w,m,step));
        visit[g][w][m] = true;
    }
}

int BFS()
{
    memset(visit,false,sizeof(visit));
    while (!Q.empty())  Q.pop();
    visit[n][n][0] = true;
    Q.push(node(n,n,0,0));
    while (!Q.empty())
    {
        node now = Q.front();
        Q.pop();
        if (now.g == 0 && now.w == 0 && now.m == 1) return now.step;
        if (now.m == 0)
        {
            for (int i = 0;i <= now.g;i++)
                for (int j = 0;j <= now.w;j++)
                    if (i+j >= 1 && i+j <= m)
                        if (check(i,j) && check(now.g-i,now.w-j) && check(n-now.g+i,n-now.w+j))
                            updata(now.g-i,now.w-j,1,now.step+1);
        }
        else
        {
            for (int i = 0;i <= n-now.g;i++)
                for (int j = 0;j <= n-now.w;j++)
                    if (i+j >= 1 && i+j <= m)
                        if (check(i,j) && check(n-now.g-i,n-now.w-j) && check(now.g+i,now.w+j))
                            updata(now.g+i,now.w+j,0,now.step+1);
        }
    }
    return -1;
}

int solve()
{
    if (m == 1) return -1;
    if (n == 1) return 1;
    if (m == 2)
    {
        if (n == 1) return 1;
        if (n == 2) return 5;
        if (n == 3) return 11;
        return -1;
    }
    if (m == 3)
    {
        if (n == 1) return 1;
        if (n == 2) return 3;
        if (n == 3) return 5;
        if (n == 4) return 9;
        if (n == 5) return 11;
        return -1;
    }
    if (m%2 == 0)   return 2*((n-2)/((m-2)/2))+1;
    int d = m/2-1;
    if (n-2 < 2*d)  return 2*((n-2)/((m-2)/2))+1;
    if (n-2 == 2*d) return 3;
    if (n-2 < 2*d+1+2*d)    return 2*((n-3)/((m-2)/2))+1;
    if (n-2 == 2*d+1+2*d)   return 7;
    return 2*((n-4)/((m-2)/2))+1;
}

int main()
{
    scanf("%d%d",&n,&m);
    printf("%d\n",solve());
    return 0;
    /*freopen("out.txt","w",stdout);
    for (n = 1;n <= 50;n++)
    {
        for (m = 1;m <= 50;m++)
            printf("%2d ",BFS()-solve());
        printf("\n");
    }*/
}

     	   	 	   		 		  	   	