#include <map>
#include <set>
#include <cmath>
#include <stack>
#include <queue>
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <algorithm>
#include <unistd.h>
#include  <sys/time.h>
#include <iomanip>
using namespace std;
#define li		 int
#define rep(i,to)	for(li i=0;i<((li)to);i++)
#define pb		push_back
#define sz(v)		((li)v.size())


struct state{
	li left0,left1;
	li right0,right1;
	li pos;
	bool operator<(const state &n) const {
		if(this->left0!=n.left0) return this->left0<n.left0;
		if(this->left1!=n.left1) return this->left1<n.left1;
		if(this->right0!=n.right0) return this->right0<n.right0;
		if(this->right1!=n.right1) return this->right1<n.right1;
		return this->pos<n.pos;
	}
};

map<state,li> dp;

int main(){
	li n,m;
	cin>>n>>m;
	state start=(state){n,n,0,0,0};
	queue<state> q;
	q.push(start);
	dp[start]=0;
	while(sz(q)){
		state s=q.front(),next;
		q.pop();
		if(s.right0==n && s.right1==n){
			cout<<dp[s]<<endl;
			return 0;
		}
		if(s.pos==0){
#define add { if(dp.find(next)==dp.end()){ q.push(next); dp[next]=dp[s]+1; } }
			li sum=s.right0+s.right1+m;
			next=(state){0,n-min(n,sum-n),n,min(n,sum-n),1};
			if(s.right0<=next.right0 && s.right1<=next.right1) add;
			next=(state){n,n-min(n,sum),0,min(n,sum),1};
			if(s.right0<=next.right0 && s.right1<=next.right1) add;
			next=(state){n-sum/2,n-sum/2,sum/2,sum/2,1};
			if(s.right0<=next.right0 && s.right1<=next.right1) add;
		}else{
			li sum=s.left0+s.left1+m;
			next=(state){0,s.left1+1,n,s.right1-1,0};
			if(s.left0<=next.left0 && s.left1<=next.left1) add;
			next=(state){n,s.left1+(s.left0==n?1:0),0,s.right1-(s.left0==n?1:0),0};
			if(s.left0<=next.left0 && s.left1<=next.left1) add;
			li tmp=min(s.right0,s.right1)-(s.right0==s.right1);
			next=(state){n-tmp,n-tmp,tmp,tmp,0};
			if(s.left0<=next.left0 && s.left1<=next.left1) add;
		}
	}
	cout<<"-1"<<endl;
}
