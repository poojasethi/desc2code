#include <cstdlib>
#include <cctype>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <map>
#include <set>
#include <queue>
using namespace std;
int n , m;
int solve() {
	if ( m == 1 ) {
		return -1;
	} else if ( m == 2 ) {
		if ( n == 1 ) return 1;
		if ( n == 2 ) return 5;
		if ( n == 3 ) return 11;
		return -1;
	} else if ( m == 3 ) {
		if ( n == 1 ) return 1;
		if ( n == 2 ) return 3;
		if ( n == 3 ) return 5;
		if ( n == 4 ) return 9;
		if ( n == 5 ) return 11;
		return -1;
	} else if ( m & 1 ) {
		m >>= 1;
		if ( n <= m ) return 1;
		if ( n <= 2 * m ) return 3;
		if ( n <= 3 * m - 1 ) return 5;
		if ( n <= 4 * m - 1 ) return 7;
		return ( n - 4 ) / ( m - 1 ) * 2 + 1;
	} else {
		return ( n - 2 ) / ( m / 2 - 1 ) * 2 + 1;
	}
}
bool vis[ 111 ][ 111 ][ 2 ];
struct Node {
	int w , s , side;
	Node() {
	}
	Node(int a, int b, int c) :
		w(a), s(b), side(c) {
	}
};
queue<Node> que;
int bfs(int n, int m) {

	int tep = 0;
	memset(vis, false, sizeof( vis ));
	while ( !que.empty() )
		que.pop();
	que.push(Node(n, n, 0));
	while ( !que.empty() ) {
		int sz = que.size();
		while ( sz -- ) {
			int w = que.front().w;
			int s = que.front().s;
			int side = que.front().side;
			que.pop();
			if ( vis[ w ][ s ][ side ] ) continue;
			vis[ w ][ s ][ side ] = true;
			//		cout << w << ' ' << s << ' ' << side << endl;
			if ( w == 0 && s == 0 && side == 1 ) return tep;
			if ( side == 0 ) {
				for ( int x = 1 ; x <= m ; x ++ ) {
					for ( int ww = 0 ; ww <= x ; ww ++ ) {

						int ss = x - ww;
						//						if ( w == 2 && s == 2 && n == 2 && ww == 1 && ss == 1 && m == 2 ) {
						//							puts("okey");
						//						}
						if ( ww > w ) continue;
						if ( ss > s ) continue;
						if ( ww > ss && ss != 0 ) continue;
						if ( w - ww > s - ss && s - ss != 0 ) continue;
						if ( n - w + ww > n - s + ss && n - s + ss != 0 ) continue;
						//						if ( w == 1 && s == 1 && n == 1 && ww == 1 && ss == 1 && m == 2 ) {
						//							puts("okey");
						//						}
						que.push(Node(w - ww, s - ss, 1));
					}
				}
			} else {
				for ( int x = 1 ; x <= m ; x ++ ) {
					for ( int ww = 0 ; ww <= x ; ww ++ ) {
						int ss = x - ww;
						if ( ww > n - w ) continue;
						if ( ss > n - s ) continue;
						if ( ww > ss && ss != 0 ) continue;
						if ( w + ww > s + ss && s + ss != 0 ) continue;
						if ( n - w - ww > n - s - ss && n - s - ss != 0 ) continue;
						que.push(Node(w + ww, s + ss, 0));
					}
				}
			}
		}
		tep ++;
	}
	return -1;
}
int main() {
	//	for ( int j = 0 ; j <= 30 ; j ++ ) {
	//		printf("%2d ", j);
	//	}
	//	puts("");
	//	for ( int i = 1 ; i <= 30 ; i ++ ) {
	//		printf("%2d:", i);
	//		for ( int j = 1 ; j <= 30 ; j ++ ) {
	//			printf("%2d ", bfs(i, j));
	//		}
	//		puts("");
	//	}
	cin >> n >> m;
	cout << solve() << endl;
	return 0;
}
/*
 *
 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
 1:-1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
 2:-1  5  3  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
 3:-1 11  5  3  3  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
 4:-1 -1  9  5  3  3  3  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
 5:-1 -1 11  7  5  3  3  3  3  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
 6:-1 -1 -1  9  7  5  3  3  3  3  3  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
 7:-1 -1 -1 11  7  5  5  3  3  3  3  3  3  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
 8:-1 -1 -1 13  9  7  5  5  3  3  3  3  3  3  3  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
 9:-1 -1 -1 15 11  7  7  5  5  3  3  3  3  3  3  3  3  1  1  1  1  1  1  1  1  1  1  1  1  1
 10:-1 -1 -1 17 13  9  7  5  5  5  3  3  3  3  3  3  3  3  3  1  1  1  1  1  1  1  1  1  1  1
 11:-1 -1 -1 19 15  9  7  7  5  5  5  3  3  3  3  3  3  3  3  3  3  1  1  1  1  1  1  1  1  1
 12:-1 -1 -1 21 17 11  9  7  7  5  5  5  3  3  3  3  3  3  3  3  3  3  3  1  1  1  1  1  1  1
 13:-1 -1 -1 23 19 11  9  7  7  5  5  5  5  3  3  3  3  3  3  3  3  3  3  3  3  1  1  1  1  1
 14:-1 -1 -1 25 21 13 11  9  7  7  5  5  5  5  3  3  3  3  3  3  3  3  3  3  3  3  3  1  1  1
 15:-1 -1 -1 27 23 13 11  9  7  7  7  5  5  5  5  3  3  3  3  3  3  3  3  3  3  3  3  3  3  1
 16:-1 -1 -1 29 25 15 13  9  9  7  7  5  5  5  5  5  3  3  3  3  3  3  3  3  3  3  3  3  3  3
 17:-1 -1 -1 31 27 15 13 11  9  7  7  7  5  5  5  5  5  3  3  3  3  3  3  3  3  3  3  3  3  3
 18:-1 -1 -1 33 29 17 15 11  9  9  7  7  7  5  5  5  5  5  3  3  3  3  3  3  3  3  3  3  3  3
 19:-1 -1 -1 35 31 17 15 11 11  9  7  7  7  5  5  5  5  5  5  3  3  3  3  3  3  3  3  3  3  3
 20:-1 -1 -1 37 33 19 17 13 11  9  9  7  7  7  5  5  5  5  5  5  3  3  3  3  3  3  3  3  3  3
 21:-1 -1 -1 39 35 19 17 13 11  9  9  7  7  7  7  5  5  5  5  5  5  3  3  3  3  3  3  3  3  3
 22:-1 -1 -1 41 37 21 19 13 13 11  9  9  7  7  7  5  5  5  5  5  5  5  3  3  3  3  3  3  3  3
 23:-1 -1 -1 43 39 21 19 15 13 11  9  9  7  7  7  7  5  5  5  5  5  5  5  3  3  3  3  3  3  3
 24:-1 -1 -1 45 41 23 21 15 13 11 11  9  9  7  7  7  7  5  5  5  5  5  5  5  3  3  3  3  3  3
 25:-1 -1 -1 47 43 23 21 15 15 11 11  9  9  7  7  7  7  5  5  5  5  5  5  5  5  3  3  3  3  3
 26:-1 -1 -1 49 45 25 23 17 15 13 11  9  9  9  7  7  7  7  5  5  5  5  5  5  5  5  3  3  3  3
 27:-1 -1 -1 51 47 25 23 17 15 13 11 11  9  9  7  7  7  7  7  5  5  5  5  5  5  5  5  3  3  3
 28:-1 -1 -1 53 49 27 25 17 17 13 13 11  9  9  9  7  7  7  7  5  5  5  5  5  5  5  5  5  3  3
 29:-1 -1 -1 55 51 27 25 19 17 13 13 11 11  9  9  7  7  7  7  7  5  5  5  5  5  5  5  5  5  3
 30:-1 -1 -1 57 53 29 27 19 17 15 13 11 11  9  9  9  7  7  7  7  7  5  5  5  5  5  5  5  5  5
 */
