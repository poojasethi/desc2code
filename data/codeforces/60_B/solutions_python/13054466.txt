#Serial Time by Shiva Velingker
import itertools

#Directional Vectors in form of 4C, North, South, East, West
dirX = [[0,0,1,-1],[0,1,-1],[0,1,-1],[0,0,-1],[0,0,1]]
dirY = [[-1,1,0,0],[1,0,0],[-1,0,0],[-1,1,0],[-1,1,0]]
changeOfHeart = [0,2,1,4,3]

class Node:
    def __init__(self,lvl,x,y,prev,kLvl):
        self.k = lvl
        self.x = x
        self.y = y
        self.z = prev
        self.dx = dirX[prev]
        self.dy = dirY[prev]
        if kLvl == 0:
            self.dk = [1,-1]
        else:
            self.dk = [kLvl]
        
def PathFinder(node):
    global counter
    #Set vars
    tX = node.x
    tY = node.y
    tK = node.k
    tZ = node.z

    if Matrix[tK][tX][tY] != ".":
        return 0
    else:
        counter += 1
        Matrix[tK][tX][tY] = "X"
    
    #Find connections in other levels
    for k in node.dk:
        if Matrix[tK+k][tX][tY] == ".":
            PathFinder(Node(tK+k,tX,tY,changeOfHeart[tZ],k))

    #Find local connections
    for x,y in itertools.izip(node.dx,node.dy):
        if Matrix[tK][tX+x][tY+y] == ".":
            PathFinder(Node(tK,tX+x,tY+y,changeOfHeart[tZ],0))

    
#FIRST INPUT  
counter = 0
knm = raw_input().split(' ')
raw_input()
k = int(knm[0])
n = int(knm[1])
m = int(knm[2])
minArray = [0]*(m+2)

#GET PLATE
Matrix = [[minArray for x in range(n+2)] for x in range(k+2)]
for i in range(1,k+1):
    for j in range(1,n+1):
        Matrix[i][j] = [0]+list(raw_input())+[0]
    raw_input()

#TAP INPUT
xy = raw_input().split(' ')
x = int(xy[0])
y = int(xy[1])

firstNode = Node(1,x,y,0,1)
PathFinder(firstNode)
print counter
