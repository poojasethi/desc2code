"""
k - number of plates
n - height of plate
m - width of plate
"""

k, n, m = map(int, raw_input().split(' '))
raw_input() # newline

# 6 directions for the plate to go in.
transforms = [(-1,0,0),(1,0,0),(0,-1,0),(0,1,0),(0,0,-1),(0,0,1)]
adjacents = {}
visited = {}

"""Helper method to check if coord is within bounds
"""
def ok(x, y, z):
    global k, n, m
    return x in xrange(k) and y in xrange(n) and z in xrange(m)

"""Now add every n lines representing a parallelpiped layer
to a list of lines
"""
plates = []

for i in xrange(k):
    plate = []
    for j in xrange(n):
        row = [particle for particle in raw_input().strip()]
        plate.append(row)
    plates.append(plate)
    raw_input() # skip a newline

# the last line - the tap coordinate
start_x, start_y = map(int, raw_input().strip().split())

"""Make a dictionary of adjacent coords per particle per plate using the list of 3-D coord transforms.

+------+
|`.  1 |`.
|  `+--+---+
|   |  |   |
+---+--+   |
 `. | -1`. |
   `+------+
"""
for x in xrange(k):
    for y in xrange(len(plates[x])):
        for z in xrange(len(plates[x][y])):
            # Make an entry into the adjacents dictionary
            # for every n layers of a parallelpiped.
            adjacents[(x,y,z)] = []
            for transform in transforms:
                nx = x + transform[0]
                ny = y + transform[1]
                nz = z + transform[2]
                if ok(nx, ny, nz):
                    adjacents[(x,y,z)].append((nx,ny,nz))

"""BFS of the plates using a stack.

Guaranteed tap coordinates to be a '.'
"""

stack = []
stack.append((0, start_x - 1, start_y - 1))

while stack:
    current = stack.pop()
    visited[current] = True
    for con in adjacents[current]:
        x, y, z = con
        if not con in visited and plates[x][y][z] == ".":
            stack.append(con)

print(len(visited))

