#! /usr/bin/env python
# -*- coding: utf-8 -*-
import sys
sys.setrecursionlimit(10000)

def solve(k, n, m, pp, x, y):
    count = [0] 
    def dfs(cz, cx, cy):

        pp[cz][cx][cy] = '#'
        # count += 1
        count[0] += 1

        if cx - 1 >= 0:
            if pp[cz][cx - 1][cy] == '.':
                dfs(cz, cx - 1, cy)
        if cx + 1 < n:
            if pp[cz][cx + 1][cy] == '.':
                dfs(cz, cx + 1, cy)
        if cy - 1 >= 0:
            if pp[cz][cx][cy - 1] == '.':
                dfs(cz, cx, cy - 1)
        if cy + 1 < m:
            if pp[cz][cx][cy + 1] == '.':
                dfs(cz, cx, cy + 1)
        if cz - 1 >= 0:
            if pp[cz - 1][cx][cy] == '.':
                dfs(cz - 1, cx, cy)
        if cz + 1 < k:
            if pp[cz + 1][cx][cy] == '.':
                dfs(cz + 1, cx, cy)

    if pp[0][x-1][y-1] == '.':
        dfs(0, x - 1, y - 1)
    return count[0]


def main():

    k, n, m = map(int, raw_input().split())

    pp = []
    for _ in range(k):
        raw_input()
        pp.append([list(raw_input()) for _i in range(n)])

#    pp = [[list(raw_input()) if _i < n else raw_input() for _ in range(m) for _i in range(n + 1)] if _k < k else raw_input() for _k in range(k+1)]
    raw_input()
    x, y = map(int, raw_input().split())

    #print(k, n, m, pp, x, y)
    your_ans = solve(k, n, m, pp, x, y)
    
    print your_ans

if __name__ == '__main__':
    main()
