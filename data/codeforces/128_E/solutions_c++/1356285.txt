#include <cstdio>
#include <cstring>
#include <cmath>

#include <iostream>
#include <algorithm>
#include <map>
#include <string>

using namespace std;
typedef long long LL;
typedef double db;

const db eps = 1e-12;
const db PI = acos(-1.0);
const int oo = 0x7f7f7f7f;
const int Max = 1024;

struct event{
    db x;
    char f;
    event(){}
    event(db x,char f):x(x),f(f){}
    bool operator <(const event &e)const {
        if (fabs(x - e.x) < eps) return f < e.f;
        return x < e.x;
    }
};

event evt1[Max * 4];
int X[Max],Y[Max],R[Max];

int sign(db x){return (x > eps) - (x < -eps);}
db sqr(db x){return x * x;}
db dis(int i,int j){
    return sqrt(sqr(X[i] - X[j]) + sqr(Y[i] - Y[j]));
}
db G(db x){
    if (x > 1.0 - eps) x = 1.0;
    if (x < -1.0 + eps) x = -1.0;
    return x;
}
db adjust(db x){
    while (x > PI - eps) x -= PI * 2;
    while (x < -PI - eps) x += PI * 2;
    return x;
}

int main(){
    int N,K;
    while (scanf("%d%d",&N,&K) != EOF){
        for (int i = 0;i < N;i++)
            scanf("%d%d%d",&X[i],&Y[i],&R[i]);
        int md = 0;
        for (int i = 0;i < N;i++){
            int en1 = 0,c1 = 0;
            for (int j = 0;j < N;j++)if (i != j){
                db d = dis(i,j);
                db f = atan2(Y[j] - Y[i] + 0.0,X[j] - X[i] + 0.0);
                db g = PI * 0.5 + asin(G((R[j] - R[i]) / d));
                db p1 = adjust(f - g);
                db q2 = adjust(f + g);
                db h = acos(G((R[i] + R[j]) / d));
                db p2 = adjust(f - h);
                db q1 = adjust(f + h);
                if (sign(p1 - p2) > 0) ++c1;
                if (sign(q1 - q2) > 0) ++c1;
                evt1[en1++] = event(p1,1);
                evt1[en1++] = event(p2,-1);
                evt1[en1++] = event(q1,1);
                evt1[en1++] = event(q2,-1);
            }
            sort(evt1,evt1 + en1);
            for (int j = 0;j < en1;){
                db x = evt1[j].x;
                while (j < en1 && sign(evt1[j].x - x) == 0 && evt1[j].f == -1)
                    --c1,++j;
                while (j < en1 && sign(evt1[j].x - x) == 0)
                    ++c1,++j;
                md = max(md,c1);
            }
        }
        LL Res = (LL)md * K + (LL)K * (K + 1) / 2 + N;
        cout << Res << endl;
    }
    return 0;
}
