#define _CRT_SECURE_NO_DEPRECATE
#include <algorithm>
#include <string>
#include <set>
#include <map>
#include <vector>
#include <queue>
#include <iostream>
#include <iterator>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <sstream>
#include <fstream>
#include <ctime>
#include <cstring>
#pragma comment(linker, "/STACK:66777216")
using namespace std;
#define pb push_back
#define ppb pop_back
#define pi 3.1415926535897932384626433832795028841971
#define mp make_pair
#define x first
#define y second
#define pii pair<int,int>
#define pdd pair<double,double>
#define INF 1000000000
#define FOR(i,a,b) for (int _n(b), i(a); i <= _n; i++)
#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;i--)
#define all(c) (c).begin(), (c).end()
#define SORT(c) sort(all(c))
#define rep(i,n) FOR(i,1,(n))
#define rept(i,n) FOR(i,0,(n)-1)
#define L(s) (int)((s).size())
#define C(a) memset((a),0,sizeof(a))
#define VI vector <int>
#define ll long long

template<int N> struct rmq {
	int tr[N * 2 + 2];
	int n;
	inline void reset() {
		memset(tr, 63, sizeof(tr));
	}
	inline void upd(int x, int val) {
		x += n;
		tr[x] = min(tr[x], val);
		for (; x /= 2; ) tr[x] = min(tr[x * 2], tr[x * 2 + 1]);
	}
	inline int fnd(int l, int r) {
		int ans = 2 * INF;
		for (l += n, r += n; l <= r; l = (l + 1) / 2, r = (r - 1) / 2) {
			if (l & 1) ans = min(ans, tr[l]);
			if (~r & 1) ans = min(ans, tr[r]);
		}
		return ans;
	}
};
int a,b,c,d,i,j,n,m,k,ans;
pii gn[100001], met[100001];
int ds[100001];

rmq<1 << 18> t1, t2;
int ny[300001];

inline bool cmp(const pair<pii, int> &a, const pair<pii, int> & b) {
	if (a.x.x != b.x.x) return a.x.x < b.x.x; else
	if (a.y != b.y) return a.y < b.y; else
	return a.x.y < b.x.y;
}
void solveMetro(vector<pair<pii, int> > &q) {
	sort(all(q), cmp);
	int k = 0;
	rept(i, L(q)) ny[k++] = q[i].x.y;
	sort(ny, ny + k);
	k = unique(ny, ny + k) - ny;
	t1.n = k; t2.n = k;
	t1.reset(); t2.reset();
	rept(i, L(q)) {
		int cy = lower_bound(ny, ny + k, q[i].x.y) - ny;
		if (q[i].y == -1) {
			t1.upd(cy, -q[i].x.x - q[i].x.y);
			t2.upd(cy, -q[i].x.x + q[i].x.y);
		} else {
			int v1 = t1.fnd(0, cy) + q[i].x.x + q[i].x.y;
			int v2 = t2.fnd(cy, k - 1) + q[i].x.x - q[i].x.y;
			if (v1 < ds[q[i].y]) ds[q[i].y] = v1;
			if (v2 < ds[q[i].y]) ds[q[i].y] = v2;
		}
	}
}
void findClosestMetro() {
	memset(ds, 63, sizeof(ds));
	vector<pair<pii, int> > q;
	rept(i, n) {
		q.pb(mp(gn[i], i));
	}
	rept(i, m) {
		q.pb(mp(met[i], -1));
	}
	solveMetro(q);

	rept(i, L(q)) {
		q[i].x.x = -q[i].x.x;
		q[i].x.y = -q[i].x.y;
	}
	solveMetro(q);
}
inline pii rot(pii t) {
	return mp(t.x + t.y, t.x - t.y);
}

bool check_simple(int d) {
	int x1 = -INF, y1 = -INF, x2 = INF, y2 = INF;
	rept(i, n) {
		x1 = max(x1, gn[i].x - d);
		x2 = min(x2, gn[i].x + d);
		y1 = max(y1, gn[i].y - d);
		y2 = min(y2, gn[i].y + d);
	}
	if (x1 <= x2 && y1 <= y2) return 1; else
	return 0;
}
int simple() {
	int l = -1, r = INF;
	while (r - l > 1) {
		int xx = (r + l) / 2;
		if (check_simple(xx)) r = xx; else
		l = xx;
	}
	return r;
}

pii ord[100001];
pair<pii, pii> rect[100001];
pair<int, pii> ev[300001];
pii bounds[100001];
int fen[300002];
int g;
inline void upd(int x, int val) {
	for (; x <= g; x |= x + 1) fen[x] += val;
}
inline void upd(int l, int r, int val) {
	upd(l, val);
	upd(r + 1, -val);
}
inline int sum(int x) {
	int ans = 0;
	for (; x >= 0; x = (x & (x + 1)) - 1) ans += fen[x];
	return ans;
}
bool inside(int cr) {
	int k = 0, ce = 0;
	rept(i, cr) {
		ny[k++] = rect[i].x.y;
		ny[k++] = rect[i].y.y;
		ev[ce++] = mp(rect[i].x.x, mp(0, i));
		ev[ce++] = mp(rect[i].y.x, mp(2, i));
	}
	rept(i, m) {
		ny[k++] = met[i].y;
		ev[ce++] = mp(met[i].x, mp(1, i));
	}
	sort(ny, ny + k);
	k = unique(ny, ny + k) - ny;
	g = k;
	rept(i, cr) {
		int l = lower_bound(ny, ny + k, rect[i].x.y) - ny;
		int r = lower_bound(ny, ny + k, rect[i].y.y) - ny;
		bounds[i] = mp(l, r);
	}
	sort(ev, ev + ce);
	C(fen);
	rept(i, ce) {
		int v = ev[i].y.y;
		if (ev[i].y.x == 0) {
			upd(bounds[v].x, bounds[v].y, 1);
		} else 
		if (ev[i].y.x == 1) {
			int y = lower_bound(ny, ny + k, met[v].y) - ny;
			if (sum(y)) return 1;
		} else {
			upd(bounds[v].x, bounds[v].y, -1);
		}
	}
	return 0;
}
bool check(int d) {
	if (ord[0].x <= d) return 1;
	if (ord[n - 1].x > d) return 0;
	int x1 = -INF, x2 = INF, y1 = -INF, y2 = INF;
	int cr = 0;
	rept(i, n) {
		if (x1 > x2 || y1 > y2) break;
		int v = ord[i].y;
		if (ord[i].x <= d) {
			int left = d - ord[i].x;
			rect[cr++] = mp(mp(x1 - left, y1 - left), mp(x2 + left, y2 + left));
		}

		x1 = max(x1, gn[v].x - d);
		x2 = min(x2, gn[v].x + d);
		y1 = max(y1, gn[v].y - d);
		y2 = min(y2, gn[v].y + d);
	}
	if (!cr) return 0;
	if (inside(cr)) return 1; else
	return 0;
}
int solve_metro() {
	rept(i, n) ord[i] = mp(ds[i], i);
	sort(ord, ord + n); reverse(ord, ord + n);

	int l = -1, r = INF;
	while (r - l > 1) {
		int xx = (r + l) / 2;
		if (check(xx)) r = xx; else
		l = xx;
	}
	return r;
}
int main() {
	//freopen("input.txt","r",stdin);
	//freopen("output.txt","w",stdout);

	scanf("%d%d", &n, &m);
	if (n == 1) {
		printf("0\n");
		exit(0);
	}
	rept(i, n) scanf("%d%d", &gn[i].x, &gn[i].y);
	rept(i, m) scanf("%d%d", &met[i].x, &met[i].y);

	if (m) findClosestMetro();
	
	rept(i, n) gn[i] = rot(gn[i]);
	rept(i, m) met[i] = rot(met[i]);
	int ans = simple();
	if (!m) {
		printf("%d\n", ans);
		exit(0);
	}

	ans = min(ans, solve_metro());
	printf("%d\n", ans);
}
