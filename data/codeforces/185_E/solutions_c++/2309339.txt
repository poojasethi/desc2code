#include<cstdio>   //���Ե���վ��Զ�ܶ�����
#include<algorithm>
#include<cmath>
#include<cstring>
#include<string>
#include<cstdlib>
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
#define MP(a,b) make_pair(a,b)
#define clr(x,y) memset(x,y,sizeof x)
#define fi first
#define se second
using namespace std;
typedef pair<int,int> PII;
const int oo=1047483647,maxn=100100,L=1000000000;//maxҪ��9��0��8��0������������һ�ӽ�����
struct node
{
	int n,tr[(1<<18)*2+10];    //2*N,N=n+m
	void clean() {clr(tr,63);}  //��ʼֵ̫��һ�ӱ�
	void upd(int x,int v)
	{
		x+=n;
		tr[x]=min(tr[x],v);
		for (;x=x/2;) tr[x]=min(tr[x*2],tr[x*2+1]);
	}
	int  ask(int l,int r)
	{
		int ans=2*L;
		for (l+=n,r+=n;l<=r;l=(l+1)/2,r=(r-1)/2)
		{
			if (l&1) ans=min(ans,tr[l]);
			if (~r&1) ans=min(ans,tr[r]);
		}
		return ans;
	}
}t1,t2;
PII a[maxn*2],b[maxn*2],ord[3*maxn];
pair<PII,int>q[3*maxn];
pair<PII,PII> rec[3*maxn];
pair<int,PII> sd[maxn*3];//������꣬3������
PII ww[maxn*3];
int ny[maxn*3],l,near[maxn*3],ge,w[maxn*3],n,m,f[maxn*3],tot;//3������״����
bool cmp(const pair<PII,int> &a,const pair<PII,int> &b){return ((a.fi.fi<b.fi.fi) || (a.fi.fi==b.fi.fi)&&(a.se<b.se));}
bool checksimple(int d)
{
	int x1,y1,x2,y2;
	x1=y1=-2*L,x2=y2=2*L;
	fo(i,1,n)
	{
		x1=max(a[i].fi-d,x1);
		x2=min(a[i].fi+d,x2);
		y1=max(a[i].se-d,y1);
		y2=min(a[i].se+d,y2);
		if (x1>x2 || y1>y2) return 0;
	}
	return 1;
}
int simple()
{
	int l=0,r=2*L,mid;
	while (l<r)
	{
		mid=(l+r)/2;
		if (checksimple(mid)) r=mid;
		else l=mid+1;
	}
	return l;
}
void work()
{
	sort(q+1,q+l+1,cmp);
	t1.n=t2.n=1<<18;     //2���������
	t1.clean();t2.clean();
	fo(i,1,l)
	w[i]=lower_bound(ny+1,ny+ge+1,q[i].fi.se)-ny;
	fo(i,1,l)
	{
		if (q[i].se==-1)
		{
			t1.upd(w[i],-q[i].fi.fi+q[i].fi.se);
			t2.upd(w[i],-q[i].fi.fi-q[i].fi.se);
		} else
		{
			int v1=t1.ask(w[i],ge)+q[i].fi.fi-q[i].fi.se;
			int v2=t2.ask(1,w[i])+q[i].fi.fi+q[i].fi.se;
			near[q[i].se]=min(near[q[i].se],min(v1,v2));
		}
	}
}
void findclose()
{
	l=0;clr(near,63);
	fo(i,1,n)
	q[++l]=MP(a[i],i);
	fo(i,1,m)
	q[++l]=MP(b[i],-1);
	fo(i,1,l) ny[i]=q[i].fi.se;
	sort(ny+1,ny+1+l);
	ge=unique(ny+1,ny+l+1)-(ny+1);
	work();
	fo(i,1,l) q[i].fi.fi=-q[i].fi.fi;
	work();
}
PII huan(PII &t)
{
	return MP(t.fi+t.se,t.fi-t.se);
}
int sum(int k) {int ans=0;for (;k>0;k-=k&(-k)) ans+=f[k];return ans;}
void add(int k,int v) {for (;k<=ge;k+=k&(-k)) f[k]+=v;}
bool check(int k)
{
	ge=0;tot=0;
	fo(i,1,k)
	{
		ny[++ge]=rec[i].se.fi;
		ny[++ge]=rec[i].se.se;
		sd[++tot]=MP(rec[i].fi.fi,MP(0,i));
		sd[++tot]=MP(rec[i].fi.se,MP(2,i));
	}
	fo(i,1,m)
	{
		ny[++ge]=b[i].se;
		sd[++tot]=MP(b[i].fi,MP(1,i));
	}
	sort(ny+1,ny+ge+1);
	ge=unique(ny+1,ny+ge+1)-(ny+1);
	sort(sd+1,sd+tot+1);
	fo(i,1,tot)
	{
		int w1=lower_bound(ny+1,ny+ge+1,rec[i].se.fi)-ny;
		int w2=lower_bound(ny+1,ny+ge+1,rec[i].se.se)-ny;
		ww[i]=MP(w1,w2);
	}
	clr(f,0);
	fo(i,1,tot)
	{
		int v=sd[i].se.se;
		if (sd[i].se.fi==1)
		{
			int w=lower_bound(ny+1,ny+ge+1,b[v].se)-ny;
			if (sum(w)) return 1;
		} else if (sd[i].se.fi==0)
		{
			add(ww[v].fi,1);add(ww[v].se+1,-1);
		} else
		{
			add(ww[v].fi,-1);add(ww[v].se+1,+1);
		}
	}
	return 0;
}
bool checkhard(int d)
{
	if (ord[1].fi<=d) return 1;
	else if (ord[n].fi>d) return 0;
	int x1,y1,x2,y2,k=0;
	x1=y1=-2*L,x2=y2=2*L;
	fo(i,1,n)
	{
        if (x1>x2 || y1>y2) break;   //ֻ��break����return
        int v=ord[i].se;
		if (ord[i].fi<=d)
		{
			int left=d-ord[i].fi;
			rec[++k]=MP(MP(x1-left,x2+left),MP(y1-left,y2+left));
		}
		x1=max(a[v].fi-d,x1);  //v!!
		x2=min(a[v].fi+d,x2);
		y1=max(a[v].se-d,y1);
		y2=min(a[v].se+d,y2);
	}
	if (!k) return 0;
	else return check(k);
}
int hard()
{
	fo(i,1,n) ord[i]=MP(near[i],i);
	sort(ord+1,ord+n+1);reverse(ord+1,ord+n+1);
	int l=0,r=2*L,mid;
	while (l<r)
	 {
		mid=(l+r)/2;
		if (checkhard(mid)) r=mid;
		else l=mid+1;
	}
	return l;
}
int main()
{
	//freopen("1.in","r",stdin);
	//freopen("1.out","w",stdout);
	scanf("%d%d",&n,&m);
	fo(i,1,n) scanf("%d%d",&a[i].fi,&a[i].se);
	fo(i,1,m) scanf("%d%d",&b[i].fi,&b[i].se);
	if (m)
	findclose();
	fo(i,1,n) a[i]=huan(a[i]);
	fo(i,1,m) b[i]=huan(b[i]);     //���ÿ��n��m��
	int ans=simple();
	if (!m) printf("%d\n",ans);
	else
	{
		ans=min(hard(),ans);
		printf("%d\n",ans);
	}
	return 0;
}
