#include <cstdio>
#include <cstring>
#include <queue>
#include <vector>
#include <utility>
#include <algorithm>
#include <map>

using namespace std;

const int MaxN = 600;
const int MaxM = MaxN*MaxN;
const int INF = 0x3f3f3f3f;

#define popcnt(a) __builtin_popcount(a)

typedef pair<int,int> PII;

struct Node{
	int v,c,cost,flag;
	Node *nxt,*twin;
}*g[MaxN],pool[MaxM],*tail=pool,*pre[MaxN];
int d[MaxN],flow[MaxN];
int n,m,S,HUB,T,SS,TT;
int a[MaxN];
map<int,PII> opr;

inline void make_edge(int u,int v,int c,int cost,int flag=0){
	tail->v=v;tail->c=c;tail->cost=cost; tail->twin=tail+1;tail->flag=flag;tail->nxt=g[u];g[u]=tail++;
	tail->v=u;tail->c=0;tail->cost=-cost;tail->twin=tail-1;tail->flag=0;   tail->nxt=g[v];g[v]=tail++;
}
int spfa(int S,int T){
	queue<int> q;
	static int inq[MaxN];
	memset(d,0x3f,sizeof(d));d[S]=0;
	memset(flow,0,sizeof(flow));flow[S]=INF;
	memset(pre,0,sizeof(pre));q.push(S);inq[S]=1;
	while(!q.empty()){
		int u=q.front();q.pop();inq[u]=0;
		for(Node *p=g[u];p;p=p->nxt) if(p->c && p->cost+d[u]<d[p->v]){
			d[p->v]=d[u]+p->cost;flow[p->v]=min(flow[u],p->c);pre[p->v]=p;
			if(!inq[p->v]) q.push(p->v),inq[p->v]=1;
		}
	}
	return d[T]<INF;
}
int aug(int S,int T){
	int dt=flow[T]*d[T];
	for(Node *p=pre[T];p;p=pre[p->twin->v]) p->c-=flow[T],p->twin->c+=flow[T];
	return dt;
}
int costFlow(int S,int T){
	int res=0;
	while(spfa(S,T)) res+=aug(S,T);
	return res;
}

int vis[MaxN],tot;

void dfs(int num,int u){
	vis[u]=1;
	for(Node *p=g[u+n];p;p=p->nxt)
		if(p->flag && !p->c && !vis[p->v]){
			opr[p->v]=PII(num,a[u]!=a[p->v]);
			tot+=1+(a[u]!=a[p->v]);
			dfs(num,p->v);
		}
}
int main()
{
	scanf("%d%d",&n,&m);
	S=0;HUB=n*2+1;T=n*2+2;SS=n*2+3;TT=n*2+4;
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	make_edge(S,HUB,m,0);make_edge(T,S,INF,0);
	for(int i=1;i<=n;i++) make_edge(HUB,i,1,popcnt(a[i])),make_edge(i+n,T,1,0),make_edge(SS,i+n,1,0),make_edge(i,TT,1,0);
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
			make_edge(i+n,j,1,a[i]==a[j] ? 0 : popcnt(a[j]),1);
	int res=costFlow(SS,TT);
	//res+=costFlow(S,T);
	int cnt=0;
	for(int i=1;i<=n;i++) if(!vis[i]) opr[i]=PII(++cnt,1),tot+=2,dfs(cnt,i);
	printf("%d %d\n",tot,res);
	for(map<int,PII> :: iterator p=opr.begin();p!=opr.end();p++){
		p->second.second ? printf("%c=%d\n",p->second.first-1+'a',a[p->first]):0;
		printf("print(%c)\n",p->second.first-1+'a');
	}
	return 0;
}
