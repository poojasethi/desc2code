#include<cstdio>
#include<algorithm>
#include<vector>
#include<iostream>
#include<cstring>
#include<cassert>
using namespace std;
//Using Disjoint Set and DFS to solve
typedef long long int64;
struct edge
{
	int u,v,d,idx,pu,pv;
	edge(int U,int V,int D,int IDX) {
		u = U,v = V,d = D,idx = IDX;
	}
};

bool operator < (edge E1,edge E2) {
	return E1.d < E2.d;
}
#define MAXN 100001
vector<edge> V;
int64 ans[MAXN];
int root[MAXN], parent[MAXN], treesz[MAXN];
vector<int> Adj[MAXN];
bool visited[MAXN];

int find(int u)
{
	return parent[u] = parent[u]!=u?find(parent[u]):u;
}

void dfs(int node,int par)
{
	visited[node] = 1;
	
	if(par != -1)
	{
		//merging disjoint sets
		root[node] = root[par];
	}
	for(int i=0;i<Adj[node].size();i++)
	{
		int child = Adj[node][i];
		if(child != par)
		{
			dfs(child,node);
			treesz[node] += treesz[child];
		}
	}
}
int main()
{
	int N;
	scanf("%d",&N);
	
	for(int i=1;i<=N;i++)
	parent[i] = i, treesz[i] = 1,root[i] = i;
	
	for(int i=0;i<N-1;i++)
	{
		int u,v,d;
		scanf("%d %d %d",&u,&v,&d);
		V.push_back(edge(u,v,d,i));
	}
	
	sort(V.begin(),V.end());
	int64 mx = 0,mcnt = 0;
	
	//start solving
	for(int i=0,j=0;i<N-1;i=j)
	{
		while(j<N-1 && V[j].d == V[i].d)j++;
		//solve from [i,j) at once
		for(int x=i;x<j;x++)
		{
			int u = V[x].u, v = V[x].v;
			V[x].pu = find(u), V[x].pv = find(v);
			u = V[x].pu, v = V[x].pv;
			visited[u] = visited[v] = 0;
			
			Adj[u].push_back(v);
			Adj[v].push_back(u);
		}
		for(int x=i;x<j;x++)
		{
			int u = V[x].pu;
			if(!visited[u])
			{
				dfs(u,-1);
				Adj[u].clear();//wiping out contracted graph info
			}
		}
		//update answers
		for(int x=i;x<j;x++)
		{
			int u = V[x].pu, v = V[x].pv;
			assert(root[u] == root[v]);
			
			int total = treesz[root[u]];
			int below;
			if(treesz[u] > treesz[v])
			below = treesz[v];
			else
			below = treesz[u];
			
			ans[V[x].idx] = (int64) 2 * below * (total - below);
			
			if(mx < ans[V[x].idx])
			mx = ans[V[x].idx], mcnt = 1;
			else if(mx == ans[V[x].idx])
			mcnt += 1;
		}
		
		for(int x=i;x<j;x++)
		{
			int u = V[x].pu, v = V[x].pv;
			parent[u] = root[u];
			parent[v] = root[v];
		}
		
	}
	//finished solving
	cout << mx << " " << mcnt << endl;
	for(int i=0;i<N-1;i++)
	if(ans[i] == mx)
	printf("%d ",(i+1));
	printf("\n");
	
	return 0;
}
