#include <cstdio>
#include <algorithm>
#define LL long long int
#define N 100005
using namespace std;

struct edge{
	int x,y,l,t;
	LL AC;
	bool operator < (const edge&T) const {
		return l<T.l;
	}
}E[N];

int n,x,y,a,b,l[N],qd[2*N],qn[2*N],p[N];
int ta[N],tb[N],f[N],v[N],t,A[N],cnt=0,CE=0;
LL s[N],dp[N],AC,w;

void bd(int x,int y){
	qd[++CE]=y;
	qn[CE]=l[x];
	l[x]=CE;
}

void dfs(int x,int y){
	v[x]=1;
	p[x]=y;	
	for (int k=l[x];k;k=qn[k])
		if (!v[qd[k]]){
			dfs(qd[k],y);
			dp[x]+=dp[qd[k]];
		}
	dp[x]+=s[x];
}

int find(int x){
	if (x==f[x]) return x;
	else return f[x]=find(f[x]);
}

int main(){
	scanf("%d",&n);
	for (int i=0;i<n-1;i++){
		scanf("%d%d%d",&E[i].x,&E[i].y,&E[i].l);
		E[i].t=i;
	}
	sort(E,E+n-1);
	
	for (int i=1;i<=n;i++){
		f[i]=i;
		s[i]=1;
	}
	
	for (int i=0;i<n-1;){
		
		x=i;
		while (i+1<n-1 && E[i+1].l==E[i].l) i++;
		y=i;
		CE=0;
		
		for (int j=x;j<=y;j++){
			ta[j]=a=find(E[j].x);
			tb[j]=b=find(E[j].y);
			v[a]=v[b]=0;
			l[a]=l[b]=0;
			p[a]=p[b]=0;
			dp[a]=dp[b]=0;
		}
		
		for (int j=x;j<=y;j++){
			bd(ta[j],tb[j]);
			bd(tb[j],ta[j]);
		}
		
		for (int j=x;j<=y;j++)
			if (!v[ta[j]])
				dfs(ta[j],ta[j]);
		
		for (int j=x;j<=y;j++){
			
			w=min(dp[ta[j]],dp[tb[j]]);
			
			E[j].AC=2*w*(dp[p[ta[j]]]-w);
			
			if (E[j].AC>AC) AC=E[j].AC;			
			
			a=find(E[j].x);
			b=find(E[j].y);
			
			s[a]+=s[b];
			f[b]=a;
		}
		
		
		i++;
	}
	
	for (int i=0;i<n-1;i++)
		if (E[i].AC==AC) A[cnt++]=E[i].t;
	sort(A,A+cnt);
	printf("%I64d %d\n",AC,cnt);
	for (int i=0;i<cnt;i++)
		printf("%d%c",A[i]+1,i==cnt-1?'\n':' ');
	
	scanf("\n");
	return 0;
}
