#include <cstdio>
#include <algorithm>
#include <utility>
#include <vector>
using namespace std;

typedef long long LL;
typedef pair<int, int> pii;

struct Edge {
    int u, v, w, i;
};

inline bool operator<(const Edge& x, const Edge& y)
{
    return x.w < y.w;
}

const int N = 100003;
Edge e[N];
int p[N];
int sz[N];

int find(int x)
{
    if(x != p[x])
        p[x] = find(p[x]);
    return p[x];
}

void merge(int u, int v)
{
    u = find(u);
    v = find(v);
    p[u] = v;
    sz[v] += sz[u];
}

vector<pii> adj[N];
int ts[N];
LL val[N];

void dfs(int u, int p)
{
    ts[u] = sz[u];
    while(!adj[u].empty()) {
        int v = adj[u].back().first;
        int i = adj[u].back().second;
        adj[u].pop_back();
        if(v == p) continue;
        dfs(v, u);
        ts[u] += ts[v];
        val[i] = ts[v];
    }
}

int main()
{
    int n;
    scanf("%d", &n);
    int m = n-1;
    for(int i = 0; i < m; ++i) {
        scanf("%d%d%d", &e[i].u, &e[i].v, &e[i].w);
        e[i].i = i;
    }
    sort(e, e + m);
    
    for(int i = 1; i <= n; ++i) {
        p[i] = i;
        sz[i] = 1;
    }
    
    for(int i = 0; i < m; ) {
        int j = i;
        while(j < m && e[i].w == e[j].w) {
            e[j].u = find(e[j].u);
            e[j].v = find(e[j].v);
            adj[e[j].u].push_back(pii(e[j].v, e[j].i));
            adj[e[j].v].push_back(pii(e[j].u, e[j].i));
            ++j;
        } 
        
        for(int k = i; k < j; ++k)
            dfs(e[k].u, 0);
        for(int k = i; k < j; ++k)
            merge(e[k].u, e[k].v);
        while(i < j) {
            val[e[i].i] = 2 * val[e[i].i] * (sz[find(e[i].u)] - val[e[i].i]);
            ++i;
        }
    }
    
    LL res = *max_element(val, val + m);
    vector<int> v;
    for(int i = 0; i < m; ++i)
        if(val[i] == res)
            v.push_back(i+1);
    printf("%lld %d\n", res, (int)v.size());
    for(int i = 0; i < (int)v.size(); ++i) {
        if(i) printf(" ");
        printf("%d", v[i]);
    }
    printf("\n");    
    return 0;
}
