#include<iostream>
#include<vector>
#include<algorithm>
#include<map>
#include<set>
using namespace std;
typedef long long LL;
const int MAX_N = int(1e5)+10;
map <LL, vector < pair< pair<int, int>, int> > > roads;

int parent[MAX_N], sz[MAX_N];
int find(int x)
{
  return (x==parent[x])?x:parent[x]=find(parent[x]);
}
long long ans[MAX_N];
vector< pair <int, int> > G[MAX_N];
vector<int> edges;
int dfs(int x, int par, int id)
{
  int cnt = sz[x];
  for (int i = 0; i < G[x].size(); i++) {
    if (G[x][i].first == par) continue;
    edges.push_back(G[x][i].second);
    cnt += dfs(G[x][i].first, x, G[x][i].second);
  }
  G[x].clear();
  return ans[id] = cnt;
}
int main()
{
  int N, a, b;
  LL d;
  cin>>N;
  for (int i = 1; i <= N; i++) parent[i] = i, sz[i] = 1;
  for (int i = 1; i <= N-1; i++) {
    cin>>a>>b>>d;
    roads[d].push_back(make_pair(make_pair(a,b),i));
  }
  for (__typeof(roads.begin()) r = roads.begin(); r != roads.end(); r++) {
    set<int> v;
    vector < pair< pair<int, int>, int> > &c = r->second;
    for (int i = 0; i < c.size(); i++) {
	int x = find(c[i].first.first), y = find(c[i].first.second);
	int id = c[i].second;
	G[x].push_back(make_pair(y, id));
	G[y].push_back(make_pair(x, id));
	v.insert(x);
	v.insert(y);
    }
    for (__typeof(v.begin()) x = v.begin(); x != v.end(); x++) if (!G[*x].empty()) {
	int total = dfs(*x, 0, 0);
	for (int i = 0; i < edges.size(); i++)
	  ans[edges[i]] = 2*(total-ans[edges[i]])*ans[edges[i]];
	edges.clear();
      }
    for (int i = 0; i < c.size(); i++) {
      int x = find(c[i].first.first), y = find(c[i].first.second);
      int id = c[i].second;
      if (sz[x] > sz[y]) sz[parent[y] = x] += sz[y];
      else sz[parent[x] = y] += sz[x];
    }
  }
  long long btrees = 0, broads = 0;
  for (int i = 1; i <= N-1; i++) if (btrees < ans[i]) btrees = ans[i];
  for (int i = 1; i <= N-1; i++) if (btrees == ans[i]) broads++;
  cout<<btrees<<" "<<broads<<endl;
  for (int i = 1; i <= N-1; i++) if (btrees == ans[i]) cout<<i<<" ";cout<<endl;
  return 0;
}

