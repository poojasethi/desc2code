#include<cstdio>
#include<algorithm>
#include<vector>

using namespace std;

#define long long long

const int MAX_N = 100005;

int n, m;
int level[MAX_N];

struct Edge{
  int u, v, w;
  int ind;
  bool operator < (const Edge &o) const{
    return w != o.w?  w < o.w: level[v] > level[o.v];
  }
};

Edge e[MAX_N];
vector<int> adj[MAX_N];

inline void leveling(int u, int p){
  for(int i = 0; i < (int)adj[u].size(); i++){
    Edge &x = e[adj[u][i]];
    if(p == (u == x.u? x.v: x.u)){
      continue;
    }
    if(u == x.v){
      swap(x.u, x.v);
    }
    level[x.v] = level[x.u] + 1;
    leveling(x.v, x.u);
  }
}

int par[MAX_N];
int sz[MAX_N];
int down_sz[MAX_N];

inline int find_par(int x){
  return x == par[x]? x: par[x] = find_par(par[x]);
}

inline void integrate(int u, int v){
  int t = sz[find_par(u)];
  par[find_par(u)] = find_par(v);
  sz[find_par(v)] += t;
}

long trees[MAX_N];

int main(){
  scanf("%d", &n);
  for(int i = 0; i < n - 1; i++){
    scanf("%d %d %d", &e[i].u, &e[i].v, &e[i].w);
    e[i].ind = i;
    adj[--e[i].u].push_back(i);
    adj[--e[i].v].push_back(i);
  }
  leveling(0, -1);
  for(int i = 0; i < n; i++){
    par[i] = i;
    sz[i] = 1;
  }
  sort(e, e + n - 1);
  for(int i = 0; i < n - 1; i++){
    down_sz[i] = sz[find_par(e[i].v)];
    integrate(e[i].u, e[i].v);
    if(e[i].w != e[i + 1].w){
      for(int j = i; j >= 0 and e[j].w == e[i].w; j--){
	trees[e[j].ind] = (long)down_sz[j] * (long)(sz[find_par(e[j].u)] - down_sz[j]);
      }
    }
  }
  long Max = -1;
  vector<int> ans;
  for(int i = 0; i < n - 1; i++){
    if(trees[i] > Max){
      Max = trees[i];
      ans.clear();
    }
    if(trees[i] == Max){
      ans.push_back(i);
    }
  }
  printf("%I64d %d\n", Max * 2, (int)ans.size());
  for(int i = 0; i < (int)ans.size(); i++){
    printf("%d ", ans[i] + 1);
  }
}
