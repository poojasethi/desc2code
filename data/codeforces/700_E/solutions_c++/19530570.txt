#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
#define maxn 200005
#define maxsq 20
#define pi pair<int,int>
#define mp(a,b) make_pair(a,b)
#define fi first
#define se second
#define oo 1e9
#define minn(a,b) (((a) < (b)) ? a : b)
#define maxx(a,b) (((a) > (b)) ? a : b)
using namespace std;

int n;

char s[maxn];

int x[maxn],y[maxn],wss[maxn],wv[maxn],rank[maxn],sa[maxn],height[maxn];

int rmq[maxn][maxsq],lg[maxn];

pi tree1[maxn * 4],tree2[maxn * 4];

int S,T,ans;

void Read_in(){
	scanf("%d",&n);
	fo(i,1,n) {
		char c=getchar();
		while (c<'a' || c>'z') c=getchar();
		s[i]=c;
	}
}

bool cmp(int *rank,int i,int j,int k){
	return rank[i]==rank[j] && rank[i+k]==rank[j+k];
}

void SA(){
	int i,j,m='z'+1,p;
	fo(i,1,n) wss[x[i]=s[i]]++;
	fo(i,1,m) wss[i]+=wss[i-1];
	fo(i,1,n) sa[wss[x[i]]--]=i;
	for(j=1,p=0;p<n;m=p,j*=2){
		for(p=0,i=n-j+1;i<=n;i++) y[++p]=i;
		for(i=1;i<=n;i++) if (sa[i]>j) y[++p]=sa[i]-j;
		for(i=1;i<=n;i++) wv[i]=x[y[i]];
		for(i=1;i<=m;i++) wss[i]=0;
		for(i=1;i<=n;i++) wss[wv[i]]++;
		for(i=1;i<=m;i++) wss[i]+=wss[i-1];
		for(i=n;i;i--) sa[wss[wv[i]]--]=y[i];
		swap(x,y);
		for(x[sa[1]]=1,p=1,i=2;i<=n;i++)
			x[sa[i]]=cmp(y,sa[i-1],sa[i],j) ? p : ++p;
	}
}

void get_height(){
	fo(i,1,n) rank[sa[i]]=i;
	int k=0,j;
	for(int i=1;i<=n;height[rank[i++]]=k)
		for(k ? k-- : k,j=sa[rank[i]-1];s[i+k]==s[j+k];k++);
}

void get_rmq(){
	lg[1]=0;
	fo(i,2,n) lg[i]=lg[i / 2]+1;
	fo(i,1,n) rmq[i][0]=height[i];
	fo(i,1,lg[n]) 
		fo(j,1,n-(1 << i)+1) rmq[j][i]=minn(rmq[j][i-1],rmq[j+(1 << (i-1))][i-1]);
}

void build(int v,int l,int r){
	tree1[v]=mp(0,0);
	tree2[v]=mp(oo,0);
	if (l==r) return;
	int mid=(l+r) >> 1;
	build(v << 1,l,mid);
	build(v << 1 | 1,mid+1,r);
}

pi query1(int v,int l,int r,int x){
	if (l==r) return tree1[v];
	int mid=(l+r) >> 1;
	if (x<=mid) return max(tree1[v],query1(v << 1,l,mid,x));
	else return max(tree1[v],query1(v << 1 | 1,mid+1,r,x));
}

pi query2(int v,int l,int r,int x,int y){
	if (l==x && r==y) return tree2[v];
	int mid=(l+r) >> 1;
	if (y<=mid) return query2(v << 1,l,mid,x,y);
	else if (x>mid) return query2(v << 1 | 1,mid+1,r,x,y);
	else return min(query2(v << 1,l,mid,x,mid),query2(v << 1 | 1,mid+1,r,mid+1,y));
}

void change1(int v,int l,int r,int x,int y,int xx,int yy){
	if (l==x && r==y) {
		tree1[v]=max(tree1[v],mp(xx,yy));
		return;
	}
	int mid=(l+r) >> 1;
	if (y<=mid) change1(v << 1,l,mid,x,y,xx,yy);
	else if (x>mid) change1(v << 1 | 1,mid+1,r,x,y,xx,yy);
	else change1(v << 1,l,mid,x,mid,xx,yy),change1(v << 1 | 1,mid+1,r,mid+1,y,xx,yy);
}

void change2(int v,int l,int r,int x,int y){
	if (l==r) {
		tree2[v]=mp(y,x);
		return;
	}
	int mid=(l+r) >> 1;
	if (x<=mid) change2(v << 1,l,mid,x,y);
	else change2(v << 1 | 1,mid+1,r,x,y);
	tree2[v]=min(tree2[v << 1],tree2[v << 1 | 1]);
}

int getmin(int x,int y){
	int len=y-x+1;
	int w=lg[len];
	return minn(rmq[x][w],rmq[y-(1 << w)+1][w]);
}

void getw(int x,int len){
	S=T=x;
	int l=1,r=x-1;
	while (l<=r) {
		int mid=(l+r) >> 1;
		if (getmin(mid+1,x)>=len) {
			r=mid-1;
			S=mid;
		}
		else l=mid+1;
	}
	l=x+1;
	r=n;
	while (l<=r) {
		int mid=(l+r) >> 1;
		if (getmin(x+1,mid)>=len) {
			l=mid+1;
			T=mid;
		}
		else r=mid-1;
	}
}

int main(){
	Read_in();
	SA();
	get_height();
	get_rmq();
	build(1,1,n);
	fd(i,n,1) {
		int wz=rank[i];
		pi now=query1(1,1,n,wz);
		int nowans=now.fi,nowlen=now.se;
		if (nowlen) {
			getw(wz,nowlen);
			nowlen+=sa[query2(1,1,n,S,T).se]-i;
			nowans++;
		}
		else nowans=nowlen=1;
		change2(1,1,n,wz,i);
		getw(wz,nowlen);
		change1(1,1,n,S,T,nowans,nowlen);
		ans=maxx(ans,nowans);
	}
	printf("%d",ans);
	return 0;
}