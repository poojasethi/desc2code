#include <bits/stdc++.h>

using namespace std;

#define pb push_back
#define sag (k + k + 1)
#define sol (k + k)
#define endl '\n'
#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)
#define mp make_pair
#define nd second
#define st first
#define type(x) __typeof(x.begin())

typedef pair < int ,int > pii;

typedef long long ll;

const long long linf = 1e18+5;
const int mod = (int) 1e9 + 7;
const int logN = 17;
const int inf = 1e9;
const int N = 2e6 + 50;
const int K = 1e6 + 5;

int x, y, q, n, m, mxx, mxy;
ll fx[N], fy[N];
int mnx, mny;
ll X[N], Y[N];
char s[N];
map< ll , int > H, H2;

int main() {
	scanf("%d %d %d", &q, &n, &m);
	int x = 0, y = 0;
	int mxx = 0, mnx = 0, mny = 0, mxy = 0;
	FOR(i, 0, N-1) fx[i] = fy[i] = linf; 
	FOR(i, 1, q) {
		fx[x+K] = min(fx[x+K], (ll)i-1);
		fy[y+K] = min(fy[y+K], (ll)i-1);
		mxx = max(mxx, x);
		mnx = min(mnx, x);
		mxy = max(mxy, y);
		mny = min(mny, y);
		scanf(" %c", &s[i]);
		char c = s[i];
		if(c == 'R') y++;
		if(c == 'U') x--;
		if(c == 'D') x++;
		if(c == 'L') y--;
	}
	ll ans = 0;

	FOR(i, 1, n) {
		ll bas = 0, son = inf;
		ll mx1 = linf;
		if(x >= 0 && i + mnx >= 1) ;
		else {
			if(x < 0)
				while(bas < son) {
					ll orta = bas + son >> 1ll;
					if(i + x * orta + mnx < 1) son = orta;
					else bas = orta + 1;
			}
			else 
				bas = 0;
			ll left = -i - bas * x;
			if(abs(left) <= 500000) 
				mx1 = fx[left + K] + q * bas;
		}
		ll mx2 = linf;
		bas = 0, son = inf;
		if(x <= 0 && i + mxx <= n) ;
		else {
			if(x > 0) 
				while(bas < son) {
					ll orta = bas + son >> 1ll;
					if(i + x * orta + mxx > n) son = orta;
					else bas = orta + 1;
				}
			else bas = 0;
			ll left = (n - i + 1) - bas * x;
			if(abs(left) <= 500000) 
			mx2 = fx[left + K] + q * bas;
		}
		X[i] = min(mx1, mx2);
		if(X[i] < N) H[X[i]]++;
	}
	FOR(i, 1, m) {
		ll bas = 0, son = inf;
		ll mx1 = linf;
		if(y >= 0 && i + mny >= 1) ;
		else {
			if(y < 0)
				while(bas < son) {
					ll orta = bas + son >> 1ll;
					if(i + y * orta + mny < 1) son = orta;
					else bas = orta + 1;
				}
			else 
				bas = 0;
			ll left = - i - bas * y;
			if(abs(left) <= 500000) 
			mx1 = fy[left + K] + q * bas;
		}
		ll mx2 = linf;
		bas = 0, son = inf;
		if(y <= 0 && i + mxy <= m) ;
		else {
			if(y > 0)
				while(bas < son) {
					ll orta = bas + son >> 1ll;
					if(i + y * orta + mxy > m) son = orta;
					else bas = orta + 1;
				}
			else bas = 0;
			ll left = (m - i + 1) - bas * y;
			if(abs(left) <= 500000) 
			mx2 = fy[left + K] + q * bas;
		} 
		Y[i] = min(mx1, mx2);
		if(Y[i] < N) H2[Y[i]]++;
	}
	sort(X+1, X+n+1);
	sort(Y+1, Y+m+1);
	int j = m+1, t = 0;
	if(X[n] >= linf && Y[m] >= linf) { cout << -1 << endl; return 0; }
	ROF(i, n, 1) {
		while(j-1 >= 1 && Y[j-1] >= X[i]) { j--; t++; }
		if(X[i] < linf) (ans += (X[i] * (ll) t) % mod) %= mod;
	}
	j = n+1, t = 0;
	ROF(i, m, 1) {
		while(j-1 >= 1 && X[j-1] > Y[i]) { j--; t++; }
		if(Y[i] < linf) (ans += (Y[i] * (ll) t) % mod) %= mod;
	}
	cout << ans << endl;
	return 0;
}
