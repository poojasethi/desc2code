#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <string>
#include <vector>
#include <stack>
#include <queue>
#include <set>
#include <map>
#include <sstream>
#include <complex>
#include <ctime>
#include <cassert>
#include <functional>

using namespace std;

typedef long long ll;
typedef vector<int> VI;
typedef pair<int, int> PII;

#define REP(i,s,t) for(int i=(s);i<(t);i++)
#define FILL(x,v) memset(x,v,sizeof(x))

const int INF = (int)1E9;
const int mod = 1000000007;
#define MAXN 500005

int N, X, Y;
char buf[MAXN];
int mdir[128], dir[4][2] = { -1, 0, 1, 0, 0, -1, 0, 1 };
int dx[4 * MAXN], dy[4 * MAXN], ds[4 * MAXN];
int main() {
	cin >> N >> X >> Y;
	mdir['U'] = 0; mdir['D'] = 1; mdir['L'] = 2; mdir['R'] = 3;
	scanf("%s", buf + 1);
	REP(i, 1, N + 1) {
		int d = mdir[buf[i]];
		dx[i] = dir[d][0];
		dy[i] = dir[d][1];
		ds[i] = 1;
	}
	int ans = 0, x = 0, y = 0, minx = 0, miny = 0, maxx = 0, maxy = 0, step = 0;
	int sx = 0, sy = 0, ss = 0, origN = N;
	REP(i, 1, N + 1) {
		int nx = x + dx[i], ny = y + dy[i];
		sx += dx[i]; sy += dy[i]; ss += ds[i];
		x = nx; y = ny;
		if (abs(x) > X + 1 || abs(y) > Y + 1) break;
		bool brk = nx < minx || nx > maxx || ny < miny || ny > maxy;
		step = (step + ds[i]) % mod;
		if (brk) {
			bool brkx = x < minx || x > maxx;
			int xx = maxx - minx + 1, yy = maxy - miny + 1;
			int sol = 0, cntx = X - xx + 1, cnty = Y - yy + 1;
			if (cntx > 0 && cnty > 0) sol = brkx ? cnty : cntx;
			ans = (ans + (ll)sol * step % mod) % mod;

			dx[N + 1] = sx; dy[N + 1] = sy; ds[N + 1] = ss; N++;

			minx = min(minx, x);
			miny = min(miny, y);
			maxx = max(maxx, x);
			maxy = max(maxy, y);
			sx = sy = ss = 0;
		}
		if (i == origN && x == 0 && y == 0 && maxx - minx + 1 <= X && maxy - miny + 1 <= Y) return puts("-1"), 0;
	}
	cout << ans << endl;
	return 0;
}
