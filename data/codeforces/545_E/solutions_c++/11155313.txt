#include <cstdio>
#include <vector>
#include <utility>
#include <queue>
#include <algorithm>
#define X first
#define Y second
#define LL long long
#define REP(i,n) for (int i=1;i<=n;++i)
#define FOR(i,n) for (__typeof(n.begin())i=n.begin();i!=n.end();++i)
using namespace std;

const int MAXN=600060;
int n,m,x,y,z,u,tot;
int nxt[MAXN];
vector<int> ans;
vector< pair<int,pair<int,int> > > v[MAXN];
pair< pair<int,int>,pair<int,int> > a[MAXN];
LL ans1;
LL d[MAXN];
priority_queue< pair<LL,int> > pq;

int Find(int k) {
	if (nxt[k]==k) return k;
	return nxt[k]=Find(nxt[k]);
}

int main() {
	scanf("%d%d",&n,&m);
	REP(i,m) {
		scanf("%d%d%d",&x,&y,&z);
		v[x].push_back(make_pair(y,make_pair(z,i)));
		v[y].push_back(make_pair(x,make_pair(z,i)));
	}
	scanf("%d",&u);
	REP(i,n) d[i]=19999999999999999ll;
	d[u]=0;
	pq.push(make_pair(0,u));
	while (!pq.empty()) {
		LL dist=-pq.top().X;
		int point=pq.top().Y;
		pq.pop();
		FOR(p,v[point]) if (dist+p->Y.X<d[p->X])
			pq.push(make_pair(-(d[p->X]=dist+p->Y.X),p->X));
	}

	REP(i,n) if (i!=u) {
		int w=1999999999,ww;
		FOR(p,v[i])
			if (d[p->X]+p->Y.X==d[i])
				if (p->Y.X<w) {
					w=p->Y.X;
					ww=p->Y.Y;
				}
		ans1+=(LL)w;
		ans.push_back(ww);
	}
	printf("%I64d\n",ans1);
	FOR(p,ans) printf("%d ",*p);
	return 0;
}