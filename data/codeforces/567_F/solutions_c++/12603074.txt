// In the name of Allah

#include <bits/stdc++.h>
using namespace std;

#define dbg(x) cerr << #x << " = " << (x) << endl;
#define FOR(i,a,b) for (int i = (a); i < (b); i ++)
#define rep(i,n) for (int i = 0; i < (n); i ++)
#define repd(i,n) for (int i = (n); i >= 0; i --)
#define PI 3.14159265358979323846
#define pb push_back
#define mp make_pair
#define X first
#define Y second

typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;

struct rule
{
	int x, y;
	short sign;
};

int n, k;
const int max_n = 35, max_k = 100;
rule List [max_k];
ll dp [2*max_n][2*max_n];
const short Equals = 0, Less = 1, LessOrEquals = 2;
short tmp [2*max_n];

bool check (int a, int b)
{
	rep (i, k)
		if ( List[i].x == a || List[i].y == a || List[i].x == b || List[i].y == b )
		{
			if ( List[i].sign == Equals )
			{
				if ( tmp [List[i].x] != tmp [List[i].y] )
					return false;
			}
			else if ( List[i].sign == Less )
			{
				if ( tmp [List[i].x] >= tmp [List[i].y] )
					return false;
			}
			else if ( List[i].sign == LessOrEquals )
			{
				if ( tmp [List[i].x] > tmp [List[i].y] )
					return false;
			}
		}
	return true;
}

int main()
{
	cin >> n >> k;
	rep (i, k)
	{
		string sign;
		cin >> List[i].x >> sign >> List[i].y;
		List[i].x --, List[i].y --;
		if ( sign == "=" )
			List[i].sign = Equals;
		else if ( sign == "<" )
			List[i].sign = Less;
		else if ( sign == "<=" )
			List[i].sign = LessOrEquals;
		else if ( sign == ">" )
		{
			swap (List[i].x, List[i].y);
			List[i].sign = Less;
		}
		else if ( sign == ">=" )
		{
			swap (List[i].x, List[i].y);
			List[i].sign = LessOrEquals;
		}	
	}
	
	memset (dp, 0, sizeof dp);
	for (int d = 1; d < 2*n; d += 2)
	{	
		rep (i, 2*n)
			tmp [i] = i <= d ? 2 : 0;
		for (int b = 0, e = b+d; e < 2*n; b ++, e ++)
		{
			tmp [b] = tmp [e] = 1;
			if ( check (b, e) )
				dp [b][e] += b+1 < e-1 ? dp [b+1][e-1] : 1;
			tmp [b] = tmp [e] = 2;
	
			if ( b+1 < e )
			{
				tmp [b] = tmp [b+1] = 1;
				if ( check (b, b+1) )
					dp [b][e] += b+2 < e ? dp[b+2][e] : 1;
				tmp [b] = tmp [b+1] = 2;
	
				tmp [e] = tmp [e-1] = 1;
				if ( check (e, e-1) )
					dp [b][e] += b < e-2 ? dp[b][e-2] : 1;
				tmp [e] = tmp [e-1] = 2;
			}
			tmp [b] = 0;
		}
	}
	
	cout << dp [0][2*n-1] << endl;
	
	return 0;
}
