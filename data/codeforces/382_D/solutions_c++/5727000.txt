#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int M[2000][2000],n,m,d0=0,d1=0,point;

vector<string> x(2000);

int dfs(int i,int j,char c) {
  // visit (i,j), direction must be c, return depth
  if (i<0 || i>=n || j<0 || j>=m || x[i][j]!=c) return 0;
  //  cout << "visit " << i << " " << j << endl;
  M[i][j]=1;
  int d=0;
  d = max(d,dfs(i,j-1,'>'));
  d = max(d,dfs(i,j+1,'<'));
  d = max(d,dfs(i-1,j,'v'));
  d = max(d,dfs(i+1,j,'^'));
  return d+1;
};

void update(int d) {
  //  cout << "depth " << d;
  if (d>d0) d1=d0, d0=d;
  else if (d>d1) d1=d;
  //  cout << " -> best " << d0 << " " << d1 << endl;
};

int main () {
  cin >> n >> m;
  for (int i=0; i<n; i++) cin >> x[i];

  for (int i=0; i<n; i++)
    for (int j=0; j<m; j++)
      M[i][j]=0; // cell marks: 0=unmarked, 1=marked

  for (int i=0; i<n; i++)
    for (int j=0; j<m; j++)
      if (x[i][j]=='#') {
	//	cout << "start at " << i << " " << j << " '" << x[i][j] << "'" << endl;
	M[i][j]=1;
	update(dfs(i,j-1,'>'));
	update(dfs(i,j+1,'<'));
	update(dfs(i-1,j,'v'));
	update(dfs(i+1,j,'^'));
      };
  
  bool cycle=false;
  for (int i=0; i<n; i++)
    for (int j=0; j<m; j++)
      if (M[i][j]==0) cycle=true;
  /*
  for (int i=0; i<n; i++) {
    for (int j=0; j<m; j++)
            cout << M[i][j];
    cout << endl;
  }
  */

  if      (cycle)   point=-1;
  else if (d0<=0)   point=0;
  else if (d0==d1)  point=d0+d1;
  else              point=d0+max(d0-1,d1);
  cout << point << endl;

  return 0;
};
