#include<cstdio>
#include<set>
#include<utility>
#define fi first
#define se second
#define fo(i,a,b) for(i=a;i<=b;++i)
#define fd(i,a,b) for(i=a;i>=b;--i)
using namespace std;
const int mn=101000;
typedef long long LL;
typedef pair<int,int> node;
typedef set<node>::iterator ite;
struct list
{
    int tt,la[mn],next[mn*2],y[mn*2],c[mn*2];
    void add(int i,int j,int v){next[++tt]=la[i],la[i]=tt,y[tt]=j,c[tt]=v;}
}e;
set<node>T;
ite it;
LL d[mn],ans,tmp;
int n,Q,m,i,j,k,v,tt,ld;
int f[mn][20],dep[mn],dfn[mn];
char ch;
void dfs(int r)
{
    dfn[r]=++tt;
    if(dep[r]>ld)ld=dep[r];
    for(int p=e.la[r];p;p=e.next[p])
        if(e.y[p]!=f[r][0])
        {
            f[e.y[p]][0]=r,dep[e.y[p]]=dep[r]+1,d[e.y[p]]=d[r]+e.c[p];
            dfs(e.y[p]);
        }
}
int lca(int a,int b)
{
    int i;
    if(dep[a]<dep[b])i=a,a=b,b=i;
    fd(i,ld,0)
        if(dep[f[a][i]]>=dep[b])a=f[a][i];
    if(a==b)return a;
    fd(i,ld,0)
        if(f[a][i]!=f[b][i])a=f[a][i],b=f[b][i];
    return f[a][0];
}
LL cost(int i,int j)
{
    return d[i]+d[j]-2*d[lca(i,j)];
}
int pre(ite it)
{
    if(it==T.begin())return T.rbegin()->se;
    return (--it)->se;
}
int suc(ite it)
{
    ++it;
    if(it==T.end())return T.begin()->se;
    return it->se;
}
int main()
{
    scanf("%d",&n);
    fo(i,1,n-1)
    {
        scanf("%d%d%d",&j,&k,&v);
        e.add(j,k,v),e.add(k,j,v);
    }
    dfs(1);
    for(i=0;(1<<i)<=ld;++i);ld=i;
    fo(j,1,ld)
        fo(i,1,n)
            f[i][j]=f[f[i][j-1]][j-1];
    scanf("%d",&Q);
    while(Q--)
    {
        scanf("%s",&ch);
        if(ch=='?'){printf("%I64d\n",ans/2);continue;}
        scanf("%d",&v);
        if(ch=='-')
        {
            it=T.find(make_pair(dfn[v],v));
            j=pre(it),k=suc(it);
            ans=ans-cost(j,v)-cost(v,k)+cost(j,k);
            T.erase(it);
        }
        else
        {
            it=T.insert(make_pair(dfn[v],v)).first;
            j=pre(it),k=suc(it);
            ans=ans-cost(j,k)+cost(j,v)+cost(v,k);
        }
    }
    return 0;
}