#include<cstdio>
#include<cstring>
#include<stack>
#include<map>
#include<set>
#include<queue>
#include<vector>
#include<iostream>
#include<cmath>
#include<string>
#include<list>
#include<algorithm>

#define foreach(it,X) for(__typeof(X.begin())it=X.begin();it!=X.end();++it)

using namespace std;

const int N = 200000, LOG = 20;
int n, m, tt;
long long ans, d[N]; 
int q[N], dfn[N], dep[N];
int jump[N][LOG];

struct edge {
	int u, v, w;
	edge(int _u, int _v, int _w) : u(_u), v(_v), w(_w) {}
};

vector<edge> E[N];
set<int> S;

void Add_edge(int u, int v, int w) {
	E[u].push_back(edge(u, v, w));
	E[v].push_back(edge(v, u, w));
} 

void dfs(int x, int fa, int de) {
	q[++tt] = x; dfn[x] = tt; dep[x] = de;
	jump[x][0] = fa;
	for (int i = 1; i < LOG; i++)
		jump[x][i] = jump[jump[x][i - 1]][i - 1];
	foreach(i, E[x]) if (!dfn[i -> v])
		d[i -> v] = d[x] + i -> w, dfs(i -> v, x, de + 1);
}

int lca(int x, int y) {
	if (dep[x] < dep[y]) swap(x, y);
	for (int i = LOG - 1; i >= 0; i--) if (dep[jump[x][i]] >= dep[y]) x = jump[x][i];
	if (x == y) return x;
	for (int i = LOG - 1; i >= 0; i--) if (jump[x][i] != jump[y][i])
		x = jump[x][i], y = jump[y][i];
	return jump[x][0];
}

long long dist(int x, int y) {
//	cout << x << " " << y << " " << d[x] + d[y] - 2 * d[lca(x, y)] << endl;
	return d[x] + d[y] - 2 * d[lca(x, y)];
}

int main() {
	cin >> n; 
	for (int i = 1; i < n; i++) {
		int u, v, w;
		scanf("%d %d %d", &u, &v, &w);
		Add_edge(u, v, w); Add_edge(v, u, w);
	}
	dfs(1, 0, 1);
//	cout << lca(3, 3) << endl;
	cin >> m; int tmp;
	for (int i = 0; i < m; i++) {
		getchar(); char ch = getchar(); 
		if (ch == '+') {
			scanf("%d", &tmp);
			if (S.empty()) { S.insert(dfn[tmp]); continue; }
			set<int>::iterator r = S.lower_bound(dfn[tmp]), l;
			if (r == S.end() || r == S.begin()) l = --S.end(), r = S.begin();
			else l = r--;
			ans += dist(q[*l], tmp) + dist(q[*r], tmp) - dist(q[*l],q[*r]);
			S.insert(dfn[tmp]);
		} else if (ch == '-') {
			scanf("%d", &tmp); S.erase(dfn[tmp]);
			if (S.empty()) continue;
			set<int>::iterator r = S.lower_bound(dfn[tmp]), l;
			if (r == S.end() || r == S.begin()) l = --S.end(), r = S.begin();
			else l = r--;
			ans -= dist(q[*l], tmp) + dist(q[*r], tmp) - dist(q[*l],q[*r]);
		} else printf("%I64d\n", ans / 2); 
	}
}
