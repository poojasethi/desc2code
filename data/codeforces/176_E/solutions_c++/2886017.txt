#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <set>
using namespace std;
typedef long long LL;
const int maxn=110000;
int n,Q;

struct Talt{
	int tot;
	struct Tsqy{
		int s,v;Tsqy *l;
		inline void build(Tsqy *_l,int _s,int _v){l=_l,s=_s,v=_v;}
	}*pos[maxn],buf[maxn*2];
	inline void Add(int a,int b,int c){
		buf[tot].build(pos[a],b,c);pos[a]=buf+tot++;
		buf[tot].build(pos[b],a,c);pos[b]=buf+tot++;
	}
}alt;

struct Tlca{
	struct Tsqy{
		int t,f,d;
	}F[maxn];
	int operator ()(int a,int b){
		for(;F[a].t!=F[b].t;a=F[F[a].t].f)
			if(F[F[a].t].d<F[F[b].t].d)swap(a,b);
		return F[a].d<F[b].d?a:b;
	}
}Lca;

namespace Ninit{
	void init(){
		int i,ai,bi,ci;
		scanf("%d",&n);
		for(i=1;i<n;++i){
			scanf("%d%d%d",&ai,&bi,&ci);
			alt.Add(ai,bi,ci);
		}
	}
}

namespace Nsolve{
	int A[maxn],B[maxn];
	bool C[maxn];LL D[maxn];
	struct Tcmp{
		inline bool operator ()(int a,int b){
			return B[a]<B[b];
		}
	};
	LL Tree;
	set<int,Tcmp> Bst;
	namespace Nprep{
		int An,S[maxn],G[maxn];
		void dfs(int x,int f,Tlca::Tsqy *F){
			Talt::Tsqy *p;int i;
			S[x]=1,G[x]=0;
			A[++An]=x,B[x]=An;
			for(p=alt.pos[x];p;p=p->l)if(p->s!=f){
				F[p->s].d=F[x].d+1,F[p->s].f=x,D[p->s]=D[x]+p->v;
				dfs(p->s,x,F);
				S[x]+=S[p->s],(!G[x] || S[G[x]]<S[p->s])?G[x]=p->s:0;
			}
			if(x==1)
				for(i=x;i;i=G[i])F[i].t=x;
			for(p=alt.pos[x];p;p=p->l)
			if(p->s!=f && p->s!=G[x])
				for(i=p->s;i;i=G[i])F[i].t=p->s;
        }
        void solve(){
			Lca.F[1].d=0,dfs(1,0,Lca.F);
		}
	}
	void solve(){
		set<int,Tcmp>::iterator p,q,t;
		int i,ai;char ki[10];
		Nprep::solve();
		
		Tree=0;
		for(cin>>Q;Q;--Q){
			scanf("%s",ki);
			if(ki[0]=='?'){
				if(Bst.size()<2){
					printf("0\n");continue;
				}
				p=Bst.begin(),q=Bst.end(),--q;
				printf("%I64d\n",Tree-D[Lca(*p,*q)]);
			}
			else {
				scanf("%d",&ai);
				if(ki[0]=='+')Bst.insert(ai);
				p=q=t=Bst.find(ai),--p,++q;
				Tree+=(ki[0]=='+'?1:-1)*D[ai];
				if(t!=Bst.begin() && q!=Bst.end())
					Tree+=(ki[0]=='+'?1:-1)*D[Lca(*p,*q)];
				if(t!=Bst.begin())Tree-=(ki[0]=='+'?1:-1)*D[Lca(*p,*t)];
				if(q!=Bst.end())Tree-=(ki[0]=='+'?1:-1)*D[Lca(*t,*q)];
				if(ki[0]=='-')Bst.erase(t);
			}
		}
	}
}

int main(){
	//freopen("A.in","r",stdin);
	Ninit::init();
	Nsolve::solve();
	return 0;
}
