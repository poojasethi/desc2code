#include <cstdio>
#include <algorithm>
#include <iostream>
#include <set>
using namespace std;
typedef long long ll;
const int N_MAX = 100010, K_MAX = 18;
struct Edge {
	int to, len;
	Edge *next;
} edge[N_MAX * 2], *begin[N_MAX];
int edgeCnt = 0;
void addEdge(int u, int v, int l) {
	Edge *e = edge + edgeCnt ++;
	e->to = v, e->next = begin[u], e->len = l;
	begin[u] = e;
}
int anc[N_MAX][K_MAX];
ll dist[N_MAX];
int dep[N_MAX], seq[N_MAX], pos[N_MAX], seqCnt;
int nNode;
void dfs(int x, int d) {
	seq[seqCnt ++] = x;
	pos[x] = seqCnt - 1;
	dep[x] = d;
	for ( int k = 1; k < K_MAX; k ++ )
		anc[x][k] = anc[anc[x][k - 1]][k - 1];
	for ( Edge *e = begin[x]; e; e = e->next ) {
		if ( e->to != anc[x][0] ) {
			anc[e->to][0] = x;
			dist[e->to] = dist[x] + e->len;
			dfs(e->to, d + 1);
		}
	}
}
int lca(int u, int v) {
	if ( dep[u] < dep[v] )
		swap(u, v);
	int delta = dep[u] - dep[v];
	for ( int i = K_MAX - 1; i >= 0; i -- )
		if ( delta & (1 << i) ) 
			u = anc[u][i];
	if ( u == v )
		return u;
	for ( int i = K_MAX - 1; i >= 0; i -- ) 
		if ( anc[u][i] != anc[v][i] )
			u = anc[u][i], v = anc[v][i];
	return anc[u][0];
}
set<int> mySet;
int main() {
	//freopen("t.in", "r", stdin);
	cin >> nNode;
	for ( int i = 0; i < nNode - 1; i ++ ) {
		int a, b, c;
		cin >> a >> b >> c;
		addEdge(a, b, c);
		addEdge(b, a, c);
	}
	dfs(1, 0);
	int nQuery;
	cin >> nQuery;
	ll ans = 0;
	while ( nQuery -- ) {
		char cmd[4];
		cin >> cmd;
		if ( cmd[0] == '?' )
			cout << ans << '\n';
		else {
			int flag = cmd[0] == '+' ? 1 : -1;
			int x;
			scanf("%d", &x);
			set<int>::iterator cur, pred, succ;
			cur = mySet.insert(pos[x]).first;
			pred = succ = cur;
			if ( pred == mySet.begin() ) 
				pred = -- mySet.end();
			else
				pred --;
			succ = cur;
			succ ++;
			if ( succ == mySet.end() )
				succ = mySet.begin();
			ll tmp = dist[x] + dist[lca(seq[*pred], seq[*succ])];
			tmp -= dist[lca(seq[*pred], seq[*cur])];
			tmp -= dist[lca(seq[*succ], seq[*cur])];
			ans += flag * tmp;
			if ( flag == -1 )
				mySet.erase(cur);
		}
	}
}
