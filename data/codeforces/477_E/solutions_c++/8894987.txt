#include<stdio.h>
#include<algorithm>
using namespace std;
const int maxn=400050,maxb=20,INF=1e9;
int bd[maxn];
int n,q,a[maxn];
int minn[maxn][maxb];
inline int get_min(int ll,int rr)
{
	if(ll>rr) swap(ll,rr);
	int t=bd[rr-ll];
	return min(minn[rr][t],minn[ll+(1<<t)-1][t]);
}
struct Query
{
	int id,r1,c1,r2,c2,ans;
	bool z;
	bool operator < (const Query &yy) const { return id<yy.id; }
	void scan(int i)
	{ 
		id=i;
		scanf("%d%d%d%d",&r1,&c1,&r2,&c2);
		if(r1>r2) z=1,r1=n-r1+1,r2=n-r2+1;
		else z=0;
	}
};
Query que[maxn];
int st[maxn],aa[maxn],top=0;
int ts=0,l[maxn*2],r[maxn*2],mn[maxn*2];
bool cmp(const Query &xx,const Query &yy) { return xx.r2<yy.r2; }
inline void update(int x) { mn[x]=min(mn[l[x]],mn[r[x]]); }
void build(int x,int ll,int rr)
{
	if(ll==rr) return ;
	int mid=(ll+rr)>>1;
	build(l[x]=++ts,ll,mid);
	build(r[x]=++ts,mid+1,rr);
}
void modify(int x,int ll,int rr,int pos,int k)
{
	if(ll==rr) { mn[x]=k;return ; }
	int mid=(ll+rr)>>1;
	if(pos<=mid)
		modify(l[x],ll,mid,pos,k);
	else
		modify(r[x],mid+1,rr,pos,k);
	update(x);
}
int query(int x,int ll,int rr,int a,int b)
{
	if(a<=ll&&rr<=b) return mn[x];
	if(ll==rr) return INF;
	int mid=(ll+rr)>>1,s=INF;
	if(a<=mid)
		s=min(s,query(l[x],ll,mid,a,b));
	if(b>mid)
		s=min(s,query(r[x],mid+1,rr,a,b));
	return s;
}
void work(bool c)
{
	int i,j,d,t;
	for(i=1;i<=n;i++)
	{
		minn[i][0]=a[i];
		for(j=0;minn[i][j];j++)
			minn[i][j+1]=min(minn[i][j],minn[i-(1<<j)][j]);
	}
	top=0;
	for(i=0,j=1;i<q;i++)
		if(que[i].z==c)
		{
			int r1=que[i].r1,r2=que[i].r2,c1=que[i].c1,c2=que[i].c2,&ans=que[i].ans,s0=r2-r1+1;
			ans=r2-r1+min(abs(c2-min(get_min(r1,r2),c1)),1+c2);
			for(;j<=r2;j++)
			{
				while(top&&a[st[top]]>=a[j])
					top--;
				st[++top]=j;
				aa[top]=a[j];
				modify(1,1,n,top,a[j]+(n-j)*2);
			}
			int p=upper_bound(st+1,st+1+top,r1)-st;
			d=upper_bound(aa+1,aa+1+top,c1)-aa;
			t=lower_bound(aa+1,aa+1+top,c2)-aa;
			if(t>=p)
				ans=min(ans,s0+a[st[t]]-c2);
			else
			{
				if(r1<r2) ans=min(ans,s0+a[st[p]]-c2);
				if(t>=d)
					ans=min(ans,s0+query(1,1,n,t,p-1)-c2-(n-r1)*2);
				else
				{
					ans=min(ans,s0-1+query(1,1,n,t,min(d,p)-1)-c2-(n-r1)*2);
					if(d<p) ans=min(ans,s0+query(1,1,n,d,p-1)-c2-(n-r1)*2);
				}
			}
			if(t>p) ans=min(ans,s0+c2-a[st[t-1]]);
			else if(t>1) ans=min(ans,s0-(t<=d)+(r1-st[t-1])*2+c2-a[st[t-1]]);
		}
	//for(i=0;i<q;i++) printf("%d ",que[i].ans); printf("\n");
	top=0;
	for(i=q-1,j=n;i>=0;i--)
		if(que[i].z==c)
		{
			int r1=que[i].r1,r2=que[i].r2,c1=que[i].c1,c2=que[i].c2,&ans=que[i].ans,s0=r2-r1+1;
			for(;j>=r2;j--)
			{
				while(top&&a[st[top]]>=a[j]) top--;
				st[++top]=j;
				aa[top]=a[j];
				modify(1,1,n,top,a[j]+j*2);
			}
			d=upper_bound(aa+1,aa+1+top,min(c1,get_min(r1,r2)))-aa;
			t=lower_bound(aa+1,aa+1+top,c2)-aa;
			if(t>=d)
				ans=min(ans,s0+query(1,1,n,t,top-1)-c2-r2*2);
			else
				ans=min(ans,s0+min(-1+query(1,1,n,t,d-1),query(1,1,n,d,top-1))-c2-r2*2);
			if(t>1) ans=min(ans,s0-(t<=d)+(st[t-1]-r2)*2+c2-a[st[t-1]]);
		}
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("data.in","r",stdin);
	freopen("data.out","w",stdout);
#endif
	int i,j;
	for(bd[1]=0,i=2;i<maxn;i<<=1)
		bd[i]=bd[i>>1]+1;
	for(i=3;i<maxn;i++)
		if(!bd[i]) bd[i]=bd[i-1];
	scanf("%d",&n);
	for(i=1;i<=n;i++)
		scanf("%d",&a[i]);
	scanf("%d",&q);
	for(i=0;i<q;i++)
		que[i].scan(i);
	sort(que,que+q,cmp);
	build(++ts,1,n);
	work(0);
	for(i=1;i<=n/2;i++)
		swap(a[i],a[n-i+1]);
	work(1);
	sort(que,que+q);
	for(i=0;i<q;i++)
		printf("%d\n",que[i].ans);
	return 0;
}
