#include<cstdio>
#include<iostream>
#include<queue>
#include<map>
#include<set>
#include<algorithm>
#include<cmath>
#include<cstdlib>
using namespace std;

#define inf 1023456789
#define linf 1023456789123456789ll
#define pii pair<int,int>
#define pipii pair<int, pii >
#define pll pair<long long,long long>
#define vint vector<int>
#define vvint vector<vint >
#define ll long long
#define pdd pair<double, double>

//#define DEBUG
#ifdef DEBUG
#define db(x) cerr << #x << " = " << x << endl
#else
#define db(x)
#endif

int n;
bool otocene = 0;
vint a;
vvint mrq;
vint logg2, moc2;

struct que
{
    int c1, r1, c2, r2;
    que()
    {
    }
    que(int R1, int C1, int R2, int C2)
    {
        r1 = R1;
        c1 = C1;
        r2 = R2;
        c2 = C2;
    }
};

void predrataj()
{
    mrq.push_back(vint(n));
    for(int i=0; i<n; i++)mrq[0][i] = a[i];
    int ind = 0;
    for(int dlz = 2; dlz <= n; dlz *= 2)
    {
        ind++;
        mrq.push_back(vint(n-dlz+1));
        for(int i=0; i+dlz <= n; i++)
        {
            mrq[ind][i] = min(mrq[ind-1][i], mrq[ind-1][i+dlz/2]);
        }
    }
    logg2.resize(n+1);
    logg2[1] = 0;
    moc2.resize(n+1);
    moc2[1] = 1;
    for(int i=2; i<=n; i++)
    {
        logg2[i] = logg2[i/2]+1;
        moc2[i] = moc2[i/2]*2;
    }
}

int obrat(int a)
{
    return n-1-a;
}

int mrqa(int a, int b)
{
    if(otocene)
    {
        a = obrat(a);
        b = obrat(b);
        swap(a,b);
    }
    b++;
    int dlz = b-a;
    return min(mrq[logg2[dlz]][a], mrq[logg2[dlz]][b-moc2[dlz]]);
}

int main()
{
    scanf("%d",&n);
    a.resize(n);
    for(int i=0; i<n; i++)scanf("%d",&a[i]);
    predrataj();
    int q;
    scanf("%d",&q);
    vint ans(q, inf);
    vector<que> query(q);
    vector<pii > udalost;
    
    for(int i=0; i<q; i++)
    {
        int r1, c1, r2, c2;
        scanf("%d %d %d %d",&r1, &c1, &r2, &c2);
        r1--;
        r2--;
        query[i] = que(r1,c1,r2,c2);
        ans[i] = min(ans[i], abs(r2-r1) + abs(c2 - min(c1, mrqa(min(r1,r2),max(r1, r2))))); //nothing
        ans[i] = min(ans[i], abs(r2-r1) + c2 + 1); //home
        
        udalost.push_back(pii(r1, i));
        udalost.push_back(pii(r2, i));
    }
    
    sort(udalost.begin(), udalost.end());
    udalost.push_back(pii(inf, -1));
    
    
    for(int strana = 0; strana < 2; strana++)
    {
        db(strana);
        vector<pii > silny_stack(1, pii(-inf, -1)), slaby_stack(1, pii(-inf, -1));
        int curud = 0;
        for(int i=0; i<n; i++)
        {
            pii pom(a[i], i);
            while(pom.first <= slaby_stack.back().first)slaby_stack.pop_back();
            slaby_stack.push_back(pom);
            while(pom.first <= silny_stack.back().first + 2*(pom.second - silny_stack.back().second))silny_stack.pop_back();
            silny_stack.push_back(pom);
            for(; udalost[curud].first == i; curud++)
            {
                db(i);
                db(a[i]);
                int id = udalost[curud].second;
                que pom = query[id];
                if(i == pom.r1)
                {
                    if(pom.r1 <= pom.r2)
                    {
                        int l=0, u = silny_stack.size();
                        int desired = pom.c2;
                        while(l < u-1)
                        {
                            int mid = (l+u)/2;
                            if(silny_stack[mid].first > desired)u = mid;
                            else l = mid;
                        }
                        for(int j=0; j<2; j++)
                        {
                            if(l+j >= silny_stack.size())break;
                            int posans = 2 * (pom.r1 - silny_stack[l+j].second);
                            if(pom.c1 < silny_stack[l+j].first)posans++;
                            posans += pom.r2 - pom.r1;
                            posans += abs(pom.c2 - min(mrqa(pom.r1, pom.r2), silny_stack[l+j].first));
                            ans[id] = min(ans[id], posans);
                        }
                    }
                    else
                    {
                        continue;
                    }
                }
                else
                {
                    if(pom.r2 < pom.r1)
                    {
                        db("yu");
                        int curc = min(pom.c1, mrqa(pom.r2, pom.r1));
                        int l=0, u = silny_stack.size();
                        db(u);
                        int desired = pom.c2;
                        while(l < u-1)
                        {
                            int mid = (l+u)/2;
                            if(silny_stack[mid].first > desired)u = mid;
                            else l = mid;
                        }
                        db(l);
                        db(silny_stack[l].first);
                        for(int j=0; j<2; j++)
                        {
                            if(l+j >= silny_stack.size())break;
                            int posans = 2 * (pom.r2 - silny_stack[l+j].second);
                            if(curc < silny_stack[l+j].first)posans++;
                            posans += pom.r1 - pom.r2;
                            posans += abs(pom.c2 - silny_stack[l+j].first);
                            db(posans);
                            ans[id] = min(ans[id], posans);
                        }
                    }
                    else
                    {
                        int l = 0, u = slaby_stack.size();
                        int desired = pom.c2;
                        while(l < u-1)
                        {
                            int mid = (l+u)/2;
                            if(slaby_stack[mid].first > desired)u = mid;
                            else l = mid;
                        }
                        for(int j=0; j<2; j++)
                        {
                            if(l+j >= slaby_stack.size())break;
                            if(slaby_stack[l+j].second < pom.r1)continue;
                            int posans = pom.r2 - pom.r1;
                            posans ++;
                            posans += abs(pom.c2 - slaby_stack[l+j].first);
                            ans[id] = min(ans[id], posans);
                        }
                    }
                }
                db(id);
                db(ans[id]);
            }
        }
        
        if(strana == 0)
        {
            udalost.pop_back();
            reverse(udalost.begin(), udalost.end());
            udalost.push_back(pii(-inf, -1));
            for(int i=0; i<udalost.size(); i++)udalost[i].first = obrat(udalost[i].first);
            for(int i=0; i<q; i++)
            {
                query[i].r1 = obrat(query[i].r1);
                query[i].r2 = obrat(query[i].r2);
            }
            reverse(a.begin(), a.end());
            otocene = 1;
        }
    }
    
    for(int i=0; i<q; i++)
    {
        printf("%d\n",ans[i]);
    }
    
    return 0;
}