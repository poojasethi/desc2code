#include <iostream>
#include <fstream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <map>
using namespace std;

const int maxN = 400005;
const int oo = 1000000000;
int n, m, a[maxN];
struct Tpro{
    int x1, y1, x2, y2, id;
}p[maxN];

int tree[4*maxN][4];
int ans[maxN];
int sta[maxN];
int rmq[25][maxN];
int lg[maxN];

void Readln(){
    scanf( "%d\n", &n );
    for (int i=1; i<=n; i++) scanf( "%d", &a[i] );
    scanf( "%d\n", &m );
    for (int i=1; i<=m; i++){
        scanf( "%d%d%d%d\n", &p[i].x1, &p[i].y1, &p[i].x2, &p[i].y2 );
        p[i].id = i;
    }
}

bool cmp(Tpro a, Tpro b){
    return a.x2 < b.x2;
}

bool cmp1(int a, int b){return a<b;}
bool cmp2(int a, int b){return a>b;}

void inserttree(int root, int lef, int rig, int p, int t){
    if (rig < p || p < lef) return;
    if (lef == rig && rig == p){
        if (t == -1){
            for (int i=0; i<4; i++) tree[root][i] = oo;
        }
        if (t == 1){
            tree[root][0] = a[p];
            tree[root][1] = a[p] - 2*p;
            tree[root][2] = - a[p];
            tree[root][3] = -2*p - a[p];
        }
        if (t == 0){
            tree[root][0] = a[p];
            tree[root][1] = a[p] + 2*p;
            tree[root][2] = - a[p];
            tree[root][3] = 2*p - a[p];
        }
        return;
    }
    int mid = (lef+rig)/2;
    inserttree(root*2, lef, mid, p, t);
    inserttree(root*2+1, mid+1, rig, p, t);
    for (int i=0; i<4; i++)
        tree[root][i] = min(tree[root*2][i], tree[root*2+1][i]);
}

int asktree(int root, int lef, int rig, int lo, int hi, int t){
    if (rig < lo || hi < lef) return oo;
    if (lo <= lef && rig <= hi) return tree[root][t];
    int mid = (lef+rig)/2;
    return min(asktree(root*2, lef, mid, lo, hi, t), 
        asktree(root*2+1, mid+1, rig, lo, hi, t));
}

int findsta1(int val, int tot){
    int lef = 0, rig = tot+1;
    while (lef+1 < rig){
        int mid = (lef+rig)/2;
        if (a[sta[mid]] <= val) lef = mid; else rig = mid;
    }
    return sta[lef];
}

int findsta2(int val, int tot){
    int lef = 0, rig = tot+1;
    while (lef+1 < rig){
        int mid = (lef+rig)/2;
        if (sta[mid] <= val) lef = mid; else rig = mid;
    }
    return lef;
}

int findsta3(int val, int tot){
    int lef = 0, rig = tot+1;
    while (lef+1 < rig){
        int mid = (lef+rig)/2;
        if (sta[mid] >= val) lef = mid; else rig = mid;
    }
    return lef;
}

void init(){
    for (int i=1; i<=n; i++) rmq[0][i] = a[i];
    for (int i=1; (1<<i) < n; i++){
        for (int j=1; j+(1<<i)-1 <= n; j++)
        rmq[i][j] = min(rmq[i-1][j], rmq[i-1][j+(1<<(i-1))]);
    }
    int now = 0;
    for (int i=1; i<=n; i++){
        if ((1<<(now+1)) < i) now++;
        lg[i] = now;
    }
}

int getmin(int u, int v){
    if (u > v) swap(u, v);
    int i = lg[v-u+1];
    return min(rmq[i][u], rmq[i][v-(1<<i)+1]);
}

void Solve(){
    sort(p+1, p+1+m, cmp);
    
    for (int i=1; i<=m; i++)
        ans[p[i].id] = abs(p[i].x2-p[i].x1)+1+p[i].y2;
    
    for (int i=1; i<=4*n; i++)
        for (int j=0; j<4; j++) tree[i][j] = oo;
    int now = 1, tot = 1;
    sta[0] = 0; sta[1] = 1;
    inserttree(1, 1, n, 1, 1);
    for (int i=1; i<=m; i++){
        for (int j=now+1; j<=p[i].x2; j++){
            int nv = a[j];
            while (tot > 0 && nv <= a[sta[tot]]){
                inserttree(1, 1, n, sta[tot], -1);
                tot--;
            }
            tot++;
            sta[tot] = j;
            inserttree(1, 1, n, j, 1);
            now++;
        }
        int tmp = getmin(p[i].x1, p[i].x2);
        int mid3 = min(p[i].x1, p[i].x2);
        int mid1 = findsta1(min(tmp, p[i].y1), tot);
        int mid2 = findsta1(p[i].y2, tot);
        
        if (p[i].x1 <= p[i].x2){
            if (tmp >= p[i].y1) 
                ans[p[i].id] = 
                min(ans[p[i].id], abs(p[i].x2-p[i].x1)+abs(p[i].y2-p[i].y1));
        }
        
        int div[5];
        div[1] = mid1; div[2] = mid2; div[3] = mid3;
        sort(div+1, div+1+3, cmp1);
        div[0] = 0; div[4] = p[i].x2;
        for (int j=0; j<4; j++)
        if (div[j] < div[j+1]){
            int c1 = (div[j+1] <= mid1);
            int c2 = (div[j+1] <= mid2);
            int c3 = (div[j+1] <= mid3);
            int ret = asktree(1, 1, n, div[j]+1, div[j+1], c2*2+c3);
            if (c1 == 0) ret++;
            ret += abs(p[i].x1-p[i].x2);
            if (c2 == 1) ret += p[i].y2; else ret -= p[i].y2;
            if (c3 == 1) ret += 2*mid3;
            ans[p[i].id] = min(ans[p[i].id], ret);
        }
    }
    
    for (int i=1; i<=4*n; i++)
        for (int j=0; j<4; j++) tree[i][j] = oo;
    now = n; tot = 1;
    sta[0] = n+1; sta[1] = n;
    inserttree(1, 1, n, n, 0);
    for (int i=m; i>=1; i--){
        for (int j=now-1; j>=p[i].x2; j--){
            int nv = a[j];
            while (tot > 0 && nv <= a[sta[tot]]){
                inserttree(1, 1, n, sta[tot], -1);
                tot--;
            }
            tot++;
            sta[tot] = j;
            inserttree(1, 1, n, j, 0);
            now--;
        }
        int tmp = getmin(p[i].x1, p[i].x2);
        int mid3 = max(p[i].x1, p[i].x2);
        int mid1 = findsta1(min(p[i].y1, tmp), tot);
        int mid2 = findsta1(p[i].y2, tot);
        
        if (p[i].x1 > p[i].x2){
            if (tmp > p[i].y1){
                ans[p[i].id] = 
                min(ans[p[i].id], abs(p[i].x2-p[i].x1)+abs(p[i].y2-p[i].y1));
            }
        }
                
        int div[5];
        div[1] = mid1; div[2] = mid2; div[3] = mid3;
        sort(div+1, div+1+3, cmp2);
        div[0] = n+1; div[4] = p[i].x2;
        for (int j=0; j<4; j++)
        if (div[j] > div[j+1]) {
            int c1 = (div[j+1] >= mid1);
            int c2 = (div[j+1] >= mid2);
            int c3 = (div[j+1] >= mid3);
            int ret = asktree(1, 1, n, div[j+1], div[j]-1, c2*2+c3);
            if (c1 == 0) ret++;
            ret += abs(p[i].x1-p[i].x2);
            if (c2 == 1) ret += p[i].y2; else ret -= p[i].y2;
            if (c3 == 1) ret -= 2*mid3;
            ans[p[i].id] = min(ans[p[i].id], ret);          
        }       
    }
    for (int i=1; i<=m; i++) printf( "%d\n", ans[i] );
}

int main(){
    Readln();
    init();
    Solve();
    return 0;
}