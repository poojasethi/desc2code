def abc(vertices):
    points = []
    points.append((vertices[0]-vertices[2])**2+(vertices[1]-vertices[3])**2)
    points.append((vertices[0]-vertices[4])**2+(vertices[1]-vertices[5])**2)
    points.append((vertices[4]-vertices[2])**2+(vertices[5]-vertices[3])**2)
    points.sort() 
    return points


def almost(vertices, index):
    vertices[index] -= 1
    if (vertices[0] == vertices[2] and vertices[1] == vertices[3]) or (vertices[0] == vertices[4] and vertices[1] == vertices[5]) or (vertices[2] == vertices[4] and vertices[3] == vertices[5]):
        vertices[index] += 1
        return False;  
    if (vertices[0] == vertices[2] and vertices[2] == vertices[4]) or (vertices[1] == vertices[3] and vertices[3] == vertices[5]):
        vertices[index] += 1
        return False
    a,b,c = abc(vertices)
    if (a+b == c):
        return True
    
    vertices[index] += 2
    if (vertices[0] == vertices[2] and vertices[1] == vertices[3]) or (vertices[0] == vertices[4] and vertices[1] == vertices[5]) or (vertices[2] == vertices[4] and vertices[3] == vertices[5]):
        vertices[index] -= 1
        return False;  
    if (vertices[0] == vertices[2] and vertices[2] == vertices[4]) or (vertices[1] == vertices[3] and vertices[3] == vertices[5]):
        vertices[index] -= 1
        return False
    a,b,c = abc(vertices)
    if (a+b == c):
        return True
    
    vertices[index] -= 1
    return False


vertices = map(int, raw_input().split())
def run():
    a,b,c = abc(vertices)
    if a+b == c:
        return "RIGHT"
    for i in xrange(6):
        if almost(vertices, i):
            return "ALMOST"
    return "NEITHER"

print run()
