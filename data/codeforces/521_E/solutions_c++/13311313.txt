#include <cstdio>
#include <cstring>
#include <cctype>
#include <iostream>
#include <algorithm>
//using namespace std;

#define N 200010
#define M 200010
int head[N],next[M<<1],end[M<<1];

void addedge(int a,int b){
	static int q=1;
	end[q]=b;
	next[q]=head[a];
	head[a]=q++;
}
void make(int a,int b){
	addedge(a,b);
	addedge(b,a);
}

bool vis[N];

struct Edge{
	int u,v;
	Edge(){}
	Edge(int _u,int _v):u(_u),v(_v){}
}E[M];

int dep[N],pa[N],pedge[N];
//int col[N],id;
void dfs(int x,int fa){
	vis[x]=1;
	//col[x]=id;
	for(int j=head[x];j;j=next[j]){
		if(!vis[end[j]]){
			dep[end[j]]=dep[x]+1;
			pa[end[j]]=x;
			dfs(end[j],x);
		}
	}
}
int getlca(int x,int y){
	while(x!=y){
		if(dep[x]<dep[y])
			std::swap(x,y);
		x=pa[x];
	}
	return x;
}
int q1[N],q2[N];

struct List{
	int c[N][2],q[N],id;
	void add(int a,int b){
		if(!c[a][0])
			c[a][0]=b;
		else
			c[a][1]=b;
	}
	void make(int a,int b){
		add(a,b);
		add(b,a);
	}
	void dfs(int x,int fa){
		q[++id]=x;
		if(c[x][0]!=fa)
			dfs(c[x][0],x);
		else if(c[x][1]&&c[x][1]!=fa)
			dfs(c[x][1],x);
	}
}p1,p2,p3;
typedef std::pair<int,int> pii;

int main(){
#ifndef ONLINE_JUDGE
	//freopen("tt.in","r",stdin);
#endif
	int n,m,i,j,a,b;
	scanf("%d%d",&n,&m);
	for(i=1;i<=m;++i){
		scanf("%d%d",&a,&b);
		E[i]=Edge(a,b);
		make(a,b);
	}

	for(i=1;i<=n;++i)
		if(!vis[i]){
			//++id;
			dep[i]=1;
			dfs(i,-1);
		}

	bool ok=0;
	int x,y,lca,edgea,edgeb;
	for(i=1;i<=m&&!ok;++i){
		if(pa[E[i].u]!=E[i].v&&pa[E[i].v]!=E[i].u){
			x=E[i].u;
			y=E[i].v;
			lca=getlca(x,y);
			while(x!=lca&&!ok){
				if(pedge[x]!=0){
					ok=1;
					edgea=pedge[x];
					edgeb=i;
					break;
				}
				pedge[x]=i;
				x=pa[x];
			}
			while(y!=lca&&!ok){
				if(pedge[y]!=0){
					ok=1;
					edgea=pedge[y];
					edgeb=i;
					break;
				}
				pedge[y]=i;
				y=pa[y];
			}
		}
	}

	if(!ok)
		puts("NO");
	else{
		puts("YES");
		memset(pedge,0,sizeof pedge);
		x=E[edgea].u,y=E[edgea].v;
		lca=getlca(x,y);
		while(x!=lca){
			p1.make(x,pa[x]);
			pedge[x]=edgea;
			x=pa[x];
		}
		while(y!=lca){
			p1.make(y,pa[y]);
			pedge[y]=edgea;
			y=pa[y];
		}
		p1.dfs(x,-1);
		x=E[edgeb].u,y=E[edgeb].v;
		lca=getlca(x,y);
		pii ans=std::make_pair(-1,0);
		while(x!=lca){
			p2.make(x,pa[x]);
			if(pedge[x]){
				p3.make(x,pa[x]);
				ans=std::max(ans,std::make_pair(dep[x],x));
			}
			x=pa[x];
		}
		while(y!=lca){
			p2.make(y,pa[y]);
			if(pedge[y]){
				p3.make(y,pa[y]);
				ans=std::max(ans,std::make_pair(dep[y],y));
			}
			y=pa[y];
		}
		p2.dfs(x,-1);
		p3.dfs(ans.second,-1);

		printf("%d ",p3.id);
		for(i=1;i<=p3.id;++i)
			printf("%d ",p3.q[i]);
		puts("");
		for(i=1;i<=p1.id;++i)
			if(p1.q[i]==p3.q[1]){
				printf("%d ",p1.id+2-p3.id);
				for(j=1;j<=p1.id+2-p3.id;++j){
					printf("%d ",p1.q[i]);
					i=(--i==0)?p1.id:i;
				}
				break;
			}
			else if(p1.q[i]==p3.q[p3.id]){
				i+=p3.id-1;
				if(i>p1.id)
					i-=p1.id;
				printf("%d ",p1.id+2-p3.id);
				for(j=1;j<=p1.id+2-p3.id;++j){
					printf("%d ",p1.q[i]);
					++i;
					if(i>p1.id)
						i-=p1.id;
				}
				break;
			}
		puts("");
		for(i=1;i<=p2.id;++i)
			if(p2.q[i]==p3.q[1]){
				for(j=1;j<=p2.id+2-p3.id;++j){
					printf("%d ",p2.q[i]);
					i=(--i==0)?p2.id:i;
				}
				break;
			}
			else if(p2.q[i]==p3.q[p3.id]){
				i+=p3.id-1;
				if(i>p2.id)
					i-=p2.id;
				printf("%d ",p2.id+2-p3.id);
				for(j=1;j<=p2.id+2-p3.id;++j){
					printf("%d ",p2.q[i]);
					++i;
					if(i>p2.id)
						i-=p2.id;
				}
				break;
			}
	}

	return 0;
}