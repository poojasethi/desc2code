#include <cstdio>
#include <cstring>
#include <vector>
#include <algorithm>
#define FOR(i,s,e) for (int i=(s); i<(e); i++)
#define FOE(i,s,e) for (int i=(s); i<=(e); i++)
#define FOD(i,s,e) for (int i=(s)-1; i>=(e); i--)
#define CLR(a,x) memset(a, x, sizeof(a))
#define EXP(i,l) for (int i=(l); i; i=qn[i])
#define N 400005
using namespace std;

int n, m, t, x, y, ed, pt, bcc;
int qd[N], qn[N], l[N], v[N], w[N], vv[N], d[N], AP[N], p[N], vis[N];
int col[N];
int done, cnt, cycl, par[N], L[N], C[N], cc[N], vc[N], pp[N];
vector<int> P;

void bd(int x, int y){
	qd[++ed] = y, qn[ed] = l[x], l[x] = ed;
}

void dfs(int x, int y){
	int c = 0;
	v[x] = w[x] = ++t; 
	p[x] = y;
	for (int i=l[x]; i; i=qn[i])
	if (!v[qd[i]]){
		dfs(qd[i], x);
		w[x] = min(w[x], w[qd[i]]);
		++c;
		if ((y >= 0 && w[qd[i]] >= v[x]) || (y < 0 && c > 1)) AP[x] = 1;
	}
	else if (qd[i] != y) w[x] = min(w[x], v[qd[i]]);
}

void color(int x, int y){
	vis[x] = 1;
	for (int i=l[x]; i; i=qn[i]){
		if (col[i] || col[i^1]) continue;
		if (p[x] == -1 || (AP[x] && w[qd[i]] >= v[x])){
			col[i] = col[i^1] = ++bcc;
			color(qd[i], bcc);
		}
		else{
			col[i] = col[i^1] = y;
			if (!vis[qd[i]]) color(qd[i], y);
		}
	}
}

void dfs(int x){
	vv[x] = 1;
	L[cnt++] = x;
	EXP(i,l[x]) if (!vv[qd[i]]) dfs(qd[i]);
	d[x] = 0;
	EXP(i,l[x]) ++d[x];
}

void cyc(int x, int p){
	vv[x] = 2;
	par[x] = p;
	EXP(i,l[x]) if (qd[i] != p){
		if (vv[qd[i]] == 1) cyc(qd[i], x);
		else if (vv[qd[i]] == 2 && !cycl){
			int t = x;
			while (1){
				C[cycl++] = t;
				cc[t] = 1;
				if (t == qd[i]) break;
				t = par[t];
			}
		}
	}
	vv[x] = 3;
}

void shoot(int x, int p){
	if (done) return;
	vc[x] = 1;
	pp[x] = p;
	EXP(i,l[x]) if (!vc[qd[i]] && !done){
		if (p == -1 && cc[qd[i]]) continue;
		if (cc[qd[i]]){
			done = 1;
			pp[qd[i]] = x;
			pt = qd[i];
		}
		else shoot(qd[i], x);
	}
}

void print(){
	printf("%d", P.size());
	FOR(i,0,P.size()) printf(" %d", P[i]);
	puts("");
}

struct edge{
	int x, y, c;
	bool operator < (edge const &T) const{return c < T.c;}
};
edge E[N];

int main(){
	scanf("%d%d", &n, &m);
	ed = 1;
	FOR(i,0,m){
		scanf("%d%d", &x, &y), --x, --y;
		bd(x, y), bd(y, x);
	}
	
	FOR(i,0,n) if (!v[i]) dfs(i, -1);
	FOR(i,0,n) if (!vis[i]) color(i, -1);
	
	CLR(l, 0);
	FOE(i,2,ed){
		E[i-2].x = qd[i];
		E[i-2].y = qd[i^1];
		E[i-2].c = col[i];
	}
	int Edges = ed - 1;
	sort(E, E + Edges);
	int ptr = 0;
	
	FOE(bb,1,bcc){
		int i;
		ed = 0;
		while (ptr < Edges && E[ptr].c == bb){
			bd(E[ptr].x, E[ptr].y);
			i = E[ptr].x;
			++ptr;
		}

		cnt = 0;
		dfs(i);
		if (cnt < 4) goto AFTER;
		
		cycl = 0;
		cyc(L[0], -1);
		if (cycl < 3) break;
		
		//FOR(j,0,cycl) printf("%d", C[j]+1);
		
		FOR(j,0,cycl) if (d[C[j]] > 2){
			EXP(k,l[C[j]]){
				int y = qd[k];
				if (!cc[y]) continue;
				if (y == C[(j+1)%cycl] || y == C[(j+cycl-1)%cycl]) continue;
				
				puts("YES");
				printf("2 %d %d\n", y + 1, C[j] + 1);
				
				int ty = y;
				FOR(k,0,cycl) if (C[k] == ty) y = k;
				
				P.clear();
				for (int k=y; k!=j; k=(k+1==cycl?0:k+1)) P.push_back(C[k] + 1);
				P.push_back(C[j] + 1);
				print();
				
				P.clear();
				for (int k=y; k!=j; k=(k==0?cycl-1:k-1))  P.push_back(C[k] + 1);
				P.push_back(C[j] + 1);
				print();				
				
				return 0;
			}
			done = 0;
			shoot(C[j], -1);
			
			if (done){
				puts("YES");
				FOR(k,0,cycl) if (C[k] == pt) y = k;
				
				P.clear();
				for (int k=y; k!=j; k=(k+1==cycl?0:k+1)) P.push_back(C[k] + 1);
				P.push_back(C[j] + 1);
				print();
				
				P.clear();
				for (int k=y; k!=j; k=(k==0?cycl-1:k-1))  P.push_back(C[k] + 1);
				P.push_back(C[j] + 1);
				print();
				
				P.clear();
				while (1){
					P.push_back(pt + 1);
					if (pt == C[j]) break;
					pt = pp[pt];
				}
				print();
				return 0;
			}
		}
		AFTER:
		FOR(i,0,cnt) vv[L[i]] = vc[L[i]] = cc[L[i]] = l[L[i]] = 0;
	}
	
	puts("NO");
	return 0;
}

