#include <cstdio>
#include <vector>
#include <set>
#include <algorithm>

#define N 200100
#define M 200100
#define gc getchar
#define pc putchar

using namespace std;

int n, m;
int from[M << 1], to[M << 1], next[M << 1];
int head[N];

int dt[N], low[N], dtime;

int St[M << 1], top;

struct Edge {
    int A, B;
    inline Edge (int a = 0, int b = 0) {
        if (a > b) A = b, B = a;
        else A = a, B = b;
    }
};

bool operator < (Edge a, Edge b) {
    if (a.A != b.A) return a.A < b.A;
    return a.B < b.B;
}

vector <int> bcc[M];
int C;

void AddEdge(int s, int e, int u) {
    from[u] = s, to[u] = e;
    next[u] = head[s], head[s] = u;
}

inline int EID(int e) { return e > m ? e - m : e; }

void update(vector <int> &v) {
    sort(v.begin(), v.end());
    v.erase(unique(v.begin(), v.end()), v.end());
}

void DFS(int s, int p = 0) {
    dt[s] = low[s] = ++ dtime;
    for (int i = head[s]; i; i = next[i]) {
        int u = to[i];
        if (dt[u] < dt[s]) St[++ top] = i;
        if (!dt[u]) {
            DFS(u, s);
            low[s] = min(low[s], low[u]);
            if (low[u] >= dt[s]) {
                bcc[++ C].clear();
                while (1) {
                    int tp = St[top --];
                    bcc[C].push_back(EID(tp));
                    if (tp == i) break;
                }
                update(bcc[C]);
            }
        } else if (u != p) low[s] = min(low[s], dt[u]);
    }
}

void BCC() {
    for (int i = 1; i <= n; i ++) if (!dt[i]) {
        dtime = top = 0;
        DFS(i);
    }
}

int fl[N], flag = 0;
int deg[N];
vector <int> con[N], V;

int col;

int sto[N], cnt;
bool cycle[N];
int S, E, last;
int pa[N], pb[N];
bool vis[N], chk[N];

bool dfs(int cur) {
    vis[cur] = 1;
    for (int i = 0; i < con[cur].size(); i ++) {
        int u = con[cur][i];
        if (u == pa[cur]) continue;
        if (vis[u]) {
            if (u == S) {
                last = cur;
                cycle[cur] = 1;
                return 1;
            }
            continue;
        }
        pa[u] = cur;
        if (dfs(u)) {
            cycle[cur] = 1;
            return 1;
        }
    }
    return 0;
}

bool dfs1(int cur) {
    chk[cur] = 1;
    for (int i = 0; i < con[cur].size(); i ++) {
        int u = con[cur][i];
        if (chk[u]) continue;
        if (cycle[u]) {
            if (cur == S && (pa[u] == cur || u == last)) continue;
            pb[u] = cur;
            E = u;
            return 1;
        }
        pb[u] = cur;
        if (dfs1(u)) return 1;
    }
    return 0;
}

int getint() {
    unsigned int c;
    int x = 0;
    while (((c = gc()) - '0') >= 10) if (c == '-') return -getint();
    do x = (x << 3) + (x << 1) + (c - '0'); while (((c = gc()) - '0') < 10);
    return x;
}

void putint(int n) {
    int i = 16, a[i];
    if (n < 0) pc('-');
    do {
        a[-- i] = 48 + abs(n % 10);
        n /= 10;
    } while (n);
    while (i < 16) pc(a[i ++]);
}

void Add(int s, int e) {
    if (fl[s] < flag) {
        V.push_back(s);
        con[s].clear();
        deg[s] = 0;
        fl[s] = flag;
    }
    con[s].push_back(e);
    deg[s] ++;
}

main() {
//  freopen("E.in", "r", stdin);
    n = getint();
    m = getint();
    for (int k = 1; k <= m; k ++) {
        int i = getint();
        int j = getint();
        AddEdge(i, j, k);
        AddEdge(j, i, k + m);
    }

    BCC();

/*  for (int i = 1; i <= C; i ++) {
        for (int j = 0; j < bcc[i].size(); j ++) printf("%d ", bcc[i][j]); puts("");
    }*/

//  for (int i = 1; i <= m; i ++) printf("%d ", color[i]); puts("");

    for (col = 1; col <= C; col ++) {
        V.clear();
        flag ++;
        for (int j = 0; j < bcc[col].size(); j ++) {
            int e = bcc[col][j];
            int a = from[e], b = to[e];
            Add(a, b);
            Add(b, a);
        }
        for (int j = 0; j < V.size(); j ++) {
            int i = V[j];
            if (deg[i] <= 2) continue;
            puts("YES");
            S = i;
            dfs(i);
            dfs1(i);

            cnt = 0;
            for (int cur = E; cur; cur = pa[cur]) sto[cnt ++] = cur;
            putint(cnt);
            for (int j = 0; j < cnt; j ++) putchar(' '), putint(sto[j]); puts("");

            cnt = 0;
            for (int cur = E; cur; cur = pb[cur]) sto[cnt ++] = cur;
            putint(cnt);
            for (int j = 0; j < cnt; j ++) putchar(' '), putint(sto[j]); puts("");

            cnt = 0;
            for (int cur = last; cur != E; cur = pa[cur]) sto[cnt ++] = cur;
            sto[cnt ++] = E;
            reverse(sto, sto + cnt);
            sto[cnt ++] = S;
            putint(cnt);
            for (int j = 0; j < cnt; j ++) putchar(' '), putint(sto[j]); puts("");

            return 0;
        }
    }

    puts("NO");
}
