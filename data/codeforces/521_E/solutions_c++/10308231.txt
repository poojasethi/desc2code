#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 410000;

int adj[N], next[N], last[N], num[N];
int dfn[N], md[N];
int stack[N], to[N], from[N];
int cyc[N], incyc[N], cov[N], lab[N], fa[N], bfs[N];
int path[N];
int cn, sn, DFN, n, m, mm = 1, pn, S, T, bn;
bool FIND;

void Link(int x, int y, int i) {adj[++mm] = y; next[mm] = last[x]; last[x] = mm; num[mm] = i;}

void Bfs(int x) {
    int l = 0, r = 1;
    lab[x] = 1;
    bfs[1] = x;
    for (; l < r; ) {
        int u = bfs[++l];
        for (int p = last[u]; p; p = next[p]) {
            int v = adj[p];
            if (lab[v] || incyc[num[p]]) continue;
            lab[v] = 1;
            fa[v] = u;
            bfs[++r] = v;
            if (cov[v] == bn) {
                for (; v; v = fa[v]) path[++pn] = v;
                return;
            }
        }
    }
}

void Tarjan(int u, int pre) {
    dfn[u] = md[u] = ++DFN;
    for (int p = last[u]; p; p = next[p]) {
        int v = adj[p], t = num[p];
        if (t == pre) continue;
        if (!dfn[v]) {
            stack[++sn] = t;
            to[t] = v;
            from[t] = pre;
            Tarjan(v, t);
            if (FIND) return;
            md[u] = min(md[u], md[v]);
            
            if (md[v] == dfn[u]) {
                int st, e = 0;
                ++bn;
                for (st = sn; stack[--st] != t; );
                for (int i = st; i <= sn; i++) if (to[stack[i]] == u) {e = stack[i]; break;}
                for (cn = 0;;) {cyc[++cn] = to[e], incyc[e] = bn, cov[to[e]] = bn; if (e == t) break; e = from[e];}
                e = 0;
                for (int i = st; i <= sn; i++) if (!incyc[stack[i]] && cov[to[stack[i]]] == bn) e = stack[i];
                
                if (e) {
                    Bfs(to[e]);
                    FIND = true; return;
                }
                
                for (int i = st; i <= sn; i++) stack[i] = 0;
                sn = st - 1;
            }
        } else if (dfn[v] < dfn[u]) {
            stack[++sn] = t;
            to[t] = v;
            from[t] = pre;
            md[u] = min(md[u], dfn[v]);
        }
    }
}

int main() {
    
    scanf("%d%d", &n, &m);
    for (int i = 1, x, y; i <= m; i++) {
        scanf("%d%d", &x, &y);
        Link(x, y, i);
        Link(y, x, i);
    }
    
    for (int i = 1; i <= n && !FIND; i++) if (!dfn[i]) sn = 0, Tarjan(i, 0);
    if (!FIND) puts("NO"); else {
        S = path[1]; T = path[pn];
        puts("YES");
        printf("%d", pn); for (int i = 1; i <= pn; i++) printf(" %d", path[i]); puts("");
        
        int s = 0;
        for (int i = 1; i <= cn; i++) if (cyc[i] == S) {s = i; break;}
        
        path[pn = 1] = S;
        for (int i = s; cyc[i] != T; ) path[++pn] = cyc[i = (i == cn) ? 1 : i + 1];
    /*  if (n == 90000) {
            printf("cn == %d\n", cn);
            for (int j = 1; j <= cn; j++) printf("%d ", cyc[j]); puts("");
        }*/
        printf("%d", pn); for (int i = 1; i <= pn; i++) printf(" %d", path[i]); puts("");
        
        path[pn = 1] = S;
        for (int i = s; cyc[i] != T; ) path[++pn] = cyc[i = (i == 1) ? cn : i - 1];
        printf("%d", pn); for (int i = 1; i <= pn; i++) printf(" %d", path[i]); puts("");
    }
    
    return 0;
}
