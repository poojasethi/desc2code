#include <algorithm>
#include <iostream>
#include <cstring>
#include <vector>
using namespace std;
const int MAX = 200005;
vector<int> adj[MAX], edges[MAX];
int par[MAX], from[MAX], to[MAX], d[MAX], low[MAX], size[MAX], seen[MAX], col;
bool mark[MAX], mark2[MAX], used[MAX];
vector<int> ver;
void dfs(int p, int v)
{
	ver.push_back(v);
	mark[v] = true;
	for (int i = 0; i < adj[v].size(); i++)
	{
		int id = adj[v][i];
		int u = from[id] + to[id] - v;
		if (u == p)
			continue;
		if (!mark[u])
		{
			int tmp = ver.back();
			d[u] = d[v] + 1;
			dfs(v, u);
			if (d[low[v]] > d[low[u]])
				low[v] = low[u];
			if (d[low[u]] >= d[v])
			{
				while (ver.back() != tmp)
				{
					int u = ver.back();
					ver.pop_back();
					size[col]++;
					for (int i = 0; i < adj[u].size(); i++)
					{
						int id = adj[u][i];
						if (!used[id])
							edges[col].push_back(id);
						used[id] = true;
					}
				}
				size[col]++;
				col++;
			}
		}
		else if (d[low[v]] > d[u])
			low[v] = u;
	}
}
int st, fi;
void fcycle(int p, int v)
{
	par[v] = p;
	mark[v] = true;
	for (int i = 0; i < adj[v].size(); i++)
	{
		int u = adj[v][i];
		if (u == p)
			continue;
		if (!mark[u])
			fcycle(v, u);
		else if (st == -1)
		{
			st = v;
			fi = u;
		}
	}
}
void _print(int st, int fi)
{
	vector<int> ans;
	ans.push_back(st);
	mark[st] = true;
	st = adj[st].back();
	while (st != fi)
	{
		mark[st] = true;
		ans.push_back(st);
		for (int i = 0; i < adj[st].size(); i++)
		{
			int u = adj[st][i];
			if (!mark[u])
			{
				st = u;
				break;
			}
		}
	}
	ans.push_back(st);
	cout << ans.size();
	for (int i = 0; i < ans.size(); i++)
		cout << " " << ans[i] + 1;
	cout << "\n";
}
void print(int st, int fi)
{
	cout << "YES\n";
	for (int i = 0; i < 3; i++)
	{
		memset(mark, false, sizeof(mark));
		_print(st, fi);
		adj[st].pop_back();
	}
}
void solve()
{
	st = -1;
	fi = -1;
	memset(mark, false, sizeof(mark));
	for (int i = 0; i < MAX; i++)
		if (!adj[i].empty())
		{
			fcycle(-1, i);
			break;
		}
	memset(mark, false, sizeof(mark));
	vector<int> cycle;
	while (st != fi)
	{
		mark[st] = true;
		mark2[st] = true;
		cycle.push_back(st);
		st = par[st];
	}
	mark[st] = true;
	mark2[st] = true;
	cycle.push_back(st);
	int v = -1, bad1 = -1, bad2 = -1;
	for (int i = 0; i < cycle.size(); i++)
		if (adj[cycle[i]].size() > 2)
		{
			v = cycle[i];
			bad1 = cycle[(i - 1 + cycle.size()) % cycle.size()];
			bad2 = cycle[(i + 1) % cycle.size()];
			break;
		}
	vector<int> path;
	path.push_back(v);
	for (int i = 0; i < adj[v].size(); i++)
	{
		int u = adj[v][i];
		if (mark[u] && u != bad1 && u != bad2)
		{
			path.push_back(u);
			break;
		}
		if (!mark[u])
		{
			v = u;
			break;
		}
	}
	if (path.size() < 2)
	{
		fcycle(-1, v);
		vector<int> ver;
		for (int i = 0; i < cycle.size(); i++)
		{
			int v = cycle[i];
			if (v != path.back())
			{
				for (int j = 0; j < adj[v].size(); j++)
				{
					int u = adj[v][j];
					if (!mark2[u] && mark[u])
					{
						ver.push_back(v);
						while (u != -1)
						{
							ver.push_back(u);
							u = par[u];
						}
						reverse(ver.begin(), ver.end());
						for (int k = 0; k < ver.size(); k++)
							path.push_back(ver[k]);
					}
					if (!ver.empty())
						break;
				}
				if (!ver.empty())
					break;
			}
		}
	}
	for (int i = 0; i < MAX; i++)
		adj[i].clear();
	for (int i = 0; i < cycle.size(); i++)
	{
		int v = cycle[i];
		int u = cycle[(i + 1) % cycle.size()];
		adj[v].push_back(u);
		adj[u].push_back(v);
	}
	for (int i = 1; i < path.size(); i++)
	{
		int v = path[i - 1];
		int u = path[i];
		adj[v].push_back(u);
		adj[u].push_back(v);
	}
	print(path[0], path.back());
}
int main()
{
	ios::sync_with_stdio(false);
	for (int i = 0; i < MAX; i++)
		low[i] = i;
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < m; i++)
	{
		cin >> from[i] >> to[i];
		from[i]--;
		to[i]--;
		adj[from[i]].push_back(i);
		adj[to[i]].push_back(i);
	}
	for (int i = 0; i < n; i++)
		if (!mark[i])
			dfs(-1, i);
	for (int i = 0; i < col; i++)
	{
		sort(edges[i].begin(), edges[i].end());
		edges[i].resize(unique(edges[i].begin(), edges[i].end()) - edges[i].begin());
		if (edges[i].size() >= size[i] + 1)
		{
			for (int j = 0; j < MAX; j++)
				adj[j].clear();
			for (int j = 0; j < edges[i].size(); j++)
			{
				int id = edges[i][j];
				adj[from[id]].push_back(to[id]);
				adj[to[id]].push_back(from[id]);
			}
			solve();
			return 0;
		}
	}
	cout << "NO\n";
	return 0;
}
