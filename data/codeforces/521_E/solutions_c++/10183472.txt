#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <vector>
#include <list>
#include <set>
#include <stack>
#include <queue>
#include <map>
#include <iostream>
#include <cassert>

using namespace std;

#define fru(j,n) for(int j=0; j<(n); ++j)
#define tr(it,v) for(typeof((v).begin()) it=(v).begin(); it!=(v).end(); ++it)
#define x first
#define y second
#define pb push_back
#define ALL(G) (G).begin(),(G).end()

//#define DEBUG
#ifdef DEBUG
#define DEB printf
#else
#define DEB(...)
#endif


typedef long long LL;
typedef double D;
typedef pair<int,int> pii;
typedef vector<int> vi;

struct Edge { // PRE: musi być bcc = -1 i bridge = 0 (konstruktor ustawia)
	Edge* rev;
	int dest;
	int bcc;        // OUT: Numer komponentu
	bool bridge;    // OUT: Czy most	// M
	Edge(int v) : dest(v), bcc(-1)
				  , bridge(0)	// M
	{};
};
const int MAXN = 200005;  //IN: 19^6
int n;                     //IN: Liczba wierzchołków

list<Edge> adj[MAXN];      // KONIECZNIE LISTY a nie vectory!!!

void add_edge (int a, int b) {//IN: Do dodawania krawedzi
	if(a==b) return;
	adj[a].pb(Edge(b));   adj[b].pb(Edge(a));
	adj[a].back().rev = &adj[b].back();
	adj[b].back().rev = &adj[a].back();
}

int tin[MAXN];
bool artp[MAXN];  // OUT: czy dany wierzchołek jest p.art.      // A
int bcc_num;      // OUT: Liczba komponentów                    // D
int low[MAXN];    // OUT: Funkcja low                           // L

stack<Edge*> st;                                                // D
int dfsTime;
int bccDFS (int u, bool root = 0) {
	int lo = tin[u] = ++dfsTime;
	tr(it,adj[u]) {
		if (it->bcc != -1) continue;
		st.push(&*it);                                  // D
		it->rev->bcc = -2;
		if (!tin[it->dest]) {
			int on = bccDFS(it->dest);
			lo = min(on, lo);
			it->bridge = it->rev->bridge = (on > tin[u]);    // M
			if (on >= tin[u]) {                              // AD
				artp[u] = !root; root = 0;               // A
				Edge* edge;                              // D
				do {                                     // D
					edge = st.top(); st.pop();       // D
					edge->bcc=edge->rev->bcc=bcc_num;// D
				} while (edge != &*it);                  // D
				++bcc_num;                               // D
			}                                                // AD
		} else lo = min(lo, tin[it->dest]);
	}
	low[u] = lo;                                                // L
	return lo;
}
void computeBCC(){ //to trzeba odpalic po dodaniu wszystkich krawedzi
	fill(artp, artp+n+1, 0);                                    // A
	fill(tin, tin+n+1, 0);
	dfsTime = 1;
	bcc_num = 0;                                                // D
	fru(i,n) if(!tin[i]) bccDFS(i, 1); 
}//UWAGA::trzeba pamietac o krawedziach wielokrotnych, ktore nie sa mostami
vector<pii> BCC[MAXN];

vector<int> V[MAXN],ANS;
bool cykl[MAXN];
vector<int> ST;
int vis[MAXN];
vector<int> CYKL;
int ile,rozmiar,startowy;
bool dfs1(int u,int par){
	++ile;
	DEB("dfs(%d,%d)\n",u,par);
	vis[u]=1;
	ST.pb(u);
	tr(it,V[u]) if(*it!=par){
		if(vis[*it]==1){
		   if(ile==rozmiar && *it==startowy) continue;
			DEB("rozmiar = %d, ile = %d\n",rozmiar,ile);
			while(1){
				int e=ST.back();
				ST.pop_back();
				CYKL.pb(e);
				if(e==*it) return 1;
			}
		}
		else if(dfs1(*it,u)) return 1;
//		assert(0);
	}
	ST.pop_back();
	--ile;
//	assert(0);
	return 0;
}
int koniec,poczatek;
bool dfs(int u,int par){
	DEB("u = %d, par = %d\n",u,par);
	vis[u]=2;
	tr(it,V[u]) if(*it!=par){
		if(vis[*it]==2) continue;
		if(u==poczatek && cykl[*it]) continue;
		if(cykl[*it]){
			koniec=*it;
			ANS.pb(*it);
			ANS.pb(u);
			return 1;
		}
		else if(dfs(*it,u)) 
		{
			ANS.pb(u);
			return 1;
		}
	}
//	assert(0);
	return 0;
}
void OUT(){
	printf("%lu",ANS.size());
	tr(it,ANS) printf(" %d",*it+1);
	printf("\n");
	ANS.clear();
}

bool ok(int u){
	DEB("sklad: \n");
	tr(it,BCC[u]) DEB("%d -- %d\n",it->x,it->y); DEB("------\n");
	assert(BCC[u].size());
	if(BCC[u].size()==2) return 0;
	map<int,int> M;
	tr(it,BCC[u]) M[it->x]++;
	tr(it,M) assert(it->y>=2);
	bool ok=0;
	tr(it,M) if(it->y!=2) ok=1;
	rozmiar=M.size();
	if(ok==0) return 0;
	tr(it,BCC[u]) V[it->x].pb(it->y);
	startowy=BCC[u][0].x;
	dfs1(startowy,-1);
	tr(it,CYKL) cykl[*it]=1;
	tr(it,CYKL) {DEB("%d na cyklu\n",*it);}
	fru(i,n) if(cykl[i]) {
		bool ok=0;
		tr(it,V[i]) if(!cykl[*it]) ok=1;
		if(ok==0) continue;


		printf("YES\n");
		poczatek=i;
		assert(dfs(i,-1));
		OUT();
		DEB("pocz = %d, koniec= %d\n",i,koniec);
		vector<int> temp;
		V[koniec].clear();
//		tr(it,CYKL) printf("===%d\n",*it);
		fru(j,CYKL.size()) {
			int u=CYKL[j];
			V[u].clear();
			assert(temp.empty());
			V[u].pb(CYKL[(j+1)%CYKL.size()]);
			V[u].pb(CYKL[(j+CYKL.size()-1)%CYKL.size()]);
		}
		if(V[koniec][0]==poczatek) swap(V[koniec][0],V[koniec][1]);
//		tr(it,V[koniec]) printf("krawedzie do %d\n",*it);
		fru(o,2){
			int q=koniec;
			cykl[koniec]=0;
			cykl[poczatek]=1;
//			fru(j,n) if(cykl[j]) printf("teraz na cyklu %d\n",j);
			while(q!=poczatek){
//		printf("q = %d\n",q);	tr(it,V[q]) printf("-->%d\n",*it);if(q==2) exit(0);
				ANS.pb(q);
				tr(it,V[q]) if(cykl[*it]){q=*it; break;}
				cykl[q]=0;
			}
			ANS.pb(poczatek);
			OUT();
	//		break;
		}
		return 1;
	}
	assert(0);
}

int main(){
	int m;
	scanf("%d%d",&n,&m);
	fru(i,m){
		int a,b;
		scanf("%d%d",&a,&b);
		add_edge(a-1,b-1);
	}
	computeBCC();
	fru(i,n) tr(it,adj[i])BCC[it->bcc].pb(pii(i,it->dest));
	fru(i,bcc_num) if(ok(i)) return 0;
	printf("NO\n");
	return 0;
}
