#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <cmath>
#include <algorithm>
#include <bitset>
#include <queue>
#include <vector>
#include <set>
#include <map>
//#include <iostream>
using namespace std;

#define  REP(i,s,e) for(int (i)=(s),(_end_)=(e);(i)<=(_end_);++(i))
#define REPD(i,s,e) for(int (i)=(s),(_end_)=(e);(i)>=(_end_);--(i))

const int MAXN = 201000;
struct edge
{
	int to,ne;
	edge(){}
	edge(int to,int ne): to(to),ne(ne) {}
}	e[MAXN<<1];
int fir[MAXN],e_tot;
int n;
void update(int x,int y)
{
	e[++e_tot]=edge(y,fir[x]);fir[x]=e_tot;
	e[++e_tot]=edge(x,fir[y]);fir[y]=e_tot;
}

int f[MAXN],dl[MAXN],LL,RR,dep[MAXN],o[MAXN];
int g[MAXN][19][2],h[MAXN][19][2];

void get_zj()
{
	int p=1,q=1;
	memset(f,-1,sizeof f);
	f[1]=0;
	dl[1]=1;
again:
	while(p<=q)
	{
		for(int i=fir[dl[p]];i;i=e[i].ne)
			if(f[e[i].to]<0)
			{
				f[e[i].to]=dl[p];
				dl[++q]=e[i].to;
			}
		++p;
	}
	if(RR==0)
	{
		RR=dl[p-1];
		memset(f,-1,sizeof f);
		f[dl[p=q=1]=RR]=0;
		goto again;
	}
	LL=dl[p-1];
	for(int i=LL;i;i=-f[i])
		f[i]=-f[i];
	for(int i=1;i<=n;++i)
		if(f[i]>0) f[i]=-1;
	for(int i=LL;i;i=f[i])
		f[i]=-f[i];
	for(int j=0,i=LL;i;j=i,i=f[i])
	{
		dl[p=q=1]=i;
		while(p<=q)
		{
			for(int j=fir[dl[p]];j;j=e[j].ne)
				if(f[e[j].to]<0 && !dep[e[j].to])
				{
					dep[e[j].to]=dep[dl[p]]+1;
					dl[++q]=e[j].to;
					f[e[j].to]=i;
				}
			++p;
		}
		g[i][0][0]=f[i];
		g[i][0][1]=dep[dl[p-1]];
		h[i][0][0]=j;
		h[i][0][1]=dep[dl[p-1]];
	}
	for(int i=LL,s=1;i;i=f[i],++s)
		dl[i]=s;
	REP(i,1,18)
		for(int j=LL;j;j=f[j])
		{
			g[j][i][0]=g[g[j][i-1][0]][i-1][0];
			g[j][i][1]=max(g[j][i-1][1],g[g[j][i-1][0]][i-1][1]+min(1<<(i-1),dl[RR]-dl[j]));
			h[j][i][0]=h[h[j][i-1][0]][i-1][0];
			h[j][i][1]=max(h[j][i-1][1],h[h[j][i-1][0]][i-1][1]+min(1<<(i-1),dl[j]-1));
		}
	for(int i=LL,j=f[LL],s=1;i;i=j,j=f[j],++s)
		f[i]=-s,o[s]=i;
	return ;
}
int work(int L,int R,int type)
{
	int ans=0;
	if(-f[L]>-f[R]) return -1000000;
	if(type==0)
	{
		int x=L;
		REPD(i,18,0)
			if( g[x][i][0] && -f[g[x][i][0]] <= -f[R] )
				ans=max(ans,g[x][i][1] - f[x] + f[L]),x=g[x][i][0];
		return max(ans,g[x][0][1]-f[x]+f[L]);
	}
	else
	{
		int x=R;
		REPD(i,18,0)
			if( h[x][i][0] && -f[h[x][i][0]] >= -f[L] )
				ans=max(ans,h[x][i][1] - f[R] + f[x]),x=h[x][i][0];
		return max(ans,h[x][0][1]-f[R]+f[x]);
	}
}
int main()
{
	scanf("%d",&n);
	REP(i,1,n-1)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		update(x,y);
	}
	get_zj();
	int m;
	scanf("%d",&m);
	REP(i,1,m)	
	{
		int x,y;
		scanf("%d%d",&x,&y);
		if(f[x]==f[y] || f[x]==y || f[y]==x)
		{
			if(dep[x]>dep[y]) swap(x,y);
			int fa;
			if(dep[x]==0) fa=x;
			else fa=f[x];
			printf("%d\n",dep[x]+max(-f[fa]-1,-f[RR]+f[fa]));
		}
		else
		{
			int fa_x,fa_y,sum;
			if(dep[x]) fa_x=f[x]; else fa_x=x;
			if(dep[y]) fa_y=f[y]; else fa_y=y;
			if(-f[fa_x] > -f[fa_y] ) swap(x,y),swap(fa_x,fa_y);
			sum=(dep[x]+dep[y]+abs(-f[fa_x]+f[fa_y]))>>1;
			if(sum<dep[x])
				printf("%d\n",dep[y]+max(-f[fa_y]-1,-f[RR]+f[fa_y]));
			else
			if( sum-dep[x]-f[fa_x] >= -f[fa_y] )
				printf("%d\n",dep[x]+max(-f[fa_x]-1,-f[RR]+f[fa_x]));
			else
				printf("%d\n",max(max(dep[x]-f[fa_x]-1,dep[x]+1+work(o[1-f[fa_x]],o[sum-dep[x]-f[fa_x]],0)),
							  max(dep[y]+f[fa_y]-f[RR],dep[y]+1+work(o[sum-dep[x]-f[fa_x]+1] , o[-f[fa_y]-1] , 1))));
		}
	}
	return 0 ;
}
