#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
typedef long long LL;
const int MAXN = 100010;
vector<int> Q1[MAXN], Q2[MAXN];
int N, M, tot; 
int dep[MAXN], size[MAXN], f[MAXN];
int ReMap[MAXN], pos[MAXN];
int d[MAXN][30];
int broke[MAXN];
LL ans[MAXN];
struct Eg { int v; Eg *ne; } e[MAXN * 2], *G = e, *po[MAXN];
struct Tseg
{
	LL key, flag; int L, R, mid; Tseg *lch, *rch;
	void Init(int l, int r)
	{
		lch = rch = 0x0; flag = 0;
		L = l; R = r; mid = (l + r) / 2;
		if(L == R) { key = dep[ReMap[L]]-1; return; }
		(lch = new Tseg()) -> Init(l, mid);
		(rch = new Tseg()) -> Init(mid + 1, r);
		key = max(lch -> key, rch -> key);
	}
	void Push()
	{
		LL d = flag; flag = 0;
		if(lch) lch -> key += d, lch -> flag += d;
		if(rch) rch -> key += d, rch -> flag += d;
	}
	void Modify(int l, int r, LL v)
	{
		if(l > r || !l || !r) return;
		if(L == l && R == r) { flag += v; key += v; return; } Push();
		if(l > mid) rch -> Modify(l, r, v); else
		if(r <=mid) lch -> Modify(l, r, v); else
		lch -> Modify(l, mid, v), rch -> Modify(mid + 1, r, v);
		key = max(lch -> key, rch -> key);
	}
	LL Query(int l, int r)
	{
		if(l > r || !l || !r) return 0;
		Push(); if(L == l && R == r) return key;
		if(l > mid) return rch -> Query(l, r); else
		if(r <=mid) return lch -> Query(l, r); else
		return max(lch -> Query(l, mid), rch -> Query(mid + 1, r));
	}
} T;
inline int iabs(int x) { return x < 0 ? -x : x; }
inline int Dis(int a, int b) { return iabs(dep[a] - dep[b] ); }
inline void renew(LL &x, LL y) { if(y > x) x = y; }
void add(int a, int b) { G->v = b; G->ne = po[a]; po[a] = G++; }
void dfs(int x)
{
	pos[x] = ++tot; ReMap[tot] = x;
	dep[x] = dep[f[x]] + 1; size[x] = 1;
	d[x][0] = f[x]; int k = 0, y = f[x];
	while(d[y][k]) d[x][k+1] = d[y][k], y = d[y][k++];
	for(Eg *j = po[x]; j; j = j->ne) if(j->v != f[x])
		f[j->v] = x, dfs(j->v), size[x] += size[j->v];
}
int lca(int x, int y)
{
	if(dep[x] < dep[y]) swap(x, y);
	for(int k = 0; k >= 0 && dep[x] >= dep[y]; )
		if(dep[d[x][k]] >= dep[y]) x = d[x][k++]; else --k;
	if(x == y) return x;
	for(int k = 0; k >= 0; )
		if(d[x][k] != d[y][k]) x = d[x][k], y = d[y][k++]; else --k;
	return d[x][0];
}
void Solve(int x)
{
	for(int i = 0; i < Q1[x].size(); ++i)
	{
		int now = Q1[x][i];
		renew(ans[now], T.Query(1, pos[broke[now]] - 1));
		renew(ans[now], T.Query(pos[broke[now]] + size[broke[now]], N));
	}
	for(int i = 0; i < Q2[x].size(); ++i)
	{
		int now = Q2[x][i];
		renew(ans[now], T.Query(pos[broke[now]], pos[broke[now]] + size[broke[now]] - 1));
	}
	for(Eg *j = po[x]; j; j = j->ne) if(j->v != f[x])
	{
		T.Modify(1, N, +1); T.Modify(pos[j->v], pos[j->v] + size[j->v] - 1, -2);
		Solve(j->v);
		T.Modify(1, N, -1); T.Modify(pos[j->v], pos[j->v] + size[j->v] - 1, +2);
	}
}
int main()
{
    scanf("%d", &N);
    for(int i = 1, a, b; i < N; ++i)
    	scanf("%d%d", &a, &b), add(a, b), add(b, a);
    dfs(1); T.Init(1, N);
	scanf("%d", &M);
	for(int i = 1, a, b; i <= M; ++i)
	{
		scanf("%d%d", &a, &b); int fa = lca(a, b);
		if(Dis(a, fa) > Dis(b, fa)) swap(a, b); int c = b;
		for(int j = 29; j >= 0; --j) if(d[c][j] != 0)
			if(Dis(d[c][j], b) <= Dis(fa, d[c][j]) + Dis(a, fa) && dep[d[c][j]] > dep[fa]) c = d[c][j];
		broke[i] = c; Q1[a].push_back(i); Q2[b].push_back(i);
	}
	Solve(1); for(int i = 1; i <= M; ++i) printf("%I64d\n", ans[i]);
	return 0;
}
