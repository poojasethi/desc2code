#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
const int M=100005;
vector<int>edge[M];
int n,m;
int A[M],mx,dis[M],id;
bool mark,in_chain[M];
int belong[M],tot,tmp;
int depth[M],dep[M],fa[M];
void rec(int x,int f,int d){
	fa[x]=f;
	if(d>=mx){
		mx=d;
		id=x;
	}
	for(int i=0;i<edge[x].size();i++){
		if(edge[x][i]==f) continue;
		rec(edge[x][i],x,d+1);
	}
}
void assign(int x,int f,int bid,int d){
	belong[x]=bid;
	dep[x]=d;
	if(d>tmp) tmp=d;
	for(int i=0;i<edge[x].size();i++){
		if(edge[x][i]==f||in_chain[edge[x][i]]) continue;
		assign(edge[x][i],x,bid,d+1);
	}
}
void dfs(){
	int x=id;
	while(x){
		in_chain[x]=1;
		tmp=0;
		assign(x,fa[x],++tot,0);
		depth[tot]=tmp;
		x=fa[x];
	}
}
int tree[M<<2][2];
void up(int p){
	tree[p][0]=max(tree[p<<1][0],tree[p<<1|1][0]);
	tree[p][1]=max(tree[p<<1][1],tree[p<<1|1][1]);
}
void build(int L,int R,int p){
	if(L==R){
		tree[p][0]=depth[L]+L-1;
		tree[p][1]=depth[L]+tot-L;
		return;
	}
	int mid=L+R>>1;
	build(L,mid,p<<1);
	build(mid+1,R,p<<1|1);
	up(p);
}
int Query(int L,int R,int p,int l,int r,int f){
	if(L>R) return 0;
	if(l==L&&r==R) return tree[p][f];
	int mid=l+r>>1;
	if(mid>=R) return Query(L,R,p<<1,l,mid,f);
	else if(mid<L) return Query(L,R,p<<1|1,mid+1,r,f);
	else return max(Query(L,mid,p<<1,l,mid,f),Query(mid+1,R,p<<1|1,mid+1,r,f));
}
int main(){
	int size=128<<20;
	char *p=(char*)malloc(size)+size;
	__asm__("movl %0, %%esp\n" :: "r"(p));
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		int a,b;
		scanf("%d%d",&a,&b);
		edge[a].push_back(b);
		edge[b].push_back(a);
	}
	mx=-1;
	rec(1,0,0);
	int root=id;
	rec(id,0,0);
	dfs();
	scanf("%d",&m);
	build(1,tot,1);
//	puts("Belong");
//	for(int i=1;i<=n;i++)
//		printf("%d ",belong[i]);
//	puts("");
//	for(int i=1;i<=tot;i++){
//		printf(" %d %d \n",dep[i],Query(i,i,1,1,tot,0));
//	}
	for(int i=0;i<m;i++){
		int a,b;
		scanf("%d%d",&a,&b);
		int ans=0;
		if(belong[a]==belong[b]){
			if(dep[a]<dep[b]) b=a;
			else a=b;
		}
		if(belong[a]>belong[b]) swap(a,b);
		ans=max(min(belong[a]-1+dep[a],belong[b]-1+dep[b]),min(tot-belong[a]+dep[a],tot-belong[b]+dep[b]));
//		else ans=min(belong[a]+dep[a]-1,tot-belong[b]+dep[b]);
		int k=(belong[a]-dep[a]+belong[b]+dep[b])>>1;
//		printf("k %d\n",k);
//		printf("ans1 %d\n",ans);
		if(k<belong[a]){
//			printf("A %d %d\n",k,belong[b]);
			ans=max(ans,Query(k+1,belong[b],1,1,tot,1)-(tot-belong[b]));
		}else if(k>belong[b]){
//			printf("B %d %d\n",belong[a],k);
			ans=max(ans,Query(belong[a],k,1,1,tot,0)-belong[a]);
		}else{
//			printf("C %d %d\n",belong[a],k);
//			printf("C %d %d\n",k,belong[b]);
//			printf("%d %d\n",Query(belong[a],k,1,1,tot,0),Query(k,belong[b],1,1,tot,1));
			ans=max(ans,dep[a]+Query(belong[a],k,1,1,tot,0)-belong[a]+1);
			ans=max(ans,dep[b]+Query(k+1,belong[b],1,1,tot,1)-(tot-belong[b]));
		}
		printf("%d\n",ans);
	}
	return 0;
}