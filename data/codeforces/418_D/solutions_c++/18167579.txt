#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<cstdlib>
using namespace std;
typedef long long ll;
typedef double db;
const int inf=1e9;
const int INF=0x7fffffff;
const ll linf=1LL<<60;
inline void rd(int &res){
	char c;res=0;
	while(c=getchar(),!isdigit(c));
	do res=(res<<1)+(res<<3)+(c^48);
	while(c=getchar(),isdigit(c));
}
const int SIZE=100005;
int N,M;
int G[SIZE<<1],nxt[SIZE<<1],head[SIZE];
int sz;
inline void add_edge(int u,int v){
	G[sz]=v;nxt[sz]=head[u];head[u]=sz;sz++;
}
void input(){
	scanf("%d",&N);
	sz=0;
	for(int i=0;i<=N;i++)head[i]=-1;
	for(int i=0;i<N-1;i++){
		int u,v;rd(u);rd(v);
		add_edge(u,v);
		add_edge(v,u);
	}
}
int td[2];
int ID,dis_mx;
void find_ID(int p,int par,int dis){
//	printf("dep %d\n",dis);
	if(dis>dis_mx){
		ID=p;
		dis_mx=dis;
	}
	for(int i=head[p];~i;i=nxt[i])if(G[i]!=par)
		find_ID(G[i],p,dis+1);
}
int tot;
int seg_id[SIZE];
bool sign(int p,int par){
	bool res=p==td[1];
	for(int i=head[p];~i;i=nxt[i])if(G[i]!=par)
		res|=sign(G[i],p);
	if(res)seg_id[p]=++tot;
	return res;
}
int seg_fa[SIZE],dis_to_seg[SIZE],mx_from_son[SIZE];
void dfs(int p,int par,int dis,int sfa){
	if(seg_id[p]==0){
		seg_fa[p]=sfa;
		dis_to_seg[p]=dis;
		mx_from_son[sfa]=max(mx_from_son[sfa],dis);
	}else{
		seg_fa[p]=seg_id[p];
		dis_to_seg[p]=0;
	}
	for(int i=head[p];~i;i=nxt[i])if(G[i]!=par){
		int nxtdis,nxtsfa;
		if(seg_id[p]){nxtdis=1;nxtsfa=seg_id[p];}
		else{nxtdis=dis+1;nxtsfa=sfa;}
		dfs(G[i],p,nxtdis,nxtsfa);
	}
}
struct Segment_Tree{
	int mx[SIZE<<2];
	void build(int a[SIZE],int tl,int tr,int p){
		if(tl==tr){
			mx[p]=a[tl];
			return;
		}
		int mid=tl+tr>>1;
		build(a,tl,mid,p<<1);
		build(a,mid+1,tr,p<<1|1);
		mx[p]=max(mx[p<<1],mx[p<<1|1]);
	}
	int query(int tl,int tr,int ql,int qr,int p){
//		printf("tl %d tr %d %d %d\n",tl,tr,ql,qr);
		if(tl==ql&&tr==qr)return mx[p];
		int mid=tl+tr>>1;
		if(qr<=mid)return query(tl,mid,ql,qr,p<<1);
		else if(mid<ql)return query(mid+1,tr,ql,qr,p<<1|1);
		else return max(query(tl,mid,ql,mid,p<<1),query(mid+1,tr,mid+1,qr,p<<1|1));
	}
}lt,rt;
int lmx[SIZE],rmx[SIZE];
void prepare(){
	ID=-1,dis_mx=-1;
	find_ID(1,0,0);
	td[0]=ID;
	ID=-1,dis_mx=-1;
	find_ID(td[0],0,0);
	td[1]=ID;
	tot=0;
//	printf("ID %d %d\n",td[0],td[1]);
	sign(td[0],0);
	dfs(td[0],0,0,0);
	for(int i=1;i<=tot;i++){
		lmx[i]=mx_from_son[i]+i-1;
		rmx[i]=mx_from_son[i]+tot-i;
	}
	lt.build(lmx,1,tot,1);
	rt.build(rmx,1,tot,1);
}
inline void answer(){
	int u,v;rd(u);rd(v);
	int su=seg_fa[u],sv=seg_fa[v];
	int du=dis_to_seg[u],dv=dis_to_seg[v];
	if(su>sv)swap(su,sv),swap(du,dv);
	int ans=0;
	ans=max(ans,min(du+(su-1),dv+(sv-1)));
	ans=max(ans,min(du+(tot-su),dv+(tot-sv)));
//	int mid=su+sv>>1;
	int mid=(su-du+sv+dv)>>1;
	if(mid<su)mid=su;
	if(mid>sv)mid=sv;
//	printf("query %d %d\n",su+1,mid);
//	printf("su %d mid %d query %d\n",su,mid,lt.query(1,tot,su+1,mid,1));
	if(su+1<=mid)ans=max(ans,lt.query(1,tot,su+1,mid,1)-(su-1)+du);
//	printf("process %d\n",ans);
	if(mid+1<=sv-1)ans=max(ans,rt.query(1,tot,mid+1,sv-1,1)-(tot-sv)+dv);
//	ans=max(ans,min(abs(mid-su),abs(mid-sv)));
	printf("%d\n",ans);
}
int main(){
	int size=128<<20;
	char *p=(char*)malloc(size)+size;
	__asm__("movl %0, %%esp\n" :: "r"(p));
//	freopen("tree05.in","r",stdin);
//	freopen("tree.out","w",stdout);
	input();
	prepare();
//	for(int i=1;i<=N;i++)printf("seg_id[%d] %d\n",i,seg_id[i]);
	scanf("%d",&M);
	while(M--)answer();
	return 0;
}
