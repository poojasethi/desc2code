#include <cstdio>
#include <vector>
using namespace std;

#define N 210000
struct aa {
	int a, b, c;
	aa() {
	}
	aa(int _a, int _b, int _c) {
		a = _a;
		b = _b;
		c = _c;
	}
};
int len, a, b, i, n, m, x, y, Time, to[N], ma[N * 2], delta[N * 2], L[N], R[N], h[N], ans[N], next[N], till[N], go[N], fa[N][21];
vector <aa> ve[N];

void add(int x, int y) {
	next[++len] = till[x];
	till[x] = len;
	go[len] = y;
}

void dfs(int k, int ff) {
	h[k] = h[ff] + 1;
	L[k] = ++Time;
	to[Time] = h[k] - 1;
	fa[k][0] = ff;
	for (int i = 1; i <= 20; i++)	fa[k][i] = fa[fa[k][i - 1]][i - 1];
	for (int i = till[k]; i; i = next[i])	if (go[i] != ff)	dfs(go[i], k);
	R[k] = Time;
}

int lca(int x, int y) {
	for (int i = 20; i >= 0; i--)	if (h[fa[x][i]] >= h[y])	x = fa[x][i];
	if (x == y)	return x;
	for (int i = 20; i >= 0; i--)	if (fa[x][i] != fa[y][i])	x = fa[x][i], y = fa[y][i];
	return fa[x][0];
}

void update(int k) {
	ma[k] = max(ma[k * 2] + delta[k * 2], ma[k * 2 + 1] + delta[k * 2 + 1]);
}

void mkt(int k, int q, int h) {
	if (q < h) {
		mkt(k * 2, q, (q + h) / 2);
		mkt(k * 2 + 1, (q + h) / 2 + 1, h);
		update(k);
	}else	ma[k] = to[q];
}

void modify(int k, int q, int h, int l, int r, int d) {
	if (l <= q && h <= r)	delta[k] += d;
	else {
		if (r <= (q + h) / 2)	modify(k * 2, q, (q + h) / 2, l, r, d);
		else	if ((q + h) / 2 < l)	modify(k * 2 + 1, (q + h) / 2 + 1, h, l, r, d);
		else	modify(k * 2, q, (q + h) / 2, l, r, d), modify(k * 2 + 1, (q + h) / 2 + 1, h, l, r, d);
		update(k);
	}
}

int query(int k, int q, int h, int l, int r) {
	if (l <= q && h <= r)	return ma[k] + delta[k];
	else	if (r <= (q + h) / 2)	return query(k * 2, q, (q + h) / 2, l, r) + delta[k];
	else	if ((q + h) / 2 < l)	return query(k * 2 + 1, (q + h) / 2 + 1, h, l, r) + delta[k];
	else	return max(query(k * 2, q, (q + h) / 2, l, r), query(k * 2 + 1, (q + h) / 2 + 1, h, l, r)) + delta[k];
}

int Query(int x, int y) {
	int ans = 0;
	if (!y)	return query(1, 1, n, L[x], R[x]);
	else {
		if (1 < L[x])	ans = max(ans, query(1, 1, n, 1, L[x] - 1));
		if (R[x] < n)	ans = max(ans, query(1, 1, n, R[x] + 1, n));
		return ans;
	}
}

void Modify(int l, int r, int d) {
	modify(1, 1, n, l, r, -d);
	if (l > 1)	modify(1, 1, n, 1, l - 1, d);
	if (r < n)	modify(1, 1, n, r + 1, n, d);
}

void dfs1(int k, int fa) {
	for (int i = 0; i < (int) ve[k].size(); i++)
		ans[ve[k][i].a] = max(ans[ve[k][i].a], Query(ve[k][i].c, ve[k][i].b));
	for (int i = till[k]; i; i = next[i])
		if (go[i] != fa) {
			Modify(L[go[i]], R[go[i]], 1);
			dfs1(go[i], k);
			Modify(L[go[i]], R[go[i]], -1);
		}
}

int main() {
	scanf("%d", &n);
	for (i = 1; i < n; i++) {
		scanf("%d%d", &a, &b);
		add(a, b);
		add(b, a);
	}
	dfs(1, 0);
	scanf("%d", &m);
	for (i = 1; i <= m; i++) {
		scanf("%d%d", &x, &y);
		if (h[x] < h[y])	swap(x, y);
		int z = lca(x, y), hh = h[x] - h[z] + h[y] - h[z], xx = x;
		hh = h[x] - ((hh - 1) / 2);
		for (int j = 20; j >= 0; j--)	if (h[fa[xx][j]] >= hh)	xx = fa[xx][j];
		ve[x].push_back(aa(i, 0, xx));
		ve[y].push_back(aa(i, 1, xx));
	}
	mkt(1, 1, n);
	dfs1(1, 0);

	for (i = 1; i <= m; i++)	printf("%d\n", ans[i]);
}
