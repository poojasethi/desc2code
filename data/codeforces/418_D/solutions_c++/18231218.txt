#include<cstdio>
#include<algorithm>
#include<cstring>
#define CLR(x,f) memset(x,f,sizeof(x))
using namespace std;
const int M=100005;
void Max(int &x,int y){
	if(x<y)x=y;
}
int n,m;
int dep[M];
int nxt[M][18];//fa[i]
int mx1[M][18];//mx[i]-dep[i]+(M)
int mx2[M][18];//mx[i]+dep[i]
int last[M],allc;
struct Edge{
	int to,nxt;
}e[M<<1];
void ins(int u,int v){
	e[++allc]=(Edge){v,last[u]};last[u]=allc;
}
struct node{
	int v,w;
	bool operator<(const node&a)const{
		if(w!=a.w)return w>a.w;
		return v>a.v;
	}
}mx[M][4];
void update(int x,int v,int w){
	mx[x][3]=(node){v,w};
	sort(mx[x],mx[x]+4);
}
int query_mx(int x,int v,int u=-1){
	for(int i=0;i<3;i++){
		if(mx[x][i].v!=v&&mx[x][i].v!=u)
			return mx[x][i].w;
	}
}
void dfs1(int x,int f){
	dep[x]=dep[f]+1;
	update(x,x,0);
	nxt[x][0]=f;
	for(int i=0;nxt[x][i];i++)
		nxt[x][i+1]=nxt[nxt[x][i]][i];
	for(int y,i=last[x];i;i=e[i].nxt){
		y=e[i].to;
		if(y==f)continue;
		dfs1(y,x);
		update(x,y,mx[y][0].w+1);
	}
}
void dfs2(int x){
	int res=0,f=nxt[x][0];
	if(f){
		res=query_mx(f,x,nxt[f][0]);
		mx1[x][0]=res-dep[f]+M;
		mx2[x][0]=res+dep[f];
	}
	for(int i=0;nxt[x][i];i++){
		mx1[x][i+1]=max(mx1[x][i],mx1[nxt[x][i]][i]);
		mx2[x][i+1]=max(mx2[x][i],mx2[nxt[x][i]][i]);
	}
	for(int y,i=last[x];i;i=e[i].nxt){
		y=e[i].to;
		if(y==f)continue;
		update(y,x,query_mx(x,y)+1);
		dfs2(y);//不含子树y的点到x的最远距离 
	}
}
void init(){
	dfs1(1,0);
	dfs2(1);
}
int raise(int x,int y){
	for(int i=0;i<18;i++)
		if(y&(1<<i))
			x=nxt[x][i];
	return x;
}
int lca(int u,int v){
	if(dep[u]<dep[v])swap(u,v);
	u=raise(u,dep[u]-dep[v]);
	if(u==v)return u;
	for(int i=17;i>=0;i--){
		if(nxt[u][i]!=nxt[v][i]){
			u=nxt[u][i];
			v=nxt[v][i];
		}
	}return nxt[u][0];
}
int query_down(int x,int h){
	int ans=0;
	for(int i=17;i>=0;i--)
		if(h&(1<<i)){
			Max(ans,mx1[x][i]);
			x=nxt[x][i];
		}
	return ans;
}
int query_up(int x,int h){
	int ans=0;
	for(int i=17;i>=0;i--)
		if(h&(1<<i)){
			Max(ans,mx2[x][i]);
			x=nxt[x][i];
		}
	return ans;
}
int ask(int u,int v){
	int w=lca(u,v),a=-1,b=-1,mid,dis,ans,res,tmp;
	
	if(dep[u]<dep[v])swap(u,v);//low u high v
	
	if(v!=w)a=raise(v,dep[v]-dep[w]-1);
	if(u!=w)b=raise(u,dep[u]-dep[w]-1);
	
	dis=dep[u]+dep[v]-(dep[w]<<1);
	mid=raise(u,dis-1>>1);
	
	ans=query_mx(u,nxt[u][0]);
	if(v!=w)Max(ans,query_mx(v,nxt[v][0]));
	
	Max(ans,dep[v]-dep[w]+query_mx(w,a,b));
	
	if(dep[u]>dep[mid]){
		res=query_down(u,dep[u]-dep[mid]);
		Max(ans,res+dep[u]-M);
	}
	
	if(dep[mid]>dep[w]+1){
		res=query_up(mid,dep[mid]-dep[w]-1);
		Max(ans,dep[v]+res-(dep[w]<<1));
	}
	
	if(dep[v]>dep[w]+1){
		res=query_down(v,dep[v]-dep[w]-1);
		Max(ans,res+dep[v]-M);
	}
	return ans;
}
int main(){

	scanf("%d",&n);
	for(int u,v,i=1;i<n;++i){
		scanf("%d%d",&u,&v);
		ins(u,v);ins(v,u);
	}
	init();
	scanf("%d",&m);
	for(int u,v,i=1;i<=m;i++){
		scanf("%d%d",&u,&v);
		printf("%d\n",ask(u,v));
	}
	return 0;
}