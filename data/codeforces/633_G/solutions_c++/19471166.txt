#include<cstdio>
#include<cstring>
#include<iostream>
#include<bitset>
#include<vector>
using namespace std;
const int maxn=1e5+5;
const int M=1005;
int seq[maxn],mark[M],n,m,R[maxn],L[maxn],tot=0,T=0,A[maxn];
inline void rd(int &res){
	int k=1;char c;
	res=0;
	while(c=getchar(),c<48);
	do res=(res<<1)+(res<<3)+(c^48);
	while(c=getchar(),c>=48);
}
inline void print(int x){
	if(x==0)return ;
	print(x/10);
	putchar((x%10)^48);
}
inline void sc(int x){
	if(x==0)putchar('0');
	else print(x);
	putchar('\n');
}
struct node{
	bitset<M>f;
	int add; 
}t[maxn<<2];//
bitset<M>res,prime;
vector<int>e[maxn]; 
void init(){
	for(int i=2;i<m;i++){
		if(!mark[i]){
			prime.set(i);
			for(int j=i+i;j<m;j+=i)mark[j]=1;
		}
	}
}
void dfs(int x,int f){
	L[x]=++T;
	seq[T]=A[x];
	for(int i=0;i<e[x].size();i++){
		if(e[x][i]!=f)dfs(e[x][i],x);
	}
	R[x]=T;
}
void Add(int &x,int y){
	x+=y;if(x>=m)x-=m;
}
void modify(int p,int x){//�������ڵ���+x
	t[p].f=((t[p].f<<x)|(t[p].f>>(m-x)));
}
void down(int p){
	if(!t[p].add)return ;
	Add(t[p<<1].add,t[p].add);
	Add(t[p<<1|1].add,t[p].add);
	modify(p<<1,t[p].add);
	modify(p<<1|1,t[p].add);
	t[p].add=0;	
}
void up(int p){
	t[p].f=t[p<<1].f|t[p<<1|1].f;
}
void build(int l,int r,int p){
	if(l==r){
		t[p].f.set(seq[l]);
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,p<<1);
	build(mid+1,r,p<<1|1);
	up(p);
}
void update(int L,int R,int l,int r,int x,int p){
	if(L==l&&R==r){
		modify(p,x);
		Add(t[p].add,x);
		return;
	}
	down(p);
	int mid=L+R>>1;
	if(r<=mid)update(L,mid,l,r,x,p<<1);
	else if(l>mid)update(mid+1,R,l,r,x,p<<1|1);
	else update(L,mid,l,mid,x,p<<1),update(mid+1,R,mid+1,r,x,p<<1|1);
	up(p);
}
void query(int L,int R,int l,int r,int p){
	if(L==l&&R==r){res|=t[p].f;return ;}
	down(p);
	int mid=(L+R)>>1;
	if(r<=mid)query(L,mid,l,r,p<<1);
	else if(l>mid)query(mid+1,R,l,r,p<<1|1);
	else query(L,mid,l,mid,p<<1),query(mid+1,R,mid+1,r,p<<1|1);
}
int main(){
	int Q,a,b,c,ans=0;
	rd(n);rd(m);
	init();
	for(int i=1;i<=n;i++){
		rd(A[i]);A[i]%=m;
	}
	for(int i=1;i<n;i++){
		rd(a);rd(b);
		e[a].push_back(b);
		e[b].push_back(a);
	}
	dfs(1,1);
	build(1,n,1);
	rd(Q);
	while(Q--){
		rd(a);rd(b);
		if(a==1)rd(c),update(1,n,L[b],R[b],c%m,1);
		else {
			res.reset();
			ans=0;
			query(1,n,L[b],R[b],1);
			ans=(res&prime).count();
			sc(ans);
		}
	}
	return 0;
}
