#include<bits/stdc++.h>
using namespace std;
bitset<1001> tree[400010];
int val[400010],dat[100010],m,in[100010],out[100010],data[100010],cnt=0;
vector<int> g[100010];
void build(int nodeno,int l,int r)
{
	if(l==r)
	{
		tree[nodeno][dat[l]]=1;
		return;
	}
	int mid=(l+r)/2;
	build(2*nodeno,l,mid);
	build(2*nodeno+1,mid+1,r);
	tree[nodeno]=tree[2*nodeno]|tree[2*nodeno+1];
}
void push(int nodeno)
{
	if(val[nodeno]!=0)
	{
		val[2*nodeno]=(val[2*nodeno]+val[nodeno])%m;val[2*nodeno+1]=(val[2*nodeno+1]+val[nodeno])%m;
		tree[nodeno]=tree[nodeno]<<val[nodeno]|tree[nodeno]>>(m-val[nodeno]);
		val[nodeno]=0;	
	}
}
void update(int nodeno,int tl,int tr,int l,int r,int add)
{//printf("1-->%d %d %d %d %d %d\n",nodeno,tl,tr,l,r,add);
	if(tl==l && tr==r)
	{
		//printf("returning\n");
		val[nodeno]=(val[nodeno]+add)%m;
		return;
	}//printf("%d %d %d %d %d %d\n",nodeno,tl,tr,l,r,add);
	push(nodeno);
	
	int mid=(tl+tr)/2;
	if(r<=mid)
	update(2*nodeno,tl,mid,l,r,add);
	else if(l>mid)
	update(2*nodeno+1,mid+1,tr,l,r,add);
	else 
	{
		update(2*nodeno,tl,mid,l,mid,add);
		update(2*nodeno+1,mid+1,tr,mid+1,r,add);
	}
	tree[nodeno]=(tree[2*nodeno]<<val[2*nodeno]|tree[2*nodeno]>>(m-val[2*nodeno]))|
				 (tree[2*nodeno+1]<<val[2*nodeno+1]|tree[2*nodeno+1]>>(m-val[2*nodeno+1]));
}
bitset<1001> query(int nodeno,int tl,int tr,int l,int r)
{
	if(tl==l && tr==r)
	{
		if(val[nodeno]==0)return tree[nodeno];
		else return ((tree[nodeno]<<val[nodeno])|(tree[nodeno]>>(m-val[nodeno])));
	}//printf("%d %d %d %d %d\n",nodeno,tl,tr,l,r);
	push(nodeno);
	int mid=(tl+tr)/2;
	if(r<=mid)return query(2*nodeno,tl,mid,l,r);
	else if(l>mid) return query(2*nodeno+1,mid+1,tr,l,r);
	else
	{
		return (query(2*nodeno,tl,mid,l,mid)|query(2*nodeno+1,mid+1,tr,mid+1,r));
	}
}
void dfs(int u,int fa)
{
	in[u]=cnt++;
	dat[in[u]]=data[u];
	for(int i=0;i<g[u].size();i++)
	if(fa!=g[u][i])dfs(g[u][i],u);
	out[u]=cnt;
}
main()
{
	int i,j,u,v,q,n,type,x,t,isprm[1010];
	scanf("%d %d",&n,&m);
	bitset<1001> prm;
	for(i=0;i<m;i++)prm[i]=1;prm[0]=prm[1]=0;
	for(i=2;i<=32;i++)
	{
		if(i<m && prm[i]==1)
		{
		for(j=2*i;j<m;j+=i)
		prm[j]=0;
		}
	}
	for(i=1;i<=n;i++)
	{
		scanf("%d",&t);data[i]=t%m;
	}
	for(i=1;i<=n-1;i++)
	{
		scanf("%d%d",&u,&v);
		g[u].push_back(v);g[v].push_back(u);
	}
	dfs(1,-1);//printf("pass1\n");
	build(1,0,n-1);//printf("pass2\n");
	scanf("%d",&q);
	for(i=0;i<q;i++)
	{
		scanf("%d",&type);
		if(type==1)
		{//printf("int tye1\n");
			scanf("%d%d",&v,&x);
			update(1,0,n-1,in[v],out[v]-1,x%m);
		}
		else
		{//printf("in type 2\n");
			scanf("%d",&v);//printf("inv=%d outv=%d\n",in[v],out[v]-1);
			//for(i=0;i<m;i++)cout<<prm[i];printf("\n");
			printf("%d\n",(query(1,0,n-1,in[v],out[v]-1)&prm).count());
		}
	}
}