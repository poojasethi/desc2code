#include <bits/stdc++.h>
using namespace std;
#define dprint(v) cerr << #v"=" << v << endl //;)
#define forr(i,a,b) for(int i=(a); i<(b); i++)
#define forn(i,n) forr(i,0,n)
#define dforn(i,n) for(int i=n-1; i>=0; i--)
#define forall(it,v) for(typeof(v.begin()) it=v.begin();it!=v.end();++it)
#define sz(c) ((int)c.size())
#define zero(v) memset(v, 0, sizeof(v))
#define fst first
#define snd second
#define mkp make_pair
#define pb push_back
typedef long long ll;
typedef pair<int,int> ii;

const int MAXN=100010;
int n,m,q,a[MAXN],f[MAXN],e[MAXN],r[MAXN],rc;
vector<int> G[MAXN];
bitset<1000> bmask;
typedef bitset<1000> Elem;
typedef int Alt;
#define operacion(x,y) ((x)|(y))
#define norm(x) ((x)&bmask)
const Elem neutro; const Alt neutro2=0;
#define MAXN 100000
struct RMQ{
	int sz;
	Elem t[4*MAXN];
	Alt dirty[4*MAXN];//las alteraciones pueden ser de distinto Elem
	Elem &operator[](int p){return t[sz+p];}
	void init(int n){//O(nlgn)
		sz = 1 << (32-__builtin_clz(n));
		forn(i, 2*sz) t[i]=neutro;
		forn(i, 2*sz) dirty[i]=neutro2;
	}
	void push(int n){//propaga el dirty a sus hijos
		if(dirty[n]!=0){
			t[n] = norm( operacion(t[n]<<dirty[n],t[n]>>(m-dirty[n])) );
			if(n<sz){
				dirty[2*n]=(dirty[n]+dirty[2*n])%m;
				dirty[2*n+1]=(dirty[n]+dirty[2*n+1])%m;
			}
			dirty[n]=0;
		}
	}
	Elem get(int i, int j, int n, int a, int b){//O(lgn)
		if(j<=a || i>=b) return neutro;
		push(n);//corrige el valor antes de usarlo
		if(i<=a && b<=j) return t[n];
		int c=(a+b)/2;
		return operacion(get(i, j, 2*n, a, c), get(i, j, 2*n+1, c, b));
	}
	Elem get(int i, int j){return get(i,j,1,0,sz);}
	//altera los valores en [i, j) con una alteracion de val
	void alterar(Alt val, int i, int j, int n, int a, int b){//O(lgn)
		push(n);
		if(j<=a || i>=b) return;
		if(i<=a && b<=j){
			dirty[n]+=val;
			push(n);
			return;
		}
		int c=(a+b)/2;
		alterar(val, i, j, 2*n, a, c), alterar(val, i, j, 2*n+1, c, b);
		t[n]=operacion(t[2*n], t[2*n+1]);//por esto es el push de arriba
	}
	void alterar(Alt val, int i, int j){alterar(val,i,j,1,0,sz);}
	void aset(int p, int pos){//O(lgn)
		for(p+=sz; p>0 ;){
			t[p].set(pos,true);
			p/=2;
		}
	}
}rmq;

void dfs (int v, int p=-1) {
	r[rc]=v;
	f[v]=rc;
	rc++;
	forall(it,G[v]) if (*it!=p) dfs(*it,v);
	e[v]=rc;
}

int prime[1000],pc;

int main() {
	pc=0;
	forr(i,2,1000) {
		int count=0;
		forr(j,1,i+1) count += (i%j==0);
		if (count==2) prime[pc++]=i;
	}
	//~ freopen("in", "r", stdin);
    ios::sync_with_stdio(0);
    while(scanf("%d %d",&n,&m)>0) {
		rmq.init(n);
		forn(i,m) bmask.set(i);
		forn(i,n) { scanf("%d",a+i); 
			a[i]%=m;
		}
		forn(i,n-1) { int a,b; scanf("%d %d",&a,&b); a--; b--;
			G[a].pb(b); G[b].pb(a);
		}
		rc=0; dfs(0);
		forn(v,n) rmq.aset(f[v],a[v]);
		scanf("%d",&q);
		forn(_,q) { int op,v; scanf("%d %d",&op,&v); v--;
			if (op==1) { int x; scanf("%d",&x);
				rmq.alterar(x%m,f[v],e[v]);
			} else {
				bitset<1000> r = norm(rmq.get(f[v],e[v]));
				int count = 0;
				forn(i,pc) if (prime[i]<m && r.test(prime[i])) count++;
				printf("%d\n",count);
			}
			
		}
		
	}
	return 0;
}
