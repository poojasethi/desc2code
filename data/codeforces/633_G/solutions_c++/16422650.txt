#include <bits/stdc++.h>

using namespace std;

#define pb push_back
#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)
#define endl '\n'
#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)
#define mp make_pair
#define nd second
#define st first
#define type(x) __typeof(x.begin())

typedef pair < int ,int > pii;

typedef long long ll;

const long long linf = 1e18+5;
const int mod = (int) 1e9 + 7;
const int logN = 17;
const int inf = 1e9;
const int N = 1e5 + 5;

int n, m, x, y, a[N], start[N], finish[N], T, L[N << 2], t, q;
bitset<1000> all, primes, ST[N << 2], ans;
vector< int > v[N];

void init(int k, int bas, int son) {
	if(bas == son) { ST[k][0] = 1; return ; }
	init(sol, bas, orta);
	init(sag, orta + 1, son);
	ST[k] = ST[sol] | ST[sag];
}

void push(int k) {
	L[k] %= m;
	int t = L[k]; 
	ST[sol] = (ST[sol] << t) | (ST[sol] >> (m - t));
	ST[sag] = (ST[sag] << t) | (ST[sag] >> (m - t));
	L[sol] += t; L[sag] += t;
	L[sol] %= m; L[sag] %= m;
	L[k] = 0;	
}

void query(int k, int bas, int son, int x, int y) {
	if(bas > y || son < x) return ;
	if(x <= bas && son <= y) {
		ans |= ST[k];
		return ;
	} push(k);
	query(sol, bas, orta, x, y);
	query(sag, orta + 1, son, x, y);
}

void update(int k, int bas, int son, int x, int y, int t) {
	if(bas > y || son < x) return ;
	if(x <= bas && son <= y) {
		t %= m;
		ST[k] = ((ST[k] << t) | (ST[k] >> (m - t)));
		L[k] += t;
		L[k] %= m;
		return ;
	} push(k);
	update(sol, bas, orta, x, y, t);
	update(sag, orta + 1, son, x, y, t);
	ST[k] = ST[sol] | ST[sag];
}

void dfs(int node, int root) {
	start[node] = ++T;
	update(1, 1, n, start[node], start[node], a[node]);
	foreach(it, v[node]) {
		if(*it != root) {
			dfs(*it, node);
		}
	} finish[node] = T;
}

int main() {

	scanf("%d %d", &n, &m);
	
	if(m >= 3) primes[2] = 1;
	FOR(i, 3, m - 1) {
		primes[i] = 1;
		for(int j = 2; j < i; j++)
			if(i % j == 0) {
				primes[i] = 0;
				break;
			}
	}

	FOR(i, 1, n) {
		scanf("%d", &a[i]);
		a[i] %= m;
	}
	
	FOR(i, 2, n) {
		scanf("%d %d", &x, &y);
		v[x].pb(y);
		v[y].pb(x);
	}
	
	init(1, 1, n);
	dfs(1, 0);

	scanf("%d", &q);

	FOR(i, 1, q) {
		scanf("%d %d", &t, &x);
		if(t == 2) {
			ans.reset();
			query(1, 1, n, start[x], finish[x]);
			ans &= primes;
			printf("%d\n", (int) ans.count());
		}
		else {
			scanf("%d", &y);
			update(1, 1, n, start[x], finish[x], y);
		}
	}

	return 0;
}
