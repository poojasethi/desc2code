#include <iostream>
#include <bitset>
#include <vector>
#include <cmath>
#include <cstdio>
using namespace std;

vector<int> G[100001];
int Eu[100001], d[100001], fin[100001], Time = 0;
bitset<1000> T[500000]; int L[500000];
bitset<1000> Get[1001], Left[1001];
int A[100001];
int N, M;

void operator*=(bitset<1000>& bs, int r) {
    if (!r) return;
    int left = M - r; bs = (((bs & Get[r]) >> left) | ((bs << r) & Get[M]));
}

#define mid ((l + r) >> 1)
void init(int v, int l, int r) {
    if (l == r) { T[v].set(A[Eu[l]] % M, 1); return; }
    init(2 * v, l, mid); init(2 * v + 1, mid + 1, r);
    T[v] = T[2 * v] | T[2 * v + 1];
}
void lazy(int v, int l, int r) {
    if (!L[v]) return;
    if (l != r) { L[2 * v] = (L[v] + L[2 * v]) % M; L[2 * v + 1] = (L[v] + L[2 * v + 1]) % M; }
    T[v] *= L[v]; L[v] = 0;
}
void up(int v, int l, int r, int i, int j, int val) {
    lazy(v, l, r);
    if (l > j || r < i) return;
    if (i <= l && r <= j) { L[v] = (L[v] + val) % M; lazy(v, l, r); return; }
    up(2 * v, l, mid, i, j, val); up(2 * v + 1, mid + 1, r, i, j, val);
    T[v] = T[2 * v] | T[2 * v + 1];
}
bitset<1000> get(int v, int l, int r, int i, int j) {
    lazy(v, l, r);
    if (l > j || r < i) return Get[0];
    if (i <= l && r <= j) return T[v];
    return (get(2 * v, l, mid, i, j) | get(2 * v + 1, mid + 1, r, i, j));
}
#undef mid

void dfs(int v, int par = 0) {
    d[v] = ++Time; Eu[Time] = v;
    for (int i = 0; i < (int)G[v].size(); ++i) {
        int u = G[v][i]; if (u == par) continue;
        dfs(u, v);
    } fin[v] = Time;
}

bool isPrime(int x) {
    if (x == 2) return 1;
    if (x % 2 == 0) return 0;
    for (int i = 3; i * i <= x; i += 2) if (x % i == 0) return 0;
    return 1;
}
vector<int> Pr;

int main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    cin >> N >> M;
    for (int i = 1; i <= M; ++i) Get[i] = Get[i - 1], Get[i].set(M - i, 1), Left[i] = Left[i - 1], Left[i].set(i - 1, 1);
    for (int i = 2; i < M; ++i) if (isPrime(i)) Pr.push_back(i);
    for (int i = 1; i <= N; ++i) cin >> A[i];
    for (int i = 1; i < N; ++i) {
        int u, v; cin >> u >> v; G[v].push_back(u); G[u].push_back(v);
    }
    dfs(1);
    init(1, 1, N);
    int q; cin >> q;
    while (q--) {
        int typ, u, v;
        cin >> typ >> u;
        if (typ == 1) { cin >> v; up(1, 1, N, d[u], fin[u], v); }
        else {
            bitset<1000> g = get(1, 1, N, d[u], fin[u]);
            int cnt = 0;
            for (int i = 0; i < (int)Pr.size(); ++i) cnt += g[Pr[i]];
            printf("%d\n", cnt);
        }
    }
}
