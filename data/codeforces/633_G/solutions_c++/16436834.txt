#pragma comment(linker, "/STACK:1024000000,1024000000")
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath>
#include <ctime>
#include <iostream>
#include <vector>
#include <queue>
#include <iomanip>
#include <algorithm>
#include <set>
#include <map>
#include <bitset>
#define LL long long
#define ULL unsigned long long 
#define INF 1<<30 
#define Mod 1000000009
#define PII pair<int,int>
#define mk make_pair
#define Min(a,b) (a<b?a:b)
#define Max(a,b) (a<b?b:a) 
using namespace std; 
const double PI=acos(-1.0);
const double EPS=1e-12;

inline int read() {
	static char ch;
	bool sgn = false;
	while (ch = getchar(), ch < '0' || ch > '9') if (ch == '-') sgn = true;
	int res = ch - 48;
	while (ch = getchar(), ch >= '0' && ch <= '9') res = res * 10 + ch - 48;
	return sgn ? -res : res;
}

const int N=1e5+5;

struct tree {
	bitset<1000> b;
	int l,r;	
	int add;
} t[N*4];

int n,m,cnt,a[N],in[N],out[N];
vector<int> E[N];
bitset<1000> prime,all,ans;

void dfs(int x,int f) {
	in[x]=++cnt;
	for(int i=0;i<E[x].size();i++) {
		int y=E[x][i];
		if(y==f) continue;
		dfs(y,x);
	}
	out[x]=cnt;
}

void build(int k,int l,int r) {
	t[k].l=l; t[k].r=r;
	t[k].b[0]=1; t[k].add=0;
	if(l==r) return;
	int mid=(l+r)>>1;
	build(k<<1,l,mid); build((k<<1)+1,mid+1,r);	
}

void cal(int k,int v) {
	t[k].add+=v;
	t[k].add%=m;
	bitset<1000> B=t[k].b;
	B=(B<<v)&all;
	B=B|(t[k].b>>(m-v));
	t[k].b=B;
}

void push_down(int k) {
	if(t[k].l==t[k].r) return;
	if(t[k].add) {
		int add=t[k].add;
		t[k].add=0;
		cal(k<<1,add);
		cal((k<<1)+1,add);
	}
}

void update(int k) {
	t[k].b=t[(k<<1)+1].b|t[k<<1].b;	
}

void ins(int k,int l,int r,int v) {
	push_down(k);
	if(t[k].l>r||t[k].r<l) return;
	if(t[k].l>=l&&t[k].r<=r) {
		cal(k,v);
		return;
	} 
	ins(k<<1,l,r,v); ins((k<<1)+1,l,r,v);
	update(k);
}

void query(int k,int l,int r) {  
	push_down(k);
	if(t[k].l>r||t[k].r<l) return;
	if(t[k].l>=l&&t[k].r<=r) {
		ans=ans|t[k].b;
		return;
	}
	query(k<<1,l,r); query((k<<1)+1,l,r);
}

bool bo[1005];

int main() {
	n=read(),m=read();
	for(int i=0;i<m;i++) all[i]=1;
	for(int i=2;i<m;i++) {
		if(!bo[i]) {
			prime[i]=1;
			for(int j=i;j<=m;j+=i) bo[j]=1;
		}
	}
	for(int i=1;i<=n;i++) a[i]=read(),a[i]%=m; 
	for(int i=1;i<n;i++) {
		int  u=read(),v=read();
		E[u].push_back(v);
		E[v].push_back(u);
	}
	dfs(1,0); 
	build(1,1,n);
	for(int i=1;i<=n;i++) ins(1,in[i],in[i],a[i]);
	int q=read();
	while(q--) {
		int p=read();
		if(p==1) {
			int v=read(),x=read(); x%=m;
			ins(1,in[v],out[v],x);
		} else {
			int v=read();
			ans=0; 
			query(1,in[v],out[v]);
			ans=ans&prime;
			printf("%d\n",(int)ans.count());
		}
	}
}
