#include<iostream>
#include<algorithm>

#define rep(i,n) for(int i=0;i<(n);i++)

using namespace std;

typedef long long     ll;
typedef pair<int,int> pii;

const ll INF=1LL<<61;

struct Subject{
    ll a,b;
    int c,id;
    bool operator<(const Subject &S)const{ return c<S.c; }
};

int main(){
    int n,m,K; cin>>n>>m>>K;
    Subject S[50];
    rep(i,m){
        cin>>S[i].a>>S[i].b>>S[i].c;
        S[i].id=i;
    }

    sort(S,S+m);

    static ll dp[50][101][50];
    static pii path[50][101][50];
    rep(i,m) rep(j,101) rep(t,n) dp[i][j][t]=-INF;
    rep(i,m) rep(j,S[i].b-S[i].a+1) dp[i][j][0]=S[i].a+j;
    rep(i,m-1) rep(t,n-1) {
        rep(j,S[i+1].b-S[i+1].a+1){
            ll task=S[i+1].a+j;
            rep(w,2){
                // w==0 : plus K
                // w==1 : multiply K
                if(w==1 && task%K!=0) continue;
                ll pretask=(w==0?task-K:task/K);

                for(int k=0;S[k].c<S[i+1].c;k++){
                    if(S[k].a<=pretask && pretask<=S[k].b){
                        int l=pretask-S[k].a;
                        if(dp[i+1][j][t+1]<dp[k][l][t]+task){
                            dp[i+1][j][t+1]=dp[k][l][t]+task;
                            path[i+1][j][t+1]=make_pair(k,l);
                        }
                    }
                }
            }
        }
    }

    ll ans=-INF;
    int i_ans,j_ans;
    rep(i,m) rep(j,101) if(ans<dp[i][j][n-1]) {
        ans=dp[i][j][n-1];
        i_ans=i;
        j_ans=j;
    }

    cout<<(ans>=0?"YES":"NO")<<endl;
    if(ans<0) return 0;

    int ans2[100],ans3[100];
    for(int t=n-1;t>=0;t--){
        ans2[t]=i_ans;
        ans3[t]=j_ans;

        pii tmp=path[i_ans][j_ans][t];
        i_ans=tmp.first;
        j_ans=tmp.second;
    }

    rep(i,n) cout<<(S[ans2[i]].id+1)<<' '<<(S[ans2[i]].a+ans3[i])<<endl;

    return 0;
}
