#include <stdio.h>
#include <algorithm>

using namespace std;

#define N 55
typedef pair<int,int> ppair;

FILE *in=stdin;
FILE *out=stdout;

int n,m;
__int64 k;
__int64 check[N][N][105];
ppair path[N][N][105];

struct data
{
	__int64 x,y,c;
	int num;
}a[N];

void output(int t, int l, int i)
{
	if(i>1) output(path[i][t][l].first,path[i][t][l].second,i-1);
	fprintf(out,"%d %I64d\n",a[t].num,a[t].x+l);
}

void process()
{
	int i,j,l,o,tt=0,tl=0;
	__int64 x;
	for(i=1;i<=m;i++)
	{
		for(j=0;j<=a[i].y-a[i].x;j++) check[1][i][j]=a[i].x+j;
	}
	for(i=1;i<n;i++)
	{
		for(j=1;j<=m;j++)
		{
			for(l=0;l<=a[j].y-a[j].x;l++)
			{
				if(check[i][j][l]==0) continue;
				for(o=j+1;o<=m;o++)
				{
					if(a[o].c==a[j].c) continue;
					
					x=a[j].x+l;
					if(x+k>=a[o].x && x+k<=a[o].y && check[i+1][o][x+k-a[o].x]<check[i][j][l]+x+k)
					{
						check[i+1][o][x+k-a[o].x]=check[i][j][l]+x+k;
						path[i+1][o][x+k-a[o].x]=make_pair(j,l);
					}
					if(x*k>=a[o].x && x*k<=a[o].y && check[i+1][o][x*k-a[o].x]<check[i][j][l]+x*k)
					{
						check[i+1][o][x*k-a[o].x]=check[i][j][l]+x*k;
						path[i+1][o][x*k-a[o].x]=make_pair(j,l);
					}
				}
			}
		}
	}

	x=-1;

	for(i=1;i<=m;i++)
	{
		for(j=0;j<=a[i].y-a[i].x;j++)
		{
			if(check[n][i][j]!=0)
			{
				if(x<check[n][i][j])
				{
					x=check[n][i][j];
					tt=i;
					tl=j;
				}			
			}
		}
	}
	if(x!=-1)
	{
		fprintf(out,"YES\n");
		output(tt,tl,n);
		return;
	}

	fprintf(out,"NO");
}

bool compare(data x, data y)
{
	return (x.c<y.c);
}

int main()
{
	int i;
	fscanf(in,"%d %d %d",&n,&m,&k);
	for(i=1;i<=m;i++) 
	{
		fscanf(in,"%I64d %I64d %I64d",&a[i].x,&a[i].y,&a[i].c);
		a[i].num=i;
	}
	sort(a+1,a+m+1,compare);
	process();
	fclose(in);
	fclose(out);
	return 0;
}