# Read input
n,m,k = map(int,raw_input().split())
a     = [map(int,raw_input().split())+[i+1] for i in range(m)]

# Format datastructure
a.sort(key=lambda x:x[2])
M     = a[-1][2]
P     = dict()
ind   = dict()

# Select the first valid interval after p
def valid (val,p,i):
    return [q for q in range (p+1,m-i+1) if a[q][0]<=val and val<=a[q][1]
                                        and a[p][2]<a[q][2] and a[q][2]<=M-i+1]

# Recursive function with memoization
def path (i,p,v):
    if P.has_key((i,p,v)): return P[i,p,v]
    if i==1:               return (v, None, None)

    val   = v+k
    ladd  = valid (val,p,i-1)
    madd  = path (i-1,ladd[0],val) if len(ladd)>0 else None
            
    val   = v*k
    lprod = valid (val,p,i-1)
    mprod = path (i-1,lprod[0],val) if len(lprod)>0 else None

    if   madd>mprod: P[i,p,v] = (madd[0] +v, ladd[0], v+k)
    elif mprod>madd: P[i,p,v] = (mprod[0]+v, lprod[0], v*k)
    else:            P[i,p,v] = None
    return P[i,p,v]

#
vals = set (sum ((range(a[i][0],a[i][1]+1) for i in range (m)), []))
for p in range(m):
    for v in range(a[p][0],a[p][1]+1):
        ind[v] = p if not ind.has_key(v) or p<ind[v] else ind[v]
seed = max ((path(n,ind[v],v),ind[v],v) for v in vals)

if seed[0]==None:
    print "NO"
else:
    print "YES"
    (s,p,v) = seed
    print a[p][3],v
    for i in range(n,1,-1):
        (s,p,v) = path(i,p,v)
        print a[p][3], v

