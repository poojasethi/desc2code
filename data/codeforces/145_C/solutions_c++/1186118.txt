#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;

typedef long long val_t;
const int MAX_N = 100000, MOD = 1000000007;
int n, p, s[MAX_N], m, now, pre;
val_t f[2][MAX_N + 1], ans;

bool islucky(int x) {
	while (x) {
		if (x % 10 != 4 && x % 10 != 7) return 0;
		x /= 10;
	}
	return 1;
}

void upt(val_t &x, val_t d) {
	x = (x + d) % MOD;
}

val_t power_mod(val_t a, val_t x) {
	if (!x) return 1LL;
	val_t ret = power_mod(a, x >> 1);
	ret = ret * ret % MOD;
	if (x & 1) ret = ret * a % MOD;
	return ret;
}

int main() {
	scanf("%d%d", &n, &p);
	for (int i = 0, x; i < n; i ++) {
		scanf("%d", &x);
		if (islucky(x)) s[m ++] = x;
	}
	sort(s, s + m);
	now = 0, pre = 1;
	f[now][0] = 1;
	for (int i = 0, j = 0, c = 0; i < m; i = j) {
		while (j < m && s[j] == s[i]) j ++;
		now ^= 1, pre ^= 1;
		for (int k = 0; k <= c; k ++) f[now][k] = f[pre][k];
		c ++;
		for (int k = 0; k < c; k ++) upt(f[now][k + 1], f[pre][k] * (j - i));	
	}
	val_t g = 1LL;
	for (int i = 0, x = n - m, y = 1; i <= p; i ++, x --, y ++) {
		if (p - i < 0) break;
		upt(ans, g * f[now][p - i]);
		g = g * x % MOD;
		if (y > 1) g = g * power_mod(y, MOD - 2) % MOD;
	}
	printf("%d\n", (int)ans);
}