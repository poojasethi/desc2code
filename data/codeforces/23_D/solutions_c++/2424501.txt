#include <cstdio>
#include <cmath>
#include <algorithm>

using namespace std;

const double eps = 1e-13;
int T;
struct point{double x, y;} A, B, C, D, K, L, M, O;

inline point operator + (const point &a, const point &b){
	point ret;
	ret.x = a.x + b.x; ret.y = a.y + b.y;
	return ret;
}

inline point operator - (const point &a, const point &b){
	point ret;
	ret.x = a.x - b.x; ret.y = a.y - b.y;
	return ret;
}

inline double operator * (const point &a, const point &b){
	return a.x * b.x + a.y * b.y;
}

inline point operator * (const point &a, const double b){
	point ret;
	ret.x = a.x * b; ret.y = a.y * b;
	return ret;
}

inline point operator / (const point &a, const double b){
	return a * (1 / b);
}

inline int cross(const point &a, const point &b){
	double ret = a.x * b.y - b.x * a.y;
	if (fabs(ret) < eps) return 0;
	if (ret > 0) return 1; else return -1;
}

bool check(point L, point K, point M){
	if (cross(K - L, L - M) == 0) return false;
	point sM = L + L - M, sK = K;
	point E = (L + sK) / 2, F = (L + sM) / 2, P = L - sK, Q = L - sM, U;
	double u = E * P, v = F * Q;
	if (fabs(Q.x) > eps){
		double k = P.x / Q.x;
		P = P - Q * k; u -= k * v;
		swap(P, Q); swap(u, v); swap(sK, sM);
	}
	U.y = v / Q.y;
	if (fabs(P.x) > eps) U.x = (u - P.y * U.y) / P.x;
	else Q = L - sM, v = F * Q, U.x = (v - Q.y * U.y) / Q.x;

	B = U; C = L + L - B; A = K + K - B; D = M + M - C;
	if (cross(B - A, C - B) != cross(C - B, D - C) || cross(C - B,  D - C) != cross(D - C, A - D) || cross(D - C, A - D) != cross(A - D, B - A)) return false;
	return true;
}

int main(){
	for (scanf("%d", &T); T--;){
		scanf("%lf%lf%lf%lf%lf%lf", &K.x, &K.y, &L.x, &L.y, &M.x, &M.y);
		if (check(L, K, M) || check(K, L, M) || check(M, K, L))
			printf("YES\n%.9lf %.9lf %.9lf %.9lf %.9lf %.9lf %.9lf %.9lf\n", A.x, A.y, B.x, B.y, C.x, C.y, D.x, D.y);
		else printf("NO\n\n");
	}
}
