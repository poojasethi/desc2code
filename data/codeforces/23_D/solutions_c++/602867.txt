#include <iostream>
#include <string>
#include <complex>

using namespace std;

typedef complex<double> point;

double prodesc(point p1,point p2)
{
  return real(conj(p1)*p2);
}

double prodvec(point p1,point p2)
{
  return imag(conj(p1)*p2);
}

double absolut(double x)
{
  if (x<0) return -x;
  return x;
}

double error=0.000000000001;

void escriu(point p)
{
  cout<<real(p)<<" "<<imag(p);
}

point llegeix()
{
  double x,y;
  cin>>x>>y;
  return point(x,y);
}

bool trobasol(point p1,point p2,point p3,
	      point &s1,point &s2,point &s3,point &s4)
{
  //escriu(p1);cout<<" ";escriu(p2);cout<<" ";escriu(p3);cout<<endl;
  point q1=(p1+p2)/2.0;
  point v1=(p2-p1)*point(0,1);
  //escriu(q1);cout<<" ";escriu(v1);cout<<endl;
  point q2=p2-(p3-p2)/2.0;
  point v2=(p3-p2)*point(0,1);
  //escriu(q2);cout<<" ";escriu(v2);cout<<endl;
  if (absolut(prodvec(v1,v2))<error) {
    return false;
  } else {
    //cout<<"hola"<<endl;
    double landa=prodvec(q2-q1,v2)/prodvec(v1,v2);
    s1=q1+landa*v1;
    s2=s1+2.0*(p2-s1);
    s3=s2+2.0*(p3-s2);
    s4=s1+2.0*(p1-s1);
    if ((prodvec(s2-s1,s3-s2)>error and
	 prodvec(s3-s2,s4-s3)>error and
	 prodvec(s4-s3,s1-s4)>error and
	 prodvec(s1-s4,s2-s1)>error) or
	(prodvec(s2-s1,s3-s2)<-error and
	 prodvec(s3-s2,s4-s3)<-error and
	 prodvec(s4-s3,s1-s4)<-error and
	 prodvec(s1-s4,s2-s1)<-error)) {
      return true;
    } else {
      return false;
    }
  }
}

int main()
{
  cout.setf(ios::fixed);
  cout.precision(9);
  int casos;
  cin>>casos;
  for (int cas=0;cas<casos;cas++) {
    point p1=llegeix();
    point p2=llegeix();
    point p3=llegeix();
    point s1,s2,s3,s4;
    if (trobasol(p1,p2,p3,s1,s2,s3,s4) or
	trobasol(p1,p3,p2,s1,s2,s3,s4) or
	trobasol(p2,p1,p3,s1,s2,s3,s4) or
	trobasol(p2,p3,p1,s1,s2,s3,s4) or
	trobasol(p3,p1,p2,s1,s2,s3,s4) or
	trobasol(p3,p2,p1,s1,s2,s3,s4)) {
      cout<<"YES"<<endl;
      escriu(s1);cout<<" ";escriu(s2);cout<<" ";escriu(s3);cout<<" ";
      escriu(s4);cout<<endl;
    } else {
      cout<<"NO"<<endl<<endl;
    }
  }
}

