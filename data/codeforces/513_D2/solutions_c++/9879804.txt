#include <cstdio>
#include <string>
#include <algorithm>
#include <vector>
#include <algorithm>
#include <cassert>
#include <cmath>
#include <queue>
#include <set>
#include <map>
#include <cassert>

#define fru(j,n) for(int j=0;j<n;++j)
#define tr(it,x) for(typeof(x.begin()) it=x.begin();it!=x.end();++it)
#define x first
#define y second
#define pb push_back

using namespace std;

typedef pair<int,int> pii;
typedef long long LL;

const int MAXN = 1000006;

int OGR[MAXN][3];

void NIE(){	puts("IMPOSSIBLE");	exit(0);}
vector<int> LE[MAXN],PR[MAXN],ANS;
int dfs(int u,int mus){
//zwraca ostatni potomek gdy poddrzewo u zawiera mus
	tr(it,LE[u]) if(*it<=u) NIE();
	tr(it,PR[u]) if(*it<=u) NIE();
	int le=-1,ri=MAXN;
	tr(it,LE[u]) le=max(le,*it);
	int tam=le==-1?u:dfs(u+1,le);
	ANS.pb(u);
	tr(it,PR[u]) ri=min(ri,*it);
	if(ri==MAXN && mus<=tam) return tam;
	if(ri<=tam) NIE();
	tr(it,PR[u]) mus=max(mus,*it);
	return dfs(tam+1,mus);
}
int main()
{
	char temp[123];
	int c,n;
	scanf("%d%d",&n,&c);
	fru(i,c){
		scanf("%d%d %s",&OGR[i][0],&OGR[i][1],temp);
		OGR[i][2]=temp[0]=='L';
	}
	fru(i,c) fru(j,2) OGR[i][j]--;
	fru(i,c) if(OGR[i][2]) LE[OGR[i][0]].pb(OGR[i][1]);
		   		      else PR[OGR[i][0]].pb(OGR[i][1]);
	dfs(0,n-1);
	tr(it,ANS) printf("%d ",*it+1); puts("");
  return 0;
}
