from math import *
from Queue import *

s = raw_input()
l = s.split(' ')
n = int(l[0])
m = int(l[1])
total = 0
dic = []
for i in range(m):
    s = raw_input()
    l = s.split(' ')
    dic.append([int(l[1]), int(l[0])])
for b in range(10, -1, -1):
    if n <= 0:
        break
    for i in range(m):
        if dic[i][0] == b:
            total += min(n, dic[i][1]) * b
            n -= dic[i][1]
            if n <= 0:
                break
print(total)


    



"""class segment(object):
    def __init__(self, x1, y1, x2, y2):
        self.ver, self.hor, self.point = False, False, False
        if x1 == x2:
            self.ver = True
        if y1 == y2:
            self.hor = True
        if (x1 == x2) and (y1 == y2):
            self.point = True
        minx = min(x1,x2)
        maxx = max(x1,x2)
        miny = min(y1,y2)
        maxy = max(y1,y2)
        self.x1 = minx
        self.x2 = maxx
        self.y1 = miny
        self.y2 = maxy

def rectangle(horseg, verseg):
    if (horseg[0].x1 != horseg[1].x1) or (horseg[0].x2 != horseg[1].x2):
        return False
    if (verseg[0].y1 != verseg[1].y1) or (verseg[0].y2 != verseg[1].y2):
        return False
    miny = min(horseg[0].y1, horseg[1].y1)
    maxy = max(horseg[0].y1, horseg[1].y1)
    minx = min(verseg[0].x1, verseg[1].x1)
    maxx = max(verseg[0].x1, verseg[1].x1)
    if (minx != horseg[0].x1) or (maxx != horseg[0].x2):
        return False
    if (miny != verseg[0].y1) or (maxy != verseg[0].y2):
        return False
    return True

horseg = []
verseg = []
for i in xrange(4):
    s = raw_input()
    l = s.split(' ')
    new_seg = segment(int(l[0]), int(l[1]), int(l[2]), int(l[3]))
    if (new_seg.hor == False) and (new_seg.ver == False):
        print('NO')
        break
    if new_seg.point:
        print('NO')
        break
    if new_seg.hor:
        horseg.append(new_seg)
    else:
        verseg.append(new_seg)
if (len(horseg) != 2):
    print('NO')
else:
    if rectangle(horseg, verseg):
        print('YES')
    else:
        print('NO')"""

    
        



"""from math import *
from Queue import *

def bfs(G, start):
    visited = set([start])
    Q = Queue()
    Ret = [start]
    Q.put(start)
    while not Q.empty():
        vertex = Q.get()
        for v in G[1][vertex]:
            if v not in visited:
                Q.put(v)
                visited.add(v)
                Ret.append(v)
    return Ret

def longest_path(G):
    l = bfs(G,G[0][0])
    marked = set()
    result = dict()
    for i in l:
        result[i] = [0,i,0,i]
    for i in range(len(l)-1, -1, -1):
        for j in G[1][l[i]]:
            if j in marked:
                if (result[j][2] > result[l[i]][2]) or ((result[j][2] == result[l[i]][2]) and (result[j][3] < result[l[i]][3])):
                    result[l[i]][2] = result[j][2]
                    result[l[i]][3] = result[j][3]
                if (result[l[i]][0] + result[j][0] + 1 > result[l[i]][2]):
                    result[l[i]][2] = result[l[i]][0] + result[j][0] + 1
                    result[l[i]][3] = min(result[l[i]][1], result[j][1])
                if ((result[l[i]][0] + result[j][0] + 1 == result[l[i]][2]) and (min(result[l[i]][1],result[j][1]) < result[l[i]][3])):
                    result[l[i]][3] = min(result[l[i]][1],result[j][1])
                if (result[j][0] + 1 > result[l[i]][0]) or ((result[j][0] + 1 == result[l[i]][0]) and (result[j][1] < result[l[i]][1])):
                    result[l[i]][0] = result[j][0] + 1
                    result[l[i]][1] = result[j][1]
        marked.add(l[i])
    return (result[l[0]][2], result[l[0]][3])

def remove(G,v):
    ver = G[0]
    ver.remove(v)
    edg = dict()
    for i in ver:
        nb = []
        for j in G[1][i]:
            if j != v:
                nb.append(j)
        edg[i] = nb
    return (ver, edg)

def harvest(G,M):
    l = bfs(G,M[0])
    seen = set()
    delete = []
    for i in range(len(l)-1, -1, -1):
        seen.add(l[i])
        if l[i] in M:
            for j in G[1][l[i]]:
                if j not in seen:
                    M.append(j)
        if l[i] not in M:
            delete.append(l[i])
    for i in delete:
        G = remove(G,i)
    return G

s = raw_input()
l = s.split(' ')
n = int(l[0])
m = int(l[1])
V = []
Adj = [[] for i in range(n+1)]
for i in range(1,n+1):
    V.append(i)
E = dict()
for i in range(n-1):
    s = raw_input()
    l = s.split(' ')
    h = int(l[0])
    t = int(l[1])
    Adj[h].append(t)
    Adj[t].append(h)
E = dict()
for i in range(1, n+1):
    E[i] = Adj[i]
G = [V,E]
s = raw_input()
l = s.split(' ')
M = []
for i in range(m):
    M.append(int(l[i]))
G = harvest(G,M)
sol = longest_path(G)
print(sol[1])
print(2*len(G[0]) - 2 - sol[0])"""
