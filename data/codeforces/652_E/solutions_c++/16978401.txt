#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;

#define all(a) (a).begin(),(a).end()
#define pb push_back
#define sz(a) ((int)(a).size())
#define mp make_pair
#define fi first
#define se second

typedef pair<int,int> pint;
typedef long long ll;
typedef vector<int> vi;


#define MAX_N 300005

typedef pair<int,bool> edge;

int n,num[MAX_N],lo[MAX_N];
vector<edge> adjl[MAX_N];
vector<edge> bi[MAX_N];
vector<pair<pint,bool> > bridge;

void dfs(int i, int p=0)
{
	static int _num=1;
	num[i]=lo[i]=_num++;
	for (int j=0; j<sz(adjl[i]); j++)
	{
		int g=adjl[i][j].fi;
		if (g==p)
			continue;
		if (!num[g])
			dfs(g,i);
		if (lo[g]>num[i])
			bridge.pb(mp(mp(i,g),adjl[i][j].se));
		else
		{
			bi[i].pb(adjl[i][j]);
			bi[g].pb(mp(i,adjl[i][j].se));
		}
		lo[i]=min(lo[i],lo[g]);
	}
}

bool vis[MAX_N];
int id[MAX_N];
bool good[MAX_N];

void assign(int i, int v)
{
	vis[i]=true;
	id[i]=v;
	for (int j=0; j<sz(bi[i]); j++)
	{
		int g=bi[i][j].fi;
		if (vis[g])
			continue;
		assign(g,v);
	}
}

vector<edge> tree[MAX_N];

pair<bool,bool> go(int a, int b, int p=0)
{
	if (a==b)
		return mp(good[a],true);
	for (int i=0; i<sz(tree[a]); i++)
	{
		int g=tree[a][i].fi;
		if (g==p)
			continue;
		pair<bool,bool> res=go(g,b,a);
		if (!res.se)
			continue;
		return mp(res.fi||tree[a][i].se||good[a],true);
	}
	return mp(false,false);
}

int main()
{
	int m;
	scanf("%d %d",&n,&m);
	while (m--)
	{
		int x,y,z;
		scanf("%d %d %d",&x,&y,&z);
		adjl[x].pb(mp(y,z));
		adjl[y].pb(mp(x,z));
	}
	dfs(1);
	int _id=1;
	for (int i=1; i<=n; i++)
		if (!vis[i])
		{
			assign(i,_id);
			_id++;
		}
	for (int i=1; i<=n; i++)
	{
		bool here=false;
		for (int j=0; j<sz(bi[i]); j++)
			here|=bi[i][j].se;
		good[id[i]]|=here;
	}
	for (int i=0; i<sz(bridge); i++)
	{
		int u=bridge[i].fi.fi,
			v=bridge[i].fi.se;
		bool here=bridge[i].se;
		u=id[u],v=id[v];
		tree[u].pb(mp(v,here));
		tree[v].pb(mp(u,here));
	}
	int a,b;
	scanf("%d %d",&a,&b);
	if (go(id[a],id[b]).fi)
		printf("YES\n");
	else
		printf("NO\n");
	return 0;
}
