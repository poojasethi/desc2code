#include <iostream>
#include <cstdio>
#include <cmath>
#include <vector>
#include <cstdlib>
#include <vector>
#include <map>
#include <set>
#include <stack>
#include <queue>
#include <algorithm>

using namespace std;

struct edge {
	bool isBridge;
	int to;
	int index;
	bool good;
};

int a, b;
vector<edge> g[300000];
int n, m;
bool used[300000];
int in[300000], mini[300000];
int t;
bool isBridge[300000];
int cnt;
int comp[300000];
bool flag;
bool goodComp[300000];

void find_bridges(int index, int parent = -1) {
	used[index] = true;
	in[index] = mini[index] = t++;
	for (int i = 0; i < g[index].size(); i++) {
		if (g[index][i].to == parent)
			continue;
		if (used[g[index][i].to])
			mini[index] = min(mini[index], in[g[index][i].to]);
		else {
			find_bridges(g[index][i].to, index);
			if (mini[g[index][i].to] > in[index]) {
				isBridge[g[index][i].index] = true;		
			}
			mini[index] = min(mini[index], mini[g[index][i].to]);
		}
	}
}

void getComps (int index) {
	used[index] = true;
	comp[index] = cnt;
	for (int i = 0; i < g[index].size(); i++) {
		if (!used[g[index][i].to] && !isBridge[g[index][i].index])
			getComps(g[index][i].to);
	}
}

bool dfs(int index) {
	used[index] = true;
	if (index == b) {
		if (goodComp[comp[index]]) {
			flag = true;
		}
		return true;
	}
	for (int i = 0; i < g[index].size(); i++) {
		if (used[g[index][i].to])
			continue;
		if (dfs(g[index][i].to)) {
			if (goodComp[comp[index]] || g[index][i].good) {
				flag = true;
			}
			return true;
		}
	}
	return false;
}

int main() {
	scanf("%d %d", &n, &m);
	for (int i = 0; i < m; i++) {
		int A, B, C;
		edge e;
		scanf("%d %d %d", &A, &B, &C);
		e.to = A - 1;
		e.good = (C == 1);
		e.index = i;
		g[B - 1].push_back(e);
		e.to = B - 1;
		g[A - 1].push_back(e);
	}
	for (int i = 0; i < n; i++) {
		if (!used[i])
			find_bridges(i);
	}
	for (int i = 0; i < n; i++) 
		used[i] = false;
	for (int i = 0; i < n; i++) {
		if (!used[i]) {
			getComps(i);
			cnt++;
		}
	}
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < g[i].size(); j++) {
			if (isBridge[g[i][j].index])
				continue;
			if (g[i][j].good)
				goodComp[comp[i]] = true;
		}
	}
	scanf("%d %d", &a, &b);
	a--;
	b--;
	if (comp[a] == comp[b]) {
		if (goodComp[comp[a]])
			cout << "YES";
		else
			cout << "NO";
		cout << endl;
		return 0;
	}
	for (int i = 0; i < n; i++)
		used[i] = false;
	dfs(a);
	if (flag)
		cout << "YES";
	else
		cout << "NO";
	cout << endl;
	return 0;
}
