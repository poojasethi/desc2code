#include <bits/stdc++.h>

using namespace std;

#define pb push_back
#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)
#define endl '\n'
#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)
#define mp make_pair
#define nd second
#define st first
#define type(x) __typeof(x.begin())

typedef pair < int ,int > pii;

typedef long long ll;

const long long linf = 1e18+5;
const int mod = (int) 1e9 + 7;
const int logN = 17;
const int inf = 1e9;
const int N = 3e5 + 5;

int bel[N], S, ok[N], OK[N], start[N], low[N], s, T, n, m, x, y, z, h[N];
vector< pii > r[N], v[N], g[N];
map< int , int > B[N];

int go(int node, int bel) {
	::bel[node] = bel;
	h[node] = 1;
	foreach(it, v[node]) {
		if(B[node].count(it->st)) continue;
		OK[bel] |= it->nd;
		if(!h[it->st])
			go(it->st, bel);
	}
}

void dfs(int node, int root) {
	start[node] = low[node] = ++T;
	foreach(it, v[node]) {
		if(it->st == root) continue;
		if(start[it->st]) { low[node] = min(low[node], start[it->st]); }
		else { dfs(it->st, node); low[node] = min(low[node], low[it->st]); }
	}
	if(node && low[node] == start[node]) {
		B[node][root] = B[root][node] = 1;	
	}
}

int dfs2(int node, int root, int tt = 0) {
	tt |= OK[bel[node]];
	h[node] = 1;
	if(node == y) {
		if(tt) cout << "YES\n";
		else cout << "NO\n";
		exit(0);
	}
	foreach(it, v[node])
		if(!h[it->st]) dfs2(it->st, node, tt | it->nd);
}

int main() {

	scanf("%d %d", &n, &m);

	FOR(i, 1, m) {
		scanf("%d %d %d", &x, &y, &z);
		v[x].pb(mp(y, z));
		v[y].pb(mp(x, z));
	} 

	scanf("%d %d", &x, &y);

	dfs(x, 0);
	FOR(i, 1, n)
		if(!h[i])
			go(i, ++S);
	memset(h, 0, sizeof h);
	dfs2(x, 0, 0);

	assert(0);

	return 0;
}
