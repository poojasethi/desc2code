#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdio>
#include <memory.h>
#include <map>

using namespace std;

const int N = 300010;

int n , m , a , b , c,dfs_time = 1 , dfs_num[N] , dfs_low[N],comp[N],component = 1;
bool vis[N];
vector<int> g[N],adj[N];
map< pair<int,int> , int> edges,fe;
map< pair<int,int> , int> bridges;
bool contain[N];

bool fff(int u ,int p, bool found){
	if(contain[u])
		found = true;
	if(u == comp[b])
		return found;
	bool can = false;
	for(int i = 0 ; i < adj[u].size();i++){
		int v = adj[u][i];
		if(v == p)
			continue;
		if(fe[make_pair(u,v)]){
			can = can || fff(v,u,true);
		}else{
			can = can || fff(v,u,found);
		}
	}
	return can;
}
void dfs(int u,int p){
	dfs_num[u] = dfs_low[u] = dfs_time++;
	for(int i = 0 ; i < g[u].size();i++){
		int v = g[u][i];
		if(dfs_num[v] == -1){
			dfs(v,u);
			dfs_low[u] = min(dfs_low[u],dfs_low[v]);
			if(dfs_low[v] > dfs_num[u]){

				bridges[make_pair(u,v)] = bridges[make_pair(v,u)] = 1;
			}
		}else if(v != p){
			dfs_low[u] = min(dfs_low[u],dfs_num[v]);
		}
	}
}
void flood(int u){
	if(vis[u])
		return;
	vis[u] = 1;
	comp[u] = component;
	for(int i = 0 ; i < g[u].size();i++){
		if(bridges.find(make_pair(g[u][i],u)) == bridges.end())
			flood(g[u][i]);
	}
}

int main(){
	//freopen("input.txt","r",stdin);
	memset(dfs_num, -1 , sizeof dfs_num);
	scanf("%d%d",&n,&m);
	for(int i = 0; i < m ; i++){
		scanf("%d%d%d",&a,&b,&c);
		if(c)
			edges[make_pair(a,b)] = edges[make_pair(b,a)] = 1;
		g[a].push_back(b);
		g[b].push_back(a);
	}
	scanf("%d%d",&a,&b);
	dfs(1,-1);
	for(int i = 1 ; i <= n ; i++){
		if(!vis[i]){
			flood(i);
			component++;
		}
	}
	for(map< pair<int,int> , int>::iterator it = bridges.begin();it != bridges.end();it++){
		int f = (it->first).first;
		int s = (it->first).second;
		adj[comp[f]].push_back(comp[s]);
	}
	for(map< pair<int,int> , int>::iterator it = edges.begin();it != edges.end();it++){
		int f = (it->first).first;
		int s = (it->first).second;
		if(comp[f] == comp[s]){
			contain[comp[f]] = 1;
		}else{
			fe[make_pair(comp[f],comp[s])] = fe[make_pair(comp[s],comp[f])] = 1;
		}
	}
	bool can = fff(comp[a],-1,0);
	if(can){
		puts("YES");
	}else{
		puts("NO");
	}
	return 0;
}