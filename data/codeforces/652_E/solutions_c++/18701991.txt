#define problem "652E"
#include <cstdio>
#include <iostream>
#include <queue>
#include <algorithm>
#include <memory.h>
using namespace std;
const int maxN(3e5 + 10);
typedef int i_N[maxN];
typedef pair<int, int> p_ii;
int N, M, U, V;
vector<p_ii> A;
namespace graph{
    int Cnum;
    i_N low, num, hi, P, key;
    vector<int> adj[maxN], stk;

    void link(const int u, const int v){adj[u].push_back(v);}

    void dfs(const int u){
        stk.push_back(u);
        low[u] = num[u] = ++Cnum;
        for(int i = 0; i < (int)adj[u].size(); i++){
            const int v(adj[u][i]);
            if(P[u] == v) continue;
            if(!P[v]){
                P[v] = u;
                dfs(v);
                low[u] = min(low[u], low[v]);
            }else low[u] = min(low[u], num[v]);
        }
        hi[u] = Cnum;
        if(low[u] == num[u]){
            int v;
            do{
                v = stk.back(); stk.pop_back();
                key[v] = u;
            }while(v != u);
        }
    }
}

int main(){
    ios_base::sync_with_stdio(0);
 
    {/// get graph
        using namespace graph;
        cin >> N >> M;
        for(int i = 0; i < M; i++){
            int u, v, W;
            cin >> u >> v >> W;
            link(u, v); link(v, u);
            if(W) A.push_back(p_ii(u, v));
        }
        cin >> U >> V;
    }
    {/// dfs
        using namespace graph;
        P[U] = -1;
        dfs(U);
    }
    {/// answer
        using namespace graph;
        for(int i = 0; i < (int)A.size(); i++){
            int u(A[i].first), v(A[i].second);
            if(key[u] != key[v] && P[u] == v) swap(u, v);
            v = key[v];
            if(num[v] <= num[V] && num[V] <= hi[v]){
                cout << "YES";
                return 0;
            }
        }
    }
    cout << "NO";
}
