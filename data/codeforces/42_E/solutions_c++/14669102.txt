#include <bits/stdc++.h>
//Practice makes perfect

using namespace std;

typedef long long ll;
typedef pair<int, int> pii;

const int MAXN = 2e5 + 100, MAXB = 19;

int s[MAXN], t[MAXN], comp[MAXN], par[MAXN][MAXB], maxe[MAXN][MAXB], h[MAXN], id[MAXN];
int w[MAXN];
vector<int> G[MAXN];

int getcomp(int u){
	return (u == comp[u] ? u : comp[u] = getcomp(comp[u]));
}

inline bool join(int u, int v){
	u = getcomp(u); v = getcomp(v);
	if (u == v) return false;
	else {
		comp[u] = v;
		return true;
	}
}

inline int other(int id, int u){
	return (s[id] == u? t[id]: s[id]);
}

bool byW(int a, int b){
	return w[a] < w[b];
}

void makeroot(int u, int topar){
	//cerr << u + 1 << " : topar is " << topar + 1 << " = " << w[topar] << endl;
	if (topar != -1){
		maxe[u][0] = w[topar];
		par[u][0] = other(topar, u);
	}else{
		maxe[u][0] = 0; par[u][0] = -1;
	}

	for (int i = 1; i < MAXB; i++)
		if (par[u][i - 1] != -1){
			par[u][i] = par[ par[u][i -1] ][i-1];
			maxe[u][i] = max(maxe[u][i - 1], maxe[ par[u][i-1] ][i - 1]);
		}

	for (int i = 0; i < G[u].size(); i++){
		int e = G[u][i], v = other(e, u);
		if (e != topar) {
			h[v] = h[u] + 1;
			makeroot(v, e);
		}
	}
}

int lca(int u, int v){
	if (h[u] < h[v]) swap(u, v);	

	int ans = 0;
	for (int i = MAXB -1; i >= 0; i--)
		if (par[u][i] != -1 && h[ par[u][i] ] >= h[v]){
			ans = max(ans, maxe[u][i]);
			u = par[u][i];
		}

	if (u == v) return ans;
	for (int i = MAXB - 1; i >= 0; i--)
		if (par[u][i] != par[v][i]){
			ans = max(ans, maxe[u][i]);
			ans = max(ans, maxe[v][i]);

			u = par[u][i];
			v = par[v][i];
		}

	ans = max(ans, max(maxe[u][0], maxe[v][0]));
	return ans;
}

int main(){
	memset(par, -1, sizeof par);

	int n, m; scanf("%d%d", &n, &m);
	for (int i = 0; i < m; i++){
		scanf("%d%d%d", &s[i], &t[i], &w[i]);
		s[i]--; t[i]--;
		id[i] = i;
	}

	sort(id, id + m, byW);

	for (int i = 0; i < n; i++)
		comp[i] = i;

	ll mst = 0, eN = 0;

	for (int i = 0; i < m; i++){
		int e = id[i], u = s[e], v = t[e];

		if ( join(u ,v) ){
			G[u].push_back( e );
			G[v].push_back( e );
			mst += w[e];
			eN++;
//			cerr << e + 1 << " is in mst\n";
		}
	}

	if (eN == n - 1)
		makeroot(0, -1);

	int q; scanf("%d", &q);
	while(q--){
		int u, v; scanf("%d%d", &u, &v); u--; v--;

		if (eN == n -1)
			printf("%I64d\n", mst - lca(u, v));
		else if (eN < n - 2 || getcomp(u) == getcomp(v)) printf("-1\n");
		else printf("%I64d\n", mst);
		
	}

}
