
//in the name of god

#include<iostream>
#include<algorithm>
#include<vector>
#include<set>
#include<map>
#include<utility>
#include<cstdio>
#include<cstdlib>
#include<ctime>
#include<cstring>
#include<string>
#include<iomanip>
#include<fstream>
#include<sstream>
#include<cmath>
#include<complex>
#include<limits>
#include<queue>
#include<stack>

using namespace std;

#define PB push_back
#define F first
#define S second
#define MP make_pair
#define X real()
#define Y imag()

typedef long long ll;
typedef pair<int,int> PII;
typedef long double ld;
typedef pair<double,double> PDD;
typedef pair<long long ,long long> PLL;

const int maxn = 2*1000*100 + 100 , K = 20;

ll n,m,mark[maxn],t,q,par[maxn][K],mx[maxn][K],sum[maxn],p[maxn],cnt,h[maxn];

vector<PLL> v[maxn];

pair<int,PII> e[maxn];

int find(int x){
	//cout<<x<<" gg"<<endl;
	if(p[x] == x)
		return x;
	return p[x] = find(p[x]);
}

void merge(int x,int y){
	p[find(x)] = find(y);
}

void dfs(int x,int parent,int d){
	mark[x] = t;
	par[x][0] =  parent;
	mx[x][0] = d;
	for(int i=1;i < K;i++){
		par[x][i] = par[par[x][i-1]][i-1];
		mx[x][i] = max(mx[par[x][i-1]][i-1],mx[x][i-1]);
	}
	for(int i=0;i<v[x].size();i++){
		int next = v[x][i].F , w=v[x][i].S;
		if(!mark[next]){
			sum[t] += w;
			h[next] = h[x]+1;
			dfs(next,x,w);
		}
	}
}

int LCA(int x,int y){
	if(h[x] < h[y])
		swap(x,y);
	ll d = h[x]-h[y];
	ll MX = 0;
	for(int i=0;i<K;i++){
		if(d & (1<<i)){
			MX = max (MX , mx[x][i]);
			x = par[x][i];
		}
	}
	for(int i= K-1 ; i >=0 ;i--){
		if(par[x][i] != par[y][i]){
			MX = max(MX,mx[x][i]);
			MX = max(MX,mx[y][i]);
			x=par[x][i];
			y=par[y][i];
		}
	}
	//cout<<x<<" "<<y<<" "<<par[x][0]<<" "<<par[y][0]<<endl;
	if(x != y)
		MX = max(MX , max(mx[x][0],mx[y][0]));
	return MX;
}

int main(){
	ios::sync_with_stdio(false);
//	cout<<fixed<<setprecision(9);
//	freopen("first.in","r",stdin);
//	freopen("first.out","w",stdout);
	cin>>n>>m;
	for(int i=0;i<m;i++){
		int x,y,w;
		cin>>x>>y>>w;
		//v[x].PB(MP(y,w));
		//v[y].PB(MP(x,w));
		e[i]=MP(w,MP(x,y));
	}
	for(int i=1;i<=n;i++)
		p[i]=i;
	sort(e,e+m);
	cnt = n;
	for(int i=0;i<m;i++){
		ll w = e[i].F , x = e[i].S.F , y = e[i].S.S;
		ll px = find(x) , py = find(y);
	//	cout<<x<<" "<<y<<" "<<px<<" e "<<py<<endl;
		if(px == py)
			continue;
		merge(x,y);
	//	cout<<x<<" "<<y<<" e "<<w<<endl;
		cnt -- ;
		v[x].PB(MP(y,w));
		v[y].PB(MP(x,w));
	}
	//cout<<cnt<<endl;
	for(int i=1;i<=n;i++){
		find(i);
		//cout<<p[i]<<" ";
	
	}
	for(int i=1;i<=n;i++){
		if(!mark[i]){
			t++;
			dfs(i,0,0);
		}
	}
	cin>>q;
	while(q--){
		int x,y;
		cin>>x>>y;
		if(cnt > 2 || (cnt == 2 && p[x] == p[y] ))
			cout << -1 <<endl;
		else if(cnt == 2)
			cout << sum[1] + sum[2] << endl;
		else if(cnt == 1)
			cout << sum[1] - LCA(x,y) << endl;
	}
	return 0;
}
  		   	     	  	   			 		