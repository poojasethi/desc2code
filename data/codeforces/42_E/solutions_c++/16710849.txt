#include <cstring>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>

using namespace std;

#define x first
#define y second
#define mp make_pair
#define pii pair<int,int>

#define Max(a,b) ((a)>(b)?(a):(b))
#define ull long long

int read()
{
	int ret=0;
	char c=getchar();
	while (c<'0' || c>'9') c=getchar();
	while (c>='0' && c<='9') { ret=ret*10+c-'0'; c=getchar(); }
	return ret;
}

const int LOG=20;
const int MAXN=100000,MAXM=200000;

int Log[MAXN+10];

void buildLog(int x)
{
	for (int i=1,a=-1,b=1;i<=x;i++) {
		if (i==b) { a++; b<<=1; } Log[i]=a; }
	return ;
}

int n,m;

namespace Tree
{
	int m;
	pii front[(MAXN<<1)+10];
	int orderx[(MAXN<<1)+10],stdx[MAXN+10];
	
	void sortx()
	{
		static int num[MAXN+10];
		memset(num,0,sizeof(num));
		for (int i=1;i<=m;i++) num[front[i].x]++;
		for (int i=1;i<=n;i++) stdx[i]=num[i]+=num[i-1];
		for (int i=1;i<=m;i++) orderx[++num[front[i].x-1]]=i;
		return ;
	}
	
	int cost[(MAXN<<1)+10];
	
	void addedge(int x,int y,int c)
	{
		front[++m]=mp(x,y); cost[m]=c;
		front[++m]=mp(y,x); cost[m]=c;
		return ;
	}
	
	int D[LOG+5][MAXN+10];
	int f[LOG+5][MAXN+10];
	int dep[MAXN+10];
	
	int up(int x,int step)
	{
		while (step) { int nxt=Log[step]; x=f[nxt][x]; step-=(1<<nxt); }
		return x;	
	}
	
	int lca(int x,int y)
	{
		if (dep[x]>dep[y]) x=up(x,dep[x]-dep[y]); else y=up(y,dep[y]-dep[x]);
		int d=Log[dep[x]];
		while (x!=y) {
			while (d>=0 && f[d][x]==f[d][y]) d--;
			if (d==-1) return f[0][x];
			x=f[d][x]; y=f[d][y]; }
		return x;
	}
	
	int dis(int x,int y)
	{
		int ret=0,d=Log[dep[x]];
		while (x!=y) {
			while (!f[d][x] || dep[f[d][x]]<dep[y]) d--;
			ret=Max(ret,D[d][x]); x=f[d][x]; }
		return ret;
	}
	
	bool vis[MAXN+10];
	
	void dfs(int pre,int x)
	{
		for (int i=1;f[i-1][x];i++) {
			f[i][x]=f[i-1][f[i-1][x]];
			D[i][x]=Max(D[i-1][x],D[i-1][f[i-1][x]]); }
		vis[x]=true;
		for (int i=stdx[x-1]+1;i<=stdx[x];i++) {
			int next=front[orderx[i]].y;
			if (next!=pre) {
				dep[next]=dep[x]+1;
				f[0][next]=x; D[0][next]=cost[orderx[i]];
				dfs(x,next); } }
		return ;
	}
	
	void build()
	{
		sortx();
		for (int i=1;i<=n;i++)
			if (!vis[i]) dfs(-1,i);
		return ;
	}
}

struct Edge
{
	int u,v,cost;
	bool operator < (const Edge &R) const { return cost<R.cost; }
}p[MAXM+10];

int fa[MAXN+10];

int find(int x) { if (!fa[x]) return x; return fa[x]=find(fa[x]); }

void init()
{
	n=read(); buildLog(n); m=read();
	for (int i=1;i<=m;i++) {
		p[i].u=read(); p[i].v=read(); p[i].cost=read(); }
	sort(p+1,p+m+1);
	
	int cnt=n;
	ull ans=0;
	
	for (int i=1;i<=m;i++) {
		int x=find(p[i].u),y=find(p[i].v);
		if (x!=y) { ans+=p[i].cost; fa[x]=y; cnt--; Tree::addedge(p[i].u,p[i].v,p[i].cost); } }
	
	Tree::build();
	int q=read();
	while (q--) {
		int x=read(),y=read();
		if (cnt>2) puts("-1");
		else if (cnt==2) {
			if (find(x)==find(y)) puts("-1");
			else printf("%I64d\n",ans); }
		else {
			int lca=Tree::lca(x,y);
			printf("%I64d\n",ans-Max(Tree::dis(x,lca),Tree::dis(y,lca))); } }
	
	return ;
}

int main()
{
	init();
	return 0;
}