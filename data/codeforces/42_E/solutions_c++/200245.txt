#include <vector>
#include <iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<string.h>
#include<queue>
#include <set>
#include<map>
#include<string>

using namespace std;
template <class T> void show(T a, int n) { for (int i = 0; i < n; ++i) cout << a[i] << ' '; cout << endl; }
template <class T> void show(T a, int r, int l) { for (int i = 0; i < r; ++i) show(a[i], l); cout << endl; }
#define max(a, b) (a > b?a:b)
#define min(a, b) (a < b?a:b)

#define MS(a, v)    memset(a, v, sizeof(a))
#define pb push_back

typedef long long LL;

const int N = 1<<18;
const int M = 1<<20;
const int oo = 10000 * 10000 * 10;
const int LG = 19;

int n, m;
int tree[N];
int ti = 0;
int ft[N];
int dt[N];
vector<int> te[N];
bool visited[N] = {false};
int anc[N][LG];
int cost[N][LG];


int find(int x)
{
    if( tree[x] != x )
        tree[x] = find( tree[x] );
    return tree[x];
}
inline void merge(int x, int y)
{
    tree[x] = y;
}

struct Node
{
    int u, v, c;
}ed[M];
bool cmp(Node a, Node b)
{
    return a.c < b.c;
}

// a is anc of b;
inline bool isanc(int a, int b)
{
    return ft[a] <= ft[b] && dt[a] >= dt[b];
}

void dfs(int u, int p, int c)
{
    ft[u] = ti++;
    visited[u] = true;
    anc[u][0] = p;
    cost[u][0] = c;
    
    
    for(int i = 1; i < LG;++i)
    {
        anc[u][i] = anc[ anc[u][i - 1] ][i - 1];
        cost[u][i] = max( cost[u][i - 1], cost[ anc[u][i - 1] ][i - 1] );
    }
    
    for(int i = 0; i < te[u].size();i += 2)
    {
        int v = te[u][i];
        int vc = te[u][i + 1];
        if( v != p && !visited[v] )
        {
            dfs(v, u, vc);
        }
    }
    dt[u] = ti++;
}

int find_e(int u, int v)
{
    if( isanc(v, u) )
        swap(u, v);
    
    int ans = 0;
    int i = LG - 1;
    while( !isanc(v, u) )
    {
        if( i == 0 || !isanc(anc[v][i], u) )
        {
            ans = max(ans, cost[v][i]);
            v = anc[v][i];
        }
        if( i > 0 )
            --i;
    }
    return ans;
}


int main()
{
//        freopen("in", "r", stdin);
//        freopen("out1","w",stdout); 
    int i, j, cas = 0;
    
    scanf("%d %d", &n, &m);
    for(i = 0; i < m;++i)
    {
        scanf("%d %d %d", &ed[i].u, &ed[i].v, &ed[i].c);
    }
    
    sort(ed, ed + m, cmp);
    for(i = 1; i <= n;++i)
        tree[i] = i;
    LL ans = 0;
    int cn = n;
    for(i = 0; i < m;++i)
    {
        int u, v, c;
        u = ed[i].u;
        v = ed[i].v;
        c = ed[i].c;
        if( find(u) != find(v) )
        {
            --cn;
            ans += c;
            merge(find(u), find(v));
            te[u].pb(v);
            te[u].pb(c);
            te[v].pb(u);
            te[v].pb(c);
        }
    }
    
    MS(visited, 0);
    dfs(1, 1, 0);
    
    
    int q;
    scanf("%d", &q);
    while(q--)
    {
        int u, v;
        scanf("%d %d", &u, &v);
        if( cn >= 3 )
        {
            puts("-1");
        }
        else if( cn == 2 )
        {
            if( find(u) == find(v) )
                puts("-1");
            else
               // printf("%lld\n", ans);
               cout<<ans<<endl;
        }
        else    //cn == 1
        {
            int tmp = 0;
            tmp = max(find_e(u, v), find_e(v, u));
            if( tmp == 0 )      while(1);
            cout<<ans - tmp<<endl;
           // printf("%lld\n", ans - tmp);
        }
    }
 
    

    
   
    return 0;
}
