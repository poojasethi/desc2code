//TO CHANGE THE WORLD
#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define pb push_back
#define L first
#define R second
const long long maxn=1e5, maxl=20;

bool mark[maxn];
long long sum=0, cmp, d[maxn];
pair<long long, long long> par[maxn][maxl];
vector <pair<long long, long long> > adj[maxn];

struct Type_Dsu
{
    long long par[maxn], h[maxn];
    void make_set(long long x)
    {
        par[x]=x;
        h[x]=0;
    }
    long long findpar(long long x)
    {
        return par[x]=(x==par[x]?x:findpar(par[x]));
    }
    bool merge(long long x, long long y)
    {
        x=findpar(x);
        y=findpar(y);
        if(x==y)
            return false;
        if(d[x]>d[y])
            swap(x,y);
        par[x]=y;
        h[y]+=(h[x]==h[y]);
        return true;
    }
    bool same(long long x, long long y)
    {
        return (findpar(x)==findpar(y));
    }
}dsu;
struct Edge
{
    long long fi, se, w;
};
vector<Edge> edges;
void input()
{
    long long n,m;
    cin>>n>>m;
    cmp=n;
    for(long long i=0; i<n; i++)
        dsu.make_set(i);
    for(long long i=0; i<m; i++)
    {
        long long fi,se,w;
        cin>>fi>>se>>w;
        fi--; se--;
        Edge edg;
        edg.fi=fi; edg.se=se; edg.w=w;
        edges.pb(edg);
    }
}
bool comp(Edge a, Edge b)
{
    return (a.w<b.w);
}
void mst()
{
    sort(edges.begin(), edges.end(), comp);
    for(long long i=0; i<edges.size(); i++)
    {
        long long fi=edges[i].fi, se=edges[i].se, w=edges[i].w;
        if(!dsu.same(fi,se))
        {
            cmp--;
            sum+=w;
            dsu.merge(fi,se);
            adj[fi].pb(mp(w,se));
            adj[se].pb(mp(w,fi));
        }
    }
}
void dfs(long long x)
{
    mark[x]=true;
    for(long long i=0; i<adj[x].size(); i++)
    {
        long long child=adj[x][i].R, w=adj[x][i].L;
        if(mark[child])
            continue;
        par[child][0]=mp(x, w);
        d[child]=d[x]+1;
        for(long long j=1; j<maxl; j++)
        {
            long long p=par[par[child][j-1].L][j-1].L;
            long long maxe=max(par[child][j-1].R, par[par[child][j-1].L][j-1].R);
            par[child][j]=mp(p, maxe);
        }
        dfs(child);
    }
}
pair<long long, long long> findpar(long long x, long long d)
{
    long long p=x, maxe=0;
    for(long long i=0; i<maxl; i++)
        if((d>>i)&1)
        {
            maxe=max(maxe,par[p][i].R);
            p=par[p][i].L;
        }
    return mp(p, maxe);
}
long long lca(long long x, long long y)
{
    long long maxe=0;
    if(d[x]>d[y])
        swap(x,y);
    maxe=findpar(y,d[y]-d[x]).R;
    y=findpar(y,d[y]-d[x]).L;
    if(x==y)
        return maxe;
    for(long long i=maxl-1; i>=0; i--)
        if(par[x][i].L!=par[y][i].L)
        {
            maxe=max(maxe, par[x][i].R);
            maxe=max(maxe, par[y][i].R);
            x=par[x][i].L;
            y=par[y][i].L;
        }
    maxe=max(maxe, par[x][0].R);
    maxe=max(maxe, par[y][0].R);
    return maxe;
}
void output()
{
    long long q;
    cin>>q;
    for(long long i=0; i<q; i++)
    {
        long long A,B;
        cin>>A>>B;
        A--; B--;
        cout<<endl;
        if(cmp>2)
            cout<<-1<<endl;
        if(cmp==2)
            if(dsu.same(A, B))
                cout<<-1<<endl;
            else
                cout<<sum<<endl;
        if(cmp==1)
            cout<<sum-lca(A, B)<<endl;
    }
}
int main()
{
    input();
    mst();
    dfs(0);
    output();
    return 0;
}
