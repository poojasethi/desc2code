#include <cstdio>
#include <cstring>
#include <algorithm>

#define X first
#define Y second

using namespace std;

const int MAXN = 100010;
const int MAXM = 200010;

struct Tedge{
   int p, v, next;
};

int n, m, c;
long long sum;
pair<int, pair<int, int> > sedge[MAXM];
int a[MAXN];
int f[MAXN];
int d[MAXN];
Tedge edge[MAXM];
bool chk[MAXN];
int lca[MAXN][20];
int lcm[MAXN][20];
int q[MAXN];
int s[MAXN];

int getf(int p)
{
   int top = 1;
   s[top] = p;
   while (f[s[top]] != s[top])
   {
      s[top + 1] = f[s[top]];
      ++top;
   }
   p = s[top];
   while (top--)
   {
      f[s[top]] = p;
   }
   return p;
}

int max(int a, int b) { return a > b ? a : b;}


void init()
{
   scanf("%d", &n);
   scanf("%d", &m);
   for (int i = 1; i <= m; ++i)
      scanf("%d %d %d", &sedge[i].Y.X, &sedge[i].Y.Y, &sedge[i].X);
}

void MST()
{
   int i, l = 0;
   c = n;
   memset(a, 0xff, sizeof(a));
   sort(sedge + 1, sedge + m + 1);
   for (i = 1; i <= n; ++i)
      f[i] = i;
   sum = 0;
   for (i = 1; i <= m; ++i)
   if (getf(sedge[i].Y.X) != getf(sedge[i].Y.Y))
   {
      edge[++l].p = sedge[i].Y.Y;
      edge[l].v = sedge[i].X;
      edge[l].next = a[sedge[i].Y.X];
      a[sedge[i].Y.X] = l;
      edge[++l].p = sedge[i].Y.X;
      edge[l].v = sedge[i].X;
      edge[l].next = a[sedge[i].Y.Y];
      a[sedge[i].Y.Y] = l;
      f[getf(sedge[i].Y.X)] = getf(sedge[i].Y.Y);
      --c;
      sum += sedge[i].X;
   }
   else
   {
      //printf("%d %d\n", sedge[i].Y.X, sedge[i].Y.Y);
   }
}

void bfs(int p)
{
   
   chk[p] = true;
   int st, ed;
   st = 0;
   ed = 1;
   q[1] = p;
   int i, k;
   while (st < ed)
   {
      k = q[++st];
      i = 0;
      while (lca[k][i] != -1)
      {
         lca[k][i + 1] = lca[lca[k][i]][i];
         lcm[k][i + 1] = max(lcm[k][i], lcm[lca[k][i]][i]);
         ++i;
      }
      for (i = a[k]; i != -1; i = edge[i].next)
      if (!chk[edge[i].p])
      {
         chk[edge[i].p] = true;
         d[edge[i].p] = d[k] + 1;
         lca[edge[i].p][0] = k;
         lcm[edge[i].p][0] = edge[i].v;
         q[++ed] = edge[i].p;
      }
   }
}


int get(int u, int v)
{
   int ret = 0;
   int tmp;
   int i;
   if (d[u] < d[v])
   {
      tmp = u;
      u = v;
      v = tmp;
   }
   //printf("A%d %d %d\n", u, v, ret);
   //fflush(stdout);
   i = 19;
   while (d[u] > d[v])
   {
      while (d[u] > d[v] && lca[u][i] > 0 && d[lca[u][i]] >= d[v])
      {
        // printf("%d %d %d\n", u, i, lcm[u][i]);
         ret = max(ret, lcm[u][i]);
         u = lca[u][i];
        // printf("%d %d %d\n", u, v, ret);
      }
     // printf("%d %d\n", u, v);
      --i;
   }
   //printf("B%d %d\n", u, v);
   //fflush(stdout);
   if (u == v) return ret;
   i = 19;
   while (lca[u][0] != lca[v][0])
   {
      while (lca[u][0] != lca[v][0] && lca[u][i] > 0 && lca[v][i] > 0 && lca[u][i] != lca[v][i])
      {
         ret = max(ret, max(lcm[u][i], lcm[v][i]));
         u = lca[u][i];
         v = lca[v][i];
      }
      --i;
   }
   return max(ret, max(lcm[u][0], lcm[v][0]));
}

void solve()
{
   MST();
   if (c > 2)
   {
      scanf("%d", &m);
      while (m--) printf("-1\n");
   }
   else if (c == 2)
   {
      int u, v;
      scanf("%d", &m);
      while (m--)
      {
         scanf("%d %d", &u, &v);
         if (getf(u) != getf(v)) printf("%I64d\n", sum);
         else printf("-1\n");
      }
   }
   else
   {
      memset(lca, 0xff, sizeof(lca));
      memset(lcm, 0xff, sizeof(lcm));
      bfs(1);
      /*for (int i = 1; i <= 4; ++i)
      {
         for (int j = 0; j < 20; ++j)
            printf("%d: %d, ", lca[i][j], lcm[i][j]);
        printf("\n");
      }*/
      memset(chk, 0, sizeof(chk));
      int u, v;
      scanf("%d", &m);
      while (m--)
      {
         scanf("%d %d", &u, &v);
         printf("%I64d\n", sum - get(u, v));
      }
   }
}

int main()
{
   init();
   solve();
   return 0;
}