#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <cassert>
#include <sstream>
#include <numeric>
#include <climits>
#include <string>
#include <cctype>
#include <ctime>
#include <iomanip>
#include <cmath>
#include <vector>
#include <queue>
#include <list>
#include <map>
#include <set>
using namespace std;

#define foreach(e, x) for (__typeof((x).begin()) e = (x).begin(); e != (x).end(); ++e)

const int MAX_N = 2 * (int)1e5 + 10;

struct WEdge {
	int x, y, z;
	WEdge(int x, int y, int z): x(x), y(y), z(z) {}
};

struct Edge {
	int t, c;
	Edge(int t, int c): t(t), c(c) {}
};

int n, m, q;
long long result;
vector<Edge> E[MAX_N];
vector<WEdge> all_edges;
int f[MAX_N];
int parts, idx[MAX_N];

bool cmp(const WEdge &a, const WEdge &b) {
	return a.z < b.z;
}

int find(int x) {
	return x == f[x] ? x : f[x] = find(f[x]);
}

void buildMST() {
	sort(all_edges.begin(), all_edges.end(), cmp);
	for (int i = 0; i < n; ++i) {
		f[i] = i;
	}
	foreach (e, all_edges) {
		int a = find(e->x);
		int b = find(e->y);
		if (a != b) {
			f[a] = b;
			result += e->z;
			E[e->x].push_back(Edge(e->y, e->z));
			E[e->y].push_back(Edge(e->x, e->z));
		}
	}
}

int deep[MAX_N];
int dp[MAX_N][20], up[MAX_N][20];

void getFather(int x, int v) {
	foreach (e, E[x]) {
		if (e->t != v) {
			deep[e->t] = deep[x] + 1;
			up[e->t][0] = x;
			dp[e->t][0] = e->c;
			getFather(e->t, x);
		}
	}
}

void checkComponents() {
	set<int> S;
	for (int i = 0; i < n; ++i) {
		S.insert(find(i));
	}
	if ((int)S.size() > 2 ) {
		parts = -1;
	} else if ((int)S.size() == 2) {
		parts = 2;
	} else {
		parts = 1;
		memset(up, -1, sizeof(up));
		getFather(0, -1);
		for (int j = 1; 1 << j <= n; ++j) {
			for (int i = 0; i < n; ++i) {
				if (up[i][j - 1] != -1) {
					up[i][j] = up[up[i][j - 1]][j - 1];
					dp[i][j] = max(dp[i][j - 1], dp[up[i][j - 1]][j - 1]);
				}
			}
		}
	}
}

int calc(int x, int y) {
	int ret = 0, d = 0;
	if (deep[x] < deep[y]) {
		swap(x, y);
	}
	for (; 1 << d <= deep[x]; ++d);
	for (int i = --d; i >= 0; --i) {
		if (deep[x] - (1 << i) >= deep[y]) {
			ret = max(ret, dp[x][i]);
			x = up[x][i];
		}
	}
	if (x == y) {
		return ret;
	}
	for (int i = d; i >= 0; --i) {
		if (up[x][i] != up[y][i]) {
			ret = max(ret, max(dp[x][i], dp[y][i]));
			x = up[x][i];
			y = up[y][i];
		}
	}
	return max(ret, max(dp[x][0], dp[y][0]));
}

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 0; i < m; ++i) {
		int x, y, z;
		scanf("%d%d%d", &x, &y, &z);
		x--;
		y--;
		all_edges.push_back(WEdge(x, y, z));
	}
	buildMST();
	checkComponents();
	scanf("%d", &q);
	if (parts == -1) {
		while (q--) {
			puts("-1");
		}
	} else if (parts == 2) {
		int x, y;
		while (q--) {
			scanf("%d%d", &x, &y);
			if (find(x - 1) == find(y - 1)) {
				puts("-1");
			} else {
				printf("%I64d\n", result);
			}
		}
	} else {
		int x, y;
		while (q--) {
			scanf("%d%d", &x, &y);
			x--;
			y--;
			printf("%I64d\n", result - calc(x, y));
		}
	}
}

