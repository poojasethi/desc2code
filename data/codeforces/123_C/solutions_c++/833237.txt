#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>

using namespace std ;

typedef long long ll ;
const int N = 110 ;

int n, m, top ;
ll k ;
int c[N][N] ;
int has[N * 2] ;
pair<int, int>path[N * 2] ;
ll f[N * 2][N * 2] ;

ll dp ()
{
    memset (f, 0, sizeof f) ;
    f[0][0] = 1 ;
    for (int i = 1; i <= top; i ++ )
        for (int j = 0; j <= top; j ++ )
        {
            if (has[i] != -1 && j) f[i][j] += f[i - 1][j - 1] ;
            if (has[i] != 1) f[i][j] += f[i - 1][j + 1] ;
            if (f[i][j] > k) f[i][j] = k + 1 ;
        }
    return f[top][0] ;
}

int main ()
{
    scanf ("%d%d%I64d", &n, &m, &k) ;
    memset (path, 127, sizeof path) ;
    top = n + m - 1 ;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
        {
            scanf ("%d", &c[i][j]) ;
            path[i + j + 1].first = min (path[i + j + 1].first, c[i][j]) ;
            path[i + j + 1].second = i + j + 1 ;
        }
    sort (path + 1, path + n + m) ;
    for (int i = 1; i < n + m; i ++ )
    {
        has[path[i].second] = 1 ;
        ll t = dp () ;
        if (t < k) k -= t, has[path[i].second] = -1 ;
    }
    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < m; j ++ )
            if (has[i + j + 1] == 1) printf ("(") ;
            else printf (")") ;
        puts ("") ;
    }
    return 0 ;
}
