#include <iostream>
#include <iomanip>
#include <fstream>
#include <algorithm>
#include <cassert>
#include <cctype>
#include <cmath>
#include <complex>
#include <cstdio>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <vector>
using namespace std;

#define INF 1e8
#define EPS 1e-14
#define rep(i,n) for(int i=0;i<n;i++)

int n,P[10001][3],vp,vs,p[3];
double t[10001],pos[3];

double sq(double x){
	return x*x;
}

double d(int a){
	return sqrt(sq(P[a][0]-p[0])+sq(P[a][1]-p[1])+sq(P[a][2]-p[2]));
}

double d(int a,int b){
	return sqrt(sq(P[a][0]-P[b][0])+sq(P[a][1]-P[b][1])+sq(P[a][2]-P[b][2]));
}

int main(){
	cin>>n;
	rep(i,n+1)cin>>P[i][0]>>P[i][1]>>P[i][2];
	cin>>vp>>vs>>p[0]>>p[1]>>p[2];
	rep(i,n+1){
		if(!i)t[i]=0.0;
		else t[i]=t[i-1]+d(i-1,i)/vs;
	}
	if(t[n]+EPS<d(n)/vp){
		cout<<"NO"<<endl;
		return 0;
	}
	double l=0.0,u=t[n];
	while(u-l>1e-11){
		double m=(l+u)/2.0;
		int L=0,U=n;
		while(U>L+1){
			int M=(L+U)/2;
			if(t[M]<m+EPS)L=M;
			else U=M;
		}
		double q[3];
		rep(i,3)pos[i]=q[i]=P[L][i]+(P[L+1][i]-P[L][i])*(m-t[L])/(t[L+1]-t[L]);
		if(sqrt(sq(q[0]-p[0])+sq(q[1]-p[1])+sq(q[2]-p[2]))/vp<m+EPS)u=m;
		else l=m;
	}
	cout<<"YES"<<endl;
	cout<<setprecision(9)<<(l+u)/2.0<<endl;
	cout<<pos[0]<<" "<<pos[1]<<" "<<pos[2]<<endl;
}
