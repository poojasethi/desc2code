#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

typedef vector<double> point;

point operator*(double a,point p)
{
  for (int i=0;i<3;i++)
    p[i]*=a;
  return p;
}

point operator+(point p1,point p2)
{
  point p(3);
  for (int i=0;i<3;i++) {
    p[i]=p1[i]+p2[i];
  }
  return p;
}

point operator-(point p1,point p2)
{
  point p(3);
  for (int i=0;i<3;i++) {
    p[i]=p1[i]-p2[i];
  }
  return p;
}

double modul(point p)
{
  double m=0;
  for (int i=0;i<3;i++)
    m+=p[i]*p[i];
  return sqrt(m);
}

double error=0.00000000001;

int main()
{
  cout.setf(ios::fixed);
  cout.precision(10);
  int n;
  cin>>n;
  vector<point> v(n+1,point(3));
  for (int i=0;i<n+1;i++) {
    point &p=v[i];
    cin>>p[0]>>p[1]>>p[2];
  }
  double vp,vs;
  cin>>vp>>vs;
  point p(3);
  cin>>p[0]>>p[1]>>p[2];
  bool trobat=false;
  int itrobat;
  double tempsant=0;
  double temps=0;
  for (int i=1;i<=n and not trobat;i++) {
    tempsant=temps;
    temps+=modul(v[i]-v[i-1])/vs;
    if (temps+error>=modul(v[i]-p)/vp) {
      trobat=true;
      itrobat=i;
    }
  }
  temps=tempsant;
  if (not trobat) {
    cout<<"NO"<<endl;
  } else {
    cout<<"YES"<<endl;
    point pinf=v[itrobat-1];
    point psup=v[itrobat];
    double tempsnext;
    while (error<modul(psup-pinf)) {
      point pmig=0.5*(psup+pinf);
      tempsnext=temps+modul(pmig-v[itrobat-1])/vs;
      if (tempsnext+error>=modul(pmig-p)/vp)
	psup=pmig;
      else
	pinf=pmig;
    }
    cout<<tempsnext<<endl;
    cout<<pinf[0]<<" "<<pinf[1]<<" "<<pinf[2]<<endl;
  }
}
