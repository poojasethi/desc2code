#include<stdio.h>
#include<math.h>
#define esp 1e-11
int n;
double e[10010][3],p[3],vs,vp,ans[3];
double dist(double a[],double b[])
{
    int i;
    double res=0;
    for (i=0;i<3;i++) res+=(a[i]-b[i])*(a[i]-b[i]);
    return sqrt(res);
}
double can(double t)
{
    int i=1,j;
    double tt=t;
    while (t-dist(e[i],e[i-1])/vs>0&&i<n)//用我的時間走到他最後一個走完的站
    {
        t-=dist(e[i],e[i-1])/vs;
        i++;
    }
    i--;//已到的最後一站
    for (j=0;j<3;j++) ans[j]=e[i][j]+t/(dist(e[i+1],e[i])/vs)*(e[i+1][j]-e[i][j]);//倘若只走這個广向去到的距離//每個方向的比例一樣的，
    //都是可用時間over該段需用時間 *上單方向差找該方向偏移
    if (dist(p,ans)<=tt*vp) return 1;else return 0;//原點直接用這個時間能不能去到這個位
}
int main()
{
    int i,j;
    double l=0,r=0.000001,m;//eps
    scanf("%d",&n);
    for (i=0;i<=n;i++)
        for (j=0;j<3;j++) scanf("%lf",&e[i][j]);//coordinate
    scanf("%lf%lf",&vp,&vs);
    for (i=0;i<3;i++) scanf("%lf",&p[i]);//mystart point
    for (i=1;i<=n;i++)
        r+=dist(e[i],e[i-1])/vs;
    if (!can(r))//到終點也追不上
    {
        printf("NO\n");
        return 0;
    }
    while (l<r-esp)
    {
        m=(l+r)/2;
        if (can(m)) r=m;else l=m;
    }
    printf("YES\n");
    printf("%.10lf\n",r);
    printf("%.10lf %.10lf %.10lf\n",ans[0],ans[1],ans[2]);//earliest coor
    return 0;
}
