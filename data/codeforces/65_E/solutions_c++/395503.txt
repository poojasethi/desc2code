 #include <vector>
 #include <map>
 #include <string>
 #include <string.h>
 #include <sstream>
 #include <math.h>
 #include <time.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <algorithm>
 #include <iostream>
 using namespace std;


 #define max_int       INT_MAX / 2
 #define max_long      0xFFFFFFFFFFFFFFFLL / 2
 #define two(a)        (1 << (a))
 #define eps           1e-6
 #define FF(i, a, b)   for (int i = (a); i <= (b); i++)
 #define FFD(i, a, b)  for (int i = (a); i >= (b); i--)


 struct Edge {
     int u, v;
     bool changed;
     Edge() {}
     Edge(int u, int v) : u(u), v(v), changed(false) {}
 };


 int n, m;
 vector <Edge > edges;
 vector <int > edgeList[100010];


 void AddEdge(int u, int v) {
     int k = edges.size();
     edgeList[u].push_back(k);
     edgeList[v].push_back(k);
     edges.push_back(Edge(u, v));
 }


 struct Component {
     int root;
     int numEdges;
     int numV;
     int extraEdge;

     Component() {
         root = numEdges = numV = 0;
         extraEdge = -1;
     }


     bool operator <(const Component & x) const {
         if (numEdges - numV == x.numEdges - x.numV) return numEdges > x.numEdges;
         else return numEdges - numV > x.numEdges - x.numV;
     }
 };


 int numComps, comp[100010];
 vector <Component > components;


 vector <vector <int > > moveSteps;
 vector <vector <int > > moveEdges;
 bool vis[100010];
 int startComp, nextComp;





 void dfs(int u, int father) {
     comp[u] = numComps;
     int numChild = 0;
     for (int i = 0; i < edgeList[u].size(); i++) {
         int e = edgeList[u][i];
         if (e == father) continue;
         int v = (edges[e].u == u) ? edges[e].v : edges[e].u;
         if (comp[v] == -1) {
             dfs(v, e);
             numChild += 1;
         } else components.back().extraEdge = e;
     }
     if (numChild == 0 && father != -1 && components.back().extraEdge == -1) {
         if (edges[father].v != u) swap(edges[father].u, edges[father].v);
         components.back().extraEdge = father;
     }
 }


 void travel(int u, int father) {
     if (vis[u]) return;
     vis[u] = true;
     if (father == -1) moveSteps.push_back(vector <int >());
     moveSteps.back().push_back(u);
     for (int i = 0; i < edgeList[u].size(); i++) {
         int e = edgeList[u][i];
         if (e == father || edges[e].changed) continue;
         int v = (edges[e].u == u) ? edges[e].v : edges[e].u;
        if (vis[v] == 0) {
             travel(v, e);
             moveSteps.back().push_back(u);
         }
         if (edges[e].changed == 0 && nextComp < components.size()) {
             edges[e].changed = 1;
             int w = components[nextComp].root;
             vector <int > tmp;
             tmp.push_back(e + 1);
             tmp.push_back(u);
             tmp.push_back(w);
             moveEdges.push_back(tmp);
             nextComp += 1;
             moveSteps.push_back(vector <int >());
             travel(w, e);
             moveSteps.back().push_back(u);
         }
     }
 }


 int main(int argc, char** argv) {

     cin >> n >> m;
     edges.clear();
     for (int i = 1; i <= n; i++) edgeList[i].clear();

     int e, u, v;
     for (int i = 1; i <= m; i++) {
         cin >> u >> v;
         AddEdge(u, v);
     }


     components.clear();
     numComps = 0;
     memset(comp, -1, sizeof(comp));
     for (int i = 1; i <= n; i++) {
         if (comp[i] != -1) continue;
         components.push_back(Component());
         components.back().root = i;
         dfs(i, -1);
         numComps += 1;
     }
     for (int i = 1; i <= n; i++) {
         components[comp[i]].numV += 1;
         components[comp[i]].numEdges += edgeList[i].size();
     }
     for (int i = 0; i < components.size(); i++) {
         components[i].numEdges /= 2;
     }


     startComp = 0;
     nextComp = 1;
     memset(vis, 0, sizeof(vis));
     if (components.size() > 1) {
         sort(components.begin() + 1, components.end());
     }
     moveSteps.clear();
     moveEdges.clear();
     vector <int > tmp;
     if (components[0].numV == 1) {
         if (n == 1) {
             cout << "YES" << endl;
             cout << "0" << endl;
             cout << "1 1" << endl;
             return 0;
         }
         if (components[1].extraEdge == -1) {
             cout << "NO" << endl;
             return 0;
         } else {
             tmp.clear();
             tmp.push_back(1);
             moveSteps.push_back(tmp);
             e = components[1].extraEdge;
             v = edges[e].u;
             tmp.clear();
             tmp.push_back(e + 1);
             tmp.push_back(1);
             tmp.push_back(v);
             moveEdges.push_back(tmp);
             startComp = 1;
             components[1].root = v;
             vis[1] = true;
             edges[e].changed = true;
             if (components[1].numEdges + 1 == components[1].numV) {
                 components.push_back(Component());
                 components.back().root = edges[e].v;
                 components.back().numV = 1;
             }
         }
     }
     nextComp = startComp + 1;
    travel(components[startComp].root, -1);
     for (int i = 1; i <= n; i++) if (vis[i] == 0) {
         cout << "NO" << endl;
         return 0;
     }
     cout << "YES" << endl;
     cout << moveEdges.size() << endl;
     if (moveEdges.size() == moveSteps.size())
         moveSteps.push_back(vector <int >());
     for (int i = 0; i < moveEdges.size(); i++) {
         cout << moveSteps[i].size() << " ";
         for (int j = 0; j < moveSteps[i].size(); j++)
             cout << moveSteps[i][j] << " ";
         cout << endl;
         for (int j = 0; j < moveEdges[i].size(); j++)
             cout << moveEdges[i][j] << " ";
         cout << endl;
     }
     cout << moveSteps.back().size() << " ";
     for (int j = 0; j < moveSteps.back().size(); j++)
         cout << moveSteps.back()[j] << " ";
     cout << endl;

     return (EXIT_SUCCESS);
 }




/*
 * E. World Evil.cpp
 *
 *  Created on: 2011-2-26
 *      Author: user
 *
 * turn the maxFlow problem to a min-cut problem
 * and as n'is 5 we can use set-dp
 *


#include <cstdio>
#include <iostream>
#include <algorithm>
#include <climits>
using namespace std;
typedef long long int64;


const int MAX_N = 5;
const int MAX_M = 100000 + 10;
int64 xCap[MAX_N][MAX_M]; //(r,c)->(r,c+1)
int64 yCap[MAX_N][MAX_M]; //(r,c)->((r+1)%n,c)
int n, m;
int cutSet[1 << MAX_N];
int64 dp[MAX_M][1 << MAX_N];

int main() {
    scanf("%d%d", &n, &m);
    for (int c = 0; c < m - 1; ++c) {
        for (int r = 0; r < n; ++r) {
            scanf("%I64d", &xCap[r][c]);
        }
    }

    for (int c = 0; c < m; ++c) {
        for (int r = 0; r < n; ++r) {
            scanf("%I64d", &yCap[r][c]);
        }
    }

    for (int set = 0; set < (1 << n); ++set) {
        cutSet[set] = 0;
        for (int cur = 0; cur < n; ++cur) {
            bool withSource1 = set >> cur & 1;
            bool withSource2 = set >> ((cur + 1) % n)&1;
            if (withSource1^withSource2)
                cutSet[set] |= 1 << cur;
        }
    }


    fill(dp[0], dp[0]+(1 << n), LONG_LONG_MAX / 4);
    dp[0][(1 << n) - 1] = 0;


    int64 xSum[1 << MAX_N], ySum[1 << MAX_N];
    for (int c = 1; c < m; ++c) {
        fill(dp[c], dp[c]+(1 << n), LONG_LONG_MAX / 4);
        fill(xSum, xSum + (1 << n), 0);
        fill(ySum, ySum + (1 << n), 0);
        for (int set = 0; set < (1 << n); ++set) {
            for (int r = 0; r < n; ++r) {
                if (set >> r & 1)
                    xSum[set] += xCap[r][c - 1];
                if (cutSet[set] >> r & 1)
                    ySum[set] += yCap[r][c];
            }
        }
        for (int prevSet = 0; prevSet < (1 << n); ++prevSet) {
            for (int curSet = 0; curSet < (1 << n); ++curSet) {
                int64 tmp = dp[c - 1][prevSet] + xSum[prevSet^curSet] + ySum[curSet];
                if (tmp < dp[c][curSet])
                    dp[c][curSet] = tmp;
            }
        }
    }

    printf("%I64d\n", dp[m - 1][0]);
}
 */

