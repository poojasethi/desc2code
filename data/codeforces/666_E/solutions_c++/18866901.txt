#include<cstdio>
#include<cstdlib>
#include<cassert> 
#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstring>
#include<string>
#include<cmath>
#include<queue>
#include<stack>
#include<map>
#include<utility>
#include<set>
#include<bitset>
#include<vector>
#include<functional>
#include<deque>
#include<cctype>
#include<climits>
#include<complex>
#include<bits/stdc++.h>
#include<ctime>
#include<ext/rope>

using namespace __gnu_cxx; 
using namespace std;

typedef long long LL;
typedef double DB;
typedef pair<int,int> PII;
typedef pair<DB,DB> PDD;
typedef complex<DB> CP;
typedef vector<int> VI;

#define mmst(a,v) memset(a,v,sizeof(a))
#define mmcy(a,b) memcpy(a,b,sizeof(a))
#define fill(a,l,r,v) fill(a+l,a+r+1,v)
#define re(i,a,b)  for(i=(a);i<=(b);i++)
#define red(i,a,b) for(i=(a);i>=(b);i--)
#define fi first
#define se second
#define mp(a,b) make_pair(a,b)
#define pb(a) push_back(a)
#define two(k) (1<<(k))
#define SZ(x) (int(x.size()))
#define all(x) (x).begin(),(x).end()
#define ire(i,v,x) for(i=0,v=i<SZ(x)?x[i]:0;i<SZ(x);v=x[++i])
#define lson (rt<<1)
#define rson (rt<<1|1)  

template<class T>inline T sqr(T x){return x*x;}
template<class T>inline void upmin(T &t,T tmp){if(t>tmp)t=tmp;}
template<class T>inline void upmax(T &t,T tmp){if(t<tmp)t=tmp;}

inline int sgn(DB x){if(abs(x)<1e-9)return 0;return(x>0)?1:-1;}
const DB Pi=acos(-1.0);


int gint()
  {
		int res=0;bool neg=0;char z;
		for(z=getchar();z!=EOF && z!='-' && !isdigit(z);z=getchar());
		if(z==EOF)return 0;
		if(z=='-'){neg=1;z=getchar();}
		for(;z!=EOF && isdigit(z);res=(res<<3)+(res<<1)+z-'0',z=getchar());
		return (neg)?-res:res; 
	}
LL gll()
  {
  	LL res=0;bool neg=0;char z;
		for(z=getchar();z!=EOF && z!='-' && !isdigit(z);z=getchar());
		if(z==EOF)return 0;
		if(z=='-'){neg=1;z=getchar();}
		for(;z!=EOF && isdigit(z);res=res*10+z-'0',z=getchar());
		return (neg)?-res:res; 
	}

const int maxn=551000*2;

namespace SAM
{
struct Tsn
  {
	  int ch[26],fail,len;
		void init(){mmst(ch,0);fail=len=0;}
	}sn[maxn];int tot;
int newnode(){sn[++tot].init();return tot;}
void init(){tot=0;newnode();}
int add(int p,int x)
  {
  	if(sn[p].ch[x] && sn[sn[p].ch[x]].len==sn[p].len+1)return sn[p].ch[x];
  	int end=newnode();
  	sn[end].len=sn[p].len+1;
  	for(;p && !sn[p].ch[x];p=sn[p].fail)sn[p].ch[x]=end;
  	if(!p){sn[end].fail=1;return end;}
  	int q=sn[p].ch[x];
  	if(sn[q].len==sn[p].len+1){sn[end].fail=q;return end;}
  	int nq=newnode();
  	sn[nq]=sn[q];
  	sn[nq].len=sn[p].len+1;
  	sn[q].fail=sn[end].fail=nq;
  	for(;p && sn[p].ch[x]==q;p=sn[p].fail)sn[p].ch[x]=nq;
  	return end;
  }
}

namespace Seg
{
struct Tnode *null;
struct Tnode
  {
	  Tnode *c[2];PII mx;
	  void init(){c[0]=c[1]=null;mx=mp(0,0);}
	  void up(){mx=max(c[0]->mx,c[1]->mx);}
	}mem[20*maxn],*iT=mem;
void init(){null=iT++;null->init();}
Tnode *newnode(){iT->init();return iT++;}
Tnode *make(int l,int r,int x)
  {
  	Tnode *p=newnode();
  	if(l==r){p->mx=mp(1,-l);return p;}
  	int mid=(l+r)>>1;
  	if(x<=mid)p->c[0]=make(l,mid,x);else p->c[1]=make(mid+1,r,x);
  	return p->up(),p;
  }
Tnode *makeleaf(Tnode *x,Tnode *y){Tnode *z=newnode();z->mx=mp(x->mx.fi+y->mx.fi,x->mx.se);return z;}
Tnode *merge(Tnode *x,Tnode *y,int l,int r)
  {
  	if(x==null)return y;
  	if(y==null)return x;
  	if(l==r)return makeleaf(x,y);
  	Tnode *z=newnode();
  	int mid=(l+r)>>1;
  	z->c[0]=merge(x->c[0],y->c[0],l,mid);
  	z->c[1]=merge(x->c[1],y->c[1],mid+1,r);
  	return z->up(),z;
  }
PII ask(Tnode *rt,int l,int r,int x,int y)
  {
  	if(x<=l && r<=y)return rt->mx;
  	int mid=(l+r)>>1;
  	if(y<=mid)return ask(rt->c[0],l,mid,x,y);
  	if(mid+1<=x)return ask(rt->c[1],mid+1,r,x,y);
  	return max( ask(rt->c[0],l,mid,x,y) , ask(rt->c[1],mid+1,r,x,y) );
  }
}
using namespace SAM;
using namespace Seg;

int n,m;
char s[maxn],t[maxn];
int sp[maxn],tp[maxn];
PII bd[maxn];

int info[maxn],now;
struct Tedge{int v,next;}edge[maxn];
int jump[maxn][31];
Tnode *rt[maxn];

void addedge(int u,int v){edge[++now]=(Tedge){v,info[u]};info[u]=now;}

void build()
  {
  	int i,j,p;
  	SAM::init();
  	p=1;re(i,1,n)p=add(p,s[i]-'a');
  	re(i,1,m){p=1;re(j,bd[i].fi,bd[i].se)p=add(p,t[j]-'a');}
  	p=1;re(i,1,n)sp[i]=p=sn[p].ch[s[i]-'a'];
  	re(i,1,m){p=1;re(j,bd[i].fi,bd[i].se)tp[j]=p=sn[p].ch[t[j]-'a'];}
  	static int head,tail,que[maxn];
  	mmst(info,-1);now=-1;
  	re(i,2,tot)addedge(sn[i].fail,i);
  	que[head=tail=1]=1;
  	re(j,0,30)jump[1][j]=1;
  	while(head<=tail)
  	  {
  	  	int u=que[head++],v;
  	  	for(i=info[u],v=edge[i].v;i!=-1;i=edge[i].next,v=edge[i].v)
  	  	  {
  	  	  	jump[que[++tail]=v][0]=u;
  	  	  	re(j,1,30)jump[v][j]=jump[jump[v][j-1]][j-1];
  	  	  }
  	  }
  	Seg::init();
  	re(i,1,tot)rt[i]=null;
  	re(i,1,m)re(j,bd[i].fi,bd[i].se)rt[tp[j]]=merge(rt[tp[j]],make(1,m,i),1,m);
  	red(j,tail,1)
  	  {
  	  	int u=que[j],v;
  	  	for(i=info[u],v=edge[i].v;i!=-1;i=edge[i].next,v=edge[i].v)rt[u]=merge(rt[u],rt[v],1,m);
  	  }
  }

int find(int l,int r)
  {
  	int i,p=sp[r];
  	red(i,30,0)if(sn[jump[p][i]].len>=r-l+1)p=jump[p][i];
		return p;
	}

int main()
  {
  	/*freopen("CF666E.in","r",stdin);
  	freopen("CF666E.out","w",stdout);*/
  	int i;
  	scanf("%s\n",s+1);
  	n=strlen(s+1);
  	m=gint();
  	re(i,1,m)scanf("%s\n",t+bd[i-1].se+1),bd[i]=mp(bd[i-1].se+1,bd[i-1].se+strlen(t+bd[i-1].se+1));
  	build();
  	int Q=gint();
  	while(Q--)
  	  {
  	  	int l=gint(),r=gint(),pl=gint(),pr=gint();
  	  	int p=find(pl,pr);
  	  	PII res=ask(rt[p],1,m,l,r);
  	  	printf("%d %d\n",max(l,-res.se),res.fi);
  	  }
  	//printf("%d\n",(sizeof(jump)+sizeof(mem)+sizeof(sn))>>20);
  	return 0;
  }
 