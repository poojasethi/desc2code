#include<stdio.h>
#include<string.h>
#include<iostream>
#include<list>
using namespace std;
const int maxn=5E5+77;
const int log2maxn=20;
const int cL=26;

int M,Q,Len;
char S[maxn];

struct SEG{
	SEG *ch[2];
	pair<int,int> mx;
	SEG():mx(make_pair(0,0)){ch[0]=ch[1]=NULL;}
	SEG(const SEG *p){
		if(p!=NULL) memcpy(this,p,sizeof(SEG));
		else memset(this,0,sizeof(SEG));
	}
	void maintain(){
		if(ch[0]) mx=max(mx,ch[0]->mx);
		if(ch[1]) mx=max(mx,ch[1]->mx);
	}
};

void segAdd(SEG *&tr,int L,int R,int p,int v){
	if(tr==NULL) tr=new SEG;
	if(L==R){
		tr->mx.first+=v;
		tr->mx.second=-L;
		return;
	}
	int M=L+((R-L)>>1);
	if(p<=M) segAdd(tr->ch[0],L,M,p,v);
	else segAdd(tr->ch[1],M+1,R,p,v);
	tr->maintain();
}
SEG *segUnion(SEG *&tr1,SEG *tr2){
	if(tr2==NULL) return tr1;
	if(tr1==NULL) return tr1=tr2;
	tr1=new SEG(tr1); //functional data structure
	if(!tr1->ch[0] && !tr1->ch[1]){
		tr1->mx=make_pair(tr1->mx.first+tr2->mx.first,tr1->mx.second);
	}else{
		tr1->ch[0]=segUnion(tr1->ch[0],tr2->ch[0]);
		tr1->ch[1]=segUnion(tr1->ch[1],tr2->ch[1]);
		tr1->maintain();
	}
	return tr1;
}
pair<int,int> segQuery(SEG *tr,int L,int R,int qL,int qR){
	if(!tr) return make_pair(0,0);
	if(qL==L && qR==R) return tr->mx;
	int M=L+((R-L)>>1);
	if(qR<=M) return segQuery(tr->ch[0],L,M,qL,qR);
	else if(qL>M) return segQuery(tr->ch[1],M+1,R,qL,qR);
	else return max(segQuery(tr->ch[0],L,M,qL,M),segQuery(tr->ch[1],M+1,R,M+1,qR));
}

struct NODE{
	NODE *go[cL],*par,*anc[log2maxn];
	int len;
	SEG *s;
	NODE(int);
	void genAnc();
};
list<NODE *> nodes[maxn];
typedef list<NODE *>::iterator IT;
NODE::NODE(int _len):par(NULL),len(_len),s(NULL){
	memset(go,0,sizeof(go));
	memset(anc,0,sizeof(anc));
	nodes[_len].push_back(this);
}
void NODE::genAnc(){
	anc[0]=par;
	for(int i=1;i<log2maxn && anc[i-1];++i) anc[i]=anc[i-1]->anc[i-1];
}
NODE *root=new NODE(0),*last=root;

NODE *mp[maxn];
NODE *getNode(int l,int r){
	NODE *ret=mp[r];
	int len=r-l+1;
	for(int i=log2maxn-1;i>=0;--i)
		if(ret->anc[i] && ret->anc[i]->len>=len) ret=ret->anc[i];
	return ret;
}

void cpy(NODE *p,int w){
	NODE *q=p->go[w],*nq=new NODE(p->len+1);
	memcpy(nq->go,q->go,sizeof(NODE::go));
	nq->par=q->par;
	q->par=nq;
	while(p && p->go[w]==q) p->go[w]=nq,p=p->par;
}

void expand(char cc){
	int w=cc-'a';
	NODE *p=last,*np;
	if(p->go[w]){
		if(p->len+1!=p->go[w]->len) cpy(p,w);
		last=p->go[w];
		return;
	}
	np=new NODE(p->len+1);
	while(p && !p->go[w]) p->go[w]=np,p=p->par;
	if(!p) np->par=root;
	else{
		if(p->len+1!=p->go[w]->len) cpy(p,w);
		np->par=p->go[w];
	}
	last=np;
}

void debug(){
	for(int i=0;i<Len;++i){
		cerr<<"i:"<<i<<endl;
		for(NODE *p=mp[i];p;p=p->par){
			cerr<<"    "<<p->len<<":"<<(p->s->mx.first)<<","<<(p->s->mx.second)<<endl;
		}
	}
}

int main(){
	scanf("%s%d",S,&M);Len=strlen(S);
	for(int i=0;i<Len;++i) expand(S[i]),mp[i]=last;
	for(int i=1;i<=M;++i){
		scanf("%s",S);
		int ll=strlen(S);
		Len=max(Len,ll);
		last=root;
		for(int j=0;j<ll;++j) expand(S[j]),segAdd(last->s,1,M,i,1);
	}
	//cerr<<"Len:"<<Len<<endl;
	for(int i=Len;i;--i) for(IT it=nodes[i].begin();it!=nodes[i].end();++it){
		segUnion((*it)->par->s,(*it)->s);
	}
	for(int i=1;i<=Len;++i) for(IT it=nodes[i].begin();it!=nodes[i].end();++it){
		(*it)->genAnc();
	}
	//debug();
	for(scanf("%d",&Q);Q;--Q){
		int l,r,pl,pr;
		scanf("%d%d%d%d",&l,&r,&pl,&pr);--pl;--pr;
		pair<int,int> ans=segQuery(getNode(pl,pr)->s,1,M,l,r);
		if(ans.second==0) ans.second=-l;
		printf("%d %d\n",-ans.second,ans.first);
	}
}
