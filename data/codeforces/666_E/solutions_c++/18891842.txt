#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cstdlib>
#include <cmath>
using namespace std;

#define MAXLEN 600050
#define INVALID make_pair(0, -100000000)

namespace Seg_tree
{
	struct Tnode
	{
		pair<int, int> maxv;
		Tnode *son[2];
		Tnode()
		{
			maxv = INVALID;
			son[0] = son[1] = 0;
		}
		void update()
		{
			maxv = INVALID;
			if (son[0] && son[0] -> maxv > maxv) 
				maxv = son[0] -> maxv;
			if (son[1] && son[1] -> maxv > maxv) 
				maxv = son[1] -> maxv;
		}
	} Mem[MAXLEN * 40], *cur_Mem;
	int M;
	void Init(int _M)
	{
		M = _M;
		cur_Mem = Mem;
	}
	void NewNode(Tnode *&r)
	{
		Tnode *r0 = r;
		r = cur_Mem++;
		if (r0) *r = *r0;
	}
	void _Insert(Tnode *&r, int L, int R, int x)
	{
		NewNode(r);
		if (L == x && R == x) 
		{
			if (r -> maxv == INVALID) r -> maxv = make_pair(0, -x);
			++ r -> maxv.first;
			return ;
		}
		int mid = (L+R)>>1;
		if (x <= mid) _Insert(r->son[0], L, mid, x);
			else _Insert(r->son[1], mid+1, R, x);
		r -> update();
	}
	Tnode* _Merge(Tnode *A, Tnode *B, int L, int R)
	{
		if (!A) return B;
		if (!B) return A;
		Tnode *res = new Tnode;
		if (L == R)
		{
			res -> maxv = make_pair(A->maxv.first + B->maxv.first, -L);
			return res;
		}
		int mid = (L+R)>>1;
		res -> son[0] = _Merge(A->son[0], B->son[0], L, mid);
		res -> son[1] = _Merge(A->son[1], B->son[1], mid+1, R);
		res -> update();
		return res;
	}
	pair<int, int> _AskMax(Tnode *r, int L, int R, int x, int y)
	{
		if (L > y || R < x || !r) return make_pair(0, -x);
		if (L >= x && R <= y) return r -> maxv;
		int mid = (L+R)>>1;
		return max(_AskMax(r->son[0], L, mid, x, y), 
				   _AskMax(r->son[1], mid+1, R, x, y) );
	}
	
	void Insert(Tnode *&r, int x)
	{
		_Insert(r, 1, M, x);
	}
	Tnode* Merge(Tnode *A, Tnode *B)
	{
		return _Merge(A, B, 1, M);
	}
	pair<int, int> AskMax(Tnode *r, int L, int R)
	{
		return _AskMax(r, 1, M, L, R);
	}
}

namespace SAM //后缀自动机
{
	struct Tnode
	{
		Tnode *fail, *son[26];
		Tnode* f[22];
		int len;
		Seg_tree::Tnode *tree;
		Tnode()
		{
			tree = 0;
			memset(son, 0, sizeof(son));
			memset(f, 0, sizeof(f));
			fail = 0;
			len = 0;
		}
		void Mark(int id)
		{
			if (id == -1) return ;
			Seg_tree::Insert(tree, id);
		}
		void Merge(Tnode *b)
		{
			tree = Seg_tree::Merge(tree, b->tree);
		}
		pair<int, int> AskMax(int L, int R)
		{
			return Seg_tree::AskMax(tree, L, R);
		}
	} Mem[MAXLEN*2], *cur_Mem, *r, *iter, *pos[MAXLEN];
	Tnode *NewNode()
	{
		return cur_Mem ++;
	}
	void Init()
	{
		cur_Mem = Mem;
		r = NewNode();
	}
	Tnode* Add_chr(Tnode *iter, char ch)
	{
		int c = ch - 'a';
		Tnode *p = iter;
		Tnode *now = 0;
		if (!p->son[c])
		{
			now = NewNode();
			now->len = p->len + 1;
			while (p && !(p -> son[c]))
			{
				p -> son[c] = now;
				p = p -> fail;
			}
			if (!p) { now -> fail = r; return now; }
		}
		Tnode *q = p -> son[c];
		if (q->len == p->len + 1) 
		{
			if (now) now -> fail = q;
			return iter -> son[c];
		}
		Tnode *newq = NewNode();
		newq -> len = p -> len + 1;
		memcpy(newq->son, q->son, sizeof(q->son));
		newq -> fail = q -> fail;
		q -> fail = newq;
		if (now) now -> fail = newq;
		while (p && (p -> son[c] == q))
		{
			p -> son[c] = newq;
			p = p -> fail;
		}
		return iter -> son[c];
	}
	
	//char S[MAXLEN];	//DEBUG
	
	void Build_str(char *st, int id = -1)
	{
		//if (id == -1) strcpy(S, st);
		for (iter = r; *st; ++ st)
		{
			(iter = Add_chr(iter, *st)) -> Mark(id);
			if (id == -1) pos[iter->len] = iter;
		}
	}
	Tnode *ord[MAXLEN*2];
	int sum[MAXLEN];
	void Finish()
	{
		int tot = cur_Mem - Mem;
		for (int i = 0; i < tot; ++ i) 
			Mem[i].f[0] = Mem[i].fail;
		for (int j = 1; j <= 20; ++ j)
			for (int i = 0; i < tot; ++ i) 
			{
				Tnode *&tmp = Mem[i].f[j] = Mem[i].f[j-1];
				if (tmp) tmp = Mem[tmp-Mem].f[j-1];
			}
		//sort
		for (int i = 0; i < tot; ++ i)
			++ sum[ Mem[i].len ];
		for (int i = 1; i < MAXLEN; ++ i) sum[i] += sum[i-1];
		for (int i = 0; i < tot; ++ i) 
			ord[ --sum[Mem[i].len] ] = Mem + i;
		//Update
		for (int i = tot-1; i >= 0; -- i)
			if (ord[i]->fail)
				(ord[i]->fail) -> Merge(ord[i]);	
	}
	Tnode* Search_substr(int L, int R)	//S
	{
		int Len = R - L + 1;
		Tnode *res = pos[R];
		for (int i = 20; i >= 0; -- i) 
			if (res->f[i])
				if (res->f[i]->len >= Len) res = res -> f[i];
		return res;
	}
	
	//DEBUG
	/*
	Tnode* Search_substr(int L, int R)	//S
	{
		Tnode *res = r;
		for (char *st = S+L-1; st < S+R; ++ st)
			res = res -> son[*st - 'a'];
		return res;
	}*/
}

int main()
{//	printf("%d\n", (sizeof(Seg_tree::Mem) + sizeof(SAM::Mem)) >> 20);
	static char st[MAXLEN];
	scanf("%s", st);
	SAM::Init();
	SAM::Build_str(st, -1);
	
	int M;
	scanf("%d", &M);
	Seg_tree::Init(M);
	for (int i = 1; i <= M; ++ i) 
	{
		scanf("%s", st);
		SAM::Build_str(st, i);
	}
	
	SAM::Finish();
	
	int Q;
	scanf("%d", &Q);
	while (Q--)
	{
		int L, R, pL, pR;
		scanf("%d%d%d%d", &L, &R, &pL, &pR);
		SAM::Tnode *addr = SAM::Search_substr(pL, pR);
		pair<int, int> res = addr->AskMax(L, R);
		printf("%d %d\n", -res.second, res.first);
	}
	
	return 0;
}