#include<cstdio>
#include<cstring>
#include<algorithm>
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
using namespace std;
const int N=1200000,M=100000*23;
char ch[N];
int diff,a[N],tmp[N],rank[N],sa[N],t[N],s[N],left[N],right[N],f[M],son[M][2],height[N],fa[N],info[N],n,tot,mx[N];
void DA()
{
	fo(i,1,diff) s[i]=0;
	fo(i,1,n) s[rank[i]]++;
	fo(i,1,diff) s[i]+=s[i-1];
	fd(i,n,1) sa[s[rank[tmp[i]]]--]=tmp[i];
}
void SA()
{
	diff=100000;
	fo(i,1,n) tmp[i]=i;
	fo(i,1,n) rank[i]=a[i];
	DA();
	diff=1;
	int last=rank[sa[1]];
	rank[sa[1]]=1;
	fo(i,2,n) if (rank[sa[i]]!=last) last=rank[sa[i]],rank[sa[i]]=++diff; else
	rank[sa[i]]=diff;
	for(int len=1;diff<n;len*=2)
	{
		int top=n;
		fd(i,n,1)
		if (sa[i]>len) tmp[top--]=sa[i]-len;
		fo(i,n-len+1,n) tmp[top--]=i;
		DA();
		memcpy(tmp,rank,sizeof tmp);
		diff=1;
		rank[sa[1]]=1;
		fo(i,2,n)
			rank[sa[i]]=(diff+=tmp[sa[i]]!=tmp[sa[i-1]] || tmp[sa[i]+len]!=tmp[sa[i-1]+len]);
	}
	fo(i,1,n)
	if (rank[i]!=n)
	{
		height[i]=max(height[i-1]-1,0);
		while (a[i+height[i]]==a[sa[rank[i]+1]+height[i]]) height[i]++;
	}
}
int find(int x)
{
	if (fa[x]==x) return x; 
	fa[x]=find(fa[x]);
	left[fa[x]]=min(left[fa[x]],left[x]);
	right[fa[x]]=max(right[fa[x]],right[x]);
	return fa[x];
}
int ans[N][2];
struct node{
	int l,r,x,y,q;
} q[N];
bool cmp(const node &a,const node &b)
{
	return a.r-a.l>b.r-b.l;
}
int co;
int build(int l,int r,int wz)
{
	int now=++tot;
	if (l==r)
	{
		f[now]=1;
		mx[now]=l;
		return now;
	}
	int mid=(l+r)>>1;
	if (wz<=mid) son[now][0]=build(l,mid,wz),mx[now]=mx[son[now][0]]; else
	son[now][1]=build(mid+1,r,wz),mx[now]=mx[son[now][1]];
	f[now]=1;
	return now;
}
int merge(int l,int r,int x,int y)
{
	if (x==0) return y; 
	if (y==0) return x;
	if (l==r)
	{
		f[x]+=f[y];
		mx[x]=l;
		return x;
	}
	int mid=(l+r)>>1;
	son[x][0]=merge(l,mid,son[x][0],son[y][0]);
	son[x][1]=merge(mid+1,r,son[x][1],son[y][1]);
	if (f[son[x][0]]<f[son[x][1]]) f[x]=f[son[x][1]],mx[x]=mx[son[x][1]]; else
	f[x]=f[son[x][0]],mx[x]=mx[son[x][0]];
	return x;
}
int a1,a2;
void query(int l,int r,int now,int x,int y)
{
	if (l==x && r==y)
	{
		if (f[now]>a1) a1=f[now],a2=mx[now];
		return;
	}
	int mid=(l+r)>>1;
	if (y<=mid) query(l,mid,son[now][0],x,y); else
	if (x>mid) query(mid+1,r,son[now][1],x,y); else
	query(l,mid,son[now][0],x,mid),query(mid+1,r,son[now][1],mid+1,y);
}
int main()
{
	scanf("%s",ch+1);
	n=strlen(ch+1);
	int last=n+1;
	int tot=256;
	fo(i,1,n) a[i]=ch[i];
	a[last]=++tot;
	int m;
	scanf("%d",&m);
	fo(i,1,m)
	{
		scanf("%s",ch+1);
		int l=strlen(ch+1);
		fo(j,1,l) a[++last]=ch[j],t[last]=i;
		a[++last]=++tot;
	}
	co=m;
	n=last;
	SA();
	tot=0;
	fo(i,1,n) 
	{
		left[i]=i,right[i]=i,fa[i]=i;
		if (t[i]!=0) info[rank[i]]=build(1,m,t[i]);
	}
	scanf("%d",&m);
	fo(i,1,m)
	{
		scanf("%d%d%d%d",&q[i].x,&q[i].y,&q[i].l,&q[i].r);
		q[i].q=i;
	}
	sort(q+1,q+1+m,cmp);
	fo(i,1,m)
	{
		int l=q[i].l,r=q[i].r,x=q[i].x,y=q[i].y;
		int len=r-l+1;
		int now=rank[l]; 
		while (1)
		{
			now=left[find(now)];
			if (now==1) break;
			if (height[sa[now-1]]>=len)
			{
				int x=find(now-1),y=find(now);
				fa[x]=y;
				info[y]=merge(1,co,info[x],info[y]);
				find(x);
			} else break;
		}
		now=rank[l];
		while (1)
		{
			now=right[find(now)];
			if (now==n) break;
			if (height[sa[now]]>=len)
			{
				int x=find(now),y=find(now+1);
				fa[x]=y;
				info[y]=merge(1,co,info[x],info[y]);
				find(x);
			} else break;
		}
		now=find(rank[l]);
		a1=a2=0;
		query(1,co,info[now],x,y);
		if (a1==0) a2=x;
		ans[q[i].q][0]=a2;
		ans[q[i].q][1]=a1;
	}
	fo(i,1,m) printf("%d %d\n",ans[i][0],ans[i][1]);
} 
