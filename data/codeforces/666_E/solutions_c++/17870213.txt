#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <algorithm>
#include <cassert>

using namespace std;

template <class TAT>
inline void read(TAT &a)
{
	static char cc;
	static bool f;
	while ((cc = getchar()) != '-' && (cc < '0' || cc > '9'));
	if (cc == '-') f = 1, a = 0;
	else f = 0, a = cc - '0';
	while ((cc = getchar()) >= '0' && cc <= '9') a = a * 10 + cc - '0';
	if (f) a = -a;
}
template <class TAT>
inline void write(TAT a)
{
	static char cc[27];
	static int ct;
	if (a == 0) {
		putchar('0');
		return;
	}
	if (a < 0) {
		a = -a;
		putchar('-');
	}
	ct = 0;
	while (a) cc[++ct] = a % 10 + '0', a /= 10;
	while (ct) putchar(cc[ct--]);
}
template <class TAT>
inline void Ckmin(TAT &a, const TAT &b)
{
	if (a > b) a = b;
}
template <class TAT>
inline void Ckmax(TAT &a, const TAT &b)
{
	if (a < b) a = b;
}
void begin()
{
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);
}
void end()
{
	fclose(stdin);
	fclose(stdout);
}

#define dig(...) fprintf(stderr, __VA_ARGS__)

const int maxn = 7e4+115;
const int maxs = 7e5+115;

int n, m, Q;
int cL[maxn], cR[maxn], total;
int tablet[maxn];
char S[maxs];
char C[maxn * 2];
bool f__k = 0;
struct node
{
	int Len;
	bool real;
	int c[27], fail;
	void strip(int _l, bool _r)
	{
		Len = _l;
		real = _r;
		fail = 0;;
		memset(c, 0, sizeof(c));
	}
}dot[maxn * 3 + 115];
int dt = 0, Root, last;
int fa[23][maxn * 3], DL[maxs], dest[maxs];
int size[maxs * 3], rank[maxs * 3], sa[maxs * 3];
int root[maxs * 3];

int lc[maxs * 43], rc[maxs * 43], ms[maxs * 43], pt = 0;

void Init()
{
	scanf("%s", S + 1);
	m = strlen(S + 1);
	read(n);
	total = 0;
	for (int i = 1; i <= n; ++i) {
		C[++total] = 'a' + 26;
		++total;
		scanf("%s", C + total);
		cL[i] = total;
		total += strlen(C + total) - 1;
		cR[i] = total;
		tablet[i] = cL[i];
	}
}

void Insert(int ch, int _L)
{
	static int now, former, tmp, p;
	now = (++dt);
	dot[now].strip(_L, 1);
	p = last;
	last = now;
	while (p != 0 && dot[p].c[ch] == 0) {
		dot[p].c[ch] = now;
		p = dot[p].fail;
	}
	if (p == 0) {
		dot[now].fail = Root;
	}
	else {
		if (dot[dot[p].c[ch]].Len == dot[p].Len + 1) {
			dot[now].fail = dot[p].c[ch];
		}
		else {
			tmp = (++dt);
			dot[tmp].strip(dot[p].Len + 1, 0);
			former = dot[p].c[ch];
			memcpy(dot[tmp].c, dot[former].c, sizeof(dot[tmp].c));
			dot[tmp].fail = dot[former].fail;
			dot[former].fail = tmp;
			dot[now].fail = tmp;
			while (p && dot[p].c[ch] == former) {
				dot[p].c[ch] = tmp;
				p = dot[p].fail;
			}
		}
	}
}

void Go()
{
	int now;
	int Cnt = 0;
	now = Root;
	for (int i = 1; i <= m; ++i) {
		while (now && dot[now].c[S[i] - 'a'] == 0) {
			now = dot[now].fail;
			Cnt = dot[now].Len;
		}
		if (now == 0) {
			now = Root;
			Cnt = 0;
		}
		else {
			/*			if (dot[now].c[S[i] - 'a'] > dt) {
				dt += 1;
				dt -= 1;
				}*/
			now = dot[now].c[S[i] - 'a'];
			++Cnt;
		}
		dest[i] = now;
		DL[i] = Cnt;
	}
}

int Addone(int l, int r, int aim)
{
	int mid = (l + r) / 2;
	int p = ++pt;
	if (l == r) {
		lc[p] = rc[p] = 0;
		ms[p] = 1;
		return p;
	}
	if (aim <= mid) {
		lc[p] = Addone(l, mid, aim);
		ms[p] = 1;
		return p;
	}
	else {
		rc[p] = Addone(mid + 1, r, aim);
		ms[p] = 1;
		return p;
	}
}

int Hb(int l, int r, int r1, int r2)
{
	int mid = (l + r) / 2;
	if (r1 == 0 && r2 == 0) return 0;
	else if (r1 == 0) {
		return r2;
	}
	else if (r2 == 0) {
		return r1;
	}
	else {
		int p = ++pt;
		if (l == r) {
			lc[p] = rc[p] = 0;
			ms[p] = ms[r1] + ms[r2];
			return p;
		}
		lc[p] = Hb(l, mid, lc[r1], lc[r2]);
		rc[p] = Hb(mid + 1, r, rc[r1], rc[r2]);
		ms[p] = max(ms[lc[p]], ms[rc[p]]);
		return p;
	}
}

void Prepare()
{
	static pair<int, int> Da[maxs * 3];
	int cnt = 0, p, to, tmp;
	dot[0].Len = -1e9;
	last = Root = (++dt);
	dot[Root].strip(0, 0);
	for (int i = 1; i <= total; ++i) {
		Insert(C[i] - 'a', i);
	}
	
	Go();
	for (int i = 1; i <= dt; ++i) {
		fa[0][i] = dot[i].fail;
	}
	for (int i = 1; i <= 20; ++i) {
		for (int j = 1; j <= dt; ++j) {
			fa[i][j] = fa[i - 1][fa[i - 1][j]];
		}
	}
	
	for (int i = 1; i <= dt; ++i) {
		Da[i] = make_pair(dot[i].Len, i);
	}
	sort(Da + 1, Da + 1 + dt);
	for (int i = 1; i <= dt; ++i) sa[i] = Da[i].second;
	for (int i = 1; i <= dt; ++i) rank[sa[i]] = i;

	lc[0] = rc[0] = 0;
	for (int i = 1; i <= dt; ++i) {
		if (dot[i].real == 0) {
			root[i] = 0;
		}
		else {
			root[i] = Addone(1, n, upper_bound(tablet + 1, tablet + 1 + n, dot[i].Len) - tablet - 1);
		}
	}
	for (int i = dt; i >= 1; --i) {
		p = sa[i];
		to = dot[p].fail;
		tmp = root[to];
		root[to] = Hb(1, n, tmp, root[p]);
	}
}

int Getpos(int L, int p)
{
	for (int i = 20; i >= 0; --i) {
		if (dot[fa[i][p]].Len >= L) {
			p = fa[i][p];
		}
	}
	return p;
}

int Mt, Max;
void Ask(int l, int r, int L, int R, int p)
{
	int mid = (l + r) / 2;
	if (L <= l && R >= r) {
		if (l == r) {
			if (Max < ms[p] || (Max == ms[p] && Mt > l)) {
				Max = ms[p];
				Mt = l;
			}
			return;
		}
		if (ms[lc[p]] >= ms[rc[p]]) Ask(l, mid, L, R, lc[p]);
		else Ask(mid + 1, r, L, R, rc[p]);
		return;
	}
	if (L <= mid) {
		Ask(l, mid, L, R, lc[p]);
	}
	if (R > mid) {
		Ask(mid + 1, r, L, R, rc[p]);
	}
}

void Solve()
{
	read(Q);
	int l, r, pl, pr;
	int pos;
	for (int i = 1; i <= Q; ++i) {
		read(pl), read(pr);
		read(l), read(r);
		/*
		if (i == 81 && f__k == 1) {
			printf("%d %d %d %d\n", pl, pr, l, r);
			printf("%d\n", DL[r]);
			for (int j = cL[40208]; j <= cR[40208]; ++j) {
				printf("%c", C[j]);
			}
			putchar('\n');
		}
		if (f__k == 1) continue;*/
		if (DL[r] < r - l + 1) {
			//			printf("%d %d\n", pl, 0);
			write(pl); putchar(' ');
			putchar('0'); putchar('\n');
			if (i == 1 && pl == 2875) f__k = 1;
		}
		else {
			pos = Getpos(r - l + 1, dest[r]);
			Mt = 0;
			Max = -1;
			Ask(1, n, pl, pr, root[pos]);
			write(Mt); putchar(' ');
			write(Max); putchar('\n');
			if (i == 1 && Mt == 2875) f__k = 1;
			//			printf("%d %d\n", Mt, Max);
		}
	}
	//	dig("%d\n%d\n", total, pt);
}

int main()
{
	
	Init();
	Prepare();
	Solve();
	
	return 0;
}
