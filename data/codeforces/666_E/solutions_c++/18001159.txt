#include <cstdio>
#include <cstring>
#include <algorithm>
#define maxn 1240000
#define maxq 500100
#define Pair pair<int,int>
using namespace std;

struct str { int v,nex; } lis[maxn];

struct seg_node {
	seg_node *lk, *rk;
	int Max,Maxp;
} seg_pool[maxn * 20];
	
struct node {
	node *f,*nex[27], *st[22];
	int ml,fst,snum;
	seg_node *root ;
	node () { ml = 0; }
} pool[maxn],*tail, *head;

struct Quer {
	int l,r,pl,pr,num;
	void read() { scanf("%d %d %d %d",&l,&r,&pl,&pr); }	
} quer[maxq];

Pair ans[maxq];
int n,m,q,N,tot,e,seg_tot;
int L[maxq],R[maxq];
char s[maxn];

void add(int ch,int len) {
	node *p = tail, *np = &pool[++tot];
	np -> ml = len;
	for (; p && !p -> nex[ch]; p = p -> f) p -> nex[ch] = np;
	tail = np;
	if (!p) np -> f = head;
	else {
		if (p -> nex[ch] -> ml == p -> ml + 1) np -> f = p -> nex[ch];
		else {
			node *q = p -> nex[ch], *just = &pool[++tot];
			*just = *q;
			just -> ml = p -> ml + 1;
			q -> f = np -> f = just;
			for (; p && p -> nex[ch] == q; p = p -> f) p -> nex[ch] = just;
		}
	}
}

void prepare() {	
	for (int i = 1; i <= tot; i++) pool[i].st[0] = pool[i].f;
	
	for (int j = 0; j < 20; j++) {
		for (int i = 1; i <= tot; i++) {
			if (pool[i].st[j] != NULL)
				pool[i].st[j + 1] = pool[i].st[j] -> st[j];
		}
	}
}

node *jump(node *u, int len) {
	int k = 20;
	for (; u -> st[k] == NULL; k--);
	for (; k >= 0; ) {
		for ( ; k >= 0 && (u -> st[k] == NULL || (u -> st[k] -> ml < len)); k--);
		if (k >= 0) u = u -> st[k];
		else break;
	}
	return u;
}

void add_query(node *u, int v) {
	lis[++e].nex = u -> fst;
	u -> fst = e;
	lis[e].v = v;
}

#define midl ((L + R) >> 1)
#define midr (midl + 1)

seg_node *change_seg(seg_node *u, int p,int L,int R) {
	if (u == NULL) u = &seg_pool[++seg_tot];
	if (L == R) { u -> Max++; u -> Maxp = p; return u; }
	if (p < midr) {
		u -> lk = change_seg(u -> lk, p, L, midl);
		if (u -> lk -> Max > u -> Max || (u -> lk -> Max == u -> Max && u -> lk -> Maxp < u -> Maxp)) {
			u -> Max = u -> lk -> Max;
			u -> Maxp = u -> lk -> Maxp;
		}
	}
	else {
		u -> rk = change_seg(u -> rk, p, midr, R);
		if (u -> rk -> Max > u -> Max || (u -> rk -> Max == u -> Max && u -> rk -> Maxp < u -> Maxp)) {
			u -> Max = u -> rk -> Max;
			u -> Maxp = u -> rk -> Maxp;
		}
	}
	return u;
}

void add_seg(node *u, int p) {
	u -> root = change_seg(u -> root, p, 1, m);
}

node *que[maxn]; // zhu yi

void topsort() {
	int L = 0, R = 0;
	for (int i = 1; i <= tot; i++) {
		if (pool[i].f != NULL) pool[i].f -> snum++;
	}
	for (int i = 1; i <= tot; i++) {
		if (pool[i].snum == 0) que[++R] = &pool[i];
	}
	while (L < R) {
		node *u = que[++L];
		if (u -> f == NULL) continue;
		if (--(u -> f -> snum) == 0) que[++R] = u -> f;
	}
}

seg_node *query(seg_node *u,int L,int R,int l,int r) {
	if (u == NULL) return u;
	if (L == l && R == r) return u;
	if (r < midr) return query(u -> lk, L, midl, l, r);
	else if (l > midl) return query(u -> rk, midr, R, l, r);
	else {
		seg_node *a = query(u -> lk, L, midl, l, midl);
		seg_node *b = query(u -> rk, midr, R, midr, r);
		if (a == NULL) return b;
		if (b == NULL) return a;
		if (a -> Max >= b -> Max) return a;
		else return b;
	}
}

seg_node *merge(seg_node *a, seg_node *b, int L,int R) {
	if (a == NULL) return b;
	if (b == NULL) return a;
	if (L == R) { a -> Max += b -> Max; return a; }
	a -> lk = merge(a -> lk, b -> lk, L, midl);
	a -> rk = merge(a -> rk, b -> rk, midr, R);
	if (a -> lk != NULL) {
		if (a -> lk -> Max > a -> Max || (a -> lk -> Max == a -> Max && a -> lk -> Maxp < a -> Maxp)) {
			a -> Max = a -> lk -> Max;
			a -> Maxp = a -> lk -> Maxp;
		}
	}
	if (a -> rk != NULL) {
		if (a -> rk -> Max > a -> Max || (a -> rk -> Max == a -> Max && a -> rk -> Maxp < a -> Maxp)) {
			a -> Max = a -> rk -> Max;
			a -> Maxp = a -> rk -> Maxp;
		}
	}
	return a;
}

void get_ans() {
	for (int t = 1; t <= tot; t++) {
		node *u = que[t];
		for (int i = u -> fst; i; i = lis[i].nex) {
			int v = lis[i].v;
			seg_node *ans_ = query(u -> root,1,m,quer[v].l,quer[v].r);
			if (ans_ == NULL) ans[quer[v].num] = make_pair(0,quer[v].l);
			else ans[quer[v].num] = make_pair(ans_ -> Max, ans_ -> Maxp);
		}
		if (u -> f == NULL) continue;
		u -> f -> root = merge(u -> f -> root, u -> root, 1, m);
	}
}

bool cmp(const Quer &a, const Quer &b) {
	return (a.pr < b.pr);
}

int main() {
	scanf("%s",s + 1); n = strlen(s + 1);
	N = n;
	s[++N] = 'a' + 26;
	scanf("%d",&m);
	for (int i = 1; i <= m; i++) {
		scanf("%s",s + N + 1);
		L[i] = N + 1;
		N += strlen(s + N + 1);
		R[i] = N;
		s[++N] = 'a' + 26;
	}
	head = tail = &pool[++tot];
	for (int i = 1; i <= N; i++) add(s[i] - 'a', i);
	prepare();
	scanf("%d",&q);
	for (int i = 1; i <= q; i++) { quer[i].read(); quer[i].num = i; }
	sort(quer + 1, quer + q + 1, cmp);

	prepare();
	node *u = head; int p = 1;
	for (int i = 1; i <= n; i++) {
		u = u -> nex[s[i] - 'a'];
		for ( ;p <= q && quer[p].pr == i; p++) {
			node *v = jump(u, quer[p].pr - quer[p].pl + 1);
			add_query(v, p);
		}
	}

	for (int t = 1; t <= m; t++) {
		u = head;
		for (int i = L[t]; i <= R[t]; i++) {
			u = u -> nex[s[i] - 'a'];
			add_seg(u, t);
		}
	}

	topsort();
	get_ans();

	for (int i = 1; i <= q; i++) printf("%d %d\n",ans[i].second,ans[i].first);
	return 0;
}