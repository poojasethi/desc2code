#include <algorithm>
#include <iostream>
#include <cstring>
#include <vector>
#include <cstdio>
#define Clear(a, b) memset(a, b, sizeof a)
#define Copy(a, b) memcpy(a, b, sizeof a)
using namespace std;

template<class T>
inline bool GetMax(T &x, T y) {
	if (x < y) { x = y; return 1; }
	return 0;
}

const int N = 5e5 + 10, M = 5e4 + 10;

int n, m, q, qry[N][2];
char s[N], t[M];

struct Data {
	int val, pos;
	Data() {}
	Data(int _val, int _pos) {
		val = _val, pos = _pos;
	}
	bool friend operator < (Data &a, Data &b) {
		if (a.val != b.val) return a.val < b.val;
		else return a.pos > b.pos;
	}
};

Data ans[N];

namespace SegTree {
	const int L = 20, N = M * L;

	Data tr[N];
	int tot, lch[N], rch[N];

	int Modify(int u, int l, int r, int p) {
		int v = u ? u : ++tot;
		if (l == r) {
			tr[v] = Data(tr[u].val + 1, p);
			return v;
		}
		int m = (l + r) >> 1;
		if (p <= m) lch[v] = Modify(lch[u], l, m, p);
		else rch[v] = Modify(rch[u], m + 1, r, p);
		GetMax(tr[v], tr[lch[v]]);
		GetMax(tr[v], tr[rch[v]]);
		return v;
	}

	int Merge(int u, int v, int l, int r) {
		if (!u || !v) return u ^ v;
		if (l == r) {
			tr[u].val += tr[v].val;
			tr[u].pos = l;
			return u;
		}
		int m = (l + r) >> 1;
		lch[u] = Merge(lch[u], lch[v], l, m);
		rch[u] = Merge(rch[u], rch[v], m + 1, r);
		GetMax(tr[u], tr[lch[u]]);
		GetMax(tr[u], tr[rch[u]]);
		return u;
	}

	Data Query(int u, int l, int r, int p, int q) {
		if (r < p || q < l || !u) return Data(0, p);
		if (p <= l && r <= q) return tr[u];
		int m = (l + r) >> 1;
		Data res = Data(0, p);
		GetMax(res, Query(lch[u], l, m, p, q));
		GetMax(res, Query(rch[u], m + 1, r, p, q));
		return res;
	}
}

namespace Sam {
	const int L = 20, N = M * L, S = 27;

	int lst, tot, fa[N], len[N], go[N][S], id[N];

	void Init() {
		lst = tot = 1;
	}

	inline int Expand(int p, int c, int fr) {
		int np = ++tot;
		len[np] = len[p] + 1;
		for (; p && !go[p][c]; p = fa[p])
			go[p][c] = np;
		if (!p)
			fa[np] = 1;
		else {
			int q = go[p][c];
			if (len[p] + 1 == len[q])
				fa[np] = q;
			else {
				int nq = ++tot;
				len[nq] = len[p] + 1;
				Copy(go[nq], go[q]);
				fa[nq] = fa[q];
				fa[np] = fa[q] = nq;
				for (; p && go[p][c] == q; p = fa[p])
					go[p][c] = nq;
			}
		}
		id[np] = fr;
		return np;
	}

	inline void Insert(char *s, int fr) {
		int n = strlen(s + 1);
		for (int i = 1; i <= n; ++i)
			lst = Expand(lst, s[i] - 'a' + 1, fr);
		lst = Expand(lst, 0, 0);
	}

	int anc[N][L], rt[N], match[N][2];

	void Calc() {
		for (int i = 1; i <= tot; ++i)
			anc[i][0] = fa[i];
		for (int j = 1; j < L; ++j)
			for (int i = 1; i <= tot; ++i)
				anc[i][j] = anc[anc[i][j - 1]][j - 1];

		for (int i = 1, p = 1, l = 0; i <= n; ++i) {
			int c = s[i] - 'a' + 1;
			for (; p && !go[p][c]; p = fa[p], l = len[p]);
			if (go[p][c]) {
				p = go[p][c];
				++l;
				match[i][0] = p;
				match[i][1] = l;
			}
			else 
				p = 1;
		}
	}

	int Find(int p, int ln) {
		for (int i = L - 1; i >= 0; --i)
			if (len[anc[p][i]] >= ln)
				p = anc[p][i];
		return p;
	}

	vector<int> qry[N];
	int q[N];

	void TopoSort() {
		static int tank[N];
		for (int i = 1; i <= tot; ++i)
			++tank[len[i]];
		for (int i = 1; i <= tot; ++i)
			tank[i] += tank[i - 1];
		for (int i = 1; i <= tot; ++i)
			q[tank[len[i]]--] = i;
	}

	void Solve() {
		TopoSort();
		for (int i = tot; i; --i) {
			int u = q[i];
			if (id[u])
				rt[u] = SegTree::Modify(rt[u], 1, m, id[u]);
			for (int j = 0, k = qry[u].size(); j < k; ++j) {
				int p = qry[u][j], l = ::qry[p][0], r = ::qry[p][1];
				ans[p] = SegTree::Query(rt[u], 1, m, l, r);
			}
			int v = fa[u];
			if (v) 
				rt[v] = SegTree::Merge(rt[v], rt[u], 1, m);
		}
	}
}

void Init() {
	scanf(" %s", s + 1);
	n = strlen(s + 1);
	scanf("%d", &m);
	Sam::Init();
	for (int i = 1; i <= m; ++i) {
		scanf(" %s", t + 1);
		Sam::Insert(t, i);
	}
	Sam::Calc();
}

void Solve() {
	scanf("%d", &q);
	for (int i = 1; i <= q; ++i) {
		int l, r, a, b;
		scanf("%d%d%d%d", &l, &r, &a, &b);
		int ln = b - a + 1;
		if (Sam::match[b][1] >= ln) {
			int p = Sam::match[b][0];
			p = Sam::Find(p, ln);
			qry[i][0] = l, qry[i][1] = r;
			Sam::qry[p].push_back(i);
		}
		else 
			ans[i] = Data(0, l);
	}
	Sam::Solve();
	for (int i = 1; i <= q; ++i)
		printf("%d %d\n", ans[i].pos, ans[i].val);
}

int main() {

	Init();
	Solve();

	return 0;
}
