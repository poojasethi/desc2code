#include <bits/stdc++.h>

#define ll long long

#define SZ(x) (int)(x).size()
#define pb push_back

template<class T>inline void chkmax(T &x, const T &y) {if(x < y) x = y;}
template<class T>inline void chkmin(T &x, const T &y) {if(x > y) x = y;}

template<class T>
inline void read(T &x) {
    char c;int f = 1;x = 0;
    while(((c=getchar()) < '0' || c > '9') && c != '-');
    if(c == '-') f = -1;else x = c-'0';
    while((c=getchar()) >= '0' && c <= '9') x= x*10+c-'0';
    x *= f;
}
int outn;
char out[(int)2e7];
template<class T>
inline void write(T x) {
    if(x < 0) out[outn++] = '-', x = -x;
    if(x) {
        static int tmpn;
        static char tmp[20];
        tmpn = 0;
        while(x) tmp[tmpn++] = x%10+'0', x /= 10;
        while(tmpn) out[outn++] = tmp[--tmpn];
    }
    else out[outn++] = '0';
}

const int N = 5e5;
const int L = 2e5;
const int SIGMA = 27;
const int LOG = 18;
const int S = 4*N*LOG;
const int Q = N;

int n;
char s[N+9];
int m;
int qn;

struct data {
    int pos, val;
    data() {pos = val = 0;}
    data(int _pos, int _val):pos(_pos), val(_val) {}
    inline friend bool operator < (const data &p, const data &q) {
        if(p.val != q.val) return p.val < q.val;
        else return p.pos > q.pos;
    }
}ans[Q+9];

namespace seg {
    struct node {
        int lc, rc;
        data info;
        node() {lc = rc = 0;}
    }tr[S+9];
    int trn;
    inline int newnode() {
        return ++trn;
    }
#define LC(x) (tr[x].lc)
#define RC(x) (tr[x].rc)
    inline void pushup(int x) {
        tr[x].info = std::max(tr[LC(x)].info, tr[RC(x)].info);
    }
    void ins(int &x, int l, int r, int p) {
        if(!x) x = newnode();
        if(l == r) {
            tr[x].info.pos = p;
            tr[x].info.val++;
            return ;
        }
        int mid = (l+r)>>1;
        if(p <= mid) ins(LC(x), l, mid, p);
        else ins(RC(x), mid+1, r, p);
        pushup(x);
    }
    int merge(int x, int y, int l, int r) {
        if(!x || !y) return x+y;
        if(l == r) {
            tr[x].info.pos = l;
            tr[x].info.val += tr[y].info.val;
            return x;
        }
        int mid = (l+r)>>1;
        LC(x) = merge(LC(x), LC(y), l, mid);
        RC(x) = merge(RC(x), RC(y), mid+1, r);
        pushup(x);
        return x;
    }
    data qry(int x, int l, int r, int ql, int qr) {
        if(ql <= l && r <= qr) return tr[x].info;
        int mid = (l+r)>>1;data ret;
        if(ql <= mid) chkmax(ret, qry(LC(x), l, mid, ql, qr));
        if(qr > mid) chkmax(ret, qry(RC(x), mid+1, r, ql, qr));
        return ret;
    }
}

int pos[N+9];
int pre[N+9];

struct data2 {
    int id, l, r;
    data2() {id = l = r = 0;}
    data2(int _id, int _l, int _r):id(_id), l(_l), r(_r) {}
};

namespace sam {
    int fa[L+9], tr[L+9][SIGMA], len[L+9], id[L+9], rt, lst, n, f[L+9][LOG], root[L+9], top[L+9];
    std::vector<data2> q[L+9];
    inline int newnode(int l) {
        int ret = ++n;
        fa[ret] = -1, memset(tr[ret], -1, sizeof tr[ret]);
        len[ret] = l, id[ret] = 0;
        return ret;
    }
    inline void init() {
        n = -1, rt = lst = newnode(0);
    }
    inline void add(int x, int i) {
        int p = lst, np = newnode(len[p]+1);
        while(p != -1 && tr[p][x] == -1)
            tr[p][x] = np, p = fa[p];
        if(p == -1) fa[np] = rt;
        else {
            int q = tr[p][x];
            if(len[q] == len[p]+1) fa[np] = q;
            else {
                int r = newnode(len[p]+1);
                std::copy(tr[q], tr[q]+SIGMA, tr[r]);
                fa[r] = fa[q], fa[q] = fa[np] = r;
                while(p != -1 && tr[p][x] == q)
                    tr[p][x] = r, p = fa[p];
            }
        }
        id[np] = i, lst = np;
    }
    inline void work() {
        for(int i = 0; i <= n; ++i)
            f[i][0] = fa[i];
        for(int j = 1; j < LOG; ++j)
            for(int i = 0; i <= n; ++i)
                if(f[i][j-1] != -1)
                    f[i][j] = f[f[i][j-1]][j-1];
        for(int i = 0; i <= n; ++i)
            if(id[i])
                seg::ins(root[i], 1, m, id[i]);
        int cur = rt, tmp = 0;
        for(int i = 1; i <= ::n; ++i) {
            int x = s[i]-'a';
            while(cur != -1 && tr[cur][x] == -1) {
                cur = fa[cur];
                tmp = len[cur];
            }
            if(cur != -1) cur = tr[cur][x], tmp++;
            else cur = rt, tmp = 0;
            pos[i] = cur, pre[i] = tmp;
        }
        static int cnt[L+9], max;
        for(int i = 0; i <= n; ++i) {
            cnt[len[i]]++;
            chkmax(max, len[i]);
        }
        for(int i = 1; i <= max; ++i) cnt[i] += cnt[i-1];
        for(int i = n; i >= 0; --i) top[--cnt[len[i]]] = i;
    }
    inline void solve() {
        for(int i = n; i >= 0; --i) {
            int x = top[i];
            for(int j = 0; j < SZ(q[x]); ++j) {
                ans[q[x][j].id] = seg::qry(root[x], 1, m, q[x][j].l, q[x][j].r);
                if(!ans[q[x][j].id].val) ans[q[x][j].id].pos = q[x][j].l;
            }
            if(fa[x] != -1) root[fa[x]] = seg::merge(root[fa[x]], root[x], 1, m);
        }
    }
    inline void debug() {
        for(int i = 0; i <= n; ++i)
            for(int j = 0; j < SIGMA; ++j)
                if(tr[i][j] != -1)
                    printf("(%d,%d) = %c\n", i, tr[i][j], 'a'+j);
        for(int i = 1; i <= ::n; ++i)
            printf("pos[%d] = %d\n", i, pos[i]);
    }
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("666E.in", "r", stdin);
    freopen("666E.out", "w", stdout);
#endif

    scanf("%s", s+1);
    n = strlen(s+1);
    read(m), sam::init();
    for(int i = 1; i <= m; ++i) {
        static char txt[L+9];
        scanf("%s", txt);
        int txtl = strlen(txt);
        for(int j = 0; j < txtl; ++j)
            sam::add(txt[j]-'a', i);
        sam::add(26, 0);
    }
    sam::work();
    //sam::debug();
    read(qn);
    for(int i = 1; i <= qn; ++i) {
        int l, r, pl, pr;
        read(l), read(r), read(pl), read(pr);
        int len = pr-pl+1, pos = ::pos[pr];
        if(pre[pr] >= len) {
            for(int i = LOG-1; i >= 0; --i)
                if(sam::f[pos][i] != -1 && sam::len[sam::f[pos][i]] >= len)
                    pos = sam::f[pos][i];
            sam::q[pos].pb(data2(i, l, r));
        }
        else ans[i] = data(l, 0);
    }
    sam::solve();
    for(int i = 1; i <= qn; ++i) {
        write(ans[i].pos), out[outn++] = ' ';
        write(ans[i].val), out[outn++] = '\n';
    }
    printf("%s", out);
    
#ifndef ONLINE_JUDGE
    fclose(stdin);fclose(stdout);
#endif    
    return 0;
}
