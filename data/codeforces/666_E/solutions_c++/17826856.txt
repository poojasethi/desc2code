#include<cstdio>
#include<algorithm>
#include<cstring>

using namespace std ;

const int N = 1e6 + 10 ;

int n , m ; 

char s[N] , t[N] ; 

int sa[N] , ws[N] , bin[N] , yy[N] , wv[N] , ra[N] , Q ;

bool comp( int *r , int a , int b , int len ) {
	return ( r[a]==r[b] && r[a+len]==r[b+len] ) ;
}

void PreSA( int n , int m ) {
	int i , j , k , *x = bin , *y = yy , *tp , p;
	for( i=1 ; i<=n ; i++ ) ws[ x[i] = s[i] ] ++ ;
	for( i=1 ; i<=m ; i++ ) ws[i] += ws[i-1] ;
	for( i=n ; i ; i-- ) sa[ ws[ x[i] ] -- ] = i ;
	for( j=1 , p=1 ; p<n ; m=p,j*=2 ) {
		p = 0 ;
		for( i=n-j+1 ; i<=n ; i++ ) y[++p] = i ;
		for( i=1 ; i<=n ; i++ ) if( sa[i] - j > 0 ) y[++p] = sa[i] - j ;
		for( i=0 ; i<=m ; i++ ) ws[i] = 0 ;
		for( i=1 ; i<=n ; i++ ) wv[i] = x[ y[i] ] ;
		for( i=1 ; i<=n ; i++ ) ws[ wv[i] ] ++ ;
		for( i=1 ; i<=m ; i++ ) ws[i] += ws[i-1] ;
		for( i=n ; i ; i-- ) sa[ ws[ wv[i] ] -- ] = y[i] ;
		tp = x , x = y , y = tp ;
		for( x[ sa[1] ] = 1 , i = 2 , p = 1  ; i<=n ; i++ ) 
			x[ sa[i] ] = comp( y , sa[i] , sa[i-1] , j ) ? p : ++ p ;;
	}
}

int h[N] ;

void GetHeight() {
	for( int i=1 ; i<=n ; i++ ) ra[ sa[i] ] = i ;
	int k = 0 ;
	for( int i=1 ; i<=n ; h[ ra[i++] ] = k ) {
		if( ra[i]==1 ) {
			k = 0 ;
			continue ;
		}
		for( k = k ? k-1 : k ; s[ k+i ] == s[ k+sa[ ra[i]-1 ] ] ; k++ ) ;
	}
}

struct Query {
	int l , r , pr , pl , ps , id , val ; 
}z[N] ;

bool cmp( Query a , Query b ) {
	return a.pr-a.pl > b.pr-b.pl ;
}

int rot[N] , ds[N] , T , L[N] , R[N] ;

int dsu( int x ) {
	return ds[x] == x ? x : ds[x] = dsu( ds[x] ) ;
}

namespace SGT {
	int bel[N*35] , ax[N*35] , cur ;

	struct Tree {
		int l , r ;
	}tr[N*35] ;

	void Maintain( int po ) {
		ax[po] = ax[ tr[po].l ] ;
		bel[po] = bel[ tr[po].l ] ;
		if( ax[ tr[po].r ] > ax[po] ) {
			ax[po] = ax[ tr[po].r ] ;
			bel[po] = bel[ tr[po].r ] ;
		}
	}

	void Ask( int l , int r , int _l , int _r , int po ) {
		if( _l==l && _r==r ) {
			if( z[cur].val < ax[po] ) {
				z[cur].val = ax[po] ;
				z[cur].id = bel[po] ;
			}
			return ;
		}
		int m = l + r >> 1 ;
		if( _r<=m ) Ask( l  , m , _l , _r , tr[po].l ) ;
			else if( _l>m ) Ask( m+1 , r , _l , _r , tr[po].r ) ;
				else Ask( l , m , _l , m , tr[po].l ) , Ask( m+1 , r , m+1 , _r , tr[po].r ) ;
		
	}

	void Insert( int l , int r , int tar , int &po ) { 
		if( po==0 ) po = ++ T ;
		if( l==r ) {
			ax[po] ++ ;
			bel[po] = l ;
			return ;
		}
		int m = l + r >>  1 ;
		if( tar <= m ) Insert( l , m , tar , tr[po].l ) ;
			else Insert( m+1 , r , tar , tr[po].r ) ;
		Maintain( po ) ;
	}

	int Merge( int a , int b , int l , int r ) {
		if( a==0 ) return b ;
		if( b==0 ) return a ;
		int m = l + r >> 1 ;
		int ret = a ;
		if( l!=r ) {
			tr[ret].l = Merge( tr[a].l , tr[b].l , l , m ) ; 
			tr[ret].r = Merge( tr[a].r , tr[b].r , m+1 ,r ) ;
			Maintain( ret ) ;
		} else {
			ax[ret] = ax[a] + ax[b] ;
			bel[ret] = l ;
		}
		return ret ;
	}
}

void Combine( int x , int y ) {
	ds[x] = y ;
	R[y] = R[y] ;
	L[y] = L[x] ;
	rot[y] = SGT :: Merge( rot[x] , rot[y] , 1 , m ) ;
}

bool _cmp( Query a , Query b ) {
	return a.ps < b.ps ; }

int main() { 
	scanf("%s%d",s+1,&m ) ;
	n = strlen( s + 1 ) ;
	for( int i=1 ; i<=m ; i++ ) {
		scanf("%s",t+1 ) ;
		int len = strlen( t + 1 ) ;
		s[++n] = 30 ;
		for( int j = 1 ; j<=len ; j++ ) s[++n] = t[j] ;
	}
	PreSA( n , 240 ) ;
	GetHeight() ;
	scanf("%d",&Q ) ;
	for( int i=1 ; i<=Q ; i++ ) scanf("%d%d%d%d",&z[i].l,&z[i].r,&z[i].pl,&z[i].pr ) , z[i].ps = i;
	sort( z+1 , z+1+Q , cmp ) ;
	for( int i=1 , j=0 ; i<=n ; i++ ) {
		if( s[i]==30 ) ++ j ; else if( j ) SGT :: Insert( 1 , m , j , rot[ ra[i] ] ) ;
	}
	for( int i=1 ; i<=n ; i++ ) ds[i] = i , R[i] = i , L[i] = i ;
	for( int i=1 ; i<=Q ; i++ ) {
		int ps = ra[ z[i].pl ] , len = z[i].pr - z[i].pl + 1 , j ;
		for( j=ps+1 ; j<=n ; j++ ) {
			if( h[j]<len ) break ;
			if( dsu( j-1 ) != dsu( j ) ) {
				Combine( dsu( j-1 ) , dsu( j ) ) ; 
			}
			j = R[ dsu( j ) ] ;
		}
		for( j=ps ; j>1 ;  ) {
			if( h[j]<len ) break ;
			if( dsu( j-1 ) != dsu( j ) ) {
			       Combine( dsu( j-1 ) , dsu( j ) ) ;
			} 
		       j = L[ dsu( j ) ] ;
		}
		SGT :: cur = i ;
		SGT :: Ask( 1 , m , z[i].l , z[i].r , rot[ dsu( ps ) ] ) ;
		if( z[i].val==0 ) z[i].id = z[i].l ;
	}
	sort( z+1 , z+1+Q , _cmp ) ;
	for( int i = 1 ; i <= Q ; i++ ) printf("%d %d\n" , z[i].id , z[i].val ) ;
}
