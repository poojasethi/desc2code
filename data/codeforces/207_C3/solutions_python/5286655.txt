#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <map>
#include <set>
#include <list>
#include <queue>
#include <vector>
#include <bitset>
#include <cmath>
#include <ctime>
#include <cassert>
using namespace std;

#define pb push_back
#define mp make_pair
#define REP(i, n) for (int i = 0; i < (n); i++)
#define foreach(e, x) for (__typeof(x.begin()) e = x.begin(); e != x.end(); e++)
#define FAST_IO std::ios::sync_with_stdio(false)
typedef long long LL;
typedef pair<int, int> PII;
int rd() { return RAND_MAX == 32767 ? ((rand() << 15) ^ rand()) : rand(); }

const int maxn = 100010;
const int md = 1000000007;

int a[20], sa[maxn], rk[maxn], c1[maxn], c2[maxn], h2[maxn], s1[maxn], s2[maxn], pw[maxn], dep[maxn], h[maxn][20], d2[maxn][20];
PII b[maxn];

struct Rec
{
	int t, v, c;
} opt[maxn];
bool cmp(int x, int y)
{
	for (int i = 19; i >= 0; i--)
		if (d2[x][i] != -1 && d2[y][i] != -1 && h[x][i] == h[y][i]) {
			x = d2[x][i];
			y = d2[y][i];
		}
	return c2[x] < c2[y];
}
int main()
{
	//freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);
	int n;
	scanf("%d", &n);
	for (int i = 0; i < n; i++) {
		scanf("%d%d", &opt[i].t, &opt[i].v);
		while ((opt[i].c = getchar()) && (opt[i].c < 'a' || opt[i].c > 'z'));
		opt[i].v--;
	}
	pw[0] = 1;
	for (int i = 1; i < n; i++)
		pw[i] = (LL)pw[i-1]*26 % md;
	int m = 1; // the number of vertices in tree 2
	c2[0] = -1;
	h2[0] = 0;
	memset(d2, -1, sizeof(d2));
	for (int i = 0; i < n; i++)
		if (opt[i].t == 2) {
			c2[m] = opt[i].c;
			h2[m] = ((LL)h2[opt[i].v]*26+c2[m]) % md;
			d2[m][0] = opt[i].v;
			for (int j = 0; ; j++) {
				if (d2[m][j] != -1)
					d2[m][j+1] = d2[d2[m][j]][j];
				else
					break;
			}
			m++;
		}
	for (int i = 0; i < m; i++) sa[i] = i;
	for (int i = 0; i < m; i++)
		for (int j = 0; j < 20; j++)
			if (d2[i][j] != -1) {
				h[i][j] = (h2[i]-(LL)h2[d2[i][j]]*pw[1 << j]) % md;
				if (h[i][j] < 0) h[i][j] += md;
			}
	sort(sa, sa+m, cmp);
	for (int i = 0; i < m; i++) rk[sa[i]] = i;
	int t = 1, tt = 1; // the number of vertices in tree 1
	c1[0] = -1;
	dep[0] = 0;
	LL res = 1;
	memset(s1, 0, sizeof(s1));
	memset(s2, 0, sizeof(s2));
	for (int k = 1; k <= m; k += k & -k) s2[k]++;
	b[0].first = 0;
	b[0].second = m;
	for (int i = 0; i < n; i++) {
		if (opt[i].t == 1) {
			c1[t] = opt[i].c;
			dep[t] = dep[opt[i].v]+1;
			int k, lt, rt, mid, head, tail, tot = 0;
			for (int j = 19, cnt = dep[t]-1; j >= 0; j--)
				if (cnt >= (1 << j)) {
					a[tot++] = j;
					cnt -= 1 << j;
				}
			for (lt = b[opt[i].v].first, rt = b[opt[i].v].second; lt < rt; ) {
				mid = (lt+rt) >> 1;
				k = sa[mid];
				for (int j = 0; j < tot; j++) k = d2[k][a[j]];
				if (k == 0) lt = mid+1;
				else c1[t] <= c2[k] ? rt = mid : lt = mid+1;
			}
			head = lt;
			for (rt = b[opt[i].v].second; lt < rt; ) {
				mid = (lt+rt) >> 1;
				k = sa[mid];
				for (int j = 0; j < tot; j++) k = d2[k][a[j]];
				if (k == 0) lt = mid+1;
				else c1[t] < c2[k] ? rt = mid : lt = mid+1;
			}
			tail = lt;
			b[t] = mp(head, tail);
			for (int k = m-head; k; k -= k & -k) res += s1[k];
			for (int k = m-tail; k; k -= k & -k) res -= s1[k];
			for (int k = head+1; k <= m; k += k & -k) s2[k]++;
			for (int k = tail+1; k <= m; k += k & -k) s2[k]--;
			t++;
		}
		else {
			int whi = rk[tt++];
			for (int k = whi+1; k; k -= k & -k) res += s2[k];
			for (int k = m-whi; k <= m; k += k & -k) s1[k]++;
		}
		printf("%I64d\n", res);
	}
	return 0;
}
