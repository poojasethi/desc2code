#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <deque>
#include <queue>
#include <set>
#include <map>
#include <algorithm>
#include <functional>
#include <utility>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstdio>

using namespace std;

#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)
#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)

#define PI acos(-1.0)

struct point {double x,y;};

double dist(point &P, point &Q){
    double dx = P.x - Q.x, dy = P.y - Q.y;
    return sqrt(dx*dx + dy*dy);
}

double inprod(point &O, point &P, point &Q){
    return (P.x - O.x) * (Q.x - O.x) + (P.y - O.y) * (Q.y - O.y);
}

point foot(point &P, point &A, point &B){
    double t = inprod(A,B,P) / inprod(A,B,B);
    point ans = {A.x + (B.x - A.x) * t, A.y + (B.y - A.y) * t};
    return ans;
}

point rotate(point &P, double theta){
    double x = P.x * cos(theta) - P.y * sin(theta);
    double y = P.x * sin(theta) + P.y * cos(theta);
    point ans = {x,y};
    return ans;
}

double arg(point &P){
    double ans = atan2(P.y,P.x);
    if(ans < 0.0) ans += 2.0 * PI;
    return ans;
}

bool check(point &A, point &C, double v, double w){
    double t = dist(A,C) / v;
    double theta = arg(C); theta = min(theta, 2.0 * PI - theta);
    return (w * t > theta);
}

double func(point A, point B, point P, double a, double w){
    int iter;
    
    if(w < 1.0E-6) return 0.0;
        
    A.x -= P.x; A.y -= P.y; B.x -= P.x; B.y -= P.y;
    A = rotate(A,-a); B = rotate(B,-a);
    
    if(arg(A) > arg(B)) {A.y = -A.y; B.y = -B.y;}
        
    point O = {0.0,0.0};
    
    double low = 0.0, high = 1.0E+7, mid;
    REP(iter,100){
        mid = (high + low) / 2.0;
        
        if(check(A,B,mid,w)) {low = mid; continue;}
        
        point H = foot(O,A,B);
        double h = dist(O,H);
        
        if(h*w < mid){
            double t = sqrt(mid / (h*w) - 1.0);
            
            point C = {H.x + H.y * t, H.y - H.x * t};
            if(inprod(C,A,B) < 0.0 && check(A,C,mid,w)) {low = mid; continue;}
            
            point D = {H.x - H.y * t, H.y + H.x * t};
            if(inprod(D,A,B) < 0.0 && check(A,D,mid,w)) {low = mid; continue;}
        }
        
        high = mid; 
    }
    
    return mid;
}

int main(void){
    int N,K,i;
    point A,B,P;
    double a,w;
    
    cin >> A.x >> A.y >> B.x >> B.y;
    cin >> N;
    
    vector <double> v;
    REP(i,N){
        cin >> P.x >> P.y >> a >> w;
        double tmp = func(A,B,P,a,w);
        v.push_back(tmp);
    }
    
    cin >> K;
    v.push_back(0.0);
    sort(v.begin(),v.end());
    double ans = v[N-K];
    
    printf("%.6f\n",ans);
    
    return 0;
}
