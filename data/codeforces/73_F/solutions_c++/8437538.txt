#include <iostream>
#include <complex>
#include <cmath>
#include <vector>
#include <algorithm>

using namespace std;

typedef complex<double> point;

double prodvec(point p1,point p2)
{
  return imag(conj(p1)*p2);
}

double prodesc(point p1,point p2)
{
  return real(conj(p1)*p2);
}

const int limite=20000;

double error=1e-7;

double computa(point p,point direccion,double w,double b)
{
  point pb(b,0);
  double tb=abs(arg((pb-p)/direccion))/w;
  double sol=b/tb;
  //cout<<"--- "<<sol<<endl;
  double x=real(p);
  double y=imag(p);
  if (x<=0) return sol;
  double inf=sol;
  double sup=1000000000;
  while (inf+error<sup) {
    double med=(inf+sup)/2.0;
    if (med*y/w<y*y) {
      sup=med;
    } else {
      point corte(x-sqrt(med*y/w-y*y),0.0);
      if (real(corte)<0 or real(corte)>b)
	sup=med;
      else {
	double t=abs(arg((corte-p)/direccion))/w;
	double tt=real(corte)/med;
	if (tt<t) sup=med;
	else inf=med;
      }
    }
  }
  //cout<<inf<<endl;
  return inf;
}

point pa,pb;
int n;
point p[100000];
point vp[100000];
double w[100000];
int k;

point leer()
{
  double x,y;
  cin>>x>>y;
  return point(x,y);
}

int main()
{
  cout.setf(ios::fixed);
  cout.precision(10);
  pa=leer();
  pb=leer();
  point divi=pb-pa;
  divi=divi/abs(divi);
  cin>>n;
  vector<double> v;
  for (int i=0;i<n;i++) {
    p[i]=leer();
    double a;
    cin>>a;
    vp[i]=polar(1.0,a);
    cin>>w[i];
    p[i]-=pa;
    p[i]=p[i]/divi;
    vp[i]=vp[i]/divi;
    if (imag(p[i])<0) {
      p[i]=conj(p[i]);
      vp[i]=conj(vp[i]);
    }
    v.push_back(computa(p[i],vp[i],w[i],abs(pb-pa)));
  }
  cin>>k;
  sort(v.begin(),v.end());
  if (k>=int(v.size())) cout<<0.0<<endl;
  else cout<<v[int(v.size())-1-k]<<endl;
}
