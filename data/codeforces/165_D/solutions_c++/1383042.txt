#include<cstdio>
#include<iostream>
#include<vector>
#include<cstring>
#include<algorithm>
using namespace std;
#define N 102400
int i,j,k,n,m,r,f,a[N],b[N],c[N],z[N],q[N];
vector<int> e[N];
vector<int> h[N];
int max(int a,int b)
{
    return a>b?a:b;
}
void ch(int p,int k,int d)
{
    for(;k<h[p].size();k+=k&-k)
        h[p][k]+=d;
}
int qu(int p,int k)
{
    for(f=0;k;k-=k&-k)
        f+=h[p][k];
    return f;
}
int main()
{
    for(scanf("%d", &n);++i<n;)
    {
        scanf("%d %d", a + i, b + i);
        e[a[i]].push_back(b[i]);
        e[b[i]].push_back(a[i]);
    }

    //ROOT
    for(i = r = 1; i <= n; ++i)
        if(e[i].size() > 2)
            r = i;

    for(i = 0; i < e[r].size(); ++i)
    {
        for(k=0,j=e[r][i],f=r;;)
        {
            z[j]=i;q[j]=++k;m=f;
            if(e[j].size()==1)
                break;
            f = j;
            j = e[f][0];
            if(j == m)
                j=e[f][1];
        }
        h[i].resize(k+1,0);
    }
    memset(c,0,sizeof(c));//开始的时候路径全为黑色
    for(scanf("%d", &m);m--;)
    {
        scanf("%d %d", &k, &i);
        if(k<3)
        {
            if(c[i]^(k==2))
            {
                ch(max(z[a[i]],z[b[i]]),max(q[a[i]],q[b[i]]),k*2-3);
                c[i]=k-1;
            }
        }
        else
        {
            scanf("%d", &j);
            if(z[i] == z[j]) 
                if (qu(z[i],q[i])==qu(z[j],q[j]))//i,j之间求和为0，即全为黑色
                    printf("%d\n", abs(q[i]-q[j]));
                else
                    printf("-1\n");
            else
                if (qu(z[i],q[i]) + qu(z[j],q[j])>0)//大于0表示连接两点的路径上有白色的边
                    printf("-1\n");
                else
                    printf("%d\n", q[i] + q[j]);
        }
    }
    return 0;
}