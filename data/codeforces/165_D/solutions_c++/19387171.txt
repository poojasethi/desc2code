#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 1;
vector <pair <int, int> > g[N];
vector <set<int> > f;
int mark[N], ver[N], o[N];
int ind = 0, compo = 0;

void dfs(int v, int par, int order) {
	mark[v] = compo;
	o[v] = order;
	for (int i = 0; i < g[v].size(); i++)
		if (g[v][i].first != par) {
			compo += v == ind;
			ver[g[v][i].second] = g[v][i].first;
			dfs(g[v][i].first, v, order + 1);
		}
}

bool ok(int v) {
	return v == ind || f[mark[v]].empty() || *f[mark[v]].begin() > o[v];
}

bool check(int u, int v) {
	if (o[u] > o[v])
		swap(u, v);
	if (u == ind)
		return ok(v);
	if (f[mark[u]].empty())
		return true;
	set <int> :: iterator it = f[mark[u]].upper_bound(o[u]);
	if (it == f[mark[u]].end() || *it > o[v])
		return true;
	return false;
}

main() {
	int n;
	scanf("%d", &n);
	for (int i = 0; i < n - 1; i++) {
		int u, v;
		scanf("%d %d", &u, &v);
		--u, --v;
		g[u].push_back(make_pair(v, i));
		g[v].push_back(make_pair(u, i));
	}
	for (int i = 1; i < n; i++)
		if (g[i].size() >= g[ind].size())
			ind = i;
	dfs(ind, -1, 0);
	f.resize(++compo);
	for (int i = 0; i < compo; i++)
		f[i].clear();
	int q;
	scanf("%d", &q);
	while (q--) {
		int type;
		scanf("%d", &type);
		if (type == 1) {
			int id;
			scanf("%d", &id);
			--id;
			f[mark[ver[id]]].erase(o[ver[id]]);
		}
		else if (type == 2) {
			int id;
			scanf("%d", &id);
			id--;
			f[mark[ver[id]]].insert(o[ver[id]]);
		}
		else {
			int u, v;
			scanf("%d %d", &u, &v);
			u--, v--;
			if (u == v)
				printf("0\n");
			else if (mark[u] != mark[v] && ok(u) && ok(v))
				printf("%d\n", o[u] + o[v]);
			else if (mark[u] == mark[v] && check(u, v))
				printf("%d\n", abs(o[v] - o[u]));
			else printf("-1\n");
		}
	}
}
