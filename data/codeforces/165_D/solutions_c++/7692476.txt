#include<bits/stdc++.h>
using namespace std;
#define ll int
#define get(n) scanf("%d",&n);
#define yup(t) printf("%d\n",t);
#define mod  1000000007
#define pb push_back
#define pi pair<ll,ll>
#define f first
#define s second
#define mp make_pair
ll root;
ll wi=0;
ll n;
ll mml=0;
void dfs(ll v,ll cur,ll w,vector<ll> edge[],ll vis[],ll d[]){
    d[v]=cur;
    cur++;
    vis[v]=w;
    for(int i=0;i<(int)edge[v].size();i++){
        if(!vis[edge[v][i]]){
            dfs(edge[v][i],cur,w,edge,vis,d);
            if(v==root) w++;
        }
    }
    wi=max(wi,w);
    mml=max(mml,cur);
}
struct bt{
vector<ll>arr;
bt(){
    arr.resize(mml+2);
}
void update(ll ind,ll val){
    while(ind<=mml){
    arr[ind]+=val;
    ind+=(ind&-ind);
    }
}
ll query(ll ind){
    ll sum=0;
    while(ind>0){
    sum+=arr[ind];
    ind-=(ind&-ind);
    }
    return sum;
}
};
int main(){
ll u,v;
get(n);
vector<ll>edge[n+1];
ll vis[n+1];
ll d[n+1];
memset(vis,0,sizeof(vis));
memset(d,0,sizeof(d));
pi ed[n];
ll maxedge=0;
for(int i=0;i<n-1;i++){
get(u);
get(v);
edge[u].pb(v);
edge[v].pb(u);
ed[i+1]=mp(u,v);
if(maxedge<(int)edge[u].size()){
    maxedge=edge[u].size();
    root=u;
}
if(maxedge<(int)edge[v].size()){
    maxedge=edge[v].size();
    root=v;
}
}
dfs(root,0,1,edge,vis,d);
vis[root]=0;
bt bit[wi+1];
ll m,type,a,b;
ll path;
ll edgenum;
get(m);
while(m--){
get(type);
get(a);
if(type!=3){
    edgenum=max(d[ed[a].s],d[ed[a].f]);
    path=max(vis[ed[a].s],vis[ed[a].f]);
}
if(type==1){
bit[path].update(edgenum,1);
}
else if(type==2){
bit[path].update(edgenum,-1);
}
else{
get(b);
if(a==b){
yup(0);
continue;
}
if(vis[a]==vis[b]){
if(bit[vis[b]].query(d[b])==bit[vis[a]].query(d[a])){
yup(abs(d[a]-d[b]));
continue;
}
}
    if(a!=root&&bit[vis[a]].query(d[a])<0){
        yup(-1);
        continue;
    }
    if(b!=root&&bit[vis[b]].query(d[b])<0){
        yup(-1);
        continue;
    }
yup(d[a]+d[b]);
}
}
}
