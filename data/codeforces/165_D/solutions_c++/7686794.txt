#include <iostream>
#include <cstdio>
#include <cstring>
#include <vector>
using namespace std;

const int N = 1e5 + 5;

vector <int> tree[N];

int first[N], next[N * 2], end[N * 2], d[N];
int tot;
pair<int, int> edge[N];

void addedge(int x, int y) {
    next[++tot] = first[x];
    first[x] = tot;
    end[tot] = y;
}

int dep[N], mark[N];

void dfs(int x, int fa) {
    dep[x] = dep[fa] + 1;
    mark[x] = mark[fa];
    tree[mark[x]].push_back(0);
    for (int k = first[x]; k; k = next[k])
	if (end[k] != fa) 
	    dfs(end[k], x);
}

void add(int x, int s, vector<int> &f) {
    int p = f.size();
    while (x < p) {
	f[x] += s;
	x += x & -x;
    }
}

int find(int x, vector<int> &f) {
    int ans = 0;
    while (x) {
	ans += f[x];
	x -= x & -x;
    }
    return ans;
}

int main() {
    //freopen("1.txt", "r", stdin);
    int n;
    scanf("%d", &n);
    for (int i = 1; i < n; ++i) {
	int x, y;
	scanf("%d%d", &x, &y);
	addedge(x, y);
	addedge(y, x);
	edge[i] = make_pair(x, y);
	++d[x]; ++d[y];
    }
    int s = 1;
    for (int i = 2; i <= n; ++i)
	if (d[i] > 2) s = i;
    tot = 0;
    for (int k = first[s]; k; k = next[k]) {
	mark[s] = tot++;
	tree[mark[s]].push_back(0);
	dfs(end[k], s);
    }
    mark[s] = -1;
    int q;
    scanf("%d", &q);
    while (q--) {
	int type;
	scanf("%d", &type);
	if (type < 3) {
	    int x;
	    scanf("%d", &x);
	    if (dep[edge[x].first] > dep[edge[x].second]) x = edge[x].first;
	    else x = edge[x].second;
	    if (type == 1) add(dep[x], -1, tree[mark[x]]);
	    else add(dep[x], 1, tree[mark[x]]);
	}
	else {
	    int x, y;
	    scanf("%d%d", &x, &y);
	    int ans = 0;
	    if (mark[x] != mark[y]) {
		if (~mark[x] && find(dep[x], tree[mark[x]])) ans = -1;
		if (~mark[y] && find(dep[y], tree[mark[y]])) ans = -1;
		if (!ans) ans = dep[x] + dep[y];
	    }
	    else {
		if (dep[x] > dep[y]) swap(x, y);
		if (find(dep[y], tree[mark[x]]) - find(dep[x], tree[mark[x]])) 
		    ans = -1;
		else ans = dep[y] - dep[x];
	    }
	    printf("%d\n", ans);
	}
    }
    return 0;
}
