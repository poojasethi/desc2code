import collections

def read_int_list():
    lst = raw_input()
    lst = lst.split(" ")
    lst = [int(x) for x in lst]
    return lst

# Get partial LIS info
def getLISInfo(inp):
    exact = []
    notExact = []
    maxLength = 0
    bestLast = {}
    # Base case
    for i in xrange(len(inp)):
        if maxLength == 0 or inp[i] > bestLast[maxLength]:
            maxLength += 1
            exact.append(maxLength)
            bestLast[maxLength] = inp[i]
        elif inp[i] <= bestLast[1]:
            bestLast[1] = inp[i]
            exact.append(1)
        else:
            lw = 1  # > bestLaw[lw]
            hg = maxLength # <= bestLaw[hg]
            while hg > lw + 1:
                md = (hg + lw)/2
                if inp[i] <= bestLast[md]:
                    hg = md
                else:
                    lw = md
            bestLast[hg] = inp[i]
            exact.append(hg)

        notExact.append(maxLength)

    return exact, notExact


n = input()
inp = read_int_list()

# We compute partial information about LIS
LISEndingThere, LISEndingThereOrBefore = getLISInfo(inp)
reversedInput = [-x for x in reversed(inp)]
LISStartingThere, LISStartingThereOrAfter = getLISInfo(reversedInput)
LISStartingThere = [x for x in reversed(LISStartingThere)]
LISStartingThereOrAfter = [x for x in reversed (LISStartingThereOrAfter)]
LISLength = LISEndingThereOrBefore[len(inp) - 1]

#print LISEndingThere
#print LISStartingThere

# For each position, we determine the category, using uniqueness
# and optimality of the partial LIS info
possibleLengths = collections.Counter()
for i in xrange(len(inp)):
    possibleLengths[(LISEndingThere[i], LISStartingThere[i])] += 1

categories = []
for i in xrange(len(inp)):
    if LISEndingThere[i] + LISStartingThere[i] - 1 == LISLength:
        if possibleLengths[(LISEndingThere[i], LISStartingThere[i])] > 1:
            categories.append('2')
        else:
            categories.append('3')
    else:
        categories.append('1')

print ''.join(categories)