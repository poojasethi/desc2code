#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

bool ok[305][305][2],vis[305][305][2];
vector<int> number;
int n,f[305];
struct tower {
	int pos,len;
} a[105];
inline bool operator <(const tower &a,const tower &b) {
	return a.pos<b.pos;
}
bool check(int l,int r,bool use) {
	if (vis[l][r][use]) return ok[l][r][use];
	vis[l][r][use]=true;
	if (l==r) return ok[l][r][use]=true;
	for (int i=1;i<=n;i++) if (a[i].pos>=number[l]&&a[i].pos<=number[r]) {
		if (a[i].pos==number[l]&&!use) {
			int p=number[l]+a[i].len;
			for (int j=i+1;j<=n;j++) if (a[j].pos<=p) p=max(p,a[j].pos+a[j].len);
			if (p>=number[r]) return ok[l][r][use]=true;
			int mid=lower_bound(number.begin(),number.end(),p)-number.begin();
			if (check(mid,r,false)) return ok[l][r][use]=true;
		}
		if (a[i].pos-a[i].len<=number[l]) {
			int p=a[i].pos;
			for (int j=1;j<=n;j++) if (a[j].pos>=number[l]&&a[j].pos<=number[r]) {
				if (a[j].pos==number[l]&&use) continue;
				if (a[j].pos<=p&&j!=i) p=max(p,a[j].pos+a[j].len);
			}
			if (p>=number[r]) return ok[l][r][use]=true;
			int mid=lower_bound(number.begin(),number.end(),p)-number.begin();
			if (check(mid,r,p==a[i].pos)) return ok[l][r][use]=true;
		}
	}
	return ok[l][r][use]=false;
}
int main() {
	scanf("%d",&n);
	number.push_back(-2000000005);
	for (int i=1;i<=n;i++) {
		scanf("%d%d",&a[i].pos,&a[i].len);
		number.push_back(a[i].pos);
		number.push_back(a[i].pos-a[i].len);
		number.push_back(a[i].pos+a[i].len);
	}
	sort(a+1,a+n+1);
	sort(number.begin(),number.end());
	number.erase(unique(number.begin(),number.end()),number.end());
	for (int i=2;i<number.size();i++) {
		f[i]=f[i-1];
		for (int j=1;j<i;j++) if (check(j,i,false)) f[i]=max(f[i],f[j-1]+number[i]-number[j]);
	}
	printf("%d\n",f[number.size()-1]);
	return 0;
}
