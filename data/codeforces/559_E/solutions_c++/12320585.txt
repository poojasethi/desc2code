#include <cmath>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#define ll long long
#define ld long double
using namespace std;

const int MaxN = 310;
struct Light {
    int A, R;
    bool operator < (const Light &X) const {
        return A < X.A;
    }
}   P[MaxN];
int X[MaxN], XTot, F[MaxN][MaxN], Left[MaxN][MaxN], N;

inline int Find(int P) {
    return lower_bound(X + 1, X + XTot + 1, P) - X;
}

int main()
{
    scanf("%d", &N);
    for (int i = 1; i <= N; i++) scanf("%d%d", &P[i].A, &P[i].R);
    sort(P + 1, P + N + 1);
    for (int i = 1; i <= N; i++) {
        X[++XTot] = P[i].A - P[i].R;
        X[++XTot] = P[i].A;
        X[++XTot] = P[i].A + P[i].R;
    }
    sort(X + 1, X + XTot + 1);
    XTot = unique(X + 1, X + XTot + 1) - X - 1;
    for (int i = 1; i <= N; i++) {
        Left[i + 1][i] = P[i].A;
        for (int j = i; j <= N; j++) Left[i][j] = min(Left[i][j - 1], P[j].A - P[j].R);
    }
    
    int Ans = 0;
    for (int i = 1; i <= N; i++) {
        int Tmp0 = Find(P[i].A), Tmp1 = Find(P[i].A - P[i].R);
        for (int j = 1; j <= XTot; j++) {
            F[i][j] = F[i][j - 1];
            if (j <= Tmp0) {
                if (j >= Tmp1) F[i][j] = max(F[i][j], F[i - 1][Tmp1] + X[j] - X[Tmp1]);
                else F[i][j] = max(F[i][j], F[i - 1][j]);
            } else {
                for (int k = 1; k <= i; k++)
                    if (P[k].A + P[k].R >= X[j])
                        F[i][j] = max(F[i][j], F[k - 1][Find(Left[k + 1][i])] + X[j] - Left[k + 1][i]);
            }
            Ans = max(Ans, F[i][j]);
        }
    }
    cout << Ans << endl;
    return 0;
}
