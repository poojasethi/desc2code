//Template
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <climits>
#include <cmath>
#include <utility>
#include <set>
#include <map>
#include <queue>
#include <ios>
#include <iomanip>
#include <ctime>
#include <numeric>
#include <functional>
#include <fstream>
#include <string>
#include <vector>
#include <bitset>
#include <cstdarg>
#include <complex>
using namespace std;

typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
typedef long double ld;
#define pair(x, y) make_pair(x, y)
#define runtime() ((double)clock() / CLOCKS_PER_SEC)

inline int read() {
    static int r, sign;
    static char c;
    r = 0, sign = 1;
    do c = getchar(); while (c != '-' && (c < '0' || c > '9'));
    if (c == '-') sign = -1, c = getchar();
    while (c >= '0' && c <= '9') r = r * 10 + (int)(c - '0'), c = getchar();
    return sign * r;
}

template <typename T>
inline void print(T *a, int n) {
    for (int i = 1; i < n; ++i) cout << a[i] << " ";
    cout << a[n] << endl;
}
#define PRINT(_l, _r, _s, _t) { cout << #_l #_s "~" #_t #_r ": "; for (int _i = _s; _i != _t; ++_i) cout << _l _i _r << " "; cout << endl; }


#define INFI 1234567890123456LL
#define NODE 2000
#define EDGE 1500000
struct edge {
    int next, node, w;
} e[(EDGE << 1) + 5];
int head[NODE + 1], S, T, tot = 1;
int d[NODE + 1], q[NODE + 1];
 
inline void addedge(int a, int b, int w) {
    e[++tot].next = head[a];
    head[a] = tot, e[tot].node = b, e[tot].w = w;
    e[++tot].next = head[b];
    head[b] = tot, e[tot].node = a, e[tot].w = 0;
}
 
bool bfs() {
    int h = 0, t = 0;
    memset(d, 0, sizeof d);
    d[S] = 1;
    q[t++] = S;
    while (h < t) {
        int cur = q[h++];
        for (int i = head[cur]; i; i = e[i].next)
            if (e[i].w > 0 && !d[e[i].node]) {
                d[e[i].node] = d[cur] + 1;
                q[t++] = e[i].node;
            }
    }
    return d[T];
}
 
int dfs(int x, int inflow) {
    if (x == T) return inflow;
    if (!inflow) return 0;
    int ret = inflow, flow;
    for (int i = head[x]; i; i = e[i].next) {
        if (d[e[i].node] != d[x] + 1) continue;
        flow = dfs(e[i].node, min(ret, e[i].w));
        if (!flow) continue;
        e[i].w -= flow, e[i ^ 1].w += flow, ret -= flow;
        if (!ret) return inflow;
    }
    if (ret == inflow) d[x] = -1;
    return inflow - ret;
}

int maxFlow() {
    int ans = 0LL;
    while (bfs())
        ans += dfs(S, 123456789);
    return ans;
}

#define N 30
int n, m, male, female, dist[N + 1][N + 1];
ll pdist[N * N + 1];
ll mdist[N * N + 1][N * N + 1];
ll fdist[N * N + 1][N * N + 1];
bool wall[N + 1][N + 1];
char s[100];

int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};

inline bool valid(int x, int y) {
    return x > 0 && x <= n && y > 0 && y <= m;
}

void Bfs(int x, int y) {
    memset(dist, 0, sizeof dist);
    queue<pair<int, int> > q;
    dist[x][y] = 1;
    q.push(pair(x, y));
    while (!q.empty()) {
        pair<int, int> cur = q.front();
        q.pop();
        for (int i = 0; i < 4; ++i) {
            int x = cur.first + dir[i][0], y = cur.second + dir[i][1];
            if (!valid(x, y) || dist[x][y] || wall[x][y]) continue;
            dist[x][y] = dist[cur.first][cur.second] + 1;
            q.push(pair(x, y));
        }
    }
}

void prepare(ll *d) {
    int x, y, t;
    scanf("%d%d%d", &x, &y, &t);
    Bfs(x, y);
    for (int a = 1; a <= n; ++a)
        for (int b = 1; b <= m; ++b)
            if (dist[a][b]) {
                d[(a - 1) * m + b] = (ll)(dist[a][b] - 1) * t;
            } else d[(a - 1) * m + b] = INFI;
}

bool check(ll val) {
    // p => m
    tot = 1;
    memset(head, 0, sizeof head);
    for (int i = 1; i <= n * m; ++i)
        addedge(i, n * m + i, 1);
    for (int i = 1; i <= male; ++i) {
        addedge(S, n * m * 2 + i, 1);
        for (int j = 1; j <= n * m; ++j)
            if (mdist[i][j] <= val)
                addedge(n * m * 2 + i, j, 1);
    }
    for (int i = 1; i <= female; ++i) {
        addedge(n * m * 2 + male + i, T, 1);
        for (int j = 1; j <= n * m; ++j)
            if (fdist[i][j] <= val)
                addedge(n * m + j, n * m * 2 + male + i, 1);
    }
    if (maxFlow() >= (male + female >> 1)) return true;
    
    return false;
}

int main(int argc, char *argv[]) {
#ifdef KANARI
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif
    
    scanf("%d%d%d%d", &n, &m, &male, &female);
    for (int i = 1; i <= n; ++i) {
        scanf("%s", s);
        for (int j = 1; j <= m; ++j)
            wall[i][j] = s[j - 1] == '#';
    }
    
    if (abs(male - female) != 1) {
        printf("-1\n");
        return 0;
    }
    
    ll l = 0LL, r = 1e9 * (ll)n * m;
    S = 0, T = n * m * 2 + male + female + 2;
    if (male < female) prepare(mdist[male + 1]);
    else prepare(fdist[female + 1]);
    for (int i = 1; i <= male; ++i)
        prepare(mdist[i]);
    for (int i = 1; i <= female; ++i)
        prepare(fdist[i]);
    if (male < female) ++male;
    else ++female;
    
    if (!check(r + 1)) printf("-1\n");
    else {
        while (l < r) {
            ll mid = l + r >> 1;
            if (check(mid)) r = mid;
            else l = mid + 1;
        }
        cout << l << endl;
    }
    
    fclose(stdin);
    fclose(stdout);
    return 0;
}
