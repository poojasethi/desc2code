#include <cstdio>
#include <string>
#include <algorithm>
#include <vector>
#include <algorithm>
#include <cassert>
#include <cmath>
#include <queue>
#include <set>
#include <map>

#define fru(j,n) for(int j=0;j<n;++j)
#define tr(it,x) for(typeof(x.begin()) it=x.begin();it!=x.end();++it)
#define x first
#define y second
#define pb push_back

using namespace std;

typedef pair<int,int> pii;
typedef long long LL;

//---------ta czesc ustawiamy------------------
typedef int type;	  //do trzymania pojemnosci i przeplywu calk.
const type inf = 1<<28; //maksymalny sum. przeplyw
const int MAXN = 2006;
vector<int> V [MAXN];
int n,ujscie,zrodlo;
//---------reszta------------------------------
type M [MAXN][MAXN];
int pocz[MAXN],w[MAXN],Q[MAXN];

type dfs(int u, type ile) //ile moge max puscic, ale <=ile
{
	if(u==ujscie || ile==0) return ile;
	type t,ans=0;
#define ne V[u][k]
	for(int k=pocz[u];k<V[u].size();++k,++pocz[u]) if(w[ne]==w[u]+1 && M[u][ne]>0)
	{
		t=dfs(V[u][k],min(M[u][ne],ile));
		M[u][ne]-=t;
		M[ne][u]+=t;
		ile-=t; ans+=t;
		if(ile==0) break;
	}
	return ans;
}
bool bfs()
{
	for(int i=0;i<n;++i) w[i]=-1;
	int ct=0;
	Q[ct++]=zrodlo;
	w[zrodlo]=1;
	for(int i=0;i<ct;++i) tr(it,V[Q[i]]) if(w[*it]==-1 && M[Q[i]][*it]>0)
	{
		Q[ct++]=*it;
		w[*it]=w[Q[i]]+1;
	}
	return w[ujscie]!=-1;
}
type maxflow()//z zew.
{
	type ans=0;
	while(bfs())
	{
		for(int i=0;i<n;++i) pocz[i]=0;
		ans+=dfs(zrodlo,inf);
	}
	return ans;
}

void edge(int a, int b, type k) //z zew.
{
	if(a==b) return;
	M[a][b]+=k;
	V[a].push_back(b);
	V[b].push_back(a);
}
void czysc(){
	fru(i,n) V[i].clear();
	fru(i,n) fru(j,n) M[i][j]=0;
}
typedef pair<int,pii> tri;
vector<pii> MA,FE;
vector<pii> PP;
LL ODL[500][500];
int N,MM,ma,fe;

#define cc MA.size()
#define ww PP.size()
int IN(int a) {return cc+cc+2*a;}
int OUT(int a){return cc+cc+2*a+1;}

bool dasie(LL czas){
	czysc();
	zrodlo=cc+cc+2*ww;
	ujscie=zrodlo+1;
	n=ujscie+1;
	fru(i,cc) edge(zrodlo,i,1);
	fru(i,cc) fru(j,ww) if(ODL[MA[i].x][j]<=czas/MA[i].y) edge(i,IN(j),1);
	fru(j,ww) edge(IN(j),OUT(j),1);
	fru(i,cc) fru(j,ww) if(ODL[FE[i].x][j]<=czas/FE[i].y) edge(OUT(j),i+cc,1);
	fru(i,cc) edge(i+cc,ujscie,1);
	return maxflow()==cc;
}
pii TRI(){
	pii p;
	int tt;
	scanf("%d%d%d",&p.x,&p.y,&tt);
	return pii(lower_bound(PP.begin(),PP.end(),p)-PP.begin(),tt);
}

int main()
{
	char SS[123][123];
	scanf("%d%d%d%d",&N,&MM,&ma,&fe);
	fru(i,N) scanf("%s",SS[i]);
	fru(i,N) fru(j,MM) if(SS[i][j]=='.') PP.pb(pii(i+1,j+1));
	sort(PP.begin(),PP.end());
	if(ma!=fe+1 && ma!=fe-1) {puts("-1"); return 0;}
	if(ma-1==fe) FE.pb(TRI());
	else MA.pb(TRI());
	fru(i,ma) MA.pb(TRI());
	fru(i,fe) FE.pb(TRI());
	//printf("MA = %d FE = %d\n",MA.size(),FE.size());
	assert(MA.size()==FE.size());
	fru(i,ww) fru(j,ww) ODL[i][j]=1LL<<58;
	fru(i,ww) ODL[i][i]=0;
	fru(i,ww) fru(j,i) if(abs(PP[i].x-PP[j].x)+abs(PP[i].y-PP[j].y)==1){
		ODL[i][j]=1;
		ODL[j][i]=1;
	}
	fru(k,ww) fru(i,ww) fru(j,ww) ODL[i][j]=min(ODL[i][j],ODL[i][k]+ODL[k][j]);
//	fru(i,ww) fru(j,ww) 
	LL po=0,kon=1LL<<40;
	while(po+1<kon){
		LL med=(po+kon)/2;
		if(dasie(med)) kon=med;
		else po=med;
	}
	if(kon==1 && dasie(0)) kon=0;
	if(kon==(1LL<<40)) kon=-1;
	printf("%lld\n",kon);
	return 0;
}
