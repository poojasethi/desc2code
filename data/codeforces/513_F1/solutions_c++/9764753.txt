#include <set>
#include <map>
#include <ctime>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>

#define MaxN 1010
#define MaxM 1000010

using namespace std;

int n, m, ma, fem;
char str[MaxN];
int Map[MaxN][MaxN];
int xx[2][MaxN], yy[2][MaxN], rr[2][MaxN];
int f[500][500];
int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};

int Hash(int a, int b) {
    return (a - 1) * m + b;
}

int Min(int a, int b) {
    return a < b ? a : b;
}

bool Checker(int a, int b) {
    if(a <= 0 || a > n || b <= 0 || b > m) return false;
    if(Map[a][b]) return false;
    return true;
}

int head[3010], prep[MaxM], v[MaxM], u[MaxM], w[MaxM], m0, nowhead[3010], cnt[3010], Dis[3010], stack[3010], s, t, Total, path[3010], Ans;
const int oo = ~0U >> 1;

void AddEdge(int a,int b,int c){
    ++m0;v[m0]=b;u[m0]=a;w[m0]=c;prep[m0]=head[a];head[a]=m0;
    ++m0;v[m0]=a;u[m0]=b;w[m0]=0;prep[m0]=head[b];head[b]=m0;
}

void Sap(){
    for(int i = 0; i <= t; ++i)
        nowhead[i] = head[i];
    int p=s,f=oo,flag;
    cnt[0]=Total;
    while(Dis[s]<Total){
        flag=0;
        stack[p]=f;
        for(int i=nowhead[p];i;i=prep[i])
            if(w[i]&&Dis[v[i]]+1==Dis[p]){
                nowhead[p]=i;
                path[v[i]]=i;
                flag=1;
                if(f>w[i])
                    f=w[i];
                p=v[i];
                if(p==t){
                    Ans+=f;
                    for(;p!=s;p=u[path[p]]){
                        w[path[p]]-=f;
                        w[path[p]^1]+=f;
                    }
                    f=~0U>>1;
                }
                break;
            }
        if(flag)
            continue;
        int minx=Total+1,tmp;
        for(int i=head[p];i;i=prep[i])
            if(w[i]&&Dis[v[i]]<minx){
                minx=Dis[v[i]];
                tmp=i;
            }
        nowhead[p]=tmp;
        --cnt[Dis[p]];
        tmp=Dis[p];
        Dis[p]=minx+1;
        ++cnt[Dis[p]];
        if(!cnt[tmp])
            break;
        if(p!=s)
            f=stack[p=u[path[p]]];
    }
}

bool Check(long long now) {
    memset(head, 0, sizeof(head));
    memset(stack, 0, sizeof(stack));
    memset(path, 0, sizeof(path));
    memset(cnt, 0, sizeof(cnt));
    memset(Dis, 0, sizeof(Dis));
    m0 = 1;
    Total = 0;
    int i, j, k;
    for(i = 1; i <= ma; ++i)
        for(j = 1; j <= n * m; ++j) {
            if(f[Hash(xx[0][i], yy[0][i])][j] <= n * m) {
                if((long long)rr[0][i] * f[Hash(xx[0][i], yy[0][i])][j] <= now) {
                    AddEdge(i, ma + j, 1);
                }
            }
        }
    for(i = 1; i <= fem; ++i)
        for(j = 1; j <= n * m; ++j) {
            if(f[Hash(xx[1][i], yy[1][i])][j] <= n * m) {
                if((long long)rr[1][i] * f[Hash(xx[1][i], yy[1][i])][j] <= now)
                    AddEdge(ma + j + n * m, i + ma + 2 * n * m, 1);
            }
        }
    for(i = 1; i <= n * m; ++i)
        AddEdge(ma + i, ma + i + n * m, 1);
    s = 0; t = 2 * ma + 2 * n * m + 1; Total = t + 1;
    for(i = 1; i <= fem; ++i) {
        AddEdge(s, i, 1);
        AddEdge(i + ma + 2 * n * m, t, 1);
    }
    Ans = 0;
    Sap();
    if(Ans == ma)
        return true;
    return false;
}

int main() {
    int i, j, k;
    scanf("%d%d%d%d", &n, &m, &ma, &fem);
    for(i = 1; i <= n; ++i) {
        scanf("%s", &str);
        for(j = 0; j < m; ++j)
            if(str[j] == '#')
                Map[i][j + 1] = 1;
    }
    int a, b, c;
    scanf("%d%d%d", &a, &b, &c);
    for(i = 1; i <= ma; ++i)
        scanf("%d%d%d", &xx[0][i], &yy[0][i], &rr[0][i]);
    for(i = 1; i <= fem; ++i)
        scanf("%d%d%d", &xx[1][i], &yy[1][i], &rr[1][i]);
    if(ma + 1 == fem) {
        ++ma;
        xx[0][ma] = a; yy[0][ma] = b; rr[0][ma] = c;
    }
    else {
        ++fem;
        xx[1][fem] = a; yy[1][fem] = b; rr[1][fem] = c;
    }
    if(fem != ma) {
        puts("-1");
        return 0;
    }
    memset(f, 63, sizeof(f));
    for(i = 1; i <= n; ++i)
        for(j = 1; j <= m; ++j)
            if(!Map[i][j])
                for(k = 0; k < 4; ++k)
                    if(Checker(i + dx[k], j + dy[k])) {
                        f[Hash(i, j)][Hash(i + dx[k], j + dy[k])] = 1;
                    }
    for(i = 1; i <= n; ++i)
        for(j = 1; j <= m; ++j)
            f[Hash(i, j)][Hash(i, j)] = 0;
    for(k = 1; k <= n * m; ++k)
        for(i = 1; i <= n * m; ++i)
            for(j = 1; j <= n * m; ++j)
                f[i][j] = Min(f[i][j], f[i][k] + f[k][j]);
    long long l = 0, r = 1000000000LL * (long long)(n * m), mid;
    if(Check(0)) {
        puts("0");
        return 0;
    }
    while(l < r - 1) {
        mid = (l + r) / 2LL;
        if(Check(mid))
            r = mid;
        else
            l = mid;
    }
    if(r < 1000000000LL * (long long)(n * m)) {
        cout << r << endl;
    }
    else {
        puts("-1");
        return 0;
    }
    return 0;
}
