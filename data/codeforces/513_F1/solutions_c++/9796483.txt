#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstring>
#include<vector>
#include<string>
#include<queue>
#include<cstdlib>
#include<ctime>
#define in cin
#define out cout
#define abs(x) ((x>0)?(x):(-(x)))
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define FOR(i, a, b) for(int i = a; i <= b; ++i)
#define DOWNFOR(i, a, b) for(int i = a; i >= b; --i)
#define FOREACH(i, t) for (typeof(t.begin()) i = t.begin(); i != t.end(); ++i)
using namespace std;
typedef long long ll;
const int dlin[]={0,0,-1,1};
const int dcol[]={-1,1,0,0};
int C[2000][2000],sour,dest,K;
int id1[30][30],id2[30][30],idm[500],idf[500];
int n,m,mal,fem,d[30][30],MF;
ll c[30][30];
struct pr{int x,y; ll t;
pr(){} pr(int _x,int _y,ll _t){x=_x,y=_y,t=_t;}
bool operator < (const pr &r) const{ return t<r.t; }
} males[500],females[500],boss;
queue<pr> q;
vector<pr> G;
vector<int> To[2000];
void bfs(pr X){
    FOR(i,1,n) FOR(j,1,m) c[i][j]=0;
    q.push(X);
    c[X.x][X.y]=1;
    while(!q.empty()){
        pr p=q.front(); q.pop();
        FOR(k,0,3){
            int xx=p.x+dlin[k],yy=p.y+dcol[k];
            if(!d[xx][yy] && (!c[xx][yy] || c[xx][yy]>c[p.x][p.y]+X.t)){
                c[xx][yy]=c[p.x][p.y]+X.t;
                q.push(pr(xx,yy,p.t));
            }
        }
    }
}
void much(int x,int y){To[x].push_back(y),To[y].push_back(x);}
int pred[2000];
queue<int> qq;
int bmfs(){
    FOR(i,1,K) pred[i]=0;
    pred[sour]=sour;
    qq.push(sour);
    while(!qq.empty()){
        int x=qq.front(); qq.pop();
        FOREACH(t,To[x]) if(C[x][*t] && !pred[*t]){
            pred[*t]=x;
            qq.push(*t);
        }
    }
    return (pred[dest]!=0);
}
int addpath(int x){
    int p=x,m=C[x][dest];
    if(!m) return 0;
    while(p!=sour){
        m=min(m,C[pred[p]][p]);
        p=pred[p];
    }
    if(!m) return 0;
    p=x;
    C[p][dest]-=m;
    C[dest][p]+=m;
    while(p!=sour){
        C[pred[p]][p]-=m;
        C[p][pred[p]]+=m;
        p=pred[p];
    }
    return m;
}
int main(){
    #ifndef ONLINE_JUDGE
    ifstream in("test.in");
    ofstream out("test.out");
    #endif
    in>>n>>m>>mal>>fem;
    if(abs(mal-fem)!=1){
        out<<"-1\n";
        return 0;
    }
    FOR(i,1,n){
        string s; in>>s;
        FOR(j,1,m){
            if(s[j-1]=='#') d[i][j]=1;
            id1[i][j]=++K;
            id2[i][j]=++K;
        }
    }
    FOR(i,0,n+1) d[i][0]=d[i][m+1]=1;
    FOR(i,0,m+1) d[0][i]=d[n+1][i]=1;
    in>>boss.x>>boss.y>>boss.t;
    FOR(i,1,mal) in>>males[i].x>>males[i].y>>males[i].t;
    FOR(i,1,fem) in>>females[i].x>>females[i].y>>females[i].t;
    if(mal<fem) males[++mal]=boss;
    else females[++fem]=boss;
    FOR(i,1,mal){
        bfs(males[i]);
        idm[i]=++K;
        FOR(j,1,n) FOR(k,1,m) if(c[j][k]){
            G.push_back( pr(idm[i],id1[j][k],c[j][k]-1) );
        }
    }
    FOR(i,1,fem){
        bfs(females[i]);
        idf[i]=++K;
        FOR(j,1,n) FOR(k,1,m) if(c[j][k]){
            G.push_back( pr(id2[j][k],idf[i],c[j][k]-1) );
        }
    }
    sort(G.begin(),G.end());
    sour=++K,dest=++K;
    FOR(i,1,mal) C[sour][idm[i]]=1,much(sour,idm[i]);
    FOR(i,1,fem) C[idf[i]][dest]=1,much(idf[i],dest);
    FOR(i,1,n) FOR(j,1,m) C[id1[i][j]][id2[i][j]]=1,much(id1[i][j],id2[i][j]);
    int k=0; ll mx=0;
    while(MF<mal && k<G.size()){
        mx=max(mx,G[k].t);
        C[G[k].x][G[k].y]=1,much(G[k].x,G[k].y); k++;
        while(bmfs()) FOR(i,1,fem) if(pred[idf[i]]) MF+=addpath(idf[i]);
    }
    if(MF==mal) out<<mx<<'\n';
    else out<<"-1\n";
    return 0;
}
