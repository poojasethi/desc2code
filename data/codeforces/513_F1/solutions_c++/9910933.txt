#include<bits/stdc++.h>
using namespace std;
typedef long long LL;

#define M 25
#define MAX 2000
const int INF = 1000000007;
const LL _INF = 100000000007;

vector<int> edge[MAX];
int cap[MAX][MAX], flow, dist[MAX], p[MAX]; 
int _src, _snk;

void augment( int u, int minEdge ){

    if( u == _src ) {
        flow = minEdge;
        return;
    }

    if(p[u] != -1) {
        augment(p[u], min(minEdge,cap[ p[u] ][ u ]) );
        cap[ p[u] ][ u ] -= flow;
        cap[ u ][ p[u] ] += flow;
    }
    return;
}

int maxflow( int src, int snk ) {
    _src = src, _snk = snk;
    int ret = 0;
    while(1){
        flow = 0;
        queue<int> q;
        q.push(src);
        for(int i=0; i < MAX; i++){
            dist[i] = INF;
            p[i] = -1;
        }
        dist[src] = 0;
        while(!q.empty()){
            int u = q.front();
            q.pop();
            if(u == snk) break;
            for(int i=0; i < edge[u].size(); i++){
                int v = edge[u][i];
                if( cap[u][v] > 0 && dist[v] == INF ) {
                    dist[v] = dist[u] + 1;
                    q.push( v );
                    p[v] = u;
                }
            }
        }
        augment( snk, INF );
        if( flow == 0 ) break;
        ret += flow;
    }
    return ret;
}

void addEdge( int u, int v, int w, int x = 0 ) {
    edge[u].push_back(v);
    edge[v].push_back(u);
    cap[u][v] += w;
    cap[v][u] += x;
}

int n, m, males,females;
char grid[M][M];
pair<int,int> cellid[M][M];

struct Scayger {

    int id, sx, sy;
    LL tm;
    Scayger(int id, int x, int y, LL t) : 
        id(id),sx(x),sy(y),tm(t){}

};

vector<Scayger> male, female;


LL movingTime[2*M*M][M][M];
int dr[] = {0,0,-1,1};
int dc[] = {-1,1,0,0};

void bfs( Scayger& sc ) {

    for( int i=0 ; i < n; i++ ) {
        for( int j=0 ; j < m; j++ ) {
            movingTime[sc.id][i][j] = _INF;
        }
    }

    movingTime[sc.id][sc.sx][sc.sy] = 0;

    queue< pair<int,int> > q;
    q.push( make_pair(sc.sx, sc.sy) );

    while(!q.empty()){
        pair<int,int> u = q.front();
        q.pop();
        for(int i=0; i < 4; i++){
            int x = u.first + dr[i];
            int y = u.second + dc[i];
            if(x<0||y<0||x>=n||y>=m) continue;
            if(grid[x][y]=='#') continue;
            if( movingTime[sc.id][x][y] 
                > movingTime[sc.id][u.first][u.second] + sc.tm ) {
                movingTime[sc.id][x][y] 
                = movingTime[sc.id][u.first][u.second] + sc.tm;
                q.push( make_pair(x,y) );
            }
        }
    }
}

bool ok( LL tm ) {
    // build the graph for given time
    // run the flow
    // return verdict

    for( int i=0 ; i < MAX; i++ ) {
        edge[i].clear();
    }

    memset( cap , 0 , sizeof cap );

    int src = MAX-2, snk = MAX-1;

    // source to females
    for(int i=0 ; i < female.size(); i++) {
        addEdge( src , female[i].id, 1 );
    }

    // males to sink
    for(int i=0 ; i < male.size(); i++) {
        addEdge( male[i].id , snk, 1 );
    }


    // between input and output of cells
    for( int i=0 ; i < n; i++ ) {
        for( int j=0; j < m; j++ ) {
            addEdge( cellid[i][j].first, cellid[i][j].second, 1 );
        }
    }

    // build the graph
    for(int i=0; i < female.size(); i++) {
        for( int j=0 ; j < n; j++ ) {
            for( int k=0; k < m; k++ ) {
                if( movingTime[ female[i].id ][ j ][ k ] <= tm ) {
                    addEdge( female[i].id, cellid[j][k].first, 1 );
                    // cout << "edge between : " << female[i].id << " " << cellid[j][k].first << endl;
                }
            }
        }
    }

    for( int j=0 ; j < n; j++ ) {
        for( int k=0; k < m; k++ ) {
            for( int l=0; l < male.size(); l++ ) {
                if( movingTime[ male[l].id ][ j ][ k ] <= tm ) {
                    addEdge( cellid[j][k].second, male[l].id, 1 );
                    // cout << "edge between : " << male[l].id << " " << cellid[j][k].second << endl;
                }
                
            }
        }
    }

    int flows = maxflow( src, snk );

    // cout << "flow is : " << flows <<" with time: " << tm << endl;

    return flows == int(male.size());

}

LL solve(bool flag,Scayger& boss){

    if( !flag ) {
        // means boss is male
        male.push_back( boss );
    } else {
        female.push_back( boss );
    }

    

    LL l = 0, r = _INF;
    bool possible = 0;
    while( l <= r ) {
        LL mid = (l+r) / 2;
        // cout << "mid: " << mid << endl;
        if( ok(mid) ) {
            possible = 1;
            r = mid - 1;
        } else {
            l = mid + 1;
        }

    }


    if( !flag ) {
        male.pop_back();
    } else {
        female.pop_back();
    }

    // cout << possible << " " << r+1 << endl;

    if( possible ) return r + 1;
    return _INF;

}

int main(){

    cin >> n >> m >> males >> females;

    for(int i=0; i < n; i++)
        scanf("%s" , grid[i] );

    int bx, by;
    LL bt;
    cin >> bx >> by >> bt;
    bx--; by--;

    Scayger boss = Scayger(0,bx,by,bt);
    bfs(boss);

    int id = 1;

    for(int i=0; i < males; i++){
        int x, y ;
        LL t;
        cin >> x >> y >> t;
        x--,y--;
        male.push_back( Scayger(id,x,y,t) );
        id++;
        bfs( male[ male.size() - 1 ] );
    }

    for(int i=0; i < females; i++){
        int x, y;
        LL t;
        cin >> x >> y >> t;
        x--,y--;
        female.push_back( Scayger(id,x,y,t) );
        id++;
        bfs( female[ female.size() - 1 ] );
    }


    for(int i=0 ; i< n; i++) {
        for(int j=0 ; j< m; j++) { 
            cellid[i][j].first = id++;
            cellid[i][j].second = id++;
        }
    }

    LL res = _INF;

    if( (males < females) && (males+1 == females) ) {
        // cout<<"male boss" << endl;
        // cout << "male" << endl;
        res = solve(0,boss);
    } else if( (females < males) && (females+1 == males) ) {
        // cout << "female" << endl;
        res = solve(1,boss);
    }

    if(res == _INF) {
        cout << "-1\n";
    } else {
        cout << res << "\n";
    }


    // for( int i=0 ; i < n; i++ ) {
    //  for( int j=0 ; j < m; j++ ){
    //      cout << movingTime[0][i][j] << " ";
    //  }
    //  cout << endl;
    // }


    return 0;
}

// 2 2 1 0
// ..
// ..
// 1 1 1
// 1 1 1


/*
2 4 3 2
..##
.#..
1 1 1
1 1 1
1 1 6
1 1 2
1 1 1
1 1 1
*/