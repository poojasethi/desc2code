#undef NDEBUG
#ifdef SU2_PROJ
#define _GLIBCXX_DEBUG
#endif

#include <iostream>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <string>
#include <cstdlib>
#include <cstdio>
#include <climits>
#include <cstring>
#include <cassert>
#include <ctime>
#include <cmath>
#include <vector>
#include <queue>
#include <stack>
#include <list>
#include <set>
#include <map>
#include <bitset>
#include <algorithm>
#include <utility>
#include <numeric>
#include <functional>

#define forn(i, n) for (int i = 0; i < int(n); i++)
#define forl(i, n) for (int i = 1; i <= int(n); i++)
#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)
#define fore(i, l, r) for (int i = int(l); i <= int(r); i++)
#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))
#define all(a) (a).begin(), (a).end()
#define sz(a) int((a).size())
#define pb(a) push_back(a)
#define mp(x, y) make_pair((x), (y))
#define ft first
#define sc second
#define x first
#define y second
#define eprintf(...) fprintf(stderr, __VA_ARGS__)

using namespace std;

typedef long long li;
typedef long double ld;
typedef pair<int, int> pt;

template<typename X> inline X abs(const X& a) { return a < 0? -a: a; }
template<typename X> inline X sqr(const X& a) { return a * a; }

const int INF = int(1e9);
const li INF64 = li(1e18);
const ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;

const int N = 22 + 1, V = 4 * N * N + 3;

int n, m, k, l;
char a[N][N];
int x[V], y[V];
li v[V];

inline bool read()
{
	if (!(cin >> n >> m >> k >> l)) return false;
	forn(i, n) scanf("%s", a[i]);
	forn(i, 1 + k + l) cin >> x[i] >> y[i] >> v[i];
	//forn(i, 1 + k + l) scanf("%d%d%I64d", &x[i], &y[i], &v[i]), cerr << x[i] << ' ' << y[i] << ' ' << v[i] << endl;
	if (k + 1 != l) swap(x[0], x[k]), swap(y[0], y[k]), swap(v[0], v[k]), l++;
	else k++;
	forn(i, k + l) x[i]--, y[i]--;
	//forn(i, k + l) cerr << x[i] << ' ' << y[i] << ' ' << v[i] << endl; 
	return true;
}

struct edge
{
	int to, f, c, rev;
};

vector<edge> g[V];

void add(int fr, int to, int c)
{
	edge f = { to, 0, c, sz(g[to]) };
	edge b = { fr, 0, 0, sz(g[fr]) };
	g[fr].pb(f);
	g[to].pb(b);
}

int p[V];

bool enlarge(int s, int t)
{
	forn(i, t + 1) p[i] = -1;
	queue<int> q;

	q.push(s);
	while (!q.empty() && p[t] == -1)
	{
		int v = q.front();
		q.pop();

		forn(i, sz(g[v]))
		{
			edge& e = g[v][i];
			if (e.f < e.c && p[e.to] == -1)
			{
				p[e.to] = e.rev;
				q.push(e.to);
			}
		}
	}

	if (p[t] == -1) return false;

	for (int v = t; v != s; v = g[v][p[v]].to)
	{
		g[g[v][p[v]].to][g[v][p[v]].rev].f++;
		g[v][p[v]].f--;
	}

	return true;
}

int d[N][N][N][N];

bool check(li T)
{
	if (k != l) return false;

	/*forn(i, k) cerr << x[i] << ' ' << y[i] << endl;
	cerr << endl;
	forn(i, l) cerr << x[k + i] << ' ' << y[k + i] << endl;
	cerr << endl;*/

	const int s = k + 2 * n * m + l, t = s + 1;
	forn(i, t + 1) g[i].clear();

	forn(i, k) add(s, i, 1);
	forn(i, l) add(k + 2 * n * m + i, t, 1);

	forn(x, n)
		forn(y, m)
		{
			add(k + 2 * (x * m + y), k + 2 * (x * m + y) + 1, 1);
			forn(i, k)
			{
				int dd = d[x][y][::x[i]][::y[i]];
				if (dd == INF) continue;
				if (dd * v[i] <= T)
				{
					add(i, k + 2 * (x * m + y), 1);
					/*cerr << ::x[i] << ' ' << ::y[i] << ' ' << v[i] << endl;
					cerr << x << ' ' << y << endl;
					cerr << endl;*/
				}
			}
			forn(i, l)
			{
				int dd = d[x][y][::x[k + i]][::y[k + i]];
				if (dd == INF) continue;
				if (dd * v[k + i] <= T)
					add(k + 2 * (x * m + y) + 1, k + 2 * n * m + i, 1);
			}
		}

	int f = 0;
	while (enlarge(s, t)) f++;
	return f == k;
}

void bfs(pt s, int d[N][N])
{
	forn(i, n) forn(j, m) d[i][j] = INF;
	queue<pt> q;

#define pos(v) (v).x][(v).y

	if (a[pos(s)] == '.')
	{
		d[pos(s)] = 0;
		q.push(s);
	}

	while (!q.empty())
	{
		pt v = q.front();
		q.pop();

		static int dx[] = { -1, 0, 1, 0 };
		static int dy[] = { 0, -1, 0, 1 };

		forn(k, 4)
		{
			pt nv(v.x + dx[k], v.y + dy[k]);
			if (!correct(nv.x, nv.y, n, m)) continue;
			if (a[pos(nv)] == '#') continue;
			if (d[pos(nv)] > d[pos(v)] + 1)
			{
				d[pos(nv)] = d[pos(v)] + 1;
				q.push(nv);
			}
		}
	}
}

inline void solve()
{
	forn(i, n) forn(j, m) bfs(mp(i, j), d[i][j]);

	//cerr << check(0) << endl;
	//exit(0);

	li lf = 0, rg = INF * 1ll * n * m;
	while (lf != rg)
	{
		li mid = (lf + rg) >> 1;
		if (check(mid)) rg = mid;
		else lf = mid + 1;
	}
	if (!check(lf)) puts("-1");
	else cout << lf << endl;
}

int main()
{
#ifdef SU2_PROJ
    assert(freopen("input.txt", "rt", stdin));
    assert(freopen("output.txt", "wt", stdout));
#endif
    
    cout << setprecision(10) << fixed;
    cerr << setprecision(5) << fixed;
    
    assert(read());
    solve();
	
    return 0;
}
