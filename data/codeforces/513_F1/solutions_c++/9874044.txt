/*
ID: keyvank2
TASK: combo
LANG: C++
*/

#include <bits/stdc++.h>

#define ff first
#define ss second
#define pb push_back
#define mp make_pair
#define FOR(i,j,k) for(int i = j; i < (int)(k); i++)
#define FORV(i, v) FOR(i, 0, ((v).size()))
#define REP(i,j,k) for(int i = j; i >= (int)(k); i--)
#define setmax(i) const int maxn = (int) i;
#define setmod(i) const int MOD = (int) i;
#define all(a) a.begin(),a.end()
#define autodef(x,v) typeof(v) x = (v)
#define autoref(x,v) typeof(v)& x = (v)
#define forit(it, c) for (autodef(it, ((c).begin())); it != ((c).end()); ++it)

//typedef complex<double> Point;
//#define X real()
//#define Y imag()

using namespace std;

//ifstream fin("");
//ofstream fout("");
//#define cin fin
//#define cout fout

typedef long long ll;
typedef long double ld;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef pair<ld,ld> pdd;
typedef pair<pii,int> ppi;
typedef pair<pll,ll> ppl;
typedef pair<int,pii> pip;
typedef pair<ll,pll> plp;
typedef pair<pii,pii> ppp;

const int INF = (int) 2e9;
const ll INFL = (ll) 9e18;
const int MAXINT = ((~0) ^ (1 << 31));
const ll MAXLL = ((~0) ^ ((ll)1 << 63));

template<class T> inline T pow2(T a) { return a*a;}
template<class T> inline bool mineq(T& a, T b){return (a > b) ? (a=b, true) : false;}
template<class T> inline bool maxeq(T& a, T b){return (a < b) ? (a=b, true) : false;}

//srand (time(NULL));

setmax(1000); //!!!

int n,m, dist[22][22][22][22];
char grid[22][22];

pii get(pii a, int t)
{
    if(t == 0)
	return mp(a.ff-1,a.ss);
    if(t == 1)
	return mp(a.ff,a.ss+1);
    if(t == 2)
	return mp(a.ff+1,a.ss);
    if(t == 3)
	return mp(a.ff,a.ss-1);
    return mp(-1,-1);
}

bool ok(pii a)
{
    if(a.ff < 0 || a.ff >= n)
	return false;
    if(a.ss < 0 || a.ss >= m)
	return false;
    if(grid[a.ff][a.ss] == '#')
	return false;
    return true;
}

void bfs(pii src, int d[22][22])
{
    bool visited[22][22];
    FOR(i,0,22)
    {
	FOR(j,0,22)
	{
	    d[i][j] = INF;
	    visited[i][j] = false;
	}
    }

    d[src.ff][src.ss] = 0;
    visited[src.ff][src.ss] = true;
    queue<pii> q;
    q.push(src);

    while(!q.empty())
    {
	pii now = q.front();
//	cout << src.ff << " " << src.ss << " " << now.ff << " " << now.ss << " " << grid[now.ff][now.ss] << endl;
	q.pop();
	
	FOR(i,0,4)
	{
	    pii t = get(now,i);
	    if(ok(t) && !visited[t.ff][t.ss])
	    {
		d[t.ff][t.ss] = d[now.ff][now.ss] + 1;
		visited[t.ff][t.ss] = true;
		q.push(t);
	    }
	}
    }
}

typedef ll flow;
const flow INFF = INF;
bool visited[maxn];
flow g[maxn][maxn];

struct MaxFlow
{
    MaxFlow()
    {
	FOR(i,0,maxn) FOR(j,0,maxn) g[i][j] = 0;
    }
    
    void addEdge(int a, int b, flow f)
    {
	g[a][b] += f;
    }

    flow dfs(int v, int sink, flow lim)
    {
//	cout << v << " " << sink << " "<< lim << endl;
	if(visited[v]) return 0;
	if(v == sink) return lim;

	visited[v] = true;
	FOR(i,0,maxn)
	{
	    if(g[v][i])
	    {
		flow f = dfs(i,sink,min(lim,g[v][i]));
		if(f != 0)
		{
		    addEdge(v,i,-f);
		    addEdge(i,v,f);
		    return f;
		}
	    }
	}
	return 0;
    }

    flow maxFlow(int src, int sink)
    {
	flow f, ans =0;
	FOR(i,0,maxn) visited[i] = false;
	while((f = dfs(src,sink,INFF)))
	{
	    ans += f;
	    FOR(i,0,maxn) visited[i] = false;
	}
	return ans;
    }
};

struct scayger
{
    int x,y,speed;
};
vector<scayger> female,male;
int malesize, femalesize;

inline ll finddist(scayger& s, int x, int y)
{
   // cout << "* " << s.x << " " << s.y << " " << x << " "<< y << " "<< dist[s.x][s.y][x][y] << endl;
    if(dist[s.x][s.y][x][y] == INF)
	return INFL;
    return (ll)s.speed * dist[s.x][s.y][x][y];
}

inline ll maletime(int p, int x, int y)
{
    if(grid[x][y] == '#')
	return INFL;
    scayger s = male[p];
    return finddist(s,x,y);
}

inline ll femaletime(int p, int x, int y)
{
    if(grid[x][y] == '#')
	return INFL;
    scayger s = female[p];
    return finddist(s,x,y);
}

//maxflow nodes
int malein[22*22], maleout[22*22], femalein[22*22], femaleout[22*22];
int gridin[22][22], gridout[22][22], source, sink;

bool can(ll len)
{
    MaxFlow mf;

    FOR(i,0,malesize)
    {
	mf.addEdge(malein[i],maleout[i],1);
	mf.addEdge(source,malein[i],1);
    }
    FOR(i,0,femalesize)
    {
	mf.addEdge(femalein[i],femaleout[i],1);
	mf.addEdge(femaleout[i],sink,1);
    }
    FOR(i,0,n)
    {
	FOR(j,0,m)
	{
	    mf.addEdge(gridin[i][j],gridout[i][j],1);
	}
    }
    
    FOR(i,0,malesize)
    {
	FOR(x,0,n)
	{
	    FOR(y,0,m)
	    {
		if(maletime(i,x,y) <= len)
		    mf.addEdge(maleout[i],gridin[x][y],1);
		if(femaletime(i,x,y) <= len)
		    mf.addEdge(gridout[x][y],femalein[i],1);
	    }
	}
    }
    
    return (mf.maxFlow(source,sink) == malesize);
}

int main()
{
    ios_base::sync_with_stdio(0);cin.tie(0);
    
    cin >> n >> m >> femalesize >> malesize;

    FOR(i,0,n)
	FOR(j,0,m)
	    cin >> grid[i][j];
   
    FOR(i,0,n)
	FOR(j,0,m)
	    bfs(mp(i,j),dist[i][j]);
    
  //  cout << ":| " << dist[0][1][3][0] << endl;
// return 0;

  /*  FOR(i,0,n)
    {
	FOR(j,0,n)
	{
	    cout << i << " " << j << " " << dist[0][0][i][j] << endl;
	}
    }*/

    int bossx, bossy, bossspeed;
    cin >> bossx >> bossy >> bossspeed;

    FOR(i,0,femalesize)
    {
	int x,y,speed;
	cin >> x >> y >> speed;
	female.pb((scayger){x-1,y-1,speed});
    }

    FOR(i,0,malesize)
    {
	int x,y,speed;
	cin >> x >> y >> speed;
	male.pb((scayger){x-1,y-1,speed});
    }
    
    if(abs(malesize - femalesize) != 1)
    {
	cout << -1;
	return 0;
    }
    
    if(malesize < femalesize)
    {
	malesize++;
	male.pb((scayger){bossx-1,bossy-1,bossspeed});
    }
    else
    {
	femalesize++;
	female.pb((scayger){bossx-1,bossy-1,bossspeed});
    }

    int cnt = 0;
    source = cnt++;
    sink = cnt++;

    FOR(i,0,malesize)
    {
	malein[i] = cnt++;
	maleout[i] = cnt++;
	femalein[i] = cnt++;
	femaleout[i] = cnt++;
    }

    FOR(i,0,n)
    {
	FOR(j,0,m)
	{
	    gridin[i][j] = cnt++;
	    gridout[i][j] = cnt++;
	}
    }

    ll l = 0, r = INFL/2, ans = -1;
    while(l <= r)
    {
	ll mid = (l+r)/2;
//	cout << mid << endl;
	if(can(mid))
	{
	    r = mid-1;
	    ans = mid;
	}
	else
	{
	    l = mid+1;
	}
    }
    cout << ans;
}
