//Coder: Balajiganapathi
#ifndef ONLINE_JUDGE
#   define DEBUG
#   define TRACE
#else
//#   define NDEBUG
#endif

#include <algorithm>
#include <bitset>
#include <deque>
#include <cassert>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <functional>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <utility>
#include <vector>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;

typedef vector<int> vi;
typedef pair<int,int> pi;
typedef vector<string> vs;
typedef vector<pi> vpi;

// Basic macros
#define fi          first
#define se          second
#define all(x)      (x).begin(), (x).end()
#define ini(a, v)   memset(a, v, sizeof(a))
#define re(i,s,n)  	for(int i=s;i<(n);++i)
#define rep(i,s,n)  for(int i=s;i<=(n);++i)
#define fo(i,n)     re(i,0,n)
#define rev(i,n,s)  for(int i=(n)-1;i>=s;--i)
#define repv(i,n,s) for(int i=(n);i>=s;--i)
#define fov(i,n)    rev(i,n,0)
#define pu          push_back
#define mp          make_pair
#define si(x)       (int)(x.size())

#ifdef TRACE
#define trace(x)            cerr<<x<<endl;
#define trace1(x)           cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<endl;
#define trace2(x,y)         cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<" | "#y" = "<<y<<endl;
#define trace3(x,y,z)       cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<" | "#y" = "<<y<<" | "#z" = "<<z<<endl;
#define trace4(a,b,c,d)     cerr<<__FUNCTION__<<":"<<__LINE__<<": "#a" = "<<a<<" | "#b" = "<<b<<" | "#c" = "<<c<<" | "#d" = "<<d<<endl;
#define trace5(a,b,c,d,e)   cerr<<__FUNCTION__<<":"<<__LINE__<<": "#a" = "<<a<<" | "#b" = "<<b<<" | "#c" = "<<c<<" | "#d" = "<<d<<" | "#e" = "<<e<<endl;
#define trace6(a,b,c,d,e,f) cerr<<__FUNCTION__<<":"<<__LINE__<<": "#a" = "<<a<<" | "#b" = "<<b<<" | "#c" = "<<c<<" | "#d" = "<<d<<" | "#e" = "<<e<<" | "#f" = "<<f<<endl;
#else
#define trace(x)
#define trace1(x)
#define trace2(x,y)
#define trace3(x,y,z)
#define trace4(a,b,c,d)
#define trace5(a,b,c,d,e)
#define trace6(a,b,c,d,e,f)
#endif

const int oo = 1000000009;
const double eps = 1e-6;
const int mod = 1000000007;
const int mx = 22;

int di[] = {0, 0, -1, 1};
int dj[] = {-1, 1, 0, 0};
int n, m, males, females;

char mapp[mx][mx];
int mr[mx * mx], mc[mx * mx], mt[mx * mx];
int fr[mx * mx], fc[mx * mx], ft[mx * mx];

int mat[mx][mx][mx][mx];

#define N (3 * mx * mx + 2)
#define M (3 * mx * mx * mx * mx)
int last_my[N], tlast_my[N], d[N];
int c[M*2], ver[M*2], next_my[M*2];
int ptr = 1;
 
void addEdge(int from, int to, int cap) {
    //trace3(from, to, cap);
    ver[ptr] = to; c[ptr] = cap; next_my[ptr] = last_my[from]; last_my[from] = ptr++;
    ver[ptr] = from; c[ptr] = 0; next_my[ptr] = last_my[to]; last_my[to] = ptr++;
}
int opp(int n) {
    if(n&1) return n+1;
    return n-1;
}
int temp;
int dfs(int cur, int flow, int &n) {
    if(cur == n) return flow;
    for(int &i=last_my[cur]; i; i = next_my[i]) if(c[i] && d[cur]==(d[ver[i]]-1) && (temp = dfs(ver[i], c[i]<flow?c[i]:flow, n))) {
        c[i] -= temp;
        c[opp(i)] += temp;
        return temp;
    }
    d[cur] = -1;
    return 0;
}
 
int dinic(int S, int T) {
    int ans = 0;
    for(int i=0; i<=T; i++) tlast_my[i] = last_my[i];
    while(1) {
        for(int i=0; i<=T; i++) last_my[i] = tlast_my[i], d[i] = -1;
        queue <int> Q;
        Q.push(S); d[S] = 0;
        while(!Q.empty()) {
            //trace1(si(Q));
            int cur = Q.front(); Q.pop();
            for(int i = last_my[cur]; i; i = next_my[i]) if(c[i] && d[ver[i]] == -1) {
                d[ver[i]] = d[cur] + 1;
                Q.push(ver[i]);
            }
        }
        if(d[T] == -1) break;
        //trace2(T, d[T]);
        int t;
        while(1) {
            t = dfs(S,oo,T);
            //trace1(t);
            if(t) ans += t;
            else break;
        }
    }
    return ans;
}

int s, t, mstart, fstart, ostart, istart;
bool ok(ll prev, ll lim) {
    ptr = 1;
    ini(last_my, 0);
    fo(i, n * m) addEdge(istart + i, ostart + i, 1);
    fo(i, males) addEdge(s, mstart + i, 1);
    fo(i, females) addEdge(fstart + i, t, 1);
    //trace2(s, t);
    //trace2(prev, lim);
    fo(i, n) fo(j, m) {
        fo(k, males) {
            int si = mr[k], sj = mc[k];
            if(mat[si][sj][i][j] >= oo) continue;
            ll c = 1ll * mat[si][sj][i][j] * mt[k];
            if(c <= lim) {
                addEdge(mstart + k, istart + i * m + j, 1);
                //trace5(k, i, j, mat[si][sj][i][j], c);
            }
        }
        fo(k, females) {
            int si = fr[k], sj = fc[k];
            if(mat[si][sj][i][j] >= oo) continue;
            ll c = 1ll * mat[si][sj][i][j] * ft[k];
            if(c <= lim) {
                addEdge(ostart + i * m + j, fstart + k, 1);
                //trace5(k, i, j, mat[si][sj][i][j], c);
            }
        }
    }

    //trace4(n, m, s, t);
    int flow = dinic(s, t);
    //trace3(prev, lim, flow);
    return flow == males;
}

int main() {
    scanf("%d %d", &n, &m);
    scanf("%d %d", &males, &females);

    fo(i, n) scanf("%s", mapp[i]);
    int r, c, _t;
    scanf("%d %d %d", &r, &c, &_t);
    if(males < females) {
        mr[males] = r;
        mc[males] = c;
        mt[males] = _t;
    } else {;
        fr[females] = r;
        fc[females] = c;
        ft[females] = _t;
    }
    fo(i, males) scanf("%d %d %d", mr + i, mc + i, mt + i);
    fo(i, females) scanf("%d %d %d", fr + i, fc + i, ft + i);
    if(males < females) ++males;
    else ++females;

    if(males != females) {
        printf("-1\n");
        return 0;
    }

    fo(i, males) --mr[i], --mc[i];
    fo(i, females) --fr[i], --fc[i];

    fo(i, n) fo(j, m) {
        fo(ji, n) fo(jj, m) mat[i][j][ji][jj] = oo;
        mat[i][j][i][j] = 0;
        if(mapp[i][j] == '.') {
            fo(d, 4) {
                int ni = i + di[d], nj = j + dj[d];
                if(ni >= 0 && ni < n && nj >= 0 && nj < m && mapp[ni][nj] == '.') {
                    //trace4(i, j, ni, nj);
                    mat[i][j][ni][nj] = 1;
                }
            }
        }
    }

    fo(ki, n) fo(kj, m) fo(ii, n) fo(ij, m) fo(ji, n) fo(jj, m) {
        mat[ii][ij][ji][jj] = min(mat[ii][ij][ji][jj], mat[ii][ij][ki][kj] + mat[ki][kj][ji][jj]);
    }
    //trace3(mapp[1][0], mapp[3][4], mat[1][0][3][4]);

    ll mx_s = 1ll * n * m * n * m * oo;
    ll lo = 0, hi = mx_s;

    s = 0;
    mstart = 1;
    istart = mstart + males;
    ostart = istart + n * m;
    fstart = ostart + n * m;
    t = fstart + females;

    ll last_mid = -oo;

    while(lo < hi) {
        ll mid = (lo + hi) / 2;
        if(ok(last_mid, mid)) hi = mid;
        else lo = mid + 1;
        last_mid = mid;
    }


    if(lo == mx_s) lo = -1;
    printf("%lld\n", lo);

	return 0;
}

