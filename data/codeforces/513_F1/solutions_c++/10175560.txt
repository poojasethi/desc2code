#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
#include <vector>
#include <queue>
#define MAXN 22
#define INF 10000000000000000LL
#define INF2 0x3f3f3f3f
#define lli long long int
#define pb push_back
using namespace std;

struct edge {
    int id;
    int x, y;
    lli w;

    edge(int id, int x, int y, lli w):id(id), x(x), y(y), w(w) {
    }
};

struct edge2 {
    int viz;
    int cap;
    int dual;

    edge2(int viz, int cap, int dual):viz(viz), cap(cap), dual(dual) {
    }
};

int dx[] = {0, -1, 0, 1};
int dy[] = {1, 0, -1, 0};
lli d[25][25];
char grid[25][25];
vector <edge> v;
vector <edge2> g[2005];

int n, m;
int flow;

int p[2005];
int p_edge[2005];
int d2[2005];

bool comp(const struct edge &a, const struct edge &b) {
    return a.w < b.w;
}

void BFS(int sx, int sy, int id, int cost) {
    int x, y;
    int nx, ny;
    queue <pair <int, int> > fila;

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            d[i][j] = INF;
        }
    }
    d[sx][sy] = 0;
    fila.push(make_pair(sx, sy));
    while(!fila.empty()) {
        x = fila.front().first;
        y = fila.front().second;
        fila.pop();

        for (int i = 0; i < 4; i++) {
            nx = x + dx[i];
            ny = y + dy[i];

            if (nx >= 0 && nx < n && ny >= 0 && ny < m) {
                if (grid[nx][ny] != '#' && d[nx][ny] > d[x][y] + cost) {
                    d[nx][ny] = d[x][y] + cost;
                    fila.push(make_pair(nx, ny));
                }
            }
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            //printf("i = %d, j = %d, d[i][j] = %lld\n", i, j, d[i][j]);
            if (d[i][j] != INF) {
                v.pb(edge(id, i, j, d[i][j]));
            }
        }
    }
    /*printf("sx = %d, sy = %d cost = %d\n", sx, sy, cost);
    printf("debug\n");
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            printf("i = %d, j = %d, d[i][j] = %lld\n", i, j, d[i][j]);
        }
    }
    printf("end debug\n"); */
    return;
}

int BFS2(int s, int t) {
    int next;
    int viz;
    int cap;
    queue <int> fila;

    memset(d2, INF2, sizeof(d2));
    d2[s] = 0;
    fila.push(s);

    while(!fila.empty()) {
        next = fila.front();
        fila.pop();

        for (int i = 0; i < (int)g[next].size(); i++) {
            viz = g[next][i].viz;
            cap = g[next][i].cap;
            if (cap && d2[viz] > d2[next] + 1) {
                d2[viz] = d2[next] + 1;
                p[viz] = next;
                p_edge[viz] = i;
                fila.push(viz);
            }
        }
    }
    return d2[t] != INF2;
}

void add_edge(int x, int y, int cap) {
    g[x].pb(edge2(y, cap, (int)g[y].size()));
    g[y].pb(edge2(x, 0, (int)g[x].size() - 1));

    return;
}

void max_flow(int s, int t) {
    int augment;
    int dual;
    int cap;
    int idx;

    while(BFS2(s, t)) {
        //printf("hey\n");
        augment = INF2;
        for (int v = t; v != s; v = p[v]) {
            idx = p_edge[v];
            cap = g[p[v]][idx].cap;
            augment = min(augment, g[p[v]][idx].cap);
        }
        for (int v = t; v != s; v = p[v]) {
            idx = p_edge[v];
            dual = g[p[v]][idx].dual;
            //printf("v = %d, dual = %d, idx = %d\n", v, dual, idx);
            g[p[v]][idx].cap -= augment;
            g[v][dual].cap += augment;
        }
        //printf("augment = %d\n", augment);
        flow += augment;
    }
    return;
}

int main(void) {
    int male, fem;
    int x, y, z;
    int male_id;
    int fem_id;
    lli next;
    int k;
    int s, t;
    int idx, idx2;

    scanf(" %d %d %d %d", &n, &m, &male, &fem);
    for (int i = 0; i < n; i++) {
        scanf(" %s", grid[i]);
    }
    if (male == fem || abs(male - fem) > 1) {
        printf("-1\n");
    } else {
        scanf(" %d %d %d", &x, &y, &z);
        x--;
        y--;
        male_id = 2 * MAXN * MAXN + 1;
        fem_id = 2 * MAXN * MAXN + 1 + male;
        if (male < fem) {
            fem_id++;
            BFS(x, y, male_id++, z);
        } else {
            BFS(x, y, fem_id++, z);
        }

        for (int i = 0; i < male; i++) {
            scanf(" %d %d %d", &x, &y, &z);
            x--;
            y--;
            BFS(x, y, male_id++, z);
        }
        for (int i = 0; i < fem; i++) {
            scanf(" %d %d %d", &x, &y, &z);
            x--;
            y--;
            BFS(x, y, fem_id++, z);
        }
        if (fem < male) {
            fem++;
        }
        sort(v.begin(), v.end(), comp);

        s = fem_id; // source
        t = fem_id + 1; // sink
        //printf("s = %d, t = %d\n", s, t);
        //printf("male_id = %d, fem_id = %d\n", male_id, fem_id);
        for (int i = 2 * MAXN * MAXN + 1; i < male_id; i++) {
            //printf("male = %d\n", i);
            add_edge(s, i, 1);
        }
        for (int i = male_id; i < fem_id; i++) {
            //printf("female = %d\n", i);
            add_edge(i, t, 1);
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] != '#') {
                    idx = MAXN * i + j;
                    idx2 = MAXN * MAXN + idx;
                    //printf("idx = %d, idx2 = %d\n", idx, idx2);
                    add_edge(idx, idx2, 1);
                }
            }
        }
        /*printf("debug\n");
        for (int i = 0; i < (int)v.size(); i++) {
            printf("i = %d, v[i].w = %lld\n", i, v[i].w);
        }
        printf("end debug\n"); */

        flow = 0;
        k = 0;
        next = 0;
        while(flow < fem) {
            //printf("flow = %d\n", flow);
            if (k >= (int)v.size()) {
                printf("-1\n");
                return 0;
            }
            next = v[k].w;
            while(k < (int)v.size() && v[k].w == next) {
                //printf("v[k].w = %lld\n", v[k].w);
                idx = MAXN * v[k].x + v[k].y;
                //printf("v[k].id = %d, idx = %d, idx2 = %d, v[k].x = %d, v[k].y = %d, v[k].w = %lld\n", v[k].id, idx, idx + MAXN * MAXN, v[k].x, v[k].y, v[k].w);
                if (v[k].id < male_id) {
                    add_edge(v[k].id, idx, 1);
                } else {
                    idx = idx + MAXN * MAXN;
                    add_edge(idx, v[k].id, 1);
                }
                k++;
            }
            //printf("k = %d, next = %lld\n", k, next);
            //printf("flow = %d\n", flow);
            max_flow(s, t);
            //printf("hum\n");
        }
        printf("%lld\n", next);
    }
    return 0;
}
