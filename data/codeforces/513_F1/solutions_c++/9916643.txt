#include<bits/stdc++.h>

using namespace std;

#define PB push_back
#define MP make_pair
#define FOR( i , n ) for( int i = 0; i < (n); i++ )
#define FORR( i , n ) for( int i = ( n - 1 ); i >= 0 ; i-- )
#define DB( x ) cout << #x << " = " << x << endl;
#define OUT( a , n ) for( int J = 0; J < (n); J++ )cout<< (a)[J] << " \n"[J == (n) - 1 ]
#define WAIT cout << flush , system("PAUSE");
#define CONTAINS(a, x) ((a).find(x) != (a).end())


typedef long long ll;
typedef pair<int, int> pii;


const int MAXV = 50005, MAXE = 600005, oo = 0x3f3f3f3f;
int E, N, M, last[MAXV], next[MAXE], adj[MAXE], level[MAXV], now[MAXV], Q[MAXV], source, sink;
ll cap[MAXE], flow[MAXE];


void add_edge (int u, int v, int c)
{
	cap[E] = c, flow[E] = 0, adj[E] = v, next[E] = last[u], last[u] = E++;
	cap[E] = 0, flow[E] = 0, adj[E] = u, next[E] = last[v], last[v] = E++;
}

#define RES(e)  (cap[e] - flow[e])

bool bfs (int s, int t)
{
	memset(level, -1, sizeof level);
	level[s] = 0;
	Q[0] = s;

	for (int ql = 0, qr = 1; ql < qr && level[t] == - 1; ++ql)
	{
		int u = Q[ql];

		for (int e = last[u]; e != -1; e = next[e])
		{
			int v = adj[e];

			if (level[v] == -1 && RES(e) > 0)
			{
				level[v] = level[u] + 1;
				Q[qr++] = v;
			}
		}
	}

	return level[t] != -1;
}

ll dfs (int u, ll curr)
{
	if (u == sink)
	    return curr;

	for (int e = now[u]; e != -1; now[u] = e = next[e])
	{
		int v = adj[e];

		if (level[v] == level[u] + 1 && RES(e) > 0)
		{
			ll ans = dfs(v, min(curr, RES(e)));

			if (ans > 0)
			{
				flow[e] += ans;
				flow[e ^ 1] -= ans;
				return ans;
			}
		}
	}

	return 0;
}

ll max_flow ()
{
	ll ans = 0, res;

	while (bfs(source, sink))
	{
		memcpy(now, last, sizeof now);

		while ((res = dfs(source, oo)) > 0)
		    ans += res;
	}

	return ans;
}

const int MAXN = 12, TOT = MAXN * MAXN;
ll dm[TOT][MAXN][MAXN], df[TOT][MAXN][MAXN];
char s[MAXN][MAXN];

int r , c , t , m , f, n;
int id_in[MAXN][MAXN], id_out[MAXN][MAXN];
int it;
bool solve( ll LIMIT )
{
	memset( last , -1 , sizeof last);
	E = 0;
	source = 0;
	sink = it + f;

	for( int i = 1; i <= m; i++ )
		add_edge(source , i , 1);

	for( int rr = 1; rr <= r; rr++ )
		for( int cc = 1; cc <= c; cc++ )
			add_edge(id_in[rr][cc], id_out[rr][cc], 1);

	for( int i = 1; i <= m; i++ )
	{
		for( int rr = 1; rr <= r; rr++ )
		for( int cc = 1; cc <= c; cc++ )
			if(dm[i][rr][cc] != -1 && dm[i][rr][cc] <= LIMIT)
					add_edge( i , id_in[rr][cc], 1);
	}

	for( int i = it; i < it + f; i++ )
		add_edge(i , sink , 1);

	for( int i = it; i < it + f; i++ )
	{
		int pos = i - it + 1;
		for( int rr = 1; rr <= r; rr++ )
			for( int cc = 1; cc <= c; cc++ )
				if(df[pos][rr][cc] != -1 && df[pos][rr][cc] <= LIMIT)
					add_edge(id_out[rr][cc] , i , 1);
	}

	int mf = max_flow();
	return mf == n;
}

bool mk[MAXN][MAXN];
int x[] = {0 , 0 , 1 , -1};
int y[] = {1 , -1 , 0 , 0};

bool isIn( int i , int j )
{
	return i >= 1 && i <= r && j >= 1 && j <= c;
}

int fx[TOT], fy[TOT], ft[TOT];
int mx[TOT], my[TOT], mt[TOT];
int sx, sy , st;

void bfs( int i , int j , int pos, ll d[][MAXN][MAXN] , bool fem)
{
	memset( mk, 0 , sizeof mk);
	mk[i][j] = true;
	d[pos][i][j] = 0;
	queue<pii> Q;
	Q.push(pii(i, j));

	while(!Q.empty())
	{
		pii top = Q.front();
		Q.pop();
		for( int i = 0; i < 4; i++)
		{
			int xx = top.first + x[i];
			int yy = top.second + y[i];
			if(isIn(xx , yy) && !mk[xx][yy] && s[xx][yy] != '#')
			{
				d[pos][xx][yy] = d[pos][top.first][top.second]+ (fem ? ft[pos] : mt[pos]);
				Q.push(pii(xx , yy));
				mk[xx][yy] = 1;
			}
		}
	}
}

int main()
{
	ios::sync_with_stdio( 0 );
	cin.tie( 0 );

	cin >> r >> c >> m >> f;

	for( int i = 1; i <= r; i++ )
		cin >> (s[i] + 1);


	cin >> sx >> sy >> st;

	for( int i = 1; i <= m; i++ )
		cin >> mx[i] >> my[i] >> mt[i];
	for( int i = 1; i <= f; i++ )
		cin >> fx[i] >> fy[i] >> ft[i];

	if(abs(f - m) != 1)
	{
		cout << -1 << endl;
		return 0;
	}
	n = (m + f + 1)/2;

	if(m < f)
		mx[m + 1] = sx, my[m+1] = sy, mt[m+1] = st, m++;
	else fx[f + 1] = sx, fy[f+1] = sy, ft[f+1] = st, f++;

	memset(dm , -1 , sizeof dm);
	memset(df , -1 , sizeof df);
	for( int i = 1; i <= m; i++ )
		bfs(mx[i], my[i], i, dm, false);

	for( int i = 1; i <= f; i++ )
		bfs(fx[i], fy[i], i, df, true);


	//for( int i = 1; i <= r; i++ )
		//OUT(df[3][i]+1, c);

	it = m + 1;
	for( int i = 1; i <= r; i++ )
		for( int j = 1; j <= c; j++ )
			id_in[i][j] = it++;
	for( int i = 1; i <= r; i++ )
		for( int j = 1; j <= c; j++ )
			id_out[i][j] = it++;

	//for( int i = 1; i <= r; i++ )
			//OUT(id[i]+1, c);

	ll inf = (ll)MAXN * MAXN * (1e9+10);
	ll lo = 0 ,  hi = inf;
	//DB(solve(2));

	while( lo < hi )
	{
		ll mid = (lo + hi) >> 1;
		if(solve( mid ))
			hi = mid;
		else lo = mid + 1;
	}
	
	lo = lo == inf ? -1 : lo;
	cout << lo << endl;
	return 0;
}