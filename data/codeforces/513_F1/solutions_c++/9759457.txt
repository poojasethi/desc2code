#include <cstdlib>
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <vector>
#include <set>
#include <map>
#include <cstring>

using namespace std;

typedef long long LL;
typedef unsigned long long ULL;

#define SIZE(x) (int((x).size()))
#define rep(i,l,r) for (int i=(l); i<=(r); i++)
#define repd(i,r,l) for (int i=(r); i>=(l); i--)
#define rept(i,c) for (typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)

#ifndef ONLINE_JUDGE
#define debug(x) { cerr<<#x<<" = "<<(x)<<endl; }
#else
#define debug(x) {}
#endif


#define maxn 2000

#define INF 1000000000

struct edge
{
        int id, wg, anti;
        edge() {}
        edge(int id, int wg, int anti): id(id), wg(wg), anti(anti) {}
};

vector<edge> e[maxn];

void addedge(int x, int y, int z)
{
        //cout<<x<<" "<<y<<" "<<z<<endl;
        e[x].push_back(edge(y,z,e[y].size()));
        e[y].push_back(edge(x,0,e[x].size()-1));
}

int source, sink, flow, augc, found;
int h[maxn], vh[maxn], cur[maxn];

void sap(int m)
{
        if (m==sink)
        {
                found=1; flow+=augc;
                return;
        }

        int augc2=augc;
        vector<edge>::iterator it=e[m].begin()+cur[m];
        while (it<e[m].end())
        {
                if (it->wg && h[m]==h[it->id]+1)
                {
                        cur[m]=it-e[m].begin();
                        augc=min(augc,it->wg);
                        sap(it->id);
                        if (found) break;
                        if (h[source]>=sink) return;
                        augc=augc2;
                }
                it++;
        }

        if (found)
        {
                it->wg-=augc;
                e[it->id][it->anti].wg+=augc;
        }
        else
        {
                int minh=sink-1, minhi=0;
                rept(it,e[m])
                        if (it->wg && h[it->id]<minh)
                        {
                                minh=h[it->id]; minhi=it-e[m].begin();
                        }
                vh[h[m]]--; if (vh[h[m]]==0) h[source]=sink;
                h[m]=minh+1;
                vh[h[m]]++;
                cur[m]=minhi;
        }
}

void networkflow()
{
        memset(h,0,sizeof h); 
        memset(vh,0,sizeof vh); vh[0]=sink;
        memset(cur,0,sizeof cur);
        while (h[source]<sink)
        {
                augc=0x7fffffff; found=0;
                sap(source);
        }
}

const int delx[4]={0,0,-1,1};
const int dely[4]={-1,1,0,0};

int mr[maxn], mc[maxn], mt[maxn], fr[maxn], fc[maxn], ft[maxn], gx[maxn], gy[maxn];
int used[25][25], dis[25][25][25][25], num[25][25];
pair<int,int> q[maxn];
char g[30][30];

void lemon()
{
	int n,m,male,female; scanf("%d%d%d%d",&n,&m,&male,&female);
	int all=0;
	rep(i,1,n) scanf("%s",g[i]+1);
	rep(i,1,n)
		rep(j,1,m)
			if (g[i][j]=='.')
			{
				rep(k,1,n) rep(l,1,m) dis[i][j][k][l]=INF;
				dis[i][j][i][j]=0;
				all++; num[i][j]=all; gx[all]=i; gy[all]=j;
				int head=1, tail=2; q[head]=make_pair(i,j);
				rep(k,1,n) rep(l,1,m) used[k][l]=-1; used[i][j]=0;
				while (head<tail)
				{
					int x=q[head].first, y=q[head].second; head++;
					rep(dir,0,3)
					{
						int nx=x+delx[dir], ny=y+dely[dir];
						if (1<=nx && nx<=n && 1<=ny && ny<=m && g[nx][ny]=='.' && used[nx][ny]==-1)
						{
							used[nx][ny]=used[x][y]+1;
							dis[i][j][nx][ny]=used[nx][ny];
							q[tail]=make_pair(nx,ny); tail++;
						}
					}
				}
			}
		
	int kr,kc,kt;
	scanf("%d%d%d",&kr,&kc,&kt);
	rep(i,1,male) scanf("%d%d%d",&mr[i],&mc[i],&mt[i]);
	rep(i,1,female) scanf("%d%d%d",&fr[i],&fc[i],&ft[i]);
	if (abs(male-female)!=1)
	{
		printf("-1\n");
		return;
	}
	if (male<female) 
	{
		male=female;
		mr[male]=kr; mc[male]=kc; mt[male]=kt;
	}
	else
	{
		female=male;
		fr[male]=kr; fc[male]=kc; ft[male]=kt;
	}
	
	source=male+all+all+female+1, sink=male+all+all+female+2;
	rep(i,1,male) addedge(source,i,1);
	rep(i,male+all+all+1,male+all+all+female) addedge(i,sink,1);
	rep(i,male+1,male+all) addedge(i,i+all,1);
	
	map<LL, vector< pair<int,int> > > e;
	rep(i,1,male)
		rep(j,1,all)
			if (dis[mr[i]][mc[i]][gx[j]][gy[j]]!=INF)
				e[LL(mt[i])*dis[mr[i]][mc[i]][gx[j]][gy[j]]].push_back(make_pair(i,male+j));
	
	rep(j,1,all)
		rep(i,1,male)
			if (dis[fr[i]][fc[i]][gx[j]][gy[j]]!=INF)
				e[LL(ft[i])*dis[fr[i]][fc[i]][gx[j]][gy[j]]].push_back(make_pair(male+all+j,male+all+all+i));
			
	flow=0;
	rept(it,e)
	{
		rept(itz,it->second)
		{
			//cout<<it->first<<" "<<itz->first<<" "<<itz->second<<endl;
			addedge(itz->first,itz->second,1);
		}
		
		networkflow();
		if (flow==male)
		{
			cout<<it->first<<endl;
			return;
		}
	}
	printf("-1\n");
}

int main()
{
	ios::sync_with_stdio(true);
	#ifndef ONLINE_JUDGE
		freopen("F.in","r",stdin);
	#endif
	lemon();
	return 0;
}

