#include <bits/stdc++.h>
using namespace std;
#define rep(i,a,n) for (int i=a;i<n;i++)
#define per(i,a,n) for (int i=n-1;i>=a;i--)
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define SZ(x) ((int)(x).size())
#define fi first
#define se second
typedef vector<int> VI;
typedef long long ll;
typedef pair<int,int> PII;
const ll mod=1000000007;
ll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
// head

const int N=601000;
struct node {
	node *go[30],*p;
	vector<node*> son;
	int val,cnt[11];
}pool[N],*cur=pool,*rt;
char s[N],t[N];
int n,l[20],r[20];

node* newnode() {
	node *p=cur++;
	return p;
}
node *append(node *p,int w) {
	node *np=newnode();np->val=p->val+1;
	for (;p&&!p->go[w];p=p->p) p->go[w]=np;
	if (!p) np->p=rt;
	else {
		node *q=p->go[w];
		if (q->val==p->val+1) np->p=q;
		else {
			node *nq=newnode();
			nq->val=p->val+1;
			memcpy(nq->go,q->go,sizeof(q->go));
			nq->p=q->p;
			np->p=q->p=nq;
			for (;p&&p->go[w]==q;p=p->p) p->go[w]=nq;
		}
	}
	return np;
}
void init(int c,char *s) {
	node *np=rt;
	int l=strlen(s);
	if (c!=0) s[l]='a'+26; else --l;
	per(i,0,l+1) {
		np=append(np,s[i]-'a');
		np->cnt[c]++;
	}
}

ll ans;

void dfs(node *p,int sl) {
	int sr=p->val;
	rep(i,0,SZ(p->son)) {
		dfs(p->son[i],sr+1);
		rep(j,0,n+1) p->cnt[j]+=p->son[i]->cnt[j];
	}
	bool fg=1;
	rep(j,0,n+1) fg&=(p->cnt[j]>=l[j]&&p->cnt[j]<=r[j]);
	if (p!=rt) ans+=fg*(sr-sl+1);
}
int main() {
	cur=pool;
	rt=newnode();
	scanf("%s",t);
	scanf("%d",&n);
	rep(i,1,n+1) {
		scanf("%s%d%d",s,l+i,r+i);
		init(i,s);
	}
	init(0,t);
	l[0]=1,r[0]=0x20202020;
	for (node *p=pool;p!=cur;p++) if (p->p) p->p->son.pb(p);
	dfs(rt,0);
	printf("%I64d\n",ans);
}