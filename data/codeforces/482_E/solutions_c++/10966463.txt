#include <cstdio>
#include <vector>
#include <cstring>
#include <functional>
#include <algorithm>
#include <math.h>
#include <bitset>
#include <set>
#include <queue>
#include <assert.h>
#include <iostream>
#include <string>
#include <sstream>
#include <stack>
#include <complex>
#include <numeric>
#include <map>
#include <time.h>
using namespace std;
typedef long double ld;
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int uint;
typedef pair<int,int> pii;
typedef pair<int,ll> pil;
typedef pair<int,ull> piu;
typedef pair<ll,int> pli;
typedef pair<ll,ll> pll;
typedef pair<pii,ll> ppl;
typedef pair<ll,pii> plp;
typedef pair<int,pii> pip;
typedef pair<pii,int> ppi;
typedef pair<pii,pii> ppp;
typedef pair<double,int> pdi;
typedef pair<int,double> pid;
typedef pair<double,pii> pdp;
typedef pair<double,double> pdd;
typedef pair<pdd,double> pd3;
typedef vector<int> vec;
typedef vector<vec> mat;
#define rep(i,n) for (int (i) = 0; (i) < (n); (i)++)
#define repn(i,a,n) for (int (i) = (a); (i) < (n); (i)++)
#define ALL(x) (x).begin(),(x).end()
#define pb push_back
#define SORT(x) sort((x).begin(),(x).end())
#define SORTN(x,n) sort((x),(x)+(n))
#define ERASE(x) (x).erase(unique((x).begin(),(x).end()),(x).end())
#define COUNT(x,c) count((x).begin(),(x).end(),(c))
#define REMOVE(x,c) (x).erase(remove((x).begin(),(x).end(),(c)),(x).end())
#define REVERSE(x) reverse((x).begin(),(x).end())
#define FORIT(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)
#define LB(x,a) lower_bound((x).begin(),(x).end(),(a))-(x).begin()
#define lb(x,a) lower_bound((x).begin(),(x).end(),(a))
#define LBN(x,a,n) lower_bound((x),(x)+(n),(a))-(x)
#define lbN(x,a,n) lower_bound((x),(x)+(n),(a))
#define UB(x,a) upper_bound((x).begin(),(x).end(),(a))-(x).begin()
#define ub(x,a) upper_bound((x).begin(),(x).end(),(a))
#define BS(x,a) binary_search((x).begin(),(x).end(),(a))
#define BS2(x,n,a) binary_search((x),(x)+(n),(a))
#define NB(x) (((x)&~((x)+((x)&-(x))))/((x)&-(x))>>1)|((x)+((x)&-(x)))
#define NP(x) next_permutation((x).begin(),(x).end())
#define MM(x,p) memset((x),(p),sizeof(x))
#define SQ(x) (x)*(x)
#define SC(c1,c2) strcmp(c1,c2)==0
#define mp make_pair
#define INF (1<<28)
#define INFL (1LL<<61)
#define fi first
#define se second
#define MOD 1000000009
#define EPS 1e-7
#define MIN(x,a) x=min(x,a)
#define MAX(x,a) x=max(x,a)
#define madd(x,a) x=(x+a)%MOD
#define msub(x,a) x=(x+MOD-a)%MOD
#define OUTPUT(x) rep(i,x.size())printf("%d%c",x[i],i+1==x.size()?'\n':' ');

int N,Q;
int P[50000];
int V[50000];
char type[50000];
int A[50000];
int B[50000];
const int SZ=220;


bool fl[50000];
vector<int> G[50000];
int t_sz[50000];
int t_par[50000];
int id[50000];
int b_sz[50000];

int par[50000];
int sz[50000];
int rr[50000];
int idptr=0;
ll fs[50000];
ll scd[50000];
ll b_sc[50000];
int b_sz_t[50000];

ll res;

bool select(int v,int p)
{
    int cc=0;
    int ver=0;
    rep(i,G[v].size())if(G[v][i]!=p)cc+=select(G[v][i],v);
    if(cc>=2)fl[v]=true;
    if(fl[v])rep(i,G[v].size())if(G[v][i]!=p)fl[G[v][i]]=true;
    if(fl[v]||cc>=1)return true;
    return false;
}
int calc_sum(int v,int p)
{
    int tsz=1;
    ll sc=1;
    rep(i,G[v].size())if(G[v][i]!=p)
    {
        int tmp=calc_sum(G[v][i],v);
        sc+=ll(tsz)*tmp;
        tsz+=tmp;
    }
    t_sz[v]=tsz;
    t_par[v]=p;
    res+=sc*V[v];
    scd[v]=sc;
    
    return tsz;
}

int b_dfs(int v)
{
    int res=1;
    rep(i,G[v].size())if(G[v][i]!=t_par[v]&&!fl[G[v][i]])res+=b_dfs(G[v][i]);
    return b_sz[v]=res;
}

void construct(int l,int r)
{
    r=min(r,Q);
    MM(fl,0);
    rep(i,N)G[i].clear();
    rep(i,N)if(P[i]!=-1)G[P[i]].pb(i);
    repn(i,l,r)
    {
        if(type[i]=='P')fl[A[i]]=fl[B[i]]=true;
        else fl[A[i]]=true;
    }
    int root;
    rep(i,N)if(P[i]==-1)root=i,fl[i]=true,select(i,-1);
    queue<pii> q;
    q.push(mp(root,-1));
    
    res=0;
    calc_sum(root,-1);
    
    rep(v,N)if(fl[v])b_dfs(v);
    
    MM(id,-1);MM(sz,0);MM(par,-1);MM(fs,0);
    idptr=0;
    
    while(!q.empty())
    {
        int v=q.front().fi,p=q.front().se;q.pop();
        queue<pii> q2;
        int x=idptr++;
        rr[x]=v;
        b_sc[x]=scd[v];
        b_sz_t[x]=t_sz[v];
        if(p!=-1)par[x]=id[p];
        q2.push(mp(v,p));
        while(!q2.empty())
        {
            int vv=q2.front().fi,pp=q2.front().se;q2.pop();
            id[vv]=x;
            sz[x]++;
            rep(i,G[vv].size())if(G[vv][i]!=pp)
            {
                if(fl[G[vv][i]])q.push(mp(G[vv][i],vv));
                else q2.push(mp(G[vv][i],vv));
            }
        }
        int ls=0;
        while(p!=-1)
        {
            fs[x]+=ll(V[p])*(b_sz[p]-ls);
            if(fl[p])break;
            ls=b_sz[p];
            p=t_par[p];
        }
        
    }
}
bool p_c(int a,int b)
{
    while(b!=-1)
    {
        if(a==b)return true;
        b=par[b];
    }
    return false;
}
ll my_sum=0,ha;
ll getfs(int v)
{
    int p=par[v];
    if(p==-1)return 0LL;
    if(sz[p]==1)return V[rr[p]];
    return fs[v];
}
void sz_upd(int v,int s,bool f=false)
{
    int p=par[v];
    
    if(p==-1)
    {
        b_sz_t[v]+=s;
        return;
    }
    res+=ll(s)*getfs(v);
    b_sc[p]+=s;
    
    int other=b_sz_t[p]-sz[p]-b_sz_t[v];
    
    res-=ll(other)*b_sz_t[v]*getfs(v);
    b_sc[p]-=ll(other)*b_sz_t[v];
    b_sz_t[v]+=s;
    res+=(other)*b_sz_t[v]*getfs(v);
    b_sc[p]+=ll(other)*b_sz_t[v];
    sz_upd(p,s,true);
}

int main()
{
    scanf("%d",&N);
    P[0]=-1;
    repn(i,1,N)scanf("%d",&P[i]),P[i]--;
    rep(i,N)scanf("%d",&V[i]),my_sum+=V[i];
    scanf("%d",&Q);
    ha=ll(N)*N;
    rep(i,Q)
    {
        scanf(" %c%d%d",&type[i],&A[i],&B[i]);
        if(type[i]=='P')A[i]--,B[i]--;
        else A[i]--;
    }
    rep(i,Q)
    {
        if(i%SZ==0)construct(i,i+SZ);
        if(i==0)printf("%.12f\n",double(res*2-my_sum)/ha);
        
        if(type[i]=='P')
        {
            int a=A[i],b=B[i];
            a=id[a],b=id[b];
            if(p_c(a,b))swap(a,b),swap(A[i],B[i]);
            
            int tt=b_sz_t[a];
            
            sz_upd(a,-tt);
            fs[a]=V[B[i]];
            
            
            par[a]=b;
            P[A[i]]=B[i];
            sz_upd(a,tt);
            
            
        }
        else
        {
            int a=id[A[i]];
            my_sum-=V[A[i]];
            res-=b_sc[a]*V[A[i]];
            V[A[i]]=B[i];
            my_sum+=V[A[i]];
            res+=b_sc[a]*V[A[i]];
        }
        printf("%.12f\n",double(res*2-my_sum)/ha);
    }
}