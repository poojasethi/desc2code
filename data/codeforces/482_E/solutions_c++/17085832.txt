#include <cstdio>
#include <algorithm>

using namespace std;

#define N 100005
#define max(a, b) ((a) > (b) ? (a) : (b))

typedef __int64 LL;

template <class T>
inline void chkmax(T &a, T b) { if (a < b) a = b; }

//////////// begin Link / Cut Tree ////////////
int pa[N], son[N][2];
int val[N], cnt[N];
LL pairs[N], cntS[N], tot[N], add[N], rlt;

void init_LCT(int n) {
	for (int i = 0; i <= n; i ++) {
		add[i] = 0;
		pa[i] = son[i][0] = son[i][1] = 0;
	}
	val[0] = cnt[0] = 0;
	pairs[0] = cntS[0] = tot[0] = 0;
}

void push_up(int x) {
	cntS[x] = cntS[son[x][0]] + cnt[x] + cntS[son[x][1]];
	tot[x] = tot[son[x][0]] + (LL)cnt[x] * val[x] + tot[son[x][1]];
}

void add_delta(int x, LL v) {
	if (x) {
		add[x] += v;
		pairs[x] += cnt[x] * v;
	}
}

void push_down(int x) {
	if (add[x]) {
		add_delta(son[x][0], add[x]);
		add_delta(son[x][1], add[x]);
		add[x] = 0;
	}
}

bool isroot(int x) { return son[pa[x]][0] != x && son[pa[x]][1] != x; }

bool down(int x) {
	if (!isroot(x)) down(pa[x]);
	push_down(x);
}

void rot(int x, int d) {
	int y = pa[x], z = pa[y];
	son[y][!d] = son[x][d];
	pa[son[x][d]] = y;
	pa[x] = pa[y];
	if (son[z][0] == y) son[z][0] = x;
	else if (son[z][1] == y) son[z][1] = x;
	pa[y] = x, son[x][d] = y;
	push_up(y);
}

void splay(int x) {
	down(x);
	while (!isroot(x)) {
		if (isroot(pa[x])) rot(x, son[pa[x]][0] == x);
		else {
			int y = pa[x], z = pa[y];
			int d = (son[z][0] == y);
			son[y][d] == x ? rot(x, !d) : rot(y, d);
			rot(x, d);
		}
	}
	push_up(x);
}

void access(int x) {
	for (int y = 0; x; x = pa[x]) {
		splay(x);
		if (son[x][1]) cnt[x] += cntS[son[x][1]];
		if (son[x][1] = y) cnt[x] -= cntS[y];
		push_up(y = x);
	}
}

int GetPa(int y) {
	splay(y);
	if (!son[y][0]) return pa[y];
	for (y = son[y][0]; son[y][1]; y = son[y][1]);
	return y;
}

void modify1(int x, int y) {
	access(x), splay(y);
	if (!pa[y]) swap(x, y);
	int p = GetPa(y);
	if (x == p) return;

	access(p), splay(p);
	cnt[p] -= cntS[y], push_up(p);
	rlt -= 2 * tot[p] * cntS[y];
	add_delta(p, -2 * cntS[y]);

	access(x), splay(x);
	rlt += 2 * tot[x] * cntS[y];
	add_delta(x, 2 * cntS[y]);
	cnt[x] += cntS[y], push_up(x);

	pa[y] = x;
}

void modify2(int x, int y) {
	splay(x);
	rlt += (y - val[x]) * pairs[x];
	val[x] = y;
	push_up(x);
}
///////////// end Link / Cut Tree /////////////

int head[N];
int to[N], nxt[N];

void AddEdge(int a, int b, int i) {
	to[i] = b;
	nxt[i] = head[a];
	head[a] = i;
}

void DFS(int u) {
	cnt[u] = pairs[u] = 1;
	for (int i = head[u]; i; i = nxt[i]) {
		int v = to[i];
		if (v == pa[u]) continue;
		DFS(v);
		pairs[u] += 2LL * cnt[u] * cnt[v];
		cnt[u] += cnt[v];
	}
	rlt += pairs[u] * val[u];
	push_up(u);
}

main() {
	int n, q;
	scanf("%d", &n);
	for (int i = 2; i <= n; i ++) {
		scanf("%d", pa + i);
		AddEdge(pa[i], i, i);
	}
	for (int i = 1; i <= n; i ++) scanf("%d", val + i);
	DFS(1);
	printf("%.9lf\n", 1.0 * rlt / n / n);
	for (scanf("%d", &q); q --; ) {
		char s[5];
		int x, y;
		scanf("%s %d %d", s, &x, &y);
		if (s[0] == 'P') modify1(y, x);
		else modify2(x, y);
		printf("%.9lf\n", 1.0 * rlt / n / n);
	}
}
