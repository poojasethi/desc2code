#include <bits/stdc++.h>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <cmath>
#include <climits>
#include <algorithm>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <cassert>
#include <vector>
#define all(x) x.begin() , x.end()
#define fi first
#define se second
#define pb push_back
#define umax( x , y ) x = max( x , (y) )
#define umin( x , y ) x = min( x , (y) )
#define For( i , a ) for(int i=1;i<=a;i++)
#define ort (b+s)/2
#define y2 asrwjaelkf
#define pa() printf("asdasd\n");
#define y1 asseopirwjaelkf

using namespace std;

typedef long long Lint;
typedef long double db;
typedef pair<int,int> ii;
typedef pair<int,ii> iii;

const int maxn = 50020;
const int maxk = 460;
const int maxx = 300000;
const int K = 250;

int a, q;
int ar[maxn], sz[maxn];
int dad[maxn], par[maxn], s[maxn];
Lint p[maxn], ch[maxn], ans;
bool ex[maxn];
vector<int> w[maxn], g[maxn];

int dfs2( int n ) {
	int c = 0, h = 0, h2 = 0;
	if( ex[n] ) c = 1;
	for(int i=0;i<w[n].size();i++) {
		int t = dfs2( w[n][i] );
		if( t ) {
			if( c ) {
				g[n].pb( t ); par[t] = n; ex[n] = 1; s[t] = sz[w[n][i]] - sz[t]; //printf("asd %d -----> %d\n",n,t);
			} else {
				c = 1;
				h = t;
				h2 = w[n][i];
				//~ s[h] = sz[w[n][i]] - sz[h];
			}
		}
	}
	if( ex[n] && h ) g[n].pb( h ), par[h] = n, s[h] = sz[h2] - sz[h];//,printf("asd2 %d -----> %d\n",n,h);
	if( ex[n] ) return n;
	return h;
}

void dfs( int n, Lint s, int h ) {
	if( !h ) {
		sz[n] = 1;
		for(int i=0;i<w[n].size();i++) {
			dfs( w[n][i], s, 0 );
			sz[n] += sz[w[n][i]];
		}
	} else {
		p[n] = s;
		Lint h = 0;
		if( ex[n] ) h = ch[n]; 
		ch[n] = sz[n];
		for(int i=0;i<w[n].size();i++) {
			ch[n] += 1ll * sz[w[n][i]] * (sz[n] - sz[w[n][i]]);
			dfs( w[n][i], s + 1ll * ar[n] * (sz[n] - sz[w[n][i]]), 1 );
		}
		//~ if( ex[n] && h != ch[n] ) printf("WTF??? %d %d (%d)\n",h,ch[n],n);
		//~ printf("asd %d %lld %lld %lld\n",n,ch[n],ans,s);
		ans += 1ll * ch[n] * (Lint)ar[n];
	}
}

bool look( int n, int x ) {
	if( !n ) return 0;
	if( n == x ) return 1;
	return look( par[n], x );
}

void inc( int n, Lint s ) {
	p[n] += s;
	//~ printf("-- %d %d\n",n,s);
	for(int i=0;i<g[n].size();i++) inc( g[n][i], s );
}

int main() {
	
	//~ freopen("asd.in","r",stdin);
	
	scanf("%d",&a);
	
	for(int i=2;i<=a;i++) {
		scanf("%d",&dad[i]);
		w[dad[i]].pb( i );
	}
	for(int i=1;i<=a;i++) scanf("%d",&ar[i]);
	
	dfs( 1, 0, 0 );
	dfs( 1, 0, 1 );
	
	scanf("%d",&q);
	
	vector<iii> v;
	printf("%.12lf\n",ans/(1.0*a*a));
	//~ printf("asd %d\n",p[24]);
	while( q-- ) {
		char c;
		int x, y;
		scanf(" %c %d %d",&c,&x,&y);
		if( c == 'P' ) {
			v.pb( iii( 1, ii( x, y ) ) );
			ex[x] = ex[y] = 1;
		} else {
			ex[x] = 1;
			v.pb( iii( 0, ii( x, y ) ) );
		}
		if( q % K == 0 ) {
			for(int i=1;i<=a;i++) g[i].clear(), par[i] = s[i] = 0;
			//~ ans = 0;
			int root = dfs2( 1 );
			//~ for(int i=1;i<=a;i++) if( ex[i] ) printf("asd %d %d\n",i,par[i]);
			for(int i=0;i<v.size();i++) {
				int x = v[i].se.fi;
				int y = v[i].se.se;
				if( v[i].fi == 1 ) {
					if( look( y, x ) ) swap( x, y );
					//~ printf("asd x=%d, y=%d, sz[x] = %d, sz[y] = %d, p[x] = %d,  %d -- %d\n",x,y,sz[x],sz[y],p[x],ch[11],ch[1]);
					//~ for(int k=1;k<=a;k++) for(int j=0;j<g[k].size();j++) printf("asd asd %d --> %d\n",k,g[k][j]);
					int c = x;
					Lint h = p[y];
					ans -= 1ll * p[x] * sz[x] * 2;
					while( par[c] ) {
						//~ printf("asd %d(%d) --- %d %d %d\n",par[c],c,1ll * sz[x], sz[par[c]],sz[c]+s[c]);
						ch[par[c]] -= 1ll * sz[x] * (sz[par[c]]-sz[c]-s[c]) * 2;
						for(int j=0;j<g[par[c]].size();j++)
							if( g[par[c]][j] != c ) inc( g[par[c]][j], -1ll * sz[x] * ar[par[c]] );
						if( c != x ) sz[c] -= sz[x];
						c = par[c];
						//~ if( c ) sz[c] -= sz[x], printf("%d\n",c);
					}
					sz[c] -= sz[x];
					//~ printf("--------- %d\n",sz[3]);
					c = y;
					ans += 1ll * (p[y]+1ll*sz[y]*ar[y]) * sz[x] * 2;
					for(int j=0;j<g[par[x]].size();j++)
						if( g[par[x]][j] == x ) {
							swap( g[par[x]][j], g[par[x]][g[par[x]].size()-1] );
							g[par[x]].pop_back();
							break;
						}
					
					//~ assert( h == p[x] );
					//~ printf("p2[y] = %d h=%d, %d %d\n",p[x],h,ar[x],sz[y]);
					inc( x, p[y]+1ll*sz[y]*ar[y]-p[x] );
					ch[y] += 1ll * sz[x] * sz[y] * 2;
					for(int j=0;j<g[y].size();j++)
						inc( g[y][j], 1ll * sz[x] * ar[y] );
					while( c ) {
						if( par[c] ) {
							//~ if( par[c] == x ) printf("asd2\n");
							//~ printf("asd2 %d(%d) --- %d %d - %d\n",par[c],c,1ll * sz[x], sz[par[c]],sz[c]+s[c]);
							ch[par[c]] += 1ll * sz[x] * (sz[par[c]]-sz[c]-s[c]) * 2;
							for(int j=0;j<g[par[c]].size();j++)
								if( g[par[c]][j] != c ) inc( g[par[c]][j], 1ll * sz[x] * ar[par[c]] );
						}
						sz[c] += sz[x];
						c = par[c];
					}
					s[x] = 0;
						//~ printf("-- %d\n",p[4]);
					g[y].pb( x );
					par[x] = y;
					dad[x] = y;
				} else {
					int d = y - ar[x];
					ar[x] = y;
					for(int j=0;j<g[x].size();j++) {
						inc( g[x][j], 1ll * d * (sz[x]-sz[g[x][j]]-s[g[x][j]]) );
						//~ printf("updated %d -- %d\n",g[x][j],d * (sz[x]-sz[g[x][j]]));;
					}
					//~ printf("%d\n",ch[x]);
					ans += 1ll * d * ch[x];
				}
				//~ printf("%d ",ans);
				printf("%.12lf\n",ans/(1.0*a*a));
			}
			for(int i=1;i<=a;i++) {
				//~ if( ex[i] ) {
					//~ printf("asd %d %d %d\n",i,par[i],dad[i]);
					//~ dad[i] = par[i];
				//~ }
				w[i].clear();
			}
			for(int i=2;i<=a;i++) w[dad[i]].pb( i );
			ans = 0;
			dfs( 1, 0, 0 );
			dfs( 1, 0, 1 );
			//~ printf("------------------------------------------- rebuild %.12lf %d\n",ans/(1.0*a*a),root);
			v.clear();
			memset( ex, 0, sizeof( ex ) );
		}
	}
	
	return 0;
}
