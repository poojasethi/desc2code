#include <cstdio>
#include <cstring>
#include <vector>
#include <iostream>
#include <algorithm>
#include <cassert>
#include <iomanip>

using namespace std;

#define forn(i,n) for (int i = 0; i < int(n); ++i)
#define sz(a) int(a.size())
#define pb push_back
#define all(a) a.begin(),a.end()
#define mp make_pair

typedef long long li;
typedef long double ld;

typedef pair<int,int> pt;
#define ft first
#define sc second

const int N = 100105;

li n2;
int n, m;
int p[N], V[N];

pair <char, pt> req[N];
vector <int> g[N];
bool marked[N], query[N];

int szv;
int v[N];

int dfs(int v) {
	int res = query[v];

	for (int i = 0; i < sz(g[v]); ++i) {
		int cur = dfs(g[v][i]);
		if (cur && res)
			marked[v] = true;
		res += cur;
	}

	return res;
}

inline void get_lcas() {
	int szq = 0;

	forn(i, n) {
		marked[i] = query[i];
		szq += query[i];
	}

	dfs(0);

	szv = 0;
	forn(i, n)
		if (marked[i])
			v[szv++] = i;

	assert(szq * 2 - 1 >= szv);
}

inline bool read() {
	if (scanf("%d", &n) != 1)
		return false;
	n2 = li(n) * n;

	forn(i, n - 1) {
		scanf("%d", &p[i + 1]);
		p[i + 1]--;
	}

	forn(i, n)
		scanf("%d", &V[i]);
	
	scanf("%d", &m);
	char buf[2];
	int a, b;

	forn(i, m) {
		scanf("%s %d %d", buf, &a, &b);
		req[i] = mp(buf[0], mp(a, b));
	}

	return true;
}

int tin[N], tout[N], T;

inline bool is_ancestor(int a, int b) {
	return tin[a] <= tin[b] && tout[b] <= tout[a];
}

li sum, path[N], ch[N];
int sz[N];

void calcsz(int v) {
	tin[v] = T++;
	sz[v] = 1;
	ch[v] = 0;

	forn(i, sz(g[v])) {
		int to = g[v][i];
		calcsz(to);
		ch[v] += li(sz[v]) * sz[to];
		sum += 2 * li(sz[v]) * sz[to] * V[v];
		sz[v] += sz[to];
	}

	tout[v] = T++;
}

void calcpath(int v, int p) {
	if (v != p)
		path[v] = path[p] + li(sz[p] - sz[v]) * V[p];
	else
		path[v] = 0;

	forn(i, sz(g[v]))
		calcpath(g[v][i], v);
}

inline void rebuild() {
	sum = 0;
	forn(i, n)
		sum += V[i];

	T = 0;
	forn(i, n) {
		tin[i] = tout[i] = -1;
		g[i].clear();
	}

	forn(i, n - 1)
		g[ p[i + 1] ].pb(i + 1);

	calcsz(0);
	calcpath(0, 0);
}

vector <int> G[N];
int P[N], C[N];

int d[N];

int szsons;
pt sons[N];

inline void calcps() {
	forn(i, szv) {
		G[ v[i] ].clear();
		P[ v[i] ] = -1;
		C[ v[i] ] = 0;
	}

	forn(i, szv)
		d[i] = 0;

	forn(i, szv)
		forn(j, szv)
			if (i != j && is_ancestor(v[i], v[j]))
				d[j]++;

	forn(_, szv) {
		int i = -1;

		forn(j, szv)
			if (d[j] == 0)
				i = j;

		d[i] = -1;

		assert(i != -1);

		forn(j, szv)
			if (i != j && is_ancestor(v[i], v[j])) {
				if (d[j] == 1) {
					P[ v[j] ] = v[i];
					G[ v[i] ].pb(v[j]);
				}
				d[j]--;
			}

		szsons = sz(G[ v[i] ]);
		forn(j, sz(G[ v[i] ])) {
			int to = G[ v[i] ][j];
			sons[j] = mp(tin[to], to);
		}

		sort(sons, sons + szsons);

		int pos = 0;
		forn(j, sz(g[ v[i] ])) {
			int to = g[ v[i] ][j];
			while (pos < szsons && is_ancestor(to, sons[pos].sc))
				C[ sons[pos++].sc ] = sz[to];
		}
	}
}

void dfspath(int v, li delta) {
	path[v] += delta;
	forn(i, sz(G[v]))
		dfspath(G[v][i], delta);
}

inline void updpath(int v, int mul) {
	int cur = v;
	while (P[cur] != -1) {
		li delta = mul * li(sz[v]) * V[ P[cur] ];
		forn(i, sz(G[ P[cur] ])) {
			int to = G[ P[cur] ][i];
			if (to != cur)
				dfspath(to, delta);
		}

		int c = C[cur];
		if (cur != v)
			C[cur] += mul * sz[v];

		cur = P[cur];
		ch[cur] += mul * li(sz[v]) * (sz[cur] - c);
		sz[cur] += mul * sz[v];
	}
}

bool visit(int v, int what) {
	int cur = what;
	while (cur != -1) {
		if (cur == v)
			return true;
		cur = P[cur];
	}
	return false;
}

inline void output() {
	//cerr << sum << " ";
	printf("%0.9lf\n", double(sum) / double(n2));
}

inline void solve() {
	int bl = 0;
	while (bl * bl < m)
		bl++;

	rebuild();
	output();

	for (int left = 0; left < m; left += bl) {
		rebuild();

		forn(i, n)
			query[i] = false;

		forn(offs, bl) {
			int i = left + offs;
			if (i >= m)
				break;
			query[req[i].sc.ft - 1] = true;
			if (req[i].ft == 'P')
				query[req[i].sc.sc - 1] = true;
		}

		get_lcas();
		calcps();

		forn(offs, bl) {
			int i = left + offs;
			if (i >= m)
				break;

			if (req[i].ft == 'P') {
				int v = req[i].sc.ft, u = req[i].sc.sc;
				--v, --u;

				if (visit(v, u))
					swap(v, u);

				sum -= 2 * path[v] * sz[v];
				updpath(v, -1);
				C[v] = 0;

				dfspath(v, -path[v]);
				G[ P[v] ].erase(find(all(G[ P[v] ]), v));

				P[v] = u;
				p[v] = u;

				dfspath(v, path[u] + li(sz[u]) * V[u]);
				G[ P[v] ].pb(v);
			
				sum += 2 * path[v] * sz[v];
				updpath(v, +1);
				C[v] = sz[v];
			}

			if (req[i].ft == 'V') {
				int v = req[i].sc.ft, val = req[i].sc.sc;
				--v;

				int dv = val - V[v];
				sum += 2 * ch[v] * dv + dv;

				forn(i, sz(G[v])) {
					int& to = G[v][i];
					dfspath(to, li(dv) * (sz[v] - C[to]));
				}

				V[v] = val;
			}

			output();
		}
	}
}

int main() {
	read();
	solve();
	return 0;
}