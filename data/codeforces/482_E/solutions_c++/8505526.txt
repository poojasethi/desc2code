#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <map>
#include <set>
#include <vector>
#include <string>
#include <queue>
using namespace std;
#define out(v) cerr << #v << ": " << (v) << endl
#define sz(v) ((int)(v).size())
#define pb push_back
#define clr(x,a) memset(x,a,sizeof(x))
const int maxint = -1u>>1;
template <class T> bool get_max(T& a, const T &b) {return b > a? a = b, 1: 0;}
template <class T> bool get_min(T& a, const T &b) {return b < a? a = b, 1: 0;}


struct node
{
    int rev;
    long long add, val, remaind, size, pairs, sum;
    node *a[2], *fa;
    bool isroot()
    {
        return fa->a[0] != this && fa->a[1] != this;
    }
    void set(node *t, int p);
    void doRev();
    void doAdd(int add);
    int dir()
    {
        return this == fa->a[1];
    }
    node *get_fa();
    void pushdown();
    void update();
    void update1();
}*stack[222222], tree[222222], nulldata, *null = &nulldata;
void node :: doRev()
{
    if(this == null)
        return ;
    swap(a[0], a[1]);
    rev ^= 1;
}
void node :: doAdd(int k)
{
    if(this == null)
        return ;
    size += k;
    pairs += remaind * k * 2;
    add += k;
}
void node :: pushdown()
{
    if(this == null)
        return ;
    if(rev)
    {
        a[0]->doRev();
        a[1]->doRev();
        rev = 0;
    }
    if(add != 0)
    {
        a[0]->doAdd(add);
        a[1]->doAdd(add);
        add = 0;   
    }
}
void node :: update()
{
    if(this == null)
        return ;
    this->pushdown();
    a[0]->pushdown();
    a[1]->pushdown();
    sum = a[0]->sum + a[1]->sum + remaind * val;
}
void node :: set(node *t, int p)
{
    if(this != null)
        a[p] = t;
    if(t != null)
        t->fa = this;
}
node* node :: get_fa()
{
    if(a[0] == null)
        return fa;
    node *p = a[0];
    while(p->a[1] != null)
        p = p->a[1];
    return p;
}
int tot;
int pre[222222], son[222222], last[222222];
void add(int a, int b)
{
    tot++;
    son[tot] = b;
    pre[tot] = last[a];
    last[a] = tot;
}
struct Splay
{
    void rotate(node *t)
    {
        node *fa = t->fa;
        int p = t->dir();
        if(fa->fa->a[0] == fa) fa->fa->a[0] = t;
        else if(fa->fa->a[1] == fa) fa->fa->a[1] = t;
        t->fa = fa->fa;
        fa->set(t->a[!p], p);
        t->set(fa, !p);
        fa->update();
    }
    void splay(node *t, node *fa = null)
    {
        int top = 0;
        node *tmp = t;
        stack[++top] = tmp;
        while(!tmp->isroot())
            stack[++top] = tmp->fa, tmp = tmp->fa;
        for(int i = top; i >= 1; i--) 
            stack[i]->pushdown();
        while(!t->isroot())
        {
            if(t->fa->isroot()) rotate(t);
            else t->dir() == t->fa->dir() ? (rotate(t->fa), rotate(t)) : (rotate(t), rotate(t));
        }
        t->update();
    }
}*splay;
node* access(node *u)
{
    node *v;
    for(v = null; u != null; v = u, u = u->fa)
    {
        if(v != null)
        {
            while(v->a[0] != null) v = v->a[0];
            splay->splay(v);
        }
        splay->splay(u);
        u->remaind = u->size - v->size;
        u->a[1] = v;
        u->update();
    }
    return v;
}
node* lca(node *u, node *v)
{
    access(v);
    splay->splay(v);
    for(v = null; u != null; v = u, u = u->fa)
    {
        if(v != null)
        {
            while(v->a[0] != null) v = v->a[0];
            splay->splay(v);
        }
        splay->splay(u);
        if(u->fa == null)
            return u;
        u->remaind = u->size - v->size;
        u->a[1] = v;
        u->update();
    }
    return u;
}
void cut(int x, int y)
{
    node *u = &tree[x], *v = &tree[y];
    access(u);
    splay->splay(v);
    if(v->fa == u) v->fa = null;
    else 
    {
        access(v);
        splay->splay(u);
        u->fa = null;
    }
}
void makeroot(node *u)
{
    access(u);
    splay->splay(u);
    u->doRev();
}
void link(int x, int y)
{
    node *u = &tree[x], *v = &tree[y];
    makeroot(u);
    u->fa = v;
}
long long ans;
void dfs(int k)
{
    tree[k].size = 1;
    tree[k].pairs = 1;
    for(int x = last[k]; x; x = pre[x])
    {
        dfs(son[x]);
        tree[k].pairs += tree[k].size * tree[son[x]].size * 2;
        tree[k].size += tree[son[x]].size;
    }
    tree[k].remaind = tree[k].size;
    tree[k].update();
    ans += tree[k].pairs * tree[k].val;
    
}
void change(int x, int y)
{   
    node *u = &tree[x], *v = &tree[y];
    node *p = lca(u, v);
    if(p == v || (p != u && p != v))
    {
        swap(u, v);
        swap(x, y);
    }
    //access(u);
    //splay->splay(v);
    //if(v->fa == null)
        //swap(u, v), swap(x, y);
    node *fa = v->get_fa();
    access(fa);
    splay->splay(fa);
    fa->remaind -= v->size;
    fa->doAdd(-v->size);
    fa->update();
    ans -= fa->sum * v->size * 2;
    access(u);
    splay->splay(u);
    ans += u->sum * v->size * 2;
    u->doAdd(v->size);
    u->remaind += v->size;
    u->update();
    //v->fa = u;
    cut(y, fa-tree);
    link(y, x);
}
int main() {
    splay = new Splay;
    null->fa = null->a[0] = null->a[1] = null;
    int n;
    cin >> n;
    for(int i = 1; i <= n; i++)
        tree[i].a[0] = tree[i].a[1] = tree[i].fa = null;
    for(int i = 2; i <= n; i++)
    {
        int a;
        scanf("%d", &a);
        add(a, i); 
        tree[i].fa = tree+a;
    }
    for(int i = 1; i <= n; i++)
        scanf("%I64d", &tree[i].val);
    dfs(1);
    printf("%.8f\n", (double)ans/n/n);
    int m;
    scanf("%d", &m);
    while(m--)
    {
        char op[111];
        int a, b;
        scanf("%s %d %d", op, &a, &b);
        if(op[0] == 'P') change(a, b);
        else
        {
            node* p = &tree[a];
            access(p);
            splay->splay(p);
            //cout << tree[a].remaind << endl;
            ans += (b - tree[a].val) * tree[a].pairs;
            tree[a].val = b;
            tree[a].update();
        }
        printf("%.8f\n", (double)ans/n/n);
    }
    return 0;
}
