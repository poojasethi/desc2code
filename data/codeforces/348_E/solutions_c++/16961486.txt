#include <cstdio>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <string>
#include <vector>
#include <set>
#include <queue>
#include <map>
#include <iostream>
#include <cassert>

using namespace std;

#define fru(j,n) for(int j=0; j<(n); ++j)
#define tr(it,v) for(typeof((v).begin()) it=(v).begin(); it!=(v).end(); ++it)
#define x first
#define y second
#define pb push_back
#define ALL(G) (G).begin(),(G).end()

//#define DEBUG
#ifdef DEBUG
#define DEB printf
#else
#define DEB(...)
#endif


typedef long long LL;
typedef pair<int,int> pii;
typedef vector<int> vi;

const int inft = 1000000009;
const int MAXN = 1000006;//10^6
bool mon[MAXN];
int wyn[MAXN];
vector<pii> V[MAXN];
pii BEST[MAXN][3];//dl sciezki, lca
pii NAJGL[MAXN];

vector<pii> pyt[MAXN];
int kolor[MAXN],REP[MAXN],przodek[MAXN];
int find(int x){ return REP[x]<0?x:REP[x]=find(REP[x]); }
int summ[MAXN],parent[MAXN];
//z zew: wywolujemy DfsTarjan(wierzcholek,-1);
void DfsTarjan(int x,int par){
	parent[x]=par;
	kolor[x]=1; REP[x]=-1; przodek[x]=x;
	tr(it,V[x]) if (it->x!=par){
		DfsTarjan(it->x,x);
		int a=find(x),b=find(it->x);
		if (REP[a]<REP[b]) swap(a,b);
		REP[b]+=REP[a]; REP[a]=b;
		przodek[b]=x;
	}
	tr(it,pyt[x]) if (kolor[it->x]==2){
		int lca=przodek[find(it->x)];
		DEB("lc(%d,%d) = %d\n",x,it->x,lca);
		summ[lca]--;
		if(parent[lca]!=-1) summ[parent[lca]]--;
	}
	kolor[x]=2;
}
int nr=0;
void sciezka(int a,int b){
	if(a==b) return;
	DEB("dodaje a = %d, b = %d\n",a,b);
	assert(a!=b);
	summ[a]++;
	summ[b]++;
	pyt[a].pb(pii(b,nr));
	pyt[b].pb(pii(a,nr));
}
int tin[MAXN],tout[MAXN],ct; //[tin,tout)

bool potomek(int a,int b){return tin[b]<=tin[a] && tin[a]<tout[b];}

#define child V[u][i].x
#define length V[u][i].y
bool init(int u,int par){
	tin[u]=ct++;
	bool monas=mon[u];
	if(mon[u]) BEST[u][0]=pii(0,u);
	fru(i,V[u].size()) if(child!=par){
		bool tam=init(child,u);
		monas|=tam;
		if(!tam) continue;
		pii q=NAJGL[child];
		q.x+=length;
		if(BEST[u][0].x<q.x){
			BEST[u][2]=BEST[u][1];
			BEST[u][1]=BEST[u][0];
			BEST[u][0]=q;
		}
		else if(BEST[u][1].x<q.x){
			BEST[u][2]=BEST[u][1];
			BEST[u][1]=q;
		} 
		else if(BEST[u][2].x<q.x) BEST[u][2]=q;
	}
	NAJGL[u]=BEST[u][0];
	if(BEST[u][0].x==BEST[u][1].x) NAJGL[u].y=u;
	DEB("%d -- %d, %d\n",u,NAJGL[u].x,NAJGL[u].y);
	tout[u]=ct;
	return monas;
}
void dfs(int u,int par,pii gora){
	DEB("u = %d, par = %d, NAJGl= (%d,%d),gora =(%d,%d)\n",u,par,NAJGL[u].x,NAJGL[u].y,gora.x,gora.y);
	if(gora.x<0 && mon[u]) gora=pii(0,u);
	if(mon[u] && NAJGL[u].x!=gora.x){
		DEB("u = %d\n",u);
		if(NAJGL[u].x>gora.x) sciezka(u,NAJGL[u].y);
		else sciezka(u,gora.y);
	}
	fru(i,V[u].size())if(child!=par){
		pii c=BEST[u][0];
		if(c.x && potomek(c.y,child)) c=BEST[u][1];
		pii g=gora;
		if(g.x==c.x) g.y=u;
		else if(g.x<c.x) {
			int ile=0;
			fru(j,3) if(!potomek(BEST[u][j].y,child) && BEST[u][j].x==c.x)
				ile++;
			g=c;
			assert(ile);
			if(ile>1) g.y=u;
		}
		g.x+=length;
		dfs(child,u,g);
	}
}
int best,best_cnt;
int DfsWynik(int u,int par){
	int q=summ[u];
	fru(i,V[u].size()) if(child!=par)q+=DfsWynik(child,u);
	if(!mon[u]){
		if(q>best){
			best=q;
			best_cnt=0;
		}
		if(q==best) best_cnt++;
	}
	DEB("sciezek w %d jest %d\n",u,q);
	return q;
}

int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	fru(i,n) fru(j,3) BEST[i][j]=pii(-(1<<30),-1);
	fru(i,m){
		int a;
		scanf("%d",&a);
		mon[a-1]=1;
	}
	fru(i,n-1){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		--a;--b;
		V[a].pb(pii(b,c));
		V[b].pb(pii(a,c));
	}
	init(0,-1);
	dfs(0,-1,pii(-(1<<30),-1));
	DfsTarjan(0,-1);
	DfsWynik(0,-1);
	printf("%d %d\n",best,best_cnt);
	return 0;
}
