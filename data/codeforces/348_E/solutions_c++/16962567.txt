#include <bits/stdc++.h>
using namespace std;

#define fru(j,n) for(int j=0; j<(n); ++j)
#define tr(it,v) for(typeof((v).begin()) it=(v).begin(); it!=(v).end(); ++it)
//#define tr(it,v) for(auto it=(v).begin(); it!=(v).end(); ++it)
#define x first
#define y second
#define pb push_back
#define ALL(G) (G).begin(),(G).end()

#if 0
	#define DEB printf
#else
	#define DEB(...)
#endif

typedef long long ll;
typedef long long LL;
typedef pair<int,int> pii;
typedef vector<int> vi;

const int inft = 1000000009;
const int mod = 1000000007;
const int MAXN = 1000006;

int M[MAXN],MM[MAXN];
pii E[MAXN],dist[MAXN];
int di[MAXN];
int C[MAXN];
vi V[MAXN];

int xo(pii d){
	return d.x^d.y;
}

int dfs(int a,int s){
	int p,ret=-inft;
	tr(it,V[a])if((p=xo(E[*it])^a)!=s){
		ret=max(ret,C[*it]+dfs(p,a));
	}
	if(MM[a])ret=max(0,ret);
	return di[a]=ret;
}

void dfs2(int a,int s,int up){
	int p;
	pii B(-inft,-inft);
	tr(it,V[a])if((p=xo(E[*it])^a)!=s){
		if(di[p]+C[*it]>B.x){B.y=B.x;B.x=di[p]+C[*it];}
		else B.y=max(B.y,di[p]+C[*it]);
	}
	DEB("dla %d-- %d %d\n",a+1,B.x,B.y);
	tr(it,V[a])if((p=xo(E[*it])^a)!=s){
		if(E[*it].x!=a)swap(E[*it].x,E[*it].y);
		dist[*it].x=di[p];
		int tem=B.x;
		if(tem==di[p]+C[*it])tem=B.y;
		dist[*it].y=max(up,tem);
		dfs2(p,a,dist[*it].y+C[*it]);
	}

}
int get(int nr,int v){
	if(E[nr].x==v)return dist[nr].x+C[nr];
	return dist[nr].y+C[nr];
}
bool procc[MAXN];
void solve() {
	int n,m,aa;
	scanf("%d%d",&n,&m);
	fru(i,m){
		scanf("%d",&aa);aa--;
		MM[aa]=1;
	}
	fru(i,n-1){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);a--;b--;
		E[i]=pii(a,b);
		C[i]=c;
		V[a].pb(i);
		V[b].pb(i);
	}
	//compute distances 
	dfs(0,-1);
	DEB("di\n");
	fru(i,n)DEB("%d ",di[i]);DEB("\n");
	dfs2(0,-1,MM[0]?0:-inft);
	fru(i,n-1)DEB("%d %d::%d -%d\n",E[i].x+1,E[i].y+1,dist[i].x,dist[i].y);
	//second part push
	fru(i,n){
		int ret=0;
		tr(it2,V[i]){
			ret=max(ret,get(*it2,i));	
		}
		di[i]=ret;
	}
	DEB("di\n");
	fru(i,n)DEB("%d ",di[i]);DEB("\n");
		
	priority_queue<pair<pii,pii> > X;
	fru(i,n)if(MM[i]){
		X.push(make_pair(pii(di[i],i),pii(i,MM[i])));
	}
	while(!X.empty()){
		pair<pii,pii> temp=X.top();X.pop();
		pii U=temp.x;
		vector<pii> T;
		T.pb(temp.y);
		while(!X.empty() && X.top().x==U){
			if(T.back().x==X.top().y.x)T.back().y+=X.top().y.y;
			else T.pb(X.top().y);
			X.pop();
		}
		DEB("mam (%d,%d) ile:",U.x,U.y+1);
		tr(it,T)DEB("(%d-%d) ",it->x+1,it->y);DEB("\n");
		int ile=0,u=U.y;
		pii v(-1,-1),du;
		tr(it,T)M[u]+=it->y;
		tr(it2,V[u]){
			if(get(*it2,u)==U.x){
				ile++;
				if(v.x==-1){
					v.x=xo(E[*it2])^u;
					du.x=U.x-C[*it2];
				}
				else {
					v.y=xo(E[*it2])^u;
					du.y=U.x-C[*it2];
				}
			}
		}
		if(ile>3)continue;
		DEB("v.x (%d, %d) v.y (%d %d)\n",v.x+1,du.x,v.y+1,du.y);
		tr(it,T){
			if(ile==2 && v.x!=it->x && v.y!=it->x)continue;
			if(v.x==it->x && v.y!=-1){
				DEB("(%d-%d)->%d %d\n",it->x+1,it->y,v.y+1,du.y);
				X.push(make_pair(pii(du.y,v.y),pii(u,it->y)));	
			}else if(v.x!=-1){
				DEB("(%d-%d)->%d %d\n",it->x+1,it->y,v.x+1,du.x);
				X.push(make_pair(pii(du.x,v.x),pii(u,it->y)));	
			}
		}
	}
	DEB("M\n");
	fru(i,n)DEB("%d ",M[i]);DEB("\n");
	int ret=0;
	fru(i,n)if(!MM[i])ret=max(ret,M[i]);
	int ile=0;
	fru(i,n)if(!MM[i] && ret==M[i])ile++;
	printf("%d %d\n",ret,ile);	
}

int main() {
	int te = 1;
//	scanf("%d",&te);
	fru(ti,te) solve();
	return 0;
}
