#include <bits/stdc++.h>

#define	st first
#define	nd second
#define	mp make_pair
#define	pb push_back
#define	lli long long int
#define	all( gg )	gg.begin(),gg.end()
#define	foreach( gg,itit )	for( typeof(gg.begin()) itit=gg.begin();itit!=gg.end();itit++ )
#define	FP( ii,aa,bb ) for( lli ii=aa;ii<=bb;ii++ )
#define	FM( ii,aa,bb ) for( lli ii=aa;ii>=bb;ii-- )
#define	debug(ccc)	cout << #ccc << " = " << ccc << endl;

#define	mod	1000000007LL

#define	maxn	150050

using namespace std;

int	n,m;

vector< pair<int,int> >	v[maxn];

int	h[maxn],max1[maxn],max2[maxn],yer[maxn],yer2[maxn],seperate[maxn],der[maxn],root[maxn][20],syer2[maxn],syer1[maxn];

int	lca( int x,int y ){
	if( der[x]<der[y] )	swap( x,y );
	FM( k,17,0 )
		if( der[ root[x][k] ]>=der[y] )
			x = root[x][k];
	if( x==y )	return	x;
	FM( k,17,0 )
		if( root[x][k]!=root[y][k] )
			x = root[x][k],
			y = root[y][k];
	return	root[x][0];
}

void	dfs( int nod,int pre,int d=0 ){

	der[nod] = d;
	root[nod][0] = pre;
	FP( k,1,17 )	root[nod][k] = root[ root[nod][k-1] ][k-1];

	max1[nod] = -1;
	max2[nod] = -1;
	if( h[nod] )	max1[nod] = 0,yer[nod] = nod;
	foreach( v[nod],it ){
		int	x = it->st;
		int	c = it->nd;
		if( x==pre )	continue;
		dfs( x,nod,d+1 );
		if( max1[x]!=-1 ){
			if( max1[x]+c>=max1[nod] ){
				max2[nod] = max1[nod];
				max1[nod] = max1[x]+c;
				yer2[nod] = yer[nod];
				yer[nod] = x;
			}
			else	if( max1[x]+c>=max2[nod] ){
				max2[nod] = max1[x]+c;
				yer2[nod] = x;
			}
		}
	}
	foreach( v[nod],it )
		if( it->st!=pre and max1[it->st]+it->nd==max2[nod] )	syer2[nod]++;
	foreach( v[nod],it )
		if( it->st!=pre and max1[it->st]+it->nd==max1[nod] )	syer1[nod]++;
	if( max1[nod]==max2[nod] or yer[nod]==nod )	seperate[nod] = nod;
	else	seperate[nod] = seperate[ yer[nod] ];
	if( max1[nod]==-1 )	seperate[nod] = -1;
	//cout << nod << "   " << max1[nod] << " " << max2[nod] << " " << seperate[nod] << endl;
}

int	dp[maxn];
void	dfs2( int nod,int pre,int k,int sep ){
	//cout << nod << " " << sep << endl;
	if( h[nod] ){
		int	x,y,l;
		if( k==-1 )
			x = nod,y = seperate[nod];
		else{
			if( k>max1[nod] )
				x = nod,y = sep;
			else	if( k<max1[nod] )
				x = nod,y = seperate[nod];
			else
				x = nod,y = nod;
		}
		l = lca( x,y );
		dp[x]++;
		dp[y]++;
		dp[l]--;
		/*if( nod==5 ){
			cout << max1[nod] << " " << k << " " << sep << " " << y  << endl;
		}*/
		if( l!=1 )	dp[root[l][0]]--;
	}
	foreach( v[nod],it ){
		int	x = it->st;
		int	c = it->nd;
		if( x==pre )	continue;
		if( yer[nod]!=x ){
			if( k==-1 and max1[nod]==0 ){
				dfs2( x,nod,c,nod );
				continue;
			}
			if( k==-1 )	assert( max1[nod]!=-1 );
			if( k>max1[nod] )
				dfs2( x,nod,k+c,sep );
			else	if( k<max1[nod] )
				dfs2( x,nod,max1[nod]+c,syer1[nod]-(max1[nod]==max1[x]+c)>1 ? nod : seperate[yer[nod]] );
			else
				dfs2( x,nod,k+c,nod );
		}
		else{
			if( k==-1 and max2[nod]==-1 ){
				dfs2( x,nod,-1,-1 );
				continue;
			}
			if( k==-1 and max2[nod]==0 ){
				dfs2( x,nod,c,nod );
				continue;
			}
	//		if( x==8 )	cout << k << " " << max2[nod] << endl;
			if( k>max2[nod] )
				dfs2( x,nod,k+c,sep );
			else	if( k<max2[nod] )
				dfs2( x,nod,max2[nod]+c,syer1[nod]-1>1 or (syer1[nod]==1 and syer2[nod]>1) ? nod : seperate[yer2[nod]] );
			else
				dfs2( x,nod,k+c,nod );
		}
	}
}

int	res,s;

void	DFS( int nod,int pre ){
	foreach( v[nod],it )
		if( it->st!=pre ){
			DFS( it->st,nod );
			dp[nod] += dp[it->st];
		}
	if( h[nod]==0 ){
		if( dp[nod]==res )
			s++;
		else	if( dp[nod]>res ){
			res = dp[nod];
			s = 1;
		}
	}
}

int main(){
	cin >> n >> m;
	FP( i,1,m ){
		int	x;
		cin >> x;
		h[x] = 1;
	}
	FP( i,1,n-1 ){
		int	x,y,c;
		cin >> x >> y >> c;
		v[x].pb( mp(y,c) );
		v[y].pb( mp(x,c) );
	}
	dfs( 1,1 );
	dfs2( 1,1,-1,-1 );
	DFS( 1,1 );
	cout << res << " " << s << endl;
}
