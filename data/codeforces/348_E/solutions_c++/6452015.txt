#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <cmath>
using namespace std;
const int N = 100005;
const int INF = (1 << 29);
int a,b,c,d,e,f,g,h,i,j,k;
vector<pair<int,int> > tree[N];
bool black[N];
pair<int,int> Lst[N], Snd[N], Best[N];
int Bottom[N], Top[N];
int father[N][20], deep[N];
int H[N];

void Init()
{
    cin >> a >> b;
    for(i = 1; i <= b; i ++)
        scanf("%d", &c), black[c] = true;
    for(i = 1; i < a; i ++)
    {
        scanf("%d%d%d", &c, &d, &e);
        tree[c].push_back(make_pair(d, e));
        tree[d].push_back(make_pair(c, e));
    }
}
void Build_LCA()
{
    for(int jj = 1; jj <= 19; jj ++)
        for(int ii = 1; ii <= a; ii ++)
            father[ii][jj] = father[father[ii][jj - 1]][jj - 1];
}
int LCA(int x,int y)
{
    if(deep[x] < deep[y]) swap(x, y);
    for(int ii = 18; ii >= 0; ii --)
    if(deep[father[x][ii]] >= deep[y])
        x = father[x][ii];
    if(x == y) return x;
    for(int ii = 18; ii >= 0; ii --)
    if(father[x][ii] != father[y][ii])
        x = father[x][ii], y = father[y][ii];
    return father[x][0];
}
void sososo(int x,int y,int z)
{
    if(y == Lst[x].first) Best[x].second = x;
    else if(y > Lst[x].first) Best[x] = make_pair(y, z);
    else Best[x] = make_pair(Lst[x].first, Bottom[x]);
    
    if(black[x] && y < 0) y = 0, z = x;
    
    for(int ii = 0; ii < tree[x].size(); ii ++)
    {
        int jj = tree[x][ii].first;
        if(jj == father[x][0]) continue;
        int yy = y, zz = z;
        pair<int,int> now;
        
        if(Lst[x].second == jj) now = Snd[x];
        else now = Lst[x];
        
        if(now.first > y) zz = Bottom[now.second];
        else if(now.first == y) zz = x;
        yy = max(yy, now.first) + tree[x][ii].second;
        sososo(jj, yy, zz);
    }
}
void soso(int x)
{
    deep[x] = deep[father[x][0]] + 1;
    Lst[x].first = Snd[x].first = -INF;
    for(int ii = 0; ii < tree[x].size(); ii ++)
    {
        int jj = tree[x][ii].first;
        if(jj == father[x][0]) continue;
        father[jj][0] = x, soso(jj);
        int now = Lst[jj].first + tree[x][ii].second;
        if(Lst[jj].first < 0 && black[jj]) now = tree[x][ii].second;
        
        if(now > Lst[x].first) Snd[x] = Lst[x], Lst[x] = make_pair(now, jj), Bottom[x] = Bottom[jj];
        else if(now > Snd[x].first) Snd[x] = make_pair(now, jj);
    }
    if(Lst[x].first == Snd[x].first) Bottom[x] = x;
}
void Find(int x)
{
    for(int ii = 0; ii < tree[x].size(); ii ++)
    {
        int jj = tree[x][ii].first;
        if(jj == father[x][0]) continue;
        Find(jj);
        H[x] += H[jj];
    }
}
void Work()
{
    soso(1);
    sososo(1, -INF, 0);
    Build_LCA();
    for(int ii = 1; ii <= a; ii ++)
    if(black[ii])
    {
        int xx = ii, yy = Best[ii].second;
        int ee = LCA(xx, yy);
        H[xx] ++, H[father[ee][0]] --;
        H[yy] ++, H[ee] --;
    }
    Find(1);
    pair<int,int> an = make_pair(-1, 0);
    for(int ii = 1; ii <= a; ii ++)
    if(black[ii] == false)
    {
        if(H[ii] > an.first) an = make_pair(H[ii], 1);
        else if(H[ii] == an.first) an.second ++;
    }
    cout << an.first << " " << an.second << endl;
}

int main()
{
    Init(), Work();
    return 0;
}