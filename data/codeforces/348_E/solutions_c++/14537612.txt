#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

#define LY(p) freopen (p".in", "r", stdin); freopen (p".out", "w", stdout)

#define arset(A, u) memset (A, u, sizeof (A))
#define fore(_,  __) for (int x = h[_], y; y = e[x].v, x && (__); x = e[x].n)
#define max(_, __) ((_) > (__)? _ : __)

#define LL long long
#define dbl double
#define ld long double
#ifdef WIN32
#define L_L "%I64d"
#else
#define L_L "%lld"
#endif
#define N 100010
int n, m, x, y, z;
int tot, h[N], val[N], nex[N], aft[N];
int b[N], s[N];
int dep[N], rank[N], tim, up[N], pa[N], siz[N], son[N];

struct edge {
	int v, w, n;
	edge (int y = 0, int z = 0, int t = 0): v(y), w(z), n(t) {}
} e[N * 2];

void link (int x, int y, int z) {e[++ tot] = edge (y, z, h[x]), h[x] = tot;}

struct DP {
	int dep, whe;
	DP (int x = 0, int y = 0): dep(x), whe(y) {}
} f[N], pre[N], suf[N];

void upd (DP *o, DP *y, int z) {
	if (! y-> whe) return;
	if (y-> dep + z > o-> dep)
		*o = *y, o-> dep += z;
	else if (y-> dep + z == o -> dep)
		o-> whe = 0;
}

void add (int L, int R) {b[L] ++, b[R + 1] --;}

void modify (int x, int y) {
	while (1) {
		if (dep[ up[x] ] < dep[ up[y] ])
			swap (x, y);
		if (up[x] == up[y]) {
			if (dep[x] > dep[y]) swap (x, y);
			return add (rank[x], rank[y]);
		}
		else
			add (rank[ up[x] ], rank[x]), x = pa[ up[x] ];
	}
}

void dfs (int o, int ft) {
	dep[o] = dep[ft] + 1, siz[o] = 1;
	f[o].whe = 0;
	int las(0);
	fore (o, 1) {
		if (y != ft) {
			dfs (y, o),	siz[o] += siz[y];
			if (siz[y] > siz[ son[o] ])
				son[o] = y;

			upd (pre + y, pre + las, 0);
			upd (pre + y, f + y, e[x].w);
			upd (f + o, f + y, e[x].w);
			nex[y] = las, aft[las] = y, las = y;
			upd (suf + y, f + y, e[x].w);

			if ((! f[o].whe) && (f[o].dep || val[o])) f[o].whe = o;
			if ((! pre[y].whe) && (pre[y].dep || val[o])) pre[y].whe = o;
			if ((! suf[y].whe) && (suf[y].dep || val[o])) suf[y].whe = o;
		}
	}
	if ((! f[o].whe) && (f[o].dep || val[o])) f[o].whe = o;
	for (int lt(0); las; lt = las, las = nex[las]) {
		upd (suf + las, suf + lt, 0);
		if ((! suf[las].whe) && (suf[las].dep || val[o])) suf[las].whe = o;
	}
}

void prep (int o, int ft) {
	rank[o] = ++ tim;
	if (son[o])
		up[ son[o] ] = up[o], prep (son[o], o);
	fore (o, 1)
		if (y != ft && y != son[o])
			pa[y] = o, up[y] = y, prep (y, o);
}

void work (int o, int ft, DP *lf) {
	DP *nf(new DP);
	if (val[o]) {
		*nf = *lf;
		upd (nf, f + o, 0);
		if ((! nf-> whe) && (nf-> dep || val[o]))
			nf-> whe = o;
		if (nf-> whe)
			modify (nf-> whe, o);
	}
	fore (o, 1)
		if (y != ft) {
			*nf = *lf;
			upd (nf, pre + nex[y], 0), upd (nf, suf + aft[y], 0);
			if ((! nf-> whe) && (nf-> dep || val[o]))
				nf-> whe = o;
			if (nf-> whe)
				nf-> dep += e[x].w;
			work (y, o, nf);
		}
}

void count() {
	int ans(0), cnt(0);
	for (int i = 1; i <= n; i++)
		s[i] = s[i - 1] + b[i];
	for (int i = 1; i <= n; i++)
		if (! val[i])
			if (s[ rank[i] ] > ans)
				cnt = 1, ans = s[ rank[i] ];
			else if (s[ rank[i] ] == ans)
				cnt ++;
	printf ("%d %d\n", ans, cnt);
}

int main()
{
#ifndef ONLINE_JUDGE
	LY("4342");
#endif
	scanf ("%d %d", &n, &m);
	for (int i = 1; i <= m; i++)
		scanf ("%d", &x), val[x] = 1;
	for (int i = 1; i < n; i++)
		scanf ("%d %d %d", &x, &y, &z), link (x, y, z), link (y, x, z);
	dfs (1, 0);
	up[1] = 1, prep (1, 0);
	work (1, 0, new DP);
	count();
	return 0;
}
