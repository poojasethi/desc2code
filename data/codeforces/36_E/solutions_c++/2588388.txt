#include <vector>
#include <cstdio>
#include <set>
#include <map>
#include <algorithm>
#include <cstdlib>
#include <sstream>
#include <numeric>
#include <queue>
#include <iostream>
#include <string>
#include <cstring>
#include <utility>
#define sz(a) ((int)(a).size())
#define pb push_back
#define mk make_pair
#define fi first
#define se second
#define Rep(i,j,k) for (int i=(j); i<=(k); i++)
#define Repd(i,j,k) for (int i=(j); i>=(k); i--)
#define ALL(c) (c).begin(),(c).end()
#define TR(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define SUM(a) accumulate(all(a),string())
#define online1
#define RAND ((rand()<<15)+rand())
using namespace std;
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef pair<int,int> II;
typedef long long LL;
#define M (10002)
#define N (M-1)

int m;
II edge[M];
bool mark[M];
int f[M], d[M];
vector<II> E[M];

int getfa(int x){
	if (x==f[x]) return x;
	return f[x]=getfa(f[x]);
}

VI ans;

void dfs(int x){
	TR(E[x],e)if(!mark[e->se]){
		mark[e->se]=1;
		dfs(e->fi);
		ans.pb(e->se);
	}
}

void doit(int m, int DelEdge){
	int Odd=0;
	VI OddPoint;
	Rep(i,1,N){
		f[i]=i;
		if (d[i]&1)
			Odd++, OddPoint.pb(i);
	}
	Rep(i,1,m)
		f[getfa(edge[i].fi)]=getfa(edge[i].se);
	int num=0;
	Rep(i,1,N)	
		if (d[i] && getfa(i)==i)
			num++;
	if (num>1 || sz(OddPoint)>2) return;
	Rep(i,1,N) E[i].clear();
	Rep(i,1,m){
		mark[i]=0;
		E[edge[i].fi].pb(mk(edge[i].se,i));
		E[edge[i].se].pb(mk(edge[i].fi,i));
	}
	ans.clear();
	if (sz(OddPoint))
		dfs(OddPoint[0]);
	else
		Rep(i,1,N)
			if (d[i]){
				dfs(i);
				break;
			}
	int x=find(ans.begin(),ans.end(),DelEdge)-ans.begin();
	if (x==sz(ans)) x=1;
	cout<<x<<endl;
	Rep(i,0,x-1)
		cout<<ans[i]<<" ";
	cout<<endl;
	if (DelEdge==-1) x=0;
	cout<<sz(ans)-x-1<<endl;
	Rep(i,x+1,sz(ans)-1)
		cout<<ans[i]<<" ";
	cout<<endl;
	exit(0);
}

int main(){
	freopen("input.txt","r",stdin);
	freopen("output.txt","w",stdout);
	
	cin>>m;
	Rep(i,1,N) f[i]=i;
	Rep(i,1,m){
		int x,y;
		scanf("%d%d",&x,&y);
		d[x]++, d[y]++;
		edge[i]=mk(x,y);
		f[getfa(x)]=getfa(y);
	}
	
	int Num=0;
	VI OddPoint;
	Rep(i,1,N) if (d[i]){
		if (getfa(i)==i)
			Num++;
		if (d[i]&1)
			OddPoint.pb(i);
	}
	
	if (Num>2 || sz(OddPoint)>4 || m==1) return puts("-1"), 0;
	if (Num==1 && sz(OddPoint)<=2)
		doit(m,-1);
	Rep(i,1,N) if (d[i] && getfa(i)==i) OddPoint.pb(i);
	TR(OddPoint,x)
		TR(OddPoint,y)if(*x!=*y){
			d[*x]++, d[*y]++;
			edge[m+1]=mk(*x,*y);
			doit(m+1,m+1);
			d[*x]--, d[*y]--;
		}
	puts("-1");

    return 0;
}
