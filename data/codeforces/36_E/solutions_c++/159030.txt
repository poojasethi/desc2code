#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <set>

#define REP(AA,BB) for(AA=0; AA<(BB); ++AA)
#define FOR(AA,BB,CC) for(AA=(BB); AA<(CC); ++AA)
#define FC(AA,BB) for(typeof(AA.begin()) BB=AA.begin(); BB!=AA.end(); ++BB)
#define SZ(AA) ((int)((AA).size()))
#define ALL(AA) (AA).begin(), (AA).end()
#define PB push_back
#define MP(AA,BB) make_pair((AA), (BB))

using namespace std;

typedef vector<int> VI;
typedef pair<int, int> PII;

set<PII> E[10010]; VI cykl;

void euler(int v) {
	while(!E[v].empty()) {
		int w=E[v].begin()->first, num=E[v].begin()->second;
		E[v].erase(E[v].begin()); E[w].erase(MP(v,num));
		euler(w);
		cykl.PB(num);
	}
}

int main(void) {
	int n=0, m, M, i, j, k, a, b;
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);
	scanf("%d", &m);
	REP(i,m) {
		scanf("%d%d", &a, &b);
		n=max(n,a); n=max(n,b);
		--a; --b; 
		E[a].insert(MP(b,i));
		E[b].insert(MP(a,i));
	}
	VI odd;
	REP(i,n) {
		if(SZ(E[i])&1)
			odd.PB(i);
	}
	if(SZ(odd)&1) {
		puts("-1");
		return 0;
	}
	M=m;
	for(i=0; i<SZ(odd); i+=2) {
		E[odd[i]].insert(MP(odd[i+1], M));
		E[odd[i+1]].insert(MP(odd[i], M++));
	}
	vector<VI> drogi;
	REP(i,n) {
		if(!E[i].empty()) {
			cykl.clear();
			euler(i);
			int st=0;
			REP(j,SZ(cykl)) {
				if(cykl[j]>=m)
					st=j;
			}
			VI cur;
			for(j=(st+1)%SZ(cykl); ; j=(j+1)%SZ(cykl)) {
				if(cykl[j]>=m) {
					if(!cur.empty())
						drogi.PB(cur);
					cur.clear();
				}
				else
					cur.PB(cykl[j]);
				if(j==st)
					break;
			}
			if(!cur.empty())
				drogi.PB(cur);
		}
	}
	if(SZ(drogi)>2 || (SZ(drogi)==1 && SZ(drogi.back())==1)) {
		puts("-1");
		return 0;
	}
	if(SZ(drogi)==1) {
		k=drogi.back().back(); drogi.back().pop_back();
		drogi.PB(VI()); drogi.back().PB(k);
	}
	REP(i,SZ(drogi)) {
		printf("%d\n", SZ(drogi[i]));
		REP(j,SZ(drogi[i]))
			printf("%d ", drogi[i][j]+1);
		puts("");
	}
	return 0;
}
