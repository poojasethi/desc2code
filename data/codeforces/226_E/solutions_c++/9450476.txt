#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define N 100100
using namespace std;
struct Ques{int t, a, b, k, y;}Q[N];
int f[N][18], p[N], nxt[N * 2], V[N * 2], L[N * 30], R[N * 30], S[N * 30];
int A[N], d[N], Rt[N], n, m, i, ed, cnt, rt;
int gi()
{
	int s = 0; char ch = getchar();
	while (ch < '0' || ch > '9') ch = getchar();
	while (ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();
	return s;
}
void Add(int u, int v)
{
	V[++ed] = v, nxt[ed] = p[u], p[u] = ed;
}
void Updata(int &x, int y, int l, int r, int p, int v)
{
	x = ++cnt;
	L[x] = L[y], R[x] = R[y], S[x] = S[y] + 1;
	if (l == r) return;
	int mid = (l + r) >> 1;
	if (p <= mid) Updata(L[x], L[y], l, mid, p, v);
	else Updata(R[x], R[y], mid + 1, r, p, v);
}
void Dfs(int x, int fa)
{
	f[x][0] = fa, d[x] = d[fa] + 1;
	Updata(Rt[x], Rt[fa], 0, m, A[x], 1);
	for (int i = p[x]; i != -1; i = nxt[i])
		if (V[i] != fa) Dfs(V[i], x);
}
int Lca(int u, int v)
{
	if (d[u] < d[v]) swap(u, v);
	for (int i = 17; i >= 0; i--)
		if (d[f[u][i]] >= d[v]) u = f[u][i];
	if (u == v) return u;
	for (int i = 17; i >= 0; i--)
		if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];
	return f[u][0];
}
int Jump(int x, int h)
{
	int j = 0;
	while(h)
	{
		if (h & 1) x = f[x][j];
		h >>= 1, j++;
	}
	return x;
}
int find(int u, int v, int c, int x)
{
	if (d[u] - d[c] >= x) return Jump(u, x);
	else return Jump(v, d[u] + d[v] - 2 * d[c] - x);
}
int Query(int x, int y, int z, int l, int r, int xl, int xr)
{
	if (l == xl && r == xr) return S[x] + S[y] - 2 * S[z];
	int mid = (l + r) >> 1;
	if (xr <= mid) return Query(L[x], L[y], L[z], l, mid, xl, xr);
	else if (xl > mid) return Query(R[x], R[y], R[z], mid + 1, r, xl, xr);
	else
	{
		int a = Query(L[x], L[y], L[z], l, mid, xl, mid);
		int b = Query(R[x], R[y], R[z], mid + 1, r, mid + 1, xr);
		return a + b;
	}  
}
int Getans(int x)
{
	int u = Q[x].a, v = Q[x].b, c = Lca(u, v);
	int xl = Q[x].y + 1, xr = x;
	int l = 1, sum = d[u] + d[v] - 2 * d[c] - 1, r = sum;
	int w = find(u, v, c, 1), o = find(u, v, c, r), g = Lca(w, o);
	int s = Query(Rt[w], Rt[o], Rt[g], 0, m, xl, xr) + (A[g] <= xr && A[g] >= xl);
	if (sum - s < Q[x].k) return -1;
	int h = find(u, v, c, 1);
	while (l <= r)
	{
		int mid = (l + r) >> 1;
		int z = find(u, v, c, mid), c1 = Lca(z, h);
		int s = d[z] + d[h] - 2 * d[c1] + 1;
		s = s - Query(Rt[h], Rt[z], Rt[c1], 0, m, xl, xr);
		if (xl <= A[c1] && A[c1] <= xr) s--;
		if (s < Q[x].k) l = mid + 1;
		else r = mid - 1;
	}
	return find(u, v, c, l);
}
int main()
{
	memset(p, -1, sizeof(p));
	scanf("%d", &n);
	for (i = 1; i <= n; i++)
	{	
		int u = gi();
		if (u) Add(u, i), Add(i, u); else rt = i;
	}
	scanf("%d", &m);
	for (i = 1; i <= m; i++)
	{
		Q[i].t = gi();
		if (Q[i].t == 1) A[gi()] = i;
		else Q[i].a = gi(), Q[i].b = gi(), Q[i].k = gi(), Q[i].y = gi();
	}
	Dfs(rt, 0);
	for (i = 1; i <= 17; i++)
		for (int j = 1; j <= n; j++)
			f[j][i] = f[f[j][i - 1]][i - 1];
	for (i = 1; i <= m; i++)
		if (Q[i].t == 2) printf("%d\n", Getans(i));
    return 0;
}