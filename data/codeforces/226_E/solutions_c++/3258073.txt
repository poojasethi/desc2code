#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <cmath>
#include <algorithm>
using namespace std;
const int MAXN=100005;

int n,m,N,tot,fst[MAXN],pre[MAXN],b[MAXN],f[MAXN][20],L[MAXN],R[MAXN],Log[MAXN],dep[MAXN],dfn[MAXN],lim,root[MAXN];

struct Tnode
{
	int ls,rs,sum;
}t[MAXN*25];

struct Tsegtree
{
	int tot;
	void build(int &x,int l,int r)
	{
		x=++tot;t[x].sum=0;
		if(l<r)
		{
			int mid=(l+r)>>1;
			build(t[x].ls,l,mid);
			build(t[x].rs,mid+1,r);
		}
	}
	void init(){tot=0,build(root[0],1,N);}
	void NewNode(int &x,int pre,int l,int r,int k,int v)
	{
		x=++tot;t[x]=t[pre];t[x].sum+=v;
		if(l==r)return;
		int mid=(l+r)>>1;
		if(k<=mid)NewNode(t[x].ls,t[x].ls,l,mid,k,v);
		else NewNode(t[x].rs,t[x].rs,mid+1,r,k,v);
	}
	int qry(int x,int l,int r,int _l,int _r)
	{
		if(l==_l&&r==_r)return t[x].sum;
		int mid=(l+r)>>1;
		if(_r<=mid)return qry(t[x].ls,l,mid,_l,_r);
		if(_l>mid)return qry(t[x].rs,mid+1,r,_l,_r);
		return qry(t[x].ls,l,mid,_l,mid)+qry(t[x].rs,mid+1,r,mid+1,_r);
	}
}tree;

int get()
{
	int f=0,v=0; char ch;
	while (!isdigit(ch=getchar()))if (ch=='-')break;
	if (ch=='-')f=1; else v=ch-48;
	while (isdigit(ch=getchar()))v=v*10+ch-48;
	if (f==1)return -v ;return v;
}

void add(int x,int y){pre[++tot]=fst[x];fst[x]=tot;b[tot]=y;}

void dfs(int x)
{
	L[x]=++tot;
	for(int i=fst[x];i;i=pre[i])dep[b[i]]=dep[x]+1,dfs(b[i]);
	R[x]=++tot;
}

int lca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	int d=dep[x]-dep[y];
	for(int i=lim;i>=0;i--)if(d&(1<<i))x=f[x][i];
	for(int i=lim;x!=y;)
	{
		for(;f[x][i]==f[y][i]&&i>0;i--);
		x=f[x][i],y=f[y][i];
	}
	return x;
}

int query(int a,int b,int x,int y){return dep[y]-dep[x]+1-tree.qry(root[b],1,N,L[x],L[y])+tree.qry(root[a],1,N,L[x],L[y]);}

int qry(int a,int b,int x,int y,int k)
{
	int x1=x;
	for(int i=lim;i>=0;i--)
		if(dep[f[x1][i]]>=dep[y]&&query(a,b,f[x1][i],x)<k)x1=f[x1][i];
	return f[x1][0];
}

int main()
{
	n=get();
	int rt;
	for(int i=1;i<=n;i++)
	{
		f[i][0]=get();
		if(f[i][0])add(f[i][0],i);else rt=i;
	}
	tot=0,dep[rt]=1,dfs(rt);N=n<<1;
	Log[1]=0;for(int i=2;i<=n;i++)Log[i]=Log[i/2]+1;
	lim=Log[n];
	for(int j=1;j<=lim;j++)
		for(int i=1;i<=n;i++)f[i][j]=f[f[i][j-1]][j-1];
	tree.init();
	m=get();
	for(int i=1;i<=m;i++)
	{
		int tp=get();
		if(tp==1)
		{
			int x=get();
			dfn[x]=i;
			tree.NewNode(root[i],root[i-1],1,N,L[x],1);
			tree.NewNode(root[i],root[i],1,N,R[x],-1);
		}else
		{
			root[i]=root[i-1];
			int a=get(),b=get(),k=get(),y=get(),c=lca(a,b);
			if(dfn[a]<=y)k++;
			int m1=query(y,i,c,a),m2=query(y,i,c,b);
			if(m1+m2-(dfn[c]<=y)-(dfn[b]<=y)<k){printf("-1\n");continue;}
			if(m1>=k)printf("%d\n",qry(y,i,a,c,k));
			else
			{
				int tmp=m2-(k-m1+(dfn[c]<=y))+1;
				printf("%d\n",qry(y,i,b,c,tmp));
			}
		}
	}
	return 0;
}
