#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#define FOR(i,s,e) for (int i=(s); i<(e); i++)
#define FOE(i,s,e) for (int i=(s); i<=(e); i++)
#define FOD(i,s,e) for (int i=(s)-1; i>=(e); i--)
#define CLR(a,x) memset(a, x, sizeof(a))
#define EXP(i,l) for (int i=(l); i; i=qn[i])
#define N 100005
using namespace std;

int n, m, w, x, y, z, t, cnt, id, op, num, ret, dx, dy, dw, cur;
int v[N+N], f[N], st[N], en[N], stk[N], l[N], qn[N], h[N], del[N];
int ST[N+N][18], p[N][18];
vector<int> BIT[N+N], TSP[N+N];

int hmin(int x, int y){return h[x] < h[y] ? x : y;}

void dfs(int x, int y){
	st[x] = ++cnt;

	stk[y] = x;
	h[x] = y;
	for (int i=0; y - (1<<i) >= 0; i++) p[x][i] = stk[y - (1<<i)];

	v[++t] = x;
	f[x] = t;

	EXP(i,l[x]){
		dfs(i, y+1);
		v[++t] = x;
	}

	en[x] = ++cnt;
}

// sparse table
void preST(){
	for (int i=1; i<=t; i++) ST[i][0] = v[i];
	for (int j=1; (1<<j)<=t; j++)
		for (int i=1; i+(1<<j)-1<=t; i++)
			ST[i][j] = hmin(ST[i][j-1], ST[i+(1<<(j-1))][j-1]);
}

int lca(int x, int y){
	int t;
	x = f[x];
	y = f[y];
	if (x > y) swap(x, y);
	for (t=0; (1<<(t+1))<=(y-x+1); t++);
	return hmin(ST[x][t], ST[y-(1<<t)+1][t]);
}


int build(){
	FOE(i,1,cnt){
		BIT[i].push_back(0);
		TSP[i].push_back(0);
	}
}

int update(int x, int v, int t){
	int l;
	for (int i=x; i<=cnt; i+=i&-i){
		l = BIT[i].size();
		if (TSP[i][l-1] == t) BIT[i][l-1] += v;
		else{
			BIT[i].push_back(BIT[i][l-1] + v);
			TSP[i].push_back(t);
		}
	}
}

int query(int x, int t){
	int r = 0;
	vector<int>::iterator d;
	for (int i=x; i>=1; i-=i&-i){
		if (t == cur) d = TSP[i].end();
		else d = upper_bound(TSP[i].begin(), TSP[i].end(), t);
		d--;
		r += BIT[i][(int)(d-TSP[i].begin())];
	}
	return r;
}

int query(int x, int y, int t){
	return query(y, t) - query(x-1, t);
}

int Count(int a, int b, int t){
	if (st[a] > st[b]) swap(a, b);
	int ret = h[b] - h[a] + 1 - query(st[a], st[b], cur) + query(st[a], st[b], t);
	if (a == x || b == x) ret -= dx;
	if (a == y || b == y) ret -= dy;
	return ret;
}

int Parent(int x, int k){
	if (!k) return x;
	int t = 0;
	while ((1 << (t+1)) <= k) ++t;
	return Parent(p[x][t], k - (1<<t));
}

int main(){
	scanf("%d", &n);
	FOE(i,1,n){
		scanf("%d", &x);
		qn[i] = l[x];
		l[x] = i;
	}

	// precompute
	t = cnt = 0;
	dfs(0, 0);
	preST();
	build();

	scanf("%d", &m);
	FOE(i,1,m){
		cur = i;
		scanf("%d", &op);
		if (op == 1){
			scanf("%d", &x);
			update(st[x], 1, i);
			update(en[x], -1, i);
			del[x] = i;
		}
		if (op == 2){
			scanf("%d%d%d%d", &x, &y, &z, &t);
			w = lca(x, y);
			dx = del[x] <= t;
			dy = del[y] <= t;
			dw = del[w] <= t;

			num = Count(x, w, t);
			ret = -1;

			if (num >= z){
				for (int i=0, j=h[x]-h[w], k; j>=i;){
					k = (i + j) / 2;
					if (Count(x, Parent(x, k), t) >= z) ret = k, j = k - 1;
					else i = k + 1;
				}
				printf("%d\n", Parent(x, ret));
			}
			else{
				if (w == x || w == y) dw = 0;
				z -= num - dw;
				if (Count(w, y, t)  < z){
					puts("-1");
					continue;
				}

				for (int i=0, j=h[y]-h[w], k; j>=i;){
					k = (i + j) / 2;
					if (Count(w, Parent(y, k), t) >= z) ret = k, i = k + 1;
					else j = k - 1;
				}
				printf("%d\n", Parent(y, ret));
			}

		}

	}
	return 0;
}
