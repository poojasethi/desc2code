#include<iostream>
#include<fstream>
#include<sstream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<vector>
#include<map>
#include<cstring>
using namespace std;

#define FOR(I,A,B) for (int I=int(A);I<int(B);++I)
#define MEM(A,B) memset(A,B,sizeof(A))
#define CPY(A,B) memcpy(A,B,sizeof(B))
#define FIN(A) freopen(A, "r", stdin)
#define FOUT(A) freopen(A, "w", stdout)
typedef long long LL;

const int N(100010), T(19);

struct Node {
	int d, le, ri;
};
int n, m, si;
vector<int> g[N];
int dep[N], ll[N], rr[N], ro[N];
int fa[T][N];
Node st[T * (1 << T)];

void dfs(int x) {
	FOR(i, 1, T)
		fa[i][x] = fa[i - 1][fa[i - 1][x]];
	ll[x] = ++m;
	FOR(i, 0, g[x].size())
		if (g[x][i] != fa[0][x]) {
			fa[0][g[x][i]] = x;
			dep[g[x][i]] = dep[x] + 1;
			dfs(g[x][i]);
		}
	rr[x] = m;
}

void add(int &i, int l, int r, int x, int y, int v) {
	if (y < l || r < x) return;
	st[++si] = st[i]; i = si;
	if (x <= l && r <= y) {
		st[i].d += v;
		return;
	}
	int mid = (l + r) / 2;
	add(st[i].le, l, mid, x, y, v);
	add(st[i].ri, mid + 1, r, x, y, v);
}

int getD(int i, int j, int l, int r, int x) {
	if (x < l || r < x) return 0;
	if (i == 0 && j == 0 || l == r) return st[j].d - st[i].d;
	int mid = (l + r) / 2;
	return getD(st[i].le, st[j].le, l, mid, x) + getD(st[i].ri, st[j].ri, mid + 1, r, x) + st[j].d - st[i].d;
}

int go(int x, int d) {
	FOR(i, 0, T)
		if (d & (1 << i)) x = fa[i][x];
	return x;
}

int lca(int x, int y) {
	if (x == y) return x;
	if (dep[x] > dep[y]) swap(x, y);
	if (dep[x] != dep[y]) return lca(x, go(y, dep[y] - dep[x]));
	for (int i = T - 1; i != -1; --i)
		if (fa[i][x] != fa[i][y]) {
			x = fa[i][x]; y = fa[i][y];
		}
	return fa[0][x];
}

int calc(int x, int y, int t1, int t2) {
	int z = lca(x, y);
	int ret = getD(ro[t1], ro[t2], 1, n, ll[x]) + getD(ro[t1], ro[t2], 1, n, ll[y]) - getD(ro[t1], ro[t2], 1, n, ll[z]);
	if (fa[0][z]) ret -= getD(ro[t1], ro[t2], 1, n, ll[fa[0][z]]);
	return dep[x] + dep[y] - 2 * dep[z] + 1 + ret;
}

int dis(int x, int y) {
	return dep[x] + dep[y] - 2 * dep[lca(x, y)];
}

int go(int x, int y, int d) {
	int z = lca(x, y);
	if (dep[x] - dep[z] >= d) return go(x, d);
	d -= dep[x] - dep[z];
	return go(y, dep[y] - dep[z] - d);
}

int main() {
	int cmd, x, a, b, k, y;
	//freopen("in.txt", "r", stdin);
	cin >> n;
	FOR(i, 1, n + 1) {
		int v;
		cin >> v;
		if (!v) continue;
		g[i].push_back(v); g[v].push_back(i);
	}
	dfs(1);
	cin >> m;
	FOR(i, 1, m + 1) {
		ro[i] = ro[i - 1];
		cin >> cmd;
		if (cmd == 1) {
			cin >> x;
			add(ro[i], 1, n, ll[x], rr[x], -1); 
		}
		else {
			cin >> a >> b >> k >> y;
			a = go(a, b, 1);
			int le = 0, ri = dis(a, b) - 1;
			while (le < ri) {
				int mid = (le + ri) / 2;
				if (calc(a, go(a, b, mid), y, i) >= k) ri = mid;
				else le = mid + 1;
			}
			if (le == ri && calc(a, go(a, b, le), y, i) >= k) cout << go(a, b, le) << endl;
			else cout << -1 << endl;
		}
	}
	return 0;
}
