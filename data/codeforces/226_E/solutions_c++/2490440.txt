#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

const int maxn = 100010;
int n, L, Q, root, cur, limit, cnt, type, x, y, s, kth;
int T[maxn], sum[maxn * 20], left[maxn * 20], right[maxn * 20];
int d[maxn], up[maxn][20], Ls[maxn], Rs[maxn], attack[maxn];
vector<int> e[maxn];

int getLCA(int x, int y){
	if (d[x] < d[y]) swap(x, y);
	for (int i = L; i >= 0; i--)
		if (d[up[x][i]] >= d[y]) x = up[x][i];
	if (x == y) return x;
	for (int i = L; i >= 0; i--)
		if (up[x][i] != up[y][i]) x = up[x][i], y = up[y][i];
	return up[x][0];
}

void dfs(int x){
	L = max(L, d[x]); Ls[x] = ++cnt;
	for(int i = 0; i < (int)e[x].size(); i++)
		d[e[x][i]] = d[x] + 1, dfs(e[x][i]);
	Rs[x] = cnt;
}

void add(int x, int &p, int l, int r, int k, int v){
	p = ++cnt, sum[p] = sum[x] + v;
	if (l == r) return;
	int m = (l + r) >> 1;
	if (k <= m) add(left[x], left[p], l, m, k, v), right[p] = right[x];
	else add(right[x], right[p], m + 1, r, k, v), left[p] = left[x];
}

int query(int p, int l, int r, int k){
	if (k < l) return 0;
	if (k >= r) return sum[p];
	int m = (l + r) >> 1;
	if (k <= m) return query(left[p], l, m, k);
	else return sum[left[p]] + query(right[p], m + 1, r, k);
}

int calc(int x, int y){
	if (!y) return d[x] - query(cur, 1, n, Ls[x]) + query(limit, 1, n, Ls[x]);
	return d[x] - d[y] - query(cur, 1, n, Ls[x]) + query(limit, 1, n, Ls[x]) + query(cur, 1, n, Ls[y]) - query(limit, 1, n, Ls[y]);
}

int find(int x, int top, int s){
	for (int k = L; k >= 0; k--){
		int y = up[x][k];
		if (d[y] < d[top]) continue;
		int t = calc(x, y);
		if (t < s) s -= t, x = y;
	}
	return x;
}

int solve(int x,int y,int step,int s){
	int lca = getLCA(x, y), v = calc(x, up[lca][0]), ret = -1;
	step += (attack[x] <= s);
	if (step <= v) ret = find(x, lca, step);
	else{
		step = step - v + (attack[lca] <= s);
		v = calc(y, up[lca][0]);
		if (step > v) ret = -1; else ret = find(y, lca, v - step + 1);
	}
	if (ret == x || ret == y) ret = -1;
	return ret;
}

int main(){
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		scanf("%d", &up[i][0]);
		if (!up[i][0]) root = i; else e[up[i][0]].push_back(i);
	}
	
	d[root] = 1; dfs(root);
	int k = 0;
	while ((1 << k) < L) k++;
	L = k;
	for (int k = 1; k <= L; k++)
		for (int i = 1; i <= n; i++)
			up[i][k] = up[up[i][k - 1]][k - 1];

	scanf("%d", &Q);
	for (int i = 1; i <= Q; i++){
		scanf("%d", &type);
		if(type == 1){
			scanf("%d", &x);
			add(T[i - 1], kth, 1, n, Ls[x], 1);
			if (Rs[x] < n) add(kth, T[i], 1, n, Rs[x] + 1, -1); else T[i] = kth;
			attack[x] = i;
		}else{
			T[i] = T[i - 1];
			scanf("%d%d%d%d", &x, &y, &kth, &s);
			cur = T[i], limit = T[s];
			printf("%d\n", solve(x, y, kth, s));
		}
	}
	return 0;
}
