/*
ID:huangta3
PROG:
LANG:C++
*/
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cmath>
#include <list>
#include <queue>
#include <vector>
#include <ctime>
#include <set>
#include <bitset>
#include <deque>
#include <fstream>
#include <stack>
#include <map>
#include <utility>
#include <cassert>
#include <string>
#include <iterator>
#include <cctype>
using namespace std;
const int maxn=100003;
int n,f[18][maxn],vis[maxn],Root,L[maxn],R[maxn],tot=0,lim,Log[maxn],depth[maxn],maxdepth,Q;
int Link[maxn],pre[maxn*2],t[maxn*2],root[maxn];
struct Ttree
{
    int ls,rs,sum;
}tree[maxn*18];
int get()
{
    int f=0,v=0;char ch;
    while(!isdigit(ch=getchar()))if(ch=='-')break;
    if(ch=='-')f=1;else v=ch-48;
    while(isdigit(ch=getchar()))v=v*10+ch-48;
    if(f==1)return -v;else return v;
}

void dfs(int x)
{
    L[x]=++tot; depth[x]=depth[f[0][x]]+1;
    maxdepth=max(maxdepth,depth[x]);
    for(int i=Link[x];i>0;i=pre[i])dfs(t[i]);
    R[x]=tot+1;
}

void modify(int &x,int pre,int l,int r,int num,int v)
{
    x=++tot; 
    tree[x]=tree[pre]; tree[x].sum+=v;
    if(l==r)return;
    int mid=(l+r)/2;
    if(num<=mid)modify(tree[x].ls,tree[pre].ls,l,mid,num,v);
    else modify(tree[x].rs,tree[pre].rs,mid+1,r,num,v);
}

int ask(int x,int l,int r,int num)
{
    if(num==0)return 0;
    if(num==r)return tree[x].sum;
    int mid=(l+r)/2;
    if(num<=mid)return ask(tree[x].ls,l,mid,num);
    else return tree[tree[x].ls].sum+ask(tree[x].rs,mid+1,r,num);
}

int query(int a,int b,int x,int y)
{
    x=f[0][x];
    return depth[y]-depth[x]-(ask(root[b],1,n,L[y])-ask(root[b],1,n,L[x]))+(ask(root[a],1,n,L[y])-ask(root[a],1,n,L[x]));
}

int lca(int x,int y)
{
    if(depth[x]<depth[y])swap(x,y);
    for(int i=lim;i>=0;i--)
        if((1<<i)&(depth[x]-depth[y]))x=f[i][x];
    for(int i=lim;i>=0;i--)
        if(f[i][x]!=f[i][y])x=f[i][x],y=f[i][y];
    if(x!=y)x=f[0][x];
    return x;
}

int query(int a,int b,int x,int y,int K)
{
    for(int i=lim;i>=0;i--)
    {
        int c=f[i][y],tp;
        if(depth[c]<depth[x])continue;
        tp=query(a,b,c,y);
        if(tp<K)K-=tp,y=f[0][c];
    }
    if((vis[y]<=a)<K)y=f[0][y];
    return y;
}

int main()
{
    n=get();
    for(int i=1;i<=n;i++)
    {
        int x=get();f[0][i]=x;
        if(x==0)Root=i;else pre[++tot]=Link[x],Link[x]=tot,t[tot]=i;
    }
    tot=0,dfs(Root);
    Log[0]=-1;
    for(int i=1;i<=maxdepth;i++)Log[i]=Log[i/2]+1;
    lim=Log[maxdepth];
    for(int i=1;i<=lim;i++)
        for(int j=1;j<=n;j++)f[i][j]=f[i-1][f[i-1][j]];
    Q=get();tot=0;
    for(int i=1;i<=Q;i++)
    {
        int t=get(),a,b,c,tp,K,y,m1=0,m2=0,m,res;
        if(t==1)
        {
            a=get();vis[a]=i;
            modify(root[i],root[i-1],1,n,L[a],1);
            if(R[a]<=n)modify(root[i],root[i],1,n,R[a],-1);
        }else
        {
            root[i]=root[i-1];
            a=get(),b=get(),K=get(),y=get();
            c=lca(a,b);
            if(vis[a]<=y)K++;
            m1=query(y,i,c,a),m2=query(y,i,c,b);
            m=m1+m2-(vis[c]<=y);
            if(m-(vis[b]<=y)<K){puts("-1");continue;}
            if(m1>=K)res=query(y,i,c,a,K);else res=query(y,i,c,b,m-K+1);
            printf("%d\n",res);
        }
    }
    return 0;
}
