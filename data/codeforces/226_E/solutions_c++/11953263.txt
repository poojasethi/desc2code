#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;
const int MAX = 100005;
const int SQRT = 333;
vector<int> adj[MAX];
int par[17][MAX], d[MAX], st[MAX], fi[MAX], c[MAX], fen[MAX], ans[MAX], num;
int get(int p)
{
	int ans = 0;
	for (p++; p < MAX; p += p & -p)
		ans += fen[p];
	return ans;
}
void _add(int p, int val)
{
	for (; p > 0; p -= p & -p)
		fen[p] += val;
}
void add(int l, int r, int val)
{
	_add(r, val);
	_add(l, -val);
}
void dfs(int p, int v)
{
	par[0][v] = p;
	for (int i = 1; i < 17; i++)
		par[i][v] = par[i - 1][par[i - 1][v]];
	st[v] = num++;
	for (int i = 0; i < adj[v].size(); i++)
	{
		int u = adj[v][i];
		if (u == p)
			continue;
		d[u] = d[v] + 1;
		dfs(v, u);
	}
	fi[v] = num;
	add(st[v], fi[v], 1);
}
int get_parent(int v, int k)
{
	for (int i = 0; i < 17; i++)
		if ((1 << i) & k)
			v = par[i][v];
	return v;
}
int lca(int u, int v)
{
	if (d[u] < d[v])
		swap(u, v);
	u = get_parent(u, d[u] - d[v]);
	if (u == v)
		return u;
	for (int i = 16; i >= 0; i--)
		if (par[i][u] != par[i][v])
		{
			u = par[i][u];
			v = par[i][v];
		}
	return par[0][v];
}
int get_ver(int u, int v, int k)
{
	int p = lca(u, v);
	if (k <= d[u] - d[p])
		return get_parent(u, k);
	k -= d[u] - d[p];
	k = d[v] - d[p] - k;
	return get_parent(v, k);
}
int get_cnt(int u, int v)
{
	int p = lca(u, v);
	if (u != p)
		u = par[0][u];
	else
		u = get_parent(v, d[v] - d[u] - 1);
	p = lca(u, v);
	int ans = get(st[u]) + get(st[v]) - get(st[p]);
	if (p != 0)
		ans -= get(st[par[0][p]]);
	return ans;
}
int get_ans(int u, int v, int k)
{
	int p = lca(u, v);
	int l = 0, r = d[u] + d[v] - 2 * d[p];
	while (r - l > 1)
	{
		int mid = (l + r) / 2;
		if (get_cnt(u, get_ver(u, v, mid)) < k)
			l = mid;
		else
			r = mid;
	}
	if (r == d[u] + d[v] - 2 * d[p])
		return -2;
	if (get_cnt(u, get_ver(u, v, r)) == k)
		return get_ver(u, v, r);
	return -2;
}
struct query
{
	int u, v, k, y, id;
	query()
	{
	}
	query(int _u, int _v, int _k, int _y, int _id)
	{
		u = _u;
		v = _v;
		k = _k;
		y = _y;
		id = _id;
	}
};
bool cmp(query a, query b)
{
	if (a.y / SQRT != b.y / SQRT)
		return (a.y / SQRT < b.y / SQRT);
	return (a.id < b.id);
}
int ll, rr;
void go(int l, int r)
{
	while (ll > l)
	{
		ll--;
		if (c[ll] != -1)
			add(st[c[ll]], fi[c[ll]], -1);
	}
	while (rr < r)
	{
		if (c[rr] != -1)
			add(st[c[rr]], fi[c[rr]], -1);
		rr++;
	}
	while (ll < l)
	{
		if (c[ll] != -1)
			add(st[c[ll]], fi[c[ll]], 1);
		ll++;
	}
	while (rr > r)
	{
		rr--;
		if (c[rr] != -1)
			add(st[c[rr]], fi[c[rr]], 1);
	}
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n;
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		int v;
		cin >> v;
		v--;
		if (v >= 0)
		{
			adj[i].push_back(v);
			adj[v].push_back(i);
		}
	}
	dfs(0, 0);
	int q;
	cin >> q;
	vector<query> qq;
	for (int i = 0; i < q; i++)
	{
		int t;
		cin >> t;
		if (t == 1)
			cin >> c[i];
		else
		{
			int u, v, k, y;
			cin >> u >> v >> k >> y;
			u--;
			v--;
			qq.push_back(query(u, v, k, y, i));
		}
		c[i]--;
	}
	sort(qq.begin(), qq.end(), cmp);
	for (int i = 0; i < qq.size(); i++)
	{
		go(qq[i].y, qq[i].id + 1);
		ans[qq[i].id] = get_ans(qq[i].u, qq[i].v, qq[i].k);
	}
	for (int i = 0; i < q; i++)
		if (c[i] == -1)
			cout << ans[i] + 1 << "\n";
	return 0;
}
