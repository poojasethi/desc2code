#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>

using namespace std;

#define IO(a,b) freopen(a,"r",stdin);\
				freopen(b,"w",stdout)
#define REP(i,n) for(int i=0;i<n;++i)
#define FOR(i,a,b) for(int i=a;i<=b;++i)
#define FORD(i,a,b) for(int i=a;i>=b;--i)
#define FOR_edge(i,x) for(int i=H[x];i;i=X[i])
#define mk make_pair
#define fi first
#define se second
#define LL long long

#define N 100010
#define TN 2000010

int n,king,t,p,q;
int H[N],E[N],X[N];
int f[N][20],D[N],St[N],En[N];;
int L[TN],R[TN],A[TN];
int root[N],Dtime[N];

void dfs(int x,int i=0){
	D[x]=D[f[x][0]]+1;
	for(i=0;i<18;++i)
		f[x][i+1]=f[f[x][i]][i];
	St[x]=++t;
	for(i=H[x];i;i=X[i]) dfs(E[i]);
	En[x]=t;	
}

inline int lca(int a,int b){
	if(D[a]>D[b]) swap(a,b);
	for(int i=0,delta=D[b]-D[a];delta;delta>>=1,++i)
		if(delta&1) b=f[b][i];
	if(a==b) return a;
	FORD(i,18,0)
		if(f[a][i]!=f[b][i])
			a=f[a][i],b=f[b][i];
	return f[a][0];
}

inline int node(int l,int r,int a){return ++p,L[p]=l,R[p]=r,A[p]=a,p;}

int add(int x,int l,int r,int lt,int rt,int delta){
	if(l==lt && r==rt) return node(L[x],R[x],A[x]+delta);
	int mid=(l+r)>>1;
	x=node(L[x],R[x],A[x]);
	if(lt<=mid) if(rt<=mid) L[x]=add(L[x],l,mid,lt,rt,delta);
	else L[x]=add(L[x],l,mid,lt,mid,delta),R[x]=add(R[x],mid+1,r,mid+1,rt,delta);
	else R[x]=add(R[x],mid+1,r,lt,rt,delta);
	return x;
}

int query(int x,int l,int r,int w){
	if(!x) return 0;
	if(l==r) return A[x];
	int mid=(l+r)>>1;
	if(w<=mid) return A[x]+query(L[x],l,mid,w);
	else return A[x]+query(R[x],mid+1,r,w);
}

inline int query(int w,int x,int y){
	return query(root[x],0,t,St[w])-query(root[y],0,t,St[w]);	
}

int main(){
	//IO("test.in","test.out");
	
	scanf("%d",&n);
	
	FOR(i,1,n){
		scanf("%d",&f[i][0]);
		if(f[i][0]) E[++t]=i,X[t]=H[f[i][0]],H[f[i][0]]=t;
		else king=i;
	}
	
	t=0;
	dfs(king);
	
	/*
	FOR(i,1,n){
		cout<<i<<" "<<D[i]<<" "<<St[i]<<" "<<En[i]<<" ";
		FOR(j,0,3) cout<<f[i][j]<<" ";
		cout<<endl;	
	}
	*/
	
	scanf("%d",&q);
	
	FOR(i,1,q){
		int type,a,b,c,k,y;
		
		scanf("%d",&type);
		
		if(type==1){
			scanf("%d",&a);
			Dtime[a]=i;
			root[i]=add(root[i-1],0,t,St[a],En[a],1);	
		}else{
			root[i]=root[i-1];
			
			scanf("%d%d%d%d",&a,&b,&k,&y);
			if(Dtime[a]<=y) ++k;
			
			c=lca(a,b);
			
			int qac=D[a]-D[f[c][0]]-query(a,i,y)+query(f[c][0],i,y);
			int qbc=D[b]-D[c]-query(b,i,y)+query(c,i,y);
			int start,tmp,qs;
			
			//cout<<a<<" "<<b<<" "<<c<<" "<<k<<" "<<qac<<" "<<qbc<<endl;
			
			if(qac+qbc<k){printf("-1\n");continue;}
			
			if(qac>=k) start=a; else start=b,k=qbc+1+qac-k;
			tmp=start;
			qs=query(start,i,y);
			
			//cout<<start<<" "<<k<<endl;
			
			FORD(j,18,0){
				int now=f[tmp][j];
			//	cout<<now<<" "<<D[start]<<" "<<D[now]<<" "<<qs<<" "<<query(now,i,y)<<endl;
				if(D[start]-D[now]-qs+query(now,i,y)<k) tmp=now;
			}
			
			if(tmp==a || tmp==b){printf("-1\n");continue;}
			
			printf("%d\n",tmp);
		}
	}
	
	return 0;
}
