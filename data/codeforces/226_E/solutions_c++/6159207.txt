#include <vector>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define pb push_back
using namespace std;
const int SIZE = 100100;
struct Fotile96
{
	int son[2], sum;
}t[SIZE * 20];
struct Question
{
	int T, a, b, k, y;
}ques[SIZE];
vector<int>nxt[SIZE];
int dep[SIZE], rmq[SIZE][20], root[SIZE], c[SIZE];
int N, M, tot, n;
void Read()
{
	scanf("%d", &N);
	for (int i = 1; i <= N; i++)
	{
		int x; scanf("%d", &x);
		nxt[x].pb(i);
	}
	scanf("%d", &M);
	for (int i = 1; i <= M; i++)
	{
		int ti; scanf("%d", &ti);
		if (ti == 1)
		{
			int x; scanf("%d", &x);
			c[x] = i;
		}
		else
		{
			ques[++tot].T = i;
			scanf("%d%d%d%d", &ques[tot].a, &ques[tot].b, &ques[tot].k, &ques[tot].y);
		}
	}
}
void Build(int p, int q, int d)
{
	int l = 0, r = M;
	while (l <= r)
	{
		int mid = (l + r) / 2;
		t[q] = t[p];
		t[q].sum++;
		
		if (l == r) break;
		
		if (d <= mid)
		{
			q = t[q].son[0] = ++n;
			p = t[p].son[0];
			
			r = mid;
		}
		else
		{
			q = t[q].son[1] = ++n;
			p = t[p].son[1];
			
			l = mid + 1;
		}
	}
}
int Query(int p, int q, int d)
{
	int res = 0;
	
	int l = 0, r = M;
	while (l <= r)
	{
		int mid = (l + r) / 2;
		
		if (l == r) break;
		
		if (d <= mid)
		{
			p = t[p].son[0];
			q = t[q].son[0];
			
			r = mid;
		}
		else
		{
			res += t[t[q].son[0]].sum - t[t[p].son[0]].sum;
			p = t[p].son[1];
			q = t[q].son[1];
			
			l = mid + 1;
		}
	}
	
	res += t[q].sum - t[p].sum;
	
	return res;
}
void Dfs(int x)
{
	Build(root[rmq[x][0]], root[x] = ++n, c[x]);
	
	for (int i = 1; i <= 16; i++)
		if (dep[x] - (1 << i) >= 1) rmq[x][i] = rmq[rmq[x][i - 1]][i - 1];
		else break;
	
	for (int k = 0; k < (int)nxt[x].size(); k++)
	{
		int y = nxt[x][k];
		
		rmq[y][0] = x;
		dep[y] = dep[x] + 1;
		Dfs(y);
	}
}
int LCA(int x, int y)
{
	if (dep[x] < dep[y]) swap(x, y);
	
	for (int i = 16; i >= 0; i--)
		if (dep[x] - (1 << i) >= dep[y]) x = rmq[x][i];
		
	if (x == y) return x;
	
	for (int i = 16; i >= 0; i--)
		if (dep[x] - (1 << i) >= 1 && rmq[x][i] != rmq[y][i])
		{	
			x = rmq[x][i];
			y = rmq[y][i];
		}
		
	return rmq[x][0];
}
int Move(int x, int step)
{
	for (int i = 16; i >= 0; i--)
		if (step - (1 << i) >= 0)
		{
			step -= (1 << i);
			x = rmq[x][i];
		}
	return x;
}
void Solve()
{
	for (int i = 1; i <= tot; i++)
	{	
		int ai = ques[i].a, bi = ques[i].b;
		int anc = LCA(ai, bi);
		int allstep = dep[ai] + dep[bi] - 2 * dep[anc] - 1;
		
		int l = 1, r = allstep, ans = -1;
		while (l <= r)
		{
			int mid = (l + r) / 2;
			int des = 0;
			int newbi;
			
			if (dep[ai] - mid >= dep[anc])
			{
				newbi = Move(ai, mid);
				des = Query(root[rmq[newbi][0]], root[rmq[ai][0]], ques[i].T) -
					  Query(root[rmq[newbi][0]], root[rmq[ai][0]], ques[i].y);
			}
			else
			{
				newbi = Move(bi, allstep - mid + 1);
				des = Query(root[rmq[anc][0]], root[rmq[ai][0]], ques[i].T) -
					  Query(root[rmq[anc][0]], root[rmq[ai][0]], ques[i].y) +
				
					  Query(root[anc], root[newbi], ques[i].T) - 
					  Query(root[anc], root[newbi], ques[i].y);
			}
			
			if (mid - des >= ques[i].k)
			{
				ans = newbi;
				r = mid - 1;
			}
			else
				l = mid + 1;
		}
		printf("%d\n", ans);
	}
}
int main()
{
	
	Read();
	dep[nxt[0][0]] = 1; Dfs(nxt[0][0]);
	Solve();
	return 0;
}