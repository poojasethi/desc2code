#include <bits/stdc++.h>

using namespace std;

#define NN 110000
#define inf 0x3f3f3f3f
#define eps 1e-8
#define eprintf(...) fprintf(stderr, __VA_ARGS__)

typedef pair<int, int> pii;
typedef long long INT;

int N, M, val[NN];
vector<int> adj[NN];
int par[NN][18], st[NN], en[NN], dp[NN], rid;
void dfs(int u) {
	st[u]=rid++;
	for (int i=0; i<adj[u].size(); i++) {
		int v=adj[u][i];
		dp[v]=dp[u]+1; dfs(v);
	}
	en[u]=rid;
}
int lca(int u, int v) {
	if (dp[u]>dp[v]) swap(u, v);
	for (int i=17; i>=0; i--) if (dp[v]-dp[u]>=(1<<i)) v=par[v][i];
	if (u==v) return u;
	for (int i=17; i>=0; i--) if (par[u][i]!=par[v][i]) u=par[u][i], v=par[v][i];
	return par[u][0];
}

struct Node {
	int sum;
	Node *ls, *rs;
} pool[2000000], *cur=pool, *rt[NN];

#define mid ((L+R)>>1)
Node *build(int L, int R) {
	Node *ans=cur++;
	ans->sum=0;
	if (R==L+1) return ans;
	ans->ls=build(L, mid);
	ans->rs=build(mid, R);
	return ans;
}
Node *add(Node *u, int L, int R, int p, int x) {
	Node *ans=cur++;
	*ans=*u;
	if (R==L+1) { ans->sum+=x; return ans; }
	if (p<mid) ans->ls=add(u->ls, L, mid, p, x), ans->rs=u->rs;
	else ans->ls=u->ls, ans->rs=add(u->rs, mid, R, p, x);
	ans->sum=ans->ls->sum+ans->rs->sum;
	return ans;
}
int calc(Node *s, Node *e, int p) {
	int ans=0, L=0, R=N+1;
	while (R-L>1) {
		if (p<mid) s = s->ls, e = e->ls, R = mid;
		else ans += e->ls->sum - s->ls->sum, s = s->rs, e = e->rs, L = mid;
	}
	ans += e->sum - s->sum;
	return ans;
}

int query(Node *s, Node *e, int u, int k) {
	for (int i=17; i>=0; i--) {
		int v=par[u][i];
		if (v==-1) continue;
		int cnt=(dp[u]-calc(s, e, st[u]))-(dp[v]-calc(s, e, st[v]));
		if (cnt<k) u=v, k-=cnt;
	}
	return u;
}

int state(int u, int y) {
	if (val[u]<=y) return 1;
	return 0;
}

int main() {
	int r;
	scanf("%d", &N);
	for (int i=0; i<N; i++) {
		scanf("%d", &par[i][0]);
		par[i][0]--;
		if (par[i][0]==-1) r=i;
		adj[par[i][0]].push_back(i);
	}
	dp[r]=1; dfs(r);
	for (int i=1; i<18; i++)
		for (int u=0; u<N; u++) {
			if (par[u][i-1]>=0) par[u][i]=par[par[u][i-1]][i-1];
			else par[u][i]=-1;
		}
	
	rt[0]=build(0, N+1);
	scanf("%d", &M);
	for (int i=1; i<=M; i++) {
		int type, u, v, k, y;
		scanf("%d", &type);
		if (type==1) {
			scanf("%d", &u); u--;
//			printf("** %d %d\n", st[u], en[u]);
			rt[i]=add(add(rt[i-1], 0, N+1, st[u], 1), 0, N+1, en[u], -1);
			val[u]=i;
		} else {
			scanf("%d%d%d%d", &u, &v, &k, &y); u--, v--;
			int p=lca(u, v);
			rt[i]=rt[i-1];
			int cu=dp[u]-calc(rt[y], rt[i], st[u])-state(u, y);
			int cv=dp[v]-calc(rt[y], rt[i], st[v])-state(v, y);
			int cp=dp[p]-calc(rt[y], rt[i], st[p]);
			int tot=cu+cv-cp*2+state(p, y);
//			printf("%d %d %d %d\n", cu, cv, cp, calc(rt[y], rt[i], st[v]));
			if (tot<k) { puts("-1"); continue; }
			if (cu-cp>=k) printf("%d\n", query(rt[y], rt[i], u, k+state(u, y))+1);
			else printf("%d\n", query(rt[y], rt[i], v, tot-k+1+state(v, y))+1);
		}
	}
	return 0;
}

                       