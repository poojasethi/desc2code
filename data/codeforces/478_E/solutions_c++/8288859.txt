#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#define INF 100000000000000LL
#define maxn 10000010
#define maxm 1000010
#define mod 10000000
#define each(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
using namespace std;
typedef long long LL;
int tot,F[20];
LL n,m,val[maxn];
int nEdge=1,to[maxm],next[maxm],start[maxn],sum[maxm];
void make(int a,int b)
{
    ++nEdge,to[nEdge]=b,next[nEdge]=start[a],start[a]=nEdge;
}
int cmp(int a,int b)
{
    if(a==b)
        return 0;
    return a<b?-1:1;
}
void DFS(int p)
{
    if(p>n)
    {
        if(n==2&&F[1]==F[2])
            return ;
        ++tot;
        for(int i=1;i<=n;++i)
            val[tot]=val[tot]*10+F[i];
        return ;
    }
    for(int i=0;i<=9;++i)
    {
        F[p]=i;
        if(p>=3&&(!cmp(F[p-1],F[p-2])||cmp(F[p-1],F[p-2])!=cmp(F[p-1],F[p])))
            continue;
        DFS(p+1);
    }
}
void Prepare()
{
    for(n=1;n<=7;++n)
        for(F[1]=1;F[1]<=9;++F[1])
            DFS(2);
}
bool check(LL p)
{
    static int stack[20];
    int tot=0;
    for(;p;p/=10)
        stack[++tot]=p%10;
    for(int i=2;i<tot;++i)
        if(!cmp(stack[i],stack[i-1])||cmp(stack[i],stack[i-1])!=cmp(stack[i],stack[i+1]))
            return false;
    return true;
}
void work()
{
    if(n>10000000)
    {
        LL i;
        for(i=n;i<=INF;i+=n)
            if(check(i)&&--m==0)
            {
                cout<<i<<endl;
                return ;
            }
        cout<<-1<<endl;
        return ;            
    }
    for(int i=1;i<=tot;++i)
        if(val[i]%n==0&&--m==0)
        {
            printf("%I64d\n",val[i]);
            return ;
        }
    for(int i=tot;i>=1;--i)
        make(val[i]%n,i);
    static int cnt[15][15];
    for(int i=0;i<n;++i)
        if(start[i])
        {
            int v1=(n-(LL)i*mod%n)%n;
            if(!start[v1])
                continue;
            memset(cnt,0,sizeof(cnt));
            for(int j=start[v1];j;j=next[j])
            {
                if(val[to[j]]>mod/10)
                    ++cnt[val[to[j]]/(mod/10)][val[to[j]]/(mod/100)%10];
                else if(val[to[j]]>mod/100&&val[to[j]]/(mod/1000)%10<val[to[j]]/(mod/100)%10)
                    ++cnt[0][val[to[j]]/(mod/100)%10];
            }
            for(int j=start[i];j;j=next[j])
            {
                int p=to[j];
                int a=val[p]%10,b=val[p]/10%10;
                if(val[p]<10)
                {
                    for(int t1=a+1;t1<=9;++t1)
                        for(int t2=t1-1;t2>=0;--t2)
                            sum[p]+=cnt[t1][t2];
                    for(int t1=a-1;t1>=0;--t1)
                        for(int t2=t1+1;t2<=9;++t2)
                            sum[p]+=cnt[t1][t2];
                }
                else if(a==b)
                    continue;
                else if(b>a)
                    for(int t1=a+1;t1<=9;++t1)
                        for(int t2=t1-1;t2>=0;--t2)
                            sum[p]+=cnt[t1][t2];
                else
                    for(int t1=a-1;t1>=0;--t1)
                        for(int t2=t1+1;t2<=9;++t2)
                            sum[p]+=cnt[t1][t2];
            }
        }
    for(int i=1;i<=tot;++i)
    {
        if(m>sum[i])
            m-=sum[i];
        else
        {
            for(int j=1;j<=tot;++j)
                if((val[i]*mod+val[j])%n==0&&check(val[i]*mod+val[j])&&--m==0)
                {
                    if(val[i]*mod+val[j]>INF)
                        printf("-1\n");
                    else
                        printf("%I64d%07I64d\n",val[i],val[j]);
                    return ;
                }
        }
    }
    printf("-1\n");
}
int main()
{
    Prepare();
    cin>>n>>m;
    work();
    return 0;
}