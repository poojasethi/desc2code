#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<ctime>
#include<cmath>
#include<algorithm>
#include<map>
#include<string>
using namespace std;

#define DIGS 10
#define ORIS 2
#define N 910000
#define M 800000
struct node { int cnt[DIGS][ORIS], sum[DIGS][ORIS], ptr[DIGS][ORIS]; };
struct tail { int64_t val; int nxt; };
int64_t que[N];
node nodes[M];
tail p[M];
int64_t n, m;
int cnt, tails;
int ori[100];
const int64_t SPLIT = 10000000LL;
const int64_t SPLIT_ = 1000000LL;
map<int64_t, node*> tail_map;

void init() {
	int i;
	for (i=0; i<100; ++i)
		if (i%10<i/10%10) ori[i]=1;
		else if (i%10>i/10%10) ori[i]=2;
		else ori[i]=0;
}

void head_bfs(int64_t x) {
	int i, j;
	if (!ori[x%100]) return;
	if (x>=SPLIT_) return;
	if (ori[x%100]==1)
		for (i=x%10+1; i<10; ++i) que[++que[0]]=x*10+i;
	else
		for (i=0, j=x%10; i<j; ++i) que[++que[0]]=x*10+i;
}

void tail_dfs(int64_t x, int st_1, int st_2, int ed_1, int ed_2, int digs) {
	int i, j;
	map<int64_t, node*>::iterator it;
	node *ptr;
	if (digs>=7) {
		if ((it=tail_map.find(x%n))==tail_map.end()) {
			ptr = &nodes[cnt];
			tail_map.insert(pair<int64_t, node*>(x%n, &nodes[cnt]));	
			memset(nodes[cnt].cnt, 0, sizeof(nodes[cnt].cnt));
			memset(nodes[cnt].ptr, 0, sizeof(nodes[cnt].ptr));
			++cnt;
		}
		else ptr = it->second;
		++tails;
		p[tails].val=x; p[tails].nxt=ptr->ptr[st_1][st_1<st_2];
		ptr->ptr[st_1][st_1<st_2]=tails;
		++(ptr->cnt[st_1][st_1<st_2]);
		return;
	}
	for (i=0; i<10; ++i)
		if ((ed_1-ed_2)*(i-ed_2)>0) tail_dfs(x*10+i, st_1, st_2, ed_2, i, digs+1);
}

void print(node *ret, int dig, int j, int m, int64_t head) {
	int i;
	if (!j)
		for (i=dig+1; i<10; ++i)
			if (ret->cnt[i][j]>=m) break;
			else m-=ret->cnt[i][j];
	else
		for (i=0; i<dig; ++i)
			if (ret->cnt[i][j]>=m) break;
			else m-=ret->cnt[i][j];
	m-=ret->cnt[i][j];
	for (i=ret->ptr[i][j]; i; i=p[i].nxt) {
		if (!m) { 
			cout<<head;
			if (p[i].val<SPLIT_)cout<<"0";
			cout<<p[i].val<<endl;
			return; 
		}
		++m;
	}
}

void conduct() {
	int i, j, k, dig;
	int64_t rem;
	map<int64_t, node*>::iterator it;
	for (que[0]=0, i=1; i<100; ++i) if (ori[i]) que[++que[0]]=i;
	for (i=10; i<=que[0]; ++i) head_bfs(que[i]);	
	tail_map.clear(); cnt=0; tails=0;
	for (i=0; i<10; ++i) for (j=0; j<10; ++j) if (i!=j) tail_dfs(i*10+j, i, j, i, j, 2);
	for (it=tail_map.begin(); it!=tail_map.end(); ++it) {
		for (it->second->sum[9][0]=0, i=8; ~i; --i) 
			it->second->sum[i][0]=it->second->sum[i+1][0]+it->second->cnt[i+1][0];
		for (it->second->sum[0][1]=0, i=1; i<10; ++i) 
			it->second->sum[i][1]=it->second->sum[i-1][1]+it->second->cnt[i-1][1];
	}
	for (i=1; i<=que[0]; ++i) {
		if (que[i]%n==0) m--;
		if (!m) {
			cout << que[i] << endl;
			return;
		}
	}
	for (i=1; i<=que[0]; ++i) {
		rem=n-(que[i]*SPLIT-1)%n-1;
		dig=que[i]%10;
		if (que[i]<10) k=3; else k=ori[que[i]%100];
		if ((it=tail_map.find(rem))!=tail_map.end()) 
			for (j=1; ~j; --j) if (k&(1<<j)) 
				if (it->second->sum[dig][j]>=m) { print(it->second, dig, j, m, que[i]); return; }
				else m-=it->second->sum[dig][j];
	}
	printf("-1\n");
}

int main() {
	init();
	while (cin >> n >> m) conduct();
	return 0;
}
