#include <iostream>
#include <cstdio>
#include <string.h>
#include <algorithm>
#include <cmath>
#include <vector>
#include <queue>
#include <set>
#include <bitset>
#include <stack>
#include <string>
#include <map>      
#define abs(x) ((x)>=0?(x):-(x))
#define i64 long long
#define u32 unsigned int
#define u64 unsigned long long
#define clr(x,y) memset(x,y,sizeof(x))
#define CLR(x) x.clear()
#define ph(x) push(x)
#define pb(x) push_back(x)
#define SZ(x) x.size()
#define PI acos(-1.0)
#define sqr(x) ((x)*(x))
#define MP(x,y) make_pair(x,y)
#define EPS 1e-7      
#define pii pair<int,int>
#define all(a) a.begin(),a.end()       
using namespace std;
const i64 Lim=1e14+5;
const int N=50005;
const int M=10000000;
i64 n,K;
vector<pair<int,int> > V[10][2];
bitset<M> a;
int f[M];
void output(i64 x)
{
    if(x<0) putchar('-'),x=-x;
    if(x==0)
    {
        putchar('0');
        return;
    }
    int a[20],num=0;
    while(x) a[++num]=x%10,x/=10;
    while(num>0) putchar('0'+a[num--]);
} 
inline i64 getInt()
{
    char c=getchar();
    while(!isdigit(c)&&c!='-') c=getchar();
    int flag=1;
    if(c=='-') flag=-1,c=getchar();
    i64 x=0;
    while(isdigit(c))
    {
        x=(x*10)+(c-'0');
        c=getchar();
    }
    if(flag==-1) return -x;
    return x;
}
void upMin(int &x,int y)
{
    if(x>y) x=y;
}
void upMax(int &x,int y)
{
    if(x<y) x=y;
}
int cal(int x,int y,i64 re,i64 &K)
{
    if(re>=M) return -1;
    int id1=lower_bound(V[x][y].begin(),V[x][y].end(),MP((int)re,0))-V[x][y].begin();
    int id2=lower_bound(V[x][y].begin(),V[x][y].end(),MP((int)re+1,0))-V[x][y].begin();
    if(id2-id1<K)
    {
        K-=id2-id1;
        return -1;
    }
    int i;
    for(i=id1;i<SZ(V[x][y]);i++)
    {
        K--;
        if(K==0) return V[x][y][i].second;
    }
    return -1;
}
i64 get()
{
    if(n>Lim/K) return -1;
    int i;
    for(i=1;i<M;i++) 
    {
        if(i/10%10==i%10) continue;
        int ff=i/10%10<i%10?1:-1;
        if(i<10||a[i/10]&&f[i/10]!=ff)
        {
            if(i<10) ff=0;
            a[i]=1;
            f[i]=ff;
            if(i%n==0)
            {if(--K==0) return i;}
        }
    }
    int b[15];
    clr(b,0);
    for(i=1;i<M;i++) 
    {
        b[0]++;
        int now=0;
        while(b[now]==10)
        {
            b[now]=0;
            b[now+1]++;
            now++;
        }
        int j;
        for(j=1;j<=5;j++) if((b[j]-b[j-1])*(b[j]-b[j+1])<=0) break;
        if(j<=5) continue;
        V[b[6]][b[6]<b[5]?1:0].pb(make_pair(i%n,i));
    }
    int j;
    for(i=0;i<10;i++) for(j=0;j<2;j++) sort(all(V[i][j]));
    for(int x=1;x<M;x++) if(a[x])
    {
        int flag=0;
        if(x>=10)
        {
            if(x/10%10<x%10) flag=1;
            else flag=-1;
        }
        i64 re=n-(i64)x*M%n;
        if(re==n) re=0;
        if(flag!=-1)
        {
            for(j=0;j<x%10;j++)
            {
                int s=cal(j,1,re,K);
                if(s!=-1) return (i64)x*M+s;
            }
        }
        if(flag!=1)
        {
            for(j=x%10+1;j<10;j++)
            {
                int s=cal(j,0,re,K);
                if(s!=-1) return (i64)x*M+s;
            }
        }
    }
    return -1;
}
int main()
{
    n=getInt();
    K=getInt();
    i64 ans=get();
    output(ans);
	return 0;
}