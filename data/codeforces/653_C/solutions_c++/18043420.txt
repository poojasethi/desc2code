#include<bits/stdc++.h>
using namespace std;
const int MAX=150005;
int t[MAX],n,p[MAX],ant;
bool ok(int i)
{
    if(i<1||i>=n)return 1;
    if(i&1&&t[i]>=t[i+1])return 0;
    if(!(i&1)&&t[i]<=t[i+1]) return 0;
    return 1;
}
bool check(int a,int b)
{
    swap(t[a],t[b]);
    int sum=1,k;
    /*for(k=1; k<n; k++)  n^2,TLE;(我是傻逼)，并不需要全部观察一边，只要观察交换那两个位置左右是否满足就行！！！
    {
        if(k&1&&t[k]<t[k+1])sum++;
        if(!(k&1)&&t[k]>t[k+1])sum++;
    }*/
    for(k=0; k<ant; k++)
        if(!ok(p[k]))sum=0;
    if(!ok(a)||!ok(a-1)||!ok(b)||!ok(b-1))sum=0;
    swap(t[a],t[b]);
    return sum;
}
int main()
{
    while(~scanf("%d",&n))
    {
        for(int i=1; i<=n; i++)
            scanf("%d",&t[i]);
        ant=0;
        for(int i=1; i<n; i++)
        {
            if(!ok(i))
                p[ant++]=i;
        }
        if(ant>4)
        {
            printf("0\n");
            continue;
        }
        int ans=0;
        for(int i=1; i<=n; i++)
        {
            if(check(p[0],i)){ans++;
            //printf("%d %d\n",t[p[0]],t[i]);
            }
            if(check(p[0]+1,i)){ans++;
            //printf("%d %d\n",t[p[0]+1],t[i]);
            }
        }
        if(check(p[0],p[0]+1))ans--;
        printf("%d\n",ans);
    }
}
