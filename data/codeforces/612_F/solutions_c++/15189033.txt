#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <iostream>
#include <list>
#include <vector>

using namespace std;

#define CLOCK true
#define CCLOCK false
#define LII list<int>::iterator
#define LLII list<list<int>*>::reverse_iterator
#define PLII pair<long int, int>
#define LONG 3*2000*2000

inline int dist(int a, int b, int n, bool clockwise) {
  if (clockwise) {
    if (a <= b)
      return b - a;
    else
      return n + b - a;
  } else {
    if (a < b)
      return n + a - b;
    else
      return a - b;
  } 
}

inline int short_dist(int a, int b, int n) {
  int c_dist;

  c_dist = dist(a, b, n, CLOCK);
  if (n < (c_dist << 1))
    return c_dist - n;
  else
    return c_dist;
}

inline LII pred(LII x, list<int> *l) {
  if (x == l->begin())
    x = l->end();
  x--;
  return x;
}

inline LII succ(LII x, list<int> *l) {
  x++;
  if (x == l->end())
    x = l->begin();
  return x;
}

inline void print(int x) {
  if (x >= 0)
    cout << "+";
  cout << x << endl;
}

int main() {
  int n, s;
  int i, j;
  int sd, sd2;
  int res_time, res_prev, res_next;
  bool res_clock;
  long int cur;
  list<int> *equals, *last;
  LII next, prev;
  list<list<int>*> layers;
  LLII next_layer;
  bool start_s;
  list<int> move;

  cin >> n >> s;
  s--;

  PLII *a = new PLII[n];
  vector<int> v_time(n), v_prev(n), v_next(n);
  vector<bool> v_clock(n);

  for (i=0; i<n; i++) {
    cin >> a[i].first;
    a[i].second = i;
  }

  sort(a, a+n);

  i = 0;
  last = new list<int>;
  last->clear();
  last->push_back(s);
  v_time[s] = 0;
  start_s = false;

  while (i < n) {
    cur = a[i].first;
    equals = new list<int>;
    equals->clear();
    equals->push_back(a[i].second);
    j = i+1;

    // find subinterval [i..j-1] of equal values
    while ((j < n) && (a[j].first == cur)) {
      equals->push_back(a[j].second);
      j++;
    }

    // compute shortest routes that finish in each of the equal value cells
    for (next=equals->begin(); next!=equals->end(); ++next) {
      res_time = LONG;
      res_prev = -1;
      res_next = -1;

      // try all previous endpoints
      for (prev=last->begin(); prev!=last->end(); ++prev) {

        if (equals->size() == 1) {
          // only one item with the same value
          sd = short_dist(*prev, *next, n);
          if (v_time[*prev] + abs(sd) < res_time) {
            res_time = v_time[*prev] + abs(sd);
            res_prev = *prev;
            res_next = *next;
            res_clock = (sd >= 0);
          }
        } else {
          // several items with the same value
          if (*prev == *next)
          // in the first iteration s may point to one of the equal values
            start_s = true;
          else {
            sd = short_dist(*prev, *succ(next, equals), n);
            sd2 = dist(*succ(next, equals), *next, n, CLOCK);

            if (v_time[*prev] + abs(sd) + sd2 < res_time) {
              res_time = v_time[*prev] + abs(sd) + sd2;
              res_prev = *prev;
              res_next = *succ(next, equals);
              res_clock = CLOCK;
            }

            sd = short_dist(*prev, *pred(next, equals), n);
            sd2 = dist(*pred(next, equals), *next, n, CCLOCK);

            if (v_time[*prev] + abs(sd) + sd2 < res_time) {
              res_time = v_time[*prev] + abs(sd) + sd2;
              res_prev = *prev;
              res_next = *pred(next, equals);
              res_clock = CCLOCK;
            } 
          }
        }
      }

      if (res_prev >= 0) {
        v_time[*next] = res_time;
        v_prev[*next] = res_prev;
        v_next[*next] = res_next;
        v_clock[*next] = res_clock;
      }
    }

    layers.push_back(equals);
    last = equals;
    if (start_s) {
      v_time[s] = LONG;
      v_prev[s] = -1;
      v_next[s] = -1;
      start_s = false;
    }
    i = j;
  }

  res_time = LONG;
  i = -1;
  for (next=last->begin(); next!=last->end(); ++next) {
    if (v_time[*next] < res_time) {
      res_time = v_time[*next];
      i = *next;
    }
  }

  cout << res_time << endl;

  for (next_layer=layers.rbegin(); next_layer!=layers.rend(); ++next_layer) {
    equals = *next_layer; 
    if (equals->size() == 1) {
      move.push_front(short_dist(v_prev[i], i, n));
    } else {
      next = equals->begin();
      while (*next != i)
        next++;
      if (v_clock[i]) {
        while (*pred(next, equals) != i) {
          move.push_front(dist(*pred(next, equals), *next, n, CLOCK));
          next = pred(next, equals);
        }
      } else {
        while (*succ(next, equals) != i) {
          move.push_front(-dist(*succ(next, equals), *next, n, CCLOCK));
          next = succ(next, equals);
        }
      }
      move.push_front(short_dist(v_prev[i], v_next[i], n));
    }
    i = v_prev[i];
  }

  for (next=move.begin(); next!=move.end(); ++next)
    print(*next);
}