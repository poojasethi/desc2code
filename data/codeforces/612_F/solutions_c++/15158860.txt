/*
 * main.cpp
 *
 *  Created on: 2015年12月27日
 *      Author: Chihao
 */

#include <iostream>
#include <cstdio>
#include <string>
#include <vector>
#include <map>
#include <list>
#include <algorithm>
#include <set>
#include <stdlib.h>
#include <cctype>
#include <memory.h>
#include <queue>
#include <cmath>
#include <stack>
using namespace std;

int n, s;
struct Node
{
	int val;
	int pos;
	Node(){}
};
Node a[2005];
static bool cmpval(const Node & a, const Node & b)
{
	if(a.val == b.val){
		return a.pos < b.pos;
	}
	else{
		return a.val < b.val;
	}

}

bool find_next(int v, int & start, int & end)
{
	for(end = start;end < n;++end) {
		if(v == a[end].val) {
			++end;
		}
	}
	return (end > start);
}
int ans[2005][5] = {0};//val, from, val1, direct1, direct2

inline void distance(int p1, int p2, int & dist, int & direct)
{
	if(p1 > p2)
	{
		dist = p1 - p2;
		direct = 1;
		if(dist > p2 + n - p1)
		{
			dist = p2 + n - p1;
			direct = 0;
		}
	}
	else
	{
		dist = p2 - p1;
		direct = 0;
		if(dist > p1 + n - p2)
		{
			dist = p1 + n - p2;
			direct = 1;
		}
	}
}

int segment[2005][2] = {0};
int segs = 1;


void output(int pos, int level)
{
	if(level == 0)
	{
		return;
	}
	output(ans[pos][1], level - 1);
	if(ans[pos][3] == 0)
	{
		printf("+");
	}
	else
	{
		printf("-");
	}
	printf("%d\n", ans[pos][2]);
	int l = segment[level][0], r = segment[level][1];
	if(ans[pos][4] == 0)
	{
		int curr = pos - 1;
		if(curr == l - 1)
		{
			curr = r - 1;
		}
		for(int i = 0;i < r - l - 1;++i)
		{
			int tar = curr - 1;
			int val = a[curr].pos - a[tar].pos;
			if(tar == l - 1)
			{
				tar = r - 1;
				val = a[curr].pos - a[tar].pos + n;
			}
			printf("-%d\n", val);
			curr = tar;
		}
	}
	else
	{
		int curr = pos + 1;
		if(curr == r)
		{
			curr = l;
		}
		for(int i = 0;i < r - l - 1;++i)
		{
			int tar = curr + 1;
			int val = a[tar].pos - a[curr].pos;
			if(tar == r)
			{
				tar = l;
				val = a[tar].pos - a[curr].pos + n;
			}
			printf("+%d\n", val);
			curr = tar;
		}
	}
}

int main()
{
	scanf("%d%d", &n, &s);
	for(int i = 1;i <= n;++i)
	{
		scanf("%d", &a[i].val);
		a[i].pos = i;
		if(s == i)
		{
			a[0].pos = i;
		}
	}
	sort(a + 1, a + n + 1, cmpval);
	segment[0][0] = 0;
	segment[0][1] = 1;
	for(int i = 1;i <= n;++i)
	{
		int j = 0;
		for(j = i;j <= n;++j)
		{
			if(a[j].val != a[i].val)
			{
				break;
			}
		}
		segment[segs][0] = i;
		segment[segs][1] = j;
		i = j - 1;
		++segs;
	}
	for(int i = 0;i <= n;++i)
	{
		ans[i][0] = 0x7fffffff;
	}
	ans[0][0] = 0;
	ans[0][1] = 0;
	for(int i = 1;i < segs;++i)
	{
		for(int start = segment[i - 1][0];start < segment[i - 1][1];++start)
		{
			int x = a[start].pos;
			for(int end = segment[i][0];end < segment[i][1];++end)
			{
				int y = a[end].pos;

				int dist1 = 0, direct1 = 0;
				int dist2 = 0, direct2 = 0;

				int end1 = end + 1;
				dist2 = n - a[end1].pos + y;
				if(end1 == segment[i][1])
				{
					end1 = segment[i][0];
					dist2 = y - a[end1].pos;
				}
				if(segment[i][1] - segment[i][0] == 1)
				{
					dist2 = 0;
				}
				int y1 = a[end1].pos;
				distance(x, y1, dist1, direct1);
				if(ans[end][0] >= ans[start][0] + dist1 + dist2)
				{
					ans[end][0] = ans[start][0] + dist1 + dist2;
					ans[end][1] = start;
					ans[end][2] = dist1;
					ans[end][3] = direct1;
					ans[end][4] = 1;
				}
				int end2 = end - 1;
				dist2 = n - y + a[end2].pos;
				if(end == segment[i][0])
				{
					end2 = segment[i][1] - 1;
					dist2 = a[end2].pos - y;
				}
				if(segment[i][1] - segment[i][0] == 1)
				{
					dist2 = 0;
				}
				int y2 = a[end2].pos;
				distance(x, y2, dist1, direct1);
				if(ans[end][0] > ans[start][0] + dist1 + dist2)
				{
					ans[end][0] = ans[start][0] + dist1 + dist2;
					ans[end][1] = start;
					ans[end][2] = dist1;
					ans[end][3] = direct1;
					ans[end][4] = 0;
				}
			}
		}
	}
	int pos = 0;
	int maxv = 0x7fffffff;
	for(int i = segment[segs - 1][0];i < segment[segs - 1][1];++i)
	{
		if(ans[i][0] < maxv)
		{
			maxv = ans[i][0];
			pos = i;
		}
	}
	printf("%d\n", maxv);
	output(pos, segs - 1);
}
