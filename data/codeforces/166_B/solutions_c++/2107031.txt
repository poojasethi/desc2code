# include <iostream>
# include <algorithm>
# include <complex>

# define X real()
# define Y imag()
# define LL long long
using namespace std;
const int MAX_N=100*1000+10;
typedef complex<LL> Point;
typedef pair<LL,LL> PDD;

bool operator <(const Point &A,const Point &B){return PDD(A.X,A.Y)<PDD(B.X,B.Y);} 
Point A[MAX_N],B[MAX_N];
LL N,M,Ans;

bool Less(const Point &A,const Point &B){return PDD(A.X,A.Y)<PDD(B.X,B.Y);}
LL Dot(const Point &A,const Point &B){return (A.X*B.X)+(A.Y*B.Y);}
LL Crs(const Point &A,const Point &B){return (A.X*B.Y)-(A.Y*B.X);}


int main()
{
	ios::sync_with_stdio(false);
	cin  >> N;
	for(int i=0;i<N;i++)
			cin >> A[i].X >> A[i].Y;
	cin >> M;
	for(int i=0;i<M;i++)
			cin >> B[i].X >> B[i].Y;
	reverse(A,A+N);
	for(int i=0;i<M;i++)
	{
		int F=1,L=N-1,Mid=0;
		if(Crs(A[1]-A[0],B[i]-A[0])<=0)
				continue;
		if(Crs(A[N-1]-A[0],B[i]-A[0])>=0)
				continue;	    
		while(F!=L)
		{
			Mid=(F+L+1)/2;
			if(Crs(A[Mid]-A[0],B[i]-A[0])>=0)
					F=Mid;
			else
					L=Mid-1;
		}
		if(Crs(A[L+1]-A[L],B[i]-A[L])>0)
				Ans++;
	}
	cout<<(Ans==M?"YES":"NO")<<endl;
	return 0;
}
