#include <iostream>
#include <complex>
using namespace std;
typedef complex<double> point;
#define X real()
#define Y imag()
#define eps 1e-8
const int MAXN=1000*100+10;
int n,m,ans;
point A[MAXN],P;
bool equal(double x,double y)
{
	return abs(x-y)<eps;
}
double cross(point a,point b)
{
	return a.X*b.Y - a.Y*b.X;
}
bool isPonLine(point P,point A,point B)
{
	return abs(cross(P-A,B-A))<0+eps;
//	return equal(abs(P-A)+abs(P-B),abs(A-B));
}
bool check(point P)
{
	int s=1,e=n;
	while(s<e-1)
	{
		int mid=(s+e)/2;
		if(cross(P-A[0],A[mid]-A[0])>0-eps)
			s=mid;
		else
			e=mid;
	}
	double p1=cross(P-A[0],A[s]-A[0]);
	if(e==n)
	{
//		if(isPonLine(P,A[0],A[n-1]))
//			return true;
		return false;
	}
	if(s==1&&isPonLine(P,A[0],A[1]))
		return false;
	if(p1<0-eps)
		return false;
	if(cross(A[e]-A[s],P-A[s])>0-eps)
		return false;
	return true;
}
int main()
{
	cin >> n;
	for(int i=0;i<n;i++)
		cin >> A[i].X >> A[i].Y;
	cin >> m;
	for(int i=0;i<m;i++)
	{
		cin >> P.X >> P.Y;
		if(check(P))
			ans++;
	}
	cout << (ans==m ? "YES" : "NO") << endl;
	return 0;
}
