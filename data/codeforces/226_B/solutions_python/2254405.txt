# def dummy_(A, K):
#   if len(A) == 1:
#     return 0
#   best = None
#   for i in xrange(len(A)):
#     for j in xrange(len(A)):
#       if i != j:
#         B = list(A)
#         iS, iK = B[i]
#         jS, jK = B[j]
#         if iK < K:
#           B.pop(max(i, j))
#           B.pop(min(i, j))
#           B.append((iS + jS, iK + 1))
#           d = dummy_(B, K)
#           if d is not None:
#             cost = d + jS
#             if best is None or best > cost:
#               best = cost
#   return best

# def dummy(A, Q):
#   return [dummy_([(a, 0) for a in A], K) for K in Q]

def breakdown(N, K):
  KK = 1
  f = 0
  while f < N:
    yield f, min(N, f + KK)
    f += KK
    KK *= K

def solve(A, Q):
  N = len(A)
  A.sort(lambda a, b: cmp(b, a))
  S = [0 for _ in xrange(N + 1)]
  for i in xrange(N):
    S[i + 1] = S[i] + A[i]
  res = []
  cache = {}
  for K in Q:
    if cache.get(K) is not None:
      res.append(cache[K])
      continue
    R = 0
    p = 0
    for f, t in breakdown(N, K):
      R += (S[t] - S[f]) * p
      p += 1
    cache[K] = R
    res.append(R)
  return res

# import random
# A = [random.randint(1, 1000000000) for _ in xrange(4)]
# Q = range(1, 4)# [random.randint(1, 100000) for _ in xrange(100000)]
# print solve(A, Q)
# print dummy(A, Q)
import sys
inp = sys.stdin
inp.readline()
A = map(int, inp.readline().split())
inp.readline()
Q = map(int, inp.readline().split())
print ' '.join(map(str, solve(A, Q)))
