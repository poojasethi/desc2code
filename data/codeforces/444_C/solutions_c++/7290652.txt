#include <iostream>
#include <cmath>
using namespace std;

typedef pair<int, int> PP;
typedef long long LL;
#define pb push_back
#define fr first
#define sc second

struct node{
	int l, r, x;
	LL sum, lazy;
	node *lt, *rt;
	node(int a, int b) : l(a), r(b), x(-1), sum(0), lt(NULL), rt(NULL), lazy(0){
		if (r == l) x = l + 1;
		else {
			int mid = (l + r) >> 1;
			lt = new node(l, mid);
			rt = new node(mid + 1, r);
		}
	}
	~node(){
		if (lt) delete lt, delete rt;
	}
	void pass(){
		lt->x = rt->x = x;
		lt->sum += lazy * (lt->r - lt->l + 1);
		rt->sum += lazy * (rt->r - rt->l + 1);
		lt->lazy += lazy;
		rt->lazy += lazy;
		lazy = 0;
	}
	void update(int y, int a, int b){
		if (a <= l && b >= r && x >= 0) {
			sum += (LL)(r - l + 1) * abs(y - x);
			lazy += abs(y - x); 
			x = y;
		}
		else {
			if (x >= 0 && lazy) pass();
			int mid = (l + r) >> 1;
			if (a <= mid) lt->update(y, a, b);
			if (b > mid) rt->update(y, a, b);
			sum = lt->sum + rt->sum;
			x = -1;
			if (a <= l && b >= r) x = y;
		}
	}

	LL query(int a, int b){
		if (a <= l && b >= r) return sum;
		if (x >= 0) pass();
		LL res = 0;
		int mid = (l + r) >> 1;
		if (a <= mid) res += lt->query(a, b);
		if (b > mid) res += rt->query(a, b);
		return res;
	}
};
int main() {
	#ifdef _TEST_
	freopen("input.txt", "r", stdin);
	//freopen("out.txt", "w", stdout);
	#endif
	int n, m;
	cin >> n >> m;
	node t(0, n - 1);
	for (int i = 0; i < m; i ++) {
		int op; cin >> op;
		if (op == 1) {
			int l, r, x;
			cin >> l >> r >> x;
			t.update(x, l - 1, r - 1);
		}
		else {
			int l, r;
			cin >> l >> r;
			cout << t.query(l - 1, r - 1) << endl;;
		}
	}
	return 0;
}
