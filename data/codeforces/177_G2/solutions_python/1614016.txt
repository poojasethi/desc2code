//In the name of Allah
//
//
//////////////////////
// Program: 
// Written By Alireza Farhadi (LGM)
//////////////////////
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <cctype>
#include <cmath>
#include <queue>
#include <stack>
#include <set>
#include <utility>
#include <vector>
#include <bitset>
#include <deque>
#include <iomanip>
#include <complex>
#include <fstream>
#include <sstream>
#include <map>
//#include <climits>
//#include <list>

using namespace std;

#if ( _WIN32 || __WIN32__ )
    #define LLD "%I64d"
#else
    #define LLD "%lld"
#endif

#define show(x) cerr<<((#x))<<" = "<<((x))<<" "<<endl
#define bit(a,b) (((a)>>(b))&1)
#define gcd __gcd
#define endl '\n'
#define bcnt(x) ((__builtin_popcount(x)))
#define sz(x) ((int((x).size())))
#define sqr(x) ((((x))*((x))))
#define fx(x) fixed<<setprecision(x)

template<class T> inline void smn(T &a,const T &b){if(b<a) a=b;}
template<class T> inline void smx(T &a,const T &b){if(b>a) a=b;}
template<class T> inline T rev(const T & a){T _=a; reverse(_.begin(),_.end()); return _;}

typedef long long ll;
typedef long double ld;
typedef pair<int,int> pie;

const double eps=1e-9;
const ld leps=1e-14;
const int MOD=1000*1000*1000+7,MN=100000+10,ML=31;
const ll key=701;
ll hash[MN];
ll pw[MN];
int size[ML];
ll fh[MN];
int mid[ML];
int d[ML];
bool e[ML][MN],s[ML][MN];
int sm[ML][MN],em[ML][MN];
int cnt=1;
string fib[MN];
ll n; int m;
string inp;
ll mh(string a)
{
	ll now=0;
	for (int i=0;i<sz(a);i++)
		now=key*now+a[i];
	return now;
}
ll fnd(int s,int e)
{
	ll res=hash[e];
	if (s>0)
		res-=pw[e-s+1]*hash[s-1];
	return res;
}
bool av1(int a,int b)
{
	if (a<0) return 0;
	if (size[a]<b+1) return 0;
	bool & res=s[a][b];
	if (sm[a][b]==cnt) return res;
	sm[a][b]=cnt;
	res=0;
	if (size[a]==b+1)
	{
		if (fh[a]==fnd(0,b))
			return res=1;
		return res=0;
	}
	if (a>1 && size[a-2]>=b+1)
		return res=av1(a-2,b);
	if (fnd(b-size[a-2]+1,b)!=fh[a-2])
		return res=0;
	return res=av1(a-1,b-size[a-2]);
}
bool av2(int a,int b)
{
	int bs=sz(inp)-b;
	if (a<0) return 0;
	if (size[a]<bs) return 0;
	bool & res=e[a][b];
	if (em[a][b]==cnt) return res;
	em[a][b]=cnt;
	res=0;
	if (size[a]==bs)
	{
		if (fh[a]==fnd(b,sz(inp)-1))
			return res=1;
		return res=0;
	}
	if (a>=1 && size[a-1]>=bs)
		return res=av2(a-1,b);
	if (fnd(b,b+size[a-1]-1)!=fh[a-1])
		return res=0;
	return res=av2(a-2,b+size[a-1]);
}
int midcal(int a,int b)
{
	int res=0;
	for (int i=0;i<sz(inp)-1;i++) 
		if (av1(a,i) && av2(b,i+1))
			res++;
	return res;
}
int fll(int a)
{
	if (a<0) return 0;
	int & res=d[a];
	if (d[a]!=-1) return d[a];
	if (size[a]==sz(inp) && fib[a]==inp) return res=1;
	if (size[a]<=sz(inp)) return res=0; 
	res=fll(a-1)+fll(a-2);
	res%=MOD;
	res+=midcal(a-1,a-2);
	res%=MOD;
	return res;
}
struct mat
{
	int v[2][2];
	mat() { memset(v,0,sizeof(v));}
};
mat operator * (const mat & a,const mat & b)
{
	mat res;
	for (int i=0;i<2;i++) for (int j=0;j<2;j++)
	{
		int now=0;
		for (int k=0;k<2;k++)
			now+=((ll(a.v[i][k])*b.v[k][j])%MOD),now%=MOD;
		res.v[i][j]=now;
	}
	return res;
}
mat pow(const mat & a,ll b)
{
	mat s,q=a;
	s.v[0][0]=s.v[1][1]=1;
	while (b)
	{
		if (b%2)
			s=s*q;
		b/=2;
		if (b)
			q=q*q;
	}
	return s;
}
mat start;
int f(ll a)
{
	if (a<=0) return 0;
	mat temp=pow(start,a);
	return temp.v[0][1];
}
ll calc(ll n)
{
	if (n<=0) return 0;
	if (n%2==1) return f(n+1);
	return f(n+1)-1;
}
int calc(int a,int b,int c,int d,ll n)
{
	ll z1=calc(n-1);
	ll z2=calc(n-2);
	ll res=ll(b)*f(n)+ll(a)*f(n-1)+ll(c)*z1+ll(d)*z2;
	res%=MOD;
	return res;
}
int main(int argc,char * argv[])
{
	ios_base::sync_with_stdio(false);
	cin>>n>>m;
	for (int i=0;i<=1000*100;i++) if (i==0)
		pw[i]=1;
	else
		pw[i]=key*pw[i-1];
	fib[0]="a";
	fib[1]="b";
	int mx=min(1LL,n-1);
	for (int i=0;i<2;i++) for (int j=0;j<2;j++) if (i==0 && j==0) start.v[i][j]=0;
	else
		start.v[i][j]=1;
	size[0]=size[1]=1;
	for (int i=2;i<n && size[i-1]+size[i-2]<=1000000;i++)
	{
		fib[i]=fib[i-1]+fib[i-2],size[i]=size[i-1]+size[i-2];
		mx=i;
	}
	for (int i=0;i<mx;i++) fh[i]=mh(fib[i]);
	for (int i=0;i<m;i++)
	{
		cin>>inp;
		for (int i=0;i<inp.size();i++) if (i==0)
			hash[i]=inp[i];
		else
			hash[i]=key*hash[i-1]+inp[i];
		memset(mid,0,sizeof(mid));
		memset(d,-1,sizeof(d));
		fll(mx);
		if (mx==n-1)
		{
			cout<<fll(mx)<<endl;
			cnt++;
			continue;
		}
		int a=fll(mx-1),b=fll(mx),c=midcal(mx-2,mx-1),d=midcal(mx-3,mx-1);
		cerr<<"a = "<<a<<" "<<b<<" "<<c<<" "<<d<<endl;
		cout<<calc(a,b,c,d,n-mx)<<endl;
		cnt++;
	}
	return 0;
}
