#include <cstring>
#include <iostream>
#include <algorithm>
#include <string>

using namespace std;

const int MOD = 1000000007;

struct matrix
{
    int M[4][4];

    matrix()
    {
        memset(M, 0, sizeof(M));
    }
};

matrix one, stand;

matrix operator * (matrix M1, matrix M2)
{
    matrix M3;
    for (int i = 0; i < 4; ++i)
        for (int j = 0; j < 4; ++j)
        {
            long long val = 0;
            for (int k = 0; k < 4; ++k)
                val += 1LL * M1.M[i][k] * M2.M[k][j];
            M3.M[i][j] = val % MOD;
        }
    return M3;
}
matrix power(matrix X, long long ex)
{
    if (ex == 0) return one;
    if (ex & 1) return X * power(X, ex - 1);
    return power(X * X, ex >> 1);
}

long long N, M;
int Q[100002], C[4];
char A[100002];

int get_times(int size, string S, int lim1, int lim2)
{
    int qnow = 0;
    for (int i = 2; i <= size; ++i)
    {
        while (qnow != 0 && A[i] != A[qnow + 1])
            qnow = Q[qnow];
        if (A[i] == A[qnow + 1])
            ++qnow;
        Q[i] = qnow;
    }

    int matchnow = 0, totmatches = 0;
    for (int i = 0; i < int(S.size()); ++i)
    {
        while (matchnow != 0 && S[i] != A[matchnow + 1])
            matchnow = Q[matchnow];
        if (S[i] == A[matchnow + 1])
            ++matchnow;

        if (matchnow == size)
        {
            if (i - size + 1 >= lim1 && i - size + 1 <= lim2) ++totmatches;
            matchnow = Q[matchnow];
        }
    }

    return totmatches;
}

int main()
{
    for (int i = 0; i < 4; ++i)
        one.M[i][i] = 1;
    stand.M[0][0] = stand.M[1][0] = stand.M[2][0] = stand.M[0][1] = stand.M[3][2] = stand.M[2][3] = 1;

    cin >> N >> M;
    for (int i = 1; i <= M; ++i)
    {
        cin >> (A + 1);

        int size = 0;
        for (int j = 1; A[j] != '\0'; ++j)
            ++size;

        int fib1 = 1, fib2 = 1, numnow = 0;
        while (fib1 < size)
        {
            int auxfib = fib2;
            fib2 = fib1 + fib2;
            fib1 = auxfib;

            ++numnow;
        }

        string s1, s2;
        s1 = "a";
        s2 = "b";

        for (int j = 1; j <= numnow; ++j)
        {
            string saux = s2;
            s2 += s1;
            s1 = saux;
        }

        if (N - (numnow + 1) <= 1) // it can be computed by a single KMP
        {
            if (N - (numnow + 1) < 0)
            {
                cout << 0 << '\n';
                continue;
            }

            while (N - (numnow + 1) > 0)
            {
                string saux = s2;
                s2 += s1;
                s1 = saux;
                ++numnow;
            }

            cout << get_times(size, s1, 0, s1.size() - 1) << '\n';

            continue;
        }

        int times_a = get_times(size, s1, 0, s1.size() - 1);
        int times_b = get_times(size, s2, 0, s2.size() - 1);
        int times_ab = get_times(size, s1 + s2, s1.size() - size + 1, s1.size() - 1);
        int times_ba = get_times(size, s2 + s1, s2.size() - size + 1, s2.size() - 1);
        int times_bb = get_times(size, s2 + s2, s2.size() - size + 1, s2.size() - 1);

        // I consider "a" and "b" fixed

        matrix now = power(stand, N - numnow - 2);

        int num_a = 0;
        C[0] = 0, C[1] = 1, C[2] = 0, C[3] = 0;
        for (int j = 0; j < 4; ++j)
            num_a = (num_a + 1LL * now.M[j][0] * C[j]) % MOD;

        int num_b = 0;
        C[0] = 1, C[1] = 0, C[2] = 0, C[3] = 0;
        for (int j = 0; j < 4; ++j)
            num_b = (num_b + 1LL * now.M[j][0] * C[j]) % MOD;

        int num_ab = 0;
        C[0] = 0, C[1] = 0, C[2] = 0, C[3] = 1;
        for (int j = 0; j < 4; ++j)
            num_ab = (num_ab + 1LL * now.M[j][0] * C[j]) % MOD;

        now = power(stand, N - numnow - 3);

        int num_ba = 0;
        C[0] = 1, C[1] = 0, C[2] = 0, C[3] = 0;
        for (int j = 0; j < 4; ++j)
            num_ba = (num_ba + 1LL * now.M[j][0] * C[j]) % MOD;

        int num_bb = 0;
        C[0] = 0, C[1] = 0, C[2] = 0, C[3] = 1;
        for (int j = 0; j < 4; ++j)
            num_bb = (num_bb + 1LL * now.M[j][0] * C[j]) % MOD;

        long long result = 1LL * times_ba * num_ba + 1LL * times_ab * num_ab + 1LL * times_bb * num_bb + 1LL * times_a * num_a + 1LL * times_b * num_b;
        result %= MOD;

        cout << result << '\n';
    }
}
