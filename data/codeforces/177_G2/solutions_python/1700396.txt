#include<stdio.h>
#include<string.h>
#include<algorithm>
#include<iostream>
using namespace std;
#define N 510000
#define ll __int64
#define MN 28
const ll mod=1000000007;
char fib[30][N];
int len[30];
#define SZ 5
class Matrix{
public:
    int n,m;
    ll s[SZ][SZ];
    Matrix(){}
    Matrix(int t){
        n=m=t;
        memset(s,0,sizeof(s));
        for(int i=0;i<n;i++)
        s[i][i]=1;
    }
    Matrix(int _n,int _m,ll *sp,int ps){
        n=_n,m=_m;
        memset(s,0,sizeof(s));
        int x,y;
        x=y=0;
        for(int p=0;p<ps;p++){
            s[x][y++]=sp[p];
            if(y>=m) x++,y=0;
        }
    }
    Matrix(int _n,int _m){
        n=_n,m=_m;
        memset(s,0,sizeof(s));
    }
    Matrix(const Matrix &p){
        n=p.n,m=p.m;
        memcpy(s,p.s,sizeof(s));
    }
    void debug(){
        printf("(%d, %d):\n",n,m);
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                cout<<s[i][j]<<" ";
            }
            cout<<endl;
        }
    }
    void clc(){
        memset(s,0,sizeof(s));
    }
    Matrix operator+(const Matrix b){
        Matrix tmp(*this);
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                tmp.s[i][j]+=b.s[i][j];
                if(tmp.s[i][j]>=mod) tmp.s[i][j]%=mod;
            }
        }
        return tmp;
    }
    Matrix operator-(const Matrix b){
        Matrix tmp(*this);
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                tmp.s[i][j]-=b.s[i][j];
            }
        }
        return tmp;
    }
    Matrix operator*(const Matrix b){
        Matrix tmp(n,b.m);
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(!s[i][j]) continue;
                for(int k=0;k<b.m;k++){
                    if(!b.s[j][k]) continue;
                    tmp.s[i][k]+=(s[i][j])*(b.s[j][k]);
                    if(tmp.s[i][k]>=mod) tmp.s[i][k]%=mod;
                }
            }
        }
        return tmp;
    }
    Matrix operator^(ll k){
        Matrix ans(n),tmp(*this);
        while(k){
            if(k&1) ans=ans*tmp;
            tmp=tmp*tmp;
            k>>=1;
        }
        return ans;
    }
};
ll k;
int m;
Matrix fa,fb;
void init(){
    strcpy(fib[0],"a"),strcpy(fib[1],"b");
    len[0]=len[1]=1;
    for(int i=2;i<MN;i++){
        strcpy(fib[i],fib[i-1]);
        strcat(fib[i],fib[i-2]);
        len[i]=len[i-1]+len[i-2];
    }
    ll t1[16]={1,1,1,0,1,0,0,0,0,0,1,0,0,0,0,1};
    fa=Matrix(4,4,t1,16);
    ll t2[16]={1,1,0,1,1,0,0,0,0,0,1,0,0,0,0,1};
    fb=Matrix(4,4,t2,16);
}
int fail[N];
template <class T>
void GetFail(T b[],int l){
    int i,j;
    fail[0]=-1;
    for(i=1,j=-1;i<l;i++){
        while(j>=0&&b[i]!=b[j+1])
        j=fail[j];
        if(b[j+1]==b[i])j++;
        fail[i]=j;
    }
}
template<class T>
int KMP(T a[],T b[],int la,int lb){
    int i,j,cnt=0;
    for(i=j=0;i<la;i++){
        while(j&&b[j]!=a[i])
        j=fail[j-1]+1;
        if(a[i]==b[j])
        j++;
        if(j==lb){
            cnt++;
            j=fail[j-1]+1;
        }
    }
    return cnt;
}
char str[N];
char tmps[N];
ll gao(char *s,int l){
    GetFail(s,l);
    if(k<MN) return (ll)KMP(fib[k],s,len[k],l);
    int st=0;
    while(len[st]<l) st++;
    ll f1=KMP(fib[st],s,len[st],l),f2=KMP(fib[st+1],s,len[st+1],l);
    strcpy(str,fib[st+1]+(len[st+1]-l+1));
    strcpy(tmps,fib[st]);
    strcat(str,tmps);
    ll dc=(ll)KMP(str,s,(l-1)*2,l)%mod;
    strcpy(str,fib[st]+(len[st]-l+1));
    strcpy(tmps,fib[st+1]);
    tmps[l-1]=0;
    strcat(str,tmps);
//  printf("~%s\n%s\n%s\n",fib[st],fib[st+1],str);
    ll bc=(ll)KMP(str,s,(l-1)*2,l);
    if(k==(ll)(st)) return f1;
    if(k==(ll)(st+1)) return f2;
//  printf("~%d %I64d %I64d %s %I64d %I64d\n",st,f1,f2,fib[st],bc,dc);
//  printf("%d %d\n",KMP(fib[9],s,len[9],l),f3);
//  printf("%s %d\n",fib[st+3],f4);
//  printf("%s %d\n",fib[st+4],f5);
    Matrix fc=fa*fb;
//  fc.debug();
//  printf("%s\n",fib[12]);
//  k=11;
    ll p=k-(st+1);
    fc=(fc^(p/2));
//  fc.debug();
    if(p&1) fc=fb*fc;
//  fc.debug();
//  printf("%I64d ~%I64d %I64d %I64d %I64d\n",p,f2,f1,bc,dc);
    return (fc.s[0][0]*f2+fc.s[0][1]*f1+fc.s[0][2]*bc+fc.s[0][3]*dc)%mod;
}
char s[N];
int main(){
    init();
    while(~scanf("%I64d%d",&k,&m)){
        k--;
        while(m--){
            scanf("%s",s);
            printf("%I64d\n",gao(s,strlen(s))%mod);
        }
    }
    return 0;
}
/*
2131 2
ab
bab


*/
