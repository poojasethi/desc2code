#include <iostream>
#include <algorithm>
#include <vector>
#include <set>
#include <map>
#include <cstring>
#include <iomanip>
#include <cmath>
#include <sstream>
//#include <windows.h>

using namespace std;

/*void timer (string s)
{
	SYSTEMTIME time;
	GetSystemTime(&time);
	WORD millis = (time.wSecond * 1000) + time.wMilliseconds;
	cerr << s << ' ' << millis << endl;
}*/

#define int long long
#define cake pair <pie, int>
#define pie pair <int, int>
#define ff first
#define ss second
#define aa ff.ff
#define bb ff.ss
#define cc ss
#define mc(a,b,c) make_pair (pie (a, b), c)

const int maxN = 1000 * 1000 + 100;
const int maxM = 10000 + 100;
const int maxF = 30 + 1;
const int MOD = 1000 * 1000 * 1000 + 7;

int k, m;
string s[maxM];

/*********************************/
#define FIBO mc (1, 1, 0)

cake multi (cake a, cake b) {
	return mc (	(a.aa * b.aa + a.bb * b.bb) % MOD, 
				(a.aa * b.bb + a.bb * b.cc) % MOD,
				(a.bb * b.bb + a.cc * b.cc) % MOD );
}

cake pow (cake a, int n) {
	if (n == 1)
		return a;
	cake res = pow (a, n / 2);
	res = multi (res, res);
	if (n % 2) res = multi (res, a);
	return res;
}

int fibo (int x) {
	if (x <= 1) return max (0ll, x);
	cake a = pow (FIBO, x - 1);
	return a.aa;
}

int fuco (int x) {
	int res = fibo (x);
	if (x % 2) res--;
	return max (res, 0ll);
}
/***********************************/

const int F = 27;

string f[maxF];
int d[maxM][maxF];
int P, Q;
int p[maxM][maxF];
int q[maxM][maxF];
int h[maxN], g[maxN], hs[maxN], hsize, gsize; // hash
const int KEY = 701;
int pw[maxN];

int getHASH (int s, int e, int *h) {
	return h[e] - h[s] * pw[e - s];
}

void preprecalc() {	
	f[1] = "a"; f[2] = "b";
	for (int i = 3; i <= F + 1; i++)
		f[i] = f[i - 1] + f[i - 2];
//	cerr << f[F].size() << endl;

//	cerr << "here " << endl;
	pw[0] = 1;
	for (int i = 0; i < maxN - 1; i++)
		pw[i + 1] = pw[i] * KEY;
	hsize = f[F].size();
//	for (int i = 0; i < f[F].size(); i++)
//		h[i + 1] = h[i] * KEY + f[F][i];
	gsize = f[F + 1].size();
//	cerr << "shere " << endl;
	for (int i = 0; i < f[F + 1].size(); i++)
		g[i + 1] = g[i] * KEY + f[F + 1][i];
}

void precalc (int i) {
	int len = s[i].size();
	for (int j = 0; j < len; j++)
		hs[j + 1] = hs[j] * KEY + s[i][j];
	P = Q = 0;
//	cerr << "precalc " << endl;
	for (int l = 1; l < len; l++) {
		p[i][l] = getHASH (len - l, len, hs) == getHASH (0, l, g) && 
			 	  getHASH (0, len - l, hs)   == getHASH (hsize - len + l, hsize, g);
		q[i][l] = getHASH (len - l, len, hs) == getHASH (0, l, g) && 
			 	  getHASH (0, len - l, hs)   == getHASH (gsize - len + l, gsize, g);
	//	if (p[i][l]) cerr << "P " << i << ' ' << l << endl;
	//	if (q[i][l]) cerr << "Q " << i << ' ' << l << endl;
		P += p[i][l], Q += q[i][l];
	}
}

long long find (int i, int k) {
	if (d[i][k] != -1) return d[i][k];
	int res = 0;
	if (k == 1) res += s[i] == "a";
	else if (k == 2) res += s[i] == "b";
	else if (k == 3) res += s[i] == "ba" || s[i] == "b" || s[i] == "a";
	else {
		res = (find (i, k - 1) + find (i, k - 2)) % MOD;
		int ls = f[k - 1].size(), rs = f[k - 2].size();
		for (int r = 1; r <= min (rs, (int) (s[i].size())); r++) {
			int l = s[i].size() - r;
			if (l < 1 || l > ls) continue;
			res += (k % 2 ? q[i][r] : p[i][r]);
		}
	}
	return d[i][k] = res % MOD;
}

int solve (int i, int k) {
	if (k <= F)
		return find (i, k);
	int x = (fibo (k - F - 1) * find (i, F)) % MOD;
	int y = (fibo (k - F) * find (i, F + 1)) % MOD;
	int yy = (fuco (k - F - 2) * Q) % MOD;
	int yx = (fibo (k - F - 1) * Q) % MOD;
	int xy = (fuco (k - F - 1) * P) % MOD;
	return (x + y + yy + yx + xy) % MOD;
}

main()
{
	ios::sync_with_stdio (false);

	preprecalc();
	
	memset (d, -1, sizeof d);
	cin >> k >> m;
	for (int i = 0; i < m; i++) {
		cin >> s[i];
		precalc (i);
		cout << solve (i, k) << endl;
	}
	
	return 0;
}
