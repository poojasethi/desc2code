#include<iostream>
#include<cstdlib>
#include<cstring>
#include<stdio.h>
#include<algorithm>
#include<cmath>
#include<map>
#include<vector>
#include<set>
using namespace std;
struct edge
{
   int id,id1,id2,w,b,flag;
};
int n,m,low,high,mid,ch;
edge e[220000],now;
vector<edge>adj[2][220000];
int list[220000],cnt_list;
double need[220000];
int times,vs[220000],tnum[220000],num[220000],queue[4000000],inner[220000],outer[220000];
bool vis[220000];
double cost,flow;
int dp[2][220000],g[2][220000],inf=2010000000;
bool dfs(int flag,int id,int v,int *dp)
{
     int i,j,s,p,q,ip;
     if(dp[id]==-inf)
        dp[id]=v;
     else 
        return (dp[id]==v);
     list[cnt_list++]=id;
     vs[id]=times;
     for(i=0;i<adj[flag][id].size();i++)
     {
         ip=adj[flag][id][i].id;
         if(!dfs(flag,ip,v+adj[flag][id][i].b*adj[flag][id][i].w,dp))
             return false;
     }
     return true;
}
int test_bad;
bool check_deter(int xp,bool do_bad)
{
     int id1,id2,i,j,s,p,q;
     bool res=1;
     double w,b;
     for(i=0;i<n&&do_bad;i++)
     {
       if(g[0][i]<-1e-9&&g[0][i]!=-inf)
       {
              test_bad=1;
              return true;
       }
       if(g[1][i]<-1e-9&&g[1][i]!=-inf)
       {
               test_bad=1;
               return true;
       }
     }
     memset(inner,0,sizeof(inner));
     memset(outer,0,sizeof(outer));
     memset(need,0,sizeof(need));
     cost=flow=0;
     if(g[0][n-1]==-inf)
         res=false;
     for(i=0;i<=xp;i++)
     {
         id1=e[i].id1;
         id2=e[i].id2;
         outer[id1]+=e[i].b;
         inner[id2]+=e[i].b;
         if(!do_bad)
            cost+=(double)e[i].w*(double)e[i].b*(double)e[i].b;
     }
     flow=0;
     for(i=0;i<n;i++)
     {
        flow=max(flow,(double)inner[i]);
        flow=max(flow,(double)outer[i]);
     }
     for(i=0;i<n;i++)
     {
         if(i==0&&flow>outer[i])
            need[i]+=-flow+outer[i];
         else if(i==n-1&&flow>inner[i])
            need[i]+=-inner[i]+flow;
         else if(i!=0&&i!=n-1)
            need[i]+=-inner[i]+outer[i];
     }
     for(i=0;i<n&&do_bad;i++)
     {
           if(abs(g[0][i])<1e-9&&need[i]>1e-9)
           {
              test_bad=1;
              return true;
           }
           if(abs(g[1][i])<1e-9&&need[i]<-1e-9)
           {
              test_bad=1;
              return true;
           }
     }
     if(do_bad)
         return true;
     double nt=0;
     bool did=false;
     for(i=0;i<n;i++)
     {
           double vv;
           b=need[i];
           vv=g[0][i]; 
           if(vv==-inf)
              vv=dp[0][i];
           if(fabs(b)>1e-9)
           {
              if(vv==-inf)
              {
                 nt=(double)(inf);
                 vv=0;
             }
             else if(vv*b>0)
                nt+=fabs(vv);
             else
                nt-=fabs(vv);
              did=true;
              cost+=(double)vv*b;
           }
     }
    if(res&&flow==0)
        test_bad=1;
     return res;
}
int check(int id)
{
     int i,j,s,p,q,id1,id2;
     for(j=0;j<2;j++)
        for(i=0;i<n;i++)
            adj[j][i].clear();
     memset(tnum,0,sizeof(tnum));
     memset(num,0,sizeof(num));
     for(i=0;i<=id;i++)
     {
         now=e[i];
         now.id=e[i].id2;
         adj[0][e[i].id1].push_back(now);
         now.w=-now.w;
         adj[1][e[i].id1].push_back(now);
         now=e[i];
         now.id=e[i].id1;
         adj[1][e[i].id2].push_back(now);
         now.w=-now.w;
         adj[0][e[i].id2].push_back(now);
         tnum[e[i].id2]++;
         num[e[i].id1]++;
     }
     if(tnum[0]>0||num[n-1]>0)
         return -1;
    for(i=0;i<2;i++)
      for(j=0;j<n;j++)
         g[i][j]=dp[i][j]=-inf;
    for(i=0;i<n;i++)
    {
         if(tnum[i]!=0)
            continue;
         if(dp[0][i]==-inf)
         {
             times++;
             cnt_list=0;
             if(!dfs(0,i,0,dp[0]))
                 return -1;
             if(vs[0]==times)
             {
                for(s=0;s<cnt_list;s++)
                   g[0][list[s]]=dp[0][list[s]];
             }
             if(vs[n-1]==times)
             {
                for(s=0;s<cnt_list;s++)
                   g[1][list[s]]=dp[0][n-1]-dp[0][list[s]];
             }
             for(s=0;s<cnt_list&&g[0][n-1]!=-inf;s++)
             {
                if(dp[0][list[s]]>g[0][n-1])
                   return -1;
                if(dp[0][list[s]]==g[0][n-1]&&g[0][list[s]]==-inf)
                   return -1;
             }
         }
    }
    for(i=0;i<n;i++)
    {
       if(dp[0][i]==-inf)
          return -1;
    }
    test_bad=0;
    check_deter(id,1);
    if(test_bad)
       return -1;
    return 0;
}
int main()
{
    int i,j,s,p,q;
    scanf("%d%d",&n,&m);
    for(i=0;i<m;i++)
    {
       scanf("%d%d%d%d",&e[i].id1,&e[i].id2,&e[i].w,&e[i].b);
       e[i].id1--;
       e[i].id2--;
    }
    memset(vs,-1,sizeof(vs));
    times=0;
    ch=check(m-1);
    if(ch<0)
    {
       low=0;
       high=m-1;
       while(low<=high)
       {
           mid=(low+high)>>1;
           if(check(mid)<0)
              high=mid-1;
           else
              low=mid+1;
       }
       printf("BAD %d\n",low+1);
    }
    else
    {
        test_bad=0;
        if(check_deter(m-1,0)&&!test_bad)
           printf("%.0f\n",cost/flow);
        else if(test_bad)
            printf("BAD %d\n",m);
        else
           puts("UNKNOWN");
    }
}