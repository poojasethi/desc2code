#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <utility>
#include <map>
#include <vector>
#define FOR(i, to, from) for (int i=to; i<from; i++)
#define ri(n) scanf("%d", &n)
#define ms(obj, value) memset(obj, value, sizeof(obj))
#define rii(n, m) scanf("%d%d", &n, &m)
#define pb push_back
#define mp make_pair
using namespace std;

typedef long long ll;
typedef pair <ll, ll> pll;
typedef vector <ll> vll;
typedef map <int, ll> mill;
typedef unsigned long long ull;

ll al[100][40]={}, be[100][40]={};
mill ex;
mill X;
vll p;
int primos[10000];
bool criba[40000];

ull m=1000000007; 

ll sq(ll a) { return a*a; }
ll potMod(ll a, ull b){ return b ? ((sq(potMod(a, b >> 1)) % m)*(b & 1 ? a : 1)) % m : 1; }
ll pot(ll a, ull b){ return b ? sq(pot(a, b >> 1))*(b & 1 ? a : 1) : 1; }



int factorizar2 (int N, int M) {
	int F=0;
	for (int i=0; primos[i]*primos[i]<=N || primos[i]*primos[i]<=M; i++) {
		if (N%primos[i]==0 || M%primos[i]==0){
			++F;
			p.pb(primos[i]);
		}
		while (N%primos[i]==0) {
			al[0][F-1]++;
			N/=primos[i];
		}
		while (M%primos[i]==0) {
			be[0][F-1]++;
			M/=primos[i];
		}
	}
	
	if (N>1 && M>1) {
		if (N==M) {
			p.pb(N);
			al[0][F]=be[0][F]=1;
			F++;
		}
 		else {
			p.pb(N); p.pb(M);
			al[0][F++]=1;
			be[0][F++]=1;
		}
	}
	else if (N>1) {
		p.pb(N);
		al[0][F++]=1;
	}
	else if (M>1) {
		p.pb(M);
		be[0][F++]=1;
	}
	
	return F;
}

mill factorizar (int N) {
	mill e;
	for (int i=0; primos[i]*primos[i]<=N; i++) {
		if (!(N%primos[i]))
		while (!(N%primos[i])) {
				e[primos[i]]++;
				N/=primos[i];
		}
	}
	if (N>1) e[N]++;
	
	return e;
}

pll egcd (ll a, ll b) {
	if (b==0) return mp(1, 0);
	pll RES=egcd(b, a%b);
	return mp(RES.second, RES.first-RES.second*(a/b));
}
ll inv (ll n, ll m) {
	pll EDGC = egcd(n, m);
	return ((EDGC.first%m)+m)%m;
}

ll tcr(int k, ll n[], ll a[]) {
	int i;
	ll temp, MOD, RES;
	MOD=1;
	for (i=0; i<k; i++)
		MOD*=n[i];
	
	RES=0;
	for (i=0; i<k; i++) {
		temp=MOD/n[i];
		temp*=inv(temp, n[i]);
		RES+=(temp*a[i])%MOD;
	}
	return RES%MOD;
}
int k;
ll x, y, A, B, C;
int intersectar (int j) {

	
	FOR(i, 1, k) {
		int D = be[j][0]*be[0][i] - be[0][0]*be[j][i];
		if (D==0) {
			if (be[0][0]*(al[j][i]-al[0][i]) != be[0][i]* (al[j][0]-al[0][0])) {
				return 0;
			}
		}
		else {
			int d1 = (al[j][i]-al[0][i])*be[j][0] - (al[j][0]-al[0][0])*be[j][i];
			int d2 = (al[j][i]-al[j][i])*be[j][0] - (al[j][0]-al[0][0])*be[0][i];
			if (d1%D || d2%D)
				return 0;
			else {
				x = d1/D; y = d2/D;
				if (x<0 || y<0) return 0;
				FOR(h, 0, k) al[0][h] += (be[0][h]*x);
				return 1;
			}
		}
	}

	int h=0;
	for (; h<k-1 && !(be[0][h] || be[j][h]); h++);
	A = be[0][h], B = be[j][h], C = al[j][h]-al[0][h];

	pll r = egcd(A, -B);
	x=r.first; y=r.second;
	int d = A*x-B*y;
	if (d<0) {d=-d; x=-x; y=-y;}
	if (C<0) {C=-C; x=-x; y=-y;}
	if (d==0) {
		x=y=0;
		return 1;
	}
	if (C%d) return 0;
	
	A/=d; B/=d; C/=d;
	while (x<0 || y<0) {
		x+=B;
		y+=A;
	}
	while (x-B>0 && y-A>0) {
		x-=B;
		y-=A;
	}
	x*=C; y*=C;
	return 2;
}


bool validar (int i) {
	int j=0;
	for (; j<k-1 && !be[i][j]; j++);
	if (be[i][j] && (al[0][j]<al[i][j] || (al[0][j]-al[i][j])%be[i][j])) return false;
	if (!be[i][j]) y=0;
	else y = (al[0][j]-al[i][j])/be[i][j];
	FOR(h, 1, k) if (al[0][h] != al[i][h] + be[i][h]*y) return false;
	return true;

}
int main () {
	int n, a0, b0, a, b, tipo;
	k=0;
	primos[k++]=2;
	ms(criba, true);
	for (int i=4; i<40000; i+=2) criba[i]=false;
	for (int i=3; i<40000; i+=2) if(criba[i]) {
		primos[k++]=i;
		for (int j=i*i; j<40000; j+=i) criba[j]=false;
	}
	
	ri(n);	
	rii(a0, b0);
	k = factorizar2(a0, b0);
	
	FOR(i, 1, n) {
		rii(a, b);
		FOR(j, 0, k) {
			while (a%p[j]==0) {
				al[i][j]++;
				a/=p[j];
			}
			while (b%p[j]==0) {
				be[i][j]++;
				b/=p[j];
			}
		}

		if (a!=1) {
			printf("-1\n");
			return 0;
		}
		if (b!=1) FOR(j, 0, k) be[i][j]=0;
			
	}
	
	ll maxX=0;
	FOR(i, 1, n) {
		tipo = intersectar (i);
		if (!tipo) {
			printf("-1\n");
			return 0;
		}
		if (tipo==1) {
			FOR(j, 0, n)
				if (!validar(j)) {
					printf("-1\n");
					return 0;
				}
			ll res = (a0*potMod(b0, x))%m;;
			printf("%d\n", (int) res);
			return 0;
		}
		

		mill e=factorizar(B);
		map<int, ll>::iterator it;
		for (it=e.begin(); it!=e.end(); it++) {
			int p = it->first;
			int z1 = ex[p], z = it->second;
			if (!z1) {
				ex[p] = z;
				X[p]  = x%pot(p, z);
			}
			else {
				ll x1 = X[p];
				if (z1<=z) {
					ll po = pot(p, z1);
					if ( x1%po != x%po) {
						printf("-1\n");
						return 0;
					}
					ex[p] = z;
					X[p] = x%pot(p, z);
				}
				else {
					ll po = pot(p, z);
					if ( x1%po != x%po) {
						printf("-1\n");
						return 0;
					}
				}
			}
		}
		
		maxX = max(maxX, x);
	}
	ll mo[100];
	ll resi[100];
	int s=0;
	map<int, ll>::iterator it;
	for (it = ex.begin(); it != ex.end(); it++)
		mo[s++] = pot(it->first, it->second);
	s=0;
	for (it = X.begin(); it != X.end(); it++)
		resi[s++] = it->second;
	

	
	ll MOD = 1;
	FOR(i, 0, s) MOD*=mo[i];
	
	ll EXP = tcr(s, mo, resi);

	while (EXP < maxX) EXP+=MOD;

	ll res = (a0*potMod(b0, EXP))%m;
	printf("%d\n", (int) res);
	return 0;
}


