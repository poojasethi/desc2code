from collections import defaultdict
from itertools import takewhile, count

def sort_topologically(graph):
    levels_by_name = {}
    names_by_level = defaultdict(set)

    def walk_depth_first(name):
        if name in levels_by_name:
            return levels_by_name[name]
        children = graph.get(name, None)
        level = 0 if not children else (1 + max(walk_depth_first(lname) for lname in children))
        levels_by_name[name] = level
        names_by_level[level].add(name)
        return level

    for name in graph:
        walk_depth_first(name)

    return list(takewhile(lambda x: x is not None, (names_by_level.get(i, None) for i in count())))

N = input()
alpha = 'abcdefghijklmnopqrstuvwxyz'
graph = {k:[] for k in alpha}

# print(sort_topologically(graph))
names = [raw_input() for x in range(N)]
ans = True
for name_a, name_b in zip(names, names[1:]):
  temp_a = str(name_a)
  temp_b = str(name_b)
  while temp_a and temp_b and temp_a[0] == temp_b[0]:
    temp_a = temp_a[1:]
    temp_b = temp_b[1:]
  if temp_a and not temp_b:
    ans = False
    break
  if not temp_a or not temp_b:
    continue
  graph[temp_b[0]].append(temp_a[0])
# for key in graph:
#   print key, graph[key]

for key in graph:
  if not graph[key]:
    continue
  visited = set([key])
  root = graph[key]
  while root:
    if root[0] in visited:
      ans = False
      break
    visited.add(root[0])
    root = graph[root[0]]
  if not ans:
    break

# abc = 0
# for key in graph:
#   if not graph[key]:
#     abc += 1
# if abc == 26:
#   ans = False

if ans:
  print ''.join(sum([list(x) for x in sort_topologically(graph)], []))
  # print ''
else:
  print 'Impossible'