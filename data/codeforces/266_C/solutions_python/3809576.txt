def uniq(l):
  res = []
  d = {}
  for x in l:
    if x not in d:
      res.append(x)
    d[x] = 0
  return res

def swap(rows, a, b):
  (rows[a],rows[b]) = (rows[b],rows[a])
  return rows

def transposition(permutation):
  i = 0
  while i < len(permutation) and permutation[i] == i:#
    i+=1
  if i == len(permutation): 
    return None
  p = permutation[i]
  return (i,p)

#Read input
n = int(raw_input())
positions = [[] for i in range(n+1)]
for i in xrange(n-1):
  (x,y) = [int(k) for k in raw_input().split()]
  positions[x].append(y)

#actions
actions = []

#push heaviest rows to the bottom
population = [(len(positions[i]),i) for i in xrange(n+1)]
population.sort()
cycle = [y for (x,y) in population]
invcyc = range(n+1)
for i in range(n+1):
  invcyc[cycle[i]] = i
t = transposition(invcyc)

while t != None:
  (a,b) = t
  actions.append((1,a,b))
  positions = swap(positions,a,b)
  invcyc = swap(invcyc,a,b)
  t = transposition(invcyc)

#push everybody to the left
columns = [x[i] for x in positions for i in range(len(x))]
columns = uniq(columns)
pad = [x for x in range(1,n+1) if x not in columns]
columns = [0] + columns + pad
invcol = range(n+1)
for i in range(n+1):
  invcol[columns[i]] = i


t2 = transposition(invcol)
while t2 != None:
  (a,b) = t2
  actions.append((2,a,b))
  invcol = swap(invcol,a,b)
  t2 = transposition(invcol)
  
print len(actions)
for (t,a,b) in actions:
  print t, a, b
