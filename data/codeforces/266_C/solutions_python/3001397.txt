import io;
import sys;
import math;
import bisect as bs;
import heapq;
# IO Method #

def read_int() :
	return map(int, raw_input().split());

def read_string() :
	return raw_input().split();

def read_float() :
	return map(float, raw_input().split());

# End #

# Data Structures #

class LinkedList :

	def __init__(self) :
		self.head = Node(); # Always null
		self.tail = Node(); # Always null
		self.now = Node(); # Init it first #
		# Create link #
		self.head.next = self.now;
		self.tail.prev = self.now;
		self.now.prev = self.head;
		self.now.next = self.tail;

		# Create attrib #
		self.__first = True;
		self.size = 0;

		pass

	def next(self) :
		return self.now.next;

	def prev(self) :
		return self.now.prev;

	def __setNow(self, data) :
		self.now.data = data;
		self.__first = False;
		pass

	def addFirst(self, data) :
		if self.__first :
			self.__setNow(data); 
		else :
			newNode = Node(data, self.head, self.head.next);
			self.head.next = newNode;
			newNode.next.prev = newNode;
			self.size += 1;
		pass

	def addLast(self, data) :
		if self.__first :
			self.__setNow(data); 
		else :
			newNode = Node(data, self.tail.prev, self.tail);
			self.tail.prev = newNode;
			newNode.prev.next = newNode;
			self.size += 1;
		pass

	def addNext(self, data) :
		if self.__first :
			self.__setNow(data); 
		else :
			newNode = Node(data, self.now, self.now.next);
			self.now.next = newNode;
			newNode.next.prev = newNode;
			self.size += 1;
		pass

	def addPrev(self, data) :
		if self.__first :
			self.__setNow(data); 
		else :
			newNode = Node(data, self.now.prev, self.now);
			self.now.prev = newNode;
			newNode.prev.next = newNode;
			self.size += 1;
		pass

	def toList(self) :
		currNode = self.head.next;
		res = [];
		while (currNode != self.tail) :
			res.append(currNode.data);
			currNode = currNode.next;
			pass
		return res;

	def __str__(self) :
		return str(self.toList());

class Node :

	def __init__(self, data = None, prev=None, next=None) :
		self.prev = prev;
		self.next = next;
		self.data = data;
		pass

	def __str__(self) :
		return str(self.data)

# Main Entry #

if __name__ == '__main__': 

	sides = input();
	
	one_row = [0 for _ in xrange(sides)];
	one_col = [0 for _ in xrange(sides)];
	row = [0 for _ in xrange(sides-1)];
	col = [0 for _ in xrange(sides-1)];
	ans = [];

	for ii in xrange(sides-1) :
		a, b = read_int();
		a -= 1;
		b -= 1;
		
		one_row[a] += 1;
		one_col[b] += 1;
		row[ii] = a;
		col[ii] = b;
		pass

	def debug() :
		print "-----"

		matrix = [[0 for _ in xrange(sides)] for _ in xrange(sides)];
		for ii in xrange(sides-1) :
			matrix[row[ii]][col[ii]] = 1;

		for ii in xrange(sides) :
			for jj in xrange(sides) :
				print matrix[ii][jj],;
				pass
			print "";
			pass

		print "-----"

		pass

	def swaprc(rc, a, b) :
		if rc == 1 :
			for ii in xrange(sides-1) :
				if row[ii] == a :
					row[ii] = b;
				elif row[ii] == b :
					row[ii] = a; 

			one_row[a], one_row[b] = one_row[b], one_row[a];

		else :
			for ii in xrange(sides-1) :
				if col[ii] == a :
					col[ii] = b;
				elif col[ii] == b :
					col[ii] = a; 

			one_col[a], one_col[b] = one_col[b], one_col[a];

		ans.append([rc, a, b]);

		pass

	# search empty column #
	lidx = sides-1;
	for ii in xrange(sides) :
		if lidx <= ii :
			break;

		if one_col[ii] == 0 :
			swaprc(2, ii, lidx);
			lidx -= 1;
		pass;

	# greedyly get farthest col in row r #
	far = [-1 for _ in xrange(sides)];
	for ii in xrange(sides-1) :
		far[row[ii]] = max(far[row[ii]], col[ii]);
		pass


	# selection sort for row #
	for ii in xrange(sides-1, -1, -1) :
		maxitem = -1;
		maxidx = -1;
		for jj in xrange(0, ii+1) :
			if far[jj] > maxitem :
				maxitem = far[jj];
				maxidx = jj;
				pass
			pass
		if maxidx == -1 :
			break;
		if maxidx != ii :
			swaprc(1, maxidx, ii); 
			far[maxidx], far[ii] = far[ii], far[maxidx];
	
	#debug();
	print len(ans)
	for ii in xrange(len(ans)) :
		print ans[ii][0], ans[ii][1]+1, ans[ii][2]+1;

	pass


# End #
