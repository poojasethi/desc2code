#include<vector>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 100005, INF = 200000000;
int n, m, dis[N], head[N], next[N << 1], v[N << 1], qh, qt, q[N],myq[N];
inline void BFS(int s) {
    qh = 0; qt = 1;
    q[1] = s;
    dis[s] = 0;
    while (qh < qt) {
        int i = q[++qh];
        for (int j = head[i]; ~j; j = next[j]) {
            int u = v[j];
            if (dis[u] > dis[i] + 1) {
                dis[u] = dis[i] + 1;
                q[++qt] = u;
            }
        }
    }
}
int main() {
    int top = 0;
    memset(head, -1, sizeof(head));
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n - 1; ++i) {
        int t1, t2;
        scanf("%d%d", &t1, &t2);
        --t1, --t2;//1-n --> 0-(n-1) ,, 0 is in red
        v[top] = t2; next[top] = head[t1]; head[t1] = top++;
        v[top] = t1; next[top] = head[t2]; head[t2] = top++;
    }
    for (int i = 0; i < n; ++i)dis[i] = INF;
    BFS(0);
    int tmp=0;
    for (int i = 0; i < m; ++i) {
        int op, t2;
        scanf("%d%d", &op, &t2);
        --t2;
        if (op == 1)myq[tmp++]=t2;
        else {
            if(tmp){//half_offline_by_random,,avoid 退化成鏈
                random_shuffle(myq,myq+tmp);
                for(int pp=0;pp<tmp;++pp){
                    BFS(myq[pp]);
                }
                tmp=0;
            }
            printf("%d\n", dis[t2]);
        }
    }
    return 0;
}
