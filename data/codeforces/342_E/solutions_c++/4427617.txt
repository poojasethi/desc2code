#include<bits/stdc++.h>
using namespace std;

#define TR(v,i) for(__typeof((v).begin())i=(v).begin();i!=(v).end();++i)
const int N = 1e5, LOG_N = 16, TEMP = 250;
vector<int> g[N];
int l[N], p[N][LOG_N+1], n;

void dfs(int u) {
	TR(g[u], v) if(*v != p[u][0])
		l[*v] = l[u] + 1, p[*v][0] = u, dfs(*v);
}

void initLCA() {
	for(int j = 1; 1 << j < n; ++j)
		for(int i = 0; i < n; ++i) if(p[i][j-1] != -1)
			p[i][j] = p[p[i][j-1]][j-1];
}

int getLCA(int u, int v) {
	if(l[u] < l[v]) swap(u, v);
	for(int i = LOG_N; i >= 0; --i)
		if(l[u] - (1 << i) >= l[v])
			u = p[u][i];
	if(u == v) return u;
	for(int i = LOG_N; i >= 0; --i)
		if(p[u][i] != p[v][i])
			u = p[u][i], v = p[v][i];
	return p[u][0];
}

int d[N], red[TEMP], m;
bool color[N];

void update() {
	queue<int> q;
	for(int i = 0; i < TEMP; ++i)
		d[red[i]] = 0, q.push(red[i]);
	while(!q.empty()) {
		int u = q.front(); q.pop();
		TR(g[u], v) if(d[*v] > d[u] + 1)
			d[*v] = d[u] + 1, q.push(*v);
	}
}

void solve() {
	for(int u = 0; u < n; ++u) d[u] = l[u];
	color[0] = true;
	int nred = 0;
	for(int x = 0; x < m; ++x) {
		int t, u; cin >> t >> u; --u;
		if(t == 1) {
			if(color[u]) continue;
			red[nred++] = u;
			if(nred == TEMP) update(), nred = 0;
		} else {
			int res = d[u];
			for(int i = 0; i < nred; ++i)
				res = min(res, l[u] + l[red[i]] - 2 * l[getLCA(u, red[i])]);
			cout << res << '\n';
		}
	}
}

void enter() {
	cin >> n >> m;
	for(int i = 1; i < n; ++i) {
		int u, v; cin >> u >> v; --u; --v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
}

int main() {
	ios::sync_with_stdio(false);
	enter();
	dfs(0);
	initLCA();
	solve();
	return 0;
}
