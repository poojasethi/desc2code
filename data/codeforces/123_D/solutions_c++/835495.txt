#include <map>
#include <set>
#include <cmath>
#include <stack>
#include <queue>
#include <string>
#include <vector>
#include <bitset>
#include <time.h>
#include <fstream>
#include <sstream>
#include <numeric>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <iostream>
#include <algorithm>
using namespace std;
#define li long long int
#define rep(i,to)	for(li i=0;i<((li)(to));++i)
#define pb       	push_back
#define sz(v)    	((li)(v).size())
#define bit(n)   	(1ll<<(li)(n))
#define each(it,c) \
for(__typeof((c).begin()) it=(c).begin();it!=(c).end();++it)
#define all(a) (a).begin(),(a).end()
#define MP make_pair
#define F first
#define S second


#define MAX 100005
#define SEED 1007
li p[MAX];
li hash[MAX];
li pr[MAX];
li now[MAX];
li sum=0,res=0;
string str;
vector<li> v,vec[MAX];

li get(li from,li len){
	return (hash[from+len]-hash[from])*p[MAX-from-1];
}

li lca(li a,li b){
	li low=0,high=MAX;
	while(low+1<high){
		li mid=(low+high)/2;
		if(get(a,mid)==get(b,mid)) low=mid;
		else high=mid;
	}
	return low;
}

bool cmp(li const &a,li const &b){
	li len=lca(a,b);
	if(a+len==sz(str)) return true;
	if(b+len==sz(str)) return false;
	return str[a+len]<str[b+len];
}

li find(li num){
	if(pr[num]==num) return num;
	return pr[num]=find(pr[num]);
}

void cal(li num){
	li a=now[find(v[num+0])];
	li b=now[find(v[num+1])];
	sum=sum-a*(a+1)/2-b*(b+1)/2+(a+b)*(a+b+1)/2;
	pr[find(v[num])]=find(v[num+1]);
	now[find(v[num])]=a+b;
}

int main(){
	rep(i,MAX) pr[i]=i;
	rep(i,MAX) now[i]=1;
	cin>>str;
	p[0]=1;
	rep(i,MAX-1) p[i+1]=p[i]*SEED;
	rep(i,sz(str)) hash[i+1]=hash[i]+(str[i]-'a'+1)*p[i];
	rep(i,sz(str)) v.pb(i);
	sort(all(v),cmp);
	rep(i,sz(v)-1) vec[lca(v[i],v[i+1])].pb(i);
	for(li i=sz(str);1<=i;i--){
		if(i) sum++;
		rep(j,sz(vec[i])) cal(vec[i][j]);
		res+=sum;
	}
	cout<<res<<endl;
}
