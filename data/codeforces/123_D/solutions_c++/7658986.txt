#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

typedef pair<int, int> pii;
typedef long long ll;

const int MAXN = 1e5 + 10, BASE = 701;

ll ph[MAXN], baseP[MAXN];

inline ll getPartHash(int s, int e) {
	return ph[e] - ph[s] * baseP[e - s];
}

int lcp(pii x, pii y) {
	int lo = 0, hi = min(x.second - x.first, y.second - y.first) + 1;
	while (hi - lo > 1) {
		int mid = (hi + lo) >> 1;
		if (getPartHash(x.first, x.first + mid) == getPartHash(y.first, y.first + mid))
			lo = mid;
		else
			hi = mid;
	}
	return lo;
}

string s;
int n;

bool compSA(pii x, pii y) {
	int len = lcp(x, y);
	return s[x.first + len] < s[y.first + len];
}

pii sArray[MAXN];

int par[MAXN], size[MAXN];

int find(int x) {
	return (par[x] == x ? x : par[x] = find(par[x]));
}

bool merge(int x, int y) {
	x = find(x); y = find(y);
	par[x] = y;
	size[y] += size[x];
}

vector<pii> edges[MAXN];

int main() {
	baseP[0] = 1;
	for (int i = 1; i < MAXN; i++)
		baseP[i] = baseP[i - 1] * BASE;
	cin >> s;
	n = s.size();
	for (int i = 0; i < n; i++)
		ph[i + 1] = ph[i] * BASE + s[i];
	for (int i = 0; i < n; i++)
		sArray[i] = pii(i, n);
	sort(sArray, sArray + n, compSA);
	for (int i = 0; i < n - 1; i++)
		edges[lcp(sArray[i], sArray[i + 1])].push_back(pii(i, i + 1));
	ll ans = 0;
	for (int i = 0; i < n; i++)
		par[i] = i, size[i] = 1;
	for (int i = n; i >= 0; i--) {
		for (int j = 0; j < edges[i].size(); j++) {
			int v = edges[i][j].first, u = edges[i][j].second;
			ans += 1ll * size[find(v)] * size[find(u)] * i;
			merge(u, v);
		}
	}
	cout << ans + 1ll * n * (n + 1) / 2 << endl;
	return 0;
}
