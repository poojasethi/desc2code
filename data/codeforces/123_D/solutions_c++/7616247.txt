#include<iostream>
#include<vector>
#include<algorithm>
#include<set>
#include<string>
#define pb push_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
const int Maxn = int(1e5)+1000 , delta= int(1e9)+9;
pair<int ,int> lcp_s[Maxn];
typedef pair<int , int> pii;
long long ans = 0;
vector<pii> D;//suffixes
string S;
long long h[Maxn] , p[Maxn] , par[Maxn];//h , p???

int getfa(int v){return (par[v] < 0  ? v : par[v] = getfa(par[v]));}
void merge(int x ,int y , int size){
	x = getfa(x);y=getfa(y);
	if(x==y) return;
	if(par[x] > par[y]) swap(x,y);
	ans -= 1LL * size*((-par[x]+1)*(-par[x])/2 + (-par[y]+1)*(-par[y])/2);
	ans += 1LL * size*((-par[x]-par[y]+1)*(-par[x]-par[y])/2);
	par[x]+=par[y];
	par[y] = x;
	return;
}


int lcp(pii a ,pii b){
	int lo = 0 , hi = min(a.se-a.fi , b.se-b.fi)+2;
	while(hi-lo>1){
		int mid = (hi+lo)/2;
		if(h[a.fi+mid-1] - h[a.fi-1]*p[mid] == h[b.fi+mid-1]-h[b.fi-1]*p[mid])
			lo = mid;
		else
			hi = mid;
	}
	return lo;
}

struct cmp{
	bool operator()(const pii& a , const pii& b){
		int l = lcp(a,b);
		if(l==a.se - a.fi+1) return true;
		if(l==b.se - b.fi+1) return false;
		return S[a.fi+l] < S[b.fi+l];
	}
};
int main()
{
	ios_base::sync_with_stdio(false);
	cin >> S;
	int n = S.size();
	ans = 1LL*n*(n+1)/2;
	fill(par , par+Maxn , -1);
	h[0] = S[0] , p[0] = 1;
	for(int i = 1 ; i<S.length();++i)  {h[i] = h[i-1]*delta+S[i] , p[i] =p[i-1]*delta;}
	for(int i = 0 ; i<S.length();++i) D.pb(mp(i , n-1));
	sort(D.begin() , D.end() , cmp());
	for(int i = 0 ; i<n-1;++i) lcp_s[i] = mp(lcp(D[i] , D[i+1]) ,i);
	sort(lcp_s , lcp_s+n-1 , greater<pii>());

	for(int i = 0  ; i<n-1;++i){
			merge(lcp_s[i].se , lcp_s[i].se+1 , lcp_s[i].fi);
	}
	cout << ans << endl;
	
}
