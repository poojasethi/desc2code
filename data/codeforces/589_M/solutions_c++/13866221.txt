#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <queue>
#include <vector>
using namespace std;

const int maxn = 100 + 10;
const int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
const int INF = 0x3f3f3f3f;
const int maxe = 20000 + 100;
const double eps = 1e-8;
typedef pair<int, int> pill;

int dcmp(double x){
    if(fabs(x) < eps) return 0;
    return x < 0 ? -1 : 1;
}

struct Edge{
    int v, next;
    double d;
    Edge(int v = 0, double d = 0, int next = 0) : v(v), d(d), next(next) {}
};
struct HeapNode{
    int v;
    double cur_v;
    double min_time;
    HeapNode(int v, double cur_v, double min_time) : v(v), cur_v(cur_v), min_time(min_time) {}
    HeapNode() {}
    bool operator < (const HeapNode &rhs) const{
        return min_time > rhs.min_time;
    }
};

int n;
int W, L;
double a, vm, vp;
pill pos[maxn];
int vis[maxn][maxn];//0 st 1 ed >=2 police
int vis2[maxn][maxn];
vector<int> neighbor;
int d[maxn];
int Head[maxn], cntE;
Edge edge[maxe];

bool judge(int x, int y){
    if(x >= 0 && x <= W && y >= 0 && y <= L)
        return true;
    return false;
}

struct Work{
    int x, y;
    int step;
    Work(int x, int y, int step) : x(x), y(y), step(step) {}
    Work() {}
};
void bfs(int x, int y, int cu){
//    printf("...%d %d %d\Cn", x, y, cu);
    Work st(x, y, 0);
    queue<Work> Q;
    Q.push(st);
    d[cu] = 0;
    while(!Q.empty()){
        Work cur = Q.front(); Q.pop();
        int xx = cur.x;
        int yy = cur.y;
        if(vis2[xx][yy]) continue;
        //if(cu == 2) printf("..\n");
        vis2[xx][yy] = 1;
        int step = cur.step;
        if(vis[xx][yy] && vis[xx][yy] != cu){
            d[vis[xx][yy]] = step;
            neighbor.push_back(vis[xx][yy]);
            continue;
        }
        for(int i = 0; i < 4; i++){
            int dx = xx + dir[i][0];
            int dy = yy + dir[i][1];
            //if(cu == 2 && !vis2[dx][dy]) printf("%d %d\n", dx, dy);
            if(!judge(dx, dy) || vis2[dx][dy]) continue;
            // if(!vis2[dx][dy] && vis[dx][dy] && d[vis[dx][dy]] > step + 1){//find the first person
        //if(cu == 2 && cur.step == 0) printf("...\n");
               // vis2[dx][dy] = 1;
             //   d[vis[dx][dy]] = step + 1;
           // }
           // if(judge(dx, dy) && !vis2[dx][dy] && !vis[dx][dy]){
               // if(cu == 2) printf("....\n");
                Q.push(Work(dx, dy, step + 1));
               // vis2[dx][dy] = 1;
           // }
        }
    }
}

void init(){
    memset(Head, -1, sizeof(Head));
    cntE = 0;
}

void add(int u, int v, int d){
    edge[cntE] = Edge(v, double(d), Head[u]);
    Head[u] = cntE++;
}

double f(double vx, double v0, double vt){
    return (2 * vx * vx - v0 * v0 - vt * vt) / 2 / a;
}

double get_time(double v0, double vt, double s, double &vf){
    //if(dcmp(v0 - vt) == 0 && dcmp(vm - vp) == 0){
    //    vf = vt;
    //    return s / vt;
    //}
    double t1 = (vt - v0) / a;
    if(dcmp(v0 * t1 + a * t1 * t1 / 2 - s) >= 0){
        if(dcmp(v0 * t1 + a * t1 * t1 / 2 - s) == 0){
            vf = vt;
            return t1;
        }
        double ans = (sqrt(v0 * v0 + 2 * a * s) - v0) / a;
        vf = v0 + a * ans;
        return ans;
    }
    /*
    else{
        vf = vt;
        double l = vt, r = vm;
        while(l + eps < r){
            double mid = (l + r) / 2;
            if(f(mid, v0, vt) < s) l = mid;
            else r = mid;
        }
        double tt = ((l - v0) + (l - vt)) / a;
        if(dcmp(vm - l) > 0){// not up to maxspeed
            return tt;
        }
        else{
            double rs = s - f(l, v0, vt);
            return tt + rs / vm;
        }
    }
    */
    else{
        double len = (2 * vm * vm - v0 * v0 - vt * vt) / 2 / a, vx;
        vf = vt;
        if(len > s){
            vx = sqrt((2 * a * s + v0 * v0 + vt * vt) / 2);
            return (2 * vx - v0 - vt) / a;
        }
        else{
            return (2  * vm - v0 - vt) / a + (s - (2 * vm * vm - v0 * v0 - vt * vt) / 2 / a) / vm;
        }
    }
}

double dist[maxn];
double cur_v[maxn];
void dijkstra(){
    double ddd;
    for(int i = 0; i < n + 3; i++) dist[i] = double(INF);
    dist[1] = 0;
    priority_queue<HeapNode> Q;
    Q.push(HeapNode(1, 0, 0));
    while(!Q.empty()){
        HeapNode cur = Q.top(); Q.pop();
        int u = cur.v;
        double t = cur.min_time;
        for(int i = Head[u]; ~i; i = edge[i].next){
            int v = edge[i].v;
            double v0, vt, vf;
            v0 = cur_v[u];
            if(v > 2) vt = vp;//is police
            else vt = vm;
            double tt = get_time(v0, vt, edge[i].d, vf);
            if(dist[v] > dist[u] + tt){
                dist[v] = dist[u] + tt;
                cur_v[v] = vf;
                //if(v == 2) printf("lf\n", dist[v]);
                //if(v == 2) printf("dist %lf v0 %lf vt %lf vf %lf %d to %d is %lf %lf\n",edge[i].d,v0, vt, vf, u, v,tt,dist[u]);
               // if(v == 20) printf(".dist %lf v0 %lf vt %lf vf %lf %d to %d is %lf %lf\n",edge[i].d,v0, vt, vf, u, v,tt,dist[u]);
               // if(u==1) printf("dist %lf v0 %lf vt %lf vf %lf %d to %d is %lf %lf\n",edge[i].d,v0, vt, vf, u, v,tt,dist[u]);

                Q.push(HeapNode(v, vf, dist[v]));
            }
        }
    }
}
int map[maxn][maxn];
int main()
{
    //freopen("in.txt", "r", stdin);
    //freopen("out.txt", "w", stdout);
    memset(vis, 0, sizeof(vis));
    scanf("%d%d%d%lf%lf%lf", &W, &L, &n, &a, &vm, &vp);
    if(dcmp(vm - vp) < 0) vp = vm;
   // double dd;
   // printf("%lf\n", get_time(0, vm, 8, dd));
    scanf("%d%d%d%d", &pos[1].first, &pos[1].second, &pos[2].first, &pos[2].second);
    vis[pos[1].first][pos[1].second] = 1;
    vis[pos[2].first][pos[2].second] = 2;
    map[pos[1].first][pos[1].second] = 1;
    map[pos[2].first][pos[2].second] = 2;
    for(int i = 3; i < n + 3; i++){
        int x, y;
        scanf("%d%d", &x, &y);
        map[x][y] = 3;
        pos[i].first = x;
        pos[i].second = y;
        vis[x][y] = i;
    }
    /*for(int i = 0; i <= W; i++){
        for(int j = 0; j <= L; j++)
            if(map[i][j] == 1) printf("S");
            else if(map[i][j] == 2) printf("T");
            else if(map[i][j] == 3) printf("%d", vis[i][j]);
            else printf("*");
        printf("\n");
    }*/
    init();
    for(int i = 1; i < n + 3; i++){
        int x = pos[i].first;
        int y = pos[i].second;
        memset(vis2, 0, sizeof(vis2));
        memset(d, INF, sizeof(d));
        neighbor.clear();
        bfs(x, y, i);
        sort(neighbor.begin(), neighbor.end());
        for(int j = 0; j < (int)neighbor.size(); j++){
            int aa, bb;
            aa = i, bb = neighbor[j];
            if(aa == 1) aa = 0;
            else if(aa == 2) aa = aa = n + 1;
            else aa = aa - 2;
            if(bb == 1) bb = 0;
            else if(bb == 2) bb = bb = n + 1;
            else bb = bb - 2;
            //printf("%d to %d distance is %d\n", aa, bb, d[neighbor[j]]);
            add(i, neighbor[j], d[neighbor[j]]);
        }
    }
    dijkstra();
    printf("%.10lf\n", dist[2]);
    return 0;
}

   	  	 			  				 		 	 		     	