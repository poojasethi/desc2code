/*
 * 	Date:
 *		2015/10/22
 * 	Author:
 *		OpenPandora
 */
#include <map>
#include <set>
#include <cmath>
#include <queue>
#include <cstdio>
#include <string>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
string _in = "data";
string _out = "data";
#define sqr(x) ((x)*(x))
const int maxn = 123, dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};
const double inf = 1e36;
int w, l, n, ed[2], st[2], x, y, nx, ny, ind, police[maxn][maxn], xx[maxn], yy[maxn], dis[maxn][maxn], vis[maxn];
double vmax, vp, a, dt, nv, dist[maxn][maxn], ans[maxn], v[maxn];
void bfs( const int &id ){
	queue<pair<int,int> >q;
	memset( dis , -1 , sizeof ( dis ) );
	dis[xx[id]][yy[id]] = 0;
	q.push( make_pair( xx[id] , yy[id] ) );
	while( !q.empty() ){
		x = q.front().first;
		y = q.front().second;
		q.pop();
		ind = police[x][y];
		if( ind && ind != id ){
			dist[id][ind] = dis[x][y];
			continue;
		}
		for( int i = 0 ; i < 4 ; i ++ ){
			nx = x + dx[i];
			ny = y + dy[i];
			if( nx < 0 || ny < 0 || nx > w || ny > l )
				continue;
			if( dis[nx][ny] > -1 )
				continue;
			dis[nx][ny] = dis[x][y] + 1;
			q.push( make_pair( nx , ny ) );
		}
	}
}
void solve( const double &v0 , const double &vt , const double &s , double &dt , double &nv ){
	double ts = ( sqr( vmax ) * 2.0 - sqr( v0 ) - sqr( vt ) ) / ( 2.0 * a ), mv = sqrt( a * s + ( sqr( v0 ) + sqr( vt ) ) / 2.0 );
	if( v0 >= vt ){
		if( sqr( v0 ) - sqr( vt ) - 2.0 * a * s > 0 ){
			dt = ( v0 - vt ) / a;
			nv = vt;
			return;
		}
		if( ts <= s ){
            dt = ( 2 * vmax - v0 - vt ) / a + ( s - ts ) / vmax;
            nv = vt;
        }else{
            dt = ( 2 * mv - v0 - vt ) / a;
            nv = vt;
        }
	}else{
        if( ( sqr( vt ) - sqr( v0 ) - ( 2.0 * a * s ) ) > 0 ){
            nv = sqrt( sqr( v0 ) + 2 * a * s );
            dt = ( nv - v0 ) / a;
            return;
        }
        if( ts <= s ){
            dt = ( 2 * vmax - v0 - vt ) / a + ( s - ts ) / vmax;
            nv = vt;
        }else{
            dt = ( 2 * mv - v0 - vt ) / a;
            nv = vt;
        }

    }

}
void spfa(){
	queue<int>q;
	q.push( 0 );
	vis[0] = 1;
	ans[0] = 0;
	while( !q.empty() ){
		x = q.front();
		q.pop();
		vis[x] = 0;
		for( int i = 1 ; i <= n + 1 ; i ++ ){
			if( i == x )
				continue;
			solve( v[x] , ( i <= n ? vp : vmax ) , dist[x][i] , dt , nv );
			if( ans[i] > dt + ans[x] ){
				ans[i] = dt + ans[x];
				v[i] = nv;
				if( !vis[i] ){
					vis[i] = 1;
					q.push( i );
				}
			}
		}
	}
}
int main(){
//	freopen( ( _in + ".in" ).c_str() , "r" , stdin );
//	freopen( ( _out + ".out" ).c_str() , "w" , stdout );
	scanf( "%d %d %d %lf %lf %lf" , &w , &l , &n , &a , &vmax , &vp );
	vp = min( vp , vmax );
	scanf( "%d %d %d %d" , &st[0] , &st[1] , &ed[0] , &ed[1] );
	for( int i = 1 ; i <= n ; i ++ ){
		scanf( "%d %d" , &xx[i] , &yy[i] );
		police[xx[i]][yy[i]] = i;
	}
	xx[0] = st[0],	yy[0] = st[1];
	xx[n+1] = ed[0],	yy[n+1] = ed[1];
	police[ed[0]][ed[1]] = n + 1;

	for( int i = 0 ; i <= n + 1 ; i ++ ){
		for( int j = 0 ; j <= n + 1 ; j ++ )
			dist[i][j] = inf;
		ans[i] = inf;
	}

	for( int i = 0 ; i <= n ; i ++ )
		bfs( i );

	spfa();
	printf( "%.10f\n" , ans[n+1] );
	return 0;
}

							   	 	 	  			  		 	  		