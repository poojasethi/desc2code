#include<cstdio>
#include<queue>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<cstring>
#define N 110
#define eps 1e-7
using namespace std;
const int mx[4]={1,0,-1,0},my[4]={0,1,0,-1};
int dis[N][N][N];
int x[N],y[N];
bool oc[N][N];
double spd[N];
double rt[N][N];
double cal_time(double d,double s1,double s2,double ms,double a){
	if(d>1e9) return 1e9;
	double d1=(ms*ms-s1*s1)/2/a,d2=(ms*ms-s2*s2)/2/a;
	if(d1+d2<d) return (ms-s1)/a+(ms-s2)/a+(d-d1-d2)/ms;
	double x=sqrt(a*d+0.5*(s1*s1+s2*s2));
	return ((x-s1)+(x-s2))/a;
}
int main(){
	memset(dis,0x3f,sizeof(dis));
	int sx,sy,tx,ty;
	int w,l,n;
	double a,vm,vp,ans=1e9;
	scanf("%d%d%d%lf%lf%lf",&w,&l,&n,&a,&vm,&vp);
	if(vp>vm) vp=vm;
	scanf("%d%d%d%d",&sx,&sy,&tx,&ty);
	x[0]=sx;
	y[0]=sy;
	for(int i=1;i<=n;i++) scanf("%d%d",&x[i],&y[i]);
	for(int i=0;i<=n;i++){
		oc[x[i]][y[i]]=true;
		double ms = sqrt(2*a*(abs(x[i]-sx)+abs(y[i]-sy)));
		spd[i] = min(ms,vp);
	}
	for(int i=0;i<=n;i++){
		queue<int> qx,qy;
		qx.push(x[i]);
		qy.push(y[i]);
		dis[i][x[i]][y[i]]=0;
		while(!qx.empty()){
			int tx=qx.front(),ty=qy.front();
			qx.pop(),qy.pop();
			for(int j=0;j<4;j++){
				int nx=tx+mx[j],ny=ty+my[j];
				if(nx>=0&&nx<=w&&ny>=0&&ny<=l&&dis[i][tx][ty]+1<dis[i][nx][ny]){
					dis[i][nx][ny]=dis[i][tx][ty]+1;
					if(!oc[nx][ny]){
						qx.push(nx);
						qy.push(ny);
					}
				}
			}
		}
	}
	for(int i=0;i<=n;i++){
		for(int j=0;j<=n;j++){
			rt[i][j]=cal_time(dis[i][x[j]][y[j]],spd[i],spd[j],vm,a);
		}
	}
	for(int i=0;i<=n;i++){
		for(int j=0;j<=n;j++){
			for(int k=0;k<=n;k++){
				if(rt[j][i]+rt[i][k]<rt[j][k]) rt[j][k]=rt[j][i]+rt[i][k];
			}
		}
	}
	for(int i=0;i<=n;i++){
		if(dis[i][tx][ty]>1e9) continue;
		double tmp;
		if((vm*vm-spd[i]*spd[i])/2/a > dis[i][tx][ty]){
			tmp=(sqrt(spd[i]*spd[i]+2*a*dis[i][tx][ty])-spd[i])/a;
		}
		else tmp=cal_time(dis[i][tx][ty],spd[i],vm,vm,a);
		if(rt[0][i]+tmp<ans) ans=rt[0][i]+tmp;
	}
	printf("%.10f\n",ans);
	return 0;
}