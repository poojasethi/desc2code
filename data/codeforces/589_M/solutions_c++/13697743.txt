#include <iostream>
#include <fstream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
#include <cmath>
#include <map>
#include <set>
#include <queue>
#define forn(i, n) for(int i = 0; i < n; i++)
#define sz(a) (int)a.size()
#define re  return
#define mp(a, b) make_pair(a, b)
#define fi first
#define se second
#define x1 x11
#define y1 y11
#define x2 x22
#define y2 y22
typedef long long ll;
typedef long double ld;
using namespace std;
const int xx[4] = {0, 1, -1, 0}, yy[4] = {1, 0, 0, -1};
int x1, x2, y1, y2, n, m, k, x, y, a[200][200], b[200][200], use[200][200];
long double ac, vmax, vp, t, v0, fld[200][200], v1, v2, t2, t1, s;
vector<pair<ld, pair<int, int> > > police;
queue<pair<int, int> > qq;
int main() {
   // ifstream cin ("input.txt");
    cin >> n >> m >> k >> ac >> vmax >> vp >> x1 >> y1 >> x2 >> y2;
    police.push_back(mp(ld(0), mp(x1, y1)));
    police.push_back(mp(vmax, mp(x2, y2)));
    forn (i, k) {
    	cin >> x >> y;
    	t = sqrt(ld(2 * abs(x - x1) + 2 * abs(y - y1)) / ac);
    	v0 = ac * t;
    	if (v0 > vmax) v0 = vmax;
    	if (v0 > vp) {
    		police.push_back(mp(vp, mp(x, y)));
		}
	}
	forn (j, sz(police))
	forn (i, sz(police)) {
		a[i][j] = 1000000000;
		b[police[i].second.first][police[i].second.second] = i + 1;
	}

	forn (ii, sz(police)) {
		forn (j, n + 1) {
			forn (k, m + 1) use[j][k] = 0;
		}
		qq.push(police[ii].second);
		use[qq.front().fi][qq.front().se] = 1;
		while (!qq.empty()) {
			forn (i, 4)
				if (qq.front().fi + xx[i] >= 0 && qq.front().fi + xx[i] <= n)
				if (qq.front().se + yy[i] >= 0 && qq.front().se + yy[i] <= m) {
					int bb = qq.front().se + yy[i], aa = qq.front().fi + xx[i];
					if (use[aa][bb] == 0) {
						if (b[aa][bb] > 0) {
							a[ii][b[aa][bb] - 1] = min(a[ii][b[aa][bb] - 1], use[qq.front().fi][qq.front().se]);
						}
						else {
							qq.push(mp(aa, bb));
							use[aa][bb] = use[qq.front().fi][qq.front().se] + 1;
						}
					}
				}
			qq.pop();
		}
	}

	forn (i, sz(police))
		forn (j, sz(police))
			if (a[i][j] < 1000000000) {
				v1 = police[i].fi;
				v2 = police[j].fi;
				if (v1 > v2) swap(v1, v2);
				ld vv = sqrt(2 * ac * ld(a[i][j]) + v1 * v1);
				if (v2 > vv) v2 = vv;
				t = (vmax - v1) / ac + (vmax - v2) / ac;
				s = (vmax * vmax - v1 * v1) / (2 * ac) + (vmax * vmax - v2 * v2) / (2 * ac);
				if (s <= a[i][j]) {
					fld[i][j] = t + (ld(a[i][j]) - s) / vmax;
				}
				else {
					v0 = sqrt(ac * ld(a[i][j]) + v1 * v1 / ld(2) + v2 * v2 / ld(2));
					fld[i][j] = (v0 - v1) / ac + (v0 - v2) / ac;
				}
			}
			else fld[i][j] = 1000000000;
    forn (k, sz(police))
    	forn (i, sz(police))
    		forn (j, sz(police))
    			if (i != j && fld[i][k] < 1000000000 && fld[k][j] < 1000000000 && i != k
    				&& j != k && fld[i][j] > fld[i][k] + fld[k][j])
    				fld[i][j] = fld[i][k] + fld[k][j];
    cout.precision(20);
	cout << fld[0][1];
	return 0;
}
