#include <stdio.h>
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <queue>
#include <map>
#include <set>
#include <cmath>
#include <sstream>
#include <stack>
#include <cassert>
#include <string.h>
#include <valarray>

#define pb push_back
#define mp make_pair
#define PI 3.1415926535897932384626433832795
#define sqr(x) (x)*(x)
#define forn(i, n) for(int i = 0; i < n; ++i)
#define ALL(x) x.begin(), x.end()
#define sz(x) int((x).size())
#define X first
#define Y second
typedef long long ll;
typedef unsigned long long ull;
typedef long double ld;
using namespace std;
typedef pair<int,int> pii;
const int INF = 2147483647;
const ll LLINF = 9223372036854775807LL;

const int maxn = 510;
bool trap[maxn];

vector<int> a[maxn];

valarray<double> v[maxn];

int sm[maxn][maxn];
int deg[maxn];


const int maxk = 110;
int K;
struct matr {
	double a[maxk][maxk];
	matr() {
		memset(a,0,sizeof(a));
	}
	matr operator*(const matr& o) const {
		matr res;
		forn(i, K) forn(j, K) forn(k, K) res.a[i][j] += a[i][k] * o.a[k][j];
		return res;
	}
	matr pow(int n) {
		matr res;
		forn(i, K) res.a[i][i] = 1;
		matr t = *this;
		while (n) {
			if (n&1) res = res * t;
			t = t * t;
			n >>= 1;
		}
		return res;
	}
};

int main()
{
#ifdef _DEBUG
	freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);
#endif
	int n, m, k; scanf("%d%d%d", &n, &m, &k);
	K = 1;
	forn(i, n) {
		int cur; scanf("%d", &cur); trap[i] = cur;
		K += cur;
	}
	forn(i, m) {
		int fr, to; scanf("%d%d", &fr, &to); --fr, --to;
		deg[fr]++;
		deg[to]++;
		sm[fr][to]++;
		sm[to][fr]++;
		a[fr].pb(to);
		a[to].pb(fr);
	}
	int N = n+n;
	forn(i, n) {
		v[i].resize(N);
		v[i][n+i] += 1, v[i][i] += 1;
	}
	forn(i, n) {
		forn(j, sz(a[i])) {
			int to = a[i][j];
			if (!trap[to]) v[i][to] -= 1./sz(a[i]);
		}
	}
	forn(i, n) {
		int ind = i;
		for (int r = i; r < n; ++r) if (fabs(v[r][i]) > fabs(v[ind][i])) ind = r;
		swap(v[i], v[ind]);
		double dd = v[i][i]; v[i] /= dd;
		forn(r, n) {
			if (r == i) continue;
			dd = v[r][i];
			v[r] -= v[i] * dd;
		}
	}
	vector<int> p;
	p.pb(0);
	forn(i, n) if (trap[i]) p.pb(i);
	assert(sz(p) == K);
	matr mm;
	forn(ii, K) {
		int fr = p[ii];
		forn(jj, K) {
			int to = p[jj];
			if (to == 0) continue;
			double val = 0;
			forn(tt, n) {
				val += v[fr][n+tt] * sm[to][tt] / (double)deg[tt];
			}
			mm.a[ii][jj] = val;
		}
	}
	matr mk = mm.pow(k-1);
	double result = mk.a[0][K-1];
	printf("%.15lf\n", result);
	return 0;
}
