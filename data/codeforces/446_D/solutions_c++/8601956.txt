#include<stdio.h>
#include<queue>
#include<iostream>
#include<string.h>
#include<vector>
#include<algorithm>
#include<map>
#include<math.h>
using namespace std;

const int maxn=510;

double coe[maxn][maxn];
double g[maxn][maxn];
double rht[maxn],ret[maxn];

void cal_ans(int n)
{
	int i,j;
	for(i=n;i>=1;i--)
	{
		ret[i]=rht[i]/g[i][i];
		for(j=i;j>=1;j--)
			rht[j]-=ret[i]*g[j][i];
	}
}

double val[maxn];
void cal(int n)
{
	int i,j;
	for(i=1;i<=n;i++)
	{
		rht[i]=0;
		for(j=1;j<=n;j++)
			rht[i]+=coe[i][j]*val[j];
	}
	cal_ans(n);
}

void gauss(int n)
{
	memset(coe,0,sizeof(coe));
	int i,j,k;
	for(i=1;i<=n;i++)
		coe[i][i]=1;
	
	for(i=1,j=1;i<=n&&j<=n;i++,j++)
	{
		int chosen=i;
		for(k=i+1;k<=n;k++)if(fabs(g[k][j])>fabs(g[chosen][j]))
			chosen=k;
		if(fabs(g[chosen][j])<1e-8)
			continue;
		for(k=1;k<=n;k++)
			swap(g[i][k],g[chosen][k]),swap(coe[i][k],coe[chosen][k]);
		for(k=i+1;k<=n;k++)
		{
			double chu=g[k][j]/g[i][j];
			for(int t=j;t<=n;t++)
				g[k][t]-=g[i][t]*chu;
			for(int t=1;t<=n;t++)
				coe[k][t]-=coe[i][t]*chu;
		}
	}
	if(i<=n)
		puts("WOCA");
	if(j<=n)
		puts("WORI");
}

struct mat
{
	double arr[102][102];
	int n;
	
	mat(int nn,int is=0)
	{
		n=nn;
		memset(arr,0,sizeof(arr));
		if(!is)
			return;
		for(int i=1;i<=n;i++)
			arr[i][i]=1;
	}
	mat(const mat& N)
	{
		n=N.n;
		memcpy(arr,N.arr,sizeof(arr));
	}
	
	mat operator *(const mat& N)
	{
		mat ret(n);
		int i,j,k;
		
		for(i=1;i<=n;i++)
		{
			for(j=1;j<=n;j++)
			{
				for(k=1;k<=n;k++)
					ret.arr[i][j]+=arr[i][k]*N.arr[k][j];
			}
		}
		return ret;
	}
};

mat myPow(int n,mat a,int b)
{
	mat ret(n,1);
	while(b)
	{
		if(b&1)
			ret=ret*a;
		a=a*a;
		b>>=1;
	}
	return ret;
}

int is[maxn],d[maxn];
int UU[110000],VV[110000];

double init[maxn];
vector<int>ch[maxn];

int main()
{
	int n,m,k,i,j,cnt=0;
	
	scanf("%d%d%d",&n,&m,&k);
	for(i=1;i<=n;i++)
	{
		scanf("%d",&is[i]),g[i][i]=1;
		if(is[i])
			is[i]=++cnt;
	}
	
	for(i=1;i<=m;i++)
	{
		scanf("%d%d",&UU[i],&VV[i]);
		d[UU[i]]++,d[VV[i]]++;
	}
	
	for(i=1;i<=m;i++)
	{
		int u=UU[i],v=VV[i];
		ch[u].push_back(v);
		ch[v].push_back(u);
		if(!is[u])
			g[v][u]-=1.0/d[u];
		if(!is[v])
			g[u][v]-=1.0/d[v];
	}
	
	gauss(n);
	mat a(cnt);
	
	val[1]=1;
	cal(n);
	
	for(i=1;i<=n;i++)if(is[i])
		init[is[i]]=ret[i];
	
	for(i=1;i<=n;i++)if(is[i])
	{
		memset(val,0,sizeof(val));
		for(j=0;j<ch[i].size();j++)
		{
			int v=ch[i][j];
			val[v]+=1.0/d[i];
		}
		cal(n);
		for(j=1;j<=n;j++)if(is[j])
			a.arr[is[j]][is[i]]=ret[j];
	}
	
	a=myPow(cnt,a,k-2);
	double ans=0;
	for(i=1;i<=cnt;i++)
		ans+=a.arr[cnt][i]*init[i];
	printf("%.12lf\n",ans);
}