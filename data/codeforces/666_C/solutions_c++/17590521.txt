#include <bits/stdc++.h>
using namespace std;

#define mp(x, y) make_pair((x), (y))

typedef long long ll;

const ll mod=1000000007;

int m;
char s[100005];
int n, l;

struct query {
	int n, l;
	int ans;
	int id;
	query() : ans(0) {}
} q[100005];
int cnt;

bool cmp1(const query &q1, const query &q2) {
	return (q1.l<q2.l || (q1.l==q2.l && q1.n<q2.n));
}

bool cmp2(const query &q1, const query &q2) {
	return q1.id<q2.id;
}

ll expo(ll b, ll e)
{
	ll ret=1;
	while(e) {
		if(e&1) ret=(ret*b)%mod;
		b=(b*b)%mod;
		e>>=1;
	}
	return ret;
}

ll inv(ll n)
{
	return expo(n, mod-2);
}

ll fact[100005];
ll invfact[100005];
ll ex[100005];

ll comb(int n, int k)
{
	return ((fact[n]*invfact[k])%mod*invfact[n-k])%mod;
}

ll ans(int n, int s)
{
	ll ret=expo(26, n);
	if(n<s) return 0;
	ll ex=expo(25, n-(s-1));
	for(int k=s-1; k>=0; k--) {
		ret=(ret+mod-(ex*comb(n, k))%mod)%mod;
		ex=(ex*25)%mod;
	}
	return ret;
}

int main()
{
	fact[0]=1;
	for(ll i=1; i<=100000; i++) fact[i]=(i*fact[i-1])%mod;
	for(int i=0; i<=100000; i++) invfact[i]=inv(fact[i]);
	ex[0]=1;
	for(int i=1; i<=100000; i++) ex[i]=(ex[i-1]*25)%mod;
	scanf("%d\n", &m);
	scanf("%s\n", s);
	l=strlen(s);
	for(int i=0; i<m; i++) {
		int t;
		scanf("%d ", &t);
		if(t==1) {
			scanf("%s\n", s);
			l=strlen(s);
		} else {
			scanf("%d\n", &n);
			q[cnt].n=n;
			q[cnt].l=l;
			q[cnt].id=cnt;
			cnt++;
		}
	}
	sort(q, q+cnt, cmp1);
	for(int i=0; i<cnt; ) {
		int j=i;
		while(j<cnt && q[j].l==q[i].l) j++;
		while(i<j && q[i].n<q[i].l) i++;
		n=l=q[i].l;
		ll cur=1;
		while(i<j) {
			while(n<q[i].n) {
				ll tmp=(ex[n-(l-1)]*comb(n, l-1))%mod;
				cur=(cur*26+tmp)%mod;
				n++;
			}
			q[i].ans=(int)cur;
			i++;
		}
		i=j;
	}
	sort(q, q+cnt, cmp2);
	for(int i=0; i<cnt; i++) printf("%d\n", q[i].ans);

	return 0;
}
