#include <bits/stdc++.h>

using namespace std;

#define FOR(i,a,b) for(int i = a; i < b; i++)
#define FORR(i,b) FOR(i, 0, b)
#define sz(e) (int)e.size()
#define CLR(x,v) memset (x, v, sizeof x)
#define pb push_back
#define all(e) e.begin(), e.end()

typedef long long ll;
typedef pair<int, int> ii;
typedef pair<int, pair<int, int> > iii;

const int MAXN = 200005;
const int INF = 1000000000;

const int MOD = INF + 7;

ll power (int n, int p){
	ll base = n, res = 1;
	while (p){
		if (p&1) res = (res * base) % MOD;
		base = (base * base) % MOD;
		p >>= 1;
	}
	return res;
}

ll fat[MAXN], ifat[MAXN];
ll p25[MAXN];
ll v[MAXN];

void solve (int t) {
	FORR (i, t) v[i] = 0LL;
	v[t] = 1LL;
	FOR (n, t+1, MAXN) {
		//Pega o anterior e multiplica por 26
		v[n] = (26 * v[n-1]) % MOD;
		ll num = fat[n-1];
		ll div = (ifat[n-t] * ifat[t-1]) % MOD;
		ll S = (num * p25[n-t]) % MOD;
		S = (S * div) % MOD;
		v[n] = (v[n] + S) % MOD;
	}
}


int ans[MAXN];

int main () {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    fat[0] = p25[0] = 1LL;
    FOR (i, 1, MAXN) fat[i] = (fat[i-1] * i) % MOD;
    FORR (i, MAXN) ifat[i] = power (fat[i], MOD-2);
    FOR (i, 1, MAXN) p25[i] = (25LL * p25[i-1]) % MOD;
	
	int m;
	cin>>m;
	string s;
	cin>>s;
	vector< iii > reqs;
	FORR (i, m) {
		int t;
		cin>>t;
		if (t==1) {
			cin>>s;
		} else {
			int n; cin>>n;
			reqs.pb (iii (sz(s), ii (n, i)));
		}
	}
	sort (all(reqs));
	CLR (ans, -1);
	FORR (i, sz(reqs)) {
		if (i==0 || reqs[i].first>reqs[i-1].first) {
			solve (reqs[i].first);
		}
		ans[reqs[i].second.second] = v[reqs[i].second.first];
	}
	FORR (i, MAXN) if (ans[i]!=-1) cout << ans[i] << endl;
}