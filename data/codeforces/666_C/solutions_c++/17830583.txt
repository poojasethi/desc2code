#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <ctime>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <vector>
#include <bitset>
#include <functional>
using namespace std;
const long long mod = 1e9 + 7;
const int maxn = 100005;
inline int read ()
{
	int res, ok = 1;
	char ch;
	for (ch = getchar (); ch < '0' || ch > '9'; ch = getchar ())
	if (ch == '-')
	ok = -1;
	res = ch - '0';
	for (ch = getchar (); ch >= '0' && ch <= '9'; ch = getchar ())
	res = res * 10 + ch - '0';
	return res * ok;
}
long long dp[maxn], inv[maxn], f[maxn], pw[maxn];
inline long long qpow (long long a, long long b)
{
	long long sum = 1;
	while (b)
	{
		if (b & 1)
		sum = sum * a % mod;
		b >>= 1;
		a = a * a % mod;
	}
	return sum;
}
inline void prework ()
{
	pw[0] = inv[0] = f[0] = 1;
	for (int i = 1; i <= 100000; i++)
	{
		pw[i] = pw[i - 1] * 25LL % mod;
		f[i] = f[i - 1] * i % mod;
		inv[i] = inv[i - 1] * qpow (i, mod - 2) % mod;
	}
}
inline long long C (long long a, long long b)
{
	return f[a] * inv[b] % mod * inv[a - b] % mod;
}
inline void work (int x)
{
	for (int i = 0; i < x; i++)
	dp[i] = 0;
	for (int i = x; i <= 100000; i++)
	dp[i] = (dp[i - 1] * 26 % mod + pw[i - x] * C (i - 1, x - 1) % mod) % mod;
}
vector <int> g[maxn];	
struct node
{
	int op, n;
}q[maxn];
long long ans[maxn];
char s[maxn];
int n, op, m, len;
int main()
{
	prework ();
	m = read();
	scanf ("%s", s);
	len = strlen (s);
	g[len].push_back(0);
	q[0].op = 1;
	for(int i = 1; i <= m; i++)
	{
		op = read();
		q[i].op = op;
		if(op == 1)
		{
			scanf ("%s", s);
			len = strlen (s);
			g[len].push_back(i);
		}
		else
		{
			n = read();
			q[i].n = n;
		}
	}
	for(int i = 1; i <= 100000; i++)
	{
		if(!g[i].size())
		continue;
		work(i);
		for(int j = 0; j < g[i].size(); j++)
		for(int k = g[i][j] + 1; k <= m && q[k].op != 1; k++)
		ans[k] = dp[q[k].n];
	}
	for(int i = 1; i <= m; i++)
	if(q[i].op == 2)
	printf ("%I64d\n", ans[i]);
	return 0;
}
