#include <cmath>
#include <map>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <set>
#include <bitset>
#include <memory.h>
#include <functional>
#include <queue>
#include <fstream>
#include <ctime>
#include <deque>
#include <utility>
#include <stack>
#include <sstream>
#include <list>
#include <cctype> 
#include <numeric> 
#include <iomanip>
#include <assert.h>
using namespace std;
#define sqr(_) ((_)*(_))

typedef pair<int, int> Pii;
#define x first
#define y second
#define mp make_pair
#define pb push_back

typedef long long LL;

const int MAXN = 1000000 + 10, T = 30;

inline LL Read()
{
	char ch = getchar();
	while (!((ch >= '0' && ch <= '9') || ch == '-')) ch = getchar();
	LL x = 0, p = 1;
	if (ch == '-') p = -1, ch = getchar();
	while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
	return x * p;
}

int hash[MAXN], prime[MAXN], tot;
int n, m, p[MAXN];
LL a[MAXN], K;
vector<Pii> tp[MAXN];

void Print()
{
	int Tohka = 0;
	for (int i = 1; i < MAXN; ++i)
		Tohka += (a[i] > 0);
	printf("%d\n", Tohka);
	for (int i = 1; i < MAXN; ++i)
		if (a[i])
			printf("%d %I64d\n", i, a[i]);
}
int main()
{
#ifndef ONLINE_JUDGE
	freopen("input.txt", "r", stdin), freopen("output.txt", "w", stdout);
#endif
	
	for (int i = 2; i < MAXN; ++i)
		if (!hash[i])
		{
			prime[++tot] = i;
			for (int j = i + i; j < MAXN; j += i)
				hash[j] = true;
		}

	n = Read();
	for (int i = 1; i <= n; ++i)
	{
		p[i] = Read();
		a[p[i]] = Read();
	}
	K = Read();

	for (int i = 1; i <= tot; ++i)
	{
		int x = prime[i] - 1, t = x;
		for (int j = 1; prime[j] * prime[j] <= t; ++j)
			if (t % prime[j] == 0)
			{
				int cnt = 0;
				for (; t % prime[j] == 0; ++cnt, t /= prime[j]);
				tp[x].pb(mp(prime[j], cnt));
			}
		if (t > 1)
			tp[x].pb(mp(t, 1));
	}
	
	for (int tt = 1; tt <= min((LL)T, K); ++tt)
		for (int i = 1; i <= tot; ++i)
			if (a[prime[i]])
			{
				int p = prime[i];
				--a[p];
				for (int j = 0; j < (int)tp[p - 1].size(); ++j)
					a[tp[p - 1][j].x] += tp[p - 1][j].y;
			}
	if (K <= T) Print(), exit(0);
	K -= T;
	for (int i = tot; i >= 1; --i)
		if (a[prime[i]])
		{
			int p = prime[i];
			for (int j = 0; j < (int)tp[p - 1].size(); ++j)
				a[tp[p - 1][j].x] += min(a[p], K) * tp[p - 1][j].y;
			a[p] -= K; a[p] = max(a[p], 0ll);
		}
	Print();
/*
	for (int tt = 1; tt <= min((LL)T, K); ++tt)
		for (int i = 1; i <= tot; ++i)
		{
			int p = prime[i];
			if (a[p])
				--a[p];
			for (int k = 1; k * p + 1 < MAXN; ++k)
				if (a[p * k + 1])
					a[p] += ;
		}
	if (K <= T) Print(), exit(0);
	K -= T;
	for (int i = tot; i >= 1; --i)
	{
		int p = prime[i];
		for (int k = 1; k * p + 1 < MAXN; ++k)
			if (a[p * k + 1])
				a[p] += min(a[p * k + 1], K) * ;
	}
	for (int i = 1; i <= tot; ++i)
		a[prime[i]] -= K, a[prime[i]] = max(a[prime[i]], 0ll);
	Print();
*/
	
	fclose(stdin);
	fclose(stdout);
	return 0;
}
