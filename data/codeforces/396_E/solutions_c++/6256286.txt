#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <climits>
#include <cstdlib>
#include <queue>
#include <vector>
#include <cmath>
#define Px first
#define Py second
using namespace std;
const int MAXP = 1e6 + 5, MAXM = 1e5 + 5;
typedef long long LL;
typedef pair<LL, LL> Pi;
int m; LL res[MAXP], k;
vector <Pi> times[MAXP];
struct PrimeTable
{
    int prime[MAXP], tot, sdiv[MAXP];
    PrimeTable()
    {
        tot = 0;
        for (int i = 2; i < MAXP; ++i) {
            if (!sdiv[i]) {
                prime[++tot] = sdiv[i] = i;
            }
            for (int j = 1; j <= tot && (LL)prime[j] * i <= MAXP; ++j) {
                sdiv[prime[j] * i] = prime[j];
                if (i % prime[j] == 0) break;
            }
        }
    }
}pri;

int main()
{
    scanf("%d", &m);
    for (int i = 1; i <= m; ++i) {
        int p; LL a; scanf("%d %I64d", &p, &a);
        times[p].push_back(Pi(0, a));
    }
    scanf("%I64d", &k);
    for (int i = MAXP - 1; i > 1; --i) {
        if (times[i].empty()) continue;
        sort(times[i].begin(), times[i].end());
        vector <Pi> ntimes;
        for (vector<Pi>::iterator j = times[i].begin(); j != times[i].end(); ++j) {
            if (ntimes.empty() || ntimes.back().Py < j->Px)
                ntimes.push_back(Pi(j->Px, j->Py));
            else ntimes.back().Py += j->Py - j->Px;
        }
        for (vector<Pi>::iterator j = ntimes.begin(); j != ntimes.end(); ++j) {
            if (j->Py > k) {
                res[i] += j->Py - k;
                j->Py = k;
            }
            if (j->Px < k) {
                for (int mp = i - 1; mp > 1; mp /= pri.sdiv[mp])
                    times[pri.sdiv[mp]].push_back(Pi(j->Px + 1, j->Py + 1));
            }
        }
    }
    int tot(0);
    for (int i = 2; i < MAXP; ++i) if (res[i]) ++tot;
    printf("%d\n", tot);
    for (int i = 2; i < MAXP; ++i) if (res[i])
        printf("%d %I64d\n", i, res[i]);
    //system("pause");
    return 0;
}