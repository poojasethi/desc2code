#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cctype>
#include<ctime>
#include<cstdlib>
#include<string>
#include<queue>
#include<cmath>
#include<set>
#include<map>
#include<bitset>
#include<vector>
#define Rep(x,a,b) for (int x=a;x<=(int)b;x++)
#define Drp(x,a,b) for (int x=a;x>=(int)b;x--)
#define Cross(x,a) for (int x=Hd[a];~x;x=Nx[x])
#define ll long long
#define INF (1<<29)
#define PII pair<int,int>
#define PDD pair<double,double>
#define mk(a,b) make_pair(a,b)
#define fr first
#define sc second
using namespace std;
inline ll Rd(){
	ll x=0;int ch=getchar(),f=1;
	while (!isdigit(ch)&&(ch!='-')&&(ch!=EOF)) ch=getchar();
	if (ch=='-'){f=-1;ch=getchar();}
	while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}
inline void Rt(ll x){
	if (x<0) putchar('-'),x=-x;
	if (x>=10) Rt(x/10),putchar(x%10+'0');
		else putchar(x+'0');
}
const int N=30005,M=205;
int F[2][M][2][2],G[2][M][2][2];
int S[2]={1,-1};
void Max(int &a,int b){if (b>a) a=b;}
int n,m,a[N];
int main(){
	n=Rd(),m=Rd();
	Rep(i,1,n) a[i]=Rd();
	int Fr=0,To=1;
	memset(F[Fr],200,sizeof F[Fr]);
	memset(G[Fr],200,sizeof G[Fr]);
	F[Fr][0][0][0]=F[Fr][0][0][1]=F[Fr][0][1][0]=F[Fr][0][1][1]=0;
	G[Fr][1][0][0]=G[Fr][1][0][1]=G[Fr][1][1][0]=G[Fr][1][1][1]=0;
	Rep(i,1,n){
		memset(F[To],200,sizeof F[To]);
		memset(G[To],200,sizeof G[To]);
		F[To][0][0][0]=F[To][0][0][1]=F[To][0][1][0]=F[To][0][1][1]=0;
		Rep(j,1,m) Rep(c1,0,1) Rep(c2,0,1){
			Max(F[To][j][c1][c2],F[Fr][j][c1][c2]);
			if (j==1) Max(F[To][j][c1][c2],G[Fr][j][c1][c2]+S[c2]*a[i]);
				else if (j==m) Max(F[To][j][c1][c2],G[Fr][j][c1][c2]-S[c1]*a[i]);
				else Max(F[To][j][c1][c2],G[Fr][j][c1][c2]+(S[c2]-S[c1])*a[i]);
			Max(G[To][j][c1][c2],F[To][j-1][0][c1]);
			Max(G[To][j][c1][c2],F[To][j-1][1][c1]);
			if (j==1) Max(G[To][j][c1][c2],G[Fr][j][c1][c2]+S[c2]*a[i]);
				else if (j==m) Max(G[To][j][c1][c2],G[Fr][j][c1][c2]-S[c1]*a[i]);
				else Max(G[To][j][c1][c2],G[Fr][j][c1][c2]+(S[c2]-S[c1])*a[i]);
		}
		To^=1,Fr^=1;
	}
	int Ans=0;
	Rep(c1,0,1) Rep(c2,0,1) Max(Ans,F[Fr][m][c1][c2]);
	Rt(Ans);
}
//F[i][j][c1][c2] c1(s(j-1)-sj)c2(sj-sj+1)...
/*
4 2
7 3 4 7
*/
