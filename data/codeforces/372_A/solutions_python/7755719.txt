# If we sort the array of kangaroos,
# Any optimal solution can be transformed into an equally optimal solution
# where all the holders are past the midpoint, and all the holdees are
# before it.  This means we don't have to choose between a kangaroo being
# a holder or a holdee.
# So if we start with the largest possible holder, we should pair him with the
# largest possible kangaroo he can hold.  Then the second largest holder
# should be paired with the largest kangaroo he can hold that isn't
# already held, etc.

n = int(raw_input())

kangaroo = []
for i in range(n):
    kangaroo.append(int(raw_input()))

kangaroo.sort()

holder = n - 1
holdee = n / 2 - 1

num_holders = 0
while holder > n / 2 - 1 and holdee > -1:
    if kangaroo[holder] >= 2 * kangaroo[holdee]:
        num_holders += 1
        holder -= 1
        holdee -= 1
    else:
        holdee -= 1

print n - num_holders
