#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#include <vector>
#include <set>
#include <queue>
#include <bitset>
#include <map>
#include <iostream>
#include <cassert>

using namespace std;

#define fru(j,n) for(int j=0; j<(n); ++j)
#define tr(it,v) for(typeof((v).begin()) it=(v).begin(); it!=(v).end(); ++it)
#define x first
#define y second
#define pb push_back
#define ALL(G) (G).begin(),(G).end()

//#define DEBUG
#ifdef DEBUG
	#define DEB printf
#else
	#define DEB(...)
#endif


typedef long long LL;
typedef pair<int,int> pii;
typedef vector<int> vi;

const int inft = 1000000009;
const int MAXN = 1000006;//10^6

vector<pair<int,pii> > E;
vector<pii> OK;
typedef bitset<150> stan;
typedef vector<stan> mac;


vector<bool> STAN,T2;
int n;

void jedenlot(){
	fru(i,n) T2[i]=0;
	tr(it,OK) if(STAN[it->x]) T2[it->y]=1;
	STAN=T2;
}
mac pusta;
mac mnoz(mac A, mac B){
	mac Q=pusta;
	fru(i,n) fru(j,n) if(A[i][j]) Q[i]|=B[j];
	return Q;
}

int main(){
	int m;
	scanf("%d%d",&n,&m);
	fru(i,m) {
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		--a;--b;
		E.pb(make_pair(c,pii(a,b)));
	}
	sort(ALL(E));
	int last=0;
	STAN.resize(n,0);
	STAN[0]=1;
	T2.resize(n);
	pusta=mac(n);
	fru(i,n) fru(j,n) pusta[i][j]=0;
	int juz=0;
	int kraw=0;
	while(kraw<E.size()){
		DEB("teraz juz = %d, kraw = %d\n",juz,kraw);
		while(juz<=last+n+2){
			DEB("\tjestem w juz = %d\n",juz);
			while(kraw<E.size() && E[kraw].x==juz){
				DEB("\t\t biore krawedz %d, (%d->%d)\n",E[kraw].x,E[kraw].y.x,E[kraw].y.y);
				last=E[kraw].x;
				OK.pb(E[kraw].y);
				++kraw;
			}
			jedenlot();
			++juz;
//			printf("teraz: (%d lotow)\n",juz);fru(i,n) if(STAN[i]) printf("%d ",i); printf("\n");
			if(STAN[n-1]){
				printf("%d\n",juz);
				return 0;
			}
		}
		if(kraw==E.size()){
			printf("Impossible\n");
			return 0;
		}
		assert(E[kraw].x>=juz);
		int ile=E[kraw].x-juz;
		DEB("terz juz = %d i lece o ile = %d\n",juz,ile);
		juz+=ile;
		last=juz;
		mac A=pusta;
		mac WYN=A;
		fru(i,n) WYN[i][i]=1;
		tr(it,OK) A[it->x][it->y]=1;
		while(ile){
			if(ile&1) WYN=mnoz(WYN,A);													A=mnoz(A,A);
			ile/=2;
		}
		fru(i,n) T2[i]=0;
		fru(i,n) if(STAN[i]) fru(j,n) if(WYN[i][j]) T2[j]=1;
		STAN=T2;
		if(STAN[n-1]){
			printf("%d\n",juz);
			return 0;
		}
	}
	printf("Impossible\n");
	return 0;
}
