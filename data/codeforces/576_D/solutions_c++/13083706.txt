#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int inf=1100000000,bl=30;
typedef int matr[211][211];
struct edge{
	int a,b,d;
}e[211];
struct edge2{
	int t,next;
}g[511];
matr a,b,c;
int ta[211][10],tb[10][211],h[211],i,j,k,n,m,f[211],ans,w[211],now,dis[211],q[211],t,tot,num;
void addedge(int x,int y){
	g[++tot].t=y;g[tot].next=h[x];h[x]=tot;
}
bool cmp(edge a,edge b){
	return a.d<b.d;
}
void mmul(matr &a,matr b){
	int i,j,k;
	memset(ta,0,sizeof(ta));memset(tb,0,sizeof(tb));
	for (i=1;i<=n;i++)
	 for (j=1,k=0;j<=n;j++){
	 	if (j%bl==1) k++;
	 	ta[i][k]=ta[i][k]*2+a[i][j];
	 	tb[k][i]=tb[k][i]*2+b[j][i];
	 }
	for (i=1;i<=n;i++)
	 for (j=1;j<=n;j++)
	  for (k=1,c[i][j]=0;k<=num;k++)
	   if (ta[i][k]&tb[k][j]){
	   	c[i][j]=1;break;
	   }
	for (i=1;i<=n;i++)
	 for (j=1;j<=n;j++) a[i][j]=c[i][j];
}
void mpw(int p){
	int i;
	memset(a,0,sizeof(a));
	for (i=1;i<=n;i++) a[i][i]=1;
	for (;p;p>>=1,mmul(b,b))
	 if (p&1) mmul(a,b);
}
int work(int lim){
	int i,j,l=0,r=0;
	memset(h,0,sizeof(h));tot=0;
	for (i=1;i<=m&&e[i].d<=lim;i++) addedge(e[i].a,e[i].b);
	for (i=1;i<=n;i++)
	 if (!f[i]) dis[i]=inf;else dis[i]=0,q[++r]=i;
	while (l<r){
		j=q[++l];
		for (i=h[j];i;i=g[i].next)
		 if (dis[g[i].t]==inf) dis[g[i].t]=dis[j]+1,q[++r]=g[i].t;
	}
	return dis[n];
}
int main(){
	scanf("%d%d",&n,&m);ans=inf;num=(n-1)/bl+1;
	for (i=1;i<=m;i++) scanf("%d%d%d",&e[i].a,&e[i].b,&e[i].d);
	sort(e+1,e+1+m,cmp);memset(f,0,sizeof(f));f[1]=1;
	if (e[1].d){
		puts("Impossible");return 0;
	}
	ans=min(ans,work(0));
	for (i=1,now=0;i<=m&&now<ans;i=j+1){
		for (j=i;j<=m&&e[j].d==now;j++);
		if (j>m) break;
		memset(b,0,sizeof(b));
		for (k=1;k<=m&&e[k].d<e[j].d;k++) b[e[k].a][e[k].b]=1;
		mpw(e[j].d-now);memset(w,0,sizeof(w));
		for (k=1;k<=n;k++)
		 for (t=1;t<=n;t++)
		  if (f[t]&a[t][k]){
		  	w[k]=1;break;
		  }
		memcpy(f,w,sizeof(f));
		now=e[j].d;ans=min(ans,now+work(e[j].d));
	}
	if (ans==inf) puts("Impossible");else printf("%d\n",ans);
	return 0;
}