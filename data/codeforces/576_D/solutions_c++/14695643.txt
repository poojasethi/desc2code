#include <cstdio>
#include <bitset>
#include <cstring>
#include <algorithm>
using namespace std;

int n,m,q,now;

struct str { int a,b,c; } edge[160];

bool cmp(str a,str b) { return (a.c < b.c); }

struct matrix {
	bitset<152> v[152],js;

	void operator *= (matrix b_) {
		matrix a,b; memcpy(a.v,v,sizeof(v));
		memset(v,0,sizeof(v));
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++)
				b.v[i][j] = b_.v[j][i];
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++) {
				js = a.v[i] & b.v[j];
				v[i][j] = v[i][j] | ((int) js.any());
			}
	}
} me,js,st;

void trans(int n) {
	matrix tr = st;
	me = js;
	for (; n; n >>= 1) {
		if (n & 1) me *= tr;
		tr *= tr;
	}
}

void trans_(int n_) {
	matrix tr = st;
	for (int i = 1; i <= n; i++) tr.v[i][i] = 1;
	me = js;
	for (; n_; n_ >>= 1) {
		if (n_ & 1) me *= tr;
		tr *= tr;
	}
}

int main() {
	scanf("%d %d",&n,&m);
	for (int i = 1; i <= m; i++) {
		scanf("%d %d %d",&edge[i].a,&edge[i].b,&edge[i].c);
	}
	js.v[1][1] = 1;
	sort(edge + 1,edge + m + 1,cmp);
	if (n == 1) { printf("0\n"); return 0; }
	if (edge[1].c != 0) { printf("Impossible\n"); return 0; }
	edge[m + 1].c = edge[m].c + 1000;
	for (q = 1,now = 0; true; ) {
		for (;q <= m && edge[q].c <= now; q++) st.v[edge[q].a][edge[q].b] = 1;
		trans_(edge[q].c - now);
		if (me.v[1][n]) {
			int L = 1, R = edge[q].c - now;
			while(L < R) {
				int mid = (L + R) >> 1;
				trans_(mid);
				if (me.v[1][n]) R = mid;
				else L = mid + 1;
			}
			printf("%d\n",now + L); return 0;
		}
		trans(edge[q].c - now);
		js = me;
		now = edge[q].c;
		if (q == m + 1) { printf("Impossible\n"); return 0; }		
	}
	return 0;
}