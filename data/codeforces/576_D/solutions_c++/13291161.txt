#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <bitset>

using namespace std;

struct bian_
{
	int a,b,d;
}bian[200]={{0,0,0}};
int N,M;
long long dist[200][200]={{0}};
long long ans=2e18;

struct Matrix
{
	int Q[200][200];
}can={{{0}}},B={{{0}}},O={{{0}}};

bitset <160> aa[160],bb[160];

Matrix operator *(Matrix a1,Matrix a2)
{
	Matrix b={{{0}}};
	for(int i=1;i<=N;i++)
		for(int j=1;j<=N;j++)
		{
			aa[i][j]=((a1.Q[i][j])&1);
			bb[j][i]=((a2.Q[i][j])&1);
		}
	for(int i=1;i<=N;i++)
		for(int j=1;j<=N;j++)
			b.Q[i][j]=((aa[i]&bb[j]).count())>0;
	return b;
}

bool cmp(struct bian_ a1,struct bian_ a2)
{return a1.d<a2.d;}

Matrix power(Matrix u,int k)
{
	Matrix v=O;
	for(;k>0;k>>=1)
	{
		if(k&1) v=v*u;
		u=u*u;
	}
	return v;
}

int main()
{
	cin>>N>>M;
	for(int i=1;i<=N;i++)
		for(int j=1;j<=N;j++)
			dist[i][j]=2e12;
	for(int i=1;i<=N;i++)
		O.Q[i][i]=1,dist[i][i]=0;
	for(int i=1;i<=M;i++)
		scanf("%d%d%d",&bian[i].a,&bian[i].b,&bian[i].d);
	sort(bian+1,bian+M+1,cmp);
	can.Q[1][1]=1;
	if(bian[1].d!=0)
	{
		puts("Impossible");
		return 0;
	}
	for(int cnt=1;cnt<=M;)
	{
		B.Q[bian[cnt].a][bian[cnt].b]=1;
		for(;cnt<M && bian[cnt].d==bian[cnt+1].d;)
		{
			cnt++;
			B.Q[bian[cnt].a][bian[cnt].b]=1;
		}
		for(int i=cnt;i>=1 && bian[i].d==bian[cnt].d;i--)
		{
			for(int p=1;p<=N;p++)
				for(int q=1;q<=N;q++)
					dist[p][q]=min(dist[p][q],dist[p][bian[i].a]+1+dist[bian[i].b][q]);
		}
		for(int i=1;i<=N;i++)
			if(can.Q[1][i]==1)
				ans=min(dist[i][N]+bian[cnt].d,ans);
		if(cnt!=M)
			can=can*power(B,bian[cnt+1].d-bian[cnt].d);
		if(cnt==M)
			break;
		cnt++;
	}
	if(ans>=2e9)
		puts("Impossible");
	else printf("%d\n",(int)ans);
	return 0;
}
