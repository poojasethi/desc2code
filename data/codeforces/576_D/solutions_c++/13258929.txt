#include<bits/stdc++.h>
using namespace std;
const int maxn=160,maxm=160,inf=0x3f3f3f3f;
struct edge{
    int u,v,d;
}e[maxm];
int n,m;

bool cmp_edge(edge a,edge b){ return a.d<b.d; }
void init(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;++i){
        scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].d);
        --e[i].u,--e[i].v;
    }
    sort(e+1,e+m+1,cmp_edge);
}

struct matrix{
    bool mat[maxn][maxn];
    void clear(){ memset(mat,false,sizeof(mat)); }
    matrix &operator*=(matrix b){
        matrix a=*this; clear();
        for(int i=0;i<n;++i)
            for(int j=0;j<n;++j)if(a.mat[i][j])
                for(int k=0;k<n;++k)
                    mat[i][k]=mat[i][k]|b.mat[j][k];
        return *this;
    }
}I,G,F;
matrix mypow(matrix a,int n){
    matrix res=I;
    for(int i=n;i;i>>=1,a*=a)
        if(i&1) res*=a;
    return res;
}

int dis[maxn][maxn],ans;
void solve(){
    if(e[1].d){ puts("Impossible"); return; }
    memset(dis,63,sizeof(dis)),ans=inf;
    I.clear(),F.clear(),G.clear();
    for(int i=0;i<n;++i)
        I.mat[i][i]=true,F.mat[i][i]=true,dis[i][i]=0;
    for(int i=1,j,u,v,d;i<=m;i=j){
        for(j=i,d=e[i].d;j<=m && e[j].d==d;++j){
            u=e[j].u,v=e[j].v,G.mat[u][v]=true;
            for(int x=0;x<n;++x)if(dis[x][u]<inf)
                for(int y=0;y<n;++y)
                    dis[x][y]=min(dis[x][y],dis[x][u]+1+dis[v][y]);
        }
        for(int x=0;x<n;++x)if(F.mat[0][x])
            ans=min(ans,e[i].d+dis[x][n-1]);
        if(j<=m) F*=mypow(G,e[j].d-e[i].d);
    }
    if(ans!=inf)
        printf("%d\n",ans);
    else puts("Impossible");
}

int main(){
//  freopen("maze.in","r",stdin); freopen("maze.out","w",stdout);
    init();
    solve();
//  fclose(stdin); fclose(stdout);
    return 0;
}
