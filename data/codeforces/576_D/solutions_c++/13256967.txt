#include <algorithm>
#include <iostream>
#include <cstring>
#include <climits>
#include <cstdio>
#include <bitset>
using namespace std;
const int N = 160, INF = INT_MAX / 2;

struct Edge {
	int u, v, d;

	Edge() {}
	Edge(int _u, int _v, int _d) { u = _u, v = _v, d = _d; }

	inline friend bool operator < (const Edge &a, const Edge &b) { return a.d < b.d; }
};

int n, m;
Edge a[N];

void Init() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; ++ i) {
		int u, v, d;
		scanf("%d%d%d", &u, &v, &d);
		a[i] = Edge(u, v, d);
	}
}

struct Matrix {
	int n, m;
	bitset <N> mat[N];

	Matrix() { 
		n = m = 0; 
		for (int i = 1; i < N; ++ i) mat[i].reset();
	}
	Matrix(int r) {
		n = m = r;
		for (int i = 1; i <= r; ++ i)
			mat[i].reset(), mat[i][i] = 1;
	}
};

Matrix reach, trans;
int ans;

Matrix Mul(const Matrix &a, const Matrix &b) {
	Matrix c;
	c.n = a.n, c.m = b.m;
	for (int i = 1; i <= a.n; ++ i)
		for (int j = 1; j <= a.m; ++ j)
			if (a.mat[i][j]) c.mat[i] |= b.mat[j];
	return c;
}

Matrix Power(const Matrix &a, int t) {
	Matrix b(n), c = a;
	for (; t; t >>= 1) {
		if (t & 1) b = Mul(b, c);
		c = Mul(c, c);
	}
	return b;
}

int tms, en[N], to[N], next[N];

inline void Link(int u, int v) { to[++ tms] = v, next[tms] = en[u], en[u] = tms; }

int q[N], dist[N];

inline void Bfs(int st, int cost) {
	for (int i = 1; i <= n; ++ i) dist[i] = INF;
	dist[st] = 0;
	int l = 0, r = 1;
	q[1] = st;
	while (l != r) {
		int u = q[++ l];
		for (int p = en[u]; p; p = next[p]) {
			int v = to[p];
			if (dist[v] == INF) {
				dist[v] = dist[u] + 1;
				q[++ r] = v;
			}
		}
	}
	for (int i = 1; i <= n; ++ i)
		if (dist[i] != INF && reach.mat[1][i]) ans = min(ans, dist[i] + cost);
}

void Solve() {
	sort(a + 1, a + m + 1);
	reach.n = 1, reach.m = n;
	trans.n = trans.m = n;
	reach.mat[1][1] = 1;
	ans = INF;
	for (int i = 1, j, last = 0; i <= m; ++ i) {
		for (j = i; a[j + 1].d == a[i].d && j < m; ++ j);
		reach = Mul(reach, Power(trans, a[j].d - last));
		for (int k = i; k <= j; ++ k) {
			int u = a[k].u, v = a[k].v;
			trans.mat[u][v] = 1;
			Link(v, u);
		}
		i = j, last = a[i].d;
		Bfs(n, last);
	}
	Bfs(n, a[m].d);
	if (ans == INF) puts("Impossible"); else printf("%d\n", ans);
}

int main() {

	Init();
	Solve();
		
	return 0;
}
