#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<bitset>
using namespace std;

const int maxn=160;
int n,m;
struct edge{
	int u,v,w;
	bool operator < (const edge &e) const {return w<e.w;}
	edge() {}
	edge(int u,int v,int w):u(u),v(v),w(w) {}
}e[maxn];
struct MAT{
	bitset <maxn> num[maxn];
	MAT operator * (const MAT &m) const
	{
		MAT ret;
		for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			if (num[i][j]) ret.num[i]|=m.num[j];
		return ret;
	}
}map,one;

MAT power(MAT a,int k)
{
	MAT ret;
	for (int i=1;i<=n;i++) ret.num[i][i]=1;
	while (k)
	{
		if (k&1) ret=ret*a;
		a=a*a; k>>=1;
	}
	return ret;
}

int erfen(int R)
{
	int L=1;
	MAT tmp=one*power(map,R);
	if (!tmp.num[1][n]) {one=tmp; return 0;}
	while (L<=R)
	{
		int mid=(L+R)/2;
		tmp=one*power(map,mid);
		if (tmp.num[1][n]) R=mid-1;
		else L=mid+1;
	}
	return L;
}

int main()
{
	int i,j;
	scanf("%d%d",&n,&m);
	for (i=1;i<=m;i++)
		scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].w);
	e[++m]=edge(0,0,1e9+1e7);
	sort(e+1,e+1+m);
	if (e[1].w)
	{
		printf("Impossible\n");
		return 0;
	}

	for (i=1;i<=n;i++) one.num[i][i]=1;
	map.num[n][n]=1;
	map.num[e[1].u][e[1].v]=1;
	for (i=2;i<=m;i++)
	{
		if (e[i].w-e[i-1].w)
		{
			int d=erfen(e[i].w-e[i-1].w);
			if (d) {printf("%d\n",e[i-1].w+d); return 0;}
		}
		map.num[e[i].u][e[i].v]=1;
	}
	printf("Impossible\n");
}

              