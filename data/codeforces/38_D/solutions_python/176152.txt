class Vec:
    def __init__( self, x, y ):
        self.x = x
        self.y = y
    def __add__( self, v ):
        return Vec( self.x + v.x, self.y + v.y )
    def __sub__( self, v ):
        return Vec( self.x - v.x, self.y - v.y )
    def __rmul__( self, k ):
        return Vec( self.x * k, self.y * k )
    def __repr__( self ):
        return "Vec< %s, %s >" % ( self.x, self.y )

class Fig:
    def __init__( self, pos, s, r, m ):
        self.pos = pos
        self.s = s
        self.r = r
        self.m = m

    def __add__( self, f ):
        m1, m2 = self.m, f.m
        rc = (1.0/( m1 + m2 )) * ( m1 * self.r + m2 * f.r )
        return Fig( f.pos, f.s, rc, m1 + m2 )


    def stay_on( self, f ):
        v = self.r - f.pos
        return ( v.x > -0.000001 ) and ( v.x < f.s + 0.000001 ) and\
               ( v.y > -0.000001 ) and ( v.y < f.s + 0.000001 )


    def __repr__( self ):
        return "Fig< %s, %s, %s, %s >" % ( self.pos, self.s, self.r, self.m )

def norm( x1, y1, x2, y2 ):
    return ( min( x1, x2 ), min( y1, y2 ), max( x1, x2 ), max( y1, y2 ) )

N = int( raw_input() )
fs = []
for i in xrange( N ):
    x1, y1, x2, y2 = map( int, raw_input().split() )
    x1, y1, x2, y2 = norm( x1, y1, x2, y2 )
    v1, v2, s = Vec( x1, y1 ), Vec( x2, y2 ), x2 - x1
    fs.append( Fig( v1, s, 0.5 * ( v1 + v2 ), s ** 3 ) )


#print fs
for i in xrange( 1, len( fs ) + 1 ):
    l = fs[ :i ]
    #print '--------------'
    #print l
    res = True
    ft = l.pop()
    while l and res:
        #print 'ft      =', ft
        #print 'l[ -1 ] =', l[ -1 ]
        #print 'ft on self', ft.stay_on( ft )
        #print 'ft on l[ -1 ]', ft.stay_on( l[ -1 ] )
        res &= ft.stay_on( ft ) and ft.stay_on( l[ -1 ] )
        ft += l.pop()
    res &= ft.stay_on( ft )
    #print 'last step ft -->', ft
    #print 'last step ft.stay_on( ft ) -->', ft.stay_on( ft )
    if not res:
        print i - 1
        exit()

print i

