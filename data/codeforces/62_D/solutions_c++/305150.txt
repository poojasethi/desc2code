#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <set>

#define REP(AA,BB) for(int AA=0; AA<(BB); ++AA)
#define FOR(AA,BB,CC) for(int AA=(BB); AA<(CC); ++AA)
#define FC(AA,BB) for(__typeof((AA).begin()) BB=(AA).begin(); BB!=(AA).end(); ++BB)
#define SZ(AA) ((int)((AA).size()))
#define ALL(AA) (AA).begin(), (AA).end()
#define PB push_back
#define MP make_pair

using namespace std;

typedef vector<int> VI;
typedef pair<int, int> PII;
typedef long long LL;
typedef long double LD;

multiset<int> ve[110]; 
VI res; int M, ok;
int p[2010];

void euler(int v, int cur) {
	while(!ve[v].empty()) {
		multiset<int>::iterator jt;
		if(cur<=M)
			jt = ve[v].lower_bound(p[cur]);
		else if(cur==M+1)
			jt = ve[v].upper_bound(p[cur]);
		else
			jt = ve[v].begin();
		if(jt == ve[v].end()) {
			ok = 0;
			return;
		}
		int w = *jt;
		multiset<int>::iterator kt = ve[w].find(v);
		ve[v].erase(jt); ve[w].erase(kt);
		euler(w, cur+1);
		if(!ok)
			return;
		res.PB(v);
	}
}

int main(void) {
	int n, m; scanf("%d%d", &n, &m);
	REP(i,m+1)
		scanf("%d", &p[i]);
	int i;
	for(i=m-1; i>=0; --i) {
		ok=1;
		FOR(j,1,n+1)
			ve[j].clear();
		res.clear();
		REP(j,m) {
			ve[p[j]].insert(p[j+1]);
			ve[p[j+1]].insert(p[j]);
		}
		M=i;
		euler(p[0], 1);
		if(ok)
			break;
	}
	if(i==-1) {
		puts("No solution");
		return 0;
	}
	reverse(ALL(res));
	REP(j,SZ(res))
		printf("%d ", res[j]);
	printf("%d\n", p[0]);
	return 0;
}
