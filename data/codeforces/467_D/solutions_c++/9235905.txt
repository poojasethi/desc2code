#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <map>
using namespace std;
typedef long long ll;

const int MAXM = 100100;
int M, N, cnt = 1;
int S[MAXM];
map<string, int> mp; //(string, index)
pair<pair<int, int>, int> A[3*MAXM]; //(# of 'r', len, index)
vector<int> adj[3*MAXM];
bool vis[3*MAXM];
pair<int, int> dp[3*MAXM];

int modify(string s) //returns index of string
{
	for (int i = 0; i < s.size(); i++)
		if ('A' <= s[i] && s[i] <= 'Z') //to lowercase
			s[i] += 'a' - 'A';

	if (mp[s]) //string already modified
		return mp[s];

	for (int i = 0; i < s.size(); i++)
		if (s[i] == 'r')
			A[cnt].first.first++;
	A[cnt].first.second = s.size();
	A[cnt].second = cnt;
	mp[s] = cnt;
	return cnt++;
}

void dfs(int node, int idx) //idx = newly updated node
{
	vis[node] = true;
	dp[node] = min(dp[node], dp[idx]);
	for (int i = 0; i < adj[node].size(); i++)
		if (!vis[adj[node][i]])
			dfs(adj[node][i], idx);
}

int main()
{
	cin >> M;
	for (int i = 0; i < M; i++)
	{
		string s;
		cin >> s;
		S[i] = modify(s);
	}

	cin >> N;
	for (int i = 0; i < N; i++)
	{
		string x, y;
		cin >> x >> y;
		adj[modify(y)].push_back(modify(x)); //go back up
	}

	for (int i = 1; i < cnt; i++)
		dp[i] = A[i].first;

	sort(A + 1, A + cnt);

	for (int i = 1; i < cnt; i++) //go from fewest 'r's to greatest
		if (!vis[A[i].second])
			dfs(A[i].second, A[i].second);

	ll total = 0, len = 0;
	for (int i = 0; i < M; i++)
	{
		total += dp[S[i]].first;
		len += dp[S[i]].second;
	}

	cout << total << " " << len << "\n";

	return 0;
}