import sys
sys.setrecursionlimit(10**6)

global wc
global de
V=0
G=[]
words={}
cost=[]
sentence=[]


def top_sort(G):
    #todo:we can use yield also
    order,stack=[],[]
    seen=set()

    n=len(G)

    for u in range(n):
        
        if u in seen:continue
        stack.append(u)

        while stack:
            u=stack[len(stack)-1]
            if u in seen:
                stack.pop()
                order.append(u)
                continue    
            seen.add(u)#mark as visited

            for v in G[u]:
                if v in seen:continue
                stack.append(v)
            #at this point process u
            
            
    #return vertex sorted in inverse topological way
    return order



def tr(G):
    n=len(G)
    GT=[[] for i in range(n)]

    for v in range(n):
        for u in G[v]:GT[u].append(v)
    return GT

def kosaraju(G,scc,res):

    GT=tr(G)

    order_s=top_sort(GT)
    
    stack=[]
    while order_s:
        node=order_s.pop()      
        stack.append(node)      

        #start
        while stack:
            u=stack.pop()
            if scc[u]!=-1:
                if scc[u]!=node:#update result using another scc                    
                    if res[scc[u]]<res[node]:res[node]=res[scc[u]]
                continue
            
            
            scc[u]=node
            if cost[u]<res[node]:res[node]=cost[u]
            
            for v in G[u]:
                stack.append(v)




        






def main():
    global wc
    global de
    global V

    n=input()
    st=raw_input().strip().split()

    def add_vertex(word):       
        global V
        words[word]=V
        cost.append((word.count('r'),len(word)))
        
        G.append([])
        V+=1
        return V-1

    def add_edge(s1,s2):
        v1,v2=0,0
        
        if s1 not in words:
            v1=add_vertex(s1)
        else:v1=words[s1]
        if s2 not in words:
            v2=add_vertex(s2)
        else:v2=words[s2]       
        G[v1].append(v2)


    for i in range(n):
        word=st[i].lower()
        sentence.append(word)
        add_vertex(word)

    m=input()

    for i in range(m):
        s1,s2=raw_input().strip().split()   
        add_edge(s1.lower(),s2.lower())

    
    V=len(G)
    scc=[-1]*(V+1)
    res=[(10**5+1,0) for i in range(V+1)]

    kosaraju(G,scc,res)


    rcount,l=0,0

    for i in range(n):
        ra,la=res[scc[words[sentence[i]]]]
        rcount+=ra
        l+=la

    print rcount,l
    

main()