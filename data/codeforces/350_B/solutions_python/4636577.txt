from Queue import * # Queue, LifoQueue, PriorityQueue
from bisect import * #bisect, insort
from datetime import * 
from collections import * #deque, Counter,OrderedDict,defaultdict
import calendar
import heapq
import math
import copy
import itertools

n = input()
    
objects = map(int, raw_input().split())
    
path = map(int, raw_input().split())
edge = [ [] for _ in xrange(n)]
edge_return = [ [] for _ in xrange(n)]

def solver():
    for i in range(n):
        to_ = i
        from_ = path[i]-1
        if from_ != -1:
            edge_return[to_].append(from_)
            edge[from_].append(to_)

    res = 0
    max_mountain = 0
    
    for i in range(n):
        if objects[i] == 1:
            now = i
            cnt = 1
            max_m = i
            before = i
            
            while True:
                #print start,edge[start],edge_return[start]
                if len(edge_return[now]) == 0:
                    if now == i:
                        break
                    else:
                        cnt += 1
                        max_m = now
                        break
                elif len(edge[now]) > 1:
                    max_m = before
                    break

                before = now
                now = edge_return[now][0]
                cnt += 1
            #print cnt,max_m
            #print "------"

            if res < cnt:
                max_mountain = max_m
                res = cnt
    now = max_mountain
    ans = []
    #print now
    while True:
        if objects[now] == 1:
            ans.append(now)
            break
        
        else:
            ans.append(now)
            now = edge[now][0]

    print len(ans)
    #print res
    for i in range(len(ans) -1):
        print ans[i]+1,

    print ans[-1]+1
    
            

if __name__ == "__main__":
    solver()
    
