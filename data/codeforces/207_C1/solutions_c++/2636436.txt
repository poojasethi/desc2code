#include <cstdio>
#include <cstring>
#include <algorithm>
#include <map>
#define FOR(i,s,e) for (int i=(s); i<(e); i++)
#define FOE(i,s,e) for (int i=(s); i<=(e); i++)
#define FOD(i,s,e) for (int i=(s)-1; i>=(e); i--)
#define CLR(a,x) memset(a, x, sizeof(a))
#define EXP(i,l) for (int i=(l); i; i=qn[i])
#define LLD long long
#define N 100005
using namespace std;

const LLD MOD = 1000000007;
int n, x, y, h[N], sz[N], p[N];
LLD pow[N], v[2][N], ret;
char s[5];
map<int, int> M[2];
map<int, int>::iterator itr;


int main(){
    scanf("%d", &n);
    
    pow[0] = 1;
    FOR(i,0,n) pow[i+1] = (pow[i] * 26) % MOD;
    
    sz[0] = sz[1] = 1;
    h[1] = -1;
    FOR(i,0,n){
        scanf("%d%d%s", &x, &y, s), x--;
        if (x == 0){
            sz[0]++;
            h[sz[0]] = h[y] + 1;
            v[0][sz[0]] = (v[0][y] + (s[0] - 'a' + 1) * pow[h[sz[0]]]) % MOD;
            
            M[0][v[0][sz[0]]]++;
        }
        if (x == 1){
            sz[1]++;
            v[1][sz[1]] = (v[1][y] * 26 + (s[0] - 'a' + 1)) % MOD;
            p[sz[1]] = y;

            int t = sz[1], off = 0;
            LLD val;
            while (t != 1){
                t = p[t];
                val = v[1][sz[1]] - v[1][t] * pow[++off];
                val = (val % MOD + MOD) % MOD;
                M[1][val]++;
            }
        }

        ret = 0;
        for (itr=M[0].begin(); itr!=M[0].end(); itr++){
            ret += (LLD)(itr->second) * (LLD)M[1][itr->first];
        }

        
        printf("%I64d\n", ret + sz[1]);
    }
    return 0;
}