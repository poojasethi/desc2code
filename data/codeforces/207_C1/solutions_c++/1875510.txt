#include <cstdio>
#include <cstring>
#include <algorithm>
#define FOR(i,s,e) for (int i=(s); i<(e); i++)
#define FOE(i,s,e) for (int i=(s); i<=(e); i++)
#define FOD(i,s,e) for (int i=(s)-1; i>=(e); i--)
#define CLR(a,x) memset(a, x, sizeof(a))
#define EXP(i,l) for (int i=(l); i; i=qn[i])
#define LLD long long
#define N 10005
using namespace std;

const LLD MOD = 1000000007;
const int SIZE = 10000007;
int n, x, y, h[N], sz[N], p[N];
LLD pow[N], v[2][N], ret;
char s[5];

struct HT{
	int a[SIZE], b[SIZE];
	
	int find(int key){
		int idx = key % SIZE;
		while (a[idx] != key && a[idx]){
			idx += 3;
			if (idx >= SIZE) idx -= SIZE;
		}
		return idx;
	}
	
	void insert(int key){
		int idx = find(key);
		a[idx] = key;
		b[idx] ++;
	}
	
	int count(int key){
		return b[find(key)];
	}
};

HT M[2];

int main(){
	scanf("%d", &n);
	
	pow[0] = 1;
	FOR(i,0,n) pow[i+1] = (pow[i] * 26) % MOD;
	
	sz[0] = sz[1] = 1;
	h[1] = -1;
	FOR(i,0,n){
		scanf("%d%d%s", &x, &y, s), x--;
		if (x == 0){
			sz[0]++;
			h[sz[0]] = h[y] + 1;
			v[0][sz[0]] = (v[0][y] + (s[0] - 'a' + 1) * pow[h[sz[0]]]) % MOD;
			
			M[0].insert(v[0][sz[0]]);
			ret += M[1].count(v[0][sz[0]]);
		}
		if (x == 1){
			sz[1]++;
			v[1][sz[1]] = (v[1][y] * 26 + (s[0] - 'a' + 1)) % MOD;
			p[sz[1]] = y;

			int t = sz[1], off = 0;
			LLD val;
			while (t != 1){
				t = p[t];
				val = v[1][sz[1]] - v[1][t] * pow[++off];
				val = val % MOD;
				if (val < 0) val += MOD;
				M[1].insert(val);
				ret += M[0].count(val);
			}
		}
		
		printf("%I64d\n", ret + sz[1]);
	}
	return 0;
}
