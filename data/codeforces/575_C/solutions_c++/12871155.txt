#include <iostream>
#include <sstream>
#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <cctype>
#include <cstring>
#include <string>
#include <vector>
#include <deque>
#include <queue>
#include <stack>
#include <list>
#include <map>
#include <set>
#include <algorithm>

using namespace std;

const int maxn = 22;
const int inf = 2000000000;
int w[maxn][maxn], wa[maxn][maxn], wb[maxn][maxn];
int mw[maxn], smw[maxn];
int slack[maxn], lx[maxn], ly[maxn], link[maxn];
struct Tstack {
    int lx[maxn], ly[maxn], link[maxn], sum;
} sta[maxn], *now;
int visx[maxn], visy[maxn];
int n, sign, ans, sum;

int count_bit(unsigned int n) { 
    n = (n & 0x55555555) + ((n >> 1) & 0x55555555); 
    n = (n & 0x33333333) + ((n >> 2) & 0x33333333); 
    n = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f); 
    n = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff); 
    n = (n & 0x0000ffff) + ((n >> 16) & 0x0000ffff); 
    return n; 
}

bool find(int x) {
    visx[x] = sign;
    for (int i = 1; i <= n; ++i) {
        if (visy[i] == sign) continue;
        int t = lx[x] + ly[i] - w[x][i];
        if (t == 0) {
            visy[i] = sign;
            if (link[i] == -1 || find(link[i])) {
                link[i] = x; return true;
            }
        } else slack[i] = min(slack[i], t);
    }
    return false;
}

int match(int mask) {
    int i, j, d, ans;
    memset(lx, 0, sizeof lx);
    memset(ly, 0, sizeof ly);
    memset(visx, 0, sizeof visx);
    memset(visy, 0, sizeof visy);
    sign = 0;
    for (i = 1; i <= n; ++i)
        for (j = 1; j <= n; ++j)
            if ((mask >> (i - 1)) & 1)
                w[i][j] = wa[i][j];
            else w[i][j] = wb[i][j];
    for (i = 1; i <= n; ++i)
        for (j = 1; j <= n; ++j)
            lx[i] = max(lx[i], w[i][j]);
    memset(link, -1, sizeof link);
    for (j = 1; j <= n; ++j) {
        memset(slack, 127, sizeof slack);
        while (true) {
            ++sign;
            if (find(j)) break;
            d = inf;
            for (i = 1; i <= n; ++i)
                if (visy[i] != sign && d > slack[i])
                    d = slack[i];
            for (i = 1; i <= n; ++i)
                if (visx[i] == sign) lx[i] -= d;
            for (i = 1; i <= n; ++i)
                if (visy[i] == sign)
                    ly[i] += d;
                else slack[i] -= d;
        }
    }
    ans = 0;
    //printf("%x\n", mask);
    for (i = 1; i <= n; ++i) {
        //printf("%d %d %d\n", link[i], i, w[link[i]][i]);
        ans += w[link[i]][i];
    }
    return ans;
}

bool find_add(int x) {
    visx[x] = sign;
    for (int i = 1; i <= n; ++i) {
        if (visy[i] == sign) continue;
        int t = now->lx[x] + now->ly[i] - w[x][i];
        if (t == 0) {
            visy[i] = sign;
            if (!now->link[i] || find_add(now->link[i])) {
                now->sum -= w[now->link[i]][i];
                now->sum += w[x][i];
                now->link[i] = x;
                return true;
            }
        } else slack[i] = min(slack[i], t);
    }
    return false;
}

void add_match(int u) {
    int i, d;
    now = sta + u;
    *now = sta[u - 1]; now->lx[u] = 0;
    for (i = 1; i <= n; ++i)
        now->lx[u] = max(now->lx[u], w[u][i]);
    memset(slack, 127, sizeof slack);
    while (true) {
        ++sign;
        if (find_add(u)) break;
        d = inf;
        for (i = 1; i <= n; ++i)
            if (visy[i] != sign && d > slack[i])
                d = slack[i];
        for (i = 1; i <= n; ++i)
            if (visx[i] == sign) now->lx[i] -= d;
        for (i = 1; i <= n; ++i)
            if (visy[i] == sign)
                now->ly[i] += d;
            else slack[i] -= d;
    }
}

void dfs(int u, int a, int b) {
    if (clock() >= 1.9 * CLOCKS_PER_SEC) return;
    int i, j;
    if (sta[u - 1].sum + smw[u] <= ans) return ;
    if (u > n) {
        //int sum = 0;
        //for (i = 1; i <= n; ++i)
        //    sum += w[sta[n].link[i]][i];
        ans = max(ans, sta[n].sum);
        //printf("%d\n", ans);
        return ;
    }
    if (a != 0) {
        for (j = 1; j <= n; ++j)
            w[u][j] = wa[u][j];
        add_match(u);
        dfs(u + 1, a - 1, b);
    }
    if (b != 0) {
        for (j = 1; j <= n; ++j)
            w[u][j] = wb[u][j];
        add_match(u);
        dfs(u + 1, a, b - 1);
    }
    //memset(w[u], 0, sizeof w[u]);
}

int main() {
    //freopen("C.in", "r", stdin);
    int i, j;
    scanf("%d", &n);
    for (i = 1; i <= n; ++i)
        for (j = 1; j <= n; ++j)
            scanf("%d", wa[i] + j);
    for (i = 1; i <= n; ++i)
        for (j = 1; j <= n; ++j)
            scanf("%d", wb[i] + j);
/*
    ans = 0;
    for (i = 0; i < (1 << n); ++i)
        if (count_bit(i) == (n >> 1)) {
            ans = max(ans, match(i));
        }
*/
    memset(mw, 0, sizeof mw);
    memset(smw, 0, sizeof smw);
    for (i = 1; i <= n; ++i) {
        for (j = 1; j <= n; ++j)
            mw[i] = max(mw[i], max(wa[i][j], wb[i][j]));
    }
    for (i = n; i >= 1; --i)
        smw[i] = smw[i + 1] + mw[i];
    memset(sta[0].link, 0, sizeof sta[0].link);
    memset(visx, 0, sizeof visx);
    memset(visy, 0, sizeof visy);
    sign = 0; ans = 0; sta[0].sum = 0;
    dfs(1, n / 2, n / 2);
    printf("%d\n", ans);
    return 0;
}
