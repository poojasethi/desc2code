#include <bits/stdc++.h>

using namespace std;

#define fillchar(a, s) memset((a), (s), sizeof(a))
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define all(v) (v).begin(), (v).end()
#define rep(it, v) for (auto it = (v).begin(); it != (v).end(); it++)

typedef long long ll;
typedef pair<int, int> pii;
const int MAXN = 22, INF = 1e9;

int N, L[2][MAXN][MAXN];
int ans;
int A[MAXN][MAXN];
int U[MAXN], V[MAXN], P[MAXN], way[MAXN];
int minv[MAXN];
bool used[MAXN];

void dfs (int i, int fri, int sat) {
    //FAAAACK
    if (i == N + 1) {
        //do something...
        int res=0;
        for(int i=1;i<=N;i++)res+=A[P[i]][i];
        ans = max(ans, res);
        return;
    }
    int oldu[MAXN], oldv[MAXN], oldp[MAXN], oldway[MAXN];
    //k choose this nc for smth
    for (int tu = 0; tu < 2; tu++) {
        //tu = turn
        if (fri == N / 2 && tu == 0) {
            continue;
        }
        if (sat == N / 2 && tu == 1) {
            continue;
        }
        for (int j = 0; j < N; j++) {
            A[i][j + 1] = L[tu][i - 1][j];
            U[i]=max(U[i],A[i][j+1]);
        }
        //copy once
        //hmm apparently copy
        for (int j = 0; j <= N; j++) {
            oldu[j] = U[j];
            oldv[j] = V[j];
            oldp[j] = P[j];
            oldway[j] = way[j];
        }
        //do the stuff
        P[0] = i;
        int j0 = 0;
        fill_n(minv, N + 1, INF);
        fill_n(used, N + 1, false);
        do {
            used[j0] = true;
            int i0 = P[j0], delta = INF, j1;
            for (int j = 1; j <= N; j++) {
                if (!used[j]) {
                    int cur =  U[i0] + V[j]-A[i0][j];
                    if (cur < minv[j]) {
                        minv[j] = cur;
                        way[j] = j0;
                    }
                    if (minv[j] < delta) {
                        delta = minv[j];
                        j1 = j;
                        // printf("j1 = %d from delta %d\n", j1, delta);
                    }
                }
            }
            for (int j = 0; j <= N; j++) {
                if (used[j]) {
                    U[P[j]] -= delta;
                    V[j] += delta;
                } else {
                    minv[j] -= delta;
                }
            }
            // printf("j0 = %d, j1 = %d\n", j0, j1);
            j0 = j1;
        } while (P[j0]);
        do {
            int j1 = way[j0];
            P[j0] = P[j1];
            j0 = j1;
        } while (j0);
        //RECURSE
        dfs(i + 1, fri + (tu == 0), sat + (tu == 1));
        //copy back
        //apparently the copy_n function is dangerous
        for (int j = 0; j <= N; j++) {
            U[j] = oldu[j];
            V[j] = oldv[j];
            P[j] = oldp[j];
            way[j] = oldway[j];
        }   
    }
}

int main() {

    scanf("%d", &N);
    for (int i = 0; i < 2; i++) {
        for (int j = 0; j < N; j++) {
            for (int k = 0; k < N; k++) {
                scanf("%d", &L[i][j][k]);
            }
        }
    }
    dfs(1, 0, 0);
    printf("%d\n", ans);
}