#include <iostream>
#include <sstream>
#include <algorithm>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <vector>

const int N = 25;
const int INF = 1e8;

int n;
int profit[2][N][N];
int answer = -INF;

struct KM_State {
    int lx[N], ly[N];
    int match[N], way[N];
    
    KM_State() {
        for (int i = 1; i <= n; i ++) {
            match[i] = 0;
            lx[i] = 0;
            ly[i] = 0;
            way[i] = 0;
        }
    }
};

struct KM_Solver {
    int w[N][N];
    KM_State state;
    int slack[N];
    bool used[N];
    
    KM_Solver() {
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= n; j ++) {
                w[i][j] = 0;
            }
        }
    }
    
    void hungary(int x) {
        state.match[0] = x;
        int j0 = 0;
        for (int j = 0; j <= n; j ++) {
            slack[j] = INF;
            used[j] = false;
        }
        do {
            used[j0] = true;
            int i0 = state.match[j0], delta = INF, j1;
            for (int j = 1; j <= n; j ++) {
                if (used[j] == false) {
                    int cur = w[i0][j] - state.lx[i0] - state.ly[j];
                    if (cur < slack[j]) {
                        slack[j] = cur;
                        state.way[j] = j0;
                    }
                    if (slack[j] < delta) {
                        delta = slack[j];
                        j1 = j;
                    }
                }
            }
            for (int j = 0; j <= n; j ++) {
                if (used[j]) {
                    state.lx[state.match[j]] += delta;
                    state.ly[j] -= delta;
                } else {
                    slack[j] -= delta;
                }
            }
            j0 = j1;
        } while (state.match[j0] != 0);
        
        do {
            int j1 = state.way[j0];
            state.match[j0] = state.match[j1];
            j0 = j1;
        } while (j0);
    }
    
    int get_ans() {
        int ret = 0;
        for (int i = 1; i <= n; i ++) {
            if (state.match[i] > 0) {
                ret += w[state.match[i]][i];
            }
        }
        return state.ly[0];
    }
};

void init() {
    std::cin >> n;
    for (int t = 0; t <= 1; t ++) {
        for (int i = 1; i <= n; i ++) {
            for (int j = 1; j <= n; j ++) {
                scanf("%d", &profit[t][i][j]);
            }
        }
    }
}

void dfs(int x, int y, KM_Solver &solver) {
    if (x + y == n) {
        answer = std::max(answer, solver.get_ans());
        return ;
    }
    if (2 * x + 2 <= n) {
        KM_State tmp = solver.state;
        for (int i = 1; i <= n; i ++) {
            solver.w[x + y + 1][i] = -profit[0][x + y + 1][i];
        }
        solver.hungary(x + y + 1);
        dfs(x + 1, y, solver);
        solver.state = tmp;
    }
    if (2 * y + 2 <= n) {
        KM_State tmp = solver.state;
        for (int i = 1; i <= n; i ++) {
            solver.w[x + y + 1][i] = -profit[1][x + y + 1][i];
        }
        solver.hungary(x + y + 1);
        dfs(x, y + 1, solver);
        solver.state = tmp;
    }
}

void work() {
    static KM_Solver solver;
    dfs(0, 0, solver);
    std::cout << answer << std::endl;
}

int main() {
    //freopen("C.in", "r", stdin);
    
    init();
    work();
    
    return 0;
}