import sys

sys.setrecursionlimit(10 ** 6)

def pyes_no(condition) :
  if condition :
    print ("YES")
  else :
    print ("NO")

def plist(a, s = ' ') :
  print (s.join(map(str, a)))

def rint() :
  return int(sys.stdin.readline())

def rints() :
  return map(int, sys.stdin.readline().split())

def rfield(n, m = None) :
  if m == None :
    m = n
  
  field = []
  for i in xrange(n) :
    chars = sys.stdin.readline().strip()
    assert(len(chars) == m)
    field.append(chars)
  return field

def pfield(field, separator = '') :
  print ('\n'.join(map(lambda x: separator.join(x), field)))

def check_field_equal(field, i, j, value) :
  if i >= 0 and i < len(field) and j >= 0 and j < len(field[i]) :
    return value == field[i][j]
  return None 

def digits(x, p) :
  digits = []
  while x > 0 :
    digits.append(x % p)
    x //= p
  return digits

def modpower(a, n, mod) :
  r = a ** (n % 2)
  if n > 1 :
    r *= modpower(a, n // 2, mod) ** 2
  return r % mod

def gcd(a, b) :
  if a > b :
    a, b = b, a
  
  while a > 0 :
    a, b = b % a, a

  return b

def vector_distance(a, b) :
  diff = vector_diff(a, b)
  
  return scalar_product(diff, diff) ** 0.5

def vector_inverse(v) :
  r = [-x for x in v]

  return tuple(r)

def vector_diff(a, b) :
  return vector_sum(a, vector_inverse(b))

def vector_sum(a, b) :
  r = [c1 + c2 for c1, c2 in zip(a, b)]
    
  return tuple(r)

def scalar_product(a, b) :
  r = 0
  for c1, c2 in zip(a, b) :
    r += c1 * c2

  return r

def check_rectangle(points) :
  assert(len(points) == 4)

  A, B, C, D = points

  for A1, A2, A3, A4 in [
    (A, B, C, D),
    (A, C, B, D),
    (A, B, D, C),
    (A, C, D, B),
    (A, D, B, C),
    (A, D, C, B),
  ] :
    sides = (
      vector_diff(A1, A2),
      vector_diff(A2, A3),
      vector_diff(A3, A4),
      vector_diff(A4, A1),
    )
    if all(scalar_product(s1, s2) == 0 for s1, s2 in zip(sides, sides[1:])) :
       return True
  return False

def check_square(points) :
  if not check_rectangle(points) :
    return False
  A, B, C, D = points

  for A1, A2, A3, A4 in [
    (A, B, C, D),
    (A, C, B, D),
    (A, B, D, C),
    (A, C, D, B),
    (A, D, B, C),
    (A, D, C, B),
  ] :
    side_lengths = [
      (first[0] - next[0]) ** 2 + (first[1] - next[1]) ** 2 for first, next in zip([A1, A2, A3, A4], [A2, A3, A4, A1])
    ]
    if len(set(side_lengths)) == 1 :
      return True
    
  return False

def check_right(p) :
  # Check if there are same points
  for a, b in [
    (p[0], p[1]),
    (p[0], p[2]),
    (p[1], p[2]),
  ] :
    if a[0] == b[0] and a[1] == b[1] :
      return False

  a, b, c = p
  a, b, c = vector_diff(a, b), vector_diff(b, c), vector_diff(c, a)   

  return scalar_product(a, b) * scalar_product(a, c) * scalar_product(b, c) == 0

n, m = rints()
field = rfield(n, m)

points = []
for i in range(n) :
  for j in range(m) : 
    if field[i][j] == '*' :
      points.append((i, j))

from collections import defaultdict

x = defaultdict(int)
y = defaultdict(int)

for i, j in points :
  x[i] += 1
  y[j] += 1

x = [c for c, v in x.items() if v == 1][0]
y = [c for c, v in y.items() if v == 1][0]

print x + 1, y + 1

