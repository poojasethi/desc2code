import itertools

adjacent_to = lambda p: lambda q: q != p and (q[0] == p[0] or q[1] == p[1])
neighbours_count = lambda p,pts: len(filter(adjacent_to(p), pts))

n,m = map(int, raw_input().split())
indexed_chars = itertools.chain(*[ [ (i+1,j+1,c) for j, c in enumerate(raw_input()) ] for i in xrange(n) ])
pts = filter(lambda t: t[2] == '*', indexed_chars) 
pts = map(lambda t: (t[0],t[1]), pts)

pts_without_neighbours = filter(lambda p: neighbours_count(p,pts) == 1, pts)
digits = itertools.chain(*pts_without_neighbours)
for candidate in itertools.product(digits,repeat=2):
    if candidate in pts:
        continue
    rect = pts[:] + [candidate]
    if all([ neighbours_count(p,rect) == 2 for p in rect ]):
        print '%d %d' % candidate
        break
