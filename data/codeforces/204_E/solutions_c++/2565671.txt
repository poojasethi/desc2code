#include<stdio.h>
#include<string.h>
#include<queue>
#include<tr1/unordered_set>
using namespace std;
using namespace tr1;
const int maxn=100010;
int n,K;
typedef unordered_set<int> set;
typedef set::iterator iter;
typedef long long ll;
namespace trie
{
	int trans[maxn][26],fa[maxn],ch[maxn];
	int N=1;
	set belong[maxn];
	void insert(char *S,int l,int id)
	{
		int p=1;
		belong[1].insert(id);
		for(int i=1;i<=l;i++)
		{
			int c=S[i];
			if(trans[p][c])p=trans[p][c];
			else trans[p][c]=++N,fa[N]=p,ch[N]=c,p=N;
			belong[p].insert(id);
		}
	}
};
namespace SAM
{
	int trans[2*maxn][26];
	int val[2*maxn];
	int fail[2*maxn];
	int N=1;
	int add(int ch,int p)
	{
		int np=++N;
		val[np]=val[p]+1;
		while(p&&!trans[p][ch])trans[p][ch]=np,p=fail[p];
		if(!p)fail[np]=1;
		else
		{
			int q=trans[p][ch];
			if(val[q]==val[p]+1)fail[np]=q;
			else
			{
				int nq=++N;
				val[nq]=val[p]+1;
				fail[nq]=fail[q];
				fail[q]=fail[np]=nq;
				memcpy(trans[nq],trans[q],26*sizeof(int));
				while(p&&trans[p][ch]==q)trans[p][ch]=nq,p=fail[p];
			}
		}
		return np;
	}
};
char S[maxn];
int t2a[maxn],a2t[2*maxn];
queue<int> Q;
struct edge
{
	int v;
	edge *n;
};
edge EPool[maxn*2],*g[maxn*2],*ep=EPool;
inline void addedge(int u,int v)
{
	ep->v=v,ep->n=g[u],g[u]=ep++;
}
set *abelong[maxn*2];
ll aans[maxn*2];
ll ans[maxn];
void dfs(int u,int fa)
{
	set *ret=0;
	for(edge *i=g[u];i;i=i->n)dfs(i->v,u);
	int _u=a2t[u];
	if(!g[u])
	{
		ret=new set;
		*ret=trie::belong[_u];
	}
	else
	{
		ret=abelong[g[u]->v];
		for(edge *i=g[u];i;i=i->n)if(abelong[i->v]->size()>ret->size())ret=abelong[i->v];
		for(edge *i=g[u];i;i=i->n)if(abelong[i->v]!=ret)
		{
			set *t=abelong[i->v];
			for(iter i=t->begin();i!=t->end();i++)ret->insert(*i);
		}
		if(_u)
		{
			set &t=trie::belong[_u];
			for(iter i=t.begin();i!=t.end();i++)ret->insert(*i);
		}
	}
	abelong[u]=ret;
	if(ret->size()>=K)aans[u]=SAM::val[u]-SAM::val[fa];
}
void dfs2(int u,int fa)
{
	aans[u]+=aans[fa];
	int _u=a2t[u];
	if(_u)
	{
		set &t=trie::belong[_u];
		for(iter i=t.begin();i!=t.end();i++)ans[*i]+=aans[u];
	}
	for(edge *i=g[u];i;i=i->n)dfs2(i->v,u);
}
int main()
{
	scanf("%d%d",&n,&K);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",S+1);
		int l=strlen(S+1);
		for(int i=1;i<=l;i++)S[i]-='a';
		trie::insert(S,l,i);
	}
	t2a[1]=1;
	Q.push(1);
	while(!Q.empty())
	{
		int u=Q.front();Q.pop();
		if(u!=1)t2a[u]=SAM::add(trie::ch[u],t2a[trie::fa[u]]),a2t[t2a[u]]=u;
		for(int i=0;i<26;i++)if(trie::trans[u][i])Q.push(trie::trans[u][i]);
	}
	for(int i=1;i<=SAM::N;i++)addedge(SAM::fail[i],i);
	dfs(1,0);
	dfs2(1,0);
	for(int i=1;i<n;i++)printf("%I64d ",ans[i]);printf("%I64d\n",ans[n]);
	return 0;
}
