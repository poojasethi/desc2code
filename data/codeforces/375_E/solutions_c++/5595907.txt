#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<vector>
#define N 502
#define INF (1 << 14)
using namespace std;
typedef long long LL;
int a,b,c,d,e,f,g,h,i,j,k;
vector<int> tree[N];
int father[N];
int siz[N];
LL D[N][N];
short F[N][N][N];
LL K;
short cost[N];
int G[N],H[N];
int best[N][N];
int Limit;

void Floyd()
{
    for(k = 1; k <= a; k ++)
        for(i = 1; i <= a; i ++)
            for(j = 1; j <= a; j ++)
                D[i][j] = min(D[i][j], D[i][k] + D[k][j]);
}
void soso(int x)
{
    int ii,jj,kk;
    int u;
    for(ii = 0; ii < tree[x].size(); ii ++)
    {
        jj = tree[x][ii];
        if(jj == father[x]) continue;
        father[jj] = x;
        soso(jj);
    }
    for(u = 1; u <= a; u ++)
    if(D[u][x] <= K)
    {
        siz[x] = 1;
        memset(G, 1, sizeof(G));
        G[1] = cost[u];
        for(ii = 0; ii < tree[x].size(); ii ++)
        {
            jj = tree[x][ii];
            if(jj == father[x]) continue;
            int cc,dd;
            memset(H, 1, sizeof(H));
            for(cc = 1; cc <= min(siz[x] + 1, Limit + 2); cc ++)
                for(dd = 1; dd <= min(siz[jj] + 1, Limit + 2); dd ++)
                if(cc + dd <= Limit + 5)
                {
                    H[cc + dd] = min(H[cc + dd], best[jj][dd] + G[cc]); 
                    if(D[u][jj] <= K) H[cc + dd - 1] = min(H[cc + dd - 1], F[jj][dd][u] + G[cc] - cost[u]);
                }
            memcpy(G, H, sizeof(G));
            siz[x] += siz[jj];
        }
        for(ii = 1; ii <= siz[x] + 1; ii ++)
        {
            F[x][ii][u] = (short) min((int)G[ii], INF);
            best[x][ii] = min(best[x][ii], (int)F[x][ii][u]);
        }
    }
}

int main()
{
    cin >> a >> K;
    for(i = 1; i <= a; i ++)
    {
        cin >> cost[i];
        Limit += cost[i];
        cost[i] ^= 1;
    }
    memset(D, 3, sizeof(D));
    for(i = 1; i <= a; i ++) D[i][i] = 0;
    for(i = 1; i < a; i ++)
    {
        cin >> c >> d >> e;
        D[c][d] = D[d][c] = e;
        tree[c].push_back(d);
        tree[d].push_back(c);
    }
    Floyd();
    for(i = 0; i <= a; i ++)
        for(j = 0; j <= a; j ++)
        {
            best[i][j] = INF;
            for(k = 0; k <= a; k ++)
                F[i][j][k] = INF;
        }
    soso(1);
    if(best[1][Limit] <= a) cout << best[1][Limit] << endl;
    else cout << "-1" << endl;
    return 0;
}