//Yaroslav and Divisors
#include<cstdio>
#include<iostream>
#include<algorithm>
#define db(x) cout<<#x<<"="<<(x)<<endl
#define rep(i,l,r) for(int i=l;i<=r;i++)
#define tr(p) for(edge*lk=p;lk;lk=lk->next)
#define push(p,x) p=new edge(x,p)
#define su lk->d
using namespace std;
typedef long long LL;
const int MXN=200002;
struct edge{
	int d,id;edge*next;
	edge(int d,edge*n):d(d),next(n){}
}*e[MXN],*q[MXN];

int N,Q;
int a[MXN],p[MXN];

LL ans[MXN];

#define lb(x) ((x)&(-x))
namespace Tarray{
	LL c[MXN];
	void met(){rep(i,1,N)c[i]=0;}
	void ins(int x,int v){for(;x<=N;x+=lb(x)) c[x]+=v;}
	LL   sum(int x){LL s=0;for(;x>0;x-=lb(x)) s+=c[x];return s;}
}

void work(){
	scanf("%d%d",&N,&Q);
	rep(i,1,N)scanf("%d",a+i),p[a[i]]=i;
	rep(i,1,N)
	for(int j=i;j<=N;j+=i)
	if (p[i]>p[j]) push(e[p[i]],p[j]); else push(e[p[j]],p[i]);
	
	int x,y;
	rep(i,1,Q) scanf("%d%d",&x,&y),push(q[y],x),q[y]->id=i;
	
	Tarray::met();
	rep(i,1,N){
		tr(e[i]) Tarray::ins(su,1);
		tr(q[i]) ans[lk->id]=Tarray::sum(i)-Tarray::sum(su-1);
	}
	rep(i,1,Q) printf("%I64d\n",ans[i]);
}
int main(){
	work();
	return 0;
}
