#include<cstdio>
#include<map>
#define mid (l+r)/2
#define lt (s<<1)
#define rt (s<<1|1)
#define oo 1000000000
#define Mn 200050
using namespace std;
map <int,int> mp;
int fc[Mn*4],xc[Mn*4],mc[Mn*4],cgm[Mn*4],xe[Mn*4],me[Mn*4],cgx[Mn*4];
int a[Mn],b[Mn],c[Mn],lg[Mn],f[Mn];
int bm[22][Mn],bx[22][Mn];
int A,kk,n,k,ans,ansl,ansr,d,i,j;
bool cmpd(const int &x,const int &y)
{return (b[x]<b[y]) || (b[x]==b[y] && x<y);}
int rmqmin(int l,int r)
{int k=lg[r-l+1]; return min(bm[k][l],bm[k][r-(1<<k)+1]);}
int rmqmax(int l,int r)
{int k=lg[r-l+1]; return max(bx[k][l],bx[k][r-(1<<k)+1]);}
void updata(int s)
{
	mc[s]=min(mc[lt],mc[rt]);
	fc[s]=min(fc[lt],fc[rt]);
	xc[s]=min(xc[lt],xc[rt]);
}
void domin(int s,int up,int x)
{
	cgm[s]=1; me[s]=up;
	mc[s]=x-up;
	fc[s]=xc[s]-up;
}
void domax(int s,int up,int x)
{
	cgx[s]=1; xe[s]=up;
	xc[s]=x+up;
	fc[s]=mc[s]+up;
}
void push(int s,int l,int r)
{
	if (cgm[s])
		domin(lt,me[s],l),domin(rt,me[s],mid+1);
	if (cgx[s])
		domax(lt,xe[s],l),domax(rt,xe[s],mid+1);
	cgm[s]=cgx[s]=0;
}
void changemin(int s,int l,int r,int ls,int rs,int up)
{
	if (l>rs || r<ls || ls>rs) return;
	if (ls<=l && r<=rs)
		return (void)(domin(s,up,l));
	push(s,l,r);
	changemin(lt,l,mid,ls,rs,up);
	changemin(rt,mid+1,r,ls,rs,up);
	updata(s);
}
void changemax(int s,int l,int r,int ls,int rs,int up)
{
	if (l>rs || r<ls || ls>rs) return;
	if (ls<=l && r<=rs)
		return (void)(domax(s,up,l));
	push(s,l,r);
	changemax(lt,l,mid,ls,rs,up);
	changemax(rt,mid+1,r,ls,rs,up);
	updata(s);
}
void find(int s,int l,int r)
{
	if (l==r) return(void)(kk=l);
	push(s,l,r);
	if (fc[lt]<=A) find(lt,l,mid);
	else find(rt,mid+1,r);
	updata(s);
}
void ask(int s,int l,int r,int ls,int rs)
{
	if (l>rs || r<ls || ls>rs) return;
	if (ls<=l && r<=rs)
		{
			if (fc[s]<=A && kk==oo)
				find(s,l,r);
			return;
		} push(s,l,r);
	ask(lt,l,mid,ls,rs);
	ask(rt,mid+1,r,ls,rs);
	updata(s);
}
void solve(int l,int r)
{
	int i,ls,rs,md;
	if (l==r) return;
	if (!d)
		{
			if ((r-l+1>ans) || (r-l+1==ans && l<ansl))
				ans=r-l+1,ansl=l,ansr=r;
			return;
		}
	mp.clear();
	f[l]=l; mp[c[l]]=l;
	for(i=l+1;i<=r;i++)
		f[i]=max(f[i-1],mp[c[i]]+1),mp[c[i]]=i;
	for(i=l;i<=r;i++)
		{
			ls=f[i]; rs=i;
			while (ls<rs)
				{
					md=(ls+rs)/2;
					if (rmqmin(md,i-1)>c[i])
						rs=md;else ls=md+1;
				}
			changemin(1,1,n,ls,i,c[i]);
			ls=f[i]; rs=i;
			while (ls<rs)
				{
					md=(ls+rs)/2;
					if (rmqmax(md,i-1)<c[i])
						rs=md;else ls=md+1;
				}
			changemax(1,1,n,ls,i,c[i]);
			kk=oo; A=k+i;
			ask(1,1,n,f[i],i);
			if (i-kk+1>ans || (i-kk+1==ans && kk<ansl))
				ans=i-kk+1,ansl=kk,ansr=i;
		}
}
void build(int s,int l,int r)
{
	if (l==r)
		return (void)(mc[s]=xc[s]=fc[s]=l);
	build(lt,l,mid); build(rt,mid+1,r);
	updata(s);
}
int main()
{
	scanf("%d %d %d",&n,&k,&d);
	for(i=1;i<=n;i++)
		{
			scanf("%d",&a[i]);
			if (!d) b[i]=a[i],c[i]=0;
			else b[i]=(a[i]%d+d)%d,c[i]=(a[i]-b[i])/d;
		}
	build(1,1,n);
	for(i=1;i<=n;i++)
		bm[0][i]=c[i],bx[0][i]=c[i];
	for(i=1;i<=20;i++)
		for(j=1;j<=n;j++)
			if (j+(1<<i)-1<=n)
			{
				bm[i][j]=min(bm[i-1][j],bm[i-1][j+(1<<i-1)]);
				bx[i][j]=max(bx[i-1][j],bx[i-1][j+(1<<i-1)]);
			}
	for(lg[0]=-1,i=1;i<=n;i++)	lg[i]=lg[i/2]+1;
	ans=1; ansl=ansr=1;
	for(i=1;i<=n;i=j)
		{
			for(j=i+1;j<=n;j++)
				if (b[j]!=b[i]) break;
			solve(i,j-1);
		}
	printf("%d %d",ansl,ansr);
	return 0;
}
