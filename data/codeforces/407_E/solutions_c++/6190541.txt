#include<cstdio>
#include<map>
#include<algorithm>
using namespace std;
#define rep(i,n) for (int i=1;i<=n;++i)
typedef long long LL;
const int N=800005,inf=2100000000;
int n,k,d,last,st,ed,ans,a[N],f[N],g[N]; map<int,int> w;
struct Tree{
	#define tree int t,int l,int r
	#define left t*2,l,mid
	#define right t*2+1,mid+1,r
	#define M int mid=l+r>>1
	int ma[N],mi[N],A[N],I[N],tl[N]; unsigned int opt[N];
	void update(int t){
		int L=t<<1,R=L+1;
		ma[t]=min(ma[L],ma[R]);
		mi[t]=min(mi[L],mi[R]);
		opt[t]=min(opt[L],opt[R]);
	}
	void renew(int t,int v,int flag){
		if (flag) ma[t]=A[t]=v;
		else mi[t]=tl[t]-v,I[t]=v;
		opt[t]=ma[t]+mi[t];
	}
	void down(int t){
		if (A[t]) renew(t*2,A[t],1),renew(t*2+1,A[t],1),A[t]=0;
		if (I[t]) renew(t*2,I[t],0),renew(t*2+1,I[t],0),I[t]=0;
	}
	void build(tree){
		opt[t]=ma[t]=inf,tl[t]=l;
		if (l==r) return; M; build(left),build(right);
	}
	void modify(tree,int ll,int rr,int v,int flag){
		if (l==ll && r==rr){renew(t,v,flag); return;} M; down(t);
		if (rr<=mid) modify(left,ll,rr,v,flag);
		else if (ll>mid) modify(right,ll,rr,v,flag);
			else modify(left,ll,mid,v,flag),modify(right,mid+1,rr,v,flag);
		update(t);
	}
	int get(tree,int k){
		if (l==r) return opt[t]<=k?l:inf; M; down(t);
		return opt[t*2]<=k?get(left,k):get(right,k);
	}
}T;
int main()
{
	scanf("%d%d%d",&n,&k,&d);
	rep(i,n) scanf("%d",a+i),a[i]+=1000000000; last=0,T.build(1,1,n);
	if (!d){
		rep(i,n){
			if (i>1 && a[i-1]!=a[i]) last=i-1;
			if (i-last>ans) ans=i-last,st=last+1,ed=i;
		}
	}else rep(i,n){
		last=max(last,w[a[i]]),w[a[i]]=i;
		if (i>1 && a[i-1]%d!=a[i]%d) last=i-1;
		
		while (*f && a[f[*f]]<a[i]) --*f;
		while (*g && a[g[*g]]>a[i]) --*g;
		T.modify(1,1,n,f[*f]+1,i,a[i]/d,1);
		T.modify(1,1,n,g[*g]+1,i,a[i]/d,0);
		f[++*f]=g[++*g]=i;
		if (last) T.modify(1,1,n,1,last,inf,1);
		
		int p=T.get(1,1,n,k+i);
		if (i-p+1>ans) ans=i-p+1,st=p,ed=i;
	}
	printf("%d %d\n",st,ed); return 0;
}

