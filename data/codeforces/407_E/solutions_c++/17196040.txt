#include<bits/stdc++.h>

using namespace std;

#define pii pair<int,int>
#define ll long long
#define N (int)(2e5+10)
#define mod 1000000007
#define mp make_pair
#define pb push_back
#define nd second
#define st first
#define inf mod
#define endl '\n'
#define sag (sol|1)
#define sol (root<<1)
#define ort ((bas+son)>>1)
#define bit(x,y) ((x>>y)&1)
#define int long long

int St[4*N],i,j,k,n,m,x,y,z,L[4*N];
int val[N],a[N],mx,d,s;
pii ans;
stack< pii > stk1,stk2;
map<int,int> H,H1;
vector<int> v[N];

void init(int root,int bas,int son,int i){
	St[root] = 0;
	L[root] = 0;

	if(bas == son)
		return;

	init(sol,bas,ort,i);
	init(sag,ort+1,son,i);
}

void push(int root,int bas,int son){
	if(L[root]){
		L[sol] += L[root];
		L[sag] += L[root];
		St[sol] += L[root];
		St[sag] += L[root];
		L[root] = 0;
	}
}

int que(int root,int bas,int son,int x,int y){
	if(bas > y or son < x)
		return inf;

	if(x <= bas and son <= y){
		if(St[root] > k)
			return inf;
		if(bas == son)
			return bas;
		push(root,bas,son);
		if(St[sol] <= k)
			return que(sol,bas,ort,x,y);
		return que(sag,ort+1,son,x,y);
	}

	push(root,bas,son);

	return min(que(sol,bas,ort,x,y) , que(sag,ort+1,son,x,y));
}

void upd(int root,int bas,int son,int x,int y,int t){

	if(bas > y or son < x)
		return ;

	if(x <= bas and son <= y){
		L[root] += t;
		St[root] += t;
		return;
	}

	push(root,bas,son);

	upd(sol,bas,ort,x,y,t);
	upd(sag,ort+1,son,x,y,t);

	St[root] = min(St[sol],St[sag]);
}

main(){
	scanf("%lld %lld %lld",&n,&k,&d);

	for(i=1 ; i<=n ; i++){
		scanf("%lld",a+i);
		if(!d)
			continue;
		int p = (a[i]%d+d)%d;
		if(H.find(p) == H.end()){
			H[p] = ++s;
		}
		v[H[p]].pb(i);
	}

	if(!d){
		for(i=1 ; i<=n ; ){
			j = i;
			while(i<=n and a[j] == a[i])
				i++;
			if(mx < i-j){
				ans = mp(j,i-1);
				mx = i-j;
			}
		}
		cout << ans.st << ' ' << ans.nd << endl;
		return 0;
	}

	for(i=1 ; i<=s ; i++){
		H1.clear();
		int n = v[i].size(),last=1;
		stack< pii > stk1,stk2;
		init(1,1,n,1);
		for(int j=0 ; j<v[i].size() ; j++){
			int beg = j+1;
			int x = (a[v[i][j]]+inf/d*d*12LL)/d;
			if(j and v[i][j]-1 != v[i][j-1])
				last = beg;
			if(H1.find(x) == H1.end())
				H1[x] = beg;
			else{
				if(H1[x] >= last)
					last = H1[x]+1;
				H1[x] = beg;
			}

			upd(1,1,n,last,beg-1,-1);
			while(stk1.size() and stk1.top().nd < x){
				upd(1,1,n,stk1.top().st,beg-1,x-stk1.top().nd);
				beg = stk1.top().st;
				stk1.pop();
			}
			stk1.push(mp(beg,x));
			beg = j+1;
			while(stk2.size() and stk2.top().nd > x){
				upd(1,1,n,stk2.top().st,beg-1,stk2.top().nd-x);
				beg = stk2.top().st;
				stk2.pop();
			}
			stk2.push(mp(beg,x));

			int p = v[i][que(1,1,n,last,j+1)-1];

			if(v[i][j]-p+1 > mx){
				mx = v[i][j]-p+1;
				ans.st = p;
				ans.nd = v[i][j];
			}
		}
	}


	cout << ans.st << ' ' << ans.nd << endl;
}
