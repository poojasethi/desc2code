#include <bits/stdc++.h>

using namespace std;

#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)

#define type(x) __typeof(x.begin())

#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair < int ,int > pii;

typedef long long ll;

const long long linf = 1e18+5;
const int mod = (int) 1e9 + 7;
const int logN = 18;
const int inf = 1e9;
const int N = 2e5 + 333;

int L[N << 2], mn[N << 2], R[N], a[N];
int n, m, l, r, ans, k, d;
map< int , int > h;

void push(int k){
    mn[sol] += L[k]; mn[sag] += L[k];
    L[sol] += L[k]; L[sag] += L[k];
    L[k] = 0;
}

void update(int k, int bas, int son, int x, int y, int t) {
    if(bas > y || son < x) return ;
    if(x <= bas && son <= y) {
        L[k] += t;
        mn[k] += t;
        return ;
    } push(k);
    update(sol, bas, orta, x, y, t);
    update(sag, orta + 1, son, x, y, t);
    mn[k] = min(mn[sol], mn[sag]);
}

int query(int k, int bas, int son, int x, int y) {
    if(bas > y || son < x || mn[k] > ::k) return -1;
    if(bas == son) return (mn[k] <= ::k) ? bas : -1;
    push(k); int r = query(sag, orta + 1, son, x, y);
    if(r != -1) return r;
    return query(sol, bas, orta, x, y);
}

int main() {

    scanf("%d %d %d", &n, &k, &d);
    FOR(i, 1, n) scanf("%d", &a[i]);

    if(d == 0) {
        int j = 1;
        FOR(i, 1, n) {
            while(j <= n && a[i] == a[j]) j++;
            if(j - i > ans) {
                ans = j - i;
                l = i, r = j - 1;
            }
        }
        return cout << l << ' ' << r << endl, 0;
    }
    else {
        stack< pair< int , pii > > Smax, Smin;
        Smax.push(mp(-inf, mp(n+1, n+1)));
        Smin.push(mp(+inf, mp(n+1, n+1)));
        int j = 1;

        FOR(i, 1, n) {
            while(j <= n && abs(a[i]-a[j]) % d == 0 && !h[a[j]])
                h[a[j++]] = true;
            R[i] = j - 1;
            h[a[i]] = false;
        }

        ROF(i, n, 1) {
            a[i] /= d;
            int fmax = i, fmin = i;
            while(Smax.size() && Smax.top().st <= a[i]) {
                fmax = Smax.top().nd.nd;
                update(1, 1, n, Smax.top().nd.st, Smax.top().nd.nd, -Smax.top().st + a[i]);
                Smax.pop();
            }
            while(Smin.size() && Smin.top().st >= a[i]) {
                fmin = Smin.top().nd.nd;
                update(1, 1, n, Smin.top().nd.st, Smin.top().nd.nd, Smin.top().st - a[i]);
                Smin.pop();
            }
            Smax.push(mp(a[i], mp(i, fmax)));
            Smin.push(mp(a[i], mp(i, fmin)));
            int t = query(1, 1, n, i, R[i]);
            if(t != -1 && t - i + 1 >= ans) {
                ans = t - i + 1;
                l = i, r = t;
            }
            update(1, 1, n, i, n, -1);
        }
        return cout << l << ' ' << r << endl, 0;
    }
    return 0;
}
