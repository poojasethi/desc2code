#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <map>
using namespace std;
const int N=200005;
const int INF=1e9;
struct node
{
	int len,l,r;
	inline node (int _l,int _r) {l=_l; r=_r; len=r-l+1;}
	inline node () {}
};
int n,K,D,a[N],A[N]; node ans;
inline long long getint()
{
    long long x=0; char c=getchar(); bool flag=false;
    while ((c!='-')&&((c<'0')||(c>'9'))) c=getchar();
    if (c=='-') flag=true,c=getchar();
    while ((c>='0')&&(c<='9')) x=x*10+(long long)(c-'0'),c=getchar();
    if (flag) return -x; else return x;
}
void init()
{
	n=getint(); K=getint(); D=getint(); int mint=INF;
	for (int i=1; i<=n; i++) a[i]=getint(),mint=min(mint,a[i]);
	for (int i=1; i<=n; i++) a[i]-=mint;
}
inline void updata(node nowans)
{
	if (nowans.len<ans.len) return;
	if (nowans.len>ans.len) {ans=nowans; return;}
	if (nowans.l<ans.l) ans=nowans;
}
namespace Fuck
{
	void solve()
	{
		for (int i=1,j; i<=n; updata((node){i,j-1}),i=j) for (j=i; (j<=n)&&(a[i]==a[j]); j++);
		printf("%d %d\n",ans.l,ans.r);
	}
}
namespace Segment
{
	const long long INF=1e18;
	struct node {long long mint,lazy;} tree[N*4];
	int nowans;
	void build(int p,int l,int r)
	{
		tree[p].mint=tree[p].lazy=0; if (l==r) return;
		int mid=(l+r)/2; build(p*2,l,mid); build(p*2+1,mid+1,r);
	}
	inline void tag(int p,long long x)
	{
		tree[p].lazy+=x;
		tree[p].mint+=x;
	}
	inline void lazy_tag(int p)
	{
		if (tree[p].lazy==0) return;
		tag(p*2,tree[p].lazy); tag(p*2+1,tree[p].lazy);
		tree[p].lazy=0;
	}
	void modify(int p,int l,int r,int ll,int rr,int x)
	{
		if (l!=r) lazy_tag(p); int mid=(l+r)/2;
		if ((l==ll)&&(r==rr)) {tag(p,x); return;}
		if (rr<=mid) modify(p*2,l,mid,ll,rr,x);
		else if (ll>mid) modify(p*2+1,mid+1,r,ll,rr,x);
		else modify(p*2,l,mid,ll,mid,x),modify(p*2+1,mid+1,r,mid+1,rr,x);
		tree[p].mint=min(tree[p*2].mint,tree[p*2+1].mint);
	}
	void ask(int p,int l,int r,int limit)
	{
		if (l>=nowans) return; if (l!=r) lazy_tag(p); if (tree[p].mint>limit) return;
		if (l==r) {nowans=l; return;} int mid=(l+r)/2;
		if (tree[p*2].mint<=limit) ask(p*2,l,mid,limit); else ask(p*2+1,mid+1,r,limit);
	}
	void ask(int p,int l,int r,int ll,int rr,int limit)
	{
		if (ll>=nowans) return;
		if (l!=r) lazy_tag(p); int mid=(l+r)/2;
		if ((l==ll)&&(r==rr)) {ask(p,l,r,limit); return;}
		if (rr<=mid) ask(p*2,l,mid,ll,rr,limit);
		else if (ll>mid) ask(p*2+1,mid+1,r,ll,rr,limit);
		else ask(p*2,l,mid,ll,mid,limit),ask(p*2+1,mid+1,r,mid+1,rr,limit);
	}
}
namespace Orz
{
	int n,a[N],far,top1,stack1[N],top2,stack2[N];
	map<int,int> mp;
	void init()
	{
		for (int i=1; i<=n; i++) a[i]/=D;
		Segment::build(1,1,n); top1=top2=0;
		mp.clear();
	}
	void solve(int fst)
	{
		far=0;
		for (int i=1; i<=n; i++)
		{
			for (;(top1)&&(a[i]>=a[stack1[top1]]);top1--) Segment::modify(1,1,n,stack1[top1-1]+1,stack1[top1],a[i]-a[stack1[top1]]);
			for (;(top2)&&(a[i]<=a[stack2[top2]]);top2--) Segment::modify(1,1,n,stack2[top2-1]+1,stack2[top2],a[stack2[top2]]-a[i]);
			stack1[++top1]=i; stack2[++top2]=i; far=max(far,mp[a[i]]+1); mp[a[i]]=i; Segment::modify(1,1,n,i,i,i);
			Segment::nowans=i; Segment::ask(1,1,n,far,i,K+i); updata((node){Segment::nowans+fst,i+fst});
		}
	}
}
void solve()
{
	if (D==0) {Fuck::solve(); return;}
	for (int i=1; i<=n; i++) A[i]=a[i]%D;
	for (int i=1,j; i<=n; i=j)
	{
		for (j=i; (j<=n)&&(A[i]==A[j]); j++); Orz::n=0;
		for (int k=i; k<j; k++) Orz::a[++Orz::n]=a[k];
		Orz::init(); Orz::solve(i-1);
	}
	printf("%d %d\n",ans.l,ans.r);
}
int main()
{
	//freopen("1.in","r",stdin);
	//freopen("1.out","w",stdout);
	init();
	solve();
	return 0;
}
