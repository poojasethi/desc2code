#include <cstdio>
#include <iostream>
#include <map>
#include <stack>
using namespace std;

#define rep(i, n) for (int i = 0; i < n; ++ i)

const int INF = 0x3f3f3f3f;
const int N = 2e5;
int n, k, d, a[N];

// Segment Tree

struct Node
{
	Node *left, *right;
	int l, r, v, d;
	inline void PushDown()
	{
		if (d)
		{
			left -> v += d;
			left -> d += d;
			right -> v += d;
			right -> d += d;
			d = 0;
		}
	}
}memory[N * 2], *root;
int mc;

Node *Build(int l, int r)
{
	Node *p = &memory[mc ++];
	p -> l = l, p -> r = r;
	if (l == r) p -> v = l;
	else
	{
		p -> left = Build(l, (l + r) / 2);
		p -> right = Build((l + r) / 2 + 1, r);
		p -> v = min(p -> left -> v, p -> right -> v);
	}
	return p;
}

void Modify(Node *p, int l, int r, int x)
{
	if (p -> l == l && p -> r == r) p -> v += x, p -> d += x; 
	else
	{
		p -> PushDown();
		if (r <= p -> left -> r) Modify(p -> left, l, r, x);
		else if (l >= p -> right -> l) Modify(p -> right, l, r, x);
		else Modify(p -> left, l, p -> left -> r, x), Modify(p -> right, p -> right -> l, r, x);
		p -> v = min(p -> left -> v, p -> right -> v);
	}
}

int Query(Node *p, int l, int r, int x)
{
	if (p -> l == p -> r) return p -> v <= x ? p -> l : -1;
	p -> PushDown();
	if (p -> left -> v <= x && l <= p -> left -> r)
	{
		int tmp = Query(p -> left, l, min(r, p -> left -> r), x);
		if (tmp != -1) return tmp;
	}
	if (p -> right -> v <= x && r >= p -> right -> l)
		return Query(p -> right, max(l, p -> right -> l), r, x);
	return -1;
}

int ansl, ansr;
inline void Submit(int l, int r)
{
	if (r - l > ansr - ansl || (r - l == ansr - ansl && l < ansl)) ansl = l, ansr = r;
}

int pre[N];

// max(l, r) - min(l, r) - (r - l) <= k

void Solve(int l, int r)
{
	map< int, int > hash;   // value and index
	for (int i = l; i <= r; i ++) a[i] /= d;
	for (int i = l; i <= r; i ++)
	{
		map<int, int> :: iterator iter = hash.find(a[i]);
		if (iter == hash.end()) hash.insert(make_pair(a[i], i));
		else pre[i] = iter -> second + 1, iter -> second = i;
	}
	
	stack< pair<int, int> > maxi, mini;
	
	int p = l;
	for (int i = l; i <= r; i ++)
	{
		p = max(p, pre[i]);
		while (! mini.empty() && a[i] <= mini.top().first) 
		{
			pair<int, int> tmp = mini.top();
			mini.pop();
			if (mini.empty() && p > tmp.second) continue;
			Modify(root, mini.empty() ? p : mini.top().second + 1, tmp.second, tmp.first - a[i]);
		}
		while (! maxi.empty() && a[i] >= maxi.top().first)
		{
			pair<int, int> tmp = maxi.top();
			maxi.pop();
			if (maxi.empty() && p > tmp.second) continue;
			Modify(root, maxi.empty() ? p : maxi.top().second + 1, tmp.second, a[i] - tmp.first);
		}
		mini.push(make_pair(a[i], i));
		maxi.push(make_pair(a[i], i));
		
		int tmp = Query(root, p, i, i + k);
		if (tmp != -1) Submit(tmp, i);
	}
}

int main()
{
	//freopen("input.txt", "r", stdin);
	
	scanf("%d%d%d", &n, &k, &d);
	rep(i, n) 
	{
		scanf("%d", a + i);
		a[i] += 1000000000;
	}
	
	if (d == 0) 
		for (int i = 0; i < n; )
		{
			int r = i + 1;
			while (r < n && a[i] == a[r]) r ++;
			Submit(i, r - 1);
			i = r;
		}
	else 
	{
		root = Build(0, n - 1);
		for (int i = 0; i < n; )
		{
			int r = i + 1;
			while (r < n && a[i] % d == a[r] % d) r ++;
			Solve(i, r - 1);
			i = r;
		}
	}
	cout << ansl + 1 << ' ' << ansr + 1 << endl;
	return 0;
}

