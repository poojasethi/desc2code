#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#include<map>
#define INF 1000000007
#define MAXN 200005
#define Mod(xx) (((xx)%D+D)%D)
using namespace std ;
typedef long long LL ;

struct Deq {
	LL k[MAXN] ;
	LL f1, r1 ;
	LL front() {return k[f1] ;}
	LL last() {return k[r1] ;}
	void pop_front() {f1 ++ ;}
	LL empty() {return f1 > r1 ;}
	void pop_last() {r1 -- ;}
	void push(LL x) {k[++r1] =  x;}
	void clear() {f1 = 1, r1 = 0 ;}
} mx, mn ;

LL N, M, K, D, ans, al, ar ;
LL dp[MAXN] ;
LL tree[MAXN*4], sum[MAXN*4] ;
LL ql, qr, q1 ;
LL p[MAXN], tt[MAXN] ;
map<int, int> last ;

void Set(LL now, LL l, LL r)
{
	LL mid = (l+r)/2 ;
	if(l == r) {tree[now] = sum[now] = q1; return ;}
	if(ql <= mid) Set(now*2, l, mid) ;
	else Set(now*2+1, mid+1, r) ;
	tree[now] = max(tree[now*2], tree[now*2+1]+sum[now*2]) ;
	sum[now] = sum[now*2]+sum[now*2+1] ;
}
LL Find(LL now, LL l, LL r)
{
	LL mid = (l+r)/2 ;
	if(l == r) return l ;
	if(tree[now*2+1]+sum[now*2]+q1 >= -K+1)
	{
		q1 += sum[now*2] ; 
		return Find(now*2+1, mid+1, r) ;
	}
	return Find(now*2, l, mid) ;
}

int main()
{
	LL i, j, t, tmp, ks = 0 ;
	LL lt, rt, debug = 0 ;
	scanf("%I64d %I64d %I64d", &N, &K, &D) ;
	ans = -1 ;
	for(i = 1; i <= N; i ++)
		scanf("%I64d", &p[i]) ;
	if(p[1] == 495252)
		debug = 0 ;
	if(D == 0)
	{
		for(i = N, p[N+1] = INF; i >= 1; i --)
		{
			if(p[i] != p[i+1]) 
				dp[i] = 1 ;
			else dp[i] = dp[i+1]+1 ;
			if(dp[i] >= ans) ans = dp[i], al = i, ar = i+dp[i]-1 ;
		}
		printf("%I64d %I64d\n", al, ar) ;
		return 0 ;
	}
	for(i = N, dp[N+1] = N+1; i >= 1; i --)
	{
		if(!last[p[i]]) dp[i] = N+1 ;
		else dp[i] = last[p[i]]-1 ;
		last[p[i]] = i ;
		dp[i] = min(dp[i], dp[i+1]) ;
	}
	for(t = 1; t <= N;)
	{
		lt = t ;
		for(t ++; t <= N && Mod(p[t]) == Mod(p[t-1]); t ++) ;
		rt = t-1 ;
		mx.clear(), mn.clear() ;
		for(i = rt, M = rt-lt+1; i >= lt; i --)
		{
			while(!mx.empty() && mx.front() > dp[i]) mx.pop_front() ;
			while(!mn.empty() && mn.front() > dp[i]) mn.pop_front() ;
			for(rt; rt > dp[i]; rt --)
			{
				ql = rt-lt+1, q1 = -INF, tt[rt] = -INF ;
				Set(1, 1, M) ;
			}
			while(!mx.empty() && p[tmp=mx.last()] < p[i]) 
			{
				ql = tmp-lt+1, q1 = 1, tt[tmp] = 1 ;
				Set(1, 1, M) ;
				mx.pop_last() ;
			}
			if(!mx.empty()) 
			{
				tmp = mx.last() ;
				ql = tmp-lt+1, q1 = (p[i]-p[tmp])/D+1, tt[tmp] = q1 ;
				Set(1, 1, M) ;
			}
			while(!mn.empty() && p[tmp=mn.last()] > p[i]) 
			{
				if(mx.empty() || mx.last() != tmp)
				{
					ql = tmp-lt+1, q1 = 1, tt[tmp] = 1 ;
					Set(1, 1, M) ;
				}
				mn.pop_last() ;
			}
			if(!mn.empty()) 
			{
				tmp = mn.last() ;
				ql = tmp-lt+1, q1 = (p[tmp]-p[i])/D+1, tt[tmp] = q1 ;
				Set(1, 1, M) ;
			}
			mn.push(i) ;
			mx.push(i) ;
			ql = i-lt+1, q1 = 1, Set(1, 1, M), tt[i] = 1 ;
			q1 = 0, tmp = Find(1, 1, M)+lt-1 ;
			if(debug && i == 716)
			{
				printf("%d %d\n", lt, rt) ;
				printf("%d\n", tmp) ;
				for(j = i; j <= rt; j ++)
					printf("%d ", tt[j]) ;
				printf("\n") ;
			}
			if(tmp-i+1 > ans || tmp-i+1 == ans && i < al)
				ans = tmp-i+1, al = i, ar = tmp ;
		}
		for(i = 1; i <= M; i ++) 
			ql = i, q1 = 0, Set(1, 1, M), tt[i+lt-1] = 0 ;
	}
	printf("%I64d %I64d\n", al, ar) ;
	//system("pause") ;
	return 0 ;
}
