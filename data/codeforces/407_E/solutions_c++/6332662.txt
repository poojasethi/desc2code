#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <map>
using namespace std;

#define REP0(i, n) for (int i = 0; i < n; i++)
#define REP1(i, n) for (int i = 1; i <= n; i++)
#define REP(i, l, r) for (int i = l; i <= r; i++)
#define RP(i, r, l) for (int i = r; i >= l; i--)
#define FORE(i, x) for (int i = fi[x]; i != -1; i = e[i].n)

#define MAX_N 210000
#define oo 2000000000

inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }

typedef struct Seg* ntp;
ntp ta, rt;
struct Seg
{
	   ntp lc, rc; int l, r, mid, mins, maxs, pt, f1, f2;
	   void build(int x, int y)
	   {
		    l = x, r = y, mid = (x + y)	>> 1, pt = mins = maxs = oo;
		    if (l == r) return ;
		    lc = ++ta, lc->build(x, mid), rc = ++ta, rc->build(mid + 1, y);
	   }
	   inline void setf(int val, int fl) //fl = 0ʱ��min  fl = 1ʱ��max 
	   {
			  if (!fl) f1 = val, mins = l - val, pt = maxs - val;
			  else f2 = val, maxs = l + val, pt = mins + val;
	   }
	   inline void down(void)
	   {
              if (f1) lc->setf(f1, 0), rc->setf(f1, 0), f1 = 0;
              if (f2) lc->setf(f2, 1), rc->setf(f2, 1), f2 = 0;
       }
	   inline void upd(void)
	   { mins = min(lc->mins, rc->mins), maxs = min(lc->maxs, rc->maxs);
         pt = min(lc->pt, rc->pt); }
       void modify(int x, int y, int val, int fl)
       {
            if (x <= l && r <= y) { setf(val, fl); return ; }
            down();
            if (x <= mid) lc->modify(x, y, val, fl);
            if (y > mid) rc->modify(x, y, val, fl);
            upd();
       }
       int get(int val)
       {
           if (l == r) return pt <= val ? l : oo;
           down();
           if (lc->pt <= val) return lc->get(val);
           if (rc->pt <= val) return rc->get(val);
           return oo;
       }
} ua[MAX_N << 1];
map < int, int > gi;
int f[MAX_N], g[MAX_N], a[MAX_N];
int n, m, d, L, R, ans, last;

int main(void)
{
//	freopen ("input.txt", "r", stdin);
//  freopen ("output.txt", "w", stdout);
	scanf("%d%d%d", &n, &m, &d);
	REP1(i, n) scanf("%d", a + i);
	if (!d)
	{
	   REP1(i, n)
	   {
		   if (i - 1 && a[i] != a[i - 1]) last = i - 1;
		   if (i - last > ans) ans = i - last, L = last + 1, R = i;
	   }
	   printf ("%d %d\n", L, R);
	   return 0;
	}
	rt = ta = ua, rt->build(1, n);
	REP1(i, n)
	{
        a[i] += oo / 2, last = max(last, gi[a[i]]), gi[a[i]] = i;
        if (i - 1 && (a[i - 1] - a[i]) % d) last = i - 1;
       // printf ("->%d %d\n", last, i);
        while (*f && a[f[*f]] < a[i]) --*f;
        while (*g && a[g[*g]] > a[i]) --*g;
       // REP1(j, *f) printf ("%d ", a[f[j]] - oo / 2); puts("");
       // REP1(j, *g) printf ("%d ", a[g[j]] - oo / 2); puts("");
        rt->modify(f[*f] + 1, i, a[i] / d + 1, 1); //��ֹ0���� 
        rt->modify(g[*g] + 1, i, a[i] / d + 1, 0);
        f[++*f] = g[++*g] = i;
        if (last) rt->modify(1, last, oo, 1);
       // printf ("--- %d\n", rt->pt);
        int li = rt->get(m + i);
      //  printf ("%d %d %d %d\n", li, i, *f, *g);
        if (ans < i - li + 1) ans = i - li + 1, L = li, R = i;
    }
	printf ("%d %d\n", L, R);
	return 0;
}
