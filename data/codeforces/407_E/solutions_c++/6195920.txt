#include <map>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#define mid ((l + r) >> 1)
#define son (k << 1)
#define upd(x) (x[k] = min(x[son], x[son + 1]))
const int inf = (int) 1e9 + 10;
using namespace std;

typedef int arr32[1000010];

arr32 smin, smax, val, Rval, Lval, Aval, v, q1, q2;
int n, k, d, x, tmp;

map <int, int> t;
map <int, int> :: iterator T;

void update(int k)  {
	if (smin[k]  &&  smax[k])  upd(val), Aval[k] = smax[k] - smin[k] + val[k], Lval[k] = - smin[k] + val[k], Rval[k] = smax[k] + val[k];  
	else  if (smax[k])  upd(val), upd(Lval), Aval[k] = Lval[k] + smax[k], Rval[k] = smax[k] + val[k]; 
	else  if (smin[k])  upd(val), upd(Rval), Aval[k] = Rval[k] - smin[k], Lval[k] = val[k] - smin[k];
	else  upd(val), upd(Lval), upd(Rval), upd(Aval);
}
void set_min(int k, int l, int r, int x)  {
	smin[k] = x;
	if (l == r)  val[k] = l, Aval[k] = smax[k] - smin[k] + l, Lval[k] = - smin[k] + l, Rval[k] = smax[k] + l;
	else  update(k);
}
void set_max(int k, int l, int r, int x)  {
	smax[k] = x;
	if (l == r)  val[k] = l, Aval[k] = smax[k] - smin[k] + l, Lval[k] = - smin[k] + l, Rval[k] = smax[k] + l;
	else  update(k);
}
void push(int k, int l, int r)  {
	if (smax[k])  set_max(son, l, mid, smax[k]), set_max(son + 1, mid + 1, r, smax[k]), smax[k] = 0;
	if (smin[k])  set_min(son, l, mid, smin[k]), set_min(son + 1, mid + 1, r, smin[k]), smin[k] = 0;
}
void update_max(int k, int l, int r, int x, int y, int t)  {
	if (l > y  ||  r < x)  return;
	if (x <= l  &&  r <= y)  return set_max(k, l, r, t);
	push(k, l, r);
	update_max(son, l, mid, x, y, t);
	update_max(son + 1, mid + 1, r, x, y, t);
	update(k);
}
void update_min(int k, int l, int r, int x, int y, int t)  {
	if (l > y  ||  r < x)  return;
	if (x <= l  &&  r <= y)  return set_min(k, l, r, t);
	push(k, l, r);
	update_min(son, l, mid, x, y, t);
	update_min(son + 1, mid + 1, r, x, y, t);
	update(k);
}
int ask(int k, int l, int r, int x, int y)  {
	if (l > y  ||  r < x)  return inf;
	if (x <= l  &&  r <= y)  {
		if (Aval[k] > tmp)   return inf;
		if (l == r)  return l;
		push(k, l, r);
		if (Aval[son] <= tmp)  return ask(son, l, mid, x, y);
		return ask(son + 1, mid + 1, r, x, y);
	}
	push(k, l, r);
	int a = ask(son, l, mid, x, y);
	if (a != inf)  return a;
	return ask(son + 1, mid + 1, r, x, y);
}
void build(int k, int l, int r)  {
	if (l == r)  return (void) (val[k] = Lval[k] = Rval[k] = Aval[k] = l);
	build(son, l, mid), build(son + 1, mid + 1, r);
	update(k);
}
int main()  {
	//freopen("E.in", "r", stdin);
	//freopen("E.out", "w", stdout);

	scanf("%d %d %d", &n, &k, &d);
	build(1, 1, n);

	int nt = 0, lt = -1, top1 = 1, top2 = 1, ans = 0, L, R, id = 0;
	for (int i = 1; i <= n; ++i)  {
		scanf("%d", &x);

		if (d == 0)  {
			if (x == lt)  ++id;
			else  id = 1, lt = x;
			if (id > ans)  ans = id, R = i, L = i - id + 1;
			continue;
		}

		v[i] = x += inf;
		if ((x % d) != lt)  nt = i;
		lt = x % d;
		
		if ((T = t.find(x)) != t.end())  nt = max(nt, T->second + 1);
		t[x] = i;

		if (i == 5)
			i = 5;

		while (top1 > 1  &&  v[q1[top1]] <= x)  --top1;
		while (top2 > 1  &&  v[q2[top2]] >= x)  --top2;

		update_max(1, 1, n, q1[top1] + 1, i, x / d + 1);
		update_min(1, 1, n, q2[top2] + 1, i, x / d + 1);

		tmp = i + k;
		int p = ask(1, 1, n, nt, i);

		if (i - p + 1 > ans)  ans = i - p + 1, L = p, R = i;
		q1[++top1] = i;
		q2[++top2] = i;
	}
	printf("%d %d\n", L, R);
}
