#include <cstdio>
#include <algorithm>
#include <map>
#include <ctime>
#define rep(i,l,r) for (int i=l;i<=r;++i)
#define per(i,r,l) for (int i=r;i>=l;--i)
typedef long long LL;
template<class T> bool upmin(T &a,const T &b){return a>b?a=b,1:0;}
template<class T> T Min(const T &a,const T &b){return a<b?a:b;}
template<class T> T Abs(const T &a){return a>0?a:-a;}
const LL LLF=(~0LLU>>1)-10;
LL getx(){
	char c;LL x;bool pd=0;
	for (c=getchar();c!='-'&&(c<'0'||c>'9');c=getchar());
	if (c=='-') pd=1,c=getchar();
	for (x=0;c>='0'&&c<='9';c=getchar())
		x=(x<<3)+(x<<1)+c-'0';
	return pd?-x:x;
}
const int MAX_N=200050;
int n,k;LL d;
LL a[MAX_N];
namespace zeroD{
void solve(){
	int l=1,L=1,R=1;
	a[n+1]=-1;
	rep(i,1,n+1) if (a[i]!=a[l]){
		if (i-l>R-L+1) L=l,R=i-1;
		l=i;
		}
	printf("%d %d\n",L,R);
	exit(0);
}
}
namespace positiveD{

#define lcv v<<1
#define rcv v<<1|1
struct Segment_Tree{
	LL k[MAX_N<<2],tag[MAX_N<<2];
	void up(int v){k[v]=Min(k[lcv],k[rcv]);}
	void down(int v){
		if (tag[v]){
			k[lcv]+=tag[v];
			k[rcv]+=tag[v];
			tag[lcv]+=tag[v];
			tag[rcv]+=tag[v];
			tag[v]=0;
			}
		}
	void modify(int v,int l,int r,int s,int t,LL x){
		if (s<=l&&r<=t){k[v]+=x;tag[v]+=x;return;}
		down(v);
		int mid=l+r>>1;
		if (s<=mid) modify(lcv,l,mid,s,t,x);
		if (t> mid) modify(rcv,mid+1,r,s,t,x);
		up(v);
		}
	LL query(int v,int l,int r,int s,int t){
		if (s<=l&&r<=t) return k[v];
		down(v);
		int mid=l+r>>1;LL res=LLF;
		if (s<=mid) res=query(lcv,l,mid,s,t);
		if (t> mid) upmin(res,query(rcv,mid+1,r,s,t));
		up(v);
		return res;
		}
	int getr(int v,int l,int r,int s,int t,LL x){
		if (r<s||l>t) return -1;
		if (l==r) return l;
		down(v);
		int mid=l+r>>1;int tp=-1;
		if (k[rcv]<=x) if(-1!=(tp=getr(rcv,mid+1,r,s,t,x))) return tp;
		if (k[lcv]<=x) if(-1!=(tp=getr(lcv,l,mid,s,t,x))) return tp;
		return tp;
		}
}T;
std::map<LL,int> suf;
int R[MAX_N];
int max[MAX_N],min[MAX_N];
int pL,C=0;
int getr(int L){
	int l=L,r=R[L];
	if (T.query(1,1,n,r,r)<=k-L) return r;
	while (r-l>1){
		int mid=l+r>>1;
		if (T.query(1,1,n,mid,mid)<=k-L) l=mid;
			else r=mid;
		}
	return l;
}
void calc(){
	int hx=0,hn=0;
	max[0]=min[0]=n+1;
	per(L,n,1){
		T.modify(1,1,n,L,L,-L);
		while(hx>=1&&a[L]>=a[max[hx]]){
			T.modify(1,1,n,max[hx],max[hx-1]-1,(a[L]-a[max[hx]])/d);
			hx--;
			}
		max[++hx]=L;
		while(hn>=1&&a[L]<=a[min[hn]]){
			T.modify(1,1,n,min[hn],min[hn-1]-1,(a[min[hn]]-a[L])/d);
			hn--;
			}
		min[++hn]=L;
		if (R[L]-L+1>=C){
			int r=T.getr(1,1,n,L,R[L],k-L);
			if (r-L+1>=C) pL=L,C=r-L+1;
			}
		}
	printf("%d %d\n",pL,pL+C-1);
}
void solve(){
	R[n]=n;
	per(i,n-1,1){
		suf[a[i+1]]=i+1;
		if (Abs(a[i+1]-a[i])%d==0) R[i]=R[i+1];
			else R[i]=i;
		int p=suf[a[i]];
		if (p&&R[i]>=p) R[i]=p-1;
		}
	calc();
}


}
int main(){
	//int xx=clock();
	n=getx(),k=getx(),d=getx();
	rep(i,1,n) a[i]=getx();
	if (d==0) zeroD::solve();
	positiveD::solve();
	//printf("%d\n",clock()-xx);
}