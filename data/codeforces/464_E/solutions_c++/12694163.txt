#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;

const int mod=1000000007;
struct node {
	int lch,rch,num;
} t[10000005];
struct edge {
	int to,next,w;
} e[200005];
int n,m,tot,st,en,power[100105],pre[100005],head[100005],root[100005],ans;
bool ok[100005];
struct element {
	int dist,id;
};
inline bool check(int p,int q,int l,int r) {
	if (l==r) return t[p].num>t[q].num;
	int mid=(l+r)>>1;
	if (t[t[p].rch].num!=t[t[q].rch].num) return check(t[p].rch,t[q].rch,mid+1,r); else return check(t[p].lch,t[q].lch,l,mid);
}
inline bool operator <(const element &a,const element &b) {
	return check(a.dist,b.dist,0,100100);
}
priority_queue<element> q;
inline void insert(int u,int v,int w) {
	e[++tot].to=v; e[tot].next=head[u]; e[tot].w=w; head[u]=tot;
	e[++tot].to=u; e[tot].next=head[v]; e[tot].w=w; head[v]=tot;
}
inline int plus1(int p,int &q,int l,int r,int d) {
	if (!q) q=++tot;
	if (l==r) {
		t[q].num=t[p].num^1;
		return t[p].num;
	}
	int mid=(l+r)>>1,ans=0;
	if (d<=mid) {
		int h=plus1(t[p].lch,t[q].lch,l,mid,d);
		if (h==0) t[q].rch=t[p].rch; else ans=plus1(t[p].rch,t[q].rch,mid+1,r,mid+1);
	} else {
		t[q].lch=t[p].lch;
		ans=plus1(t[p].rch,t[q].rch,mid+1,r,d);
	}
	t[q].num=((long long)power[mid-l+1]*t[t[q].rch].num+t[t[q].lch].num)%mod;
	return ans;
}
inline void getans(int now) {
	ans++;
	if (now==st) {
		printf("%d\n%d",ans,now);
	} else {
		getans(pre[now]);
		printf(" %d",now);
	}
}
inline void print(int now) {
	printf("%d\n",t[now].num);
	getans(en);
	putchar('\n');
}
int main() {
	scanf("%d%d",&n,&m);
	power[0]=1;
	for (int i=1;i<=100100;i++) power[i]=(power[i-1]<<1)%mod;
	for (int i=1;i<=m;i++) {
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		insert(u,v,w);
	}
	scanf("%d%d",&st,&en);
	root[st]=tot=1;
	q.push((element){root[st],st});
	while (!q.empty()) {
		element now=q.top(); q.pop();
		if (now.id==en) {
			print(now.dist);
			return 0;
		}
		if (ok[now.id]) continue;
		ok[now.id]=true;
		for (int i=head[now.id];i;i=e[i].next) {
			int newnode=0;
			plus1(now.dist,newnode,0,100100,e[i].w);
			if (!root[e[i].to]||check(root[e[i].to],newnode,0,100100)) {
				root[e[i].to]=newnode; pre[e[i].to]=now.id;
				q.push((element){newnode,e[i].to});
			}
		}
	}
	printf("-1\n");
	return 0;
}
