#include <cstdio>
#include <queue>
#include <utility>
#include <vector>
#define X first
#define Y second
#define PB push_back
#define MP make_pair
#define ULL unsigned long long
#define REP(i, n) for (int i = 1; i <= n; ++i)
#define FOR(i, n) for (__typeof(n.begin())i = n.begin(); i != n.end(); ++i)
using namespace std;

const int MAXN=100030;
struct Segment{
	int l, r, m, s, lazy, ls, rs;
	ULL ha;
} t[15000200];
struct PII{
	int X, Y;
	PII(int __X,int __Y):X(__X),Y(__Y){}
};
priority_queue<PII> pq;
vector< pair<int,int> > v[MAXN];
int n, m, S, T, now, cnt, ans, tot;
int way[MAXN];
int root[MAXN];
ULL JW[MAXN];
ULL FU[MAXN];

inline int Newnode(int k) {
	t[++cnt] = t[k];
	return cnt;
}

inline void Pushdown(int &k) {
	if (t[k].lazy == -1) return;
	k = Newnode(k);
	if (t[k].lazy == 0) {
		t[k].s = 0;
		t[k].ha = 0;
	} else {
		t[k].s = t[k].r - t[k].l + 1;
		t[k].ha = FU[t[k].s - 1];
	}
	if (t[k].l != t[k].r) {
		t[k].ls = Newnode(t[k].ls);
		t[k].rs = Newnode(t[k].rs);
		t[t[k].ls].lazy = t[t[k].rs].lazy = t[k].lazy;
	}
	t[k].lazy = -1;
}

inline void Update(int k) {
	t[k].s = t[t[k].ls].s + t[t[k].rs].s;
	t[k].ha = (t[t[k].rs].ha * JW[t[t[k].ls].r - t[t[k].ls].l + 1]) + t[t[k].ls].ha;
}

inline void Query_now(int &k, int x) {
	Pushdown(k); Pushdown(t[k].ls);
	if (t[k].l == t[k].r) now += t[k].s;
	else if (x <= t[k].m) Query_now(t[k].ls, x);
	else {
		now += t[t[k].ls].s;
		Query_now(t[k].rs, x);
	}
}

inline int Query(int &k, int x, int xx) {
	Pushdown(k); Pushdown(t[k].ls);
	if (t[k].l == t[k].r) return t[k].l;
	if (t[k].m < x) return Query(t[k].rs, x, xx + t[t[k].ls].s);
	if (now + t[k].m - x + 1 == xx + t[t[k].ls].s) return Query(t[k].rs, x, xx + t[t[k].ls].s);
	else return Query(t[k].ls, x, xx);
}

inline void Modify(int &k, int l, int r, int x) {
	if (t[k].lazy == -1) k = Newnode(k);
	Pushdown(k);
	if (l <= t[k].l && t[k].r <= r) {
		t[k].lazy = x;
		Pushdown(k);
	} else {
		if (l <= t[k].m) Modify(t[k].ls, l, r, x);
		if (r > t[k].m) Modify(t[k].rs, l, r, x);
		Pushdown(t[k].ls);
		Pushdown(t[k].rs);
		k = Newnode(k);
		Update(k);
	}
}

inline void Build(int &k, int l, int r) {
	k = ++cnt;
	t[k].l = l;
	t[k].r = r;
	t[k].m = (l + r) >> 1;
	t[k].lazy = -1;
	if (t[k].l != t[k].r) {
		Build(t[k].ls, l, t[k].m);
		Build(t[k].rs, t[k].m + 1, r);
	}
}

inline bool Small(int &x,int &y) {
	if (!y) return true;
	Pushdown(x); Pushdown(t[x].rs);
	Pushdown(y); Pushdown(t[y].rs);
	if (t[x].l == t[x].r) return t[x].s < t[y].s;
	if (t[t[x].rs].ha == t[t[y].rs].ha) return Small(t[x].ls, t[y].ls);
	return Small(t[x].rs, t[y].rs);
}

inline bool operator < (PII x, PII y) {
	return !Small(x.Y, y.Y);
}

inline void Calc(int k) {
	Pushdown(k);
	if (t[k].l == t[k].r)
		ans = (ans + ans + t[k].s) % 1000000007;
	else {
		Calc(t[k].rs);
		Calc(t[k].ls);
	}
}

inline void Dfs(int k) {
	if (k == S) printf("%d\n%d", tot+1, S);
	else {
		++tot;
		Dfs(way[k]);
		printf(" %d", k);
	}
}

int main() {
//	freopen("1.in","r",stdin);
	scanf("%d%d", &n, &m);
	JW[0] = FU[0] = 1;
	REP(i, 100022) JW[i] = JW[i-1] * 131ll;
	REP(i, 100022) FU[i] = FU[i-1] + JW[i];
	REP(i, m) {
		int x, y, z;
		scanf("%d%d%d", &x, &y, &z);
		v[x].PB(MP(y, z));
		v[y].PB(MP(x, z));
	}
	scanf("%d%d", &S, &T);
	Build(root[S], 0, 100020);
	pq.push(PII(S, root[S]));
	while (!pq.empty()) {
		PII tmp = pq.top();
		pq.pop();
		if (root[tmp.X] != tmp.Y) continue;
		FOR(p, v[tmp.X]) {
			now = 0;
			if (p -> Y) Query_now(root[tmp.X], p -> Y - 1);
			int pos = Query(root[tmp.X], p -> Y, 0);
			int dist = Newnode(root[tmp.X]);
			if (p -> Y < pos) Modify(dist, p -> Y, pos-1, 0);
			Modify(dist, pos, pos, 1);
			if (Small(dist, root[p -> X])) {
				root[p -> X] = dist;
				pq.push(PII(p -> X, dist));
				way[p -> X] = tmp.X;
			}
		}
	}
	if (!root[T]) {puts("-1");return 0;}
	Calc(root[T]);
	printf("%d\n",ans);
	Dfs(T);
	puts("");
	return 0;
}