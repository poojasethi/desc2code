#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <cstdlib>

using namespace std;

typedef long long int ll;

const ll modulo=1e9+7;
const ll infinito=modulo;

ll eleva[1<<17];

const int limite=10000000;

int nprof=2*18;
int prof[limite];
int hijo[limite][2];
ll hash[limite];

bool menor(int i,int j)
{
  if (i==infinito) return false;
  if (j==infinito) return true;
  if (i<=17) return false;
  if (j<=17) return true;
  if (j<=18+17) return false;
  if (i<=18+17) return true;
  if (hash[i]==hash[j]) return false;
  if (hash[hijo[i][1]]!=hash[hijo[j][1]]) return menor(hijo[i][1],hijo[j][1]);
  return menor(hijo[i][0],hijo[j][0]);
}

struct elem {
  int u,d;
  elem() {
  }
  elem(int inu,int ind) {
    u=inu;d=ind;
  }
};

bool operator<(elem e1,elem e2)
{
  return menor(e2.d,e1.d);
}

pair<int,int> anyade(int i,int valdesp)
{
  if (i<=17 and valdesp==0) return pair<int,int> (18+i,1);
  if (prof[i]==0) return pair<int,int> (0,0);
  int hij[2];
  int carry;
  if ((1<<(prof[i]-1))>valdesp) {
    pair<int,int> p0=anyade(hijo[i][0],valdesp);
    hij[0]=p0.first;
    hij[1]=hijo[i][1];
    carry=0;
    if (p0.second==1) {
      //cout<<"acarreo "<<i<<" "<<valdesp<<endl;
      pair<int,int> p1=anyade(hijo[i][1],0);
      hij[1]=p1.first;
      carry=p1.second;
    }
  } else {
    //cout<<"anyadeleft "<<i<<" "<<valdesp<<" "<<prof[i]<<" "<<(1<<prof[i])<<" "<<(1<<(prof[i]-1))<<endl;
    pair<int,int> p1=anyade(hijo[i][1],valdesp-(1<<(prof[i]-1)));
    hij[0]=hijo[i][0];
    hij[1]=p1.first;
    carry=p1.second;
  }
  if (hij[0]<=17 and hij[1]<=17) return pair<int,int> (hij[0]+1,carry);
  prof[nprof]=prof[i];
  hijo[nprof][0]=hij[0];
  hijo[nprof][1]=hij[1];
  hash[nprof]=(hash[hijo[nprof][0]]+hash[hijo[nprof][1]]*eleva[1<<(prof[nprof]-1)])%modulo;
  pair<int,int> p(nprof,carry);
  //cout<<"crea "<<nprof<<" "<<prof[nprof]<<" "<<hijo[nprof][0]<<" "<<hijo[nprof][1]<<" "<<hash[nprof]<<endl;
  nprof++;
  return p;
}

vector<pair<int,int> > g[limite];
int dist[limite];
int anterior[limite];

int main()
{
  ios::sync_with_stdio(false);
  eleva[0]=1;
  for (int i=1;i<1<<17;i++)
    eleva[i]=(eleva[i-1]*2)%modulo;
  hash[0]=1;
  for (int i=1;i<=17;i++) {
    hijo[i][0]=hijo[i][1]=i-1;
    prof[i]=i;
    hash[i]=(hash[i-1]+hash[i-1]*eleva[1<<prof[i-1]])%modulo;
    hijo[i+18][0]=hijo[i+18][1]=i+18-1;
    prof[i+18]=i;
    //cout<<hash[i]<<endl;
  }
  int n,m;
  cin>>n>>m;
  for (int i=0;i<m;i++) {
    int u,v,d;
    cin>>u>>v>>d;
    g[u].push_back(pair<int,int> (v,d));
    g[v].push_back(pair<int,int> (u,d));
  }
  int uini,ufin;
  cin>>uini>>ufin;
  priority_queue<elem> q;
  for (int i=1;i<=n;i++)
    dist[i]=infinito;
  dist[uini]=18+17;
  q.push(elem(uini,dist[uini]));
  while (not q.empty()) {
    elem e=q.top();
    q.pop();
    int u=e.u;
    int d=e.d;
    if (dist[u]==d) {
      vector<pair<int,int> > &ar=g[u];
      for (int i=0;i<int(ar.size());i++) {
	int v=ar[i].first;
	int valdesp=ar[i].second;
	int dv=anyade(d,valdesp).first;
	if (menor(dv,dist[v])) {
	  dist[v]=dv;
	  q.push(elem(v,dv));
	  anterior[v]=u;
	}
      }
    }
  }
  if (dist[ufin]==infinito) {
    cout<<-1<<endl;
    exit(0);
  }
  cout<<hash[dist[ufin]]<<endl;
  vector<int> sol;
  sol.push_back(ufin);
  int u=ufin;
  while (u!=uini) {
    u=anterior[u];
    sol.push_back(u);
  }
  reverse(sol.begin(),sol.end());
  cout<<int(sol.size())<<endl;
  for (int i=0;i<int(sol.size());i++) {
    if (i>0) cout<<" ";
    cout<<sol[i];
  }
  cout<<endl;
}
