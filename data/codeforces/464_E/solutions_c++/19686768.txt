#include <cstring>
#include <cstdio>
#include <algorithm>
#include <queue>

using namespace std;

const int MAXN = 1e5 + 5e2;
const int Mo = 1e9 + 7;

struct Node {
	int Root, Ver;
	Node (int r, int v) {Root = r, Ver = v;}
	Node () {}
};

struct Tree {
	int l, r, Num;
} Tr[MAXN * 50];

priority_queue<Node> D;

int N, M, S, T, Root[MAXN], Pow[MAXN + 5], Pre[MAXN], Ans[MAXN];
int tot, Next[MAXN * 2], Len[MAXN * 2], Go[MAXN * 2], Last[MAXN];
bool Flag[MAXN];

bool Check(int R1, int R2, int l, int r) {
	if (l == r) return Tr[R1].Num > Tr[R2].Num;
	int Mid = (l + r) >> 1;
	if (Tr[Tr[R1].r].Num != Tr[Tr[R2].r].Num) return Check(Tr[R1].r, Tr[R2].r, Mid + 1, r); else
		Check(Tr[R1].l, Tr[R2].l, l, Mid);
}

bool operator < (Node A, Node B) {
	return Check(A.Root, B.Root, 0, MAXN);
}

void Link(int u, int v, int len) {
	Next[++ tot] = Last[u], Last[u] = tot, Go[tot] = v, Len[tot] = len;
}

int Modify(int &Now, int Rt, int l, int r, int Side) {
	Now = ++ tot;
	if (Rt) Tr[Now] = Tr[Rt];
	if (l == r) {
		Tr[Now].Num ^= 1;
		return Tr[Now].Num ^ 1;
	}
	int Mid = (l + r) >> 1, Flag;
	if (Side <= Mid) {
		Flag = Modify(Tr[Now].l, Tr[Rt].l, l, Mid, Side);
		if (Flag) Flag = Modify(Tr[Now].r, Tr[Rt].r, Mid + 1, r, Mid + 1);
	} else Flag = Modify(Tr[Now].r, Tr[Rt].r, Mid + 1, r, Side);
	Tr[Now].Num = (1ll * Tr[Tr[Now].r].Num * Pow[Mid - l + 1] % Mo + Tr[Tr[Now].l].Num) % Mo;
	return Flag;
}

void Solve() {
	tot = 0;
	Root[S] = ++ tot;
	D.push(Node(Root[S], S));
	bool Succ = 0;
	while (!D.empty()) {
		Node Now = D.top(); D.pop();
		if (Flag[Now.Ver]) continue;
		Flag[Now.Ver] = 1;
		if (Now.Ver == T) {Succ = 1; break;}
		for (int p = Last[Now.Ver]; p; p = Next[p]) {
			int v = Go[p], New;
			Modify(New, Now.Root, 0, MAXN, Len[p]);
			if (!Root[v] || Check(Root[v], New, 0, MAXN)) {
				Root[v] = New, Pre[v] = Now.Ver; 
				D.push(Node(Root[v], v));
			}
		}
	}
	
	if (Succ) {
		int top = 0;
		for (int Now = T; Now; Now = Pre[Now]) Ans[++ top] = Now;
		printf("%d\n%d\n", Tr[Root[T]].Num, top);
		for (; top; top --) printf("%d ", Ans[top]);
	} else printf("-1\n");
}

int main() {
	scanf("%d%d", &N, &M);
	for (int i = 1; i <= M; i ++) {
		int u, v, len;
		scanf("%d%d%d", &u, &v, &len);
		Link(u, v, len), Link(v, u, len);
	}
	scanf("%d%d", &S, &T);
	Pow[0] = 1;
	for (int i = 1; i <= MAXN; i ++) Pow[i] = 1ll * Pow[i - 1] * 2 % Mo;  
	Solve();
}