#include <bits/stdc++.h>

using namespace std;

#define dbgs(x) cerr << (#x) << " --> " << (x) << ' '
#define dbg(x) cerr << (#x) << " --> " << (x) << endl

#define foreach(i,x) for(type(x)i=x.begin();i!=x.end();i++)
#define FOR(ii,aa,bb) for(int ii=aa;ii<=bb;ii++)
#define ROF(ii,aa,bb) for(int ii=aa;ii>=bb;ii--)

#define type(x) __typeof(x.begin())

#define orta (bas + son >> 1)
#define sag (k + k + 1)
#define sol (k + k)

#define pb push_back
#define mp make_pair

#define nd second
#define st first

#define endl '\n'

typedef pair < int ,int > pii;

typedef long long ll;

const int inf = 1e9, mod = 1e9+7;
const int N = 1e5+5;

int hh[N], z,s,t,i, j, k, n, m, x, y, p[N+4], h[2][N+4];

class node{
	public:
	int hash, L;
	node *left, *right;
	node(int x){ L = -1; hash = h[x][N-1]; left = right = NULL;  }
	node(){ L = -1; hash = 0; left = right = NULL;  }
};

typedef node* pnode;

pnode SP[N];

map< int , int > ways[N];

int POW[N], way[N];

vector< pii > v[N];

void push(pnode &ST,int bas,int son){
	if(!ST) ST = new node;
	if(!ST->left) ST->left = new node; 
	if(!ST->right) ST-> right = new node;
	if(ST->L != -1){
		ST->left->L = ST->right->L = ST->L;
		ST->left->hash = h[ST->L][orta-bas+1]; 
		ST->right->hash = h[ST->L][son-orta];
	}
	ST->L = -1;
}
int merge(int x,int y,int sz){ return (x * (ll)p[sz] % mod + y) % mod; }

pnode relax(pnode &ST,int bas,int son){ ST->hash = merge(ST->left->hash,ST->right->hash,son-orta); }

int find(pnode x,pnode y,int bas,int son){
	if(bas == son) return bas;
	if(!x) x = new node;
	if(!y) y = new node;
	push(x,bas,son); push(y,bas,son);
	if(x->right->hash == y->right->hash) return find(x->left,y->left,bas,orta);
	return find(x->right,y->right,orta+1,son);
}

int query(pnode ST,int bas,int son,int x,int y){
	if(!ST) ST = new node;
	if(ST->L != -1) return h[ST->L][max(bas,x)-min(son,y)+1];
	if(x <= bas && son <= y) return ST->hash;
	x = max(x, bas); y = min(y, son);
	push(ST,bas,son); 
	if(orta >= y) return query(ST->left,bas,orta,x,y);
	if(orta < x) return query(ST->right,orta+1,son,x,y);
	return merge(query(ST->left,bas,orta,x,y), query(ST->right,orta+1,son,x,y),min(y,son)-max(orta+1,x)+1);
}

pnode copy(pnode ST,int bas,int son,int x,int y,int t){
	if(bas > y || son < x) return ST;
	pnode temp = new node;
	if(x <= bas && son <= y){ temp->L = t; temp->hash = h[t][son-bas+1]; return temp; }
	push(ST,bas,son);
	temp->left = copy(ST->left,bas,orta,x,y,t);
	temp->right = copy(ST->right,orta+1,son,x,y,t);
	relax(temp,bas,son);
	return temp;	
}

pnode init(pnode &ST,int bas,int son){
	ST = new node; 
	if(bas == son){ ST->hash = 0, ST->L = -1; return ST; }
	ST->left = init(ST->left,bas,orta);
	ST->right = init(ST->right,orta+1,son);
	ST-> L = -1;
	relax(ST,bas,son);
	return ST;	
}

pnode mul(pnode x, int y){
	int m, bas = 0, son = N-y;
	while(bas < son){ 
		m = bas + son >> 1;
		if(m == bas) m++;
		if(query(x,0,N,y,y+m-1) == h[1][m]) bas = m;
		else son = m - 1;
	}
	return copy(copy(x,0,N,y+bas,y+bas,1),0,N,y,y+bas-1,0);
}

bool smaller(pnode x,pnode y){ 
	int diff = find(x,y,0,N);
	return query(x,0,N,diff,diff) < query(y,0,N,diff,diff); 
}

class cmp{
	public:
	bool operator()(const pair< pnode , int > x, const pair< pnode ,int > y){
		int diff = find(x.st,y.st,0,N);
		return query(x.st,0,N,diff,diff) > query(y.st,0,N,diff,diff); 
	}
};

int main(){

	scanf("%d %d",&n,&m);

	FOR(i,1,m){
		scanf("%d %d %d",&x,&y,&z);
		v[x].pb(mp(y,z));
		v[y].pb(mp(x,z));
		ways[x][y] = ways[y][x] = z;
	}
	
	scanf("%d %d",&s,&t);

	POW[0] = 1; p[0] = 1 ; FOR(i,1,N) p[i] = p[i-1] * 5LL % mod, POW[i] = POW[i-1] * 2 % mod;

	FOR(i,1,N) h[1][i] = (h[1][i-1] * 5LL % mod + 1) % mod;

	priority_queue < pair< pnode , int > , vector< pair < pnode , int > > , cmp > q;
	
	pnode zero; init(zero,0,N); 

	pnode a, b; 

	q.push(mp(zero,s));
	
	while(!q.empty()){
		
		a = q.top().st; x = q.top().nd; q.pop();

		if(hh[x] || smaller(SP[x],a)) continue;

		hh[x] = 1;

		if(x == t){
			int ans = 0; int node = t;
			stack< int > S;
			while(node){ S.push(node); ans = (ans + POW[ways[node][way[node]]]) % mod; node = way[node]; }
			printf("%d\n%d\n",(ans-1+mod)%mod,(int)S.size());
			while(!S.empty()){ printf("%d ",S.top()); S.pop(); } return 0; 
			return 0;
		} 
		
		foreach(it,v[x]){
			if(hh[it->st]) continue;
			b = mul(a,it->nd);
			if(it->st != s && !SP[it->st] || smaller(b,SP[it->st])){ 
				SP[it->st] = b; 
				way[it->st] = x;
				q.push(mp(SP[it->st], it->st)); 
			}
		}
		
	}
	
	cout << -1 << endl;
	
    return 0;
}
