#include<bits/stdc++.h>
#define N 110005
#define M 40020005
#define X first
#define Y second
#define pb push_back
#define mk make_pair
using namespace std;
const int P=1000000007;
typedef pair<int,int> Pair;
int wri[N],Pow[N],L[M],R[M],key[M],root[N],id[N],pre[N];
vector<Pair>a[N];bool cnt[M];
int n,m,i,x,y,z,U,j,k,s,t;
int ql,qr,opt,rt,_rt,tot,_tot,flag;
#define down(k) \
    if (cnt[k]) {cnt[k]=0;  \
    if (!L[k]) L[k]=++tot;cnt[L[k]]=1,key[L[k]]=0;  \
    if (!R[k]) R[k]=++tot;cnt[R[k]]=1,key[R[k]]=0;}   
#define up(k) key[k]=(((L[k])?key[L[k]]:0)+1ll*((R[k])?key[R[k]]:0)*Pow[mid-l+1]%P)%P
/*void Build(int &k,int l,int r){
    k=++tot;if (l==r) return;int mid=(l+r)>>1;
    Build(L[k],l,mid);Build(R[k],mid+1,r);
}*/
int Query(int x,int y,int l,int r){
    if (l==r) return key[x]<key[y];
    int mid=(l+r)>>1;
    down(x);down(y);
    return (key[R[x]]!=key[R[y]])?Query(R[x],R[y],mid+1,r):Query(L[x],L[y],l,mid);
}
int Find(int k,int l,int r,int v){
    if (key[k]==Pow[r-l+1]-1) return 0;
    if (l==r) return flag=l,1;int mid=(l+r)>>1;down(k);
    if (v<=l) return Find(L[k],l,mid,v)||Find(R[k],mid+1,r,v);
  if (flag==-1&&v<=mid) Find(L[k],l,mid,v);
  if (flag==-1) Find(R[k],mid+1,r,v);up(k);
  return flag!=-1;
}
void Add(int &k,int l,int r)
{
    int mid=(l+r)>>1;down(k);int x=k;k=++tot;
  L[k]=L[x];R[k]=R[x];key[k]=key[x];
    if (ql<=l&&r<=qr) {key[k]=opt^1;cnt[k]=opt;L[k]=R[k]=0;return;}
    if (ql<=mid) Add(L[k],l,mid);
    if (qr>mid) Add(R[k],mid+1,r);up(k);
}
struct data{
    int k,id,rt;
    friend inline int operator < (const data &a,const data &b){
        return Query(a.rt,b.rt,0,U);
  }
}T;multiset<data>Q;
int main(){
    //freopen("E.in","r",stdin);
    //srand((int)time(0));int x=rand()%3;
    //if (!x) return 1/0;
        scanf("%d%d",&n,&m);
    for (i=1;i<=m;i++)
        scanf("%d%d%d",&x,&y,&z),U=max(U,z),
        a[x].pb(mk(y,z)),a[y].pb(mk(x,z));
    scanf("%d%d",&s,&t);U+=50;
    for (Pow[0]=i=1;i<=U+1;i++) Pow[i]=(Pow[i-1]<<1)%P;
    //Build(root[s],0,U);
    root[s]=tot=1;Q.insert((data){s,id[s]=1,root[s]});
    while (!Q.empty()){
        T=*Q.begin();Q.erase(Q.begin());
        k=T.k;rt=T.rt;if (k==t) break;
        if (T.id<id[k]) continue;
        for (i=0;i<a[k].size();i++){
            x=a[k][i].X;y=a[k][i].Y;
            flag=-1;Find(rt,0,U,y);
            _tot=tot;_rt=rt;
            ql=y;qr=flag-1;opt=1;if (ql<=qr) Add(rt,0,U);
            ql=qr=flag;opt=0;Add(rt,0,U);
            if (root[x]&&!Query(rt,root[x],1,U)) {
                for (j=_tot+1;j<=tot;j++) key[j]=L[j]=R[j]=cnt[j]=0;
                rt=_rt;tot=_tot;continue;
          }pre[x]=k;root[x]=rt;rt=_rt;
          Q.insert((data){x,++id[x],root[x]});
    }

  }if (root[t]==0) return puts("-1"),0;
    printf("%d\n",key[root[t]]);
    for (i=t;i;i=pre[i]) wri[++*wri]=i;
        printf("%d\n",*wri);
        for (i=*wri;i;i--) printf("%d ",wri[i]);
        puts("");
    //printf("%d\n",tot);
}