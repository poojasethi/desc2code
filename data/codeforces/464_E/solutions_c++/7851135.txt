#include <iostream>
#include <fstream>
#include <cstring>
#include <string>
#include <cstdlib>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <bitset>
#include <ctime>
#include <map>
#include <queue>
using namespace std;

const int modd=1e9+7;
const int maxp=20000000;
const int maxn=100000+55;
const int sumw=100000+55;
struct Node
{
	int l,r;
	int sumo;
	long long hash;
}sz[maxp];
int n,m,tot;
bool boo[maxn];
int com[maxn];
int fre,node[maxn*2],next[maxn*2],head[maxn],vv[maxn*2];
int powe[maxn];
int x,y,z,S,T; 
int root[maxn];
int wint[maxn*4];
int prew;
bool got;
int line[maxn],summ;
bool operator < (const Node &a,const Node &b)
{
	if (a.hash==b.hash) return false;
	if (a.sumo>0 && b.sumo==0) return false;
	if (a.sumo==0 && b.sumo>0) return true;
	if (sz[a.r].hash!=sz[b.r].hash) return sz[a.r]<sz[b.r];
	return sz[a.l]<sz[b.l];
}
int inser(int x,int y,int z)
{
	node[++fre]=y;
	next[fre]=head[x];
	head[x]=fre;
	vv[fre]=z;
	return 0;
}
int upw(int wz)
{
	while (wz!=1)
	{
		wz>>=1;
		if (wint[wz<<1]==-1) wint[wz]=wint[wz<<1|1];
		 else if (wint[wz<<1|1]==-1) wint[wz]=wint[wz<<1];
		  else if (sz[root[wint[wz<<1]]]<sz[root[wint[wz<<1|1]]]) wint[wz]=wint[wz<<1];
		   else wint[wz]=wint[wz<<1|1];		
	}
	return 0;
}
int build(int root,int l,int r,int x)
{
	if (r<x || got) return root;
	if (l>=x && sz[root].sumo==r-l+1) return 0;
	int g=++tot;
	sz[g]=sz[root];
	if (l==r)
	 {
	 	sz[g].sumo=1;
	 	sz[g].hash=1;
	 	got=true;
	 	return g;
	 }
	int mid=(l+r)>>1;
	sz[g].l=build(sz[root].l,l,mid,x);
	sz[g].r=build(sz[root].r,mid+1,r,x);
	sz[g].sumo=sz[sz[g].l].sumo+sz[sz[g].r].sumo;
	sz[g].hash=sz[sz[g].l].hash+sz[sz[g].r].hash*powe[mid-l+1]%modd;
	sz[g].hash%=modd;
	return g;
}
int main()
{
	scanf("%d%d",&n,&m);
	powe[0]=1;
	for (int i=1;i<=sumw;i++) 
	  powe[i]=powe[i-1]*2%modd;
	for (int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		inser(x,y,z);
		inser(y,x,z);
	}
	scanf("%d%d",&S,&T);
	prew=1;
	while (prew<n) prew*=2;
	prew--;
	memset(wint,-1,sizeof(wint));
	root[S]=1;
	tot++;
	wint[prew+S]=S;
	upw(prew+S);
	for (int i=1;i<=n;i++)
	{
		int g=wint[1];
		if (g==-1) break;
		wint[prew+g]=-1;
		boo[g]=true;
		upw(prew+g);
		for (int u=head[g];u;u=next[u])
		 if (!boo[node[u]])
		  {
		  	got=false;
		  	root[0]=build(root[g],0,sumw,vv[u]);
		  	if (root[node[u]]==0 || sz[root[0]]<sz[root[node[u]]])
		  	{
		  	 root[node[u]]=root[0];
		  	 com[node[u]]=g;
		  	 wint[prew+node[u]]=node[u];
		  	 upw(prew+node[u]);
		    }
		  }
	}
	if (!boo[T]) printf("-1\n");
	 else
	 {
	 	printf("%I64d\n",sz[root[T]].hash);
	 	summ=1;
	 	line[1]=T;
	 	while (line[summ]!=S) 
	 	{
	 		summ++;
	 		line[summ]=com[line[summ-1]];
	 	}
	 	printf("%d\n",summ);
	 	for (int i=summ;i>1;i--) printf("%d ",line[i]);
	 	printf("%d\n",line[1]);
	 }
	return 0;
}