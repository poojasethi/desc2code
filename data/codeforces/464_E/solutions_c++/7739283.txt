#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
#include<string>
#include<set>
#define LL long long
#define MP make_pair
#define lc tr[p].l
#define rc tr[p].r
#define mid ((l+r)>>1)
#define PII pair<int,int>
using namespace std;
vector<PII> E[100010];
int n,m,D,x,y,z,pre[100010],inf=1e9,st,en,root[100010],M[100040],P=inf+7,ans[100010];
struct node
{
	int cnto,hash,l,r,lmzro;
};
struct seg_tre
{
	node tr[8000010];int cnt;
	void updata(int p,int l,int r)
	{
		tr[p].cnto=tr[lc].cnto+tr[rc].cnto;
		tr[p].lmzro=min(tr[lc].lmzro,tr[rc].lmzro);
		tr[p].hash=((LL)tr[rc].hash*M[mid-l]%P+tr[lc].hash)%P;
	}
	int Build(int l,int r)
	{
		int p=++cnt;
		if (l==r-1){tr[p].lmzro=l;return p;}
		lc=Build(l,mid);rc=Build(mid,r);updata(p,l,r);
		return p;
	}
	int GetLM(int p,int l,int r,int a,int b)
	{
		if (l==a&&r==b) return tr[p].lmzro;
		if (b<=mid) return GetLM(lc,l,mid,a,b);
		if (a>=mid) return GetLM(rc,mid,r,a,b);
		return min(GetLM(lc,l,mid,a,mid),GetLM(rc,mid,r,mid,b));
	}
	int Addone(int p,int l,int r,int x)
	{
		int k=++cnt;
		if (l==r-1){tr[k].cnto++;tr[k].hash=1;tr[k].lmzro=inf;return k;}
		tr[k]=tr[p];
		if (x+1<=mid) tr[k].l=Addone(lc,l,mid,x);
		else tr[k].r=Addone(rc,mid,r,x);
		updata(k,l,r);
		return k;
	}
	int Coverzro(int p,int zro,int l,int r,int a,int b)
	{
		if (l==a&&r==b) return zro;
		int k=++cnt;tr[k]=tr[p];
		if (b<=mid) tr[k].l=Coverzro(lc,tr[zro].l,l,mid,a,b);
		else if (a>=mid) tr[k].r=Coverzro(rc,tr[zro].r,mid,r,a,b);
		else
		{
			tr[k].l=Coverzro(lc,tr[zro].l,l,mid,a,mid);
			tr[k].r=Coverzro(rc,tr[zro].r,mid,r,mid,b);
		}
		updata(k,l,r);
		return k;
	}
	bool Small(int p1,int p2,int l,int r)
	{
		if (l==r-1) return tr[p1].hash<tr[p2].hash;
		if (tr[tr[p1].r].hash==tr[tr[p2].r].hash&&tr[tr[p1].r].cnto==tr[tr[p2].r].cnto) 
			return Small(tr[p1].l,tr[p2].l,l,mid);
		return Small(tr[p1].r,tr[p2].r,mid,r);
	}
}T;
struct heap
{
	int ind,root;
	bool operator<(heap const&A) const
	{
		if (root==inf) return 0;
		if (A.root==inf) return 1;
		return T.Small(root,A.root,0,D+1);
	}
};
multiset<heap> A;
void read(int &x)
{
	char ch=getchar();int mark=1;for(;ch!='-'&&(ch<'0'||ch>'9');ch=getchar());if (ch=='-') mark=-1,ch=getchar();
	for(x=0;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-48;x*=mark;
}
inline heap make(int ind,int root){heap ans;ans.ind=ind;ans.root=root;return ans;}
int main()
{
	//freopen("a.in","r",stdin);
	read(n);read(m);
	for(int i=1;i<=m;i++)
	{
		read(x);read(y);read(z);D=max(D,z);
		E[x].push_back(MP(y,z));E[y].push_back(MP(x,z));
	}
	read(st);read(en);
	D+=20;
	M[0]=1;
	for(int i=1;i<=D;i++) M[i]=M[i-1]*2%P;
	//A.insert(make(st,0));
	for(int i=1;i<=n;i++) root[i]=inf;
	root[st]=T.Build(0,D+1);
	for(int i=1;i<=n;i++) A.insert(make(i,root[i]));
	while (A.size())
	{
		heap it=*A.begin();
		if (it.ind==en) break;
		if (it.root==inf) break;
		A.erase(A.begin());
		int u=it.ind,rt=it.root;
		for(int i=0;i<E[u].size();i++)
		{
			int v=E[u][i].first,z=E[u][i].second;
			int t=T.GetLM(rt,0,D+1,z,D+1);
			int nrt=T.Addone(rt,0,D+1,t);
			if (z<t) nrt=T.Coverzro(nrt,1,0,D+1,z,t);
			if (make(v,nrt)<make(v,root[v])) 
			{
				A.erase(A.find(make(v,root[v])));
				pre[v]=u;root[v]=nrt;
				A.insert(make(v,root[v]));
			}
		}
		//printf("%d\n",T.cnt);
	}
	if (root[en]==inf) printf("-1\n");
	else
	{
		printf("%d\n",T.tr[root[en]].hash);
		int cnt=0;
		for(int u=en;u;u=pre[u]) ans[++cnt]=u;
		printf("%d\n",cnt);
		for(int i=cnt;i;i--) printf("%d ",ans[i]);printf("\n");
	}
	return 0;
}
