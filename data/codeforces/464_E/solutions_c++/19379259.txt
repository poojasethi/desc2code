#include <iostream>
#include <cstdio>
#include <vector>
#include <map>
#include <cstring>
#include <string>
#include <cmath>
#include <ctime>
#include <queue>
#include <set>
#include <algorithm>

using namespace std;

#define LL long long
#define N 100100
#define M 5000010
#define MP make_pair
#define Pi acos(-1.0)
//#pragma comment(linker,"/STACK:1024000000,1024000000")
#define inf 0x3f3f3f3f
#define ls (rt << 1)
#define rs (ls | 1)
#define md ((ll+rr)>>1)
#define lson ll, md, ls
#define rson md+1,rr,rs
#define mod 1000000007
#define INF 1LL<<63
#define sqr(x) ((x)*(x))
#define uLL unsigned long long
#define U unsigned int
LL powmod(LL a,LL b){
	LL res = 1; a %= mod;
	for(;b;b>>=1){
		if(b & 1) res = res * a % mod;
		a = a * a % mod;
	}
	return res;
}

int hashv[N * 80];
int ch[N * 80][2],cnt[N * 80];
int tot;
int p2[N];
int rt[N];
int fst[N],cost[M],nxt[M],vv[M],e;
LL ans;

void init(){
	e = 0;
	memset(fst,-1,sizeof fst);
	p2[0] = 1;
	for(int i = 1; i < N; i++){
		p2[i] = 2LL * p2[i-1] % mod;
	} 
}

void add(int u,int v,int c){
	vv[e] = v,nxt[e] = fst[u],cost[e] = c,fst[u] = e++;
	vv[e] = u,nxt[e] = fst[v],cost[e] = c,fst[v] = e++;
}

void up(int rt,int ll,int rr){
	cnt[rt] = cnt[ch[rt][0]] + cnt[ch[rt][1]];
	hashv[rt] = (1LL * hashv[ch[rt][0]] * p2[rr - md] + hashv[ch[rt][1]])%mod;
}


int update(int rt,int x,int v,int ll,int rr){
	int k = ++tot;
	ch[k][0] = ch[rt][0];
	ch[k][1] = ch[rt][1];
	cnt[k] = cnt[rt] + v;
	if(ll == rr){
		hashv[k] = v;
		return k;
	}
	if(x <= md) ch[k][0] = update(ch[rt][0],x,v,ll,md);
	else ch[k][1] = update(ch[rt][1],x,v,md+1,rr);
	up(k,ll,rr);
	return k;
}

int getfirstone(int rt,int x,int ll,int rr){
	if(cnt[rt] == rr - ll + 1) return -1;	
	if(ll == rr){
		if(cnt[rt]) return -1;
		else return ll;
	}

	if(x > md) return getfirstone(ch[rt][1],x,md+1,rr);
	else if(x == ll){
		if(cnt[ch[rt][0]] == md - ll + 1) return getfirstone(ch[rt][1],md+1,md+1,rr);
		else return getfirstone(ch[rt][0],x,ll,md);
	}
	int res = getfirstone(ch[rt][0],x,ll,md);
	if(res == -1) res = getfirstone(ch[rt][1],md+1,md+1,rr);
	return res;
}

int setzero(int rt,int l,int r,int ll,int rr){
	if(l == ll && r == rr) return 0;

	int k = ++tot;
	ch[k][0] = ch[rt][0];
	ch[k][1] = ch[rt][1];
	if(r <= md) ch[k][0] = setzero(ch[rt][0],l,r,ll,md);
	else if(l > md) ch[k][1] = setzero(ch[rt][1],l,r,md+1,rr);
	else ch[k][0] = setzero(ch[rt][0],l,md,ll,md),ch[k][1] = setzero(ch[rt][1],md+1,r,md+1,rr);
	up(k,ll,rr);
	return k;
}

bool cmp(int rt1,int rt2,int ll,int rr){
	if(hashv[rt1] == hashv[rt2]) return 0;
	if(ll == rr){
		return cnt[rt1] < cnt[rt2];
	}
	if(hashv[ch[rt1][1]] != hashv[ch[rt2][1]]) return cmp(ch[rt1][1],ch[rt2][1],md+1,rr);
   	return cmp(ch[rt1][0],ch[rt2][0],ll,md);	
}

void dfs(int rt,int ll,int rr){
	if(ll == rr){
		if(cnt[rt]) ans = ans * 2 + 1;
		else ans *= 2;
		ans %= mod;
		return;
	}
	dfs(ch[rt][1],md+1,rr);
	dfs(ch[rt][0],ll,md);
}

struct node{
	int u,rt;
	node(){}
	node(int _u,int _rt):u(_u),rt(_rt){}
	bool operator <(const node&x) const{
		return cmp(x.rt,rt,0,N-1);
	}
};
int s,t;
int n,m,pre[N];

void spfa(){
	priority_queue<node> q;
	q.push(node(s,rt[s]));
	for(int i = 1; i <= n; i++) //初始化为inf
		if(i != s) rt[i] = update(0,N-1,1,0,N-1);
	while(!q.empty()){
		int u = q.top().u;
		int root = q.top().rt;
		q.pop();
		if(rt[u] != root) continue;
		
		for(int i = fst[u]; ~i; i = nxt[i]){
			int v = vv[i],c = cost[i];
			
			int p = getfirstone(rt[u],c,0,N-1);
			int t = rt[u];
			if(p > c) t = setzero(rt[u],c,p-1,0,N-1);
			t = update(t,p,1,0,N-1);
			
			if(cmp(t,rt[v],0,N-1)){
				
				rt[v] = t;
				pre[v] = u;
				q.push(node(v,rt[v]));
			}
		}
	}
}

void solve(){
	spfa();
	if(pre[t] == 0){
		puts("-1");
		return;
	}
	ans = 0;
	dfs(rt[t],0,N-1);
	vector<int> ans1;
	ans1.push_back(t);
	while(pre[t]){
		t = pre[t];
		ans1.push_back(t);
	}
	int ss = (int)ans1.size();
	printf("%lld\n%d\n",ans,ss);
	for(int i = ss - 1; i >= 0; i--){
		printf("%d%c",ans1[i],i == 0 ? '\n' : ' ');
	}
}

int main(){
	scanf("%d%d",&n,&m);
	init();
	for(int i = 1; i <= m; i++){
		int u,v,c;
		scanf("%d%d%d",&u,&v,&c);
		add(u,v,c);
	}
	scanf("%d%d",&s,&t);
	if(s == t){
		puts("0");puts("1");printf("%d\n",s);
		return 0;
	}
	solve();
}
			      		 	 		  		 	 				   	