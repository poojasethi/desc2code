#include <iostream>
#include <cstdio>
#include <map>
#include <queue>
#include <stack>
#include <set>
#include <cstring>
#include <cstdlib>
#include <cctype>
#include <string>
#include <algorithm>
#define REP(i, a, b) for (int i = (a); i <= (b); ++i)
#define PER(i, a, b) for (int i = (a); i >= (b); --i)
#define RED(k, u) for (int k = head[(u)]; k; k = edge[k].next)
#define CL(x, v) memset(x, v, sizeof x)
#define MP make_pair
#define FR first
#define SC second
#define rank rankk
using namespace std;

typedef pair<int, int> PII;
typedef pair<PII, int> PIII;
typedef long long LL;

const int N = 100010;
const LL mo = 1000000007;

int tot = 0;
struct Edge_node {
	int p, w, next;
}edge[2 * N];



int head[N];

void ae(int a, int b, int c)
{
	edge[++tot].p = b;
	edge[tot].w = c;
	edge[tot].next = head[a];
	head[a] = tot;
}

struct Seg_node {
	int l, r, num;
	LL hash;
	Seg_node() {l = r = num = hash = 0;}
}tree[N * 50];
int cnt = 0;
LL pow[2 * N];
int n, m, d, pre[N];
int S, T, dis[N];
bool vis[N], inf[N];


inline
void update(int u, int s)
{
	tree[u].num = tree[tree[u].l].num + tree[tree[u].r].num;
	tree[u].hash = (tree[tree[u].r].hash * pow[s] % mo + tree[tree[u].l].hash) % mo;
}

void insert(int &u, int L, int R, const int p)
{
	tree[++cnt] = tree[u]; u = cnt;
	if (L == R) {tree[u].hash = tree[u].num = 1; return;}
	int mid = (L + R) >> 1;
	if (p <= mid) insert(tree[u].l, L, mid, p);
	else insert(tree[u].r, mid + 1, R, p);
	update(u, mid - L + 1);
}

void make_same(int &u, int L, int R, int l, int r)
{
	tree[++cnt] = tree[u]; u = cnt;
	if (l <= L && r >= R) {
		tree[u] = tree[0];
		return;
	}
	int mid = (L + R) >> 1;
	if (r <= mid) make_same(tree[u].l, L, mid, l, r);
	else if (l > mid) make_same(tree[u].r, mid + 1, R, l, r);
	else {
		make_same(tree[u].l, L, mid, l, mid);
		make_same(tree[u].r, mid + 1, R, mid + 1, r);
	}
	update(u, mid - L + 1);
}

int get(int &u, int L, int R, const int &p)
{
	if (L == R) return tree[u].num;
	int mid = (L + R) >> 1;
	if (p <= mid)  return get(tree[u].l, L, mid, p);
	else return get(tree[u].r, mid + 1, R, p) + tree[tree[u].l].num;
}

int next_zero(int u, int p)
{
	int l = p, r = d, tmp;
	int x;
	if (p == 0) x = 0;
	else x = get(u, 0, d, p - 1);
	while (l <= r) {
		int mid = (l + r) >> 1;
		if (get(u, 0, d, mid) - x < mid - p + 1) {
			tmp = mid;
			r = mid - 1;
		}
		else l = mid + 1;
	}
	return tmp;
}

bool comp(int u, int v, int L, int R)
{
	if (L == R) return tree[u].num < tree[v].num;
	int mid = (L + R) >> 1;
	int a = tree[u].r, b = tree[v].r;
	if (tree[a].hash != tree[b].hash) return comp(a, b, mid + 1, R);
	else return comp(tree[u].l, tree[v].l, L, mid);
}

struct Compare {
	inline
	bool operator () (const PII &a, const PII &b) {
		return comp(b.FR, a.FR, 0, d);
	}
};

int Plus(int a, const int p)
{
	int pos = next_zero(a, p);
	insert(a, 0, d, pos);
	if (pos > p) make_same(a, 0, d, p , pos - 1);
	return a;
}

priority_queue<PII, vector<PII> , Compare> q;

void dij()
{
	inf[S] = 0;
	dis[S] = 0;
	q.push(MP(dis[S], S));
	while (!q.empty()) {
		while (!q.empty()&&vis[q.top().SC]) q.pop();
		if (q.empty()) break;
		int u = q.top().SC, tmp =q.top().FR; q.pop();
		vis[u] = 1;
		RED(k, u) {
			int v = edge[k].p;
			if (vis[v]) continue;
			int a = Plus(tmp, edge[k].w);
			if (inf[v] || comp(a, dis[v], 0, d)) {
				inf[v] = 0;
				dis[v] = a;
				pre[v] = u;
				q.push(MP(dis[v], v));
			}
		}
	}
}

stack<int> ans;


int main()
{
	cin >> n >> m;
	while (m--) {
		int x, y, z;
		scanf("%d%d%d", &x, &y, &z);
		ae(x, y, z);
		ae(y, x, z);
		d = max(d, 2 * z);
	}
	cin >> S >> T;
	pow[0] = 1;
	REP(i, 1, d) pow[i] = pow[i - 1] * 2LL % mo;
	CL(inf, 1);
	CL(vis, 0);
	dij();

	if (inf[T])  {
		puts("-1");
		return 0;
	}
	cout << tree[dis[T]].hash << endl;
	int now = T;
	while (now) {
		ans.push(now);
		now = pre[now];
	}
	cout << ans.size() <<endl;
	while (!ans.empty()) {
		printf("%d ", ans.top());
		ans.pop();
	}
	return 0;
}
