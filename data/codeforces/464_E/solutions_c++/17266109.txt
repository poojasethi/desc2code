#include<bits/stdc++.h>
using namespace std;
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define re(i,a,b) for(int i=(a);i<(b);i++)
#define repd(i,a,b) for(int i=(a);i>=(b);i--)
#define run(v) for(int k=head[v];k;k=e[k].ne)
#define v e[k].t
#define ergomap(i,a) for(map<int,int>::iterator i=a.begin();i!=a.end();i++)
#define ergoset(i,a) for(set<int>::iterator i=a.begin();i!=a.end();i++)
#define ergo(i,a) for(int i=0;i<a.size();i++)
#define clr(a) memset(a,0,sizeof(a));
#define il inline
#define sz(a) ((int)a.size())
#define pb push_back 
#define w1 first
#define w2 second
#define addm(a,b,c) {a=a+b;if(a>=c)a-=c;}
typedef pair<int,int> pa;
typedef long long ll;typedef long double ld;typedef unsigned long long ull;
const int N=1e5+5,M=2e6+5,INF=1e9,mod=1e9+7,MX=1e5;
const ll linf=1e18;const double eps=1e-8,pi=acos(-1);
il int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}
il void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}
il void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}
il void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}
il ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}
il ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)addm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)addm(ret,a,mod);return ret;}
il void judge(){
	freopen("data.in","r",stdin);
	freopen("data.out","w",stdout);}
il void gen(){freopen("data.in","w",stdout);}
int n,m,bin[N]={1},flag,tot,head[N],b[N],f[N],rt[N],cnt,S,T;
struct edge{int t,ne,c;}e[N*2];
struct data{int h,l,r;}t[M*5];
il bool cmp(int x,int y){
	if(!t[x].l&&!t[x].r)return t[x].h>t[y].h;
	if(t[x].h==t[y].h)return x>y;
	return(t[t[x].r].h==t[t[y].r].h)?cmp(t[x].l,t[y].l):cmp(t[x].r,t[y].r);
}
struct comp{il bool operator()(pa x,pa y){return cmp(x.w1,y.w1);}};
priority_queue<pa,vector<pa>,comp >pq;
il void adde(int a,int b,int c){
	e[++cnt]=(edge){b,head[a],c};head[a]=cnt;
	e[++cnt]=(edge){a,head[b],c};head[b]=cnt;
}
#define ls t[k].l
#define rs t[k].r
il void update(int k,int l,int r){
	int mid=(l+r)>>1;
	t[k].h=(t[ls].h+1ll*t[rs].h*bin[mid-l+1]%mod)%mod;
}
void add(int&y,int x,int l,int r,int adt){
	t[y=++tot]=t[x];
	if(l==r){
		if(t[y].h)flag=1,t[y].h=0;else t[y].h=1;
		return;
	}int mid=(l+r)>>1;
	if(adt<=mid){
		add(t[y].l,t[x].l,l,mid,adt);
		if(flag)flag=0,add(t[y].r,t[x].r,mid+1,r,mid+1);
	}else add(t[y].r,t[x].r,mid+1,r,adt);
	update(y,l,r);
}
int vis[N],q[N],top,pre[N];
int main(){
	read(n,m);
	rep(i,1,m){
		int a,b,c;read(a,b,c);adde(a,b,c);
	}read(S,T);
	rep(i,1,MX+1)bin[i]=bin[i-1]*2%mod;
	rep(i,1,n)if(i!=S)flag=0,add(rt[i],rt[i],0,MX+20,MX+20);
	pq.push(pa(rt[S],S));
	while(!pq.empty()){
		int x=pq.top().w2;pq.pop();
		if(x==T){
			printf("%d\n",t[rt[x]].h),q[++top]=T;
			while(x!=S)x=pre[x],q[++top]=x;
			printf("%d\n",top);
			while(top)printf("%d ",q[top--]);
			return 0;
		}if(vis[x])continue;else vis[x]=1;
		run(x){
			flag=0;int root;add(root,rt[x],0,MX+20,e[k].c);
			if(cmp(rt[v],root))
				rt[v]=root,pre[v]=x,pq.push(pa(rt[v],v));
		}
	}
	printf("-1\n");
}
