#include<iostream>
#include<fstream>
#include<cstdio>
#include<vector>
#include<string>
#include<cstring>
#include<queue>
#include<map>
#include<set>
#include<algorithm>
#include<iomanip>
#include<bitset>
using namespace std;

const int N = 101000;
const int MOD = 1000000007;

int n, m, s, d;
vector<pair<int, int> > v[N];

struct node {
    int l, r, hash;
};

int rad[N], pw[N], nodc = 1, add;
node x[N * 111];

void update(int &nod, int pozx, int pozy, int poz) {
    x[++nodc] = x[nod];
    nod = nodc;

    if(pozx == pozy) {
        if(x[nod].hash) {
            x[nod].hash = 0;
            add = 1;
        }
        else
            x[nod].hash = 1;

        return;
    }

    int mid = (pozx + pozy) / 2;

    if(poz <= mid) {
        update(x[nod].l, pozx, mid, poz);
        if(add) {
            add = 0;
            update(x[nod].r, mid + 1, pozy, poz);
        }
    }
    else
        update(x[nod].r, mid + 1, pozy, poz);

    x[nod].hash = ( 1LL * x[x[nod].r].hash * pw[mid - pozx + 1] + 1LL * x[x[nod].l].hash) % MOD;
}

//1 daca a > b
bool cmp(int a, int b) {
    if(!x[a].l && !x[a].r)
        return x[a].hash > x[b].hash;

    if(x[x[a].r].hash == x[x[b].r].hash)
        return cmp(x[a].l, x[b].l);
    else
        return cmp(x[a].r, x[b].r);
    return a < b;
}

struct cmpp {
    bool operator()(pair<int, int> a, pair<int, int> b) {
        return cmp(a.second, b.second);
    }
};

priority_queue<pair<int, int>, vector<pair<int, int> >, cmpp> q;
vector<int> rez;
bool ver[N];
int t[N];

bool dijkstra() {
    int i;

    pw[0] = 1;
    for(i = 1; i < N; ++i)
        pw[i] = (pw[i - 1] * 2) % MOD;

    rad[s] = 1;
    for(i = 1; i <= n; ++i) if(i != s) {
        update(rad[i], 0, N - 1, N - 1);

        //cout << x[rad[i]].l << " " << x[rad[i]].r << " " << x[rad[i]].hash << "\n";
    }

    q.push(pair<int, int>(s, rad[s]));

    while(!q.empty()) {
        int el = q.top().first;
        q.pop();

        if(ver[el])
            continue;
        ver[el] = 1;

        if(el == d) {

            cout << x[rad[el]].hash << "\n";

            while(el) {
                rez.push_back(el);
                el = t[el];
            }

            cout << rez.size() << "\n";
            for(i = rez.size() - 1; i >= 0; --i)
                cout << rez[i] << " ";

            return true;
        }

        for(vector<pair<int, int> >::iterator it = v[el].begin(); it != v[el].end(); ++it) {

            //cout << it->first << " " << it->second << "\n";

            int dist = rad[el];
            update(dist, 0, N - 1, it->second);

            if(cmp(rad[it->first], dist)) {
                rad[it->first] = dist;
                t[it->first] = el;

                q.push(pair<int, int>(it->first, rad[it->first]));
            }
        }
    }

    return false;
}

int main() {
    int i;
    //freopen("ttt", "r", stdin);

    cin >> n >> m;

    for(i = 1; i <= m; ++i) {
        int a, b, c;
        cin >> a >> b >> c;

        v[a].push_back(pair<int, int>(b, c));
        v[b].push_back(pair<int, int>(a, c));
    }
    cin >> s >> d;

    if(!dijkstra())
        cout << -1;

    return 0;
}
