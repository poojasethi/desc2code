#include<bits/stdc++.h>
#define M 100050
#define fi first
#define se second
using namespace std;
typedef pair < int , int > ii;
int mod = 1e9 + 7 ,dist[M + 5] , n , m , trace[M + 5] , s , t , max_c , all0 , all1;
struct node{
	int cleft , cright , hash_val , lazy , zero;
	void init(){
		cleft = -1 ; cright = -1 ; hash_val = -1 , lazy = -1 , zero = -1;
	}
};
vector < node > X;
node toAdd;
int pw[M + 5];
struct persistent_IT{
	void build(int k,int p,int q,int x){
		X.push_back(toAdd);
		if(p == q){
			X[k].hash_val = x; 
			X[k].zero = (x == 0) ? p : -1;
			return ;
		}
		int mid = (p + q)/2;
		X[k].cleft = X.size() ; build(X.size() , p , mid , x);
		X[k].cright = X.size() ; build(X.size() , mid + 1 , q , x);
		X[k].zero = (X[X[k].cleft].zero == -1) ? X[X[k].cright].zero : X[X[k].cleft].zero;
		X[k].hash_val = (1ll*X[X[k].cright].hash_val*pw[mid - p + 1] + X[X[k].cleft].hash_val)%mod;
	}
	int upd(int k,int p,int q,int u,int v,int x,int t){
		if(p > v || u > q || u > v)	return k;
		if(p >= u && v >= q) return t;
		int mid = (p + q)/2;
		int tleft  = upd(X[k].cleft, p , mid , u , v , x , X[t].cleft);
		int tright = upd(X[k].cright , mid + 1 , q , u , v , x , X[t].cright);
		int c = X.size() ; X.push_back(toAdd);
		X[c].cleft = tleft ; X[c].cright = tright;
		X[c].zero = X[X[c].cleft].zero == -1 ? X[X[c].cright].zero : X[X[c].cleft].zero;
		X[c].hash_val = (1ll*X[X[c].cright].hash_val*pw[mid - p + 1] + X[X[c].cleft].hash_val)%mod;	
		return c;	
		
	}
	int get(int k,int p,int q,int u,int v){
		if(p > v || u > q)	return -1;
		if(p >= u && v >= q)	return X[k].zero;
		int mid = (p + q)/2;
		int xx = get(X[k].cleft , p , mid , u , v);
		int yy = get(X[k].cright , mid + 1 , q , u , v);
		return (xx == -1) ? yy : xx; 
	}
	bool is_smaller(int x,int y,int p,int q){
		if(p == q)	return X[x].hash_val < X[y].hash_val;
		if(X[X[x].cright].hash_val != X[X[y].cright].hash_val)	return is_smaller(X[x].cright , X[y].cright , (p + q)/2 + 1 , q);
		return is_smaller(X[x].cleft , X[y].cleft , p , (p + q)/2);
	}
};
persistent_IT IT;
vector < ii > adj[M + 5];
struct cmp{
	bool operator () (ii x , ii y){
		return IT.is_smaller(y.fi , x.fi , 1 , M);
	}
};
priority_queue < ii , vector < ii > , cmp > pq;
bool valid = false;
void solve(){
	toAdd.init();
	all0 = 0 ; IT.build(all0, 1 , M , 0); dist[s] = all0; 
	all1 = X.size() ; IT.build(all1 , 1 , M , 1) ; for(int i = 1 ; i <= n ; i++) if(i != s)	dist[i] = all1 ;
	pq.push(ii(dist[s] , s));
	while(!pq.empty()){
		int x = pq.top().fi; int u = pq.top().se; pq.pop();
		if(u == t)	valid = true;
		if(dist[u] != x)	continue;
		for(int i = 0 ; i < adj[u].size() ; i++){
			int v = adj[u][i].fi , c = adj[u][i].se;
			int t = IT.get(dist[u] , 1 , M , c , M);
			int ret = IT.upd(dist[u] , 1 , M , c , t - 1 , 0 , all0);
			ret = IT.upd(ret , 1 , M , t , t , 1 , all1);
			if(IT.is_smaller(ret , dist[v] , 1 , M)){
				dist[v] = ret; trace[v] = u;
				pq.push(ii(dist[v] , v));
			}
		}
	}
	if(!valid){
		printf("-1");
		return ;
	}
	printf("%d\n",X[dist[t]].hash_val);
	vector < int > sol;
	while(t != s){
		sol.push_back(t) ; t = trace[t];
	}
	sol.push_back(s);
	reverse(sol.begin() , sol.end());
	printf("%d\n",sol.size());
	for(int i = 0 ; i < sol.size() ; i++)	printf("%d ",sol[i]);
}
void load_graph(){
	scanf("%d %d",&n,&m);
	for(int i = 1 ; i <= m ; i++){
		int u , v , x;
		scanf("%d %d %d",&u,&v,&x);
		x++;
		max_c = max(max_c , x);
		adj[u].push_back(ii(v , x));
		adj[v].push_back(ii(u , x));
	}
	pw[0] = 1;
	for(int i = 1 ; i <= M ; i++)	pw[i] = 1ll*pw[i - 1]*2%mod;
	scanf("%d %d",&s,&t);
}
main(){
	//freopen("test.inp","r",stdin);
	load_graph();
	solve();
}