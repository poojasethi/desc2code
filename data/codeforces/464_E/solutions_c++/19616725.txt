#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
#define maxn 100055
#define mo 1000000007
using namespace std;

struct seg{
	int lson,rson,now;
}tree[maxn * 50];

struct note{
	int rt,w;
};

int dist[maxn];

int n,m,num,S,T;

int head[maxn],t[maxn * 2],next[maxn * 2],v[maxn * 2],sum;

int sh[maxn],pre[maxn];

bool bz[maxn];

priority_queue<note> q;

// x is larger than y

bool larger(int x,int y,int l,int r){
	if (l==r) return tree[x].now>tree[y].now;
	int mid=(l+r) >> 1;
	if (tree[tree[x].rson].now!=tree[tree[y].rson].now) 
		return larger(tree[x].rson,tree[y].rson,mid+1,r);
		else return larger(tree[x].lson,tree[y].lson,l,mid);
}

bool operator < (note i,note j){
	return larger(i.rt,j.rt,0,100050);
}

void insert(int x,int y,int z){
	t[++sum]=y;
	v[sum]=z;
	next[sum]=head[x];
	head[x]=sum;
}

int ans[maxn];

void outp(note tmp){
	printf("%d\n",tree[tmp.rt].now);
	for(int i=T;i;i=pre[i]) ans[++ans[0]]=i;
	printf("%d\n",ans[0]);
	fd(i,ans[0],1) printf("%d ",ans[i]);
}

int add(int rt1,int &rt2,int l,int r,int x){
	rt2=++num;
	if (l==r) {
		tree[rt2].now=tree[rt1].now ^ 1;
		return tree[rt1].now;
	}
	int mid=(l+r) >> 1,ret=0;
	if (x<=mid){
		int tmp=add(tree[rt1].lson,tree[rt2].lson,l,mid,x);
		if (tmp==0) {
			tree[rt2].rson=tree[rt1].rson;
			ret=0;
		}
		else ret=add(tree[rt1].rson,tree[rt2].rson,mid+1,r,mid+1);
	}
	else {
		tree[rt2].lson=tree[rt1].lson;
		ret=add(tree[rt1].rson,tree[rt2].rson,mid+1,r,x);
	}
	tree[rt2].now=(1ll*tree[tree[rt2].rson].now*sh[mid-l+1] % mo+tree[tree[rt2].lson].now) % mo;
	return ret;
}

int main(){
	sh[0]=1;
	fo(i,1,100050) sh[i]=sh[i-1] * 2 % mo;
	scanf("%d%d",&n,&m);
	fo(i,1,m) {
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		insert(x,y,z);
		insert(y,x,z);
	}
	scanf("%d%d",&S,&T);
	dist[S]=++num;
	note tmp;
	tmp.rt=dist[S];
	tmp.w=S;
	q.push(tmp);
	while (!q.empty()) {
		note tmp=q.top();
		q.pop();
		if (bz[tmp.w]) continue;
		bz[tmp.w]=1;
		if (tmp.w==T) {
			outp(tmp);
			return 0;
		}
		for(int i=head[tmp.w];i;i=next[i]) {
			int now;
			add(tmp.rt,now,0,100050,v[i]);
			if (dist[t[i]]==0 || larger(dist[t[i]],now,0,100050)) {
				dist[t[i]]=now;
				pre[t[i]]=tmp.w;
				note pq;
				pq.rt=now;
				pq.w=t[i];
				q.push(pq);
			}
		}
	}
	puts("-1");
	return 0;
}