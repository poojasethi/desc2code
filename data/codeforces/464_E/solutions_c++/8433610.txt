#include<stdio.h>
#include<queue>
#include<iostream>
#include<string.h>
#include<vector>
#include<algorithm>
#include<map>
using namespace std;

const int maxn=100010;
const int mod1=131;
const int mod2=133;
const int mod=1000000007;

unsigned long long mi1[maxn],mi2[maxn];
struct hash
{
	unsigned long long v1,v2;
	hash(int v=0)
	{
		v1=v2=v;
	}
	bool operator ==(const hash& n)const
	{
		return v1==n.v1&&v2==n.v2;
	}
	hash operator +(const hash& n)const
	{
		hash ret;
		ret.v1=v1+n.v1;
		ret.v2=v2+n.v2;
		return ret;
	}
	hash operator *(int n)const
	{
		hash ret;
		ret.v1=v1*mi1[n];
		ret.v2=v2*mi2[n];
		return ret;
	}
};
int cnt,lc[maxn*60],rc[maxn*60],con[maxn*60];
hash val[maxn*60];

void flow(int n,int l,int r)
{
	int mid=(l+r)/2;
	val[n]=val[lc[n]];
	if(rc[n])
		val[n]=val[n]+val[rc[n]]*(mid-l+1);

	if(rc[n])
	{
		con[n]=con[rc[n]];
		if(con[n]==r-mid&&lc[n])
			con[n]+=con[lc[n]];
	}
	else
		con[n]=0;
}

int del(int n,int l,int r,int ll,int rr)
{
	if(l==ll&&r==rr)
		return 0;
	int m=++cnt;
	int mid=(l+r)/2;

	lc[m]=lc[n],rc[m]=rc[n];
	if(rr<=mid)
		lc[m]=del(lc[m],l,mid,ll,rr);
	else if(ll>mid)
		rc[m]=del(rc[m],mid+1,r,ll,rr);
	else
		lc[m]=del(lc[m],l,mid,ll,mid),rc[m]=del(rc[m],mid+1,r,mid+1,rr);
	flow(m,l,r);
	return m;
}

int ins(int n,int l,int r,int p)
{
	int m=++cnt;
	lc[m]=lc[n],rc[m]=rc[n];
	if(l==r)
	{
		val[m]=1;
		con[m]=1;
		return m;
	}
	int mid=(l+r)/2;
	if(p<=mid)
		lc[m]=ins(lc[m],l,mid,p);
	else
		rc[m]=ins(rc[m],mid+1,r,p);
	flow(m,l,r);
	return m;
}

int ask(int n,int l,int r,int p)
{
	if(l==r||n==0)
		return p;
	int mid=(l+r)/2;
	if(p>mid)
		return ask(rc[n],mid+1,r,p);
	if(lc[n]&&con[lc[n]]>=mid-p+1)
		return ask(rc[n],mid+1,r,mid+1);
	return ask(lc[n],l,mid,p);
}

int cmp(int r1,int r2,int l,int r)
{
	if(val[r1]==val[r2])
		return 0;
	if(l==r)
	{
		if(val[r1].v1<val[r2].v1)
			return -1;
		return 1;
	}
	if(val[rc[r1]]==val[rc[r2]])
		return cmp(lc[r1],lc[r2],l,(l+r)/2);
	return cmp(rc[r1],rc[r2],(l+r)/2+1,r);
}

int dis[maxn],first[maxn],nxt[maxn*2],vv[maxn*2],w[maxn*2],pre[maxn*2];
int vis[maxn];

struct NN
{
	int n,r;

	NN(int nn=0,int rr=0)
	{
		n=nn,r=rr;
	}

	bool operator <(const NN & n)const
	{
		return cmp(r,n.r,0,maxn-1)>0;
	}
};

priority_queue<NN>q;

void bfs(int n,int s,int t)
{
	int u,v,e,i;
	val[0]=0;

	memset(dis,-1,sizeof(dis));
	dis[s]=0;

	q.push(NN(s,0));

	while(!q.empty())
	{
		NN uu=q.top();q.pop();
		u=uu.n;
		if(vis[u])
			continue;
		vis[u]=1;

		for(e=first[u];e;e=nxt[e])
		{
			v=vv[e];
			if(vis[v])
				continue;
			int pos=ask(uu.r,0,maxn-1,w[e]);
			int nr=uu.r;

			if(pos>w[e])
				nr=del(nr,0,maxn-1,w[e],pos-1);
			nr=ins(nr,0,maxn-1,pos);

			if(dis[v]==-1||cmp(nr,dis[v],0,maxn-1)<0)
			{
				dis[v]=nr;
				q.push(NN(v,nr));
				pre[v]=e;
			}
		}
	}
}

int mi[maxn];
int main()
{
	int n,m,i,j,k,u,v,e=2;

	for(mi1[0]=mi2[0]=mi[0]=1,i=1;i<maxn;i++)
		mi1[i]=mi1[i-1]*mod1,mi2[i]=mi2[i-1]*mod2,mi[i]=mi[i-1]*2%mod;
	scanf("%d%d",&n,&m);
	for(i=1;i<=m;i++)
	{
		scanf("%d%d%d",&u,&v,&j);
		nxt[e]=first[u],vv[e]=v,w[e]=j,first[u]=e++;
		nxt[e]=first[v],vv[e]=u,w[e]=j,first[v]=e++;
	}
	int s,t;
	scanf("%d%d",&s,&t);
	swap(s,t);
	bfs(n,s,t);

	if(dis[t]>=0)
	{
		int ans1=0,ans2=0;

		for(i=t;i-s;i=vv[pre[i]^1])
			ans1=(ans1+mi[w[pre[i]]])%mod,ans2++;
		printf("%d\n%d\n",ans1,ans2+1);
		
		for(i=t;i-s;i=vv[pre[i]^1])
			printf("%d ",i);
		printf("%d\n",i);
	}
	else
		puts("-1");
}
