#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <vector>
#include <ctime>
#include <queue>
#define fi first
#define se second
#define PA pair<int,int>
#define VI vector<int>
#define VP vector<PA >
#define mk(x,y) make_pair(x,y)
#define N 110000
#define mo 1000000007
#define For(i,x,y) for (i=x;i<=y;i++)
using namespace std;
struct ww {
	int l,r,a;
} tr[N*100];

int i,j,k,n,m,nn,S,T,t,an;
int ro[N],F[N],fa[N],ha[N];
VP a[N];

bool ju(int p,int q,int x,int y) {
	if (x==y) return tr[p].a>tr[q].a;
	int mid=(x+y)/2;
	if (tr[tr[p].r].a!=tr[tr[q].r].a) return ju(tr[p].r,tr[q].r,mid+1,y);
	else return ju(tr[p].l,tr[q].l,x,mid);
}//p>q

struct dui {
	int a,id;
	inline bool operator < (const dui &A) const {
		return ju(a,A.a,0,nn);
	}
};

priority_queue<dui> D;

bool jia(int p,int &q,int x,int y,int k) {
	if (!q) q=++t;
	if (x==y) {
		tr[q].a=tr[p].a^1;
		return tr[p].a;
	}
	int mid=(x+y)/2,re;
	if (mid<k) tr[q].l=tr[p].l,re=jia(tr[p].r,tr[q].r,mid+1,y,k);
	else {
		int A=jia(tr[p].l,tr[q].l,x,mid,k);
		if (!A) tr[q].r=tr[p].r,re=0;
		else re=jia(tr[p].r,tr[q].r,mid+1,y,mid+1);
	}
	tr[q].a=(1ll*ha[mid-x+1]*tr[tr[q].r].a+tr[tr[q].l].a)%mo;
	return re;
}

void dfs(int x) {
	an++;
	if (x==S) {
		printf("%d\n%d ",an,x);
		return;
	}
	dfs(fa[x]);
	printf("%d ",x);
}
inline void print(int w) {
	printf("%d\n",tr[w].a);
	an=0;
	dfs(T);
	printf("\n");
	exit(0);
}
int main() {
	ha[0]=1; For(i,1,N-1) ha[i]=ha[i-1]*2%mo;
	scanf("%d%d",&n,&m);
	For(i,1,m) {
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		a[x].push_back(mk(y,z));
		a[y].push_back(mk(x,z));
	}
	scanf("%d%d",&S,&T);
	nn=101000;
	ro[S]=++t; D.push((dui){ro[S],S});
	for (;!D.empty();) {
		dui A=D.top();
		D.pop();
		if (A.id==T) print(A.a);
		if (F[A.id]) continue;
		F[A.id]=1;
		for (i=0;i<a[A.id].size();i++) {
			PA B=a[A.id][i];
			int x=0;
			jia(A.a,x,0,nn,B.se);
			if (!ro[B.fi]||ju(ro[B.fi],x,0,nn)) {
				ro[B.fi]=x; fa[B.fi]=A.id;
				D.push((dui){x,B.fi});
			}
		}
	}
	printf("-1\n");
	return 0;
}
