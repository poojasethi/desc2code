#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <vector>
#include <ctime>
#include <queue>
#define fi first
#define se second
#define PA pair<int,int>
#define VI vector<int>
#define VP vector<PA >
#define mk(x,y) make_pair(x,y)
#define N 110000
#define mo 1000000007
#define For(i,x,y) for (i=x;i<=y;i++)
using namespace std;
struct ww {
	int l,r,a;
} tr[N*100];

int i,j,k,n,m,nn,S,T,t,an;
int ro[N],F[N],fa[N],ha[N],Ha[N];
VP a[N];

bool ju(int p,int q,int x,int y) {
	if (x==y) return tr[p].a>tr[q].a;
	int mid=(x+y)/2;
	if (tr[tr[p].r].a!=tr[tr[q].r].a) return ju(tr[p].r,tr[q].r,mid+1,y);
	else return ju(tr[p].l,tr[q].l,x,mid);
}//p>q

struct dui {
	int a,id;
	inline bool operator < (const dui &A) const {
		return ju(a,A.a,0,nn);
	}
};

priority_queue<dui> D;

bool find(int q,int x,int y,int l,int r) {
	if (l<=x&&y<=r) {
		int len=y-x+1;
		return tr[q].a==Ha[len];
	}
	int mid=(x+y)/2,re=1;
	if (l<=mid) re&=find(tr[q].l,x,mid,l,r);
	if (mid<r) re&=find(tr[q].r,mid+1,y,l,r);
	return re;
}

inline void update(int x,int l,int r) {
	int y=tr[x].l,z=tr[x].r,mid=(l+r)/2;
	tr[x].a=(1ll*ha[mid-l+1]*tr[z].a+tr[y].a)%mo;
}

void clear(int p,int &q,int x,int y,int l,int r) {
	if (!q) q=++t;
	if (l<=x&&y<=r) return;
	int mid=(x+y)/2;
	if (l<=mid) clear(tr[p].l,tr[q].l,x,mid,l,r);
	else tr[q].l=tr[p].l;
	if (mid<r) clear(tr[p].r,tr[q].r,mid+1,y,l,r);
	else tr[q].r=tr[p].r;
	update(q,x,y);
}

void jia(int p,int &q,int x,int y,int k) {
	if (!q) q=++t;
	if (x==y) {
		tr[q].a=1;
		return;
	}
	int mid=(x+y)/2;
	if (k<=mid) jia(tr[p].l,tr[q].l,x,mid,k),tr[q].r=tr[p].r;
	else tr[q].l=tr[p].l,jia(tr[p].r,tr[q].r,mid+1,y,k);
	update(q,x,y);
}

inline void into(int &w,int k) {
	int L,R,mid,r=0;
	for (L=k,R=nn;L<=R;) {
		mid=(L+R)/2;
		if (find(w,0,nn,k,mid)) L=mid+1;
		else R=mid-1;
	}
	if (L==k) r=w;
	else clear(w,r,0,nn,k,L-1);
	w=0;
	jia(r,w,0,nn,L);
}

void Dfs(int q,int x,int y) {
	if (!q) return;
	if (x==y) {
		an=(1ll*ha[x]*tr[q].a+an)%mo;
		return;
	}
	int mid=(x+y)/2;
	Dfs(tr[q].l,x,mid);
	Dfs(tr[q].r,mid+1,y);
}
void dfs(int x) {
	an++;
	if (x==S) {
		printf("%d\n%d ",an,x);
		return;
	}
	dfs(fa[x]);
	printf("%d ",x);
}
inline void print(int w) {
	an=0;
	Dfs(w,0,nn);
	printf("%d\n",an);
	an=0;
	dfs(T);
	printf("\n");
	exit(0);
}
int main() {
	ha[0]=1; For(i,1,N-1) ha[i]=ha[i-1]*2%mo;
	For(i,1,N-1) Ha[i]=(Ha[i-1]+ha[i-1])%mo;
	scanf("%d%d",&n,&m);
	For(i,1,m) {
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		a[x].push_back(mk(y,z));
		a[y].push_back(mk(x,z));
	}
	scanf("%d%d",&S,&T);
	nn=101000;
	For(i,1,n) {
		ro[i]=++t;
		if (i!=S) into(ro[i],nn);
		else D.push((dui){ro[i],i});
	}
	for (;!D.empty();) {
		dui A=D.top();
		D.pop();
		if (A.id==T) print(A.a);
		if (F[A.id]) continue;
		F[A.id]=1;
		for (i=0;i<a[A.id].size();i++) {
			PA B=a[A.id][i];
			int x=A.a;
			into(x,B.se);
			if (ju(ro[B.fi],x,0,nn)) {
				ro[B.fi]=x; fa[B.fi]=A.id;
				D.push((dui){x,B.fi});
			}
		}
	}
	printf("-1\n");
	return 0;
}
