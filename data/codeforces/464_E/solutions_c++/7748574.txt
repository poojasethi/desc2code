#include <cstdio>
#include <algorithm>
#include <map>
#include <queue>

using namespace std;

typedef pair<int,int> PII;

const int N = 100010;
const int D = 10000010;
const int MAXW = N + 1000;

const int mod = 1e9 + 7;

int n, m;
int pw2[MAXW + 10];

struct edge {
    int to, nx, w;
} ee[N * 2];
int eq[N], en = 1;

int dn, flag;
int l[D], r[D], hs[D];

int ans[N], root[N], pred[N];
bool done[N];

int sv[N], svt;

bool cmp(int u, int v) {
    if (!l[u] && !r[u])
        return hs[u] <= hs[v];
    else
        return hs[r[u]] == hs[r[v]]? cmp(l[u], l[v]): cmp(r[u], r[v]);
}
struct compare {
    bool operator () (const PII& u, const PII& v) {
        if (hs[u.first] == hs[v.first])
            return u > v;
        else
            return !cmp(u.first, v.first);
    }
};
priority_queue<PII,vector<PII>,compare> Q;

void update(int d, int lt, int rt) {
    int md = (lt + rt) >> 1;
    hs[d] = (1LL * hs[r[d]] * pw2[md - lt + 1] + hs[l[d]]) % mod;
}
int add(int d, int lt, int rt) {
    int nd = ++dn, md = (lt + rt) >> 1;
    if (lt == rt) hs[nd] = 1;
    else {
        if ((hs[l[d]] + 1) % mod != pw2[md - lt + 1]) {
            l[nd] = add(l[d], lt, md);
            r[nd] = r[d];
        } else {
            l[nd] = 0;
            r[nd] = add(r[d], md + 1, rt);
        }
        update(nd, lt, rt);
    }
    return nd;
}
int add(int d, int lt, int rt, int w) {
    int nd = ++dn, md = (lt + rt) >> 1;
    if (lt == rt) {
        if (hs[d]) return 0;
        else {
            flag = 1;
            return hs[nd] = 1, nd;
        }
    }
    if (w <= md) {
        l[nd] = add(l[d], lt, md, w);
        if (flag) {
            r[nd] = r[d];
        } else {
            if ((hs[r[d]] + 1) % mod == pw2[rt - md])
                r[nd] = 0;
            else {
                flag = 1;
                r[nd] = add(r[d], md + 1, rt);
            }
        }
    } else {
        l[nd] = l[d];
        r[nd] = add(r[d], md + 1, rt, w);
    }
    update(nd, lt, rt);
    return nd;
}
void link(int u, int v, int w) {
    ee[++en] = (edge) {v, eq[u], w}, eq[u] = en;
}
int main() {
    scanf("%d %d", &n, &m);
    for (int i = 0; i <= MAXW; ++i) {
        pw2[i] = !i? 1: (pw2[i - 1] * 2) % mod;
    }
    for (int i = 1; i <= m; ++i) {
        int u, v, w;
        scanf("%d %d %d", &u, &v, &w);
        link(u, v, w);
        link(v, u, w);
    }

    int s, t;
    scanf("%d %d", &s, &t);
    for (int i = 1; i <= n; ++i) {
        if (i != s) {
            flag = 0;
            root[i] = add(root[i], 0, MAXW, MAXW);
        }
        Q.push(make_pair(root[i], i));
    }
    while (!Q.empty()) {
        int u = Q.top().second;
        Q.pop();
        if (done[u]) continue;
        done[u] = 1;
        for (int j = eq[u], v; v = ee[j].to, j; j = ee[j].nx)
            if (!done[v]) {
                flag = 0;
                int nt = add(root[u], 0, MAXW, ee[j].w);
                if (cmp(nt, root[v])) {
                    root[v] = nt;
                    pred[v] = u;
                    ans[v] = (ans[u] + pw2[ee[j].w]) % mod;
                    flag = 0;
                    int nt = add(root[u], 0, MAXW, ee[j].w);
                    Q.push(make_pair(root[v], v));
                }
            }
    }

    if (s == t || pred[t]) {
        printf("%d\n", ans[t]);
        svt = 0;
        for (int o = t; o; o = pred[o])
            sv[++svt] = o;
        printf("%d\n", svt);
        for (int i = svt; i >= 1; --i)
            printf("%d ", sv[i]);
            putchar('\n');
            
    } else {
        printf("-1\n");
    }
}