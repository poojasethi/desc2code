#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <map>
#include <set>
#include <list>
#include <queue>
#include <vector>
#include <bitset>
#include <complex>
#include <cmath>
#include <ctime>
#include <cassert>

using namespace std;

#define pb push_back
#define mp make_pair
#define REP(i, n) for (int i = 0; i < (int)(n); i++)
#define foreach(e, x) for (__typeof(x.begin()) e = x.begin(); e != x.end(); e++)
typedef long long LL;
typedef pair<int, int> PII;

const int maxn = 100010;
const int maxl = 100100;
const int MOD = 1000000007;

int pre[maxn], TEN[maxl];
vector<PII> graph[maxn];

struct Tree
{
	int l, r, low, flag, hashe;
	Tree *lc, *rc;

	void down()
	{
		lc = new Tree(*lc);
		rc = new Tree(*rc);
		lc->low = lc->l;
		rc->low = rc->l;
		lc->flag = rc->flag = 1;
		lc->hashe = rc->hashe = 0;
		flag = 0;
	}

	void fresh()
	{
		low = min(lc->low, rc->low);
		hashe = ((LL)rc->hashe * TEN[lc->r-lc->l] + lc->hashe) % MOD;
	}

	Tree(int _l, int _r) : l(_l), r(_r)
	{
		low = l;
		flag = hashe = 0;
		lc = l+1 < r ? new Tree(l, (l+r) >> 1) : NULL;
		rc = l+1 < r ? new Tree((l+r) >> 1, r) : NULL;
	}

	Tree *cover(int ll, int rr) // change 1 to 0
	{
		if (l+1 < r && flag) down();
		Tree *node = new Tree(*this);
		if (ll <= l && rr >= r) {
			node->low = l;
			node->flag = 1;
			node->hashe = 0;
		}
		else {
			if (ll < (l+r) >> 1) node->lc = lc->cover(ll, rr);
			if (rr > (l+r) >> 1) node->rc = rc->cover(ll, rr);
			node->fresh();
		}
		return node;
	}

	Tree *change(int x) // change 0 to 1
	{
		if (l+1 < r && flag) down();
		Tree *node = new Tree(*this);
		if (l+1 == r) {
			node->low = maxl;
			node->flag = 0;
			node->hashe = 1;
		}
		else {
			if (x < (l+r) >> 1) node->lc = lc->change(x);
			else node->rc = rc->change(x);
			node->fresh();
		}
		return node;
	}

	int search(int x)
	{
		if (l == x) return low;
		if (flag) down();
		if (x < (l+r) >> 1) {
			int ret = lc->search(x);
			fresh();
			return min(ret, rc->low);
		}
		else {
			int ret = rc->search(x);
			fresh();
			return ret;
		}
	}
} *root, *d[maxn];

Tree *add(Tree *root, int x)
{
	int y = root->search(x);
	root = root->change(y);
	if (x < y) root = root->cover(x, y);
	return root;
}

int lesser(Tree *a, Tree *b)
{
	while (a->l+1 < a->r) {
		if (a->flag) a->down();
		if (b->flag) b->down();
		if (a->rc->hashe != b->rc->hashe) {
			a = a->rc;
			b = b->rc;
		}
		else {
			a = a->lc;
			b = b->lc;
		}
	}
	return a->hashe - b->hashe;
}

struct cmp {
	bool operator()(int a, int b) {
		int ret = lesser(d[a], d[b]);
		return ret == -1 || (ret == 0 && a < b);
	}
};

set<int, cmp> S;

int main()
{
	//freopen("input.txt", "r", stdin);
	//freopen("output.txt", "w", stdout);

	int n, m, u, v, w, s, t;
	cin >> n >> m;
	for (int i = 0; i < m; i++) {
		cin >> u >> v >> w; u--; v--;
		graph[u].push_back(make_pair(v, w));
		graph[v].push_back(make_pair(u, w));
	}
	cin >> s >> t; s--; t--;

	TEN[0] = 1;
	for (int i = 1; i < maxl; i++) TEN[i] = TEN[i-1]*2 % MOD;
	root = new Tree(0, maxl-10);
	d[s] = root;
	root = root->change(maxl-20);
	for (int i = 0; i < n; i++) if (i != s) d[i] = root;
	for (int i = 0; i < n; i++) S.insert(i);
	memset(pre, -1, sizeof(pre));
	while (! S.empty()) {
		int k = *S.begin();
		S.erase(k);
		foreach(e, graph[k]) {
			Tree *cnt = add(d[k], e->second);
			if (lesser(cnt, d[e->first]) == -1) {
				S.erase(e->first);
				d[e->first] = cnt;
				S.insert(e->first);
				pre[e->first] = k;
			}
		}
	}

	if (pre[t] == -1 && s != t) cout << -1 << endl;
	else {
		cout << d[t]->hashe << endl;
		vector<int> path;
		for (int k = t; k != -1; k = pre[k]) path.push_back(k);
		cout << path.size() << endl;
		for (int i = path.size()-1; i >= 0; i--) {
			cout << path[i]+1;
			i == 0 ? cout << endl : cout << ' ';
		}
	}

	return 0;
}

