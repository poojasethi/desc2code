def is_palindrome(s): return s==s[::-1]

def palin2(s, l):
    end = [1]*l
    y,total=0,0
    if s=='': return 0
    for i in xrange(l):
        x = 1
        for j in xrange(i+1,l):
            if is_palindrome(s[i:j+1]):
                x += 1
                end[j]+=1
        total += x*y
        y += end[i]
    print total

def palin(s,l):
    start = [1]*l
    end = [1]*l
    for i in xrange(l):
        find_palin(s, l, i-1, i+1, start, end)
        find_palin(s, l, i, i+1, start, end)
    total,y = 0,0
    for i in xrange(l):
        total += start[i]*y
        y += end[i]
    print total

def find_palin(s, l, left, right, start, end):
    while(left>=0 and right<l and s[left]==s[right]):
        start[left]+=1
        end[right]+=1
        left-=1
        right+=1
    
def solve():
    s = raw_input().strip()
    l = len(s)
#    l = 100
#    s = 'a'*l
    palin(s, l)

solve()
#####################
## method to solve ##
#####################
# find the various palindromes starting from a particular index, i
# and ending at a later index, j for all i <= n-1 where n is
# the number of elements
#
# This is a classic implementation of greedy algorithm or dynamic
# implementation since you should find all the palindromic substrings
# of all the lengths only once. Something like what is done in palin
# instead of palin2.
