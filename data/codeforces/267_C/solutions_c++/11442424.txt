#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
using namespace std;
const double eps=1e-10;
const int SIZEN=110,SIZEM=5010;
void Gauss_Jordan(double A[SIZEN][SIZEN],double b[SIZEN],int N){
	for(int j=1;j<=N;j++){
		int r=j;
		for(int i=j+1;i<=N;i++){
			if(fabs(A[i][j])>fabs(A[r][j])) r=i;
		}
		for(int k=1;k<=N+1;k++) swap(A[r][k],A[j][k]);
		if(fabs(A[j][j])<eps) continue;
		for(int i=1;i<=N;i++){
			if(i==j) continue;
			double t=A[i][j]/A[j][j];
			for(int k=1;k<=N+1;k++){
				A[i][k]-=A[j][k]*t;
			}
		}
	}
	for(int i=1;i<=N;i++) b[i]=A[i][N+1]/A[i][i];
}
int N,M;
double A[SIZEN][SIZEN]={0};
int u[SIZEM],v[SIZEM],w[SIZEM];
double pot[SIZEN]={0};
double traffic[SIZEM];
int ufs[SIZEN]={0};
int grand(int x){
	return !ufs[x]?x:ufs[x]=grand(ufs[x]);
}
void merge(int x,int y){
	int gx=grand(x),gy=grand(y);
	if(gx!=gy) ufs[gx]=gy;
}
void work(void){
	A[1][1]=A[N][N]=1;
	A[1][N+1]=1;A[N][N+1]=0;
	for(int i=1;i<=M;i++){
		merge(u[i],v[i]);
		if(u[i]!=1&&u[i]!=N) A[u[i]][u[i]]++,A[u[i]][v[i]]--;
		if(v[i]!=1&&v[i]!=N) A[v[i]][u[i]]--,A[v[i]][v[i]]++;
	}
	if(grand(1)!=grand(N)){
		for(int i=1;i<=M+1;i++) printf("%.9lf\n",0);
		return;
	}
	Gauss_Jordan(A,pot,N);
	double magnify=1e18;
	for(int i=1;i<=M;i++){
		magnify=min(magnify,fabs(w[i]/(pot[u[i]]-pot[v[i]])));
	}
	double ans=0;
	for(int i=1;i<=M;i++){
		traffic[i]=(pot[u[i]]-pot[v[i]])*magnify;
		if(u[i]==1) ans+=traffic[i];
		if(v[i]==1) ans-=traffic[i];
	}
	printf("%.9lf\n",ans);
	for(int i=1;i<=M;i++) printf("%.9lf\n",traffic[i]);
}
void read(void){
	scanf("%d%d",&N,&M);
	for(int i=1;i<=M;i++)
		scanf("%d%d%d",&u[i],&v[i],&w[i]);
}
int main(){
	//freopen("t1.in","r",stdin);
	read();
	work();
	return 0;
}
