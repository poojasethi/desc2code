#include <fstream>
#include <iostream>
using namespace std;

#define F cin
#define G cout

//ifstream F("p.in");
//ofstream G("p.out");

const int N = 55;
const int mod = 1000000007;

int n,m;
long long c[N][N],f[N][N],g[N][N];

int main()
{
    F>>n>>m;

    c[0][0] = 1;
    for (int i = 1; i <= n; c[i][0] = 1, i++)
        for (int j = 1; j <= n; j++)
            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;

    f[1][0] = 0;
    f[0][0] = 1;
    g[1][0] = g[0][0] = 1;

    for (int i = 2; i <= n; i++)
    {
        for (int j = 0; j <= n; j++)
        {
            for (int left = 1; left <= i - 1; left++)
            { // aleg nodurile din primul subarbore si radacina arborilor si radacina sub drept celuilalt
                long long mul = c[i - 2][left - 1] * (left) * max(1, (i - 1 - left)) % mod;
                for (int kleft = 0; kleft <= j - 1; kleft++)
                {
                    long long addA = g[left][kleft] * (i - 1 - left > 0 ? g[i - 1 - left][j - 1 - kleft]
                                    + f[i - 1 - left][j - 1 - kleft] : j - 1 - kleft == 0 ? 1 : 0) % mod;
                    long long addB = ((i - 1 - left) > 0 ? g[i - 1 - left][j - 1 - kleft] * f[left][kleft] : 0) % mod;
                    f[i][j] = (f[i][j] + mul * (addA + addB) % mod) % mod;
                }
                for (int kleft = 0; kleft <= j; kleft++)
                    g[i][j] = (g[i][j] + mul * f[left][kleft] % mod * f[i - 1 - left][j - kleft]) % mod;
            }
        }
    }
    G<<(f[n][m]+g[n][m])%mod<<'\n';
}
