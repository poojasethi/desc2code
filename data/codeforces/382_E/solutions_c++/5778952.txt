#include <cstdio>
#include <iostream>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <functional>
#include <limits>
#include <cassert>
#include <sstream>
#include <cmath>
#include <string>
#include <fstream>

using namespace std;
typedef long long ll;

const int max_n=55;
const ll mod=1000000007ll;

int n,k;
ll dp[max_n][max_n][2],C[max_n][max_n];
bool B[max_n][max_n][2];

ll rec(int N, int K, int p)
{
	if(N==1)
		return K==0?(p==0?1:0):0;
	if(N==0)
		return K==0?(p==1?1:0):0;
	if(B[N][K][p])
		return dp[N][K][p];
	B[N][K][p]=1;

	ll ret=0;
	if(p==0)
	{
		for(int n1=N/2; n1<N; n1++)
		{
			int n2=N-1-n1;
			ll w=(n2==n1)?C[N-2][n1-1]:C[N-1][n1];
			w*=(ll)(n1>0?n1:1)*(ll)(n2>0?n2:1);
			w%=mod;
			for(int k1=0; k1<=K; k1++)
				ret+=(((w*rec(n1,k1,1))%mod)*rec(N-n1-1,K-k1,1))%mod,ret%=mod;
		}
	}
	else
	{
		for(int n1=N/2; n1<N; n1++)
		{	
			int n2=N-1-n1;
			ll w=(n2==n1)?C[N-2][n1-1]:C[N-1][n1];
			w*=(ll)(n1>0?n1:1)*(ll)(n2>0?n2:1);
			w%=mod;
			for(int k1=0; k1<K; k1++)
				ret+=(w*(((rec(n1,k1,0)*rec(N-n1-1,K-k1-1,1))%mod+(rec(n1,k1,0)*rec(N-n1-1,K-k1-1,0))%mod+(rec(n1,k1,1)*rec(N-n1-1,K-k1-1,0))%mod )%mod))%mod,ret%=mod;
		}
	}
	return dp[N][K][p]=ret;
}

int main()
{

	for(int i=0; i<max_n; i++)
	{
		C[i][0]=1ll;
		C[i][i]=1ll;
		for(int j=1; j<i; j++)
			C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
	}

    scanf("%d%d",&n,&k);
    
    cout<<(rec(n,k,0)+rec(n,k,1))%mod<<"\n";

    return 0;
}
 	