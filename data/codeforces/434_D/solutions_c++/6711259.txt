#include <cstdio>
#include <cstring>
#include <algorithm>
#define FOR(i,s,e) for (int i=(s); i<(e); i++)
#define FOE(i,s,e) for (int i=(s); i<=(e); i++)
#define FOD(i,s,e) for (int i=(s)-1; i>=(e); i--)
#define CLR(a,x) memset(a, x, sizeof(a))
#define EXP(i,l) for (int i=(l); i; i=qn[i])
#define N 12000
#define M 110000
using namespace std;

const int INF = (1 << 29), BIG = 350000, MX = 101;

struct maxFlow{
	int S, T, V, ed;
	int g[N], l[N], v[N], qd[M], qc[M], qn[M];

	void bd(int x, int y, int w){
		qd[++ed] = y;
		qc[ed] = w;
		qn[ed] = l[x];
		l[x] = ed;
		if (ed % 2 == 0) bd(y, x, 0);
	}
	int ISAP(int x, int y){
		int mn = V - 1, F = 0, R = y, t;
		if (x == T) return y;
		for (int i=l[x]; i; i=qn[i]){
			if (qc[i] > 0){
				if (v[x] == v[qd[i]]+1){
					t = ISAP(qd[i], min(qc[i], R));
					qc[i] -= t;
					qc[i^1] += t;
					R -= t;
					F += t;
					if (v[S] >= V) return F;
					if (!R) break;
				}
				mn = min(mn, v[qd[i]]);
			}
		}
		if (!F){
			g[v[x]]--;
			if (!g[v[x]]) v[S] = V;
			v[x] = mn+1;
			g[v[x]]++;
		}
		return F;
	}
	int Flow(){
		memset(v, 0, sizeof(v));
		memset(g, 0, sizeof(g));
		int ret = 0;
		g[0] = V;
		while (v[S] < V) ret += ISAP(S, INF);
		return ret;
	}
};

int n, m;
int ca[55], cb[55], cc[55], lo[55], hi[55];
maxFlow S;

int label(int x, int y){
	return x * 204 + (y + 101) + 2;
}

int main(){
	scanf("%d%d", &n, &m);
	FOR(i,0,n) scanf("%d%d%d", &ca[i], &cb[i], &cc[i]);
	S.S = 0, S.T = 1, S.V = 2 + n * 204;
	S.ed = 1;
	
	FOR(i,0,n){
		scanf("%d%d", &lo[i], &hi[i]);
		FOE(j,-MX,MX){
			int x = label(i, j);
			if (j >= lo[i] && j <= hi[i]){
				S.bd(x, x + 1, BIG - (ca[i] * j * j + cb[i] * j + cc[i]));
			}
			else S.bd(x, x + 1, INF);
		}
		S.bd(S.S, label(i, -MX), INF);
		S.bd(label(i, MX) + 1, S.T, INF);
	}

	while (m--){
		int x, y, d, j;
		scanf("%d%d%d", &x, &y, &d), --x, --y;
		FOE(i,-MX,MX){
			j = i - d;
			if (abs(j) <= MX) S.bd(label(x, i) + 1, label(y, j) + 1, INF);
		}
	}

	printf("%d\n", n * BIG - S.Flow());
	return 0;
}
