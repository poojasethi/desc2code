#include <bits/stdc++.h>

#define MAX_N 10100
#define MAX_E 2222222
struct Edge {int v, x, cap;} E[MAX_E];
int l[MAX_N], tot;
const int inf = 1e9 + 7;
void add_edge(int u, int v, int cap) {
	E[tot].v = v; E[tot].cap = cap; E[tot].x = l[u]; l[u] = tot ++;
	E[tot].v = u; E[tot].cap =   0; E[tot].x = l[v]; l[v] = tot ++;
}
int d[MAX_N], queue[MAX_N];
bool bfs(int src, int sink) {
	int s = 0, t = 0;
	memset(d, -1, sizeof d);
	d[src] = 0;
	queue[t ++] = src;
	while(s < t) {
		int u = queue[s ++];
		for(int i = l[u]; ~i; i = E[i].x) {
			int v = E[i].v;
			if(d[v] == -1 && E[i].cap) {
				d[queue[t ++] = v] = d[u] + 1;
			}
		}
	}
	return d[sink] != -1;
}
int dfs(int u, int in, int sink) {
	if(u == sink)	return in;
	int flow = 0, f;
	for(int i = l[u]; ~i && flow < in; i = E[i].x) {
		int v = E[i].v;
		if(d[v] == d[u] + 1 && E[i].cap) {
			if(f = dfs(v, std::min(E[i].cap, in - flow), sink)) {
				E[i].cap -= f;
				E[i^1].cap += f;
				flow += f;
			}
		}
	}
	if(flow < in)	d[u] = -1;
	return flow;
}
int Dinic(int src, int sink) {
	int flow = 0;
	while(bfs(src, sink))
			flow += dfs(src, inf, sink);
	return flow;
}

int a[50], b[50], c[50], down[50], up[50];
#define pair(x, y) std::make_pair(x, y)
#define MAX_V 10000000
typedef std::pair<int, int> P;
std::map<P, int> id;
int calc(int i, int x) {
	return a[i]*x*x + b[i]*x + c[i];
}
int main() {
	int N, M, u, v, d, n = 0;
	int src, sink;
	std::memset(l, -1, sizeof l);
	tot = 0;

	scanf("%d%d", &N, &M);
	for(int i = 0; i < N; i ++) 
		scanf("%d%d%d", &a[i], &b[i], &c[i]);
	for(int i = 0; i < N; i ++) {
		scanf("%d%d", &down[i], &up[i]);
		for(int x = down[i] - 1; x <= up[i]; x ++) {
			id[pair(i, x)] = ++ n;
		}
	}
	src = ++ n;
	sink = ++ n;
	for(int i = 0; i < N; i ++) {
		for(int x = down[i] - 1; x < up[i]; x ++) {
			u = id[pair(i, x)];
			add_edge(u, u + 1, MAX_V - calc(i, x + 1));
		}
		add_edge(src, id[pair(i, down[i] - 1)], inf);
		add_edge(id[pair(i, up[i])], sink, inf);
	}
	for(int i = 0; i < M; i ++) {
		scanf("%d%d%d", &u, &v, &d);
		u --, v --;
		for(int x = down[u] - 1; x < up[u]; x ++) {
			if(!id.count(pair(v, x - d)))	continue;
			add_edge(id[pair(u, x)], id[pair(v, x - d)], inf);
		}
	}
	int ans = MAX_V * N - Dinic(src, sink);
	printf("%d\n", ans);
	return 0;
}
		


