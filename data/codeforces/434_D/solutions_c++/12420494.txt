#include <bits/stdc++.h>
#define M 200000
using namespace std;
#define MX 1234567
#define MN 55
int n, m;
#define INF 123456789
struct Edge {
    int en, cap;
    Edge(int en = 0, int cap = 0) : en(en), cap(cap) {}
}edge[MX];
int l[MN], r[MN], a[MN], b[MN], c[MN], first[MN], last[MN];
int head[12345], next[MX], num;
int S, T, C;
 
void add_edge(int st, int en, int cap) {
    edge[num] = Edge(en, cap);
    next[num] = head[st];
    head[st] = num++;
    edge[num] = Edge(st, 0);
    next[num] = head[en];
    head[en] = num++;
}
int calc(int i, int j) {
    return a[i] * j * j + b[i] * j + c[i];
}
int prev[12345], Q[12345];
void Flow() {
    int i;
    int res = 0;
    while (true) {
        int hd(0), tl(0);
        for (i = 0; i <= T; i++) prev[i] = -1;
        Q[tl++] = S;
        prev[S] = -2;
        while (hd < tl) {
            int id = Q[hd++];
            for (i = head[id]; ~i; i = next[i]) {
                if (edge[i].cap > 0) {
                    int en = edge[i].en;
                    if (prev[en] == -1) {
                        prev[en] = 1 ^ i;
                        Q[tl++] = en;
                    }
                }
            }
        }
        if (prev[T] == -1) break;
        for (i = head[T]; ~i; i = next[i]) {
            int amt = INF;
            if (prev[edge[i].en] == -1) continue;
            int j = i;
            for (; j >= 0; ) {
                amt = min(amt, edge[1 ^ j].cap);
                if (amt == 0) break;
                j = prev[edge[j].en];
            }
            if (amt == 0) continue;
            res += amt;
            j = i;
            for (; j >= 0;) {
                edge[1 ^ j].cap -= amt;
                edge[j].cap += amt;
                j = prev[edge[j].en];
            }
        }
    }
    printf("%d\n", n * M - res);
}
int main() {
    int i, u, v, w, j, k;
    memset(head, -1, sizeof head);
    scanf("%d%d", &n, &m);
    S = 0;
    for (i = 0; i < n; i++) scanf("%d%d%d", a + i, b + i, c + i);
    C = 1;
    for (i = 0; i < n; i++) {
        scanf("%d%d", l + i, r + i);
        first[i] = C;
        int prev = S;
        for (j = l[i]; j <= r[i]; j++) {
            add_edge(prev, C, M - calc(i, j));
            prev = C++;
        }
        last[i] = C;
    }
    T = C;
    for (i = 0; i < n; i++) {
        int tmp = last[i] - 1;
        add_edge(tmp, T, INF);
    }
    for (i = 0; i < m; i++) {
        scanf("%d%d%d", &u, &v, &w);
        u--, v--;
        for (j = l[u]; j <= r[u]; j++) {
            int x = first[u] + j - l[u] - 1;
            if (j == l[u]) x = S;
            int tmp = j - w - 1;
            if (tmp >= l[v] && tmp <= r[v]) {
                k = tmp - l[v] + first[v];
                add_edge(x, k, INF);
            }
        }
    }
    Flow();
    return 0;
} 

 		 	 			    		 		 	  		  	   	