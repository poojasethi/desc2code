#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>

using namespace std;

#define node(a,b) (b-l[a]+start[a])

const int maxn=50*201+10;
const int maxm=(60*210+100)*2;
const int INF=0x3f3f3f3f;

int n,m,en,q[maxn],depth[maxn],l[60],r[60],start[60],A[60],B[60],C[60],s,t;

struct edge
{
	int e,f;
	edge *next,*op;
}*v[maxn],ed[maxm];

void add_edge(int s,int e,int f)
{
	en++;
	ed[en].next=v[s];v[s]=ed+en;v[s]->e=e;v[s]->f=f;
	en++;
	ed[en].next=v[e];v[e]=ed+en;v[e]->e=s;v[e]->f=0;
	v[s]->op=v[e];v[e]->op=v[s];
}

bool bfs()
{
	int front=1,tail=1;
	q[1]=s;
	memset(depth,0,sizeof(depth));
	depth[s]=1;
	for (;front<=tail;)
	{
		int now=q[front++];
		for (edge *e=v[now];e;e=e->next)
			if (e->f && !depth[e->e])
			{
				depth[e->e]=depth[now]+1;
				if (e->e==t) return true;
				q[++tail]=e->e;
			}
	}
	return false;
}

int dfs(int now,int cur_flow)
{
	if (now==t) return cur_flow;
	int rest=cur_flow;
	for (edge *e=v[now];e && rest;e=e->next)
		if (e->f && depth[e->e]==depth[now]+1)
		{
			int new_flow=dfs(e->e,min(e->f,rest));
			e->f-=new_flow;
			e->op->f+=new_flow;
			rest-=new_flow;
		}
	if (rest==cur_flow) depth[now]=-1;
	return cur_flow-rest;
}

int dinic()
{
	int ans=0;
	while (bfs())
		ans+=dfs(s,INF);
	return ans;
}

int f(int x,int y)
{
	return y*y*A[x]+y*B[x]+C[x];
}

int main()
{
	scanf("%d%d",&n, &m);
	for (int a=1;a<=n;a++)
		scanf("%d%d%d",&A[a],&B[a],&C[a]);
	int maxv=-INF;
	int tot=0;
	for (int a=1;a<=n;a++)
	{
		scanf("%d%d",&l[a],&r[a]);
		start[a]=tot+1;
		tot+=r[a]-l[a]+2;
		for (int b=l[a];b<=r[a];b++)
			maxv=max(maxv,f(a,b));
	}
maxv++;
	s=0;t=tot+1;
	for (int a=1;a<=n;a++)
	{
		add_edge(s,start[a],INF);
		for (int b=l[a];b<=r[a];b++)
			add_edge(node(a,b),node(a,b+1),maxv-f(a,b));
		add_edge(node(a,r[a]+1),t,INF);
	}
	for (int a=1;a<=m;a++)
	{
		int s,e,d;
		scanf("%d%d%d",&s,&e,&d);
		for (int b=l[s];b<=r[s];b++)
			if (b-d>=l[e] && b-d<=r[e]+1) add_edge(node(s,b),node(e,b-d),INF);
	}
	printf("%d\n",maxv*n-dinic());

	return 0;
}
  		 	  			   			 	   		 	   	