#include<bits/stdc++.h>

#define rep(i,n) for(int i=0;i<(int)n;i++)
#define all(c) (c).begin(),(c).end()
#define mp make_pair
#define pb push_back
#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)
#define dbg(x) cerr<<__LINE__<<": "<<#x<<" = "<<(x)<<endl

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pi;
const ll inf = 1e12;
const double INF = 1e12, EPS = 1e-9;

struct flowGraph{
	struct edge{ ll to, cap, rev; };
	
	ll n, *level, *iter;
	vector<vector<edge> > G;
	
	flowGraph(ll sz) : n(sz){
		G.resize(n);
		iter = new ll[n]; level = new ll[n];
	}
	~flowGraph(){
		delete iter; delete level;
	}
	
	void add(ll s, ll t, ll cap){
		G[s].pb((edge){t, cap, G[t].size()});
		G[t].pb((edge){s, 0, G[s].size() - 1});
	}
	void bfs(ll s){
		rep(i, n) level[i] = -1;
		queue<ll> q;
		level[s] = 0;
		q.push(s);
		while(!q.empty()){	
			ll v = q.front();
			q.pop();
			rep(i, G[v].size()){
				edge &e = G[v][i];
				if(e.cap > 0 && level[e.to] < 0){
					level[e.to] = level[v] + 1;
					q.push(e.to);
				}
			}
		}
	}
	ll dfs(ll v, ll t, ll f){
		if(v == t) return f;
		for(ll &i = iter[v]; i < (ll)G[v].size(); i++){
			edge &e = G[v][i];
			if(e.cap > 0 && level[v] < level[e.to]){
				ll d = dfs(e.to, t, min(f, e.cap));
				if(d > 0){
					e.cap -= d;
					G[e.to][e.rev].cap += d;
					return d;
				}
			}
		}
		return 0;
	}
	ll max_flow(ll s, ll t){
		ll flow = 0;
		while(1){
			bfs(s);
			if(level[t] < 0) return flow;
			rep(i, n) iter[i] = 0;
			ll f;
			while((f = dfs(s, t, inf)) > 0) flow += f;
		}
	}
};

int n, m;
int a[50], b[50], c[50];
int l[50], r[50];

int f(int i, int x){
	return a[i] * x * x + b[i] * x + c[i];
}

int main(){
	
	cin >> n >> m;
	
	const ll BIG = 1000000;
	int s = 0, t;
	int base[60] = {};
	
	rep(i, n) cin >> a[i] >> b[i] >> c[i];
	rep(i, n){
		cin >> l[i] >> r[i];
		base[i] = s;
		s += r[i] - l[i] + 2;
	}
	t = s + 1;
	
	flowGraph g(t + 1);
	rep(i, n){
		g.add(s, base[i], inf);
		int k = base[i];
		rep(j, r[i] - l[i] + 1) g.add(k, k + 1, BIG - f(i, l[i] + j)), k++;
		g.add(k, t, inf);
	}
	rep(i, m){
		int u, v, d;
		cin >> u >> v >> d; u--; v--;
		for(int j = l[u] - 1; j <= r[u]; j++){
			
			if(j - d >= l[v] - 1 && j - d <= r[v])
			g.add(j - l[u] + 1 + base[u], j - d - l[v] + 1 + base[v], inf);
		}
	}
	cout << n * BIG - g.max_flow(s, t) << endl;
	
	return 0;
}
