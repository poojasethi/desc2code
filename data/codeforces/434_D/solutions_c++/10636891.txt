#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<ctime>
#include<vector>
#define rep(i,l,r) for(int i=l;i<=r;i++)
#define drep(i,r,l)for(int i=r;i>=l;i--)
using namespace std;
const int N=11111;
const int inf=10000000;
struct Edge {
    int b,c,nxt;
}e[999999];
int p[N];
int th;
int pre[N],dis[N],gap[N],cur[N];
int sap(int s, int t,int n) {
    int i,v,u;
    int c,aug=-1,maxflow=0;
    for(i=0;i<=n;i++) cur[i]=p[i];
    memset(dis,0,sizeof(dis));
    memset(gap,0,sizeof(gap));
    u=pre[s]=s,
    gap[0]=n;
    while(dis[s]<n) {
loop:
        for(int &ee=cur[u];ee!=-1;ee=e[ee].nxt) {
            v=e[ee].b; c=e[ee].c;
            if(c>0&&dis[u]==dis[v]+1) {
                if(aug==-1||aug>c) aug=c;
                pre[v]=u;
                u=v;
                    if(v==t) {
                        maxflow+=aug;
                        for(u=pre[u];v!=s;v=u,u=pre[u])
                            e[ cur[u] ].c-=aug , e[ cur[u]^1 ].c+=aug;
                        aug=-1;
                    }
                    goto loop;
            }
        }
        int mindis=n;
        for(i=p[u];i!=-1;i=e[i].nxt) {
            v=e[i].b;
            if(e[i].c>0&&mindis>dis[v])
                cur[u]=i , mindis=dis[v];
        }
        if((--gap[dis[u]])==0) break;
        gap[dis[u]=mindis+1]++;
        u=pre[u];
    }
    return maxflow;
}

void addedge(int a,int b,int c) {
    e[th].b=b; e[th].c=c; e[th].nxt=p[a]; p[a]=th++;
    e[th].b=a; e[th].c=0; e[th].nxt=p[b]; p[b]=th++;
}
void init() {
    memset(p,-1,sizeof(p));
    th=0;
}
int n,m;
int a[55],b[55],c[55],l[55],r[55],d;
int pos[55];
int find(int x,int y){
	return y*y*a[x]+y*b[x]+c[x];
}
int main(){
	int S=0,T=0;
	init();
	cin>>n>>m;
	rep(i,1,n)cin>>a[i]>>b[i]>>c[i];
	rep(i,1,n)cin>>l[i]>>r[i];
	rep(i,1,n){
	pos[i]=++d;
	rep(j,l[i],r[i])addedge(d,d+1,300000-find(i,j)),d++;
	}
	S=d+1,T=S+1;
	int a,b,c;
	while(m--){
		cin>>a>>b>>c;
		//ka-c<=kb
		for(int i=l[a];i<=r[a];i++){
			int j=i-c;
			if(j<=l[b])continue;
			if(j>r[b])addedge(pos[a]+i-l[a],T,inf);
			else addedge(pos[a]+i-l[a],pos[b]+j-l[b],inf);
		}
	}

	for(int i=1;i<=n;i++)addedge(S,pos[i],inf),addedge(pos[i]+r[i]-l[i]+1,T,inf);
	cout<<n*300000-sap(S,T,T)<<endl;
	return 0;
}

	 			 			    				  			 			 	  	