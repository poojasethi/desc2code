#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
#include<queue>
#include<set>
#define SF scanf
#define PF printf
#define ls (i<<1)
#define rs ((i<<1)|1)
#define sqr(x) ((LL)(x)*(x))
using namespace std;
typedef long long LL;
const int MAXN = 50;
const int BIG = 4000000;
const int INF = 0x3f3f3f3f;
template <int maxn, int maxm>
struct ISAP {
	struct Node {
		int v, c, next;
	} Edge[maxm*2+10];	
	int adj[maxn+10], ecnt;
	int gap[maxn+10], d[maxn+10];
	int n, m, s, t;
	void addedge(int u, int v, int c) {
		Node &e = Edge[ecnt];
		e.v = v; e.c = c; e.next = adj[u]; adj[u] = ecnt++;
	}
	void add(int u, int v, int c) {
		addedge(u, v, c); addedge(v, u, 0);
	}
	void init() {
		memset(adj, -1, sizeof(adj));
		ecnt = 0;
	}
	void init_dis() {
		memset(d, -1, sizeof(d));
		memset(gap, 0, sizeof(gap));
		queue <int> q;
		d[t] = 0; q.push(t);
		while(!q.empty()) {
			int u = q.front(); q.pop();
			n++;
			gap[d[u]]++;
			for(int i = adj[u]; ~i; i = Edge[i].next) {
				int v = Edge[i].v;
				if(d[v] == -1) d[v] = d[u]+1, q.push(v);
			}
		}
	}
	int aug(int u, int inc) {
		int Inc = 0, mindis = n-1;
		if(u == t) return inc;
		for(int i = adj[u]; ~i; i = Edge[i].next) {
			int v = Edge[i].v, c = Edge[i].c;
			if(c) {
				if(d[v] == d[u] - 1) {
					int del = min(c, inc-Inc);
					del = aug(v, del);
					Inc += del;
					Edge[i].c -= del;
					Edge[i^1].c += del;
					if(inc == Inc) return Inc;
					if(d[s] >= n) return Inc;
				}
				mindis = min(mindis, d[v]);
			}
		}
		if(!Inc) {
			gap[d[u]]--;
			if(gap[d[u]] == 0) d[s] = n;
			d[u] = mindis+1;
			gap[d[u]]++;
		}
		return Inc;
	}
	int Maxflow(int _s, int _t) {
		s = _s; t = _t; n = 0;
		int Flow = 0;
		init_dis();
		while(d[s] < n) Flow += aug(s, INF);
		return Flow;
	}
};

ISAP <20000, 2000000> sap;
int a[MAXN+10], b[MAXN+10], c[MAXN+10], l[MAXN+10], r[MAXN+10];
int n, m, S, T;
int f(int i, int x) {
	return a[i] * x * x + b[i] * x + c[i];
}
inline int idx(int x, int num) {
	if(T && num < l[x]) 
		return S;
	return (x-1) * (300) + num + 101;
}
int main() {
	sap.init();
	SF("%d%d", &n, &m);
	S = idx(n+1, -100); T = idx(n+1, -99);
	for(int i = 1; i <= n; i++) SF("%d%d%d", &a[i], &b[i], &c[i]);
	for(int i = 1; i <= n; i++) SF("%d%d", &l[i], &r[i]);
	for(int i = 1; i <= n; i++) {
		sap.add(S, idx(i, l[i]), BIG-f(i, l[i]));
		sap.add(idx(i, r[i]), T, INF);
		for(int j = l[i]+1; j <= r[i]; j++)
			sap.add(idx(i, j-1), idx(i, j), BIG-f(i, j));
	}
	for(int i = 1; i <= m; i++) {
		int u, v, d;
		SF("%d%d%d", &u, &v, &d);
		for(int j = l[u]; j <= r[u]+1; j++) {
			int t = j-d-1;
			if(l[v] <= t && t <= r[v])
				sap.add(idx(u, j-1), idx(v, t), INF);
		}
	}
	int ans = sap.Maxflow(S, T);
	PF("%d\n", -ans+BIG*n);
}
	  				    	   			  			 	 					