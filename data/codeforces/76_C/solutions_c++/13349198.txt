#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

using namespace std;

#define FOREACH(i, c) for(__typeof( (c).begin() ) i = (c).begin(); i != (c).end(); ++i)
#define FOR(i, a, n) for(__typeof(n) i = (a); i<(n); ++i)
#define REP(i, a, n) for(__typeof(n) i = (a); i<=(n); ++i)
#define ROF(i, n, a) for(__typeof(n) i = (n); i>=(a); --i)
#define error(n) cout << #n << " = " << n << endl
#define all(c) c.begin(), c.end()
#define pb push_back
#define po pop_back
#define Size(n) ((int)(n).size())
#define X first
#define Y second
#define scanf _ = scanf
// #define X real()
// #define Y imag()

typedef long long   ll ;
typedef long double ld ;
typedef pair<int,int> pii ;

const int maxn = 200 * 1000;
const int maxmask = (1<<22);
const int maxk = 22;

int n, k;
ll T;
string s;

ll dp[maxmask]; // dp[mask] -> if we remove mask characters from the initial string

ll removeCost[maxk];
ll adjacentCost[maxk][maxk];
//
int leftestItem[maxk];

void addItem(int mask , int leftChar , int rightChar) {
    ll cost = adjacentCost[leftChar][rightChar];
//     cerr << mask << " : " << leftChar << ", " << rightChar << " , + " << cost << endl;
    if (leftChar != rightChar) {
        dp[mask] += cost;
        dp[mask^(1<<leftChar)] -= cost;
        dp[mask^(1<<rightChar)] -= cost;
        dp[mask^(1<<leftChar)^(1<<rightChar)] += cost;
    } else {
        dp[mask] -= cost;
        dp[mask^(1<<leftChar)] += cost;
    }
}

void addInitialCosts() {
    FOR (i,0,k)
        leftestItem[i] = n;
    ROF (i,n-1,0) {
//         cerr << string(20,'-') << " " << i << endl;
        int currentChar = s[i]-'A';
        //--> compute
        vector <pii> p;
        FOR (j,0,k) {
            if (leftestItem[j] < n) {
                p.pb(pii(leftestItem[j],j));
            }
        }
        sort(all(p));
        int mask = (1<<currentChar);
        FOR (lv,0,Size(p)) {
            mask |= (1<<(p[lv].Y));
            addItem(mask,currentChar,p[lv].Y);
            if (p[lv].Y == currentChar) {
                break;
            }
        }
        //--> update
        leftestItem[currentChar] = i;
    }
}

void computeDynamicIteratively() {
    FOR (i,0,k) {
        FOR (mask,0,(1<<k)) {
            if (mask&(1<<i)) {
                dp[mask] += dp[mask^(1<<i)];
            }
        }
    }
}

void addRemoveCosts() {
    FOR (mask,0,(1<<k)) {
//         cerr << " before addRemove : dp[" << mask << "] = " << dp[mask] << endl;
        FOR (i,0,k) {
            if ( ((mask&(1<<i)) != 0) && (leftestItem[i] != n)) {
                dp[mask] += removeCost[i];
            }
        }
    }
}

bool OK(int mask) {
    FOR (i,0,k) {
        if (((mask&(1<<i)) == 0) && (leftestItem[i] == n)) {
            return false;
        }
    }
    return true;
}

void printFisibleAnswer() {
    int ans = 0;
    FOR (mask,0,(1<<k)-1) {
//         cerr << mask << ": " << dp[mask] << endl;
        if (dp[mask] <= T && OK(mask)) {
            ++ans;
        }
    }
    cout << ans << endl;
}

int main() {
    // reading input
    ios_base::sync_with_stdio(false);
    cin >> n >> k >> T >> s;
    
    FOR (i,0,k)
        cin >> removeCost[i];
    FOR (i,0,k) 
        FOR (j,0,k) {
            cin >> adjacentCost[i][j];
        }
    // 
    addInitialCosts();
//     cerr << string(80,'-') << endl;

    computeDynamicIteratively();
    
    addRemoveCosts();

    printFisibleAnswer();
    return 0 ;
}
