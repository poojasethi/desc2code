#include <bits/stdc++.h>
using namespace std;


const int MAXN = 1005;
const int MAXM = 30005;
int n;
int a[MAXM];
int b[MAXM];
int c[MAXM];

vector<int> g[MAXN];
bool br[MAXM]; 
bool used[MAXN];
int timer, tin[MAXN], fup[MAXN];

int TO(int from, int i)
{
	if (a[i] == from)
		return b[i];
	else
		return a[i];
}

int s, t;

void dfs (int v, int p = -1) {
	used[v] = true;
	tin[v] = fup[v] = timer++;
	for (size_t i=0; i<g[v].size(); ++i) {
		int to = TO(v, g[v][i]);
		if (to == p) {
			continue;
		} 
		if (used[to])
		{
			fup[v] = min (fup[v], tin[to]);
		}
		else {
			dfs (to, v);
			fup[v] = min (fup[v], fup[to]);
			if (fup[to] > tin[v])
				br[g[v][i]] = true;
		}
	}
}

int comp[MAXN];
int comps;
void dfs2(int i, int c)
{
	if (comp[i] != -1)
		return;
	comp[i] = c;
	for (int j = 0; j < g[i].size(); j++)
		if (!br[g[i][j]])
			dfs2(TO(i, g[i][j]), c);
}
vector<int> tr[MAXN]; 
void convertToTree() {
	timer = 0;
	memset(br, 0, sizeof(br));
	for (int i=0; i<n; ++i)
	{
		used[i] = false;
		tr[i].clear();
	}
	for (int i=0; i<n; ++i)
		if (!used[i])
			dfs (i);
	memset(comp, -1, sizeof(comp));
	comps = 0;
	for (int i=0; i<n; ++i)
		if (comp[i] == -1)
			dfs2(i, comps++);
	for (int i = 0; i < n; i++)
	{
		for (int j = 0; j < g[i].size(); j++)
		{
			int to = TO(i, g[i][j]);
			if (comp[i] != comp[to])
			{
				tr[comp[i]].push_back(g[i][j]);
			}
		}
	}
}

bool tk[MAXN];

int dfs3(int i, int p)
{
	if (i == comp[t])
		return -1;
	int inf = -2;
	for (int j = 0; j < tr[i].size(); j++)
	{
		int to;
		if (i == comp[a[tr[i][j]]])
			to = comp[b[tr[i][j]]];
		else
			to = comp[a[tr[i][j]]];
		if (to == p)
			continue;
		else
		{
			int res = dfs3(to, i);
			if (res > inf)
			{
				if (res == -1 || c[tr[i][j]] < c[res])
					return tr[i][j];
				else
					return res;
			}
		}
	}
	return inf;
}

vector<int> og[MAXN];
int bestVal;
int cnt;
int bi, bj;
void check(int x)
{
	for (int i = 0; i < n; i++)
	{
		g[i].clear();
		for (int j = 0; j < og[i].size(); j++)
		{
			if (og[i][j] == x)
				continue;
			g[i].push_back(og[i][j]);
		}
	}
	convertToTree();
	if (comp[s] == comp[t])
		return;
	memset(tk, 0, sizeof(tk));
	int res = dfs3(comp[s], -1);
	if (res < -1)
	{
		if (c[x] < bestVal)
		{
			bestVal = c[x];
			bi = x;
			bj = -1;
			cnt = 1;
		}
		return;
	}
	if (c[x] + c[res] < bestVal)
	{
		bestVal = c[x] + c[res];
		bi = x;
		bj = res;
		cnt = 2;
	}
}

int p[MAXN];

void solve()
{
	queue<int> q;
	q.push(s);
	memset(p, -1, sizeof(p));
	p[s] = s;
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		for (int j = 0; j < og[u].size(); j++)
		{
			int to = TO(u, og[u][j]);
			if (p[to] == -1)
			{
				p[to] = og[u][j];
				q.push(to);
			}
		}
	}
	if (p[t] == -1)
	{
		bestVal = 0;
		cnt = 0;
		return;
	}
	bestVal = 2000000005;
	int cur = t;
	while (cur != s)
	{
		check(p[cur]);
		cur = TO(cur, p[cur]);
	}
}

int main()
{
	int m;
	scanf("%d %d", &n, &m);
	scanf("%d %d", &s, &t);
	s--;
	t--;
	for (int i = 0; i < m; i++)
	{
		scanf("%d %d %d", a+i, b+i, c+i);
		a[i]--;
		b[i]--;
		og[a[i]].push_back(i);
		og[b[i]].push_back(i);
	}
	solve();
	if (bestVal > 2000000000)
	{
		printf("-1\n");
		return 0;
	}
	printf("%d\n", bestVal);
	printf("%d\n", cnt);
	if (cnt == 1)
		printf("%d\n", bi + 1);
	else if (cnt == 2)
		printf("%d %d\n", bi + 1, bj + 1);
}