#include <cstdio>
#include <cstring>
#include <vector>
#include <utility>
#include <algorithm>
using namespace std;

const int MAXN = 1005, MAXM = 30005;
const int NOT_CONNECTED = -1;
const long long INFTY = 2000000001LL;
int N, M, S, T;
struct edge{
	edge() {}
	edge(int endId, int weight, int edgeId):
		endId(endId), weight(weight), edgeId(edgeId) {}
	int endId, weight, edgeId;
};
vector<edge> e[MAXN], pathToRoot;
edge fatherEdge[MAXN];
int DFN[MAXN], low[MAXN], cnt;
int bannedEdgeId = 0;

void DFS(int x, int prevEdgeId) {
	low[x] = DFN[x] = ++cnt;
	for (int i = 0; i < e[x].size(); ++i) {
		if (prevEdgeId == e[x][i].edgeId)
			fatherEdge[x] = e[x][i];
		else if (bannedEdgeId != e[x][i].edgeId) {
			int v = e[x][i].endId;
			if (DFN[v] > 0)
				low[x] = min(low[x], DFN[v]);
			else {
				DFS(v, e[x][i].edgeId);
				low[x] = min(low[x], low[v]);
			}
		}
	}
}

pair<int, int> findBridge() { // (edgeId, weight)
	cnt = 0;
	memset(DFN, 0, sizeof(DFN));
	DFS(S, 0);
	if (0 == DFN[T]) return make_pair(NOT_CONNECTED, 0);
	int minWeight = INFTY, x = T, edgeId = 0;
	while (x != S) {
		if (low[x] > DFN[fatherEdge[x].endId] && fatherEdge[x].weight < minWeight)
			minWeight = fatherEdge[x].weight, edgeId = fatherEdge[x].edgeId;
		x = fatherEdge[x].endId;
	}
	return make_pair(edgeId, minWeight);
}

int main() {
	int x, y, w, ans[3];
	long long minBudget = INFTY;
	scanf("%d%d%d%d", &N, &M, &S, &T);
	for (int i = 1; i <= M; ++i) {
		scanf("%d%d%d", &x, &y, &w);
		e[x].push_back(edge(y, w, i));
		e[y].push_back(edge(x, w, i));
	}
	pair<int, int> result = findBridge();
	if (result.first == NOT_CONNECTED)
		printf("0\n0\n");
	else {
		x = T;
		while (x != S)
			pathToRoot.push_back(fatherEdge[x]), x = fatherEdge[x].endId;
		x = T;
		for (int i = 0; i < pathToRoot.size(); ++i) {
			int father = pathToRoot[i].endId;
			bannedEdgeId = pathToRoot[i].edgeId;
			long long firstEdgeWeight = pathToRoot[i].weight;
			result = findBridge();
			if (NOT_CONNECTED == result.first) {
				if (firstEdgeWeight < minBudget) {
					minBudget = firstEdgeWeight;
					ans[0] = 1;
					ans[1] = bannedEdgeId;
				}
			}
			else {
				if (firstEdgeWeight + result.second < minBudget) {
					minBudget = firstEdgeWeight + result.second;
					ans[0] = 2;
					ans[1] = bannedEdgeId;
					ans[2] = result.first;
				}
			}
			x = father;
		}
		if (INFTY == minBudget)
			printf("-1\n");
		else {
			printf("%d\n%d\n", (int)minBudget, ans[0]);
			for (int i = 1; i <= ans[0]; ++i)
				printf("%d%c", ans[i], i == ans[0] ? '\n' : ' ');
		}
	}
	return 0;
}
