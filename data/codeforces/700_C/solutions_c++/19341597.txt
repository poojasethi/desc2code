#include<bits/stdc++.h>
#define rep(i,n) for(int i=0;i<n;i++)
#define pb push_back
#define mp make_pair
#define X first
#define Y second
#define pi acos(-1.0)
#define MIN(x,y) (x)<(y)?(x):(y)

using namespace std;

typedef vector<int> vi;
typedef pair<int,int> pii;
typedef long long LL;
typedef double flt;

const int N=1003;
const int M=30033;
const LL INF=20000000010;

struct Edge
{
	int u,v,cst;
}e[M];

vector<pii> g[N];
LL ans=INF;
vi erase;
int n,m,S,T,clk;
int dfn[N],low[N],id[N],cst[N],parent[N],treeid[N];
int dst[N],q[N];
bool on[N],treeedge[M],vis[N];

inline void BFS()
{
	memset(dst,-1,sizeof(dst));
	int fnt,rar;
	fnt=rar=0;
	q[rar++]=S;
	while(fnt<rar)
	{
		int u=q[fnt++];
		rep(i,(int)g[u].size())
		{
			int v=g[u][i].X;
			if(dst[v]<0)
			{
				dst[v]=dst[u]+1;
				q[rar++]=v;
			}
		}
	}
	return;
}

inline void build_tree(int u=S,int par=-1,int _=-1)
{
	vis[u]=1;
	treeid[u]=_;
	rep(i,(int)g[u].size())
	{
		int v=g[u][i].X;
		if(!vis[v])
			build_tree(v,u,g[u][i].Y);
	}
	return;
}

inline void dfs(int u=S,int par=-1,int _=-1)
{
	parent[u]=par;
	id[u]=_;
	dfn[u]=low[u]=++clk;
	bool FUCK=0;
	rep(i,(int)g[u].size())
	{
		int v=g[u][i].X;
		if(v!=par || v==par && FUCK)
		{
			if(!low[v])
				dfs(v,u,g[u][i].Y);
			low[u]=MIN(low[u],low[v]);
		}
		else if(v==par)
			FUCK=1;
	}
	return;
}

int main()
{
	scanf("%d%d",&n,&m);
	scanf("%d%d",&S,&T);
	S--;
	T--;
	rep(i,m)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		x--;
		y--;
		e[i].u=x;
		e[i].v=y;
		e[i].cst=z;
		g[x].pb(mp(y,i));
		g[y].pb(mp(x,i));
	}
	BFS();
	if(dst[T]<0)
	{
		puts("0");
		puts("0");
		return 0;
	}
	build_tree();
	rep(i,n)
		if(i!=S)
			treeedge[treeid[i]]=1;
	rep(i,m)
	{
		if(!treeedge[i])
			continue;
		int u=e[i].u,v=e[i].v;
		LL cur=(LL)e[i].cst;
		bool fuck=0;
		vector<pii> tmpu,tmpv,_tgu,_tgv;
		vi curese;
		curese.clear();
		curese.pb(i);
		tmpu.clear();
		tmpv.clear();
		rep(j,(int)g[u].size())
			if(g[u][j].Y!=i)
				tmpu.pb(g[u][j]);
		rep(j,(int)g[v].size())
			if(g[v][j].Y!=i)
				tmpv.pb(g[v][j]);
		_tgu=g[u];
		_tgv=g[v];
		g[u]=tmpu;
		g[v]=tmpv;
		BFS();
		if(dst[T]>=0)
		{
			memset(on,0,sizeof(on));
			memset(dfn,0,sizeof(dfn));
			memset(low,0,sizeof(low));
			clk=0;
			int tmp;
			LL mini=INF;
			dfs();
			int U=T;
			while(U!=S)
			{
				on[U]=1;
				U=parent[U];
			}
			rep(j,n)
				if(on[j] && (LL)e[id[j]].cst<mini && low[j]>=dfn[j])
				{
					mini=(LL)e[id[j]].cst;
					tmp=id[j];
					fuck=1;
				}
			if(fuck)
			{
				cur+=mini;
				curese.pb(tmp);
			}
		}
		else
			fuck=1;
		if(fuck)
		{
			if(cur<ans)
			{
				ans=cur;
				erase=curese;
			}
		}
		g[u]=_tgu;
		g[v]=_tgv;
	}
	if(ans==INF)
	{
		puts("-1");
		return 0;
		
	}
	printf("%d\n",ans);
	printf("%d\n",(int)erase.size());
	rep(i,(int)erase.size())
		printf("%d%c",erase[i]+1,i==(int)erase.size()-1?'\n':' ');
	return 0;
}
