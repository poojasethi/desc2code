#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<climits>
#include<utility>
#include<vector>
using namespace std;

const int MaxN=1005;
const int MaxM=30005*2;

struct Edge{
    int to,next,va;
	}edge[MaxM];

int head[MaxN],tot=0;
int Low[MaxN],DFN[MaxN];
int visit[MaxN]={0},bridge[MaxM]={0};
int Index=0;
int n,m,s,t,a,b,c;

void addedge(int u,int v,int c){
    edge[tot].to=v;edge[tot].next=head[u];edge[tot].va=c;
    head[u]=tot++;
	}

bool dfs(int u,int pa,int del,vector<int> &path){
	visit[u]=1;
	if(u==t){
		return true;
		}
	for(int i=head[u];~i;i=edge[i].next){
		int v=edge[i].to;
		if(v==pa||(i>>1)==del){
			continue;
		}
		if(!visit[v]&&dfs(v,u,del,path)){
			path.push_back(i>>1);
			return true;
			}
		}
	return false;
	}

void Tarjan(int u,int pa,int del){
    DFN[u]=Low[u]=++Index;
    int flag=0;
    for(int i=head[u];i!=-1;i=edge[i].next){
        int v=edge[i].to;
        if((i>>1)==del) continue;
        if(v==pa&&!flag){
            flag=1;
            continue;
			}
        if(!DFN[v]){
            Tarjan(v,u,del);
            if(Low[u]>Low[v])Low[u]=Low[v];
            if(Low[v]>DFN[u]) bridge[i>>1]=1;
			}
        else Low[u]=min(DFN[v],Low[u]);
		}
	}

void init(){
	memset(DFN,0,sizeof(DFN));
	memset(visit,0,sizeof(visit));
	memset(bridge,0,sizeof(bridge));
	Index=0;
	}

int main(){
	memset(head,-1,sizeof(head));
	memset(visit,0,sizeof(visit));
	scanf("%d%d",&n,&m);
	scanf("%d%d",&s,&t);
	for(int i=0;i<m;i++){
		scanf("%d%d%d",&a,&b,&c);
		addedge(a,b,c);
		addedge(b,a,c);
		}
	vector<int> path;
	if(!dfs(s,-1,-1,path)){
		printf("0\n0\n");
		}
	else{
		int ans=2e9+5;
		vector<int> ret;
		for(int i=0;i<path.size();i++){
			init();
			for(int j=1;j<=n;j++){
				if(!DFN[j]){
					Tarjan(j,-1,path[i]);
					}
				}
			vector<int> tmp;
			if(!dfs(s,-1,path[i],tmp)){
				if(ans>edge[path[i]*2].va){
					ans=edge[path[i]*2].va;
					ret.clear();
					ret.push_back(path[i]+1);
					}
				}
			else{
				for(int j=0;j<tmp.size();j++){
					if(bridge[tmp[j]]){
                        if(ans>edge[path[i]*2].va+edge[tmp[j]*2].va){
                            ans=edge[path[i]*2].va+edge[tmp[j]*2].va;
                            ret.clear();
                            ret.push_back(path[i]+1);
                            ret.push_back(tmp[j]+1);
							}
						}
					}
				}
			}
		if(ans>2e9) cout<<-1<<endl;
		else{
			cout<<ans<<endl<<ret.size()<<endl;
			for(int i=0;i<ret.size();i++){
				printf("%d",ret[i]);
				if(i==ret.size()-1)
					cout<<endl;
				else
					cout<<" ";
				}
			}
		}
	}

   	 			  			 	 		   	 					  	