#include <map>
#include <set>
#include <stack>
#include <queue>
#include <cmath>
#include <ctime>
#include <string>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#pragma comment(linker,"/STACK:102400000,102400000")
using namespace std;

#define 	N 			100008 			
#define 	V 			1008
#define		E			60008	
#define		lson		l,m,rt<<1
#define 	rson		m,r+1,rt<<1|1
#define		clr(x,v)	memset(x,v,sizeof(x));
#define		LL			long long 

const int	mo	=	1000000007;
const int 	inf =	0x3f3f3f3f;
const int 	INF =	2000000008;
/**************************************************************************/ 

int n,m,S,T,tmp;
int vis[V],path[V],dfn[V],low[V],road[V],bridge[E];
int ans;
int ANS[V];
struct line{
	int u,v,w,nt;
}eg[E];
int sum,lt[V];


void adt(int u,int v,int w){
	eg[++sum]=(line){u,v,w,lt[u]};
	lt[u]=sum;
}
void add(int u,int v,int w){
	adt(u,v,w); adt(v,u,w);
}

bool dfs(int u){
	vis[u]=1;
	if (u==T) return true; 
	for (int i=lt[u];i;i=eg[i].nt){
		int v=eg[i].v;
		if (vis[v]) continue;
		if (dfs(v)){
			path[++path[0]]=i/2;
		//	printf("%d %d\n",path[0],i );
			return true;
		}
	}
	return false;
}

bool dfs_2(int u,int del){
	vis[u]=1;
	if (u==T) return true;
	for (int i=lt[u];i;i=eg[i].nt){
		int v=eg[i].v;
		if (i/2==del) continue;
		if (vis[v]) continue;
		if (dfs_2(v,del)){
			road[++road[0]]=i/2;
			return true;
		}
	}
	return false;
}
void tarjan(int u,int fa,int del){
	dfn[u]=low[u]=++tmp;
	int flag=0;
	for (int i=lt[u];i;i=eg[i].nt){
		int v=eg[i].v;
		if (i/2==del) continue;
		if (v==fa && !flag){
			flag=1;
			continue;
		}
		if (!dfn[v]){
			tarjan(v,u,del);
			low[u]=min(low[u],low[v]);
			if (dfn[u]<low[v]) bridge[i/2]=1;
		}
		else low[u]=min(low[u],dfn[v]);
	}
}

int main(){
	scanf("%d %d",&n,&m);
	scanf("%d %d",&S,&T);
	sum=1;
	for (int i=1;i<=m;i++){
		int u,v,w;
		scanf("%d %d %d",&u,&v,&w);
		add(u,v,w);
	}

	clr(vis,0); 
	clr(path,0);
	if (!dfs(S)) { printf("0\n0\n"); return 0; }
	else
	{	
		ans=INF;
		for (int ii=1;ii<=path[0];ii++){
			clr(bridge,0);
			clr(vis,0);
			clr(road,0);
			clr(dfn,0);
			tmp=0; 			
			for (int i=1;i<=n;i++)
				if (!dfn[i])
					tarjan(i,0,path[ii]);
			if (!dfs_2(S,path[ii])){
				if (eg[path[ii]*2].w<ans){
					ans = eg[path[ii]*2].w;
					ANS[0]=1;
					ANS[1]=path[ii];
				}
			}
			else
			{
				for (int i=1;i<=road[0];i++){
					if (bridge[road[i]]){
						if (eg[road[i]*2].w+eg[path[ii]*2].w<ans){
							ans=eg[road[i]*2].w+eg[path[ii]*2].w;
							ANS[0]=2;
							ANS[1]=road[i];
							ANS[2]=path[ii];
						}
					}
				}
			}
		}
		if (ans==INF) printf("-1\n");
		else
		{
			printf("%d\n%d\n",ans,ANS[0]);
			for (int i=1;i<=ANS[0];i++) printf("%d%c",ANS[i],i!=ANS[0]?' ':'\n');
		}
	}	
}



