#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<vector>
#include<string>
#define N 10005
#define INF (1LL << 61)
using namespace std;
typedef long long LL;
LL a,b,c,d,e,f,g,h,i,j,k;
struct node
{
    LL v,w;
    LL next;
};
node GG[N << 1];
LL end[N << 1];
LL tot;

LL L[N];
LL X[N];
LL E[10];

LL D[3][N];
LL que[N << 2],l,r;
bool v[N];

LL F[N];

void Add_Edge(LL u,LL v,LL w)
{
    GG[++tot].v = v;GG[tot].w = w;
    GG[tot].next = end[u];end[u] = tot;
}

void Spfa(LL source,LL DD[])
{
    LL ii,jj,kk;
    for(ii = 1; ii <= a; ii ++) DD[ii] = INF;
    DD[source] = 0;
    que[1] = source;
    v[source] = true;
    l = 0; r = 1;
    while(l < r)
    {
        l ++;
        jj = end[que[l]];
        while(jj)
        {
            if(DD[que[l]] + GG[jj].w < DD[GG[jj].v])
            {
                DD[GG[jj].v] = DD[que[l]] + GG[jj].w;
                if(v[GG[jj].v] == false)
                {
                    que[++r] = GG[jj].v;
                    v[GG[jj].v] = true;
                }
            }
            jj = GG[jj].next;
        }
        v[que[l]] = false;
    }
}
void Work()
{
    Spfa(E[1], D[1]);
    Spfa(E[2], D[2]);
}
void Get()
{
    LL ii,jj,kk;
    bool hav;
    while(true)
    {
        hav = false;
        for(ii = 1; ii <= k; ii ++)
        if(D[1][X[ii]] < D[2][X[ii]] && F[ii] != L[ii])
        {
            hav = true;
            GG[b + ii].w = L[ii];
            F[ii] = L[ii];
        }
        Work();
        if(hav == false) break;
    }
    string an;
    if(D[1][E[0]] < D[2][E[0]]) an = "WIN";
    else if(D[1][E[0]] == D[2][E[0]]) an = "DRAW";
    else an = "LOSE";
    cout << an << endl;
    if(an != "LOSE")
    {
        for(ii = 1; ii <= k ;ii ++)
            cout << F[ii] << " ";
        cout << endl;       
    } 
}

int main()
{
    cin >> a >> b >> k;
    cin >> E[1] >> E[2] >> E[0];
    for(i = 1; i <= b; i ++)
    {
        cin >> c >> d >> e;
        Add_Edge(c, d, e);
    }
    for(i = 1; i <= k; i ++)
    {
        cin >> c >> d >> L[i] >> e;
        Add_Edge(c, d, e);
        X[i] = c;
        F[i] = e;
    }
    Work();
    Get();
    return 0;
}