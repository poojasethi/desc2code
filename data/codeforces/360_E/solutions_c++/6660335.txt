#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
struct node{
	int u;long long d;
	node(){}
	node(int u,long long d):u(u),d(d){}
	bool operator<(const node&rhs)const{
		return d>rhs.d;
	}
};
priority_queue<node>Q;
struct edge{
	edge*n;
	int v,l,r,id;
	edge(){}
	edge(edge*n,int v,int l,int r,int id):n(n),v(v),l(l),r(r),id(id){}
}E[100000],*etp=E,*G[100000];
void addedge(int u,int v,int l,int r,int id){
	*etp=edge(G[u],v,l,r,id);G[u]=etp++;
}
int n,m,k,S1,S2,T,ans[100000],state[100000];
long long dis[100000];
int main(){
	scanf("%d%d%d%d%d%d",&n,&m,&k,&S1,&S2,&T);
	for(int a,b,c;m--;)
		scanf("%d%d%d",&a,&b,&c),addedge(a,b,c,c,0);
	for(int i=1,a,b,c,d;i<=k;i++)
		scanf("%d%d%d%d",&a,&b,&c,&d),addedge(a,b,c,d,i),ans[i]=c;
	for(int i=1;i<=n;i++)dis[i]=1e18;
	for(state[S1]|=1,state[S2]|=2,dis[S1]=dis[S2]=0,Q.push(node(S1,0)),Q.push(node(S2,0));!Q.empty();){
		int u=Q.top().u;
		long long d=Q.top().d;
		Q.pop();
		if(d==dis[u]){
			int turn=(state[u]&2),w;
			for(edge*e=G[u];e;e=e->n){
				if(turn)ans[e->id]=e->r;
				else ans[e->id]=e->l;
				w=ans[e->id];
				if(dis[e->v]>dis[u]+w){
					state[e->v]=state[u];
					dis[e->v]=dis[u]+w;
					Q.push(node(e->v,dis[e->v]));
				}else if(dis[e->v]==dis[u]+w)state[e->v]|=state[u];
			}
		}
	}if(state[T]==2)return puts("LOSE"),0;
	else if(state[T]==1)puts("WIN");
	else puts("DRAW");
	for(int i=1;i<k;i++)printf("%d ",ans[i]);
	printf("%d\n",ans[k]);
}
