#include<cstdio>
#include<algorithm>
#include<map>
#include<set>
#include<cstring>
#define rep(i,l,r) for (int i=l; i<=r; ++i)
#define dep(i,r,l) for (int i=r; i>=l; --i)
#define foredge(u) for (int j=eq[u],v; v=ee[j].v,j; j=ee[j].nx)
#define mkp make_pair
#define CLR(ar) memset(ar,0,sizeof(ar))
#define good(i) (d1[i]<d2[i] || (d1[i]==d2[i]&&draw))
using namespace std;

typedef long long i64;
typedef pair<i64,int> PLI;

const int N=11010;

int n,m,k,s1,s2,f,ans[N];
i64 d1[N],d2[N];

struct edge{
	int v,nx,w,dc,id;
} ee[N];
int eq[N],en;

set<PLI> S;
bool done[N];

void link(int u,int v,int w,int z,int id){
	ee[++en]=(edge){v,eq[u],w,z,id},eq[u]=en;
}
void dijkstra(int s,i64 *dis){
	rep(i,1,n) dis[i]=1e18;
	S.clear();
	S.insert(mkp(dis[s]=0,s));
	CLR(done);
	while (!S.empty()){
		int u=S.begin()->second; S.erase(S.begin());
		if (done[u]) continue;
		done[u]=1;
		foredge(u) if (dis[u]+ee[j].w<dis[v]){
			dis[v]=dis[u]+ee[j].w;
			S.insert(mkp(dis[v],v));
		}
	}
}
bool solve(bool draw){
	int cnt=0;
	while(!good(f)){
		dijkstra(s1,d1);
		dijkstra(s2,d2);
		int cur=0;
		rep(i,1,n) cur+=good(i);
		if (cur==cnt) break;
		cnt=cur;

		rep(u,1,n) if (good(u))
			foredge(u) if (ee[j].dc){
				ee[j].w-=ee[j].dc;
				ee[j].dc=0;
				ans[ee[j].id]=ee[j].w;
			}
	}
	return good(f);
}
int main(){
	scanf("%d%d%d",&n,&m,&k);
	scanf("%d%d%d",&s1,&s2,&f);
	rep(i,1,m){
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		link(u,v,w,0,0);
	}
	rep(i,1,k){
		int u,v,wl,wr;
		scanf("%d%d%d%d",&u,&v,&wl,&wr);
		link(u,v,wr,wr-wl,i),ans[i]=wr;
	}

	if (!solve(0)) solve(1);

	if (d1[f]>d2[f]) printf("LOSE\n");
	else{
		printf("%s\n",d1[f]==d2[f]?"DRAW":"WIN");
		rep(i,1,k) printf("%d ",ans[i]);
	}
}
