#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<fstream>
#include<map>
#include<ctime>
#include<set>
#include<queue>
#include<cmath>
#include<vector>
#include<bitset>
#include<functional>
#define x first
#define y second
#define mp make_pair
#define pb push_back
#define REP(i,l,r) for((i)=(l);(i)<=(r);++(i))
#define REP2(i,l,r) for((i)=(l);(i)!=(r);++(i))
using namespace std;

typedef long long LL;
typedef double ld;

const int MAX=20000+10;
const LL INF=1e15;
int n,m,k;
int S1,S2,T;

struct Edge
{
	int t,next;
	int l,r,flag;
}e[MAX];
int begin[MAX],nume;

void add(int a,int b,int c,int d)
{
	++nume;
	e[nume].t=b;
	e[nume].next=begin[a];
	begin[a]=nume;
	e[nume].l=c;
	e[nume].r=d;
	e[nume].flag=0;
}

int hash[MAX],come[MAX],comeE[MAX];
LL dist[MAX],dist2[MAX];

void bellman_ford(int S,int flag,LL* dist)
{
	int i;
	queue<int> q;
	REP(i,1,n)
	{
		dist[i]=INF;
		hash[i]=0;
	}
	dist[S]=0;
	q.push(S);
	hash[S]=1;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		hash[u]=0;
		if(flag && dist2[u]<dist[u])
			continue;
		if(flag==1 && dist2[u]==dist[u])//这是检查是否能胜利的
			continue;
		for(i=begin[u];i;i=e[i].next)
		{
			int v=e[i].t,w;
			if(!flag)
				w=e[i].r;
			else
				w=e[i].l;
			if(dist[v]>dist[u]+w)
			{
				dist[v]=dist[u]+w;
				if(flag)
				{
					come[v]=u;
					comeE[v]=i;
				}
				if(!hash[v])
				{
					hash[v]=1;
					q.push(v);
				}
			}
		}
	}
}

int main()
{
#ifndef ONLINE_JUDGE
	freopen("input.txt","r",stdin);freopen("output.txt","w",stdout);
#endif
	int i;
	scanf("%d%d%d",&n,&m,&k);
	scanf("%d%d%d",&S1,&S2,&T);
	REP(i,1,m)
	{
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		add(a,b,c,c);
	}
	REP(i,1,k)
	{
		int a,b,c,d;
		scanf("%d%d%d%d",&a,&b,&c,&d);
		add(a,b,c,d);
	}
	bellman_ford(S2,0,dist2);
	bellman_ford(S1,2,dist);
	if(dist[T]>dist2[T])
		cout<<"LOSE"<<endl;
	else
	{
		bellman_ford(S1,1,dist);
		if(dist[T]<dist2[T])
			cout<<"WIN"<<endl;
		else
		{
			bellman_ford(S1,2,dist);
			cout<<"DRAW"<<endl;
		}
		int P=T;
		while(P!=S1)
		{
			e[comeE[P]].flag=1;
			P=come[P];
		}
		REP(i,m+1,m+k)
			cout<<(e[i].flag?e[i].l:e[i].r)<<" ";
		cout<<endl;
	}
	return 0;
}
