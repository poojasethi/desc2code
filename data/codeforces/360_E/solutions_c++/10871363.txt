#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
typedef long long LL;
template<class T> inline bool ten(T &x,const T &y){return y<x?(x=y,1):0;}
template<class T> inline bool rel(T &x,const T &y){return x<y?(x=y,1):0;}
const int maxn=10005;
int n,m,k,S1,S2,F;
int cur[maxn],U[maxn],V[maxn],L[maxn],R[maxn];
LL d1[maxn],d2[maxn];

int head[maxn],adj[maxn*2],c[maxn*2],next[maxn*2],tot;

struct state
{
	int id;
	LL dis;
	state(const int &_id=0,const LL &_dis=0):id(_id),dis(_dis){}
	bool operator<(const state &o)const
	{return dis>o.dis;}
};
inline int addedge(int u,int v,int w)
{return tot++,adj[tot]=v,c[tot]=w,next[tot]=head[u],head[u]=tot,tot;}

void init()
{
	scanf("%d%d%d",&n,&m,&k);
	scanf("%d%d%d",&S1,&S2,&F);
	for(int i=1,u,v,w;i<=m;i++)
		scanf("%d%d%d",&u,&v,&w),addedge(u,v,w);
	for(int i=1;i<=k;i++)
		scanf("%d%d%d%d",U+i,V+i,L+i,R+i),cur[i]=addedge(U[i],V[i],R[i]);
}

void dijkstra(int S,LL *d)
{
	priority_queue<state> Q;
	memset(d,31,n+1<<3);
	d[S]=0;
	Q.push(state(S,0));
	LL t;
	for(int u,v,i;!Q.empty();)
	{
		u=Q.top().id,t=Q.top().dis,Q.pop();
		if(d[u]==t)
			for(i=head[u];i;i=next[i])
				if(ten(d[v=adj[i]],t+c[i]))
					Q.push(state(v,d[v]));
	}
}

bool work()
{
	dijkstra(S1,d1);
	dijkstra(S2,d2);
	bool flag=0;
	for(int i=1;i<=k;i++)
		if(d1[U[i]]<d2[U[i]]&&c[cur[i]]>L[i])c[cur[i]]=L[i],flag=1;
	return flag;
}

int main()
{
	init();
	while(work());
	if(d1[F]>d2[F])puts("LOSE");
	else
	{
		puts(d1[F]<d2[F]?"WIN":"DRAW");
		for(int i=1;i<=k;i++)
			printf("%d%c",c[cur[i]]," \n"[i==k]);
	}
	return 0;
}
