// File Name: 107E.cpp
// Author: YangYue
// Created Time: Tue Oct  8 19:07:18 2013
//headers 
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <ctime>
#include <string>
#include <queue>
#include <set>
#include <map>
#include <iostream>
#include <vector>

using namespace std;

typedef long long LL;
typedef unsigned long long ULL;
typedef pair<int,int> PII;
typedef pair<double,double> PDD;
typedef pair<LL, LL>PLL;
typedef pair<LL,int>PLI;

#define lch(n) ((n<<1))
#define rch(n) ((n<<1)+1)
#define lowbit(i) (i&-i)
#define sqr(x) ((x)*(x))
#define fi first
#define se second
#define MP make_pair
#define PB push_back

const int MaxN = 5005;
const double eps = 1e-8;
const double DINF = 1e100;
const int INF = 1000000006;
const LL LINF = 1000000000000000005ll;

int dcmp(double x) { return x < -eps ? -1 : x > eps; }
struct Point {
    double x, y;
    Point(){}
    Point(double x, double y) : x(x), y(y) {}
    Point operator + (const Point &b) { return Point(x+b.x,y+b.y); }
    Point operator - (const Point &b) { return Point(x-b.x,y-b.y); }
    Point operator * (const double &b) { return Point(x*b,y*b); }
    Point operator / (const double &b) { return Point(x/b,y/b); }
    double operator * (const Point &b) { return x * b.y - y * b.x; }
    double operator % (const Point &b) { return x * b.x + y * b.y; }
    double len() { return sqrt(x * x + y * y); }
    double len2() { return x * x + y * y; }
    void init() { scanf("%lf%lf", &x, &y); }
    bool operator == (const Point &b) const { return dcmp(x-b.x) == 0 && dcmp(y-b.y) == 0; }
    bool operator < (const Point &b) const { if (dcmp(x-b.x) != 0) return dcmp(x-b.x) < 0; return dcmp(y-b.y) < 0; }
};
struct Rect {
    Point p[5];
    void init() {
        for (int i = 0; i < 4; ++i) p[i].init();
        if (dcmp((p[1]-p[0]) * (p[3]-p[0])) < 0) reverse(p, p + 4);
        p[4] = p[0];
    }
    Point& operator [](const int &i) { return p[i]; }
} rect[MaxN];
double xmul(Point a, Point b, Point c) { return (b-a)*(c-a); }

int n;
pair<double, int> keys[MaxN];
double get(Point a, Point b, Point c) {
    double t;
    if (fabs(a.x-b.x) > eps) t = (c.x-a.x)/(b.x-a.x);
    else t = (c.y-a.y)/(b.y-a.y);
    t = max(min(t,1.0),0.0);
    return t;
}
double solve() {
    double res = 0;
    for (int i = 0; i < n; ++i)
    for (int x = 0; x < 4; ++x) {
        int keysize = 0;
        for (int k = 0; k < n; ++k) if (k != i)
        for (int y = 0; y < 4; ++y) {
            int t1 = dcmp(xmul(rect[i][x], rect[i][x+1], rect[k][y]));
            int t2 = dcmp(xmul(rect[i][x], rect[i][x+1], rect[k][y+1]));
            if (!t1 && !t2) {
                if (k < i && dcmp((rect[k][y+1]-rect[k][y])%(rect[i][x+1]-rect[i][x])) >= 0) {
                    double d1 = get(rect[i][x], rect[i][x+1], rect[k][y]);
                    double d2 = get(rect[i][x], rect[i][x+1], rect[k][y+1]);
                    keys[keysize++] = make_pair(d1, 1);
                    keys[keysize++] = make_pair(d2, -1);
                }
            } else if ((t1 >= 0 && t2 < 0) || (t1 < 0 && t2 >= 0)) {
                double d1 = xmul(rect[k][y], rect[k][y+1], rect[i][x]);
                double d2 = xmul(rect[k][y], rect[k][y+1], rect[i][x+1]);
                int t = 1; if (t2 >= 0) t = -1;
                keys[keysize++] = make_pair(max(min(d1/(d1-d2),1.),0.), t);
            }
        }
        sort(keys, keys + keysize);
        int cnt = 0;
        double s = 0, tmp = 0;
        bool f = 1;
        for (int j = 0; j < keysize; ++j) {
            cnt += keys[j].second;
            if (!cnt && !f) tmp = keys[j].first, f = 1;
            if (cnt && f) s += keys[j].first - tmp, f = 0;
        }
        s += 1. - tmp;
        res += (rect[i][x] * rect[i][x+1]) * s;
    }
    return res * 0.5;
}
int main()
{
  //  freopen("in","r",stdin);

    scanf("%d", &n);

    double res = 0;
    for (int i = 0; i < n; ++i) {
        rect[i].init();
        res += fabs((rect[i].p[2]-rect[i].p[1])*(rect[i].p[1]-rect[i].p[0]));
    }
    printf("%.10f\n", res / solve());

    return 0;
}

// hehe ~

