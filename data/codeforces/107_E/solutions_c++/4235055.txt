#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
#define mk(x,y) make_pair(x,y)
typedef double db;
const db eps = 1e-8;
const int N = 505;
int sign(db x){return (x>eps)-(x<-eps);}
int n;
struct P{
    db x,y;
    P(db a = 0.,db b = 0.):x(a),y(b){}
    P operator+(const P& a)const{return P(x+a.x,y+a.y);}
    P operator-(const P& a)const{return P(x-a.x,y-a.y);}
    db operator*(const P& a)const{return x*a.x+y*a.y;}
    db operator^(const P& a)const{return x*a.y-y*a.x;}
    db cross(P a,P b){return (a-*this)^(b-*this);}
    db radio(P p,P b){
        if(sign(b.x-x)) return (p.x-x)/(b.x-x);
        return (p.y-y)/(b.y-y);
    }
    void in(){scanf("%lf%lf",&x,&y);}
};
struct PLOY{
    int pnt;
    P ch[6];
    bool anti(){
        int dr = sign(ch[0].cross(ch[1],ch[2]));
        if(dr == 0) return false;
        if(dr < 0) reverse(ch,ch+pnt);
        ch[pnt] = ch[0];
        return true;
    }
    db S(){
        db s = 0.;
        for(int i = 0; i < pnt; i ++) s += ch[i]^ch[i+1];
        return fabs(s)*0.5;
    }
}pl[505];
pair<db ,int> pr[2005];//括号序列
db cover[505];
db get(){
    for(int i = 0; i < N; i ++) cover[i] = 0.;
    db s = 0.;
    int cnt = 0;
    for(int i = 0; i < n; i ++){
        for(int x = 0; x < pl[i].pnt; x ++){
            cnt = 0;
            pr[cnt++] = mk(0.,0);
            pr[cnt++] = mk(1.,0);
            for(int j = 0; j < n; j ++){
                for(int y = 0; y < pl[j].pnt; y ++){
                    int dr1 = sign(pl[i].ch[x].cross(pl[i].ch[x+1],pl[j].ch[y]));
                    int dr2 = sign(pl[i].ch[x].cross(pl[i].ch[x+1],pl[j].ch[y+1]));
                    if(dr1 == 0&& dr2 == 0){
                        if(i > j&&(pl[i].ch[x+1]-pl[i].ch[x])*(pl[j].ch[y+1]-pl[j].ch[y]) > 0.){
                            pr[cnt++] = mk(pl[i].ch[x].radio(pl[j].ch[y],pl[i].ch[x+1]),1);
                            pr[cnt++] = mk(pl[i].ch[x].radio(pl[j].ch[y+1],pl[i].ch[x+1]),-1);
                        }
                    }
                    else if(dr1 >= 0&&dr2 < 0){
                        db s1 = pl[j].ch[y+1].cross(pl[j].ch[y],pl[i].ch[x]);
                        db s2 = pl[j].ch[y+1].cross(pl[j].ch[y],pl[i].ch[x+1]);
                        pr[cnt++] = mk(s1/(s1-s2),1);
                    }
                    else if(dr2 >=0&&dr1 < 0){
                        db s1 = pl[j].ch[y].cross(pl[j].ch[y+1],pl[i].ch[x]);
                        db s2 = pl[j].ch[y].cross(pl[j].ch[y+1],pl[i].ch[x+1]);
                        pr[cnt++] = mk(s1/(s1-s2),-1);
                    }
                }
            }
            sort(pr,pr+cnt);
            db r = 0.,cur,last;
            int sum;
            sum = pr[0].second;
            last = min(max(pr[0].first,0.),1.);
            for(int k = 1; k < cnt; k ++){
                cur = min(max(pr[k].first,0.),1.);
                cover[sum] += (cur-last)*(pl[i].ch[x]^pl[i].ch[x+1]);
                sum += pr[k].second,last = cur;
            }
        }
    }
    return cover[0]*0.5;
}
int main()
{
    while(~scanf("%d",&n))
    {
        db ans = 0.;
        for(int i = 0; i < n; i ++){
            for(int j = 0; j < 4; j ++) pl[i].ch[j].in();
            pl[i].pnt = 4;
            if(!pl[i].anti()) continue;
            ans += pl[i].S();
        }
        printf("%.10f\n",ans/get());
    }

return 0;
}

	 					 	   				   	    	 	