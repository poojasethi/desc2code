#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <cstdio>

#define PI   3.14159265358979323846
#define PI_2 1.57079632679489661923
#define PI_4 0.78539816339744830962

#define eps 1e-6
#define DINF 1e200
using namespace std;
struct point
{
    double x,y;
    point(){}
    point(double _x,double _y){x=_x;y=_y;}
    void read()
    {
        scanf("%lf%lf",&x,&y);
    }
    void write()
    {
        printf("%lf %lf\n",x,y);
    }
};

bool dy(double x,double y)  {return x > y + eps;}          // x > y
bool xy(double x,double y)  {return x < y - eps;}          // x < y
bool dyd(double x,double y) {return x > y - eps;}          // x >= y
bool xyd(double x,double y) {return x < y + eps;}          // x <= y
bool dd(double x,double y)  {return fabs( x - y ) < eps;}  // x == y

inline int dblcmp(double x) //判断符号
{
    if(fabs(x) < eps)
        return 0;
    return x > 0 ? 1 : -1;
}

point operator + (const point& lhs, const point& rhs) { return point(lhs.x + rhs.x, lhs.y + rhs.y); }
point operator - (const point& lhs, const point& rhs) { return point(lhs.x - rhs.x, lhs.y - rhs.y); }
point operator * (const long double& lhs, const point& rhs) { return point(lhs*rhs.x, lhs*rhs.y); }
point operator * (const point& lhs, const long double& rhs) { return point(lhs.x*rhs, lhs.y*rhs); }
point operator / (const point& lhs, const double& rhs) { return point(lhs.x / rhs, lhs.y / rhs); }

double cross(point a,point b){
    return a.x*b.y-a.y*b.x;
}
double cross(point a,point b,point o){
    double x1=a.x-o.x,y1=a.y-o.y,x2=b.x-o.x,y2=b.y-o.y;
    return x1*y2-x2*y1;
}
double dis(point a,point b)
{
    return (sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y)));
}

double dot(point a,point b){
    return a.x*b.x+a.y*b.y;
}

double seg(point a,point b,point c){
    if(dblcmp(a.y-b.y)==0)return (c.x-a.x)/(b.x-a.x);
    else return (c.y-a.y)/(b.y-a.y);
}

int cmp(point a,point b)
{
    if(dd(a.x,b.x)) return a.y<b.y;
    return a.x<b.x;
}
#define PolN 1000
struct polygon{
    int n;
    point a[PolN];
    point& operator[](const int x){return a[x];}
    void read(){
        for(int i=0;i<n;++i)
            scanf("%lf%lf",&a[i].x,&a[i].y);
    }
    double area(){
        double sum=cross(a[n-1],a[0]);
        for(int i=0;i<n-1;++i)sum+=cross(a[i],a[i+1]);
        return sum/2;
    }
};

polygon po[2000];
point b[4010];
double polyunion(int n){
    double sum=0;
    for(int i=0;i<n;++i)po[i][po[i].n]=po[i][0];
    for(int i=0;i<n;++i)
        for(int ii=0;ii<po[i].n;++ii){
            int tot=0;
            b[tot++]=point(0.0,0);
            b[tot++]=point(1.0,0);
            for(int j=0;j<n;++j){
                if(i==j)continue;
                for(int jj=0;jj<po[j].n;++jj){
                    int aa,bb;
                    aa=dblcmp(cross(po[i][ii+1],po[j][jj],po[i][ii]));
                    bb=dblcmp(cross(po[i][ii+1],po[j][jj+1],po[i][ii]));
                    if(aa==0&&bb==0){
                        if(dot(po[i][ii+1]-po[i][ii],po[j][jj+1]-po[j][jj])>0&&j<i){
                            b[tot++]=point(seg(po[i][ii],po[i][ii+1],po[j][jj]),1);
                            b[tot++]=point(seg(po[i][ii],po[i][ii+1],po[j][jj+1]),-1);
                        }
                    }
                    else if(aa<0&&bb>=0){
                        double s1=cross(po[i][ii],po[j][jj+1],po[j][jj]),s2=s1+cross(po[j][jj+1],po[i][ii+1],po[j][jj]);
                        b[tot++]=point(s1/s2,-1);
                    }
                    else if(aa>=0&&bb<0){
                        double s1=cross(po[i][ii],po[j][jj+1],po[j][jj]),s2=s1+cross(po[j][jj+1],po[i][ii+1],po[j][jj]);
                        b[tot++]=point(s1/s2,1);
                    }
                }
            }
            sort(b,b+tot,cmp);
            double last,now,s=0,co;
            last=min(max(b[0].x,0.0),1.0);
            co=b[0].y;
            for(int j=1;j<tot;++j){
                now=min(max(b[j].x,0.0),1.0);
                if(!co)s+=now-last;
                co+=b[j].y;
                last=now;
            }
            sum+=cross(po[i][ii],po[i][ii+1])*s;
        }
    return sum/2;
}
int n;
double sum;
int main()
{
    scanf("%d",&n);
    sum=0;
    for(int i=0;i<n;i++)
    {
        po[i].n=4;
        po[i].read();
        double area=po[i].area();
        if(area<0)
        {
            for(int j=0,k=po[i].n-1;j<k;++j,--k)
                swap(po[i][j],po[i][k]);
            area=-area;
        }
        sum+=area;
    }
    printf("%.7lf\n",sum/polyunion(n));
    return 0;
}
