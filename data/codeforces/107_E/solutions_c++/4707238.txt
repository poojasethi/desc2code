#include<cstdio>
#include<algorithm>
#define pi pair<double,int>
#define mp make_pair
using namespace std;
const double eps=1e-10;
struct point{
    double x,y;
};
double cross(point a,point b);
double cross(point a,point b,point o);
struct polygon{
    int n;
    point a[5];
    point& operator[](const int x){return a[x];}
    void read(){
        for(int i=0;i<n;++i)
            scanf("%lf%lf",&a[i].x,&a[i].y);
    }
    double area(){
        double sum=cross(a[n-1],a[0]);
        for(int i=0;i<n-1;++i)sum+=cross(a[i],a[i+1]);
        return sum/2;
    }
}po[510];
point operator-(point a,point b){
    point px;px.x=b.x-a.x;px.y=b.y-a.y;
    return px;
}
double cross(point a,point b){
    return a.x*b.y-a.y*b.x;
}
double cross(point a,point b,point o){
    double x1=a.x-o.x,y1=a.y-o.y,x2=b.x-o.x,y2=b.y-o.y;
    return x1*y2-x2*y1;
}
double dot(point a,point b){
    return a.x*b.x+a.y*b.y;
}
int sign(double x){
    return x<-eps?-1:x>eps;
}
double seg(point a,point b,point c){
    if(sign(a.y-b.y)==0)return (c.x-a.x)/(b.x-a.x);
    else return (c.y-a.y)/(b.y-a.y);
}
pi b[4010];
double polyunion(int n){
    double sum=0;
    for(int i=0;i<n;++i)po[i][po[i].n]=po[i][0];
    for(int i=0;i<n;++i)
        for(int ii=0;ii<po[i].n;++ii){
            int tot=0;
            b[tot++]=mp(0.0,0);
            b[tot++]=mp(1.0,0);
            for(int j=0;j<n;++j){
                if(i==j)continue;
                for(int jj=0;jj<po[j].n;++jj){
                    int aa,bb;
                    aa=sign(cross(po[i][ii+1],po[j][jj],po[i][ii]));
                    bb=sign(cross(po[i][ii+1],po[j][jj+1],po[i][ii]));
                    if(aa==0&&bb==0){
                        if(dot(po[i][ii+1]-po[i][ii],po[j][jj+1]-po[j][jj])>0&&j<i){
                            b[tot++]=mp(seg(po[i][ii],po[i][ii+1],po[j][jj]),1);
                            b[tot++]=mp(seg(po[i][ii],po[i][ii+1],po[j][jj+1]),-1);
                        }
                    }
                    else if(aa<0&&bb>=0){
                        double s1=cross(po[i][ii],po[j][jj+1],po[j][jj]),s2=s1+cross(po[j][jj+1],po[i][ii+1],po[j][jj]);
                        b[tot++]=mp(s1/s2,-1);  
                    }
                    else if(aa>=0&&bb<0){
                        double s1=cross(po[i][ii],po[j][jj+1],po[j][jj]),s2=s1+cross(po[j][jj+1],po[i][ii+1],po[j][jj]);
                        b[tot++]=mp(s1/s2,1);
                    }
                }
            }
            sort(b,b+tot);
            double last,now,s=0,co;
            last=min(max(b[0].first,0.0),1.0);
            co=b[0].second;
            for(int j=1;j<tot;++j){
                now=min(max(b[j].first,0.0),1.0);
                if(!co)s+=now-last;
                co+=b[j].second;
                last=now;
            }
            sum+=cross(po[i][ii],po[i][ii+1])*s;
        }
    return sum/2;
}
int main(){
    double sum=0,ar;
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;++i){
        po[i].n=4;
        po[i].read();
        ar=po[i].area();
        if(ar<0){
            for(int j=0,k=po[i].n-1;j<k;++j,--k)
                swap(po[i][j],po[i][k]);
            ar=-ar;
        }
        sum+=ar;
    }
    printf("%.9lf\n",sum/polyunion(n));
    return 0;
}
  		  	   	      		 	     	