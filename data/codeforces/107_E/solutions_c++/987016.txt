# include<cstdio>
# include<cstring>
# include<cstdlib>
# include<iostream>
# include<cmath>
# include<algorithm>
using namespace std;
#define rep(i,l,r) for(int i=l;i<=r;i++)
#define drep(i,r,l) for(int i=r;i>=l;i--)
#define min(a,b) (a<b?a:b)
#define max(a,b) (a>b?a:b)
#define LL long long
#define sqr(x) ((x)*(x))
struct point
{
       double x , y;  
       point(){}
       point(double x1 , double y1){x = x1; y = y1;}
       inline double operator%(const point &a)const{ return x*a.y - y*a.x; }
       inline double operator*(const point &a)const{ return x*a.x + y*a.y; }
       inline point operator+(const point &a)const{ return point(x + a.x , y + a.y); }
       inline point operator-(const point &a)const{ return point(x - a.x , y - a.y); }
       inline point operator*(double k)const{ return point(x*k , y*k); }
       inline point operator/(double k)const{ return point(x/k , y/k); }
       inline double dis(){ return sqrt(x*x + y*y); }
}; 
double ans , sum;
int n , m , r;
struct PT
{
       point v[6];
       point& operator [](const int i){return v[i];}
}a[508];
struct arr
{
       double x ; int y;       
       arr(){}
       arr(double x1 , int y1){x = x1; y = y1;}
       inline bool operator < (const arr &i)const { return x < i.x; }
}c[2008];

inline double Area(PT &a)
{
       double sum = 0;
       rep(i,1,m) sum += a[i]%a[i+1];
       return sum;
}

inline void Init()
{
       scanf("%d" , &n);
       m = 4;
       rep(i,1,n) {
           rep(j,1,m)
             scanf("%lf%lf" , &a[i][j].x , &a[i][j].y);
           a[i][5] = a[i][1];
           double  s = Area(a[i]);         
           if (s < 0) {
              swap(a[i][2] , a[i][4]);
              s = -s;
           }
           sum += s;
       }
}

inline double Cross(point &a , point &b , point &c)
{
       return (b-a)%(c-a);
}
inline int Sg(double x)
{
       if (fabs(x) < 1e-6) return 0;
       return x > 0 ? 1 : -1;       
}
inline double Seg(point &a , point &b , point &c)
{
       double t;
       if (fabs(a.x - b.x) > 1e-6) t = (c.x - a.x)/(b.x - a.x);
       else t = (c.y - a.y)/(b.y - a.y);
       t = max(min(t,1.0),0.0); return t;
}

inline void Work()
{
       rep(i,1,n) 
       rep(j,1,m) {
            r = 0;
            rep(k,1,n) if (k != i)
              rep(l,1,m) {
                 int t1 = Sg(Cross(a[i][j],a[i][j+1],a[k][l]));
                 int t2 = Sg(Cross(a[i][j],a[i][j+1],a[k][l+1]));
                 if (t1 ==0 && t2==0) {
                   if (k < i && (a[k][l+1]-a[k][l])*(a[i][j+1]-a[i][j]) >= 0) {
                    double d1 = Seg(a[i][j],a[i][j+1],a[k][l]);
                    double d2 = Seg(a[i][j],a[i][j+1],a[k][l+1]);
                    c[++r] = arr(d1 , 1); c[++r] = arr(d2 , -1);
                 }
                 }else if (t1 >=0 && t2 < 0 || t1 < 0 && t2 >= 0) {
                      double d1 = Cross(a[k][l],a[k][l+1],a[i][j]);
                      double d2 = Cross(a[k][l],a[k][l+1],a[i][j+1]);
                      int t = 1; if (t2 >= 0) t = -1;
                      c[++r] = arr(max(min(d1/(d1-d2),1.0),0.0) , t);
                 }
              }
            sort(c+1 , c+r+1);
            int cnt = 0; double s = 0 , tmp = 0;
            bool f = 1;
            rep(i,1,r) {
               cnt += c[i].y;
               if (!cnt && !f) tmp = c[i].x , f = 1;
               if (cnt && f) s += c[i].x - tmp , f = 0;
            }
            s += 1.0 - tmp;
            ans += (a[i][j] % a[i][j+1])*s;
         }
       printf("%.9lf\n" , sum/ans);
}
int main()
{
    Init();
    Work();
    return 0;   
} 
