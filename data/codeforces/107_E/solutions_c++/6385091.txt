#include <algorithm>
#include <stdio.h>
#include <memory.h>
#include <queue>
#include <cmath>
#include <set>
#include <map>
#include <string.h>
#include <string>
#include <ctype.h>
#include <ctime>

#define eprintf(...) fprintf(stderr, __VA_ARGS__)
#define mp make_pair

using namespace std;

typedef long long INT;
typedef pair<int, int> pii;
template <class T> inline void chkmin(T &a, T b) { if (a>b) a=b; }
template <class T> inline void chkmax(T &a, T b) { if (a<b) a=b; }

#define eps 1e-8
#define inf 1e20
const double pi=4*atan(1);
struct point {
	double x, y;
	point(double _x=0, double _y=0) : x(_x), y(_y) {}
	point operator+(point p) { return point(x+p.x, y+p.y); }
	point operator-(point p) { return point(x-p.x, y-p.y); }
	point operator*(double t) { return point(x*t, y*t); }
	point operator/(double t) { return point(x/t, y/t); }
};
inline int sign(double x) { return x<-eps?-1:x>eps; }
inline double dot(point a, point b) { return a.x*b.x+a.y*b.y; }
inline double multi(point a, point b) { return a.x*b.y-a.y*b.x; }
inline double norm(point a) { return dot(a, a); }
inline double abs(point a) { return sqrt(norm(a)); }
inline double arg(point a) { return atan2(a.y, a.x); }
inline double dist(point a, point b) { return abs(a-b); }
inline point polar(double len, double al) { return point(len*cos(al), len*sin(al)); }
inline double angle(point a, point b) {
	double al;
	al=dot(a, b)/abs(a)/abs(b);
	chkmax(al, -1.0); chkmin(al, 1.0);
	al=acos(al);
	return al;
}
double seg(point a,point b,point c){
    if(sign(a.y-b.y)==0)return (c.x-a.x)/(b.x-a.x);
    else return (c.y-a.y)/(b.y-a.y);
}

point p[555][5];
pair<double, int> b[5555];

int main() {
	int N, i, j, ii, jj, cnt, aa, bb, co;
	double tot, area, s1, s2, s, last, now;
	
	scanf("%d", &N);
	for (i=0; i<N; i++)
		for (j=0; j<4; j++) 
			scanf("%lf%lf", &p[i][j].x, &p[i][j].y);
	
	tot=0;
	for (i=0; i<N; i++) {
		area=0; p[i][4]=p[i][0];
		for (j=0; j<4; j++) area+=multi(p[i][j], p[i][j+1]);
		if (area<0) {
			reverse(p[i], p[i]+4);
			p[i][4]=p[i][0];
			area=-area;
		}
		tot+=area;
	}
	area=0;
	for (i=0; i<N; i++) for (ii=0; ii<4; ii++) {
		cnt=0;
        b[cnt++]=mp(0.0,0);
        b[cnt++]=mp(1.0,0);
        for (j=0; j<N; j++) {
        	if (i==j) continue;
        	for (jj=0; jj<4; jj++) {
                aa=sign(multi(p[i][ii+1]-p[i][ii], p[j][jj]-p[i][ii]));
                bb=sign(multi(p[i][ii+1]-p[i][ii], p[j][jj+1]-p[i][ii]));
                if(aa==0&&bb==0){
                    if(dot(p[i][ii+1]-p[i][ii], p[j][jj+1]-p[j][jj])>0 && j<i) {
                        b[cnt++]=mp(seg(p[i][ii], p[i][ii+1], p[j][jj]), 1);
                        b[cnt++]=mp(seg(p[i][ii], p[i][ii+1], p[j][jj+1]), -1);
                    }
                } else if(aa<0 && bb>=0) {
                    s1=multi(p[i][ii]-p[j][jj], p[j][jj+1]-p[j][jj]);
					s2=s1+multi(p[j][jj+1]-p[j][jj], p[i][ii+1]-p[j][jj]);
                    b[cnt++]=mp(s1/s2,-1);  
                } else if(aa>=0 && bb<0) {
                    s1=multi(p[i][ii]-p[j][jj], p[j][jj+1]-p[j][jj]);
					s2=s1+multi(p[j][jj+1]-p[j][jj], p[i][ii+1]-p[j][jj]);
                    b[cnt++]=mp(s1/s2,1);
                }
			}
        }
        sort(b,b+cnt);
        s=0;
        last=min(max(b[0].first,0.0),1.0);
        co=b[0].second;
        for(j=1;j<cnt;++j){
            now=min(max(b[j].first,0.0),1.0);
            if(!co)s+=now-last;
            co+=b[j].second;
            last=now;
        }
        area+=multi(p[i][ii],p[i][ii+1])*s;
	}
	area=fabs(area);
	printf("%.15lf\n", tot/area);
	
	return 0;
}
