#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <vector>
#define ALL(x) x.begin(),x.end()
#define CLR(x) memset((x),0,sizeof(x))
#define Foreach(e,x) for(__typeof(x.begin()) e=x.begin();e!=x.end();++e)
#define MP make_pair
#define PB push_back
#define SZ(x) (int)((x).size())
using namespace std;
typedef double DB;
const int N = 111;
const DB eps = 1e-8;
const DB pi = acos(-1.0);
inline DB sqr(DB x) { return x*x; }
inline int sgn(DB x) { return fabs(x)<eps ? 0 : x>eps ? 1 : -1; }
struct point {
    DB x,y;
    point(DB _x=0,DB _y=0):x(_x),y(_y) {}
    void input(void) { scanf("%lf%lf",&x,&y); }
    void output(void) { printf("%f %f\n",x,y); }
    bool operator==(const point &p)const {
        return sgn(x-p.x)==0 && sgn(y-p.y)==0;
    }
    bool operator<(const point &p)const {
        return sgn(y-p.y)<0 || (sgn(y-p.y)==0 && sgn(x-p.x)<0);
    }
    point operator+(const point &p)const {
        return point(x+p.x,y+p.y);
    }
    point operator-(const point &p)const {
        return point(x-p.x,y-p.y);
    }
    point operator*(DB k) { return point(x*k,y*k); }
    point operator/(DB k) { return point(x/k,y/k); }
    DB operator*(const point &p)const {
        return x*p.x+y*p.y;
    }
    DB operator^(const point &p)const {
        return x*p.y-y*p.x;
    }
    DB norm(void) { return hypot(x,y); }
    DB norm2(void) { return sqr(x)+sqr(y); }
    DB dist(const point &p)const { return hypot(x-p.x,y-p.y); }
    DB dist2(const point &p)const { return sqr(x-p.x)+sqr(y-p.y); }
};
struct line {
    point a,b;
    line() {}
    line(point _a,point _b):a(_a),b(_b) {}
    point cross_point(line v) {
        DB a1=(v.b-v.a)^(a-v.a);
        DB a2=(v.b-v.a)^(b-v.a);
        return point((a.x*a2-b.x*a1)/(a2-a1),(a.y*a2-b.y*a1)/(a2-a1));
    }
};
struct polygon {
    int n;
    point p[N];
    void input(void) { for(int i=0;i<n;i++) p[i].input(); }
    DB get_area(void) {
        DB sum=0;
        for(int i=0;i<n;i++)    sum+=p[i]^p[(i+1)%n];
        return fabs(sum)/2;
    }
    // 1: counter-clockwise, 0: clockwise
    bool get_dir(void) {
        DB sum=0;
        for(int i=0;i<n;i++)    sum+=p[i]^p[(i+1)%n];
        return sgn(sum)>0;
    }
};
struct polygons {
    vector<polygon> p;
    vector<pair<DB,int> >e;
    polygons() { p.clear(); }
    void clear(void) { p.clear(); }
    void push(polygon q) { if(sgn(q.get_area()))    p.PB(q); }
    void ins(point st,point ed,point X,int i) {
        DB r=fabs(ed.x-st.x)>eps?(X.x-st.x)/(ed.x-st.x):(X.y-st.y)/(ed.y-st.y);
        r=min(r,1.0);
        r=max(r,0.0);
        e.PB(MP(r,i));
    }
    // point in every polygon must in clockwise or counter-clockwise order 
    DB polygon_area_union(void) {
        DB res=0.0;
        int c0,c1,c2,c3,dp,k,l;
        size_t i,j;
        // change point into counter-clockwise order
        for(i=0;i<p.size();i++) if(!p[i].get_dir())
            reverse(p[i].p,p[i].p+p[i].n);
        for(i=0;i<p.size();i++) for(k=0;k<p[i].n;k++) {
            point &s=p[i].p[k],&t=p[i].p[(k+1)%p[i].n];
            if(!sgn(s^t))   continue;
            e.clear();
            e.PB(MP(0.0,1));
            e.PB(MP(1.0,-1));
            for(j=0;j<p.size();j++) if(i!=j) for(l=0;l<p[j].n;l++) {
                point a=p[j].p[l],b=p[j].p[(l+1)%p[j].n],c=p[j].p[(l-1+p[j].n)%p[j].n];
                c0=sgn((t-s)^(c-s));
                c1=sgn((t-s)^(a-s));
                c2=sgn((t-s)^(b-s));
                if(c1*c2<0) ins(s,t,line(s,t).cross_point(line(a,b)),-c2);
                else if(!c1&&c0*c2<0) ins(s,t,a,-c2);
                else if(!c1&&!c2) {
                    c3=sgn((t-s)^(p[j].p[(l+2)%p[j].n]-s));
                    dp=sgn((t-s)*(b-a));
                    if(dp&&c0) ins(s,t,a,dp>0?c0*((j>i)^(c0<0)):-(c0<0));
                    if(dp&&c3) ins(s,t,b,dp>0?-c3*((j>i)^(c3<0)):c3<0);
                }
            }
            sort(ALL(e));
            int ct=0;
            DB tot=0.0,last;
            for(j=0;j<e.size();j++) {
                if(ct==1) tot+=e[j].first-last;
                ct+=e[j].second;
                last=e[j].first;
            }
            res+=(s^t)*tot;
        }
        return fabs(res)*0.5;
    }
};
int main(void) {
    polygons P;
    polygon tp;
    tp.n=4;
    int n;
    DB res=0;
    scanf("%d",&n);
    if(n==1) { puts("1"); return 0; }
    for(int i=0;i<n;i++) {
        tp.input();
        res+=tp.get_area();
        P.push(tp);
    }
    printf("%f\n",res/P.polygon_area_union());
    return 0;
}