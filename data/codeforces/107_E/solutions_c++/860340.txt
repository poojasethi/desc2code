#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
#define eps 1e-8
#define db double
#define rt return
inline int sgn(db x){rt (x<-eps)?-1:(x>eps);}
#define cpt const pt&
#define cs const
#define op operator
struct pt{
    db x,y;
    pt(){}
    pt(db x,db y):x(x),y(y){}
    void in(){scanf("%lf%lf",&x,&y);}
    pt op+(cpt a)cs{rt pt(x+a.x,y+a.y);}
    pt op-(cpt a)cs{rt pt(x-a.x,y-a.y);}
    pt op*(cs db&k)cs{rt pt(x*k,y*k);}
    db op*(cpt a)cs{rt x*a.x+y*a.y;}
    db op^(cpt a)cs{rt x*a.y-a.x*y;}
    db X(pt a,pt b){rt a-*this^b-*this;}
    db O(pt a,pt b){rt (a-*this)*(b-*this);}
    db len(){rt sqrt(x*x+y*y);}
    db Len(){rt x*x+y*y;}
};
cs int N=511;
struct poly{
    int sz;
    pt p[5];
    void in(){
        sz=4;
        for(int i=0;i<sz;i++) p[i].in();
        p[sz]=p[0];
    }
    void anti(){
        if(sgn(p[0].X(p[1],p[2])<0)) reverse(p,p+sz);
        p[sz]=p[0];
    }
    db S(){
        db s=0;
        for(int i=0;i<sz;i++) s+=p[i]^p[i+1];
        rt s*0.5;
    }
}ply[N];

pair<db,int> E[N*200];

inline db ratio(pt a,pt b,pt p){
    if(sgn( b.x-a.x )) rt (p.x-a.x)/(b.x-a.x);
    rt (p.y-a.y)/(b.y-a.y);
}

db US(poly *ply,int n){
    db s=0;
    for(int i=0;i<n;i++)
        for(int x=0;x<ply[i].sz;x++){
            int cnt=0;
            E[cnt++]=make_pair(0.0,0);
            E[cnt++]=make_pair(1.0,0);
            for(int j=0;j<n;j++){
                if(i==j) continue;
                for(int y=0;y<ply[j].sz;y++){
                    int dir1=sgn( ply[i].p[x].X(ply[i].p[x+1],ply[j].p[y]) );
                    int dir2=sgn( ply[i].p[x].X(ply[i].p[x+1],ply[j].p[y+1]) );
                    if(!dir1 && !dir2){
                        if(i>j && (ply[i].p[x+1]-ply[i].p[x])*(ply[j].p[y+1]-ply[j].p[y])>0){
                            E[cnt++]=make_pair(ratio(ply[i].p[x],ply[i].p[x+1],ply[j].p[y]),1);
                            E[cnt++]=make_pair(ratio(ply[i].p[x],ply[i].p[x+1],ply[j].p[y+1]),-1);
                        }
                    }else if(dir1>=0 && dir2<0){
                        db s1=ply[j].p[y].X(ply[j].p[y+1],ply[i].p[x]);
                        db s2=ply[j].p[y].X(ply[j].p[y+1],ply[i].p[x+1]);
                        E[cnt++]=make_pair(s1/(s1-s2),1);
                    }else if(dir1<0 && dir2>=0){
                        db s1=ply[j].p[y].X(ply[j].p[y+1],ply[i].p[x]);
                        db s2=ply[j].p[y].X(ply[j].p[y+1],ply[i].p[x+1]);
                        E[cnt++]=make_pair(s1/(s1-s2),-1);
                    }
                }
            }
            sort(E,E+cnt);
            db last=min(max(E[0].first,0.0),1.0),r=0.0,cur;
            int L=E[0].second;
            for(int k=1;k<cnt;k++){ /*cur and last is unnecessary！*/
                cur=min(max(E[k].first,0.0),1.0);
                if(!L) r+=cur-last;
                L+=E[k].second;
                last=cur;
            }
            s+=(ply[i].p[x]^(ply[i].p[x+1]))*r;
        }
    rt s*0.5;
}
int main()
{
    int n;
    while(scanf("%d",&n)!=-1){
        db s=0.0;
        for(int i=0;i<n;i++){
           ply[i].in();
           ply[i].anti();
           s+=ply[i].S();
        }
        printf("%.9f\n",s/US(ply,n));
    }
    rt 0;
}