//107E Hewr
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <vector>
#include <queue>
#include <iomanip>
using namespace std;
#define fo(i,a,b) for (int i = a; i <= b; ++i)
#define fd(i,a,b) for (int i = a; i >= b; --i)
#define fe(i,x) for (int i = g[x], y = E[i].y; i; i = E[i].l, y = E[i].y)
#define forall(i, x) for (typeof((x).begin()) i = (x).begin(); i != (x).end(); ++i)
#define pb push_back
#define SIZE(x) ((int) (x).size())
#define MP make_pair
#define fi first
#define se second
#define UNIQUE(x) x.resize(unique(x.begin(), x.end()) - x.begin())
#define clr(a,x) memset(&a, x, sizeof(a))
#define move(a,b) memcpy(&b, &a, sizeof(a))
#define Plus(a,b) (((LL) (a) + (b)) % mo)
#define Minus(a,b) ((((LL) (a) - (b) ) % mo + mo) % mo)
#define Mul(a,b) ((LL) (a) * (b) % mo)
#define updmin(a,b) (a = min(a, b))
#define updmax(a,b) (a = max(a, b))
#define sqr(x) ((x) * (x))

typedef long long LL;
typedef long double LD;
typedef pair<int, int> PII;
typedef pair<double, int> PDI;
typedef vector<int> VI;

const double eps = 1e-10;
const int oo = ~0u >> 2, mo = (int) 1e9 + 7;
const int mn = 510;

int sgn(double x){
	if (fabs(x) <= eps) return 0;
	if (x > -eps) return 1;
	return -1;
}

struct po{
	double x, y;
	po(){ x = y = 0; }
	po(int X, int Y){ x = X, y = Y; }
	po operator - (const po &p){ return *(new po(x - p.x, y - p.y)); }
} o;

double dot(const po &a, const po &b){
	return a.x * b.x + a.y * b.y;
}

double det(const po &a, const po &b, const po &c){
	return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);
}

double ratio(const po &a, const po &b, const po &c){
	if (sgn(a.x - b.x)) return (c.x - a.x) / (b.x - a.x);
	return (c.y - a.y) / (b.y - a.y);
}

struct Polygon{
	po p[5];
	void readin(){
		fo (i, 0, 3) cin >> p[i].x >> p[i].y;
		if (sgn(det(p[0], p[1], p[2])) < 0) reverse(p, p + 4);
		p[4] = p[0];
	}
	double area(){
		double ret = 0;
		fo (i, 0, 3) ret += det(o, p[i], p[i + 1]);
		return ret;
	}
} py[mn];

int n;

vector<PDI> Q;

double Union(){
	double ret = 0;
	fo (i, 0, n - 1) fo (ii, 0, 3){
		Q.clear(), Q.pb(MP(0.0, 0)), Q.pb(MP(1.0, 0));
		fo (j, 0, n - 1) if (i != j) fo (jj, 0, 3){
			int d1 = sgn(det(py[i].p[ii], py[i].p[ii + 1], py[j].p[jj]));
			int d2 = sgn(det(py[i].p[ii], py[i].p[ii + 1], py[j].p[jj + 1]));
			if (!d1 && !d2){
				if (j < i && dot(py[i].p[ii + 1] - py[i].p[ii], py[j].p[jj + 1] - py[j].p[jj]) > 0){
					Q.pb(MP(ratio(py[i].p[ii], py[i].p[ii + 1], py[j].p[jj]), 1));
					Q.pb(MP(ratio(py[i].p[ii], py[i].p[ii + 1], py[j].p[jj + 1]), -1));
				}
			} else 
			if (d1 >= 0 && d2 < 0){
				double s1 = det(py[j].p[jj], py[j].p[jj + 1], py[i].p[ii]);
				double s2 = det(py[j].p[jj], py[j].p[jj + 1], py[i].p[ii + 1]);
				Q.pb(MP(s1 / (s1 - s2), 1));
			} else
			if (d1 < 0 && d2 >= 0){
				double s1 = det(py[j].p[jj], py[j].p[jj + 1], py[i].p[ii]);
				double s2 = det(py[j].p[jj], py[j].p[jj + 1], py[i].p[ii + 1]);
				Q.pb(MP(s1 / (s1 - s2), -1));
			}
		}
		sort(Q.begin(), Q.end());
		double Last = min(max(Q[0].fi, 0.0), 1.0), Sum = 0;
		int p = Q[0].se;
		fo (j, 1, SIZE(Q) - 1){
			double Now = min(max(Q[j].fi, 0.0), 1.0);
			if (!p) Sum += Now - Last;
			p += Q[j].se, Last = Now;
		}
		ret += det(o, py[i].p[ii], py[i].p[ii + 1]) * Sum;
	}
	return ret;
}

int main(){
	cin >> n;
	double tot = 0, Sum = 0;
	fo (i, 0, n - 1){
		py[i].readin();
		tot += py[i].area();
	}
	Sum = Union();
	double Ans = tot / Sum;
	cout << fixed << setprecision(10) << Ans << endl;
}
