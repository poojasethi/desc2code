// 10 monthes remaining for red =D
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define FOR(i,a,b) for(int i=(a);i<=(b);i++)

using namespace std;

const double EPS=1E-7;

struct point{
    double x; double y;
    int id;
    point (double xx=0,double yy=0){x=xx;y=yy;}
}O,rec[600][7],A,B;

double sqr(double x){return x*x;}
point operator + (const point & a,const point & b){return  point(a.x+b.x,a.y+b.y);}
point operator - (const point & a,const point & b){return  point(a.x-b.x,a.y-b.y);}
double operator ^ (const point & a,const point & b){return  a.x*b.x+a.y*b.y;}
double operator * (const point & a,const point & b){return  a.x*b.y-a.y*b.x;}

double dis(point & a,point & b){return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));}

point j_d(point &a,point &b,point &c,point &d){
    double s1,s2;
    s1=(c-a)*(b-a);
    s2=(b-a)*(d-a);
    return point((c.x*s2+d.x*s1)/(s1+s2) , (c.y*s2+d.y*s1)/(s1+s2));
}

struct EV{
    int de;
    double cc;
    EV(point a=point(0,0),int delta=0){
        cc=dis(a,A)/dis(A,B);
        if(((a-A)^(B-A)) < 0)cc=-cc;
        de=delta;
    }
}ev[4000];

bool operator < (const EV &a,const EV &b){return a.cc<b.cc;}

int n;
int main(){
    scanf("%d",&n);
    double an=0,ans=0;
    FOR(i,1,n){
        FOR(ii,1,4)scanf("%lf%lf",&rec[i][ii].x,&rec[i][ii].y);
        double t=(rec[i][2]-rec[i][1])*(rec[i][3]-rec[i][1]);
        if(t<0)
        {
            point trec[7];
            FOR(ii,1,4)trec[ii]=rec[i][5-ii];
            FOR(ii,1,4)rec[i][ii]=trec[ii];
        }
        rec[i][0]=rec[i][4];
        rec[i][5]=rec[i][1];
        an+=fabs(t);
    }
    O=rec[1][1];
    FOR(i,1,n)FOR(ii,0,5)rec[i][ii]=rec[i][ii]-O;
    O=point(0,0);

    FOR(i,1,n){
        FOR(ii,1,4){
            double ss=rec[i][ii]*rec[i][ii+1];
            int p=0;
            A=rec[i][ii]; B=rec[i][ii+1];
            ev[++p]=EV(A,0);
            ev[++p]=EV(B,0);
            FOR(j,1,n)if(i!=j){
                FOR(jj,1,4){
                    double ta=(B-A)*(rec[j][jj]-A);
                    double tb=(B-A)*(rec[j][jj+1]-A);
                    if(fabs(ta)+fabs(tb)<EPS&&i>j)
                    {
                        if( ( (B-A)^(rec[j][jj+1]-rec[j][jj]) ) > 0 )
                        {
                            ev[++p]=EV(rec[j][jj],1);
                            ev[++p]=EV(rec[j][jj+1],-1);
                        }
                    }
                    point vv;
                    if(abs((B-A)*(rec[j][jj+1]-rec[j][jj]))>EPS)
                        vv=j_d(A,B,rec[j][jj+1],rec[j][jj]);
                    if(ta>-EPS&&tb<-EPS)ev[++p]=EV(vv,1);
                    if(ta<-EPS&&tb>-EPS)ev[++p]=EV(vv,-1);
                }
            }
            sort(ev+1,ev+p+1);
            int o=0;
            FOR(j,1,p){
                if(!(o+=ev[j].de) && ev[j].cc>-EPS && ev[j].cc<1-EPS)
                    ans+=ss*(ev[j+1].cc-ev[j].cc);
            }
        }
    }

    printf("%.12f",an/(ans/2));
}








