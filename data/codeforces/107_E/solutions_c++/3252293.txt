#include<cstdio>
#include<cmath>
#include<algorithm>
#include<iostream>
using namespace std;
#define L(x) tree[x].ch[0]
#define R(x) tree[x].ch[1]
#define INF 0x7fffffff
#define inf 99999999.9
#define eps 1e-11
#define MAXN 100015
#define db double
#define op operator
#define cp const P&
#define cs const
#define rt return
//typedef __int64 ll;
int sig(db x){
    rt (x > eps) - (x < -eps);
}
struct P{
    db x,y;
    P(db a = 0.,db b = 0.):x(a),y(b){}
    db cross(cp a,cp b)cs{
        rt (a.x - x)*(b.y - y) - (a.y - y)*(b.x - x);
    }
    db op^(cp a)cs{
        rt x*a.y - y*a.x;
    }
    db op*(cp a)cs{
        rt x*a.x + y*a.y;
    }
    P op-(cp a)cs{
        rt P(x - a.y,y - a.y);
    }
    db ratio(cp a,cp b)cs{
        if(sig(b.x - x)) rt (a.x - x)/(b.x - x);
        else rt (a.y - y)/(b.y - y);
    }
};
int n;
struct poly{
    int pl_cnt;
    P ch[10];
    void anti(){
        if(ch[0].cross(ch[1],ch[2]) < 0.)  reverse(ch,ch+pl_cnt);
        ch[pl_cnt] = ch[0];
    }
    db S(){
        db s = 0.;
        for(int i = 0; i <= pl_cnt; i ++)
            s += ch[i]^ch[i+1];
        rt s*0.5;
    }
}pl[505];
pair<db,int> arr[1005];
inline db get(){
    int cnt;
    db s = 0.;
    for(int i = 0; i < n; i ++){
        for(int x = 0; x < pl[i].pl_cnt; x ++){
            cnt = 0;
            arr[cnt++] = make_pair(0.,0);
            arr[cnt++] = make_pair(1.,0);
            for(int j = 0; j < n; j ++){//puts("*");
                if(i == j) continue;
                for(int y = 0; y < pl[j].pl_cnt; y ++){
                    int dr1 = sig(pl[i].ch[x].cross(pl[i].ch[x+1],pl[j].ch[y])),dr2 = sig(pl[i].ch[x].cross(pl[i].ch[x+1],pl[j].ch[y+1]));
                    if(!dr1 && !dr2){
                        if(i > j && (pl[i].ch[x+1] - pl[i].ch[x])*(pl[j].ch[y+1] - pl[j].ch[y]) > 0.){
                            arr[cnt++] = make_pair(pl[i].ch[x].ratio(pl[j].ch[y],pl[i].ch[x+1]),1);
                            arr[cnt++] = make_pair(pl[i].ch[x].ratio(pl[j].ch[y+1],pl[i].ch[x+1]),-1);
                        }
                    }
                    else if(dr1 >= 0 && dr2 < 0){//1
                        db s1 = pl[j].ch[y+1].cross(pl[j].ch[y],pl[i].ch[x]),s2 = pl[j].ch[y+1].cross(pl[j].ch[y],pl[i].ch[x+1]);
                        arr[cnt++] = make_pair(s1/(s1 - s2),1);

                    }
                    else if(dr1 < 0 && dr2 >= 0){//-1
                        db s1 = pl[j].ch[y].cross(pl[j].ch[y+1],pl[i].ch[x]),s2 = pl[j].ch[y].cross(pl[j].ch[y+1],pl[i].ch[x+1]);
                        arr[cnt++] = make_pair(s1/(s1 - s2),-1);
                    }
                }
            }
            sort(arr,arr+cnt);

            db r = 0.,cur,last;
            int sum;
            last = min(max(arr[0].first,0.),1.);
            sum = arr[0].second;
            for(int k = 1; k < cnt; k ++){
                cur = min(max(arr[k].first,0.),1.);
                if(!sum) r += cur - last;//不能遇到>0才开始计数，因为cur和last都保证在了[0,1]
                sum += arr[k].second, last = cur;
            }
            //printf("r=%f\n",r);
            s += (pl[i].ch[x]^pl[i].ch[x+1])*r;
            //printf("%f\n",s);
        }
    }
    //printf("%f\n",s);
    rt s*0.5;
}
int main()
{
    //freopen("c.in","r",stdin);
    //freopen("c.out","w",stdout);

    while(~scanf("%d",&n))
    {
        db s = 0.;
        for(int i = 0; i < n; i ++){
            for(int j = 0; j < 4; j ++)
                scanf("%lf%lf",&pl[i].ch[j].x,&pl[i].ch[j].y);
            pl[i].pl_cnt = 4;
            pl[i].anti();
            s += pl[i].S();
            //puts("*");
        }
        //printf("%f\n",s);
        printf("%.9f\n",s/get());
    }
return 0;
}
/*
1
0 0 0 2 2 2 2 0
4
0 0 0 1 3 1 3 0
0 0 0 3 1 3 1 0
3 3 2 3 2 0 3 0
3 3 3 2 0 2 0 3
2
-1 0 0 1 1 0 0 -1
0 0 1 1 2 0 1 -1
*/
