#include <iostream>
#include <sstream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <string>
#include <algorithm>
#include <cmath>
#include <iomanip>
#include <vector>
#include <queue>
#include <map>
#include <set>

using namespace std;

const int MAXN = 55;

struct Poker {
	int suit, rank;

	Poker(int x = 0) {
		suit = x / 13;
		rank = x % 13;
	}

	Poker(char* s) {
		if (string(s) == "J1") {
			suit = 4;
			rank = 0;
			return;
		}
		if (string(s) == "J2") {
			suit = 4;
			rank = 1;
			return;
		}

		if (s[1] == 'S')
			suit = 0;
		else if (s[1] == 'H')
			suit = 1;
		else if (s[1] == 'C')
			suit = 2;
		else
			suit = 3;

		if (s[0] == 'A')
			rank = 1;
		else if (s[0] == 'T')
			rank = 10;
		else if (s[0] == 'J')
			rank = 11;
		else if (s[0] == 'Q')
			rank = 12;
		else if (s[0] == 'K')
			rank = 0;
		else
			rank = s[0] - '0';
	}
	int hash() { return suit * 13 + rank; }
	string toString() {
		string ret = "";
		if (rank == 0)
			ret += 'K';
		else if (rank == 1)
			ret += 'A';
		else if (rank == 10)
			ret += 'T';
		else if (rank == 11)
			ret += 'J';
		else if (rank == 12)
			ret += 'Q';
		else
			ret += rank + '0';

		if (suit == 0)
			ret += 'S';
		else if (suit == 1)
			ret += 'H';
		else if (suit == 2)
			ret += 'C';
		else
			ret += 'D';
		return ret;
	}
};

int n, m, ans[2];
Poker board[MAXN][MAXN];
char poker[10];
bool contains[MAXN];

inline bool flush(int x, int y) {
	int suit = board[x][y].suit;
	for (int i = 0; i < 3; ++i)
		for (int j = 0; j < 3; ++j)
			if (board[x + i][y + j].suit != suit)
				return false;
	return true;
}

inline bool straight(int x, int y) {
	bool has[15];
	memset(has, 0, sizeof has);
	for (int i = 0; i < 3; ++i)
		for (int j = 0; j < 3; ++j) {
			if (has[board[x + i][y + j].rank])
				return false;
			has[board[x + i][y + j].rank] = true;
		}
	return true;
}

void dfs(int cnt) {
	if (cnt == 0) {
		for (int i = 0; i < n; ++i)
			for (int j = 0; j < m; ++j)
				for (int k = i; k < n; ++k)
					for (int l = 0; l < m; ++l) {
						if (abs(i - k) < 3 && abs(j - l) < 3)
							continue;
						if (i + 3 > n || j + 3 > m || k + 3 > n || l + 3 > m)
							continue;
						if (!flush(i, j) && !straight(i, j))
							continue;
						if (!flush(k, l) && !straight(k, l))
							continue;
						puts("Solution exists.");
						if (contains[52] && contains[53]) {
							printf("Replace J1 with %s and J2 with %s.\n", Poker(ans[0]).toString().c_str(), Poker(ans[1]).toString().c_str());
						}
						else if (contains[52]) {
							printf("Replace J1 with %s.\n", Poker(ans[0]).toString().c_str());
						}
						else if (contains[53]) {
							printf("Replace J2 with %s.\n", Poker(ans[1]).toString().c_str());
						}
						else {
							puts("There are no jokers.");
						}
						printf("Put the first square to (%d, %d).\n", i + 1, j + 1);
						printf("Put the second square to (%d, %d).\n", k + 1, l + 1);
						exit(0);
					}
		return;
	}

	for (int i = 0; i < n; ++i)
		for (int j = 0; j < m; ++j)
			if (board[i][j].hash() >= 52) {
				int tmp = board[i][j].hash();
				for (int k = 0; k < 52; ++k)
					if (!contains[k]) {
						ans[tmp - 52] = k;
						contains[k] = true;
						board[i][j] = Poker(k);
						dfs(cnt - 1);
						contains[k] = false;
					}
				board[i][j] = Poker(tmp);
			}
}

int main() {
	scanf("%d %d", &n, &m);
	for (int i = 0; i < n; ++i)
		for (int j = 0; j < m; ++j) {
			scanf("%s", poker);
			board[i][j] = Poker(poker);
			contains[board[i][j].hash()] = true;
		}

	dfs(contains[52] + contains[53]);
	cout << "No solution." << endl;
}

				  		   			   	   	  	