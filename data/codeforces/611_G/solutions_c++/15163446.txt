#include <iostream>
#include <algorithm>

using namespace std;

typedef long long int ll;

ll modulo=1e9+7;
ll div2=500000004;

struct point {
  ll x,y;
  point() {
    x=y=0;
  }
  point(ll inx,ll iny) {
    x=iny;y=iny;
  }
};

point modularizar(point p)
{
  p.x%=modulo;
  p.y%=modulo;
  return p;
}

point operator*(ll a,point p)
{
  p.x*=a;
  p.y*=a;
  return p;
}

point operator+(point p1,point p2)
{
  p1.x+=p2.x;
  p1.y+=p2.y;
  return p1;
}

point operator-(point p1,point p2)
{
  p1.x-=p2.x;
  p1.y-=p2.y;
  return p1;
}

ll prodvec(point p1,point p2)
{
  return p1.x*p2.y-p1.y*p2.x;
}

const int limite=2000000;

int n;

void escribe(ll v[limite])
{
  for (int i=1;i<=3*n;i++)
    cout<<v[i]<<",";
  cout<<endl;
}

void anular(ll v[limite])
{
  for (int i=1;i<=3*n;i++)
    v[i]=0;
}

point p[limite];
point sumap[limite];
ll pv[limite];
ll area[limite];
ll acum[limite];
ll addinc[limite];


int main()
{
  ios::sync_with_stdio(false);
  cin>>n;
  for (int i=1;i<=n;i++) {
    cin>>p[i].x>>p[i].y;
  }
  reverse(p+1,p+n+1);
  for (int i=1;i<=n;i++)
    p[i+2*n]=p[i+n]=p[i];
  for (int i=1;i<=3*n;i++)
    sumap[i]=sumap[i-1]+p[i];
  for (int i=2;i<=3*n;i++) {
    pv[i]=prodvec(p[i-1],p[i]);
    area[i]=area[i-1]+pv[i];
  }
  ll areatotal=area[n+1];
  //cout<<"areatotal "<<areatotal<<endl;
  int i2=1;
  /*
  for (int i=1;i<=n;i++)
    cout<<"("<<p[i].x<<","<<p[i].y<<")";
  cout<<endl;
  escribe(pv);
  escribe(area);
  */
  ll sol=0;
  for (int i1=1;i1<=n;i1++) {
    i2=max(i1,i2);
    while ((area[i2+1]-area[i1]+prodvec(p[i2+1],p[i1]))<=areatotal/2) i2++;
    //cout<<"caso "<<i1<<" "<<i2<<endl;
    acum[i1]+=(n+i1-2-i2)-(i2-i1-1);
    addinc[i1+1]+=2;
    addinc[i2]-=4;
    /*
    if (2*(area[i2]-area[i1]+prodvec(p[i2],p[i1]))<areatotal) {
      addinc[i2]-=4;
    } else {
      cout<<"exacto"<<endl;
      addinc[i2-1]-=2;
      addinc[i2]-=2;
    }
    */
    addinc[i1+n-2]+=2;
    acum[i1+n]-=(i2-i1-1)-(n+i1-2-i2);
    sol=(sol+prodvec(p[i1],modularizar(2*(sumap[i2]-sumap[i1+1])
				       -2*(sumap[i1+n-2]-sumap[i2]))))%modulo;
    //escribe(acum);
    //escribe(addinc);
    //anular(acum);
    //anular(addinc);
  }
  ll acu=0,inc=0;
  //cout<<"acu:";
  for (int i=1;i<3*n;i++) {
    acu=(acu+acum[i]+inc)%modulo;
    sol=(sol+pv[i+1]%modulo*acu)%modulo;
    inc+=addinc[i];
    //cout<<acu<<",";
  }
  //cout<<endl;
  sol=(sol*div2)%modulo;
  cout<<(sol%modulo+modulo)%modulo<<endl;
}
