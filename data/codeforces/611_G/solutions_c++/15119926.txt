#include <algorithm>
#include <bitset>
#include <cassert>
#include <cctype>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <string>
#include <utility>
#include <vector>
using namespace std;

#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(), (x).end()
#define sz(x) (int((x).size()))
#define bit(x) (1 << (x))
#define cnt1(x) (__builtin_popcount(x))

template<class T, class U>
inline void chkmax(T& x, U y) {
    if (x < y) x = y;
}

template<class T, class U>
inline void chkmin(T& x, U y) {
    if (y < x) x = y;
}

typedef long long LL;
typedef double DB;
typedef pair<int, int> PII;
typedef vector<int> VI;
const int MX = 1000005;
const int M = 1000000007;

struct PT {
    int x, y;
    
    void in() {
        scanf("%d%d", &x, &y);
    }
};

LL vect(PT& p1, PT& p2) {
    return LL(p1.x) * p2.y - LL(p2.x) * p1.y;
}

LL vect(PT& p, PT& p1, PT& p2) {
    return LL(p1.x - p.x) * (p2.y - p.y) - LL(p2.x - p.x) * (p1.y - p.y);
}

LL calcArea(PT *p, int n) {
    LL s = 0;
    for (int i = 0; i < n; i++) s += vect(p[i], p[i + 1]);
    return s;
}

int n;
PT p[MX];

inline void add(int& x, int y) {
    x += y;
    while (x >= M) x -= M;
    while (x < 0) x += M;
}

int main() {
//  freopen("in.txt", "r", stdin);
//  freopen("out.txt", "w", stdout);
    
    int i, j, tot, del, rlt;
    LL area, sum, tp, sx, sy, tx, ty;
    
    scanf("%d", &n);
    for (i = 0; i < n; i++) p[i].in();
    
    reverse(p, p + n);
    for (i = 0; i <= n; i++) p[i + n] = p[i];
    area = calcArea(p, n);
    j = 0;
    sum = tot = sx = sy = 0;
    rlt = 0;
    for (i = 0; i < n; i++) {
        while (1) {
            tp = vect(p[i], p[j], p[j + 1]);
            if (sum + tp > area / 2) break;
            j++;
            sum += tp;
            add(tot, sum % M);
            sx += p[j].x, sy += p[j].y;
        }
        add(rlt, area % M * (j - i - 1) % M);
        add(rlt, -2 * tot % M);
        sum -= vect(p[i], p[i + 1], p[j]);
        tx = (sx - p[i + 1].x) % M;
        ty = (sy - p[i + 1].y) % M;
        del = vect(p[i], p[i + 1]) % M * (j - i - 1) % M;
        add(del, (p[i + 1].x * ty - p[i + 1].y * tx) % M);
        add(del, (tx * p[i].y - ty * p[i].x) % M);
        add(tot, -del);
        sx -= p[i + 1].x;
        sy -= p[i + 1].y;
    }
    printf("%d\n", rlt);
    return 0;
}