#include <algorithm>
#include <iostream>
#define x first
#define y second
using namespace std;
typedef pair<long long, long long> point;
const int MOD = 1000000007;
const int MAX = 500005;
point p[2 * MAX];
int n;
long long area(point a, point b, point c)
{
	return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
}
long long sum[2 * MAX], sum2[2 * MAX], sumx[2 * MAX], sumy[2 * MAX], o;
long long get_area(int l, int r)
{
	long long ans = sum[r] - sum[l];
	ans -= area(p[o], p[l], p[r]);
	return ans;
}
long long s;
int get_sum_area(int l, int r)
{
	if (l + 2 > r)
		return 0;
	int ans = 0;
	ans = (ans + sum[l] % MOD * (r - l - 1)) % MOD;
	ans = (ans - (sum2[r + 1] - sum2[l + 2])) % MOD;
	ans = (ans - (p[l].x - p[o].x) * p[o].y % MOD * (r - l - 1)) % MOD;
	ans = (ans + (p[l].y - p[o].y) * p[o].x % MOD * (r - l - 1)) % MOD;
	ans = (ans + (p[l].x - p[o].x) * (sumy[r + 1] - sumy[l + 2])) % MOD;
	ans = (ans - (p[l].y - p[o].y) * (sumx[r + 1] - sumx[l + 2])) % MOD;
	ans = ans * 2LL % MOD;
	ans = (ans + 1LL * s % MOD * (r - l - 1)) % MOD;
	return (ans % MOD + MOD) % MOD;
}
int solve(int st)
{
	if (st == n)
		return 0;
	o = st;
	sum[st] = 0;
	sum2[st] = 0;
	sumx[st] = 0;
	sumy[st] = 0;
	s = 0;
	for (int i = st; i < st + n; i++)
	{
		s += area(p[st], p[i], p[i + 1]);
		sum[i + 1] = sum[i] + area(p[st], p[i], p[i + 1]);
		sum2[i + 1] = (sum2[i] + sum[i]) % MOD;
		sumx[i + 1] = (sumx[i] + p[i].x) % MOD;
		sumy[i + 1] = (sumy[i] + p[i].y) % MOD;
	}
	int fi = st + 1;
	while (get_area(st, fi + 1) * 2 <= s / 2)
		fi++;
	int ans = 0;
	int ptr = fi;
	while (st < n && st != fi)
	{
		while (get_area(st, ptr + 1) <= s / 2)
			ptr++;
		ans = (ans + get_sum_area(st, ptr)) % MOD;
		st++;
	}
	return (ans + solve(st)) % MOD;
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin >> n;
	for (int i = 0; i < n; i++)
		cin >> p[i].x >> p[i].y;
	reverse(p, p + n);
	for (int i = 0; i < n; i++)
		p[i + n] = p[i];
	cout << solve(0) << "\n";
	return 0;
}
