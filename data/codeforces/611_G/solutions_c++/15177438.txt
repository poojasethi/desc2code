#include<bits/stdc++.h>
using namespace std;
#define FOR(i,a,b) for(int i = (a); i <= (b); ++i)
#define RI(i,n) FOR(i,1,(n))
#define REP(i,n) FOR(i,0,(n)-1)
#define I64d lld
typedef long long ll;
 
const int nax = 1e6 + 15;
const int mod = 1e9 + 7;
 
struct P {
    ll x, y;
    ll operator * (const P & b) const {
        return -x * b.y + y * b.x;
    }
} t[nax];
 
ll sum_x, sum_y, sum_product, sum_product2;
 
void makeMod() {
    // sum_x %= mod;
    // sum_y %= mod;
    // sum_product %= mod;
    sum_product2 %= mod;
}
 
void insert(int i) {
    sum_x += t[i].x;
    sum_y += t[i].y;
    sum_product += t[i-1] * t[i];
    sum_product2 += (t[i-1] * t[i]) % mod * i;
    makeMod();
}
void remove(int i) {
    sum_x -= t[i].x;
    sum_y -= t[i].y;
    sum_product -= t[i] * t[i+1];
    sum_product2 -= (t[i] * t[i+1]) % mod * (i + 1);
    makeMod();
}
 
int main() {
    int n;
    scanf("%d", &n);
    REP(i, n) scanf("%lld%lld", &t[i].x, &t[i].y);
    REP(i, n+2) t[i+n] = t[i];
    ll total = 0;
    REP(i, n) total += t[i] * t[i+1];
    assert(total > 0);
    int b = 0;
    sum_x = t[0].x;
    sum_y = t[0].y;
    ll ans = 0;
    REP(a, n) {
        while(true) {
            unsigned long long tmp = 2 * (sum_product + (unsigned long long)( t[b] * t[b+1]) + (unsigned long long) (t[b+1] * t[a]));
            if(tmp < (unsigned long long)total || (tmp == (unsigned long long)total && b + 1 < n)) {
                insert(b + 1);
                ++b;
            }
            else break;
        }
        ll tmp = sum_product % mod * (b + 1) - sum_product2;
        tmp %= mod;
        P fake = P{sum_x % mod, sum_y % mod};
        tmp += fake * t[a];
        ans += tmp;
        ans %= mod;
        remove(a);
    }
    ans = (ll) n * (n - 3) / 2 % mod * (total % mod) - 2 * ans;
    ans = (ans % mod + mod) % mod;
    printf("%lld\n", ans);
    return 0;
}