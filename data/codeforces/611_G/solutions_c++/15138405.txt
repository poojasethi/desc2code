#include <cstdlib>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <queue>
#include <cmath>
#include <stack>
#include <map>
#include <set>
#include <deque>
#include <cstring>
#include <functional>
#include <climits>
#include <list>
#include <ctime>
#include <complex>
 
#define F1(x,y,z) for(int x=y;x<z;x++)
#define F2(x,y,z) for(int x=y;x<=z;x++)
#define F3(x,y,z) for(int x=y;x>z;x--)
#define F4(x,y,z) for(int x=y;x>=z;x--)
#define pb push_back
#define LL long long
#define co complex<double>
 
#define MAX 100005
#define AMAX 1500
#define MOD ((LL)1000000007)

#define f(c,d) ((1<<(c))*(d))

using namespace std;

int n,lo,mi,hi,to[MAX*10];
LL x[MAX*10],y[MAX*10],flag,ans,tc,td;
pair<LL,LL> xx[MAX*10],yy[MAX*10],ta,tb,all;

void add(pair<LL,LL> &a,pair<LL,LL> b){
	a.first+=b.first,a.second+=b.second;
	a.first+=a.second>>61;
	a.second&=flag;
}

void sub(pair<LL,LL> &a,pair<LL,LL> b){
	a.first-=b.first,a.second-=b.second;
	if(a.second<0){
		a.second+=1LL<<61;
		a.first--;
	}
}

pair<LL,LL> mp(LL a){
	return make_pair(a>>61,a&flag);
}

void cal(int &a){
	ta=yy[mi];
	add(ta,xx[a]);
	add(ta,mp(y[mi]*x[a]));
	sub(ta,yy[a]);
	sub(ta,xx[mi]);
	sub(ta,mp(x[mi]*y[a]));
	tb=ta;
	add(ta,tb);
}
int main(){
	flag=(1LL<<61)-1;
	scanf("%d",&n);
	F1(a,0,n){
		scanf("%I64d%I64d",&x[a],&y[a]);
		x[a]+=MOD;
		y[a]+=MOD;
		x[a+n]=x[a],y[a+n]=y[a];
	}
	n<<=1;
	x[n]=x[0];
	y[n]=y[0];
	x[n+1]=x[1];
	y[n+1]=y[1];
	F2(a,0,n){
		xx[a+1]=xx[a];
		add(xx[a+1],mp(x[a]*y[a+1]));
		yy[a+1]=yy[a];
		add(yy[a+1],mp(y[a]*x[a+1]));
	}
	n>>=1;
	all=yy[n];
	sub(all,xx[n]);
	F1(a,0,n){
		lo=a+2;
		hi=a+n-1;
		while(lo<hi){
			mi=(lo+hi)/2;
			cal(a);
			if(ta<=all)lo=mi+1;
			else hi=mi;
		}
		if((lo+n-1)%n<a){		
			mi=lo-1;
			cal(a);
			if(ta==all)lo--;
		}
		to[a]=lo;
	}
	flag=(flag+1)%MOD;
	n<<=1;
	F2(a,0,n){
		xx[a+1].second=(xx[a+1].first%MOD*flag+xx[a+1].second%MOD)%MOD;
		xx[a+1].first=(xx[a].first+x[a])%MOD;
		yy[a+1].second=(yy[a+1].first%MOD*flag+yy[a+1].second%MOD)%MOD;
		yy[a+1].first=(yy[a].first+y[a])%MOD;
	}
	n>>=1;
	ans=(yy[n].second-xx[n].second+MOD)%MOD*((((LL)n)*(n-3)/2)%MOD)%MOD;
	F1(a,0,n){
		if(a){
			while(to[a-1]>to[a]){
				tc=(tc-yy[to[a-1]-1].second+yy[a].second+xx[to[a-1]-1].second-xx[a].second+(MOD<<1))%MOD;
				to[a-1]--;
			}
			while(to[a-1]<to[a]){
				tc=(tc+yy[to[a-1]].second-yy[a].second-xx[to[a-1]].second+xx[a].second+(MOD<<1))%MOD;
				to[a-1]++;
			}
		}else F1(b,a+1,to[a])tc=(tc+(y[b-1]*x[b]%MOD-x[b-1]*y[b]%MOD+MOD)%MOD*(to[a]-max(b,a+2)))%MOD;
		td=(tc+x[a]*(yy[to[a]].first-yy[a+2].first+MOD)%MOD-y[a]*(xx[to[a]].first-xx[a+2].first+MOD)%MOD+MOD)%MOD;
		ans=(ans-(td<<1)+(MOD<<1))%MOD;
		tc=(tc-(y[a]*x[a+1]%MOD-x[a]*y[a+1]%MOD+MOD)%MOD*(to[a]-a-2)%MOD+yy[to[a]].second-yy[a+2].second-xx[to[a]].second+xx[a+2].second+MOD*3)%MOD;
		to[a]++;
	}
	printf("%I64d\n",ans);
	//system("pause");
	return 0;
}
