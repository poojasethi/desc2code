#include<algorithm>
#include<cstring>
#include<cstdio>
#include<vector>
#include<queue>
#include<set>
using namespace std;

typedef long long LL;
typedef vector<int> VI;
typedef pair<int,int> PII;

#define FOR(x,y,z) for(int x=y;x<=z;++x)
#define FORD(x,y,z) for(int x=y;x>=z;--x)
#define FOReach(x,Z) for(__typeof((Z).begin()) x=(Z).begin();x!=(Z).end();++x)
#define REP(x,y) for(int x=0;x<y;++x)

#define PB push_back
#define ALL(X) (X).begin(),(X).end()
#define SZ(X) ((int)(X).size())
#define CLR(X,x) memset(X, x, sizeof(X))

#define MP make_pair
#define ST first
#define ND second

#define DBG

#ifdef DBG
#define debug printf
#else
#define debug(fmt, ...)
#endif


const int MAX = 200;
const int INF = 1000000001;

PII H[MAX+1];
PII T[MAX+1];
int D[MAX+1][MAX+1];
int in[MAX+1][MAX+1];
int out[MAX+1][MAX+1];
int pre;

int h, t, r;
int n, m;

int dfs(int vh, int vt) {
	if(vh + vt > r)
		return 0;
	if(!D[vh][vt]) {
		FOR(i,1,min(n, vh))
		{
			int nh = vh - i + H[i].ST;
			int nt = vt + H[i].ND;
			D[vh][vt] = max(D[vh][vt], dfs(nh, nt));
		}
		FOR(i,1,min(m, vt))
		{
			int nh = vh + T[i].ST;
			int nt = vt - i + T[i].ND;
			D[vh][vt] = max(D[vh][vt], dfs(nh, nt));
		}
		++D[vh][vt];
	}
	return D[vh][vt];
}

bool cycle(int vh, int vt) {
	in[vh][vt] = ++pre;
	FOR(i,1,min(n, vh))
	{
		int nh = vh - i + H[i].ST;
		int nt = vt + H[i].ND;
		if(nh + nt > r)
			continue;
		if(!in[nh][nt]) {
			if(cycle(nh, nt))
				return true;
		}
		else {
			if(in[nh][nt] <= in[vh][vt] && !out[nh][nt])
				return true;
		}
	}
	FOR(i,1,min(m, vt))
	{
		int nh = vh + T[i].ST;
		int nt = vt - i + T[i].ND;
		if(nh + nt > r)
			continue;
		if(!in[nh][nt]) {
			if(cycle(nh, nt))
				return true;
		}
		else {
			if(in[nh][nt] <= in[vh][vt] && !out[nh][nt])
				return true;
		}
	}
	out[vh][vt] = ++pre;
	return false;
}

void bfs() {
	vector<PII> Q;
	Q.PB(MP(h, t));
	D[h][t] = 1;
	REP(foo,Q.size())
	{
		PII v = Q[foo];
		FOR(i,1,min(n, v.ST))
		{
			int nh = v.ST - i + H[i].ST;
			int nt = v.ND + H[i].ND;
			if(nh + nt > r)
				continue;
			if(!D[nh][nt]) {
				D[nh][nt] = D[v.ST][v.ND] + 1;
				Q.PB(MP(nh, nt));
			}
		}
		FOR(i,1,min(m, v.ND))
		{
			int nh = v.ST + T[i].ST;
			int nt = v.ND - i + T[i].ND;
			if(nh + nt > r)
				continue;
			if(!D[nh][nt]) {
				D[nh][nt] = D[v.ST][v.ND] + 1;
				Q.PB(MP(nh, nt));
			}
		}
	}
	if(D[0][0])
		printf("Ivan\n%d\n", D[0][0]-1);
	else if(cycle(h, t))
		printf("Draw\n");
	else {
		FOR(i,0,r)
			FOR(j,0,r)
				D[i][j] = 0;
		printf("Zmey\n%d\n", dfs(h, t));
	}
}

int main(int argc, char *argv[]) {
	scanf("%d %d %d", &h, &t, &r);
	scanf("%d", &n);
	FOR(i,1,n)
		scanf("%d %d", &H[i].ST, &H[i].ND);
	scanf("%d", &m);
	FOR(i,1,m)
		scanf("%d %d", &T[i].ST, &T[i].ND);
	bfs();
	return 0;
}

