// be namee khoda

#include <iostream>
#include <vector>
#include <queue>

using namespace std;

#define F first
#define S second
#define pb push_back
#define mp make_pair

const int maxn = 210;
typedef pair <int, int> pii;

int dis[2*maxn][2*maxn];
vector <pii> adj[2 * maxn][2 * maxn];
int R, h, t, n, m, dp[2*maxn][2*maxn];
pii ch[maxn], ct[maxn];
queue <pii> Q;
short mark[2*maxn][2*maxn];

void clear_mark()
{
	for (int i = 0; i < 2 * maxn; i++)
		for (int j = 0; j < 2 * maxn; j++)
		{
			mark[i][j] = 0;
			dp[i][j] = -1;
		}
}

void input()
{
	cin >> h >> t >> R;
	cin >> n;
	for (int i = 0; i < n; i++)
		cin >> ch[i].F >> ch[i].S;
	cin >> m;
	for (int i = 0; i < m; i++)
		cin >> ct[i].F >> ct[i].S;
	for (int i = 0; i < 2 * maxn; i++)
		for (int j = 0; j < 2 * maxn; j++)
			dis[i][j] = -1;
}

bool valid (int x, int y)
{
	return (x > -1 && y > -1);
}

void make_adj()
{
	for (int i = 0; i <= maxn; i++)
		for (int j = 0; j <= maxn; j++)
		{
			if(i + j > R)
				break;
			for (int k = 0; k < min(i, n); k++)
			{
				int x, y;
				x = i - k - 1 + ch[k].F;
				y = j + ch[k].S;
				if(valid(x, y))
				{
					if(x + y > R)
						adj[i][j].pb( mp(R, R) );
					else
						adj[i][j].pb( mp(x, y) );
				}
			}
			for (int k = 0; k < min(j, m); k++)
			{
				int x,y ;
				x = i + ct[k].F;
				y = j - k - 1 + ct[k].S;
				if(valid(x, y))
				{
					if(x + y > R)
						adj[i][j].pb( mp(R, R) );
					else
						adj[i][j].pb( mp( x, y ) );
				}
			}
		}
}

void BFS()
{
	Q.push( mp(h, t) );
	mark[h][t] = 1;
	dis[h][t] = 0;
	while(!Q.empty())
	{
		pii v = Q.front();
		Q.pop();
		for (int i = 0; i < adj[v.F][v.S].size(); i++)
		{
			pii nextV = adj[v.F][v.S][i];
			if(!mark[nextV.F][nextV.S])
			{
				dis[nextV.F][nextV.S] = dis[v.F][v.S] + 1;
				mark[nextV.F][nextV.S] = 1;
				Q.push(nextV);
			}
		}
	}
	clear_mark();
}

bool dag;

void dfs(pii v)
{
	mark[v.F][v.S] = 1;
	for (int i = 0; i < adj[v.F][v.S].size(); i++)
	{
		pii nV = adj[v.F][v.S][i];
		if(!mark[nV.F][nV.S])
			dfs(nV);
		else if(mark[nV.F][nV.S] == 1)
			dag = 0;
	}
	mark[v.F][v.S] = 2;
}

int memoize (int x, int y, int lx, int ly)
{

	if(x == R && y == R)
		return 0;
	if(dp[x][y] != -1)
		return dp[x][y];
	int ret = 0;
	for (int i = 0; i < adj[x][y].size(); i++)
	{
		pii nV = adj[x][y][i];
		if(lx != nV.F || ly != nV.S)
			ret = max(ret, memoize(nV.F, nV.S, x, y));
	}
	return dp[x][y] = ret + 1;
}

int main()
{
	dag = 1;
	input();
	make_adj();
	BFS();
	if(dis[0][0] != -1)
		cout << "Ivan\n" << dis[0][0] << endl;
	else{
		dfs( mp (h, t) );
		if(!dag)
			cout << "Draw" << endl;
		else
			cout << "Zmey\n" << memoize(h, t, -1, -1) << endl;
	}
}
  		  	 				 	  		  	    		  	