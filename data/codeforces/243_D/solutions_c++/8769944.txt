#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
#include<string>
#include<set>
#define LL long long
#define fi first
#define se second
#define MP make_pair
#define PII pair<int,int>
#define lc (p<<1)
#define rc ((p<<1)+1)
#define mid ((l+r)>>1)
using namespace std;
int n,X,Y,a[1010][1010],c[2000010],tot;
LL ans;
struct node
{
	int Min,flag;
	void push(int num)
	{
		Min=max(Min,num);flag=max(flag,num);
	}
};
struct seg_tre
{
	node tr[5000010];
	void updata(int p)
	{
		tr[p].Min=min(tr[lc].Min,tr[rc].Min);
	}
	void pushdown(int p)
	{
		tr[lc].push(tr[p].flag);tr[rc].push(tr[p].flag);tr[p].flag=0;
	}
	void Cover(int p,int l,int r,int a,int b,int num)
	{
		if (l==a&&r==b)
		{
			tr[p].push(num);return;
		}
		if (tr[p].flag) pushdown(p);
		if (b<=mid) Cover(lc,l,mid,a,b,num);
		else if (a>=mid) Cover(rc,mid,r,a,b,num);
		else 
		{
			Cover(lc,l,mid,a,mid,num);Cover(rc,mid,r,mid,b,num);
		}
		updata(p);
	}
	int GetMin(int p,int l,int r,int a,int b)
	{
		if (l==a&&r==b) return tr[p].Min;
		if (tr[p].flag) pushdown(p);
		if (b<=mid) return GetMin(lc,l,mid,a,b);
		if (a>=mid) return GetMin(rc,mid,r,a,b);
		return min(GetMin(lc,l,mid,a,mid),GetMin(rc,mid,r,mid,b));
	}
}T;
void read(int &x)
{
	char ch=getchar();int mark=1;for(;ch!='-'&&(ch<'0'||ch>'9');ch=getchar());if (ch=='-') mark=-1,ch=getchar();
	for(x=0;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-48;x*=mark;
}
inline int make(const int&x,const int&y){return Y*x-X*y;}
int main()
{
	//freopen("a.txt","r",stdin);
	read(n);read(X);read(Y);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++) read(a[i][j]);
	if (X<0)
	{
		for(int i=1;i<=n/2;i++)
			for(int j=1;j<=n;j++) swap(a[i][j],a[n-i+1][j]);
		X=-X;
	}
	if (Y<0)
	{
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n/2;j++) swap(a[i][j],a[i][n-j+1]);
		Y=-Y;
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			c[++tot]=make(i-1,j);
			c[++tot]=make(i,j-1);
		}
	sort(c+1,c+tot+1);tot=unique(c+1,c+tot+1)-(c+1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			int l=lower_bound(c+1,c+tot+1,make(i-1,j))-c,r=lower_bound(c+1,c+tot+1,make(i,j-1))-c;
			int t=T.GetMin(1,1,tot,l,r);
			if (a[i][j]>t)
			{
				ans+=a[i][j]-t;
				T.Cover(1,1,tot,l,r,a[i][j]);
			}
		}
	printf("%I64d\n",ans);
	return 0;
}
