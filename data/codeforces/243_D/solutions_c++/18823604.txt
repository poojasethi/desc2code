#include <algorithm>
#include <iostream>
#include <climits>
#include <cstring>
#include <cstdio>
using namespace std;

#define lch(u) ((u) << 1)
#define rch(u) (((u) << 1) | 1)

typedef long long i64;

const int N = 1e3 + 10, M = N * N, Inf = INT_MAX / 2;

struct Info {
	int x, y, h, p;
	Info() {}
	Info(int _x, int _y, int _h, int _p) {
		x = _x, y = _y, h = _h, p = _p;
	}
};

inline bool cmp(const Info &a, const Info &b) {
	return a.p < b.p;
}

int n, m, tot, x, y, a[N][N], b[N][N], B[M], h[N][N], val[M * 4];
Info info[M];

int Query(int u, int l, int r, int p, int q) {
	if (q < l || r < p)
		return Inf;
	if (p <= l && r <= q)
		return val[u];
	int m = (l + r) >> 1, qry = 0;
	qry = min(Query(lch(u), l, m, p, q), Query(rch(u), m + 1, r, p, q));
	qry = max(qry, val[u]);
	return qry;
}

void Modify(int u, int l, int r, int p, int q, int mdf) {
	if (q < l || r < p)
		return;
	if (p <= l && r <= q) {
		val[u] = max(val[u], mdf);
		return;
	}
	int m = (l + r) >> 1;
	Modify(lch(u), l, m, p, q, mdf);
	Modify(rch(u), m + 1, r, p, q, mdf);
	val[u] = max(val[u], min(val[lch(u)], val[rch(u)]));
}

int main() {

	scanf("%d %d %d", &n, &x, &y);
	for (int i = 1; i <= n + 1; ++i)
		for (int j = 1; j <= n + 1; ++j) {
			a[i][j] = x * i + y * j;
			b[i][j] = x * j - y * i;
			B[++tot] = b[i][j];
		}
	sort(B + 1, B + tot + 1);
	tot = unique(B + 1, B + tot + 1) - B - 1;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j) {
			int h;
			scanf("%d", &h);
			info[++m] = Info(i, j, h, a[i][j]);
		}
	sort(info + 1, info + m + 1, cmp);
	i64 ans = 0;
	for (int i = 1; i <= m; ++i) {
		int x = info[i].x, y = info[i].y, h = info[i].h;
		int l = min(min(b[x][y], b[x + 1][y]), min(b[x][y + 1], b[x + 1][y + 1]));
		int r = max(max(b[x][y], b[x + 1][y]), max(b[x][y + 1], b[x + 1][y + 1]));
		l = lower_bound(B + 1, B + tot + 1, l) - B;
		r = lower_bound(B + 1, B + tot + 1, r) - B;
		ans += max(0, h - Query(1, 1, tot, l, r - 1));
		Modify(1, 1, tot, l, r - 1, h);
	}
	printf("%I64d\n", ans);

	return 0;
}
