#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define LL long long
using namespace std;
const int inf=0x3f3f3f3f;
struct cube
{
	int x,y;
}A[1000050];
int key[2097152],tag[2097152];
int rev[20000050];
int det[1002050];
int a[1010][1010];
int n,vx,vy,m,tot,N;
int find(int i,int j)
{
	int x,h,t,mid;
	x=vx*j-vy*i; h=1; t=m;
	while (h<t)
	{
		mid=(h+t)/2;
		if (det[mid]>=x) t=mid;
		else h=mid+1;
	}
	return h;
}
inline int dot(cube a)
{
	return a.x*vx+a.y*vy;
}
bool cmp(cube a,cube b)
{
	return dot(a)<dot(b);
}
void release(int i,int l0,int r0)
{
	if (l0<r0)
	{
		tag[i*2]=max(tag[i*2],tag[i]);
		key[i*2]=max(key[i*2],tag[i]);
		tag[i*2+1]=max(tag[i*2+1],tag[i]);
		key[i*2+1]=max(key[i*2+1],tag[i]);
	}
	tag[i]=0;
}
void modify(int i,int l,int r,int l0,int r0,int x)
{
	int mid;
	if ((l0>=l)&&(r0<=r))
	{
		key[i]=max(key[i],x); tag[i]=max(tag[i],x);
	}
	else
	{
		mid=(l0+r0)/2; release(i,l0,r0);
		if (l<=mid) modify(i*2,l,r,l0,mid,x);
		if (r>=mid+1) modify(i*2+1,l,r,mid+1,r0,x);
		key[i]=min(key[i*2],key[i*2+1]);
	}
}
int query(int i,int l,int r,int l0,int r0)
{
	int mid,ans;
	if ((l0>=l)&&(r0<=r)) return key[i];
	mid=(l0+r0)/2; ans=inf; release(i,l0,r0);
	if (l<=mid) ans=min(ans,query(i*2,l,r,l0,mid));
	if (r>=mid+1) ans=min(ans,query(i*2+1,l,r,mid+1,r0));
	return ans;
}
int main()
{
	LL ans;
	int i,j,l,r,z;
	scanf("%d%d%d",&n,&vx,&vy);
	for (i=1;i<=n;i++)
		for (j=1;j<=n;j++) scanf("%d",&a[i][j]);
	if (vx<0)
	{
		vx*=-1;
		for (i=1;i<=n/2;i++)
			for (j=1;j<=n;j++) swap(a[i][j],a[n-i+1][j]);
	}
	if (vy<0)
	{
		vy*=-1;
		for (i=1;i<=n;i++)
			for (j=1;j<=n/2;j++) swap(a[i][j],a[i][n-j+1]);
	}
	tot=0; m=0;
	for (i=0;i<=n;i++)
		for (j=0;j<=n;j++)
		{
			m++; det[m]=i*vy-j*vx;
		}
	sort(det+1,det+m+1);
	j=0;
	for (i=1;i<=m;i++)
		if ((i==1)||(det[i]!=det[i-1]))
		{
			j++; rev[det[i]+10000000]=j;
		}
	m=j;
	for (i=1;i<=n;i++)
		for (j=1;j<=n;j++)
		{
			tot++; A[tot].x=i; A[tot].y=j;
		}
	sort(A+1,A+tot+1,cmp);
	memset(key,0,sizeof(key));
	memset(tag,0,sizeof(tag));
	N=1<<int(ceil(log(m-1)/log(2))); ans=0;
	for (i=1;i<=tot;i++)
	{
		l=rev[(A[i].x-1)*vy-A[i].y*vx+10000000];
		r=rev[A[i].x*vy-(A[i].y-1)*vx+10000000]-1;
		z=query(1,l,r,1,N);
		if (a[A[i].x][A[i].y]>z)
		{
			ans+=a[A[i].x][A[i].y]-z;
			modify(1,l,r,1,N,a[A[i].x][A[i].y]);
		}
	}
	printf("%I64d\n",ans); return 0;
}