#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <queue>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <ctime>

using namespace std;

const int inf = 2000000000;

int h[1000000], axis[2000000], maxv[1 << 22], cover[1 << 22];
pair<int, int> seg[1000000], order[1000000];

int transformX(int x, int y, int vx, int vy) {
	return x * vx + y * vy;
}

int transformY(int x, int y, int vx, int vy) {
	return y * vx - x * vy;
}

int getMax(int i, int l, int r, int l0, int r0) {
	if (l0 <= l && r <= r0) return maxv[i];
	int mid = (l + r) / 2, res = inf;
	if (l0 < mid) res = min(res, getMax(i * 2, l, mid, l0, r0));
	if (r0 > mid) res = min(res, getMax(i * 2 + 1, mid, r, l0, r0));
	return max(res, cover[i]);
}

void update(int i, int l, int r, int l0, int r0, int x) {
	if (l0 <= l && r <= r0) {
		cover[i] = max(cover[i], x);
		maxv[i] = max(maxv[i], x);
		return;
	}
	int mid = (l + r) / 2;
	if (l0 < mid) update(i * 2, l, mid, l0, r0, x);
	if (r0 > mid) update(i * 2 + 1, mid, r, l0, r0, x);
	maxv[i] = max(cover[i], min(maxv[i * 2], maxv[i * 2 + 1]));
}

int main() {
#ifndef ONLINE_JUDGE
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);
#endif
	
	int n, vx, vy;
	scanf("%d%d%d", &n, &vx, &vy);
	int tot = 0;
	for (int i = 0; i < n; i ++)
		for (int j = 0; j < n; j ++) {
			scanf("%d", &h[i * n + j]);
			int l = inf, r = -inf, t = inf;
			for (int d1 = 0; d1 < 2; d1 ++)
				for (int d2 = 0; d2 < 2; d2 ++) {
					int x = transformX(i + d1, j + d2, vx, vy);
					int y = transformY(i + d1, j + d2, vx, vy);
					l = min(l, y);
					r = max(r, y);
					t = min(t, x);
				}
			seg[i * n + j] = make_pair(l, r);
			axis[tot ++] = l;
			axis[tot ++] = r;
			order[i * n + j] = make_pair(t, i * n + j);
		}
	
	sort(axis, axis + tot);
	tot = unique(axis, axis + tot) - axis;
	sort(order, order + n * n);
	memset(maxv, 0, sizeof(maxv));
	
	long long ans = 0;
	for (int i = 0; i < n * n; i ++) {
		int cur = order[i].second;
		int t1 = lower_bound(axis, axis + tot, seg[cur].first) - axis;
		int t2 = lower_bound(axis, axis + tot, seg[cur].second) - axis;
		int t = getMax(1, 0, tot, t1, t2);
		if (h[cur] > t) {
			ans += h[cur] - t;
			update(1, 0, tot, t1, t2, h[cur]);
		}
	}
	printf("%I64d\n", ans);
	
	return 0;
}
