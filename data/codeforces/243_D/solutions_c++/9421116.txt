#include <cstdio>
#include <algorithm>
const int N = 1009;
struct point
{
	int x,y;
	point():x(0),y(0){}
	point(const int _x,const int _y):
		x(_x),y(_y){}
}p[N * N],U,V;
struct tower
{
	int l,r,d,h;
	bool operator < (const tower &o)const{return d < o.d;}
}a[N * N];
int Min[N * N * 4],L,R,val,n,m;
long long ans;
bool tag[N * N * 4];
inline int cpr(const point &a,const point &b,const point &c)
{
	return (b.x - a.x) * (c.y - a.y) - (c.x - a.x) * (b.y - a.y);
}
inline bool operator < (const point &a,const point &b)
{
	return cpr(a,point(a.x + V.x,a.y + V.y),b) > 0;
}
inline bool operator == (const point &a,const point &b)
{
	return cpr(a,point(a.x + V.x,a.y + V.y),b) == 0;
}
inline point rotate(const point &o)
{
	return point(-o.y,o.x);
}
int _modify(const int id,const int l,const int r)
{
	if (Min[id] >= val) return 0x7fffffff;
	if (L <= l && r <= R) {int res = Min[id]; Min[id] = val; tag[id] = true; return res;}
	if (tag[id]) {
		tag[id] = false; tag[id * 2] = tag[id * 2 + 1] = true;
		if (Min[id * 2] < Min[id]) Min[id * 2] = Min[id];
		if (Min[id * 2 + 1] < Min[id]) Min[id * 2 + 1] = Min[id];
	}
	const int mid = (l + r) / 2;
	int res = 0x7fffffff;
	if (L < mid) res = _modify(id * 2,l,mid);
	if (mid < R) res = std::min(res,_modify(id * 2 + 1,mid,r));
	Min[id] = std::min(Min[id * 2],Min[id * 2 + 1]);
	return res;
}
int modify(const tower &o)
{
	L = o.l; R = o.r; val = o.h;
	if (L == R) puts("^ ^");
	if (!val) return 0;
	int tmp = _modify(1,1,m);
	if (tmp < val) return val - tmp;
	else return 0;
}
int main()
{
	#ifndef ONLINE_JUDGE
	freopen("243D.in","r",stdin);
	freopen("243D.out","w",stdout);
	#endif
	scanf("%d%d%d",&n,&V.x,&V.y);
	U = rotate(V);
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j) {
			p[++m] = point(i,j);
			scanf("%d",&a[m].h);
		}
	for (int i = 1; i <= n; ++i) p[++m] = point(0,i);
	for (int i = 0; i <= n; ++i) p[++m] = point(i,0);
	std::sort(p + 1,p + 1 + m);
	m = std::unique(p + 1,p + 1 + m) - p - 1;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j) {
			point l = std::min(std::min(point(i,j),point(i - 1,j)),std::min(point(i,j - 1),point(i - 1,j - 1)));
			point r = std::max(std::max(point(i,j),point(i - 1,j)),std::max(point(i,j - 1),point(i - 1,j - 1)));
			a[(i - 1) * n + j].l = std::lower_bound(p + 1,p + 1 + m,l) - p;
			a[(i - 1) * n + j].r = std::lower_bound(p + 1,p + 1 + m,r) - p;
			a[(i - 1) * n + j].d = -cpr(point(i,j),point(0,0),U);
		}
	std::sort(a + 1,a + 1 + n * n);
	for (int i = 1; i <= n * n; ++i) ans += modify(a[i]);
	printf("%I64d\n",ans);
}
