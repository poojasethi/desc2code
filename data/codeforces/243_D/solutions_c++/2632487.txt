#include <iostream>
#include <sstream>
#include <string>
#include <vector>
#include <deque>
#include <queue>
#include <set>
#include <map>
#include <algorithm>
#include <functional>
#include <utility>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstdio>

using namespace std;

#define REP(i,n) for((i)=0;(i)<(int)(n);(i)++)
#define foreach(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)

typedef long long ll;

int N;
int a[1010][1010],b[1010][1010];
int vx,vy;

vector <pair <int, pair <int, int> > > queries;
vector <int> v,w;

int mp(int x){
    int low = 0, high = v.size();
    while(high-low > 1){
        int mid = (low + high) / 2;
        if(v[mid] <= x) low = mid; else high = mid;
    }
    return low;
}

#define T (1<<20)
struct node {int val, min;};
node tree[2*T];

void update_query(int L, int R, int h, int id = 1, int low = 0, int high = T){
    if(L <= low && R >= high){
        tree[id].val = max(tree[id].val, h);
        tree[id].min = max(tree[id].min, h);
        return;
    }
    
    int mid = (low + high) / 2;
    
    if(L < mid) update_query(L, R, h, 2*id, low, mid);
    if(R > mid) update_query(L, R, h, 2*id+1, mid, high);
    
    tree[id].min = max(tree[id].val, min(tree[2*id].min, tree[2*id+1].min));
}

int min_query(int L, int R, int id = 1, int low = 0, int high = T){
    if(L <= low && R >= high) return tree[id].min;
    
    int ans = (1<<30);
    int mid = (low + high) / 2;
    if(L < mid) ans = min(ans, min_query(L, R, 2*id, low, mid));
    if(R > mid) ans = min(ans, min_query(L, R, 2*id+1, mid, high));
    ans = max(ans, tree[id].val);
    
    return ans;
}

int query(int L, int R, int h){ // cout << "q " << L << ' ' << R << ' ' << h << endl;
    int ans = min_query(L, R);
//  cout << ans << endl;
    update_query(L, R, h);
    if(ans > h) return 0;
    return h - ans;
}

int main(void){
    int i,j;
    
    cin >> N >> vx >> vy;
    REP(i,N) REP(j,N) scanf("%d",&a[i][j]);
    
    while(vx < 0 || vy < 0){
        swap(vx,vy);
        vx = -vx;
        REP(i,N) REP(j,N) b[i][j] = a[i][j];
        REP(i,N) REP(j,N) a[i][j] = b[j][N-1-i];
    }
    
    REP(i,N) REP(j,N) queries.push_back(make_pair(i*vx+j*vy, make_pair(i,j)));
    sort(queries.begin(),queries.end());
    
    REP(i,N+1) REP(j,N+1) w.push_back(i*vy - j*vx);
    sort(w.begin(),w.end());
    REP(i,w.size()) if(i+1 == w.size() || w[i] < w[i+1]) v.push_back(w[i]);
    
    REP(i,2*T) tree[i].val = tree[i].min = 0;
    
    ll ans = 0;
    REP(i,queries.size()){
        int x = queries[i].second.first, y = queries[i].second.second;
        int L = x*vy-y*vx-vx, R = x*vy-y*vx+vy;
        int tmp = query(mp(L), mp(R), a[x][y]);
        ans += tmp;
    }
    
    cout << ans << endl;
    
    return 0;
}