#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <set>
#include <vector>
#include <cstdio>
using namespace std;

#define FOR(i,m,n) for(int i=m; i<n; i++)
#define ms(obj, val) memset(obj, val, sizeof(obj))
#define mp make_pair
#define pb push_back
#define ri(a) scanf("%d",&a)
#define rii(a,b) scanf("%d%d",&a,&b)

typedef long long ll;
typedef vector<int> vi;
const int MAXK=1000001;
const int MAXN=1001;
const ll MOD=1000000007;

ll sq(ll a){return a*a;}
ll modExp(ll a, ll e){return e? sq(modExp(a, e/2))%MOD*(e&1 ? a: 1)%MOD : 1;}
ll fact[MAXK];
ll factInv[MAXK];

void fillFact(){
	fact[0]=factInv[0]=1;
	FOR(i, 1, MAXK) fact[i]=(fact[i-1]*i)%MOD;
	FOR(i, 1, MAXK) factInv[i]=modExp(fact[i], MOD-2);
}

ll c(int n, int m){
	if(m>n) return 0;
	return fact[n]*factInv[m]%MOD*factInv[n-m]%MOD;
}

ll S[MAXN][MAXN];
void iniS(){
	FOR(i, 0, MAXN) FOR(j, 0, MAXN) S[i][j]=-1;
	FOR(i, 0, MAXN) S[i][0]=S[0][i]=0;
	S[0][0]=1;
}
ll s(int n, int k){
	if(S[n][k]>=0) return S[n][k];
	if(k>n) return S[n][k]=0;
	return S[n][k]=(k*s(n-1, k)%MOD+s(n-1, k-1))%MOD;
}

int main(){
	fillFact();
	iniS();
	
	int n, m, k;
	ll res=0;
	cin>>n>>m>>k;
	if(m==1){
		cout<<modExp(k, n)<<endl;
		return 0;
	}
	if(m==2){
		FOR(p, 1, min(n, k)+1) {
			ll ag=sq(c(k, p)*s(n, p)%MOD*fact[p]%MOD)%MOD;
			res=(res+ag)%MOD;
		}
		cout<<res<<endl;
		return 0;
	}
	FOR(p, 1, min(n, k)+1) FOR(a, 0, min(n, k)+1-p){
		ll ag=c(k, p)*c(k-p, a)%MOD*c(k-p-a, a)%MOD;
		ag=ag*(sq(s(n, p+a)*fact[p+a]%MOD)%MOD)%MOD;
		ag=ag*modExp(p, n*(m-2))%MOD;
		res=(res+ag)%MOD;
	}
	cout<<res<<endl;
	
}
