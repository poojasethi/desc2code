#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<vector>
#define N 100005
using namespace std;
int a,b,c,d,e,f,g[N],h,i,j,k;
struct node
{
    int left,right;
    int id;
    int an;
};
node Q[N];
int end[N];
int next[N];

int lowbit(int x){return x & (-x);}
struct ShuZhuangShuZu
{
    int x[N];
    void Add(int begin,int y)
    {
        for(int ii = begin; ii <= a; ii += lowbit(ii))
            x[ii] += y;
    }
    int Sigma(int xx)
    {
        int R = 0;
        for(int ii = xx; ii; ii -= lowbit(ii))
            R += x[ii];
        return R;
    }
};
ShuZhuangShuZu A,B;

bool cmp_Right(node x,node y)
{
    return x.right < y.right;
}
bool cmp_Id(node x,node y)
{
    return x.id < y.id;
}

int main()
{
    cin >> a;
    for(i = 1; i <= a; i ++)
    {
        cin >> g[i];
        next[i] = end[g[i]];
        end[g[i]] = i;
    }
    cin >> b;
    for(i = 1; i <= b; i ++)
    {
        cin >> Q[i].left >> Q[i].right;
        Q[i].id = i;
    }
    sort(Q + 1, Q + b + 1, cmp_Right);
    memset(end, 0, sizeof(end));
    int now = 1;
    for(i = 1; i <= a; i ++)
    {
        A.Add(next[i] + 1, 1);
        A.Add(i + 1, -1);
        int father = next[i];
        int grand = next[father];
        if(grand != 0 && i - father != father - grand)
        {
            B.Add(end[g[i]] + 1, 1);
            end[g[i]] = grand;
            B.Add(end[g[i]] + 1, -1);
        }
        while(Q[now].right == i)
        {
            int t1 = A.Sigma(Q[now].left);
            int t2 = B.Sigma(Q[now].left);
            Q[now].an = t1 + (t1 == t2);
            now ++;
        }
    }
    sort(Q + 1, Q + b + 1, cmp_Id);
    for(i = 1; i <= b; i ++)
    {
        cout << Q[i].an << endl;
    }
    return 0;
}