#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#define mp make_pair
using namespace std;

const int N = 100005;

bool cmp(const pair<pair<int,int>, int>&a, const pair<pair<int,int>, int>&b){
	return a.first.second < b.first.second;
}

int cnt1[N], cnt2[N];
void add(int x, int val, int c[]){
    for(; x<N; x+=x&-x){
        c[x] += val;
    }
}

int sum(int x, int c[]){
    int res;
    for(res=0; x; x-=x&-x){
        res += c[x];
    }
    return res;
}

int a[N];
pair<pair<int,int>, int> Q[N];
pair<int,int> ans[N];
int pre[N], delta[N], put[N];
int main(){
    int n, i, m, j;
	scanf("%d",&n);
	for(i = 1; i <= n; ++i)
		scanf("%d",&a[i]);
	scanf("%d",&m);
	for(i = 1; i <= m; ++i){
	    int l, r;
		scanf("%d%d",&l,&r);
		Q[i] = mp(mp(l, r), i);
	}
	sort(Q+1, Q+m+1, cmp);

    memset(delta, -1, sizeof(delta));
    memset(pre, 0, sizeof(pre));
	int last = 0, mark;
	for(i = 1; i <= m; i = j){
		mark = Q[i].first.second;
		for(j = last+1; j <= mark; ++j){
			if(!pre[a[j]]){
			    add(1, 1, cnt1);
                add(1, 1, cnt2);
				add(j+1, -1, cnt1);
				add(j+1, -1, cnt2);
				pre[a[j]] = j;
				put[a[j]] = 1;
			}
			else{
			    add(pre[a[j]]+1, 1, cnt1);
			    add(pre[a[j]]+1, 1, cnt2);
			    add(j+1, -1, cnt1);
			    add(j+1, -1, cnt2);
				if(delta[a[j]] == -1 || delta[a[j]] == j-pre[a[j]]){
                    delta[a[j]] = j-pre[a[j]];
				}
				else{
				    add(put[a[j]], -1, cnt2);
				    add(put[a[j]]=pre[a[j]]-delta[a[j]]+1, 1, cnt2);
                    delta[a[j]] = j-pre[a[j]];
				}
				pre[a[j]] = j;
			}
		}
		for(j = i; j <=m && Q[j].first.second == mark; ++j){
		    int tmp1, tmp2;
			int res = 1 + (tmp1=sum(Q[j].first.first, cnt1)) - ((tmp2=sum(Q[j].first.first, cnt2)) >= 1);
			ans[j] = mp(Q[j].second, res);
		}
		last = mark;
	}
	sort(ans+1, ans+m+1);
	for(i = 1; i <= m; ++i)
		printf("%d\n", ans[i].second);
	return 0;
}


/*
10
1 2 2 1 2 1 2 1 2 1
2
1 10
2 10
*/
