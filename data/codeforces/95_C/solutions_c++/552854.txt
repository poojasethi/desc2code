#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <queue>

#define REP(AA,BB) for(int AA=0; AA<(BB); ++AA)
#define FOR(AA,BB,CC) for(int AA=(BB); AA<(CC); ++AA)
#define FC(AA,BB) for(__typeof((AA).begin()) BB=(AA).begin(); BB!=(AA).end(); ++BB)
#define SZ(AA) ((int)((AA).size()))
#define ALL(AA) (AA).begin(), (AA).end()
#define PB push_back
#define MP make_pair

using namespace std;

typedef vector<int> VI;
typedef pair<int, int> PII;
typedef long long LL;
typedef long double LD;

vector<PII> ae[1010], be[1010];
LL d[1010]; LL INF = LL(1e15);
int n;

void dijkstra(int v, vector<PII> ve[]) {
	REP(i,n)
		d[i]=INF;
	d[v]=0;
	priority_queue<pair<LL, int>, vector<pair<LL, int> >, greater<pair<LL, int> > > PQ;
	PQ.push(MP(0, v));
	while(!PQ.empty()) {
		v=PQ.top().second; LL c=PQ.top().first; PQ.pop();
		if(d[v]>c)
			continue;
		FC(ve[v],it) {
			LL can=it->second+d[v];
			if(can<d[it->first]) {
				d[it->first]=can;
				PQ.push(MP(d[it->first], it->first));
			}
		}
	}
}

int main(void) {
	int m, x, y; scanf("%d%d%d%d", &n, &m, &x, &y);
	--x; --y;
	REP(i,m) {
		int a, b, c; scanf("%d%d%d", &a, &b, &c);
		--a; --b;
		ae[a].PB(MP(b, c));
		ae[b].PB(MP(a, c));
	}
	REP(i,n) {
		dijkstra(i, ae);
		int t, c; scanf("%d%d", &t, &c);
		REP(j,n) {
			if(d[j]<=t)
				be[i].PB(MP(j, c));
		}
	}
	dijkstra(x, be);
	if(d[y]<INF)
		printf("%I64d\n", d[y]);
	else
		puts("-1");
	return 0;
}

