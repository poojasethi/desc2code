#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#define N 1005
#define M 2005
using namespace std;

struct node{
	int x;
	long long s;
	node(){}
	node(int x, long long s):x(x),s(s){}
	bool operator < (node const &T) const{return s > T.s;}
}	T;

int n, m, st, ed, x, y, w, t, l[N], cost[N], qd[M], qn[M], ql[M];
long long lim[N], dist[N][N], dp[N];
priority_queue<node> q;



void bd(int x, int y, int w){
	qd[++t]=y, qn[t]=l[x], l[x]=t, ql[t]=w;
}

int main(){

	scanf("%d%d", &n, &m);
	scanf("%d%d", &st, &ed);
	while(m--) scanf("%d%d%d", &x, &y, &w), bd(x, y, w), bd(y, x, w);
	
	for (int i=1; i<=n; i++){
		scanf("%d%d", &lim[i], &cost[i]);
		
		for (int j=1; j<=n; j++) dist[i][j] = -1;
		
		q.push(node(i, 0));
		while (!q.empty()){
			T = q.top();
			q.pop();
			if (T.s > lim[i]) continue;
			if (dist[i][T.x] != -1) continue;
			
			dist[i][T.x] = T.s;
			for (int k=l[T.x]; k; k=qn[k]) q.push(node(qd[k], T.s+ql[k]));
		}
		
	}
	
	q.push(node(st, 0));
	memset(dp, -1, sizeof(dp));
	while (!q.empty()){
		T = q.top();
		q.pop();
		if (dp[T.x] != -1) continue;
		
		dp[T.x] = T.s;
		for (int i=1; i<=n; i++){
			if (dist[T.x][i]!=-1 && dist[T.x][i] <= lim[T.x]) q.push(node(i, T.s+cost[T.x]));
		}
	}
	
	printf("%I64d\n", dp[ed]);

	return 0;
}
