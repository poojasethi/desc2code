#include <iostream>
#include <iomanip>
#include <fstream>
#include <algorithm>
#include <cassert>
#include <cctype>
#include <cmath>
#include <complex>
#include <cstdio>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <vector>
using namespace std;

#define INF 1e16
#define EPS 1e-9
#define rep(i,n) for(int i=0;i<n;i++)

typedef long long ll;
typedef pair<ll,int> P;
struct edge{
	int to;ll cost;
	edge(int to,ll cost):to(to),cost(cost){}
};

ll d[1000],n,m,s,f;
vector<edge> g[1000],G[1000];

void dijkstra(int s){
	priority_queue<P,vector<P>,greater<P> > q;
	fill(d,d+n,INF);
	d[s]=0;
	q.push(P(0,s));
	while(!q.empty()){
		P p=q.top();q.pop();
		int v=p.second;
		if(d[v]<p.first)continue;
		rep(i,g[v].size()){
			edge e=g[v][i];
			if(d[e.to]>d[v]+e.cost){
				d[e.to]=d[v]+e.cost;
				q.push(P(d[e.to],e.to));
			}
		}
	}
}

int main(){
	cin>>n>>m>>s>>f;
	s--;f--;
	rep(i,m){
		ll u,v,w;
		cin>>u>>v>>w;
		u--;v--;
		g[u].push_back(edge(v,w));
		g[v].push_back(edge(u,w));
	}
	rep(i,n){
		ll t,c;
		cin>>t>>c;
		dijkstra(i);
		rep(j,n)if(d[j]<=t)G[i].push_back(edge(j,c));
	}
	rep(i,n)g[i]=G[i];
	//rep(i,n){cout<<i<<endl;rep(j,g[i].size())cout<<g[i][j].to<<" "<<g[i][j].cost<<endl;}
	dijkstra(s);
	//rep(i,n)cout<<d[i]<<" ";cout<<endl;
	cout<<((d[f]==INF)?-1:d[f])<<endl;
}
