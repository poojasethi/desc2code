//#define _GLIBCXX_DEBUG
#include <cassert>
#include <cstdio>
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
using namespace std;

#define REP(i,n) for(int i=0;i<int(n);++i)
#define AUTO(v,e) __typeof__(e) v = (e)
#define FOR(it,c) for(AUTO (it,(c).begin()); (it) != (c).end(); ++(it))

typedef pair<int, int> edge; // cost dest
typedef vector<edge> edges;
typedef vector<edges> graph;
typedef long long ll;
const ll INF = 1LL<<60;

void dijkstra(int s, const graph& g, ll *ds, int n) {
    multimap<ll, int> q;
    fill(ds, ds + n, INF);
    ds[s] = 0;
    q.insert(make_pair(0, s));
    while (!q.empty()) {
	int v = q.begin()->second;
	ll d = q.begin()->first;
	q.erase(q.begin());
	FOR (it, g[v]) {
	    ll nd = d + it->first;
	    int nv = it->second;
	    if (ds[nv] > nd) {
		ds[nv] = nd;
		q.insert(make_pair(nd, nv));
	    }
	}
    }
}

int main() {
    int n, m, x, y;
    cin >> n >> m >> x >> y;
    --x, --y;
    graph g0(n), g1(n);
    REP (i, m) {
	int u, v, w;
	cin >> u >> v >> w;
	--u, --v;
	g0[u].push_back(edge(w, v));
	g0[v].push_back(edge(w, u));
    }
    static int ls[1234], cs[1234];
    REP (i, n) cin >> ls[i] >> cs[i];
    static ll mat[1234][1234], ds[1234];
    REP (i, n) dijkstra(i, g0, mat[i], n);
    REP (i, n) REP (j, n)
	if (mat[i][j] <= ls[i])
	    g1[i].push_back(edge(cs[i], j));
    dijkstra(x, g1, ds, n);
    cout << (ds[y] >= INF ? -1 : ds[y]) << endl;
}
