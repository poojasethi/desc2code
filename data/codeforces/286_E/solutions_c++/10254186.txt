#include <cmath>
#include <cstdio>
#include <vector>
#include <algorithm>

#define sz(v) (int)(v).size()
#define rep(i,j,k) for (int (i)=(j);(i)<=(k);++(i))

using namespace std;

const int M=(int)1e6;
const double pi=acos(-1);

vector<int> v;
int t[M+10],rev[M*4+10];

struct complex{
	double re,im;
	complex(double _re=0,double _im=0):
		re(_re),im(_im){
		}
	inline complex operator +(const complex &t){
		return complex(re+t.re,im+t.im);
	}
	inline complex operator -(const complex &t){
		return complex(re-t.re,im-t.im);
	}
	inline complex operator *(const complex &t){
		return complex(re*t.re-im*t.im,re*t.im+im*t.re);
	}
}a[M*4+10],b[M*4+10];

void FFT(complex a[],int f,int n){
	rep(i,0,n-1) if (i<rev[i]) swap(a[i],a[rev[i]]);
	for (int i=2;i<=n;i<<=1){
		complex wn(cos(2*pi/i),f*sin(2*pi/i));
		for (int k=0;k<n;k+=i){
			complex w(1);
			rep(j,0,i/2-1){
				complex x=a[k+j],y=w*a[k+j+i/2];
				a[k+j]=x+y;
				a[k+j+i/2]=x-y;
				w=w*wn;
			}
		}
	}
	if (f==-1) rep(i,0,n-1) a[i].re/=n;
}

int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	rep(i,1,n){
		int x;
		scanf("%d",&x);
		a[x].re=b[x].re=t[x]=1;
	}
	int fn,fl;
	for (fn=1,fl=0;fn<m+1;fn<<=1,fl++);
	fn<<=1;
	fl++;
	rep(i,0,fn-1) rep(j,0,fl-1) rev[i]=(rev[i]<<1)+(i>>j&1);
	FFT(a,1,fn);
	FFT(b,1,fn);
	rep(i,0,fn-1) a[i]=a[i]*b[i];
	FFT(a,-1,fn);
	rep(i,1,m) if (lround(a[i].re) && !t[i]){
		puts("NO");
		return 0;
	}
	rep(i,1,m) if (t[i] && !lround(a[i].re)) v.push_back(i);
	printf("YES\n%d\n",sz(v));
	rep(i,0,sz(v)-1) printf("%d%c",v[i]," \n"[i==sz(v)-1]);
	return 0;
}
