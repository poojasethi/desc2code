#include <cstdio>
#include <complex>
#include <cmath>
#include <algorithm>

using namespace std;

const int N=1<<21;
const double PI=acos(-1.0);

void FFT(complex<double> a[],int n,int oper) { // n must be 2^k
	for (int i=1,j=0;i<n;i++) {
		for (int s=n;j^=s>>=1,~j&s;);
		if (i<j) swap(a[i],a[j]);
	}
	for (int m=1;m<n;m<<=1) {
		int m2=m<<1;
		double p=PI/m*oper;
		complex<double> w=complex<double>(cos(p),sin(p));
		for (int i=0;i<n;i+=m2) {
			complex<double> unit=1;
			for (int j=0;j<m;j++) {
				complex<double> &x=a[i+j+m],&y=a[i+j];
				complex<double> t=unit*x;
				x=y-t;
				y=y+t;
				unit*=w;
			}
		}
	}
	if (oper==-1)
		for (int i=0;i<n;i++) a[i]/=n;
}

int a[N],b[N],c[N];
int n,m,nn;

void square() {
	static complex<double> c[N];
	for (int i=0;i<nn;i++) c[i]=a[i];
	FFT(c,nn,1);
	for (int i=0;i<nn;i++) c[i]*=c[i];
	FFT(c,nn,-1);
	for (int i=0;i<nn;i++) b[i]=c[i].real()+0.5;
}
int calans() {
	int ans=0;
	for (int i=1;i<=m;i++) {
		if (b[i]&&!a[i]) return -1;
		if (a[i]&&!b[i]) ans++;
	}
	return ans;
}
int main() {
	int i;
	scanf("%d%d",&n,&m);
	nn=1;
	while (nn<=m*2) nn<<=1;
	for (i=0;i<n;i++) {
		scanf("%d",&c[i]);
		a[c[i]]++;
	}
	square();
	int ans=calans();
	if (~ans) {
		printf("YES\n");
		printf("%d\n",ans);
		bool flag=false;
		for (i=1;i<=m;i++) if (a[i]&&!b[i]) {
			if (flag) printf(" %d",i);
			else printf("%d",i);
			flag=true;
		}
		printf("\n");
	} else printf("NO\n");
	return 0;
}
