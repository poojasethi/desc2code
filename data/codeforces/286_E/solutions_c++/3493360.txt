#include <bits/stdc++.h>
#define fr(i,a,b) for(int i=a;i<b;i++)
#define rep(i,b) fr(i,0,b)

using namespace std;
typedef complex<double> cp;

typedef complex<double> T;

typedef vector<T> VT;
const int maxn = 1<<21;
T _A[maxn];

void fft(T* A, int n, bool inv = false) {
if(n==1) return;
T *A0=A,*A1=A+n/2; rep(i,n) _A[i]=A[i];
rep(i,n/2) A0[i]=_A[2*i], A1[i]=_A[2*i+1];
fft(&A0[0],n/2,inv), fft(&A1[0],n/2,inv);
T w=exp(T(0,(inv?-2:2)*M_PI/n)), wnow=T(1,0);
rep(i,n/2)
_A[i]=A0[i]+wnow*A1[i],
_A[i+n/2]=A0[i]-wnow*A1[i],wnow*=w;
rep(i,n) A[i]=_A[i];
}

void multiply(T* A, int ta) {
int n = ta + ta;
while(n & (n-1)) n++;
fft(&A[0],n,false);
rep(i,n) A[i] *= A[i];
fft(&A[0],n,true);
rep(i,n) A[i] /= n;
}

int r[maxn];
bool mk[maxn];
T va[maxn];

int main(){
    int n, w, v;
    scanf("%d %d",&n,&w);
    rep(i,n) scanf("%d",&v), va[v] = T(1.0,0.0), mk[v]=true;
    
    //rep(i,w+1) printf(" (%d - %.2lf)\n",i,va[i]);
    
    multiply(va,w+1);
    
    int pnt=0;
    bool rsp=true;
    rep(i,w+1){
        //printf("%d - %.2lf\n",i,vc[i]);
        if(va[i].real()>1e-3){
            if(!mk[i]){
                //if(w==1000000) printf("[%d %.10lf]\n",i,vc[i]);
                rsp = false; break; 
            }
        }else if(mk[i]) r[pnt++] = i;
    }
    if(rsp){
        printf("YES\n%d\n",pnt);
        rep(i,pnt){
            if(i) printf(" ");
            printf("%d",r[i]);
        }
        printf("\n");
    }else
        printf("NO\n");
        
    return 0;
}
