#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<algorithm>

using namespace std;

struct UnionFind{
    int p[100050], cnt[100050];
    void set(int N){ for(int i = 0; i <= N; i++) cnt[i] = 1, p[i] = -1; }
    int find(int x){ return p[x] == -1? x: p[x] = find(p[x]); }
    bool merge(int a,int b){
        int x = find(a), y = find(b);
        if( x == y ) return false;
        if( cnt[x] >= cnt[y] ){
            p[y] = x; cnt[x] += cnt[y];
        }
        else p[x] = y; cnt[y] += cnt[x];
        return true;
    }
} uf[2];

int main()
{
    int N, K, tot[2] = {0};
    scanf("%d%d", &N, &K);
    uf[0].set(N+10); uf[1].set(N+10);
    for(int i = 1; i <= K; i++){
        char ord[10];
        int x, y, ch, ad;
        scanf("%d%d%s", &x, &y, ord);
        ch = (ord[0]=='o'?1:0);
        int s = x+y-2, e = x-y;
        if( s > N-1 ) s = 2*N-2-s;
        if( e < 0 ) e = -e;
        ad = e%2;
        e = e/2+1, s = s/2+1;
        if( s > e ) swap(s, e);
        if( ch == 0 ) tot[ad] += uf[ad].merge( (s-1)*2, e*2 ), uf[ad].merge( (s-1)*2+1, e*2+1 );
        else tot[ad] += uf[ad].merge( (s-1)*2+1, e*2 ), uf[ad].merge( (s-1)*2, e*2+1 );
    }
    for(int i = 0; i < N/2+2; i++){
        for(int j = 0; j < 2; j++){
            if( uf[j].find( 2*i ) == uf[j].find( 2*i+1 ) ){
                printf("0");
                return 0;
            }
        }
    }
    int ans = 1;
    for(int i = 1; i <= N - tot[0] - tot[1]; i++){
        ans *= 2;
        ans %= 1000000007;
    }
    printf("%d", ans);
}