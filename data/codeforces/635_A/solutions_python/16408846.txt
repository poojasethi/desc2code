#!/usr/bin/python

import sys, os, subprocess, time, optparse, collections
from pprint import pprint

# BEGIN SOLUTION

def solution():
    r, c, n, k = ints()
    vio = set()
    for i in range(n):
        vio.add(tuple(ints()))

    res = 0
    for r0 in range(r):
        for r1 in range(r0+1, r+1):
            for c0 in range(c):
                for c1 in range(c0+1, c+1):
                    count = 0
                    for x in range(r0, r1):
                        for y in range(c0, c1):
                            if (x+1, y+1) in vio:
                                count += 1
                    if count >= k:
                        res += 1
    out(res)

# END SOLUTION

'''
Codeforces template

Copyright by Jeroen van Wolffelaar <jeroen@wolffelaar.nl>, 2016
Codeforces username 'jeroen'

Pick any license you want: Public domain / WTFPL / MIT / 3-clause BSD / PSFL


Makes it easy to run under various modes, like adhoc something, regular mode,
various verbosity options. Compares output to expected, shows time taken, can
enable the python profiler, can show in/out.

print statement will not end up in actual output, you must use out(), outp(),
or return the result from case().

Usage:

- Run with one argument, the single .in file in the currect directory matching
  the argument will be picked.

- Omit the mask, and the script will pick the most recently modified .in file.

- Run with the first argument being a global in the solution, and that
  function will be called with the remaining arguments passed through.

  If you specify 'case', you can thus run a single case.

'''


import __main__

def line():
    L = sys.stdin.readline()
    if not L:
        raise Exception("End of file")
    if VERBOSE:
        print 'INPUT:', L,
    return L.strip()
def ints():
    return map(int, line().split())

def outp(s): # p for partial (= no newline)
    OUT.write(s)
def out(s):
    outp(str(s)+'\n')

def vprint(s):
    if VERBOSE: print s

def profile(func, *a, **kw):
    if OPTS.profile:
        import cProfile, pstats
        P = cProfile.Profile()
        P.enable()

    try:
        return func(*a, **kw)
    finally:
        if OPTS.profile:
            print '='*80
            P.disable()
            P.print_stats('cumulative')
            print '='*80

def processInput():
    solution()
    if sys.stdin.readline():
        print 'WARNING: not all input consumed!'

def main():
    parser = optparse.OptionParser()
    parser.add_option('--run', action='store_true')
    parser.add_option('--outfd')
    parser.add_option('-v', '--verbose', action='store_true')
    parser.add_option('-d', '--debug', action='store_true')
    parser.add_option('-q', '--quiet', action='store_true') # suppress stdout
    parser.add_option('-p', '--profile', action='store_true')
    opts, args = parser.parse_args()

    if opts.run is None:
        if not os.isatty(sys.stdin.fileno()):
            opts.run = True

    if opts.outfd is not None:
        out = os.fdopen(int(opts.outfd), 'w')
    else:
        out = sys.stdout
    
    if opts.run and sys.stdout is out:
        # Hide stdout
        pass#sys.stdout = open('/dev/null', 'w')

    global OUT, OPTS, VERBOSE, DEBUG
    OUT     = out
    OPTS    = opts
    VERBOSE = opts.verbose
    DEBUG   = opts.debug

    if opts.run:
        return profile(processInput)

    if args:
        cmd = args[0]
        if hasattr(__main__, cmd):
            res = getattr(__main__, cmd)(*args[1:])
            pprint(res)
            return

    if args:
        mask, = args
        mastermain(mask)
    else:
        mastermain()

def mastermain(mask=None):
    files = [f for f in os.listdir('.') if f.endswith('.in')]
    if not files:
        raise Exception("No .in file found")

    if mask is None:
        fn = max(files, key=os.path.getmtime)
    else:
        matches = [f for f in files if mask in f]
        if not matches:
            raise Exception("No .in file matched %r" % mask)
        if len(matches) > 1:
            raise Exception("Too many .in file matched %r: [%s]"
                    % (mask, ', '.join(matches)))
        fn, = matches

    print "Processing input from %r..." % fn

    root = fn[:-2]
    infn   = root+'in'
    tmpfn  = root+'tmp'
    outfn  = root+'out'
    goodfn = root+'good'
    assert infn == fn

    with open(infn) as fdin:
        with open(tmpfn, 'wb') as fdout:
            start = time.time()
            kw = {}
            if OPTS.quiet:
                kw.update(stdout=open('/dev/null', 'w'))
            rc = subprocess.call(sys.argv +
                [ '--run', '--outfd=%d' % fdout.fileno()],
                    stdin=fdin, **kw)
            tottime = time.time()-start

    print 'Done in %.3fs' % tottime
    if rc:
        print "WITH EXITCODE %d" % rc
        return

    os.rename(tmpfn, outfn)
    if os.path.exists(goodfn):
        subprocess.call(['diff', '-sdu', goodfn, outfn])
    else:
        print '>>> %s' % outfn
        with open(outfn, 'r') as fd:
            sys.stdout.write(fd.read())
        print '<<< %s' % outfn

    print 'Done in %.3fs' % tottime

if __name__ == '__main__':
    main()
