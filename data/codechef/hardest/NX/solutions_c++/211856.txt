#include<cmath>
#include<cstdio>

#define MAX_POINT_NUMBER 100

#define EPS 1E-9
#define INF 1E99

struct Point
{
	double x,y;

	inline Point(){}
	inline Point(double x,double y):x(x),y(y){}
	inline ~Point(){}
};

struct Circle
{
	Point o;
	double r;

	inline Circle(){}
	inline Circle(Point o,double r):o(o),r(r){}
	inline ~Circle(){}
};

inline double squaredDistance(const Point &a,const Point &b)
{
	return (a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);
}

inline bool contain(const Circle &c,const Point &p)
{
	return squaredDistance(c.o,p)<=c.r*c.r;
}

Circle secureCircle;

int n;
Point p[MAX_POINT_NUMBER];

Circle tower;
double minTotalDistance;

int m=16;
double dx[128];
double dy[128];

void countDelta()
{
	double delta=2*acos(-1.0)/m;
	double angle=0.0;
	for(int i=0;i<m;i++)
	{
		dx[i]=cos(angle);
		dy[i]=sin(angle);
		angle+=delta;
	}
}

void readData()
{
	scanf("%lf %lf %lf",&secureCircle.o.x,&secureCircle.o.y,&secureCircle.r);
	scanf("%d",&n);
	for(int i=0;i<n;i++) scanf("%lf %lf",&p[i].x,&p[i].y);
}

double search(const Point &o,double &totalDist)
{
	double D=0,D2=0;
	for(int i=0;i<n;i++)
	{
		double distPower=squaredDistance(o,p[i]);
		D+=sqrt(distPower);
		D2+=distPower;
	}
	totalDist=(n*D2-D*D)/n;
	return D/n;
}

Point updata(const Point &p)
{
	Point o=Point(floor(p.x*1000.0)/1000.0,floor(p.y*1000.0)/1000.0);
	for(int i=-1;i<=1;i++) for(int j=-1;j<=1;j++)
	{
		Point temp=Point(p.x+i*0.001,p.y+j*0.001);
		if(contain(secureCircle,temp)) return temp;
	}
	return secureCircle.o;
}

void check(double x,double y,double r)
{
	double d=0.0,D=0.0;
	for(int i=0;i<n;i++) D+=squaredDistance(secureCircle.o,p[i]);
	for(int i=0;i<n;i++) d+=(sqrt(squaredDistance(Point(x,y),p[i]))-r)*(sqrt(squaredDistance(Point(x,y),p[i]))-r);
	printf("%lf\n",d/D);
}

void solve()
{
	tower.o=secureCircle.o;
	tower.r=search(tower.o,minTotalDistance);

	double delta=secureCircle.r;

	while(delta>EPS)
	{
		while(true)
		{
			bool loop=true;
			for(int i=0;i<m;i++)
			{
				Point newO=Point(tower.o.x+dx[i]*delta,tower.o.y+dy[i]*delta);
				if(!contain(secureCircle,newO)) continue;
				double dist;
				double r=search(newO,dist);
				if(dist<minTotalDistance)
				{
					minTotalDistance=dist;
					tower=Circle(newO,r);
					loop=false;
				}
			}
			if(loop) break;
		}
		delta*=0.9;
	}
	tower.o=updata(tower.o);
	printf("%.3lf %.3lf %.3lf\n",tower.o.x,tower.o.y,tower.r);
}

int main()
{
	int T;
	countDelta();
	scanf("%d",&T);
	while(T--)
	{
		readData();
		solve();
	}
	return 0;
}
