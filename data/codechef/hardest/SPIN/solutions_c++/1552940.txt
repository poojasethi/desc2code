#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
 
#define SET(mask, bit) ((mask)|=1<<(bit))
#define TEST(mask, bit) (((mask)>>(bit))&1)
#define RESET(mask, bit) ((mask)&=~(1<<(bit)))
#define TOGGLE(mask, bit) ((mask)^=1<<(bit))
 
struct state{
	int color[50][2];
	int needles[50][2][4];
	int N;
	
	state(int cc[50][50], int rot[50][50], int N, int goal): N(N){
		memset(color, 0, sizeof(color));
		memset(needles, 0, sizeof(needles));
		for(int y=0; y<N; y++)
		for(int x=0; x<N; x++){
			int parity=(x+y)&1;
			if(cc[y][x]==goal)
				SET(color[y][parity], x>>1);
			SET(needles[y][parity][rot[y][x]], x>>1);
			SET(needles[y][parity][(rot[y][x]+1)&3], x>>1);
		}
	}
	
	int colorat(int x, int y) const{
		int parity=(x+y)&1;
		return TEST(color[y][parity], x>>1);
	}
	int countbad() const{
		int res=0;
		for(int i=0; i<N; i++)
			res+=__builtin_popcount(color[i][0])
			    +__builtin_popcount(color[i][1]);
		return N*N-res;
	}
	bool solved() const{
		int goal0=(1<<((N+1)/2))-1, goal1=(1<<(N/2))-1;
		for(int i=0; i<N; i++)
			if(color[i][i&1]!=goal0 || color[i][~i&1]!=goal1)
				return false;
		return true;
	}
	bool impossible() const{
		for(int i=0; i<N; i++)
			if(color[i][0] || color[i][1])
				return false;
		return true;
	}
	bool pointedat(int x, int y) const{
		const int dx[4]={ 0, -1,  0,  1};
		const int dy[4]={ 1,  0, -1,  0};
		for(int d=0; d<4; d++){
			int nx=x+dx[d], ny=y+dy[d];
			if(0<=nx && nx<N && 0<=ny && ny<N && !colorat(nx, ny) &&
			  TEST(needles[ny][(nx+ny)&1][d], nx>>1)
			)
				return true;
		}
		return false;
	}
	void rotate(int x, int y){
		int newcolor=colorat(x, y);
		int colorchanged[50][2]={0};
		int S[2][50]={0};
		int parity=(x+y)&1;
		int *cur=S[parity], *next=S[1^parity];
		SET(cur[y], x>>1);
		bool any=true;
		for(;any; swap(cur, next), parity^=1){
			any=false;
			for(int i=0; i<N; i++)
				next[i]=0;
			for(int i=0; i<N; i++)
				if(cur[i]){
					any=true;
					int *needle=needles[i][parity];
					int temp=needle[3];
					int mask=cur[i];
					needle[3]=(needle[2]&mask)|(needle[3]&~mask);
					needle[2]=(needle[1]&mask)|(needle[2]&~mask);
					needle[1]=(needle[0]&mask)|(needle[1]&~mask);
					needle[0]=(     temp&mask)|(needle[0]&~mask);
					colorchanged[i][parity]|=cur[i];
					if(i>0){
						next[i-1]|=mask&needle[0]&needles[i-1][1^parity][2];
					}
					if((parity+i)&1){
						next[i]|=mask&needle[3]&needles[i][1^parity][1];
						next[i]|=((mask&needle[1])<<1)&needles[i][1^parity][3];
					}else{
						next[i]|=mask&needle[1]&needles[i][1^parity][3];
						next[i]|=((mask&needle[3])>>1)&needles[i][1^parity][1];
					}
					if(i<N-1){
						next[i+1]|=mask&needle[2]&needles[i+1][1^parity][0];
					}
				}
		}
		for(int i=0; i<N; i++){
			if(newcolor){
				color[i][0]|=colorchanged[i][0];
				color[i][1]|=colorchanged[i][1];
			}else{
				color[i][0]&=~colorchanged[i][0];
				color[i][1]&=~colorchanged[i][1];
			}
		}
	}
	void flood(){
		int cnt=countbad();
		for(;;){
			for(int i=0; i<N; i++){
				if(i>0){
					color[i-1][0]|=color[i][1]&needles[i-1][0][2];
					color[i-1][1]|=color[i][0]&needles[i-1][1][2];
				}
				if(i&1){
					color[i][1]|=color[i][0]&needles[i][1][1];
					color[i][0]|=color[i][1]&needles[i][0][3];
					color[i][1]|=(color[i][0]<<1)&needles[i][1][3];
					color[i][0]|=(color[i][1]>>1)&needles[i][0][1];
				}else{
					color[i][0]|=color[i][1]&needles[i][0][1];
					color[i][1]|=color[i][0]&needles[i][1][3];
					color[i][0]|=(color[i][1]<<1)&needles[i][0][3];
					color[i][1]|=(color[i][0]>>1)&needles[i][1][1];
				}
				if(i<N-1){
					color[i+1][0]|=color[i][1]&needles[i+1][0][0];
					color[i+1][1]|=color[i][0]&needles[i+1][1][0];
				}
			}
			int next=countbad();
			if(cnt==next)
				break;
			cnt=next;
		}
	}
};
 
int cc[50][50], rot[50][50], N;
int K;
pair<int, int> solution[1001];
 
void read(){
	scanf("%d", &N);
	for(int i=0; i<N; i++)
	for(int j=0; j<N; j++){
		scanf("%d", &rot[i][j]);
		rot[i][j]--;
	}
	for(int i=0; i<N; i++)
	for(int j=0; j<N; j++){
		scanf("%d", &cc[i][j]);
		cc[i][j]--;
	}
}
 
void print(){
	if(K>1000){
		puts("-1");
	}else{
		printf("%d\n", K);
		for(int i=0; i<K; i++)
			printf("%d %d\n", solution[i].second+1, solution[i].first+1);
	}
}
 
void solve(int goal){
	int k=0;
	pair<int, int> sol[1001];
	state st(cc, rot, N, goal);
	for(;;){
		if(st.impossible())
			return;
		state cpy(st);
		cpy.flood();
		if(cpy.solved())
			break;
		int x, y;
		do{
			x=rand()%N;
			y=rand()%N;
		}while(cpy.colorat(x, y));
		st.rotate(x, y);
		sol[k++]=make_pair(x, y);
	}
	int max_iter=N<20 ? 100 : N<30 ? 5 : N<40 ? 4 : 3;
	for(int iter=max_iter; k<K && iter>0 && !st.solved(); iter--){
		int bestx=-1, besty=-1, best=st.countbad();
		for(int y=0; y<N; y++)
		for(int x=0; x<N && best>0; x++){
			if(!st.colorat(x, y))
				continue;
			state cpy(st);
			cpy.rotate(x, y);
			if(cpy.countbad()<best){
				best=cpy.countbad();
				bestx=x;
				besty=y;
			}
		}
		if(bestx==-1)
			break;
		st.rotate(bestx, besty);
		sol[k++]=make_pair(bestx, besty);
	}
	while(k<K && !st.solved()){
		int x, y;
		do{
			x=rand()%N;
			y=rand()%N;
		}while(!st.colorat(x, y) || !st.pointedat(x, y));
		st.rotate(x, y);
		sol[k++]=make_pair(x, y);
	}
	if(k<K){
		K=k;
		copy(sol, sol+k, solution);
	}
}
 
int main(int argc, char *argv[]){
	int T;
	scanf("%d", &T);
	for(int t=0; t<T; t++){
		read();
		K=1001;
		for(int i=0; i<5; i++)
			solve(i);
		print();
	}
	return 0;
} 