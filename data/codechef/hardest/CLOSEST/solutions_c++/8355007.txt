#include <algorithm>
#include <iostream>
#include <cassert>
#include <cstring>
#include <cstdio>
#include <vector>
#include <cmath>
#include <ctime>
#include <map>
#include <set>
 
using namespace std;
 
#define SIZE(A) ((int)A.size())
#define LENGTH(A) ((int)A.length())
#define MP(A,B) make_pair(A,B)
#define PB(A) push_back(A)
#define THLIM 235
#define getchx getchar_unlocked
#define eps 1e-14
const int MAXN = 200000;
int threshhold = 100000;
typedef unsigned long long ll;
 
int n, m, CH;
int ans[MAXN];
double sqbest;
 
struct point {int a[6];};
point a[MAXN];
bool cmp(const int i, const int j) {return a[i].a[CH] < a[j].a[CH];}
 
//// Presorted
//int srt[3][MAXN];
// Positions
int p[MAXN];
 
struct node
{
	int l, r;
	int key, key1;
	double A, B, C, D;
	double len;
};
node v[MAXN];
int last, amo;
 
// Temprorary
int b[MAXN];
 
// Querry
int x[3];
int who;
ll best;
 
inline ll dist(const int p)
{
 	return (unsigned long long)(x[0]-a[p].a[0])*(x[0]-a[p].a[0]) + 1LL*(x[1]-a[p].a[1])*(x[1]-a[p].a[1]) + 1LL*(x[2]-a[p].a[2])*(x[2]-a[p].a[2]);
}
 
inline void build(int *p, int n)
{
	int u = last++;
	v[u].l = v[u].r = -1;
 
	int mid = rand()%n, pos = rand()%n;
 
	v[u].key = v[u].key1 = p[mid];
 
	if (n == 1) return;
 
	while (pos == mid) pos = rand()%n;
 
	v[u].key1 = p[pos];
 
	v[u].A = a[p[mid]].a[0] - a[p[pos]].a[0];
	v[u].B = a[p[mid]].a[1] - a[p[pos]].a[1];
	v[u].C = a[p[mid]].a[2] - a[p[pos]].a[2];
 
	double mx = (a[p[mid]].a[0] + a[p[pos]].a[0])/2., my = (a[p[mid]].a[1] + a[p[pos]].a[1])/2., mz = (a[p[mid]].a[2] + a[p[pos]].a[2])/2.;
	v[u].D = -(v[u].A*mx + v[u].B*my + v[u].C*mz);
 
	v[u].len = sqrt(v[u].A*v[u].A + v[u].B*v[u].B + v[u].C*v[u].C);
 
	int newn = 0, n1;
	double val;
	for (int i = 0; i < n; i++)
		if (i!=mid && i!=pos)
		{
			val = v[u].A*a[p[i]].a[0] + v[u].B*a[p[i]].a[1] + v[u].C*a[p[i]].a[2] + v[u].D;
 
			if (val >= eps)
				b[newn++] = p[i];
		}
	n1 = newn;
	for (int i = 0; i < n; i++)
		if (i != mid && i!=pos)
		{
			val = v[u].A*a[p[i]].a[0] + v[u].B*a[p[i]].a[1] + v[u].C*a[p[i]].a[2] + v[u].D;
 
			if (val < eps)
				b[newn++] = p[i];
		}
 
	for (int i = 0; i < newn; i++)
		p[i] = b[i];
 
	if (n1)
	{
		v[u].l = last;
		build(p, n1);
	}
	if (newn-n1)
	{
		v[u].r = last;
		build(p+n1, newn-n1);
	}
}
 
inline void doit(int u)
{
	ll tmp;
	int lson = v[u].l, rson = v[u].r;
 
	if ((tmp = dist(v[u].key)) < best)
	{
	 	best = tmp;
	 	amo = 0;
	 	sqbest = sqrt(1.*best);
	 	who = v[u].key;
	}
 
	amo++;
 
	if ((tmp = dist(v[u].key1)) < best)
	{
	 	best = tmp;
	 	amo = 0;
	 	sqbest = sqrt(1.*best);
	 	who = v[u].key1;
	}
 
	amo += 2;
	if (amo > threshhold || lson==rson) return;
 
	double val = v[u].A*x[0] + v[u].B*x[1] + v[u].C*x[2] + v[u].D;
 
	if (val >= eps)
	{
//		assert(dist(v[u].key) < dist(v[u].key1));
 
		if (lson!=-1) doit(lson);
 
		if (rson!=-1 && val < sqbest*v[u].len)
			doit(rson);
	}
	else
	{
//		assert(dist(v[u].key) >= dist(v[u].key1));
 
		if (rson!=-1) doit(rson);
 
		if (lson!=-1 && val < sqbest*v[u].len)
			doit(lson);
	}
}
 
inline void scan(int &x)
{
	char ch = getchx();
	for (; ch!='-' && (ch < '0' || ch > '9'); ch = getchx());
	bool neg = (ch == '-');
	if (ch == '-') ch = getchx();
	
	x = 0;
	for (; ch >= '0' && ch <= '9'; ch = getchx())
		x = x*10 + ch-'0';
 
	if (neg) x = -x;
}
 
 
int main()
{
	double start = clock();
 
	srand(4041978);
	scan(n);
	for (int i = 0; i < n; i++)
		for (int j = 0; j < 3; j++)
			scan(a[i].a[j]);
 
	for (int i = 0; i < n; i++)
		p[i] = i;
 
	build(p, n);
	cerr << "Generation process finished\n";
 
	int sz = 0;
	for (int i = 0; i < last; i++)
		p[sz++] = v[i].key1,
		p[sz++] = v[i].key;
	sort(p, p+sz);
	assert(unique(p, p+sz)-p == n);
 
	scan(m);
	for (int i = 0; i < m; i++)
		ans[i] = rand()%n;
 
	int asd;
	ll tmp;
	for (int it = 0; it < m; it++)
	{
		scan(x[0]);
		scan(x[1]);
		scan(x[2]);
 
		best = dist(v[0].key);
	 	sqbest = sqrt(1.*best);
		who = v[0].key;
 
		amo = 0;
		doit(0);
 
		ans[it] = who;
		asd = it+1;
 
		threshhold = THLIM;
 
		if ((clock()-start) > 3.84*CLOCKS_PER_SEC) break;
	}
 
	cerr << asd << " " << m << endl;
	for (int i = 0; i < m; i++)
		printf("%d\n", ans[i]);
 
	return 0;
}   