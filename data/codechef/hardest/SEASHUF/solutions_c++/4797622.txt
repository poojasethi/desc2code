#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <cassert>
using namespace std;
 
typedef long long ll;
typedef pair <int, int> ii;
 
const int Maxn = 100005;
const int iter = 10000;
const int from1 = 100;
const int to1 = 2200;
const int step1 = 150;
const int from2 = 50;
const int to2 = 400;
const int step2 = 50;
 
int param;
int param2;
 
int n, hn;
int ia[Maxn], a[Maxn];
ll best;
vector <ii> res;
int used;
ll gbest;
vector <ii> gres;
 
void makeMove(int l, int r)
{
    int rem = a[l];
    for (int i = l + 1; i <= r; i++)
    a[i - 1] = a[i];
    a[r] = rem;
    res.push_back(ii(l, r));
}
 
int getMax(int l, int r, ll obest)
{
    int bi = -1;
    for (int i = l; i <= r && used + 2 * (i - hn - 1) <= 2 * n; i++)
        if (bi == -1 || a[i] > a[bi])
            bi = i;
    return bi;
}
 
int getMin(int l, int r, ll obest)
{
    int bi = -1;
    for (int i = l; i <= r && used + 2 * (i - hn - 1) <= 2 * n; i++)
        if (bi == -1 || a[i] < a[bi])
            bi = i;
    return bi;
}
 
int getBigger(int l)
{
    while (l <= n && a[hn + 1] >= a[l]) l++;
    if (l > n || used + 2 * (l - hn - 1) > 2 * n) return -1;
    return l;
}
 
int getSmaller(int l)
{
    while (l <= n && a[hn + 1] <= a[l]) l++;
    if (l > n || used + 2 * (l - hn - 1) > 2 * n) return -1;
    return l;
}
 
void makeBetter(ll &obest)
{
    if (obest == 0) { used = 2 * n + 1; return; }
    int got;
    if (obest < 0) {
        got = getMax(hn + 2, min(n, hn + 2 + param2), obest);
        if (got == -1) got = getBigger(hn + 2);
    } else {
        got = getMin(hn + 2, min(n, hn + 2 + param2), obest);
        if (got == -1) got = getSmaller(hn + 2);
    }
    if (got == -1) { used = 2 * n + 1; return; }
    used += 2 * (got - hn - 1);
    int bi = -1;
    int lst = max(1, hn - param);
    for (int i = hn; i >= lst; i--) 
        if (used + hn + 1 - i + 1 <= 2 * n) {
            ll cand = abs(obest - 2 * a[i] + 2 * a[got]);
            if (cand < best) { best = cand; bi = i; }
        }
    if (bi == -1) {
        for (int i = lst - 1; i >= 1; i--) 
            if (used + hn + 1 - i + 1 <= 2 * n) {
                ll cand = abs(obest - 2 * a[i] + 2 * a[got]);
                if (cand < best) { best = cand; bi = i; }
            }
        if (bi == -1) { used = 2 * n + 1; return; }
    }
    obest = obest - 2 * a[bi] + 2 * a[got];
    used += hn + 1 - bi + 1;
    for (int i = got - 1; i >= hn + 1; i--)
        makeMove(i, i + 1);
    makeMove(bi, hn + 1);
}
 
void Solve(ll myobest, int from1, int to1, int step1, int from2, int to2, int step2)
{
    for (int i = 1; i <= n; i++)
        ia[i] = a[i];
    gbest = abs(myobest);
    for (param = from1; param <= to1; param += step1)
        for (param2 = from2; param2 <= to2; param2 += step2) {
            ll obest = myobest; best = abs(myobest);
            for (int i = 1; i <= n; i++)
                a[i] = ia[i];
            res.clear(); used = 0;
            for (int i = 0; i < iter && used < 2 * n; i++)
                makeBetter(obest);
            if (abs(obest) < gbest) { gbest = abs(obest); gres = res; }
        }
}
 
int main()
{
    scanf("%d", &n); hn = n / 2;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        if (i <= hn) best += a[i];
        else best -= a[i];
    }
    ll obest = best;
    if (best < 0) best = -best;
    if (n <= 100) Solve(obest, 0, n, 1, 0, n, 1);
    else if (n <= 1000) Solve(obest, 0, n, 30, 0, n, 30);
    else Solve(obest, from1, to1, step1, from2, to2, step2);
    printf("%d\n", gres.size());
    for (int i = 0; i < gres.size(); i++)
    printf("%d %d\n", gres[i].first, gres[i].second);
    return 0;
}  
