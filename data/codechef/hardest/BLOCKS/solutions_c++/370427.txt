#include<algorithm>
#include<iostream>
#include<cstring>
#include<string>
#define MAXN 200
using namespace std;
double tot_score = 0;
int SOLVETIMES = 202;
string NUM[MAXN + 1] , OUTPUT;
int lowbit(int x){return x&(-x);}
short lowbit1[101];
short lowbit2[101];
int n , z;
int x[MAXN + 1][3];
int ans[MAXN + 1][3] , amount , nowans;
int faceup[MAXN + 1];
int dp[6 * MAXN + 1] , opt[6 * MAXN + 1];
int s[101];
bool use[6 * MAXN + 1] , Ause[6 * MAXN + 1];
int whichface[MAXN + 1] , atwhere[MAXN + 1];
int R3[65536] , R100[65536];
int R_now = 19911120 , R_add = 22222223 , R_mul = 1000000001;
int getRand3()
{
R_now = (R_now + R_add) * R_mul;
return R3[R_now & 65535];
}
int getRand100()
{
R_now = (R_now + R_add) * R_mul;
return R100[R_now & 65535];
}
void update(int loc , int v)
{
while(loc <= 100)
{
if(dp[s[loc]] < dp[v])
s[loc] = v;
loc = lowbit1[loc];
}
}
int getval(int loc)
{
int ret = 0;
while(loc)
{
if(dp[ret] < dp[s[loc]])
ret = s[loc];
loc = lowbit2[loc];
}
return ret;
}
struct data
{
unsigned char val , key , d , from;
data(){}
data(int _v , int _k , int _d , int _f){val = _v , key = _k , d = _d , from = _f;}
}D[MAXN * 6 + 1];
bool cmp(data A , data B)
{
if(A.key != B.key)
return A.key < B.key;
return A.d < B.d;
}
void solve()
{
D[z+1] = data(100 , 100 , 100 , 0);
for(int i = 1 ; i <= n ; i++)
{
if(whichface[i] && getRand100() < 77)
faceup[i] = whichface[i];
else
faceup[i] = x[i][getRand3()];
whichface[i] = 0;
}
memset(s , 0 , sizeof(s));
int maxval = 0 , where = 0;
for(int i = 1 ; i <= z ; i++)
use[i] = false;
for(int i = 1 ; i <= z ; i++)
if(D[i].val == faceup[D[i].from])
{
opt[i] = getval(D[i].d);
dp[i] = dp[opt[i]] + D[i].val;
update(D[i].d , i);
if(opt[opt[i]] > 0 && dp[i] > maxval)
maxval = dp[i] , where = i;
}
while(where)
{
use[where] = true;
whichface[D[where].from] = D[where].val;
atwhere[D[where].from] = where;
where = opt[where];
}
use[0] = true;
use[z + 1] = true;
int lef = 0 , rig = 0;
for(int i = 1 ; i <= z ; i++)
if(!use[i])
{
while(rig <= i || use[rig] == false)
rig ++;
if(D[lef].d <= D[i].d && D[i].d <= D[rig].d)
{
if(whichface[D[i].from] == 0)
{
use[i] = true;
lef = i;
maxval += D[i].val;
whichface[D[i].from] = D[i].val;
atwhere[D[i].from] = i;
}
else
if(atwhere[D[i].from] > i)
if(whichface[D[i].from] < D[i].val)
{
use[i] = true;
lef = i;
maxval += D[i].val - whichface[D[i].from];
use[atwhere[D[i].from]] = false;
whichface[D[i].from] = D[i].val;
atwhere[D[i].from] = i;
}
}
}
else
lef = i;
if(maxval > nowans)
{
nowans = maxval;
memcpy(Ause , use , sizeof(use));
}
}
void solve2()
{
for(int i = 1 ; i <= n ; i++)
{
faceup[i] = 0;
for(int j = 0 ; j < 3 ; j++)
faceup[i] = max(faceup[i] , x[i][j]);
whichface[i] = 0;
}
memset(s , 0 , sizeof(s));
int maxval = 0 , where = 0;
for(int i = 1 ; i <= z ; i++)
use[i] = false;
for(int i = 1 ; i <= z ; i++)
if(D[i].val == faceup[D[i].from])
{
opt[i] = getval(D[i].d);
dp[i] = dp[opt[i]] + D[i].val;
update(D[i].d , i);
if(opt[opt[i]] > 0 && dp[i] > maxval)
maxval = dp[i] , where = i;
}
while(where)
{
use[where] = true;
whichface[D[where].from] = D[where].val;
atwhere[D[where].from] = where;
where = opt[where];
}
use[0] = true;
use[z + 1] = true;
int lef = 0 , rig = 0;
for(int i = 1 ; i <= z ; i++)
if(!use[i])
{
while(rig <= i || use[rig] == false)
rig ++;
if(D[lef].d <= D[i].d && D[i].d <= D[rig].d)
{
if(whichface[D[i].from] == 0)
{
use[i] = true;
lef = i;
maxval += D[i].val;
whichface[D[i].from] = D[i].val;
atwhere[D[i].from] = i;
}
else
if(atwhere[D[i].from] > i)
if(whichface[D[i].from] < D[i].val)
{
use[i] = true;
lef = i;
maxval += D[i].val - whichface[D[i].from];
use[atwhere[D[i].from]] = false;
whichface[D[i].from] = D[i].val;
atwhere[D[i].from] = i;
}
}
}
else
lef = i;
if(maxval > nowans)
{
nowans = maxval;
memcpy(Ause , use , sizeof(use));
}
}
void getStart(int t);
int main()
{
//freopen("in.txt" , "r" , stdin);
//freopen("out.txt" , "w" , stdout);
ios::sync_with_stdio(false);
for(int i = 0 ; i < 65536 ; i++)
R3[i] = i % 3 , R100[i] = i % 100;
for(int i = 1 ; i <= 100 ; i++)
{
lowbit1[i] = i + lowbit(i);
lowbit2[i] = i - lowbit(i);
}
for(int i = 1 ; i <= MAXN ; i++)
NUM[i] = NUM[i / 10] + char('0' + i % 10);
opt[0] = 0 , dp[0] = 0;
D[0] = data(0 , 0 , 0 , 0);
int TestCases;
cin>>TestCases;
for(int CaseID = 1 ; CaseID <= TestCases ; CaseID ++)
{
cin>>n;
getStart(CaseID);
nowans = 0;
z = 0;
for(int i = 1 ; i <= n ; i++)
{
whichface[i] = 0;
for(int j = 0 ; j < 3 ; j++)
cin>>x[i][j];
D[++z] = data(x[i][0] , x[i][1] , x[i][2] , i);
if(x[i][1] != x[i][2])
D[++z] = data(x[i][0] , x[i][2] , x[i][1] , i);
if(x[i][1] != x[i][0])
{
D[++z] = data(x[i][1] , x[i][0] , x[i][2] , i);
if(x[i][0] != x[i][2])
D[++z] = data(x[i][1] , x[i][2] , x[i][0] , i);
}
if(x[i][2] != x[i][1] && x[i][2] != x[i][0])
{
D[++z] = data(x[i][2] , x[i][0] , x[i][1] , i);
if(x[i][0] != x[i][1])
D[++z] = data(x[i][2] , x[i][1] , x[i][0] , i);
}
}
sort(D + 1 , D + 1 + z , cmp);
for(int i = 1 ; i <= z ; i++)
use[i] = false;
for(int i = 1 ; i <= SOLVETIMES ; i++)
solve();
amount = 0;
for(int i = 1 ; i <= z ; i++)
if(Ause[i])
{
amount ++;
ans[amount][0] = D[i].val;
ans[amount][1] = D[i].d;
ans[amount][2] = D[i].key;
}
tot_score += (double)nowans / (double)n;
OUTPUT += NUM[amount] + "\n";
for(int i = 1 ; i <= amount ; i++)
OUTPUT += NUM[ans[i][0]] + " " + NUM[ans[i][1]] + " " + NUM[ans[i][2]] + "\n";
}
tot_score /= (double)TestCases;
//cout<<tot_score<<endl;
cout<<OUTPUT;
return 0;
}
int START[] =
{11111
,22221
,33336
,44444
,4
,55551
,6
,77775
,88889
,9
};
void getStart(int t)
{
if(t % 50 == 1)
R_now = START[(t - 1) / 50];
if(t == 25)
R_now = 25259;
if(t == 125)
R_now = 12503;
} 

