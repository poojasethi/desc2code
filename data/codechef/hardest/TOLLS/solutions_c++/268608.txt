int seed[]={59672,27,78126,53588,31869,85,41534,91,63167,39056,54,83,39150,43,70083,86,91451,17066,70532,42487,37231,75955,57813,63206,40,590,58117,63563,35,33,41875,65,85,16772,87353,97,46,69,42,79895};
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <vector>
#include <assert.h>
#include <sys/time.h>
using namespace std;

typedef long long int64;
#define sqr(X) ((X)*(X))

int64 counter=0;

double getTime() {
	struct timeval tv;
	gettimeofday(&tv, NULL);
	return tv.tv_sec+tv.tv_usec/1000000.0;
}

double t0[101][101];
double t[101][101];
double trow[101];
int dis[101];
void simplex(int n, int m, double val[]) { // simplex(constraints, variables, result)
	counter++;

	pair<int,int> colID[m],rowID[n];
	for (int i=0;i<m;i++) colID[i]=make_pair(0,i);
	for (int i=0;i<n;i++) rowID[i]=make_pair(1,i);

	while (1) {
		// najbolj pozitiven v spodnji vrstici
		double best=-1;
		int col=-1;
		for (int c=0;c<m;c++) {
			if (t[c][n]>0 && t[c][n]>best) { best=t[c][n]; col=c; }
		}
		if (col==-1) break;

		//vrstica z najmanjsim pozitivnim kolicnikom
		best=-1;
		int row=-1;
		for (int r=0;r<n;r++) if (!dis[r]) {
			if (t[col][r]<=0) continue;
			double rat=t[m][r]/t[col][r];
			if ((rat>0 || (t[m][r]==0 && t[col][r]>0)) && (rat<best || best<0)) { best=rat; row=r; }
		}
		if (best<0) break;
		double pivot=t[col][row];
		//cout << "pivot = " << row << " " << col << endl;

		swap(colID[col],rowID[row]);
		//pivotna vrstica
		trow[col]=1/t[col][row];
		t[col][row]=1/t[col][row];
		for (int i=0;i<=m;i++) {
			if (i!=col) {
				trow[i]=t[i][row]*1/pivot;
				t[i][row]*=1/pivot;
			}
		}

		//ostalo
		for (int j=0; j<=m; j++) if (j!=col && trow[j]!=0) {
			double *tj=t[j], *tcol=t[col], *last=&t[j][n];
			//for (int i=0;i<=n;i++,tj++,tcol++) {
			for (;tj<=last;tj++,tcol++) {
				//t[j][i]=t[j][i]-trow[j]*t[col][i];
				*tj-=trow[j]*(*tcol);
				//if (j<m && i<n) assert(*tj==0 || *tj==1 || *tj==-1);
			}
		}

		for (int i=0;i<=m;i++) {
			t[i][row]=trow[i];
		}

		//pivotni stolpec
		for (int i=0;i<=n;i++) if (!dis[i]) {
			if (i!=row) t[col][i]*=-1/pivot;
		}


	}

	for (int i=0;i<m;i++) val[i]=0;
	for (int i=0;i<n;i++) if (!dis[i]) if (rowID[i].first==0) {
		val[rowID[i].second]=t[m][i];
	}
	val[m]=-t[m][n];
}

void setMaxFun(int n, int m) {
	for (int i=0;i<=m;i++) t[i][n]=0;
	for (int i=0;i<n;i++) if (!dis[i]) {
		for (int j=0;j<m;j++) t[j][n]+=t[j][i];
	}
}

void printLinProg(int n, int m) {
	for (int i=0;i<=n;i++) {
		for (int j=0;j<=m;j++) printf("%.2lf ",t[j][i]);
		printf("\n");
	}
	printf("\n");
}

int getLucky(double prob) {
	int rez = rand()<prob*RAND_MAX;
	return rez;
}

int n,m;
int used[101];
int from[100],to[100],b[100];

int dis0[101];
double p0[101];
double score0=-1;

void gen() {
	freopen("toll3.in","w",stdout);
	int tests=2;
	printf("%d\n",tests);
	srand(time(0));
	while (tests--) {
		int n=100, m=30+rand()%70;
		//int n=100, m=100;
		printf("%d %d\n",n,m);
		for (int i=0;i<m;i++) {
			int x=1+rand()%(n-1);
			printf("%d %d %d\n",x,x+1,rand());
		}
	}
}

int main() {
	//gen(); return 0;
	double startTime = getTime();
	double timeLimit = 7.0;
	//freopen("toll2.in","r",stdin);
	//srand(time(0));
	int tests,alltests;
	scanf("%d",&tests);
	alltests=tests;
	double total=0;
	int degCnt=0;
	while (tests--) {

		// LAME PART
		srand(seed[tests]);

		double testStartTime = getTime();
		//double testTimeLimit = (timeLimit-(testStartTime-startTime))/(tests+1);
		double testTimeLimit = 7.0/alltests;

		scanf("%d %d",&n,&m);
		memset(used,0,sizeof(used));
		double budget=0, maxDist=0, maxBudget=0;
		int degenerate=1, vals=-1, len1=1;
		for (int i=0;i<m;i++) {
			scanf("%d %d %d",&from[i],&to[i],&b[i]);
			if (from[i]>to[i]) swap(from[i],to[i]);
			budget+=b[i];
			if (from[i]==to[i]) { m--; i--; continue; }

			maxBudget=max(maxBudget,1.0*b[i]);
			maxDist=max(maxDist,1.0*to[i]-from[i]);

			if (i==0) vals=b[i];
			else if (i>0 && b[i]!=vals) degenerate=0;

			if (to[i]-from[i]!=1) len1=0;

			from[i]--; to[i]--;
			used[from[i]]=1; used[to[i]]=1;
		}
		degCnt+=len1;
		//assert(degCnt<=1);
		for (int i=0;i<m;i++) {
			int x=from[i]; from[i]=0;
			for (int j=0;j<x;j++) from[i]+=used[j];
			int y=to[i]; to[i]=0;
			for (int j=0;j<y;j++) to[i]+=used[j];
		}
		int n2=0;
		for (int j=0;j<n;j++) n2+=used[j];
		swap(n,n2);

		memset(t,0,sizeof(t));
		memset(dis,0,sizeof(dis));
		for (int j=0;j<m;j++) {
			for (int i=from[j];i<to[j];i++) t[i][j]=1;
			t[n][j]=b[j];
		}
		for (int i=0;i<n;i++) {
			for (int j=0;j<m;j++) {
				if (from[j]<=i && i<to[j]) t[i][m]+=1;
			}
		}

		// components


		/*for (int j=0;j<=m;j++) {
			for (int i=0;i<=n;i++) printf("%.0lf ",t[j][i]);
			printf("\n");
		}
		printf("\n");*/

		//dis[3]=1; dis[4]=1;


		for (int i=0;i<m;i++) { dis[i]=1; }

		memcpy(dis0,dis,sizeof(dis));
		memcpy(t0,t,sizeof(t));
		memset(p0,0,sizeof(p0));
		score0=0;

		if (len1 && 1) { // NO PARTIAL OVERLAP OF SEGMENTS
			for (int i=0;i<n-1;i++) {
				vector<int> seg;
				for (int j=0;j<m;j++) {
					if (from[j]==i && to[j]==i+1) seg.push_back(b[j]);
				}
				sort(seg.begin(),seg.end());
				reverse(seg.begin(),seg.end());
				int best=0;
				for (int j=0;j<(int)seg.size();j++) {
					if (seg[j]*(j+1)>best) {
						best=seg[j]*(j+1);
						p0[i]=seg[j];
					}
				}
				score0+=best;
			}

		} else if (m<=20 && 0) { // OPTIMAL

			for (int mask=0;mask<(1<<m);mask++) {
				//fprintf(stderr,"%d/%d\n",mask,1<<m);
				memset(dis,0,sizeof(dis));
				for (int i=0;i<m;i++) if (mask&(1<<i)) dis[i]=1;
				memcpy(t,t0,sizeof(t0));
				double p[101];
				setMaxFun(m,n);
				simplex(m,n,p);
				double score=p[n];
				if (score>score0) {
					score0=score;
					memcpy(dis0,dis,sizeof(dis));
					memcpy(p0,p,sizeof(p));
				}
			}
		} else {

			setMaxFun(m,n);
			simplex(m,n,p0);
			score0=p0[n];
			//cout << score0 << endl;

			// build improve solution
			vector<pair<double,int> > order;
			for (int i=0;i<m;i++) {
				//order.push_back(make_pair(1.0*pow(to[i]-from[i],0.1)/b[i],i));
				double dr=(to[i]-from[i])/maxDist;
				double br=b[i]/maxBudget;
				order.push_back(make_pair(1/br,i));
				//printf("%d: %lf %lf -> %lf\n",i,dr,br,order[i].first);
			}

			int change=1, iter=0;
			while (change) {
				change=0; iter++;

				// add customers
				sort(order.begin(),order.end());
				for (int i=0;i<m;i++) {
					int id=order[i].second;
					if (!dis[id]) continue;
					if (getTime()-testStartTime > testTimeLimit) break;

					memcpy(dis,dis0,sizeof(dis0));
					memcpy(t,t0,sizeof(t0));
					double p[101];

					dis[id]=0;
					setMaxFun(m,n);
					simplex(m,n,p);
					double score=p[n];
					double T=1.0-(getTime()-testStartTime)/testTimeLimit;
					if (score>=score0 || getLucky(pow(15,(-score0/score)/T))) {
						change=1;
						memcpy(dis0,dis,sizeof(dis));
						memcpy(p0,p,sizeof(p));
						score0=score;
					} else {
						dis[id]=1;
					}
				}


				// remove customers
				sort(order.begin(),order.end());
				//reverse(order.begin(),order.end());
				for (int i=0;i<m;i++) {
					int id=order[i].second;
					if (dis[id]) continue;
					if (getTime()-testStartTime > testTimeLimit) break;

					int bi=0;
					for (int j=from[id];j<to[id];j++) bi+=(int)p0[j];
					if (bi<b[id]) continue;

					memcpy(dis,dis0,sizeof(dis0));
					memcpy(t,t0,sizeof(t0));
					double p[101];

					dis[id]=1;
					setMaxFun(m,n);
					simplex(m,n,p);
					double score=p[n];
					if (score>score0) {
						change=1;
						memcpy(dis0,dis,sizeof(dis));
						memcpy(p0,p,sizeof(p));
						score0=score;
					} else {
						dis[id]=0;
					}
				}

				if (!change) {
					// TODO
				}

			}
		}

		// build integer solution
		for (int i=0;i<n;i++) {
			assert(p0[i]-(int)p0[i]<1e-9);
			p0[i]=(int)p0[i];
		}

		/*for (int i=0;i<n-1;i++) {
			while (1) {
				p0[i]+=1;
				int ok=1;
				for (int j=0;j<m;j++) {
					int cost=0;
					for (int i2=from[j];i2<to[j];i2++) cost+=p0[i];
					if (cost>b[i]) { ok=0; break; }
				}
				if (!ok) {
					p0[i]-=1;
					break;
				}
			}
		}*/


		total+=score0/budget;

		int st=0;
		for (int i=0;i<n2-1;i++) {
			if (i!=0) printf(" ");
			if (!used[i]) { printf("0"); }
			else printf("%d",(int)p0[st++]);
			//else printf("%.2lf",p0[st++]);
		}
		printf("\n");

		/*for (int i=0;i<m;i++) {
			if (!dis0[i]) printf("%d: dist = %d, b=%d\n",i,to[i]-from[i],b[i]);
			else printf("NOT %d: dist = %d, b=%d\n",i,to[i]-from[i],b[i]);
		}
		printf("\n");*/
	}
	cerr << "total = " << total/alltests << endl;
	cerr << "counter = " << counter << endl;
    return 0;
}
