#include <stdio.h>
#include <math.h>
#include <stdlib.h>
 
#define yn yn_
 
const int N = 111;
const int dx[4] = {0,1,0,-1};
const int dy[4] = {1,0,-1,0};
const char let[5] = "ESWN";
 
char a[N][N], ch, aa[N][N], curr[N*N*17], best[N*N*17], aq[N][N];
int num[N][N], xt[N*N], yt[N*N], was[N][N], x[N*N], y[N*N], z[N*N];
int last[N*N], ws[N*N], pr[N*N], pd[N][N], pat[N*N], deg[N*N], pdd[N*N], vis[N][N], kr[N*N];
char r[N*N][17];
int nn,mm,k,tt,i,j,ii,e,zz,n,m,xk,yk,p,kp,xn,yn,qq,maxv,qw,xp,yp,zp,zq,tot,cnt,uv;
int maxcnt,count,length;
int ss[N*N*N], ff[N*N*N], pred[N*N*N];
 
int used[N*N];
 
void rec(int v) {
  ws[v] = 1;
  int kt = 0, j = last[v], t[111], tmp, i;
  while (j > 0) {
    if (!ws[ff[j]]) --deg[ff[j]], t[kt++] = ff[j];
    j = pred[j];
  }
  for (i=0;i<kt;i++)
    for (j=i+1;j<kt;j++)
      if (uv == 0 && xt[t[i]]*sqrt(1.0*nn)+yt[t[i]]*sqrt(1.0*mm) > xt[t[j]]*sqrt(1.0*nn)+yt[t[j]]*sqrt(1.0*mm) ||
          uv == 3 && xt[t[i]]*nn*nn+yt[t[i]]*mm*mm > xt[t[j]]*nn*nn+yt[t[j]]*mm*mm ||
          uv == 2 && xt[t[i]]+yt[t[i]] > xt[t[j]]+yt[t[j]] ||
          uv == 1 && xt[t[i]]*nn+yt[t[i]]*mm > xt[t[j]]*nn+yt[t[j]]*mm) {
        tmp = t[i]; t[i] = t[j]; t[j] = tmp;
      }
  for (i=0;i<kt;i++) {
    if (ws[t[i]]) continue;
    pr[t[i]] = v;
    rec(t[i]);
  }
/*  ws[v] = 1;
  int j = last[v];
  while (j > 0) {
    if (!ws[ff[j]]) {
      pr[ff[j]] = v;
      rec(ff[j]);
    }
    j = pred[j];
  }*/
}
 
inline int mabs(int q) {
  if (q < 0) return -q;
  return q;
}
 
void go(int xc,int yc,int xf,int yf,int moves,int nv) {
  if (nv+zz-moves <= maxv) return;
  if (moves+mabs(xc-xf)+mabs(yc-yf) > zz) return;
  if (xc == xf && yc == yf) {
    if (nv > maxv) {
      maxv = nv;
      for (int i=moves-1;i>=0;i--) {
        int dir = pdd[i];
        pd[xc][yc] = dir+1;
        xc -= dx[dir];
        yc -= dy[dir];
      }
    }
    return;
  }
  if (!vis[xc][yc]) nv++; else
  if (nv+zz-moves-1 <= maxv) return;
  vis[xc][yc] += 10000;
  for (int j=3;j>=0;j--) {
    int xk = xc+dx[j], yk = yc+dy[j];
    if (xk < 0 || yk < 0 || xk >= nn || yk >= mm) continue;
    if (a[xk][yk] != '.') continue;
    if (vis[xk][yk] >= 10000) continue;
    pdd[moves] = j;
    go(xk,yk,xf,yf,moves+1,nv);
  }
  vis[xc][yc] -= 10000;
}
 
int main() {
//  freopen("in","r",stdin);
//  freopen("out","w",stdout);
  scanf("%d",&tt);
  double ans = 0;
  int cans = 0;
  for (qq=1;qq<=tt;qq++) {
    scanf("%d%d%d",&nn,&mm,&k);
    for (i=0;i<nn;i++)
      for (j=0;j<mm;j++) {
        do {
          ch = getchar();
        } while (ch != '.' && ch != 't' && ch != '#');
        a[i][j] = ch;
        aq[i][j] = ch;
      }
  maxcnt = -1;
  int maxkp = 0;
  for (uv=0;uv<4;uv++)
  for (zq=0;zq<2;zq++) {
    n = 0;
    for (i=0;i<nn;i++)
      for (j=0;j<mm;j++)
        if (a[i][j] == 't' || i == nn-1 && j == mm-1 || i == 0 && j == 0) {
          num[i][j] = n;
          xt[n] = i;
          yt[n] = j;
          n++;
        }
        else num[i][j] = -1;
    for (i=0;i<nn;i++)
      for (j=0;j<mm;j++) was[i][j] = -1;
    m = 0;
    for (ii=0;ii<n;ii++) {
      i = 1; e = 1;
      x[1] = xt[ii];
      y[1] = yt[ii];
      z[1] = 0;
      was[x[1]][y[1]] = ii;
      while (i <= e) {
        if (z[i] <= k && (a[x[i]][y[i]] != 't' || i == 1))
          for (j=0;j<4;j++) {
            xk = x[i]+dx[j];
            yk = y[i]+dy[j];
            if (xk >= 0 && yk >= 0 && xk < nn && yk < mm)
              if (a[xk][yk] != '#' && was[xk][yk] < ii) {
                e++;
                x[e] = xk;
                y[e] = yk;
                z[e] = z[i]+1;
                was[xk][yk] = ii;
              }
          }
        i++;
      }
      for (i=1;i<=e;i++)
        if (num[x[i]][y[i]] >= 0 && num[x[i]][y[i]] != ii) {
          zz = z[i];
          if (a[xt[ii]][yt[ii]] != 't') zz++;
          if (a[x[i]][y[i]] != 't') zz++;
          if (zz <= k) {
            m++;
            ss[m] = ii;
            ff[m] = num[x[i]][y[i]];
          }
        }
    }
    for (i=0;i<n;i++) last[i] = 0;
    for (i=1;i<=m;i++) {
      pred[i] = last[ss[i]];
      last[ss[i]] = i;
    }
    for (i=0;i<n;i++) deg[i] = 0;
    for (i=1;i<=m;i++) deg[ss[i]]++;
    for (i=0;i<n;i++) ws[i] = 0;
    rec(0);
    if (ws[n-1] == 0) {
      fprintf(stderr,"test %d is guilty\n",qq);
      goto finish;
    }
    p = n-1; kp = 0;
    while (p > 0) {
      pat[kp++] = p;
      p = pr[p];
    }
    pat[kp] = 0;
 
    int found, jj, q;
    for (i=0;i<n;i++) used[i] = 0;
    for (i=0;i<=kp;i++) used[pat[i]] = 1;
    for (qw=0;qw<10;qw++) {
      for (i=0;i<kp;i++) {
        found = 0;
        j = last[pat[i]];
        while (j > 0) {
          if (!used[ff[j]]) {
            jj = last[pat[i+1]];
            while (jj > 0) {
              if (ff[j] == ff[jj]) {
                for (q=kp+1;q>=i+2;q--) pat[q] = pat[q-1];
                pat[i+1] = ff[j];
                used[pat[i+1]] = 1;
                kp++;
                found = 1;
                break;
              }
              jj = pred[jj];
            }
          }
          if (found) break;
          j = pred[j];
        }
        if (found) i--;
      }
      for (i=0;i<=kp-2;i++) {
        found = 0;
        j = last[pat[i]];
        while (j > 0) {
          if (!used[ff[j]]) {
            jj = last[pat[i+2]];
            while (jj > 0) {
              if (ff[j] == ff[jj] && ff[j] != pat[i+1]) {
                used[pat[i+1]] = 0;
                pat[i+1] = ff[j];
                used[pat[i+1]] = 1;
                found = 1;
                break;
              }
              jj = pred[jj];
            }
          }
          if (found) break;
          j = pred[j];
        }
      }
    }
    if (kp > maxkp) maxkp = kp;
    if (kp >= maxkp-2) {
      for (i=0;i<nn;i++)
        for (j=0;j<mm;j++) vis[i][j] = 0;
      for (qw=0;qw<4 || nn*mm < 3500;qw++) {
        int good = 0;
        for (ii=kp-1;ii>=0;ii--) {
          zz = k;
          if (ii == 0 && a[nn-1][mm-1] == '.') zz--;
          if (ii == kp-1 && a[0][0] == '.') zz--;
          i = 1; e = 1;
          x[1] = xt[pat[ii+1]];
          y[1] = yt[pat[ii+1]];
          z[1] = 0;
          xn = xt[pat[ii]];
          yn = yt[pat[ii]];
          if ((zz & 1) != ((x[1]+y[1]+xn+yn) & 1)) zz--;
          maxv = -1;
          if (qw > 0) {
            maxv--;
            xp = xn; yp = yn; zp = 0;
            while (xp != x[1] || yp != y[1]) {
              vis[xp][yp]--;
              if (vis[xp][yp] == 0) maxv++;
              int dir = r[ii][zp++];
              xp -= dx[dir];
              yp -= dy[dir];
            }
          }
          char oldc = a[xn][yn];
          a[xn][yn] = '.';
          if (k <= 15) go(x[1],y[1],xn,yn,0,0);
          kr[ii] = 0;
          while (xn != x[1] || yn != y[1]) {
            vis[xn][yn]++;
            int dir = pd[xn][yn]-1;
            if (r[ii][kr[ii]] != dir) good = 1;
            r[ii][kr[ii]++] = dir;
            xn -= dx[dir];
            yn -= dy[dir];
          }
          a[xt[pat[ii]]][yt[pat[ii]]] = oldc;
        }
        if (!good) break;
      }
      for (i=0;i<nn;i++)
        for (j=0;j<mm;j++) vis[i][j] = 0;
      ii = jj = 0;
      vis[0][0] = 1;
      count = 0;
      for (i=kp-1;i>=0;i--)
        for (j=kr[i]-1;j>=0;j--) {
          curr[count++] = let[r[i][j]];
          ii += dx[r[i][j]];
          jj += dy[r[i][j]];
          vis[ii][jj] = 1;
        }
      cnt = tot = 0;
      for (i=0;i<nn;i++)
        for (j=0;j<mm;j++) {
          cnt += vis[i][j];
          if (a[i][j] != '#') tot++;
        }
      if (cnt > maxcnt) {
        maxcnt = cnt;
        length = count;
        if (zq == 0)
          for (i=0;i<length;i++) best[i] = curr[i];
        else
          for (i=0;i<length;i++) best[i] = curr[length-i-1];
      }
    }
    for (i=0;i<nn;i++)
      for (j=0;j<mm;j++) aa[i][j] = aq[nn-i-1][mm-j-1];
    for (i=0;i<nn;i++)
      for (j=0;j<mm;j++) a[i][j] = aq[i][j] = aa[i][j];
   }
   ans += 1.0*maxcnt/tot;
   cans++;
   for (i=0;i<length;i++) putchar(best[i]);
   puts("");
   finish: ;
  }
  fprintf(stderr,"%.6f\n",ans/cans);
  return 0;
} 