#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <math.h>
#include <algorithm>
#include <vector>
using namespace std;

const int priority[]={49,45,7,5};

struct Pair{
	int x,y;
	Pair(){x=y=0;}
	Pair(int a,int b):x(a),y(b){}
	bool operator<(const Pair&b)const{
		if(x!=b.x)return x>b.x;
		return y<b.y;
	}
};
bool pair_cmp_smaller(Pair a,Pair b){
	if(a.x!=b.x)return a.x<b.x;
	return a.y<b.y;
}

int n;
int g[55][55];
bool taken[55][55];
int outdgr[55];

void flushwrite(int x,int y){
	printf("%d %d\n",x,y);
	fflush(stdout);
}

inline bool moveable(int p){
	return outdgr[p]>0;
}

Pair maxdegree(int p){
	Pair best;
	for(int i=1;i<=n;i++){
		if(i==p||taken[p][i])continue;
		if(g[p][i]>best.x){
			best.x=g[p][i];
			best.y=i;
		}
	}
	return best;
}

vector<int> stg1(int p){
	vector<int> ans;
	vector<Pair> tmp;
	for(int i=1;i<=n;i++){
		if(i==p||taken[p][i])continue;
		tmp.push_back(Pair(g[p][i]-maxdegree(i).x,i));
	}
	sort(tmp.begin(),tmp.end());
	for(int i=0;i<tmp.size();i++){
		ans.push_back(tmp[i].y);
	}
	return ans;
}

vector<Pair> Best_two_steps(int p){
	vector<Pair> tmp;
	for(int i=1;p&&i<=n;i++){
		if(i==p||taken[p][i])continue;
		tmp.push_back(Pair(g[p][i]-maxdegree(i).x,i));
	}
	sort(tmp.begin(),tmp.end());
	if(tmp.size()==0)tmp.push_back(Pair(0,0));
	return tmp;
}

vector<int> stg2(int p){
	vector<int> ans;
	vector<Pair> tmp;
	for(int i=1;i<=n;i++){
		if(i==p||taken[p][i])continue;
		taken[p][i]=true;
		vector<Pair>tt=Best_two_steps(i);
		tmp.push_back(Pair(g[p][i]-tt[0].x,i));
		taken[p][i]=false;
	}
	sort(tmp.begin(),tmp.end());
	for(int i=0;i<tmp.size();i++){
		ans.push_back(tmp[i].y);
	}
	return ans;
}

vector<int> stg3(int p){
	vector<int> ans;
	vector<Pair> tmp;
	for(int i=1;i<=n;i++){
		if(i==p||taken[p][i])continue;
		Pair t2=maxdegree(i);
		taken[p][i]=true;
		tmp.push_back(Pair(g[p][i]-t2.x+maxdegree(t2.y).x,i));
		taken[p][i]=false;
	}
	sort(tmp.begin(),tmp.end());
	for(int i=0;i<tmp.size();i++){
		ans.push_back(tmp[i].y);
	}
	return ans;
}

vector<int> stg3_better(int p){
	vector<int> ans;
	vector<Pair> tmp;
	for(int i=1;i<=n;i++){
		if(i==p||taken[p][i])continue;
		Pair t2=maxdegree(i);
		taken[p][i]=true;
		tmp.push_back(Pair(g[p][i]-t2.x+Best_two_steps(t2.y)[0].x,i));
		taken[p][i]=false;
	}
	sort(tmp.begin(),tmp.end());
	for(int i=0;i<tmp.size();i++){
		ans.push_back(tmp[i].y);
	}
	return ans;
}

vector<int> stg4(int p){
	vector<int> ans;
	vector<Pair> tmp;
	for(int i=1;i<=n;i++){
		if(i==p||taken[p][i])continue;
		Pair t2=maxdegree(i);
		taken[p][i]=true;
		Pair t3=maxdegree(t2.y);
		tmp.push_back(Pair(g[p][i]-t2.x+t3.x-maxdegree(t3.y).x,i));
		taken[p][i]=false;
	}
	sort(tmp.begin(),tmp.end());
	for(int i=0;i<tmp.size();i++){
		ans.push_back(tmp[i].y);
	}
	return ans;
}

int main()
{
	scanf("%d",&n);
	int maxx,maxy,maxv=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			scanf("%d",&g[i][j]);
			if(g[i][j]>maxv){
				maxx=i;maxy=j;maxv=g[i][j];
			}
		}
		outdgr[i]=n-1;
	}
	flushwrite(maxx,maxy);
	taken[maxx][maxy]=true;
	outdgr[maxx]--;
	int px,py;
	int state=0;
	while(~scanf("%d%d",&px,&py)){
		if(state!=2)state=(maxdegree(px).y==py)?1:2;
		taken[px][py]=true;
		outdgr[px]--;
		if(!moveable(py)) return 0;
		vector<int> ans1=stg1(py);
		vector<int> ans2=stg2(py);
		vector<int> ans3=stg3(py);
		vector<int> ans3_b=stg3_better(py);
		vector<int> ans4=stg4(py);
		int rank[55]={0};
		for(int i=0;i<ans1.size();i++){
			rank[ans1[i]]+=(state==1?priority[0]:priority[1])*(i+1);
			rank[ans2[i]]+=(state==2?priority[0]:priority[1]/2)*(i+1);
			rank[ans3[i]]+=priority[3]*(i+1);
			rank[ans3_b[i]]+=(state==1?priority[0]+3:priority[1]-5)*(i+1);
			rank[ans4[i]]+=priority[2]*(i+1);
		}
		vector<Pair>ans;
		for(int i=1;i<=n;i++){
			if(rank[i]){
				ans.push_back(Pair(rank[i],i));
			}
		}
		sort(ans.begin(),ans.end(),pair_cmp_smaller);
		flushwrite(py,ans[0].y);
		taken[py][ans[0].y]=true;
		outdgr[py]--;
		if(!moveable(ans[0].y)) return 0;
	}
    return 0;
}