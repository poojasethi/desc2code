//{{{
#include <algorithm>
#include <cassert>
#include <cstdio>
#include <cstdlib>
#include <cctype>
#include <cmath>
#include <cstring>
#include <iostream>
#include <sstream>
#include <string>
#include <utility>
#include <vector>
#include <cassert>
#include <ctime>
#include <queue>
using namespace std;
#define VAR(a,b) __typeof(b) a=(b)
#define REP(i,n) for(int _n=n, i=0;i<_n;++i)
#define FOR(i,a,b) for(int i=(a),_b=(b);i<=_b;++i)
#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;--i)
#define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it)
#define ALL(c) (c).begin(),(c).end()
#define TRACE(x) cerr << "TRACE(" #x ")" << endl;
#define DEBUG(x) cerr << #x << " = " << x << endl;
 
template<class T>
ostream& operator<<(ostream&o, const vector<T>&v) {
  o<<'{';
  FOREACH(it,v) o<<*it<<',';
  return o<<'}';
}
typedef long long LL;
const int INF = 1000000000; const LL INFLL = LL(INF) * LL(INF);
typedef vector<int> VI; typedef vector<string> VS; typedef vector<VI> VVI;
template<class T> inline int size(const T&c) { return c.size(); }
 
class INPUT {
  static const int BUFSIZE = 1<<16;
  static char buffer[];
  char *bufpos;
  char *bufend;
  void grabBuffer();
 public:
  INPUT() { grabBuffer(); }
  bool eof() { return bufend==buffer; }
  char nextChar() { return *bufpos; }
  inline char readChar();
  inline void skipWS();
  inline unsigned readUnsigned();
  inline int readInt();
  int readCost();
};
 
char INPUT::buffer[INPUT::BUFSIZE];
 
void INPUT::grabBuffer() {
  bufpos = buffer;
  bufend = buffer + read(0, buffer, BUFSIZE);
}
 
char INPUT::readChar() {
  char res = *bufpos++;
  if(bufpos==bufend) grabBuffer();
  return res;
}
 
inline bool myisspace(char c) { return c<=' '; }
 
void INPUT::skipWS() {
  while(!eof() && myisspace(nextChar())) readChar();
}
 
unsigned INPUT::readUnsigned() {
  skipWS();
  unsigned res = 0;
  while(!eof() && isdigit(nextChar())) {
    res = 10u * res + (readChar()-'0');
  }
  return res;
}
 
int INPUT::readInt() {
  skipWS();
  bool neg = false;
  if(!eof() && nextChar()=='-') { neg=true; readChar(); }
  int res = static_cast<int>(readUnsigned());
  if(neg) res = -res;
  return res;
}
 
int INPUT::readCost() {
  int a = readUnsigned();
  assert(a>=0 && a<=1000000);
  int afterDecimal = 0;
  if(!eof() && nextChar() == '.') {
    readChar();
    while(!eof() && isdigit(nextChar())) {
      a = 10 * a + (readChar()-'0');
      ++afterDecimal;
    }
  }
  assert(afterDecimal <= 2);
  while(afterDecimal < 2) { a = 10*a; ++afterDecimal; }
  return a;
}
 
class OUTPUT {
  static const int BUFSIZE = 1<<16;
  static char buffer[];
  char *bufpos;
  char *BUFLIMIT;
 public:
  void flushBuffer();
  OUTPUT():bufpos(buffer),BUFLIMIT(buffer+BUFSIZE-100) {}
  ~OUTPUT() { flushBuffer(); }
  inline void operator()(char c);
  inline void operator()(unsigned x);
  inline void operator()(int x);
  inline void operator()(const char*s);
  void operator()(const string&s) { operator()(s.c_str()); }
  template<class A,class B>
  void operator()(const A& a,const B& b) {
    operator()(a); operator()(b);
  }
  template<class A,class B,class C>
  void operator()(const A& a,const B& b,const C&c) {
    operator()(a); operator()(b); operator()(c);
  }
  template<class A,class B,class C,class D>
  void operator()(const A& a,const B& b,const C&c,const D&d) {
    operator()(a); operator()(b); operator()(c); operator()(d);
  }
  template<class A,class B,class C,class D,class E>
  void operator()(const A& a,const B& b,const C&c,const D&d,const E&e) {
    operator()(a); operator()(b); operator()(c); operator()(d); operator()(e);
  }
  template<class A,class B,class C,class D,class E,class F>
  void operator()(const A& a,const B& b,const C&c,const D&d,const E&e,const F&f) {
    operator()(a); operator()(b); operator()(c); operator()(d); operator()(e); operator()(f);
  }
};
 
char OUTPUT::buffer[OUTPUT::BUFSIZE];
 
void OUTPUT::flushBuffer() {
  char *p = buffer;
  while(p < bufpos) {
    p += write(1, p, bufpos-p);
  }
  bufpos = buffer;
}
 
void OUTPUT::operator()(char c) {
  *bufpos = c;
  ++bufpos;
  if(bufpos >= BUFLIMIT) flushBuffer();
}
 
void OUTPUT::operator()(unsigned x) {
  char *old = bufpos;
  do {
    *bufpos = char('0' + x % 10u);
    x /= 10u;
    ++bufpos;
  } while(x);
  reverse(old, bufpos);
  if(bufpos >= BUFLIMIT) flushBuffer();
}
 
void OUTPUT::operator()(int x) {
  if(x<0) { operator()('-'); x = -x; }
  operator()(static_cast<unsigned>(x));
}
 
void OUTPUT::operator()(const char*s) {
  while(*s) operator()(*s++);
}
 
INPUT input;
OUTPUT output;
 
 
//}}}
 
const int MAX_FACTORIES = 100;
const int MAX_CLIENTS = 100;
 
struct Solution {
  LL value;
  bool open[MAX_FACTORIES];
  int choice[MAX_CLIENTS];
};
 
struct State {
  LL extraPayment;
  LL newFixedCost[MAX_FACTORIES];
  LL payment[MAX_CLIENTS];
 
  LL shortfall[MAX_FACTORIES];
  LL totalPayment;
  Solution sol;
};
 
int nfactories, nclients;
LL fixedCost[MAX_FACTORIES];
LL dist[MAX_CLIENTS][MAX_FACTORIES];
LL sortedDist[MAX_CLIENTS][MAX_FACTORIES];
Solution bestSolution;
 
void readInput() {
  nfactories = input.readInt();
  assert(1 <= nfactories && nfactories <= MAX_FACTORIES);
  nclients = input.readInt();
  assert(1 <= nclients && nclients <= MAX_CLIENTS);
  REP(f, nfactories) fixedCost[f] = input.readCost();
  REP(c, nclients) REP(f, nfactories) dist[c][f] = input.readCost();
}
 
void printSolution() {
  REP(f, nfactories) {
    if(f>0) output(' ');
    output(bestSolution.open[f] ? '1' : '0');
  }
  output('\n');
  REP(c, nclients) {
    if(c>0) output(' ');
    output(bestSolution.choice[c] + 1);
  }
  output('\n');
}
 
void calcSortedDist() {
  REP(c, nclients) {
    REP(f, nfactories) sortedDist[c][f] = dist[c][f];
    sort(sortedDist[c], sortedDist[c] + nfactories);
  }
}
 
void profitOptimization(State *state) {
  static bool enabled[MAX_CLIENTS];
  static int next[MAX_CLIENTS];
  REP(c, nclients) enabled[c]=true;
  REP(f, nfactories) {
    state->shortfall[f] = state->newFixedCost[f];
    REP(c, nclients) state->shortfall[f] -= max(0LL, state->payment[c] - dist[c][f]);
  }
  REP(c, nclients) {
    next[c] = lower_bound(sortedDist[c], sortedDist[c]+nfactories,
        state->payment[c]) - sortedDist[c];
    if(next[c] < nfactories && state->payment[c] == sortedDist[c][next[c]])
      ++next[c];
  }
  bool keepGoing = true;
  while (keepGoing) {
    keepGoing = false;
    REP(c, nclients) if(enabled[c]) {
      LL delta = INFLL;
      REP(f, nfactories) if(state->payment[c] - dist[c][f] >= 0)
        delta = min(delta, state->shortfall[f]);
      if (next[c] < nfactories && delta > sortedDist[c][next[c]] - state->payment[c]) {
        delta = sortedDist[c][next[c]] - state->payment[c];
        ++next[c];
        keepGoing = true;
      } else enabled[c]=false;
      REP(f, nfactories) if(state->payment[c] - dist[c][f] >= 0)
        state->shortfall[f] -= delta;
      state->payment[c] += delta;
    }
  }
}
 
void genAssignment(State *state) {
  state->totalPayment = state->extraPayment;
  REP(c, nclients) state->totalPayment += state->payment[c];
 
  REP(f, nfactories) state->sol.open[f] = false;
  REP(c, nclients) {
    int ff = -1;
    REP(f, nfactories) if(state->shortfall[f] == 0 &&
        state->payment[c] >= dist[c][f]) {
      if(ff != -1) { ff=-1; break; }
      ff = f;
    }
    if (ff != -1) { 
      state->sol.open[ff] = true;
      state->sol.choice[c] = ff;
    } else state->sol.choice[c] = -1;
  }
  REP(c, nclients) if(state->sol.choice[c] == -1) {
    int ff = -1;
    REP(f, nfactories) if(state->shortfall[f] == 0 &&
        state->payment[c] >= dist[c][f]) {
      if (ff==-1 || dist[c][f] < dist[c][ff]) ff=f;
    }
    assert(ff != -1);
    state->sol.open[ff] = true;
    state->sol.choice[c] = ff;
  }
  state->sol.value = 0;
  REP(f, nfactories) if(state->sol.open[f]) state->sol.value += fixedCost[f];
  REP(c, nclients) state->sol.value += dist[c][state->sol.choice[c]];
}
 
State *initialState() {
  State *state = new State();
  state->extraPayment = 0;
  REP(f, nfactories) state->newFixedCost[f] = fixedCost[f];
  REP(c, nclients) state->payment[c] = sortedDist[c][0];
  return state;
}
 
void trySolving(State *state) {
  profitOptimization(state);
  genAssignment(state);
}
 
pair<State*, State*> branchState(State *state) {
  int ff = -1;
  REP(f, nfactories) if(state->sol.open[f]) {
    bool bad = false;
    REP(c, nclients) if(state->sol.choice[c] != f && state->payment[c] > dist[c][f]) {
      bad = true; break;
    }
    if(bad) { ff=f; break; }
  }
  assert(ff != -1);
 
  State *sClosed = new State(*state);
  sClosed->newFixedCost[ff] = INFLL;
 
  State *sOpen = new State(*state);
  sOpen->extraPayment += sOpen->newFixedCost[ff];
  sOpen->newFixedCost[ff] = 0;
  REP(c, nclients) sOpen->payment[c] = min(sOpen->payment[c], dist[c][ff]);
 
  return make_pair(sOpen, sClosed);
}
 
void solve() {
  bestSolution.value = INFLL;
  vector<State*> states;
  states.push_back(initialState());
  while(!states.empty()) {
    State *state = states.back(); states.pop_back();
    trySolving(state);
    if(state->sol.value < bestSolution.value) bestSolution = state->sol;
    if(state->totalPayment < bestSolution.value) {
      pair<State*, State*> p = branchState(state);
      states.push_back(p.first);
      states.push_back(p.second);
    }
    delete state;
  }
}
 
int main() {
  int ntc = input.readInt();
  REP(tc,ntc) {
    readInput();
    calcSortedDist();
    solve();
    printSolution();
  }
}
  