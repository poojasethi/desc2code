/*
 Team Proof
 IIT Delhi
 
 C++ Template
 */


#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cassert>
#include <string>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <cstdlib>
using namespace std;

#define s(T) scanf("%d", &T)
#define sl(T) scanf("%lld", &T)
#define fill(a, val) memset(a, val, sizeof(a))
#define mp make_pair

//parameters
const double ln2 = pow(log(2.0), 2.0);
const double actln2 = log(2.0);
const double lnln2 = log(ln2);
const double exchg = 0.025;

int totalCases, testNum;

int dist(int x1, int y1, int x2, int y2)
{
	return abs((x1 - x2)) + abs((y1 - y2));
}

int N,M;
int H[105][105];
int output[105][105];
double tmpH[2][105][105];

double split;

void preprocess()
{
	
}

bool input()
{
	s(N);
	s(M);
	for(int i = 0; i < N; i++)
		for(int j = 0; j < M; j++)
			s(H[i][j]);
	
	return true;
}

void display()
{
	for(int i = 0; i < N; i++)
	{
		for(int j = 0; j < M; j++)
			printf("%d ", (output[i][j]));
		printf("\n");
	}
	printf("\n");
}

double avg(int i, int j, int prevparity, double inertia)
{
	int cnt = 0;
	
	double mean = 0.0;
	double m = 0.0, M = 50.0;
	
	if(i > 0)
	{
		m = min(m, tmpH[prevparity][i-1][j]);
		M = max(M, tmpH[prevparity][i-1][j]);
//		mean += tmpH[prevparity][i-1][j];
//		cnt++;
	}
	if(i < N-1)
	{
		m = min(m, tmpH[prevparity][i+1][j]);
		M = max(M, tmpH[prevparity][i+1][j]);
//		mean += tmpH[prevparity][i+1][j];
//		cnt++;
	}
	
	if(j > 0)
	{
		m = min(m, tmpH[prevparity][i][j-1]);
		M = max(M, tmpH[prevparity][i][j-1]);
//		mean += tmpH[prevparity][i][j-1];
//		cnt++;
	}
	if(j < M-1)
	{
		m = min(m, tmpH[prevparity][i][j+1]);
		M = max(M, tmpH[prevparity][i][j+1]);
//		mean += tmpH[prevparity][i][j+1];
//		cnt++;
	}
	
	return inertia * tmpH[prevparity][i][j] + (1-inertia) * (m+M)/2;
}

void dodH(int i, int j, int parity, bool mult)//double xp)
{
	int old = 1 ^ parity;
	double val = tmpH[old][i][j];
	double diff, cons, term;
	
	double dH = 0.0;
	double d2H = 0.0;
	
	double mup = 50.0;
	double mdown = 0.0;
	
	double scale;
	if(mult)
		scale = ln2;
	else 
		scale = 1/ln2;
	
	if(i > 0)
	{
		cons = tmpH[old][i-1][j];
		diff=abs((val - cons));
		if(diff > 1e-9)
		{
			term = exp(actln2*diff);
			d2H += term;
			if(val < cons)
			{	
				mup = min(mup, cons);
				dH -= term;
			}
			else 
			{	
				mdown = max(mdown, cons);
				dH += term;
			}
		}
	}
	if(i < N-1)
	{
		cons = tmpH[old][i+1][j];
		diff=abs((val - cons));
		if(diff > 1e-9)
		{
			term = exp(actln2*diff);
			d2H += term;
			if(val < cons)
			{	
				mup = min(mup, cons);
				dH -= term;
			}
			else 
			{	
				mdown = max(mdown, cons);
				dH += term;
			}
		}
	}
	if(j > 0)
	{
		cons = tmpH[old][i][j-1];
		diff=abs((val - cons));
		if(diff > 1e-9)
		{
			term = exp(actln2*diff);
			d2H += term;
			if(val < cons)
			{	
				mup = min(mup, cons);
				dH -= term;
			}
			else 
			{	
				mdown = max(mdown, cons);
				dH += term;
			}
		}
	}
	if(j < M-1)
	{
		cons = tmpH[old][i][j+1];
		diff=abs((val - cons));
		if(diff > 1e-9)
		{
			term = exp(actln2*diff);
			d2H += term;
			if(val < cons)
			{	
				mup = min(mup, cons);
				dH -= term;
			}
			else 
			{	
				mdown = max(mdown, cons);
				dH += term;
			}
		}
	}
	
	double newval = val - dH/d2H*scale;
	if(dH > 1e-9)
	{
		tmpH[parity][i][j] = max(newval, mdown-exchg);
	}
	else if(dH < -1e-9)
	{
		tmpH[parity][i][j] = min(newval, mup+exchg);
	}
}

double frac[10000];

void intelrnd(int parity)
{
	int nm = N*M;
	
	for(int i = 0, k = 0; i < N; i++)
		for(int j = 0; j< M; j++,k++)
			frac[k] = tmpH[parity][i][j] - (int)tmpH[parity][i][j];
	
	double m = 0.025;
	sort(frac, frac + nm);
	split = 0.5;
	for(int i = 0; i < nm-1; i++)
		if(m < frac[i+1]-frac[i])
		{
			m = frac[i+1]-frac[i];
			split = 0.5*(frac[i+1] + frac[i]);
		}
	if(m < 1 + frac[0] - frac[nm-1])
	{
		m = 1 + frac[0] - frac[nm-1];
		split = 0.5*(1 + frac[0] + frac[nm-1]);
	}
}

void solve()
{
	for(int i = 0; i < N; i++)
		for(int j = 0; j < M; j++)
			output[i][j] = H[i][j];
	
	int Qx[10005], Qy[10005];
	int qf, qb;
	qf = qb = 0;
	
	for(int i = 0; i < N; i++)
		for(int j = 0; j < M; j++)
			if(H[i][j] != 0)
			{
				Qx[qb] = i;
				Qy[qb++] = j;
			}
	
	while(qf < qb)
	{
		int curx, cury;
		curx = Qx[qf];
		cury = Qy[qf++];
		
		for(int nxtx = max(0, curx - 1), lx = min(curx+1, N-1); nxtx <= lx; nxtx++)
			for(int nxty = max(0, cury-1), ly = min(cury+1, M-1); nxty <= ly; nxty++)
				if(!output[nxtx][nxty])
				{
					output[nxtx][nxty] = output[curx][cury];
					Qx[qb] = nxtx;
					Qy[qb++] = nxty;
				}
		
	}
	
	for(int i = 0; i < N; i++)
		for(int j = 0; j < M; j++)
			tmpH[0][i][j] = tmpH[1][i][j] = output[i][j];
	
	int iter, tlim, now, old;
	double inertia;
	for(iter = 1, now = 1, old = 0, tlim = 320000/N/M-2, inertia = (tlim-1)/(2.0*tlim); iter < tlim; iter++, now ^= 1, old ^= 1, inertia -= 0.5/(tlim))
	{
		for(int i = 0; i < N; i++)
			for(int j = 0; j < M; j++) 
			{	
				if(!H[i][j])
					tmpH[now][i][j] = avg(i, j, old, inertia);
			}
	}
	
	for(tlim += (int)(tlim); iter < tlim; iter++, now^=1)
		for(int i = 0; i < N; i++)
			for(int j = 0; j < M; j++)
			{	
				if(!H[i][j])
					dodH(i, j, now, true);
			}
	
	now ^= 1;
	intelrnd(now);
	for(int i = 0; i < N; i++)
		for(int j = 0; j < M;j++)
			output[i][j] = (int)(tmpH[now][i][j] + 1-split + 1e-9);
	display();
}

int main()
{
	preprocess();
	s(totalCases);
	for(testNum = 1; testNum <= totalCases; testNum++)
	{
		if( !input())
			break;
		solve();
	}
}