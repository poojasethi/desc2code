#include<cstdio>
#include<cstring>
#include<algorithm>
#include<set>
#include<map>
#include<ctime>
#include<vector>
#define rep(i,j,k) for(int i=(int)j;i<=(int)k;i++)
#define per(i,j,k) for(int i=(int)j;i>=(int)k;i--)
using namespace std;
typedef long long LL;
typedef double db;
const int N=105;
int a[N][N],n,m;
bool can[N][N];
bool need[N][N];
LL ck(int x,int y){
	LL ans=0;
	if(x>1)ans+=(1ll<<abs(a[x][y]-a[x-1][y]));
	if(x<n)ans+=(1ll<<abs(a[x][y]-a[x+1][y]));
	if(y>1)ans+=(1ll<<abs(a[x][y]-a[x][y-1]));
	if(y<m)ans+=(1ll<<abs(a[x][y]-a[x][y+1]));
	return ans;
}
int q[N*N][2];int M;
void Main(){
	scanf("%d%d",&n,&m);int ma=0;
	rep(i,1,n)rep(j,1,m){scanf("%d",&a[i][j]);if(a[i][j]>ma)ma=a[i][j];}
	rep(i,1,n)rep(j,1,m){
		need[i][j]=1;
		can[i][j]=0;
		if(a[i][j]==0){
			can[i][j]=1;
			if(!a[i][j])a[i][j]=1;
		}
	}
	srand((int)time(0));
	rep(i,1,n)rep(j,1,m)if(can[i][j]){
		int clo=n+m+5;int cg=30;
		rep(l,1,n)rep(k,1,m)if(!can[l][k])
		if(abs(i-l)+abs(j-k)<clo){
			clo=abs(i-l)+abs(j-k);
			cg=a[l][k];
		}
		a[i][j]=cg;
	}
	
	M=0;
	rep(i,1,n)rep(j,1,m)if(can[i][j]){
		++M;q[M][0]=i;q[M][1]=j;
	}
	
	rep(tim,1,1000){
		rep(k,1,n*m/60){
			int x=rand()%M+1;
			a[q[x][0]][q[x][1]]--;
			if(!a[q[x][0]][q[x][1]])a[q[x][0]][q[x][1]]+=2;
			need[q[x][0]][q[x][1]]=1;
		}
		rep(i,1,n)rep(j,1,m)if(can[i][j])if(need[i][j]){
			while(a[i][j]<50){
				LL x1=ck(i,j);
				a[i][j]++;
				LL x2=ck(i,j);
				//if(i==1&&j==2)printf("_%d %lld %lld\n",a[i][j],x1,x2);
				if(x2>x1){a[i][j]--;break;}
				need[i-1][j]=need[i][j-1]=need[i+1][j]=need[i][j+1]=1;
			}
			while(a[i][j]>1){
				LL x1=ck(i,j);
				a[i][j]--;
				LL x2=ck(i,j);
				if(x2>x1){a[i][j]++;break;}
				need[i-1][j]=need[i][j-1]=need[i+1][j]=need[i][j+1]=1;
			}
			need[i][j]=0;
		}
	}
	rep(i,1,n){
		rep(j,1,m)printf("%d ",a[i][j]);printf("\n");
	}
}
int main(){
	int T;scanf("%d",&T);
	while(T--)Main();
	return 0;
}
