#include <iostream>
#include <cstdio>
#include <cctype>
#include <string>
#include <cmath>
#include <vector>
#include <algorithm>
#include <stack>
#include <queue>
#include <map>
#include <set>
#include <sstream>
#include <fstream>
#include <ctime>
#include <cassert>
 
using namespace std;
 
#define GI ({int t;scanf("%d",&t);t;})
#define GL ({LL t;scanf("%lld",&t);t;})
#define GD ({double t;scanf("%lf",&t);t;})
#define FOR(i,a,b) for(int i=a;i<b;i++)
#define REP(i,n) FOR(i,0,n)
#define ROF(i,a,b) for(int i=a;i>b;i--)
#define SET(x,a) memset(x,a,sizeof(x));
#define all(a) a.begin(),a.end()
#define rall(a) a.rbegin(),a.rend()
#define tr(i,a) for( typeof(a.begin()) i=a.begin();i!=a.end();i++)
#define pb push_back
#define sz(a) (int)(a.size())
#define INF (int)1e9
#define EPS (double)1e-9
 
#define is istringstream
#define os ostringstream
#define lb lower_bound
#define ub upper_bound
#define bs binary_search
 
typedef long long LL;
typedef pair< int,int > ii;
typedef pair< int, ii > pi;
typedef vector< ii > vii;
typedef vector < vii > vvii;
typedef vector< int > vi;
typedef vector< vi > vvi;
 
#define MAXN 200+5
int grid[MAXN][MAXN];
int mod_grid[MAXN][MAXN];
int islandid[MAXN][MAXN];
int visited[MAXN][MAXN];
int visitid, islands;
int m, n;
 
vvii boundaries_of_island;
vi island_order;
 
int di[] = {1, -1, 0, 0, -1, -1, 1, 1}, dj[] = {0, 0, -1, 1, -1, 1, -1, 1};
int parent_for_dijk[MAXN][MAXN];
int dist_for_dijk[MAXN][MAXN];
int seen_for_dijk[MAXN][MAXN];
int seenid_for_dijk;
int parent[(MAXN) * (MAXN)];
int rank[(MAXN) * (MAXN)];
 
// checks if a point is valid
inline bool ok(int i, int j){
    return i >= 0 && i < m && j >= 0 && j < n;
}
 
// if it returns 4, then the point is surrounded by land on all sides( hence not on the boundary of an island )
inline int neighbours(int i, int j){
	int ret = 0;
    REP(k, 4){
		if(!ok(i + di[k], j + dj[k]))    continue;
		if(grid[i + di[k]][j + dj[k]] == -1)    ret++;
	}
	return ret;
}
 
// find the representative of the set x
inline int find_set(int x){
    if(parent[x] != x)    parent[x] = find_set(parent[x]);
    return parent[x];
}
 
// unite 2 sets with representatives x & y
inline void union_set(int x, int y){
    x = find_set( x ), y = find_set( y );
    if(x == y)    return;
    if(rank[x] > rank[y])    parent[y] = x;
    else parent[x] = y;
    if(rank[x] == rank[y])    rank[y]++;
}
 
// partition the input into disjoint islands
inline void find_island(int island_id, int i, int j){
	queue < ii > q;
	q.push(ii(i, j));
	visited[i][j] = visitid;
	boundaries_of_island[island_id].pb( ii(i, j) );
	islandid[i][j] = island_id;
	while(!q.empty()){
	    ii cur = q.front();
	    q.pop();
		int ci = cur.first, cj = cur.second;
		REP(k, 8){
			int ni = ci + di[k], nj = cj + dj[k];
		    if(ok(ni, nj) && (visited[ni][nj] != visitid) && grid[ni][nj] == -1){
			    q.push( ii(ni, nj) );
			    visited[ni][nj] = visitid;
			    islandid[ni][nj] = island_id;
			    union_set(n * ni + nj, n * ci + cj);
			    if(neighbours(ni, nj) < 4)    boundaries_of_island[island_id].pb( ii(ni, nj) );
			}
		}
	}
}
 
// no of test cases to be done by brute - force
#define critical_value 10
 
int main(){
	int _ = GI;
	int kase = 0;
	while(_--){
		kase++;
		// generate a new seed value each time
		srand( time(NULL) );
		visitid++;
		islands = 0;
		m = GI, n = GI;
		REP(i, m)    REP(j, n){
			grid[i][j] = GI, mod_grid[i][j] = grid[i][j], islandid[i][j] = -1;
			// create disjoint sets
			rank[n * i + j] = 0, parent[n * i + j] = n * i + j;
		}
		// create distinct islands
		boundaries_of_island.resize(m * n);
		REP(i, m)    REP(j, n){
		    if(visited[i][j] == visitid || grid[i][j] != -1)    continue;
			find_island( islands, i, j );
			islands++;
		}
		REP(i, islands)    	island_order.pb( i );
		random_shuffle(all( island_order ));
		REP(i, islands)    random_shuffle(all( boundaries_of_island[i] ));
		REP(i, islands){
			// Choose a random point on boundary of island 
			int luck = rand() % sz( boundaries_of_island[island_order[i]] );
			int si = boundaries_of_island[island_order[i]][luck].first, sj = boundaries_of_island[island_order[i]][luck].second;
			//do a dijkstra from the random start point and stop for the first time you reach some unseen land
			//Note: Land can be existing land or land formed by us
			//Have disjoint set data structure to unite 2 islands if they are different and we have joined them now by some path
			//We use the answer iff the source and dest are in different sets
			seenid_for_dijk++;
			REP(i, m)    REP(j, n)    dist_for_dijk[i][j] = INF;
			set < pi > s;
			dist_for_dijk[si][sj] = 0;
			seen_for_dijk[si][sj] = seenid_for_dijk;
			parent_for_dijk[si][sj] = -1;
			s.insert( pi(0, ii( si, sj )) );
			while(!s.empty()){
				pi cur = *(s.begin());
				s.erase(s.begin());
				int dist = cur.first;
				int ci = cur.second.first, cj = cur.second.second;
				seen_for_dijk[ci][cj] = seenid_for_dijk;
				if(mod_grid[ci][cj] == -1 && find_set(n * ci + cj) != find_set(n * si + sj)){
					int tmp_par;
					while( 1 ){
						union_set(n * si + sj, n * ci + cj);
						mod_grid[ci][cj] = -1;
						tmp_par = parent_for_dijk[ci][cj];
						if(tmp_par == -1)    break;
						ci = tmp_par / n, cj = tmp_par % n;
					}
					break;
				}
				REP(k, 8){
					int ni = ci + di[k], nj = cj + dj[k];
					if(ok(ni, nj) && seen_for_dijk[ni][nj] != seenid_for_dijk){
						int new_dist = dist_for_dijk[ci][cj] + (mod_grid[ni][nj] == -1 ? 0 : mod_grid[ni][nj]);
						if(dist_for_dijk[ni][nj] > new_dist){
							if(dist_for_dijk[ni][nj] != INF)    s.erase(s.find(pi( dist_for_dijk[ni][nj], ii( ni, nj ))));
							dist_for_dijk[ni][nj] = new_dist;
							parent_for_dijk[ni][nj] = n * ci + cj;
							s.insert(pi( dist_for_dijk[ni][nj], ii( ni, nj )));
						}	
					}	
				}
			}
			ii some_point = boundaries_of_island[0][0];
			int ci = some_point.first, cj = some_point.second;
			int cur_set = find_set(n * ci + cj), flag = 1;
			FOR(j, 1, islands){
				some_point = boundaries_of_island[j][0];
				ci = some_point.first, cj = some_point.second;
				if(find_set(n * ci + cj) != cur_set){
				    flag = 0;
					break;	
				}
			}
			if(flag)    break;
		}
		vii points;
		int ans = 0;
		REP(i, m)    REP(j, n){
		    if(mod_grid[i][j] == -1 && grid[i][j] != -1){
			    ans += grid[i][j];
				points.pb(ii( i + 1, j + 1 ));
			}	
		}
		printf("%d\n", ans);
		printf("%d\n", sz( points ));
		REP(i, sz( points ))    printf("%d %d\n", points[i].first, points[i].second);
		boundaries_of_island.clear();
		island_order.clear();
	}
	//GI;
    return 0;
}