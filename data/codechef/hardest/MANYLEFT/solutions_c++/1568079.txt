bool submit=1;
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <climits>
#include <cfloat>
#include <map>
#include <utility>
#include <set>
#include <iostream>
#include <memory>
#include <string>
#include <vector>
#include <algorithm>
#include <functional>
#include <sstream>
#include <complex>
#include <stack>
#include <queue>
#include <cstring>
#include <assert.h>
#include <sys/time.h>
#include <fstream>
#define FOR(i,a,b) for(int i=(a);i<(b);++i)
#define rep(i,n) FOR(i,0,n)
#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)
#define exist(s,e) ((s).find(e)!=(s).end())
#define all(vec) (vec).begin(),(vec).end()
#define dump(x) cerr << #x << " = " << (x) << endl;
#define debug(x) cerr << #x << " = " << (x) << " (L" << __LINE__ << ")" << " " << __FILE__ << endl;
#define deb(x) cerr << #x << " = " << (x) << " , ";
#define debl cerr << " (L" << __LINE__ << ")"<< endl;
#define clr(a) memset((a),0,sizeof(a))
#define nclr(a) memset((a),-1,sizeof(a))
#define pb push_back
#define INRANGE(x,s,e) ((s)<=(x) && (x)<(e))
#define MP(x,y) make_pair((x),(y))
#define sz(v) ((ll)(v).size())
#define bit(n) (1LL<<n)
double pi=3.14159265358979323846;
using namespace std;
static const double EPS = 1e-5;
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef pair<ll,double> pld;
typedef pair<double,ll> pdl;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<ll> vl;
typedef vector<vl> vvl;
typedef vector<double> vd;
typedef vector<vd> vvd;
typedef vector<string> vs;
template<typename T> std::ostream& operator<<(std::ostream& os, const vector<T>& z){
os << "[ ";
rep(i,z.size())os << z[i] << ", " ;
return ( os << "]" << endl);
}
template<typename T> std::ostream& operator<<(std::ostream& os, const set<T>& z){
os << "set( ";
each(p,z)os << (*p) << ", " ;
return ( os << ")" << endl);
}
template<typename T,typename U> std::ostream& operator<<(std::ostream& os, const map<T,U>& z){
os << "{ ";
each(p,z)os << (p->first) << ": " << (p->second) << ", " ;
return ( os << "}" << endl);
}
template<typename T,typename U> std::ostream& operator<<(std::ostream& os, const pair<T,U>& z){
return ( os << "(" << z.first << ", " << z.second << ",)" );
}
double get_time(){
struct timeval tv;
gettimeofday(&tv, NULL);
return tv.tv_sec + tv.tv_usec*1e-6;
}
typedef unsigned int uint32_t;
struct RND{
uint32_t x;
uint32_t y;
uint32_t z;
uint32_t w;
RND(){
x=123456789;
y=362436069;
z=521288629;
w=88675123;
}
void init(int seed){
x=123456789;
y=362436069;
z=521288629;
w=seed+100;
rep(i,10)get();
}
uint32_t get(){
uint32_t t;
t=x^(x<<11);
x=y;y=z;z=w;
w=(w^(w>>19))^(t^(t>>8));
return w;
}
};
RND rnd;
ll dx[] = {0, 1, 0, -1};
ll dy[] = {1, 0, -1, 0};
void print_field(vi f){
int n;
for(n=1; ;n++){
assert(n*n<=sz(f));
if(n*n==sz(f))break;
}
rep(x,n){
string s;
rep(y,n)s.pb(f[x*n+y]+'0');
cerr << s << endl;
}
}
int cnt_all_move;
int all_move[10000][3];
vi zero_ad[10000];
vi one_ad[10000];
struct Cal{
int n;
void print_answer(vi ts){
cout << sz(ts) << endl;
rep(i,sz(ts)){
int t=ts[i];
int x = all_move[t][0]/n, y = all_move[t][0]%n;
int x2 = all_move[t][2]/n, y2 = all_move[t][2]%n;
cout << y2 << " " << x2 << " " << y << " " << x << endl;
}
}
void set_all_move(vi f){
cnt_all_move=0;
rep(x0,n) rep(y0,n) rep(r,4){
int x[3], y[3];
rep(k,3){
x[k] = x0 + k*dx[r];
y[k] = y0 + k*dy[r];
}
if(INRANGE(x[2],0,n) && INRANGE(y[2],0,n)){
rep(k,3) all_move[cnt_all_move][k] = x[k]*n+y[k];
zero_ad[cnt_all_move].clear();
one_ad[cnt_all_move].clear();
rep(k,3){
rep(r2,4){
int xa=x[k]+dx[r2], ya=y[k]+dy[r2];
if(!INRANGE(xa,0,n) || !INRANGE(ya,0,n))continue;
bool ok=true;
rep(k2,4) if(xa==x[k] && ya==y[k])ok=false;
if(!ok)continue;
int p=xa*n+ya;
if(k==0)zero_ad[cnt_all_move].pb(p);
else one_ad[cnt_all_move].pb(p);
}
}
cnt_all_move++;
}
}
debug(cnt_all_move);
}
int solve_step_1(const vi& f, int b){
int t=-1;
rep(_k,cnt_all_move){
int k=_k;
assert(INRANGE(k,0,cnt_all_move));
int*z=all_move[k];
int p=z[0], p1=z[1], p2=z[2];
if(f[p]==0 && f[p1]==1 && f[p2]==1 && (p%n+p/n)%2==b){
if(rnd.get()%2==0)return k;
t=k;
}
}
if(t+1)return t;
int best=-100;
rep(k,cnt_all_move){
int*z=all_move[k];
int p=z[0], p1=z[1], p2=z[2];
if(f[p]==0 && f[p1]==1 && f[p2]==1){
int rank = 0;
each(pp,zero_ad[k]) rank -= f[*pp];
each(pp,one_ad[k]) rank += f[*pp];
if(rank>=3)return k;
if(rank>best){
best = rank;
t=k;
}
}
}	
return t;
}
bool can_move(const vi&f, int t){
int p[3]={all_move[t][0], all_move[t][1], all_move[t][2]};
return f[p[0]]==0 && f[p[1]]==1 && f[p[2]]==1;
}
void move(vi&f, int t){
int p[3]={all_move[t][0], all_move[t][1], all_move[t][2]};
assert(f[p[0]]==0);
assert(f[p[1]]==1);
assert(f[p[2]]==1);
f[p[0]]=1;
f[p[1]]=0;
f[p[2]]=0;
}
vi solve_a(vi f){
int b;
{
int z[2]={0,0};
rep(p,n*n) if(f[p]) z[((p/n)+(p%n))%2]++;
int dd=2;
if(z[0]>=z[1]+dd)b=0;
else if(z[1]>=z[0]+dd)b=1;
else b=rnd.get()%2;
}
vi ts;
for(int step=0;;step++){
assert(step<=n*n);
int t=solve_step_1(f,b);
if(t==-1)break;
move(f,t);
ts.pb(t);
}
return ts;
}
vi solve_from(vi f, vi seq){
// given partial seq
rep(i,sz(seq)) move(f, seq[i]);
vi seq2=solve_a(f);
vi ret;
each(pt,seq)ret.pb(*pt);
each(pt,seq2) ret.pb(*pt);
return ret;
}
vi solve_from2(vi f, vi seq, int k){
// given totally seq
assert(sz(seq)!=0);
//int k1=rnd.get()%sz(seq), k2=rnd.get()%sz(seq), k3=rnd.get()%sz(seq);
vi forbid(sz(seq));
rep(i,sz(forbid)) if(rnd.get()%sz(seq)<=0 || i==k) forbid[i]=1;
vi seq2;
rep(i,sz(seq)){
if( forbid[i]==0 && can_move(f,seq[i])){
seq2.pb(seq[i]);
move(f,seq[i]);
}
}
vi seq3 = solve_a(f);
vi ret;
each(pt,seq2)ret.pb(*pt);
each(pt,seq3) ret.pb(*pt);
return ret;
}
vi solve(vi f){
double start=get_time();
for(n=0; ;n++){
if(n*n==sz(f))break;
assert(n*n<sz(f));
}
set_all_move(f);
vi best=solve_a(f);
int seed=0;
map<int,int> u;
vi ls;
double t1,t2,t3;
if (n<=15) {
rnd.init(2);
t1=0.2;
t2=0.05;
t3=0.7;
}
else{
t1 =0.2;
t2=0.05;
t3=0.7;
}
while(get_time()-start<t1){
rnd.init(seed);
seed++;
vi ts = solve_a(f);
u[sz(ts)]++;
if(sz(ts)<sz(best))best=ts;
//debug(sz(seq));
}
debug(seed);
ls.pb(sz(best));
if(sz(best)==0)return best;
{
debug(sz(best));
double start = get_time();
debug("a");
while(get_time()-start<t2){
int w=rnd.get()%sz(best);
vi init(best.begin(), best.begin()+w);
vi ts=solve_from(f,init);
if(sz(ts)<=sz(best)){
best=ts;
}
}
}
ls.pb(sz(best));
{
debug(sz(best));
double start = get_time();
debug("a");
for(int step=0; ;step++){
if(get_time()-start>t3)break;
vi ts=solve_from2(f,best, step%sz(best));
if(sz(ts)<=sz(best)){
best=ts;
}
}
}
ls.pb(sz(best));
debug(ls);
debug(seed);
return best;
}
};
struct Test{
vi genRndField(int n, int D){
vi f(n*n);
rep(p,n*n){
if(rnd.get()%1000<=D)f[p]=1;
}
return f;
}
vi genRndField(){
int n=10+rnd.get()%21;
int D=500+rnd.get()%450;
return genRndField(n,D);
}
void test(){
ofstream ofs("result.csv");
ofs << " , , , " << endl;
for(int step=0; step<100 ;step++){
rnd.init(step);
vi f=genRndField();
debug(step);
int nn;
int bn=0;
{
nn=sz(f);
rep(p,nn) bn+=f[p];
}
rnd.init(0);
Cal a;
vi best = a.solve(f);
ofs << step << "," << int(sqrt(nn)+0.5) << "," << 1.0*(bn-sz(best))/nn << "," << sz(best) << endl;
}
}
};
void _main(istream &inp){
if(submit){
int n;
inp >> n;
vi f(n*n);
deb(n);debl;
rep(x,n){
string s;
inp >> s;
rep(y,sz(s)){
if(s[y]=='*')f[x*n+y]=1;
}
}
Cal a;
rnd.init(0);
vi ts=a.solve(f);
a.print_answer(ts);
}
else{
rnd.init(0);
Test t;
t.test();
return;
vi f=t.genRndField();
Cal a;
a.solve(f);
}
}
int main(){
if(!submit){
ifstream ifs("test.txt");
_main(ifs);
}
else{
_main(cin);
}
return 0;
} 