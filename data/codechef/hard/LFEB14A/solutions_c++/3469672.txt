#include <cstdio>
#include <iostream>
#include <vector>
#include <list>
#include <queue>
#include <map>
#include <set>
#include <utility>
#include <functional>
#include <string>
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;
typedef map<int,int> mii;
typedef vector<int> vi;
typedef vector< vector<int> > vvi;
typedef vector<char> vc;
typedef vector<bool> vb;
typedef vector<string> vs;

#define rep(i,n) for(int i=0;i<n;i++)
#define forup(i,a,b) for(int i=a;i<=b;i++)
#define fordn(i,a,b) for(int i=a;i>=b;i--)
#define drep(i,n) for(i=0;i<n;i++)
#define dforup(i,a,b) for(i=a;i<=b;i++)
#define dfordn(i,a,b) for(i=a;i>=b;i--)
#define all(x) x.begin(),x.end()
#define permute(x) next_permutation(all(x))
#define gi(x) scanf("%d",&x)
#define pb push_back
#define mp make_pair
#define fi first
#define sc second

struct BIT
{
	int bn; //bn>0
	vector<int> bA;
	
	BIT(){ bn=0; }
	BIT(int bn_){ bn=bn_; bA.resize(bn+1); fill(bA.begin(),bA.end(),0); }
	
	int prefix(int bposn)
	{
		if(bposn<=0) return 0;
		if(bposn>bn) bposn=bn;
		
		int ret=0;
		for(int i=bposn; i>0; i-=((i)&(-i)))
			ret+=bA[i];
		return ret;
	}
	
	void update(int bposn, int bincr)
	{
		if(bposn<=0) return;
		if(bposn>bn) return;
		
		for(int i=bposn; i<=bn; i+=((i)&(-i)))
			bA[i]+=bincr;
	}
	
	int query(int bl, int br)
	{
		if(br<=0 or bl>bn or bl>br) return 0;
		if(bl<=0) bl=1;
		if(br>bn) br=bn;
		return (prefix(br)-prefix(bl-1));
	}
};

const int max_nm=100010;
int t,n,m;
int a[max_nm],b[max_nm];
ll cnt[max_nm];
BIT bit;

int main() {
	gi(t);
	while(t--) {
		gi(n); gi(m);
		int maxa=0,maxb=0;
		fill(cnt,cnt+max_nm,0ll);
		rep(i,n) { gi(a[i]); maxa=max(maxa,a[i]); }
		rep(i,m) { gi(b[i]); maxb=max(maxb,b[i]); cnt[b[i]]++; }
		bit=BIT(maxa);
		double inva=0;
		rep(i,n) {
			inva+=(double)bit.query(a[i]+1,maxa);
			bit.update(a[i],1);
		}
		double invb=0;
		forup(i,1,max_nm-1) {
			invb+=double(cnt[i]*cnt[i-1]);
			cnt[i]+=cnt[i-1];
		}
		invb/=2.0;
		double invab=0;
		rep(i,n) {
			invab+=double((ll)m-cnt[a[i]])*double(i+1);
			invab+=double(cnt[a[i]-1])*double(n-i);
		}
		invab/=double(n+1);
		printf("%.9lf\n",inva+invb+invab);
	}
	return 0;
}