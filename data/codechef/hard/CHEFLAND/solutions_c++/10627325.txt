//Amit Kumar Gupta              
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int,int> II;
#define REP(i,i1,n) for(int i=i1;i<n;i++)
#define REPB(i,i1,n) for(int i=i1;i>=n;i--)
#define PB push_back
#define MP make_pair
#define ALL(c) (c).begin(),(c).end()
#define F first
#define S second
#define SZ(a) (LL)a.size()
#define EPS 1e-12
#define MOD 1000000007
#define TR1(x) cerr<<#x<<" : "<<x<<endl
#define TR2(x,y) cerr<<#x<<" : "<<x<<" | "<<#y<<" : "<<y<<endl
#define FAST_IO ios_base::sync_with_stdio(false);cin.tie(NULL)
#define SI(c) scanf("%d",&c)
#define SII(c,d) scanf("%d%d",&c,&d)
#define SLL(c) scanf("%lld",&c)
#define PIN(c) printf("%d\n",c)
#define PLLN(c) printf("%lld\n",c)
#define N 100010
#define INIT1(array,ST,END,val) for(int i=ST;i<END;i++)array[i]=val
#define INIT2(array,nn,mm,val) for(int i=0;i<nn;i++)for(j=0;j<mm;j++)array[i][j]=val
//------------------------------------------------------MAIN CODE STARTS HERE---------------------------------------
vector<pair<int,int> > g[N];
vector<int> h[N];
vector<int> v[N];
map<pair<int,int>,int> mp;
int time1,low[N],dis[N],bridge[2*N+10],vis[N],comp_no,n,m,par[N];
queue<int> q[N];
void dfs(int z) {
	vis[z]=1;
	time1++;
	low[z]=time1;
	dis[z]=time1;
	REP(i,0,g[z].size()) {
		if(!vis[g[z][i].F]) {
			par[g[z][i].F]=z;
			dfs(g[z][i].F);
			low[z]=min(low[z],low[g[z][i].F]);
			if(low[g[z][i].F]>dis[z]&&mp[MP(z,g[z][i].F)]==1)
				bridge[g[z][i].S]=1;
		}
		else if(g[z][i].F!=par[z])
			low[z]=min(dis[g[z][i].F],low[z]);
	}
}
void dfs1(int z) {
	vis[z]=1;
	int curr_comp=comp_no;
	q[curr_comp].push(z);
	while(!q[curr_comp].empty()) {
		int ver=q[curr_comp].front();
		v[curr_comp].PB(ver);
		q[curr_comp].pop();
		for(int i=0;i<g[ver].size();i++) {
			int edge_no=g[ver][i].S;
			if(vis[g[ver][i].F])
				continue;
			if(bridge[edge_no]) {
				comp_no++;
				h[curr_comp].PB(comp_no);
				h[comp_no].PB(curr_comp);
				dfs1(g[ver][i].F);
			}
			else {
				q[curr_comp].push(g[ver][i].F);
				vis[g[ver][i].F]=1;
			}
		}
	}
}
int main() {
	SI(n);SI(m);
	REP(i,0,m) {
		int x,y;
		SI(x);SI(y);
        mp[MP(x,y)]++;
        mp[MP(y,x)]++;
		g[x].PB(MP(y,i));
		g[y].PB(MP(x,i));
	}
	par[1]=-1;
    int fl2=-1;
    REP(i,1,n+1) {
        if(!vis[i])
	        dfs(i),fl2++;
    }
	INIT1(vis,0,n+1,0);
	dfs1(1);
    int fl=0;
    REP(i,0,comp_no+1) {
        if(h[i].size()>2)
            fl=1;
    }
    if(fl==0&&fl2==0)
        printf("YES\n");
    else
        printf("NO\n");
    return 0;
}
