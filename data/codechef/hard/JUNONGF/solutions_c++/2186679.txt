/*
    Problem: JUNONGF
*/
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cassert>
#include <string>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <cstdlib>
using namespace std;

typedef  long long ll;

//MOD
long long m=1000000007;

//this function calculates a^b
ll modulo(ll a, ll b)
{
    //base case: a^0 is 1
	if(b==0) return 1;
	//a^b = (a^(b/2))*(a^(b/2)) when b is even
	//a^b = (a^(b/2))*(a^(b/2))*a when b is odd
	ll ans=modulo(a,b/2);
	ans=ans*ans;
	ans%=m;
	if(b%2) ans*=a;
	ans%=m;
	return ans;
}

long long pp[101],qq[101];

int main()
{
    int t;
    long long dim,v,power,a0,a1,b0,b1,c0,c1,m0,m1;
    int n;
	cin>>t;
	assert(t<=100000&&t>=0);
	while(t--)
	{
		cin>>v>>n;
		cin>>pp[0]>>pp[1]>>a0>>b0>>c0>>m0;
        cin>>qq[0]>>qq[1]>>a1>>b1>>c1>>m1;
		power=1;
		a0=(a0*a0)%m0;
		a1=(a1*a1)%m1;
		b0%=m0;
		b1%=m1;
		c0%=m0;
		c1%=m1;
		for(int i=0;i<n;i++)
		{
            if(i>1)
            {
                //P[i] = A0 * A0 * P[i-1] + B0 * P[i-2] + C0 modulo M0
                //Q[i] = A1 * A1 * Q[i-1] + B1 * Q[i-2] + C1 modulo M1,
                pp[i]=(((a0*pp[i-1])%m0+(b0*pp[i-2])%m0)%m0+c0)%m0;
                qq[i]=(((a1*qq[i-1])%m1+(b1*qq[i-2])%m1)%m1+c1)%m1;
            }
            //calculating the ith dimension
            dim=pp[i]*m1+qq[i]+1;
            dim-=1;
            //we can apply fermat-euler theorem only when v and m are co-primes
            if(v%m)
            {
                dim%=(m-1);
                power=(power*dim)%(m-1);
            }
            //if one of the dimensions is of unit length there's only one way of opening restaurants in this city as v^0=1
            //this is inspite of v being a multiple of m
            else if(dim==0) power=0;
		}
		if(power==0) printf("1\n");
		else if(v%m==0) printf("0\n");
		else printf("%lld\n",modulo(v%m,power));
	}
	return 0;
}