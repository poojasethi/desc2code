#include<stdio.h>
 
typedef unsigned long long ull;
 
ull p[105], q[105], l[105];
 
ull inline getUll() {
	long long rslt = 0;
	char cha;
	while ((cha = getchar_unlocked()) < '0' || cha > '9')
		;
	do {
		rslt = (rslt << 3) + (rslt << 1) + (long long) cha - '0';
	} while ((cha = getchar_unlocked()) >= '0' && cha <= '9');
	return (ull) rslt;
}
 
ull inline exponentiate(ull a, ull b, ull c) {
	ull x = 1ull, y = (ull) a;
 
	while (b > 0) {
		if (b % 2 == 1) {
			x = (x * y) % c;
		}
		y = (y * y) % c;
		b /= 2;
	}
 
	return x % c;
}
 
int main() {
	ull t, n, i;
	ull v, a0, a1, b0, b1, c0, c1, m0, m1;
 
	const ull MOD = (ull) 1e9 + 7;
	const ull MOD2 = (ull) 1e9 + 6;
 
	t = getUll();
 
	while (t--) {
		v = getUll();
		n = getUll();
 
		p[0] = getUll();
		p[1] = getUll();
		a0 = getUll();
		b0 = getUll();
		c0 = getUll();
		m0 = getUll();
 
		q[0] = getUll();
		q[1] = getUll();
		a1 = getUll();
		b1 = getUll();
		c1 = getUll();
		m1 = getUll();
 
		v %= MOD;
 
		bool one = false;
 
		l[0] = p[0] * m1 + q[0] + 1;
		l[1] = p[1] * m1 + q[1] + 1;
 
		ull exponent;
		if (l[0] > 1)
			exponent = (l[0] - 1) % MOD2;
		else {
			exponent = 1;
			one = true;
		}
 
		if (l[1] > 1)
			exponent = (exponent * ((l[1] - 1) % MOD2)) % MOD2;
		else
			one = true;
 
		for (i = 2; i < n; ++i) {
			p[i] = (a0 * a0 * p[i - 1] + b0 * p[i - 2] + c0) % m0;
			q[i] = (a1 * a1 * q[i - 1] + b1 * q[i - 2] + c1) % m1;
			l[i] = p[i] * m1 + q[i] + 1;
 
			if (l[i] > 1)
				exponent = (exponent * ((l[i] - 1) % MOD2)) % MOD2; //Important property of modular exponentiation
			else {
				one = true;
				break;
			}
 
			if (exponent == 0)
				break;
		}
 
		if (one) {
			printf("1\n");
		} else if (v == 0) {
			printf("0\n");
		} else {
			printf("%llu\n", exponentiate(v, exponent, MOD));
		}
	}
 
	return 0;
}