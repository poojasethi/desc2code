/*
 	C++ Template
	Pradeep George Mathias
 */


#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cassert>
#include <string>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <cstdlib>
using namespace std;

#define s(T) scanf("%d", &T)
#define sl(T) scanf("%lld", &T)
#define fill(a, val) memset(a, val, sizeof(a))
#define mp make_pair
#define pb push_back
#define all(x) x.begin(), x.end()
#define DREP(x) sort(all(x)); x.erase(unique(all(x)), x.end())
#define INDEX(a, val) (lower_bound(all(a), val) - a.begin())

const int MOD = 1000000007;
const int maxN = 100;
const int lim = 100000;

int totalCases, testNum;
unsigned long long inp;
long long N, R, V;
long long P[maxN];
long long Q[maxN];
long long L[maxN];
long long A0, B0, C0, M0, A1, B1, C1, M1;

void preprocess()
{
	
}

int mypow(int a, long long expo)
{
	if(expo == 0)
		return 1;
	
	int ret = mypow(( a * 1ll * a ) % MOD, expo >> 1);
	if(expo & 1)
		ret = (a * 1ll * ret) % MOD;
	return ret;
}

bool input()
{
	sl(V); sl(N);	assert(2 <= N && N <= maxN);
	
	sl(P[0]); //assert(0 <= P[0] && P[0] <= lim);
	sl(P[1]); //assert(0 <= P[1] && P[1] <= lim);
	sl(A0); assert(0 <= A0 && A0 <= lim);
	sl(B0); assert(0 <= B0 && B0 <= lim);
	sl(C0); assert(0 <= C0 && C0 <= lim);
	sl(M0); 
	
	sl(Q[0]); //assert(0 <= Q[0] && Q[0] <= lim);
	sl(Q[1]); //assert(0 <= Q[1] && Q[1] <= lim);
	sl(A1); assert(0 <= A1 && A1 <= lim);
	sl(B1); assert(0 <= B1 && B1 <= lim);
	sl(C1); assert(0 <= C1 && C1 <= lim);
	sl(M1); 
	
	return true;
}

void solve()
{
	A0 %= M0; A1 %= M1; B0 %= M0; B1 %= M1; C0 %= M0; C1 %= M1;
	A0 = (A0 * A0) % M0; A1 = (A1 * A1) % M1;
	
	//first find L[i]'s
	for(int i = 2; i < N; i++)
	{	
		P[i] = (A0 * P[i-1] + B0 * P[i-2] + C0) % M0;
		Q[i] = (A1 * Q[i-1] + B1 * Q[i-2] + C1) % M1;
	}
	for(int i = 0; i < N; i++)
		L[i] = P[i] * M1 + Q[i] + 1;
	
	/* Calculate V ^ product(L[i]-1)
	 * Boundary Cases: V % MOD = 0, then mypow(0, x) should return 0, not 1
	 * Also, 0^(prod(L[i]-1)) should return 1, not 0, if some L[i] = 1.
	 */
	int expo = 1;
	bool iszero = false;
	for(int i = 0; i < N; i++)
	{
		if(L[i] == 1)
			iszero = true;
		expo = (expo * ((L[i]-1) % (MOD - 1))) % (MOD-1);		//exponent is taken modulo MOD-1 because of Fermat's Little Theorem
	}
	
	if(V % MOD == 0)
	{
		if(iszero)
			printf("1\n");
		else 
			printf("0\n");
		return;
	}
	
	printf("%d\n", mypow(V%MOD, expo));

// slower version - for testing:
//	V %= MOD;
//	long long ans = V;
//	for(int i = 0; i < N; i++)
////		ans = (mypow(ans, (L[i]-1))) % (MOD);
//		ans = (mypow(ans, (L[i]-1)%(MOD-1))) % (MOD);
//	printf("%lld\n", ans);
}

int main()
{
	preprocess();
	s(totalCases); assert(totalCases <= 100000);
	for(testNum = 1; testNum <= totalCases; testNum++)
	{
		if( !input())
			break;
		solve();
	}
}
