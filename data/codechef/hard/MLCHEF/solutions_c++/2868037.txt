
#include"stdio.h"
#include"vector"
#include"iostream"
using namespace std;
int mini(int a, int b) { return a<b? a:b;}
struct node {
    int min, alive, poison;
    void split(node& l, node& r) {
        l.min -= poison, l.poison += poison;
        r.min -= poison, r.poison += poison;
        poison = 0;
    }
    void merge(node&l, node& r) {
        min = mini(l.min, r.min);
        alive = l.alive + r.alive;
        poison = 0;
    }
    bool update(int decrement) {
        poison += decrement;
        min -= decrement;
        if(min>0) return 0;
        else return 1;
    }
    void make_dead() {
        min = 1.1e9;
        poison = 0;
        alive = 0;
    }
    void init(int a) {
        alive = a>0?1:0;
        min = a>0? a: 1.1e9;
        poison = 0;
    }
} tree[1<<18];
#define DEBUG(x) /*cerr<<x<<"\n";*/
void update(int root, int l_lim, int r_lim, int u, int v, int dec) {
    int l = root << 1, r = l | 1, mid = (l_lim+r_lim)>>1;
    if(u<=l_lim and v>=r_lim) {
        if(tree[root].update(dec)) {
            if(l_lim <= root) {
                tree[root].make_dead();
                DEBUG("RIP CHEF # "<<(root-(1<<17)))
            }
            else {
                tree[root].split(tree[l], tree[r]);
                update(l, l_lim, mid, u, v, 0);
                update(r, mid, r_lim, u, v, 0);
                tree[root].merge(tree[l], tree[r]);
            }
        }
        return;
    }
    tree[root].split(tree[l], tree[r]);
    if(u<mid) update(l, l_lim, mid, u, v, dec);
    if(v>mid) update(r, mid, r_lim, u, v, dec);
    tree[root].merge(tree[l], tree[r]);
}
int query(int root, int l_lim, int r_lim, int u, int v) {
    if(u<=l_lim and v>=r_lim)
        return tree[root].alive;
    int l = root<<1, r = l|1, mid = (l_lim+r_lim)>>1, ans=0;
    if(u<mid) ans += query(l, l_lim, mid, u, v);
    if(v>mid) ans += query(r, mid, r_lim, u, v);
    return ans;
}
int dfs_1[1<<17], dfs_2[1<<17], cnt=0;
vector<int> G[1<<17];
void dfs(int u) {
    dfs_1[u] = (1<<17)+ ++cnt;
    for(vector<int>::iterator p=G[u].begin(); p!=G[u].end(); p++)
        dfs(*p);
    dfs_2[u] = (1<<17)+ cnt;
}
int main() {
    int N, Q;
    scanf("%d", &N);
    int h[N+1];
    h[0] = 0;
    for(int i=1; i<=N; i++) {
        int p;
        scanf("%d%d", &h[i], &p);
        G[p].push_back(i);
    }
    dfs(0);
    for(int i=0; i<(1<<17); i++)
        if(i>N)
            tree[i+(1<<17)].init(0);
        else
            tree[dfs_1[i]-1].init(h[i]);
    for(int i=(1<<17); --i; )
        tree[i].merge(tree[i<<1], tree[(i<<1)+1]);
    scanf("%d", &Q);
    while(Q--) {
        int type, a, x;
        scanf("%d%d", &type, &a);
        if (type==1)
            scanf("%d", &x),
            dfs_1[a]!=dfs_2[a]? update(1, 1<<17, 1<<18, dfs_1[a], dfs_2[a], x):(void)0;
        else
            printf("%d\n", dfs_1[a]!=dfs_2[a]? query(1, 1<<17, 1<<18, dfs_1[a], dfs_2[a]):0);
    }
}

