#include <stdio.h>
#include <vector>

using namespace std;
typedef pair<int,int>par;
#define pb push_back
#define s second
#define f first
#define mp make_pair
const int maxn = 5e5;

int n,q;

vector<int>grafo[maxn];
int abitime[maxn],abid[maxn];
int position[maxn],health[maxn];

vector<par>poison[maxn];
vector<par>queries[maxn];
int salida[maxn];
bool mk[maxn];

int my_stack[maxn];

int ini[maxn],tmp[maxn],cnt[maxn],idx;

void updatedeath(int pos)
{
	if(pos == 0)return ;

	while(pos <= q)
	{
		abid[pos]++;
		pos += (pos&(-pos));
	}
}

void updatetime(int pos, int v)
{
	if(pos == 0)return ;

	while(pos <= q)
	{
		abitime[pos] += v;
		pos += (pos&(-pos));
	}
}

int querydeath(int pos)
{
	int res = 0;
	while(pos)
	{
		res += abid[pos];
		pos -= (pos&(-pos));
	}
	return res;
}

int querytime(int pos)
{
	int res = 0;
	while(pos)
	{
		res += abitime[pos];
		pos -= (pos&(-pos));
	}
	return res;
}

int timeofdeath(int chef)
{
	if(querytime(q) < health[chef])return 2000000000;
	int a = 1;
	int b = q ;

	while(b - a > 1)
	{
		int m = (b + a) >> 1;
		if(health[chef] <= querytime(m))
			b = m;
		else
			a = m + 1;
	}
	return b;
}

void dfs(int v)
{
	position[idx++] = v;
	ini[v] = idx - 1;

	if(grafo[v].empty())
	{
		cnt[v] = 0;
		return;
	}
	
	for(int i = 0; i < grafo[v].size(); i++)
	{
		dfs(grafo[v][i]);
		cnt[v] += cnt[grafo[v][i]];
	}
	cnt[v] += grafo[v].size();
}

void process()
{
	dfs(0);
	/*for (int i = n;i >= 0;i--)
	{
		cnt[i] = 0;
		for (int j = grafo[i].size() - 1;j >= 0;j--)
		{
			cnt[i] += cnt[grafo[i][j]] + 1;
		}
	}*/

	for(int i = 1; i <= n; i++)
		tmp[i] = health[i];

	for(int i = 1; i <= n; i++)
		health[ini[i]] = tmp[i];
}

void ProcessData()
{
	int cur_pos,i,j,node,top;
	// DFS START
	top = 0;
	my_stack[top] = 0;
	cur_pos = 0;

	while(top >= 0)
	{
		node = my_stack[top];
		top--;
		position[node] = cur_pos;
		cur_pos++;

		for (i = grafo[node].size() - 1;i >= 0;i--)
		{
			my_stack[++top] = grafo[node][i];
		}
	}
	// DFS END
	for (i = n;i >= 0;i--)
	{
		cnt[i] = 0;
		for (j = grafo[i].size() - 1;j >= 0;j--)
		{
			cnt[i] += cnt[grafo[i][j]] + 1;
		}
	}

	for(i = 1;i <= n;i++)
	{
		tmp[i] = health[i];
	}
	for(i = 1;i <= n;i++)
	{
		health[position[i]] = tmp[i];
	}

	return;
}

int main()
{
	scanf("%d", &n);

	int p,v,t;
	for(int i = 1; i <= n; i++)
	{
		scanf("%d %d",&health[i],&p);
		grafo[p].pb(i);
	}

	scanf("%d", &q);

	process();
	//ProcessData();
	for(int i = 1; i <= q; i++)
	{
		scanf("%d", &t);
		if(t== 1)
		{
			scanf("%d %d",&p,&v);
			poison[ini[p] + 1].pb(mp(i,v));
			poison[ini[p] + cnt[p] + 1].pb(mp(i,-v));
		}
		else
		{
			scanf("%d", &p);
			queries[ini[p]].pb(mp(i,1));
			queries[ini[p] + cnt[p]].pb(mp(i,2));
			salida[i] = cnt[p];
			mk[i] = 1;
		}
	}

	for(int i = 1; i <= n; i++)
	{
		for(int j =  poison[i].size() - 1; j >= 0; j--)
		{
			updatetime(poison[i][j].f,poison[i][j].s);
		}

		updatedeath(timeofdeath(i));
		for(int j = 0; j < queries[i].size(); j++)
		{
			if(queries[i][j].second == 1)
				salida[queries[i][j].f] += querydeath(queries[i][j].f);
			else
				salida[queries[i][j].f] -= querydeath(queries[i][j].f);
		}
	}

	for(int i = 1; i <= q; i++)
	{
		if(mk[i])
			printf("%d\n",salida[i]);
	}
	return 0;
}