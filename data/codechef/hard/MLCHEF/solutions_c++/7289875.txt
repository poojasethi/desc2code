//26062015 1922 codechef MLCHEF
#include<stdio.h>
#include<iostream>
#include<algorithm>
#include<vector>
#include<stack>

using namespace std;

#define MX 100007

int ind[MX];

struct data
{
      int nd, in;
      data(){}
      data(int a, int b)
      {
            nd=a;
            in=b;
      }
      bool operator<(const data& a)const
      {
            return ind[nd]<ind[a.nd];
      }
};

bool tq2[4*MX];
int tq1[4*MX], lazy[4*MX], ans[MX], r_in[MX], xh[MX], h[MX], pos, l, r, arr[MX], in, lst[MX];
stack<data> st1, st2;
vector<data> q1, q2;
vector<int> edge[MX];

void dfs(int i)
{
      arr[++in]=i;
      ind[i]=in;
      for(int k=0; k<edge[i].size(); k++)
      {
            dfs(edge[i][k]);
      }
      lst[i]=in;
}

void update1(int nd, int tl, int tr, bool flag)
{
      if(tl==tr)
      {
            tq1[nd]=flag?xh[tl]:0;
            return ;
      }

      int tm=(tl+tr)>>1;
      int lc=nd<<1;
      int rc=lc+1;

      if(pos<=tm)update1(lc, tl, tm, flag);
      else update1(rc, tm+1, tr, flag);

      tq1[nd]=tq1[lc]+tq1[rc];
}

int query1(int nd, int tl, int tr, int num)
{
      if(tl==tr)
      {
            return tl;
      }

      int tm=(tl+tr)>>1;
      int lc=nd<<1;
      int rc=lc+1;

      if(tq1[lc]>=num)return query1(lc, tl, tm, num);
      else return query1(rc, tm+1, tr, num-tq1[lc]);
}

void update_nd(int nd, int tl, int tr, int v)
{
      lazy[nd]+=v;
      if(tl==tr)
      {
            ans[tl]+=tq2[nd]*v;
            //if(tl==1)printf("............................%d %d\n", tl, ans[tl]);
      }
}

void push(int nd, int tl, int tr)
{
      int tm=(tl+tr)>>1;
      int lc=nd<<1;
      int rc=lc+1;

      update_nd(lc, tl, tm, lazy[nd]);
      update_nd(rc, tm+1, tr, lazy[nd]);

      lazy[nd]=0;
}

void update2(int nd, int tl, int tr, int flag)
{
      if(tl==tr)
      {
            //printf("..... %d\n", tl);
            tq2[nd]=flag;
            return ;
      }

      if(lazy[nd])
      {
            push(nd, tl, tr);
      }

      int tm=(tl+tr)>>1;
      int lc=nd<<1;
      int rc=lc+1;

      if(pos<=tm)update2(lc, tl, tm, flag);
      else update2(rc, tm+1, tr, flag);
}

void update3(int nd, int tl, int tr)
{
      if(r_in[tr]<l || r_in[tl]>r)return ;
      //printf("............... %d %d\n", r_in[tl], r_in[tr]);

      if(r_in[tl]>=l && r_in[tr]<=r)
      {
            update_nd(nd, tl, tr, 1);
            return ;
      }

      if(lazy[nd])
      {
            push(nd, tl, tr);
      }

      int tm=(tl+tr)>>1;
      int lc=nd<<1;
      int rc=lc+1;

      update3(lc, tl, tm);
      update3(rc, tm+1, tr);
}

void query2(int nd, int tl, int tr)
{
      if(tl==tr)
      {
            return ;
      }

      if(lazy[nd])
      {
            push(nd, tl, tr);
      }

      int tm=(tl+tr)>>1;
      int lc=nd<<1;
      int rc=lc+1;

      if(pos<=tm)query2(lc, tl, tm);
      else query2(rc, tm+1, tr);
}

int main()
{
      //freopen("mlchef.in", "r", stdin);
      int n, q, tp, p, i, x, in1, in2;
      scanf("%d", &n);
      for(i=1; i<=n; i++)
      {
            scanf("%d %d", &h[i], &x);
            edge[x].push_back(i);
      }

      in=-1;
      dfs(0);

      scanf("%d", &q);
      for(i=0; i<q; i++)
      {
            scanf("%d %d", &tp, &p);
            if(tp-1)
            {
                  in=q2.size();
                  r_in[in]=q1.size()-1; //holds the index of last q1 element
                  q2.push_back(data(p, in));
            }
            else
            {
                  scanf("%d", &x);
                  in=q1.size();
                  xh[in]=x;
                  q1.push_back(data(p, in));
            }
      }

      sort(q1.begin(), q1.end());
      sort(q2.begin(), q2.end());

      h[0]=2e9;
      for(i=in1=in2=0; i<=n; i++)
      {
            if(h[arr[i]]<=tq1[1])
            {
                  p=query1(1, 0, q1.size()-1, h[arr[i]]);
                  r=p-1;
            }
            else
            {
                  r=r_in[q2.size()-1];
            }
            l=r_in[0];
            //printf("arr %d: %d %d\n", arr[i], l, r);
            update3(1, 0, q2.size()-1);

            //query type 1
            while(in1<q1.size() && q1[in1].nd==arr[i])
            {
                  pos=q1[in1].in;
                  st1.push(q1[in1]);
                  update1(1, 0, q1.size()-1, true);
                  in1++;
            }
            while(!st1.empty() && lst[st1.top().nd]==i)
            {
                  pos=st1.top().in;
                  st1.pop();
                  update1(1, 0, q1.size()-1, false);
            }

            //query type 2
            //printf("Statuses.... %d %d %d %d\n", arr[i], q2[in2].nd, in2, q2.size());
            while(in2<q2.size() && q2[in2].nd==arr[i])
            {
                  pos=q2[in2].in;
                  st2.push(q2[in2]);
                  update2(1, 0, q2.size()-1, true);
                  in2++;
            }
            while(!st2.empty() && lst[st2.top().nd]==i)
            {
                  pos=st2.top().in;
                  st2.pop();
                  update2(1, 0, q2.size()-1, false);
            }
      }
      for(i=0; i<q2.size(); i++)
      {
            pos=i;
            query2(1, 0, q2.size()-1);
            printf("%d\n", ans[i]);
      }
      return 0;
}
