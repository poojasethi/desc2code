#include <cassert>
#include <cstdio>
#include <ctime>
#include <cstdlib>
#include <climits>
#include <cstddef>
#include <cctype>
#include <cmath>
#include <cstring>
#include <fstream>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <iterator>
#include <numeric>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <bitset>
#include <list>
#include <string>
#include <functional>
#include <utility>
using namespace std;
typedef long long llint;
class BIT
{
public:
    BIT(int n): MAX_VAL(f(n)), tree(MAX_VAL, 0)
    {
    }
    void update(int idx ,int val)
    {
        while (idx <= MAX_VAL)
        {
            tree[idx] += val;
            idx += (idx & -idx);
        }
    }
    int read(int idx) const
    {
        int sum = 0;
        while (idx > 0)
        {
            sum += tree[idx];
            idx -= (idx & -idx);
        }
        return sum;
    }
    int read_single(int idx) const
    {
        int sum = tree[idx];
        if (idx > 0)
        {
            int z = idx - (idx & -idx);
            idx--;
            while (idx != z)
            {
                sum -= tree[idx]; 
                idx -= (idx & -idx);
            }
        }
        return sum;
    }
    static int f(int n)
    {
        int ret = 1;
        while (ret < n)
        {
            ret <<= 1;
        }
        return ret;
    }
private:
    int MAX_VAL;
    vector <int> tree;
};
int const N = 100000;
int const MAX_H = 1000000000;
int n;
int health[N + 1];
vector <int> g[N + 1];
int cnt;
int pre_order[N + 1];
int bd[N + 1][2];
int death_time[N + 1];
void traverse(int u)
{
    pre_order[cnt++] = u;
    bd[u][0] = cnt;
    for (vector <int>::const_iterator it = g[u].begin(); it != g[u].end(); ++it)
    {
        traverse(*it);
    }
    bd[u][1] = cnt;
}
int get_death_time(int i, int q, BIT const &acc)
{
    int lo = 1, hi = q;
    int mid;
    while (lo < hi)
    {
        mid = lo + (hi - lo) / 2;
        if (health[i] <= acc.read(mid))
        {
            hi = mid;
        }
        else
        {
            lo = mid + 1;
        }
    }
    return lo;
}
int main()
{
    // tree
    scanf("%d", &n);
    for (int i = 1, j, k; i <= n; ++i)
    {
        scanf("%d%d", &j, &k);
        health[i] = j;
        g[k].push_back(i);
    }
    cnt = 0;
    traverse(0);
    // query
    int q;
    int op, a, x;
    vector <pair <int, int> > update_op;
    vector <vector <int> > b(n + 1), e(n + 1);
    vector <pair <int, int> > query_op;
    scanf("%d", &q);
    update_op.push_back(make_pair(0, 0));
    while (q--)
    {
        scanf("%d", &op);
        if (op == 1)
        {
            scanf("%d%d", &a, &x);
            if (bd[a][0] < bd[a][1])
            {
                update_op.push_back(make_pair(a, x));
                b[pre_order[bd[a][0]]].push_back(update_op.size() - 1);
                e[pre_order[bd[a][1] - 1]].push_back(update_op.size() - 1);
            }
        }
        else
        {
            scanf("%d", &a);
            query_op.push_back(make_pair(update_op.size() - 1, a));
        }
    }
    update_op.push_back(make_pair(0, MAX_H));
    b[pre_order[1]].push_back(update_op.size() - 1);
    e[pre_order[n]].push_back(update_op.size() - 1);
    // calculate
    BIT acc(update_op.size() - 1);
    for (int i = 1, j; i <= n; ++i)
    {
        j = pre_order[i];
        for (vector <int>::const_iterator it = b[j].begin(); it != b[j].end(); ++it)
        {
            acc.update(*it, update_op[*it].second);
        }
        death_time[j] = get_death_time(j, update_op.size() - 1, acc);
        for (vector <int>::const_iterator it = e[j].begin(); it != e[j].end(); ++it)
        {
            acc.update(*it, -update_op[*it].second);
        }
    }
    // answer
    BIT alive(update_op.size() - 1);
    vector <pair <int, pair <int, int> > > pr;
    int s, d;
    vector <int> ans(query_op.size());
    for (vector <pair <int, int> >::const_iterator it = query_op.begin(); it != query_op.end(); ++it)
    {
        pr.push_back(make_pair(bd[it->second][0] - 1, make_pair(it->first, -(it - query_op.begin() + 1))));
        pr.push_back(make_pair(bd[it->second][1] - 1, make_pair(it->first, it - query_op.begin() + 1)));
    }
    sort(pr.begin(), pr.end());
    s = 0;
    while (s < int(pr.size()) && pr[s].first == 0)
    {
        ++s;
    }
    for (int i = 1; i <= n; ++i)
    {
        alive.update(death_time[pre_order[i]], 1);
        while (s < int(pr.size()) && pr[s].first == i)
        {
            d = alive.read(pr[s].second.first);
            if (pr[s].second.second < 0)
            {
                ans[-pr[s].second.second - 1] -= d;
            }
            else
            {
                ans[pr[s].second.second - 1] += d;
            }
            ++s;
        }
    }
    for (vector <int>::const_iterator it = ans.begin(); it != ans.end(); ++it)
    {
        int u = query_op[it - ans.begin()].second;
        printf("%d\n", bd[u][1] - bd[u][0] - *it);
    }
    return 0;
}
