#include <cstdio>
#include <iostream>
#include <algorithm>
#include <climits>
#include <vector>
#include <utility>
#define inf 1e9
#define MAX 100002
using namespace std;
int tree[4*MAX],lazy[4*MAX],change[4*MAX],arr[MAX],d[MAX][2],cnt;
vector<pair<int,int> > v[MAX];
void ordering_segtree(int u,int h){
int start,end;
start=cnt;
if(v[u].size()==0){
   d[u][0]=-1;
   d[u][1]=-1;
   arr[cnt++]=h;
   return;
}
for(int i=0;i<(int)v[u].size();i++){
    ordering_segtree(v[u][i].first,v[u][i].second);
}
end=cnt-1;
d[u][0]=start;
d[u][1]=end;
arr[cnt++]=h;
}
void init_tree(int indx,int l,int h){
if(l==h){
    tree[indx]=arr[l];
    return;
}
int mid=(l+h)>>1;
init_tree(indx<<1,l,mid);
init_tree(indx<<1|1,mid+1,h);
tree[indx]=min(tree[indx<<1],tree[indx<<1|1]);
}
void update_tree(int indx,int l,int h,int rx,int ry,int val){
if(lazy[indx]!=0){
  tree[indx]-=lazy[indx];
  if(l!=h){
    lazy[indx<<1]+=lazy[indx];
    lazy[indx<<1|1]+=lazy[indx];
  }
  lazy[indx]=0;
}
if(change[indx]== h-l+1)
    return;
if(h<rx || l>ry)
    return;
if(rx<=l && h<=ry){
   if(val<tree[indx]){
    tree[indx]-=val;
    if(l!=h){
        lazy[indx<<1]+=val;
        lazy[indx<<1|1]+=val;
    }
    return;
   }
   else if(l==h){
    tree[indx]=inf;
    change[indx]=1;
    return;
   }
}
int mid=(l+h)>>1;
update_tree(indx<<1,l,mid,rx,ry,val);
update_tree(indx<<1|1,mid+1,h,rx,ry,val);
change[indx]=change[indx<<1]+change[indx<<1|1];
tree[indx]=min(tree[indx<<1],tree[indx<<1|1]);
}
int query_tree(int indx,int l,int h,int rx,int ry){
if(h<rx || l>ry)
    return 0;
if(rx<=l && h<=ry){
    return h-l+1-change[indx];
}
int mid=(l+h)>>1;
return query_tree(indx<<1,l,mid,rx,ry)+query_tree(indx<<1|1,mid+1,h,rx,ry);
}
int main(){
int N,a,b,c,Q,l,h,k;
cin>>N;
cnt=0;
for(int i=1;i<=N;i++){
    cin>>a>>b;
    v[b].push_back(make_pair(i,a));
}
ordering_segtree(0,inf);
init_tree(1,0,N-1);
cin>>Q;
while(Q--){
cin>>c;
if(c==1){
    cin>>l>>h;
    if(d[l][0]!=-1 && d[l][1]!=-1)
        update_tree(1,0,N-1,d[l][0],d[l][1],h);
}
else{
    cin>>k;
    if(d[k][0]!=-1 && d[k][1]!=-1){
        int ans = query_tree(1,0,N-1,d[k][0],d[k][1]);
        cout<<ans<<endl;
    }
    else
        cout<<"0"<<endl;
}
}
return 0;
}
