#include<iostream>
#include<stack>
#include<vector>

#define INF 2000000000
using namespace std;
typedef pair< int , int > pii;


vector< vector<int> > edgeList;
vector< int > health;
vector< pii > se;
vector< int > pre;
int t = 0;

struct NODE{
	int min;
	int num;
	int lazy;

} tree[2000000];


int MIN(int a, int b){
	return a<b?a:b;
}

void buildTree(int node, int a, int b){

	tree[node].num = 0;
	tree[node].lazy = 0;
	if(a!=b){
		int mid = (a+b)/2;
		buildTree(2*node+1, a, mid);
		buildTree(2*node+2, mid+1, b);
		tree[node].min = MIN(tree[2*node+1].min, tree[2*node+2].min);
	}
	else{
		tree[node].min = pre[a];
		//cout<<node<<" "<<pre[a]<<endl;
	}

}

int count(int node, int a, int b, int l, int r){

	if(a>b){
		return 0;
	}
	if(tree[node].lazy!=0){
		tree[node].min = tree[node].min - tree[node].lazy;
		if(a!=b){
			tree[2*node+1].lazy += tree[node].lazy;
			tree[2*node+2].lazy += tree[node].lazy;
		}
		tree[node].lazy = 0;
	}
	if(a>r || b<l){
		return 0;
	}
	if(a>=l && b<=r){
		return tree[node].num;
	}	
	int mid = (a+b)/2;
	int ans1 = count(2*node+1,a,mid,l,r);
	int ans2 =  count(2*node+2,mid+1,b,l,r);
//	tree[node].min = MIN(tree[2*node+1].min, tree[2*node+2].min);
//	tree[node].num = tree[2*node+1].num + tree[2*node+2].num;
	return ans1 + ans2;

}

void update(int node, int a, int b, int l, int r, int value){


	if(a>b || l>r){
		return;
	}
	if(tree[node].lazy!=0){
		tree[node].min = tree[node].min - tree[node].lazy;
		if(a!=b){
			tree[2*node+1].lazy += tree[node].lazy;
			tree[2*node+2].lazy += tree[node].lazy;
		}
		tree[node].lazy = 0;
	}
	if(a>r || b<l || l>r){
		return;
	}


	if(a==b){
		tree[node].min = tree[node].min - value;
		if(tree[node].min <= 0){
			tree[node].min = INF;
			tree[node].num = 1;
		}
		return;
	}
	if( a>=l && b<=r && tree[node].min > value){
		tree[node].min = tree[node].min - value;
		tree[2*node+1].lazy += value;
		tree[2*node+2].lazy += value;
		return;
	}

	int mid = (a+b)/2;
	update(2*node+1, a, mid, l, r, value);
	update(2*node+2, mid+1, b, l , r, value);
	tree[node].min = MIN(tree[2*node+1].min, tree[2*node+2].min);
	tree[node].num = tree[2*node+1].num + tree[2*node+2].num;


}


void visit(int node){
	se[node].first = t;
	int len = edgeList[node].size();
	pre.push_back(health[node]);
	//cout<<health[node]<<" ";
	for(int i=0;i<len;i++){
		t++;
		visit(edgeList[node][i]);
	}
	se[node].second = t;
}



int main(){

	int n;
	cin>>n;
	for(int i=0;i<=n;i++){
		edgeList.push_back(vector<int>());
		health.push_back(0);
		se.push_back(pii(0,0));
	}
	health[0] = INF;
	for(int i=1;i<=n;i++){
		int a,h;
		cin>>h>>a;
		edgeList[a].push_back(i);
		health[i] = h;
	}
	int q;
	visit(0);
	//cout<<endl;
	buildTree(0,0,n);
	cin>>q;
	while(q--){
		int opt;
		cin>>opt;
		if(opt==1){
			int a,x;
			cin>>a>>x;
			update(0,0,n,se[a].first+1,se[a].second,x);
		
		}
		else{
			int a;
			cin>>a;
			int ans = count(0,0,n,se[a].first+1,se[a].second);
			ans = se[a].second - se[a].first - ans;
			cout<<ans<<endl;
		}
	}
		

}
