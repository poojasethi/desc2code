
/*Programmed by Ayush Jaggi*/
//seg trees using lazy propogation :)

#include<iostream>
#include<cstring>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<ctype.h>
#include<climits>
#include<vector>
#include<cassert>
#include<sstream>
#include<map>
#include<stack>
#include<queue>
#include<algorithm>
#include<set>
#include<deque>
#include<list>
#include<utility>
#include<fstream>
#include<iterator>
#include<ctime>
#include<deque>
#include<numeric>
#include<functional>
#include<sstream>

using namespace std;
#define MOD 1000000007
#define mp make_pair
#define pb push_back
#define F first
#define S second
#define L(i,x,y) for(i=x;i<y;i++)
#define l0(i,x) for(i=0;i<x;i++)
#define l1(i,x) for(i=1;i<x;i++)
#define pd(n) printf("%d",n)
#define pdn(n) printf("%d\n",n)
#define pds(n) printf("%d ",n)
#define plld(n) printf("%lld",n)
#define plldn(n) printf("%lld\n",n)
#define pllds(n) printf("%lld ",n)
#define pc(n) printf("%c",n)
#define pn printf("\n")
#define ps printf(" ")
#define plf(n) printf("%.6lf",n)
#define plfn(n) printf("%.6lf\n",n)
#define plfs(n) printf("%.6lf ",n)
#define sd(n) scanf("%d",&n)
#define sld(n) scanf("%ld",&n)
#define slld(n) scanf("%lld",&n)
#define slf(n) scanf("%lf",&n)
#define ss(n) scanf("%s",n)
#define sc(n) scanf("%c",&n)
#define mem(n,m) memset(n,m,sizeof(n))
#define W(t) while(t--)
#define ll long long int
#define vec vector<int>
#define dead 1000000000

int health[100002], pre_order[100002][3], counter, pre_order_index[100002];
vec tree[100002];

struct chef
{
    int least_health, alive, poison;
} seg_tree[300010];



inline int build_seg_tree(int first, int last, int index)
{
    if(first==last)
    {
        seg_tree[index].alive=1;
        seg_tree[index].poison=0;
        seg_tree[index].least_health=health[pre_order[first][0]];
        return health[pre_order[first][0]];

    }
    else
    {
        seg_tree[index].alive=last-first+1;
        seg_tree[index].poison=0;
        seg_tree[index].least_health=min(build_seg_tree(first,(first+last)/2,2*index+1),build_seg_tree((first+last)/2+1,last,2*index+2));
        return seg_tree[index].least_health;
    }
}

/*inline int update(int first, int last, int curr_index, int curr_first, int curr_last)
{
    if(curr_first==curr_last && curr_first>=first && curr_first<=last)
    {
        if(health[pre_order[curr_first][0]]>0)
        {
            health[pre_order[curr_first][0]]-=x;
            if(health[pre_order[curr_first][0]]<0)
            {
                seg_tree[curr_index]=0;
                return 1;
            }
            else return 0;
        }
        else return 0;
    }

    else

        if((curr_first>=first && curr_last<=last) || (curr_first<first && curr_last>=first && curr_last<=last) || (curr_first>=first && curr_first<=last && curr_last>last) || (curr_first<first && curr_last>last))
        {
            int dead_chefs=update(first,last,curr_first,(curr_first+curr_last)/2,2*curr_index+1)+update(first,last,(curr_first+curr_last)/2+1,curr_last,2*curr_index+2);
            seg_tree[curr_index]-=dead_chefs;
            return dead_chefs;

        }

        else return 0;

}
OR THE BELOW FUNCTION (ONE OF THE SAME THINGS)
*/
inline int update(int first, int last, int curr_index, int curr_first, int curr_last, int dec)
{
    if(curr_first>=first && curr_last<=last)
    {
        if(seg_tree[curr_index].alive)
        {
            seg_tree[curr_index].poison+=dec;
            seg_tree[curr_index].least_health-=dec;
            if(seg_tree[curr_index].least_health<=0)
            {
                if(curr_first==curr_last)
                {
                    seg_tree[curr_index].poison=seg_tree[curr_index].alive=0;
                    seg_tree[curr_index].least_health=dead;
                }
                else
                {
                    update(first,last,2*curr_index+1,curr_first,(curr_first+curr_last)/2,seg_tree[curr_index].poison);
                    update(first,last,2*curr_index+2,(curr_first+curr_last)/2+1,curr_last,seg_tree[curr_index].poison);
                    seg_tree[curr_index].poison=0;
                    seg_tree[curr_index].least_health=min(seg_tree[2*curr_index+1].least_health,seg_tree[2*curr_index+2].least_health);
                    seg_tree[curr_index].alive=seg_tree[2*curr_index+1].alive+seg_tree[2*curr_index+2].alive;
                }
            }
            //else return;
        }
//else return;
    }
    else
    {
        seg_tree[2*curr_index+1].poison+=seg_tree[curr_index].poison;
        seg_tree[2*curr_index+2].poison+=seg_tree[curr_index].poison;
        seg_tree[2*curr_index+1].least_health-=seg_tree[curr_index].poison;
        seg_tree[2*curr_index+2].least_health-=seg_tree[curr_index].poison;
        int mid=(curr_first+curr_last)/2;
        if(first<=mid)
            update(first,last,2*curr_index+1,curr_first,(curr_first+curr_last)/2,dec);
        if(last>mid)
            update(first,last,2*curr_index+2,(curr_first+curr_last)/2+1,curr_last,dec);
        seg_tree[curr_index].poison=0;
        seg_tree[curr_index].least_health=min(seg_tree[2*curr_index+1].least_health,seg_tree[2*curr_index+2].least_health);
        seg_tree[curr_index].alive=seg_tree[2*curr_index+1].alive+seg_tree[2*curr_index+2].alive;
    }
}

/*if((curr_first>=first && curr_last<=last) || (curr_first<first && curr_last>=first && curr_last<=last) || (curr_first>=first && curr_first<=last && curr_last>last) || (curr_first<first && curr_last>last))
{
    int dead_chefs=update(first,last,curr_first,(curr_first+curr_last)/2,2*curr_index+1)+update(first,last,(curr_first+curr_last)/2+1,curr_last,2*curr_index+2);
    seg_tree[curr_index]-=dead_chefs;
    return dead_chefs;

}

else return 0;*/



inline int query(int first, int last, int curr_index, int curr_first, int curr_last)
{
    if(curr_first>=first && curr_last<=last)
        return seg_tree[curr_index].alive;
    else if(last<curr_first || first>curr_last)
        return 0;
    else return query(first,last,2*curr_index+1,curr_first,(curr_first+curr_last)/2) + query(first,last,2*curr_index+2,(curr_first+curr_last)/2+1,curr_last);
}


inline void preorder(int index)
{
    int i, count=counter;
    pre_order[counter][0]=index;
    pre_order_index[index]=counter;
    if(tree[index].size())
    {
        pre_order[counter][1]=counter+1;
        counter++;
        l0(i,tree[index].size())
        preorder(tree[index][i]);
        pre_order[count][2]=counter-1;

    }


    else
    {
        pre_order[counter][1]=pre_order[counter][2]=-1;
        counter++;
    }


}
int main()
{
    int n, q, a, x, i, type, superior, min_health;
    sd(n);

    l1(i,n+1)
    {
        sd(health[i]);
        sd(superior);
        tree[superior].pb(i);
    }
    //l0(i,n+1)
    //pdn(health[i]);
    sd(q);
    //l0(i,tree[1].size())
    //pdn(tree[1][i]);
    preorder(0);
    min_health=build_seg_tree(1,n,0);

    //l0(i,2*n+1)
    //pdn(seg_tree[i]);
    //pdn(total_alive);
    //l0(i,n+1)
    //printf("%d %d %d %d %d\n",i,pre_order[i][0],pre_order_index[i],pre_order[i][1], pre_order[i][2]);
    //pdn(counter);
    W(q)
    {
        sd(type);
        if(type==1)
        {
            sd(a);
            sd(x);
            if(pre_order[pre_order_index[a]][1]!=-1)
                update(pre_order[pre_order_index[a]][1],pre_order[pre_order_index[a]][2],0,1,n,x);
            //pdn(pre_order[pre_order_index[a]][1]);
            //pdn(pre_order[pre_order_index[a]][2]);
            //pdn(chefs_removed);
            //l0(i,2*n+1)
            //pdn(seg_tree[i]);
            //pdn(total_alive);

        }
        else
        {
            sd(a);
            //pdn(alive[a]);
            pdn(query(pre_order[pre_order_index[a]][1],pre_order[pre_order_index[a]][2],0,1,n));
        }
    }
    return 0;
}
