//Codechef September Challenge 2013

#include<cstdio>
#include<algorithm>
#include<vector>

using namespace std;

struct node{
    int alive, poison, leastHealthy;
    void split(node &lft, node &rgt){
        lft.poison+=poison; lft.leastHealthy-=poison;
        rgt.poison+=poison; rgt.leastHealthy-=poison;
        poison=0;
    }
    void merge(node &lft, node &rgt){
        alive=lft.alive+rgt.alive;
        leastHealthy=min(lft.leastHealthy, rgt.leastHealthy);
        poison=0;
    }
    bool update(int decrement){
        leastHealthy-=decrement;
        poison+=decrement;
        if(leastHealthy>0) return 0;
        else return 1;
    }
    void make_dead(){
        leastHealthy=1.1e9;
        alive=0;
        poison=0;
    }
    void init(int a){
        alive=a>0?1:0;
        leastHealthy=a>0?a:1.1e9;
        poison=0;
    }
}tree[1<<18];

void update(int root, int lftmst, int rgtmst, int u, int v, int dcrmnt){
    int l=root<<1, r=l|1, mid=(lftmst+rgtmst)>>1;
    if(u<=lftmst && v>=rgtmst){
        if(tree[root].update(dcrmnt)){
            if(lftmst<=root){
                tree[root].make_dead();
            }
            else{
                tree[root].split(tree[l], tree[r]);
                update(l, lftmst, mid, u, v, 0);
                update(r, mid, rgtmst, u, v, 0);
                tree[root].merge(tree[l], tree[r]);
            }
        }
        return;
    }
    tree[root].split(tree[l], tree[r]);
    if(u<mid) update(l, lftmst, mid, u, v, dcrmnt);
    if(v>mid) update(r, mid, rgtmst, u, v, dcrmnt);
    tree[root].merge(tree[l], tree[r]);
}

int query(int root, int lftmst, int rgtmst, int u, int v){
    if(u<=lftmst && v>=rgtmst) return tree[root].alive;
    int ans=0, l=root<<1, r=l|1, mid=(lftmst+rgtmst)>>1;
    if(u<mid) ans+=query(l, lftmst, mid, u, v);
    if(v>mid) ans+=query(r, mid, rgtmst, u, v);
    return ans;
}

int in[1<<17], out[1<<17], cnt=0;
vector<int> G[1<<17];

void dfs(int u){
    in[u]=(1<<17)+(++cnt);
    for(int i=0; i<G[u].size(); i++) dfs(G[u][i]);
    out[u]=(1<<17)+cnt;
}

int main(){
    int N, Q;
    scanf("%d", &N);
    int health[N+1];
    health[0]=0;
    for(int i=1; i<=N; i++){
        int p;
        scanf("%d %d", &health[i], &p);
        G[p].push_back(i);
    }
    dfs(0);
    for(int i=0; i<(1<<17); i++){
        if(i>N) tree[i+(1<<17)].init(0);
        else tree[in[i]-1].init(health[i]);
    }
    for(int i=(1<<17); --i; ) tree[i].merge(tree[i<<1], tree[(i<<1)+1]);
    scanf("%d", &Q);
    while(Q--){
        int type, a, x;
        scanf("%d %d", &type, &a);
        if(type==1){
            scanf("%d", &x);
            in[a]!=out[a]?update(1, 1<<17, 1<<18, in[a], out[a], x):void(0);
        }
        else
            printf("%d\n", in[a]!=out[a]?query(1, 1<<17, 1<<18, in[a], out[a]):0);
    }
}

