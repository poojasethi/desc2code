#include <bits/stdc++.h>
using namespace std;
#define mx 100001
#define ll long long
#define pii pair<long long,long long>
struct node
{
	int a,b,c;
	node(int a, int b, int c)
	{
		this->a = a;
		this->b = b;
		this->c = c;
	}
};
vector<vector<int> > graph;
int health[mx+5];
int ar[mx+5];
vector<vector<pii> > op;
vector<node> query;
ll poison[mx+5];
ll bit[mx+5];
vector<int> death[mx+5];
int st[mx+5];
int en[mx+5];
int ix;
int n;
int q;
ll sum(long long *ar,int x)
{
	ll ans = 0;
	while (x) {
		ans += ar[x];
		x -= (x&-x);
	}
	return ans;
}
void update(long long *ar, int x, int val)
{
	while (x < mx+3){
		ar[x] += val;
		x += (x&-x);
	}
}
int find_death(int x)
{
	int l = 1;
	int r = q;
	while (l < r) {
		int mid = (l+r)/2;
		if (sum(poison,mid) >= health[x]) {
			r = mid;
		}
		else {
			l = mid+1;
		}
	}
	return l;
}
void dfs(int u)
{
	ar[++ix] = u;
	st[u] = ix;
	if(u && sum(poison,q) >= health[u]) { // find death time of chef u which is at st[u] in ar 
		int tym = find_death(u);
		death[tym].push_back(ix);
	}
	for (int i = 0; i < op[u].size(); i++) {
		update(poison,op[u][i].first,op[u][i].second);
	}
	for (int i = 0; i < graph[u].size(); i++) {
		dfs(graph[u][i]);
	}
	for (int i = 0; i < op[u].size(); i++) {
		update(poison,op[u][i].first,-1*op[u][i].second);
	}
	en[u] = ix;
}
int main()
{
	int t;
	scanf("%d",&n);
	graph.resize(n+5);
	op.resize(n+5);
	for (int i = 1; i <= n; i++) {
		int awe;
		scanf("%d%d",&health[i],&awe);
		graph[awe].push_back(i);
	}
	scanf("%d",&q);
	for (int i = 0; i < q; i++) {
		int c,a,b;
		scanf("%d",&c);
		if (c == 1) {
			scanf("%d%d",&a,&b);
			op[a].push_back(pii(i+1,b));
		}
		else {
			scanf("%d",&a);
		}
		query.push_back(node(a,b,c));
	}
	dfs(0);
	for (int i = 0; i < q; i++) {

		if(query[i].c == 2) {
			int chef = query[i].a;
			int l = st[chef];
			int r = en[chef];
			int died = sum(bit,r)-sum(bit,l);
			printf("%d\n",r-l-died);
		}
		else {
			for (int j = 0; j < death[i+1].size(); j++) {
				update(bit,death[i+1][j],1);
			}
		}
	}
	return 0;
}

