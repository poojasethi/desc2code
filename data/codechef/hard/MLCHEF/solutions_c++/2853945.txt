#include <cassert>
#include <cstdio>
#include <ctime>
#include <cstdlib>
#include <climits>
#include <cstddef>
#include <cctype>
#include <cmath>
#include <cstring>
#include <fstream>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <iterator>
#include <numeric>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <bitset>
#include <list>
#include <string>
#include <functional>
#include <utility>
using namespace std;
typedef long long llint;
int const N = 100000;
int const MAX_H = 1000000000;
int n;
int health[N + 1];
vector <int> g[N + 1];
int cnt;
int pre_order[N + 1];
int bd[N + 1][2];
struct Node
{
    int fi, la;
    int alive, min_h, dec;
    void init(int fi, int la)
    {
        this->fi = fi;
        this->la = la;
        this->alive = fi == la ? 1 : 0;
        this->min_h = fi == la ? health[pre_order[fi]] : 0;
        this->dec = 0;
    }
    int update(int poison)
    {
        dec += poison;
        min_h -= poison;
        return min_h > 0 ? 0 : 1;
    }
    void split(Node &l, Node &r)
    {
        l.dec += dec; l.min_h -= dec;
        r.dec += dec; r.min_h -= dec;
        dec = 0;
    }
    void merge(Node &l, Node &r)
    {
        alive = l.alive + r.alive;
        min_h = min(l.min_h, r.min_h);
    }
    void make_dead()
    {
        alive = 0;
        min_h = MAX_H + 1;
        dec = 0;
    }
};
Node nodes[N * 3];
void traverse(int u)
{
    pre_order[cnt++] = u;
    bd[u][0] = cnt;
    for (vector <int>::const_iterator it = g[u].begin(); it != g[u].end(); ++it)
    {
        traverse(*it);
    }
    bd[u][1] = cnt;
}
inline int lc(int root)
{
    return root << 1;
}
inline int rc(int root)
{
    return (root << 1) | 1;
}
void build(int root, int fi, int la)
{
    nodes[root].init(fi, la);
    if (fi != la)
    {
        int mid = (fi + la) / 2;
        build(lc(root), fi, mid);
        build(rc(root), mid + 1, la);
        nodes[root].merge(nodes[lc(root)], nodes[rc(root)]);
    }
}
void update(int root, int fi, int la, int x)
{
    if (fi <= nodes[root].fi && la >= nodes[root].la)
    {
        if (nodes[root].update(x))
        {
            if (nodes[root].fi == nodes[root].la)
            {
                nodes[root].make_dead();
            }
            else
            {
                nodes[root].split(nodes[lc(root)], nodes[rc(root)]);
                update(lc(root), fi, la, 0);
                update(rc(root), fi, la, 0);
                nodes[root].merge(nodes[lc(root)], nodes[rc(root)]);
            }
        }
        return;
    }
    int mid = (nodes[root].fi + nodes[root].la) / 2;
    nodes[root].split(nodes[lc(root)], nodes[rc(root)]);
    if (fi <= mid)
    {
        update(lc(root), fi, la, x);
    }
    if (la > mid)
    {
        update(rc(root), fi, la, x);
    }
    nodes[root].merge(nodes[lc(root)], nodes[rc(root)]);
}
int query(int root, int fi, int la)
{
    if (fi <= nodes[root].fi && la >= nodes[root].la)
    {
        return nodes[root].alive;
    }
    int ret = 0;
    int mid = (nodes[root].fi + nodes[root].la) / 2;
    if (fi <= mid)
    {
        ret += query(lc(root), fi, la);
    }
    if (la > mid)
    {
        ret += query(rc(root), fi, la);
    }
    return ret;
}
int main()
{
    // tree
    scanf("%d", &n);
    for (int i = 1, j, k; i <= n; ++i)
    {
        scanf("%d%d", &j, &k);
        health[i] = j;
        g[k].push_back(i);
    }
    cnt = 0;
    traverse(0);
    build(1, 1, n);
    // update & query
    int q;
    int op, a, x;
    scanf("%d", &q);
    while (q--)
    {
        scanf("%d", &op);
        if (op == 1)
        {
            scanf("%d%d", &a, &x);
            if (bd[a][0] < bd[a][1])
            {
                update(1, bd[a][0], bd[a][1] - 1, x);
            }
        }
        else
        {
            scanf("%d", &a);
            printf("%d\n", bd[a][0] < bd[a][1] ? query(1, bd[a][0], bd[a][1] - 1) : 0);
        }
    }
    return 0;
}
