#include <iostream>
#include<vector>
#include<cstdio>
using namespace std;
struct tre
{
    long long int health;
    long long int alive;
    long long int least;
}T[100005*4];
long long int hel[100005],seg_hel[100005],flag[100005*4];
void build(long long int node,long long int i,long long int j)
{
    if(i==j)
    {
        T[node].health=seg_hel[i];
        T[node].alive=1;
        T[node].least=seg_hel[i];
        flag[node]=-1;
        return;
    }
    long long int lt=2*node,rt=2*node+1,mid=(i+j)/2;
    build(lt,i,mid);
    build(rt,mid+1,j);
    flag[node]=-1;
    T[node].health=T[lt].health+T[rt].health;
    T[node].alive=T[lt].alive+T[rt].alive;
    T[node].least=min(T[lt].least,T[rt].least);
}
void refres(long long int node,long long int i,long long int j)
{
    if(flag[node]!=-1)
    {
        T[node].health-=(j-i+1)*flag[node];
        T[node].least-=flag[node];
        if(i!=j)
        {if(flag[2*node]!=-1)
        flag[2*node]+=flag[node];
        else
        flag[2*node]=flag[node];
        if(flag[2*node+1]!=-1)
        flag[2*node+1]+=flag[node];
        else
        flag[2*node+1]=flag[node];
        }
flag[node]=-1;
    }
    return;
}
void remove(long long int node,long long int i,long long int j)
{
  refres(node,i,j);
if(T[node].least>0)
{
    return;
}
long long int mid=(i+j)/2;
if(i==j)
{
    T[node].alive=0;
    T[node].least=1e+11;
    return;
}
else
{
    remove(2*node,i,mid);
    remove(2*node+1,mid+1,j);
    T[node].least=min(T[2*node].least,T[2*node+1].least);
    T[node].alive=T[2*node].alive+T[2*node+1].alive;
}
}
void update(long long int node,long long int i,long long int j,long long int s,long long int e,long long int val)
{
    if(j<s||e<i||i>j)
    {
        refres(node,i,j);
        return;
    }
    else if(s<=i&&j<=e)
    {
        if(flag[node]!=-1)
        flag[node]+=val;
        else
        flag[node]=val;
        refres(node,i,j);
        return;
    }
    long long int lt=2*node,rt=2*node+1,mid=(i+j)/2;
    refres(node,i,j);
    update(lt,i,mid,s,e,val);
    update(rt,mid+1,j,s,e,val);
    if(i!=j)
    {
    T[node].health=T[lt].health+T[rt].health;
    T[node].alive=T[lt].alive+T[rt].alive;
    T[node].least=min(T[lt].least,T[rt].least);
    }
}
long long int query(long long int node,long long int i,long long int j,long long int s,long long int e)
{
 refres(node,i,j);
 remove(node,i,j);
 if(i==s&&e==j)
 return T[node].alive;
 long long int lt=2*node,rt=lt+1,mid=(i+j)/2;
 if(e<=mid)
 return query(lt,i,mid,s,e);
 else if(s>mid)
 return query(rt,mid+1,j,s,e);
 else
 return query(lt,i,mid,s,mid)+query(rt,mid+1,j,mid+1,e);
}
struct arr
{
    long long int t;
    long long int s;
    long long int l;
    long long int h;
}range[100005*4];
typedef vector<long long int> VI;
VI mark;
vector<VI> a;
long long int sum;
long long int cnt=-1;
long long int dfs(long long int u,long long int &sum)
{
cnt++;
mark[u]=1;
range[u].t=cnt;
for (VI::iterator v = a[u].begin(); v != a[u].end(); v++)
{
    if(mark[*v]==0)
    {long long int t=0;
        dfs(*v,t);
        sum+=range[*v].s+1;
    }
}
range[u].s+=sum;
return sum;
}
int main()
{
    long long int n,i,u,t,Q,A,X;
    int typ;
    scanf("%lld",&n);
    a=vector<VI> (n+1);
    mark=VI(n+1,0);
    hel[0]=1e+11;
    for(i=1;i<=n;i++)
    {
     scanf("%lld %lld",&hel[i],&u);
     a[u].push_back(i);
     a[i].push_back(u);
    }
    t=0;
    dfs(0,t);
    for(i=0;i<=n;i++)
    seg_hel[i]=1e+11;
    for(i=0;i<=n;i++)
    {
        seg_hel[range[i].t]=hel[i];
        if(range[i].s>0)
        {
        range[i].l=range[i].t+1;
        range[i].h=range[i].t+range[i].s;
        }
        else
        {
        range[i].l=range[i].t;
        range[i].h=range[i].t;
        }
    }
    build(1,0,n);
    scanf("%lld",&Q);
    while(Q--)
    {
        scanf("%d",&typ);
        if(typ==1)
        {
            scanf("%lld %lld",&A,&X);
            if(range[A].s>0)
            {update(1,0,n,range[A].l,range[A].h,X);
            remove(1,0,n);
            }
        }
        else
        {
            scanf("%lld",&A);
            remove(1,0,n);
            if(range[A].s>0)
            printf("%lld\n",query(1,0,n,range[A].l,range[A].h));
            else
            printf("0\n");
        }
    }
    return 0;
}
