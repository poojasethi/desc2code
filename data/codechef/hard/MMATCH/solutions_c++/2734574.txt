#include <stdio.h>
#include <string.h>
 
int childrenCount, bedCount, caseCount;
 
struct Grid
{
   char c[100];
   char b[100];
   char bc[100][100];
};
 
void ClearCell(Grid * pG, int const b, int const c)
{
   int ii;
 
   pG->bc[b][c] = 0;
   pG->b[b] = 0;
   pG->c[c] = 0;
 
   for (ii = 0; ii < bedCount; ++ii)
   {
      if (pG->bc[ii][c])
      {
         pG->bc[ii][c] = 0;
         --(pG->b[ii]);
      }
   }
 
   for (ii = 0; ii < childrenCount; ++ii)
   {
      if (pG->bc[b][ii])
      {
         pG->bc[b][ii] = 0;
         --(pG->c[ii]);
      }
   }
}
 
int CalcMaxHappy(Grid const * const pG)
{
   int maxHappy, ii;
   int cCount = 0;
   int bCount = 0;
 
   for (ii = 0; ii < bedCount; ++ii)
   {
      if (pG->b[ii])
      {
         ++bCount;
      }
   }
 
   for (ii = 0; ii < childrenCount; ++ii)
   {
      if (pG->c[ii])
      {
         ++cCount;
      }
   }
 
    maxHappy = (bCount <= cCount) ? bCount : cCount;
    return maxHappy;
}
 
int GetTheOnes (Grid * pG)
{
   int ii, jj, kk;
   bool goAgain;
   int happy = 0;
 
   do
   {
      goAgain = false;
 
      for (ii = 0; ii < bedCount; ++ii)
      {
         if (pG->b[ii] == 1)
         {
            ++happy;
 
            for (jj = 0; !(pG->bc[ii][jj]); ++jj);
            pG->c[jj] = 0;

            for (kk = 0; kk < bedCount; ++kk)
            {
               if (pG->bc[kk][jj])
               {
                  pG->bc[kk][jj] = 0;
                  --(pG->b[kk]);
                  if (pG->b[kk] == 1)
                  {
                     goAgain = true;
                  }
               }
            }
         }
      }
 
      for (ii = 0; ii < childrenCount; ++ii)
      {
         if (pG->c[ii] == 1)
         {
            ++happy;
 
            for (jj = 0; !(pG->bc[jj][ii]); ++jj);
            pG->b[jj] = 0;

            for (kk = 0; kk < childrenCount; ++kk)
            {
               if (pG->bc[jj][kk])
               {
                  pG->bc[jj][kk] = 0;
                  --(pG->c[kk]);
                  if (pG->c[kk] == 1)
                  {
                     goAgain = true;
                  }
               }
            }
         }
      }
   } while (goAgain);
 
   return happy;
}
 
int Tree (Grid g, int const b, int const c)
{
   ClearCell(&g, b, c);
   int level = GetTheOnes(&g) + 1;

   int maxHappy = CalcMaxHappy(&g);
   if (maxHappy == 0)
   {
      return level;
   }
   maxHappy += level;
   
   int happy = level;
   
   for (int ii = 0; ii < bedCount; ++ii)
   {
      for (int jj = 0; jj < childrenCount; ++jj)
      {
         if (g.bc[ii][jj])
         {
            int t = Tree(g, ii, jj) + level;
            if (t > happy)
            {
               happy = t;
 
               if (maxHappy == happy)
               {
                  return happy;
               }
            }
         }
      }
   }
 
   return happy;
}

int TreeRoot (Grid &g)
{
   int level = GetTheOnes(&g);
   
   int maxHappy = CalcMaxHappy(&g);
   if (maxHappy == 0)
   {
      return level;
   }
   maxHappy += level;
   
   int happy = level;
   
   for (int ii = 0; ii < bedCount; ++ii)
   {
      for (int jj = 0; jj < childrenCount; ++jj)
      {
         if (g.bc[ii][jj])
         {
            int t = Tree(g, ii, jj) + level;
            if (t > happy)
            {
               happy = t;
 
               if (maxHappy == happy)
               {
                  return happy;
               }
            }
         }
      }
   }
 
   return happy;
} 
 
int main()
{
   int tcCount, ii;
   Grid g;
   scanf("%d", &tcCount);
 
   for (ii = 0; ii < tcCount; ++ii)
   {
      scanf("%d %d", &childrenCount, &bedCount);
      if (childrenCount > 100 || bedCount > 100) return -1; 
 
      memset(&g, 0, sizeof(struct Grid));
 
      while (1)
      {
         int c, b;
 
         scanf("%d %d", &c, &b);
 
         if (c == 0 && b == 0) break;
         --b;
         --c;
 
         g.bc[b][c] = 1;
         ++(g.c[c]);
         ++(g.b[b]);
      }
 
      printf("%d\n", TreeRoot(g));
   }
 
   return 0;
}