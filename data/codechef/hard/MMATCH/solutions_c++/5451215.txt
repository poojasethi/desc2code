#include <stdio.h>
#include <string.h>
 
int childrenCount, bedCount, memSize;
 
struct Grid
{
   Grid()
   {
      b = new char[memSize];
      c = b + bedCount;
      bc = c + childrenCount;
   }
   
   ~Grid()
   {
      delete [] b;
   }
   
   char *b;
   char *c;
   char *bc;
};
 
int GetTheOnes (Grid &g, int &bCount, int &cCount)
{
   int ii, jj, kk;
   int happy = 0;
 
   for (ii = 0; ii < bedCount; ++ii)
   {
      if (g.b[ii] == 1)
      {
         ++happy;
 
         for (jj = 0; !(g.bc[ii*childrenCount+jj]); ++jj);
         g.c[jj] = 0;
         --cCount;
 
         for (kk = 0; kk < bedCount; ++kk)
         {
            if (g.bc[kk*childrenCount+jj])
            {
               g.bc[kk*childrenCount+jj] = 0;
               --(g.b[kk]);
               if (g.b[kk] == 1 && kk < ii)
               {
                  ii = kk - 1;
               }
               else if (!(g.b[kk]))
               {
                  --bCount;
               }
            }
         }
      }
   }
 
   for (ii = 0; ii < childrenCount; ++ii)
   {
      if (g.c[ii] == 1)
      {
         ++happy;
 
         for (jj = 0; !(g.bc[jj*childrenCount+ii]); ++jj);
         g.b[jj] = 0;
         --bCount;
 
         for (kk = 0; kk < childrenCount; ++kk)
         {
            if (g.bc[jj*childrenCount+kk])
            {
               g.bc[jj*childrenCount+kk] = 0;
               --(g.c[kk]);
               if (g.c[kk] == 1 && kk < ii)
               {
                  ii = kk - 1;
               }
               else if (!(g.c[kk]))
               {
                  --cCount;
               }
            }
         }
      }
   }
 
   return happy;
}
 
int Tree(Grid const &gIn, int const bCountIn, int const cCountIn, int const baseHappyIn, int const maxHappyIn)
{
   int happy = 0;
   Grid g;
   
   for (int ii = 0; ii < bedCount; ++ii)
   {
      int II = ii*childrenCount;
      for (int jj = 0; jj < childrenCount; ++jj)
      {
         if (gIn.bc[II+jj])
         {
            memcpy(g.b, gIn.b, memSize);
            
            int bCount = bCountIn;
            int cCount = cCountIn;
            
            g.bc[II+jj] = 0;
            g.b[ii] = 0;
            g.c[jj] = 0;
            --bCount;
            --cCount;
          
            for (int kk = 0; kk < bedCount; ++kk)
            {
               if (g.bc[kk*childrenCount+jj])
               {
                  g.bc[kk*childrenCount+jj] = 0;
                  --(g.b[kk]);
                  if (!(g.b[kk]))
                  {
                     --bCount;
                  }
               }
            }
          
            for (int kk = 0; kk < childrenCount; ++kk)
            {
               if (g.bc[II+kk])
               {
                  g.bc[II+kk] = 0;
                  --(g.c[kk]);
                  if (!(g.c[kk]))
                  {
                     --cCount;
                  }
               }
            }
   
            int baseHappy = GetTheOnes(g, bCount, cCount) + 1;
            int maxHappy = (bCount <= cCount) ? bCount : cCount;
            
            if ((maxHappy + baseHappy) > happy)
            {
               int t = maxHappy ? Tree(g, bCount, cCount, baseHappy, maxHappy) : baseHappy;
               
               if (t > happy)
               {
                  happy = t;
    
                  if (maxHappyIn == happy)
                  {
                     ii = bedCount;
                     jj = childrenCount;
                  }
               }
            }
         }
      }
   }
 
   return happy + baseHappyIn;
}
 
int main()
{
   int tcCount = 0;
   scanf("%d", &tcCount);
 
   for (int ii = 0; ii < tcCount; ++ii)
   {
      scanf("%d %d", &childrenCount, &bedCount);
      if (childrenCount > 100 || bedCount > 100) return -1; 
      memSize = bedCount+childrenCount+bedCount*childrenCount;
      
      Grid g;
      memset(g.b, 0, memSize);
 
      int bCount = 0;
      int cCount = 0;
   
      while (1)
      {
         int b, c;
 
         scanf("%d %d", &c, &b);
 
         if (!b && !c) break;
         --b;
         --c;
 
         g.bc[b*childrenCount+c] = 1;
         if(!(g.b[b])) ++bCount;
         ++(g.b[b]);
         if(!(g.c[c])) ++cCount;
         ++(g.c[c]);
      }
      
      int baseHappy = GetTheOnes(g, bCount, cCount);
      
      int maxHappy = (bCount <= cCount) ? bCount : cCount;
      int t = maxHappy ? Tree(g, bCount, cCount, baseHappy, maxHappy) : baseHappy;
      printf("%d\n", t);
   }
 
   return 0;
}  