//Coder: Balajiganapathi
//#define TRACE
#define DEBUG

#include <algorithm>
#include <bitset>
#include <deque>
#include <cassert>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <functional>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <utility>
#include <vector>

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pi;
typedef vector<string> vs;

// Basic macros
#define st          first
#define se          second
#define all(x)      (x).begin(), (x).end()
#define ini(a, v)   memset(a, v, sizeof(a))
#define re(i,s,n)  	for(int i=s;i<(n);++i)
#define rep(i,s,n)  for(int i=s;i<=(n);++i)
#define fr(i,n)     re(i,0,n)
#define repv(i,f,t) for(int i = f; i >= t; --i)
#define rev(i,f,t)  repv(i,f - 1,t)
#define frv(i,n)    rev(i,n,0)
#define pu          push_back
#define mp          make_pair
#define sz(x)       (int)(x.size())

const int oo = 2000000009;
const double eps = 1e-9;

#ifdef TRACE
    #define trace1(x)                cerr << #x << ": " << x << endl;
    #define trace2(x, y)             cerr << #x << ": " << x << " | " << #y << ": " << y << endl;
    #define trace3(x, y, z)          cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl;
    #define trace4(a, b, c, d)       cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << endl;
    #define trace5(a, b, c, d, e)    cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << endl;
    #define trace6(a, b, c, d, e, f) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << " | " << #f << ": " << f << endl;

#else

    #define trace1(x)
    #define trace2(x, y)
    #define trace3(x, y, z)
    #define trace4(a, b, c, d)
    #define trace5(a, b, c, d, e)
    #define trace6(a, b, c, d, e, f)

#endif

const int mx = 202;
struct Order {
    public:
    int s, x, d, p;
} orders[mx], orders2[mx];

struct Range {
    public:
    int s, e;
    Range(int _s, int _e) {
        s = _s; e = _e;
    }
};

bool byP(Order o1, Order o2) {
    return o1.p > o2.p;
}

bool byD(Order o1, Order o2) {
    return o1.d < o2.d;
}

int n;

int main() {
    int t;
    scanf("%d", &t);
    while(t--) {
        scanf("%d", &n);
        fr(i, n) scanf("%d %d %d %d", &orders[i].s, &orders[i].x, &orders[i].d, &orders[i].p);
        fr(i, n) orders[i].d--;
        sort(orders, orders + n, byP);
        fr(i, n) orders2[i] = orders[i];

        map<pi, int> scnt;

        fr(i, n) {
            scnt[mp(orders[i].s, 1)] += 1;
            scnt[mp(orders[i].d, 0)] += 1;
        }

        int prev = 0, cur = 0;
        vector<pi> v;
        for(map<pi, int>::iterator it = scnt.begin(); it != scnt.end(); ++it) {
            trace4(cur, it->st.st, it->st.se, it->se);

            if(cur > 0) {
                if(it->st.se == 1) {
                    cur += it->se;
                    v.pu(mp(prev + 1, it->st.st - 1));
                    prev = v.back().se;
                } else {
                    cur -= it->se;
                    v.pu(mp(prev + 1, it->st.st));
                    prev = v.back().se;
                }
            } else {
                prev = it->st.st - 1;
                cur += it->se;
            }
        }
        fr(i, sz(v)) trace3(i, v[i].st, v[i].se);

        ll ans = 0, cur_tot = 0, tot, diff;
        fr(i, n) {
            cur_tot += orders[i].x;
            priority_queue<pi, vector<pi>, greater<pi> > q;
            tot = 0;

            fr(k, sz(v)) {
                int rem = v[k].se - v[k].st + 1;
                int lo = v[k].st;

                rep(l, 0, i) if(orders[l].s == v[k].st) q.push(mp(orders[l].d, orders[l].x));

                while(rem > 0 && !q.empty()) {
                    pi p = q.top(); q.pop();
                    if(p.st < lo) continue;
                    trace6(i, k, lo, rem, p.st, p.se);
                    assert(v[k].se - lo + 1 == rem);
                    int x = min(p.se, v[k].se - lo + 1);
                    lo += x;
                    rem -= x;
                    p.se -= x;
                    tot += x;
                    if(p.se > 0) q.push(p);
                }
            }

            diff = cur_tot - tot;
            trace3(i, cur_tot, tot);
            assert(diff <= orders[i].x);
            orders[i].x -= diff;
            cur_tot -= diff;
            ans += diff * orders[i].p;

        }
        printf("%lld\n", ans);
        
    }
        
    
	return 0;
}
