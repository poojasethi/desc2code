#include <algorithm>
#include <functional>
#include <numeric>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <cassert>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <bitset>
#include <sstream>

using namespace std;

#define fore(i, l, r) for(int i = (l); i < (r); ++i)
#define forn(i, n) fore(i, 0, n)
#define fori(i, l, r) fore(i, l, (r) + 1)
#define sz(v) int((v).size())
#define all(v) (v).begin(), (v).end()
#define pb push_back
#define mp make_pair
#define X first
#define Y second

#if ( _WIN32 || __WIN32__ )
    #define LLD "%I64d"
#else
    #define LLD "%lld"
#endif

typedef long long li;
typedef long double ld;
typedef pair<int, int> pt;

template<typename T> T abs(T a) { return a < 0 ? -a : a; }
template<typename T> T sqr(T a) { return a*a; }

const int INF = (int)1e9;
const ld EPS = 1e-9;
const ld PI = 3.1415926535897932384626433832795;

const ld __EPS__ = 1e-15;

const int NMAX = 400;
const int MAXC = 100000000;

struct rec{
    int s, x, d, p;
    rec(){
        s = x = d = p = 0;
    }
};

int n;
rec a[NMAX];
vector<int> sep;

bool operator < (const rec& o1, const rec& o2){
    return o1.p < o2.p;
}

bool cmp(const rec& o1, const rec& o2){
    return o1.d < o2.d;
}

li getOverflow(vector<rec> a){
    sort(all(a), cmp);
    
    vector<int> cnt(sz(sep));
    forn(i, sz(sep) - 1)
        cnt[i] = sep[i + 1] - sep[i];
   
    li sum = 0;
    forn(i, sz(a)){
        int lf = lower_bound(all(sep), a[i].s) - sep.begin();
        while(sep[lf] != a[i].d){
            int cur = min(a[i].x, cnt[lf]);
            cnt[lf] -= cur;
            a[i].x -= cur;
            lf++;
        }
        sum += a[i].x;
    }
    return sum;
}

void solve(){
    //cerr << '+' << endl;
    scanf("%d",&n);
    sep.clear();
    forn(i, n){
        //cerr << i << endl;
        
        scanf("%d",&a[i].s);
        scanf("%d",&a[i].x);
        scanf("%d",&a[i].d);
        scanf("%d",&a[i].p);
        sep.pb(a[i].s);
        sep.pb(a[i].d);
    }
    sort(all(sep));
    sep.erase(unique(all(sep)), sep.end());
    sort(a, a + n);
    reverse(a, a + n);
    
    li sum = 0;
    forn(i, n){
        vector<rec> tmp;
        forn(j, i + 1)
            tmp.pb(a[j]);
        li cur = getOverflow(tmp);
        sum += cur * a[i].p;
        assert(cur <= a[i].x);
        a[i].x -= cur;
    }
    cout << sum << endl;
}

int main(){
    int T;
    scanf("%d",&T);
    forn(Ti, T){
        solve();
    }
    
    return 0;
}
