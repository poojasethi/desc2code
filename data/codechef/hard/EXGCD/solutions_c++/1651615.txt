#include <iostream>
#include <cstdio>
#include <cstring>
using namespace::std;

const int MOD  = 1000000007;
const int SIZE = 200001;

struct gcdV
{
	int gcd;
	int x,y;
	gcdV(int g,int _x, int _y):gcd(g),x(_x),y(_y)
	{}
};

int invNew(int a)
{
	int b = MOD-2;
	int res = 1, pow = a;
	while(b)
	{
		if(b&1)
		{
			res = (((long long)res * pow)) % MOD;
		}
		pow = (((long long)pow * pow)) % MOD;
		b >>= 1;
	}
	return res;
}

gcdV euclidGCD(int a, int b)
{
	if(b==0)
		return gcdV(a,1,0);
	gcdV d = euclidGCD(b,a%b);
	int t = d.x; d.x = d.y; d.y = t;
	d.y = (d.y - (a/b)*(d.x));
	return d;
}


int invi(int a, int mod)
{
	gcdV d = euclidGCD(a,mod);
	return (d.x%MOD);
}

int main()
{	
	int t,k,Q,P,i,j,d,minB,N;
	int a[5],b[5];
	char composite[SIZE];
	int phi[SIZE],cur;

	memset(composite,0,sizeof(composite));
	
	for(i=1;i<SIZE;++i)
		phi[i] = i;
	
	for(i=2;i<SIZE;++i)
	{
		if(!composite[i])
		{
			for(j=i;j<SIZE;j+=i)
			{
				composite[j] = 1;
				phi[j] = (phi[j] / i) * (i-1);
			}
		}
	}
	
	scanf("%d",&t);
	while(t--)
	{
		Q = 1;
		minB = SIZE;
		scanf("%d",&k);
		for(i=0;i<k;++i)
		{
			scanf("%d %d", a+i, b+i);
			Q = (((long long)Q * (b[i] - a[i] + 1))) % MOD;
			minB = min(minB, b[i]);
		}
		
		P = 0;
		for(i=1;i<=minB;++i)
		{
			d = i;
			cur = 1;
			for(j=0;j<k && cur;++j)
			{
				//cur *= (b[j]/d - (a[j]-1)/d);
				cur = (((long long)cur * ((b[j]/d - (a[j]-1)/d)))) %MOD;
				//cout << cur<<endl;
			}
			cur = (((long long)cur * phi[d]))%MOD;
			P = (P + cur);
			if(P >= MOD)
				P -= MOD;
		}
		
		int gcdd = invNew(MOD-Q);//, MOD);
		//int gcdd = invi(MOD-Q, MOD);
		
		N = (((long long)P * gcdd))%MOD;
		//printf(" N= %d gcdd= %d Q= %d P= %d minB= %d\n",N, gcdd, Q, P, minB);
		printf("%d\n",N);
	}
	return 0;
}
