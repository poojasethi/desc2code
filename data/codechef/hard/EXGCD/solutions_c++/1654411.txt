#include <iostream>
#include <vector>
#include <set>
#include <map>
#include <algorithm>
#include <sstream>
#include <cmath>
#include <cstdio>
#include <string>
#include <queue>
#include <stack>
#include <deque>
#include <cstring>
#include <limits>

using namespace std;

#define FOR(I,A,B) for(int I= (A); I<(B); ++I)
#define REP(I,N) FOR(I,0,N)
#define S(N) scanf("%d", &N)
#define SL(N) scanf("%lld", &N)
#define PB push_back
#define MP make_pair
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define cell pair<int,int>
#define edge pair<int, cell>
typedef long long int LL;
typedef vector<int> vi;
typedef vector<LL> vii;
const int MOD = 1000000007;

int prod(int a, int b)
{
	return (LL) a * b % MOD;
}

int inv(int a) 
{
	int res = 1;
	for (int n = MOD - 2; n > 0; n /= 2)
    {
		if (n & 1)res = prod(res, a);
		a = prod(a, a);
	}
	return res;
}

const int maxK = 5;
const int maxN = 200000;
int composite[maxN+1];
int phi[maxN+1];

int main()
{
    for(int i = 1 ;i <= maxN ; i++ ) phi[i]=i;
    for(int i=2 ; i<= maxN ; i++ )
    if ( phi[i] == i)
    for(int j = 2*i ; j <= maxN ; j += i) phi[j] -=  phi[j]/ i ;
    for(int i=2 ; i<= maxN ; i++) if ( phi[i]==i) phi[i] = i-1;
    int T;
	S(T);
    while(T--)
    {
              int K; S(K);
              int A[maxK], B[maxK];
              int N = maxN;
		      int Q = 1;
              for (int i = 0; i < K; ++i)
              {
                  S(A[i]);
                  S(B[i]);
                  A[i]--;
                  N = min(N, B[i]);
                  Q = prod(Q, B[i] - A[i]);
              }
              int P = 0;
		      for (int d = 1; d <= N; ++d)
              {
                  int cur = phi[d];
                  for(int i = 0; i < K; ++i)
                  cur = prod(cur, B[i] / d - A[i] / d);
                  P = (P + cur) % MOD;
		}
		int res = prod(P, inv(MOD - Q));
        printf("%d\n", res);
	}
	return 0;
}
