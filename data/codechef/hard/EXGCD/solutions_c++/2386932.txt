/**
 * December Cook-Off 2012 at Codechef
 *
 * Problem:     EXGCD - Expected Greatest Common Divisor
 * Author:      Anton Lunyov (Tester)
 * Complexity:  O(N * log log N + T * N * K)
 * Timing:      0.88 out of 3
 *
 * Short description:
 * The expected GCD equals to P/Q where
 * P = sum(phi[d] * product(B[i]/d - (A[i]-1)/d : 0<=i<K) : 1<=d<=N),
 * Q = product(B[i]-A[i]+1: 0<=i<K).
 * Since Q is always coprime to MOD = 10^9+7,
 * we don't need to reduce this fraction,
 * and the answer to the problem is (P * inv(-q, MOD)) mod MOD
 * where x=inv(a,m)  if and only if  m divides a*x-1 and 0<=x<m.
 * phi[d] is Euler totient function,
 * values of which can be precomputed using Eratosthenes sieve.
 * See editorial for proof and details.
 */
#include <iostream>
using namespace std;

const int MOD = 1000000007;

// returns product a * b modulo MOD
int prod(int a, int b) {
	return (long long) a * b % MOD;
}

// returns number b such that MOD divides a * b - 1
// By Little Fermat Theorem it is equal to a^(MOD-2) % MOD
// Hence we apply exponentiation by squaring
int inv(int a) {
	int res = 1;
	for (int n = MOD - 2; n > 0; n /= 2) {
		if (n & 1) {
			res = prod(res, a);
		}
		a = prod(a, a);
	}
	return res;
}

const int maxK = 5;
const int maxN = 200000;

// needed for Eratosthenes sieve
// initialized by zeros
int composite[maxN+1];

// Euler totient function
// phi[n] is the count of numbers d from 1 to n, inclusive, for which gcd(n,d)=1
// phi[n] = n * product(1-1/p : p is prime and divides n)
int phi[maxN+1];

int main() {

	// init of array phi[]
	for (int n = 1; n <= maxN; ++n) {
		phi[n] = n;
	}

	// Eratosthenes sieve
	for (int p = 2; p <= maxN; ++p) {
		if (!composite[p]) { // p is prime

			// loop over numbers divisible by p
			for (int n = p; n <= maxN; n += p) {

				// we mark all numbers as composite, even p
				// but it is fine, since we need only array phi[] below
				composite[n] = 1;

				// update of phi[n] according to the above formula
				phi[n] = phi[n] / p * (p - 1);
				
				// IMPORTANT!!!
				// writing phi[n] = phi[n] * (p - 1) / p; is wrong
				// since we will have integer overflow then
				// it first occurs when n = p = 46349
				// then phi[n] * (p - 1) = 46349 * 46348 > 2^31
			}
		}
	}

	// input number of tests
	int T;
	cin >> T;

	// loop over tests
	for (int t = 0; t < T; ++t) {

		// input number of intervals
		int K;
		cin >> K;

		// [A[i], B[i]] is the interval where X[i] is chosen
		int A[maxK], B[maxK];

		// N is min(B[i] : 0 <= i < K)
		int N = maxN; // init by maxN which is an upper bound for each B[i]

		// Q is denominator of the expected GCD
		// and equals to product(B[i] - A[i] + 1 : 0 <= i < K) modulo MOD
		int Q = 1; // init by 1 as usual for products

		// loop over the intervals
		for (int i = 0; i < K; ++i) {
			// input interval length
			cin >> A[i] >> B[i];

			// decreasing A[i] by 1 for convenience
			A[i]--;

			// updating N by the number B[i]
			N = min(N, B[i]);

			// multiplying Q by B[i] - A[i] modulo MOD
			Q = prod(Q, B[i] - A[i]);
		}

		// P is numerator of the expected GCD
		// and equals to sum(phi[d] * product(B[i]/d - A[i]/d : 0 <= i < K) : 1<=d<=N) modulo MOD
		// according to editorial
		int P = 0; // init by 0 as usual for sums

		// loop over d
		for (int d = 1; d <= N; ++d) {

			// cur will be phi[d] * product(B[i]/d - A[i]/d : 0 <= i < K)
			// so we init it by phi[d]
			int cur = phi[d];

			// loop over intervals
			for(int i = 0; i < K; ++i) {
				// multiply cur by (B[i]/d - A[i]/d) modulo MOD
				cur = prod(cur, B[i] / d - A[i] / d);
			}

			// adding cur to P modulo MOD
			P = (P + cur) % MOD;
		}

		// res should satisfy the congruence P + Q * res = 0 (mod MOD)
		// or (-Q) * res = P (mod MOD)
		// Hence res = P * inv(-Q) % MOD by definition of inv(a)
		// in order to avoid negative numbers we replace inv(-Q) by inv(MOD-Q)
		int res = prod(P, inv(MOD - Q));

		// output the result
		cout << res << endl;
	}
	return 0;
}