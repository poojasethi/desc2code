#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <ctime>
#include <cctype>
#include <cfloat>
#include <climits>
#include <iostream>
#include <iomanip>
#include <fstream>
#include <algorithm>
#include <string>
#include <vector>
#include <list>
#include <stack>
#include <queue>
#include <deque>
#include <map>
#include <set>
#include <utility>
#include <sys/time.h>

#define INF 1000000007
#define EPS (1e-8)
#define pb(a) push_back(a)
#define pf(a) push_front(a)
#define mp make_pair
#define FOR(i,k) for(i=0;i<k;i++)
#define RFOR(i,k) for(i=k-1;i>=0;i--)
const long double PI = 3.1415926535897932384626433832795;
typedef long long LL;

using namespace std;

class Cell
{
public:
  int rowidx,colidx;
};

// mat[rowidx][colidx] should be = 'o'
int bfs(vector<string>& mat, int rowidx, int colidx )
{
  queue<Cell> bfsq;

  Cell u;
  u.rowidx = rowidx;
  u.colidx = colidx;
  
  mat[u.rowidx][u.colidx] = 'x';
  bfsq.push(u);
  int componentSize = 1;
  
  while( bfsq.size() > 0 )
    {
      Cell t = bfsq.front();
      bfsq.pop();
      
      // up
      int rownw = t.rowidx-1;
      int colnw = t.colidx;

      if( (rownw >= 0 ) && ( rownw < mat.size()) &&
	  ( colnw >= 0 ) && ( colnw < mat[0].size() ) )
	{
	  if( mat[rownw][colnw] == 'o' )
	    {
	      Cell nt;
	      nt.rowidx = rownw;
	      nt.colidx = colnw;
	      
	      mat[rownw][colnw] = 'x';
	      bfsq.push(nt);
	      componentSize++;
	    }
	}

      // down
      rownw = t.rowidx+1;
      colnw = t.colidx;

      if( (rownw >= 0 ) && ( rownw < mat.size()) &&
	  ( colnw >= 0 ) && ( colnw < mat[0].size() ) )
	{
	  if( mat[rownw][colnw] == 'o' )
	    {
	      Cell nt;
	      nt.rowidx = rownw;
	      nt.colidx = colnw;
	      
	      mat[rownw][colnw] = 'x';
	      bfsq.push(nt);
	      componentSize++;
	    }
	}

      // left
      rownw = t.rowidx;
      colnw = t.colidx-1;

      if( (rownw >= 0 ) && ( rownw < mat.size()) &&
	  ( colnw >= 0 ) && ( colnw < mat[0].size() ) )
	{
	  if( mat[rownw][colnw] == 'o' )
	    {
	      Cell nt;
	      nt.rowidx = rownw;
	      nt.colidx = colnw;
	      
	      mat[rownw][colnw] = 'x';
	      bfsq.push(nt);
	      componentSize++;
	    }
	}

      // right
      rownw = t.rowidx;
      colnw = t.colidx+1;

      if( (rownw >= 0 ) && ( rownw < mat.size()) &&
	  ( colnw >= 0 ) && ( colnw < mat[0].size() ) )
	{
	  if( mat[rownw][colnw] == 'o' )
	    {
	      Cell nt;
	      nt.rowidx = rownw;
	      nt.colidx = colnw;
	      
	      mat[rownw][colnw] = 'x';
	      bfsq.push(nt);
	      componentSize++;
	    }
	}
    }

  return componentSize;
}

void fillComponents( vector<string>& mat, vector<int>& components )
{
  for( int rowidx = 0 ; rowidx < mat.size() ; rowidx++ )
    for( int colidx = 0 ; colidx < mat[0].size() ; colidx++ )
      {
	if( mat[rowidx][colidx] == 'o')
	  {
	    int componentSize = bfs(mat,rowidx,colidx);
	    components.push_back(componentSize);
	  }
      }
}

main()
{
  int tests;
  scanf("%d",&tests);
  
  while(tests-- > 0 )
    {
      int rows,cols;
      scanf("%d%d",&rows,&cols);

      vector<string> mat;
      for( int i = 0 ; i < rows ; i++ )
	{
	  string line;
	  cin >> line;
	  mat.push_back(line);
	}
      
      vector<int> components;

      fillComponents( mat, components);

      long double ans = 1.0;
      for( int i = 1 ; i < components.size() ; i++ )
	{
	  long double xi = components[i];
	  long double x0 = components[0];
	  
	  ans = ans + (xi)/(xi+x0);
	}
      printf("%Lf\n",ans);
    }
}
