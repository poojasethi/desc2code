#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <climits>
#include <cctype>
#include <cassert>
 
using namespace std;

#define F(i,a,n) for(int i=(a);i<(n);++i)
 
/* Relevant code begins here */
 
/* Input from file or online */
 
void input() {
#ifndef ONLINE_JUDGE
    freopen("C:\\Users\\ronish\\OneDrive\\Documents\\in.txt","r",stdin);
#endif
}
 
/* Input opener ends */
 
int n;
int a[800005];
 
struct tree {
	int flag;
	int mx[12];
} t[3000005];
 
int Pow10[5] = {1,10,100,1000,10000};
 
int change(int n,int force,int sz) {
	force = force%sz;
	if ( force == 0 ) return n;
	int nx = n/Pow10[sz-force];
	nx += (n%Pow10[sz-force])*(Pow10[force]);
	return nx;
}
 
void build(int idx,int l,int r) {
	if ( l == r ) {
		t[idx].flag = 0;
		int sz = 0;
		int tmp = a[l];
		while ( tmp > 0 ) sz++,tmp/=10;
		if ( sz == 0 ) sz++;
		t[idx].mx[0] = a[l];
		F(i,1,12) t[idx].mx[i] = change(a[l],i,sz);
		return;
	}
	int nx = idx<<1;
	int mid = (l+r)>>1;
	build(nx,l,mid);
	build(nx+1,mid+1,r);
	t[idx].flag = 0;
	F(i,0,12) {
		t[idx].mx[i] = max(t[nx].mx[i],t[nx+1].mx[i]);
		//cout << t[idx].mx[i] << " ";
	}
	//cout << endl;
}
 
void update(int idx,int l,int r,int from,int to,int force) {
	if ( l == from && r == to ) {
		t[idx].flag = (t[idx].flag+force)%12;
		return;
	}
	int nx = idx<<1;
	int mid = (l+r)>>1;
	if ( t[idx].flag ) {
		t[nx].flag = (t[nx].flag+t[idx].flag)%12;
		t[nx+1].flag = (t[nx+1].flag+t[idx].flag)%12;
		t[idx].flag = 0;
	}
	if ( to <= mid ) update(nx,l,mid,from,to,force);
	else if ( from > mid ) update(nx+1,mid+1,r,from,to,force);
	else { update(nx,l,mid,from,mid,force);
	update(nx+1,mid+1,r,mid+1,to,force); }
	F(i,0,12) t[idx].mx[i] = max(t[nx].mx[ (i+t[nx].flag)%12 ], t[nx+1].mx[ (i+t[nx+1].flag)%12]);
}
 
int query(int idx,int l,int r,int from,int to) {
	if ( l == from && r == to ) {
		return t[idx].mx[t[idx].flag];
	}
	int nx = idx<<1;
	int mid = (l+r)>>1;
	if ( t[idx].flag ) {
		t[nx].flag = (t[nx].flag+t[idx].flag)%12;
		t[nx+1].flag = (t[nx+1].flag+t[idx].flag)%12;
		t[idx].flag = 0;
	}
	int res;
	if ( to <= mid ) res = query(nx,l,mid,from,to);
	else if ( from > mid ) res = query(nx+1,mid+1,r,from,to);
	else res = max(query(nx,l,mid,from,mid),query(nx+1,mid+1,r,mid+1,to));
	F(i,0,12) t[idx].mx[i] = max(t[nx].mx[ (i+t[nx].flag)%12 ], t[nx+1].mx[ (i+t[nx+1].flag)%12]);
	return res;
}
 
int main() {
	input();
	scanf("%d", &n);
	for (int i = 0; i < n; i++) scanf("%d", &a[i]);
	build(1,0,n-1);
	int q; scanf("%d", &q);
	while ( q-- ) {
		int type; scanf("%d", &type);
		int l,r,x;
		if ( type == 0 ) {
			scanf("%d", &l); scanf("%d", &r); scanf("%d", &x);
			update(1,0,n-1,l,r,x);
		} else {
			scanf("%d", &l); scanf("%d", &r);
			printf("%d\n", query(1,0,n-1,l,r));
		}
	}
	return 0;
} 