#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<ctype.h>
#include<string.h>
#include<iostream>
#include<vector>
#include<map>
#include<queue>
#include<stack>
#include<set>
#include<algorithm>
#include<sstream>
using namespace std;

#define READ(a) freopen(a,"r",stdin);
#define WRITE(a) freopen(a,"w",stdout);
#define FOR(i,a,b)  for(int i=(a);i<b;i++)
#define REV(i,a,b)  for(int i=a;i>=b;i--)
#define mem(a,b) memset(a,b,sizeof(a))
#define clr(a) a.clear()
#define mp make_pair
#define pb push_back
#define SZ(a) (int)a.size()
#define all(a) (a).begin(),(a).end()
#define reall(a) (a).rbegin(),(a).rend()
#define fs first
#define sc second
#define PI (2*acos(0.0))
#define ERR (1e-7)
#define EQ(a,b) (fabs(a-b)<ERR)
#define onlyCPP ios_base::sync_with_stdio(0);cin.tie(0)
//#define FOREACH(it,x) for(__typeof((x.begin())) it=x.begin();it!=x.end();it++)
////int rrr[]={1,0,-1,0};int ccc[]={0,1,0,-1};                      //4 Direction
////int rrr[]={1,1,0,-1,-1,-1,0,1};int ccc[]={0,1,1,1,0,-1,-1,-1};  //8 direction
////int rrr[]={2,1,-1,-2,-2,-1,1,2};int ccc[]={1,2,2,1,-1,-2,-2,-1};//Knight Direction

typedef long long ll;
typedef unsigned long long ull; //scanf("%llu",&N);
typedef vector<int>     VI;
typedef vector<string>  VS;
typedef pair<int,int>   PII;
typedef pair<int,PII >  DPII;
typedef vector<pair<int,int> >VPII;
typedef vector<pair<int,pair<int,int> > > VDPII;

const int INF=(1<<29);
const int MAX=800002;

struct abc
{
    int A[13];
};
abc tree[4*MAX];
int n,hit[4*MAX];
int arr[MAX],q[20];

int d(int x, int rt)
{
	int xx=x, l=0;
	while (xx>0) xx/=10, l++;
	xx=x;
	for (int i=l-1; i>=0; i--) q[i]=xx%10, xx/=10;
	int res=0;
	for (int i=rt; i<rt+l; i++)
		res=res*10 + q[i%l];
	return res;
}


void NodeUpdate(int node)
{
    for(int i=0;i<12;i++) tree[node].A[i]=max(tree[node*2].A[i],tree[node*2+1].A[i]);
    return;
}

void build(int node,int left,int right)
{
    if(left==right)
    {
        for(int i=0;i<12;i++)
        {
            tree[node].A[i]=d(arr[left],i);
        }
        return;
    }

    int mid=(left+right)/2;
    build(node*2,left,mid);
    build(node*2+1,mid+1,right);
    NodeUpdate(node);
    return;
}


void refresh(int node,int left,int right)
{
    int x=hit[node];
    if(left!=right)
    {
        hit[node*2]+=hit[node];
        hit[node*2+1]+=hit[node];
    }
    x%=12;

    int tmp[14];
    for(int i=0;i<12;i++)
    {
        tmp[(i-x+12)%12]=tree[node].A[i];
    }
    FOR(i,0,12) tree[node].A[i]=tmp[i];

//    for(int i=0;i<12;i++)
//    {
//        swap(tree[node].A[i],tree[node].A[x]);
//        if(x!=11) x++;
//    }

    hit[node]=0;
    return;
}


void update(int node,int left,int right,int l,int r,int val)
{
    if(l>right || r<left) return;
    if(left>=l && right<=r)
    {
        hit[node]+=val;
        refresh(node,left,right);
        return;
    }
    int mid=(left+right)/2;
    update(node*2,left,mid,l,r,val);
    update(node*2+1,mid+1,right,l,r,val);

    if(hit[node*2]) refresh(node*2,left,mid);
    if(hit[node*2+1]) refresh(node*2+1,mid+1,right);

    NodeUpdate(node);

    return;
}

int query(int node,int left,int right,int l,int r)
{
    if(l>right || r<left)
    {
        return 0;
    }
    if(hit[node]) refresh(node,left,right);

    if(left>=l && right<=r)
    {
        return tree[node].A[0];
    }

    int mid=(left+right)/2;
    int  x=query(node*2,left,mid,l,r);

    int y=query(node*2+1,mid+1,right,l,r);
    return max(x,y);
}


int main()
{
    //READ("IN.txt");
    //WRITE("OUT.txt");


    while(scanf("%d",&n)==1)
    {
        FOR(i,0,n)
        {
            scanf("%d",&arr[i]);
        }

        build(1,0,n-1);
        mem(hit,0);

        int m;scanf("%d",&m);
        for(int i=1;i<=m;i++)
        {
            int id,l,r,f;
            scanf("%d",&id);
            if(id==0)
            {
                //cin>>l>>r>>f;
                scanf("%d %d %d",&l,&r,&f);
                update(1,0,n-1,l,r,f%12);
            }
            else
            {
                //cin>>l>>r;
                scanf("%d %d",&l,&r);
                int ans=query(1,0,n-1,l,r);
                printf("%d\n",ans);
            }
        }
    }

    return 0;
}


/*

3
17 3140 832
8
1 0 2
0 0 2 1
1 1 2
1 0 0
0 0 2 2
1 0 2
0 1 1 1
1 0 2


**/



