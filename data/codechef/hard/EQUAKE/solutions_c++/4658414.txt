#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <vector>
#include <utility>
#include <set>
#include <map>
#include <iostream>
#include <queue>
#include <climits>

using namespace std;

typedef long long LL;

#define PB push_back
#define FRO freopen("in.txt","r",stdin);

#define CLR(arr) memset( (arr),0,sizeof(arr) );
#define NEG(arr) memset( (arr),-1,sizeof(arr) );

#define X first
#define Y second

#define MP make_pair

#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)


typedef pair<int,int> pint;
typedef map<int,int> mint;

#define SIZE 800100

struct node{
    int val[12];
    int cnt ;
    int left,right;
}tree[7*SIZE];
int arr[SIZE];


int ppp[]={1,10,100,1000,10000,100000};

node* merge( node* x,node* y ){
    node *tmp = new node();

    int save1 = (x->cnt)%12;
    int save2 = (y->cnt)%12;

    for (int i=0;i<12;++i){
        tmp->val[i] = max( x->val[save1++],y->val[save2++] );
        if ( save1==12 )save1=0;
        if ( save2==12 )save2=0;
    }
    tmp->cnt = 0;

    tmp->left=x->left;
    tmp->right=y->right;

    return tmp;
}
void merge2(node& tmp ,node& x,node& y ){

    int save1 = (x.cnt)%12;
    int save2 = (y.cnt)%12;
    for (int i=0;i<12;++i){
        tmp.val[i] = max( x.val[save1++],y.val[save2++] );
        if ( save1==12 )save1=0;
        if ( save2==12 )save2=0;
    }
    tmp.cnt = 0;

    tmp.left=x.left;
    tmp.right=y.right;
}

void build( int num ,int le,int ri){
    //printf("%d\n",num);
    tree[num].left=le;
    tree[num].right=ri;
    if ( le==ri ){
        tree[num].val[0]=arr[le];
        tree[num].cnt = 0;
        char tmp[25];
        sprintf(tmp,"%d",arr[le]);

        int len = strlen(tmp);
        for (int i=1;i<12;++i){
            //tmp[len] = tmp[ i-1 ];
            //tmp[++len] = '\0';
            //sscanf(&tmp[i],"%d",&tree[num].val[i]);
            //cout<<"sss "<<&tmp[i]<<endl;
            if ( len > 1 )
                tree[num].val[i] = (tree[num].val[i-1]%ppp[len-1])*10+
                                (tree[num].val[i-1]/ppp[len-1]);
            else
                tree[num].val[i]=tree[num].val[i-1];
        }
    }else{
        build(2*num,le,(le+ri)/2);
        build(2*num+1, (le+ri)/2+1,ri);
        merge2(tree[num],tree[2*num],tree[2*num+1]);
    }
}

int lazy[7*SIZE];


node* query( int num,int ql,int qr ){
    //printf("%d %d %d\n",num,tree[num].left,tree[num].right);
    lazy[num]%= 12;
    if ( lazy[num] != 0 ){
        lazy[2*num]+= lazy[num] ;
        lazy[2*num+1]+= lazy[num] ;
        tree[num].cnt+= lazy[num];
        lazy[num]=0;
    }


    if ( ql <= tree[num].left && qr >= tree[num].right  )return &tree[num];
    else{
        bool lon=false,ron=false;
        if (  ql<= tree[2*num].right )
            lon=true;
        if ( qr>= tree[2*num+1].left  )
            ron=true;
        if ( lon && ron ){
            return merge(query(2*num,ql,qr),query(2*num+1,ql,qr));
        }else if ( lon ){
            return query(2*num,ql,qr);
        }else if ( ron ){
            return query(2*num+1,ql,qr);
        }
    }
}


void update(int num,int ul,int ur,int vv){
    //printf("%d %d %d %d %d %d\n",l,r,lazy[node],tree[node].zero,tree[node].one,tree[node].two);
    lazy[num]%= 12;
    if ( lazy[num]!= 0 ){
        lazy[2*num]+= lazy[num] ;
        lazy[2*num+1]+= lazy[num] ;
        tree[num].cnt+= lazy[num];
        lazy[num]=0;
    }

    if (tree[num].right  <ul || tree[num].left>ur)return ;
    else if (tree[num].left>=ul && tree[num].right <=ur){
        lazy[num]+=vv;
        tree[num].cnt+= lazy[num];
        lazy[num]=0;
        lazy[2*num]+= vv;
        lazy[2*num+1]+= vv ;
    }else{
        update(2*num,ul,ur,vv);
        update(2*num+1,ul,ur,vv);

        merge2( tree[num], tree[2*num],tree[2*num+1] );
    }
}


int n;
const int maxBufSize = (1 << 23);

struct Input
{
	int bufSize, bufEnd, bufPos;
	char buffer[maxBufSize];
	void grabBuffer() {
		bufSize = (maxBufSize); bufPos = 0;
		bufEnd = fread(buffer, sizeof (char), bufSize, stdin);
		buffer[bufEnd] = '\0';
	}
	bool bufEof() {return bufPos == bufEnd;}
	int getChar() {return buffer[bufPos++];}
	void skipWS() {
		while ( ( buffer[bufPos] == '\n' || buffer[bufPos] == '\r' ||
			buffer[bufPos] == ' ' || buffer[bufPos] == '\t'))
			bufPos++;
	}
	int rInt() {
		int n = 0, x; skipWS();
		bool neg=false;
		if (  ( x = getChar() )=='-'  ){
            neg=true;
            x=getChar();
		}

		for (; x <= '9' && x >= '0'; x = getChar())
			n = (n << 3) + (n << 1) + (x - '0');
        if ( neg )return -n;
        else return n;
	}
	inline bool isWhiteSpace(char x) {
		return x == ' ' || x == '\n' || x == '\t';
	}
	char rChar() {skipWS(); return getChar();}
};
struct Output
{
	int bufSize, bufEnd, bufPos;
	char buffer[maxBufSize];
	Output() {bufPos = bufEnd = 0; bufSize = maxBufSize;}
	void print(int x) {
		if (x < 0) {
			print('-'); print(-x); return;
		}
		char temp[1 << 4]; int idx = 0;
		do {
			temp[idx++] = '0' + (x % 10);
			x /= 10;
		} while (x != 0);
		temp[idx] = '\0';
		reverse(temp, temp + idx);
		print(temp);
	}
	inline void print(char ch) {buffer[bufEnd++] = ch;}
	inline void print(const char* s) {while (*s) buffer[bufEnd++] = *s++;}
	inline void print(const string& s) {print(s.c_str());}
	inline void flushBuffer() {buffer[bufEnd] = '\0'; printf("%s", buffer); bufEnd = 0;}
	template <class A, class B>
	void print(const A& a, const B& b) {print(a); print(b);}
	template <class A, class B, class C>
	void print(const A& a, const B& b, const C& c) {print(a); print(b); print(c);}
};

Output output;
Input input;

int main(){

   

    input.grabBuffer();

    n=input.rInt();

    for (int i=1;i<=n;++i){
        arr[i]=input.rInt();
    }

    build(1,1,n);

    int qq;
    qq=input.rInt();

    //int shaon = 0;

    int u,v,t,w;
    while ( qq-- ){
        t=input.rInt();
        u=input.rInt();
        v=input.rInt();

        u++,v++;
        if ( t==1 ){
            node *ans = query(1,u,v);
            output.print(ans->val[ ans->cnt%12 ]);
            output.print('\n');
        }else{
            w=input.rInt();


            update( 1,u,v,w );
        }
    }
    //cout<<shaon<<endl;
    output.flushBuffer();

    return 0;
}
