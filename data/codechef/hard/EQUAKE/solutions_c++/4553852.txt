#include<iostream>
#include<sstream>
#include<cstdio>
#include<cstdlib>
#include<vector>
#include<set>
#include<map>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<string>
#include<queue>
#include<stack>
#include<cctype>
 
using namespace std;
 
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;
typedef map<int,int> mii;
typedef vector<int> vi;
typedef vector< vector<int> > vvi;
typedef vector<char> vc;
typedef vector<bool> vb;
typedef vector<string> vs;
 
#define rep(i,n) for(int i=0;i<n;i++)
#define forup(i,a,b) for(int i=a;i<=b;i++)
#define fordn(i,a,b) for(int i=a;i>=b;i--)
#define all(x) x.begin(),x.end()
#define permute(x) next_permutation(all(x))
#define pb push_back
 
#define debug if(printf("GD "))
#define inf -1
 
/*char* max_str(char* s1, char* s2)
{
    if(atoi(s1)<atoi(s2))
    	return s2;
    return s1;
}*/
 
int arr[800005][12];
int tree[2097153][12];
int seg[2097153];
int lazy[2097153];
int flag[2097153];
/**
 * Build and init tree
 */
void build_tree(int node, int a, int b, int idx) {
  	if(a > b) return; // Out of range
  	
  	if(a == b) { // Leaf node
        tree[node][idx] = arr[a][idx]; // Init value
		return;
	}
	
	build_tree(node*2, a, (a+b)/2, idx); // Init left child
	build_tree(node*2+1, 1+(a+b)/2, b, idx); // Init right child
	
	tree[node][idx] = max(tree[node*2][idx], tree[node*2+1][idx]); // Init root value
	//debug cout<<tree[node*2]<<" "<<tree[node*2+1]<<" "<<tree[node]<<endl;
}
 
void build_tree(int node, int a, int b) 
{
  	if(a > b) return; // Out of range
  	
  	if(a == b) { // Leaf node
        seg[node] = arr[a][0]; // Init value
		return;
	}
	
	build_tree(node*2, a, (a+b)/2); // Init left child
	build_tree(node*2+1, 1+(a+b)/2, b); // Init right child
	
	seg[node] = max(seg[node*2], seg[node*2+1]);// Init root value
	//debug cout<<tree[node*2]<<" "<<tree[node*2+1]<<" "<<tree[node]<<endl;
}

/**
 * Increment elements within range [i, j] with value value
 */
void update_tree(int node, int a, int b, int i, int j, int value) 
{
    if(lazy[node]!=0) { // This node needs to be updated
   		//rotate(tree[node],tree[node]+lazy[node],tree[node]+sizeof(tree[node])-1); // Update it
 
		if(a != b) {
			lazy[node*2] = (lazy[node*2]+lazy[node])%12; // Mark child as lazy
    		lazy[(node*2)+1] = (lazy[node*2+1]+lazy[node])%12; // Mark child as lazy
            //flag[node*2] += flag[node];
            //flag[node*2+1] += flag[node];
		}
        int tmp[12];
        rep(i,12)
            tmp[i] = tree[node][i];
        rep(i,12)
        {
            //tree[node][i] = max(tree[node][(i+lazy[2*node])%12], tree[node][(i+lazy[node*2+1])%12]);
            tree[node][i] = tmp[(i+lazy[node])%12];
        }
        lazy[node] = 0;  
        //lazy[node] = (lazy[node]+flag[node])%12;
        /*rep(i,12)
        {
            tree[node][(i+lazy[node])%12] = max(tree[node][(i+lazy[2*node])%12], tree[node][(i+lazy[node*2+1])%12]);
        } */
        //seg[node] = tree[node][lazy[node]];
   	    //debug cout<<"Updated "<<node<<" "<<" with "<<flag[node]<<" "<<lazy[node]<<" to "<<seg[node]<<endl;
        //flag[node] = 0; // Reset it
  	}
  
	if(a > b || a > j || b < i) // Current segment is not within range [i, j]
		return;
    
  	if(a >= i && b <= j) { // Segment is fully within range
		if(a != b) 
        { // Not leaf node
			lazy[node*2] = (lazy[node*2]+value)%12;
            //flag[node*2]+= value;
			lazy[node*2+1] = (lazy[node*2+1]+value)%12;
            //flag[node*2+1]+= value;
		}
        lazy[node] = (lazy[node]+value)%12;
        //seg[node] = tree[node][lazy[node]];
        int tmp[12];
        rep(i,12)
            tmp[i] = tree[node][i];
        rep(i,12)
        {
            //tree[node][i] = max(tree[node][(i+lazy[2*node])%12], tree[node][(i+lazy[node*2+1])%12]);
            tree[node][i] = tmp[(i+lazy[node])%12];
        } 
        lazy[node] = 0;   
        //debug cout<<"Updated "<<node<<" "<<" with "<<value<<" "<<lazy[node]<<" to "<<tree[node][lazy[node]]<<endl;
        //debug cout<<"Updating "<<node<<" by "<<lazy[node];
        //cout<<" "<<seg[node]<<endl;
        return;
	}
 
	update_tree(node*2, a, (a+b)/2, i, j, value); // Updating left child
	update_tree(1+(node*2), 1+(a+b)/2, b, i, j, value); // Updating right child
 
	rep(i,12)
    {
        //tree[node][(i+lazy[node])%12] = max(tree[node][(i+lazy[2*node])%12], tree[node][(i+lazy[node*2+1])%12]);
        tree[node][i] = max(tree[node*2][i], tree[node*2+1][i]);
    }
    //debug cout<<"Updated "<<node<<" to "<<tree[node][lazy[node]]<<" "<<lazy[node]<<endl;
    //seg[node] = max(seg[node*2], seg[(node*2)+1]); // Updating root with max value
}
 
/**
 * Query tree to get max element value within range [i, j]
 */
int query_tree(int node, int a, int b, int i, int j) 
{
	//debug cout<<a<<" "<<b<<" "<<i<<" "<<j<<" "<<node<<" "<<lazy[node]<<endl;
    if(a > b || a > j || b < i) return inf; // Out of range
 
	if(lazy[node]!=0) { // This node needs to be updated
 
		if(a != b) {
		    lazy[node*2] = (lazy[node*2]+lazy[node])%12;
            //flag[node*2] += flag[node];
			lazy[node*2+1] = (lazy[node*2+1]+lazy[node])%12;
            //flag[node*2+1] += flag[node];
		}
        
        //lazy[node] = (lazy[node]+flag[node])%12;
        /*rep(i,12)
        {
            tree[node][(i+lazy[node])%12] = max(tree[node][(i+lazy[2*node])%12], tree[node][(i+lazy[node*2+1])%12]);
        } */
        //seg[node] = tree[node][lazy[node]];
        int tmp[12];
        rep(i,12)
            tmp[i] = tree[node][i];
        rep(i,12)
        {
            //tree[node][i] = max(tree[node][(i+lazy[2*node])%12], tree[node][(i+lazy[node*2+1])%12]);
            tree[node][i] = tmp[(i+lazy[node])%12];
        }
        lazy[node] = 0;  
		//flag[node] = 0; // Reset it        
	}
 
	if(a >= i && b <= j) // Current segment is totally within range [i, j]
		return tree[node][lazy[node]];
 
	int q1 = query_tree(node*2, a, (a+b)/2, i, j); // Query left child
	int q2 = query_tree(1+(node*2), 1+(a+b)/2, b, i, j); // Query right child
    //debug cout<<q1<<" "<<q2<<endl;
	int res = max(q1, q2); // Return final result
	return res;
}
 
int main()
{
    int n, m, q, l, r, f;
    char str[6];
    memset(lazy,0,sizeof(lazy));
    memset(flag,0,sizeof(flag));
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
    	scanf("%s",str);
        arr[i][0] = atoi(str);
        l = strlen(str);
        for (int j = 1; j < 12; j++) 
        {
            rotate(str,str+1,str+l);
            arr[i][j] = atoi(str);
            //debug cout<<arr[i][j]<<endl;
        }
    }
    rep(i,12)
        build_tree(1,0,n-1,i);
    build_tree(1,0,n-1);
    //debug cout<<seg[3]<<endl;
    scanf("%d",&m);
    while(m--)
    {
    	scanf("%d",&q);
    	if(q==0)
    	{
    		scanf("%d %d %d",&l,&r,&f);
    		update_tree(1,0,n-1,l,r,f);
    	}
    	else
    	{
    		scanf("%d %d",&l,&r);
    		printf("%d\n",(query_tree(1,0,n-1,l,r)));
    	}
    }
    return 0;
}
