#include <iostream>
#include<vector>
#include<cstring>
#include<algorithm>
#include<stdio.h>
#include<climits>
#include<set>
#include<fstream>
#include<cmath>
#include<bitset>
#include<map>

#include<iostream>
#include<queue>
#define test(t) while(t--)
#define s(n) scanf("%d",&n)
#define sl(n) scanf("%lld",&n)


#define rep(i,a,n) for(i=a;i<=n;i++)
#define vi vector<int>
#define vii vector< vector<int> >
#define vpii vector< pair<int,int> >
#define mii map<int,int>
#define pb push_back
#define inf 1000000000LL
#define mp make_pair
#define MOD 1000000009LL
#define lim 1e18
//#define inf 100000000
#define ll  long long
#define gc getchar_unlocked
using namespace std;
int ar[800002];
int len[800002];
int rot[800002][4];
int n;

struct T
{
 int ma[12];
 int shift;
}node[3*800005+1];
vector<int>v[10004];
///preprocess
void preprocess()
{
   int i,j;
   for(i=1;i<=10000;++i)
   {

     int tmp=i;
     int ct=0;
     int div=1;
     while(tmp!=0)
     {
       ct++;
       tmp/=10;
       div=div*10;
     }

     div=div/10;

     for(j=0;j<ct;++j)
     {
      if(j==0)
      v[i].pb(i);
      else
      v[i].pb(((v[i][j-1])%div)*10+v[i][j-1]/div);
     }
   }
   /*for(i=999;i<=1003;++i)
   {
     for(j=0;j<v[i].size();++j)
     cout<<v[i][j]<<" ";
     cout<<endl;
   }*/
   }
///build original tree
void build_tree(int idx,int l,int r)
{
 int mid=(l+r)/2;
 int i;
  if(l==r)
  {
   node[idx].shift=0;
   for(i=0;i<=11;++i)
   node[idx].ma[i]=rot[l][i%len[l]];
  }
  else if(l<r)
  {
     build_tree(2*idx+1,l,mid);
     build_tree(2*idx+2,mid+1,r);
     node[idx].shift=0;
     for(i=0;i<=11;++i)
     {
      node[idx].ma[i]=max(node[2*idx+1].ma[i],node[2*idx+2].ma[i]);
     }

  }
}
///build 12 possible trees
/*void build1_tree(int idx,int l,int r,int fr)
{
 int mid=(l+r)/2;
  if(l==r)
  {
   node1[idx][fr].val=rot[l][fr-(fr/len[l])*len[l]];
   return;
  }
  else if(l<r)
  {
     build1_tree(2*idx+1,l,mid,fr);
     build1_tree(2*idx+2,mid+1,r,fr);
     node1[idx][fr].val=max(node1[2*idx+1][fr].val,node1[2*idx+2][fr].val);

  }
}*/

///update
void update(int idx,int l,int r,int ql,int qr,int fr)
{
  int mid=(l+r)/2;
  int i;
  if(node[idx].shift>0)
   {
     if(l!=r)
     {
       node[2*idx+1].shift=(node[2*idx+1].shift+node[idx].shift)%12;
       node[2*idx+2].shift=(node[2*idx+2].shift+node[idx].shift)%12;
     }
     int tmp[12];
    for(i=0;i<=11;++i)
    tmp[i]=node[idx].ma[i];
    int sh=(node[idx].shift)%12;
    for(i=0;i<=11;++i)
    node[idx].ma[i]=tmp[(i+sh)%12];
     node[idx].shift=0;

   }
  if(ql>r||qr<l||l>r)
  return;
  else if(ql<=l && qr>=r)
  {
     if(l!=r)
     {
       node[2*idx+1].shift=(node[2*idx+1].shift+fr)%12;
       node[2*idx+2].shift=(node[2*idx+2].shift+fr)%12;
     }
     int tmp[12];
    for(i=0;i<=11;++i)
    tmp[i]=node[idx].ma[i];
    int sh=(fr)%12;
    for(i=0;i<=11;++i)
    node[idx].ma[i]=tmp[(i+sh)%12];
     node[idx].shift=0;
  }
  else
  {
     update(2*idx+1,l,mid,ql,qr,fr);
       update(2*idx+2,mid+1,r,ql,qr,fr);
       for(i=0;i<=11;++i)
       {
        node[idx].ma[i]=max(node[2*idx+1].ma[i],node[2*idx+2].ma[i]);
       }
  }
}
/// query
int query(int idx,int l,int r,int ql,int qr)
{
   int mid=(l+r)/2;
   int i;
   if(node[idx].shift>0)
   {
     if(l!=r)
     {
       node[2*idx+1].shift=(node[2*idx+1].shift+node[idx].shift)%12;
       node[2*idx+2].shift=(node[2*idx+2].shift+node[idx].shift)%12;
     }
     int tmp[12];
    for(i=0;i<=11;++i)
    tmp[i]=node[idx].ma[i];
    int sh=(node[idx].shift)%12;
    for(i=0;i<=11;++i)
    node[idx].ma[i]=tmp[(i+sh)%12];
     node[idx].shift=0;

   }
   if(ql>r||qr<l||l>r)
   return INT_MIN;
   else if(ql<=l && qr>=r)
   return node[idx].ma[0];
   else
   {
     return max(query(2*idx+1,l,mid,ql,qr),query(2*idx+2,mid+1,r,ql,qr));
   }
}

int main()
{
preprocess();
int i,tmp,j;
s(n);
for(i=0;i<n;++i)
{
 s(ar[i]);
 int ct=0;
 if(ar[i]>0)
 {
 	len[i]=v[ar[i]].size();
 for(j=0;j<v[ar[i]].size();++j)
 {
  if(j==0)
  rot[i][j]=ar[i];
  else
  {
   rot[i][j]=v[ar[i]][j];
  }
 }
 }
 else
 {
   len[i]=1;
   rot[i][0]=0;
 }
}

build_tree(0,0,n-1);
/*for(i=1;i<=11;++i)
build1_tree(0,0,n-1,i);*/

int q,n1,n2,type,force;
s(q);
while(q--)
{
s(type);
if(type==0)
{
  s(n1);s(n2);s(force);
  if(force>0)
  {
  update(0,0,n-1,n1,n2,force);

  }
}
else
{
   s(n1);s(n2);
   printf("%d\n",query(0,0,n-1,n1,n2));
}

/*for(i=0;i<=4;++i)
  {
   cout<<"i="<<" "<<i<<endl;
   cout<<node[i].shift<<endl;
   for(j=0;j<=11;++j)
   cout<<node[i].ma[j]<<" ";
   cout<<endl;
 }*/
 }
 return 0;
}
