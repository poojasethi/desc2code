#include <stdio.h>
#include <vector>
#include <iostream>
#include <queue>
#include <set>
#include <algorithm>
#include <math.h>
#include <string>
#include <string.h>
#include <stdlib.h>
#include <map>
using namespace std;

//Input macros
#define si(n) scanf("%d",&n)
#define sc(n) scanf("%c",&n)
#define sl(n) scanf("%lld",&n)
#define sf(n) scanf("%lf",&n)
#define ss(n) scanf("%s",n)
#define mem(a,b) memset(a,b,sizeof(a))
#define f(a,b) for(int i=a;i<b;i++)
#define maX(a,b) ((a)>(b)?a:b)
#define ll  long long int
typedef pair<ll, ll> ii;
typedef pair<ii, ll> iii;
#define llu long long unsigned
#define ld long
#define F first
#define S second
int scan_d()    {int ip=getchar_unlocked(),ret=0,flag=1;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;}
ld scan_ld()    {int ip=getchar_unlocked(),flag=1;ld ret=0;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;}
ll scan_ll()    {int ip=getchar_unlocked(),flag=1;ll ret=0;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;}

struct node{
    int a[12];
};
int hh[800057];
 int temp[15];
struct node tree[5*800000];
int lazy[5*800000]={0};
int rotate(int a, int b)
{
    int length=0,i,j,rot;
    int string[6],temp[6],final;
    
    while(a!=0)
    {
        string[length++]=a%10;
        a/=10;
    }
    
    for(j=0,i=length-1;i>=0;i--,j++)
        temp[j]=string[i];
    
    rot=b%length;
    
    for(i=0;i<length;i++)
        string[i]=temp[(i+rot)%length];
    
    final=0;
    
    for(i=0;i<length;i++)
        final=final*10+string[i];
    
    return final;
}

void build(int node,int a,int b){
    if(a==b){
        for(int i=0;i<12;i++){
            tree[node].a[i]=rotate(hh[a],i);
        }
        lazy[node]=0;
        return;
    }
    int mid=(a+b)/2;
    build(2*node, a, mid);
    build(2*node+1, mid+1, b);
    for(int i=0;i<12;i++){
        tree[node].a[i]=maX(tree[2*node].a[i],tree[2*node+1].a[i]);
    }
     lazy[node]=0;
    return;
}
void update(int node,int a,int b,int i ,int j,int val){
    if(lazy[node]!=0){
        for(int i=0;i<12;i++){
            temp[i]=tree[node].a[i];
        }
        for(int i=0;i<12;i++){
            tree[node].a[i]=temp[(i+lazy[node])%12];
        }
        if(a!=b){
            lazy[2*node]+=lazy[node];
            lazy[2*node]%=12;
            lazy[2*node+1]+=lazy[node];
            lazy[2*node+1]%=12;
        }
        lazy[node]=0;
    }
    if(a>b||a>j||b<i)return;
    if(a>=i&&j>=b){
        for(int i=0;i<12;i++){
            temp[i]=tree[node].a[i];
        }
        for(int i=0;i<12;i++){
            tree[node].a[i]=temp[(i+val)%12];
        }
        if(a!=b){
            lazy[2*node]+=val;
             lazy[2*node]%=12;
            lazy[2*node+1]+=val;
             lazy[2*node+1]%=12;
        }
        return;
    }
    int mid=(a+b)/2;
    update(2*node,a,mid,i,j,val);
    update(2*node+1,mid+1,b,i,j,val);
    for(int i=0;i<12;i++){
        tree[node].a[i]=maX(tree[2*node].a[i],tree[2*node+1].a[i]);
    }
    return;
}
int query(int node,int a,int b,int i,int j){
    if(lazy[node]!=0){
        for(int i=0;i<12;i++){
            temp[i]=tree[node].a[i];
         }
        for(int i=0;i<12;i++){
            tree[node].a[i]=temp[(i+lazy[node])%12];
        }
        if(a!=b){
            lazy[2*node]+=lazy[node];
            lazy[2*node]%=12;
            lazy[2*node+1]+=lazy[node];
            lazy[2*node+1]%=12;
        }
        lazy[node]=0;
    }
    if(a>b||i>j||i>b)return 0;
    if(a>=i&&j>=b){
        return tree[node].a[0];
    }
    int mid=(a+b)/2;
    if(j<=mid) return query(2*node,a,mid,i,j);
    else if(i>mid) return query(2*node+1,mid+1,b,i,j);
    else {
        int m1=query(2*node,a,mid,i,j);
        int m2=query(2*node+1,mid+1,b,i,j);
        return maX(m1, m2);
  }
}
int main(int argc, const char * argv[])
{
    int n;
    n=scan_d();
    for(int i=0;i<n;i++){
        hh[i]=scan_d();
        }
    int m,x,y,z,val;
    m=scan_d();
    build(1, 0, n-1);
    while (m--) {
        x=scan_d();
        if(x==1){
            y=scan_d();
            z=scan_d();
            printf("%d\n",query(1, 0, n-1, y, z));
        }
        if(x==0) {
            y=scan_d();
            z=scan_d();
            val=scan_d();
            update(1, 0, n-1, y, z, val);
        }
    }
    
    return 0;
}


