#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <ctime>
#include <cstring>
#include <string>
#include <algorithm>
#include <vector>
#include <stack>
#include <queue>
#include <deque>
#include <set>
#include <map>

#define pb push_back
#define mp make_pair
#define LL long long
#define maxlongint 2147483647

using namespace std;

const int MAXN = 800010;
const int MOD = 95542721;
const int LEN = 12;

struct node
{
	node *Lc, *Rc;
	int v[LEN];
	int L, R, m, p;
	node (int x, int y)
	{
		L = x, R = y, m = L + R >> 1;
		p = 0, Lc = Rc = 0;
		memset(v, 0, sizeof(v));
	}
};

node *root;

int a[MAXN], tmp[LEN], dig[10];
int n, m, flag, x, y, z;

inline int Mod(int x, int MOD)
{
	while (x >= MOD) x -= MOD;
	return x;
}

inline void Update(node *it)
{
	for (int i = 0; i < LEN; i++)
	{
		it -> v[i] = max(it -> Lc -> v[i], it -> Rc -> v[i]);
	}
}

inline void Clear(node *it)
{
	if (!it -> p) return;
	memcpy(tmp, it -> Lc -> v, sizeof(tmp));
	for (int i = 0; i < LEN; i++)
	{
		it -> Lc -> v[i] = tmp[Mod(i + it -> p, LEN)];
	}
	it -> Lc -> p = Mod(it -> Lc -> p + it -> p, LEN);
	memcpy(tmp, it -> Rc -> v, sizeof(tmp));
	for (int i = 0; i < LEN; i++)
	{
		it -> Rc -> v[i] = tmp[Mod(i + it -> p, LEN)];
	}
	it -> Rc -> p = Mod(it -> Rc -> p + it -> p, LEN);
	it -> p = 0;
}

node *Build(int L, int R)
{
	node *it = new node(L, R);
	if (L < R)
	{
		it -> Lc = Build(L, it -> m);
		it -> Rc = Build(it -> m + 1, R);
		Update(it);
	}
	else
	{
		int t = a[L], L0 = 0;
		while (t)
		{
			dig[++L0] = t % 10;
			t /= 10;
		}
		int start = L0;
		for (int i = 0; i < LEN; i++)
		{
			int now = 0;
			for (int j = start; j > 0; j--) now = now * 10 + dig[j];
			for (int j = L0; j > start; j--) now = now * 10 + dig[j];
			it -> v[i] = now;
			start--;
			if (!start) start = L0;
		}
	}
	return it;
}

int Query(node *it, int L, int R)
{
	if (it -> L == L && it -> R == R) return it -> v[0];
	Clear(it);
	if (R <= it -> m) return Query(it -> Lc, L, R);
	if (L > it -> m)  return Query(it -> Rc, L, R);
	return max(Query(it -> Lc, L, it -> m), Query(it -> Rc, it -> m + 1, R));
}

void Modify(node *it, int L, int R, int level)
{
	if (it -> L == L && it -> R == R)
	{
		it -> p += level;
		memcpy(tmp, it -> v, sizeof(tmp));
		for (int i = 0; i < LEN; i++)
		{
			it -> v[i] = tmp[Mod(i + level, LEN)];
		}
		return;
	}
	Clear(it);
	if (R <= it -> m)
	{
		Modify(it -> Lc, L, R, level);
	}
	else if (L > it -> m)
	{
		Modify(it -> Rc, L, R, level);
	}		
	else
	{
		Modify(it -> Lc, L, it -> m, level);
		Modify(it -> Rc, it -> m + 1, R, level);
	}
	Update(it);
}

inline void Init()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
	{
		scanf("%d", &a[i]);
	}
	root = Build(1, n);
}

inline void Work()
{
	scanf("%d", &m);
	
	for (int i = 1; i <= m; i++)
	{
		
		scanf("%d%d%d", &flag, &x, &y);
		x++, y++;
		if (flag == 1)
		{
			printf("%d\n", Query(root, x, y));
		}
		else
		{
			scanf("%d", &z);
			Modify(root, x, y, z);
		}
	}
}

int main()
{
	Init();
	Work();
	return 0;
}