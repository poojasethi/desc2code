#include<iostream>
#include<cstdio>
#include<algorithm>
#define gc getchar_unlocked
#define pc putchar_unlocked
using namespace std;
void scanint(int &x){
	register int c = gc();
	x = 0;
	int neg = 0;
	for(;((c<48 || c>57) && c != '-');c = gc());
	if(c=='-') {neg=1;c=gc();}
	for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}
	if(neg) x=-x;
}
void println_d(int n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=10;char output_buffer[11];output_buffer[10]='\n';do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<11);}
void printint(int n){
	char op[41];
	int size = 40;
	while(n){
		op[size--] = n%10+'0';
		n/=10;
	}
	for(int i=size+1;i<41;i++)
		pc(op[i]);
	pc('\n');
}inline void out(register int N)
{
    register int rev=N, count = 0;
    if (N == 0)
    {
          putchar_unlocked('0');
          putchar_unlocked('\n');
          return ;
    }
    while ((rev % 10) == 0)
    {
          count++;
          rev /= 10;
    }
    rev = 0;
    while (N != 0)
    {
          rev = (rev<<3) + (rev<<1) + N % 10;
          N /= 10;
    }
    while (rev != 0)
    {
          putchar_unlocked(rev%10 + '0');
          rev /= 10;
    }
    while (count--)
          putchar_unlocked('0');
    putchar_unlocked('\n');
    return ;
}
struct node {
	int rot[12];
	int force;
} *tree, *arr;
 
void Build(node * arr, int v, int t1, int t2){
	if (t1 == t2){
		tree[v] = arr[t1];
	}
	else{
		int mid = (t1+t2)/2;
		Build(arr, v<<1, t1, mid);
		Build(arr, v<<1 | 1, mid+1, t2);
		tree[v].force = 0;
		for (int i = 0;i<12;i++)
			tree[v].rot[i] = max ( tree[v<<1].rot[i], tree[v<<1 | 1].rot[i]);
	}
}
int query(int v, int tl, int tr, int l, int r){
	if (l>r)
		return 0;
	if (tl == l && r == tr)
		return tree[v].rot[tree[v].force%12];
	int tm = (tl + tr)/2;
	tree[v<<1].force += tree[v].force;
	tree[v<<1 | 1].force += tree[v].force;
	tree[v].force = 0;
	int l1, l2;
	l1 = query(v<<1, tl, tm, l, min(tm, r));
	l2 = query(v<<1 | 1, tm+1, tr, max(l, tm+1), r);
	for (int i = 0;i<12;i++)
		tree[v].rot[i] = max ( tree[v<<1].rot[(i + tree[v<<1].force)%12], tree[v<<1 | 1].rot[(i + tree[v<<1 | 1].force)%12]);
	return max(l1, l2);
}
 
void Update(int v, int tl, int tr, int l, int r, int f){
	if (l>r)
		return ;
	if (tl == l && tr == r){
		tree[v].force += f;
	}
	else{
		int tm = (tl + tr)/2;
		tree[v<<1].force += tree[v].force;
		tree[v<<1 | 1].force += tree[v].force;
		tree[v].force = 0;
		Update(v<<1 , tl, tm, l, min(r, tm), f);
		Update(v<<1 | 1, tm+1, tr, max (l, tm+1 ), r, f);
		for (int i = 0;i<12;i++)
			tree[v].rot[i] = max ( tree[v<<1].rot[(i + tree[v<<1].force)%12], tree[v<<1 | 1].rot[(i + tree[v<<1 | 1].force)%12]);
	}
}
int main(){
	int N, M;
	scanint(N);
	//node arr[N];
	tree = new node[4 * N + 1];
	arr = new node[N];
	int pow10[5] = {1, 1, 10, 100, 1000};
	for (int i = 0;i<N;i++){
		int temp;
		scanint(temp);
		int len, num;
		num = temp;
		len = 0;
		while(temp>0) temp/=10, len++;
		arr[i].rot[0] = num;
		arr[i].force = 0;
		for (int j = 1;j<12;j++){
			arr[i].rot[j] = arr[i].rot[j-1]/pow10[len] + (arr[i].rot[j-1]%pow10[len])*10;
		}
	}
	scanint(M);
	Build(arr, 1, 0, N-1);
	while(M--){
		int swi;
		scanint(swi);
		if (!swi){
			int l, r, f;
			scanint(l);scanint(r);scanint(f);
			Update(1, 0, N-1, l, r, f);
		}
		else{
			int l, r;
			scanint(l);scanint(r);
			out(query(1, 0, N-1, l, r));
		}
	}
	delete tree;
	delete arr;
	return 0;
}