//Equake.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#define ll long long
#define si(x) scanf("%d",&x);
#define max(a,b) ((a) > (b) ? a : b)
struct num{
	char *c;
	int val[12];
	int size;
};
#define gc getchar_unlocked
int readint()
{
    char c = gc();
    while(c<'0' || c>'9') c = gc();
    int ret = 0;
    while(c>='0' && c<='9')
    {
        ret = (ret<<3) + (ret<<1) + c - 48;
        c = gc();
    }
    return ret;
}
int arr[800004]={0};
struct num tree[4*800005]={0};
int lazy[4*800005];
int temp[12];
char *convert(int x)
{
	char *temp=(char *)malloc(sizeof(char)*7);
	int k=0,y=0;
	int d=10000;
	while(1)
	{
		y=x/d;
		x=x%d;
		d/=10;
		if(y!=0 || d==0) break;
	}
	while(d!=0)
	{
		temp[k++]=y+48;
		y=x/d;
		x=x%d;
		d/=10;
	}
	temp[k++]=y+48;
	temp[k++]='\0';
	return temp;

}
int cal(char *q,int beg,int len)
{
	int res=0;
	int i=0;
	int st=beg;
	int d=pow(10,len-1);
	while(i<len)
	{
		res+=(q[st]-48)*d;
		st=(st+1)%len;
		i++;
		d/=10;
	}
	return res;
}
void build(int node,int a,int b)
{
	int i;
	lazy[node]=0;
	if(a==b)
	{
		tree[node].val[0]=arr[a];
		tree[node].c=convert(arr[a]);
		tree[node].size=strlen(tree[node].c);
		for(i=1;i<tree[node].size;i++)
		{
			tree[node].val[i]=cal(tree[node].c,i,tree[node].size);
			//printf("i=%d val=%d\n",i,tree[node].val[i]);
		}
		for(i=tree[node].size;i<12;i++)
		{
			tree[node].val[i]=cal(tree[node].c,i%tree[node].size,tree[node].size);
			//printf("i=%d val=%d\n",i,tree[node].val[i]);
		}
		return;
	}
	int mid=(a+b)/2;
	build(2*node,a,mid);
	build(2*node+1,mid+1,b);
	for(i=0;i<12;i++) tree[node].val[i]=max(tree[2*node].val[i],tree[2*node+1].val[i]);
	tree[node].size=0;
}
void makelazy(int node,int a,int b)
{
	int k,s=lazy[node];
	for(k=0;k<12;k++) temp[k]=tree[node].val[(s+k)%12];
	for(k=0;k<12;k++) tree[node].val[k]=temp[k];	
	if(a!=b){
		lazy[2*node]=(lazy[2*node]+lazy[node])%12;
		lazy[2*node+1]=(lazy[2*node+1]+lazy[node])%12;
	}
	lazy[node]=0;
}
void update(int node,int a,int b,int i,int j,int v)
{
	int k;
	if(lazy[node]) makelazy(node,a,b);
	if(a>b || a>j || b<i) return;
	if(a>=i && b<=j)
	{		
		for(k=0;k<12;k++) temp[k]=tree[node].val[(v+k)%12];
		for(k=0;k<12;k++) tree[node].val[k]=temp[k];
		if(a!=b){
			lazy[2*node]=(lazy[2*node]+v)%12;
			lazy[2*node+1]=(lazy[2*node+1]+v)%12;
		}
		return;
	}
	int mid=(a+b)/2;
	update(2*node,a,mid,i,j,v);
	update(2*node+1,mid+1,b,i,j,v);
	for(i=0;i<12;i++) tree[node].val[i]=max(tree[2*node].val[i],tree[2*node+1].val[i]);
}
int query(int node,int a,int b,int i,int j)
{
	if(lazy[node]) makelazy(node,a,b);
	if(a>b || a>j || b<i) return 0;
	else if(a>=i && b<=j){
		return tree[node].val[0];
	}
	int mid=(a+b)/2;
	int p1=query(2*node,a,mid,i,j);
	int p2=query(2*node+1,mid+1,b,i,j);
	return max(p1,p2);
}
int main()
{
	int n,m,f,l,r,p,i;
	n=readint();
	for(i=0;i<n;i++)
	{
		arr[i]=readint();
	}
	build(1,0,n-1);
	m=readint();
	for(i=0;i<m;i++)
	{
		p=readint();
		if(p==0)
		{
			l=readint();r=readint();f=readint();
			update(1,0,n-1,l,r,f);
		}
		else
		{
			l=readint();r=readint();
			printf("%d\n",query(1,0,n-1,l,r));
		}
	}
	return 0;
}