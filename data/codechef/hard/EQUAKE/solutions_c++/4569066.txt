/** author : ayush sharma **/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<climits>
#include<algorithm>
#include<string>
#include<sstream>
#include<vector>
#include<queue>
#include<set>
#include<map>
#include<stack>

#define FOR(i,a,b) for(int i=a; i<b; i++)
#define FORr(i,a,b) for(int i=a ; i>=b; i--)
#define pb push_back
#define mp make_pair
#define ub upper_bound
#define lb lower_bound
#define si1(n) scanf("%d",&n)
#define si2(n1, n2) scanf("%d%d",&n1,&n2)
#define si3(n1,n2,n3) scanf("%d%d%d",&n1, &n2, &n3)
#define si4(n1,n2,n3,n4) scanf("%d%d%d%d",&n1, &n2, &n3, &n4)
#define ff first
#define ss second

#define READ(x) freopen(x,"r",stdin)
#define WRITE(x) freopen(x,"w",stdout)
#define show1(a) cout<<a<<"\n"
#define show2(a, b) cout<<a<<"   "<<b<<"\n"
#define show3(a, b, c) cout<<a<<"   "<<b<<"    "<<c<<"\n"
#define show4(a, b, c,d) cout<<a<<"   "<<b<<"    "<<c<<"   "<<d<<"\n"

using namespace std;
typedef long long LL;
typedef pair <int,int> pii;
typedef pair <pii, int> piii;
typedef pair<string,int> psi;
typedef vector<int> vi;
typedef unsigned long long ull;

const int sz = 800005;
int n, m;
int A[sz];

struct node{
    int lazy;
    int ar[12];
    node() : lazy(0) {}
};

node T[3*sz];

vector<int> vec[10000];
void preprocess(){
    FOR(k,0,10000){
        if(k<10) {
            vec[k].pb(k);
        }
        else if(k >= 10 && k < 100){
            int x[2]; x[0] = k;
            int y = k/10, d = k%10;
            x[1] = d*10 + y;
            vec[k].pb(x[0]); vec[k].pb(x[1]);
        }
        else if(k >= 100 && k < 1000){
            int x[3]; x[0] = k;
            int num = x[0], i = 1;
            while(i<3){
                int d = num%10;
                num/=10;
                x[3-i] = d*100 + num;
                num = x[3-i];
                i++;
            }
            FOR(i,0,3) vec[k].pb(x[i]);
        }
        else {
            int x[4]; x[0] = k;
            int num = x[0], i = 1;
            while(i<4){
                int d = num%10;
                num/=10;
                x[4-i] = d*1000 + num;
                num = x[4-i];
                i++;
            }
            FOR(i,0,4) vec[k].pb(x[i]);
        }
    }
}

void init(int root, int st, int en){
    if(st>en) return ;
    if(st == en){
        if(A[st]<10) {
            int k = A[st];
            FOR(i,0,12) T[root].ar[i] = vec[k][i%1];
        }
        else if(A[st] >= 10 && A[st] < 100){
            int k = A[st];
            FOR(i,0,12) T[root].ar[i] = vec[k][i%2];
        }
        else if(A[st] >= 100 && A[st] < 1000){
            int k = A[st];
            FOR(i,0,12) T[root].ar[i] = vec[k][i%3];
        }
        else {
            int k = A[st];
            FOR(i,0,12) T[root].ar[i] = vec[k][i%4];
        }
    }
    else{
        int L = root<<1, R = L|1, mid = (st+en)>>1;
        init(L, st, mid);
        init(R, mid+1, en);
        FOR(i,0,12) T[root].ar[i] = max( T[L].ar[i], T[R].ar[i] );
        return ;
    }
}

void update(int root, int st, int en, int left, int right, int val){
    //if(st>en) return;
    if( T[root].lazy !=0 ){
        int temp[12];
        FOR(i,0,12) temp[i] = T[root].ar[i];
        FOR(i,0,12) T[root].ar[i] = temp[ (i + T[root].lazy)%12 ];
        if(st != en){
            int L = root<<1, R = L|1;
            T[L].lazy += T[root].lazy; T[L].lazy %=12;
            T[R].lazy += T[root].lazy; T[R].lazy %=12;
        }
        T[root].lazy = 0;
    }
    if(st > right || en<left || st>en) return;
    if(st>=left && en<=right){
        int temp[12];
        FOR(i,0,12) temp[i] = T[root].ar[i];
        FOR(i,0,12) T[root].ar[i] = temp[ (i + val)%12 ];
        if(st!=en){
            int L = root<<1, R = L|1;
            T[L].lazy+=val; T[L].lazy %=12;
            T[R].lazy+=val; T[R].lazy %=12;
        }
        return;
    }
    int L = root<<1, R = L|1, mid = (st+en)>>1;
    update(L, st, mid, left, right, val);
    update(R, mid+1, en, left, right, val);
    FOR(i,0,12) {
        T[root].ar[i] = max( T[L].ar[i], T[R].ar[i] );
    }
    return;
}

int query(int root, int st, int en, int left, int right){
    if( st>right || en<left || st>en ) return -1;
    if( T[root].lazy !=0 ){
        int temp[12];
        FOR(i,0,12) temp[i] = T[root].ar[i];
        FOR(i,0,12) T[root].ar[i] = temp[ (i+T[root].lazy)%12 ];

        if( st!= en ){
            int L = root<<1, R = L|1;
            T[L].lazy += T[root].lazy; T[L].lazy %=12;
            T[R].lazy += T[root].lazy; T[R].lazy %=12;
        }
        T[root].lazy = 0;
    }
    if( st>=left && en<=right ){
        return T[root].ar[ (T[root].lazy) ];
    }
    int L = root<<1, R = L|1, mid = (st+en)>>1;
    int x1 = query(L, st, mid, left, right);
    int x2 = query(R, mid+1, en, left, right);
    return max(x1,x2);
}


int main(){
//    READ("input.txt");
    preprocess();
    si1(n);
    FOR(i,0,n) si1(A[i]);
    init(1,0,n-1);
    si1(m);
    FOR(i,0,m){
        int type; si1(type);
        if(type == 0){
            int left, right, F;
            si3(left, right, F);
            update(1,0,n-1,left, right, F%12);
        }
        else{
            int left, right;
            si2(left, right);
            int ans = query(1,0,n-1,left, right);
            cout<<ans<<endl;

        }
    }
    return 0;
}
