#include <iostream>
#include <string>
#include <string.h>
#include <math.h>
#include <time.h>
#include <stdio.h>
#include <utility>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <map>
#include <list>
 
#define FORST(X,S,T) for(int X=S; X<=T; X++)  
#define RFORST(X,S,T) for(int X=S; X>=T; X--)  
#define FOR(X,XB) for(int X=0; X<XB; X++)
#define RFOR(X,XB) for(int X=(XB)-1; X>=0; X--)
#define FORSTL(X,C) for(X=C.begin();X!=C.end();X++)
#define SQR(X) ((X)*(X))
#define MID(X,Y) (((X)+(Y))/2)
#define FILL(X,V) memset(X,V,sizeof(X))
#define FILE_R(X) freopen(X, "r", stdin)  
#define FILE_W(X) freopen(X, "w", stdout)  
#define ERREQ(X,Y) (fabs((X)-(Y))<EPS)
#define DBGL cout << "here" << endl;
#define MIN(X,Y) ((X)<(Y)?(X):(Y))
#define MAX(X,Y) ((X)>(Y)?(X):(Y))
#define INITLISTS {L=0; FILL(adj,-1);}
#define SZ(X) sizeof(X)
const double PI = acos(-1.0);
const double EPS = 1E-9;
const int INF = (int)1E9;
using namespace std;
 
#define MAXN 50005
#define MAXM 400005
 
int N, M, S, T, B;
 
struct bus{
	int u,v,s,e;
	bool operator < (const bus &ano) const{
		return e < ano.e;
	}
} buses[MAXM];
 
 
vector<int> reach[MAXN];
 
bool solve(int w){
	FORST(i, 1, N) reach[i].clear();
	reach[1].push_back(0);
	FOR(i, M){
		const bus &b = buses[i];
		vector<int> &vec = reach[b.u];
		int j = upper_bound(vec.begin(), vec.end(), b.s)-vec.begin()-1;
		if(j>=0 && b.s-vec[j]<=w) reach[b.v].push_back(b.e);
	}
	if(reach[N].size() && reach[N][0]<=B) return 1;
	return 0;
}
 
int main(){
	scanf("%d%d%d", &N, &B, &M);
	FOR(i, M){
		int u,v,s,e;
		scanf("%d%d%d%d", &u, &v, &s, &e);
		buses[i].u = u; buses[i].v = v; buses[i].s = s; buses[i].e = e;
	}
	sort(buses, buses+M);
	int l=0, r=B+1;
	while(l<=r){
		int m = (l+r)/2;
		if(solve(m)){
			r = m-1;
		}else{
			l = m+1;
		}
	}
 
	if(r==B+1) printf("-1\n");
	else printf("%d\n", l);
 
	return 0;
}  