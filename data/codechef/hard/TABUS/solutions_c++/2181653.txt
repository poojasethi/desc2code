//http://www.codechef.com/problems/TABUS

#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;

const int MAX=300000;

struct bus
{
	int u,v;
	int s,e;
	void read()
	{
		scanf("%d%d%d%d",&u,&v,&s,&e);
	}
	bool operator<(const bus &b) const
	{
		return e < b.e;
	}
}b[MAX];


int main()
{
	int N,T,M,i;
	int L,R;
	scanf("%d%d%d",&N,&T,&M);
	
	// read all input u,v,s,e
	for(i=0;i<M;i++)
		b[i].read();
	// sort given input by there arival time
	sort(b,b+M);
	// let L be the impossible waiting time;
	// R be the possible waiting time
	L=-1;
	R=T+1;
	while(L+1 < R)
	{
		int mid=(L+R)/2;
		//d[u] contain all possibe arrival time at bus station by any anothr bus station;
		vector<vector<int> >d(N+1);
		d[1].push_back(0);
		for(i=0;i<M;i++)
		{
			int u=b[i].u;
			int v=b[i].v;
			int s=b[i].s;
			int e=b[i].e;
			// we seek for the latest bus that arrive at u bus station <=s
			int j=upper_bound(d[u].begin(),d[u].end(),s)-d[u].begin()-1;
			
			// j < 0 when no bus arrive at u and d[j][u]+mid < s when arrival time and upper bond of waiting time < waiting time at bus sattion ;
			
			if(j < 0 ||d[u][j]+mid < s)
				continue;
			// otherwise we add e to the list d[v]
			// as it is possible to arrive at v at time e
			d[v].push_back(e);
			//d[v] remain sorted;
		}
		//check wheter mid is good or bad
		if(d[N].size() && d[N][0] <= T)
			R=mid;  // there is posibility to reach N at mid time
		else
			L=mid; //there is no possibility to reach at N b/w mid
	}
	if(R > T)	R=-1;
	printf("%d\n",R);
}
