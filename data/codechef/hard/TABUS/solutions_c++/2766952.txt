#include <cstdio>
#include <deque>
#include <algorithm>

struct Bus {
	int x, y;
	int t1, t2;
	bool operator< (Bus const & o) const {
		return t1 < o.t1;
	}
} edge[100005];

int perm[100005];
bool by_endtime(int i, int j) { return edge[i].t2 < edge[j].t2; }

struct t_and_v {
	int t;
	int v;
	t_and_v (int t, int v) : t (t), v (v) { }
};

const int infInt = 1010101010;

int opt[100005]; // i -> min. wait time over all sequences ending with bus #i
inline int T(int i) { return edge[i].t2; }
inline int V(int i) { return opt[i]; }
int memory[100005];
int * ql[50005], * qr[50005];
int latest[50005];
inline void push(int i) {
	int k = edge[i].y;
	int t = T(i), v = V(i);
	if (ql[k]!=qr[k] and T(*(qr[k]-1)) == t and V(*(qr[k]-1)) <= v) { return; }
	while (ql[k]!=qr[k] and V(*(qr[k]-1)) >= v) qr[k] --;
	*qr[k] = i; qr[k] ++;
}
inline int get(int k, int t) {
	while (ql[k]!=qr[k] and T(*ql[k]) + V(*ql[k]) < t) {
		latest[k] = T(*ql[k]);
		ql[k] ++;
	}
	int answer = std::min(infInt, t - latest[k]);
	if (ql[k]!=qr[k]) answer = std::min(answer, V(*ql[k]));
	return answer;
}

int main() {
	int n, T, ne;
	scanf("%d%d%d", &n, &T, &ne);
	for (int i = 0; i < ne; i ++) {
		int u, v, s, e;
		scanf("%d%d%d%d", &u, &v, &s, &e);
		edge[i].x = u;
		edge[i].y = v;
		edge[i].t1 = s;
		edge[i].t2 = e;
		perm[i] = i;
	}
	std::sort(edge, edge + ne);
	std::sort(perm, perm + ne, by_endtime);
	static int need[50005];
	for (int i=1;i<=n;i++)latest[i]=-infInt;
	for (int i=1;i<=n;i++)need[i]=0;
	for (int edgeID=0; edgeID<ne; edgeID++) {
		need[edge[edgeID].y] ++;
	}
	int ptr = 0;
	for (int i=1;i<=n;i++) {
		ql[i] = qr[i] = memory + ptr;
		ptr += need[i];
	}
	latest[1] = 0;
	int answer = infInt;
	int perm_ptr=0;
	for (int edgeID=0; edgeID<ne; edgeID++) {
		Bus & b (edge[edgeID]);
		while (perm_ptr<ne and edge[perm[perm_ptr]].t2<=b.t1) { int i=perm[perm_ptr]; push(i); perm_ptr++; }
		opt[edgeID] = get(b.x, b.t1);
		if (b.y == n and b.t2 <= T) {
			answer = std::min(answer, opt[edgeID]);
		}
	}
	if (answer > T) puts("-1"); else printf("%d\n", answer);
}
