#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;

const int maxM = 300000;

struct bus
{
	int u,v;
	int s,e;
	void read() {
		scanf("%d%d%d%d",&u,&v,&s,&e);
	}
	bool operator<(const bus &b) const {
		return e < b.e;
	}
} b[maxM];

int main()
{
	int N, T, M;
	scanf("%d%d%d",&N,&T,&M);
	// input buses
	for(int i=0;i<M;i++)
		b[i].read();
	sort(b,b+M); // sort buses by arrival time

	// binary search or the answer
	// L is impossible waiting time
	// R is possible and will be the answer in the end
	int L = -1;
	int R = T + 1;
	while(L+1<R)
	{
		// we check the waiting time "mid" now
		int mid = (L+R)/2;
		// d[u] will contain all possible moments of time we could reach bus station u
		vector<vector<int> > d(N+1);
		d[1].push_back(0); // at time 0 we at station 1
		// we process buses in order of arrival time
		for(int i=0;i<M;i++)
		{
			int u = b[i].u;
			int v = b[i].v;
			int s = b[i].s;
			int e = b[i].e;
			// we seek for the latest bus that arrive at u at time <=s
			int j = upper_bound(d[u].begin(), d[u].end(), s) - d[u].begin() - 1;
			// if waiting time > mid we skip this bus
			if (j<0 || d[u][j]+mid<s) continue;
			// otherwise we add e to the list d[v]
			// as it is possible to arrive at v at time e
			d[v].push_back(e);
			// d[v] remains sorted since b was so
		}
		// if station N is reachable and the earliest time is <=T
		// the mid is good otherwise it is bad
		if(d[N].size() && d[N][0]<=T)
			R = mid;
		else
			L = mid;
	}
	// if R > T it is not possible to reach N with any gap
	if(R > T) R = -1;
	printf("%d\n",R);
	return 0;
}
