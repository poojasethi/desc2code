
//		 USING BIT

#include<bits/stdc++.h>
using namespace std;

//    GC  

#define in(a) scanf("%d",&a)
#define inll(a) scanf("%lld",&a)
#define ins(a) scanf("%s",a)
#define out(a) printf("%d\n",a)
#define fo(i,n) for(i=1;i<=n;i++)

//binary indexed trees for rows and coloumns	
int row1[500100]={0},row0[500100]={0},col1[500100]={0},col0[500100]={0};
	
int n,q;
	
void change(int *bit,int idx,int data)
{
	while(idx<=q)
	{
		bit[idx]+=data;
		idx+=(idx & -idx);
	}
}

int ans(int *bit,int idx)
{
	int s=0;
	
	while(idx>0)
	{
		s+=bit[idx];
		idx-=(idx & -idx);
	}
	
	return s;
}

int trow[500100][2]={0};
int tcol[500100][2]={0};

int main()
{
	int i,idx,val;
	
	char str[20];
	
	in(n);
	
	in(q);
	
	fo(i,q)
	{
		ins(str);  
		
		
		if(str[0]=='R')
		{
			if(str[3]=='S')
			{
				// ROWSET 
				
				in(idx);	in(val);
				
				// check if this row is previously changed , to avoid repetitions
				
				if(trow[idx][1]>0 || trow[idx][0]>0)
				{
					if(trow[idx][1]>trow[idx][0])
						change(row1,trow[idx][1],-1);
					else
						change(row0,trow[idx][0],-1);
				}
				
				// now , add this timestamp 
				
				if(val==0)    change(row0,i,1);   else  change(row1,i,1);
				
				trow[idx][val]=i;
			}
			
			else
			{
				// ROWQUERY
				
				in(idx);
				
				if(trow[idx][1]>trow[idx][0])
				{
					
					int t=trow[idx][1];
					
					// as this row was previously set to 1 , we find 
					// if any colset queries changed it to 0
					
					int zeros = ans(col0,q) - ans(col0,t);
					
					out(zeros);
				}
				
				else
				{
						// find no. of ones due to colset queries..
					
					int t=trow[idx][0];
					
					int ones  =  ans(col1,q) - ans(col1,t);
					
					// the answer is n - no. of ones;
					
					out(n-ones);
				}
				
			}
			
		}
		
		
		else if(str[0]=='C')
		{
			if(str[3]=='S')
			{
				//	COLSET
				
				in(idx);   in(val);
				
				if(tcol[idx][1]>0 || tcol[idx][0]>0)
				{
					if(tcol[idx][1]>tcol[idx][0])
						change(col1,tcol[idx][1],-1);
					else
						change(col0,tcol[idx][0],-1);
				}
				
				if(val==0)   change(col0,i,1);  else  change(col1,i,1);
				
				tcol[idx][val]=i;
			}
			
			else
			{
				//  COLQUERY
				
				in(idx);
				
				if(tcol[idx][1]>tcol[idx][0])
				{
					int t=tcol[idx][1];
					
					// as this coloumn was previously set to 1 , we find 
					// if any rowset queries changed it to 0
					
					int zeros = ans(row0,q) - ans(row0,t);
					
					out(zeros);
				}
				
				else
				{
					
					int t=tcol[idx][0];
					
					// no of ones due to future rowset queries
					
					int ones = ans(row1,q) - ans(row1,t);
					
					out(n-ones);
				}
				
			}
		}
			

	}
	
	return 0;
}