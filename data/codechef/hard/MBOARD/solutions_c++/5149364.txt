#include <cstdio>
#include <cstring>
#include <utility>
#include <algorithm>
#define X first
#define Y second
#define REP(i,n) for (int i=1;i<=n;++i)
#define FOR(i,n) for (__typeof(n.begin)i=n.begin();i!=n.end();++i)
using namespace std;

const int MAXN=1000100;
int n,m;
char s[11];
int ans[MAXN];
int a[MAXN][4];
int last[MAXN];
int t[2][MAXN];
int tp,pp,tv,vv;
pair< pair<int,int>,int > v[MAXN];
pair< pair<int,int>,pair<int,int> > p[MAXN];


int Query(int w,int x) {
	int ret=0;
	for (;x;x-=(x&(-x))) ret+=t[w][x];
	return ret;
}

void Modify(int w,int x,int d) {
	for (;x<=m;x+=(x&(-x))) t[w][x]+=d;
}

void Work(int w) {
	memset(v,0,sizeof(v));
	memset(p,0,sizeof(p));
	memset(t,0,sizeof(t));
	tv=tp=0;

	memset(last,0,sizeof(last));
	REP(i,m) if (a[i][0]==w) {
		if (a[i][1]) last[a[i][2]]=i;
		else {
			v[++tv].X.X=last[a[i][2]]+1;
			v[tv].X.Y=i;
			v[tv].Y=a[last[a[i][2]]][3];
		}
	}

	memset(last,0,sizeof(last));
	REP(i,m) if (a[i][0]!=w && a[i][1]) {
		p[++tp].X.X=i;
		p[tp].X.Y=i;
		p[tp].Y.X=a[i][3];
		p[tp].Y.Y=1;
		if (last[a[i][2]]) {
			p[++tp].X.X=last[a[i][2]];
			p[tp].X.Y=i;
			p[tp].Y.X=a[last[a[i][2]]][3];
			p[tp].Y.Y=-1;
		}
		last[a[i][2]]=i;
	}
	sort(v+1,v+tv+1);
	sort(p+1,p+tp+1);

/*
	REP(i,tv) printf("%d %d %d\n",v[i].X.X,v[i].X.Y,v[i].Y);
	REP(i,tp) printf("%d %d %d %d\n",p[i].X.X,p[i].X.Y,p[i].Y.X,p[i].Y.Y);
*/


	REP(i,tp) Modify(p[i].Y.X,p[i].X.Y,p[i].Y.Y);
	vv=1,pp=1;
	REP(i,m) {
		for (;v[vv].X.X==i;++vv) {
			if (v[vv].Y)
				ans[v[vv].X.Y]=Query(0,v[vv].X.Y);
			else
				ans[v[vv].X.Y]=n-Query(1,v[vv].X.Y);
		}
		for (;p[pp].X.X==i;++pp)
			Modify(p[pp].Y.X,p[pp].X.Y,-p[pp].Y.Y);
	}
}

// 0 RC
// 1 QS

int main() {
//	freopen("1.in","r",stdin);
	scanf("%d%d",&n,&m);
	REP(i,m) {
		scanf("%s",s);
		if (s[0]=='R') a[i][0]=0;
		else a[i][0]=1;
		if (s[3]=='Q') {
			a[i][1]=0;
			scanf("%d",&a[i][2]);
		} else {
			a[i][1]=1;
			scanf("%d%d",&a[i][2],&a[i][3]);
		}
	}
	Work(0);
	Work(1);
	REP(i,m) if (!a[i][1]) printf("%d\n",ans[i]);
	return 0;
}
