
// START BOILERPLATE HEADER
// Useful Includes
// <vector> <list> <map> <set> <deque> <queue> <stack> <bitset>
// <algorithm> <functional> <numeric> <utility> <sstream> <iomanip>
// <ctime> <cassert>

#include <iostream>
#include <fstream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>

using namespace std;

// Useful Constants
#define PI  3.141592653589793238462643383279502884197169399375105820974944592307816406286
#define E   2.718281828459045235360287471352662497757247093699959574966967627724076630353               

//Useful Macros
#define MAX(i,j)            ((i)>(j)?(i):(j))
#define MIN(i,j)            ((i)<(j)?(i):(j))
#define ABS(i)              ((i)<0?-(i):(i))
#define REP(i,a)            for((i)=0;(i)<(a);(i)++)
#define FOR(i,a,b)          for((i)=a;(i)<(b);(i)++)
#define FORE(i,a,b)         for((i)=a;(i)<=(b);(i)++)
#define EACH(it,b)          for(__typeof((b).begin())it=(b).begin();it!=(b).end();it++)
#define CLRI(ptr,n)         memset((ptr),0,(n)*sizeof(int))
#define CLRC(ptr,n)         memset((ptr),0,(n)*sizeof(char))

//Useful Typedefs
typedef long long ll;
typedef unsigned long long ull;

//Fast stdin class (my windows g++ doesn't have getchar_unlocked, so this will have to do)
class FastInput {
	private:
        static const int BUFSIZE = 1<<16;
        static char buffer[];
        char *bufpos;
        char *bufend;
        bool debug_mode;
        ifstream mystream;
    public:
        inline void getmore();
		inline void getint(int &n);
		inline void getull(ull &n);
		inline void getstr(char k[]);
		FastInput()                     { debug_mode = false; getmore(); }
		FastInput(const char *filename) { debug_mode = true; mystream.open(filename); getmore(); }
		inline void nextchar(char &c)   { c = *bufpos++; if (bufpos==bufend) getmore(); }
};

char FastInput::buffer[FastInput::BUFSIZE];

inline void FastInput::getmore() {
    bufpos = buffer;
#ifdef ONLINE_JUDGE
    bufend = buffer + read(0, buffer, BUFSIZE);
#else
	if (debug_mode) { mystream.read(buffer,BUFSIZE); bufend = buffer + mystream.gcount(); }
	else            {      cin.read(buffer,BUFSIZE); bufend = buffer +      cin.gcount(); }
#endif
}

inline void FastInput::getint(int &n) {
    n = 0; register char ch; bool neg = false; nextchar(ch);
    while (ch < '0' || ch > '9')   { if (ch=='-') neg = true; nextchar(ch); }
	while (ch >= '0' && ch <= '9') { n=(n<<3)+(n<<1)+ch-'0'; nextchar(ch); }
    if (neg) n = -n;
}

inline void FastInput::getull(unsigned long long &n) {
    n = 0; register char ch; nextchar(ch);
    while (ch < '0' || ch > '9')   { nextchar(ch); }
	while (ch >= '0' && ch <= '9') { n=(n<<3)+(n<<1)+ch-'0'; nextchar(ch); }
}

inline void FastInput::getstr (char k[]) {
    register int cnt = 0; register char ch; nextchar(ch);
    while (( ch < 'a' || ch > 'z' ) && ( ch < 'A' || ch > 'Z' )) nextchar(ch);
    while ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) { k[cnt++] = ch; nextchar(ch); }
    k[cnt] = '\0';
}


class FastOutput {
	private:
        static const int BUFSIZE = 1<<16;
        static char buffer[];
        char *bufpos;
        char *bufend;

    public:
		inline void flush();
		inline void putll(ll n,char c);
		FastOutput()  { bufpos = buffer; bufend = bufpos + BUFSIZE; }
		~FastOutput() { flush(); }
		inline void wrchar(char c) { *bufpos++ = c;	if (bufpos == bufend) flush(); }
        inline void putstr(char *k) { while (*k != 0) wrchar(*k++); }
};

char FastOutput::buffer[FastOutput::BUFSIZE];

inline void FastOutput::flush() {
	if (bufpos == buffer) { return; }
#ifdef ONLINE_JUDGE
    write(1, buffer, bufpos-buffer);
#else
	cout.write(buffer,bufpos-buffer);
#endif
	bufpos = buffer;
}

inline void FastOutput::putll(ll n, char c) {
	char buf[32]; bool neg = false; char *bufptr; bufptr = buf + 31; *bufptr-- = 0; if (c > 0) *bufptr-- = c;
	if (n == 0) *bufptr-- = '0';
	if (n < 0) { neg = true; n = -n; }
	while (n>0) { int r = n % 10; *bufptr-- = '0'+r; n /=10; }
	if (neg) { *bufptr-- = '-'; }
	putstr(++bufptr);
}

ll analyze( ll mult, int m, int n ) {
	ll lower = mult * m / 2;
	ll upper = mult * m - lower;
	if (lower == upper) { lower--; upper++; }
	return MIN(lower,n-upper+1);
}


/////////////////////////////////////////////////////////////////////////////////////
// SOLUTION STARTS HERE
/////////////////////////////////////////////////////////////////////////////////////
ll solve (int n, int m) {
	ll maxmult = (ll) n * 2 - 1;
	ll nummult = maxmult/m;
	// We treat cases where nummult = 0, 1,2,3 separately.  After that, we find a general case for n >= 4
	if (nummult == 0) { return (ll) 0; }
	ll seqm_numelem = analyze(nummult,m,n);
	if (nummult == 1) { return seqm_numelem; }
	ll seq1_numelem = analyze(1,m,n);
	if (nummult == 2) { return seqm_numelem + seq1_numelem; }
	ll seqmm1_numelem = analyze(nummult-1,m,n); 
	if (nummult == 3) { return seqm_numelem + seq1_numelem + seqmm1_numelem; }
	ll seq2_lower = 2 * m / 2;
	ll seq2_numelem = analyze(2,m,n);
	// We now have 4 arithmetic sequences, each with common difference m that we have to sum up
	// Recall t + (t+d) + (t+2d) + ... + (t + (n-1)d) = (n * t) + (n-1)(n)/2 * d
	// if nummult % 4 == 0, all 4 sequences get the same number of elements 
	// if nummult % 4 == 1, the seqm gets the extra element
	// if nummult % 4 == 2, seqm and seq1 get the extra elements
	// if nummult % 4 == 3, seqm and seq1 and seqmm1 get the extra elements
	ll k = nummult / 4;
	ll base = k * (k-1) / 2 * m * 4 + k * (seqm_numelem + seq1_numelem + seqmm1_numelem + seq2_numelem);
	if (nummult % 4 == 0) { return base ; }
	if (nummult % 4 == 1) { return base + analyze((nummult+1)/2,m,n) ; }
	if (nummult % 4 == 2) { return base + seqm_numelem + seq1_numelem + 2 * k * m; }
	if (nummult % 4 == 3) { return base + seqm_numelem + seq1_numelem + 2 * k * m + analyze((nummult+1)/2,m,n); }
	return 0;
}

int main() {
    FastInput fi;
	//FastInput fi("DIVPAIR.in3");
	FastOutput fo;
	int n,m;
    int t; fi.getint(t);
    while (t--) {
		fi.getint(n); fi.getint(m);
		fo.putll(solve(n,m),'\n');
    }
	fo.flush();
	return(0);
}
