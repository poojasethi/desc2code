#!/usr/bin/python

import sys

# |A - B + x * C - y * D| -> min
# Find smallest m such that 
# A - B + x * C - y * D = +/- m

# https://en.wikibooks.org/wiki/Algorithm_Implementation/Mathematics/Extended_Euclidean_algorithm#Iterative_algorithm
def xgcd(b, n):
    x0, x1, y0, y1 = 1, 0, 0, 1
    while n != 0:
        q, b, n = b / n, n, b % n
        x0, x1 = x1, x0 - q * x1
        y0, y1 = y1, y0 - q * y1
    return  b, x0, y0

# solving LDE (1) C * x - D * y = B - A +/- m
def solve(A, B, C, D):
    g, x0, y0 = xgcd(C, -D)

    # for any k, f(k) yields an m such that (x0 * k, y0 * k)
    # is a solution of (1)
    def f(k):
        return A + x0 * k * C - (B + y0 * k * D)
        
    # this function is monotonic in k
    # find where it crosses zero.
    ilow, ihigh = -10**18, 10**18
    while ilow + 1 < ihigh:
        m = (ilow + ihigh)/2
        if f(m) > 0:
            ilow, ihigh = m, ihigh
        else:
            ilow, ihigh = ilow, m

    return min(abs(f(ilow)), abs(f(ihigh)))

def R(): return map(int, raw_input().split())

T = R()[0]
for i in range(T):
    A, B, C, D = R()
    print solve(A, B, C, D)
