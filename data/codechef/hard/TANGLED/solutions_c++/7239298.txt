#include <bits/stdc++.h>

using namespace std;

#define ll long long
#define MOD 1000000009
#define INF (int)1e9
#define s(n) scanf("%d", &n)
#define sc(n) scanf("%c", &n)
#define sl(n) scanf("%lld", &n)
#define sf(n) scanf("%f", &n)
#define ss(n) scanf("%s", n);
#define all(a) a.begin(), a.end()
#define pii pair<int, int>
#define fi first
#define se second
#define pb push_back
#define mp make_pair
#define sq(x) ((x)*(x))
#define mset(x,v) memset(x,v,sizeof(x))
#define PI 3.1415926535897932384626

struct suffix {
    int id;
    int rank[2];
};

int ans[2000005], lcp[2000005];

bool operator <(suffix a, suffix b)
{
    return (a.rank[0] == b.rank[0])? (a.rank[1] < b.rank[1] ?1: 0):
               (a.rank[0] < b.rank[0] ?1: 0);
}

void buildSuffix(string s)
{
    int n = s.size(), i;
    suffix suf[n];

    for (i = 0; i < n; i++) {
        suf[i].id = i;
        suf[i].rank[0] = s[i];
        if (i + 1 < n)
            suf[i].rank[1] = s[i+1];
        else
            suf[i].rank[1] = -1;
    }

    sort(suf, suf + n);

    int ind[n], j;
    for (i = 4; i < 2*n; i = i*2) {
        int r = 0;
        int pre = suf[0].rank[0];
        suf[0].rank[0] = r;
        ind[suf[0].id] = 0;

        for (j = 1; j < n; j++) {
            if (suf[j].rank[0] == pre && suf[j].rank[1] == suf[j-1].rank[1]) {
                pre = suf[j].rank[0];
                suf[j].rank[0] = r;
            }
            else {
                pre = suf[j].rank[0];
                suf[j].rank[0] = ++r;
            }
            ind[suf[j].id] = j;
        }

        for (int j = 0; j < n; j++) {
            int nextindex = suf[j].id + i/2;
            suf[j].rank[1] = (nextindex < n)?
                                  suf[ind[nextindex]].rank[0]: -1;
        }

        sort(suf, suf + n);
    }

        for (i = 0; i < n; i++)
            ans[i] = suf[i].id;
        //ans stores the sorted prefixes
        //ans[0] is the starting index of lexographically first prefix

}

void lcpfun(string s)
{
    int n = s.size();
    int pos[n], i;
    for (i = 0; i < n; i++)
        pos[ans[i]] = i;

    lcp[0] = 0;
    int h;
    for (i = 0, h = 0; i < n; i++) {
        if (pos[i] > 0) {
            int j = ans[pos[i]-1];
            while (i + h < n && j + h < n && s[i+h] == s[j+h]) h++;
            lcp[pos[i]] = h;
            if(h) h--;
        }
    }

    //lcp contains the longest common prefixes of string i & i-1 in suffix array
}

ll sum[2000005], dp[2000005];

int main()
{
    int t;
    s(t);

    string s1, s2, s;
    int L;
    while (t--) {
        cin >> s1 >> s2 >> L;
        s = s1 + '#' + s2;

        int l1 = s1.size();
        int l2 = s2.size();
        int n = l1 + l2 + 1, i;

        buildSuffix(s);
        lcpfun(s);
        mset(sum, 0);
        mset(dp, 0);

        for (i = 0; i < n; i++) {
            if (i > 0)
                sum[i] = sum[i-1];
            if (ans[i] > l1) sum[i]++;

        }

        stack<pii> ss;
        for(int i = 0; i < n; ++i){
            int num = lcp[i];
            while(!ss.empty() and ss.top().fi > num){
                int temp = ss.top().first;
                ss.pop();

                if (!ss.empty() and ss.top().fi == temp)
                    continue;

                int en = i-1;
                int st = (!ss.empty() ? ss.top().se : 0);

                ll two = sum[en] - (st != 0 ? sum[st-1] : 0);
                ll one = (en-st+1) - two;
                ll pairs = two*one;

                dp[temp] += pairs;

                int rem = 0;
                if (!ss.empty()) rem = max(rem,ss.top().fi);
                rem = max(rem,num);
                dp[rem] -= pairs;
            }

            ss.push(mp(lcp[i],i));
        }

        while(!ss.empty()){
            int temp = ss.top().fi;
            ss.pop();

            if (!ss.empty() and ss.top().fi == temp)
                continue;

            int en = n-1;
            int st = (!ss.empty() ? ss.top().se : 0);

            ll two = sum[en] - (st != 0 ? sum[st-1] : 0);
            ll one = (en-st+1) - two;
            ll pairs = two*one;

            //dbg("range is",st,en,temp,one,two);
            dp[temp] += pairs;

            int rem = 0;
            if (!ss.empty()) rem = max(rem,ss.top().fi);
            dp[rem] -= pairs;
            //dbg("subtracted",rem,pairs);
        }

        ll tmp = 0;
        for (i = n; i >= 0; i--) {
            tmp += dp[i];
            dp[i] = tmp;
        }

        for (i = 1; i <= L; i++)
            printf("%lld ", dp[i]);
        printf("\n");
    }

    return 0;
}
