#include <algorithm>
#include <cmath>
#include <cstdio>
#include <deque>
#include <iomanip>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <stdlib.h>
#include <string>
#include <vector>

using namespace std;

#define LL long long
#define LD long double

#define VI vector<int>

#define sd(x) x = GetNextInt()
#define slld(x) scanf("%lld",&x)

#define PB push_back
#define MP make_pair
#define F first
#define S second
#define PII pair<int,int>
#define PPII pair< PI , PI >

#define INF 2000000009

#if 0
#define get getchar_unlocked
#else
#define get getchar
#endif

int next_int;
char in_char;

inline int GetNextInt(){
    in_char = ' ';
    while((in_char < '0') || (in_char > '9')){
        in_char = get();
    }
    next_int = 0;
    while((in_char >= '0') && (in_char <= '9')){
        next_int *= 10;
        next_int += in_char - 48;
        in_char = get();
    }
    return next_int;
}

LL PowerMod(LL base,LL power,LL mod){
    LL ret = 1;
    if(base >= mod){
        base %= mod;
    }
    while(power > 0){
        if((power & 1) == 1){
            ret *= base;
            if(ret >= mod){
                ret %= mod;
            }
        }
        power >>= 1;
        base *= base;
        if(base >= mod){
            base %= mod;
        }
    }
    return ret;
}

/* Main Code */

#define sh pair< pair< int , int > , int >
#define MAXN 1000000
#define Max(a,b) (a>b?a:b)
set<sh> possible;
int d[MAXN],c[MAXN];
LL sum[MAXN];
sh arr[MAXN];
int D,i,r,n;

inline void solve()
{
    sd(n);sd(D);

    for(int i = 1;i <= n;i++){
        sd(d[i]);sd(c[i]);
    }

    sum[0] = 0;
    c[0] = 0;
    d[0] = 0;

    for(i = 1;i <= n;i++){
        sum[i] = sum[i-1] + d[i];
    }

    arr[n].F.F = 0;
    arr[n].F.S = 0;
    arr[n].S = n;

    possible.clear();
    possible.insert(arr[n]);

    r = n;

    for(i = n-1;i >= 0;i--)
    {
        while(r > i)
        {
            //cout<<i<<" "<<r<<" "<<sum[r] - sum[i]<<" "<<D<<endl;
            if(sum[r] - sum[i] <= D)
            {
                break;
            }
            possible.erase(arr[r]);
            r--;
        }

        arr[i] = (*possible.begin());
        arr[i].F.F = arr[i].F.F + 1;
        arr[i].F.S = Max(c[i],arr[i].F.S);
        arr[i].S = i;

        //cout<<arr[i].F.F<<" "<<arr[i].F.S<<" "<<r<<endl;

        possible.insert(arr[i]);
    }
    cout<<arr[0].F.F<<" "<<arr[0].F.S<<endl;
}

int main(){
    int t;
    sd(t);
    while(t--){
        solve();
    }
    return 0;
}
