/*
 	C++ Template
	Gaurav Babbar
*/

/* Solution: Convert nodes into dfs-visit times(mapping).
 * Then, a single node's subtree includes all the visit times in contiguous order: begin[] to end[]
 * Querying is then just a segment query, and node update
 */
 //http://discuss.codechef.com/questions/15036/tytactic-editorial

#include<bits/stdc++.h>
#define MOD 1000000007
#define MAX 100005
#define mp make_pair
#define pb push_back
#define gc getchar
#define pc putchar
#define llu unsigned long long
#define fill(a, val) memset(a, val, sizeof(a))
#define all(x) x.begin(), x.end()

int gcd(int a,int b){if (b==0) return a;else return gcd(b,a%b);}
llu power(llu b,llu exp,llu m) {llu ans=1; b%=m; while(exp){if(exp&1) ans=(ans*b)%m; exp>>=1; b=(b*b)%m; } return ans; }
using namespace std;

#define debug(args...) {dbg,args; cerr<<endl;}
struct debugger
{template<typename T> debugger& operator,(const T& v)
 {cerr<< v <<" ";
  return *this;
 }
}dbg;

inline void inp(int &n)
{
  n = 0;
  int ch = gc();
  int sign = 1;
  while(ch < '0' || ch > '9') {
    if (ch == '-') sign = -1;
    ch = gc();
  }
  while(ch >= '0' && ch <= '9')
    n = (n<<3) + (n<<1) + ch - '0', ch = gc();
  n = n*sign;
}

inline void outp(int a)
{
  char snum[25];
  int i=0;
  do
  {
    snum[i++]=a%10+48;
    a=a/10;
  } while(a!=0);
  i=i-1;
  while(i>=0)
    pc(snum[i--]);
  pc('\n');
}

int n,m;
int skill[MAX];
int tree[MAX];
bool visited[MAX];
int beginRange[MAX];
int endRange[MAX];
vector<int> adj[MAX];
int cTime;

int read(int idx)
{
	int sum = 0;
	while (idx > 0)
	{
		sum += tree[idx];
		idx -= (idx & -idx);
	}
	return sum;
}


void update(int idx ,int val)
{
	while (idx <= MAX)
    {
		tree[idx] += val;
		idx += (idx & -idx);
	}
}

void dfs(int u)
{
    visited[u]=true;
    beginRange[u]=++cTime;
    for(int v=0;v<adj[u].size();v++)
        if(!visited[adj[u][v]])
            dfs(adj[u][v]);
    endRange[u]=cTime;
}

void preprocess()
{
    dfs(1);
    //for(int i=1;i<=n;i++)
    //debug(beginRange[i],endRange[i]);
    for(int i=1;i<=n;i++)
        update(beginRange[i],skill[i]);
}

void reset()
{
}

void input()
{
    inp(n);inp(m);
    for(int i=1;i<=n;i++)
        inp(skill[i]);
    for(int i=1;i<=n-1;i++)
    {
        int u,v;
        inp(u);inp(v);
        adj[u].pb(v);
        adj[v].pb(u);
    }
}

void solve()
{
    char type;
    int s,val;
    for(int q=1;q<=m;q++)
    {
        cin>>type;
        inp(s);
        if(type=='U')
        {
            inp(val);
            update(beginRange[s],val-skill[s]);
            skill[s] = val;
        }
        else if(type=='Q')
        {
            outp((read(endRange[s])-read(beginRange[s]-1)));
        }
    }
}

int main()
{
   int t=1;
   //inp(t);
   while(t--)
   {
	   reset();
	   input();
	   preprocess();
	   solve();
   }
   return 0;
}
