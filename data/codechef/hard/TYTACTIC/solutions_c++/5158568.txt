#include<iostream>
#include<cstdio>
#include<vector>
#include<set>
#include<map>
#include<queue>
#include<string>
#include<algorithm>
#include<stack>
#include<cmath>

#define max(x, y) ((x) > (y) ? (x) : (y))

#define min(x, y) ((x) < (y) ? (x) : (y))

#define FOR(i, n) for(int i=0; (i) < (int)(n); ++i)


using namespace std;

inline void readint(int &x)
{
	register int c = getchar_unlocked();
	x = 0;
	for(;(c<48 || c>57);c = getchar_unlocked());
	for(;c>47 && c<58;c = getchar_unlocked()) {x = (x<<1) + (x<<3) + c - 48;}
}

inline void writeint(int x, char endchar)
{
	if(x == 0)
		putchar_unlocked('0');
	else
	{
		int cnt = 0;
		char ch[20];
		while(x != 0)
		{
			ch[cnt++] = x%10 + '0';
			x /= 10;
		}
		for(int i=cnt - 1; i>=0; --i)
			putchar_unlocked(ch[i]);
	}
	putchar_unlocked(endchar);
}

inline void writestring(const char* ch)
{
	while(*ch != '\0')
		putchar_unlocked(*(ch++));
	putchar_unlocked('\n');
}

vector<int> edg[100001];
int dfs[100001];
int ski[100001];
int skipre[100001];
int ind;
int dfl[100001];
int ll[100001];
int rl[100001];
int seg[400005];
int slt[400005];
int srt[400005];

void preorder(int root)
{
	if(dfl[root] != 0)
		return ;
	int size = edg[root].size();
	dfs[ind] = root;
	skipre[ind] = ski[root];
	ll[root] = ind;
	dfl[root] = 1;
	ind++;
	FOR(i, size)
	{
		preorder(edg[root][i]);
	}
	rl[root] = ind;
	return ;
}

void make_seg(int* arr, int st, int en, int root)
{
	//en > st
	if(en - st == 1)
	{
		seg[root] = arr[st];
		slt[root] = st;
		srt[root] = en;
		return ;
	}
	slt[root] = st;
	srt[root] = en;
	int mid = (st + en)/2;
	make_seg(arr, st, mid, 2 * root);
	make_seg(arr, mid, en, 2 * root + 1);
	seg[root] = seg[2 * root] + seg[2 * root + 1];
	return ;
}

int query(int st, int en, int root)
{
	//en > st
	if(st <= slt[root] && en >= srt[root])
		return seg[root];
	if(srt[2 * root] <= st)
		return query(st, en, 2 * root + 1);
	if(slt[2 * root + 1] >= en)
		return query(st, en, 2 * root);
	return query(st, en, 2 * root) + query(st, en, 2 * root + 1);
}

void update(int pos, int nkey, int root)
{
	if(slt[root] == srt[root] - 1 && slt[root] == pos)
	{
		seg[root] = nkey;
		return ;
	}
	if(slt[root] > pos)
		return ;
	if(srt[root] <= pos)
		return ;
	else
	{
		update(pos, nkey, 2 * root);
		update(pos, nkey, 2 * root + 1);
	}
	seg[root] = seg[2 * root] + seg[2 * root + 1];
	return ;
}

int main()
{
	int n, m;
	cin>>n>>m;
	ind = 1;
	int t1, t2;
	FOR(i, n)cin>>ski[i+1];
	FOR(i, n-1)
	{
		cin>>t1>>t2;
		edg[t1].push_back(t2);
		edg[t2].push_back(t1);
	}
	preorder(1);
	make_seg(skipre, 1, n+1, 1);
	char c;
	int v1, v2;
	FOR(i, m)
	{
		cin>>c;
		if(c == 'Q')
		{
			cin>>v1;
			cout<<query(ll[v1], rl[v1], 1)<<endl;
		}
		else
		{
			cin>>v1>>v2;
			update(ll[v1], v2, 1);
		}
	}
	return 0;
}
	
