#include<stdio.h>
#include<iostream>
#include<math.h>
#include<vector>
#include<map>
#include<string>
#include<string.h>
#include<algorithm>
#include<cassert>
#define PI acos(-1.0)
#define SZ 100007
#define Fi(a,n) for(int i=a;i<n;i++)
#define Fj(a,n) for(int j=a;j<n;j++)
using namespace std;

vector<int> adjList[SZ];
int parent[SZ],skill[SZ],data[2*SZ],tin[2*SZ],tout[2*SZ],TIMER;
int N,Q,u,v;
 
//dfs to calculate tin,tout and level of node in the tree
void dfs(int i,int p)
{
	
	tin[i]=++TIMER;
	for(int j=0;j<adjList[i].size();j++)
		if(adjList[i][j]!=p)
			dfs(adjList[i][j],i);
	tout[i]=++TIMER;
}

//fenwick tree for range max query w/ update/query functions
void update(int at, int by)
 { 
 while (at <= 2*N) { data[at] += by; at |= (at + 1); } 
 } 
int query(int at) 
 { 
 int res = 0; 
 while (at >= 0) 
 { res += data[at]; at = (at & (at + 1)) - 1; } 
 return res; 
 }


int main()
{
 
 	Fi(0,SZ)adjList[i].clear();
 	memset(data,0,sizeof(data));
 	memset(tin,0,sizeof(tin));
 	memset(tout,0,sizeof(tout));
 	scanf("%d %d",&N,&Q);
	Fi(1,N+1)
	scanf("%d",&skill[i]);
 	Fi(0,N-1){
 		scanf("%d %d",&u,&v);
 		parent[v]=u;
 		adjList[u].push_back(v);
 		adjList[v].push_back(u);
 	}
 	TIMER=0;
	dfs(1,1);
	Fi(1,N+1)
	{
		update(tin[i],skill[i]);
	}
	char s[10];
	int j;
	Fi(0,Q)
	{
		scanf("%s",s);
		if(s[0]=='U')
		{
			scanf("%d %d",&u,&v);
			update(tin[u],v-skill[u]);
			skill[u]=v;	
		}else
		{
			scanf("%d",&u);
			printf("%d\n",query(tout[u])-query(tin[u]-1));
		}
	}
 return 0;
}