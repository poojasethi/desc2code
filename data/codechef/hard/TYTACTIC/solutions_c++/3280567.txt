#include <stdio.h>
#include <algorithm>
#include <assert.h>
#include <string>
#include <cstring>
#include <map>
#include <set>
#include <vector>
#include <iostream>
#include <queue>
#include <cmath>
#include <ctime>
using namespace std;

typedef long long LL;
typedef pair<int, int> PII;
#define tr(container, it)for(__typeof(container.begin()) it = container.begin(); it != container.end(); it++)
#define PB push_back
#define REP(i,a,b) for (int i = (a); i < (int)(b); i++)

int GCD (int a, int b) { if (!a) return b; return GCD(b%a, a);}

void init() {
}

class BIT { // 0-indexed
private :
    int *tree, N, *val;
public :
    BIT(int sz) {
        N = sz;
        tree = new int[N + 1];
        val = new int[N + 1];
        for (int i = 0; i <= N; i++) tree[i] = val[i] = 0;
    }
    ~BIT() {
        delete[] tree;
        delete[] val;
    }
    void update(int idx, int val) {
        idx++;
        while (idx <= N) {
            tree[idx] += val;
            idx += (idx & -idx);
        }
    }
    int sum(int idx) {
        idx++;
        int ret = 0;
        while (idx > 0) {
            ret += tree[idx];
            idx -= (idx & -idx);
        }
        return ret;
    }
    int rangeSum(int start, int end) {
        if (!start) return sum(end);
        return sum(end) - sum(start - 1);
    }
};

#define X 100009
vector<vector<int> >graph;
int start[X], end[X];

int dfs(int u, int time) {
    start[u] = time;
    int ret = time;
    for (int i = 0; i < graph[u].size(); i++) {
        if (start[graph[u][i]] == -1)
            ret = dfs(graph[u][i], ret + 1);
    }
    end[u] = ret;
    return ret;
}

int main() {
    clock_t startTime = clock();
    ios_base::sync_with_stdio(false);

    int n, m; cin>>n>>m;
    vector<int>skill;
    skill.reserve(n+1);
    REP(i, 0, n) {
        int p; cin>>p;
        skill.PB(p);
    }

    graph.resize(n+1);
    REP(i, 0, n - 1) {
        int u, v; cin>>u>>v;
        --u; --v;
        graph[u].PB(v);
        graph[v].PB(u);
    }

    memset(start, -1, sizeof start);
    dfs(0, 0);

    BIT bit(n);

    REP(i, 0, n) {
        bit.update(start[i], skill[i]);
    }


    REP(q, 0, m) {
        char type; int idx, val;
        while (1) {
            cin>>type;
            if (type == 'U' || type == 'Q') break;
        }
        if (type == 'U') {
            cin>>idx>>val;
            --idx;
            bit.update(start[idx], val - skill[idx]);
            skill[idx] = val;
        } else {
            cin>>idx;
            --idx;
            cout<<bit.rangeSum(start[idx], end[idx])<<"\n";
        }
    }

    clock_t endTime = clock();
    cerr<<"\nTime:"<< double(endTime - startTime) / CLOCKS_PER_SEC <<" seconds\n" ;
    return 0;
}
