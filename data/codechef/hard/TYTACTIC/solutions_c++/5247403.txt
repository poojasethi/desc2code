#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cassert>
#include <string>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <cstdlib>
#define SIZE 1000001

using namespace std;

#define mp make_pair
#define pb push_back

/*int read()
{
    int n = 0, sign = 1, ch = getchar_unlocked();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
            sign = -1;
        ch = getchar_unlocked();
    }
    while (ch >= '0' && ch <= '9')
    {
        n = (n << 3) + (n << 1) + ch - '0';
        ch = getchar_unlocked();
    }
    return n * sign;
}*/

#define identity 0
#define c1(i) ((i)<<1)
#define c2(i) (((i)<<1)+1)
#define p(i) (i/2)
class SegTree
{
private:
    int ceil;
    int *key;
public:
    SegTree(int n, int *a)
    {
        int i; ceil = 1;
        while(ceil<n) ceil = ceil << 1;
        key = new int[(2*ceil)+1];
        for(i=0; i<n; i++) key[i+ceil] = a[i];
        for(; i<ceil; i++) key[i+ceil] = identity;
        for(i=ceil-1; i>0; i--) key[i] = key[c1(i)] + key[c2(i)];
    }

    int range_query(int i, int j)
    {
        int sum=0;
        i += (ceil-1); j += (ceil-1);
        sum = key[i];
        if(j>i)
        {
            sum +=key[j];
            while(p(i)!=p(j))
            {
                if(i%2==0) sum += key[i+1];
                if(j%2==1) sum += key[j-1];
                i = p(i); j = p(j);
            }
        }
        return sum;
    }

    void point_update(int i, int x)
    {
        i += (ceil-1);
        int delta = x - key[i];
        while(i>0)
        {
            key[i] += delta;
            i = p(i);
        }
        return;
    }

    void print_tree()
    {
        int i=1;
        for(int lim=2;lim<=(2*ceil); lim = lim<<1)
        {
            for(; i<lim; i++)
                printf("%d ",key[i]);
            printf("\n");
        }
    }
};


int x,S,delta,dfn,dfsno[SIZE],skill[SIZE],start[SIZE],end[SIZE],vmap[SIZE],smap[SIZE];
vector<int> adjl[SIZE];

void DFS1(int s)
{
    dfsno[s] = dfn++;
    vmap[s] = dfsno[s]; smap[vmap[s]] = skill[s];
    //printf("DFS started at vertex %d. Mapped to %d. dfsno is %d.\n",s,vmap[s],dfsno[s]);
    for(int i=0; i<adjl[s].size(); i++)
    {
        if(dfsno[ adjl[s][i] ] == 0)
            DFS1(adjl[s][i]);
    }

    start[vmap[s]] = dfsno[s];
    end[vmap[s]] = dfn-1;
    //printf("DFS ended of vertex %d. Mapped to %d. Range end is %d.\n",s,vmap[s],dfn-1);
    return;
}

int main()
{
    int n,m,a,b;
    char ch;

    //Input:
    scanf("%d%d", &n, &m);
    for(int i=1; i<=n; i++) dfsno[i] = 0;
    //parent[1] = 1;
    for(int i=1; i<=n; i++) scanf("%d", skill+i);
    for(int i=1; i<n; i++)
    {
        scanf("%d%d", &a,&b);
        adjl[a].push_back(b);
        adjl[b].push_back(a);
    }


    //Pre-processing:
    dfn=1; DFS1(1);
    SegTree T(n,smap+1);
    //T.print_tree();
    //Queries:
    while(m--)
    {
        getchar();
        ch = getchar();
        if(ch == 'Q')
        {
            scanf("%d",&S); // S is soldier
            a = start[ vmap[S] ]; b = end[ vmap[S] ];
            printf("%d\n",T.range_query(a,b));
        }
        else
        {
            scanf("%d%d", &S, &x);
            T.point_update(vmap[S],x);
            //T.print_tree();
        }
    }
    return 0;
}
