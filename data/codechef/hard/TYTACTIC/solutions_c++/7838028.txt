#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define pb push_back
#define mp make_pair
#define ff first
#define ss second
#define MOD 1000000007
#define MAX 100005
#define inf 0x7fffffff
#define ln cout<<endl;
int vis[MAX];
int ar[MAX];
int skill[MAX];
vector<ll> v[MAX];
int st[MAX];
int ed[MAX];
int tme=0;
int tree[4*MAX];

void dfs(int src,int parent)
{
	vis[src]=1;
	st[src]=tme++;
	for(int i=0;i<(int)v[src].size();i++)
	{
		int x1=v[src][i];
		if(vis[x1]==0 && x1!=parent)
		{
			dfs(x1,src);
		}
	}
	ed[src]=tme;
}

void build(int node,int a,int b)
{
	if(a==b)
	{
		tree[node]=ar[a];
		return ;
	}
	int mid;
	mid=(a+b)/2;
	build(2*node,a,mid);
	build(2*node+1,mid+1,b);
	tree[node]=tree[2*node]+tree[2*node+1];
	return ;
}

void update(int node,int a,int b,int j,int val)
{
	if(a==j && b==j)
	{
		tree[node]=val;
		return ;
	}
	int mid;
	mid=(a+b)/2;
	if(j<=mid)
	{
		update(2*node,a,mid,j,val);
	}
	else
	{
		update(2*node+1,mid+1,b,j,val);
	}
	tree[node]=tree[2*node]+tree[2*node+1];
	return ;
}

int query(int node,int a,int b,int i,int j)
{
	if(a > b || a > j || b < i) 
	{
		return 0;
	}
	if(a>=i && b<=j)
	{
		return tree[node];
	}
	int mid;
	mid=(a+b)/2;
	int q1=query(2*node,a,mid,i,j);
	int q2=query(2*node+1,mid+1,b,i,j);
	int res=q1+q2;
	return res;
}

int main()
{
	ios::sync_with_stdio(0);
	int n,m,a,b;
	char c;
	int x,y;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>skill[i];
	}
	for(int i=0;i<n-1;i++)
	{
		cin>>a>>b;
		v[a].pb(b);
		v[b].pb(a);
	}
	dfs(1,1);
	for(int i=1;i<=n;i++)
	{
		ar[st[i]]=skill[i];
	}
	build(1,0,n-1);
	

	for(int i=0;i<m;i++)
	{
		cin>>c;
		if(c=='U')
		{
			cin>>x>>y;
			update(1,0,n-1,st[x],y);
		}
		else
		{
			cin>>x;
			cout<<query(1,0,n-1,st[x],ed[x]-1);
			ln
		}
	}
	return 0;
}
