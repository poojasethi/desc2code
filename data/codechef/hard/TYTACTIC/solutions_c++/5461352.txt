#include <cstdio>
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <string>
#include <vector>
using namespace std;

const int maxn=122222;
vector<int> adj[maxn];
int num[maxn];
int pos[maxn];
int node[maxn];
int weight[maxn];
int n;
int index_;

void dfs(int u)
{
    num[u]=1;
    pos[u]=++index_;

    for(int i=0;i<adj[u].size();i++)
    {
        int v=adj[u][i];
        if(num[v]==0)
        {
            dfs(v);
            num[u]+=num[v];
        }
    }
}

void update(int pos,int diff)
{
    while(pos<=n)
    {
        node[pos]+=diff;
        pos += (pos & (-pos));
    }
}

int get(int pos)
{
    int sum=0;
    while(pos)
    {
        sum += node[pos];
        pos -= (pos & (-pos));
    }

    return sum;
}

int main()
{
    int m;
    scanf("%d %d",&n,&m);

    for(int i=1;i<=n;i++)
    {
        scanf("%d",weight+i);
    }
    int u,v;
    for(int i=1;i<n;i++)
    {
        scanf("%d %d",&u,&v);
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    //find the dfs order
    //num[u] is the size of sub-tree rooted at u
    dfs(1);

    for(int i=1;i<=n;i++)
    {
        update(pos[i],weight[i]);
    }
    char k;
    while(m--)
    {
        getchar();
        
        scanf("%c",&k);
        if(k=='Q')
        {
            scanf("%d",&u);
            printf("%d\n",get(pos[u]+num[u]-1)-get(pos[u]-1));
        }
        else
        {
            int value;
            scanf("%d %d",&u,&value);
            update(pos[u],value-weight[u]);
            weight[u]=value;
        }
    }

    return 0;
}
