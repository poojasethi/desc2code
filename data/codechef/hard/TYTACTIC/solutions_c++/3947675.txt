// TYPE : dfs and segtree implementation withut lazy propagation technique // :) :D
#include <cstdio>
#include <vector>
#include <algorithm>
#include <set>
#include <stack>
#include <utility>
#include <climits>
#include <iostream>
#include <queue>
#include <map>
#include <cmath>
#include <cstring>
#include <string>
using namespace std;
#define MOD 1000000007
#define MAX 100005
int start[100001],end[100001];
int dfs[100001],inv_dfs[100001];
int dnum=1;
vector<int> neigh[100001];
bool vis[100001];
void number(int v){
    if(vis[v]) return;
    vis[v]=true;
    dfs[v]=dnum;
    inv_dfs[dnum]=v;
    start[v]=dnum;
    dnum++;
    for(int i=0;i<neigh[v].size();i++){
        number(neigh[v][i]);
    }
    end[v]=dnum-1;
}
int skill[100001];
int tree[400004];
void init_tree(int ind,int l,int h){
    if(l==h){
        tree[ind]=skill[inv_dfs[l]];
        return;
    }
    int m=(l+h)/2;
    init_tree(2*ind,l,m);
    init_tree(2*ind+1,m+1,h);
    tree[ind]=tree[2*ind]+tree[2*ind+1];
}
void update(int ind,int l,int h,int pos,int val){
    if(pos<l || pos>h)
        return;
    if(l==h){
        tree[ind]=val;
        return;
    }
    int m=(l+h)/2;
    update(2*ind,l,m,pos,val);
    update(2*ind+1,m+1,h,pos,val);
    tree[ind]=tree[2*ind]+tree[2*ind+1];
}
int query(int ind, int l,int h,int x,int y){
    if(y<l or x>h)
        return 0;
    if(l>=x and y>=h)
        return tree[ind];
    int m=(l+h)/2;
    return query(2*ind,l,m,x,y)+query(2*ind+1,m+1,h,x,y);
}
int n,m;
int main(){
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&skill[i]);
    int x,y;
    for(int i=0;i<n-1;i++){
        scanf("%d %d",&x,&y);
        neigh[x].push_back(y);
        neigh[y].push_back(x);
    }
    memset(vis,false,sizeof vis);
    number(1);
    init_tree(1,1,n);
    char ch[10];
    while(m--){
        scanf("%s",ch);
        if(ch[0]=='Q'){
            int tmp;
            scanf("%d",&tmp);
            printf("%d\n",query(1,1,n,start[tmp],end[tmp]));
        }
        else{
            int s;
            scanf("%d %d",&s,&x);
            update(1,1,n,dfs[s],x);
        }
    }
    return 0;
}
