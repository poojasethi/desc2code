#include<bits/stdc++.h>
using namespace std;

#define ip(x) scanf("%d",&x)
#define ipLL(x) scanf("%lld",&x)
#define ForInc(var,beg,end) for(int var=beg;var<=end;++var)
#define advForInc(var,beg,end,inc) for(int var=beg;var<=end;var+=inc)
#define ForDec(var,end,beg) for(int var=end;var>=beg;--var)
#define ipArray(arr,size) ForInc(i,0,size-1) ip(arr[i]);
#define print(x) printf("%d\n",x)
#define printLL(x) printf("%lld\n",x)
#define ss(str) scanf("%s",str)
#define ii pair<int,int>
#define mp make_pair
#define pb push_back
#define READ(f) freopen(f,"r",stdin);
#define WRITE(f) freopen(f,"w",stdout);
#define TEST int testcases; ip(testcases);fflush(stdin);for(;testcases;--testcases)

template<typename T> T gcd(T a, T b) { return (b == 0) ? abs(a) : gcd(b, a % b); }
template<typename T> inline T lcm(T a, T b) { return a / gcd(a, b) * b; }
template<typename T> inline T mod(T a, T b) { return (a % b + b) % b; }
template<typename T> inline T sqr(T x) { return ((x) * (x)); }

const double EPS = 1e-9;
const double BIG = 1e19;
const int INF = 0x7f7f7f7f;

typedef long long LL;
#define LMT 100010

/* Main Code starts here :) */
const int h=17;
vector<int>g[LMT];
int stree[LMT];
vector<bool>vis(LMT,0);
int mytime=0;

struct arr1
{
int skl,b,e;
}arr[LMT];

class Tree{
public:
LL skl;
Tree():skl(0LL){}
inline void combine(Tree a, Tree b){
skl=a.skl+b.skl;
}
}T[1<<(h+1)];

inline void dfs(int sol)
{
    mytime++;
    vis[sol]=1;
    stree[mytime]=arr[sol].skl;
    arr[sol].b=mytime;
    for(int i=0;i<g[sol].size();i++) {if(!vis[g[sol][i]]) dfs(g[sol][i]);}
    arr[sol].e=mytime;
}

inline void build(int node,int l,int r)
{
    if(l==r)
    {
      T[node].skl=(LL)stree[l] ;
      return;
    }
    int child=node<<1,mid=(l+r)>>1;
    build(child,l,mid);
    build(child+1,mid+1,r);
    T[node].combine(T[child],T[child+1]);

}

LL query(int node,int l,int r,int s,int k)
{
    if(l==s && k==r)
        return T[node].skl;
    int mid=(s+k)>>1,child=node<<1;
    if(r<=mid)
    return query(child,l,r,s,mid);
    if(l>mid) return query(child+1,l,r,mid+1,k);
    LL ans1=query(child,l,mid,s,mid);
    LL ans2=query(child+1,mid+1,r,mid+1,k);
    return(ans1+ans2);


}

void update(int node,int val,int i,int j,int k)
{
    if(k==j && k==i)
    {
        T[node].skl=(LL)val;
        return;
    }
    int mid=(i+j)>>1;
    int child=node<<1;
    if(k<=mid) update(child,val,i,mid,k);
    else if(k>mid) update(child+1,val,mid+1,j,k);
    T[node].combine(T[child],T[child+1]);

}

int main()
{
    int m,n,h1,p,i,sol,val;
    char f;
    scanf("%d %d",&n,&m);
    for(i=1;i<=n;i++)
     scanf("%d",&arr[i].skl);
    for(i=1;i<=n-1;i++)
    {
        scanf("%d %d",&h1,&p);
        g[h1].pb(p);
        g[p].pb(h1);

    }
    dfs(1);
    build(1,1,n);
    for(i=0;i<m;i++)
    {  cin>>f;
      if(f=='U')
      {
      scanf("%d %d",&sol,&val);
      update(1,val,1,n,arr[sol].b);
      }
      else{

          scanf("%d",&sol);
          LL ans=query(1,arr[sol].b,arr[sol].e,1,n);
          printf("%lld\n",ans);
      }
    }

    return 0;

}
