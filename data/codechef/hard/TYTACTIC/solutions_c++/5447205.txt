#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int, int> pi;
const int MOD = 1000000007;

#define repu(i, a, b) for (int i = (a); i < (b); ++i)
#define foru(i, a, b) for (int i = (a); i <= (b); ++i)
#define repd(i, a, b) for (int i = (a); i > (b); --i)
#define ford(i, a, b) for (int i = (a); i >= (b); --i)
#define sz(a) ((int) a.size())
#define pb(a) push_back(a)
#define mp(a, b) make_pair(a, b)
#define mem(a) memset(a, 0, sizeof(a))

template<class T> inline T tmin(T a, T b) {return (a < b) ? a : b;}
template<class T> inline T tmax(T a, T b) {return (a > b) ? a : b;}
template<class T> inline void add_max(T &a, T b) {if (b > a) a = b;}
template<class T> inline void add_min(T &a, T b) {if (b < a) a = b;}
template<class T> inline T tabs(T a) {return (a > 0) ? a : -a;}
template<class T> T gcd(T a, T b) {if (b == 0) return a; return gcd(b, a % b);}

const int maxn = 100005;
vector<int> G[maxn];
int ord[maxn], subtree[maxn], skill[maxn];
int n, ptr;

template<class T> struct Fenwick {
    vector<T> bit;
    int fw_size;
    
    Fenwick(int _n) {
        fw_size = _n;
        bit.assign(_n + 1, 0);
    }
    
    void add(int ind, T val) {
        for (int i = ind; i <= fw_size; i += i & -i) {
            bit[i] += val;
        }
    }
    
    T get(int ind) {
        T ans = 0;
        for (int i = ind; i > 0; i -= i & -i) {
            ans += bit[i];
        }
        return ans;
    }
};

int dfs(int v, int pre) {
    subtree[v] = 1;
    ord[v] = ptr++;
    repu(i, 0, G[v].size()) {
        if (G[v][i] != pre) {
            subtree[v] += dfs(G[v][i], v);
        }
    }
    return subtree[v];
}

int main(int argc, char *argv[]) {
    ios_base::sync_with_stdio(false);
    int m, u, v, s, x;
    char op;
    cin >> n >> m;
    foru(i, 1, n) cin >> skill[i];
    repu(i, 1, n) {
        cin >> u >> v;
        G[v].pb(u);
        G[u].pb(v);
    }
    ptr = 1;
    mem(subtree);
    dfs(1, 0);
    Fenwick<int> fw = Fenwick<int>(ptr);
    foru(i, 1, n) {
        fw.add(ord[i], skill[i]);
    }
    repu(i, 0, m) {
        cin >> op;
        if (op == 'Q') {
            cin >> s;
            printf("%d\n", fw.get(ord[s] + subtree[s] - 1) - fw.get(ord[s] - 1));
        }
        else {
            cin >> s >> x;
            fw.add(ord[s], x - skill[s]);
            skill[s] = x;
        }
    }
    return 0;
}
