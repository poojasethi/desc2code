#include <iostream>

#include <stdio.h>

#include <stack>



using namespace std;



#define MAX 501
#define get getchar_unlocked



int men_rank_list[MAX][MAX];

int women_rank_list[MAX][MAX];

int women_preference_order[MAX][MAX];

int next_to_be_asked[MAX];

int men_engaged_to[MAX];

int women_engaged_to[MAX];

inline int scan()
{
    register int n=0,s=1;
    char p=get();
    if(p=='-')  s=-1;
    while((p<'0'||p>'9')&&p!=EOF&&p!='-') p=get();
    if(p=='-') s=-1,p=get();
    while(p>='0'&&p<='9') { n = (n<< 3) + (n<< 1) + (p - '0'); p=get(); }
    return n*s;
}
 
inline void print(int X)
{
	register int Len=0;
	int Data[10];
	while(X) { Data[Len++]=X%10; X/=10; }
	if(!Len) Data[Len++]=0;
	while(Len--) putchar_unlocked(Data[Len]+48);
	putchar_unlocked(' ');
}



inline void stable_matching(int num_pairs)

{

		stack<int> free_men_list;

		int m, w, m1, woman_index_number;

		for(int i = 1; i <= num_pairs; i++)

		{

			free_men_list.push(i);

			women_engaged_to[i] = 0;

			next_to_be_asked[i] = 1;

		}

		

		while(!free_men_list.empty())					// Stops when the free men list is empty.

		{

				m = free_men_list.top();			// m is the free man .

				woman_index_number = next_to_be_asked[m];  	// Man has not asked woman_index_number indexed woman in his list

				next_to_be_asked[m]+=1;				// The man m  has asked the  men_rank_list[woman_index_number] now .So 											// next time the man m has to propose men_rank_list[woman_index_number+1].



				w = men_rank_list[m][woman_index_number];     	// w = m's highest ranked such woman to whom he has not yet proposed



				//if w is free (m, w) become engaged

				if(women_engaged_to[w]==0)			// woman_engaged_to = 0 which means she is Free.

				{

					women_engaged_to[w]=m;			// The womanNumber W is now  engaged to man m;

					men_engaged_to[m]=w;

					free_men_list.pop();			// The free man m is now engaged ,so he is popped from stack.

					continue;

				}	

				else			                     	// Some pair (m1, w) already exists, if the control is here.

				{

					m1= women_engaged_to[w];            	// The woman w is not free and is already engaged to man m1.



					// Now based on who the woman gives more preference, that man will be selected.



					if(women_preference_order[w][m]<women_preference_order[w][m1])

										// If w prefers m to m1, the following happens.

					{ 

										// The woman w will be engaged to man m.

						free_men_list.pop();		// Man m is done,so he is popped from the stack.

						women_engaged_to[w]=m;		// m and e get engaged.

						men_engaged_to[m]=w;

						free_men_list.push(m1);		// m1 is now free. So, he is back into the stack.

					}

			}	

			

		}

		for(int j = 1; j <= num_pairs; j++)

		{

			//std::cout << j << " " << men_engaged_to[j] << std::endl;
			print(j);
			print(men_engaged_to[j]);

			puts(" ");
		}



}



int main()

{



	int num_test_cases, num_pairs, neglect;

	//scanf("%d", &num_test_cases);

	num_test_cases = scan();
	 

	while(num_test_cases--)

	{		

		//scanf("%d", &num_pairs);

		num_pairs = scan();
		

		for(int i = 1; i <= num_pairs; i++)

		{

			//scanf("%d", &neglect);

			neglect = scan();
	
			for(int j = 1; j <= num_pairs; j++)

			{

				//scanf("%d", &women_rank_list[i][j]);

				women_rank_list[i][j] = scan();
				women_preference_order[i][women_rank_list[i][j]] = j;	// Here we take the order of the preferences as they give and map

											// them appropriately.

			}

		}



		for(int i = 1; i <= num_pairs; i++)

		{

			//scanf("%d", &neglect);

			neglect = scan();
			for(int j = 1; j <= num_pairs; j++)

			{

				//scanf("%d", &men_rank_list[i][j]);

				men_rank_list[i][j] = scan();
			}

		}



		stable_matching(num_pairs);

	}		

return 0;

}