#include <iostream>

#include <cstdlib>
#include <stdio.h>

#include <vector>
#include <stack>


#define MAX 501
int jobs[MAX][MAX];
int applicants[MAX][MAX];
int applicant_preferences[MAX][MAX];
int next_to_be_interviewed[MAX];
int job_allotted_to[MAX];
int applicant_allotted_to[MAX];

void stableMatching(int N)
{
			std::stack<int> freeJobsList;

	

		for(int i = 1; i <= N; i++)

		{

			freeJobsList.push(i);
			applicant_allotted_to[i] = 0;
			next_to_be_interviewed[i] = 1;

		}
	
	

		// Now based on the things in the freeJobsList start allocating the jobs and then update the applicants and jobs information and 			// simultaneously push the taken jobs into the takenJobsList.

	


		int m;
		int applicant_index_number;
		int w;
		int m1;
		

		while(!freeJobsList.empty())						// Stops when the free jobs list is empty.

		{
				m = freeJobsList.top();						//m is the free man .
				applicant_index_number = next_to_be_interviewed[m];  //Man has not proposed woman_index_number indexed woman in his list
				next_to_be_interviewed[m]+=1;			//The man m  has proposed the  Man_list[woman_index_number] now .So next time
					//the man m has to propose Man_list[woman_index_number+1].

				w=jobs[m][applicant_index_number];     //w = m's highest ranked such woman to whom he has not yet proposed

				//if w is free (m, w) become engaged
				if(applicant_allotted_to[w]==0)			   //womanEngagedto=0 :: Means she is Free.
				{
					applicant_allotted_to[w]=m;			   //The womanNumber W is now  engaged to man m;
					job_allotted_to[m]=w;
					freeJobsList.pop();					  //The Free Man M is now Engaged ,so lets pop him from stack
					continue;				 //Boyzz - Man is popped ,is engaged now ,so why to go further.
				}	
				else			                     //Else some pair (m', w) already exists
				{
					m1= applicant_allotted_to[w];            //The woman w is not free and is already engaged to man m1 :( sad for Man  m

					// But Man m has still a chance ,Lets check whom woman w Prefers a lot.

					if(applicant_preferences[w][m]<applicant_preferences[w][m1])//if w prefers m to m1 (ie prefw for m >pref w for m1)
					{ 
						freeJobsList.pop();	//Then Woman w will be engaged with Man m.Man M is done,so lets pop him from stack.
						applicant_allotted_to[w]=m;		//(m, w) become engaged	
						job_allotted_to[m]=w;
						freeJobsList.push(m1);	//Man m1 is now free .Let him search for another woman by pushing him to stack.
					}
					else
					{
		
						/*This  is important . The wikipedia psudo code doesnot explain this properly*/
						/*if preference of man m is lower than m1 ,then women will stick to the partner
						(m1, w) remain engaged.
						But Man 'm' is still unengaged .
						So what to do now????
						Note for this reason i had not popped man m after m=freeMan.top() statement.
						Solution::
						Under that case ,the man m searches the next high ranked such woman to whom he has not yet proposed
						*/

					}
			}	

			

		}
		for(int j = 1; j <= N; j++)
		{
			std::cout << j << " " << job_allotted_to[j] << std::endl;
		}


}



int main()

{


	int num_test_cases, N, neglect;
	scanf("%d", &num_test_cases);
	

	// We create a vector of jobs and a vector of arrays and at each job object and at each applicant object we maintain a array in the order of the

	// preferences.
 
	while(num_test_cases--)
	{		
		scanf("%d", &N);
		

		for(int i = 1; i <= N; i++)

		{
			scanf("%d", &neglect);

			for(int j = 1; j <= N; j++)

			{

				scanf("%d", &applicants[i][j]);

				applicant_preferences[i][applicants[i][j]] = j;	// Here we take the order of the preferences as they give and map
											// them appropriately.

			}

		}



		for(int i = 1; i <= N; i++)

		{

			scanf("%d", &neglect);

			for(int j = 1; j <= N; j++)

			{

				scanf("%d", &jobs[i][j]);

			}

		}


		stableMatching(N);

		// Build a queue here. First all the free jobs are in one queue and the taken jobs are in one queue.

		// Then once a job becomes taken move it from one queue to the other. Once a job becomes free move it into the other queue.




	}	


	

return 0;

}