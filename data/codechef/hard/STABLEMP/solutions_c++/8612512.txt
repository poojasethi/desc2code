#include <algorithm>
#include <bitset>
#include <cctype>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <fstream>
#include <iostream>
#include <list>
#include <map>
#include <memory>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <vector>
#include <iomanip>
#include <math.h>

#define INF (1<<30)
#define PI acos(-1.0)
#define pb push_back
#define mem(x,y) memset(x,y,sizeof(x))
#define eps 1e-9

//template<class T> T gcd(T a, T b){ T r; while (b != 0) { r = a % b; a = b; b = r; } return a;}
//template<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }

using namespace std;

#define READ(f) freopen(f, "r", stdin)
#define WRITE(f) freopen(f, "w", stdout)


//Geometry
/*
struct Point
{
    int x;
    int y;
};
*/
/*
//Compute the dot product of AB.BC
int dot(Point A,Point B,Point C)
{
    Point AB;
    Point BC;
    AB.x=B.x-A.x;
    AB.y=B.y-A.y;
    BC.x=C.x-B.x;
    BC.y=C.y-B.y;
    int dot = AB.x*BC.x+AB.y*BC.y;
    return dot;
}
*/

/*
//Compute the cross product AB x AC
int cross(Point A,Point B,Point C)
{
    Point AB;
    Point AC;
    AB.x=B.x-A.y;
    AB.y=B.y-A.y;
    AC.x=C.x-A.x;
    AC.y=C.y-A.y;
    int cross = AB.x*AC.y-AB.y*AC.x;
    return cross;
}
*/

/*
//Compute the distance from A to B
double Distance(Point A,Point B)
{
    int d1=A.x-B.x;
    int d2=A.y-B.y;
    return sqrt(d1*d1+d2*d2);
}
*/
/*
//compute the degree between two line segments (cartesian)
double calDeg(Point A,Point B,Point C,Point D)
{
    double Angle=atan2(B.y-A.y,B.x-A.x)-atan2(D.y-C.y,D.x-C.x);
    Angle*=180;
    Angle/=PI;
    return Angle;
}
*/
/*
//Compute the distance from AB to C
//if isSegment is true, AB is a segment, not line.
double linePointDist(Point A,Point B,Point C,bool isSegment)
{
    double dist = cross(A,B,C)/Distance(A,B);
    if(isSegment)
    {
        int dot1 = dot(A,B,C);
        if(dot1>0) return Distance(B,C);
        int dot2 = dot(B,A,C);
        if(dot2>0) return Distance(A,C);
    }
    return abs(dist);
}
*/

/*
bool onSegment(Point p,Point q,Point r)
{
    if(q.x<=max(p.x,r.x)&&q.x>=min(p.x,r.x)&&
       q.y<=max(p.y,r.y)&&q.y>=min(p.y,r.y))
        return true;

    return false;
}
*/

/*
int orientation(Point p,Point q,Point r)
{
    int val=(q.y-p.y)*(r.x-q.x)-
            (q.x-p.x)*(r.y-q.y);

    if(val==0) return 0;
    return (val>0)?1:2;
}
*/

/*
bool doIntersect(Point p1,Point q1,Point p2,Point q2)
{
    int o1 = orientation(p1,q1,p2);
    int o2 = orientation(p1,q1,q2);
    int o3 = orientation(p2,q2,p1);
    int o4 = orientation(p2,q2,q1);

    if(o1!=o2 && o3!=o4)
        return true;

    if(o1==0&&onSegment(p1,p2,q1)) return true;

    if(o2==0&&onSegment(p1,q2,q1)) return true;

    if(o3==0&&onSegment(p2,p1,q2)) return true;

    if(o4==0&&onSegment(p2,q1,q2)) return true;

    return false;
}
*/

/*
void convexHull(Point points[],int n)
{
    if(n<3) return;
    int next[n];
    mem(next,-1);

    int l=0;
    for(int i=0;i<n;i++)
        if(points[i].x<points[l].x)
        l=i;

    int p=l,q;
    do
    {
        q=(p+1)%n;
        for(int i=0;i<n;i++)
            if(orientation(points[p],points[i],points[q])==2)
            q=i;

        next[p]=q;
        p=q;
    }while(p!=l);

    for(int i=0;i<n;i++)
    {
        if(next[i]!=-1)
            cout<<"("<<points[i].x<<", "<<points[i].y<<")\n";
    }
}
*/

//Number Theory

/*
#define Max 2000000
int prime[Max];
int palindrome[Max];
*/

/*
void sieveForPrime()
{
    memset(prime,-1,sizeof(prime));
    int N=Max;
    int sq=sqrt(N);
    for(int i=4;i<=N;i+=2) prime[i]=0;
    for(int i=3;i<=sq;i+=2)
    {
        if(prime[i])
        {
            for(int j=i*i;j<=N;j+=i) prime[j]=0;
        }
    }
    prime[1]=0;
}
*/

/*
void calculatePrime()
{
    for(int i=2;i<=Max;i++)
    {
        prime[i]=prime[i-1]-prime[i];
    }
}
*/

//to make palindrome the numbers odd variable is less than 2

/*
void sieveForPalidrome()
{
    memset(palindrome,0,sizeof(palindrome));
    for(int i=1;i<=Max;i++)
    {
        int a=i;
        int b=0;
        while(a)
        {
            b=b*10+a%10;
            a/=10;
        }
        if(b==i)
            palindrome[i]=1;
    }
}
*/

/*
void calculatePalindrome()
{
    for(int i=2;i<=Max;i++)
        palindrome[i]+=palindrome[i-1];
}
*/

//Graph

/*
#define valid(nx,ny) nx>=0 && nx<=row && ny>=0 && ny<=col
int fx[]={1,-1,0,0};
int fy[]={0,0,1,-1};
*/

//Stable Matching


#define MAX_N 550
int N,pref_men[MAX_N][MAX_N],pref_women[MAX_N][MAX_N];
int inv[MAX_N][MAX_N],cont[MAX_N],wife[MAX_N],husband[MAX_N];

void stable_marriage(){

    for(int i = 0 ; i < N ; i++)
        for(int j = 0;j < N; j++)
            inv[i][pref_women[i][j]] = j;

    fill(cont,cont+N,0);
    fill(wife,wife+N,-1);
    fill(husband,husband+N,-1);
    queue<int> Q;
    for(int i = 0; i < N; i++) Q.push(i);

    int m,w;

    while(!Q.empty()){
        m = Q.front();
        w = pref_men[m][cont[m]];

        if(husband[w] == -1){
            wife[m] = w;
            husband[w] = m;
            Q.pop();
        }else{
            if( inv[w][m] < inv[w][husband[w]] ){
                wife[m] = w;
                wife[husband[w]] = -1;
                Q.pop();
                Q.push(husband[w]);
                husband[w] = m;
            }
        }

        cont[m]++;
    }
}


//Permutation and combination

/*
long long dp[32];

long long factorial(long long n)
{
    if(dp[n]!=-1) return dp[n];
    else
    {
        dp[n]= (n == 1 || n == 0) ? 1 : factorial(n - 1) * n;
        return dp[n];
    }
}

long long nPr(long long  n,long long r)
{
    long long sum=1;
    for(int i=1;i<=r;i++)
    {
        sum*=n;
        n--;
    }
    return sum;
}

long long nCr(long long n,long long r)
{
    if(n<r) return 0;
    return (nPr(n,r) / factorial(r));
}
*/

int main()
{
    ios_base::sync_with_stdio(false);cin.tie(NULL);
    int T;
    cin>>T;
    while(T--)
    {
        cin>>N;
        int index;
        int num;
        for(int i=0;i<N;i++)
        {
            cin>>index;
            for(int j=0;j<N;j++)
            {
                cin>>num;
                pref_women[index-1][j]=num-1;
            }
        }
        for(int i=0;i<N;i++)
        {
            cin>>index;
            for(int j=0;j<N;j++)
            {
                cin>>num;
                pref_men[index-1][j]=num-1;
            }
        }
        stable_marriage();
        for(int i=0;i<N;i++)
        {
            printf("%d %d\n",i+1,wife[i]+1);
        }
    }
    return 0;
}
