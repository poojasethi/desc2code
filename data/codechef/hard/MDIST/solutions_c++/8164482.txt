#include <bits/stdc++.h>
 
using namespace std;
 
#define HODOR        long long
#define INF          1234567890
#define rep(i, a, b) for(int i = (a); i < (b); ++i)
#define gc           getchar_unlocked
#define pc           putchar_unlocked
 
template<typename X> inline void inp(X &n ) {
    register int ch=gc();int sign=1;n=0;
    while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=gc();}
    while(  ch >= '0' && ch <= '9' ) n = (n<<3)+(n<<1) + ch-'0', ch=gc();
    n=n*sign;
}
 
typedef struct node {
    int d[4];
}N;
 
vector<N> T;
 
void update(int start, int end) {
    for ( start >>= 1 , end >>= 1 ; start > 0; start >>= 1 , end >>= 1) {
        rep(i, start, end+1) {
            int next = i<<1;
            T[i].d[0] = max(T[next].d[0], T[next+1].d[0]);
            T[i].d[1] = min(T[next].d[1], T[next+1].d[1]);
            T[i].d[2] = max(T[next].d[2], T[next+1].d[2]);
            T[i].d[3] = min(T[next].d[3], T[next+1].d[3]);
        }
    }
}
 
HODOR query(int start, int end) {
    N ans = {-INF, INF, -INF, INF};
    for(; start <= end ; start = (start+1)>>1, end = (end-1)>>1) {
        ans.d[0] = max(ans.d[0], max(T[start].d[0], T[end].d[0]));
        ans.d[1] = min(ans.d[1], min(T[start].d[1], T[end].d[1]));
        ans.d[2] = max(ans.d[2], max(T[start].d[2], T[end].d[2]));
        ans.d[3] = min(ans.d[3], min(T[start].d[3], T[end].d[3]));
    }
    return max(1LL*ans.d[0]-ans.d[1], 1LL*ans.d[2]-ans.d[3]);
}
 
int findSize(int n) {
    int i = 1;
    for (; i < n; i <<= 1);
    return i;
}
 
int main() {
    // freopen("ip","r",stdin);
    int n, q, a, b, c, sz;
    char ch;
 
    inp(n), sz = findSize(n), T.assign(sz+sz, (N){-INF, INF, -INF, INF});
    rep(i, 0, n)
        inp(a), inp(b), T[i+sz].d[0] = T[i+sz].d[1] = a+b, T[i+sz].d[2] = T[i+sz].d[3] = a-b;
 
    update( sz, sz+n-1 ), inp(q);
    rep(i, 0, q) {
        for( ch = gc(); !(ch=='U' || ch=='Q'); ch = gc());
        inp(a), inp(b);
        if ( ch == 'U' ) 
            inp(c), T[a+sz].d[0] = T[a+sz].d[1] = b+c, T[a+sz].d[2] = T[a+sz].d[3] = b-c, update(a+sz, a+sz);
        else 
            printf("%lld\n", query(a+sz, b+sz));
    }
    return 0;
} 