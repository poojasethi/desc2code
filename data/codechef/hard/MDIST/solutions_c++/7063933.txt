#include<stdio.h>
#include<limits.h>
#include<stdlib.h>
#include<iostream>
using namespace std;
//Returns power of 2 just larger than N,puts in i the number of bits
long long getPowerTwo(long long N,long long *i){
	long long p=1;
	*i=0;
	while(p<N){
		p=p*2;
		(*i)++;
	}
	return p;
}
	
long long max(long long a,long long b){
	if(a>=b){
		return a;
	}
	else{
		return b;
	}
}
long long min(long long a,long long b){
	if(a<=b){
		return a;
	}
	else{
		return b;
	}
}
//Input:L:integer,n:No.of bits,places output in rep
void getBinaryRep(long long L,long long n,char *rep){
	long long i;
	for(i=n-1;i>=0;i--){
		if(L%2==0){
			rep[i]='0';
			L=L/2;
		}
		else{
			rep[i]='1';
			L=(L-1)/2;
		}
	}
}

long long query_max(long long*arr,char* L,char* R,long long n){//n=no. of bits
	long long i=0,ind=0;
	//Pre:(i=0)
	while((i<n)&&(L[i]==R[i])){
		//INV:(0<=i<n)/\((0 <=j<i)=>L[j]=R[j])/\(ind is the unique node by following L[j],0<=j<i,from initial 0)
		if(L[i]=='0'){
			ind=2*ind+1;
		}
		else{
			ind=2*ind+2;
		}
		i++;
	}
	//Post:(i=n/\ ind follows upto n-1 /\(for all i<n,L[i]=R[i]))  \/ ((i<n)/\(0<=j<i)=>L[j]=R[j],ind follows upto i-1/\L[i]!=R[i])
	if(i>=n){
		return arr[ind];
	}
	long long l=2*ind+1,r=2*ind+2;
	i++;
	long long max=LONG_MIN;
	while(i<n){
		if(L[i]=='0'){
			l=2*l+1;
			if(arr[l+1]>max){
				max=arr[l+1];
			}			
		}
	    else{
			l=2*l+2;		    
		}
		if(R[i]=='1'){
			r=2*r+2;
			if(arr[r-1]>max){
				max=arr[r-1];
			}			
		}
	    else{
			r=2*r+1;		    
		}
		i++;
	}
	if(arr[l]>max){
		max=arr[l];
	}
	if(arr[r]>max){
		max=arr[r];
	}	
	return max;
}
void updateQuerry(long long *arr,long long e,long long ind,long long size){
	//printf("ind=%lld\n",ind);
	arr[ind]=e;
	//Pre:arr[ind] updated,ind is the node
	while(ind>0){
		//INV:All ancestors upto ind updated
		ind=(ind-1)/2;
		//printf("ind=%lld\n",ind);
		if(2*ind+2<size){
			arr[ind]=max(arr[2*ind+1],arr[2*ind+2]);
		}
		else{
			arr[ind]=arr[2*ind+1];
		}
	}
	//Post:All ancestors updated
}
//Fills arrays f1..f4[ind_heap...] as segment trees for a_x a_y[L,,R], p=power of two	
void fillArrays(long long *A_x,long long*A_y,long long ind_heap,long long ind_L,long long ind_R,
                long long*arr_f1,long long*arr_f2,long long*arr_f3,long long*arr_f4,long long p){
						
	if(p==1){
		arr_f1[ind_heap]=A_x[ind_L]+A_y[ind_L];
		
		arr_f2[ind_heap]=A_x[ind_L]-A_y[ind_L];
		arr_f3[ind_heap]=-A_x[ind_L]+A_y[ind_L];
		arr_f4[ind_heap]=-A_x[ind_L]-A_y[ind_L];
	}
	else{
		
		fillArrays(A_x,A_y,2*ind_heap+1,ind_L, min(ind_L+p/2-1,ind_R),arr_f1,arr_f2,arr_f3,arr_f4,p/2);
		if((ind_L+p/2)<=ind_R){
			//printf("ind_L:%lld p:%lld ind_R:%lld\n",ind_L,p,ind_R);
			fillArrays(A_x,A_y,2*ind_heap+2,ind_L+p/2,ind_R,arr_f1,arr_f2,arr_f3,arr_f4,p/2);		    
		    arr_f1[ind_heap]=max(arr_f1[2*ind_heap+1],arr_f1[2*ind_heap+2]);
			arr_f2[ind_heap]=max(arr_f2[2*ind_heap+1],arr_f2[2*ind_heap+2]);
			arr_f3[ind_heap]=max(arr_f3[2*ind_heap+1],arr_f3[2*ind_heap+2]);
			arr_f4[ind_heap]=max(arr_f4[2*ind_heap+1],arr_f4[2*ind_heap+2]);
		}
		else{
			arr_f1[ind_heap]=arr_f1[2*ind_heap+1];
			arr_f2[ind_heap]=arr_f2[2*ind_heap+1];
			arr_f3[ind_heap]=arr_f3[2*ind_heap+1];
			arr_f4[ind_heap]=arr_f4[2*ind_heap+1];
		}			
	}	
}
	
int main(){
	long long N,Q,i,j;
	scanf("%lld",&N);
	long long *arr_x,*arr_y;
	arr_x=new long long[N];
	arr_y=new long long[N];
	//printf("created ");
	//printf("%lld" ,N);
	for(i=0;i<N;i++){
		scanf("%lld %lld",&arr_x[i],&arr_y[i]);
	}
	//printf("scanned");
	
	long long sz;
	long long p=getPowerTwo(N,&sz);
	//printf("p=%lld n=%lld",p,N);
	long long *arr_f1=new long long[p+N-1];
	long long *arr_f2=new long long[p+N-1];
	long long *arr_f3=new long long[p+N-1];
	long long *arr_f4=new long long[p+N-1];
	
	char *L=(char*)malloc(sz);
	char *R=(char*)malloc(sz);
	//printf("reached");
	//scanf("%lld",&i);
	for(i=0;i<p+N-1;i++){
		arr_f1[i]=LONG_MIN;
	}
	for(i=0;i<p+N-1;i++){
		arr_f2[i]=LONG_MIN;
	}
	for(i=0;i<p+N-1;i++){
		arr_f3[i]=LONG_MIN;
	}
	for(i=0;i<p+N-1;i++){
		arr_f4[i]=LONG_MIN;
	}
	
	
	fillArrays(arr_x,arr_y,0,0,N-1,arr_f1,arr_f2,arr_f3,arr_f4,p);
	/*printf("arr_f1\n");
	for(i=0;i<p+N-1;i++){
		printf("%lld ",arr_f1[i]);
	}
	printf("arr_f2\n");
	for(i=0;i<p+N-1;i++){
		printf("%lld ",arr_f2[i]);
	}
	printf("arr_f3\n");
	for(i=0;i<p+N-1;i++){
		printf("%lld ",arr_f3[i]);
	}
	printf("arr_f4\n");
	for(i=0;i<p+N-1;i++){
		printf("%lld ",arr_f4[i]);
	}*/
	scanf("%lld",&Q);
	long long output[Q];
	char c;
	long long ind,x,y,l,r;
	long long m1,m2,m3,m4;
	for(i=0;i<Q;i++){
		//printf("i=%lld\n",i);
		cin>>c;
		if(c=='U'){
			scanf("%lld %lld %lld",&ind,&x,&y);
			updateQuerry(arr_f1,x+y,ind+p-1,p+N-1);
			updateQuerry(arr_f2,x-y,ind+p-1,p+N-1);
			updateQuerry(arr_f3,-x+y,ind+p-1,p+N-1);
			updateQuerry(arr_f4,-x-y,ind+p-1,p+N-1);
			output[i]=-1;
			/*printf("arr_f1\n");
			for(j=0;j<p+N-1;j++){
				printf("%lld ",arr_f1[j]);
			}
			printf("arr_f2\n");
			for(j=0;j<p+N-1;j++){
				printf("%lld ",arr_f2[j]);
			}
			printf("arr_f3\n");
			for(j=0;j<p+N-1;j++){
				printf("%lld ",arr_f3[j]);
			}
			printf("arr_f4\n");
			for(j=0;j<p+N-1;j++){
				printf("%lld ",arr_f4[j]);
			}*/
			
			
		}
		else{
			scanf("%lld %lld",&l,&r);
			getBinaryRep(l,sz,L);
			getBinaryRep(r,sz,R);
			m1=query_max(arr_f1,L,R,sz);
			m2=query_max(arr_f2,L,R,sz);
			m3=query_max(arr_f3,L,R,sz);
			m4=query_max(arr_f4,L,R,sz);
			m1=m1+m4;
			if(m1<0){
				m1=-m1;
			}
			m2=m2+m3;
			if(m2<0){
				m2=-m2;
			}
			output[i]=max(m1,m2);
		}
	}
	for(i=0;i<Q;i++){
		if(output[i]>=0){
			printf("%lld\n",output[i]);
		}
	}
	return 0;
}
