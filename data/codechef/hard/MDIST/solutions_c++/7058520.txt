#include<vector>
#include<cstring>
#include<algorithm>
#include<stdio.h>
#include<climits>
#include<set>
#include<fstream>
#include<cmath>
#include<bitset>
#include<map>
#include<stack>
#include<fstream>
#include<iostream>
#include<queue>
#define test(t) while(t--)
#define s(n) scanf("%d",&n)
#define sl(n) scanf("%lld",&n)

#define p(n) printf("%lld\n",n)
#define rep(i,a,n) for(i=a;i<=n;i++)
#define vi vector<int>
#define vii vector< vector<int> >
#define vpii vector< pair<int,int> >
#define mii map<int,int>
#define pb push_back
#define inf 1000000000LL
#define mp make_pair

#define N 500014
//#define inf 100000000
#define ll  long long
using namespace std;

ll mod =1000000007;
ll powmod(ll a,ll b)
{
   ll res = 1;
   while(b>0)
   {
     if(b&1)
        res = (res*a)%mod;
        a=(a*a)%mod;
        b/=2;
   }
   return res;
}
ll minverse(ll a)
{
  if(a==0)
    return 1LL;
  else
   return powmod(a,mod-2);
}



ll tmax[N][4],tmin[N][4];
int X[N],Y[N];
void build_tree(int id,int l,int r)
{
  if(l==r)
  {
    tmax[id][0] = tmin[id][0] = X[l]+Y[l];
    tmax[id][1] = tmin[id][1] = X[l]-Y[l];
    tmax[id][2] = tmin[id][2] = -X[l]+Y[l];
    tmax[id][3] = tmin[id][3] = -X[l]-Y[l];
  }
  else
  {
    int mid = (l+r)/2;
    build_tree(2*id+1,l,mid);
    build_tree(2*id+2,mid+1,r);
    tmax[id][0] = max(tmax[2*id+1][0],tmax[2*id+2][0]);
    tmax[id][1] = max(tmax[2*id+1][1],tmax[2*id+2][1]);
    tmax[id][2] = max(tmax[2*id+1][2],tmax[2*id+2][2]);
    tmax[id][3] = max(tmax[2*id+1][3],tmax[2*id+2][3]);

    tmin[id][0] = min(tmin[2*id+1][0],tmin[2*id+2][0]);
    tmin[id][1] = min(tmin[2*id+1][1],tmin[2*id+2][1]);
    tmin[id][2] = min(tmin[2*id+1][2],tmin[2*id+2][2]);
    tmin[id][3] = min(tmin[2*id+1][3],tmin[2*id+2][3]);
  }
}

void update(int id,int l,int r,int qid,int lx,int ly)
{
  if(qid>r||qid<l)
  return;
  else if(l==r)
  {
    tmax[id][0] = tmin[id][0] = lx+ly;
    tmax[id][1] = tmin[id][1] = lx-ly;
    tmax[id][2] = tmin[id][2] = -lx+ly;
    tmax[id][3] = tmin[id][3] = -lx-ly;
  }
  else
  {
    int mid = (l+r)/2;
    update(2*id+1,l,mid,qid,lx,ly);
    update(2*id+2,mid+1,r,qid,lx,ly);
    tmax[id][0] = max(tmax[2*id+1][0],tmax[2*id+2][0]);
    tmax[id][1] = max(tmax[2*id+1][1],tmax[2*id+2][1]);
    tmax[id][2] = max(tmax[2*id+1][2],tmax[2*id+2][2]);
    tmax[id][3] = max(tmax[2*id+1][3],tmax[2*id+2][3]);

    tmin[id][0] = min(tmin[2*id+1][0],tmin[2*id+2][0]);
    tmin[id][1] = min(tmin[2*id+1][1],tmin[2*id+2][1]);
    tmin[id][2] = min(tmin[2*id+1][2],tmin[2*id+2][2]);
    tmin[id][3] = min(tmin[2*id+1][3],tmin[2*id+2][3]);
  }
}

ll qm1(int id,int l,int r,int ql,int qr)
{
  if(ql>r||qr<l)
  return INT_MIN;
  else if(ql<=l && qr>=r)
  return tmax[id][0];
  else
  {
    int mid = (l+r)/2;
    return max(qm1(2*id+1,l,mid,ql,qr),qm1(2*id+2,mid+1,r,ql,qr));
  }
}

ll qm2(int id,int l,int r,int ql,int qr)
{
  if(ql>r||qr<l)
  return INT_MIN;
  else if(ql<=l && qr>=r)
  return tmax[id][1];
  else
  {
    int mid = (l+r)/2;
    return max(qm2(2*id+1,l,mid,ql,qr),qm2(2*id+2,mid+1,r,ql,qr));
  }
}

ll qm3(int id,int l,int r,int ql,int qr)
{
  if(ql>r||qr<l)
  return INT_MIN;
  else if(ql<=l && qr>=r)
  return tmax[id][2];
  else
  {
    int mid = (l+r)/2;
    return max(qm3(2*id+1,l,mid,ql,qr),qm3(2*id+2,mid+1,r,ql,qr));
  }
}

ll qm4(int id,int l,int r,int ql,int qr)
{
  if(ql>r||qr<l)
  return INT_MIN;
  else if(ql<=l && qr>=r)
  return tmax[id][3];
  else
  {
    int mid = (l+r)/2;
    return max(qm4(2*id+1,l,mid,ql,qr),qm4(2*id+2,mid+1,r,ql,qr));
  }
}

ll qq1(int id,int l,int r,int ql,int qr)
{
  if(ql>r||qr<l)
  return INT_MAX;
  else if(ql<=l && qr>=r)
  return tmin[id][0];
  else
  {
    int mid = (l+r)/2;
    return min(qq1(2*id+1,l,mid,ql,qr),qq1(2*id+2,mid+1,r,ql,qr));
  }
}

ll qq2(int id,int l,int r,int ql,int qr)
{
  if(ql>r||qr<l)
  return INT_MAX;
  else if(ql<=l && qr>=r)
  return tmin[id][1];
  else
  {
    int mid = (l+r)/2;
    return min(qq2(2*id+1,l,mid,ql,qr),qq2(2*id+2,mid+1,r,ql,qr));
  }
}

ll qq3(int id,int l,int r,int ql,int qr)
{
  if(ql>r||qr<l)
  return INT_MAX;
  else if(ql<=l && qr>=r)
  return tmin[id][2];
  else
  {
    int mid = (l+r)/2;
    return min(qq3(2*id+1,l,mid,ql,qr),qq3(2*id+2,mid+1,r,ql,qr));
  }
}

ll qq4(int id,int l,int r,int ql,int qr)
{
  if(ql>r||qr<l)
  return INT_MAX;
  else if(ql<=l && qr>=r)
  return tmin[id][3];
  else
  {
    int mid = (l+r)/2;
    return min(qq4(2*id+1,l,mid,ql,qr),qq4(2*id+2,mid+1,r,ql,qr));
  }
}

int main()
{
int n,i,j,n1,n2;
cin>>n;
for(i=0;i<n;++i)
{
   s(X[i]);s(Y[i]);
}
build_tree(0,0,n-1);

 //cout<<tmax[0][0]<<" "<<tmax[0][1]<<" "<<tmax[0][2]<<" "<<tmax[0][3]<<endl;
 //cout<<tmin[0][0]<<" "<<tmin[0][1]<<" "<<tmin[0][2]<<" "<<tmin[0][3]<<endl;

int q;
cin>>q;
while(q--)
{
  char ty;
  scanf(" %c",&ty);
  if(ty=='U')
  {
    int id;
    scanf("%d%d%d",&id,&n1,&n2);
    update(0,0,n-1,id,n1,n2);
  }
  else
  {
    scanf("%d%d",&n1,&n2);
    ll ans1=qm1(0,0,n-1,n1,n2)-qq1(0,0,n-1,n1,n2);
    ans1=max(ans1,qm2(0,0,n-1,n1,n2)-qq2(0,0,n-1,n1,n2));
    ans1=max(ans1,qm3(0,0,n-1,n1,n2)-qq3(0,0,n-1,n1,n2));
    ans1=max(ans1,qm4(0,0,n-1,n1,n2)-qq4(0,0,n-1,n1,n2));
    printf("%lld\n",ans1);
  }
}
return 0;
}
