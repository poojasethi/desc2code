#include<bits/stdc++.h>
#include<iostream>
using namespace std;
#define fre 	freopen("0.in","r",stdin),freopen("0.out","w",stdout)
#define abs(x) ((x)>0?(x):-(x))
#define MOD 1000000007LL
#define INF 1000000000000000LL
#define SHIFT 10000000000LL
#define lld signed long long int
#define pp pop_back()
#define ps(x) push_back(x)
#define mpa make_pair
#define pii pair<int,int>
#define fi first
#define se second
#define scan(x) scanf("%d",&x)
#define print(x) printf("%d\n",x)
#define scanll(x) scanf("%lld",&x)
#define printll(x) printf("%lld\n",x)
#define boost ios_base::sync_with_stdio(0)
//vector<int> g[2*100000+5];int par[2*100000+5];
struct SEG_TREE
{
	lld MAX,MIN;
	lld ans;
	SEG_TREE()
	{
		MAX = -INF;
		MIN = INF;
		ans = 0;
	}
 
}tree[5][100000*6+5];
SEG_TREE combine(SEG_TREE L,SEG_TREE R)
{
	SEG_TREE P;
	P.MIN = min(L.MIN,R.MIN);
	P.MAX = max(L.MAX,R.MAX);
	P.ans = P.MAX-P.MIN;
	return P;
}
void update(int i,int si,int sj,int at,int val,int T)
{
	if(si == sj)
	{
		tree[T][i].ans = 0;
		tree[T][i].MAX = val;
		tree[T][i].MIN = val;
	}
	else
	{
		int mid = (si+sj)/2;
		if(at<=mid)
			update(2*i,si,mid,at,val,T);
		else
			update(2*i+1,mid+1,sj,at,val,T);
 
		tree[T][i] = combine(tree[T][2*i],tree[T][2*i+1]);
	}
}
SEG_TREE query(int i,int si,int sj,int qi,int qj,int T)
{
	if(si==qi and sj==qj)
		return tree[T][i];
	else
	{
		int mid = (si+sj)/2;
		if(qj<=mid)
			return query(2*i,si,mid,qi,qj,T);
		else
		if(mid+1<=qi)
			return query(2*i+1,mid+1,sj,qi,qj,T);
 
		SEG_TREE T1 = query(2*i,si,mid,qi,mid,T);
		SEG_TREE T2 = query(2*i+1,mid+1,sj,mid+1,qj,T);
		return combine(T1,T2);
	}
}
int main()
{
	//fre;
	int i,L,R,N,Q;
	lld x,y;
	char c;
	scan(N);
	for(int i=1;i<=N;++i)
	{
		scanll(x);
		scanll(y);
			update(1,1,N,i,x+y,1);
			update(1,1,N,i,x-y,2);
			update(1,1,N,i,-x-y,3);
			update(1,1,N,i,-x+y,4);
	}
	scan(Q);
	while(Q--)
	{
		scanf(" %c",&c);
		if(c=='U')
		{
			scan(i);
			i++;
			scanll(x);
			scanll(y);
			update(1,1,N,i,x+y,1);
			update(1,1,N,i,x-y,2);
			update(1,1,N,i,-x-y,3);
			update(1,1,N,i,-x+y,4);
		}
		else
		{
			scan(L);scan(R);
			L++;
			R++;
			printll(max(
						query(1,1,N,L,R,1).ans,
						max(
						query(1,1,N,L,R,2).ans,
						max(
						query(1,1,N,L,R,3).ans,
						query(1,1,N,L,R,4).ans
						))));
		}
	}
}