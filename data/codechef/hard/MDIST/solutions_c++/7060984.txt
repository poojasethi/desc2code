/*
Author - Shubham Shukla (shuklas664)
*/
#include <bits/stdc++.h>

typedef long long       ll;

#define MOD         1000000007
#define scll(t)     scanf("%lld",&t)
#define sc(t)       scanf("%d",&t)
#define max(a,b)    (a>=b?a:b)
#define min(a,b)    (a<b?a:b)
#define gc          getchar_unlocked
#define mp          make_pair
#define pb          push_back
#define freinp	    freopen("in.txt","r",stdin)
#define freout	    freopen("out.txt","w",stdout)
#define MAX         123456
#define inf         10e12
using namespace std;


/*
void scanint(int &x)
{
    register int c = gc();
    x = 0;
    for(;(c<48 || c>57);c = gc());
    for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}
}
*/
void scanll(ll &x)
{
    register ll c = gc();
    x = 0;
    int neg = 0;
    for(;((c<48 || c>57) && c != '-');c = gc());
    if(c=='-') {neg=1;c=gc();}
    for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}
    if(neg) x=-x;
}



ll arx[MAX],ary[MAX];
ll tree1[4*MAX];//max of x+y
ll tree2[4*MAX];//min x+y
ll tree3[4*MAX];//max x-y
ll tree4[4*MAX];//min x-y
ll maxVal, minVal;

void build1(ll node, ll a, ll b) {
   if(a > b) return;

         if(a == b) {
                   tree1[node] = arx[a] + ary[a];
                   tree2[node] = arx[a] + ary[a];
               return;
       }

       build1(node*2, a, (a+b)/2);
       build1(node*2+1, 1+(a+b)/2, b);

       tree1[node] = max(tree1[node*2], tree1[node*2+1]);
       tree2[node] = min(tree2[node*2], tree2[node*2+1]);
}
void build2(ll node, ll a, ll b) {
   if(a > b) return;

         if(a == b) {
                tree3[node] = arx[a] - ary[a];
                tree4[node] = arx[a] - ary[a];
               return;
       }

       build2(node*2, a, (a+b)/2);
       build2(node*2+1, 1+(a+b)/2, b);

       tree3[node] = max(tree3[node*2], tree3[node*2+1]);
       tree4[node] = min(tree4[node*2], tree4[node*2+1]);
}
void query1(ll node, ll a, ll b, ll i, ll j) {

       if(a > b || a > j || b < i) return;

       if(a >= i && b <= j)
               {
                    maxVal = max(maxVal, tree1[node]);
                    minVal = min(minVal, tree2[node]);
                    return;
               }

        query1(node*2, a, (a+b)/2, i, j);
        query1(1+node*2, 1+(a+b)/2, b, i, j);

}
void query2(ll node, ll a, ll b, ll i, ll j) {

       if(a > b || a > j || b < i) return;

       if(a >= i && b <= j)
               {
                    maxVal = max(maxVal, tree3[node]);
                    minVal = min(minVal, tree4[node]);
                    return;
               }

        query2(node*2, a, (a+b)/2, i, j);
        query2(1+node*2, 1+(a+b)/2, b, i, j);

}

void update1(ll node, ll a, ll b, ll i, ll j, ll value) {

       if(a > b || a > j || b < i)
               return;

         if(a == b) {
                   tree1[node] = value;
                   tree2[node] = value;
                   return;
       }

       update1(node*2, a, (a+b)/2, i, j, value);
       update1(1+node*2, 1+(a+b)/2, b, i, j, value);
       tree1[node] = max(tree1[node*2], tree1[node*2+1]);
       tree2[node] = min(tree2[node*2], tree2[node*2+1]);
}
void update2(ll node, ll a, ll b, ll i, ll j, ll value) {

       if(a > b || a > j || b < i)
               return;

         if(a == b) {
                   tree3[node] = value;
                   tree4[node] = value;
                   return;
       }

       update2(node*2, a, (a+b)/2, i, j, value);
       update2(1+node*2, 1+(a+b)/2, b, i, j, value);
       tree3[node] = max(tree3[node*2], tree3[node*2+1]);
       tree4[node] = min(tree4[node*2], tree4[node*2+1]);
}





int main()
{

    //freinp;
	ll x,y,n;
	ll l,r,i,mi,ma,ans,q;
	scanll(n);
	char c;
	for(i=0;i<n;i++)
	{
        scanll(arx[i]);
        scanll(ary[i]);

	}
	build1(1,0,n-1);
	build2(1,0,n-1);
    scanll(q);
    while(q--)
    {
        scanf(" %c",&c);
        if(c=='U')
        {
            scanll(i);
            scanll(x);
            scanll(y);
            update1(1,0,n-1,i,i,x+y);
            update2(1,0,n-1,i,i,x-y);
        }
        else
        {

            scanll(l);
            scanll(r);
            maxVal = -inf;
            minVal = inf;

            query1(1,0,n-1,l,r);

            ll max1 = maxVal - minVal;

            maxVal = -inf;
            minVal = inf;

            query2(1,0,n-1,l,r);

            max1 = max(max1, maxVal - minVal);

            printf("%lld\n",max1);
        }
    }


}
