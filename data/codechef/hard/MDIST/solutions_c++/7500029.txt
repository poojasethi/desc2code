#include<bits/stdc++.h>

using namespace std;

#define ll long long int
#define maxN 100005
#define maxK 500
#define maxW 1005
#define pb push_back
#define mp make_pair
#define INF (((ll)1000000000) * ((ll)1000000000))
#define inf 0x7fffffff
#define inff 100000
#define ff first
#define ss second
#define MOD 1000000007
#define fast cin.sync_with_stdio(0);cin.tie(0)
#define rep(i,N) for(int i=0;i<N;i++)
#define pii pair<int,int>
#define fill(A,v) memset(A,v,sizeof A)
#define setbits(x) __builtin_popcount(x)
#define print(A,n) for(int i=0;i<n;i++)cout<<A[i]<<" ";cout<<"\n"


//where f1(P) = x+y, f2(P) = -x+y, f3(P) = x-y, f4(P) = -x-y
// minimum value of f1(P) gives maximum value of f4(P)
ll T1[800080],T2[800080],T3[800080],T4[800080];
ll x[maxN],y[maxN];

void build(int node,int l,int r) {
	if(l>r)
		return;
	if(l==r) {
		T1[node]=x[l]+y[l];
		T2[node]=x[l]+y[l];
		T3[node]=x[l]-y[l];
		T4[node]=x[l]-y[l];
		return;
	}
	build(2*node,l,(l+r)/2);
	build(2*node+1,(l+r)/2+1,r);
	T1[node]=max(T1[2*node],T1[2*node+1]);
	T2[node]=min(T2[2*node],T2[2*node+1]);
	//cout<<l<<" "<<r<<" "<<T2[node]<<"\n";
	T3[node]=max(T3[2*node],T3[2*node+1]);
	T4[node]=min(T4[2*node],T4[2*node+1]);
}

void update(int node,int l,int r,int index,int a,int b) {
	if(l>r || l>index || r<index)
		return;
	if(l==r && l==index) {
		x[index]=a;
		y[index]=b;
		T1[node]=a+b;
		T2[node]=a+b;
		T3[node]=a-b;
		T4[node]=a-b;
		return;
	}
	update(2*node,l,(l+r)/2,index,a,b);
	update(2*node+1,(l+r)/2+1,r,index,a,b);
	T1[node]=max(T1[2*node],T1[2*node+1]);
	T2[node]=min(T2[2*node],T2[2*node+1]);
	T3[node]=max(T3[2*node],T3[2*node+1]);
	T4[node]=min(T4[2*node],T4[2*node+1]);
}

//max value in T1
ll query1(int node,int l,int r,int ql,int qr) {
	if(l>qr || l>r || ql>qr || r<ql )
		return -INF;
	if(l>=ql && r<=qr)
		return T1[node];
	int mid=(l+r)/2;
	return max(query1(2*node,l,mid,ql,qr),query1(2*node+1,mid+1,r,ql,qr));
}

ll query2(int node,int l,int r,int ql,int qr) {
	if(l>qr || l>r || ql>qr || r<ql )
		return INF;
	if(l>=ql && r<=qr)
		return T2[node];
	int mid=(l+r)/2;
	return min(query2(2*node,l,mid,ql,qr),query2(2*node+1,mid+1,r,ql,qr));
}

ll query3(int node,int l,int r,int ql,int qr) {
	if(l>qr || l>r || ql>qr || r<ql )
		return -INF;
	if(l>=ql && r<=qr)
		return T3[node];
	int mid=(l+r)/2;
	return max(query3(2*node,l,mid,ql,qr),query3(2*node+1,mid+1,r,ql,qr));
}

ll query4(int node,int l,int r,int ql,int qr) {
	if(l>qr || l>r || ql>qr || r<ql )
		return INF;
	if(l>=ql && r<=qr)
		return T4[node];
	int mid=(l+r)/2;
	return min(query4(2*node,l,mid,ql,qr),query4(2*node+1,mid+1,r,ql,qr));
}

int main(int argc, char const *argv[])
{
	fast;

	int n;
	cin>>n;

	rep(i,n)
		cin>>x[i]>>y[i];

	build(1,0,n-1);

	int q;
	cin>>q;
	char ch;
	ll v1,v2;
	int l,r,a,b;
	while(q--) {
		cin>>ch;
		if(ch=='Q') {
			cin>>l>>r;
			v1=query1(1,0,n-1,l,r)-query2(1,0,n-1,l,r);
			v2=query3(1,0,n-1,l,r)-query4(1,0,n-1,l,r);
			cout<<max(v1,v2)<<"\n";
		}
		else {
			cin>>l>>a>>b;
			update(1,0,n-1,l,a,b);
		}
	}
	
	return 0;
}