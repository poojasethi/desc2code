#include <iostream>
#include <stdio.h>
#define INF 2123456789
using namespace std;

const int maxn = 100007;

struct node
{
	int l,r,mi,mx;
};

class segTree
{
public:
	node SG[4*maxn];
	void init(int pt,int st,int en);
	int qmx(int pt,int st,int en);
	int qmi(int pt,int st,int en);
	void upd(int pt,int i,int val);
}stx,sty;
int main()
{
	#ifndef ONLINE_JUDGE
		freopen("I.in","r",stdin);
	#endif
		
	int n,foo,bar,q,pos;
	char ch;
	scanf("%d",&n);
	stx.init(0,0,n-1);
	sty.init(0,0,n-1);
	for(int i=0;i<n;i++)
	{
		scanf("%d%d",&foo,&bar);
		stx.upd(0,i,foo+bar);
		sty.upd(0,i,foo-bar);
	}
	scanf("%d",&q);
	while(q--)
	{
		cin>>ch;
		if(ch=='U')
		{
			scanf("%d%d%d",&pos,&foo,&bar);
			stx.upd(0,pos,foo+bar);
			sty.upd(0,pos,foo-bar);
		}
		else
		{
			scanf("%d%d",&foo,&bar);
			long long maxx,minx,maxy,miny;
			maxx = stx.qmx(0,foo,bar);
			minx = stx.qmi(0,foo,bar);
			maxy = sty.qmx(0,foo,bar);
			miny = sty.qmi(0,foo,bar);
			printf("%lld\n",max(maxx-minx,maxy-miny));
		}
	}
	return 0;
}

void segTree::init(int pt,int st,int en)
{
	SG[pt].l=st;
	SG[pt].r=en;
	SG[pt].mx=-INF;
	SG[pt].mi=INF;
	if(st==en) return;
	int mid=(st+en)>>1;
	init(2*pt+1,st,mid);
	init(2*pt+2,mid+1,en);
}
void segTree::upd(int pt,int pos,int val)
{
	if(SG[pt].l>pos or SG[pt].r<pos) return;
	if(SG[pt].l==SG[pt].r)
	{
		SG[pt].mx=val;
		SG[pt].mi=val;
		return;
	}
	upd(2*pt+1,pos,val);
	upd(2*pt+2,pos,val);
	SG[pt].mx=max(SG[2*pt+1].mx,SG[2*pt+2].mx);
	SG[pt].mi=min(SG[2*pt+1].mi,SG[2*pt+2].mi);
}
int segTree::qmx(int pt,int qs,int qe)
{
	if(qs>SG[pt].r or qe<SG[pt].l) return -INF;
	if(SG[pt].l>=qs and SG[pt].r<=qe) return SG[pt].mx;
	return max(qmx(2*pt+1,qs,qe),qmx(2*pt+2,qs,qe));
}
int segTree::qmi(int pt,int qs,int qe)
{
	if(qs>SG[pt].r or qe<SG[pt].l) return INF;
	if(SG[pt].l>=qs and SG[pt].r<=qe) return SG[pt].mi;
	return min(qmi(2*pt+1,qs,qe),qmi(2*pt+2,qs,qe));
}