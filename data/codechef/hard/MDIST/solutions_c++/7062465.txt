#include<bits/stdc++.h>
#define intMAX 1123456789LL
#define MAX intMAX * intMAX
#define F first
#define S second
#define mp make_pair
#define ll long long
#define pb push_back
#define pv(v,b,a) v.insert(v.begin()+b,a)
#define all(c) c.begin(),c.end()
#define sf(a) scanf("%d",&a);
#define sl(a) scanf("%lld",&a);
#define MAXCR 1000000000
#define mem(arr,a) memset(arr, a, sizeof arr)
#define er(vec,a,b) vec.erase(vec.begin() + a, vec.begin() + b+1)
#define traverse(a) for()
#define pii pair<int ,int>
#define mod 1000000007
#define LIM 100
using namespace std;
/*
list as pop_front();push_front(ELEMENT);
list as pop_front();push_back(ELEMENT);
to see first element stack=q.front()
to see last element queue=q.back()
*/
//str.insert(6,str3,3,4); to insert 4 words from str3 starting from 3rd position(0 based indexing) to str from 6th position (0 based indexing)
//str.find("live");//finds first occurance of string and returns its 0 based indes
//string str1=str.substr (a,n);//a=0 based start index,n=length of words//if length not given substring till end is formed
//auto bound_=upper_bound (v.begin(), v.end(), 20); //Returns an iterator pointing to the first element in the range [first,last) which compares greater than val.
//auto bound_=lower_bound (v.begin(), v.end(), 20);//Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.
//for(???<???>:iterator itr;itr!=???.end();itr++) or for(auto &tt : t.edges)
//getline(cin,s,'\n');  to get input terminating at'\n';excluding '\n'
//(a/b)%m = ((a%m)(b^(m-2)%m))%m.
//(a^b)%m=
//vector<ll>v(size,default val);
vector<pair<ll ,ll> >v(100005);
typedef struct
{
	ll f1min;
	ll f1max;
	ll f2min;
	ll f2max;
	ll f3min;
	ll f3max;
	ll f4min;
	ll f4max;
}segnode;
segnode tree[500005];
segnode arrange(segnode s1,segnode s2)
{
	segnode s;
	s.f1min=min(s1.f1min,s2.f1min);
	s.f2min=min(s1.f2min,s2.f2min);
	s.f3min=min(s1.f3min,s2.f3min);
	s.f4min=min(s1.f4min,s2.f4min);
	s.f1max=max(s1.f1max,s2.f1max);
	s.f2max=max(s1.f2max,s2.f2max);
	s.f3max=max(s1.f3max,s2.f3max);
	s.f4max=max(s1.f4max,s2.f4max);
	return s;
}
void initialize(ll a,ll b,ll node)
{
	if(a>b)
		return ;
	if(a==b)
	{
		tree[node].f1min=v[a].F+v[a].S;
		tree[node].f1max=v[a].F+v[a].S;
		tree[node].f2min=-v[a].F-v[a].S;
		tree[node].f2max=-v[a].F-v[a].S;
		tree[node].f3min=-v[a].F+v[a].S;
		tree[node].f3max=-v[a].F+v[a].S;
		tree[node].f4min=v[a].F-v[a].S;
		tree[node].f4max=v[a].F-v[a].S;
		return ;
	}
	initialize(a,(a+b)/2,node*2);
	initialize((b+a)/2+1,b,node*2+1);
	tree[node]=arrange(tree[node*2],tree[node*2+1]);
}
segnode query(ll i,ll j,ll a,ll b,ll node)
{
	if(j<a||i>b)
	{
		segnode s;
		s.f1min=MAX;
		return s;			
	}
	if(a>=i&&b<=j)
	{
		return tree[node];
	}
	segnode s1=query(i,j,a,(a+b)/2,2*node);
	segnode s2=query(i,j,(a+b)/2+1,b,2*node+1);
	if(s1.f1min==MAX)
		return s2;
	if(s2.f1min==MAX)
		return s1;
	return arrange(s1,s2);
}
void update(ll i,ll j,ll a,ll b,ll node,pair<ll,ll> p)
{
	if(j<a||i>b)
		return ;
	if(a>=i&&b<=j)
	{
		tree[node].f1min=p.F+p.S;
		tree[node].f1max=p.F+p.S;
		tree[node].f2min=-p.F-p.S;
		tree[node].f2max=-p.F-p.S;
		tree[node].f3min=-p.F+p.S;
		tree[node].f3max=-p.F+p.S;
		tree[node].f4min=p.F-p.S;
		tree[node].f4max=p.F-p.S;
		return;
	}
	update(i,j,a,(a+b)/2,node*2,p);
	update(i,j,(a+b)/2+1,b,node*2+1,p);
	tree[node]=arrange(tree[node*2],tree[node*2+1]);
}
ll max_(ll a,ll b,ll c,ll d)
{
	return max(a,max(b,max(c,d)));
}
int main()
{
	ll i,n,a,b,ans,c,q;
	char ch;
	sl(n)
	for(i=1;i<=n;i++)
	{
		sl(a)
		sl(b)
		v[i]=mp(a,b);
	}
	initialize(1,n,1);
	sl(q)
	for(i=1;i<=q;i++)
	{
		cin>>ch;
		if(ch=='U')
		{
			sl(a)
			sl(b)
			sl(c)
			pair<int,int>p=mp(b,c);
			update(a+1,a+1,1,n,1,p);
		}	
		else
		{
			sl(a)
			sl(b)
			segnode s=query(a+1,b+1,1,n,1);
			ans=max_(s.f1max-s.f1min,s.f2max-s.f2min,s.f3max-s.f3min,s.f4max-s.f4min);
			printf("%lld\n",ans);	
		}	
	}
	return 0;
}