#include <stdio.h>
#include <iostream>
#include <algorithm>
#include <assert.h>
#include <vector>
using namespace std;
typedef long long lint;
const lint MOD = 1000003;
const int MAXP = 100;
 
lint power(lint x, lint n, lint mod){
  if(n==0) return 1%mod;
  if(n%2) return x * power(x, n-1, mod)%mod;
  lint y = power(x, n/2, mod);
  return y*y%mod;
}
 
int inverse(int x, int p){
  return power(x, p-2, p);
}
 
int inv[MAXP+1];
vector<int> baseP(lint x, int p){
  vector<int> ret;
  while(x) ret.push_back(x%p), x/=p;
  reverse(ret.begin(),ret.end());
  return ret;
}
 
int p;
lint choose(lint n, lint r){
  assert(0 <= r && r < p);
  lint ret = 1;
  for(int i=0;i<r;++i)
    ret = ret*((n-i)%MOD)%MOD*inv[i+1]%MOD;
  return ret;
}
 
lint F(lint n, lint k){
  assert(0 <= n && n < p);
  assert(k >= 1);
  return choose(n+k-1,n);
}
 
vector<int> X;
vector<int> P;
lint D[MAXP+1];
 
lint doit(int x, lint k){
  if(x==X.size()) return 1;
  lint t = X[x];
  lint A = D[t] * P[x];
  lint B = F(t, k) * doit(x+1,k);
  return (A + B)%MOD;
}
void solveCase(lint n, lint k){
  if(p==1) {
    cout<<0<<endl;
    return;
  }
 
  X = baseP(n, p);
  lint C = 0;
  for(int i=0;i<p;++i) {
    C = (C + F(i, k))%MOD;
    D[i+1] = C;
  }
  P.clear(); P.push_back(1); while(P.size() < X.size()) P.push_back(P.back() * C % MOD); reverse(P.begin(),P.end());
 
  lint ret = doit(0, k);
  cout<<ret<<endl;
}
 
bool isPrime(int x){
  for(int i=2;i*i<=x;++i) if(x%i==0) return false;
  return true;
}
 
void init(){
  assert(isPrime(MOD));
  for(int i=1;i<=MAXP;++i)
    inv[i] = inverse(i, MOD);
}
 
const int MAXCASES = 10000;
const lint MAXN = 1000000000000000LL;
const lint MAXK = 1000000000000000LL;
void checkInput(lint n, lint k,lint p){
  assert(0 <= n && n <= MAXN);
  assert(1 <= k && k <= MAXK);
  assert(1 <= p && p <= MAXP);
  assert(isPrime(p));
}
 
main(){
  init();
  int cases; cin>>cases;
  assert(1 <= cases && cases <= MAXCASES);
  while(cases--){
    lint n,k;
    cin>>n>>k>>p;
    checkInput(n,k,p);
    solveCase(n,k);
  }
}
