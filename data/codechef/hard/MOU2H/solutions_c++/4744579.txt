#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0);cin.tie(0);

using namespace std;


#define ll long long
#define ff first
#define ss second
#define mpa make_pair
#define MOD 1000000009
#define pb push_back
#define lld I64d
#define MXN 1000000

int bitcnt(int mask){return __builtin_popcount(mask);}
int SET(int N,int pos){	return N=N | (1<<pos);}
int RESET(int N,int pos){	return N= N & ~(1<<pos);}
int check(int N,int pos){	return (N & (1<<pos));}
int toggle(int N,int pos){if(check(N,pos))return N=RESET(N,pos);return N=SET(N,pos);}
void PRINTBIT(int N){	printf("("); for(int i=6;i>=1;i--)	{bool x=check(N,i);cout<<x;}	puts(")");}
int mod(int a, int b) { return a - a/b * b;}

ll Dp[MXN];
ll Arr[MXN];
vector<ll> vec;
int N;
int last[8*MXN];

ll minn;
ll mxx;

 
inline void inp(int &n) {
  n = 0;
  int ch = getchar_unlocked();
  int sign = 1;
  while(ch < '0' || ch > '9') {
    if (ch == '-') sign = -1; 
    ch = getchar_unlocked();
  }
  while(ch >= '0' && ch <= '9')
    n = (n<<3) + (n<<1) + ch - '0', ch = getchar_unlocked();
  n = n*sign;
}


inline void inpl(ll &n) {
  n = 0;
  int ch = getchar_unlocked();
  int sign = 1;
  while(ch < '0' || ch > '9') {
    if (ch == '-') sign = -1; 
    ch = getchar_unlocked();
  }
  while(ch >= '0' && ch <= '9')
    n = (n<<3) + (n<<1) + ch - '0', ch = getchar_unlocked();
  n = n*sign;
}
 
inline void outp(ll a) {
  char c;
  char snum[20];
  int i=0;
  do {
    snum[i++]=a%10+48;
    a=a/10;
  } while(a!=0);
  i=i-1;
  while(i>=0)
    putchar_unlocked(snum[i--]);
  putchar_unlocked('\n');
}
 
static inline void dump(int a[], int n) {
  int i = 0;
  fprintf(stderr, "line-dump: ");
  while (i < n) fprintf(stderr, "%d ", a[i++]);
  fprintf(stderr, "\n");
}

ll mx;


int main()
{
	mx = (4*MXN);
	
	int T;
	inp(T);
	
	while(T--) {
		
		inp(N);
		
		for(int i = 0; i < N; ++i) {
			inpl(Arr[i]);
		}
		
		vec.clear();
		for(int i = 1; i < N; ++i) {
			ll data = Arr[i] - Arr[i - 1];
			last[mx + data] = 0;
			
			vec.pb(data);
		}
		
		fill(Dp, Dp + (N + 2), 0);
		
		Dp[0] = 1;
		
		for(int i = 1; i <= N - 1; ++i) {
			Dp[i] = (Dp[i - 1] << 1);
			if(Dp[i] >= MOD)
				Dp[i] %= MOD;
			
			int pos = last[(vec[i - 1] + mx)];
			if(pos != 0) {
				Dp[i] = Dp[i] - Dp[pos - 1];
				if(Dp[i] < 0)
					Dp[i] += MOD;
			}
			last[(vec[i - 1] + mx)] = i;
		}
		Dp[N - 1] -= 1;
		if(Dp[N - 1] < 0)
			Dp[N - 1] += MOD;
		
		outp(Dp[N - 1]);
	}
	
	return 0;
}
