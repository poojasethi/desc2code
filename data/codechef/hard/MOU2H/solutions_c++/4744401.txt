#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0);cin.tie(0);

using namespace std;


#define ll long long
#define ff first
#define ss second
#define mpa make_pair
#define MOD 1000000009
#define pb push_back
#define lld I64d
#define MXN 1000000

int bitcnt(int mask){return __builtin_popcount(mask);}
int SET(int N,int pos){	return N=N | (1<<pos);}
int RESET(int N,int pos){	return N= N & ~(1<<pos);}
int check(int N,int pos){	return (N & (1<<pos));}
int toggle(int N,int pos){if(check(N,pos))return N=RESET(N,pos);return N=SET(N,pos);}
void PRINTBIT(int N){	printf("("); for(int i=6;i>=1;i--)	{bool x=check(N,i);cout<<x;}	puts(")");}
int mod(int a, int b) { return a - a/b * b;}

ll Dp[MXN];
ll Arr[MXN];
vector<ll> vec;
int N;
int last[8*MXN];

ll minn;
ll mxx;

void inp()
{
	scanf("%d", &N);
	
	for(int i = 0; i < N; ++i) {
		scanf("%lld", &Arr[i]);
	}
	
	vec.clear();
	for(int i = 1; i < N; ++i) {
		ll data = Arr[i] - Arr[i - 1];
		last[(4*MXN) + data] = 0;
		
		vec.pb(data);
	}
}

void solve()
{
	fill(Dp, Dp + (N + 2), 0);
	
	Dp[0] = 1;
	
	int n = vec.size();
	
	for(int i = 1; i <= n; ++i) {
		Dp[i] = (Dp[i - 1] << 1);
		if(Dp[i] >= MOD)
			Dp[i] %= MOD;
		
		int pos = last[(vec[i - 1] + (4*MXN))];
		if(pos != 0) {
			Dp[i] = Dp[i] - Dp[pos - 1];
			if(Dp[i] < 0)
				Dp[i] += MOD;
		}
		last[(vec[i - 1] + (4*MXN))] = i;
	}
	Dp[n] -= 1;
	if(Dp[n] < 0)
		Dp[n] += MOD;
	
	printf("%lld\n", Dp[n]);
}

int main()
{
	int T;
	scanf("%d", &T);
	
	while(T--) {
		inp();
		solve();
	}
	
	return 0;
}
