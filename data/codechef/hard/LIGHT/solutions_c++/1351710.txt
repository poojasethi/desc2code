#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <algorithm>
#include <functional>
#include <numeric>
#include <map>
#include <set>
#include <list>
#include <vector>
#include <stack>
#include <queue>
#include <bitset>
#include <iterator>
#include <cstring>
#include <climits>
#include <cmath>
#include <cassert>

using namespace std;

#define ALL(x) x.begin(),x.end()
#define REP(i,n) for (int i=0; i<(n); ++i)
#define FOR(var,start,end) for (int var=(start); var<=(end); ++var)
#define FORD(var,start,end) for (int var=(start); var>=(end); --var)
#define FOREACH(it, X) for(__typeof((X).begin()) it = (X).begin(); it != (X).end(); ++it)
#define PB push_back
#define PF push_front
#define MP(a,b) make_pair(a,b)
#define ST first
#define ND second
#define SIZE(x) ((int)((x).size()))

// typedef long long LL;
typedef pair<int, int> PII;
typedef vector<int> VI;
typedef vector<bool> VB;
typedef vector< vector<int> > VVI;
typedef vector< vector<bool> > VVB;

static const double EPS = 1e-10;
static const int MAXN = 50000;

static int N;
static double L, R;
static double X[MAXN], Y[MAXN], Z[MAXN];

struct IntersectionPoint {
    double x, y;
    int delta;

    bool operator<(const IntersectionPoint &rhs) const {
        return x < rhs.x || (x == rhs.x && y < rhs.y);
    }
};

static IntersectionPoint intersectionPoints[2*MAXN];

static inline bool good(double height) {
    int nIntersectionPoints = 0;
    REP (i, N) if (height <= Y[i]) {
        double deltaX = (Y[i] - height) * tan(Z[i]);
        intersectionPoints[nIntersectionPoints].x = X[i] - deltaX;
        intersectionPoints[nIntersectionPoints].y = Y[i];
        intersectionPoints[nIntersectionPoints].delta = 1;
        ++nIntersectionPoints;
        intersectionPoints[nIntersectionPoints].x = X[i] + deltaX;
        intersectionPoints[nIntersectionPoints].y = Y[i];
        intersectionPoints[nIntersectionPoints].delta = -1;
        ++nIntersectionPoints;
    }

    sort(intersectionPoints, intersectionPoints + nIntersectionPoints);

    if (nIntersectionPoints == 0 || L < intersectionPoints[0].x) {
        return false;
    }

    int activeSegments = 0;
    REP (i, nIntersectionPoints) {
        IntersectionPoint &p = intersectionPoints[i];
        activeSegments += p.delta;
        if (L <= p.x && p.x <= R && activeSegments == 0) {
            return false;
        }
    }

    return true;
}

int main(int argc, char *argv[]) {

    scanf("%d%lf%lf", &N, &L, &R);
    REP (i, N) {
        scanf("%lf%lf%lf", &X[i], &Y[i], &Z[i]);
        // degree to radian
        Z[i] = (Z[i] * M_PI) / 180.0;
    }

    double low = 0.0, high = 1000.0;
    while (abs(high - low) > EPS) {
        double middle = (high + low) / 2.0;
        if (good(middle)) {
            low = middle;
        } else {
            high = middle;
        }
    }

    printf("%.8f\n", (high + low) / 2.0);

    return 0;
}
