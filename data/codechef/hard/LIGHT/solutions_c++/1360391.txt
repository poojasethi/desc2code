#include <iostream>
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <cmath>
#define EPSILON 0.00000001
using namespace std;


struct light
{
	double x,y,z,ytan;
};

struct effect
{
	double l,r;
};

effect getBoundsOfLight(light l,double height)
{
	effect ret={0};
	double base=(l.y-height) * l.ytan;
	ret.l=l.x-base;
	ret.r=l.x+base;
	return ret;
}

bool inline isInLight(double h,double L,double R,light *l,int n)
{
	effect tmp;
	vector< pair<double,int> > m(2*n);
	m.push_back(make_pair(L,0));
	m.push_back(make_pair(R,0));
	for(int i=0;i<n;i++)
	{
		if(l[i].y > h)
		{
			tmp=getBoundsOfLight(l[i],h);
			m.push_back(make_pair(tmp.l,1));
			m.push_back(make_pair(tmp.r,-1));
		}
	}
	sort(m.begin(),m.end());
	
	vector< pair<double,int> >::iterator it=m.begin();
	int cnt=0;
	while(it!=m.end() && it->first <= L)
	{
		cnt+=it->second;
		it++;
	}
	while(it!=m.end() && it->first <= R && cnt)
	{
		cnt+=it->second;
		it++;
	}
	return cnt!=0;
}

int main()
{
	int n;
	scanf("%d",&n);
	
	double L,R;
	scanf("%lf",&L);
	scanf("%lf",&R);

	light l[n];
	//loop and remove irrelevant lights while input
	int cnt=0;
	double maxy=-10001;
	effect tmp;
	while(n--)
	{
		scanf("%lf",&l[cnt].x);
		scanf("%lf",&l[cnt].y);
		scanf("%lf",&l[cnt].z);
		l[cnt].ytan=tan((3.14159265/180.0) * l[cnt].z);
		tmp=getBoundsOfLight(l[cnt],0);
		if(maxy < l[cnt].y)
				maxy=l[cnt].y;
		/*if( !(tmp.r < L || tmp.l > R) )
		{
			
			cnt++;
		}*/
		cnt++;
	}
	
	//binary search
	double start=0,end=maxy;
	double newmid=(start+end)/2;
	
	while(end-start > EPSILON)
	{
		
		//cout<<"checking height : "<<newmid<<endl;
		if(isInLight(newmid,L,R,l,cnt))
		{
			//go up
			//cout<<"Is In Light goin UP"<<endl;
			start=newmid;
		}
		else
		{
			//go down
			//cout<<"Is NOT In Light goin DOWN"<<endl;
			end=newmid;
		}
		newmid=(start+end)/2;
		//cout<<mid<<" "<<newmid<<endl;
	}
	printf("%.10lf\n",newmid);
	return 0;
}
