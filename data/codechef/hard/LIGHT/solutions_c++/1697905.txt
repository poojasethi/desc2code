#include <cstdio>
#include <utility>
#include <cmath>
#include <algorithm>

using namespace std;

#define abs(x) ((X)<0 ? -(x) : (x))
#define MXN 50000
const double PI = acos(-1.0);
const double EPS = 1e-9;

int N;
double X[MXN], Y[MXN], Z[MXN], L, R;
pair<double, int> segmentPoints[2*MXN];

bool ok(double H);

int main()
{
    scanf("%d %lf %lf", &N, &L, &R);
    for(int i=0; i<N; i++) scanf("%lf %lf %lf", &X[i], &Y[i], &Z[i]);
    for(int i=0; i<N; i++) Z[i] = Z[i] * PI / 180.0;

    double low = 0, high = 1000;
    double mid = (high + low)/2.0;
    while(high-low> EPS) {
        if(ok(mid)) low = mid;
        else high = mid;
        mid = (high+low)/2.0;
    }

    printf("%.10lf\n", low);
}

bool ok(double H)
{
    int pts = 0;
    segmentPoints[pts++] = make_pair(L, 0);
    segmentPoints[pts++] = make_pair(R, 0);
    for(int i=0; i<N; i++) if(H <= Y[i]) {
        double dx = (Y[i] - H) * tan(Z[i]);
        segmentPoints[pts++] = make_pair(X[i]-dx, 1);
        segmentPoints[pts++] = make_pair(X[i]+dx, -1);
    }

    if(pts == 0) return 0;

    sort(segmentPoints, segmentPoints+pts);

    int  cnt = 0;
    double x;
    for(int i=0; i<pts; ) {
        x = segmentPoints[i].first;
        if(x-EPS>=L && x-EPS<=R && cnt==0) return 0;
        while(i<pts && segmentPoints[i].first-x<=EPS) cnt+=segmentPoints[i++].second;
    }
    return 1;
}
