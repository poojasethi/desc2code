#include<iostream>
#include<stdio.h>
#include<assert.h>
#include<string.h>
#include<time.h>
#include<stdlib.h>
#include<math.h>
#include<string>
#include<sstream>
#include<map>
#include<set>
#include<queue>
#include<stack>
#include<vector>
#include<algorithm>
#pragma comment(linker, "/STACK:16777216")
#define pb push_back
#define ppb pop_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()
#define LL long long
#define bit __builtin_popcountll
#define sqr(x) (x) * (x)
using namespace std;
typedef pair<int, int> pii;
const double eps = 1e-9;
const double pi = acos(-1.0);
const int maxn = (int)5e4 + 10;
int n;
double L,R,down = 0.0,up = 0.0;
double x[maxn],y[maxn],z[maxn],lx[maxn],rx[maxn];
bool intersect(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4, double &x, double &y)
{
	double a1 = y2 - y1;
	double b1 = x1 - x2;
	double c1 = a1 * x1 + b1 * y1;
	double a2 = y4 - y3;
	double b2 = x3 - x4;
	double c2 = a2 * x3 + b2 * y3;
	double det = a1 * b2 - a2 * b1;
	if (fabs(det) < eps) return false;
	double detx = c1 * b2 - c2 * b1;
	double dety = a1 * c2 - c1 * a2;
	x = detx / det;
	y = dety / det;
	return true;
}
bool can(double h)
{
	vector< pair<double, double> > v;
	for(int i = 0; i < n; i++)
	{
		if (y[i] < h - eps) continue;
		double X1,Y1,X2,Y2;
		intersect(L,h,R,h,lx[i],0,x[i],y[i],X1,Y1);
		intersect(L,h,R,h,rx[i],0,x[i],y[i],X2,Y2);
		if (X1 < L - eps) X1 = L;
		if (X2 > R + eps) X2 = R;
		if (X1 > X2 + eps) continue;
		v.pb(mp(X1,X2));
	}
	sort(all(v));
	if (v.empty()) return false;
	if (v[0].first > L + eps) return false;
	double ma = v[0].first;
	for(int i = 0; i < sz(v); i++)
	{
		if (ma < v[i].first - eps) return false;
		ma = max(ma,v[i].second);
	}
	if (ma < R - eps) return false;
	return true;
}
int main()
{
	#ifndef ONLINE_JUDGE
	//freopen("input.txt","r",stdin);
	//freopen("output.txt","w",stdout);
	#endif	
	cin>>n>>L>>R;
	for(int i = 0; i < n; i++)
	{
		scanf("%lf%lf%lf",&x[i],&y[i],&z[i]);
		up = max(up,y[i]);
		z[i] = z[i] * pi / 180.0;
		lx[i] = x[i] - y[i] * tan(z[i]);
		rx[i] = x[i] + y[i] * tan(z[i]);
	}
	for(int it = 0; it < 150; it++)
	{
		double mid = (up + down) / 2.0;
		if (can(mid)) down = mid; else up = mid;
	}
	printf("%.9lf\n",up);
	return 0;
}
