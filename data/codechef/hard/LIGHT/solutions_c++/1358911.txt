#include <cmath>
#include <ctime>
#include <iostream>
#include <string>
#include <vector>
#include<cstdio>
#include<sstream>
#include<algorithm>
#include<cstdlib>
#include<cstring>
#include<map>
#include<cctype>
using namespace std;
#define pb push_back
#define all(s) s.begin(),s.end()
#define f(i,a,b) for(int i=a;i<b;i++)
#define F(i,a,b) for(int i=a;i>=b;i--)
#define PI 3.1415926535897932384626433832795
#define INF 1000000005
#define BIG_INF 7000000000000000000LL
#define mp make_pair
#define eps 1e-9
#define ll long long


int n;
double L,R,X[50005],Y[50005],AG[50005];

bool check(double h)
{
    vector<pair<double,double> > A;
    f(i,0,n)
    {
        if(h+eps<=Y[i]){
        A.pb(mp(X[i]-(Y[i]-h)*tan(AG[i]),X[i]+(Y[i]-h)*tan(AG[i])));
    }}
    sort(all(A));
    if(A.empty()) return false;
    double cur_l,cur_r;
    cur_l=A[0].first;
    cur_r= A[0].second;
     f(i,1,A.size())
    {
        if(A[i].first+eps<=cur_r)
        {
            cur_r=max(cur_r,A[i].second);
        }
        else
        {
            if(L>=cur_l+eps && R+eps<=cur_r)
            {
                return true;
            }
            cur_l=A[i].first;
            cur_r=A[i].second;
        }
    }
    return (L>=cur_l+eps && R+eps<=cur_r);
}




int main()
{
    //cin>>n;
    //cin>>L>>R;
    scanf("%d%lf%lf",&n,&L,&R);
    f(i,0,n)
    {
        //cin>>X[i]>>Y[i]>>AG[i];
        scanf("%lf%lf%lf",&X[i],&Y[i],&AG[i]);
        AG[i]= (AG[i]/180.0)*PI;
    }
    //Binary search
    //low would always be smaller than high
    // and everytime the pair (low,high) would be unique
    //you can be sure that in 64 iterations u would get a very correct value
    double low=-1.0,high=1000.0,mid;
    f(i,0,65){
    mid= (low+high)/2.0;
    if(check(mid))
    {
        low=mid;
    }
    else
    {
        high=mid;
    }
    }
    printf("%.10lf\n",mid);
}
