#include<bits/stdc++.h>
using namespace std;
struct node
{
    int a;
    int b;
    int c;
};
node tree[300000];
int lazy[300000];
int temp;
inline void fast( int &x) {
    int c = getchar_unlocked();
    x = 0;
    int neg = 0;
    
    for(; ((c<48 || c>57) && c != '-'); c = getchar_unlocked());
    
    if(c=='-') {
        neg = 1;
        c = getchar_unlocked();
    }
    
    for(; c>47 && c<58 ; c = getchar_unlocked()) {
        x = (x<<1) + (x<<3) + c - 48;
    }
    
    if(neg)
        x = -x;
}
void buildtree(int node,int l,int r)
{
    if(l>r)
        return ;
    else if(l==r)
    {
        tree[node].a=tree[node].b=0;
        tree[node].c=1;
        lazy[node]=0;
        return ;
    }
    buildtree(2*node,l,(l+r)/2);
    buildtree(1+2*node,(l+r)/2+1,r);
    tree[node].a=tree[2*node].a+tree[2*node+1].a;
    tree[node].b=tree[2*node].b+tree[2*node+1].b;
    tree[node].c=tree[2*node].c+tree[2*node+1].c;
    lazy[node]=lazy[2*node]+lazy[1+2*node];
}/*
int getmultiple(int node,int l,int r,int i,int j)
{
    if(l>r||i>r||j<l)
        return 0;
    if(lazy[node]!=0)
    {
       // lazy[node]%=3;
        if(lazy[node]==1)
        {
            temp=tree[node].a;
            tree[node].a=tree[node].c;
            tree[node].c=tree[node].b;
            tree[node].b=temp;

        }
        if(lazy[node]==2)
        {
            temp=tree[node].a;
            tree[node].a=tree[node].b;
            tree[node].b=tree[node].c;
            tree[node].c=temp;

        }
        if(l!=r)
        {
            lazy[2*node]=(lazy[2*node]+lazy[node])%3;
            lazy[2*node+1]=(lazy[2*node+1]+lazy[node])%3;
        }
        lazy[node]=0;
    }
    if(l<=i&&j>=r)
        return tree[node].c;
    return getmultiple(2*node,l,(l+r)/2,i,j)+getmultiple(2*node+1,(l+r)/2+1,r,i,j);
}*/
int query_tree(int node, int l, int r, int i, int j) {

	if(l > r || l> j || r < i) return 0; // Out of range

	if(lazy[node] != 0) { // This node needs to be updated
        if(lazy[node]==1)
        {
            temp=tree[node].a;
            tree[node].a=tree[node].c;
            tree[node].c=tree[node].b;
            tree[node].b=temp;

        }
        if(lazy[node]==2)
        {
            temp=tree[node].a;
            tree[node].a=tree[node].b;
            tree[node].b=tree[node].c;
            tree[node].c=temp;

        }
        if(l!=r)
        {
            lazy[2*node]=(lazy[2*node]+lazy[node])%3;
            lazy[2*node+1]=(lazy[2*node+1]+lazy[node])%3;
        }
        lazy[node]=0;
    }
		/*tree[node] += lazy[node]; // Update it

		if(a != b) {
			lazy[node*2] += lazy[node]; // Mark child as lazy
			lazy[node*2+1] += lazy[node]; // Mark child as lazy
		}

		lazy[node] = 0; // Reset it*/

	if(l >= i && r <= j) // Current segment is totally within range [i, j]
		return tree[node].c;

	int q1 = query_tree(node*2, l, (l+r)/2, i, j); // Query left child
	int q2 = query_tree(1+node*2, 1+(l+r)/2, r, i, j); // Query right child

	int res =q1+ q2; // Return final result

	return res;
}

void update(int node,int l,int r,int i,int j)
{
    if(lazy[node]!=0)
    {
        lazy[node]%=3;
        if(lazy[node]==1)
        {
            temp=tree[node].a;
            tree[node].a=tree[node].c;
            tree[node].c=tree[node].b;
            tree[node].b=temp;

        }
        if(lazy[node]==2)
        {
            temp=tree[node].a;
            tree[node].a=tree[node].b;
            tree[node].b=tree[node].c;
            tree[node].c=temp;

        }
         if(l!=r){
                lazy[2*node]=(lazy[2*node]+lazy[node])%3;
                lazy[2*node+1]=(lazy[2*node+1]+lazy[node])%3;}
        lazy[node]=0;
    }
    if(l>r||i>r||j<l)
        return ;
    if(l>=i&&r<=j)
    {
        temp=tree[node].a;
        tree[node].a=tree[node].c;
        tree[node].c=tree[node].b;
        tree[node].b=temp;
        if(l!=r)
        {
            lazy[2*node]=(lazy[2*node]+1)%3;
            lazy[2*node+1]=(lazy[2*node+1]+1)%3;
        }
        return ;
    }
    update(2*node,l,(l+r)/2,i,j);
    update(2*node+1,(l+r)/2+1,r,i,j);
    tree[node].a=tree[node*2].a+tree[1+2*node].a;
    tree[node].b=tree[node*2].b+tree[1+2*node].b;
    tree[node].c=tree[node*2].c+tree[1+2*node].c;
}
int main()
{
    int i,n,q,choice,left,right;
    fast(n);
    fast(q);
    //scanf("%d %d",&n,&q);
    buildtree(1,0,n-1);
    
    while(q--)
    {
       fast(choice);
       fast(left);
       fast(right);
       // scanf("%d %d %d",&choice,&left,&right);
        if(choice==0)
        {
            update(1,0,n-1,left,right);
        }
        else
        {
            printf("%d\n",query_tree(1,0,n-1,left,right));        }
    }
    return 0;

}
