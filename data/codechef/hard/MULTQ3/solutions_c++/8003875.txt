#include<iostream>
#include<algorithm>
#include<string.h>
#include<math.h> 
#include<stdio.h>
#include<vector>
using namespace std;
#define inf 0x7fffffff
struct Node{
	int md[3];
	Node(){
		md[0] = 1;
		md[1] = md[2] = 0;
	}
	void add(){
		int temp = md[0];
		md[0] = md[2];
		md[2] = md[1];
		md[1] = temp;
	}
	void addVal(int val){
		val %= 3;
		while (val--) add();
	}
};
Node merge(Node a, Node b){
	Node c;
	for (int i = 0; i < 3; i++)c.md[i] = a.md[i] + b.md[i];
	return c;
}
class SegmentTree{
public:
	vector<Node> arr;
	vector<Node> tree;
	vector<int> lazy;
	SegmentTree(int N){
		arr.assign(N, Node());
		tree.assign(4 * N + 10, Node());
		lazy.assign(4 * N + 10, 0);
	}
	void build_tree(int node, int a, int b) {
		if (a > b) return;
		if (a == b) {
			tree[node] = arr[a];
			return;
		}
		build_tree(node * 2, a, (a + b) / 2);
		build_tree(node * 2 + 1, 1 + (a + b) / 2, b);
		tree[node] = merge(tree[node * 2], tree[node * 2 + 1]);
	}
	void update_tree(int node, int a, int b, int i, int j, int value) {
		if (lazy[node] != 0) {
			tree[node].addVal(lazy[node]);
			if (a != b) { // a!=b mean has children :D 
				lazy[node * 2] += lazy[node];
				lazy[node * 2 + 1] += lazy[node];
			}
			lazy[node] = 0;
		}
		if (a > b || a > j || b < i)  return;
		if (a >= i && b <= j) {
			tree[node].addVal(value);
			if (a != b) {
				lazy[node * 2] += value; // to be updated in the next
				lazy[node * 2 + 1] += value;
			}
			return;
		}
		update_tree(node * 2, a, (a + b) / 2, i, j, value);
		update_tree(1 + node * 2, 1 + (a + b) / 2, b, i, j, value);
		tree[node] = merge(tree[node * 2], tree[node * 2 + 1]);
	}
	int query_tree(int node, int a, int b, int i, int j) {
		if (a > b || a > j || b < i) return 0;
		if (lazy[node] != 0) {
			tree[node].addVal(lazy[node]);
			if (a != b) {
				lazy[node * 2] += lazy[node];
				lazy[node * 2 + 1] += lazy[node];
			}
			lazy[node] = 0;
		}
		if (a >= i && b <= j)
			return tree[node].md[0];
		int q1 = query_tree(node * 2, a, (a + b) / 2, i, j);
		int q2 = query_tree(1 + node * 2, 1 + (a + b) / 2, b, i, j);
		int res = q1+q2;
		return res;
	}
};
inline int inp()
{
	int noRead = 0;
	char p = getchar_unlocked();
	for (; p<33;)
	{
		p = getchar_unlocked();
	};
	while (p>32)
	{
		noRead = (noRead << 3) + (noRead << 1) + (p - '0');
		p = getchar_unlocked();
	}
	return noRead;
};
char ob[2048], *at = ob, *end = ob + 2048 - 1;
void flush_buffer()
{
	fwrite(ob, 1, at - ob, stdout);
	at = ob;
}
void buffer(int k)
{
	if (at + 10 > end) flush_buffer();
	int d[10], dc = 0;
	if (k < 0) *at++ = '-', k = -k;
	if (k == 0) d[dc++] = 0;
	while (k) d[dc++] = k % 10, k /= 10;
	for (int k = dc; k--; *at++ = d[k] + '0');
	*at++ = 10;
}
int main() {
	int n, m;
	n = inp();
	m = inp();
	SegmentTree s(n);
	s.build_tree(1, 0, n-1);
	while (m--){
		int a, b, c;
		a = inp();
		b = inp();
		c = inp();
		if (a == 1){

			buffer(s.query_tree(1, 0, n - 1, b, c));
			flush_buffer();
		}
		else{
			s.update_tree(1, 0, n-1, b, c, 1);
		}
	}	
}