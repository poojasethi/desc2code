#include <bits/stdc++.h>
using namespace std;
typedef struct {
	int zero;
	int one;
	int two;
}node;
vector<node> segTree;
vector<int> lazy;
inline void fast_read(int *number){
	
	*number=0;
	
	register char currentChar=getchar_unlocked();
	
	while(currentChar<'0'||currentChar>'9')
	   currentChar=getchar_unlocked();
	   
	while(currentChar>='0'&&currentChar<='9'){
		
		*number=*number*10+currentChar-'0';
		currentChar=getchar_unlocked();
		
	}   
	
}
/*Segment tree and lazytree initialised*/
void init(int n) {
	segTree.resize(6*n);
	lazy.resize(6*n);
}
void buildTree(int l,int r,int node) {
	if(l > r) 
		return;
	if(l == r) {
		segTree[node].zero = 1;
		segTree[node].one = segTree[node].two = 0;
	}
	else {
		int mid = (l+r)/2;
		buildTree(l,mid,2*node);
		buildTree(mid+1,r,2*node+1);
		segTree[node].zero = segTree[2*node].zero + segTree[2*node+1].zero;
		segTree[node].one = segTree[node].two = 0;
	}
}
void update(int lQ,int rQ,int l,int r,int node) {
	if(lazy[node]) {
		if(lazy[node] == 1) {
			swap(segTree[node].zero,segTree[node].one);
			swap(segTree[node].zero,segTree[node].two);
		}
		else if(lazy[node] == 2) {
			swap(segTree[node].zero,segTree[node].two);
			swap(segTree[node].zero,segTree[node].one);
		}
		if(l != r) {
			lazy[2*node] += lazy[node];
			lazy[2*node+1] += lazy[node];
 
			lazy[2*node] %= 3;
			lazy[2*node+1] %= 3; 
		}
		lazy[node] = 0;
	}
	if(l>r or lQ>r or rQ<l) return;
	if(l>=lQ and r<=rQ) {
		swap(segTree[node].zero,segTree[node].one);
		swap(segTree[node].zero,segTree[node].two);
 
		if(l!=r) {
			lazy[2*node] += 1;
			lazy[2*node+1] += 1;
 
			lazy[2*node] %= 3;
			lazy[2*node+1] %= 3;
		}
		return;
	}
	int mid = (l+r)/2;
	update(lQ,rQ,l,mid,2*node);
	update(lQ,rQ,mid+1,r,2*node+1);
 
	segTree[node].zero = segTree[2*node].zero + segTree[2*node+1].zero;
	segTree[node].one = segTree[2*node].one + segTree[2*node+1].one;
	segTree[node].two = segTree[2*node].two + segTree[2*node+1].two;
}
int query(int lQ,int rQ,int l,int r,int node) {
	if(lazy[node]) {
		if(lazy[node] == 1) {
			swap(segTree[node].zero,segTree[node].one);
			swap(segTree[node].zero,segTree[node].two);
		}
		else if(lazy[node] == 2) {
			swap(segTree[node].zero,segTree[node].two);
			swap(segTree[node].zero,segTree[node].one);
		}
		if(l != r) {
			lazy[2*node] += lazy[node];
			lazy[2*node+1] += lazy[node];
 
			lazy[2*node] %= 3;
			lazy[2*node+1] %= 3; 
		}
		lazy[node] = 0;
	}
	if(l>r or lQ>r or rQ<l) return 0;
	if(l >= lQ and r <= rQ) return segTree[node].zero;
	int mid = (l+r)/2;
	return (query(lQ,rQ,l,mid,2*node) + query(lQ,rQ,mid+1,r,2*node+1));
}
int main() {
	int tot_ele,queries,qtype,a,b;
	fast_read(&tot_ele);
	fast_read(&queries);
	init(tot_ele);
	buildTree(1,tot_ele,1);
	while(queries--) {
		fast_read(&qtype);
		fast_read(&a);
		fast_read(&b);
		a++;
		b++;
		if(qtype) printf("%d\n",query(a,b,1,tot_ele,1));
		else update(a,b,1,tot_ele,1);
	}
	return 0;
}