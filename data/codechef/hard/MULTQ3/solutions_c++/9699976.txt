#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5;
const int mod = 20011;
inline long long add(long long u , long long v , long long mod){
    return (u%mod + v%mod) % mod;
}
inline long long mul(long long u , long long v , long long mod){
    return (u % mod * v % mod) % mod;
}
inline long long sub(long long u , long long v , long long md){
    return(u - v + md) % md;
}
int n , q , u , v , type;
int a[N];
int tree[N << 2LL][3];
int lazy[N << 2LL];
inline void build(int node , int u , int v){
    if(u > v) return;
    if(u == v){
        tree[node][a[u] % 3]++;
        return;
    }
    build(2 * node , u , (u + v) / 2 );
    build(1 + (2 * node) , 1 + ( (u + v) / 2) , v );
    for(int i = 0; i < 3; ++i){
        tree[node][i] = tree[2 * node][i] + tree[1 + (2 * node)][i];
    }
}
inline void update(int node , int u , int v , int l , int r , int val){
    if(lazy[node] != 0){
        if(lazy[node] == 1){
            int tmp = tree[node][0];
            tree[node][0] = tree[node][2];
            tree[node][2] = tree[node][1];
            tree[node][1] = tmp;
        }else if(lazy[node] == 2){
            int tmp = tree[node][0];
            tree[node][0] = tree[node][1];
            tree[node][1] = tree[node][2];
            tree[node][2] = tmp;
        }
        if(u != v){
            lazy[2 * node] = (lazy[2 * node] + lazy[node]) % 3;
            lazy[1 + (2 * node)] = (lazy[1 + (2 * node)] + lazy[node]) % 3;
        }
        lazy[node] = 0;
    }
    if(u > v || u > r || v < l) return;
    if(u >= l && v <= r){
            int tmp = tree[node][0];
            tree[node][0] = tree[node][2];
            tree[node][2] = tree[node][1];
            tree[node][1] = tmp;
            if(u != v){
                lazy[2 * node] = (lazy[2 * node] + 1) % 3;
                lazy[1 + (2 * node)] = (lazy[1 + (2 * node)] + 1) % 3;
            }
            return;
    }
    update(2 * node , u , (u + v) / 2 , l , r , val);
    update(1 + (2 * node) , 1 + ( (u + v) / 2) , v , l , r , val);
    for(int i = 0; i < 3; ++i){
        tree[node][i] = tree[2 * node][i] + tree[1 + (2 * node)][i];
    }
}
inline int query(int node , int u , int v , int l , int r){
    if(lazy[node] != 0){
        if(lazy[node] == 1){
            int tmp = tree[node][0];
            tree[node][0] = tree[node][2];
            tree[node][2] = tree[node][1];
            tree[node][1] = tmp;
        }else if(lazy[node] == 2){
            int tmp = tree[node][0];
            tree[node][0] = tree[node][1];
            tree[node][1] = tree[node][2];
            tree[node][2] = tmp;
        }
        if(u != v){
            lazy[2 * node] = (lazy[2 * node] + lazy[node]) % 3;
            lazy[1 + (2 * node)] = (lazy[1 + (2 * node)] + lazy[node]) % 3;
        }
        lazy[node] = 0;
    }
    if(u > v || u > r || v < l) return 0;
    if(u >= l && v <= r) return tree[node][0];
    return(query(2 * node , u , (u + v) / 2 , l , r) + query(1 + (2 * node) , 1 + (u + v) / 2 , v , l , r));
}
int main(){
    memset(a , 0 , sizeof a);
    memset(lazy , 0 , sizeof lazy);
    memset(tree , 0 , sizeof tree);
    scanf("%d %d", &n , &q);
    build(1 , 0 , n - 1);
    while(q--){
        scanf("%d %d %d", &type , &u , &v);
        if(!type){
            update(1 , 0 , n - 1 , u , v , 1);
        }else{
            printf("%d\n" , query(1 , 0 , n - 1 , u , v ) );
        }
    }
    return 0;
}
