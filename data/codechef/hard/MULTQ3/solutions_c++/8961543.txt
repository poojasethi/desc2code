# include <bits/stdc++.h>
# define mod 1000000007
# define rep(i,a,b) for(i=a;i<=b;i++)
# define repd(i,a,b) for(i=a;i>=b;i--)
# define saaf(h) (h).clear()
# define pb push_back
# define mp make_pair

using namespace std;
typedef long long ll;

struct node{ 
	int c[3];
	int mov;
} tree[4*100005];

void build(int root,int l, int r) {
	if (l > r) return;
	if (l==r) {
		tree[root].c[0]=1;
		tree[root].c[1]=0;
		tree[root].c[2]=0;
		tree[root].mov=0;
		return;
	}
	int x = root<<1;
	int mid = (l+r)>>1;
	build(x,l,mid);
	build(x+1,mid+1,r);
	tree[root].c[0] = tree[x].c[0]+tree[x+1].c[0];
}

void update(int root, int l, int r, int i, int j) {
	
	if (l > j || r < i || l > r) return;
	
	if (i <= l && j >= r) {
		tree[root].mov = (tree[root].mov+1)%3;
		return ;
	}
	int x = root<<1;
	int mid = (l+r)>>1;
	update(x , l, mid , i , j);
	update(x + 1, mid + 1 , r , i , j);
	int ls = tree[x].mov;
	int rs = tree[x+1].mov;
	tree[root].c[0] = tree[x].c[(0+ls)%3] + tree[x+1].c[(0+rs)%3];
	tree[root].c[1] = tree[x].c[(1+ls)%3] + tree[x+1].c[(1+rs)%3];
	tree[root].c[2] = tree[x].c[(2+ls)%3] + tree[x+1].c[(2+rs)%3];
}

int query(int root, int l , int r , int i , int j, int m) {
	if (i > r || j < l || l > r) return 0 ;
	
	m += tree[root].mov;
	
	if (i <= l && j >= r) {
		return tree[root].c[(0+m)%3];
	}
	int x = root<<1;
	int mid = (l+r)>>1;
	return query(x, l,mid,i,j,m%3)+query(x+1,mid+1,r,i,j,m%3);
}

int main () {
	int n,q,i,j,k;
	scanf("%d%d",&n,&q);
	build(1,0,n-1);
	while (q--) {
		int x,y,z;
		scanf("%d%d%d",&z,&x,&y);
		if(z) {
			printf("%d\n",query(1,0,n-1,x,y,0));
		} else update(1,0,n-1,x,y);
	}
	return 0;
}
