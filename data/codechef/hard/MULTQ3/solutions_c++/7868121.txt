/*
      !!  TRUTH IS GOD    !!
      TRUTH ALONE TRIUMPHS
*/

#include<iostream>
#include<math.h>

#define llu int
#define gc getchar_unlocked
#define pc putchar_unlocked

using namespace std;

inline llu read()
{
  llu n=0, c=gc();
 
  while(c < '0' || c > '9') c = gc();
 
  while(c >= '0' && c <= '9')
   n = (n<<3) + (n<<1) + c - '0', c = gc();
 
  return n;
}

inline void write(llu a)
{
   char snum[20];
   int i=0;
   
   do
    {
     snum[i++]=a%10+48;
     a=a/10;
   }while(a!=0);

   i=i-1;

   while(i>=0)
    pc(snum[i--]);

   pc('\n');
}

struct node
{
	 int zero , one , two , lazy ;
	
	 node()
	 {
	 	zero=0 , one=0 , two=0 , lazy=0 ;
	 }
	
	 node( int a , int b , int c , int d)
	  {
	 	zero=a , one=b , two=c , lazy=d ;
	  }
	
	 void 
	 merge( node l_child , node r_child )
	 {
		zero=  l_child.zero  +  r_child.zero;
		one =  l_child.one   +  r_child.one;
		two =  l_child.two   +  r_child.two;
	    // lazy=  l_child.lazy  +  r_child.lazy;
	 }
	  	
}*data;

void
update( int root , int l , int r , int a , int b )
{	
    if( data[root].lazy !=0 )
	 {
	 	if( data[root].lazy%3==0 )
	 	 {
	 	 	 data[root]=node( data[root].zero , data[root].one , data[root].two , data[root].lazy );
	 	 }
	    else if( data[root].lazy%3==1 )
		 {
			 data[root]=node( data[root].two , data[root].zero , data[root].one , data[root].lazy );
		 }
	    else if( data[root].lazy%3==2 )
		 {
			 data[root]=node( data[root].one , data[root].two , data[root].zero , data[root].lazy );
		 }  
	 	
	 	if( a != b )
	 	 {
			 data[root*2].lazy   += data[root].lazy ;
		 	 
			 data[root*2+1].lazy += data[root].lazy ;
		 }
		 
		 data[root].lazy=0; 
	 }
	 
	 if( r<a || b<l )
	  {
	  	 return ;
	  }
	  
	 if( l<=a && r>=b )
	  {  
		 data[root]=node( data[root].two , data[root].zero , data[root].one , data[root].lazy );   
	 	
	 	 if( a != b )
	 	  {
		 	 data[root*2].lazy ++;
		 	 
			 data[root*2+1].lazy ++;
		  }
		 
		 data[root].lazy=0;
		 
		 return ; 	  
	  }
	  
	  update( root*2    , l , r , a , (a+b)/2 );
	  
	  update( root*2 +1 , l , r , 1+(a+b)/2 , b );
	  
	  data[root].merge( data[root*2] , data[root*2+1] );  	
}

struct node 
query( int root , int l , int r , int a , int b )
{
	if( data[root].lazy !=0 )
	 {
	 	if( data[root].lazy%3==0 )
	 	 {
	 	 	 data[root]=node( data[root].zero , data[root].one , data[root].two , data[root].lazy );
	 	 }
	    else if( data[root].lazy%3==1 )
		 {
			 data[root]=node( data[root].two , data[root].zero , data[root].one , data[root].lazy );
		 }
	    else if( data[root].lazy%3==2 )
		 {
			 data[root]=node( data[root].one , data[root].two , data[root].zero , data[root].lazy );
		 }  
	 	
	 	//printf("root=%d a=%d b=%d\n",root,a,b);
	 	
	 	if( a != b )
	 	 {	 
		 	 data[root*2].lazy   += data[root].lazy ;
		 	 
			 data[root*2+1].lazy += data[root].lazy ;
		 }
		 
		 data[root].lazy=0; 
	 }
	 
	 if( r<a || l>b )
	  {
	  	 return node( 0,0,0,0 );
	  }
	  
	 if( l<=a && r>=b )
	  {	
		return data[root] ; 
	  }
	  
	  struct node left=node(0 , 0 , 0 , 0 ), right=node(0 , 0 , 0 , 0 ) , result=node( 0, 0, 0 , 0 ) ; 
	  
	  left  =query( root*2    , l , r , a , (a+b)/2   );
	  
	  right =query( root*2 +1 , l , r , 1+(a+b)/2 , b );
	  
	  // data[root].merge( data[ root*2 ] , data[ root*2+1 ] );
	  
	  result.merge( left , right );
	  
	  return result; 	
}

int main()
{
	int i , n , q , start , type , l , r , pos ;
	
	n=read() , q=read() ;

    pos=ceil( log2(n) );
    
    start=(1<<pos);
    
    data=new struct node[2*start + 100];
    
    for( i=start ; i<start+n ; i++ )
     {
     	data[i]=node( 1 , 0 , 0 , 0 );
     }
    
    
	for( i=start+n ; i<start+start ; i++ )
	 {
	 	data[i]=node( 0 , 0 , 0 , 0 );
	 }
	 
	for( i=start-1 ; i>=1 ; i-- )
	 {
	 	 data[i].merge( data[i*2] , data[2*i+1] );
	 	 
	 	 data[i].lazy=0;
	 }  
    
    /*
    printf("\n");
     	  
    for( i=1 ; i<start+start ; i++ )
     {
     	printf("i=%d zero=%d one=%d two=%d lazy=%d\n",i,data[i].zero,data[i].one,data[i].two,data[i].lazy); 
     }
		  
	printf("\n");
    
    */
    
    while( q-- )
     {
     	 type=read() , l=read() , r=read() ;
		 
     	 if( type==0 ) // update
     	  {
     	       update( 1 , l+1 , r+1 , 1 , start );	
     	  }
     	 else
     	  {
     	 	  write( query( 1 , l+1 , r+1 , 1 , start ).zero );
     	  }
     	 
		  /* 
     	    printf("\n");
     	  
     	   for( i=1 ; i<start+start ; i++ )
            {
     	      printf("i=%d zero=%d one=%d two=%d lazy=%d\n",i,data[i].zero,data[i].one,data[i].two,data[i].lazy); 
            }
		  
		    printf("\n");
		 */
		   
     }
   	 
    return 0;
}