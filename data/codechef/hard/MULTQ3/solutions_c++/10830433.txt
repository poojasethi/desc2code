/*
	               _            .                                 .x+=:.
	              u            @88>                              z`    ^%    .uef^"
	             88Nu.   u.    %8P      u.    u.                    .   <k :d88E
	      u     '88888.o888c    .     x@88k u@88c.       u        .@8Ned8" `888E
	   us888u.   ^8888  8888  .@88u  ^"8888""8888"    us888u.   .@^%8888"   888E .z8k
	.@88 "8888"   8888  8888 ''888E`   8888  888R  .@88 "8888" x88:  `)8b.  888E~?888L
	9888  9888    8888  8888   888E    8888  888R  9888  9888  8888N=*8888  888E  888E
	9888  9888    8888  8888   888E    8888  888R  9888  9888   %8"    R88  888E  888E
	9888  9888   .8888b.888P   888E    8888  888R  9888  9888    @8Wou 9%   888E  888E
	9888  9888    ^Y8888*""    888&   "*88*" 8888" 9888  9888  .888888P`    888E  888E
	"888*""888"     `Y"        R888"    ""   'Y"   "888*""888" `   ^"F     m888N= 888>
	 ^Y"   ^Y'                  ""                  ^Y"   ^Y'               `Y"   888
	                                                                             J88"
	                                                                             @%
	                                                                           :"
*/
#include <stdio.h>

typedef long long int ll;

#ifdef __WIN32__
#define getchar_unlocked getchar
#define putchar_unlocked putchar
#endif

inline ll inp(){ ll n=0, sg=1; register int c=getchar_unlocked(); if(c=='-') sg=-1; while(c<'0' || c>'9')
c=getchar_unlocked(); while(c>='0' && c<='9'){n = (n<<3) + (n<<1) + c-48; c=getchar_unlocked();} return n*sg;}

char _str[19];
inline void pout(ll _x){ register int _i=0;ll _tmp=(_x); do{*(_str + _i++)=_tmp % 10 + 48;_tmp /= 10;}
while (_tmp != 0);for (_i--; _i >= 0; _i--) putchar_unlocked(*(_str + _i)); }


struct node{
	int rem1, rem2, added;
};

node st[100001*3];

void change(node &P, int l, int r) {
	int tmp = P.rem1;
	P.rem1 = (r-l+1) - P.rem1 - P.rem2;
	P.rem2 = tmp;
}

void update(int i, int l, int r, int a, int b) {
	if(b<l || r<a) return;

	if(a<=l && r<=b) {
		change(st[i],l,r);
		st[i].added = (st[i].added+1)%3;	
		return;
	}
	int mid = (l+r)>>1;
	int left = (i<<1);
	int right = left|1;

	update(left, l, mid, a, b);
	update(right, mid+1, r, a, b);

	st[i].rem1 = st[left].rem1 + st[right].rem1;
	st[i].rem2 = st[left].rem2 + st[right].rem2;
	
	for(int k=0; k<st[i].added; k++) change(st[i],l,r);
}

int query(int i, int l, int r, int a, int b, int added) {
	if(b<l || r<a) return 0;

	if(a<=l && r<=b) {
		switch(added) {
			case 1 : return st[i].rem2;
			case 2 : return st[i].rem1;
			default : return (r-l+1) - st[i].rem1 - st[i].rem2;
		}
	}

	added = (added + st[i].added)%3;

	int mid = (l+r)>>1;
	int left = (i<<1);
	int right = left|1;
	int x = query(left, l, mid, a, b, added);
	int y = query(right, mid+1, r, a, b, added);
	return x+y;
}

int main() {
	int N, Q;
	N = inp();
	Q = inp();

	int type, l, r;
	while(Q--){
		type = inp();
		l = inp();
		r = inp();

		if(type == 0) update(1, 0, N-1, l, r);

		else printf("%d\n", query(1, 0, N-1, l, r, 0));
	}
	return 0;
}
