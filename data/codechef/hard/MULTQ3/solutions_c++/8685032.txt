//---------------------------JUGNU: LET YOUR LIGHT SHINE---------------------------//
#include <bits/stdc++.h>
#define ll long long int
#define pb push_back
#define pf push_front
#define sz size
#define mk make_pair
#define ln length
#define vt(a) vector <int> a
#define st(a) set <int> a
#define sti(a) set <int>::iterator a
#define fr(i,a,b) for(i=a;i<b;i++)
#define fre(i,a,b) for(i=a;i<=b;i++)
#define frr(i,a,b) for(i=a;i>=b;i--)
#define sc(a) scanf("%d",&a)
#define sm(a,b) scanf("%d%d", &a, &b)
#define pr(a) printf("%d\n", a)
#define pm(a,b) printf("%d %d\n", a, b)
#define cn(a) cin >> a
#define ct(a) cout << a << endl
#define isset(x,i) ((x>>i)&1)
#define fastScan ios_base::sync_with_stdio(0); cin.tie(NULL);
using namespace std;
typedef struct node
{
	int rem_0, rem_1, rem_2;
}node;
node tree[400005];
int lazy[400005];
int half(int x, int y)
{
	return (x + (y-x)/2);
}
node cnstrct_tree(int current ,int left, int right)
{
	if(left==right)
	{
		tree[current].rem_0 = 1;
		tree[current].rem_1 = tree[current].rem_2 = 0;
		return tree[current];
	}
	int mid = half(left, right);
	node lft = cnstrct_tree(2*current+1, left, mid);
	node rght = cnstrct_tree(2*current+2, mid+1, right);
	tree[current].rem_0 = lft.rem_0 + rght.rem_0;
	tree[current].rem_1 = lft.rem_1 + rght.rem_1;
	tree[current].rem_2 = lft.rem_2 + rght.rem_2;
	return tree[current];
}
node update(int current, int left, int right, int q_left, int q_right)
{
	if(lazy[current]!=0)
	{
		if(lazy[current]==1)
		{
			int temp = tree[current].rem_1;
			tree[current].rem_1 = tree[current].rem_0;
			tree[current].rem_0 = tree[current].rem_2;
			tree[current].rem_2 = temp;
		}
		else 
		{
			int temp = tree[current].rem_2;
			tree[current].rem_2 = tree[current].rem_0;
			tree[current].rem_0 = tree[current].rem_1;
			tree[current].rem_1 = temp;
		}
		if(left!=right)
		{
			lazy[2*current+1] = (lazy[2*current+1] + lazy[current])%3;
			lazy[2*current+2] = (lazy[2*current+2] + lazy[current])%3;
		}
		lazy[current] = 0;
	}
	if ( q_left>right || q_right< left)
		return tree[current];
	if(q_left<=left && q_right>=right)
	{
		int temp = tree[current].rem_1;
		tree[current].rem_1 = tree[current].rem_0;
		tree[current].rem_0 = tree[current].rem_2;
		tree[current].rem_2 = temp;
		if(left!=right)
		{
			lazy[2*current+1] = (lazy[2*current+1] + 1)%3;
			lazy[2*current+2] = (lazy[2*current+2] + 1)%3;
		}
		return tree[current];
	}
	int mid = half(left, right);
	node lft = update(2*current+1, left, mid, q_left, q_right);
	node rght = update(2*current+2, mid+1, right, q_left, q_right);
	tree[current].rem_0 = lft.rem_0 + rght.rem_0;
	tree[current].rem_1 = lft.rem_1 + rght.rem_1;
	tree[current].rem_2 = lft.rem_2 + rght.rem_2;
	return tree[current];
}
int query(int current, int left, int right, int q_left, int q_right)
{
	if(lazy[current]!=0)
	{
		if(lazy[current]==1)
		{
			int temp = tree[current].rem_1;
			tree[current].rem_1 = tree[current].rem_0;
			tree[current].rem_0 = tree[current].rem_2;
			tree[current].rem_2 = temp;
		}
		else 
		{
			int temp = tree[current].rem_2;
			tree[current].rem_2 = tree[current].rem_0;
			tree[current].rem_0 = tree[current].rem_1;
			tree[current].rem_1 = temp;
		}
		if(left!=right)
		{
			lazy[2*current+1] = (lazy[2*current+1] + lazy[current])%3;
			lazy[2*current+2] = (lazy[2*current+2] + lazy[current])%3;
		}
		lazy[current] = 0;
	}
	if (q_left>right || q_right< left)
		return 0;
	if(q_left<=left && q_right>=right)
		return tree[current].rem_0;
	int mid = half(left, right);
	return (query(2*current+1, left, mid, q_left, q_right) + query(2*current+2, mid+1, right, q_left, q_right));
}
int main()
{
	int i, j, t, n, m, k, l, r, mini,cnt, maxi, flag, result, type;
	node temp;
	sm(n, m);
	temp = cnstrct_tree(0, 0, n-1);
	while(m--)
	{
		sc(type);
		sm(l, r);
		if(type==0)
			temp = update(0, 0, n-1, l, r);
		else
			pr(query(0, 0, n-1, l, r));
	}
	
return 0;
}
