    #include <bits/stdc++.h>
    using namespace std;
    const int N = 1e6 + 5;
    const int mod = 20011;
    inline long long add(long long u , long long v , long long mod){
        return (u%mod + v%mod) % mod;
    }
    inline long long mul(long long u , long long v , long long mod){
        return (u % mod * v % mod) % mod;
    }
    inline long long sub(long long u , long long v , long long md){
        return(u - v + md) % md;
    }
    int n , q , u , v , type;
    int a[N];
    int tree[N << 2LL][3];
    int lazy[N << 2LL];
    #define gc() getchar_unlocked()
    inline int get(){
    int x = 0;
    char c = gc();
    while(c < '0' || c > '9') c = gc();
    while(c >= '0' && c <= '9'){
        x = x * 10 + (c - '0');
        c = gc();
    }
    return x;
    }
    #define pc(x) putchar_unlocked(x)
    inline void out(int n){
        char s[15];
        int i = 0;
        do{
            s[i++] = (char)(n % 10 + '0');
            n /= 10;
        }while(n > 0);
        --i;
        while(i >= 0) pc(s[i--]);
        pc('\n');
    }
    inline void build(int node , int u , int v){
        if(u > v) return;
        if(u == v){
            tree[node][a[u] % 3]++;
            return;
        }
        build(2 * node , u , (u + v) / 2 );
        build(1 + (2 * node) , 1 + ( (u + v) / 2) , v );
        for(int i = 0; i < 3; ++i){
            tree[node][i] = tree[2 * node][i] + tree[1 + (2 * node)][i];
        }
    }
    inline void update(int node , int u , int v , int l , int r , int val){
        if(lazy[node] != 0){
            if(lazy[node] == 1){
                int tmp = tree[node][0];
                tree[node][0] = tree[node][2];
                tree[node][2] = tree[node][1];
                tree[node][1] = tmp;
            }else if(lazy[node] == 2){
                int tmp = tree[node][0];
                tree[node][0] = tree[node][1];
                tree[node][1] = tree[node][2];
                tree[node][2] = tmp;
            }
            if(u != v){
                lazy[2 * node] = (lazy[2 * node] + lazy[node]) % 3;
                lazy[1 + (2 * node)] = (lazy[1 + (2 * node)] + lazy[node]) % 3;
            }
            lazy[node] = 0;
        }
        if(u > v || u > r || v < l) return;
        if(u >= l && v <= r){
                int tmp = tree[node][0];
                tree[node][0] = tree[node][2];
                tree[node][2] = tree[node][1];
                tree[node][1] = tmp;
                if(u != v){
                    lazy[2 * node] = (lazy[2 * node] + 1) % 3;
                    lazy[1 + (2 * node)] = (lazy[1 + (2 * node)] + 1) % 3;
                }
                return;
        }
        update(2 * node , u , (u + v) / 2 , l , r , val);
        update(1 + (2 * node) , 1 + ( (u + v) / 2) , v , l , r , val);
        for(int i = 0; i < 3; ++i){
            tree[node][i] = tree[2 * node][i] + tree[1 + (2 * node)][i];
        }
    }
    inline int query(int node , int u , int v , int l , int r){
        if(lazy[node] != 0){
            if(lazy[node] == 1){
                int tmp = tree[node][0];
                tree[node][0] = tree[node][2];
                tree[node][2] = tree[node][1];
                tree[node][1] = tmp;
            }else if(lazy[node] == 2){
                int tmp = tree[node][0];
                tree[node][0] = tree[node][1];
                tree[node][1] = tree[node][2];
                tree[node][2] = tmp;
            }
            if(u != v){
                lazy[2 * node] = (lazy[2 * node] + lazy[node]) % 3;
                lazy[1 + (2 * node)] = (lazy[1 + (2 * node)] + lazy[node]) % 3;
            }
            lazy[node] = 0;
        }
        if(u > v || u > r || v < l) return 0;
        if(u >= l && v <= r) return tree[node][0];
        return(query(2 * node , u , (u + v) / 2 , l , r) + query(1 + (2 * node) , 1 + (u + v) / 2 , v , l , r));
    }
    int main(){
        memset(a , 0 , sizeof a);
        memset(lazy , 0 , sizeof lazy);
        memset(tree , 0 , sizeof tree);
        n = get() , q = get();
        build(1 , 0 , n - 1);
        while(q--){
            type = get() , u = get() , v = get();
            if(!type){
                update(1 , 0 , n - 1 , u , v , 1);
            }else{
                out( query(1 , 0 , n - 1 , u , v ) );
            }
        }
        return 0;
    }
     