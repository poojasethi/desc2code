#include<bits/stdc++.h>
using namespace std;
int ST[300010][3],lazy[300010],n,q;

void construct(int i,int j, int index)// Updates ST[index][0] to hold the number of numbers divisible.
{
    int mid=(i+j)/2;
    if(i==j)
    {
        //cout<<"first "<<i<<" == "<<j<<endl;
        //cout<<"Initially ST["<<index<<"][0] "<<ST[index][0]<<endl;

        ST[index][0]=1;
        ST[index][1] = ST[index][2] = 0;

        //cout<<"Then ST["<<index<<"][0] "<<ST[index][0]<<endl;


        return;
    }
    construct(i,mid,2*index);
    construct(mid+1,j,2*index+1);
    ST[index][1] = ST[index][2] = 0;
    ST[index][0]=ST[2*index][0]+ST[2*index+1][0];// This stores the count of numbers divisible

    //cout<<"At last ST["<<index<<"][0] "<<ST[index][0]<<endl;

}
int query(int i,int j,int a,int b,int index)
{
    int temp;
    if(lazy[index]!=0)
    {
        if(lazy[index]%3==1)
        {

            //cout<<"lazy["<<index<<"] ==1 ST["<<index<<"][0] "<<ST[index][0]<<" ST["<<index<<"][1] "<<ST[index][1]<<" ST["<<index<<"][2] "<<ST[index][2]<<" temp "<<temp<<endl;
            temp=ST[index][1];
            ST[index][1]=ST[index][0];
            ST[index][0]=ST[index][2];

            ST[index][2]=temp;
            //cout<<"Eventually ST["<<index<<"][0] "<<ST[index][0]<<" ST["<<index<<"][1] "<<ST[index][1]<<" ST["<<index<<"][2] "<<ST[index][2]<<" temp "<<temp<<endl;

        }
        else if(lazy[index]%3==2)
        {
            //cout<<"lazy["<<index<<"] ==2 ST["<<index<<"][0] "<<ST[index][0]<<" ST["<<index<<"][1] "<<ST[index][1]<<" ST["<<index<<"][2] "<<ST[index][2]<<" temp "<<temp<<endl;
            temp=ST[index][0];
            ST[index][0]=ST[index][1];
            ST[index][1]=ST[index][2];
            ST[index][2]=temp;
            //cout<<"Eventually ST["<<index<<"][0] "<<ST[index][0]<<" ST["<<index<<"][1] "<<ST[index][1]<<" ST["<<index<<"][2] "<<ST[index][2]<<" temp "<<temp<<endl;
        }
        if(i!=j)
        {
            //cout<<i<<" ! = "<<j<<endl;
            //cout<<"Here ST["<<index<<"][0] "<<ST[index][0]<<" ST["<<index<<"][1] "<<ST[index][1]<<" ST["<<index<<"][2] "<<ST[index][2]<<" temp "<<temp<<endl;

            lazy[2*index]=(lazy[index]+lazy[2*index])%3;
            lazy[2*index+1]=(lazy[index]+lazy[2*index+1])%3;


        }
        lazy[index]=0;
    }
    int mid=(i+j)/2;

    if(a>j || b<i ){
        //cout<<"returning 0"<<endl;
        return 0;
    }

    if(i>=a && j<=b){// Complete overlap Returns number of numbers divisible
        //cout<<"returning "<<ST[index][0]<<' '<<index<<endl;
        return ST[index][0];
    }

    //cout<<"returning query( "<<i<<' '<<mid<<' '<<a<<' '<<b<<' '<<2*index<<" + query( <<"<<mid+1<<' '<<j<<' '<<a<<' '<<b<<' '<<2*index+1<<")";

    return query(i,mid,a,b,2*index)+query(mid+1,j,a,b,2*index+1);

}
void  update(int i,int j,int a, int b,int index)
{
    //printf("i=%d j=%d a=%d b=%d ST[%d]=%d\n",i,j,a,b,index,ST[index][0]);
    int mid=(i+j)/2,temp;
    if(lazy[index]!=0)
    {
        if(lazy[index]%3==1)
        {

            //cout<<"lazy["<<index<<"] = "<<lazy[index]<<endl;
            //cout<<"ST["<<index<<"][0] "<<ST[index][0]<<" ST["<<index<<"][1] "<<ST[index][1]<<" ST["<<index<<"][2] "<<ST[index][2]<<endl;
            temp=ST[index][1];
            ST[index][1]=ST[index][0];
            ST[index][0]=ST[index][2];

            ST[index][2]=temp;
            //cout<<"NOW ST["<<index<<"][0] "<<ST[index][0]<<" ST["<<index<<"][1] "<<ST[index][1]<<" ST["<<index<<"][2] "<<ST[index][2]<<" temp "<<temp<<endl;
        }
        else if(lazy[index]%3==2)
        {
            //cout<<"lazy["<<index<<"] = "<<lazy[index]<<endl;
            //cout<<"ST["<<index<<"][0] "<<ST[index][0]<<" ST["<<index<<"][1] "<<ST[index][1]<<" ST["<<index<<"][2] "<<ST[index][2]<<endl;
            temp=ST[index][0];
            ST[index][0]=ST[index][1];
            ST[index][1]=ST[index][2];
            ST[index][2]=temp;
            //cout<<"NOW ST["<<index<<"][0] "<<ST[index][0]<<" ST["<<index<<"][1] "<<ST[index][1]<<" ST["<<index<<"][2] "<<ST[index][2]<<" temp "<<temp<<endl;

        }
        if(i!=j)
        {
            //cout<<i<<" != "<<j<<endl;
            lazy[2*index]=(lazy[index]+lazy[2*index]);
            lazy[2*index+1]=(lazy[index]+lazy[2*index+1]);


        }
        lazy[index]=0;
    }

    if(a>j || b<i)
        return;

    if(i>=a && j<=b)//Swaps  3k,3k+1 and 3k+2. Agar ek range mein 1 se update kiya, then 3k wale 3k+1 ban jayenge and so on
    {
        //cout<<"Complete overlap ST["<<index<<"][0] "<<ST[index][0]<<" ST["<<index<<"][1] "<<ST[index][1]<<" ST["<<index<<"][2] "<<ST[index][2]<<" temp "<<temp<<endl;

        temp=ST[index][1];

        ST[index][1]=ST[index][0];
        ST[index][0]=ST[index][2];
        ST[index][2]=temp;
        if(i!=j)// if not leaf node mark child as lazy
        {
            //cout<<"again "<<i<<" != "<<j<<endl;
            lazy[2*index]=(1+lazy[2*index]);
            lazy[2*index+1]=(1+lazy[2*index+1]);

        }

        //cout<<"Finally ST["<<index<<"][0] "<<ST[index][0]<<" ST["<<index<<"][1] "<<ST[index][1]<<" ST["<<index<<"][2] "<<ST[index][2]<<" temp "<<temp<<endl;


        return;
    }


    update(i,mid,a,b,2*index);
    update(mid+1,j,a,b,2*index+1);
    ST[index][0]=ST[2*index][0]+ST[2*index+1][0];
    ST[index][1]=ST[2*index][1]+ST[2*index+1][1];
    ST[index][2]=ST[2*index][2]+ST[2*index+1][2];
    return;

}

int main()
{
    int x,a,b;
    scanf("%d %d",&n,&q);
    construct(1,n,1);
    while(q--)
    {
        scanf("%d %d %d",&x,&a,&b);
        if(x==1)
        {
            printf("%d\n",query(1,n,a+1,b+1,1));
        }
        else
            update(1,n,a+1,b+1,1);

    }

return 0;
}
