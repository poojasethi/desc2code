/**



   Pradip chandra karmaker
   Comilla University(6th_ICT)
*/



#include<bits/stdc++.h>
using namespace std;
#define inf 1<<30
#define xx first
#define yy second
#define pb push_back
#define mp make_pair
#define clr(a) memset(a,0,sizeof a)
#define neg(a) memset(a,-1,sizeof a)
#define Sort(a) sort(a.begin(),a.end())
#define All(a) a.begin(),a.end()
typedef long long i64;
typedef pair<int,int> pi;
#define mod 1000000007LL





template<class T>T Bitcnt(T a){int sum=0;while(a){if(a&1)sum++;a/=2;}return sum;}
template<class T>T Max3(T a,T b,T c){return max(a,max(b,c));}
template<class T>T Lcm(T a,T b){T tmp=__gcd(a,b);return (a/tmp)*b;}
template<class T> T Pow(T a,T b){T ans=1;T base=a;while(b){if(b&1)ans=(ans*base);base=(base*base);b/=2;}return ans;}
i64 Bigmod(i64 a,i64 b)
{
    i64 res=1;
    i64 pw=a%mod;
    while(b>0)
    {
       if(b&1)res=(res*pw)%mod;
       pw=(pw*pw)%mod;
       b/=2;
    }
    return res;
}


#define s1(a) scanf("%d",&a)
#define s2(a,b) scanf("%d %d",&a,&b)
#define s3(a,b,c) scanf("%d %d %d",&a,&b,&c)
#define sl1(a) scanf("%lld",&a)
#define sl2(a,b) scanf("%lld %lld",&a,&b)
#define sl3(a,b,c) scanf("%lld %lld %lld",&a,&b,&c)
#define p1(a) printf("%d",a)
#define p2(a,b) printf("%d %d",&a,&b)
#define NL printf("\n")
#define N 4000000
#define rep(i,a,b)    for(int i=a;i<=b;i++)
#define rrep(i,b,a)   for(int i=b;i>=a;i--)
#define fs(i,a,s)     for(int i=a;s[i];i++)
#define EPS 1e-13
#define PI acos(-1.0)

int a_x[]={1,-1,0,0};
int a_y[]={0,0,1,-1};
i64 X,Y;

void extend_euclid(i64 a,i64 b)
{
    if(b==0)
    {
        X=a;Y=0;return;
    }
    extend_euclid(b,a%b);
    i64 x,y;
    x=Y;
    y=X-(a/b)*Y;
    X=x;
    Y=y;
}
i64 inverse_modulo(i64 a,i64 b)
{
    extend_euclid(a,b);
    return (X+mod)%mod;
}

/** dijkstra,bitmask,ME,scc,backtraking,grid dp,segment tree,bit,LCA,bfs,dfs,BPM,MAX_FLOW,MCM,Tree dp,kmp,MST,Meet in the middle*/

/**Triangle characteristics,Phi,bitwise_seive,SOD,articulation,topological,HLD,Z,knapsack,Coin,Digit,LIS,LCS,minimum vertex
cover,josephus,chinese remainder,square root decomposition,ternary search,binary search,Number of theory(divisor,prime),chinese remainder,Generic functoin,Convex hull*/

/*************************************************************************************************************************************************************************************************/

i64 dist(int x1,int y1,pair<int,int> tmp)
{
     i64 t=1LL*(x1-tmp.xx)*(x1-tmp.xx)+1LL*(y1-tmp.yy)*(y1-tmp.yy);
    return (i64)(t);
}
bool collinear(pair<int,int>a,pair<int,int>b,pair<int,int>c)
{
    int area;
    area=a.xx*(b.yy-c.yy)+b.xx*(c.yy-a.yy)+c.xx*(a.yy-b.yy);
    return area;
}




/**********************************Main code starts frome here****************************************/

struct info
{
   i64 x,y;
   info(){x=0;y=0;}
   info (i64 a,i64 b){x=a;y=b;}
   info operator+(info &p)
   {
       info tmp(x+p.x,y+p.y);
       return tmp;
   }
   info operator-(info &p)
   {
     info tmp(x-p.x,y-p.y);
     return tmp;
   }
};
i64 cross2D(info a,info b)
{
    return a.x*b.y-a.y*b.x;
}

bool cmp(const info&a,const info &b)
{
    if(a.y!=b.y)
        return a.y<b.y;
     return a.x<b.x;

}
int convexHull(info points[],info convexPoints[],int n)
{
   if(n<=3)
   {
       rep(i,0,n-1)convexPoints[i]=points[i];
       return n;
   }
   sort(points,points+n,cmp);
     int m = 0;
    for(int i = 0; i < n; i++){
        while(m >= 2 && cross2D(convexPoints[m-2]- convexPoints[m-1],convexPoints[m-2]- points[i]) < 0)
            m--;
        convexPoints[m++] = points[i];
    }
    for(int i = n-2, t = m+1; i >= 0; i--){
        while(m >= t && cross2D(convexPoints[m-2]- convexPoints[m-1],convexPoints[m-2]- points[i]) < 0)
            m--;
        convexPoints[m++] = points[i];
    }
    return m-1;
}

i64 areaPolygon(info points[],int n)
{
   i64 area=0;
   for(int i=0;i<n;i++)
   {
       area+=points[i].x*points[(i+1)%n].y-points[i].y*points[(i+1)%n].x;
   }
   return abs(area);
}

info pradip[5];
i64 get_tri(info a,info b,info c)
{
    pradip[0]=a;
    pradip[1]=b;
    pradip[2]=c;
    return areaPolygon(pradip,3);
}
info arr[N];
info con[N];
info inside[N];

int main()
{
   ///freopen("input.txt","r",stdin);
        int t;
        s1(t);
        while(t--)
        {
            int n;
            s1(n);
            rep(i,0,n-1)sl2(arr[i].x,arr[i].y);
            int m=convexHull(arr,con,n);
            i64 area=areaPolygon(con,m);
            int ptr=0;
            int s=0;
            sort(arr,arr+n,cmp);
            sort(con,con+m,cmp);
            for(int i=0;i<n;i++)
            {
               if(ptr<m && arr[i].x==con[ptr].x && arr[i].y==con[ptr].y)
               {
                   ptr++;
               }
               else {

                 inside[s++]=arr[i];
               }
            }

            if(s==0)
            {
                puts("-1");
                continue;
            }
            n=convexHull(arr,con,n);
            m=convexHull(inside,arr,s);
            rep(i,0,m-1)inside[i]=arr[i];
            rep(i,0,n-1)
            {
                con[n+i]=con[i];
                con[n+n+i]=con[i];
            }
            rep(i,0,m-1)
            {
                inside[i+m]=inside[i];
                inside[i+m+m]=inside[i];
            }
             ptr=0;
            i64 val=1LL<<62;
           for(int i=0;i<n;i++)
           {
                while(get_tri(con[i],con[i+1],inside[ptr+1])<get_tri(con[i],con[i+1],inside[ptr]))
                {
                     ptr++;
                }
                val=min(val,get_tri(con[i],con[i+1],inside[ptr]));
           }
           cout<<area-val<<endl;
        }
     return 0;
}
