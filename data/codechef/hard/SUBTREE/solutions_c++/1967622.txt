/**
 * March 2013 Long Challenge at Codechef
 *
 * Problem:     SUBTREE - Festivals
 * Author:      Anton Lunyov (Tester)
 * Complexity:  O(N * log N + sum(Ki) * log N)
 * Timing:      0.24 out of 1.00
 */
#include <cstdio>
#include <vector>
using namespace std;

typedef vector<int> VI;

const int maxN = 100000;
const int maxH = 17; // 2^maxH > maxN
const int maxC = 10000; // the maximal length of the edge

int LOG2[maxN+1]; // LOG2[n] is the maximal h such that 2^h <= n
// representation of tree
// for each edge (u,v,c) we have (v,c) in a[u], and (u,c) in a[v]
vector<pair<int, int> > maStr[maxN+1];
int depth[maxN+1]; // d[u] is the depth of the vertex
int dist[maxN+1]; // dist[u] is the distance between root and u
int in_time[maxN+1]; // in[u] is the time when dfs enters to u
int in_t; // the time counter for enters to dfs
int out_time[maxN+1]; // out[u] is the time when dfs exits from u
int out_t; // the time counter for exits from dfs

// p[u][h] is such ancestor v of u for which d[u]-d[v]=2^h
// p[u][h] = 0 if such v does not exist, i.e., if d[u] < 2^h
// p[u][0] is the direct parent of u
int hopf[maxN+1][maxH];
// minc[u][h] is the length of the shortest edge on the path from u to p[u][h]
int minDist[maxN+1][maxH];

void dfs(int n)
{
	in_time[n]=++in_t;
	for(int i=0;i<maStr[n].size();i++)
	{
		int m=maStr[n][i].first;
		if(hopf[n][0]!=m)
		{
			dist[m]=dist[n]+maStr[n][i].second;
			depth[m]=depth[n]+1;
			hopf[m][0]=n;
			minDist[m][0]=maStr[n][i].second;
			dfs(m);
		}
	}
	out_time[n]=++out_t;
}

// determine whether a is ancestor of b
int is_ancestor(int a,int b)
{
	return in_time[a]<=in_time[b]&&out_time[a]>=out_time[b];
}

int is_ancestor(int a,vector<int> B)
{
	for(int j=0;j<B.size();j++)
	{
		if(is_ancestor(a,B[j]))
			return 1;
	}
	return 0;
}

// return LCA of a and b
int LCA(int a,int b)
{
	if(is_ancestor(a,b))
		return a;
	else if(is_ancestor(b,a))
		return b;
	else
	{
		for(int h=LOG2[depth[a]];h>=0;h--)
		{
			if(hopf[a][h]!=0 && !is_ancestor(hopf[a][h],b))
				a=hopf[a][h];
		}
		return hopf[a][0];
	}
}

int LCA(vector<int> Que)
{
	int lca0=Que[0];
	for(int i=1;i<Que.size();i++)
		lca0=LCA(lca0,Que[i]);
	return lca0;
}

// return distance between a and b
int get_dist(int a,int b)
{
	if(is_ancestor(a,b))
		return dist[b]-dist[a];
	else if(is_ancestor(b,a))
		return dist[a]-dist[b];
	else
		return dist[a]+dist[b]-2*dist[LCA(a,b)];
}

int get_max(int a,vector<int> Que,int &mx)
{
	int di, loc=a;
	mx=-1;
	for(int j=0,i=Que[j];j<Que.size();j++,i=Que[j])
	{
		if((di=get_dist(a,i))>mx)
		{
			mx=di;
			loc=i;
		}
	}
	return loc;
}

// in this case, w is root of a
int get_easy_min(int a,int w)
{
	int h, minD, n=depth[a]-depth[w];
	if(n==0)
		return maxN+100;
	for(h=LOG2[n],minD=maxN+100;h>=0;h--)
	{
		if(n&(1<<h))
		{
			minD=minDist[a][h]<minD?minDist[a][h]:minD;
			a=hopf[a][h];			
		}
	}
	return minD;
}

// the shortest road between a and b
int get_min(int a,int b)
{
	int w=LCA(a,b);
	int minD, minD1;
	minD=get_easy_min(a,w);
	minD1=get_easy_min(b,w);
	return minD1<minD?minD1:minD;
}

// in this case, a is ancestor of b
int get_min_all(int b,vector<int> A)
{
	int a=LCA(A), minD=maxN+100;
	
	for(int h=LOG2[depth[b]-depth[a]];h>=0;h--)
	{
		if(!hopf[b][h] || is_ancestor(hopf[b][h],A))
			continue;
		minD=minDist[b][h]<minD?minDist[b][h]:minD;
		b=hopf[b][h];
	}
	return minDist[b][0]<minD?minDist[b][0]:minD;
}

int main() {
	int i, n, u, v, c;
	n=1;
	for(int h=0;n<=maxN;n++)
	{
		if(n<(1<<(h+1)))
			LOG2[n]=h;
		else
			LOG2[n]=++h;
	}

	// input tree
	scanf("%d",&n);
	for(i=0;i<n-1;i++)
	{
		scanf("%d %d %d",&u,&v,&c);
		maStr[u].push_back(pair<int,int>(v,c));
		maStr[v].push_back(pair<int,int>(u,c));
	}

	dfs(1);

	/*
	// binary lifting for parents and minimums
	for (int h = 0; (1 << (h + 1)) < n; ++h) {
		for (int u = 1; u <= n; ++u) {
			int pu = hopf[u][h];
			hopf[u][h + 1] = hopf[pu][h];
			minDist[u][h + 1] = min(minDist[u][h], minDist[pu][h]);
		}
	}
	*/

	for(int h=1;h<=LOG2[n];h++)
	{
		for(i=2;i<=n;i++)
		{
			hopf[i][h]=hopf[hopf[i][h-1]][h-1];
			minDist[i][h]=min(minDist[i][h-1],minDist[hopf[i][h-1]][h-1]);
		}
	}

	int Q;
	scanf("%d", &Q);
	for (int q = 0; q < Q; ++q) {
		int K;
		scanf("%d", &K);
		VI F(K);
		for (int i = 0; i < K; ++i) {
			scanf("%d", &F[i]);
		}
		int mx;
		int u1 = get_max(F[0], F, mx);
		int u2 = get_max(u1, F, mx);
		// u1 and u2 are two furthest vertexes among given K
		// and mx is the gistance between them
		printf("%d ", mx);

		// U1 is the set of vertexes in F for which dist to u2 is mx
		// U2 is the set of vertexes in F for which dist to u1 is mx
		// u1 will belong to U1, u2 will belong to U2
		bool noB = false;
		VI U1, U2;
		for (int i = 0; i < K; ++i) {
			int cnt = 0;
			if (get_dist(u1, F[i]) == mx) {
				U2.push_back(F[i]);
				++cnt;
			}
			if (get_dist(u2, F[i]) == mx) {
				U1.push_back(F[i]);
				++cnt;
			}
			if (cnt == 2) {
				noB = true;
			}
		}
		// if for some vertex Fi dist to both u1 and u2 = mx
		// there is no common edge at ideal paths
		if (noB) {
			printf("-1\n");
			continue;
		}

		// otherwise we find lca of all U1 and also of all U2
		int lca1 = LCA(U1);
		int lca2 = LCA(U2);
		// and do some analysis
		int min_edge;
		// if one of lca1, lca2 is ancestor of another
		// then we apply get_min for vertex and list
		if (is_ancestor(lca1, lca2)) {
			min_edge = get_min_all(lca2, U1);
		} else if (is_ancestor(lca2, lca1)) {
			min_edge = get_min_all(lca1, U2);
		} else {
			// in this case the path lca1 - lca2 is the intersection of all ideal path
			min_edge = get_min(lca1, lca2);
		}
		printf("%d\n", min_edge);
	}
	return 0;
}