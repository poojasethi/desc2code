/**
 * March 2013 Long Challenge at Codechef
 *
 * Problem:     SUBTREE - Festivals
 * Author:      Anton Lunyov (Tester)
 * Complexity:  O(N * log N + sum(Ki) * log N)
 * Timing:      0.24 out of 1.00
 */
#include <cstdio>
#include <vector>
using namespace std;

typedef vector<int> VI;

const int maxN = 100000;
const int maxH = 17; // 2^maxH > maxN
const int maxC = 10000; // the maximal length of the edge

int LOG2[maxN+1]; // LOG2[n] is the maximal h such that 2^h <= n
// representation of tree
// for each edge (u,v,c) we have (v,c) in a[u], and (u,c) in a[v]
vector<pair<int, int> > maStr[maxN+1];
int d[maxN+1]; // d[u] is the depth of the vertex
int dist[maxN+1]; // dist[u] is the distance between root and u
int in[maxN+1]; // in[u] is the time when dfs enters to u
int in_time; // the time counter for enters to dfs
int out[maxN+1]; // out[u] is the time when dfs exits from u
int out_time; // the time counter for exits from dfs

// p[u][h] is such ancestor v of u for which d[u]-d[v]=2^h
// p[u][h] = 0 if such v does not exist, i.e., if d[u] < 2^h
// p[u][0] is the direct parent of u
int p[maxN+1][maxH];
// minc[u][h] is the length of the shortest edge on the path from u to p[u][h]
int minc[maxN+1][maxH];

void dfs(int n)
{
	in[n]=++in_time;
	for(int i=0;i<maStr[n].size();i++)
	{
		int m=maStr[n][i].first;
		if(p[n][0]!=m)
		{
			dist[m]=dist[n]+maStr[n][i].second;
			d[m]=d[n]+1;
			p[m][0]=n;
			minc[m][0]=maStr[n][i].second;
			dfs(m);
		}
	}
	out[n]=++out_time;
}

int is_ancestor(int a,int b)
{
	return in[a]<=in[b]&&out[a]>=out[b];
}

int is_ancestor(int a,vector<int> B)
{
	for(int j=0;j<B.size();j++)
	{
		if(is_ancestor(a,B[j]))
			return 1;
	}
	return 0;
}

// returns ancestor v of u such that d[u]-d[v]=k
int ancestor(int u, int k) {
	// for this we represent k in binary as
	// k = 2^h1 + 2^h2 + ... + 2^hs
	// and change u to p[u][h] for each h=hi
	// since p[u][h] exactly 2^h vertexes up from u
	for (int h = 0; (1 << h) <= k; ++h) {
		if (k & 1 << h) {
			u = p[u][h];
		}
	}
	return u;
}

int LCA(int a,int b)
{
	if(is_ancestor(a,b))
		return a;
	else if(is_ancestor(b,a))
		return b;
	else
	{
		for(int h=LOG2[d[a]];h>=0;h--)
		{
			if(p[a][h]!=0 && !is_ancestor(p[a][h],b))
				a=p[a][h];
		}
		return p[a][0];
	}
}

int LCA(vector<int> Que)
{
	int lca0=Que[0];
	for(int i=1;i<Que.size();i++)
		lca0=LCA(lca0,Que[i]);
	return lca0;
}

int get_dist(int a,int b)
{
	if(is_ancestor(a,b))
		return dist[b]-dist[a];
	else if(is_ancestor(b,a))
		return dist[a]-dist[b];
	else
		return dist[a]+dist[b]-2*dist[LCA(a,b)];
}

int getFurthest(int a,vector<int> Que,int &mx)
{
	int di, loc=a;
	mx=-1;
	for(int j=0,i=Que[j];j<Que.size();j++,i=Que[j])
	{
		if((di=get_dist(a,i))>mx)
		{
			mx=di;
			loc=i;
		}
	}
	return loc;
}

int get_min_easy(int a,int w)
{
	int h, minD, n=d[a]-d[w];
	if(n==0)
		return maxN+100;
	for(h=LOG2[n],minD=maxN+100;h>=0;h--)
	{
		if(n&(1<<h))
		{
			minD=minc[a][h]<minD?minc[a][h]:minD;
			a=p[a][h];			
		}
	}
	return minD;
}

int get_min(int a,int b)
{
	int w=LCA(a,b);
	int minD, minD1;
	minD=get_min_easy(a,w);
	minD1=get_min_easy(b,w);
	return minD1<minD?minD1:minD;
}

/*
// the minimum edge belonging to each path u-U[i]
int get_min(int u, const vector<int> &U) {
	int res = maxC + 1;
	for (int h = LOG2[d[u]]; h >= 0; --h) {
		if (!p[u][h] || is_ancestor(p[u][h], U)) {
			continue;
		}
		res = min(res, minc[u][h]);
		u = p[u][h];
	}
	res = min(res, minc[u][0]);
	return res;
}
*/
int get_min(int b,vector<int> A)
{
	int a=LCA(A), minD=maxN+100;
	
	for(int h=LOG2[d[b]-d[a]];h>=0;h--)
	{
		if(!p[b][h] || is_ancestor(p[b][h],A))
			continue;
		minD=minc[b][h]<minD?minc[b][h]:minD;
		b=p[b][h];
	}
	return minc[b][0]<minD?minc[b][0]:minD;
}

int main() {
	// precalc of LOG2[n]
	for (int h = 0; (1 << h) < maxN; ++h) {
		for (int n = 1 << h; n < maxN && n < (1 << (h + 1)); ++n) {
			LOG2[n] = h;
		}
	}

	// input tree
	int n;
	scanf("%d" ,&n);
	for (int u = 1; u <= n; ++u) {
		maStr[u].clear();
	}
	for (int i = 0; i < n - 1; ++i) {
		int u, v, c;
		scanf("%d%d%d", &u, &v, &c);
		maStr[u].push_back(make_pair(v, c));
		maStr[v].push_back(make_pair(u, c));
	}

	// dfs to find parent of each vertex, in and out time and so on
	// all global variables are initialized by zeros so no need to initialize them
	dfs(1);

	// binary lifting for parents and minimums
	for (int h = 0; (1 << (h + 1)) < n; ++h) {
		for (int u = 1; u <= n; ++u) {
			int pu = p[u][h];
			p[u][h + 1] = p[pu][h];
			minc[u][h + 1] = min(minc[u][h], minc[pu][h]);
		}
	}

	int Q;
	scanf("%d", &Q);
	for (int q = 0; q < Q; ++q) {
		int K;
		scanf("%d", &K);
		VI F(K);
		for (int i = 0; i < K; ++i) {
			scanf("%d", &F[i]);
		}
		int mx;
		int u1 = getFurthest(F[0], F, mx);
		int u2 = getFurthest(u1, F, mx);
		// u1 and u2 are two furthest vertexes among given K
		// and mx is the gistance between them
		printf("%d ", mx);

		// U1 is the set of vertexes in F for which dist to u2 is mx
		// U2 is the set of vertexes in F for which dist to u1 is mx
		// u1 will belong to U1, u2 will belong to U2
		bool noB = false;
		VI U1, U2;
		for (int i = 0; i < K; ++i) {
			int cnt = 0;
			if (get_dist(u1, F[i]) == mx) {
				U2.push_back(F[i]);
				++cnt;
			}
			if (get_dist(u2, F[i]) == mx) {
				U1.push_back(F[i]);
				++cnt;
			}
			if (cnt == 2) {
				noB = true;
			}
		}
		// if for some vertex Fi dist to both u1 and u2 = mx
		// there is no common edge at ideal paths
		if (noB) {
			printf("-1\n");
			continue;
		}

		// otherwise we find lca of all U1 and also of all U2
		int lca1 = LCA(U1);
		int lca2 = LCA(U2);
		// and do some analysis
		int min_edge;
		// if one of lca1, lca2 is ancestor of another
		// then we apply get_min for vertex and list
		if (is_ancestor(lca1, lca2)) {
			min_edge = get_min(lca2, U1);
		} else if (is_ancestor(lca2, lca1)) {
			min_edge = get_min(lca1, U2);
		} else {
			// in this case the path lca1 - lca2 is the intersection of all ideal path
			min_edge = get_min(lca1, lca2);
		}
		printf("%d\n", min_edge);
	}
	return 0;
}