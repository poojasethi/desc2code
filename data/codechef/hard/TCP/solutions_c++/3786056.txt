/*
    Problem:
	Date:        4/20/2014 9:51:21 PM
	Description: APRIL COOK OFF
*/

#include <iostream>
#include <cstdio>
#include <vector>
#include <string>
#include <algorithm>
#include <queue>
#include <map>
#include <set>
#include <utility>
#include <iomanip>

typedef long long int ll;

ll gcd(ll a, ll b){ if(!b) return a; return gcd(b,a%b);}
using namespace std;

double m[16], invOut[16];
double ABCD[4],d[4]; 

bool MatrixInverse()
{
    double inv[16], det;
    int i;

    inv[0] = m[5]  * m[10] * m[15] - 
             m[5]  * m[11] * m[14] - 
             m[9]  * m[6]  * m[15] + 
             m[9]  * m[7]  * m[14] +
             m[13] * m[6]  * m[11] - 
             m[13] * m[7]  * m[10];

    inv[4] = -m[4]  * m[10] * m[15] + 
              m[4]  * m[11] * m[14] + 
              m[8]  * m[6]  * m[15] - 
              m[8]  * m[7]  * m[14] - 
              m[12] * m[6]  * m[11] + 
              m[12] * m[7]  * m[10];

    inv[8] = m[4]  * m[9] * m[15] - 
             m[4]  * m[11] * m[13] - 
             m[8]  * m[5] * m[15] + 
             m[8]  * m[7] * m[13] + 
             m[12] * m[5] * m[11] - 
             m[12] * m[7] * m[9];

    inv[12] = -m[4]  * m[9] * m[14] + 
               m[4]  * m[10] * m[13] +
               m[8]  * m[5] * m[14] - 
               m[8]  * m[6] * m[13] - 
               m[12] * m[5] * m[10] + 
               m[12] * m[6] * m[9];

    inv[1] = -m[1]  * m[10] * m[15] + 
              m[1]  * m[11] * m[14] + 
              m[9]  * m[2] * m[15] - 
              m[9]  * m[3] * m[14] - 
              m[13] * m[2] * m[11] + 
              m[13] * m[3] * m[10];

    inv[5] = m[0]  * m[10] * m[15] - 
             m[0]  * m[11] * m[14] - 
             m[8]  * m[2] * m[15] + 
             m[8]  * m[3] * m[14] + 
             m[12] * m[2] * m[11] - 
             m[12] * m[3] * m[10];

    inv[9] = -m[0]  * m[9] * m[15] + 
              m[0]  * m[11] * m[13] + 
              m[8]  * m[1] * m[15] - 
              m[8]  * m[3] * m[13] - 
              m[12] * m[1] * m[11] + 
              m[12] * m[3] * m[9];

    inv[13] = m[0]  * m[9] * m[14] - 
              m[0]  * m[10] * m[13] - 
              m[8]  * m[1] * m[14] + 
              m[8]  * m[2] * m[13] + 
              m[12] * m[1] * m[10] - 
              m[12] * m[2] * m[9];

    inv[2] = m[1]  * m[6] * m[15] - 
             m[1]  * m[7] * m[14] - 
             m[5]  * m[2] * m[15] + 
             m[5]  * m[3] * m[14] + 
             m[13] * m[2] * m[7] - 
             m[13] * m[3] * m[6];

    inv[6] = -m[0]  * m[6] * m[15] + 
              m[0]  * m[7] * m[14] + 
              m[4]  * m[2] * m[15] - 
              m[4]  * m[3] * m[14] - 
              m[12] * m[2] * m[7] + 
              m[12] * m[3] * m[6];

    inv[10] = m[0]  * m[5] * m[15] - 
              m[0]  * m[7] * m[13] - 
              m[4]  * m[1] * m[15] + 
              m[4]  * m[3] * m[13] + 
              m[12] * m[1] * m[7] - 
              m[12] * m[3] * m[5];

    inv[14] = -m[0]  * m[5] * m[14] + 
               m[0]  * m[6] * m[13] + 
               m[4]  * m[1] * m[14] - 
               m[4]  * m[2] * m[13] - 
               m[12] * m[1] * m[6] + 
               m[12] * m[2] * m[5];

    inv[3] = -m[1] * m[6] * m[11] + 
              m[1] * m[7] * m[10] + 
              m[5] * m[2] * m[11] - 
              m[5] * m[3] * m[10] - 
              m[9] * m[2] * m[7] + 
              m[9] * m[3] * m[6];

    inv[7] = m[0] * m[6] * m[11] - 
             m[0] * m[7] * m[10] - 
             m[4] * m[2] * m[11] + 
             m[4] * m[3] * m[10] + 
             m[8] * m[2] * m[7] - 
             m[8] * m[3] * m[6];

    inv[11] = -m[0] * m[5] * m[11] + 
               m[0] * m[7] * m[9] + 
               m[4] * m[1] * m[11] - 
               m[4] * m[3] * m[9] - 
               m[8] * m[1] * m[7] + 
               m[8] * m[3] * m[5];

    inv[15] = m[0] * m[5] * m[10] - 
              m[0] * m[6] * m[9] - 
              m[4] * m[1] * m[10] + 
              m[4] * m[2] * m[9] + 
              m[8] * m[1] * m[6] - 
              m[8] * m[2] * m[5];

    det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    if (det == 0)
        return false;

    det = 1.0 / det;

    for (i = 0; i < 16; i++)
        invOut[i] = inv[i] * det;

    return true;
}

void v(int i, int t)
{
 	 m[4*i]   = t*t*t*1.0;
 	 m[4*i+1] = t*t*1.0;
 	 m[4*i+2] = t*1.0;
 	 m[4*i+3] = 1*1.0;
}

double val(double t){ return ABCD[0]*t*t*t + ABCD[1]*t*t + ABCD[2]*t + ABCD[3]; }

double FindRoot(double i, double j)
{
    double mid = (i+j)/2;
    
    if(val(mid)<0.0000000001 && val(mid)>-0.0000000001)  return mid;
    
    if(val(i)<0 && val(j)>0)
    {
			 if(val(i)<0 && val(mid)<0)
			        return FindRoot(mid,j);
             if(val(i)<0 && val(mid)>0)
			        return FindRoot(i,mid);
    }
    if(val(i)>0 && val(j)<0)
    {
	 	     if(val(i)>0 && val(mid)>0)
			        return FindRoot(mid,j);
             if(val(i)>0 && val(mid)<0)
			        return FindRoot(i,mid);
    }
}

void MatrixMul()
{
 	 int i,j;
 	 
 	 for(i=0;i<4;i++)
 	 {
	  				 ABCD[i] = 0.0;
	  				 for(j=0;j<4;j++)
					     ABCD[i] += invOut[4*i+j]*d[j];
     }
 	 
}

double iVal(double t){ return ABCD[0]*t*t*t*t/4.0 + ABCD[1]*t*t*t/3.0 + ABCD[2]*t*t/2.0 + ABCD[3]*t*1.0; }

int main()
{
 	int n;
 	cin>>n;
 	
 	while(n--)
 	{
	 		  int T,i,j,r=0;
	 		  int cv,ct;
	 		  double dist=0.00;
	 		  double root[3];
	 		  
	 		  cin>>T;
	 		  
	 		  for(i=0;i<4;i++)
	 		  {  
			   				  cin>>ct>>cv;
			   				  
			   				  d[i]=cv;
			   				  v(i,ct);
			  }
			  
			  
			  
			  MatrixInverse();
			  MatrixMul();
			  
			  for(i=0;i<=T;i++)
			  {
				  if(val(i)==0) root[r++]=i*1.0;
				  else if(val(i*1.0)<0 && val((i+1)*1.0)>0)  root[r++] = FindRoot(i*1.0,(i+1)*1.0);
				  else if(val(i*1.0)>0 && val((i+1)*1.0)<0)  root[r++] = FindRoot(i*1.0,(i+1)*1.0);
			  } 
			  
			  root[r++] = T;
			  
			  dist=0.00;
			  
			  for(i=0;i<r;i++)
			  {
			            if(!i)
						{
						 	  if(ABCD[3]<0)  dist += iVal(0)-iVal(root[0]);
						 	  else  dist += iVal(root[0])-iVal(0);
				        }
						else
						{
						 	  double mid = (root[i]+root[i-1])/2.0;
						 	  
						 	  if(val(mid)<0)  dist +=  iVal(root[i-1])-iVal(root[i]); 
						 	  else  dist += iVal(root[i])-iVal(root[i-1]);
					    }	  
			  }
			  
			  cout<<setprecision(12)<<dist<<endl;	  
    }

return 0;
}
