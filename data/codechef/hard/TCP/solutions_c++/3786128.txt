#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <string>
#include <cmath>
#include <cctype>
#include <queue>
#include <stack>
#include <map>
#include <set>
#include <iostream>
#include <ctime>
#include <cassert>
#include <sstream>

using namespace std;

#define INF 0x3f3f3f3f
#define ll long long
#define SZ(x) (int)((x).size())

const double EPS = 1e-12;

typedef vector<int> VI;
typedef double T;
typedef vector<T> VT;
typedef vector<VT> VVT;

T GaussJordan(VVT &a, VVT &b) {
  const int n = a.size();
  const int m = b[0].size();
  VI irow(n), icol(n), ipiv(n);
  T det = 1;

  for (int i = 0; i < n; i++) {
    int pj = -1, pk = -1;
    for (int j = 0; j < n; j++) if (!ipiv[j])
      for (int k = 0; k < n; k++) if (!ipiv[k])
    if (pj == -1 || fabs(a[j][k]) > fabs(a[pj][pk])) { pj = j; pk = k; }
    if (fabs(a[pj][pk]) < EPS) { cerr << "Matrix is singular." << endl; exit(0); }
    ipiv[pk]++;
    swap(a[pj], a[pk]);
    swap(b[pj], b[pk]);
    if (pj != pk) det *= -1;
    irow[i] = pj;
    icol[i] = pk;

    T c = 1.0 / a[pk][pk];
    det *= a[pk][pk];
    a[pk][pk] = 1.0;
    for (int p = 0; p < n; p++) a[pk][p] *= c;
    for (int p = 0; p < m; p++) b[pk][p] *= c;
    for (int p = 0; p < n; p++) if (p != pk) {
      c = a[p][pk];
      a[p][pk] = 0;
      for (int q = 0; q < n; q++) a[p][q] -= a[pk][q] * c;
      for (int q = 0; q < m; q++) b[p][q] -= b[pk][q] * c;      
    }
  }

  for (int p = n-1; p >= 0; p--) if (irow[p] != icol[p]) {
    for (int k = 0; k < n; k++) swap(a[k][irow[p]], a[k][icol[p]]);
  }

  return det;
}

VVT a,b;

double getf(double i) {
    return b[0][0]*i*i*i + b[1][0]*i*i + b[2][0]*i + b[3][0];
}

double getF(double i) {
    return b[0][0]*i*i*i*i/4.0 + b[1][0]*i*i*i/3.0 + b[2][0]*i*i/2.0 + b[3][0]*i;
}

int main() {
    //~ cin.sync_with_stdio(false);
    int nt;
    double t;
    a.resize(4);
    for (int i=0; i<4; i++)
        a[i].resize(4);
    b.resize(4);
    for (int i=0; i<4; i++)
        b[i].resize(1);
    
    scanf("%d",&nt);
    while (nt--) {
        scanf("%lf",&t);
        for (int i=0; i<4; i++) {
            double ct,cv,p=1.0;
            scanf("%lf%lf",&ct,&cv);
            b[i][0] = cv;
            for (int j=3; j>=0; j--) {
                a[i][j] = p;
                p *= ct;
            }
        }
        
        GaussJordan(a,b);
        
       double ans = 0.0;
       double lo,hi,mid;
       for (double i=0; i+0.5<=t; i+=0.5) {
           double fi,fi1;
           fi = getf(i);
           fi1 = getf(i+0.5);
           if (fi*fi1 < 0.0) {
               lo = i; hi = i+0.5;
               for (int k=0; k<80; k++) {
                    mid = (lo+hi)/2.0;
                    if (fi*getf(mid) < 0.0) hi = mid;
                    else lo = mid;
               }
               ans += abs(getF(lo)-getF(i)) + abs(getF(i+0.5)-getF(lo));
           }
           else {
               ans += abs(getF(i+0.5)-getF(i));
           }
       }
        
        printf("%.15lf\n",ans);
    }
    
    return 0;
}
