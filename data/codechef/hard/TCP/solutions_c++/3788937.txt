#include <iostream>
#include <cmath>
#include <cstring>
#include <algorithm>

using namespace std;

long double M[4];
long double D[4];
long double DE;
long double S;
long double V[4];
long double W[4];
long double X[5];

void lagrangeInterpolation()
{
    for (int i = 0; i < 4; ++i)
    {
        D[i] = 1;
        W[i] = 0;
    }
    for (int i = 0; i < 4; ++i)
    {
        for (int j = 0; j < 4; ++j)
        {
            if (i == j)
            {
                continue;
            }
            D[i] *= (M[i] - M[j]);
        }
    }

    W[3] = V[0]/D[0] + V[1]/D[1] + V[2]/D[2] + V[3]/D[3];
    W[2] = - (V[0]/D[0]*(M[1]+M[2]+M[3]))
           - (V[1]/D[1]*(M[0]+M[2]+M[3]))
           - (V[2]/D[2]*(M[0]+M[1]+M[3]))
           - (V[3]/D[3]*(M[0]+M[1]+M[2]));
    W[1] = + V[0]/D[0]*(M[1]*M[2]+M[2]*M[3]+M[3]*M[1])
           + V[1]/D[1]*(M[0]*M[2]+M[2]*M[3]+M[3]*M[0])
           + V[2]/D[2]*(M[0]*M[1]+M[1]*M[3]+M[3]*M[0])
           + V[3]/D[3]*(M[0]*M[1]+M[1]*M[2]+M[2]*M[0]);
    W[0] = - V[0]/D[0]*M[1]*M[2]*M[3]
           - V[1]/D[1]*M[0]*M[2]*M[3]
           - V[2]/D[2]*M[0]*M[1]*M[3]
           - V[3]/D[3]*M[0]*M[1]*M[2];
}

inline long double integralF(long double s1)
{
    return s1*(W[0] + s1*(W[1]/2.0L + s1*(W[2]/3.0L + s1*W[3]/4.0L)));
}

inline long double calcAbsIntegral(long double s1, long double s2)
{
    return abs(integralF(s1) - integralF(s2));
}

#define MAXITER 5000  // maksymalna liczba iteracji dla metody stycznych
long double eps=0.00000000000000000001L;  // dokladnosc obliczeń
long double eps2=0.000000001L;

// Oblicza wartość wielomianu oraz jego pierwszej pochodnej
long double PolyValueAndDiff(long double w[], int deg, long double x, long double &diff)
{
    long double y = w[deg]; // wartość
    diff = y;               // pochodna
    for (int i = deg-1; i >= 1; --i)
    {
        y = y*x + w[i];
        diff = diff*x + y;
    }
    y=y*x + w[0];
    return y;
}

// Wyszukuje miejsce zerowe wielomianu w oparciu o metode stycznych zaczynajac od punktu x0 z dokl. eps
long double PolyNewton(long double w[], int deg, long double x0)
{
    long double diff;
    long double val = PolyValueAndDiff(w, deg, x0, diff);
    int i = 0;
    long double x1 = x0;
    while ((abs(val) > eps) || (abs(x1-x0) > eps))
    {
        if (abs(diff) < eps)
        {
            diff = 0.0001;
        }
        x1 = x0;
        x0 = x0 - val/diff;
        val = PolyValueAndDiff(w, deg, x0, diff);
        i++;
        if (i > MAXITER)
        {
            if (abs(val) > eps2)
            {
                throw MAXITER;
            }
            break;
        }
    }
    return x0;
}

// Dzieli wielomian o wsp. w w przez dwumian (x-x0), zapisujac nowe wsp. w wd
// Zwraca stopien nowego wielomianu. Schemat Hornera bez reszty
int PolyDiv(long double w[], long double wd[], int deg, long double x0)
{
    for (int i = 1; i <= deg; ++i)
    {
        wd[i-1] = w[i];
    }
    for (int i = deg-1; i > 0; --i)
    {
        wd[i-1] = w[i] + x0*wd[i];
    }
    return deg-1;
}

// Funkcja znajduje miejsca zerowe wielomianu o wsp. w w i stopniu deg, zwraca ilosc miejsc zerowych
// Miejsca zerowe umieszczne są w tablicy wr. W x0 punkt startowy, w eps dokladność obliczeń
int PolyRoots(long double w[], long double wr[], int deg, long double x0=1)
{
    long double w1[deg+1];
    long double w2[deg+1];
    memcpy(w1, w, sizeof(long double)*(deg+1));

    int i = 0;
    int deg1 = deg;
    while (i < deg)
    {
        try
        {
            x0 = PolyNewton(w1, deg1, x0);
        }
        catch (...)
        {
            return i;
        }
        wr[i] = x0;
        deg1 = PolyDiv(w1, w2, deg1, x0);
        memcpy(w1, w2, sizeof(long double)*(deg1 + 1));
        i++;
    }
    return i;
}

const double EPS   = 0.0000000000000001;

inline long double qrt(long double x)
{
    return abs(x) < EPS ? 0 : (x > 0 ? exp(log(x)/3) : -exp(log(-x)/3));
}

int calcRootsOfW()
{
    long double a,b,c,d,f,g,h,i,j,k,m,n,p;
    a = W[3];
    b = W[2];
    c = W[1];
    d = W[0];

    f = (c - b*b/3.0L/a)/a;
    g = ((2.0L*b*b/9.0L/a - c)/a*b/3.0L + d)/a;
    h = g*g/4.0L + f*f*f/27.0L;

    if((abs(f) < EPS) && (abs(g) < EPS))
    {
        X[1] = - qrt(d/a);
        return 1;
    }
    else if(h >= EPS)
    {
        X[1] = qrt(-g/2.0L + sqrt(h)) + qrt(-g/2.0L - sqrt(h)) - b/3.0L/a;
        return 1;
    }
    else
    {
        i  = sqrt(g*g/4.0L - h);
        j  = qrt(i);
        k  = acos(-g/2.0L/i);
        m  = cos(k/3.0L);
        n  = sqrt(3.0L)*sin(k/3.0L);
        p  = -b/3.0L/a;
        X[1] = 2.0L*j*m + p;
        X[2] = -j*(m + n) + p;
        X[3] = -j*(m - n) + p;
        return 3;
    }
}

void testCase()
{
    cin >> S;
    cout.precision(100);

    for (int i = 0; i < 4; ++i)
    {
        cin >> M[i] >> V[i];
    }

    lagrangeInterpolation();

    long double w[5];
    for (int i = 3; i >= 0; --i)
    {
        w[i] = (long double) W[i];
    }

    int cnt = PolyRoots(w, X, 3);
    X[cnt++] = 0.0;
    X[cnt++] = S;
    sort(X, X+cnt);

/*
    int cnt = calcRootsOfW();
    X[0] = 0.0L;
    X[cnt+1] = S;
    cnt += 2;
    sort(X, X+cnt);
*/

    long double result = 0.0L;
    bool start = false;
    for (int i = 0; i < cnt-1; ++i)
    {
        if (abs(X[i]) == 0.0L)
        {
            start = true;
        }
        if (start && (X[i+1] <= S))
        {
            long double res = calcAbsIntegral(X[i], X[i+1]);
            result += res;
        }
    }

    cout.precision(100);
    cout << result << endl;
}

int main()
{
    int T;
    cin >> T;
    for (int i = 0; i < T; ++i)
    {
        testCase();
    }
    return 0;
}
