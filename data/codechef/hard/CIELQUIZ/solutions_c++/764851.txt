
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stdint.h>
#include <algorithm>

int DEBUG = 0;

struct NODE {
  int i;
  int v;
};
int compare_NODE_inc (const void * a, const void * b) {
  return ( (*(NODE*)a).v - (*(NODE*)b).v );
}

void print_vec(int *vec, int n, const char *str=NULL) {
  if(str != NULL) printf("%s ", str);
  for(int i=0; i<n; i++) {
    if(i>0) printf(" ");
    printf("%d", vec[i]);
  }
  printf("\n");
  fflush(stdout);
}

double calcProb(int *P, int K) {
  double sum = 0.0;
  for(int i=0; i<K; i++) {
    double prod = 1.0;
    for(int j=0; j<K; j++) {
      prod *= (j==i ? (1.0-P[j]/100.0) : (1.0*P[j]/100.0));
    }
    sum += prod;
  }
  if(DEBUG) {
    print_vec(P, K, "P:");
    printf("calcProb= %g\n", sum);
  }
  return sum;
}

main(int argc, char **argv) {
  DEBUG = (argc>=2) ? atoi(argv[1]) : 0;

  int T, N, K;
  scanf("%d", &T);

  NODE nodes[36];
  for(int t=0; t<T; t++) {
    scanf("%d%d", &N, &K);
    for(int i=0; i<N; i++) {
      int Pi;
      scanf("%d", &Pi);
      nodes[i].v = Pi;
      nodes[i].i = i;
    }
    qsort(nodes, N, sizeof(NODE), compare_NODE_inc);
    int max_i = 0;
    double max_prob = 0.0;
    int P[K];
    for(int i=0; i<=K; i++) {
      int cnt=0;
      for(int j=0; j<i; j++) {
	P[cnt++] = nodes[j].v;
      }
      for(int j=N-K+i; j<N; j++) {
	P[cnt++] = nodes[j].v;
      }
      double prob = calcProb(P, cnt);
      if(max_prob < prob) {
	max_i = i;
	max_prob = prob;
      }
    }
    int cnt=0;
    int out[K];
    for(int i=0; i<max_i; i++) {
      out[cnt++] = nodes[i].i+1;
    }
    for(int i=N-K+max_i; i<N; i++) {
      out[cnt++] = nodes[i].i+1;
    }
    std::sort(out, out+K);
    print_vec(out, K);
  }

}

// g++ CIELQUIZ.cpp; cat CIELQUIZ.in  | ./a.out


