#include<algorithm>
#include<vector>
#include<iostream>
#include<set>
#include<map>
#include<list>
using namespace std;
#define mod 1000000007
long long int fact[100007];
long long int power[100007];
bool flagg;
void gen()
{
fact[0]=1;
power[0]=1;
for(long long int i=1;i<=100000;i++)
{
fact[i]=(fact[i-1]*i)%mod;
power[i]=(2LL*power[i-1])%mod;
}
}

bool dfs(int i,list<int>*adj,bool *visited,int parent)
{
visited[i]=true;
list<int>::iterator j;
for(j=adj[i].begin();j!=adj[i].end();j++)
if(!visited[*j])
dfs(*j,adj,visited,i);
else if(*j!=parent)
flagg=false;
}

long long int cal(vector<pair<int,int> >temp,int n)
{
map<int,int>m;
int c=0;
for(int i=0;i<temp.size();i++)
{
if(m.find(temp[i].first)==m.end())
m[temp[i].first]=c++;
if(m.find(temp[i].second)==m.end())
m[temp[i].second]=c++;
}
list<int>adj[20];
bool visited[20];
fill(visited,visited+20,false);
for(int i=0;i<temp.size();i++)
{
adj[m[temp[i].first]].push_back(m[temp[i].second]);
adj[m[temp[i].second]].push_back(m[temp[i].first]);
}
for(int i=0;i<c;i++)
if(adj[i].size()>2)
return 0;
int color=0;
for(int i=0;i<c;i++)
if(!visited[i])
{
flagg=true;
color++;
dfs(i,adj,visited,-1);
if(!flagg)
return 0;
}
long long int ans=n-c+color;
ans=fact[ans]*power[color];
ans=ans%mod;
return ans;
}

long long int func(vector<pair<int,int> >edge,int n,int m)
{
long long int ans=0;
for(int i=1;i<(1<<m);i++)
{
vector<pair<int,int> >temp;
for(int j=0;j<m;j++)
if(i&1<<j)
temp.push_back(edge[j]);
if(temp.size()%2==0)
ans=(ans-cal(temp,n)+mod)%mod;
else
ans=(ans+cal(temp,n))%mod;
}
return (fact[n]-ans+mod)%mod;
}

int main()
{
ios_base::sync_with_stdio(false);
gen();
int t;
cin>>t;
while(t--)
{
int n,m;
cin>>n>>m;
vector<pair<int,int> >edge;
for(int i=1;i<=m;i++)
{
int u,v;
cin>>u>>v;
if(u>v)
swap(u,v);
edge.push_back(make_pair(u,v));
}
cout<<func(edge,n,m)<<endl;
}
return 0;
}
