#include <bits/stdc++.h>
#define mod 1000000007
#define REP(i,a,b) for(i=a;i<=b;i++)
using namespace std;
typedef long long ll;
typedef vector<ll> vi;
typedef pair<ll,ll> ii;
ii p[100];
vi g[100],mrk,par,fact,v;
map<ll,ll> mp;
void init(){
    ll i;
    fact.assign(100010,0);
    fact[0]=1;
    REP(i,1,100009)
        fact[i]=(fact[i-1]*i)%mod;
}
ll dfs(ll v){
    ll i,x,res=1;
    mrk[v]=1;
    for(i=0;i<g[v].size();i++){
        x=g[v][i];
        if(!mrk[x])
            par[x]=v,res+=dfs(x);
        else if(mrk[x]==1 && x!=par[v])
            return -mod;
    }
    return res;
}
int main(){
    map<ll,ll>::iterator it;
    int t;
    cin>>t;
    init();
    while(t--){
        mp.clear();
        ll i,j,n,m,a,b,c=0,d=0,x,y,sum,ans=0,flag;
        cin>>n>>m;
        REP(i,0,m-1){
            cin>>a>>b;  a--,b--;
            mp[a]=mp[b]=1;
            REP(j,0,c-1){
                x=p[j].first;   y=p[j].second;
                if((x==a && y==b)||(x==b && y==a))
                    break;
            }
            if(j==c)
                p[c++]=ii(a,b);
        }
        for(it=mp.begin();it!=mp.end();it++)
            it->second=d++;
        REP(i,0,c-1){
            x=p[i].first;   y=p[i].second;
            p[i]=ii(mp[x],mp[y]);
        }
        REP(i,0,(1<<c)-1){
            v.clear();
            mrk.clear();    par.clear();
            mrk.assign(d,-1);
            par.assign(d,0);
            REP(j,0,d-1)
                par[j]=j,g[j].clear();
            a=flag=0;
            REP(j,0,c-1)
                if(i&(1<<j)){
                    a++;
                    x=p[j].first;   y=p[j].second;
                    g[x].push_back(y);  g[y].push_back(x);
                    mrk[x]=mrk[y]=0;
                }
            REP(j,0,d-1){
                if(g[j].size() > 2){
                    flag=1;
                    break;
                }
                if(g[j].size()==2)
                    continue;
                if(!mrk[j])
                    v.push_back(dfs(j));
            }
            if(flag)
                continue;
            x=v.size();
            REP(j,0,d-1)
                if(g[j].size()==2 && !mrk[j]){
                    y=dfs(j);
                    if(y==n && x==0)
                        ans+=pow(-1,a)*2;
                    flag=1;
                    break;
                }
            if(flag)
                continue;
            sum=0;     b=(1<<x)%mod;
            for(j=0;j<x;j++)
                sum+=v[j];
            if(a%2==0)
                ans=(ans+(b*fact[n-sum+x])%mod)%mod;
            else
                ans=(ans+mod-(b*fact[n-sum+x])%mod)%mod;
        }
        cout<<ans<<endl;
    }
}