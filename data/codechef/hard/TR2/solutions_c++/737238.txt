#include <cstdio>
#include <iostream>
#include <vector>
#include <list>
#include <cmath>
#include <fstream>
#include <algorithm>
#include <string>
#include <queue>
#include <set>
#include <map>
#include <complex>
#include <iterator>
#include <cstdlib>
#include <cstring>
#include <sstream>

using namespace std;

#define EPS (1e-10)
#define EQ(a,b) (abs((a) - (b)) < EPS)
#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))

typedef complex<double> P;
typedef pair<P,P> Edge;
typedef long long ll;

const double PI=4*atan(1.0);

void fast_stream(){
	std::ios_base::sync_with_stdio(0);
}
	
//#define RED_FILE

#ifdef RED_FILE
ifstream ifs("input.txt");
ofstream ofs("output.txt");
#define cin ifs
#define cout ofs
#endif

struct edge {
    int to;
    char ag;
};

struct node{
    node(){
        rc=lc=NULL;
        s=0;
    }
    node *lc;
    node *rc;
    int s;
};

// 全体をあらわすグラフ.該当ノードを何度通過したかをカウント.
vector<edge> G[10001];
int maxLen[10001];

void dfs(int s,node *cn){
    cn->s++;
    for(int i = 0; i < G[s].size(); i++){
        edge &e=G[s][i];
        if(e.ag=='L'){
            if(cn->lc==NULL)
                cn->lc=new node();
            dfs(e.to,cn->lc);
        }
        else{
            if(cn->rc==NULL)
                cn->rc=new node();
            dfs(e.to,cn->rc);
        }
    }
}

void dfs2(node *cn,int depth){
    if(cn==NULL)return;
    int passCnt=cn->s;
    for(int i = 1; i <= passCnt; i++)
        maxLen[i]=max(maxLen[i],depth);
    dfs2(cn->lc,depth+1);
    dfs2(cn->rc,depth+1);
}

void delTree(node *nd){
    if(nd==NULL)return;
    delTree(nd->lc);
    delTree(nd->rc);
    delete nd;
}

void solve(){
    fast_stream();
    int t;
    cin>>t;
    while(t--){
        node *root=new node();
        memset(maxLen,0,sizeof(maxLen));
        int m;
        cin>>m;
        for(int i = 0; i < m; i++){
            int n;
            for(int i = 0; i < 10001; i++)G[i].clear();
            cin>>n;
            for(int j = 0; j < n-1; j++){
                int u,v;
                char c;
                cin>>u>>c>>v;
                edge e;
                e.to=v;e.ag=c;
                G[u].push_back(e);
            }
            dfs(1,root);
        }
        // 最後に全ノードを探索して、通過回数ごとの最大長を割り出す
        dfs2(root,0);
        for(int i = 1; i <= m; i++){
            cout<<maxLen[i];
            if(i==m)cout<<endl;
            else cout<<" ";
        }
        delTree(root);
    }
}

int main(){

    solve();

    return 0;
}

