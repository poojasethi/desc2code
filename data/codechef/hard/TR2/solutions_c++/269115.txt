#include <vector>
#include <map>
#include <algorithm>
#include <sstream>
#include <iostream>
#include <cmath>
#include <set>
#include <ctime>
#include <cstring>

#define rei(i,a,b) for(int i=a;i<b;i++)
#define ree(i,a,b) for(int i=a;i<=b;i++)
#define red(i,a,b) for(int i=a;i>=b;i--)
#define pb(a,x) a.push_back(x)
#define sort(v) sort(v.begin(),v.end())

using namespace std;

struct node{
	int numOfMap,len;
	struct node* lft;
	struct node* rht;
};

int main()
{
//	freopen("input.txt","r",stdin);
//	freopen("output.txt","w",stdout);
	int T;
	scanf("%d",&T);
	rei(t,0,T){
		int L[1001][2];// L[i][j][0] = in ith Map jth node's LEFT child , 0->1 LEFT -> RIGHT 
		int m,c;
		scanf("%d",&m);
		vector<int> sz(m,-1);
		struct node* root=new node();
		root->lft=NULL;
		root->rht=NULL;
		root->len=0;
		root->numOfMap=0;
		rei(j,0,m){
			struct node* NODE=new node();
			NODE=root;
			memset(L,-1,sizeof(L));
			scanf("%d",&c);
			rei(i,0,c-1){
				int u,v;
				char ch;
				scanf("%d",&u);ch=getchar();ch=getchar();scanf("%d",&v);
				ch=='L'?L[u][0]=v:L[u][1]=v;
			}
			//Now Running DFS 
			vector<int> st;
			st.push_back(1);
			vector<string> pos(1001,"");
			vector<struct node*> tree(c+1);
			tree[1]=new node();
			tree[1]=root;
			while(st.size()!=0){
				int ver=st[st.size()-1];
				string posver=pos[ver];
				NODE=tree[ver];
				NODE->numOfMap++;
				int depth=posver.size();
				NODE->len=depth;
				int maps=NODE->numOfMap;
				sz[maps-1]=max(sz[maps-1],depth); //Stored Max depth correspoondibng to m number of maps
				st.pop_back();
				int Liverz=L[ver][0];
				int Livero=L[ver][1];
				if(Liverz!=-1){ 
					pb(st,Liverz);
					pos[Liverz]=posver+"L"; 
					if(NODE->lft==NULL){
						NODE->lft=new node();
						tree[Liverz]=new node();
						tree[Liverz]=NODE->lft;
						tree[Liverz]->numOfMap=0;
						tree[Liverz]->len=0;
						tree[Liverz]->lft=NULL;
						tree[Liverz]->rht=NULL;
					}else{
						tree[Liverz]=NODE->lft;
					}
				}
				if(Livero!=-1){ 
					pb(st,Livero); 
					pos[Livero]=posver+"R";
					if(NODE->rht==NULL){
						NODE->rht=new node();
						tree[Livero]=new node();
						tree[Livero]=NODE->rht;
						tree[Livero]->numOfMap=0;
						tree[Livero]->len=0;
						tree[Livero]->lft=NULL;
						tree[Livero]->rht=NULL;		
					}else{
						tree[Livero]=NODE->rht;
					}
				}
			}
		}
		int mx=-1;
		red(i,m-1,0){
			mx=max(mx,sz[i]);
			if(sz[i]==-1)
				sz[i]=mx;
		}
		rei(i,0,m){
			printf("%d ",sz[i]);
		}
		printf("\n");
	}
	return 0;
}
