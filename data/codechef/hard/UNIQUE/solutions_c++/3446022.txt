#include <cstdio>
#include <iostream>
#include <algorithm>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <functional>
#include <limits>
#include <cassert>
#include <sstream>
#include <cmath>
#include <string>
#include <fstream>

using namespace std;
typedef long long ll;

const int max_n=100010;
const int max_l=20;
const ll mod=1000000009ll;
const int inf=1e9;

int L[max_n][max_l];
int p[max_n];
pair<int,int> M[max_n],R[max_n];
int e,pwr;

struct node
{
	int f,s,ind;
	node(){}
	node(int t1, int t2, int t3){f=t1;s=t2;ind=t3;}
};

node P[max_n],Q[max_n];

struct less_node_f : public binary_function<node,node,bool>
{
    bool operator()(const node &a, const node &b){ return (a.f<b.f or (a.f==b.f and a.s<b.s)); }
};

int n;
string s;

void suf()
{
	for(int i=0; i<n; i++)
        L[i][0]=s[i]-'a';

    pwr=1,e=1;
    while(pwr<n)
    {
    	for(int i=0; i<n; i++)
    		P[i]=node(L[i][e-1],i+pwr<n?L[i+pwr][e-1]:-1,i);
    	sort(P,P+n,less_node_f());

    	for(int i=0; i<n; i++)
    		if(i>0 and P[i].f==P[i-1].f and P[i].s==P[i-1].s)
    			L[P[i].ind][e]=L[P[i-1].ind][e];
    		else
    			L[P[i].ind][e]=i;

    	pwr*=2;
    	e++;
    }
}

int findlcp(int i, int j)
{
	int ret=0;
    if(i==j)
        return n-i;
	for(int k=e-1; k>=0; k--)
		if(i<n and j<n and L[i][k]==L[j][k])
		{
			ret+=(1<<k);
			i+=(1<<k);
			j+=(1<<k);
		}
	return ret;
}

int ST[2][4*max_n];

void initST(int r, int s, int re)
{
	if(s==re)
		ST[1][r]=inf;
	else
	{
		int mid=(s+re)/2;
		initST(2*r,s,mid);
		initST(2*r+1,mid+1,re);
		ST[1][r]=inf;
	}
}

pair<int,int> queryST(int r, int b, int re, int i, pair<int,int> ret)
{
	if(ret.second>ST[1][r] or (ret.second==ST[1][r] and L[ret.first][e-1]>L[ST[0][r]][e-1]))
		ret=make_pair(ST[0][r],ST[1][r]);

    if(b==re)
        return ret;

    int mid=(b+re)/2;
    if(i<=mid)
        return queryST(2*r,b,mid,i,ret);
    else
        return queryST(2*r+1,mid+1,re,i,ret);
}

void updateST(int r, int b, int re, int i, int j, int ui, int ul)
{
    if(b>=i and re<=j)
    {
        ST[0][r]=ui;
        ST[1][r]=ul;
        return;
    }
    
    int mid=(b+re)/2;
    if(i<=mid)
    	updateST(2*r,b,mid,i,min(j,mid),ui,ul);
	if(j>mid)
    	updateST(2*r+1,mid+1,re,max(mid+1,i),j,ui,ul);
}


int main()
{
    cin>>s;
    n=s.size();

    suf();
    for(int i=0; i<n; i++)
    	M[i]=make_pair(L[i][e-1],i);

    sort(M,M+n);

    for(int i=0; i<n; i++)
    {
    	p[M[i].second]=max(((i>0)?findlcp(M[i].second,M[i-1].second):0),((i<n-1)?findlcp(M[i].second,M[i+1].second):0));
    	Q[i]=node(p[M[i].second],L[M[i].second][e-1],M[i].second);
    }

    sort(Q,Q+n,less_node_f());
    initST(1,0,n-1);

    for(int i=n-1; i>=0; i--)
    {
    	int l=Q[i].f,j=Q[i].ind;
	    if(j+l<n)
	    	updateST(1,0,n-1,j,j+l,j,l+1);
	}

	for(int i=0; i<n; i++)
	{
		R[i]=queryST(1,0,n-1,i,make_pair(0,inf));
		if(i>0)
		{
			int j=R[i-1].first,l=R[i-1].second;
			int lj=R[i].first,ll=R[i].second;
			if(l+1<ll or (l+1==ll and L[j][e-1]<L[lj][e-1]))
				R[i]=make_pair(j,l+1);
		}

		printf("%d %d\n",R[i].first+1,R[i].second);
	}
    
    return 0;
}
