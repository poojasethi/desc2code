#include <bits/stdc++.h>
using namespace std;

const int N = 200010;
int wa[N],wb[N],wv[N],wss[N];
int cmp(int *r,int a,int b,int len)
{
    return r[a] == r[b] && r[a + len] == r[b + len];
}

void da(int *r,int *sa,int n,int m)
{
    int i,j,p,*x = wa,*y = wb,*t;
    for(i = 0; i < m; i ++) wss[i] = 0;
    for(i = 0; i < n; i ++) wss[x[i] = r[i]] ++;
    for(i = 1; i < m; i ++) wss[i] += wss[i - 1];
    for(i = n - 1; i >= 0; i --) sa[-- wss[x[i]]] = i;
    for(j = p = 1; p < n; j *= 2,m = p) {
        for(p = 0, i = n - j; i < n; i ++) y[p ++] = i;
        for(i = 0; i < n; i ++) if(sa[i] >= j) y[p ++] = sa[i] - j;
        for(i = 0; i < n; i ++) wv[i] = x[y[i]];
        for(i = 0; i < m; i ++) wss[i] = 0;
        for(i = 0; i < n; i ++) wss[wv[i]] ++;
        for(i = 1; i < m; i ++) wss[i] += wss[i - 1];
        for(i = n - 1; i >= 0; i --) sa[-- wss[wv[i]]] = y[i];
        for(t = x,x = y,y = t,p = 1,x[sa[0]] = 0, i = 1; i < n; i ++)
            x[sa[i]] = cmp(y,sa[i - 1],sa[i],j) ? p - 1 : p ++;
    }
}

int rak[N],height[N];
void calheight(int *r,int *sa,int n)
{
    int i,j,k = 0;
    for(i = 1; i < n; i ++) rak[sa[i]] = i;
    for(i = 0; i < n - 1; height[rak[i ++]] = k)
        for(k ? k -- : 0, j = sa[rak[i] - 1]; r[i + k] == r[j + k]; k ++);
}

        
int r[N];
char s[N],str[N];
int sa[N];

struct point
{
    int x,y,val,rank;
    point() {}
    point(int x,int y,int val,int rank):x(x),y(y),val(val),rank(rank) {}
    friend bool operator < (const point &p,const point &q) {
        if(p.val != q.val) return p.val > q.val;
        return p.rank > q.rank;
    }
}pt[N];

struct tree
{
    int lt,rt,cover;
}a[N * 4];

void init(int lt,int rt,int step)
{
    a[step].lt = lt;
    a[step].rt = rt;
    a[step].cover = -1;
    if(lt == rt) return;
    int mid = (lt + rt) >> 1;
    init(lt,mid,2 * step);
    init(mid + 1,rt,2 * step + 1);
}

void down(int step)
{
    a[2 * step].cover = a[step].cover;
    a[2 * step + 1].cover = a[step].cover;
    a[step].cover = -1;
}

void update(int lt,int rt,int step,int id)
{
    if(a[step].lt == lt && rt == a[step].rt) {
        a[step].cover = id;
        return;
    }
    if(a[step].cover != -1) down(step);
    if(rt <= a[2 * step].rt) update(lt,rt,2 * step,id);
    else if(lt > a[2 * step].rt) update(lt,rt,2 * step + 1,id);
    else {
        update(lt,a[2 * step].rt,2 * step,id);
        update(a[2 * step + 1].lt,rt,2 * step + 1,id);
    }
}

int query(int pos,int step)
{
    if(a[step].lt == a[step].rt) return a[step].cover;
    if(a[step].cover != -1) down(step);
    if(pos <= a[2 * step].rt) return query(pos,2 * step);
    else return query(pos,2 * step + 1);
}

set<int> st;
int pos[N],epos[N];

int main()
{
    scanf("%s",s);
    int n = strlen(s);
    memset(r,0,sizeof(r));
    memset(sa,0,sizeof(sa));
    memset(height,0,sizeof(height));
    for(int i = 0; i < n; i ++) r[i] = s[i];
    da(r,sa,n + 1,256);
    calheight(r,sa,n + 1);
    int cnt = 0;
    memset(epos,-1,sizeof(epos));
    for(int i = 0; i < n; i ++) {
        int x = rak[i];
        int len = max(height[x],height[x + 1]);
        if(len >= n - i) continue;
        pt[++ cnt] = point(i,i + len,len + 1,rak[i]);
        pos[i] = len + 1;
    }
    sort(pt + 1,pt + cnt + 1);
    init(0,n - 1,1);
    for(int i = 1; i <= cnt; i ++) {
        update(pt[i].x,pt[i].y,1,i);
        st.insert(pt[i].x);
        epos[pt[i].y] = max(epos[pt[i].y],pt[i].x);
    }
    int pre = -1;
    for(int i = 0; i < n; i ++) {
        int x = query(i,1),y;
        if(x != -1) {
            int ansx = -1,anslen = 0x7fffffff;
            if(pre != -1) ansx = pre,anslen = i - pre + 1;
            if(pt[x].val < anslen) anslen = pt[x].val,ansx = pt[x].x;
            else if(pt[x].val == anslen && rak[pt[x].x] < rak[ansx]) anslen = pt[x].val,ansx = pt[x].x;
            set<int>::iterator it = st.upper_bound(i);
            if(it != st.end()) {
                int y = *it;
                if(y - i + pos[y] < anslen) anslen = y - i + pos[y],ansx = i;
                else if(y - i + pos[y] == anslen && rak[i] < rak[ansx]) anslen = y - i + pos[y],ansx = i;
            }
            printf("%d %d\n",ansx + 1,anslen);
        }
        else {
            set<int>::iterator it = st.lower_bound(i);
            if(it == st.end()) {
                it --;
                printf("%d %d\n",(*it) + 1,i - (*it) + 1);
            }
            else {
                y = *it;
                x = *(--it);
                if(i - x + 1 < y - i + pos[y]) printf("%d %d\n",x + 1,i - x + 1);
                else if(i - x + 1 > y - i + pos[y]) printf("%d %d\n",i + 1,y - i + pos[y]);
                else {
                    if(rak[x] < rak[i]) printf("%d %d\n",x + 1,i - x + 1);
                    else printf("%d %d\n",i + 1,y - i + pos[y]);
                }
            }
        }
        if(epos[i] != -1) pre = epos[i];
    }
    return 0; 
}
