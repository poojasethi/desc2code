#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <limits>
#include <string>
#include <cassert>

using namespace std;
typedef long long LL;
typedef pair<int,int> pii;
typedef pair<int,pii> piii;

#define forup(i,a,b) for(int i=a; i<b; ++i)
#define fordn(i,a,b) for(int i=a; i>b; --i)
#define rep(i,a) for(int i=0; i<a; ++i)

#define dforup(i,a,b) for(i=a; i<b; ++i)
#define dfordn(i,a,b) for(i=a; i>b; --i)
#define drep(i,a) for(i=0; i<a; ++i)

#define slenn(s,n) for(n=0; s[n]!=13 and s[n]!=0; ++n);s[n]=0

#define gi(x) scanf("%d",&x)
#define gl(x) cin>>x
#define gd(x) scanf("%lf",&x)
#define gs(x) scanf("%s",x)

#define pis(x) printf("%d ",x)
#define pin(x) printf("%d\n",x)
#define pls(x) cout<<x<<" "
#define pln(x) cout<<x<<"\n"
#define pds(x) printf("%.12f ",x)
#define pdn(x) printf("%.12f\n",x)
#define pnl() printf("\n")

#define fs first
#define sc second

#define pb push_back

const int inv=1000000000;
const int minv=-inv;

const int max_c=100010;
const int max_clog=17;

// Suffix Arrays

int slog,spow;
int p[max_clog+1][max_c+1];

struct Lel
{
	int pr;
	int se;
	int ix;
};
struct less_Lel : public binary_function<Lel,Lel,bool>
{
	bool operator () (const Lel &a, const Lel &b) { return ( (a.pr<b.pr) or ( (a.pr==b.pr) and (a.se<b.se) ) ); }
};
Lel L[max_c];

int findlcp(int x, int y, int k, int p2k, int slen)
{
	//cout<<"findlcp: "<<x<<" "<<y<<" "<<k<<" "<<p2k<<"\n";
	if(k==-1)
		return 0;
	if(x>=slen or y>=slen)
		return 0;
	 
	if(p[k][x]==p[k][y])
		return p2k+findlcp(x+p2k, y+p2k, k-1, p2k/2, slen);
	else
		return findlcp(x,y,k-1,p2k/2,slen);
}

void f(char s[], int slen)
{
	slog=0; spow=1;
	while(spow<slen)
	{
		spow*=2;
		slog+=1;
	}
	
	for(int i=0; i<slen; ++i)
	{
		L[i].pr=s[i]-'a';
		L[i].se=0;
		L[i].ix=i;
	}
	sort(L, L+slen, less_Lel());
	
	int ct=0;
	p[0][L[0].ix]=0;
	for(int i=1; i<slen; ++i)
	{
		if( not (L[i].pr==L[i-1].pr and L[i].se==L[i-1].se) )
		++ct;
		p[0][L[i].ix]=ct;
	}
	
	int cpow=1;
	for(int k=1; k<=slog; ++k)
	{
		for(int i=0; i<slen; ++i)
		{
			L[i].pr=p[k-1][i];
			if(i+cpow<slen)
				L[i].se=p[k-1][i+cpow];
			else
				L[i].se=-1;
			L[i].ix=i;
		}
		sort(L, L+slen, less_Lel());
		
		ct=0;
		p[k][L[0].ix]=0;
		for(int i=1; i<slen; ++i)
		{
			if( not (L[i].pr==L[i-1].pr and L[i].se==L[i-1].se) )
				++ct;
			p[k][L[i].ix]=ct;
		}
		
		cpow*=2;
	}
	
	/*LL ret = (LL(slen))*(LL(slen+1))/2ll;
	forup(i,1,slen)
		ret -= (LL(findlcp(L[i-1].ix,L[i].ix,slog,spow,slen)));
	return ret;*/
}

// End of Codechunk

const int max_n=100010;

// BIT struct

struct BIT
{
	int bn; //bn>0
	vector<int> bA;
	
	BIT(){ bn=0; }
	BIT(int bn_){ bn=bn_; bA.resize(bn+1); fill(bA.begin(),bA.end(),0); }
	
	int prefix(int bposn)
	{
		if(bposn<=0) return 0;
		if(bposn>bn) bposn=bn;

		/*forup(i,1,bn+1)
			cout<<"@ "<<bA[i]<<" ";
		pnl();*/
		
		int ret=0;
		for(int i=bposn; i>0; i-=((i)&(-i)))
			ret=max(ret,bA[i]);
		return ret;
	}
	
	void update(int bposn, int bincr)
	{
		if(bposn<=0) return;
		if(bposn>bn) return;
		
		for(int i=bposn; i<=bn; i+=((i)&(-i)))
			bA[i]=max(bA[i],bincr);
	}
};
BIT bit1,bit2;

// End of BIT struct

// Segment Tree Codechunk

int slr[4*max_n+10];
int srr[4*max_n+10];
piii sval[4*max_n+10];

struct ST
{
	int sn; //sn>0
	
	ST(){ sn=0; }
	ST(int sn_){ sn=sn_; init(0,0,sn); }
	
	void init(int ix, int l, int r)
	{
		slr[ix]=l;
		srr[ix]=r;
		sval[ix]=piii(inv,pii(-1,-1));
		if(l+1<r)
		{
			int mid=(l+r)/2;
			init(2*ix+1,l,mid);
			init(2*ix+2,mid,r);
		}
	}
	
	void iupdate(int ix, int l, int r, piii val)
	{
		int lc=2*ix+1, rc=2*ix+2;
		
		if(l==slr[ix] and r==srr[ix])
			sval[ix]=min(sval[ix],val);
		else if(r<=srr[lc])
			iupdate(lc,l,r,val);
		else if(l>=slr[rc])
			iupdate(rc,l,r,val);
		else
		{
			iupdate(lc,l,srr[lc],val);
			iupdate(rc,slr[rc],r,val);
		}
	}
	
	void update(int l, int r, piii val)
	{
		iupdate(0,l,r+1,val);
	}

	piii pquery(int ix, int pos)
	{
		//cerr<<"B";
		int lc=2*ix+1, rc=2*ix+2;
		if(slr[ix]+1==srr[ix]) return sval[ix];

		if(pos<srr[lc]) return min(sval[ix],pquery(lc,pos));
		else return min(sval[ix],pquery(rc,pos));
	}
	
	piii query(int pos)
	{
		return pquery(0,pos);
	}
};
ST st;

// End of Codechunk

int n;
char s[max_n];
int q[max_n];

int main()
{
	gs(s); slenn(s,n);

	f(s,n);
	rep(i,n)
	{
		int lcp=0;
		if(i-1>=0) lcp=max(lcp,findlcp(L[i-1].ix,L[i].ix,slog,spow,n));
		if(i+1<n) lcp=max(lcp,findlcp(L[i+1].ix,L[i].ix,slog,spow,n));

		q[L[i].ix]=lcp;
	}

	st=ST(n);
	bit1=BIT(n);
	bit2=BIT(n);

	/*for(int i=1; i<=12; ++i)
		cout<<"** "<<bit1.prefix(i)<<" "<<bit2.prefix(i)<<"\n";*/

	rep(i,n)
	{
		if(i+q[i]==n) continue;

		//cout<<i<<": "<<q[i]<<" :: "<<i+q[i]+2<<" "<<i+1<<"\n";

		st.update(i,i+q[i],piii(q[i]+1,pii(p[slog][i],i)));
		if(i+q[i]+1<n) bit1.update(i+q[i]+2,i+1);
		if(i-1>=0) bit2.update(n-(i-1),n-(i+q[i]));
	}
	//cout<<"%% "<<bit1.prefix(4)<<" "<<bit1.prefix(5)<<"\n";

	/*for(int i=1; i<=12; ++i)
		cout<<"** "<<bit1.prefix(i)<<" "<<bit2.prefix(i)<<"\n";*/

	rep(i,n)
	{
		int res=n,resix=0;

		int cdt[3],cdtix[3];
		piii tQ=st.query(i); cdt[0]=tQ.fs; cdtix[0]=tQ.sc.sc;
		int tq=bit1.prefix(i+1); if(tq!=0) { cdt[1]=abs((i+1)-tq)+1; cdtix[1]=tq-1; } else { cdt[1]=inv; cdtix[1]=-1; }
		tq=bit2.prefix(n-i); if(tq!=0) { cdt[2]=abs((n-i)-tq)+1; cdtix[2]=i; } else { cdt[2]=inv; cdtix[2]=-1; }

		//cout<<i<<" "<<cdt[0]<<" "<<cdt[1]<<" "<<cdt[2]<<"\n";

		rep(j,3)
		{
			if(res>cdt[j] or (res==cdt[j] and p[slog][cdtix[j]]<p[slog][resix]))
			{
				res=cdt[j];
				resix=cdtix[j];
			}
		}

		pis(resix+1); pin(res);
	}
	
	return 0;
}