// O(nlog2n) time to sort all suffixes
// O(n) space

#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

#define MAXN 100007
#define MAXLG 18

char A[MAXN];
struct segment{
	int a,b;
	int c,d;
	int cf,df;
} ar[300000];
int min(int p,int q){
	if(p>q) return q;
	else return p;
}
struct entry
{
    int nr[2];
    int p;
} L[MAXN];

int P[MAXLG][MAXN];
int N,i;
int stp, cnt;
int FLCP(int x,int y){
    int answer = 0;
		int z=1;
		for(int j=1;j<=stp;j++)	z=z*2;
    for(int k=stp-1;k>=0;k--){
    		z=z/2;
    		if(x>=N || y>=N)	break;
        if(P[k][x] == P[k][y]){
            // sort-index is same if the first k characters are same
            
            
            answer += z;
            // now we wish to find the characters that are same in the remaining strings
				x+=z;
				y+=z;
			}
		}
		return answer;
}
void maketree(int root){
	if(ar[root].a==ar[root].b) return;
	ar[2*root].a=ar[root].a;
	ar[2*root].c=ar[2*root].d=100000000;
	ar[2*root].b=(ar[root].a+ar[root].b)/2;
	maketree(2*root);
	ar[2*root+1].b=ar[root].b;
	ar[2*root+1].c=ar[2*root+1].d=100000000;
	ar[2*root+1].a=(ar[root].a+ar[root].b)/2+1;
	maketree(2*root+1);
}
int chanstr(int p,int q,int l){
	int k=0;
	for(k=0;k<=l;++k){
		if(A[p+k]<A[q+k])	return p;
		else if(A[p+k]>A[q+k])	return q;
	}
	return p;
}
void update1(int i,int j,int val,int q,int r){
	//printf("%d %d %d %d %d %d %d %d\n",i,j,val,q,r,ar[r].c,ar[r].a,ar[r].b);	
				if(j<i)	return ;
	if(j<ar[r].a || i>ar[r].b)	return ;
	if(i<=ar[r].a &&j>=ar[r].b){
		if(ar[r].c>val){ ar[r].c=val;	ar[r].cf=q;}
		else if(ar[r].c==val){	ar[r].cf= chanstr(ar[r].cf,q,val);}
		
		return;
	}

	update1(i,j,val,q,2*r);	
	update1(i,j,val,q,2*r+1);
}
void update2(int i,int j,int val,int q,int r){
		
				if(j<i)	return ;
	if(j<ar[r].a || i>ar[r].b)	return ;
	if(i<=ar[r].a &&j>=ar[r].b){
		int v=val-i+ar[r].a;
		if(ar[r].d>v){ ar[r].d=v;	ar[r].df=q;}
		else if(ar[r].d==v){	ar[r].df= chanstr(ar[r].df,q,v);}
		return;
	}
	update2(i,j,val,q,2*r);	
	update2(i,j,val,q,2*r+1);
}

void query(int i){
 int r=1,ans=10000000,pq=0;
  while(1){
  		//printf("%d %d %d %d %d\n",ar[r].c,ar[r].d,ar[r].a,ar[r].b,i);
  		//printf("%d %d %d %d %d %d %d %d\n",i,pq+1,ans,r,ar[r].a,ar[r].b,ar[r].c,ar[r].d);
  		if(ans>ar[r].d+i-ar[r].a) {ans=ar[r].d+i-ar[r].a;pq=ar[r].df;}
  		else if(ans==ar[r].d+i-ar[r].a){pq=chanstr(ar[r].df,pq,ans);}
  		if(ans>ar[r].c) {ans=ar[r].c;pq=ar[r].cf;}
  		else if(ans==ar[r].c){pq=chanstr(ar[r].cf,pq,ans);}
  		if(ar[r].a==ar[r].b)	break;
  		if(i<=(ar[r].a+ar[r].b)/2) r=2*r; else r=2*r+1;
  	}
  	if(ans>N) {	ans=N; pq=0;}
  	 printf("%d %d\n",pq+1,ans);
  	
}	
	
int cmp(struct entry a, struct entry b)
{
    return a.nr[0]==b.nr[0] ?(a.nr[1]<b.nr[1] ?1: 0): (a.nr[0]<b.nr[0] ?1: 0);
}

int main()
{
    scanf("%s",A);
    for(N=strlen(A), i = 0; i < N; i++)
        P[0][i] = A[i] - 'a';
    ar[1].a=0;ar[1].b=N-1;
    ar[1].c=ar[1].d=100000000;
    maketree(1);  
    if(N==1){		printf("1 1\n"); return 0;}  

    for(stp=1, cnt = 1; cnt < N; stp++, cnt *= 2)
    {
        for(i=0; i < N; i++)
        {
            L[i].nr[0]=P[stp- 1][i];
            L[i].nr[1]=i +cnt <N? P[stp -1][i+ cnt]:-1;
            L[i].p= i;
        }
        sort(L, L+N, cmp);
        for(i=0; i < N; i++)
            P[stp][L[i].p] =i> 0 && L[i].nr[0]==L[i-1].nr[0] && L[i].nr[1] == L[i- 1].nr[1] ? P[stp][L[i-1].p] : i;
    }
    int l,q,a=0,s;
    l=FLCP(L[0].p,L[1].p);
    if(L[0].p+l<N){
    	update1(L[0].p,L[0].p+l,l+1,L[0].p,1);
    	
    	update2(L[0].p+l+1,N-1,l+2,L[0].p,1);
    
    }
    	//printf("%d %d %d %d %d\n",l,ar[3].a,ar[3].b,ar[3].c,ar[3].d);
    q=l;
    for(a=1;a<N-1;++a){
    	
    	l=FLCP(L[a].p,L[a+1].p);
    	s=q;
    	if(l>q)	s=l;
    	//printf("%d %d %d %d\n",a,L[a].p,l,q);
    	if(L[a].p+s<N){
    	update1(L[a].p,L[a].p+s,s+1,L[a].p,1);
    	
    	update2(L[a].p+s+1,N-1,s+2,L[a].p,1);
    		 //printf("%d %d %d %d %d %d\n",L[a].p,L[a].p+s,ar[3].a,ar[3].b,ar[3].c,ar[3].d);
   	 }
   	
   	 
    	q=l;
    }
    if(L[a].p+l<N){
    	update1(L[a].p,L[a].p+l,l+1,L[a].p,1);
    	
    	update2(L[a].p+l+1,N-1,l+2,L[a].p,1);
    	//printf("%d %d %d %d %d\n",l,ar[3].a,ar[3].b,ar[3].c,ar[3].d);
    }
    
    for(a=0;a<N;++a)	query(a);	
    
    
    return 0;
}
