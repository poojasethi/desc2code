// Suffix Automata
#include<stdio.h>
#include<iostream>
#include<string.h>
#include<stdlib.h>
#include<math.h>
#include<algorithm>
#include<set>
#include<map>
#include<utility>
#include<vector>
#include<string>
#include<stack>
#include<queue>
using namespace std;               //REMEMBER TO TAKE DOUBLE SIZED ARRAY
#define MAXLEN 100006
#define MAXL 30
int n,stp,mv;
int sum[MAXLEN],cnt[MAXLEN],rrank[MAXL][MAXLEN], suf[MAXLEN], suffix[MAXLEN], tmp[MAXLEN],lcps[MAXLEN];
struct State
{
    int len, link;
    map < char , int > nxtc;
} SA[2*MAXLEN];
int FirstPos[2*MAXLEN], DistSub[2*MAXLEN], NumOcc[2*MAXLEN];
bool vis[2*MAXLEN];
char str[MAXLEN];
vector < pair < int , int > > lenState;
int LCP(int u,int v)
{
    int ret=0,i;
    for(i = stp; i >= 0 && u<n && v<n; i--)
    {
        if(rrank[i][u]==rrank[i][v])
        {
            ret += 1<<i;
            u += 1<<i;
            v += 1<<i;
        }
    }
    return ret;
}
bool equal(int u,int v)
{
    if(!stp) return str[u]==str[v];
    if(rrank[stp-1][u]!=rrank[stp-1][v]) return false;
    int a = u + mv < n ? rrank[stp-1][u+mv] : -1;
    int b = v + mv < n ? rrank[stp-1][v+mv] : -1;
    return a == b ;
}
void update()
{
    int i;
    for(i=0; i<n; ++i) sum[i] = 0;
    int rnk = 0;
    for(i=0; i<n; i++)
    {
        suffix[i] = tmp[i];
        if(i && !equal(suffix[i],suffix[i-1]))
        {
            rrank[stp][suffix[i]]= ++rnk;
            sum[rnk+1] = sum[rnk];
        }
        else rrank[stp][suffix[i]] = rnk;
        ++sum[rnk+1];
    }
}
void Sort()
{
    int i;
    for(i=0; i<n; ++i) cnt[i] = 0;
    memset(tmp, -1, sizeof tmp);
    for(i=0; i<mv; ++i)
    {
        int idx = rrank[stp-1][n-i-1];
        int x = sum[idx];
        tmp[x+cnt[idx]] = n-i-1;
        ++cnt[idx];
    }
    for(i=0; i<n; ++i)
    {
        int idx = suffix[i] - mv;
        if(idx<0) continue;
        idx = rrank[stp-1][idx];
        int x = sum[idx];
        tmp[x+cnt[idx]] = suffix[i] - mv;
        ++cnt[idx];
    }
    update();
}
bool cmp(const int &a,const int &b)
{
    return str[a]<str[b];
}
void buildSuffixArray(int nn)
{
    n = nn;
    int i;
    for(i=0; i<n; i++) tmp[i] = i;
    sort(tmp,tmp+n,cmp);
    stp = 0;
    update();
    ++stp;
    for(mv=1; mv<n; mv<<=1)
    {
        Sort();
        stp++;
    }
    stp--;
}
bool cmp2(int x, int y)
{
    int l = LCP(x,y);
    return (str[x+l] < str[y+l]);
}
int revsuf[MAXLEN];
pair < int , int > TREE[4*MAXLEN];
bool lazy[4*MAXLEN];
void initialize(int node, int left, int right)
{
    TREE[node] = make_pair(100000000,-1);
    lazy[node] = false;
    if (left == right) return;
    int mid = (left + right) / 2;
    initialize(2*node, left, mid);
    initialize(2*node+1, mid+1, right);
}
void updatelazy(int node, int left, int right)
{
    if (left == right)
    {
        lazy[node] = false;
        return;
    }
    if (TREE[2*node] > TREE[node])
    {
        lazy[2*node] = true;
        TREE[2*node] = TREE[node];
    }
    if (TREE[2*node+1] > TREE[node])
    {
        lazy[2*node+1] = true;
        TREE[2*node+1] = TREE[node];
    }
    lazy[node] = false;
}
void update(int node, int left, int right, int start, int end, pair < int , int > val)
{
    if (lazy[node]) updatelazy(node,left,right);
    if (right < start || end < left) return;
    if (start <= left && right <= end)
    {
        if (TREE[node] > val)
        {
            TREE[node] = val;
            lazy[node] = true;
        }
        return;
    }
    int mid = (left + right) / 2;
    update(2*node, left, mid, start, end, val);
    update(2*node+1, mid+1, right, start, end, val);
}
pair < int , int > query(int node, int left, int right, int idx)
{
    if (lazy[node]) updatelazy(node,left,right);
    if (left == right) return TREE[node];
    int mid = (left + right) / 2;
    if (idx <= mid) return query(2*node, left, mid, idx);
    return query(2*node+1, mid+1, right, idx);
}
bool cmp3(int a, int b)
{
    return FirstPos[a] < FirstPos[b];
}
class SuffixAutomata
{
    int sz, last, lm;
    int fnl;
    void init(int idx)
    {
        SA[idx].len = 0, SA[idx].link = -1;
        FirstPos[idx] = -1;
        SA[idx].nxtc.clear();
    }
public:
    SuffixAutomata()
    {
        sz = last = 0;
        init(0);
        lenState.clear();
        lm = 0;
        ++sz;
    }
    int size() {return sz;}
    void extend(char ch, int idx = -1)
    {
        int p, q, clone, cur = sz++;
        lm = fnl = cur;
        init(cur);
        SA[cur].len = SA[last].len + 1;
        FirstPos[cur] = idx;
        lenState.push_back(make_pair(SA[cur].len, cur));
        for (p = last; p != -1 && SA[p].nxtc.count(ch) == 0; p = SA[p].link) SA[p].nxtc[ch] = cur;
        if (p == -1) SA[cur].link = 0;
        else
        {
            q = SA[p].nxtc[ch];
            if (SA[p].len + 1 == SA[q].len) SA[cur].link = q;
            else
            {
                clone = sz++;
                init(clone);
                SA[clone] = SA[q];
                SA[clone].len = SA[p].len + 1;
                for (; p != -1 && SA[p].nxtc[ch] == q; p = SA[p].link) SA[p].nxtc[ch] = clone;
                SA[cur].link = SA[q].link = clone;
                FirstPos[clone] = FirstPos[q];
                lenState.push_back(make_pair(SA[clone].len, clone));
            }
        }
        last = cur;
    }
    void numOcc()
    {
        int i,p,q;
        map < char, int > :: iterator im;
        memset(NumOcc, 0, sizeof(NumOcc));
        NumOcc[lm] = 1;
        sort(lenState.begin(), lenState.end());
        for (i=lenState.size()-1; i>=0; --i)
        {
            p = lenState[i].second;
            if (p < 1) continue;
            map < char , int > &M = SA[p].nxtc;
            for (im = M.begin(); im != M.end(); ++im)
            {
                q = im -> second;
                NumOcc[p] += NumOcc[q];
            }
        }
    }
    void calc(int N)
    {
        int i,j,p,q,l,st,nd;
        pair < int , int > now;
        initialize(1,1,N);
        vector < int > V;
        V.clear();
        for (q=1; q<lm; ++q)
        {
            if (NumOcc[q] != 1) continue;
            V.push_back(q);
        }
        sort (V.begin(), V.end(), cmp3);
        for (j=0; j<V.size(); ++j)
        {
            q = V[j];
            p = SA[q].link;
            nd = FirstPos[q];
            l = SA[q].len;
            st = nd - SA[p].len;
            now.first = SA[p].len+1, now.second = suf[st];
            if (SA[p].len) update(1,1,N,nd-SA[p].len+1 +1,nd +1,now);
            for (i=SA[p].len+1; i<=l; ++i)
            {
                st = nd - i + 1;
                now.first = i, now.second = suf[st];
                if (now < query(1,1,N,st +1)) update(1,1,N,st +1, st +1, now);
                else break;
            }
        }
    }
};
void print(int N)
{
    int i;
    pair < int , int > now;
    for (i=0; i<N; ++i)
    {
        now = query(1,1,N,i +1);
        printf("%d %d\n", revsuf[now.second] +1, now.first);
    }
}
int main()
{
    int N,i;
    while(scanf("%s", str) != EOF)
    {
        SuffixAutomata temp;
        for (i=0; str[i]; ++i) temp.extend(str[i], i);
        temp.extend('$');
        temp.numOcc();
        N = strlen(str);
        //for (i=N-1; i>=0; --i) suf[i] = i;
        buildSuffixArray(N);
        for (i=N-1; i>=0; --i) suf[i] = suffix[i];
        //sort(suf, suf+N, cmp2);
        for (i=N-1; i>=0; --i) revsuf[suf[i]] = i;
        for (i=0; i<N; ++i) swap(suf[i], revsuf[i]);
        temp.calc(N);
        print(N);
    }
    return 0;
}
