#include <cstdio>
#include <ctime>
#include <algorithm>
#include <iostream>
#include <cstring>

using namespace std;

#define maxn 100011
#define base 31
#define mod 1000000007
#define ull unsigned long long

string s;
int rang[20][maxn], sa[maxn], n, pos[maxn], r[maxn], sf[maxn], cnt[maxn], p[maxn];
//ull power[maxn], h[maxn];
pair <int, int> t[4 * maxn], bestL[maxn], bestR[maxn], lf[maxn], rg[maxn], ans[maxn], INF;

bool cmp2(int a, int b)
{
	return s[a] < s[b];
}

/*ull get(int l, int r)
{
	if (!l)
		return h[r];
	return h[r] - (h[l - 1] * power[r - l + 1]);
}*/

int ls(int x, int y, int x2, int y2)
{
	int l = min(y2 - x2 + 1, y - x + 1), k = p[l];

	pair <int, int> a = make_pair(rang[k][x], rang[k][x + l - (1 << k)]);
	pair <int, int> b = make_pair(rang[k][x2], rang[k][x2 + l - (1 << k)]);

	if (a == b && y - x + 1 <= y2 - x2 + 1)
		return 2;

	return a <= b ? 1 : 0;
}

bool cmp3(pair <int, int> a, pair <int, int> b)
{
	if (a.second - a.first + 1 < b.second - b.first + 1)
		return 1;

	if (a.second - a.first + 1 > b.second - b.first + 1)
		return 0;

	return ls(a.first, a.second, b.first, b.second) == 1;
}

bool check(int x, int y)
{
	if (x > y)
		return 0;

	bool ok = 1;
	if (pos[x] > 1 && (n - sa[pos[x] - 1]) >= y - x + 1)
		ok &= ls(x, y, sa[pos[x] - 1], n - 1) != 2;
	if (pos[x] < n - 1 && (n - sa[pos[x] + 1]) >= y - x + 1)
		ok &= ls(x, y, sa[pos[x] + 1], n - 1) != 2;

	return ok;
}

void update(int tl, int tr, int v, int pos, pair <int, int> val)
{
	if (tl == tr)
	{
		if (cmp3(val, t[v]))
			t[v] = val;
	}
	else
	{
		int td = (tl + tr) >> 1;

		if (pos <= td)
			update(tl, td, v + v, pos, val);
		else
			update(td + 1, tr, v + v + 1, pos, val);

		if (cmp3(t[v + v], t[v + v + 1]))
			t[v] = t[v + v];
		else
			t[v] = t[v + v + 1];
	}
}

pair <int, int> get(int tl, int tr, int v, int l, int r)
{
	if (l > r)
		return INF;

	if (tl == l && tr == r)
		return t[v];

	int td = (tl + tr) >> 1;

	pair <int, int> lf = get(tl, td, v + v, l, min(r, td));
	pair <int, int> rg = get(td + 1, tr, v + v + 1, max(l, td + 1), r);

	if (cmp3(lf, rg))
		return lf;
	return rg;			
}

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);

//	freopen("in", "r", stdin);
//	freopen("out", "w", stdout);
	
	cin >> s;

	s += char('a' - 1);

	n = s.length();

	INF = make_pair(0, n + 10);

	p[0] = 0;
	for (int i = 1; i <= n; ++i)
	{
		p[i] = p[i - 1];
		while ((1 << (p[i] + 1)) <= i) ++p[i];
	}

	for (int i = 0; i < n; ++i)
		++cnt[s[i]];

	for (int i = 1; i < 256; ++i)
		cnt[i] += cnt[i - 1];

	for (int i = 0; i < n; ++i)
		sa[--cnt[s[i]]] = i;
	
	rang[0][sa[0]] = 0;

	int classes = 1;
	for (int i = 1; i < n; ++i)
	{
		if (s[sa[i]] != s[sa[i - 1]])
			++classes;
		rang[0][sa[i]] = classes - 1;
	}

	for (int h = 0; (1 << h) < n; ++h)
	{
		for (int i = 0; i < n; ++i)
		{
			sf[i] = sa[i] - (1 << h);
			if (sf[i] < 0)	sf[i] += n;
		}			

		for (int i = 0; i < n; ++i)
			cnt[i] = 0;

		for (int i = 0; i < n; ++i)
			++cnt[rang[h][sa[i]]];

		for (int i = 1; i < classes; ++i)
			cnt[i] += cnt[i - 1];

		for (int i = n - 1; i >= 0; --i)
			sa[--cnt[rang[h][sf[i]]]] = sf[i];

		rang[h + 1][sa[0]] = 0;
		classes = 1;
		
		for (int i = 1; i < n; ++i)
		{
			int mid1 = (sa[i] + (1 << h)) % n, mid2 = (sa[i - 1] + (1 << h)) % n;

			if (rang[h][sa[i]] != rang[h][sa[i - 1]] || rang[h][mid1] != rang[h][mid2])
				classes++;

			rang[h + 1][sa[i]] = classes - 1;
		}
	}

	for (int i = 0; i < n; ++i)
	{
		pos[sa[i]] = i;
		bestL[i].first = bestR[i].first = 0;
		bestL[i].second = bestR[i].second = n - 1;
	}

	for (int i = 0; i < n - 1; ++i)
	{
		int l = -1, r = n - i;

		while (r - l > 1)
		{
			int m = (l + r) >> 1;

			if (!check(i, i + m - 1))
				l = m;
			else
				r = m;
		}

		if (r != n - i && r > 0)
			bestL[i] = make_pair(i, i + r - 1);
	}

	for (int i = 0; i < n - 1; ++i)
	{
		int l = -1, r = i + 1;
		
		while (r - l > 1)
		{
			int m = (l + r) >> 1;

			if (!check(i - m + 1, i))
				l = m;
			else
				r = m;
		}

		if (r != i + 1 && r > 0)
			bestR[i] = make_pair(i - r + 1, i);
	}

	for (int i = 1; i <= 4 * n; ++i)
		t[i] = INF;

	for (int i = 0; i < n - 1; ++i)
	{
		update(1, n, 1, bestL[i].second + 1, bestL[i]);
		lf[i] = get(1, n, 1, i + 1, n);
	}

	for (int i = 1; i <= 4 * n; ++i)
		t[i] = INF;

	for (int i = n - 2; i >= 0; --i)
	{
		update(1, n, 1, bestR[i].first + 1, bestR[i]);
		rg[i] = get(1, n, 1, 2, i + 1);
	}

	for (int i = 0; i < n; ++i)
		if (cmp3(lf[i], rg[i]))
			ans[i] = lf[i];
		else
			ans[i] = rg[i];

	//cerr << clock();

	for (int i = 0; i < n - 1; ++i)
		printf("%d %d\n", ans[i].first + 1, ans[i].second - ans[i].first + 1);
}