//Coder: Balajiganapathi
//#define TRACE
#define DEBUG

#include <algorithm>
#include <bitset>
#include <deque>
#include <cassert>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <functional>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <utility>
#include <vector>

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pi;
typedef vector<string> vs;

// Basic macros
#define st          first
#define se          second
#define all(x)      (x).begin(), (x).end()
#define ini(a, v)   memset(a, v, sizeof(a))
#define re(i,s,n)  	for(int i=s;i<(n);++i)
#define rep(i,s,n)  for(int i=s;i<=(n);++i)
#define fr(i,n)     re(i,0,n)
#define repv(i,f,t) for(int i = f; i >= t; --i)
#define rev(i,f,t)  repv(i,f - 1,t)
#define frv(i,n)    rev(i,n,0)
#define pu          push_back
#define mp          make_pair
#define sz(x)       (int)(x.size())

const int oo = 2000000009;
const double eps = 1e-9;

#ifdef TRACE
    #define trace1(x)                cerr << #x << ": " << x << endl;
    #define trace2(x, y)             cerr << #x << ": " << x << " | " << #y << ": " << y << endl;
    #define trace3(x, y, z)          cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl;
    #define trace4(a, b, c, d)       cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << endl;
    #define trace5(a, b, c, d, e)    cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << endl;
    #define trace6(a, b, c, d, e, f) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << " | " << #f << ": " << f << endl;

#else

    #define trace1(x)
    #define trace2(x, y)
    #define trace3(x, y, z)
    #define trace4(a, b, c, d)
    #define trace5(a, b, c, d, e)
    #define trace6(a, b, c, d, e, f)

#endif

const int mx = 100005, log_mx = 18;
char str[mx];
int sa[mx], inv_sa[mx], sa_rank[mx][log_mx], lcp[mx];
int log_n, n;

class sa_entry {
    public:
    int rank[2], pos;

    bool operator <(const sa_entry &s) const {
        if(rank[0] == s.rank[0]) return rank[1] < s.rank[1];
        else return rank[0] < s.rank[0];
    }

    bool operator == (const sa_entry &s) const {
        return rank[0] == s.rank[0] && rank[1] == s.rank[1];
    }
} sa_nxt[mx];

int get_lcp(int x, int y) {
    int _x = x, _y = y;
    int ret = 0;

    for(int i = log_n - 1; i >= 0 && x < n && y < n; --i) {
        if(sa_rank[x][i] == sa_rank[y][i]) {
            ret += (1 << i);
            x += (1 << i);
            y += (1 << i);
        }
    }

    return ret;
}

void sa_build() {
    for(int i = 0; i < n; ++i) sa_rank[i][0] = str[i];

    if(n == 1) sa_rank[0][0] = 0;

    int siz = 1;
    for(log_n = 1; siz < n; ++log_n, siz *= 2) {
        for(int i = 0; i < n; ++i) {
            sa_nxt[i].rank[0] = sa_rank[i][log_n - 1];
            sa_nxt[i].rank[1] = i + siz < n? sa_rank[i + siz][log_n - 1]: -1;
            sa_nxt[i].pos = i;
        }

        sort(sa_nxt, sa_nxt + n);
        for(int i = 0; i < n; ++i) {
            sa_rank[sa_nxt[i].pos][log_n] = (i > 0 && sa_nxt[i] == sa_nxt[i - 1])? sa_rank[sa_nxt[i - 1].pos][log_n]: i;
        }
    }

    for(int i = 0; i < n; ++i) {
        sa[sa_rank[i][log_n - 1]] = i;
    }

    for(int i = 0; i < n; ++i) inv_sa[sa[i]] = i;

    lcp[0] = 0;
    for(int i = 1; i < n; ++i) lcp[i] = get_lcp(sa[i - 1], sa[i]);
}

int sa_compare(int i, int j, int len) {
    if(i == j) return 0;
    assert(i + len <= n && j + len <= n);

    for(int k = log_n - 1; k >= 0; --k) if((1 << k) <= len) {
        if(sa_rank[i][k] < sa_rank[j][k]) return -1;
        if(sa_rank[i][k] > sa_rank[j][k]) return 1;
        len -= (1 << k);
        i += (1 << k);
        j += (1 << k);
    }

    assert(len == 0);
    assert(0);
    return 0;
}

int seg[4 * mx];

void put(int i, int a, int b, int qa, int qb, int x) {
    if(qb < a || qa > b) return;
    if(qa <= a && b <= qb) {
        seg[i] = max(seg[i], x);
        return;
    }
    int m = (a + b) / 2;
    put(2 * i + 1, a, m, qa, qb, x);
    put(2 * i + 2, m + 1, b, qa, qb, x);
}

int get(int i, int a, int b, int q) {
    if(q < a || q > b) return -1;
    //trace5(i, a, b, q, seg[i]);
    if(a == b) return seg[i];
    int m = (a + b) / 2;
    return max(seg[i], max(get(2 * i + 1, a, m, q), get(2 * i + 2, m + 1, b, q)));
}

struct Substr {
    public:
    int start, len;
    Substr(int s, int l) {
        start = s; len = l;
    }

    bool operator <(const Substr &s) const {
        if(len != s.len) return len > s.len;
        return sa_compare(start, s.start, len) > 0;
    }
};

int p[mx], from[mx], length[mx], g[mx];

void brute() {
#ifdef TRACE
    string ss(str);
    vector<pair<string, int> > v;
    map<string, int> cnt;

    fr(i, n) re(j, i, n) cnt[ss.substr(i, j - i + 1)] += 1;

    fr(i, n) re(j, i, n) {
        string tmp = ss.substr(i, j - i + 1);
        if(cnt[tmp] == 1) v.pu(mp(tmp, i));
    }

    fr(i, n) {
        int x = -1;
        fr(j, sz(v)) if(v[j].se <= i && i < v[j].se + sz(v[j].st)) {
            if(x == -1 || sz(v[x].st) > sz(v[j].st) || (sz(v[x].st) == sz(v[j].st) && v[j].st < v[x].st)) x = j;
        }
        if(v[x].se != from[i] || sz(v[x].st) != length[i]) {
            trace3(i, from[i], length[i]);
            trace3(v[x].se, sz(v[x].st), v[x].st);
            assert(0);
        }
    }
#endif
}

int main() {
    scanf("%s", str);
    n = strlen(str);

    sa_build();
    fr(i, n) {
        int x = lcp[i];
        if(i < n - 1) x = max(x, lcp[i + 1]);
        if(sa[i] + x < n) p[sa[i]] = x + 1;
        else p[sa[i]] = -1;
    }
    fr(i, n) trace2(i, p[i]);

    priority_queue<Substr> q;
    fr(i, n) {
        if(p[i] != -1) q.push(Substr(i, p[i]));
        from[i] = -1; length[i] = n + 1;
        while(!q.empty()) {
            Substr cur = q.top();
            trace3(i, cur.start, cur.len);
            if(i >= cur.start + cur.len) {
                q.pop();
                continue;
            }
            from[i] = cur.start;
            length[i] = cur.len;
            break;
        }

    }
    ini(g, -1);
    fr(i, n) if(p[i] != -1) g[i + p[i]] = max(g[i + p[i]], i);

    int cur = -1;
    fr(i, n) {
        cur = max(cur, g[i]);
        if(cur != -1) {
            int len2 = i - cur + 1;
            if(len2 < length[i] || (len2 == length[i] && sa_compare(from[i], cur, length[i]) > 0)) {
                length[i] = len2;
                from[i] = cur;
            }
        }
    }

    fr(i, n) printf("%d %d\n", from[i] + 1, length[i]);
    brute();



	return 0;
}
