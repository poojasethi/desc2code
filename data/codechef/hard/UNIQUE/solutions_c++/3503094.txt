#include<stdio.h>
#include<iostream>
#include<string.h>
#include<stdlib.h>
#include<math.h>
#include<algorithm>
#include<set>
#include<map>
#include<utility>
#include<vector>
#include<string>
#include<stack>
#include<queue>
using namespace std;               //REMEMBER TO TAKE DOUBLE SIZED ARRAY
#define MAXLEN 100006
#define MAXL 30
int n,stp,mv;
int sum[MAXLEN],cnt[MAXLEN],rrank[MAXL][MAXLEN], suf[MAXLEN], suffix[MAXLEN], tmp[MAXLEN],lcps[MAXLEN];
char str[MAXLEN];
pair < int , int > TREE[4*MAXLEN];
bool lazy[4*MAXLEN];
int LCP(int u,int v)
{
    int ret=0,i;
    for(i = stp; i >= 0 && u<n && v<n; i--)
    {
        if(rrank[i][u]==rrank[i][v])
        {
            ret += 1<<i;
            u += 1<<i;
            v += 1<<i;
        }
    }
    return ret;
}
bool equal(int u,int v)
{
    if(!stp) return str[u]==str[v];
    if(rrank[stp-1][u]!=rrank[stp-1][v]) return false;
    int a = u + mv < n ? rrank[stp-1][u+mv] : -1;
    int b = v + mv < n ? rrank[stp-1][v+mv] : -1;
    return a == b ;
}
void update()
{
    int i;
    for(i=0; i<n; ++i) sum[i] = 0;
    int rnk = 0;
    for(i=0; i<n; i++)
    {
        suffix[i] = tmp[i];
        if(i && !equal(suffix[i],suffix[i-1]))
        {
            rrank[stp][suffix[i]]= ++rnk;
            sum[rnk+1] = sum[rnk];
        }
        else rrank[stp][suffix[i]] = rnk;
        ++sum[rnk+1];
    }
}
void Sort()
{
    int i;
    for(i=0; i<n; ++i) cnt[i] = 0;
    memset(tmp, -1, sizeof tmp);
    for(i=0; i<mv; ++i)
    {
        int idx = rrank[stp-1][n-i-1];
        int x = sum[idx];
        tmp[x+cnt[idx]] = n-i-1;
        ++cnt[idx];
    }
    for(i=0; i<n; ++i)
    {
        int idx = suffix[i] - mv;
        if(idx<0) continue;
        idx = rrank[stp-1][idx];
        int x = sum[idx];
        tmp[x+cnt[idx]] = suffix[i] - mv;
        ++cnt[idx];
    }
    update();
}
bool cmp(const int &a,const int &b)
{
    return str[a]<str[b];
}
void buildSuffixArray(int nn)
{
    n = nn;
    int i;
    for(i=0; i<n; i++) tmp[i] = i;
    sort(tmp,tmp+n,cmp);
    stp = 0;
    update();
    ++stp;
    for(mv=1; mv<n; mv<<=1)
    {
        Sort();
        stp++;
    }
    stp--;
}
bool cmp2(int x, int y)
{
    int l = LCP(x,y);
    return (str[x+l] < str[y+l]);
}
void initialize(int node, int left, int right)
{
    TREE[node] = make_pair(100000000,-1);
    lazy[node] = false;
    if (left == right) return;
    int mid = (left + right) / 2;
    initialize(2*node, left, mid);
    initialize(2*node+1, mid+1, right);
}
void updatelazy(int node, int left, int right)
{
    if (left == right)
    {
        lazy[node] = false;
        return;
    }
    if (TREE[2*node] > TREE[node])
    {
        lazy[2*node] = true;
        TREE[2*node] = TREE[node];
    }
    if (TREE[2*node+1] > TREE[node])
    {
        lazy[2*node+1] = true;
        TREE[2*node+1] = TREE[node];
    }
    lazy[node] = false;
}
void update(int node, int left, int right, int start, int end, pair < int , int > val)
{
	//printf("%d %d %d %d %d %d %d\n", node, left, right, start, end, val.first, val.second);
    if (lazy[node]) updatelazy(node,left,right);
    if (right < start || end < left) return;
    if (start <= left && right <= end)
    {
        if (TREE[node] > val)
        {
            TREE[node] = val;
            lazy[node] = true;
        }
        return;
    }
    int mid = (left + right) / 2;
    update(2*node, left, mid, start, end, val);
    update(2*node+1, mid+1, right, start, end, val);
}
pair < int , int > query(int node, int left, int right, int idx)
{
    if (lazy[node]) updatelazy(node,left,right);
    if (left == right) return TREE[node];
    int mid = (left + right) / 2;
    if (idx <= mid) return query(2*node, left, mid, idx);
    return query(2*node+1, mid+1, right, idx);
}
void print(int N)
{
    int i;
    pair < int , int > now;
    for (i=0; i<N; ++i)
    {
        now = query(1,1,N,i +1);
        printf("%d %d\n", suf[now.second]+1, now.first);
    }
}
int main()
{
	//freopen("data.txt", "r", stdin);
	//freopen("wa.txt", "w", stdout);
    int N,i;
    int s,pl,nl,l;
    pair < int , int > now;
    while(scanf("%s", str) != EOF)
    {
        N = strlen(str);
        for (i=N-1; i>=0; --i) suf[i] = i;
        buildSuffixArray(N);
        sort(suf, suf+N, cmp2);
        //for (i=0; i<N; ++i) printf("%d ", suf[i]); puts("");
        initialize(1,1,N);
        pl = 0;
		for (s=0; s+1<N; ++s)
		{
			nl = LCP(suf[s],suf[s+1]);
			l = max(pl,nl);
			pl = nl;
			if (suf[s] + l == N) continue;
			now.first = l+1, now.second = s;
			//printf("%d %d : %d\n", suf[s],suf[s+1],l);
			update(1,1,N,suf[s] +1,suf[s]+l-1 +1, now);
			for (; suf[s]+l<N; ++l)
			{
				now.first = l+1;
				if (query(1,1,N,suf[s]+l +1) < now) break;
				update(1,1,N,suf[s]+l +1, suf[s]+l +1, make_pair(l+1,s));
			}
		}
		s = N-1, l = pl;
		if (suf[s] + l < N)
		{
			now.first = l+1, now.second = s;
			update(1,1,N,suf[s] +1,suf[s]+l-1 +1, make_pair(l+1,s));
			for (; suf[s]+l<N; ++l)
			{
				now.first = l+1;
				if (query(1,1,N,suf[s]+l +1) < now) break;
				update(1,1,N,suf[s]+l +1, suf[s]+l +1, make_pair(l+1,s));
			}
		}
        print(N);
    }
    return 0;
}