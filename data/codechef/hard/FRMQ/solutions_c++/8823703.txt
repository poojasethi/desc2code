#include<bits/stdc++.h>
using namespace std;
struct sparseT{
    //RMQ with sparse Table
    vector<int> sT[64];
    int intialVal;
    sparseT():intialVal(0){

    }
    int bitsCount[100009];
    void preprocess(int N){
        bitsCount[0] = 0;
        bitsCount[1] = 0;
        for(int i = 2;i <= N;++i){
            bitsCount[i] = bitsCount[i -1];
            if(!(i & (i - 1))){
                ++bitsCount[i];
            }
        }
    }
    inline int merge(int a,int b){
        return max(a, b);
    }
    void build(int A[], int N){
        preprocess(N + 1);
        sT[0] = vector<int> (A, A+N);
        for(int p = 1;(1<<p) <= N ;++p){
            for(int i = 0;(i + (1 << p))<=N;++i){
                sT[p].push_back(merge(sT[p-1][i],sT[p-1][i + (1<<(p-1))]));
            }
        }
    }
    inline int query(int L, int R){
        int ans = intialVal;
        for(int i = L; i <= R;){
            int k = bitsCount[(R - i + 1)];
            // printf("%d %d %d\n",i,R,k);
            ans = merge(ans, sT[k][i]);
            i += (1<<k);
        }
        return ans;
    }
    inline int mmquery(int L, int R){
        int k = bitsCount[(R - L + 1)];
        int ans = merge(sT[k][L], sT[k][R - (1 << k) + 1]);
        return ans;
    }
};
int A[1000000];
int main(){
    int N;
    cin>>N;
    for(int i = 0;i < N;++i){
        scanf("%d",&A[i]);
    }
    sparseT tree;
    tree.build(A, N);
    int M,x,y;
    scanf("%d%d%d",&M,&x,&y);
    long long ans = 0;
    while(M--){
        ans += tree.mmquery(min(x, y), max(x, y));
        x += 7;
        while(x >= (N - 1))
            x -= (N - 1);
        y += 11;
        while(y >= N)
            y -= N;
    }
    printf("%lld\n",ans );
    return 0;
}