//https://www.topcoder.com/community/data-science/data-science-tutorials/range-minimum-query-and-lowest-common-ancestor/#Sparse_Table_(ST)_algorithm
//sparse tree for RMQ o(1) time to find min/max in a range and o(nlogn) to update
#include <iostream>
#include<bits/stdc++.h>
#include <cstdio>
#include <cmath>
using namespace std;
 

 
int pow2[17];
 
int st[17][100100];
 
int arr[100100];
int getl[100001];
 
void makest(int n)
{
    int k=getl[n];
    for(int i=0;i<n;i++)
        st[0][i]=arr[i];
    for(int i=1;i<=k;i++)
    {
 
 
        for(int j=0;j+pow2[i]-1<n;j++)
        {
            st[i][j]=max(st[i-1][j],st[i-1][j+pow2[i-1]]);
        }
 
    }
}
 
int query(int i,int j)
{
    int k=getl[j-i+1];
    return max(st[k][i],st[k][j-pow2[k]+1]);
}
 
 
 
 
 
 
 
int main(){
    int n,m,x,y;
    scanf("%d",&n);
 
    for(int i=0;i<n;i++)
        scanf("%d",&arr[i]);
 
 
    pow2[0]=1;
 
 
    for(int i=1;i<17;i++)
    {
        pow2[i]=2*pow2[i-1];
 
    }
 
 
    for(int i=1;i<=n;i++)
        getl[i]=(int)log2(i);
    makest(n);
    scanf("%d%d%d",&m,&x,&y);
    long long ans=0;
 
    ans+=(x<y?query(x,y):query(y,x));
    for(int i=2;i<=m;i++)
    {
        x+=7;
        while(x>=n-1)
            x-=(n-1);
 
 
        y+=11;
        while(y>=n)
            y-=n;
        ans+=(x<y?query(x,y):query(y,x));
    }
    printf("%lld\n",ans);
 
 
 
}
 
 