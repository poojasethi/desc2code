#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
#include <functional>
#include <math.h>
#include <map>

inline bool fastreadIsEndOfLine(int* a)
{
  register char c = 0;
  while (c < 33)
    c = getchar();
  *a = 0;
  while (c > 33)
  {
    *a = (*a <<1)+(*a<<3) + c - '0';
    c = getchar();
    if(c == '\r' || c == '\n')
      return true;
  }

  return false;
}

inline void fastread(int* a)
{
  register char c = 0;
  while (c < 33)
    c = getchar();
  *a = 0;
  while (c > 33)
  {
    *a = (*a <<1)+(*a<<3) + c - '0';
    c = getchar();
  }
}

inline void fastreadll(long long* a)
{
  register char c = 0;
  while (c < 33)
    c = getchar();
  *a = 0;
  while (c > 33)
  {
    *a = (*a <<1)+(*a<<3) + c - '0';
    c = getchar();
  }
}

inline void fastreadNeg(int* a)
{
  register char c = 0;
  while (c < 33)
    c = getchar();
  *a = 0;
  bool neg = false;
  if(c == '-')
  {
	  c = getchar();
	  neg = true;
  }
  while (c > 33)
  {
    *a = (*a <<1)+(*a<<3) + c - '0';
    c = getchar();
  }

  if(neg)
	  *a = -*a;
}

inline void readString(char *s)
{
  *s = getchar();
  while(*s == '\r' || *s == '\n' || *s == -1)
    *s = getchar();

  while(*s != '\r' && *s != '\n' && *s != -1)
  {
    ++s;
    *s = getchar();
  }
  *s = '\0';
}

int N, K, M, Q, O;
int T = 1;
int A[100000 + 1];
int X, Y;

// Sparse table solution
int ST[20][100000];
//                       0  1  2  3  4   5   6   7    8    9    10    11    12    13    14     15     16     17
const int DegOfTwo[] = { 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 100000/*131072*/ };

char log2Cache[100000 + 1];
int BLA[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

void CreateSparseTableDP()
{
  for(int i = 0; i < N; ++i)
  {
    ST[0][i] = A[i];
  }

  int deg = 1;
  int degOf2 = 2;
  for(; degOf2 <= N; ++deg, degOf2 <<= 1)
  {
    const int upperBound = N - degOf2;
    const int prevDeg = deg - 1;
    const int prevDegOf2 = degOf2 >> 1;
    for(int i = 0; i <= upperBound; ++i)
    {
      const int a = ST[prevDeg][i];
      const int b = ST[prevDeg][i + prevDegOf2];
      ST[deg][i] = a > b ? a : b;
    }
  }
}

// Segment tree solution - too slow
struct Node
{
  int maxim;
  int l;
  int r;
  Node *left;
  Node *right;

  Node(int _l, int _r) : maxim(0), l(_l), r(_r), left(NULL), right(NULL) {}
};

Node * CreateSegmentTree(int l, int r)
{
  Node *n = new Node(l, r);

  if(l == r)
  {
    n->maxim = A[l];
    return n;
  }

  const int m = (l + r) >> 1;
  n->left = CreateSegmentTree(l, m);
  n->right = CreateSegmentTree(m + 1, r);
  n->maxim = n->left->maxim > n->right->maxim ? n->left->maxim : n->right->maxim;
  return n;
}

int FindMaximum(const Node *n, int l, int r)
{
  // This node is hit directly
  if(n->l == l && n->r == r)
    return n->maxim;

  // All is to the left
  if(r < n->right->l)
    return FindMaximum(n->left, l, r);

  // All is to the right
  if(n->left->r < l)
    return FindMaximum(n->right, l, r);

  // We need to split here
  const int a = FindMaximum(n->left, l, n->left->r);
  const int b = FindMaximum(n->right, n->right->l, r);
  return a > b ? a : b;
}

int main()
{
  log2Cache[1] = 0;
  log2Cache[2] = 1;
  for(int deg = 2; deg <= 17; ++deg)
  {
    memset(log2Cache + DegOfTwo[deg - 1] + 1, (char)deg, DegOfTwo[deg] - DegOfTwo[deg - 1]);
  }

#ifdef USE_DATA_TXT
  freopen_s(&stream, "C:\\Projects\\TaskTemplate\\data.txt", "r", stdin);
#endif
#ifdef PRINT_PERF
  auto start = std::chrono::high_resolution_clock::now();
#endif

  //fastread(&T);

  while(T--)
  {
    fastread(&N);
    for(int i = 0; i < N; ++i)
      fastread(A + i);
    fastread(&M);
    fastread(&X);
    fastread(&Y);
    const int Nm1 = N - 1;

    //Node *n = CreateSegmentTree(0, Nm1);
    CreateSparseTableDP();

#ifdef PRINT_PERF
  PrintResultPerf(start);
#endif

    long long answer = 0;
    //long long answerDebug = 0;
    for(int q = 0; q < M; ++q)
    {
      int l = X;
      int r = Y;
      if(l > r)
      {
        l = Y;
        r = X;
      }

      // How many elements
      const int count = r - l + 1;

      // Figure out the degree of two, so it is well within the number of elemennts. Use // Binary search
      // That is too slow, use precalculated logs (see above)
      //int ll = 0;
      //int rr = 17;
      //int deg = 8;
      //int degOfTwo = 1;
      //while(true)
      //{
      //  degOfTwo = DegOfTwo[deg];

      //  // Exact hit!
      //  if(count == degOfTwo)
      //    break;

      //  // Need to decide where to go
      //  if(count > degOfTwo)
      //    ll = deg;
      //  else
      //    rr = deg;

      //  if(ll == rr - 1)
      //  {
      //    deg = rr;
      //    degOfTwo = DegOfTwo[deg];
      //    break;
      //  }

      //  deg = (ll + rr) >> 1;
      //}
      
      const int deg = log2Cache[count];
      const int degOfTwo = DegOfTwo[deg];

      if(degOfTwo == count) // The length of the subsequence is a degree of two, so take just one span
      {
        answer += ST[deg][l];
      }
      else
      {
        // Use max of two table entries encompassing the whole range
        const int *pst = ST[deg - 1];
        answer += pst[l] > pst[l + (count - (degOfTwo >> 1))] ? pst[l] : pst[l + (count - (degOfTwo >> 1))];
      }

      // Update the X and Y for the next iteration
      X = (X + 7);
      while(X >= Nm1) X -= Nm1;
      Y = (Y + 11);
      while(Y >= N) Y -= N;
    }


    printf("%lld\n", answer);
  }

#ifdef PRINT_PERF
  PrintResultPerf(start);
#endif
#ifdef USE_DATA_TXT
  if(stream)
  {
    fclose(stream);
    stream = NULL;
  }
#endif

  return 0;
}
