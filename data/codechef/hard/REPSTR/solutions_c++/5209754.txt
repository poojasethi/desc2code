#include <string>
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <map>
#include <set>
#include <vector>
#include <algorithm>
#include <math.h>
#include <utility>
#include <sstream>
#include <queue>
#include <stack>
#include <iomanip>
using namespace std;

#define pb push_back
#define mp make_pair
#define all(X) (X).begin(),(X).end()
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

const int MAXN = 100000 + 10;
char str[MAXN], start = 'a', endc = 'z';
int sa[MAXN], rnk[MAXN], cntR[260], cnt[MAXN], aux[MAXN], trnk[MAXN];

void radix(int x, int N, int sa[], int aux[])
{
    int i;
    memset(cnt, 0, sizeof cnt);
    for(i = 0; i < N; i++)
    {
        int y = sa[i] + x < N ? rnk[sa[i] + x] + 1 : 0;        
        cnt[y + 1]++;
    }
    for(i = 1; i <= N+1; i++)
        cnt[i] += cnt[i-1];
    for(i = 0; i < N; i++)
    {
        int y = sa[i] + x < N ? rnk[sa[i] + x] + 1 : 0;
        aux[cnt[y]++] = sa[i];        
    }
}

void suffixarray(int N)
{
    int i;
    memset(cntR, 0, sizeof cntR);
    for(i = 0; i < N; i++)
        cntR[str[i]]++;
    for(i = start; i <= endc; i++)
        cntR[i] += cntR[i-1];
    for(i = 0; i < N; i++) 
    {
        sa[--cntR[str[i]]] = i;
        rnk[i] = cntR[str[i]];
    }   
    for(i = 1; i < N; i++)
        if(str[sa[i]] == str[sa[i-1]])
            rnk[sa[i]] = rnk[sa[i-1]]; 
    for(int h = 1; h < N; h *= 2)
    {   
        radix(h, N, sa, aux);                   
        radix(0, N, aux, sa);    
        trnk[sa[0]] = 0;
        int b, a = sa[0] + h < N ? rnk[sa[0] + h] : -1;
        for(i = 1; i < N; i++)
        {
            b = sa[i] + h < N ? rnk[sa[i] + h] : -1;            
            trnk[sa[i]] = trnk[sa[i-1]] + (rnk[sa[i]] == rnk[sa[i-1]] && a == b ? 0 : 1);    
            a = b;              
        }        
        for(i = 0; i < N; i++)
            rnk[sa[i]] = trnk[sa[i]];
        if(rnk[sa[N-1]] == N-1) break;
    }
}

int height[MAXN];
// height[i] = length of the longest common prefix of suffix pos[i] and suffix pos[i-1]
// height[0] = 0
void getHeight(int n){
  for (int i=0; i<n; ++i) rnk[sa[i]] = i;
  height[0] = 0;
  for (int i=0, h=0; i<n; ++i){
    if (rnk[i] > 0){
      int j = sa[rnk[i]-1];
      while (i + h < n && j + h < n && str[i+h] == str[j+h]) h++;
      height[rnk[i]] = h;
      if (h > 0) h--;
    }
  }
}
// End of longest common prefixes algorithm

int freq,len,l,h;

// Traverse With Array :
// A linear time algorithm for the substring traversal problem.
void TraverseWithArray(int n)
{
   stack<pair<int,int> > s;
   s.push( mp(-1,-1) );
   int Llca,Hlca,L,H,R;
   pair<int,int> LH;
   for(int k=1; k<=n+1; k++)
   {
      Llca = k - 1;
      Hlca = height[k];
      LH= s.top();
      L = LH.first;
      H = LH.second;
      while(H > Hlca)
      {              
         s.pop();
         R = k - 1;
         //cout<<L<<" "<<R<<" "<<H<<endl;
         //cout<<R-L<<" "<<H<<endl;
         if(H>=l && H<=h)
         {
             if(R-L+1 > freq)
             {
                freq = R-L+1;
                len = H;
             }
             else if(R-L+1 == freq && H > len)
             {
                len = H;
             }
         }  
         Llca = L;
         LH = s.top();
         L = LH.first;
         H = LH.second;
      }
      if(H < Hlca)
      {
         s.push( mp(Llca,Hlca) );
      }
      s.push( mp(k,n - sa[k] + 1) );
   }
}

int N,i,j;

int main()
{   
   //freopen("repstr.in","r",stdin);
   scanf("%d %d%*c",&l,&h);   
   while(!(l==0 && h==0))
   {      
       scanf("%s",str); 
       N=strlen(str);           
       freq=0;
       len=0;
       suffixarray(N);
       getHeight(N);
       TraverseWithArray(N);
       printf("%d %d\n",freq,len);
       scanf("%d %d%*c",&l,&h);   
   }
   return 0;
}