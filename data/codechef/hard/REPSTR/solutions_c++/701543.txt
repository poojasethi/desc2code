#include<stdio.h>
#include<iostream>
#include<map>
#include<string>

using namespace std;

inline int solve(string &s, int l, int h);

int cnt = 0, mark[1000117];

int main() {
    ios::sync_with_stdio(false);

//    freopen("repstr.in", "rt", stdin);
//    freopen("repstr.out", "wt", stdout);

    do {
        int l, h;
        cin >> l >> h;
        if (!l) break;

        string s;
        cin >> s;

        solve(s, l, h);
    } while (1);

    return 0;
}

int hash0(string &s, int base, int mod) {
    int ret = 0;

    for (int i = 0; i < s.length(); i++) {
        ret *= base;
        ret += s[i] - 'a';
        ret %= mod;
    }

    return ret;
}

int hash1(string &s, int base, int mod) {
    int ret = 0;

    for (int i = s.length() - 1; i >= 0; i++) {
        ret *= base;
        ret += s[i] - 'a';
        ret %= mod;
    }

    return ret;
}

map<int, int> M[1000117];

inline int check1(string &s, int len) {
    cnt++;
    int ckey = 2;

    int n = s.length(), ret = 0;
    int base[4] = {26, 27, 28, 29};
    int mod[4] = {1000117, 1000133, 1000213, 1000313};
    int hash[4], pow[4];

    for (int i = 0; i < ckey; i++) {
        pow[i] = 1;
        for (int j = 1; j <= len - 1; j++) {
            pow[i] *= base[i];
            pow[i] %= mod[i];
        }
    }

    string ss = s.substr(0, len - 1);
    ss = 'a' + ss;

    for (int i = 0; i < ckey; i++) hash[i] = hash0(ss, base[i], mod[i]);

    int fi = ss[0] - 'a', la = ss[len - 1] - 'a';

    for (int i = 0; i <= n - len; i++) {
        la = s[i + len - 1] - 'a';

        for (int j = 0; j < ckey; j++) {
            hash[j] += mod[j];
            hash[j] -= fi * pow[j] % mod[j];
            hash[j] *= base[j];
            hash[j] += la;
            hash[j] %= mod[j];
        }

        if (mark[hash[0]] != cnt) {
            M[hash[0]].clear();
            mark[hash[0]] = cnt;
        }

        ret = max(ret, ++M[hash[0]][hash[1]]);

        fi = s[i] - 'a';
    }

    return ret;
}

inline int check2(string &s, int len, int m) {
    cnt++;
    int ckey = 2;

    int n = s.length();
    int base[4] = {26, 27, 28, 29};
    int mod[4] = {1000117, 1000133, 1000213, 1000313};
    int hash[4], pow[4];

    for (int i = 0; i < ckey; i++) {
        pow[i] = 1;
        for (int j = 1; j <= len - 1; j++) {
            pow[i] *= base[i];
            pow[i] %= mod[i];
        }
    }

    string ss = s.substr(0, len - 1);
    ss = 'a' + ss;

    for (int i = 0; i < ckey; i++) hash[i] = hash0(ss, base[i], mod[i]);

    int fi = ss[0] - 'a', la = ss[len - 1] - 'a';

    for (int i = 0; i <= n - len; i++) {
        la = s[i + len - 1] - 'a';

        for (int j = 0; j < ckey; j++) {
            hash[j] += mod[j];
            hash[j] -= fi * pow[j] % mod[j];
            hash[j] *= base[j];
            hash[j] += la;
            hash[j] %= mod[j];
        }

        if (mark[hash[0]] != cnt) {
            M[hash[0]].clear();
            mark[hash[0]] = cnt;
        }

        if (++M[hash[0]][hash[1]] >= m) {
            return 1;
        }

        fi = s[i] - 'a';
    }

    return 0;
}

inline int solve(string &s, int l, int h) {
    int m = check1(s, l);

    int n = s.length(), lo = l, hi = min(n - m + 1, h), res1 = m, res2;

    while (lo <= hi) {
        int mid = (lo + hi) >> 1;
        if (check2(s, mid, m)) {
            res2 = mid;
            lo = mid + 1;
        } else hi = mid - 1;
    }

    cout << res1 << " " << res2 << endl;

    return 0;
}
