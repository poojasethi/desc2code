#include <string>
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <map>
#include <set>
#include <vector>
#include <algorithm>
#include <math.h>
#include <utility>
#include <sstream>
#include <queue>
#include <stack>
#include <iomanip>
using namespace std;

#define pb push_back
#define mp make_pair
#define all(X) (X).begin(),(X).end()
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

const int MAXN = 100000 + 10;
char str[MAXN], start = 'a', endc = 'z';
int sa[MAXN], rnk[MAXN], cnt[MAXN], lcp[MAXN], cntR[260];
bool bh[MAXN], b2h[MAXN];

void suffixarray(int N)
{
    int i, j, k;
    memset(cntR, 0, sizeof cntR);
    for(i = 0; i < N; i++)    
        cntR[str[i] + 1]++, bh[i] = b2h[i] = false;    
    for(i = start+1; i <= endc+1; i++)
        cntR[i] += cntR[i-1];   
    for(i = start; i <= endc; i++)
        bh[cntR[i]] = true;     
    for(i = 0; i < N; i++)    
    {
        sa[cntR[str[i]]++] = i;    
        rnk[i] = cntR[str[i]] - 1;
    }
    for(int h = 1; h < N; h *= 2)
    {        
        for(i = 0; i < N; i++)
            if(!bh[i]) break;
        if(i == N) break;
        for(i = 0; i < N; i = j)        
        {
            cnt[i] = 0;
            for(j = i+1; j < N && !bh[j]; j++)
                rnk[sa[j]] = rnk[sa[i]];        
        }        
        cnt[rnk[N - h]]++;
        b2h[rnk[N - h]] = true;
        for(i = 0; i < N; i = j)
        {
            for(j = i; !bh[j] || j == i; j++)
            {          
                if(j >= N) break;      
                int x = sa[j] - h;
                if(x < 0) continue;
                cnt[rnk[x]]++;
                rnk[x] += cnt[rnk[x]] - 1;
                b2h[rnk[x]] = true;
            }        
            for(j = i; !bh[j] || j == i; j++)
            {
                if(j >= N) break;
                int x = sa[j] - h;
                if(x < 0 || !b2h[rnk[x]]) continue;
                for(k = rnk[x]+1; !bh[k] && b2h[k]; k++)
                    b2h[k] = false;      
            }
        }
        for(i = 0; i < N; i++)
        {
            bh[i] = b2h[i];        
            sa[rnk[i]] = i;
        }        
    }   
    int h = 0;
    for(i = 0; i < N; i++)
    {
        j = rnk[i] - 1;
        if(j < 0) continue;
        j = sa[j];
        while(i+h < N && j+h < N && str[i+h] == str[j+h]) h++;
        lcp[rnk[i]] = h;
        if(h) h--;
    }
}

int freq,len,l,h;

// Traverse With Array :
// A linear time algorithm for the substring traversal problem.
void TraverseWithArray(int n)
{
   stack<pair<int,int> > s;
   s.push( mp(-1,-1) );
   int Llca,Hlca,L,H,R;
   pair<int,int> LH;
   for(int k=1; k<=n+1; k++)
   {
      Llca = k - 1;
      Hlca = lcp[k];
      LH= s.top();
      L = LH.first;
      H = LH.second;
      while(H > Hlca)
      {              
         s.pop();
         R = k - 1;
         //cout<<L<<" "<<R<<" "<<H<<endl;
         //cout<<R-L<<" "<<H<<endl;
         if(H>=l && H<=h)
         {
             if(R-L+1 > freq)
             {
                freq = R-L+1;
                len = H;
             }
             else if(R-L+1 == freq && H > len)
             {
                len = H;
             }
         }  
         Llca = L;
         LH = s.top();
         L = LH.first;
         H = LH.second;
      }
      if(H < Hlca)
      {
         s.push( mp(Llca,Hlca) );
      }
      s.push( mp(k,n - sa[k] + 1) );
   }
}

int N,i,j;

int main()
{   
   //freopen("repstr.in","r",stdin);
   scanf("%d %d%*c",&l,&h);   
   while(!(l==0 && h==0))
   {      
       scanf("%s",str); 
       N=strlen(str);           
       freq=0;
       len=0;
       suffixarray(N);
       TraverseWithArray(N);
       printf("%d %d\n",freq,len);
       scanf("%d %d%*c",&l,&h);   
   }
   return 0;
}