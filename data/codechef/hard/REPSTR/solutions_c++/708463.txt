#include <stdlib.h>
#include <stdio.h>
#include <string>
#include <math.h>
#include <fstream>
#include <iostream>
#include <vector>
#include <deque>
#include <map>
#include <cstdlib>
using namespace std;

//October Long Contest 2011, REPSTR Repeated String codechef.com
//Disable warning messages C4996.
//#pragma warning(disable:4996)

#define INPUT_FROM 0
#if INPUT_FROM
#define fromc from
#else
#define fromc cin
#endif

struct node{
	map<char, int> mnext;
	int i0, i1;//previous edge label: s[i0]...s[i1] 
	int sf;//suffix link to a node
	int lf;//a leaf number: -1 => not a leaf
	int prev;//previous node number
	int n;//only for this problem: number of nodes in lower levels plus this one
	int k;//only for this problem: the length of the suffix till this node or leaf
};

//long long fr(vector<long long>&, long long);
int ukkonen(vector<node>&, string&);

int main(int argc, char **argv)
{
	//ifstream from;
	const int nmin=1, nmax=100000, mmin=1, mmax=1000000000;
	int n, m, mt, res, rt, i, i0, i1, j, j0, j1, k, kt, kr, t, ax;
	//char ch;
	//string sres[2]={"YES", "NO"};
	string s, st, sr;
	//long double dt;

	//if(INPUT_FROM) from.open("test.txt");
	//freopen("input.txt","r",stdin);
	//freopen("output.txt","w",stdout);

	vector<int> vr;
	vector<node> v;
	//vector<vector<long long> > v(n);
	deque<int> dq;
	//map<int, int> mi;
	//map<int, int>::iterator it;
	map<char, int>::iterator itc;
	//typedef map<string, long long>::const_iterator CI;


	while((fromc>>i0>>i1)&&(i0+i1>0)){//0<i0<=i1<=m
		fromc>>s;
		m=s.size();
		ukkonen(v, s);//m->m+1 added '$'
		n=v.size();

		mt=0;
		for(i=0;i<n;i++){
			if(v[i].lf>=0){
				v[i].n=1;
				v[i].i1=m-1;
			}else v[i].n=0;
		}

		v[0].k=0;
		vr.push_back(0);
		i=0;
		mt=1;
		while(mt<n){
			j0=vr[i];
			for(itc=v[j0].mnext.begin();itc!=v[j0].mnext.end();itc++){
				j1=itc->second;
				kt=v[j1].i1-v[j1].i0+1;
				v[j1].k=v[j0].k+kt;
				vr.push_back(j1);
				mt++;
			}
			i++;
		}
		for(i=n-1;i>0;i--) v[v[vr[i]].prev].n+=v[vr[i]].n;

		dq.push_back(0);
		mt=1;
		res=kr=0;//res - number of a kr-length substring in s

		while(mt>0){
			j0=dq.front();
			dq.pop_front();
			mt--;
			for(itc=v[j0].mnext.begin();itc!=v[j0].mnext.end();itc++){
				j1=itc->second;
				if(v[j1].k<=i1){
					dq.push_back(j1);
					mt++;
					if(i0<=v[j1].k){
						if(res<v[j1].n){
							res=v[j1].n;
							kr=v[j1].k;
						}else if((res==v[j1].n)&&(kr<v[j1].k)){
							kr=v[j1].k;
						}
					}
				}
			}
		}
		v.clear();
		dq.clear();
		vr.clear();
		cout<<res<<' '<<kr<<endl;
	}

	return 0;
}



int ukkonen(vector<node>& v, string& s){
	const int nmin=1, nmax=100000, mmin=1, mmax=1000000000;
	int n, m, res, rt, rt0, rt1, tt, i, i0, i1, j, j0, j1, j2, k, k0, k1, kt, t, t0, t1, ax, a0, a1, bx, cx;
	char ch;

	//vector<node> v;
	deque<int> dq0, dqk0, dq1, dqk1;
	node node0, node1;

	ch='$';
	//bx=0;//to add ch to s
	//fromc>>s;
	m=s.size();

	s+=ch;//add '$'

	j=0;//extension number
	node0.i0=node0.i1=node0.sf=node0.lf=node0.prev=-1;//root
	node0.k=0;
	v.push_back(node0);
	t=1;//next node number
	node1.i0=0;
	node1.i1=mmax;//will be replaced for a leaf by e=i
	node1.sf=-2;
	node1.lf=j;//leaf number
	node1.prev=0;
	node1.k=mmax;
	v.push_back(node1);
	v[0].mnext[s[j]]=t++;

	ax=2;
	a0=0;

	//rt: s[v[rt].i0]...s[i-1] is before rt
	//the first node (root) for j=0, i=0, -- will be used for j=1, i=1
	//k - number of letters between s[v[rt].i0] and s[i-1] (including)

	rt0=k0=1;	//rt=rt0 last visited node for j=j0+1
	j0=0;		//last extension number in the continued sequence of 1 or 2 rules
			//in (i-1) phase

	//k - number of letters between j1=j2-k+1 and j2=i-1 (including) in rt:
	//s[v[rt].i0]=s[j1]
	//s[v[rt].i0+k-1]=s[j2]

	for(i=1;i<m+1;i++){//==e, phase number
		rt=rt0;
		k=k0;
		j=j0+1;

		while(j<=i){

			bx=cx=0;
			if(i==j){
				rt=0;
				if(v[0].mnext.find(s[i])==v[0].mnext.end()) ax=2;
				else{
					kt=k;
					ax=3;
				}
				bx=1;
			}else if(ax==3);// rt=v[rt].prev;//rt is before s[i-1] for j
			else if((v[rt].prev==0)&&(v[0].mnext.find(s[j])==v[0].mnext.end())){
				rt=0;
				ax=2;
				k=i-j+1;
				bx=1;
			}else{
				if(v[rt].prev==0){
					j1=j;
					k=i-j;
					rt=0;
				}else{
					rt=v[rt].prev;
					if(v[rt].sf>=0) rt=v[rt].sf;
					else if(v[rt].sf==-2){
						i0=v[rt].i0;
						i1=v[rt].i1;
						i1=(i1==mmax)?(i-1):i1;
						kt=i1-i0+1;
						k+=kt;
						rt=v[rt].prev;
						if(rt!=0) rt=v[rt].sf;
					}
					j1=i-k;
				}
				//rt is before s[i-1] for j

				rt=v[rt].mnext[s[j1]];
			}
			//rt is after s[j1]

			if(bx==0){
				i0=v[rt].i0;
				i1=v[rt].i1;
				i1=(i1==mmax)?(i-1):i1;
				kt=i1-i0+1;

				while(k>kt){
					if(k>kt){
						k-=kt;
						j1+=kt;
						rt=v[rt].mnext[s[j1]];
					}
					i0=v[rt].i0;//i0==j1-kt
					i1=v[rt].i1;
					i1=(i1==mmax)?(i-1):i1;//rt is after s[j1]
					kt=i1-i0+1;
				}

				if((k==kt)&&(i1<i-1)){
					if(v[rt].mnext.find(s[i])==v[rt].mnext.end()) ax=2;
					else ax=3;
				}else if(k<kt){
					if(s[i]!=s[v[rt].i0+k]){
						ax=2;
						cx=1;
					}else ax=3;
				}else if((k==kt)&&(i1==i-1)) ax=1;
			}

			if((cx==0)&&(a0>0)){
				//if(ax==3) v[a0].sf=v[rt].prev;
				//else 
				v[a0].sf=rt;
				a0=0;
			}

			if(ax==1){//=>v[rt].lf>=0
				k0=k+1;
				j0++;
				rt0=rt;
			}else if(ax==2){//rule 2
				if(cx==1){
					//rt=v[rt].mnext[s[j1]];
					//node1.mnext.clear();
					node1.i0=v[rt].i0;
					node1.i1=v[rt].i0+k-1;
					node1.lf=-1;//not a leaf
					node1.prev=v[rt].prev;

					node1.k=v[node1.prev].k+k;//the length till this node

					if(a0>0) v[a0].sf=t;
					if((k==1)&&(node1.prev==0)){
						node1.sf=0;//was error without (k==1) if node1.i1-node.i0+1>1
						a0=0;
					}else{
						node1.sf=-2;
						a0=t;
					}
					node1.mnext[s[v[rt].i0+k]]=rt;//!!!!!!! corrected
					node1.mnext[s[i]]=t+1;//will add a leaf
					v.push_back(node1);
					node1.mnext.clear();

					v[v[rt].prev].mnext[s[v[rt].i0]]=t;
					v[rt].i0+=k;
					v[rt].prev=t;
					
					rt=t++;
				}else v[rt].mnext[s[i]]=t;

				node1.i0=i;
				node1.i1=mmax;
				node1.sf=-2;
				node1.lf=j;//a leaf
				node1.prev=rt;
				node1.k=mmax;//for leaves

				v.push_back(node1);
				if(i==j){
					k0=1;
					rt0=t;
				}else{
					k0=k;
					rt0=rt;
				}
				//k0=1;
				//k0=k;
				//rt0=rt;
				t++;

				j0++;//rule 2 for j0
			}else if(ax==3){// rule 3
				if(k==kt){
					k0=1;
					rt=v[rt].mnext[s[i]];
				}else k0=k+1;
				rt0=rt;
				j=m;
			}
			j++;
		}

		/*if(i==m-1){
			s+=ch;
			bx=1;
		}*/
	}
	//return v;
	return 0;
}