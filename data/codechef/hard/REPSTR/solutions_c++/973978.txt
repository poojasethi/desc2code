#pragma comment(linker, "/STACK:1000000000")

#include <map>
#include <vector>
#include <string>
#include <fstream>
#include <iostream>

using namespace std;

#define		MAXN	200010

int mx,mn,bm,bs,nm,ns;
string s;
int n;
vector<int> adj[MAXN];
int len[MAXN];
int d[MAXN];

struct node {
	int l, r, par, link;
	map<char,int> next;

	node (int l=0, int r=0, int par=-1)
		: l(l), r(r), par(par), link(-1) {}
	int len()  {  return r - l;  }
	int &get (char c) {
		if (!next.count(c))  next[c] = -1;
		return next[c];
	}
};
node t[MAXN];
int sz;

struct state {
	int v, pos;
	state (int v, int pos) : v(v), pos(pos)  {}
};
state ptr (0, 0);

state go (state st, int l, int r) {
	while (l < r)
		if (st.pos == t[st.v].len()) {
			st = state (t[st.v].get( s[l] ), 0);
			if (st.v == -1)  return st;
		}
		else {
			if (s[ t[st.v].l + st.pos ] != s[l])
				return state (-1, -1);
			if (r-l < t[st.v].len() - st.pos)
				return state (st.v, st.pos + r-l);
			l += t[st.v].len() - st.pos;
			st.pos = t[st.v].len();
		}
		return st;
}

int split (state st) {
	if (st.pos == t[st.v].len())
		return st.v;
	if (st.pos == 0)
		return t[st.v].par;
	node v = t[st.v];
	int id = sz++;
	t[id] = node (v.l, v.l+st.pos, v.par);
	t[v.par].get( s[v.l] ) = id;
	t[id].get( s[v.l+st.pos] ) = st.v;
	t[st.v].par = id;
	t[st.v].l += st.pos;
	return id;
}

int get_link (int v) {
	if (t[v].link != -1)  return t[v].link;
	if (t[v].par == -1)  return 0;
	int to = get_link (t[v].par);
	return t[v].link = split (go (state(to,t[to].len()), t[v].l + (t[v].par==0), t[v].r));
}

void tree_extend (int pos) {
	for(;;) {
		state nptr = go (ptr, pos, pos+1);
		if (nptr.v != -1) {
			ptr = nptr;
			return;
		}

		int mid = split (ptr);
		int leaf = sz++;
		t[leaf] = node (pos, MAXN, mid);
		t[mid].get( s[pos] ) = leaf;

		ptr.v = get_link (mid);
		ptr.pos = t[ptr.v].len();
		if (!mid)  break;
	}
}

void build_tree() {
	sz = 1;
	for (int i=0; i<n; ++i)
		tree_extend (i);
}

int dfs(int x,int l){
	int nl = 0;
	int ln = t[x].len();
	len[x] = l+ln;
	if (adj[x].empty()){
		d[x] = 1;
		len[x]--;
		return 1;
	}
	for (int i=0;i<adj[x].size();i++){
		nl += dfs(adj[x][i],l+ln);
	}
	d[x] = nl;
	return nl;
}

void dfs2(int x){
	if (len[x]>=mn){
		if (d[x]>bm || (d[x]==bm && (min(len[x],mx))>bs)){
			bm = d[x];
			bs = min(len[x],mx);
		}
		return;
	}
	for (int i=0;i<adj[x].size();i++){
		dfs2(adj[x][i]);
	}
	return;
}


int main(){
//	ifstream fin("A.in");
//	cin.rdbuf(fin.rdbuf());

	while(cin >> mn >> mx,(mn!=0 || mx!=0)){
		t[0] = node();
		bm = 0;
		cin >> s;
		s+='.';
		n = s.length();
		sz = 0;
		ptr = state(0,0);
		build_tree();
		for (int i=0;i<sz;i++){
			adj[i].clear();
		}
		for (int i=1;i<sz;i++){
			adj[t[i].par].push_back(i);
		}
		dfs(0,0);
		dfs2(0);
		cout << bm << " " << bs << endl;
	}
	return 0;
}