#include <iostream>
#include <string>
#include <cstring>
#include <algorithm>
#include <ctime>
#include <cstdio>
#include <climits>
using namespace std;
#define N 10000000

typedef unsigned long long ULL;
/****************
Give Input:   aabcaaabba
nBucket[i] -> Represents the Bucket no in which suffix[i...n-1] is placed at that H...
Pos[i]     -> Suffix at ith position after sorting all the suffixes by their first 1 << H characters...
****************/
char str[N];
int H = 0, Bucket[N], nBucket[N], c;

struct Suffix
{
    	int idx; // Suffix starts at idx, i.e. it's str[ idx .. L-1 ]
    	bool operator < (const Suffix& sfx) const
    	// Compares two suffixes based on their first 2H symbols,
    	// assuming we know the result for H symbols.
    	{
    		if(H == 0)
                   return str[idx] < str[sfx.idx];
    		else if(Bucket[idx] == Bucket[sfx.idx])
    			   return (Bucket[idx+H] < Bucket[sfx.idx+H]);
    		else
    			   return (Bucket[idx] < Bucket[sfx.idx]);
    	}

    	bool operator==(const Suffix& sfx) const
    	{
    		     return !(*this < sfx) && !(sfx < *this);
    	}
}Pos[N];

void Display(Suffix *pos, int L);
void Display(int* nBucket, int L);

int UpdateBuckets(int L)
{
    	int start = 0, id = 0, c = 0;
    	for(int i = 0; i < L; i++)
    	{
                /// If Pos[i] is not equal to Pos[i-1], a new bucket has started.
        		if(i != 0 && !(Pos[i] == Pos[i-1]))
        		{
          			start = i;
          			id++;
        		}

        		if(i != start) /// If there is bucket with size larger than 1, we should continue ...
          			c = 1;
        		nBucket[Pos[i].idx] = id; /// Bucket for suffix starting at Pos[i].idx is id ...
    	}
    	memcpy(Bucket, nBucket, 4 * L);
    	return c;
}

void SuffixSort(int L)
{
    	for(int i = 0; i < L; i++)
            Pos[i].idx = i;

    	// H == 0, Sort based on first Character.
    	sort(Pos, Pos + L);

    	// Create initial buckets
    	c = UpdateBuckets(L);

    	//cout << "H is " << H << endl;
        //Display(Pos, L);
        //Display(nBucket, L);
        //cout << endl;

    	for (H=1; c ;H *= 2)
        {
        		// Sort based on first 2*H symbols, assuming that we have sorted based on first H character
        		sort(Pos, Pos+L);
        		// Update Buckets based on first 2*H symbols
        		c = UpdateBuckets(L);

        		//cout << "H is " << H << endl;
                //Display(Pos, L);
                //Display(nBucket, L);
                //cout << endl;
	    }
}

void Display(int* nBucket, int L)
{
     cout << "Bucket array:\n";
     for (int i=0; i < L; i++)
        cout << nBucket[i] << " ";
     cout << endl;
}

void Display(Suffix *pos, int L)
{
     cout << "Position array:\n";
     for (int i=0; i < L; i++)
        cout << pos[i].idx << " ";
     cout << endl;
}

int main()
{
        //freopen("input.txt", "r", stdin);
        //freopen("output.txt", "w", stdout);

        while (1)
        {
            H = 0;
            /// str = "aabaaa"
            int Left, Right;
            scanf("%d %d", &Left, &Right);
            if (Left == 0 && Right == 0)
                break;

            cin >> str;
            int L = strlen(str) + 1;
            //str[L-1] = '|';
            //str[L] = '\0';

            SuffixSort(L);
            /*
            for(int i = 0; i < L; i++)
                cout << str + Pos[i].idx << endl;
            */

            /// Linear time LCP Precomputation
            /// height[i] = length of the longest common prefix of suffix pos[i] and suffix pos[i-1]
            /// height[0] = 0
            int suf_inv[L], h = 0, k, height[L];
            height[0] = 0;
            for (int i=0; i<L; i++)
                suf_inv[Pos[i].idx] = i;

            /*
            for (int i=0; i<L; i++)
                cout << i << " -> " << suf_inv[i] << endl;
            */

            for (int i=0; i<L; i++)
            {
                if (suf_inv[i] > 0)
                {
                    k = Pos[suf_inv[i]-1].idx;
                    //cout << "i is " << i <<  " and k is " << k << endl;
                    while (i + h < L && k + h < L && str[i+h] == str[k+h])
                        h++;
                    //cout << "Assigning to height[" << suf_inv[i] << "] = " << h << endl;
                    height[suf_inv[i]] = h;
                    if (h>0)
                        h--;
                }
            }

            /*
            cout << "Height:" << endl;
            for (int i=0; i<L; i++)
                cout << i << ":" << height[i] << " " << str + Pos[i].idx << endl;
            */

            /// Codechef REPSTR Ques
            int max_occu = 1, occurences = 1, mini = INT_MAX, max_index, max_len, index;
            for (int i=1; i<L; i++)
            {
                if (height[i] >= Left)
                {
                    occurences++;
                    mini = min(mini, height[i]);
                }
                else
                {
                    if (occurences > max_occu)
                    {
                        max_occu = occurences;
                        max_len = mini;
                    }
                    else if (occurences == max_occu)
                        max_len = max(mini, max_len);
                    occurences = 1;
                    mini = INT_MAX;
                }
            }

            if (occurences > max_occu)
            {
                max_occu = occurences;
                max_len = mini;
            }
            else if (occurences == max_occu)
                max_len = max(mini, max_len);

            if (occurences == 1)
                printf("1 %d\n", Right);
            else
                printf("%d %d\n", max_occu, min(max_len, Right));
        }
    	return 0;
}
