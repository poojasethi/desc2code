#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <queue>
#include <set>
#include <cstdio>
#include <cstdlib>
#include <stack>
#include <cstring>
#include <iomanip>
#include <cctype>
#include <map>
#include <cfloat>
#include <numeric>

using namespace std;

void add(int &a,int b,int MOD) {
    a+=b;
    if(a < 0) a+=MOD;
    if(a >= MOD) a-=MOD;
}

void mul(int &a,int b,int MOD) {
    a = ((long long)a * b) % MOD;
}

int Power(int a,int b,int MOD) {
    if(b == 0) return 1;
    else {
        int p = Power(a,b/2,MOD);
        mul(p,p,MOD);
        if(b & 1) {
            mul(p,a,MOD);
        }
        return p;
    }
}

int inverseMod(int a,int MOD) {
    return Power(a,MOD - 2,MOD);
}

const int N = 100005;

int pr[3] = {2,500000003,1000000007};
long long ex,ey;

int fact[3][N];
int invFact[3][N];

int ncr(int n,int r,int mode) {
    if(r > n) return 0;
    if(mode == 0) {
        while(n && r) {
            if(n % 2 == 0 && r % 2 == 1) return 0;
            n/=2;
            r/=2;
        }
        return 1;
    }
    int a = fact[mode][n];
    mul(a,invFact[mode][r],pr[mode]);
    mul(a,invFact[mode][n - r],pr[mode]);
    return a;
}

int ncr2(int n,int r) {
    int ncr1 = ncr(n,r,0);
    int ncr2 = ncr(n,r,1);
    int pw = (ncr1 * ey * pr[1] + ncr2 * ex * pr[0]) % 1000000006;
    return pw;
}

void solve() {
    int n; cin>>n;
    int ans = ncr(n,n/2,2);
    int cnt = 1;
    for(int i = 0;i < n;i++) {
        int b,p; scanf("%d %d",&b,&p);
        mul(cnt,p,pr[2]);
    }
    if(n == 1) {
        cout<<1<<' '<<cnt + 1<<endl;
        return;
    }
    int pw = ncr2(n - 1,n/2 - 1);
    int initCnt = cnt;
    cnt = Power(initCnt,pw,pr[2]);
    if(n & 1) {
        pw = ncr2(n - 1,n/2);
        add(cnt,Power(initCnt,pw,pr[2]),pr[2]);
    }
    cout<<ans<<' '<<cnt<<endl;
}

int main() {
    
    for(int i = 0;i < 3;i++) fact[i][0] = invFact[i][0] = 1;
    for(int i = 1;i <= 100000;i++) {
        for(int j = 0;j < 3;j++) {
            fact[j][i] = i;
            invFact[j][i] = inverseMod(i,pr[j]);
            mul(fact[j][i],fact[j][i - 1],pr[j]);
            mul(invFact[j][i],invFact[j][i - 1],pr[j]);
        }
    }
    ex = inverseMod(pr[0],pr[1]);
    ey = inverseMod(pr[1],pr[0]);
    int t; cin>>t;
    while(t--) {
        solve();
    }
}