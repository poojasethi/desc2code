#include<iostream>
#include<vector>
#include<map>
#include<queue>
#include<sstream>
 
#include<set>
#include<fstream>
#include<algorithm>
#include<cstring>
#include<cassert>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#define oo (int)13e7
#define s(n) scanf("%d",&n)
#define sl(n) scanf("%lld",&n)
#define sf(n) scanf("%lf",&n)
#define fill(a,v) memset(a, v, sizeof a)
#define For(i,s,e) for(int i=s; i < e; i++)
#define ull unsigned long long
#define ll long long
#define bitcount __builtin_popcount
#define all(x) x.begin(), x.end()
#define pb( z ) push_back( z )
using namespace std;
const int mod = 7051954;
 
 
int n, a, b, l;
char moves[512];
//map<int, int> dp[512];
 
const int ub = 512 + 32;
int dp[512][ub+256];
int vis[512][ub+256], vid;
int pluses[ 512 ], ptop;
int minuses[ 512 ], mtop;
 
int solve( int p, int poz )
{
	if( poz > l || poz < 0 )
		return 0;
		
	if( p == n )
	{
		return poz == b;
	}
	if( vis[ p ][ poz ] == vid )
		return dp[ p ][ poz ];
	int& d = dp[ p ][ poz ];
	vis[ p ][ poz ] = vid;
	int ret = poz == b;
	
	int nxtPlus = pluses[ lower_bound( pluses, pluses+ptop, p ) - pluses ];
	int nxtMinus = minuses[ lower_bound( minuses, minuses+mtop, p ) - minuses ];
	if( nxtPlus < n && nxtPlus >= p)
		ret += solve( nxtPlus+1, poz+1 ), ret %= mod;
	if( nxtMinus < n && nxtMinus >= p  )
		ret += solve( nxtMinus+1, poz-1 ), ret %= mod;
	
	return d = ret;
}
 
int main()
{
	int runs;
	scanf("%d", &runs);
	while( runs-- )
	{
		ptop = 0;
		mtop = 0;
		++vid;
		
		scanf("%d%d%d%d", &n, &l, &a, &b );
		scanf("%s", moves );
		
		if( a >= ub )
		{
			
			int offset = a - 512;
			a -= offset;
			b -= offset;
		}
		
		for(int i=0; i <n ;i ++)
			if( moves[i] == '+' )
				pluses[ ptop++ ] = i;
			else if( moves[i] == '-' )
				minuses[ mtop++ ] = i;
		
		cout<< solve( 0, a ) << endl;
	}
	return 0;
}
 