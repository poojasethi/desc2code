#include <iostream>
#include <vector>
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath>
#include <algorithm>
using namespace std;

#define FOR(i,a,b)				for (int i=a;i<b;i++)
#define s(n)					scanf("%d",&n)
#define p(n)					printf("%d\n",n)
#define pl(n)					printf("%lld\n",n)
#define sd(n)					int n;scanf("%d",&n)
#define sl(n)					scanf("%lld",&n)
#define sld(n)					long long int n;scanf("%lld",&n)

typedef long long ll;

typedef struct
{int a;int b;int c;}oper;

vector <vector <oper> > ans;
int n;

void solve(int k)
{
	//preparing to call solve(2k)
	vector <oper> temp;	//these operations can occur in parallel
	for (int i=k;i+k<=n;i+=(2*k))
		temp.push_back((oper){i,i+k,i+k});
	if (!temp.empty()) ans.push_back(temp);
	//solve(2*k); - can't. need a terminating condition.
	if (4*k<=n) solve(2*k);		//so that goes into the first for loop at least once.
	temp.clear();
	for (int i=3*k;i<=n;i+=(2*k))
		temp.push_back((oper){i,i-k,i});
	if (!temp.empty()) ans.push_back(temp);
}

int main()
{
	s(n);
	//ans.clear();
	solve(1);
	p(ans.size());
	int steps=0;
	FOR(j,0,ans.size())
	{
		printf("%d ",ans[j].size());
		steps+=ans[j].size();
		FOR(k,0,ans[j].size())
			printf("%d+%d=%d ",ans[j][k].a,ans[j][k].b,ans[j][k].c);
		printf("\n");
	}
	
	return 0;
}