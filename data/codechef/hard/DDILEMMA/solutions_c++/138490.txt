//TODO: Add digit support.
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <iostream>
using namespace std;

#define RULED_OUT 3
#define SAME 5
#define INITIAL_PHASE 0
#define PHASE1 1
#define MAX_LENGTH 32
//#define DEBUG 
//#define EXCEPTION

void Print(const char **registered,const char **requested,int m,int n);
int Maximum_surcharge(const char **registered,const char *requested,int m);
int Surcharge(const int point);
int Point(const char *registereed,const char *requested);
int Point1(const char *registered,const char *requested);
int Point2(const char *registered,const char *requested);
int Point3(const char *registered,const char *requested);
void Print_Map();
void Fill_Map();

//Use hash map.

int pos[150];

int pos_character[]={1,26,24,3,13,4,5,6,18,7,8,9,28,27,19,20,11,14,2,15,17,25,12,23,16,22 };
//int pos[150]={22,16,23,12,25,17,15,2,14,11,20,19,27,28,9,8,7,18,6,5,4,13,3,24,26,1};
//pos[65]={ 38,37,36,35,34,33,32,31,30};
//pos_digit[d-'0']={ };

main()
{
const char **registered;
const char **requested;
int m,n,i,j;
scanf("%d %d",&m,&n);
/*
//pos[65]={38,37,36,35,34,33,32,31,30};
//pos[65]=38;

pos[66]=39;
pos[67]=40;
pos[68]=41;
pos[69]=42;
pos[70]=43;
pos[71]=44;
pos[72]=45;
pos[73]=46;
pos[74]=47;
*/

/*
for(i=0;i<10;i++)
pos['z'-'i']=30+i;
*/

Fill_Map();

#ifdef DEBUG
Print_Map();
#endif

registered=(const char **)malloc(sizeof(char *)*m);
requested=(const char **)malloc(sizeof(char *)*n);

for(i=0;i<m;i++)
{
registered[i]=(char *)malloc(sizeof(char)*MAX_LENGTH);
scanf("%s",registered[i]);

}

for(j=0;j<n;j++)
{

requested[j]=(char *)malloc(sizeof(char)*MAX_LENGTH);
scanf("%s",requested[j]);
}

#ifdef DEBUG
Print(registered,requested,m,n);
#endif

#ifndef EXCEPTION
for(i=0;i<n;i++)
{
printf("%d\n",Maximum_surcharge(registered,requested[i],m));
}

#else
for(i=0;i<n;i++)
{
try
{
printf("%d\n",Maximum_surcharge(registered,requested[i],m));
}
catch(...)
{
exit(-1);
}
}
#endif

}

void Print(const char **registered,const char **requested,int m,int n)
{
int i,j;
for(i=0;i<m;i++)
printf("%s\n",registered[i]);
printf("\n");
for(j=0;j<n;j++)
printf("%s\n",requested[j]);

}

int Maximum_surcharge(const char **registered,const char *requested,int m)
{
int maxsurcharge=0;
int surcharge;
int i;
int point=3;
int count_domain_names=0;
for(i=0;i<m;i++)
{
point=Point(registered[i],requested);
#ifdef DEBUG
printf("pair: %s %s %d\n",registered[i],requested,point);
#endif
if(point == 1 || point == 2)
count_domain_names++;
if(point == SAME)
{
return -1;
}
surcharge=Surcharge(point);
if(surcharge > maxsurcharge)
maxsurcharge=surcharge;
}
//printf("count domain names %d\n",count_domain_names);
if(count_domain_names!=0)
return (maxsurcharge+int(log10(count_domain_names)));
else return maxsurcharge;
}

int Surcharge(const int point)
{
if(point == 1)
return 50;
if(point == 2)
return 25;
if(point == RULED_OUT)
return 0;
if(point == SAME)
return -1;
}

int Point(const char *registered,const char *requested)
{
int len1,len2;
len1=strlen(registered);
len2=strlen(requested);
int len_smaller;
int point;
if(abs(len1-len2) >2)
return RULED_OUT;

if(strcmp(registered,requested)==0)
return SAME;

if(len1==len2)
{
// Assume this is even.
point=Point1(registered,requested);
}
else if (abs(len1-len2)==1)
point=Point2(registered,requested);
else  if (abs(len1-len2)==2)
point=Point3(registered,requested);
else point = RULED_OUT;
return point;
}

//same length
int Point1(const char *registered,const char *requested)
{
int len=strlen(registered);
int i,j,point=0;
bool phase=INITIAL_PHASE;
for(i=0;i<len;i++)
{
if(registered[i]!=requested[i])
{
if(abs(pos[registered[i]]-pos[requested[i]])==1)
point++;
else point=point+2;
if(point>2) goto MODE1;
}
}
return point;
// first insert and then delete
MODE1:
i=0;j=0;point=0;phase=INITIAL_PHASE;
while(i!=len || j!=len)
{
if(registered[i]==requested[j])
{
i++;j++;
}
if(registered[i]!=requested[j])
{
if(phase == INITIAL_PHASE)
{
point++;
j++;
phase = PHASE1;
}
else
{
point++;
if(point > 2) goto MODE2;
i++;
}
}
}
return point;

//first delete and then insert
MODE2:
i=0;j=0;point=0;phase=INITIAL_PHASE;
while(i!=len || j!=len)
{
if(registered[i]==requested[j])
{
i++;j++;
}
if(registered[i]!=requested[j])
{
if(phase == INITIAL_PHASE)
{
point++;
i++;
phase = PHASE1;
}
else
{
point++;
if(point > 2) return RULED_OUT;
j++;
}
}
}
return point;

}


//when diff of 2
int Point3(const char *registered,const char *requested)
 {
 /*
cases:
both inserts
first is smaller ; second is larger
no replacement is allowed because that would incur one more point.
*/
int i=0,j=0,point=0;
int len_smaller,len_larger;
int len1=strlen(registered);
int len2=strlen(requested);
const char *first,*second,*temp;
if(len1 < len2)
{first=registered;second=requested ;len_smaller=len1;  
len_larger=len_smaller+2;
}
else
{first=requested;second=registered;len_smaller=len2; 
len_larger=len_smaller+2;
}
while(j<len_larger)
{
if(i==len_smaller)
{
point++;
j++;
if(point > 2)
return RULED_OUT;
}
if(first[i]!=second[j])
{
point++;
j++;
if(point > 2)
return RULED_OUT;
}
else
{
i++;j++;
}
}
return point;
}

//whene diff is 1
// This is a bit tricky
int Point2(const char *registered,const char *requested)
 {
/*
Cases: 1 replacement(adj), 1 insert
only 1 insert
*/
int i=0,j=0,point=0;
bool phase=INITIAL_PHASE;
//only 1 insert
int len_smaller;
int len_larger;
int len1=strlen(registered);
int len2=strlen(requested);
const char *first,*second,*temp;
if(len1 < len2)
{first=registered;second=requested ;len_smaller=len1;  
len_larger=len_smaller+1;
}   
else
{first=requested;second=registered;len_smaller=len2;
len_larger=len_smaller+1;
}   


//if above does not work then
// this has to be one adj replacement and 1 insert
// mode2 = first adj replacement and then insert
//mode1 = first insert and then replacement

//this is in mode 1
while(j<len_larger)
{
if(i==len_smaller)
{
point++;
j++;
if(point > 2)
goto MODE2;;
}
if(first[i]==second[j])
{
i++;j++;
continue;
}
if(first[i]!=second[j])
{
if(phase == INITIAL_PHASE)
{
point++;
j++;
phase = PHASE1;
}
else
{ // phase 1
if(abs(pos[first[i]]-pos[second[j]]) ==1)
{
point++;
i++;j++;
if(point > 2) goto MODE2;
}
else goto MODE2;
 }
  }
   } 
return point; //see do we still want to coninue to MODE2 for better option.

MODE2:
i=0;j=0; // do remaining initializations
// this is in mode2
phase = INITIAL_PHASE;
point=0;
while(j<len_larger)
{
if(first[i]==second[j])
{
i++;j++;
continue;
}
if (phase == INITIAL_PHASE)
{
if(abs(pos[first[i]]-pos[second[j]])!=1)
return RULED_OUT;
else 
{
phase=PHASE1;
i++;j++;
point++;
}
}
else //if(phase == PHASE1)
{
point++;
j++;
if(point > 2)
return RULED_OUT;
}
}
return point;
}

void Print_Map()
{
int i;
for(i='a';i<='z';i++)
printf("%d ",pos[i]);
printf("\n");

for(i='0';i<='9';i++)
printf("%d ",pos[i]);
printf("\n");


}
void Fill_Map()
{
pos['a']=1;pos['s']=2;pos['d']=3;pos['f']=4;pos['g']=5;pos['h']=6;pos['j']=7;pos['k']=8;pos['l']=9;

pos['q']=11;pos['w']=12;pos['e']=13;pos['r']=14;pos['t']=15;pos['y']=16;pos['u']=17;pos['i']=18;pos['o']=19;pos['p']=20;

pos['z']=22;pos['x']=23;pos['c']=24;pos['v']=25;pos['b']=26;pos['n']=27;pos['m']=28;

pos['1']=30;pos['2']=31;pos['3']=32;pos['4']=33;pos['5']=34;pos['6']=35;pos['7']=36;pos['8']=37;pos['9']=38;pos['0']=39;
}

