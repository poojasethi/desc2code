#include <iostream>
#include <cmath>
#include <map>
#include <string>
#include <vector>

using namespace std;

typedef map<string, vector<string* > > PrefixMap;

class Domains {
 public:
  explicit Domains(vector<string*> domains,
		   int prefix_size = 3,
		   int points_threshold = 3);

  // This function is where the point cost
  // gets translated into the dollar cost
  int Cost(const string& name);

 private:
  void UpdatePointCost(const string& name,
		       const int target_size,
		       int& min_point_cost,
		       int& num_neighbours);

  map<int, PrefixMap> domains_;
  int prefix_size_;

  // The threshold at which dollar cost becomes 0
  // ie if point cost equals or exceeds this
  // quantity then dollar cost will be 0
  int points_threshold_;
};

const int min(const int a, const int b, const int c) {
  int min = a;
  if (b < min)
    min = b;

  if (c < min)
    min = c;

  return min;
}

static int qwertymap[26] = {11, 25, 23, 13, 2, 14, 15, 16, 7, 17,
			    18, 19, 27, 26, 8, 9, 0, 3, 12, 4,
			    6, 24, 1, 22, 5, 21};

const bool is_adj(const char ch1, const char ch2) {
  int index1, index2;
  index1 = ((ch1 - '0') <= 9)? (30 + ch1 - '0') : qwertymap[ch1 - 'a'];
  index2 = ((ch2 - '0') <= 9)? (30 + ch2 - '0') : qwertymap[ch2 - 'a'];

  if (((index1 - index2) == 1) ||
      ((index1 - index2) == -1)) {
    return true;
  } else {
    return false;
  }
}

const bool suffix_equal(const string& s1, const string& s2,
			const int index1, const int index2) {
  if ((s1.size() - index1) != (s2.size() - index2))
    return false;

  int i1 = index1;
  int i2 = index2;
  while ((i1 < s1.size()) && (s1[i1] == s2[i2])) {
    ++i1; ++i2;
  }

  if (i1 == s1.size()) {
    return true;
  } else {
    return false;
  }
}

const int sub_cost(const string& s1, const string& s2, int index1, int index2) {
  int i1 = index1, i2 = index2;
  int replace_cost, delete_cost, insert_cost;

  while ((i1 < s1.size()) && (i2 < s2.size()) && (s1[i1] == s2[i2])) {
    ++i1;
    ++i2;
  }

  if (i1 == s1.size())
    return (s2.size() - i2);

  if (i2 == s2.size())
    return (s1.size() - i1);

  // Try replacing
  if ((is_adj(s1[i1], s2[i2])) &&
      (suffix_equal(s1, s2, i1 + 1, i2 + 1))) {
    replace_cost = 1;
  } else {
    replace_cost = 2;
  }

  // Try deleting
  if (suffix_equal(s1, s2, i1 + 1, i2)) {
    delete_cost = 1;
  } else {
    delete_cost = 2;
  }

  // Try inserting
  if (suffix_equal(s1, s2, i1, i2 + 1)) {
    insert_cost = 1;
  } else {
    insert_cost = 2;
  }

  return min(replace_cost, delete_cost, insert_cost);
}

const int PointCost(const string& s1, const string& s2) {
  int replace_cost, delete_cost, insert_cost;
  int size1 = s1.size();

  if (size1 == 0)
    return -2;


  int i = 0;
  while ((i < size1) && (s1[i] == s2[i])) {
    ++i;
  }

  if (i == size1) {
    if (size1 == s2.size()) {
      return -1;
    }

    return (s2.size() - size1);
  }

  // Try replacing
  if (is_adj(s1[i], s2[i])) {
    replace_cost = 1 + sub_cost(s1, s2, i + 1, i + 1);
  } else if (suffix_equal(s1, s2, i + 1, i + 1)) {
    replace_cost = 2;
  } else {
    replace_cost = 3;
  }
    
  // Try deleting
  delete_cost = 1 + sub_cost(s1, s2, i + 1, i);

  // Try inserting
  insert_cost = 1 + sub_cost(s1, s2, i, i + 1);

  return min(replace_cost, delete_cost, insert_cost);
}

Domains::Domains(vector<string*> domains,
		 int prefix_size,
		 int points_threshold) {
  prefix_size_ = prefix_size;
  points_threshold_ = points_threshold;

  string* curr;
  for (int i = 0; i < domains.size(); ++i) {
    curr = domains[i];
    if (curr->size() < prefix_size_) {
      domains_[curr->size()][*curr].push_back(curr);
    } else {
      domains_[curr->size()][curr->substr(0, prefix_size_)].push_back(curr);
    } 
  }
}

bool Disjoint(const string& s1, const string& s2, int maxpos) {
  for (int i = 0; i < maxpos; ++i) {
    for (int j = 0; j < maxpos; ++j) {
      if (s1[i] == s2[j]) {
	return false;
      }
    }
  }

  return true;
}

int max(const int a, const int b) {
  if (a < b)
    return b;
  else
    return a;
}

// Returns the final output value
int Domains::Cost(const string& name) {
  int min_point_cost = points_threshold_, num_neighbours = 0;
  for (int i = max(1, name.size() - 2); i <= name.size() + 2; ++i) {
    UpdatePointCost(name, i, min_point_cost, num_neighbours);
    if (min_point_cost == -1) {
      return -1;
    }
  }

  if (min_point_cost <= 2)
    return (25*(3 - min_point_cost) + floor(log10(num_neighbours)));

  return 0;
}

void Domains::UpdatePointCost(const string& name, const int target_size,
			      int& min_point_cost, int& num_neighbours) {
  const PrefixMap& curr_map = domains_[target_size];

  PrefixMap::const_iterator prefix_it;
  for (prefix_it = curr_map.begin(); prefix_it != curr_map.end(); ++prefix_it) {
    if ( (target_size < prefix_size_) ||
	 (name.size() < prefix_size_) ||
	 (!Disjoint(name, prefix_it->first, prefix_size_))) {
      const vector<string*>& curr_doms = prefix_it->second;
      vector<string*>::const_iterator doms_it;

      for (doms_it = curr_doms.begin(); doms_it != curr_doms.end(); ++doms_it) {
	int cost = PointCost(*(*doms_it), name);
	if (cost == -1) {
	  min_point_cost = -1;
	  return;
	}

	if (cost < points_threshold_)
	  ++num_neighbours;

	if (cost < min_point_cost)
	  min_point_cost = cost;
      }
    }
  }
}

int main() {
  int m, n;
  cin >> m >> n;

  vector<string*> domains(m);
  
  for (int i = 0; i < m; ++i) {
    domains[i] = new string();
    cin >> *domains[i];
  }

  Domains D(domains);

  string candidate;
  for (int i = 0; i < n - 1; ++i) {
    cin >> candidate;
    cout << D.Cost(candidate) << endl;
  }

  cin >> candidate;
  cout << D.Cost(candidate);

  for (int i = 0; i < m; ++i) {
    delete domains[i];
  }

  return 0;
}
