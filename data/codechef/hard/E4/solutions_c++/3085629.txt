//author viper_yash
#include <iostream>
#include <cstdio>
#include <vector>
#include <map>
#include <iterator>
#include <set>
#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstring>
#include <string>
#include <queue>
#include <stack>
#include <list>
#include <sstream>
#include <ctype.h>
#include <utility>
#include <cstdlib>
#include <functional>
#include <numeric>


using namespace std;

#define LL long long
#define linf 998877665544332211ll
#define inf 987654321ll
#define MOD 1000000007ll
#define ADD(v) accumulate(v.begin(),v.end(), 0)
#define PRO(v) accumulate(v.begin(),v.end(), 1,multiplies <int>())
LL POS(LL x) { if (x > 0)  return x; else return 0; }
#define maxe(v) max_element(v.begin(),v.end())
#define mine(v) min_element(v.begin(),v.end())
#define rep(k,a,b) for(int k=(a); k < (b); ++k)
#define per(k,a,b) for(int k=(b-1); k >= (a); --k)

struct ysh {
	long double z, y, x;
	ysh() {}
	ysh(long double z, long double y, long double x) : z(z), y(y), x(x) {}
	ysh operator + (const ysh &p) const { return ysh(z + p.z, y + p.y, x + p.x); }
	ysh operator - (const ysh &p)  const { return ysh(z - p.z, y - p.y, x - p.x); }
	ysh operator * (long double con)     const { return ysh(z*con, y*con, x*con); }
	ysh operator / (long double con)     const { return ysh(z / con, y / con, x / con); }
	bool operator<(const ysh &rhs) const { return make_pair(z, make_pair(y, x)) < make_pair(rhs.z, make_pair(rhs.y, rhs.x)); }
	bool operator==(const ysh &rhs) const { return make_pair(z, make_pair(y, x)) == make_pair(rhs.z, make_pair(rhs.y, rhs.x)); }
};


//power function
long long  power(long long x, long long y, long long md){
	long long  temp;
	if (y == 0)
		return 1;
	temp = power(x, y / 2, md) % md;
	if (y % 2 == 0)
		return ((temp % md)*(temp% md)) % md;
	else
		return (((((x%md)*(temp%md)) % md)*(temp%md)) % md) % md;
}

/* Returns the legendre symbol (a|p):
1 is a is a quardratic residue of p, -1 if it is not.
We assert that Gcd(a,p) == 1, and that p is an odd prime.
*/
long long legendre(long long a, long long p) {
	// assert(is_prime(p) && a%p != 0);
	long long r = power(a, (p - 1) >> 1, p);
	assert(r == 1 || r == p - 1);
	return r == 1 ? 1 : -1;
}
/* returns an x < p such that x^2 == n (mod p), p is odd prime.
Returns 0 if n is not a quardratic res.
If p is of form 4k+3, just returns n^((p+1)/4) (mod p).
Else If p is of the form 4k+1, uses the Shanks-Tonelli algorithm alg. to find one.
The other residue will of course be p-x.
*/
long long residuesolve(long long n, long long p) {
	assert(n%p != 0 && n < p);
	if (legendre(n, p) == -1) return 0;
	else if (p % 4 == 3) return power(n, (p + 1) >> 2, p);

	long long q, r, s, w, v, i, j, t, jj;
	long long y, b;
	/* p-1 = q*2^s, odd q */
	for (s = 0, q = p - 1; !(q & 1); ++s, q >>= 1)
		;
	/* Pick w such that Legendre(w, p) == -1 */
	for (w = 2; legendre(w, p) == 1; ++w)
		;
	v = power(w, q, p);
	r = power(n, (q + 1) >> 1, p);
	t = power(n, q, p);/* We maintain t = r^2*n^(-1) */
	while (true) {
		// printf("p=%u n=%u w=%u q=%u s=%u r=%u t=%u\n",p,n,w,q,s,r,t);
		/* y = t^{2^i} */
		for (i = 0, y = t; y != 1; ++i)
			y = (y*y) % p;
		if (i == 0) break;
		/* b = v^{2^{s-i-1}} */
		for (b = v, j = 0, jj = s - i - 1; j < jj; ++j)
			b = (b*b) % p;
		/* New r' = r*b, new t = t*b^2 */
		r = (r*b) % p;
		b = (b*b) % p, t = (t*b) % p;
		/* We've reestablished t = r^2*n^(-1) */
	}
	assert(power(r, 2, p) == n);
	return r;
}
long long extended_euclid(long long a, long long b, long long &x, long long &y) {
	long long xx = y = 0;
	long long yy = x = 1;
	while (b) {
		long long q = a / b;
		long long t = b; b = a%b; a = t;
		t = xx; xx = x - q*xx; x = t;
		t = yy; yy = y - q*yy; y = t;
	}
	return a;
}
// Returns b such that a*b = 1 (mod p)
long long mod_inverse(long long a, long long p) {
	long long x, y;
	long long q = extended_euclid(a, p, x, y);
	long long r = (x + p) % p;
	return r;
}

int main() {
	LL n, m, l;
	int t;
	cin >> t;
	while (t--){
		LL a, c, b, p;
		cin >> a >> b >> c >> p;
		long long x1, x2;
		//quadratic equation is	aw*w+b*w+c
		LL temp = ((b*b) % p - (4 * a*c) % p + p + p) % p;
		//cout << temp << endl;
		int no_of_solutions=0;
		vector<long long> solutions;
		if (c == 0){
			//no_of_solutions++;
			solutions.push_back(0);
		}
		if (p == 2) {
			if ((a + b + c) % 2 == 0) { // 1 is a solution
				solutions.push_back(1);
			}
		}
		else if (temp%p == 0){
			x1 = ((p - b)*mod_inverse(2 * a, p)) % p;
			//cout << 1 << " " << x1 << endl;
			if (x1 != 0)
				solutions.push_back(x1);
		}
		else {
			int qresidue = legendre(temp, p);
			//cout << qresidue << endl;
			if (qresidue == -1){
				//cout << "0 solutions " << endl;
				//continue;
			}
			else if (qresidue == 1){
				long long y1 = residuesolve(temp, p);
				long long y2 = p - y1;
				x1 = ((y1 + p - b)* mod_inverse(2 * a, p)) % p;
				x2 = ((y2 + p - b)* mod_inverse(2 * a, p)) % p;
				//cout << "2 " << x1 << " " << x2 << endl;
				if (x1 != 0)
					solutions.push_back(x1);
				if (x2 != 0)
					solutions.push_back(x2);
			}
		}
		int l = solutions.size();
		sort(solutions.begin(), solutions.end());
		cout << l << " ";
		rep(i, 0, l){
			cout << solutions[i] << " ";
		}
		cout << endl;
	}
	return 0;
}