#include<bits/stdc++.h>
using namespace std;
#define ll long long
 
int tree[50000 * 5 + 1];
ll last_time[50003]={0},last_distance[50003]={0},last_speed[50003]={0},leaf_number[50003];
 
void build(int p,int l,int r)
{
    if(l>r) return;
    if(l==r) {tree[p]=l;leaf_number[l]=p;return;}
    int mid=(l+r)/2;
    build(p*2,l,mid);
    build(p*2+1,mid+1,r);
    tree[p]=tree[p*2];
}
 
class event
{
public:
    ll time,node,challenger;
    event(ll _time,ll _node,ll _challenger)
    {
        time=_time;
        node=_node;
        challenger=_challenger;
    }
    void perform();
};
 
class compareEventByTime
{
public:
    bool operator () (const event &a, const event &b) {return a.time > b.time;}
};
 
priority_queue< event, vector<event> , compareEventByTime > Q;
 
void event::perform()
{
    //cout<<challenger<<" challenging "<<tree[node]<<" "<<last_distance[23]<<endl;
    int opponent = tree[node];
    last_distance[challenger] += (time - last_time[challenger]) * last_speed[challenger];
    last_time[challenger]=time;
    last_distance[opponent] += (time - last_time[opponent]) * last_speed[opponent];
    last_time[opponent]=time;
    if(last_distance[challenger] >= last_distance[opponent])
    {
        tree[node] = challenger;
        if(node == 1) return;
        opponent = tree[node/2];
        last_distance[opponent] += (time - last_time[opponent]) * last_speed[opponent];
        last_time[opponent] = time;
        if(last_speed[challenger] > last_speed[opponent])
        {
            ll numerator=time * (last_speed[challenger] - last_speed[opponent]) + last_distance[opponent] - last_distance[challenger];
            ll denominator = (last_speed[challenger] - last_speed[opponent]);
            ll newtime = numerator / denominator;
            while((last_distance[challenger]+(newtime-time)*last_speed[challenger]) < (last_distance[opponent]+(newtime-time)*last_speed[opponent])) newtime++;
            event e(newtime,node/2,challenger);
            Q.push(e);
        }
    }
    else if(last_speed[challenger] > last_speed[opponent])
    {
        ll numerator=time * (last_speed[challenger] - last_speed[opponent]) + last_distance[opponent] - last_distance[challenger];
        ll denominator = (last_speed[challenger] - last_speed[opponent]);
        ll newtime = numerator / denominator;
        while((last_distance[challenger]+(newtime-time)*last_speed[challenger]) < (last_distance[opponent]+(newtime-time)*last_speed[opponent])) newtime++;
        event e(newtime,node,challenger);
        Q.push(e);
    }
}
 
void query1()
{
    //input
    ll time,cyclist,newspeed;
    cin>>time>>cyclist>>newspeed;
 
    //flush the event queue !!!
    while(!Q.empty() && Q.top().time <= time)
    {
        event e=Q.top();
        e.perform();
        Q.pop();
    }
 
    int node=leaf_number[cyclist];
    while(tree[node]==cyclist && node!=1) node/=2;
    if(tree[node]==cyclist)
    {
        last_distance[cyclist] += (time-last_time[cyclist]) * last_speed[cyclist];
        last_time[cyclist]=time;
        last_speed[cyclist]=newspeed;
        return;
    }
    int opponent = tree[node];
    last_distance[cyclist] += (time-last_time[cyclist]) * last_speed[cyclist];
    last_time[cyclist]=time;
    last_speed[cyclist]=newspeed;
    last_distance[opponent] += (time-last_time[opponent]) * last_speed[opponent];
    last_time[opponent]=time;
    int challenger = cyclist;
    if(last_speed[challenger] > last_speed[opponent])
    {
        ll numerator=time * (last_speed[challenger] - last_speed[opponent]) + last_distance[opponent] - last_distance[challenger];
        ll denominator = (last_speed[challenger] - last_speed[opponent]);
        ll newtime = numerator / denominator;
        while((last_distance[challenger]+(newtime-time)*last_speed[challenger]) < (last_distance[opponent]+(newtime-time)*last_speed[opponent])) newtime++;
        event e(newtime,node,challenger);
        Q.push(e);
    }
}
 
void query2()
{
    ll time;
    cin>>time;
 
    //flushing
    while(!Q.empty() && Q.top().time <= time)
    {
        event e=Q.top();
        e.perform();
        Q.pop();
    }
 
    int winner = tree[1];
    last_distance[winner] += (time - last_time[winner]) * last_speed[winner];
    last_time[winner] = time;
    cout<<last_distance[winner]<<endl;
}
 
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
  // freopen("input.c","r",stdin);
 
   // freopen("1.out.c","w",stdout);
    int n,q;
    cin>>n>>q;
    build(1,1,n);
    while(q--)
    {
        int type;
        cin>>type;
        if(type==1) query1();
        else query2();
    }
}
 