
#include<bits/stdc++.h>
using namespace std;
#define D(x)        cout<<#x " = "<<(x)<<endl
#define un(x)       x.erase(unique(x.begin(),x.end()), x.end())
#define sf(n)       scanf("%d", &n)
#define sff(a,b)    scanf("%d %d", &a, &b)
#define sfff(a,b,c) scanf("%d %d %d", &a, &b, &c)
#define pb          push_back
#define mp          make_pair
#define xx          first
#define yy          second
#define hp          (LL) 999983
#define MAX         100000
#define eps         1e-9
typedef long long int LL;

struct racer{
    LL x, y, v;

    racer(LL _x = 0, LL _y = 0, LL _v = 0):x(_x), y(_y), v(_v){}
};

bool meetPoint(racer r1, racer r2, LL &retx)
{
    assert(r1.v <= r2.v);

    if(r1.x > r2.x)
    {
        r2.y += r2.v * (r1.x - r2.x);
        r2.x = r1.x;
    }
    else
    {
        r1.y += r1.v * (r2.x - r1.x);
        r1.x = r2.x;
    }

    if(r1.y < r2.y) return false;
    if(r1.y == r2.y)
    {
        retx = r1.x;
        return true;
    }
    else
    {
        LL dpos = r1.y - r2.y;
        LL dv = r2.v - r1.v;
        assert(dpos <= 1000000000000000000LL);
        assert(r1.x <= 1000000000000000000LL);

        retx = r1.x + dpos/dv;
        if(dpos % dv) retx++;

        return true;
    }
}

bool cmp(racer r1, racer r2)
{
    if(r1.v == r2.v)
    {
        if(r1.x > r2.x)
        {
            r2.y += r2.v * (r1.x - r2.x);
            r2.x = r1.x;
        }
        else
        {
            r1.y += r1.v * (r2.x - r1.x);
            r1.x = r2.x;
        }

        if(r1.y > r2.y) return true;
        return false;
    }

    return (r1.v > r2.v);
}

struct convexHullTrick{
    vector<racer> stk;

    convexHullTrick(vector<racer> &R){
        racer u, v, pre;
        LL pos, pp;
        int i;

        sort(R.begin(), R.end(), cmp);

        stk.push_back(R[0]);
        i = 1;
        while(i < R.size())
        {
            if(stk.size() == 1){
                if(meetPoint(R[i], stk.back(), pos)  ) stk.push_back(R[i]);
            }

            else
            {
                pre = stk[(int) stk.size() - 2];
                v = stk.back();
                u = R[i];

                if(!meetPoint(u, v, pos));
                else
                {
                    assert(meetPoint(v, pre, pp));
                    if(pos >= pp){
                        stk.pop_back();
                        continue;
                    }
                    else stk.push_back(R[i]);
                }
            }
            i++;
        }

        reverse(stk.begin(), stk.end());
    }

    void printStack()
    {
        int i;
        for(i = 0; i < stk.size(); i++)
            printf("%lld %lld %lld\n", stk[i].x, stk[i].y, stk[i].v);
    }

    void processQuery(vector<int> &qry)
    {
        racer cur;
        int i = 0, j = 0;
        LL pos;

        while(i < qry.size())
        {
            if(j + 1 == stk.size())
            {
                cur = stk[j];
                cur.y += (qry[i] - cur.x) * cur.v;
                printf("%lld\n", cur.y);

                i++;
            }
            else
            {
                meetPoint(stk[j], stk[j+1], pos);
                if(pos <= qry[i]) j++;
                else
                {
                    cur = stk[j];
                    cur.y += (qry[i] - cur.x) * cur.v;
                    printf("%lld\n", cur.y);

                    i++;
                }
            }
        }
    }
};

vector<racer> vR;
vector<int> vI;

racer sq[MAX+11];

int main()
{
    //freopen("c:\\Users\\User\\Desktop\\in.txt", "r", stdin);
    //freopen("c:\\Users\\User\\Desktop\\out.txt", "w", stdout);


    int i, j, k, n, q;
    int tp, v;
    int nt, id, spd;

    sff(n, q);
    vR.push_back(sq[0]);

    while(q--)
    {
        sf(tp);
        if(tp == 1)
        {
            sfff(nt, id, spd);
            sq[id].y += (nt - sq[id].x) * sq[id].v;
            sq[id].x = nt;
            sq[id].v = spd;

            vR.push_back(sq[id]);
        }
        else
        {
            sf(v);
            vI.pb(v);
        }
    }

    convexHullTrick cht = convexHullTrick(vR);
    //cht.printStack();
    cht.processQuery(vI);
    return 0;
}
