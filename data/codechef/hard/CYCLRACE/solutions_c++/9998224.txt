
#include<bits/stdc++.h>
using namespace std;
#define D(x)        cout<<#x " = "<<(x)<<endl
#define un(x)       x.erase(unique(x.begin(),x.end()), x.end())
#define sf(n)       scanf("%d", &n)
#define sff(a,b)    scanf("%d %d", &a, &b)
#define sfff(a,b,c) scanf("%d %d %d", &a, &b, &c)
#define pb          push_back
#define mp          make_pair
#define xx          first
#define yy          second
#define hp          (LL) 999983
#define MAX         100000
#define eps         1e-9
typedef long long int LL;

struct racer{
    LL x, y, v;

    racer(LL _x = 0, LL _y = 0, LL _v = 0):x(_x), y(_y), v(_v){}
};

bool meetPoint(racer r1, racer r2, LL &retx)
{
    assert(r1.v <= r2.v);

    if(r1.x > r2.x)
    {
        r2.y += r2.v * (r1.x - r2.x);
        r2.x = r1.x;
    }
    else
    {
        r1.y += r1.v * (r2.x - r1.x);
        r1.x = r2.x;
    }

    if(r1.y < r2.y) return false;
    if(r1.y == r2.y)
    {
        retx = r1.x;
        return true;
    }
    else
    {
        LL dpos = r1.y - r2.y;
        LL dv = r2.v - r1.v;
        assert(dpos <= 1000000000000000000LL);
        assert(r1.x <= 1000000000000000000LL);

        retx = r1.x + dpos/dv;
        if(dpos % dv) retx++;

        return true;
    }
}

bool cmp(racer r1, racer r2)
{
    if(r1.v == r2.v)
    {
        if(r1.x > r2.x)
        {
            r2.y += r2.v * (r1.x - r2.x);
            r2.x = r1.x;
        }
        else
        {
            r1.y += r1.v * (r2.x - r1.x);
            r1.x = r2.x;
        }

        if(r1.y > r2.y) return true;
        return false;
    }

    return (r1.v > r2.v);
}

struct convexHullTrick{
    vector<racer> stk;

    convexHullTrick(vector<racer> &R){
        racer u, v, pre;
        LL pos, pp;
        int i;

        sort(R.begin(), R.end(), cmp);

        stk.push_back(R[0]);
        i = 1;
        while(i < R.size())
        {
            if(stk.size() == 1){
                if(meetPoint(R[i], stk.back(), pos)  ) stk.push_back(R[i]);
            }

            else
            {
                pre = stk[(int) stk.size() - 2];
                v = stk.back();
                u = R[i];

                if(!meetPoint(u, v, pos));
                else
                {
                    assert(meetPoint(v, pre, pp));
                    if(pos >= pp){
                        stk.pop_back();
                        continue;
                    }
                    else stk.push_back(R[i]);
                }
            }
            i++;
        }

        //reverse(stk.begin(), stk.end());
    }

    void printStack()
    {
        int i;
        for(i = 0; i < stk.size(); i++)
            printf("%lld %lld %lld\n", stk[i].x, stk[i].y, stk[i].v);
    }

    struct Line{
        LL m,c;
        Line(LL _m = 0, LL _c = 0):m(_m), c(_c){};
    };


    LL getX(racer r1, racer r2){ // Fast vrs Slow

        Line u = Line(r1.v, r1.y-r1.x*r1.v);
        Line v = Line(r2.v, r2.y-r2.x*r2.v);

        LL difC = v.c - u.c, difM = u.m - v.m, ret = difC/difM;
        return (difC % difM) ? ret+1:ret;
    }

    LL query(LL pos){
        int lo = 0, hi = (int) stk.size() - 1, n = hi, mid;
        LL L, R;

        while(true)
        {
            mid = (lo+hi)/2;
            if(mid == n) L = -5e18;
            else L = getX(stk[mid], stk[mid+1]);

            if(mid == 0) R = 5e18;
            else R = getX(stk[mid-1], stk[mid]);

            if(L <= pos && pos <= R)
            {
                racer r1 = stk[mid];
                Line u = Line(r1.v, r1.y-r1.x*r1.v);

                return u.m * pos + u.c;
            }
            if(pos < L) lo = mid+1;
            else hi = mid;
        }
    }
};

vector<racer> vR;
vector<int> vI;

racer sq[MAX+11];

int main()
{
    //freopen("c:\\Users\\User\\Desktop\\in.txt", "r", stdin);
    //freopen("c:\\Users\\User\\Desktop\\out.txt", "w", stdout);


    int i, j, k, n, q;
    int tp, v;
    int nt, id, spd;

    sff(n, q);
    vR.push_back(sq[0]);

    while(q--)
    {
        sf(tp);
        if(tp == 1)
        {
            sfff(nt, id, spd);
            sq[id].y += (nt - sq[id].x) * sq[id].v;
            sq[id].x = nt;
            sq[id].v = spd;

            vR.push_back(sq[id]);
        }
        else
        {
            sf(v);
            vI.pb(v);
        }
    }

    convexHullTrick cht = convexHullTrick(vR);
    //cht.printStack();
    //cht.processQuery(vI);
    for(i = 0; i < vI.size(); i++)
        printf("%lld\n", cht.query(vI[i]));
    return 0;
}
