#include<bits/stdc++.h>
using namespace std;
#define D(x)        cout<<#x " = "<<(x)<<endl
#define un(x)       x.erase(unique(x.begin(),x.end()), x.end())
#define sf(n)       scanf("%d", &n)
#define sff(a,b)    scanf("%d %d", &a, &b)
#define sfff(a,b,c) scanf("%d %d %d", &a, &b, &c)
#define pb          push_back
#define mp          make_pair
#define xx          first
#define yy          second
#define hp          (LL) 999983
#define MAX         100000
typedef long long int LL;
typedef pair<int,int> pii;

struct Line{
        LL m,c;
        Line(LL _m = 0, LL _c = 0):m(_m), c(_c){};
};

struct ConvexHullTrick{ //works with long long integers.

    vector<Line> Q; //Fast -> Slow -> Slower -> Slowest
    bool minFlag;

    ConvexHullTrick(bool flg = false):minFlag(flg){};

    LL getX(Line u, Line v){ // Fast vrs Slow *ORDER MATTERS*
        LL difC = v.c - u.c, difM = u.m - v.m, ret = difC/difM;
        return (difC % difM) ? ret+1:ret;
    }

    bool isBad(Line L1, Line L2, Line L3)
    {
        if(minFlag == false) return (L3.c - L1.c) / (long double) (L1.m - L3.m) > (L2.c-L1.c) / (long double) (L1.m - L2.m);
        else return (L3.c - L1.c) / (long double) (L1.m - L3.m) < (L2.c-L1.c) / (long double) (L1.m - L2.m);
    }

    void addLine(Line L){ //Has to be slower than then the slowest in the Q
        while(Q.empty() == false)
        {
            if(Q.back().m < L.m) __builtin_trap();
            else if(Q.back().m == L.m && L.c > Q.back().c) Q.pop_back();
            else if(Q.back().m == L.m) return;
            else if(Q.size() <= 1) break;
            else if(isBad(Q[Q.size()-2], Q.back(), L)) Q.pop_back();
            else break;
        }
        Q.push_back(L);
    }

    LL query(LL pos){
        int lo = 0, hi = (int) Q.size() - 1, n = hi, mid;
        LL L, R;

        while(true)
        {
            mid = (lo+hi)/2;
            if(minFlag)
            {
                if(mid == 0) L = -5e18;
                else L = getX(Q[mid-1], Q[mid]);

                if(mid == n) R = 5e18;
                else R = getX(Q[mid], Q[mid+1]);

                if(L <= pos && pos < R) return Q[mid].m * pos + Q[mid].c;
                if(pos < L) hi = mid-1;
                else lo = mid+1;
            }

            else
            {
                if(mid == n) L = -5e18;
                else L = getX(Q[mid], Q[mid+1]);

                if(mid == 0) R = 5e18;
                else R = getX(Q[mid-1], Q[mid]);

                if(L <= pos && pos < R) return Q[mid].m * pos + Q[mid].c;
                if(pos < L) lo = mid+1;
                else hi = mid-1;
            }

        }
    }
};

vector<int> timeQuery;
vector<Line> sq;

LL when[MAX+11];
LL spd[MAX+11];
LL H[MAX+11];

bool cmp(Line u, Line v)
{
    if(u.m == v.m)
        return u.c > v.c;

    return u.m > v.m;
}

int main()
{
    //freopen("c:\\Users\\User\\Desktop\\in.txt", "r", stdin);
    //freopen("c:\\Users\\User\\Desktop\\out.txt", "w", stdout);

    int i, j, k, n, q, v;
    int tp;
    int _tm, cyc, nspd;
    LL curPos;
    sq.pb(Line());

    sff(n, q);
    for(i = 1; i <= q; i++)
    {
        sf(tp);
        if(tp == 1)
        {
            sfff(_tm, cyc, nspd);
            H[cyc] += (_tm - when[cyc]) * spd[cyc];
            spd[cyc] = nspd;
            when[cyc] = _tm;

            curPos = H[cyc] - (LL)_tm * nspd;
            sq.pb(Line(nspd, curPos));
        }

        else
        {
            sf(v);
            timeQuery.pb(v);
        }
    }

    sort(sq.begin(), sq.end(), cmp);

    ConvexHullTrick hull;
    for(i = 0; i < sq.size(); i++)
        hull.addLine(sq[i]);

    for(i = 0; i < timeQuery.size(); i++)
        printf("%lld\n", hull.query(timeQuery[i]));

    return 0;
}
