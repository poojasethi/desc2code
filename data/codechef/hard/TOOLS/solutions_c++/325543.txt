#include <cstdio>
#include <cstdlib>
#include <cstring>

#define rep(i, n) for(int i = 0, __n = (n); i < __n; ++i)
#define clr(a, v) memset(a, v, sizeof(a))
#define mineq(a, b) a = a < b ? a : b

const int max_n = 8;

unsigned dp[1 << max_n][1 << max_n][max_n << 1], ones[1 << max_n];
int x[max_n << 1], y[max_n << 1];

void doit(){
    int n; scanf("%d", &n); 
    unsigned end = 1<<n;
    rep(i, n) scanf("%d%d%d%d", x+n+i, y+n+i, x+i, y+i);
    
    clr(dp, 0xef);
    rep(t, n) dp[1<<t][0][t] = x[t] + y[t];
    for(unsigned t = 0; t < end; ++t)
    for(unsigned c = 0; c < end; ++c)
    if((t&c) == c){
        int h = ones[t] - ones[c];
        if(h <= 2)
        rep(p, n<<1)
        if(dp[t][c][p] != 0xefefefef){
            unsigned cs = t^c, not_t = ~t;
            switch(h){
                case 1:
                    rep(nc, n) if( (1<<nc) & cs )
                    mineq(dp[t][c|(1<<nc)][n+nc], dp[t][c][p] + abs(x[p] - x[n+nc]) + abs(y[p] - y[n+nc]));
                    // go to a cook, and a tool
                case 0:
                    // get a tool
                    rep(nt, n) if( (1<<nt) & not_t )
                    mineq(dp[t|(1<<nt)][c][nt], dp[t][c][p] + abs(x[p] - x[nt]) + abs(y[p] - y[nt]));
                    break;
                case 2:
                    // go to the cook
                    rep(nc, n) if( (1<<nc) & cs )
                    mineq(dp[t][c|(1<<nc)][n + nc], dp[t][c][p] + abs(x[p] - x[n+nc]) + abs(y[p] - y[n+nc])); 
            }
        }
    }
    
    unsigned ans = 0xefefefef;
    rep(p, n<<1) mineq(ans, dp[end-1][end-1][p] + x[p] + y[p]);
    printf("%u\n", ans);
}

int main(){
    for(unsigned v = 1, n = (1<<max_n); v < n; ++v) ones[v] = 1 + ones[v - (v&(-v))];
    
    int t; scanf("%d", &t);
    while(t--) doit();
    return 0;
}
