#include<iostream>
#include<map>
#include<vector>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdio>
#include<fstream>
using namespace std;//miller rabin primality 7 set for 64 bit int {2, 325, 9375, 28178, 450775, 9780504, 1795265022}
#define abs(x) ((x)>0?(x):-(x))
#define M 1000000007
#define lld signed long long int
#define pp pop_back()
#define ps(x) push_back(x)
#define tkint(n) scanf("%d",&n)
#define tkchar(ch) scanf("%c",&ch)
#define tklong(n) scanf("%I64d",&n)
lld dp[1<<17][18];
lld dist[18][18];
int x[18],y[18],n;
void init()
{
	for(int i=0;i<=(1<<n);++i)
		for(int j=0;j<=n;++j)dp[i][j]=M;
}
int check(lld x)
{
	int ret=0;
	for(int i=2;i<n;i+=2)
	{
		if(((x&(1<<(i-1)))!=0)/*tool present*/ &&((x&(1<<(i)))==0)/*yet not delivered to the chef*/)++ret;
		if(((x&(1<<(i-1)))==0)&&((x&(1<<(i)))!=0))return 0;//delivered but chef not in path
	}
	if(ret<=2)return 1;
	return 0;

}
int main()
{
	n=16;
	int t;
	cin>>t;
	while(t--)
	{
		cin>>n;
		n=2*n+1;
		x[0]=y[0]=0;
		for(int i=1;i<n;i+=2)
		{
			cin>>x[i+1]>>y[i+1]>>x[i]>>y[i];
		}
		for(int i=0;i<n;++i)
		{
			for(int j=0;j<n;++j)
			{
				dist[i][j]=abs(x[i]-x[j])+abs(y[i]-y[j]);
			}
		}
		init();
		dp[1][0]=0;//assuming every hamiltonian walk begins from vertex 0,0
		for(lld mask=1;mask<(1<<n);++mask)
		{
			//mask is not allowed to carry more than two tools
			//any mask must contain the vertex zero
			//chef must not be prsent if tool is not there
			if(check(mask) && (mask&1));
				else continue;
			for(int i=1;i<n;++i)
			{//end of walk must not be on 0,,,therefore i=1 in beginning

				if(mask&(1<<i))
				{
					for(int j=0;j<n;++j)
					{
						if(mask&(1<<j) && j!=i)dp[mask][i]=min(dp[mask][i],dp[mask-(1<<i)][j]+dist[i][j]);
					}
				}
			}
		}
		lld ans=M;
		for(int i=1;i<n;++i)
		{
			ans=min(ans,dp[(1<<n)-1][i]+dist[i][0]);
		}
		cout<<ans<<endl;
	}
}
