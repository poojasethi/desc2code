//#include "programming_contests.h"







#ifndef PROGRAMMING_CONTESTS_H
#define PROGRAMMING_CONTESTS_H
#include <algorithm>
#include <bitset>
#include <cctype>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <string>
#include <typeinfo>
#include <utility>
#include <vector>
using namespace std;
#ifdef LOCAL
static FILE* _freopen = freopen("input.txt", "r", stdin);
#else
#define NDEBUG
#endif
#include <cassert>








typedef long long LL;

#define RI(x) {int _res=scanf("%i", &(x)); assert(_res);}
#define RLL(x) {int _res=scanf("%lli", &(x)); assert(_res);}
#define RS(x) {char _buf[2000]; int _res=scanf("%s", _buf); assert(_res); x = string(_buf);}
#define RL(x) getline(cin, x) //Consumes and discards line break at end of line.
#define FOUT(path) freopen(path, "w", stdout)

#define FOR(i, a, b) for(int i=(a), _b=(b); i<_b; ++i)
#define FORR(i, a, b) for(int i=(b-1), _a=(a); i>=_a; --i)
#define IT(c) typeof(c.begin())
#define FORE(it, c) for(IT(c) it=c.begin(); it!=c.end(); ++it)
#define ALL(x) x.begin(), x.end()

#define PB push_back
#define MP make_pair
#define SZ(c) ((int)c.size())
#define LEN(a) (sizeof(a)/sizeof(a[0]))
#define END(a) (a+LEN(a))

#define TWO(e) (1<<e)
#define TWOL(e) (1LL<<e)


static const double PI = acos(-1.0);
static const double GOLD = (1+sqrt(5.0))/2;














template<typename T> inline T sqr(const T& x){return x*x;}
template<typename T> inline double eucDist(const T& x0, const T& y0, const T& x1, const T& y1){return sqrt(sqr(x0-x1)+sqr(y0-y1));}
template<typename T> inline T manDist(const T& x0, const T& y0, const T& x1, const T& y1){return abs(x0-x1)+abs(y0-y1);}


// Requires that type of v is the type that a contains.
template <typename A, typename V>
static void fillArray(A &a, const V &v) {
  fill((V*)a, (V*)a+sizeof(a)/sizeof(V), v);
}

// Returns true iff a is less than b according to a pairwise element comparison.
template<typename T, size_t N>
static bool aLT(T (&a)[N], T (&b)[N]) {
  for(int i=0;i<N;++i) {
    if(a[i]<b[i]) return true;
    if(a[i]>b[i]) return false;
  }
  return false;
}

// Pieces which are the empty string are dropped.
static void split(const string &s, vector<string> &pieces, const string &delim = " ") {
  unsigned int nextI = 0;
    for(unsigned int cutAt = s.find(delim,nextI); cutAt != s.npos; cutAt = s.find(delim,nextI)) {
         if(cutAt > nextI) pieces.push_back(s.substr(nextI,cutAt-nextI));
         nextI = cutAt+delim.length();
    }
    if(nextI < s.length()) {
         pieces.push_back(s.substr(nextI));
  }
}

static string toLower(const string& s) {
  string t = s;
  transform(s.begin(), s.end(), t.begin(), (int (*)(int))tolower);
  return t;
}
static string toUpper(const string& s) {
  string t = s;
  transform(s.begin(), s.end(), t.begin(), (int (*)(int))toupper);  
  return t;
}



static bool isLetter(const char& c) {
  char d = tolower(c);
  return d >= 'a' && d <= 'z';
}
static bool isVowel(const char& c) {
  char d = tolower(c);
  return d=='a'||d=='e'||d=='i'||d=='o'||d=='u'||d=='y';
}
static bool isConsonant(const char& c) {
  return isLetter(c) && !isVowel(c);
}






























// Stuff for debugging.

static void sleep(const int ms) {
    clock_t goal = ms + clock();
    while (goal > clock());
}

template<typename T>
static void print(T x) {
  cerr << x << endl;
}

template<typename T>
static void print(T first, const T &last) {
  while(first != last) cerr << *(first++) << " ";
  cerr << endl;
}

template<typename T, size_t LENGTH>
static void print(const T (&a)[LENGTH]) {
  print(a,a+LENGTH);
}

template<typename T, size_t LENGTH0, size_t LENGTH1>
static void print(const T (&a)[LENGTH0][LENGTH1]) {
  for(int i = 0; i < LENGTH0; ++i) {
    print(a[i]);
  }
}

static double timer() {
  return 1.0*clock()/CLOCKS_PER_SEC;
}

#endif // PROGRAMMING_CONTESTS_H










int n;
int cx[10];
int cy[10];
int tx[10];
int ty[10];













// Efficient representation of an array in which index i
// can be assigned values 0,...,2^baB[i]-1. Thus baB[i]
// is the number of bits to represent index i.
//MODIFY///////////////////////////////////////////////////////
typedef int baT; static const size_t baLen = 8*sizeof(baT);
static const int baB[baLen] = {5,4,1,1,1,1,1,1,1,1};
///////////////////////////////////////////////////////////////
static baT baP[baLen] = {0}; // index i is 2^baB[i]-1
static int baS[baLen] = {0}; // index i is starting bit of ith value
static baT baMax = 0;

// Sets value of index i to v.
static inline void baSet(baT& s, const int& i, const baT& v) {
  assert(v >= 0 && v <= baP[i]);
  s &= (~(baP[i] << baS[i])); // Set bits for ith value to 0.
  s |= (v << baS[i]); // Set bits for ith value to v.
}

// RETURNS: Value of index i.
static inline baT baGet(const baT& s, const int& i) {
    return (s >> baS[i]) & baP[i];
}

static baT baMake(const baT& a = 0, const baT& b = 0, const baT& c = 0, const baT& d = 0) {
  baT res = 0;
  baSet(res,0,a); baSet(res,1,b); baSet(res,2,c); baSet(res,3,d);
  return res;
}

// Swap values of indices i and j.
static void baSwap(baT& s, const int& i, const int& j) {
  baT temp = baGet(s,i);
  baSet(s,i,baGet(s,j));
  baSet(s,j,temp);
}

static void baPrint(const baT& s) {
  cout << "(";
  int i = 0;
  while(true) {
    cout << baGet(s,i++);
    if(i == baLen || baB[i] == 0) break;
    cout << ",";
  }
  cout << ")" << endl;
}

static int _baInit() {
  int bits = 0;
  for(int i = 0; i < baLen; ++i) {
    bits += baB[i];
    baP[i] = (((baT)1)<<baB[i])-1;
    if(i+1<baLen) baS[i+1] = baS[i]+baB[i];
    baSet(baMax,i,baP[i]);
  }
  assert(bits <= baLen);
  return 0;
} static int __baInit = _baInit();






typedef baT State;
const State NONE = numeric_limits<State>::min();
typedef int Cost;
const Cost INF = 1000000000;

Cost* costsFromStart = new Cost[baMax+1]; //map<State,Cost> costsFromStart;
bool* seen = new bool[baMax+1];
//State* prev = new State[baMax+1]; //map<State,State> prev;
//vector<State> path;


State goal = 0;
inline bool isGoal(const State &s) {
  if(goal == 0) FOR(i,2,2+n) baSet(goal,i,1);
  return s == goal;
}



const int MAX_SUCCS = 100;
State succs[MAX_SUCCS+1] = {NONE};
Cost costs[MAX_SUCCS+1];
#define addSucc(s,c) succs[i] = s; costs[i] = c; ++i
inline void getSuccs(const State& curr) {
  int i = 0;
  int loc = baGet(curr,0);
  int x = (loc == 0 ? 0 : (loc > 8 ? tx[loc-8] : cx[loc]));
  int y = (loc == 0 ? 0 : (loc > 8 ? ty[loc-8] : cy[loc]));
  int tool = baGet(curr,1);

  //go back to start
  {
    State succ = curr;
    baSet(succ,0,0);
    addSucc(succ,manDist(x,y,0,0));
  }
  
  if(tool==0) { //holding nothing, must pick up a tool
    FOR(t,1,n+1) {
      if(!baGet(curr,1+t)) {
        State succ = curr;
        baSet(succ,0,8+t);        
        baSet(succ,1,t);
        addSucc(succ,manDist(x,y,tx[t],ty[t]));
      } 
    }
  }
  else { //holding 1 tool
    // deliver it
    State succ = curr;
    baSet(succ,0,tool);
    baSet(succ,1,0);
    baSet(succ,1+tool,1);
    addSucc(succ,manDist(x,y,cx[tool],cy[tool]));
    FOR(t,1,n+1) { // pick up another tool 
      if(t != tool && !baGet(curr,1+t)) {
        Cost pickupCost = manDist(x,y,tx[t],ty[t]);
        //deliver the older 1
        State succ = curr;
        baSet(succ,0,tool);
        baSet(succ,1,t);
        baSet(succ,1+tool,1);
        addSucc(succ,pickupCost+manDist(tx[t],ty[t],cx[tool],cy[tool]));
        //deliver the newer 1
        succ = curr;
        baSet(succ,0,t);
        baSet(succ,1,tool);
        baSet(succ,1+t,1);
        addSucc(succ,pickupCost+manDist(tx[t],ty[t],cx[t],cy[t]));
      }
    }
  }
  
  succs[i] = NONE;
}






//Returns cost of shortest path from start to a goal state or INF if no such path exists.
struct DijkstraComparator {
  public:
    // Compare cost of the cheapest path currently known from start to s
    // and the cost of the cheapest path currently known from start to t.
    bool operator()(const State &s, const State &t) const {
      return costsFromStart[s] > costsFromStart[t];
    }
};
Cost dijkstra(const State &start) {
  memset(seen,0,sizeof(bool)*(baMax+1));
  costsFromStart[start] = 0;
  seen[start] = true;
  priority_queue<State,vector<State>,DijkstraComparator> unexpanded;
  unexpanded.push(start);

  while (!unexpanded.empty()) {
    const State curr = unexpanded.top(); //cant use reference here since top could change in for loop
    //baPrint(curr);
    if (isGoal(curr)) {
      //makePath(curr);
      return costsFromStart[curr];
    }

    getSuccs(curr);
    for (int i = 0; succs[i] != NONE; ++i) {
      const State &succ = succs[i];
      const Cost &alt = costsFromStart[curr] + costs[i];
      if (!seen[succ] || alt < costsFromStart[succ]) {
        costsFromStart[succ] = alt;
        seen[succ] = true;
        unexpanded.push(succ);
        //prev[succ] = curr;
      }
    }
    unexpanded.pop();
  }
  return INF;
}











int main() {
  int T; RI(T);
  FOR(test,0,T) {
    goal = 0;
    RI(n);
    FOR(i,1,n+1) {
      scanf("%i %i %i %i",&(cx[i]),&(cy[i]),&(tx[i]),&(ty[i]));
    }
    Cost res = dijkstra(0);
    printf("%i\n",res);
  }
  return 0;
}
