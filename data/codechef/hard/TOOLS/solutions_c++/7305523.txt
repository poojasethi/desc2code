// Author: thecodekaiser
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
#define MXN 16
#define INF 1000000007

ll dp[(1 << MXN)][MXN];
int x[MXN], y[MXN];
int N;

int dis(int x1, int y1, int x2, int y2)
{
	return abs(x1-x2) + abs(y1-y2);
}

bool valid(int mask)
{
	int cnt = 0;
	for(int i = 1; i < N; i += 2)
	{
		if((mask & (1 << (i-1))) and (!(mask & (1 << i)))) cnt++;			// Tool is there but chef has not been yet visited
		if((!(mask & (1 << (i-1)))) and (mask & (1 << i))) return false;	// Tool is not there but chef has been visited
	}
	
	if(cnt <= 2)	return true;
	else			return false;
}

void solve()
{
	cin >> N;
	
	N *= 2;
	
	for(int i = 0; i < N; i += 2)
	{
		cin >> x[i+1] >> y[i+1] >> x[i] >> y[i];		// Locations, Tools
	}
	
	// Initialisation
	for(int mask = 0; mask < (1 << N); mask++)
		for(int i = 0; i < N; i++) dp[mask][i] = INF;
	
	// Setting up for single tools	
	for(int i = 0; i < N; i += 2)
		dp[(1 << i)][i] = dis(x[i], y[i], 0, 0);		// Min distance to get this particular tool
	
	
	for(int mask = 1; mask < (1 << N); mask++)
	{
		if(valid(mask))
		{
			if(!(mask & (mask-1)))		// A power of two we have already calculated for this one
				continue;
				
			for(int i = 0; i < N; i++)
			{	
				if(mask & (1 << i))
				{
					for(int j = 0; j < N; j++)
					{
						if(!((i != j) and (mask & (1 << j))))	continue;
						
						dp[mask][i] = min(dp[mask][i], dp[mask ^ (1 << i)][j] + dis(x[i], y[i], x[j], y[j]));
						
					}
				}
			}
		}
	}
	
	ll ans = INF;
	for(int i = 1; i < N; i += 2)
		ans = min(ans, dp[(1 << N)-1][i] + dis(x[i], y[i], 0, 0));
		
	cout << ans << endl;
	 
	return;
}

int main()
{
	int t;
	cin >> t;
	
	
	while(t--)
		solve();
		
	return 0;
}