#include<iostream>
#include<cstdio>
#include<vector>
#include<map>
#include<math.h>
#include<queue>
#include<list>
#include<algorithm>
#include<string>
#include<cstdlib>
#include<cstring>
#include<climits>
#include<stack>
#include<cfloat>

using namespace std;

#define inf 100005
#define iter(v,i,j) for(v=i;v!=j;v++)
#define rec(i,n) for(int i=0;i<n;i++)
#define vs vector<string>
#define vi vector<int>
#define vvi vector<vector<int> >
#define ll long long int
#define ull unsigned long long int
#define get1(i) scanf("%d",&i)
#define get2(i,j) scanf("%d %d",&i,&j)
#define get3(i,j,k) scanf("%d %d %d",&i,&j,&k)
#define getll(i) scanf("%lld",&i)
#define getllu(i) scanf("%llu",&i)
#define show(i) printf("%d\n",i)
#define show2(i,j) printf("%d %d\n",i,j)
#define init(m) memset(m,0,sizeof(m))
#define showvec(v) for(int i=0;i<v.size();i++)cout<<v[i]<<" ";cout<<endl;

int C[8][2];
int T[8][2];
int n;
ull values[600000];
ull process(vector<int> c,int cur1, int cur2, int pos){
	int index;//cout<<"vec: ";showvec(c);
	if(pos!=-1){//memoized or not
		index=0;for(int i=0,factor=1;i<n;i++,factor*=2)index+=c[i]*factor;
		index=index*16+cur1;
		index=index*16+cur2;
		index=index*8+pos;//cout<<index<<" here\n";
		if(values[index]!=0){return values[index];}
	}
	vector<int> ctemp;
	ull minim=LONG_MAX;
	int tempsum,x,y;//cout<<"init: "<<minim<<endl;
	if(cur1==0 && cur2==0){//no tool
		for(int i=0;i<n;i++){
			if(c[i]==1)continue;
			if(pos!=-1)	minim=min(minim,abs(C[pos][0]-T[i][0])+abs(C[pos][1]-T[i][1])+process(c,i+1,cur2,i));
			else minim=min(minim,T[i][0]+T[i][1]+process(c,i+1,cur2,i));
		}
		if(minim==LONG_MAX){if(pos!=-1)minim=(C[pos][0]+C[pos][1]);else minim=0;}
	}
	else if(cur1==0){
		//drop cur2 or pick cur1
		//--
		ctemp=c;ctemp[cur2-1]=1;
		if(cur2-1==pos){x=T[pos][0];y=T[pos][1];}
		else {x=C[pos][0];y=C[pos][1];}
		minim=abs(x-C[cur2-1][0])+abs(y-C[cur2-1][1])+process(ctemp,cur1,0,cur2-1);
		
		//--
		for(int i=0;i<n;i++){
			if(c[i]==1 || (i+1)==cur2)continue;
			minim=min(minim,abs(x-T[i][0])+abs(y-T[i][1])+process(c,i+1,cur2,i));
		}	
	}
	else if(cur2==0){
		//drop cur1 or pick cur2
		//--
		ctemp=c;ctemp[cur1-1]=1;
		if(cur1-1==pos){x=T[pos][0];y=T[pos][1];}
		else {x=C[pos][0];y=C[pos][1];}
		minim=abs(x-C[cur1-1][0])+abs(y-C[cur1-1][1])+process(ctemp,0,cur2,cur1-1);
		
		//--
		for(int i=0;i<n;i++){
			if(c[i]==1 || (i+1)==cur1)continue;
			minim=min(minim,abs(x-T[i][0])+abs(y-T[i][1])+process(c,cur1,i+1,i));
		}	
	}
	else {
		//drop cur1 or drop cur2
		x=T[pos][0];y=T[pos][1];
		ctemp=c;ctemp[cur1-1]=1;
		minim=abs(x-C[cur1-1][0])+abs(y-C[cur1-1][1])+process(ctemp,0,cur2,cur1-1);
		
		ctemp=c;ctemp[cur2-1]=1;
		minim=min(minim,abs(x-C[cur2-1][0])+abs(y-C[cur2-1][1])+process(ctemp,cur1,0,cur2-1));
	}
	if(pos!=-1){values[index]=minim;}//showvec(c);//cout<<cur1<<" "<<cur2<<" "<<pos<<" "<<minim<<" "<<index<<endl;
	return minim;
}


int main(){
	int t;
	get1(t);
	vector<int> c;
	while(t--){
		memset(values,0,sizeof(values));
		get1(n);
		for(int i=0;i<n;i++){get2(C[i][0],C[i][1]);get2(T[i][0],T[i][1]);}
		c.clear();
		for(int i=0;i<n;i++){c.push_back(0);}
		printf("%llu\n",process(c,0,0,-1));
	}
	return 0;
}

