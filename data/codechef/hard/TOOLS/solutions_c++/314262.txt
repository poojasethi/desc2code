#include<iostream>
#include<cstring>
#include<cstdlib>
#include<map>
#include<vector>
#include<list>
#include<set>
#include<queue>
#include<cassert>
#include<sstream>
#include<string>
#include<cmath>
#include<algorithm>
#include<climits>

#define FOR(i,a,b) for(int i=a;i<b;++i)
#define REP(i,n) FOR(i,0,n)
#define myabs(x) abs(x) //((x)>=0?(x):(-x))
#define min(a,b) ((a)<(b)?(a):(b))

using namespace std;

#define MAX 20
#define INF 1234567890
#define two(n) (1<<n)

int n;
int cx[20], cy[20];
int mem[two(10)][20][10];

int solve(int mask, int at, int have) {
	if (mask == 0) {
		assert(at <= n);
		return cx[at] + cy[at];
	}
	
	int &ret = mem[mask][at][have];
	if (ret != -1) 
		return ret;
	
	ret = INF;
	if (at < n) {
		if (have > 0) {
			ret = min(ret, myabs(cx[at]-cx[have-1]) + myabs(cy[at]-cy[have-1]) + solve(mask^two(have-1), have-1, 0));
		}
		REP(i,n) if (((mask >> i) & 1) == 1)
			ret = min(ret, myabs(cx[at]-cx[n+i]) + myabs(cy[at]-cy[n+i]) + solve(mask, n+i, have));
	} else {
		if (have > 0) {
			ret = min(ret, myabs(cx[at]-cx[have-1]) + myabs(cy[at]-cy[have-1]) + solve(mask^two(have-1), have-1, at-n+1));
		}
		if (have == 0) {
			REP(i,n) if (((mask >> i) & 1) == 1)
				ret = min(ret, myabs(cx[at]-cx[n+i]) + myabs(cy[at]-cy[n+i]) + solve(mask, n+i, at-n+1));
		}
		ret = min(ret, myabs(cx[at]-cx[at-n]) + myabs(cy[at]-cy[at-n]) + solve(mask^two(at-n), at-n, have));
	}
	
	return ret;
}

int main() {
	int t;
	scanf("%d", &t);
	while (t--) {
		memset(mem, -1, sizeof mem);
		
		scanf("%d", &n);
		REP(i,n) cin >> cx[i] >> cy[i] >> cx[n+i] >> cy[n+i];
		
		int res = INF;
		REP(i,n) res = min(res, cx[n+i] + cy[n+i] + solve(two(n)-1, n+i, 0));
		
		printf("%d\n", res);
	}
	return 0;
}
