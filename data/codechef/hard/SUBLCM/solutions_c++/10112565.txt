#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <string.h>
#include <algorithm>
#include <math.h>
#include <vector>
#include <queue>
#include <set>
#include <stack>
#include <map>
#define INF_MAX 2147483647
#define INF_MIN -2147483647
#define INF_LL 9223372036854775807LL
#define INF 2000000000
#define PI acos(-1.0)
#define inf INT_MAX
#define llu unsigned long long int
#define all(v) v.begin(),v.end()
#define pb push_back
#define mp make_pair
#define F first
#define S second
#define si(n) scanf("%d",&n)
#define slli(n) scanf("%lld",&n);
#define ss(n) scanf("%s",n);
using namespace std;
typedef long long int LL;
vector<int > primes;
int is_prime[1000010];

std::vector<int > myprimes[1000004];

void seive(){
for(int i=0;i<=1000005;i++)
  is_prime[i] = 1;
is_prime[1] = 0;
is_prime[0] = 0;
for(long long int j=2;j<=1000000;j++){
  if(is_prime[j]==1){
    // primes.push_back(j);
    myprimes[j].pb(j);
    for(long long int k=(2*j);k<=1000000;k+=j)
    {
     	myprimes[k].pb(j);
      	is_prime[k] = 0;
  	}
  }
}
}

int largestoccuring[1000004] , dp[100010] , A;



//dp[i] stores how back we can go from i such that [dp[i] , i] forms a substring of GCD = 1
int main(){
seive();
int test , N , ans;
si(test);

while(test--)
{

si(N);

// memset(dp , 1 , sizeof(dp));
// memset(largestoccuring , 0 , sizeof(largestoccuring));
for(int i=0;i<N+4;i++)
	dp[i] = 1;

for(int i=0;i<1000004;i++)
	largestoccuring[i] = 0;


for(int i=1;i<=N;i++)
{
	si(A);
	// for(int j=2;j<A;j++)
	// {
		/*
		if((A%j)==0){
			while((A%j)==0)
				A = (A/j);
			dp[i] = max(dp[i] , largestoccuring[j]+1);
			largestoccuring[j] = i;
		}
		*/
		for(int k=0;k<myprimes[A].size();k++)
		{
			dp[i] = max(dp[i] , largestoccuring[myprimes[A][k]]+1);
			largestoccuring[myprimes[A][k]] = i;
		}

		
	// }

/*	
	if(A!=1)
	{
		dp[i] = max(dp[i] , largestoccuring[A]+1);
		largestoccuring[A] = i;
	}
*/
	dp[i] = max(dp[i] , dp[i-1]);
}


// for(int i=1;i<=N;i++)
	// printf("%d ", dp[i]);
// printf("\n");

ans = -1;
for(int i=1;i<=N;i++)
	ans = max(ans , i - dp[i] + 1);
if(ans!=1)
	printf("%d\n", ans);
else
	printf("-1\n");

}
return 0;
}




