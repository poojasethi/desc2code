#include <cstdio>
#include <cstring>
#include <iostream>
#include <vector>
#define MAX 1000001 // maximum number to make the sieve
#define IMAX 100001 // input array size
using namespace std;
bool V[MAX]; // to make the erastostenes sieve
int Primes[78498],cnt_primes; // to save the primes numbers
//int posPrimes[MAX]; // to save in which position of the Primes array is the prime in the Primes array
int lposPrime[MAX]; // last position prime

// get prime numbers with erastostenes sieve
void get_primes(){
	memset(V,true,sizeof V);
	for(int i = 2;i*i <= MAX;i++){
		if(!V[i]) continue;
		for(int j = 2*i;j < MAX;j += i) V[j] = false;
	}
	
	// retrieval of the prime numbers
	cnt_primes = 0;
	for(int i = 2;i < MAX;i++){
		if(V[i]){
			Primes[cnt_primes] = i;
			//posPrimes[i] = cnt_primes;
			cnt_primes++;
		}
	}
}

// return the factors of n
vector < int > factorize(int n){
	//printf("getting factors of %d\n",n);
	vector < int > factors;
	for(int i = 0;Primes[i]*Primes[i] <= n;i++){
		if(n % Primes[i] == 0){
			factors.push_back(Primes[i]);
			while( n % Primes[i] == 0) n /= Primes[i];
		}
	}
	if(n != 1) factors.push_back(n);
	return factors;
}

int main(){
	get_primes();
		
	int t,n;
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		//for(int i = 0;i < n;i++) scanf("%d",&A[i]);
		// save the last position in which the prime number was a factor
		memset(lposPrime,-1,sizeof(lposPrime));
		int last = 0; // the position where the current subsequence start 
		int res = 0;  // the longest sequence so far
		int s;
		for(int i = 0;i < n;i++){
			//printf("sequence form %d to %d\n",last,i);
			int rep = -1; // if there is an prime number between [last, i] then it will have the last element wich contains this
			/*vector < int > factor = factorize(A[i]);
			for(int j = 0;j < factor.size();j++){
				//printf("last position of %d is %d\n",factor[j],lposPrime[factor[j]]);
				if(lposPrime[factor[j]] < last) lposPrime[factor[j]] = i;
				else{
					// the factor was added in the sequence,save the position
					//printf("replace %d by %d because it also have %d factor\n",lposPrime[factor[j]],i,factor[j]);
					rep = max(rep,lposPrime[factor[j]]);
					lposPrime[factor[j]] = i;
				}
			}*/
			scanf("%d",&s);
			for(int j = 0;Primes[j]*Primes[j] <= s && !V[s];j++){
				if(s % Primes[j] == 0){
					if(lposPrime[Primes[j]] < last) lposPrime[Primes[j]] = i;
					else{
						rep = max(rep,lposPrime[Primes[j]]);
						lposPrime[Primes[j]] = i;
					}
					while(s % Primes[j] == 0) s /= Primes[j];
				}
			}
			
			if(s != 1){
				if(lposPrime[s] < last) lposPrime[s] = i;
				else{
					rep = max(rep,lposPrime[s]);
					lposPrime[s] = i;
				}
			}
			
			
			if(rep != -1){
				last = rep + 1;
			}
			res = max(res,i - last + 1);
			
		}
		if(res == 1) printf("-1\n");
		else printf("%d\n",res);
		//printf("maximum subsequence %d\n",res);
		
	}
	return 0;
}
