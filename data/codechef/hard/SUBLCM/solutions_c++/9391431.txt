#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <algorithm>
#include <math.h>
#include <vector>
#include <queue>
#include <set>
#include <stack>
#include <map>
#define INF_MAX 2147483647
#define INF_MIN -2147483647
#define INF_LL 9223372036854775807LL
#define INF 2000000000
#define PI acos(-1.0)
#define inf INT_MAX
using namespace std;
typedef long long int LL;

std::vector<int > factor[1000010];
// vector<int > primes;
inline int scan(){
    char c = getchar_unlocked();
    int x = 0;
    while(c < '0' || c > '9'){
        c = getchar_unlocked();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + c - '0';
        c = getchar_unlocked();
    }
    return x;
}

int present[1000010] , N , A[100010];
int dp[100010];

void seive(){

for(int i=2;i<=1000000;i++)
{
	if(factor[i].size() == 0)
	{
		for(int j=i;j<=1000000;j+=i)
			factor[j].push_back(i);
	}
}

}


int main()
{
int test;
// scanf("%d",&test);
test = scan();
seive();

while(test--)
{
// scanf("%d",&N);
N = scan();
for(int i=1;i<=N;i++)
	// scanf("%d",&A[i]);
	A[i] = scan();
int at = 1 , T;
// memset(dp , 0 , sizeof(dp));
memset(present , 0 , sizeof(present));

int can_back = 0 , ans = 0;

for(int i=1;i<=N;i++)
{
	can_back = 0;
	// cout << A[i] << "   --->    ";
	for(int j=0;j<factor[A[i]].size() ;j++)
	{
		can_back = max(can_back , present[factor[A[i]][j]]);
		present[factor[A[i]][j]] = i;
	}
	can_back++;
	dp[i] = dp[i-1];
	if(can_back>dp[i])
		dp[i] = can_back;
	ans = max(ans , i - dp[i] + 1);
}


if(ans>1)
	// cout << ans << endl;
	printf("%d\n", ans);
else
	// cout << "-1" << endl;
	printf("-1\n");
}

return 0;
}






















