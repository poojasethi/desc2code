#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
#include <math.h>

// C and D together use 7.6294 Mb, A uses 0.381473 Mb, P uses 3.81464. Total is 11.82551 Mb
int A[100001];  // Ai in [1, 1000000]
int C[1000001]; // Contains the largest prime factor (for the primes it is equal to the prime itself)
int D[1000001]; // Contains the result of the number divided by the largest prime factor
int P[999984];  // Contains the rightmost position of the primes (initially -1), max prime in [1, 1000000] is 999983 

// The function fills the array C with the greatest prime factor
// and the array D with the number to look up the next greatest unique prime factor
void Sieve()
{
  memset(C, 0, sizeof(C));
  C[1] = 1;
  for(int i = 2; i <= 1000000; ++i)
  {
    if(C[i] != 0)
      continue;

    C[i] = i;
    D[i] = 1;
    for(int j = i + i; j <= 1000000; j += i)
    {
      C[j] = i;
      int d = j / i;
      while(C[d] == i) // Skip duplicate primes
        d = d / i;

      D[j] = d;
    }
  }
}

inline void fastread(int* a)
{
  register char c = 0;
  while (c < 33)
    c = getchar();
  *a = 0;
  while (c > 33)
  {
    *a = (*a <<1)+(*a<<3) + c - '0';
    c = getchar();
  }
}

int main()
{
  Sieve();

  int T;
  fastread(&T);

  while(T--)
  {
    int N;
    fastread(&N);

    for(register int i = 0; i < N; ++i)
      fastread(A + i);

    memset(P, 0xFF, sizeof(P));

    int maxRes = -1;

    int l = -1;
    for(register int r = 0; r < N; ++r)
    {
      int num = A[r];
      while(num != 1)
      {
        const int prime = C[num];
        int &rPos = P[prime];
        if(rPos != -1)
        {
          if(l < rPos)
            l = rPos;
        }
        rPos = r;

        num = D[num];
      }

      if(maxRes < r - l)
      {
        maxRes = r - l;
      }
    }

    if(maxRes <= 1)
      maxRes = -1;

    printf("%d\n", maxRes);
  }

  return 0;
}
