#include<bits/stdc++.h>
using namespace std;
typedef double D;
typedef long long ll;
typedef int TYPE;
#define mod9 1000000009
#define mod7 1000000007
#define INF 1023456789
TYPE getint(){
    TYPE x=0,tmp=1; char c=getchar();
    while( (c<'0'||c>'9')&&c!='-' ) c=getchar();
    if( c == '-' ) c=getchar() , tmp = -1;
    while(c>='0'&&c<='9') x*=10,x+=(c-'0'),c=getchar();
    return x*tmp;
}
int __ = 1;
inline void O(ll a)
{
 register char s[30];
 register int t=-1;
 do s[++t]=a%10+'0',a/=10; while(a>0);
 while(t>=0) putchar_unlocked(s[t--]);
 putchar_unlocked('\n');
}
#define N 131073
int n , q , a[ N ] , st0[ N << 1 ] , st1[ N << 1 ] , tag[ N << 1 ] , presum[ N ];
char c[ N ];
void build_ST( int no , int l , int r ){
    if( l == r ){
        if( presum[ l ] == 0 ) st0[ no ] = 1;
        else if( presum[ l ] == 1 ) st1[ no ] = 1;
        return;
    }
    int mid = ( l + r ) >> 1;
    build_ST( no << 1 , l , mid );
    build_ST( ( no << 1 ) + 1 , mid + 1 , r );
    st0[ no ] = st0[ no << 1 ] + st0[ ( no << 1 ) + 1 ];
    st1[ no ] = st1[ no << 1 ] + st1[ ( no << 1 ) + 1 ];
}
void insert( int no , int l , int r , int dlt ){
    int no0 = st0[ no ] , no1 = st1[ no ];
    int no2 = ( r - l + 1 ) - no0 - no1;
    if( dlt == 1 ){
        st0[ no ] = no2;
        st1[ no ] = no0;
    }else if( dlt == 2 ){
        st0[ no ] = no1;
        st1[ no ] = no2;
    }
}
void push( int no , int l , int r ){
    if( tag[ no ] ){
        if( l != r ){
            int mid = ( l + r ) >> 1;
            insert( no << 1 , l , mid , tag[ no ] );
            insert( ( no << 1 ) + 1 , mid + 1 , r , tag[ no ] );
            tag[ no << 1 ] = ( tag[ no << 1 ] + tag[ no ] ) % 3;
            tag[ ( no << 1 ) + 1 ] = ( tag[ ( no << 1 ) + 1 ] + tag[ no ] ) % 3;
        }
        tag[ no ] = 0;
    }
}
void modify( int no , int l , int r , int ql , int qr , int dlt ){
    push( no , l , r );
    if( l == ql && r == qr ){
        insert( no , l , r , dlt );
        tag[ no ] = ( tag[ no ] + dlt ) % 3;
        return;
    }
    int mid = ( l + r ) >> 1;
    if( qr <= mid ) modify( no << 1 , l , mid , ql , qr , dlt );
    else if( mid < ql ) modify( ( no << 1 ) + 1 , mid + 1 , r , ql , qr , dlt );
    else{
        modify( no << 1 , l , mid , ql , mid , dlt );
        modify( ( no << 1 ) + 1 , mid + 1 , r , mid + 1 , qr , dlt );
    }
    st0[ no ] = st0[ no << 1 ] + st0[ ( no << 1 ) + 1 ];
    st1[ no ] = st1[ no << 1 ] + st1[ ( no << 1 ) + 1 ];
}
pair<int,int> query( int no , int l , int r , int ql , int qr ){
    push( no , l , r );
    if( l == ql && r == qr )
        return make_pair( st0[ no ] , st1[ no ] );
    int mid = ( l + r ) >> 1;
    if( qr <= mid ) return query( no << 1 , l , mid , ql , qr );
    if( mid < ql ) return query( ( no << 1 ) + 1 , mid + 1 , r , ql , qr );
    pair<int,int> al , ar;
    al = query( no << 1 , l , mid , ql , mid );
    ar = query( ( no << 1 ) + 1 , mid + 1 , r , mid + 1 , qr );
    return make_pair( al.first + ar.first , al.second + ar.second );
}
void init(){
    n = getint(); q = getint();
    scanf( "%s" , c + 1 );
    for( int i = 1 ; i <= n ; i ++ ){
        a[ i ] = ( c[ i ] - '0' ) % 3;
        presum[ i ] = ( presum[ i - 1 ] + a[ i ] ) % 3;
    }
    build_ST( 1 , 0 , n );
}
ll C_2( int x ){
    return ( (ll)x * (ll)( x - 1 ) ) / 2ll;
}
void solve(){
    int ty , q1 , q2;
    while( q -- ){
        ty = getint(); q1 = getint(); q2 = getint();
        if( ty == 1 ){
            q2 %= 3;
            if( q2 != a[ q1 ] ){
                if( ( a[ q1 ] + 1 ) % 3 == q2 )
                    modify( 1 , 0 , n , q1 , n , 1 );
                else modify( 1 , 0 , n , q1 , n , 2 );
            }
            a[ q1 ] = q2;
        }else{
            pair<int,int> ans = query( 1 , 0 , n , q1 - 1 , q2 );
            ll cans = 0;
            cans += C_2( ans.first );
            cans += C_2( ans.second );
            cans += C_2( ( q2 - q1 + 2 - ans.first - ans.second ) );
            O( cans );
        }
    }
}
int main(){
//    __ = getint();
    while( __ -- ){
        init();
        solve();
    }
}
 