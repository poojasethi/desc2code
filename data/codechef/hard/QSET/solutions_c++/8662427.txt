//Author : Sharath Chandran
//Handle : sharad07

#include<bits/stdc++.h>
#define lld long long int
#define llu unsigned long long int
#define pb(x) push_back(x)
#define sz size()
#define inp(x) scanf("%d",&x)
#define print(x) printf("%d",x)
#define println(x) printf("%d\n",x)
#define for(i,x,y) for(int i=x;i<y;i++)
#define MAX 100002
using namespace std;

struct SGT
{
    lld count,sum;
    lld prefix[3],suffix[3];
    
    void reset()
    {
        count=sum=0;
        for(i,0,3)
        {
            prefix[i]=suffix[i]=0;
        }
    }
    
    void copy(SGT a)
    {
        count=a.count;
        sum=a.sum;
        for(i,0,3)
        {
            prefix[i]=a.prefix[i];
            suffix[i]=a.suffix[i];
        }
    }
};

int SIZE;
int orig[MAX];
SGT seg_tree[4*MAX];
SGT Q;

void getsize(int N)
{
    SIZE=log(N)/log(2) + 2;
    SIZE=pow(2,SIZE);
}

void merge(int index)
{
    lld ctr=0;
    int left=2*index;
    int right=2*index+1;
    lld x=seg_tree[left].sum,y=seg_tree[right].sum,p,s;
    
    for(i,0,3)
    {
        for(j,0,3)
        {
            if((i+j)%3==0) ctr+=seg_tree[left].suffix[i] * seg_tree[right].prefix[j];
        }
        seg_tree[index].prefix[i]=seg_tree[left].prefix[i];
        seg_tree[index].suffix[i]=seg_tree[right].suffix[i];
    }
    
    for(i,0,3)
    {
        p=(x+i)%3;
        s=(y+i)%3;
        seg_tree[index].prefix[p]+=seg_tree[right].prefix[i];
        seg_tree[index].suffix[s]+=seg_tree[left].suffix[i];
    }
    ctr+=seg_tree[left].count + seg_tree[right].count;
    seg_tree[index].count=ctr;
    seg_tree[index].sum= x + y;
}

void build(int index,int left,int right)
{
    if(left==right) //leaf node
    {
        lld x=orig[left];
        seg_tree[index].sum=x;
        if(x%3==0) seg_tree[index].count=1;
        seg_tree[index].prefix[x%3]=1;
        seg_tree[index].suffix[x%3]=1;
        return;
    }
    int mid=(left+right)/2;
    build(2*index,left,mid);
    build(2*index+1,mid+1,right);
    merge(index); //parent node <-- merge left and right child
    return;
}

void mergeQuery(int index)
{
    lld ctr=0;
    lld x=Q.sum,y=seg_tree[index].sum,p,s;
    SGT temp;
    for(i,0,3)
    {
        for(j,0,3)
        {
            if((i+j)%3==0) ctr+= Q.suffix[i]*seg_tree[index].prefix[j];
        }
        temp.prefix[i]=Q.prefix[i];
        temp.suffix[i]=seg_tree[index].suffix[i];
    }
    for(i,0,3)
    {
        p=(x+i)%3;
        s=(y+i)%3;
        temp.prefix[p]+=seg_tree[index].prefix[i];
        temp.suffix[s]+=Q.suffix[i];
    }
    temp.count=Q.count + seg_tree[index].count + ctr;
    temp.sum=Q.sum + seg_tree[index].sum;
    Q.copy(temp); //copy.. Q <-- temp
}

void query(int index,int L,int R,int left,int right)
{
    if(L>R) return;
    if(L==left&&R==right)
    {
        mergeQuery(index);
        return;
    }
    int mid=(left+right)/2;
    query(2*index,L,min(mid,R),left,mid);
    query(2*index+1,max(L,mid+1),R,mid+1,right);
    return;
}

void mergeUpdate(int index)
{
    lld ctr=0;
    int left=2*index,right=2*index+1;
    lld x=seg_tree[left].sum,y=seg_tree[right].sum,p,s;
    SGT temp;
    for(i,0,3)
    {
        for(j,0,3)
        {
            if((i+j)%3==0) ctr+= seg_tree[left].suffix[i]*seg_tree[right].prefix[j];
        }
        temp.prefix[i]=seg_tree[left].prefix[i];
        temp.suffix[i]=seg_tree[right].suffix[i];
    }
    for(i,0,3)
    {
        p=(x+i)%3;
        s=(y+i)%3;
        temp.prefix[p]+=seg_tree[right].prefix[i];
        temp.suffix[s]+=seg_tree[left].suffix[i];
    }
    temp.count=seg_tree[left].count + seg_tree[right].count + ctr;
    temp.sum=seg_tree[left].sum + seg_tree[right].sum;
    seg_tree[index].copy(temp); //copy new values to parent.. seg_tree[index] <-- temp
}

void update(int val,int index,int L,int R,int left,int right)
{
    if(L>R) return;
    if(L==left&&R==right) //arrived at leaf node
    {
        seg_tree[index].reset();
        seg_tree[index].sum=val;
        if(val%3==0) seg_tree[index].count=1;
        seg_tree[index].prefix[val%3]=1;
        seg_tree[index].suffix[val%3]=1;
        return;
    }
    int mid=(left+right)/2;
    update(val,2*index,L,min(mid,R),left,mid);
    update(val,2*index+1,max(L,mid+1),R,mid+1,right);
    mergeUpdate(index); //update the parent node
    return;
}

int main()
{
    int N,M,type,L,R,val,index;
    char ch;
    inp(N); inp(M);
    getsize(N);
    
    for(i,0,N)
    {
        scanf(" %c",&ch);
        orig[i]=ch-'0';
    }
    
    build(1,0,N-1);
    
    //for(i,1,SIZE) cout<<seg_tree[i].sum<<" "<<seg_tree[i].count<<endl;
    
    while(M--)
    {
        inp(type);
        if(type==1)
        {
            inp(index); inp(val);
            update(val,1,index-1,index-1,0,N-1);
        }
        else
        {
            inp(L); inp(R);
            L--; R--;
            Q.reset();
            query(1,L,R,0,N-1);
            printf("%lld\n",Q.count);
        }
    }
    return 0;
}
