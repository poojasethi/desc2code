#include <iostream>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <vector>
#include<stack>
#include<set>
#include<limits.h>
#include <queue>
#include <map>
#include <cstdlib>
#include <algorithm>
//psyduck
#define ll long long
#define S(x) scanf("%d",&x)
#define Sf(x) scanf("%f",&x)
#define Slf(x) scanf("%lf",&x)
#define Sl(x) scanf("%lld",&x)
#define P(x)  printf("%d\n", x)
#define Pf(x)  printf("%f\n", x)
#define Plf(x)  printf("%lf\n", x)
#define Pl(x)  printf("%lld\n", x)
#define mem(x,i) memset(x,i,sizeof(x))
#define mod 1000000007
using namespace std;

void dba(int debug_array[],int n){
    for (int i = 1; i <= n; i++)cout << debug_array[i]<<" ";
    cout << endl;
}
void db2a(int debug2d[100][100],int n, int m)
{
    for (int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            cout << debug2d[i][j];
        cout << endl;
}
ll int a[100005];
struct node{
    ll int ans,total;
    ll int l[3];
    ll int r[3];
};
node seg[400005];
ll int h[3][3];
void construction(ll int node,ll int b, ll int e);
struct node query(ll int node, ll int b, ll int e);
void update(ll int node, ll int b, ll int e, ll int idx, ll int val);
ll int l,r;
int main()
{
    ll int n,q,i,type,idx,val;
    Sl(n);Sl(q);
    string s;
    cin >> s;
    for (i = 1; i <= n; i++){
        a[i] = s[i-1]-48;
    }
    h[0][0] = 0; h[0][1] = 2; h[0][2] = 1;
    h[1][0] = 1; h[1][1] = 0; h[1][2] = 2;
    h[2][0] = 2; h[2][1] = 1; h[2][2] = 0;
    construction(1,1,n);
    /*for (i = 1; i <= 3; i++){
        cout <<"***********node"<<i<<"***************"<<endl;
        cout <<"ans "<<seg[i].ans<<endl;
        cout <<"tot "<<seg[i].total<<endl;
        cout <<"left:0 "<<seg[i].l[0]<<endl;
        cout <<"left:1 "<<seg[i].l[1]<<endl;
        cout <<"left:2 "<<seg[i].l[2]<<endl;
        cout <<"right:0 "<<seg[i].r[0]<<endl;
        cout <<"right:1 "<<seg[i].r[1]<<endl;
        cout <<"right:2 "<<seg[i].r[2]<<endl;
    }*/
    while(q--){
        Sl(type);
        if(type == 2){
            Sl(l);Sl(r);
            struct node z = query(1,1,n);
            Pl(z.ans);
        }
        else {
            Sl(idx);Sl(val);
            update(1,1,n,idx,val);
        }
    }
}
void construction(ll int node,ll int b,ll int e)
{
    ll int p = 2*node;
    ll int q = 2*node+1;
    if(b == e){
        seg[node].ans = 0; seg[node].total = 0;
        seg[node].l[0] = 0;seg[node].l[1] = 0;seg[node].l[2] = 0;
        seg[node].r[0] = 0;seg[node].r[1] = 0;seg[node].r[2] = 0;
        if(a[b]%3 == 0){
            seg[node].ans = 1;
            seg[node].l[0] = 1;
            seg[node].r[0] = 1;
        }
        else if(a[b]%3 == 1){
            seg[node].total = 1;
            seg[node].l[1] = 1;
            seg[node].r[1] = 1;
        }
        else {
            seg[node].total = 2;
            seg[node].l[2] = 1;
            seg[node].r[2] = 1;
        }
        return ;
    }
    ll int mid = (b+e)/2;
    construction(p, b, mid);
    construction(q, mid+1, e);
    ll int tmp = ((seg[p].l[0])*(seg[q].r[0]))+((seg[p].l[1])*(seg[q].r[2]))+((seg[p].l[2])*(seg[q].r[1]));
    seg[node].ans = seg[p].ans + seg[q].ans + tmp;
    seg[node].total = (seg[p].total + seg[q].total)%3;
    ll int tot = seg[q].total;
    seg[node].l[0] = seg[q].l[0] + seg[p].l[h[0][tot]];
    seg[node].l[1] = seg[q].l[1] + seg[p].l[h[1][tot]];
    seg[node].l[2] = seg[q].l[2] + seg[p].l[h[2][tot]];
    tot = seg[p].total;
    seg[node].r[0] = seg[p].r[0] + seg[q].r[h[0][tot]];
    seg[node].r[1] = seg[p].r[1] + seg[q].r[h[1][tot]];
    seg[node].r[2] = seg[p].r[2] + seg[q].r[h[2][tot]];
}
struct node query(ll int node, ll int b, ll int e)
{
    if(b > r || e < l){
        struct node tmp;
        tmp.ans = 0; tmp.total = 0;
        tmp.l[0] = 0; tmp.l[1] = 0; tmp.l[2] = 0;
        tmp.r[0] = 0; tmp.r[1] = 0; tmp.r[2] = 0;
        return tmp;
    }
    if(b >= l && e <= r){
        return seg[node];
    }
    ll int mid = (b+e)/2;
    struct node x = query(2*node,b,mid);
    struct node y = query(2*node+1,mid+1,e);
    struct node z;
    ll int tmp = ((x.l[0])*(y.r[0]))+((x.l[1])*(y.r[2]))+((x.l[2])*(y.r[1]));
    z.ans = x.ans + y.ans + tmp;
    z.total = (x.total + y.total)%3;
    ll int tot = y.total;
    z.l[0] = y.l[0] + x.l[h[0][tot]];
    z.l[1] = y.l[1] + x.l[h[1][tot]];
    z.l[2] = y.l[2] + x.l[h[2][tot]];
    tot = x.total;
    z.r[0] = x.r[0] + y.r[h[0][tot]];
    z.r[1] = x.r[1] + y.r[h[1][tot]];
    z.r[2] = x.r[2] + y.r[h[2][tot]];

    return z;
}
void update(ll int node, ll int b, ll int e, ll int idx, ll int val)
{
    ll int p = 2*node;
    ll int q = 2*node+1;
    if(b == e && b == idx){
        seg[node].ans = 0; seg[node].total = 0;
        seg[node].l[0] = 0;seg[node].l[1] = 0;seg[node].l[2] = 0;
        seg[node].r[0] = 0;seg[node].r[1] = 0;seg[node].r[2] = 0;
        if(val%3 == 0){
            seg[node].ans = 1;
            seg[node].l[0] = 1;
            seg[node].r[0] = 1;
        }
        else if(val%3 == 1){
            seg[node].total = 1;
            seg[node].l[1] = 1;
            seg[node].r[1] = 1;
        }
        else {
            seg[node].total = 2;
            seg[node].l[2] = 1;
            seg[node].r[2] = 1;
        }
        return ;
    }
    if(idx < b || idx > e){
        return ;
    }
    ll int mid = (b+e)/2;
    update(2*node,b,mid,idx,val);
    update(2*node+1,mid+1,e,idx,val);
    ll int tmp = ((seg[p].l[0])*(seg[q].r[0]))+((seg[p].l[1])*(seg[q].r[2]))+((seg[p].l[2])*(seg[q].r[1]));
    seg[node].ans = seg[p].ans + seg[q].ans + tmp;
    seg[node].total = (seg[p].total + seg[q].total)%3;
    ll int tot = seg[q].total;
    seg[node].l[0] = seg[q].l[0] + seg[p].l[h[0][tot]];
    seg[node].l[1] = seg[q].l[1] + seg[p].l[h[1][tot]];
    seg[node].l[2] = seg[q].l[2] + seg[p].l[h[2][tot]];
    tot = seg[p].total;
    seg[node].r[0] = seg[p].r[0] + seg[q].r[h[0][tot]];
    seg[node].r[1] = seg[p].r[1] + seg[q].r[h[1][tot]];
    seg[node].r[2] = seg[p].r[2] + seg[q].r[h[2][tot]];
}
