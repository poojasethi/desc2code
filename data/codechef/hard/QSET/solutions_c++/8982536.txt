#include<stdio.h>
#include<algorithm>
typedef long long int ll;
using namespace std;
ll arr[100005];
struct node;
typedef struct node data;
struct node
{
ll l0,l1,l2,r0,r1,r2,total,div;
};
data tree[2000100];
void commonUpdate(ll node)
{
ll x=tree[2*node].div;
tree[node].total=0;
if(x%3==0)
{
tree[node].l0=tree[2*node].l0+tree[2*node+1].l0;
tree[node].l1=tree[2*node].l1+tree[2*node+1].l1;
tree[node].l2=tree[2*node].l2+tree[2*node+1].l2;
}
else if(x%3==1)
{
tree[node].l0=tree[2*node].l0+tree[2*node+1].l2;
tree[node].l1=tree[2*node].l1+tree[2*node+1].l0;
tree[node].l2=tree[2*node].l2+tree[2*node+1].l1;
}
else if(x%3==2)
{
tree[node].l0=tree[2*node].l0+tree[2*node+1].l1;
tree[node].l1=tree[2*node].l1+tree[2*node+1].l2;
tree[node].l2=tree[2*node].l2+tree[2*node+1].l0;
}
x=tree[2*node+1].div;
if(x%3==0)
{
tree[node].r0=tree[2*node+1].r0+tree[2*node].r0;
tree[node].r1=tree[2*node+1].r1+tree[2*node].r1;
tree[node].r2=tree[2*node+1].r2+tree[2*node].r2;
}
else if(x%3==1)
{
tree[node].r0=tree[2*node+1].r0+tree[2*node].r2;
tree[node].r1=tree[2*node+1].r1+tree[2*node].r0;
tree[node].r2=tree[2*node+1].r2+tree[2*node].r1;
}
else if(x%3==2)
{
tree[node].r0=tree[2*node+1].r0+tree[2*node].r1;
tree[node].r1=tree[2*node+1].r1+tree[2*node].r2;
tree[node].r2=tree[2*node+1].r2+tree[2*node].r0;
}
tree[node].total=tree[2*node].total+tree[2*node+1].total + tree[2*node].r0*tree[2*node+1].l0 +tree[2*node].r1*tree[2*node+1].l2+tree[2*node].r2*tree[2*node+1].l1;
tree[node].div=(tree[2*node].div+tree[2*node+1].div)%3;
}
void build(ll node,ll a,ll b)
{
if(a>b) return;
if(a==b) {
tree[node].l0=tree[node].r0=arr[a]%3==0?1:0;
tree[node].l1=tree[node].r1=arr[a]%3==1?1:0;
tree[node].l2=tree[node].r2=arr[a]%3==2?1:0;
tree[node].total=arr[a]%3==0?1:0;
tree[node].div = arr[a]%3;
return;
}
build(2*node,a,(a+b)/2);
build(2*node+1,1+(a+b)/2,b);
commonUpdate(node);
}
void update(ll node,ll a,ll b,ll i,ll j,ll val) {
if(a>b||a>j||b<i) return;
if(a==b)
{
tree[node].l0=tree[node].r0=val%3==0?1:0;
tree[node].l1=tree[node].r1=val%3==1?1:0;
tree[node].l2=tree[node].r2=val%3==2?1:0;
tree[node].total=val%3==0?1:0;
tree[node].div = val%3;
return;
}
update(2*node,a,(a+b)/2,i,j,val);
update(2*node+1,1+(a+b)/2,b,i,j,val);
commonUpdate(node);
}
data query(ll node,ll a,ll b,ll i,ll j)
{
data d;
d.l0=d.l1=d.l2=d.r0=d.r1=d.r2=d.total=d.div=0;
if(a>b||a>j||b<i)
return d;
if(a>=i && b<=j)
return tree[node];
data d1=query(2*node,a,(a+b)/2,i,j);
data d2=query(2*node+1,1+(a+b)/2,b,i,j);
//printf(".%d...%d %d...\n",node,a,b);
//printf("%d %d %d %d %d %d %d %d..\n",d1.total,d1.l0,d1.l1,d1.l2,d1.r0,d1.r1,d1.r2,d1.div);
//printf("%d %d %d %d %d %d %d %d..\n",d2.total,d2.l0,d2.l1,d2.l2,d2.r0,d2.r1,d2.r2,d2.div);

data ans;
//
ll x=d1.div;
ans.total=0;
if(x%3==0)
{
ans.l0=d1.l0+d2.l0;
ans.l1=d1.l1+d2.l1;
ans.l2=d1.l2+d2.l2;
}
else if(x%3==1)
{
ans.l0=d1.l0+d2.l2;
ans.l1=d1.l1+d2.l0;
ans.l2=d1.l2+d2.l1;
}
else if(x%3==2)
{
ans.l0=d1.l0+d2.l1;
ans.l1=d1.l1+d2.l2;
ans.l2=d1.l2+d2.l0;
}
x=d2.div;
if(x%3==0)
{
ans.r0=d2.r0+d1.r0;
ans.r1=d2.r1+d1.r1;
ans.r2=d2.r2+d1.r2;
}
else if(x%3==1)
{
ans.r0=d2.r0+d1.r2;
ans.r1=d2.r1+d1.r0;
ans.r2=d2.r2+d1.r1;
}
else if(x%3==2)
{
ans.r0=d2.r0+d1.r1;
ans.r1=d2.r1+d1.r2;
ans.r2=d2.r2+d1.r0;
}
ans.total=d1.total+d2.total + d1.r0*d2.l0 +d1.r1*d2.l2+d1.r2*d2.l1;
ans.div=(d1.div+d2.div)%3;
//

return ans;
}
int main()
{
char ch[1000006];
ll i,j,k,n,m,q,t,a,b;
scanf("%lld%lld",&n,&m);
scanf("%s",ch);
for(i=0;i<n;i++)
arr[i]=ch[i]-'0';
build(1,0,n-1);
int g=2;
//printf("%d %d %d %d %d %d %d %d\n",tree[g].total,tree[g].l0,tree[g].l1,tree[g].l2,tree[g].r0,tree[g].r1,tree[g].r2,tree[g].div);
while(m--)
{
scanf("%lld%lld%lld",&t,&a,&b);
if(t==1)
{
update(1,0,n-1,a-1,a-1,b);
}
else
{
printf("%lld\n",query(1,0,n-1,a-1,b-1).total);
}
//for(i=1;i<=9;i++)
//printf("%d..%d %d %d %d %d %d %d %d\n",i,tree[i].total,tree[i].l0,tree[i].l1,tree[i].l2,tree[i].r0,tree[i].r1,tree[i].r2,tree[i].div);

}
}
