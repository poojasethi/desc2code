#include <iostream>
#include<stdio.h>
#include<math.h>
#define ll long long int
using namespace std;
ll m=1000000007;
ll a[100005],b[100005];
struct node{
    ll key;
    int cnt[3];
};
node *st;//[400000];
ll *lazy;
ll comb(ll n)
{
    if(n>= 2)
        return (n*(n-1))/2;
    return 0;
}
node merge(node &c,node &a, node&b)
{
    for(int i=0;i<3;i++)
        c.cnt[i]=a.cnt[i]+b.cnt[i];
    c.key=comb(c.cnt[0])+comb(c.cnt[1])+comb(c.cnt[2]);
}
void construct(ll a[], int l, int r, int i, node *st)
{
    if(l==r)
    {
        st[i].key=0;
        if(l==0)
        {
            st[i].cnt[0]=1;
        }
        else if(a[l]%3==0)
        {
           st[i].key=1;
           st[i].cnt[0]=1;
        }
        else if(a[l]%3==1)
        {
           st[i].cnt[1]=1;
        }
        else if(a[l]%3==2)
           st[i].cnt[2]=1;
        return;
    }
        construct(a,l,(l+r)/2,2*i+1,st);
        construct(a,(l+r)/2+1,r,2*i+2,st);
        merge(st[i],st[i*2+1],st[i*2+2]);
        return ;
}

void updateset(node *st,int l, int r, int ql, int qr, ll diff, int i)
{
    if(lazy[i]!=0)
    {
            int temp0=st[i].cnt[0],temp1=st[i].cnt[1],temp2=st[i].cnt[2];
      if(lazy[i]==1)
        {
            st[i].cnt[0]=temp2;
            st[i].cnt[1]=temp0;
            st[i].cnt[2]=temp1;
        }
        else if(lazy[i]==2)
        {
            st[i].cnt[0]=temp1;
            st[i].cnt[1]=temp2;
            st[i].cnt[2]=temp0;
        }
        st[i].key=comb(st[i].cnt[0])+comb(st[i].cnt[1])+comb(st[i].cnt[2]);
        if(l!=r)
        {
            lazy[i*2+1]+=lazy[i];
            lazy[i*2+1]%=3;
            lazy[i*2+2]+=lazy[i];
            lazy[i*2+2]%=3;
        }
        lazy[i]=0;
    }
    if(l>r||ql>r||qr<l) return;
    if(l>=ql&&r<=qr)
    {
      if(diff!=0)
       {
            int temp0=st[i].cnt[0],temp1=st[i].cnt[1],temp2=st[i].cnt[2];
      if(diff==1)
        {
            st[i].cnt[0]=temp2;
            st[i].cnt[1]=temp0;
            st[i].cnt[2]=temp1;
        }
        else if(diff==2)
        {
            st[i].cnt[0]=temp1;
            st[i].cnt[1]=temp2;
            st[i].cnt[2]=temp0;
        }
        st[i].key=comb(st[i].cnt[0])+comb(st[i].cnt[1])+comb(st[i].cnt[2]);
        if(l!=r)
        {
            lazy[i*2+1]+=diff;
            lazy[i*2+1]%=3;
            lazy[i*2+2]+=diff;
            lazy[i*2+2]%=3;
        }
       }
        return;
    }
    updateset(st,l,(l+r)/2,ql,qr,diff,i*2+1);
    updateset(st,(l+r)/2+1,r,ql,qr,diff,i*2+2);
        merge(st[i],st[i*2+1],st[i*2+2]);
        return;
}

node getsum(node *st, int l, int r, int i, int ql, int qr)
{
    if(lazy[i]!=0)
    {
            int temp0=st[i].cnt[0],temp1=st[i].cnt[1],temp2=st[i].cnt[2];
      if(lazy[i]==1)
        {
            st[i].cnt[0]=temp2;
            st[i].cnt[1]=temp0;
            st[i].cnt[2]=temp1;
        }
        else if(lazy[i]==2)
        {
            st[i].cnt[0]=temp1;
            st[i].cnt[1]=temp2;
            st[i].cnt[2]=temp0;
        }
        st[i].key=comb(st[i].cnt[0])+comb(st[i].cnt[1])+comb(st[i].cnt[2]);
        if(l!=r)
        {
            lazy[i*2+1]+=lazy[i];
            lazy[i*2+1]%=3;
            lazy[i*2+2]+=lazy[i];
            lazy[i*2+2]%=3;
        }
        lazy[i]=0;
    }

    struct node temp = {0,{0,0,0}};
    if(l>r||l>qr||r<ql) return temp;
    if(l>=ql&&r<=qr)
    {
       return st[i];//=comb(tot0[i])+comb(tot1[i])+comb(tot2[i]);
    }
        node a=(getsum(st,l,(l+r)/2,i*2+1,ql,qr));
        node b=(getsum(st,(l+r)/2+1,r,i*2+2,ql,qr));
        node c= {0,{0,0,0}};
        merge(c,a,b);
        return c;
}
char s[100005];
int main()
{
     //  freopen("input.txt","r",stdin);
    ll t,n,q,w,c,l,r,v;
    char ch;
        scanf("%lld%lld%s",&n,&q,&s);
        a[0]=0;
        for(int i=1; i<=n; i++)
        {
            b[i]=s[i-1]-'0';
            a[i]=b[i]%3;
     //       cout<<a[i];
                a[i]+=a[i-1];
                a[i]%=3;
        //        cout<<a[i]<<endl;
        }
        int x=int(ceil(log2(n+1)));
        int siz=2*int(pow(2,x))-1;
        st=new node[siz];
       lazy=new ll[siz];
        for(int i=0; i<siz; i++)
        {
            lazy[i]=0;
            st[i].key=0;
            for(int j=0;j<3;j++)
                st[i].cnt[j]=0;
        }
        construct(a,0,n,0,st);      //query(l-1,r)      //update(x,n,y)
/*
        cout<<st[8].key<<st[4].key<<endl;
        cout<<st[8].cnt[0]<<st[4].cnt[0]<<endl;
*/
/*        for(int i=0; i<siz; i++)
        {
            cout<<st[i].key;
            }
        cout<<endl;
        for(int i=0; i<siz; i++)
        {
            cout<<st[i].cnt[0];
        }
        cout<<endl;
        for(int i=0; i<siz; i++)
        {
            cout<<st[i].cnt[1];
        }
        cout<<endl;
        for(int i=0; i<siz; i++)
        {
            cout<<st[i].cnt[2];
        }
        cout<<endl;
*/
    for(ll i=0;i<q;i++)
    {
        scanf("%lld%lld%lld",&c,&l,&r);
        if(c==1){
                v=r;
    //            cout<<b[l]<<" ";
                r=r-b[l];
                r%=3;
                r+=3;
                r%=3;
                b[l]=v;
     //           cout<<r<<"this is r\n";
                if(r!=0)
            updateset(st,0,n,l,n,r,0);
           // root=updateadd(a,0,n-1,l,r,v,root);
        }
        else if(c==2)
        {
            printf("%lld\n",getsum(st,0,n,0,l-1,r).key);
  //          printf("%lld %d %d %d\n",getsum(st,0,n,0,l-1,r).key,getsum(st,0,n,0,l-1,r).cnt[0],getsum(st,0,n,0,l-1,r).cnt[1],getsum(st,0,n,0,l-1,r).cnt[2]);
 //           cout<<"yoyo\n";
           // cout<<rmslazy(a,0,n-1,l,r,&root)<<endl;
        }
    }

    return 0;
}
