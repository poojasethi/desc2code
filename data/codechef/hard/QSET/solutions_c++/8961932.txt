#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
#include <functional>
#include <math.h>
#include <map>

inline bool fastreadIsEndOfLine(int* a)
{
  register char c = 0;
  while (c < 33)
    c = getchar();
  *a = 0;
  while (c > 33)
  {
    *a = (*a <<1)+(*a<<3) + c - '0';
    c = getchar();
    if(c == '\r' || c == '\n')
      return true;
  }

  return false;
}

inline void fastread(int* a)
{
  register char c = 0;
  while (c < 33)
    c = getchar();
  *a = 0;
  while (c > 33)
  {
    *a = (*a <<1)+(*a<<3) + c - '0';
    c = getchar();
  }
}

inline void fastreadll(long long* a)
{
  register char c = 0;
  while (c < 33)
    c = getchar();
  *a = 0;
  while (c > 33)
  {
    *a = (*a <<1)+(*a<<3) + c - '0';
    c = getchar();
  }
}

inline void fastreadNeg(int* a)
{
  register char c = 0;
  while (c < 33)
    c = getchar();
  *a = 0;
  bool neg = false;
  if(c == '-')
  {
	  c = getchar();
	  neg = true;
  }
  while (c > 33)
  {
    *a = (*a <<1)+(*a<<3) + c - '0';
    c = getchar();
  }

  if(neg)
	  *a = -*a;
}

inline void readString(char *s)
{
  *s = getchar();
  while(*s == '\r' || *s == '\n' || *s == -1)
    *s = getchar();

  while(*s != '\r' && *s != '\n' && *s != -1)
  {
    ++s;
    *s = getchar();
  }
  *s = '\0';
}

int N, K, M, Q, O, X, Y;
int T = 1;
char A[100000 + 1];

struct Node
{
  int         l;
  int         r;
  int         p[3];
  int         s[3];
  long long   t;
  int         sum;

  Node *      left;
  Node *      right;

  Node(int _l, int _r) : l(_l), r(_r), t(0), sum(0), left(NULL), right(NULL) { p[0] = p[1] = p[2] = 0; s[0] = s[1] = s[2] = 0; }

};

void Merge(const Node *l, const Node *r, Node *n)
{
  n->t = l->t + r->t;
  switch(l->sum + r->sum)
  {
    case 2:         n->sum = 2; break;
    case 1: case 4: n->sum = 1; break;
    default:        n->sum = 0; break;
  }
  //n->sum = (l->sum + r->sum) % 3;

  n->t += ((long long)l->s[0]) * r->p[0];
  n->t += ((long long)l->s[1]) * r->p[2];
  n->t += ((long long)l->s[2]) * r->p[1];
  //for(int i = 0; i < 2; ++i)
  //{
  //  for(int j = 0; j < 2; ++j)
  //  {
  //    if(((i + j) % 3) == 0)
  //      n->t += l->s[i] * r->p[j];
  //  }
  //}
  n->p[0] = l->p[0] + r->p[(3 - l->sum) % 3]; // 0, 2, 1
  n->p[1] = l->p[1] + r->p[(4 - l->sum) % 3]; // 1, 0, 2
  n->p[2] = l->p[2] + r->p[2 - l->sum]; // 2, 1, 0
  n->s[0] = r->s[0] + l->s[(3 - r->sum) % 3]; // 0, 2, 1
  n->s[1] = r->s[1] + l->s[(4 - r->sum) % 3]; // 1, 0, 2
  n->s[2] = r->s[2] + l->s[2 - r->sum]; // 2, 1, 0
  //if(l->sum == 0)
  //{
  //  n->p[0] += r->p[0];
  //  n->p[1] += r->p[1];
  //  n->p[2] += r->p[2];
  //}
  //else if(l->sum == 1)
  //{
  //  n->p[0] += r->p[2];
  //  n->p[1] += r->p[0];
  //  n->p[2] += r->p[1];
  //}
  //else // if(l->sum == 2)
  //{
  //  n->p[0] += r->p[1];
  //  n->p[1] += r->p[2];
  //  n->p[2] += r->p[0];
  //}

}

void UpdateTreeRec(Node *n, int i)
{
  if(n->l == i && n->r == i)
  {
    switch(A[i])
    {
      case 2: case 5: case 8: n->sum = 2; break;
      case 1: case 4: case 7: n->sum = 1; break;
      default:                n->sum = 0; break;
    }
    //n->sum = A[l] % 3;

    n->p[0] = 0; n->p[1] = 0; n->p[2] = 0;
    n->s[0] = 0; n->s[1] = 0; n->s[2] = 0;
    n->t = 0;
    n->p[n->sum] = n->s[n->sum] = 1;
    if(n->sum == 0)
      n->t = 1;
    return;
  }

  if(i < n->right->l)
    UpdateTreeRec(n->left, i);
  else
    UpdateTreeRec(n->right, i);
  Merge(n->left, n->right, n);
}

void UpdateTree(Node *n, int i, char v)
{
  A[i] = v;
  UpdateTreeRec(n, i);
}

Node Query(const Node *n, int l, int r)
{
  // Exactly this node!
  if(n->l == l && n->r == r)
    return *n;

  // Completely to the left
  if(r < n->right->l)
    return Query(n->left, l, r);

  // Completely to the right
  if(l > n->left->r)
    return Query(n->right, l, r);

  // Separation!
  const Node nl = Query(n->left, l, n->left->r);
  const Node nr = Query(n->right, n->right->l, r);

  Node nRet(l, r);
  Merge(&nl, &nr, &nRet);
  return nRet;
}

Node * PreprocessNodes(int l, int r)
{
  Node *n = new Node(l, r);

  // End of recursion
  if(l == r)
  {
    switch(A[l])
    {
      case 2: case 5: case 8: n->sum = 2; break;
      case 1: case 4: case 7: n->sum = 1; break;
      default:                n->sum = 0; break;
    }
    //n->sum = A[l] % 3;

    n->p[n->sum] = n->s[n->sum] = 1;
    if(n->sum == 0)
      n->t = 1;
    return n;
  }

  const int m = (l + r) >> 1;
  n->left = PreprocessNodes(l, m);
  n->right = PreprocessNodes(m + 1, r);

  Merge(n->left, n->right, n);
  return n;
}

int main()
{

#ifdef USE_DATA_TXT
  freopen_s(&stream, "C:\\Projects\\TaskTemplate\\data.txt", "r", stdin);
#endif
#ifdef PRINT_PERF
  auto start = std::chrono::high_resolution_clock::now();
#endif


  while(T--)
  {
    fastread(&N);
    fastread(&M);

    for(int i = 1; i <= N; ++i)
    {
      A[i] = getchar() - '0';
    }

    Node *n = PreprocessNodes(1, N);

    for(int i = 1; i <= M; ++i)
    {
      fastread(&O);
      fastread(&X);
      fastread(&Y);

      if(O == 1)
      {
        UpdateTree(n, X, (char)Y);
      }
      else // 2
      {
        const Node res = Query(n, X, Y);
        printf("%lld\n", res.t);
      }
    }
  }

#ifdef PRINT_PERF
  PrintResultPerf(start);
#endif
#ifdef USE_DATA_TXT
  if(stream)
  {
    fclose(stream);
    stream = NULL;
  }
#endif

  return 0;
}
