#include <iostream>
#include <algorithm>
#include <cstdio>
#include <queue>
#include <math.h>
#include <limits.h>
#include <cstdlib>
#include <string.h>
#include <vector>
#include <map>
#include <stack>
using namespace std;
//mehulagarwal
#define ll         long long
#define S(x)       scanf("%d", &x)
#define Sl(x)      scanf("%lld", &x)
#define Sd(x)      scanf("%lf", &x)
#define P(x)       printf("%d\n", x)
#define Pl(x)      printf("%lld\n", x)
#define Pd(x)      printf("%lf\n", x)
#define Pblank()   printf(" ")
#define mem(x,y)   memset(x,y,sizeof(x))
#define F(x,y,z,i) for (x = y; x < z; x = x + i)
#define mod 1000000007

struct tt {
    ll int cur,l[3],r[3];
    ll int freq;
};

ll int a[100005];
tt tree[400005] = {-1};

void maketree(int node, int s, int e)
{
    if (s > e) {
        return;
    }
    if (s == e) {
        if (a[s] % 3 == 0) {
            tree[node].cur = 0;
            tree[node].freq = 1;
            tree[node].l[0] = tree[node].r[0] = 1;
            tree[node].l[1] = tree[node].r[1] = tree[node].l[2] = tree[node].r[2] = 0;
        } else if (a[s] % 3 == 1) {
            tree[node].cur = 1;
            tree[node].freq = 0;
            tree[node].l[1] = tree[node].r[1] = 1;
            tree[node].l[0] = tree[node].r[0] = tree[node].l[2] = tree[node].r[2] = 0;
        } else {
            tree[node].cur = 2;
            tree[node].freq = 0;
            tree[node].l[2] = tree[node].r[2] = 1;
            tree[node].l[1] = tree[node].r[1] = tree[node].l[0] = tree[node].r[0] = 0;
        }
        return;
    }

    int mid;
    mid = (s+e)/2;
    maketree(2*node,s,mid);
    maketree(2*node +1,mid+1,e);

    tt z;
   // z.freq = z.l[0] = z.l[1] = z.l[2] = z.r[0] = z.r[1] = z.r[2] = z.cur = 0;
    z.freq = tree[node*2].freq + tree[(node*2) +1].freq;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            if ((i+j) % 3 == 0) {
                z.freq = z.freq + (tree[node*2].r[i]*tree[(node*2) +1].l[j]);
            }
        }
    }
    for (int i = 0; i < 3; i++) {
        z.l[i] = tree[node*2].l[i] + tree[(node*2) +1].l[(3-tree[node*2].cur+i)%3];
        z.r[i] = tree[(node*2) +1].r[i] + tree[node*2].r[(3-tree[(node*2) + 1].cur+i)%3];
    }
    z.cur = (tree[node*2].cur + tree[node*2 + 1].cur) % 3;
    tree[node] = z;
}

void update(int node, int s, int e, int pos, int val)
{
    if (s > e) {
        return;
    }
    if (s == e && s == pos) {
        if (a[pos]%3 == 0) {
            tree[node].cur = 0;
            tree[node].freq = 1;
            tree[node].l[0] = tree[node].r[0] = 1;
            tree[node].l[1] = tree[node].r[1] = tree[node].l[2] = tree[node].r[2] = 0;
        } else if (a[pos]%3 == 1) {
            tree[node].cur = 1;
            tree[node].freq = 0;
            tree[node].l[1] = tree[node].r[1] = 1;
            tree[node].l[0] = tree[node].r[0] = tree[node].l[2] = tree[node].r[2] = 0;
        } else {
            tree[node].cur = 2;
            tree[node].freq = 0;
            tree[node].l[2] = tree[node].r[2] = 1;
            tree[node].l[1] = tree[node].r[1] = tree[node].l[0] = tree[node].r[0] = 0;
        }
        return;
    }
    if (pos < s || pos > e) {
        return;
    }

    int mid;
    mid = (s+e)/2;
    update(node*2,s,mid,pos,val);
    update(node*2 +1,mid+1,e,pos,val);

    tt z;
    z.cur = (tree[node*2].cur + tree[node*2 + 1].cur) % 3;
    z.freq = tree[node*2].freq + tree[node*2 +1].freq;

    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            if ((i+j) % 3 == 0) {
                z.freq = z.freq + (tree[node*2].r[i]*tree[node*2 +1].l[j]);
            }
        }
    }
    for (int i = 0; i < 3; i++) {
        z.l[i] = tree[node*2].l[i] + tree[node*2 +1].l[(3-tree[node*2].cur+i)%3];
        z.r[i] = tree[node*2 +1].r[i] + tree[node*2].r[(3-tree[node*2 + 1].cur+i)%3];
    }
    tree[node] = z;

    return;
}

tt query(int node, int s, int e, int qs, int qe)
{
    //cout << s << " " << e << " " << qs << " " << qe << endl;
    if (qs > e || s > e || qe < s) {
        tt temp;
        temp.cur = 0;
        temp.freq = 0;
        temp.l[0] = temp.l[1] = temp.l[2] = temp.r[1] = temp.r[2] = temp.r[0] = 0;
        return temp;
    }
    if ((s >= qs) && (qe >= e)) {
        return tree[node];
    }

    int mid;
    tt q1,q2,z;
    mid = (s+e)/2;
    q1 = query(node*2,s,mid,qs,qe);
    q2 = query((node*2)+1,mid+1,e,qs,qe);

    z.freq = q1.freq + q2.freq;
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            if ((i+j) % 3 == 0) {
                z.freq = z.freq + (q1.r[i]*q2.l[j]);
            }
        }
    }
    for (int i = 0; i < 3; i++) {
        z.l[i] = q1.l[i] + q2.l[(3-q1.cur+i)%3];
        z.r[i] = q2.r[i] + q1.r[(3-q2.cur+i)%3];
    }
    z.cur = (q1.cur + q2.cur) % 3;

    return z;
}

int main()
{
    int n,m,i,p,val,qt,l,r;
    tt ans;
    string str;

    S(n);
    S(m);

    cin >> str;

    for (i = 0; i < n; i++) {
        a[i+1] = str[i] - '0';
    }

   /* for (i = 1; i <= n; i++)
        cout << a[i] << " ";
    cout << endl;*/
    maketree(1,1,n);

   /* for (i = 1; i < 10; i++) {
        cout << "node->" << i << " " << tree[i].cur << " " << tree[i].freq << " " << endl;
    }*/

    while (m--) {
        S(qt);
        if (qt == 1) {
            S(p);
            S(val);
            a[p] = val;
            update(1,1,n,p,val);
        } else {
            S(l);
            S(r);
            ans = query(1,1,n,l,r);
            //cout << endl << ans.cur << " " << ans.freq << endl;
            printf("%lld\n",ans.freq);
        }
    }

    return 0;
}
