#include <assert.h> 
#include <ctype.h> 
#include  <float.h> 
#include <math.h> 
#include <stdio.h> 
#include <string> 
#include <stdlib.h> 
#include <time.h> 
#include <algorithm> 
#include <numeric> 
#include <functional> 
#include <utility> 
#include <vector> 
#include <list> 
#include <set> 
#include <map> 
#include <queue> 
#include <stack> 
#include <sstream> 
#include <iostream>  
#include <memory.h>

using namespace std; 


int w[500000];
int z[500002];
int n, c;

deque<int> q1; deque<int> q2;
void add(int h) {
	while (!q1.empty() && q1.back() > h)
		q1.pop_back();
	q1.push_back (h);

	while (!q2.empty() && q2.back() < h)
		q2.pop_back();
	q2.push_back (h);
}
void remove(int removed) {
	if (!q1.empty() && q1.front() == removed)
		q1.pop_front();
	if (!q2.empty() && q2.front() == removed)
		q2.pop_front();
}

void calcCand() {
	fill(z, z + n + 2, 0);
	q1.clear();
	q2.clear();
	add(w[0]);
	int r = 0;
	for (int l = 0; l < n; l++) {
		while (r < n) {
			int f = q1.front();
			int l = q2.front();
			if (l - f > c)
				break;
			r++;
			add(w[r]);
		}
		z[r - l]++;
		remove(w[l]);
	}
	int t = 0;
	for (int i = n; i >= 1; i--) {
		z[i] += t;
		t = z[i];
	}
	assert (z[1] == n);
	
}

void solve(int M) {
	int l = 1, r = n;
	while (l < r) {
		int K = (l + r) / 2;
		if (z[K] > M) {
			l = K + 1;
		}
		else {
			r = K;
		}
	}
	assert (z[l] <= M);
	assert (l == 1 || z[l - 1] > M);
	printf("%d %d\n", l, z[l]);
}

int main(int argc, char* argv[])
{
	int t;
	for(scanf("%d",&t);t--;)
	{
		int q,a,b,d;
		scanf("%d %d %d %d %d %d",&n,&c,&q,&a,&b,&d);
		int x = min(n, 10000);
		for (int i = 0; i < x; i++) {
				scanf("%d",w+i);
		}
		for (int i = x; i < n; i++) {
			w[i] = (a * w[i - 1] + b * w[i - 2] + d) & ((1 << 30) - 1);
		}
		
		calcCand();
		while (q--) {
			int M;
			scanf("%d",&M);
			solve(M);
		}
	}

	return 0;

}