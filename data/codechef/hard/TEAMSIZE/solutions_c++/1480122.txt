#include <iostream>
#include <string.h>
#include <vector>
#include <queue>

using namespace std;

#define l64 long long
#define l32 int
#define BUFFER_SIZE 65536
#define MIN_LEN 20

l64 MODULO = 1073741824;
l32* logs;

long n, c, q;
l64* skill;
l32 BASE = 500000;

l32* counts = NULL;
l32* m;
l32* values;

int ops;


//queue<char> buffer_queue;

void fillBuffer(int min) {
	/*
	if( buffer_queue.size() < min ) {
		char buffer[BUFFER_SIZE];
		int c = fread(buffer, 1, BUFFER_SIZE, stdin);
		if(c) {
			for(int i=0; i<c; i++) {
				buffer_queue.push(buffer[i]);
			}
		}
	}*/
}

l32 ReadInt()
{
	l32 x;
	scanf("%ld", &x);
	/*
	fillBuffer(MIN_LEN);

	x=0;
	int neg=0;
	
	while(!buffer_queue.empty()) {
		char c = buffer_queue.front();
		if(c==10 || c==13 || c==32)
			buffer_queue.pop();
		else
			break;
	}
	while(!buffer_queue.empty()) {
		char c = buffer_queue.front();
		buffer_queue.pop();

		if(c==32 || c==10 || c==13) {
			return neg ? -x:x;
		} else if(c=='-') {
			neg=1;
		}

		x=x*10 + c-'0';
	}
	*/
	return x;
}

l64 ReadLong()
{
	l64 x;
	scanf("%lld", &x);
	/*
	fillBuffer(MIN_LEN);

	x=0;
	int neg=0;

	while(!buffer_queue.empty()) {
		char c = buffer_queue.front();
		buffer_queue.pop();

		if(c==' ') {
			return neg ? -x:x;
		} else if(c=='-') {
			neg=1;
		}

		x=x*10 + c-'0';
	}
	*/
	return x;
}

l32* ReadIntArray(l32* arr, l32 len)
{
	l32 pos=0;

	while(len-->0) {
		arr[pos++] = ReadInt();
	}

    return arr;
}

l32* ReadIntArray(l32 len)
{
	l32* res = new l32[len];
	l32 pos=0;

	while(len-->0) {
		res[pos++] = ReadInt();
	}

    return res;
}

l64* ReadLongArray(l32 len)
{
	l64* res = new l64[len];
	l32 pos=0;
	while(len-->0) {
		res[pos++] = ReadLong();
	}

    return res;
}

l64* ReadLongArray(l64* arr, l32 len)
{
	l32 pos=0;

	while(len-->0) {
		arr[pos++] = ReadInt();
	}

    return arr;
}

int main(int argc, char** argv)
{
	int t;
	
	int pp = 0;
    int lim = 1;

	logs = new l32[500001];
	logs[0]=0;
    for (int i = 1; i < 500001; i++)
    {
        if (i >= lim*2)
        {
            lim *= 2;
            pp++;
        }
        logs[i]=pp;
	}
	
	t = ReadInt();

	while(t-- > 0 ) {

            values = ReadIntArray(6);

            n = values[0];
            c = values[1];
            q = values[2];
            
            int a = values[3];
            int b = values[4];
            int d = values[5];

            int x = n < 10000 ? n:10000;

            skill = new l64[500000];
			ReadLongArray(skill, x);

            m = ReadIntArray(q);

			for (int i = x; i < n; i++)
				skill[i] = (l32)((((l64)skill[i - 1] * (l64)a % MODULO + (l64)skill[i - 2] * (l64)b % MODULO) % MODULO + (l64)d) % MODULO);

			int left=0;
			int right=0;
			int min=(int)skill[0];
			int max=(int)skill[0];

			int min_pointer_start=0;
			int min_pointer_end=0;

			int max_pointer_start=0;
			int max_pointer_end=0;

			int* mins = new int[500001];
			int* mins_indx = new int[500001];

			int* maxs = new int[500001];
			int* maxs_indx = new int[500001];

			int* lens = new int[500001];

			mins[0] = min;
			maxs[0] = max;
			mins_indx[0]=0;
			maxs_indx[0]=0;

			if(counts==NULL) counts = new l32[500001];

			for (int i = 0; i <= n; i++)
            {
                lens[i] = 0;
            }

			while(1) {
				if(max-min <= c)
					lens[left]=right-left+1;
				
				if(left==n-1) break;

				if(max-min <= c && right<n-1) {
					right++;
					
					while( min_pointer_end>=min_pointer_start && mins[min_pointer_end] >= skill[right] ) min_pointer_end--;
					mins[++min_pointer_end] = (int)skill[right];
					mins_indx[min_pointer_end] = right;

					while( max_pointer_end>=max_pointer_start && maxs[max_pointer_end] <= skill[right] ) max_pointer_end--;
					maxs[++max_pointer_end] = (int)skill[right];
					maxs_indx[max_pointer_end] = right;

				} else {
					left++;
					lens[left]=lens[left-1]-1;
					if(mins_indx[min_pointer_start]==left-1)
						min_pointer_start++;
					
					if(maxs_indx[max_pointer_start]==left-1)
						max_pointer_start++;
				}

				min = mins[min_pointer_start];
				max = maxs[max_pointer_start];
				
			}
			for (int i = 0; i <= n; i++)
            {
                counts[i] = 0;
            }

			for (int i = 0; i < n; i++)
            {
                counts[lens[i]] ++;
            }

			for (int i = n - 1; i >= 1; i--)
            {
                counts[i] += counts[i + 1];
            }

            for (int qidx = 0; qidx < q; qidx++)
            {
                int query = m[qidx];
                int left = 1;
                int right = n;

                int middle = (left + right) / 2;
                while (left < right)
                {
					ops++;

                    if (counts[middle] > query)
                    {
                        left = middle + 1;
                    }
                    else
                    {
                        right = middle;
                    }
                    middle = (left + right) / 2;
                }

				printf("%ld %ld\n", left, counts[left]);
                //outstream.WriteLine("{0} {1}", left, counts[left]);
            }
			
			delete[] skill;
	}
	
	delete[] counts;
	delete[] logs;
	
	return 0;
}