#include<algorithm>
#include<bitset>
#include<cassert>
#include<cctype>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<ctime>
#include<deque> 
#include<ext/numeric>
#include<fstream>
#include<functional>
#include<iomanip>
#include<iostream>
#include<limits>
#include<list>
#include<map>
#include<numeric>
#include<queue>
#include<set>
#include<sstream>
#include<stack>
#include<tr1/unordered_map>
#include<tr1/unordered_set>
#include<utility>
#include<vector>
using namespace std;

typedef long long int i64;

#define ForEach(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();++it) 


class FastInput {
	public:
		FastInput() {
			m_dataOffset = 0;
			m_dataSize = 0;
			m_v = 0x80000000;
		}
		uint32_t ReadNext() {
			if (m_dataOffset == m_dataSize) {
				int r = read(0, m_buffer, sizeof(m_buffer));
				if (r <= 0) return m_v;
				m_dataOffset = 0;
				m_dataSize = 0;
				int i = 0;
				if (m_buffer[0] < '0') {
					if (m_v != 0x80000000) {
						m_data[m_dataSize++] = m_v;
						m_v = 0x80000000;
					}
					for (; (i < r) && (m_buffer[i] < '0'); ++i);
				}
				for (; i < r;) {
					if (m_buffer[i] >= '0') {
						m_v = m_v * 10 + m_buffer[i] - 48;
						++i;
					} else {
						m_data[m_dataSize++] = m_v;
						m_v = 0x80000000;
						for (i = i + 1; (i < r) && (m_buffer[i] < '0'); ++i);
					}
				}
			}
			return m_data[m_dataOffset++];
		}
	public:
		uint8_t m_buffer[1<<19];
		uint32_t m_data[1<<19];
		size_t m_dataOffset, m_dataSize;
		uint32_t m_v;
};
class FastOutput {
	public:
		FastOutput() {
			m_dataOffset = 0;
		}
		~FastOutput() {
		}
		void Flush() {
			if (m_dataOffset) {
				if (write(1, m_data, m_dataOffset));
				m_dataOffset = 0;
			}
		}
		void PrintUint(uint32_t v, char d) {
			if (m_dataOffset + 11 > sizeof(m_data)) Flush();
			if (v < 100000) {
				if (v < 1000) {
					if (v < 10) {
						m_data[m_dataOffset + 0] = v + 48;
						m_dataOffset += 1;
					} else if (v < 100) {
						m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;
						m_data[m_dataOffset + 0] = v + 48;
						m_dataOffset += 2;
					} else {
						m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;
						m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;
						m_data[m_dataOffset + 0] = v + 48;
						m_dataOffset += 3;
					}
				} else {
					if (v < 10000) {
						m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 0] = v + 48;
						
						m_dataOffset += 4;
						
					} else {
						
						m_data[m_dataOffset + 4] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 0] = v + 48;
						
						m_dataOffset += 5;
						
					}
					
				}
				
			} else {
				
				if (v < 100000000) {
					
					if (v < 1000000) {
						
						m_data[m_dataOffset + 5] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 4] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 0] = v + 48;
						
						m_dataOffset += 6;
						
					} else if (v < 10000000) {
						
						m_data[m_dataOffset + 6] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 5] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 4] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 0] = v + 48;
						
						m_dataOffset += 7;
						
					} else {
						
						m_data[m_dataOffset + 7] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 6] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 5] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 4] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 0] = v + 48;
						
						m_dataOffset += 8;
						
					}
					
				} else {
					
					if (v < 1000000000) {
						
						m_data[m_dataOffset + 8] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 7] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 6] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 5] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 4] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 0] = v + 48;
						
						m_dataOffset += 9;
						
					} else {
						
						m_data[m_dataOffset + 9] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 8] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 7] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 6] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 5] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 4] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 3] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 2] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 1] = v - v / 10 * 10 + 48; v /= 10;
						
						m_data[m_dataOffset + 0] = v + 48;
						
						m_dataOffset += 10;
						
					}
					
				}
				
			}
			
			m_data[m_dataOffset++] = d;
			
		}
		
		void PrintChar(char d) {
			
			if (m_dataOffset + 1 > sizeof(m_data)) Flush();
			
			m_data[m_dataOffset++] = d;
			
		}
		
		void ReplaceChar(int offset, char d) {
			
			m_data[m_dataOffset + offset] = d;
			
		}
		
		
		
	public:
		
		uint8_t m_data[1<<19];
		
		size_t m_dataOffset;
		
};

FastInput g_fi;
FastOutput g_fo;

#define MAX 19

const int MOD=1<<30;

int A,B,C,D,N,Q;

int V[1<<MAX];
int Y[1<<MAX];
int M=0;

void init_case(){
	tr1::unordered_map<int,int> Map;
	//map<int,int> Map;
	multiset<int> Set;
	memset(Y,0,sizeof (Y));
	int s=0;
	for (int i=0;i<N;++i){
		while(s<N){
			if (!Set.size())Set.insert(V[s++]);
			else{
				int mn=*Set.begin(),mx=*Set.rbegin();
				//if(V[s] <= mn + C && V[s] >= mx - C){
				if(V[s]>=mn&&V[s]-mn<=C || V[s]<=mx&&mx-V[s]<=C){
				//if(1){
					Set.insert(V[s++]);
				}else break;
			}
		}		
		int w=Set.size();
		++Y[w];
		Set.erase(Set.find(V[i]));
	}
	for (int i=N-1;i>0;--i) Y[i]+=Y[1+i];
}	

int main(){
	int ncases;
	//scanf("%d",&ncases);
	ncases=g_fi.ReadNext();

	for(int kase=0;kase<ncases;++kase){
		//cerr<<"kase: "<<kase<<endl;
		//scanf("%d %d %d %d %d %d",&N,&C,&Q,&A,&B,&D);
		//N=input(),C=input(),Q=input(),A=input(),B=input(),D=input();
		N=g_fi.ReadNext(),C=g_fi.ReadNext(),Q=g_fi.ReadNext(),A=g_fi.ReadNext(),B=g_fi.ReadNext(),D=g_fi.ReadNext();
		{
			int m=0,n=min(N,10000);
			//cerr<<"m: "<<m<<", N: "<<N<<", n: "<<n<<endl;
			while(m<n){
				//scanf("%d",V+m);++m;
				V[m++]=g_fi.ReadNext();
			}
			//cerr<<"m: "<<m<<endl;
			while(m<N){
				V[m]=(1LL*A*V[m-1]+1LL*B*V[m-2]+D)%MOD;
				++m;
			}
		}
		
		init_case();
				
		
		while(Q--){
			int q;
			//scanf("%d",&q);
			q=g_fi.ReadNext();
			
			int f=-1,fv;
			int lo=1,hi=N;
			while(lo<=hi){
				int m=lo+hi>>1;
				int x=Y[m];
				if (x<=q){
					f=m,fv=Y[m];
					hi=m-1;
				}else lo=1+m;
			}
			if (f>-1){
				//printf("%d %d\n",f,fv);
				g_fo.PrintUint(f, ' '); g_fo.PrintUint(fv,'\n');
				//output(f,0); output(fv);
			}
			else{
				//printf("%d %d\n",Y[M-1].first+1,0);
				g_fo.PrintUint(2, ' '); g_fo.PrintUint(0,'\n');
				//output(Y[M-1].first+1,0); output(0);
			}
		}
	}
	g_fo.Flush();
	return 0;
}