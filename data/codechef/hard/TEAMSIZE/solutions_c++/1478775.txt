#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <climits>
#include <cfloat>
#include <ctime>
#include <cassert>
#include <map>
#include <utility>
#include <set>
#include <iostream>
#include <memory>
#include <string>
#include <vector>
#include <algorithm>
#include <functional>
#include <sstream>
#include <complex>
#include <stack>
#include <queue>
#include <numeric>
#include <list>
#include <iomanip>
   
using namespace std;
   

#define rep(i, n) for (int i = 0; i < (int)n; ++i)
#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)
#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)
#define all(c) (c).begin(), (c).end()
#define rall(c) (c).rbegin(), (c).rend()
#define CL(arr, val) memset(arr, val, sizeof(arr))
#define COPY(dest, src) memcpy(dest, src, sizeof(dest))
   
template <class T> void max_swap(T& a, const T& b) { a = max(a, b); }
template <class T> void min_swap(T& a, const T& b) { a = min(a, b); }

template <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }
template <class T> void uniq(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }

template <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }
template <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }
  
bool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }

template <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << "( " << p.first << ", " << p.second << " )"; return os; }
  
template <class T> void print(T a, int n, const string& deli = " ", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }
template <class T> void print(const T& c, const string& deli = " ", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }
template <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }
   
template <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }
template <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }
template <class T> void input2d(T& a, int w, int h) { for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> a[i][j]; }

void fast_io() { cin.tie(0); ios::sync_with_stdio(false); }
#define trace(x) (cout << #x << ": " << (x) << endl)

typedef long long ll;
typedef pair<int, int> pint;

const int dx[] = { 0, 1, 0, -1 };
const int dy[] = { 1, 0, -1, 0 };
  
const double PI = acos(-1.0);
const int mod = 1000000007;



int main()
{
    int T;
    scanf("%d", &T);
    while (T--)
    {
        const int MAXN = 500100;

        int n, c, q, a, b, d;
        scanf("%d%d%d%d%d%d", &n, &c, &q, &a, &b, &d);
        int X = min(n, 10000);
        static int skill[MAXN];
        for (int i = 0; i < X; ++i)
            scanf("%d", skill + i);

        const int mod = 1 << 30;
        for (int i = 10000; i < n; ++i)
            skill[i] = ((ll)a * skill[i - 1] + (ll)b * skill[i - 2] + d) % mod;



        static int ok_len[MAXN];
        static int min_deq[MAXN], max_deq[MAXN];
        int min_p = 0, min_q = 0;
        int max_p = 0, max_q = 0;
        for (int left = 0, i = 0; i < n; ++i)
        {
            while (min_p < min_q && skill[min_deq[min_q - 1]] >= skill[i])
                --min_q;
            min_deq[min_q++] = i;

            while (max_p < max_q && skill[max_deq[max_q - 1]] <= skill[i])
                --max_q;
            max_deq[max_q++] = i;


            while (skill[max_deq[max_p]] - skill[min_deq[min_p]] > c)
            {
                if (left == min_deq[min_p])
                    ++min_p;
                if (left == max_deq[max_p])
                    ++max_p;
                ++left;
            }

            ok_len[i] = i - left + 1;
        }
        sort(ok_len, ok_len + n, greater<int>());

        static int cand[MAXN];
        for (int k = n, num = 0; k > 0; --k)
        {
            while (num < n && k <= ok_len[num])
                ++num;
            cand[k] = num;
        }

        while (q--)
        {
            int m;
            scanf("%d", &m);

            int low = 0, high = n;
            while (low + 1 < high)
            {
                int k = (low + high) / 2;
                if (cand[k] <= m)
                    high = k;
                else
                    low = k;
            }

            printf("%d %d\n", high, cand[high]);
        }
    }
}
