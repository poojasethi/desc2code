#include <stdio.h>
#include <queue>
#include <vector>
#define MOD 1073741824;

using namespace std;

struct SS{
  int aw, ak;
};
struct SN{
  int id, val;
};

struct SLess{
  bool operator()(SN a, SN b){
    if(a.val > b.val) return true;
    if((a.val == b.val) && (a.id < b.id)) return true;
    return false;
  }
};
struct SMore{
  bool operator()(SN a, SN b){
    if(a.val < b.val) return true;
    if((a.val == b.val) && (a.id < b.id)) return true;
    return false;
  }
};
struct SQ{
  queue<SN> q;
  deque<SN> dl, dm;
};

int N, diff, jQ;
SN arr[500010];
SS s[500010];
int js;
int indexof[500010];
int count[500010];
int ans[500010];
SQ q;

void push(SN a){
  q.q.push(a);
  while(!q.dm.empty() && (q.dm.back().val <= a.val)) q.dm.pop_back();
  q.dm.push_back(a);
  while(!q.dl.empty() && (q.dl.back().val >= a.val)) q.dl.pop_back();
  q.dl.push_back(a);
}
void pop(){
  SN a = q.q.front();
  q.q.pop();
  if((a.val == q.dl.front().val) && (a.id == q.dl.front().id)) q.dl.pop_front();
  if((a.val == q.dm.front().val) && (a.id == q.dm.front().id)) q.dm.pop_front();
}
SN qtop(){
  return q.q.front();
}
SN qbig(){
  return q.dm.front();
}
SN qsmall(){
  return q.dl.front();
}

int main(){
  int jcase;
  int A, B, D;
  long long ll1, ll2;
  int idfront, idrear;
  int mini, maxi;
  int idmin, idmax, idlow;
  
//  freopen("in.txt", "r", stdin);
//  freopen("out.txt", "w", stdout);
  
  scanf("%d", &jcase);
  for(int icase=0; icase<jcase; icase++){
    scanf("%d %d %d %d %d %d", &N, &diff, &jQ, &A, &B, &D);
    if(N <= 10000){
      for(int i=0; i<N; i++){
        scanf("%d", &arr[i].val);
        arr[i].id = i;
      }
    }
    else{
      for(int i=0; i<10000; i++){
        scanf("%d", &arr[i].val);
        arr[i].id = i;
      }
      for(int i=10000; i<N; i++){
        ll1 = arr[i-1].val;
        ll1 *= A;
        ll2 = arr[i-2].val;
        ll2 *= B;
        ll1 += ll2;
        ll1 += D;
        ll1 %= MOD;
        arr[i].val = (int)ll1;
        arr[i].id = i;
      }
    }
    
    idfront = idrear = 0;
    while(!q.q.empty()) q.q.pop();
    while(!q.dl.empty()) q.dl.pop_back();
    while(!q.dm.empty()) q.dm.pop_back();
    js = 0;
    while(idfront < N){
      push(arr[idfront]);
      idfront++;
      maxi = qbig().val;
      mini = qsmall().val;
      if(maxi - mini > diff){
        s[js].aw = idrear;
        s[js].ak = idfront - 2;
        js++;
      }
      while(maxi - mini > diff){
        idmin = qsmall().id;
        idmax = qbig().id;
        idlow = idmin < idmax ? idmin : idmax;
        
        idrear = idlow + 1;
        while(qtop().id < idrear) pop();
        maxi = qbig().val;
        mini = qsmall().val;
      }
    }
    s[js].aw = idrear;
    s[js].ak = idfront - 1;
    js++;
    //for(int i=0; i<js; i++) printf("%d: %d - %d\n", i, s[i].aw, s[i].ak);
    //for(int i=499980; i<500000; i++) printf("%d: %d\n", i, arr[i].val);
    
    for(int i=0; i<N; i++) indexof[i] = -1;
    for(int i=0; i<js; i++) indexof[s[i].aw] = i;
    for(int i=0; i<N; i++){
      if(indexof[i] == -1) indexof[i] = A;
      else A = indexof[i];
    }
    
    for(int i=0; i<N; i++) count[i] = 0;
    for(int i=0; i<N; i++) count[s[indexof[i]].ak - i + 1]++;
    for(int i=0; i<N; i++) count[i+1] += count[i];
    for(int i=0; i<N; i++) count[i] = N - count[i];
    //for(int i=0; i<N; i++) printf("%d: %d\n", i + 1, count[i]);
    
    for(int i=0; i<N; i++) ans[i] = -1;
    for(int i=N-1; i>=0; i--) ans[count[i]] = i;
    A = -1;
    for(int i=0; i<N; i++){
      if(ans[i] == -1) ans[i] = A;
      else A = ans[i];
    }
    
    for(int i=0; i<jQ; i++){
      scanf("%d", &A);
      printf("%d %d\n", ans[A] + 1, count[ans[A]]);
    }
    //printf("N = %d diff = %d jQ = %d A = %d B = %d D = %d\n", N, diff, jQ, A, B, D);
  }
  return 0;
}
