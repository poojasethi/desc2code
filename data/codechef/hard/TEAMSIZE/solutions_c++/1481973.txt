#include <iostream>
#include <cstdio>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <queue>
#include <cmath>
#include <algorithm>
#include <climits>
#include <sstream>
#include <stack>
#include <cstring>
#include <iomanip>
#include <ctime>
using namespace std;
#define pb push_back
#define INF 1001001001
#define FOR(i,n) for(int (i)=0;(i)<(n);++(i))
#define FORI(i,n) for(int (i)=1;(i)<=(n);++(i))
#define mp make_pair
#define pii pair<int,int>
#define ll long long
#define vi vector<int>
#define SZ(x) ((int)((x).size()))
#define fi first
#define se second
#define wez(n) int (n); scanf("%d",&(n));
#define wez2(n,m) int (n),(m); scanf("%d %d",&(n),&(m));
#define wez3(n,m,k) int (n),(m),(k); scanf("%d %d %d",&(n),&(m),&(k));
inline void pisz(int n) { printf("%d\n",n); }
template<typename T,typename TT> ostream& operator<<(ostream &s,pair<T,TT> t) {return s<<"("<<t.first<<","<<t.second<<")";}
template<typename T> ostream& operator<<(ostream &s,vector<T> t){FOR(i,SZ(t))s<<t[i]<<" ";return s; }
#define IN(x,y) ((y).find((x))!=(y).end())
#define DBG(vari) cerr<<#vari<<" = "<<(vari)<<endl;
#define ALL(t) t.begin(),t.end()
#define FOREACH(i,t) for (typeof(t.begin()) i=t.begin(); i!=t.end(); i++)
#define TESTS wez(testow)while(testow--)
#define REP(i,a,b) for(int (i)=(a);(i)<=(b);++i)
#define REPD(i,a,b) for(int (i)=(a); (i)>=(b);--i)
#define REMAX(a,b) (a)=max((a),(b));
#define REMIN(a,b) (a)=min((a),(b));
#define IOS ios_base::sync_with_stdio(0);

#define N 500006
int skill[N], leftEnd[N], radiusCnt[N], minKForCandValue[N];

int main () {
   TESTS {
      wez3(n,C,queries)
      wez3(A,B,D)
      FORI(i,min(n,10000)) scanf("%d", skill+i);
      REP(i,10001,n) skill[i] = ((ll)A * skill[i-1] + (ll)B * skill[i-2] + D) % (1<<30);
      
      leftEnd[0] = 1;
      deque<pii> rosnacy, malejacy;
      FORI(i,n) {
         leftEnd[i] = leftEnd[i-1];
         
         while (!malejacy.empty() && malejacy.back().se <= skill[i]) malejacy.pop_back();
         malejacy.pb(mp(i, skill[i]));
         while (!malejacy.empty() && malejacy.front().se > skill[i]+C) {
            REMAX(leftEnd[i], malejacy.front().fi + 1);
            malejacy.pop_front();
         }
         
         while (!rosnacy.empty() && rosnacy.back().se >= skill[i]) rosnacy.pop_back();
         rosnacy.pb(mp(i, skill[i]));
         while (!rosnacy.empty() && rosnacy.front().se < skill[i]-C) {
            REMAX(leftEnd[i], rosnacy.front().fi + 1);
            rosnacy.pop_front();
         }
      }
      
      memset(radiusCnt, 0, sizeof(int)*(n+3));
      FORI(i,n) radiusCnt[i - leftEnd[i] + 1]++;
      vi radii; radii.reserve(n+3);
      REP(radius,1,n) while (radiusCnt[radius]--) radii.pb(radius);
      
      int cand = n;
      REP(candValue,0,n) minKForCandValue[candValue] = INF;
      FORI(k,n) {
         while (cand > 0 && radii[n-cand] < k) --cand;
         //v.pb(mp(-cand, k));
         REMIN(minKForCandValue[cand], k);
      }
      
      //sort(ALL(v));
      vector<pii> v;
      REPD(candValue,n,0) if (minKForCandValue[candValue] < INF) v.pb(mp(-candValue, minKForCandValue[candValue]));
            
      while (queries--) {
         wez(M)
         pii res = *lower_bound(ALL(v), mp(-M,-INF));
         printf("%d %d\n", res.se, -res.fi);
      }
   }
}
