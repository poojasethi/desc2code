// directives 
	#include <stdio.h>
	#include <vector>
	#include <map>
	#include <set>
	#include <deque>
	#include <queue>
	#include <algorithm>
	#include <iostream>
	#include <cmath>
	#include <cstring>
	#include <typeinfo>
	#include <sstream>
// 
using namespace std;
// macros 
	#define FOR(i,a,b)      for(int i(a);i<b;++i)
	#define REP(i,n)        FOR(i,0,n)
	#define FORD(i,a,b)      for(int i(a-1);i>=b;--i)
	#define CL(a,x)         memset(a,x,sizeof(a))
	#define FL(a,x)			fill_n(a,sizeof(a)/sizeof(a[0]),x)
	#define asort(a,n)		sort(a,a+n)
	#define vsort(v,n)		sort(v.begin(), v.begin()+n)
	#define sz(x)			x.size()
	#define all(x)			x.begin(), x.end()
	#define SSTR( x )		dynamic_cast< std::ostringstream & >( ( std::ostringstream() << std::dec << x ) ).str()
// 

typedef long long LL;
typedef vector<int> vi;
int rint() { int x; if(scanf("%d",&x)!=1) return -1; return x; }
string rstring() { static char buf[100000]; if(scanf("%s",buf)!=1) return ""; return buf; }

struct point {
	int x,y,n;
	int f1() const { return x+y; }
	int f2() const { return x-y; }
	int f3() const { return -x+y; }
	int f4() const { return -x-y; }
};
struct c1 {
	bool operator () (const point* a, const point *b) {
		return a->f1() < b->f1();
	}
};
priority_queue<point*, vector<point*>, c1> F1;
struct c2 {
	bool operator () (const point* a, const point *b) {
		return a->f2() < b->f2();
	}
};
priority_queue<point*, vector<point*>, c2> F2;
struct c3 {
	bool operator () (const point* a, const point *b) {
		return a->f3() < b->f3();
	}
};
priority_queue<point*, vector<point*>, c3> F3;
struct c4 {
	bool operator () (const point* a, const point *b) {
		return a->f4() < b->f4();
	}
};
priority_queue<point*, vector<point*>, c4> F4;

int v = 1, ans = 0;
set<int> removed;

void add(int x, int y) {
	point *p = new point();
	p->x = x^ans;
	p->y = y^ans;
	p->n = v++;
	F1.push(p);
	F2.push(p);
	F3.push(p);
	F4.push(p);
}
void remove (int n) {
	removed.insert(n^ans);
}

int maximalManhattenDist (int x, int y) {
	point p;
	p.x = x^ans;
	p.y = y^ans;
	while (!F1.empty() && removed.find(F1.top()->n) != removed.end()) F1.pop();
	while (!F2.empty() && removed.find(F2.top()->n) != removed.end()) F2.pop();
	while (!F3.empty() && removed.find(F3.top()->n) != removed.end()) F3.pop();
	while (!F4.empty() && removed.find(F4.top()->n) != removed.end()) F4.pop();
	int d = -1;
	if (!F1.empty()) d = max( d, F1.top()->f1() - p.f1() );
	if (!F2.empty()) d = max( d, F2.top()->f2() - p.f2() );
	if (!F3.empty()) d = max( d, F3.top()->f3() - p.f3() );
	if (!F4.empty()) d = max( d, F4.top()->f4() - p.f4() );
	return ans=d;
}

int main()
{
	int q = rint();
	char op[2];
	while (q--) {
		scanf("%s", op);
		if (op[0] == '+') {
			int x = rint(), y = rint();
			add (x,y);
		}
		if (op[0] == '-') {
			int n = rint();
			remove (n);
		}
		if (op[0] == '?') {
			int x = rint(), y = rint();
			printf("%d\n", maximalManhattenDist(x,y));
		}
	}
	
	return 0;
}
