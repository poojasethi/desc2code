//BISMILLAHIR RAHMANIR RAHIM
#include<stdio.h>
#include<string.h>
#include<math.h>
#include<stdlib.h>
#include<queue>
#include<set>
#include <iostream>
#include<stack>
#include<map>
#include<string>
#include<vector>
#include<algorithm>
#define N 1000000
#define sn scanf
#define pf printf
#define pb push

typedef long long int ll;
using namespace std;
struct T{
ll x,y,p;
 bool operator <(const T &b)const
 {
     return (b.x+b.y)<x+y;
 }
}tm1;
struct TT{
ll x,y,p;
 bool operator <(const TT &b)const
 {
     return (b.x+b.y)>x+y;
 }

}tm2;
struct S{
ll x,y,p;
 bool operator <(const S &b)const
 {
     return (b.x-b.y)<x-y;
 }
}tm3;
struct SS{
ll x,y,p;
 bool operator <(const SS &b)const
 {
     return (b.x-b.y)>x-y;
 }
}tm4;

char st[1000];
ll vis[1000000],bit[1000000];

void update(int idx,int val)
{
    int mx=500000;
    while(idx<=mx)
    {
        bit[idx]+=val;
        idx+=(idx&-idx);
    }
}
int read(int idx)
{
    int mx=0;
    while(idx>0)
    {
        mx+=bit[idx];
        idx-=(idx&-idx);
    }
    return mx;
}
int main()
{
   ll i,j,k,l,t,cs=1,r=1,s,m,n,a,b,c,d,e,f,g,h,u,v;
    memset(vis,0,sizeof(vis));
    memset(bit,0,sizeof(bit));
    priority_queue<T>a1;
    priority_queue<TT>a2;
    priority_queue<SS>a4;
    priority_queue<S>a3;
    sn("%lld",&t);
    n=1;ll ans=0;
    while(t--)
    {
       sn("%s",&st);
       if(st[0]=='+')
       {
           sn("%lld %lld",&u,&v);
           u=u^ans;
           v=v^ans;
           tm1.x=u;tm1.y=v;tm1.p=n;
           tm2.x=u;tm2.y=v;tm2.p=n;
           tm3.x=u;tm3.y=v;tm3.p=n;
           tm4.x=u;tm4.y=v;tm4.p=n;
           vis[n]=1;
           update(n,1);
           n++;
           a1.pb(tm1);
           a2.pb(tm2);
           a3.pb(tm3);
           a4.pb(tm4);
       }
      else if(st[0]=='-')
       {
           sn("%lld",&g);
           g=g^ans;
//           ll mid;
//           l=0;h=n;
//           while(l<=h)
//           {
//               mid=(l+h)/2;
//               v=read(mid);
//               if(v==g)
//               {
//                   if(mid-1>0&&read(mid-1)==g)
//                    h=mid-1;
//                   else
//                    break;
//               }
//               else if(v>g)
//                 h=mid-1;
//               else
//                 l=mid+1;
//
//           }
//           if(l<=h)
//          {
//               vis[mid]=0;
//            update(mid,-1);
//          }
        vis[g]=0;
       }
       else
       {
           sn("%lld %lld",&u,&v);
           u=u^ans;
           v=v^ans;
           h=0;
           while(!a1.empty())
           {
               tm1=a1.top();
               if(vis[tm1.p]==0)
               a1.pop();
               else
               {
                  h=max(h,abs(tm1.x+tm1.y-u-v));
                  break;
               }
           }
           while(!a2.empty())
           {
               tm2=a2.top();
               if(vis[tm2.p]==0)
               a2.pop();
               else
               {
                  h=max(h,abs(-tm2.x-tm2.y+u+v));
                  break;
               }
           }
           while(!a3.empty())
           {
               tm3=a3.top();
               if(vis[tm3.p]==0)
               a3.pop();
               else
               {
                  h=max(h,abs(tm3.x-tm3.y-u+v));
                  break;
               }
           }
           while(!a4.empty())
           {
               tm4=a4.top();
               if(vis[tm4.p]==0)
               a4.pop();
               else
               {
                  h=max(h,abs(-tm4.x+tm4.y+u-v));
                  break;
               }
           }
           ans=h;
           pf("%lld\n",ans);
       }
    }
    return 0;

}

/*
#include <bits/stdc++.h>
  #define _ ios_base::sync_with_stdio(0);cin.tie(0);
*/
