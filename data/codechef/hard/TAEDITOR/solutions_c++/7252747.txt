#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<ctime>
#include<assert.h>
 
#include<cmath>
#include<iostream>
#include<fstream>
 
#include<string>
#include<vector>
#include<queue>
#include<map>
#include<algorithm>
#include<set>
#include<sstream>
#include<stack>
#include<limits.h>
 
using namespace std;
 
#define MAX(a,b) ((a)>(b) ? (a) : (b))
#define MIN(a,b) ((a)<(b) ? (a) : (b))
#define EPS 1e-9
#define asdf exit(0);
#define AB(a) ((a)<(0) ? (-a) : (a))
#define EQ(a,b) ( (fabs(a-b)<EPS) ? (1) : (0))
 
 
 
 
 
typedef long long LL;
//typedef __int64 LL;
 
 
 
 
 
int tree[300010];
char store[300010];
int BIG;
 
 
int get(int pos)
{
    int ret=0,i;
    for(i=pos; i; i-=(i & -i )) ret+=tree[i];
    return ret;
}
void update(int pos,int val)
{
    int i;
    for(i=pos; i<=300004; i+=(i & -i )) tree[i]+=val;
}
 
 
 
 
// cumFree ta kon pos a ase oita bair kore
void ini_find()
{
    int i;
    for(i=20; i>=0; i--)
    {
        if( (1<<i) & 300004) break;
    }
    BIG=1<<i;
}
 
 
 
 
//1 to n bit ta kaj kore.
//returns maximum index where cumFre lives,
//if you want min ind where cumFre lives f=find(i,cumFree) v=get(i,f-1)  f=find(i,v-1)+1
int find(int cumFre)
{
    int idx = 0;
    int bitMask=BIG;//i think =n will be enough
 
    //cout<<BIG[id];
    //asdf
 
    while ( (bitMask != 0) && idx <=300004  )
    {
        //cout<<bitMask <<endl;
        int tIdx = idx + bitMask;
        if (tIdx<=300004 &&   cumFre >= tree[tIdx] )
        {
            idx = tIdx;
            cumFre -= tree[tIdx];
        }
        bitMask >>= 1;
    }
 
//use these to return index if the val is found otherwise return -1
    /*if (cumFre != 0)
    return -1;
    else*/
    return idx;
}
 
 
 
 
char in[400000];
struct Q
{
    int type;
 
    int pos,len;
    char *s;
 
    //vector<int> is;
    int *is;
 
}q[300010];
 
 
 
 
 
int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);
    int i,j,k,n,sum=0;
 
 
    ini_find();
 
    char tt[3];
    scanf("%d",&n);
 
 
 
    for(i=0;i<n;i++)
    {
        scanf("%s",&tt);
 
 
        if(tt[0]=='+')
        {
 
            q[i].type=0;
            scanf("%d",&q[i].pos);
            scanf("%s",in);
 
 
            q[i].s=new char[strlen(in)+1];;
            q[i].is=new int[strlen(in)];
 
 
 
            strcpy(q[i].s,in);
            q[i].len=strlen(in);
 
 
 
            if(0<=q[i].pos && q[i].pos<=sum) {}
            else while(1);
 
 
 
            q[i].pos+=2;
            sum+=q[i].len;
        }
        else
        {
            q[i].type=1;
            scanf("%d %d",&q[i].pos,&q[i].len);
 
 
            if(1<=q[i].pos && q[i].pos<=sum) {}
            else while(1);
 
 
 
            if(1<=(q[i].pos+q[i].len-1) && (q[i].pos+q[i].len-1)<=sum) {}
            else while(1);
 
 
            q[i].pos++;
 
 
 
 
            if(i==0) while(1);
            if(q[i].len==0) while(1);
        }
 
 
        //cout<<i<<" "<<sum<<endl;
 
        if(sum>300000) while(1);
    }
 
 
    for(i=1;i<=300004;i++) update(i,1);
 
 
 
 
 
 
    for(i=n-1;i>=0;i--)
    {
        if(q[i].type==0)
        {
            for(j=0;j<q[i].len;j++)
            {
                int id=find(q[i].pos-1)+1;
 
               // cout<<q[i].pos+j<<" "<<id<<endl;
 
 
                //cout<<id<<endl;
                if( (get(id)-get(id-1))!=1 ) while(1);
 
 
                if(store[id]) while(1);
 
 
                store[id]=q[i].s[j];
                update(id,-1);
 
                q[i].is[j]=id;
            }
          //  asdf
        }
    }
 
   // for(i=2;i<=7;i++) cout<<store[i]<<" "<<get(i)<<endl;
   // asdf
 
 
 
 
    memset(tree,0,sizeof(tree));
 
 
    update(1,1);
 
 
 
    for(i=0;i<n;i++)
    {
        if(q[i].type==0)
        {
            for(j=0;j<q[i].len;j++)
            {
                //if(get(q[i].is[j])-get(q[i].is[j]-1)) while(1);
 
                update(q[i].is[j],1);
            }
        }
        else
        {
            for(j=0;j<q[i].len;j++)
            {
                int id=find(q[i].pos+j-1)+1;
 
                printf("%c",store[id]);
            }
            printf("\n");
        }
    }
 
 
 
 
 
    return 0;
}
 