#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef pair<ll,ll> pll;
typedef map<ll,ll> mll;
typedef vector<ll,ll> vll;
typedef set<ll> sll;
typedef stack<ll> stll;
typedef stack< pair<ll,ll> > stpll;
typedef map<ll,pair<ll,ll> > mllpll;
typedef vector< pair<ll,ll> > vpll;
#define mk make_pair 
#define pb push_back
#define X first 
#define Y second 
#define tr(c,it) for(typeof((c).begin()) it = (c).begin(); it != (c).end(); it++)
#define rep(x,n)   for((x)=0;(x)<(n);(x)++)
#define mod 1000000007
const double eps=1e-15;
const double Max=1e+18;

inline void normal(ll& a) {
    a %= mod;
    (a < 0) && (a += mod);
}

inline ll mul(ll a, ll b) {
    a %= mod, b %= mod;
    normal(a), normal(b);
    return (a * b) % mod;
}
 
inline ll add(ll a, ll b) {
    a %= mod, b %= mod;
    normal(a), normal(b);
    return (a + b) % mod;
}
 
inline ll sub(ll a, ll b) {
    a %= mod, b %= mod;
    normal(a), normal(b);
    a -= b;
    normal(a);
    return a;
}

#define MAX 10e15

struct edge 
{ ll to, length; 

	edge(ll x,ll y)
	{
		to=x;
		length=y;
	}
};

vector< vector<edge> > Graph(500010);

vector<ll> min_distance(100010,MAX);

int par[100010];
    
ll dijkstra(ll source,ll target) {
    // memset(min_distance,MAX,sizeof(min_distance));
    min_distance[ source ] = 0;
    set< pair<ll,ll> > active_vertices;
    active_vertices.insert( make_pair(0,source) );
        
    while (!active_vertices.empty()) {
        ll where = active_vertices.begin()->second;
        // if (where == target) return min_distance[where];
        active_vertices.erase( active_vertices.begin() );
        ll n=Graph[where].size();
        for (ll i=0;i<n;i++) 
        {
        	edge e=Graph[where][i];
        	if (min_distance[e.to] > min_distance[where] + e.length) 
        	{
        		if(par[where]!=0) par[e.to]=par[where];
                active_vertices.erase( make_pair(min_distance[e.to], e.to) );
                min_distance[e.to] = min_distance[where] + e.length;
                active_vertices.insert( make_pair( min_distance[e.to], e.to ) );
            }
        }
    }
    return MAX;
}

int main()
{
	ios::sync_with_stdio(false);
	// cout<<min_distance.size()<<endl;
	ll n,m,k,i,j,x,y,z;
	cin>>n>>m>>k;
	vector< pair<int,edge> > Edges;
	ll S[k];
	for(i=0;i<k;i++) cin>>S[i];
	for(i=0;i<m;i++)
	{
		cin>>x>>y>>z;
		Graph[x].pb(edge(y,z));
		Graph[y].pb(edge(x,z));
		Edges.pb(mk(x,edge(y,z)));
	}
	for(i=0;i<k;i++) 
	{
		Graph[0].pb(edge(S[i],0));
		Graph[S[i]].pb(edge(0,0));
	}
	for(i=0;i<k;i++) par[S[i]]=S[i];

	dijkstra(0,0);
	ll ans=Max;
	for(i=0;i<m;i++)
	{
		if(par[Edges[i].X]!=par[Edges[i].Y.to]) ans=min(ans,min_distance[Edges[i].X]+
			min_distance[Edges[i].Y.to]+Edges[i].Y.length);
	}
	cout<<ans<<endl;
	return 0;
}