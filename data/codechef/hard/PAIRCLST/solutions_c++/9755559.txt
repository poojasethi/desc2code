#include <bits/stdc++.h>
using namespace std;
#define MAX 100005
#define INF 1e9
#define pii pair<int,int >
#define psi pair<string,int>
#define pb(x) push_back(x) 
struct comp {
    bool operator() (const pii &a, const pii &b) {
        return a.second > b.second;
    }
};
 
vector< pii > G[MAX];
int D[MAX];
int P[MAX];
bool F[MAX];
 int arr[100005];
int main() {
    int i, u, v,j, w, sz, nodes, edges, starting,ending;
    // create graph
    
    int n,m,k;
	scanf("%d %d %d",&n,&m,&k);
	for(i=0;i<k;i++)
	scanf("%d",&arr[i]);
    for(i=0;i<m;i++)
    {
    		scanf("%d %d %d",&u,&v,&w);
    		G[u].pb(pii(v,w));
    		G[v].pb(pii(u,w));
    }
    long long ans=1e15;
    priority_queue< pii, vector< pii >, comp > Q;
    for(int l=0; l<=n; l++) 
	{	
		P[l]=-1;
		D[l] = INF;
		F[l]=false;
	}
    for(i=0;i<k;i++)
    {
    	P[arr[i]]=arr[i];
    	D[arr[i]]=0;
    	Q.push(pii(arr[i],0));
    }
 			
    while(!Q.empty()) {
        u = Q.top().first;
        Q.pop();
        if(F[u]) continue;
        sz = G[u].size();
        for(i=0; i<sz; i++) {
            v = G[u][i].first;
            w = G[u][i].second;
            if(!F[v] && D[u]+w < D[v]) {
                D[v] = D[u] + w;
                P[v] = P[u];
                Q.push(pii(v, D[v]));
            }
        }
        F[u] = 1; // done with u
    }
    for(i=1;i<=n;i++)
    {
    	for(j=0;j<G[i].size();j++)
    	{
    		if(P[i]!=P[G[i][j].first])
    		{
    			ans=min(ans,(long long)(D[i]+D[G[i][j].first]+G[i][j].second));
    		}
    	}
    }
    		//printf("%d\n",D[ending]);
	
 	cout<<ans<<endl;
    //for(i=1; i<=nodes; i++) printf("Node %d, min weight = %d\n", i, D[i]);
    return 0;
} 