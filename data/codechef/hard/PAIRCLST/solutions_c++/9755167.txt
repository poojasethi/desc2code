
#include<bits/stdc++.h>
using namespace std;
#define D(x)        cout<<#x " = "<<(x)<<endl
#define un(x)       x.erase(unique(x.begin(),x.end()), x.end())
#define sf(n)       scanf("%d", &n)
#define sff(a,b)    scanf("%d %d", &a, &b)
#define sfff(a,b,c) scanf("%d %d %d", &a, &b, &c)
#define pb          push_back
#define mp          make_pair
#define xx          first
#define yy          second
#define hp          (LL) 999983
#define MAX         100000
typedef long long int LL;
typedef pair<int,int> pii;

vector<pii> edge[MAX+11];
vector<int> spcl;

int dist[MAX+11][4];
int frm[MAX+11][4];
bool done[MAX+11][4];
int vis[MAX+11];

struct node{
    int cost;
    int dnode;
    int snode;

    node(){}
    node(int _c, int _d, int _s):cost(_c), dnode(_d), snode(_s){}
};

bool operator < (const node &a, const node &b){
    return a.cost > b.cost;
}

priority_queue<node> Q;

void dijkstra()
{
    memset(dist, -1, sizeof(dist));
    int i, j, k, u, v, w;
    node cur;

    for(i = 0; i < spcl.size(); i++)
    {
        dist[spcl[i]][1] = 0;
        frm[spcl[i]][1] = spcl[i];
        vis[spcl[i]] = 1;

        Q.push(node(0, spcl[i], spcl[i]));
    }

    while(!Q.empty())
    {
        cur = Q.top(); Q.pop();
        u = cur.dnode;
        if(vis[u] == 2) continue;

        if(frm[u][vis[u]] != cur.snode)
        {
            vis[u]++;
            dist[u][vis[u]] = cur.cost;
            frm[u][vis[u]] = cur.snode;
        }

        if(done[u][vis[u]]) continue;
        done[u][vis[u]] = true;

        for(i = 0; i < (int) edge[u].size(); i++)
        {
            v = edge[u][i].xx;
            w = edge[u][i].yy;
            Q.push(node(w + cur.cost, v, cur.snode));
        }
    }
}

int main()
{
    //freopen("c:\\Users\\User\\Desktop\\in.txt", "r", stdin);
    //freopen("c:\\Users\\User\\Desktop\\out.txt", "w", stdout);

    int i, j, k, n, m, u, v, w;
    int mn = 2e9;

    sfff(n, m, k);
    for(i = 1; i <= k; i++)
    {
        sf(u);
        spcl.pb(u);
    }

    for(i = 1; i <= m; i++)
    {
        sfff(u,v,w);
        edge[u].pb(mp(v,w));
        edge[v].pb(mp(u,w));
    }

    dijkstra();
    for(i = 0; i < (int) spcl.size(); i++)
        mn = min(mn, dist[spcl[i]][2]);

    printf("%d\n", mn);
    return 0;
}

/*
4 3 2
1 4
1 2 1
2 3 1
3 4 1
*/

