/*Programmed by Ayush Jaggi*/

#include<bits/stdc++.h>

using namespace std;

#define pb push_back
#define mp make_pair
#define F first
#define S second
#define L(i,x,y) for(i=x;i<y;i++)
#define l0(i,x) for(i=0;i<x;i++)
#define l1(i,x) for(i=1;i<x;i++)
#define pd(n) printf("%d",n)
#define pdn(n) printf("%d\n",n)
#define pds(n) printf("%d ",n)
#define plld(n) printf("%lld",n)
#define plldn(n) printf("%lld\n",n)
#define pllds(n) printf("%lld ",n)
#define pc(n) printf("%c",n)
#define pn printf("\n")
#define ps printf(" ")
#define plf(n) printf("%.6lf",n)
#define plfn(n) printf("%.6lf\n",n)
#define plfs(n) printf("%.6lf ",n)
#define pllf(n) printf("%.6llf",n)
#define pllfn(n) printf("%.6llf\n",n)
#define pllfs(n) printf("%.6llf ",n)
#define psn(n) printf("%s\n",n)
#define pss(n) printf("%s ",n)
#define sd(n) scanf("%d",&n)
#define sld(n) scanf("%ld",&n)
#define slld(n) scanf("%lld",&n)
#define slf(n) scanf("%lf",&n)
#define ss(n) scanf("%s",n)
#define sc(n) scanf("%c",&n)
#define mem(n,m) memset(n,m,sizeof(n))
#define W(t) while(t--)

typedef long long LL;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef pair<int,int> ii;
typedef vector<string> VS;

template<class T> inline T gcd(T a, T b)
{
    return b ? gcd(b, a % b) : a;
}

/*inline void prime()
{
    int s, d, count=0;
    lb=sqrt(n);
    for(s=2; s<=lb; s++)
        if(!pr[s])
        {
            sieve[count++]=s;
            for(d=s*s; d<=n; d+=s)
                pr[d]=1;
        }
}

inline LL expo(LL base, int nent)
{
    if(nent==1)
        return base;
    else if(nent&1)
    {
        LL temp=expo(base,nent/2);
        temp=temp*temp*base;
        if(temp>=MOD)
            temp%=MOD;
        return temp;
    }
    else
    {
        LL temp=expo(base,nent/2);
        temp*=temp;
        if(temp>=MOD)
            temp%=MOD;
        return temp;
    }
}*/

LL MOD=1000000007;
int dp[2][100005];//only 2 rows required, previous and current since we don't need to print the string, so 100005*2 instead of 100005*205
//dp[0]->prev
//dp[1]->current
char s[100005], w[100005];

inline int min3(int x, int y, int z)
{
    if(x<=y && x<=z)
        return x;
    if(y<=z && y<=x)
        return y;
    if(z<=x && z<=y)
        return z;
}

int main()
{
    int t, a, b, k, l1, l2, ans, i, j, end, start, g;
    sd(t);
    W(t)
    {
        ss(s);
        ss(w);
        sd(a);
        sd(b);
        sd(k);
        if(b>2*a)
            b=2*a;//not necessary, dp will eventually figure this out
        ans=-1;
        l1=strlen(s);
        l2=strlen(w);
        if(!a)
            ans=0;
        else if(abs(l1-l2)<=k)//edit distance optimized
        {
            l0(i,l2+1)
            dp[0][i]=i*a;
            l1(i,l1+1)
            {
                dp[1][0]=i*a;
                end=i+k>l2?l2:i+k;
                start=i-k<1?1:i-k;
                if(start>1)
                    dp[1][start-1]=k+1;
                L(j,start,end+1)
                if(s[i-1]==w[j-1])
                    dp[1][j]=min3(dp[0][j-1],dp[1][j-1]+a,dp[0][j]+a);
                else
                    dp[1][j]=min3(dp[0][j-1]+b,dp[1][j-1]+a,dp[0][j]+a);
                L(j,start-1,end+1)
                dp[0][j]=dp[1][j];
                dp[0][end+1]=k+1;
            }
            if(dp[1][l2]<=k)
                ans=dp[1][l2];
        }
        pdn(ans);
    }
    return 0;
}
