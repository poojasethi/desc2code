#include <cassert>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <ctime>
#include <algorithm>
#include <vector>
#include <stack>
#include <queue>
#include <iostream>
typedef unsigned long long int ull;
typedef long long int ll;


int Y=0, X=0;
char C[701][701];
size_t ix[700][700];


struct pos
{
	pos(): x(), y() {}
	pos(int _x, int _y): x(_x), y(_y) {}
	pos &operator+= (pos const &d) { x+=d.x; y+=d.y; return *this; }
	pos operator+ (pos const &rhs) const { return pos(x+rhs.x,y+rhs.y); }
	pos operator- (pos const &rhs) const { return pos(x-rhs.x,y-rhs.y); }
	pos operator* (int m) const { return pos(x*m,y*m); }
	friend pos operator* (int m, pos const &rhs) { return pos(rhs.x*m,rhs.y*m); }
	friend std::ostream& operator<< (std::ostream &o, pos const &p) { o << "(" << p.x << "," << p.y << ")"; return o; }
	void rot_ccw90() { int m=y; y=x; x=-m; }
	void rot_cw90() { int m=y; y=-x; x=m; }
	int x, y;
};

/*
// http://code.google.com/p/menglin-icpc-code-library/source/browse/icpcLibrary/BiGraph_Match_Hopcroft_Karp.cpp
const int maxn = 700*700/8;
const int maxm = 700*700/8*4;
struct max_bipartite_matching_hopcroft_karp
{
	struct EDGE
	{
		int a, b;
		int next;
	};

	int nx, ny, m;
	EDGE edge[maxm];
	int edge_num;
	int first[maxn];
	int cx[maxn], cy[maxn];
	int distx[maxn], disty[maxn];
	int que[maxn];
	int head, tail;
	int ans;

	void Init()
	{
		int i, j;
		std::fill_n ( cx, maxn, -1 );
		std::fill_n ( cy, maxn, -1 );
		std::fill_n ( first, maxn, -1 );
		edge_num = 0;
		ans = 0;
	}

	void AddEdge ( int a, int b )
	{
		edge[edge_num].a = a;
		edge[edge_num].b = b;
		edge[edge_num].next = first[a];
		first[a] = edge_num++;
	}

	bool BFS ( void )
	{
		int i, j, k;
		bool flag ( 0 );
		int h, t;
		std::fill_n ( distx, maxn, 0 );
		std::fill_n ( disty, maxn, 0 );
		head = tail = 0;
		for ( i = 1; i <= nx; i++ )
		{
			if ( cx[i] == -1 ) que[tail++] = i;
		}
		while ( head != tail )
		{
			for ( h = head, t = tail; h != t; h = ( h + 1 ) % maxn )
			{
				i = que[h];
				for ( k = first[i]; k != -1; k = edge[k].next )
				{
					j = edge[k].b;
					if ( !disty[j] )
					{
						disty[j] = distx[i] + 1;
						if ( cy[j] == -1 ) flag = 1;
						else
						{
							distx[cy[j]] = disty[j] + 1;
							que[tail] = cy[j];
							tail = ( tail + 1 ) % maxn;
						}
					}
				}
			}
			head = t;
		}
		return flag;
	}

	bool DFS ( int i )
	{
		int j, k;
		for ( k = first[i]; k != -1; k = edge[k].next )
		{
			j = edge[k].b;
			if ( disty[j] == distx[i] + 1 )
			{
				disty[j] = 0;
				if ( cy[j] == -1 || DFS ( cy[j] ) )
				{
					cx[i] = j, cy[j] = i;
					return 1;
				}
			}
		}
		return 0;
	}

	int Hopcroft_Karp()
	{
		int i, j;
		while ( BFS() )
		{
			for ( i = 1; i <= nx; i++ )
			{
				if ( cx[i] == -1 && DFS ( i ) ) ans++;
			}
		}
		return ans;
	}
} wat;
*/


template <size_t N, size_t O>
struct max_bipartite_matching_hopcroft_karp
{
	static size_t const INF=size_t(-1);
	size_t ord[N];
	size_t adj[N][O];
	size_t nx, ny;
	size_t dist[N];
	size_t xy[N];

	bool bfs()
	{
		std::queue<size_t> q;
		for(size_t i=1; i<=nx; ++i)
		{
			if(xy[i]==0)
			{
				dist[i]=0;
				q.push(i);
			}
			else dist[i]=INF;
		}
		dist[0]=INF;
		while(!q.empty())
		{
			size_t u=q.front();
			q.pop();
			if(u!=0)
			{
				for(size_t i=0; i<ord[u]; ++i)
				{
					size_t v=adj[u][i];
					if(dist[xy[v]]==INF)
					{
						dist[xy[v]]=dist[u]+1;
						q.push(xy[v]);
					}
				}
			}
		}
		return dist[0]!=INF;
	}

	bool dfs(size_t u)
	{
		if(u!=0)
		{
			for(size_t i=0; i<ord[u]; ++i)
			{
				size_t v=adj[u][i];
				if(dist[xy[v]]==dist[u]+1)
				{
					if(dfs(xy[v]))
					{
						xy[v]=u;
						xy[u]=v;
						return true;
					}
				}
			}
			dist[u]=INF;
			return false;
		}
		return true;
	}

	size_t solve()
	{
		size_t matching=0;
		for(size_t i=0; i<=nx+ny; ++i)
			xy[i]=0;
		while(bfs())
			for(size_t i=1; i<=nx; ++i)
				if(xy[i]==0 && dfs(i))
					++matching;
		return matching;
	}
};


max_bipartite_matching_hopcroft_karp<701*701/8, 4> wat;


size_t solve(int m)
{
	// index every node in this group
	size_t n1=0, n2=0;
	for(pos p(0,0); p.y<Y; ++p.y)
		for(p.x=0; p.x<X; ++p.x)
			if((p.x+p.y/2*2)%4+p.y%2*4==m && C[p.y][p.x]=='F')
			{
				if(p.x/2%2)
					ix[p.y][p.x]=n1++;
				else ix[p.y][p.x]=n2++;
			}
	wat.nx=n1;
	wat.ny=n2;
	for(size_t i=0; i<=n1+n2; ++i)
		wat.ord[i]=0;

	// connect nodes in group
	for(pos p(0,0); p.y<Y; ++p.y)
		for(p.x=0; p.x<X; ++p.x)
			if((p.x+p.y/2*2)%4+p.y%2*4==m && C[p.y][p.x]=='F')
				if(p.x/2%2)
				{
					size_t i=ix[p.y][p.x];
					pos d(1,1);
					for(size_t rot=0; rot<4; ++rot)
					{
						pos p1=p+d;
						pos p2=p1+d;
						if(0<=p2.x && p2.x<X && 0<=p2.y && p2.y<Y
							&& C[p2.y][p2.x]=='F' && C[p1.y][p1.x]!='P')
						{
							wat.adj[i+1][wat.ord[i+1]++]=1+n1+ix[p2.y][p2.x];
						}
						d.rot_ccw90();
					}
				}

	// max cardinality matching
	size_t c=wat.solve();
	return n1+n2-c;
}


int main()
{
	while(1)
	{
		scanf("%d %d", &Y, &X);
		if(X==0 || Y==0)
			break;

		for(int y=0; y<Y; ++y)
			scanf("%s", C[y]);
		for(pos p(0,0); p.y<Y; ++p.y)
			for(p.x=0; p.x<X; ++p.x)
				if(C[p.y][p.x]=='G')
				{
					pos d(1,1);
					for(size_t rot=0; rot<4; ++rot)
					{
						pos p1=p+d;
						pos p2=p1+d;
						if(0<=p2.x && p2.x<X && 0<=p2.y && p2.y<Y
							&& C[p1.y][p1.x]!='P' && C[p2.y][p2.x]=='F')
						{
							C[p2.y][p2.x]='X';
						}
						d.rot_ccw90();
					}
				}

		size_t r=0;
		for(int m=0; m<8; ++m)
			r+=solve(m);
		printf("%zu\n", r);
	}
	return 0;
}

