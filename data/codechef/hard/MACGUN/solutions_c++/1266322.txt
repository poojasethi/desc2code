#include <string>
#include <vector>
#include <cstdlib>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <ctime>
#include <list>
#include <map>
#include <set>
#include <iostream>
#include <sstream>
#include <cstring>
#include <queue>
#include <cassert>
#include <cctype>
#define PB push_back
#define MP make_pair
#define MOD
#define INF
#define MAXN 701
using namespace std;
typedef pair<int, int> PII;
typedef unsigned long long ULL;
typedef long long LL;
int m, n;
int g[MAXN*MAXN][4], szg[MAXN*MAXN], part[2][MAXN*MAXN], szp[2], lkup[MAXN*MAXN], lt[MAXN*MAXN], rt[MAXN*MAXN];
bool vis[MAXN*MAXN];
char grid[MAXN][MAXN];
const int dx[] = {1, 1, -1, -1};
const int dy[] = {-1, 1, -1, 1};

bool inside(int x, int y)
{
    if(x<0 || y<0 || x>=m || y>=n)return false;
    return true;
}

bool findpath(int id, bool *check)
{
    if(check[id])return false;
    check[id] = true;
    int u = part[0][id];
    for(int i=0; i<szg[u]; i++)
    {
        int t1 = g[u][i];
        int t2 = lkup[t1];
        if(rt[t2]<0 || findpath(rt[t2], check))
        {
            lt[id] = t2, rt[t2] = id;
            return true;
        }
    }
    return false;
}
int main()
{
    while(true)
    {
        scanf("%d%d", &m, &n);
        if(!m && !n)break;
        int N = m*n;
        for(int i=0; i<m; i++)scanf("%s", grid[i]);

        for(int i=0; i<m; i++) for(int j=0; j<n; j++) if(grid[i][j] == 'G') for(int d=0; d<4; d++)
        {
            int x = i+dx[d], y = j+dy[d];
            if(!inside(x,y) || grid[x][y] == 'P')continue;
            x = x+dx[d], y = y+dy[d];
            if(!inside(x,y) || grid[x][y]!='F')continue;
            grid[x][y] = 'D';
        }

        for(int i=0; i<N; i++)szg[i] = 0;
        for(int i=0; i<m; i++) for(int j=0; j<n; j++) if(grid[i][j] == 'F') for(int d=0; d<2; d++)
        {
            int x = i+dx[d], y = j+dy[d];
            if(!inside(x,y) || grid[x][y]=='P')continue;
            x = x +dx[d], y = y+dy[d];
            if(!inside(x,y) || grid[x][y] != 'F')continue;
            g[i*n+j][szg[i*n+j]++] = x*n+y, g[x*n+y][szg[x*n+y]++] = i*n+j;
        }

        for(int i=0; i<N; i++)lkup[i] = -1;
        for(int i=0; i<N; i++)vis[i] = false;
        for(int i=0; i<m; i++) for(int j=0; j<n; j++) if(grid[i][j] != 'F') vis[i*n+j] = true;
        szp[0]=0, szp[1]=0;

        for(int i=0; i<(m*n); i++) if(!vis[i])
        {
            queue<int> Q;
            Q.push(i), Q.push(0), vis[i] = true, part[0][szp[0]++] = i, lkup[i] = szp[0]-1;
            while(!Q.empty())
            {
                int v = Q.front();
                Q.pop();
                int c = Q.front();
                Q.pop();
                for(int j=0; j<szg[v]; j++) if(!vis[g[v][j]])
                {
                    Q.push(g[v][j]), Q.push(1-c), vis[g[v][j]] = true;
                    part[1-c][szp[1-c]++] = g[v][j], lkup[g[v][j]] = szp[1-c]-1;

                }
            }
        }
        for(int i=0; i<N; i++)lt[i]=-1, rt[i] = -1;
        bool path;
        bool check[szp[0]];

        do
        {
            memset(check, false, sizeof(check));
            path = false;
            for(int i=0; i<szp[0]; i++) if(lt[i]<0 && !check[i])
                path |= findpath(i, check);
        }while(path);

        int R = 0;
        for(int i=0; i<szp[1]; i++) if(rt[i]<0) R++;
        R += szp[0];
        printf("%d\n", R);
    }
    return 0;
}
