#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define oo 1000000000
#define N 700 * 700 + 10
#define E 3000010
using namespace std;

struct edge
{
	int v,next;
}e[E];
int head[N],cx[N],cy[N];
int disx[N],disy[N];
int que[N*2],cnt,nx,ny;

void addedge(int u,int v)
{
	e[cnt].v = v;
	e[cnt].next = head[u];
	head[u] = cnt ++;
}

int bfs()
{
	for(int i = 1; i <= nx; i ++) disx[i] = 0;
	for(int j = 1; j <= ny; j ++) disy[j] = 0;
	int top  = 0,tail = 0;
	for(int i = 1; i <= nx; i ++) {
		if(cx[i] == -1){
			que[tail++] = i;
			disx[i] = 0;
		}
	}
	int flag = 0;
	while(top < tail) {
		int u =que[top ++];
		for(int i = head[u] ; i != -1; i = e[i].next) {
			if(disy[e[i].v] == 0) {
				disy[e[i].v] = disx[u] + 1;
				if(cy[e[i].v] == -1) flag = 1;
				else {
					disx[cy[e[i].v]] = disy[e[i].v] + 1;
					que[tail++] = cy[e[i].v];
				}
			}
		}
	}
	return flag;
}

int dfs(int u)
{
	for(int i = head[u]; i != -1; i = e[i].next) {
		if(disy[e[i].v] == disx[u] + 1) {
			disy[e[i].v] = 0;
			if(cy[e[i].v] == -1 || dfs(cy[e[i].v]) ) {
				cx[u] = e[i].v,cy[e[i].v] = u;
				return 1;
			}
		}
	}
	return 0;
}

int match()
{
	int ans = 0;
	while(bfs()) {
		for(int i = 1; i <= nx; i ++)
			if(cx[i] == -1 && dfs(i)) ans ++;
	}
	return ans;
}

char s[710][710];
int dir[4][2] = {-2,-2,-2,2,2,-2,2,2};
int visit[710][710],map[710][710],n,m;

int sure(int x,int y)
{
	return x >= 1 && x <= n && y >= 1 && y <= m;
}

int main()
{
	
	while(scanf("%d%d",&n,&m) != EOF) {
		if(!n && !m) break;
		for(int i = 1; i <= n; i ++)
			scanf("%s",s[i] + 1);
		for(int i = 1; i <= n; i ++)
			for(int j = 1; j <= m; j ++)
				visit[i][j] = 0;
		nx = ny = 0;
		int ans = 0;
		for(int i = 1; i <= n; i ++)
			for(int j = 1; j <= m; j ++)
				if(s[i][j] == 'P') visit[i][j] = 1;
				else if(s[i][j] == 'G') {
					visit[i][j] = 1;
					for(int k = 0; k < 4; k ++) {
						int x = i + dir[k][0];
						int y = j + dir[k][1];
						if(sure(x,y) && !visit[x][y] && s[x][y] == 'F' && s[(x + i) / 2][(y + j) / 2] != 'P') visit[x][y] = 1;
					}
				}
		for(int i = 1; i <= n; i ++)
			for(int j = 1; j <= m; j ++)
				if(!visit[i][j]) {
					ans ++;
					if(j % 4 == 1 || j % 4 == 2) map[i][j] = ++nx;
					else map[i][j] = ++ny;
				}
		cnt = 0;
		fill(head,head + nx + 10,-1);
		fill(cx,cx + nx + 10,-1);
		fill(cy,cy + ny + 10,-1);
		for(int i = 1; i <= n; i ++)
			for(int j = 1; j <= m; j ++)
				if(!visit[i][j]) {
					if(j % 4 == 1 || j % 4 == 2) {
						for(int k = 0; k < 4; k ++) {
							int x = i + dir[k][0];
							int y = j + dir[k][1];
							if(!sure(x,y) || visit[x][y]) continue;
							if(s[(x + i) / 2][(y + j) / 2] != 'P') addedge(map[i][j],map[x][y]);
						}
					}
				}
		printf("%d\n",ans - match());
	}
	return 0;
}

