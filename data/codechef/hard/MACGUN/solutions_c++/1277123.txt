#include <cstdio>
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define InMap(xx,yy) ( (xx)>=1&&(yy)>=1&&(xx)<=N&&(yy)<=M )
const int TrueN = 700*700 + 9 , MaxN = TrueN , INF  = 1000000000 , Dx[4] = { -1 , -1 , +1 , +1 } , Dy[4] = { -1 , +1 , -1 , +1 } ;
int N , M , id[709][709] , ntot , Adj[MaxN][5] , Side[MaxN] , Dist[MaxN] , Pair_G1[MaxN] , Pair_G2[MaxN] , Q[MaxN] , L , R ;
char Map[709][709] ;
void Init() { ntot = 0 ; }
int New( int side ) { Side[++ntot] = side ; Adj[ntot][0] = 0 ; return ntot ; }
void AddEdge( int u , int v ) { Adj[u][++Adj[u][0]] = v ; Adj[v][++Adj[v][0]] = u ; }
bool BFS() {
	L = 1 ; R = 0 ;	fo(v,1,ntot) if ( Side[v] == 0 ) if ( Pair_G1[v] == 0 ) Q[++R] = v ; fo(v,0,ntot) Dist[v] = INF ; while ( L <= R ) {
		int v = Q[L++] ; fo(i,1,Adj[v][0]) {
			int u =Adj[v][i] ; if ( Dist[u] == INF ) {
				Dist[u] = Dist[v] + 1 ; Dist[ Pair_G2[u] ] = Dist[u] + 1 ; if ( Pair_G2[u] != 0 ) Q[++R] = Pair_G2[u] ;
			}
		}
	}
	return ( Dist[0] != INF ) ;
}
bool DFS( int v ) {
	if ( v != 0 ) { fo(i,1,Adj[v][0]) {
			int u = Adj[v][i] ; if ( Dist[u] == Dist[v] + 1 ) {
				Dist[u] = INF ; if ( DFS( Pair_G2[u] ) ) {
					Pair_G2[u] = v ; Pair_G1[v] = u ; return 1 ;
				}
			}
		} return 0 ;
	} return 1 ;
}
int Hopcroft_Karp() {
	fo(v,0,ntot) Pair_G1[v] = Pair_G2[v] = 0 ; int matching = 0 ;
	while ( BFS() ) fo(v,1,ntot) if ( Side[v] == 0 ) if ( Pair_G1[v] == 0 ) if ( DFS(v) ) matching ++ ;
	return matching ;
}
int main(){
	while ( 2 == scanf( "%d%d" , &N , &M ) && ( N || M ) ) {
		Init() ; fo(i,1,N) { scanf("\n") ; fo(j,1,M) scanf( "%c" , &Map[i][j] ) ; }
		fo(i,1,N) fo(j,1,M) {
			id[i][j] = -1 ; if ( Map[i][j] != 'F' ) continue ; bool p = true ;
			fo(k,0,3) if ( InMap(i+2*Dx[k],j+2*Dy[k]) && Map[i+2*Dx[k]][j+2*Dy[k]] == 'G' && Map[i+Dx[k]][j+Dy[k]] != 'P' ) p = false ;
			if ( !p ) continue ; id[i][j] = New( i % 4 <= 1 ? 0 : 1 ) ;
		}
		fo(i,1,N) fo(j,1,M) if ( id[i][j] != -1 ) fo(k,2,3) if ( InMap(i+2*Dx[k],j+2*Dy[k]) && id[i+2*Dx[k]][j+2*Dy[k]] != -1 && Map[i+Dx[k]][j+Dy[k]] != 'P' )
			AddEdge(id[i][j] , id[i+2*Dx[k]][j+2*Dy[k]]) ;
		printf( "%d\n" , ntot - Hopcroft_Karp() ) ;
	}
}