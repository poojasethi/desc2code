/*
PROB:msquare
NAME:chen_yu2
LANG:C++
*/
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;
typedef long long LL;

int m, n;
char map[ 705 ][ 705 ];
bool canput[ 705 ][ 705 ];
int dir[ 4 ][ 2 ] = { { -2, -2 }, { 2, 2 }, { 2, -2 }, { -2, 2 } };
int matchx[ 500000 ], matchy[ 500000 ], id[ 705 ][ 705 ];
int xedge[ 500000 ][ 5 ];
bool bound( int x, int y )
{
    if ( x < 0 || y < 0 || x >= m || y >= n ) return false;
    return true;
}
struct node
{
    int x, y;
} xlist[ 500005 ], ylist[ 500005 ];
int xlist_size, ylist_size, que[ 500000 ];
int disx[ 500000 ], disy[ 500000 ];
bool attack( node &a, node &b )
{
    if ( abs( a.x - b.x ) == 2 && abs( a.y - b.y ) == 2 && map[ ( a.x + b.x ) / 2 ][ ( a.y + b.y ) / 2 ] != 'P' )
        return true;
    return false;
}
bool bfs()
{
    int qe = 0, qh = 0;
    for ( int i = 0; i < xlist_size; i++ )
    {
        if ( matchx[ i ] == -1 )
        {
            que[ qe++ ] = i;
            disx[ i ] = 0;
        }
    }
    //memset( disx, 0, xlist_size * sizeof( int ) );
    memset( disy, 0, ylist_size * sizeof( int ) );
    int v, t;
    bool flag = false;
    while ( qh < qe )
    {
        v = que[ qh++ ];
        for ( int i = 1; i <= xedge[ v ][ 0 ]; i++ )
        {
            t = xedge[ v ][ i ];
            if ( disy[ t ] == 0 )
            {
                disy[ t ] = disx[ v ] + 1;
                if ( matchy[ t ] == -1 )
                {
                    flag = true;
                    //matchy[ t ] = v;
                }
                else
                {
                    disx[ matchy[ t ] ] = disy[ t ] + 1;
                    que[ qe++ ] = matchy[ t ];
                }
            }
        }
    }
    return flag;
}
bool dfs( int a )
{
    for ( int i = 1; i <= xedge[ a ][ 0 ]; i++ )
    {
        int v = xedge[ a ][ i ];
        if ( disy[ v ] == disx[ a ] + 1 )
        {
            disy[ v ] = 0;
            if ( matchy[ v ] == -1 || dfs( matchy[ v ] ) )
            {
                matchx[ a ] = v;
                matchy[ v ] = a;
                return true;
            }
        }
    }
    return false;
}
int binmatch()
{
    int cnt = 0;
    memset( matchy, -1, ylist_size * sizeof( int ) );
    memset( matchx, -1, xlist_size * sizeof( int ) );
    for ( int i = 0; i < xlist_size; i++ )
    {
        for ( int j = 1; j <= xedge[ i ][ 0 ]; j++ )
        {
            int v = xedge[ i ][ j ];
            if ( matchy[ v ] == -1 )
            {
                matchy[ v ] = i;
                matchx[ i ] = v;
                cnt++;
                break;
            }
        }
    }
    while( bfs() )
        for ( int i = 0; i < xlist_size; i++ )
        {
            if ( matchx[ i ] == -1 && dfs( i ) )
                cnt++;
        }
    return cnt;
}
int main()
{
    while ( scanf( "%d %d", &m, &n ) == 2 && m && n )
    {
        xlist_size = ylist_size = 0;
        memset( canput, 0, sizeof( canput ) );
        memset( id, -1, sizeof( id ) );
        for ( int i = 0; i < m; i++ )
        {
            scanf( "%s", map[ i ] );
        }
        for ( int i = 0; i < m; i++ )
            for ( int j = 0; j < n; j++ )
            {
                if ( map[ i ][ j ] == 'P' )
                {
                    canput[ i ][ j ] = 1;
                }
                else if ( map[ i ][ j ] == 'G' )
                {
                    canput[ i ][ j ] = 1;
                    int px, py, mx, my;
                    for ( int k = 0; k < 4; k++ )
                    {
                        px = dir[ k ][ 0 ] + i;
                        py = dir[ k ][ 1 ] + j;
                        mx = ( px + i ) / 2;
                        my = ( py + j ) / 2;
                        if ( !bound( px, py ) ) continue;
                        if ( map[ mx ][ my ] != 'P' )
                            canput[ px ][ py ] = 1;
                    }
                }
            }
        node t;
        for ( int i = 0; i < m; i++ )
            for ( int j = 0; j < n; j++ )
            {
                if ( canput[ i ][ j ] == 0 )
                {
                    t.x = i, t.y = j;
                    if ( i % 4 < 2 )
                    {
                        //id[ i ][ j ] = xlist_size - 1;
                        xlist[ xlist_size++ ] = t;
                    }
                    else
                    {
                        id[ i ][ j ] = ylist_size;
                        ylist[ ylist_size++ ] = t;
                    }
                }
            }

        for ( int i = 0; i < xlist_size; i++ )
        {
            xedge[ i ][ 0 ] = 0;
            for ( int j = 0; j < 4; j++ )
            {
                int mx, my, px, py;
                mx = xlist[ i ].x + dir[ j ][ 0 ];
                my = xlist[ i ].y + dir[ j ][ 1 ];
                px = xlist[ i ].x + dir[ j ][ 0 ] / 2;
                py = xlist[ i ].y + dir[ j ][ 1 ] / 2;
                if ( !bound( mx, my ) || map[ px ][ py ] == 'P' ) continue;
                if ( id[ mx ][ my ] == -1 ) continue;
                xedge[ i ][ ++xedge[ i ][ 0 ] ] = id[ mx ][ my ];
            }
        }
        printf( "%d\n", xlist_size + ylist_size - binmatch() );
    }
    return 0;
}
