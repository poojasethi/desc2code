#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <map>
#include <cstdio>

using namespace std;

int x [ 100005 ], sq;
int v [ 100005 ], tmp [ 100005 ], ret [ 100005 ];
map < int , int > MP;

struct node
{
       int a , b, wh;
       
       node ( int A , int B , int C ) { a = A; b = B; wh = C; }
       
       bool operator < ( const node &t ) const
       {
            if ( a / sq != t.a / sq )
               return a / sq < t.a / sq;
            
            return b < t.b;
       }
};

vector < node > s;

int main()
{
    int n, k, r;
    
    scanf ( "%d%d" , &n , &k );
    
    sq = int ( sqrt ( n ) );
       
    for ( int i = 0; i < n; i++ )
    {
        scanf ( "%d" , &v[i] );
        tmp[i] = v[i];
    }
     
    sort ( tmp , tmp + n );
    
    for ( int i = 0; i < n; i++ )
        MP[tmp[i]] = i;
    
    for ( int i = 0; i < n; i++ )
        v[i] = MP[v[i]];
    
    scanf ( "%d" , &r );
    
    for ( int i = 0; i < r; i++ )
    {
        int a , b;
        
        scanf ( "%d%d" , &a , &b );
        
        s.push_back ( node ( a , b , i ) );
    }
    
    sort ( s.begin() , s.end() );
    
    k++;
    
    int lft = 0, rgh = 0, uk = 0;
    x[v[0]]++;
    
    if ( k == 1 )
       uk++;
    
    for ( int i = 0; i < r; i++ )
    {
        while ( lft < s[i].a ) { if ( x[v[lft]] == k ) uk--; x[v[lft]]--; lft++; } //cout << uk << endl;
        while ( lft > s[i].a ) { lft--; x[v[lft]]++; if ( x[v[lft]] == k ) uk++; } //cout << uk << endl;
        
        while ( rgh < s[i].b ) { rgh++; x[v[rgh]]++; if ( x[v[rgh]] == k ) uk++; } //cout << uk << endl;
        while ( rgh > s[i].b ) { if ( x[v[rgh]] == k ) uk--; x[v[rgh]]--; rgh--; } //cout << uk << endl;
        
        ret[s[i].wh] = uk;
    }
    
    for ( int i = 0; i < r; i++ )
        printf ( "%d\n" , ret[i] );
    
    return 0;
}
