#define _CRT_SECURE_NO_DEPRECATE

#include <iostream>
#include <cstdio>
#include <memory>
#include <vector>
#include <set>
#include <map>
#include <queue>
#include <list>
#include <stack>
#include <string>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <ctime>
#include <utility>

#define pb push_back
#define mp make_pair
#define pii pair<int,int>
#define LL long long
#define VI vector<int>
#define X first
#define Y second
#define sz(_v) ((int)_v.size())
#define all(_v) (_v).begin(),(_v).end()
#define FOR(i,a,b) for (int i(a); i<=(b); i++)
#define rep(i,a) FOR(i,1,a)
#define rept(i,a) FOR(i,0,a-1)
#define x1 X1
#define y1 Y1
#define sqr(a) ((a)*(a))
#define INF 2000000000

using namespace std;

int t[100100];
int n;

void update(int ind, int delta)
{
	for (; ind<n; ind=ind|(ind+1)) t[ind]+=delta;
}

int sum(int r)
{
	int res=0;
	for (; r>=0; r=(r&(r+1))-1) res+=t[r];
	return res;
}

int sum(int l, int r)
{
	if (l!=0) return sum(r)-sum(l-1);
	return sum(r);
}

int main()
{
	memset(t,0,sizeof t);
	int n,k;
	scanf("%d%d",&n,&k);
	vector< pii > a(n);
	::n=n;
	rept(i,n)
	{
		scanf("%d",&a[i].X);
		a[i].Y=i;
	}
	sort(all(a));
	VI d(n);
	d[a[0].Y]=0;
	rept(i,n-1)
	{
		if (a[i].X!=a[i+1].X) d[a[i+1].Y]=d[a[i].Y]+1;
		else d[a[i+1].Y]=d[a[i].Y];
	}
	scanf("%d",&n);
	vector< pair< int, pii > > Q(n);
	rept(i,n)
	{
		scanf("%d%d",&Q[i].Y.X,&Q[i].X);
		Q[i].Y.Y=i;
	}
	sort(all(Q));
	int k_v=d[a.back().Y]+1;
	vector< pii > count(k_v,mp(0,-1));
	int q=0;
	VI next(sz(a),-1);
	VI first(k_v,-1);
	VI last(k_v,-1);
	VI ans(sz(Q));
	rept(i,sz(a))
	{
		if (count[d[i]].Y!=-1) next[count[d[i]].Y]=i;
		count[d[i]].X++;
		count[d[i]].Y=i;
		if (first[d[i]]==-1) first[d[i]]=i;
		if (count[d[i]].X>k)
		{
			if (count[d[i]].X>k+1)
			{
				update(last[d[i]],-1);
				last[d[i]]=next[last[d[i]]];
				update(last[d[i]],1);
			}
			else
			{
				last[d[i]]=first[d[i]];
				update(last[d[i]],1);
			}
		}
		while (q<sz(Q) && Q[q].X==i)
		{
			ans[Q[q].Y.Y]=sum(Q[q].Y.X,Q[q].X);
			q++;
		}
	}
	rept(i,sz(ans))
	{
		printf("%d\n",ans[i]);
	}
	return 0;
}