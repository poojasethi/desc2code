#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
 
using namespace std;
 
typedef vector<int> vi; 
typedef vector<vi> vvi; 
typedef pair<int,int> ii; 
typedef long long ll;
#define sz(a) int((a).size()) 
#define pb push_back 
#define all(c) (c).begin(),(c).end() 
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) 
#define present(c,x) ((c).find(x) != (c).end()) 
#define cpresent(c,x) (find(all(c),x) != (c).end()) 
#define mp make_pair
#define go(i,n) for(int i=0;i<n;i++)
#define go3(i,j,n) for(int i=j;i<n;i++)


int fen[100005];


int sum(int r){
 int res=0;
 for(;r>=0;r=(r&(r+1))-1)
  {
   res+=fen[r];
   //printf("res+=fen[%d](%d)\n",r,fen[r]);
  }
 return res;
}

void inc(int i,int delta){
 for(;i<100001;i=(i|(i+1)))
  fen[i]+=delta;
}

int sum(int l,int r){
  //printf("query to sum sum(%d)=%d sum(%d)=%d\n",l-1,sum(l-1),r,sum(r));
  return sum(r)-sum(l-1);
}


struct reg{
public: 
  int index;
  int start;
  int end;
  reg(){}
  reg(int i,int st,int e){
  index=i;
  start=st;
  end=e;
  }
};

bool les(reg a,reg b){
 if(a.end<b.end) return true;
 if(a.end>b.end) return false;
 if(a.start<b.start) return true;
 if(a.start>b.start) return false;
 return a.index>b.index;
}

int a[100005];

void oku(){
 int n,k;
 scanf("%d%d",&n,&k);
 k++;

 map<int,int> memo;
 int iter=0;
 
 go(i,n)
 {
  scanf("%d",&a[i]);
  if(memo.count(a[i])==0) memo[a[i]]=iter++;
  a[i]=memo[a[i]];
 }


 int q,x,y;
 vector<reg> v;

 scanf("%d",&q);
 go(i,q){
 scanf("%d%d",&x,&y);
 v.pb(reg(i,x,y));
 }

 //go(i,sz(v))
 //cout<<v[i].index<<" "<<v[i].start<<" "<<v[i].end<<endl;

 sort(all(v),les);
 
 vvi vec(n,vi (0));
 iter=0;
 vi ans(q,0);

 go(i,n){

  int san=a[i];
  //printf("case %d:\n",san);
  int oc=vec[san].size();
  if(oc>=k)
   {
    inc(vec[san][oc-k],-1);
    //printf("removed from pos %d\n",vec[san][oc-k]);

   }
  vec[san].pb(i);
  oc++;
  
  if(oc>=k)
   {
    inc(vec[san][oc-k],1);
    //printf("added to pos %d\n",vec[san][oc-k]);
   }


  while(iter<q && v[iter].end==i)
  {
    ans[v[iter].index]=sum(v[iter].start,v[iter].end);
    //printf("ans[%d]=sum(%d,%d) iter=%d \n",v[iter].index,v[iter].start,v[iter].end, iter);
    iter++;
  }
 }



 go(i,q)
 printf("%d\n",ans[i]);

}


int main(){
//freopen("input.txt","r",stdin);
//freopen("output.txt","w",stdout);
oku();

return 0;}
