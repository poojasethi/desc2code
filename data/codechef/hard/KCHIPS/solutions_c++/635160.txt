#include<iostream>
#include<cstdio>
#include<memory.h>
#include<cstdlib>
#include<algorithm>
#include<cmath>
#include<string>
#include<map>
#include<cstring>
#include<vector>
#include<queue>
#include<stack>
#include<assert.h>
#include<set>
#include<deque>
#include<climits>
#include<utility>

using namespace std;

#define lc(i) (i<<1)
#define rc(i) ((i<<1)+1)
#define iscan(n) scanf("%d",&n)
#define cscan(n) scanf("%c",&n)
#define sscan(n) scanf("%s",n)

int tree[100000 + 10];
int n; // this is the maximum value of the index ...

int read(int idx)
{
	int ans = 0;
	while(idx > 0)
	{
		ans += tree[idx];
		idx -= (idx & -idx); // this will toggle the least significant bit that is set to 1, to 0.
	}
	return ans;
}

void update(int idx, int val)
{
	while(idx <= n)
	{
		tree[idx] += val; // updating all the places where the value stored contains the frequency of state[i] ..
		idx += (idx & -idx); // this i do not understand completely.. will come back later and see ....
	}
	return;
}

queue <int> m[100000 + 10];
int inp[100000 + 10];
pair <int,int> temp[100000 + 10];

typedef struct{
	int s,e,id,ans;
}node;

node query[100000 + 10];

bool compare_end(node n1, node n2){return n1.e < n2.e;}
bool compare_id(node n1, node n2){return n1.id < n2.id;}

int main()
{
	iscan(n);
	int i,q,x,y,k,cnt;
	iscan(k); ++k;
	for(i=1;i<=n;++i)
	{
		iscan(x);
		temp[i-1] = make_pair(x,i);
	}
	sort(temp,temp+n);
	cnt = 1;
	inp[temp[0].second] = cnt;
	for(i=1;i<n;++i)
	{
		if(temp[i].first > temp[i-1].first)
			++cnt;
		inp[temp[i].second] = cnt;
	}

	iscan(q);
	for(i=0;i<q;++i)
	{
		iscan(x);
		iscan(y);
		query[i] = (node){x+1,y+1,i+1,-1};
	}
	sort(query,query+q,compare_end);
	int j = 1,cur; // this is the inp parsed so far ...
	for(i=0;i<q;++i)
	{
		while(j <= query[i].e)
		{
			cur = inp[j];
			m[cur].push(j);
			if(m[cur].size() == k)
				update(m[cur].front(),1);
			if(m[cur].size() == k + 1)
			{
				update(m[cur].front(),-1);
				m[cur].pop();
				update(m[cur].front(),1);
			}
			++j;
		}
		query[i].ans = read(query[i].e) - read(query[i].s - 1);
	}
	sort(query,query+q,compare_id);
	for(i=0;i<q;++i)
		printf("%d\n",query[i].ans);
	return 0;
}
