#include <iostream>
#include <stdio.h>
#include <vector>
#include <algorithm>
#include <limits.h>

using namespace std;

struct Item {
    int p, q;
};

vector<Item> items[6];

bool checkAllItemsExist() {
    for (int i = 0; i < 6; i++)
        if (items[i].size() == 0)
            return false;
    return true;
}

bool cmp(const Item& a, const Item& b) {
    if (a.p != b.p)
        return a.p < b.p;
    return a.q > b.q;
}

int bestItemIndex(int minQ[6]) {
    int ind = -1, q = INT_MAX;
    for (int i = 0; i < 6; i++)
        if (minQ[i] < q)
            q = minQ[ind = i];
    return items[ind].size() ? ind : -1;
}

int main() {
    int N, T, type, p, q;
    int lastPrice[6], minQ[6];
    scanf("%d %d", &N, &T);
    while (N--) {
        scanf("%d %d %d", &type, &p, &q);
        Item item = {p, q};
        items[type - 1].push_back(item);
    }
    if (!checkAllItemsExist()) {
        printf("0\n");
        return 0;
    }
    for (int i = 0; i < 6; i++) {
        sort(items[i].begin(), items[i].end(), cmp);
    }
    for (int i = 0; i < 6; i++) {
        Item item = items[i].front();
        T -= item.p;
        minQ[i] = item.q;
        lastPrice[i] = item.p;
        items[i].erase(items[i].begin());
    }
    if (T < 0) {
        printf("0\n");
        return 0;
    }
    while (1) {
        int ind = bestItemIndex(minQ);
        if (ind == -1)
            break;
        Item item = items[ind].front();
        if (item.q < minQ[ind] || item.q == minQ[ind] && item.p > lastPrice[ind]) { // more money with lower quality
            items[ind].erase(items[ind].begin());
            continue;
        }
        if (T + lastPrice[ind] - item.p < 0)
            break;
        T += lastPrice[ind] - item.p;
        minQ[ind] = item.q;
        lastPrice[ind] = item.p;
        items[ind].erase(items[ind].begin());
    }
    printf("%d\n", *min_element(minQ, minQ + 6));

    return 0;
}
