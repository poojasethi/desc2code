#include<stdio.h>
#include<algorithm>
#include<vector>
#define INF 1000000
using namespace std;

typedef struct item
{
	int type,price,quality;
}item;

bool operator<(const item a,const item b)
{
	return a.type < b.type;
}

int size[6]={0};
int dp[6][1002]={0};
item items[6][100];

int MAX(int a,int b)
{
	return a > b ? a : b;
}

int MIN(int a,int b)
{
	return a < b ? a : b;
}

int findMin(int W)
{
	int i,j,temp,k;	
	item x;
	
	for(i=0;i<6;i++)
	{	
		for(j=0;j<=W;j++)
		{
			int max=0;
			// Considering all items of a common type
			for(k=0;k<size[i];k++)
			{
				x=items[i][k];
				
				// Can be purchased using the current amount
				if(x.price <= j)
				{
					if(i>0)
					temp=MIN(x.quality , dp[i-1][j-x.price]);
					
					else
					temp=x.quality;
				}
				
				// We are considering all possible combinations of items of type i to generate the sum j
				// we have to consider the minimum quality for all the combinations
				// The maximum out of those minimum qualities is our answer
				max=MAX(max,temp);
			}
			
			dp[i][j]=max;
		}
	}
	
	return dp[5][W];
}

int main()
{
	int n,w,i,j;
	int type,price,quality;
	int check[7]={0},flag=0;
	scanf("%d%d",&n,&w);

	for(i=0;i<n;i++)
	{
		scanf("%d%d%d",&type,&price,&quality);
		items[type-1][size[type-1]].type=type;
		items[type-1][size[type-1]].price=price;
		items[type-1][size[type-1]].quality=quality;
		check[type]=1;
		size[type-1]++;
	}
	
	for(i=1;i<=6;i++)
	{
		if(check[i]==0)
		{
			flag=1;
			break;
		}
	}
	
	if(flag==0)
	{	
		printf("%d\n",findMin(w));	
	}
	
	else
	printf("0\n");
	
	return 0;
}