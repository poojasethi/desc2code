#pragma comment(linker, "/STACK:10000000")
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <iomanip>
#include <set>
#include <map>
#include <cstdio>
#include <cassert>
#include <string>
#include <cstring>
#define ldb long double
#define ll long long
#define fi first
#define se second
#define fill(a, c) memset(a, c, sizeof(a))
#define sqr(a) ((a) * (a))
#define nextLine() {int c = 0; while((c = getchar()) != 10 && c != EOF);}
#define getBit(mask, k) (((mask) / pw[k]) % pw[1])
#define setBit(mask, k, l) (((mask) / pw[k + 1] * pw[1] + (l)) * pw[k] + ((mask) % pw[k]))
#define mp(a, b) make_pair(a, b)
#define pb(a) push_back(a)
#define ff first
#define ss second 
using namespace std;
const int inf = 1000000007;
const ll mod = 1000000000 + 7;
int N, Q;
int a[123123], q[123123];
int result[123123];
ll fact[123123], invfact[123123];

void extgcd(ll a, ll b, ll &x, ll &y)
{
	if (b == 0)
	{
		x = 1;
		y = 0;
		return;
	}
	else
	{
		ll _x, _y;
		extgcd(b, a % b, _x, _y);
		x = _y;
		y = _x - (a / b) * _y;
	}
}

ll inverse(ll a)
{
	ll x, y;
	extgcd(a, mod, x, y);
	x %= mod;
	x += mod;
	x %= mod;
	return x;
}

void prepare()
{
	fact[0] = 1;
	invfact[0] = 1;
	for (int i = 1; i <= 100001; i++)
	{
		fact[i] = (fact[i - 1] * i) % mod;
		invfact[i] = inverse(fact[i]);
	}
}



void load()
{
	cin >> N;
	for (int i = 0; i < N; i++)
	{
		scanf("%d", &a[i]);
	}
	cin >> Q;
	for (int j = 0; j < Q; j++)
		scanf("%d", &q[j]);
}

inline int roundUp(int a, int b)
{
	int t = a / b;
	if (a % b) t++;
	return t;
}

inline int roundDown(int a, int b)
{
	if (b == 0) return inf;
	int t = a / b;
	if (a % b == 0)
		t--;
	return t;
}

class Event
{
	public:
		int x, type, val;
		Event(){}
		Event(int x, int type, int val) : x(x), type(type), val(val){}
};
vector <Event> ev;

inline bool operator < (const Event &e1, const Event &e2)
{
	return e1.x < e2.x || e1.x == e2.x && e1.type < e2.type;
}
ll res, res_whole, den_half, res_half;
int odd, sum;

inline void updateRes()
{
	if (odd <= 1)
	{
		res_half = (fact[sum / 2] * den_half) % mod;
		res = (res_whole - res_half) * invfact[2] + res_half;
		res %= mod;
	}
	else
		res = (res_whole * invfact[2]) % mod;
}
vector <int> all, all2;

void solve()
{
	for (int i = 0; i < N; i++)
	{
		/*all.resize(0);
		all2.resize(0);
		for (int t = 1; t * t <= a[i]; t++)
		{
			if (a[i] % t == 0)
			{
				all.pb(t);
				if (t * t != a[i])
					all2.pb(a[i] / t);
			}
		}
		for (int t = all2.size() - 1; t >= 0; t--)
			all.pb(all2[t]);
		all2.resize(0);
		for (int t = 0; t < all.size(); t++)
		{
			all2.pb(all[t]);
			if (t + 1 < all.size() && all[t + 1] != all[t] + 1)
				all2.pb(all[t] + 1);
		}
		*/
		for (int t = 1; t * t <= a[i]; t++)
		{
			int l = roundUp(a[i], t);
			int r = roundDown(a[i], t - 1);
			if (l <= r)
			{
				ev.pb(Event(l, -1, t));
				ev.pb(Event(r, 1, t));
			}
		}
		int r = 1, l = 1;
		int val = a[i];
		for (int t = 1; val * 1ll * val > (ll)a[i]; t++)
		{
			if (roundUp(a[i], t) != val)
			{
				ev.pb(Event(l, -1, val));
				ev.pb(Event(r, 1, val));
				l = t;
				val = roundUp(a[i], t);
			}
			r = t;
		}
	}
	for (int i = 0; i < Q; i++)
		ev.pb(Event(q[i], 0, i));
	sort(ev.begin(), ev.end());
	odd = 0;
	sum = 0;
	res_whole = 1;
	den_half = 1;
	res = 1;
	for (int i = 0; i < ev.size(); i++)
	{
//		cerr << "x = " << ev[i].x << " type = " << ev[i].type << " val = " << ev[i].val << "\n"; 
		if (ev[i].type == -1)
		{
			res_whole *= invfact[sum];
			res_whole %= mod;
			if (ev[i].val % 2 == 1)
				odd++;
			res_whole *= invfact[ev[i].val];
			res_whole %= mod;
			den_half *= invfact[ev[i].val / 2];
			den_half %= mod;
			sum += ev[i].val;
			res_whole *= fact[sum];
			res_whole %= mod;
		}
		else if (ev[i].type == 1)
		{
			res_whole *= invfact[sum];
			res_whole %= mod;
			if (ev[i].val % 2 == 1)
				odd--;
			res_whole *= fact[ev[i].val];
			res_whole %= mod;
			den_half *= fact[ev[i].val / 2];
			den_half %= mod;
			sum -= ev[i].val;
			res_whole *= fact[sum];
			res_whole %= mod;
		}
		else if (ev[i].type == 0)
		{
			updateRes();
			result[ev[i].val] = res;
		}
	}
	for (int i = 0; i < Q; i++)
	{
		printf("%d\n", result[i]);
	}
}



#define file "a"
int main()
{
	#ifndef ONLINE_JUDGE
	//	freopen(file".in", "rt", stdin);
	//	freopen(file".out", "wt", stdout);
	#endif
	prepare();
	load();
	solve();
	return 0;
}
