#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <fstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cassert>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <climits>
#include <cstring>

using namespace std;

typedef     long long         ll;
typedef     long double       ld;
typedef     pair<int,int>     pii;
typedef     pair<ll,ll>       pll;
typedef     vector<int>       vi;
typedef     vector<string>    vs;
typedef     map<int,int>      mii;
typedef     map<string,int>   msi;
typedef     map<char,int>     mci;
typedef     istringstream     iss;
typedef     ostringstream     oss;

#define     FOR(i,a,b)        for (int i=a; i<=b; i++)
#define     REP(i,a)          for (int i=0; i<a; i++)
#define     FIT(it,v)         for (typeof((v).begin())it=(v).begin(); it!=(v).end(); ++it)
#define     ALL(v)            (v).begin(),(v).end()
#define     SET(a,x)          memset((a),(x),sizeof(a))
#define     EXIST(a,b)        find(ALL(a),(b))!=(a).end()
#define     SORT(x)           sort(ALL(x))
#define     GSORT(x)          sort(ALL(x), greater<typeof(*((x).begin()))>())
#define     UNIQUE(v)         SORT(v); (v).resize(unique(ALL(v)) - (v).begin())
#define     PB                push_back
#define     MP                make_pair

template<typename T> inline string tostring(const T& x){oss os;os<<x;return os.str();}
inline int toint(const string& s){iss is(s);int x;is>>x;return x;}
inline int todecimal(string s){int a=0;REP(i,s.size())a=2*a+(s[i]-'0');return a;}
inline string tobinary( int a){string s;while(a!=0){s=(char)(a%2+'0')+s;a>>=1;}return s;}

template<typename T> inline T sqr(T x){return x*x;}
template<typename T> T gcd(T a,T b){return (b==0)?abs(a):gcd(b,a%b);}
inline int isvowel(char c){if(c=='a'||c=='e'||c=='i'||c=='o'||c=='u')return 1;return 0;}
inline int isprime(int a){for(int i=2;i*i<=a;i++)if(!(a%i))return 0;return 1;}

#define getcx getchar_unlocked
inline void inp( int &n )
{
       n = 0;
       int ch=getcx();int sign=1;
       while(ch<'0'||ch>'9'){if(ch=='-')sign=-1;ch=getcx();}
       while(ch>='0'&&ch<='9')n=(n<<3)+(n<<1)+ch-'0',ch=getcx();
       n = n*sign;
}

// main codes begin here //

const int maxn = 100005;
const int maxlg = 20;

int s[maxn];

struct entry {
    int nr[2];
    int pos;
} l[maxn];

int p[maxlg][maxn];

int stp, cnt;

bool cmp( entry a, entry b )
{
    if ( a.nr[0] != b.nr[0] ) return a.nr[0] < b.nr[0];
    return a.nr[1] < b.nr[1];
}

int n;
int height[maxn];
int rank[maxn];

int lcp( int x, int y )
{
    int ret = 0;

    for ( int k = stp-1; k >= 0 && x < n && y < n; k-- ) {
        if ( p[k][x] == p[k][y] ) {
            int z = 1<<k;
            x += z, y += z, ret += z;
        }
    }

    return ret;
}

void buildsuffix()
{
    REP( i, n ) p[0][i] = s[i];

    for ( stp = 1, cnt = 1; cnt < n; cnt <<= 1, stp++ ) {
        REP( i, n ) {
            l[i].nr[0] = p[stp-1][i];
            l[i].nr[1] = (i+cnt < n) ? p[stp-1][i+cnt] : -1;
            l[i].pos = i;
        }

        sort( l, l+n, cmp );

        REP( i, n ) {
            p[stp][l[i].pos] = ( i > 0 && l[i].nr[0] == l[i-1].nr[0] && l[i].nr[1] == l[i-1].nr[1] ) ? p[stp][l[i-1].pos] : i;
        }
    }
}

void solve()
{
    ll ans = n;
    ans *= n-1;
    ans /= 2;

    n--;

    REP( i, n ) s[i] = height[i+1] - height[i] + 101;

    buildsuffix();

    REP( i, n ) rank[p[stp-1][i]] = i;

    REP( i, n-1 ) ans -= lcp( rank[i], rank[i+1] );

    ans %= (ll)1e9 + 9;

    printf( "%d\n", (int)ans );
}

void input()
{
    inp( n );
    REP( i, n ) inp( height[i] );
}

int main()
{
    int testcase = 1;
    inp( testcase );

    REP( i, testcase ) {
        input();
        solve();
    }

    return 0;
}