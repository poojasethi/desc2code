//{{{
#include<iostream>
#include<algorithm>
#include<cmath>
#include<climits>
#include<vector>
#include<list>
#include<stack>
#include<queue>
#include<deque>
#include<stack>
#include<bitset>
#include<set>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<map>
#include<functional>
#include<numeric>
#include<utility>
#include<sstream>
#include<iomanip>
#include<cctype>
//#undef thecodegame
#ifdef thecodegame
    #include<debug.h>
#else
    #define DBG_ARR(a,b,c) {}
    #define DBG_MAT(a,s,b,c) {}
    #define DBG_VECT(a) {}
    #define db(...) {}
    #define dbt(x, ...) {}
#endif

using namespace std;

#define assert(f) {if(!(f)){fprintf(stderr,"Line-->%d  Assertion failed: %s \n",__LINE__,#f);exit(1);}}
#define MOD 	 1000000009LL
#define LL 		 long long
#define ULL      unsigned long long
#define ABS(x)   ((x)<0?-(x):(x))
#define SQR(x) 	 ((x)*(x))
#define CUBE(x)  ((x)*(x)*(x))
#define SD(n)    scanf("%d",&n)
#define SD2(n,m) scanf("%d %d",&n,&m)
#define SLL(n)   scanf("%lld",&n)
#define SLU(n)   scanf("%llu",&n)
#define SS(n)    scanf("%s",n)
#define pnl      printf("\n")
#define REP(i,n)        for(__typeof(n) i=0;i<(n);i++)
#define FOR(i,a,b)      for(__typeof(b) i=(a);i<(b);++i)
#define FORE(i,a,b)     for(__typeof(b) i=(a);i<=(b);++i)
#define FORD(i,a,b,d)   for(__typeof(b) i=(a);i<(b);i+=(d))
#define FORR(i,n,e)     for(__typeof(n) i=(n);i>=(e);--i)
#define FORRD(i,n,e,d)  for(__typeof(n) i=(n);i>=(e);i-=(d))
#define REP_IT(it,m)    for(it=m.begin();it!=m.end();it++)
#define FORI(it,s) 	    for(__typeof((s).begin()) (it)=(s).begin();(it)!=(s).end();(it)++)
#define FOREACH(it, X)  for(__typeof((X).begin()) it = (X).begin(); it != (X).end(); ++it)
#define UNIQUE(v)       sort(aLL(v)),v.erase(unique(aLL(v)),v.end())
#define FILL(a,b)       memset(a,b,sizeof(a))
#define ALL(v)          (v).begin(), (v).end()
#define RALL(v)         (v).rbegin(), (v).rend()
#define checkbit(n,b)    ( ((n) >> (b)) & 1)
#define PB push_back
#define MP make_pair
#define XX first
#define YY second

const double PI=acos(-1.0);
const double EPS=1e-11;
template<typename T>inline T mod(T N,T M){return (N%M+M)%M;}
template<typename T>inline void checkmin(T &a,T b){if(b<a)a=b;}
template<typename T>inline void checkmax(T &a,T b){if(b>a)a=b;}
class minHeap{public:bool operator()(int& c1,int& c2){return c1>c2;}};
class maxHeap{public:bool operator()(int& c1,int& c2){return c1<c2;}};
double start;//time
#ifdef amy
    #define getcx getchar
#else
    #define getcx getchar_unlocked
#endif
template<typename T>inline void inp(T &n){
    n=0;int ch=getcx();int sign=1;
    while(ch<'0'||ch>'9'){if(ch=='-')sign=-1;ch=getcx();}
    while(ch>='0'&&ch<='9'){n=(n<<3)+(n<<1)+ch-'0',ch=getcx();}
    n=n*sign;
}

//}}}
#define SIZE 100011
#define MAXX 100000009

//#define inp(x) SLL(x)
void pre(){}//end precompute



//namespace SuffixArray{
	const int MAXN = 111111;
// Begins Suffix Arrays implementation
// O(n log n) - Manber and Myers algorithm
// Refer to "Suffix arrays: A new method for on-line string searches",
// by Udi Manber and Gene Myers
 
//Usage:
// Fill str with the characters of the string.
// Call SuffixSort(n), where n is the length of the string stored in str.
// That's it!
 
//Output:
// pos = The suffix array. Contains the n suffixes of str sorted in lexicographical order.
//       Each suffix is represented as a single integer (the position of str where it starts).
// rank = The inverse of the suffix array. rank[i] = the index of the suffix str[i..n)
//        in the pos array. (In other words, pos[i] = k <==> rank[k] = i)
//        With this array, you can compare two suffixes in O(1): Suffix str[i..n) is smaller
//        than str[j..n) if and only if rank[i] < rank[j]
 
int str[MAXN]; //input
int rank[MAXN], pos[MAXN]; //output
int cnt[MAXN], next[MAXN]; //internal
bool bh[MAXN], b2h[MAXN];
 
// Compares two suffixes according to their first characters
bool smaller_first_char(int a, int b){
  return str[a] < str[b];
}
 
void suffixSort(int n){
  //sort suffixes according to their first characters
  for (int i=0; i<n; ++i){
    pos[i] = i;
  }
  sort(pos, pos + n, smaller_first_char);
  //{pos contains the list of suffixes sorted by their first character}
 
  for (int i=0; i<n; ++i){
    bh[i] = i == 0 || str[pos[i]] != str[pos[i-1]];
    b2h[i] = false;
  }
 
  for (int h = 1; h < n; h <<= 1){
    //{bh[i] == false if the first h characters of pos[i-1] == the first h characters of pos[i]}
    int buckets = 0;
    for (int i=0, j; i < n; i = j){
      j = i + 1;
      while (j < n && !bh[j]) j++;
      next[i] = j;
      buckets++;
    }
    if (buckets == n) break; // We are done! Lucky bastards!
    //{suffixes are separted in buckets containing strings starting with the same h characters}
 
    for (int i = 0; i < n; i = next[i]){
      cnt[i] = 0;
      for (int j = i; j < next[i]; ++j){
        rank[pos[j]] = i;
      }
    }
 
    cnt[rank[n - h]]++;
    b2h[rank[n - h]] = true;
    for (int i = 0; i < n; i = next[i]){
      for (int j = i; j < next[i]; ++j){
        int s = pos[j] - h;
        if (s >= 0){
          int head = rank[s];
          rank[s] = head + cnt[head]++;
          b2h[rank[s]] = true;
        }
      }
      for (int j = i; j < next[i]; ++j){
        int s = pos[j] - h;
        if (s >= 0 && b2h[rank[s]]){
          for (int k = rank[s]+1; !bh[k] && b2h[k]; k++) b2h[k] = false;
        }
      }
    }
    for (int i=0; i<n; ++i){
      pos[rank[i]] = i;
      bh[i] |= b2h[i];
    }
  }
  for (int i=0; i<n; ++i){
    rank[pos[i]] = i;
  }
}
// End of suffix array algorithm
 
 
// Begin of the O(n) longest common prefix algorithm
// Refer to "Linear-Time Longest-Common-Prefix Computation in Suffix
// Arrays and Its Applications" by Toru Kasai, Gunho Lee, Hiroki
// Arimura, Setsuo Arikawa, and Kunsoo Park.
int height[MAXN];
// height[i] = length of the longest common prefix of suffix pos[i] and suffix pos[i-1]
// height[0] = 0
void getHeight(int n){
  for (int i=0; i<n; ++i) rank[pos[i]] = i;
  height[0] = 0;
  for (int i=0, h=0; i<n; ++i){
    if (rank[i] > 0){
      int j = pos[rank[i]-1];
      while (i + h < n && j + h < n && str[i+h] == str[j+h]) h++;
      height[rank[i]] = h;
      if (h > 0) h--;
    }
  }
}
// End of longest common prefixes algorithm
LL ans;
int N;
void doThis(int cc){

	/********** always check the MOD value :P :P ***********/


	ans =0; /* silly me :P */
	inp(N);
	//scanf("%lld",&N);
	//assert(N>=1&&N<=100000);
	REP(i,N){
		inp(str[i]);
		//scanf("%lld",&arr[i]);
		//assert(ABS(arr[i])<=1000000);
		//
	}

	/*** fire in the hole *******/
	/****** bug spotted :D *******/


	if(N==1){
		puts("0");
		return;
	}
	if(N==2){
		puts("1");
		return;
	}

	N = N-1;
	REP(i,N){
		str[i]=(str[i+1]+100)-str[i];
	}
	suffixSort(N);
	getHeight(N);
	//buildSA();//first sa then lcp
	//buildLCP();

	REP(i,N){
		ans=((LL)ans+((N - pos[i]) - height[i+1]))%MOD;
	}
	//ans%=MOD;
	printf("%lld\n",ans);

}//end solve
void gen(){
	int T = 10000;
	printf("%d\n",T);
	int N = 10000;
	REP(i,T){
		printf("%d\n",N);
		REP(j,N){
			printf("%d ",rand()%(1<<11));
		}
		pnl;
	}
}
int main(){
start = clock();
#ifdef amy
	freopen("C:\\A\\in.txt","r",stdin);freopen("C:\\A\\out.txt","w",stdout);freopen("C:\\A\\out.txt","w",stderr);
#endif
int cases;
inp(cases);
FORE(i,1,cases){doThis(i);}
#ifdef amy
	fprintf(stdout,"\nTIME: %.3lf sec\n",(double)(clock()-start)/(CLOCKS_PER_SEC));
#endif
//while((clock()-start)<0.999*CLOCKS_PER_SEC){} // :D :D
return 0;
}//end main