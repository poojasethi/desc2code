#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define N 100001
#define sf scanf
#define pf printf
#define mod 1000000009

using namespace std;

int arr[N];
int h, bucket[N], temp_bucket[N], len;

struct Suffix
{
	int idx;
	bool operator<(const Suffix& sfx) const
	{
		if(h == 0)
		{
			return (arr[idx] < arr[sfx.idx]);
		}
		else if(bucket[idx] == bucket[sfx.idx])
		{
			if((idx+h) < len && (sfx.idx + h) < len)
				return (bucket[idx + h] < bucket[sfx.idx + h]);
			else
				return (idx > sfx.idx);
		}
		else
		{
			return (bucket[idx] < bucket[sfx.idx]);
		}
	}
	bool operator==(const Suffix& sfx) const
	{
		return (!(*this < sfx) && !(sfx < *this));
	}
};

Suffix pos[N];

bool update_buckets()
{
	bool c = false;
	int id = 0, start = 0;
	for(int i=0; i<len; i++)
	{
		if(i != 0 && !(pos[i] == pos[i-1]))
		{
			start = i;
			id++;
		}
		if(i != start)
			c = true;
		temp_bucket[pos[i].idx] = id;
	}
	memcpy(bucket, temp_bucket, sizeof(int) * len);
	return c;
}

void suffix_sort()
{
	for(int i=0; i<len; i++)
		pos[i].idx = i;
	sort(pos, pos + len);
	bool c = update_buckets();
	h = 1;
	while(c)
	{
		sort(pos, pos + len);
		c = update_buckets();
		h *= 2;
	}
}

long long distinct_subarrays()
{
	long long count = len - pos[0].idx;
	if(count >= mod)
			count %= mod;
	int same, j, k;
	for(int i=1; i<len; i++)
	{
		same = 0;
		j = pos[i-1].idx;
		k = pos[i].idx;
		while(j<len && k<len && (arr[j] == arr[k]))
		{
			same++;
			j++;
			k++;
		}
		count += (len - pos[i].idx - same);
		if(count >= mod)
			count %= mod;
	}
	return count;
}

int main()
{
	int t;
	sf("%d", &t);
	while(t--)
	{
		int n;
		sf("%d", &n);
		for(int i=0; i<n; i++)
		{
			sf("%d", &arr[i]);
			if(i>0)
				arr[i-1] -= arr[i];
		}
		len = n-1;
		h = 0;
		suffix_sort();
		pf("%lld\n", distinct_subarrays());
	}
	return 0;
}
