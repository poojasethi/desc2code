#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<set>
#include<map>
#include<string>
#include<string.h>
#include<cstring>
#include<stack>
#include<queue>
#include<cassert>
#include<cmath>
using namespace std;

#define LL long long int
#define PII pair<int,int>
#define PB push_back
#define MP make_pair
#define INF 1000000000
#define debug(args...) do {cerr << #args << ": "; dbg,args; cerr << endl;} while(0)
#define MOD 1000000007
vector<vector<int> > g;
LL dp[300000][2];
int vis2[300000];
int vis[300000];
vector<int> cycle_heads;
int  findcycle(int cnode,int par){
    if(vis2[cnode]){
        vis2[cnode] = 2;
        return 1;
    }
    vis2[cnode] = 1;
    for(int i=0;i<g[cnode].size();i++){
        if(g[cnode][i] == par)continue;
        int ret = findcycle(g[cnode][i],cnode);
        if(ret == 3)
            return 3;
        if(ret){
            cycle_heads.PB(cnode);
            if(vis2[cnode] == 2)return 3;
            return 1;
        }
    }
    return 0;
}

LL dfs(int cnode){
    vis[cnode] = 1;
    vis2[cnode] = 1;
    LL ret1 = 1,ret2 = 1;
    int i;
    for(i=0;i<g[cnode].size();i++){
        if(vis[g[cnode][i]] != 0)
            continue;
        dfs(g[cnode][i]);
        ret1 *= dp[g[cnode][i]][1];
        ret2 *= (dp[g[cnode][i]][0] + dp[g[cnode][i]][1]);
        if(ret1 >= MOD)
            ret1 %= MOD;
        if(ret2 >= MOD)
            ret2 %= MOD;
    }
    dp[cnode][0] = ret1;
    dp[cnode][1] = ret2;
    return 0;
}

map<PII,int> mp;
int main(){
    int t,n,i,x;
    scanf("%d",&t);
    while(t--){
        scanf("%d",&n);
        mp.clear();
        g.clear();
        g.resize(200000);
        memset(dp,-1,sizeof(dp));
        memset(vis,0,sizeof(vis));
        memset(vis2,0,sizeof(vis2));
        for(i=1;i<=n;i++){
            scanf("%d",&x);
            if(mp.count(MP(x,i)))continue;
            if(mp.count(MP(i,x)))continue;
            mp[MP(i,x)] = 1;
            g[x].PB(i);
            g[i].PB(x);
        }
        LL ans = 1;
        int j;
        LL oldret12,oldret22;
        for(i=1;i<=n;i++){
            if(vis2[i] != 0)continue;
            cycle_heads.clear();
            findcycle(i,-1);
            if(cycle_heads.size() > 1){
                LL ret11=0,ret12=1;
                LL ret21=1,ret22=1;
                for(j=0;j<cycle_heads.size();j++){
                    vis[cycle_heads[(j-1+(int)cycle_heads.size())%cycle_heads.size()]] = 1;
                    vis[cycle_heads[(j+1)%cycle_heads.size()]] = 1;
                    dfs(cycle_heads[j]);
                    if(j == 0){
                        ret21 = 0;
                        ret22 = dp[cycle_heads[j]][1];
                    }
                    if(j > 1 && j+1 != cycle_heads.size()){
                        oldret12 = ret12;
                        ret12 = ((oldret12 + ret11)*dp[cycle_heads[j]][1])%MOD; 
                        ret11 = (oldret12*dp[cycle_heads[j]][0])%MOD;
                        if(ret11 >= MOD)ret11 %= MOD;
                        if(ret12 >= MOD)ret12 %= MOD;
                    }
                    if(j > 0){
                        oldret22 = ret22;
                        ret22 = ((oldret22 + ret21)*dp[cycle_heads[j]][1])%MOD;
                        ret21 = (oldret22*dp[cycle_heads[j]][0])%MOD;
                        if(ret21 >= MOD)ret21 %= MOD;
                        if(ret22 >= MOD)ret22 %= MOD;
                    }
                    vis[cycle_heads[(j-1+(int)cycle_heads.size())%cycle_heads.size()]] = 0;
                    vis[cycle_heads[(j+1)%cycle_heads.size()]] = 0;
                }

                for(j=0;j<cycle_heads.size();j++)
                    vis[cycle_heads[j]] = 1;
                LL add = (ret11 + ret12);
                add *= dp[cycle_heads[1]][1];
                add %= MOD;
                add *= dp[cycle_heads[(int)cycle_heads.size()-1]][1];
                add %= MOD;
                add *= dp[cycle_heads[0]][0];
                add %= MOD;
                ans *= (add + ret21 + ret22)%MOD;
                ans %= MOD;
            }
            else{
                dfs(i);
                ans *= (dp[i][0]+ dp[i][1]);
                ans %= MOD;
            }
        }
        cout<<ans<<endl;
    }
    return 0;
}

