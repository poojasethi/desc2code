#include <algorithm>
#include <functional>
#include <vector>
#include <cmath>
#include <cstdio>
#include <cstring>

#define MOD_PRIME 1000000007
#define MAX_N 100000

using namespace std;

vector<int> neighbours[MAX_N];
vector<int> new_nodes;
vector<int> cycle_nodes;
bool visited[MAX_N];
bool in_cycle[MAX_N];
int parent[MAX_N];
int enemy[MAX_N];
int cycle[2];
int dp[MAX_N][2];
int fw[MAX_N][2];
int bw[MAX_N][2];

int addmod(int x, int y)
{
	int sum = x + y;
	if (sum >= MOD_PRIME)
		sum -= MOD_PRIME;
	return sum;
}

int addmod(int x, int y, int z)
{
	return addmod(x, addmod(y, z));
}

int mulmod(int x, int y)
{
	long long prod = x;
	prod *= y;
	return (int) (prod % MOD_PRIME);
}

void dfs(int root)
{
	new_nodes.push_back(root);
	int prev = parent[root];
	visited[root] = 1;
	for (vector<int>::iterator it = neighbours[root].begin(); it != neighbours[root].end(); ++it) {
		int node = *it;
		if (visited[node]) {
			if (node != prev && cycle[0] < 0) {
				cycle[0] = node;
				cycle[1] = root;
			}
		} else {
			parent[node] = root;
			dfs(node);
		}
	}
}

void mark_cycle()
{
	int node = cycle[1];
	if (node > 0) {
		while (node != cycle[0]) {
			in_cycle[node] = true;
			cycle_nodes.push_back(node);
			node = parent[node];
		}
		in_cycle[node] = true;
		cycle_nodes.push_back(node);
	}
}

void tree_dfs(int root)
{
	visited[root] = true;
	for (vector<int>::iterator it = neighbours[root].begin(); it != neighbours[root].end(); ++it) {
		int node = *it;
		if (!visited[node]) {
			tree_dfs(node);
			if (!in_cycle[node]) {
				dp[root][1] = mulmod(dp[root][1], dp[node][0]);
				dp[root][0] = mulmod(dp[root][0], addmod(dp[node][0], dp[node][1]));
			}
		}
	}
}

int solve_problem()
{
	int n;

	if (scanf("%d", &n) != 1)
		return 1;

	fill(enemy, enemy + n, -1);
	fill(in_cycle, in_cycle + n, false);
	fill(visited, visited + n, false);
	for (int i = 0; i < n; i++) {
		neighbours[i].clear();
		fill(dp[i], dp[i] + 2, 1);
		fill(bw[i], bw[i] + 2, 0);
	}

	for (int i = 0; i < n; i++) {
		int x;
		if (scanf("%d", &x) != 1)
			return 1;
		--x;
		enemy[i] = x;
		if (enemy[x] != i) {
			neighbours[i].push_back(x);
			neighbours[x].push_back(i);
		}
	}

	int result = 1;
	for (int i = 0; i < n; i++)
		if (!visited[i]) {
			fill(cycle, cycle + 2, -1);
			parent[i] = -1;
			new_nodes.clear();
			dfs(i);

			int j = cycle[0];
			int k;

			cycle_nodes.clear();
			if (j >= 0) {
				fill(cycle, cycle + 2, -1);
				for (vector<int>::iterator it = new_nodes.begin(); it != new_nodes.end(); ++it) {
					int node = *it;
					visited[node] = false;
					parent[node] = -1;
				}
				new_nodes.clear();
				dfs(j);

				mark_cycle();
				k = j;
			} else {
				k = i;
			}

			for (vector<int>::iterator it = new_nodes.begin(); it != new_nodes.end(); ++it) {
				int node = *it;
				visited[node] = false;
			}
			tree_dfs(k);

			if (j < 0) {
				int term = addmod(dp[k][0], dp[k][1]);
				result = mulmod(result, term);
			} else {
				int fw[2] = { dp[cycle_nodes.front()][0], 0 };
				for (size_t j = 1;j < cycle_nodes.size(); j++) {
					int crt = cycle_nodes[j];
					int tmp[2];
					tmp[0] = mulmod(dp[crt][0], addmod(fw[0], fw[1]));
					tmp[1] = mulmod(dp[crt][1], fw[0]);
					memcpy(fw, tmp, sizeof(tmp));
				}

				bw[cycle_nodes.front()][1] = dp[cycle_nodes.front()][1];
				for (size_t j = 1;j < cycle_nodes.size(); j++) {
					int crt = cycle_nodes[j];
					int prev = cycle_nodes[j - 1];
					bw[crt][1] = mulmod(dp[crt][1], bw[prev][0]);
					bw[crt][0] = mulmod(dp[crt][0], addmod(bw[prev][0], bw[prev][1]));
				}

				int term = addmod(fw[0], fw[1], bw[cycle_nodes.back()][0]);
				result = mulmod(result, term);
			}
		}

	printf("%d\n", result);

	return 0;
}

int main()
{
	int num_tests;

	if (scanf("%d", &num_tests) != 1)
		return 1;
	for (int i = 0; i < num_tests; i++)
		solve_problem();

	return 0;
}
