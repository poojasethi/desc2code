#include<cstdio>
#include<cstdlib>
#include<iostream>
#include<vector>
#include<algorithm>
#include<cstring>
#include<set>
#include<cassert>

using namespace std;

#define FOR(i, a, b) for(int i = a; i < b; i++)
#define REP(i, n) FOR(i, 0, n)
#define pb push_back
#define mp make_pair
#define ll long long
#define INF (int)1e9
#define LINF 1000000000000000000LL
#define mod 1000000007
#define N 100005
#define fill(a, v) memset(a, v, sizeof a);

int n;
bool found, vis[N], done[N];
int par[N];
vector<int> a[N], cycle;
ll take[N], notake[N];
ll takedp[N], notakedp[N];

void findcycle(int u)
{
    bool p = 0;
    if(found) return;
    vis[u] = 1;
    REP(i, a[u].size())
    {
        int v = a[u][i];
        if(v == par[u] and p == 0)
        {
            p = 1;
            continue;
        }
        if(vis[v] or (v == par[u] and p))
        {
            found = true;
            for(int x = u; x != par[v]; x = par[x])
            {
                cycle.pb(x);
            }
            return;
        }
        par[v] = u;
        findcycle(v);
        if(found) return;
    }
}

void dfs(int u)
{
    vis[u] = 1;
    done[u] = 1;
    take[u] = notake[u] = 1;
    REP(i, a[u].size())
    {
        int v = a[u][i];
        if(done[v]) continue;
        dfs(v);
        take[u] = take[u] * notake[v] % mod;
        notake[u] = notake[u] * (take[v] + notake[v]) % mod;
    }
}

ll solve(int u)
{
    found = 0;
    cycle.clear();
    findcycle(u);
    ll sol = 0;
    
    int c = cycle.size();
    
    REP(i, c) done[cycle[i]] = 1;
    REP(i, c) dfs(cycle[i]);
    
    REP(i, c) takedp[i] = notakedp[i] = 0;
    
    takedp[1] = take[cycle[1]];
    notakedp[1] = notake[cycle[1]];
    
    FOR(i, 2, c)
    {
        takedp[i] = take[cycle[i]] * notakedp[i-1] % mod;
        notakedp[i] = notake[cycle[i]] * (takedp[i-1] + notakedp[i-1]) % mod;
    }
    
    sol = notake[cycle[0]] * (takedp[c-1] + notakedp[c-1]) % mod;
    
    REP(i, c) takedp[i] = notakedp[i] = 0;
    
    if(c >= 4)
    {
        takedp[2] = take[cycle[2]];
        notakedp[2] = notake[cycle[2]];
        
        FOR(i, 3, c-1)
        {
            takedp[i] = take[cycle[i]] * notakedp[i-1] % mod;
            notakedp[i] = notake[cycle[i]] * (takedp[i-1] + notakedp[i-1]) % mod;
        }
        
        ll add = take[cycle[0]] * notake[cycle[1]] % mod;
        add = add * notake[cycle[c-1]] % mod;
        
        sol += add * (takedp[c-2] + notakedp[c-2]) % mod;
    }
    else
    {
        ll add = take[cycle[0]];
        FOR(i, 1, c) add = add * notake[cycle[i]] % mod;
        sol += add;
    }
    
    return sol;
}

int main()
{
    int test; scanf("%d", &test);
    while(test--)
    {
        scanf("%d", &n);
        
        REP(i, n) a[i].clear();
        fill(vis, 0);
        fill(done, 0);
        
        REP(u, n)
        {
            int v;
            scanf("%d", &v);
            a[u].pb(--v);
            a[v].pb(u);
        }
        REP(u, n) par[u] = -1;
        ll ans = 1;
        REP(u, n)
            if(!vis[u])
                ans = (ans * solve(u)) % mod;
        printf("%lld\n", ans);
    }
    system("pause");
    return 0;
}
