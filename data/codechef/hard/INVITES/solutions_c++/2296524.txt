#include <cstdio>
#include <vector>
#include <cstring>
#include <utility>
using namespace std;

#define long long long
#define fst first
#define snd second
typedef pair<int,int> pii;

const int MAXN = 100010, MOD = 1000000007;
int N;
vector<pii> adj[MAXN];
vector<pii> edges;
bool vis[MAXN];
int splitter;

void dfs(int at, int from = -1)
{
    vis[at] = true;
    for (int i=0; i<adj[at].size(); i++)
    {
        if (adj[at][i].fst != from)
        {
            if (vis[adj[at][i].fst])
            {
                if (splitter == -1)
                    splitter = adj[at][i].snd;
                continue;
            }
            dfs(adj[at][i].fst, at);
        }
    }
}

long cache[MAXN], ncache[MAXN];
int bad;

long ninvite(int, int);
long invite(int node, int parent = -1)
{
    if (cache[node] != 0) return cache[node];
    if (node == bad) return ninvite(node, parent);

    long &ans = cache[node];
    ans = 1;
    for (int i=0; i<adj[node].size(); i++)
    {
        if (adj[node][i].fst != parent && adj[node][i].snd != splitter)
            ans = (ans*ninvite(adj[node][i].fst, node))%MOD;
    }
    return ans = (ans+ninvite(node, parent))%MOD;
}
long ninvite(int node, int parent = -1)
{
    if (ncache[node] != 0) return ncache[node];

    long &ans = ncache[node];
    ans = 1;
    for (int i=0; i<adj[node].size(); i++)
    {
        if (adj[node][i].fst != parent && adj[node][i].snd != splitter)
            ans = (ans*invite(adj[node][i].fst, node))%MOD;
    }
    return ans;
}

void reset_cache(int at)
{
    if (cache[at] == 0 && ncache[at] == 0) return;
    cache[at] = ncache[at] = 0;
    for (int i=0; i<adj[at].size(); i++)
        reset_cache(adj[at][i].fst);
}

int rvis[MAXN];
void reset_cache(int at, int id)
{
    if (rvis[at] == id)
        return;
    rvis[at] = id;
    cache[at] = ncache[at] = 0;
    for (int i=0; i<adj[at].size(); i++)
        reset_cache(adj[at][i].fst, id);
}

int main()
{
    int t; scanf("%d", &t);
    while (t--)
    {
        scanf("%d", &N);
        for (int i=0; i<N; i++)
            adj[i].clear();
        edges.clear();
        for (int i=0; i<N; i++)
        {
            int a;
            scanf("%d", &a);
            a--;
            adj[i].push_back(make_pair(a, i));
            adj[a].push_back(make_pair(i, i));
            edges.push_back(make_pair(i, a));
        }
        memset(vis, false, sizeof(vis));
        memset(rvis, -1, sizeof(rvis));
        long ans = 1;
        for (int i=0; i<N; i++)
        {
            if (!vis[i])
            {
                splitter = -1;
                dfs(i);
                bad = -1;
                reset_cache(i, i);
                long cur = ninvite(edges[splitter].fst);
                reset_cache(i, N+i);
                cur += ninvite(edges[splitter].snd);
                reset_cache(i, 2*N+i);
                bad = edges[splitter].snd;
                cur = (cur-ninvite(edges[splitter].fst)+MOD)%MOD;
                ans = (ans*cur)%MOD;
            }
        }
        printf("%lld\n", ans);
    }
    return 0;
}
#undef long
#undef fst
#undef snd
