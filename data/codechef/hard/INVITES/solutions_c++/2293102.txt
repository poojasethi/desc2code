//Template

// By Anudeep :)
//Includes
#include <vector> 
#include <queue>
#include <map> 
#include <set>
#include <utility> //Pair
#include <algorithm>
#include <sstream> // istringstream>> ostring stream<<
#include <iostream> 
#include <iomanip> 
//setbase - cout << setbase (16); cout << 100 << endl; Prints 64
//setfill -   cout << setfill ('x') << setw (5); cout << 77 << endl; prints xxx77
//setprecision - cout << setprecision (4) << f << endl; Prints x.xxxx
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
using namespace std;

//M lazy ;)
typedef long long ll;
typedef vector <int> vi;
typedef vector <vi> vvi;
typedef vector <string> vs;
typedef pair< int ,int > pii;
typedef vector <ll> vll;
typedef istringstream iss;
typedef ostringstream oss;
#define pb push_back
#define mp make_pair
#define ff first
#define ss second
#define sz size()
#define ln length()
#define rep(i,n) for(int i=0;i<n;i++)
#define all(a)  a.begin(),a.end() 
#define ESP (1e-9)
#define N 222222
#define M 1000000007
vi adj[N];
vvi cycles;
int v[N],incycle[N],e[N];
int take[N],ntake[N];

void cdfs(int cur, int prev) {
	take[cur] = ntake[cur] = 1;
	rep(i,adj[cur].sz) if(adj[cur][i]!=prev && !incycle[adj[cur][i]]) {
		cdfs(adj[cur][i],cur);
		take[cur] = (1LL*take[cur]*ntake[adj[cur][i]])%M;
		ntake[cur] = (1LL*ntake[cur]*(take[adj[cur][i]] + ntake[adj[cur][i]]))%M;
	}
}

int dfs(int cur,vi &cycle) {
	if(v[cur]==2) return -1;
	if(v[cur]==1) return cur;
	v[cur] = 1;
	int ret = dfs(e[cur],cycle);
	if(ret != -1) {
		incycle[cur] = 1;
		cycle.pb(cur);
	}
	else incycle[cur] = 0;
	if(ret==cur) ret = -1;
	v[cur] = 2;
	return ret;
}

int sol(vi &cycle) {
	int k=cycle.sz;
	ll t,nt,nextt,nextnt,ret;
	//take 0th
	t = take[cycle[0]];
	nt = 0;
	for(int i=1;i<k;i++) {
		if(i==k-1) {
			//should not take this
			nextt = 0;
			nextnt = ntake[cycle[i]]*(nt+t);
		}
		else {
			nextt = take[cycle[i]]*nt%M;
			nextnt = ntake[cycle[i]]*(nt+t)%M;
		}
		t = nextt;
		nt = nextnt;
	}
	ret = (t+nt)%M;
	t = 0;
	nt = ntake[cycle[0]];
	for(int i=1;i<k;i++) {
		nextt = take[cycle[i]]*nt%M;
		nextnt = ntake[cycle[i]]*(nt+t)%M;
		t = nextt;
		nt = nextnt;
	}
	ret = (ret + t + nt)%M;
	return ret;
}
void solve() {
	int n;
	scanf("%d",&n);
	rep(i,N) {
		adj[i].clear();
		v[i] = 0;
	}
	cycles.clear();
	rep(i,n) {
		scanf("%d",&e[i+1]);
		adj[i+1].pb(e[i+1]); adj[e[i+1]].pb(i+1);
	}
	vi tmp;
	rep(i,n+1) if(i) {
		tmp.clear();
		dfs(i,tmp);
		if(tmp.sz>1) cycles.pb(tmp);
	}
	rep(i,n+1) if(i && incycle[i]) cdfs(i,i);
	ll ans=1;
	rep(i,cycles.sz) ans = ans*sol(cycles[i])%M;
	printf("%d\n",int(ans));
}

int main() {
	int t;
	scanf("%d",&t);
	while(t--) {
		solve();
	}
	return 0;
}