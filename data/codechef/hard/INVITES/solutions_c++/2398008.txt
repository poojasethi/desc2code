#include <cstdlib>
#include <string>
#include<stdio.h>
#include<vector>
#include<stack>
#include<queue>
#include<list>
#include<iostream>
#include<algorithm>
#include<math.h>
#include<string.h>
#include<stdlib.h>
#include<time.h>
#define snd(a) scanf("%d",&(a))
#define snlld(a) scanf("%lld",&(a))
#define fr(i,n) for((i)=0;(i)<(n);(i)+=1)
#define pb push_back
#define all(a) (a).begin(),(a).end()
#define sz size()
#define mp make_pair
#define N 100010
#define mod  1000000007
#define maxx 1000000000
#define vi vector<int>
#define vl vector<long long>
using namespace std;
typedef long long ll;
ll e[100010];//enemy
ll ch[100010],chv;//chosen
ll nch[100010],nchv;//not chosen
char fl[100010],incycle[100010];
int n;
vector<vl > c;//cycles
vector<vl> a(100010,vl());//aadjacency lst
int findcycle(int i,vl& tmp){//a multigraph(directed) with components having exactly 1 cycle (n nodes n edges)
   // cout<<i<<"\n";
    if(fl[i]==2){//node is already done, it cant be a part of cycle O-->(O )(: done)....
        return -1;
    }
    else if(fl[i]==1)return i;//cycle found.. this is the start of the cycle
    fl[i]=1;
    int j=findcycle(e[i],tmp);
    if(j!=-1){//start of cycle has been found
          incycle[i]=1;
          tmp.pb(i);
    }
    else{//head not found && dfs is returnning so this node is not in cycle
        incycle[i]=0;
    }
    fl[i]=2;//done
    if(j==i)return -1;// this was the last node on dfs stack which belonged to the cycle: start node of cycle
    else return j;
}
void comp_dfs(int i){//dfs over connected component//------------------------[DP on graph]---------------------------
    ch[i]=nch[i]=1;//chosen,not chosen
    for(int j=0;j<a[i].sz;j++){//adjacnenodes

        if(incycle[a[i][j]])
            {
         //  cout<<"incycle i="<<i<<"a[i][j]="<<a[i][j]<<"\n";
           continue;
            }
        comp_dfs(a[i][j]);
        ch[i]=(ch[i]*nch[a[i][j]])%mod;
        nch[i]=(nch[i]*(ch[a[i][j]]+nch[a[i][j]]))%mod;
    }

}
ll breakcycle(int i){
    chv=ch[c[i][0]];//start node of cycle is chosen
    nchv=0;
    ll ans=1,tmp;
    int j,k=c[i].sz;
    for(j=1;j<k;j++){
        if(j==k-1){//start node of cycle was chosen so last node must not be chosen
             tmp=chv;
            chv=0;
            nchv=(nch[c[i][j]]*(nchv+tmp))%mod;
        }
        else{
            tmp=chv;
            chv=(ch[c[i][j]]*nchv)%mod;
            nchv=(nch[c[i][j]]*(nchv+tmp))%mod;
        }

    }
    ans=nchv;
    chv=0;//start node of cycle is not chosen
    nchv=nch[c[i][0]];


    for(j=1;j<k;j++){


            tmp=chv;
            chv=(ch[c[i][j]]*nchv)%mod;
            nchv=(nch[c[i][j]]*(nchv+tmp))%mod;


    }
   return ans=(ans+chv+nchv)%mod; //both ch and nch has been added as both can be nonzero as since the first node is not chosen then the last node of cyclye may or may not b chosen
}
int main(){
    int t,i,j;
    snd(t);
    while(t--){

            snd(n);
            for(i=1;i<=n;i++){snlld(e[i]);a[e[i]].pb(i);}
            for(i=1;i<=n;i++){
                vl tmp;
                j=findcycle(i,tmp);
                if(tmp.sz)c.pb(tmp);
            }
          //  return 0;
            for(i=1;i<=n;i++){if(incycle[i])comp_dfs(i);
      //  cout<<"ch[i]="<<ch[i]<<" "<<"nch[i]="<<nch[i]<<"\n";
            }
            //join result of different components
            ll ans=1;
            for(i=0;i<c.sz;i++){
                ans=(ans*breakcycle(i))%mod;
            }
            cout<<ans<<"\n";
            for(i=1;i<=n;i++)a[i].erase(all(a[i]));
            c.erase(all(c));
            memset(fl,0,sizeof(fl));

    }
    return 0;
}
