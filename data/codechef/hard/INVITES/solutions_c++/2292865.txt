#include <iostream>
#include <fstream>
#include <sstream>
#include <string.h>
#include <algorithm>
#include <cmath>
#include <assert.h>
#include <stack>
#include <queue>
#include <list>
#include <vector>
#include <map>
#include <set>

#define for0(i,n) for (int i=0; i<n; i++)
#define forr(i,n) for (int i=n-1; i>=0; i--)
#define fori(i,a,b) for (int i=a; i<=b; i++)
#define iter(c,x) for(x::iterator it=c.begin(); it!=c.end(); it++)
#define vec(x) vector< x >
#define pb push_back
#define ms(a,z) memset(a,z,sizeof(a))
#define mp make_pair
#define nl cout<<"\n";
#define pr(x) cout<<(x)<<" ";
#define prl(x) cout<<#x " = "<<x<<endl;
#define prp(x) cout<<"("<<(x).first<<" "<<(x).second<<") ";
#define printv(v) {for(int _=0; _<v.size(); _++) cout<<v[_]<<" "; cout<<"\n";}
#define printa(a,s) {for (int _=0; _<s; _++) cout<<a[_]<<" "; cout<<"\n";}
#define print2D(a,m,n) {for (int _=0; _<m; _++) {for (int __=0; __<n; __++) cout<<a[_][__]<<" "; cout<<"\n";} cout<<"\n";}
#define debug cout<<"ok at line "<<__LINE__<<endl;
#define X first
#define Y second
#define sqr(x) 1LL*(x)*(x)
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define all(a) a.begin(),a.end()
#define read(x) scanf("%lld",&x);
#define int long long
#define prdp(i) cout<<dp[0][0][i]<<" "<<dp[0][1][i]<<"\n"<<dp[1][0][i]<<" "<<dp[1][1][i]<<"\n\n";

using namespace std;

typedef long long ll;

const int INF = 999999999;
const double EPSILON = 0.00000001;
const long long MOD = 1000000007;

int n;
vec(int) adj[100005];
bool is_cycle[100005], visited[100005], vis2[100005], vis3[100005];
int from[100005];
vec(int) order;
ll dp[2][2][100005];

void backtrack(int i)
{
    while (i != from[i] and from[i] != -1){
        is_cycle[i] = true;
        i = from[i];
    }
    is_cycle[i] = true;
}

int find_cycle_start(int start)
{
    vis3[start] = true;
    from[start] = -1;
    stack<int> s;
    s.push(start);

    while (not s.empty()){
        int top = s.top(); s.pop();
        iter(adj[top],vec(int)){
            if (vis3[*it] and *it != from[top]){
                return top;
            }
            else if (not vis3[*it]){
                from[*it] = top;
                vis3[*it] = true;
                s.push(*it);
            }
        }
    }
    return -1;
}

int find_cycle(int start)
{
    int ref = -1;
    visited[start] = true;
    from[start] = -1;
    stack<int> s;
    s.push(start);

    while (not s.empty()){
        int top = s.top(); s.pop();
        iter(adj[top],vec(int)){
            if (ref == -1 and visited[*it] and *it != from[top]){
                backtrack(top);
                backtrack(*it);
                ref = *it;
            }
            else if (not visited[*it]){
                from[*it] = top;
                visited[*it] = true;
                s.push(*it);
            }
        }
    }
    return ref;
}

void dfs(int start)
{
    vis2[start] = true;
    stack<int> s;
    s.push(start);

    while (not s.empty()){
        int top = s.top(); s.pop();
        if (not is_cycle[top]) order.pb(top);
        iter(adj[top],vec(int)){
            if (not vis2[*it]){
                vis2[*it] = true;
                s.push(*it);
            }
        }
    }
}

int32_t main()
{
    //freopen("P3_random.txt","r",stdin);
    int cases;
    cin >> cases;

    for0(casen,cases){
        cin >> n;
        for0(i,n) adj[i].clear();
        ll ans = 1;

        for0(i,n){
            int u;
            read(u);
            u--;
            adj[i].pb(u);
            adj[u].pb(i);
        }

        ms(is_cycle,false);
        ms(visited,false);
        ms(vis2,false);
        ms(vis3,false);
        ms(dp,-1);

        for0(i,n){
            if (not visited[i]){
                int ref = find_cycle(find_cycle_start(i));
                //prl(ref)
                //pr("is_cycle:") printa(is_cycle,n)
                order.clear();
                dfs(ref);
                //pr("order:") printv(order)

                vec(int) cycle;
                int cur = ref, pre = -1;
                while (true){
                    cycle.pb(cur);
                    bool flag = false;
                    iter(adj[cur],vec(int)){
                        if (is_cycle[*it] and *it != pre and *it != ref){
                            pre = cur;
                            cur = *it;
                            flag = true;
                            break;
                        }
                    }
                    if (not flag) break;
                }
                //pr("cycle:") printv(cycle)

                //nodes in branches from the cycle
                forr(j,(int)order.size()){
                    if (is_cycle[order[j]]) continue;
                    int node = order[j];

                    bool base = true, from_ref = false;
                    iter(adj[node],vec(int)){
                        if (*it == ref) from_ref = true;
                        if (dp[0][0][*it] != -1 and not is_cycle[*it]) base = false;
                    }

                    if (base){
                        dp[0][0][node] = 2;
                        dp[0][1][node] = dp[1][1][node] = 1;
                        dp[1][0][node] = 2-from_ref;
                        continue;
                    }

                    ll in0=1, ex0=1, in1=1, ex1=1;
                    iter(adj[node],vec(int)){
                        if (dp[0][0][*it] != -1 and not is_cycle[*it]){
                            in0 = (in0 * dp[0][1][*it]) % MOD;
                            in1 = (in1 * dp[1][1][*it]) % MOD;
                            ex0 = (ex0 * dp[0][0][*it]) % MOD;
                            ex1 = (ex1 * dp[1][0][*it]) % MOD;
                        }
                    }
                    dp[0][0][node] = (ex0+in0) % MOD;
                    dp[0][1][node] = ex0;
                    dp[1][0][node] = (ex1 + in1*(1-from_ref)) % MOD;
                    dp[1][1][node] = ex1;
                }

                //node at the end of the cycle
                int end = cycle[cycle.size()-1];
                bool base = true;
                iter(adj[end],vec(int)){
                    if (dp[0][0][*it] != -1) {
                        base = false;
                        break;
                    }
                }

                if (base){
                    dp[0][0][end] = 2;
                    dp[0][1][end] = dp[1][1][end] = 1;
                    dp[1][0][end] = 1;
                }
                else{
                    ll in0=1, ex0=1, in1=1, ex1=1;
                    iter(adj[end],vec(int)){
                        if (dp[0][0][*it] != -1){
                            in0 = (in0 * dp[0][1][*it]) % MOD;
                            in1 = (in1 * dp[1][1][*it]) % MOD;
                            ex0 = (ex0 * dp[0][0][*it]) % MOD;
                            ex1 = (ex1 * dp[1][0][*it]) % MOD;
                        }
                    }
                    dp[0][0][end] = (ex0+in0) % MOD;
                    dp[0][1][end] = ex0;
                    dp[1][0][end] = ex1;
                    dp[1][1][end] = ex1;
                }

                //nodes in the middle of the cycle
                for (int j=cycle.size()-2; j>=1; j--){
                    int node = cycle[j];
                    ll in0=1, ex0=1, in1=1, ex1=1;
                    iter(adj[node],vec(int)){
                        if (dp[0][0][*it] != -1){
                            in0 = (in0 * dp[0][1][*it]) % MOD;
                            in1 = (in1 * dp[1][1][*it]) % MOD;
                            ex0 = (ex0 * dp[0][0][*it]) % MOD;
                            ex1 = (ex1 * dp[1][0][*it]) % MOD;
                        }
                    }
                    dp[0][0][node] = (ex0 + in0) % MOD;
                    dp[0][1][node] = ex0;
                    dp[1][0][node] = (ex1 + in1) % MOD;
                    dp[1][1][node] = ex1;
                }

                //second node in cycle (if not end)
                /*if (cycle.size() > 2){
                    int node = cycle[1];
                    ll in0=1, ex0=1, in1=1, ex1=1;
                    iter(adj[node],vec(int)){
                        if (dp[0][0][*it] != -1){
                            in0 = (in0 * dp[0][1][*it]) % MOD;
                            in1 = (in1 * dp[1][1][*it]) % MOD;
                            ex0 = (ex0 * dp[0][0][*it]) % MOD;
                            ex1 = (ex1 * dp[1][0][*it]) % MOD;
                        }
                    }
                    dp[0][0][node] = (ex0 + in0) % MOD;
                    dp[0][1][node] = ex0;
                    dp[1][0][node] = ex1;
                    dp[1][1][node] = ex1;
                }*/

                //node at the start of the cycle
                dp[0][0][ref] = 0;
                ll in1=1, ex0=1;
                iter(adj[ref],vec(int)){
                    if (dp[0][0][*it] != -1 and not is_cycle[*it]){
                        in1 = (in1 * dp[1][1][*it]) % MOD;
                        ex0 = (ex0 * dp[0][0][*it]) % MOD;
                    }
                }
                int next = cycle[1];
                in1 = (in1 * dp[1][1][next]) % MOD;
                ex0 = (ex0 * dp[0][0][next]) % MOD;
                dp[0][0][ref] = (in1+ex0) % MOD;

                ans = (ans*dp[0][0][ref]) % MOD;
            }
        }

        printf("%lld\n",ans);
    }
    return 0;
}
