/* Pranet Verma */
/* Yeh mera template hai. Apna khud banao =_= */
#include <bits/stdc++.h>
using namespace std;
#define infinity (1000000007)
#define ll long long
#define ull unsigned long long
#define pii pair<int,int>
#define ppi pair<pii,int>
#define ppp pair<pii,pii>
#define pip pair<int,pii>
#define pb push_back
#define mp make_pair
#define s(n) scanf("%d",&n)
#define s2(n,m) scanf("%d%d",&n,&m)
#define s3(n,m,l) scanf("%d%d%d",&n,&m,&l)
#define rep(i,n) for(int i=0;i<n;++i)
ll pwr(ll a,ll b,ll mod) {a%=mod;if(a<0)a+=mod;ll ans=1; while(b) {if(b&1) ans=(ans*a)%mod; a=(a*a)%mod; b/=2; } return ans; }
ll pwr(ll a,ll b) {ll ans=1; while(b) {if(b&1) ans*=a; a*=a; b/=2; } return ans; }
ll gcd(ll a,ll b) {while(b) {ll temp=a; a=b; b=temp%b; } return a; }
ll lcm(ll a,ll b) {return (a/gcd(a,b))*b; }
ll modularInverse(ll a,ll m) {/*reminder: make sure m is prime*/ assert(false); return pwr(a,m-2,m); }
const int mod=1000000007;
bool vis[100001];
int root;
set<int> g[100001];
void findRoot(int u,int p)
{

    vis[u]=true;
    for(set<int>::iterator i=g[u].begin();i!=g[u].end();++i)
    {
        int v=(*i);
        if(v==p)
            continue;
        if(v==root)
            continue;
        if(vis[v] && root==-1)
            {
                root=v;
            }
        findRoot(v,u);
    }

}

ll DP[100001][2][2];
int doNotVisit=-1;

bool visited[100001];
void dfs(int u,int p)
{

    assert(visited[u]==false);
    visited[u]=true;
    /* don;t take this */   
    DP[u][0][0]=1;
    DP[u][0][1]=1;

    /* take this but root not taken */
    DP[u][1][0]=1;


    /* take this but root is taken */
    DP[u][1][1]=1;

    if(u==root)
    {
        DP[u][1][0]=0;
        DP[u][0][1]=0;
    }
    for(set<int>::iterator i=g[u].begin();i!=g[u].end();++i)
    {
        int v=(*i);

        if(v==p)
            continue;
        if(v==root)
        {
            DP[u][1][1]=0;
            doNotVisit=u;
            continue;
        }
        if(u==root && v==doNotVisit)
        {
            continue;
        }
        dfs(v,u);

    
        DP[u][0][0]*=(DP[v][0][0] + DP[v][1][0]);
        DP[u][0][0]%=mod;
        
        DP[u][0][1]*=(DP[v][0][1] + DP[v][1][1]);
        DP[u][0][1]%=mod;

        DP[u][1][0]*=(DP[v][0][0]);
        DP[u][1][0]%=mod;

        DP[u][1][1]*=(DP[v][0][1]);
        DP[u][1][1]%=mod;    



    }   

    


}
int main()
{
  std::ios::sync_with_stdio(false);
    
  int t;
  s(t);
  while(t--)
  {
    int n;
    s(n);
    assert(n<=100000);
    memset(vis,0,sizeof vis);
    memset(visited,0,sizeof visited);

    for(int i=1;i<=100000;++i)
        g[i].clear();
    doNotVisit=-1;

    for(int i=1;i<=n;++i)
    {

        int x;
        s(x);
        assert(x<=100000);
        g[i].insert(x);
        g[x].insert(i);
    }
    /* root will be some point that lies on the cycle */
    ll ans=1;
    for(int i=1;i<=n;++i)
    {
        if(vis[i])
            continue;
        root=-1;
        findRoot(i,0);
        if(root==-1)
            root=i;
        assert(root>=1 && root<=n);
        

        dfs(root,0);
        ans*= (DP[root][0][0] + DP[root][1][1]);
        ans%=mod;
        

        assert(DP[root][0][1]==0);
        assert(DP[root][1][0]==0);
    }
    cout<<ans<<endl;
  }
   


}