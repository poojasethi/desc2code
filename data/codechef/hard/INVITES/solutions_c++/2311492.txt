//#undef _GLIBCXX_DEBUG

#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <ctime>
#include <iomanip>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <valarray>
#include <vector>

using namespace std;

#define foreach(iter,cont) for(typeof((cont).begin()) iter = (cont).begin(); iter != (cont).end(); ++iter)
#define min3(a, b, c) min(a, min(b, c))
#define max3(a, b, c) max(a, max(b, c))
#define inf 1000000008
#define eps 1.0e-10L
#define divisible(a, b) (((a) / (b)) * (b) == (a))
static const long long p = 1000000007;
__attribute__((unused)) static bool eq(long double a, long double b)  { return (a == b ? true : (a * b == 0 ? abs(a - b) < eps : abs(a - b) / (abs(a) + abs(b)) < eps));  }
__attribute__((unused)) static long long modp(long long n, long long m) { long long r = n % m; return r >= 0 ? r : r + m; }
__attribute__((unused)) static long long gcd(long long a, long long b) { return (a < 0 ? gcd(-a, b) : (b < 0 ? gcd(a, -b) : (!a && !b ? 1 : (b ? gcd(b, a % b) : a)))); }
template<class T> static int len(const T& cont) { return (int) cont.size(); }

// BEGIN CUT HERE
template<class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << "(" << p.first << ", " << p.second << ")"; }
template<class T> ostream &operator<<(ostream& os, const vector<T> &vec) { os << "[ "; for(size_t i = 0; i < vec.size(); i++) { os << vec[i]; if(i != vec.size() - 1) { os << ", "; } } return os << " ]"; }
template<class T> ostream &operator<<(ostream& os, const list<T> &l) { os << "[ "; bool first = true; for(typename list<T>::const_iterator lstIt = l.begin(); lstIt != l.end(); ++lstIt) { if(!first) { os << ", "; } first = false; os << *lstIt; } return os << " ]"; }
template<class T> ostream &operator<<(ostream& os, const deque<T> &d) { os << "[ "; bool first = true; for(typename deque<T>::const_iterator dIt = d.begin(); dIt != d.end(); ++dIt) { if(!first) { os << ", "; } first = false; os << *dIt; } return os << " ]"; }
template<class T> ostream &operator<<(ostream& os, const vector<vector<T> > &mat) { for(size_t i = 0; i < mat.size(); i++) { if(i) os << endl; os << mat[i]; } return os; }
template<class T> ostream &operator<<(ostream &os, const set<T> &s) { os << "{ "; bool first = true; for(typename set<T>::const_iterator setIt = s.begin(); setIt != s.end(); ++setIt) { if(!first) { os << ", "; } first = false; os << *setIt; } return os << " }"; }
template<class T, class U> ostream &operator<<(ostream &os, const map<T, U> &m) { os << "{ "; bool first = true; for(typename map<T, U>::const_iterator mapIt = m.begin(); mapIt != m.end(); ++mapIt) { if(!first) { os << ", "; } first = false; os << mapIt->first << " = " << mapIt->second; } return os << " }"; }
// END CUT HERE

struct CompDfsCb {
	CompDfsCb(vector<int> &curComponent, vector<bool> &visited) : curComponent(curComponent), visited(visited) { }

	void preTraverse(int u) {
		visited[u] = true;
		curComponent.push_back(u);
	}

	void postTraverse(int) { }

	vector<int> &curComponent;
	vector<bool> &visited;
};

struct Edge {

	Edge(int edgeId, int from, int to, int cost) :
		edgeId(edgeId), from(from), to(to), cost(cost) {
	}

	int edgeId;
	int from;
	int to;
	int cost;
};

struct Graph {

	Graph(int n, bool directed = true) : n(n), numEdges(0), directed(directed), edges(n, vector<Edge>()) {
	}

	void resize(int newN) {
		edges.resize(newN, vector<Edge>());
		n = newN;
	}

	void createEdge(int from, int to, int cost = 0) {
		edges[from].push_back(Edge(numEdges++, from, to, cost));
		if(!directed) {
			edges[to].push_back(Edge(numEdges - 1, to, from, cost));
		}
	}

	void removeEdge(int edgeId) {
		for(int i = 0; i < n; i++) {
			for(int j = 0; j < len(edges[i]); j++) {
				if(edges[i][j].edgeId == edgeId) {
					edges[i].erase(edges[i].begin() + j);
					j--;
				}
			}
		}
	}

	vector<Graph> components() {
		vector<bool> visited(n, false);
		vector<int> curComponent;
		vector<Graph> ret;

		CompDfsCb cb(curComponent, visited);
		for(int i = 0; i < n; i++) {
			if(visited[i]) {
				continue;
			}

			curComponent.clear();
			dfs(i, cb);

			Graph g(curComponent.size(), directed);

			map<int, int> nodeLu;
			for(int j = 0; j < len(cb.curComponent); j++) {
				map<int, int>::iterator it = nodeLu.find(curComponent[j]);
				if(it == nodeLu.end()) {
					it = nodeLu.insert(it, make_pair(curComponent[j], len(nodeLu)));
				}
			}

			map<int, int> edgeLu;
			for(int j = 0; j < len(curComponent); j++) {
				int u = curComponent[j];
				for(int k = 0; k < len(edges[u]); k++) {
					Edge e = edges[u][k];
					map<int, int>::iterator it = edgeLu.find(e.edgeId);
					if(it == edgeLu.end()) {
						it = edgeLu.insert(it, make_pair(e.edgeId, len(edgeLu)));
					}
					g.edges[nodeLu[u]].push_back(Edge(it->second, nodeLu[e.from], nodeLu[e.to], e.cost));
				}
			}

			ret.push_back(g);
		}

		return ret;
	}

	template<class T>
	void dfs(int u, T &callback) {
		struct DfsFunc {
			DfsFunc(int n, const vector<vector<Edge> > &edges, T &callback) : 
				n(n), visited(n, false), edges(edges), callback(callback) { }

			void dfs(int u, int prevEdge) {
				visited[u] = true;

				callback.preTraverse(u);

				for(int i = 0; i < len(edges[u]); i++) {
					int v = edges[u][i].to;
					if(!visited[v] && edges[u][i].edgeId != prevEdge) {
						dfs(v, edges[u][i].edgeId);
					}
				}

				callback.postTraverse(u);
			}

			int n;
			vector<int> visited;
			const vector<vector<Edge> > &edges;
			T &callback;
		};

		DfsFunc dfsFunc(n, edges, callback);
		dfsFunc.dfs(u, -1);
	}

	/**
	 * If there is a cycle, find *an* edge on the cycle (impossible to uniquely identify
	 * cycles, in general) and return it.  If no cycles, return Edge(-1, -1, -1, -1)
	 */
	Edge findCycle() {
		struct DfsFunc {
			DfsFunc(int n, const vector<vector<Edge> > &edges) : 
				n(n), ret(Edge(-1, -1, -1, -1)),
				visited(n, false), edges(edges) { }

			void dfs(int u, int prevEdge) {
				visited[u] = true;
				for(int i = 0; i < len(edges[u]); i++) {
					int v = edges[u][i].to;
					
					if(edges[u][i].edgeId != prevEdge) {
						if(visited[v]) {
							ret = edges[u][i];
						} else {
							dfs(v, edges[u][i].edgeId);
						}
					}
				}
			}

			int n;
			Edge ret;
			vector<int> visited;
			const vector<vector<Edge> > &edges;
		};

		DfsFunc dfsFunc(n, edges);
		dfsFunc.dfs(0, -1);
		return dfsFunc.ret;
	}

	int n, numEdges;
	bool directed;
	vector<vector<Edge> > edges;
};

ostream &operator<<(ostream &os, const Graph &g) {
	for(int i = 0; i < g.n; i++) {
		os << i << " " << i + 1 << endl;
	}
	os << "#" << endl;
	for(int i = 0; i < g.n; i++) {
		for(int j = 0; j < len(g.edges[i]); j++) {
			if(g.directed || g.edges[i][j].to < i) {
				cout << g.edges[i][j].from << " " << g.edges[i][j].to << endl;
			}
		}
	}
	return os;
}

struct DebugDfsCallback {
	void preTraverse(int u) {
		cout << "Pre " << u + 1 << endl;
	}

	void postTraverse(int u) {
		cout << "Post " << u + 1 << endl;
	}
};


int t, n;
vector<pair<long long, long long> > dp;
int startNode, endNode;
bool startInUse;
vector<bool> visited;

pair<long long, long long> numWays(const Graph &g, int u, int prevEdge) {
	if(dp[u].first != -1) {
		return dp[u];
	}

	long long numWaysUninvited = (u == startNode ? startInUse ? 0 : 1 : 1);
	long long numWaysInvited = (u == startNode ? startInUse ? 1 : 0 : 1);

	for(int i = 0; i < len(g.edges[u]); i++) {
		if(g.edges[u][i].edgeId != prevEdge) {
			int v = g.edges[u][i].to;
			pair<long long, long long> next = numWays(g, v, g.edges[u][i].edgeId);

			numWaysUninvited = numWaysUninvited * ((next.first + next.second) % p) % p;
			numWaysInvited = numWaysInvited * next.first % p;
		}
	}

	if(u == endNode && startInUse) {
		numWaysInvited = 0;
	}

	dp[u] = make_pair(numWaysUninvited, numWaysInvited);
	return dp[u];
}

struct NumWaysDfsCb {
	NumWaysDfsCb(Graph &g) : g(g) { }

	void postTraverse(int u) {
		long long numWaysUninvited = (u == startNode ? startInUse ? 0 : 1 : 1);
		long long numWaysInvited = (u == startNode ? startInUse ? 1 : 0 : 1);

		bool done = true;
		for(int i = 0; i < len(g.edges[u]); i++) {
			int v = g.edges[u][i].to;

			if(visited[v]) {
				pair<long long, long long> prev = dp[v];

				numWaysUninvited = numWaysUninvited * ((prev.first + prev.second) % p) % p;
				numWaysInvited = numWaysInvited * prev.first % p;
			}
		}

		if(u == endNode && startInUse) {
			numWaysInvited = 0;
		}

		dp[u] = make_pair(numWaysUninvited, numWaysInvited);

		visited[u] = true;
	}

	void preTraverse(int) { }

	Graph &g;
};

int main(__attribute__((unused)) int argc, __attribute__((unused)) char **argv) {
	scanf("%d", &t);
	while(t--) {
		scanf("%d", &n);

		Graph g(n, false);

		for(int i = 0; i < n; i++) {
			int hates;
			scanf("%d", &hates);
			g.createEdge(i, hates - 1);
		}

		vector<Graph> comp = g.components();
		long long total = 1;
		foreach(c, comp) {
			long long curTotal = 0;
			Edge cycleEdge = c->findCycle();
			c->removeEdge(cycleEdge.edgeId);

			startNode = cycleEdge.from;
			endNode = cycleEdge.to;

			NumWaysDfsCb cb(*c);

			int from = 0;
			for(int i = 0; i < c->n; i++) {
				if(len(c->edges[i]) == 1) {
					from = i;
					break;
				}
			}

			startInUse = false;
			dp.assign(c->n, make_pair(-1, -1));
			visited.assign(c->n, false);
			c->dfs(startNode, cb);
			curTotal = (curTotal + dp[startNode].first + dp[startNode].second) % p;

			startInUse = true;
			dp.assign(c->n, make_pair(-1, -1));
			visited.assign(c->n, false);
			c->dfs(startNode, cb);
			curTotal = (curTotal + dp[startNode].first + dp[startNode].second) % p;

			total = (total * curTotal) % p;
		}

		printf("%lld\n", total);
	}

	return 0;
}