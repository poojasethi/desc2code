#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>
#include <set>
#include <map>
#include <cmath>
#include <list>
#include <ctime>
#include <sstream>
#include <queue>
#include <stack>
#include <bitset>
using namespace std;
typedef vector<int> VI;
typedef pair<int,int> PII;
typedef long long LL;
#define FOR(x, b, e) for(int x=b; x<=(e); ++x)
#define FORD(x, b, e) for(int x=b; x>=(e); --x)
#define REP(x, n) for(int x=0; x<(n); ++x)
#define VAR(v,n) typeof(n) v=(n)
#define ALL(c) c.begin(),c.end()
#define SIZE(x) (int)x.size()
#define FOREACH(i,c) for(VAR(i,(c).begin());i!=(c).end();++i)
#define PB push_back
#define ST first
#define ND second
#define mp(x,y) make_pair(x,y)
#define DEBUG 1
#define debug(x) {if (DEBUG)cerr <<#x <<" = " <<x <<endl; }
#define debugv(x) {if (DEBUG) {cerr <<#x <<" = "; FOREACH(it, (x)) cerr <<*it <<", "; cout <<endl; }}
typedef short int sint;

const int N = 101010;
const LL mod = 1000000007;
VI za[N];
int deg[N];
LL F[N][2];
LL pom[N][2];
bool done[N];
int n;

void testcase() {
	scanf("%d", &n);
	FOR(i, 1, n) {
		int c;
		scanf("%d", &c);
		++deg[c];
		za[i].PB(c);
		F[i][0] = F[i][1] = 1;
	}
	queue<int> Q;
	FOR(i, 1, n) {
		if (deg[i] == 0) {
			Q.push(i);
			done[i] = true;
		}
	}
	while (!Q.empty()) {
		int front = Q.front(); Q.pop();
		FOREACH(p, za[front]) {
			if (!done[*p]) {
				--deg[*p];
				F[*p][1] = (F[front][0] * F[*p][1]) % mod;
				F[*p][0] = ((F[front][1] + F[front][0]) * F[*p][0]) % mod;
				if (deg[*p] == 0) {
					Q.push(*p);
					done[*p] = true;
				}
			}
		}
	}
	LL res = 1;
	// pozostaly nam cykle
	FOR(i, 1, n) if (!done[i]) {
		// jakis cykl
		VI zbior;
		zbior.PB(i);
		done[i] = true;
		int curr = za[i][0];
		while (curr != i) {
			zbior.PB(curr);
			done[curr] = true;
			curr = za[curr][0];
		}
		//debugv(zbior);
		//printf("biore start\n");
		LL temp = 0;
		pom[i][0] = 0; pom[i][1] = F[i][1];
		FOR(q, 1, SIZE(zbior)-1) {
			curr = zbior[q];
			pom[curr][0] = ((pom[zbior[q-1]][0] + pom[zbior[q-1]][1]) * F[curr][0] ) % mod;
			if (q < SIZE(zbior)-1)pom[curr][1] = ((pom[zbior[q-1]][0]) * F[curr][1] ) % mod;
			else pom[curr][1] = 0;
			//printf("%d[0] = %lld, %d[1] = %lld\n", curr, pom[curr][0], curr, pom[curr][1]);
		}
		temp = ( (pom[zbior.back()][0] + pom[zbior.back()][1])) % mod;
		//printf("nie biore\n");
		pom[i][0] = F[i][0]; pom[i][1] = 0;
		FOR(q, 1, SIZE(zbior)-1) {
			curr = zbior[q];
			pom[curr][0] = ((pom[zbior[q-1]][0] + pom[zbior[q-1]][1]) * F[curr][0] ) % mod;
			pom[curr][1] = ((pom[zbior[q-1]][0]) * F[curr][1] ) % mod;
			//printf("%d[0] = %lld, %d[1] = %lld\n", curr, pom[curr][0], curr, pom[curr][1]);
		}
		temp = (temp + (pom[zbior.back()][0] + pom[zbior.back()][1])) % mod;
		res = (res * temp) % mod;
	}
	FOR(i, 1, n) if (SIZE(za[i]) == 0) res = (res * (F[i][0] + F[i][1])) % mod;
	printf("%lld\n", res);
	FOR(i, 1, n) {
		za[i].clear();
		done[i] = false;
		deg[i] = 0;
	}
}

int main(){
	int t;
	scanf("%d", &t);
	while (t--) {
		testcase();
	}
}