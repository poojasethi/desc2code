//Amit Gupta              
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int,int> II;
#define REP(i,i1,n) for(int i=i1;i<n;i++)
#define REPB(i,i1,n) for(int i=i1;i>=n;i--)
#define PB push_back
#define MP make_pair
#define ALL(c) (c).begin(),(c).end()
#define F first
#define S second
#define SZ(a) (LL)a.size()
#define EPS 1e-12
#define MOD 1000000007
#define TR1(x) cerr<<#x<<" : "<<x<<endl
#define TR2(x,y) cerr<<#x<<" : "<<x<<" | "<<#y<<" : "<<y<<endl
#define FAST_IO ios_base::sync_with_stdio(false);cin.tie(NULL)
#define SI(c) scanf("%d",&c)
#define SII(c,d) scanf("%d%d",&c,&d)
#define SLL(c) scanf("%lld",&c)
#define PIN(c) printf("%d\n",c)
#define PLLN(c) printf("%lld\n",c)
#define N 200010
#define endl '\n'
#define FILL(ar,vl) for(int i=0;i<N;i++)ar[i]=vl
#define FILL2(ar,vl) for(int i=0;i<N;i++)for(j=0;j<N;j++)ar[i][j]=vl
//--------------------------MAIN CODE STARTS HERE----------------
int P[N][22],par[N],lev[N],n,vis[N],tree[2*N+10],q,in[N],out[N],time1,A[N],B[N],tree1[2*N+10];
vector<int> g[N];
void dfs(int z) {
    vis[z]=1;
    in[z]=++time1;
    REP(i,0,g[z].size()) {
        if(!vis[g[z][i]]) {
            par[g[z][i]]=z;
            lev[g[z][i]]=lev[z]+1;
            dfs(g[z][i]);
        }
    }
    out[z]=time1;
}
void preprocess() {
    
    REP(i,0,n+1)
        for(int j=0;j<=20;j++)   
            P[i][j]=-1;

    REP(i,1,n+1)
        P[i][0]=par[i];

    for(int j=1;(1<<j) <=n;j++)
        for(int i=1;i<=n;i++)
            if(P[i][j-1]!=-1)
                P[i][j]=P[P[i][j-1]][j-1];
}

int lca(int p,int q) {
    int lg;
    if(lev[p]<lev[q])
        swap(p,q);
    for(lg=1;(1<<lg) <=lev[p];lg++);
    lg--;

    for(int i=lg;i>=0;i--)
        if(lev[p]-(1<<i) >=lev[q])
            p=P[p][i];

    if(p==q)
        return p;

    for(int i=lg;i>=0;i--)
        if(P[p][i]!=-1&&P[p][i]!=P[q][i])
            p=P[p][i],q=P[q][i];
    return par[p];
}

int read(int idx) {
    int sum = 0;
    while (idx > 0) {
        sum += tree[idx];
        idx -= (idx & -idx);
    }
    return sum;
}
void update(int idx ,int val) {
    while (idx <= n) {
        tree[idx] += val;
        idx += (idx & -idx);
    }
}
int read1(int idx) {
    int sum = 0;
    while (idx > 0) {
        sum += tree1[idx];
        idx -= (idx & -idx);
    }
    return sum;
}
void update1(int idx ,int val) {
    while (idx <= n) {
        tree1[idx] += val;
        idx += (idx & -idx);
    }
}
int main() {
    SI(n);
    REP(i,0,n-1) {
        int x,y;
        SII(x,y);
        g[x].PB(y);
        g[y].PB(x);
    }
    time1=0;
    par[1]=-1;
    dfs(1);
    preprocess();
    SI(q);
    n++;
    while(q--) {
        int x,y,lc,ans=0;
        SII(x,y);
        lc=lca(x,y);
        ans+=read1(out[lc])-read1(in[lc]-1);
        update1(in[x],1);
        update1(in[y],1);
        update1(in[lc],-2);
        ans+=read(in[x])+read(in[y])-read(in[lc])-(lc==1 ? 0 : read(in[par[lc]]));
        update(in[lc],1);
        update(out[lc]+1,-1);
        PIN(ans);
    }
    return 0;
}
