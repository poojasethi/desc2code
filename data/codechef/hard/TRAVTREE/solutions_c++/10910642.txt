#include <bits/stdc++.h>
using namespace std;

#define DEBUG(x)    cerr << #x << " = " << x << endl
#define INPUT       freopen("Data.inp", "r", stdin)
#define OUTPUT      freopen("Data.out", "w", stdout)

typedef long long LL;
typedef pair<int, int> II;

const int N = (int) 2e5 + 10;
int n, m, p[N][21], h[N], c[N];
vector<int> adj[N];
bool fre[N];

int nChain, nPos;
int head[N], chain[N], pos[N];

void DFS(int u) {
    fre[u] = false; c[u] = 1;
    for (int i = 0; i < (int) adj[u].size(); ++i) {
        int v = adj[u][i];
        if (fre[v]) {
            p[v][0] = u;
            h[v] = h[u] + 1;
            DFS(v);
            c[u] = c[u] + c[v];
        }
    }
}

void InitLCA() {
    for (int j = 1; 1 << j <= n; ++j)
        for (int i = 1; i <= n; ++i)
            p[i][j] = p[p[i][j - 1]][j - 1];
}

int LCA(int u, int v) {
    if (h[u] < h[v]) swap(u, v);
    for (int i = 20; i >= 0; --i) if (h[u] - (1 << i) >= h[v]) u = p[u][i];
    if (u == v) return u;
    for (int i = 20; i >= 0; --i) if (p[u][i] != p[v][i]) u = p[u][i], v = p[v][i];
    return p[u][0];
}

void HLD(int u) {
    if (head[nChain] == 0) head[nChain] = u;
    chain[u] = nChain; pos[u] = ++nPos;
    int hVertex = -1;
    for (int i = 0; i < (int) adj[u].size(); ++i) {
        int v = adj[u][i]; if (p[v][0] != u) continue;
        if (hVertex == -1 || c[hVertex] < c[v]) hVertex = v;
    }
    if (hVertex != -1) HLD(hVertex);
    for (int i = 0; i < (int) adj[u].size(); ++i) {
        int v = adj[u][i]; if (p[v][0] != u) continue;
        if (v != hVertex) {
            nChain++;
            HLD(v);
        }
    }
}

struct FenwickTree {
    int ft[N];
    void Update(int i, int v) {
        while (i <= n) {
            ft[i] += v;
            i += i & -i;
        }
    }
    int Query(int i) {
        int ans = 0;
        while (i) {
            ans += ft[i];
            i -= i & -i;
        }
        return ans;
    }
} T1, T2;
/**
    T1: Point update, Range query.
    T2: Range update, Point query.
**/

int Query(int u, int w) {
    int ans = 0;
    while (1) {
        if (chain[u] == chain[w]) {
            ans += T1.Query(pos[u]) - T1.Query(pos[w]);
            break;
        }
        ans += T1.Query(pos[u]) - T1.Query(pos[head[chain[u]]] - 1);
        u = p[head[chain[u]]][0];
    }
    return ans;
}

void Update(int u, int w, int v) {
    while (1) {
        if (chain[u] == chain[w]) {
            T2.Update(pos[w], v);
            T2.Update(pos[u] + 1, -v);
            break;
        }
        T2.Update(pos[head[chain[u]]], v);
        T2.Update(pos[u] + 1, -v);
        u = p[head[chain[u]]][0];
    }
}

int Answer(int u, int v) {
    int w = LCA(u, v);
    int ans = 0;
    ans += Query(u, w) + Query(v, w);
    ans += T2.Query(pos[w]);
    Update(u, w, 1);
    Update(v, w, 1);
    Update(w, w, -1);
    T1.Update(pos[w], 1);
    return ans;
}

int main() {
    #ifdef LOCAL
        INPUT;
        OUTPUT;
    #endif

    scanf("%d", &n);
    for (int i = 1; i <= n - 1; ++i) {
        int u, v; scanf("%d%d", &u, &v);
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    memset(fre, true, sizeof fre);
    DFS(1); InitLCA(); HLD(1);

    scanf("%d", &m);
    while (m--) {
        int u, v; scanf("%d%d", &u, &v);
        printf("%d\n", Answer(u, v));
    }
    return 0;
}
