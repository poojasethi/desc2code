#include <cstdio>
#include <list>
#include <cctype>
#include <cstdlib>
#include <cassert>

using namespace std;

typedef long long ll;
const ll  M = 0x0100000000LL;
const int L = 0x80000000;

struct TOKEN
{
    char type, op, pr;
    int  v;
    TOKEN(char type, int   v) : type(type), v(v)   {}
    TOKEN(char type, char op) : type(type), op(op)
    {
        if (op == '!')
            pr = 6;
        else if (op == '^')
            pr = 5;
        else if (op == '/')
            pr = 4;
        else if (op == '*')
            pr = 3;
        else if (op == '+')
            pr = 2;
        else if (op == '-')
            pr = 1;
    }
};

enum {OPERATOR, NUMBER};

list<TOKEN> tlist;
int fact[51];
int ifact[51];

inline int pow(int a, int b)
{
    if (b < 0)
        b = -b;

    int prod = 1;
    int term = a;
    while (b!=0)
    {
        if (b&0x1)
            prod *= term;
        term *= term;
        b /= 2;
    }
    return prod;
}

ll gcd(ll a, ll b)
{
    while (b != 0)
    {
        ll tmp = a%b; a = b; b = tmp;
    }
    return a;
}

void ext_euclid(ll a, ll b, ll &x, ll &y)
{
    x = 0; y = 1;
    ll xx = 1, yy = 0, q, tmp;
    while(b > 1)
    {
        q = a/b;
        ll tmp = a % b; a = b; b = tmp;
        tmp = x; x=xx-q*x; xx=tmp;
        tmp = y; y=yy-q*y; yy=tmp;
    }
}

inline ll mul_inv(ll b, ll a)
{
    ll x, y;
    ext_euclid(a, b, x, y);
    return y>0? y : a + y;
}

inline list<TOKEN>::iterator back_and_remove(list<TOKEN>::iterator it)
{
        it--;
        it--;
        it = tlist.erase(it);
        it = tlist.erase(it);
        return it;
}

bool calculate(list<TOKEN>::iterator &it)
{
    char op   = it->op; it++;
    int  a    = it->v;  it++;
    int  b    = it->v;
    int  dist = distance(tlist.begin(), it)-1;
    if (op == '^')
    {
        int t = pow(a, b);
        if (b < 0)
        {
            if (t == 0)
                return false;

            ll sign = 1;
            ll ttt  = t;
            if (t < 0)
            {
                sign = -1;
                ttt = llabs(t);
            }
            ll g = gcd(ttt, M);
            if (gcd(ttt, M) != 1)
                return false;
            else
            {
                ll inv_t = mul_inv(ttt , M)*sign;
                it->v = inv_t%M;
            }

                assert(t * it->v == 1);
        }
        else
            it->v = t;
        it = back_and_remove(it);
        printf("%d %c %d %d %d\n", dist, op, a, b, it->v);
        return true;
    }
    else if (op == '/')
    {
        if (b == 0)
        {
            if (a != 0)
                return false;
            else
                it->v = -pow(2,31);
        }
        else
        {
            ll sign = 1;
            ll bbb = b;
            if (b < 0)
            {
                sign = -1;
                bbb = llabs(b);
            }
            ll g = gcd(bbb,M);
            if ((ll)a % g != 0)
                return false;
            else
            {
                if (g == 1)
                {
                    ll inv_b = mul_inv((ll)bbb , M) * sign;
                    it->v = (inv_b*a)%M;
                }

                else
                {
                    ll aa = (ll)a / g;
                    ll bb = bbb   / g;
                    ll mm = M     / g;

                    ll inv_bb = mul_inv(bb, mm) * sign;
                    int t = (inv_bb*aa)%mm;
                    if (t < 0)
                        t += mm;
                    assert(L-t>=L+t);
                    it->v = L+t;
                    assert(a == b * it->v);
                }
            }
        }
        assert(a == b * it->v);
        //printf("a=%d b=%d q=%d,  b*q = %d\n", a, b, it->v,  b*it->v);
        it = back_and_remove(it);
        printf("%d %c %d %d %d\n", dist, op, a, b, it->v);
        return true;
    }
    else if (op == '*')
    {
        it->v = a * b;
        if (((ll)a*(ll)b-it->v)%M != 0)
            assert(false);
        it = back_and_remove(it);
        printf("%d %c %d %d %d\n", dist, op, a, b, it->v);
        return true;
    }
    else if (op == '+')
    {
        it->v = a + b;
        if (((ll)a+(ll)b-(ll)it->v)%(ll)M != 0)
            assert(false);
        it = back_and_remove(it);
        printf("%d %c %d %d %d\n", dist, op, a, b, it->v);
        return true;
    }
    else if (op == '-')
    {
        it->v = a - b;
        if (((ll)a-(ll)b-(ll)it->v)%(ll)M != 0)
            assert(false);
        it = back_and_remove(it);
        printf("%d %c %d %d %d\n", dist, op, a, b, it->v);
        return true;
    }
    //printf("OP=%c a=%d b=%d\n", op, a, b);
    assert(false);
}

inline int factorial(int i)
{
    if (i>40 || i<-40)
        return 0;
    else if (i >= 0)
        return fact[i];
    else 
        return ifact[-i];
}

void solve()
{
    // to calculate factorial
    bool err=false;
    for(;;)
    {
        list<TOKEN>::iterator one, two, thr, fou, fac, cal;
        one = tlist.begin();
        two = one; two++;
        fac = tlist.end();
        while(two != tlist.end())
        {
            if (one->type == OPERATOR && one->op == '!'
                && two->type == NUMBER)
            {
                fac = one;
                break;
            }
            one++;
            two++;
        }

        if (fac != tlist.end())
        {
            int  dist = distance(tlist.begin(), fac) + 1;
            char op = fac->op;
            fac = tlist.erase(fac); 

            int a = fac->v;
            fac->v = factorial(fac->v);
            printf("%d %c %d %d %d\n", dist, '!', a, -1, fac->v);
            continue;
        }

        one = tlist.begin();
        two = one; two++;
        thr = two; thr++;
        fou = thr; fou++;
        cal = tlist.end();

        while(fou != tlist.end())
        {
            if (one->type == OPERATOR 
                && two->type == NUMBER 
                && thr->type == NUMBER 
                && fou->type == NUMBER)
            {
                if(cal == tlist.end() || one->pr > cal->pr)
                    cal = one;
            }
            one++;
            two++;
            thr++;
            fou++;
        }

        if (cal != tlist.end())
        {
            if (!calculate(cal))
            {
                err = true;
                break;
            }
            else
                continue;
        }

        one = tlist.begin();
        two = one; two++;
        thr = two; thr++;
        fou = thr; fou++;
        cal = tlist.end();
        while(thr != tlist.end())
        {
            if (one->type == OPERATOR 
                && two->type == NUMBER 
                && thr->type == NUMBER)
            {
                if(fou != tlist.end() && fou->type != NUMBER)
                {
                    if(cal == tlist.end() || one->pr > cal->pr)
                        cal = one;
                }
                else if (fou == tlist.end())
                {
                    if(cal == tlist.end() || one->pr > cal->pr)
                        cal = one;
                }
            }
            one++;
            two++;
            thr++;
            fou++;
        }

        if (cal != tlist.end())
        {
            if (!calculate(cal))
            {
                err = true;
                break;
            }
            else
                continue;
        }
        else
            break;
    }
    //printf("TSIZE=%d\n", tlist.size());
    if (!err & tlist.size() == 1 && tlist.begin()->type == NUMBER)
        printf("OK\n");
    else
        printf("NOT OK\n");
}

// factorial 34!=0;
int main()
{
    fact[0] = ifact[0] = 1;
    for(int i=1; i<=50; i++)
    {
        fact[i]  = ((ll)i*(ll)fact[i-1])%M;
        ifact[i] = ((ll)(-i)*(ll)ifact[i-1])%M;
    }

    //for(int i=1; i<=50; i++)
    //{
    //    printf("i=%d fact=%8x ifact=%8x\n", i, fact[i], ifact[i]);
    //}

    int T;
    scanf("%d", &T);

    for(int i=0; i<T; i++)
    {
        tlist.clear();
        int N;
        scanf("%d", &N);
        for(int j=0; j<N; j++)
        {
            char t[100];
            scanf("%s", t);
            if (isdigit(t[0]) || (t[0] == '-' && isdigit(t[1])))
                tlist.push_back(TOKEN(NUMBER,   atoi(t)));
            else
                tlist.push_back(TOKEN(OPERATOR, t[0]));
        }
        solve();
    }
    return 0;
}
