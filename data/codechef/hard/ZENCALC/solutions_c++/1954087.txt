#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <string>
#include <vector>
using namespace std;

const int maxV = 2147483647; // 2^31 - 1
const int minV = -maxV-1; // -2^31
const int OP_CNT = 6;
const char pri[OP_CNT+1]="!^/*+-"; // the operations listed in priority order

// returns index of c in the string pri[]
int op_ind(char c)
{
	for(int i=0;i<OP_CNT;i++)
		if(pri[i]==c) return i;
	return OP_CNT;
}

enum tokenType {OP, INT};

struct token {
	tokenType type;
	int val; // equals to op_ind if type is OP and to integer value if type is INT
	token(){}
	token(tokenType _type, int _val): type(_type), val(_val) {}
	bool operator == (const token &tok) {
		return type == tok.type && val == tok.val;
	}
};

// return a 32-bit factorial of A
int fact32(int A) {
	// 34! mod 2^32 = 0 while 33! mod 2^32 = 2^31
	// we can't use abs here since abs(-2147483648) = -2147483648
	if (A < -33 || A > 33) {
		return 0;
	}
	int fact = 1;
	// but now we know that |A|<=33 so using abs(A) is safe
	for (int i = 1; i <= abs(A); ++i) {
		fact *= i;
	}
	// handling the case of negative A
	// we should change the sign of factorials only when A is odd
	if (A < 0 && A % 2) {
		// note that when fact was -2^31 this will not change its value
		// but it is correct behavior
		fact = -fact;
	}
	return fact;
}

// return 32-bit residue of A^B
// note that B is unsigned here. It is very important!
int pow32_positive(int A, unsigned B) {
	int res = 1;
	// exponentiation by squaring
	while (B) {
		if (B % 2) {
			res *= A;
		}
		if (B /= 2) {
			A *= A;
		}
	}
	return res;
}

// return false in case of error and true otherwise
// and save the result in C
bool div32(int A, int B, int &C) {
	if (B % 2) {
		// when B is odd the result is unique
		// and equal to 32-bit residue of A * B^(2^31-1) by Euler theorem
		C = A * pow32_positive(B, maxV);
		return true;
	}
	if (B == 0) {
		// A / 0 does not exist when A is non-zero
		if (A) {
			return false;
		}
		// but for zero A any C will work and the smallest one is -2^31
		C = minV;
		return true;
	}
	if (A == 0) {
		// when A is zero and B is even, -2^31 always works
		// some other numbers also could work but it is the smallest one
		C = minV;
		return true;
	}
	// now A and B are non-zero and B is even

	// we reduce A by 2 as many times as possible
	// since A is non-zero than this loop is finite
	int dA = 0;
	while (A % 2 == 0) {
		++dA;
		A /= 2;
	}
	// and now reduce B as well
	int dB = 0;
	while (B % 2 == 0) {
		++dB;
		B /= 2;
	}
	// so actual values of A and B are 2^dA * A and 2^dB * B
	if (dA < dB) {
		// in this case the answer is not exist due parity reasons
		return false;
	}
	// we have the following congruence for C:
	// B * C = 2^(dA-dB) * A (mod 2^(32-dB))
	// by Euler theorem C will be like this
	C = A * pow32_positive(B, (1 << (31 - dB)) - 1) << (dA - dB);
	// but we should replace C by its actual residue modulo 2^(32-dB)
	// note that for dB=1 we have 2^(32-dB) = 2^31 which not fit in int
	// so we use unsigned int
	C %= 1U << (32 - dB);
	if (C < 0) {
		C += 1U << (32 - dB);
	}
	// since B is even the actual answer is C - 2^31
	C += minV;
	return true;
}

// return false in case of error and true otherwise
// and save the result in C
bool pow32(int A, int B, int &C) {
	if (A % 2 == 0 && B < 0) {
		// error occurs if and only if B is negative and A is even
		// then 1 / (A^(-B)) does not exist
		return false;
	}
	// when A is odd then by Euler theorem A^(2^31) mod 2^32 = 1
	// hence we can replace B by its mathematical residue modulo 2^31
	// to make it non-negative
	// The cool thing is that casting B to unsigned will do the job:
	C = pow32_positive(A, B);
	return true;
}

// perform C = A op B and return false in case of error
// where op = ^, /, *, +, -
bool calc(int op, int A, int B, int &C) {
	if (op == 1) {
		return pow32(A, B, C);
	}
	if (op == 2) {
		return div32(A, B, C);
	}
	// *, +, - can be simply made in int
	if (op == 3) {
		C = A * B;
	} else if (op == 4) {
		C = A + B;
	} else {
		C = A - B;
	}
	return true;
}

int main() {
	// input number of tests
	int T;
	cin >> T;
	// loop over tests
	for (int t = 0; t < T; ++t) {
		// input length of expression
		int N;
		cin >> N;
		vector<token> ex(N);
		// input tokens one by one
		for(int i=0;i<N;i++)
		{
			// input string representation of the current token
			string token_str;
			cin >> token_str;
			// use sscanf to check whether it is an integer
			// and according to this create a token of corresponding type
			int val;
			if(sscanf(token_str.c_str(), "%d", &val) == 1) {
				ex[i] = token(INT, val);
			} else {
				// op_ind replace the character of operation by its priority
				ex[i] = token(OP, op_ind(token_str[0]));
			}
		}
		// expression evaluation loop
		while(true) {
			int N = ex.size();
			// when expression is just one integer output "OK" and break
			if (N == 1 && ex[0].type == INT) {
				printf("OK\n");
				break;
			}
			// try to apply first rule with factorials
			// fi is 0-based index of first factorial sign followed by an integer
			int fi = -1;
			for (int i = 0; i + 1 < N; ++i) {
				// token(OP, 0) denotes token with factorial sign
				if(ex[i] == token(OP, 0) && ex[i+1].type == INT) {
					fi = i;
					break;
				}
			}
			if (fi >= 0) {
				// calculate and output 32-bit factorial
				int A = ex[fi + 1].val;
				int factA = fact32(A);
				printf("%d ! %d -1 %d\n", fi + 1, A, factA);
				ex[fi + 1].val = factA; // replace A by A!
				ex.erase(ex.begin() + fi); // and delete factorial sign
				continue;
			}
			// if first rules fails we try 2nd and 3rd
			int op = OP_CNT; // the operation priority we will be calculating
			int ind = -1; // the index of this operation
			int cnt = -1; // the number of operands after this operation (3 means 3 or more)
			// loop over tokens
			for (int i = 0; i < N;)
			{
				// we skip integer token
				if (ex[i].type == INT) {
					++i;
					continue;
				}
				// priority of the current operation
				int cur_op = ex[i].val;
				// calculating the index of first operation after the given one
				int j;
				for (j = i + 1; j < N && ex[j].type == INT; ++j)
					;
				// the number of operands after cur_op
				int cur_cnt = min(j - i - 1, 3);
				// relax (op, ind, cnt) by (cur_op, i, cur_cnt) if necessary
				// namely when cnt is smaller or it is equal but op has lower priority
				if(cnt < cur_cnt || cnt==cur_cnt && op > cur_op) {
					cnt = cur_cnt;
					op = cur_op;
					ind = i;
				}
				// moving tokens cursor to j
				i = j;
			}
			// cnt < 2 means that we do not meet operation with at least 2 operands
			// or do not meet any operation at all
			if (cnt < 2) {
				// so we output "NOT OK" and stop the evaluation
				printf("NOT OK\n");
				break;
			}
			// otherwise we do calculation
			// A and B are to operands followed by op
			int A = ex[ind + 1].val;
			int B = ex[ind + 2].val;
			int C; // the result of calculation
			if(!calc(op, A, B, C)) {
				// in case of error we output "NOT OK" and stop the evaluation
				printf("NOT OK\n");
				break;
			}
			// otherwise we output the calculation log as required
			printf("%d %c %d %d %d\n", ind + 1, pri[op], A, B, C);
			ex[ind + 2].val = C; // we replace B by C
			ex.erase(ex.begin() + ind, ex.begin() + ind + 2); // and erase op and A
		}
	}
	return 0;
}