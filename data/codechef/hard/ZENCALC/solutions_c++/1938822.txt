#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <string>
#include <vector>
using namespace std;

const int maxV  = 2147483647; 
const int minV = -maxV-1;
const char ops[] = {'!', '^', '/', '*', '+', '-'};

enum Type {OP, INT};

struct token {
  int type;
  int val;
};
int EFlag;

void swap(long long int *a, long long int *b)
{
  long long int t = *a;
  *a = *b;
  *b = t;
}

bool invModulo(long long int a, long long int b, int &c)
{
  int xLast=1, yLast=0, x=0, y=1, nx, ny, q, r, flaga = false;
  if(a < 0){
    flaga = true;
    a = -a;
  }
  if(b<0)
    b = -b;
  while(b != 1 && a){
    q = a/b;
    nx = xLast - q*x;
    ny = yLast - q*y;
    xLast = x;
    yLast = y;
    x = nx;
    y = ny;
    a = a%b;
    swap(&a, &b);
  }
  if(flaga)
    x = -x;
  if(a){
    c = x;
    return true;
  }
  return false;
}

bool divModulo(int a, int b, int &c)
{
  if(b%2){
    if(invModulo(b, 1LL<<32, c)){
      c = c*a;
      return true;
    }
    else return false;
  }
  if(b==0){
    if(a){
      return false;
    }
    c = minV;
    return true;
  }
  if(a == 0){
    c = minV;
    return true;
  }
  int k=0;
  while(a%2 == 0 && b%2 == 0){
    a /= 2;
    b /= 2;
    k++;
  }
  if(b%2 == 0){
    return false;
  }
  if(invModulo(b, 1LL<<(32-k), c)){
    c = a*c;
    c %= 1U<<(32-k);
    if(c<0){
      c += 1U << (32-k);
    }
    c += minV;
    return true;
  }
  else
    return false;
}

int pow32Modulo(int a, unsigned int b)
{
  int res = 1;
  while(b){
    if(b%2){
      res *= a;
    }
    if(b /= 2){
      a *= a;
    }
  }
  return res;
}

int powModulo(int a, int b, int &c)
{
  if(a%2 == 0 && b<0)
    return false;
  c = pow32Modulo(a, b);
  return true;
}

int factModulo(int a)
{
  if(a < -33 || a > 33)
    return 0;
  int fact = 1;
  for(int i=1; i<=abs(a); i++)
    fact *= i;
  if(a < 0 && a%2)
    return -fact;
  return fact;
}

bool calc(int op, int or1, int or2, int &c){
  switch(op){
  case 1: return powModulo(or1, or2, c);
  case 2: return divModulo(or1, or2, c);
  case 3: c = or1*or2;
    break;
  case 4: c = or1+or2;
    break;
  case 5: c = or1-or2;
    break;
  }
  return true;
}

void print(vector<token> inp){
  for(int i=0; i<inp.size(); i++){
    if(inp[i].type == INT)
      printf("%d ", inp[i].val);
    else{
      switch (inp[i].val) {
      case 0: printf("! ");
	break;
      case 1: printf("^ ");
	break;
      case 2: printf("/ ");
	break;
      case 3: printf("* ");
	break;
      case 4: printf("+ ");
	break;
      case 5: printf("- ");
	break;
      }
    }
  }
  printf("\n");
}

int main(void)
{
  int a, b, T, n;
  char str[100];
  scanf("%d", &T);
  while(T--){
    scanf("%d", &n);
    vector<token> inp(n);
    for(int i=0; i<n; i++){
      scanf("%s", str);
      token nTok;
      if(sscanf(str,"%d", &(nTok.val)) == 1){
	nTok.type = INT;
      }
      else{
	nTok.type = OP;
	switch(str[0]){
	case '!': nTok.val = 0;
	  break;
	case '^': nTok.val = 1;
	  break;
	case '/': nTok.val = 2;
	  break;
	case '*': nTok.val = 3;
	  break;
	case '+': nTok.val = 4;
	  break;
	case '-': nTok.val = 5;
	  break;
	}
      }
      inp[i] = nTok;
    }
    while(true){
      //      print(inp);
      int fi=-1;
      int res;
      for(int i=0; i<inp.size();){
	if(inp[i].type == OP && inp[i].val == 0){
	  fi = i;
	  i++;
	}
	else if(inp[i].type == INT && fi != -1){
	  res = factModulo(inp[i].val);
	  printf("%d ! %d -1 %d\n", fi+1, inp[i].val, res);
	  inp[i].val = res;
	  inp.erase(inp.begin() + fi);
	  fi = -1;
	  i = i>1?i-2:i-1;
	  continue;
	}
	else{
	  i++;
	  fi = -1;
	}
      }
      if(inp.size() == 1 && inp[0].type == INT){
	printf("OK\n");
	break;
      }
      int op = -1;
      int ind = -1;
      int cnt = -1;
      int cur_op = -1;
      int cur_cnt = -1;
      int cur_ind = -1;
      for(int i=0; i<inp.size(); i++){
	if(inp[i].type == OP){
	  cur_op = inp[i].val;
	  cur_cnt = 0;
	  cur_ind = i;
	}
	else if(cur_op != -1 && cur_cnt<3){
	  cur_cnt++;
	}
	if(cnt < cur_cnt){
	  op = cur_op;
	  cnt = cur_cnt;
	  ind = cur_ind;
	}
	else if(cnt == cur_cnt && op > cur_op){
	  op = cur_op;
	  cnt = cur_cnt;
	  ind = cur_ind;
	}
      }	
      if(cnt < 2){
	printf("NOT OK\n");
	break;
      }
      else{
	if(calc(op, inp[ind+1].val, inp[ind+2].val, res)){
	  printf("%d %c %d %d %d\n", ind+1, ops[op], inp[ind+1].val, inp[ind+2].val, res);
	  inp[ind+2].val = res;
	  inp.erase(inp.begin() + ind, inp.begin() + ind + 2);
	}
	else{
	  printf("NOT OK\n");
	  break;
	}
      }
    }
  }
  return 0;
}
