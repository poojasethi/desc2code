#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>

using namespace std;

const int kMaxN = 1000000, kMaxR = 500, kMaxC = 2500;
int n, r, c;
int idx[256];

#define ID(x, y) ((x) * c + (y))

struct IndexTree {
	int root[kMaxR * kMaxC];
	int cnt[kMaxR * kMaxC];
	void clear() {
		for (int i = 0; i < r * c; ++ i) root[i] = i, cnt[i] = 0;
	}
	int find(int x) {
		if (x == root[x]) return x;
		int y = find(root[x]);
		cnt[y] += cnt[x], cnt[x] = 0;
		return (root[x] = y);
	}
	void merge(int x, int y) {
		x = find(x), y = find(y);
		if (x != y) {
			root[x] = y;
			cnt[y] += cnt[x], cnt[x] = 0;
		}
	}
} ds;

void Get(char *src, int &a, int &b) {
	a = idx[*(src ++)];
	a = a * 52 + idx[*(src ++)];
	b = idx[*(src ++)];
	b = b * 52 + idx[*(src ++)];
}

void Get(char *src, int &a, int &b, int &c, int &d) {
	a = idx[*(src ++)];
	a = a * 52 + idx[*(src ++)];
	b = idx[*(src ++)];
	b = b * 52 + idx[*(src ++)];
	c = idx[*(src ++)];
	c = c * 52 + idx[*(src ++)];
	d = idx[*(src ++)];
	d = d * 52 + idx[*(src ++)];
}

int main() {
	//freopen("t.in", "r", stdin);
	scanf("%d%d%d", &n, &r, &c);
	ds.clear();
	for (int i = 0; i < 26; ++ i) idx['A' + i] = i;
	for (int i = 0; i < 26; ++ i) idx['a' + i] = i + 26;
	while (n --) {
		static char buf[32];
		scanf("%s", buf);
		if (buf[0] == 'W') {
			int x0, y0, x1, y1;
			Get(buf + 1, y0, x0, y1, x1);
			-- x0, -- y0, -- x1, -- y1;
			x0 /= 5, x1 /= 5;
			ds.merge(ID(x0, y0), ID(x1, y1));
		}
		else if (buf[0] == 'V') {
			int x, y;
			Get(buf + 1, y, x);
			-- x, -- y;
			x /= 5;
			++ ds.cnt[ds.find(ID(x, y))];
		}
		else if (buf[0] == 'R') {
			int x, y;
			Get(buf + 1, y, x);
			-- x, -- y;
			x /= 5;
			-- ds.cnt[ds.find(ID(x, y))];
		}
		else {
			int x0, y0, x1, y1;
			Get(buf + 1, y0, x0, y1, x1);
			-- x0, -- y0, -- x1, -- y1;
			x0 /= 5, x1 /= 5;
			puts((ds.cnt[ds.find(ID(x0, y0))] > 0) == (ds.cnt[ds.find(ID(x1, y1))] > 0) ? "OFF" : "ON");
		}	
	}
	return 0;
}