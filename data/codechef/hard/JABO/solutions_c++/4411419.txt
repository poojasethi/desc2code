#include <iostream>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <list>
#include <vector>
#include <string>
#include <deque>
#include <bitset>
#include <algorithm>
#include <utility>
#include <functional>
#include <limits>
#include <numeric>
#include <complex>
#include <cassert>
#include <cmath>
#include <memory.h>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <climits>

using namespace std;

template<typename X> inline X abs(const X& a) { return (a < 0 ? -a : a); }
template<typename X> inline X sqr(const X& a) { return (a * a); }
template<typename X> inline void print(const X& a,int N) {cout<<endl;for(int i=0;i<N;i++)cout<<a[i]<<" ";cout<<endl;}
typedef long long ll;
typedef long double ld;
typedef pair<int,int> pp;
typedef pair<ld, ld> ppld;
typedef unsigned long long ull;

#define swap(a,b) a^=b^=a^=b;
#define FOR(i, n) for(int i = 0; i < int(n); i++)
#define FORD(i, n) for(int i = int(n-1); i >= 0; i--)
#define FORAB(i, a, b) for(int i = int(a); i < int(b); i++)
#define foreach(it, a) for(__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)
#define pb push_back
#define mp make_pair
#define mset(a, val) memset(a, val, sizeof (a))
#define all(a) (a).begin(), (a).end()
#define rall(a) (a).rbegin(), (a).rend()
#define getcx getchar
#define getmid(a,b) (a+(b-a)/2)
#define tr(container, it) \
   for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) //to iterate in container

const int INF = int(1e9);
const ll INF64 = ll(INF) * ll(INF);
const ld EPS = 1e-9;
const ld PI = ld(3.1415926535897932384626433832795);

template<typename X> inline void inp(X &n ) {
     int ch=getcx();int sign=1;n=0;
     while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}
     while(  ch >= '0' && ch <= '9' ) n = (n<<3)+(n<<1) + ch-'0', ch=getcx();
     n=n*sign;
}
template<typename X> inline void out(X a) {
    char snum[20]; int i=0;
    do {snum[i++]=a%10+48; a=a/10; }while(a!=0);
    i=i-1;
    while(i>=0) putchar(snum[i--]);
    putchar('\n');
}
#define MAX 1250005

int pointParent[MAX];
int voltPoint[MAX];
int rankPoint[MAX];

int findParent(int node)
{
	if(pointParent[node] == node)
		return node;
	else
	{
		pointParent[node] = findParent(pointParent[node]);
		return pointParent[node];
	}
}

void mergeForest(int a, int b)
{
	if(rankPoint[a] == rankPoint[b])
	{
		++rankPoint[a];
		pointParent[b] = a;
		voltPoint[a]+=voltPoint[b];
	}
	else
	{
		if(rankPoint[a]>rankPoint[b])
		{
			pointParent[b] = a;
			voltPoint[a]+=voltPoint[b];
		}
		else
		{
			pointParent[a] = b;
			voltPoint[b]+=voltPoint[a];
		}
	}
}

int getCoOrdinate(char a, char b)
{
	int asciiA = (int)a;
	int asciiB = (int)b;
	if(asciiA>=65 && asciiA<=90)
		asciiA-=65;
	else
		asciiA-=71;

	if(asciiB>=65 && asciiB<=90)
		asciiB-=65;
	else
		asciiB-=71;

	return (((asciiA*52)+asciiB) - 1);
}

bool getPotential(int x)
{
	return voltPoint[x]!=0;
}

int main()
{
	int x1, x2, y1, y2, a, b;
	int i, size;
	int rows, columns, queries;
	char inputQuery[20];

	scanf("%d %d %d", &queries, &rows, &columns);
	size = columns*rows;
	for(i=0; i<size; ++i)
	{
		pointParent[i] = i;
		rankPoint[i] = 0;
		voltPoint[i] = 0;
	}

	while(queries--)
	{
		scanf("%s",inputQuery);
		
		switch(inputQuery[0])
		{
		case 'W':
			{
				x1 = getCoOrdinate(inputQuery[1], inputQuery[2]);
				y1 = getCoOrdinate(inputQuery[3], inputQuery[4]) / 5;

				x2 = getCoOrdinate(inputQuery[5], inputQuery[6]);
				y2 = getCoOrdinate(inputQuery[7], inputQuery[8]) / 5;

				a = x1 + (y1 * columns);
				b = x2 + (y2 * columns);

				a = findParent(a);
				b = findParent(b);
				if(a!=b)
					mergeForest(a, b);
			}
			break;

		case 'R':
			{
				x1 = getCoOrdinate(inputQuery[1], inputQuery[2]);
				y1 = getCoOrdinate(inputQuery[3], inputQuery[4]) / 5;

				a = x1 + (y1 * columns);
				a = findParent(a);
				voltPoint[a]--;
			}
			break;

		case 'L':
			{
				x1 = getCoOrdinate(inputQuery[1], inputQuery[2]);
				y1 = getCoOrdinate(inputQuery[3], inputQuery[4]) / 5;

				x2 = getCoOrdinate(inputQuery[5], inputQuery[6]);
				y2 = getCoOrdinate(inputQuery[7], inputQuery[8]) / 5;

				a = x1 + (y1 * columns);
				b = x2 + (y2 * columns);
				
				a = findParent(a);
				b = findParent(b);

				if(getPotential(a)!=getPotential(b))
					printf("ON\n");
				else
					printf("OFF\n");
			}
			break;

		case 'V':
			{
				x1 = getCoOrdinate(inputQuery[1], inputQuery[2]);
				y1 = getCoOrdinate(inputQuery[3], inputQuery[4]) / 5;

				a = x1 + (y1 * columns);
				a = findParent(a);
				voltPoint[a]++;
			}
			break;
		}
	}


	return 0;
}