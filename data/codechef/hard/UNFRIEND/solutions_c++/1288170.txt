#include<queue>
#include<cstdio>

#define rep(i,n) for(int i=0;i<(n);i++)

using namespace std;

struct edge{ int u,v; };

const int V_MAX=50;

bool is_bipartite(int n,const vector<int> *G){
	int L=0,R=0;
	static int color[V_MAX];
	rep(u,n) color[u]=-1;

	rep(u,n) if(color[u]==-1) {
		color[u]=2*(L++);

		queue<int> Q; Q.push(u);
		while(!Q.empty()){
			int v=Q.front(); Q.pop();

			rep(i,G[v].size()){
				int w=G[v][i];
				if(color[w]%2==color[v]%2) return false;
				if(color[w]==-1){
					if(color[v]%2==0) color[w]=2*(R++)+1;
					else              color[w]=2*(L++);
					Q.push(w);
				}
			}
		}
	}

	return true;
}

int main(){
	int T; scanf("%d",&T);
	while(T--){
		int n,m; scanf("%d%d",&n,&m);
		edge E[200];
		rep(i,m) scanf("%d%d",&E[i].u,&E[i].v), E[i].u--, E[i].v--;

		int w; scanf("%d",&w);
		bool warp[200]={};
		rep(i,w){
			int id; scanf("%d",&id); id--;
			warp[id]=true;
		}

		vector<int> G[V_MAX];
		rep(i,m) if(!warp[i]) {
			G[E[i].u].push_back(E[i].v);
			G[E[i].v].push_back(E[i].u);
		}
		puts(is_bipartite(n,G)?"YES":"NO");
	}

	return 0;
}
