#include <cstdio>
#include <vector>
#include <queue>
#include <string.h>

#define MAXV 50
#define MAXE 200

using namespace std;
	 
inline void inp(int &n){
        n = 0;
        char ch = getchar();
        int sign = 1;
        while(ch < '0' || ch > '9'){
                 if(ch == '-')
                       sign = -1; 
                 ch = getchar();
        }
        while(ch >= '0' && ch <= '9'){
                n = (n<<3) + (n<<1) + ch - '0';
                ch = getchar();
        }
        n = n*sign;
}

struct Edge {
       int from, to;
}E[MAXE];

int visited[MAXV + 1];
int partition[MAXV + 1];
int G[MAXV + 1][MAXV + 1];

void Reset(){
     memset(partition, 0, sizeof(partition));
     memset(visited, 0, sizeof(visited));
     memset(G, 0, sizeof(G));
}

bool is_bipartite(int n){
     
     queue <int> Q;
     
     for (int i = 1; i <= n; i++) {
         if (!visited[i]) {
             Q.push(i);
             partition[i] = 1;
             
             while(!Q.empty()){
                  int u = Q.front(); 
                  Q.pop();
                  
                  for(int v = 1; v <= n; v++){
                        if (G[u][v]){
            	            if(partition[u] == partition[v]) 
                                  return false;
                                  
            	            if(!visited[v]){
            	                partition[v] = 3 - partition[u];
            	                Q.push(v);
            	            }
                        }
                  }
                  visited[u] = true;
             }
         }
     }
     return true;
}
	 
int main(){
    int T, N, M, W, u, v, indx;
    
    inp(T);
    while(T--) {
               inp(N), inp(M);
               
               for(int i = 0; i < M; i++){
                       inp(u), inp(v);
                       
                       E[i].from = u;
                       E[i].to = v;
                       
                       G[u][v] = G[v][u] = 1;
               }
               
               inp(W);
               for(int i = 0; i < W; i++) {
                       inp(indx);
                       G[E[indx - 1].from][E[indx - 1].to] = G[E[indx - 1].to][E[indx - 1].from] = 0;
               }
               
               if(is_bipartite(N))
                    printf("YES\n");
               else
                   printf("NO\n");
                   
               Reset();
    }
    
    return 0;
}
