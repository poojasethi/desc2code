#include <iostream>
#include <cstdio>
#include <vector>
#include <queue>
#include <stack>
#include <cassert>
#include <cstdlib>
#include <cmath>
#include <utility>
#include <algorithm>
#include <map>
#include <climits>
#include <string>
#include <cstring>
using namespace std;
 
typedef long long LL;
typedef unsigned long long ULL;
typedef vector<int> VI;
typedef vector<ULL> VULL;
typedef vector<LL> VLL;
 
#define MX 100000001
#define MN -1
#define SZ 1001
#define REP(i, s, e) for(int i = (s); i <= (e); ++i)
#define FOR(i, s, n) for(int i = (s); i < (n); ++i)
#define FORALL(i, n) for(int i = 0; i < (n); ++i)
#define pushb push_back
#define MOD 1000000007
 
int a[SZ][SZ] ={0}, areas[SZ][SZ] = {0}, dp[SZ][SZ] = {0};
 
int inline scan() {
    int N = 0;
    char C;
    C = getchar_unlocked();
    while (C < '0' || C > '9') C = getchar_unlocked();
    while (C >= '0' && C <= '9') {
        N = (N<<3) + (N<<1) + C - '0';
        C = getchar_unlocked();
    }
    return N;
}
 
void compute_areas(int hist[], int *area, int n) {
    stack<int> s;
	int hcopy[n];
	FOR(i, 1, n+1) hcopy[i-1] = hist[i];
    int top, top_area, i = 0, minh = SZ, maxh = 0;
    while (i < n) {
        if (s.empty() || hcopy[s.top()] <= hcopy[i]) s.push(i++);
        else {
            top = s.top();
            s.pop();
			maxh = max(maxh, hcopy[top]);
            top_area = hcopy[top] * (s.empty() ? i : i - s.top() - 1);
			area[hcopy[top]] = max(area[hcopy[top]], top_area);
        }
    }
    while (!s.empty()) {
        top = s.top();
        s.pop();
		maxh = max(maxh, hcopy[top]);
		top_area = hcopy[top] * (s.empty() ? i : i - s.top() - 1);
        area[hcopy[top]] = max(area[hcopy[top]], top_area);
    }
	int maxw = 0;
	for(int h = maxh; h > 0; h--) {
		maxw = max(maxw, area[h]/h);
		area[h] = max(h*maxw, area[h]);
	}
}
 
int main() {
	int n, m, k, x, y, q, h, mx = 0;
	n = scan(); m = scan(); k = scan();
	while (k--) {
		x = scan(); y = scan();
		a[x][y] = 1;
	}
	FOR(i, 1, n+1) {
		FOR(j, 1, m+1) {
			if (!a[i][j]) a[i][j] = 1 + a[i-1][j];
			else a[i][j] = 0;
		}
	}
	FOR(i, 1, n+1) compute_areas(a[i], areas[i], m);
	FOR(i, 1, n+1) {
		FOR(h, 1, i+1) {
			dp[i][h] = max(dp[i-1][h-1], dp[i][h-1]);
			dp[i][h] = max(dp[i][h], areas[i][h]);
		}
	}
	q = scan();
	while (q--) {
		x = scan(); y = scan();
		printf ("%d\n", dp[y][y-x+1]);
	}
	return 0;
} 