# include <iostream>
# include <sstream>
# include <algorithm>
# include <cstdio>
# include <cmath>
# include <numeric>
# include <cstdlib>
# include <cstring>
# include <vector>
# include <list>
# include <set>
# include <map>
# include <stack>
# include <queue>
# include <cctype>
# include <climits>
# include <complex>
using namespace std;
typedef long long ll ;
typedef unsigned long long ull;
ll INF = 1e9 ;
typedef pair < int , int > pii ;
typedef  vector < int > vi ;
typedef vector < pii > vpi ;
typedef vector < ll > vl ;
typedef pair < int , pii > tri ;
typedef vector < string > vs ;
typedef vector < vi > mat ;
#define all(a) a.begin(),a.end()
#define si(n) scanf("%d",&n)
#define ss(n) scanf("%s" , n)
#define sl(n) scanf("%lld" , &n)
#define pi(n) printf("%d" , n)
#define ps(n) printf("%s" , n)
#define pl(n) printf("%lld" , n)
#define pnl() printf("\n")
#define fors( i , a , b ) for ( int i = a ; i < b ; i++ )
#define pb push_back
#define ff first
#define mp make_pair
#define sz(a) a.size()
#define fill(a,v)  memset(a,v,sizeof(a))
#define index(arr,ind) (lower_bound(all(arr),ind)-arr.begin())

int n , m , k , a[1005][1005] , ans[1005][1005] , lefto[1005] , righto[1005] , width[1005] ;

int cal( int row )
{
    //ll ans = 0 , temans = 0 ;
    int t ;
// to store indexes  in increasing order of elements

   stack < int > s ;

   fors (i , 0 , m + 1 )
   lefto[i] = righto[i] = 0 ;

  // calculating left boundaries of each bar
  fors ( i , 1  , m + 1  )
  {
      // extract elements till i donot get the element less than the ith element
    while ( !s.empty())
    {
        if ( a[row][s.top()] >= a[row][i])
        {
            s.pop() ;
        }
        else
            break ;
    }

    if ( s.empty() )
    {
        t = 0 ;
    }
    else
    {
        t = s.top() ;
    }
   lefto[i] = i - t - 1 ;
   s.push(i) ;
  }

  while ( !s.empty() )
  {
      s.pop() ;
  }

  // calculating right
  for ( int i = m  ; i > 0 ; i--)
  {
    while ( !s.empty())
    {
        if ( a[row][s.top()] >= a[row][i])
        {
            s.pop() ;
        }
        else
            break ;
    }
    if ( s.empty() )
    {
        t = m + 1  ;
    }
    else
    {
        t = s.top() ;
    }
   righto[i] = t - i  - 1 ;
   s.push(i) ;
  }

  memset ( width , 0 , sizeof(width)) ;

  // finding maximum width for each height
  fors ( i , 1 , m + 1 )
  {
      width[a[row][i]] = max ( width[a[row][i]]  ,   (lefto[i]  + righto[i] + 1)  ) ;
  }

  int len = 0 ;


  fors ( j , 1 , row + 1 )
  {
      len = max ( len , width[row - j + 1] ) ;
      ans[row][j] = len * ( row - j + 1 ) ;
  }



  for( int j = row ; j > 0 ; j--)
  {
      ans[row][j] = max ( ans[row][j] , ans[row - 1 ][j] ) ;
      ans[row][j] = max ( ans[row][j] , ans[row][j+1]) ;
  }




/*      fors ( j , 1 , row + 1 )
      {
          cout << ans[row][j] << " " ;
      }
      cout << endl ;
*/






/*fors ( i , 0 , n )
{
    cout << lefto[i] << " "  ;
}

cout << endl  ;

fors ( i , 0 , n )
{
    cout << righto[i] << " "  ;
}

cout << endl  ;

fors( i , 0 , n )
  {
      temans = a[i] * ( lefto[i] + righto[i] + 1 ) ;
      ans = max ( ans , temans ) ;
  }


return ans ;
*/
}





int main()
{
  int q , x , y ;
  si(n) , si(m) , si(k) ;
  fors ( i , 1 , n + 1  )
  {
      fors ( j , 1  , m  + 1 )
      a[i][j] = 1 ;
  }

  fors ( te , 0 , k  )
  {
      si(x) , si(y) ;
      a[x][y] = 0 ;
  }

fors ( j , 0 , m + 2 )
ans[0][j] = ans[n+1][j] = 0 ;

fors( i , 0 , n + 2)
ans[i][0] = ans[i][m+1] = 0 ;


  // calculating histogram


  fors ( i , 2 , n + 1 )
  {
      fors ( j , 1, m + 1 )
      {
          if ( a[i][j])
          a[i][j] += a[i-1][j] ;
          else
            a[i][j] = 0 ;
      }
  }



// now finding left and right of each bar

  fors ( i , 1 , n + 1 )
  {
      cal(i) ;
  }

  si(q);
  int lo , hi ;
  while ( q-- )
  {
      si(lo) , si(hi) ;
    printf("%d\n" , ans[hi][lo]) ;
  }
return 0 ;
}
