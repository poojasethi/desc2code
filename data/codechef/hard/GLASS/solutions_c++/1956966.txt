/* Money Changing Problem / Frobenius Numbers:
Computing the Frobenius number in time O(k a1)
Sebastian Böcker Zsuzsanna Lipták

In the classical Money Changing Problem (MCP), we are given coins of k different values a1 < a2 < · · · < ak with gcd(a1, . . . , ak) = 1. We want to know what change n = summation( aixi ) we can generate from these coins for non-negative integers xi, assuming that we have an infinite supply of coins. Then, there exists an integer g(a1, . . . , ak) called the Frobenius number of a1, . . . , ak, such that g(a1, . . . , ak) does not allow a decomposition of the above type, but all integers n > g(a1, . . . , ak) do. for k = 2 we have g(a1, a2) = a1a2 − a1 − a2. It is NP-Hard Probem.

For integers a, b, let a mod b denote the unique integer in 0, . . . , b − 1 such that (a mod b) == a mod b holds. Let a1 < · · · < ak with gcd(a1, . . . , ak) = 1 be an instance of the Money Changing Problem. We denote by np the smallest integer with np == p mod a1 ( NOTE: on doing p%a1 we make x1=0 as it eliminates the sum in n produces by quantity a1*x1. For e.g. let a1=3 a2= 2 and n= 13 ( 3*3 + 2*2) now on doping 13%3 = 4 (3*0 + 2*2). this implies that all the contribution made by a1 has been nullified and hence x1 = 0 now. The same aruement holds true for all ai's ) that can be decomposed into a non-negative integer combination of a1, . . . , ak. The np are well-defined: If n has a decomposition, so has n + a1 ( x1-> x1+1 ), and n  == n + a1 mod a1. Clearly, summation( ai*xi ) = np implies x1 = 0 because otherwise, np − a1 (this would mean that np was not the samllest number ) has a decomposition, too. If the np are known, then we can test in constant time whether some number n can be decomposed: Set p = n mod a1, then n can be decomposed if and only if n >= np. Given the values np for p = 0, . . . , a1 − 1 we can compute the Frobenius number g(a1, . . . , ak) and the number of omitted values ! that cannot be decomposed using a1, . . . , ak. 
*/

/*
np=  smallest integer with np == p mod a1 that can be decomposed into a non-negative integer combination of a1, . . . , ak.

Round Robin Algorithm for frobenius numbers 
initialize n0 = 0 and np = -1 for p = 1, . . . , a1 − 1
2 for i = 2, . . . , k do
3 	d = gcd(a1, ai);
4 	for r = 0, . . . , d − 1 do
5 		Find n = min{nq : q = r, r + d, r + 2d, . . . , r + (a1 − d)};
6 		If n < -1 then repeat a1/d times
7			n = n + ai;
			p = n mod a1;
8 			n = min{n, np}; n =  np;
9 		done;
10	done;
11 done.
*/

#include <cstdio>
#include <algorithm>
using namespace std;

#define FOR(i,a,b) for(int i=a;i<b;i++)
#define FORD(i,a,b) for(int i=a;i>=b;i--)
#define wile(n) while(n--> 0 )
#define REP(i,n) FOR(i,0,n)
typedef long long int LL;
#define INF 1000000000000000000LL

inline long long int FAST_IO()
{	long long int x=0;
	char ch;
	while ((ch=getchar_unlocked()) < 48 || ch > 57);
	x = ch-48;
	while ((ch=getchar_unlocked()) >= 48 && ch <= 57)
		x=x*10+ch-48;
	return x;
}

LL np[100010];

LL gcd(LL a,LL b)
{	return (b==0) ? a : gcd((LL)b,(LL)a%b);		}

int main()
{	LL t, gc, p, q, a1, c1, b1, x, maxm, n,a[100],d,y,no,yes;
	t= FAST_IO();
	wile(t)
	{	n=FAST_IO();
		REP(i,n)
			a[i]=FAST_IO();
		q= FAST_IO();
		a1= FAST_IO();
		b1= FAST_IO();
		c1= FAST_IO();
		sort(a,a+n);
		REP(i,a[0])
			np[i]=INF;
		np[0]=0;
		gc=gcd(a[0],a[1]);
		FOR(i,2,n)
			gc=gcd(gc,a[i]);
		FOR(i,1,n)
		{	d=gcd(a[0],a[i]);
			for(LL j=0;j<d;j++)
			{	x=INF;
				for(LL k=j;k<=j+a[0]-d;k+=d)
					x=min(x,np[k]);
				if(x<INF)
				{	REP(ii,a[0]/d)
					{	x+=a[i];
						p=x%a[0];
						x=min(x,np[p]);
						np[p]=x;
					}
				}
			}
		}
		maxm=-INF;
		REP(i,a[0])
			maxm=max(maxm,np[i]);
		if(gc==1)
			printf("%lld\n",maxm-a[0]);
		else
			printf("%lld\n",-1LL);
		no=0,yes=0;
		FOR(i,1,q+1)
		{	LL num=(a1*i+b1)%c1;
			LL p=num%a[0];
			if(np[p]>num)
				no++;
			else
				yes++;
		}
		printf("%lld %lld\n",no,yes);
	}
	return 0;
}