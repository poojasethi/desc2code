#include <cstring>
#include <string>
#include <iostream>
#include <cstdio>
#include <vector>
#include <cassert>
#include <algorithm>

using namespace std;
#define MAXN 55
typedef long long int64;

/* 
    Problem can be reduced to red-black hackenbush 
    even=blue,odd=red
    http://en.wikipedia.org/wiki/Hackenbush
    Each pile represent a hackenbush stalk 
    Game value cooresponding to hackenbush stalk is easy to find. 
    Please refer here : http://www.geometer.org/mathcircles/hackenbush.pdf. 
    For hackebush games value of two disjoint game is equal to sum of individual game value.
    (http://www-math.mit.edu/~rstan/transparencies/games.pdf)

*/ 
       
int t,n,tcase;
int arr[MAXN];

int64 calculate(){
   int64 res = 0; int64 value = 1LL<<48;
   res = (arr[0]%2==0)?value:-value;
   bool is_changed = false;
   for(int i=1; i<n; ++i){
      assert(arr[i]!=arr[i-1]);
      if(arr[i]%2 != arr[i-1]%2){
          is_changed = true;
      }
      if(is_changed) value /= 2;
      res += (arr[i]%2==0)?value:-value;
   }
   return res;
}

int main(){
  for(scanf("%d",&tcase); tcase; tcase-=1){
     scanf("%d",&t); 
     int64 res = 0;
     for(int i=0; i<t; ++i){
       scanf("%d",&n);
       for(int j=0; j<n; ++j) scanf("%d",&arr[j]);
       sort(arr,arr+n);
       res += calculate();
     }
     if(res > 0 ) printf("EVEN\n");
     else if(res < 0 ) printf("ODD\n");
     else printf("DON'T PLAY\n");
  }
  return 0; 
}
