#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
#include <cstdlib>
using namespace std;
//EVEN = BLUE
//ODD = RED
//blue-red Hackenbush

typedef long long int64;
const int64 DENOMINATOR = 1LL << 50, INF = 1LL << 60;

int nextInt() { //fast input method to speed up
	char ch;
	while (ch = getchar(), ch < '0' || ch > '9')
		;
	int ret = ch - '0';
	while (ch = getchar(), ch >= '0' && ch <= '9')
		ret = ret * 10 + ch - '0';
	return ret;
}

//a straightforward implementation of blue-red Hackenbush
//You can find detail in this paper:http://www.link.cs.cmu.edu/15859-s11/notes/Hackenbush.pdf
int64 calc() {
	static int a[50], n;
//	scanf("%d", &n);
	n = nextInt();
	for (int i = 0; i < n; ++i) {
//		scanf("%d", a + i);
		a[i] = nextInt();
	}
	sort(a, a + n);
	n = unique(a, a + n) - a;
//	return 0;

	static int64 dp[50];
	dp[0] = 0;

	int64 r = INF, b = -INF, pw = DENOMINATOR;

	for (int i = 1; i <= n; ++i) {

		if (a[i - 1] % 2 == 1)
			r = min(r, dp[i - 1]);
		else
			b = max(b, dp[i - 1]);

		for (;; pw /= 2) {
			//find a pw's multiplier between b and r
//			cout << "start" << endl;
			int64 L = (b / pw - 2) * pw;
			while (L <= b) {
				L += pw;
			}

			int64 R = (r / pw + 2) * pw;
			while (R >= r)
				R -= pw;
//			cout << "end" << endl;

//[L,R]
			if (L <= R) {
				if (L <= 0 && R >= 0) {
					dp[i] = 0;
				} else {
					if (llabs(L) < llabs(R))
						dp[i] = L;
					else
						dp[i] = R;
				}
				break;
			}
		}
	}

	return dp[n];
}

int main() {
	int T = nextInt();
//	cin >> T;
	while (T--) {
		int k = nextInt();
//		scanf("%d", &k);
		int64 sum = 0;
		while (k--)
			sum += calc();
		if (sum > 0)
			puts("EVEN");
		else if (sum < 0)
			puts("ODD");
		else
			puts("DON'T PLAY");
	}
}
