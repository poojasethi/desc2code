#include <bits/stdc++.h>

#define LL long long
#define FI first
#define SE second
#define PB push_back
#define MP make_pair
#define VI vector<int> 
#define VP vector<PII>
#define VS vector<string>
#define PII pair<int, int>
#define SZ(a) ((int) a.size())
#define ALL(a) a.begin(), a.end()
#define mem(a) memset(a, 0, sizeof(a))
#define memm(a) memset(a, -1, sizeof(a))

#define SL(a) strlen(a)
#define RS(s) scanf("%s", (s))
#define PI(r) printf("%d\n", (r))
#define RI(a) scanf("%d", &(a))
#define RII(a, b) scanf("%d%d", &(a), &(b))
#define RIII(a, b, c) scanf("%d%d%d", &(a), &(b), &(c))

#define DBG(x, s) cout << (x) << ' ' << (s) << endl
#define REP(i, n) for (int i = 0; i < (int) (n); ++i)
#define REPP(i, a, b) for (int i = (int) (a); i <= (int) (b); ++i)
#define RED(i, n) for (int i = (int) (n - 1); i >= 0; --i)
#define REDD(i, a, b) for (int i = (int) (a); i >= (int) (b); --i)

#define L (x << 1)
#define R ((x << 1) | 1)
#define MID ((l + r) >> 1)
#define LC L, l, MID
#define RC R, MID + 1, r
#define LB(x) ((x) & (-(x)))
#define B(x) __builtin_popcount(x)

#define EPS 1e-7
#define INF 0x3f3f3f3f
#define LIM (1ll << 60)

using namespace std;

int n, m;

//倍增
//无论如何请在字符串最后加一个未出现过的标记字符比如'#'(35), '@'('A'-1), '['('Z'+1), '`'('a'-1), '{'('z'+1)
//'A'(65) 'a'(97)

const int N = 100050;

struct Suffix_Array {
	int s[N]; // or int s[N];
	int sa[N], t1[N], t2[N], c[N], n; // n 字符串长度 sa 后缀数组
	//sa[i] 排名是i的后缀的序号（从0开始标号，第零个是我们添加的字符的后缀，显然是n，sa[0] = n）
	
	void Init(int x) { //x = SL(s) or etc;
		n = x;
		// s[n] = '#', s[++n] = 0;
		//s[n]要比所有出现的字符（or数字）小，但是大于0，比如'#'，或者数字的时候1
		getsa(50);
		gethg();
		// n--;//n现在变成原串长度，不包含'#'
		//所有初始化数组已经写在函数里面，没有必要另外memset了。
	}

	void getsa(int m) { // m 字符集大小
		int *x = t1, *y = t2;
		mem(c);
		REP(i, n) c[x[i] = s[i]]++; //这里反正都是转化成 int 做
		REPP(i, 1, m - 1) c[i] += c[i - 1];
		for (int i = n - 1; i >= 0; --i) sa[--c[x[i]]] = i;
		for(int k = 1; k <= n; k <<= 1) {
			int p = 0;
			for (int i = n - k; i < n; ++i) y[p++] = i;
			REP(i, n) if (sa[i] >= k) y[p++] = sa[i] - k;
			REP(i, m) c[i] = 0;
			REP(i, n) c[x[y[i]]]++;
			REPP(i, 1, m - 1) c[i] += c[i - 1];
			for (int i = n - 1; i >= 0; --i) sa[--c[x[y[i]]]] = y[i];
			swap(x, y);
			p = 1; x[sa[0]] = 0;
			REPP(i, 1, n - 1) {
				x[sa[i]] = y[sa[i - 1]] == y[sa[i]] && y[sa[i - 1] + k] == y[sa[i] + k] ? p - 1 : p++;
			}
			if (p >= n) break;
			m = p;
		}
	}

	int r[N], hg[N]; //rank[], height[]
	
	//rank[i] 第i个后缀在后缀数组里面的排名，（反函数的关系）
	//height[i] sa[i]和sa[i-1]的最长公共前缀，hg[0] = 0, hg[1] = 0;

	void gethg(){
		REP(i, n) r[sa[i]] = i;
		int k = 0;
		REP(i, n) {
			if (k) k--;
			int j = sa[r[i] - 1];
			while (s[i + k] == s[j + k]) k++;
			hg[r[i]] = k;
		}
	}

	void output(){
		REP(i, n) cout << sa[i] << ' ';
		cout << endl;
		REP(i, n) cout << hg[i] << ' ';
		cout << endl;
	}
}SA;

char s[15][10005];
int mi[15], mx[15];
int mp[N];

bool check(int x) {
	int pos = 0;
	int tot = n;
	int &n = SA.n;
	int* sa = &SA.sa[0];
	int* hg = &SA.hg[0];

	while (pos < n) {
		while (pos < n && hg[pos] < x) pos++;
		int st = pos;
		if (st >= n) return 0;
		while (pos < n && hg[pos] >= x) pos++;
		int ed = pos - 1;
		REP(i, tot) mi[i] = INF, mx[i] = -1;
		REPP(i, st - 1, ed) {
			int x = mp[sa[i]];
			mi[x] = min(sa[i], mi[x]);
			mx[x] = max(sa[i], mx[x]);
		}
		int cnt = 0;
		REP(i, tot) if (mi[i] < INF && mx[i] >= 0 && mi[i] + x <= mx[i]) {
			cnt++;
		}
		if (cnt == tot) return 1;
	}
	return 0;
}

int main(){
	// freopen("cf.in", "r", stdin);
	//freopen("1.ans", "w", stdout);
	//ios :: sync_with_stdio(0);

	int t, x, y, z, ca = 1;
	
	RI(t);

	while (t--) {
		RI(n);
		int now = 0, pos = 0, tot = 0;
		REP(i, n) {
			RS(s[i]);
			int len = SL(s[i]);
			REP(j, len) {
				mp[pos] = now;
				SA.s[pos++] = s[i][j] - 'a' + 20;
			}
			mp[pos] = -1;
			SA.s[pos++] = now;
			now++;
			tot += len + 1;
		}

		SA.Init(tot);
		// REP(i, SA.n) cout << SA.s[i] << ' ';
		// cout << endl;

		int hi = tot, lo = 0;
		while (lo + 1 < hi) {
			int mid = hi + lo >> 1;
			if (check(mid)) lo = mid;
			else hi = mid;
		}
		printf("%d\n", lo);
	}


	return 0;
}
