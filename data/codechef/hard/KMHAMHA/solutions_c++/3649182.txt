#include <iostream>
#include <cstdlib>
#include <cstring>
#include <sstream>
#include <cassert>
#include <utility>
#include <string>
#include <bitset>
#include <vector>
#include <cstdio>
#include <stack>
#include <queue>
#include <list>
#include <set>
#include <map>
#include <algorithm>
#include <cmath>
#include <complex>
#include <memory.h>

using namespace std;

typedef long long        LL;
typedef pair<int, int>   pii;
typedef pair<int, pii>   piii;
typedef vector<int>      vi;
typedef vector<pii>      vii;

inline void inpint( int &n ) {
  n=0; register int ch = getchar_unlocked(); bool sign = 0;
  while(ch < 48 || ch > 57) { if(ch == '-') sign = 1; ch = getchar_unlocked(); }
  while(ch >= 48 && ch <= 57) { n = (n << 3) + (n << 1) + ch - 48, ch = getchar_unlocked(); }
  if(sign) n = -n;
}

const int BUF_SIZE = 65536;
char input[BUF_SIZE];

struct Scanner {
    char* curPos;

    Scanner() {
        fread(input, 1, sizeof(input), stdin);
        curPos = input;
    }

    void ensureCapacity() {
        int size = input + BUF_SIZE - curPos;
        if (size < 100) {
            memcpy(input, curPos, size);
            fread(input + size, 1, BUF_SIZE - size, stdin);
            curPos = input;
        }
    }

    int nextInt() {
        ensureCapacity();
        while (*curPos <= ' ')
            ++curPos;
        bool sign = false;
        if (*curPos == '-') {
            sign = true;
            ++curPos;
        }
        int res = 0;
        while (*curPos > ' ')
            res = res * 10 + (*(curPos++) & 15);
        return sign ? -res : res;
    }

    char nextChar() {
        ensureCapacity();
        while (*curPos <= ' ')
            ++curPos;
        return *(curPos++);
    }
    /*
    Scanner sc;
    int a = sc.nextInt();
    char b = sc.nextChar();
    */
};

inline double getDouble() {
    char ch; bool seen = false, sign = false, beforeDot = true;
    char values[10]; double result =0.; int beforeLength = 0; double multiplier;
    while((ch = getchar_unlocked()) != EOF){
        if(ch == '-') {
            sign = true;
            continue;
        }
        if(ch == ' ' || ch == '\n'){
            if(seen) break;
            continue;
        }
        if(ch == '.'){
            beforeDot = false;
            multiplier = 1.;
            while(beforeLength){
                result += (double)(values[--beforeLength] - '0') * multiplier;
                multiplier *= 10.;
            }
            multiplier = 10.;
        }
        else{
            if(!beforeDot){
                result += double(ch - '0') / multiplier;
                multiplier *= 10.;
            } 
            else{
                values[beforeLength++] = ch;
            }
            seen = true;
        }
    }
    if(beforeDot){
        multiplier = 1;
        while(beforeLength){
            result += (double)(values[--beforeLength] - '0') * multiplier;
            multiplier *= 10.;
        }
    }
    if(sign) result = -result;
    return result;
}


inline int sqr(int x){return x * x;}
inline int cube(int x){return x * x * x;}
inline LL sqrLL(LL x){return x * x;}
inline LL cubeLL(LL x){return x * x * x;}

const LL LLINF      = 9223372036854775807LL;
const LL LLINF17    = 100000000000000000LL;
const int INF       = 2147483647;
const int INF9      = 1000000000;
const int MOD       = 1000000007;
const double eps    = 1e-7;
const double PI     = acos(-1.0);

#define FORIT(a,b)   for (__typeof((b).begin()) (a)=(b).begin(); (a)!=(b).end(); (a)++)
#define FOR(a,b,c)   for (int (a)=(b); (a)<(c); (a)++)
#define FORN(a,b,c)  for (int (a)=(b); (a)<=(c); (a)++)
#define FORD(a,b,c)  for (int (a)=(b); (a)>=(c); (a)--)
#define REP(i,n)     FOR(i,0,n)
#define REPN(i,n)    FORN(i,1,n)
#define REPD(i,n)    FORD(i,n,1)

#define RESET(a,b)   memset(a,b,sizeof(a)) 
#define SYNC         ios_base::sync_with_stdio(0);
#define SIZE(a)      (int)(a.size())
#define MIN(a,b)     (a) = min((a),(b))
#define MAX(a,b)     (a) = max((a),(b))
#define ALL(a)       a.begin(),a.end()
#define RALL(a)      a.rbegin(),a.rend()
#define SIZE(a)      (int)(a.size())
#define LEN(a)       (int)(a.length())

#define fi           first
#define se           second
#define pb           push_back
#define mp           make_pair

int dr[] = {1,0,-1,0,-1,1,1,-1};
int dc[] = {0,-1,0,1,1,1,-1,-1};
int t, n; vi coordx, coordy; pii arr[1005];
map<int, int> lolx, loly; int it1 = 0, it2 = 0;
vi adj[1005]; int match[1005]; bool flag[1005];

bool dfs(int node){
	for(int i = 0; i < SIZE(adj[node]); i++){
		int next = adj[node][i];
		if(flag[next]) continue;
		flag[next] = 1;

		if(match[next] == -1 || dfs(match[next])){
			match[next] = node;
			return 1;
		}
	}
	return 0;
}

int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		lolx.clear(); loly.clear();
		coordx.clear(); coordy.clear();
		for(int i = 1; i <= n; i++){
			scanf("%d %d",&arr[i].fi,&arr[i].se);
			coordx.pb(arr[i].fi); coordy.pb(arr[i].se);
		}
		sort(ALL(coordx)); sort(ALL(coordy));
		it1 = it2 = 0;
		for(int i = 0; i < n; i++){
			if(!lolx[coordx[i]]){
				lolx[coordx[i]] = it1++;
			}
			if(!loly[coordy[i]]){
				loly[coordy[i]] = it2++;
			}
		}

		int ans = 0;
		for(int i = 0; i < 1005; i++) adj[i].clear();
		for(int i = 1; i <= n; i++){
			arr[i].fi = lolx[arr[i].fi];
			arr[i].se = loly[arr[i].se];
			adj[arr[i].fi].pb(arr[i].se);
		}

		memset(match,-1,sizeof(match));
		for(int i = 0; i < it1; i++){
			memset(flag,0,sizeof(flag));
			ans += dfs(i);
		}
		printf("%d\n",ans);
	}

	return 0;
}