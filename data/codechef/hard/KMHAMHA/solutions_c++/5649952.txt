//Maximum bipartite Matching
//Ref. @honeyslawyer
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<map>
#include<queue>
#include<utility>
#include<cstring>
#include<cmath>
#define LL long long int
#define mod 1000000007
#define vi vector<int>
#define vvi vector < vi >
#define pii pair<int,int>
#define all(c) c.begin(),c.end()
#define sf(n) scanf("%d",&n);
#define mem(a,val) memset(a,val,sizeof(a))
#define pb push_back
#define f first
#define s second
using namespace std;
map<int,vi>mymap;
map<int,int>match;
map<int,bool>vis;
bool mbp(int src)
{	int i;
	for(i=0;i<mymap[src].size();i++)
	{	if(!vis[mymap[src][i]])
		{	vis[mymap[src][i]]=true;
			if(match[mymap[src][i]]<0||mbp(match[mymap[src][i]]))
			{	match[mymap[src][i]]=src;
				return true;
			}
		}
	}
	return false;
}
int main()
{	int t,i,j,n,x,y,ans;
	sf(t);
	while(t--)
	{	sf(n);
		mymap.clear();
		vis.clear();
		match.clear();
		for(i=0;i<n;i++)
		{	sf(x);sf(y);
			mymap[x].pb(y);
			vis[y]=false;
			match[y]=-1;
		}
		ans=0;
		map< int,vi >::iterator itr;
		for(itr=mymap.begin();itr!=mymap.end();itr++)
		{	map<int,bool>::iterator itr1;
			for(itr1=vis.begin();itr1!=vis.end();itr1++)
				(itr1->second)=false;
			if(mbp(itr->first))
				ans++;		
		}	
		cout<<ans<<endl;	
	}
	return 0;
}
