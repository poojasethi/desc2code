#include <iostream>
#include <vector>
#include <cstring>
#include <queue>
#include <map>
using namespace std;
#define MAX 100001
///maxx is max number of nodes
#define NIL 0
#define INF (1<<28)
#define pb push_back
vector< int > G[MAX];
int n, m, match[MAX], dist[MAX];
// n: number of nodes on left side, nodes are numbered 1 to n
// m: number of nodes on right side, nodes are numbered n+1 to n+m
// G = NIL[0] âˆª G1[G[1---n]] âˆª G2[G[n+1---n+m]]
int len_=0;
bool bfs()
{
        int i, u, v, len;
        //cout<<len_++<<endl;
        queue< int > Q;
        for(i=1; i<=n; i++) {
                if(match[i]==NIL) {	///if the A's node is still unmatched->check for the viable flow
                        dist[i] = 0;
                        Q.push(i);
                } else dist[i] = INF;	//otherwise make it non avaiable
        }
        dist[NIL] = INF;
        while(!Q.empty()) {
                u = Q.front();
                Q.pop();
                if(dist[u]<dist[NIL]) {
                        len = G[u].size();
                        for(i=0; i<len; i++) {
                                v = G[u][i];
                                if(dist[match[v]]==INF) {	//if any unmatched on the B's node
                                        dist[match[v]] = dist[u] + 1;
                                        Q.push(match[v]);
                                }
                        }
                }
        }
        return (dist[NIL]!=INF);
}

bool dfs(int u)
{
        int i, v, len;
        if(u!=NIL) {
                len = G[u].size();
                for(i=0; i<len; i++) {
                        v = G[u][i];
                        if(dist[match[v]]==dist[u]+1) {
                                if(dfs(match[v])) {
                                        match[v] = u;
                                        match[u] = v;
                                        return true;
                                }
                        }
                }
                dist[u] = INF;
                return false;
        }
        return true;
}

int hopcroft_karp()
{
        int matching = 0, i;
        // match[] is assumed NIL for all vertex in G
        while(bfs())
                for(i=1; i<=n; i++)
                        if(match[i]==NIL && dfs(i))
                                matching++;
        return matching;
}
#define pii pair<int,int>
#define pb push_back
#define mp make_pair
int main()
{
        //int N,M,P;
        int tst;
        cin>>tst;
        while(tst--) {
                memset(match,0,sizeof(match));
                memset(dist,0,sizeof(dist));
                for(int i=0; i<MAX; i++)G[i].clear();
                int p,row=0,col=0,maxi=0;
                cin>>p;
                vector<pii >vecc;
                map<int,int>X,Y;
                for(int i=0; i<p; i++) {
                        int a,b;
                        cin>>a>>b;
                        if(X.find(a)==X.end())X[a]=++row;
                        if(Y.find(b)==Y.end())Y[b]=++col;
                        vecc.pb(mp(X[a],Y[b]));
                        maxi=max(maxi,X[a]);
                }
                n=row;
                for(int i=0; i<p; i++) {
                        pii A=vecc[i];
                        G[A.first].pb(A.second+maxi);
                }
                cout<<hopcroft_karp()<<endl;
        }
        return 0;
}
