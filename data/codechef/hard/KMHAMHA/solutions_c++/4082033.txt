#include <cstdio>
#include <algorithm>
#include <vector>
#include <list>

using namespace std;

#define all(a) (a).begin(),(a).end()
#define pb push_back
#define sz(a) ((int)(a).size())
#define mp make_pair
#define fi first
#define se second

typedef pair<int,int> pint;
typedef long long ll;
typedef unsigned long long ull;
typedef vector<int> vi;

#define MAX_N 1005

int n,a,b,match[2*MAX_N];
pint p[MAX_N];
list<int> adjl[2*MAX_N];
bool vis[2*MAX_N];

bool cmp1(const pint &a, const pint &b)
{
	return a.fi<b.fi;
}

bool cmp2(const pint &a, const pint &b)
{
	return a.se<b.se;
}

int f(int i)
{
	if (vis[i])
		return 0;
	vis[i]=true;
	for (list<int>::iterator it=adjl[i].begin(); it!=adjl[i].end(); it++)
		if (match[*it]==-1||f(match[*it]))
		{
			match[*it]=i;
			return 1;
		}
	return 0;
}

int kuhn()
{
	for (int i=0; i<a; i++)
		match[i]=-1;
	for (int i=0; i<b; i++)
		match[MAX_N+i]=-1;
	int ans=0;
	for (int i=0; i<a; i++)
	{
		if (match[i]!=-1)
			continue;
		for (int j=0; j<a; j++)
			vis[j]=false;
		for (int j=0; j<b; j++)
			vis[MAX_N+j]=false;
		ans+=f(i);
	}
	return ans;
}

int main()
{
	int tc;
	scanf("%d",&tc);
	while (tc--)
	{
		scanf("%d",&n);
		for (int i=0; i<n; i++)
			scanf("%d %d",&p[i].fi,&p[i].se);
		sort(p,p+n,cmp1);
		int x=-1,pv=-1;
		for (int i=0; i<n; i++)
		{
			if (p[i].fi!=pv)
			{
				x++;
				pv=p[i].fi;
			}
			p[i].fi=x;
		}
		a=x+1;
		sort(p,p+n,cmp2);
		x=pv=-1;
		for (int i=0; i<n; i++)
		{
			if (p[i].se!=pv)
			{
				x++;
				pv=p[i].se;
			}
			p[i].se=x;
		}
		b=x+1;
		for (int i=0; i<n; i++)
		{
			adjl[i].clear();
			adjl[i+MAX_N].clear();
		}
		for (int i=0; i<n; i++)
		{
			adjl[p[i].fi].pb(MAX_N+p[i].se);
			adjl[MAX_N+p[i].se].pb(p[i].fi);
		}
		//answer = minimum vertex cover
		//e.g. the minimum number of vertices to 'destroy' all edges
		//in bipartite graphs this is equal to the maximum matching (koenigs theorem)
		//due low constraints we do not need to use hopcroft karp - kuhn's algorithm should be fine too
		printf("%d\n",kuhn());
	}
	return 0;
}
