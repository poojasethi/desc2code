#include<map>
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;

int n1;
int n2;
vector<int> m1,m2;
vector<bool> seen;
vector< vector<int> > graph;
vector<int> lev;

bool bfs()
{
	queue<int> myq;
	for(int i=0;i<n1;++i)
	{	
		if(m1[i]==-1)
		{
			myq.push(i);
			lev[i]=0;
		}
		else
		{
			lev[i]=-1;
		}
	}
	int found=1e9;
	while(!myq.empty())
	{
		int now=myq.front();
		myq.pop();
		if(lev[now] < found)
		{
			for(int i=0;i<(int)graph[now].size();++i)
			{
				int next=graph[now][i];
				if(m2[next]==-1)
				{
					found=lev[now]+1;
				}
				else
				{
					if(lev[m2[next]]==-1)
					{
						myq.push(m2[next]);
						lev[m2[next]]=lev[now]+1;
					}
				}
			}
		}
	}
	return found<1e9;
}

bool dfs(int x)
{
	for(int i=0;i<(int)graph[x].size();++i)
	{
		int next=graph[x][i];
		if( m2[next] == -1)
		{
			m1[x]=next;
			m2[next]=x;
			return 1;
		}
		else
		{
			if(lev[m2[next]]==lev[x]+1 && dfs(m2[next]))
			{
				m1[x]=next;
				m2[next]=x;
				return 1;
			}
		}
	}
	lev[x]=-1;
	return 0;

}

/* Hopcroft Karp algorithm for bipartite matching
 * O(root (v) * E) in practice fast.
 * graph is the adjlist rep
 * n1, n2 is the bipartite partition
 * vertices are 0 to n1, 0 to n2
 * m1 is the matched vertex from n1 to n2
 */

int match()
{
	m2.resize(n2);
	m1.resize(n1);
	for(int i=0;i<n1;++i)
		m1[i]=-1;
	for(int j=0;j<n2;++j)
		m2[j]=-1;
	lev.resize(n1);
	int ans=0;
	while(bfs())
	{
		for(int i=0;i<n1;++i)
			if(m1[i]==-1 && dfs(i))
				ans++;
	}
	return ans;
}

void doit()
{
	int n;
	map<int,int> x,y;
	int r=0,c=0;
	scanf("%d",&n);
	vector<vector<int> > arr(n,vector<int> (2,0));
	for(int i=0;i<n;++i)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		arr[i][0]=a;
		arr[i][1]=b;

		if(x.find(a)==x.end())
		{
			x[a]=r++;
		}
		if(y.find(b)==y.end())
		{
			y[b]=c++;
		}
	}
	n1=r;
	n2=c;
	graph.clear();
	graph.resize(n1);
	for(int i=0;i<n;++i)
	{
		graph[x[arr[i][0]]].push_back(y[arr[i][1]]);
	}
	printf("%d\n",match());
}

int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		doit();
	}
	return 0;
}
