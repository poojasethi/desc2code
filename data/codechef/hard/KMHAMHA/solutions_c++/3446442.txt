#include <algorithm>
#include <map>
#include <cstring>
#include <vector>
#include <queue>
#include <cstdio>
#include <iostream>
using namespace std;
#define MAXN 100000
#define INF (1<<28)

vector <int> adj[MAXN + 1]; // (u, v) <=> (v, u)
int n, m, NIL, match[MAXN + 1], dist[MAXN + 1];
// Izquierda; nodos del 0 al n-1
// Derecha: Nodos del n al n+m-1
// NIL: Nodo n+m

bool bfs(){
    queue <int> Q;
    for(int i=0; i<n; i++) {
        if(match[i] == NIL) {
            dist[i] = 0;
            Q.push(i);
        }
        else dist[i] = INF;
    }
    dist[NIL] = INF;
    
    while(!Q.empty()) {
        int u = Q.front(); Q.pop();
        for(int i=0; i<adj[u].size(); i++){
            int v = adj[u][i];
            if(dist[match[v]] == INF) {
                dist[match[v]] = dist[u] + 1;
                Q.push(match[v]);
            }
        }
    }
    return dist[NIL] != INF;
}

bool dfs(int u) {
	if(u != NIL) {
		for(int i=0; i<adj[u].size(); i++) {
			int v = adj[u][i];
			if(dist[match[v]] == dist[u] + 1) {
				if(dfs(match[v])) {
					match[v] = u;
					match[u] = v;
					return true;
				}
			}
		}
		dist[u] = INF;
		return false;
	}
	return true;
}

int hopcroft_karp()
{
    NIL = n + m;
    for(int i=0; i<n+m; i++)
    	match[i] = NIL;
    
    int matching = 0;
    
    //Greedy Step
    for(int u=0; u<n; u++)
    {
    	for(int i=0; i<adj[u].size(); i++)
    	{
    		int v = adj[u][i];
    		if(match[v] == NIL)
    		{
    			matching++;
    			match[u] = v;
    			match[v] = u;
    			break;
    		}
    	}
    }
    
    while(bfs())
        for(int u=0; u<n; u++)
            if(match[u] == NIL && dfs(u))
                matching++;
    
    return matching;
}
pair<int, int> v[1010];
int main() {
    int T, points, cnt;
    scanf("%d", &T);
    while( T-- ) {
        scanf("%d", &points);
        for(int i=0 ; i<points ; i++)
            scanf("%d %d", &v[i].first, &v[i].second);
        sort(v, v+points);
        map<int,int> hash;
        cnt = 0;
        for(int i=0 ; i<points ; i++)
            if( hash.find(v[i].first) == hash.end() ) {
                hash[v[i].first] = cnt;
                v[i].first = cnt;
                cnt++;
            } else v[i].first = hash[v[i].first];
        n = cnt;
        hash = map<int,int>();
        for(int i=0 ; i<points ; i++)
            if( hash.find(v[i].second) == hash.end() ) {
                hash[v[i].second] = cnt;
                v[i].second = cnt;
                cnt++;
            } else v[i].second = hash[v[i].second];
        m = cnt - n;
        //for(int i=0 ; i<points ; i++) cout<<v[i].first<<" "<<v[i].second<<endl;
        //cout<<n<<" "<<m<<endl;
        for(int i=0 ; i<points ; i++) {
            adj[v[i].first].push_back(v[i].second);
            adj[v[i].second].push_back(v[i].first);
        }
        printf("%d\n", hopcroft_karp());
        for(int i=0 ; i<=n+m ; i++) adj[i].clear();
    }
    return 0;
}