//------- By Swapnil Saxena aka dragonslayerx-----
#include <iostream>
#include <cstdio>
#include <vector>
#include <set>
#include <map>
#include <list>
#include <cstring>
#include <cstdlib>
#include <climits>
#include <queue>
#include <algorithm>

using namespace std;

//#define DEBUG


class Max_Bipartite_Match {
	#define MAX 101
	vector<vector<int> > G; 
	public:
	vector<int> match, mark;
	int max_match, stamp;
	Max_Bipartite_Match(vector<vector<int> > &bipartite_graph, int v)
	{
		G = bipartite_graph;
		match.resize(v);
		mark.resize(v);
		for (int i = 0; i < v; i++) {
			match[i] = -1;
			mark[i] = -1;
		}
		stamp = 0;
		max_match = 0;
	}

	bool augment_path(int vertex)
	{
		for (int i = 0; i < G[vertex].size(); i++) {
			int v = G[vertex][i];
			if (mark[v] == stamp)
				continue;
			mark[v] = stamp;
			if (match[v] == -1 || augment_path(match[v])) {
				match[v] = vertex;
				return true;
			}
		}
		return false;
	}
	void max_matching()
	{
		for (int i = 0; i < G.size(); i++) {
			stamp++;
			if (augment_path(i))
				max_match++;
		}
	}
	
};
int main()
{
	int t;
	scanf("%d", &t);
	while (t--) {
		int n;
		scanf("%d", &n);
		vector<int> r, c;
		vector<vector<int> > G;
		vector<pair<int,int> > monster;
		for (int i = 0; i < n; i++) {
			int u, v;
			scanf("%d%d", &u, &v);
			r.push_back(u);
			c.push_back(v);
			monster.push_back(make_pair(u, v));
		}
		sort(r.begin(), r.end());
		sort(c.begin(), c.end());
		map<int, int> row_id, col_id;
		int id = 0;
		for (int i = 0; i < r.size(); i++) {
			if (i > 0 && r[i] == r[i - 1])
				continue;
			else {
				row_id[r[i]] = id;
				id++;
			}
		}
		G.resize(id);
		id = 0;		
		for (int i = 0; i < c.size(); i++) {
			if (i > 0 && c[i] == c[i - 1])
				continue;
			else {
				col_id[c[i]] = id;
				id++;
			}
		}
		for (int i = 0;  i < monster.size(); i++) {
				int u = row_id[monster[i].first];
				int v = col_id[monster[i].second];
				G[u].push_back(v);
		}
		Max_Bipartite_Match M(G, id);
		M.max_matching();
		cout << M.max_match << endl;
	}
}
