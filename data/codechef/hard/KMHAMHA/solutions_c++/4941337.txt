#include <bits/stdc++.h>
using namespace std;
#define N 200000
struct nod
{
    int x,y;
}nods[1000+10];
int x[1000 + 10],y[1000 + 10];

int src,dest,nodes;
struct edge
{
    int v,rev;
    int cap,flow;
};
vector <edge> adj[N + 10];
int dst[N + 10],save[N + 10];

void init(int s,int d,int n)
{
    src = s;
    dest = d;
    nodes = n;
    for(int i = 0 ; i<n ; i++)
    adj[i].clear();
}
void AddEdge(int u,int v,int cap,int revcap)
{
    edge a = {v,adj[v].size(),cap,0};
    edge b = {u,adj[u].size(),revcap,0};
    adj[u].push_back(a);
    adj[v].push_back(b);
}
bool bfs()
{
    int i;
    for(i = 0 ; i<nodes ; i++)
    {
        dst[i] = -1;
        save[i] = 0;
    }
    dst[src] = 0;
    queue <int> q;
    q.push(src);
    while(!q.empty())
    {
        int u = q.front();
        q.pop();
        int sz = adj[u].size();
        for(int j =0 ; j<sz ; j++)
        {
            int v = adj[u][j].v;
            if(dst[v] < 0 && adj[u][j].cap > adj[u][j].flow)
            {
                dst[v] = dst[u] + 1;
                q.push(v);
            }
        }
    }
    return (dst[dest] == -1)? false : true;
}
int dfs(int u,int mn)
{
    if(u == dest) return mn;
    int sz = adj[u].size();
    for(int j = save[u] ; j<sz ; j++)
    {
        save[u] = j;
        int v = adj[u][j].v;
        if(dst[v] - dst[u] == 1 && adj[u][j].cap > adj[u][j].flow)
        {
            int f = dfs(v,min(mn,adj[u][j].cap - adj[u][j].flow));
            if(f > 0)
            {
                int rev = adj[u][j].rev;
                adj[u][j].flow = adj[u][j].flow + f;
                adj[v][rev].flow = adj[v][rev].flow - f;
                return f;
            }
        }
    }
    return 0;
}
int MaxFlow()
{
    int INF = pow(10,9) + 10;
    int flow = 0;
    while(bfs())
    {
        int d;
        while((d = dfs(src,INF)) > 0)
        flow = flow + d;
    }
    return flow;
}
int b_search(int [],int,int,int);
int match(int,int);
int matching(int,int);

int main()
{
    int u,v,k,t,i,j,n,r,c;

    scanf("%d",&t);
    for(k = 1 ; k <= t ; k++)
    {
        scanf("%d",&n);

        for(i = 1 ; i <= n ; i++)
        {
            scanf("%d %d",&nods[i].x,&nods[i].y);
            x[i-1] = nods[i].x;
            y[i-1] = nods[i].y;
        }

        sort(x,x+n);
        sort(y,y+n);

        j = 0;
        for(i = 1 ; i<n ; i++)
        {
            if(x[i] != x[j])
            {
                j++;
                x[j] = x[i];
            }
        }
        r = j;
        j = 0;
        for(i = 1 ; i<n ; i++)
        {
            if(y[i] != y[j])
            {
                j++;
                y[j] = y[i];
            }
        }
        c = j;
        r++;c++;
        init(0,r+c+1,r+c+2);
        for(i = 1 ; i<=r ; i++) AddEdge(0,i,1,0);

        for(i = 1 ; i<=c ; i++) AddEdge(r + i,r + c + 1,1,0);

        for(i = 1 ; i<= n ; i++)
        {
            u = b_search(x , 0 , r-1, nods[i].x);u++;
            v = b_search(y , 0 , c-1 , nods[i].y);v++;
            AddEdge(u,r+v,1,0);
        }
        printf("%d\n",MaxFlow());

    }
    return 0;
}
int b_search(int pos[],int l,int h,int tar)
{
    int m ;
    while(l <= h)
    {
        m = ( l + h )/2;
        if(pos[m] == tar)
        {
            return m;
        }
        if(pos[m] > tar)
        {
            h = m - 1;
        }
        else
        {
            l = m + 1;
        }
    }
    return -1;
}
