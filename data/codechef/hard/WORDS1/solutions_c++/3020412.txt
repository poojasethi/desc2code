//Euler Problem
#include <cstdio>
#include <cstring>
#include <map>
#include <set>
#include <queue>

using namespace std;

typedef map<char, set<char> > graph;
typedef set<char> vertices;
typedef char vertex;
typedef set<char> vertices;

int isconnected(graph &G, vertices &V, vertex tmp) 
{
		set<char> isvisited;
		queue<char> Q;
		Q.push(tmp);
		while (Q.size()) {
			char tmp = Q.front();
			Q.pop();
			for (vertices::iterator V = G[tmp].begin(); V != G[tmp].end(); V++) {
				if (!(isvisited.count(*V))) {
					Q.push(*V);
				}
			}
			isvisited.insert(tmp);
		}
		for (vertices::iterator Vi = V.begin(); Vi!= V.end(); Vi++) {
			if (!isvisited.count(*Vi)) {
				return 0;
			}
		}
		return 1;
}

int main()
{
	int tc;
	scanf("%d", &tc);
	while (tc--) {
		int n;
		graph G;
		vertices V;
		map <char, int> indeg, outdeg;
		scanf("%d", &n);
		while (n--) {
			char tmp[1001];
			int length = scanf("%s", tmp);
			
			char fc = tmp[0];
			char lc = tmp[strlen(tmp) - 1];
			
			G[fc].insert(lc);
			V.insert(fc);
			V.insert(lc);
			
			outdeg[fc]++;
			indeg[lc]++;
		}
		
		int flag = 1;
		int flag1 = 0;
		int flag2 = 0;
		char t = (*(V.begin()));
		
		for (vertices::iterator Vi = V.begin(); Vi != V.end(); Vi++) {
			char tmp = *Vi;
			if(indeg[tmp] != outdeg[tmp]){
				if (indeg[tmp] == outdeg[tmp] + 1) {
					flag1++;
				} else if (indeg[tmp] + 1 == outdeg[tmp]){
					flag2++;
					t = tmp;
				} else {
					flag = 0;
					break;
				}
			}
		}
		if (!((flag1 == 0 && flag2 == 0) || (flag1 == 1 && flag2 == 1))){
			flag = 0;
		}
		
		if (!isconnected(G, V, t)) {
			flag = 0;
		}
		
		if (flag) {
				printf("Ordering is possible.\n");
		} else {
				printf("The door cannot be opened.\n");
		}
		
		indeg.clear();
		outdeg.clear();
		G.clear();
	}
	return 0;
}