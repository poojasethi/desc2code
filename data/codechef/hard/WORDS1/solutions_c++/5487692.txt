#include <cstdio>
#include <vector>
#include <stack>
#include <cstring>
#include <assert.h>
using namespace std;
void dfs(vector< vector <int> > *v,int node, int *visited)
{
    if(!visited[node])
    {
	visited[node]=1;
	for(int i=0;i<(*v)[node].size();i++)
	{
	    dfs(v,(*v)[node][i],visited);
	}
    }
}
main()
{
    int t,n;
    scanf("%d",&t);
    while(t--)
    {
	scanf("%d",&n);
	vector< vector<int> >und;
	for(int i=0;i<26;i++)
	{
	    //stack <int> ss
	    und.push_back( vector<int>());
	}
	int indeg[26]={0},outdeg[26]={0},visited[26]={0};

	int cnt=0,flag=1;

	    
	for(int i=1;i<=n;i++)
	{
	    char s[1001];
	    scanf("%s",s);
	    char a=s[0];
	    char b=s[strlen(s)-1];
	    und[a-'a'].push_back(b-'a');
	    und[b-'a'].push_back(a-'a');
	    indeg[b-'a']++;
	    outdeg[a-'a']++;

	}


	for(int i=0;i<26;i++)
	{
	    if(und[i].size()==0)
		visited[i]=1;

	    
	    if(!visited[i])
	    {
		dfs(&und,i,visited);
		cnt++;
		//printf("%d %d %d\n",p,n,gz);
		if(cnt>1)
		break;
	    }
	}

	//to check if eulerian path exists.
	int p=0,n=0,gz=0;
	for(int i=0;i<26;i++)
	{
	    if(indeg[i]!=outdeg[i])
		gz++;
	    if(indeg[i]-outdeg[i]==1)
		p++;
	    if(outdeg[i]-indeg[i]==1)
		n++;
	}
		
	if( !((p==1 && n==1 && gz==2)|| (p==0 && n==0 && gz==0)) )
	{
	    flag=0;   
	}

	if(flag && cnt==1)
	    printf("Ordering is possible.\n");
	else
	    printf("The door cannot be opened.\n");
    }
    return 0;
}