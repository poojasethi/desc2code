/*Play on Words*/

#include<cstdio>
#include<cstring>
#include<queue>

using namespace std;

bool adj[26][26];
bool found[26];
char word[1024];
int color[26], indegree[26], outdegree[26];

bool has_euler_path(void);
bool is_connected(void);

int main()
{
	int end, length, N, start, T;
	scanf("%d", &T);
	while (T--)
	{
		memset(adj, false, sizeof(adj));
		memset(found, false, sizeof(found));
		memset(indegree, 0, sizeof(indegree));
		memset(outdegree, 0, sizeof(outdegree));
		scanf("%d", &N);
		while (N--)
		{
			scanf("%s", word);
			length = strlen(word);
			start = word[0] - 'a';
			end = word[length - 1] - 'a';
			indegree[end]++;
			outdegree[start]++;
			adj[start][end] = found[start] = found[end] = true;
		}
		if (has_euler_path())
			puts("Ordering is possible.");
		else
			puts("The door cannot be opened.");
	}
	return 0;
}

bool has_euler_path(void)
{
	int count1, count2, i;
	if (!is_connected())
		return false;
	count1 = count2 = 0;
	for (i = 0; i < 26; i++)
	{
		if (outdegree[i] - indegree[i] == 1)
			count1++;
		else if (indegree[i] - outdegree[i] == 1)
			count2++;
		else if (indegree[i] != outdegree[i])
			return false;
	}
	if (((count1 == 0) && (count2 == 0)) || ((count1 == 1) && (count2 == 1)))
		return true;
	return false;
}

bool is_connected(void)
{
	int i, j;
	queue<int> q;
	for (i = 0; i < 26; i++)
		color[i] = (found[i] ? 0 : 2);
	i = 0;
	while (color[i])
		i++;
	color[i] = 1;
	q.push(i);
	while (!q.empty())
	{
		i = q.front();
		q.pop();
		for (j = 0; j < 26; j++)
		{
			if ((adj[i][j] || adj[j][i]) && (!color[j]))
			{
				q.push(j);
				color[j] = 1;
			}
		}
		color[i] = 2;
	}
	for (i = 0; i < 26; i++)
		if (color[i] != 2)
			return false;
	return true;
}