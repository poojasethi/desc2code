#include <iostream>
#include <algorithm>
#include <vector>
#include <stdio.h>
#include <string>
#include <queue>

using namespace std;

void play_on_words()
{
    int i,j,k,t;
    int T,n,a,b,flag;
    int graph[26][26];
    int degrees[26][2];
    vector<int> visited;
    string str;

    cin >> T;
    for(k = 0; k < T; ++k)
    {
        vector<int> nodes;
        visited.assign(26, 0);

        cin >> n;
        for(i = 0; i < 26; ++i)
        {
            for(j = 0; j < 26; ++j)
                graph[i][j] = 0;
            degrees[i][0] = 0;
            degrees[i][1] = 0;
            visited[i] = 0;
        }
        for(i = 0; i < n; ++i)
        {
            cin >> str;
            a = str[0]-'a';
            b = str[str.length()-1]-'a';
            degrees[a][0] += 1;
            degrees[b][1] += 1;
            graph[a][b] += 1;
            if(visited[a] == 0)
            {
                visited[a] = 1;
                nodes.push_back(a);
            }
            if(visited[b] == 0)
            {
                visited[b] = 1;
                nodes.push_back(b);
            }
        }
        for(i = j = t = flag = 0; i < 26; ++i)
        {
            a = degrees[i][0] - degrees[i][1];
            if(a > 0)
            {
                if(a == 1)
                    j += 1;
                else
                {
                    flag  = 1;
                    break;
                }
            }
            if(a < 0)
            {
                if(a == -1)
                    t += 1;
                else
                {
                    flag = 1;
                    break;
                }
            }
        }
        if(flag == 1 || !(j == t && t <= 1))
        {
            cout << "The door cannot be opened." << endl;
            continue;
        }

        queue<int> Q;
        for(i = 0; i < 26; ++i)
        {
            for(j = 0; j < 26; ++j)
            {
                t = max(graph[i][j], graph[j][i]);
                graph[i][j] = t;
                graph[j][i] = t;
            }
        }
        visited.assign(26, 0);
        Q.push(nodes[0]);
        visited[nodes[0]] = 1;
        for(t = 0; !Q.empty();)
        {
            i = Q.front();
            Q.pop();
            t += 1;
            for(j = 0; j < 26; ++j)
            {
                if(graph[i][j] > 0 && visited[j] == 0)
                {
                    Q.push(j);
                    visited[j] = 1;
                }
            }
        }
        if(t == nodes.size())
            cout << "Ordering is possible." << endl;
        else
            cout << "The door cannot be opened." << endl;
    }
}

int main()
{
    play_on_words();
    return 0;
}
