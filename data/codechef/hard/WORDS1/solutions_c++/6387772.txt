#include <bits/stdc++.h>
using namespace std;
int letters[26];//+1 on incident -1 on leaving 
int visited[26];//initially all to 0 then when visited to 2
int graph[26][26];//stores all the edges
int isfound[26];
bool isconnected(){//is the undirected graph connected 
	//***NEED NOT SEE CONNECTED FOR DIRECTED graph a-->b-->c is a valid key
	for(int i=0;i<26;i++)visited[i]=(isfound[i]? 0:2);
	queue<int>Q;
	
	for(int i=0;i<26;i++){
		if(isfound[i]){
			Q.push(i);
			break;
		}
	}
	// cout<<"came here con1"<<endl;

	while(!Q.empty()){
		// cout<<"came in the loop"<<endl;
		int i=Q.front();Q.pop();
		// cout<<i<<endl;
		for(int j=0;j<26;j++){
			if((graph[i][j] || graph[j][i]) && visited[j]==0){
				Q.push(j);
				visited[j]=1;
			}
		}
		visited[i]=2;
	}
	for(int i=0;i<26;i++){
		if(visited[i]!=2)
			return false;
	}
	return true;
}
bool iseulerian(){//checks for eulerian condition
	if(!isconnected()){
		// cout<<"it is not connected"<<endl;
		return false;
	}
	// cout<<"eulerian"<<endl;
	int count1=0,count2=0;
	for(int i=0;i<26;i++){
		if(letters[i]==1)count1++;
		else if(letters[i]==-1)count2++;
		else if (letters[i]!=0)return false;
	}
	if(count1+count2==0 || (count1==1 && count2==1))return true;
}
int main(){
	// cout<<"came here";
	int t,n,first=0,last=0,len;
	char word[1001];
	scanf("%d",&t);
	while(t--){
		// cout<<"came here";
		
		memset(letters, 0, sizeof letters );
		memset(visited, 0, sizeof visited );
		memset(graph, 0, sizeof graph );
		memset(isfound,0,sizeof isfound);
		scanf("%d", &n);
		while(n--){
			scanf("%s",word);
			len=strlen(word);
			letters[first=word[0]-'a']++;
			letters[last=word[len-1]-'a']--;
			// cout<<first<<"******"<<last<<endl;
			graph[first][last]=isfound[first]=isfound[last]=1;
		}
		// cout<<"came"<<endl;
		if(iseulerian()) printf("Ordering is possible.\n");
		else printf("The door cannot be opened.\n");
	}

}