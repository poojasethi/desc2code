#include <vector>
#include <string>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <ctype.h>
#include <bitset>

using namespace std;

#define REP(i, n) for(int i=0; i<(n); i++)
#define FOR(i, a, b) for(int i=(a); i<(b); i++)
#define IFOR(i, a, b) for(int i=(a); i>=(b); i--)
#define FORD(i, a, b, c) for(int i=(a); i<(b); i+=(c))

#define MAX(a, b) ((a)>(b)?(a):(b))
#define MIN(a, b) ((a)<(b)?(a):(b))
#define SI(x) ((int)x.size())
#define PB(x) push_back(x)
#define MP(a,b) make_pair(a, b)
#define SORT(a) sort(a.begin(),a.end())
#define ITER(it,a) for(typeof(a.begin()) it=a.begin();it!=a.end();it++)
#define ALL(a) a.begin(),a.end()
#define INF 1000000000
#define V vector
#define S string
#define FST first
#define SEC second
typedef V<int> VI;
typedef V<S> VS;
typedef long long LL;
typedef pair<int, int> PII;
char inp[10000000];
char *ptr;
bool pres[26];
bool vis[26];
int arr[26][26];
inline int dfs(int k){
	vis[k]=true;
	int ans=1;
	REP(i, 26){
		if( (arr[k][i] || arr[i][k] ) && !vis[i]) ans+=dfs(i);
	}
	return ans;
}
char s[1005];

inline int SCAN_INT(void) {
    while(!(*ptr >='0' && *ptr<='9')) ptr++;
    int ret=0;
    while(1) {
        char c=*ptr++;
        if (c<=32) return ret;
        ret=(ret<<1)+(ret<<3)+c-'0';
    }
}
inline int SCAN_STR(){
	while(!isalpha(*ptr)) ptr++;
	int i=0;
	while(isalpha(*ptr)) s[i++]=*ptr++;
	s[i]=0;
	return i;
}
int in[26],out[26];
main()
{
	///freopen("input.txt","r", stdin);
	fread(inp, sizeof(char), 10000000, stdin);
	ptr = inp;
	int t = SCAN_INT();
	while(t--){
		int n=SCAN_INT();
		REP(i,26){
			pres[i]=vis[i]= false;
			in[i]=out[i]=0;
			REP(j, 26) arr[i][j] = 0;
		}
		int k;
		REP(i,n){
			int l=SCAN_STR();
			int a=s[0]-'a';
			int b=s[l-1]-'a';
			arr[a][b]++;
			in[b]++;
			out[a]++;
			pres[a]=pres[b]=true;
			k=a;
		}
		int node=0;
		REP(i, 26) node+=pres[i];
		int a=0,b=0,c=0;
		REP(i, 26){
			if(pres[i]){
				if(out[i]-in[i]==1) a++;
				else if(in[i]-out[i]==1) b++;
				else if(out[i]!=in[i]){
					 c++;
					 break;
				}

			}
		}
		if(!(c==0 && a<=1 && b<=1)){
			 printf("The door cannot be opened.\n");
			 continue;
		}
		if(dfs(k)!=node){
			printf("The door cannot be opened.\n");
		}
		else {
			printf("Ordering is possible.\n");
		}
	}
}
