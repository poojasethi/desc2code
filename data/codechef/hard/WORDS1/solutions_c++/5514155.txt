#include <bits/stdc++.h>
#define snd(a) scanf("%d",&(a))
#define snlld(a) scanf("%lld",&(a))
#define rep(i,n) for((i)=0;(i)<(n);(i)+=1)
#define reps(i,s,n) for((i)=(s);(i)<(n);(i)+=1)
#define tr(container,it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++)
#define pb push_back
#define pf push_front
#define all(a) (a).begin(),(a).end()
#define rall(a) (a).rbegin(),(a).rend()
#define fill(a,v) memset((a),(v),sizeof(a))
#define sz size()
#define mp make_pair
#define mod  1000000007
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
template<class T> inline T poww(T b,T p){ll a=1;while(p){if(p&1){a=(a*b);}p>>=1;b=(b*b);}return a;}
template<class T> inline T poww2(T b,ll p){T a=1;while(p){if(p&1){a=(a*b);}p>>=1;b=(b*b);}return a;}
template<class T> inline T modpoww(T b,T p,T mmod){ll a=1;while(p){if(p&1){a=(a*b)%mmod;}p>>=1;b=(b*b)%mmod;}return a%mmod;}
template<class T>  inline T gcd(T a,T b){ if(b>a)return gcd(b,a);return ((b==0)?a:gcd(b,a%b));}
template<class T> inline void scan(vector<T>& a,int n){T b;int i; rep(i,n){cin>>b;a.pb(b);}}
inline void scand(vector<int>& a,int n){int b;int i; rep(i,n){snd(b);a.pb(b);}}
#define pii pair<int,int>
#define vpii vector<pii >
#define vi vector<int>
#define vvi vector<vi >
#define vl vector<long long>
#define vs vector<string>
#define fr first
#define sd second
int n;
int ct[2][26],fl[26],e[26][26];
void dfs(int ch,vi& vis){
    if(vis[ch])return ;
    vis[ch]=1;
    int i;
    rep(i,26)if(e[ch][i])dfs(i,vis);
}
int main(){
   int i,j,k,t,n;
   snd(t);
   char s[1010];
   while(t--){
        snd(n);
        fill(ct,0);
        fill(fl,0);
        fill(e,0);

       // fill(same,0);
        rep(i,n){
            scanf("%s",s);
            j=strlen(s);
            int fc=s[0]-'a';
            int lc=s[j-1]-'a';
            ct[0][fc]++;//ist char
            ct[1][lc]++;//last char
           // if(s[0]==s[j-1])same[s[0]-'a']++;
           fl[fc]=fl[lc]=1;
           e[fc][lc]=e[lc][fc]=1;

        }
        int start,stfl=0,edfl=0;
       rep(i,26){//atmost 1 candidate for satrt char can be there.. ( it may be 0.. in case the count is even.. then in that we cant know from counts only)
        if(ct[0][i]==ct[1][i])continue;
        if(ct[0][i]==ct[1][i]+1){
            if(stfl)break;
            start=i;
            stfl=1;
        }
        else if(ct[0][i]+1==ct[1][i]){
            if(edfl)break;
            edfl=1;
        }
        else break;
       }
       if(i<26){
        printf("The door cannot be opened.\n");
       }
       else{
        vi vis(26,0);
        rep(i,26){
            if(ct[0][i]){
                dfs(i,vis);
                break;
            }
        }
        if(accumulate(all(vis),0)==accumulate(fl,fl+26,0))printf("Ordering is possible.\n");
        else  printf("The door cannot be opened.\n");
       }



   }
}













