#include <bits/stdc++.h>

using namespace std;

#define gc getchar_unlocked

void scanint(int &x)
{
    register int c = gc();
    x = 0;
    for(;(c<48 || c>57);c = gc());
    for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}
}

vector<int> v[26];
vector<int> nodes;
int in[26], out[26];
char s[1100];

void dfs(int src, bool *visited)
{
    int i;
    visited[src]=true;
    for(i=0; i<v[src].size(); i++){
        if(!visited[v[src][i]])
            dfs(v[src][i], visited);
    }
    return;
}

void graph_rev()
{
    int i, j;
    vector<int> rev[26];
    for(i=0; i<nodes.size(); i++){
        for(j=0; j<v[nodes[i]].size(); j++)
            rev[v[nodes[i]][j]].push_back(nodes[i]);
    }
    for(i=0; i<26; i++){
        v[i].clear();
        v[i]=rev[i];
    }
}

bool is_strongly_connected()
{
    int i, j;
    bool visited[26];
    memset(visited, false, sizeof(visited));
    dfs(nodes[0], visited);
    for(i=0; i<nodes.size(); i++){
        if(!visited[nodes[i]])
            return false;
    }
    //graph_rev();
    /*for(i=0; i<nodes.size(); i++){
        cout << nodes[i] << "     ";
        for(j=0; j<v[nodes[i]].size(); j++)
            cout << v[nodes[i]][j] << " ";
        cout << endl;
    }
    /*memset(visited, false, sizeof(visited));
    dfs(nodes[0], visited);
    for(i=0; i<nodes.size(); i++){
        if(!visited[nodes[i]])
            return false;
    }*/
    return true;
}

int main()
{
    int n, t, i, j, len, k;
    scanint(t);
    while(t--){
        for(i=0; i<26; i++){
            v[i].clear();
            in[i]=out[i]=0;
        }
        nodes.clear();
        scanint(n);
        map<char, bool> m1;
        for(i=0; i<n; i++){
            scanf("%s", s);
            len=strlen(s);
            v[s[0]-'a'].push_back(s[len-1]-'a');
            v[s[len-1]-'a'].push_back(s[0]-'a');
            in[s[len-1]-'a']++;
            out[s[0]-'a']++;
            if(m1.find(s[0])==m1.end()){
                m1[s[0]]=true;
                nodes.push_back(s[0]-'a');
            }
            if(m1.find(s[len-1])==m1.end()){
                m1[s[len-1]]=true;
                nodes.push_back(s[len-1]-'a');
            }
        }
        sort(nodes.begin(), nodes.end());
        if(!is_strongly_connected()){
            printf("The door cannot be opened.\n");
            continue;
        }
        //cout << "1\n";
        int st, en;
        bool pos=true;
        st=en=0;
        for(i=0; i<26; i++){
            k=out[i]-in[i];
            if(k==0)
                continue;
            else if(k==1)
                st++;
            else if(k==-1)
                en++;
            else{
                pos=false;
                break;
            }
        }
        if(!pos){
            printf("The door cannot be opened.\n");
            continue;
        }
        if(st<=1 && en<=1)
            printf("Ordering is possible.\n");
        else
            printf("The door cannot be opened.\n");
    }
    return 0;
}
