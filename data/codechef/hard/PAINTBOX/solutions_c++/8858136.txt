#include<iostream>
#include<bits/stdc++.h>
using namespace std;
typedef long long int lli ;

lli arr[500010],lazy[500010];
 lli n;
   lli q,m;
long long int read_int(){
 char r;
 bool start=false,neg=false;
 long long int ret=0;
 while(true){
  r=getchar();
  if((r-'0'<0 || r-'0'>9) && r!='-' && !start){
   continue;
  }
  if((r-'0'<0 || r-'0'>9) && r!='-' && start){
   break;
  }
  if(start)ret*=10;
  start=true;
  if(r=='-')neg=true;
  else ret+=r-'0';
 }
 if(!neg)
  return ret;
 else
  return -ret;
}

struct node 
 {
  lli pf,sf,pfc,sfc,ans;
  
 } seg[500001];
 
 lli ups,upe,qs,qe;//qs = query start index , qe= query end index   
 lli val;
 
 
 
 
 
 void build(lli index ,lli start,lli end)
  {
 	// cout<<" build "<<start<<" "<<end<<endl;
   if(start==end)
    {
    //	cout<<" leaf set"<<endl;
     seg[index].pf=arr[start];
     seg[index].sf=arr[start];
     if(m==1)
     seg[index].ans=1;
     else  seg[index].ans=0;
     seg[index].pfc=1;
     seg[index].sfc=1;
    }
    else if(start>end) return ;
    
    else
    {
    	
     build(2*index,start,(start+end)/2);
     build(2*index+1,(start+end)/2+1,end);
     
    // cout<<"st "<<start<<" en "<<end<<endl;
     
     seg[index].pf=seg[2*index].pf;
     seg[index].sf=seg[2*index+1].sf;
     
      lli mid=(start+end)/2;
      lli ll=(mid-start+1);
      lli rr=(end-mid);
      if(seg[index].pf==seg[index].sf  && seg[2*index].pfc+seg[2*index+1].pfc==(end-start+1))
       {
     //  	cout<<"entire set same "<<endl;
       	seg[index].pfc=(end-start+1);
       	seg[index].sfc=(end-start+1);
       	if((end-start+1)-m>=0)
       	seg[index].ans=(end-start+1)-m+1;
       	else seg[index].ans=0;
       	
	   }
	   
	   else if(seg[2*index].sf!=seg[2*index+1].pf)
	    {
	    		seg[index].pfc=seg[2*index].pfc;
       	        seg[index].sfc=seg[2*index+1].sfc;
	    	seg[index].ans=seg[2*index].ans+seg[2*index+1].ans;
		}
		
	   else
	   {
	   	lli an=seg[2*index].ans+seg[2*index+1].ans;
	   	// cal for prefix;;;
	   	lli f=0;
	   	     if(seg[2*index].pf==seg[2*index+1].pf  && ll==seg[2*index].pfc)
	   	    {
	   	    	f=1;
	   	    lli add=0;
	   	    lli min=0;
	   	    
	   	 	seg[index].pfc=ll+seg[2*index+1].pfc;
	   	 	if(seg[index].pfc-m>=0)
	   	 	   add=seg[index].pfc-m+1;
	   	 	   if(seg[2*index].pfc-m>=0) min=seg[2*index].pfc-m+1;
	   	 	   if(seg[2*index+1].pfc-m>=0) min+=seg[2*index+1].pfc-m+1;
	   	 	
	   	 	an+=add-min;
			}
			else
			{
				
				seg[index].pfc=seg[2*index].pfc;
			
			}
		//	cout<<"ans by pre "<<an<<endl;
		///	//// cal for suffix::
			
			if(seg[2*index].sf==seg[2*index+1].pf  && rr==seg[2*index+1].sfc)
	   	    {
	   	    	f=1;
	   	    	 lli add=0;
	   	          lli min=0;
	   	 	seg[index].sfc=rr+seg[2*index].sfc;
	   	 	if(seg[index].sfc-m>=0)
	   	 	add=seg[index].sfc-m+1;
	   	 	if(seg[2*index+1].sfc-m>=0) min=seg[2*index+1].sfc-m+1;
	   	 	if(seg[2*index].sfc-m>=0) min+=seg[2*index].sfc-m+1;
	   	 		an+=add-min;
			}
			else
			{
				seg[index].sfc=seg[2*index+1].sfc;
			
			}
		//	cout<<"ans by suf "<<an<<endl;
			if(f==0)
			 {
			 	if(seg[2*index].sf==seg[2*index+1].pf)
			 	{
			 		lli cc=seg[2*index].sfc+seg[2*index+1].pfc;
			 		if(cc-m>=0) an+=cc-m+1;
			 		if(seg[2*index].sfc-m>=0) an-=seg[2*index].sfc-m+1;
			 		if(seg[2*index+1].pfc-m>=0) an-=seg[2*index+1].pfc-m+1;
			 		
			 		
				 }
			 }
			 //	cout<<"ans by mid "<<an<<endl;
			
			seg[index].ans=an;
	   }
	  // cout<<seg[index].pf<<" "<<seg[index].pfc<<" "<<seg[index].sf<<" "<<seg[index].sfc<<" "<<seg[index].ans<<endl;
    // 
    }
  }
  
  
  
  
   void update(lli index,lli start,lli end)
   {
   	

   
   if(start>end || start>upe || end<ups) return ;// if(range in complitly out of range sooo need not to update ;;;;)
    if(start==end  && start==ups)
    {
   	//cout<<" leaf set"<<"at "<<start<<endl;
     seg[index].pf=val;
     seg[index].sf=val;
     if(m==1)
     seg[index].ans=1;
     else  seg[index].ans=0;
     seg[index].pfc=1;
     seg[index].sfc=1;
     return;
    }
    
     update(2*index,start,(start+end)/2);
     update(2*index+1,((start+end)/2)+1,end);
  //    cout<<"update "<<start<<" "<<end<<endl;
     
    
     seg[index].pf=seg[2*index].pf;
     seg[index].sf=seg[2*index+1].sf;
     
      lli mid=(start+end)/2;
      lli ll=(mid-start+1);
      lli rr=(end-mid);
      
      if(seg[index].pf==seg[index].sf  && seg[2*index].pfc+seg[2*index+1].pfc==(end-start+1))
       {
     //  	cout<<"entire range is same "<<endl;
       	//cout<<"seg[index].pf"<<seg[index].pf<<"seg[index].sf"<<seg[index].sf<<endl;
       	seg[index].pfc=(end-start+1);
       	seg[index].sfc=(end-start+1);
       	if((end-start+1)-m>=0)
       	seg[index].ans=(end-start+1)-m+1;
       	else seg[index].ans=0;
       	
	   }
	    else if(seg[2*index].sf!=seg[2*index+1].pf)
	    {
	    	seg[index].pfc=seg[2*index].pfc;
       	seg[index].sfc=seg[2*index+1].sfc;
	    	seg[index].ans=seg[2*index].ans+seg[2*index+1].ans;
		}
	   else
	   {
	   	lli an=seg[2*index].ans+seg[2*index+1].ans;
	   	// cal for prefix;;;
	   	lli f=0;
	   	     if(seg[2*index].pf==seg[2*index+1].pf  && ll==seg[2*index].pfc)
	   	    {
	   	    	f=1;
	   	    lli add=0;
	   	    lli min=0;
	   	    
	   	 	seg[index].pfc=ll+seg[2*index+1].pfc;
	   	 	if(seg[index].pfc-m>=0)
	   	 	   add=seg[index].pfc-m+1;
	   	 	   if(seg[2*index].pfc-m>=0) min=seg[2*index].pfc-m+1;
	   	 	   if(seg[2*index+1].pfc-m>=0) min+=seg[2*index+1].pfc-m+1;
	   	 	
	   	 	an+=add-min;
			}
			else
			{
				
				seg[index].pfc=seg[2*index].pfc;
			
			}
		//	cout<<"ans by pre "<<an<<endl;
		///	//// cal for suffix::
			
			if(seg[2*index].sf==seg[2*index+1].pf  && rr==seg[2*index+1].sfc)
	   	    {
	   	    	f=1;
	   	    	 lli add=0;
	   	          lli min=0;
	   	 	seg[index].sfc=rr+seg[2*index].sfc;
	   	 	if(seg[index].sfc-m>=0)
	   	 	add=seg[index].sfc-m+1;
	   	 	if(seg[2*index+1].sfc-m>=0) min=seg[2*index+1].sfc-m+1;
	   	 	if(seg[2*index].sfc-m>=0) min+=seg[2*index].sfc-m+1;
	   	 		an+=add-min;
			}
			else
			{
				seg[index].sfc=seg[2*index+1].sfc;
			
			}
		//	cout<<"ans by suf "<<an<<endl;
			if(f==0)
			 {
			 	if(seg[2*index].sf==seg[2*index+1].pf)
			 	{
			 		lli cc=seg[2*index].sfc+seg[2*index+1].pfc;
			 		if(cc-m>=0) an+=cc-m+1;
			 		if(seg[2*index].sfc-m>=0) an-=seg[2*index].sfc-m+1;
			 		if(seg[2*index+1].pfc-m>=0) an-=seg[2*index+1].pfc-m+1;
			 		
			 		
				 }
			 }
			 //	cout<<"ans by mid "<<an<<endl;
			
			seg[index].ans=an;
	   }
	 //	   cout<<seg[index].pf<<" "<<seg[index].pfc<<" "<<seg[index].sf<<" "<<seg[index].sfc<<" "<<seg[index].ans<<endl;
  
 }
 
 
 
 
 
 
 
 
 
 
   node  query(lli index ,lli start,lli end)
   {
     // cout<<" query "<<start<<" "<<end<<endl;
      if(start>end || start>qe || end<qs)
      {
   	// cout<<" return dummy "<<endl;
       node inf;
      inf.pf=-999999999;
     inf.sf=-999999999;
     inf.pfc=0;
     inf.sfc=0;
       inf.ans=0;
       return inf;
       } 
      else if(qs<=start && qe>=end) 
       {
        
          return seg[index];    
      
          
       }
       
        
         node node1= query(2*index,start,(start+end)/2);
         node node2= query(2*index+1,(start+end)/2+1,end);
         node rnode;
         
          lli mid=(start+end)/2;
      lli ll=(mid-start+1);
      lli rr=(end-mid);
      if(rnode.pf==rnode.sf  && node1.pfc+node2.pfc==(end-start+1))
       {
       	rnode.pfc=(end-start+1);
       	rnode.sfc=(end-start+1);
       	if((end-start+1)-m>=0)
       	rnode.ans=(end-start+1)-m+1;
       	else rnode.ans=0;
       	
	   }
	    else if(node1.sf!=node2.pf)
	    {
	    	rnode.pfc=node1.pfc;
	    	rnode.sfc=node2.sfc;
	    	rnode.ans=node1.ans+node2.ans;
		}
	  else
	   {
	   	lli an=node1.ans+node2.ans;
	   	// cal for prefix;;;
	   	lli f=0;
	   	     if(node1.pf==node2.pf  && ll==node1.pfc)
	   	    {
	   	    	f=1;
	   	    lli add=0;
	   	    lli min=0;
	   	    
	   	 	rnode.pfc=ll+node2.pfc;
	   	 	if(rnode.pfc-m>=0)
	   	 	   add=rnode.pfc-m+1;
	   	 	   if(node1.pfc-m>=0) min=node1.pfc-m+1;
	   	 	   if(node2.pfc-m>=0) min+=node2.pfc-m+1;
	   	 	
	   	 	an+=add-min;
			}
			else
			{
				
				rnode.pfc=node1.pfc;
			
			}
		//	cout<<"ans by pre "<<an<<endl;
		///	//// cal for suffix::
			
			if(node1.sf==node2.pf  && rr==node2.sfc)
	   	    {
	   	    	f=1;
	   	    	 lli add=0;
	   	          lli min=0;
	   	 	rnode.sfc=rr+node1.sfc;
	   	 	if(rnode.sfc-m>=0)
	   	 	add=rnode.sfc-m+1;
	   	 	if(node2.sfc-m>=0) min=node2.sfc-m+1;
	   	 	if(node1.sfc-m>=0) min+=node1.sfc-m+1;
	   	 		an+=add-min;
			}
			else
			{
				rnode.sfc=node2.sfc;
			
			}
		//	cout<<"ans by suf "<<an<<endl;
			if(f==0)
			 {
			 	if(node1.sf==node2.pf)
			 	{
			 		lli cc=node1.sfc+node2.pfc;
			 		if(cc-m>=0) an+=cc-m+1;
			 		if(node1.sfc-m>=0) an-=node1.sfc-m+1;
			 		if(node2.pfc-m>=0) an-=node2.pfc-m+1;
			 		
			 		
				 }
			 }
			 //	cout<<"ans by mid "<<an<<endl;
			
			rnode.ans=an;
	   }
	  
	   return rnode;
	 
       
        
   }
   
   
int main()
 {
 	lli t;
 	 cin>>t;
 	 while(t--)
 	 {
 	 	
	  
  
    cin>>n>>m;
    
    for(lli i=0;i<n;i++)arr[i]=read_int();
    build(1,0,n-1);
    cin>>q;
    
     while(q--)
      {
      	lli x,y;
      	 cin>>x>>y;
      	 
      		if(1)
			 {
			 
			 	 ups=x-1;
			 	 upe=x-1;
			 	 val=y;
			 	// for(lli i=ups;i<=upe;i++) arr[i]=val;
			 	// cout<<"after update in the range "<<x-1<<" val "<<y<<endl;
			 	 
			 	 update(1,0,n-1);
			 	 //cout<<"after update in the range "<<x-1<<" val "<<y<<endl;
			 	 
			 }
      	
      	  if(1)
      	   {
      	  
      	   	
      	   	 qs=0;
      	   	 qe=n-1;
      	 
      	   	 node fin=query(1,0,n-1);
      	   	  cout<<fin.ans<<endl;
			 }
		
	  }
}
      
 }
