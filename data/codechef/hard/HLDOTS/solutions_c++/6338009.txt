#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <cstring>
#include <cstdlib>
#include <numeric>
#include <utility>
#include <sstream>
#include <iomanip>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long Long;
typedef double DD;
typedef vector<int> VI;
typedef vector<VI > VVI;
typedef pair<int, int> PII;
typedef pair<Long, Long> PLL;
typedef vector<PII> VPII;
typedef vector<PLL> VPLL;

const int INF = 2000000000;
const int MOD = 19101995;

#define sf scanf
#define pf printf
#define mem(a,b)          memset(a,b,sizeof(a))
#define pb push_back
#define REP(i,a,b)        for(int i=a; i<=b; ++i)
#define REPI(i,a,b,c)     for(int i=a; i<=b; i+=c)
#define REPR(i,a,b)       for(int i=b; i>=a; --i)
#define REPRD(i,a,b,c)    for(int i=b; i>=a; i-=c)
#define REPB(i,a)         for(int i=a; ;i++)
#define REPRB(i,a)        for(int i=a; ; i--)
#define mp(a,b)   make_pair(a,b)
#define fs        first
#define sc        second
#define SZ(s)     ((int)s.size())
#define PI        3.141592653589793
#define VS        vector<string>
#define VI        vector<int>
#define VD        vector<DD>
#define VL        vector<Long>
#define VVL       vector<VL >
#define lim       100001
#define tlim      (1<<((int)ceil(log2(lim))+1))
#define unq(vec)  stable_sort(vec.begin(),vec.end());\
	vec.resize(distance(vec.begin(),unique(vec.begin(),vec.end())));
#define BE(a)     a.begin(),a.end()
#define rev(a)    reverse(BE(a))
#define sorta(a)  stable_sort(BE(a))
#define sortc(a, comp)  sort(BE(a),comp)

//int X[]={1,1,2,2,-1,-1,-2,-2},Y[]={2,-2,1,-1,2,-2,1,-1};//knight move
//int X[]={0,-1,-1,-1,0,1,1,1},Y[]={-1,-1,0,1,1,1,0,-1};//8 move
//int X[]={-1,0,1,0},Y[]={0,1,0,-1};//4 move
Long DP[lim][20], T[lim][20];
bool vis[lim];
VVI G, GD;
int N, maxl;

void DFS(int ch, int par)
{
	if (vis[ch]) return;
	vis[ch] = true;
	REP(i, 0, (SZ(G[ch]) - 1))
	{
		int v = G[ch][i];
		if (v == par) continue;
		GD[ch].pb(v);
		DFS(v, ch);
	}
}
Long REC(int ch, int light)
{
	if (light > maxl) return 0;
	if (SZ(GD[ch]) == 0) return 1;
	Long &ret = DP[ch][light];
	if (~ret) return ret;
	if (SZ(GD[ch]) == 1) return ret = REC(GD[ch][0], light);
	Long prod = 1, aux = 1, ans = 0;
	int len = SZ(GD[ch]) - 1;
	REP(i, 0, len)
	{
		int v = GD[ch][i];
		prod = prod * REC(v, light + 1);
		prod %= MOD;
		T[ch][i] = prod;
	}
	prod = 1;
	REPR(i, 0, len)
	{
		int v = GD[ch][i];
		aux = REC(v, light) * prod;
		aux %= MOD;
		if (i > 0) aux = aux * T[ch][i - 1];
		aux %= MOD;
		ans += aux;
		ans %= MOD;
		prod = prod * REC(v, light + 1);
		prod %= MOD;
	}
	ret = ans;
	return ret;
}
int main(int argc, const char **argv)
{
	ios::sync_with_stdio(false);
	//freopen("input.txt","r",stdin);
	//freopen("output.txt","w",stdout);
	//double st=clock(),en;
	int u, v;
	cin >> N;
	maxl = 31 - __builtin_clz(N);
	G = VVI(N + 1, VI(0));
	GD = VVI(N + 1, VI(0));
	REP(i, 1, (N - 1))
	{
		cin >> u >> v;
		G[u].pb(v);
		G[v].pb(u);
	}
	mem(vis, false);
	DFS(1, 1);
	mem(DP, -1);
	cout << REC(1, 0) << endl;
	//en=clock();
	//cerr<<(double)(en-st)/CLOCKS_PER_SEC<<endl;
	return 0;
}