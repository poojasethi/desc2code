import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
public class Main {
private static final int MAX = 500;
public static void main(String[] args) throws Exception {
int totalTestCases, l, b, n, jr, jc, maxJump = 0;
BufferedInput in = new BufferedInput(System.in);
totalTestCases = in.getNextInt();
for (int i = 0; i < totalTestCases; i++) {
Tree row = new Tree(), columns[] = new Tree[MAX], column;
maxJump = 0;
l = in.getNextInt();
b = in.getNextInt();
for (int j = 0; j < l; j++) {
row = new Tree();
for (int k = 0; k < b; k++) {
if (columns[k] != null) {
column = columns[k];
} else {
column = columns[k] = new Tree();
}
n = in.getNextInt();
jc = column.add(-1 * n);
jr = row.add(n);
if (jc >= jr) {
if (jc > maxJump)
maxJump = jc;
if (jc > jr)
row.update(n, jc);
} else {
if (jr > maxJump)
maxJump = jr;
column.update(-1 * n, jr);
}
}
}
System.out.println(maxJump);
}
}
static class Tree {
public static final int LL = 0;
public static final int LR = 1;
public static final int RL = 2;
public static final int RR = 3;
Node root;
int add(int num) {
Node n = new Node(num);
if (root == null) {
root = n;
} else {
add(root, n, true);
}
return n.jump;
}
void update(int num, int jump) {
Node n = new Node(num);
n.jump = jump;
add(root, n, false);
}
private void add(Node p, Node n, boolean create) {
if (n.num == p.num) {
// Update current node
if (create)
n.jump = n.num == p.num ? ++p.jump : p.jump;
n.height = p.height;
substitute(p, n, p.left, p.right, 7);
p = n;
fixSubTree(p.right, p.num, p.jump);
} else if (n.num < p.num) {
// add left
if (p.left != null) {
add(p.left, n, create);
} else {
addLeft(p, n);
}
p = fixAfterInsertion(p, n) ? n : p;
} else if (n.num > p.num) {
// add right
if (create)
n.jump = p.jump + 1;
if (p.right != null) {
add(p.right, n, create);
} else {
addRight(p, n);
}
} else {
return;
}
updateHeight(p);
reBalance(p);
}
private boolean fixAfterInsertion(Node p, Node n) {
if (n.jump >= p.jump) {
boolean leftNode = p.left == n;
Node p1 = leftNode ? null : n.parent;
n.right = null;
substitute(n, n.left, null, null, 4);
substitute(p, n, p.left, p.right, 7);
if (leftNode) {
updateHeight(n);
} else {
while (p1 != n) {
updateHeight(p1);
p1 = p1.parent;
}
updateHeight(n);
}
fixSubTree(n.right, n.num, n.jump);
return true;
}
return false;
}
private void fixSubTree(Node n, int num, int jump) {
if (n == null)
return;
if (n.num > num) {
if (n.jump <= jump) {
substitute(n, n.right, null, null, 0);
if (n.right != null) {
fixSubTree(n.right, num, jump);
}
} else {
fixSubTree(n.left, num, jump);
}
} else if (n.jump < num) {
if (n.num >= num) {
substitute(n, n.left, null, null, 0);
if (n.left != null) {
fixSubTree(n.left, num, jump);
}
} else {
fixSubTree(n.right, num, jump);
}
}
updateHeight(n);
}
private void addLeft(Node p, Node n) {
if (n != null)
n.parent = p;
p.left = n;
}
private void addRight(Node p, Node n) {
if (n != null)
n.parent = p;
p.right = n;
}
private void substitute(Node n1, Node n2, Node left, Node right,
int flag) {
if (n1.parent != null) {
if (n1.parent.left == n1) {
n1.parent.left = n2;
} else {
n1.parent.right = n2;
}
}
if (root == n1) {
root = n2;
}
if (n2 != null) {
if ((flag & 1) == 1)
addLeft(n2, left);
if ((flag & 2) == 2)
addRight(n2, right);
if ((flag & 4) == 4) {
if (n2.parent != null) {
if (n2.parent.left == n2) {
n2.parent.left = null;
} else {
n2.parent.right = null;
}
}
}
n2.parent = n1.parent;
}
}
private void updateHeight(Node p) {
if (p != null) {
int hl = p.left != null ? p.left.height : 0;
int hr = p.right != null ? p.right.height : 0;
p.height = (hr > hl ? hr : hl) + 1;
}
}
private int getBalanceFactor(Node n) {
int hl = n.left == null ? 0 : n.left.height;
int hr = n.right == null ? 0 : n.right.height;
return hr - hl;
}
private boolean reBalance(Node n) {
int b1 = getBalanceFactor(n), b2;
int r = 5;
if (b1 < -1) {
b2 = getBalanceFactor(n.left);
if (b2 < 0)
r = LL;
else if (b2 > 0)
r = LR;
else
return false;
} else if (b1 > 1) {
b2 = getBalanceFactor(n.right);
if (b2 < 0)
r = RL;
else if (b2 > 0)
r = RR;
else
return false;
}
switch (r) {
case LL:
rotateRight(n);
break;
case LR:
rotateLeft(n.left);
rotateRight(n);
break;
case RL:
rotateRight(n.right);
rotateLeft(n);
break;
case RR:
rotateLeft(n);
break;
}
return r != 5;
}
private void rotateLeft(Node n) {
Node r = n.right;
if (r != null) {
updateHeightForLeftRotation(n);
updateParentChild(n, r, true);
n.right = r.left;
r.left = n;
if (n == root) {
root = r;
}
}
}
private void updateHeightForRightRotation(Node n) {
int hr = 0, hll = 0, hlr = 0;
Node t = n.right;
if (t != null) {
hr = t.height;
}
t = n.left;
if (t.left != null) {
hll = t.left.height;
}
if (t.right != null) {
hlr = t.right.height;
}
n.height = (hr > hlr ? hr : hlr) + 1;
t.height = (hll > n.height ? hll : n.height) + 1;
}
private void updateHeightForLeftRotation(Node n) {
int hl = 0, hrr = 0, hrl = 0;
Node t = n.left;
if (t != null) {
hl = t.height;
}
t = n.right;
if (t.right != null) {
hrr = t.right.height;
}
if (t.left != null) {
hrl = t.left.height;
}
n.height = (hl > hrl ? hl : hrl) + 1;
t.height = (hrr > n.height ? hrr : n.height) + 1;
}
private void rotateRight(Node n) {
Node l = n.left;
if (l != null) {
updateHeightForRightRotation(n);
updateParentChild(n, l, false);
n.left = l.right;
l.right = n;
if (n == root) {
root = l;
}
}
}
private void updateParentChild(Node n, Node lr, boolean leftRotation) {
lr.parent = n.parent;
if (n.parent != null) {
if (n.parent.right == n) {
n.parent.right = lr;
} else {
n.parent.left = lr;
}
}
if (lr.left != null && leftRotation) {
lr.left.parent = n;
}
if (lr.right != null && !leftRotation) {
lr.right.parent = n;
}
n.parent = lr;
}
static class Node {
int num;
int jump = 1;
int height = 1;
Node left, right, parent;
Node(int num) {
this.num = num;
}
}
}
static class BufferedInput {
private static int BUFF_SIZE = 100*1024;
private char[] buffer = new char[BUFF_SIZE];
private int pointer;
private BufferedReader br;
int currentBufferSize;
BufferedInput(InputStream in) {
br = new BufferedReader(new InputStreamReader(in));
}
private void fillBuffer() throws Exception {
if (pointer == currentBufferSize) {
int a = br.read(buffer);
if (a == -1) {
throw new Exception("No more bytes to read");
} else {
currentBufferSize = a;
pointer = 0;
}
}
}
private char getNextChar() throws Exception {
fillBuffer();
return buffer[pointer++];
}
public int getNextInt() throws Exception {
int num = -1, ch;
ch = getNextChar();
while (ch < '0') {
ch = getNextChar();
}
if (ch != -1) {
num = 0;
do {
num = 10 * num + ch - '0';
ch = getNextChar();
} while (ch >= '0');
}
return num;
}
}
}