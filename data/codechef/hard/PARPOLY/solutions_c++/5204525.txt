/*
 	C++ Template
	Gaurav Babbar
*/

#include<bits/stdc++.h>
#define MOD 1000000007
#define MAX 805
#define mp make_pair
#define pb push_back
#define fr fread
#define fw fwrite
#define lld long long
#define llu unsigned long long
using namespace std;

#define DisplayDebuggingInfo 1
#define debug(args...) {dbg,args; if(DisplayDebuggingInfo) cerr<<endl;}
struct debugger{template<typename T> debugger& operator,(const T& v){if(DisplayDebuggingInfo){cerr<< v <<" ";return *this;}}}dbg;

lld ABS(lld a){if(a>0) return a; else return (-1*a);}
int gcd(int a,int b){if (b==0) return a;else return gcd(b,a%b);}
llu power(llu b,llu exp,llu m) {llu ans=1; b%=m; while(exp){if(exp&1) ans=(ans*b)%m; exp>>=1; b=(b*b)%m; } return ans; }
llu mulmod(llu a,llu b,llu c){llu x = 0,y=a%c;while(b > 0){if(b&1) x = (x+y)%c;y = (y<<1)%c;b=b>>1;}return x;}

char *ipos, *opos, InpFile[90000000], OutFile[90000000], DIP[20];
inline void InitFASTIO(){ipos = InpFile; opos = OutFile;fr(InpFile,90000000,1,stdin);}
inline unsigned long long int input(int flag=0){while(*ipos <= 32) ++ipos;if (flag) return (*ipos++ - '0'); /* For getting Boolean Characters */
long long int x=0, neg = 0;char c;while( true ){c=*ipos++; if(c == '-') neg = 1;else{if (c<=32) return neg?-x:x;x=(x<<1)+(x<<3)+c-'0';}}}
inline void output(unsigned long long int x,int flag = 1){if(x<0){*opos++='-';x *= -1;}
int dig=0;long long int y;while (x||!dig) { y=x/10;DIP[dig++]=x-((y << 3) + (y << 1))+'0';x=y;}while (dig--) *opos++=DIP[dig];*opos++= flag ? '\n' : ' ';}
inline void FlushFASTIO(){fw(OutFile,opos-OutFile,1,stdout);}



// * Description:
// * Denote A[j] = P(x*j). Clearly
// * F[m][n] = Sum[F[m-1][k] * A[n-k], 0<=k<=n],
// * So F[m] = F[m-1] * A
// * where A * B is the convolution of sequences A and B:
// * C = A * B if C[n] = Sum[A[k] * B[n-k], 0<=k<=n].
// * We need to find F[M][N]. We have
// * F[M] = F[M-1] * A = (F[M-2] * A) * A = ... = (((F[0] * A) * A) ...) * A,
// * where F[0] = {1, 0, ..., 0}.
// * It can be shown that convolution operation has associative property:
// * A * (B * C) = (A * B) * C
// * and commutative property:
// * A * B = B * A.
// * Hence we can simply write F[M] = A^M * F[0],
// * where A^M = A * ... * A is the convolution power.
// * Associative property allows us to use binary exponentiation method
// * of finding A^M that allows to do this in O(log M) convolution operations.


llu c[15],m,n,x,d,P[MAX];

void calcP()//calc P(num*x)
{
    for(int i=0;i<=n;++i)
    {
        llu pp = i*x;
        if(pp>=MOD)pp%=MOD;
        llu temp = 0,mul=1;
        for(int j=0;j<=d;++j)
        {
            temp = temp + (c[j]*mul);
            if(temp>=MOD) temp%=MOD;
            mul*=pp;
            if(mul>=MOD)mul%=MOD;
        }
        P[i] = temp;
    }
}

// C = A * B if C[n] = Sum[ A[k] * B[n-k], 0<=k<=n]
void convolute(llu* A,llu* B,llu _size)
{
    llu res[MAX];
    for (int i = 0; i <= _size; ++i)
    {
        res[i] = 0;
        for (int j = 0; j <= i; ++j)
        {
            res[i] = (res[i] + (A[j] * B[i - j]) % MOD) % MOD;
        }
    }
    for(int i = 0; i <= _size; ++i)
        A[i] = res[i];
}

int main()
{
   //freopen("input.txt","r",stdin);
   //freopen("output.txt","w",stdout);
   //ios::sync_with_stdio(false);
   InitFASTIO();
   lld t;
   t = input();
   //cin>>t;
   while(t--)
   {
       memset(c,0,sizeof(0));
       m=input(),n=input(),x=input(),d=input();
       for(int i=0;i<=d;++i)c[i]=input();
       calcP();
       llu ans[MAX] = {1};
       llu exp = m;
       while(exp)
        {
            if(exp&1)
                convolute(ans,P,n);
            convolute(P,P,n);
            exp>>=1;
        }
       cout<<ans[n]<<endl;
   }
   FlushFASTIO();
   return 0;
}
