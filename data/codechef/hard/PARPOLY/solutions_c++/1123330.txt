/**
 * June 2012 Codechef Long Contest
 *
 * Problem:     PARPOLY
 * Author:      Anton Lunyov (Tester)
 * Complexity:  O(T * (N * D + N * N * log M))
 * Timing:      1.96 out of 7
 *
 * Description:
 * Denote A[j] = P(x*j). Clearly
 * F[m][n] = Sum[F[m-1][k] * A[n-k], 0<=k<=n],
 * So F[m] = F[m-1] * A
 * where A * B is the convolution of sequences A and B:
 * C = A * B if C[n] = Sum[A[k] * B[n-k], 0<=k<=n].
 * We need to find F[M][N]. We have
 * F[M] = F[M-1] * A = (F[M-2] * A) * A = ... = (((F[0] * A) * A) ...) * A,
 * where F[0] = {1, 0, ..., 0}.
 * It can be shown that convolution operation has associative property:
 * A * (B * C) = (A * B) * C
 * and commutative property:
 * A * B = B * A.
 * Hence we can simply write F[M] = A^N * F[0],
 * where A^N = A * ... * A is the convolution power.
 * Associative property allows us to use binary exponentiation method
 * of finding A^N that allows to do this in O(log M) convolution operations.
 */

#include <iostream>
using namespace std;

typedef long long LL;

const int maxN = 800;
const int maxD = 10;
const int MOD = 1000000007;

void convolute(int N, int *A, int *B) {
	int C[maxN + 1] = {0};
	for (int i = 0; i <= N; ++i) {
		for (int j = 0; i + j <= N; ++j) {
			C[i + j] = (C[i + j] + LL(A[i]) * B[j]) % MOD;
		}
	}
	for (int i = 0; i <= N; ++i) {
		A[i] = C[i];
	}
}

int main() {
#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
#endif
	int T;
	cin >> T;
	for (int t = 0; t < T ; ++t) {
		int M, N, X, D;
		cin >> M >> N >> X >> D;

		int C[maxD + 1];
		for (int i = 0; i <= D; ++i) {
			cin >> C[i];
		}

		int A[maxN + 1] = {0};
		for (int j = 0; j <= N; ++j) {
			int Y = LL(X) * j % MOD;
			for (int i = D; i >= 0; --i) {
				A[j] = (LL(A[j]) * Y + C[i]) % MOD;
			}
		}

		int F[maxN + 1] = {1};
		for (int m = M; m > 0; m /= 2) {
			if (m % 2 == 1) {
				convolute(N, F, A);
			}
			convolute(N, A, A);
		}
		cout << F[N] << endl;
	}
	return 0;
}
