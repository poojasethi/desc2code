#include <bits/stdc++.h>
using namespace std;
 
typedef pair< int , int > pii;
typedef long long LL;
#define fr first
#define se second
#define EPS 1e-8
#define INF 10000*10000*10000LL
stringstream ss;
#define two(x) ( 1LL<<x )
LL mod = 1000000007LL;

/**************************Code****************************/

int mark[1024], cycle[1024], ans[1024][1024], a[1024][1024], p[1024];
int b[3][4] = { {0,2,9,10}, {1,6,7,8}, {3,4,5,11} };

int solve( int n , int m )
{
	if( n < 3 || m < 3 )
		return 0;
	for( int j = 0 ; j < m ; j ++ )
		for( int i = 0 ; i < n ; i ++ )
			a[i][j] = j * n + ( j % n - i + n ) % n;
	if( n == 3 && m == 4 )
		for( int i = 0 ; i < n ; i ++ )
			for( int j = 0 ; j < m ; j ++ )
				a[i][j] = b[i][j];
	return 1;
}

int main()
{
	int t, n, m;
	scanf( "%d" , &t );
	while( t -- )
	{
		scanf( "%d%d" , &n , &m );
		for( int i = 0 ; i < n ; i ++ )
			scanf( "%d" , p + i );
		int possible = 1, last = 0;
		memset( mark , 0 , sizeof mark );
		for( int i = 0 ; possible && i < n ; i ++ )
			if( !mark[i] )
			{
				int now = p[i], k = 0;
				cycle[ k++ ] = i;
				mark[i] = 1;
				while( now != i )
				{
					cycle[ k++ ] = now;
					mark[now] = 1;
					now = p[now];
				}
				possible *= solve( k , m );
				for( int i = 0 ; i < k ; i ++ )
					for( int j = 0 ; j < m ; j ++ )
						ans[ cycle[i] ][j] = a[i][j] + last;
				last += k * m;
			}
		if( possible )
			for( int i = 0 ; i < n ; i ++ )
				for( int j = 0 ; j < m ; j ++ )
					printf( "%d%c" , 1+ ans[i][j] , j+1 == m ? '\n' : ' ');
		else
			puts( "No Solution" );
	}
	return 0;
}
