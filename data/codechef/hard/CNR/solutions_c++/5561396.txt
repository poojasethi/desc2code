#include <iomanip>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <cmath>
#include <vector>
#include <string>
using namespace std;

const int base = 1000000000;			// should be powers of 10 within 10^9
const int offset = int(log10(base));

class BigInteger {

	// Input / Output
	friend std::ostream & operator << (std::ostream & out, const BigInteger & b) {
		if (b.sign == -1)
			out << '-';
		out << (b.digit.empty() ? 0 : b.digit.back());
		for (int i = (int)b.digit.size() - 2; i >= 0; --i)
			out << setw(offset) << setfill('0') << b.digit[i];
		return out;
	}
	friend std::istream & operator >> (std::istream & in, BigInteger & b) {
		string s;
		in >> s;
		b = s;
		return in;
	}

private:
	vector<int> digit;
	int sign;

public:
	// constructors
	BigInteger(long long int value = 0) {
		sign = 1;
		if (value < 0)
			sign = -1, value = -value;
		do {
			digit.push_back(value % base);
			value = value / base;
		} while (value > 0);
	}

	BigInteger(string s) {
		sign = 1;
		digit.clear();
		int pos = 0;
		while (pos < (int)s.size() && (s[pos] == '-' || s[pos] == '+')) {
			if (s[pos] == '-')
				sign = -sign;
			++pos;
		}
		for (int i = s.size() - 1; i >= pos; i -= offset) {
			int x = 0;
			for (int j = max(pos, i - offset + 1); j <= i; j++)
				x = x * 10 + s[j] - '0';
			digit.push_back(x);
		}
		trim();
	}

	// copy constructor
	BigInteger(const BigInteger& b) {
		sign = b.sign;
		digit = b.digit;
	}

	// destructor
	virtual ~BigInteger() {

	}

	// unary operators
	BigInteger operator + () const {
		BigInteger r = *this;
		return r;
	}
	BigInteger operator - () const {
		BigInteger r = *this;
		r.sign = -sign;
		return r;
	}

	// arithmetic operators
	BigInteger operator + (const BigInteger& b) const {
		if (sign != b.sign) {
			return *this - (-b);
		}
		
		BigInteger r = b;
		r.digit.resize(max(digit.size(), b.digit.size()) + 1);
		for (int i = 0, carry = 0; i < (int)max(digit.size(), b.digit.size()) || carry; i++) {
			r.digit[i] += carry + (i < (int)digit.size() ? digit[i] : 0);
			carry = r.digit[i] >= base;
			if (carry)
				r.digit[i] -= base;
		}
		r.trim();
		return r;		
	}
	BigInteger operator - (const BigInteger& b) const {
		if (sign == b.sign) {
			if (abs() >= b.abs()) {
				BigInteger r = *this;
				for (int i = 0, carry = 0; i < (int)b.digit.size() || carry; ++i) {
					r.digit[i] -= carry + (i < (int)b.digit.size() ? b.digit[i] : 0);
					carry = r.digit[i] < 0;
					if (carry)
						r.digit[i] += base;
				}
				r.trim();
				return r;
			}
			return -(b - *this);
		}
		return *this + (-b);
	}
	BigInteger operator * (const BigInteger& b) const {
		BigInteger r;
		long long value;
		int carry = 0;
		r.sign = sign * b.sign;
		r.digit.resize(digit.size() + b.digit.size(), 0);
		for (unsigned int i = 0; i < digit.size(); i++) {
			for (unsigned int j = 0; j < b.digit.size() || carry; j++) {
				value = 1LL * digit[i] * (j < b.digit.size() ? b.digit[j] : 0);
				value += r.digit[i + j] + carry;
				r.digit[i + j] = int(value % base);
				carry = int(value / base);
			}
		}
		r.trim();
		return r;
	}
	BigInteger operator / (const BigInteger& b) const {
		if (b == 0) {
			cout << "Division by zero" << endl;
			return 0;
		}
		
		BigInteger q, r;
		int m, n, d;

		q.digit.resize(digit.size());
		for (int i = (int) digit.size() - 1; i >= 0; i--) {
			r *= base;
			r += digit[i];
			m = r.digit.size() <= b.digit.size() ? 0 : r.digit[b.digit.size()];
			n = r.digit.size() <= b.digit.size() - 1 ? 0 : r.digit[b.digit.size() - 1];
			d = (1LL * base * m + n) / b.digit.back();
			r -= b * d;
			while (r < 0) {
				r += b, d--;
			}
			q.digit[i] = d;
		}
		q.sign = sign * b.sign;
		q.trim();		
		return q;
	}
	BigInteger operator % (const BigInteger& b) const {
		if (b == 0) {
			cout << "Division by zero" << endl;
			return 0;
		}

		BigInteger q, r;
		int m, n, d;

		q.digit.resize(digit.size());
		for (int i = (int)digit.size() - 1; i >= 0; i--) {
			r *= base;
			r += digit[i];
			m = r.digit.size() <= b.digit.size() ? 0 : r.digit[b.digit.size()];
			n = r.digit.size() <= b.digit.size() - 1 ? 0 : r.digit[b.digit.size() - 1];
			d = (1LL * base * m + n) / b.digit.back();
			r -= b * d;
			while (r < 0) {
				r += b, d--;
			}
			q.digit[i] = d;
		}
		r.sign = sign;
		r.trim();
		return r;
	}

	// Bitwise operators
	BigInteger operator ^ (const BigInteger& b) const;
	BigInteger operator | (const BigInteger& b) const;
	BigInteger operator & (const BigInteger& b) const;
	BigInteger operator ~ () const;

	// Relational operators
	bool operator == (const BigInteger& b) const {
		if (sign != b.sign)
			return false;
		if (digit.size() != b.digit.size())
			return false;
		for (int i = digit.size() - 1; i >= 0; i--)
			if (digit[i] != b.digit[i])
				return false;
		return true;
	}
	bool operator <  (const BigInteger& b) const {
		if (sign != b.sign)
			return sign < b.sign;
		if (digit.size() != b.digit.size())
			return digit.size() * sign < b.digit.size() * b.sign;
		for (int i = digit.size() - 1; i >= 0; i--)
			if (digit[i] != b.digit[i])
				return digit[i] * sign < b.digit[i] * sign;
		return false;
	}
	bool operator >  (const BigInteger& b) const {
		return b < *this;
	}
	bool operator != (const BigInteger& b) const {
		return !(*this == b);
	}
	bool operator >= (const BigInteger& b) const {
		return (*this > b) || (*this == b);
	}
	bool operator <= (const BigInteger& b) const {
		return (*this < b) || (*this == b);
	}
	
	// Logical operators
	BigInteger operator ! ();
	bool operator && (const BigInteger& b) const;
	bool operator || (const BigInteger& b) const;

	// Compund assignment operators
	BigInteger& operator  = (const BigInteger& b) {
		if (this != &b) {
			sign = b.sign;
			digit = b.digit;
		}
		return *this;
	}
	BigInteger& operator += (const BigInteger& b) { *this = *this + b; return *this; }
	BigInteger& operator -= (const BigInteger& b) { *this = *this - b; return *this; }
	BigInteger& operator *= (const BigInteger& b) { *this = *this * b; return *this; }
	BigInteger& operator /= (const BigInteger& b) { *this = *this / b; return *this; }
	BigInteger& operator %= (const BigInteger& b) { *this = *this % b; return *this; }
	BigInteger& operator &= (const BigInteger& b) { *this = *this & b; return *this; }
	BigInteger& operator |= (const BigInteger& b) { *this = *this | b; return *this; }
	BigInteger& operator ^= (const BigInteger& b) { *this = *this ^ b; return *this; }

	// Increment/Decrement operators
	BigInteger& operator ++ () {
		*this += 1;
		return *this;
	}
	BigInteger& operator -- () {
		*this -= 1;
		return *this;
	}
	BigInteger operator  ++ (int) {
		BigInteger r(*this);
		operator++();
		return r;
	}
	BigInteger operator  -- (int) {
		BigInteger r(*this);
		operator--();
		return r;
	}

	string toString() const {
	}
	BigInteger abs() const {
		BigInteger r = *this;
		r.sign = 1;
		return r;
	}
	void trim() {
		while (digit.size() > 1 && digit.back() == 0)
			digit.pop_back();
	}

	BigInteger exponent(BigInteger base, BigInteger exponent)
	{
		BigInteger result = 1;
		while (exponent > 0) {
			if (exponent % 2 == 1) {
				result = result * base;
			}
			exponent = exponent / 2;
			base = base * base;
		}
		return result;
	}
};

BigInteger dp[352][352];

int main(int argc, char *argv[])
{
	int T, N, K;
	BigInteger M;
	string ans;

	dp[0][0] = 1;
	for (int i = 1; i <= 350; i++) {
		dp[i][0] = 1;
		for (int j = 1; j <= i; j++) {
			dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
		}
	}

	cin >> T;
	while (T--) {
		cin >> N >> K >> M;
		if (dp[N][K] < M) {
			cout << "-1" << endl;
			continue;
		}
		for (int i = N; i >= 1; i--) {
			if (dp[i - 1][K] >= M) ans += '0';
			else {
				ans += '1';
				M -= dp[i - 1][K];
				K--;
			}
		}
		cout << ans << endl;
		ans.clear();
	}
	return 0;
}