#include<bits/stdc++.h>
using namespace std;
 
#define ii pair<int,int>
#define iii pair<int,ii>
#define mp(a,b) make_pair(a,b)
#define pb(a) push_back(a)
#define BUF 4096 
 
// fast i/o
char ibuf[BUF];
int ipt = BUF;
int read_uint()
{
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF)
    {
        fread(ibuf, 1, BUF, stdin);
        ipt = 0;
        while (ipt < BUF && ibuf[ipt] < '0')
            ipt++;
    }
    int n = 0;
    while (ipt < BUF && ibuf[ipt] >= '0')
    n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF)
    {
        fread(ibuf, 1, BUF, stdin);
        ipt = 0;
        while (ipt < BUF && ibuf[ipt] >= '0')
            n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}
 
int find(int parent[],int x)
{
	if(parent[x]!=x)
	parent[x]=find(parent,parent[x]);
	return parent[x];
}
 
void unite(int parent[],int x,int y)
{
	int parx=find(parent,x);
	int pary=find(parent,y);
	parent[parx]=pary;
	return ;
}
 
int main()
{
//	freopen("C:\\games\\input.txt","r",stdin);
	int t=read_uint();
	while(t--)
	{
		int n,m1,m2;
		n=read_uint();
		m1=read_uint();
		m2=read_uint();
		
		vector<iii> ot;
		vector<iii> ch;
		
		int parent[n+1];
		for(int i=0;i<=n;i++)
		parent[i]=i;
		
		for(int i=0;i<m1;i++)
		{
			int a,b,w;
			a=read_uint();
			b=read_uint();
			w=read_uint();
			ot.pb(mp(w,mp(a,b)));
		}
		
		for(int i=0;i<m2;i++)
		{
			int a,b,w;
			a=read_uint();
			b=read_uint();
			w=read_uint();
			ch.pb(mp(w,mp(a,b)));
		}
		
		long long int ans=0,z=0;
		// z will keep track of number of edges included 
		// ans will keep track of total cost till yet
		
		// Applying kruskal on chef from the end
		sort(ch.rbegin(),ch.rend());
		
		for(int i=0;i<ch.size();i++)
		{
			if(z==n-1)
			break;
			int x = ch[i].second.first;
			int y = ch[i].second.second;
			int w = ch[i].first;
			if(find(parent,x)!=find(parent,y))
			{
				unite(parent,x,y);
				ans+=w;
				z++;
			}
		} 
 
		long long int chef=ans;
 
		// Applying kruskal on others
		sort(ot.begin(),ot.begin()+ot.size());
		
		for(int i=0;i<ot.size();i++)
		{
			if(z==n-1)
			break;
			int x = ot[i].second.first;
			int y = ot[i].second.second;
			int w = ot[i].first;
			if(find(parent,x)!=find(parent,y))
			{
				unite(parent,x,y);
				ans+=w;
				z++;
			}
		}
		if(z!=n-1)
		printf("Impossible\n");
		else
		printf("%lld %lld\n",chef,ans);
	}
	return 0;
} 
