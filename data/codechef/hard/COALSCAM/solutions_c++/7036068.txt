#include<bits/stdc++.h>
using namespace std;
vector < pair< int,pair<int,int> > > v1;
vector < pair <int,pair<int,int> > > v2;
int parent[5010],rank[5010];
int parent_find(int a)
{
	if(parent[a]==a)
	{
		return a;
	}
	int val=parent_find(parent[a]);
	parent[a]=val;
	return parent[a];
}
int main()
{
	int t,i,n,m1,m2,count,s,d;
	long long int w,weight,chef_profit,total_profit;
	
	scanf("%d",&t);
	while(t--)
	{
		 count=0;
		scanf("%d%d%d",&n,&m1,&m2);
		for(i=0;i<m1;i++)
		{
			scanf("%d %d %lld",&s,&d,&w);
			v1.push_back(make_pair(w,make_pair(s,d)));
		}
		for(i=0;i<m2;i++)
		{
			scanf("%d %d %lld",&s,&d,&w);
			v2.push_back(make_pair(w,make_pair(s,d)));
	 }
	 for(i=0;i<n;i++)
	 {
	 	parent[i]=i;
	 	rank[i]=1;
	 }
	 
	 sort(v2.rbegin(),v2.rend());
	 chef_profit=0;
	 total_profit=0;
	for(i=0;i<m2&&count<n-1;i++)
	 {
	 	 weight=v2[i].first;
	 	int a=v2[i].second.first;
	 	int b=v2[i].second.second;
	 	int par_a=parent_find(a);
	 	int par_b=parent_find(b);
	 	
	 	if(par_a!=par_b)
	 	{
	 		count++;
	 		chef_profit=chef_profit+weight;
	 		if(rank[par_a]>rank[par_b])
	 		{
	 			parent[par_b]=par_a;
	 			
	 		}
	 		else if(rank[par_a]<rank[par_b])
	 		{
	 			parent[par_a]=par_b;
	 			
	 		}
	 		else
	 		{
	 			parent[par_a]=par_b;
	 			rank[par_b]++;
	 		}
	 		
	 	}
	 	
	 	
	 }
	  total_profit=chef_profit;
	  sort(v1.begin(),v1.end());
	  for(i=0;i<m1&&count<n-1;i++)
	 {
	 	weight=v1[i].first;
	 	int a=v1[i].second.first;
	 	int b=v1[i].second.second;
	 	int par_a=parent_find(a);
	 	int par_b=parent_find(b);
	 	
	 	if(par_a!=par_b)
	 	{
	 		count++;
	 		total_profit=total_profit+weight;
	 		if(rank[par_a]>rank[par_b])
	 		{
	 			parent[par_b]=par_a;
	 			
	 		}
	 		else if(rank[par_a]<rank[par_b])
	 		{
	 			parent[par_a]=par_b;
	 			
	 		}
	 		else
	 		{
	 			parent[par_a]=par_b;
	 			rank[par_b]++;
	 		}
	 		
	 	}
	 	
	 	
	 }
	  
	
	 v1.clear();
	 	v2.clear();
	 	if(count!=n-1)
	 	{
	 		printf("Impossible\n");
	 	}
	 	else
	 	{
	 		printf("%lld %lld\n",chef_profit,total_profit);
	 	}
	}
}