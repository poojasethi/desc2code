#include <iostream>
#include <cstdio>
#include <vector>
#include <cstring>
#include <algorithm>
using namespace std;

struct UnionFind
{
    vector<int> dad,mass;
    int N;
    UnionFind(int _N)
    {
        N=_N;
        dad.resize(N);
        mass.resize(N);
        for(int i=0;i<N;i++)
        {
            dad[i]=-1,mass[i]=1;
        }
    }

    int findv(int a)
    {
        if(dad[a]<0)return a;
        return dad[a]=findv(dad[a]);
    }

    bool mergev(int a,int b)
    {
        int c1=findv(a),c2=findv(b);
        if(c1!=c2)
        {
            N--;
            if(mass[c1]<mass[c2]){swap(c1,c2);}
            mass[c1]+=mass[c2];
            dad[c2]=c1;
            return true;
        }
        return false;
    }

    int comps()
    {
        return N;
    }
};

typedef pair<int, pair<int,int> > edge;
int N,M1,M2;
const int max_edge=100005;
edge one[max_edge],two[max_edge];

void solve()
{
    UnionFind uf(N);
    sort(two,two+M2);
    reverse(two,two+M2);

    long long profit=0;

    for(int i=0;i<M2;i++)
    {
        edge e=two[i];
        if(uf.mergev(e.second.first,e.second.second))
        {
            profit+=e.first;
        }
    }

    long long cost = profit;
    sort(one,one+M1);

    for(int i=0;i<=M1;i++)
    {
        edge e=one[i];
        if(uf.mergev(e.second.first,e.second.second))
        {
            cost += e.first;
        }
    }

    if(uf.comps()>1)
    {
        printf("Impossible\n");
    }
    else
    {
        printf("%lld %lld\n", profit, cost);
    }
}

int cnt=0;
bool input()
{
    int u,v,c;
    scanf("%d %d %d",&N,&M1,&M2);

    for(int i=0;i<M1;i++)
    {
        scanf("%d %d %d",&u,&v,&c);
        one[i]=std::make_pair(c,std::make_pair(u,v));
    }

    for(int i=0;i<M2;i++)
    {
        scanf("%d %d %d",&u,&v,&c);
        two[i]=std::make_pair(c,std::make_pair(u,v));
    }

    return true;
}

int main()
{
    int T=1;
    scanf("%d",&T);
    while(T--)
    {
        if(input())
        {
            solve();
        }
    }
    return 0;
}
