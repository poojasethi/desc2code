#include<bits/stdc++.h>
#define ll long long int
#define vi vector<int>
#define vpi vector<pair<ll,pair<int,int> > >
using namespace std;
vpi v1 , v2;
class UF
{
	private:vi id,sz;
	public:
	UF(int n)
	{
		id=vi(n+1);
		sz=vi(n+1,1);
		for(int i=0;i<=n;i++)
		{
			id[i]=i;
		}
	}
	ll root(int i)
	{
		while(i!=id[i])
		{
			id[i]=id[id[i]]; // make each node point to it's grandparent to flatten the tree
			i=id[i];
		}
		return i;
	}
	bool Connected(ll p,ll q)
	{
		return root(p)==root(q);
	}
	void Union(ll p,ll q)
	{
		ll proot=root(p);
		ll qroot=root(q);
		if(sz[proot]>sz[qroot]) { id[qroot]=id[proot]; sz[proot]+=sz[qroot]; }
		else { id[proot]=id[qroot]; sz[qroot]+=sz[proot]; }
	}
};
int main()
{
	ios_base::sync_with_stdio(0);
	int t,n,m1,m2,u,v;
	ll c,profit,total;
	cin>>t;
	while(t--)
	{
		v1.clear();
		v2.clear();
		cin>>n>>m1>>m2;
		UF uf(n);
		for(int i=0;i<m1;i++)
		{
			cin>>u>>v>>c;
			v1.push_back(make_pair(c,make_pair(u,v)));
		}
		for(int i=0;i<m2;i++)
		{
			cin>>u>>v>>c;
			v2.push_back(make_pair(c,make_pair(u,v)));
		}
		sort(v1.begin(),v1.end());
		sort(v2.rbegin(),v2.rend());
		int edges=profit=total=0;
		for(int i=0;i<v2.size();i++)
		{
			if(edges==n-1)	break;
			
			if(!uf.Connected(v2[i].second.first,v2[i].second.second))
			{
				uf.Union(v2[i].second.first,v2[i].second.second);
				profit+=v2[i].first;
				total+=v2[i].first;
				edges++;
			}
		}
		if(edges!=n-1)
		{
		for(int i=0;i<v1.size();i++)
		{
			if(!uf.Connected(v1[i].second.first,v1[i].second.second))
			{
				uf.Union(v1[i].second.first,v1[i].second.second);
				total+=v1[i].first;
				edges++;
			}
		}
		}
		if(edges<n-1)
		cout<<"Impossible\n";
		else
		cout<<profit<<" "<<total<<"\n";
	}
}