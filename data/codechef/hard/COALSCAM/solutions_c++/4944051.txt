//Author: Aman Choudhary
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <cmath>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>
#include <climits>
#include <map>
#include <cassert>
#define mod  1000000007
#define PHI 1000000006
#define ull unsigned long long
#define ill long long int
#define pii pair<int,int>
#define pb(x) push_back(x)
#define F(i,a,n) for(i=(a);i<(n);++i)
#define FD(i,a,n) for(i=(a);i>=(n);--i)
#define FE(it,x) for(it=x.begin();it!=x.end();++it)
#define V(x) vector<x>
#define S(x) scanf("%d",&x)
#define S1(x) scanf("%llu",&x)
#define MAX 50009
#define NIL 0
#define INF (1<<28)

#define MAXNODES 50009
using namespace std;

struct nnn {
    int element,parent,r1;
    nnn() {}
    nnn(int e,int p,int r) {
        element = e;
        parent = p;
        r1 = r;
    }
};
nnn disjoint[MAXNODES];
void makeset(int x) {
    // disjoint[x] = node(x,x,0);
    disjoint[x].parent = x;
    disjoint[x].element = x;
    disjoint[x].r1 = 0;
}
int findset(int x) {
    if ( disjoint[x].parent != disjoint[x].element )
        disjoint[x].parent = findset(disjoint[x].parent);
    return disjoint[x].parent;
}
void unionset(int x,int y) {
    if ( findset(x) == findset(y) ) return;
    int parX = disjoint[x].parent;
    int parY = disjoint[y].parent;
    if ( disjoint[parX].r1 > disjoint[parY].r1 )
        disjoint[parY].parent = parX;
    else
        disjoint[parX].parent = parY;
    if ( disjoint[parY].r1 == disjoint[parX].r1 )
        disjoint[parY].r1++;
}

struct node
{
    int x,y;
    ill z;
};
struct node get(int x, int y, ill z)
{
    struct node s;
    s.x = x;
    s.y = y;
    s.z = z;
    return s;
}
bool fff (struct node a, struct node b)
{
    return a.z>b.z;
}
bool ff (struct node a, struct node b)
{
    return a.z<b.z;
}
vector <struct node> a,b;
int n;

void print(vector <struct node> s)
{
    int i;
    F (i, 0, s.size()) cout << s[i].x << " " << s[i].y << " " << s[i].z << endl;
    cout << endl;
}

int main()
{
  //  freopen ("input.txt", "r", stdin);

    int t;
    S (t);

    while (t--) {
        int m1,m2;
        S (n);
        S (m1);
        S (m2);

        int i;
        F (i, 0, n) makeset(i);

        a.clear();
        b.clear();

        while (m1--) {
            int x,y;
            ill z;
            S (x);
            S (y);
            S1 (z);
            a.pb (get(x,y,z));
        }

        while (m2--) {
            int x,y;
            ill z;
            S (x);
            S (y);
            S1 (z);
            b.pb (get(x,y,z));
        }
        sort (a.begin(), a.end(), ff);
        sort (b.begin(), b.end(), fff);

        ill aa,bb;
        aa = bb = 0;
        F (i, 0, b.size()) {
            int x = findset(b[i].x);
            int y = findset(b[i].y);
            if (x == y) continue;
            unionset(b[i].x, b[i].y);
            aa+= b[i].z;
        }

        F (i, 0, a.size()) {
            int x = findset(a[i].x);
            int y = findset(a[i].y);
            if (x == y) continue;
            unionset(a[i].x, a[i].y);
            bb+= a[i].z;
        }

        bool ok = true;
        int yes = findset(0);
        F (i, 1, n) {
            int x = findset(i);
            if (x != yes) ok = false;
        }

        if (!ok) printf ("Impossible\n");
        else printf ("%lld %lld\n", aa, bb+aa);

    }

	return 0;
}
