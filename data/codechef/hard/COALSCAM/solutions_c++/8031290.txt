#include <iostream>
#include <algorithm>
using namespace std;
#define MAX_INT  99999

struct Edge1
{
	int U;
	int V;
	int nCost;

	bool operator < (const struct Edge1& S1)const
	{
		return nCost < S1.nCost;
	}
};

struct Edge2
{
	int U;
	int V;
	int nCost;

	bool operator < (const struct Edge2& S2)const
	{
		return nCost > S2.nCost;
	}
};

struct subset
{
    int parent;
    int rank;
};


struct subset stSubsetARR[5001];
struct Edge1 stFirstEdge[20001];
struct Edge2 stSecEdge[20001];
int nNoOfCities;

int Find(struct subset stSubsetARR[],int i)
{
	if(stSubsetARR[i].parent == i)
		return stSubsetARR[i].parent;
	Find(stSubsetARR,stSubsetARR[i].parent);
}

void MakeSet(int U,int V)
{
	int nX = Find(stSubsetARR,U);
	int nY = Find(stSubsetARR,V);

	if(stSubsetARR[nX].rank < stSubsetARR[nY].rank)
	{
		stSubsetARR[nX].parent = nY;
	}
	else
	{
		stSubsetARR[nY].parent  = nX;
		stSubsetARR[nX].rank++;
	}
}

void ResetMatrix()
{
   for(int l = 0; l < nNoOfCities; l++)
   {
	   stSubsetARR[l].parent = l;
	   stSubsetARR[l].rank = 0;

	   stFirstEdge[l].nCost = 0;
	   stFirstEdge[l].U = 0;
	   stFirstEdge[l].V = 0;

	   stSecEdge[l].nCost = 0;
	   stSecEdge[l].U = 0;
	   stSecEdge[l].V = 0;
   }
}


int main()
{
	int nNoOftestCases = 0;
	cin >> nNoOftestCases;

	int M1;
	int M2;
	int nStartPoint;
	int nEndPoint;

	unsigned long long nCost = 0;
	unsigned long long ntotalProfit = 0;
	for(int ntest = 0; ntest < nNoOftestCases; ntest++)
	{
		cin >> nNoOfCities;
		cin >> M1;
		cin >> M2;

		ResetMatrix();

		for(int i = 0; i < M1; i++)
		{
			cin >> stFirstEdge[i].U;
			cin >> stFirstEdge[i].V;
			cin >> stFirstEdge[i].nCost;
		}

		sort(stFirstEdge,stFirstEdge+M1);

		for(int i = 0; i < M2; i++)
		{
		    cin >> stSecEdge[i].U;
			cin >> stSecEdge[i].V;
			cin >> stSecEdge[i].nCost;
		}

		sort(stSecEdge,stSecEdge+M2);

		unsigned long long nCost = 0;
		unsigned long long nProfit = 0;
		int nCount = 0;
		for(int k = 0; k < M2; k++)
		{ 
			int x = Find(stSubsetARR, stSecEdge[k].U);
            int y = Find(stSubsetARR, stSecEdge[k].V);
			if (x != y)
			{
				MakeSet(x,y);
             	nCost += stSecEdge[k].nCost;
			    nProfit += stSecEdge[k].nCost;
			    nCount++;
			}
		}

		for(int i = 0; i < M1; i++)
		{
			int x = Find(stSubsetARR, stFirstEdge[i].U);
            int y = Find(stSubsetARR, stFirstEdge[i].V);
			if (x != y)
			{
				MakeSet(x,y);
				nCost += stFirstEdge[i].nCost;
			    nCount++;
			}
		}

		if(nNoOfCities-1 != nCount)
			cout << "Impossible";
		else
		    std::cout << nProfit << " " << nCost;
		cout << endl;
	}	
}