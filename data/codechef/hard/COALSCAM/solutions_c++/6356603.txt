#include<iostream>
#include<vector>
#include<algorithm>
#include<stdio.h>
using namespace std;
typedef long long int L;
/*inline int inp()
{
int noRead=0;
char p=getchar_unlocked();
for(;p<33;)
{
p=getchar_unlocked();
};
while(p>32)
{
noRead = (noRead << 3) + (noRead << 1) + (p - '0');
p=getchar_unlocked();
}
return noRead;
};*/
class edge
{
public:
int u,v,c,chef;
edge(int a,int b,int co,int ch)
{
u=a;
v=b;
c=co;
chef=ch; // 0 for chef
}
bool operator < (const edge &e) const{
if(chef != e.chef)
return chef<e.chef;
if(chef==0)
return c> e.c;
if(chef==1)
return c<e.c;
}
};
int root[40000+4],rank[40000+4]={0};
int find(int x)
{
if(root[x]==x)
return x;
else
{root[x]=find(root[x]);
return root[x];}
}
bool union_set(int a,int b)
{
int x=find(a);
int y=find(b);
if(x==y)
return false;
if(rank[x]==rank[y])
{
rank[x]++;
root[y]=x;
}
else if(rank[x]<rank[y])
root[x]=y;
else
root[y]=x;
return true;
}
int main()
{
int t;
cin>>t;
while(t--)
{
vector<edge> edges;
vector<int> MST;
int n,m1,m2;
//n=inp();
//m1=inp();
//m2=inp();
scanf("%d%d%d",&n,&m1,&m2);
int i,u,v,c;
for(i=1;i<=m1;i++)
{
//u=inp();
//v=inp();
//c=inp();
scanf("%d%d%d",&u,&v,&c);
edges.push_back(edge(u,v,c,1));
}
for(i=1;i<=m2;i++)
{
//u=inp();
//v=inp();
//c=inp();
scanf("%d%d%d",&u,&v,&c);
edges.push_back(edge(u,v,c,0));
}
sort(edges.begin(),edges.end());
/* for(i=0;i<edges.size();i++)
{
cout<<edges[i].u<<" "<<edges[i].v<<" "<<edges[i].c<<endl;
}*/
for(i=0;i<=n;i++)
{
root[i]=i;
}
int k=0,m;
m=m1+m2;
L sum=0,prft=0;
i=0;
while((k<n-1) && (i<m))
{
if(union_set(edges[i].u,edges[i].v))
{
if(edges[i].chef==0)
prft=prft+edges[i].c;
sum=sum+edges[i].c;
k++;
}
i++;
}
if(k==n-1)
printf("%lld %lld\n",prft,sum);
else
printf("Impossible\n");}
return 0;
}
