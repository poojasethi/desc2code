#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
#include <functional>
#include <math.h>

inline bool fastreadIsEndOfLine(int* a)
{
  register char c = 0;
  while (c < 33)
    c = getchar();
  *a = 0;
  while (c > 33)
  {
    *a = (*a <<1)+(*a<<3) + c - '0';
    c = getchar();
    if(c == '\r' || c == '\n')
      return true;
  }

  return false;
}

inline void fastread(int* a)
{
  register char c = 0;
  while (c < 33)
    c = getchar();
  *a = 0;
  while (c > 33)
  {
    *a = (*a <<1)+(*a<<3) + c - '0';
    c = getchar();
  }
}

inline void fastreadNeg(int* a)
{
  register char c = 0;
  while (c < 33)
    c = getchar();
  *a = 0;
  bool neg = false;
  if(c == '-')
  {
	  c = getchar();
	  neg = true;
  }
  while (c > 33)
  {
    *a = (*a <<1)+(*a<<3) + c - '0';
    c = getchar();
  }

  if(neg)
	  *a = -*a;
}

int N, K, F, M1, M2;
int T = 1;

int C[5000 + 1];

struct Road
{
	int		cityA;
	int		cityB;
	int		cost;
};
Road R1[20000 + 1];
Road R2[20000 + 1];

struct lessCost : public std::binary_function<Road, Road, bool>
{
  bool operator()(const Road& l, const Road& r) const
  {
	  if(l.cost == r.cost)
	  {
		  if(l.cityA == r.cityA)
			  return l.cityB < r.cityB;

		  return l.cityA < r.cityA;
	  }

    return l.cost < r.cost;
  }
};

struct greaterCost : public std::binary_function<Road, Road, bool>
{
  bool operator()(const Road& l, const Road& r) const
  {
	  if(l.cost == r.cost)
	  {
		  if(l.cityA == r.cityA)
			  return l.cityB > r.cityB;

		  return l.cityA > r.cityA;
	  }

    return l.cost > r.cost;
  }
};

int Find(int c)
{
	if(C[c] != c)
		C[c] = Find(C[c]);
	return C[c];
}

int leftUnjoined = 0;
bool ProcessRoads(Road *roads, int count, long long &profit, long long &cost)
{
	for(int i = 0; i < count; ++i)
	{
		const Road &r = roads[i];

		const int parentA = Find(r.cityA);
		const int parentB = Find(r.cityB);
		if(parentA != parentB)
		{
			C[parentA] = parentB; // union/join
			profit += r.cost;
			cost += r.cost;
			--leftUnjoined;
		}

		if(leftUnjoined == 1)
			return true;
	}

	return false;
}

int main()
{
#ifdef USE_DATA_TXT
  freopen_s(&stream, "C:\\Projects\\TaskTemplate\\data.txt", "r", stdin);
#endif
#ifdef PRINT_PERF
  auto start = std::chrono::high_resolution_clock::now();
#endif

  fastread(&T); // [1, 100000]

  while(T--)
  {
    fastread(&N);
    fastread(&M1);
    fastread(&M2);

	for(int i = 0; i < N; ++i)
	{
		C[i] = i;
		//C[i].hub = i;
		//C[i].next = -1;
		//C[i].last = i;
		//C[i].count = 1;
	};

	int *p = (int*)R1;
    for(int i = 0; i < M1; ++i)
    {
		fastread(p++);
		fastread(p++);
		fastread(p++);
    }

	p = (int*)R2;
    for(int i = 0; i < M2; ++i)
    {
		fastread(p++);
		fastread(p++);
		fastread(p++);
    }

	std::sort(R1, R1 + M1, lessCost()); // Sort other roads - lesser first
	std::sort(R2, R2 + M2, greaterCost()); // Sort Chef's roads - greater first

	long long profit = 0;
	long long cost = 0;
	long long dummy = 0;

	leftUnjoined = N;

	bool isDone = ProcessRoads(R2, M2, profit, cost);
	if(!isDone)
		isDone = ProcessRoads(R1, M1, dummy, cost);
	if(isDone)
		printf("%lld %lld\n", profit, cost);
	else
		printf("Impossible\n");
  }

#ifdef PRINT_PERF
  PrintResultPerf(start);
#endif
#ifdef USE_DATA_TXT
  if(stream)
  {
    fclose(stream);
    stream = NULL;
  }
#endif

  return 0;
}
