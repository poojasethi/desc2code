#include <iostream>
#include <iosfwd>
#include <iomanip>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <cassert>
#include <cctype>
#include <climits>
#include <vector>
#include <bitset>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <deque>
#include <string>
#include <list>
#include <iterator>
#include <sstream>
#include <complex>
#include <fstream>
#include <functional>
#include <numeric>
#include <utility>
#include <algorithm>
# define getcx getchar_unlocked

using namespace std;
long long profit, cost2;
int maxedge;

inline void inpInt( int  &n )//fast input function
{
        n=0;
        int ch=getcx();

        while( ch < '0' || ch > '9' )
        {ch=getcx();}
        while( ch >= '0' && ch <= '9' )
        n = (n<<3)+(n<<1) + ch-'0', ch=getcx();
}

struct edge
{
    int u,v;
    long long cost;

    static edge makeEdge(int u, int v,long long cost){
    edge e;
    e.u= u;
    e.v= v;
    e.cost= cost;

    return e;
    }
};

//solution to topological compare function problem and need of edge class
bool EdgeComp(edge a, edge b)
{
    return(a.cost<b.cost);

}

struct MST
{
    vector <edge> Edges;
    vector<int> parent;
    int nodes;
    void initialise(int n)
    {
            nodes= n;
            for(int i=0;i<nodes;i++)
            parent.push_back(i);
    }

    void addEdge(int u, int v, long long cost)
    {
      Edges.push_back(edge::makeEdge(u,v,cost));        // important
    }

    int findSet(int i)
    {
        while(parent[i]!= i)
        i= parent[i];
        return i;
    }
    void setUnion(int u, int v)
    {
        parent[u]=v;
    }
    void Krushkal()
    {
            vector<edge> mst;
            int u1,v1,x,y;
            sort(Edges.begin(),Edges.end(),EdgeComp);
            for(int i=0;i<Edges.size();i++)
            {
                u1= Edges[i].u;
                v1= Edges[i].v;
                x= findSet(u1);
                y= findSet(v1);
                 //   printf("%d %d\n",u1, v1);

                if(x!=y)
                {
                    setUnion(x,y);
                    maxedge++;
                    if(Edges[i].cost<0)
                        profit= profit- Edges[i].cost;
                    else
                        cost2= cost2+ Edges[i].cost;
                }
            }
    }

};

void program();
int main()
{
    int t;
//    scanf("%d",&t);
    inpInt(t);
    while(t--)
    program();
    return 0;
}

void program()
{
    int i,n, m1, m2,u,v;
    long long cost;
    profit=0;
    cost2=0;
    maxedge=0;
    vector<edge> ans;
//    scanf("%d %d %d",&n,&m1,&m2);
    inpInt(n);
    inpInt(m1);
    inpInt(m2);
    MST g;
    g.initialise(n);
    for(i=0;i<m1;i++)
        {
            //scanf("%d %d %lld",&u,&v,&cost);
            inpInt(u);
            inpInt(v);
            scanf("%lld",&cost);
            g.addEdge(u,v,cost);
        }
    for(i=0;i<m2;i++)
        {
            inpInt(u);
            inpInt(v);
            scanf("%lld",&cost);
            g.addEdge(u,v,-cost);
        }
     g.Krushkal();

    if(maxedge!= n-1)
    {
        printf("Impossible\n");
        return;
    }

    cost2= cost2+ profit;
    printf("%lld %lld\n",profit,cost2);
}
