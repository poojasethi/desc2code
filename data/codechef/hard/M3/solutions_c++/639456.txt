//  Filename:  M3.cpp 
//  Author:  pankaj kumar, pankaj4u4m@gmail.com
#include <algorithm>
#include <bitset>
#include <cassert>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <deque>
#include <functional>
#include <iostream>
#include <iterator>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <utility>
#include <vector>
using namespace std;

/* Only for Debugging */
#define out(_x) cout << #_x<< "=" <<_x << endl;
#define outC(A) cout<<#A<<"={";for(__typeof(A.begin()) _it=A.begin();_it!=A.end();++_it)cout<<*_it<< " ";cout<<"}"<<endl;
template<class T>inline void outA(T A[], int n) {cout<<"{";for(int i=0;i<n;i++)cout<<A[i]<<" ";cout<<"}"<<endl;}

/* Input Output Function */
//#define GET
#ifdef GET
#define BUFSIZE (1<<26)
char DIP[20];
char IBUF[BUFSIZE+1], *inputptr=IBUF;
#define INPUT fread(IBUF, 1, BUFSIZE, stdin);
#define DIG(a) (((a)>='0')&&((a)<='9'))
#define getChar(t) {t=*inputptr++;}
template<class T>inline bool getInt(T &j){j=0;int _t;getChar(_t);if(_t==0)return false;char sign;while(!DIG(_t)&&_t!=0){sign=_t;getChar(_t);}while(DIG(_t)){j=10*j+(_t-'0');getChar(_t);}if(sign == '-') j = -j;*inputptr--;return j==0&&_t==0?false:true;}//::getInt(
inline bool getString(char *s, char n = 32){char _c;getChar(_c);if(_c==0)return false;while(_c==10||_c==n)getChar(_c);while(_c != 10&&_c != n&&_c!=0){*s++=_c;getChar(_c)}*s=0;inputptr--;return s[0]==0&&_c==0?false:true;}
inline bool getLine(char *s){return getString(s, 10);}
#endif
/**************** Main program *******************/
int n;
int a[500][500];
int one[500];
int mxone = 0;
int two[500];

int main(){
  //freopen("input.txt","r",stdin);
  int t;scanf("%d", &t);while(t--){
    scanf("%d", &n);for(int i = 0; i< n; i++)for(int j =0 ; j<n; j++)
      scanf("%d", &a[i][j]);
    mxone = 0;
    for(int i =0 ; i< n; i++){
      one[i] = 0;
      two[i] = 0;
      for(int j =0 ; j< n; j++){
        one[i] += (a[i][j] == 1);
        two[i] += (a[i][j] == 2);
      }
      mxone=max(mxone, one[i]);
    }
    for(int i =0 ; i< n; i++){
      int mx = one[i]+two[i];
      bool flag = ((mx>=mxone) && (mx >=n/2));
      if(flag)
      for(int j = 0; j< n; j++){
        if(i !=j)
        for(int k = j+1 ; k< n; k++){
          if(one[j]>=mx && one[k]>=mx && a[j][k] == 2)flag = false;
        }
      }
      putchar(flag?'1':'0');
    }
    puts("");
  }
  return 0;
}
