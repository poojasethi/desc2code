#include<bits/stdc++.h>
#define PB push_back
using namespace std;

const double PI = 2.00*acos(0.0);

typedef complex<double> base;
vector<base> omega;
long long FFT_N,mod=99991;

void init_fft(int n)
{
     int i;
     FFT_N=n;
     omega.resize(FFT_N);
     double angle=2*PI/FFT_N;

     for(i=0; i<n; i++)
     {
          omega[i]=base( cos(i*angle), sin(i*angle) );
     }
}

void fft(vector<base>&a)
{
      int n=a.size();
      if(n==1)  return;
      int half=n/2;
      vector<base>even(half),odd(half);

      int i,j;
      for(i=0,j=0; i<n; i+=2,j++)
      {
          even[j]=a[i];
          odd[j]=a[i+1];
      }

      fft(even),fft(odd);

      int fact=FFT_N/n;
      for(i=0; i<half; i++)
      {
           base t=odd[i]*omega[i*fact];
           a[i]=even[i]+t;
           a[i+half]=even[i]-t;
      }
}

void multiply(const vector<long long>&a, const vector<long long>&b, vector<long long>&c)
{
    vector<base>fa(a.begin(),a.end()), fb(b.begin(),b.end());
    int n=1;
    while(n<2*max(a.size(),b.size()))  n<<=1;

    fa.resize(n),fb.resize(n);
    init_fft(n);
    fft(fa),fft(fb);

    int i;

    //pointwise multiplication
    for(i=0; i<n; i++)
    {
         fa[i]=conj(fa[i]*fb[i]);//conjugation is needed for interpolation
    }

    fft(fa);
    c.resize(n);

    //interpolation
    for(i=0; i<n; i++)
    {
        c[i]=(long long)(fa[i].real()/n+0.5);
        c[i]%=mod;
    }
}

long long pwr(long long base,long long pwr)
{
    long long res=1LL;
    while(pwr>0)
    {
        if(pwr%2){
            res=(res*base);
            if(res>=mod)  res%=mod;
        }
        base*=base;
        if(base>=mod)  base%=mod;
        pwr/=2;
    }
    return res;
}

int main()
{
     int n,i,j,l,p,k;
     long long x,ya,yb,inv;
     inv=22019LL;
     vector<long long>a,b,c;
     vector< vector<long long> >Pa[20];
     vector< vector<long long> >Pb[20];

     for(i=0; i<20; i++)  Pa[i].clear(),Pb[i].clear();

     scanf("%d%d",&n,&k);

     for(i=0; i<n; i++)
     {
         a.clear();
         b.clear();
         a.PB(1);
         b.PB(1);

         scanf("%lld",&x);
         ya=pwr(55048,x);
         yb=pwr(44944,x);

         a.PB(ya);
         b.PB(yb);

         Pa[0].PB(a);
         Pb[0].PB(b);
     }

     p=0;l=n;
     while(l>1)
     {
         p++;
         for(i=0; i<l/2; i++)
         {
             a.clear();
             Pa[p].PB(a);
             multiply(Pa[p-1][2*i],Pa[p-1][2*i+1],Pa[p][i]);

             b.clear();
             Pb[p].PB(b);
             multiply(Pb[p-1][2*i],Pb[p-1][2*i+1],Pb[p][i]);
         }
         if(l%2)
         {
             Pa[p].PB(Pa[p-1][l-1]);
             Pb[p].PB(Pb[p-1][l-1]);
         }

         l=Pa[p].size();
     }


     long long ans=(Pa[p][0][k]-Pb[p][0][k]+mod)%mod;
     ans=(ans*inv)%mod;
     cout<<ans<<endl;

     return 0;
}
