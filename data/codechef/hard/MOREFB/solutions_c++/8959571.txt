#include <bits/stdc++.h>
 
using namespace std;
 
#define      pii               std::pair<int,int>
#define      vi                std::vector<int>
#define      mp(a,b)           std::make_pair(a,b)
#define      pb(a)             std::push_back(a)
#define      each(it,s)        for(auto it = s.begin(); it != s.end(); ++it)
#define      rep(i, n)         for(int i = 0; i < (n); ++i)
#define      fill(a)           memset(a, 0, sizeof (a))
#define      sortA(v)          sort(v.begin(), v.end())
#define      sortD(v)          sort(v.begin(), v.end(), greater<auto>())
#define      X                 first
#define      Y                 second
 
typedef long long LL;
LL MOD = 99991;
const LL root5 = 89887;
const LL a = 44944, b = 55048;	// fib(n) = a^n - b^n
const  long double PI = M_PI;
typedef pair<long double,long double> pt;
 
/*
	Declare the class simply like : FFT f;
	pt is real number, pt.first is real part and pt.second is imaginary part
	To get Fast Discrete FT of an vector<int>, vector<double> or vector<pt>, just call 
		f.DFT(vector<> v) which returns in turn a vector of same length but of type vector<pt>
	To get Inverse FFT call 
		f.InverseDFT(vector<pt>), it always takes pt type vectors and length should be perfect poer of 2
	To multiply two polynomials of int do:
		f.polynomialMul(vector<int>& a, vector<int>& b), resuslt is stored into a
*/
class FFT
{
public:
	typedef pair<long double,long double> pt;
	FFT(){Initialized = 0;}
	~FFT(){if(Initialized) free(Ar), free(tmp), free(omega);}
	// vector<pt> DFT(vector<pt>& v){
	// 	init(v.size(), 0);
	// 	for(int i = 0; i < (int)v.size(); ++i) Ar[i] = v[i];
	// 	fastFourierTransform(Ar, N);
	// 	return Return(v.size());
	// };
	// vector<pt> DFT(vector<double> & v){
	// 	init(v.size(), 0);
	// 	for(int i = 0; i < v.size(); ++i) Ar[i] = mp(v[i], 0);
	// 	fastFourierTransform(Ar, N);
	// 	return Return(v.size());
	// };
	vector<pt> DFT(vector<int> & v){
		init(v.size(), 0);
		for(int i = 0; i < v.size(); ++i) Ar[i] = mp(v[i], 0);
		for(int i = v.size(); i < N; ++i) Ar[i] = mp(0, 0); 
		fastFourierTransform(Ar, N);
		return Return(N);
	};
 
	/*vector<pt> InverseDFT(vector<pt>& v){
		init(v.size(), 1);
		for(int i = 0; i < v.size(); ++i) Ar[i] = v[i];
		fastFourierTransform(Ar, N);
		vector<pt> ret(Ar, Ar+v.size());
		rep(i, v.size()) ret[i].X /= N, ret[i].Y /= N;
		return ret;
	}*/
 
	void polynomialMul(vector<int>& a, vector<int>& b){
		int n = (int)a.size() + (int)b.size() - 1;
		a.resize(n);
		b.resize(n);
		vector<pt> aa = DFT(a); DFT(b);
		for(int i = 0; i < N; ++i){
			Ar[i] = mul(Ar[i], aa[i]);
		}
		flag = 1;
		fastFourierTransform(Ar, N);
		for(int i = 0; i < n; ++i){
			a[i] = ((LL)(Ar[i].X/N + 0.5)) % MOD;
		}
	}
 
private:
	
	bool Initialized;
	bool flag; // Flag = 0, means DFT. Flag = 1 means Inverse DFT
	pt * Ar, * tmp, tmp1;
	pt * omega;
	int N;
	inline pt mul(pt& a, pt& b){
		return mp(a.X * b.X - a.Y * b.Y, a.X * b.Y + a.Y * b.X);
	}
 
	inline vector<pt> Return(int n){
		vector<pt> ret(n);
		for(int i = 0; i < n; ++i) ret[i] = Ar[i];
		return ret;
	}
 
	void fastFourierTransform(pt * A, int n){
		if(n <= 1) return ;
		for(int i = 0; i < n; ++i) tmp[i] = A[i];
		for(int i = 0; i < n; i += 2){
			A[i>>1] = tmp[i];
			A[(i+n)>>1] = tmp[i+1];
		}
		fastFourierTransform(A, n/2);
		fastFourierTransform(A+n/2, n/2);
		if(flag) omega[n].Y *= -1;
		pt cur = mp(1, 0);
		for(int i = 0; i < n/2; ++i){
			tmp1 = mul(A[i+n/2], cur);
			tmp[i] = mp(A[i].X + tmp1.X, A[i].Y + tmp1.Y);
			tmp[i+n/2] = mp(A[i].X - tmp1.X, A[i].Y - tmp1.Y);
			cur = mul(cur, omega[n]);
		}
		for(int i = 0; i < n; ++i) A[i] = tmp[i];
		if(flag) omega[n].Y *= -1;
		return ;
	}
 
	inline void init(int n, bool f){ // f = 0, FFT, f = 1, Inverse FFT
		int tt = N;
		N = 1;
		while(N < n) N <<= 1;
		flag = f;
		if(Initialized && tt == N) return ;
		if(Initialized) free(Ar), free(tmp), free(omega);
		Ar = (pt *)calloc(N, sizeof (pt));
		tmp = (pt *)calloc(N, sizeof (pt));
		omega = (pt *)calloc(N+1, sizeof (pt));
		for(int i = 1; i <= N; i<<=1){
			omega[i] = mp(cos(2 * PI / i), sin(2 * PI / i));
		}
		if(!Initialized) Initialized = 1;
	}
 
};
pt mul(pt a, pt b){
	return mp(a.X * b.X - a.Y * b.Y, a.X * b.Y + a.Y * b.X);
}
 
LL pow_(LL a, LL b){
	LL ans = 1;
	while(b){
		if(b & 1) ans = ans * a % MOD;
		b >>= 1;
		a = a * a % MOD;
	}
	return ans;
}
 
pt evaluate(vector<int>& v, pt x){
	pt ans = mp(0, 0);
	pt cur = mp(1, 0);
 
	for(int i = 0; i < v.size(); ++i){
		pt tmp = mp(cur.X * v[i], cur.Y * v[i]);
		ans.X += tmp.X;
		ans.Y += tmp.Y;
		cur = mul(cur, x);
	}
	return ans;
}
int aa[60000];
 
FFT f;
vector<int> multiply(int ar[], int n){
	if(n == 1){
		vector<int> ret;
		ret.push_back(1);
		ret.push_back(ar[0]);
		return ret;
	}
	vector<int> a = multiply(ar, n/2);
	vector<int> b = multiply(ar+n/2, n-n/2);
 
	f.polynomialMul(a, b);
	b.clear();
	return a;
}
 
int main()
{
	int n, k;
	cin >> n >> k;
	vector<int> inp(n);
	rep(i, n) scanf("%d",&inp[i]);
	
	rep(i, n) aa[i] = pow_(a, inp[i]);
	int ans = multiply(aa, n)[k];
	rep(i, n) aa[i] = pow_(b, inp[i]);
	ans -= multiply(aa, n)[k];
	if(ans < 0) ans += MOD;
	ans = (LL)ans * pow_(root5, MOD-2) % MOD;
	printf("%d\n",ans);
 
	return 0;
}