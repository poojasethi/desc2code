#include <bits/stdc++.h>
using namespace std;

#define PB push_back
#define MP make_pair
#define SZ size()
#define all(v) v.begin(), v.end()
#define REP(i, n) for(int i = 0; i < (int)n; i++)
#define ITR(i, j, n) for(int i = j; i < (int)n; i++)
#define mem(array, val) memset(array, val, sizeof(array))
#define READ(filename) freopen(filename, "r", stdin)
#define WRITE(filename) freopen(filename, "w", stdout)
#define Pii pair <int, int>
#define Fr first
#define Sc second
#define Long long long
#define si(a) scanf("%d", &a)
#define sl(a) scanf("%I64d", &a)
#define sd(a) scanf("%lf", &a)
#define sii(a, b) scanf("%d%d", &a, &b)
#define sll(a, b) scanf("%I64d%I64d", &a, &b)
#define sdd(a, b) scanf("%lf%lf", &a, &b)
#define Fast_IO ios_base::sync_with_stdio(0);cin.tie(0)


// MAX should be >= maximum power of polynomial to be multiplied * 2 and a power of 2
#define MAX (1 << 17)
int mod = 99991;
int val[50005];
Long arrays[18][MAX];
Long Val[50005];

// MAX should be >= maximum power of polynomial to be multiplied * 2 and a power of 2
#define MAX (1 << 17)
int rev[MAX], mlgn;
double omega[MAX][2];
double FA[MAX][2], FB[MAX][2];

inline void mult(double A[2], double B[2], double C[2])
{
   C[0] = A[0]*B[0] - A[1]*B[1];
   C[1] = A[0]*B[1] + A[1]*B[0];
}

void calc_rev(int n = MAX)
{
   while((1 << mlgn) < n) mlgn++;
   int lvl = 1, mx = (1<<mlgn);
   while(lvl < mx) {
      int j = 0, sg = 0;
      for(int i = 0; i < mx; i++) {
         rev[i] = (rev[i]<<1) | sg;
         j++;
         if(j == lvl) j = 0, sg ^= 1;
      }
      lvl <<= 1;
   }
}

void fft(double X[MAX][2], int n, bool invert)
{
   int lgn = 0;
   while((1 << lgn) != n) lgn++;
   REP(i, n) if(i < rev[i << (mlgn - lgn)])
      swap(X[i][0], X[rev[i << (mlgn - lgn)]][0]),
      swap(X[i][1], X[rev[i << (mlgn - lgn)]][1]);

   double ang = (2.0*M_PI/n) * (invert ? -1.0:1.0);
   REP(i, n) omega[i][0] = cos(ang * i), omega[i][1] = sin(ang * i);
   for(int len = 2; len <= n; len <<= 1) {
      int fact = n / len;
      int len2 = len>>1;

      for(int i = 0; i < n; i += len) REP(j, len2) {
         double u[2], v[2];
         u[0] = X[i+j][0], u[1] = X[i+j][1];
         mult(X[i+j+len2], omega[j * fact], v);
         X[i+j][0] = u[0]+v[0], X[i+j][1] = u[1]+v[1];
         X[i+j+len2][0] = u[0]-v[0], X[i+j+len2][1] = u[1]-v[1];
      }
   }

   if(invert) REP(i, n)
      X[i][0] /= n, X[i][1] /= n;
}

int multiply(Long A[MAX], Long B[MAX], int n1, int n2, Long ret[MAX])
{
   REP(i, n1) FA[i][0] = (double)A[i], FA[i][1] = 0.0;
   REP(i, n2) FB[i][0] = (double)B[i], FB[i][1] = 0.0;
   int n = 1;
   while(n < max(n1, n2)) n <<= 1;
   n <<= 1;
   ITR(i, n1, n) FA[i][0] = FA[i][1] = 0.0;
   ITR(i, n2, n) FB[i][0] = FB[i][1] = 0.0;

   fft(FA, n, false);
   fft(FB, n, false);
   double tmp[2];
   REP(i, n) {
      mult(FA[i], FB[i], tmp);
      FA[i][0] = tmp[0], FA[i][1] = tmp[1];
   }
   fft(FA, n, true);
   REP(i, n) ret[i] = (Long)(FA[i][0] + 0.5), ret[i] %= mod;
   // should do a mod here if there is a modulo
   return n;
}

int solve(int id, int l, int r)
{
   if(l == r) {
      arrays[id][0] = Val[l];
      arrays[id][1] = 1;
      return 2;
   }
   int mid = (l + r) / 2;
   int n1 = solve(id, l, mid);
   int n2 = solve(id+1, mid+1, r);
   return multiply(arrays[id], arrays[id+1], n1, n2, arrays[id]);
}

Long bigmod(Long x, Long pow)
{
   Long ret = 1;
   while(pow > 0) {
      if(pow & 1) ret = (ret * x) % mod;
      x = (x * x) % mod;
      pow /= 2;
   }
   return ret;
}

int main()
{
   int N, K;
   sii(N, K);
   REP(i, N) si(val[i]);
   Long root5 = bigmod(5, (mod + 1) / 4), ans = 0;
   Long a = ((1 + root5) * bigmod(2, mod-2)) % mod;
   Long b = ((1 - root5 + mod) * bigmod(2, mod-2)) % mod;
   Long c = bigmod(root5, mod-2);

   calc_rev();
   REP(i, N) Val[i] = bigmod(a, val[i]);
   solve(1, 0, N-1);
   ans = arrays[1][N-K];
   REP(i, N) Val[i] = bigmod(b, val[i]);
   solve(1, 0, N-1);
   ans = (ans - arrays[1][N-K] + mod) % mod;
   ans = (c * ans) % mod;
   printf("%lld\n", ans);

   return 0;
}
