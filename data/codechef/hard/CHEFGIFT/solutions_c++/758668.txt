// birthday gift 
#include<stdio.h>
#include<queue>
#include"assert.h"
#define Max 102
#define MaxCost 10000000
using namespace std;
int D, n, m;
int cost[Max][Max];
bool visited[Max][Max];
int toll[Max][Max];
int inter[Max][Max];

class node{
      public:
      int route;
      int segment;
	  int cost;
      node(int r, int s,int c){
               route = r;
               segment = s;
			   cost=c;
      }
};
bool operator<(const node& left, const node& right){
	if(left.cost==right.cost)return (left.route!=right.route)?(left.route<right.route):(left.segment<right.segment);
     return (left.cost>right.cost);
}

int findMin();

int main(){
    int T;
    scanf("%d",&T);
    while(T--){
               //cout<<"dnm"<<endl;
               scanf("%d %d %d",&D,&n,&m);
               assert(n<Max&&m<Max);
               //cout<<"toll"<<endl;
               for(int i=0;i<Max;i++)for(int j =0;j<Max;j++){cost[i][j] = MaxCost; visited[i][j] = false;}
               for(int i=0;i<m;i++)for(int j=0;j<n;j++){scanf("%d",&toll[i][j]);}
               //cout<<"inter"<<endl;
               for(int i=0;i<m;i++)for(int j=0;j<m;j++){scanf("%d",&inter[i][j]);}
               int result=findMin();          
			   assert(result>=0);
               if(D-result < 0)printf("-1\n");
               else printf("%d\n",D-result);
    }
    return 0;
}
     
int findMin(){
    priority_queue<node> q;
    for(int i=0;i<m;i++){
            q.push(node(i,0,0));
			cost[i][0] = 0;
    }
    while(!q.empty()){
                      int r,s;
                      r = q.top().route;
                      s = q.top().segment;
                      q.pop();
                      if(visited[r][s]==true) continue;
                      //cout<<"route : "<<r<<" segment: "<<s<<endl;
                      //cout<<"cost: "<<cost[r][s]<<endl;
                      visited[r][s] = true;
                      if(s==n)return cost[r][s];
                      int i, j;
                      for(i=0;i<m;i++){
							  if(visited[i][s]==true)continue;
							  if(cost[i][s]>cost[r][s]+inter[r][i])
									 q.push(node(i,s,cost[i][s]=cost[r][s]+inter[r][i]));
                      }
					  if(cost[r][s+1]>cost[r][s] + toll[r][s])
												q.push(node(r,s+1,cost[r][s+1]=cost[r][s] + toll[r][s]));
    }
    return -1;
}
