#include<iostream>
#include<algorithm>
#include<cmath>
#include<climits>
#include<vector>
#include<list>
#include<stack>
#include<queue>
#include<deque>
#include<bitset>
#include<set>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<map>
#include<functional>
#include<numeric>
#include<utility>
#include<sstream>
#include<iomanip>
#include<cctype>
using namespace std;

#define assert(f) {if(!(f)){fprintf(stderr,Line-- Assertion failed: %sn,__LINE__,#f);exit(1);}}
#define ABS(x)   ((x)<0?-(x):(x))
#define SQR(x) 	 ((x)*(x))
#define CUBE(x)  ((x)*(x)*(x))
#define pnl      printf(n)
#define REP(i,n)        for(__typeof(n) i=0;i<(n);i++)
#define FOR(i,a,b)      for(__typeof(b) i=(a);i<(b);++i)
#define FORE(i,a,b)     for(__typeof(b) i=(a);i<=(b);++i)
#define FORD(i,a,b,d)   for(__typeof(b) i=(a);i<(b);i+=(d))
#define FORR(i,n,e)     for(__typeof(n) i=(n);i>=(e);--i)
#define FORRD(i,n,e,d)  for(__typeof(n) i=(n);i>=(e);i-=(d))
#define REP_IT(it,m)    for(it=m.begin();it!=m.end();it++)
#define FOREACH(it,s) 	for(__typeof((s).begin()) (it)=(s).begin();(it)!=(s).end();(it)++)
#define UNIQUE(v)       sort(ALL(v)),v.erase(unique(ALL(v)),v.end())
#define FILL(a,b)       memset(a,b,sizeof(a))
#define ALL(v)          (v).begin(), (v).end()
#define RALL(v)         (v).rbegin(), (v).rend()
#define checkbit(n,b)   (((n)>>(b))&1)
#define PB push_back
#define MP make_pair
#define XX first
#define YY second
#define EPS 1e-5
#define MAXK 505
#define MOD 1000000007
typedef long long LL;
typedef unsigned long long ULL;
double start;				//time
template<typename T>inline T mod(T N,T M)
{	return (N%M+M)%M;	}

//#define tukku26
#ifdef tukku26
	#define SD(x) scanf(%d,&x);
#else
	#define SD(x) inp(x)
	#define getcx getchar_unlocked
	template<typename T>
	// generic i/p for int / long long int / unsigned long long / etc.
	inline void inp( T &n )
	{	n=0;
		int ch=getcx();
		int sign=1;
		while(ch<'0'||ch>'9')
		{	if(ch=='-')
				sign=-1;
			ch=getcx();
		}
		while(ch>='0'&&ch<='9')
		{	n=(n<<3)+(n<<1)+ch-'0';
			ch=getcx();		// n= n*10 = n*(8+2) - n<<3 + n<<2 => optimization
		}
		n *= sign;			// n = -n => bitwise
	}
#endif

namespace Num
{	
}

using namespace Num;

void pre()
{	
}

bool eval ( int *ak, int *ap, int n,int k, int p )
{	for ( int i=2; i<n; i++ )
	{	if ( ak[i] == ak[i-1] && ap[i] != ap[i-1] )
			return 0;
	}
	return 1;
}

void solve ( int &T )
{	int n, k, p, ctr, x, y, q;
	map<int,bool> ak;
	map<int,bool> ap;
	map<int,bool>::iterator it;
	FOR(i,0,T)
	{	ak.clear();
		ap.clear();
		inp(n);
		inp(k);
		inp(p);
		//cin>>n>>k>>p;
		ctr=0;
		FOR(j,0,k)
		{	inp(x);
			inp(y);
			//cin>>x>>y;
			ak[y]=1;
			ctr++;
		}
		ctr=0;
		FOR(j,0,p)
		{	inp(x);
			inp(y);
			//cin>>x>>y;
			ap[y]=1;			// means breakage at y. y and y+1th segment not linked. Error only when x is linked originally and the boy breaks at that point. If break at original and no break by boy then the break can be created by chef and hence no problem
			ctr++;
		}
		for ( it=ap.begin(); it != ap.end(); it++ )
			if ( ak.count(it->first) == 0 && ap[it->first] == 1 )
				break;
		if ( it != ap.end() )
			printf("No\n");//cout<<"No"<<endl;
		else
			printf("Yes\n");//cout<<"Yes"<<endl;
	}
}

int main()
{	pre();
	int t;
	inp(t);
	solve(t);
	return 0;
}
