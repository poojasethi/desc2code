/*
 * Author:  Eyelids
 * Created Time:  2014/10/19 19:02:23
 * File Name: C.cpp
 */
#include<iostream>
#include<sstream>
#include<fstream>
#include<vector>
#include<list>
#include<deque>
#include<queue>
#include<stack>
#include<map>
#include<set>
#include<bitset>
#include<algorithm>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cctype>
#include<cmath>
#include<ctime>
using namespace std;
const double eps(1e-8);
typedef long long lint;
#define clr(x) memset( x , 0 , sizeof(x) )
#define sz(v) ((int)(v).size())
#define rep(i, n) for (int i = 0; i < (n); ++i)
#define repf(i, a, b) for (int i = (a); i <= (b); ++i)
#define repd(i, a, b) for (int i = (a); i >= (b); --i)
#define clrs( x , y ) memset( x , y , sizeof(x) )
#define x first
#define y second
int T;
int n, m, s;
char grid[110][110], g[110][110];
int num[110][110];
vector < pair<int, int> > p;

int main(){
    scanf( "%d", &T );
    while ( T -- ) {
        scanf( "%d%d", &n, &m  );
        p.clear();
        memset( num, -1, sizeof(num) );
        for ( int i = 0; i < n; i ++ ) {
            scanf( "%s", grid[i] );
            for ( int j = 0; j < m; j ++ ) {
                if ( grid[i][j] == 'L' ) {
                    p.push_back( make_pair( i, j ) );
                }
            }
        }

        s = p.size();
        bool possible = false;
        for ( int i = 0; i < (1 << s); i ++ ) {
            memcpy( g, grid, sizeof(grid) );
            for ( int j = 0; j < s; j ++ ) {
                if ( (i >> j) & 1 ) {
                    g[p[j].x][p[j].y] = '.';
                    for ( int a = 0; a < p[j].x; a ++ ) {
                        if ( g[a][p[j].y] == 'E' ) g[a][p[j].y] = '.'; 
                    }
                }
            }
            /*for ( int a = 0; a < n; a ++ ) {
                for ( int b = 0; b < m; b ++ ) cout <<g[a][b];
                cout <<endl;
            }*/
            bool flag = true;
            for ( int a = 0; a < n; a ++ ) {
                int num = 0, l = m, r = 0, pos;
                for ( int b = 0; b < m; b ++ ) if ( g[a][b] == 'L' ) {
                    num ++; 
                    pos = b;
                } else if ( g[a][b] == 'E' ) {
                    l = min( l, b );
                    r = max( r, b );
                }
                if ( num == 0 && l <= r ) {
                    flag = false;
                    break;
                }
                if ( num == 1 && l <= r && l <= pos && pos <= r ) {
                    flag = false;
                    break;
                }
            }

            if ( flag ) {
                possible = true;
                break; 
            }
        }

        cout <<(( possible ) ? "Possible" : "Impossible")<<endl;
    }
    
    return 0;
}










