#pragma comment(linker,"/STACK:102400000,102400000") 
#include<stdio.h>
#include<iostream>
#include<string.h>
#include<queue>
#include<algorithm>
#include<string>
#include<map>
#include<set>
#include<fstream>
#include<math.h>
#include<iomanip>
#include<time.h>
#include<assert.h>
using namespace std;
#define ll long long
#define ull unsigned long long
#define db double
#define inf 1000000007
#define mod 1000000007
#define pii pair<int,int>
#define vi vector<int>
#define VS vector<string>
#define all(x) x.begin(),x.end()
#define mp make_pair
#define pb push_back
#define x first
#define y second
#define N 10050
#define pi 3.14159265358979323846
#define DBG(vari) cerr<<#vari<<"="<<(vari)<<endl;
#define FOREACH(i,t) for(__typeof(t.begin()) i=t.begin();i!=t.end();i++)

char s[55][55];int n,m;
bool dfs(int r,vi c)
{
	if(r==-1)return 1;
	bool good=1;
	for(int i=0;i<m;i++)good&=c[i];
	if(good)return 1;
	vi q,p;
	for(int i=0;i<m;i++)
	if(s[r][i]=='E'&&c[i]==0)q.pb(i);
	else if(s[r][i]=='L')p.pb(i);
	if(q.size()==0)
	{
		for(int i=0;i<p.size();i++)c[p[i]]=1;
		return dfs(r-1,c);
	}
	if(p.size()==0)return 0;
	if(p.size()==1)
	{
		if(q.size()==1)return dfs(r-1,c);
		if(p[0]>q[0]&&p[0]<q[q.size()-1])return 0;
		return dfs(r-1,c);
	}
	for(int i=0;i<p.size();i++)
	for(int j=i+1;j<p.size();j++)
	{
		vi cc=c;
		for(int k=0;k<p.size();k++)
		if(k!=i&&k!=j)cc[p[k]]=1;
		if(dfs(r-1,cc))return 1;
	}
	for(int i=0;i<p.size();i++)
	{
		if(p[i]>q[0])break;
		vi cc=c;
		for(int k=0;k<p.size();k++)
		if(k!=i)cc[p[k]]=1;
		if(dfs(r-1,cc))return 1;
	}
	for(int i=p.size()-1;i>=0;i--)
	{
		if(p[i]<q[q.size()-1])break;
		vi cc=c;
		for(int k=0;k<p.size();k++)
		if(k!=i)cc[p[k]]=1;
		if(dfs(r-1,cc))return 1;
	}
	return 0;
}
int main()
{
	int T,k,i,j,ca=0;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d",&n,&m);
		for(i=0;i<n;i++)
		{
			scanf("%s",s[i]);
		}
		vi c(m,0);
		if(dfs(n-1,c))puts("Possible");
		else puts("Impossible");
	}
    return 0;
}