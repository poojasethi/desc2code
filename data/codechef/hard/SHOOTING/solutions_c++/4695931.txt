#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
#include <string.h>
using namespace std;

string grid[50];
int lasersTo[50][50];
int lasersX[50];
int can[51][1 << 16];

int main()
{
    cin.sync_with_stdio(0);
    cout.setf(ios::floatfield, ios::fixed);
    cout.precision(8);

    int t;
    cin >> t;
    while (t--)
    {
        memset(lasersX, 0, sizeof(lasersX));
        memset(lasersTo, 0, sizeof(lasersTo));
        memset(can, 0, sizeof(can));

        int n, m;
        cin >> n >> m;

        for (int i = 0; i < n; ++i)
        {
            cin >> grid[n - 1 - i];
        }

        vector< pair<int, int> > lasers;
        for (int i = 0; i < n; ++i)
        {
            for (int j = 0; j < m; ++j)
            {
                if (grid[i][j] == 'L')
                {
                    lasersX[j] |= 1 << (lasers.size());
                    lasers.push_back(make_pair(i, j));
                }
                else if (grid[i][j] == 'E')
                {
                    lasersTo[i][j] = lasersX[j];
                }
            }
        }

        int laserPos = 0;
        can[0][0] = 1;
        for (int i = 0; i < n; ++i)
        {
            vector< int > curLasers;
            int curMask = 0;
            for (int j = 0; j < lasers.size(); ++j)
            {
                if (lasers[j].first == i)
                {
                    curLasers.push_back(j);
                    curMask |= 1 << j;
                }
            }

            for (int k = 0; k < (1 << lasers.size()); ++k)
            {
                if (can[i][k])
                {

                    int leftMost = m, rightMost = 0;
                    for (int j = 0; j < m; ++j)
                    {
                        if (grid[i][j] == 'E')
                        {
                            if (!(k & (lasersTo[i][j])))
                            {
                                if (leftMost == m) leftMost = j;
                                rightMost = j;
                            }
                        }
                    }

                    if (!rightMost)
                    { // No enemy
                        can[i + 1][curMask | k] = 1;
                    }
                    else
                    { // Has enemy
                        for (int l = 0; l < curLasers.size(); ++l)
                        {
                            int laserId = curLasers[l];
                            if (lasers[laserId].second < leftMost)
                            {
                                can[i + 1][(curMask | k) ^ (1 << laserId)] = 1;
                            }
                        }

                        for (int l = curLasers.size() - 1; l >= 0; --l)
                        {
                            int laserId = curLasers[l];
                            if (lasers[laserId].second > rightMost)
                            {
                                can[i + 1][(curMask | k) ^ (1 << laserId)] = 1;
                            }
                        }

                        for (int l1 = 0; l1 < curLasers.size(); ++l1)
                        {
                            for (int l2 = 0; l2 < l1; ++l2)
                            {
                                can[i + 1][(curMask | k) ^ (1 << curLasers[l1]) ^ (1 << curLasers[l2])] = 1;
                            }
                        }
                    }
                }
            }
        }

        bool possible = false;
        for (int i = 0; i < (1 << lasers.size()); ++i)
        {
            possible |= can[n][i];
        }

        cout << (possible ? "Possible" : "Impossible") << endl;
    }

    return 0;
}
