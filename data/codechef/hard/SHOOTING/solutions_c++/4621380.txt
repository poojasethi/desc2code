#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <map>
#include <cstring>
#include <queue>
#include <deque>
using namespace std;

typedef pair<int,int> PII;
typedef vector<int> VI;
typedef vector<VI> VVI;

char mat[64][64];
int LEFT[20],RIGHT[20];
int CL[20],CR[20];
int ERC[64] , ERCC[64];
vector<int> UE[64];
int N,M;
bool check(int mask,vector<PII> LL){
	memcpy(CL,LEFT,sizeof(LEFT));
	memcpy(CR,RIGHT,sizeof(RIGHT));
	memcpy(ERCC,ERC,sizeof(ERC));
	vector<int> IGN(LL.size());
	for(int i = 0; i < LL.size(); ++i)
		if((1<<i) & mask)
			for(int j = i+1; j < LL.size(); ++j)
				if(((1<<j) & mask) && LL[i].second == LL[j].second)
					IGN[i] = 1;
					
	for(int i = 0; i < LL.size(); ++i){
		if(IGN[i])continue;
		if((1<<i) & mask){
			for(int j = 0; j < i; ++j){
				if( ((1<<j) & mask) == 0 && LL[i].first > LL[j].first){
					if(mat[LL[j].first][LL[i].second] == 'E') {
						(LL[i].second < LL[j].second ? CL[j] : CR[j])--;
					}
				}
			}
			for(int j = 0; j < UE[i].size(); ++j){
				ERCC[UE[i][j]]--;
			}
		}
	}
	vector< vector<int> > RC(N);
	for(int i = 0; i < LL.size(); ++i){
		if(((1<<i) & mask) == 0)
			RC[LL[i].first].push_back(i);
	}
	for(int i = 0; i < N; ++i){
		if(ERCC[i] > 0){
			if(RC[i].size() == 0)
				 return false;
			if(RC[i].size() == 1){
				int l = RC[i][0];
				if(CL[l] != 0 && CR[l] != 0){
					return false;
				}
			}
		}
	}
	return true;
}
/*
1
6 6
.E..E.
....E.
.L..E.
...EL.
.LE...
..LEL.

 */
int main()
{
	int TC;
	cin >> TC;
	while(TC-->0)
	{
		for(int i = 0; i < 64; ++i)
			UE[i].clear(), ERC[i] =0;
		for(int i = 0; i < 20; ++i)
			LEFT[i] = 0 , RIGHT[i] = 0;
		scanf("%d%d",&N,&M);
		int L = 0;
		vector<PII> LL;
		for(int i = 0; i < N; ++i){
			scanf("%s",mat[i]);
			for (int j = 0; j < M; ++j) {
				if(mat[i][j] == 'L'){
					L++;
					LL.push_back(PII(i,j));
				}
			}
		}
		sort(LL.begin(),LL.end());
		bool imP = 0;
		for(int i = 0; i < N && !imP; ++i)
			for (int j = 0; j < M && !imP; ++j){
				if(mat[i][j] != 'E')continue;
				ERC[i]++;
				bool f = 0;
				for(int k = 0; k < L; ++k){
					if(i < LL[k].first && j == LL[k].second){
						f = 1;
						UE[k].push_back(i);
					}
					if(i == LL[k].first) {
						f = 1;
						(j < LL[k].second ? LEFT[k] : RIGHT[k])++;
					}
				}
				if(!f)
					imP = 1;
			}
		
		int isP = 0;
		if(!imP){
			for(int i = 0; i < (1<<L) && !isP; ++i){
				if(check(i,LL)){
					isP = 1;
				}
			}
		}
		cout << (isP ? "Possible" : "Impossible") << endl;
	}
	
}

/*

      1
  3       4
       2  5  6
               7
 */


