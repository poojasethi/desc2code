#include <cstdio>
#include <cmath>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <map>
#include <queue>
#include <set>
#include <cassert>

using namespace std;

#define _ ios_base::sync_with_stdio(0);cin.tie(0);
#define S(x) 			scanf("%d",&x)
#define all(c) 			(c).begin(),(c).end() 
#define sz(c) 			int((c).size())
#define pb 				push_back
#define present(c,x) 	((c).find(x) != (c).end()) 
#define cpresent(c,x) 	(find(all(c),x) != (c).end())
#define rep(i,x,y) 		for(int i = x; i < y; i++)
#define REV(i,x,y) 		for(int i = x; i >= y; i--)
#define foreach(c,itr)	for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)
#define FILL(a,v) 		memset(a,v,sizeof(a))
#define debug(args...)	{dbg,args; cerr<<endl;}
#define F first
#define SS second 

typedef long long int LL;
typedef vector<int> vi; 
typedef vector<vi> vvi; 
typedef pair<int,int> ii;
typedef vector<ii> vii;

struct _debugger
{
	template<typename T> _debugger& operator , (const T& v)
	{	
		cerr<<v<<" ";
		return *this;
	}
} dbg;
 
void debugarr(int * arr,int n)
{
	cout<<"[";
	for(int i=0;i<n;i++) cout<<arr[i]<<" ";
	cout<<"]"<<endl;
}

/* ------------------------Main Code----------------------- */
const int MAX = 100001;

int RE[55], RL[55], el[55][55], er[55][55];
int u[55][55];
vii lasers;
char mark[55][55], s[51][51];

void rebuild(int id, int cnt)
{
	rep(i,0,cnt) if(id & (1<<i)){
		//if(id == 1027) printf("element = %d\n",i);
		REV(j,lasers[i].F-1,0) if(s[j][lasers[i].SS] == 'E'){
			mark[j][lasers[i].SS] = 'E';
			//if(id == 1027) printf("element = %d row = %d\n",i,j);
		}
		mark[lasers[i].F][lasers[i].SS] = 'L';
	}
}
int main()
{
	int t;
	S(t);
	while(t--){
		int n, m, enemy=0;
		S(n); S(m);
		rep(i,0,n){
			getchar();
			rep(j,0,m) s[i][j] = getchar();
		}
		FILL(RE,0); FILL(RL,0); FILL(u,0);
		lasers.clear();
		rep(i,0,n){
			rep(j,0,m){
				if(s[i][j] == 'L'){
					RL[i]++;
					lasers.pb(ii(i,j));
					//REV(k,j-1,0) if(s[i][k] == 'E'){el[i][j] = 1; break;}
					//rep(k,j+1,m) if(s[i][k] == 'E'){er[i][j] = 1; break;}
				}
				if(s[i][j] == 'E'){
					enemy++;
					RE[i]++;
				} 
				mark[i][j] = s[i][j];
			}
		}
		int cnt = sz(lasers), vis[51], it = 0;
		//rep(i,0,cnt) printf("%d %d\n",lasers[i].F,lasers[i].SS);
		bool okay = false;
		rep(id,0,1<<cnt){
			int re[55], rl[55];
			rep(i,0,n){
				re[i] = RE[i];
				rl[i] = RL[i];
			}
			int tmp = enemy;it++;
			bool fb = false;
			rep(i,0,n) vis[i] = 0;
			rep(i,0,cnt) if(id & (1<<i)){
				//if(id == 1027) printf("element = %d\n",i);
				bool fk = false;
				REV(j,lasers[i].F-1,0){
					if(u[j][lasers[i].SS] == it){
						fb = true;
						break;
					} 
					if(mark[j][lasers[i].SS] == 'E'){
						mark[j][lasers[i].SS] = '.';
						re[j]--;
						tmp--;
						fk = true;
					}
					u[j][lasers[i].SS] = it;
					//if(id == 1027) printf("element = %d row = %d\n",i,j);
				}
				mark[lasers[i].F][lasers[i].SS] = '.';
				rl[lasers[i].F]--;
				fb |= !fk;
				if (fb) break;

			}
			if(fb){rebuild(id,cnt); continue;}
			rep(i,0,cnt){
				if(!(id&(1<<i)) && !vis[lasers[i].F]){
					//if(id == 0) printf("element = %d\n",i);
					//if(id == 0) debug(ct);
					if(rl[lasers[i].F] > 1) tmp -= re[lasers[i].F];
					if(rl[lasers[i].F] == 1){
						int f1 = 0, f2 = 0;
						//if(id == 0) debug(f1,f2);
						REV(k,lasers[i].SS-1,0) if(mark[lasers[i].F][k] == 'E'){f2 = 1; break;}
						rep(k,lasers[i].SS+1,m) if(mark[lasers[i].F][k] == 'E'){f1 = 1; break;}
						if(f2^f1){
							tmp -= re[lasers[i].F];
						}
					}
					vis[lasers[i].F] = 1;
				}
			}
			rebuild(id,cnt);
			//if(id == 0) debug(tmp);
			if(tmp == 0){
				// debug(id,cnt);
				// rep(i,0,n){
				// 	rep(j,0,m) printf("%c",mark[i][j]);
				// 	printf("\n");
				// }
				// rep(i,0,cnt){
				// 	if((id&(1<<i))) printf("1\n");
				// 	else printf("0\n");
				// }
				okay = true;
				break;
			}	
		}
		if(enemy == 0) okay = true;
		printf(okay ? "Possible\n" : "Impossible\n");
	}
	return 0;
}