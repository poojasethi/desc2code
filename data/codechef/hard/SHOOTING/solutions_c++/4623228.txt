#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0);cin.tie(0);
 
using namespace std;
 
 
#define ll long long
#define ff first
#define ss second
#define mpa make_pair
#define MOD 1000000007
#define pb push_back
#define lld I64d
#define MXN 1000000
 
int bitcnt(int mask){return __builtin_popcount(mask);}
int SET(int N,int pos){	return N=N | (1<<pos);}
int RESET(int N,int pos){	return N= N & ~(1<<pos);}
int check(int N,int pos){	return (N & (1<<pos));}
int toggle(int N,int pos){if(check(N,pos))return N=RESET(N,pos);return N=SET(N,pos);}
void PRINTBIT(int N){	printf("("); for(int i=6;i>=1;i--)	{bool x=check(N,i);cout<<x;}	puts(")");}
int mod(int a, int b) { return a - a/b * b;}
 
int N;
int M;
char gra[100][100];
 
void inp()
{
	scanf("%d%d", &N, &M);
	for(int i = 0; i < N; ++i) {
		scanf("%s", &gra[i]);
	}
} 

void solve()
{
	vector<pair<int, int> >laser;
	
	for(int i = 0; i < N; ++i) {
		for(int j = 0; j < M; ++j) {
			if(gra[i][j] == 'L') {
				laser.pb(mpa(i, j));
			}
		}
	}

	bool flg = false;
	int size = 1 << laser.size();
	int size1 = laser.size();
	for(int mask = 0; mask < size; ++mask) {
		bool matrix[N][M];
		bool ye_h[N][M];
		memset(matrix, false, sizeof matrix);
		memset(ye_h, false, sizeof ye_h);
		
		for(int j = 0; j < size1; ++j) {
			if(mask&(1 << j)) {
				matrix[laser[j].ff][laser[j].ss] = true;
				ye_h[laser[j].ff][laser[j].ss] = true;
			}
		}
		
		bool ok = true;
		for(int i = N - 1; i >= 0; --i) {
			int min_pos = 1e9;
			int max_pos = -1e9;
			int min_pos_laser = 1e9;
			int max_pos_laser = -1e9;
			int cnt = 0;
			int ecnt = 0;
			for(int j = 0; j < M; ++j) {
				if(i + 1 < N && matrix[i + 1][j] == true) {
					matrix[i][j] = true;
				}
				
				if(gra[i][j] == 'E' && matrix[i][j] == false) {
					min_pos = min(min_pos, j);
					max_pos = max(max_pos, j);
					ecnt++;
				}
				
				if(gra[i][j] == 'L' && !ye_h[i][j]) {
					min_pos_laser = min(min_pos_laser, j);
					max_pos_laser = max(max_pos_laser, j);
					cnt++;
				}
			}
			
			if(cnt >= 2)
				continue;
			if(ecnt == 0)
				continue;
			
			if(min_pos > min_pos_laser || max_pos < max_pos_laser)
				continue;
			
			ok = false;
			break;
		}
		
		if(ok) {
			flg = true;
			break;
		}
	}
	
	if(flg) {
		puts("Possible");
	} else {
		puts("Impossible");
	}
}
 
int main()
{
	int T;
	scanf("%d", &T);
	
	while(T--) {
		inp();
		solve();
	}
	
	return 0;
}
 