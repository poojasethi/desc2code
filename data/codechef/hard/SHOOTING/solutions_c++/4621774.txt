#include <bits/stdc++.h>
using namespace std;

//Uzumaki Naruto :)
#define TRACE

#ifdef TRACE
#define trace(a,n)   for(int i = 0; i < n; ++i) cerr << a[i] << " ";cerr << endl;
#define dbg(args...) {debug,args; cerr<<endl;}
#define pause()      cin.get();cin.get();

#else
#define trace(a,n)
#define dbg(args...)
#define pause()

#endif

struct debugger {
    template<typename T> debugger& operator , (const T& v) {
        cerr<<v<<" "; return *this;
    }
} debug;

template <typename T1, typename T2>
inline ostream& operator << (ostream& os, const pair<T1, T2>& p) {
    return os << "(" << p.first << ", " << p.second << ")";
}

template<typename T>
inline ostream &operator << (ostream & os,const vector<T>& v) {
    bool first = true; os << "[";
    for (typename vector<T>::const_iterator ii = v.begin(); ii != v.end(); ++ii) {
        if(!first) os << ", ";
        os << *ii; first = false;
    }
    return os << "]";
}

template <typename T>
inline void fi(T *a)
{
    register char c=0;
    while (c<33) c=getchar_unlocked();
    *a=0;
    int tmp = 0;
    while (c>33)
    {
        if ( c == 45 ) tmp = 1;
        else *a=*a*10+c-'0';
        c=getchar_unlocked();
    }
    if ( tmp == 1 ) *a = 0-(*a);
}

typedef long long LL;
typedef pair<int,int> pii;
typedef vector<int> vi;

const int NN = 52;
const int inf = 1123456;

char g[NN][NN];
int pos[NN][2],perm[NN*NN][2], enemy[NN][2];
int en[NN],st[NN],cnt,temp;

bool check(int mask,int n,int m){
    int tot = 0;
    memset(en,-1,sizeof(en));
    memset(st,-1,sizeof(st));
    memset(enemy,-1,sizeof(enemy));

    for(int i = 0; i < cnt; ++i){
        if ((mask >> i) & 1)
            en[pos[i][1]] = max(en[pos[i][1]],pos[i][0]);
        else if (st[pos[i][0]] == -1)
            st[pos[i][0]] = pos[i][1];
        else
            st[pos[i][0]] = inf;
    }

    for(int i = 0; i < temp; ++i){
        if (perm[i][0] > en[perm[i][1]]){
            if (enemy[perm[i][0]][0] == -1)
                enemy[perm[i][0]][0] = perm[i][1];
            enemy[perm[i][0]][1] = max(enemy[perm[i][0]][1],perm[i][1]);
        }
    }

    for(int i = 0; i < n; ++i){
        if (enemy[i][0] == -1) continue;
        if (st[i] == -1) return false;
        if (st[i] == inf) continue;
        if (enemy[i][1] <= st[i]) continue;
        if (enemy[i][0] >= st[i]) continue;
        return false;
    }
    return true;
}

void solve(){
    int n,m;
    fi(&n);fi(&m);
    for(int i = 0; i < n; ++i)
        scanf("%s",g[i]);
    cnt = temp = 0;
    for(int i = 0; i < n; ++i){
        for(int j = 0; j < m; ++j){
            if (g[i][j] == 'L')
                pos[cnt][0] = i, pos[cnt++][1] = j;
            else if (g[i][j] == 'E')
                perm[temp][0] = i, perm[temp++][1] = j;
        }
    }

    for(int i = 0; i < (1 << cnt); ++i) if (check(i,n,m)){
        puts("Possible");
        return;
    }
    puts("Impossible");
}

int main()
{
    int t; fi(&t);
    while(t--) solve();
    return 0;
}
