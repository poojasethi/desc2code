#ifdef _WIN32
#  define LL "%I64d"
#else
#  define LL "%Ld"
#endif
 
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <ctime>
#include <vector>
#include <deque>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <bitset>
#include <string>
#include <algorithm>
#include <complex>
#include <utility>
using namespace std;
#define null NULL
#define mp make_pair
#define pb(a) push_back(a)
#define sz(a) ((int)(a).size())
#define all(a) a.begin() , a.end()
#define fi first
#define se second
#define relaxMin(a , b) (a) = min((a),(b))
#define relaxMax(a , b) (a) = max((a),(b))
#define SQR(a) ((a)*(a))
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef long long ll;
#define MOD 1000000007LL
void add_to(ll& w , ll how){
  w += how;
  if(w >= MOD)
   w -= MOD;
}
ll fact[2010];
// helpers
ll line_dp[2010][2010];
ll cyc_dp[2010][2010];
ll eval_line(int len , int cnt){
  if(cnt == 0)return 1;
  if(len <= 0)return 0;
  if(line_dp[len][cnt] != -1)
   return line_dp[len][cnt];
  ll& DP = line_dp[len][cnt];
  DP = 0;
  add_to(DP , eval_line(len-2 , cnt-1));
  add_to(DP , eval_line(len-1 , cnt));
  return DP;
}
ll eval_cyc(int len , int cnt){
  if(cnt == 0)return 1;
  if(len < cnt || len <= 0)return 0;
  ll& DP = cyc_dp[len][cnt];
  DP = 0;
  add_to(DP , eval_line(len-3 , cnt-1));
  add_to(DP , eval_line(len-1 , cnt));
  return DP;
}
// solution
int N;
vi cyc_sz;
vector<ll> m_cnt;
void init(){
  m_cnt.resize(N+1);
  fill(all(m_cnt) , 0);
  m_cnt[0] = 1;
  for(int i=0;i<sz(cyc_sz);++i){
   int cur = cyc_sz[i];
   for(int i=N;i>=0;--i){
    int up = min(i , cur);
    for(int take=1;take<=up;++take)
     add_to(m_cnt[i] , (eval_cyc(cur , take)*m_cnt[i-take])%MOD);
                        }
                               }
}
vi go[2010];
vector<char> used;
void dfs(int vr){
  ++cyc_sz.back();
  used[vr] = true;
  for(int i=0;i<sz(go[vr]);++i)
   if(!used[go[vr][i]])
    dfs(go[vr][i]);
}
void doit(){
  scanf("%d" , &N);
  cyc_sz.clear();
  for(int i=0;i<2*N;++i)
   go[i].clear();
  used.resize(2*N);
  fill(all(used) , false);
  vi r1(N) , r2(N);
  for(int i=0;i<N;++i){
   scanf("%d" , &r1[i]);
   //r1[i] = 1 + i;
   go[i].pb(N + r1[i]-1);
   go[N + r1[i] - 1].pb(i);
                      }
  for(int i=0;i<N;++i){
   scanf("%d" , &r2[i]);
   //r2[i] = 1 + (i+1)%N;
   go[i].pb(N + r2[i]-1);
   go[N + r2[i] - 1].pb(i);
                      }
  for(int i=0;i<2*N;++i)
   if(!used[i])
    cyc_sz.pb(0),
    dfs(i);
  init();
  ll ans = 0;
  for(int i=0;i<=N;++i){
   ll koef = fact[N-i];
   koef *= m_cnt[i];
   if(i&1)ans = (ans - koef)%MOD;
   else ans = (ans + koef)%MOD;
                       }
  printf("%d\n" , (int)((ans + MOD)%MOD));
}
int main(){
  fact[0] = 1;
  for(int i=1;i<1010;++i)
   fact[i] = (i*fact[i-1])%MOD;
  memset(line_dp , -1 , sizeof line_dp);
  memset(cyc_dp , -1 , sizeof cyc_dp);
  int Q;
  scanf("%d" , &Q);
  while(Q-- > 0)
   doit();
  return 0;
}