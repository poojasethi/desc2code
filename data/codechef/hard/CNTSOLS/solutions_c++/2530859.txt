//Author: Siddharth Saluja
//Quote: "DIE FOR YOUR AIM"
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<vector>
#include<string>
#include<set>
#include<map>
#include<stack>
#include<queue>
#include<deque>
#include<algorithm>

using namespace std;


#define mod 1000000007
//#define DEBUG
#define inf 2147483647
#define ninf -2147483648
#define FOR(i,a,b) for(i=a;i<b;i++)
#define s(a) scanf("%d",&a)
#define lls(a) scanf("%lld",&a)
#define ss(a) scanf("%s",a)
#define p(a) printf("%d",a)
#define llp(a) printf("%lld",a)
#define sp(a) printf("%s",a)
#define cp(a) printf("%c",a)
#define nline printf("\n")
#define space printf(" ")
#define fs(a) fscanf(fp,"%d",&a)
#define flls(a) fscanf(fp,"%lld",&a)
#define fss(a) fscanf(fp,"%s",a)
#define fp(a) fprintf(fo,"%d",a)
#define fllp(a) fprintf(fo,"%lld",a)
#define fsp(a) fprintf(fo,"%s",a)
#define fcp(a) fprintf(fo,"%c",a)
#define fnline fprintf(fo,"\n")
#define fspace fprintf(fo," ")
#define ll long long

long long int modexpo(long long int base,long long int po,long long int m)
{
    long long res=1;
    while(po>0)
    {
        if(po%2)
        res=(res*base)%m;
        base=(base*base)%m;
        po=po/2;
    }
    return res%m;
}


int main()
{
#ifdef DEBUG
    cout<<"Debugging\n";
#endif
//FILE *fp,*fo;
//fp=fopen("input.txt","r");
//fo=fopen("output.txt","w");
    long long int t,upper,d,m,n,i,j,k,count1=0,ans,rem;
    lls(t);
    while(t--)
    {
        count1=0;
        lls(upper);
        lls(d);
        lls(m);
        lls(n);
        ll remainder[41]={0};
        for(i=0;i<n && i<=upper;i++)
        {
            rem=modexpo(i,d,n);
            remainder[rem]=remainder[rem]+((upper-i)/n);
            remainder[rem]++;
            remainder[rem]=remainder[rem]%mod;
        }
        for(i=0;i<n;i++)
        {
            for(j=0;j<n;j++)
            {
                for(k=0;k<n;k++)
                {
                    ans=(i+j+k)%n;
                    if(ans==m)
                    {
                    count1=count1+(((((remainder[i]%mod)*(remainder[j]%mod))%mod)*(remainder[k]%mod))%mod);
                    count1=count1%mod;
                    }
                }
            }
        }
        llp(count1);
        nline;
    }
return 0;
}