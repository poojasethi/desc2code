/*editotrial:  	http://discuss.codechef.com/problems/CNTSOLS
*/

#include<iostream>
#include<string>
using namespace std;
#define FOR(i,a,b) for(int i=a;i<=b;++i)
typedef long long Int;

// void assert(bool x)
// {
	// if(!x)
		// throw -1;
// }

const int MODULO = 1000000007;


/*
binpw is one of the standard ways of doing modular exponentiation by using repeated squaring.

x^n = (x^2)^(n/2) - when n is even
	= x*(x^2)^((n-1)/2) - when n is odd
	
for e.g x^7 = x*(x^2)^3

*/
int binpw(int x,int times,int md){
	int ans=1;
	while(times){
		/*
		times&1 will be true for all odd value of 'times'
		ignoring the md for an example, if we call 2^5
		in first iteration, ans=1*2=2
		then as power goes down from 5 to 2 to 1
		x will go from 2 to 4 to 16
		in the last iteration when times & 1 will again be true for times=1, 
		ans will become ans=2*16=32 which is indeed 2^5
		
		however for 2^4, ans would have stayed 1 till the last iteration
		where it will become ans=1*16=16 which is indeed 2^4
		*/
		if(times&1) 
		{
			ans=(ans*(Int)x)%md;
			//cout<<"ans: "<<ans<<endl;
		}
		x=(x*(Int)x)%md;
		//cout<<"times: "<<times<<" x: "<<x<<endl;
		times/=2;
	}
	return ans;
}


 
int has_mod[111];
void solve(){
	int tests;cin>>tests;
	while(tests--){
		int up,N,d,m;
		//1<=xi<=up
		//sum xi^d == m mod N
		//0<=m<N
		cin>>up>>d>>m>>N;
 
		// assert(m>=0 && m<N);
		// assert(1<=up && up<=1000000000);
		// assert(0<=d && d<=1000000000);
		// assert(N<=40);
 
		
		/*
		if say up is 10 and N is 4 then by modulo arithmetic, there will be cycles of 0,1,2,3 using %4
		so for 0,1,2,3,4...9,10 will become 0,1,2,3,0,1,2,3,0,1,2
		so as you can see there are up/N = 2 full chain repeatitions + few more repeatitions for all numbers which are <=up%N (in this eg 0,1,2) for 
		N=4 and up=10 as up%N = 2
		*/
		FOR(i,0,N-1)
			has_mod[i] = (up/N)+(up%N>=i);
		Int ans=0;
		
		/*
		if there is a solution say (X,Y,Z) between 0 to N-1
		then all numbers such that x = X,modulo N  y = Y,modulo N  z = Z,modulo N
		(x,y,z) will be a solution as well
		*/
		FOR(md1,0,N-1)FOR(md2,0,N-1)FOR(md3,0,N-1){
			Int cur=0;
			cur+=binpw(md1,d,N);
			cur+=binpw(md2,d,N);
			cur+=binpw(md3,d,N);
 
			if(cur%N==m){
				int tmp=has_mod[md1];
				tmp=(tmp*(Int)has_mod[md2])%MODULO;
				tmp=(tmp*(Int)has_mod[md3])%MODULO;
				//cout<<md1<<" "<<md2<<" "<<md3<<" "<<tmp<<endl;
				ans=(ans+tmp)%MODULO;
			}
		}
		cout<<ans<<endl;
		/*ans=0;
		FOR(i1,0,up)FOR(i2,0,up)FOR(i3,0,up){
			Int now = (0LL+binpw(i1,d,N)+binpw(i2,d,N)+binpw(i3,d,N))%N;
			if(now==m)++ans;//cout<<i1<<" "<<i2<<" "<<i3<<endl;
		}
		cout<<ans<<endl;*/
	}
}
 
int main()
{
	//freopen("input.txt","r",stdin);freopen("output.txt","wb",stdout);
	solve();
	//cout<<binpw(2,4,5);
	
	/*const int files = 4;
	for(int file=0;file<files;++file){
		//cerr<<file<<endl;
		string fread = "input";fread+=char(file+48);fread+=".txt";
		string fwrite = "output";fwrite+=char(file+48);fwrite+=".txt";
		freopen(fread.data(),"r",stdin);freopen(fwrite.data(),"wb",stdout);
		solve();
	}*/
}