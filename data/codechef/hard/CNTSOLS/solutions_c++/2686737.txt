/* Author : Pranav
BITS PILANI Hyderabad Campus */
// x1^d +x2^d+x3^d mod n =m ; number of solutions  1=<x1,x2,x3<=up
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cctype>
#include <cstring>
using namespace std;

#define sz(a) int((a).size())
#define pb push_back
#define all(c) (c).begin(),(c).end()
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define present(c,x) ((c).find(x) != (c).end())
#define cpresent(c,x) (find(all(c),x) != (c).end())
#define fr(i,n) for(i=0; i<n; i++)
#define N 100005
#define mo 1000000007
#define f first
#define s second
typedef vector<int> vi;
typedef pair <int, int> paint;
typedef long long ll;
long long up,d,m,n,temp,cur;
long long mod(long long i)
{return i%mo;}
long long degree(long long a, long long k) {      
   temp = 1;
   cur = a;
if(a==0&&k==0){return 1;}
  while (k) {
     if (k%2) {
      temp = (temp * cur)%n;
     }
     k /= 2;
     cur = (cur * cur) % n;
  }
  return temp;
}


long long getsol(int x1){      
long long c=0,i;
long long store=0;
    for(i=0;i<n;i++){
     if( degree(i,d)==x1){c++;}
     }
     store=(up/n)*c;
     for(i=0;i<=(up-(up/n)*n);i++){
     if(degree(i,d)==x1){store++;}
     }
     return store;
}


// x1^d +x2^d+x3^d mod n =m ; number of solutions  1=<x1,x2,x3<=up
int main()
{
    long long t,i,j,k,sum=0,sol[50]={0};
     cin>>t;
     while(t--){
          sum=0;
          cin>>up>>d>>m>>n;
          for(i=0;i<40;i++){
               sol[i]=getsol(i);
          }
          
          
          
          for(i=0;i<40;i++){
               for(j=0;j<40;j++){
                    for(k=0;k<40;k++){
                         if((i%n + j%n+ k%n)%n==m){
                              sum=mod(sum +mod(  mod(sol[i]*sol[j] )  *sol[k]  ));
                         }
                    }
               }
          }
          cout<<sum<<endl;
     }

  return 0;
}