#include<cstring>
#include<cstdio>
#include<assert.h>
using namespace std;

#define FORN(i, n) for(i = 0; i < n; i++)
#define IN(A, B, C) assert( B <= A && A <= C)

typedef long long int LL;

long long int mod = 1000000007;
inline long long int modulo( long long int a, long long int b, long long int c )
{	long long x=1, y=a;
	while(b > 0)
        {	if ( ( b & 1 ) == 1)
            	{	x= ((long long int)x*y)%c;
			if ( x == 0 )
				return 0;
		}
        	y= ((long long int)y*y)%c;
		b >>= 1;
	}
    	return x;
}

int calc(int i, int upper, int n )
{	if(i <= upper)
		return (upper - i)/n + 1;
	return 0;
}

int main()
{	int t, upper, d, m, n, now, i, j, k, ans;
	long long int cnt[50];
	scanf("%d", &t);
	IN(t, 1, 10);
	while(t--)
	{	scanf("%d %d %d %d", &upper, &d, &m, &n);
		IN(upper, 1, 1000000000);
		IN(d, 0, 1000000000);
		IN(m, 0, n-1);
		IN(n, 1, 40);
		memset(cnt, 0, sizeof(cnt));
		//count how many i are there so that, i^d % n
		/*FORN(i, n)
		{	now = modulo(i, d, n);
			printf("i: %d now: %d\n",i,now);
			if(i <= upper)
				cnt[now] += (upper - i)/n + 1;			// preprocessed
		}*/
		//You have the counts.. now check if x^d + y^d + z^d = m % n. It can be done in O(n^2) as well.
		ans = 0;
		FORN(i, n)
			FORN(j, n)
				FORN(k, n)
				{	if( ( ( modulo(i,d,n) + modulo(j,d,n) )%n + modulo(k,d,n) )%n == m%n )
					{	int c1= calc(i,upper,n);
						int c2= calc(j,upper,n);
						int c3= calc(k,upper,n);
						//printf("upper: %d i: %d j: %d k: %d cnt[i]: %d cnt[j]: %d cnt[k]: %d\n",upper, i,j,k, c1, c2, c3);
						ans += (( long long )c1*((( long long )c2*c3)%mod))%mod;
						ans %= mod;
					}
				}
		printf("%d\n", ans);
	}
	return 0;
}