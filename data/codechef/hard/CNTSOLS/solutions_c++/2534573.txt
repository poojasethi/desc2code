/* Sm19 */
// http://www.codechef.com/problems/CNTSOLS
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>
#include <iostream>
#include <vector>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <algorithm>
#include <sstream>
#include <iterator>
#include <utility>
#include <iomanip>
#include <list>
#include <time.h>
using namespace std;

#define ll long long
#define rep(i,a,b) for(__typeof(a) i=(a);i<=b;i++)
#define all(a) (a).begin(),(a).end()
#define reall(a) (a).rbegin(),(a).rend()
#define fit(it,x)for(__typeof((x.begin())) it=x.begin();it!=x.end();it++)
#define rfit(it,x)for(__typeof((x.rbegin())) it=x.rbegin();it!=x.rend();it++)
#define mp make_pair
#define pb push_back
#define SZ(a) (int)a.size()
#define fs first
#define sc second
#define mem(a,b) memset(a,b,sizeof(a))
#define VI vector<int>
#define PII pair<int,int>

const double EPS=1e-9;
const int INF=0x7f7f7f7f;
const int MAX=100000;

const int MODULO = 1000000007;
inline ll sq(ll a){ return (a*a);}
//ll BigMod(ll a,ll b,ll M)
//{
//    if(b==0) return 1%M;
//    if(b%2) return (a*BigMod(a,b-1,M))%M;
//    return sq(BigMod(a,b/2,M))%M;
//}

ll binpw(int x,int times,int md)
{
    int ans=1;
    while(times)
    {
        if(times&1)ans=(ans*(ll)x)%md;
        x=(x*(ll)x)%md;
        times/=2;
    }
    return ans;
}

ll A[111],B[111];
ll U,D,N;

ll numof_Sol(ll x,ll y ,ll z)
{
    ll a=(B[x])%1000000007;
    a=(a*B[y])%1000000007;
    a=(a*B[z])%1000000007;

    return a;
}

int main(void)
{
    ll M;
    int t;
    cin>>t;
    while(t--)
    {
        cin>>U>>D>>M>>N;
//        A[0]=0;
//        rep(i,1,N)
//        {
//           // A[i]=BigMod(i,D,N);
//            A[i]=binpw(i,D,N);
//        }

        for(int i=0;i<N;i++)
        {
            B[i]=(U/N)+((U%N)>=i);
        }

        ll ans=0;
        for(int X=0;X<N;X++)
        {
            for(int Y=0;Y<N;Y++)
            {
                for(int Z=0;Z<N;Z++)
                {
                    ll cur=0;
                    cur+=binpw(X,D,N);
                    cur+=binpw(Y,D,N);
                    cur+=binpw(Z,D,N);

                    if(cur%N==M)
                    {
                        ll tmp=B[X];
                        tmp=(tmp*(ll)B[Y])%MODULO;
                        tmp=(tmp*(ll)B[Z])%MODULO;
                        ans=(ans+tmp)%MODULO;
                    }
//                    if((A[X]+A[Y]+A[Z])%N==M)
//                    {
//                        ans=(ans+numof_Sol(X,Y,Z))%1000000007;
//                    }
                }
            }
        }

        cout<<ans<<endl;
    }
    return 0;
}

/*

All submissions for this problem are available.

Little Chief loves math. Most of all, he loves equations. He can solve any equation in the whole world. Recently he found one interesting and easy equation

x1d+x2d+x3d ≡ m (mod N)
Where x1, x2 and x3 are non negative integer numbers.

But, as always, this was easy enough for him and he solved it in just a few seconds. Now he wants you to do the same. Of course he understands that nobody is as good as he is, so he wants only the number of solutions of such equation which satisfies 0 ≤ x1, x2, x3 ≤ upper for given upper, d,m and N. As the answer might be very large, he asks you to find the answer modulo 1000000007.
Input

The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follow. Each test case consists of 4 integers: upper, d, m, N.
Output

For each test case, output a single line containing number of solutions for the corresponding equation, modulo 1000000007. You may assume that 00 is equal to 1.
Constraints

    1 ≤ T ≤ 10
    1 ≤ upper ≤ 1,000,000,000
    0 ≤ d ≤ 1,000,000,000
    1 ≤ N ≤ 40
    0 ≤ m < N

*/
