#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<assert.h>
#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define ll long long
#define MOD 1000000007

ll inv[800010];
ll fact[800010], fact_inv[800010];

ll comb(int a,int b){
  return (((fact[a] * fact_inv[b]) % MOD) * fact_inv[a-b]) % MOD;
}

ll ways(int a, int b){
  return comb(a+b, a);
}

void extended_euclid(ll x,ll y,ll *c,ll *a,ll *b){
  ll a0,a1,a2,b0,b1,b2,r0,r1,r2,q;
  r0=x; r1=y; a0=1; a1=0; b0=0; b1=1;
  while(r1>0){
    q=r0/r1; r2=r0%r1; a2=a0-q*a1; b2=b0-q*b1;
    r0=r1; r1=r2; a0=a1; a1=a2; b0=b1; b1=b2;
  }
  *c=r0; *a=a0; *b=b0;
}

ll get_inv(ll n, ll p){
  ll a,b,c;
  extended_euclid(n,p,&c,&a,&b);
  if(a<p) a+=p;
  return a%p;
}

ll pw(ll a,ll b, ll md){
  ll r;
  if(!b) return 1;
  r = pw(a,b/2,md);
  r = (r*r)%md;
  if(b%2) r = (r*a)%md;
  return r;
}

int main(){
  int T, N, M, A, B;
  int i;
  ll res;

  /* calculate all inverses of 1..8000000 mod MOD */
  inv[1] = 1;
  REP(i,2,800010) inv[i] = MOD - ((MOD/i)*inv[MOD%i]%MOD);

  /* The followings are slower methods for calculating inv[i] */
  /* These methods may cause TLE if no optimizations are used */
  /* get_inv (extended Euclid) is mediam,
   (a^(MOD-2)) is most slow */
/*  REP(i,1,800010) inv[i] = get_inv(i,MOD);
  REP(i,1,800010) inv[i] = pw(i,MOD-2,MOD);*/

  fact[0] = fact_inv[0] = 1;
  REP(i,1,800010) fact[i] = (fact[i-1]*i)%MOD;
  REP(i,1,800010) fact_inv[i] = (fact_inv[i-1]*inv[i])%MOD;

  /* fact_inv[8000000] = inv(fact[8000000]) */
  /* then fact_inv[k-1] = fact[k] * k mod MOD is one of good ways:) */

  //printf("%d\n",(int)ways(5,3));
  assert( scanf("%d",&T)==1 );
  assert( 0 <= T && T <= 10 );
  while(T--){
    assert( scanf("%d%d%d%d",&N,&M,&A,&B)==4 );
    assert( 0<A && A<N && 1<=N && N<=400000 );
    assert( 0<B && B<M && 1<=M && M<=400000 );

    if(A==0 || B==0){
      res = ways(N, M);
      printf("%d\n",(int)res);
      continue;
    }

    res = 0;
    REP(i,A,N+1){
      res += ways(i, M-B) * ways(N-i, B-1); /* the way through (0, 0) - (i, M-B) - (i, M-B+1) - (N, B)
                                             */
      res %= MOD;
    }
    printf("%d\n",(int)res);
  }

  return 0;
}
