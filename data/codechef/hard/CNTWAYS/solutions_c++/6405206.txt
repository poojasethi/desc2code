#include <iostream>
#include <algorithm>
#include <cstdio>
#include <map>
#include <cmath>
#include <stdio.h>
#include <memory.h>
#include <string.h>
#include <string>
#include <stack>
#include <vector>
#include <set>
#include <queue>
#include <stdlib.h>

using namespace std;

#define FOR(i,a,b) for (int i = int(a); i <= b; i++)
#define mod 1000000007
#define MOD 1000000007
#define ll long long int
#define inchar getchar_unlocked
#define mx 800010
#define REP(i,a,b) for(int i= int(a);i<b;i++)
#define rep(i,n) REP(i,0,n)


ll fact[mx+5],modinverse[mx+5],inv[mx+5];

inline void inp( ll &n )
{
n=0;
ll ch=inchar();ll sign=1;
while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=inchar();}
while( ch >= '0' && ch <= '9' )
n = (n<<3)+(n<<1) + ch-'0', ch=inchar();
n=n*sign;
}


ll po(ll a, ll b)
{
  ll r;
  if(b==0) return 1;
  r = po(a,b/2);
  r = (r*r)%mod;
  if(b%2) r = (r*a)%mod;
  return r;
}


void init()
 {
      inv[1] = 1;
  REP(i,2,800010) inv[i] = MOD - ((MOD/i)*inv[MOD%i]%MOD);
  fact[0] = modinverse[0] = 1;
  REP(i,1,800010) fact[i] = (fact[i-1]*i)%MOD;
  REP(i,1,800010) modinverse[i] = (modinverse[i-1]*inv[i])%MOD;
    
 }



ll comb(ll a,ll b)
 {
    a = a + b; 
    ll ret = (fact[a] * modinverse[a-b])%mod;
    ret = (ret * modinverse[b])%mod;
    return ret;          
 }
 
int main() {
	// your code goes here

    init();
    ll r;
    inp(r);
    while(r--)
     {
       ll n,m,a,b;
       cin>>n>>m>>a>>b;
       
       ll sum = (comb(b,n-a) * comb(m-b,a)) % mod;
       ll right = n-a-1;
       for(ll i=0;i<=right;i++)
          sum = ( sum +( ( comb(b,i) * comb(m-b-1,n-i) )%mod )) %mod;
    
       cout<<sum<<endl;      
       
     }
    
	return 0;
}
