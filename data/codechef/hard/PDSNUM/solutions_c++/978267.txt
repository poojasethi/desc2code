
#include<bitset>
#include<complex>
#include<deque>
#include<map>
#include<queue>
#include<set>
#include<stack>
#include<vector>
#include<algorithm>
#include<climits>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<fstream>
#include<iostream>
#include<sstream>
using namespace std;
#define bitcount __builtin_popcount
#define gcd __gcd
#define VVII vector< vector < pair<int,int> > > 
#define VVI vector< vector < int > > 
#define VII vector < pair<int,int> >
#define MSI map< string , int >
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)
#define ii pair< int, int >
 
#define s(n)                                    scanf("%d",&n)
#define sl(n)                                   scanf("%lld",&n)
#define sf(n)                                   scanf("%lf",&n)
#define ss(n)                                   scanf("%s",n)
#define INF                                             (int)1e9
#define LINF                                    (long long)1e18
#define EPS                                             1e-9
#define maX(a,b)                                ((a)>(b)?(a):(b))
#define miN(a,b)                                ((a)<(b)?(a):(b))
#define abS(x)                                  ((x)<0?-(x):(x))
#define FOR(i,a,b)                              for(int i=a;i<b;i++)
#define REP(i,n)                                FOR(i,0,n)
#define foreach(v,c)            for( typeof((c).begin()) v = (c).begin();  v != (c).end(); ++v)
#define mp                                              make_pair
#define FF                                              first
#define SS                                              second
#define tri(a,b,c)                              mp(a,mp(b,c))
#define XX                                              first
#define YY                                              second.first
#define ZZ                                              second.second
#define pb                                              push_back
#define fill(a,v)                               memset(a,v,sizeof a)
#define all(x)                                  x.begin(),x.end()
#define SZ(v)                                   ((int)(v.size()))
#define DREP(a)                                 sort(all(a)); a.erase(unique(all(a)),a.end())
#define INDEX(arr,ind)                  (lower_bound(all(arr),ind)-arr.begin())
#define debug(args...)                  {dbg,args; cerr<<endl;}
#define dline                                   cerr<<endl      
#define MAX 144000
using namespace std;
 
void sc(char &c){
        char temp[4];   ss(temp);       
        c=temp[0];
}
 
struct debugger
{
        template<typename T> debugger& operator , (const T& v)
        {       
                cerr<<v<<" ";   
                return *this;   
        }
} dbg;
 
 
 
/*Main code begins now */
 
 
int sumOfDigits(int n){
    int sum=0;
    while(n>0){
	int k=n%10;
	sum+=k;
        n=n/10;
    }
    return sum;
}
    
int mulOfDigits(int n){
    int mul=1;
    while (n > 0){
        mul*=n%10;
        n=n/10;
     }
    return mul;
}
 
ii calculate(int n)
{
    ii no;
    no.first=0;no.second=1;
    while(n)
    {
        int d=n%10;
        no.first+=d;
        no.second*=d;
        n/=10;
    }
    return no;
}
int array[10000000];
map< ii ,int> myMap;
map< ii ,int>::iterator it;
    
void preprocess()
{
    array[1]=4009;
    ii number,temp;
    int count=0,index=0;
    int sum,product,i;
    int iIndex=2;
    FOR(i,1000,10000)
    {
        number=calculate(i);
        if(number.second!=0)
            myMap[number]++;
    }
    FOR(i,1,MAX+1)
    {
        number=calculate(i);
        if(number.second==0)
        {
            array[iIndex++]=10000;
        
        }
        else
        {
            count=3439;
            foreach(it,myMap)
            {
                temp=(*it).first;
                product=number.second*temp.second;
                sum=number.first+temp.first;
                if(product%sum==0)
                    count+=(*it).second;
            }
            array[iIndex++]+=count;
        }
        array[iIndex-1]+=array[iIndex-2];
    }
}
 
void solve()
{	
    ii number;
    int count=0,index=0;
    int n,lb,i;
    while(s(n) && n)
    {
        lb=lower_bound(array,array+MAX,n)-array-1;
        count=array[lb];
        i=lb*10000;
        if(!i)
        {
        	i++;
        	count++;
        }
        while(count<=n)
        {   
            number=calculate(i);
            if(number.second%number.first==0)
                count++;
            i++;
        }
        i--;
        printf("%d\n",i);
    }             
}
 
 
 
bool input()
{
        
}
 
 
int main()
{
        preprocess();
        //int T; s(T);
        //while(T--)
        {
                solve();
        }
}