#include <iostream>
#include <cstdio>
#include <cassert>
#include <vector>
#include <queue>
#include <set>
#include <map>
#include <stack>
#include <algorithm>
#include <cmath>
#include <complex>
#include <string>
#include <sstream>
#include <cstdlib>
#include <numeric>
#include <bitset>
#include <cstring>
#include <iomanip>
#include <climits>
using namespace std;

#define REP(i, m, n) for(int i=(m); i<int(n); ++i)
#define rep(i, n) for(int i=0; i<int(n); ++i)
#define each(it, a) for(__typeof((a).begin()) it = (a).begin(); it != (a).end(); ++it)
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(),(v).end()
#define rall(v) (v).rbegin(),(v).rend()
//#define FILL(a, c) std::fill((__typeof(c)*)(a), (__typeof(c)*)(a) + sizeof(a) / sizeof(__typeof(c)), (c))
#define FILL(a, c) fill_n(reinterpret_cast<__typeof(c)*>(a), sizeof(a) / sizeof(__typeof(c)), (c))
template<class T> void fill_n(const T *first, size_t n, const T &value) { for(; n>0; --n) *const_cast<T*>(first++) = value; }
#define pb push_back                                                                          
#define mp make_pair
#define def(a, x) __typeof(x) a = x
#define fi first
#define se second
typedef long long ll;
typedef pair<ll, ll> PI;
const int dx[] = {1, 0, -1, 0, 1, 1, -1, -1}, dy[] = {0, 1, 0, -1, 1, -1, 1, -1};


ll memo[12][100][100][100][2];

/* if zero = true, then it is leading zero */
ll g(int n, int s, int cursum, int prod, bool zero) {
	ll &res = memo[n][s][cursum][prod][zero];
	if (res != -1) return res;
	if (n == 0) return res = cursum == s && prod % s == 0;
	res = 0;
	rep(i, 10) {
		int nextprod = (zero && i == 0 ? 1 : prod * i) % s;
		int nextsum = cursum + i;
		res += g(n-1, s, nextsum, nextprod, zero && !i);
	}
	return res;
}

ll f(ll x) {
	ll cursum = 0, prod = 1;
	bool zero = true;
	ll ans = 0;
	ll lastres = 0;
	for(int n=12; n>=1; n--) {
		ll res = lastres;
		rep(i, 10) {
			ll nextprod = (zero && i == 0 ? 1 : prod * i);
			ll nextsum = cursum + i;
			lastres = res;
			for(int s=1; s<100; s++) res += g(n-1, s, nextsum, nextprod % s, zero && !i);

			if (x <= res) {
				cursum = nextsum;
				prod = nextprod;
				zero = zero && !i;
				ans = 10*ans + i;
				break;
			}
		}
	}
	return ans;
}
int main() {
	memset(memo, -1, sizeof(memo));
	ll N;
	while(cin >> N, N) {
		cout << f(N) << endl;
	}
}
