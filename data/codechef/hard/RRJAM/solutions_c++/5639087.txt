#include<cstdio>
#include<cmath>
#include<queue>
#include<vector>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long int lli;
lli n,x[100005],b[100005],Y[100005],a[100005],Z[100005],i,j,k,mark[100005],z,m,l,r,x1,y,flag=0,val[100005],cnt;

lli min(lli x,lli y)
{
    if(x<y)
        return x;
    return y;
}
struct op
{
    lli l,r,x,y;
    op(lli a,lli b,lli c,lli d)
    {
        l=a;
        r=b;
        x=c;
        y=d;
    }
    op()
    {
        l=r=x=y=0LL;
    }
} d;

std::queue<op>temp;
std::vector<op>vec;
int main()
{
    scanf("%lld",&n);
    for(i=0; i<n; i++)
    {
        scanf("%lld",&x[i]);
    }
    for(i=0; i<n; i++)
    {
        scanf("%lld",&b[i]);
        x[i]-=b[i];
    }
    scanf("%lld",&m);
    for(i=0; i<n; i++)
        mark[i]=val[i]=12345678LL;
    for(i=0; i<n; i++)
    {
        if(x[i]>=0)
            mark[i]=val[i]=0LL;
    }

    for(i=0; i<m; i++)
    {
        scanf("%lld %lld %lld %lld",&l,&r,&x1,&y);
        l--;
        r--;
        temp.push(op(l,r,x1,y));
        vec.push_back(op(l,r,x1,y));
    }

    for(i=1;; i++)
    {
        if(flag)
            break;
        for(j=0; j<=n; j++)
            a[j]=Y[j]=Z[j]=0LL;
        j=sqrt(m);
        cnt=0LL;
        while(j--)
        {
            if(temp.empty())
                flag=1;
            if(flag)
                break;
            d=temp.front();
            temp.pop();
            cnt++;
            a[d.l]+=d.x;
            a[(d.r)+1]-=d.x;
            Y[(d.l)]+=d.y;
            Y[(d.r)+1]-=(d.y);
            Z[(d.l)]+=d.l*d.y;
            Z[d.r+1]-=d.l*d.y;
        }
        for(j=1; j<n; j++)
        {
            a[j]+=a[j-1];
            Y[j]+=Y[j-1];
            Z[j]+=Z[j-1];
        }

        for(j=0; j<n; j++)
        {

            x[j]+=a[j]+Y[j]*j-Z[j];
            //printf("%lld %lld %lld %lld\n",a[j],Y[j],x[j],V[j]);
            if(x[j]>=0)
                mark[j]=min(mark[j],i);
            //printf("%lld %lld %lld\n",x[j],mark[j],val[j]);
            if(mark[j]==i)
            {
               x[j]-=a[j]+Y[j]*j-Z[j];
                z=sqrt(m);
                for(k=0; k<cnt; k++)
                {
                    if(j>=vec[k+(i-1)*z].l && j<=vec[k+(i-1)*z].r)
                    {
                        x[j]+=vec[k+(i-1)*z].x + (j-vec[k+(i-1)*z].l)*(vec[k+(i-1)*z].y);
                        if(x[j]>=0)
                        {
                            val[j]=(i-1)*z + k + 1;
                            break;
                        }

                    }
                }
            }
        }
        //for(j=0; j<n; j++)
        // printf("%lld %lld %lld\t",x[j],mark[j],val[j]);
        //printf("\n");
    }
    for(i=0; i<n; i++)
    {
        if(val[i]>m)
            printf("-1 ");
        else
            printf("%lld ",val[i]);
    }

    return 0;
}
