//Amit Kumar Gupta              
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef pair<int,int> II;
#define REP(i,i1,n) for(int i=i1;i<n;i++)
#define REPB(i,i1,n) for(int i=i1;i>=n;i--)
#define PB push_back
#define MP make_pair
#define ALL(c) (c).begin(),(c).end()
#define F first
#define S second
#define SZ(a) (LL)a.size()
#define EPS 1e-12
#define MOD 1000000007
#define TR1(x) cerr<<#x<<" : "<<x<<endl
#define TR2(x,y) cerr<<#x<<" : "<<x<<" | "<<#y<<" : "<<y<<endl
#define FAST_IO ios_base::sync_with_stdio(false);cin.tie(NULL)
#define SI(c) scanf("%d",&c)
#define SII(c,d) scanf("%d%d",&c,&d)
#define SLL(c) scanf("%lld",&c)
#define PIN(c) printf("%d\n",c)
#define PLLN(c) printf("%lld\n",c)
#define N 100010
#define LOGN 21
#define INIT1(array,ST,END,val) for(int i=ST;i<END;i++)array[i]=val
#define INIT2(array,nn,mm,val) for(int i=0;i<nn;i++)for(j=0;j<mm;j++)array[i][j]=val
//------------------------------------------------------MAIN CODE STARTS HERE---------------------------------------

int n,q,par[N],P[N][22];
vector<pair<int,int> > v,v1;
vector<int> v2;
pair<int,int> edge[N];

bool cmp(const II a,const II b) {
    if(a.F < b.F)
        return true;
    if(a.F == b.F)
        if(a.S >= b.S)
            return true;
    return false;
}

void preprocess() {
	
    REP(i,0,n+1)
		for(int j=0;j<=20;j++)  
			P[i][j]=-1;

	REP(i,1,n+1)
		P[i][0]=par[i];

	for(int j=1;(1<<j) <=n;j++)
		for(int i=1;i<=n;i++)
			if(P[i][j-1]!=-1)
				P[i][j]=P[P[i][j-1]][j-1];

}
int query(int p,int lm) {
	
    int log1=20,ans=0;
	for(int i=log1;i>=0;i--) {
		if(P[p][i]!=-1&&edge[P[p][i]].F<=lm) {
            ans+=(1<<i);
			p=P[p][i];
		}
	}
    return ans;

}
int main() {
    SII(n,q);
    REP(i,0,n) {
        int x,y;
        SII(x,y);
        v.PB(MP(y,x));
    }

    int cnt=1;
    sort(ALL(v),cmp);
    v1.PB(v[0]);
    v2.PB(v[0].S);
    edge[cnt]=v[0];
    cnt++;

    REP(i,1,n) {
        int st1 = v[i].S,en1 = v[i].F;
        int st2 = v1[v1.size()-1].S,en2 = v1[v1.size()-1].F;
        if(st1 > st2 && en1 > en2) {
            v1.PB(v[i]),v2.PB(st1);
            edge[cnt]=v[i],cnt++;
        }
    }

    REP(i,0,v1.size()) {
        int st = v1[i].S , en = v1[i].F;
        int id = lower_bound(ALL(v2),en+1) - v2.begin();
        if(id == v1.size())
            par[i + 1] = v1.size() + 1;
        else
            par[i + 1] = id + 1;
    }

    n=v1.size()+1;
    par[n]=-1;
    edge[n]=MP(MOD,MOD);
    preprocess();

    while(q--) {
        int st,end;
        SII(st,end);
        int id1=lower_bound(ALL(v2),st)-v2.begin();
        int vl=query(id1+1,end);
        if(edge[id1+1].F<=end)
            vl++;
        PIN(vl);
    }
    return 0;
}
