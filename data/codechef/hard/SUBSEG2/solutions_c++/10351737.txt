#include <bits/stdc++.h>
using namespace std;
long long nodes[100010][20];
int jumpTo[100010][20];
int nearest[1000100];
int n;
struct data
{
    int left;
    int right;
}courses[100010];
 
bool comp(const data &a,const data &b)
{
    return (a.right<b.right || (a.right==b.right && a.left<b.left));
}
 
 
long long get(int close,int limit)
{
    long long ans = 1;
    for(int i=19;i>=0;i--)
    {
        if(jumpTo[close][i]>=n)
        {
            continue;
        }
        else
        {
            int next = jumpTo[close][i];
            if(courses[next].right>limit)
            {
                continue;
            }
            ans+=nodes[close][i];
            close = next;
        }
    }
    return ans;
}
 
int main()
{
    for(int i=0;i<=1000010;i++)
    {
        nearest[i] = 1000000;
    }
    for(int i=0;i<=100000;i++)
    {
        for(int j=0;j<20;j++)
        {
            jumpTo[i][j] = 1000000;
        }
    }
    ios::sync_with_stdio(false);
    int q;
    cin>>n>>q;
    for(int i=0;i<n;i++)
    {
        cin>>courses[i].left>>courses[i].right;
    }
    sort(courses,courses+n,comp);
    int a = 0;
    for(int i=0;i<=1000001;i++)
    {
        while(a<n && courses[a].left<i)
        {
            a++;
        }
        nearest[i] = a;
    }
 
    for(int i=0;i<n;i++)
    {
        int near = nearest[courses[i].right+1];
        jumpTo[i][0] = near;
        nodes[i][0] = 1;
    }
 
    for(int i=1;i<20;i++)
    {
        for(int j=0;j<n;j++)
        {
            if(jumpTo[j][i-1]>=0 && jumpTo[j][i-1]<n)
            {
                jumpTo[j][i] = jumpTo[jumpTo[j][i-1]][i-1];
                nodes[j][i] = nodes[j][i-1] + nodes[jumpTo[j][i-1]][i-1];
            }
        }
    }
 
    while(q--)
    {
        int L,R;
        cin>>L>>R;
        int closest = nearest[L];
        if(closest>=n || closest<0 || courses[closest].right>R)
        {
            cout<<0<<endl;
        }
        else
        {
            cout<<get(closest,R)<<endl;
        }
    }
}