#include"stdio.h"
#include"iostream"
#include"map"
#include"cassert"
using namespace std;
int gcd(int a,int b)
{
  if(a==0)return b;
  if(a>b)return gcd(b,a);
  return gcd(b%a,a);
}
void solve(long long x,long long p,long long& n,long long& k)
{
  if(x==1)
  {
    n=1;k=0;return;
  }
  solve(p%x,x,k,n);
  n=n-k*(p/x);
  long long r=-1-(n/p);
  n=n-p*r;
  k=k+x*r;
}
int inverse(int x,int p)
{
  long long n,k;
  solve(x,p,n,k);
  return (int)n;
}
int powermod(int a,long long b,int c)
{
  if(b<0)while(1);
  if(b==0)return 1;
  if(b==1)return a%c;
  int l=powermod((int)(((long long)a*a)%c),b>>1,c);
  if(b&1)l=((long long)l*a)%c;
  return l;
}
map<int,int> s;
void findfactors(int a)
{
  s.clear();
  int x=2;
  while(a>1)
  {
    while(a%x==0){s[x]++;a/=x;}
    x++;
  }
}
int findSumPower(long long n,int l)//solve the problem for n=n,m=l which is p^l for some prime p
{
  if(l==0)while(1);
  int sum=0;
  for(int i=1;i<l;i++)
  {
    if(i>n)return sum;
    int ipoweri=powermod(i,i,l);
    int ipowerl=powermod(i,l,l);
    int gpsum=0;
    long long upto=(n-i)/l;
    if(ipowerl==0)gpsum=1;
    else if (ipowerl==1)gpsum=(upto+1)%l;
    else
    {
      gpsum=(powermod(ipowerl,upto+1,l)-1);
      while(gpsum<0)gpsum+=l;
      int b=ipowerl-1;
      gpsum=((long long)gpsum*inverse(b/gcd(b,l),l))%l;
    }
    gpsum=((long long) ipoweri*gpsum)%l;
    sum+=gpsum;
    if(sum>=l)sum-=l;
  }
  return sum;
}
int main()
{
  int T;
  scanf("%d",&T);
//   printf("%d\n",T);
  while(T--)
  {
    long long n,m;
    scanf("%Ld%Ld",&n,&m);
    if(m==1)
    {
      printf("0\n");continue;
    }
    findfactors(m);
    int sum=0;
    //use chineese remainder theorem
    for(map<int,int>::iterator it=s.begin();it!=s.end();it++)
    {
      int p=it->first;
      int t=it->second;
      int ni=powermod(p,t,m+1);
      if(ni<=1)while(1);
      int Nbyni=m/ni;
      int ai=findSumPower(n,ni);
      sum+=(((long long)Nbyni*inverse(Nbyni,ni))*ai)%m;
      if(sum>=m)sum-=m;
    }
    printf("%d\n",sum);
  }
}