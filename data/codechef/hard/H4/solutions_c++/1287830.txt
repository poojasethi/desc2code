#include<cstdio>  
#include<iostream>  
using namespace std;
typedef long long ll;

int Phi(int n){
	int result=n;
	int m=n/2;
	if (!(n%2)){
		result = result/2;
		n=n/2;
		while(!(n%2)) n=n/2;
	}
	for (int i=3; i<=m ; i+=2)
		if (!(n%i)){
			result = (result/i)*(i-1);
			n=n/i;
			while(!(n%i)) n=n/i;
		}
	if (result==n) result=n-1;
	return result;
}

int seriesum(int x, ll n, int phi, int m){	//returns 1 + x + x^2 + x^3 + ... + x^n (mod m)
	int result=1;
	int q = (n / ll(phi)) % ll(m);		//quotient (mod m)
	int r = n % ll(phi);			//remainder

	int y=0;				//y = x + x^2 + ... + x^r (mod m)
	int z=0;				//z = x + x^2 + ... + x^phi (mod m)
	int count,l,h,l1,h1;
	if(r){
		count=1;
		while(!(r&(1<<31))) {r=r<<1; count++;}
		r=r<<1;
		y=1+x;
		l=x;
		h=(ll(x)*ll(x))% m;
		while (count!=32){
			y=(ll(y)*ll(1+h))% m;
			h1=h; l1=l;
			if (r&(1<<31)){
				h=(ll(h1)*ll(h1))% m;
				l=(ll(h1)*ll(l1))% m;
			}
			else{
				h=(ll(h1)*ll(l1))% m;
				l=(ll(l1)*ll(l1))% m;
				y=(m+y-h)%m;		
			}
			r=r<<1;
			count++;
		}
		y=(m+y-1)% m;
	}
	if(q){
		count=1;
		while(!(phi&(1<<31))) {phi=phi<<1; count++;}
		phi=phi<<1;
		z=1+x;
		l=x;
		h=(ll(x)*ll(x))% m;
		while (count!=32){
			z=(ll(z)*ll(1+h))% m;
			h1=h; l1=l;
			if (phi&(1<<31)){
				h=(ll(h1)*ll(h1))% m;
				l=(ll(h1)*ll(l1))% m;
			}
			else{
				h=(ll(h1)*ll(l1))% m;
				l=(ll(l1)*ll(l1))% m;
				z=(m+z-h)%m;		
			}
			phi=phi<<1;
			count++;
		}
		z=(m+z-1)% m;
	}

	result = result + ((ll(z)*ll(q))% m);
	result = (result+y)% m;
	return result;
} 

int main(){
int T,M,R,phi,ans,w,x,y,z,i,j,ss;
ll N,Q;
scanf("%d", &T);
while (T--){
	scanf("%Ld%d", &N, &M);
	Q=N/ll(M); R=N%ll(M);
	phi=Phi(M);
	ans=0;
	int ssarr[M];
	for (i=0; i<M; i++)
		ssarr[i]=-1;


	bool B[18];	//B is boolean representation of M
	x=M; for (j=0;j<18;j++){B[j]=x&1; x=x>>1;}
	
	for (i=1; i<=M; i++){
		//first we compute y=i^M(mod M) and z=i^i(mod M)
		y=1; z=1;
		x=i; w=i;
		for (j=0;j<18;j++){
			if (B[j]) y = (ll(y)*ll(w)) % M;
			if (x&1)  z = (ll(z)*ll(w)) % M;
			x=x>>1;
			w = (ll(w)*ll(w)) % M;
		}

		//now we compute 1 + y^1 + y^2 + ... till y^(Q-1), or y^(Q)
		if(Q)
		 	if (y){
				if (ssarr[y]>=0) ss=ssarr[y];
				else {
					ss = seriesum(y,Q-1,phi,M);
					ssarr[y] = ss;
				}
				if (i<=R) ss = (ll(ss)*ll(y) + 1)% M;
				}
			else ss=1;
		else
			if(i<=R) ss=1;
			else ss=0;

		ans = (ans + ll(ss)*ll(z) )% M;
	}
	cout<<ans<<endl;
}
return 0;
}
