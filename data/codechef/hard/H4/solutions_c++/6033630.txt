#include<stdio.h>
using namespace std;
typedef long long int ulli;
ulli min(ulli a, ulli b)
{
    if(a<=b)return a;
    else return b;
}
ulli modPow(ulli base, ulli exp, ulli mod)
{
    ulli ans = 1;
    base = base % mod;
    while(exp)
    {
        if(exp%2)
        {
            ans = (ans* base)%mod;
        }
        base = (base * base)%mod;
        exp/=2;
    }
    return ans;
}
ulli sumGP(ulli r, ulli n, ulli mod)
{
    if(n == 0) return 1%mod;
	else if(n == 1) return (1 + r)%mod;
	else if(n%2 == 1) return ((1+r)*sumGP(modPow(r,2,mod),(n-1)/2,mod))%mod;
	else return (1 +  (r* (1+r) * sumGP(modPow(r,2,mod),(n-2)/2,mod)))%mod;
}
int main()
{
    ulli n, mod;
    int t;
    scanf("%d",&t);
    while(t--){
    scanf("%lld%lld",&n,&mod);
    int ans = 0;
    ulli upto = min(mod-1,n);
    for(ulli i = 1;i<=upto;i++)//this loop must run till mod, but what if mod >> n itself?
    {
        ulli ii = modPow(i,i,mod);//i^i into sumGP
        /*calculate how long do these sums go, what if out number is less than modulo?
        suppose 2, 2^2 is less than mod, i.e. if n is less than mod, it goes till n itself?
        consider a case where n = 10, mod = 11
        1^1 2^2 3^3 4^4 5^5
        1 4 27 64 125
        1 4 5 9 4
        Now how long does 2^2 go? Simple to n itself
        But then, 2^2 is a single term and gp is of term 1 only, so how to determine the NUMBER of termsp
        power of i is i, so check to determine it, whether it exceeds the mod or not
        if it does, then we need to make a gp, otherwise not required
            otherwise how many terms> it can go till mod-1 if needed.
        1^1 + 2^2 + 3^3 ..... mod-1^mod-1 ..1^(mod+1)
        1^1 + 1^(mod+1) + 1^(2*mod+1)
        1^1(1 + 1^mod + 1^2*mod....)
         */

        //how mant number of terms is stil a query
        ulli ratio = modPow(i,mod,mod);//just for fun
        ans = (ans + (ii*sumGP(ratio,(n-i+mod)/mod-1,mod))%mod)%mod;
    }
    printf("%d\n",ans);
    }
    return 0;
}
