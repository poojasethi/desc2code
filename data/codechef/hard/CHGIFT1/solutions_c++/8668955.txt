#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <algorithm>
#include <functional>
#include <math.h>

inline bool fastreadIsEndOfLine(int* a)
{
  register char c = 0;
  while (c < 33)
    c = getchar();
  *a = 0;
  while (c > 33)
  {
    *a = (*a <<1)+(*a<<3) + c - '0';
    c = getchar();
    if(c == '\r' || c == '\n')
      return true;
  }

  return false;
}

inline void fastread(int* a)
{
  register char c = 0;
  while (c < 33)
    c = getchar();
  *a = 0;
  while (c > 33)
  {
    *a = (*a <<1)+(*a<<3) + c - '0';
    c = getchar();
  }
}

inline void fastreadNeg(int* a)
{
  register char c = 0;
  while (c < 33)
    c = getchar();
  *a = 0;
  bool neg = false;
  if(c == '-')
  {
	  c = getchar();
	  neg = true;
  }
  while (c > 33)
  {
    *a = (*a <<1)+(*a<<3) + c - '0';
    c = getchar();
  }

  if(neg)
	  *a = -*a;
}

int N, K;
int T = 1;

int A[10 + 1];

enum EOperation
{
	mul,
	plus,
	minus,
	num_ops,
};

static const long long MAX_RES = 3486784402; // 9^10 + 1
long long minResult = 0;

//#include <map>
//std::map<long long, int> mapCache;
//
////long long debugCalls = 0;
////long long debugSkip = 0;
//void solve(long long result, int index)
//{
//	if(index >= N) // Finished with numbers
//	{
//		if(minResult > result)
//			minResult = result;
//		return;
//	}
//
//	//++debugCalls;
//
//	// Check map for the current result and index, if marked then we shouldn't continue
//	std::map<long long, int>::iterator it = mapCache.find(result);
//	if(it != mapCache.end())
//	{
//		if(it->second & (1 << index))
//		{
//			//++debugSkip;
//			return;
//		}
//	}
//
//	solve(result * A[index], index + 1);
//	solve(result + A[index], index + 1);
//	solve(result - A[index], index + 1);
//
//	// Mark map for the current result and index as done!
//	it = mapCache.find(result);
//	if(it != mapCache.end())
//	{
//		it->second |= (1 << index);
//	}
//	else
//	{
//		mapCache[result] = (1 << index);
//	}
//}
//
int main()
{
#ifdef USE_DATA_TXT
  freopen_s(&stream, "C:\\Projects\\TaskTemplate\\data.txt", "r", stdin);
#endif
#ifdef PRINT_PERF
  auto start = std::chrono::high_resolution_clock::now();
#endif

  fastread(&T); // [1, 100000]

  while(T--)
  {
    fastread(&N); // [1, 10]

    for(int i = 0; i < N; ++i)
    {
		fastreadNeg(A + i); // [-9, 9]
    }

	//minResult = MAX_RES;
	//mapCache.clear();

	//debugCalls = 0;
	//debugSkip = 0;
	
	long long minRes = A[0];
	long long maxRes = A[0];

	for(int i = 1; i < N; ++i)
	{
		const long long minm = ((A[i] > 0) ? minRes : maxRes) * A[i];
		const long long mina = minRes + A[i];
		const long long mins = minRes - A[i];
		const long long maxm = ((A[i] > 0) ? maxRes : minRes) * A[i];
		const long long maxa = maxRes + A[i];
		const long long maxs = maxRes - A[i];

		if(minRes > minm) minRes = minm;
		if(minRes > mina) minRes = mina;
		if(minRes > mins) minRes = mins;
		if(maxRes < maxm) maxRes = maxm;
		if(maxRes < maxa) maxRes = maxa;
		if(maxRes < maxs) maxRes = maxs;
	}

	
	//solve(A[0], 1);
    
	
	printf("%lld\n", minRes);
	//printf("%lld - %lld\n", debugCalls, debugSkip);
  }

#ifdef PRINT_PERF
  PrintResultPerf(start);
#endif
#ifdef USE_DATA_TXT
  if(stream)
  {
    fclose(stream);
    stream = NULL;
  }
#endif

  return 0;
}
