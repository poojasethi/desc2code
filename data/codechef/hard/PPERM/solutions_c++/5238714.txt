#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0);cin.tie(0);

using namespace std;


#define ll long long
#define ff first
#define ss second
#define mpa make_pair
#define MOD 1000000007
#define pb push_back
#define lld I64d
#define MXN 1000000

int bitcnt(int mask){return __builtin_popcount(mask);}
int SET(int N,int pos){ return N=N | (1<<pos);}
int RESET(int N,int pos){   return N= N & ~(1<<pos);}
int check(int N,int pos){   return (N & (1<<pos));}
int toggle(int N,int pos){if(check(N,pos))return N=RESET(N,pos);return N=SET(N,pos);}
void PRINTBIT(int N){   printf("("); for(int i=6;i>=1;i--)  {bool x=check(N,i);cout<<x;}    puts(")");}
int mod(int a, int b) { return a - a/b * b;}

bool pri[6 * MXN];
int Sum[6 * MXN];
ll dp[6 * MXN];

void Pre()
{
	int Limit = 6 * MXN;
	for(int i = 2; i * i <= Limit; ++i) {
		if(!pri[i]) {
			for(int j = i * i; j <= Limit; j += i) {
				pri[j] = true;
			}
		}
	}
	
	Sum[2] = 1;
	
	for(int i = 3; i <= Limit; ++i) {
		if(!pri[i]) {
			Sum[i] = Sum[i - 1] + 1;
		} else
			Sum[i] = Sum[i - 1];
	}
}

ll rec(int num)
{
	if(num == 1) {
		return 1;
	}
	
	//cout<<"num => " << num << "\n";
	
	if(dp[num] != -1)
		return dp[num];
	
	ll ans = (1 + Sum[num]) * rec(num - 1);
	if(ans >= MOD)
		ans %= MOD;
	
	return dp[num] = ans;
}

void it()
{
	int Limit = 6 * MXN; 
	dp[1] = 1;
	for(int i = 2; i <= Limit; ++i)  {
		dp[i] = (1 + Sum[i]) * dp[i - 1];
		if(dp[i] >= MOD)
			dp[i] %= MOD;
	}
}

int main()
{
	Pre();
	//memset(dp, -1, sizeof dp);
	it();
	
	int T;
	scanf("%d", &T);
	
	while(T--) {
		int N;
		scanf("%d", &N);
		
		//ll ans = rec(N);
		printf("%lld\n", dp[N]);
	}
	
	return 0;
}