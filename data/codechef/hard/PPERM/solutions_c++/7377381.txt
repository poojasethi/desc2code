#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

inline void fastread(int* a)
{
  register char c = 0;
  while (c < 33)
    c = getchar();
  *a = 0;
  while (c > 33)
  {
    *a = (*a <<1)+(*a<<3) + c - '0';
    c = getchar();
  }
}

int N;
unsigned int cache[5000001];
unsigned int primes[5000001]; // number of primes + 1 in [1, N]

void sieve()
{
  memset(primes, 0, sizeof(primes));
  primes[0] = primes[1] = 1;
  unsigned int *prev = primes + 1;

  unsigned int *pend = primes + 5000001;
  for(unsigned int *pcur = primes + 2; pcur < pend; ++pcur)
  {
    if(*pcur != 0)
    {
      *pcur = *prev;
      continue;
    }

    *pcur = *prev + 1;
    prev = pcur;

    const int prime = pcur - primes;
    for(unsigned int *pnext = pcur + prime; pnext < pend; pnext += prime)
    {
      ++(*pnext);
    }
  }
}


unsigned int solve()
{
  if(cache[N] == 0)
  {
    // Binary search for the first zero cache record that is in [1, N] range
    int l = 1;
    int r = N;
    while(l < r)
    {
      const int mid = (r + l) >> 1;
      if(cache[mid] == 0)
        r = mid;
      else
        l = mid + 1;
    }

    // l should point to the first zero cache record (not calculated value). Now calculate up to N
    for(; l <= N; ++l)
    {
      long long ll = cache[l - 1];
      ll *= primes[l];
      cache[l] = ll % 1000000007;
    }
  }

  return cache[N];
}

int main()
{
  memset(cache, 0, sizeof(cache));
  cache[0] = 1;
  cache[1] = 1;
  sieve();

  int T;
  fastread(&T); // [1, 500000]

  while(T--)
  {
    fastread(&N);

    printf("%u\n", solve());
  }

  return 0;
}
