#include<bits/stdc++.h>
using namespace std;
typedef long long int lli;

#define test()    int test_case;cin>>test_case;while(test_case--)
#define fr(i,n) for(int i=0;i<n;i++)
#define frr(i,a,n) for(int i=a;i<n;i++)
#define sll(a) scanf("%lld",&a)
#define sl(a) scanf("%ld",&a)
#define si(a) scanf("%i",&a)
#define sd(a)  scanf("%ld",&a)
#define sf(a) scanf("%f",&a)
#define rn(a) return a
#define pai pair<int,int>
#define pal pair<li,li>
#define pall pair<lli,lli>
#define ff first
#define ss second
#define mod  1000000007
#define mp make_pair
#define pb push_back
#define pll(a) printf("%lld\n",a)
#define pl(a) printf("%lld\n",a)
#define pi(a) printf("%d\n",a)
#define pd(a) printf("%lf\n",a)
#define pf(a) printf("%f\n",a)
#define lc (start+end)/2
#define rc  lc+1
int   main()
 {
 	  lli      n;
 	   cin>> n;
 	   vector<pall> one,two;
 	   for(lli     i=0;i<n;i++)
 	    {
 	    lli a,b;
 	    cin>>a>>b;
 	       if(a==1)
 	       one.pb(mp(b,a));
 	       else two.pb(mp(b,a));
 	    
		 }
		 
		 sort(one.begin(),one.end());
		 sort(two.begin(),two.end());
		 reverse(one.begin(),one.end());
		 reverse(two.begin(),two.end());
		 
		 vector<pair<pair<lli,lli>,lli> > ans;//ans ,one used,2used
		 
		 lli os=one.size();
		 lli ts=two.size();
		 lli sum=os+2*ts;
		 ans.pb(mp(mp(0,0),0));
		 if(os!=0)
		 ans.pb(mp(mp(one[0].ff,1),0));
		 else
		ans.pb(mp(mp(0,1),0));
		
		 for(lli i=2;i<=sum;i++)
		  {
		   // case 1 using 2
		   lli tu=ans[i-2].ss;
		   lli ou=ans[i-1].ff.ss;
		   lli temp1=0;
		   lli  temp2=0;
		    if(tu<ts)
			{
				temp1=ans[i-2].ff.ff+two[tu].ff;
			}
			if(ou<os)
			    {
				  temp2=ans[i-1].ff.ff+one[ou].ff;
			    }
			if(temp1>=temp2)
				{
					if(temp1>ans[i-1].ff.ff)
				    ans.pb(mp(mp(temp1,ou),tu+1));
				  else// 1 wt had end so temp2=0 , but we can condider last 1 covered as best also 
				  {
				  	ans.pb(mp(mp(ans[i-1].ff.ff,ans[i-1].ff.ss),ans[i-1].ss));
				  }
				}
			else
			 {
			 	if(temp2>ans[i-2].ff.ff)
			   ans.pb(mp(mp(temp2,ou+1),tu));
			   else// 2 wt had end so temp1=0 , but we can condider last 2 covered  as best also 
			   	ans.pb(mp(mp(ans[i-2].ff.ff,ans[i-2].ff.ss),ans[i-2].ss));
			 }
											    
		  }
		 
		 
		  for(lli i=1;i<=sum;i++) cout<<ans[i].ff.ff<<" ";
		  
		  return 0;
 }