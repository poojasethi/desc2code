#include<bits/stdc++.h>
using namespace std;
long long mod=1000000007;
int a[1003],visit[1003],opp[1003]; // op opposite

struct node
{
	int p,q,val;
}arr[1000006];

struct myfun
{
	bool operator() (node a,node b)
	{
		return a.val>b.val;
	}
};
int power(int a,int n)
{
	if(n==1)
	return a;
	
	long long ans=power(a,n/2);
	ans=(ans*ans)%mod;
	if(n%2)
	ans=(ans*a)%mod;
	return ans;
}
int f(int i)
{
	if(i==a[i])
	return a[i];
	
	a[i]=f(a[i]);
	return a[i];
}
void union1(int i,int j)
{
	f(i);
	f(j);
	int mx=max(a[i],a[j]);
	int mn=min(a[i],a[j]);
	a[mx]=a[mn];
}
void init(int m)
{
	for(int i=0;i<=m;++i)
	{a[i]=i;visit[i]=0;}
}
int main()
{
	
	int t,id[1003],i,k,j,m;
	cin>>t;
	while(t--)
	{
		cin>>m;
		init(m);
		for(i=0;i<m;++i)
		cin>>id[i];
		
		k=0;
		for(i=0;i<m;++i)
		for(j=i+1;j<m;++j)
		{
			arr[k].p=i;
			arr[k].q=j;
			arr[k].val=min(power(id[i],id[j]),power(id[j],id[i]));
			k++;
		}
		
		sort(arr,arr+k,myfun());
		
		node x;
		for(i=0;i<k;++i)
		{
			x=arr[i];
			int p=x.p,q=x.q;
			
			if(visit[p]==0 && visit[q]==0)
			{
				visit[p]=1;
				opp[p]=q;
				visit[q]=1;
				opp[q]=p;
			}
			else
			if(visit[p]==1 && visit[q]==0)
			{
				union1(q,opp[p]);
				visit[q]=1;
				opp[q]=p;
			}
			else 
			if(visit[q]==1 && visit[p]==0)
			{
				union1(p,opp[q]);
				visit[p]=1;
				opp[p]=q;
			}
			else
			{
				if(f(p)==f(q))
				{
					cout<<x.val<<'\n';
					break;
				}
				//**********************error may be
				union1(p,opp[q]);
				union1(q,opp[p]);
			}
			
			
		}
		
			
	}
	//min(power(a,b),power(b,a));
}