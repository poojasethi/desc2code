#include <algorithm>
#include <iostream>
#include <cstring>
#include <cassert>
#include <cstdio>

#define MOD (int)((1e9)+7)
#define NMAX 1010

using namespace std;

int exp(int n, int k){
	if(!k) return 1;

	int n2 = exp(n,k>>1);
	n2 = (1LL*n2*n2)%MOD;
	if(k&1) n2 = (1LL*n2*n)%MOD;
	return n2;
}

int adj[NMAX][NMAX];
int lev[NMAX];
int N;
int A[NMAX];

int dfs(int v, int l, int limit){
	int i;

	lev[v] = l;

	for(i = 0; i < N; ++i){
		if(adj[i][v] <= limit) continue;
		if(lev[i] >= 0){
			if(lev[v]^lev[i]) continue;
			return 1;
		}

		if(dfs(i,l^1,limit)) return 1;
	}
	return 0;
}

int is_bipartite(int limit){
	memset(lev,-1,sizeof(lev));
	int i;

	for(i = 0; i < N; ++i){
		if(lev[i] >= 0) continue;
		if(dfs(i,0,limit)) return 0;
	}
	return 1;
}



int binary_search(){
	int low,high,mid;

	low = 0;
	high = MOD-1;

	while(low < high){
		mid = low+(high-low)/2;
		if(is_bipartite(mid)){
			high = mid;
		}else{
			low = mid+1;
		}
	}

	return low;
}


int main(){
	int t,i,j;

	scanf("%d",&t);

	while(t--){
		scanf("%d",&N);
		for(i = 0; i < N; ++i)	scanf("%d",&A[i]);

		for(i = 0; i < N; ++i){
			for(j = i+1; j < N; ++j){
				adj[i][j] = adj[j][i] = min(exp(A[i],A[j]), exp(A[j],A[i]));
			}
		}

		printf("%d\n",binary_search());
	}

	return 0;

}
