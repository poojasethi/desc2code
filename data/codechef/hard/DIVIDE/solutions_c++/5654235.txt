#include<bits/stdc++.h>
#define vi vector<long long int> 
#define pb push_back 
#define mod 1000000007
#define ll long long
using namespace std;

vi graph[1008];
queue<int> q;
int id[1008];
 long long int sim[1008][1008];
bool visited[1008];
bool color[1008];
long long int n;

long long int power( long long int a, long long int b)
{
	if(b==0)
	return 1;
	long long int temp=power(a,b/2)%mod;
	if((b&1)==0)
	{
		return (temp%mod*temp%mod)%mod;
	}
	else
	return ((temp%mod*temp%mod*a)%mod);
}

long long int similarity(long long int x,long long int y)//x y indices
{
	long long int a=id[x];
	long long int b=id[y];
	sim[x][y]=min(power(a,b),power(b,a));
//	printf("a=%d b=%d\t",a,b);
//	printf("%lld ",sim[x][y]);
	sim[y][x]=sim[x][y];
	
	
	
} 

void makegraph( long long int x)
{
	long long int i,j;
	for(i=1;i<n;i++)
	{
		for(j=i+1;j<=n;j++)
		{
			if(sim[i][j]>x)
			{
				graph[i].pb(j);
				graph[j].pb(i);
			}
		}
	}
}

long long int bfs(long long int src)
{
	long long int i;
	visited[src]=1;
	color[src]=1;
	q.push(src);
	long long int v;
	while(!q.empty())
	{
		v=q.front();
		for(i=0;i<graph[v].size();i++)
		{
			if(visited[graph[v][i]]==0)
			{
				visited[graph[v][i]]=1;
				if(color[v]==1)
				{
					color[graph[v][i]]=0;
					q.push(graph[v][i]);
					
				}
				else
				{
					color[graph[v][i]]=1;
					q.push(graph[v][i]);
				}
			
			}
			else
			{
				if(color[graph[v][i]]==color[v])
				{
					return -1;
				}
			}
		}
		q.pop();
		
	}
	return 0;
}

int main()
{
	long long int i,j,k,t,x,y,ans,res;
	long long int low,mid,high;
//	long long int a,b;
//	printf("Enter a b\n");
//	scanf("%d %d",&a,&b);
//	printf("%d",power(a,b));
	scanf("%lld",&t);
	while(t--)
	{
	//	while(!q.empty())
	//	q.pop();
		
		scanf("%lld",&n);
		memset(sim,0,sizeof(sim));
		
		for(i=1;i<=n;i++)
		{
			scanf("%lld",&id[i]);
		}
		
		for(i=1;i<n;i++)
		{
			for(j=i+1;j<=n;j++)
			{
				similarity(i,j);
			}
		//	printf("\n");
		}
	/*	for(i=1;i<n;i++)
		{
			for(j=1;j<=n;j++)
			{
				printf("%d ",sim[i][j]);
			}
			printf("\n");
		}
		*/
		//Binary search
		low=1;
		high=mod-1;
		mid=(low+high)/2;
		x=mid;
		memset(color,0,sizeof(color));
	//	res=x;
		
		while(low<high)
		{
		//	printf("hi");
			while(!q.empty())
			q.pop();
			memset(visited,0,sizeof(visited));
			
			makegraph(x);
			for(i=1;i<=n;i++)
			{
				if(visited[i]==0)
				{
					ans=bfs(i);
					if(ans==-1)
					break;
				}
			}
			//ans=bfs(1);//check wheter bipart is possible
			
			if(ans==-1)//bipartite not possile
			{
			//	printf("hi %d ",x);
				low=mid+1;
				mid=(low+high)/2;
				x=mid;
				
				
			}
			else
			{
			//	printf("hi ");
				res=x;
				high=mid;
				mid=(low+high)/2;
				x=mid;
			}
			for(i=1;i<=n;i++)
			{
				graph[i].clear();
			}
			if(low==high)
			break;
			
		}
		
		if(high>=low)
		printf("%lld\n",x);
	//	else
	//	printf("%lld\n",res);
		
		
		
	}
	return 0;
	
}