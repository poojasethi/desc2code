#include<bits/stdc++.h>
#define vi vector< int> 
#define pb push_back 
#define mod 1000000007
#define ll long long int
using namespace std;

vi graph[1008];
queue<int> q;
int id[1008];
int sim[1008][1008];
bool visited[1008];
bool color[1008];
 int n;
int power(int a,int b)			//a^b mod
{	int ans=1,temp=a;
	while(b>0)
	{	if(!(b&1))
		{	temp=(temp*1LL*temp)%mod;
			b=b>>1;
		}
		else
		{	ans=(ans*1LL*temp)%mod;
			b--;
		}
	}
	return ans;
}
/*
int power(int a,int b)
{
	if(b==0)
	return 1;
	int temp=power(a,(b>>1))%mod;
	if((b&1)==0)
	{
		return (temp*1ll*temp)%mod;
	}
	else
	return ((temp*1ll*temp*a)%mod);
}
*/
 int similarity( int x, int y)//x y indices
{
	 int a=id[x];
	 int b=id[y];
	sim[x][y]=min(power(a,b),power(b,a));
//	printf("a=%d b=%d\t",a,b);
//	printf("%lld ",sim[x][y]);
	sim[y][x]=sim[x][y];
	
	
	
} 

void makegraph(int x)//x is the value to be compared
{
	 int i,j;
	for(i=1;i<n;i++)
	{
		for(j=i+1;j<=n;j++)
		{
			if(sim[i][j]>x)
			{
				graph[i].pb(j);
				graph[j].pb(i);
			}
		}
	}
}

bool bfs( int src)
{
	 int i;
	visited[src]=1;
	color[src]=1;
	q.push(src);
	 int v;
	while(!q.empty())
	{
		v=q.front();
		for(i=0;i<graph[v].size();i++)
		{
			if(visited[graph[v][i]]==0)
			{
				visited[graph[v][i]]=1;
				if(color[v]==1)
				{
					color[graph[v][i]]=0;
					q.push(graph[v][i]);
					
				}
				else
				{
					color[graph[v][i]]=1;
					q.push(graph[v][i]);
				}
			
			}
			else
			{
				if(color[graph[v][i]]==color[v])
				{
					return 1;
				}
			}
		}
		q.pop();
		
	}
	return 0;
}

int main()
{
	 int i,j,k,t,y,ans,res;
	int low,mid,high,x;
//	 int a,b;
//	printf("Enter a b\n");
//	scanf("%d %d",&a,&b);
//	printf("%d",power(a,b));
	scanf("%d",&t);
	while(t--)
	{
	//	while(!q.empty())
	//	q.pop();
		
		scanf("%d",&n);
		memset(sim,0,sizeof(sim));
		
		for(i=1;i<=n;i++)
		{
			scanf("%d",&id[i]);
		}
		
		for(i=1;i<n;i++)
		{
			for(j=i+1;j<=n;j++)
			{
				similarity(i,j);
			}
		//	printf("\n");
		}
	/*	for(i=1;i<n;i++)
		{
			for(j=1;j<=n;j++)
			{
				printf("%d ",sim[i][j]);
			}
			printf("\n");
		}
		*/
		//Binary search
		low=1;
		high=mod-1;
		mid=(low+high)>>1;
		x=mid;
		memset(color,0,sizeof(color));
	//	res=x;
		
		while(low<high)
		{
		//	printf("hi");
			while(!q.empty())
			q.pop();
			memset(visited,0,sizeof(visited));
			
			makegraph(x);
			for(i=1;i<=n;i++)
			{
				if(visited[i]==0)
				{
					ans=bfs(i);
					if(ans==1)
					break;
				}
			}
			//ans=bfs(1);//check wheter bipart is possible
			
			if(ans==1)//bipartite not possile
			{
			//	printf("hi %d ",x);
				low=mid+1;
				mid=(low+high)>>1;
				x=mid;
				
				
			}
			else
			{
			//	printf("hi ");
				res=x;
				high=mid;
				mid=(low+high)>>1;
				x=mid;
			}
			for(i=1;i<=n;i++)
			{
				graph[i].clear();
			}
			if(low==high)
			break;
			
		}
		
		//if(high>=low)
		printf("%d\n",x);
	//	else
	//	printf("%lld\n",res);
		
		
		
	}
	return 0;
	
}