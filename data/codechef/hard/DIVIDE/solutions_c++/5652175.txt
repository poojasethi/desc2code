//Bipartite Graph :-
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<map>
#include<queue>
#include<utility>
#include<cstring>
#include<cmath>
#define LL long long int
#define mod 1000000007
#define vi vector<int>
#define vvi vector < vi >
#define pii pair<int,int>
#define all(c) c.begin(),c.end()
#define sf(n) scanf("%d",&n)
#define sl(n) scanf("%lld",&n)
#define mem(a,val) memset(a,val,sizeof(a))
#define pb push_back
#define f first
#define s second
using namespace std;
LL arr[1005],similar[1050][1050];
bool vis[1005];
queue<int> q;
vector<LL> v[1005];
LL n,col[1005];
LL power(LL a,LL b)			//a^b mod
{	LL ans=1,temp=a;
	while(b>0)
	{	if(!(b&1))
		{	temp=(temp*temp)%mod;
			b=b>>1;
		}
		else
		{	ans=(ans*temp)%mod;
			b--;
		}
	}
	//cout<<"powerrr 2can div "<<q.size()<<endl;
	return ans;
}
void precompute()			//To precompute similar function
{	int i,j;
	for(i=1;i<=1050;i++)
		similar[1][i]=similar[i][1]=1;
	//cout<<"comp 1can div "<<q.size()<<endl;	
	for(i=1;i<=n;i++)
		for(j=i;j<=n;j++)
			similar[i][j]=similar[j][i]=min(power(arr[i],arr[j]),power(arr[j],arr[i]));
	//cout<<"comp 2can div "<<q.size()<<endl;
	/*for(i=1;i<=4;i++)
	{	for(j=1;j<=4;j++)
		{	cout<<similar[i][j]<<"  ";
		}
		cout<<endl;
	}*/
	//cout<<"chk ans"<<similar[1024][1025]<<" "<<similar[2][1024]<<" "<<similar[2][1025]<<endl;
	return ;	
}
bool bfs(int src)
{	int x,i;
	vis[src]=true;
	while(!q.empty())
	{	x=q.front();
		for(i=0;i<v[x].size();i++)
		{	if(!vis[v[x][i]])
			{	vis[v[x][i]]=true;
				col[v[x][i]]=1-col[x];
				q.push(v[x][i]);
			}
			else if(col[v[x][i]]==col[x])
				return false;
		}
		q.pop();
	}
	return true;
}
bool Is_bipartite()
{	int num,x;
	//cout<<"bip ";
	for(num=1;num<=n;num++)
	{	//cout<<"bip ";
		if(!vis[num])
		{	//cout<<"bip ";
			//cout<<"hi "<<q.size()<<endl;
			while(!q.empty()) 
			{	//cout<<"que nt \n";
				q.pop();
			}
			//cout<<"wx bip num"<<q.size()<<endl;
			q.push(num);
			//x=q.front();
			//cout<<"x pushx bip "<<endl;
			col[num]=0;
			//cout<<"cur node num"<<num<<endl;
			if(!bfs(num))
				return false;
			//else
			//	cout<<"yes"<<endl;	
		}
	}
	return true;
}
bool Can_Divide(LL value)
{	int i,j;
	//cout<<"hiiiiican div "<<q.size()<<endl;
	for(i=1;i<=n;i++)
	{	v[i].clear();
		col[i]=-1;
		vis[i]=false;
	}
	
	//To create graph
	for(i=1;i<=n;i++)
	{	for(j=i+1;j<=n;j++)
		{	if(similar[i][j]>value)
			{	v[i].pb(j);
				v[j].pb(i);
			}
		}
	}
	//cout<<"hello";
	// To chk bipartite
	//cout<<"hican div "<<q.size()<<endl;
	return Is_bipartite();
	//return false;
}
void solve()
{	LL low=1,high=mod-1,mid;
	//cout<<"preeeecan div "<<q.size()<<endl;
	precompute();
	//cout<<"solveecan div "<<q.size()<<endl;
	while(low+1<high)
	{	mid=(low+high)>>1;
		//cout<<mid<<endl;
		if(Can_Divide(mid))
			high=mid;
		else
			low=mid;
	}
	if(Can_Divide(low))
		printf("%lld\n",low);
	else
		printf("%lld\n",high);	
}
int main()
{	int t,i,j;
	//precompute();
	sf(t);
	//cout<<"hi "<<q.size()<<endl;
	while(t--)
	{	sf(n);
		for(i=1;i<=n;i++)
			sl(arr[i]);
		//cout<<"hi "<<q.size()<<endl;	
		solve();	
		//cout<<"hi "<<q.size()<<endl;
	}
	return 0;
}
