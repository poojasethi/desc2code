#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <vector>
#include <utility>
#include <set>
#include <map>
#include <iostream>
#include <queue>
#include <climits>

using namespace std;

typedef long long LL;

#define PB push_back
#define FRO freopen("in.txt","r",stdin);

#define CLR(arr) memset( (arr),0,sizeof(arr) );
#define NEG(arr) memset( (arr),-1,sizeof(arr) );

#define X first
#define Y second

#define MP make_pair

#define snuke(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)


typedef pair<int,int> pint;
typedef map<int,int> mint;


long long BigMod ( long long a, long long p, long long m ){
    long long res = 1;
    long long x = a;

    while ( p ){
        if ( p & 1 ){
            res = ( res * x ) % m;
        }
        x = ( x * x ) % m;
        p = p >> 1;
    }

    return res % m;
}


#define SIZE 1010

LL mod = 1e9+7+1e-6;
LL val[SIZE][SIZE];

LL arr[SIZE];
int n;

char vis[SIZE];
vector<int> out[SIZE];

bool checkBipartite(int start){

    //cout<<"sahon\n";

    queue<int> q;

    q.push(start);
    vis[start]=0;
    bool bipartitePossible=true;


    while (!q.empty() && bipartitePossible){
        int tmp=q.front();
        q.pop();


        for (int i=0;i<out[tmp].size();++i){
            if ( vis[ out[tmp][i] ]==-1 ){
                vis[ out[tmp][i] ]=  !vis[tmp];
                q.push( out[tmp][i] );
            }
            else if ( vis[ out[tmp][i] ] ==  vis[tmp]){
                bipartitePossible=false;
                break;
            }
        }
    }
    //cout<<bipartitePossible<<endl;
    return bipartitePossible;
}

bool pos(int x){
    for (int i=0;i<n;++i){
        vis[i] = -1;
        out[i].clear();
    }
    for (int i=0;i<n;++i){
        for (int j=i+1;j<n;++j){
            if ( val[i][j] > x ){
                out[i].PB ( j );
                out[j].PB ( i );
                //cout<<i<<" x "<<j<<endl;
            }
        }
    }

    for (int i=0;i<n;++i){
        if ( vis[i] == -1 ){
            if ( !checkBipartite(i) ){
                return false;
            }
        }
    }
    return true;
}

int main(){

   

    int kase;
    scanf("%d",&kase);

    while ( kase-- ){
        scanf("%d",&n);
        for (int i=0;i<n;++i){
            scanf("%lld",&arr[i]);
        }
        for (int i=0;i<n;++i){
            for (int j=0;j<n;++j){
                val[i][j] = min( BigMod( arr[i],arr[j],mod ) ,BigMod( arr[j],arr[i],mod ) );
                //printf("%10lld",val[i][j]);
            }
            //printf("\n");
        }



        int low = 0,high=mod+100;
        int ans = -1;
        while ( low<=high ){
            int mid = (low+high)/2;
            //cout<<mid<<" "<<pos(mid)<<endl;
            if ( pos( mid ) ){
                ans = mid;
                high= mid-1;
            }else{
                low = mid+1;
            }
        }
        printf("%d\n",ans);
    }

    return 0;
}
