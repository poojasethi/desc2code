#include <stdio.h>
#include <algorithm>
#include <assert.h>
#include <string>
#include <cstring>
#include <map>
#include <set>
#include <vector>
#include <iostream>
#include <queue>
#include <cmath>
using namespace std;

typedef long long LL;
#define tr(container, it)for(typeof(container.begin()) it = container.begin(); it != container.end(); it++)
#define MP make_pair

int GCD (int a, int b) { if (!a) return b; return GCD(b%a, a);}

void init() {
}

const LL P = 1000000007;
#define N_MAX 100009
LL hl[N_MAX];
LL hr[N_MAX];
int ct[N_MAX];
LL PP[N_MAX];
vector<pair<char, int> >I;

int main() {
    PP[0] = 1;
    for (int i = 1; i < N_MAX; i++) {
        PP[i] = PP[i-1] * P;
    }
    int t;
    scanf("%d", &t);
    while (t--) {
        int k;
        scanf("%d", &k);
        LL ans = 0;
        I.clear();
        for (int i = 0; i < k; i++) {
            getchar();
            char ch;
            int a;
            scanf("%c%d", &ch, &a);
            I.push_back(MP(ch, a));
            ans += ((LL)a * (LL)(a+1))/2;
            if (i) ct[i] = ct[i-1] + a;
            else ct[i] = a;
        }

        hl[0] = I[0].first * P + I[0].second;
        for (int i = 1; i < k; i++) {
            hl[i] = hl[i-1] * P + I[i].first;
            hl[i] = hl[i] * P + I[i].second;
        }
        hr[k] = 0;
        for (int i = k-1; i >= 0; i--) {
            hr[i] = hr[i+1] * P + I[i].first;
            hr[i] = hr[i] * P + I[i].second;
        }

        for (int i = 1; i < k; i++) {
            int low = 1, mid, high = i+3, mx = 0;
            while (low <= high) {
                mid = (low + high)>>1;
                if (i - mid < 0 || i + mid >= k) {
                    high = mid - 1;
                    continue;
                }
                LL fwd = hl[i+mid] - hl[i] * PP[mid*2];
                LL bck = hr[i-mid] - hr[i] * PP[mid*2];
                if (fwd == bck) {
                    low = mid + 1;
                    mx = mid;
                } else {
                    high = mid - 1;
                }
            }
            int len = ct[i+mx] - ct[i-mx] + I[i-mx].second;
            len -= I[i].second;
            if (i+mx+1 < k && i-mx-1 >= 0) {
                if (I[i+mx+1].first == I[i-mx-1].first) {
                    len += 2 * min(I[i+mx+1].second, I[i-mx-1].second);
                }
            }
            ans = ans + len/2;

        }
        printf("%lld\n", ans);
    }
    return 0;
}
