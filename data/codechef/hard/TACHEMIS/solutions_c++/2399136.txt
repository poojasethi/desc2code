#include <set>
#include <map>
#include <cmath>
#include <ctime>
#include <queue>
#include <stack>
#include <vector>
#include <string>
#include <cctype>
#include <cstdio>
#include <iomanip>
#include <sstream>
#include <cstdlib>
#include <cassert>
#include <climits>
#include <complex>
#include <numeric>
#include <valarray>
#include <iostream>
#include <string.h>
#include <algorithm>
using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<string> vs;

#define inf 1061109567
#define pb push_back
#define mp make_pair
#define all(a) a.begin(),a.end()
#define mem(x,a) memset(x,a,sizeof(x))
#define rep(i,n) for(int i(0),_n(n);i<_n;++i)
#define repi(i,a,b) for(int i(a),_b(b);i<_b;++i)
#define repr(i,a,b) for(int i(a),_b(b);i>=_b;--i)
#define repe(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();++it)
#define len(x) ((int)(x.size()))

#define DEBUG 1 
#if DEBUG && !ONLINE_JUDGE 
	#define debug(args...) (Debugger()) , args
	class Debugger { public: Debugger(const std::string& _separator = ", ") : first(true), separator(_separator){} template<typename ObjectType> Debugger& operator , (const ObjectType& v) { if(!first) std::cerr << separator; std::cerr << v; first = false; return *this; } ~Debugger() { std::cerr << endl;} private: bool first; std::string separator; }; template <typename T1, typename T2> inline std::ostream& operator << (std::ostream& os, const std::pair<T1, T2>& p) { return os << "(" << p.first << ", " << p.second << ")"; } template<typename T> inline std::ostream &operator << (std::ostream & os,const std::vector<T>& v) { bool first = true; os << "["; for(unsigned int i = 0; i < v.size(); i++) { if(!first) os << ", "; os << v[i]; first = false; } return os << "]"; } template<typename T> inline std::ostream &operator << (std::ostream & os,const std::set<T>& v) { bool first = true; os << "["; for (typename std::set<T>::const_iterator ii = v.begin(); ii != v.end(); ++ii) { if(!first) os << ", "; os << *ii; first = false; } return os << "]"; } template<typename T1, typename T2> inline std::ostream &operator << (std::ostream & os,const std::map<T1, T2>& v) { bool first = true; os << "["; for (typename std::map<T1, T2>::const_iterator ii = v.begin(); ii != v.end(); ++ii) { if(!first) os << ", "; os << *ii ; first = false; } return os << "]"; } 
#else 
		#define debug(args...) 
#endif

vi sum;

//~ int find_longest_palindrome(vector<pair<char,ll> > str){
	//~ int strLength=len(str);
	//~ vector<int> arr;
	//~ int i=0,palLength=0;
	//~ while(i<strLength){
		//~ while(i>palLength&&i<strLength){
			//~ if(str[i-palLength-1]==str[i])palLength+=2,i+=1;
			//~ else break;
		//~ }
		//~ arr.push_back(palLength);
		//~ int s = arr.size() - 2;
		//~ int e = s - palLength;
		//~ bool found = false;
		//~ for (int j = s; j > e; j--) {
			//~ int d = j - e - 1;
			//~ if (arr[j] == d) {
				//~ palLength = d;
				//~ found = true;
			//~ break;
			//~ }
			//~ arr.push_back(min(d,arr[j]));
			//~ }
		//~ if (!found) {
			//~ i += 1;
			//~ palLength = 1;
		//~ }
	//~ }
	//~ arr.push_back(palLength);
	//~ int ret = 0;
	//~ vi tem;
	//~ 
	//~ for (int q = 0; q < (int)arr.size(); q++) {
		//~ 
		//~ if(arr[q])tem.pb(arr[q]);
		//~ 
	//~ }
	//~ 
	//~ 
	//~ int t1,t2;
	//~ 
	//~ rep(i,len(tem)){
		//~ t1=i-tem[i]/2-1;
		//~ t2=i+tem[i]/2+1;
		//~ ret+=sum[i]-sum[t1+1];
		//~ if(t1<0||t2>=len(tem))continue;
		//~ if(str[t1].first==str[t2].first){
			//~ ret+=min(str[t1].second,str[t2].second);
		//~ }
	//~ }
	//~ return ret;
//~ }


//~ ll find_longest_palindrome(vector<pair<char,ll> > str){
	//~ 
	//~ 
	//~ ll ret=0;
	//~ 
	//~ 
	//~ 
	//~ int strLength=len(str);
	//~ vector<int>arr;
	//~ int i=0,palLength=0;
	//~ while(i<strLength){
		//~ while(i>palLength&&i<strLength){
			//~ if(str[i-palLength-1].first==str[i].first&&str[i-palLength-1].second==str[i].second){
				//~ 
				//~ 
				//~ palLength+=2,i+=1;
				//~ 
			//~ }
			//~ else break;
		//~ }
		//~ 
		//~ arr.push_back(palLength);
		//~ 
		//~ int s = arr.size() - 2;
		//~ 
		//~ int e = s - palLength;
		//~ 
		//~ bool found = false;
		//~ 
		//~ for (int j = s; j > e; j--) {
			//~ int d = j - e - 1;
			//~ if (arr[j] == d) {
				//~ palLength = d;
				//~ found = true;
				//~ break;
			//~ }
			//~ arr.push_back(min(d,arr[j]));
		//~ }
		//~ 
		//~ if (!found) {
			//~ i += 1;
			//~ palLength = 1;
		//~ }
	//~ }
	//~ arr.push_back(palLength);
//~ 
	//~ vi tem;
	//~ 
	//~ for (int q = 0; q < (int)arr.size(); q++) {
		//~ 
		//~ if(arr[q])tem.pb(arr[q]);
		//~ 
	//~ }
	//~ 
	//~ 
	//~ int t1,t2;
	//~ 
	//~ rep(i,len(tem)){
		//~ if(tem[i]>=1){
			//~ t1=i-tem[i]/2-1;
			//~ t2=i+tem[i]/2+1;
			//~ ret+=sum[i]-sum[t1+1];
			//~ if(t1<0||t2>=len(tem))continue;
			//~ if(str[t1].first==str[t2].first){
				//~ ret+=min(str[t1].second,str[t2].second);
			//~ }
		//~ }
	//~ }
	//~ return ret;
//~ }





template <class RAI1,class RAI2>
void fastLongestPalindromes(RAI1 seq,RAI1 seqEnd,RAI2 out)
{
	int seqLen=seqEnd-seq;
	int i=0,j,d,s,e,lLen,k=0;
	int palLen=0;
	while (i<seqLen)
	{
		if (i>palLen && seq[i-palLen-1]==seq[i])
		{
			palLen+=2;
			i++;
			continue;
		}
		out[k++]=palLen;
		s=k-2;
		e=s-palLen;
		bool b=true;
		for (j=s; j>e; j--)
		{
			d=j-e-1;
			if (out[j]==d)
			{
				palLen=d;
				b=false;
				break;
			}
			out[k++]=min(d,out[j]);
		}
		if (b)
		{
			palLen=1;
			i++;
		}
	}
	out[k++]=palLen;
	lLen=k;
	s=lLen-2;
	e=s-(2*seqLen+1-lLen);
	for (i=s; i>e; i--)
	{
		d=i-e-1;
		out[k++]=min(d,out[i]);
	}
}





int main(){
	ios_base::sync_with_stdio(0);
	
	int tests;
	cin>>tests;
	
	
	
	for(int t=1;t<=tests;t++){
		vector<pair<char,ll> > vp;
		
		sum.clear();
		sum.pb(0);
		
		char cc;
		ll t1;
		int k;
		cin>>k;
		
		ll ans=0;
		
		rep(i,k){
			
			cin>>cc>>t1;
			ans+=t1*(t1+1)/2;
			sum.pb(sum.back()+t1);
			vp.pb(mp(cc,t1));
			
		}
		vector<int> V(2*len(vp)+1);
		fastLongestPalindromes(vp.begin(),vp.end(),V.begin());
		
		vi tem;
		
		for (int q = 0; q < (int)V.size(); q++) {
			
			if(V[q])tem.pb(V[q]);
			
		}
		
		
		ll t2,ret=0;
		
		rep(i,len(tem)){
			if(tem[i]>=1){
				t1=i-tem[i]/2-1;
				t2=i+tem[i]/2+1;
				ret+=sum[i]-sum[t1+1];
				if(t1<0||t2>=len(tem))continue;
				if(vp[t1].first==vp[t2].first){
					ret+=min(vp[t1].second,vp[t2].second);
				}
			}
		}
		
		ans+=ret;
		
		//~ ans+=find_longest_palindrome(vp);
		
		cout<<ans<<endl;
		
		
	}
	
	
}









