#include <iostream>
#include <vector>
#include <cstdio>
#include <cstring>
#include <string>
#include <cmath>
#include <algorithm>
#include <utility>
#include <stack>
#include <sstream>
#include <list>
#include <map>
#include <queue>
#include <set>
#include <deque>
#include <bitset>
#include <functional>
#include <numeric>
#include <utility>
#include <iomanip>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <climits>
#include <cassert>

using namespace std;

#define FOR(i,a,b)				for (i=a;i<b;i++)
#define s(n)					scanf("%d",&n)
#define p(n)					printf("%d\n",n)
#define pl(n)					printf("%lld\n",n)
#define sd(n)					int n;scanf("%d",&n)
#define sl(n)					scanf("%lld",&n)
#define sld(n)					long long int n;scanf("%lld",&n)
#define pb(n)                                   push_back(n)
#define all(c)                                  (c).begin(),(c).end()
#define tr(container,it)                        for (typeof(container.begin()) it=container.begin();it!=container.end();it++ )
#define sz(a)                                   int((a).size())
#define clr(a)                                  memset(a,0,sizeof(a))
#define mp(a,b)                                 make_pair(a,b)

#define INF                                     INT_MAX
#define UINF                                    UINT_MAX
#define INF_LL                                  LLONG_MAX
#define UINF_LL                                 ULLONG_MAX

typedef long long ll;
typedef vector <int> vi;
typedef vector <vi> vvi;
typedef vector <string> vstr;
typedef pair<int,int> pii;
typedef vector<vector<pair<int,int> > > TG;

//modified manachers
//returns q
vi manachers(vector<char> c,vi arr )
{
    //taken from http://leetcode.com/2011/11/longest-palindromic-substring-part-ii.html
    int n=sz(arr),i;
    //preprocessing starts
    
    //preprocessing ends
    int C=-1,R=-1;
    vi P(n);
    vi Q(n,0);
    FOR(i,0,n)
    {
        int i_mirror=C+C-i;
        P[i]=i<R?min(P[i_mirror],R-i):0;
        while (i+P[i]+1<n&&i-P[i]-1>=0&&arr[i+P[i]+1]==arr[i-P[i]-1]&&c[i+P[i]+1]==c[i-P[i]-1]) P[i]++;
        if (i+P[i]>R)
        {
            R=i+P[i];
            C=i;
        }
    }
    //filling Q
    vi sum(n,0);
    sum[0]=arr[0];
    FOR(i,1,n) sum[i]=sum[i-1]+arr[i];
    FOR(i,0,n)
    {
        int p=P[i];
        int lo=i-p,hi=i+p;
        lo=lo==0?0:sum[lo-1];
        hi=sum[hi];
        Q[i]=hi-lo;
        if (i+p<n-1&&i-p>0)
        {
            if (c[i+p+1]==c[i-p-1]) Q[i]+=(2*min(arr[i+p+1],arr[i-p-1]));
        }
    }
    return Q;
}

vector<string> &split(string &s, char delim, vector<string> &elems) {
    stringstream ss(s);
    string item;
    while(getline(ss, item, delim)) {
        elems.push_back(item);
    }
    return elems;
}


vector<string> split(string &s, char delim) {
    vector<string> elems;
    return split(s, delim, elems);
}

int str2int(string s)
{
    istringstream buffer(s);
    int ans;
    buffer>>ans;
    return ans;
}

int ceil(int a,int b)
{
    return (a+b-1)/b;
}
int main()
{
    sd(T);
    int t;
    int i,j;
    FOR(t,0,T)
    {
        int k;
        scanf("%d",&k);
        vector<char> c(k);
        vi arr(k);
        string tmp;
//        getline(cin,tmp);
        FOR(i,0,k)
        {
//            p(i);
            char ch; int ti;
            scanf("\n%c %d",&ch,&ti);
            c[i]=ch;
            arr[i]=ti;
        }
        
        vi Q=manachers(c,arr);
//        FOR(i,0,k) printf("%d ",Q[i]);
//        printf("\n");
        ll ans=0;
        FOR(i,0,k)
        {
            int num=arr[i];
            ans+=((ll)num*(num+1))/2;
            ans+=(ll)ceil(Q[i],2);
            ans-=(ll)ceil(num,2);
        }
        pl(ans);
    }
}
//TLE on first submission - maybe because of getline. Using scanf instead. (note the unusual usage)