#include<bits/stdc++.h>

using namespace std;

// Shortcuts for "common" data types in contests
typedef long long int ll;
typedef vector<int> vi;
typedef pair<int, int> ii;
typedef vector<ii> vii;
typedef set<int> si;
typedef map<string, int> msi;
// To simplify repetitions/loops, Note: define your loop style and stick with it!
#define s(i) scanf("%d",&i)
#define sl(i) scanf("%ld",&i)
#define sll(i) scanf("%lld",&i)
#define REP(i, a, b) \
for (int i = int(a); i <= int(b); i++) // a to b, and variable i is local!
#define TRvi(c, it) \
for (vi::iterator it = (c).begin(); it != (c).end(); it++)
#define TRvii(c, it) \
for (vii::iterator it = (c).begin(); it != (c).end(); it++)
#define TRmsi(c, it) \
for (msi::iterator it = (c).begin(); it != (c).end(); it++)
#define INF 2000000000 // 2 billion
// If you need to recall how to use memset:
#define MEMSET_INF 127 // about 2B
#define MEMSET_HALF_INF 63 // about 1B
//memset(dist, MEMSET_INF, sizeof dist); // useful to initialize shortest path distances
//memset(dp_memo, -1, sizeof dp_memo); // useful to initialize DP memoization table
//memset(arr, 0, sizeof arr); // useful to clear array of integers

bool firc = false;
vi mat[509];
string p[509] , t;
int m[509] , n , diff[509] , b[509][100009] , dp[509][100009] , pats , sta[509];

void kmpreprocess(int no)
{
    m[no] = p[no].length();
    int i = 0,j = -1;b[no][0] = -1;
    while(i < m[no])
    {
        while( j >=0 && p[no][i] != p[no][j] ) j = b[no][j];
        i++;j++;
        b[no][i] = j;
    }
}

void kmpsearch( int no )
{
    int i = 0,j = 0;
    while( i < n )
    {
        while( j >=0 && t[i] != p[no][j] ) j = b[no][j];
        i++;j++;
        if( j == m[no])
        {
            mat[no].push_back( i - j );
            j = b[no][j];
        }
    }
}

int memoize( int no , int idx )
{
    //cout << no << " " << idx << endl;
    if( no == pats )
        return idx;
    if( dp[no][idx] != -1 )
        return dp[no][idx];
    int ans = INF;
    vi::iterator it = lower_bound( mat[no].begin() , mat[no].end() , idx );
    if( it != mat[no].end() )
    {
        ans = min( ans , memoize( no + 1 , *it + m[no] ) );
        if( no != 0 || firc )
            ans = min( ans , memoize( no , idx + 1 ) ) ;
    }
    return dp[no][idx] = ans;
}

void init()
{
    REP( i , 0 , n + 1)
        REP( j , 0 , pats + 1)
            dp[j][i] = -1;
    REP( j , 0 , pats  )
    {
        p[j] = "";
        mat[j].clear();
    }
    pats = 0;
    firc = false;
}

int main()
{
    //freopen("input.txt","r",stdin);
    //freopen("output.txt","r",stdout);
    memset( dp , -1 , sizeof(dp) ) ;
    int T ; s(T) ;
    while( T-- )
    {
        string str;
        cin >> str;
        firc = ( str[0] == '*' );
        int len = str.length() , i = 0 ;
        while( i < len )
        {
            while( i < len && str[i] == '*' )
                i++;
            if( i < len && str[i] != '*' )
            {
                sta[pats] = i;
                while( i < len && str[i] != '*')
                {
                    p[pats] += str[i];
                    i++;
                }
                pats++;
            }
        }
        cin >> t;
        n = t.length();
        REP( i , 0 , pats - 1 )
        {
            kmpreprocess( i );
            kmpsearch( i );
            diff[i] = sta[i];
            if( i - 1 >= 0 )
                diff[i] -= ( sta[i - 1] +  m[i - 1] );
        }
        REP( i , 0 , n  - 1 )
        {
            if( pats == 0 )
                printf("%d ",i + 1);
            else if( memoize(0 , i) != INF )
                printf("%d ",memoize( 0 , i ));
            else
                printf("-1 ");
        }
        printf("\n");
        init();
    }
    return 0;
}
