/* Jai Gupta */
#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <queue>
#include <string>
#include <cstring>
#include <map>
#include <cstdlib>
#include <algorithm>
#include <list>
#include <deque>
#include <bitset>
#include <cmath>
#include <functional>
#include <set>

using namespace std;

#define INT_MAX 2147483647
#define INT_MIN -2147483648
#define uint unsigned int
#define MAX(a,b)   (((a)>(b))?(a):(b))
#define MIN(a,b)   (((a)<(b))?(a):(b))
#define CMAX(a,b)  if((a)<(b)) a=b
#define CMIN(a,b)  if((a)>(b)) a=b
#define FOR(i,a,b)   for(i=a; i<b; i++)
#define REVI(i,a,b)  for(int i= a ; i >= b ; --i)
#define LET(x,a)     __typeof(a) x(a)
#define IFOR(i,a,b)  for(LET(i,a);i!=(b);++i)
#define EACH(it,v)   IFOR(it,v.begin(),v.end())
#define SWAP(a,b,t)  t=a,a=b,b=t
#define REP(i,n)     for(int i=0; i<n; i++)
#define ll           long long int
#define ull          unsigned long long int
#define gint(t)      scanf("%d", &t);
#define pint(t)      printf("%d\n", t);
#define pb           push_back

#ifdef JAI_ARENA
#define debug(args...) {dbg,args; cerr<<endl;}
#define dline cerr<<endl
#else
#define debug(args...) {};
#endif

typedef pair<int, int>  pii;
typedef vector<int>     vi;
typedef vector<vi>      vii;
typedef vector<pii>     vpii;

struct debugger
{
    template<typename T> debugger& operator , (const T& v)
	{
	    cerr<<v<<" ";
	    return *this;
	}
} dbg;


#define BUF 4096
char ibuf[BUF];
int ipt = BUF;
 
int readInt() {
    while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    if (ipt == BUF) {
	fread(ibuf, 1, BUF, stdin);
	ipt = 0;
	while (ipt < BUF && ibuf[ipt] < '0') ipt++;
    }
    int n = 0;
    while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    if (ipt == BUF) {
	fread(ibuf, 1, BUF, stdin);
	ipt = 0;
	while (ipt < BUF && ibuf[ipt] >= '0') n = (n*10)+(ibuf[ipt++]-'0');
    }
    return n;
}


/* memset(start*, byteVal, numBytes);
 *  memcpy(dst*, src*, numBytes);
 */

vpii e[65540];
char col[65540];
vector<ll> dis;
int n;
char bfs(int start) {
    dis.resize(n);
    queue<int> tr;
    tr.push(start);
    col[start] = 1;
    dis[start] = 0;
    while(!tr.empty())
    {
	int a = tr.front(), d = dis[a]+1;
	IFOR(i,0,e[a].size())
	{
	    if(col[e[a][i].first] == 0)
	    {
		dis[e[a][i].first] = dis[a]+e[a][i].second;
		debug("setting dis of ", e[a][i].first, "to", dis[e[a][i].first]);
		tr.push(e[a][i].first);
		col[e[a][i].first] = 1;
	    }
	    else if(dis[e[a][i].first] != dis[a] + e[a][i].second) {
		debug(i, a, e[a][i].first, "failed", dis[e[a][i].first], dis[a], e[a][i].second);
		return 0;
	    }
	}
	tr.pop();
    }
    return 1;
}
int main()
{
    gint(n);
    n++;
    memset(col, 0, n*sizeof(char));
    int m; gint(m);
    REP(mi, m)
    {
	int s; gint(s);
	int t; gint(t);
	int w; gint(w);
	pii a(t, w);
	pii b(s-1, -w);
	e[s-1].pb(a);
	e[t].pb(b);
    }
    REP(ni, n)
    {
	if(col[ni] == 0)
	if( !bfs(ni))
	{
	    printf("-1\n"); return 0;
	}
    }
    printf("%lld", dis[1]-dis[0]);
    IFOR(ni, 2, n)
    {
	printf(" %lld", dis[ni] - dis[ni-1]);
    }
    printf("\n");
    return 0;
}
