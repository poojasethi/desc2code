/*
 * Restore the Recipe
 * File:   RSRECIPE.cpp
 * Author: Andy Y.F. Huang
 * Created on April 16, 2013, 7:59 PM
 */

#include <algorithm>
#include <bitset>
#include <cassert>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <complex>
#include <deque>
#include <fstream>
#include <functional>
#include <iomanip>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <valarray>
#include <vector>

#ifdef AZN
#include "Azn.cpp"
#endif

using namespace std;

namespace RSRECIPE {

template <class T, size_t MAXV, size_t MAXE> struct Graph {
  int last[MAXV], to[MAXE], pred[MAXE];
  T edge[MAXE];
  int cnt;

  void init() {
    memset(last, -1, sizeof (last));
    cnt = 0;
  }

  void addedge(int a, int b, const T & c) {
    to[cnt] = b;
    edge[cnt] = c;
    pred[cnt] = last[a];
    last[a] = cnt++;
  }

  class iterator {
    Graph* g;
    int e;
  public:
    int from, to;

    iterator() : g(NULL), e(-1), from(-1), to(-1) { }

    iterator(Graph* g, int v) : g(g), e(g->last[v]), from(v), to(g->to[e]) { }

    iterator& operator++() {
      e = g->pred[e];
      to = g->to[e];
      return *this;
    }

    bool end() {
      return e == -1;
    }

    T* operator->() {
      return &(g->edge[e]);
    }

    T& operator*() {
      return (g->edge[e]);
    }

  } ;

  iterator begin(int v) {
    return iterator(this, v);
  }
} ;

template <class T, size_t MAXSIZE> struct Queue {
  T q[MAXSIZE], *qf, *qb;

  Queue() : qf(q), qb(q) { }

  void clear() {
    qf = qb = q;
  }

  void push(T val) {
    *qb++ = val;
  }

  bool empty() {
    return qf >= qb;
  }

  int size() {
    return qb - qf;
  }

  void pop() {
    qf++;
  }

  T front() {
    return *qf;
  }

} ;


#define MAXV 66666
#define MAXE 400100
#define INF (1LL << 60)
Graph<int, MAXV, MAXE> net;
Graph<int, MAXV, MAXE>::iterator it;
Queue<int, MAXV> que;
typedef long long llong;
llong ans[MAXV];

void solve(int test_num) {
  net.init();
  int vertices, edges;
  scanf("%d %d", &vertices, &edges);
  for (int e = 0; e < edges; e++) {
    int a, b, sum;
    scanf("%d %d %d", &a, &b, &sum);
    net.addedge(a - 1, b, sum);
    net.addedge(b, a - 1, -sum);
  }
  memset(ans, 0x3F, sizeof (ans));
  bool ok = true;
  for (int v = 0; v <= vertices; v++) {
    if (ans[v] >= INF) {
      que.clear();
      que.push(v);
      ans[v] = 0;
      for (int cur; !que.empty(); que.pop()) {
        cur = que.front();
        for (it = net.begin(cur); !it.end(); ++it) {
          if (ans[it.to] < INF && ans[cur] + *it != ans[it.to]) {
            ok = false;
            goto end;
          }
          if (ans[it.to] >= INF) {
            ans[it.to] = ans[cur] + *it;
            que.push(it.to);
          }
        }
      }
    }
  }
end:
  if (!ok)
    puts("-1");
  else
    for (int v = 1; v <= vertices; v++)
      printf("%lld\n", ans[v] - ans[v - 1]);
}

void solve() {
  #ifdef AZN
  freopen("input.txt", "r", stdin);
  freopen("output.txt", "w", stdout);
  freopen("azn.txt", "w", stderr);
  #endif
  solve(1);
}
}

int main() {
  RSRECIPE::solve();
  return 0;
}

