#include <stdio.h>
#include <algorithm>
#include <vector>
#include <stack>

/* given any string of left and right parens, after removing all matching left
   and right parens, what remains is a string consisting of some number of 
   left parans followed by some number of right parens */
struct ReducedStr1 {
  int left_count;
  int right_count;
  ReducedStr1(char paren = 0) : 
    left_count((paren == '(') ? 1 : 0),
    right_count((paren == ')') ? 1 : 0)
  {} 
};

ReducedStr1 operator+(ReducedStr1 a, ReducedStr1 b) {
  ReducedStr1 ret;
  int cancelled = std::min(a.left_count, b.right_count);
  ret.left_count = a.left_count + b.left_count - cancelled;
  ret.right_count = a.right_count + b.right_count - cancelled;
  return ret;
} 

struct ReducedStr {
  ReducedStr1 forward, reverse;
  ReducedStr(char paren = 0) : forward(paren), reverse(paren) {}
};

ReducedStr operator+(ReducedStr a, ReducedStr b) {
  ReducedStr ret;
  ret.forward = a.forward + b.forward;
  ret.reverse = b.reverse + a.reverse;
  return ret;
}

struct Node;

struct AncestorInfo {
  Node* n;
  ReducedStr str; // path string to n (not including paren at n)
  AncestorInfo(Node* n, ReducedStr str) : n(n), str(str) {}
};

struct Node {
  char paren;  // ')' or '('
  std::vector<AncestorInfo> anc; // anc[i] is 2^i hops toward the root
  std::vector<Node*> adj; // list of adjacent nodes
  int level;
  Node() : paren(0) {}
  Node* find_ancestor_at_level(int level, ReducedStr& str)
  {
    if (this->level <= level) return this;
    int i;
    for (i=0;i<anc.size();i++)
      if (anc[i].n->level <= level) break;
    if (i != anc.size() && anc[i].n->level == level) {
      str = str + anc[i].str;
      return anc[i].n;
    }
    str = str + anc[i-1].str;
    return anc[i-1].n->find_ancestor_at_level(level, str);
  }
};

Node* find_common_ancestor(Node* u, Node* v, ReducedStr& s, ReducedStr& t)
{
  if (u == v) return u;
  int i;
  for (i=0;i<u->anc.size();i++)
    if (u->anc[i].n == v->anc[i].n) break;
  if (i==0) {
    s = s + u->anc[0].str;
    t = t + v->anc[0].str;
    return u->anc[i].n;
  }
  s = s + u->anc[i-1].str;
  t = t + v->anc[i-1].str;
  return find_common_ancestor(u->anc[i-1].n, v->anc[i-1].n, s, t);
}

int is_balanced(Node *u, Node* v)
{
  ReducedStr s, t;
  if (u->level > v->level)
    u = u->find_ancestor_at_level(v->level, s);
  else if (v->level > u->level)
    v = v->find_ancestor_at_level(u->level, t);

  Node* w = find_common_ancestor(u,v,s,t);

  ReducedStr1 path = s.forward + w->paren + t.reverse;
  return (!path.left_count && !path.right_count);
}
 
void make_tree(Node* root)
{
  std::stack<Node*> st;
  st.push(root);
  root->level = 0;
  while (!st.empty()) {
    Node* u = st.top();
    st.pop();
    for (int j=0;j<u->adj.size();j++) {
      Node* v = u->adj[j];
      if (v == root || !v->anc.empty()) continue;
      v->anc.push_back(AncestorInfo(u, ReducedStr(v->paren)));
      Node* w = u;
      for (int k=1;k <= w->anc.size();k++) {
        Node* x = w->anc[k-1].n;
        v->anc.push_back(
          AncestorInfo(x, v->anc[k-1].str + w->anc[k-1].str));
        w = x;
      }
      v->level = u->level + 1;
      st.push(v);
    }
  }
}

int main()
{
  int T;

  scanf("%d\n", &T);
  for (int i=0;i<T;i++) {
    int N, Q;
    scanf("%d %d\n", &N, &Q);
    std::vector<Node> tree(N);
    for (int j=0;j<(N-1);j++) {
      int u, v;
      scanf("%d %d\n", &u, &v);
      --u; --v;
      tree[u].adj.push_back(&tree[v]);
      tree[v].adj.push_back(&tree[u]);
    }
    for (int j=0;j<N;j++) {
      char c;
      scanf(j == (N-1) ? "%c\n" : "%c ", &c);
      tree[j].paren = c;
    }
    make_tree(&tree[0]);
    for (int j=0;j<Q;j++) {
      int u, v;
      scanf("%d %d\n", &u, &v);
      --u; --v;
      printf("%s\n", is_balanced(&tree[u], &tree[v]) ? "Yes" : "No");
    }
  } 
  return 0;
}
