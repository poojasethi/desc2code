# include <iostream>
# include <cstdio>
# include <vector>
# include <set>
# include <map>
# include <bitset>
# include <algorithm>
# include <string>
# include <cstring>
# include <sstream>
# include <cstdlib>
# include <queue>
# include <stack>
using namespace std;
# define MAXN 100100
# define MAXQ 100100
# define INF 10000000000LL


struct node
{
  vector<int> T;
  vector<long long> m1;
  vector<long long> m2;
};


node M[3 * MAXN];
long long Arr[MAXN];
int n;
long long MOD;
int A,B,C,D;
node st[MAXQ];
int pos;
long long val;
int start, end;
int cq,t;

pair<long long, long long> merge(pair<long long, long long> p1, pair<long long, long long> p2)
{
  long long A[4];
  A[0] = p1.first;
  A[1] = p2.first;
  A[2] = p1.second;
  A[3] = p2.second;

  sort(A, A + 4);
  return pair<long long, long long>(A[3], A[2]);
}


void func(int idx, int Left, int Right)
{

  pair<long long, long long> p1(M[Left].m1.back(), M[Left].m2.back());
  pair<long long, long long> p2(M[Right].m1.back(), M[Right].m2.back());
  pair<long long, long long> p = merge(p1, p2);

  M[idx].T.push_back(cq);
  M[idx].m1.push_back(p.first);
  M[idx].m2.push_back(p.second);
}



void build(int idx, int lo, int hi)
{
  if(lo > hi) return;

  if(lo == hi)
    {
      M[idx].T.push_back(0);
      M[idx].m1.push_back( Arr[lo] );
      M[idx].m2.push_back( -INF );
      return;
    }

  
  int Left = 2 * idx + 1;
  int Right = 2 * idx + 2;
  int mid = (lo + hi) / 2;
  
  build(Left, lo, mid);
  build(Right, mid + 1, hi);
  func(idx, Left, Right);
  //printf("%d %d %lld %lld\n",lo, hi, M[idx].m1[0], M[idx].m2[0]); 
}


void update(int idx, int lo, int hi)
{
  if(lo > hi) return;

  if(lo > pos || hi < pos) return;

  if(lo == hi)
    {
      M[idx].T.push_back(cq);
      M[idx].m1.push_back(val);
      M[idx].m2.push_back( -INF );
      return;
    }
  
  int Left = 2 * idx + 1;
  int Right = 2 * idx + 2;
  int mid = (lo + hi) / 2;
  update(Left, lo, mid);
  update(Right, mid + 1, hi);

  func(idx, Left, Right);
  //printf("%d %d %lld %lld\n", lo, hi, M[idx].m1.back(), M[idx].m2.back());
}


pair<long long, long long> query(int idx, int lo, int hi)
{
  if(lo > hi) return pair<long long, long long>(-INF, -INF);

  if(lo > end || hi < start) return pair<long long, long long>(-INF, -INF);

  if(lo >= start && hi <= end)
    {
      int i;
      vector<int>::iterator vi = upper_bound(M[idx].T.begin(), M[idx].T.end(), t); 
      i = (int)(vi - M[idx].T.begin());
      i--;				     
      long long m1 = M[idx].m1[i];
      long long m2 = M[idx].m2[i];
      return pair<long long, long long>(m1, m2);
    }

    
  int Left = 2 * idx + 1;
  int Right = 2 * idx + 2;
  int mid = (lo + hi) / 2;

  pair<long long, long long> p1, p2;
  p1 = query(Left, lo, mid);
  p2 = query(Right, mid + 1, hi);

  return merge(p1, p2);
}


int main()
{
  int i,q;
  pair<long long, long long> p;
  long long R1, R2;

  scanf("%d %lld %d %d %d %d", &n, &MOD, &A, &B, &C, &D);
  for(i = 0; i < n; i++)
    scanf("%lld", &Arr[i]);
  
  cq = 0;
  build(0, 0, n - 1);

  scanf("%d", &q);
  R1 = 0;
  R2 = 0;
  for(i = 1; i <= q; i++)
    {
      cq = i;
      t = (A * R1 + D) % i;
      //printf("\nQuery: %d\n", t);
      scanf("%d %d", &start, &end);

      p = query(0, 0, n - 1);
      R1 = p.first;
      R2 = p.second;

      printf("%lld %lld\n", R1, R2);

      pos = (B * R1 + D) % n;
      val = (C * R2 + D) % MOD;

      //printf("\n%d %lld\n", pos, val);
      update(0, 0, n - 1);
    }
  

  return 0;
}
