// In the name of GOD
// Learnt a nice concept
// Persistent Segment Trees
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define mp make_pair
#define pii pair<int,int>
#define pb push_back 
#define MAXN 100010
#define f first
#define s second
struct node
{
	node *l;
	node *r;
	pii m;
	node() { l=NULL;r=NULL;m=mp(-1,-1);}	
};
node* ro[MAXN];
int n,m,a,b,c,d;
int e[MAXN];
pii maxi(pii a,pii b)
{
	if(a.f>b.f)
		return mp(a.f,max(b.f,a.s));
	else
		return mp(b.f,max(a.f,b.s));
}
node *build(int i,int j)
{
	node * t=new node();
	if(i==j)
	{
		t->m=mp(e[i],-1);
		return t;
	}
	t->l=build(i,(i+j)>>1);
	t->r=build(((i+j)>>1)+1,j);
	t->m=maxi(t->l->m,t->r->m);
	return t;
}
pii find(node * idx,int lo,int hi,int i,int j)
{
	if((lo>j) || (hi<i))	return mp(-1,-1);
	if(lo>=i && hi<=j)	return idx->m;
	return maxi(find(idx->l,lo,(lo+hi)>>1,i,j),find(idx->r,((lo+hi)>>1)+1,hi,i,j));
}
node * update(node * idx,int lo,int hi,int i,int val)
{
	node *t=new node();
	if(lo==hi)
	{
		t->m=mp(val,-1);
		return t;
	}
	int mid=(lo+hi)>>1;
	if(i<=mid)
	{
		t->r=idx->r;
		t->l=update(idx->l,lo,mid,i,val);
	}
	else 
	{
		t->l=idx->l;
		t->r=update(idx->r,mid+1,hi,i,val);
	}
	t->m=maxi(t->l->m,t->r->m);
	return t;
}
int main()
{
	scanf("%d%d%d%d%d%d",&n,&m,&a,&b,&c,&d);
	for(int i=0;i<n;i++)
		scanf("%d",&e[i]);
	ro[0]=build(0,n-1);
	int q;scanf("%d",&q);
	pii rp=mp(0,0);
	for(int tc=1;tc<=q;tc++)
	{
		int t=(int)((a*1LL*rp.f+d)%tc);
		int i,j;scanf("%d%d",&i,&j);
		rp=find(ro[t],0,n-1,i,j);
		printf("%d %d\n",rp.f,rp.s);
		int idx=(int)((b*1LL*rp.f+d)%n);
		int val=(int)((c*1LL*rp.s+d)%m);
		ro[tc]=update(ro[tc-1],0,n-1,idx,val);
	}
	return 0;
}