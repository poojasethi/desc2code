#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <string>
#include <iostream>
#include <vector>
#include <map>
#include <utility>
#include <algorithm>
#include <queue>
#include <set>
#include <stack>
#include <list>

using namespace std;

//GyS Loves Algorithm
#define X first
#define Y second
#define all(x) x.begin(), x.end()
#define mk(x, y) make_pair(x, y)
#define pb(x) push_back(x)
#define rep(x, n) for (int x = 0; x < n; x++)
#define range(x, a, b)for (int x = a; x <= b; x++)
#define sz(x) x.size()
#define setv(x, y) memset(x, y, sizeof(x))
#define repi(it, x) for (typeof(x.begin()) it = x.begin(); it != x.end(); ++it)
#define pl() printf("\n")

typedef long long ll;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
const int inf = 1 << 30;

struct NODE {
	int l, r;
	int R1, R2;
	NODE *lc, *rc;
};


NODE *rt[1000100];
NODE nodes[1000100];
int tot;
int V[100100];

void init()
{
	tot = 0;
}

void gao(NODE *root)
{
	if (root->l == root->r) {
		root->R1 = V[root->l];
		root->R2 = -inf;
	} else {
		root->R1 = max(root->lc->R1, root->rc->R1);
		root->R2 = max(min(root->lc->R1, root->rc->R1), max(root->lc->R2, root->rc->R2));
	}
}

void build(NODE *root, int l, int r)
{
	root->l = l;
	root->r = r;
	if (l < r) {
		root->lc = nodes + ++tot;
		build(root->lc, l, (l + r) / 2);
		root->rc = nodes + ++tot;
		build(root->rc, (l + r) / 2 + 1, r);
	}
	gao(root);
}

void query(NODE *root, int l, int r, int &R1, int &R2)
{
	if (root->l == l && root->r == r) {
		R1 = root->R1;
		R2 = root->R2;
		return;
	}
	int mid = (root->l + root->r) / 2;
	if (r <= mid) {
		query(root->lc, l, r, R1, R2);
	} else if (l >= mid + 1) {
		query(root->rc, l, r, R1, R2);
	} else {
		int lR1, lR2, rR1, rR2;
		query(root->lc, l, mid, lR1, lR2);
		query(root->rc, mid + 1, r, rR1, rR2);
		R1 = max(lR1, rR1);
		R2 = max(min(lR1, rR1), max(lR2, rR2));
	}
}

NODE *update(NODE *root, int x, int v)
{
	if (root->l == x && root->r == x) {
		NODE *nt = nodes + ++tot;
		memcpy(nt, root, sizeof(NODE));
		nt->R1 = v;
		return nt;
	}
	int mid = (root->l + root->r) / 2;
	NODE *ret, *nt;
	if (x <= mid) {
		ret = update(root->lc, x, v);
		nt = nodes + ++tot;
		memcpy(nt, root, sizeof(NODE));
		nt->lc = ret;
	} else {
		ret = update(root->rc, x, v);
		nt = nodes + ++tot;
		memcpy(nt, root, sizeof(NODE));
		nt->rc = ret;
	}
	gao(nt);
	return nt;
}

int main()
{
	int n, m, A, B, C, D;


	scanf("%d%d%d%d%d%d", &n, &m, &A, &B, &C, &D);

	rep(i, n) {
		scanf("%d", &V[i]);
	}

	int Q;
	scanf("%d", &Q);
	init();
	rt[0] = nodes;
	build(rt[0], 0, n - 1);
	int R1 = 0, R2 = 0;
	range(i, 1, Q) {
		int x, y;
		int t = ((ll)A * R1 + D) % i;
		scanf("%d%d", &x, &y);
		query(rt[t], x, y, R1, R2);
		printf("%d %d\n", R1, R2);
		rt[i] = update(rt[i - 1], ((ll)B * R1 + D) % n, ((ll)C * R2 + D) % m);
	}
	return 0;
}
