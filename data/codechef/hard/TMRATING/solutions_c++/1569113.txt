#include <iostream>
#include <vector>
#include <cmath>
#include <cstdlib>
#include <algorithm>
 
using namespace std;
#define pair pair<int, int>
const int NOVALUE = -1;
const int MAXN = 100001;
int startValues[MAXN];
 
 
pair greatest(pair a, pair b) {
	vector<int> vals;
	vals.resize(4);
	vals[0] = a.first; vals[1] = a.second;
	vals[2] = b.first; vals[3] = b.second;
	sort(vals.begin(), vals.end());
	return make_pair(vals[3], vals[2]);
}
 
class vertex 
{
public:
	vertex * left, * right;
	pair value;
 
	vertex(pair pvalue) : left(NULL), right(NULL), value(pvalue) {	}
 
	vertex(vertex * pleft, vertex * pright) : left(pleft), right(pright) {
		value = greatest(left -> value, right -> value);
	}
};
 
vertex* build(int fromV, int toV) {
	if (fromV == toV) {
		return new vertex(make_pair(startValues[fromV], NOVALUE));
	}
	else {
		int mediumV = (fromV + toV) / 2;
		return new vertex(build(fromV, mediumV), build(mediumV + 1, toV));
	}
}
 
pair get(vertex* tree, int fromV, int toV, int left, int right) {
	if (fromV > toV) {
		return make_pair(NOVALUE, NOVALUE);
	}
 
	if ((fromV == left) && (toV == right)) {
		return tree -> value;
	}
 
	int mediumV = (left + right) / 2;
	return greatest(get(tree -> left, fromV, min(mediumV, toV), left, mediumV), 
					get(tree -> right, max(mediumV + 1, fromV), toV, mediumV + 1, right));
}
 
vertex* update(vertex* tree, int fromV, int toV, int newValue, int index) {
 
	if (fromV == toV) {
		return new vertex(make_pair(newValue, NOVALUE));
	}
 
	int mediumV = (fromV + toV) / 2;
	if (index <= mediumV) {
		return new vertex(update(tree -> left, fromV, mediumV, newValue, index), tree -> right);
	}
	else {
		return new vertex(tree -> left, update(tree -> right, mediumV + 1, toV, newValue, index));
	}
}
 
int main() {
	#ifndef ONLINE_JUDGE
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);
	#endif
 
	int num, m;
	long long A, B, C, D;
	cin >> num >> m >> A >> B >> C >> D;
	for (int i = 0; i < num; i++)
		cin >> startValues[i];
 
	vector<vertex*> roots;
	roots.push_back(build(0, num - 1));
	
	int queryNum;
	cin >> queryNum;
 
	pair answer = make_pair(0, 0);
	for (int K = 1; K <= queryNum; K++) {
		int fromV, toV;
		int rootNum = (A * answer.first + D) % K;
		
		cin >> fromV >> toV;
		answer = get(roots[rootNum], fromV, toV, 0, num - 1);
 
		cout << answer.first << " " << answer.second << endl;
 
		int index = (B * answer.first + D) % num;
		int newValue = (C * answer.second + D) % m;
		roots.push_back(update(roots[K - 1], 0, num - 1, newValue, index));
	}
 
	return 0;
} 