#include<iostream>
#include<vector>
#include<stdio.h>
#include<stdio.h>
#include<map>
using namespace std;
#define f(i,a,b) for(int i=a;i<b;i++)
typedef long long int ll;
typedef int I;
typedef string S;
ll mod_pow(ll a,ll n,ll b){ll res = 1;while(n){if(n&1) {res = (res*a)%b;}a = (a*a)%b;n >>= 1;}return res%b;}
ll mod_div(ll a,ll b,ll md){ll ans = (a*mod_pow(b,md-2,md))%md; return ans;}
ll mul(ll a,ll b,ll md){ return (ll)(a*b)%md;}
void add(ll &a,ll b,ll md){a=((a%md)+(b%md))%md;}
void sub(ll &a,ll b,ll md){add(a,md-b,md);}
ll mod=23102009;
I dp[1005][1005];
ll ndls[1005][1005];
void solve(S a,S b)
{
   f(i,0,1005){ndls[0][i]=1;ndls[i][0]=1;}
   f(i,1,a.length()+1)
   {
        f(j,1,b.length()+1)
        {
            dp[i][j]=0;
            ndls[i][j]=0;
            if(a[i-1]==b[j-1])dp[i][j]=dp[i-1][j-1]+1;
            else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            if(a[i-1]==b[j-1])ndls[i][j]=ndls[i-1][j-1];
            else
            {
            if(dp[i][j]==dp[i-1][j])add(ndls[i][j],ndls[i-1][j],mod);
            if(dp[i][j]==dp[i][j-1])add(ndls[i][j],ndls[i][j-1],mod);
            if(dp[i][j-1]==dp[i-1][j-1] && dp[i-1][j]==dp[i][j-1])sub(ndls[i][j],ndls[i-1][j-1],mod);
            }
        }
   }
   printf("%d %lld\n",dp[a.length()][b.length()],ndls[a.length()][b.length()]);
}
I main()
{
    I t;
    scanf("%d",&t);
    while(t>0)
    {
        S a,b;
        cin>>a>>b;
        solve(a,b);
        t--;
    }
}
