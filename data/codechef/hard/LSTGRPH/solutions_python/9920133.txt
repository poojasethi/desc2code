from collections import defaultdict
import Queue
import sys

class Graph():

    def __init__(self, connections=[], directed=False,weighted=False):
        self.status_dict      = defaultdict(lambda : 1)
        self.graph_dict       = defaultdict(list)
        self.is_directed      = directed
        if weighted:
            self.add_connections(connections)#USE FOR WEIGHTED GRAPH

    
    def add_connections(self,connections):
        if self.is_directed:         
           for source , destination , cost in connections:
                self.graph_dict[source].append((destination,cost))
                self.graph_dict[destination]
                self.status_dict[source]
                self.status_dict[destination]
                
        else:
           for source , destination , cost in connections:
           
                self.graph_dict[source].append((destination,cost))
                self.graph_dict[destination].append((source,cost))
                self.status_dict[source]
                self.status_dict[destination]

    def add_vertex(self,node):
        self.graph_dict[node]
        self.status_dict[node]

    def pprint(self):
        for key,value in self.graph_dict.iteritems():
            print str(key)+":"+str(value)


def dfs_xor(g,src_node,N,x):
    stack    = []
    x[src_node] = 0
    g.status_dict[src_node] = 3
    stack.append(src_node)
    while len(stack) != 0:
         u = stack.pop()
         for nbs in g.graph_dict[u]:
             v,y = nbs[0],nbs[1]
             if g.status_dict[v]==1:
                 stack.append(v)
                 x[v] = x[u]^y
                 g.status_dict[v] = 2
             else:
                 if x[v]!=x[u]^y:
                     return -1
    


    

def dfs_k(g,src_node,N,x,K):
    stack = []
    status = [1]*(N+1)
    x[src_node] = (K-1)
    stack.append(src_node)
    status[src_node]= 3
    while len(stack) >0:
        u = stack.pop()
        for nbs in g.graph_dict[u]:
            v,y = nbs[0],nbs[1]
            if status[v] == 1:
                x[v] = x[u]^y
                status[v] = 2
                stack.append(v)
            else:
                if x[v]!=x[u]^y:
                    return -1
                




N,M,K = [int(x) for x in raw_input().split()]
connections = []

for i in range(M):
    u,v,y = [int(x) for x in raw_input().split()]
    connections.append((u,v,y))


G = Graph(connections,False,True)


for i in range(1,N+1):
    G.add_vertex(i)
check =0

x = [-1]*(N+1)
maxi = -1;
for i in range(1,N+1):

    if G.status_dict[i] == 1:

        maxi = i
        ans1 = dfs_xor(G,i,N,x)
     
        if ans1 == -1:
            print -1
            check = 1
            break
 
  
if check == 0:
    ans2 = dfs_k(G,maxi,N,x,K)

    if ans2 == -1:
        print -1
    else:
        for i in range(1,N+1):
            print x[i],
    
 
  





