//November Cook-Off 2014
//Lost Graph
//Problem code: LSTGRPH
#include<iostream>
#include <list>
#include <utility> 

using namespace std;
int *X;
bool poss=true;
bool *visited ;
// This class represents a directed graph using adjacency list representation
class Graph
{
    int V;    // No. of vertices
    list<std::pair <int,int> > *adj;    // Pointer to an array containing adjacency lists
public:
    Graph(int V);  // Constructor
    void addEdge(int v, int w,int y); // function to add an edge to graph
    void BFS(int s,int k);  // prints BFS traversal from a given source s
};

Graph::Graph(int V)
{
    this->V = V;
    adj = new list<std::pair <int,int> >[V];
}

void Graph::addEdge(int v, int w,int y)
{
	adj[v].push_back(std::make_pair(w,y)); // Add w to vâ€™s list.
}

void Graph::BFS(int s,int k)
{
    
    // Create a queue for BFS
    list<int> queue;

    // Mark the current node as visited and enqueue it
    visited[s] = true;
    queue.push_back(s);
	X[s]=k;
    // 'i' will be used to get all adjacent vertices of a vertex
    list<std::pair <int,int> >::iterator i;

    while(!queue.empty())
    {
        // Dequeue a vertex from queue and print it
        s = queue.front();
        //cout << s << " ";
        queue.pop_front();

        // Get all adjacent vertices of the dequeued vertex s
        // If a adjacent has not been visited, then mark it visited
        // and enqueue it
        for(i = adj[s].begin(); i != adj[s].end(); ++i)
        {
			int temp=(*i).first;
			int temp2=(*i).second;
            if(!visited[temp])
            {
                visited[temp] = true;
                queue.push_back(temp);
				X[temp]=X[s]^temp2;
            }
			else{
				if(X[temp]!=(X[s]^temp2)) {
					poss=false;
					return ;
				}
			}
        }
    }
}

// Driver program to test methods of graph class
int main()
{
    // Create a graph given in the above diagram
	//freopen("1_input.txt","r",stdin);
	int N,M,K;
	int u,v,y;
	scanf("%d %d %d",&N,&M,&K);
	X=new int[N];
    Graph g(N+1);
	for(int i=0;i<M;i++){
		scanf("%d %d %d",&u,&v,&y);
		 g.addEdge(u,v,y);
		 g.addEdge(v,u,y);
	}
	// Mark all the vertices as not visited
    visited = new bool[N+1];
    for(int i = 0; i <= N; i++)
        visited[i] = false;
	int last;
	for(int i=1;i<=N;i++){
		if(!visited[i]){
			last=i;
			g.BFS(i,0);
		}
	}
	if(poss==false)printf("-1");
	else{
		for(int i = 0; i <= N; i++)
        visited[i] = false;
		g.BFS(last,K-1);
		if(poss==false)printf("-1");
		else{
			for(int i=1;i<=N;i++){
				printf("%d ",X[i]);
			}
		}
	}
    return 0;
}

