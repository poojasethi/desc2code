#include<iostream>
#include <list>
 
using namespace std;

bool visited[200001];
int x[200001],f=0;
 
// This class represents a directed graph using adjacency list representation
class Graph
{
    int V;    // No. of vertices
    list<int> *adj; 
    list<int> *weight;    // Pointer to an array containing adjacency lists
public:
    Graph(int V);  // Constructor
    void addEdge(int v, int w,int z); // function to add an edge to graph
    void BFS(int s);
    void bfs(int s);  // prints BFS traversal from a given source s
};
 
Graph::Graph(int V)
{
    this->V = V;
    adj = new list<int>[V];
    weight= new list<int>[V];
}
 
void Graph::addEdge(int v, int w,int z)
{
    adj[v].push_back(w);
    weight[v].push_back(z); // Add w to vâ€™s list.
}
 
void Graph::BFS(int s)
{
    // Mark all the vertices as not visited
    
    //for(int i = 1; i <V; i++)
      //  visited[i] = false;
 
    // Create a queue for BFS
    list<int> queue;
 
    // Mark the current node as visited and enqueue it
    visited[s] = true;
    queue.push_back(s);
 
    // 'i' will be used to get all adjacent vertices of a vertex
    list<int>::iterator i;
 
    while(!queue.empty())
    {
        // Dequeue a vertex from queue and print it
        s = queue.front();
      //  cout << s << " ";
        queue.pop_front();
             //cout<<s<<endl;
        // Get all adjacent vertices of the dequeued vertex s
        // If a adjacent has not been visited, then mark it visited
        // and enqueue it
        for(i = adj[s].begin(); i != adj[s].end(); ++i)
        {
            if(!visited[*i])
            {
                visited[*i] = true;
                queue.push_back(*i);
            }
        }
    }
}


void Graph::bfs(int s)
{
    // Mark all the vertices as not visited
    
    int temp;
 
    // Create a queue for BFS
    list<int> queue;
 
    // Mark the current node as visited and enqueue it
    //x[s] = true;
    queue.push_back(s);
 
    // 'i' will be used to get all adjacent vertices of a vertex
    list<int>::iterator i,j;
 
    while(!queue.empty())
    {
        // Dequeue a vertex from queue and print it
        s = queue.front();
             //cout<<s<<endl;

      //  cout << s << " ";
        queue.pop_front();
 
        // Get all adjacent vertices of the dequeued vertex s
        // If a adjacent has not been visited, then mark it visited
        // and enqueue it
        for(i = adj[s].begin(),j=weight[s].begin(); i != adj[s].end(); ++i,++j)
        {
            temp=(*j)^x[s];
            if(x[*i]==-1)
            {
                x[*i]=temp;
                queue.push_back(*i);
            }
            else if(temp==x[*i] ){
                x[*i]=temp;
            }
            else{
                f=1;
                return ;
            }

        }
    }
}

int main(){
    long long int n,m,k,i,temp,u,y,z,j;

    cin>>n>>m>>k;
        Graph g(n+1);
    for(i=0;i<m;++i){
        cin>>u>>y>>z;
        g.addEdge(u,y,z);
        g.addEdge(y,u,z);
    }
    for(i=0;i<=n;++i){
        visited[i]=false;
    }
    for(i=1;i<=n;++i){
        if(visited[i]==false){
            g.BFS(i);
            temp=i;
        }
    }
   //cout<<temp;

for(int i = 1; i <= n;i++)
        x[i] = -1;

   x[temp]=k-1;

    for(i=1;i<=n;++i){
        if(f!=0)
            break;

        if(x[i]==-1 || i==temp){
            if(i!=temp)
                x[i]=0;
            g.bfs(i);
        }
    }
    if(f==0){
    for(j=0;j<n;++j){
        cout<<x[j+1]<<" ";
    }
   }
  else
    cout<<"-1";

   /* cout<<endl;
    for(j=0;j<n;++j){
        cout<<x[j+1]<<" ";
    }*/
  }
