#include<bits/stdc++.h>
using namespace std;
typedef long long llu;
inline long long scanf()
{	long long n = 0, c = getchar();
	int t=0;
	while(c < '0' || c > '9')
	{c = getchar();}
	while(c >= '0' && c <= '9')
	{	n = (n<<3) + (n<<1) + c - '0';
		c = getchar();
	}
	if(t==0)return n;
	else return -n;}
	
vector<vector<pair<int,int> > > graph(200001);
llu edgexor[300001]; 
int main()
{	int n,m,k;
	n=scanf();
	m=scanf();k=scanf();
	int marked[200001]={0};
	int secondmark[200001]={0};
	for(int i=1;i<m+1;i++)
	{	int k1,k2;llu xolo;
		k1=scanf();k2=scanf();xolo=scanf();
	//	cout<<k1<<k2<<endl;
		graph[k1].push_back(make_pair(k2,i));
		graph[k2].push_back(make_pair(k1,i));
		edgexor[i]=xolo;
	}

	int count=0;
	int lastconnected=-1;
	for(int i=1;i<n+1;i++)
	{	if(marked[i]==0)
		{	lastconnected=i;
		//	cout<<i<<endl;
			queue<int> q;
			q.push(i);
			marked[i]=1;
			while(q.size()!=0)
			{	int top=q.front();
			//	cout<<"top"<<top<<endl;
				q.pop();
				for(int i=0;i<graph[top].size();i++)
				{	int ch=graph[top][i].first;
			//		cout<<"ch"<<ch<<endl;
					if(marked[ch]==0)
					{	//cout<<"ch"<<ch<<endl;
						marked[ch]=1;
						q.push(ch);
					}
				}
			}
		}
	}
//	cout<<lastconnected<<endl;
//	int secondmark[n+1];
	llu xormark[n+1];
	int wrong=0;
	for(int i=1;i<n+1;i++)
	{	if(i!=lastconnected)
		{	if(secondmark[i]==0)
			{	queue<int> q;
				q.push(i);
				xormark[i]=0;
				secondmark[i]=1;
				while(q.size()!=0)
				{	int top=q.front();
					q.pop();
					for(int i=0;i<graph[top].size();i++)
					{	int ch=graph[top][i].first;
						if(secondmark[ch]==0)
						{	secondmark[ch]=1;
							xormark[ch]=xormark[top] xor edgexor[graph[top][i].second];
							q.push(ch);
						}
						else if(secondmark[ch]==1)
						{	if((xormark[top] xor edgexor[graph[top][i].second]) != xormark[ch])
							{	wrong=1;
								break;
							}
						}
					}
					if(wrong==1)
					{	break;	}
				}
			}
		}
		else if(i==lastconnected)
		{	if(secondmark[i]==0)
			{	queue<int> q;
				q.push(i);
				xormark[i]=k-1;
				secondmark[i]=1;
				while(q.size()!=0)
				{	int top=q.front();
					q.pop();
					for(int i=0;i<graph[top].size();i++)
					{	int ch=graph[top][i].first;
						if(secondmark[ch]==0)
						{	secondmark[ch]=1;
							xormark[ch]=xormark[top] xor edgexor[graph[top][i].second];
							q.push(ch);
						}
						else if(secondmark[ch]==1)
						{	if((xormark[top] xor edgexor[graph[top][i].second]) != xormark[ch])
							{	wrong=1;
								break;
							}
						}
					}
					if(wrong==1)
					{	break;
					}
				}	
			}
		}
	}
 	if(wrong==0)
	{	for(int i=0;i<n;i++)
		{	printf("%llu ",xormark[i+1]);
		}
	}
	else
	{	cout<<-1<<endl;
	}
	
	
}