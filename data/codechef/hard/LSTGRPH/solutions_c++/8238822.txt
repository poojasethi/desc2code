#include<iostream>
#include<stdio.h>
#include<list>
#include<vector>
using namespace std;
//long long adj[200000][200000];
struct Node
{
    int node;
    long long y;
    Node(int n,long long Y)
    {
        node = n;
        y = Y;
    }
};
class Graph
{
    int v;
    list<Node> *adj;
    long long *x;
    bool *visited;
    bool ans;
    vector<int> lastMile;
    public:
    Graph(int v)
    {
        this->v = v;
        x = new long long[v];
        adj = new list<Node>[v];
       // for(int i=0; i<v; i++)
         //   adj[i] = new long long[v];
        visited = new bool[v];
        for(int i=0; i<v; i++)
            visited[i] = false;
        ans = true;

    }
    void addEdge(int a,int b,long long y)
    {
        adj[a].push_back(Node(b,y));
        adj[b].push_back(Node(a,y));
        //adj[a][b] = adj[b][a] = y;
    }


    void findSolutionUtil(int src,long long k)
    {

        visited[src] = true;
        x[src] = 0;
        list<int> q;
        q.push_back(src);
        lastMile.clear();


        bool possible = true;
        while(!q.empty())
        {
            int k = q.front();
            lastMile.push_back(k);
            q.pop_front();

            for(list<Node>::iterator it = adj[k].begin(); it != adj[k].end(); it++)
            {
                //printf("Edge between %d and %d with y as %lld\n",k+1,(*it).node+1,(*it).y);

                int j = (*it).node;
                long long y = (*it).y;
                if(!visited[j])
                {
                    x[j] = x[k] ^ y;
                    visited[j] = true;
                    q.push_back(j);
                }
                else if((x[j] ^ x[k]) != y)
                {
                    possible = false;
                    //printf("Edge between %d and %d with x as and with y as %lld\n",j+1,k+1,(*it).y);
                }
            }

           /* for(int j=0; j<v; j++)
            {
                if(!visited[j] && adj[k][j] != -1)
                {
                    x[j] = x[k] ^ adj[i][j];
                    visited[j] = true;
                    q.push_back(j);
                }
                else if(x[j] ^ x[k] != adj[k][j])
                    possible = false;
            }*/
        }
      //  for(int i=0; i<v; i++)
        //    cout<<x[i]<<" ";
        //cout<<endl;
        if(!possible)
            ans = false;
        else
        {
          //  for(int i=0; i<v; i++)
            //    cout<<(x[i] ^ (k-1))<<" ";
        }

    }

    void findSolution(int src,long long k)
    {
        for(int i=0; i<v; i++)
            if(!visited[i])
                findSolutionUtil(i,k);
        if(ans == false)
            cout<<-1<<endl;
        else
        {
            for(int i=0,l=lastMile.size(); i<l; i++)
                x[lastMile[i]] = x[lastMile[i]] ^ (k-1);
            for(int i=0; i<v; i++)
                cout<<x[i]<<" ";
        }
    }

};


int main()
{
    int n,m;
    long long k;
    scanf("%d %d %lld",&n,&m,&k);

    int a,b;
    long long y;
    Graph graph(n);
    for(int i=0; i<m; i++)
    {
        scanf("%d %d %lld",&a,&b,&y);
        graph.addEdge(a-1,b-1,y);
    }
    graph.findSolution(0,k);


    return 0;
}
