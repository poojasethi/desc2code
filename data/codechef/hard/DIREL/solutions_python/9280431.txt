uniqueueId = 0
class Dictionary(object):
	#generic dectionary object
	def __init__(self, type):
		self.descriptor = type
		self.hashTable = {}

	def setKeyValPair(self, key, value):
		self.hashTable[key] = value

	def getValue(self, key):
		if key in self.hashTable:
			return self.hashTable[key]
		return None

#helper funcs
def getObject(name):
	global dictionary
	obj = dictionary.getValue(name)
	if obj == None:
		obj = Person(name)
		dummyAncestor = Person(None)
		dummyAncestor.initChildrenList(obj)
		obj.initParentList(dummyAncestor)
	return obj

def setFirstObjectParentofSecondObject(parentObj, child):
	#is it possible that parentObj is already a parent of child? No since there are no cyclic relations
	for parentOtherHalf in child.getParentList():
		break
	newParents = set([parentObj])

	#update the children set
	parentObj.appendChildren(parentOtherHalf.getChildrenList())
	if type(parentOtherHalf.getName()) != type(1):
		parentObj.setOtherHalf(parentOtherHalf)
		parentOtherHalf.setOtherHalf(parentObj)
		parentOtherHalf.initChildrenList(parentObj.getChildrenList())
		newParents.add(parentOtherHalf)
	elif parentObj.getOtherHalf() != None:
		existingOtherHalf = parentObj.getOtherHalf()
		newParents.add(existingOtherHalf)
		existingOtherHalf.initChildrenList(parentObj.getChildrenList())
		
	#update the parent set in the children
	for child in parentObj.getChildrenList():
		child.initParentList(newParents)

def setTheObjectBros(bro1, bro2):
	bBro1Parent = not bro1.isMyCurrentParentDummy()
	bBro2Parent = not bro2.isMyCurrentParentDummy()
	parent1 = bro1.getParentList()
	parent2 = bro2.getParentList()
	for parentBro1 in parent1:
		break
	for parentBro2 in parent2:
		break
	broBand1 = parentBro1.getChildrenList()
	broBand2 = parentBro2.getChildrenList()

	if bBro1Parent and bBro2Parent:
		newParents = parent1.union(parent2)
		newBroBand = broBand1.union(broBand2)
		for bro in newBroBand:
			bro.initParentList(newParents)
		parentBro1.initChildrenList(newBroBand)
		parentBro2.initChildrenList(newBroBand)
		#update other half fields too!
		if parentBro1.__hash__() != parentBro2.__hash__():
			parentBro1.setOtherHalf(parentBro2)
			parentBro2.setOtherHalf(parentBro1)
	elif bBro1Parent or bBro2Parent:
		#make sure that bro1 is the one with valid parent parent1
		if not bBro1Parent:
			bro1, bro2 = bro2, bro1
			parent1, parent2 = parent2, parent1
			broBand1, broBand2 = broBand2, broBand1
		iterParent1 = iter(parent1)
		half1 = next(iterParent1)
		half1.appendChildren(broBand2)
		if len(parent1) == 2:
			half2 = next(iterParent1)
			half2.initChildrenList(half1.getChildrenList())
		for bro in broBand2:
			bro.initParentList(parent1)
	else:
		#make sure that bro1 is the one with higher no. of bros
		if len(broBand1) < len(broBand2):
			bro1, bro2 = bro2, bro1
			parent1, parent2 = parent2, parent1
			broBand1, broBand2 = broBand2, broBand1
		for parent in parent1:
			break
		parent.appendChildren(broBand2)
		for bro in broBand2:
			bro.initParentList(parent1)

def bfs(bfsPerson):
	global distance, visited, currentVisitedCount
	bfsPersonId = bfsPerson.__hash__()
	queue = [[bfsPerson, 0]]
	while len(queue) != 0:
		thisPersonEntry = queue.pop(0)
		thisPerson = thisPersonEntry[0]
		thisPersonId = thisPerson.__hash__()
		#mark it as visited and update its distance
		if visited[thisPersonId] != currentVisitedCount:
			visited[thisPersonId] = currentVisitedCount
		else:
			continue
		thisPersonDist = thisPersonEntry[1]
		distance[bfsPersonId][thisPersonId] = thisPersonDist
		#append thisPersonEntry's parents, siblings, and offsprings to the list, if they are not already visited,  with updated distance
		#parents
		for parent in thisPerson.getParentList():
			if type(parent.getName()) != type(1) and visited[parent.__hash__()] != currentVisitedCount:
				queue.append([parent, thisPersonDist + 1])
		#siblings
		#The outer for loop is executed only once. It serves the purpose of initialization of parent
		for parent in thisPerson.getParentList():
			for sibling in parent.getChildrenList():
				if visited[sibling.__hash__()] != currentVisitedCount:
					queue.append([sibling, thisPersonDist + 1])
			break;
		#children
		for child in thisPerson.getChildrenList():
			if visited[child.__hash__()] != currentVisitedCount:
				queue.append([child, thisPersonDist + 1])
		

def getDistance(person1, person2):
	global distance, currentVisitedCount
	if distance[person1.__hash__()][person1.__hash__()] == 0:
		return distance[person1.__hash__()][person2.__hash__()]
	elif distance[person2.__hash__()][person2.__hash__()] == 0:
		return distance[person2.__hash__()][person1.__hash__()]
	else:#polulate the distance array for person1
		bfs(person1)
		currentVisitedCount += 1
		return distance[person1.__hash__()][person2.__hash__()]

class Person(object):
	def __init__(self, name):
		#if name is None, its a dummy object.
		global dictionary, uniqueueId
		if name == None:
			self.name = uniqueueId
		else:
			self.name = name
		self.uid = uniqueueId
		uniqueueId += 1
		self.otherHalf = None
		#use dictionary instead of list
		self.parents = set()
		self.children = set()
		dictionary.setKeyValPair(self.name, self)

	def __hash__(self):
		# The only required property is that objects which compare equal have the same hash value
		return self.uid
	
	def __str__(self):
		return str(self.name)

	def getName(self):
		return self.name

	def getOtherHalf(self):
		return self.otherHalf

	def getParentList(self):
		return self.parents

	def getChildrenList(self):
		return self.children

	def appendChildren(self, children):
		if isinstance(children , set):
			self.children = self.children.union(children)
		else:
			self.children.add(children)

	def initChildrenList(self, children):
		#used for setting same set of children for both parents, so that changes are propogated to them
		if isinstance(children , set):
			self.children = children
		#used while normal initialization of child od dummy parent
		else:
			self.children = set([children])

	def appendParent(self, parent):
		if isinstance(parent, set):
			self.parents = self.parents.union(parent)
		else:
			self.parents.add(parent)

	def initParentList(self, parents):
		#used for setting same set of parent for all the children, so that changes are propogated to all
		if isinstance(parents, set):
			self.parents = parents
		#used while normal initialization of dummy parent for a child
		else:
			self.parents = set([parents])

	def setOtherHalf(self, otherHalf):
		self.otherHalf = otherHalf

	def isMyCurrentParentDummy(self):
		return len(self.parents) == 1 and type(next(iter(self.parents)).getName()) == type(1)


#main prog
#create a dictionary to lookup Person object from its name
dictionary = Dictionary("nameLookupTable")
NRStr = raw_input().split()
N = int(NRStr[0])
R = int(NRStr[1])
for i in range(R):
	relation = raw_input().split()
	if relation[2] == "father" or relation[2] == "mother":
		parentObj = getObject(relation[0])
		child = getObject(relation[4])
		setFirstObjectParentofSecondObject(parentObj, child)
	elif relation[2] == "son" or relation[2] == "daughter":
		parentObj = getObject(relation[4])
		child = getObject(relation[0])
		setFirstObjectParentofSecondObject(parentObj, child)
	else:
		c1 = getObject(relation[0])
		c2 = getObject(relation[4])
		setTheObjectBros(c1, c2)
	
#for name in dictionary.hashTable:
#	personObj = dictionary.hashTable[name] #This is hacky
#	if type(personObj.getName()) != type(1):
#		print
#		print "person name: ", personObj
#		print "Other half: ", personObj.getOtherHalf()
#		print "Its offsprings: \n\t", 
#		for child in personObj.getChildrenList():
#			print child,
#		print
#		print "Its parent list: \n\t", 
#		for parent in personObj.getParentList():
#			print parent,
#		print
#distance is 2d list which is indexed by person's uniqueue id. uniqueue id can never go beyond 2*N
distance = [[ -1 for i in range(2*N + 1)] for j in range(2*N + 1)]
currentVisitedCount = 1
visited = [0] * 2*N
Q = int(raw_input())
for i in range(Q):
	strXY = raw_input().split()
	X = getObject(strXY[0])
	Y = getObject(strXY[1])
	print getDistance(X, Y)
