// BINARY SEARCH TECHNIQUE  +++  DYNAMIC PROGRAMMING
#include <iostream>
#include <cstring>

using namespace std;

const int MAXN = 1000;
const int MAXD = 1000;

int x[MAXN], y[MAXN], n;
bool a[MAXD+1];

bool solve(int k) // K==MID.
{
    memset(a, false, sizeof(a)); // initialise bool a[] to FALSE.
    a[0] = true;
    int tot = 0;
    for (int i = 0; i < n; i++) 
    {
        if (x[i] <= k) 
            continue;
        else 
            tot += y[i];
        for (int l = k-y[i]; l >= 0; --l)
            a[l+y[i]] |= a[l];
    }
    for (int i = k; tot-i <= k; --i)
        if (a[i]) 
            return true;
    return false;
}

int main() 
{
    int t; 
    cin >> t; // test cases
    while (t--) 
    {
        cin >> n; // NO. OF DISHES
        for (int i = 0; i < n; ++i) 
            cin >> x[i] >> y[i];  // INPUT other cooks time AND chef/asst time.
        int lo = 0, hi = 1000;
        while (lo+1 < hi) 
        {
            int mid = (lo+hi)/2;
            if (solve(mid)) 
                hi = mid;
            else 
                lo = mid;
        }
        cout << hi << endl;
    }
}
