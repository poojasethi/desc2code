#include <iostream>
#include <cstdio>
using namespace std;

#include <bitset>
#include <algorithm>
#include <iomanip>
#include <cmath>
#include <cstring>

# define FR(i, n)           for( int i = 0; i<=n; i++)
# define FRm(i, m, n)     for( int i = m; i <=n; i++)
# define FRrev(i, n)         for( int i = n; i >= 0; i-- )
# define FRrevm(i,n,m)         for( int i = n; i >= m; i-- )

# define PF       printf
# define PFS PF(" ")
# define PFd(x)   printf("%d" , x )
# define PFdS(x)   printf("%d " , x )
# define PFdN(x)  printf("%d\n" , x )
# define PFN	  printf("\n")
# define SF    scanf
# define SFd(x) scanf("%d",&x)
# define SFd2(x,y) scanf("%d%d",&x,&y)
# define SFll(x) scanf("%lld",&x)
# define SFllc(x) cin>>x

#define LL long long
#define inarrd(arr,n) for(int i=0;i<n;i++)SFd(arr[i]);
#define outarrdS(arr,n) for(int i=0;i<n;i++){PFd(arr[i]);PF(" ");}PFN;
#define outarrN(arr,n) for(int i=0;i<n;i++){PFd(arr[i]);PFN;}
#define nmax 10000

int bSearch(int key , int len , int arr[])
{
	int left,right,mid;

	left=0; right=len-1;
	while(left<=right)
	{
		mid=(left+right)/2;
		if(arr[mid]==key) return mid;

		if(key<arr[mid]) right=mid-1;
		else left=mid+1;

	}
	return -1;
}
int solveBinary(int inp[] , int p1 , int p2 , int m , int low=0, int high=100000000 )
{
	// p1=starting index
	// p2=last index
	// m=values b/w p1 and p2 required. so including p1 and p2, total of m+2 values to be choosen
	// low,high--> initial low and high values

	int next,cur,mid,start=p1;
	int c2=inp[p2];

	while( (1+low)<high )
	{
			mid=(low+high)/2;
			cur=start;

			FRm(i,1,m+1)
			{
				next=cur;
				while( inp[next]<c2 && inp[next+1]<=(inp[cur]+mid)  )
				{
					next++;
				}
				cur=next;
			}
			if(inp[cur]<c2)
				low=mid;
			else   // if u can't get all m values for current mid, then the mid required is less than the current mid
				high=mid;
	}
	return high;
}

struct node
{
	int x,y;
};
class Compare {
public:
    bool operator()(node a, node b)
    {
       	if(a.x>b.x)return true;
		if(a.x<b.x)return false;
		return (a.y<b.y);
    }
    //priority_queue< node,vector<node>,Compare > pq;  // priority if not swapped
    //node arr[]={ {1,2},{3,4},{2,3} };  sort(arr,arr+n,Compare()); // b,a system
};

int chef[nmax],other[nmax];

int t,n;



int solve()
{
	
	int low=0,high=1000000,mid,ans=1000000,chefasstsum; bool flag;
	
	while(low<=high)
	{
		mid=(low+high)/2;
		
		chefasstsum=0; flag=false;
		FR(i,n-1)
		{
			if(other[i]<=mid)continue;
			
			if(chef[i]>mid){ flag=true; break; }
			chefasstsum+=chef[i];
			if(chefasstsum > (2*mid)){flag=true; break;}
			
		}
		
		if(!flag){ ans=min(ans,mid);  high=mid-1; }
		else
		{
			low=mid+1;
		}
		
	}
	
	return ans;
	
}

void input()
{
	SFd(t);
	
	
	while(t--)
	{
		SFd(n);
		
		FR(i,n-1)SFd2(other[i],chef[i]);
		
		PFdN(solve());
	}
	
}

int main()
{
	input();
	return 0;
}
