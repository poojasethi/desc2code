

#include<stdio.h>
#include<stdlib.h>
#include <iostream>
#include <stack>
#include <vector>
#include <string>
#include<list>
#include <algorithm>
#include <map>

#define INF 222222
#define pri(v) cout<<" "<<v<<" ";
#define pr(s)	cout<<s;     //note cin and cout are 3 times slower than printf and scanf
#define forr(i,n)  for(i=0;i<n;i++)
#define dbg(v) cout<<endl<<" debug: "<<v<<endl;
#define hi cout<<" hi "<<endl;
#define dem(a,n) a=(int**)malloc(sizeof(int*)*n);
#define dems(a,n) a=(int*)malloc(sizeof(int)*n);

#define dem_s(a,n) a=(char**)malloc(sizeof(char*)*n);
#define dems_s(a,n) a=(char*)malloc(sizeof(char)*n);

#define decs(a,n) a=(int*)calloc(sizeof(int),n);
#define space cout<<endl;
#define swap(a,b,c) {temp=a[b];a[b]=a[c];a[c]=temp;} 
#define sca(a) scanf("%d",&a);


using namespace std;



//it finds if there exist a subset S1 and S2, such that S1<=t S2<=t.. so we find S(n,t)
//after finding table.. we start from t and go till the index S-t, if anyone is found, we output 1
int partition_t(int *skill, int n, int sum1){    

	if(n==1) {
		if(skill[0]<sum1)
			return 1;
		else 	return -1;	
	}					


	int i, j, k, sum=0, temp, val, min;

	
	forr(i,n)
		sum+=skill[i];

	int **memo; 
	dem(memo, n)
	
	forr(i,n)
		decs(memo[i],sum1+1)  

	memo[0][skill[0]]=1;

	for(i=1;i<n;i++){

		for(j=0;j<=sum1;j++){
			temp=j-skill[i];
			memo[i][j]=memo[i-1][j];
			if(temp>=0) memo[i][j]=memo[i][j]||memo[i-1][temp];
		}	

	}

	for(i=sum1;i>=sum-sum1;i--){     //this condition checks if S1 and S2 <=t, both
		if(memo[n-1][i])		//uncomment if using for that purpose
			return 1;   		//ie yes, there exist such subsets
	}
	
	
	return -1;  //else return no
	
}



int chef(int *assis, int *skill, int n){

	int i, j, k, sum=0,low;
	int *temp;
	dems(temp,n);
	
	forr(i,n)
		sum+=skill[i];

	low=1;		  //min can be 1 because of assistants
	int high=sum;   //for more than sum , amount , cant run actually
	
	int mid=(high+low)/2;	


	while(low!=high){
		
		mid=(low+high)/2;
		k=0;
		
		forr(j,n){
			if(assis[j]>mid){
				temp[k]=skill[j];
				k++;
			}	
		}
		
		if(k==0){ 
			high=mid;
		}	
		else if(partition_t(temp, k, mid)==1){	
			high=mid;	
		}
		else{
			if(low==mid)  //because of integer rounding, this takes place
				low=high;	
			else
				low=mid;
		}
		
	}
		
	return low;


}



int main()		//find the k partition of n integers
{
	int ii,i,j, n, nn;

	int *skill,*assis;
	dems(skill, 1003);
	dems(assis, 1003);
	
	sca(nn);

	forr(ii,nn){
		sca(n);
		
		forr(j,n){
			sca(assis[j]);
			sca(skill[j]);
		}

		cout<<chef(assis, skill,n)<<endl;
	}
	
	return 0;
}


