#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

#define rep(i,a,b) for(int i = a; i < b; i++)
#define REP(i, n) for (int i = 0; i < (int)(n); ++i)
#define S(x) scanf("%d",&x)
#define P(x) printf("%d\n",x)

typedef long long LL;

const int MAXN = 200005;
char S1[MAXN], S2[MAXN], S3[MAXN];
int sa[MAXN];
int lcp[MAXN];
int rankk[MAXN];
int n,N;

// Suffix Array and LCP in O(N)
char mask[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };
#define tget(i) ( (t[(i)/8]&mask[(i)%8]) ? 1 : 0 )
#define tset(i, b) t[(i)/8]=(b) ? (mask[(i)%8]|t[(i)/8]) : ((~mask[(i)%8])&t[(i)/8])
#define chr(i) (cs==sizeof(int)?((int*)s)[i]:((char *)s)[i])
#define isLMS(i) (i>0 && tget(i) && !tget(i-1))

void getBuckets(char *s, int *bkt, int n, int K, int cs, bool end) {
    int i, sum = 0;
    for (i = 0; i <= K; i++)
        bkt[i] = 0;
    for (i = 0; i < n; i++)
        bkt[chr(i)]++;
    for (i = 0; i <= K; i++) {
        sum += bkt[i];
        bkt[i] = end ? sum : sum - bkt[i];
    }
}

void induceSAl(char *t, int *SA, char *s, int *bkt, int n, int K, int cs, bool end) {
    int i, j;
    getBuckets(s, bkt, n, K, cs, end);
    for (i = 0; i < n; i++) {
        j = SA[i] - 1;
        if (j >= 0 && !tget(j))
            SA[bkt[chr(j)]++] = j;
    }
}

void induceSAs(char *t, int *SA, char *s, int *bkt, int n, int K, int cs, bool end) {
    int i, j;
    getBuckets(s, bkt, n, K, cs, end);
    for (i = n - 1; i >= 0; i--) {
        j = SA[i] - 1;
        if (j >= 0 && tget(j))
            SA[--bkt[chr(j)]] = j;
    }
}

void buildSA(char *s, int *SA, int n, int K, int cs) {
    int i, j;
    char *t = (char *) malloc(n / 8 + 1);
    tset(n-2, 0);
    tset(n-1, 1);
    for (i = n - 3; i >= 0; i--)
        tset(i, (chr(i)<chr(i+1) || (chr(i)==chr(i+1) && tget(i+1)==1))?1:0);
    int *bkt = (int *) malloc(sizeof(int) * (K + 1));
    getBuckets(s, bkt, n, K, cs, true);
    for (i = 0; i < n; i++)
        SA[i] = -1;
    for (i = 1; i < n; i++)
        if (isLMS(i))
            SA[--bkt[chr(i)]] = i;
    induceSAl(t, SA, s, bkt, n, K, cs, false);
    induceSAs(t, SA, s, bkt, n, K, cs, true);
    free(bkt);

    int n1 = 0;
    for (i = 0; i < n; i++)
        if (isLMS(SA[i]))
            SA[n1++] = SA[i];

    for (i = n1; i < n; i++)
        SA[i] = -1;
    int name = 0, prev = -1;
    for (i = 0; i < n1; i++) {
        int pos = SA[i];
        bool diff = false;
        for (int d = 0; d < n; d++)
            if (prev == -1 || chr(pos+d) != chr(prev+d) || tget(pos+d) != tget(prev+d)) {
                diff = true;
                break;
            } else if (d > 0 && (isLMS(pos+d) || isLMS(prev+d)))
                break;
        if (diff) {
            name++;
            prev = pos;
        }
        pos = (pos % 2 == 0) ? pos / 2 : (pos - 1) / 2;
        SA[n1 + pos] = name - 1;
    }
    for (i = n - 1, j = n - 1; i >= n1; i--)
        if (SA[i] >= 0)
            SA[j--] = SA[i];
    int *SA1 = SA, *s1 = SA + n - n1;
    if (name < n1)
        buildSA((char*) s1, SA1, n1, name - 1, sizeof(int));
    else
        for (i = 0; i < n1; i++)
            SA1[s1[i]] = i;

    bkt = (int *) malloc(sizeof(int) * (K + 1));
    getBuckets(s, bkt, n, K, cs, true);
    for (i = 1, j = 0; i < n; i++)
        if (isLMS(i))
            s1[j++] = i;
    for (i = 0; i < n1; i++)
        SA1[i] = s1[SA1[i]];
    for (i = n1; i < n; i++)
        SA[i] = -1;
    for (i = n1 - 1; i >= 0; i--) {
        j = SA[i];
        SA[i] = -1;
        SA[--bkt[chr(j)]] = j;
    }
    induceSAl(t, SA, s, bkt, n, K, cs, false);
    induceSAs(t, SA, s, bkt, n, K, cs, true);
    free(bkt);
    free(t);
}

void buildLCP(char *S) {
    for (int i = 0; i <= n; i++)
        rankk[sa[i]] = i;
    for (int i = 0, h = 0; i < n; i++) {
        if (rankk[i] < n - 1) {
            for (int j = sa[rankk[i] + 1]; S[i + h] == S[j + h]; ++h)
                ;
            lcp[rankk[i]] = h;
            if (h > 0)
                --h;
        }
    }
}
 // END OF DC3 routines

LL solve(char *S, int L)
{
    n = N = L;
    buildSA(S, sa, n + 1, 256, 1);
    for(int i=0; i<n; i++) sa[i] = sa[i+1];
    buildLCP(S);
    LL ans = 0;
    //cout<<S<<"\n";
    lcp[n-1] = 0; // because of global
    rep(i,0,n) {
        //cout<<sa[i]<<" "<<lcp[i]<<"\n";
        ans += n-sa[i]-lcp[i];
    }
    //cout<<"ans = "<<ans<<"\n";
    return ans;
}

int main()
{
    #ifndef ONLINE_JUDGE
        freopen("in.txt","r",stdin);
    #endif
    scanf("%s",S1);
    scanf("%s",S2);
    strcat(S3,S1);
    strcat(S3,"$");
    strcat(S3,S2);
    //cout<<S1<<"\n"<<S2<<"\n"<<S3;

    int n=strlen(S1);
    int m=strlen(S2);
    LL U1 = solve(S1, n);
    LL U2 = solve(S2, m);
    LL U3 = solve(S3, n+m+1) - ((LL)n+1)*(m+1);

    //cout<<U1<<" "<<U2;

    //LL ans = 2*U1 + 2*U2 - U3 + (n+1)*(m+1);
    LL ans = 2*U3 - U1 - U2;
    printf("%lld",ans);
    return 0;
}
