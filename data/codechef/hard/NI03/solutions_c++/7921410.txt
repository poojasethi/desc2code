#include <stdio.h>
#include <map>
#ifndef ONLINE_JUDGE
#include <windows.h>
#endif
#include <hash_map>
#include <vector>
#include <algorithm>
 
#include <cmath>
using namespace std;
 
#ifndef ONLINE_JUDGE
#define TEST_PRINT //printf
#else
#define TEST_PRINT //
#endif
 
typedef long double PRECISION_TYPE;
 
typedef struct _XY
{
	PRECISION_TYPE x, y;
	
	_XY()
	{
	}
	
	_XY(PRECISION_TYPE _x, PRECISION_TYPE _y) : x(_x), y(_y)
	{
	}	
} XY;
 
typedef struct _PLANE
{
	XY pos;
	XY v;
	
	_PLANE()
	{
	}
	
	_PLANE(XY pos, XY v) : pos(pos), v(v)
	{
	}
	
	XY getpos(PRECISION_TYPE T) const
	{
		return XY(pos.x + T * v.x, pos.y + T * v.y);
	}
	
	bool is_stopped() const
	{
		return v.x == 0 && v.y == 0;	
	}
} Plane;
 
PRECISION_TYPE pt_dist(const XY &p1, const XY &p2)
{
	return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));		
}
 
void walk(vector<Plane> &planes, const XY &base, const XY &curpos, PRECISION_TYPE S, unsigned short done, int N, int left, PRECISION_TYPE T, PRECISION_TYPE &best_T)
{
	if (left == 0)
	{
		PRECISION_TYPE new_best_T = T + pt_dist(curpos, base) / S;
		
		best_T = best_T == 0 ? new_best_T : min(best_T, new_best_T);
		
		TEST_PRINT("[left = 0], done=%08X, time = %.04f\n", done, best_T);
		
		return;	
	}
	
	TEST_PRINT("[left = %d], time = %.04f\n", left, T);
	
	for (int i = 0, mask = 1; i < N; i++, mask <<= 1)
	{
		if (!(done & mask))
		{
			const Plane &plane = planes[i];
			
			XY planepos = plane.getpos(T);
			
			XY newpos;
			PRECISION_TYPE intersectTime = 0;
			
			//printf("left %d, pick %d\n", left, i);
			if (0) //plane.is_stopped())
			{
				intersectTime = pt_dist(curpos, planepos) / S;
				
				TEST_PRINT("(%f,%f) to (%f,%f) = dist %.04f = time %.04f\n", curpos.x, curpos.y, planepos.x, planepos.y, pt_dist(curpos, planepos), intersectTime);
			}
			else
			{
				PRECISION_TYPE tx = planepos.x - curpos.x,
			      ty = planepos.y - curpos.y,
			      tvx = plane.v.x,
			      tvy = plane.v.y;
			      
			      const PRECISION_TYPE min_val = 0.000001;
			
				  // Get quadratic equation components
				  PRECISION_TYPE a = tvx*tvx + tvy*tvy - S*S;
				  PRECISION_TYPE b = 2 * (tvx * tx + tvy * ty);
				  PRECISION_TYPE c = tx*tx + ty*ty;   
				
					pair<PRECISION_TYPE, PRECISION_TYPE> sol(0, 0);
				
				
					TEST_PRINT("%.5f %.5f %.5f\n", a, b, c);
				
				  if (abs(a) < min_val)
				  {
				  	if (abs(b) < min_val)
				  		sol = abs(c) < min_val ? make_pair(0, 0) : make_pair(0, 0);
				  	else
				  		sol = make_pair(-c/b, -c/b);
				  }
				  else
				  {				
					PRECISION_TYPE disc = b * b - 4 * a * c;
					
					if (disc < 0)
						exit(0);
					
	
					PRECISION_TYPE t1 = (-b + sqrt(disc)) / (2 * a);
					PRECISION_TYPE t2 = (-b - sqrt(disc)) / (2 * a);
					
					sol = make_pair(t1, t2);
				}
				
				const PRECISION_TYPE t1 = sol.first, t2 = sol.second;
				
				if (t1 > 0)
				{
					if (t2 > 0)
						intersectTime = min(t1, t2);
					else
						intersectTime = t1;
				}
				else
					intersectTime = t2;
					
				XY testpos = plane.getpos(T + intersectTime);
				PRECISION_TYPE testtime = pt_dist(curpos, testpos) / S;
				
				intersectTime = testtime;
				
				TEST_PRINT("plane speed (%f,%f) S=%.10f\n", tvx, tvy, S);
				TEST_PRINT("(%f,%f) to (%f,%f) = dist %.04f = [%f,%f], time %.04f\n", curpos.x, curpos.y, planepos.x, planepos.y, pt_dist(curpos, planepos), t1, t2, intersectTime);
				TEST_PRINT("test time %.10f\n", testtime);
			}
						
			PRECISION_TYPE newT = T + intersectTime + (60.0 * 60.0);
			newpos = plane.getpos(newT);
			
			if (best_T == 0 || newT < best_T)
				walk(planes, base, newpos, S, done | mask, N, left - 1, newT, best_T);
		}
	}
}
 
int main(int argc, char *argv[])
{
#ifndef ONLINE_JUDGE
	DWORD start = GetTickCount();
#endif
	
	unsigned int N, A = 1;
	
	scanf("%d", &N);
	
	while(N > 0)
	{
		vector<Plane> planes(N);
		
		for (int i = 0; i < N; i++)
		{
			double px, py, vx, vy;
			
			scanf("%lf %lf %lf %lf\n", &px, &py, &vx, &vy);	
			
			planes[i] = Plane(XY(px, py), XY(vx / (60 * 60), vy / (60 * 60)));
		}
		
		#if 0
		srand(GetTickCount());
		random_shuffle(planes.begin(), planes.end());
		printf("%f %f\n", planes[0].pos.x, planes[0].pos.y);
		#endif
		
		double x, y, S;
		scanf("%lf %lf %lf\n", &x, &y, &S);
		
		S /= 60 * 60;
		
		XY base = XY(x, y);
		
		TEST_PRINT("base = (%f,%f)\n", base.x, base.y);
		
		PRECISION_TYPE best_T = 0;
		
		walk(planes, base, base, S, 0, N, N, 0, best_T);
		
		//printf("best T: %.10f\n", best_T);
		
		long long int round_T = ceil(best_T);
		
		//round_T = 15 * 60 * 60 + 65;
		
		printf("%d %lld %lld %lld\n", A++, round_T / (60*60), (round_T % (60*60)) / 60, round_T % 60);
		
		scanf("%d", &N);
	}
	
	#ifndef ONLINE_JUDGE
	DWORD diff = GetTickCount() - start;
	
	printf("Took %.3f seconds\n", (PRECISION_TYPE)diff / 1000.0);
	#endif
}  
