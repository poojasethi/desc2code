
#ifndef __TEMPLATE_H__
#define __TEMPLATE_H__

using namespace std;
#include <algorithm>
#include <cassert>
#include <cctype>
#include <cfloat>
#include <climits>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <limits>
#include <map>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <vector>
#define FORab(i,a,b) for(__typeof(b) i=(a);i<=(b);i++)
#define FOR(i,n) FORab(i,0,(n)-1)
#define FOR1(i,n) FORab(i,1,n)
#define ROFba(i,b,a) for(__typeof(b) i=(b);i>=(a);i--)
#define ROF(i,n) ROFba(i,(n)-1,0)
#define ROF1(i,n) ROFba(i,n,1)
#define FORstl(i,s) for(__typeof((s).end()) i=(s).begin(); i != (s).end(); i++)
#define pb push_back
#define sz(a) ((int)a.size())
#define ms(a,n) memset(a, n, sizeof(a))
#define ms0(a) ms(a,0)
#define all(a) a.begin(), a.end()
#define sorts(a) sort(all(a))
#define sorta(a,n) sort(a,a+n)
#define amax(a,b) ( (a) = max( (a) , (b) ) )
#define amin(a,b) ( (a) = min( (a) , (b) ) )
#define mp make_pair

#ifndef USING_IOSTREAM
#define CC ({char a; scanf(" %c ", &a); a;})
#define II ({int a; scanf(" %d ", &a); a;})
#define DD ({double a; scanf(" %lf ", &a); a;})
#define SS(s) scanf("%s", s)
#else
#define CC ({char a; cin >> a; a;})
#define II ({int a; cin >> a; a;})
#define DD ({double a; cin >> a; a;})
#define SS(s) cin >> s
#endif
#define endl '\n'

#define DIM(a,b) __typeof(b) a=(b)
#define RDIM(a,b) __typeof(b) &a=(b)
#define in(a,b,c) ((a) <= (b) && (b) <= (c))
#define sqr(a) ((a)*(a))
#define amax(a,b) ( (a) = max( (a) , (b) ) )
#define amin(a,b) ( (a) = min( (a) , (b) ) )

#define EPS DBL_EPSILON
#define abs(x) (((x)<0)?-(x):(x))
#define ZERO(x) (abs(x) < EPS)
#define EQ(a,b) (ZERO((a)-(b)))

int ssz(char *s) { return strlen(s); }
int ssz(const string& s) { return sz(s); }

#ifdef __eXYZ__
#define RFILE(a)    freopen(a, "r", stdin)
#define WFILE(a)    freopen(a, "w", stdout)
#define _r(arg) {dbg,arg; dbg.start(); }
#define _n(arg...) {_r(#arg " ==> ");dbg,arg; }
#define _(arg...) { _n(arg); dbg.nl(); }
#else
#define RFILE(a)
#define WFILE(a)
#define _r(arg) {}
#define _n(arg...) {}
#define _(arg...) {}
#endif

typedef long long ll;
typedef unsigned long long ull;
typedef vector<int> vi;
typedef pair<int,int> pii;
typedef pair<ll,ll> pll;
typedef pair<string,int> psi;
typedef vector<pii> vii;

template<class A, class B> ostream &operator<<(ostream& o, const pair<A,B>& p) { //pair print
	return o << "("<<p.first<<", "<<p.second<<")";
}

template<class T> ostream& operator<<(ostream& o, const vector<T>& v) { //vector print
	o << "{";FORstl(it, v) o << *it << ", "; return o << "}";
}

template<class T> ostream& operator<<(ostream& o, const pair<T*,int> arr) { //vector print
	o << "{";FOR(i, arr.second) o << arr.first[i] << ", "; return o << "}";
}

template<class T> ostream& operator<<(ostream& o, const set<T>& v) { //set print
	o << "{";FORstl(it, v) o << *it << ", "; return o << "}";
}

template<class F, class S> ostream& operator<<(ostream& o, const map<F,S>& v) { //map print
	o << "{";FORstl(it, v) o << *it << ", "; return o << "}";
}

struct debugger
{
	ostream &out; bool first;
	void start() { first = true; }
	debugger(ostream& out):out(out) {start();}
	void nl() { out << '\n'; start(); }
    // Taken from rudradevbasak
    template<class T> debugger& operator,(const T& v) {
    	if(first) first = false; else out << ", ";
    	out << v; return *this;
    }
} dbg(cout);

#define px first
#define py second

#define pr first
#define pc second

#define qpopret(s) ({DIM(r, s.front()); s.pop(); r;})

string i2b(ll a) {
	string str = "";
	do {
		str += (a&1)+'0';
		a >>= 1;
	}while(a);
	reverse(all(str));
	return str;
}

#endif


#ifndef MODTYPE_H_
#define MODTYPE_H_


template<class T, T MOD>
struct ModT {
	T v;
	ModT(T a = 0) {
		if(a <= -MOD || a >= MOD) a %= MOD;
		if(a < 0) { a += MOD; }
		v = a;
	}
	ModT(const ModT& a) { v = a.v; }

	friend ModT operator-(ModT a) { return -a.v; }
	friend bool operator==(ModT a, ModT b) { return a.v == b.v;}
	friend ModT operator+(ModT a, ModT b) { return a.v+b.v; }
	friend ModT operator-(ModT a, ModT b) { return a.v-b.v; }
	friend ModT operator*(ModT a, ModT b) { return a.v*b.v; }

	friend ModT& operator+=(ModT &a, ModT b) { return a = a + b; }
	friend ModT& operator-=(ModT &a, ModT b) { return a = a - b; }
	friend ModT& operator*=(ModT &a, ModT b) { return a = a * b; }

	friend ModT operator^(ModT n, ModT p) {
		if(!p.v) return 1;
		ModT ans = n^(p.v/2); ans = ans*ans;
		if(p.v & 1) ans = ans * n;
		return ans;
	}
	friend ModT operator/(ModT a, ModT b) { return a.v*(b^(MOD-2)); }
	friend ostream& operator<<(ostream& out, ModT a) { return out << a.v; }
	friend istream& operator>>(istream& in, ModT& a) {
		int v; in >> v;
		a = ModT(v);
		return in;
	}
};

template<int MOD> struct ModInt : ModT<int,MOD> { ModInt(int a = 0) : ModT<int,MOD>(a) {} };
template<ll MOD> struct ModLL : ModT<ll,MOD> {
	ModLL(ll a = 0) : ModT<ll,MOD>(a) {}
	ModLL(const ModT<ll,MOD>& a) : ModT<ll,MOD>(a) {}
};

#endif /* MODTYPE_H_ */

const ll MOD = 1000000007;

ModLL<MOD> nck[5010][5010];

ModLL<MOD> ncr(int n, int r) {
	ModLL<MOD> ans;
	if(n < 0 || r < 0 || r > n) ans = 0;
	else ans = nck[n][r];
	return ans;
}

int main() {
	RFILE("input.txt");
#ifdef USING_IOSTREAM
	ios::sync_with_stdio(false);
	cin.tie(NULL);
#endif

	FOR(n, 5010) {
		nck[n][0] = nck[n][n] = 1;
		FOR1(r, n - 1) {
			nck[n][r] = nck[n-1][r-1] + nck[n-1][r];
		}
	}

	int numT = II;
	FOR1(cno, numT) {
		string s;
		cin >> s;
		int num4 = 0, num7 = 0;
		FOR(i, sz(s)) { if(s[i] == '4') num4++; else num7++; }

		int m = min(num4, num7);

		ModLL<MOD> ans = 0;
		FOR(i, m + 1) {
			ans += ncr(num7, i) * ncr(num4 - 1, i);

			ans += ncr(num7 - 1, i) * ncr(num4, i);

			ans -= ncr(num7 - 1, i) * ncr(num4 - 1, i);

		}
		cout << ans << endl;
	}

	return 0;
}
