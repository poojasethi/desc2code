/***********Template Starts Here***********/
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <map>
#include <queue>
#include <stack>
#include <vector>
#include <deque>
#include <functional>
#include <string>
#include <iostream>
#include <cctype>
#include <set>

#define pb push_back
#define nl puts ("")
#define sp printf ( " " )
#define phl printf ( "hello\n" )
#define ff first
#define ss second
#define popcount __builtin_popcount
#define rightmost __builtin_ctz

using namespace std;

typedef long long vlong;
typedef unsigned long long uvlong;
typedef vector < int > vi;
typedef pair < int, int > ii;
typedef pair < vlong, vlong > lili;
typedef vector < ii > vii;

template < class T > T sq( T x ) { return x * x; }

const vlong inf = 2147383647;
const double pi = 2 * acos ( 0.0 );
const double eps = 1e-9;
const vlong maxint = 2147483647;
const vlong minint = -2147483648;

vlong gcd ( vlong a, vlong b ) {
    a = abs ( a ); b = abs ( b );
    while ( b ) {
        a = a % b;
        swap ( a, b );
    }
    return a;
}

vlong power ( vlong a, vlong p ) {
    vlong res = 1, x = a;
    while ( p ) {
        if ( p & 1 ) res = ( res * x );
        x = ( x * x );
        p >>= 1;
    }
    return res;
}


vlong bigmod ( vlong a, vlong p, vlong m ) {
    vlong res = 1, x = a % m;
    while ( p ) {
        if ( p & 1 ) res = ( res * x ) % m;
        x = ( x * x ) % m;
        p >>= 1;
    }
    return res;
}

/***********Template Ends Here***********/
vlong sss, ddd, x, y, g;
vlong nnn, q, r, p11, p22, p3;
vlong arr[100010];

vlong mod ( vlong a, vlong b ) {
    a %= p3;
    b %= p3;

    long double res;
    res = a;
    res *= b;
    vlong c = res / p3;

    a *= b;
    a -= c * p3;
    a %= p3;
    if ( a < 0 ) a += p3;
    return a;
}

struct node {
    vlong s, d;
    vlong sum, flag;
}tnode[400010];

void lazyClear ( node &p ) {
    p.s = 0;
    p.d = 0;
}

void mergeIT ( node &p, node &u, node &v ) {
    p.sum = ( u.sum + v.sum ) % p3;
}

void build ( int p, int b, int e ) {
    int m = ( b + e ) / 2;
    int u = p * 2;
    int v = u + 1;

    lazyClear( tnode[p] );

    if ( b == e ) {
        tnode[p].sum = ( arr[b] ) % p3;
        return;
    }

    build ( u, b, m );
    build ( v, m + 1, e );

    mergeIT ( tnode[p], tnode[u], tnode[v] );
}

vlong powR[100010], XX[100010], YY[100010];
void precal () {
    int i;
    powR[0] = 1;
    XX[0] = 1;
    YY[0] = 0;
    for ( i = 1; i <= nnn; i++ ) {
        powR[i] = mod ( powR[i-1], r );
        XX[i] = ( XX[i-1] + powR[i] ) % p3;
        YY[i] = ( YY[i-1] + mod ( i , powR[i] ) ) % p3;
    }
}

void lazyUpdate ( node &p, vlong left ) {
    vlong ns = ( mod ( ( ( sss + mod ( left , ddd ) ) % p3 ) , powR[left] ) ) % p3;
    vlong nd = mod ( ddd , powR[left] );
    p.s = ( p.s + ns ) % p3;
    p.d = ( p.d + nd ) % p3;
}

vlong agp ( vlong a, vlong d, vlong n ) {
    vlong res = mod ( a , XX[n-1] ) + mod ( d , YY[n-1] );
    return res % p3;
}

void calculate ( node &p, int len ) {
    p.sum += agp ( p.s, p.d, len );
    p.sum %= p3;
}

void lazyPropagate ( node &p, node &u, node &v, vlong len ) {
    u.s += p.s; u.s %= p3;
    u.d += p.d; u.d %= p3;

    v.s += ( mod ( ( ( p.s + mod ( len , p.d ) ) % p3 ) , powR[len] ) ) % p3; v.s %= p3;
    v.d += mod ( p.d , powR[len] ); v.d %= p3;
}

void update1 ( int p, int b, int e ) {
    int m = ( b + e ) / 2;
    int u = p * 2;
    int v = u + 1;

    if ( b >= x && e <= y ) {
        lazyUpdate ( tnode[p], b - x );
        calculate ( tnode[p], e - b + 1 );
        if ( b != e ) lazyPropagate ( tnode[p], tnode[u], tnode[v], m - b + 1 );
        lazyClear( tnode[p] );
        return;
    }

    if ( b > y || e < x ) {
        calculate ( tnode[p], e - b + 1 );
        if ( b != e ) lazyPropagate ( tnode[p], tnode[u], tnode[v], m - b + 1 );
        lazyClear( tnode[p] );
        return;
    }

    lazyPropagate ( tnode[p], tnode[u], tnode[v], m - b + 1 );
    lazyClear( tnode[p] );

    update1 ( u, b, m );
    update1 ( v, m + 1, e );

    mergeIT ( tnode[p], tnode[u], tnode[v] );
}

void update2 ( int p, int b, int e ) {
    int m = ( b + e ) / 2;
    int u = p * 2;
    int v = u + 1;

    if ( b >= x && e <= y ) {
        calculate ( tnode[p], e - b + 1 );
        tnode[p].sum = ( bigmod ( tnode[p].sum, g, p22 ) );
        if ( b != e ) lazyPropagate ( tnode[p], tnode[u], tnode[v], m - b + 1 );
        lazyClear( tnode[p] );
        return;
    }

    if ( b > y || e < x ) {
        calculate ( tnode[p], e - b + 1 );
        if ( b != e ) lazyPropagate ( tnode[p], tnode[u], tnode[v], m - b + 1 );
        lazyClear( tnode[p] );
        return;
    }

    lazyPropagate ( tnode[p], tnode[u], tnode[v], m - b + 1 );
    lazyClear( tnode[p] );

    update2 ( u, b, m );
    update2 ( v, m + 1, e );

    mergeIT ( tnode[p], tnode[u], tnode[v] );
}

vlong qans = 0;
void query ( int p, int b, int e ) {
    int m = ( b + e ) / 2;
    int u = p * 2;
    int v = u + 1;

    if ( b >= x && e <= y ) {
        calculate ( tnode[p], e - b + 1 );
        if ( b != e ) lazyPropagate ( tnode[p], tnode[u], tnode[v], m - b + 1 );
        lazyClear( tnode[p] );
        qans = ( qans + tnode[p].sum ) % p3;
        return;
    }

    if ( b > y || e < x ) {
        calculate ( tnode[p], e - b + 1 );
        if ( b != e ) lazyPropagate ( tnode[p], tnode[u], tnode[v], m - b + 1 );
        lazyClear( tnode[p] );
        return;
    }

    lazyPropagate ( tnode[p], tnode[u], tnode[v], m - b + 1 );
    lazyClear( tnode[p] );

    query ( u, b, m );
    query ( v, m + 1, e );

    mergeIT ( tnode[p], tnode[u], tnode[v] );
}

int main () {
    #ifdef forthright48
    //freopen ( "input.txt", "r", stdin );
    //freopen ( "output.txt", "w", stdout );
    #endif

    int kase;
    scanf ( "%d", &kase );

    while ( kase-- ) {

        int i, j, k;

        scanf ( "%lld %lld %lld %lld %lld", &nnn, &q, &r, &p11, &p22 );
        p3 = p11 * p22;

        precal();

        for ( i = 0; i < nnn; i++ ) {
            scanf ( "%lld", &arr[i] );
        }

        build ( 1, 0, nnn - 1 );

        while ( q-- ) {

            int t;
            scanf ( "%d", &t );
            if ( t == 0 ) {
                scanf ( "%lld %lld %lld %lld", &sss, &ddd, &x, &y );
                x--; y--;
                update1 ( 1, 0, nnn - 1 );
            }
            else if ( t == 1 ) {
                scanf ( "%lld %lld", &x, &g );
                x--;
                y = x;
                update2 ( 1, 0, nnn - 1 );
            }
            else {
                scanf ( "%lld %lld", &x, &y );
                x--; y--;
                qans = 0;
                query ( 1, 0, nnn - 1 );
                qans %= p11;
                printf ( "%lld\n", qans );
            }
        }
    }

    return 0;
}
