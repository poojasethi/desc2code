#include <bits/stdc++.h>

using namespace std;

//#define FILE_IO

const int buffer = 1 << 13;
int cnt = buffer - 1;
char buff[buffer + 5];

char gchar()
{
    if(++cnt == buffer)
        cnt = 0, fread(buff, buffer, 1, stdin);
    return buff[cnt];
}

int gint()
{
    char ch = gchar();
    while(ch < '0' || '9' < ch)
        ch = gchar();
    int x = 0;
    while('0' <= ch && ch <= '9')
        x = x * 10 + ch - '0', ch = gchar();
    return x;
}

int N, R, p1, p2, S;
int aint[400005][2], add[400005], addcoef[400005][4];
int pows[100005][2], gsspws[100005][2];
int v[100005];

int power(int x, int y, int mod)
{
    int r = 1, p = x;
    while(y)
    {
        if(y & 1)
            r = (1LL * r * p) % mod;
        p = (1LL * p * p) % mod;
        y >>= 1;
    }
    return r;
}

class segmentTree
{
private:
    int mod, ans;
    int aint[400005];
    int add[400005];
    int addcoef[400005][2];
    int pws[100005];
    int gsspws[100005];
    int rpow[100005];

    void precalc()
    {
        int pw = 1;
        rpow[0] = 1;
        pws[0] = 1;
        gsspws[0] = 0;
        for(int i = 1; i <= N; i++)
        {
            pw = (1LL * pw * R) % mod;
            pws[i] = (pws[i - 1] + pw) % mod;
            gsspws[i] = (gsspws[i - 1] + (1LL * i * pw) % mod) % mod;
            rpow[i] = pw;
        }
    }

    void B(int nod, int st, int dr)
    {
        if(st == dr)
        {
            aint[nod] = v[st] % mod;
            add[nod] = 0;
            addcoef[nod][0] = addcoef[nod][1] = 0;
            return;
        }

        int mij = st + (dr - st) / 2;
        B(nod * 2, st, mij);
        B(nod * 2 + 1, mij + 1, dr);

        aint[nod] = (aint[nod * 2] + aint[nod * 2 + 1]) % mod;
        add[nod] = addcoef[nod][0] = addcoef[nod][1] = 0;
    }

    void lazy(int nod, int st, int dr)
    {
        int mij = st + (dr - st) / 2;

        int coef1 = addcoef[nod][0];
        int coef2 = addcoef[nod][1];
        add[nod] = addcoef[nod][0] = addcoef[nod][1] = 0;

        addlazyagp(nod * 2, 0, mij - st, coef1, coef2);
        addlazyagp(nod * 2 + 1, mij - st + 1, dr - st, coef1, coef2);
    }

    void addlazyagp(int nod, int st, int dr, int coef1, int coef2)
    {
        int cf1 = (1LL * coef1 * rpow[st]) % mod;
        cf1 = (cf1 + (1LL * ((1LL * coef2 * st) % mod) * rpow[st]) % mod) % mod;
        int cf2 = (1LL * coef2 * rpow[st]) % mod;

        add[nod] = 1;
        aint[nod] = (aint[nod] + (1LL * cf1 * pws[dr - st])) % mod;
        aint[nod] = (aint[nod] + (1LL * cf2 * gsspws[dr - st])) % mod;
        addcoef[nod][0] += cf1;
        addcoef[nod][0] %= mod;
        addcoef[nod][1] += cf2;
        addcoef[nod][1] %= mod;
    }

    void addagp(int nod, int st, int dr, int coef1, int coef2)
    {
        int cf1 = (1LL * rpow[st] * ( (1LL * coef1 + 1LL * coef2 * st) % mod ) ) % mod;
        int cf2 = (1LL * rpow[st] * coef2) % mod;

        add[nod] = 1;
        aint[nod] = (aint[nod] + (1LL * cf1 * pws[dr - st])) % mod;
        aint[nod] = (aint[nod] + (1LL * cf2 * gsspws[dr - st])) % mod;
        addcoef[nod][0] += cf1;
        addcoef[nod][0] %= mod;
        addcoef[nod][1] += cf2;
        addcoef[nod][1] %= mod;
    }

    void U(int nod, int st, int dr, int pos, int val)
    {
        if(st == dr)
        {
            aint[nod] = val;
            return;
        }

        if(add[nod])
            lazy(nod, st, dr);

        int mij = st + (dr - st) / 2;
        if(pos <= mij)
            U(nod * 2, st, mij, pos, val);
        else
            U(nod * 2 + 1, mij + 1, dr, pos, val);

        aint[nod] = (aint[nod * 2] + aint[nod * 2 + 1]) % mod;
    }

    void U(int nod, int st, int dr, int sti, int dri, int coef1, int coef2)
    {
        if(sti <= st && dr <= dri)
        {
            int stpos = st - sti;
            int drpos = dr - sti;
            addagp(nod, stpos, drpos, coef1, coef2);
            return;
        }

        if(add[nod])
            lazy(nod, st, dr);

        int mij = st + (dr - st) / 2;
        if(sti <= mij)
            U(nod * 2, st, mij, sti, dri, coef1, coef2);
        if(mij < dri)
            U(nod * 2 + 1, mij + 1, dr, sti, dri, coef1, coef2);

        aint[nod] = (aint[nod * 2] + aint[nod * 2 + 1]) % mod;
    }

    void Q(int nod, int st, int dr, int sti, int dri)
    {
        if(sti <= st && dr <= dri)
        {
            ans += aint[nod];
            ans %= mod;
            return;
        }

        if(add[nod])
            lazy(nod, st, dr);

        int mij = st + (dr - st) / 2;

        if(sti <= mij)
            Q(nod * 2, st, mij, sti, dri);
        if(mij < dri)
            Q(nod * 2 + 1, mij + 1, dr, sti, dri);
    }

public:
    void setmod(int _mod)
    {
        mod = _mod;
    }

    void B()
    {
        B(1, 1, N);
        precalc();
    }

    int Q(int st, int dr)
    {
        ans = 0;
        Q(1, 1, N, st, dr);
        return ans;
    }

    void U(int pos, int val)
    {
        U(1, 1, N, pos, val);
    }

    void U(int st, int dr, int coef1, int coef2)
    {
        U(1, 1, N, st, dr, coef1, coef2);
        return;
    }
}aintp1, aintp2;

void printarray()
{
    for(int i = 1; i <= N; i++)
    {
        int S = aintp1.Q(i, i);
        printf("%d ", S);
    }
    printf("\n");
}

int main()
{
    #ifdef FILE_IO
    freopen("1.in", "r", stdin);
    freopen("1.out", "w", stdout);
    #endif

    int T;
    T = gint();
    while(T--)
    {
        int M;
        N = gint();
        M = gint();
        R = gint();
        p1 = gint();
        p2 = gint();
        aintp1.setmod(p1);
        aintp2.setmod(p2);
        for(int i = 1; i <= N; i++)
            v[i] = gint();

        aintp1.B();
        aintp2.B();
        //printarray();
        while(M--)
        {
            int op;
            op = gint();
            if(op == 1)
            {
                int pos, pw;
                pos = gint();
                pw = gint();
                int val = aintp2.Q(pos, pos);
                val = power(val, pw, p2);
                aintp1.U(pos, val % p1);
                aintp2.U(pos, val);
            }
            else if(op == 2)
            {
                int st, dr;
                st = gint();
                dr = gint();
                int ans = aintp1.Q(st, dr);
                printf("%d\n", ans);
            }
            else
            {
                int start, dif, st, dr;
                start = gint();
                dif = gint();
                st = gint();
                dr = gint();
                aintp1.U(st, dr, start, dif);
                aintp2.U(st, dr, start, dif);
            }
            //printarray();
        }
    }

    return 0;
}
