#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<string>
#include<cmath>
#include<stack>
#include<queue>
#include<map>
#include<set>
#include<algorithm>
#include<ctime>
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;

#define pb push_back
#define VEC vector
#define For(i,a,b) for(int i=a;i<=b;i++)
#define For_(i,a,b) for(int i=a;i>=b;i--)
#define mem(a,k) memset(a,k,sizeof(a))
#define sqr(a) ((a)*(a))
#define getc getchar_unlocked
#define lc(o) (o<<1)
#define rc(o) ((o<<1)|1)
#define Update(o) (Sum[o]=(Sum[lc(o)]+Sum[rc(o)])%mod)
//#define getc getchar
inline void read(int &x)//mini fast input function
{
    x=0;
    int ch=getc();int sign=1;
    while(ch<'0'||ch>'9'){if(ch=='-')sign=-1;ch=getc();}
    while(ch>='0'&&ch<='9')
        x=(x<<3)+(x<<1)+ch-'0',ch=getc();
    x=x*sign;
}
const int maxn=100010;
int n,q,p1,p2;
class SegmentTree{
private:
    int mod;
    int R1[maxn],R2[maxn],R3[maxn];
    int Sum[maxn<<2],Size[maxn<<2];
    int S[maxn<<2],D[maxn<<2];
    inline void Mark(const int &o,const int &s,const int &d){
        S[o]=(S[o]+s)%mod;
        D[o]=(D[o]+d)%mod;
        Sum[o]=(Sum[o]+(LL)s*R2[Size[o]-1]+(LL)d*R3[Size[o]-1])%mod;
    }
    inline void PushDown(const int &o){
        if(S[o] || D[o])
        {
            Mark(lc(o),S[o],D[o]);
            Mark(rc(o),(S[o]+(LL)Size[lc(o)]*D[o]%mod)*R1[Size[lc(o)]]%mod,((LL)D[o]*R1[Size[lc(o)]]%mod));
            S[o]=D[o]=0;
        }
    }
    inline void Build(int *A,int L=1,int R=n,int o=1){
        S[o]=D[o]=0;
        if(L==R)
        {
            Sum[o]=A[L]%mod;
            Size[o]=1;
            return ;
        }
        int mid=(L+R)>>1;
        Build(A,L,mid,lc(o));
        Build(A,mid+1,R,rc(o));
        Update(o);
        Size[o]=Size[lc(o)]+Size[rc(o)];
    }
public:
    inline void Modify(const int &s,const int &d,const int &ql,const int &qr,int L=1,int R=n,int o=1){
        if(ql==L && R==qr)
        {
            Mark(o,s,d);
            return ;
        }
        PushDown(o);
        int mid=(L+R)>>1;
        if(qr<=mid)Modify(s,d,ql,qr,L,mid,lc(o));
        else if(mid<ql)Modify(s,d,ql,qr,mid+1,R,rc(o));
        else
        {
            Modify(s,d,ql,mid,L,mid,lc(o));
            int size=mid-ql+1;
            Modify(((s+(LL)size*d%mod)*R1[size]%mod),((LL)d*R1[size]%mod),mid+1,qr,mid+1,R,rc(o));
        }
        Update(o);
    }
    inline void Change(const int &pos,const int &v,int L=1,int R=n,int o=1){
        if(L==R)
        {
            Sum[o]=v%mod;
            return ;
        }
        PushDown(o);
        int mid=(L+R)>>1;
        if(pos<=mid)Change(pos,v,L,mid,lc(o));
        else Change(pos,v,mid+1,R,rc(o));
        Update(o);
    }
    inline int Query(const int &ql,const int &qr,int L=1,int R=n,int o=1){
        if(qr<L || R<ql)return 0;
        if(ql<=L && R<=qr)return Sum[o];
        PushDown(o);
        int mid=(L+R)>>1,Ans=0;
        Ans=(Query(ql,qr,L,mid,lc(o))+Query(ql,qr,mid+1,R,rc(o)))%mod;
        Update(o);
        return Ans;
    }
    void Init(int _mod,int *A){
        mod=_mod;
        Build(A);
        R1[0]=R2[0]=1;R3[0]=0;
        for(int i=1;i<=n;i++)R1[i]=(LL)R1[i-1]*q%mod;
        for(int i=1;i<=n;i++)R2[i]=(R2[i-1]+R1[i])%mod;
        for(int i=1;i<=n;i++)R3[i]=(R3[i-1]+(LL)R1[i]*i%mod)%mod;
    }
}Tree1,Tree2;
int A[maxn];
LL Pow(LL x,LL y,int mod)
{
    LL Ans=1;
    while(y)
    {
        if(y&1)Ans=Ans*x%mod;
        x=x*x%mod;
        y>>=1;
    }
    return Ans;
}
void Solve()
{
    int m;
    read(n),read(m),read(q),read(p1),read(p2);
    for(int i=1;i<=n;i++)
        read(A[i]);
    Tree1.Init(p1,A);Tree2.Init(p2,A);
    while(m--)
    {
        int type;
        int s,d,l,r,g;
        read(type);
        if(type==0)
        {
            read(s),read(d),read(l),read(r);
            Tree1.Modify(s,d,l,r);
            Tree2.Modify(s,d,l,r);
        }
        else if(type==1)
        {
            read(l),read(g);
            int Ax=Tree2.Query(l,l);
            Ax=Pow(Ax,g,p2);
            Tree1.Change(l,Ax);
            Tree2.Change(l,Ax);
        }
        else if(type==2)
        {
            read(l),read(r);
            printf("%d\n",Tree1.Query(l,r));
        }
    }
}
int main()
{
    #ifndef ONLINE_JUDGE
    freopen("data.in","r",stdin);
    freopen("data.out","w",stdout);
    #endif
    int T;
    scanf("%d",&T);
    while(T--)
        Solve();
    return 0;
}
