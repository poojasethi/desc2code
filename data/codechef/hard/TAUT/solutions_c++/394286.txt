#include <vector>
#include <list>
#include <cassert>
#include <sstream>
#include <map>
#include <set>
#include <climits>
#include <deque>
#include <fstream>
#include <stack>
#include <bitset>
#include <stack>
#include <queue>
#include <algorithm>
#include <functional>
#include <numeric>
#include <cstring>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

template<class A, class B> A cvt(B x) {stringstream s;s<<x;A r;s>>r;return r;}

#define FOR(i,a,b) for(int i= (int )a ; i < (int )b ; ++i) 
#define REP(i,n) FOR(i,0,n)
#define PB push_back
#define PP pop()
#define EM empty()
#define INF 1000000000
#define PF push_front
#define ALL(x) x.begin(),x.end()
#define SORT(x) sort(ALL(x))
#define V(x) vector< x >
#define Debug false
#define PRINT(x)        cout << #x << " " << x << endl
#define LET(x,a) 	    __typeof(a) x(a)
#define IFOR(i,a,b) 	for(LET(i,a);i!=(b);++i)
#define EACH(it,v)  	IFOR(it,v.begin(),v.end())
#define PRESENT(c,x) 	((c).find(x) != (c).end())
#define SZ(x) 		x.size();
#define CPRESENT(c,x) 	(find(c.begin(),c.end(),x) != (c).end())
#define D(N) 		int N
#define S(N)		scanf("%d",&N)

typedef pair<int,int>  PI;
typedef pair<int,PI>   TRI;
typedef V( int )       VI;
typedef V( PI  )       VII;
typedef V( string )    VS;
typedef long long      LL;

bool eval (char var);
int pos [26];
int vars;
int ptr;
int assign;

class Exp {
	public :
		char type;
		Exp *left;
		Exp *right;
		bool evaluate ();
};

bool Exp::evaluate () {
	switch (type) {
	case 'C':	return (left->evaluate () && right->evaluate ());
	case 'D':	return (left->evaluate () || right->evaluate ());
	case 'I':	return (!left->evaluate () || right->evaluate ());
	case 'E':	return (left->evaluate () == right->evaluate ());
	case 'N':	return (!left->evaluate ());
	default :
		return eval (type);
	}
}

bool eval (char var) {
	return ((assign & (1 << pos [var-'a'])) != 0);
}

Exp* formExpression (string str) {
	Exp *ret = new Exp;
	ret->type = str [ptr++];
	if (ret->type >= 97 && ret->type <= 122) {
		if (pos [ret->type-'a'] == -1) {
			pos [ret->type-'a'] = vars++;
		}
	}
	else {
		ret->left = formExpression (str);
		if (ret->type != 'N') ret->right = formExpression (str);
	}
	return ret;
}

int main () {
	int test;
	cin >> test;
	int flag = 0;
	while (test-- > 0) {
		string str;
		cin >> str;
		memset (pos, -1, sizeof (pos));
		vars = 0;
		ptr = 0;
		flag = 0;
		Exp *expres = formExpression (str);
		for (assign = (1<<vars)-1; assign>=0; assign--) {
			if (!expres->evaluate ()) {
				cout << "NO" << endl;
				flag = 1;
				break;
			}
		}
		if (flag == 0) cout << "YES" << endl;
	}
}