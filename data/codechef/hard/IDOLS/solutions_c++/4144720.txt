#include<iostream>
#include<stdio.h> 
#include<algorithm>
#include<math.h>
#include<vector>
#include<set>
#include<stdlib.h>
#include<string.h>
#include<queue>
#include<stack>
#include<assert.h>
#include<limits.h>
#define tr(i) for(typeof(i.begin()) it=i.begin(); it!=i.end();it++)
#define pb push_back
#define mp make_pair
#define REP(i,n) for(int i=0;i<n;i++)
#define rep(i,s,n) for(int i=s;i<n;i++)
#define s(n) scanf("%d",&n)
#define XX first
#define X first
#define Y second
#define all(a) a.begin(),a.end()
#define YY second.first
#define ZZ second.second
#define fill(a,b) memset(a,b,sizeof(a))
#define DREP(a) sort(all(a)); a.erase(unique(all(a)),a.end());
#define INDEX(arr,ind) (lower_bound(all(arr),ind)-arr.begin())
#define SZ(x) (int)(x.size())
#define lin(val,j) (DP[j]-val*D[j])
using namespace std;
typedef long long LL;
typedef pair<int,int> pii;
#define MN 100000
int A[MN],par[MN];
vector<vector<int> > ad;
int N,Q;
int w[MN];
int cl[MN],cr[MN],chain[MN],sz[MN],pos[MN],D[MN];
int cc=0;

struct node
{
	int mx,tms;
	node(){ mx=-1e9; tms=0; }
	void merge(node &l, node &r)
	{
		if(l.mx>r.mx) mx=l.mx,tms=l.tms;
		else if(r.mx>l.mx) mx=r.mx,tms=r.tms;
		else mx=l.mx,tms=l.tms+r.tms;
	}
};
struct seg
{
	node* seq;
	int h;
	seg() {}
	seg(int sz) 
	{
		h=ceil(log2(sz));
		seq=new node[1<<(h+1)];
	}
	void build()
	{
		for(int i=(1<<h)-1;i>0;i--) seq[i].merge(seq[2*i],seq[2*i+1]);
	}
	node q(int root, int lef, int rig, int u, int v)
	{
		//cout<<root<<" "<<u<<" "<<v<<endl;
		if(u<=lef&&rig<=v) return seq[root];
		int lc=2*root, rc=lc+1,mid=(lef+rig)/2;
		node l,r,n;
		if(u<mid) l=q(lc,lef,mid,u,v);
		if(mid<v) r=q(rc,mid,rig,u,v);
		n.merge(l,r);
		return n;
	}
	node query(int i)
	{
		return q(1,(1<<h),1<<(h+1),(1<<h)+i,1<<(h+1));
	}
	void mup(int i)
	{
		while(i>1) 
		{
			i>>=1;
			seq[i].merge(seq[2*i],seq[2*i+1]);
		}
	}
	void up(int i, int Ax)
	{
		seq[(1<<h)+pos[i]].mx=Ax-D[i];
		seq[(1<<h)+pos[i]].tms=1;
		mup((1<<h)+pos[i]);
	}
} *hld;
void dfs(int i)
{
	w[i]=1;
	//cout<<i<<endl;
	tr(ad[i])
	{
		D[*it]=D[i]+1;
		dfs(*it);
		w[i]+=w[*it];
	}
	tr(ad[i])
	{
		if(w[*it]>=((w[i]+1)/2))
		{
			chain[i]=chain[*it];
			sz[chain[i]]++;
			cl[chain[i]]=i;
			pos[i]=pos[*it]+1;
			return;
		}
	}
	cl[cc]=cr[cc]=i;
	sz[cc]++;
	chain[i]=cc++;
	pos[i]=0;
}

int main()
{	
	s(N); s(Q);
	REP(i,N) cin>>A[i];
	ad.resize(N);
	par[0]=-1;
	D[0]=0;
	REP(i,(N-1))
	{
		s(par[i+1]);
		ad[--par[i+1]].pb(i+1);
	}
	dfs(0);
	int k,v,val;
	hld=new seg[cc];
	REP(c,cc) hld[c]=seg(sz[c]);
	REP(i,N)
	{
		//cout<<chain[i]<<" "<<i<<" "<<sz[chain[i]]<<endl;
		int h=hld[chain[i]].h;
		hld[chain[i]].seq[(1<<h)+pos[i]].mx=A[i]-D[i];
		hld[chain[i]].seq[(1<<h)+pos[i]].tms=1;
	}
	REP(c,cc) hld[c].build();
	REP(qq,Q)
	{
		s(k);
		if(k==0)
		{
			s(v); s(val);
			v--;
			hld[chain[v]].up(v,val);
		}
		else
		{
			s(v);
			v--;
			int ov=v;
			node n=hld[chain[v]].query(pos[v]),m;
			v=par[cl[chain[v]]];
			while(v!=-1)
			{
				m= hld[chain[v]].query(pos[v]);
				n.merge(n,m);
				v=par[cl[chain[v]]];
			}
			cout<<n.mx+D[ov]<<" "<<n.tms<<endl;
		}
	}
	return 0;
}
