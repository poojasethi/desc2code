#include <cstdio>
#include <cmath>
#include <iostream>
#include <set>
#include <algorithm>
#include <vector>
#include <map>
#include <cassert>
#include <string>
#include <cstring>

using namespace std;

#define rep(i,a,b) for(int i = a; i < b; i++)
#define S(x) scanf("%d",&x)
#define P(x) printf("%d\n",x)

typedef long long int LL;
const int N = 100001;
int A[N];

vector<int > g[N];
int P[N], dep[N];
int n;
int SSize[N]; // subtree size
int chain;
int chainHead[N], chainSize[N], chainNumber[N];
vector<int > chains[N];

// chaining of  tree start----
void dfs(int c, int d) {
	dep[c] = d;
	rep(i,0,g[c].size()) if(g[c][i] != P[c]) {
		dfs(g[c][i], d+1);
		SSize[c] += SSize[g[c][i]];
	}
	SSize[c]++;
}

void hld(int c) {

	if(chainHead[c] == -1) {
		chainHead[c] = c;
		chainSize[chain] = 0;
	} else {
		chainHead[c] = chainHead[P[c]];
	}
	chainNumber[c] = chain;
	chainSize[chain]++;
	if(!chains[chain].size()) chains[chain].push_back(0);
	chains[chain].push_back(c);

	int idx = -1;
	rep(i,0,g[c].size()) if(g[c][i] != P[c]) {
		int u = g[c][i];
		if(idx == -1 || SSize[u] > SSize[idx]) {
			idx = u;
		}
	}

	if(idx != -1)
		hld(idx);

	rep(i,0,g[c].size()) if(g[c][i] != P[c] && g[c][i] != idx) {
		chain++;
		chainHead[g[c][i]] = -1;
		hld(g[c][i]);
	}

}

// chaining end -----

struct node {
	int mx, cnt;
};

node *ST[N];

void buildST(int idx, int nd, int b, int e) {
	if(b == e) {
		ST[idx][nd].mx = A[chains[idx][b]];
		ST[idx][nd].cnt = 1;
		return;
	}
	buildST(idx, nd<<1, b, (b+e)>>1);
	buildST(idx, (nd<<1)|1, (b+e)/2+1, e);

	ST[idx][nd].mx = max(ST[idx][nd<<1].mx, ST[idx][(nd<<1)|1].mx );

	if(ST[idx][nd<<1].mx > ST[idx][(nd<<1)|1].mx) {
		ST[idx][nd].cnt = ST[idx][nd<<1].cnt;
	} else if(ST[idx][nd<<1].mx < ST[idx][(nd<<1)|1].mx) {
		ST[idx][nd].cnt = ST[idx][(nd<<1)|1].cnt;
	} else {
		ST[idx][nd].cnt = ST[idx][nd<<1].cnt + ST[idx][(nd<<1)|1].cnt;
	}
}

void pre() {
	dfs(1, 0);
	chainHead[1] = -1;
	hld(1);

	rep(i,1,n+1) A[i] -= dep[i];


	rep(i,0,chain+1) {
		ST[i] = new node[4*chainSize[i]+4];
		buildST(i, 1, 1, chainSize[i]);
	}
}


void updateST(int idx, int nd, int b, int e, int x) {

	if(b == e) {
		ST[idx][nd].mx = A[chains[idx][b]];
		ST[idx][nd].cnt = 1;
		return;
	}

	if(x <= (b+e)/2) {
		updateST(idx, nd<<1, b, (b+e)/2, x);
	} else {
		updateST(idx, (nd<<1)|1, (b+e)/2+1, e, x);
	}

	ST[idx][nd].mx = max(ST[idx][nd<<1].mx, ST[idx][(nd<<1)|1].mx );

	if(ST[idx][nd<<1].mx > ST[idx][(nd<<1)|1].mx) {
		ST[idx][nd].cnt = ST[idx][nd<<1].cnt;
	} else if(ST[idx][nd<<1].mx < ST[idx][(nd<<1)|1].mx) {
		ST[idx][nd].cnt = ST[idx][(nd<<1)|1].cnt;
	} else {
		ST[idx][nd].cnt = ST[idx][nd<<1].cnt + ST[idx][(nd<<1)|1].cnt;
	}

}


node queryST(int idx, int nd, int b, int e, int x, int y) {
	// printf("%d %d %d %d %d %d\n",idx,nd,b,e,x,y);

	if(b == x && e == y) {
		return ST[idx][nd];
	}

	int m = (b+e)>>1;

	if(y <= m) {
		return queryST(idx, nd<<1, b, m, x, y);
	} else {
		if(x > m)
			return queryST(idx, (nd<<1)|1, m+1, e, x, y);
		else {
			node a = queryST(idx, nd<<1, b, m, x, m);
			node b = queryST(idx, (nd<<1)|1, m+1, e, m+1, y);
			if(b.mx > a.mx) return b;
			if(a.mx > b.mx) return a;
			a.cnt += b.cnt;
			return a;
		}
	}

}

node queryTree(int x) {

	node res;
	res.mx = res.cnt = 0;

	while(x) {
		// P(x);
		node tmp = queryST(chainNumber[x], 1, 1, chainSize[chainNumber[x]], 1, dep[x] - dep[chainHead[x]] + 1);
		if(tmp.mx > res.mx) {
			res.mx = tmp.mx;
			res.cnt = tmp.cnt;
		} else if(tmp.mx == res.mx) {
			res.cnt += tmp.cnt;
		}

		x = P[chainHead[x]];
		// P(x);
	}

	return res;
}

int main() {

	int q;
	scanf("%d%d",&n,&q);

	rep(i,1,n+1) S(A[i]);

	rep(i,2,n+1) {
		int x;
		S(x);
		P[i] = x;
		g[x].push_back(i);
		g[i].push_back(x);
	}

	pre();

	while(q--) {
		int type;
		S(type);
		if(type) {
			int x;
			S(x);
			node q = queryTree(x);
			printf("%d %d\n",q.mx+dep[x], q.cnt);

		} else {
			int x,val;
			scanf("%d%d",&x,&val);
			A[x] = val - dep[x];
			updateST(chainNumber[x], 1, 1, chainSize[chainNumber[x]], dep[x] - dep[chainHead[x]] + 1);
		}
	}
	return 0;
}