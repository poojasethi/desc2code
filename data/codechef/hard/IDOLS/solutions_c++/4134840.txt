#include<bits/stdc++.h>

using namespace std;

#define vi vector < int >
#define pb push_back
#define mp make_pair
#define ll long long
#define llu unsigned long long
#define MOD 1000000007
#define INF 2000000000
#define dbg(x) { cout<< #x << ": " << (x) << endl; }
#define all(x) x.begin(),x.end()
#define MAXN 100005

struct node
{
    int mx,cnt;
};

ll a[MAXN];

vector <node> tree[MAXN];
vi adj[MAXN];
int subSize[MAXN],depth[MAXN];
int chainNo,chainHead[MAXN],chainInd[MAXN],chainSize[MAXN],chainPos[MAXN];
vi chainArray[MAXN];

int P[MAXN][14];

void build_st(int node,int s,int e,int id)
{
    if(s == e)
    {
        tree[id][node].mx = chainArray[id][s];
        tree[id][node].cnt = 1;
        return;
    }
    int m = (s+e)/2;
    int child = 2*node;

    build_st(child,s,m,id);
    build_st(child+1,m+1,e,id);

    tree[id][node].mx = max(tree[id][child].mx,tree[id][child+1].mx);

    if(tree[id][node].mx == tree[id][child].mx)
        tree[id][node].cnt += tree[id][child].cnt;

    if(tree[id][node].mx == tree[id][child+1].mx)
        tree[id][node].cnt += tree[id][child+1].cnt;
}

void update_st(int node,int s,int e,int pos,int val,int id)
{
    if(s == e && s == pos)
    {
        tree[id][node].mx = val;
        tree[id][node].cnt = 1;
        return;
    }
    int m = (s+e)/2;
    int child = 2*node;

    if(pos <= m)
    {
        update_st(child,s,m,pos,val,id);
    }
    else
    {
        update_st(child+1,m+1,e,pos,val,id);
    }

    tree[id][node].mx = max(tree[id][child].mx,tree[id][child+1].mx);
    tree[id][node].cnt = 0;

    if(tree[id][node].mx == tree[id][child].mx)
        tree[id][node].cnt += tree[id][child].cnt;

    if(tree[id][node].mx == tree[id][child+1].mx)
        tree[id][node].cnt += tree[id][child+1].cnt;
}

node query_st(int Node,int s,int e,int x,int y,int id)
{
    if(s == x && e == y)
    {
        return tree[id][Node];
    }
    int m = (s+e)/2;
    int child = 2*Node;

    if(y <= m)
    {
        return query_st(child,s,m,x,y,id);
    }
    else if(x > m)
    {
        return query_st(child+1,m+1,e,x,y,id);
    }
    else
    {
        node L = query_st(child,s,m,x,m,id);
        node R = query_st(child+1,m+1,e,m+1,y,id);
        node RES;
        RES.mx = max(L.mx,R.mx);
        RES.cnt = 0;
        if(RES.mx == L.mx)
            RES.cnt += L.cnt;
        if(RES.mx == R.mx)
            RES.cnt += R.cnt;
        return RES;
    }
}

int lca(int u,int v)
{
    if(depth[u] < depth[v])
        swap(u,v);

    int i,lg;

    for(lg=1;(1<<lg)<=depth[u];lg++);

    lg--;

    for(i=lg;i>=0;i--)
        if(depth[u] - (1<<i) >= depth[v])
        u = P[u][i];

    if(u == v)
        return u;

    for(i=lg;i>=0;i--)
        if(P[u][i] != -1 && P[u][i] != P[v][i])
        u = P[u][i],v = P[v][i];

    return P[u][0];
}


void dfs(int node,int par)
{
    int i;
    subSize[node] = 1;
    for(i=0;i<adj[node].size();i++)
    {
        if(adj[node][i] != par)
        {
            depth[adj[node][i]] = depth[node] + 1;
            dfs(adj[node][i],node);
            subSize[node] += subSize[adj[node][i]];
        }
    }
}

void hld(int node,int par)
{
    if(chainHead[chainNo] == -1)
    {
        chainHead[chainNo] = node;
        chainSize[chainNo] = 0;
    }

    chainInd[node] = chainNo;
    chainPos[node] = chainSize[chainNo];
    //-----------------------

    chainArray[chainNo].pb(a[node] - depth[node]);    // A[x] - depth[x]

    //-----------------------
    chainSize[chainNo]++;

    int mx = -1,id = -1,i;

    for(i=0;i<adj[node].size();i++)
    {
        if(adj[node][i]!=par)
        {
            if(mx < subSize[adj[node][i]])
            {
                mx = subSize[adj[node][i]];
                id = adj[node][i];
            }
        }
    }

    if(id != -1)
    {
        hld(id,node);
    }

    for(i=0;i<adj[node].size();i++)
    {
        if(adj[node][i] != par && adj[node][i] != id)
        {
            chainNo++;
            hld(adj[node][i],node);
        }
    }
}

void init(int n)
{
    int i,j;
    for(i=0;i<n;i++)
    {
        chainHead[i] = -1;
        chainSize[i] = 0;

        adj[i].clear();

        for(j=0;j<14;j++)
            P[i][j] = -1;
    }
}

void prec(int n)
{
    int i,j;
    chainNo = 0;
    depth[0] = 0;
    dfs(0,-1);
    hld(0,-1);

    for(j=1;j<(1<<n);j++)
    {
        for(i=0;i<n;i++)
        {
            if(P[i][j-1] != -1)
            P[i][j] = P[P[i][j-1]][j-1];
        }
    }

    for(i=0;i<=chainNo;i++)
    {
        tree[i].resize(chainSize[i]*4);
        build_st(1,0,chainSize[i]-1,i);
    }
}

node query_up(int u,int v) // from u to v in upper direction
{
    int uchain , vchain = chainInd[v];
    node RET;
    RET.mx = -INF;
    RET.cnt = 0;
    while(1)
    {
        uchain = chainInd[u];
        if(uchain == vchain)
        {
            node TMP = query_st(1,0,chainSize[uchain]-1,chainPos[v],chainPos[u],uchain);
            if(TMP.mx > RET.mx)
            {
                RET.mx = TMP.mx;
                RET.cnt = TMP.cnt;
            }
            else if(TMP.mx == RET.mx)
            {
                RET.cnt += TMP.cnt;
            }
            break;
        }

        node TMP = query_st(1,0,chainSize[uchain]-1,0,chainPos[u],uchain);

        if(TMP.mx > RET.mx)
        {
            RET.mx = TMP.mx;
            RET.cnt = TMP.cnt;
        }
        else if(TMP.mx == RET.mx)
        {
            RET.cnt += TMP.cnt;
        }

        u = chainHead[uchain];
        u = P[u][0];
    }
    return RET;
}

node query(int v) // u = 0
{
    int l = 0; // l = lca(0,v)
    node ret = query_up(v,0);
    return ret;
}

void update(int u,int val)
{
    int uchain = chainInd[u];
    update_st(1,0,chainSize[uchain]-1,chainPos[u],val - depth[u],uchain);
}

int main()
{
    int i,n,q;
    scanf("%d%d",&n,&q);

    init(n);

    for(i=0;i<n;i++)
    {
        scanf("%lld",&a[i]);
    }

    for(i=1;i<n;i++)
    {
        int p;
        scanf("%d",&p);
        p--;
        adj[i].pb(p);
        adj[p].pb(i);
        P[i][0] = p;
    }

    prec(n);
    //dbg("AAAA");
    while(q--)
    {
        int op,x,val;
        scanf("%d%d",&op,&x);
        x--;
        if(op)
        {
            node ANS = query(x);
            printf("%d %d\n",depth[x] + ANS.mx,ANS.cnt);
        }
        else
        {
            scanf("%d",&val);
            update(x,val);
        }
    }
    return 0;
}
