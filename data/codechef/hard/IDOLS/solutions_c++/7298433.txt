#include<stdio.h>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <string>
#include <map>
#include <queue>
#include <set>
using namespace std;
#define S(x) scanf("%d",&x)
#define sz(c) int((c).size())
#define pb push_back
#define rep(i,x,y) for(int i = x; i < y; i++)
const int MAX = 100001;
int arr[MAX], par[MAX], depth[MAX], size[MAX];
int chainHead[MAX], cnum, ptr, whichNode[MAX];
int nodeChain[MAX], nodepos[MAX];
vector <int> g[MAX];
struct node{
int val,cnt;
}tree[5*MAX];
int dfs(int c)
{
    for(int i=0;i<int(g[c].size());i++)
        if(g[c][i]!=par[c])
        size[c]+=dfs(g[c][i]);
    return size[c];
}
void hld(int c)
{
	if(chainHead[cnum] == 0) chainHead[cnum] = c;
	nodeChain[c] = cnum;
	nodepos[c] = ptr;
	whichNode[ptr] = c; ptr++;
	int id, mx = -1;
	for(int i=0;i<int(g[c].size());i++)if(g[c][i]!=par[c]){
		if(mx < size[g[c][i]]){
			mx = size[g[c][i]];
			id = g[c][i];
		}
	}
	if(mx != -1) hld(id);
	for(int i=0;i<int(g[c].size());i++)if(g[c][i]!=par[c] && g[c][i] != id){
		cnum++;
		hld(g[c][i]);
	}
}
node merge(node a, node b)
{
	if(a.val < b.val) return b;
	if(a.val > b.val) return a;
	node tmp = {a.val,a.cnt+b.cnt};
	return tmp;
}


void build_tree(int cur, int l, int r)
{
	if(l == r){
		tree[cur].val = arr[whichNode[l]] - depth[whichNode[l]];
		tree[cur].cnt = 1;
		return ;
	}
	int m = (l+r)>>1, L = cur << 1, R = L + 1;
	build_tree(L,l,m); build_tree(R,m+1,r);
	tree[cur] = merge(tree[L], tree[R]);
}
node query_tree(int cur, int l, int r, int x, int y)
{
	if(l == x && r == y){
		return tree[cur];
	}
	int m = (l+r)>>1, L = cur << 1, R = L + 1;
	if(y <= m) return query_tree(L,l,m,x,y);
	else if(x > m) return query_tree(R,m+1,r,x,y);
	else return merge(query_tree(L,l,m,x,m),query_tree(R,m+1,r,m+1,y));
}
void update_tree(int cur, int l, int r, int x, int data)
{
	if(l == r){
		tree[cur].val = data;
		tree[cur].cnt = 1;
		return ;
	}
	int m = (l+r)>>1, L = cur << 1, R = L + 1;
	if(x <= m) update_tree(L,l,m,x,data);
	else update_tree(R,m+1,r,x,data);
	tree[cur] = merge(tree[L], tree[R]);
}
node query_up(int u)
{
	int uchain = nodeChain[u];
	node ans = {-10000000,0};
	while(1){
		if(uchain == 0){
			ans = merge(ans,query_tree(1,0,ptr-1,nodepos[1],nodepos[u]));
			break;
		}
		ans = merge(ans,query_tree(1,0,ptr-1,nodepos[chainHead[uchain]],nodepos[u]));
		u = par[chainHead[uchain]];
		uchain = nodeChain[u];
	}
	return ans;
}
int main()
{
	int n, q;
	S(n); S(q);
	rep(i,1,n+1){
		S(arr[i]);
		size[i] = 1;
	}
	par[1] = -1;
	rep(i,2,n+1){
		int x;
		S(x);
		par[i] = x;
		depth[i] = depth[x]+1;
		g[i].pb(x);
		g[x].pb(i);
	}
	dfs(1);
	hld(1);
	build_tree(1,0,ptr-1);
	while(q--){
		int x, y, z;
		S(x);
		if(x == 0){
			S(y); S(z);
			update_tree(1,0,ptr-1,nodepos[y],z-depth[y]);
		}
		else{
			S(y);
			node tmp = query_up(y);
			printf("%d %d\n",depth[y]+tmp.val,tmp.cnt);
		}
	}
	return 0;
}
