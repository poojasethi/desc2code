#include <iostream>
#include <iomanip>
#include <vector>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <numeric>
#include <map>
#include <cassert>
#include <queue>
#include <sstream>
#include <set>
using namespace std;

//BEGIN_CODETEMPLATE
//END_CODETEMPLATE

char maze[105][105];
bool visited[105][105][105];

struct State
{
	int i;
	int j;
	int sum;
};

int main()
{
	int t;
	cin >> t;

	while(t--)
	{
		int M;
		int N;

		cin >> M >> N;

		memset(visited, false, sizeof(visited));

		State init;
		init.sum = 0;

		for(int i=0 ; i<=M ; i++)
			for(int j=0 ; j<=N ; j++)
			{
				cin >> maze[i][j];
				
				if(maze[i][j] == '*')
				{
					init.i = i;
					init.j = j;
				}
			}

		int X;
		cin >> X;

		queue<State> Q;
		int cnt = 0;

		Q.push(init);
		visited[init.i][init.j][0] = true;

		bool found = false;

		while(Q.size())
		{
			int oldsize = Q.size();

			while(oldsize--)
			{
				State &f = Q.front();

				if(f.sum == X)
				{
					cout << cnt << endl;
					found = true;
					goto out;
				}

				if(f.sum < X)
				{
					State next;

					for(int di=-1 ; di<=1 ; di++)
						for(int dj=-1 ; dj<=1 ; dj++)
							if((di!=0 && dj==0) || (di==0 && dj!=0))
							{
								int ni = f.i + di;
								int nj = f.j + dj;

								if(ni>=0 && ni<=M && nj>=0 && nj<=N)
								{
									char c = maze[ni][nj];

									if(c == '#') continue;

									next.i = ni;
									next.j = nj;
									next.sum = f.sum;

									if(c >= '0' && c <= '9')
										next.sum += c - '0';

									if(!visited[next.i][next.j][next.sum])
									{
										Q.push(next);
										visited[next.i][next.j][next.sum] = true;
									}
								}
							}
				}

				Q.pop();
			}

			cnt++;
		}

out:
		if(!found) cout << -1 << endl;
	}

	return 0;
}