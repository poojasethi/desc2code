// #include <stdio.h>
// #include <string.h>
// #include <queue>
// #include <assert.h>
// #include <ctype.h>
// using namespace std;
// 
// char visit[101][101][101];
// char grid[101][102];
// int dirs[4][2] = {{-1,0},{1,0},{0,1},{0,-1}};
// 
// struct state {
// 	int x, y, s;
// 	state(int x, int y, int s):x(x), y(y), s(s) {
// 	}
// };
// 
// int main() {
// #ifndef ONLINE_JUDGE
// 	freopen("input.txt","r",stdin);
// 	//freopen("output.txt","w",stdout);
// #endif
// 
// 	int n, m, tc;
// 	scanf("%d", &tc);
// 	while(tc--) {
// 		scanf("%d %d", &n, &m);
// 		assert(n >= 0 && n <= 100);
// 		assert(m >= 0 && m <= 100);
// 		++n;
// 		++m;
// 		memset(visit, 0, sizeof(visit));
// 		queue<state> Q;
// 		for (int i=0; i<n; ++i) {
// 			scanf("%s", grid[i]);
// 			for (int j=0; j<m; ++j) {
// 				if (grid[i][j] == '*') {
// 					Q.push(state(i,j,0));
// 					visit[i][j][0] = 1;
// 				}
// 			}
// 		}
// 		assert(Q.size() == 1);
// 		int q;
// 		scanf("%d", &q);
// 		assert(q >= 1 && q <= 100);
// 		int steps = 0;
// 		while(!Q.empty()) {
// 			int oldsize = Q.size();
// 			while(oldsize--) {
// 				state cur = Q.front();
// 				if (cur.s == q) {
// 					printf("%d\n", steps);
// 					goto done;
// 				}
// 				Q.pop();
// 				for (int i=0; i<4; ++i) {
// 					int tx = cur.x + dirs[i][0];
// 					int ty = cur.y + dirs[i][1];
// 					if (tx < 0 || tx >= n || ty < 0 || ty >= m || grid[tx][ty] == '#')
// 						continue;
// 					int ts = cur.s;
// 					if (isdigit(grid[tx][ty]))
// 						ts += grid[tx][ty]-'0';
// 					if (ts <= q && !visit[tx][ty][ts]) {
// 						visit[tx][ty][ts] = 1;
// 						Q.push(state(tx,ty,ts));
// 					}
// 				}
// 			}
// 			++steps;
// 		}
// 		puts("-1");
// done:;
// 	}
// 	return 0;
// }









#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <math.h>
#include <time.h>
#include <float.h> 
#include <assert.h>
#include <cmath>//M_PI
#include <queue>
#include <utility>

using namespace std;
#define FOR(i,a,b) for(int i=(a);i<(b);++i) 
#define REP(i,n) FOR(i,0,n) 
#define FORE(i,a,b) for(int i=(a);i<=(b);++i) 
#define REPE(i,n) FORE(i,0,n) 
#define SZ(v) ((int)v.size())
#define LL long long

struct node
{
	int x;
	int y;
	int sum;
	int step;
	node(int a, int b, int c, int d)
	{
		x=a,y=b,sum=c,step=d;
	}
};

bool bm[101][101][101];
int main()
{
#ifndef ONLINE_JUDGE
	freopen("input.txt","r",stdin);
	//freopen("output.txt","w",stdout);
#endif


	int T;
	scanf("%d", &T);

	while(T--)
	{
		REP(i,101)REP(j,101)REP(k,101) bm[i][j][k] = false;

		int M,N;
		scanf("%d %d\n", &N, &M);
		vector<string> m;
		REPE(i,N)
		{
			char str[1000];
			scanf("%s\n", str);
			m.push_back(str);
		}
		int X;
		scanf("%d\n\n", &X);
		
		int sx=-1,sy=-1;

		REPE(i, N)
			REPE(j,M)
				if(m[i][j]=='*') sx=j,sy=i;

		assert(sx!=-1 && sy!=-1);

		queue<node> q;
		q.push(node(sx,sy,0,0));

		int count = 0;
		bool bFound = false;
		while(!q.empty())
		{
			//if(++count>100000) break;
			node n = q.front();q.pop();


			if(n.x<0 || n.x>M || n.y<0 || n.y>N) continue;
			//if(n.step>100) continue;

			if(bm[n.x][n.y][n.sum]) continue;
			bm[n.x][n.y][n.sum] = true;

			if(m[n.y][n.x]=='#') continue;
			if(m[n.y][n.x]>='0' && m[n.y][n.x]<='9') n.sum+=m[n.y][n.x]-'0';


			if(n.sum>X) continue;
			if(n.sum==X)
			{
				bFound = true;
				printf("%d\n", n.step);
				break;
			}

			q.push(node(n.x-1, n.y, n.sum, n.step+1));
			q.push(node(n.x+1, n.y, n.sum, n.step+1));
			q.push(node(n.x, n.y-1, n.sum, n.step+1));
			q.push(node(n.x, n.y+1, n.sum, n.step+1));
		}
		if(bFound==false)
		{
			printf("-1\n");
		}
	}

	return 0;
}

