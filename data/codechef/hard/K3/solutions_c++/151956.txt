
/***** Author : Kunal *****/
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>

#include <cmath>
#include <cstdio>
#include <queue>
#include <list>
#include <stack>
#include <utility>
#include <numeric>
#include <map>
#include <cctype>
#include <cstring>
#include <sstream>
#include <cstdlib>
#include <cassert>

using namespace std;

#define F(a,b) for(int a=0;a<b;a++)
#define REP(a,b) for(int a=0;a<b;a++)
#define FOR(a,b,c) for(int a=b;a<c;a++)
#define FORD(a,b,c) for(int a=b;a>=c;a--)

#define s scanf
#define p printf

#define LEN(x) ((int)x.length())
#define SZ(x) ((int)x.size())
#define ALL(x) x.begin(), x.end()
#define MP(x,y) make_pair(x,y)
#define PB(x) push_back(x)
#define INF 1000000000

typedef long long LL;
typedef pair<int,int> PII;
typedef pair<int, PII> PIII;
typedef vector<int> VI;
typedef vector<bool> VB;
typedef vector<string> VS;

int d[][2]={{-1.0},{1,0},{0,-1},{0,1}};

char A[105][105];
int n,m;
bool marked[105][105];

int dist[105][105];

int num[100];
int xcount;
int a[1200];

map<int,map<int,int> > M;
map<int, pair<int,int> > MRev;

int numcount;

inline void BFS(int i, int j, int step)
{
	int ti,tj;
	queue<PIII> Q;
	Q.push(MP(0,MP(i,j)));
	while(!Q.empty())
	{
		i=Q.front().second.first;
		j=Q.front().second.second;
		step=Q.front().first;
		Q.pop();

		F(k,4)
		{
			ti=d[k][0]+i;
			tj=d[k][1]+j;
			if(ti>=0 && ti<n && tj>=0 && tj<m && !marked[ti][tj] && A[ti][tj]!='#')
			{
				if(isdigit(A[ti][tj]))
				{
					M[ti][tj]=xcount;
					MRev[xcount]=MP(ti,tj);
					dist[xcount][xcount]=2;
					dist[0][xcount++]=step+1;
					num[numcount++]=A[ti][tj]-'0';
					assert(numcount<100);
				}
					Q.push(MP(step+1,MP(ti,tj)));
				marked[ti][tj]=true;
			}
		}
	}
}

inline void BFS1(int node,int i, int j, int step)
{
	int ti,tj;
	queue<PIII> Q;
	Q.push(MP(0,MP(i,j)));
	while(!Q.empty())
	{
		i=Q.front().second.first;
		j=Q.front().second.second;
		step=Q.front().first;
		Q.pop();

		F(k,4)
		{
			ti=d[k][0]+i;
			tj=d[k][1]+j;
			if(ti>=0 && ti<n && tj>=0 && tj<m && !marked[ti][tj] && A[ti][tj]!='#')
			{
				if(isdigit(A[ti][tj]))
				{
					dist[node][M[ti][tj]]=step+1;
				}
					Q.push(MP(step+1,MP(ti,tj)));
				marked[ti][tj]=true;
			}
		}
	}
}

void formGraph()
{
	PII tmp;
	FOR(i,1,xcount)
	{
		memset(marked,0,sizeof(marked));
		tmp=MRev[i];
		BFS1(i,tmp.first,tmp.second,0);
	}
}

bool KS(int sum)
{
	//vector<bool> a(sum+1);
	memset(a,0,sizeof(a));
	a[0]=true;
	F(i,numcount)
	{
		F(j,sum+1)
			if(j-num[i]>=0 && a[j-num[i]]==true)
			{
				a[j]=true;
			}
	}
	return a[sum];
}

int ans;

void solveGen(int node, int len, int left)
{
	if(left<0) return;
	if(len>=ans) return;
	if(left==0)
	{
		ans=min(ans,len);
		return;
	}
	PII tmp;
	FOR(i,1,xcount)
	{
			tmp=MRev[i];
			solveGen(i, len+dist[node][i], left-A[tmp.first][tmp.second]+'0');
	}
}

int main()
{
	bool fl;
	int t;
	int sum;
	s("%d",&t);
	gets(A[0]);
	while(t--)
	{
		M.clear();
		MRev.clear();
		s("%d%d",&n,&m);
		n++,m++;
		gets(A[0]);
		F(i,n) gets(A[i]);
		s("%d",&sum);

		memset(dist,0,sizeof(dist));
		numcount=0;
		xcount=1;
		memset(marked,0,sizeof(marked));
		F(i,n) F(j,m) if(A[i][j]=='*') {marked[i][j]=true;BFS(i,j,0);break;}

		fl=KS(sum);

		if(!fl) p("-1\n");
		else
		{
			ans=INF;
			formGraph();
			solveGen(0, 0, sum);
			p("%d\n",ans);
		}
	}
	return 0;
}
