//This is getting accepted!
#include<bits/stdc++.h>
#define pb push_back
#define mp make_pair
#define PI acos(-1)
#define ll long long
const int MOD = 1000000007;
const double eps = 1e-8;
const int nm = 500005;
using namespace std;
 
int n, m, k, t;
ll res;
int a[nm], b[nm];
int disc;
 
struct Node{
	int cnt;
	Node *left, *right;
	Node(int _, Node* l, Node*r): cnt(_), left(l), right(r){}
	Node* insert(int l, int r, int k);
};
 
Node *null = new Node(0, NULL, NULL);
Node *root[nm];
 
Node* Node::insert(int l, int r, int k){
	if(l > k || r < k) return this;
	if(l == r) return new Node(this->cnt + 1, null, null);
	int mid = (l + r) >> 1;
	return new Node(this->cnt + 1, this->left->insert(l, mid, k), this->right->insert(mid + 1, r, k));
}
 
int cmp(int u, int v){
	return b[u] < b[v];
}
 
int query(Node* u, Node* v, int l, int r, int k){
	if(l == r) return l;
	int mid = (l + r) >> 1;
	int cnt = v->left->cnt - u->left->cnt;
	if(cnt >= k)
		return query(u->left, v->left, l, mid, k);
	else
		return query(u->right, v->right, mid + 1, r, k - cnt);
}
 
int q1[nm << 2], q2[nm << 2], lq = 0, rq = 0;
 
void getRange(){
	int vL, vR;
	q1[rq] = 0;
	q2[rq++] = MOD;
	while(lq < rq){
		vL = q1[lq];
		vR = q2[lq++];
		if(vL > vR) continue;
		int j, lb, ub;
		int l = 0, r = n - 1, mid;
		
		while(l < r){
			mid = (l + r) >> 1;
			if(b[a[mid]] >= vL)
				r = mid;
			else l = mid + 1;
		}
		lb = l;
		
		l = 0, r = n - 1;
		while(l + 1 < r){
			mid = (l + r) >> 1;
			if(b[a[mid]] <= vR)
				l = mid;
			else r = mid - 1;
		}
		for(j = r; j > l; j--)
			if(b[a[j]] <= vR) break;
		ub = j;
		
		int sz = ub - lb + 1;
		if(sz <= 1) continue;
		res += sz;
		mid = (sz + 1) >> 1;
		int pivot = b[query(lb <= 0 ? null : root[lb - 1], root[ub], 0, disc, mid)];
		q1[rq] = vL;
		q2[rq++] = pivot - 1;
		
		q1[rq] = pivot + 1;
		q2[rq++] = vR;
	}
	
}
 
int main(){
    #ifndef ONLINE_JUDGE
    freopen("inp2.txt", "r", stdin);
    #endif
	int i, j, x, y, z, u, v, w;
	scanf("%d", &n);
	for(i = 0; i < n; i++)
		scanf("%d", &b[i]), a[i] = i;
	sort(a, a + n, cmp);
	disc = n - 1;
	
	null->left = null->right = null;
	root[0] = null->insert(0, disc, a[0]);
	for(i = 1; i < n; i++)
		root[i] = root[i - 1]->insert(0, disc, a[i]);
	
	getRange();
 
	printf("%lld", res);
 
	return 0;
} 