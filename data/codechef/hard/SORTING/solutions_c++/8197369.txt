#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
 
int A[500005],Inv[500005],N,As[500005];
 
void ucitaj(){
    int i;
    scanf("%d",&N);
    for (i=1; i<=N; i++) scanf("%d",A+i);
    for (i=1; i<=N; i++) Inv[A[i]] = i;
}
 
struct node{
    node *next,*prev;
    int key;
};
 
struct task{
    int l,r;
};
 
node L[500005],*median,*Invs[500005];
task T[500005];
int Tb,Te,Ls,lrm;
 
long long sol;
 
void napravi_fmm(int l,int r){
    Ls=0;
    int i;
    for (i=l; i<=r; i++) As[i] = Inv[i];
    sort(As+l,As+r+1);
    for (i=l; i<=r; i++){
        Ls++;
        L[Ls].key = As[i];
        L[Ls].prev = L+Ls-1;
        L[Ls].next = L+Ls+1;
        Invs[As[i]] = L+Ls;
    }
    L[0].key = 0;
    L[0].next = L+1;
    L[0].prev = NULL;
    L[Ls+1].next = NULL;
    L[Ls+1].prev = L+Ls;
    L[Ls+1].key = N+1;
    median = L+(Ls+1)/2;
    lrm = Ls;
}
 
void izbaci_fmm(node *ptr){
    ptr->next->prev = ptr->prev;
    ptr->prev->next = ptr->next;
    lrm--;
    if (lrm%2==1){
        if (ptr->key <= median->key) median = median->next;
    } else {
        if (ptr->key >= median->key) median = median->prev;
    }
}
 
void resi_sa_vrha(){
    int l,r,x,i;
    l = T[Tb].l;
    r = T[Tb].r;
    Tb++;
    if (l>=r) return;
    napravi_fmm(l,r);
    while (l<r){
        //printf("%d %d\n",l,r);
        sol += r-l+1;
        x = A[median->key];
        if (x-l > r-x){
            Te++;
            T[Te].l = x+1;
            T[Te].r = r;
            for (i=x; i<=r; i++){
                izbaci_fmm(Invs[Inv[i]]);
            }
            r = x-1;
        } else {
            Te++;
            T[Te].l = l;
            T[Te].r = x-1;
            for (i=l; i<=x; i++){
                izbaci_fmm(Invs[Inv[i]]);
            }
            l = x+1;
        }
    }
}
 
int main(){
    ucitaj();
    Tb=1;
    Te=1;
    T[1].l = 1;
    T[1].r = N;
    while (Tb<=Te) resi_sa_vrha();
    printf("%lld\n",sol);
    return 0;
} 