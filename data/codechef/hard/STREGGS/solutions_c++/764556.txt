#include<iostream>
#include<queue>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<set>
#include<string>
#include<cstring>
#include<map>
#include<numeric>
#include<sstream>
#include<cmath>
using namespace std;
#define all(v) (v).begin(), (v).end()
#define rall(v) (v).rbegin(), (v).rend()
#define pb push_back
#define f(i,x,y) for(int i = x; i<y; i++)
#define FOR(it,A) for(typeof A.begin() it = A.begin(); it!= A.end(); it++)
#define quad(x) (x) * (x)
#define mp make_pair
#define clr(x, y) memset(x, y, sizeof x)
#define fst first
#define snd second
typedef pair<int, int> pii;
typedef long long ll;
typedef long double ld;
#define inf (1LL << 40)
#define N 505
struct pt{
   ll x, y;
   pt(ll a = 0, ll b = 0): x(a), y(b){}
   pt operator -(pt q){return pt(x - q.x, y - q.y);}
   ll operator %(pt q){return x * q.y - y * q.x;}
};
ll A[N];
ll G[N][N];
pt T[N];
int n, sz;

void add(ll x, ll y){
   pt p(x, y);
   while(sz >= 2 && (p - T[sz - 1]) % (p - T[sz - 2]) <= 0) sz--;
   T[sz++] = p;
   if(sz >= 2 && T[sz - 1].x == T[sz - 2].x) sz--;
}
ll eval(int i, ll x){
   return T[i].x * x + T[i].y;
}
int main(){
	int t; cin >> t;
   A[0] = 0;
   while(t--){
      int K;
      scanf("%d %d", &n, &K);
      f(i, 0, n) scanf("%lld", A + i);
      sort(A, A + n);

      f(k, 0, K + 1){
         sz = 0;
         for(int pos = n; pos >= 0; pos--){
            ll &res = G[pos][k];
            if(pos == n) res = k == 0 ? 0LL : inf;
            else{
               if(k && G[pos + 1][k - 1] != inf) add(pos + 1, G[pos + 1][k - 1]);
               res = inf;

               int le = 0, ri = sz - 1;
               while(ri - le >= 4){
                  int a = le + (ri - le) / 3, b = le + (ri - le) * 2 / 3;
                  if(eval(a, A[pos]) < eval(b, A[pos])) ri = b;
                  else le = a;
               }
               f(it, le, ri + 1)
                  res = min(res, eval(it, A[pos]) - A[pos] * pos);
            }

         }
      }
      ll ret = inf;
      f(i, 0, n) ret = min(ret, G[i][K]);
      printf("%lld\n", ret);
   }
}

