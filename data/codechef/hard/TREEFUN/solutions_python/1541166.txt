#include <cstdio>
#include <cassert>

#include <list>
#include <set>
#include <utility>
#include <algorithm>

using namespace std;

#define assertr(x,a,b) assert(a <= (x) && b >= (x))

typedef pair<int,int> pii;
#define fi first
#define se second

int N;
pii e[1<<16];
int p[1<<16][16];
int h[1<<16];

int goDown(int u, int steps) {
    for(int i=15;i>=0;i--) if(steps&(1<<i)) u = p[u][i];
    return u;
}

int find_lca(int u, int v) {
    if(h[u]>h[v]) swap(u,v);
    v = goDown(v, h[v]-h[u]);
    if(v == u) return u;
    for(int i=15;i>=0;i--) if(p[u][i] != p[v][i]) {
        u = p[u][i];
        v = p[v][i];
    }
    return p[u][0];
}

int getNode(int u, int v, int w) {
    int a = find_lca(u, v),
        b = find_lca(v, w),
        c = find_lca(w, u);
    int ma = h[a], r = a;
    if(ma < h[b]) {
        ma = h[b];
        r = b;
    }
    if(ma < h[c]) {
        ma = h[c];
        r = c;
    }
    if(r == u || r == v || r == w) return 0;
    return r;
}

int K;
int t[1<<16];

pii _sbh[1<<16];
void sort_by_height() {
    for(int i=0;i<K;i++) {
        _sbh[i].fi = h[t[i]];
        _sbh[i].se = t[i];
    }
    sort(_sbh,_sbh+K);
    for(int i=0;i<K;i++) t[i] = _sbh[i].se;
}

int do_query() {
    scanf("%d",&K);
    assertr(K,2,N);
    set<int> _T;
    for(int i=0;i<K;i++) {
        scanf("%d",&t[i]);
        assertr(t[i],1,N);
        assert(_T.find(t[i]) == _T.end());
        _T.insert(t[i]);
    }
    sort_by_height();
    if(K == 2) {
        int u = t[0];
        int v = goDown(t[1], h[t[1]]-h[t[0]]);
        if(v == u) return h[t[1]]-h[t[0]]-1;
        int w = find_lca(u, v);
        return h[t[0]]-h[w]+h[t[1]]-h[w]-1;
    }
    /*the answer will be either 1, or 0*/
    int r = getNode(t[0], t[1], t[2]);
    if(r == 0) return 0;
    set<int> vis;
    for(int i=0;i<K;i++) {
        if(t[i] == r) return 0;
        if(h[t[i]] <= h[r]) {
            if(vis.find(0) != vis.end()) return 0;
            vis.insert(0);
            continue;
        }
        int x = goDown(t[i], h[t[i]]-h[r]-1);
        if(p[x][0] != r) {
            if(vis.find(0) != vis.end()) return 0;
            vis.insert(0);
            continue;
        }
        if(vis.find(x) != vis.end()) return 0;
        vis.insert(x);
    }
    return 1;
}

list<int> A[1<<16];
int vi[1<<16];

void dfs(int u, int pa, int hi) {
    vi[u] = 1;
    p[u][0] = pa;
    h[u] = hi;
    for(list<int>::iterator it=A[u].begin(); it!=A[u].end(); it++) {
        int v = *it;
        assert(v == pa || !vi[v]);
        if(v != pa) dfs(v, u, hi+1);
    }
}

int main() {
    int T;
    scanf("%d",&T);
    assertr(T,1,5);
    while(T--) {
        int M;
        scanf("%d%d",&N,&M);
        assertr(N,1,50000);
        assertr(M,1,50000);
        for(int i=0;i<N-1;i++) {
            scanf("%d%d",&(e[i].fi),&(e[i].se));
            assertr(e[i].fi,1,N);
            assertr(e[i].se,1,N);
            if(e[i].fi>e[i].se) swap(e[i].fi,e[i].se);
        }
        sort(e,e+N-1);
        for(int i=1;i<=N;i++) {
            p[i][0]=-1;
            h[i]=0;
            A[i].clear();
            vi[i] = 0;
        }
        for(int i=0;i<N-1;i++) {
            int u=e[i].fi, v=e[i].se;
            A[u].push_back(v);
            A[v].push_back(u);
        }
        dfs(1,0,0);
        for(int i=1;i<=N;i++) assert(p[i][0] != -1);
        for(int j=1;j<16;j++)
            for(int i=1;i<=N;i++) {
                int u = p[i][j-1];
                if(u != -1) p[i][j] = p[u][j-1];
            }
        while(M--) printf("%d\n", do_query());
    }
    return 0;
}