#include<bits/stdc++.h>
 
#define forn(i, n) for (int i = 0; i < int(n); i++)
#define forl(i, n) for (int i = 1; i <= int(n); i++)
#define ford(i, n) for (int i = int(n) - 1; i >= 0; i--)
#define fore(i, l, r) for (int i = int(l); i <= int(r); i++)
#define correct(x, y, n, m) (0 <= (x) && (x) < (n) && 0 <= (y) && (y) < (m))
#define all(a) (a).begin(), (a).end()
#define sz(a) int((a).size())
#define pb(a) push_back(a)
#define mp(x, y) make_pair((x), (y))
#define ft first
#define sc second
#define x first
#define y second
#define DEBUG 1
 
using namespace std;
 
typedef long long li;
typedef long double ld;
typedef pair<int, int> pt;
 
template<typename X> inline X abs(const X& a) { return a < 0? -a: a; }
template<typename X> inline X sqr(const X& a) { return a * a; }
template<typename X> inline void print(const vector<X>& a, ostream& out) { forn(i, sz(a)) { out << a[i]; if (i + 1 < sz(a)) out << ' '; } out << endl; }
template<typename X> inline void print(const vector<X>& a) { if (DEBUG) print(a, cerr); }
template<typename X> inline void print(X *a, int n, ostream& out) { print(vector<X> (a, a + n), out); }
template<typename X> inline void print(X *a, int n) { print(vector<X> (a, a + n)); }
template<typename X> inline ostream& operator<< (ostream& out, const pair<X, X>& p) { return out << '(' << p.x << ' ' << p.y << ')'; }
 
const int INF = int(1e9);
const li INF64 = li(1e18);
const ld EPS = 1e-9, PI = 3.1415926535897932384626433832795;
 
const int N = 50 * 1000 + 3, LOGN = 18;
 
int n, m;
vector<int> g[N];
 
inline bool read()
{
	if (scanf("%d%d", &n, &m) != 2)
		return false;
		
	forn(i, n)
		g[i].clear();
		
	forn(i, n - 1)
	{
		int x, y;
		assert(scanf("%d%d", &x, &y) == 2);
		x--, y--;
		
		g[x].pb(y), g[y].pb(x);
	}
	
	return true;
}
 
int tt, tin[N], tout[N];
int p[LOGN][N];
int d[N];
int z1[N];
int z2[N];
 
void dfs(int v, int pr, int depth, int num)
{
	tin[v] = tt++;
	d[v] = depth;
	z2[v] = num;
	
	p[0][v] = pr;
	
	forl(i, LOGN - 1)
		p[i][v] = p[i - 1][p[i - 1][v]];
		
	forn(i, sz(g[v]))
		if (g[v][i] != pr)
			dfs(g[v][i], v, depth + 1, i);
		else
			z1[v] = i;
			
	tout[v] = tt++;
}
 
inline bool parent(int a, int b) { return tin[a] <= tin[b] && tout[b] <= tout[a]; }
 
inline int lca(int a, int b)
{
	if (parent(a, b)) return a;
	if (parent(b, a)) return b;
	
	ford(i, LOGN)
		if (!parent(p[i][a], b))
			a = p[i][a];
			
	return p[0][a];
}
 
inline int get(int l, int v)
{
	if (!parent(l, v)) return z1[l];
	
	ford(i, LOGN)
		if (!parent(p[i][v], l))
			v = p[i][v];
			
	return z2[v];
}
 
int u = 0, used[N];
 
int szv, v[N];
 
inline bool check(int l)
{
	u++;
	
	forn(i, szv)
	{
		int cur = get(l, v[i]);
		
		if (l == v[i]) return false;
		if (used[cur] == u) return false;
		used[cur] = u;
	}
	
	return true;
}
 
inline bool check()
{
	assert(szv > 2);
	
	int l[] = { lca(v[0], v[1]), lca(v[0], v[2]), lca(v[1], v[2]) };
	
	forn(i, 3)
		if (check(l[i]))
			return true;
			
	return false;
}
 
inline void solve()
{
	tt = 0;
	dfs(0, 0, 0, n);
	
	forn(i, m)
	{
		int cnt;
		assert(scanf("%d", &cnt) == 1);
		szv = cnt;
		
		int x = -1, y = -1;
		
		forn(j, cnt)
		{
			int v;
			assert(scanf("%d", &v) == 1);
			v--;
			
			::v[j] = v;
			
			if (j == 0) x = v;
			y = v;
		}
		
		assert(x != -1 && y != -1);
		
		if (cnt > 2)
		{
			if (check())
				puts("1");
			else
				puts("0");
		}
		else
			printf("%d\n", d[x] + d[y] - 2 * d[lca(x, y)] - 1);
	}
}
 
int main()
{
    //freopen("input.txt", "rt", stdin);
    //freopen("output.txt", "wt", stdout);
    
    cout << setprecision(10) << fixed;
    cerr << setprecision(5) << fixed;
    
    int testCount;
    cin >> testCount;
    
    forn(test, testCount)
    {
	    assert(read());
		solve();
	}
	
    return 0;
}
 
