
#include <bits/stdc++.h>
using namespace std;

#if !ONLINE_JUDGE
#include "debug.h"
#else
#endif

typedef long long int LL;
typedef unsigned long long LLU;
typedef long double LD;

#define INF 1500000000000000000LL
#define MOD 1000000007
#define F first
#define S second
#define PB push_back
#define MK make_pair
#define LEN(vale) strlen(vale)
#define SZ(vale) (int)vale.size()
#define SQ(A) ((A)*(A))
#define FI(i,fa,fb) for(int i=fa;i<fb;++i)
#define FD(i,fa,fb) for(int i=fa;i>fb;--i)
#define FT(it,S) for(it = (S).begin(); it != (S).end(); ++it) 
#define bits(vale) __builtin_popcount(vale)
#define VT vector

#define SET1(array,val,sz) for(int i=0;i<sz;i++)array[i]=val;
#define SET2(array,val,sz1,sz2) for(int i=0;i<sz1;i++)for(int j=0;j<sz2;j++)array[i][j]=val;

#define ALL(a) (a.begin(),a.end())
#define LB (lower_bound)
#define UB (upper_bound)

#define SI(vale) scanf("%d",&vale)
#define PI(vale) printf("%d\n",vale)
#define PIS(vale) printf("%d ",vale)
#define SL(vale) scanf("%lld",&vale)
#define PL(vale) printf("%lld\n",vale)
#define PLS(vale) printf("%lld ",vale)
#define SS(vale) scanf("%s",vale)
#define PS(vale) printf("%s\n",vale)
#define SLD(vale) scanf("%Lf",&vale)
#define PLD(vale) printf("%0.12Lf\n",vale)
#define NL printf("\n")
#define TCS() int testcase; SI(testcase);while(testcase--) 

typedef pair<int,int> PR;
bool deb = false;
const int N = 50011;
const int LOGN = 32;
int n,Ncount;
bool mark[N];                                                                                                                                     
int dp[N][LOGN+5],dep[N],in[N],T;
int out[N],q[N]; // q stores query 
vector<int >gr[N];     // tree stores auxiliary tree
int deg[N];

void dfs(int v,int p) {
     in[v] = ++T;
     dp[v][0] = p;
     for(int i=1;i<=LOGN;++i)
          dp[v][i] = dp[dp[v][i-1]][i-1];
     dep[v] = dep[p] + 1;
     for(int i = 0;i<gr[v].size();i++) {
          int u = gr[v][i];
          if(u != p) {
               dfs(u,v);
          }
     }
     out[v] = T;
}


int LCA(int a,int b) {
     if(a == b)
          return a;
     if(dep[a] < dep[b]) swap(a,b);
     int diff = dep[a] - dep[b];
     int i = 0;
     while(i < LOGN) {
          if( (diff >> i) & 1)
               a = dp[a][i];
          i++;
     }
     if(a == b) return  a;
     i = LOGN-1;
     while(i >= 0) {
          if(dp[a][i] != dp[b][i])
               a = dp[a][i],b = dp[b][i];
          i--;
     }
     return dp[a][0];
}


bool isAnc(int p,int u) {
     return (in[p] <= in[u] && out[p] >= out[u]);
}


bool comp(int aa,int ab) {
     return in[aa] < in[ab];
}


int build_tree() {        // build auxiliary tree
     set<int>st;
     for(int i=0;i<Ncount;i++) st.insert(q[i]);
     Ncount = 0;
     for(auto it : st) {
          q[Ncount++] = it;
     }                   // find the unique nodes
     int TNodes = Ncount;
     sort(q,q+Ncount,comp);
     for(int i=0;i<TNodes-1;i++) {
          int lca = LCA(q[i],q[i+1]);
          if(st.find(lca) != st.end())   // if parent already exists
               continue;
          q[Ncount++] = lca;
          st.insert(lca);
     }
     sort(q,q+Ncount,comp);
     stack<int>S;
     S.push(q[0]);
     for(int i=1;i<Ncount;i++) {
          while((!isAnc(S.top(),q[i])))
               S.pop();
          deg[S.top()]++;
          deg[q[i]]++;
          S.push(q[i]);
     }
     return q[0];
}


void dfs2(int v,int p) {

}


void init() {
     T = 0;
     dp[1][0] = 0;
     dfs(1,0);
}


int main(){
     //clock_t tStart = clock();
     int t,m;
     TCS(){
          SI(n);SI(m);
          FI(i,0,n+2)gr[i].clear();
          FI(i,1,n) {
               int u,v;
               SI(u),SI(v);
               gr[u].PB(v);
               gr[v].PB(u);
          }
          init();
          while(m--) {
               SI(Ncount);
               int orc = Ncount;
               FI(i,0,Ncount) {
                    SI(q[i]);
                    mark[q[i]] = 1;
               }
               if(Ncount == 2) {
                    PI(dep[q[0]]+dep[q[1]]-2*dep[LCA(q[0],q[1])]-1);
               }
               else {
                    int root = build_tree();
                    int ans = 0;
                    FI(i,0,Ncount) if(deg[q[i]] == orc && !mark[q[i]]) {
                         ans++; break;
                    }
                    PI(ans);
               }
               FI(i,0,Ncount) {
                    mark[q[i]] = 0;
                    deg[q[i]] = 0;
               }
          }
     }
     //exectime();
     return 0;        
}


