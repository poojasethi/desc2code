#include<set>
#include<stack>
#include<cstdio>
#include<vector>
#include<algorithm>

#define rep(i,n) for(int i=0;i<(n);i++)

using namespace std;

const int V_MAX=50000,LG_V_MAX=17;

struct LCA_solver{
	int par[LG_V_MAX][V_MAX],dep[V_MAX];

	void build(int n,const vector<int> *T,int root=0){
		struct info{ int u,pre,d; };
		static info S[V_MAX];
		int head=0,tail=0;
		S[tail++]=(info){root,-1,0};
		while(head<tail){
			int u=S[head].u,pre=S[head].pre,d=S[head].d; head++;
			par[0][u]=pre;
			dep[u]=d;
			rep(i,T[u].size()) if(T[u][i]!=pre) S[tail++]=(info){T[u][i],u,d+1};
		}

		rep(i,LG_V_MAX-1) rep(u,n) par[i+1][u]=(par[i][u]==-1?-1:par[i][par[i][u]]);
	}

	int lca(int u,int v)const{
		if(dep[u]>dep[v]) swap(u,v);
		rep(i,LG_V_MAX) if((dep[v]-dep[u])>>i&1) v=par[i][v];
		if(u==v) return u;

		for(int i=LG_V_MAX-1;i>=0;i--){
			if(par[i][u]!=par[i][v]){
				u=par[i][u];
				v=par[i][v];
			}
		}
		return par[0][u];
	}
};

bool check(int k,const int *a,int tar,const LCA_solver &L){
	set<int> Nei; // a[i] から tar へ向かうパス上の頂点で tar と隣接しているもの
	rep(i,k){
		if(a[i]==tar) return false;

		int u;
		if(L.lca(a[i],tar)!=tar) u=L.par[0][tar];
		else{
			u=a[i];
			for(int j=LG_V_MAX;j>=0;j--){
				if(L.dep[tar]+(1<<j)<L.dep[u]){
					u=L.par[j][u];
				}
			}
		}
		if(Nei.count(u)>0) return false;
		Nei.insert(u);
	}
	return true;
}

void solve(){
	int n,q; scanf("%d%d",&n,&q);
	static vector<int> T[V_MAX];
	rep(u,n) T[u].clear();
	rep(i,n-1){
		int u,v; scanf("%d%d",&u,&v); u--; v--;
		T[u].push_back(v);
		T[v].push_back(u);
	}

	static LCA_solver L;
	L.build(n,T);

	while(q--){
		int k; scanf("%d",&k);
		static int a[50000];
		rep(i,k) scanf("%d",a+i), a[i]--;

		if(k>2){
			int w[3];
			w[0]=L.lca(a[0],a[1]);
			w[1]=L.lca(a[1],a[2]);
			w[2]=L.lca(a[2],a[0]);

			bool ok=false;
			rep(i,3) if(check(k,a,w[i],L)) { ok=true; break; }
			puts(ok?"1":"0");
		}
		else{ // k==2
			int w=L.lca(a[0],a[1]);
			printf("%d\n",L.dep[a[0]]+L.dep[a[1]]-2*L.dep[w]-1);
		}
	}
}

int main(){ int T; scanf("%d",&T); while(T--) solve(); return 0; }
