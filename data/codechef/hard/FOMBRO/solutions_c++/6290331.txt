
#include<bits/stdc++.h>
//#include <windows.h>
using namespace std;

#define FRE(i,a,b)  for(i = a; i <= b; i++)
#define FRL(i,a,b)  for(i = a; i < b; i++)
#define mem(t, v)   memset ((t) , v, sizeof(t))
#define sqr(x)      (x)*(x)
#define all(x)      x.begin(),x.end()
#define un(x)       x.erase(unique(all(x)), x.end())
#define sf(n)       scanf("%d", &n)
#define sff(a,b)    scanf("%d %d", &a, &b)
#define sfff(a,b,c) scanf("%d %d %d", &a, &b, &c)
#define D(x)        cout<<#x " = "<<(x)<<endl
#define pf          printf
#define VI          vector <int>
#define pii         pair <int, int>
#define pll         pair <LL, LL>
#define pb          push_back
#define mp          make_pair
#define pi          acos(-1.00)
#define DBG         pf("Hi\n")
#define sz          size()
#define ins         insert
#define fi          first
#define se          second
#define xx          first
#define yy          second
#define inf         (1<<29)
#define MOD         100007
#define eps         1e-9
#define MAX         1000000

typedef long long int LL;
typedef double db;

//int dx[] = {+0,+1,+0,-1};
//int dy[] = {+1,+0,-1,+0};
//int dx[] = {-1,-1,-1,+0,+0,+1,+1,+1};
//int dy[] = {-1,+0,+1,-1,+1,-1,+0,+1};
//bool check(int n, int pos) {return (bool) (n & (1<<pos));}
//int on(int n, int pos) {return n | (1<<pos); }
//int off(int n, int pos) {return n & ~(1<<pos); }

LL md, L[MAX+10], R[MAX+10];

LL ip(LL a, LL p)
{
    if(!p) return 1;
    if(p&1) return (a*ip(a,p-1))%md;
    LL ret = ip(a,p/2);
    return (ret*ret)%md;
}

//Range Minimum Query = Structre of Segment Tree [ Single Point update, range query ]
struct node{
    LL rem;
};

node tree[4*MAX];

node merge(node l, node r) //change here
{
    node ret;
    ret.rem = (l.rem*r.rem)%md;
    return ret;
}

void update_single_node(int idx, int val) // change here
{
    tree[idx].rem = val%md;
    return;
}

void update(int idx, int st, int ed, int pos, int val) // single point update
{
    if(pos < st || pos > ed) return;
    if(st == ed)
    {
        update_single_node(idx, val);
        return;
    }
    int mid = (st+ed)/2, l = 2*idx, r = l+1;
    update(l,st,mid,pos,val);
    update(r,mid+1,ed,pos,val);
    tree[idx] = merge(tree[l], tree[r]);
}

node query(int idx, int st, int ed, int i, int j) // Range Query
{
    if(st == i && ed == j) return tree[idx];
    int mid = (st+ed)/2, l =2*idx, r = l+1;
    if(j <= mid) return query(l,st,mid,i,j);
    if(i > mid) return query(r,mid+1,ed,i,j);
    return merge(query(l,st,mid,i,mid), query(r,mid+1,ed,mid+1,j));
}

int main()
{
    //freopen("in.txt", "r", stdin);

    int i, j, k, t, cs, n, q, r;
    LL res, a, p;

    sf(t);
    while(t--)
    {
        scanf("%d %lld %d", &n, &md, &q);

        L[1] = 1;
        FRE(i,2,n)
            L[i] = (L[i-1] * ip(i,i-1))%md;

        R[n] = ip(n, 1);
        for(i = n-1; i >= 1; i--)
            R[i] = (R[i+1]*ip(i,n-i+1))%md;
        R[n+1] = 1;
        FRE(i,1,n)
            update(1,1,n,i,i);

        while(q--)
        {
            sf(r);
            r = min(r, n-r);
            res = L[r];
            res = (res*R[n-r+1])%md;
            if(r+1 <= n-r)a = query(1,1,n,r+1,n-r).rem;
            else a = 1;
            res = (res*ip(a,r))%md;
            pf("%lld\n", res);
        }
    }

    return 0;
}
