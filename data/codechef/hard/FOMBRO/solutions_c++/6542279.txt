///This  code is created by Samar Singh Holkar
#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <deque>
#include <iomanip>
#include <iostream>
#include<list>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <vector>

using namespace std;

#define sd(x) scanf("%d",&x)
#define sfd(x) scanf("%d",&x)
#define sfld(x) scanf("%lld",&x
#define pf printf

#define LL long long
#define ll long long
#define LD long double
#define ld long double
#define PB push_back
#define pb push_back
#define MP make_pair
#define mp make_pair
#define F first
#define S second

#define pii pair<int,int>
#define vi vector<int>
#define fr(i,n) for( int i=0; i<=n; i++)
#define frm(i,m,n) for(int i=m; i<=n; i++)
#define N 200000

ll dp1[1000010],dp2[1000010];

ll modMul(ll x,ll y,ll z) {
    ll result = ((ll)x * y) % z;
    return result;
}

ll poww(ll x,ll y, ll z) {
    if (y == 0)
        return 1;

    ll sqrt = poww(x, y / 2, z);
    ll result = modMul(sqrt, sqrt, z);

    if (y % 2 == 1)
        result = modMul(result, x, z);

    return result;
}

ll fast_pow(ll base, ll n,ll M)
{
    if(n==0)
       return 1;
    if(n==1)
    return base;
    ll halfn=fast_pow(base,n/2,M);
    if(n%2==0)
        return ( halfn * halfn ) % M;
    else
        return ( ( ( halfn * halfn ) % M ) * base ) % M;
}



ll findMMI_fermat(ll n,ll M)
{
    return fast_pow(n,M-2,M);
}


int main(){

    int t; cin>>t;



    while(t--){

        ll n,m,q; cin>>n>>m>>q;dp1[1]=1;dp2[n]=n;

        for(int i=2;i<=n;i++){

            dp1[i] = (dp1[i-1]*poww(i,i-1,m))%m;
        }//cout<<dp1[2]<<"\n";

        for(int i=n-1;i>=1;i--){

            dp2[i] = (dp2[i+1]*poww(i,n-i+1,m))%m;
        }//cout<<dp2[4]<<"\n";

        ll dp[1000000];

        if(n&1){

            dp[n/2+1] = n/2+1;

            for(int i = n/2;i>=1;i--){

                dp[i] = (((dp[i+1]*i)%m)*(n-i+1))%m;
            }
        }

        else{

            dp[n/2] = ((n/2)*(n-n/2+1))%m;

            for(int i=n/2-1;i>=1;i--){

                dp[i] = (((dp[i+1]*i)%m)*(n-i+1))%m;
            }
        }

        for(int i=0;i<q;i++){

            ll r; cin>>r;

            r = min(r,n-r);

            ll ans = dp1[r];

            ll temp = poww(dp[r+1],r,m);

            ans = (ans*temp)%m;

            ans = (ans*dp2[n-r+1])%m;

            cout<<ans<<"\n";
        }



    }
}
