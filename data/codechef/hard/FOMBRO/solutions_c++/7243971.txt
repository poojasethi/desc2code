#include <bits/stdc++.h>
using namespace std;
#define ll  long long int
//#define MOD 13
#define MAXM    1001110

ll fordp[MAXM/2],backdp[MAXM/2],betdp[MAXM/2];
ll phi[MAXM];
ll exponentiation(ll base,ll exp,ll mod)
{
    ll ans=1;
    while(exp>0)
    {
        if(exp%2)   ans=(ans*base)%mod;
        base=(base*base)%mod;
        exp/=2;
    }
    return ans%mod;
}

ll inverse_mod(ll base,ll mod)
{
    return exponentiation(base,mod-2,mod);
}
ll euler_totient_funt(ll n)
{
    ll result=n;
    for(ll i=2;i<=sqrt(n);i++)
    {
        if(n%i==0)
            result=result-result/i;
        while(n%i==0)
            n/=i;
    }
    if(n>1)
        result=result-result/n;
    return result;
}
void euler_totient_sieve()  // sieve with phi function
{
    // phi(n) = n*(1-1/p)   p -> prime factors
    phi[0]=0;
    phi[1]=1;

    for(ll i=2;i<MAXM;i++)
    {
        if(!phi[i])
        {
            phi[i] = i-1;
            for(ll j=(i<<1);j<MAXM;j+=i)
            {
                if(!phi[j])
                    phi[j]=j;
                phi[j]=phi[j]/i*(i-1);          // to prevent overflow always use when modulo    as a/c*b instead of a*b/c
            }
        }
    }

}
pair<ll, pair<ll, ll> > extendedEuclid(ll a, ll b)
{
    ll x = 1, y = 0;
    ll xLast = 0, yLast = 1;
    ll q, r, m, n;
    while(a != 0)
    {
        q = b / a;
        r = b % a;
        m = xLast - q * x;
        n = yLast - q * y;
        xLast = x, yLast = y;
        x = m, y = n;
        b = a, a = r;
    }
    return make_pair(b, make_pair(xLast, yLast));
}
ll modInverse(ll a, ll m)
{
    return (extendedEuclid(a,m).second.first + m) % m;
}



int main()
{
ios::sync_with_stdio(0);
cin.tie(0);
    int t;
    cin>>t;
    while(t--)
    {
        ll i,n,r,m,q,ans=0,mid=0;
        cin>>n>>m>>q;
        mid=n/2;
        fordp[0]=1;
        for(i=1;i<=mid;i++)
            fordp[i]=((fordp[i-1]%m)*exponentiation(i,i-1,m))%m;
        backdp[0]=1;
        for(i=1;i<=mid;i++)
            backdp[i]=((backdp[i-1]%m)*exponentiation(n-i+1,i,m))%m;

        if(n%2==1)
            betdp[mid]=mid+1;
        else
            betdp[mid]=1;

        for(i=mid-1;i>=1;i--)
            betdp[i]=((((betdp[i+1]%m)*(i+1))%m)*(n-i))%m;
        while(q--)
        {
            cin>>r;
            r=min(r,n-r);
            //ans = (((fordp[r] * exponentiation(betdp[r],r,m))%m) * backdp[r])%m;
            ans=(((fordp[r]%m)*(backdp[r]%m))%m*(exponentiation(betdp[r],r,m)%m))%m;
            cout<<ans<<endl;
        }
    }
    return 0;
}
