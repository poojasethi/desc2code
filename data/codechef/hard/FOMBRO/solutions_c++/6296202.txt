#include<bits/stdc++.h>
using namespace std;
#define F(i,p,n) for(i=p;i<n;i++)
#define I(i,p,q) for(i=p;i>=q;i--)
#define Ss(x) scanf("%s",x)
#define S(x) scanf("%lld",&x)
#define P(x) printf("%lld\n",x)
#define Ps(x) printf("%lld ",x)
#define LL long long int
#define pii pair<LL,LL>
const LL maxn=1000005;
LL sieve[maxn],a[10][maxn],b[maxn],f[maxn],finv[maxn],m,n,r,a1[10][maxn],f1[maxn];
vector<LL> vec;
LL _pow(LL x,LL y,LL mod)
{
    if(!y)
        return 1;
    if(y==1)
        return x;
    if(y==2)
        return (x*x)%mod;
    if(y&1)
        return (x*_pow(x,y-1,mod))%mod;
    else
        return (_pow(_pow(x,y/2,mod),2,mod))%mod;
}
void pre()
{
    LL i,j,k;
    sieve[0]=sieve[1]=1;
    for(i=4;i<maxn;i+=2)
        sieve[i]=1;
    for(i=3;i*i<maxn;i+=2)
    {
        if(!sieve[i])
            for(j=i*i;j<maxn;j+=2*i)
                sieve[j]=1;
    }
}
LL invcal(LL x,LL y,LL p,LL q)
{
    LL i,j,k,r;
    if(y==0)
        return p;
    return invcal(y,x%y,q,p-(x/y)*q);
}
void precomp()
{
    LL i,p,j,k;
    F(i,0,n+1)
        b[i]=i;
    F(i,0,vec.size())
    {
        F(j,0,n+1)
        a[i][j]=a1[i][j]=0;
    }
    F(i,0,vec.size())
    {
        p=vec[i];
        while(p<=n)
        {
            for(j=p;j<=n;j+=p)
            {
                a[i][j]++;
                a1[i][j]++;
                b[j]/=vec[i];
            }
            p*=vec[i];
        }
    }
    finv[1]=f[1]=f1[1]=1;
    finv[0]=f[0]=f1[0]=1;
    F(i,2,n+1)
    {
        if(b[i]==1)
        {
            f[i]=f[i-1];
            finv[i]=finv[i-1];
            f1[i]=f1[i-1];
        }
        else
        {
            f[i]=(f[i-1]*_pow(b[i],i,m))%m;
            finv[i]=((invcal(f[i],m,1,0)%m)+m)%m;
            f1[i]=(b[i]*f1[i-1])%m;
        }
    }
    F(i,0,vec.size())
    {
        F(j,1,n+1)
        {
            a[i][j]=a[i][j-1]+a[i][j]*j;
            a1[i][j]+=a1[i][j-1];
        }
    }
}
int main()
{
    LL i,j,k,q,t;
    pre();
    S(t);
    while(t--)
    {
        S(n);
        S(m);
        F(i,2,n+1)
        {
            if(!sieve[i]&&m%i==0)
                vec.push_back(i);
        }
        precomp();

        /*printf("\nvec:\n");
        F(i,0,vec.size())
        Ps(vec[i]);
        printf("\narr b:\n");
        F(i,0,n+1)
        Ps(b[i]);
        printf("\narr a:\n");
        F(i,0,vec.size())
        {
            F(j,0,n+1)
            Ps(a[i][j]);
            printf("\n");
        }
        printf("\narr f:\n");
        F(i,0,n+1)
        Ps(f[i]);
        printf("\narr finv:\n");
        F(i,0,n+1)
        Ps(finv[i]);
        printf("\n");
        printf("\narr a1:\n");
        F(i,0,vec.size())
        {
            F(j,0,n+1)
            Ps(a1[i][j]);
            printf("\n");
        }
        printf("\narr f1:\n");
        F(i,0,n+1)
        Ps(f1[i]);
        printf("\n");*/

        S(q);
        while(q--)
        {
            S(r);
            LL ans=1;
            ans=(ans*f[n])%m;
            ans=(ans*finv[r])%m;
            ans=(ans*finv[n-r])%m;
            ans=((invcal(ans,m,1,0)%m)+m)%m;
            F(i,0,vec.size())
            {
                ans=(ans*_pow(vec[i],(n+1)*a1[i][n]-(r+1)*a1[i][r]-(n-r+1)*a1[i][n-r]-(a[i][n]-a[i][r]-a[i][n-r]),m))%m;
            }
            ans=(ans*_pow(f1[n],n+1,m))%m;
            LL in=(invcal(_pow(f1[r],r+1,m),m,1,0)%m+m)%m;
            ans=(ans*in)%m;
            in=(invcal(_pow(f1[n-r],n-r+1,m),m,1,0)%m+m)%m;
            ans=(ans*in)%m;
            P(ans);
        }
        vec.clear();
    }
    return 0;
}
