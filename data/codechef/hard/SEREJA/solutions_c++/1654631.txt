#include <iostream>
#include <cstdio>
#define MOD 1000000007
#define SIZE 300100
using namespace std;

int array[SIZE];

template<class T>
class SegTreeMin
{
	int size;
	public:
	int makeSegTree(T *arrT, int l, int r, int node)
	{
		if(l==r)
		{
			return l;
		}
		
		int mid = (l+r)/2;
		int left = makeSegTree(arrT, l, mid, 2*node);
		int right = makeSegTree(arrT, mid+1, r, 2*node+1);
		
		if(arrT[left] > arrT[right])
		{
			array[node] = right;
			return right;
		}
		else
		{
			array[node] = left;
			return left;
		}
	}
	
	
	SegTreeMin(int _size):size(_size)
	{
		//makeSegTree(arrT,0,size-1,1);		
	}	
	
	int query(int l, int r, int nodeL, int nodeR, int node, const T arrT[])
	{	
		/*	
		if(nodeR < l || nodeL > r)
			return -1;
		
		if(nodeL==nodeR)
			return nodeL;
		*/
		if(nodeL>=l && nodeR<=r)
			return array[node];
			
		int mid=(nodeL+nodeR)/2, left, right;
		
		if(mid < l || nodeL > r)
			left =  -1;
		else
			if(nodeL==mid)
				left = nodeL;
			else
				left = query(l, r, nodeL, mid, 2*node, arrT);
		
		if(nodeR < l || mid+1 > r)
			right = -1;
		else
			if(nodeR == mid+1)
				right = nodeR;
			else 
				right = query(l, r, mid+1, nodeR, 2*node+1, arrT);
	
		if(left==-1)
			return right;
		if(right==-1)
			return left;
			
		if(arrT[left] > arrT[right])
			return right;
		return left;
	}
	
	int *getArray()
	{
		return array;
	}
};
int arrayMax[SIZE];
	
template<class T>
class SegTreeMax
{
	int size;
	public:
	int makeSegTree(T *arrT, int l, int r, int node)
	{
		if(l==r)
		{
			return l;
		}
		
		int mid = (l+r)/2;
		
		int left = makeSegTree(arrT, l, mid, 2*node);
		int right = makeSegTree(arrT, mid+1, r, 2*node+1);
		
		if(arrT[left] < arrT[right])
		{
			arrayMax[node] = right;
			return right;
		}
		else
		{
			arrayMax[node] = left;
			return left;
		}
	}
	
	
	SegTreeMax(int _size):size(_size)
	{
		//makeSegTree(arrT,0,size-1,1);		
	}	
	
	int query(int l, int r, int nodeL, int nodeR, int node, const T arrT[])
	{
		/*
		if(nodeR < l || nodeL > r)
		{
			return -1;
		}
		
		if(nodeL==nodeR)
		{
			return nodeL;
		}
		*/
		if(nodeL>=l && nodeR<=r)
		{
			return arrayMax[node];
		}	
		
		int mid=(nodeL+nodeR)/2, left, right;
		
		if(mid < l || nodeL > r)
			left =  -1;
		else
			if(nodeL==mid)
				left = nodeL;
			else
				left = query(l, r, nodeL, mid, 2*node, arrT);
		
		if(nodeR < l || mid+1 > r)
			right = -1;
		else
			if(nodeR == mid+1)
				right = nodeR;
			else 
				right = query(l, r, mid+1, nodeR, 2*node+1, arrT);
	
		
		if(left==-1)
			return right;
		if(right==-1)
			return left;
		if(arrT[left] < arrT[right])
			return right;
		return left;
	}
	
	int *getArray()
	{
		return arrayMax;
	}
};

long long powerMod(long long a, long long b, long long mod)
{
	
	long long res = 1, pow = a;
	while(b)
	{
		if(b&1)
			res = (res * pow)% mod;
		pow = (pow * pow)%mod;
		b >>= 1;
	}	
	return res;
}

SegTreeMin<int> mini(SIZE);
SegTreeMax<int> maxx(SIZE);
	
SegTreeMin<int> &minT = mini;
SegTreeMax<int> &maxT = maxx;

int arr[100001],n,i,j;
long long prod = 1;
int maxQ, minQ,s=0;
int e , sArr;

long long Result = 1;
void evaluate(int i, int j, int &s, int &e, int &sArr)
{
	if(i>=j)
		return;
	//cout << i << " " << j << " \n" ;
	int max_idx = maxT.query(i,j,s,e,sArr,arr);
	evaluate(i, max_idx-1, s, e, sArr);
	evaluate(max_idx+1, j, s, e, sArr);
	int min_idx, diff;
	while(i<j)
	{
		min_idx = minT.query(i,j,s,e,sArr,arr);
		diff = arr[max_idx] - arr[min_idx];
		Result = (Result * powerMod(diff, 
				((long long)(min(max_idx, min_idx)-i+1))*(j-max(max_idx,min_idx)+1),
				MOD)) % MOD;
		// Result %= MOD;
		if(min_idx < max_idx)
			i = min_idx + 1;
		else
			j = min_idx - 1;
	}
}

int main()
{
	//clock_t start = clock(), end;
	scanf("%d", &n);
	
	for(i=0;i<n;++i)
	{
		scanf("%d",arr+i);
	}
	
	e = n-1, sArr = 1;
	
	maxT.makeSegTree(arr,0,n-1,1);	
	minT.makeSegTree(arr,0,n-1,1);	
	//cout << "Made Tree";
	evaluate(0,n-1,s,e,sArr);
		
	printf("%lld\n", Result);
	//end = clock();
	//cout << "\n"<< end-start << endl;

	return 0;
}

	
