//shivamrana
#include <cassert>
#include <cctype>
#include <cmath>
#include <cstring>
#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <set>
#include <map>
#include <vector>
#include <queue>
#include <list>
#include <deque>
#include <stack>
#include <iterator>
#include <string>
#include <sstream>
#include <iostream>
#include <fstream>
#include <functional>
#include <numeric>
#include <algorithm>
#define f0r(i,n) for(int i=0;i<n;i++)
#define fOr(i,n) for(int i=1;i<=n;i++)
#define si(a) scanf("%d",&a)
#define sl(a) scanf("%I64d",&a)
#define pi(a) printf("%d",a)
#define pl(a) printf("%I64d",a)
#define n(l) cout<<endl
#define ll long long
#define ull unsigned long long
#define mod 1000000007
#define vi vector<int>
#define pb(a) push_back(a)
#define modu( a ) ( ( (a) + mod)%mod )
using namespace std;
/*inline long long read_int() {
char c;
while ((c=getchar_unlocked()) < 48 || c > 57);
long long p = c-48;
while ((c=getchar_unlocked()) >= 48 && c <= 57) p=p*10+c-48;
return p;
}*/
long long gcd(long long a, long long b)
{
    if(a==0)
                return b;
        else
        if(b==0)
                return a;
        else
        {
                a=a%b;
                return gcd(b,a);
        }
}
ll M[524300]={-1};
ll X[524300]={-1};
ll A[100010];
int n;
void ini(int node,int b,int e)
{
     if(b==e)
     {
     M[node]=b;
     X[node]=b;
     }
     else
     {
     ini(node*2,b,(b+e)/2);
     ini(node*2+1,((b+e)/2)+1,e);
     if(A[M[node*2]]<=A[M[node*2+1]])
     M[node]=M[node*2];
     else 
     M[node]=M[node*2+1];
     if(A[X[node*2]]<=A[X[node*2+1]])
     X[node]=X[node*2+1];
     else 
     X[node]=X[node*2];
     }
}
int min_query(int node,int b,int e,int i,int j)
{
     if(i>e||j<b)
     return -1;
     if(b>=i&&e<=j)
     return M[node];
     int p1=min_query(node*2,b,(b+e)/2,i,j);
     int p2=min_query(node*2+1,((b+e)/2+1),e,i,j);
     if(p1==-1)
     return p2;
     if(p2==-1)
     return p1;
     if(A[p1]<=A[p2])
     return p1;
     else return p2;
} 
int max_query(int node,int b,int e,int i,int j)
{
     if(i>e||j<b)
     return -1;
     if(b>=i&&e<=j)
     return X[node];
     int p1=max_query(node*2,b,(b+e)/2,i,j);
     int p2=max_query(node*2+1,((b+e)/2+1),e,i,j);
     if(p1==-1)
     return p2;
     if(p2==-1)
     return p1;
     if(A[p1]<=A[p2])
     return p2;
     else return p1;
}
ull modpow(ull n,ull p)
{
if(n==0)
return 0;
if(p==0)
return 1;
if(p==1)
return n;
else {
     ll temp=modpow(n,p/2);
     if(p%2)
     return (((temp*temp)%mod*n)>mod)?((temp*temp)%mod*n)%mod:((temp*temp)%mod*n);
     else return (temp*temp*1ull)%mod;
     }
}
ull RS=1;
void solve(int i,int j)
{
     if( i>= j )
return;
int min_idx = min_query( 1, 0, n - 1, i, j );
solve( i, min_idx - 1 );
solve( min_idx + 1, j );
while( j > i ){
int max_idx = max_query( 1, 0, n - 1, i, j );
unsigned long long diff = A[ max_idx ] - A[ min_idx ], L = min( min_idx, max_idx ) - i + 1, R = j - max( min_idx, max_idx ) + 1;
//printf( "For (%d, %d), diff : %lld, R : %lld, L : %lld : %lld\n", i, j, diff, R, L, power( diff, R*L ) );
RS = modu( RS*modpow( diff, R*L ) );
min_idx < max_idx ? j = max_idx - 1 : i = max_idx + 1;
}
}
int main()
{
si(n);
f0r(i,n)
scanf("%lld",&A[i]);//A[i]=read_int();
ini(1,0,n-1);
 RS=1;
solve(0,n-1);
printf("%lld\n",RS);
system("pause");
return 0;
}
