#include<cstdio>
#include<vector>
#include<set>
#include<map>
#include<queue>
#include<algorithm>
#include<string>
#include<utility>
#include<cassert>
using namespace std;

#define REP(i,a,b) for(i=a;i<b;i++)
#define rep(i,n) REP(i,0,n)

#define ll long long

#define M 1000000007

int mymin(int a, int b){ if(a<b) return a; return b; }
int mymax(int a, int b){ if(a>b) return a; return b; }

/* Range Minimum Query */
/* res[n*k+i] = argmin( i<=k<i+2^k, arr[k] ) */
void doublingRMQBuild(int *arr,int n, int res[][30] )
{
        for ( int i = 0 ; i < n; i++ )
        {
                res[i][0] = i;
        }
        for ( int j = 1; (1<<j) < n; j++ )
        {
                for ( int i = 0; i + (1<<j) - 1 < n ; i++ )
                {
                        if ( arr[res[i][j-1]] < arr[res[i+(1<<(j-1))][j-1]]  )
                        {
                                res[i][j] = res[i][j-1];
                        }
                        else
                        {
                                res[i][j] = res[i+(1<<(j-1))][j-1];
                        }
  //                      cout << i << " "<<i+(1<<j)-1<<" " <<res[i][j] << endl;
                }
        }
        return;
}
int doublingRMQQuery(int *arr, int n,int res[][30], int start, int end)
{
        int j = 0;
        for ( ; start+(1<<j) < end+1; j++ );
        if ( arr[res[start][j-1]] <  arr[res[end-(1<<(j-1))+1][j-1]])
        {
                return res[start][j-1];
        }
        return   res[end-(1<<(j-1))+1][j-1];
}

ll pw(ll a,ll b, ll md){
  ll r;
  if(!b) return 1;
  r = pw(a,b/2,md);
  r = (r*r)%md;
  if(b%2) r = (r*a)%md;
  return r;
}

int N;
int A[100001], A_i[100001], rmq[100001][30], rmq_i[100001][30];
map<pair<int,int>,ll> memo;

ll solve(int a, int b){
  int k, mn, mx, ind_mn, ind_mx;
  ll res = 0;
  pair<int,int> p = make_pair(a,b);

  if(a >= b) return 1;
  if(memo.count(p)) return memo[p];

  mn = doublingRMQQuery(A, N, rmq, a, b);
  mx = doublingRMQQuery(A_i, N, rmq_i, a, b);

  ind_mn = mymin(mn, mx);
  ind_mx = mymax(mn, mx);

  res = pw( (A[mx]-A[mn])%M, (ll)(ind_mn-a+1)*(b-ind_mx+1), M );
  res = (res * solve(a, ind_mx-1))%M;
  res = (res * solve(ind_mn+1, b))%M;
  res = (res * pw(solve(ind_mn+1, ind_mx-1),M-2, M))%M; /* res = res / solve(ind_mn+1,ind_mx-1) */

  return memo[p] = res;
}

int main(){
  int i;
  ll res;

  assert( scanf("%d",&N)==1 );
  assert( 2<=N && N<=100000 );
  rep(i,N) assert( scanf("%d",A+i)==1 ), assert( 1<=A[i]&&A[i]<=1000000000 );

  rep(i,N) A_i[i] = -A[i];

  doublingRMQBuild(A, N, rmq);
  doublingRMQBuild(A_i, N, rmq_i);

  res = solve(0, N-1);
  printf("%d\n",(int)res);
  //fprintf(stderr,"count %d\n",memo.size());

  return 0;
}

