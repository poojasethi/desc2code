#include <iostream>
#include <cstdio>
#include <vector>
#include <stack>
#include <algorithm>
#include<map>
#include <math.h>
typedef long long int ul ;
#define MOD 1000000007
//#define for(i,l,n) for(int i=l+1;i<n;i++)
//#define range(j,i,n) for(int j=i+1;j<n;j++)
using namespace std;
int findAns(int s,int e);
ul modexp(int a, long long int b);
void initialize_min(ul a[],int node,int m[],int b,int e);
int query_min(ul a[],int node,int m[],int i,int j,int b,int e);
int query_max(ul a[],int node,int m[],int i,int j,int b,int e);
ul a[100005]; int maxo[1000000],mino[1000000]; int n; 
void initialize_max(ul a[],int node,int m[],int b,int e){
    // cout<<"node="<<node<<"\n";
     if(b==e)
              m[node]=b;
              
     else {
          initialize_max(a,2*node,m,b,(b+e)/2);
          initialize_max(a,2*node+1,m,((b+e)/2)+1,e);
          
          m[node]=a[m[2*node]]>a[m[2*node+1]]?m[2*node]:m[2*node+1];
          //cout<<"m["<<node<<"] ="<<m[node]<<"\n";
          }
          }    
                   
          
          void initialize_min(ul a[],int node,int m[],int b,int e){
     //cout<<"node="<<node<<"\n";
     if(b==e)
              m[node]=b;
              
     else {
          initialize_min(a,2*node,m,b,(b+e)/2);
          initialize_min(a,2*node+1,m,((b+e)/2)+1,e);
          
          m[node]=a[m[2*node]]<a[m[2*node+1]]?m[2*node]:m[2*node+1];
          //cout<<"m["<<node<<"] ="<<m[node]<<"\n";
          }
          }         
int query_min(ul a[],int node,int m[],int i,int j,int b,int e){
  int p1,p2;  
if(i>e || j<b) return -1;
if(b>=i && e<=j) return m[node];
 
p1=query_min(a,2*node,m,i,j,b,(b+e)/2);
p2=query_min(a,2*node+1,m,i,j,((b+e)/2)+1,e);
//cout<<"p2"<<p2<<"\n";
//cout<<"p1"<<p1<<"\n";
if(p1==-1)return p2; /*these two lines for retrieving  max and min which coincides with one of the trees interval */
if(p2==-1)return p1; 
if(a[p1]<=a[p2]) return p1;
return p2;
}   
 
 
 
int query_max(ul a[],int node,int m[],int i,int j,int b,int e){
  int p1,p2;  
if(i>e || j<b) return -1;
if(b>=i && e<=j) return m[node];
 
p1=query_max(a,2*node,m,i,j,b,(int)((b+e)/2));
p2=query_max(a,2*node+1,m,i,j,(int)((b+e)/2)+1,e);
//cout<<"p2"<<p2<<"\n";
//cout<<"p1"<<p1<<"\n";
if(p1==-1) return p2; /*these two lines for retrieving  max and min which coincides with one of the trees interval */
if(p2==-1) return p1; 
if(a[p1]>=a[p2]) return p1;
return p2;
}   
 
int main(){
    int k,i,j,p,u,q;
    ul result; 
    scanf("%d",&n);u=log2(n)+1;
    k=2*(1<<u);//cout<<k;
    
    for(int i=0;i<n;i++) scanf("%lld",&a[i]);
    for(int j=0;j<k;j++) {maxo[i]=-1;mino[i]=-1;}
    //for(i,k) cout<<m[i]<<"\n";
    initialize_min(a,1,mino,0,n-1);
    initialize_max(a,1,maxo,0,n-1);
   // for(i,k) cout<<m[i]<<"\n";
   result=findAns(0,n-1);
   printf("%llu\n",result);
    
    }
 
map<pair<int,int>, int> rem;
 
int findAns(int s, int e) {
    if(s >= e) return 1;
    pair<int,int> pr = make_pair(s,e);
    if(rem.count(pr)) {
        return rem[pr];
    }
    int mni=query_min(a,1,mino,s,e,0,n-1);
   int mxi=query_max(a,1,maxo,s,e,0,n-1);
    long long diff = a[mxi] - a[mni];
    int p = min(mxi, mni);
    int q = max(mxi, mni);
    long long ans = modexp(diff, (p-s+1)*1LL*(e-q+1));
    ans = ans * findAns(s, q-1);
    ans = ans%MOD;
    ans = ans * findAns(p+1, e);
    ans = ans%MOD;
    ans = ans * modexp( findAns(p+1, q-1), MOD-2);
    ans = ans%MOD;
    
    rem[pr] = ans;
    return ans;
}
 
ul modexp(int a, long long int b) {
    long long ans = 1;
    long long temp = a;
    while(b) {
        if((b&1LL) != 0) {
            ans = ans*temp;
            if(ans > MOD) ans = ans%MOD;
        }
        temp = temp*temp;
        if(temp > MOD) temp = temp%MOD;
        b = b/2;
    }
    return ans;
}
   
  