 #include<stdio.h>
 #define mod 1000000007
 #define ll long long
  #define getcx getchar_unlocked
inline void inp( int &n )//fast input function
{
   n=0;
   int ch=getcx();
   while( ch < '0' || ch > '9' ) ch=getcx();
   while(  ch >= '0' && ch <= '9' )
           n = (n<<3)+(n<<1) + ch-'0', ch=getcx();
}
	int n;
 int m[1000000],a[1000000],ma[1000000];
 ll ans = 1;
 void initialize(int node, int b, int e)
  {
      int k;
      if (b == e)
          m[node] = b;
      else
       {
           k=2*node;
          initialize(k, b,(b + e) / 2);
          initialize(k+1,(b + e) / 2 + 1, e);
          if (a[m[k]] <= a[m[k + 1]])
              m[node] = m[k];
          else
              m[node] = m[k+1]; 
      }
}
  int query(int node, int b, int e,int i, int j)
  {
      int p1, p2;
      if (i > e || j < b)
          return 0;
      if (b >= i && e <= j)
          return m[node];
      p1 = query(2 * node, b, (b + e) / 2,i, j);
      p2 = query(2 * node + 1, (b + e) / 2 + 1, e, i, j);
      if (a[p1] <= a[p2]){
          return p1;
          }
          else
      return p2;
  }
  void initialize2(int node, int b, int e)
  {
      int k;
      if (b == e)
          ma[node] = b;
      else
       {
           k=2*node;
          initialize2(k, b,(b + e) / 2);
          initialize2(k+1,(b + e) / 2 + 1, e);
          if (a[ma[k]] <= a[ma[k + 1]])
              ma[node] = ma[k+1];
          else
              ma[node] = ma[k]; 
      }
  }
  ll po(int a2,ll b2)
{
        ll x2=1,y2=a2;
        while(b2 > 0)
        {
                if(b2%2 == 1)
                {
                        x2=(x2*y2)%mod;
                        if(x2>mod) x2%=mod;
                }
                y2 = (y2*y2)%mod;
                if(y2>mod) y2%=mod;
                b2 /= 2;
        }
        return x2;
}
int query2(int node, int b, int e,int i, int j)
  {
      int p1, p2;
      if (i > e || j < b)
          return n+1;
      if (b >= i && e <= j)
          return ma[node];
      p1 = query2(2 * node, b, (b + e) / 2,i, j);
      p2 = query2(2 * node + 1, (b + e) / 2 + 1, e, i, j);
      if (a[p2] >= a[p1]){
          return p2;
          }
          else
      return p1;
  }
  void calc2 ( int low, int mid, int high, int sta ) 
  {
  	int x1,x2,max1,max2,maxi,min1,min2,mini,c1,c2,z;
	  ll lo;
  	if ( sta == 0 )
  	{
  		mini = a[mid];
  		c1= x1 = mid + 1;
  		c2= x2 = mid - 1;
  		max1 = a[x1];
  		max2 = a[x2];
  		z = mid - 1;
  		while ( x1 <= high )
  		{
  			while ( x1<=high && a[x1]<=max1 ) x1++;
  			while ( z>= low && a[z] <= max1 ) z--;
  			lo = (mid - z );
			  lo*=(x1-c1);
  			ll ho = po ( max1 - mini,lo );
  			ans = (ho*ans)%mod;
  			if(x1<=high && a[x1]>max1) max1 = a[x1];
  			c1 = x1;
  		}
  		z = mid + 1;
  		while ( x2 >= low )
  		{
 			while ( x2>= low && a[x2] <= max2 ) x2--;
  			while ( z <= high && a[z] <= max2 ) z++;
  			lo = (z - mid);
			  lo*=(c2-x2);
  				ll ho = po ( max2 - mini,lo);
  				ans=(ans*ho)%mod;
  				if(x2>= low && a[x2] > max2) max2=a[x2];
  				c2=x2;
 		}		
  	}
  	if ( sta == 1 )
  	{
  		maxi = a[mid];
  		c1= x1 = mid + 1;
  		c2= x2 = mid - 1;
  		min1 = a[x1];
  		min2 = a[x2];
  		z = mid - 1;
  		while ( x1 <= high )
  		{
  			while ( x1<=high && a[x1]>=min1 ) x1++;
  			while ( z>= low && a[z] >= min1 ) z--;
  			lo = (mid - z );
			  lo*=(x1-c1);
  			ll ho = po ( maxi - min1,lo );
  			ans = (ans*ho)%mod;
  			if(x1<=high && a[x1]<min1)
  			min1 = a[x1];
  			c1 = x1;
  		}
  		z = mid + 1;
  		while ( x2 >= low )
  		{
 			while ( x2>= low && a[x2] >= min2 ) x2--;
  			while ( z <= high && a[z] >= min2 ) z++;
  					lo = (z - mid);
					  lo*=(c2-x2);
  			ll ho = po ( maxi - min2,lo);
  			ans = (ans*ho)%mod;
  			if(x2>= low && a[x2] < min2)
  			min2=a[x2];
  				c2=x2;
 		}		
  	}
  }
  void calc1(int L,int R )
{
	
	int flag= 0;
    int left=query(1,1,n,L,R), right=query2(1,1,n,L,R),range;
    if ( left > right ) {
    	flag = 1;
    	int k = left;
    	left = right;
    	right = k;
    }
    ll all_segments = (left - L + 1);
	 all_segments *=  (R - right + 1);
   	range = a[right] - a[left];
    if ( range < 0 )
    range *= -1;
    ll ho = po(range, all_segments);
    ans = (ans*ho)%mod;
   	if ( L < left- 1)
	calc1 ( L, left-1);
    if ( right+1 < R )
    calc1 ( right+1, R);
    
	if ( left +1< right - 1 )
    calc1 ( left+1, right - 1);
	calc2( L, left,right - 1 ,flag );
    
	calc2 ( left + 1,right, R,!flag );
}
int main()
{
	ans = 1;
  	inp(n);
  	int i;
  	for ( i = 1; i <=  n; i++ )
	{
  		inp(a[i]);	
  	}
  	a[0]=mod-1,a[n+1]=0;
  	initialize(1,1,n);
  	initialize2(1,1,n);
  	calc1(1, n);
  	printf ( "%lld\n", ans );
  	return 0;
}

 