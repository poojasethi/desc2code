#include <iostream>
#include <cstdio>
#include <cstring>
#define LL long long int
using namespace std;
int M;
char strC[32];
LL n,P,F;// ans = P + CF
/** P is sum of distances between every possible ordered pair of vertices **/

int Cint,Cdouble;
const int d = 9;// 9 digits after decimal point
const int d10 = 1000000000;//d10 = 10^9

/** Read Editorial for proofs of the various cases**/

void solve0()//No free fly-overs
{
    /** Basic Idea:-

        If C > 2, star graph is optimal
        If C < 2, clique is optimal
        If C = 2 - both are optimal - equal costs

    **/
    if(Cint>=2)//star
    {
        F = n-1;// n-1 fly-overs to 1 central vertex in star graph
        P = n-1 + (n-1)*(2*(n-2)+1);
        /**
            For the central vertex, distance from remaining
            n-1 vertices is 1 -> so n-1

            For the remaining n-1 vertices:-
            Distance to other vertices (except the central vertex) is 2 -> 2*(n-2)
            Distance to central vertex is 1
            Hence the term n-1 + (n-1)*(2*(n-2)+1)
        **/
    }
    else//clique
    {
        F = (n*(n-1))/2;// A flyover between every pair of vertices
        P = n*(n-1);
        /**
            For every vertex, distance to the other vertices -> 1
            No. of other vertices = n-1
            So P = n*(n-1)
        **/
    }
}

/** M = 1 case **/
void solve1()
{
    /** Same as M=0 case, but decrement value of F by one
        as one flyover is constructed for free **/
    solve0();
    F--;//1 flyover is already constructed
}

/** M = 2 case but with common vertex **/
void solve2_CommonVertex()
{
    /** Again Same as M=0 case, but decrement value of F
        by 2 as 2 flyovers are constructed for free **/
    solve0();
    F-=2;//2 flyovers are already constructed
}

/** M = 2 case with disjoint edges
    Involves some more cases **/

void solve2_DistinctVertices()// (1,2) and (3,4)
{
    /** Assume the free fly-overs are constructed
        between (1,2) and (3,4)
        Even though (u1,v1) (u2,v2) are given,
        it doesn't really matter

        Refer to editorial for derivation of the cases below

    **/

    if(Cint>=2*(n-2))//check C >= 2*(n-2)
    {
        F = n-3;//connect 1 with 4,...,n
        LL d1,d3,d4,rest;
        //di is sum of distances from vertex i to others

        d1 = (n-2) + 2;
        /** Distance of 1 from all vertices except 3 is 1 -> n-2 such vertices
            Distance of 1 from 3 is 2
            So d1 = n-2 + 2
        **/
        d4 = 1 + 1 + 2*(n-3);
        /** Distance of 4 from 1 -> 1 (as 1 is kind of central vertex)
            Distance of 4 from 3 -> 1 (due to free flyover)
            Distance of 4 from other n-3 vertices -> 2 (due to almost-star-shape)
            So d4 = 1 + 1 + 2*(n-3)
        **/
        d3 = 1 + 2 + (n-3)*3;
        /** Distance of 3 from 4 -> 1
            Distance of 3 from 1 -> 2 (via 4)
            Distance of 3 from other n-3 vertices -> 3 (through 4 and 1)
            So d3 = 1 + 2 + (n-3)*3
        **/
        rest = (n-3)*(1 + 3 + (n-3)*2);
        /** For vertices other than 1,3,4:-
            Distance to 1 -> 1
            Distance to 3 -> 3
            Distance to other n-3 vertices -> 2
            So rest = (n-3)*(1 + 3 + (n-3)*2)
        **/
        P = d1 + d3 + d4 + rest;
    }
    else if(Cint>=2)
    {
        F = n-2;//connect 1 with 3,4,...,n
        LL d1,d34,rest;
        //di is sum of distances from vertex i to others
        d1 = n-1;
        /** Distance of 1 from other n-1 vertices is 1 **/
        d34 = 2*(2*(n-3)+2);
        /** Vertices 3 and 4 are symmetrical.
            Distance of 3 :-
            From 1,4: 1
            From other n-3 vertices: 2

            So d34 = d3 + d4 = 2*(2*(n-3)+2)
        **/

        rest = (n-3)*(1+(n-2)*2);
        /** Remaining n-3 vertices are at a
            distance of 1 from 1 and 2 from rest n-2 vertices
        **/
        P = d1 + d34 + rest;
    }
    else
    {
        //Clique case, similar to solve0() clique case
        F = (n*(n-1))/2 - 2;// -2 because of 2 free flyovers
        P = n*(n-1);
    }
}

/** Till now, in the solve functions above,
    we find answer in the form of P + C*F
    We have computed P and F already...

    In the function below, we display it accurately
    using an elegant technique
**/
void calcAns()
{
    //d = 9
    //Write C as C1 + C2/10^d - already done in processC()
    LL C1;
    int C2;
    C1 = Cint;
    C2 = Cdouble;

    //Write F as F1*10^d + F2
    //Recall that F is long long
    LL F1;
    int F2;
    F1 = F/d10;
    F2 = F%d10;

    /** Observe that we can break down C*F as follows
        C*F = C1*F1*10^d + C2*F1 + C1*F2 + C2*F2/10^d

        Note that only the last term may be non-integer !

        2nd crucial (but very simple) observation:
        |C*F| <= 10^18 always.
        Why?

        When C<=2, (clique case) F <= n*(n-1)/2
        --> C*F <= n*(n-1) <= 10^18 since n<= 10^9

        When C>2, F <= n-1
        --> C*F <= 10^18 as C,N <= 10^9

        So, in the break up of C*F above,
        the integral part WILL fit into a long long
        comfortably

        Once we have broken up C*F, we can do all calculations
        in long long, see below
    **/

    LL D1;
    int D2;
    //Write last term of C*F i.e. C2*F2/10^d as D1 + D2/10^d
    //d10 is simply 10^9
    D1 = (C2*(LL)F2)/d10;
    D2 = (C2*(LL)F2)%d10;
    LL ansIntPart = P + C1*F1*d10 + C2*F1 + C1*F2 + D1;
    LL ansDoublePart = D2;
    printf("%lld.%09d\n",ansIntPart,ansDoublePart);
}

// function to find and store integer and fractional part of C separately
void processC()
{
    Cint=0;//integral part of C
    Cdouble=0;//fractional part of C
    //It is ensured that Cdouble always has 9 digits
    int len=strlen(strC),i,d;
    for(i=0;i<len;i++)
    {
        if(strC[i]=='.')
            break;
        Cint*=10;
        Cint+=strC[i]-'0';
    }
    i++;
    for(d=0;i<len;i++,d++)
    {
        Cdouble*=10;
        Cdouble+=strC[i]-'0';
    }
    for(;d<9;d++)
    {
        Cdouble*=10;//Ensuring that Cdouble always has 9 digits
    }
    //Effectively C = Cint + Cdouble/(10^9)
    //printf("Check %d.%d\n",Cint,Cdouble);
}

int main()
{
    int t;
    scanf("%d",&t);
    int u1,v1,u2,v2;
    while(t>0)
    {
        scanf("%lld",&n);
        scanf("%s",strC);
        scanf("%d",&M);
        /** C can have upto 10 digits before the decimal point
            and upto 9 digits after the decimal point
            So "double" data type shouldn't be used as it
            can handle only upto 14/15 digits
            Hence, I take input of C as a string strC
            and process it in processC() function below.
        **/
        processC();

        //Now different cases based on value of M
        /** Note: Answer is always in the form of
            P + C*F , where P is the penalty due to
            time and C*F is the cost of constructing
            the required fly-overs
            The various solve functions below simply
            find the values of P and F.
            The ACTUAL answer (to the required precision)
            is calculated later in the calcAns() function
        **/

        switch(M)
        {
            case 0: solve0();//no free flyovers
                    break;
            case 1: scanf("%d%d",&u1,&v1);
                    solve1();//one free fly-over
                    break;
            case 2: scanf("%d%d",&u1,&v1);
                    scanf("%d%d",&u2,&v2);
                    if(u1>v1)
                        swap(u1,v1);//ensuring u1<v1
                    if(u2>v2)
                        swap(u2,v2);//ensuring u2<v2
                    if(u1==u2||v1==v2||u1==v2||v1==u2)//Common vertex?
                    {
                        solve2_CommonVertex();//2 edges with a common vertex
                    }
                    else
                    {
                        solve2_DistinctVertices();//2 disjoint edges
                    }
                    break;
        }
        calcAns();//Displaying in Correct format
        t--;
    }

    return 0;
}
