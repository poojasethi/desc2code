#include<bits/stdc++.h>

using namespace std;

#define sd(x) scanf("%d",&x);
#define slld(x) scanf("%lld",&x);
#define LL long long
#define LD long double
#define PB push_back
#define MP make_pair
#define F first
#define S second
#define Fill(a, b) memset(a, b, sizeof(a))
#define INF 2000000009

typedef pair<int,int> PII;
typedef vector<int> VI;

#define N 100010

int node_idx = 1,mod = 1000000007;

struct node
{
    int l,r,lc,rc;
    LL val;
}st[N*200];

int init(int left, int right)
{
    int idx = node_idx++;
    st[idx].l = left;
    st[idx].r = right;
    st[idx].val = 1;
    //cout<<left<<" "<<right<<" "<<idx<<endl;
    if(left < right)
    {
        int mid = (left+right)/2;
        st[idx].lc = init(left, mid);
        st[idx].rc = init(mid+1, right);
    }
    return idx;
}

void cpy(int a, int b)
{
    st[a].l = st[b].l;
    st[a].r = st[b].r;
    st[a].val = st[b].val;
    st[a].lc = st[b].lc;
    st[a].rc = st[b].rc;
}

void mrge(int i)
{
    st[i].val = (st[st[i].lc].val * st[st[i].rc].val) % mod;
}

int update(int idx, int val, int i)
{
    if(st[i].l > idx || st[i].r < idx)return i;
    int index = node_idx++;
    //cout<<index<<" "<<i<<endl;
    cpy(index, i);
    if(st[index].l == st[index].r)
    {
        st[index].val = val;
    }
    else
    {
        st[index].lc = update(idx, val, st[index].lc);
        st[index].rc = update(idx, val, st[index].rc);
        mrge(index);
    }
    return index;
}

LL query(int left, int right, int i)
{
    if(st[i].l > right || st[i].r < left)return 1;
    if(left <= st[i].l && st[i].r <= right)
    {
        return st[i].val;
    }
    else
    {
        return (query(left, right, st[i].lc) * query(left, right, st[i].rc)) % mod;
    }
}

VI vec[N];
int root[N];

stack<int > qu[N];

void pre()
{
    int temp,num;
    for(int i=2;i<N;i++)
    {
        if(vec[i].size() == 0)
        {
            for(int j=i;j<N;j+=i)
            {
                temp = j;
                while(temp%i == 0)
                {
                    vec[j].PB(i);
                    temp/=i;
                }
            }
        }
    }
    init(1,N-1);
    //cout<<node_idx<<endl;
    root[1] = 1;
    int fst,last = 1;
    LL val;
    for(int i=2;i<N;i++)
    {
        for(int j=0;j<vec[i].size();j++)
        {
            if(!qu[vec[i][j]].empty())
            {
                fst = qu[vec[i][j]].top();
                val = query(fst,fst,last);
                //if(i==8)cout<<j<<" "<<vec[i][j]<<" "<<fst<<" "<<val<<endl;
                //if(val%vec[i][j] != 0)
                //{
                    qu[vec[i][j]].pop();
                    //continue;
                //}
                //if(i==8)cout<<j<<" "<<vec[i][j]<<" "<<fst<<" "<<val<<endl;
                last = update(fst, val/vec[i][j],last);
                //break;
            }
        }

        for(int j=0;j<vec[i].size();j++)
        {
            qu[vec[i][j]].push(i);
        }
        last = update(i,i,last);

        //if(i==100000)cout<<i<<" "<<last<<endl;
        //cout<<"Aman\n";
        root[i] = last;
    }
}

PII ar[N*10];

int get_lcm(int a, int b)
{
    int ans = 1;
    for(int i=a;i<=b;i++)
    {
        ans/=__gcd(ans,i);
        ans*=i;
    }
    return ans;
}


void solve()
{
    int t,a,b,c,d,m,n,k;
    LL ans = 0;
    sd(t);
    sd(n);sd(k);
    sd(a);sd(b);sd(m);
    for(int i=1;i<t;i++)
    {
        sd(ar[i].F);
    }
    for(int i=1;i<t;i++)
    {
        sd(ar[i].S);
    }
    //cout<<"aman\n";
    int flag = 0;
    for(int i=1;i<=t;i++)
    {
        if(n>10 && flag == 0)
        {
            flag = 1;
            pre();
        }
        if(n<=10)
        {
            ans = get_lcm(n-k+1,n);
        }
        else
        {
            ans = query(n-k+1,n,root[n]);
        }
        printf("%lld\n",ans);
        n = 1 + ((ans*a + ar[i].F)%m);
        k = 1 + ((ans*b + ar[i].S)%n);
        //cout<<n<<" nk "<<k<<endl;
    }
}

int main()
{
    //pre();
    //cout<<"done!!\n";
    //cout<<query(998,1000,root[1000])<<endl;
	int t=1;
	//9scanf("%d",&t);
	for(int i=1;i<=t;i++)
	{
		solve();
	}
}
