#include<bits/stdc++.h>
#include<iostream>
#define ll int
#define ll1 long long
#define maxn 100009
#define inf 1000000009
using namespace std;
vector<ll> primes;
ll mod=1000000007;
ll primepro[maxn+7],primeinv[maxn+9],c[1000009],d[1000009];
//inline int getchar_unlocked() { return getchar(); }
ll scan()
{
    register int n = 0, ch = getchar_unlocked();
    while (ch < '0' || ch > '9')
        ch = getchar_unlocked();
    while (ch >= '0' && ch <= '9') {
        n = (n << 3) + (n << 1) + ch - '0';
        ch = getchar_unlocked();
    }
    return n;
}
void markMultiples(bool arr[], int a, int n) {
	int num = 2 * a;
	while (num <= n) {
		arr[num - 1] = 1;
		num += a;
	}
}
void SieveOfEratosthenes(int n) {
	if (n >= 2) {
		bool arr[n];
		memset(arr, 0, sizeof(arr));
		for (int i = 1; i < n; ++i) {
			if (arr[i] == 0) {
				primes.push_back(i + 1);
				markMultiples(arr, i + 1, n);
			}
		}
	}
}
int powmod(int base, int exponent) {
	ll x = 1, y = base;
	while (exponent > 0) {
		if (exponent % 2 == 1) {
			x = (x * (ll1)y)%mod;
		}
		y = (y * (ll1)y)%mod;
		exponent/=2;
	}
	return x;
}
int modularMultiplicativeInverse(int a) {
	return powmod(a, mod - 2);
}
ll get(ll n,ll k)
{
	if(n==k)
	return k;
	ll tmp,high,low,i,j,l,ct,ct1,temp,ans,a,b;
	i=0;
	ans=1;
	ll lowchk;
	while(primes[i]*primes[i]<=k)
	{
		ll num=primes[i];
		temp=1;
		//lowchk=num;
		while(num<=k)
		{
			a=(n-1)/num;
			++a;
			b=k/num;
			if(a<=b)
			{
				temp=num;
				num=num*primes[i];
			}
			else
			break;
		}
		//cout<<temp<<endl;
		if(temp!=1)
		ans=(ans*(ll1)temp)%mod;
		++i;
	}
	//printf("%d\n",ans);
	 ll highchk;
	 highchk=inf;
	ll div=1;
	lowchk=sqrt(k);
	while(lowchk+1<highchk)
	{
		low=(n-1)/div;
		++low;
		high=k/div;
		if(high>=highchk)
		{
			high=highchk-1;
		}
		if(low<=lowchk)
		{
			low=lowchk+1;
			highchk=-199;
		}
		if(low<=high)
		{
			temp=((ll1)primepro[high]*(ll1)primeinv[low-1])%mod;
			ans=(ans*(ll1)temp)%mod;
		}
		highchk=min(highchk,low);
		div=max(div+1,k/highchk);
		//cout<<ans<<endl;
	}
	return ans;
}
int main()
{
	
	ll j,t,n,ans,prev,tmp,temp,a,b,m,k;
	/*for(i=1; i<16; i++)
	{
		printf("%d\n",get(i,15));
	}*/
	int NN = 100005;
	SieveOfEratosthenes(NN);
	ll lastprod = 2;
	primepro[0] = 1;
	primeinv[0] = primepro[1]=primeinv[1]=1;
	primepro[2] = 2;
	primeinv[2] = modularMultiplicativeInverse(2);
//	cout<<primeinv[2]<<endl;
	int x = 0;
	for (int i = 1; i < primes.size(); i++) {
		lastprod = (lastprod * (ll1)primes[i])%mod;
		if(primes[i] < 100005){
			primepro[primes[i]] = lastprod;
			if(lastprod == 1)
				primeinv[primes[i]] = 1;
			else
				primeinv[primes[i]] = modularMultiplicativeInverse(lastprod);
		}
	}
	for(int i =1; i <100005; i++){
		if(primepro[i] == 0){
			primepro[i] = primepro[i-1];
			primeinv[i] = primeinv[i-1];
		}
	}
	//cout<<primeinv[2]<<endl;
	t=scan();
	n=scan();
	k=scan();
	a=scan();
	b=scan();
	m=scan();
	ans=get(n-k+1,n);
	ll i;    // getting the answer
	for(i=0; i<t-1; i++)
	{
		c[i]=scan();
	}
	for(i=0; i<t-1; i++)
	{
		d[i]=scan();
	}
	ll thl;
	for(i=0; i<t-1; i++)
	{
		printf("%d\n",ans);
		thl=(a*(ll1)ans)%m;
		n=1+(thl+(ll1)c[i])%m;
		thl=(b*(ll1)ans)%n;
		k=1+(thl+(ll1)d[i])%n; 
		ans=get(n-k+1,n);
	}
		printf("%d\n",ans);
	return 0;
}