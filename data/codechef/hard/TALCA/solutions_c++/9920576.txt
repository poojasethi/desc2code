// tree is treated as 1 based 
// level is also 1 based 

#include<bits/stdc++.h>
using namespace std;
typedef long long int lli;
list<pair<int,int> >li[200010];
lli dp[200010][31];
int lev[200010];
int dist[200010];
int st[200010];
int en[200010];
int timee;
int dfs(int start,int par,int le,int di)
{
	st[start]=timee;
  lev[start]=le;
  list<pair<int,int > >:: iterator it;
  for(it=li[start].begin();it!=li[start].end();it++)
   {
     if(it->first!=par)
      {
      	timee++;
        dp[it->first][0]=start;
        lev[it->first]=le+1;
        dist[it->first]=di+it->second;
        dfs(it->first,start,le+1,di+it->second);
   }
   }
   
   en[start]=timee;
}

int binary_rais(int a,int b)// return lca of a,b
 {
  
   if(lev[a]<lev[b]) swap(a,b);
   
   int lg;
   
   /// maximum jump that can be alloweable to make both a and 
   // b at same level  will be the depth of the node a 
   for(lg=1;(1<<lg)<=lev[a];lg++);
   
   // 
   lg--;
   
   // this will make both at same level
   //  we can write any number as the power of 2 
   //  so by binary raise we can reach to any node 
     for(int i=lg;i>=0;i--)
      {
        if(lev[a]-(1<<i)>=lev[b])
         {
            a=dp[a][i];//   moving a upward
          }
      }
    
    //  now a and b are at same level 
     // cout<<" at same level "<<a<<" "<<b<<endl;
   if(a==b) return a;
   
   else
   {
    for(int i=lg;i>=0;i--)
    {
     if(dp[a][i]!=-1 && dp[a][i]!=dp[b][i])//  moving botha and b up 
      {
        a=dp[a][i];
        b=dp[b][i];
      }
    }
    return dp[a][0];
   }
 }


int main()
{

 int n;
 cin>>n;

  
 for(int i=0;i<n-1;i++)
 {
   int a,b,c;
    cin>>a>>b;
    
    li[a].push_back(make_pair(b,1));
    li[b].push_back(make_pair(a,1));
}

 memset(dp,-1,sizeof dp);
 dist[1]=0;
 dp[1][0]=0;
 dfs(1,-1,1,0);

    int max_h=30;
    for(int i=1;i<=max_h;i++)
     {
       for(int j=1;j<=n;j++)
        {
            if(dp[j][i-1]!=-1)
       dp[j][i]=dp[dp[j][i-1]][i-1];//
     }
  }
  
  int q;
  cin>>q;
  while(q--)
   {
     int a,b,c;
      cin>>a>>b>>c;
      int par= binary_rais(a,b);
        int  ab=dist[a]+dist[b]-2*dist[par];
          int  ac=dist[a]+dist[c]-2*dist[binary_rais(a,c)];
          int bc=dist[b]+dist[c]-2*dist[binary_rais(b,c)];
          // cout<<ab<<" "<<ac<<" "<<bc<<endl;
          if(ab==ac+bc)
           {
           	 cout<<c<<endl;
		   }
		   else if(lev[c]<=lev[par])
		    {
		    	  cout<<par<<endl;
			}
			else
			{
				
				
				  int stt=st[par];
				  int enn=en[par];
				  if(st[c]>=stt && en[c]<=enn)
				  {
				  	int lc1= binary_rais(a,c);
				  int lc2= binary_rais(b,c);
				  if(lev[lc1]>=lev[lc2])
				   {
				   	 cout<<lc1<<endl;
				   }
				   else cout<<lc2<<endl;
				  }
				  else cout<<par<<endl;
				  
			}
   }
 }
