#include<stdio.h>
#include<vector>
using namespace std;
vector< vector<int> >G(2000100);
#define tr(v,it) for(typeof(v.begin()) it=v.begin();it!=v.end();it++)
int visited[2000100];
int ET[4000100],L[4000100],FO[4000100];
int k=0;
struct node
{
	int val;
	int indx;
}seg_tree[8000100]={0};
int mini(int a,int b)
{
	return a<b?a:b;
}
void build(int array[],int low,int high,int pos)
{
	if(low==high)
	{
		seg_tree[pos].val=array[low];
		seg_tree[pos].indx=low;
		return;
	}
	int mid=(low+high)/2;
	build(array,low,mid,2*pos+1);
	build(array,mid+1,high,2*pos+2);
	if(seg_tree[2*pos+1].val<=seg_tree[2*pos+2].val)
	{
		seg_tree[pos].val=seg_tree[2*pos+1].val;
		seg_tree[pos].indx=seg_tree[2*pos+1].indx;
	}
	else
	{	
		seg_tree[pos].val=seg_tree[2*pos+2].val;
		seg_tree[pos].indx=seg_tree[2*pos+2].indx;
	}
}
struct node query(int qlow,int qhigh,int low,int high,int pos)
{
	//printf("hi\n");
	if(qlow>high||qhigh<low)
	{
	//	printf("1\n");
		return (struct node){999999999,-1};
	}
	
	if(low>=qlow&&high<=qhigh)
	{
	//	printf("%d %d\nreturn %d\n",low,high,pos);
		return seg_tree[pos];
	}
	
	int mid=(low+high)/2;
	struct node i1,i2;
	//printf("2\n");
	i1=query(qlow,qhigh,low,mid,2*pos+1);
	//printf("3\n");
	i2=query(qlow,qhigh,mid+1,high,2*pos+2);
	if(i1.val<=i2.val)
	{
		return (struct node){i1.val,i1.indx};
	}
	else
	return (struct node){i2.val,i2.indx};
}
void dfs(int ET[],int L[],int FO[],int level,int u,int n)
{
	ET[k]=u;
	FO[u]=k;
	L[k]=level;
	k++;
	visited[u]=1;
	tr(G[u],it)
	{
		if(visited[*it]==0)
		{
		visited[*it]=1;
		dfs(ET,L,FO,level+1,*it,n);
	    ET[k]=u;
	    L[k]=level;
	    k++;
		}
    }
}
struct node findodd(struct node indx,struct node indx1,struct node indx2)
{
	if(indx.val==indx1.val)
	{
		return indx2;
	}
	else if(indx.val==indx2.val)
	return indx1;
	else
	return indx;
}
int main()
{
	int tt=1;
	int t;
//	scanf("%d",&t);
//	while(t--)
//	{
		int xx=-1,ch,childs,i,j,n,u,v;
		scanf("%d",&n);
		for(i=1;i<=n;i++)
		G[i].clear();
		
		for(i=1;i<=n-1;i++)
		{
			visited[i]=0;
			
			scanf("%d %d",&u,&v);
			//for(j=1;j<=childs;j++)
			//{
			//	scanf("%d",&ch);
				G[u].push_back(v);
				G[v].push_back(u);
			//}
		}
		
		for(i=0;i<=2*n;i++)
		ET[i]=L[i]=FO[i]=-1;
		
		k=0;
		
		dfs(ET,L,FO,0,1,n);
		
	//	for(i=0;i<2*(n-1)+1;i++)
	//	printf("%d ",L[i]);
	//	printf("\n");
		
	//	for(i=0;i<2*(n-1)+1;i++)
	//	printf("%d ",ET[i]);
	//	printf("\n");
		build(L,0,2*(n-1),0);
	//	for(i=0;i<2*(n-1)+1;i++)
	//	printf("%d ",seg_tree[i]);
	//	printf("\n");
		int r,q;
		struct node indx,indx1,indx2,odd;
		scanf("%d",&q);
	//	printf("Case %d:\n",tt);
		for(i=1;i<=q;i++)
		{
			scanf("%d %d %d",&r,&u,&v);
			
			if(FO[r]<=FO[u])
			{
			//printf("cas 1\n");	
			indx=query(FO[r],FO[u],0,2*(n-1),0);
			}
			else
			indx=query(FO[u],FO[r],0,2*(n-1),0);
			
			
			if(FO[u]<=FO[v])
			indx1=query(FO[u],FO[v],0,2*(n-1),0);
			else
			indx1=query(FO[v],FO[u],0,2*(n-1),0);
			
			
			
			if(FO[r]<=FO[v])
			indx2=query(FO[r],FO[v],0,2*(n-1),0);
			else
			indx2=query(FO[v],FO[r],0,2*(n-1),0);
			//printf("ho;a\n");
			//printf("%d\n",ET[indx.indx]);
			//printf("%d\n",ET[indx1.indx]);
			//printf("%d\n",ET[indx2.indx]);
			odd=findodd(indx,indx1,indx2);
			printf("%d\n",ET[odd.indx]);
		}
	//	tt++;
	//}
}