#include <iostream>
#define INF 100000000
#define MIN(X, Y) (((X) < (Y)) ? (X) : (Y))
#define MAX(X, Y) (((X) > (Y)) ? (X) : (Y))
using namespace std;


    int inv[200][200];                  //Stores possible inversions
    int w[200000];                       //Stores the word
    int dp[200][200000];  
    
int main() {
    int t,k,m,n;
    int x,y;
    cin>>t;
    while(t--){
        cin>>m>>k>>n;
        for(int i=0;i<m;i++){           //INF=Inversion not possible
            for(int j=0;j<m;j++){
                inv[i][j]=INF;
            }
        }
        for(int i=0;i<k;i++){
            cin>>x>>y;
            inv[x-1][y-1]=inv[y-1][x-1]=1;
        }
        
        for(int i=0;i<m;i++){
            inv[i][i]=0;
        }
        
        for(int i=0;i<m;i++){               //Floyd-Warshall to find all possible composite inversions
            for(int j=0;j<m;j++){
                for(int p=0;p<m;p++){
                    if(inv[i][j]==1&&inv[i][p]==1&&j!=p)  inv[j][p]=1;
                }
            }
        }
        
        
        for(int i=0;i<n;i++){
            cin>>w[i];
        }
        
        /* 
        dp[i][j]=How many inversions are needed to make the word sorted and having digits <= i+1 
        considering the first j+1 digits of the word.
        */
        
                      
        dp[0][0]=inv[0][w[0]-1];         //Filling the first element of the table
        
        for(int i=1;i<n;i++){           //filling the first row
            dp[0][i]=(dp[0][i-1]+inv[0][w[i]-1]>INF)?INF:dp[0][i-1]+inv[0][w[i]-1];
        }
        
        for(int i=1;i<m;i++){           //filling the first column
            dp[i][0]=MIN(inv[i][w[0]-1],dp[i-1][0]);
        }
        
        for(int i=1;i<m;i++){           //filling the rest of the table
            for(int j=1;j<n;j++){
                dp[i][j]=MIN((dp[i][j-1]+inv[i][w[j]-1])>INF?INF:dp[i][j-1]+inv[i][w[j]-1],dp[i-1][j]);
            }
        }
        /*
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                cout<<dp[i][j]<<" ";
            }
            cout<<endl;
        }
        cout<<endl; 
        */
        int ans=dp[m-1][n-1];
        if(ans==INF) ans=-1;
        
        cout<<ans<<endl;
    }
	return 0;
}
