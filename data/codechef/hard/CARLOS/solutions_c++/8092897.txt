#include <bits/stdc++.h>

using namespace std;

#define INF 100000000

int test,n,m,k,path[205][205],dp[200005][205],pre[200005][205],word[200005];

int main() {
	// your code goes here
	
	scanf("%d",&test);
	
	while(test--)
	 {
	     scanf("%d %d %d",&m,&k,&n);
	     
	     for(int i=1;i<=m;i++)
	      {
	          for(int j=1;j<=m;j++)
	           path[i][j] = INF;
	       
	          path[i][i] = 0;    
	      }
	      
	      for(int i=1;i<=k;i++)
	       {
	           int u,v;
	           scanf("%d %d",&u,&v);
	           path[u][v] = 1;
	           path[v][u] = 1;
	       }
	       
	       // floyd warshall for calculating the transitive closure
	       
	       for(int r=1;r<=m;r++)
	        for(int i=1;i<=m;i++)
	         for(int j=1;j<=m;j++)
	         {
	           path[i][j] = min(path[i][j],path[i][r] +  path[r][j]);
	         }
	        
	        for(int i=1;i<=m;i++)
	       {
	           for(int j=1;j<=m;j++)
	         {
	           if(path[i][j] == INF)
	            path[i][j] = 0;     // path[i][j] = 1 means that transformation from letter i to j is possible
	           else
	            path[i][j] = 1;
	            
	          //  cout<<path[i][j]<<" ";
	         }
	       //  cout<<"\n";
	       }
	         
	       for(int i=1;i<=n;i++)
	        scanf("%d",&word[i]);
	        
	       for(int i=1,j=1;j<=m;j++)
	        {
                if(word[1] == j)
                 dp[1][j] = 0;
	            
	            else if(path[word[1]][j])
	             dp[1][j] = 1;
	             
	            else
	             dp[1][j] = INF;
	             
	            if(j == 1)
	             pre[i][j] = dp[i][j];
	            else
	             pre[i][j] = min(dp[i][j] , pre[i][j-1]);
	             
	            // cout<<dp[i][j]<<" ";
	        }
	       // cout<<"\n";
	        
	       for(int i=2;i<=n;i++)
	        {
	            for(int j=1;j<=m;j++)
	             {
	                 
	                 if(word[i] == j)
	                  dp[i][j] = pre[i-1][j];
	                 
	                 else if(path[word[i]][j])
	                  dp[i][j] = 1 + pre[i-1][j];
	             
	                 else
	                  dp[i][j] = INF; 
	                 
	                 if(j == 1)
	                  pre[i][j] = dp[i][j];
	                 else
	                  pre[i][j] = min(dp[i][j] , pre[i][j-1]);
	                 
	                 //cout<<dp[i][j]<<" ";
	                  
	             }
	            // cout<<"\n";
	        }
	        
	        if(pre[n][m] >= INF)
	         printf("-1\n");
	        else
	         printf("%d\n",pre[n][m]);
	        
	 }
	
	return 0;
}
