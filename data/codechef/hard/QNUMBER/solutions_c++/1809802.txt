#include <cstdio>
#include <fstream>
#include <cassert>
#include <iostream>
#define lim 1000000
#define MAXN 50
using namespace std;
typedef long long ll;
ll p[MAXN+1];
int q[MAXN+1],q2[MAXN+1],sz;
int dpl[MAXN+1],dpr[MAXN+1];

//factorization of N is as follows:
//N=p[0]^q[0]*p[1]^q[1]*.....*p[sz-1]^q[sz-1]
//for each K in the query, we will calculate an array q2 such that
//K=p[0]^q2[0]*p[1]^q2[1]*.....*p[sz-1]^q2[sz-1]*X and gcd(X,N)=1.


//for the third type of query,assume that for some divisor Y of N its factorization is
//Y=p[0]^q1[0]*p[1]^q1[1]*....*p[sz-1]^q1[sz-1] 
//As we want such Y's which K doesn't divide them, there is such indices i such that
//0<=i<sz and q1[i]<=q[i] and q1[i]<q2[i].
//Let's call the minimum of these indices as M.
//Iterate M over [0;sz) and calculate such number's that in their prime factorization
//minimum index having above property is M.
//Find these numbers and add them up. This will give us the result.:)


int min(int a,int b){
    return (a<b)?a:b;
}

int main()
{
    ll N,K,tn;
    int T,Q;

    scanf("%lld%d",&N,&Q);

    ll LM=lim; LM*=lim;

    tn=N;

	sz=0;

    for(int i=2;i<=lim;i++)
        if(N%i==0){
            p[sz]=i;
            while(N%i==0){N/=i;q[sz]++;}
            sz++;
        }

    if(N>1){p[sz]=N; q[sz]=1; sz++;}
    N=tn;


    while(Q--){
        scanf("%d%lld",&T,&K);

        int ans=1;

		for(int i=0;i<sz;i++)q2[i]=0;

        if(T==1){
            for(int i=0;i<sz;i++){
                while(K%p[i]==0){K/=p[i];q2[i]++;}
                ans*=min(q[i],q2[i])+1;
            }
        }
        else if(T==2){
            if(N%K)ans=0;
            else{
                for(int i=0;i<sz;i++){
                    while(K%p[i]==0){K/=p[i];q2[i]++;}
                    ans*=(q[i]-q2[i]+1);
                }
            }
        }
        else{
            if(N%K){for(int i=0;i<sz;i++)ans*=(q[i]+1);}
            else{
                for(int i=0;i<sz;i++){
                    while(K%p[i]==0){K/=p[i];q2[i]++;}
                    dpl[i]=(q[i]-q2[i]+1);
                    if(i)dpl[i]*=dpl[i-1];
                }
                dpr[sz]=1; ans=0;
                for(int i=sz-1;i>=0;i--){
                    dpr[i]=(q[i]+1)*dpr[i+1];
                    ans+=(dpr[i+1]*q2[i]*(i?dpl[i-1]:1));
                }
            }
        }

        printf("%d\n",ans);

    }

    return 0;
}