/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* File Name : cchef_june13_collect.cpp
* Creation Date : 07-07-2013
* Last Modified : Sunday 07 July 2013 04:48:20 PM IST
* Created By :  Vishal Gupta IIIT-H
_._._._._._._._._._._._._._._._._._._._._.*/
                                   
#include <iostream>
#include <cmath>
#include <algorithm>
#include <cstdio>
#include <stack>
#include <vector>
#include <cstring>
#include <set>
#include <map>
#include <bitset>
#include <string>
#include <queue>
using namespace std;

#define sz(a) int((a).size())
#define all(c) c.begin(),c.end() //all elements of a container
#define rall(c) c.rbegin(),c.rend() 
#define tr(container,it) for(typeof(container.begin()) it = container.begin(); it != container.end(); it++) //traversing a container..works for any type of container
#define present(container, element) (container.find(element) != container.end())    //used for set...return 1 if el is ps 0 otherwise
#define cpresent(container, element) (find(all(container),element) != container.end())  //same as present...but is for vectors
#define INF		INT_MAX
#define FOR(i,a,b) 	for(int i= (int )a ; i < (int )b ; ++i)
#define rep(i,n) 	FOR(i,0,n)
#define si(n) scanf("%d",&n)
#define pi(n) printf("%d ",n)
#define pil(n) printf("%d\n",n)
#define piL(n) printf("%lld ",n)
#define piLL(n) printf("%lld\n",n)
#define sl(n) scanf("%lld",&n)
#define sd(n) scanf("%lf",&n)
#define ss(n) scanf("%s",n)
#define PB push_back
#define MP make_pair
#define scan(v,n)	vector<int> v;rep(i,n){ int j;si(j);v.PB(j);}
#define mod 3046201
#define pn printf("\n")
typedef long long int LL;
typedef vector <int> VI;
typedef pair < int ,int > PII;
typedef vector < PII > VPII;
template<class T>inline T gcd(T a,T b){return b?gcd(b,a%b):a;}
int tree[1000000];
int index1[100100];
int a[100100];
int fact[3100000];
int n;
void precompute( int N)
{
	fact[0]=1;
	int i;
	LL temp=1;
	for(i=1; i<3100000; i++)
	{
		temp=((LL)i*(LL)fact[i-1])%mod;
		fact[i]=(int)temp;
	}
}
int power(int a, int b)
{
	if(b==0) return 1;
	LL x=1,y=a;
	while(b>0)
	{
		if(b&1) x=(x*y)%mod;
		y=(y*y)%mod;
		b/=2;
	}
	return (int) x;
}
void initialize(int node, int b, int e)
{
	if(b==e){
		tree[node]=a[b];
		index1[b]=node;
		return ;
	}
	initialize(2*node,b,(b+e)/2);
	initialize(2*node+1,(b+e)/2+1,e);
	tree[node]=tree[2*node]+tree[2*node+1];  
	return;
}
void update(int val , int pos)
{
	int t=index1[pos];
	int diff=val-tree[t]; 
	while(t>0)
	{
		tree[t]+=diff;
	        t=t/2;
	}
	return;
}
int query(int node,int b, int e, int i, int j)
{
   if(b>j || e<i) return -1;
   
   if(b>=i && e<=j) return tree[node];
   int p1,p2;
   p1=query(2*node,b,(b+e)/2,i,j);
   p2=query(2*node+1,(b+e)/2+1,e,i,j);
   
   if(p1==-1) return p2;
   if(p2==-1) return p1;
   return p1+p2;

}
int solve(int A,int B)
{       LL first,second,ans;
        int sum,count,num1,num2; 
//        sum=10;
		sum = query(1,1,n,A,B);
           
//	printf(" sum %d \n",sum);
	count=B-A+1;
	num1=sum/count;
	num2=sum%count;
  //      pil(num1);
		first=((LL)fact[num2]*(LL)fact[count-num2])%mod;
	first=power((int)first,mod-2);
	first=(first*fact[count])%mod;
  //      printf("first %lld\n",first);
	second=((LL)(power(fact[num1],count-num2))*((LL)power(fact[num1+1],num2)))%mod;
	second=power(second,mod-2);
    //   printf("after denominator %lld\n",second); 
      // pil(fact[sum]);	
       second=(fact[sum]*second)%mod;
//	piLL( second);
	second=(second*first)%mod;
	return (int) second;
}
int main()
{
        int i,j,q,A,B; char s[20];
	si(n);
        rep(i,n) si(a[i+1]);
        precompute(n);
	initialize(1,1,n);
//	rep(i,32) pi(tree[i]); pn;
//	rep(i,n+1) pi(index1[i]); pn;
	si(q);
	rep(i,q)
	{
	  ss(s); si(A); si(B);
	  if(s[0]=='c') update(B,A);
	  else 
	  pil(solve(A,B));
	
	}
	return 0;
}
