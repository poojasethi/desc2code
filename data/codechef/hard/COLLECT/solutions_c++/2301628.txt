#include <iostream>
#include <cassert>
#include <algorithm>
#include <cstdio>
#include <vector>
using namespace std;
#define mod 3046201
#define maxn 111111


vector<int> tree;
vector<int> initialArray;

//Increase the thing at i by delta
void increase(int i, int delta)
{
    for (; i < (int)tree.size(); i |= i + 1)
    {
        tree[i] += delta;
    }
}

//Change the thing at i to value
void change(int i, int value){
    increase(i, value - initialArray[i]);
    initialArray[i] = value;
}

void createTree(){
    tree.resize(initialArray.size());
    for(uint i = 0 ; i<tree.size(); i++)
    {
        increase(i, initialArray[i]);
    }
}

int sum(int ind)
{
    int sum = 0;
    while (ind>=0)
    {
        sum += tree[ind];
        ind &= ind + 1;
        ind--;
    }
    return sum;
}

int getsum(int left, int right)
{
    return sum(right) - sum(left-1);
}

long long ret,one,two,fact[mod],divs,mods;
int n,i,j,m,x,y,total,len,b;
char ch;
long long pow(long long a,int b){ // fast exponentation
    if(!b)return 1;else
    if(b==1)return a;else{
        long long tmp=pow(a,b/2);
        tmp=(tmp*tmp)%mod;
        if(b&1)return(tmp*a)%mod;else return tmp;
    }
}
long long divide(long long a,long long b){return (a*pow(b,mod-2))%mod;} // division modulo prime number
int main (int argc, char * const argv[]) {
    scanf("%d",&n); // n is the number of the bushes
    for(i=1;i<=n;i++){
        scanf("%d",&b); // the amount of berries on the i-th bush
        initialArray.push_back(b);
    }
    createTree();
    fact[0]=1;
    for(i=1;i<mod;i++)fact[i]=(fact[i-1]*1LL*i)%mod; // precalculating factorials modulo 3046201
    scanf("%d",&m); // m is the number of queries
    for(i=1;i<=m;i++){
        ch=getchar();
        while(ch!='q'&&ch!='c')ch=getchar();
        for(j=0;j<4;j++)getchar();
        if(ch=='c')getchar();
        scanf("%d %d",&x,&y);
        if(ch=='c'){ // changing
            assert(1<=x&&x<=n);
            change(x-1,y);
        }else{ // query
            assert(1<=x&&x<=y&&y<=n);
            total=getsum(x-1,y-1);
            len=y-x+1;
            one=divide(fact[total],(pow(total/len+1,total%len)*pow(fact[total/len],len))%mod);
            two=divide(fact[len],(fact[total%len]*fact[len-total%len])%mod);
            ret=(divide(fact[total],(pow(total/len+1,total%len)*pow(fact[total/len],len))%mod)*divide(fact[len],(fact[total%len]*fact[len-total%len])%mod))%mod;
            printf("%d\n",(int)ret);
        }
    }
    return 0;
}
