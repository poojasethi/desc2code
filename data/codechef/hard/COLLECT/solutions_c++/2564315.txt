#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <iterator>

#include <cstring>
#include <bitset>
#include <cstring>
using namespace std;
#define mod 3046201
typedef long long LL;

int tree[300000];
vector<int> v;
int fact[3000001];
void init()
{
    fact[0]=1;
    fact[1]=1;
    for (int i=2;i<=3000000;++i)
        fact[i]=LL(fact[i-1])*i%mod;
}
void make_tree(int node, int a , int b)
{
    if (a==b) {tree[node]=v[a];return;}
    int mid=(a+b)/2;
    make_tree(2*node,a,mid);
    make_tree(2*node+1,mid+1,b);
    tree[node]=(tree[2*node] + tree[2*node+1])%mod;

}
int query (int node, int a, int b, int x, int y)
{
    if (x>b || y<a ) return 0;
    if (a>=x && b<=y) return tree[node];
    int mid=(a+b)/2;
    return ( query(2*node,a,mid,x,y) + query(2*node+1,mid+1,b,x,y))%mod;
}

void update_node (int node, int a, int b, int pos, int val)
{
    //cout<<"node up="<<a<<" "<<b<<endl;
    if (pos>b || pos<a ) return;
    if (a==b) {tree[node]=val;return;}
    //if (a==b && a==pos) {tree[node]=(tree[node]+val)%mod;return;}
    int mid=(a+b)/2;
    if (pos<=mid)
    update_node(2*node,a,mid,pos,val);
    else update_node(2*node+1,mid+1,b,pos,val);
    tree[node]=tree[2*node] + tree[2*node+1];
}

int modpow(int a, int n, int num=mod)
{
    if (!n) return 1;
    int p=1;
    while(n)
    {
        if (n%2) p=LL(p)*a%num;
        if (n/=2) a=LL(a)*a%num;
    }
    return p;
}

int main()
{
    std::ios_base::sync_with_stdio(false);
    int t,n,q,a,b;
    int berry,x,r,k,ans,denom;
    string str;
    init();
    cin>>n;
    v.resize(n+1);
    for (int i=1;i<=n;++i)
        cin>>v[i];
    make_tree(1,1,n);
    cin>>q;
    while(q--){
    cin>>str>>a>>b;
    if (str[0]=='q')
    {
        if (a==b) cout<<"1"<<'\n';
        else{
        berry=query(1,1,n,a,b);//cout<<"berry: "<<berry<<endl;
        k=b-a+1;//cout<<"k="<<k<<endl;
        x=berry/k;
        r=berry%k;
        ans=LL(fact[berry])*fact[k]%mod;//cout<<"ans="<<ans<<endl;
        denom=modpow(fact[x+1],r);
        denom=LL(denom)*modpow(fact[x],k-r)%mod;
        denom=LL(denom)*fact[r]%mod;
        denom=LL(denom)*fact[k-r]%mod;
        ans=LL(ans)*modpow(denom,mod-2)%mod;//cout<<"ans="<<ans<<endl;
        cout<<ans<<'\n';}
    }
    else
    {
        update_node(1,1,n,a,b);
    }
    }
    return 0;
}
