#include<iostream>
using namespace std ;
int a[122222] , tree[122222 * 4];
long long  mod = 3046201 ;
long long ans ;
long long fact[3444144] ;
long long pow ( long long a , long long b  )
{
    if ( b == 0 )
        return 1 ;
    if ( b == 1 )
        return ( a % mod );
    else
        {
        long long y = pow ( a , ( b / 2 ) ) ;
        long long y2 = ( ( y % mod ) * ( y % mod ) ) % mod ;
        if ( ( b % 2 ) != 0 )
        {
          return ( ( ( y2 % mod ) * ( a  % mod ) ) % mod ) ;
        }
        else
            return ( y2 % mod );
        }
}

void build ( int id , int i , int j )
{
    if ( i == j )
       {
        tree[id] = a[i] ;
        return ;
       }
    int mid = ( i + j ) / 2 ;
    build( 2*id , i , mid   );
    build( ( (2*id) + 1 ) , (mid  + 1 ) , j );
    tree[id] = tree[2*id] + tree[(2*id)+ 1] ;
    return  ;
}

void update ( int id , int i , int j , int u , int k )
{
    if ( ( u < i) || ( j < u ) || ( i  > j ) )
    return ;

    if ( ( u == i ) && ( u == j ) )
    {
     tree[id] = ( long long )k ;
     return ;
    }

   if ( ( i <= u ) && ( u <= j ) )
   {
       int mid = ( i + j ) / 2 ;
    update( 2*id , i , mid  , u , k   );
    update(( 2*id + 1 ) , ( mid  + 1 ) , j , u , k  );
    tree[id] = tree[2*id] + tree[(2*id)+ 1] ;
    return ;
   }

}

long long  query ( int id , int i , int j , int l ,  int r )
{
    if ( ( r < i) || (  l >  j ) )
    return 0  ;
    if ( ( i >= l ) && ( j <= r ) )
        return tree[id] ;


       int mid = ( i + j ) / 2 ;
    long long  h1 =  query( (2*id) , i ,  mid  , l , r   );
    long long  h2 =  query(( 2*id + 1 ) , ( mid  + 1 ) , j , l , r  ) ;
    return ( h1 + h2 ) ;


}

/*long long choose ( int n , int r )
{
     long long ans = fact[n] % mod ;
     long long ty =  ( ( fact[r] % mod ) * ( fact[n-r] % mod ) ) % mod ;
     ty = pow ( ty , ( mod - 2 ) ) ;
     long long jk = ( ( ans % mod ) * ( ty % mod) ) % mod ;
     return jk ;

}
*/

int main()
{

    int n , l , r , q , mi , mx , nom ;
    string s ;

    fact[0] = 1 ;
    fact[1] = 1 ;
    a[0] = 0 ;
    for ( int i = 2 ; i <= mod   ; i++)
    {
        fact[i] = ( ( ( long long )( i ) % mod )* ( fact[i-1] % mod ) ) % mod  ;
    }
        cin >> n ;
    for ( int i = 0 ; i < n ; i++)
        cin >> a[i+1] ;
       /* for ( int i = 0 ; i < n ; i++)
        cout <<  a[i] << " " ;
        */
     build ( 1 , 1 , n   );
     cin >> q ;
     for ( int i = 0 ; i < q ; i++)
     {
        cin >> s ;
        cin >> l >> r ;
        if ( s[0] == 'c')
        {

            update ( 1 , 1 , n  , l , r  );
            a[l] = r ;
        }
        else
        {
            int sum =  query ( 1 , 1 , n  , l , r  );
            int people = r - l + 1 ;



                    mx = ( sum / people ) + 1 ;
                    nom = sum % people ;
                    mi = mx - 1 ;
               //     momi = people - nom ;

              //ans = choose ( people , nom ) ;
              long long a1 = fact[people] % mod ;
              long long a2 = ( ( fact[nom] % mod ) * ( fact[people - nom ] % mod ) ) % mod ;
              long long a3 = pow ( fact[mx] , nom );
              long long a4 = pow ( fact[mi] ,( people - nom ) ) ;
              long long a5 = ( ( a3 % mod ) * ( a4 % mod ) ) % mod ;
              long long a6 =  ( ( a5 % mod ) * ( a2 % mod ) ) % mod ;
              long long a7  = pow ( a6 , mod - 2 );
              long long a8 =   ( ( a1 % mod ) * ( a7 % mod ) ) % mod ;
              //long long b1 = pow ( fact[mx] , nom ) ;
              //long long b2 = pow ( fact[mi] , people - nom ) ;
              //long long b3 = ( ( b1 % mod ) * ( b2 % mod ) ) % mod ;
              //ans = ( ( ( ( ans % mod ) * ( fact[sum] % mod ) ) % mod ) * ( (  pow ( b3 , mod - 2 ) % mod )   % mod  )  % mod ) ;
                long long a9  = ( ( a8 % mod ) * ( fact[sum] % mod ) ) % mod ;
              cout << a9 << endl ;
        }
     }

return 0 ;

}
