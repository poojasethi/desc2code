#include<stdio.h>
#include<algorithm>
#include<string.h>
using namespace std;
#define ll long long

typedef struct nodex
{
    int sum;
    int flag;
}array;

array tree[300002];
int arr[100002],arr2[100002];
int input()
{
int flag=0,t=0;
char c;
c=getchar_unlocked();
while(c<'0' || c>'9'){
if(c=='-'){
flag=1;
c=getchar_unlocked();
}
else
c=getchar_unlocked();
}
while(c>='0' && c<='9')
{
t=t*10+c-'0';
c=getchar_unlocked();
}
if(flag)
t*=-1;
return(t);
}

void build(int n, int b, int e)
{

    if (b==e)
      { tree[n].sum=arr[b];
        tree[n].flag=1;
        arr2[b]=n;
        return ;
      }

 build ( n*2 , b , (b+e)/2 ); //go to children...child nodes of node n are 2n and 2n+1.

build (n*2+1, (b+e)/2 + 1 , e );

 //now both child nodes 2n and 2n+1 are built (ie they have done their responsibility of storing the correct information)
 tree[n].sum=tree[n*2].sum+tree[n*2+1].sum;
 tree[n].flag=1;
}

  void update(int pos, int val)
{
    pos=arr2[pos];
    tree[pos].sum=val;
    pos>>=1;
    while(pos>0)
    {
            tree[pos].sum=tree[pos*2].sum+tree[pos*2+1].sum;
            pos>>=1;
    }

    }

array query(int n, int b, int e, int i, int j)
{
   array node,node2,node3;

 if (b>=i && e<=j)
 {
     return tree[n];
 }
 int mid = (e+b)/2;
 if(j<=mid){
                return query(2*n, b, mid, i, j);
        }
        else if(i>mid){
                return query(2*n+1, mid+1, e, i, j);
        }

 node=query(n*2,b,mid,i,mid);
 node2=query(n*2+1,mid+1,e,mid+1,j);

 node3.sum=node.sum+node2.sum;

 return node3;
 }

  long long f[3000001];

void fact(long long MOD)
{
 f[0]=1;  f[1]=1;
 for (long long i=2; i<=3000000;i++)

        f[i]= (f[i-1]*i) % MOD;
 }


/* This function calculates (a^b)%MOD */

long long pow(long long a, long long b, long long MOD)

{

    long long x=1,y=a;

    while(b > 0)

    {

        if(b%2 == 1)

        {

            x=(x*y);

            if(x>MOD) x%=MOD;

        }

        y = (y*y);

        if(y>MOD) y%=MOD;

        b /= 2;

    }

    return x;

}



/*  Modular Multiplicative Inverse

    Using Euler's Theorem

    a^(phi(m)) = 1 (mod m)

    a^(-1) = a^(m-2) (mod m) */

long long IEuler(long long i,long long MOD)

{

    return pow(i,MOD-2,MOD);

}


int main()
{
   int n,m,i,a,b,total,group;
   long long MOD=3046201,ans;
   char s[10];
   n=input();
   for(i=0;i<n;i++)
   {
       arr[i]=input();
   }
   build(1,0,n-1);
   fact(MOD);
   m=input();
   while(m--)
   {
       scanf("%s",s);
       a=input(); b=input();
       if(!strcmp(s,"change"))
       {
           update(a-1,b);
           continue;
       }
       total=query(1,0,n-1,a-1,b-1).sum;
       group=b-a+1;
       a=total/group;
       b=total%group;

       //b of a+1 and group-b of a
       ans=f[total];
       ans*=IEuler(pow(f[a+1],b,MOD),MOD);
       ans%=MOD;
       ans=(ans*IEuler(pow(f[a],group-b,MOD),MOD))%MOD;
       ans=(ans*f[group])%MOD;
       ans=(((ans*IEuler(f[b],MOD))%MOD)*IEuler(f[group-b],MOD))%MOD;
       printf("%lld\n",ans);

   }
   return 0;
}