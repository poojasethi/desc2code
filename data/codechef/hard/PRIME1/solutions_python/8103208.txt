import math


def sieve(n):
    primes = [True] * n
    i = 2
    if n >= 1:
        primes[0] = False
    if n >= 2:
        primes[1] = False
    while i*i <= n:
        if primes[i]:
            j = i*i
            while j < n:
                primes[j] = False
                j += i
        i += 1
    return primes
 
# i_0 <= n <= i_n
def segmented_sieve(i_0, i_n, primes):

    
    another_sieve = [True] * (i_n-i_0+1)
    for j, x in enumerate(primes):
            if primes[j]:
                # find first multiplication in given range of a prime number 
                min_in_another = (i_0+j-1)/(j) * j
                
                # adjust the index of given number in the list
                min_in_another_index = min_in_another - i_0
                while min_in_another_index < len(another_sieve):
                    # don't mark primes as themself
                    if (min_in_another_index + i_0) != j:
                        another_sieve[min_in_another_index] = False
                    min_in_another_index += j
    return another_sieve
        
    

n = int(raw_input())
for i in xrange(n):
    a, b = raw_input().split()
    a = int(a)
    b = int(b)
    sqrt_max = int(math.ceil(math.sqrt(1000000000)))
    primes = sieve(sqrt_max)
    if a == 1 and b == 1:
        print ""
        continue
    if a == 1 and b > 1:
        a += 1
    another_sieve = segmented_sieve(a, b, primes)
    for j, x in enumerate(another_sieve):
        if x:
            print (j+a)
    print ""