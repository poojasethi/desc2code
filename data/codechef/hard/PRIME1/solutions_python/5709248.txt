import  math, sys

already = 31623
primes = range(already)
def find_primes():
   for p in primes[2:]:
        top = len(primes) - 1
        if p:
            bottom = p * p 
            primes[p*p::p] = [0] * ( 1+ (top - bottom )  // p ) 



find_primes()

primes = filter(None, primes)
primes = primes[1:]

def get_nearest_prime_index(l1 , l2, n ) :
   mid = int (( l1 + l2 ) / 2 ); 
   if ( l2 - l1 <= 1) :
        return l1
   if ( primes[mid] > n ) : 
        return get_nearest_prime_index(l1, mid, n )
   else: 
       return get_nearest_prime_index(mid, l2, n ) 


def get_first_multiple_in_range(x, n, m ):
    if n <= x and x <= m : 
        return x
    return int ( x * math.ceil( float(n) / float ( x) ) )
    
def primes_in_range(n , m ) : 
    pr1 = []
    if m < already:
        res = filter( lambda x : n<= x and x<= m , primes) 
        return res
    elif n < already : 
	res = filter( lambda x : n<= x and x<= already , primes ) 
        pr1 = res
    	n = already 

    pr = range(n , m + 1 ) 
    lim = 1 + get_nearest_prime_index(0 , len(primes), int ( math.sqrt(m))) 
    #print "Limit is at index {0} with val {1}".format(lim, primes[lim]);
    for p in primes[:lim]:
        #print "prime" , p
        fm = get_first_multiple_in_range(p , n , m ) 
        idx = fm - n 
	#print "First multiple {0} at index {1}".format(fm, idx)
	#print pr[:50]
        pr[idx::p] = [0] * len ( pr[idx::p])
    pr2 = filter( None, pr)
    return pr1 + pr2


def main():
    f = sys.stdin
    cases  = int ( f.readline())
    for i in range(cases) : 
        nos = f.readline().split()
        nos = map(int, nos)
        pr = primes_in_range(nos[0], nos[1])
        for p in pr: 
            print p
        if cases  != i : 
            print ""
            

if __name__ == "__main__":
    main()
