#include <stdio.h>
//#include <conio.h>
//#include <iostream>
//using namespace std;
	
//#define sh(X) cout << #X": " << X << endl;
	
typedef struct
{
	int Aw, Bw, Amax, Bmax, diag_stepA, diag_stepB;
} cell;

cell cells[62750];
int start_lines[500], crit_ends[250];

int main()
{
	
	int cases, N, line, col, test, half, lines_cnt, crit_ends_cnt, M;
	int offsetA, offsetB, tempMin, tempMaxA, tempMaxB, tempCalc, aboveCell, cellWeightA, cellWeightB, colCnt, diagCnt;
	bool diagFlagA, diagFlagB;
	int diagSelections, selectionCase1, selectionCase2, result1, result2, finalResult;
	cell * ptr;
	
	//capturing and storing input
	
	
	scanf("%d",&cases);
	
	for ( test = 0 ; test < cases ; test++ )
	{
		scanf("%d",&N);
		if (N == 2)
		{
			int a, b, c;
			scanf("%d %d %d", &a, &b, &c);
			printf("%d", a+b+c);
			if (test < cases - 1)
				printf("\n");
			continue;
		}
		
		half = (N >> 1) + 1;
		offsetA = 0;
		crit_ends_cnt = 0;
		for (line = 1 ; line < half ; line++)
		{
			start_lines[line-1] = offsetA;
			lines_cnt = 1;
			do
			{
				scanf("%d",&(cells[offsetA++].Aw));
			}
			while (lines_cnt++ < line);
		}
		
		do
		{
			start_lines[line-1] = offsetA;
			M = N - line + 1;
			col = 1;
			while ( col < M )
			{
				//cout << "phase 1: line " << line << " , col " << col << " -> ";
				scanf("%d",&(cells[offsetA++].Aw));
				col++;
			}
			ptr = cells + offsetA;
			//cout << "phase 2: line " << line << " , col " << col << " -> ";
			scanf("%d",&ptr->Bw);
			ptr->Aw = ptr->Bw;
			crit_ends[crit_ends_cnt++] = offsetA;
			offsetB = offsetA++;
			col++;
			while ( col <= line )
			{
				//cout << "phase 3: line " << line << " , col " << col << " -> ";
				tempCalc = N - col + 1;
				tempMin = (col < tempCalc ? col : tempCalc);
				offsetB -= tempMin;
				scanf("%d",&(cells[offsetB].Bw));
				col++;
			}
		}
		while ( line++ < N );
		
		/*
		cout << "exited" << endl;
		//debug
		for (int i = 0 ; i < offsetA ; i++)
			printf("cell %d Aw: %d\n", i, cells[i].Aw);
		printf("--------\n");
		for (int i = 0 ; i < offsetA ; i++)
			printf("cell %d Bw: %d\n", i, cells[i].Bw);
		printf("--------\n");
		for (int i = 0; i < crit_ends_cnt ; i++)
			printf("diag %d W: %d\n", i, cells[crit_ends[i]].Aw);
		*/
		
		//finding max path for every cell
		
		offsetA = 0;
		cells[offsetA].Amax = cells[offsetA].Aw;
		cells[offsetA].Bmax = cells[offsetA].Bw;
		offsetA++;
		for (line = 2 ; line < half ; line++ )
		{
			colCnt = 0;
			do
			{
				cellWeightA = cells[offsetA].Aw;
				cellWeightB = cells[offsetA].Bw;
				aboveCell = offsetA - line + 1;
				tempMaxA = cells[aboveCell].Amax + cellWeightA;
				tempMaxB = cells[aboveCell].Bmax + cellWeightB;
				if ( offsetA + 1 == start_lines[line] )
					tempMaxA = tempMaxB = 0;
				aboveCell--;
				if (colCnt)
				{
					tempCalc = cells[aboveCell].Amax + cellWeightA;
					if ( tempCalc > tempMaxA ) tempMaxA = tempCalc;
					tempCalc = cells[aboveCell].Bmax + cellWeightB;
					if ( tempCalc > tempMaxB ) tempMaxB = tempCalc;					
				}
				aboveCell += 2;
				if ( aboveCell < start_lines[line-1] )
				{
					tempCalc = cells[aboveCell].Amax + cellWeightA;
					if ( tempCalc > tempMaxA ) tempMaxA = tempCalc;
					tempCalc = cells[aboveCell].Bmax + cellWeightB;
					if ( tempCalc > tempMaxB ) tempMaxB = tempCalc;	
				}
				
				cells[offsetA].Amax = tempMaxA;
				cells[offsetA].Bmax = tempMaxB;
				cells[offsetA].diag_stepA = cells[offsetA].diag_stepB = -1;
				//cout << "offset " << offsetA << " -> Amax : " << cells[offsetA].Amax << " , Bmax : " << cells[offsetA].Bmax << endl;
				offsetA++;
				colCnt++;
			}
			while (offsetA < start_lines[line] - 1);		//start_lines[line] checks the start of the NEXT line
			cells[offsetA].Amax = cells[offsetA - line].Amax + cells[offsetA].Aw;
			cells[offsetA].Bmax = cells[offsetA - line].Bmax + cells[offsetA].Bw;
			//cout << "offset " << offsetA << " -> Amax : " << cells[offsetA].Amax << " , Bmax : " << cells[offsetA].Bmax << endl;
			offsetA++;
		}
		diagCnt = 0;
		do
		{
			colCnt = 0;
			do
			{
				cellWeightA = cells[offsetA].Aw;
				cellWeightB = cells[offsetA].Bw;
				
				aboveCell = offsetA - N + line - 2;
				if (line == half)
					aboveCell = offsetA - line + 1;

				tempMaxA = cells[aboveCell].Amax + cellWeightA;
				tempMaxB = cells[aboveCell].Bmax + cellWeightB;
				
				if ( (line == half) && (N % 2) && (offsetA == crit_ends[diagCnt]) )
					tempMaxA = tempMaxB = 0;
				
				aboveCell--;
				if (colCnt)
				{
					tempCalc = cells[aboveCell].Amax + cellWeightA;
					if ( tempCalc > tempMaxA ) tempMaxA = tempCalc;
					tempCalc = cells[aboveCell].Bmax + cellWeightB;
					if ( tempCalc > tempMaxB ) tempMaxB = tempCalc;					
				}
				aboveCell += 2;
				diagFlagA = diagFlagB = false;
				if ( aboveCell < start_lines[line-1] )
				{
					tempCalc = cells[aboveCell].Amax + cellWeightA;
					if ( tempCalc > tempMaxA ) 
					{
						tempMaxA = tempCalc;
						diagFlagA = true;
					}
					tempCalc = cells[aboveCell].Bmax + cellWeightB;
					if ( tempCalc > tempMaxB ) 
					{
						tempMaxB = tempCalc;
						diagFlagB = true;
					}
				}
				cells[offsetA].Amax = tempMaxA;
				cells[offsetA].Bmax = tempMaxB;
				cells[offsetA].diag_stepA = cells[offsetA].diag_stepB = -1;
				//cout << "offset " << offsetA << " -> Amax : " << cells[offsetA].Amax << " , Bmax : " << cells[offsetA].Bmax << endl;
				
				if (offsetA == crit_ends[diagCnt])
				{
					diagCnt++;
					cells[offsetA].diag_stepA = cells[offsetA].diag_stepB = line;
					if (diagFlagA)
					{
						cells[offsetA].diag_stepA = cells[aboveCell].diag_stepA;
					}
					if (diagFlagB)
					{
						cells[offsetA].diag_stepB = cells[aboveCell].diag_stepB;
					}
				}
				
				//debug
				if (line == N - 1)
				{
					//cout << "aristera: max " << cells[offsetA].Amax << ", diag " << cells[offsetA].diag_stepA << endl;
					//cout << "dexia: max " << cells[offsetA].Bmax << ", diag " << cells[offsetA].diag_stepB << endl;
					if ( colCnt == 1 )
					{
						//cout << "diag1: " << cells[offsetA].Amax << endl;
						//cout << "diag2: " << cells[offsetA-1].Amax << endl;
						diagSelections = 0;
						if ( cells[offsetA].Amax >= cells[offsetA-1].Amax )
						{
							diagSelections++;
							result1 = cells[offsetA].Amax;
						}
						else
							result1 = cells[offsetA-1].Amax;
							
						if ( cells[offsetA].Bmax >= cells[offsetA-1].Bmax )
						{
							diagSelections++;
							result2 = cells[offsetA].Bmax;
						}
						else
							result2 = cells[offsetA-1].Bmax;
							
						if ( diagSelections == 2 )
						{
							selectionCase1 = cells[offsetA].Amax + cells[offsetA-1].Bmax;
							selectionCase2 = cells[offsetA].Bmax + cells[offsetA-1].Amax;
							finalResult = (selectionCase1 > selectionCase2 ? selectionCase1 : selectionCase2);
						}
						else
							finalResult = result1 + result2;
					}
				}
				
				offsetA++;
				colCnt++;
			}
			while (offsetA < start_lines[line]);		//start_lines[line] checks the start of the NEXT line
		}
		while ( line++ < N - 1 );
		//cout << "final: " << finalResult << endl;
		finalResult += cells[offsetA].Aw;
		printf("%d", finalResult);
		if ( test < cases - 1 )
			printf("\n");
	}
	
	//getch();
	return 0;
}