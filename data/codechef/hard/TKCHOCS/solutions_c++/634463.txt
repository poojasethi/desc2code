#define _CRT_SECURE_NO_DEPRECATE

#include <iostream>
#include <cstdio>
#include <utility>
#include <memory>
#include <vector>
#include <algorithm>
#include <set>
#include <map>
#include <queue>
#include <stack>
#include <string>
#include <cmath>
#include <cstring>
#include <memory.h>
#include <ctime>

#define pb push_back
#define mp make_pair
#define pii pair<int,int>
#define LL long long
#define VI vector<int>
#define X first
#define Y second
#define sz(_v) ((int)_v.size())
#define all(_v) (_v).begin(),(_v).end()
#define FOR(i,a,b) for (int i(a); i<=(b); i++)
#define rep(i,a) FOR(i,1,a)
#define rept(i,a) FOR(i,0,a-1)
#define x1 X1
#define y1 Y1
#define sqr(a) ((a)*(a))
#define INF 2000000000

using namespace std;

int chips[510][510];
int dyn[510][510];
int back_dyn[510][510];
int n;

int dfs(int i, int j, bool first)
{
	if (i<0 || j<0 || j>=n || i>=n || j>i || i+j+1==n || (i+j+1<n && !first) || (i+j+1>n && first)) return 0;
	if (dyn[i][j]>=0) return dyn[i][j];
	int ans=0;
	if (first)
	{
		rept(q,3) ans=max(ans,dfs(i+1,j+q-1,1));
	}
	else
	{
		rept(q,3) ans=max(ans,dfs(i+q-1,j-1,0));
	}
	dyn[i][j]=ans+chips[i][j];
	return dyn[i][j];
}

int back_dfs(int i, int j, int first)
{
	if (i<0 || j<0 || j>=n || i>=n || j>i || i+j+1==n || (i+j+1<n && !first) || (i+j+1>n && first)) return 0;
	if (back_dyn[i][j]>=0) return back_dyn[i][j];
	int ans=0;
	if (first)
	{
		rept(q,3) ans=max(ans,back_dfs(i-1,j+q-1,1));
	}
	else
	{
		rept(q,3) ans=max(ans,back_dfs(i+q-1,j+1,0));
	}
	back_dyn[i][j]=ans+chips[i][j];
	return back_dyn[i][j];
}

int main()
{
	int t;
	scanf("%d",&t);
	rept(tst,t)
	{
		scanf("%d",&n);
		rept(i,n)
			rept(j,i+1) scanf("%d",&chips[i][j]);
		memset(dyn,-1,sizeof dyn);
		memset(back_dyn,-1,sizeof back_dyn);
		int dyn1=dfs(0,0,1);
		int dyn2=dfs(n-1,n-1,0);
		int ans=dyn1+dyn2+chips[n-1][0];
		back_dfs(n-1,1,0);
		back_dfs(n-2,0,1);
		dyn[n-1][0]=chips[n-1][0];
		rept(i,(n+1)/2-1)
		{
			dyn[n-2-i][i+1]=dyn[n-1-i][i]+chips[n-2-i][i+1];
			int cur=dyn[n-2-i][i+1];
			ans=max(ans,cur+back_dfs(n-2-i-1,i+1,1)+dyn2);
			ans=max(ans,cur+back_dfs(n-2-i-1,i+1-1,1)+dyn2);
			ans=max(ans,cur+back_dfs(n-2-i,i+1+1,0)+dyn1);
			ans=max(ans,cur+back_dfs(n-2-i+1,i+1+1,0)+dyn1);
		}
		printf("%d\n",ans);
	}
	return 0;
}