#include <algorithm>
#include <cmath>
#include <complex>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <utility>
#include <vector>

using namespace std;

typedef long long ll;

#define MP make_pair
#define PB push_back
#define SZ(xs) int((xs).size())
#define ELEM(x,xs) ((xs).find(x)!=(xs).end())
#define SORT(xs) sort((xs).begin(),(xs).end())

#define FOR(i,a,b) for(int i=(a);i<(b);++i)
#define REP(i,n) FOR(i,0,n)

#define PMOD(a,b) (((a)%(b)+(b))%(b))

#define DUMP(x) cerr << #x << " = " << (x) << endl;

const double EPS = 1e-9;
const double PI = acos(-1.);

template <class T> inline T sq(T x) {return x*x;}

void solve() {

  int T;
  scanf("%d", &T);
  REP(i,T) {
    int N;
    scanf("%d", &N);
    int table[512][512][4] = {};
    REP(j,N) {
      REP(k,j+1) {
        scanf("%d", table[j+1][k+1]);
      }
    }
    REP(j,N) {
      REP(k,j+1) {
        table[j+1][k+1][1] = max(table[j][k][1],max(table[j][k+1][1],table[j][k+2][1]));
        if (j+k < N-1) table[j+1][k+1][1] += table[j+1][k+1][0];
        else break;
      }
    }
    for (int j=N-1; j>=0; --j) {
      for (int k=N-1; k>=j; --k) {
        table[k+1][j+1][2] = max(table[k][j+2][2],max(table[k+1][j+2][2],table[k+2][j+2][2]));
        if (j+k > N-1) table[k+1][j+1][2] += table[k+1][j+1][0];
        else break;
      }
    }
    REP(j,N+1>>1) {
      table[N-j][j+1][3] = table[N-j+1][j][3]+table[N-j][j+1][0];
    }
    ll ans = 0LL;
    REP(j,N+1>>1) {
      REP(k,N+1>>1) {
        ll _ans = 0LL;
        _ans += table[N-j][j+1][1];
        _ans += table[N-k][k+1][2];
        _ans += table[N-max(j,k)][max(j,k)+1][3];
        if (ans < _ans) ans = _ans;
      }
    }
    printf("%lld\n", ans);
  }

}

int main() {

  solve();

  return 0;

}
