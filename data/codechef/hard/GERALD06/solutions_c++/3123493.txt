#include <iostream>
#include <cstdio>
#include <vector>
#include <queue>
using namespace std;
const int N = 5000+5;
bool gr[N][N];
struct coord
{
   int x, y;
};
int T, n, m, k;
vector< int > graph[N];
vector< int > g[N];
int top, st[N];
int go[N];

int mark[N];
void dfsT(int v, int ty)
{
   mark[v] = ty;
   for(unsigned int j = 0; j < g[v].size(); ++ j)
   {
      int to = g[v][j];
      if(mark[to]==0)
      {
         dfsT(to, 2-ty+1);
      }
   }
}
void twopart(int q)
{
   for(int i = 1; i <= q; ++ i)
   {
      mark[i] = 0;
   }
   for(int i = 1; i <= q; ++ i)
   {
      if(mark[i]==0)
      {
         dfsT(i, 1);
      }
   }
}

int rtop, re[N];

vector< coord > res[N];
bool used[N][N];
queue< coord > qu;

int sta[N], fin[N];
int siz;

int main()
{
  // freopen("input.txt", "r", stdin);
   scanf("%d", &T);
   for(int te = 1; te <= T; ++ te)
   {
      scanf("%d%d", &n, &m);

      for(int i = 1; i <= m; ++ i)
      {
         int s, f;
         scanf("%d%d", &s, &f);
         graph[s].push_back(f);
         graph[f].push_back(s);

         gr[s][f] = 1;
         gr[f][s] = 1;
      }
      rtop = 0;
      for(int i = 1; i <= n; ++ i)
      {
         if(graph[i].size() >= 3)
         {
            for(int j = 1; j <= n; ++ j)
            go[j] = 0;

            top = 0;
            for(unsigned int j = 0; j < graph[i].size(); ++ j)
            {
               int v = graph[i][j];
               ++ top;

               st[ top ] = v;
               go[v] = top;
               g[ top ].clear();
            }

            for(int u = 1; u <= top; ++ u)
            {
               for(int v = u+1; v <= top; ++ v)
               {
                  if(gr[ st[u] ][ st[v] ]==0)
                  {
                     g[ u ].push_back(v);
                     g[ v ].push_back( u );
                  }
               }
            }
            //g is bipartite
            twopart(top);
            int q1 = 0, q2 = 0;
            for(int u = 1; u <= top; ++ u)
            {
               if(mark[ u ]==1)
               ++ q1;
               else
               ++ q2;
            }
            if(q1 >= 3 || q2 >= 3)
            {
               if(q1 < 3)
               {
                  swap(q1, q2);
                  for(int v = 1; v <= top; ++ v)
                  {
                     mark[v] = 2-mark[v]+1;
                  }
               }
               //q1 >= 3
               for(int sh = 1; sh <= top; ++ sh)
               {
                  int sz = 0;
                  int v = st[ sh ];
                  if(mark[sh]==2)
                  {
                     for(unsigned int j = 0; j < graph[v].size(); ++ j)
                     {
                        if(go[ graph[v][j] ]!=0 && mark[ go[ graph[v][j] ] ]==1)
                        ++ sz;
                     }
                     if(sz >= 2)
                     {
                        mark[ sh ] = 1;
                     }
                  }
               }
               rtop = 0;
               ++ rtop;
               re[ rtop ] = i;
               for(int v = 1; v <= top; ++ v)
               {
                  if(mark[v]==1)
                  {
                     ++ rtop;
                     re[rtop] = st[v];
                  }
               }
               goto x;
            }
            else
            continue;
            //x*x+y*y >= 2*x*y x*x+y*y+2*x*y <= 2*(x*x+y*y) <= O(m)
         }
      }
      x:
      for(int i = 1; i <= n; ++ i)
      mark[i] = 0;
      top = 1;
      for(int i = 1; i <= rtop; ++ i)
      {
         coord c;
         ++ top;
         c.x = top;
         c.y = re[i];
         qu.push(c);

         mark[ c.y ] = 1;

         sta[ c.y ] = 1;
         fin[ c.y ] = top;

         res[1].push_back(c);
      }
      while(!qu.empty())
      {
         coord c;
         c = qu.front();
         qu.pop();
         for(unsigned int j = 0; j < graph[c.y].size(); ++ j)
         {
            int u = graph[ c.y ][j];
            if(mark[u]==0)
            {
               bool stug = 0;
               for(unsigned int e = 0; e < graph[ u ].size(); ++ e)
               {
                  int to = graph[u][e];
                  if(mark[to]!=0)
                  {
                     if(sta[to]==c.x || fin[to]==c.x)
                     continue;

                     stug = 1;
                     coord d;
                     d.x = fin[to];
                     d.y = u;
                     mark[ u ] = 1;
                     sta[u] = c.x;
                     fin[u] = d.x;
                     res[ c.x ].push_back(d);
                     break;
                  }
               }
               if(stug==0)
               {
                  coord d;
                  ++ top;
                  d.x = top;
                  d.y = u;
                  qu.push(d);

                  mark[ d.y ] = 1;

                  sta[ d.y ] = c.x;
                  fin[ d.y ] = top;

                  res[c.x].push_back(d);
               }
            }
         }
      }
      printf("%d\n", top);
      for(int i = 1; i <= n; ++ i)
      printf("%d %d\n", sta[i], fin[i]);
      //clear gr
      for(int i = 1; i <= n; ++ i)
      {
         for(unsigned int j = 0; j < graph[i].size(); ++ j)
         {
            gr[i][ graph[i][j] ] = 0;
            gr[ graph[i][j] ][ i ] = 0;
         }
      }
      for(int i = 1;i <= n; ++ i)
      {
         graph[i].clear();
         res[i].clear();
      }
   }
   return 0;
}
