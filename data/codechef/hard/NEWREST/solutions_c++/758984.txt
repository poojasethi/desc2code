#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <iostream>
#include <cmath>
#include <algorithm>

#include <string>
#include <vector>
#include <deque>
#include <queue>
#include <set>
#include <map>

using namespace std;

typedef long long ll;


#define MOD 1000000007

ll mpow(ll a, ll n){
  if(!n)return 1;
  ll b = mpow(a, n/2);
  b = b * b % MOD;
  if(n & 1)
    b = b * a % MOD;
  return b;
  /*
  if(n==0)return 1;
  if(n==1)return a;
  if(n&1){
    return (a * mpow((a*a)%MOD, n/2)) % MOD;
  }else{
    return mpow((a*a)%MOD, n/2) % MOD;
  }
  */
}


int N, M, K;
ll dp[1010][1010];

ll fact[1000010];

ll mfc[1000010];
ll mfact(int n){
  if(mfc[n] >= 0)return mfc[n];
  return mfc[n] = mpow(fact[n], MOD-2);
}

int main(){
  cin.tie(0);
  ios_base::sync_with_stdio(false);

  // dp[i][j]: the number of ways to cook exactly j different types of dish for i days
  dp[0][0] = 1;
  for(int i = 1; i <= 1000; i++)
    for(int j = 1; j <= i; j++){
      /*
      dp[i+1][j] += j * dp[i][j];
      dp[i+1][j] %= MOD;
      dp[i+1][j+1] += dp[i][j];
      dp[i+1][j+1] %= MOD;
      */
      dp[i][j] = (j*dp[i-1][j] + dp[i-1][j-1])%MOD;
    }

  // factorial
  // C(M, j) = M! * ((M-j)!)^(-1)
  // ((M-j)!)^(-1) (mod MOD) -> K!^(-1)=K!^(MOD-2) {Euler's theorem}
  fact[0] = 1;
  mfc[0] = 1;
  for(int i = 1; i <= 1000000; i++){
    fact[i] = (fact[i-1] * i) % MOD;
    //mfact[i] = mpow(fact[i], MOD-2);
    mfc[i] = -1;
  }

  int T;
  cin >> T;
  for(;T;T--){
    cin >> N >> M >> K;
    ll ans = 0;
    int lim = min(M, K);
    for(int i = 1; i <= lim; i++){
      ans += (((fact[M] * mfact(M-i))%MOD)*dp[N][i])%MOD;
      ans %= MOD;
    }

    cout << ans << endl;
  }

  return 0;
}
