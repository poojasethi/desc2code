#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<math.h>
#include<algorithm>
#include<set>
#include<map>
#include<utility>
#include<vector>
#include<string>
#include<stack>
#include<queue>
using namespace std;
#define MINI(a,b) ((a)<(b)?(a):(b))
#define MAXN 50006
#define MAXL 20
int n,stp,mv;
int sum[MAXN],cnt[MAXN],rrank[MAXL][MAXN], suf[MAXN], revsuf[MAXN], suffix[MAXN], tmp[MAXN];
char str[MAXN];
int N;
int LCP(int u,int v)
{
    int ret=0,i;
    for(i = stp; i >= 0 && u<n && v<n; i--)
    {
        if(rrank[i][u]==rrank[i][v])
        {
            ret += 1<<i;
            u += 1<<i;
            v += 1<<i;
        }
    }
    return ret;
}
bool equal(int u,int v)
{
    if(!stp) return str[u]==str[v];
    if(rrank[stp-1][u]!=rrank[stp-1][v]) return false;
    int a = u + mv < n ? rrank[stp-1][u+mv] : -1;
    int b = v + mv < n ? rrank[stp-1][v+mv] : -1;
    return a == b ;
}
void update()
{
    int i;
    for(i=0; i<n; ++i) sum[i] = 0;
    int rnk = 0;
    for(i=0; i<n; i++)
    {
        suffix[i] = tmp[i];
        if(i && !equal(suffix[i],suffix[i-1]))
        {
            rrank[stp][suffix[i]]= ++rnk;
            sum[rnk+1] = sum[rnk];
        }
        else rrank[stp][suffix[i]] = rnk;
        ++sum[rnk+1];
    }
}
void Sort()
{
    int i;
    for(i=0; i<n; ++i) cnt[i] = 0;
    memset(tmp, -1, sizeof tmp);
    for(i=0; i<mv; ++i)
    {
        int idx = rrank[stp-1][n-i-1];
        int x = sum[idx];
        tmp[x+cnt[idx]] = n-i-1;
        ++cnt[idx];
    }
    for(i=0; i<n; ++i)
    {
        int idx = suffix[i] - mv;
        if(idx<0) continue;
        idx = rrank[stp-1][idx];
        int x = sum[idx];
        tmp[x+cnt[idx]] = suffix[i] - mv;
        ++cnt[idx];
    }
    update();
}

bool cmp(const int &a,const int &b)
{
    return str[a]<str[b];
}
void buildSuffixArray(int nn)
{
    n = nn;
    int i;
    for(i=0; i<n; i++) tmp[i] = i;
    sort(tmp,tmp+n,cmp);
    stp = 0;
    update();
    ++stp;
    for(mv=1; mv<n; mv<<=1)
    {
        Sort();
        stp++;
    }
    stp--;
}
bool cmp2(int x, int y)
{
    int l = LCP(x,y);
    return (str[x+l] < str[y+l]);
}
int A[MAXN];
int DP[MAXN][MAXL];
void RMQ(int N)
{
    int i,j;
    for (i=0; i<N; ++i) DP[i][0] = i;
    for (j=1; (1<<j)<=N; ++j)
    {
        for (i=0; i+(1<<j)<=N; ++i)
        {
            if (A[DP[i][j-1]] < A[DP[i+(1<<(j-1))][j-1]]) DP[i][j] = DP[i][j-1];
            else DP[i][j] = DP[i+(1<<(j-1))][j-1];
        }
    }
}
int calc(int start, int end)
{
    start = revsuf[start]+1, end = revsuf[end];
    if (start > end) swap(start,end);
    int i,j;
    int diff = end - start + 1;
    j = 0;
    while((1<<j)<=diff) ++j;
    --j;
    if (A[DP[start][j]]<A[DP[end-(1<<j)+1][j]]) return A[DP[start][j]];
    else return A[DP[end-(1<<j)+1][j]];
}
void pre(char *str)
{
    int i;
    N = strlen(str);
    for (i=N-1; i>=0; --i) suf[i] = i;
    buildSuffixArray(N);
    sort(suf, suf+N, cmp2);
    for (i=0; i<N; ++i) revsuf[suf[i]] = i;
    A[0] = N+6;
    for (i=1; i<N; ++i) A[i] = LCP(suf[i-1],suf[i]);
    RMQ(N);
    //for (i=0; i<N; ++i) printf("%2d ", suf[i]); puts("");
    //for (i=0; i<N; ++i) printf("%2d ", revsuf[i]); puts("");
}
set < int > S;
long long ans;
void insert(int idx)
{
    int sfx = revsuf[idx];
    //printf("%d %d\n", idx, sfx);
    if (S.find(sfx) != S.end()) return;
    if (S.empty())
    {
        S.insert(sfx);
        ans = N - idx;
        return;
    }
    int x,y,l;
    set < int > :: iterator it = S.begin();
    if (*it > sfx)
    {
        x = idx, y = suf[*it];
        //l = LCP(x,y);
        l = calc(x,y);
        ans += N - x;
        ans -= l;
        S.insert(sfx);
        return;
    }
    it = --(S.end());
    if (*it < sfx)
    {
        x = suf[*it], y = idx;
        //l = LCP(x,y);
        l = calc(x,y);
        ans += N - y;
        ans -= l;
        S.insert(sfx);
        return;
    }
    set < int > :: iterator itl,itu;
    int m1,m2;
    itl = itu = S.upper_bound(sfx);
    --itl;
    //ans += LCP(suf[*itl], suf[*itu]);
    ans += N - idx;
    //ans -= (m1 = LCP(suf[*itl],idx));
    ans -= (m1 = calc(suf[*itl],idx));
    //ans -= (m2 = LCP(idx,suf[*itu]));
    ans -= (m2 = calc(idx,suf[*itu]));
    ans += MINI(m1,m2);
    S.insert(sfx);
}
void remove(int idx)
{
    int sfx = revsuf[idx];
    //printf("%d %d\n", idx, sfx);
    if (S.find(sfx) == S.end()) return;
    if (S.size() == 1)
    {
        S.clear(), ans = 0;
        return;
    }
    int x,y,l;
    set < int > :: iterator it = S.begin();
    if (*it == sfx)
    {
        ++it;
        x = idx, y = suf[*it];
        //l = LCP(x,y);
        l = calc(x,y);
        ans += l;
        ans -= N - x;
        S.erase(sfx);
        return;
    }
    it = --(S.end());
    if (*it == sfx)
    {
        --it;
        x = suf[*it], y = idx;
        //l = LCP(x,y);
        l = calc(x,y);
        ans += l;
        ans -= N - y;
        S.erase(sfx);
        return;
    }
    set < int > :: iterator itl,itu;
    itl = itu = S.upper_bound(sfx);
    --itl; --itl;
    int m1,m2;
    //ans -= LCP(suf[*itl], suf[*itu]);
    //ans += (m1 = LCP(suf[*itl], idx)) + (m2 = LCP(idx, suf[*itu]));
    ans += (m1 = calc(suf[*itl], idx)) + (m2 = calc(idx, suf[*itu]));
    ans -= MINI(m1,m2);
    ans -= N - idx;
    S.erase(sfx);
}
struct qq
{
    int idx,x,y;
    qq(int ii, int xx, int yy) {idx = ii, x = xx, y = yy;}
};
int sz;
bool cmpb(qq a, qq b)
{
    if (a.x / sz == b.x / sz) return a.y < b.y;
    return a.x / sz < b.x / sz;
}
vector < qq > queries;
vector < pair < int , long long > > qans;
void process(vector < qq > &V)
{
    if (V.size() == 0) return;
    S.clear(), ans = 0;
    sort (V.begin(), V.end(), cmpb);
    int l = V[0].x, r = V[0].y, i, q, ll, rr;
    ll = l, rr = r;
    S.clear(), ans = 0;
    for (i=l; i<=r; ++i) insert(i);
    qans.push_back(pair < int, long long > (V[0].idx,ans));
    /*printf("%d %d : %lld :: ", ll,rr,ans);
    for (set < int > :: iterator is = S.begin(); is != S.end(); ++is) printf("%d ", suf[*is]); puts("");*/
    for (q=1; q<V.size(); ++q)
    {
        ll = V[q].x, rr = V[q].y;
        while (r>rr) remove(r--);
        while (r<rr) insert(++r);
        while (l>ll) insert(--l);
        while (l<ll) remove(l++);
        /*while (l<ll) remove(l++);
        while (l>ll) insert(--l);
        insert(l);
        while (r>rr) remove(r--);
        if (r<l) r = l;
        while (r<rr) insert(++r);
        insert(rr);*/
        /*printf("%d %d : %d %d : %lld :: ", ll,rr,l,r,ans);
        for (set < int > :: iterator is = S.begin(); is != S.end(); ++is) printf("%d ", suf[*is]); puts("");*/
        qans.push_back(pair < int, long long > (V[q].idx,ans));
    }
}
int main()
{
    //freopen("data2.txt", "r", stdin);
    //freopen("my.txt", "w", stdout);
    int T,x,y,Q,q,i;
    scanf("%d", &T);
    while (T--)
    {
        scanf("%s", str);
        pre(str);
        sz = ceil(sqrt((double) N) + 0.5);
        queries.clear();
        scanf("%d", &Q);
        for (q=0; q<Q; ++q)
        {
            scanf("%d %d", &x, &y);
            queries.push_back(qq(q,--x,--y));
        }
        qans.clear();
        process(queries);
        sort(qans.begin(), qans.end());
        for (q=0; q<qans.size(); ++q) printf("%lld\n", qans[q].second);
    }
    return 0;
}
