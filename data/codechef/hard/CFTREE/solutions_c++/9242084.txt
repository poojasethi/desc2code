#pragma comment(linker, "/STACK:64000000")
 
#define _USE_MATH_DEFINES
#define _CRT_NO_DERPECATE
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <ctime>
#include <cassert>
#include <memory.h>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <queue>
#include <utility>
#include <algorithm>
#include <functional>
#include <complex>
 
using namespace std;
 
typedef long long int64;
typedef unsigned long long uint64;
typedef pair<int, int> pii;
#define sq(x) ((x)*(x))
#define INF ((int)(2e9))
#define LINF ((int64)(2e18))
#define EPS ((double)(1e-7))
#define MOD ((int64)(1e9 + 9))
#define y0 xdsf
const double PI = 6.283185307179586476925286766559;
const int MAXN = 300100, root = 333;
int f[MAXN], res[MAXN];
pii mas[MAXN];
int n, m, k;
double p;
vector < vector < int > > gr;
int mod = 1e9 + 7;
int tin[MAXN], tout[MAXN], tim;
pii que[root];
int level[MAXN];
inline int sum(int a, int b)
{
	a += b;
	if (a >= mod)
		a -= mod;
	return a;
}

void precalc()
{
	f[1] = 1;
	f[2] = 1;
	for(int i = 3; i < MAXN; ++i)
	{
		f[i] = sum(f[i - 2], f[i - 1]);
	}
}

void dfs1(int u, int lev = 0)
{
	tin[u] = tim++;
	level[u] = lev;
	for(int i = 0; i < (int)gr[u].size(); ++i)
	{
		dfs1(gr[u][i], lev + 1);
	}
	tout[u] = tim++;
	
}


int is_anc(int a, int b)
{
	if (tin[a] <= tin[b] && tout[a] >= tout[b])
		return 1;
	return 0;
}

void dfs2(int u)
{
	res[u] = sum(res[u], mas[u].first);
	for(int i = 0; i < (int)gr[u].size(); ++i)
	{
		int to = gr[u][i];
		mas[to].first = sum(mas[to].first, mas[u].second);
		mas[to].second = sum(mas[to].second, sum(mas[u].second, mas[u].first));
		dfs2(to);
	}
	mas[u] = pii(0, 0);
}
int en = 0;
void update(int u, int k)
{
	mas[u].first = sum(mas[u].first, f[k]);
	mas[u].second = sum(mas[u].second, f[k + 1]);
	que[en++] = pii(u, k);
	if (en == root)
	{
		dfs2(1);
		en = 0;
		return;
	}
}

int ans(int u)
{
	int an = res[u];
	for(int i = 0; i < en; ++i)
	{
		if (is_anc(que[i].first, u))
		{
			an = sum(an, f[que[i].second + level[u] - level[que[i].first]]);
		}
	}
	return an;
}

void solve()
{
	scanf("%d %d\n", &n, &m);
	gr.resize(n + 1);
	for(int i = 2; i <= n; ++i)
	{
		int t;
		scanf("%d\n", &t);
		gr[t].push_back(i);
	}
	dfs1(1);
	for(int i = 0; i < m; ++i)
	{
		char p;
		scanf("%c ", &p);
		if (p == 'Q')
		{
			int x;
			scanf("%d\n", &x);
			printf("%d\n", ans(x));
		}
		else
		{
			int u, k;
			scanf("%d %d\n", &u, &k);
			update(u, k);
		}
	}
}
 
int main()
{
#ifdef _MY_DEBUG
    freopen("input.txt", "rt", stdin); freopen("output.txt", "wt", stdout);
#else
#endif
    ios_base::sync_with_stdio(false); cin.tie(0);
    srand(time(0));
	precalc();
	solve();
    return 0;
}  