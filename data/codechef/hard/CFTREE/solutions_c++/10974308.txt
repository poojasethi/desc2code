// Author: thecodekaiser
// FIB(M + N) = FIB(M-1) * FIB(N) + FIB(M) * FIB(N+1)
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
#define MXN 110010
#define MOD (ll)(1e9+7)
#define pb push_back
#define mp make_pair

ll BIT1[MXN*3], BIT2[MXN*3];
map<int, ll> FIB;
int N, M, _tm, depth[MXN], tin[2*MXN], tout[2*MXN];
vector<int> gph[MXN];

void dfs(int cur, int pre)
{
	tin[cur] = tout[cur] = ++_tm;

	for(int i = 0; i < gph[cur].size(); i++)
	{
		int child = gph[cur][i];
		if(child != pre)
		{
			depth[child] = depth[cur] + 1;
			dfs(child, cur);
			tout[cur] = max(tout[cur], tout[child]);
		}
	}
}

void update(ll * BIT, int idx, ll VAL)
{
	int i = idx;
	while(i <= _tm+1)
		{ BIT[i] = (BIT[i] + VAL + MOD) % MOD; i += (i & -i); }
	return;
}

ll query(ll * BIT, int idx)
{
	int i = idx; 
	ll ret = 0;
	while(i > 0)
		{ ret = (ret + BIT[i] + MOD) % MOD; i -= (i & -i); }
	return ret;
}

void pre(int root)
{
	depth[root] = 0;
	dfs(root, -1);
}

void solve()
{
	cin >> N >> M;
	for(int i = 2; i <= N; i++)
	{
		int p;	cin >> p;
		gph[p].pb(i); gph[i].pb(p);
	}

	pre(1);
	
	FIB[0] = 0; FIB[1] = 1;
	for(int i = 2; i <= N+1; i++)
		FIB[i] = (FIB[i-2] + FIB[i-1]) % MOD;
	for(int i = -1; i >= -N-1; i--)
		FIB[i] = (FIB[i+2] - FIB[i+1] + MOD) % MOD;

	char str[3];

	for(int i = 0; i < M; i++)
	{
		scanf("%s", str);
		if(str[0] == 'Q')
		{	
			int x;
			scanf("%d", &x);
			ll a = query(BIT1, tin[x]);
			ll b = query(BIT2, tin[x]);

			ll ans = (a * FIB[depth[x]] + b * FIB[depth[x] - 1] + MOD) % MOD;
			printf("%lld\n", ans);
		}
		else if (str[0] == 'U')
		{
			int x, k;
			scanf("%d %d", &x, &k);

			update(BIT1, tin[x], FIB[k - depth[x] + 1]);	 update(BIT2, tin[x], FIB[k - depth[x]]);
			update(BIT1, tout[x]+1, -FIB[k - depth[x] + 1]); update(BIT2, tout[x]+1, -FIB[k - depth[x]]);
		}
	}
	return;
}

int main()
{
	solve();
	return 0;
}