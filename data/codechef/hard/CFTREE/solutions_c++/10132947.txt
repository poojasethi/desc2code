//This is getting accepted!
// Fibonaci tree
#include<bits/stdc++.h>

using namespace std;

#define FI first
#define SE second
#define pb push_back
#define mp make_pair
#define ll long long
#define sz(a) ((int)(a).size())
#define __builtin_popcount __builtin_popcounll

typedef pair<int, int> pii;
typedef pair<double, double> pdd;
typedef pair<int, pii> ppi;

const double PI = acos(0) * 2;
const double EPS = 1e-8;
const ll MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const int oo = 1e9;
const double foo = 1e30;

template<class T> int getbit(T s, int i) { return (s >> i) & 1; }
template<class T> T onbit(T s, int i) { return s | (T(1) << i); }
template<class T> T offbit(T s, int i) { return s & (~(T(1) << i)); }
template<class T> int cntbit(T s) { return __builtin_popcounll(s);}

const int k = 330;

int time1 = 0, n, m;
int values[100100], pos[100100], ty[100100], L[100100], tin[100100], tout[100100], value[100100], parent[100100];
ll f[200100], b[100100], c[100100], a[100100];
vector<int> adj[100100], v;

void DFS(int u, int lv) {
//	cout << u << endl;
	L[u] = lv;
	time1++;
	v.pb(u);
	tin[u] = time1;
	for (int i=0; i<sz(adj[u]); i++) {
		int v = adj[u][i];
		DFS(v, lv + 1);
	}
	time1++;
//	v.pb(u);
	tout[u] = time1;
}

int main() {
#ifndef ONLINE_JUDGE
    freopen("inp.txt", "r", stdin);
    freopen("out.txt", "w", stdout);
#endif

	f[1] = 1; f[2] = 1;
	for (int i=3; i<=200001; i++) f[i] = (f[i-1] + f[i-2]) % MOD;
//	ll stest = 0;
//	for (int i=2; i<=332; i+=2) (stest += f[i]) %= MOD;
//	cout << stest << endl;
	scanf("%d%d", &n, &m);
	for (int i=2; i<=n; i++) {
		int x;
		scanf("%d", &x);
		adj[x].pb(i);
		parent[i] = x;
	}
	DFS(1, 1);
//	for (int i=0; i<sz(v); i++) cout << v[i] << " ";
//	cout << endl;
	char type;
	int tc = 0;
	for (int i=1; i<=m; i++) {
		scanf("\n%c", &type);
//		cout << i << " " << type << endl;
		if (type == 'U') scanf("%d%d", &pos[i], &value[i]), ty[i] = 0;
		else scanf("%d", &pos[i]), ty[i] = 1;
		if (i % k == 0 || i == m) { // cache full
			fill_n(b, n + 1, 0);
			fill_n(c, n + 1, 0);
			for (int j = k * tc + 1; j<=i; j++) {
				if (ty[j] == 1) { // here
//					if (j % 2 != 1) cout << j << endl;
					int x = tin[pos[j]];
					ll ret = a[pos[j]];
					for (int t=k * tc + 1; t<=j; t++) if (ty[t] == 0) {
						if (tin[pos[t]] <= x && tout[pos[t]] >= x) {
							(ret += f[value[t] + L[pos[j]] - L[pos[t]]]) %= MOD;
						}
					}
					printf("%lld\n", ret);
				}
				else {
					(b[pos[j]] += f[value[j]]) %= MOD;
					(c[pos[j]] += f[value[j] - 1]) %= MOD;
				}
			}
			tc++;
			// update
			for (int j=0; j<sz(v); j++) {
				int u = v[j];
				int pu = parent[u];
				(a[u] += b[pu] + c[pu] + b[u]) %= MOD;
				(b[u] = b[u] + b[pu] + c[pu]) %= MOD;
				(c[u] = b[pu] + c[u]) %= MOD;
			}
		}
	}

}
