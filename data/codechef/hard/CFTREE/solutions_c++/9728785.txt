//#include<bits/stdc++.h>
#include <iostream>
#include <cstdio>
#include <vector>
#include <map>
#include <queue>
#include <stack>
#include <cstring>
#include <algorithm>
#include <cstdlib>
#include <cmath>
#include <set>
using namespace std;
#define w(t) while(t--)
#define S(x) scanf("%d",&x)
#define SLL(x) scanf("%lld",&x)
#define P(x) printf("%d\n",x)
#define fl(i , a, b) for(i = (int)a; i<(int)b; i++)
#define mem(a , value) memset(a , value , sizeof(a))
#define tr(c, itr) for(itr = (c).begin(); itr != (c).end(); itr++)
#define MOD 1000000007
#define MAX 1000000010
#define ll long long
#define all(v) v.begin(),v.end()
#define mp make_pair
#define pb push_back
#define N 100002
#define f first
#define s second
typedef pair<int,int> pp;
int n , m ,ui, in[N] , out[N] , depth[N]; 
vector<int> v[N], updates[N];
std::vector<pp> buff;
ll a[N] , f[3*N]; 
int tim=0; 
void dfs(int u ,int par)
{
    in[u] = ++tim; 
    for (int i = 0; i < (int)v[u].size(); ++i)
    {
        int nx=v[u][i];
        if(nx != par) {
            depth[nx] = depth[u]+1;
            dfs(nx , u); 
        }
    }
    out[u] = tim ; 
}
void remake(int u , int par ,ll v1 , ll v2)
{
    a[u] = (a[u] + v1) % MOD;
    a[u] = (a[u] + v2) % MOD;  
    ll vv1 = v1; ll vv2 = v2; 
    v2 = (v1 + v2)%MOD; 
    v1 = vv2; 
    for (int i = 0; i < (int)updates[u].size(); i++)
    {
        a[u] = (a[u] + f[updates[u][i]]) % MOD; // modified the current value of node u.
        v1 = (v1 + f[updates[u][i] - 1]) % MOD; 
        v2 = (v2 + f[updates[u][i]])%MOD; 
    }
    for (int i = 0; i < v[u].size(); ++i)
    {
        int nx = v[u][i]; 
        if(nx != par)
            remake(nx , u , v1 , v2); 

    }
}
int main()
{
       // freopen("C:\\Users\\screw_1011\\Desktop\\input.txt","r",stdin);
        // freopen("C:\\Users\\screw_1011\\Desktop\\output.txt","w",stdout);
    int i, k,x, j;
    f[0] = 0 ; f[1] = 1;

    fl(i , 2 , 2*N + 10)
    f[i] = (f[i-2] + f[i-1]) % MOD; 
    
    S(n); S(m);
    fl(i,1,n)
    {
        S(ui);
        v[ui].pb(i+1);
    }
    dfs(1,-1); 
    int root = sqrt(n);
    ll ans=0 ; 
    buff.clear();
    string ch ;    
    fl(i,1,m+1)
    {   
        cin >> ch; 
        if (ch == "U")
        {
            S(x) ;S(k) ;    
            if((int)buff.size() > root)
            {
                remake(1,-1,0,0);  
                for(j=1;j<=N;j++) updates[j].clear(); 
                buff.clear();
            }
            buff.pb(mp(x,k));
            updates[x].pb(k);
        }
        else 
        {   
            S(x);
            ans = a[x] % MOD ;
            fl(j,0,buff.size())
            {
                int u = buff[j].f ;int k = buff[j].s; 
                if(in[u] <= in[x] && out[x] <= out[u])
                {
                    ans = (ans + f[k + depth[x] - depth[u]])%MOD; 
                }
            }
            printf("%lld\n", ans);
        }       
        
    }
    return 0;
}