//used topcoder as a reference
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <string.h>
#include <algorithm>
#include <math.h>
#include <vector>
#include <queue>
#include <set>
#include <stack>
#include <map>
#define INF_MAX 2147483647
#define INF_MIN -2147483647
#define INF_LL 9223372036854775807LL
#define INF 2000000000
#define PI acos(-1.0)
#define inf INT_MAX
#define mod 1000000007
using namespace std;
typedef long long int LL;
int max_buffer;
// LL add_val[100010];
LL updates[100010];

std::vector<int > adjList[100010];

int val_at_node[100010] , fibo[1000010] , st[100010] , en[100010];
int counter = 1;

// int addmetoNode[100010] , addmetoNextNode[100010];
std::vector<int > addmetoNode[100010];



int nr , T[100010] , P[100010] , L[100010] , N;
int u , v , dp[100010][32];

// std::vector< pair < int , int > > sqrtBuffer;
pair<int , int > sqrtBuffer[100010];

void initFibo()
{
  fibo[0] = 1;
  fibo[1] = 1;
  fibo[2] = 1;
  for(int i=3;i<=1000000;i++){
    fibo[i] = (fibo[i-1] + fibo[i-2]);
    if(fibo[i] >= mod)
      fibo[i] = (fibo[i]%mod);
  }
}



void dfs(int curr_node, int parent)  
{
      int k;
      st[curr_node] = counter++;
      if(L[curr_node] < nr)
          P[curr_node] = 1;
      else{
          if(!(L[curr_node] % nr))
              P[curr_node] = T[curr_node];
          else
              P[curr_node] = P[T[curr_node]];
      }   
      std::vector< int >::iterator it = adjList[curr_node].begin();
      while(it!=adjList[curr_node].end())
      {
          if((*it)!=parent)
          {
            L[(*it)] = L[curr_node] + 1;
            T[(*it)] = curr_node;
            dfs((*it) , curr_node);
          }
          it++;
      }
      en[curr_node] = counter-1;
}


void process3()
{
      int i, j;   
  //we initialize every element in P with -1
      for(i=0; i<=N + 4 ; i++)
          for (j=0;(1<<j)<=N + 4; j++)
              dp[i][j] = -1;   
  //the first ancestor of every node i is T[i]
      for (i = 1; i <= N; i++)
          dp[i][0] = T[i];   
  //bottom up dynamic programing
      for (j = 1; (1 << j) <= N; j++)
         for (i = 1; i <= N; i++)
             if (dp[i][j - 1] != -1)
                 dp[i][j] = dp[dp[i][j - 1]][j - 1];
}
  
int query(int p, int q)
{
      int tmp, lg , i;   
  //if p is situated on a higher level than q then we swap them
      if (L[p] < L[q])
      {
          tmp = p;
          p = q;
          q = tmp;  
      }
  //we compute the value of [log(L[p)]
      for (lg = 1; (1<<lg) <= L[p];)
         lg++;
      lg--;   
  //we find the ancestor of node p situated on the same level
  //with q using the values in P
      for (i = lg; i >= 0; i--){
          if(L[p] - (1 << i) >= L[q])
              p = dp[p][i];   
      }

      if (p == q)
          return p;   
  //we compute LCA(p, q) using the values in P
      for (i = lg; i >= 0; i--)
      {
          if (dp[p][i] != -1 && dp[p][i] != dp[q][i])
          {
                p = dp[p][i];
              q = dp[q][i];
          }
      }
   
      return T[p];
}

  int LCA(int x, int y)
  {
  //as long as the node in the next section of 
  //x and y is not one common ancestor
  //we get the node situated on the smaller 
  //lever closer
      while (P[x] != P[y])
          if (L[x] > L[y])
             x = P[x];
          else
              y = P[y];
           
  //now they are in the same section, so we trivially compute the LCA
      while (x != y)
          if (L[x] > L[y])
             x = T[x];
          else
             y = T[y];
      return x;
  }


void pushDown(int curr_node , int parent , int curr_nodeUpdate , int prev_nodeUpdate)
{

  int adder = 0;


  for(int i=0;i<addmetoNode[curr_node].size();i++)
  {
    adder = adder + fibo[addmetoNode[curr_node][i] + 1];
    if(adder >= mod)
      adder = (adder%mod);
  }

  int temp = (prev_nodeUpdate + (curr_nodeUpdate + adder)%mod)%mod;

  if(temp>=mod)
    temp = (temp%mod);

  for(int i=0;i<addmetoNode[curr_node].size();i++)
  {
    curr_nodeUpdate = curr_nodeUpdate + fibo[addmetoNode[curr_node][i]];
    // prev_nodeUpdate = prev_nodeUpdate + fibo[addmetoNode[curr_node][i] - 1];
    
    if(curr_nodeUpdate >= mod)
      curr_nodeUpdate = (curr_nodeUpdate % mod);
    

    // if(prev_nodeUpdate >= mod)
      // prev_nodeUpdate = (prev_nodeUpdate % mod);

  }


  val_at_node[curr_node] = val_at_node[curr_node] + (0LL + curr_nodeUpdate)%mod;
  if(val_at_node[curr_node] >= mod)
    val_at_node[curr_node] = (val_at_node[curr_node]%mod);
  
  std::vector<int >::iterator it = adjList[curr_node].begin();
  

  while(it!=adjList[curr_node].end())
  {
    if((*it)!=parent)
pushDown((*it) , curr_node , temp ,  curr_nodeUpdate );
    it++;
  }
  addmetoNode[curr_node].clear();
}





int main()
{
initFibo();

// memset(addmetoNode , 0 , sizeof(addmetoNode));
// memset(addmetoNextNode , 0 , sizeof(addmetoNextNode));


int M , sz;
scanf("%d %d",&N,&M);
max_buffer = sqrt(N);
// max_buffer  = 3;
// max_buffer = 0;  
nr = sqrt(M);
// memset(dp , -1 , sizeof(dp));
memset(val_at_node , 0 , sizeof(val_at_node));
// memset(add_val , 0 , sizeof(add_val));

for(int i=0;i<100004;i++)
  addmetoNode[i].clear();

memset(L , 0 , sizeof(L));

for(int i=1;i<=N-1;i++){
  scanf("%d",&u);
  v = i + 1;
  adjList[u].push_back(v);
  adjList[v].push_back(u);
}
L[1] = 0;
T[1] = 1;
dfs(1 , 1);
process3();
char flag;
int node_number;
int curr_node;
int update_val , new_val;
int ans = 0;
sz = 0;
// memset(add_val , 0 , sizeof(add_val));
// while(M--)
for(int o=1;o<=M;o++)
{
  // cin >> u >> v;
  cin >> flag;
  // scanf("%c",&flag);
  if(flag=='Q')
  {
    // cin >> node_number;
    scanf("%d",&node_number);
    ans = val_at_node[node_number];
    for(int i=0;i<sz;i++)
    {
      curr_node = sqrtBuffer[i].first;
      update_val = sqrtBuffer[i].second;
      

      if(L[node_number] >= L[curr_node])
      {
        /*
        if(query(node_number , curr_node) == curr_node)
        {
          ans = ans + fibo[update_val + L[node_number] - L[curr_node]];
          if(ans >= mod)
            ans = (ans%mod);
        }
        */

        //this is enough no need to do LCA part
        if((st[node_number]>=st[curr_node]) && (en[node_number]<=en[curr_node]))
        {
          ans = ans + fibo[update_val + L[node_number] - L[curr_node]];
          if(ans >= mod)
            ans = (ans%mod); 
        }


      }

    }
    //change to lld
    printf("%d\n", ans);
  }
  else if(flag == 'U')
  {
    cin >> node_number >> new_val;
    sqrtBuffer[sz] = make_pair(node_number , new_val);
    // add_val[node_number]+=new_val;


    addmetoNode[node_number].push_back(new_val);


    // addmetoNode[node_number]+=fibo[new_val];
    // if(addmetoNode[node_number]>=mod)
      // addmetoNode[node_number] = (addmetoNode[node_number]%mod);

    // addmetoNextNode[node_number]+=fibo[(new_val+1)];
    // if(addmetoNextNode[node_number]>=mod)
      // addmetoNextNode[node_number]  = (addmetoNextNode[node_number]%mod);

    // updates[node_number]++;
    sz++;
  }
  if(sz >= max_buffer)
  {
    pushDown(1 , 1 , 0 , 0);
    sz = 0;
  }
}
return 0;
}










































