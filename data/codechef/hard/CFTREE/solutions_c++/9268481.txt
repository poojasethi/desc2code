#include<iostream>
#include<vector>
#include<algorithm>
#include<cstdio>
using namespace std;
#define mod 1000000007

vector<int>adj[100007],v[100007];
int fib[200008];
int subtree[100007];
int timee;
int beg[100007];
int temp[100007];
int depth[100007];
pair<int,int>store[500];
int queries,n,m;
void dfs(int i,int parent)
{
beg[i]=++timee;
subtree[i]=1;
for(int j=0;j<adj[i].size();j++)
if(adj[i][j]!=parent)
{
depth[adj[i][j]]=1+depth[i];
dfs(adj[i][j],i);
subtree[i]+=subtree[adj[i][j]];
}
}

void update_(int i,int parent,int temp1,int temp2)
{
for(int j=0;j<v[i].size();j++)
{
temp1+=fib[v[i][j]];
temp2+=fib[v[i][j]-1];
temp1=temp1%mod;
temp2=temp2%mod;
}
temp[i]=(temp[i]+temp1)%mod;
for(int j=0;j<adj[i].size();j++)
if(adj[i][j]!=parent)
update_(adj[i][j],i,(temp1+temp2)%mod,temp1);
}


void update(int x,int k)
{
queries++;
store[queries].first=x;
store[queries].second=k;
v[x].push_back(k);
if(queries>=320)
{
update_(1,-1,0,0);
queries=0;
for(int i=0;i<=n;i++)
v[i].clear();
}
}

int query(int x)
{
int ans=0;
ans+=temp[x];
for(int i=1;i<=queries;i++)
if(beg[x]>=beg[store[i].first]&&beg[x]<=beg[store[i].first]+subtree[store[i].first]-1)
{
ans+=fib[store[i].second+depth[x]-depth[store[i].first]];
ans=ans%mod;
}
return ans;
}

void gen()
{
fib[0]=0;
fib[1]=1;
for(int i=2;i<=200007;i++)
fib[i]=(fib[i-1]+fib[i-2])%mod;
}

int main()
{
ios_base::sync_with_stdio(false);
//freopen("in.txt","r",stdin);
gen();
cin>>n>>m;
for(int i=1;i<n;i++)
{
int x;
cin>>x;
adj[i+1].push_back(x);
adj[x].push_back(i+1);
}
dfs(1,-1);
while(m--)
{
char c;
int k,x;
cin>>c;
if(c=='U')
{
cin>>x>>k;
update(x,k);
}
else if(c=='Q')
{
cin>>x;
cout<<query(x)<<endl;
}
}
return 0;
}
