// Author: thecodekaiser
#include <bits/stdc++.h>
using namespace std;
 
typedef long long ll;
#define MXN 100100
#define SQRT 330
#define MOD (ll)(1e9+7)
#define pb push_back
#define mp make_pair
 
vector<int> gph[MXN], node_update[MXN];
vector< pair<int,int> > updates;
int depth[MXN], tin[2*MXN], tout[2*MXN];
ll val[MXN], FIB[3*MXN];;
int N, M, _tm;
 
void dfs_pre(int cur, int par)
{
	tin[cur] = tout[cur] = ++_tm;
 
	for(int i = 0; i < gph[cur].size(); i++)
	{
		int child = gph[cur][i];
		if(child != par)
		{
			depth[child] = depth[cur] + 1;
			dfs_pre(child, cur);
			tout[cur] = max(tout[cur], tout[child]);
		}
	}
}
 
void query(int idx)
{
	ll ans = val[idx];
 
	for(int i = 0; i < updates.size(); i++)
	{
		int x = updates[i].first, k = updates[i].second;
 
		if(tin[x] <= tin[idx] and tout[idx] <= tout[x])
		{
			ans = ans + FIB[k + (depth[idx] - depth[x])];
 
			if (ans >= MOD or ans < 0) ans = (ans + 2*MOD) % MOD;
		}
	}
 
	printf("%lld\n", ans);
}
 
void dfs(int cur, int par, int current, int prev)
{
	ll upd = 0;
 	ll cval = current, pval = prev;

	for(int i = 0; i < node_update[cur].size(); i++)
	{
		cval += FIB[node_update[cur][i]];
		if(cval >= MOD or cval < 0)	cval = (cval + MOD) % MOD;
 
		upd += FIB[node_update[cur][i]-1];
		if(upd >= MOD or upd < 0)	upd = (upd + MOD) % MOD;
	}
 
	val[cur] += cval;
 
	if(val[cur] >= MOD or val[cur] < 0) val[cur] = (val[cur] + MOD) % MOD;
 
	ll ncurrent = cval + upd + pval;
	ll nprev = cval;
 
	if(ncurrent >= MOD or ncurrent < 0) ncurrent = (ncurrent + MOD) % MOD;
	if(nprev >= MOD or nprev < 0) nprev = (nprev + MOD) % MOD;
 
	for(int i = 0; i < gph[cur].size(); i++)
	{
		int child = gph[cur][i];
		if(child != par)
		{
			dfs(child, cur, ncurrent, nprev);
		}
	}
 
	node_update[cur].clear();
}
 
void rebuild()
{
	//cout << "REBUILDING\n";
	dfs(1, -1, 0, 0);
	updates.clear();
	//cout << "REBUILDING DONE\n";
}
 
void solve()
{
	FIB[1] = FIB[2] = 1LL;
	for(int i = 3; i < 3*MXN; i++)
	{
		FIB[i] = FIB[i-2] + FIB[i-1];
		if(FIB[i] >= MOD or FIB[i] < 0) FIB[i] = (FIB[i] + MOD) % MOD;
	}
 
	cin >> N >> M;
	for(int i = 2; i <= N; i++)
	{
		int par; cin >> par;
		gph[par].pb(i); gph[i].pb(par);
	}
 
	depth[1] = 0; dfs_pre(1, -1);
 
	char str[3];
 
	for(int i = 0; i < M; i++)
	{
		scanf("%s", str);
		if(str[0] == 'Q')
		{
			int x;
			scanf("%d", &x);
			query(x);
		}
		else if(str[0] == 'U')
		{
			int x, k;
			scanf("%d %d", &x, &k);
			updates.pb(mp(x, k));
			node_update[x].push_back(k);
		}
 
		if (updates.size() >= SQRT)
			rebuild();
	}
 
	return;
}
 
int main()
{
	solve();
	return 0;
} 