//coded using the editorial
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <string.h>
#include <algorithm>
#include <math.h>
#include <vector>
#include <queue>
#include <set>
#include <stack>
#include <map>
#define INF_MAX 2147483647
#define INF_MIN -2147483647
#define INF_LL 9223372036854775807LL
#define INF 2000000000
#define PI acos(-1.0)
#define inf INT_MAX
#define mod 1000000007
using namespace std;
typedef long long int LL;
std::vector<int > adjList[200010];
int V , Q , u , X , K  , st[200010] , en[200010] , counter = 1 , at[200010] , depth[200010] , fibo[200010];
int const_factor = 1;
int val_at_node[200010];
char flag;

std::vector<int > node_update[100010];

void calc_fibo(){
	fibo[0] = 0;
	fibo[1] = 1;
	fibo[2] = 1;
	for(int i=3;i<=200004;i++){
		fibo[i] = (fibo[i-1] + fibo[i-2]);
		if(fibo[i] >= mod)
			fibo[i] = (fibo[i]%mod);
	}
}


std::vector< pair<int , int > > update_queries;


void dfs(int curr_vertex , int parent){
	st[curr_vertex] = counter;
	depth[curr_vertex] = depth[parent] + 1;
	at[counter++] = curr_vertex;
	std::vector<int >::iterator it = adjList[curr_vertex].begin();
	while(it!=adjList[curr_vertex].end())
	{
		if((*it)!=parent)
			dfs((*it) , curr_vertex);
		it++;
	}
	en[curr_vertex] = counter-1;
}


int calc(int node)
{
	int curr_vertex , fibo_index;
	LL ret = 0;
	for(int i=0;i<update_queries.size();i++)
	{
		curr_vertex = update_queries[i].first;
		fibo_index = update_queries[i].second;

		if(st[node]>=st[curr_vertex] && en[node] <=en[curr_vertex])  	//shows that node is inside the curr_vertex
		{
			
			ret  = (ret + (fibo[fibo_index + depth[node] - depth[curr_vertex] ])%mod);
			if(ret >= mod)
				ret = (ret % mod);

		}
	}
	return ret;
}

/*
3 4 5
4 5 6
5 6 7
11 12 13
*/

void rebuild(int curr_vertex , int parent , int current , int prev)
{
	

	int upd = 0;
	for(int i=0;i<node_update[curr_vertex].size();i++)
	{
		current = (current + fibo[node_update[curr_vertex][i]])%mod;
		upd = (upd + fibo[node_update[curr_vertex][i] - 1])%mod;
	}
	// cout << " current    " << current <<  "    prev   " << prev << endl;
	val_at_node[curr_vertex] = (val_at_node[curr_vertex]%mod + current%mod)%mod;
	int new_current = (prev + (current + upd)%mod)%mod;
	int new_prev = current%mod;
	// cout << " rebuilding  node  " << curr_vertex << "  val_at_node   " << val_at_node[curr_vertex] << endl;
	std::vector<int >::iterator it = adjList[curr_vertex].begin();
	while(it!=adjList[curr_vertex].end())
	{
		// cout << "# " << endl;
		if((*it)!=parent)
			rebuild((*it) , curr_vertex , new_current , new_prev );
		it++;
	}
	node_update[curr_vertex].clear();
}




int main()
{
int temp;
calc_fibo();
scanf("%d %d",&V,&Q);
val_at_node[1] = 0;
for(int i=2;i<=V;i++){
	val_at_node[i] = 0;
	scanf("%d",&temp);
	adjList[temp].push_back(i);
	adjList[i].push_back(temp);
}
val_at_node[V+1] = 0;
depth[0] = 0;
dfs(1 , 0);
int val = 0;
while(const_factor*const_factor<V)
	const_factor++;
// cout << const_factor << endl;
// const_factor = 0;
// const_factor--;
for(int i=0;i<Q;i++)
{
	cin >> flag;
	if(flag=='U')
	{
		scanf("%d %d",&X,&K);
		node_update[X].push_back(K);
		update_queries.push_back(make_pair(X , K));
		val++;
		if(val > const_factor){
			val = 0;
			update_queries.clear();
			rebuild(1 , 0 , 0 , 0);			
		}
	}
	else
	{
		scanf("%d",&X);
		// cout << " # " << update_queries.size() << endl;
		cout << (val_at_node[X]%mod + calc(X))%mod << endl;
		// cout << val_at_node[X] << endl;
	}	
}


return 0;
}










