#include<cstdio>
#include<iostream>
#include<cstring>
#include<vector>
#include<memory.h>
#include<cstdlib>
#include<cmath>
#include<cassert>
#include<memory.h>
#include<algorithm>
#include<queue>
#include<map>
#include<stack>
using namespace std;

typedef pair<int, int>PII;

#define mp make_pair
#define fi first
#define se second
#define NN 50005

stack<PII>dfs;
priority_queue<PII>west;
priority_queue<PII>east;
map<int, int>sweep;
map<int, int>::iterator it;

int sq[NN][3], parent[NN], grundy[NN], child[NN], sibling[NN];
int N;

int min(int a, int b){return a<b?a:b;}

void solve()
{
    scanf("%d", &N);
    memset(grundy ,0, sizeof(grundy));

    child[N] = -1;
    for(int i=0; i<N; i++)
    {
        child[i] = -1;
        scanf("%d%d%d", &sq[i][0], &sq[i][1], &sq[i][2]);
        west.push(mp(-sq[i][0], i));
        east.push(mp(-sq[i][0]-sq[i][2], i));
    }

    while(!east.empty())
    {
        if(west.empty() || east.top()>= west.top())
        {
            int n = east.top().se;
            east.pop();
            grundy[n]++;
            grundy[parent[n]]^=grundy[n];
            sweep.erase(sq[n][1]);
            sweep.erase(sq[n][1] + sq[n][2]);
        }
        else
        {
            int n = west.top().se;
            west.pop();
            it = sweep.lower_bound(sq[n][1]);
            if(it == sweep.end())
            {
                parent[n] = N;
            }
            else
            {
                parent[n] = it->se;
            }
            sibling[n] = child[parent[n]];
            child[parent[n]] = n;
            sweep[sq[n][1]] = parent[n];
            sweep[sq[n][1] + sq[n][2]] = n;
        }
    }
    if(grundy[N] == 0)
    {
        printf("Fit\n");
    }
    else
    {
        int ans = N;
        dfs.push(mp(grundy[N], child[N]));
        while(!dfs.empty())
        {
            if(dfs.top().se == -1)dfs.pop();
            else
            {
                int n = dfs.top().se;
                dfs.top().se = sibling[n];
                if(grundy[n] == dfs.top().fi)
                {
                    ans = min(ans, n);
                    continue;
                }
                dfs.push(mp(((dfs.top().fi^grundy[n]) - 1)^(grundy[n] - 1), child[n] ));
            }
        }
        printf("Fat %d\n", ans+1);
    }



}

int main()
{
    #ifndef ONLINE_JUDGE
    freopen("input.txt","r",stdin);
    freopen("output.txt","w",stdout);
    #endif

    int t;
    scanf("%d", &t);
    while(t--)
    {
       solve();
    }


}

