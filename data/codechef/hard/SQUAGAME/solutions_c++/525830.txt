#include <cstdio>
#include <map>
#include <stack>
#include <vector>
#include <cstring>
#include <algorithm>
#include <cassert>
using namespace std;

typedef pair<int, int> PII;

const int N = 51200;

int n;
int parent[N];

//////////// SG begin ////////////////

vector<int> g[N], base;

void buildGraph()
{
	base.clear();
	for(int i = 0; i < n; i++) g[i].clear();
	for(int i = 0; i < n; i++) {
		if(parent[i] == -1) base.push_back(i);
		else g[parent[i]].push_back(i);
	}		
}

int sg[N];

int getSG(int v)
{
	if(sg[v] != -1) return sg[v];
	if(g[v].size() == 0) return sg[v] = 1;
	sg[v] = 0;
	for(int i = 0; i < g[v].size(); i++) sg[v] ^= getSG(g[v][i]);
	return sg[v] = sg[v]+1;
}

int getSGSum()
{
	memset(sg, -1, sizeof(sg));
	int sum = 0;
	for(int i = 0; i < base.size(); i++) sum ^= getSG(base[i]);
	return sum;
}

bool canMove[N];

void markIt(int v, int needXor)
{
	if(needXor == 0) { canMove[v] = true; return; }
	if(g[v].size() == 0) return;
	// children Xor
	int chXor = 0;
	for(int i = 0; i < g[v].size(); i++) chXor ^= sg[g[v][i]];
	for(int i = 0; i < g[v].size(); i++) markIt(g[v][i], (needXor-1) ^ chXor ^ sg[g[v][i]]);
}

void getMarks()
{
	memset(canMove, false, sizeof(canMove));
	int xorSum = 0;
	for(int i = 0; i < base.size(); i++) xorSum ^= sg[base[i]];
	for(int i = 0; i < base.size(); i++) markIt(base[i], xorSum ^ sg[base[i]]);
}

//////////// SG end ////////////////

int y[2*N];

class Event {
public:
	int id, tm, x1, x2, tp;
	Event(int _id, int _tm, int _x1, int _x2, int _tp) : id(_id), tm(_tm), x1(_x1), x2(_x2), tp(_tp) {}
	bool operator <(const Event& e) const { return tm < e.tm; }
};

vector<Event> ve;

stack<int> S[1<<18];
int depth[N];

inline int LEFT(int nid) { return 2*nid+1; }
inline int RIGHT(int nid) { return 2*nid+2; }

void initTree(int nid, int x, int y) {
	while(!S[nid].empty()) S[nid].pop();
	if(y-x == 1) return;
	int mid = (x+y)/2;
	initTree(LEFT(nid), x, mid);
	initTree(RIGHT(nid), mid, y);
}

void insert(int nid, int x, int y, int px, int py, int id) {
	if(px <= x && py >= y) S[nid].push(id);
	else if(y-x == 1) return;
	else {
		int mid = (x+y)/2;
		if(px < mid) insert(LEFT(nid), x, mid, px, py, id);
		if(py > mid) insert(RIGHT(nid), mid, y, px, py, id);
	}
}
int query(int nid, int x, int y, int px) {
	int res = -1;
	if(S[nid].size() != 0) res = S[nid].top();
	if(y-x == 1) return res;
	int mid = (x+y)/2;
	int tmpr = -1;
	if(px < mid) tmpr = query(LEFT(nid), x, mid, px);
	else tmpr = query(RIGHT(nid), mid, y, px);
	if(res == -1 || (res != -1 && tmpr != -1 && depth[res] < depth[tmpr])) res = tmpr;
	return res;
}

void remove(int nid, int x, int y, int px, int py, int id) {
	if(px <= x && py >= y) S[nid].pop();
	else if(y-x == 1) return;
	else {
		int mid = (x+y)/2;
		if(px < mid) remove(LEFT(nid), x, mid, px, py, id);
		if(py > mid) remove(RIGHT(nid), mid, y, px, py, id);
	}
}

int main()
{
	// freopen("G:\\a.txt", "r", stdin);
	int T;
	scanf("%d", &T);
	for(int t = 0; t < T; t++) {
		ve.clear();
		memset(parent, -1, sizeof(parent));
		
		// printf("..........\n");
		
		scanf("%d", &n);
		for(int i = 0; i < n; i++) {
			int a, b, c;
			scanf("%d %d %d", &a, &b, &c);
			y[2*i] = b;
			y[2*i+1] = b+c;
			ve.push_back(Event(i, a, b, b+c, 0));
			ve.push_back(Event(i, a+c, b, b+c, 1));
		}
		
		sort(ve.begin(), ve.end());
		sort(y, y+2*n);
		int yn = unique(y, y+2*n) - y;

		// printf("????????\n");
		// initTree(0, 0, yn);
		
		for(int i = 0; i < (int)ve.size(); i++) {
			int x1 = lower_bound(y, y+yn, ve[i].x1) - y;
			int x2 = lower_bound(y, y+yn, ve[i].x2) - y;
			int id = ve[i].id;
			if(ve[i].tp == 0) {
				int res = query(0, 0, yn, x1);
				if(res != -1) parent[id] = res;
				depth[id] = i;
				insert(0, 0, yn, x1, x2, id);
			} else {
				remove(0, 0, yn, x1, x2, id);
			}
		}
		
		// printf("!!!!!!!!!\n");
		
		buildGraph();
		int xorSum = getSGSum();
		printf("%s", xorSum == 0 ? "Fit" : "Fat");
		if(xorSum == 0) { printf("\n"); continue; }
		getMarks();
		int lo = -1;
		for(int i = 0; i < n; i++) if(canMove[i]) { lo = i; break; }
		printf(" %d\n", lo+1);
	}
	
	return 0;
}
