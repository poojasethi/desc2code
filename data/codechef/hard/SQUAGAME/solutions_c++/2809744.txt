#include <cstdio>
#include <queue>
#include <map>
#include <stack>
#include <algorithm>
using namespace std;
 
int N, sq[50000][3];
int parent[50001], child[50001], sibling[50001], grundy[50001];
 
void read(){
	scanf("%d", &N);
	for(int i=0; i<N; i++)
		scanf("%d %d %d", sq[i], sq[i]+1, sq[i]+2);
	fill(parent, parent+N+1, 0);
	fill(grundy, grundy+N+1, 0);
	fill(child, child+N+1, -1);
}
 
int solve(){
	priority_queue<pair<int, int> > enter, exit;
	for(int i=0; i<N; i++){
		enter.push(make_pair(-sq[i][0], i));
		exit.push(make_pair(-(sq[i][0]+sq[i][2]), i));
	}
	map<int, int> sweep;
	while(!exit.empty()){
		if(enter.empty() || exit.top().first>=enter.top().first){
			int n=exit.top().second;
			exit.pop();
			sweep.erase(sq[n][1]);
			sweep.erase(sq[n][1]+sq[n][2]);
			grundy[n]++;
			grundy[parent[n]]^=grundy[n];
		}else{
			int n=enter.top().second;
			enter.pop();
			map<int, int>::iterator it=sweep.lower_bound(sq[n][1]);
			if(it==sweep.end())
				parent[n]=N;
			else
				parent[n]=it->second;
			sibling[n]=child[parent[n]];
			child[parent[n]]=n;
			sweep[sq[n][1]]=parent[n];
			sweep[sq[n][1]+sq[n][2]]=n;
		}
	}
	if(grundy[N]==0)
		return 0;
	stack<pair<int, int> > st;
	int res=N;
	st.push(make_pair(grundy[N], child[N]));
	while(!st.empty()){
		if(st.top().second==-1){
			st.pop();
		}else{
			int n=st.top().second;
			st.top().second=sibling[n];
			if(grundy[n]==st.top().first){
				res=min(res, n);
				continue;
			}
			st.push(make_pair(((st.top().first^grundy[n])-1)^(grundy[n]-1), child[n]));
		}
	}
	return res+1;
}
 
int main(){
	int T;
	for(scanf("%d", &T); T--; ){
		read();
		int s=solve();
		if(s)
			printf("Fat %d\n", s);
		else
			puts("Fit");
	}
	return 0;
}
 