#include<cstdio>
#include<vector>
#include<algorithm>
#include<cassert>
#include<queue>
std::deque<int> Q;
#define CLEARQ while (!Q.empty()) Q.pop_back()
#define REPCHILD for(EIT it=Child[u].begin();it!=Child[u].end();it++)
#define GOOD ((*it)->c<=v?1:0)
#define CV (*it)->nbr
#define ss(a) scanf("%d", &a)
#define ss3(a, b, c) scanf("%d%d%d", &a, &b, &c)
#define PB(a) push_back(a)
#define REP(a, b) for(int i=a;i<b;i++)
#define REP2(i, a, b) for(int i=a;i<b;i++)
#define IREP(a, b) for(int i=a;i>=b;i--)
const int ROOT = 1;
const int MINF = -2147000000;
struct edge {
	edge(int a, int w) {
		nbr = a;
		c = w;
	}
	int nbr;
	int c;
};
typedef std::vector<edge*>::iterator EIT;
const int N = 100001;

struct vertex {
	int v;
	int depth;
}v_arr[N];

inline int depth_compare(const vertex& a, const vertex &b) {
	return a.depth<b.depth;
}

std::vector<edge*> Arr[N];
std::vector<edge*> Child[N];
int maxC;

void retrieve_edge() {
	int a, b, c;
	ss3(a, b, c);
	Arr[a].PB(new edge(b, c));
	Arr[b].PB(new edge(a, c));
	maxC = std::max(c, maxC);
}

int n, L, R;
bool phi(int);
int min_phi() {
	int lo = 0, hi = maxC+1, Found=-1, mid;
	// return phi(9)?9:-1;
	while (hi>lo+1) {
		mid = lo+hi>>1;
		if (phi(mid)) {
			Found = mid;
			hi = mid;
		}
		else
			lo = mid;
	}
	return Found>maxC?-1:Found;
}

int maxEdgeDown[N];

int dfs(int u, int dpth, int par=-1) {
	v_arr[u].v = u;
	v_arr[u].depth = dpth;
	int maxD = dpth, dpc;
	Child[u].clear();
	for (EIT it=Arr[u].begin();it!=Arr[u].end();it++) {
		if(par==CV)
			continue;
		Child[u].PB(*it);
		dpc = dfs(CV, dpth+1, u);
		maxD = std::max(dpc, maxD);
		
	}
	maxEdgeDown[u] = maxD - dpth;
	
	return maxD;
}
const int RLimit = 54;
int g[N][RLimit], G[N][RLimit], H[N][RLimit];
int M[RLimit];

int main() {
	int t;
	REP(1, N) g[i][0] = 0;
	ss(t);
	while(t--) {
		maxC = -1;
		ss3(n, L, R);
		REP(1, n+1)
			Arr[i].clear();
		REP(1, n)// only n-1 times
			retrieve_edge();
		/*parent[ROOT] = ROOT;*/
		dfs(ROOT, 0);
		std::sort(v_arr+1, v_arr+n+1, depth_compare);
		printf("%d\n", min_phi());
	}
	return 0;
}

int set_g(int u, int l, int v) {
	int gv = 0;
	REPCHILD {
		if (l-1>maxEdgeDown[CV])
			continue;
		G[CV][l] = GOOD + g[CV][l-1];
		gv = std::max(G[CV][l], gv);
		H[CV][l] = G[CV][l]*2-l;
		/*printf("%d %d %d %d\n", CV, l, G[CV][l], H[CV][l]);*/
	}
	return (g[u][l] = gv);
}



bool phi(int v) {
	
	IREP(n, 1) {
		int V = v_arr[i].v;
		REP2(l, 1, (1+std::min(R, maxEdgeDown[V]))) {
			int a = set_g(V, l, v);
			if(l>=L && 2*a>l)
				return true;
		}
	}

	REP2(u, 1, n+1) {
		// all parents u
	
		REP(1, R+1) M[i] = MINF;

		REPCHILD {
			int J = CV;
			int medj = 1+maxEdgeDown[J];
			/*
			break b loop into 1...L-1  and L..R-1
			*/
			// for (int b=1;b<=std::min(R, medj);b++) {
			// 	for (int a=std::max(1, L-b);a<=R-b;a++)
			// 		/*if (J==3 && b==2 && a==3) {
			// 			printf("%d\n", );
			// 		}*/
			// 		if (M[a]>MINF && M[a]+H[J][b]>0)
			// 			return true;
			// }
			// /*update M array for new values from node J*/
			// for (int i=1;i<=std::min(R, medj);i++)
			// 	M[i] = std::max(H[J][i], M[i]);
			// continue;
			if (L>1) { // means 1..L-1 part can be broken off b
				CLEARQ;
				Q.PB(M[R-1]);
				
				for (int Ind=R-2;Ind>=L-1;Ind--) {
					
					while (!Q.empty() && Q.back()<M[Ind])
						Q.pop_back();
					Q.PB(M[Ind]);

				}
				for (int b=1;b<=medj;) {
					
					if (Q.front()>MINF && Q.front()+H[J][b]>0) {
						/*printf("%d:%d\n", J, b);*/
						return true;
					}
					
					if (b==L-1) break;
					
					/*remove M[R-b]*/
					if (Q.front()==M[R-b])
						Q.pop_front();
					b++;
					/*add M[L-b]*/
					while (!Q.empty() && M[L-b]>=Q.back())
						Q.pop_back();
					Q.PB(M[L-b]);
				}
				/*if(G[J][b]<0)
					continue;*/
			}
			/*
			second part is when b goes from L to R-1
			the interval is like 1..R-L then 1..R-L-1 then 1...R-L-2 until 1..1
			so if b is iterated from R-1 to L then my intervals increase by new R-b
			*/

			if (R>L && L<=medj) {
				CLEARQ;
				Q.PB(M[R-L]);
				IREP (R-L-1, 1) {
					while (!Q.empty() && Q.back()<M[i])
						Q.pop_back();
					Q.PB(M[i]);
				}
				for (int b=L;b<=medj && b<R;b++) {
					if (Q.front()>MINF && Q.front()+H[J][b]>0) {
						/*printf("%d:%d\n", J, b);*/
							return true;
					}
					if (M[R-b]==Q.front())
						Q.pop_front();
				}
			}
			/*ignoring the case when R=L=1*/

			/*update M array for new values from node J*/
			for (int i=1;i<=R && i<=medj;i++)
				M[i] = std::max(H[J][i], M[i]);
		}
	}


	return false;
}