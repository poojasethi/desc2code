#include <iostream>
#include <cstdio>
#include <string>
#include <vector>
#include <set>
#include <map>
#include <queue>
#include <cmath>
#include <algorithm>
using namespace std;
#define pb push_back
#define INF (int)1e9
#define FOR(i,n) for(int (i)=0;(i)<(n);++(i))
#define FORI(i,n) for(int (i)=1;(i)<=(n);++(i))
#define mp make_pair
#define pii pair<int,int>
#define ll long long
#define wez(n) int (n); scanf("%d",&(n));
#define IN(x,y) ((y).find((x))!=(y).end()) 
#define DBG(vari) cout<<#vari<<" = "<<vari<<endl;

inline void pisz(int n) {
   printf("%d\n",n);
}

vector<int> good[8][8];

int prawo(int x, int n) {
   return (x >> 1) | ((x&1) << (n-1));
}

int main () {
   vector<int> v;
   FOR(i,8) v.pb(i);
   do {
      bool gray = 1;
      FOR(i,8) {
         int j = (i+1) % 8;
         int x = v[i]^v[j];
         bool found = 0;
         FOR(k,3) if (1 << k == x) found = 1;
         if (!found) gray = 0;
      }
      if (gray) {
         /*FOR(i,8) printf("%d ",v[i]);
         printf("\n");*/
         FOR(i,8) FOR(j,8) if (i!=j) {
            FOR(k,8) if (v[k]==i) {
               int k1 = (k+1)%8;
               int k2 = k-1;
               if (k2<0) k2 += 8;
               if (v[k1] != j && v[k2] != j) good[i][j] = v;
            }
         }
      }
   } while (next_permutation(v.begin(),v.end()));
   /*
   FOR(i,8)FOR(j,8)if(i!=j) {
      DBG(i)DBG(j)
      if (good[i][j].empty()) printf("fail");
      else FOR(k,8) printf("%d ",good[i][j][k]);
      printf("\n\n");
   }*/
   
   wez(t)
   while(t--) {
      wez(n)wez(aa)wez(bb)
      int a = min(aa,bb), b = max(aa,bb);
      
      if (n==1) {
         printf("-1\n");
      } else if (n==2) {
         if ((a == 1 && b == 2) || (a == 0 && b == 3)) {
            printf("0 1 3 2\n");
         } else {
            printf("-1\n");
         }
      } else {
         // n >= 3
         int przes = 0;
         while ((a & 7) == (b & 7)) {
            ++przes;
            a = prawo(a,n);
            b = prawo(b,n);
         }
//         DBG(przes)
         vector<int> v = good[a&7][b&7];
         for (int teraz = 4; teraz <= n; ++teraz) {
            vector<int> w = v; // przepisujemy na razie
            for (int i = v.size()-1; i >= 0; --i) {
               w.pb(v[i] + (1 << (teraz-1)));
            }
            v = w;
         }
         FOR(i,n-przes) {
            FOR(j,v.size()) {
               v[j] = prawo(v[j],n);
            }
         }
         FOR(j,v.size()) printf("%d ",v[j]);
         printf("\n");
      }
   }
}
