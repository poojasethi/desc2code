#include<map>
#include<set>
#include<list>
#include<cmath>
#include<queue>
#include<stack>
#include<bitset>
#include<cstdio>
#include<string>
#include<vector>
#include<climits>
#include<complex>
#include<cstdlib>
#include<cstring>
#include<numeric>
#include<sstream>
#include<iostream>
#include<algorithm>
#include<functional>

#define	pb			push_back
#define	rep(i,n)	for(int i=0;i<n;i++)

using namespace std;

typedef	vector<int>			vi;

#define	rot(x,i)	( ( ((x)<<(i)) & ((1<<n)-1) ) | ((x)>>(n-(i))) )

int main(){
	int T;	scanf("%d",&T);
	while(T--){
		int n,a,b;	scanf("%d%d%d",&n,&a,&b);

		vi gray(1<<n);
		rep(i,1<<n)	gray[i]=i^(i>>1);
		gray.pb(gray[0]);

		bool ok=true;
		rep(i,gray.size()-1){
			if(gray[i]==b && gray[i+1]==a)	swap(a,b);
			if(gray[i]==a && gray[i+1]==b){ ok=false; break; }
		}
		if(ok)	goto FOUND;
		else{
			int p=-1;
			rep(i,n){
				int rot1=rot(gray[1],i),rot2=rot(gray[(1<<n)-1],i);
				// printf("rot1=%d, rot2=%d\n",rot1,rot2);
				// printf("rot1^a=%d, rot2^a=%d\n",rot1^a,rot2^a);
				if((rot1^a)!=b && (rot2^a)!=b){ p=i; break; }
			}
			if(~p){
				rep(i,gray.size())	gray[i]=rot(gray[i],p)^a;
				// printf("a=%d, b=%d, p=%d\n",a,b,p);
				goto FOUND;
			}
			else goto NOT_FOUND;
		}

		FOUND:
		rep(i,gray.size()-1)	printf("%s%d",i?" ":"",gray[i]);
		putchar('\n');
		continue;

		NOT_FOUND:
		puts("-1");
		continue;
	}

	return 0;
}
