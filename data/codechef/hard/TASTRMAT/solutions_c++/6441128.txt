#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define rep(i,x,y) for(int i=x;i<=y;++i)
#define dep(i,x,y) for(int i=x;i>=y;--i)
using namespace std;
#define N 200005
#define LD double
#define LL long long
#define P 1000000007
#define W 100001
const LD pi=acos(-1.0);

struct complex{
	LD re,im;
	complex(LD re=0,LD im=0):re(re),im(im){}
}a[N<<2],b[N<<2];

complex operator +(const complex &a,const complex &b){return complex(a.re+b.re,a.im+b.im);}
complex operator -(const complex &a,const complex &b){return complex(a.re-b.re,a.im-b.im);}
complex operator *(const complex &a,const complex &b){return complex(a.re*b.re-a.im*b.im,a.re*b.im+a.im*b.re);}

void DFT(complex *a,int n,int f){
	rep(i,0,n-1){
		int y=i,x=0;
		for(int k=1;k<n;k<<=1,y>>=1) (x<<=1)|=(y&1);
		if(x>i) swap(a[i],a[x]);
	}
	complex x,y;
	for(int i=2;i<=n;i<<=1){
		complex wn(cos(2*pi/i),f*sin(2*pi/i));
		for(int j=0;j<n;j+=i){
			complex w(1);
			for(int k=0;k<i>>1;k++){
				x=a[j+k];
				y=a[j+k+(i>>1)]*w;
				a[j+k]=x+y;
				a[j+k+(i>>1)]=x-y;
				w=w*wn;
			}
		}
	}
	if(f==-1) rep(i,0,n-1) a[i].re/=n;
}

char s[N];
int n,m,k,pre[N],tn;

int main(){
	scanf("%s",s+1);
	n=strlen(s+1);
	for(tn=1;tn<n<<1;tn<<=1)
	//return 0;
	rep(i,0,n-1) a[i].re=s[i+1]=='1',pre[i+1]=s[i+1]=='1';
	rep(i,1,n) pre[i]+=pre[i-1];
	DFT(a,tn<<1,1);
	scanf("%d",&k);
	while(k--){
		scanf("%s",s+1);
		m=strlen(s+1);
		LL ans=0,cnt=0;
		//rep(i,m,n) ans+=pre[i]-pre[i-m];
		rep(i,0,m-1) b[m-1-i].re=s[i+1]=='1',cnt+=s[i+1]=='1';
		//ans+=cnt*(n-m+1);
		DFT(b,tn<<1,1);
		rep(i,0,tn<<1) b[i]=b[i]*a[i];
		DFT(b,tn<<1,-1);
		rep(i,m-1,n-1)
ans=(((ans*W+pre[i+1]-pre[i+1-m]+P)%P-2*(LL)(b[i].re+0.5)%P)%P+cnt)%P;
		//rep(i,0,tn<<1) ans-=2*(LL)(b[i].re+0.5);
		printf("%lld\n",ans);
		rep(i,0,tn<<1) b[i]=complex(0,0);
	}
}
