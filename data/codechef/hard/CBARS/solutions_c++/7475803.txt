#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

using namespace std;

#define pb push_back
#define mp make_pair

#define ALL(x) (x).begin(),(x).end()
#define CLR(a,b) memset(a,b,sizeof(a))
#define REPN(x,a,b) for (int x=a; x<b;++x)
#define REP(x,b) REPN(x, 0, b)
#define forit(i,c) for (typeof((c).end()) i=(c).begin();i!=(c).end(); ++i)

#define dbg(x) cout << #x << " = " << x << endl;
#define dbg2(x, y) cout << #x << " = " << x << "  " << #y << " = " << y << endl;
#define dbg3(x, y, z) cout << #x << " = " << x << "  " << #y << " = " << y << "  " << #z << " = " << z << endl;
#define dbg4(x, y, z, w) cout << #x << " = " << x << "  " << #y << " = " << y << "  " << #z << " = " << z << "  " << #w << " = " << w <<  endl

typedef unsigned long long ll;

const ll MOD = 1000000007;

ll a, b;
vector <int> G[100];

struct Matrix {
    ll M[32][32];

    Matrix operator*(Matrix A) {
        Matrix ret;
        CLR(ret.M, 0);
        REP(k, 32) REP(i, 32) REP(j, 32) {
            ret.M[i][j] += M[i][k] * A.M[k][j];
            ret.M[i][j] %= MOD;
        }
        return ret;
    }

    Matrix pow(ll a) {
        Matrix ret, act;
        CLR(ret.M, 0);
        REP(i, 32) ret.M[i][i] = 1;
        act = *this;
        while (a) {
            if (a & 1) ret = ret * act;
            act = act * act;
            a >>= 1;
        }
        return ret;
    }
};

bool valid (int u, int v, int n) {
    for (int i = 0; i < n-1; i++) {
        int cnt = 0;
        for (int j = 0; j < 2; j++) {
            if (1<<(i + j) & u) cnt++;
            if (1<<(i + j) & v) cnt++;
        }
        if (cnt == 4 || cnt == 0) return false;
    }
    return true;
}

int main() {
    
    cin >> a >> b;
    if (b == 1) {
        cout << (1<<a) << endl;
        return 0;
    }
    if (a == 1) {
        ll ans = 1;
        a = 2;
        while (b) {
            if (b & 1) ans *= a, ans %= MOD;
            a *= a;
            a %= MOD;
            b >>= 1;
        }
        cout << ans << endl;
        return 0;
    }
    int n = (1<<a);
    for (int t = 0; t < n; t++) {
        G[t].clear();
        int c = 0;
        for (int k = 0; k < n; k++) {
            if (valid(t, k, a)) {
                G[t].pb(k);
            }
        }
    }

    Matrix Mat, res;
    CLR(Mat.M, 0);


    REP(u, n) {
        REP(j, G[u].size()) {
            int v = G[u][j]; // u = 0 -> v = 1
            if (v < n/2) {
                int uu = u;
                if (u >= n/2) uu = n - u - 1;
                Mat.M[v][uu]++;
            }
        }
    }

    res = Mat.pow(b-1);
    ll sum = 0;
    REP(i, 32) REP(j, 32) sum += res.M[i][j]*2, sum %= MOD;

    cout << sum << endl;

    return 0;
}


