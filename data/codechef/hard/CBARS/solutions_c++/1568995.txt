#include<stdio.h>
#include<iostream>
#include<memory.h>
#define N 70
#define CLR(a,x) memset(a,x,sizeof(a))
#define llu long long unsigned int
#define ll long long unsigned int
#define Mi 1000000007
using namespace std;

class TMatr
{
	public:
	int n;
	llu A[N][N];
	TMatr operator * (TMatr b);
	
};

TMatr res;

TMatr TMatr::operator * (TMatr b)
{
	
	res.n=n;
	for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++){
            res.A[i][j] = 0;
            for (int k = 0; k < n; k++)
                res.A[i][j] = (res.A[i][j] + (this->A[i][k] * b.A[k][j]) % Mi) % Mi;  
        }
    return res;
}

bool bit[4];
bool CanGo (int mask1, int mask2, int len)
{
    for (int i = 0; i < len - 1; i++)
    {
        bit[0] = (mask1 >> i) & 1;
       
        bit[1] = (mask1 >> (i + 1)) & 1;
        bit[2] = (mask2 >> i) & 1;
        bit[3] = (mask2 >> (i + 1)) & 1;
        if (bit[0] && bit[1] && bit[2] && bit[3]) return false; 
        if (!bit[0] && !bit[1] && !bit[2] && !bit[3]) return false;
    }
    return true;
}










TMatr A;
TMatr B;
int n;
ll m;

int main ()
{
    //freopen ("input.txt", "r", stdin);
    //freopen ("output.txt", "w", stdout);
    cin >> n >> m;
    //assert (n >= 1 && n <= 6);
    //assert (m >= 1 && m < (1LL << 63));
    int k = 1 << n;
    A.n = k;
    for (int m1 = 0; m1 < k; m1++)
        for (int m2 = 0; m2 < k; m2++)
            A.A[m1][m2] = CanGo(m1, m2, n);//fill the matrix D. D[i][j] = true if we can put masks i and j together and false otherway
    B.n = k;
    CLR(B.A, 0);
    for (int i = 0; i < k; i++)
        B.A[i][i] = 1;//single matrix
    m--;
    //binary power
    while (m){
        if (m & 1)
            B = B * A;
        A = A * A;
        m >>= 1;
    }
    ll ans = 0;
    //answer is sum of values in all cells of result matrix
    for (int i = 0; i < k; i++)
        for (int j = 0; j < k; j++)
            ans = (ans + B.A[i][j]) % Mi;
    printf ("%d\n", ans);
    return 0;
}
