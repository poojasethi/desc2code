///===========================///
/// ///
/// ID : FlaminRage ///
/// School : JU ///
/// ///
///===========================///

#include<iostream>
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#include<ctype.h>
#include<math.h>
#include<assert.h>
#include<limits.h>
#include<float.h>
#include<string>
#include<algorithm>
#include<sstream>
#include<fstream>
#include<map>
#include<vector>
#include<queue>
#include<set>
#include<stack>
#include<list>
#include<utility>
#include<iterator>
#include<iomanip>
#include <limits>

#define S(a) scanf("%d",&a)
#define P(a) printf("%d",a)
#define PS(s) printf(s)

#define S2(a,b) scanf("%d%d",&a,&b)
#define S3(a,b,c) scanf("%d%d%d",&a,&b,&c)

#define SLL(a) scanf("%lld",&a)
#define PLL(a) printf("%lld",a)
#define SLL2(a,b) scanf("%lld%lld",&a,&b)
#define SLL3(a,b,c) scanf("%lld%lld%lld",&a,&b,&c)

#define SS(s) scanf("%s",s)

#define PCASE() printf("Case %d: ",kk++)
#define PCASENL() printf("Case %d:\n",kk++)
#define PHASH() printf("Case #%d: ",kk++)

#define NL PS("\n")

#define rep(i,a,b) for(int i=a;i<=b;i++)
#define rev(i,a,b) for(int i=a;i>=b;i--)

#define SZ(a) ((int)a.size())
#define all(a) a.begin(),a.end()
#define sorts(a) sort(all(a))
#define sorta(a,n,x) sort(a+x,a+n+x)
#define REV(a) reverse(all(a))
#define COUNTBIT(x) __builtin_popcount(x)

#define READ(f) freopen(f, "r", stdin)
#define WRITE(f) freopen(f, "w", stdout)
#define _min3(a,b,c) _min(a,_min(b,c))
#define _max3(a,b,c) _max(a,_max(b,c))
#define pb(a) push_back(a)
#define mp(a,b) make_pair(a,b)
#define pi (2*acos(0))
#define SET(a) memset(a,-1,sizeof a)
#define CLR(a) memset(a,0,sizeof a)
#define root 1

#define in(a,x,y) (a>=x && a<=y)

#define EQ(a,b) (_abs(a-b)<eps)
#define LESS(a,b) (a+eps<b)
#define GREAT(a,b) (a>b+eps)

#define DEBUG() cout<<"\nPASS "<<_DB++<<"\n\n"

using namespace std;

int ts,kk=1,_DB=1;

inline int LEN(string a) {return a.length();}
inline int LEN(char a[]) {return strlen(a);}

typedef long long LL;
typedef unsigned long long ULL;

typedef vector<int> vi;
typedef vector<LL> vLL;
typedef vector<string> vst;
typedef pair<int,int> pii;
typedef pair<LL,LL> pLL;
typedef pair<string,int> psi;
typedef vector<pii> vii;

template< class T > inline T _abs(T n) { return (n < 0 ? -n : n); }
template< class T > inline T _max(T a, T b) { return (a > b ? a : b); }
template< class T > inline T _min(T a, T b) { return (a < b ? a : b); }
template< class T > inline T _sq(T x) { return x * x; }
template< class T > inline T _sqrt(T x) { return (T) sqrt( (double) x); }
template< class T > inline T _pow(T x,T y) {T z=1; rep(i,1,y){z*=x;} return z; }
template< class T > inline T _gcd(T x,T y) {x=_abs(x);y=_abs(y);T z; while(x%y){ z=x%y; x=y; y=z; } return z;}
template< class T > inline T _lcm(T x,T y) {x=_abs(x);y=_abs(y); return (x/_gcd(x*y))*y;}
template< class T > inline T GETBIT(T x,T i) { T t=1;return (x&(t<<i)); }
template< class T > inline T SETBIT(T x,T i) { T t=1;return (x|(t<<i)); }
template< class T > inline T RESETBIT(T x,T i) { T t=1;return (x&(~(t<<i))); }

///===========================///
/// //CONSTANT// ///
/// power 0123456789 ///
#define MX ( 100 + 5 )

#define MOD 1000000007

#define inval 1000000005

#define inf 2000000000

#define eps 1e-9
/// ///
///===========================///

template< class T > inline T _bigmod(T n,T m) {T ans=1,mult=n%MOD; while(m){ if(m & 1) ans=(ans*mult)%MOD; m>>=1; mult=(mult*mult)%MOD; } ans%=MOD; return ans;}

template< class T > inline T _modinv(T x) {return _bigmod(x,(T) MOD-2)%MOD;}

///===============///
///End of template///
///===============///

struct matrix
{
int row,col;
LL cell[MX][MX];
};

matrix res,base,mat,ID;

LL W,L,wid;

int sz;

matrix mult(matrix a,matrix b)
{
matrix temp;
temp.row=a.row;
temp.col=b.col;

rep(i,0,a.row-1)
{
rep(j,0,b.col-1)
{
LL sum=0;
rep(k,0,a.col-1)
{
sum=(sum + (a.cell[i][k]*b.cell[k][j])%MOD)%MOD;
}
temp.cell[i][j]=sum;
}
}
return temp;
}

matrix mat_expo(matrix a,LL n)
{
matrix ret=ID;
while(n)
{
if(n&1) ret=mult(ret,a);
n>>=1;
a=mult(a,a);
}
return ret;
}

int main()
{
SLL2(W,L);

if(W>L) swap(W,L);

wid=W;

sz=1<<wid;

rep(i,0,sz-1)
rep(j,0,sz-1)
{
res.cell[i][j]=mat.cell[i][j]=ID.cell[i][j]=0;
if(i==j) ID.cell[i][j]=1;
}

base.row=base.col=ID.row=ID.col=mat.row=res.row=sz;
mat.col=res.col=1;

rep(i,0,sz-1)
{
rep(j,i,sz-1)
{
int previ,prevj,ti,tj,consi,consj;
previ=prevj=-1;
consi=consj=0;

bool chk=true;

rep(k,0,wid-1)
{
ti=tj=0;

if(GETBIT(i,k)) ti=1;

if(ti==previ) consi++;
else consi=1;

if(GETBIT(j,k)) tj=1;

if(tj==prevj) consj++;
else consj=1;

if(consi>1 && consj>1 && ti==tj) {chk=false;break;}

previ=ti;
prevj=tj;
}
base.cell[i][j]=base.cell[j][i]=chk;
}
mat.cell[i][0]=1;
}

LL ans=0;

matrix A;
A=mat_expo(base,L-1);
res=mult(A,mat);

rep(i,0,res.row-1)
ans=(ans+res.cell[i][0])%MOD;

PLL(ans); NL;
return 0;
}
