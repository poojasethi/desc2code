#pragma comment(linker, "/stack:100000000")

#include <cstdio>
#include <iostream>
#include <vector>
#include <set>
#include <map>
#include <algorithm>
#include <cstring>
#include <string>
#include <cmath>
#include <ctime>
#include <cassert>
#include <queue>

using namespace std;

#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)
#define sz(v) (int)(v).size()
#define all(v) (v).begin(), (v).end()

const int MOD = 1000000007;
const int N = 1 << 6;

long long M[N][N], R[N][N], T[N][N]; 
int n;

int get(int x, int k) {
	if (x & (1 << k)) return 1;
	else return 0;
}

void matrix_mult(long long A[N][N], long long B[N][N], long long C[N][N]) {
	REP(i, n) REP(j, n) C[i][j] = 0;
	REP(i, n) REP(j, n) REP(k, n) {
		C[i][j] += A[i][k] * B[k][j];
		C[i][j] %= MOD;
	}
}

void matrix_pow(long long p) {
	if (p == 0) {
		REP(i, n) REP(j, n) {
			if (i == j) {
				R[i][j] = 1;
			} else {
				R[i][j] = 0;
			}
		}
	} else if (p % 2 == 0) {
		matrix_pow(p / 2);
		matrix_mult(R, R, T);
		REP(i, n) REP(j, n) R[i][j] = T[i][j];
	} else {
		matrix_pow(p - 1);
		matrix_mult(M, R, T);
		REP(i, n) REP(j, n) R[i][j] = T[i][j];
	}
}

int main() {
#ifdef LOCAL
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);
#endif
	int n;
	long long m;
	cin >> n >> m;
	REP(i, 1 << n) REP(j, 1 << n) {
		M[i][j] = 1;
		REP(k, n - 1) {
			int v = get(i, k) + get(i, k + 1) + get(j, k) + get(j, k + 1);
			if (v == 0 || v == 4) {
				M[i][j] = 0;
				break;
			}
		}
	}
	::n = 1 << n;
	matrix_pow(m - 1);
	int res = 0;
	REP(i, ::n) REP(j, ::n) {
		res += R[i][j];
		res %= MOD;
	}
	printf("%d\n", res);
	return 0;
}