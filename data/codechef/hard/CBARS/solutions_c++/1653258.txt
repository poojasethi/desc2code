#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long ll;
const int kMod = 1000000007;
const int kSize = 64;
int a, s;
ll b;

#define UPT(x, y) { \
	(x) += (y); \
	if ((x) >= kMod) (x) -= kMod; \
}

struct Matrix {
	int v[kSize][kSize];
	void clear() {
		memset(v, 0, sizeof(v));
	}
	Matrix() {
		clear();
	}
} e, f, t;

Matrix operator * (const Matrix &a, const Matrix &b) {
	Matrix c;
	for (int i = 0; i < s; ++ i)
		for (int k = 0; k < s; ++ k)
			if (a.v[i][k])
				for (int j = 0; j < s; ++ j)
					UPT(c.v[i][j], (ll)a.v[i][k] * b.v[k][j] % kMod);
	return c;
}

Matrix Power(const Matrix &a, ll b) {
	Matrix res = e, tmp = a;
	while (b) {
		if (b & 1) res = res * tmp;
		b >>= 1;
		tmp = tmp * tmp;
	}
	return res;
}

bool Can(int p, int q) {
	for (int i = 0; i < a - 1; ++ i) {
		int j = i + 1;
		int ii = (p >> i & 1) + (p >> j & 1);
		int jj = (q >> i & 1) + (q >> j & 1);
		if (ii == 2 && jj == 2) return false;
		if (ii == 0 && jj == 0) return false;
	}
	return true;
}

int main() {
	scanf("%d%lld", &a, &b);
	s = 1 << a;
	for (int i = 0; i < s; ++ i) e.v[i][i] = 1;
	for (int i = 0; i < s; ++ i) t.v[i][0] = 1;
	for (int i = 0; i < s; ++ i)
		for (int j = 0; j < s; ++ j)
			if (Can(i, j)) ++ f.v[j][i];
	t = Power(f, b - 1) * t;
	int res = 0;
	for (int i = 0; i < s; ++ i) UPT(res, t.v[i][0]);
	printf("%d\n", res);
	return 0;
}