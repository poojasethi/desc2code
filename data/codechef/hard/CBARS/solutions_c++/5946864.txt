/*
***************************************************************************************************************

							Author : Yash Sadhwani

**************************************************************************************************************
*/
#include<stdio.h>
#include<iostream>
#include<vector>
#include<string.h>
#include<algorithm>
#include<deque>
#include<map>
#include<set>
#include<stdlib.h>
#include<math.h>
#include<queue>
#include<functional>
using namespace std;
#define ll long long
#define si(x) scanf("%d",&x)
#define sl(x) scanf("%lld",&x)
#define sc(x) scanf("%c",&x)
#define vl vector<ll>
#define vi vector<int>
#define vvl vector< vl >
#define vvi vector< vi >
#define pb push_back
#define mod 1000000007
#define mem(x,y) memset(x,y,sizeof(x))
#define f(i,a,b) for(int i=(a);i<(b);i++)
#define max_int_value 2147483647
#define max_long_value 9223372036854775807


//thanks to Vinay Guthal(win_ay) for the below fast IO functions
#define llu long long unsigned
#define ld long
#define F first
#define S second
int scan_d()    {int ip=getchar_unlocked(),ret=0,flag=1;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;}
ld scan_ld()    {int ip=getchar_unlocked(),flag=1;ld ret=0;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;}
ll scan_ll()    {int ip=getchar_unlocked(),flag=1;ll ret=0;for(;ip<'0'||ip>'9';ip=getchar_unlocked())if(ip=='-'){flag=-1;ip=getchar_unlocked();break;}for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return flag*ret;}
llu scan_llu()    {int ip=getchar_unlocked();llu ret=0;for(;ip<'0'||ip>'9';ip=getchar_unlocked());for(;ip>='0'&&ip<='9';ip=getchar_unlocked())ret=ret*10+ip-'0';return ret;}
 
//end of fast input
//fast output
 
//no line break
void print_d(int n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=10;char output_buffer[10];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<10);}
void print_ld(ld n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=11;char output_buffer[11];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<11);}
void print_ll(ll n)     {if(n<0){n=-n;putchar_unlocked('-');}int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<21);}
void print_llu(llu n)     {int i=21;char output_buffer[21];do{output_buffer[--i]=(n%10)+'0';n/=10;}while(n);do{putchar_unlocked(output_buffer[i]);}while(++i<21);}


//qsort(ww,cc,sizeof(tp),compare);
/*int compare(const void *a,const void *b){
	ll y=((((tp*)a)->w)-(((tp*)b)->w));
	if(y>0)return 1;
	else if(y==0)return 0;
	else return -1;
}
bool way(ii x,ii y){
	return x.first<y.first or x.first==y.first and x.second<y.second;
}
*/


#define MAXN 100010
#define ls (node<<1)
#define rs ((node<<1)+1)

struct matrix{
	ll mat[65][65];
};


int max_mask;

matrix mul(matrix A,matrix B){
	matrix ret;
	for(int i=0;i<=max_mask;i++){
		for(int j=0;j<=max_mask;j++){
			ret.mat[i][j]=0;
			for(int k=0;k<=max_mask;k++){
				ret.mat[i][j]+=(A.mat[i][k]*B.mat[k][j]);
				ret.mat[i][j]%=mod;
			}
		}
	}
	return ret;
}

matrix pow(matrix A,ll p){
	if(p==1)return A;
	matrix ret=pow(A,p/2);
	ret=mul(ret,ret);
	if(p&1)return mul(ret,A);
	return ret;
}

ll aa;

bool check(int mask1,int mask2){
	for(int i=0;i<aa;i++){
		int a,b,c,d;
		if(mask1&(1<<i))a=1;
		else a=0;
		if(mask2&(1<<i))b=1;
		else b=0;
		if(mask1&(1<<(i+1)))c=1;
		else c=0;
		if(mask2&(1<<(i+1)))d=1;
		else d=0;
        //if(mask1==0 and mask2==1)cout<<a<<" "<<b<<" "<<c<<" "<<d<<endl;
		if(a==b && c==d && a==c)return false;
	}
	return true;
}

matrix transtion;


inline void CreateTransitionMatrix(void){
	for(int i=0;i<=63;i++)for(int j=0;j<=63;j++)transtion.mat[i][j]=0;
	for(int mask1=0;mask1<=max_mask;mask1++){
		for(int mask2=0;mask2<=max_mask;mask2++){
			if(check(mask1,mask2))transtion.mat[mask1][mask2]++;
		}
	}
}

ll a,b;

inline void ReadInput(void){
	a=scan_ll(); b=scan_ll();
}

inline void solve(void){
	if(b==1){
		printf("%d\n",(1<<a) );
		return;
	}
	int limits=(1<<a)-1;
	max_mask=limits;
	aa=a-1;
	CreateTransitionMatrix();
    //cout<<limits<<endl;
	ll ans=0;
	matrix ret=pow(transtion,b-1);
    /*for(int i=0;i<=limits;i++){
        for(int j=0;j<=limits;j++)cout<<ret.mat[i][j]<<" ";
        cout<<endl;
    }*/
	for(int i=0;i<=limits;i++){
		for(int j=0;j<=limits;j++){
			ans+=(ret.mat[i][j]);
			ans%=mod;
		}
	}
	printf("%lld\n",ans );
}

inline void Refresh(void){

}

int main()
{
    ios_base::sync_with_stdio(false);
   	ReadInput();
    solve();
	return 0;
}