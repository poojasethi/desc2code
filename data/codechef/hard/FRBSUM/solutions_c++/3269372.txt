//Solution by Daniyar Maminov                                                                                                                                                                     
#include<iostream>
#include<fstream>
#include<string>
#include<algorithm>
#include<math.h>
#include<vector>
#include<cstring>
#include<queue>
#include<map>
#include<set>
#define mp make_pair
#define f first
#define pb push_back
#define s second
#define ub upper_bound
#define lb lower_bound
#define inf 1000*1000*1000
using namespace std;

vector <int> a;

struct po
{
	int l, r, x;
}t[5555555];

int n, i, j, k, x, v, sz, pr, l, r, m, s, new_s;

const int N = (1<<30);

int upd(int x, int v, int tl=1, int tr=N)
{
	if (tl==tr)
	{
		sz++;
		t[sz].x=t[v].x+x;
		return sz;
	}
	int tm=(tl+tr)>>1;
	if (x<=tm)
	{
		if (!t[v].l)
		{
			sz++;
			t[v].l=sz;
		}
		pr=upd(x, t[v].l, tl, tm);
		sz++;
		t[sz].r=t[v].r;
		t[sz].l=pr;
		t[sz].x=0;
		if (t[sz].l) t[sz].x+=t[t[sz].l].x;
		if (t[sz].r) t[sz].x+=t[t[sz].r].x;
		return sz;
	}
	else
	{
		if (!t[v].r)
		{
			sz++;
			t[v].r=sz;
		}
		pr=upd(x, t[v].r, tm+1, tr);
		sz++;
		t[sz].r=pr;
		t[sz].l=t[v].l;
		t[sz].x=0;
		if (t[sz].l) t[sz].x+=t[t[sz].l].x;
		if (t[sz].r) t[sz].x+=t[t[sz].r].x;
		return sz;
	}
}

int sum(int v, int l, int r, int tl=1, int tr=N)
{
	if (!v || l>r || tl>r || l>tr) return 0;
	if (l<=tl && tr<=r)
		return t[v].x;
	int tm=(tl+tr)>>1;
	return sum(t[v].l, l, r, tl, tm)+sum(t[v].r, l, r, tm+1, tr);
}

int main()
{
	#ifndef ONLINE_JUDGE
	freopen (".in","r",stdin);
	freopen (".out","w",stdout);
	#endif
	sz=1;
	a.pb(1);
	cin>>n;
	for (i=1; i<=n; i++)
	{	
		scanf("%d", &x);
		a.pb(upd(x, a[i-1]));
	}
	cin>>m;
	for (i=1; i<=m; i++)
	{	
		scanf("%d%d", &l, &r);
		s=0;
		while (1)
		{
			new_s=sum(a[r], 0, s+1)-sum(a[l-1], 0, s+1);
			if (s==new_s) break;
			s=new_s;
		}
		printf("%d\n", s+1);
	}



	return 0;
}