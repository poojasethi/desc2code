/*Finds sum in l--->r for all elements less than x
 *  Time complexity:O(log^2n) Space Complexity:O(nlogn)*/

#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define mp make_pair
#define clr(x) x.clear()
#define For(i,a,b) for(i=a;i<b;i++)
#define loop(i,b) for(i=0;i<b;i++)
#define Loop(i,b) for(i=1;i<=b;i++)
#define pi(n) printf("%d ",n)
#define si(n) scanf("%d",&n)
typedef long long LL;
const int MOD=1e9+7;
typedef pair<LL,LL> PII;
typedef vector<PII> VPII;
typedef vector<int> VI;
#define F first
#define S second
#define sz size
#define pLL(x) cout<<x<<' '
#define fill(x,c) memset(x,c,sizeof(x))
#define DB(x)              cerr<<__LINE__<<" :: "<<#x<< ": "<<x<<endl;
#define DB2(x, y)          cerr<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<endl;
#define DB3(x, y, z)       cerr<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<" | "<<#z<<": "<<z<<endl

const int N=1e5+5;
const int INF=1e9;
int baseArray[N];
int n;
/*void print(VI aa)
{
	int i,l=aa.sz();
	loop(i,l)
		DB(i);
}*/

typedef struct node
{
	VI sorted_array;
	vector<LL> prefix_sum;
	void merge(node &l,node &r)
	{

		
		int i;int j;
		i=0;
		j=0;
		int l1=l.sorted_array.sz();
		int l2=r.sorted_array.sz();
		int c=0;
		while(i<l1 && j<l2)
		{
		if(l.sorted_array[i]<=r.sorted_array[j])
			sorted_array.pb(l.sorted_array[i++]);
		else
			sorted_array.pb(r.sorted_array[j++]);
		}

		while(i<l1)
			sorted_array.pb(l.sorted_array[i++]);
		while(j<l2)
			sorted_array.pb(r.sorted_array[j++]);
		prefix_sum.pb(sorted_array[0]);
		l1=l1+l2;
		c=0;
		for(i=1;i<l1;++i)
			prefix_sum.pb(prefix_sum[i-1]+sorted_array[i]);
	//	print(prefix_sum);
		//DB("MERGED");
		
	}


	


	void print(vector<LL> aa)
	{
	int i,l=aa.sz();
	loop(i,l)
		DB(aa[i]);
		//DB2(segmentSum,bestPrefix);
		//DB2(bestSuffix,bestSum);
	}

	

}node;

node st[3*N];
struct node createLeaf(int val)
{
	        node n;
		n.sorted_array.pb(val);
		n.prefix_sum.pb(val);
		//DB(val);
		return n;
}
/*node my_copy(node n)
{
	node n1;
	n1.bestSum=n.bestSum;
	n1.bestPrefix=n.bestPrefix;
	n1.bestSuffix=n.bestSuffix;
	n1.segmentSum=n.segmentSum;
	return n1;
}*/

// sum of x<=val in l-r
void make_tree(int current,int s,int e)
{
	if(s == e-1)
	{
		st[current]=createLeaf(baseArray[s]);
		//DB(st[current].bestSum);
		return ;
	}

	int c1=current*2;
	int c2=c1+1;
	int m=(s+e)/2;
	make_tree(c1,s,m);
	make_tree(c2,m,e);
	st[current].merge(st[c1],st[c2]);
}
void update_tree(int curr,int s,int e,int x,int val)
{
	if(x<s || x>=e)
		return ;
	if(s == x && s == e-1)   //leaf node
	{
		st[curr]=createLeaf(val);
//		st[curr].S+=depth[s]*val;
		return ;
	}

	int left=curr*2;
	int right=left+1;
	int mid=(s+e)/2;
	update_tree(left,s,mid,x,val);
	update_tree(right,mid,e,x,val);

	st[curr].merge(st[left],st[right]);
	//DB(curr)
	//st[curr].print();
	

}
void update(int i,int val)
{
	//DB(posInBase[i])
	update_tree(1,0,n,i,val);
}

LL query_tree(int curr,int s,int e,int ql,int qr,LL val)
{
	LL res=0;
	if(qr<s || ql>=e)
	{
		//qt[curr]=createLeaf(0);
		return 0;
	}

	if(s >= ql && e-1<=qr)
	{
		int idx=upper_bound(st[curr].sorted_array.begin(),st[curr].sorted_array.end(),val)-st[curr].sorted_array.begin();
		idx--;
		if(idx<0)
			return 0;
		res= st[curr].prefix_sum[idx];
		//DB(res);
		return res;
		

	}

	int c1=curr*2;
	int c2=c1+1;
	int mid=(s+e)/2;
	res+=query_tree(c1,s,mid,ql,qr,val);
	res+=query_tree(c2,mid,e,ql,qr,val);
	//qt[curr].merge(qt[c1],qt[c2]);
	return res;
}

LL query(int x,int y,int val)
{


	return query_tree(1,0,n,x,y,(LL)val);
//	cout<<qt[1].sum<<endl;
}

int main()
{
	int i,j,q,x,y,type;
	si(n);
	loop(i,n)
		si(baseArray[i]);
	
	si(q);
	int val;
	make_tree(1,0,n);
	//DB("CREATED");
	//DB(n);
	while(q--)
	{
		//si(type);
		si(x);
		si(y);
		x--;
		y--;
	//	si(val);

		LL S=0,newS;
		while(1)
		{
			 newS=query(x,y,S+1);
			if(S == newS)
				break;
			S=newS;
		}

		printf("%lld\n",S+1);
		
	
	}


	return 0;
}

