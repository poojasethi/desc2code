#undef _GLIBCXX_DEBUG

#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <ctime>
#include <iomanip>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <valarray>
#include <vector>

using namespace std;

#define foreach(iter,cont) for(typeof((cont).begin()) iter = (cont).begin(); iter != (cont).end(); ++iter)
#define min3(a, b, c) min(a, min(b, c))
#define max3(a, b, c) max(a, max(b, c))
#define inf 1000000008
#define eps 1.0e-10L
#define divisible(a, b) (((a) / (b)) * (b) == (a))
//static const long long p = 1000000007;
__attribute__((unused)) static bool eq(long double a, long double b)  { return (a == b ? true : (a * b == 0 ? abs(a - b) < eps : abs(a - b) / (abs(a) + abs(b)) < eps));  }
__attribute__((unused)) static long long modp(long long n, long long m) { long long r = n % m; return r >= 0 ? r : r + m; }
__attribute__((unused)) static long long gcd(long long a, long long b) { return (a < 0 ? gcd(-a, b) : (b < 0 ? gcd(a, -b) : (!a && !b ? 1 : (b ? gcd(b, a % b) : a)))); }
template<class T> static int len(const T& cont) { return (int) cont.size(); }

// BEGIN CUT HERE
template<class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << "(" << p.first << ", " << p.second << ")"; }
template<class T> ostream &operator<<(ostream& os, const vector<T> &vec) { os << "[ "; for(size_t i = 0; i < vec.size(); i++) { os << vec[i]; if(i != vec.size() - 1) { os << ", "; } } return os << " ]"; }
template<class T> ostream &operator<<(ostream& os, const list<T> &l) { os << "[ "; bool first = true; for(typename list<T>::const_iterator lstIt = l.begin(); lstIt != l.end(); ++lstIt) { if(!first) { os << ", "; } first = false; os << *lstIt; } return os << " ]"; }
template<class T> ostream &operator<<(ostream& os, const deque<T> &d) { os << "[ "; bool first = true; for(typename deque<T>::const_iterator dIt = d.begin(); dIt != d.end(); ++dIt) { if(!first) { os << ", "; } first = false; os << *dIt; } return os << " ]"; }
template<class T> ostream &operator<<(ostream& os, const vector<vector<T> > &mat) { for(size_t i = 0; i < mat.size(); i++) { if(i) os << endl; os << mat[i]; } return os; }
template<class T> ostream &operator<<(ostream &os, const set<T> &s) { os << "{ "; bool first = true; for(typename set<T>::const_iterator setIt = s.begin(); setIt != s.end(); ++setIt) { if(!first) { os << ", "; } first = false; os << *setIt; } return os << " }"; }
template<class T, class U> ostream &operator<<(ostream &os, const map<T, U> &m) { os << "{ "; bool first = true; for(typename map<T, U>::const_iterator mapIt = m.begin(); mapIt != m.end(); ++mapIt) { if(!first) { os << ", "; } first = false; os << mapIt->first << " = " << mapIt->second; } return os << " }"; }
enum CONSOLE_FG { FG_BLACK, FG_RED, FG_GREEN, FG_YELLOW, FG_BLUE, FG_MAGENTA, FG_CYAN, FG_WHITE };
enum CONSOLE_STYLE { STYLE_NONE, STYLE_BOLD };
ostream& operator<<(ostream &os, CONSOLE_FG color) { return os << "\x1b[" << ((int) color + 30) << "m"; }
ostream& operator<<(ostream &os, CONSOLE_STYLE style) { return os << "\x1b[" << (style == STYLE_NONE ? 0 : 1) << "m"; }
// END CUT HERE

int n, m, l, r, nums[100000], curN;

struct STChange {
	STChange() { }

	// A change to be applied, contents will be problem-specific
};

struct STNode {
	// Contents here will be problem-dependent
	int *vals, *sums, numSums, l, r;
};

struct STQueryResult {
	// Contents here will be problem-dependent
	int ans;
};

// Initialize the node as representing the given index
void init(STNode &node, __attribute__((unused)) int idx) {
	node.vals = new int[1];
	node.sums = new int[1];

	node.vals[0] = nums[idx];
	node.sums[0] = nums[idx];

	node.l = idx;
	node.r = idx + 1;
}

// Completely combine to existing nodes to create a new persistent node
void combine(STNode &node, const STNode &left, const STNode &right) {
	node.l = left.l;
	node.r = right.r;

	int *n = new int[node.r - node.l];
	memcpy(n, nums + node.l, (node.r - node.l) * sizeof(int));
	sort(n, n + (node.r - node.l));
	int total = 0;

	if(node.vals) {
		delete[] node.vals;
	}

	if(node.sums) {
		delete[] node.sums;
	}

	node.vals = new int[node.r - node.l];
	node.sums = new int[node.r - node.l];

	node.numSums = 0;
	for(int i = 0; i < (node.r - node.l); i++) {
		total += n[i];

		if(i > 0 && n[i] == n[i - 1]) {
			node.sums[node.numSums - 1] += n[i];
		} else {
			node.vals[node.numSums] = n[i];
			node.sums[node.numSums] = total;
			node.numSums++;
		}
	}

	delete[] n;
}

// Add a new change onto an existing change
void addChange(STChange &change, const STChange &newChange) {
}

// Are the two changes equivalent?
bool changeEquivalent(const STChange &a, const STChange &b) {
	return true;
}

// Does this change affect results?
bool emptyChange(const STChange &change) {
	return true;
}

// Apply the given change to the given node, update the change to reflect its
// new status
void applyChange(STNode &node, const STChange &change) {
}

// Clear a change
void clearChange(STChange &change) {
}

// Build a query result from a single node
void initResult(STQueryResult &result, const STNode &node) {
	int low = 0;
	int high = node.numSums;

	while(low < high - 1) {
		int m = (low + high) / 2;
		if(node.vals[m] <= curN + 1) {
			low = m;
		} else {
			high = m;
		}
	}

	if(low < node.r && node.vals[low] <= curN + 1) {
		result.ans = node.sums[low];
	} else {
		result.ans = 0;
	}
}

 // Combine the results from b into a
 void combineResults(STQueryResult &a, const STQueryResult &b) {
	 a.ans += b.ans;
 }

 struct SegTree {
	 SegTree(int n) {
		 int curN = n;
		 int logN = 0;
		 while(curN > 1) {
			 logN++;
			 curN /= 2;
		 }

		 nodes = new STNode[1 << (logN + 2)];
		 changes = new STChange[1 << (logN + 2)];
		 dirty = new bool[1 << (logN + 2)];
		 needsComb = new bool[1 << (logN + 2)];

		 fill_n(nodes, 1 << (logN + 2), STNode());
		 fill_n(changes, 1 << (logN + 2), STChange());
		 fill_n(dirty, 1 << (logN + 2), false);
		 fill_n(needsComb, 1 << (logN + 2), false);

		 stInit(0, 0, n);
	 }

	 void changeRange(int l, int r, const STChange &change) {
		 stPushChange(0, 0, n, l, r, change);
	 }

	 STQueryResult queryRange(int l, int r) {
		 return stQuery(0, 0, n, l, r);
	 }

 private:
	 void stInit(int nodeIdx, int l, int r) {
		 if(r == l + 1) {
			 init(nodes[nodeIdx], l);
		 } else {
			 int m = (l + r) / 2;
			 stInit(2 * nodeIdx + 1, l, m);
			 stInit(2 * nodeIdx + 2, m, r);

			 combine(nodes[nodeIdx], nodes[2 * nodeIdx + 1], nodes[2 * nodeIdx + 2]);
		 }
		 clearChange(changes[nodeIdx]);
	 };

	 void eval(int nodeIdx, int l, int r, bool apply = true) {
		 if(!emptyChange(changes[nodeIdx])) {
			 applyChange(nodes[nodeIdx], changes[nodeIdx]);

			 if(r > l + 1) {
				 addChange(changes[2 * nodeIdx + 1], changes[nodeIdx]);
				 addChange(changes[2 * nodeIdx + 2], changes[nodeIdx]);
			 }

			 clearChange(changes[nodeIdx]);
		 }
	 }

	 void stPushChange(int nodeIdx, int l, int r, int changeL, int changeR, const STChange &change) {
		 if(l >= changeL && r <= changeR) {
			 addChange(changes[nodeIdx], change);
			 eval(nodeIdx, l, r);
		 } else {
			 eval(nodeIdx, l, r, false);

			 int m = (l + r) / 2;
			 if(m > changeL) {
				 stPushChange(2 * nodeIdx + 1, l, m, changeL, changeR, change);
				 eval(2 * nodeIdx + 2, m, r);
			 } 

			 if(m < changeR) {
				 stPushChange(2 * nodeIdx + 2, m, r, changeL, changeR, change);
				 eval(2 * nodeIdx + 1, l, m);
			 }

			 combine(nodes[nodeIdx], nodes[2 * nodeIdx + 1], nodes[2 * nodeIdx + 2]);
		 }
	 }

	 STQueryResult stQuery(int nodeIdx, int l, int r, int queryL, int queryR) {
		 int m = (l + r) / 2;

		 eval(nodeIdx, l, r);

		 if(l >= queryL && r <= queryR) {
			 STQueryResult res;
			 initResult(res, nodes[nodeIdx]);
			 return res;
		 } else {
			 bool lOverlaps = m > queryL;
			 bool rOverlaps = m < queryR;

			 if(lOverlaps && !rOverlaps) {
				 return stQuery(2 * nodeIdx + 1, l, m, queryL, queryR);
			 } else if(rOverlaps && !lOverlaps) {
				 return stQuery(2 * nodeIdx + 2, m, r, queryL, queryR);
			 } else {
				 STQueryResult res = stQuery(2 * nodeIdx + 1, l, m, queryL, queryR);
				 combineResults(res, stQuery(2 * nodeIdx + 2, m, r, queryL, queryR));
				 return res;
			 }
		 }
	 }

	 STNode *nodes;
	 STChange *changes;
	 bool *dirty, *needsComb;
};
//#define BRUTE

int main(__attribute__((unused)) int argc, __attribute__((unused)) char **argv) {
	scanf("%d", &n);
	for(int i = 0; i < n; i++) {
		scanf("%d", &nums[i]);
	}

	SegTree st(n);
	//st.queryRange(0, n, -1);

	scanf("%d", &m);

	for(int q = 0; q < m; q++) {
		scanf("%d %d", &l, &r);

#ifdef BRUTE
		printf("%d\n", brute(l, r));
#else
		curN = 0;
		while(true) {
			int ans = st.queryRange(l - 1, r).ans;

			if(ans == curN) {
				break;
			} else {
				curN = ans;
			}
		}
		printf("%d\n", curN + 1);
#endif
	}

	return 0;
}
