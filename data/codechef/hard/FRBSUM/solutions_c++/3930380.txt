#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

#define REP0(i, n) for (int i = 0; i < n; i++)
#define REP1(i, n) for (int i = 1; i <= n; i++)
#define REP(i, l, r) for (int i = l; i <= r; i++)
#define RP(i, r, l) for (int i = r; i >= l; i--)
#define FORE(i, x) for (int i = fi[x]; i != -1; i = e[i].n)

#define MAX_N 110000
#define MAX_M 2100000
#define A first
#define B second
#define MP make_pair
typedef pair < int, int > PT;

typedef struct node* ntp;
struct node { ntp lc, rc; int s; } ua[MAX_M];
PT b[MAX_N]; ntp rt[MAX_N], ta = ua;
int a[MAX_N];
int n, m;

ntp ins(ntp u, int x, int y, int l = 1, int r = n)
{
    ntp v = ++ta; if (u) *v = *u; v->s += y;
	if (l == r) return v;
	int mid = (l + r) >> 1;
	if (x <= mid) v->lc = ins(v->lc, x, y, l, mid);
	else v->rc = ins(v->rc, x, y, mid + 1, r);
	return v; 
}

int query(ntp v, int x, int y, int l = 1, int r = n)
{
	if (!v) return 0;
	if (x <= l && r <= y) return v->s;
	int mid = (l + r) >> 1, t = 0;
	if (x <= mid) t = query(v->lc, x, y, l, mid);
	if (y > mid) t += query(v->rc, x, y, mid + 1, r);
	return t;
}

int get(int x)
{
	int l = 1, r = n, mid;
	while (l <= r)
	{
		  mid = (l + r) >> 1;
		  if (b[mid].A <= x) l = mid + 1;
		  else r = mid - 1;
	}
	return l - 1;
}

int solve(int x, int y)
{
	int k = 0;
	while (true)
	{
		  int cur = query(rt[get(k + 1)], x, y);
		  if (cur > k) { k = cur; continue ; }
		  else break;
	}
	return k + 1;
}

int main(void)
{
	scanf ("%d", &n); REP1(i, n) scanf ("%d", a + i), b[i] = MP(a[i], i);
	sort(b + 1, b + n + 1);  scanf ("%d", &m);
	REP1(i, n) rt[i] = ins(rt[i - 1], b[i].B, b[i].A);
	REP1(i, m)
	{
		int x, y; scanf ("%d%d", &x, &y);
		printf ("%d\n", solve(x, y));
	}
	return 0;
}
