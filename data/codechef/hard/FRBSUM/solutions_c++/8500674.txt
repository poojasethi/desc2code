#include<iostream>
#include<cstdio>
#include<algorithm>
#include<map>
#include<set>
#include<vector>
#include<cstdlib>
using namespace std;

struct node
{
int temp;
node *left,*right;
node(int temp,node *left,node *right):temp(temp),left(left),right(right){}
node* insert(int beg,int last,int x,int val);
};

int a[100007];
node *root[111111];
node *null=new node(0,NULL,NULL);
map<int,int>ma;
int maxi;
set<int>s;
vector<int>v;
node *node::insert(int beg,int last,int x,int val)
{
if(beg>x||last<x)
return this;
if(beg==last)
{
return new node(this->temp+val,null,null);
}
int mid=(beg+last)>>1;
return new node(this->temp+val,this->left->insert(beg,mid,x,val),this->right->insert(mid+1,last,x,val));
}

void maketree(int n)
{
for(set<int>::iterator j=s.begin();j!=s.end();j++)
{
ma[*j]=maxi++;
v.push_back(*j);
}
null->left=null->right=null;
root[0]=(null)->insert(0,maxi-1,ma[a[0]],a[0]);
for(int i=1;i<n;i++)
root[i]=root[i-1]->insert(0,maxi-1,ma[a[i]],a[i]);
}

int query2(node *root,int beg,int last,int p,int q)
{
if(beg>q||last<p)
return 0;
if(p<=beg&&q>=last)
return root->temp;
return (root->left?query2(root->left,beg,(beg+last)/2,p,q):0)+(root->right?query2(root->right,(beg+last)/2+1,last,p,q):0);
}

int query1(int l,int r,int n)
{
int temp1=0;
for(;;)
{
int temp3=upper_bound(v.begin(),v.end(),temp1+1)-v.begin();
temp3--;
if(temp3==-1)
return 1;
int temp2=query2(root[r],0,maxi-1,0,temp3);
temp2=temp2-(l-1>=0?query2(root[l-1],0,maxi-1,0,temp3):0);
if(temp1==temp2)
return temp1+1;
temp1=temp2;
}
}

int inline scan()
{
int n=0;
char c=getchar_unlocked();
while(c < '0' || c >'9')
{
c=getchar_unlocked();
}
while(c>='0' && c<='9')
{
n=(n<<3)+(n<<1)+c-'0';
c=getchar_unlocked();
}
return n;
}


int main()
{
int n;
n=scan();
for(int i=0;i<n;i++)
{
a[i]=scan();
s.insert(a[i]);
}
maketree(n);
int m;
m=scan();
while(m--)
{
int l,r;
l=scan();
r=scan();
printf("%d\n",query1(l-1,r-1,n));
}
return 0;
}

