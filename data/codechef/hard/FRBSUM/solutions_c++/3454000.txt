#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mp make_pair
#define all(X) (X).begin(),(X).end()
#define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++)

struct node
{
    int l,r;
    int sum;
} buf[2100000];    

int N,i,j,T,Q,roots[100000+10],num;
vector<pair<int,int> > a;
int insert(int id,int l,int r,int p,int v);
int query(int id,int l,int r,int s,int e);

int main()
{
    scanf("%d",&N);
    for(i = 0; i < N; i++)
    {
        scanf("%d",&j);
        a.pb(mp(j,i+1));
    }
    sort(all(a));    
    roots[0] = 0;
    for(i = 1; i <= N; i++)
        roots[i] = insert(roots[i-1],1,N,a[i-1].second,a[i-1].first);
    scanf("%d",&Q);
    while(Q--)
    {
        int l,r;
        scanf("%d %d",&l,&r);
        int ans = 0;
        while(1)
        {
            int p = upper_bound(all(a),mp(ans+1,N+1)) - a.begin() - 1;
            int nans = query(roots[p+1],1,N,l,r);
            if(nans == ans)
                break;
            ans = nans;
        }
        printf("%d\n",ans+1);
    }
    
    return 0;
}

int insert(int id,int l,int r,int p,int v)
{
    int idx = ++num;
    buf[idx] = buf[id];
    if(l == r)
    {
        buf[idx].sum = v;        
        return idx;
    }
    int mid = (l + r) / 2;
    if(p <= mid) buf[idx].l = insert(buf[idx].l,l,mid,p,v);
    else         buf[idx].r = insert(buf[idx].r,mid+1,r,p,v);
    buf[idx].sum = buf[buf[idx].l].sum + buf[buf[idx].r].sum;    
    return idx;
}

int query(int id,int l,int r,int s,int e)
{
    if(l == s && r == e)
        return buf[id].sum;
    int mid = (l + r) / 2;
    int ans = 0;
    if(s <= mid)
        ans += query(buf[id].l,l,mid,s,min(e,mid));
    if(e > mid)
        ans += query(buf[id].r,mid+1,r,max(s,mid+1),e);
    return ans;
}