#include <iostream>
#include <cstring>
#include <cmath>
#include <cstdio>
#include <climits>
#include <ctime>
#include <cassert>
#include <cctype>
#include <algorithm>
#include <numeric>
#include <map>
#include <set>
#include <queue>
#include <string>
#include <vector>
#include <bitset>

#define X first
#define Y second
#define pb push_back
#define bit(x) (1 << (x))
#define bnum(x) (__builtin_popcount(x))
#define sqr(x) ((x) * (x))
#define sz(x) ((int)(x.size()))
#define PQ priority_queue

using namespace std;
typedef long long LL;
typedef pair<int, int> pii;
typedef vector<int> vi;

template <class T> inline void chkmin(T &a, T b) {
	if (b < a) a = b;
}
template <class T> inline void chkmax(T &a, T b) {
	if (a < b) a = b;
}

#define MX 100005
int n, m, N;
int a[MX], b[MX], ans[MX];
int fr[MX], sum[MX];

struct Data {
	int x, y, u;
}q[MX];
bool operator <(const Data &a, const Data &b) {
	int aa = a.x / N, bb = b.x / N;
	if (aa != bb) return aa < bb;
	return a.y < b.y;
}

int main() {
	#ifndef ONLINE_JUDGE
	freopen("in.txt", "r", stdin);
	freopen("out.txt", "w", stdout);
	#endif
	
	int mm;
	scanf("%d", &n);
	N = int(sqrt(n + 0.1));
	int i;
	for (i = 1; i <= n; i++) {
		scanf("%d", a + i);
		b[i - 1] = a[i];
	}
	
	sort(b, b + n);
	mm = unique(b, b + n) - b;
	for (i = 1; i <= n; i++)
		a[i] = lower_bound(b, b + mm, a[i]) - b;
	
	scanf("%d", &m);
	for (i = 0; i < m; i++) {
		scanf("%d%d", &q[i].x, &q[i].y);
		q[i].u = i;
	}
	sort(q, q + m);
	N = int(sqrt(mm + 0.1));
	
	int st = -1, en = -1;
	for (i = 0; i < m; i++) {
		while (en > q[i].y) fr[a[en]]--, sum[a[en] / N] -= b[a[en]], en--;
		while (en < q[i].y) en++, fr[a[en]]++, sum[a[en] / N] += b[a[en]];
		while (st < q[i].x) {
			if (st >= 0) fr[a[st]]--, sum[a[st] / N] -= b[a[st]];
			st++;
		}
		while (st > q[i].x) st--, sum[a[st] / N] += b[a[st]], fr[a[st]]++;
		
		int tot = 0, now = -1;
		while (1) {
			int tp = 0;
			int id = upper_bound(b, b + mm, tot + 1) - b - 1;
			for (int j = 0; j < id / N; j++) tp += sum[j];
			for (int j = id / N * N; j <= id; j++) tp += b[j] * fr[j];
			if (tp == tot) break;
			tot = tp;
		}
		ans[q[i].u] = tot + 1;
	}
	
	for (i = 0; i < m; i++) printf("%d\n", ans[i]);
	return 0;
}