#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cstring>

using namespace std;

#define pb push_back
#define mp make_pair

#define ALL(x) (x).begin(),(x).end()
#define CLR(a,b) memset(a,b,sizeof(a))
#define REPN(x,a,b) for (int x=a; x<b;++x)
#define REP(x,b) REPN(x, 0, b)

#define dbg(x) cout << #x << " = " << x << endl;
#define dbg2(x, y) cout << #x << " = " << x << "  " << #y << " = " << y << endl;
#define dbg3(x, y, z) cout << #x << " = " << x << "  " << #y << " = " << y << "  " << #z << " = " << z << endl;
#define dbg4(x, y, z, w) cout << #x << " = " << x << "  " << #y << " = " << y << "  " << #z << " = " << z << "  " << #w << " = " << w <<  endl;

typedef long long ll;

int n, nnode;
pair <int, int> V[100010];

struct ST {
    int l, r, sum;
    ST():l(-1), r(-1), sum(0) {}
    ST(int _l, int _r, int _sum):l(_l), r(_r), sum(_sum) {}
};

ST segmentTree[2000000];
int node[2000000];


int insert(int at, int le, int ri, int pos, int val) {
    int cur = nnode++;
    if (at != -1) segmentTree[cur] = segmentTree[at];
    else segmentTree[cur] = ST(-1, -1, 0);

    segmentTree[cur].sum += val;

    if (le == ri) return cur;

    int mid = (le + ri)>>1;
    if (pos <= mid) segmentTree[cur].l = insert(segmentTree[cur].l, le, mid, pos, val);
    else segmentTree[cur].r = insert(segmentTree[cur].r, mid+1, ri, pos, val);
    return cur;
}

int queryST(int u, int le, int ri, int ql, int qr) {
    if (u == -1) return 0;
    if (ql <= le && qr >= ri) return segmentTree[u].sum;
    if (qr < le || ql > ri) return 0;
    int mid = (le + ri)>>1;
    return queryST(segmentTree[u].l, le, mid, ql, qr) + queryST(segmentTree[u].r, mid+1, ri, ql, qr);
}

int query(int ql, int qr) {
    int sum = 0;
    while (1) {
        int id = upper_bound(V, V+n, mp(sum+1, n+1)) - V; //encontrar el máximo numero que su suma sea igual a sum+1
        int nsum = queryST(node[id], 0, n-1, ql, qr); //tenemos que sumar todos los numeros desde ql hasta qr que son menores o iguales a sum+1 
//        if (nsum == sum) return sum+1;
//        sum = nsum;
        if (nsum >= sum+1) sum = nsum; //or if (nsum == sum) return sum+1
        else break;
    }
    return sum+1;
}


int main() {

    ios_base::sync_with_stdio(false);

    cin >> n;
    REP(i, n) {
        cin >> V[i].first;
        V[i].second = i;
    }
    sort(V, V+n);

    node[0] = -1;
    nnode = 0;
    REPN(i, 1, n+1) {
        node[i] = insert(node[i - 1], 0, n-1, V[i-1].second, V[i-1].first); //crear raízes para cada nodo, es decir el segment tree para cada V[i]
    }

    int m, ql, qr;
    cin >> m;
    REP(i, m) {
        cin >> ql >> qr;
        ql--; qr--;
        cout << query(ql, qr) << "\n";
    }
 
    return 0;
}
