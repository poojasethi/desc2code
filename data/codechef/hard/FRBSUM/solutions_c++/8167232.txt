/******************************************************************************\
*                         Author:  Dumbear                                     *
*                         Email:   dumbear[#at]163.com                         *
*                         Website: http://dumbear.com                          *
\******************************************************************************/
#include <algorithm>
#include <bitset>
#include <cctype>
#include <climits>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <functional>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <typeinfo>
#include <utility>
#include <vector>
 
using namespace std;
 
typedef long long LL;
typedef vector<int> VI;
typedef vector<long long> VL;
typedef vector<double> VD;
typedef vector<string> VS;
 
struct chair_tree {
    struct node {
        int l, r, sum;
        node(): l(0), r(0), sum(0) {
        }
    };
    vector<node> nodes;
    vector<int> sorted_nums;
    vector<int> index;
    void clear() {
        nodes.clear();
        nodes.push_back(node());
    }
    void build(const int* nums, int n) {
        sorted_nums = vector<int>(nums, nums + n);
        sort(sorted_nums.begin(), sorted_nums.end());
        sorted_nums.resize(unique(sorted_nums.begin(), sorted_nums.end()) - sorted_nums.begin());
        index.resize(n);
        for (int i = 0, last = 0; i < n; ++i) {
            index[i] = nodes.size();
            insert(index[i], last, 0, sorted_nums.size() - 1, nums[i]);
            last = index[i];
        }
    }
    void insert(int id, int pre, int l, int r, int val) {
        nodes.push_back(node());
        if (l == r) {
            nodes[id].sum = nodes[pre].sum + val;
            return;
        }
        int mid = (l + r) / 2;
        if (val <= sorted_nums[mid]) {
            nodes[id].l = nodes.size();
            insert(nodes[id].l, nodes[pre].l, l, mid, val);
            nodes[id].r = nodes[pre].r;
            update(id);
        } else {
            nodes[id].r = nodes.size();
            insert(nodes[id].r, nodes[pre].r, mid + 1, r, val);
            nodes[id].l = nodes[pre].l;
            update(id);
        }
    }
    void update(int id) {
        node &v = nodes[id];
        v.sum = nodes[v.l].sum + nodes[v.r].sum;
    }
    int get_sum(int id1, int id2, int l, int r, int val) {
        if (l == r)
            return val >= sorted_nums[l] ? nodes[id2].sum - nodes[id1].sum : 0;
        int mid = (l + r) / 2;
        int res = 0;
        if (val <= sorted_nums[mid]) {
            res += get_sum(nodes[id1].l, nodes[id2].l, l, mid, val);
        } else {
            res += nodes[nodes[id2].l].sum - nodes[nodes[id1].l].sum;
            res += get_sum(nodes[id1].r, nodes[id2].r, mid + 1, r, val);
        }
        return res;
    }
};
 
const int max_n = 100000 + 10;
 
int n, m, nums[max_n];
chair_tree ct;
 
int get_sum(int l, int r) {
    int res = 0;
    while (true) {
        int k = ct.get_sum((l == 0 ? 0 : ct.index[l - 1]), ct.index[r], 0, ct.sorted_nums.size() - 1, res + 1);
        if (k == res)
            return res + 1;
        res = k;
    }
    return 0;
}
 
void solve() {
    scanf("%d", &n);
    for (int i = 0; i < n; ++i)
        scanf("%d", &nums[i]);
    ct.clear();
    ct.build(nums, n);
    scanf("%d", &m);
    for (int i = 0; i < m; ++i) {
        int l, r;
        scanf("%d%d", &l, &r);
        printf("%d\n", get_sum(l - 1, r - 1));
    }
}
 
int main() {
    solve();
    return 0;
}
 