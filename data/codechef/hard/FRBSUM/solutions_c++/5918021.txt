#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#define FOE(i, x, y) for (int i = x; i <= y; i ++)
#define u t[x]
#define v t[y]
using namespace std;
typedef long long LL;
const int N = 111111;
struct arr { int l, r, lc, rc, sm; } t[N*20*4];
int n, m, nid, Q, a[N], b[N], T[N], sum;
int bt(int l, int r) {
	int x = ++nid; u.l = l, u.r = r;
	if (l == r) return x;
	int md = (l + r) >> 1;
	u.lc = bt(l, md), u.rc = bt(md+1, r);
	return x;
}
int upd(int tx, int y) {
	int x = ++ nid;
	u = t[tx], u.sm += b[y];
	if (u.l == u.r) return x;
	int md = (u.l + u.r) >> 1;
	if (y <= md) u.lc = upd(t[tx].lc, y);else u.rc = upd(t[tx].rc, y);
	return x;
}
int qry(int x, int y) {
	if (b[u.l] > sum + 1) return 0;
	if (b[u.r] <= sum + 1) return u.sm - v.sm;
	return qry(u.lc, v.lc) + qry(u.rc, v.rc);
}
int main(){
	scanf ("%d", &n);
	FOE(i, 1, n)scanf ("%d", &a[i]), b[i] = a[i];
	sort (b+1, b+n+1);
	m = unique(b+1, b+n+1) - b - 1;
	T[n+1] = bt(1, m);//dx
	for (int i = n; i >= 1; i --) {
		int pos = lower_bound(b+1, b+m+1, a[i]) - b;
		T[i] = upd(T[i+1], pos);//dq
	}
	scanf ("%d", &Q);
	while (Q --) {
		int l, r, w = 0;
		scanf ("%d%d", &l, &r);
		for (sum = 0; (w = qry(T[l], T[r+1])) && sum < w; ) sum = w;//still can extend sum= get prefix sum 1 to r
		printf ("%d\n", sum + 1);
	}
	return 0;
}
