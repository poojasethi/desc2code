#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;

struct node
{
vector<int>v;
vector<int>sum;
};

struct node tree[(1<<18)];
int a[100007];

void merge_(int u,int v,int w)
{
int i=0,j=0;
for(;;)
if(i>=tree[v].v.size()||j>=tree[w].v.size())
break;
else if(tree[v].v[i]<=tree[w].v[j])
tree[u].v.push_back(tree[v].v[i++]);
else
tree[u].v.push_back(tree[w].v[j++]);
while(i<tree[v].v.size())
tree[u].v.push_back(tree[v].v[i++]);
while(j<tree[w].v.size())
tree[u].v.push_back(tree[w].v[j++]);
tree[u].sum.push_back(tree[u].v[0]);
for(i=1;i<tree[u].v.size();i++)
tree[u].sum.push_back(tree[u].sum[i-1]+tree[u].v[i]);
}


void maketree(int beg,int last,int si)
{
if(beg==last)
{
tree[si].v.push_back(a[beg]);
tree[si].sum.push_back(a[beg]);
return;
}
maketree(beg,(beg+last)/2,2*si+1);
maketree((beg+last)/2+1,last,2*si+2);
merge_(si,2*si+1,2*si+2);
}

int query2(int beg,int last,int p,int q,int si,int x)
{
if(beg>q||last<p)
return 0;
//cout<<beg<<" "<<last<<endl;
if(p<=beg&&q>=last)
{
//cout<<beg<<" "<<last<<endl;
int pos=upper_bound(tree[si].v.begin(),tree[si].v.end(),x)-tree[si].v.begin();
pos--;
if(pos==-1)
return 0;
return tree[si].sum[pos];
}
return query2(beg,(beg+last)/2,p,q,2*si+1,x)+query2((beg+last)/2+1,last,p,q,2*si+2,x);
}

int query1(int l,int r,int n)
{
int temp1=0;
for(;;)
{
int temp2=query2(0,n-1,l,r,0,temp1+1);
if(temp1==temp2)
return temp1+1;
temp1=temp2;
}
}

int inline scan()
{
int n=0;
char c=getchar_unlocked();
while(c < '0' || c >'9')
{
c=getchar_unlocked();
}
while(c>='0' && c<='9')
{
n=(n<<3)+(n<<1)+c-'0';
c=getchar_unlocked();
}
return n;
}


int main()
{
int n;
n=scan();
for(int i=0;i<n;i++)
a[i]=scan();
maketree(0,n-1,0);
int m;
m=scan();
while(m--)
{
int l,r;
l=scan();
r=scan();
printf("%d\n",query1(l-1,r-1,n));
}
return 0;
}
