#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<vector>
#include<bitset>
#include<map>
#include<set>
#include<climits>
#include<algorithm>
#include<utility>
#include<cstdlib>
#include<cctype>
#include<queue>
#include<sstream>
#include<cassert>
using namespace std;



int val[1000001]={0};
int mem[32][100001]={{0}};
int tree[32][524289]={{0}};
int rangesz[33]={0};

vector < pair <int,int>  > range[32];
vector < pair <int,int>  >::iterator it1,it2;


bool compare(const pair<int,int> &left,const pair<int,int>  &right)
{
    return left.first<right.first;
}


int query(int node, int l, int r, int r1, int r2,int id ) 
{
 if( r < r1 || l > r2 ) return -1;
 if( l >= r1 && r <= r2 ) return tree[id][ node ];
 int mid = ( l + r )>>1,q1,a1,a2;
 q1 =(node<<1) + 1;
 a1 = query( q1, l, mid , r1, r2,id);
 a2 = query( q1+1, mid + 1, r, r1, r2,id);
 if(a1 == -1) return a2;
 else if(a2 == -1) return a1;
 else return min(a1,a2);
}

 int make(int node,int l, int r ,int id)
{
 if(l==r) 
 {
  tree[id][node]=range[id][l].second;
  return 0 ;
 }
 int mid = (l+r)>>1,q1=(node<<1) + 1;
 make(q1,l,mid,id) ;
 make( q1+1,mid + 1,r ,id);
 tree[id][ node]=min(tree[id][ q1],tree[id][q1+1]);
 return 1;
}


int findmin(int l,int r,int j)
{
    pair <int,int> ll=make_pair(l,0);
    pair <int,int> rr=make_pair(r,0);
    
    it1=lower_bound(range[j].begin(),range[j].end(),ll,compare);
    it2=upper_bound(range[j].begin(),range[j].end(),rr,compare);
    int pos1=(int) (it1-range[j].begin());
    int pos2=(int) (it2-range[j].begin());
    l=pos1;
    r=pos2-1;
    return query(0,0,rangesz[j]-1,l,r,j);
    
}
int main()
{
//freopen("in.txt","r",stdin);
int n,i,j,q,l,r;
scanf("%d",&n);
long long int ans;


for(i=0;i<n;i++)
{
   scanf("%d",&val[i]);
   
   if(i)
   for(j=0;j< (32);j++)
   mem[j][i]=mem[j][i-1];
    
   for(j=0;j<(32);j++)
   if ( (1ll<<j) >val[i])
    {
	    mem[j-1][i]+=val[i];
		rangesz[j-1]++;
		range[j-1].push_back(make_pair(i,val[i]));
        break;
    }
}


for(j=0;j< (32) ;j++)
if(rangesz[j])
make(0,0,rangesz[j]-1,j);

scanf("%d",&q);
while(q--)
{
    scanf("%d%d",&l,&r);
    l-=1;
    r-=1;
    ans=0;
    for(j=0;j< (32);j++)
    {
        int rem=mem[j][r];
        if(l)rem-=mem[j][l-1];
        
        if(ans >=( (1ll <<(j+1))-1))
        ans+=rem;
        else if(rem && findmin(l,r,j)<=ans+1)ans+=rem;
        else break;
    }
    printf("%lld\n",ans+1);
 }
    
}
