#include <iostream>   
#include <sstream>   
#include <cstdio>   
#include <cstdlib>   
#include <cmath>   
#include <memory.h>   
#include <cctype>   
#include <string>   
#include <vector>   
#include <list>   
#include <queue>   
#include <deque>   
#include <stack>   
#include <map>   
#include <set>   
#include <algorithm>   
using namespace std;  
   
#define FOR(i,a,b) for(int (i) = (a); (i) < (b); ++(i))  
#define RFOR(i,a,b) for(int (i) = (a)-1; (i) >= (b); --(i))  
#define CLEAR(a) memset((a),0,sizeof(a))  
#define INF 1000000000  
#define PB push_back  
#define ALL(c) (c).begin(), (c).end()  
#define pi 2*acos(0.0)  
#define SQR(a) (a)*(a)  
#define MP make_pair  
#define MAX 102
#define MOD 1000000007
   
typedef long long Int;

int numBlocks, k, T;
int blockSize[20], blockColor[20];
double dp[21][201];
double factorial[21];
bool done[21];

double COUNT(int size1, int size2, int diff) {

    int ctr = 0;
    FOR(x, 1, size1 + 1) {

        if(x + k > size1 + diff && x + k <= size1 + diff + size2) 
            ctr++;
    }
    double ret = ctr + 0.0;
    return ret;
}

/*double COUNT(int size1, int size2, int diff) {

    int l = size1 + diff;
    int r = size1 + size2 + diff - 1;

    int ll = k;
    int rr = size1 + k - 1;

    return max(0, min(r, rr) - max(l, ll) + 1);
}*/

int main() {

    factorial[0] = 1.0;
    FOR(i, 1, 21) {

        double j = i + 0.0;
        factorial[i] = factorial[i - 1] * j;
    }

    scanf("%d", &T);
    FOR(t, 0, T) {

        scanf("%d%d", &numBlocks, &k);
        CLEAR(done);
        double ans = 0;

        FOR(i, 0, numBlocks) {

            scanf("%d%d", &blockSize[i], &blockColor[i]);
        }
    
        int total = 0;

        FOR(i, 0, numBlocks) {

            total += blockSize[i];
        }

        FOR(i, 0, numBlocks) {

            if(done[i])
                continue;

            int block1 = i, block2 = -1;
            FOR(j, i + 1, numBlocks) {

                if(blockColor[j] == blockColor[i])
                    block2 = j;
            }

            if(block2 == -1) {

                ans += max(0, blockSize[block1] - k);
            }
            else {

                ans += max(0, blockSize[block1] - k);
                ans += max(0, blockSize[block2] - k);
                done[block2] = true;

                CLEAR(dp);
                dp[0][0] = 1.0;

                int sum = 0;

                FOR(j, 0, numBlocks) {

                    if(j == block1 || j == block2)
                        continue;
                    RFOR(q, j + 1, 0) {
                        
                        RFOR(s, sum + 1, 0) {

                            dp[q + 1][s + blockSize[j]] += dp[q][s];
                        }
                    }
                    sum += blockSize[j];
                }

                FOR(j, 0, numBlocks - 1) {

                    FOR(s, 0, sum + 1) {

                        double r = dp[j][s] * factorial[j] * (j + 1) * factorial[numBlocks - 2 - j] * 2;
                        r /= factorial[numBlocks];
                        ans += r * COUNT(blockSize[block1], blockSize[block2], total - blockSize[block1] - blockSize[block2] - s);
                    }
                }
            }
        }
        printf("%0.8f\n", ans);
    }
    return 0;
}
