//Segment Tree
#include<iostream>
#include<cstdio>
#include<algorithm>
#define LL long long int
using namespace std;
struct seg
{	pair<int,int>left;
	pair<int,int>right;
	int ans;
}tree[500005];
int arr[100005];
void build(int node,int a,int b)
{	int temp;
	if(a==b)
	{	/*tree[node].left.first=arr[a];
		tree[node].left.second=1;
		tree[node].right.first=arr[a];
		tree[node].right.second=1;
		tree[node].ans.first=arr[a];
		tree[node].ans.second=1;*/
		
		tree[node].left=make_pair(arr[a],1);
		tree[node].right=make_pair(arr[a],1);
		tree[node].ans=1;
		
		return ;
	}
		
	build(2*node,a,(a+b)/2);
	build(2*node+1,(a+b)/2+1,b);
	int m=(a+b)/2;
	tree[node].left.first=tree[2*node].left.first;
	if( (tree[2*node].left.first==tree[2*node+1].left.first) && (tree[2*node].left.second==(m-a+1)) )
		tree[node].left.second=tree[2*node].left.second+tree[2*node+1].left.second;
	else
		tree[node].left.second=tree[2*node].left.second;
	
	tree[node].right.first=tree[2*node+1].right.first;
	if( (tree[2*node].right.first==tree[2*node+1].right.first) && (tree[2*node+1].right.second==b-m))
		tree[node].right.second=tree[2*node].right.second+tree[2*node+1].right.second;
	else
		tree[node].right.second=tree[2*node+1].right.second;
	
	temp=max(tree[2*node].ans,tree[2*node+1].ans);
	if(tree[2*node].right.first==tree[2*node+1].left.first)
		tree[node].ans=max(temp,tree[2*node].right.second+tree[2*node+1].left.second);	
	else
		tree[node].ans=temp;
	return ;
}
void update(int node,int a,int b,int p,int q)
{	int temp;
	//cout<<"a b p "<<a<<" "<<b<<" "<<p<<endl;
	if(a>b||p<a||p>b)
		return ;
	if(a==b&&a!=p)
		return ;	
	if(a==b&&a==p)
	{	/*tree[node].left.first=arr[a];
		tree[node].left.second=1;
		tree[node].right.first=arr[a];
		tree[node].right.second=1;
		tree[node].ans.first=arr[a];
		tree[node].ans.second=1;*/
		
		tree[node].left=make_pair(q-p,1);
		tree[node].right=make_pair(q-p,1);
		tree[node].ans=1;
		arr[a]=q-p;
		//cout<<"hello";
		return ;
	}

	//cout<<"hii";
	update(2*node,a,(a+b)/2,p,q);
	update(2*node+1,(a+b)/2+1,b,p,q);
	int m=(a+b)/2;
	tree[node].left.first=tree[2*node].left.first;
	if( (tree[2*node].left.first==tree[2*node+1].left.first) && (tree[2*node].left.second==(m-a+1)) )
		tree[node].left.second=tree[2*node].left.second+tree[2*node+1].left.second;
	else
		tree[node].left.second=tree[2*node].left.second;
	
	tree[node].right.first=tree[2*node+1].right.first;
	if( (tree[2*node].right.first==tree[2*node+1].right.first) && (tree[2*node+1].right.second==b-m))
		tree[node].right.second=tree[2*node].right.second+tree[2*node+1].right.second;
	else
		tree[node].right.second=tree[2*node+1].right.second;
	
	temp=max(tree[2*node].ans,tree[2*node+1].ans);
	if(tree[2*node].right.first==tree[2*node+1].left.first)
		tree[node].ans=max(temp,tree[2*node].right.second+tree[2*node+1].left.second);		
	else
		tree[node].ans=temp;
	
	/*cout<<endl;
	cout<<"Soltion"<<endl;
	printf("a%d b%d node%d tree%d\n",a,b,node,tree[node].ans);
	cout<<"TRee node values "<<endl;
	printf("Node %d %d %d %d \n",tree[node].left.first,tree[node].left.second,tree[node].right.first,tree[node].right.second);
	printf("Left child %d %d %d %d \n",tree[2*node].left.first,tree[2*node].left.second,tree[2*node].right.first,tree[2*node].right.second);
	printf("right child %d %d %d %d \n",tree[2*node+1].left.first,tree[2*node+1].left.second,tree[2*node+1].right.first,tree[2*node+1].right.second);*/	
	return ;
}
int main()
{	int N,M,p,q,val,i;
	scanf("%d%d",&N,&M);
	for(i=0;i<N;i++)
	{	scanf("%d",&arr[i]);
		arr[i]-=i;
	}
	/*cout<<endl;
	for(i=0;i<10;i++)
		cout<<arr[i]<<" ";
	cout<<endl;*/
	build(1,0,N-1);
	/*for(i=1;i<32;i++)
		printf("%d ",tree[i].ans);*/
	val=tree[1].ans;
		printf("%d\n",val);
	while(M--)
	{	scanf("%d%d",&p,&q);
		update(1,0,N-1,p-1,q);
		/*cout<<endl;
		for(i=1;i<32;i++)
			printf("%d ",tree[i].ans);
		
		cout<<endl;
		for(i=0;i<10;i++)
			cout<<arr[i]<<" ";
		cout<<endl;*/
		val=tree[1].ans;
		printf("%d\n",val);
	}
	return 0;
}
/*
10 20
1 2 3 4 5 6 7 8 9 10
*/
