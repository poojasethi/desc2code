// Artur Kraska, II UWr

#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <cmath>
#include <list>
#include <set>
#include <map>

#define forr(i, n)                  for(int i=0; i<n; i++)
#define FOREACH(iter, coll)         for(typeof(coll.begin()) iter = coll.begin(); iter != coll.end(); ++iter)
#define FOREACHR(iter, coll)        for(typeof(coll.rbegin()) iter = coll.rbegin(); iter != coll.rend(); ++iter)
#define lbound(P,R,PRED)            ({typeof(P) X=P,RRR=(R), PPP = P; while(PPP<RRR) {X = (PPP+(RRR-PPP)/2); if(PRED) RRR = X; else PPP = X+1;} PPP;})
#define testy()                     int _tests; scanf("%d", &_tests); forr(_test, _tests)
#define CLEAR(tab)                  memset(tab, 0, sizeof(tab))
#define CONTAIN(el, coll)           (coll.find(el) != coll.end())
#define FOR(i, a, b)                for(int i=a; i<=b; i++)
#define FORD(i, a, b)               for(int i=a; i>=b; i--)
#define MP                          make_pair
#define PB                          push_back

#define M 1000000007
#define INF 1000000007

using namespace std;

#define S 131072

int n, m, a, b;
int tab[1000007];

struct elem
{
    int maks, ile_lewo, ile_prawo, co_lewo, co_prawo, rozm;
};
elem d[300007];

static inline void ustaw(int nr)
{
    d[nr].rozm = d[nr*2].rozm + d[nr*2+1].rozm;
    d[nr].co_lewo = d[nr*2].co_lewo;
    d[nr].co_prawo = d[nr*2+1].co_prawo;
    d[nr].ile_lewo = (d[nr*2].maks != d[nr*2].rozm || d[nr*2].co_lewo != d[nr*2+1].co_lewo ? d[nr*2].ile_lewo : d[nr*2].rozm + d[nr*2+1].ile_lewo);
    d[nr].ile_prawo = (d[nr*2+1].maks != d[nr*2+1].rozm || d[nr*2+1].co_prawo != d[nr*2].co_prawo ? d[nr*2+1].ile_prawo : d[nr*2+1].rozm + d[nr*2].ile_prawo);
    d[nr].maks = max(max(d[nr*2].maks, d[nr*2+1].maks), (d[nr*2].co_prawo == d[nr*2+1].co_lewo ? d[nr*2].ile_prawo + d[nr*2+1].ile_lewo : 0));

}

int main()
{
    scanf("%d %d", &n, &m);
    forr(i, n)
    {
        scanf("%d", &a);
        tab[i] = a-i;
        d[i+S].co_lewo = d[i+S].co_prawo = tab[i];
        d[i+S].maks = d[i+S].ile_lewo = d[i+S].ile_prawo = d[i+S].rozm = 1;
    }

    FOR(i, n, S-1)
        d[i+S].co_lewo = d[i+S].co_prawo = INF-i;

    FORD(i, S-1, 1)
        ustaw(i);

    printf("%d\n", d[1].maks);

    forr(i, m)
    {
        scanf("%d %d", &a, &b);
        a--;
        tab[a] = b-a;
        a = a+S;
        d[a].co_lewo = d[a].co_prawo = tab[a-S];
/*
        forr(j, n)
            cout << d[j+S].co_lewo << " (" << d[j+S].co_prawo << ") ";
        cout << endl;
*/
        a >>= 1;
        while(a > 0)
        {
            ustaw(a);
            int nr = a;
            //cout << nr << " - co: " << d[nr].co_lewo << ", " << d[nr].co_prawo << ", ile: " << d[nr].ile_lewo << ", " << d[nr].ile_prawo << ", maks: " << d[nr].maks << endl;
            a >>= 1;
        }

        printf("%d\n", d[1].maks);
    }

	return 0;
}
