#include <cstdio>
#include <queue>
#include <vector>
#include <set>
#include <iostream>

using namespace std;

struct cord {
    int vale, dnde;
    bool operator ()(const cord &b, const cord &a) const {
        if(a.vale>b.vale)
            return true;
        return false;
    }
} m;

int A[100005], B[100005], ctos, pregs, pos, por, v, es, g, g2;
priority_queue<cord, vector<cord>, cord> P;
set<int> M;
set<int>::iterator it;

void po(int lugar){
    m.dnde=lugar;
    m.vale=B[lugar];
    P.push(m);
}

int main()
{
    scanf("%d%d",&ctos,&pregs);
    for(int i=1; i<=ctos; i++)
        scanf("%d",&A[i]);
    for(int i=1; i<=ctos; i++){
        for(v=i; A[v]==A[v+1]-1; v++);
        B[i]=v-i+1;
        m.vale=B[i];
        m.dnde=i;
        P.push(m);
        M.insert(i);
        i=v;
    }
    printf("%d\n",P.top().vale);
    while(pregs--){
        scanf("%d%d",&pos,&por);
        if(A[pos]!=por){
            A[pos]=por;

            it=M.lower_bound(pos);
            --it;
            es=*it;
            g=B[es];
            g2=es;
            if(B[pos]==0){
                B[es]=pos-es;
                po(es);
            }

            if(A[pos]==A[pos+1]-1){
                if(B[pos]==0)
                    M.insert(pos);
                B[pos]=B[pos+1]+1;
                po(pos);
                B[pos+1]=0;
                M.erase(M.find(pos+1));
            }
            else {
                if(B[pos+1]==0){
                    if(B[pos]==0)
                        B[pos+1]=max((g2+g-1)-(pos+1)+1, 1);
                    else
                        B[pos+1]=B[pos]-1;
                    po(pos+1);
                    M.insert(pos+1);
                }
                if(B[pos]==0){
                    M.insert(pos);
                }

                B[pos]=1;
                po(pos);

            }
            if(B[pos]>0 and pos>1 and A[pos-1]==A[pos]-1){
                it=M.lower_bound(pos);
                --it;
                es=*it;
                B[es]+=B[pos];
                po(es);
                B[pos]=0;
                M.erase(M.find(pos));
                if(A[pos]==A[pos+1]-1 and B[pos+1]>0){
                    B[pos+1]=0;
                    M.erase(M.find(pos+1));
                }
            }
        }
        while(!P.empty() and B[P.top().dnde]!=P.top().vale)
            P.pop();
        /*for(int i=1; i<=ctos; i++)
            cout<<A[i]<<" ";
        cout<<" :  ";
        for(int i=1; i<=ctos; i++)
            cout<<B[i]<<" ";
        cout<<endl;*/
        printf("%d\n",P.top().vale);
    }
    return 0;
}
