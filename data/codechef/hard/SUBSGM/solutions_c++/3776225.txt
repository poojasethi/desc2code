#include <iostream>
#include <vector>
#include <algorithm>
#include <memory.h>
#include <math.h>
#include <cstdio>
#define MAX 100100
using namespace std;

struct point{
    int suf, pre, mx, sz, prev, sufv;
    friend point operator +(const point &a, const point &b) {
        point ret;
        ret.sz = a.sz + b.sz;
        ret.mx = max(a.mx,b.mx);
        ret.pre = a.pre;
        ret.suf = b.suf;
        ret.prev = a.prev;
        ret.sufv = b.sufv;
        if(b.prev - a.sufv == 1)
        {
            ret.mx = max(ret.mx, a.suf + b.pre);
            if(a.sz == a.pre) ret.pre = a.sz + b.pre;
            if(b.sz == b.suf) ret.suf = b.sz + a.suf;
        }
        return ret;
    }
}t[MAX * 5];

point emp;
int a[MAX];
point query(int v, int l, int r, int a, int b)
{
    if(a > b)
        return emp;
    if(a == l && r == b) return t[v];
    int mid = (l+r) / 2;
    point L = query(v*2,l,mid,a,min(mid,b));
    point R = query(v*2+1,mid+1,r,max(mid+1,a),b);
    if(L.sz == -1) return R;
    if(R.sz == -1) return L;
    return L + R;
}
void update(int v, int l, int r, int x, int k)
{
    if(x < l || x > r) return;
    if(l == r)
    {
        t[v].mx = 1;
        t[v].pre = 1;
        t[v].suf = 1;
        t[v].prev = k;
        t[v].sufv = k;
        t[v].sz = 1;

        return;
    }
    int mid = (l+r) / 2;
    update(v*2,l,mid,x,k);
    update(v*2+1,mid+1,r,x,k);
    t[v] = t[v*2] + t[v*2+1];
}
int main()
{
    int n, m;
    cin >> n >> m;
    emp.sz = -1;
    for(int i = 1; i <= n; i++)
    {
        scanf("%d",&a[i]);
        update(1,1,n,i,a[i]);
    }
    cout << query(1,1,n,1,n).mx<<endl;;
    while(m--)
    {
        int x, y;
        scanf("%d%d",&x, &y);
        update(1,1,n,x,y);
        printf("%d\n",query(1,1,n,1,n).mx);
    }
    return 0;
}
