#include <iostream>
#include <vector>
#include <math.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

using namespace std;

#define inchar getchar_unlocked
 
inline void inp( int &n )
{
n=0;
int ch=inchar();int sign=1;
while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=inchar();}
while( ch >= '0' && ch <= '9' )
n = (n<<3)+(n<<1) + ch-'0', ch=inchar();
n=n*sign;
}




typedef struct element
{
   int total,fromleft,fromright,leftelem,rightelem;
    
}element;

vector<element> segment_tree;
int a[100010];


inline void init_segment_tree(int N)
{ 
    int length = (2 * pow(2.0, floor((log((double)N) / log(2.0)) + 1))+2);
    segment_tree.resize(length); 
}


inline int maximum(int a,int b,int c)
 {
     return max(a,max(b,c));
 }

inline void build_segment_tree( int node, int b, int e)
{
 
 if (b == e) // base case
  { 
    
    segment_tree[node].total = 1;
    segment_tree[node].fromright = 1;
    segment_tree[node].fromleft = 1;
    segment_tree[node].leftelem = a[b];
    segment_tree[node].rightelem = a[b];
  } 
  
  
else 
 { // recursively compute the values in the left and right subtrees
   int leftIdx = 2 * node, rightIdx = 2 * node + 1;
   build_segment_tree(leftIdx , b , (b + e) / 2);
   build_segment_tree( rightIdx, (b + e) / 2 + 1, e );
  
 
 // update left and right element

 segment_tree[node].leftelem = segment_tree[leftIdx].leftelem;
 segment_tree[node].rightelem = segment_tree[rightIdx].rightelem;
 
 // update the longest from left
 
 segment_tree[node].fromleft = segment_tree[leftIdx].fromleft;
 int sizeleftchild = (b+e)/2 - b + 1;
 if(segment_tree[leftIdx].fromleft == sizeleftchild && segment_tree[leftIdx].rightelem == segment_tree[rightIdx].leftelem-1)
  {
     segment_tree[node].fromleft += segment_tree[rightIdx].fromleft; 
  }

  // update the longest from right
  
  segment_tree[node].fromright = segment_tree[rightIdx].fromright;
  int sizerightchild = e - (b+e)/2;
   if(segment_tree[rightIdx].fromright == sizerightchild && segment_tree[leftIdx].rightelem == segment_tree[rightIdx].leftelem-1)
  {
     segment_tree[node].fromright += segment_tree[leftIdx].fromright; 
  }
  
  // update the total field
  
  int crossover = 0;
  if(segment_tree[leftIdx].rightelem == segment_tree[rightIdx].leftelem-1)
   {
       crossover = segment_tree[leftIdx].fromright + segment_tree[rightIdx].fromleft;
   }
   
  segment_tree[node].total = maximum(crossover,segment_tree[leftIdx].total,segment_tree[rightIdx].total); 
          
  
 } 
    
}



inline void update(  int node, int b, int e, int upind, int upval)
{
  int leftIdx,rightIdx,p,px;
  leftIdx = 2*node;
  rightIdx = leftIdx+1;
  p = (b+e)/2;
  px = p+1;
  if(b == e) // update at the lowest node
  {
     a[upind] = upval;
     segment_tree[node].leftelem = a[b];
     segment_tree[node].rightelem = a[b];
     return;
  }
  
  if(upind<=p)
  update(leftIdx,b,p,upind,upval);
  else
  update(rightIdx,px,e,upind,upval);
  
  // update left and right element

 segment_tree[node].leftelem = segment_tree[leftIdx].leftelem;
 segment_tree[node].rightelem = segment_tree[rightIdx].rightelem;
 
 // update the longest from left
 
 segment_tree[node].fromleft = segment_tree[leftIdx].fromleft;
 int sizeleftchild = (b+e)/2 - b + 1;
 if(segment_tree[leftIdx].fromleft == sizeleftchild && segment_tree[leftIdx].rightelem == segment_tree[rightIdx].leftelem-1)
  {
     segment_tree[node].fromleft += segment_tree[rightIdx].fromleft; 
  }

  // update the longest from right
  
  segment_tree[node].fromright = segment_tree[rightIdx].fromright;
  int sizerightchild = e - (b+e)/2;
   if(segment_tree[rightIdx].fromright == sizerightchild && segment_tree[leftIdx].rightelem == segment_tree[rightIdx].leftelem-1)
  {
     segment_tree[node].fromright += segment_tree[leftIdx].fromright; 
  }
  
  // update the total field
  
  int crossover = 0;
  if(segment_tree[leftIdx].rightelem == segment_tree[rightIdx].leftelem-1)
   {
       crossover = segment_tree[leftIdx].fromright + segment_tree[rightIdx].fromleft;
   }
   
  segment_tree[node].total = maximum(crossover,segment_tree[leftIdx].total,segment_tree[rightIdx].total); 
          
}
 
 

 

int main() {
	// your code goes here
	
	int n,m;
	inp(n);inp(m);
	for(int i=1;i<=n;i++)
	 {
	     inp(a[i]);
	 }
	
	init_segment_tree(n);
	build_segment_tree(1,1,n);
	printf("%d\n",segment_tree[1].total); 
	
	for(int i=1;i<=m;i++)
	 {
	     int ind,val;
	     inp(ind);inp(val);
	     update(1,1,n,ind,val);
	     printf("%d\n",segment_tree[1].total);
	 }
	
	
	return 0;
}
