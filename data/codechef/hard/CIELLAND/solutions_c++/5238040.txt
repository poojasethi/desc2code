    #include <algorithm>
    #include <cmath>
    #include <cstdio>
     
    using namespace std;
     
    template <class T> inline void upd_min(T &lhs, T rhs) {if(lhs>rhs)lhs=rhs;}
    template <class T> inline void upd_max(T &lhs, T rhs) {if(lhs<rhs)lhs=rhs;}
     
    int side(int x1, int y1, int x2, int y2) {
     
    int tmp = x1 * -y2 + y1 * x2;
    return tmp < 0 ? -1 : !!tmp;
     
    }
     
    int T;
    int N, K;
    int x[16], y[16];
     
    double w[1 << 13];
    double dp[7][1 << 13];
     
    void solve() {
     
    scanf("%d", &T);
    while (T--) {
    scanf("%d%d", &N, &K);
    for (int i = 0; i < N; ++i) {
    scanf("%d%d", x + i, y + i);
    }
    if (N <= K << 1) {
    printf("%.16lf\n", 0.0);
    continue;
    }
    w[0] = 0.0;
    for (int i = 1; i < 1 << N; ++i) {
    w[i] = 200.0;
    }
    for (int i = 0; i < N; ++i) {
    w[1 << i] = 0.0;
    for (int j = i + 1; j < N; ++j) {
    w[1 << i | 1 << j] = 0.0;
    double den = hypot(x[j] - x[i], y[j] - y[i]);
    for (int k = 0; k < N; ++k) {
    if (i == k || i == j) continue;
    double _w = ((x[k] - x[i]) * -(y[j] - y[i]) +
    (y[k] - y[i]) * (x[j] - x[i])) / den;
    int cover = 0;
    for (int l = 0; l < N; ++l) {
    int foo = side(x[k] - x[i], y[k] - y[i],
    x[j] - x[i], y[j] - y[i]);
    int bar = side(x[l] - x[i], y[l] - y[i],
    x[j] - x[i], y[j] - y[i]);
    int baz = side(x[l] - x[k], y[l] - y[k],
    x[j] - x[i], y[j] - y[i]);
    if (foo && foo * bar >= 0 && foo * baz <= 0 ||
    bar == 0 ||
    baz == 0) {
    cover |= 1 << l;
    }
    }
    upd_min(w[cover], abs(_w));
    }
    }
    }
    for (int i = (1 << N) - 1; i; --i) {
    for (int j = 1; j <= i; j <<= 1) {
    if (i & j) upd_min(w[i ^ j], w[i]);
    }
    }
    for (int i = 0; i <= K; ++i) {
    dp[i][0] = 0.0;
    for (int j = 1; j < 1 << N; ++j) {
    dp[i][j] = 200.0;
    }
    }
    for (int i = 1; i <= K; ++i) {
    int msb = -1;
    for (int j = 1; j < 1 << N; ++j) {
    if ((j & -j) == j) ++msb;
    for (int k = j ^ 1 << msb; ; k = k - 1 & j) {
    upd_min(dp[i][j], max(dp[i - 1][k], w[j ^ k]));
    if (!k) break;
    }
    }
    }
    printf("%.16lf\n", dp[K][(1 << N) - 1] / 2.0);
    }
     
    }
     
    int main() {
     
    solve();
     
    return 0;
     
    }
