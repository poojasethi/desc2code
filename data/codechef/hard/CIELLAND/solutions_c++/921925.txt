#include <algorithm>
#include <cmath>
#include <cstdio>

using namespace std;

typedef long long ll;

const double EPS = 1e-9;

template <class T> inline void upd_min(T &lhs, T rhs) {if(lhs>rhs)lhs=rhs;}
template <class T> inline void upd_max(T &lhs, T rhs) {if(lhs<rhs)lhs=rhs;}

int side(int x1, int y1, int x2, int y2) {

  int i = x1 * -y2 + y1 * x2;
  return i < 0 ? -1 : !!i;

}

struct rational {

  ll num, den;
  rational(ll num = 0, ll den = 1)
    : num(num), den(den) {}
  bool operator <(const rational r) const {
    return num * r.den < r.num * den;
  }
  bool operator >(const rational r) const {
    return num * r.den > r.num * den;
  }
  double value() {
    return sqrt((double)num / den) / 2.0;
  }

};

ll sq(ll n) {

  return n * n;

}

int T;
int N, K;
int x[16], y[16];
rational w[1<<13];
rational dp[16][1 << 13];

void solve() {

  scanf("%d", &T);
  while (T--) {
    scanf("%d%d", &N, &K);
    for (int i = 0; i < N; ++i) {
      scanf("%d%d", x + i, y + i);
    }
    for (int i = 0; i < 1 << N; ++i) {
      w[i] = rational(40000);
    }
    for (int i = 0; i < N; ++i) {
      for (int j = i + 1; j < N; ++j) {
        for (int k = 0; k < N; ++k) {
          if (i == k || i == j) continue;
          rational _w
            (sq((x[k] - x[i]) * -(y[j] - y[i]) +
                (y[k] - y[i]) * (x[j] - x[i])),
             sq(x[j] - x[i]) + sq(y[j] - y[i]));
          int cover = 0;
          for (int l = 0; l < N; ++l) {
            int foo = side(x[k] - x[i], y[k] - y[i],
                           x[j] - x[i], y[j] - y[i]);
            int bar = side(x[l] - x[i], y[l] - y[i],
                           x[j] - x[i], y[j] - y[i]);
            int baz = side(x[l] - x[k], y[l] - y[k],
                           x[j] - x[i], y[j] - y[i]);
            if (foo && foo * bar >= 0 && foo * baz <= 0
                || bar == 0
                || baz == 0) {
              cover |= 1 << l;
            }
          }
          upd_min(w[cover], _w);
        }
      }
    }
    for (int i = 0; i < 1 << N; ++i) {
      if (__builtin_popcount(i) <= 2) {
        w[i] = rational();
      }
      for (int j = i; j; j = j - 1 & i) {
        upd_min(w[j], w[i]);
      }
    }
    for (int i = 0; i < 16; ++i) {
      for (int j = 0; j < 1 << N; ++j) {
        dp[i][j] = rational(40000);
      }
    }
    for (int i = 0; i <= K; ++i) {
      dp[i][0] = rational();
    }
    for (int i = 1; i <= K; ++i) {
      for (int j = 1; j < 1 << N; ++j) {
        int msb = 1 << N;
        for (; !(j & msb); msb >>= 1);
        for (int k = j ^ msb; ; k = k - 1 & j) {
          upd_min(dp[i][j], max(dp[i - 1][k], w[j ^ k]));
          if (!k) break;
        }
      }
    }
    double ans = 100.0;
    for (int i = 0; i <= K; ++i) {
      upd_min(ans, dp[i][(1 << N) - 1].value());
    }
    printf("%.16lf\n", ans);
  }

}

int main() {

  solve();

  return 0;

}
