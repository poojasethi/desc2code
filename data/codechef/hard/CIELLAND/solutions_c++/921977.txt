#ifdef NALP_PROJECT
#pragma hdrstop
#endif

#define _CRT_SECURE_NO_DEPRECATE
#pragma comment(linker, "/STACK:64000000")

#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <cctype>
#include <cmath>
#include <algorithm>
#include <utility>

#include <set>
#include <map>
#include <vector>
#include <string>
#include <queue>
#include <memory.h>

#include <iostream>
#include <sstream>

using namespace std;

typedef long long int64;

#define forn(i, n) for(int i = 0; i < (int)(n); i++)
#define ford(i, n) for(int i = (int)(n) - 1; i >= 0; i--)
#define pb push_back
#define mp make_pair
#define X first
#define Y second
#define y1 YYYYYYYYYYYY1
#define all(a) (a).begin(), (a).end()
#define rall(a) (a).rbegin(), (a).rend()
#define Abs(x) (((x) >= 0) ? (x) : (-(x)))

const int INF = (int)1E9;
const int64 INF64 = (int64)1E18;
const long double EPS = 1E-9;
const long double PI = 3.1415926535897932384626433832795;

struct point {
	double x, y;

	point() {}

	point(double x, double y) : x(x), y(y) {}
};

struct line {
	long double A, B, C;

	line() {}

	line(const point &a, const point &b, double r){
		A = a.y - b.y;
		B = b.x - a.x;
		double l = sqrt(A*A + B*B);
		A /= l; B /= l;
		C = - (A*a.x + B*a.y) + r;
	}

	inline double dist(const point &p) const {
		return abs(A*p.x + B*p.y + C);
	}
};

const int MAXN = 13;

int n, k, d[1 << MAXN];
double r;
point p[MAXN];
bool g[1 << MAXN];
int b[1 << MAXN];

int get(int mask) {
	if (mask == 0) return 0;
	if (b[mask] <= 2) return 1;
	int &ans = d[mask];
	if (ans != -1) return ans;

	ans = INF;
	for(int sm = mask; sm != 0; sm = (sm - 1) & mask)
		if (g[sm])
			ans = min(ans, get(mask - sm) + 1);

	return ans;
}

bool solve(double r) {
	memset(g, 0, sizeof g);
	ford(i, n)
		forn(j, i) {
			{
				line l(p[i], p[j], +r);
				int mask = 0;
				forn(k, n)
					if (l.dist(p[k]) - EPS < r)
						mask += 1 << k;

				g[mask] = true;
			}

			{
				line l(p[i], p[j], -r);
				int mask = 0;
				forn(k, n)
					if (l.dist(p[k]) - EPS < r)
						mask += 1 << k;

				g[mask] = true;
			}
		}

	ford(mask, 1 << n) {
		if (!g[mask]) continue;
		for(int sm = mask; sm != 0; sm = (sm - 1) & mask)
			g[sm] = true;
	}

	memset(d, 255, sizeof d);
	return get((1 << n) - 1) <= k;
}

void solve() {
	cin >> n >> k;
	forn(i, n)
		cin >> p[i].x >> p[i].y;

	double l = 0.0, r = 100;
	forn(i, 33) {
		double mid = (l + r) / 2;
		if (solve(mid))
			r = mid;
		else
			l = mid;
	}

	cout.precision(10);
	cout << fixed << (l + r) / 2 << endl;
}

int main() {
#ifdef NALP_PROJECT
	freopen("input.txt", "rt", stdin);
	freopen("output.txt", "wt", stdout);
#else
#endif

	forn(mask, 1 << MAXN)
		forn(i, MAXN)
			if ((mask & (1 << i)) != 0)
				b[mask]++;

	int tests;
	cin >> tests;
	forn(test, tests) {
		solve();
		cerr << clock() << endl;
	}
	
	return 0;
}
