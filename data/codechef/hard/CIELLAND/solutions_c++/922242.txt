#include <algorithm>
#include <cmath>
#include <cstdio>

using namespace std;

template <class T> inline void upd_min(T &lhs, T rhs) {if(lhs>rhs)lhs=rhs;}
template <class T> inline void upd_max(T &lhs, T rhs) {if(lhs<rhs)lhs=rhs;}

inline int side(int x1, int y1, int x2, int y2) {

  int i = x1 * -y2 + y1 * x2;
  return i < 0 ? -1 : !!i;

}

int T;
int N, K;
int x[16], y[16];

double w[1 << 13];
double dp[16][1 << 13];

void solve() {

  scanf("%d", &T);
  while (T--) {
    scanf("%d%d", &N, &K);
    for (int i = 0; i < N; ++i) {
      scanf("%d%d", x + i, y + i);
    }
    if (N <= K << 1) {
      printf("%.16lf\n", 0.0);
      continue;
    }
    for (int i = 0; i < 1 << N; ++i) {
      w[i] = 100.00;
    }
    for (int i = 0; i < N; ++i) {
      for (int j = i + 1; j < N; ++j) {
        double den = 2.0 * hypot(x[j] - x[i], y[j] - y[i]);
        for (int k = 0; k < N; ++k) {
          if (i == k || i == j) continue;
          double _w = ((x[k] - x[i]) * -(y[j] - y[i]) +
                       (y[k] - y[i]) * (x[j] - x[i])) / den;
          int cover = 0;
          for (int l = 0; l < N; ++l) {
            int foo = side(x[k] - x[i], y[k] - y[i],
                           x[j] - x[i], y[j] - y[i]);
            int bar = side(x[l] - x[i], y[l] - y[i],
                           x[j] - x[i], y[j] - y[i]);
            int baz = side(x[l] - x[k], y[l] - y[k],
                           x[j] - x[i], y[j] - y[i]);
            if (foo && foo * bar >= 0 && foo * baz <= 0 ||
                bar == 0 || baz == 0) {
              cover |= 1 << l;
            }
          }
          upd_min(w[cover], abs(_w));
        }
      }
    }
    for (int i = 0; i < 1 << N; ++i) {
      if (__builtin_popcount(i) <= 2) {
        w[i] = 0.0;
      }
      for (int j = i; j; j = j - 1 & i) {
        upd_min(w[j], w[i]);
      }
    }
    for (int i = 0; i <= K; ++i) {
      dp[i][0] = 0.0;
      for (int j = 1; j < 1 << N; ++j) {
        dp[i][j] = 100.0;
      }
    }
    for (int i = 1; i <= K; ++i) {
      int msb = -1;
      for (int j = 1; j < 1 << N; ++j) {
        if ((j & -j) == j) ++msb;
        for (int k = j ^ 1 << msb; ; k = k - 1 & j) {
          upd_min(dp[i][j], max(dp[i - 1][k], w[j ^ k]));
          if (!k) break;
        }
      }
    }
    printf("%.16lf\n", dp[K][(1 << N) - 1]);
  }

}

int main() {

  solve();

  return 0;

}
