/*
Farsid
BUET
*/

#include <bits/stdc++.h>
using namespace std;

#define filer() freopen("far.in","r",stdin)
#define filew() freopen("out.txt","w",stdout)

#define SET(a, x) memset((a), (x), sizeof(a))
#define ll long long
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define SZ(x) ((int)(x).size())
#define i64 ll
#define IN(A, B, C)  ((B) <= (A) && (A) <= (C))
#define MAX
#define xx first
#define yy second

typedef vector<int> VI;
typedef vector<string> VS;
typedef vector<double> VD;
typedef vector<ll> VL;
typedef pair<int,int> PII;
typedef pair<ll,ll> PLL;
const int inf=0x20202020;
//const ll mod=1000000007;
const double eps=1e-9;
const double pi=3.1415926535897932384626;

const int DX[]={1,0,-1,0},DY[]={0,1,0,-1};
//ll powmod(ll a,ll b) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll powmod(ll a,ll b,ll mod) {ll res=1;a%=mod;for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}
ll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}


template<class X>void debug(vector<X>&v){for(int i=0;i<v.size();i++)cout<<v[i]<<" ";cout<<endl;}


// multiplying primes
i64 p[3];

// prime mods
i64 mod[3];

i64 H1[100009],HR1[100009],H2[100009],HR2[100009];


int main()
{
    //filer();
	//freopen("far.in","r",stdin);
	//freopen("gadha.out","w",stdout);
    int i,j,k ,T,cas=0;
    p[0]=29;
    p[1]=37;
    mod[0]=1000000007;
    mod[1]=1000000009;

    scanf("%d",&T);
	while(T--){
		string s;
		cin>>s;
		H1[0]=s[0]%mod[0];
		H2[0]=s[0]%mod[1];
		int j=s.size();
		int sz=j;
		HR1[0]=((s[0]%mod[0])*powmod(p[0],--j,mod[0]))%mod[0];
		HR2[0]=((s[0]%mod[1])*powmod(p[1],j,mod[1]))%mod[1];

		for(i=1;i<sz;i++){
			//H1 H2
			H1[i]=((s[i]%mod[0])*powmod(p[0],i,mod[0]))%mod[0];
			H2[i]=((s[i]%mod[1])*powmod(p[1],i,mod[1]))%mod[1];
			H1[i]=(H1[i-1]+H1[i])%mod[0];
			H2[i]=(H2[i-1]+H2[i])%mod[1];

			HR1[i]=((s[i]%mod[0])*powmod(p[0],--j,mod[0]))%mod[0];
			HR2[i]=((s[i]%mod[1])*powmod(p[1],j,mod[1]))%mod[1];

			HR1[i]=(HR1[i-1]+HR1[i])%mod[0];
			HR2[i]=(HR2[i-1]+HR2[i])%mod[1];

		}

//		cout<<H1[sz-1]<<" "<<HR1[sz-1]<<endl;
//		cout<<H2[sz-1]<<" "<<HR2[sz-1]<<endl;


		i64 h1,h2,hr1,hr2;
		int cnt=0;
		if(sz & 1){
			int mid=sz/2;
			h1=H1[mid-1];
			h2=H2[mid-1];
			hr1=(HR1[sz-1]-HR1[mid]+mod[0])%mod[0];
			hr2=(HR2[sz-1]-HR2[mid]+mod[1])%mod[1];
			if(h1==hr1 && h2==hr2)cnt+=2;
			for(i=0;i<sz;i++){
				h1=-1,h2=-2,hr1=-3,hr2=-4;
				if(i==mid)continue;
				if(i<mid){
					hr1=(HR1[sz-1]-HR1[mid]+mod[0])%mod[0];
					hr2=(HR2[sz-1]-HR2[mid]+mod[1])%mod[1];
					h1=h2=0;
					if(i){
						h1=H1[i-1];
						h2=H2[i-1];
					}
					i64 a=(H1[mid]-H1[i]+mod[0])%mod[0];
					a*=powmod(p[0],mod[0]-2,mod[0]);

					i64 b=(H2[mid]-H2[i]+mod[1])%mod[1];
					b*=powmod(p[1],mod[1]-2,mod[1]);

					a%=mod[0];
					b%=mod[1];
					h1=(h1+a)%mod[0];
					h2=(h2+b)%mod[1];
				}
				else{
					h1=h2=0;
					if(mid){
						h1=H1[mid-1];
						h2=H2[mid-1];
					}

					hr1=(HR1[sz-1]-HR1[i]+mod[0])%mod[0];
					hr2=(HR2[sz-1]-HR2[i]+mod[1])%mod[1];
					i64 a=(HR1[i-1]-HR1[mid-1]+mod[0])%mod[0];
					i64 b=(HR2[i-1]-HR2[mid-1]+mod[1])%mod[1];
					a*=powmod(p[0],mod[0]-2,mod[0]);
					b*=powmod(p[1],mod[1]-2,mod[1]);
					a%=mod[0];
					b%=mod[1];
					hr1=(hr1+a)%mod[0];
					hr2=(hr2+b)%mod[1];
				}
				if(h1==hr1 && h2==hr2)cnt++;
			}
		}
		else {
			int mid;
			mid=sz/2;
			h1=H1[mid-1];
			hr1=(HR1[sz-1]-HR1[mid-1]+mod[0])%mod[0];
			h2=H2[mid-1];
			hr2=(HR2[sz-1]-HR2[mid-1]+mod[1])%mod[1];
			if(h1==hr1 && h2==hr2)cnt++;
			for(i=0;i<sz;i++){
				h1=-1,h2=-2,hr1=-3,hr2=-4;
				if(i<mid){
					hr1=(HR1[sz-1]-HR1[mid]+mod[0])%mod[0];
					hr2=(HR2[sz-1]-HR2[mid]+mod[1])%mod[1];
					if(i){
						h1=H1[i-1];
						h2=H2[i-1];
					}
					else {
						h1=0;
						h2=0;
					}
					i64 a=(H1[mid-1]-H1[i]+mod[0])%mod[0];
					a*=powmod(p[0],mod[0]-2,mod[0]);
					i64 b=(H2[mid-1]-H2[i]+mod[1])%mod[1];
					b*=powmod(p[1],mod[1]-2,mod[1]);
					a%=mod[0];
					b%=mod[1];
					h1=(h1+a)%mod[0];
					h2=(h2+b)%mod[1];
				}
				else{
					//mid--;
					int x=mid-1;
					h1=h2=0;
					if(x){
						h1=H1[x-1];
						h2=H2[x-1];
					}
					hr1=(HR1[sz-1]-HR1[i]+mod[0])%mod[0];
					hr2=(HR2[sz-1]-HR2[i]+mod[1])%mod[1];
					i64 a=(HR1[i-1]-HR1[x]+mod[0])%mod[0];
					i64 b=(HR2[i-1]-HR2[x]+mod[1])%mod[1];
					a*=powmod(p[0],mod[0]-2,mod[0]);
					b*=powmod(p[1],mod[1]-2,mod[1]);
					a%=mod[0];
					b%=mod[1];
					hr1=(hr1+a)%mod[0];
					hr2=(hr2+b)%mod[1];
				}
				if(h1==hr1 && h2==hr2)cnt++;
			}
		}
		printf("%d\n",cnt);
	}
    return 0;
}
/*Test Cases


*/