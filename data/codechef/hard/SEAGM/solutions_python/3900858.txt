# collect primes until 100
primes = [p for p in xrange(2,100) if all(p % q for q in xrange(2,p))]

def memoize(func):
    '''
    Given a function, return a memoized version of it, i.e.,
    it never calls the original function more than once given the same arguments.
    '''
    memo = {} # storage for already-calculated results
    def new_func(*args):
        if args not in memo: 
            # not found in memo, so new set of args. call func
            memo[args] = func(*args)
        return memo[args]
    return new_func

def ave(vs):
    ''' Returns the average of vs '''
    return sum(vs) / len(vs)

@memoize
def simplify(a,b):
    '''
    Normalize the primes of a, and fix b along with it.
    simplify(3*7*11^2,2*5*7*11*13) = 3*5
    '''
    res = 1
    i = 0
    for p in primes:
        if a % p == 0:
            if b % p == 0:
                res *= primes[i]
            i += 1
    return res

@memoize
def winning_optimal(g,*vs):
    '''
    Returns the probability of winning, given that the numbers are vs, the current gcd is g,
    and both players play optimally.
    '''
    n = len(vs)
    if g == 1: return 1
    if n == 0: return 0
    if g != 0: return winning_optimal(0, *sorted(simplify(g,v) for v in vs))
    return max([1 - winning_optimal(vs[i],*(vs[:i] + vs[i+1:])) for i in xrange(n)])

@memoize
def winning_random(g,*vs):
    '''
    Returns the probability of winning, given that the numbers are vs, the current gcd is g,
    and both players play randomly.
    '''
    n = len(vs)
    if g == 1: return 1.
    if n == 0: return 0.
    if g != 0: return winning_random(0, *sorted(simplify(g,v) for v in vs))
    return ave([1 - winning_random(vs[i],*(vs[:i] + vs[i+1:])) for i in xrange(n)])

z = input()
for cas in xrange(z):
    n = input()
    vs = map(int, raw_input().strip().split())
    print "%d %.4f" % (winning_optimal(0,*vs), winning_random(0,*vs))
