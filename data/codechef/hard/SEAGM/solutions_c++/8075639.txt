#include <iostream>
#include <iomanip>
 
#define DEBUG 0
#define MAX_N 100
 
using namespace std;
 
typedef long double ld;
 
bool primes[MAX_N+1];
int cards[MAX_N+1];
int divisors[MAX_N+1][4];   // max 3 prime number, index 0 -> number of primes
int profiles[MAX_N+1][8];   // indexed by profile enum
int N;  // number of cards
 
enum profile { P1=0, P2, P3, P5, P23, P25, P35, P235 };
 
void sievePrimes()
{
    for (int i = 0; i < MAX_N+1; ++i)
    {
        primes[i] = true;
    }
    for (int i = 2; i < MAX_N+1; ++i)
    {
        if (!primes[i])
        {
            continue;
        }
        for (int j = 2*i; j < MAX_N+1; j += i)
        {
            primes[j] = false;
        }
    }
}
 
void calcPrimeDivisors(int card)
{
    int cardValue = cards[card];
    int index = 1;
    for (int i = 0; i < 4; ++i)
    {
        divisors[card][i] = 0;
    }
    for (int i = 2; i < MAX_N; ++i)
    {
        if (primes[i] && (cardValue % i == 0))
        {
            divisors[card][index++] = i;
            while (cardValue % i == 0)
            {
                cardValue /= i;
            }
            if (cardValue == 1)
            {
                break;
            }
        }
    }
    divisors[card][0] = index;
}
 
int calcProfile(int div1[], int div2[])
{
    int count = 0;
    bool match[4];
    for (int i = 1; i <= 3; ++i)
    {
        match[i] = false;
        if (div1[i] == 0)
        {
            continue;
        }
        for (int j = 1; j <= 3; ++j)
        {
            if (div2[j] == 0)
            {
                continue;
            }
            if (div1[i] == div2[j])
            {
                match[i] = true;
                count++;
            }
        }
    }
    if (count == 0)
    {
        return P1;
    }
    if (count == 3)
    {
        return P235;
    }
    if (count == 1)
    {
        if (match[1])
        {
            return P2;
        }
        if (match[2])
        {
            return P3;
        }
        if (match[3])
        {
            return P5;
        }
    }
    if (!match[3])
    {
        return P23;
    }
    if (!match[2])
    {
        return P25;
    }
    if (!match[1])
    {
        return P35;
    }
    return 0;
}
 
void countProfiles(int card)
{
    for (int j = 0; j < 8; ++j)
    {
        profiles[card][j] = 0;
    }
    for (int i = 0; i < N; ++i)
    {
        if (i == card)
        {
            continue;
        }
        int profile = calcProfile(divisors[card], divisors[i]);
        profiles[card][profile]++;
    }
#if DEBUG
    cout << "PROFILE OF CARD[" << card << "] = " << cards[card] << endl;
    for (int j = 0; j < 8; ++j)
    {
        cout << profiles[card][j] << " " << endl;
    }
    cout << endl;
#endif
}
 
bool isWinnerProfile(int p[])
{
    return (((p[P2] + p[P23] + p[P25] + p[P235]) % 2) == 1) ||
           (((p[P3] + p[P23] + p[P35] + p[P235]) % 2) == 1) ||
           (((p[P5] + p[P25] + p[P35] + p[P235]) % 2) == 1);
}
 
ld tabF1[MAX_N+1][MAX_N+1];
void clearCache()
{
    for (int i = 0; i < MAX_N+1; ++i)
    {
        for (int j = 0; j < MAX_N+1; ++j)
        {
            tabF1[i][j] = -1;
        }
    }
}
 
ld F1(int N1, int N2)
{
#if DEBUG
    cout << "F1 (" << N1 << "," << N2 << ")" << endl;
#endif
    if (N2 <= 0)
    {
        return 0;
    }
    if (tabF1[N1][N2] < 0)
    {
        tabF1[N1][N2] = (ld) N2 * (1 - F1(N1, N2-1));
    }
#if DEBUG
    cout << "RES: " << tabF1[N1][N2] << endl;
#endif
    return tabF1[N1][N2] / (N1 + N2);
}
 
ld F2_1(int N1, int N2, int N3, int N23)
{
#if DEBUG
    cout << "F2_1 (" << N1 << "," << N2 << "," << N3 << "," << N23 << ")" << endl;
#endif
    ld sum = N1 + N2 + N3 + N23;
    if (sum <= 0)
    {
        return 0;
    }
    ld result = N2 * (1 - F1(N1 + N3, N2-1 + N23))
              + N3 * (1 - F1(N1 + N2, N3-1 + N23));
    if (N23)
    {
              result += N23 * (1 - F2_1(N1, N2, N3, N23-1));
    }
#if DEBUG
    cout << "RES: " << (result/sum) << endl;
#endif
    return result/sum;
}
 
ld reduceP2(int p[])
{
    if (!p[P2]) return 0;
 
    ld p1 = p[P1] + p[P3] + p[P5] + p[P35];
    ld p2 = p[P2]-1 + p[P23] + p[P25] + p[P235];
    return 1 - F1(p1, p2);
}
 
ld reduceP3(int p[])
{
    if (!p[P3]) return 0;
 
    ld p1 = p[P1] + p[P2] + p[P5] + p[P25];
    ld p2 = p[P3]-1 + p[P23] + p[P35] + p[P235];
    return 1 - F1(p1, p2);
}
 
ld reduceP5(int p[])
{
    if (!p[P5]) return 0;
 
    ld p1 = p[P1] + p[P2] + p[P3] + p[P23];
    ld p2 = p[P5]-1 + p[P25] + p[P35] + p[P235];
    return 1 - F1(p1, p2);
}
 
ld reduceP23(int p[])
{
    if (!p[P23]) return 0;
 
    ld p1 = p[P1] + p[P5];
    ld p2 = p[P2] + p[P25];
    ld p3 = p[P3] + p[P35];
    ld p23 = p[P23]-1 + p[P235];
    return 1 - F2_1(p1, p2, p3, p23);
}
 
ld reduceP25(int p[])
{
    if (!p[P25]) return 0;
 
    ld p1 = p[P1] + p[P3];
    ld p2 = p[P2] + p[P23];
    ld p3 = p[P5] + p[P35];
    ld p23 = p[P25]-1 + p[P235];
    return 1 - F2_1(p1, p2, p3, p23);
}
 
ld reduceP35(int p[])
{
    if (!p[P35]) return 0;
 
    ld p1 = p[P1] + p[P2];
    ld p2 = p[P3] + p[P23];
    ld p3 = p[P5] + p[P25];
    ld p23 = p[P35]-1 + p[P235];
    return 1 - F2_1(p1, p2, p3, p23);
}
 
ld reduceP235(int p[], bool decrease=false)
{
    if (decrease)
    {
        if (!p[P235]) return 0;
        p[P235]--;
    }
    ld sum = 0;
    for (int i = P1; i <= P235; sum += p[i++]);
#if DEBUG
    cout << "SUM: " << sum << endl;
#endif
    if (sum <= 0)
    {
        return 1;
    }
 
    ld result = p[P2] * reduceP2(p)
              + p[P3] * reduceP3(p)
              + p[P5] * reduceP5(p)
              + p[P23] * reduceP23(p)
              + p[P25] * reduceP25(p)
              + p[P35] * reduceP35(p)
              + p[P235] * reduceP235(p, true);
#if DEBUG
    cout << "P2: " << p[P2] << " RESULT: " << result << ", " << (1-(result/sum)) << endl;
#endif
 
    return 1 - (result / sum);
}
 
ld calcProfileProbability(int p[])
{
    return reduceP235(p);
}
 
void testCase()
{
    cin >> N;
    for (int i = 0; i < N; ++i)
    {
        cin >> cards[i];
        calcPrimeDivisors(i);
    }
    for (int i = 0; i < N; ++i)
    {
        countProfiles(i);
    }
    bool winsA = false;
    ld sumProb = 0;
    for (int i = 0; i < N; ++i)
    {
        if (cards[i] == 1) continue;
 
        if (!winsA && !isWinnerProfile(profiles[i]))
        {
            winsA = true;
        }
        ld prob = calcProfileProbability(profiles[i]);
#if DEBUG
        cout << "Probability of card: " << cards[i] << " = " << prob << endl;
#endif
        sumProb += prob;
    }
    cout << setprecision(4);
    cout << (winsA ? 1 : 0) << " " << fixed << (sumProb/N) << endl;
}
 
int main()
{
    sievePrimes();
    clearCache();
    
    int T;
    cin >> T;
    for (int i = 0; i < T; ++i)
    {
        testCase();
    }
    
    return 0;
}  