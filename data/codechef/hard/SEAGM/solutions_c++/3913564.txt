#include<bits/stdc++.h>

using namespace std;

// Input macros
#define s(n)                        scanf("%d",&n)
#define _sc(n)                       scanf("%c",&n)
#define sl(n)                       scanf("%lld",&n)
#define sf(n)                       scanf("%lf",&n)
#define ss(n)                       scanf("%s",n)

// Useful constants
#define INF                         (int)1e9
#define EPS                         1e-9

// Useful hardware instructions
#define bitcount                    __builtin_popcount

// Useful container manipulation / traversal macros
#define all(a)                      a.begin(), a.end()
#define in(a,b)                     ( (b).find(a) != (b).end())
#define pb                          push_back
#define fill(a,v)                    memset(a, v, sizeof a)
#define sz(a)                       ((int)(a.size()))
#define mp                          make_pair
#define f                           first
#define sc                          second

#define SSTR( x ) dynamic_cast< std::ostringstream & >( \
        ( std::ostringstream() << std::dec << x ) ).str() // converting number (x) to string
#define SST(x) atoi(x) // converting a char array x to number

// Some common useful functions
#define checkbit(n,b)                ( (n >> b) & 1)
#define DREP(a)                      sort(all(a)); a.erase(unique(all(a)),a.end())
#define INDEX(arr,ind)               (lower_bound(all(arr),ind)-arr.begin())

typedef long long LL;
typedef vector<int> VI;
typedef vector<VI> VVI;
typedef pair<int,int> pp;
typedef vector<string> VS;

#define fr(i,s,n)    for(int i=s;i<(n);++i)
#define MOD 1000000007

#define trace1(x)                cerr << #x << ": " << x << endl;
#define trace2(x, y)             cerr << #x << ": " << x << " | " << #y << ": " << y << endl;
#define trace3(x, y, z)          cerr << #x << ": " << x << " | " << #y << ": " << y << " | " << #z << ": " << z << endl;
#define trace4(a, b, c, d)       cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << endl;
#define trace5(a, b, c, d, e)    cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << endl;
#define trace6(a, b, c, d, e, f) cerr << #a << ": " << a << " | " << #b << ": " << b << " | " << #c << ": " << c << " | " << #d << ": " << d << " | " << #e << ": " << e << " | " << #f << ": " << f << endl;

int n;
int a[100];
int dp[200][200];
float memo1[200][200];


float prob_winning(int g,int taken,int n)
{
    if(memo1[g][taken]==-1)
    {


        if(g==1)
            memo1[g][taken]= 1.0;
        else if(taken==n)
            memo1[g][taken]= 0.0;
        else
        {


            int tot=0;
            float c=0.0,c1=0.0;
            for(int i=0;i<n;i++)
            {
                if(a[i]%g == 0)
                    tot++;
                else
                    c1=c1+  (1.0-  prob_winning(__gcd(g,a[i]) ,taken+1,n) ) ;
            }

            int residual=tot-taken;

            c=(1.0- prob_winning(g,taken+1,n));
            c= c * (float)residual;

            memo1[g][taken]=(c+c1)/(n-taken);
        }
    }
    return memo1[g][taken];
}


int f(int gcd,int cnt)
{
    int& res=dp[gcd][cnt];
    if(res==-1)
    {
        res=0;
        if(gcd==1)res=1;
        else if(cnt<n)
        {
            if(gcd==0)
            {
                for(int i=0;i<n;++i)
                {
                    if(f(a[i],1)==0)res=1;
                }
            }
            else
            {
                int c=0;
                for(int i=0;i<n;++i)
                {
                    if(a[i]%gcd==0)c++;
                    else
                    {
                        if(f(__gcd(gcd,a[i]),cnt+1)==0)res=1;
                    }
                }
                if(c>cnt)
                {
                    if(f(gcd,cnt+1)==0)res=1;
                }
            }
        }
    }
    return res;
}

int main()
{
    int t;
    s(t);

    while(t--)
    {
        s(n);
        for(int i=0;i<n;++i)s(a[i]);

        fill(dp,-1);

        int res1=1;
        for(int i=0;i<n;i++)
        {

            res1=f(a[i],1);
            if(res1==0)
                break;
        }
   /*     //if(res1==0)
      //      printf("1 ");
    //    else
  //          printf("0 ");

*/
        int ans=1-res1;



        for(int i=0;i<200;i++)
        {
            for(int j=0;j<200;j++)
            {
            memo1[i][j]=-1;
            }
        }
        float res=0;
        for(int i=0;i<n;++i)
        {
            res=res + (float)(1.0-prob_winning(a[i],1,n));
        }



        float ans1=res/(float) n;




        printf("%d %.4f\n",ans,ans1);
    }

     return 0;
}
