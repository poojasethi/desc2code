#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<set>
#include<map>
#include<string>
#include<string.h>
#include<cstring>
#include<stack>
#include<queue>
#include<cassert>
#include<cmath>
using namespace std;

#define LL long long int
#define PII pair<int,int>
#define PB push_back
#define MP make_pair
#define INF 1000000000
#define debug(args...) do {cerr << #args << ": "; dbg,args; cerr << endl;} while(0)

stack<PII> st, st1;
int BIT[200000];
int rnd[200000];
int mtch[200000];
int MX;
string s;
void U(int x,int val){
    x += 5;
    while(x < MX){
        BIT[x] += val;
        x += (x&-x);
    }
}
int Q(int x){
    int ret = 0;
    x += 5;
    while(x > 0){
        ret += BIT[x];
        x -= (x&-x);
    }
    return ret;
}
class RMQ{
    public:
    struct node {
        node *lft, *rgt;
        int cmax;
        node(){
            lft = rgt= NULL;
            cmax = 0;
        }
    };
    node *top;
    int N;
    RMQ(int n){
        top = NULL;
        N = n;
    }
    int _update(node *&cur, int cl, int cr, int loc, int val){
        if(loc < cl || loc > cr)
            return (cur == NULL? 0:cur->cmax);
        if(cur == NULL)
            cur = new node();
        if(cl == loc && cl == cr)
            return cur->cmax = val;
        int mid = (cl + cr)/2;
        return cur->cmax = max(_update(cur->lft, cl, mid, loc, val), _update(cur->rgt,mid + 1, cr, loc, val ));
    }
    int _query(node *&cur, int cl, int cr, int al, int ar){
        if(cl > ar || al > cr)
            return 0;
        if(cur == NULL)
            return 0;
        if(cl >= al && cr <= ar)
            return cur->cmax;
        int mid = (cl + cr)/2;
        return max(_query(cur->lft, cl , mid, al, ar), _query(cur->rgt, mid + 1, cr, al, ar));
    }
    void U(int loc, int val){
        _update(top, 0,N, loc, val);
    }
    int Q(int al, int ar){
        return _query(top, 0, N, al, ar);
    }
};
RMQ* rmq;
vector<PII> ord;
int main(){
    int t,i,n;
    cin >> t;
    while(t--){
        cin >> n;
        MX = n + 100;
        memset(BIT,0,sizeof(int)*(n+100));
        memset(rnd,-1,sizeof(int)*(n+100));
        memset(mtch,-1,sizeof(int)*(n+100));
        cin >> s;
        st  = st1;
        rmq = new RMQ(MX);
        LL ans = 0;
        ord.clear();
        for(i=0;i<(int)s.size();i++){
            if(st.size() == 0){
                st.push(MP(s[i]-'0', i));
                continue;
            }
            if(s[i] == '4')
                st.push(MP(4, i));
            else{
                if(st.top().first == 4){
                    mtch[st.top().second] = i;
                    rnd[st.top().second] = rmq->Q(st.top().second, i) + 1;
                    rmq->U(st.top().second, rnd[st.top().second]);
                    ord.PB(MP(rnd[st.top().second], -st.top().second));
                    st.pop();
                }
                else
                    st.push(MP(7,i));
            }
        }
        sort(ord.begin(), ord.end());
        for(i=0;i<(int)ord.size();i++){
            LL cloc = -ord[i].second;
            ans += cloc  + 1 + (LL)Q(cloc);
            U(cloc,-1);
            U(mtch[cloc], -1);
        }
        cout<<ans<<endl;
    }
    return 0;
}

