#include <vector>
#include <queue>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>

using namespace std;

#define fi first
#define se second
#define mp make_pair
#define sz(x) ((int)(x).size())
#define re return
#define pb(x) push_back(x)
#define pf(x) push_front(x)
#define abs(x) ((x) < 0 ? -(x) : (x))
#define INF 2000000000
#define sqr(x) ((x) * (x))
#define all(x) x.begin(), x.end()
#define fname "a"
#define MOD 1000000007

int t, n;
string s;
long long p[111111], tt[511111], res, ttt[511111];
stack < int > q;

int get(int v, int l, int r, int A, int B) {
	if(r < A || l > B) re 0;
	if(A <= l && r <= B) re tt[v];
	int m = (l + r) / 2;
	re get(v * 2, l, m, A, B) + get(v * 2 + 1, m + 1, r, A, B);
}
void update(int v, int l, int r, int x) {
	if(l == r) tt[v]++;
	else {
		int m = (l + r) / 2;
		if(x <= m) update(v * 2, l, m, x); else update(v * 2 + 1, m + 1, r, x);
		tt[v] = tt[v * 2] + tt[v * 2 + 1];
	}
}

int getmax(int v, int l, int r, int A, int B) {

	if(r < A || l > B) re 0;
	if(A <= l && r <= B) re ttt[v];
	int m = (l + r) / 2;
	re max(getmax(v * 2, l, m, A, B) , getmax(v * 2 + 1, m + 1, r, A, B));
}

void up(int v, int l, int r, int x, int val) {
	if(l == r) ttt[v] = val;
	else {
		int m = (l + r) / 2;
		if(x <= m) up(v * 2, l, m, x, val); else up(v * 2 + 1, m + 1, r, x, val);
		ttt[v] = max(ttt[v * 2], ttt[v * 2 + 1]);
	}
}


int main() {

	//freopen(fname".in", "r", stdin);
	//freopen(fname".out", "w", stdout);

	cin >> t;
	while(t--) {
		scanf("%d", &n);
		cin >> s; 
		res = 0;
		for(int i = 1; i <= n; i++) p[i] = 0;
		for(int i = 1; i <= 4 * n; i++) tt[i] = 0, ttt[i] = 0;
		while(!q.empty()) q.pop();
		for(int i = 1; i <= n; i++) {
			if(s[i - 1] == '4') q.push(i);
			else
			if(s[i - 1] == '7' && sz(q)) {
				int l = q.top();
				q.pop();
				p[l] = p[i] = getmax(1, 1, n, l + 1, i) + 1;
				up(1, 1, n, l, p[l]);
			}
		}
		for(int i = 1; i <= n; i++) {
			if(s[i - 1] == '4' && p[i]) {
				//cout << i << " " << p[i] << " ";
				int k = get(1, 1, n, 1, p[i] - 1);
				res += i - 2 * k;
				update(1, 1, n, p[i]);
				//cout << i - 2 * k << "\n";
			}
		}
		printf("%lld\n", res);

	}
	re 0;
}






