#include <iostream>
#include <sstream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
#include <stack>
#include <vector>

using namespace std;

#define SI ({int x;scanf("%d",&x);x;})
#define getSize(x) ((int) (x).size()) 
#define SLL ({LL x;scanf("%lld",&x);x;})
#define MP make_pair
#define PB push_back
#define PII pair<int,int>
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define getSize(x) ((int) (x).size()) 
char A[110000];
int lev[110000];

struct vertex
{
     int val;
     /*
      * int maxSum;
      * int leftSum;
      * int rightSum;
      * int sum;
      */
};

class SegmentTree
{
     private:
	  int N;
	  int *Lazy;
	  vertex *Tree;

     public:
	  SegmentTree(int S = (1<<20))
	  {
	       N = S;
	       Lazy = new int[4 * N];
	       Tree = new vertex[4 * N];
	  }

	  void build(int node=1, int start=1, int end=-1)
	  {
	       if(end == -1)
		    end = N;
	       if(start == end)
	       {
		    // Store what you want to store in the leaf.
		    // For example we store the value of global array A[end]
		    Tree[node].val = lev[end];
		    Lazy[node] = 0;
	       }
	       else
	       {
		    build(2 * node, start, start + (end - start) / 2);
		    build(2 * node + 1, 1 + start + (end - start) / 2, end);

		    // Assign a value depending on the left and right nodes to this node
		    // For example we assign the minimum of the left and the right nodes to this node
		    Tree[node].val = max(Tree[2 * node].val, Tree[2 * node + 1].val);
		    Lazy[node] = 0;
	       }
	  }

	  // Increment the Tree from index s to e with the value "inc"
	  void update(int s, int e, int inc, int node=1, int start=1, int end=-1)
	  {
	       if(end == -1)
		    end = N;
	       if(s > e)
		    return;
	       if(Lazy[node] != 0) // This node needs to be updated
	       {
		    Tree[node].val += Lazy[node];
		    if(start != end) // Mark children as Lazy
		    {
			 Lazy[2 * node] += Lazy[node];
			 Lazy[2 * node + 1] += Lazy[node];
		    }
		    Lazy[node] = 0; // Reset it
	       }

	       if((start > e) || (end < s)) // Completely out of range
		    return;

	       if((start >= s) && (end <= e)) // Completely within range
	       {
		    Tree[node].val += inc; // Increment the value

		    if(start != end)
		    {
			 Lazy[2 * node] += inc;
			 Lazy[2 * node + 1] += inc;
		    }
		    return;
	       }

	       update(s, e, inc, 2 * node, start, start + (end - start) / 2); // Update Left Child
	       update(s, e, inc, 2 * node + 1, 1 + start + (end - start) / 2, end); // Update Right Child

	       Tree[node].val = max(Tree[2 * node].val, Tree[2 * node + 1].val); // The value of Children might have been modified
	  }

	  // Query for the minimum value from index s to e
	  int query(int s, int e, int node=1, int start=1, int end=-1)
	  {
	       if(end == -1)
		    end = N;
	       if(s > e)
		    return 0;
	       if((start > e) || (end < s)) // Out of range value, return a value which DOESN'T MATTER
		    return 0; // In case of Range Minimum Query, it is INF

	       if(Lazy[node] != 0) // This node needs to be updated
	       {
		    Tree[node].val += Lazy[node];
		    if(start != end) // Mark children as Lazy
		    {
			 Lazy[2 * node] += Lazy[node];
			 Lazy[2 * node + 1] += Lazy[node];
		    }
		    Lazy[node] = 0; // Reset it
	       }

	       if((start >= s) && (end <= e)) // Completely within range
		    return Tree[node].val;

	       int leftQuery = query(s, e, 2 * node, start, start + (end - start) / 2);
	       int rightQuery = query(s, e, 2 * node + 1, 1 + start + (end - start) / 2, end);

	       return max(leftQuery, rightQuery);
	  }
};

const int maxVal = 100001;
int BIT[maxVal];
void U(int x, int val)
{
     x += 5;
     for(;x <= maxVal;x += (x&(-x)))
	  BIT[x] += val;
}
int Q(int x)
{
     x += 5;
     int res = 0;
     for(;x > 0; x -= (x&(-x)))
	  res += BIT[x];
     return res;
}

int main(int argc, char** argv)
{
     int T = SI;
     while(T --)
     {
	  stack< pair<int,int> > myst;
	  memset(lev, 0, sizeof(lev));
	  memset(BIT, 0, sizeof(BIT));
	  int L = SI, pos;
	  long long res = 0;
	  scanf("%s", A);

	  SegmentTree S(L+1);
	  S.build();
	  for(int i = 0; i < L; ++i)
	  {
	       if(A[i] == '4')
		    myst.push(MP(4, i));
	       else
	       {
		    if(myst.empty() || myst.top().first != 4)
			 myst.push(MP(7, i));
		    else
		    {
			 pos = myst.top().second;
			 myst.pop();
			 lev[pos] = max(0,S.query(pos+1, i-1)) + 1;
			 S.update(pos, pos, lev[pos]);
		    }
	       }
	  }
	  for(int i = 0; i < L; ++i)
	  {
	       if(lev[i] == 0)
		    continue;
	       res = res + (1LL + i) - (2LL * Q(lev[i] - 1));
	       U(lev[i], 1);
	  }
	  cout << res << endl;
     }
     return 0;
}

