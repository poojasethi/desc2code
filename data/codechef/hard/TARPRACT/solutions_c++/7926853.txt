#include<stdio.h>
#include<string.h>
#include<math.h>
#include<ctype.h>
#include<stdlib.h>
#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<queue>
#include<stack>
 
using namespace std;
 
typedef long long LL;
typedef vector<int> VI;
typedef vector<string> VS;
typedef pair<int,int> II;
typedef vector<II> VII;
typedef vector<VII> VVII;
typedef vector<VI> VVI;
 
#define INF 2000000000
#define INFLL (1LL<<62)
#define FI first
#define SE second
#define PB push_back
#define SS ({int x;scanf("%d", &x);x;})
#define SSL ({LL x;scanf("%lld", &x);x;})
 
double dp[1<<18];
 
int main()
{
	int i,j,k,n,t;
	double a,b,c;
	scanf("%d",&t);
	while(t--)
	{
		n=SS;
		a=SS/100.;
		b=SS/100.;
		c=SS/100.;
		dp[0]=0;
		for(i=1;i<(1<<n);i++)
		{
			dp[i]=1e80;
			//improvisation for continious two 0s
			for(j=0;j<=n-3;j++)
				if(((i>>j)&3)==0)
				{
					int t1=i&((1<<j)-1);
					int t2=(i-t1);
					if(t2 && t1)
					{
						dp[i]=dp[t1]+dp[t2];
						break;
					}
				}
			//improvisation ends :P
			if(j>n-3)
			{
				for(j=0;j<n;j++)
				{
					double num=1,den=1;
					bool flag=false;
					int mask=1<<j;
					if(j>0 && (i&(mask>>1)))
					{
						num+=a*dp[i^(mask>>1)];
						flag=true;
					}
					else
						den-=a;
					if(j<n-1 && (i&(mask<<1)))
					{
						num+=c*dp[i^(mask<<1)];
						flag=true;
					}
					else
						den-=c;
					if(i&(mask))
					{
						num+=b*dp[i^(mask)];
						flag=true;
					}
					else
						den-=b;
					if(flag)
						dp[i]=min(dp[i],num/den);
				}
			}	
		}
		printf("%.6f\n",dp[(1<<n)-1]);
	}
	return 0;
} 
