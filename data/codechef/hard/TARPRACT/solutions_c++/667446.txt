/*
 * 2011-09-19  Martin  <Martin@Martin-desktop>

 * 
 */
#include <climits>
#include <cstdio>
#include <cstring>
#include <cctype>
#include <cmath>
#include <ctime>
#include <cstdlib>
#include <cstdarg>
#include <iostream>
#include <fstream>
#include <iomanip>
#include <sstream>
#include <exception>
#include <stdexcept>
#include <memory>
#include <locale>
#include <bitset>
#include <deque>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <vector>
#include <algorithm>
#include <iterator>
#include <functional>
#include <string>
#include <complex>
#include <valarray>

using namespace std;

template <class T> inline T checkmin(T &a, T b)
{
	return (a < b) ? a : a = b;
}

template <class T> inline T checkmax(T &a, T b)
{
	return (a > b) ? a : a = b;
}

template <class T> T GCD(T a, T b)
{
	if (a < 0)
		return GCD(- a, b);
	if (b < 0)
		return GCD(a, - b);
	return (a == 0) ? b : GCD(b % a, a);
}

template <class T> T LCM(T a, T b)
{
	if (a < 0)
		return LCM(- a, b);
	if (b < 0)
		return LCM(a, - b);
	return (a == 0 || b == 0) ? 0 : a / GCD(a, b) * b;
}

#define tr(i, x) for (typeof(x.begin()) i = x.begin(); i != x.end(); ++ i)
#define rep(i, n) for (int i = 0; i < n; ++ i)
#define pii pair <int, int>
#define mp make_pair
#define pb push_back
#define x first
#define y second
#define ll long long

namespace Poor
{
	const int MaxiN = 18;
	
	long double Opt[1 << MaxiN];
	long double P[3];
	
	void Run()
	{
		int TestCase;
		scanf("%d", &TestCase);
		rep (i, TestCase)
		{
			int N, A, B, C;
			scanf("%d%d%d%d", &N, &A, &B, &C);
			P[0] = (double) A / 100.0;
			P[1] = (double) B / 100.0;
			P[2] = (double) C / 100.0;
			fill(Opt, Opt + (1 << N), INT_MAX);
			Opt[0] = 0;
			for (int Sit = 1; Sit < (1 << N); ++ Sit)
			{
				if ((Sit & 3) == 0 && (Sit & (1 << (N - 1))) == 0)
				{
					Opt[Sit] = Opt[Sit >> 1];
					continue;
				}
				bool Stop = 0;
				rep (i, N - 1)
					if ((Sit & (1 << i)) == 0 && (Sit & (1 << (i + 1))) == 0)
					{
						int Part = Sit & ((1 << i) - 1);
						if (Part > 0 && (Sit ^ Part) > 0)
						{
							Stop = 1;
							Opt[Sit] = Opt[Part] + Opt[Sit ^ Part];
							break;
						}
					}
				if (Stop)
					continue;
				rep (i, N)
				{
					bool Flag = 0;
					long double Fail = 0;
					for (int t = - 1; t <= 1; ++ t)
					{
						if (i + t >= 0 && i + t < N && ((Sit & (1 << (i + t))) > 0))
							Flag = 1;
						else
							Fail += P[t + 1];
					}
					if (!Flag || Fail > 0.999)
						continue;
					long double Val = 0.0;
					for (int t = - 1; t <= 1; ++ t)
						if (i + t >= 0 && i + t < N && ((Sit & (1 << (i + t))) > 0))
							Val += P[t + 1] / (1.0 - Fail) * Opt[Sit ^ (1 << (i + t))] + P[t + 1] / (1.0 - Fail) / (1.0 - Fail);
					checkmin(Opt[Sit], Val);
				}
			}
			printf("%.6lf\n", (double) Opt[(1 << N) - 1]);
			//~ for (int i = 1; i <= N; ++ i)
				//~ for (int a = 0; a <= 1; ++ a)
					//~ for (int b = 0; b <= 1; ++ b)
						//~ Opt[i][a][b] = INT_MAX;
			//~ for (int a = 0; a <= 1; ++ a)
				//~ for (int b = 0; b <= 1; ++ b)
					//~ Opt[0][a][b] = 0;
			//~ for (int i = 1; i <= N; ++ i)
				//~ for (int a = 0; a <= 1; ++ a)
					//~ for (int b = 0; b <= 1; ++ b)
					//~ {
						//~ for (int j = 2; j < N; ++ j)
							//~ checkmin(Opt[i][a][b], (p * (Opt[j - 2][a][1] + Opt[N - j + 1][1][b]) + q * (Opt[j - 1][a][1] + Opt[N - j][1][b]) + r * (Opt[j][a][1] + Opt[N - j - 1][1][b])) + 1.0);
						//~ if (i == 1)
						//~ {
							//~ checkmin(Opt[i][a][b], 1.0 / q);
						//~ }
						//~ else
						//~ {
							//~ checkmin(Opt[i][a][b], q / (1.0 - p) / (1.0 - p) * Opt[i - 1][1][b] + r / (1.0 - p) / (1.0 - p) * (Opt[1][a][1] + Opt[i - 2][1][b]));
							//~ checkmin(Opt[i][a][b], q / (1.0 - r) / (1.0 - r) * Opt[i - 1][a][1] + p / (1.0 - r) / (1.0 - r) * (Opt[i - 2][a][1] + Opt[1][1][b]));
						//~ }
					//~ }
		}
	}
}

int main(int argc, char** argv)
{
	#ifndef ONLINE_JUDGE
	freopen("TARPRACT.in", "r", stdin);
	freopen("TARPRACT.out", "w", stdout);
	#endif
	Poor::Run();
	return 0;
}
