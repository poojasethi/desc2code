#include<iostream>
#include<cstdio>
#include<stack>
#include<queue>
#include<set>
#include<iomanip>
#include<complex>
#include<vector>
#include<map>
#include<algorithm>
#include<cmath>
#include<string>
#include<bitset>
#include<memory.h>
#include<cassert>
#include<ctime>
#ifndef ONLINE_JUDGE
#include<conio.h>
#endif

#pragma comment(linker, "/stack:30000000")

using namespace std;

#define For(i,l,r) for (int i = l ;i < r ; ++ i )
#define ForI(it , s , T) for (T :: iterator it = s.begin(); it != s.end() ; ++ it )
#define LL long long
#define iinf 2000000000
#define linf 4000000000000000000LL
#define MOD  (1LL<<32)
#define Pi 3.1415926535897932384
#define bit(mask,i) ((mask>>i)&1)
#define pb(x) push_back(x)
#define mk(x,y) make_pair(x,y)
#define sqr(x) ((x)*(x))
#define pause cin.get();cin.get();
#define fir first
#define sec second
#define ln(x) log(x)
#define pi pair<int,int>      
int i,j,k,n,m,dp[19][60][40][30][30],ans[39][60][40][30][30];
int deg[10][4]={
               { 0,0,0,0 },
               { 0,0,0,0 },
               { 1,0,0,0 },
               { 0,1,0,0 },
               { 2,0,0,0 },
               { 0,0,1,0 },
               { 1,1,0,0 },
               { 0,0,0,1 },
               { 3,0,0,0 },
               { 0,2,0,0 }
               };

main()
{
      dp[0][0][0][0][0]=1;
      /*
   For(l,0,19) For(n2,0,3*l+1) For(n3,0,2*l+1) { if(n2/3+n3/2>l) continue;
   For(n5,0,l+1) For(n7,0,l+1) {
   if(dp[l][n2][n3][n5][n7]==0) continue;
   if(n2/3+n3/2+n5+n7>l) continue;
   For(d,1,10)
   dp[l+1][n2+deg[d][0]][n3+deg[d][1]][n5+deg[d][2]][n7+deg[d][3]]+=dp[l][n2][n3][n5][n7];
   }
   }*/
   for(int L=0; L<=18; L++)
	  for(int m2=0;m2 <= L*3; m2++)  // m2 will go till 3*L --> in case of all 8's
		 for(int m3=0; m3 <= 2*L && (m2/3 + m3/2 <=L); m3++) // m3 will go till 2*L --> in case of all 9's
			for(int m5 =0; m5 <= L; m5++)
			   for(int m7=0; m7<= L; m7++)
			   {
				  if(m2/3+m3/2+m5+m7 > L) continue; 
				  LL cnt = dp[L][m2][m3][m5][m7];  
				  if(cnt==0) continue;
				  // For every possible value of next number we can fill the DP table
				  dp[L+1][m2][m3][m5][m7]+=cnt;   // 1   1
				  dp[L+1][m2+1][m3][m5][m7]+=cnt; // 2   2
				  dp[L+1][m2][m3+1][m5][m7]+=cnt; // 3   3
				  dp[L+1][m2+2][m3][m5][m7]+=cnt; // 4   2*2
				  dp[L+1][m2][m3][m5+1][m7]+=cnt; // 5   5
				  dp[L+1][m2+1][m3+1][m5][m7]+=cnt;// 6  2*3
				  dp[L+1][m2][m3][m5][m7+1]+=cnt; // 7   7
				  dp[L+1][m2+3][m3][m5][m7]+=cnt; // 8   2*2*2
				  dp[L+1][m2][m3+2][m5][m7]+=cnt; // 9   3*3
			   }

   
      for(int L=1; L<=18; L++)
   {
	  for(int m2=0;m2<=L*3; m2++)
		 for(int m3=0;m3<=2*L && (m2/3+m3/2)<=L ;m3++)
			for(int m5=0;m5<=L; m5++)
			   for(int m7=0;m7<=L;m7++)
			   {
				  //For a given 2*L Length number, L/2 will be Length of Denominator, L-L/2 will be of Numerator
				  // m2, m3, m5, m7 are the powers of 2,3,5,7 respectively for Numerator

				  LL cnt = dp[L][m2][m3][m5][m7];
				  if(cnt==0) continue;
 				 // Iterating over all possible powers of 2,3,5,7 for Denomiator which are less than Numerator's.
				  for(int L2=L-1;L2<=L;L2++)
					 for(int n2=0; n2<= m2; n2++)
						for(int n3=0; n3 <= m3; n3++)
						   for(int n5=0; n5 <= m5; n5++)
							  for(int n7=0; n7 <= m7;n7++)
								 ans[L+L2][m2-n2][m3-n3][m5-n5][m7-n7] += cnt*dp[L2][n2][n3][n5][n7];
				  				 // Total lenght will be L+L2, and powers will be (m2-n2), (m3-n3) ,(m5-n5) , (m7-n7) for 2,3,5 & 7.
			   }
   }
   ans[1][0][0][0][0]=1;
   ans[1][1][0][0][0]=1;
   ans[1][0][1][0][0]=1;
   ans[1][2][0][0][0]=1;
   ans[1][0][0][1][0]=1;
   ans[1][1][1][0][0]=1;
   ans[1][0][0][0][1]=1;
   ans[1][3][0][0][0]=1;
   ans[1][0][2][0][0]=1;

/*
   ans[0][0][0][0][0]=0;
   
   For(l1,1,19) For(n2,0,3*l1+1) For(n3,0,2*l1+1) { if(n2/3+n3/2>l1) continue;
   For(n5,0,l1+1) For(n7,0,l1+1) {
   if(dp[l1][n2][n3][n5][n7]==0) continue;
   
   For(l2,l1-1,l1+1) For(m2,0,n2+1) For(m3,0,n3+1) For(m5,0,n5+1) For(m7,0,n7+1) ans[l1+l2][n2-m2][n3-m3][n5-m5][n7-m7]+=dp[l1][n2][n3][n5][n7]*dp[l2][m2][m3][m5][m7];
   }
   }
   
   ans[1][0][0][0][0]=1;
   ans[1][1][0][0][0]=1;
   ans[1][0][1][0][0]=1;
   ans[1][2][0][0][0]=1;
   ans[1][0][0][1][0]=1;
   ans[1][1][1][0][0]=1;
   ans[1][0][0][0][1]=1;
   ans[1][3][0][0][0]=1;
   ans[1][0][2][0][0]=1;
   */
   
   LL p9[37],p10[37],ans0[37];
   p9[0]=p10[0]=1;

   for(int n=1;n<=36;n++)
   {
	  p9[n]=(9*p9[n-1])%MOD;
	  p10[n]=(10*p10[n-1])%MOD;           // Handling case when V = 0;
	  int n1=(n-1)/2;
	  ans0[n] = (p10[n1]-p9[n1])*p9[n-n1];
	  ans0[n]%=MOD;
   }
   
   int t=0;
   cin >> t;
   LL L,V;
   while(t--)
   {
	  cin >> L >> V;
	  if(V==0)
	  {
		 LL TMP = ans0[L];
		 TMP%=MOD;
		 if(TMP < 0) TMP+=MOD;		
		 cout << TMP << endl;
		 continue;
	  }
	  int n2,n3,n5,n7;
	  n2=n3=n5=n7=0;

	  while(V%2==0){
	  n2++;V/=2;
	  }
	  while(V%3==0){
	  n3++;V/=3;		// Processing the number in O(log(V))
	  }
	  while(V%5==0){
	  n5++;V/=5;
	  }
	  while(V%7==0){
	  n7++;V/=7;
	  }

	  if(V!=1) cout << 0 << endl; // If V !=1 , it means it has another prime factor, hence answer will be 0
	  else
	  {
		 LL TMP = ans[L][n2][n3][n5][n7]; // Using the precomputed result to get the answer in O(1)
		 TMP %= MOD;
		 if(TMP < 0)
			TMP += MOD;
		 cout << TMP << endl;
	  }
   }

        

   
#ifndef ONLINE_JUDGE
getch();
#endif
}
