/**
 * January 2013 Long Challenge at Codechef
 *
 * Problem:     DIVPRO - Dividing Products
 * Author:      Anton Lunyov (Tester and Editorialist)
 * Complexity:  O(L^5 * B + T * log(L^4)), where B = 10
 * Timing:      1.02 out of 3.00 (0.54 with #define FAST)
 *
 * Description:
 * See editorial :)
 */

// uncomment to speed up the solution almost twice
#define FAST

#include <cstdio>
#include <cstring> // need memset from here
#include <algorithm> // need sort and lower_bound from here
#include <vector> // use vectors to save dp-values
using namespace std;

const int maxL = 36;
const int maxL1 = (maxL+1)/2;
const int N2 = 3*maxL1;
const int N3 = 2*maxL1;
const int N5 = maxL1;
const int N7 = maxL1;
// N2, N3, N5, N7 are used to access dp[L][n2][n3][n5][n7]
// from the editorial as dp[p][N2+n2][N3+n3][N5+n5][N7+n7]

// the main dp array
unsigned dp[2][2 * N2 + 1][2 * N3 + 1][2 * N5 + 1][2 * N7 + 1];

// d = 2^g2[d] * 3^g3[d] * 5^g5[d] * 7^g7[d]
// digits are 0  1  2  3  4  5  6  7  8  9
int g2[10] = {0, 0, 1, 0, 2, 0, 1, 0, 3, 0};
int g3[10] = {0, 0, 0, 1, 0, 0, 1, 0, 0, 2};
int g5[10] = {0, 0, 0, 0, 0, 1, 0, 0, 0, 0};
int g7[10] = {0, 0, 0, 0, 0, 0, 0, 1, 0, 0};

int main() {

	// Vres[L][i] is the pair (V, dp_val)
	// where dp_val is the answer for the problem with input (L, V)
	vector<pair<long long, unsigned> > Vres[maxL + 1];

	// pw9[n] is 9^n modulo 2^32
	unsigned pw9[maxL + 1] = {1};

	// pw10[n] is 10^n modulo 2^32
	unsigned pw10[maxL + 1] = {1};

	// loop over L to compute results for V = 0
	for(int L=1;L<=maxL;L++)
	{
		// calculation of pw9[L] and p10[L] from the previous values
		pw9[L] = 9 * pw9[L - 1];
		pw10[L] = 10 * pw10[L - 1];

		// calculating answer for the problem in the case V = 0
		// see editorial for details
		int X = (L - 1) /2;
		unsigned res0 = pw9[L - X] * (pw10[X] - pw9[X]);

		// saving this result in Vres[L]
		Vres[L].push_back(make_pair(0LL, res0));
	}

	// precalculation of powers of 2, 3, 5, 7 to restore V by (n2, n3, n5, n7)
	// in O(1) time while saving dp-values

	// pw2[n] is 2^n
	long long pw2[N2 + 1] = {1};
	for(int n = 1; n <= N2; ++n) {
		pw2[n] = 2 * pw2[n - 1];
	}

	// pw3[n] is 3^n
	long long pw3[N3 + 1] = {1};
	for(int n = 1; n <= N3; ++n) {
		pw3[n] = 3 * pw3[n - 1];
	}

	// pw5[n] is 5^n
	long long pw5[N5 + 1] = {1};
	for(int n = 1; n <= N5; ++n) {
		pw5[n] = 5 * pw5[n - 1];
	}

	// pw7[n] is 7^n
	long long pw7[N7 + 1] = {1};
	for(int n = 1; n <= N7; ++n) {
		pw7[n] = 7 * pw7[n - 1];
	}

	// p is the variable that control current layer of DP
	int p = 0;

	// init of dp[0][][][][]
	// at first set all to zero
	memset(dp[p], 0, sizeof dp[p]);
	// and then assign 1 to dp[0][0][0][0][0] from editorial
	// which is dp[p][N2][N3][N5][N7] according to comments above
	dp[p][N2][N3][N5][N7] = 1;

	// the main loop over L to calculate dp-values
	for (int L = 1; L <= maxL; ++L)
	{
		// we flip p to change the layer in dp array
		// where we will save the dp for the current value of L
		p = !p;

		// we will iterate over dp[L-1][][][][] from editorial
		// hence L1 and L2 are calculated for L-1
		int L1 = L / 2;
		int L2 = (L - 1) - L1;
		// for L = 0 we need adjust L2 since it appears to be -1
		if (L == 0) {
			L2 = 0;
		}

		// init of dp[L][][][][] which is dp[p][][][][] by setting all to zero
		memset(dp[p], 0, sizeof dp[p]);

		// loop over arrays (n2, n3, n5, n7) as described in the editorial
		for (int n2 = -3 * L2; n2 <= 3 * L1; ++n2) {
			for (int n3 = - 2 * L2; n3 <= 2 * L1; ++n3) {
				for (int n5 = -L2; n5 <= L1; ++n5) {
					for (int n7 = -L2; n7 <= L1; ++n7) {
						// the value of dp[L-1][n2][n3][n5][n7]
						unsigned cnt = dp[!p][N2 + n2][N3 + n3][N5 + n5][N7 + n7];
						// we don't need to process zero value
						// it is important optimization
						if (cnt > 0) {
#ifndef FAST
							// loop over digits
							for (int d = 1; d <= 9; ++d) {
								// and using the formula from editorial
								dp[p][N2 - n2 + g2[d]][N3 - n3 + g3[d]][N5 - n5 + g5[d]][N7 - n7 + g7[d]] += cnt;
							}
#else 
							// note that writing the following quite ugly copy-pasted code
							// instead of this elegant loop speeds up the program twice:
							dp[p][N2-n2]  [N3-n3]  [N5-n5]  [N7-n7]  += cnt; // digit 1
							dp[p][N2-n2+1][N3-n3]  [N5-n5]  [N7-n7]  += cnt; // digit 2
							dp[p][N2-n2]  [N3-n3+1][N5-n5]  [N7-n7]  += cnt; // digit 3
							dp[p][N2-n2+2][N3-n3]  [N5-n5]  [N7-n7]  += cnt; // digit 4
							dp[p][N2-n2]  [N3-n3]  [N5-n5+1][N7-n7]  += cnt; // digit 5
							dp[p][N2-n2+1][N3-n3+1][N5-n5]  [N7-n7]  += cnt; // digit 6
							dp[p][N2-n2]  [N3-n3]  [N5-n5]  [N7-n7+1]+= cnt; // digit 7
							dp[p][N2-n2+3][N3-n3]  [N5-n5]  [N7-n7]  += cnt; // digit 8
							dp[p][N2-n2]  [N3-n3+2][N5-n5]  [N7-n7]  += cnt; // digit 9
#endif
						}
					}
				}
			}
		}

		// we recalc L1 for the L instead of L-1
		// we don't need L2 below
		L1 = (L + 1)/2;

		// loop over dp[L][][][][][] by arrays (n2, n3, n5, n7)
		// with non-negative elements to save non-zero dp-values to Vres[L]
		for (int n2 = 0; n2 <= 3 * L1; ++n2) {
			for (int n3 = 0; n3 <= 2 * L1; ++n3) {
				for (int n5 = 0; n5 <= L1; ++n5) {
					for (int n7 = 0; n7 <= L1; ++n7) {

						// the value of dp[L][n2][n3][n5][n7]
						unsigned cnt = dp[p][N2 + n2][N3 + n3][N5 + n5][N7 + n7];

						// we are interested only in positive dp-values
						if (cnt > 0) {

							// we calc V as 2^n2 * 3^n3 * 5^n5 * n^n7
							// using precalculated arrays of powers
							long long V = pw2[n2] * pw3[n3] * pw5[n5] * pw7[n7];

							// finally we add pair (V, cnt) to Vres[L]
							Vres[L].push_back(make_pair(V, cnt));
						}
					}
				}
			}
		}
	}

	// sorting Vres[L] for each L to apply binary search further
	for (int L = 0; L <= maxL; ++L) {
		sort(Vres[L].begin(), Vres[L].end());
	}

	// input number of tests
	int T;
	scanf("%d", &T); // we use scanf for faster input

	// loop over tests
	for (int t = 0; t < T; ++t) {

		// input numbers L and V
		int L;
		long long V;
		scanf("%d%lld", &L, &V);

		// finding the position of the first element in Vres[L] having Vres[L].first >= V
		// the complexity is O(log Vres[L].size()) since lower_bound behaves like binary search
		int pos = lower_bound(Vres[L].begin(), Vres[L].end(), make_pair(V, 0U)) - Vres[L].begin();

		unsigned ans = 0;

		// recognizing whether for the pair (L, V) we have non-zero answer
		if (pos < Vres[L].size() && Vres[L][pos].first == V) {
			// Vres[L][pos].second is the result for pair (L, V)
			ans = Vres[L][pos].second;
		}

		// output the result, note specifier %u here
		printf("%u\n", ans);
	}
	return 0;
}