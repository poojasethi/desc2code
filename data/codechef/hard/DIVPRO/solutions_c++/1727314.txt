// January 2013 Long Challenge at Codechef
// Problem : DIVPRO - Dividing Products
// Author  : Vivek Hamirwasia 

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
typedef long long int LLD;

// Bitwise trick for modulo division
LLD MOD (1LL<<32);

using namespace std;
int DP[19][60][40][30][24]; 
int ans[39][60][40][30][24];

void generate()
{
  //Number of Ways of getting Value = (2^m2 * 3^m3 * 5^m5 * 7^m7) from Length L.

  for(int L=0; L<=18; L++)
   for(int m2=0;m2 <= L*3; m2++)  // m2 will go till 3*L --> in case of all 8's
    for(int m3=0; m3 <= 2*L && (m2/3 + m3/2 <=L); m3++) // m3 will go till 2*L --> in case of all 9's
     for(int m5 =0; m5 <= L; m5++)
      for(int m7=0; m7<= L; m7++)
      {
        if(m2/3+m3/2+m5+m7 > L) 
         continue; 
        LLD cnt = DP[L][m2][m3][m5][m7];  
        if(cnt==0) 
         continue;

        // For every possible value of next number we can fill the DP table
        DP[L+1][m2][m3][m5][m7]+=cnt;     // 1   1
        DP[L+1][m2+1][m3][m5][m7]+=cnt;   // 2   2
        DP[L+1][m2][m3+1][m5][m7]+=cnt;   // 3   3
        DP[L+1][m2+2][m3][m5][m7]+=cnt;   // 4   2*2
        DP[L+1][m2][m3][m5+1][m7]+=cnt;   // 5   5
        DP[L+1][m2+1][m3+1][m5][m7]+=cnt; // 6  2*3
        DP[L+1][m2][m3][m5][m7+1]+=cnt;   // 7   7
        DP[L+1][m2+3][m3][m5][m7]+=cnt;   // 8   2*2*2
        DP[L+1][m2][m3+2][m5][m7]+=cnt;   // 9   3*3
      }
}

void precompute()
{
  DP[0][0][0][0][0] = 1;
  ans[0][0][0][0][0] = 0;

  generate();

  for(int L=1; L<=18; L++)
  {
    for(int m2=0;m2<=L*3; m2++)
     for(int m3=0;m3<=2*L && (m2/3+m3/2)<=L ;m3++)
      for(int m5=0;m5<=L; m5++)
       for(int m7=0;m7<=L;m7++)
       {
         // For a given 2*L Length number, L/2 will be Length of Denominator, L-L/2 will be of Numerator
         // m2, m3, m5, m7 are the powers of 2,3,5,7 respectively for Numerator

         LLD cnt = DP[L][m2][m3][m5][m7];
         if(cnt==0) 
          continue;

         // Iterating over all possible powers of 2,3,5,7 for Denomiator which are less than Numerator's.
         for(int L2=L-1;L2<=L;L2++)
          for(int n2=0; n2<= m2; n2++)
           for(int n3=0; n3 <= m3; n3++)
            for(int n5=0; n5 <= m5; n5++)
             for(int n7=0; n7 <= m7;n7++)
              ans[L+L2][m2-n2][m3-n3][m5-n5][m7-n7] += cnt*DP[L2][n2][n3][n5][n7];
         // Total lenght will be L+L2, and powers will be (m2-n2), (m3-n3) ,(m5-n5) , (m7-n7) for 2,3,5 & 7.

       }
  }
  ans[1][0][0][0][0]=1;
  ans[1][1][0][0][0]=1;
  ans[1][0][1][0][0]=1;
  ans[1][2][0][0][0]=1;
  ans[1][0][0][1][0]=1;
  ans[1][1][1][0][0]=1;
  ans[1][0][0][0][1]=1;
  ans[1][3][0][0][0]=1;
  ans[1][0][2][0][0]=1;
}

int main()
{
  memset(DP,0,sizeof(DP));	
  memset(ans,0,sizeof(ans));
  precompute();

  LLD p9[37],p10[37],ans0[37];
  p9[0]=p10[0]=1;

  for(int n=1;n<=36;n++)
  {
    p9[n]=(9*p9[n-1])%MOD;
    p10[n]=(10*p10[n-1])%MOD;           // Handling case when V = 0;
    int n1=(n-1)/2;
    ans0[n] = (p10[n1]-p9[n1])*p9[n-n1];
    ans0[n]%=MOD;
  }

  int t=0;
  cin >> t;
  LLD L,V;
  while(t--)
  {
    cin >> L >> V;
    if(V==0)
    {
      LLD TMP = ans0[L];
      TMP%=MOD;
      if(TMP < 0) 
       TMP+=MOD;		
      cout << TMP << endl;
      continue;
    }
    int n2,n3,n5,n7;
    n2=n3=n5=n7=0;

    while(V%2==0)
    {
      n2++;
      V/=2;
    }
    while(V%3==0)
    {
      n3++;
      V/=3;		// Processing the number in O(log(V))
    }
    while(V%5==0)
    {
      n5++;
      V/=5;
    }
    while(V%7==0)
    {
      n7++;
      V/=7;
    }

    if(V!=1) 
     cout << 0 << endl; // If V !=1 , it means it has another prime factor, hence answer will be 0
    else
    {
      LLD TMP = ans[L][n2][n3][n5][n7]; // Using the precomputed result to get the answer in O(1)
      TMP %= MOD;
      if(TMP < 0)
       TMP += MOD;
      cout << TMP << endl;
    }
  }

  return 0;
}
