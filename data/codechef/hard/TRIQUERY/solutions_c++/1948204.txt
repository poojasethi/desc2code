#include <iostream>
#include <cstdio>
using namespace std;

#include <bitset>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>
#include <set>
#include <map>
#include <queue>
#include <cassert>

# define fr(i, n)           for( int i = 0; i<=n; i++)
# define frm(i, m, n)     for( int i = m; i <=n; i++)
# define pf printf
# define sf scanf
# define sfd(x) scanf("%d",&x)
# define ll long long
# define PB push_back
# define pii pair<int,int>
# define F first
# define S second
# define MP make_pair

# define nmax 300000
# define qmax 200000
# define inf 1000000000

struct point{
    int x,y;
    int event_type;
    int event_index;
};
class Compare1 {//X
public:
    bool operator()(point a, point b)
    {
       	if(a.x<b.x)return true;
		if(a.x>b.x)return false;
		return (a.y<b.y);
    }
};
class Compare2 {//Y
public:
    bool operator()(point a, point b)
    {
       	if(a.y<b.y)return true;
		if(a.y>b.y)return false;
		return (a.x<b.x);
    }
};
class Compare3 { //X+Y
public:
    bool operator()(point a, point b)
    {
       	if(a.x+a.y<b.x+b.y)return true;
		if(a.x+a.y>b.x+b.y)return false;
		if(a.x==b.x && a.y==b.y){
               if(a.event_type==1)return true;
               if(b.event_type==1)return false;
               return a.event_type<b.event_type;
		}
		return a.x<b.x;
    }
};
int read(int arr_bit[],int maxval,int idx)
{
    int ret=0;
    while(idx>0)
    {
        ret+=arr_bit[idx];
        idx-=idx&-idx;
    }
    return ret;
}
void update(int arr_bit[],int maxval,int idx,int val)
{
     assert(idx!=0);
    while(idx<=maxval)
    {
          arr_bit[idx]+=val;
          idx+=idx&-idx;
    }
}
point Points[nmax];
point Arr[nmax+3*qmax+1];
int Query_answer[qmax+1]={0};
int N,Q;
int Counter;
#define MAXX 300000
int BITX[MAXX+1]={0};
int BITY[MAXX+1]={0};
//ll BITX[MAXVAL+1];

void in()
{
     sfd(N); sfd(Q);
    //event type:
    //0-> point
    //1-> point opp. to hypotenus
    //2-> pooint above
    //3-> point right
     point tmp;
     Counter=0;
     fr(i,N-1){
          sfd(tmp.x); sfd(tmp.y); tmp.event_type=0; tmp.event_index=-1;
          Arr[Counter++]=tmp;
     }
     int x,y,d;
     fr(i,Q-1){
          scanf("%d%d%d",&x,&y,&d);
          tmp.x=x; tmp.y=y; tmp.event_type=1; tmp.event_index=i;
          Arr[Counter++]=tmp;
          tmp.x=x; tmp.y=y+d; tmp.event_type=2; tmp.event_index=i;
          Arr[Counter++]=tmp;
          tmp.x=x+d; tmp.y=y; tmp.event_type=3; tmp.event_index=i;
          Arr[Counter++]=tmp;
     }
     sort(Arr,Arr+Counter,Compare3());
}


void solve()
{
     point cur;
     int tmp,v1,v2,v3;
     int num_of_points=0;
     fr(i,Counter-1){
          cur=Arr[i];
          if(cur.event_type==0){
               num_of_points++;
               //BITX[cur.x]
               update(BITX,MAXX,cur.x,1);
               update(BITY,MAXX,cur.y,1);
          }
          else if(cur.event_type==1){
               v1=read(BITX,MAXX,cur.x-1);
               v2=read(BITY,MAXX,cur.y-1);
               v3=v1+v2-num_of_points;
               Query_answer[cur.event_index]+=v3;
          }
          else if(cur.event_type==2){
               v1=read(BITX,MAXX,cur.x-1);
               Query_answer[cur.event_index]-=v1;
          }
          else{
               v1=read(BITY,MAXX,cur.y-1);
               Query_answer[cur.event_index]-=v1;
               v2=num_of_points;
               Query_answer[cur.event_index]+=v2;
          }
     }
     fr(i,Q-1){
          pf("%d\n",Query_answer[i]);
     }
}

int main()
{
    //freopen("input.txt","r",stdin);
    in();
    solve();

    return 0;
}
