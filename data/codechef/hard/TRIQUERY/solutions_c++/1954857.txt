//program TRIQUERY

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>

using namespace std;

struct Point
{
  int X,Y;
};

struct Query
{
  int X,Y,D;
};

struct Event
{
  int X,Y,Number;
  bool Add;
};

bool operator <(Event A,Event B)
{
  return (A.X==B.X)?(A.Number<B.Number):(A.X<B.X);
}

struct Node
{
  int Data,Count,Size;
  Node *Parent,*Lc,*Rc;
};

struct MySet
{
  Node *Root;
  void Init()
    {
      Root=NULL;
    }
  void Update(Node *X)
    {
      X->Size=X->Count;
      if(X->Lc!=NULL)
        X->Size+=X->Lc->Size;
      if(X->Rc!=NULL)
        X->Size+=X->Rc->Size;
    }
  void Tr(Node *X)
    {
      Node *Y=X->Parent;
      X->Parent=Y->Parent;
      if(X->Parent!=NULL)
        if(Y==X->Parent->Lc)
          X->Parent->Lc=X;
        else
          X->Parent->Rc=X;
      Y->Lc=X->Rc;
      if(X->Rc!=NULL)
        X->Rc->Parent=Y;
      X->Rc=Y;
      Y->Parent=X;
      Update(Y);
    }
  void Tl(Node *X)
    {
      Node *Y=X->Parent;
      X->Parent=Y->Parent;
      if(X->Parent!=NULL)
        if(Y==X->Parent->Lc)
          X->Parent->Lc=X;
        else
          X->Parent->Rc=X;
      Y->Rc=X->Lc;
      if(X->Lc!=NULL)
        X->Lc->Parent=Y;
      X->Lc=Y;
      Y->Parent=X;
      Update(Y);
    }
  void Splay(Node *X)
    {
      while(X->Parent!=NULL)
        {
          Node *Y=X->Parent,*Z=Y->Parent;
          if(Z==NULL)
            if(X==Y->Lc)
              Tr(X);
            else
              Tl(X);
          else
            if(X==Y->Lc&&Y==Z->Lc)
              {Tr(Y);Tr(X);}
            else if(X==Y->Rc&&Y==Z->Rc)
              {Tl(Y);Tl(X);}
            else if(X==Y->Lc&&Y==Z->Rc)
              {Tr(X);Tl(X);}
            else if(X==Y->Rc&&Y==Z->Lc)
              {Tl(X);Tr(X);}
        }
      Update(X);
      Root=X;
    }
  void Insert(int X)
    {
      if(Root==NULL)
        {
          Root=new Node;
          Root->Data=X;
          Root->Count=Root->Size=1;
          Root->Parent=Root->Lc=Root->Rc=NULL;
          return;
        }
      Node *P=Root,*Pre;
      while(P!=NULL)
        {
          Pre=P;
          if(P->Data==X)
            {
              P->Count++;
              Splay(P);
              return;
            }
          if(X<P->Data)
            P=P->Lc;
          else
            P=P->Rc;
        }
      P=new Node;
      P->Data=X;
      P->Count=P->Size=1;
      P->Parent=Pre;
      P->Lc=P->Rc=NULL;
      if(X<Pre->Data)
        Pre->Lc=P;
      else
        Pre->Rc=P;
      Splay(P);
    }
  int Count(int X)
    {
      int Ans=0;
      Node *P=Root,*Pre=NULL;
      while(P!=NULL)
        {
          Pre=P;
          if(P->Data>X)
            P=P->Lc;
          else
            {
              Ans+=P->Count;
              if(P->Lc!=NULL)
                Ans+=P->Lc->Size;
              P=P->Rc;
            }
        }
      if(Pre!=NULL)
        Splay(Pre);
      return Ans;
    }
};

int Get()
{
  char c;
  while(c=getchar(),c<'0'||c>'9');
  int X=0;
  while(c>='0'&&c<='9')
    {
      X=X*10+c-48;
      c=getchar();
    }
  return X;
}

void Output(int X)
{
  int Len=0,Data[10];
  while(X)
    {
      Data[Len++]=X%10;
      X/=10;
    }
  if(!Len)
    Data[Len++]=0;
  while(Len--)
    putchar(Data[Len]+48);
  putchar('\n');
}

int N,M,Total;
Point P[300000];
Query Q[200000];
int Ans[200000];
Event E[1000000];
int Value[1000000];
int Sum[1000000];

void Init()
{
  N=Get();
  M=Get();
  for(int i=0;i<N;i++)
    {
      P[i].X=Get();
      P[i].Y=Get();
    }
  for(int i=0;i<M;i++)
    {
      Q[i].X=Get();
      Q[i].Y=Get();
      Q[i].D=Get();
    }
  memset(Ans,0,sizeof(Ans));
}

int Find(int X)
{
  int Left=0,Right=Total-1;
  while(Left<Right)
    {
      int Mid=(Left+Right)/2;
      if(Value[Mid]==X)
        return Mid;
      if(Value[Mid]<X)
        Left=Mid+1;
      else
        Right=Mid-1;
    }
  return Left;
}

void Add(int X)
{
  while(X<=Total)
    {
      Sum[X]++;
      X+=X&-X;
    }
}

int GetSum(int X)
{
  int Ans=0;
  while(X)
    {
      Ans+=Sum[X];
      X^=X&-X;
    }
  return Ans;
}

void Work()
{
  sort(E,E+Total);
  for(int i=0;i<Total;i++)
    Value[i]=E[i].Y;
  sort(Value,Value+Total);
  memset(Sum,0,sizeof(Sum));
  for(int i=0;i<Total;i++)
    if(E[i].Number==-1)
      Add(Find(E[i].Y)+1);
    else
      {
        int X=GetSum(Find(E[i].Y)+1);
        if(E[i].Add)
          Ans[E[i].Number]+=X;
        else
          Ans[E[i].Number]-=X;
      }
}

void Solve_0()
{
  for(int i=Total=0;i<N;i++)
    {
      E[Total].X=P[i].X;
      E[Total].Y=P[i].X+P[i].Y;
      E[Total].Number=-1;
      Total++;
    }
  for(int i=0;i<M;i++)
    {
      E[Total].X=Q[i].X+Q[i].D;
      E[Total].Y=Q[i].X+Q[i].Y+Q[i].D;
      E[Total].Number=i;
      E[Total].Add=true;
      Total++;
      E[Total].X=Q[i].X-1;
      E[Total].Y=Q[i].X+Q[i].Y+Q[i].D;
      E[Total].Number=i;
      E[Total].Add=false;
      Total++;
    }
  Work();
}

void Solve_1()
{
  for(int i=Total=0;i<N;i++)
    {
      E[Total].X=P[i].X;
      E[Total].Y=P[i].Y;
      E[Total].Number=-1;
      Total++;
    }
  for(int i=0;i<M;i++)
    {
      E[Total].X=Q[i].X-1;
      E[Total].Y=Q[i].Y-1;
      E[Total].Number=i;
      E[Total].Add=true;
      Total++;
      E[Total].X=Q[i].X+Q[i].D;
      E[Total].Y=Q[i].Y-1;
      E[Total].Number=i;
      E[Total].Add=false;
      Total++;
    }
  Work();
}

void Print()
{
  for(int i=0;i<M;i++)
    Output(Ans[i]);
}

int main()
{
  Init();
  Solve_0();
  Solve_1();
  Print();
  return 0;
}
