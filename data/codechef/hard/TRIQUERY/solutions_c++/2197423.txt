#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

#define TX 0
#define TY 1

int tree[2][300001];

typedef struct point {
	int x,y;
} point;

typedef struct query {
	int id, x, y, d;
} query;

point pts[300001];
query qs[300001];

int ans[300001];

void updatebit(int idx, int val, int T){
	while (idx<=300000){
		tree[T][idx] += val;
		idx += idx & -idx;
	}
}

int querybit(int idx, int T){
	int ans=0;
	while (idx){
		ans += tree[T][idx];
		idx -= idx & -idx;
	}
	return ans;
}

bool comp_sweep_pt(const point& l, const point& r){
	return l.x + l.y < r.x + r.y;
}

bool comp_sweep_q(const query& l, const query& r){
	return l.x + l.y + l.d < r.x + r.y + r.d;
}

bool comp_x_pt(const point& l, const point& r){
	return l.x==r.x?l.y<r.y:l.x<r.x;
}

bool comp_x_q(const query& l, const query& r){
	return l.x==r.x?l.y<r.y:l.x<r.x;
}

int main(){
	int n, q;
	scanf("%d %d", &n, &q);
	for (int i=0; i<n; i++){
		scanf("%d %d", &(pts[i].x), &(pts[i].y));
	}
	for (int i=0; i<q; i++){
		scanf("%d %d %d", &(qs[i].x), &(qs[i].y), &(qs[i].d));
		qs[i].id=i;
	}

	sort(pts, pts+n, comp_sweep_pt);
	sort(qs, qs+q, comp_sweep_q);


	int j=0;
	for (int i=0; i<q; i++){
		while (j<n && pts[j].x+pts[j].y<=qs[i].x+qs[i].y+qs[i].d){
			updatebit(pts[j].x, 1, TX);
			updatebit(pts[j].y, 1, TY);
			j++;
		}
		ans[qs[i].id] = j - querybit(qs[i].x-1, TX) - querybit(qs[i].y-1, TY);
	}

	sort(pts, pts+n, comp_x_pt);
	sort(qs, qs+q, comp_x_q);

	memset(tree, 0, sizeof(tree));

	j=0;
	for (int i=0; i<q; i++){
		while (j<n && pts[j].x < qs[i].x){
			updatebit(pts[j].y, 1, TY);
			j++;
		}
		ans[qs[i].id] += querybit(qs[i].y-1, TY);
	}

	for (int i=0; i<q; i++){
		printf("%d\n", ans[i]);
	}

	return 0;
}