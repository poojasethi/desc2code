#include <iostream>
#include <cstdio>
#include <climits>
#include <algorithm>
#include <queue>
#include <cstring>
#include <cmath>
#include <vector>
#include <stack>
#include <set>
#include <map>
#include <deque>
#define SET(p) memset(p,-1,sizeof(p))
#define CLR(p) memset(p,0,sizeof(p))
#define LL long long int
#define ULL unsigned long long int
#define S(n)					scanf("%d",&n)
#define Sl(n)					scanf("%lld",&n)
#define Sf(n) 					scanf("%lf",&n)
#define Ss(n) 					scanf("%s",n)
using namespace std;
////////////////////////////////////////////////////////
using std::string;
 
static struct IO {
        char tmp[1 << 10];
 
        // fast input routines
        char cur;
 
//#define nextChar() (cur = getc_unlocked(stdin))
//#define peekChar() (cur)
        inline char nextChar() { return cur = getc_unlocked(stdin); }
        inline char peekChar() { return cur; }
 
        inline operator bool() { return peekChar(); }
        inline static bool isBlank(char c) { return (c < '-' && c); }
        inline bool skipBlanks() { while (isBlank(nextChar())); return peekChar() != 0; }
 
        inline IO& operator >> (char & c) { c = nextChar(); return *this; }
 
        inline IO& operator >> (char * buf) {
                if (skipBlanks()) {
                        if (peekChar()) {
                                *(buf++) = peekChar();
                                while (!isBlank(nextChar())) *(buf++) = peekChar();
                        } *(buf++) = 0; } return *this; }
 
        inline IO& operator >> (string & s) {
                if (skipBlanks()) {     s.clear(); s += peekChar();
                        while (!isBlank(nextChar())) s += peekChar(); }
                return *this; }
 
        inline IO& operator >> (double & d) { if ((*this) >> tmp) sscanf(tmp, "%lf", &d); return *this; }
 
#define defineInFor(intType) \
        inline IO& operator >>(intType & n) { \
                if (skipBlanks()) { \
                        int sign = +1; \
                        if (peekChar() == '-') { \
                                sign = -1; \
                                n = nextChar() - '0'; \
                        } else \
                                n = peekChar() - '0'; \
                        while (!isBlank(nextChar())) { \
                                n += n + (n << 3) + peekChar() - 48; \
                        } \
                        n *= sign; \
                } \
                return *this; \
        }
 
defineInFor(int)
defineInFor(unsigned int)
defineInFor(long long)
 
        // fast output routines
 
//#define putChar(c) putc_unlocked((c), stdout)
        inline void putChar(char c) { putc_unlocked(c, stdout); }
        inline IO& operator << (char c) { putChar(c); return *this; }
        inline IO& operator << (const char * s) { while (*s) putChar(*s++); return *this; }
 
        inline IO& operator << (const string & s) { for (int i = 0; i < (int)s.size(); ++i) putChar(s[i]); return *this; }
 
        char * toString(double d) { sprintf(tmp, "%lf%c", d, '\0'); return tmp; }
        inline IO& operator << (double d) { return (*this) << toString(d); }
 
 
#define defineOutFor(intType) \
        inline char * toString(intType n) { \
                char * p = (tmp + 30); \
                if (n) { \
                        bool isNeg = 0; \
                        if (n < 0) isNeg = 1, n = -n; \
                        while (n) \
                                *--p = (n % 10) + '0', n /= 10; \
                        if (isNeg) *--p = '-'; \
                } else *--p = '0'; \
                return p; \
        } \
        inline IO& operator << (intType n) { return (*this) << toString(n); }
 
defineOutFor(int)
defineOutFor(long long)
 
#define endl ('\n')
#define cout __io__
#define cin __io__
} __io__;
 

/////////////////////////////////////////////////////////
#define maxn 500009
struct pnt
{
	int x,y;
	pnt()
	{}
	pnt(int _x,int _y)
	{
		x=_x;
		y=_y;
	}
};
bool operator<(const pnt &a,const pnt &b)
{
	return a.x<b.x||(a.x==b.x&&a.y<b.y);
}
vector<pnt> v;
struct cont
{
	vector <int> v;
	cont()
	{
		
	}
	cont(int x)
	{
		v.push_back(x);
	}
}m[5*maxn];
void init(int node,int b,int e)
{
	//cout<<node<<"  "<<b<<"  "<<e<<endl;
	if(b==e)
	{
		//cout<<"hola  "<<v[b].y<<endl;
		m[node].v.push_back(v[b].y);
		//cout<<"lol"<<endl;
		return;
	}
	else
	{
		init(2*node,b,(b+e)/2);
		init(2*node+1,(b+e)/2+1,e);
		int l,r;
		l=m[2*node].v.size();
		r=m[2*node+1].v.size();
		m[node].v.resize(l+r);
		merge(m[2*node].v.begin(),m[2*node].v.end(),m[2*node+1].v.begin(),m[2*node+1].v.end(),m[node].v.begin());
	}
}
int rect_query(int node,int b,int e,int i,int j,int y1,int y2)
{
	//cout<<"rect_q  "<<node<<" "<<i<<"  "<<j<<" "<<y1<<" "<<y2<<endl;
	if(y1>y2||i>j)
		return 0;
	if(m[node].v.size()==0)
		return 0;
	int b1,e1;
	b1=v[b].x;
	e1=v[e].x;
	if(j<b1||i>e1)
		return 0;
	if(b1>=i&&e1<=j)
	{
		vector<int>::iterator it1,it2;
		it1=lower_bound(m[node].v.begin(),m[node].v.end(),y1);
		it2=upper_bound(m[node].v.begin(),m[node].v.end(),y2);
		return distance(it1,it2);
		//return m[node].v.size();
	}
	i=max(i,b1);
	j=min(j,e1);
	int mid=(b+e)/2;
	
	if(j<v[mid].x)
		return rect_query(2*node,b,mid,i,j,y1,y2);
	else if(i>v[mid].x)
		return rect_query(2*node+1,mid+1,e,i,j,y1,y2);
	else
	{
		int p1,p2;
		p1=rect_query(2*node,b,mid,i,j,y1,y2);
		p2=rect_query(2*node+1,mid+1,e,i,j,y1,y2);
		return p1+p2;
	}		
}
struct qq
{
	int x,y,d,qno;
	int type;
	qq()
	{
	}
	qq(int _x,int _y)
	{
		x=_x;
		y=_y;
		type=0;
	}
	qq(int _x,int _y,int _d,int _q)
	{
		x=_x;
		y=_y;
		d=_d;
		type=1;
		qno=_q;
	}
};
bool operator<(const qq &a,const qq &b)
{
	int t1=a.x+a.y;
	int t2=b.x+b.y;
	if(t1!=t2)
		return t1<t2;
	if(a.x!=b.x)
		return a.x<b.x;
	return a.type<b.type;
}
class BIT
{
	public:
	int len;
	int bit[300009];
	void clear()
	{
		CLR(bit);
	}
	int readcum(int idx)
	{
		idx=min(idx,len-1);
		int sum=0;
		while(idx>0)
		{
			sum+=bit[idx];
			idx-=(idx&-idx);
		}
		return sum;
	}
	void update(int idx,int val)
	{
		while(idx<=len)
		{
			bit[idx]+=val;
			idx+=(idx&-idx);
		}
	}
};

vector<qq> v2;
int query[300009];
int main()
{
	int t,i,j,k,n,m;
	#ifndef ONLINE_JUDGE
	//freopen("example.txt","r",stdin);
	//freopen("op.txt","r",stdin);
	#endif
	//S(n);S(m);
	cin>>n>>m;
	int x,y;
	for(i=0;i<n;i++)
	{
		//S(x);S(y);
		cin>>x>>y;
		v.push_back(pnt(x,y));
		v2.push_back(qq(x,y));
	}
	sort(v.begin(),v.end());
	init(1,0,n-1);
	int d;
	for(i=0;i<m;i++)
	{
		//S(x);S(y);S(d);
		cin>>x>>y>>d;
		v2.push_back(qq(x+d,y,d,i));
	}
	sort(v2.begin(),v2.end());
	BIT bit;
	bit.clear();
	bit.len=300001;
	for(i=0;i<v2.size();i++)
	{
		if(v2[i].type==0)
		{
			bit.update(v2[i].x,1);
		}
		else
		{
			int ans=0;
			x=v2[i].x;
			d=v2[i].d;
			y=v2[i].y;
			ans=bit.readcum(x)-bit.readcum(x-d-1);
			
			ans-=rect_query(1,0,n-1,x-d,x,0,y-1);
			query[v2[i].qno]=ans;
		}
	}
	for(i=0;i<m;i++)
	{
		printf("%d\n",query[i]);
	}
	return 0;
}