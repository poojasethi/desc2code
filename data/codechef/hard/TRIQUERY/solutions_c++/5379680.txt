#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <cctype>
#include <cstdio>
#include <string>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <iomanip>
#include <sstream>
#include <iostream>
#include <algorithm>

using namespace std;

#define PB push_back
#define MP make_pair
#define AA first
#define BB second
#define OP begin()
#define ED end()
#define SZ size()
#define SORT(x) sort(x.OP,x.ED)
#define SQ(x) ((x)*(x))
#define SSP system("pause")
#define cmin(x,y) x=min(x,y)
#define cmax(x,y) x=max(x,y)
typedef long long LL;
typedef pair<int, int> PII;
const double eps=1e-8;
const double INF=1e20;
const double PI=acos( -1. );
const int MXN = 50;
const LL MOD = 1000000007;

const int Maxn=300005;

#define Left p<<1,pz,mid
#define Right p<<1|1,mid+1,py
struct node{
    int v;
}pl[Maxn<<3|1];
int n,nq;
void build(int p,int pz,int py)
{
    int mid=(pz+py)>>1;
    pl[p].v=0;
    if(pz==py)return;
    build(Left);
    build(Right);
}
void refresh(int p,int pz,int py,int pos)
{
    int mid=(pz+py)>>1;
    if(pz==py)
    {
        pl[p].v++;
        return;
    }
    if(pos<=mid)refresh(Left,pos);
    else refresh(Right,pos);
    pl[p].v=pl[p<<1].v+pl[p<<1|1].v;
}
int query(int p,int pz,int py,int zz,int yy)
{
    int mid=(pz+py)>>1;
    if(pz==zz && py==yy)return pl[p].v;
    if(yy<=mid)return query(Left,zz,yy);
    else if(mid<zz)return query(Right,zz,yy);
    else
    {
        int t1=query(Left,zz,mid);
        int t2=query(Right,mid+1,yy);
        return t1+t2;
    }
}

PII P[Maxn];
struct Query
{
    int x,y,d,id,ans;
    void read(int i)
    {
        scanf("%d%d%d",&x,&y,&d);
        ans=0;id=i;
    }
}q[Maxn];
bool cmpx(PII A,PII B){
    return A.AA<B.AA;
}
bool cmpy(PII A,PII B){
    return A.BB<B.BB;
}
bool cmpqid(Query A,Query B){
    return A.id<B.id;
}
bool cmpqx(Query A,Query B){
    return A.x<B.x;
}
bool cmpqy(Query A,Query B){
    return A.y<B.y;
}

int main(){
    int i,j,slen=0;
    scanf("%d%d",&n,&nq);
    for(i=1;i<=n;i++)
    {
        scanf("%d%d",&P[i].AA,&P[i].BB);
        cmax(slen,P[i].AA+P[i].BB);
    }
    for(i=1;i<=nq;i++)
        q[i].read(i);
    sort(P+1,P+n+1,cmpx);
    sort(q+1,q+nq+1,cmpqx);
    slen++;
//    printf("slen=%d\n",slen);
    build(1,0,slen);
    j=1;
    for(i=1;i<=nq;i++)
    {
        while(j<=n && P[j].AA<q[i].x)
        {
//            printf("RFS %d\n",P[j].AA+P[j].BB);
            refresh(1,0,slen,P[j].AA+P[j].BB);
            j++;
        }
        int ll=min(slen,q[i].x+q[i].y),rr=min(slen,q[i].x+q[i].y+q[i].d);
        int tp=query(1,0,slen,ll,rr);
//        printf("QUERY %d %d: %d\n",ll,rr,tp);
        q[i].ans-=tp;
    }
    sort(P+1,P+n+1,cmpy);reverse(P+1,P+n+1);
    sort(q+1,q+nq+1,cmpqy);reverse(q+1,q+nq+1);
    build(1,0,slen);
    j=1;
    for(i=1;i<=nq;i++)
    {
        while(j<=n && P[j].BB>=q[i].y)
        {
//            printf("RFS %d\n",P[j].AA+P[j].BB);
            refresh(1,0,slen,P[j].AA+P[j].BB);
            j++;
        }
        int ll=min(slen,q[i].x+q[i].y),rr=min(slen,q[i].x+q[i].y+q[i].d);
        int tp=query(1,0,slen,ll,rr);
//        printf("QUERY %d %d: %d\n",ll,rr,tp);
        q[i].ans+=tp;
    }
    sort(q+1,q+nq+1,cmpqid);
    for(i=1;i<=nq;i++)
        printf("%d\n",q[i].ans);
    return 0;
}
/*
3 2
1 1
2 1
1 2
1 1 1
1 1 0

5 4
1 3
1 5
3 6
4 4
2 6
1 5 3
1 5 4
1 1 1
5 6 3
*/

