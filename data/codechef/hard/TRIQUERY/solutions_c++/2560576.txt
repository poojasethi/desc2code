#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<vector>
#include<list>
#include<map>
#include<set>
#include<deque>
#include<queue>
#include<stack>
#include<bitset>
#include<algorithm>
#include<functional>
#include<numeric>
#include<utility>
#include<sstream>
#include<fstream>
#include<iomanip>
#include<cmath>
#include<cctype>
#include<cstring>
#include<string>
#include<ctime>
#include<cassert>
using namespace std;
#define TRACE(x) cerr << "TRACE(" #x ")" << endl;
#define DEBUG(x) cerr << #x << " = " << x << endl;
#define FOR(i,a,b) for(int i=(a);i< (b);i++)
#define CLEAR(a) memset((a),0,sizeof(a))
#define INF 1000000000
#define LL long long
#define PI 2*acos(0.0)
#define sqr(a) (a)*(a)
#define pi pair<int,int>
#define pii pair<int,pi>
#define mp make_pair
#define pb push_back
#define MAXN 300000
#define MAXQ 200000
int tree[2][MAXN+2];
struct point
{
   int x,y;    
};
struct query
{
  int x,y,d;
  int id;     
};
point pts[MAXN+1];
query qs[MAXQ+1];
int ans[MAXQ+1];
int read(int id,int x)
{
   int sum=0;
   while(id>0)
   {
     sum += tree[x][id]; 
     id -=(id&-id);
   }
   return sum;
}
void update(int id,int val,int x)
{
   while(id<=MAXN)
   {
      tree[x][id] +=val;
      id += (id&-id);            
   }  
}
bool comp_pts_dia(point a,point b)
{
   return a.x+a.y < b.x+b.y;  
}
bool comp_pts_x(point a,point b)
{
   if(a.x==b.x)
     return a.y<b.y;
   else
     return a.x<b.x;  
}
bool comp_qs_dia(query a,query b)
{
   return a.x+a.y+a.d < b.x+b.y+b.d;  
}
bool comp_qs_x(query a,query b)
{
   if(a.x==b.x)
     return a.y<b.y;
   else
     return a.x<b.x;  
}
inline int input()
{
    char temp;
    int x=0;
    temp=getchar_unlocked();
    while(temp<48)temp=getchar_unlocked();
    x+=(temp-'0');
    temp=getchar_unlocked();
    while(temp>=48)
    {
        x=x*10;
        x+=(temp-'0');
        temp=getchar_unlocked();
    }
    return x;
}
int main()
{
    int n,q;
    //scanf("%d %d",&n,&q);
    n=input();q=input();
    for(int i=0;i<n;i++)
    {
      pts[i].x=input();pts[i].y=input();
    }
      //scanf("%d %d",&pts[i].x,&pts[i].y);
    for(int i=0;i<q;i++)
    {
        qs[i].x=input();qs[i].y=input();qs[i].d=input();    
       //scanf("%d %d %d",&qs[i].x,&qs[i].y,&qs[i].d);
       qs[i].id=i;     
    }
    sort(pts,pts+n,comp_pts_dia);
    sort(qs,qs+q,comp_qs_dia);
    for(int i=0,j=0;i<q;i++)
    {
       for(;j<n;j++)
       {
         if(pts[j].x+pts[j].y > qs[i].x+qs[i].y+qs[i].d)
           break;
         update(pts[j].x,1,0);
         update(pts[j].y,1,1);           
       }
       ans[qs[i].id]=j-read(qs[i].x-1,0)-read(qs[i].y-1,1);     
    }
    memset(tree,0,sizeof(tree));
    sort(pts,pts+n,comp_pts_x);
    sort(qs,qs+q,comp_qs_x);
    for(int i=0,j=0;i<q;i++)
    {
      for(;j<n;j++)
      {
         if(pts[j].x>=qs[i].x)
          break;
         update(pts[j].y,1,1);          
      }        
      ans[qs[i].id] +=read(qs[i].y-1,1);
    }
    for(int i=0;i<q;i++)
      printf("%d\n",ans[i]);
    //getch();
    return 0;
}
