//#undef _GLIBCXX_DEBUG

#include <algorithm>
#include <cassert>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <ctime>
#include <iomanip>
#include <iostream>
#include <limits>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <valarray>
#include <vector>

using namespace std;

#define foreach(iter,cont) for(typeof((cont).begin()) iter = (cont).begin(); iter != (cont).end(); ++iter)
#define min3(a, b, c) min(a, min(b, c))
#define max3(a, b, c) max(a, max(b, c))
#define inf 1000000008
#define eps 1.0e-10L
#define divisible(a, b) (((a) / (b)) * (b) == (a))
//static const long long p = 1000000007;
__attribute__((unused)) static bool eq(long double a, long double b)  { return (a == b ? true : (a * b == 0 ? abs(a - b) < eps : abs(a - b) / (abs(a) + abs(b)) < eps));  }
__attribute__((unused)) static long long modp(long long n, long long m) { long long r = n % m; return r >= 0 ? r : r + m; }
__attribute__((unused)) static long long gcd(long long a, long long b) { return (a < 0 ? gcd(-a, b) : (b < 0 ? gcd(a, -b) : (!a && !b ? 1 : (b ? gcd(b, a % b) : a)))); }
template<class T> static int len(const T& cont) { return (int) cont.size(); }

// BEGIN CUT HERE
template<class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << "(" << p.first << ", " << p.second << ")"; }
template<class T> ostream &operator<<(ostream& os, const vector<T> &vec) { os << "[ "; for(size_t i = 0; i < vec.size(); i++) { os << vec[i]; if(i != vec.size() - 1) { os << ", "; } } return os << " ]"; }
template<class T> ostream &operator<<(ostream& os, const list<T> &l) { os << "[ "; bool first = true; for(typename list<T>::const_iterator lstIt = l.begin(); lstIt != l.end(); ++lstIt) { if(!first) { os << ", "; } first = false; os << *lstIt; } return os << " ]"; }
template<class T> ostream &operator<<(ostream& os, const deque<T> &d) { os << "[ "; bool first = true; for(typename deque<T>::const_iterator dIt = d.begin(); dIt != d.end(); ++dIt) { if(!first) { os << ", "; } first = false; os << *dIt; } return os << " ]"; }
template<class T> ostream &operator<<(ostream& os, const vector<vector<T> > &mat) { for(size_t i = 0; i < mat.size(); i++) { if(i) os << endl; os << mat[i]; } return os; }
template<class T> ostream &operator<<(ostream &os, const set<T> &s) { os << "{ "; bool first = true; for(typename set<T>::const_iterator setIt = s.begin(); setIt != s.end(); ++setIt) { if(!first) { os << ", "; } first = false; os << *setIt; } return os << " }"; }
template<class T, class U> ostream &operator<<(ostream &os, const map<T, U> &m) { os << "{ "; bool first = true; for(typename map<T, U>::const_iterator mapIt = m.begin(); mapIt != m.end(); ++mapIt) { if(!first) { os << ", "; } first = false; os << mapIt->first << " = " << mapIt->second; } return os << " }"; }
enum CONSOLE_FG { FG_BLACK, FG_RED, FG_GREEN, FG_YELLOW, FG_BLUE, FG_MAGENTA, FG_CYAN, FG_WHITE };
enum CONSOLE_STYLE { STYLE_NONE, STYLE_BOLD };
ostream& operator<<(ostream &os, CONSOLE_FG color) { return os << "\x1b[" << ((int) color + 30) << "m"; }
ostream& operator<<(ostream &os, CONSOLE_STYLE style) { return os << "\x1b[" << (style == STYLE_NONE ? 0 : 1) << "m"; }
// END CUT HERE

struct BitTree {
	
	BitTree(int maxValue) : tree(maxValue + 2, 0) { }
	
	void update(int idx, int val) {
		idx++;
		while(idx < (int) tree.size()) {
			tree[idx] += val;
			idx += (idx & -idx);
		}
	}
	
	int queryCumulative(int idx) {
		idx++;
		int res = 0;
		while(idx) {
			res += tree[idx];
			idx -= (idx & -idx);
		}
		return res;
	}
	
	int queryRange(int start, int end) {
		return queryCumulative(end - 1) - queryCumulative(start - 1);
	}
	
	int querySingle(int idx) {
		return queryCumulative(idx) - queryCumulative(idx - 1);
	}
	
	int findByCumFreq(int freq) {
		int curMaxBit = 1;
		while(2 * curMaxBit < (int) tree.size()) {
			curMaxBit *= 2;
		}
		
		int idx = 0;
		while(curMaxBit) {
			if(idx + curMaxBit < (int) tree.size() && tree[idx + curMaxBit] <= freq) {
				idx += curMaxBit;
				freq -= tree[idx];
			}
			curMaxBit /= 2;				
		}
		
		return freq || !idx ? idx : idx - 1;
	}
	
	vector<int> tree;
};

struct Poi {
	Poi(int x, int y, int d, int time) : x(x), y(y), d(d), time(time) { }

	int x, y, d, time;

	bool operator<(const Poi &other) const {
		return time < other.time;
	}
};

ostream &operator<<(ostream &os, const Poi &poi) {
	return os << "(" << poi.x << ", " << poi.y << "): " << poi.d;
}

struct TopDownComp {
	bool operator()(const Poi &a, const Poi &b) const {
		return a.y > b.y ? true :
			a.y < b.y ? false :
			a.x < b.x;
	}
};

struct RtlComp {
	bool operator()(const Poi &a, const Poi &b) const {
		return a.x > b.x ? true :
			a.x < b.x ? false :
			a.y > b.y;
	}
};

int n, q, X, Y, x, y, d, rowStart;
BitTree btXpY1(300000 + 300000 + 300000), btXpY2(300000 + 300000 + 300000), btY(300000);
vector<Poi> pois;
map<Poi, int> ans;

int main(__attribute__((unused)) int argc, __attribute__((unused)) char **argv) {

	scanf("%d %d", &n, &q);
	for(int i = 0; i < n; i++) {
		scanf("%d %d", &X, &Y);
		btXpY1.update(X + Y, 1);
		btXpY2.update(X + Y, 1);
		btY.update(Y, 1);
		pois.push_back(Poi(X, Y, -1, i));
	}

	for(int i = 0; i < q; i++) {
		scanf("%d %d %d", &x, &y, &d);
		pois.push_back(Poi(x, y, d, i));
	}

	for(int i = 0; i < len(pois); i++) {
		if(pois[i].d != -1) {
			ans[pois[i]] = btXpY1.queryCumulative(pois[i].x + pois[i].y + pois[i].d);
		}
	}

	sort(pois.begin(), pois.end(), TopDownComp());
	rowStart = 0;
	for(int i = 0; i <= len(pois); i++) {
		if(i == len(pois) || (i != 0 && pois[i].y != pois[i - 1].y)) {
			for(int j = rowStart; j < i; j++) {
				if(pois[j].d == -1) {
					btXpY1.update(pois[j].x + pois[j].y, -1);
				}
			}

			for(int j = rowStart; j < i; j++) {
				if(pois[j].d != -1) {
					ans[pois[j]] -= btXpY1.queryCumulative(pois[j].x + pois[j].y + pois[j].d);
				}
			}

			rowStart = i;
		}
	}

	sort(pois.begin(), pois.end(), RtlComp());
	rowStart = 0;
	for(int i = 0; i <= len(pois); i++) {
		if(i == len(pois) || (i != 0 && pois[i].x != pois[i - 1].x)) {
			for(int j = rowStart; j < i; j++) {
				if(pois[j].d == -1) {
					btXpY2.update(pois[j].x + pois[j].y, -1);
				}
			}

			for(int j = rowStart; j < i; j++) {
				if(pois[j].d != -1) {
					ans[pois[j]] -= btXpY2.queryCumulative(pois[j].x + pois[j].y + pois[j].d);
				}
			}

			rowStart = i;
		}
	}

	rowStart = 0;
	for(int i = 0; i <= len(pois); i++) {
		if(i == len(pois) || (i != 0 && pois[i].x != pois[i - 1].x)) {
			for(int j = rowStart; j < i; j++) {
				if(pois[j].d == -1) {
					btY.update(pois[j].y, -1);
				}
			}

			for(int j = rowStart; j < i; j++) {
				if(pois[j].d != -1) {
					ans[pois[j]] += btY.queryCumulative(pois[j].y - 1);
				}
			}

			rowStart = i;
		}
	}

	sort(pois.begin(), pois.end());
	for(int i = 0; i < len(pois); i++) {
		if(pois[i].d != -1) {
			printf("%d\n", ans[pois[i]]);
		}
	}

	return 0;
}
