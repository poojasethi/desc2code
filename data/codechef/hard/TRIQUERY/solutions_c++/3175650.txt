//This is the painkiller...
#include <bits/stdc++.h>
using namespace std;
#define mem(a,v) memset(a,v,sizeof(a))
#define pb push_back
#define mp make_pair
#define sz(x) int((x).size())
#define x first
#define y second
#define all(a) (a).begin(),(a).end()
#define rep(i,n) for(int i=0;i<int(n);i++)
#define repi(i,a,n) for(int i=int(a);i<int(n);i++)
#define repe(i,a) for(__typeof((a).begin()) i=(a).begin();i!=(a).end();i++)
#if !ONLINE_JUDGE
#define debug(args...) (Debugger()) , args
#else
#define debug(args...)
#endif

class Debugger{ public: Debugger(const std::string& _separator = ","): first(true), separator(_separator){} template<typename ObjectType>Debugger& operator , (const ObjectType& v) { if(!first) std::cerr << separator; std::cerr << v; first = false; return *this; } ~Debugger() { std::cerr << endl; } private: bool first; std::string separator; }; template <typename T1, typename T2> inline std::ostream& operator << (std::ostream& os, const std::pair<T1, T2>& p) { return os << "(" << p.first << "," << p.second << ")"; } template<typename T> inline std::ostream &operator << (std::ostream & os,const std::vector<T>& v) { bool first = true; os << "{"; for(unsigned int i = 0;i < v.size();i++){ if(!first) os << ","; os << v[i]; first = false; } return os << "}"; } template<typename T> inline std::ostream &operator << (std::ostream & os,const std::set<T>& v) { bool first = true; os << "{"; for (typename std::set<T>::const_iterator ii = v.begin();ii != v.end();++ii) { if(!first) os << ","; os << *ii; first = false; } return os << "}"; } template<typename T1, typename T2> inline std::ostream &operator << (std::ostream & os,const std::map<T1, T2>& v) { bool first = true; os << "{"; for (typename std::map<T1, T2>::const_iterator ii = v.begin();ii != v.end();++ii) { if(!first) os << ","; os << *ii ; first = false; } return os << "}"; }template<class X,class Y> std::istream & operator >>(std::istream &i,std::pair<X,Y> &a){i>>a.first>>a.second; return i;}template<class X> std::istream & operator >>(std::istream &is,std::vector<X> &a){for(int i=0;i<int(a.size());i++)is>>a[i];return is;}

typedef long long ll;
typedef pair<int,int> pii;
typedef vector<int> vi;

int X[300005],Y[300005],size=300005;

void update(int id,int val,int *tree)
{
	assert(id>0);
	while(id<size)
	{
		tree[id]+=val;
		id+=id&-id;
	}
}

int read(int id,int *tree)
{
	int sum=0;
	while(id>0)
	{
		sum+=tree[id];
		id-=id&-id;
	}
	return sum;
}

typedef pair<pii,pii> node;
bool comp(node a,node b)
{
	if(a.x.x+a.x.y!=b.x.x+b.x.y)
		return (a.x.x+a.x.y<b.x.x+b.x.y);
	return a.y.y<b.y.y;
}
node points[700005];
int ans[200005];

int main()
{
	//~ freopen("in.txt","r",stdin);
	int n,q,c=0;
	scanf("%d%d",&n,&q);
	rep(i,n)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		points[c++]=mp(mp(x,y),mp(-1,-1));
	}
	rep(i,q)
	{
		int x,y,d;
		scanf("%d%d%d",&x,&y,&d);
		points[c++]=mp(mp(x-1,y-1),mp(-1,i));
		points[c++]=mp(mp(x+d,y),mp(d,i));
	}
	sort(points,points+c,comp);
	int cnt=0;
	rep(i,c)
	{
		node now=points[i];
		if(now.y.y==-1)
		{
			cnt++;
			update(now.x.x,1,X);
			update(now.x.y,1,Y);
		}
		else if(now.y.x==-1)
		{
			ans[now.y.y]=read(now.x.x,X)+read(now.x.y,Y)-cnt;
		}
		else
		{
			ans[now.y.y]+=cnt-read(now.x.x-now.y.x-1,X)-read(now.x.y-1,Y);
		}
	}
	rep(i,q)printf("%d\n",ans[i]);
	return 0;
}