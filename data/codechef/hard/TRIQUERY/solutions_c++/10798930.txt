//---------------------------JUGNU: LET YOUR LIGHT SHINE---------------------------//
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <map>
#include <set>
#define ll long long int
#define pb push_back
#define pf push_front
#define sz size
#define mk make_pair
#define ln length
#define fr(i,a,b) for(i=a;i<b;i++)
#define fre(i,a,b) for(i=a;i<=b;i++)
#define frr(i,a,b) for(i=a;i>=b;i--)
#define sc(a) scanf("%d",&a)
#define sm(a,b) scanf("%d%d", &a, &b)
#define pr(a) printf("%d\n", a)
#define pm(a,b) printf("%d %d\n", a, b)
#define cn(a) cin >> a
#define ct(a) cout << a << endl
#define isset(x,i) ((x>>i)&1)
#define fastScan ios_base::sync_with_stdio(0); cin.tie(NULL);
#define MAXN 900005

#define trace1(x)       cerr << #x << " : " << x << endl;
#define trace2(x, y)    cerr << #x << " : " << x << " | " << #y << " : " << y << endl;
#define trace3(x, y, z) cerr << #x << " : " << x << " | " << #y << " : " << y << " | " << #z << " : " << z << endl;
#define cline cout << "----------------------" << endl;

using namespace std;

typedef struct event{
	int x, y, idx, type;
	event(){};
	event(int A, int B, int C, int D){
		x = A;
		y = B;
		idx = C;
		type = D;
	}
}event;


vector< pair<int, int> > pointsCount[MAXN];
int result[MAXN], BIT[MAXN][2];
vector<event> events[MAXN];
set <pair<int, int> > S;

void update(int idx, int type){
	while(idx < MAXN){
		BIT[idx][type] += 1;
		idx += (idx & -idx);
	}
	return;
}

int query(int idx, int type){
	int sum = 0;
	while(idx > 0){
		sum += BIT[idx][type];
		idx -= (idx & -idx);
	}
	return sum;
}

int main()
{
	int i, j, t, n, m, k, l, r, mini, cnt = 0, maxi, flag, temp;
	sm(n, m);
	fr(i, 0, n){
		sm(l, r);
		pointsCount[l + r].pb(mk(l, r));
		S.insert(mk(l, r));
	}
	fre(i, 1, m){
		sm(l, r);
		sc(k);
		event temp0(l - 1, r - 1, i, 0);
		events[l + k + r].pb(temp0);
		event temp1(l - 1, r - 1, i, 1);
		events[l + r].pb(temp1);
	}

	fr(i, 2, MAXN){
		cnt += (int)pointsCount[i].sz();
		fr(j, 0, pointsCount[i].sz()){
			update(pointsCount[i][j].first, 0);
			update(pointsCount[i][j].second, 1);
		}
		fr(j, 0, events[i].sz()){
			l = query(events[i][j].x, 0);
			r = query(events[i][j].y, 1);
			if(events[i][j].type == 1){
				if(S.find(mk(events[i][j].x + 1, events[i][j].y + 1)) != S.end()) temp = l + r - cnt + 1;
				else temp = l + r - cnt ;
				result[events[i][j].idx] += temp;
			}
			else{
				temp = cnt - l - r;
				result[events[i][j].idx] += temp;
			}
		}
	}
	fre(i, 1, m) pr(result[i]);
  return 0;
}
