#include <unistd.h>
#include <algorithm>
#include <cassert>
#include <cstdio>
#include <cstdlib>
#include <cctype>
#include <cmath>
#include <cstring>
#include <iostream>
#include <sstream>
#include <string>
#include <utility>
#include <vector>
#include <cassert>
#include <ctime>
#include <queue>
#include <tr1/random>
using namespace std;
using namespace std::tr1;
#define VAR(a,b) __typeof(b) a=(b)
#define REP(i,n) for(int _n=n, i=0;i<_n;++i)
#define FOR(i,a,b) for(int i=(a),_b=(b);i<=_b;++i)
#define FORD(i,a,b) for(int i=(a),_b=(b);i>=_b;--i)
#define FOREACH(it,c) for(VAR(it,(c).begin());it!=(c).end();++it)
#define TRACE(x) cerr << "TRACE(" #x ")" << endl;
#define DEBUG(x) cerr << #x << " = " << (x) << endl;
 
typedef unsigned long long ULL;
typedef long long LL;
const int INF = 1000000000;
template<class T> inline int size(const T&c) { return c.size(); }
 
class INPUT {
  static const int BUFSIZE = 1<<16;
  char buffer[BUFSIZE];
  char *bufpos;
  char *bufend;
  void grabBuffer() {
    bufpos = buffer;
    bufend = buffer + read(0, buffer, BUFSIZE);
  }
 public:
  INPUT() { grabBuffer(); }
  bool eof() { return bufend==buffer; }
  char next() { return *bufpos; }
  static bool myisspace(char c) { return c <= ' '; }
  void skipWS();
  template<class T> T get();
  template<class T> void operator()(T &x) { x = get<T>(); }
  template<class A,class B> void operator()(A& a,B& b) {
    operator()(a); operator()(b);
  }
  template<class A,class B,class C> void operator()(A& a,B& b,C&c) {
    operator()(a,b); operator()(c);
  }
  template<class A,class B,class C,class D> void operator()(A& a,B& b,C&c,D&d) {
    operator()(a,b,c); operator()(d);
  }
  template<class A,class B,class C,class D,class E> void operator()(A& a,B& b,C&c,D&d,E&e) {
    operator()(a,b,c,d); operator()(e);
  }
  template<class A,class B,class C,class D,class E,class F> void operator()(A& a,B& b,C&c,D&d,E&e,F&f) {
    operator()(a,b,c,d,e); operator()(f);
  }
};
 
template<> inline char INPUT::get<char>() {
  char res = *bufpos++;
  if(bufpos==bufend) grabBuffer();
  return res;
}
 
void INPUT::skipWS() {
  while(!eof() && myisspace(next())) get<char>();
}
 
template<> unsigned INPUT::get<unsigned>() {
  skipWS();
  unsigned x = 0;
  while(!eof() && isdigit(next())) {
    x = 10u * x + (get<char>()-'0');
  }
  return x;
}
 
template<> int INPUT::get<int>() {
  skipWS();
  bool neg = false;
  if(!eof() && next()=='-') { neg=true; get<char>(); }
  unsigned x = get<unsigned>();
  if (neg) x = -x;
  return static_cast<int>(x);
}
 
template<> ULL INPUT::get<ULL>() {
  skipWS();
  ULL x = 0;
  while(!eof() && isdigit(next())) {
    x = 10ULL * x + (get<char>()-'0');
  }
  return x;
}
 
template<> LL INPUT::get<LL>() {
  skipWS();
  bool neg = false;
  if(!eof() && next()=='-') { neg=true; get<char>(); }
  ULL x = get<ULL>();
  if (neg) x = -x;
  return static_cast<LL>(x);
}
 
template<> string INPUT::get<string>() {
  skipWS();
  string s;
  while(!eof() && !myisspace(next())) s += get<char>();
  return s;
}
 
class OUTPUT {
  static const int BUFSIZE = 1<<16;
  char buffer[BUFSIZE];
  char *bufpos;
  char *BUFLIMIT;
 public:
  void flushBuffer();
  OUTPUT():bufpos(buffer),BUFLIMIT(buffer+BUFSIZE-100) {}
  ~OUTPUT() { flushBuffer(); }
  void operator()(char c);
  void operator()(unsigned x);
  void operator()(int x);
  void operator()(ULL x);
  void operator()(LL x);
  void operator()(const char*s);
  void operator()(const string&s) { operator()(s.c_str()); }
  template<class A,class B>
  void operator()(const A& a,const B& b) {
    operator()(a); operator()(b);
  }
  template<class A,class B,class C>
  void operator()(const A& a,const B& b,const C&c) {
    operator()(a,b); operator()(c);
  }
  template<class A,class B,class C,class D>
  void operator()(const A& a,const B& b,const C&c,const D&d) {
    operator()(a,b,c); operator()(d);
  }
  template<class A,class B,class C,class D,class E>
  void operator()(const A& a,const B& b,const C&c,const D&d,const E&e) {
    operator()(a,b,c,d); operator()(e);
  }
  template<class A,class B,class C,class D,class E,class F>
  void operator()(const A& a,const B& b,const C&c,const D&d,const E&e,const F&f) {
    operator()(a,b,c,d,e); operator()(f);
  }
};
 
void OUTPUT::flushBuffer() {
  char *p = buffer;
  while(p < bufpos) {
    p += write(1, p, bufpos-p);
  }
  bufpos = buffer;
}
 
inline void OUTPUT::operator()(char c) {
  *bufpos = c;
  ++bufpos;
  if(bufpos >= BUFLIMIT) flushBuffer();
}
 
void OUTPUT::operator()(unsigned x) {
  char *old = bufpos;
  do {
    *bufpos = char('0' + x % 10u);
    x /= 10u;
    ++bufpos;
  } while(x);
  reverse(old, bufpos);
  if(bufpos >= BUFLIMIT) flushBuffer();
}
 
void OUTPUT::operator()(int x) {
  if(x<0) {
    (*this)('-', -static_cast<unsigned>(x));
  } else {
    (*this)(static_cast<unsigned>(x));
  }
}
 
void OUTPUT::operator()(ULL x) {
  char *old = bufpos;
  do {
    *bufpos = char('0' + x % 10u);
    x /= 10u;
    ++bufpos;
  } while(x);
  reverse(old, bufpos);
  if(bufpos >= BUFLIMIT) flushBuffer();
}
 
void OUTPUT::operator()(LL x) {
  if(x<0) {
    (*this)('-', -static_cast<ULL>(x));
  } else {
    (*this)(static_cast<ULL>(x));
  }
}
 
void OUTPUT::operator()(const char*s) {
  while(*s) operator()(*s++);
}
 
INPUT input;
OUTPUT output;
 
//}}}
 
const int MAX = 300000;
 
class Counter {
  int cnt[MAX+1];
 public:
  Counter() { memset(cnt, 0, sizeof(cnt)); }
  void add(int x);
  int ge(int x) const;
  int total() const { return cnt[0]; }
};
 
void Counter::add(int x) {
  for(;;) {
    ++cnt[x];
    if(!x) break;
    x &= x-1;
  }
}
 
int Counter::ge(int x) const {
  int res = 0;
  while(x<=MAX) {
    res += cnt[x];
    x += x ^ (x&(x-1));
  }
  return res;
}
 
Counter counterX, counterY;
 
void addPoint(int x, int y) {
  counterX.add(x);
  counterY.add(y);
}
 
int queryLT(int x, int y) {
  return counterX.total() - counterX.ge(x) - counterY.ge(y);
}
 
int queryGE(int x, int y, int lt) {
  return counterX.ge(x) + counterY.ge(y) + lt - counterX.total();
}
 
struct Event {
  int t;
  int x,y;
  int queryNr;
};
 
inline bool operator<(const Event &a, const Event &b) {
  return a.t < b.t;
}
 
int main() {
  int N,Q; input(N,Q);
  vector<Event> events;
  events.reserve(N+2*Q);
  REP(i,N) {
    Event e;
    e.queryNr = -1;
    input(e.x, e.y);
    e.t = 3*(e.x + e.y)+1;
    events.push_back(e);
  }
  REP(i,Q) {
    Event e;
    e.queryNr = i;
    int d;
    input(e.x, e.y, d);
    e.t = 3*(e.x + e.y);
    events.push_back(e);
    e.t = 3*(e.x + e.y + d) + 2;
    events.push_back(e);
  }
  sort(events.begin(), events.end());
  vector<int> res(Q, 0);
  FOREACH(it, events) {
    switch(it->t % 3) {
      case 0:
        res[it->queryNr] = queryLT(it->x, it->y);
        break;
      case 1:
        addPoint(it->x, it->y);
        break;
      case 2:
        res[it->queryNr] = queryGE(it->x, it->y, res[it->queryNr]);
        break;
    }
  }
  FOREACH(it, res) output(*it, '\n');
}
 