//c libraries
#include <cstdio>
#include <cstring>
#include <cmath>
#include <climits>
//cpp libraries
#include <iostream>
#include <algorithm>
#include <vector>

//input
#define ni(x) scanf("%d",&x)
#define nl(x) scanf("%lld",&x)
#define nc(n) scanf("%c",&n)
#define nf(n) scanf("%lf",&n)
#define ns(n) scanf("%s",n)
//constants
#define INF 0x7f7f7f7f
#define INFL 0x7f7f7f7f7f7f7f7fL
#define EPS 1e-9
//hardware funcs
#define msb(x) 31-__builtin_clz (x)
#define setbits(x) __builtin_popcount(x)
#define gcd __gcd
//convenience
#define v1 first
#define v2 second
#define pb push_back
#define foreach(v, c)  for( typeof( (c).begin()) v = (c).begin();  v != (c).end(); ++v)

using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef vector<int> vi;


struct BIT{
   int maxn;
   int* tree;

   void set(int sz){
      maxn=sz;
      tree = new int[maxn+1];
      memset(tree,0,4*(maxn+1));
   }
   void set(int* ds,int sz){
      maxn=sz;
      tree=ds;
      memset(tree,0,4*(maxn+1));
   }
   void set(){
      memset(tree,0,4*(maxn+1));
   }
   BIT(){}
   BIT(int sz){set(sz);}
   BIT(int* ds,int sz){set(ds,sz);}
   int read(int idx)
   {
      int sum = 0;
      while (idx > 0) sum =(sum+tree[idx]) , idx -= (idx & -idx);
      return sum;
   }

   void update(int idx,int val)
   {
	   while (idx <= maxn){
         tree[idx]=(tree[idx]+val);
         idx += (idx & -idx);
      }
   }
};
struct query{
   int x,y,d,ind;
   int sum1(){return x+y+d;}
   int sum2(){return x+y;}
};
bool cmpq(query q1,query q2){
   return q1.sum2()<q2.sum2();
}
bool cmp(query q1,query q2){
   return q1.sum1()<q2.sum1();
}
bool cmpp(pii q1,pii q2){
   return (q1.v1 + q1.v2)<(q2.v1 + q2.v2);
}

BIT bx,by;
int ds1[400001],ds2[400001];
pii points[300000];
query queries[200000];
int ans[200000];

int main (){
   bx.set(ds1,400000);
   by.set(ds2,400000);
   int n,q; ni(n); ni(q);
   for (int i = 0; i < n; i++)
   {
      ni(points[i].v1); ni(points[i].v2);
   }
   for (int i = 0; i < q; i++)
   {
      ni(queries[i].x);
      ni(queries[i].y);
      ni(queries[i].d);
      queries[i].ind=i;
   }
   sort(points,points+n,cmpp);
   sort(queries,queries+q,cmpq);

   int pq=0,pn=0;
   for ( ; pq < q; pq++){
      for ( ; pn < n; pn++){
         if((points[pn].v1 + points[pn].v2)  >= queries[pq].sum2()) break;
         bx.update(points[pn].v1+1,1);
         by.update(points[pn].v2+1,1);
      }
      ans[queries[pq].ind] = bx.read(queries[pq].x) + by.read(queries[pq].y)-pn;
   }

   pq=0,pn=0;
   bx.set();
   by.set();
   sort(queries,queries+q,cmp);
   for ( ; pq < q; pq++){
      for ( ; pn < n; pn++){
         if((points[pn].v1 + points[pn].v2)  > queries[pq].sum1()) break;
         bx.update(points[pn].v1 +1,1);
         by.update(points[pn].v2 +1,1);
      }
      ans[queries[pq].ind] += pn  - bx.read(queries[pq].x)- by.read(queries[pq].y);
   }
   for (int i = 0; i < q; i++)
   {
      printf("%d\n",ans[i]);
   }
}
