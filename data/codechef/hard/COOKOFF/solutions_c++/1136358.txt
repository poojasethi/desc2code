#include <iostream>
#include <cstdio>
using namespace std;

#include <bitset>
#include <algorithm>
#include <iomanip>
#include <cmath>
#include <cstring>

# define FR(i, n)           for( int i = 0; i<=n; i++)
# define FRm(i, m, n)     for( int i = m; i <=n; i++)
# define FRrev(i, n)         for( int i = n; i >= 0; i-- )
# define FRrevm(i,n,m)         for( int i = n; i >= m; i-- )

# define PF       printf
# define PFS PF(" ")
# define PFd(x)   printf("%d" , x )
# define PFdS(x)   printf("%d " , x )
# define PFdN(x)  printf("%d\n" , x )
# define PFN	  printf("\n")
# define SF    scanf
# define SFd(x) scanf("%d",&x)
# define SFd2(x,y) scanf("%d%d",&x,&y)

#define nmax 1002

int inp[nmax];
int t,n,m,c1,c2;

int bSearch(int key , int len , int arr[])
{
	int left,right,mid;
	
	left=0; right=len-1; 
	while(left<=right)
	{
		mid=(left+right)/2;
		if(inp[mid]==key) return mid;
		
		if(key<arr[mid]) right=mid-1;
		else left=mid+1;
		
	}
	return -1;
	
}


int bSearch( int key , int len )
{
	return bSearch(key , len , inp);
}


int solveBinary(int low, int high, int p1 , int p2)
{
	int next,cur,mid,start=p1;
	int c1=inp[p1];
	int c2=inp[p2];
	
	while( (1+low)<high )
	{
			mid=(low+high)/2;
			cur=start;
			
			FRm(i,1,m+1) 
			{
				next=cur;
				while( inp[next]<c2 && inp[next+1]<=(inp[cur]+mid)  )
				{
					next++;
				}
				cur=next;
			}
			
			if(inp[cur]<c2)  
				low=mid;
			else   // if u can't get all m values for current mid, then the mid required is less than the current mid
				high=mid;
	}
	
	return high;
	
}








int main()
{
	
	int ans,count,p1,p2,left,right;
	
	SFd(t);
	
	while(t--)
	{		
		
		SFd2(n,m);
		SFd2(c1,c2);
		
		int qq=max(c1,c2),ww=min(c1,c2);
		c1=ww; c2=qq;
		
		FR(i,n-1)SFd(inp[i]);
		inp[n++]=c1; inp[n++]=c2;
		sort(inp,inp+n);
		
		int total=n;
		p1=bSearch(min(c1,c2),total);
		p2=bSearch(max(c1,c2),total);
		
		int check=(p2-p1-1);
		
		if(check<=m)
		{
			ans=inp[p1+1]-inp[p1];
			FRm(i,p1,p2-1)ans=max(ans,inp[i+1]-inp[i]);
			
			left=p1-1;
			right=p2+1;
			count=check+2;
			
			while(count<m)
			{
				if( ( right>=(total) ) || (left>=0 && (inp[left+1]-inp[left])<(inp[right]-inp[right-1]) )  )
				{
					ans=max( ans , inp[left+1]-inp[left] );
					left--;
				}
				else
				{
					ans=max( ans , (inp[right]-inp[right-1]) );
					right++;
				}
				count++;
			}
			
		}
		else
		{
			//ans=0;
			ans=solveBinary(0 , abs(c1-c2) , p1 , p2);
		}
		
		cout<<ans<<endl;
		
	}
	
	return 0;
}
