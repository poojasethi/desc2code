/* ############################################################################
 * START OF HEADER 
 * ############################################################################
 */
#include<cstdio>
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<cstdlib>
#include<cmath>
#include<cassert>
#include<ctime>
#include<algorithm>
#include<vector>
#include<stack>
#include<queue>
#include<deque>
#include<list>
#include<set>
#include<map>
using namespace std;
 
#define LL long long
#define LD long double

#define sc(x)  scanf("%c",&x) //char
#define si(x)  scanf("%d",&x) //int
#define sf(x)  scanf("%f",&x) //float
#define sl(x)  scanf("%I64d",&x) //int64_
#define sd(x)  scanf("%lf",&x) //double
#define sld(x) scanf("%Lf",&x) //long double
#define slld(x) scanf("%lld",&x) //long long int
#define ss(x)  scanf("%s",x) // string

#define pc(x)  printf("%c",x)
#define pi(x)  printf("%d ",x)
#define pf(x)  printf("%f ",x)
#define pl(x)  printf("%I64d ",x)
#define pd(x)  printf("%lf ",x)
#define pld(x) printf("%Lf ",x)
#define plldn(x) printf("%lldn", x);
#define ps(x) printf("%s", x);

#define pin(x)  printf("%d\n",x)
#define pln(x)  printf("%I64d\n",x)
#define pfn(x)  printf("%f\n",x)
#define pdn(x)  printf("%lf\n",x)
#define pldn(x) printf("%Lf\n",x)
#define plld(x) printf("%lld\n", x);
#define psn(x)  printf("%s\n",x)

#define pn() printf("\n")
#define _p() printf(" ")

#define MODVAL 1000000007

#define FORab(i,a,b) for(int i=a;i<=b;i++)
#define REVab(i,a,b) for(int i=a;i>=b;i--)
#define FORn(i,n) for(int i=0;i<n;i++)
#define REVn(i,n) for(int i=n;i>=0;i--)
#define FORSTL(it, a) for(it=a.begin(); it!=a.end(); it++)
#define REVSTL(it, a) for(it=a.end(); it!=a.begin(); it--)

#define MEM(a,v) memset(a,v,sizeof(a))
#define MAX(x,y) (x)>(y)?(x):(y)
#define MIN(x,y) (x)<(y)?(x):(y)
#define pb push_back
#define pob pop_back
#define b() begin()
#define e() end()
#define s() size()
#define cl() clear()
#define fi first
#define se second
#define INF (1000000000)
#define SZ 100000
#define MOD (1<<30)

#define VS vector<string>
#define VI vector<int>
#define VF vector<float>
#define VD vector<double>
#define MII map<int,int>
#define MIS map<int, string>
#define MSI map<string, int> 
#define MSS map<string, string>

#define VSI vector<string>::iterator
#define VII vector<int>::iterator
#define VFI vector<float>::iterator
#define VDI vector<double>::iterator
#define MIII map<int,int>::iterator
#define MISI map<int, string>::iterator
#define MSII map<string, int>::iterator 
#define MSSI map<string, string>::iterator
#define print_array(x,n) for(int i=0; i<n; i++) { cout << x[i] << endl; }
#define TEST int T;scanf("%d",&T);while(T--)
#define CASES int N;scanf("%d",&N);while(N--)

/* ############################################################################
 * END OF HEADER 
 * ############################################################################
 */
int g_inconvenience = 0;
typedef vector<pair<int, int> > VPII;
VPII steps[501];
bool all_calc[501];

int RNG_arr[] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 1- 10
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 11 - 20
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 21 - 30
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 31 - 40
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, //41 - 50
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 51 - 60
  0, 0, 0, 0, 1, 2, 3, 4, 5, 6, // 61 - 70
  7, 8, 9, 10, 11, 12, 13, 14, 15, 16, // 71 - 80 
  17, 18, 19, 20, 21, 22, 23, 24, 25, 26, // 81 - 90 
  0, 0, 0, 0, 0, 0, 1, 2, 3, 4, // 91 - 100 
  5, 6, 7, 8, 9, 10, 11, 12, 13, 14, // 101 - 110 
  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 111 - 120 
  25, 26, 0, 0, 0, 0, 0, 0, 0, 0};  // 121 - 130 

template<typename T> T 
horners_algo(vector<T> &co_eff, T x, int R) {
  //* co_eff[0] represents MSB and co_eff[size-1] represents LSB */
  T ans=0;
  if(co_eff.size() == 0) {
    ans = 0;
  } else if(co_eff.size() == 1) {
    ans = co_eff[0];
  } else {
    ans = co_eff[0]*x + co_eff[1];
    for(int i=2; i<co_eff.size(); i++) {
      ans = ((ans)*x + co_eff[i])%R;
    }
  }
  return ans;
}

int
RNG(string &name, int R) {
  vector <int> co_eff;
  for(int i=0; i < name.size(); i++) {
    co_eff.pb(RNG_arr[name[i]-1]);
  }
  return (horners_algo<int>(co_eff, 33, R) + g_inconvenience);
}

int A[350000];
int sumA[350000];

void
calculate_steps(int R) {
  /* Check with testers implementation of this algo */
  vector<int> firstVisit(R, -1);
  for (int k = 0; ; ++k) {
    A[k] = (k < 3 ? k : A[k - 1] + A[k - 2] + A[k - 3]) % R;
    sumA[k] = A[k];
    if (k > 0) {
      sumA[k] = (sumA[k] + sumA[k - 1]) % R;
    }
    int r = sumA[k];
    if(firstVisit[r] < 0) {
      firstVisit[r] = k;
      steps[R].push_back(make_pair(k, r));
    }
    if (k >= 3 && sumA[k - 3] == 0 && A[k - 2] == 0 && A[k - 1] == 1 % R && A[k] == 2 % R) {
      break;
    }
  }
  all_calc[R] = true;  
}

int main() {
  memset(all_calc, false, 501*sizeof(bool));
  CASES {
    // input N and R
    int N, R;
    si(N); si(R);
    if(!all_calc[R]) {
      calculate_steps(R);
    } 
    vector<int> time(R, 0);
    int day = 0; 
    int prev = 0; 
    g_inconvenience = 0;
    for (int n = 0; n < N; ++n) {
      int H, M, G;
      char S[11];
      int wait_time = 60 * 10000000;
      si(H); si(M); si(G);
      scanf("%s", S);
      string name(S);
      int cur = 60 * H + M;
      if (prev > cur) {
        day++;
      }
      prev = cur;
      cur += 24 * 60 * day;
      int r0 = RNG(name, R);

      VPII &x = steps[R];
      VPII::iterator it;
      bool found=false;
      for(it=x.b(); (it!=x.end() && !found); it++) {
        int k = it->first;
        int r = it->second;
        int rk = (r+r0)%R;
        if(time[rk] <= cur) {
          /* can occupy */
          time[rk] = cur + G*60;
          g_inconvenience = (g_inconvenience + k)%R;
          printf("%d\n", k);
          found = true;
        }
        if(wait_time > (time[rk] - cur)) {
          wait_time = time[rk] - cur;
        }
      }
      if(!found) {
        printf("-%d\n", wait_time);
        g_inconvenience = (g_inconvenience + wait_time)%R;
      }
    }
  }
}

