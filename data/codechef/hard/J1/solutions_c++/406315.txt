#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

#define SET(x, i) (x|=(1<<i))
#define RESET(x, i) (x&=(~(1<<i)))
#define IS(x, i) ((x&(1<<i))!=0) 
inline int getBox(int i, int j) {
    int r = i/3;
    int c = j/3;
    return r*3+c;
}

bool inline d1(int i,int j) {
     if(i==j) return true;
     return false;
}

bool inline d2(int i, int j) {
     if(i==(9-j-1)) return true;
     return false;
}

int cord[9][9];

unsigned char grid[9][9];
int box[9], x[9], y[9], d[2];

struct point {
       unsigned char x, y;
       bool operator<(const point &b) const{
            if(x==b.x) return y<b.y;
            return x<b.x;
       }
};

bool filled[9][9];
point unfilled[81];
int n;

void init() {
     
     memset(x, 0, sizeof(x));
     memset(y, 0, sizeof(y));
     memset(d, 0, sizeof(d));
     for(int i = 0; i < 9; i++) memset(filled[i], 0, sizeof(filled[i]));
     memset(box, 0, sizeof(box));
}

bool finished;

void dfs(int k) {
     if(finished) return;
     if(k == n){
          for(int i = 0; i < 9; i++) { 
                  for(int j = 0; j < 9; j++)
                    printf("%c", grid[i][j]);
          printf("\n");
          }
          finished = true;
          return;
     } 
     
     int minr, minc;
     int tmin = (int)1e7;
     int r, c;
     for(int i = 0; i < n; i++)
     {
       r = unfilled[i].x; c = unfilled[i].y;
       if(!filled[r][c]) {
           int possible = 0;
           for(int j = 1; j <= 9; j++) {
               if(!IS(x[r],j) && !IS(y[c],j) && !IS(box[cord[r][c]],j)) {
               if(d1(r,c) && IS(d[0], j)) continue;
               if(d2(r,c) && IS(d[1], j)) continue;
               possible++;
           }
           }
           if(possible <= tmin) {
                       tmin = possible;
                       minr = r;
                       minc = c;
           }
         }
     }
     r = minr;
     c = minc;   
     //printf("backtracking %d %d n==%dk==%d\n", r, c, n, k);
     //getchar();
     //getchar();                                         
     filled[r][c] = 1;
     for(int i = 1; i <= 9; i++)
             if(!IS(x[r],i) && !IS(y[c],i) && !IS(box[cord[r][c]],i)) {
               if(d1(r,c) && IS(d[0], i)) continue;
               if(d2(r,c) && IS(d[1], i)) continue;
               grid[r][c] = '0'+i;
               SET(x[r],i);SET(y[c],i);SET(box[cord[r][c]],i);
               if(d1(r,c))SET(d[0], i);if(d2(r,c))SET(d[1], i);
               dfs(k+1);
               if(finished) return;
               RESET(x[r],i);RESET(y[c],i);RESET(box[cord[r][c]],i);
               if(d1(r,c))RESET(d[0], i);if(d2(r,c))RESET(d[1], i);
             }
     filled[r][c] = 0;
}


int main() {
    for(int i = 0; i < 9; i++)
       memset(cord[i], 0, sizeof(cord[i]));
    for(int i = 0; i < 9; i++)
       for(int j = 0; j < 9; j++)
         cord[i][j] = getBox(i,j);
    int t;
    scanf("%d", &t);
    
    while(t--) {
    finished = false;
    init();
    n=0;
    
    for(int i = 0; i < 9; i++)
      scanf("%s", grid[i]);
      
    for(int i = 0; i < 9; i++) for(int j = 0; j < 9; j++)
      if(grid[i][j]!='.'){
                          
            if(d1(i, j)) SET(d[0], grid[i][j]-'0');
            if(d2(i, j)) SET(d[1], grid[i][j]-'0');
            SET(x[i],grid[i][j]-'0');
            SET(y[j],grid[i][j]-'0');
            SET(box[cord[i][j]],grid[i][j]-'0');
      } else {
             unfilled[n].x = i;
             unfilled[n].y = j;
             n++;;
      }    
    dfs(0);
    printf("\n");
    }
    
    
}

