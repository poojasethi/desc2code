#include<algorithm>
#include <fstream>
#include<bitset>
#include<cctype>
#include<cmath>
#include<complex>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<functional>
#include<iostream>
#include<istream>
#include<iterator>
#include<list>
#include<map>
#include<numeric>
#include<queue>
#include<set>
#include<sstream>
#include<stack>
#include<strstream>
#include<string>
#include<utility>
#include<vector>
#include<iomanip>
#include<ctime>
using namespace std;
/******************************************************************************************/
typedef long long int LLI;
typedef unsigned long long int ULLI;
#define IMAX ((unsigned)1<<31)-1
#define eps 1e-11
#define LIMAX (1LL<<63)-1
#define ULIMAX (1LL<<64)-1
#define UIMAX ((LLI)1<<32)-1
#define MP(X,Y) make_pair(X,Y)
#define REP(i,n) for(int i=0;i<n;i++)
#define FOR(i,a,b,c) for(int i=a;i<=b;i+=c)
#define fill(a,v) memset(a,v,sizeof(a))
#define fillx(a,v,n) memset(a,v,n*sizeof(a[0]))
#define DEBUG(x) cout << #x << ": " << x << endl;
#define all(x) (x).begin(),(x).end()
#define SORT(x) sort(all(x))
#define VI vector<int>
#define VS vector<string>
#define PB push_back
#define REV(a) reverse(all(a))
typedef pair<int, int>PII;

template<class T> inline T MIN_3(T a, T b, T c)
{
    return min(min(a, b), c);
}
template<class T> inline T MAX_3(T a, T b, T c)
{
    return max(max(a, b), c);
}

template<class T> inline T BIGMOD(T n, T m, T mod)
{
    LLI ans = 1;
    LLI k = n;
    while(m)
    {
        if(m & 1)
        {
            ans *= k;
            if(ans>mod) ans %= mod;
        }
        k *= k;
        if(k>mod) k %= mod;
        m >>= 1;
    }
    return ans;
}


inline int DBLCMP(double a, double b)
{
    if(fabs(a - b) <= eps) return 0;
    if(a < b) return -1;
    return 1;
}
template<class T> inline T sqr(T x)
{
    return x*x;
}
template<class T> inline int countbit(T n)
{
    return (n == 0) ? 0 : (1 + countbit(n&(n - 1)));
}

template<class T> string toString(T n)
{
    ostringstream ost;
    ost << n;
    ost.flush();
    return ost.str();
}
template<class T> string toBinary(T n)
{
    string ret="";
    while(n)
    {
        if(n%2==1)ret+='1';
        else ret+='0';
        n>>=1;
    }
    reverse(ret.begin(),ret.end());
    return ret;
}
void combination(int n,vector< vector<int> > &ret)
{
    ret.resize(n+1, vector<int>(n+1, 0));
    for(int i=1; i<=n; i++)
    {
        ret[i][0]=ret[i][i]=1;
        for(int j=1; j<i; j++)
        {
            ret[i][j]=ret[i-1][j]+ret[i-1][j-1];
        }
    }
}
int toInt(string s)
{
    int r = 0;
    istringstream sin(s);
    sin >> r;
    return r;
}
LLI toLInt(string s)
{
    LLI r = 0;
    istringstream sin(s);
    sin >> r;
    return r;
}
double toDouble(string s)
{
    double r = 0;
    istringstream sin(s);
    sin >> r;
    return r;
}
vector<string> parse(string temp)
{
    vector<string> ans;
    ans.clear();
    string s;
    istringstream iss(temp);
    while (iss >> s)ans.PB(s);
    return ans;
}
template<class T> inline T gcd(T a, T b)
{
    if (a < 0)return gcd(-a, b);
    if (b < 0)return gcd(a, -b);
    return (b == 0) ? a : gcd(b, a % b);
}
template<class T> inline T lcm(T a, T b)
{
    if (a < 0)return lcm(-a, b);
    if (b < 0)return lcm(a, -b);
    return a*(b / gcd(a, b));
}
template<class T> inline T power(T b, T p)
{
    if (p < 0)return -1;
    if (b <= 0)return -2;
    if (!p)return 1;
    return b*power(b, p - 1);
}

template<class T> inline void asd(T &ret)
{
    char r;
    bool start=false,neg=false;
    ret=0;
    while(true)
    {
        r=getchar();
        if((r-'0'<0 || r-'0'>9) && r!='-' && !start)
        {
            continue;
        }
        if((r-'0'<0 || r-'0'>9) && r!='-' && start)
        {
            break;
        }
        if(start)ret*=10;
        start=true;
        if(r=='-')neg=true;
        else ret+=r-'0';
    }

    if(neg)
        ret*=-1;
    return ;
}

template<class T> inline void asdasd(T x,char y)
{
    // 0- print+newline, 1 - print ' ',2 - nothing;
    if (x < 0)
    {
        putchar('-');
        x = -x;
    }
    char buf[21], *p = buf;
    do
    {
        *p++ = '0' + x % 10;
        x /= 10;
    }
    while (x);
    do
    {
        putchar(*--p);
    }
    while (p > buf);
    if(y==0)putchar('\n');
    else if(y==1)putchar(' ');
}
#define filein(x) freopen(x,"r",stdin)
#define fileout(x) freopen(#x".txt","w",stdout)
#define fst first
#define snd second
//istringstream(temp) >> data >> value >> stamp;
//mod1 = 1000000007, mod2 = 1000000009;
//.016-.040-.900-2.48
/***************************************************************************************************************************************/
#define PLI pair<long long,int>
long long arr[10009];
long long Mod=1000000007;
vector<PLI>P[65];
long long inf=1000000000;
void precal()
{
    for(long long int i=1; i<=1000000; i++)
    {
        long long v=i*i*i;
        for(int j=3; j<=60; j++)
        {
            P[j].PB(MP(v,i));
            if(v<=inf/i)v=v*i;
            else break;
        }
    }
}

int solve(long long base,int p)
{
    int low=0,high=P[p].size()-1;
    int mid,ret=low;
    while(low<high)
    {
        mid=(low+high)>>1;
        if(P[p][mid].fst<base)low=mid+1;
        else
        {
            high=mid;
        }

    }
    for(int i=min((int)P[p].size()-1,high+5); i>=max(0,high-5); i--)if(P[p][i].first<=base)return P[p][i].second;
    return 1;
}
int main()
{
    //freopen("inp.txt","r",stdin);
    //freopen("stdout.txt","w",stdout);
    inf*=inf;
    precal();
    int kase;
    asd(kase);
    int N,Q;
    long long x,base;
    while(kase--)
    {
        asd(N);
        asd(Q);
        fill(arr,0);
        REP(i,N)
        {
            asd(arr[i+1]);
        }
        long long res=0;
        long long tmp,xtra=0;
        for(int i=60; i<=N; i++)
        {
            xtra+=arr[i];
            if(xtra>=Mod)xtra-=Mod;
        }
        REP(q,Q)
        {
            res=0;
            asd(base);
            res+=(base%Mod * arr[1]);
            if(res>=Mod)res-=Mod;
            if(N>=2)
            {
                long long sq=sqrt(base);
                res += (sq * arr[2]);
                if(res>=Mod)res-=Mod;
                for(int i=3; i<=N && i<60; i++)
                {
                    tmp=solve(base,i);
                    res += tmp*arr[i];
                    if(res>=Mod)res-=Mod;
                }
                res+=xtra;
            }
            if(res>=Mod)res-=Mod;
            res = (res %Mod + Mod)%Mod;
            //while(res<0)res+=Mod;
            if(q<Q-1)asdasd(res,1);
            else asdasd(res,0);
        }
    }
    return 0;
}














