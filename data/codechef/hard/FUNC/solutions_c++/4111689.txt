#include<cstdio>
#include<vector>
#include<map>
 
#define MOD 1000000007
 
#define RNG 1000000000000000000ULL
#define ROOT2 1000000000000ULL
 
#define ROOT2L 1000000
#define ROOT2U 1000000000
#define ROOT3 31623446801367ULL
#define ROOT3L 31623
#define ROOT3U 1000000
#define ROOT4 251423010792976ULL
#define ROOT4L 3982
#define ROOT4U 31622
#define ROOT2L1 99999
#define ROOT3L1 31622
#define ROOT4L1 3981
 
 
 
using namespace std;
 
 
 
//map<int,int> posit;
vector<vector <unsigned long long int> > predata;
map<unsigned long long,int> m2;
vector<map <unsigned long long,int> > ranges(58,m2);
 
 
int sqr(unsigned long long int q,int low,int high,int index)
{
	int mid=(low+high)/2,i;
	unsigned long long int val=1;
	for(i=0;i<index;i++)
		val=val*mid;	
	if(val<q)
	{
		if(mid==high)
			return mid;
		val=1;
		for(i=0;i<index;i++)
			val=val*(mid+1);
 
		if(val>q)
		{
			return mid;
		}
		if(val==q)
			return mid+1;	
		return sqr(q,mid+1,high,index);
	}
	else if(val>q)
	{
		if(mid==low)
			return mid-1;
		val=1;
		for(i=0;i<index;i++)
			val=val*(mid-1);
		if(val<=q)
			return mid-1;
		return sqr(q,low,mid-1,index);
	}
	return mid;
			
}
 
 
 
int search(unsigned long long int q,int index)
{
 
	map<unsigned long long int,int>::iterator m1=ranges[index-2].lower_bound(q);
	unsigned long long i;
	i=m1->first;
	if(i==q)	
	{
		return m1->second;
	}
	
	else if(m1!=ranges[index-2].begin())
	{
		m1--;
	//			printf("yo:\t%d\t%d\n",index,m1->second);
 
		return m1->second;
	}
	
		return 1;		
/*	int mid=(low+high)/2;
	if(predata[mid][index-1]>q)
	{
		if(mid==low)
			return mid+1;
		else if(predata[mid-1][index-1]<=q)
			return mid+1;
		else
			return search(q,index,low,mid-1);
	}
	else if(predata[mid][index-1]<q)
	{
		if(mid==high || predata[mid+1][index-1]>q)
			return mid+2;
		else if(predata[mid+1][index-1]==q)
			return mid+3;
		else 
			return search(q,index,mid+1,high);			
	}
	else
		return mid+2;
*/
}
 
int calculate(unsigned long long int q,int k)
{
	//int size;
	if(k==2)
	{
		if(q>=ROOT2)
			return sqr(q,ROOT2L,ROOT2U,k);
		return sqr(q,0,ROOT2L1,k);
				
	}
	else if(k==3)
	{
		if(q>=ROOT3)
			return sqr(q,ROOT3L,ROOT3U,k);
		return sqr(q,0,ROOT3L1,k);
	}
	else if(k==4)
	{
		if(q>=ROOT4)
			return sqr(q,ROOT4L,ROOT4U,k);
		return sqr(q,0,ROOT4L1,k);
	}
 
	else
	{
		return search (q,k);
	}
}
 
int main()
{
vector<unsigned long long int> subdata;
int size[ROOT4L1];
int i,l,T,N,Q,no,limit;
vector<int> data;
unsigned long long int total[15000],no1;
unsigned long long int j=RNG,temp,sum,q;
vector<unsigned long long int> queries;
//char s=' ';
 
 
for(i=2;i<=ROOT4L1;i++)
{
	subdata.push_back(i);
//	ranges[0][i]=i;
	temp=RNG/i;
	l=0;
	while(true)
	{
		j=subdata[l]*i;
		ranges[l++][j]=i;		
		subdata.push_back(j);
		if(j>temp)
			break;
	}
	size[i-2]=subdata.size();
	predata.push_back(subdata);
	subdata.clear();
}
limit=size[0];
/*for(i=0;i<limit;i++)
{
	printf("%lld\n",ranges[i].begin()->first);	
}*/
 
//printf("%d\n",limit);
scanf("%d",&T);
while(T-->0)
{
	for(i=0;i<15000;i++)
		total[i]=0;
	scanf("%d%d",&N,&Q);
	for(i=0;i<N;i++)
	{
		scanf("%d",&no);
		if(no<0)
			no=no+MOD;
		data.push_back(no);
	}
	for(i=0;i<Q;i++)
	{
		scanf("%lld",&q);
		queries.push_back(q);
	}
 
	for(i=2;i<=limit;i++)
	{
		if(i>N)
			break;
		q=data[i-1];
		for(int k=0;k<Q;k++)
		{
			sum=q*calculate(queries[k],i)%MOD;
			total[k]=(total[k]+sum)%MOD;				
		}
	}
	sum=0;
 
	if(i<=N)
		i--;
 
	for(int k=i;k<N;k++)
		sum=(data[k]+sum)%MOD;				
	no1=data[0];
	for(i=0;i<Q;i++)
	{
		q=(no1*(queries[i]%MOD))%MOD;
		total[i]=(total[i]+sum+q)%MOD;				
	}	
 
//	printf("%lld",total[0]);
//	for(int i=0;i<1000000000;i++);
 
	for(i=0;i<Q;i++)
		printf("%lld ",total[i]);
	printf("\n");
//	for(int i=0;i<1000000000;i++);
	
	queries.clear();
	data.clear();
 
/*scanf("%lld %d",&q,&no);
printf("%d\n",calculate(q,no));
*/
}
}	
