#include <iostream>
#include <stack>
#include <cassert>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <cstdlib>
#include <vector>
#include <algorithm>
#include <queue>
#include <set>
#include <map>
#include <ctime>
#include <sstream>
#define bkt_size 320
#define lli long long
#define M 1000000007
#define MAX 100005

using namespace std;

int A[MAX];
int vis[MAX];
int B[322][MAX];
int lastpos[322][MAX];
int nxt[MAX];
int prv[MAX];
int pos[MAX];

//Code for FAST INPUT :)
template <typename T>
inline void fi(T *a)
{
    register char c=0;
    while (c<33) c=getchar_unlocked();
    *a=0;
    int tmp = 0;
    while (c>33)
    {
        if ( c == 45 ) tmp = 1;
        else *a=*a*10+c-'0';
        c=getchar_unlocked();
    }
    if ( tmp == 1 ) *a = 0-(*a);
}

int main()
{
    int n,m,q,x,y;
    fi(&n), fi(&m), fi(&q);

    for ( int i = 0; i < n; i++ ) fi(&A[i]);

    for ( int i = 0; i < n; i += bkt_size ) {
        int mx = 0;
        for ( int j = i; j < n; j++ ) {
            if ( vis[A[j]] != i+1 ) vis[A[j]] = i+1, pos[A[j]] = j;
            else mx = max(mx,j - pos[A[j]]);
            B[i/bkt_size][j] = mx;
        }
    }

    memset(pos, -1, sizeof(pos));

    for ( int i = n-1; i >= 0; i-- ) {
        nxt[i] = pos[A[i]];
        if ( nxt[i] == -1 ) nxt[i] = n;
        pos[A[i]] = i;
    }

    memset(pos, -1, sizeof(pos));

    for ( int i = 0; i < n; i++ ) {
        prv[i] = pos[A[i]];
        pos[A[i]] = i;
    }

    memset(lastpos, -1, sizeof(lastpos));

    for ( int i = 0; i < n; i++ ) lastpos[i/bkt_size][A[i]] = i;

    int bkts = n/bkt_size + 1;
    for ( int i = 1; i < bkts; i++ ) {
        for ( int j = 1; j <= m; j++ ) {
            if ( lastpos[i][j] == -1 ) lastpos[i][j] = lastpos[i-1][j];
        }
    }

    while ( q-- ) {
        fi(&x), fi(&y);
        x--, y--;
        int ans;
        if ( x/bkt_size == y/bkt_size ) {
            ans = 0;
            for ( int i = x; i <= y; i++ ) {
                 if ( vis[A[i]] == 2*n + q ) ans = max(ans, i - pos[A[i]]);
                 else vis[A[i]] = 2*n + q, pos[A[i]] = i;
            }
        }
        else {
            ans = 0;
            int e_x = x/bkt_size * bkt_size;
            if ( x%bkt_size != 0 ) e_x += bkt_size;
            int e_y = y;
            if ( y%bkt_size != bkt_size-1 ) e_y = y/bkt_size * bkt_size - 1;
            ans = max(ans, B[e_x/bkt_size][y]);
            for ( int i = x; i < e_x; i++ ) {
                if ( prv[i] >= x ) continue;
                int idx = lastpos[e_y/bkt_size][A[i]];
                while ( idx <= y ) {
                    ans = max(ans, idx-i);
                    idx = nxt[idx];
                }
            }
        }
        printf("%d\n", ans);
    }
    return 0;
}
