#define _USE_MATH_DEFINES
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <vector>
#include <math.h>
#include <string.h>
#include <queue>
#include <algorithm>
#include <assert.h>
#include <stack>
#include <stdio.h>
#include <string>
#include <set>
#include <assert.h>
#include <deque>
#include <map>
#include <time.h>
typedef long long li;

using namespace std;
const int N = 1e5 + 4;
const long long INF = 1e18;
#define x first
#define y second
typedef pair<int, int> pnt;
#define mp make_pair

int a[N];
int len;
int n, m, k;

struct seg {
	int l, r, idx;
	seg(int l, int r, int idx) :
		l(l), r(r), idx(idx) {};
	seg() :
		l(0), r(0), idx(0) {};
};

seg zapr[N];
int answer[N];


inline bool cmp(const seg &a, const seg &b) {
	if ((a.l / len) == (b.l / len)) {
		return a.r < b.r;
	}
	return a.l < b.l;
}

int rg[N];
int lg[N];

int nxt[N];
int last[N];
int sz[N];

int cnt[N];
int sum[N];

int main()
{
#ifdef _DEBUG
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);
#endif
	scanf("%d%d%d", &n, &m, &k);
	len = sqrt(n + 0.0) + 1.0;
	for (int i = 0; i < n; i++) {
		scanf("%d", &a[i]);
	}
	for (int i = 0; i < k; i++) {
		int l, r;
		scanf("%d%d", &l, &r);
		l--;
		r--;
		zapr[i] = seg(l, r, i);
	}
	sort(zapr, zapr + k, cmp);
	int L = 0;
	int R = 0;
	memset(lg, -1, sizeof lg);
	memset(rg, -1, sizeof rg);
	rg[a[0]] = 0;
	lg[a[0]] = 0;
	sz[a[0]]++;
	cnt[0]++;
	sum[0]++;

	for (int i = 0; i < k; i++) { 
		while (R < zapr[i].r) {
			R++;
			if (sz[a[R]] > 0) {
				cnt[rg[a[R]] - lg[a[R]]]--;
				sum[(rg[a[R]] - lg[a[R]]) / len]--;
			}
			last[R] = rg[a[R]];
			nxt[rg[a[R]]] = R;
			rg[a[R]] = R;
			if (sz[a[R]] == 0) lg[a[R]] = rg[a[R]];

			sz[a[R]]++;
			cnt[rg[a[R]] - lg[a[R]]]++;
			sum[(rg[a[R]] - lg[a[R]]) / len]++;
		}
		while (L > zapr[i].l) {
			L--;
			if (sz[a[L]] > 0) {
				cnt[rg[a[L]] - lg[a[L]]]--;
				sum[(rg[a[L]] - lg[a[L]]) / len]--;
			}
			nxt[L] = lg[a[L]];
			last[lg[a[L]]] = L;
			lg[a[L]] = L;
			if (sz[a[L]] == 0) rg[a[L]] = lg[a[L]];

			sz[a[L]]++;
			cnt[rg[a[L]] - lg[a[L]]]++;
			sum[(rg[a[L]] - lg[a[L]]) / len]++;
		}
		while (L < zapr[i].l) {
			cnt[rg[a[L]] - lg[a[L]]]--;
			sum[(rg[a[L]] - lg[a[L]]) / len]--;
			lg[a[L]] = nxt[lg[a[L]]];
			sz[a[L]]--;

			if (sz[a[L]] > 0) {
				cnt[rg[a[L]] - lg[a[L]]]++;
				sum[(rg[a[L]] - lg[a[L]]) / len]++;
			}
			L++;
		}
		while (R > zapr[i].r) {
			cnt[rg[a[R]] - lg[a[R]]]--;
			sum[(rg[a[R]] - lg[a[R]]) / len]--;
			rg[a[R]] = last[rg[a[R]]];
			sz[a[R]]--;

			if (sz[a[R]] > 0) {
				cnt[rg[a[R]] - lg[a[R]]]++;
				sum[(rg[a[R]] - lg[a[R]]) / len]++;
			}
			R--;
		}
		for (int j = len; j >= 0; j--) {
			if (sum[j] > 0) {
				for (int qwa = (j + 1) * len; qwa >= j * len; qwa--) {
					if (cnt[qwa] > 0) {
						answer[zapr[i].idx] = qwa;
						break;
					}
				}
				break;
			}
		}
	}
	for (int i = 0; i < k; i++)
		printf("%d\n", answer[i]);
	return 0;
}
////www.codechef.com/problems/QCHEF/