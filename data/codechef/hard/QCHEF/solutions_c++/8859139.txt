#include<bits/stdc++.h>
using namespace std;
#define sd(x) scanf("%d",&x);
#define pb push_back
#define debug(x) cout << "[DEBUG] " << #x << " = " << x << "\n"

typedef pair<int,int> PII;
typedef vector<int> VI;

#define N 100010
#define RN 400

int arr[N];
VI vec[N];
VI heavy;
bool is_heavy[N];
pair<PII,int> qr[N];

int ans[N],fst[N],nxt[N],lst[N];

struct node
{
    int l,r,val;
}st[6*N];


void initialize(int left,int right,int i)
{
    st[i].l=left;
    st[i].r=right;
    st[i].val=0;

    if(left<right)
    {
        int mid = (left+right)/2;
        initialize(left,mid,2*i);
        initialize(mid+1,right,2*i+1);
    }
}

void update(int x,int v,int i)  // update index x with value v
{
    if(st[i].l>x || st[i].r<x)
        return;
    if(st[i].l==st[i].r)
        st[i].val=v;
    else{
        update(x,v,2*i);
        update(x,v,2*i+1);
        st[i].val=max(st[2*i].val,st[2*i+1].val); //segment tree to get maximum in a range
    }
}

int query(int left,int right,int i)
{
    if(right<st[i].l || st[i].r<left)
        return 0;
    if(left<=st[i].l && st[i].r<=right)
        return st[i].val;
    else{
        return max(query(left,right,2*i),query(left,right,2*i+1));
    }
}


int main()
{
int n,m,k,i,j;
sd(n);
sd(m);
sd(k);

initialize(1,n,1);   //root of the tree is 1

for(i=1;i<=n;i++)
{
    sd(arr[i]);
    vec[arr[i]].pb(i);
}

for(i=1;i<=n;i++)
    vec[arr[i]].pb(n+1);

for(i=1;i<=m;i++)
{
    if(vec[i].size()>RN)
    {
        heavy.pb(i);
        is_heavy[i]=true;
    }
}

for(i=n;i>=1;i--)            //next equal element
{
    if(lst[arr[i]]!=0)
        nxt[i]=lst[arr[i]];
    lst[arr[i]]=i;
}

for(i=1;i<=n;i++)
{
    if(fst[arr[i]]==0)
        fst[arr[i]]=i;
    else if(is_heavy[arr[i]]==false)
    {
        update(i,i-fst[arr[i]],1);
    }
}


for(i=0;i<k;i++)
{
    sd(qr[i].first.first);
    sd(qr[i].first.second);
    qr[i].second=i;
}

sort(qr,qr+k);     //Offline processing of queries

int id=1,l,r,x;

for(i=0;i<k;i++)
{
    while(id<qr[i].first.first)
    {
        if(is_heavy[arr[id]]==false)
        {
            for(j=1;j<vec[arr[id]].size();j++)
            {
                if(vec[arr[id]][j]>=id)
                {
                    update(vec[arr[id]][j],vec[arr[id]][j]-nxt[id],1);
                }
            }
        }
      id++;
    }

    ans[qr[i].second]=query(qr[i].first.first,qr[i].first.second,1);

    for(j=0;j<heavy.size();j++)
    {
        x=heavy[j];
        r=upper_bound(vec[x].begin(),vec[x].end(),qr[i].first.second)-vec[x].begin()-1;
        l=lower_bound(vec[x].begin(),vec[x].end(),qr[i].first.first)-vec[x].begin();
        ans[qr[i].second]=max(ans[qr[i].second],vec[x][r]-vec[x][l]);
    }

}

for(i=0;i<k;i++)
    printf("%d\n",ans[i]);

return 0;


}
