#include<iostream>
#include<queue>

using namespace std;

class State{
	int a,b;
public:
	State(int a,int b){
		this->a=a;
		this->b=b;
	}
	int getA(){
		return a;
	}
	int getB(){
		return b;
	}
};

class PouringWater{
	int A,B,C;
	int *fullA,*emptyA,*fullB,*emptyB;
public:
	PouringWater(int A,int B,int C){
		this->A=A;
	 	this->B=B;
		this->C=C;

	 	fullA=new int[B+1];
	 	emptyA=new int[B+1];
	 	fullB=new int[A+1];
	 	emptyB=new int[A+1];


	 	for(int i=0;i<=B;i++){
	 		fullA[i]=0;
	 		emptyA[i]=0;
	 	}
	 	for(int i=0;i<=A;i++){
	 		fullB[i]=0;
	 		emptyB[i]=0;
	 	}
	}

	int getMinSteps(){
		int count=0;
		queue<State*> q;
		State *start = new State(0,0);

		q.push(start);
		visit(0,0,1);

		while(!q.empty()){
			State *s = q.front();
			q.pop();

			int m = s->getA();
			int n = s->getB();

			int t= getSteps(m,n);


			if(isDesiredState(m,n)){
				count= t;

				break;
			}

			if(!isVisited(m,0)){

				visit(m,0,t+1);
				q.push(new State(m,0));
			}
			if(!isVisited(0,n)){

				visit(0,n,t+1);
				q.push(new State(0,n));
			}
			if(!isVisited(m,B)){

				visit(m,B,t+1);
				q.push(new State(m,B));
			}
			if(!isVisited(A,n)){

				visit(A,n,t+1);
				q.push(new State(A,n));
			}

			if(m+n>A){
				if(!isVisited(A,n-(A-m))){

					visit(A,n-(A-m),t+1);
					q.push(new State(A,n-(A-m)));
				}
			}
			else{
				if(!isVisited(m+n,0)){

					visit(m+n,0,t+1);
					q.push(new State(m+n,0));		
				}
			}
			
			if(m+n>B){
				if(!isVisited(m-(B-n),B)){

					visit(m-(B-n),B,t+1);
					q.push(new State(m-(B-n),B));
				}
			}
			else{
				if(!isVisited(0,m+n)){

					visit(0,m+n,t+1);
					q.push(new State(0,m+n));		
				}
			}
						
		}
		return count;

	}

	void visit(int m,int n,int steps){
		if(m==A){
			fullA[n]=steps;
		}
		if(m==0){
			emptyA[n]=steps;
		}
		if(n==B){
			fullB[m]=steps;
		}
		if(n==0){
			emptyB[m]=steps;
		}
		return;
	}

	bool isVisited(int m,int n){

		if(m==A){
			if(fullA[n]!=0){
				return true;
			}
		}
		if(m==0){
			if(emptyA[n]!=0){
				return true;
			}
		}
		if(n==B){
			if(fullB[m]!=0){
				return true;
			}
		}
		if(n==0){
			if(emptyB[m]!=0){
				return true;
			}			
		}

		return false;
	}

	int getSteps(int m,int n){
		if(m==A){
			return fullA[n];
		}
		if(m==0){
			return emptyA[n];
		}
		if(n==B){
			return fullB[m];
		}
		if(n==0){
			return emptyB[m];
		}
		return 0;
	}


	bool isDesiredState(int m,int n){
		if((m==C)||(n==C)){
			return true;
		}
		else
			return false;
	}

};

int main(){
	int t=0,a=0,b=0,c=0;
	cin>>t;
	while(t>0){
			cin>>a>>b>>c;
			PouringWater *pw = new PouringWater(a,b,c);
			cout<< pw->getMinSteps()-1<<endl;
			t--;
	}

	return 0;
}