#include<stdio.h>
#include<iostream>
using namespace std;
#include<algorithm>
#define mod 1000000007
#include<map>
#include<list>

#define gc getchar_unlocked
#define pc(x) putchar_unlocked(x)

inline void scanll(long long *x)
{
    register char c = gc();
    *x = 0;
    for(;(c<48 || c>57);c = gc());
    for(;c>47 && c<58;c = gc()) {*x = (*x<<1) + (*x<<3) + c - 48;}
}
 
inline void write(long long n)
{
    register long long N = n, rev, count = 0;
    rev = N;
    if (N == 0) { pc('0'); pc('\n'); return ;}
    while ((rev % 10) == 0) { ++count; rev /= 10;} //obtain the count of the number of 0s
    rev = 0;
    while (N != 0) { rev = (rev<<3) + (rev<<1) + N % 10; N /= 10;}  //store reverse of N in rev
    while (rev != 0) { pc(rev % 10 + '0'); rev /= 10;}
    while (count--) pc('0');
}

struct edges
{
	long long layer1,vertex1,layer2,vertex2;
};

bool comparator(pair<long long,long long>a,pair<long long,long long>b)
{
	if(a.first<b.first)
	return 1;
	
	if(a.first>b.first)
	return 0;
	
	if(a.second<b.second)
	return 1;
	
	return 0;
}

long long power(long long a,long long b)
{
	if(b==0)
	return 1;
	
	if(b==1)
	return a;
	
	long long var=power(a,b/2);
	
	if(b%2==0)
	return (var*var)%mod;
	
	return ((var*var)%mod*a)%mod;
}

int main()
{
	long long n,m,k,i,j,l,size;
	
	//scanf("%lld%lld%lld",&n,&m,&k);
	scanll(&n);
	scanll(&m);
	scanll(&k);
	
	edges E[k];
	
	pair<long long,long long>distinct[2*k];
	
	long long index=-1;
	map<pair<long long,long long>,long long>distmp;
	
	for(i=0;i<k;i++)
	{
	 //scanf("%lld%lld%lld%lld",&E[i].layer1,&E[i].vertex1,&E[i].layer2,&E[i].vertex2);
     scanll(&E[i].layer1);   
     scanll(&E[i].vertex1);
     scanll(&E[i].layer2);
     scanll(&E[i].vertex2);
    }
	
	map<pair<long long,long long>,list<pair<long long,long long> > >mp;
	
	pair<long long,long long>a,b;
	
	for(i=0;i<k;i++)
	{
	  a.first=E[i].layer2;
	  a.second=E[i].vertex2;
	 
	  b.first=E[i].layer1;
	  b.second=E[i].vertex1;
	  
	  mp[a].push_back(b);
    }
	
	for(i=0;i<k;i++)
	{
	  a.first=E[i].layer2;
	  a.second=E[i].vertex2;
	 
	  b.first=E[i].layer1;
	  b.second=E[i].vertex1;
	  
	  if((distmp.count(a)==0)&&(a.first!=0))
	  distinct[++index]=a;
	  distmp[a]=1;
	  
	  if((distmp.count(b)==0)&&(b.first!=0))
	  distinct[++index]=b;
	  distmp[b]=1;
	}
	
	sort(distinct,distinct+index+1,comparator);
	
	map<long long,long long>sumlayer;
	
    map<long long,long long>::iterator it;

    map<pair<long long,long long>,long long>ways;
    
    sumlayer[0]=1; 
	a.first=0;
	a.second=0;
	ways[a]=1;
	
	for(i=0;i<=index;i++)
	{
		a.first=distinct[i].first;
		a.second=distinct[i].second;
		
		size=mp[a].size();
		for(l=0;l<size;l++)
		 {
			b=mp[a].front();
			mp[a].pop_front();
			
			ways[a]=(ways[a]+ways[b])%mod;
		 }
		 
		 sumlayer[a.first]=(sumlayer[a.first]+ways[a])%mod;
		 
		 it=sumlayer.end();
		 it--;
		 it--;
		 
		 ways[a]=(ways[a]+(sumlayer[it->first]*power(m,(a.first-it->first-1)))%mod)%mod;
		 
		 if((i==0)||((i>0)&&(distinct[i].first!=distinct[i-1].first)))
		 {
		  if(a.first!=(n+1))
		  sumlayer[a.first]=(sumlayer[a.first]+(sumlayer[it->first]*power(m,(a.first-it->first)))%mod)%mod;
	      
		  else
		  sumlayer[a.first]=(sumlayer[a.first]+(sumlayer[it->first]*power(m,(a.first-it->first-1)))%mod)%mod;
	     }
	} 
	
	it=sumlayer.end();
	it--;
	
	if(it->first!=(n+1))
	sumlayer[n+1]=(sumlayer[n+1]+(sumlayer[it->first]*power(m,n+1-it->first-1))%mod)%mod;
	
	//cout<<sumlayer[n+1];
	write(sumlayer[n+1]);
	return 0;
}