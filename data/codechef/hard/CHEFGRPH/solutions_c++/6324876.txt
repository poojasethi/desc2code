#include<bits/stdc++.h>
#define ll long long
#define N 1000000007
using namespace std;
ll n,m;
struct point
{
	ll x;
	ll y;
};
vector<point>given,extras;
vector<ll>points;
vector<ll>layers;
vector<ll>pointsum;
vector<ll>layersum;
bool cmp(point p1,point p2)
{
	if(p1.x<p2.x) return true;
	if(p1.x>p2.x) return false;
	return p1.y<p2.y;
}
ll find(ll x1,ll x2)
{
	ll lo=0,hi=extras.size()-1,mid;
	while(lo<=hi)
	{
		mid=(lo+hi)/2;
		if(mid==0 && extras[mid].x==x1) return 0;
		if(extras[mid].x==x1 && extras[mid-1].x<x1)
		{
			return mid;
		}
		else if(extras[mid].x<x1)
		{
			lo=mid+1;
		}
		else if(extras[mid].x>x1)
		{
			hi=mid-1;
		}
		else
		{
			hi=mid-1;
		}
	}
}
ll power(ll a,ll b)
{
	ll t=1;
	while(b>0)
	{
		if(b&1)
		{
			t=(t*a)%N;
		}
		a=(a*a)%N;
		b>>=1;
	}
	return t;
}
ll find(ll p1)
{
	ll lo=0,hi=layers.size()-1,mid;
	while(lo<=hi)
	{
		mid=(lo+hi)/2;
		if(mid==layers.size()-1  && layers[mid]>=p1) return mid;
		if(layers[mid]>=p1 && layers[mid+1]<p1) return mid;
		if(layers[mid]<p1) hi=mid-1;
		if(layers[mid]>=p1) lo=mid+1;
	}
}
ll find2(ll p1)
{
	ll lo=0,hi=points.size()-1,mid;
	while(lo<=hi)
	{
		mid=(lo+hi)/2;
		if(points[mid]==p1) return mid;
		if(points[mid]<p1) hi=mid-1;
		else lo=mid+1;
	}
}
int main()
{
	ll k,l1,l2,p1,p2,pos,pos2,x1,x2,x3,i,val,x4,cnt=0;
	scanf("%lld %lld %lld",&n,&m,&k);
	point p4,p5,p3;
	for(i=0;i<k;i++)
	{
		scanf("%lld %lld %lld %lld",&l1,&p1,&l2,&p2);
		if(l1==0)
		{
			p4.x=0;
		}
		else
		{
			p4.x=(l1-1)*m+p1+1;
		}
		p3.x=p4.x;
		p4.y=1;
		if(l2==n+1)
		{
			p5.x=m*n+1;
		}
		else
		{
			p5.x=(l2-1)*m+p2+1;
		}
		p5.y=0;
		p3.y=p5.x;
		given.push_back(p4);
		given.push_back(p5);
		extras.push_back(p3);
	}
	sort(given.begin(),given.end(),cmp);
	sort(extras.begin(),extras.end(),cmp);
	layers.push_back(n+1);
	layersum.push_back(1);
	layers.push_back(n);
	layersum.push_back(1);
	ll pl=given.size();
	for(i=pl-1;i>=0;i--)
	{
		if(given[i].x==0)
		{
			x1=0;
			x2=0;
		}
		else
		{
			x1=(given[i].x-1)/m+1;
			x2=(given[i].x-1)%m;
		}
		if(points.size()!=0 && points[points.size()-1]==given[i].x)
		{
			cnt++;
		}
		else
		{
			cnt=0;
		}
		if(given[i].y==0)
		{
			if(points.size()!=0 && points[points.size()-1]==given[i].x)
			{
				continue;
			}
			pos=find(x1);
			if(layers[pos]==x1)
			{
				points.push_back(given[i].x);
				pointsum.push_back(layersum[pos]);
			}
			else
			{
				l1=layers[pos]-x1;
				val=power(m,l1);
				val=(val*layersum[pos])%N;
				layers.push_back(x1);
				layersum.push_back(val);
				points.push_back(given[i].x);
				pointsum.push_back(val);
			}
		}
		else
		{
			pos=find(x1);
			pos2=points.size()-1;
			if(layers[pos]==x1)
			{
				val=layersum[pos];
			}
			else
			{
				l1=layers[pos]-x1;
				val=power(m,l1);
				val=(val*layersum[pos])%N;
			}
			l1=find(given[i].x,x2);
			l1+=cnt;
			p1=extras[l1].y;
			x3=p1/m+1;
			x4=p1%m;
			p2=find2(p1);
			if(pos2!=-1 && points[pos2]==given[i].x)
			{
				pointsum[pos2]=(pointsum[pos2]+pointsum[p2])%N;
			}
			else
			{
				points.push_back(given[i].x);
				pointsum.push_back((val+pointsum[p2])%N);
			}
			if(layers[pos]!=x1)
			{
				layers.push_back(x1);
				layersum.push_back(val);
			}
			if(x1!=0)
			{
				pos2=find(x1-1);
				if(layers[pos2]==x1-1)
				{
					layersum[pos2]=(layersum[pos2]+pointsum[p2])%N;
				}
				else
				{
					layers.push_back(x1-1);
					val=(val*m)%N;
					layersum.push_back((val+pointsum[p2])%N);
				}
			}
		}
	}
	pos=layers.size()-1;
	if(points.size()!=0 && points[points.size()-1]==0)
	{
		printf("%lld\n",pointsum[points.size()-1]);
	}
	else if(pos!=-1 && (layers[pos]==0))
	{
		printf("%lld\n",layersum[pos]);
	}
	else
	{
		l1=layers[pos];
		val=power(m,l1);
		val=(val*layersum[pos])%N;
		printf("%lld\n",val);
	}
	return 0;
}