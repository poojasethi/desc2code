#include <bits/stdc++.h>
#define gc getchar_unlocked
#define fo(i,n) for(i=0;i<n;i++)
#define Fo(i,k,n) for(i=k;i<n;i++)
#define lli long long int
#define pii pair<int,int>
#define vi vector<int>
#define pb push_back
#define mp make_pair
 //676671058
using namespace std;
const lli mod = 1000000007;
void sd(int &x)
{
    register int c = gc();
    x = 0;
    for(;(c<48 || c>57);c = gc());
    for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}
}
void sd(lli &x)
{
    register int c = gc();
    x = 0;
    for(;(c<48 || c>57);c = gc());
    for(;c>47 && c<58;c = gc()) {x = (x<<1) + (x<<3) + c - 48;}
}
lli modPow(lli a, lli b) {   
    if(b<=0)
        return 1;
    lli x = 1,y=a;
    while(b>0){
        if(b&1) x = (x*y)%mod;
        y = (y*y)%mod;
        b=b/2;
    }
    return x;
}
struct node
{
	lli l1;
	int v1;
	lli l2;
	int v2;
	lli rl1,rl2,rl1v1,diff,extra;
	void read()
	{
		scanf("%lld %d %lld %d",&l1,&v1,&l2,&v2);
	}
 
};
node edge[50005];
bool comp(node a, node b)
{
	if(a.l2!=b.l2)
	return a.l2<b.l2;
	return a.v2<b.v2;
}
lli f(lli x)
{
	if(x<0)
		return 0;
	return x;
}
lli get(lli i , lli l)
{
	//0 to i-1 mei index dhundo st a[index]<=l & index is as max as possible
	lli s,e,mid;
	s=0;
	e=i-1;
	while(s<e)
	{
		mid=(s+e)/2;
		if(edge[mid].l2>l)
			e=mid-1;
		else
			s=mid+1;
	}
	if(edge[s].l2<=l)
	return s;
	return s-1;
 
 
}
void display(node x)
{
	cout<<"From ("<<x.l1<<" , "<<x.v1<<") -> ("<<x.l2<<" , "<<x.v2<<")"<<endl;
	cout<<"rl1 : "<<x.rl1<<endl;
	cout<<"rl1v1 : "<<x.rl1v1<<endl;
	cout<<"rl2 : "<<x.rl2<<endl;
 
	cout<<"diff : "<<x.diff<<endl;
	cout<<"extra : "<<x.extra<<endl;
	
}
int main()
{
	int i;
	lli n,m,res;
	int k;
	scanf("%lld %lld %d",&n,&m,&k);
	
 	if(k==0)
 	{
 		res = modPow(m,n);
 		printf("%lld\n",res);
 		return 0;
 	
 	}
	
	fo(i,k)
	{
		edge[i].read();
	}
	sort(edge,edge+k,comp);
	
	edge[0].rl2 = modPow(m,edge[0].l2-1);
	edge[0].rl1 = modPow(m,edge[0].l1-1);
	edge[0].rl1v1 = edge[0].rl1;
	edge[0].extra=edge[0].rl1v1;
	edge[0].diff = edge[0].rl1v1;
	lli tem;
	node x;
	Fo(i,1,k)
	{
		
		lli index = get(i,edge[i].l1);
		
		if( index == -1 )
		{
		//	printf("yaha %d \n",i);
			edge[i].rl1 = modPow(m,edge[i].l1-1);
			edge[i].rl1v1 = edge[i].rl1;
		}
		else
		{
		  //  cout<<"#"<<i<<endl;
			x=edge[index];
			edge[i].rl1 = modPow(m,edge[i].l1-x.l2-1);
			tem = (x.rl2*m)%mod;
			tem = (tem+ x.diff)%mod;
			edge[i].rl1 = (edge[i].rl1*tem)%mod;
			if(x.l2 == edge[i].l1)
				edge[i].rl1 = x.rl2;
			edge[i].rl1v1=edge[i].rl1;
			lli raw = index;
		
			while(edge[i].l1==edge[index].l2)
			{
				//printf("KKKK %d %d \n", i , edge[index].v2);
				if(edge[i].v1==edge[index].v2){
				edge[i].rl1v1= (edge[i].rl1v1+edge[index].extra)%mod;
				break;
				}
				index--;
				if(index<0) break;
				
				
			}
		
		}
		
		//For end point of edge
		
		x=edge[i-1];
		edge[i].rl2 = modPow(m,edge[i].l2-x.l2-1);
		tem = (x.rl2*m)%mod;
		tem = (tem+ x.diff)%mod;
		edge[i].rl2 = (edge[i].rl2*tem)%mod;
		if(x.l2==edge[i].l2)
			edge[i].rl2 = x.rl2;
		
		
		
		edge[i].diff = edge[i].rl1v1;
		if(edge[i-1].l2==edge[i].l2)
			edge[i].diff = (edge[i].diff+edge[i-1].diff)%mod;
			
		
		edge[i].extra = edge[i].rl1v1;
		if(edge[i-1].l2==edge[i].l2 && edge[i-1].v2==edge[i].v2)
		{
			edge[i].extra = (edge[i].extra+edge[i-1].extra)%mod;
		}
		
		
	
	
	
	}
	
//	fo(i,k)
//	{
//	    printf("#%d ",i);
//		display(edge[i]);
//		printf("\n###############\n ");
		
//	}
	
	
	node final = edge[k-1];
	res = modPow(m,n-final.l2);
	tem=(m*(final.rl2))%mod;
	tem=(tem+final.diff)%mod;
	res = (tem*res)%mod;
	if(final.l2==n+1)
	res = (final.rl2 + final.diff)%mod;
	
	printf("%lld\n",res);
	return 0;
}  