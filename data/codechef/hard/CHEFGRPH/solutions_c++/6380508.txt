#include <algorithm>
#include <iostream>
#include <stdio.h>
#include <vector>
#include <map>
#define MOD 1000000007
using namespace std;
 
typedef long long int LL;
typedef pair< LL, int > Pr;
 
LL powe(int a, LL n) {
	if (n==0) return 1;
	if (n==1) return a;
 
	LL tmp = powe(a, n>>1);
	tmp = (tmp*tmp)%MOD;
 
	if (n&1) 
		tmp = (tmp*a)%MOD;
	return tmp;
}
 
map< pair<LL, int >, LL > sp_v;
map< LL, LL > last_change;
map< int, LL > other_nodes_vals;
 
int m;
vector< pair< Pr, Pr> > edges, special_edges;
 
LL get_layer_val(LL n) {
	if (last_change.find(n) != last_change.end()) {
		return last_change[n];
	}
	map< LL, LL >::iterator it = last_change.upper_bound(n);
	//cout << it->first << "**" << n << endl;
	return (1LL * it->second * powe (m, it->first - n))%MOD;
}
 
LL get_per_node_val(LL n) {
	if (other_nodes_vals.find(n) != other_nodes_vals.end()) {
		return other_nodes_vals[n];
	}
	map< LL, LL >::iterator it = last_change.upper_bound(n);
	//cout << it->first << "**" << n << endl;
	LL tmp = (1LL * it->second * powe (m, it->first - n))%MOD;
	return (tmp * powe (m, MOD-2))%MOD;
}
 
int main() {
	LL n;
	int k;
	cin >> n >> m >> k;
	last_change[n+1] = 1;
	LL n1, n2;
	int m1, m2;
	while (k--) {
		scanf("%lld%d%lld%d", &n1, &m1, &n2, &m2);
		if (n1!=0)
			edges.push_back(make_pair(make_pair(n1, m1), make_pair(n2, m2)));
		else
			special_edges.push_back(make_pair(make_pair(n1, m1), make_pair(n2, m2)));
	}
	stable_sort(edges.begin(), edges.end());
 
	for (int i = edges.size()-1; i >= 0; --i) {
		LL no_of_ways_from_end;
		if (sp_v.find(edges[i].second) != sp_v.end()) {
			no_of_ways_from_end = sp_v[edges[i].second];
		} else if ( edges[i].second.first == n+1) {
			no_of_ways_from_end = 1;
		} else {
			no_of_ways_from_end = get_per_node_val(edges[i].second.first);
		}
 
		LL no_of_ways_from_current_layer = get_layer_val(edges[i].first.first);
		LL per_node_val = get_per_node_val(edges[i].first.first);
 
		other_nodes_vals[edges[i].first.first] = per_node_val;
		if (sp_v.find(edges[i].first) != sp_v.end())
			sp_v[edges[i].first] += no_of_ways_from_end;
		else 
			sp_v[edges[i].first] = no_of_ways_from_end + per_node_val;
		no_of_ways_from_current_layer = (no_of_ways_from_current_layer + no_of_ways_from_end)%MOD;
		last_change[edges[i].first.first] = no_of_ways_from_current_layer; 
	}
	LL ans = get_layer_val(1);
	for (int i=0; i<special_edges.size(); ++i) {
		LL no_of_ways_from_end;
		if (sp_v.find(special_edges[i].second) != sp_v.end()) {
			no_of_ways_from_end = sp_v[special_edges[i].second];
		} else if ( special_edges[i].second.first == n+1) {
			no_of_ways_from_end = 1;
		} else {
			no_of_ways_from_end = get_per_node_val(special_edges[i].second.first);
		}
		ans = (ans + no_of_ways_from_end)%MOD;
	}
	cout << ans << endl;
	return 0;
}  