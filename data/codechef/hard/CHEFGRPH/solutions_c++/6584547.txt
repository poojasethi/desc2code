#include<iostream>
#include<vector>
#include<algorithm>
#include<string>
#include<map>
#include<set>
#include<queue>
#include<list>
#include<cstdio>
#include<cstdlib>
#include<ctime>
#include<cstring>
#include<cmath>
#include<cassert>

using namespace std;

#define mod 1000000007
#define X first
#define Y second
#define pb push_back
#define mp make_pair
#define tr(container,it) for(typeof(container.begin()) it=container.begin();it!=container.end();it++)
#define all(c) c.begin(),c.end()
#define MAXN 1000010

typedef long long LL;
typedef unsigned long long ULL;
typedef long double LD;
typedef vector<int> vi;
typedef pair<int,int> pii;

LL n;
int m,k;

int power(int base,LL exp){
	int ans=1;
	if(exp>0){
		while(exp){
			if(exp%2) ans=(LL)ans*base%mod;
			base=(LL)base*base%mod;
			exp/=2;
		}
	}
	if(ans<0) ans+=mod;
	return ans;
}

pair< LL,pii > P[MAXN];
int pos[MAXN];
map< pair<LL,int>,int > M;

bool sortBy(int a,int b){
	return P[a]<P[b];
}

int main(){
	cin.sync_with_stdio(0);
	cin.tie();
	cin>>n>>m>>k;
	k*=2;
	int p=0;
	for(int i=0;i<k;i++){
		cin>>P[i].X>>P[i].Y.X;
		pos[i]=i;
		P[i].Y.Y = 1-(i&1);

	}
	sort(pos,pos+k,sortBy);
    LL prev=0;
	int prevSum=1;
	for(int i=0;i<k;){
		int curSum=(LL)prevSum*power(m,P[pos[i]].X-prev-1)%mod;
		//cout<<prev<<" "<<prevSum<<" "<<pos[i]<<" "<<curSum<<endl;
		int j,totSum=0;
		map< pair<LL,int>,int > M1;
		for(j=i;j<k && P[pos[j]].X==P[pos[i]].X;j++){
			if(!M1[mp(P[pos[j]].X,P[pos[j]].Y.X)])
				M1[mp(P[pos[j]].X,P[pos[j]].Y.X)]=curSum;
			if(P[pos[j]].Y.Y==0){
				int val=M[mp(P[pos[j]-1].X,P[pos[j]-1].Y.X)];
				M1[mp(P[pos[j]].X,P[pos[j]].Y.X)]=(M1[mp(P[pos[j]].X,P[pos[j]].Y.X)]+val)%mod;
				totSum=(totSum+val)%mod;
			}
		}
		tr(M1,it) {
		    M[it->X]=it->Y;
		}
		if(P[pos[i]].X==0){
			i=j;
			continue;
		}
		prevSum=(totSum+(LL)curSum*m%mod)%mod;
		prev=P[pos[i]].X;
		i=j;
	}
	if(prev!=n+1){
		int sum=(LL)prevSum*power(m,n-prev)%mod;
		cout<<sum<<"\n";
	}
	else
	    cout<<M[mp(n+1,0)]<<"\n";
	return 0;
}
