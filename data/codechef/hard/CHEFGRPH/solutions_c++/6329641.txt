/****** BISMILLAHIR RAHMANIR RAHIM ******/

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef unsigned int ul;
typedef unsigned long long ull;
typedef vector <int> vi;
typedef map<string,string> mss;
typedef map<int, vector<int> > mvii;
typedef map<int, int> mii;
typedef queue <int> qi;
typedef map <int, vector<string> > mvis;
typedef map <string, vector<int> > mvsi;
typedef vector <string> vs;
typedef pair <int, int> pii;

#define MP make_pair
#define SORT(a) sort (a.begin(), a.end())
#define REVERSE(a) reverse (a.begin(), a.end())
#define PI acos(-1)
#define ms(x,y) memset (x, y, sizeof (x))
#define INF 2000000000
#define pb push_back
#define MAX 100002
#define debug cout<<"A"<<endl
#define prnt(a) cout<<a<<endl
#define mod 1000000007LL
#define FOR(i,a,b) for (int i=(a); i<(b); i++)
#define FORr(i,a,b) for (int i=(a); i>=b; i--)
#define itrALL(c,itr) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)

/* Direction Array */

// int fx[]={1,-1,0,0};
// int fy[]={0,0,1,-1};
// int fx[]={0,0,1,-1,-1,1,-1,1};
// int fy[]={-1,1,0,0,1,1,-1,-1};

template <class T> inline T bigmod(T p,T e,T M)
{
    ll ret = 1;
    for(; e > 0; e >>= 1)
    {
        if(e & 1) ret = (ret * p) % M;
        p = (p * p) % M;
    } return (T)ret;
}

template <class T> inline T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}
template <class T> inline T modinverse(T a,T M){return bigmod(a,M-2,M);}
template <class T> inline T lcm(T a,T b) {a=abs(a);b=abs(b); return (a/gcd(a,b))*b;}
template <class T, class X> inline bool getbit(T a, X i) { T t=1; return ((a&(t<<i))>0);}
template <class T, class X> inline T setbit(T a, X i) { T t=1;return (a|(t<<i)); }
template <class T, class X> inline T resetbit(T a, X i) { T t=1;return (a&(~(t<<i)));}

inline ll power(ll a, ll b)
{
	ll multiply=1;
	FOR(i,0,b)
	{
		multiply=(multiply*a)%mod;
	}
	return multiply%mod;
}

/****** END OF HEADER ******/

ll n, a, x;
int m, k, b, y;
vector<pair<ll,ll> > allPoints;
map<pair<ll,ll>, int> endPoints;
vector< pair<ll,ll> > from[100005];
map<ll,ll> waysLayer;
map<pair<ll,ll>, ll> waysVertex;
map<pair<ll,ll>,bool> done;	

pair<ll,ll> p1, p2;

int main()
{
	// ios_base::sync_with_stdio(0);
	// freopen("in.txt","r",stdin);

	scanf("%lld%d%d", &n, &m, &k);

	int how=0;
	FOR(i,0,k)
	{
		scanf("%lld%d%lld%d", &a, &b, &x, &y);
		p1=MP(a,b); p2=MP(x,y);
		if(done.find(p1)==done.end())
		{
			allPoints.pb(p1);
			done[p1]=true;
		}
		if(done.find(p2)==done.end())
		{
			allPoints.pb(p2);
			done[p2]=true;
		}
		if(endPoints.find(p2)==endPoints.end())
		{
			endPoints[p2]=how;
			how++;
		}
		from[endPoints[p2]].pb(p1);
	}

	// FOR(i,0,endPoints.size())
	// 	cout<<endPoints[i].first<<" "<<endPoints[i].second<<endl;

	// if(done.find(MP(0LL,0LL))==done.end())
	// 	allPoints.pb(MP(0LL,0LL));
	p1=MP(n+1,0LL);

	if(done.find(p1)==done.end())
		allPoints.pb(p1);

	SORT(allPoints);

	// FOR(i,0,allPoints.size())
	// 	cout<<allPoints[i].first<<" "<<allPoints[i].second<<endl;

	ll curLayer=0;
	waysLayer[0]=1;
	waysVertex[MP(0,0)]=1;

	for(int i=0; i<allPoints.size();)
	{
		ll X=allPoints[i].first;
		if(X==0)
		{
			i++;
			continue;
		}

		if(X-1>curLayer)
		{
			waysLayer[X-1]=(waysLayer[curLayer]*bigmod((ll)m,X-1-curLayer,mod)%mod)%mod;
			curLayer=X-1;
		}

		// cout<<curLayer<<" "<<X<<" "<<waysLayer[X-1]<<endl;

		int cnt=0;

		while(allPoints[i].first==X)
		{
			cnt++;
			waysVertex[allPoints[i]]=waysLayer[X-1];
			// debug;
			// cout<<allPoints[i].first<<" "<<allPoints[i].second<<endl;
			if(endPoints.find(allPoints[i])!=endPoints.end())
			{
				// debug;
				int idx=endPoints[allPoints[i]];
				for(int j=0; j<from[idx].size(); j++)
				{
					waysVertex[allPoints[i]]=(waysVertex[allPoints[i]]+waysVertex[from[idx][j]])%mod;
					// debug;
				}
			}

			waysLayer[X]=(waysLayer[X]+waysVertex[allPoints[i]])%mod;
			i++;
		}

		waysLayer[X]=(waysLayer[X]+((m-cnt)*(waysLayer[X-1]))%mod)%mod;
		curLayer=X;
	}

	// cout<<waysVertex[MP(n+1,0LL)]<<endl;
	printf("%lld\n", waysVertex[p1]);

	return 0;
}



