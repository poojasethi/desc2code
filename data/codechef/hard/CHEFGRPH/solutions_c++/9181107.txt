#include<stdio.h>
#include<iostream>
using namespace std;
#include<algorithm>
#define mod 1000000007
#include<map>
#include<list>

struct edges
{
	long long layer1,vertex1,layer2,vertex2;
};

bool comparator(pair<long long,long long>a,pair<long long,long long>b)
{
	if(a.first<b.first)
	return 1;
	
	if(a.first>b.first)
	return 0;
	
	if(a.second<b.second)
	return 1;
	
	return 0;
}

long long power(long long a,long long b)
{
	if(b==0)
	return 1;
	
	if(b==1)
	return a;
	
	long long var=power(a,b/2);
	
	if(b%2==0)
	return (var*var)%mod;
	
	return ((var*var)%mod*a)%mod;
}

int main()
{
	long long n,m,k,i,j,l,size;
	
	scanf("%lld%lld%lld",&n,&m,&k);
	
	edges E[k];
	
	pair<long long,long long>distinct[2*k];
	
	long long index=-1;
	map<pair<long long,long long>,long long>distmp;
	
	for(i=0;i<k;i++)
	scanf("%lld%lld%lld%lld",&E[i].layer1,&E[i].vertex1,&E[i].layer2,&E[i].vertex2);
	
	map<pair<long long,long long>,list<pair<long long,long long> > >mp;
	
	pair<long long,long long>a,b;
	
	for(i=0;i<k;i++)
	{
	  a.first=E[i].layer2;
	  a.second=E[i].vertex2;
	 
	  b.first=E[i].layer1;
	  b.second=E[i].vertex1;
	  
	  mp[a].push_back(b);
    }
	
	for(i=0;i<k;i++)
	{
	  a.first=E[i].layer2;
	  a.second=E[i].vertex2;
	 
	  b.first=E[i].layer1;
	  b.second=E[i].vertex1;
	  
	  if((distmp.count(a)==0)&&(a.first!=0))
	  distinct[++index]=a;
	  distmp[a]=1;
	  
	  if((distmp.count(b)==0)&&(b.first!=0))
	  distinct[++index]=b;
	  distmp[b]=1;
	}
	
	sort(distinct,distinct+index+1,comparator);
	
	map<long long,long long>sumlayer;
	
    map<long long,long long>::iterator it;

    map<pair<long long,long long>,long long>ways;
    
    sumlayer[0]=1; 
	a.first=0;
	a.second=0;
	ways[a]=1;
	
	for(i=0;i<=index;i++)
	{
		a.first=distinct[i].first;
		a.second=distinct[i].second;
		
		size=mp[a].size();
		for(l=0;l<size;l++)
		 {
			b=mp[a].front();
			mp[a].pop_front();
			
			ways[a]=(ways[a]+ways[b])%mod;
		 }
		 
		 sumlayer[a.first]=(sumlayer[a.first]+ways[a])%mod;
		 
		 it=sumlayer.end();
		 it--;
		 it--;
		 
		 ways[a]=(ways[a]+(sumlayer[it->first]*power(m,(a.first-it->first-1)))%mod)%mod;
		 
		 if((i==0)||((i>0)&&(distinct[i].first!=distinct[i-1].first)))
		 {
		  if(a.first!=(n+1))
		  sumlayer[a.first]=(sumlayer[a.first]+(sumlayer[it->first]*power(m,(a.first-it->first)))%mod)%mod;
	      
		  else
		  sumlayer[a.first]=(sumlayer[a.first]+(sumlayer[it->first]*power(m,(a.first-it->first-1)))%mod)%mod;
	     }
	} 
	
	it=sumlayer.end();
	it--;
	
	if(it->first!=(n+1))
	sumlayer[n+1]=(sumlayer[n+1]+(sumlayer[it->first]*power(m,n+1-it->first-1))%mod)%mod;
	
	cout<<sumlayer[n+1];
	return 0;
}