#include <iostream>
#include <string>
#include <string.h>
#include <cstdlib>
#include <set>
#include <map>
#include <vector>
#include <algorithm>
#include <iomanip>
#include <sstream>
#include <memory.h>
#include <stdio.h>
#include <ctime>
#include <queue>
#include <cmath>
#include <cassert>

using namespace std;
 
#define LL long long
#define U unsigned
#define pnt pair<int,int>
#define FOR(i,a,b) for (int i=(a); i<(b); ++i)
#define MEMS(a,b) memset((a),(b),sizeof(a))
#define MIN(a,b) ((a)<(b)?(a):(b))
#define MAX(a,b) ((a)>(b)?(a):(b))
#define ABS(a) (((a)>=(0))?(a):(-(a)))
#define mp make_pair
#define pb push
#define ALL(a) a.begin(),a.end()
#define FI(i,b) FOR(i,0,b)
#define V(t) vector < t >
#define sz size()
#define MOD 1000000007LL

int T, N, S;
const int threshold = 100007;
set<int> bigPrimes;
int num[20006];

priority_queue<int>  occ[threshold];

LL bigMod(LL a, LL b, LL c)
{
   LL x, y;
   x = a;
   y = 1;
   
   while (b)
   {
       if (b & 1)
           y = (y * x) % c;
           
       b = b / 2;
       x = (x * x) % c;      
   }             
   
   return y;
}

int main()
{      
    scanf("%d", &T);
    while (T--)
    {
        bigPrimes.clear();
        scanf("%d", &N);
        for (int i=1 ; i<=N ; i++)
            scanf("%d", &num[i]);
            
        for (int i=1 ; i<=N ; i++)
        {
            int v = num[i];
            for (int p=2 ; p*p<=v ; p++)
            {
                if (v%p!=0)
                    continue;
                int count = 0;
                while (v%p == 0)
                {
                    count++;
                    v = v/p;      
                }  
                occ[p].pb(count);  
            }    
            
            // v is bigger prime
            if (v > 1)
            {
                if (v < threshold)
                    occ[v].pb(1);  
                else
                {
                    if (bigPrimes.find(v) == bigPrimes.end())  bigPrimes.insert(v);
                    else  bigPrimes.erase(v);    
                }    
            }
        }   
    
        LL ans = 1;
        for (set<int>::iterator itr = bigPrimes.begin() ; itr != bigPrimes.end() ; itr++)
            ans = (ans * (*itr)) % MOD;
            
        for(int i=2 ; i<threshold ; i++)
        {
            if(occ[i].size()==0) continue;

            while(occ[i].size() > 0)
            {
                if(occ[i].size() == 1)
                {
                    ans=(ans*(bigMod(i,occ[i].top(), MOD)))%MOD;
                    occ[i].pop();
                }
                else if(occ[i].size() == 2){
                    int tp1=occ[i].top();
                    occ[i].pop();

                    int tp2=occ[i].top();
                    occ[i].pop();

                    occ[i].push(tp1-tp2);
                }
                else{
                    int tp1 = occ[i].top();
                    occ[i].pop();

                    int tp2 = occ[i].top();
                    occ[i].pop();

                    int tp3 = occ[i].top();

                    tp1 -= (tp2-tp3+1);
                    tp2 -= (tp2-tp3+1);

                    if(tp1 > 0) occ[i].push(tp1);
                    if(tp2 > 0) occ[i].push(tp2);
                }
            }
        }
        printf("%lld\n",ans);
    }     
    return 0;    
}
