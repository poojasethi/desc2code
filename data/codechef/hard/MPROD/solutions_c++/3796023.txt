#include <cstdio>
#include <algorithm>
#include <vector>
#include <cassert>
#include <iostream>

using namespace std;

#define NMAX 20010
#define MOD 1000000007

vector<int> primes;
vector<int> occ;
vector<int> max_occ;

int comp[10010];

int A[NMAX];
int N;

void seive(){
	int i,n,j;

	n = 10002;

	comp[0] = comp[1] = 1;
	for(i = 2; i*i <= n; ++i){
		if(comp[i]) continue;
		for(j = i*i; j <= n; j+=i){
			comp[j] = 1;
		}
	}

	for(i = 0; i <= n; ++i){
		if(comp[i]) continue;
		primes.push_back(i);
		occ.push_back(0);
		max_occ.push_back(0);
	}
}



int init(){
	int i,k,oc;

	long long sol = 1;
	vector<int> left;

	for(i = 0; i < primes.size(); ++i) occ[i] = max_occ[i] = 0;

	sol = 1;

	for(k = 0; k < N; ++k){
		i = 0;
		while(A[k] > 1 && i < (int)primes.size()){

			oc = 0;
			while(! (A[k]%primes[i]) ){
				A[k] /= primes[i];
				++oc;
			}

			occ[i] += oc;
			max_occ[i] = max(max_occ[i],oc);
			++i;
		}

		if(A[k] > 1) left.push_back(A[k]);
	}


	for(i = 0; i < primes.size(); ++i){
		if(!occ[i]) continue;
		if(occ[i]%2 == 0 && max_occ[i]*2 <= occ[i]) continue;
		if(occ[i]%2) oc = 1;
		else oc = (max_occ[i]*2)-occ[i];

		while(oc--){
			sol*= (long long)primes[i];
			sol%=MOD;
		}

	}

	sort(left.begin(),left.end());


	for(i = 0; i < left.size(); ++i){
		if(i+1 < left.size() && left[i] == left[i+1]){
			++i;
			continue;
		}
		sol *= (long long)left[i];
		sol %= MOD;
	}

	return sol;
}



int main(){
	int i,t;

	seive();

	scanf("%d",&t);

	while(t--){
		scanf("%d",&N);

		for(i = 0; i < N; ++i){
			scanf("%d",&A[i]);
		}

		printf("%d\n",init());
	}

	return 0;
}
