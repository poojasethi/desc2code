#include <bits/stdc++.h>
using namespace std;

#define ll long long int
#define ull unsigned long long int
#define uint unsigned int

typedef pair<int,int> pii;
#define x first
#define y second

#define read(n) scanf("%d",&n)
#define readll(n) scanf("%lld",&n)
#define read2(n,m) scanf("%d%d",&n,&m)
#define read3(n,m,l) scanf("%d%d%d",&n,&m,&l)

#define fr(i,n)     for(int i=0;i<n;i++)
#define frr(i,a,b)   for(int i=a;i<b;i++)
#define rf(i,n)     for(int i=n-1;i>=0;i--)

#define init(mem,v) memset(mem,v,sizeof(mem))

#define DB(x)              cout<<__LINE__<<" :: "<<#x<< ": "<<x<<endl;
#define DB2(x, y)          cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<endl;
#define DB3(x, y, z)       cout<<__LINE__<<" :: "<<#x<< ": "<<x<<" | "<<#y<< ": "<<y<<" | "<<#z<<": "<<z<<endl;
#define DB4(a, b, c, d)    cout<<__LINE__<<" :: "<<#a<< ": "<<a<<" | "<<#b<< ": "<<b<<" | "<<#c<<": "<<c<<" | "<<#d<<": "<<d<<endl;

#define mod 1000000007

ll ppow(ll b,int p){
    ll rem=1;
    while(p){
        if(p%2==0){
            p/=2;
            b=(b*b)%mod;
        }
        else{
            p--;
            rem=(rem*b)%mod;
        }
    }
    return rem;
}

const int mx=1000001;
const int threshold=100000;
int arr[mx];

priority_queue<int> occurance_count[threshold]; // smaller primes, occurance_count[i] holds powers of the number threshold (only for prime values of threshold)

set<int> big_facs;  // prime occurances for primes larger than threshold
// big primes can occur atmost once at each index, hence just counting wheather even or odd would suffice

int main(){
    int t;
    read(t);
    while(t--){
        big_facs.clear();

        int n;
        read(n);
        fr(i,n) read(arr[i]);

        fr(j,n){
            int v=arr[j];
            for(int i=2;i*i<=v;i++){
                if(v%i==0){
                    int cnt=0;
                    while(v%i==0){
                        cnt++;
                        v/=i;
                    }
                    occurance_count[i].push(cnt);
                }
            }
            if(v>1){
                if(v<threshold){
                    occurance_count[v].push(1);
                }
                else{
                    if(big_facs.find(v)==big_facs.end()) big_facs.insert(v);
                    else big_facs.erase(v);
                }
            }
        }

        ll ans=1;
        for(set<int>::iterator itr = big_facs.begin();itr!=big_facs.end();itr++){
            ans=(ans*(*itr))%mod;
        }

        for(int i=2;i<threshold;i++){
            if(occurance_count[i].size()==0) continue;

            while(occurance_count[i].size() > 0){
                if(occurance_count[i].size() == 1){
                    ans=(ans*(ppow(i,occurance_count[i].top())))%mod;
                    occurance_count[i].pop();
                }
                else if(occurance_count[i].size() == 2){
                    int tp1=occurance_count[i].top();
                    occurance_count[i].pop();

                    int tp2=occurance_count[i].top();
                    occurance_count[i].pop();

                    occurance_count[i].push(tp1-tp2);
                }
                else{
                    int tp1=occurance_count[i].top();
                    occurance_count[i].pop();

                    int tp2=occurance_count[i].top();
                    occurance_count[i].pop();

                    int tp3=occurance_count[i].top();

                    tp1 = tp1-1;
                    tp2 = tp2-1;

                    if(tp1 > 0) occurance_count[i].push(tp1);
                    if(tp2 > 0) occurance_count[i].push(tp2);
                }
            }
        }
        printf("%lld\n",ans);
    }
}
