// Artur Kraska, II UWr

#include <algorithm>
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <vector>
#include <cmath>
#include <list>
#include <set>
#include <map>

#define forr(i, n)                  for(int i=0; i<n; i++)
#define FOREACH(iter, coll)         for(typeof(coll.begin()) iter = coll.begin(); iter != coll.end(); ++iter)
#define FOREACHR(iter, coll)        for(typeof(coll.rbegin()) iter = coll.rbegin(); iter != coll.rend(); ++iter)
#define lbound(P,R,PRED)            ({typeof(P) X=P,RRR=(R), PPP = P; while(PPP<RRR) {X = (PPP+(RRR-PPP)/2); if(PRED) RRR = X; else PPP = X+1;} PPP;})
#define testy()                     int _tests; scanf("%d", &_tests); FOR(_test, 1, _tests)
#define CLEAR(tab)                  memset(tab, 0, sizeof(tab))
#define CONTAIN(el, coll)           (coll.find(el) != coll.end())
#define FOR(i, a, b)                for(int i=a; i<=b; i++)
#define FORD(i, a, b)               for(int i=a; i>=b; i--)
#define MP                          make_pair
#define PB                          push_back

#define M 1000000007
#define INF 1000000007

using namespace std;

int n, tab[1000007], p[1000007], ilep;

struct str
{
    int maks;
    int ile;
};
map <int, str> mapa;

void sito()
{
    p[0] = 2;
    ilep = 1;

    for(int i=3; i<=100000; i++)
    {
        bool b = 1;
        for(int j=0; p[j]*p[j] <= i; j++)
            if(i % p[j] == 0)
            {
                b = 0;
                break;
            }

        if(b)
        {
            p[ilep++] = i;
            //cout << i << endl;
        }
    }
}

int main()
{
    sito();

    testy()
    {
        scanf("%d", &n);
        mapa.clear();
        forr(i, n)
        {
            scanf("%d", &tab[i]);

            for(int j=0; p[j]*p[j] <= tab[i]; j++)
            {
                int il = 0;
                while(tab[i]%p[j] == 0)
                {
                    il++;
                    tab[i] /= p[j];
                }
                if(il > 0)
                {
                    str elem = mapa[p[j]];
                    elem.maks = max(elem.maks, il);
                    elem.ile += il;
                    mapa[p[j]] = elem;
                }
            }

            if(tab[i] > 1)
            {
                str elem = mapa[tab[i]];
                elem.maks = max(elem.maks, 1);
                elem.ile++;
                mapa[tab[i]] = elem;
            }
        }

        long long res = 1;
        FOREACH(it, mapa)
        {
            int nr = it->first;
            str elem = it->second;

            if(2*elem.maks > elem.ile)
                forr(i, 2*elem.maks - elem.ile)
                    res = (res*nr)%M;
            else
                if(elem.ile&1)
                    res = (res*nr)%M;
        }

        printf("%d\n", res);
    }
	return 0;
}
