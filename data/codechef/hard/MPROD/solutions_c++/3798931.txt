#include <vector>
#include <cstring>
#include <string>
#include <algorithm>
#include <iostream>
#include <cmath>
#include <map>
#include <cstdio>
#include <cassert>
#include <queue>

using namespace std;

#define FOR(i, a, b) for(int i = a; i < b; i++)
#define REP(i, n) FOR(i, 0, n)
#define ll long long
#define mp make_pair
#define pb push_back

#define MAX 10005
#define N 20005
#define mod 1000000007ll

int n;
ll a[N];
bool primes[MAX];
int sp[10005],tp, cnt[N];

void gen_primes()
{
    for(int i=2;i<MAX;i++) primes[i] = 1;
    int x = sqrt(MAX);
    for(int i = 2; i <= x; i++)
        if (primes[i])
            for(int j = i; j*i < MAX; j++) primes[i*j] = 0;
    for(int i=2; i <= 10000; i++) if(primes[i])
        sp[tp++] = i;
}

int main()
{
    tp = 0;
    gen_primes();
    int t; scanf("%d", &t);
    while(t--)
    {
        memset(cnt, 0, sizeof cnt);
        ll ans = 1;
        scanf("%d", &n);
        REP(i, n) scanf("%lld", a+i);
        REP(i, tp)
        {
            int p = sp[i];
            REP(j,n)
            {
                cnt[j] = 0;
                while(a[j] == p*(a[j]/p))
                {
                    a[j] /= p;
                    cnt[j]++;
                }
            }
            priority_queue<int> pq;
            REP(j, n) if(cnt[j] != 0) pq.push(cnt[j]);
            while(pq.size() >= 2)
            {
                int ti1 = pq.top()-1; pq.pop();
                int ti2 = pq.top()-1; pq.pop();
                if(ti1 > 0) pq.push(ti1);
                if(ti2 > 0) pq.push(ti2);
            }
            ll cur = pq.empty() ? 0 : pq.top();
            ll pcur = 1; REP(lol, cur) pcur = pcur*p;
            ans = (ans * pcur) % mod;
        }
        sort(a, a+n);
        bool parity = 0;
        REP(i, n)
        {
            parity ^= 1;
            if(i == n-1 or a[i] != a[i+1])
            {
                if(parity) ans = ans*a[i] % mod;
                parity = 0;
            }
        }
        printf("%lld\n", ans);
    }
    return 0;
}
