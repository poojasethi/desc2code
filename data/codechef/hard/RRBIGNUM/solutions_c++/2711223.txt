#include <bits/stdc++.h>

using namespace std;

typedef long long LL;

const int N = 1000005;

LL mod = (LL) ((1e9) + 7);

char s[N];
int n;
int bit[N];
LL power[N];

struct node
{
    int range;
    int set_bits;
    LL value;
    LL flipped_value;
    int flip;
/*
    node ()
    {

    }

/*
    node (int _range, int _set_bits, LL _value, LL _flipped_value, int _flip)
    {
        range = _range;
        set_bits = _set_bits;
        value = _value;
        flipped_value = _flipped_value;
        flip = _flip;
    }
*/

};

node tree[4 * N];

LL modpow (LL a, LL b, LL mod)
{
    assert (b >= 0);
    LL res = 1;

    while (b)
    {
        if (b & 1)
            res = (res * a) % mod;
        a = (a * a) % mod;

        b >>= 1;
    }

    return res;
}

node merge (node &a, node &b)
{
    node it;

    it.range = a.range + b.range;
    it.set_bits = a.set_bits + b.set_bits;
    it.value = (a.value + b.value) % mod;
    it.flipped_value = (a.flipped_value + b.flipped_value) % mod;
    it.flip = 0;

    return it;
}

void buildTree (int k, int lo, int hi)
{
    if (lo == hi)
    {
        node it;

        it.flip = 0;
        it.range = 1;
        it.set_bits = bit[lo];
        it.value = power[n - lo] * it.set_bits;
        it.flipped_value = power[n - lo] * (it.set_bits ^ 1);

        tree[k] = it;
    }
    else
    {
        int mid = (lo + hi) >> 1;

        buildTree ((k << 1), lo, mid);
        buildTree ((k << 1) + 1, mid + 1, hi);

        tree[k] = merge (tree[k << 1], tree[(k << 1) + 1]);
    }
}

void update_subtree (node &a)
{
    a.set_bits = a.range - a.set_bits;
    swap (a.value, a.flipped_value);
    a.flip ^= 1;
}

/*
void split (int k)
{
    node &a = tree[k];

    if (a.flip)
    {
        flip_node (tree[2 * k]);
        flip_node (tree[2 * k + 1]);
        a.flip = 0;
    }
}
*/

void clear_it (int k)
{
    if (!tree[k].flip)
        return;

    update_subtree (tree[k << 1]);
    update_subtree (tree[(k << 1) + 1]);

    tree[k].flip = 0;
}

void update (int k, int lo, int hi, int left, int right)
{
    if (lo == left && hi == right)
    {
        update_subtree (tree[k]);
    }
    else
    {
        clear_it(k);

        int mid = (lo + hi) >> 1;

        if (right <= mid)
            update (k << 1, lo, mid, left, right);
        else if (left > mid)
            update ((k << 1)+ 1, mid + 1, hi, left, right);
        else
        {
            update ((k << 1), lo, mid, left, mid);
            update ((k << 1) + 1, mid + 1, hi, mid + 1, right);
        }

        tree[k] = merge (tree[(k << 1)], tree[(k << 1) + 1]);
    }
}


LL query (int k, int lo, int hi)
{
    return tree[k].value;
}

void print (node it)
{
    cout << "Node";
    cout << it.range << " " << it.set_bits << " " << it.value << " " << it.flipped_value << " " << it.flip << endl;
    cout << endl;
}

int main()
{
    //freopen ("input.txt", "r", stdin);

    power[0] = 1;
    for (LL i = 1; i <= N; i++)
    {
        power[i] = (power[i - 1] * 2) % mod;
    }

    LL inv = modpow (2, mod  - 2, mod);
    //cout << "here" << endl;
    scanf ("%s", s);
    n = strlen (s);

    for (int i = 1; i <= n; i++)
        bit[i] = s[i - 1] - '0';

    //cout << "building" << endl;
    buildTree (1, 1, n);

/*
    for (int i = 1; i <= 10; i++)
        print (tree[i]);
*/
    int q;
    scanf ("%d", &q);

    int lastBit = bit[n];

    for (int i = 0; i <= q; i++)
    {
        int L, R;
        if (i == 0)
        {
            L = 1, R = n;
        }
        else
        {
            scanf ("%d %d", &L, &R);
            update (1, 1, n, L, R);
            if (R == n)
            lastBit ^= 1;
        }

        LL res = query (1, 1, n);

        //cout << "res " << res << endl;

        LL ans = 0;
        if (lastBit == 1)
        {
            ans = (res + 1) % mod;
            ans = (ans * inv) % mod;
        }
        else
        {
            res = (res * inv) % mod;
            ans = (res + !(tree[1].set_bits & 1)) % mod;
        }

        //cout << ans << endl;
        printf ("%lld\n", ans);
    }

    return 0;
}
