/*
Codechef September Cook-off 2013
Big Number
*/

#include<cstdio>
#include<cstring>

const int MAXN=1000001;
const int MODULO=1000000007;

using namespace std;

int MOD(int num){
    if(num>=MODULO) num=num-MODULO;
    else if(num<0) num=MODULO+num;
    return num;
}

struct node{
    int bitSet, bitScan, placeSum, actualSum;
    bool flip;
    void merge(node& a, node& b){
        bitSet=a.bitSet+b.bitSet;
        bitScan=a.bitScan+b.bitScan;
        placeSum=MOD(a.placeSum+b.placeSum);
        actualSum=MOD(a.actualSum+b.actualSum);
        flip=0;
    }
    void invert(node &a){
            a.bitSet=MOD(a.bitScan-a.bitSet);
            a.actualSum=MOD(a.placeSum-a.actualSum);
            a.flip^=1;
    }
};

typedef struct node node;

node idt={0,0,0,0,0};

struct SegTree{
    node *T;
    int hgt, lftmst, rgtmst;
    SegTree(char *binary, int n){
        for(hgt=0; (1<<hgt)<n; hgt++);
        lftmst=(1<<hgt);
        rgtmst=lftmst<<1;
        T=new node[rgtmst];
        int base=1;
        T[0]=idt;
        for(int i=n-1; i>=0; i--){
            int val=binary[i]-'0';
            T[i+lftmst].bitSet=val;
            T[i+lftmst].bitScan=1;
            T[i+lftmst].placeSum=base;
            T[i+lftmst].actualSum=val*(T[i+lftmst].placeSum);
            T[i+lftmst].flip=0;
            base=MOD(base<<1);
        }
        for(int i=n+lftmst ; i<rgtmst; i++) T[i]=idt;
        for(int i=lftmst-1; i; i--) T[i].merge(T[(i<<1)], T[((i<<1)|1)]);
        return;
    }
    void update(int u, int i, int j, int p, int q){
        int mid=(i+j)>>1, lt=u<<1, rt=lt|1;
        //printf("In %d [%d %d] [%d %d]\n", u, i, j, p, q);
        //printf("In  %d [%d %d %d %d %d]\n", u, T[u].flip, T[u].bitSet, T[u].bitScan, T[u].actualSum, T[u].placeSum);
        if(T[u].flip){
            if(i!=j){
                T[u].invert(T[lt]);
                T[u].invert(T[rt]);
            }
            T[u].flip=0;
            //printf("In %d After lazy propogation [%d %d %d %d %d]\n", u, T[u].flip, T[u].bitSet, T[u].bitScan, T[u].actualSum, T[u].placeSum);
        }
        if(i>=p && j<=q){
            T[u].invert(T[u]);
             //printf("In %d After range is found [%d %d %d %d %d]\n", u, T[u].flip, T[u].bitSet, T[u].bitScan, T[u].actualSum, T[u].placeSum);
            return;
        }
        if(q<=mid) update(lt, i, mid, p, q);
        else if(p>mid) update(rt, mid+1, j, p, q);
        else{
            update(lt, i, mid, p, mid);
            update(rt, mid+1, j, mid+1, q);
        }
        T[u].merge(T[lt], T[rt]);
        //printf("In %d after merge [%d %d %d %d %d]\n", u, T[u].flip, T[u].bitSet, T[u].bitScan, T[u].actualSum, T[u].placeSum);
        return;
    }
    void checkOdd(int u){
        u>>=1;
        if(u>0) checkOdd(u);
        if(T[u].flip){
            T[u].invert(T[(u<<1)]);
            T[u].invert(T[((u<<1)|1)]);
            T[u].flip=0;
        }
    }
    node query(int u){
       checkOdd(u);
       return T[u];
    }
    /*node query(int u, int i, int j, int p, int q){
        node lret, rret, ret;
        int mid=(i+j)>>1, lt=u<<1, rt=lt|1;
        if(T[u].flip){
            if(i!=j){
                T[lt].invert(T[lt]);
                T[rt].invert(T[rt]);
            }
            T[u].flip=0;
        }
        if(i>=p && j<=q) return T[u];
        if(q<=mid) return query(lt, i, mid, p, q);
        else if(p>mid) return query(rt, mid+1, j, p, q);
        else{
            lret=query(lt, i, mid, p, mid);
            rret=query(rt, mid+1, j, mid+1, q);
            ret.merge(lret, rret);
        }
        return ret;
    }*/
    ~SegTree(){ if(T) delete[] T;}
};

int input(){
    int in=0;
    char c=getchar();
    while(c<48) c=getchar();
    while(c>47){
        in=(in<<3)+(in<<1)+c-'0';
        c=getchar();
    }
    return in;
}

int inputChar(char N[]){
    int i=0;
    char c=getchar();
    while(c<48) c=getchar();
    while(c>47) {N[i++]=c; c=getchar();}
    N[i]='\0';
    return i;
}

void output(int n){
    char out[11];
    out[10]='\n';
    int i=10;
    if(n==0) out[--i]='1';
    while(n){ out[--i]=n%10+'0', n/=10;}
    while(i<11){ putchar(out[i++]);}
}

int main()
{
    char N[MAXN];
    int length, M, L, R;
    node res;
    scanf("%s", &N);
    //memset(N, '0', 40);
    length=strlen(N);
    //length=40;
    M=input();
    SegTree tree(N, length);
    //int size=tree.rgtmst;
    //for(int i=1; i<size; i++)
    //printf("In %d after merge [%d %d %d %d %d]\n", i, tree.T[i].flip, tree.T[i].bitSet, tree.T[i].bitScan, tree.T[i].actualSum, tree.T[i].placeSum);
    res=tree.T[1];
    int inc=tree.query(length-1+tree.lftmst).bitSet?1: ((res.bitSet&1)?0:2);
    output(((long long int)(res.actualSum+inc)*((MODULO+1)/2))%MODULO);
    while(M--){
        L=input();
        R=input();
        tree.update(1, 0, tree.lftmst-1, L-1, R-1);
        res=tree.T[1];
        int inc=tree.query(length-1+tree.lftmst).bitSet?1: ((res.bitSet&1)?0:2);
        //printf("Inc %d\n", inc);
        //printf("%ld\n",((res.actualSum+inc)*(long long int)((MODULO+1)/2))%MODULO );
        output(((long long int)(res.actualSum+inc)*((MODULO+1)/2))%MODULO);
    }
}
