/*
 *Kartik Singal @ ka4ti
 */
#include<bits/stdc++.h>
using namespace std;
#define sll(n) scanf("%lld",&n);
#define s(n) scanf("%d",&n);
#define MAXN 1000001
#define mod 1000000007
#define ll long long
int inv2;
void gentests()
{
    ofstream file;
    file.open("in");
    int n=100;
    int N=n;
    while(n--)
    {
        file<<(rand()%2);
    }
    file<<endl;
    int q=10;
    file<<q<<endl;
    while(q--)
    {
        int l=(rand()%N)+1;
        int r=(rand()%N)+1;
        if(l>r) swap(l,r);
        file<<l<<" "<<r<<endl;

    }
    file.close();
}
long long modpow(long long n,long long p)
{
    long long ret=1;
    while(p)
    {
        if(p&1){
            ret=ret*n;
            if(ret>=mod) ret%=mod;
        }

        p=p/2;
        n*=n;
        if(n>=mod)
            n%=mod;
    }
    return ret;
}
typedef struct {
    int total_bits;
    int bitsset;
    int total_sum;
    int sum;
    int flip;
}node;
int N;
node tree[4*MAXN];
char str[MAXN];
void build(int node,int start,int end)
{
    if(start==end)
    {
        tree[node].total_bits=1;
        tree[node].bitsset=(str[start-1]=='1');
        tree[node].sum=tree[node].bitsset*modpow(2,N-start);
        tree[node].total_sum=modpow(2,N-start);
        tree[node].flip=0;
        return ;
    }

    int mid=(start+end)/2;
    int c=2*node;
    build(c,start,mid);
    build(c+1,mid+1,end);
    tree[node].total_bits=tree[c].total_bits+tree[c+1].total_bits;
    tree[node].bitsset=tree[c].bitsset+tree[c+1].bitsset;
    tree[node].sum=tree[c].sum+tree[c+1].sum;
    if(tree[node].sum>=mod) tree[node].sum%=mod;
    tree[node].total_sum=tree[c].total_sum+tree[c+1].total_sum;
    if(tree[node].total_sum>=mod) tree[node].total_sum%=mod;
    tree[node].flip=0;
}
void update(int node,int start,int end,int p,int q)
{
    if(tree[node].flip)
    {
        tree[node].bitsset=tree[node].total_bits-tree[node].bitsset;
        tree[node].sum=tree[node].total_sum-tree[node].sum;
        if(tree[node].sum<0) tree[node].sum+=mod;
        if(start!=end)
        {
            tree[2*node].flip=1-tree[2*node].flip;
            tree[2*node+1].flip=1-tree[2*node+1].flip;
        }
        tree[node].flip=0;

    }
    if(start>end||start>q||end<p)
        return ;

    if(p<=start&&q>=end)
    {
        tree[node].bitsset=tree[node].total_bits-tree[node].bitsset;
        tree[node].sum=tree[node].total_sum-tree[node].sum;
        if(tree[node].sum<0) tree[node].sum+=mod;
        if(start!=end)
        {
            tree[2*node].flip=1-tree[2*node].flip;
            tree[2*node+1].flip=1-tree[2*node+1].flip;
        }
        tree[node].flip=0;
        return;
    }
    int mid=(start+end)/2;

    update(2*node,start,mid,p,q);
    update(2*node+1,mid+1,end,p,q);

    int c=2*node;
    tree[node].bitsset=tree[c].bitsset+tree[c+1].bitsset;
    tree[node].sum=tree[c].sum+tree[c+1].sum;
    if(tree[node].sum>=mod) tree[node].sum%=mod;

}
int main()
{
    //gentests();
    //freopen("in","r",stdin);
    ///freopen("out","w",stdout);


    int even=1;
    inv2=modpow(2,mod-2);
    scanf("%s",str);
    N=strlen(str);
    if(str[N-1]=='1')
        even=0;

    build(1,1,N);

    ll ans;
    if(even)
    {
        //ans=(tree[1].sum)/2;
        ans=((long long)(tree[1].sum)*(long long)inv2);
        if(((tree[1].bitsset&1))==0)
            ans++;
        if(ans>=mod) ans%=mod;
    }
    else
    {
        ans=((long long)(tree[1].sum+1)*(long long)inv2);
        if(ans>=mod) ans%=mod;
    }
    printf("%lld\n",ans);
    int q;s(q);
    while(q--)
    {
        int l,r;
        s(l);s(r);
        update(1,1,N,l,r);
        if(r==N)
            even^=1;
        ll ans;
        if(even)
        {
            //ans=(tree[1].sum)/2;
            ans=((long long)(tree[1].sum)*(long long)inv2);
            if(((tree[1].bitsset&1))==0)
                ans++;
            if(ans>=mod) ans%=mod;
        }
        else
        {
            ans=((long long)(tree[1].sum+1)*(long long)inv2);
            if(ans>=mod) ans%=mod;
        }
        printf("%lld\n",ans);
    }

    return 0;
}

