// iostream is too mainstream
#include <cstdio>
// bitch please
#include <iostream>
#include <vector>
#include <set>
#include <map>
#include <string>
#include <queue>
#include <stack>
#include <algorithm>
#define dibs reserve
#define OVER9000 123456789012LL
#define tisic 47
#define soclose 10e-7
#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)
#define chocolate win
#define ff first
#define ss second
#define uint unsigned int
// mylittlepony
using namespace std;

vector<long long> Pow;
long long mod =1000000007;
	
struct node {
	int son[2];
	int z,k,ones,fl;
	long long sum;};

struct intervalac {
	// and again...
	vector<node> T;

	void constI(int akt) {
		node n =T[akt];
		if(n.z == n.k-1) return;
		for(int i =0; i < 2; i++) {
			if(i == 0) n.k =(n.z+n.k)/2;
			else {n.z =n.k; n.k =T[akt].k;}
			T[akt].son[i] =T.size();
			T.push_back(n);
			constI(T[akt].son[i]);}
		}

	intervalac(int N) {
		node n;
		n.z =n.ones =n.sum =n.fl =0, n.k =N;
		n.son[0] =n.son[1] =-1;
		T.resize(1,n);
		constI(0);}
	
	void kopanice(int akt) {
		// flip tohto podstromu
		node n =T[akt];
		if(n.fl == 0) return;
		if(n.son[0] != -1) for(int i =0; i < 2; i++)
			T[n.son[i]].fl =(T[n.son[i]].fl+n.fl)%2;
		T[akt].ones =n.k-n.z-n.ones;
		T[akt].sum =(Pow[n.k-n.z]-1-n.sum)%mod;
		if(T[akt].sum < 0) T[akt].sum +=mod;
		T[akt].fl =0;}
	
	void flip(int akt, int zac, int kon) {
		node n =T[akt];
		if(zac == n.z && kon == n.k) T[akt].fl =(T[akt].fl+1)%2;
		kopanice(akt);
		if(zac >= n.k || kon <= n.z) return;
		if(zac == n.z && kon == n.k) return;
		flip(n.son[0],zac,min(kon,T[n.son[0]].k));
		flip(n.son[1],max(zac,T[n.son[1]].z),kon);
		T[akt].sum =(T[n.son[0]].sum+T[n.son[1]].sum*Pow[(n.k-n.z)/2])%mod;
		if(T[akt].sum < 0) T[akt].sum +=mod;
		T[akt].ones =(T[n.son[0]].ones+T[n.son[1]].ones);}
	};

int main() {
	cin.sync_with_stdio(0);
	char cc[1000000+tisic];
	string s;
	scanf("%s",cc);
	s =(string)cc;
	int N =s.length(),M,a,b;
	Pow.resize(N+tisic,1);
	for(int i =0; i < N; i++) {
		Pow[i+1] =(Pow[i]*2)%mod;
		if(Pow[i+1] < 0) Pow[i+1] +=mod;}
	intervalac I(N-1);
	for(int i =0; i < N-1; i++) if(s[i] == '1') I.flip(0,N-i-2,N-i-1);
	int k =(int)(s[N-1] == '1');
	if(k == 0) printf("%lld\n",I.T[0].sum+(int)((I.T[0].ones+k)%2 == 0));
	else printf("%lld\n",I.T[0].sum+1);
	scanf(" %d",&M);
	for(int i =0; i < M; i++) {
		scanf(" %d %d",&b,&a);
		a =N-a, b =N-b;
		if(a == 0) {k =1-k; a++;}
		I.flip(0,a-1,b);
		if(k == 0) printf("%lld\n",I.T[0].sum+(int)((I.T[0].ones+k)%2 == 0));
		else printf("%lld\n",I.T[0].sum+1);}
    return 0;}
        
// look at my code
// my code is amazing
