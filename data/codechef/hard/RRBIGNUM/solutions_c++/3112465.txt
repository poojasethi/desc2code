//{{{ theCodeGame
/******
When we seek excellence, excellence exists in performance, more-so in the preparation :D
******/
#include<iostream>
#include<algorithm>
#include<cmath>
#include<climits>
#include<vector>
#include<list>
#include<stack>
#include<queue>
#include<deque>
#include<stack>
#include<bitset>
#include<set>
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<map>
#include<functional>
#include<numeric>
#include<utility>
#include<sstream>
#include<iomanip>
#include<cctype>
//#undef thecodegame
#ifdef thecodegame
    #include<debug.h>
#else
    #define db(...) {}
    #define dbt(...) {}
	#define pprintf(...) {}
#endif

using namespace std;

#define assert(f) {if(!(f)){fprintf(stderr,"Line-->%d  Assertion failed: %s\n",__LINE__,#f);exit(1);}}
#define MOD 	 1000000007LL
#define ABS(x)   ((x)<0?-(x):(x))
#define SQR(x) 	 ((x)*(x))
#define CUBE(x)  ((x)*(x)*(x))
#define pnl      printf("\n")
#define REP(i,n)        for(__typeof(n) i=0;i<(n);i++)
#define FOR(i,a,b)      for(__typeof(b) i=(a);i<(b);++i)
#define FORE(i,a,b)     for(__typeof(b) i=(a);i<=(b);++i)
#define FORD(i,a,b,d)   for(__typeof(b) i=(a);i<(b);i+=(d))
#define FORR(i,n,e)     for(__typeof(n) i=(n);i>=(e);--i)
#define FORRD(i,n,e,d)  for(__typeof(n) i=(n);i>=(e);i-=(d))
#define REP_IT(it,m)    for(it=m.begin();it!=m.end();it++)
#define FORI(it,s) 	    for(__typeof((s).begin()) (it)=(s).begin();(it)!=(s).end();(it)++)
#define FOREACH(it, X)  for(__typeof((X).begin()) it = (X).begin(); it != (X).end(); ++it)
#define UNIQUE(v)       sort(ALL(v)),v.erase(unique(ALL(v)),v.end())
#define FILL(a,b)       memset(a,b,sizeof(a))
#define ALL(v)          (v).begin(), (v).end()
#define RALL(v)         (v).rbegin(), (v).rend()
#define checkbit(n,b)   (((n)>>(b))&1)
#define PB push_back
#define MP make_pair
#define XX first
#define YY second

const double PI=acos(-1.0);
const double EPS=1e-11;
template<typename T>inline T mod(T N,T M){return (N%M+M)%M;}
double start;//time
#ifdef amy
	#define SD(x) scanf("%d",&x);
#else
	#define SD(x) inp(x)
    #define getcx getchar_unlocked
    template<typename T>inline void inp(T &n){
        n=0;int ch=getcx();int sign=1;
        while(ch<'0'||ch>'9'){if(ch=='-')sign=-1;ch=getcx();}
        while(ch>='0'&&ch<='9'){n=(n<<3)+(n<<1)+ch-'0',ch=getcx();}
        n=n*sign;
    }
#endif
//}}}
typedef long long LL;
typedef unsigned long long ULL;
typedef vector<int> VI;
typedef pair<int,int> PII;
typedef vector<pair<int,int> >VPII;

#define SIZE 100000009
#define MAXX 100000009
void pre(){}
template<class node>
class segtree{
    int u,v;
	template<void(*fn)(node&)>void update(int rt,int ll,int rr){
        if(u<=ll&&rr<=v){return fn(tree[rt]);}
        int m=(ll+rr)>>1,l=rt<<1,r=l|1;
        split(tree[rt],tree[l],tree[r]);
        if(v>m){update<fn>(r,m,rr);}
        if(u<m){update<fn>(l,ll,m);}
        tree[rt].merge(tree[l],tree[r]);
    }
    node query(int rt,int ll,int rr){
        if(u<=ll&&rr<=v){return tree[rt];}
        int m=(ll+rr)>>1,l=rt<<1,r=l|1;
        split(tree[rt],tree[l],tree[r]);
        node res;
        if(u>=m){res=query(r,m,rr);
        }else if(v<=m){res =query(l,ll,m);
        }else{node n1=query(l,ll,m),n2=query(r,m,rr);res.merge(n1,n2);}
        tree[rt].merge(tree[l],tree[r]);
        return res;
    }
    void mergeup(int i){i>>=1;while(i>0){tree[i].merge(tree[i<<1],tree[(i<<1)|1]),i>>=1;}}
    void splitdown(int i){i>>=1;if(i>0){splitdown(i);}tree[i].split(tree[i<<1],tree[(i<<1)|1]);}
    inline void split(node& a,node& b,node& c){return a.split(b,c);}
public:
    int N,lf,rf;
    node *tree,id;
    segtree(int n,const node arr[],node& id){
        this->id=id;N=0;
        while((1<<N)<n){N++;}
        lf=1<<N;rf=lf<<1;
        tree=new node[rf];
        REP(i,n){tree[i+lf]=arr[i];}
        FOR(i,n+lf,rf){tree[i]=id;}
        FORR(i,lf-1,1){tree[i].merge(tree[i<<1],tree[(i<<1)|1]);}
    }
    node query(int u,int v){this->u=u+lf;this->v=v+lf+1;return query(1,lf,rf);}
    node query(int u){u+=lf;splitdown(u);return tree[u];}
    template<void(*fn)(node&)>void update(int u,int v){this->u=u+lf;this->v=v+lf+1;update<fn>(1,lf,rf);}
    template<void(*fn)(node&)>void update(int u){u+=lf;splitdown(u);fn(tree[u]);mergeup(u);}
    void display(){FOR(i,1,rf){tree[i].display(i);}pnl;pnl;}
    ~segtree(){delete tree;}
};

typedef int I32;
typedef long long I64;
const int P = 1000000007;
int NORM(int x) {
    if(x>=P) return x-P;
    if(x<0)  return x+P;
    return x;
}

struct node{
    int totsum, count, sum, totcount;
    bool flip;
    node(){
        totsum = count = sum = totcount = 0;
        flip = false;
    }
    void merge(node& a, node& b) {
        sum = NORM(a.sum + b.sum);
        count = a.count + b.count;
        totsum = NORM(a.totsum + b.totsum);
        totcount = a.totcount + b.totcount;
        flip = 0;
    }
    void invert() {
        flip ^= 1;
        sum = totsum - sum;
        count = NORM(totcount - count);
    }
    void split(node& a, node& b) {
        if(flip)a.invert(), b.invert();
        flip = 0;
    }
};
void change(node& n){
    n.invert();
}
char str[1000001];
node arr[1000001],identity;
int n,q,l,r;
void result(segtree<node>&s) {
    node r = s.query(0,n-1);
    int inc = s.query(n-1).count? 1: ((r.count&1)?0:2);
    printf("%Ld\n", ((r.sum+inc)*(I64)((P+1)/2))%P);
}

void doThis(int ccc){
    scanf("%s",str);
    n = strlen(str);
    for(int i=n,pow=1; i--; pow=NORM(pow*2)){
        arr[i].totsum = pow;
        arr[i].count = str[i]-'0';

        arr[i].sum = (str[i]-'0')*pow;
        arr[i].totcount = 1;
        arr[i].flip = false;
    }
    segtree<node>s(n,arr,identity);
    result(s);
    scanf("%d",&q);
    REP(Q,q){
        scanf("%d %d",&l,&r);
        s.update<change>(l-1,r-1);
        result(s);
    }
}
int main(){
start = clock();
ios_base::sync_with_stdio(false);
#ifdef amy
	freopen("C:\\A\\in.txt","r+",stdin);freopen("C:\\A\\out.txt","w+",stdout);//freopen("C:\\A\\err.txt","w+",stderr);
#endif
pre();
int cases = 1;
//SD(cases);
FORE(i,1,cases){doThis(i);}
#ifdef amy
	fprintf(stdout,"\nTIME: %.3lf sec\n",(double)(clock()-start)/(CLOCKS_PER_SEC));
#endif
//while((clock()-start)<0.999*CLOCKS_PER_SEC){} // :D :D
return 0;
}//end main
