#include<cstdio>
#include<iostream>
using namespace std;
 
#define mod 1000000007
#define MAX 1000001
 
struct st
{
    int l,r;
    int count;
    long long totalsum,countsum;
    bool flip;
}st[3*MAX];
 
long long power[MAX];
int n;
string s;
void solve(int flag);
void buildtree(int nodenum);
void rangeflip(int left,int right,int i = 1);
 
int main()
{
    power[0]=1;
    for(int i = 1;i < MAX;i++)power[i] = (power[i-1] * 2) % mod;
    cin>>s;
    n = s.length();
    st[1].l=1;
    st[1].r=n;
    buildtree(1);
    int q,l,r;
    int flag=0;
    if(s[n-1]=='1')flag=1;
    solve(flag);
    scanf("%d",&q);
    while(q--)
    {
        scanf("%d%d",&l,&r);
        if(r==n)flag^=1;
        rangeflip(l,r);
        solve(flag);
    }
}
void solve(int flag)
{
    long long ans = st[1].countsum , temp = 0;
    if(flag == 0)
    {
        temp = 1 - st[1].count % 2;
    }
    else ans += 1;
    ans %= mod;
    if(ans % 2 == 0)ans /= 2;
    else ans = (ans + mod) / 2;
    printf("%lld\n",ans + temp);
}
 
inline void flipsingle(int i)
{
    st[i].count = st[i].r - st[i].l - st[i].count+1;
    st[i].countsum = st[i].totalsum - st[i].countsum;
    st[i].flip ^= 1;
}
 
inline void merge(int i)
{
    st[i].count = st[2*i].count + st[2*i+1].count;
    st[i].totalsum = st[2*i].totalsum + st[2*i+1].totalsum;
    st[i].countsum = st[2*i].countsum + st[2*i+1].countsum;
}
 
void rangeflip(int i,int j,int nodenum)
{
    int a,b;
    a=st[nodenum].l;
    b=st[nodenum].r;
    if(b<i || a>j)return ;
 
    if(a>=i && b<=j)
    {
           // cout<<a<<"   "<<b<<"   "<<count<<endl;
                       flipsingle(nodenum);
                       return;
    }
    if( st[nodenum].flip==true)
    {
        flipsingle(2*nodenum);
        flipsingle(2*nodenum+1);
        st[nodenum].flip=false;
    }
 
    rangeflip(i,j,2*nodenum);
    rangeflip(i,j,2*nodenum+1);
    merge(nodenum);
}
/*void rangeflip(int left,int right,int i)
{
    if(st[i].r>=left&&st[i].l<=right)
    {
        if(st[i].l>=left&&st[i].r<=right)
        {
            flipsingle(i);
        }
        else
        {
            if(st[i].l!=st[i].r&&st[i].flip==1)
            {
                flipsingle(2*i);
                flipsingle(2*i+1);
                st[i].flip=0;
            }
            rangeflip(left,right,2*i);
            rangeflip(left,right,2*i+1);
            merge(i);
        }
    }
}
*/

void buildtree(int nodenum)
{
    //st[nodenum].num_bits=st[nodenum].right-st[nodenum].left+1;
    
    if(st[nodenum].l==st[nodenum].r)
    {
        char xyz=(char)s[st[nodenum].l-1];
        //cout<<xyz<<endl;
        if(xyz=='1')
        {
            //cout<<xyz<<'adasd'<<endl;
            st[nodenum].count=1;
            st[nodenum].countsum=power[n-st[nodenum].l];
            st[nodenum].totalsum=st[nodenum].countsum;
            st[nodenum].flip=false;
        
        }
        else
        {
            //cout<<xyz<<endl;
            st[nodenum].count=0;
            st[nodenum].countsum=0;//power[n-st[nodenum].l];
            st[nodenum].totalsum=power[n-st[nodenum].l];
            st[nodenum].flip=false;
            
        }
        return;
    }
    else
    {
         int mid=(st[nodenum].l+st[nodenum].r)/2;
          st[2*nodenum].l=st[nodenum].l;
          st[2*nodenum].r=mid;
          st[2*nodenum+1].l=mid+1;
          st[2*nodenum+1].r=st[nodenum].r;
          st[nodenum].flip=false;
          buildtree(2*nodenum);
          buildtree(2*nodenum+1);
          merge(nodenum);
          return;
    }
}
