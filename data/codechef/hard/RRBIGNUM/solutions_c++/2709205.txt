#include <set>
#include <map>
#include <cmath>
#include <ctime>
#include <queue>
#include <stack>
#include <vector>
#include <string>
#include <cctype>
#include <cstdio>
#include <iomanip>
#include <sstream>
#include <cstdlib>
#include <cassert>
#include <climits>
#include <complex>
#include <numeric>
#include <valarray>
#include <iostream>
#include <string.h>
#include <algorithm>
using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<string> vs;

#define inf 1061109567
#define pb push_back
#define mp make_pair
#define all(a) a.begin(),a.end()
#define mem(x,a) memset(x,a,sizeof(x))
#define rep(i,n) for(int i(0),_n(n);i<_n;++i)
#define repi(i,a,b) for(int i(a),_b(b);i<_b;++i)
#define repr(i,a,b) for(int i(a),_b(b);i>=_b;--i)
#define repe(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();++it)
#define len(x) ((int)(x.size()))

#define DEBUG 1 
#if DEBUG && !ONLINE_JUDGE 
	#define debug(args...) (Debugger()) , args
	class Debugger { public: Debugger(const std::string& _separator = ", ") : first(true), separator(_separator){} template<typename ObjectType> Debugger& operator , (const ObjectType& v) { if(!first) std::cerr << separator; std::cerr << v; first = false; return *this; } ~Debugger() { std::cerr << endl;} private: bool first; std::string separator; }; template <typename T1, typename T2> inline std::ostream& operator << (std::ostream& os, const std::pair<T1, T2>& p) { return os << "(" << p.first << ", " << p.second << ")"; } template<typename T> inline std::ostream &operator << (std::ostream & os,const std::vector<T>& v) { bool first = true; os << "["; for(unsigned int i = 0; i < v.size(); i++) { if(!first) os << ", "; os << v[i]; first = false; } return os << "]"; } template<typename T> inline std::ostream &operator << (std::ostream & os,const std::set<T>& v) { bool first = true; os << "["; for (typename std::set<T>::const_iterator ii = v.begin(); ii != v.end(); ++ii) { if(!first) os << ", "; os << *ii; first = false; } return os << "]"; } template<typename T1, typename T2> inline std::ostream &operator << (std::ostream & os,const std::map<T1, T2>& v) { bool first = true; os << "["; for (typename std::map<T1, T2>::const_iterator ii = v.begin(); ii != v.end(); ++ii) { if(!first) os << ", "; os << *ii ; first = false; } return os << "]"; } 
#else 
		#define debug(args...) 
#endif


const ll mod= 1000000007;


typedef pair<int,int> pii;

ll bigmod(ll b, ll p, ll m){
	ll  r = 1;
	while(p > 0){
		if(p%2==1){
			r=(r*b)%m;
		}
		p/=2;
		b=(b*b)%m;
	}
	return r;
}


pii tree[4000000];
int lazy[4000000];
int p2[1111111],odd,mod2;



int getfirst(int node,int f,int s){
	
	if(f>s)return 0;
	
	if(!lazy[node])return tree[node].first;
	
	ll t1=(p2[s-f+1]-1+mod)%mod;
	
	t1*=p2[f];
	
	t1%=mod;
	
	
	
	return (t1-tree[node].first+mod)%mod;
	
}

int getsecond(int node,int f,int s){
	
	if(f>s)return 0;

	if(!lazy[node])return tree[node].second;
	
	return s-f+1-tree[node].second;
	
}


void update(int node,int l,int r,int lt,int rt){
	
	if(l>rt||r<lt)return;
	
	if(l>=lt&&r<=rt){
		lazy[node]^=1;
		return;
	}
	
	if(lazy[node]){
		lazy[node]^=1;
		lazy[node*2]^=1;
		lazy[node*2+1]^=1;
	}
	
	int m=(l+r)>>1;
	
	update(node*2,l,m,lt,rt);
	update(node*2+1,m+1,r,lt,rt);
	
	tree[node].first=(getfirst(node*2,l,m)+getfirst(node*2+1,m+1,r))%mod;
	tree[node].second=getsecond(node*2,l,m)+getsecond(node*2+1,m+1,r);
	
	
}


pii query(int node,int l,int r,int lt,int rt){
	
	
	if(l>rt||r<lt)return mp(0,0);
	
	if(l>=lt&&r<=rt){
		return mp(getfirst(node,l,r),getsecond(node,l,r));
	}
	
	int m=(l+r)>>1;
	
	if(lazy[node]){
		lazy[node]^=1;
		lazy[node*2]^=1;
		lazy[node*2+1]^=1;
	}
	
	pii p=mp(0,0),p1,p2;
	
	
	
	p1=query(node*2,l,m,lt,rt);
	p2=query(node*2+1,m+1,r,lt,rt);
	
	
	tree[node].first=(getfirst(node*2,l,m)+getfirst(node*2+1,m+1,r))%mod;
	tree[node].second=getsecond(node*2,l,m)+getsecond(node*2+1,m+1,r);
	
	
	p.first=(p1.first+p2.first)%mod;
	p.second=(p1.second+p2.second)%mod;
	
	return p;
	
}


string s;

void fun(){
	
	pii p=query(1,0,len(s)-1,0,len(s)-1);
	
	//~ debug(p);
	
	ll t1;
	
	if(odd){
		t1=((p.first+1LL)*mod2)%mod;
		printf("%d\n",(int)t1);
		return;
	}
	
	t1=p.first;
	
	t1*=mod2;
	t1%=mod;
	
	t1+=p.second%2==0;
	t1%=mod;
	
	printf("%d\n",(int)t1);
	
	
	
}


int main(){

	//~ freopen("in", "r", stdin);
	//~ freopen("out1", "w", stdout);
	
	p2[0]=1;

	
	
	mod2=bigmod(2,mod-2,mod);
	
	cin>>s;
	
	repi(i,1,len(s)+1){
		p2[i]=(p2[i-1]+p2[i-1])%mod;
	}
	
	odd=s[len(s)-1]=='1';
	
	
	reverse(all(s));
	
	
	rep(i,len(s)){
		
		if(s[i]=='1')update(1,0,len(s)-1,i,i);
		
	}
	
	fun();
	
	int m,t1,t2;

	scanf("%d",&m);
	
	rep(i,m){
		
		scanf("%d %d",&t1,&t2);
	
		if(t2==len(s))odd^=1;
		t1=len(s)-t1;
		t2=len(s)-t2;
		update(1,0,len(s)-1,t2,t1);
		fun();
	}
	
	//~ cout<<endl<<1.0*clock()/CLOCKS_PER_SEC;
	

}









