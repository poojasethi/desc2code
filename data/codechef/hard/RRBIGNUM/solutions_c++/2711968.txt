#include<iostream>
#include<cstdio>
using namespace std;
#include<string>
int power[1000001];
#define max 1000001
int mod=1000000007;int mid;
string s;int k;
struct node
{
    int left,right,num_one;
    int total,curr;
    bool flip;
};
node tree[3*max];//long long ans;
void flip(int x)
{
    tree[x].flip^=1;
    tree[x].num_one=tree[x].right-tree[x].left+1-tree[x].num_one;
    tree[x].curr=tree[x].total-tree[x].curr;
    if(tree[x].curr<0)tree[x].curr+=mod;
}    
void merge(int nodenum)
{
        tree[nodenum].num_one=tree[2*nodenum].num_one+tree[2*nodenum+1].num_one;
        tree[nodenum].total=(tree[2*nodenum].total+tree[2*nodenum+1].total)%mod;
        tree[nodenum].curr=(tree[2*nodenum].curr+tree[2*nodenum+1].curr)%mod;
}        
void buildtree(int nodenum)
{
    //tree[nodenum].num_bits=tree[nodenum].right-tree[nodenum].left+1;
    
    if(tree[nodenum].left==tree[nodenum].right)
    {
        char xyz=(char)s[tree[nodenum].left-1];
        //cout<<xyz<<endl;
        if(xyz=='1')
        {
            //cout<<xyz<<'adasd'<<endl;
            tree[nodenum].num_one=1;
            tree[nodenum].curr=power[k-tree[nodenum].left];
            tree[nodenum].total=tree[nodenum].curr;
            tree[nodenum].flip=false;
        
        }
        else
        {
            //cout<<xyz<<endl;
            tree[nodenum].num_one=0;
            tree[nodenum].curr=0;
            tree[nodenum].total=power[k-tree[nodenum].left];
            tree[nodenum].flip=false;
            
        }
        return;
    }
    else
    {
          mid=(tree[nodenum].left+tree[nodenum].right)/2;
          tree[2*nodenum].left=tree[nodenum].left;
          tree[2*nodenum].right=mid;
          tree[2*nodenum+1].left=mid+1;
          tree[2*nodenum+1].right=tree[nodenum].right;
          tree[nodenum].flip=false;
          buildtree(2*nodenum);
          buildtree(2*nodenum+1);
          merge(nodenum);
          return;
    }
}
void query(int i,int j,int nodenum)
{
    int a,b;
    a=tree[nodenum].left;
    b=tree[nodenum].right;
    if(b<i || a>j)return ;
    
    if(a>=i && b<=j)
    {
                       flip(nodenum);
                       return;
    }
    if( tree[nodenum].flip==true)
    {
        flip(2*nodenum);
        flip(2*nodenum+1);
        tree[nodenum].flip=false;
    }    
        
    query(i,j,2*nodenum);
    query(i,j,2*nodenum+1);
    merge(nodenum);
}    
    
int give_ans(int parity)
{
    int temp=tree[1].curr,x=0;
    if(parity==1)
    {
        temp++;
        temp%=mod;
        if(temp%2==0)return temp/2;
        else return (temp+mod)/2;
    }
    else 
    {
        if( tree[1].num_one%2==0)
        {
            //cout<<"YAY"<<temp<<endl;
              temp%=mod;
              if(temp%2==0)return temp/2+1;
              else return (temp+mod)/2+1;
        }
        else
        {
              temp%=mod;
              if(temp%2==0)return temp/2;
              else return (temp+mod)/2;
        }
    }
}                
              
        
        
        
                    
int main()
{
    power[0]=1;
    for(int i=1;i<1000001;i++)
    {
        power[i]=(2*power[i-1])%mod;
    }
     //cout<<power[105]<<endl;
   
    cin>>s;
    k=s.length();
    
    //t x=k&(k-1);
    
    int parity=0;
    if(s[k-1]=='1')parity=1;
    //tree=new node[4*temp];
    tree[1].left=1;
    tree[1].right=k;
    buildtree(1);
    printf("%d\n",give_ans(parity));
                
    int m;
    scanf("%d",&m);
    int p,q;
    while(m--)
    {
        scanf("%d %d",&p,&q);
        query(p,q,1);
        if(q==k)parity^=1;
       // cout<<give_ans(parity)<<endl;
        printf("%d\n",give_ans(parity));
    }
}        
        

    