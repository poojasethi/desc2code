#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
#include <string>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <stack>
#include <map>
#include <new>

#define LL long long int
#define MOD 1000000007
#define MAX 4000007

using namespace std;

string bs;//binary string
int l;//length of binary string
vector<int> bv;//binary vector corresponding to  bs
int lb;//last bit
vector<int> nb1;//no.of bits 1
vector<LL> spv;//sum of place value
vector<LL> spvwd;//spv with digit
vector<int> flip;
LL pp;//partial product in ans=2^(M-2)%M

void preprocess() {
    nb1.resize(MAX);
    spv.resize(MAX);
    spvwd.resize(MAX);
    flip.resize(MAX);
}

LL power_up(LL base,LL power,LL modd) {
    LL result=1;
    LL cp=base;
    while(power>0) {
        if(power%2!=0) { 
            result =(result * cp)%modd;
        }
        power=power/2;;
        cp =(cp * cp)% modd;
    }
    return (result%modd);
}

void build_st(int node,int low,int high) {
    if(low==high) {
        flip[node]=0;
        spv[node]=power_up(2,(LL)(l-1-low),MOD);
        if(bv[low]==1){
            nb1[node]=1;
            spvwd[node]=spv[node];
        }
        else {
            nb1[node]=0;
            spvwd[node]=0;
        }
        return;
    }
    int mid=(low+high)/2;
    build_st(2*node,low,mid);
    build_st(2*node+1,mid+1,high);
    nb1[node]=nb1[2*node]+nb1[2*node+1];
    flip[node]=0;
    spv[node]=(spv[2*node]+spv[2*node+1])%MOD;
    spvwd[node]=(spvwd[2*node]+spvwd[2*node+1])%MOD;
}

LL find_ans() {
    if(lb==0) {
        if(nb1[1]%2==0) {
            if(spvwd[1]-1<0) {
                return 1;
            }
            else {
                return (((spvwd[1]*pp)%MOD)+1)%MOD;
            }
        }
        else {
            if(spvwd[1]-1<0) {
                return 0;
            }
            else {
                return (((spvwd[1]*pp)%MOD));
            }
        }
    }
    else {
        return (((spvwd[1]+1)%MOD)*pp)%MOD;
    }
}

void update(int node,int low,int high,int i,int j) {
    if(flip[node]==1) {
        spvwd[node]=(spv[node]-spvwd[node]+MOD)%MOD;
        nb1[node]=(high-low+1)-nb1[node];
        if(low!=high) {
            flip[2*node] ^= 1;
            flip[2*node+1] ^= 1;
        }
        flip[node]=0;
    }
    if(high<i || low>j)
        return;
    if(low>=i && high<=j) {
        spvwd[node]=(spv[node]-spvwd[node]+MOD)%MOD;
        nb1[node]=(high-low+1)-nb1[node];
        if(low!=high) {
            flip[2*node] ^= 1;
            flip[2*node+1] ^= 1;
        }
        return;
    }
    int mid=(low+high)/2;
    update(2*node,low,mid,i,j);
    update(2*node+1,mid+1,high,i,j);
    nb1[node]=nb1[2*node]+nb1[2*node+1];
    spvwd[node]=(spvwd[2*node]+spvwd[2*node+1])%MOD;
}

int main() {
    //ios_base::sync_with_stdio(false);
    //freopen("input.txt","r",stdin);
    //freopen("output.txt","w",stdout);
    pp=power_up(2,(MOD-2),MOD);
    //preprocess();
    char sr[1000007];
    scanf("%s",sr);
    l=strlen(sr);
    //cin>>bs;
    //l=bs.size();
    for(int i=0;i<l;i++) {
        bv.push_back(sr[i]-'0');
    }
    lb=bv[l-1];
    preprocess();
    build_st(1,0,l-1);
    //cout<<find_ans()<<endl;
    printf("%lld\n",find_ans());
    int upd;
    //cin>>upd;
    scanf("%d",&upd);
    while(upd--) {
        int lidx,ridx;
        //cin>>lidx>>ridx;
        scanf("%d %d",&lidx,&ridx);
        lidx--;ridx--;
        if(ridx==l-1) {
            lb ^= 1;
        }
        update(1,0,l-1,lidx,ridx);
        //cout<<find_ans()<<endl;
        printf("%lld\n",find_ans());
    }
    return 0;
}
