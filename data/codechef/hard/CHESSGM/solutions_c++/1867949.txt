/*
brute force using DP

#include<cstdio>

using namespace std;
#define mod 1000000007
#define wile(n) while(n-- > 0 )
#define FOR(i,a,b) for( int i=a; i<b; i++)

int FAST_IO()
{	int x=0, Negativity=0;
	char ch;
	while (((ch=getchar_unlocked()) < 48 || ch > 57) && ch != '-');		// ASCII value 0->9
	if (ch == '-')
		Negativity=1;
	else 
		x = ch-48;
	while ((ch=getchar_unlocked()) >= 48 && ch <= 57)
		x=x*10+ch-48;
	return (Negativity) ? -x : x;
}

int count=0,d;

int func(int i, int j, int t)
{	printf("i: %d j: %d t: %d\n",i,j,t);
	if ( ( i == j && j == t ) && ( t == 0 ) )
		return 1;
	int s1,s2,s3;
	s1= ( i+1 > d || t-1 < 0 ) ? 0 : func(i+1,j,t-1);
	s2= ( ( i-1 < 0 || j+1 > d ) || (t-1 < 0) ) ? 0 : func(i-1,j+1,t-1);
	s3= ( j-1 < 0 || t-1 < 0 ) ? 0 : func(i,j-1,t-1);
	return ((long long int)s1+s2+s3)%mod;
	//return ((func(i+1,j,t-1))%mod + (func(i-1,j+1, t-1))%mod + (func(i,j-1, t-1))%mod) %mod;
}

int main()
{	int k;
	d=FAST_IO();
	k=FAST_IO();
	printf("%d\n", func(0,0,k));
	return 0;
}
*/


#include<cstdio>
#include<vector>
#include<cstring>

using namespace std;

#define MOD 1000000007
#define MAXK 8
#define MAXSTATE MAXK*MAXK
#define FOR(i,a,b) for( int i=a; i<b; i++)
#define fi first
#define se second

int FAST_IO()
{	int x=0, Negativity=0;
	char ch;
	while (((ch=getchar_unlocked()) < 48 || ch > 57) && ch != '-');		// ASCII value 0->9
	if (ch == '-')
		Negativity=1;
	else 
		x = ch-48;
	while ((ch=getchar_unlocked()) >= 48 && ch <= 57)
		x=x*10+ch-48;
	return (Negativity) ? -x : x;
}

typedef long long ll;
typedef pair<int, int> pii;

class matrix
{	public:
	int m, n, v[MAXSTATE][MAXSTATE];		// m*n matrix size
	matrix(int m1, int n1)
	{	m=m1, n=n1;
		memset(v, 0, sizeof(v));		// initialize all 0
	}
};

int n, state_moves[MAXK][MAXK][MAXK][MAXK];	// state_moves-> adjacency matrix if a[i][j][i0][j0]=1 -> (i,j)->(i0,j0) a valid move
// adjacency matrix that shows set of all possibe movements. Since separation has to be <= D, and i,j denote separation MAX_SIZE <= 7  ( D max = 7 )

matrix mul(matrix *m1, matrix *m2)
{	matrix ret((*m1).m, (*m2).n);
	FOR(i,0,ret.m)
		FOR(j,0,ret.n)
		{	ret.v[i][j] = 0;
			FOR(k,0,(*m1).n)
			{	ret.v[i][j] += ((long long)(*m1).v[i][k] * (*m2).v[k][j]) % MOD;
				ret.v[i][j] %= MOD;
			}
		}
	return ret;
}
 
matrix pow(matrix *m, int a)		// matrix exponentiation
{	if (a == 1)
		return *m;
	matrix ret = pow(m, a>>1);
	ret = mul(&ret, &ret);
	if (a & 1)
		ret = mul(&ret, m);
	return ret;
}
 
int main()
{	int d=FAST_IO(), k=FAST_IO();
	if (k < 2)
	{	switch (k)
		{	case 0:	printf("1\n");		// 0 moves, initially already distance between the pair is 0!
				break;
			default: printf("0\n");		// in 1 move not possible as originally dist b/w each pair is 0!
		}
		return 0;
	}
	vector<pii> states;	// a linear array that stores al possible states
	FOR(i,0,d+1)
		FOR(j,0,d+1)
		{	states.push_back(pii(i, j));		// store all possible permutation of moves
			/*
			states[0]=(0,0), states[1]=(0,1), states[2]=(0,2), ....
			from (i,j) state, the state can change to->
			(i-1,j)
			(i+1,j-1)
			(i,j+1)
			*/
			if ( i != 0 )
				state_moves[i][j][i - 1][j] = 1;		// means (i,j)->(i-1,j) a valid move
			if ( i < d && j != 0 )
				state_moves[i][j][i + 1][j - 1] = 1;
			if ( j < d )
				state_moves[i][j][i][j + 1] = 1;
		}
	n = states.size();		// total possible states == (i*j)
	matrix mat(n,n);
	FOR(i,0,n)
		FOR(j,0,n)
		{	mat.v[i][j] = state_moves[states[i].fi][states[i].se][states[j].fi][states[j].se];
			// transform the 4d matrix to a 2d matrix v[i][j] where i-> represents a valid state of the form -> (states[i].fi, states[i].se) and j-> represents a valid state of the form -> (states[j].fi, states[j].se)
		}
	// mat.v[][] represents an adjacency matrix of possible valid moves of length 1 aka length == no. of turns
	// Using property of graph theory, power k of an adjacency matrx A, then A[i][j]= no. of paths from i->j of length k! Using thesame logic
	// here, wherei->j is the state transitions
 	mat = pow(&mat, k);		// exponentiation
	/*FOR(i,0,n)
	{	FOR(j,0,n)
			printf("states:%d,%d-> %d,%d   %d\t", states[i].fi, states[i].se, states[j].fi, states[j].se,mat.v[i][j]);
		printf("\n");
	}*/
	int res = 0;
	printf("%d\n", mat.v[0][0]);
	return 0;
}

/*
EXPLANATION

We can solve this problem using Dynamic Programming:

    Call F(i, j, t) = the number of ways to complete the game after t turns in the state that the left pawn is i steps far from the middle, and the middle pawn is j steps far from the right one.

    So F(i, j, t) = SUM( F(i', j', t - 1) ) while (i', j') can be:

--- (i + 1, j) in case the last move is the move of the left pawn,

--- or (i - 1, j + 1) in case the last move is the move of the midle pawn,

--- or (i, j - 1) in case the last move is the move of the right one.

    The base state should be F(0, 0, 0) = 1,

    then the result should be F(0, 0, K).

            This solution takes a complexity of O( D^2 x K ).

To reduce the complexity, we use matrix multiplication!

    At first, we build the matrix M, while M(s, s') = 1 or 0 whether the state s can go directly to state s' or not (each state s or s' represents a state of (i, j) in the DP function mentioned above), then
1- Just take the power K of the matrix M and take the sum of M(s, s * ) as the result while s * is the state of (0, 0).
2- Alternately, using powers of adjacency matrix property of graphs
*/
