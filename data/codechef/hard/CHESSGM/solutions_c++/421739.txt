/*if we know adjecency matrix(A) of a graph then  each entry (i,j) of (A)^k will give us the number of paths of length k from  node i to node j 
say (i,j) is a state defined as difference between pawn first and middle is i and difference between pawn middle is j (ahead) then for each pair (i,j) 
where 0<=i<=d , 0<=j<=d we will generate a graph then we connect the states if state s1 can be reached by state s2 in a single move after making the 
adjecency matrix(AA) of this graph the required answer is (AA)^k[0][0] *
atul verma
iit2008137*/

#include <iostream>
#include <cstdio>
#include <string.h>
#include <vector>


#define mod 1000000007
typedef long long ll;
using namespace std;

struct matrix{
       int m;
       int n;
       int v[64][64];
       };
       
struct matrix matrix_mul(struct matrix m1, struct matrix m2){
       struct matrix t;
       t.m=m1.m;
       t.n=m2.n;
       for(int i=0; i<m1.m; i++){
               for(int j=0; j<m2.n; j++){
                       t.v[i][j]=0;
                       for(int k=0; k<m1.n; k++){
                               t.v[i][j]+=((ll)(m1.v[i][k])*(m2.v[k][j]))%mod;
                               t.v[i][j]%=mod;
                               }
                               }
                               }
       return t;
       }
       
struct matrix matrix_expo(struct matrix m1, int k){
       if(k==1){
                return m1;
                }
       struct matrix t=matrix_expo(m1,k/2);
       t=matrix_mul(t,t);
       if(k&1){
               t=matrix_mul(t,m1);
               }
       return t;
       }
       
vector< pair<int,int> > vii;
int adj[8][8][8][8];
int main()
{
    int d,k; 
    scanf("%d%d",&d,&k);
    if(k==0){
             printf("%d\r\n",1);
             return 0;
             }
    if(k==1||k==2){
                   printf("%d\r\n",0);
                   return 0;
                   }
            
    int newadj[64][64];
    memset(adj,0,sizeof(adj));
    memset(newadj,0,sizeof(newadj));
      //start to generate the graph 

for(int i=0; i<=d; i++){
        for(int j=0; j<=d; j++){
                vii.push_back(make_pair(i,j));
                 if(i) {adj[i][j][i-1][j]=1;}
                 if(i<d && j) {adj[i][j][i+1][j-1]=1;}
                 if(j<d) {adj[i][j][i][j+1]=1;}
                 }
                 }
//generate the adjecency matrix for the generated graph

int sz=vii.size();
struct matrix temp;
temp.m=sz;
temp.n=sz;
for(int i=0; i<sz; i++){
        for(int j=0; j<sz; j++){
                newadj[i][j]=adj[vii[i].first][vii[i].second][vii[j].first][vii[j].second];
                }}
for(int i=0; i<sz; i++){
        for(int j=0; j<sz; j++){
                temp.v[i][j]=newadj[i][j];
                }}

struct matrix m1=matrix_expo(temp,k);
    printf("%d\r\n",m1.v[0][0]%mod);
    
    
    

//system("pause");
return 0;
}
