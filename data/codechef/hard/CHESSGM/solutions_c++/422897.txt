#include <algorithm>
#include <iostream>
#include <sstream>
#include <fstream>
#include <memory>
#include <limits>
#include <vector>
#include <string>
#include <bitset>
#include <queue>
#include <stack>
#include <set>
#include <map>
#include <climits>
#include <cstring>
#include <cstdio>
#include <cmath>
using namespace std;
typedef long long llong;

const int mod = 1000000007;

int D;
llong K;
llong f[64][64], ans[64][64];

void matrixMulti(llong f1[][64], llong f2[][64])
{
    llong tmp[64][64];

    memset(tmp, 0, sizeof(tmp));
    for(int i=0; i<D*D; i++)
        for(int j=0; j<D*D; j++)
            for(int k=0; k<D*D; k++)
                tmp[i][j] =  (tmp[i][j]+f1[i][k]*f2[k][j])%mod;
    memcpy(ans, tmp, sizeof(ans));
}

void matrixPower(llong p)
{
    if( p == 0 )
        for(int i=0; i<D*D; i++)
            ans[i][i] = 1;
    else if( p == 1 )
        memcpy(ans, f, sizeof(f));
    else if( p&1 )
    {
        matrixPower(p-1);
        matrixMulti(f, ans);
    }
    else
    {
        matrixPower(p/2);
        matrixMulti(ans, ans);
    }
}

int main()
{
    cin>>D>>K;
    if( K%3 )
    {
        cout<<0<<endl;
        return 0;
    }
    D++;
    for(int i=0; i<D*D; i++)
    {
        int t1=i/D, t2=i%D;
        if( t1 != 0 )
            f[i][(t1-1)*D+t2]++;
        if( t1<D-1 && t2!=0 )
            f[i][(t1+1)*D+t2-1]++;
        if( t2 < D-1 )
            f[i][t1*D+t2+1]++;
    }
    matrixPower(K);
    cout<<ans[0][0]<<endl;

    return 0;
}
