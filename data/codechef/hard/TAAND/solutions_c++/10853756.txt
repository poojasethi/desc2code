#include<cstdio>
#include<iostream>
#include<map>
#include<vector>
#include<stack>
#include<queue>
#include<string>
#include<cstring>
#include<cmath>
#include<cstdlib>
#include<algorithm>
#include<iomanip>
#include<utility>
#include<cctype>
using namespace std;
#define initial              -1
#define visited               0
#define finished              1
#define TEMP                  false
#define PERM                  true
#define NIL                  -1
#define PB                   push_back
#define MAX(a,b)             ((a) > (b) ? (a) : (b))
#define MIN(a,b)             ((a) < (b) ? (a) : (b))
#define ABS(X)               ( (X) > 0 ? (X) : ( -(X) ) )
#define swap(a,b)            (a)^=(b),(b)^=(a),(a)^=(b) 
#define mulmod(a,b)          ((a%MOD)*(b%MOD))%MOD
#define PI                   acos(-1.0)
#define F                    first
#define S                    second
#define E                    1e-9
#define DBG(vari)            cout<<#vari<<" = "<<(vari)<<endl;
#define SQR(a)               (a)*(a)
#define DISTSQR(x1,y1,x2,y2) (sqr(x1-x2) + sqr(y1-y2))
#define SP                   system("pause")
#define ifc(x)               (flag[x>>6]&(1<<((x>>1)&31)))
#define isc(x)               (flag[x>>6]|=(1<<((x>>1)&31)))
#define malloc(type,n)       (type *)malloc(n*sizeof(type))
#define ALL(a)               (a.begin(),a.end())
#define digits(i)            (int)((log(i)/log(10))+1)
#define round(num)           (int)floor(num+0.5) 
#define count_1(num)         __builtin_popcount(num)
#define maxele(arr,a,b)                        *max_element(arr+a,arr+b+1)
#define minele(arr,a,b)                        *min_element(arr+a,arr+b+1)
#define rev(arr,a,b)                           reverse(arr+(a),arr+(b)+1)
#define bin_search(arr,a,b,val)                binary_search(arr+(a),arr+(b)+1,val)
#define sort(arr,a,b)                          sort(arr+a,arr+b+1)
#define make_unique(arr,b)                     sort(arr,0,b); n=unique(arr,arr+b+1)-arr
#define MEMSET(arr,b)                          rep(n) arr[i]=(b)
#define CLR(arr)                               rep(n) arr[i]=0
#define swapstr(s1,s2)                         swap(s1,s2)
#define strtoint(str)                          (extract_int(str)[0])
#define dela(v,a)                              (v.erase(v.begin()+a))
#define delab(v,a,b)                           (v.erase(v.begin()+a, v.begin()+b+1))
typedef struct node 
{
        int ad;
        int wt;
}NODE;
typedef unsigned long long int ull;
typedef unsigned ui;
typedef long long int ll;
typedef long double ld;
typedef vector<int>   VI;
typedef map<int,int>  MPII;
typedef vector<NODE> VN;
#define MAXVAL               (1<<31)-1
#define LIM                  (1<<15)-1
#define MOD                  1000000007
#define IND                  6542
#define MINVAL               -1
#define infinity             (1<<31)-1
#define test()               int tt; scan(tt); while(tt--)
#define scan(a)              scanf("%d",&a)
#define scanll(a)            scanf("%lld",&a)
#define print(a)             printf("%d\n",a)
#define printll(a)           printf("%lld\n",a)
#define rep(n)               for(int i=0;i<n;++i)
#define revrep(n)            for(int i=(n)-1;i>=0;--i)
#define repab(a,b)           for(int i=a;i<=b;++i) 
#define getcx getchar_unlocked
inline void inp( int &n )//fast input function
{
   n=0;
   int ch=getcx();int sign=1;
   while( ch < '0' || ch > '9' ){if(ch=='-')sign=-1; ch=getcx();}
 
   while(  ch >= '0' && ch <= '9' )
           n = (n<<3)+(n<<1) + ch-'0', ch=getcx();
   n=n*sign;
}
#define pc(x) putchar_unlocked(x);
inline void writeInt (int n)
{
	int N = n, rev, count = 0;
	rev = N;
	if (N == 0) { pc('0'); pc('\n'); return ;}
	while ((rev % 10) == 0) { count++; rev /= 10;} //obtain the count of the number of 0s
	rev = 0;
	while (N != 0) { rev = (rev<<3) + (rev<<1) + N % 10; N /= 10;}  //store reverse of N in rev
	while (rev != 0) { pc(rev % 10 + '0'); rev /= 10;}
	while (count--) pc('0');
}
VI temp,cpy;
int main()
{
int n,j,num;
inp(n);
rep(n)
{
inp(num);
temp.PB(num);
}
revrep(31)
{
cpy.clear();
for(j=0;j<(int)temp.size();++j)
if(temp[j]&1<<i)
cpy.PB(temp[j]);
if(cpy.size()>=2)
{
temp=cpy;
if(cpy.size()==2)
break;
}}
writeInt(temp[0]&temp[1]);
return 0;
}