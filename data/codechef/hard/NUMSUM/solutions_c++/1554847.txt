    #include<iostream>
    #include<string>
    #include<vector>
    #include<map>
    #include<queue>
    #include<deque>
    #include<set>
    #include<stack>
    #include<sstream>
    #include<fstream>
    #include<algorithm>
    #include<cstdlib>
    #include<cstdio>
    #include<cstring>
    #define CLRM(x) memset(x,-1,sizeof(x))
    #define CLR(x) memset(x,0,sizeof(x))
    #define ALL(x) x.begin(),x.end()
    #define PB push_back
    #define MP make_pair
    #define VI vector<int>
    #define VVI vector<vector<int> >
    #define PII pair<int,int>
    #define SZ(x) (int)x.size()
    #define LL long long
    #define MIN(a,b) (a)<(b)?(a):(b)
    #define MAX(a,b) (a)>(b)?(a):(b)
    #define LMAX 1000000000000000000LL
    #define IMAX 100000000
    using namespace std;
    #include<complex>
    complex<double> a[10][10];
    double N=8.0;
    int n=8;
    int sn;
    int pw;
    int off;
    #define PI 3.1415926535
    #define eps 1e-9
    #define VCD vector<complex<double> >
    #define CD complex<double>
    CD twiddle[1005555];
    int reversed[1005555];
    VCD getVCD(char *t,int off)
    {
    string s(t);
    int i,j,k;
    while(SZ(s)%off!=0)
    {
    s="0"+s;
    }
    VCD ret;
    for(i=0;i<SZ(s);i+=off)
    {
    int val=0;
    for(j=i;j-i<off;j++)
    {
    val*=10;
    val+=(s[j]-'0');
    }
    ret.PB(CD(val,0));
    }
    return ret;
    }
    VCD extend(VCD _v,int n)
    {
    VCD v=_v;
    while(SZ(v)!=n)
    {
    v.PB(CD(0,0));
    }
    return v;
    }
    void Vdisp(VCD &v)
    {
    int i,j,k;
    for(i=0;i<SZ(v);i++)
    {
    cout<<(fabs(v[i].real())<eps?0:v[i].real())<<" , "<<(fabs(v[i].imag())<eps?0:v[i].imag())<<"\t";
    }
    cout<<endl;
    }
    void disp(VCD &v)
    {
    int i,j,k;
    for(i=0;i<SZ(v);i++)
    {
    cout<<(fabs(v[i].real())<eps?0:v[i].real())<<" ";
    }
    cout<<endl;
    }
    CD gettwid(int _N,int _n,int _k)
    {
    int tn=_n;
    int t=_N;
    while(t<N)
    {
    t<<=1;
    tn<<=1;
    }
    return twiddle[tn];
    }
    CD twid(int _N,int _n,int _k)
    {
    return CD(cos(2*PI*_n*_k/_N),-sin(2*PI*_n*_k/_N));
    }
    VCD FT(VCD &v)
    {
    int i,j,k;
    VCD prev=v;
    VCD now=VCD(SZ(v),CD(0,0));
    int nn=n;
    for(i=n;i!=1;i>>=1)
    {
    for(j=0;j<SZ(now);j+=i)
    {
    int c=0;
    for(k=j;k<j+i/2;k++,c++)
    {
    now[k]=prev[k]+prev[k+i/2];
    now[k+i/2]=(prev[k]-prev[k+i/2])*gettwid(i,c,1);
    }
    }
    prev=now;
    }
    return now;
    }
    int rev(int t,int szn)
    {
    int tp=1<<(szn-1);
    int i,j,k;
    j=t;
    int ret=0;
    for(i=0;i<szn;i++)
    {
    if(j&1)
    ret|=tp;
    tp>>=1;
    j>>=1;
    }
    return ret;
    }
    VCD bitrev(VCD v)
    {
    int i,j,k;
    VCD ret=VCD(SZ(v),CD(0,0));
    for(i=0;i<SZ(v);i++)
    {
    ret[reversed[i]]=v[i];
    }
    return ret;
    }
    VCD mult(VCD &v1,VCD &v2)
    {
    VCD ret;
    int i,j,k;
    for(i=0;i<SZ(v1);i++)
    {
    ret.PB(v1[i]*v2[i]);
    }
    return ret;
    }
    VCD IFT(VCD &v)
    {
    int i,j,k;
    VCD prev=v;
    VCD now=VCD(SZ(v),CD(0,0));
    int nn=n;
    for(i=n;i!=1;i>>=1)
    {
    for(j=0;j<SZ(now);j+=i)
    {
    int c=0;
    for(k=j;k<j+i/2;k++,c++)
    {
    now[k]=prev[k]+prev[k+i/2];
    now[k+i/2]=(prev[k]-prev[k+i/2])*conj(gettwid(i,c,1));
    }
    }
    prev=now;
    }
    for(i=0;i<SZ(now);i++)
    {
    now[i]/=N;
    }
    return now;
    }
    string getans(VCD &v)
    {
    int i,j,k;
    string s;
    int carry=0;
    for(i=SZ(v)-1;i>=0;i--)
    {
    int t1=carry+v[i].real()+0.5;
    int t=t1;
    int x=t%pw;
    for(j=0;j<off;j++)
    {
    s.PB((x%10)+'0');
    x/=10;
    }
    carry=t/pw;
    }
    while(carry!=0)
    {
    s.PB((carry%10)+'0');
    carry/=10;
    }
    while(s[SZ(s)-1]=='0')
    s.resize(SZ(s)-1);
    reverse(ALL(s));
    return s;
    }
    char buf[601000];
    char s1[301000];
    char s2[301000];
    char s3[301000];
    int sl1, sl2;
    void add1(char*s, int& c)
    {
    //cout<<s<<" "<<c<<endl;
    int t=c-1;
    while(t>=0 && s[t]=='9')
    {
    s[t]='0';
    t--;
    }
    if(t<0)
    {
    s[c]='0';
    s[0]='1';
    c++;
    }
    else
    {
    s[t]++;
    }
    }
    void div2(char*s, int& c)
    {
    int car = 0;
    int cur = 0;
    int i, j, k;
    s3[c]='\0';
    for(i = 0; i < c; i++)
    {
    int t = s[cur]-'0';
    t = car*10+t;
    s3[cur]=(t/2)+'0';
    car = (t%2);
    cur++;
    }
    strcpy(s, s3);
    }
    void process()
    {
    int cur=0;
    int i, j, k;
    while(buf[cur]!='\0')
    {
    s1[sl1++]=buf[cur];
    s2[sl2++]=buf[cur];
    cur++;
    }
    s1[sl1]='\0';
    s2[sl2]='\0';
    add1(s1,sl1);
    if((s1[sl1-1]-'0')%2==0)
    {
    //cout<<s1<<endl;
    div2(s1,sl1);
    }
    else
    {
    //cout<<s2<<endl;
    div2(s2,sl2);
    }
    }
    int main()
    {
    int tes;
    scanf("%d",&tes);
    getchar();
    int prev=-1;
    while(tes--)
    {
    int i,j,k;
    //string s1,s2;
    gets(buf);
    int flag=0;
    int cur=0;
    sl1=0,sl2=0;
    //cout<<buf<<endl;
    process();
    /*while(buf[cur]!='\0')
    {
    if(buf[cur]==' ')
    {
    flag=1;
    cur++;
    continue;
    }
    if(flag==0)
    {
    s1[sl1++]=(buf[cur]);
    }
    else
    {
    s2[sl2++]=(buf[cur]);
    }
    cur++;
    }*/
    s1[sl1]='\0';
    s2[sl2]='\0';
    //cout<<s1<<" "<<s2<<endl;
    int z1=0;
    while(s1[sl1-1]=='0' && sl1>0)
    {
    s1[sl1-1]='\0';
    sl1--;
    z1++;
    }
    while(s2[sl2-1]=='0' && sl2>0)
    {
    s2[sl2-1]='\0';
    sl2--;
    z1++;
    }
    if(sl1==0 || sl2==0)
    {
    cout<<0<<endl;
    continue;
    }
    off=min(3,min(sl1,sl2));
    pw=1;
    for(i=0;i<off;i++)
    pw*=10;
    VCD v1=getVCD(s1,off);
    VCD v2=getVCD(s2,off);
    int t=SZ(v1)+SZ(v2)-1;
    n=1;
    sn=0;
    while(n<=t)
    {
    sn++;
    n<<=1;
    }
    N=n;
    if(n!=prev)
    for(i=0;i<=n/2;i++)
    {
    twiddle[i]=twid(n,i,1);
    }
    if(n!=prev)
    for(i=0;i<n;i++)
    {
    reversed[i]=rev(i,sn);
    }
    v1=extend(v1,n);
    v2=extend(v2,n);
    VCD ft1=FT(v1);
    VCD ft2=FT(v2);
    ft1=bitrev(ft1);
    ft2=bitrev(ft2);
    VCD fmul=mult(ft1,ft2);
    VCD ans=IFT(fmul);
    ans=bitrev(ans);
    ans.resize(t);
    string ret=getans(ans);
    ret+=string(z1,'0');
    printf("%s\n",ret.c_str());
    prev=n;
    }
    } 
