#include <bits/stdc++.h>

using namespace std;

#define sd(x) scanf("%d",&x)
#define sl(x) scanf("%lld",&x)
#define P(x) printf("%d\n",x)
#define Pl(x) printf("%lld\n",x)
#define FOR(i,x) for(int i=0;i<x;i++)
#define FORC(i,k,x) for(int i=k;i<x;i++)
#define PB push_back
#define MP make_pair
#define F first
#define S second
#define Fill(a, b) memset(a, b, sizeof(a))

#define N 100010
#define INF 1000000009
#define MOD 1000000007
#define MOD_INVERSE 500000004

typedef long long LL;
typedef pair<int, int> PII;
typedef vector<int> VI;

bool flag;
int p[N], q[N], fact[N], bit[N], inversions;

void init();
void merge_sort(int*, int, int);
void merge(int*, int, int);
void bit_update(int, int);
int bit_query(int);
LL position(int);
bool is_rotation(int);

void solve() {
	int n,k;
	LL pos;	
	sd(n); sd(k);
	FOR(i, n)	sd(p[i]);
	FOR(i, n)	sd(q[i]);
	

	if (n != k) {
		pos = position(n);
		if (k & 1) {
			int diff;
			inversions = 0;
			merge_sort(p, 0, n-1);
			diff = inversions;
			inversions = 0;
			merge_sort(q, 0, n-1);
			if ( (abs(diff-inversions)) & 1 ) {
				printf("-1\n");
			} else {
				printf("%lld\n", pos);
			}
		} else {
			printf("%lld\n", (2*pos - flag) % MOD);
		}
	} else {
		if (is_rotation(n) == false) {
			printf("-1\n");
		} else {
			printf("%d\n", q[0]);
		}
	}
}

int main() {
    int t=1;
	scanf("%d",&t);
	init();
	for(int i=1;i<=t;i++)
	{
		solve();
	}
}

void init() {
	fact[0] = 1;
	FORC(i, 1, N) {
		fact[i] = ( ((LL)fact[i-1]) * i) % MOD;
	}
}

LL position(int n) {
	flag = false;
	Fill(bit, 0);
	LL ans = 1, mul, times;
	FOR(i, n-2) {
		times = q[i] - 1;
		times -= bit_query(q[i]);
		bit_update(q[i], 1);
		mul = ((LL)fact[n-i-1] * MOD_INVERSE) % MOD;
		ans = (ans + times*mul) % MOD;
	}
	if (q[n-2] < q[n-1])	flag = true;
	return ans;
}

bool is_rotation(int n) {
	int i,j;
	for(i = 0; i < n; i++) {
		if (p[i] == q[0])
			break;
	}
	for(j = 0; j < n; j++) {
		if (p[((i+j) % n)] != q[j])
			break;
	}
	return (j == n);
}

int bit_query(int index) {
	int sum = 0;
	while (index > 0) {
		sum += bit[index];
		index -= (index & -index);
	}
	return sum;
}

void bit_update(int index, int val) {
	while(index < N) {
		bit[index] += val;
		index += (index & -index);
	}
}

void merge_sort(int* ar, int a, int b) {
	if (a < b) {
		merge_sort(ar, a, (a+b)/2);
		merge_sort(ar, (a+b)/2+1, b);
		merge(ar, a, b);
	}
}

void merge(int* ar, int a, int b) {
	int i, j, mid = (a+b)/2, temp[b-a+1], k = 0;
	for(i = a, j = mid + 1; i <= mid && j <=b;) {
		if (ar[i] <= ar[j]) {
			temp[k] = ar[i];
			i++;
		} else {
			temp[k] = ar[j];
			j++;
			inversions+= (mid - i + 1);
		}
		k++;
	}
	while(i <= mid) {
		temp[k] = ar[i];
		k++;
		i++;
	}
	while(j <= b) {
		temp[k] = ar[j];
		k++;
		j++;
	}
	for(i = a; i <= b; i++)	ar[i] = temp[i-a];
}