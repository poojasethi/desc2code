#include<iostream>
#include<algorithm>
#include<set>
#include<cstdio>
#include<cstdlib>
#include<map>
#include<list>
#include<vector>
#include<iterator>
#include<stack>
#include<deque>
#include<queue>
#include<fstream>
#include<cmath>
#include<climits>
#include<cstring>
#include<string>
#include<iomanip>
using namespace std;
#define ll long long
#define ull unsigned ll
#define f(i,n) for(int i=0;i<n;i++)
#define fr(i,s,e) for(int i=s;i<e;i++)
#define mh(a, d) make_heap(a, a+d)
#define pushh(a, d) push_heap(a, a+d)
#define poph(a, d) pop_heap(a, a+d)
#define sh(a, d) sort(a, a+d)
#define mhm(a, d) make_heap(a, a+d, MIN_HEAP)
#define pushhm(a, d) push_heap(a, a+d, MIN_HEAP)
#define pophm(a, d) pop_heap(a, a+d, MIN_HEAP)
#define shm(a, d) sort(a, a+d, MIN_HEAP)
ll fact(int n) { ll f=1; fr(i, 1, n+1) f*=i; return f; }
ll factMOD(int n, int m) { ll f=1; fr(i, 1, n+1) { f*=i; f%=m; } return f; }
ll gcd(ll a, ll b) { ll tem; while(b) { tem=b; b=a%b; a=tem; } return a; }
ll pow(ll a, ll n) { ll res=1, cur=a; while(n) { if(n&1) res*=cur; cur*=cur; n>>=1; } return res; }
ll powMOD(ll a, ll n, ll mod) { ll res=1, cur=a; while(n) { if(n&1) { res*=cur; res%=mod; } cur*=cur; n>>=1; cur%=mod; } return res; }
void scan(int &n) { register char ch; n=0; for(ch=getchar();ch>'9'||ch<'0';ch=getchar()); for(;ch<='9'&&ch>='0';ch=getchar()) n=(n<<3)+(n<<1)+ch-'0';}
void scan(ll &n) { register char ch; n=0; for(ch=getchar();ch>'9'||ch<'0';ch=getchar()); for(;ch<='9'&&ch>='0';ch=getchar()) n=(n<<3)+(n<<1)+ch-'0';}
void scan(ull &n) { register char ch; n=0; for(ch=getchar();ch>'9'||ch<'0';ch=getchar()); for(;ch<='9'&&ch>='0';ch=getchar()) n=(n<<3)+(n<<1)+ch-'0';}
void print(int t) { printf("%d", t); }
void print(ll t) { printf("%lld", t); }
void print(ull t) { printf("%llu", t); }
void println(int t) { printf("%d\n", t); }
void println(ll t) { printf("%lld\n", t); }
void println(ull t) { printf("%llu\n", t); }
/*
void redirect() { freopen("in.in", "r", stdin); freopen("out.out", "w", stdout); }
void close() { fclose(stdin); fclose(stdout); }
*/

#define mod 1000000007

// geeksfrgeeks

ll _mergeSort(ll arr[], ll temp[], ll , ll );

ll merge(ll arr[], ll temp[], ll left, ll mid, ll right);

ll mergeSort(ll q[],ll n) {
    ll *temp = (ll *)malloc(sizeof(ll)*n);
    ll *tem = (ll *)malloc(sizeof(ll)*n);
    f(i, n) tem[i]=q[i];
    return _mergeSort(tem, temp, 0, n - 1);
}
 
ll _mergeSort(ll arr[],ll temp[],ll left,ll right) {
  ll mid, inv_count = 0;
  if (right > left)
  {
    mid = (right + left)/2;
    inv_count  = _mergeSort(arr, temp, left, mid);
    inv_count += _mergeSort(arr, temp, mid+1, right);
    inv_count += merge(arr, temp, left, mid+1, right);
  }
  return inv_count;
}
 
ll merge(ll arr[], ll temp[], ll left, ll mid, ll right) {
  ll i, j, k;
  ll inv_count = 0; 
  i = left; 
  j = mid;  
  k = left;
  while ((i <= mid - 1) && (j <= right))
  {
    if (arr[i] <= arr[j])
    {
      temp[k++] = arr[i++];
    }
    else
    {
      temp[k++] = arr[j++];
      inv_count = inv_count + (mid - i);
    }
  }
  while (i <= mid - 1)
    temp[k++] = arr[i++]; 
  while (j <= right)
    temp[k++] = arr[j++];
  for (i=left; i <= right; i++)
    arr[i] = temp[i];
  return inv_count;
}

int parity(ll p[], ll n) {
	return mergeSort(p, n)&1;
}

// geeksover
	

ll fen[100001];
ll fac[100001];


ll FR(ll q[], ll n) {
	ll rank = 1;
	
	fr(i, 0, n+1) fen[i]=0;
	
	f(i, n) 
		for(int j=q[i];j<=n;j+=(j&(-j)))
			fen[j]++;
			
	f(i, n) {
		ll sum=0;
		for(int j=q[i]-1;j>0;j-=(j&(-j)))
			sum+=fen[j];
		for(int j=q[i];j<=n;j+=(j&(-j)))
			fen[j]--;
		rank += (sum*fac[n-i-1])%(2*mod);
		rank %= (2*mod);
	}
	
	return rank;
}
	

int main() {
	bool MIN_HEAP(int, int );
 	ios::sync_with_stdio(false);
	int t;
	ll n, k;
	ll p[100001], q[100001];
	bool ans;
	fac[0]=1;
	fr(i, 1, 100001) fac[i]=(fac[i-1]*i)%(2*mod);
	scan(t);
	while(t--) {
		ans=true;
		scan(n);
		scan(k);
		f(i, n)
			scan(p[i]);
		f(i, n)
			scan(q[i]);
		if(k==n) {
			int x=p[0], rank;
			f(i, n)
				if(x==q[i])
					rank=i;
			
			f(i, n)
				if(p[i]!=q[(i+rank)%n]) {
					ans=false;
					break;
				}
			if(ans)
				cout<<q[0]<<endl;
			else
				cout<<-1<<endl;
		}
		else {
			if(k&1) {
				if(parity(p, n) != parity(q, n))
					cout<<-1<<endl;
				else
					cout<<((FR(q, n)+1)>>1)%mod<<endl;
					
			}
			else 
				cout<<FR(q, n)%mod<<endl;
		}
	}
	return 0;
}

bool MIN_HEAP(int one, int two) { return one>two; }
