#include<iostream>
#include<algorithm>
#include<set>
#include<cstdio>
#include<cstdlib>
#include<map>
#include<list>
#include<vector>
#include<iterator>
#include<stack>
#include<deque>
#include<queue>
#include<fstream>
#include<cmath>
#include<climits>
#include<cstring>
#include<string>
#include<iomanip>
using namespace std;
#define ll long long
#define ull unsigned ll
#define f(i,n) for(int i=0;i<n;i++)
#define fr(i,s,e) for(int i=s;i<e;i++)
#define mh(a, d) make_heap(a, a+d)
#define pushh(a, d) push_heap(a, a+d)
#define poph(a, d) pop_heap(a, a+d)
#define sh(a, d) sort(a, a+d)
#define mhm(a, d) make_heap(a, a+d, MIN_HEAP)
#define pushhm(a, d) push_heap(a, a+d, MIN_HEAP)
#define pophm(a, d) pop_heap(a, a+d, MIN_HEAP)
#define shm(a, d) sort(a, a+d, MIN_HEAP)
ll fact(int n) { ll f=1; fr(i, 1, n+1) f*=i; return f; }
ll factMOD(int n, int m) { ll f=1; fr(i, 1, n+1) { f*=i; f%=m; } return f; }
ll gcd(ll a, ll b) { ll tem; while(b) { tem=b; b=a%b; a=tem; } return a; }
ll pow(ll a, ll n) { ll res=1, cur=a; while(n) { if(n&1) res*=cur; cur*=cur; n>>=1; } return res; }
ll powMOD(ll a, ll n, ll mod) { ll res=1, cur=a; while(n) { if(n&1) { res*=cur; res%=mod; } cur*=cur; n>>=1; cur%=mod; } return res; }
void scan(int &n) { register char ch; n=0; for(ch=getchar();ch>'9'||ch<'0';ch=getchar()); for(;ch<='9'&&ch>='0';ch=getchar()) n=(n<<3)+(n<<1)+ch-'0';}
void scan(ll &n) { register char ch; n=0; for(ch=getchar();ch>'9'||ch<'0';ch=getchar()); for(;ch<='9'&&ch>='0';ch=getchar()) n=(n<<3)+(n<<1)+ch-'0';}
void scan(ull &n) { register char ch; n=0; for(ch=getchar();ch>'9'||ch<'0';ch=getchar()); for(;ch<='9'&&ch>='0';ch=getchar()) n=(n<<3)+(n<<1)+ch-'0';}
void print(int t) { printf("%d", t); }
void print(ll t) { printf("%lld", t); }
void print(ull t) { printf("%llu", t); }
void println(int t) { printf("%d\n", t); }
void println(ll t) { printf("%lld\n", t); }
void println(ull t) { printf("%llu\n", t); }
/*
void redirect() { freopen("in.in", "r", stdin); freopen("out.out", "w", stdout); }
void close() { fclose(stdin); fclose(stdout); }
*/

#define mod 1000000007

ll fen[100001];
ll fac[100001];
bool visit[100001];


void traverse(ll p[], ll cur) {
	while(!visit[cur]) {
		visit[cur] = true;
		cur = p[cur]-1;
	}
}
	
 
bool parity(ll p[], ll n) {
	
	ll c=0;
	
	f(i, n) visit[i]=false;
	
	f(i, n)
		if(!visit[i]) {
			c++;
			traverse(p, i);
		}
	return c&1;
}


ll FR(ll q[], ll n) {
	ll rank = 1;
	
	fr(i, 0, n+1) fen[i]=0;
	
	f(i, n) 
		for(int j=q[i];j<=n;j+=(j&(-j)))
			fen[j]++;
			
	f(i, n) {
		ll sum=0;
		for(int j=q[i]-1;j>0;j-=(j&(-j)))
			sum+=fen[j];
		for(int j=q[i];j<=n;j+=(j&(-j)))
			fen[j]--;
		rank += (sum*fac[n-i-1])%(2*mod);
		rank %= (2*mod);
	}
	
	return rank;
}
	

int main() {
	bool MIN_HEAP(int, int );
 	ios::sync_with_stdio(false);
	int t;
	ll n, k;
	ll p[100001], q[100001];
	bool ans;
	fac[0]=1;
	fr(i, 1, 100001) fac[i]=(fac[i-1]*i)%(2*mod);
	scan(t);
	while(t--) {
		ans=true;
		scan(n);
		scan(k);
		f(i, n)
			scan(p[i]);
		f(i, n)
			scan(q[i]);
		if(k==n) {
			int x=p[0], rank;
			f(i, n)
				if(x==q[i])
					rank=i;
			
			f(i, n)
				if(p[i]!=q[(i+rank)%n]) {
					ans=false;
					break;
				}
			if(ans)
				cout<<q[0]<<endl;
			else
				cout<<-1<<endl;
		}
		else {
			if(k&1) {
				if(parity(p, n) != parity(q, n))
					cout<<-1<<endl;
				else
					cout<<((FR(q, n)+1)>>1)%mod<<endl;
					
			}
			else 
				cout<<FR(q, n)%mod<<endl;
		}
	}
	return 0;
}

bool MIN_HEAP(int one, int two) { return one>two; }
