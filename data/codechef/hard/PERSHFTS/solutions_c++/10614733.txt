// #include<abhi.944>

#include<bits/stdc++.h>
using namespace std;

typedef long long int ll;
typedef double ld;

#ifndef ONLINE_JUDGE
    #define TRACE
#endif

const long double PI=3.1415926535897932384626;
const ll MAX=1000000000+7;
const int INF = 0x3f3f3f3f;

#define ps printf(" ")
#define pn printf("\n")
#define sc(n) scanf("%d",&n)
#define pf(n) printf("%d",n)
#define forall(it, x) for(__typeof((x).begin()) it=(x).begin();it!=(x).end();it++)
#define sz size()
#define ff first
#define ss second
#define pb push_back //pop_back
#define mp make_pair
#define fill(a,val) memset(a,val,sizeof(a))
#define pii pair <int ,int>

ll Nmul(ll A,ll B){ll ret = (ll)((ll)(A)*(ll)(B));return ret;}ll Mmul(ll a,ll b,ll mod){ll c=Nmul(a,b);c%=mod;while(c<0){c+=mod;};return c;}
ll Nadd(ll A,ll B){ll ret = (ll)((ll)(A)+(ll)(B));return ret;}ll Madd(ll a,ll b,ll mod){ll c=Nadd(a,b);while(c>=mod){c-=mod;};while(c<0){c+=mod;};return c;}
ll Nsub(ll A,ll B){ll ret = (ll)((ll)(A)-(ll)(B));return ret;}ll Msub(ll a,ll b,ll mod){return Madd(a,mod-b,mod);}
ll Npow(ll A,ll p){ll ret=1;while(p){if(p&1){ret=(ret*A);}A=(A*A);p>>=1;}return ret;}ll Mpow(ll a,ll n,ll b){ll res=1;while(n){if(n&1) {res=Mmul(res,a,b);}a=Mmul(a,a,b);n>>=1;}return Madd(res,0,b);}
ll Ndiv(ld A,ld B,bool ud){if(B){ld ret=(ld)(A)/(ld)(B);if(ud)return ceil(ret);return floor(ret);}return INF;}ll Mdiv(ll a,ll b,ll mod){ll ans=Mmul(a,Mpow(b,mod-2,mod),mod);return ans;}

#ifdef TRACE
    #define trace(x)            cerr<<__FUNCTION__<<":"<<__LINE__<<": ERROR---->"<<x<<endl;
    #define trace1(x)           cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<endl;
    #define trace2(x,y)         cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<" | "#y" = "<<y<<endl;
    #define trace3(x,y,z)       cerr<<__FUNCTION__<<":"<<__LINE__<<": "#x" = "<<x<<" | "#y" = "<<y<<" | "#z" = "<<z<<endl;
    #define trace4(a,b,c,d)     cerr<<__FUNCTION__<<":"<<__LINE__<<": "#a" = "<<a<<" | "#b" = "<<b<<" | "#c" = "<<c<<" | "#d" = "<<d<<endl;
#else
    #define trace(x)
    #define trace1(x)
    #define trace2(x,y)
    #define trace3(x,y,z)
    #define trace4(a,b,c,d)
#endif

#define N 100005

int a[N+1];
int b[N+1];
ll fact[N+1];

template <class type> class Fenwick {
public:
    type tree[N+1];
    int n;

    type get(int idx) {
        type sum = 0;
        while(idx) {
            sum += tree[idx];
            idx-=(idx&-idx);
        }
        return sum;
    }

    void update(int idx,type val) {
        while(idx <= n) {
            tree[idx] = Nadd(tree[idx],val);
            idx += (idx&-idx);
        }
    }

    void init(int n) {
        this->n = n;
        for(int i=0;i<=n;i++) tree[i]=0;
    }
};

Fenwick <int> fw;

void get_fact() {
    fact[0]=1;
    for(int i=1;i<N;i++) {
        fact[i] = Mmul(fact[i-1],i,MAX);
    }
}

ll get_rank(int n) {
    ll rank = 0;
    fw.init(n);
    for(int i=0;i<n;i++) {
        int idx = b[i] - fw.get(b[i]-1) - 1;
        rank = Madd(rank ,Mmul(idx, fact[n-i-1],MAX) , MAX);
        fw.update(b[i],1);
    }
    return rank;
}

bool parity(int c[],int n) {      //no of inversions
    ll cnt = 0;
    fw.init(n);
    for(int i=n-1;i>=0;i--) {
        cnt += fw.get(c[i]-1);
        fw.update(c[i],1);
    }
    bool ans = cnt&1;
    return ans;
}

int main(int argc, char const *argv[])
{
    get_fact();
    int t;
    sc(t);
    while(t--) {
        int n,k;
        sc(n); sc(k);

        for(int i=0;i<n;i++) sc(a[i]);
        for(int i=0;i<n;i++) sc(b[i]);

        if(k==n) {
            int spos;
            for(int i=0;i<n;i++) {
                if(b[i]==a[0]) {
                    spos = i;
                    break;
                }
            }
            bool flag = 1;
            for(int i=0,j=spos;i<n;i++,j++) {
                if(a[i%n]!=b[j%n]) {
                    flag = 0;
                    break;
                }
            }
            if(flag) {
                printf("%d\n",b[0]);
            }
            else puts("-1");
        }
        else if(k&1) {
            bool p = parity(a,n);
            bool q = parity(b,n);
            if(p==q) {
                ll rank = get_rank(n);
                if(b[n-2] > b[n-1]) rank--;
                rank = Mdiv(rank,2,MAX);
                printf("%lld\n",Madd(rank,1,MAX));
            }
            else {
                puts("-1");
            }
        }
        else {
            printf("%lld\n",Madd(get_rank(n),1,MAX));
        }
    }
    return 0;
}