
//~           Author : Sarvesh Mahajan                             
//               IIIT,Hyderabad                                   
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define mp make_pair
#define clr(x) x.clear()
#define For(i,a,b) for(i=a;i<b;i++)
#define loop(i,b) for(i=0;i<b;i++)
#define Loop(i,b) for(i=1;i<=b;i++)
#define pi(n) printf("%d ",n)
#define si(n) scanf("%d",&n)

#define pc putchar_unlocked
const int MOD=1e9+7;
typedef pair<int,int> PII;
typedef vector<PII> VPII;
typedef vector<int> VI;
typedef long long LL;
inline void inp(int *ar)
{
	register char c=0;
	while (c<33) c=getchar_unlocked();
	*ar=0;
	while (c>33)
	{
		*ar=*ar*10+c-'0';
		c=getchar_unlocked();
	}
}

int fre;

inline void writeInt (int n)
{
	int N = n, rev, count = 0;
	rev = N;
	if (N == 0) { pc('0'); pc('\n'); return ;}
	while ((rev % 10) == 0) { count++; rev /= 10;}
	rev = 0;
	while (N != 0) { rev = (rev<<3) + (rev<<1) + N % 10; N /= 10;}
	while (rev != 0) { pc(rev % 10 + '0'); rev /= 10;}
	while (count--) pc('0');
	pc(' ');
	return ;
}

int pending[510];
int id[250001],a[250001];
int g_f,g_val;
typedef struct node
{
	bool is_there;
    short  freq;
}node;


node tries[510][(1<<17)];  //array of tries


const int max_level=15;
int base=1<<(max_level+1);
int g_ptr;
bool g_where;
int g_level;
void insert(int id,int val)
{
	int idx=1,i;
	for(i=max_level;i>=0;--i)
	{
		int pp=(val>>i)&1;
		int val2=(idx<<1);
		if(pp == 1)
		{
			tries[id][val2+1].is_there=true;
			idx = val2+1;
		}

		else
		{
			tries[id][val2].is_there=true;
			idx=val2;
		}
	}
	tries[id][idx].freq++;
	g_f=(int)tries[id][idx].freq;
}
		
bool search(int id,int val)
{
	int idx=1,i;
	for(i=max_level;i>=0;--i)
	{
		int ll=idx<<1;
		int pp=(val>>i)&1;
		if(pp)
		{
			if(tries[id][ll+1].is_there == false)
				return false;
			idx=ll+1;
		}
		else
		{
			if(tries[id][ll].is_there == false)
				return false;
			idx=ll;
		}
	}

	return true;
}




int find_min(int id,int data) 
{
	int idx=1,i;
	for(i=max_level;i>=0;--i)
	{
	    int val=idx<<1;
		int pp=(data>>i)&1;
		if(pp)
		{
		if(tries[id][val+1].is_there == true)
		idx=val+1;
		else if(tries[id][val].is_there == true)
		idx=val;
		else
			exit(0);
		}

		else
		{
			if(tries[id][val].is_there == true)
				idx=val;
			else if(tries[id][val+1].is_there == true)
				idx=val+1;
			else
				exit(0);
		}
	}
	g_f=(int)tries[id][idx].freq;
	return idx-base;
}


void dele(int id,int data)
{
	int i;
	int idx=1;
	int level=max_level;

	for(i=max_level;i>=0;--i)
	{
		int val=(idx<<1);
		int pp=(data>>i)&1;
		if(pp == 1)
		{
			

			
			if(tries[id][val].is_there == true)
			{
			g_ptr=idx;
			g_where=1;
			level=i;
			}
			idx=val+1;
		}

		else
		{
			if(tries[id][val+1].is_there == true)
			{
				g_ptr=idx;
				g_where=0;
				level=i;

			}
			idx=val;
		}
	}

	if(tries[id][idx].freq > 1)
		tries[id][idx].freq --;
	else
	{
		    tries[id][idx].freq=0;
	     	idx=g_ptr;
			for(i=level;i>=0;--i)
			{
				int pp=(data>>i)&1;
				if(pp == 0)
				{
				tries[id][idx<<1].is_there=false;
				idx=idx<<1;
				}
		    	else
				{
				tries[id][(idx<<1)+1].is_there=false;
				idx=(idx<<1)+1;
				}
			}

	}
	

}

int main()
{

int n,t,m,l,k,ans,i,j,res=0,fl,q;
si(n);
si(q);
loop(i,n)
	si(a[i]);
l=sqrt(n);

/*loop(i,l+5)
{
	loop(j,(1<<17)+10000)
	{
		tries[i][j].is_there=false;
		tries[i][j].freq=0;
	}
}*/

int left=0;
int right=min(l,n);
int ct=0;
fre=0;

while(1)
{
ct++;
for(i=left;i<right;++i)
{
	id[i]=ct;
    insert(ct,a[i]);
}


left=right;
right=min(n,right+l);

if(left == n)
	break;
}

id[n]=ct+1;

int type,L,R,K;
while(q--)
{
	bool ans;
	si(type);
	si(L);
	si(R);
	L--;R--;
	if(type == 2)
	{
		
		si(K);
		int lo=id[L];
		i=L;
		while(id[i] == lo && i<=R)
		{
			
			g_where=0;
			g_ptr=1;

			dele(id[i],a[i]);

			a[i]^=K;
			insert(id[i],a[i]);
			

			++i;
		}

		if(i>R)
         continue;
		
		i=id[R];
		j=lo+1;
		while(j<i)
		{
			pending[j]^=K;
			j++;
		}

		for(i=R;id[i]>j-1;--i)
		{
			g_ptr=1;
			g_where=0;

			dele(id[i],a[i]);
			a[i]^=K;
			insert(id[i],a[i]);
		}



			
	}

	else
	{
		int pp,mini,current_val,freq=0;
		int curr_id=id[L];
		mini=pending[curr_id]^a[L];
		for(j=L;id[j]==curr_id && j<=R;++j)
		{
			pp=a[j]^pending[curr_id];
			if(pp < mini)
			{
				mini=pp;
				freq=1;
			}

			else if(mini == pp)
				freq++;
			
		}



		if(j>R)
		{
			pi(mini);
			printf("%d",freq);
			puts("");
			continue;
		}


		i=id[R];
		j=curr_id+1;
		while(j<i)
		{
			g_val=find_min(j,pending[j]);
			current_val=g_val^pending[j];

			if(current_val<mini)
			{
				mini=current_val;
				freq=g_f;
			}

			else if(current_val == mini)
			{
				freq+=g_f;
			}
			++j;
		}

		for(i=R;id[i]>j-1;--i)
		{
			int ll=a[i]^pending[id[i]];
			if(ll < mini)
			{
				mini=ll;
				freq=1;
			}
			else if( ll == mini)
			{
				freq++;
			}
		}
		pi(mini);
		printf("%d",freq);
		puts("");
	}


}


return 0;
}
