#include <iostream>
#include <ctime>
#include <fstream>
#include <cmath>
#include <cstring>
#include <cassert>
#include <cstdio>
#include <algorithm>
#include <iomanip>
#include <vector>
#include <stack>
#include <queue>
#include <set>
#include <map>
#include <complex>
#include <utility>
#include <cctype>
#include <list>

using namespace std;

#define FORALL(i,a,b) for(int i=(a);i<=(b);++i)
#define FOR(i,n) for(int i=0;i<(n);++i)
#define FORB(i,a,b) for(int i=(a);i>=(b);--i)

typedef long long ll;
typedef long double ld;
typedef complex<ld> vec;

typedef int num;

typedef pair<num,int> pii;
typedef map<int,int> mii;

#define pb push_back
#define mp make_pair

#define MAXN 250010
#define INF 65535

#define PW 15

// a trie on bits
// can support (flip i^th bit) operation (using "lazy" propagation)
struct trie {
	trie *L, *R;	// children (if any)
	num cnt;	// total number of items in this tree
	num flip;	// the bit-mask saying which bits should be flipped
	char pw;		// the corresponding power of 2 (starts at 16 (2^16))
	pii min_elem;
	
	trie() { L = R = NULL; cnt = flip = 0; pw = PW; min_elem.first = INF; }
	
	void insert(num v) {
		min_elem.first = INF;
		for(trie* x = this;;) {
			++x->cnt;
			if (x->pw<0) return;
			else if ((v & (1<<x->pw)) == (flip & (1<<x->pw))){ 
				if (!x->L) x->L = new trie(), x->L->pw = x->pw-1;
				x = x->L;
			} else {
				if (!x->R) x->R = new trie(), x->R->pw = x->pw-1;
				x = x->R;
			}
			
		}
	}
	
	void remove(num v) {
		min_elem.first = INF;
		for(trie* x = this;;) {
			--x->cnt;
			if (x->pw<0) return;
			else if ((v & (1<<x->pw)) == (flip & (1<<x->pw))) x = x->L;
			else x = x->R;
		}
	}
	
	//void remove(int v) { min_elem.first = INF; update(v,-1); }
	void flip_bits(num k) {	min_elem.first = INF; flip ^= k;}
	
	pii get_min() {	// return the smallest element in the trie (traverse the bits)
		if (min_elem.first < INF) return min_elem;
		min_elem.first = min_elem.second = 0;
		for(trie* x = this;;) {
			if (x->pw<0) return (min_elem.second = x->cnt), min_elem;
			else if (flip&(1<<x->pw)) {
				if (x->R && x->R->cnt > 0) x = x->R;
				else min_elem.first += (1<<(x->pw)), x = x->L;
			} else {
				if (x->L && x->L->cnt > 0) x = x->L;
				else min_elem.first += (1<<(x->pw)), x = x->R;
			}
		}
	}
};

int t1,t2;
pii t3;
#define check1(a,v,t) { t1 = (v); t2 = (t); \
	if ((a).first > t1) (a).first = t1, (a).second = t2; \
	else if ((a).first == t1) (a).second += t2; \
	}

#define check(a,b) {t3 = (b); check1(a,t3.first, t3.second); }

// square root decomposition data structure
#define BIN_SIZE 300
#define NUM_BINS (((MAXN+BIN_SIZE-1)/BIN_SIZE)+5)
#define bin(i) (((i)-1)/BIN_SIZE)
#define pos(i) (((i)-1)%BIN_SIZE)
#define left(b) (BIN_SIZE*(b) + 1)
#define right(b) (left(b+1) - 1)

#define flip(b,k) (B[b].flip_bits((k)), xors[b] ^= ((k)))
struct sqrt_t {
	trie B[NUM_BINS];		// the bins (they are tries here)
	num xors[NUM_BINS];		// keep track of xor's that happened to the bin
						//	 since we assume the trie simply applies them
						//	 and it won't perform any "translations" for us
	num* A;
	
	// 1-indexed initialization
	void init(num* A_, int N) {
		A = A_;
		FORALL(i,1,N) B[bin(i)].insert(A[i]);
	}
	
	// xor everything in A[l..r] by k in O(sqrt(N)) time
	void update(int l, int r, num k) {
		int low_bin = bin(l);	// check the boundaries
		int high_bin = bin(r);
		int rb,lb,old_v,new_v;
		
		// update complete bins
		FORALL(b,low_bin+1, high_bin-1) flip(b,k);
		
		// lower boundary bin (must do items individually)
		rb = min(r, right(low_bin));		// needed if only one bin
		FORALL(i,l,rb) {
			old_v = A[i]^xors[low_bin];
			new_v = old_v^k;
			B[low_bin].remove(old_v);
			B[low_bin].insert(new_v);
			A[i] ^= k;	// need to actually store this since the trie won't know
		}
		
		// upper boundary bin (must do items individually)
		if (high_bin > low_bin) {
			lb = max(l, left(high_bin));		// needed if only one bin
			FORALL(i,lb,r) {
				old_v = A[i]^xors[high_bin];	// the actual current value of this item
				new_v = old_v^k;
				B[high_bin].remove(old_v);
				B[high_bin].insert(new_v);
				A[i] ^= k;
			}
		}
	}
	
	// compute the minimum element in O(sqrt(N)) time
	pii get_min(int l, int r) {
		int low_bin = bin(l);	// check the boundaries
		int high_bin = bin(r);
		
		// update complete bins
		pii ans(INF,0);
		FORALL(b,low_bin+1, high_bin-1) check(ans,B[b].get_min());

		// lower boundary bin (must check items individually)
		int rb = min(r, right(low_bin));	// needed if only one bin
		FORALL(i,l,rb) check1(ans,A[i]^xors[low_bin],1);

		// upper boundary bin (must do items individually)
		if (high_bin > low_bin) {
			int lb = max(l, left(high_bin));	// needed if only one bin
			FORALL(i,lb,r) check1(ans, A[i]^xors[high_bin], 1);
		}
		
		assert(ans.first < INF && ans.second >= 1);
		return ans;
	}
};

sqrt_t T;
num A[MAXN];

int main_() {
	srand(time(NULL));
	int N = 250000, Q = 50000;
	FORALL(i,1,N) A[i] = rand()%65536;
	T.init(A,N);

	int t,l,r,k=0;
	FOR(q,Q) {
		t = rand()%5+1, l = rand()%N + 1, r = rand()%N + 1;
		if (l>r) swap(l,r);
		if (t<=1) t = 2;
		else t = 1;
		
		if (t==1) {
			pii ans = T.get_min(l,r);
			printf("%d %d\n", ans.first, ans.second);
		} else {
			k = rand()%65536;
			T.update(l,r,k);
		}
		//printf("%d %d %d %d\n", t, l ,r , k);
	}
	return 0;
}

int main() {
	int N,Q;
	cin >> N >> Q;
	int x;
	FORALL(i,1,N) scanf("%d",&x), A[i] = x;
	T.init(A,N);
	
	int t,l,r,k;
	FOR(q,Q) {
		scanf("%d%d%d",&t,&l,&r);
		if (t==1) {
			pii ans = T.get_min(l,r);
			printf("%d %d\n", ans.first, ans.second);
		} else {
			scanf("%d",&k);
			T.update(l,r,k);
		}
	}
	
	return 0;
}
