#include<bits/stdc++.h>

#define rep(i,n) for(int i=0;i<(int)n;i++)
#define all(c) (c).begin(),(c).end()
#define mp make_pair
#define pb push_back
#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)
#define dbg(x) cerr<<__LINE__<<": "<<#x<<" = "<<(x)<<endl

using namespace std;

typedef long long ll;
typedef vector<int> vi;
typedef pair<int,int> pi;
const int inf = (int)1e9;
const double INF = 1e12, EPS = 1e-9;

#define F first
#define S second

const int N = 250000;
const int M = 500;

int child[N*16*10][2], value[N*16*10], trie_sz = 1;
inline int node(){
	assert(trie_sz + 1 < N*16*10);
	return trie_sz++;
}

int n, q, a[N];
int root[M], sum[M];
pi mn[M];

inline void add(int &r, int v, int x, int pos = 15){
	if(!r) r = node();
	value[r] += x;
	if(pos < 0) return;
	
	add(child[r][v >> pos & 1], v, x, pos - 1);
}
inline pi get(int r, int s, int ans = 0, int pos = 15){
	if(pos < 0) return mp(ans, value[r]);
	rep(ii, 2){
		int i = ii ^ (s >> pos & 1);
		if(child[r][i] && value[child[r][i]]) return get(child[r][i], s, ans * 2 + ii, pos - 1);
	}
	assert(0);
}

int main(){
	
	scanf("%d%d", &n, &q);
	rep(i, n) scanf("%d", a + i);
	
	rep(i, M) mn[i] = mp(inf, 0);
	rep(i, n){
		add(root[i / M], a[i], 1);
		if(mn[i / M].F > a[i]) mn[i / M] = mp(a[i], 0);
		if(mn[i / M].F == a[i]) mn[i / M].S++;
	}
	//rep(i, n) cerr<<mn[i/M].F<<" "<<mn[i/M].S<<" : "<<i<<endl;
	
	while(q--){
		int type, l, r, x;
		scanf("%d%d%d", &type, &l, &r);
		l--;
		
		if(type == 1){
			pi ans = mp(inf, 0);
			while(l % M && l < r){
				if(ans.F > (a[l] ^ sum[l / M])) ans = mp(a[l] ^ sum[l / M], 0);
				if(ans.F == (a[l] ^ sum[l / M])) ans.S++;
				l++;
			}
			while(r % M && l < r){
				r--;
				if(ans.F > (a[r] ^ sum[r / M])) ans = mp(a[r] ^ sum[r / M], 0);
				if(ans.F == (a[r] ^ sum[r / M])) ans.S++;
			}
			l /= M; r /= M;
			while(l < r){
				if(ans.F > mn[l].F) ans = mp(mn[l].F, 0);
				if(ans.F == mn[l].F) ans.S += mn[l].S;
				l++;
			}
			
			printf("%d %d\n", ans.F, ans.S);
		}
		else{
			scanf("%d", &x);
			while(l % M && l < r){
				add(root[l / M], a[l], -1); a[l] ^= x;
				add(root[l / M], a[l], 1);
				l++;
				
				if(l % M == 0) mn[l / M - 1] = get(root[l / M - 1], sum[l / M - 1]);
			}
			while(r % M && l < r){
				r--;
				add(root[r / M], a[r], -1); a[r] ^= x;
				add(root[r / M], a[r], 1);
				
				if(r % M == 0) mn[r / M] = get(root[r / M], sum[r / M]);
			}
			l /= M; r /= M;
			while(l < r){
				sum[l] ^= x;
				mn[l] = get(root[l], sum[l]);
				l++;
			}
		}
	}
	
	return 0;
}