
//~           Author : Sarvesh Mahajan                             
//               IIIT,Hyderabad                                   
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define mp make_pair
#define clr(x) x.clear()
#define For(i,a,b) for(i=a;i<b;i++)
#define loop(i,b) for(i=0;i<b;i++)
#define Loop(i,b) for(i=1;i<=b;i++)
#define pi(n) printf("%d ",n)
#define si(n) scanf("%d",&n)

#define pc putchar_unlocked
const int MOD=1e9+7;
typedef pair<int,int> PII;
typedef vector<PII> VPII;
typedef vector<int> VI;
typedef long long LL;
inline void inp(int *ar)
{
	register char c=0;
	while (c<33) c=getchar_unlocked();
	*ar=0;
	while (c>33)
	{
		*ar=*ar*10+c-'0';
		c=getchar_unlocked();
	}
}

int fre;

inline void writeInt (int n)
{
	int N = n, rev, count = 0;
	rev = N;
	if (N == 0) { pc('0'); pc('\n'); return ;}
	while ((rev % 10) == 0) { count++; rev /= 10;}
	rev = 0;
	while (N != 0) { rev = (rev<<3) + (rev<<1) + N % 10; N /= 10;}
	while (rev != 0) { pc(rev % 10 + '0'); rev /= 10;}
	while (count--) pc('0');
	pc(' ');
	return ;
}

int pending[1000];
int id[250001],a[250001];
int g_f,g_val;
typedef struct node
{
	bool is_there;
//	int data; //used only for leaves
	int freq;
}node;


node tries[510][(1<<17)+10000];  //array of tries

//node arr[maxn];

const int max_level=15;
int base=1<<(max_level+1);
int g_ptr;
bool g_where;
int g_level;
void insert(int id,int val)
{
	int idx=1,i;
	for(i=max_level;i>=0;--i)
	{
		int pp=(val>>i)&1;
		int val2=(idx<<1);
		if(pp == 1)
		{
			tries[id][val2+1].is_there=true;
			idx = val2+1;
		}

		else
		{
			tries[id][val2].is_there=true;
			idx=val2;
		}
	}
//	tries[id][idx].data=val;
	tries[id][idx].freq++;
	g_f=tries[id][idx].freq;
//	pi(idx);
}
		
bool search(int id,int val)
{
	int idx=1,i;
	for(i=max_level;i>=0;--i)
	{
		int ll=idx<<1;
		int pp=(val>>i)&1;
		if(pp)
		{
			if(tries[id][ll+1].is_there == false)
				return false;
			idx=ll+1;
		}
		else
		{
			if(tries[id][ll].is_there == false)
				return false;
			idx=ll;
		}
	}

	return true;
}




int find_min(int id,int data) 
{
	int idx=1,i;
	for(i=max_level;i>=0;--i)
	{
	    int val=idx<<1;
		int pp=(data>>i)&1;
		if(pp)
		{
		if(tries[id][val+1].is_there == true)
		idx=val+1;
		else if(tries[id][val].is_there == true)
		idx=val;
		else
			exit(0);
		}

		else
		{
			if(tries[id][val].is_there == true)
				idx=val;
			else if(tries[id][val+1].is_there == true)
				idx=val+1;
			else
				exit(0);
		}
	}
	g_f=tries[id][idx].freq;
	return idx-base;
}


void dele(int id,int data)
{
	int i;
	int idx=1;
	int level=max_level;

	for(i=max_level;i>=0;--i)
	{
		int val=(idx<<1);
		int pp=(data>>i)&1;
		if(pp == 1)
		{
			

			
			if(tries[id][val].is_there == true)
			{
			g_ptr=idx;
			g_where=1;
			level=i;
			}
			idx=val+1;
		}

		else
		{
			if(tries[id][val+1].is_there == true)
			{
				g_ptr=idx;
				g_where=0;
				level=i;

			}
			idx=val;
		}
	}
	//puts("Delete INDEX");
	//pi(idx);
	//puts("");

	if(tries[id][idx].freq > 1)
		tries[id][idx].freq --;
	else
	{
		    tries[id][idx].freq=0;
	     	idx=g_ptr;
			for(i=level;i>=0;--i)
			{
				int pp=(data>>i)&1;
				if(pp == 0)
				{
				tries[id][idx<<1].is_there=false;
				idx=idx<<1;
				}
		    	else
				{
				tries[id][(idx<<1)+1].is_there=false;
				idx=(idx<<1)+1;
				}
			}

	}

	

	//pi(tmp->data);
	

}


	
/*node *my_del(node *root,int data,int level)
{
	g_ptr=root;
	g_level=max_level;
	g_where=0;
	return dele(root,data);
}
*/
/*bool search(node *root,int data,int level)
{
	if(level == -1)
		return true;
	if(root == NULL)
		return false;
	int pp=(data>>level)&1;
	if(pp)
		return search(root->right,data,level-1);
	else
		return search(root->left,data,level-1);
}
*/	

int main()
{

int n,t,m,l,k,ans,i,j,res=0,fl,q;
si(n);
si(q);
loop(i,n)
	si(a[i]);
l=sqrt(n);

loop(i,l+5)
{
	loop(j,(1<<17)+10000)
	{
		tries[i][j].is_there=false;
		tries[i][j].freq=0;
	}
}

int left=0;
int right=min(l,n);
int ct=0;
fre=0;

//puts("M");
//insert(1,0);
//insert(1,65535);
//dele(1,1);
//puts("\n Over");
while(1)
{
ct++;
for(i=left;i<right;++i)
{
	id[i]=ct;
    insert(ct,a[i]);
//	printf("Inserted %d in block %d, freq = %d\n",a[i],ct,g_f); //Correct
	bool ans=search(ct,a[i]);
/*	if(ans)
		puts("YES");
	else
		puts("NO");*/
	//pi(g_f);
}


left=right;
right=min(n,right+l);

if(left == n)
	break;
}

id[n]=ct+1;
/*loop(i,n)
	pi(id[i]);*/
//puts("CT");
//pi(ct);
//puts("");

int type,L,R,K;
while(q--)
{
	bool ans;
	si(type);
	si(L);
	si(R);
	L--;R--;
	if(type == 2)
	{
		
		si(K);
		int lo=id[L];
		i=L;
		while(id[i] == lo && i<=R)
		{
			
	        /*ans=search(id[i],a[i]);
         	if(ans)
	    	puts("YES");
	        else
	      	puts("NO");*/
			//print(tries[id[i]],5);
			g_where=0;
			g_ptr=1;

			dele(id[i],a[i]);
		//	printf("Deleted %d in block %d \n",a[i],id[i]);

			//print(tries[id[i]],5);
	       /*ans=search(id[i],a[i]);
            if(ans)
	    	puts("YES");
	        else
	      	puts("NO");*/
			//For testing only 
			a[i]^=K;
			insert(id[i],a[i]);
		//	printf("Inserted %d in block %d and freq = %d\n",a[i],id[i],g_f);
			
	      /* ans=search(id[i],a[i]);
         	if(ans)
	    	puts("YES");
	        else
	      	puts("NO");*/

			++i;
		}

		if(i>R)
         continue;
		
		i=id[R];
		j=lo+1;
		while(j<i)
		{
			pending[j]^=K;
			j++;
		}

		for(i=R;id[i]>j-1;--i)
		{
			g_ptr=1;
			g_where=0;

			dele(id[i],a[i]);
			a[i]^=K;
			insert(id[i],a[i]);
		}

		/*loop(i,n)
			pi(a[i]^pending[id[i]]);
		puts("");*/


			
	}

	else
	{
		int pp,mini,current_val,freq=0;
		int curr_id=id[L];
		mini=pending[curr_id]^a[L];
//		printf("J on entry : %d\n",L);
		for(j=L;id[j]==curr_id && j<=R;++j)
		{
			pp=a[j]^pending[curr_id];
//			printf("For j=%d Value=%d\n",j,pp);
			if(pp < mini)
			{
				mini=pp;
				freq=1;
			}

			else if(mini == pp)
				freq++;
			
		}

		/*printf("J on exit : %d\n",j);
		puts("RES");*/
			//pi(mini);
			//pi(freq);
			//puts("");


		if(j>R)
		{
			pi(mini);
			printf("%d",freq);
			puts("");
			continue;
		}


		i=id[R];
		j=curr_id+1;
		while(j<i)
		{
			g_val=find_min(j,pending[j]);
			//puts("Value got");
			//pi(g_val);
			current_val=g_val^pending[j];

			//printf("Value for block %d = %d\n",j,current_val);
			//printf("Freq for this block = %d\n",g_f);
			if(current_val<mini)
			{
				mini=current_val;
				freq=g_f;
			}

			else if(current_val == mini)
			{
				freq+=g_f;
			}
			++j;
		}

		for(i=R;id[i]>j-1;--i)
		{
			int ll=a[i]^pending[id[i]];
			if(ll < mini)
			{
				mini=ll;
				freq=1;
			}
			else if( ll == mini)
			{
				freq++;
			}
		}
		pi(mini);
		printf("%d",freq);
		puts("");
	}


}

//loop(i,n)
//	pi(id[i]);

return 0;
}
