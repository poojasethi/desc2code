#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <set>
#include <map>
#include <vector>
#include <string>
#include <cmath>
#include <cstring>
#include <queue>
#include <stack>
#include <algorithm>
using namespace std;

const int inf = int(1e9);

struct columntree {
	int t[1050];
	int N, depth;
	void init(int n) {
		for (N = 1, depth = 0; N < n; N <<= 1, ++depth);
		
		for (int i = 1; i < N + N; ++i)
			t[i] = inf;
	}
	
	void update(int u, int d) {
		while (u >= 1) {
			t[u] = min(t[u], d);
			u >>= 1;
		}
	}
	
	int get(int v, int l, int r, int d = 100) {
		if (d == 100) {
			d = depth;
			l += N;
			r += N;
		}
		int ll = (v << d);
		int rr = ll + (1 << d) - 1;
		
		if (l > rr || r < ll) return inf;
		if (ll == l && r == rr) return t[v];
		
		int res = inf;
		int m = (ll + rr) / 2;
		if (l <= m)
			res = get(v * 2, l, min(m, r), d - 1);
		if (r >= m)
			res = min(res, get(v * 2 + 1, max(l, m + 1), r, d - 1));
			
		return res;						
		
	}
};

struct rowtree {	
	columntree t[1050];
	int N, depth;
	void init(int n, int m) {
		for (N = 1, depth = 0; N < n; N <<= 1, ++depth);
		
		for (int i = 1; i < N + N; ++i)
			t[i].init(m);
	}
	
	int get(int v, int l, int r, int x1, int x2, int d = 100) {
		if (d == 100) {
			d = depth;
			l += N;
			r += N;
		}

		int ll = (v << d);
		int rr = ll + (1 << d) - 1;
		
		//printf("%d %d %d %d %d\n", v, ll, rr, l, r);
		if (l > rr || r < ll) return inf;
		if (ll == l && r == rr) return t[v].get(1, x1, x2); //modify
		
		int res = inf;
		int m = (ll + rr) / 2;
		if (l <= m)
			res = get(v * 2, l, min(m, r), x1, x2, d - 1);
		if (r >= m)
			res = min(res, get(v * 2 + 1, max(l, m + 1), r, x1, x2, d - 1));
			
		return res;						
	}
	
	void update(int u, int x, int d) {
		//printf("%d %d %d\n", u - N, x, d);
		while (u >= 1) {
			t[u].update(t[u].N + x, d);	
			u >>= 1;
		}		
	}  	
} tree;

struct point {
	int x, y, d;
	void create(int xx, int yy) {
		x = xx;
		y = yy;
		d = x * x + y * y;
	}
	bool operator < (const point &z) const {
		return d < z.d;
	}
} a[250000];

int n, m, d, N;

int Res[501][501];
int cur[250000];
int grid[501][501];

int main() {
	int tests, i, j, k, l, R, C;
	scanf("%d", &tests);
	while (tests--) {
	 	scanf("%d%d%d%d%d", &n, &m, &d, &R, &C);
	 	N = 0;
	 	for (i = 0; i < n; ++i)
	 		for (j = 0; j < m; ++j) {
	 			scanf("%d", &grid[i][j]);
	 			a[N++].create(i, j);
	 		}
		sort(a, a + N);	 		
		
		tree.init(n, m);
		
		Res[0][0] = grid[0][0];			
		tree.update(tree.N + 0, 0, grid[0][0]);
						
		for (j = 1; j < N; j = l) {
			for (l = j + 1; l < N && a[l].d == a[j].d; ++l);
			
			for (k = j; k < l; ++k) {
				cur[k] = tree.get(1, max(a[k].x - d, 0), min(a[k].x + d, n - 1), max(a[k].y - d, 0), min(a[k].y + d, m - 1));			
			}
			
			for (k = j; k < l; ++k) {
				Res[a[k].x][a[k].y] = cur[k] + grid[a[k].x][a[k].y];
				tree.update(tree.N + a[k].x, a[k].y, Res[a[k].x][a[k].y]);
			}					
			
		}			 		
		
		printf("%d\n", Res[R][C]);	
	}
	return 0;
}

