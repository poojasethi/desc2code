#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <cmath>
using namespace std;
 
#define lo long long
	
#define FIO_BUF_SIZE 65536
//--------------------- fast input
class FastIn {
	int poi, avail;
	char buf[FIO_BUF_SIZE];
	
	private:
		bool read();
	public:
		FastIn();
		char getChar();
		template <typename I> I getNum();
};
 
			FastIn::FastIn() {
				poi = avail = 0;
			}
 
			bool FastIn::read() {
				if (poi >= avail) {
					poi=0;
					avail = fread(buf, 1, FIO_BUF_SIZE, stdin);
					return avail > 0;
				}
				return true;
			}
 
			// fetch next char
			char FastIn::getChar() {
				if (!read()) return '?';
				return buf[poi++];
			}
 
			// fetch next int or long long
			template <typename I>
			I FastIn::getNum() {
				I re=0;
				bool dg=0, mi=0;
				while(1) {
					if (!read()) break;
					char c=buf[poi++];
					if (c>='0' && c<='9') {
						dg = 1;
						re = re*10 + c - '0';
					} else if (c=='-') {
						if (mi) return -3; // two minuses
						if (dg) return -4; // minus after digits
						mi = dg = 1;
					} else if (dg) break;   // whitespace after number, else whitestpace before number
				}
				return mi?-re:re;
			}
 
//--------------------------------------- output ----------------
class FastOut {
	int poi;
	char buf[FIO_BUF_SIZE], rev_buf[32];
	
	private:
		void reqSpace(int sz);
	
	public:
		FastOut();
		~FastOut();
		void flush();
		void putChar(char c);
		template <typename I> void putNum(I i, bool space_after);
		void putStr(char *p, int sz);
};
 
			// require cnt chars at buffer for next operation
			void FastOut::reqSpace(int cnt) {
				if (poi+cnt+3 > FIO_BUF_SIZE) flush();
			}
 
			FastOut::FastOut() {
				poi = 0;
			}
			
			FastOut::~FastOut() {
				flush();
			}
 
			// flush buffers
			void FastOut::flush() {
				if (poi) {
					fwrite(buf, 1, poi, stdout);
					poi=0;
				}
			}
 
			// output one char
			void FastOut::putChar(char c) {
				reqSpace(1);
				buf[poi++]=c;
			}
 
			// output int or long long
			template <typename I>
			void FastOut::putNum(I i, bool space_after = true) {
				reqSpace(32);
				int op=0, mi=0;
				
				if (i<0) { mi=1; i=-i; }	
				do {
					rev_buf[op++] = i%10 + '0';
					i /= 10;
				} while (i);
				if (mi) rev_buf[op++] = '-';
				
				while (op)
					buf[poi++]=rev_buf[--op];
				if (space_after)
					buf[poi++]=' ';
			}
 
			// output string
			void FastOut::putStr(char* str, int sz) {
				reqSpace(sz);
				for (int i=0; i<sz; i++)
					buf[poi++]=str[i];
			}
//------------------------------------- stupid libs eof ---------

int ntc;
int R,C,D,rs,cs, rof,cof;
int w[502][502], a[502][502], m[1025][1025];

struct Point {
	int r,c, di2;
	Point(int r0, int c0) {
		r=r0;
		c=c0;
		di2=r*r+c*c;
	}
};

bool operator<(const Point &a, const Point &b) {
	return a.di2<b.di2;
}

vector<Point> points;

void setmin(const Point &p, int v) {
	//printf("   set(%d,%d)=%d\n", p.r, p.c, v);
	int r=rof+p.r, c=cof+p.c;
	while (r) {
		int c0=c;
		while (c0) {
			m[r][c0] = min(m[r][c0],v);
			c0/=2;
		}
		r/=2;
	}
}

int getmin(const Point &p) {
	int r0=rof+max(0,p.r-D), r1=rof+min(R-1,p.r+D),
		c0=cof+max(0,p.c-D), c1=cof+min(C-1,p.c+D),
		rez=1<<29;
	while (r0<=r1) {
		int c2=c0, c3=c1;
		while (c2<=c3) {
			if (r0%2==1) {
				if (c2%2==1) rez=min(rez,m[r0][c2]);
				if (c3%2==0) rez=min(rez,m[r0][c3]);
			}
			if (r1%2==0) {
				if (c2%2==1) rez=min(rez,m[r1][c2]);
				if (c3%2==0) rez=min(rez,m[r1][c3]);
			}
			c2 = (c2+1)/2;
			c3 = (c3-1)/2;
		}
		r0 = (r0+1)/2;
		r1 = (r1-1)/2;
	}
	//printf("   get(%d,%d): %d\n", p.r, p.c, rez);
	return rez;
}

main() {
	FastIn fi;
	ntc=fi.getNum<int>();
	
	while (ntc--) {
		R=fi.getNum<int>();
		C=fi.getNum<int>();
		D=fi.getNum<int>();
		rs=fi.getNum<int>();
		cs=fi.getNum<int>();
		
		rof=1; while (rof<R) rof*=2;
		cof=1; while (cof<C) cof*=2;
		
		for (int r=0; r<rof*2; r++)
			for (int c=0; c<cof*2; c++)
				m[r][c]=1<<29;
		
		points.clear();
		for (int r=0; r<R; r++)
			for (int c=0; c<C; c++) {
				w[r][c]=fi.getNum<int>();
				points.push_back(Point(r,c));
			}
			
		sort(points.begin(),points.end());
		
		int dpr2=-1, ipr=2;
		setmin(points[0], a[0][0]=0);
		for (int i=1; i<points.size(); i++) {
			Point p=points[i];
			if (p.di2>dpr2) {
				for (int j=ipr; j<i; j++) {
					Point e=points[j];
					setmin(e, a[e.r][e.c]);
				}
				dpr2=p.di2;
				ipr=i;
			}
			a[p.r][p.c] = w[p.r][p.c] + getmin(p);
		}
		
		printf("%d\n", a[rs][cs]);
	}
} 
