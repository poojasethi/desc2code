#include <cstdio>
#include <cassert>
#include <cstring>
#include <ctime>
#include <cstdlib>
#include <vector>
#include <iostream>
#include <algorithm>

using namespace std;

#define N 500
#define LOGN 9

int tests,n,m,logn,logm;
int x[N][N], f[N][N];
int r0,c0,d;

int onBoard(int r, int c) {
	return 0<=r && r<n && 0<=c && c<m;
}

void update(int &ff, int v) {
	if (ff==-1) ff=v;
	else if (v!=-1 && v<ff) ff=v;
}

int tree[LOGN+1][N][LOGN+1][N];

void updateTreeX(int t[LOGN+1][N], int x, int v, int lev=0) {
	if (lev<=logm) {
		update(t[lev][x],v);
		updateTreeX(t, x/2, v, lev+1);
	}
}

void updateTreeYX(int t[LOGN+1][N][LOGN+1][N], int y, int x, int v, int lev=0) {
	if (lev<=logn) {
		updateTreeX(t[lev][y], x, v);
		updateTreeYX(t, y/2, x, v, lev+1);
	}
}

int y1, y2, x1, x2;

int queryTreeX(int t[LOGN+1][N], int lev=logm, int id=0) {
	int m=id*(1<<lev), M=(id+1)*(1<<lev)-1;
	if (x2<m || M<x1) return -1;
	else if (x1<=m && M<=x2) return t[lev][id];

	int r1=queryTreeX(t, lev-1, id*2);
	int r2=queryTreeX(t, lev-1, id*2+1);
	update(r1,r2);
	return r1;
}

int queryTreeYX(int t[LOGN+1][N][LOGN+1][N], int lev=logn, int id=0) {
	int m=id*(1<<lev), M=(id+1)*(1<<lev)-1;
	if (y2<m || M<y1) return -1;
	else if (y1<=m && M<=y2) return queryTreeX(t[lev][id]);

	int r1=queryTreeYX(t, lev-1, id*2);
	int r2=queryTreeYX(t, lev-1, id*2+1);
	update(r1,r2);
	return r1;
}

int main() {
	scanf("%d",&tests); assert(tests<=10);
	int sum=0;
	while (tests--) {
		scanf("%d %d",&n,&m); assert(n<=500 && m<=500);
		logn=0; logm=0;
		for (int i=1;i<n;i*=2,logn++);
		for (int i=1;i<m;i*=2,logm++);
		sum+=n*m;
		scanf("%d %d %d",&d,&r0,&c0);
		vector<pair<int,pair<int,int > > > v;
		for (int i=0;i<n;i++) for (int j=0;j<m;j++) {
			scanf("%d",&x[i][j]); assert(x[i][j]<=10000);
			v.push_back(make_pair(i*i+j*j,make_pair(i,j)));
		}
		assert(x[0][0]==0);
		sort(v.begin(),v.end());

		memset(f,-1,sizeof(f));
		//memset(tree,-1,sizeof(tree));
		for (int iy=0;iy<=logn;iy++) for (int jy=0;jy<(1<<(logn-iy));jy++) {
			for (int ix=0;ix<=logm;ix++) for (int jx=0;jx<(1<<(logm-ix));jx++) tree[iy][jy][ix][jx]=-1;
		}

		f[0][0]=0;
		updateTreeYX(tree,0,0,0);
		int i,j;
		for (i=1;i<v.size();i=j) {
			for (j=i;j<v.size() && v[i].first==v[j].first;j++) {
				int r=v[j].second.first, c=v[j].second.second;
				y1=max(0,r-d); y2=min(n-1,r+d); x1=max(0,c-d); x2=min(m-1,c+d);
				f[r][c]=queryTreeYX(tree)+x[r][c];
			}
			for (j=i;j<v.size() && v[i].first==v[j].first;j++) {
				int r=v[j].second.first, c=v[j].second.second;
				updateTreeYX(tree,r,c,f[r][c]);
			}
		}
		printf("%d\n",f[r0][c0]);
	}
	assert(sum<=250000);
    return 0;
}