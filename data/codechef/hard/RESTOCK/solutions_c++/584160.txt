#include <algorithm>
#include <string>
#include <vector>
#include <queue>
#include <iostream>
#include <cmath>
#include <sstream>
#include <map>
#include <set>
#include <numeric>
#include <complex>
#include <stdio.h>
#include <memory.h>

using namespace std;

#define pb push_back
#define INF 1011111111
#define L(s) (int)((s).size())
#define FOR(i,a,b) for (int _n(b), i(a); i < _n; i++)
#define rep(i,n) FOR(i,0,n)
#define ford(i,a,b) for(int i=(a),_b=(b);i>=_b;--i)
#define CL(a,v) memset((a),(v),sizeof(a))
#define ll long long
#define VI vector<int>
#define mp make_pair
#define X first
#define Y second
#define all(c) (c).begin(), (c).end()
#define SORT(c) sort(all(c))

typedef pair<int,int> pii;

int cost[1024][1024];
pii points[500*500];
int dp[500][500];

inline int norm(const pii &a)
{
    return a.X*a.X + a.Y*a.Y;
}

inline bool cmp(const pii &a, const pii &b)
{
    return norm(a) < norm(b);
}

struct Problem
{
    // two dimensional tree

    void build_y(int vx, int lx, int rx, int vy, int ly, int ry)
    {
        if(ly == ry)
        {
            if(lx == rx)
            {
                cost[vx][vy] = lx<500 && ly<500 ? dp[lx][ly] : INF;
            }
            else
            {
                cost[vx][vy] = min( cost[2*vx][vy], cost[2*vx+1][vy] );
            }
        }
        else
        {
            int my = (ly + ry)/2;

            build_y(vx, lx, rx, 2*vy, ly, my);
            build_y(vx, lx, rx, 2*vy+1, my+1, ry);

            cost[vx][vy] = min(cost[vx][2*vy], cost[vx][2*vy+1]);
        }
    }


    void build_x(int vx, int lx, int rx)
    {
        if(lx != rx)
        {
            int mx = (lx + rx)/2;

            build_x(vx*2, lx, mx);
            build_x(vx*2+1, mx+1, rx);
        }

        build_y(vx, lx, rx, 1, 0, M-1);
    }

    int min_y (int vx, int vy, int t_ly, int t_ry, int ly, int ry)
    {
        if(ly > ry) return INF;
        if(t_ly > t_ry) return INF;

        if(ly == t_ly && ry == t_ry)  return cost[vx][vy];

        int tmy = (t_ly + t_ry) / 2;

        return min( min_y(vx, vy*2, t_ly, tmy, ly, min(ry, tmy)), min_y(vx, vy*2+1, tmy+1, t_ry, max(ly,tmy+1), ry) );
    }

    int min_x(int vx, int tlx, int trx, int lx, int rx, int ly, int ry)
    {
        if(lx > rx) return INF;
        if(tlx > trx) return INF;

        if( lx == tlx && rx == trx )
            return min_y(vx, 1, 0, M-1, ly, ry);

        int tmx = (tlx + trx) / 2;

        return min( min_x(2*vx, tlx, tmx, lx, min(rx, tmx), ly, ry) , min_x(2*vx+1, tmx+1, trx, max(tmx+1, lx), rx, ly, ry) );
    }

    void update_y(int vx, int lx, int rx, int vy, int ly, int ry, int x, int y, int val)
    {
        if(ly == ry)
        {
            if(lx == rx)
            {
                cost[vx][vy] = min(cost[vx][vy], val);
            }
            else
                cost[vx][vy] = min(cost[vx*2][vy], cost[vx*2+1][vy]);
        }
        else
        {
            int my = ( ly + ry )/2;

            if( y <= my)
            {
                update_y (vx, lx, rx, vy*2, ly, my, x, y, val);
            }
            else
            {
                update_y (vx, lx, rx, vy*2+1, my+1, ry, x, y, val);
            }

            cost[vx][vy] = min(cost[vx][vy*2], cost[vx][vy*2+1]);
        }
    }

    void update_x(int vx, int lx, int rx, int x, int y, int val)
    {
        if(lx != rx)
        {
            int mx = (lx + rx)/2;

            if(x <= mx)
            {
                update_x(vx*2, lx, mx, x, y, val);
            }
            else
            {
                update_x(vx*2+1, mx+1, rx, x, y, val);
            }
        }

        update_y(vx, lx, rx, 1, 0, M-1, x, y, val);
    }

    void update( int x, int y, int val) { update_x(1, 0, N-1, x, y, val ); }

    int query(int x, int y) { return min_x(1, 0, N-1, x, x, y, y); }

    int query(int x1, int x2, int y1, int y2) { return min_x(1, 0, N-1, x1, x2, y1, y2); }

    //----------

    int N,M,D,R,C;
    int w[500][500];

    Problem()
    {
        cin >> N >> M >> D >> R >> C;

        rep(i,N) rep(j,M) scanf("%d ", &w[i][j]);
    }

    int solve()
    {
        rep(i,500) rep(j,500) dp[i][j] = INF;
        dp[0][0] = 0;

        build_x(1, 0, N-1);

//        rep(i, N)
//        {
//            rep(j, M) cout << query( i, j ) << ' ';
//            cout << endl;
//        }
//        cout << endl;
//
//        return 0;

        int sz = 0;

        rep(i,N) rep(j,M) points[sz++] = mp(i,j);
        sort(points, points + sz, cmp);

        int curr = 0;

        rep(i,sz)
        {
            if( cmp(points[curr], points[i]) )
            {
                for(; curr < i ; ++curr)
                {
//                    const int x1 = points[curr].X - D;
//                    const int y1 = points[curr].Y - D;
//                    const int x2 = points[curr].X + D;
//                    const int y2 = points[curr].Y + D;

                    const int x = points[curr].X;
                    const int y = points[curr].Y;

                    //for( int x = max(0,x1); x < min(N,x2+1); ++x)
                        //for( int y = max(0,y1); y < min(M,y2+1); ++y)
                        {
                            //dp[x][y] = min(dp[x][y], dp[points[curr].X][points[curr].Y]);

                            update(x, y, dp[points[curr].X][points[curr].Y]);
                        }
                }
            }

//            rep(i, N)
//            {
//                rep(j, M) cout << query( i, j ) << ' ';
//                cout << endl;
//            }
//            cout << endl;

            //dp[points[i].X][points[i].Y] = cost[points[i].X][points[i].Y]; there must be query

            {
                const int x1 = max(points[i].X - D, 0);
                const int y1 = max(points[i].Y - D, 0);
                const int x2 = min(points[i].X + D, N-1);
                const int y2 = min(points[i].Y + D, M-1);

                //dp[points[i].X][points[i].Y] = query( points[i].X, points[i].Y );
                dp[points[i].X][points[i].Y] = query( x1, x2, y1, y2 );
            }

            if(dp[points[i].X][points[i].Y] < INF) dp[points[i].X][points[i].Y] += w[points[i].X][points[i].Y];

            if(points[i].X == R && points[i].Y == C) break;
        }

        return dp[R][C];
    }
};


int main()
{
//	#ifndef ONLINE_JUDGE
        //freopen("input.txt","r",stdin);
        //freopen("output.txt","w", stdout);
//	#endif

    int T;

    cin >> T;

    while(T--) cout << Problem().solve() << endl;

	return 0;
}
