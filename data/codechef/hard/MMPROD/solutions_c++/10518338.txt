#include<bits/stdc++.h>
using namespace std;


#define MEM(a,N,b) fill(a,(a+N),b)
#define FORN(i, n) for(i = 0; i < n; i++)
#define FORAB(i, a, b) for(i = a; i <= b; i++)
#define FORR(i,n) for(i=n-1;i>=0;--i)
#define elif else if
#define mp make_pair
#define pb push_back
#define ff first
#define ss second
#define all(x) (x).begin(),(x).end()
#define rall(x) (x).rbegin(),(x).rend()
#define sll(x) scanf("%lld",&x)
#define sl(x)  scanf("%ld",&x)
#define sd(x)  scanf("%d",&x)
#define pi(x)  printf("%d",x)
#define pl(x)  printf("%ld",x)
#define pll(x) printf("%lld",x)
#define nl     printf("\n")
#define sp     printf(" ")
typedef pair<int,int> PII;
typedef pair<double, double> PDD;
typedef pair<int,long> PIL;
typedef pair<long,int> PLI;
typedef pair<int,long long> PILL;
typedef pair<long long,int> PLLI;
typedef pair<long,long> PLL;
typedef pair<long long,long long> PLLLL;
typedef pair<double,PIL> PDPIL;
typedef vector<int> VI;
typedef vector<long> VL;
typedef vector<double> VD;
typedef vector<long double> VLD;
typedef vector<long long> VLL;
typedef vector<VI> VVI;
typedef vector<VL> VVL;
typedef vector<VLL> VVLL;
typedef vector<PII > VPII;
typedef vector<PLL > VPLL;
typedef vector<PIL> VPIL;
typedef vector<PLI > VPLI;
typedef vector<PILL> VPILL;
typedef vector<PLLI> VPLLI;
typedef vector<PLLLL> VPLLLL;
typedef vector<VPLL> VVPLL;
typedef vector<PDPIL> VPDPIL;
#define ll long long
#define l long
#define MIN(a,b) ((a) < (b) ? (a) : (b))
#define MAX(a,b) ((a) > (b) ? (a) : (b))
#define ABS(x)   ((x) < 0 ? (-1)*(x) : (x))
#define Pi 3.1415926535897
#define MOD 1000000007
#define coolreshab ios::sync_with_stdio(false);//cin.tie(NULL)


/*freopen("test.txt","r",stdin);
  freopen("out.txt","w",stdout);*/

ll fast_exp(ll a, ll b,ll mod)
{
    ll x=1,y=a;
    while(b > 0)
    {
        if(b%2 == 1)
        {
            if(x>=mod) x%=mod;
            x=(x*y);
            if(x>=mod) x%=mod;
        }
        if(y>=mod) y%=mod;
        y = (y*y);
        if(y>=mod) y%=mod;

        b /= 2;
    }
    return x;
}

ll modcheck(ll n,ll mod)
{
	while(n<0)
		n+=mod;
	if(n>=mod)
		n%=mod;
	return n;
}
ll modinverse(ll N,ll mod)
 {
     return fast_exp(N,mod-2,mod);
 }


VPLLI arr;
VLL neg;
main()
 { l T,N,K,i,np1,pp1,np2,pp2;
   int flag1,flag2;
   //coolreshab;
  /*freopen("test.txt","r",stdin);
  freopen("out.txt","w",stdout);*/
   sl(T);
   ll ans,x,inv;
   while(T--)

      {   ans=1;
          x=0;
          np1=pp1=np2=pp2=-1;
          sl(N);
          sl(K);
          arr.resize(N);
          FORN(i,N)
          {
              sll(arr[i].ff);
              if(arr[i].ff<0)
                {
                    arr[i].ss=0;
                    neg.pb(arr[i].ff);
                }//0= negative
              else
                arr[i].ss=1;//1=+
             arr[i].ff=ABS(arr[i].ff);
             //cout<<arr[i].ss<<endl;

          }
          sort(rall(arr));
          sort(rall(neg));
          pp1=np1=-1;
          ans=1;
          x=0;
          FORN(i,K)
          {
              ans*=arr[i].ff;
              if(ans>=MOD)
                ans%=MOD;
              if(arr[i].ss==0)
                {
                    np1=i;
                    ++x;
                }
              else
                pp1=i;
          }
         // cout<<ans<<endl;
          flag1=flag2=0;
          np2=pp2=-1;
          if(x%2!=0)
          {
              for(;i<N;++i)
              {
                  if(flag1 and flag2)
                    break;
                  if(arr[i].ss==0 and flag1==0)
                    {
                        np2=i;
                        flag1=1;
                    }
                  elif(arr[i].ss==1 and flag2==0)
                  {
                      pp2=i;
                      flag2=1;
                  }
              }
              if(np1!=-1 and pp2!=-1 and pp1!=-1 and np2!=-1)
              {
                  if(arr[np1].ff *1LL * arr[np2].ff < arr[pp1].ff * 1LL * arr[pp2].ff)
                  {
                      inv=modinverse(arr[np1].ff,MOD);
                      ans= (ans * inv)%MOD;
                      ans= (ans * arr[pp2].ff)%MOD;
                  }
                  else
                  {
                      inv=modinverse(arr[pp1].ff,MOD);
                      ans= (ans * inv)%MOD;
                      ans= (ans * arr[np2].ff)%MOD;
                  }
              }
             elif((np1!=-1 and pp2!=-1 ) or (pp1!=-1 and np2!=-1))
             {
                 if(np1!=-1 and pp2!=-1)
                 {
                      inv=modinverse(arr[np1].ff,MOD);
                      ans= (ans * inv)%MOD;
                      ans= (ans * arr[pp2].ff)%MOD;
                 }
                 else
                 {
                     inv=modinverse(arr[pp1].ff,MOD);
                     ans= (ans * inv)%MOD;
                     ans= (ans * arr[np2].ff)%MOD;
                 }
             }
             else
             {
                 if(K!=N)
                  {
                     ans=1;
                     FORN(i,K)
                     {
                         ans*=neg[i];
                         ans%=MOD;
                         ans=modcheck(ans,MOD);
                     }
                  }
                  else
                  {
                      ans=(ans%MOD * -1%MOD)%MOD;
                      ans=modcheck(ans,MOD);
                  }
             }


          }

          pll(ans);
          nl;
          arr.clear();
          neg.clear();


      }
 }
