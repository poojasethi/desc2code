#include<bits/stdc++.h>
using namespace std;
int b[100003];

long long int inverse_modulo(long long int x,long long int y,long long int p){
	long long int res=1;
	while(y>0){
		if(y&1)
		res=(res*x)%p;
		
		y=y>>1;
		x=(x*x)%p;
	}
	return res;
}
 
/* Function to merge the two haves arr[l..m] and arr[m+1..r] of array arr[] */
void merge(long long int arr[], int l, int m, int r)
{
    int i, j, k;
    int n1 = m - l + 1;
    int n2 =  r - m;
 
    /* create temp arrays */
    long long int L1[n1], R1[n2];
    int l2[n1],r2[n2];
    /* Copy data to temp arrays L[] and R[] */
    for (i = 0; i < n1; i++)
       {
     L1[i] = arr[l + i];
     l2[i]=b[l+i];}
     
    for (j = 0; j < n2; j++)
        {
		R1[j] = arr[m + 1+ j];
		r2[j]=b[m+1+j];
       }
    /* Merge the temp arrays back into arr[l..r]*/
    i = 0;
    j = 0;
    k = l;
    while (i < n1 && j < n2)
    {
        if (L1[i] <= R1[j])
        {    b[k]=l2[i];  
            arr[k] = L1[i];
            i++;
        }
        else
        {
            arr[k] = R1[j];
            b[k]=r2[j];
            j++;
        }
        k++;
    }
 
    /* Copy the remaining elements of L[], if there are any */
    while (i < n1)
    {   b[k]=l2[i];
        arr[k] = L1[i];
        i++;
        k++;
    }
 
    /* Copy the remaining elements of R[], if there are any */
    while (j < n2)
    {     b[k]=r2[j];
        arr[k] = R1[j];
        j++;
        k++;
    }
}
void mergeSort(long long int arr[], int l, int r)
{
   if (l < r)
   {
      int m = l+(r-l)/2; //Same as (l+r)/2 but avoids overflow for large l & h
      mergeSort(arr, l, m);
      mergeSort(arr, m+1, r);
      merge(arr, l, m, r);
   }
}
int main(){
	int t;
	cin>>t;
	while(t--){
		int n,k;
		cin>>n>>k;
		long long int  a[n];
		
		for(int i=0;i<n;i++){
			cin>>a[i];
			if(a[i]<0){
				a[i]=-1*a[i];          //storing abs value of a[i]
				b[i]=-1;              // b[i] would track whether the element is negative or not 
			}
			else{
				b[i]=1;
			}
		}
		int c=pow(10,9)+6;
		int t=pow(10,9)+7;
		mergeSort( a,0,n-1);
	   long long int product=1;
	   int product1=1;
	   
	   for(int i=n-1;i>=n-k;i--)
	   {product1*=b[i];
	   	if(b[i]==-1){
	   		product=(((product*c)%t)*a[i])%t;
		   }
		   else
		   product=(product*a[i])%t;
	   }
	   if(product1==1)
	   cout<<product<<endl;
	   else{
	   	bool flag1=false,flag2=false,flag3=false,flag4=false;
	   	long long int p,q,r,s;
	   	for(int i=n-k;i<n;i++){
	   		if(b[i]==-1)
	   		{p=a[i]; 
			   flag1=true;                // first negative term in last k elemnts
	   		break;	   			
			   }
		   }
		   for(int i=n-k;i<n;i++){
		   	if(b[i]==1){
		   		q=a[i];   
				   flag2=true;         // first positive element in last k elemnts 
		   		break;
			   }
		   }
		   for(int i=n-k-1;i>=0;i--){
		   	if(b[i]==-1){
		   		r=a[i];       
				   flag3=true;      //last negative
		   		break;
			   }
		   }
		   for(int i=n-k-1;i>=0;i--){
		   	if(b[i]==1){
		   		flag4=true;
				s=a[i];                 //last positive element 
		   		break;
			   }
		   }
		   
		   
		   if(flag1==true && flag2==true && flag3==true && flag4==true)
		   {
		   float c,d;
		   c=(float)s/p;
		   d=(float)r/q;
		   
		   
		   if(c>d)
		   	{     
			   product=(((((product*s)%t)*(t-1)%t)%t)*inverse_modulo(p,t-2,t)%t)%t;
		}
		   	else
		   	product=((((product*r)%t*(t-1))%t)*inverse_modulo(q,t-2,t))%t;  
	     }
	     else if(flag1==true && flag4==true){
		 
	       product=(((((product*s)%t)*(t-1)%t)%t)*inverse_modulo(p,t-2,t)%t)%t;}
	      else if(flag2==true && flag3==true)
	      product=((((product*r)%t*(t-1))%t)*inverse_modulo(q,t-2,t))%t;
	      else{
	      	product=1;
	      	for(int i=0;i<k;i++){
	      		if(b[i]==-1){
	   		product=(((product*c)%t)*a[i])%t;
		   }
		   else
		   product=(product*a[i])%t;
	   }
	   
			  }
			  cout<<product<<endl;
		  }
		   
	   }
		
	
	
	return 0;
}