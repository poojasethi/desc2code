/*
 * $File: meanmedi.cpp
 * $Date: Tue Jul 26 23:55:02 2011 +0800
 * $Author: jiakai <jia.kai66@gmail.com>
 */
#define INPUT	"meanmedi.in"
#define OUTPUT	"meanmedi.out"

// f{{{ 

#include <stdint.h>
#include <algorithm>
#include <bitset>
#include <cmath>
#include <cassert>
#include <cctype>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <deque>
#include <functional>
#include <iomanip>
#include <iostream>
#include <list>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <utility>
#include <vector>
#include <limits>

#define ITER_VECTOR(v, var) \
	for (typeof((v).begin()) var = (v).begin(); var != (v).end(); var ++)

#define ITER_VECTOR_IDX(v, var) \
	for (typeof((v).size()) var = 0; var < (v).size(); var ++)

using namespace std;

// f}}}

namespace Solve
{
	const int SEQLEN_MAX = 65,
		  VAL_MAX = 1205,
		  SUM_MAX = SEQLEN_MAX * VAL_MAX,
		  INF = 1 << 30;

	struct Knapsack
	{
		struct Seg
		{
			int low, high;
		};
		struct Node
		{
			Seg *seg;
			int nseg;
			void add(int l, int h);
		};
		class Iterator
		{
			protected:
				Seg *cur, *begin, *end;
			public:
				Iterator(const Node &n);
				int val;
				inline bool is_valid() const;
				void move_next();
				void move_prev();
		};
		class Reverse_iterator : public Iterator
		{
			public:
				Reverse_iterator(const Node &n);
		};
		Node cap[SEQLEN_MAX];
		void work(const int *seq, int seqlen, int nchosen);
	};
	Knapsack npsk_front, npsk_end;

	int calc_min_diff(int len_front, int len_end, int tgt);

	double work(int *seq, int seqlen, int nchosen);
	void solve(FILE *fin, FILE *fout);
}

void Solve::solve(FILE *fin, FILE *fout)
{
	static int seq[SEQLEN_MAX];
	int ncase;
	fscanf(fin, "%d", &ncase);
	while (ncase --)
	{
		int seqlen, nch;
		fscanf(fin, "%d%d", &seqlen, &nch);
		for (int i = 0; i < seqlen; i ++)
			fscanf(fin, "%d", &seq[i]);
		fprintf(fout, "%.3lf\n", work(seq, seqlen, nch));
	}
}

double Solve::work(int *seq, int seqlen, int nchosen)
{
	if (nchosen == 1)
		return 0;
	sort(seq, seq + seqlen);
	if (nchosen == 2)
	{
		int ans = INF;
		for (int i = 1; i < seqlen; i ++)
			ans = min(ans, seq[i] - seq[i - 1]);
		return ans * 0.5;
	}
	int len0 = (nchosen + 1) / 2 - 1,
		len1 = nchosen - 1 - len0;
	npsk_front.work(seq, seqlen, len0);
	static int seq_rev[SEQLEN_MAX];
	reverse_copy(seq, seq + seqlen, seq_rev);
	npsk_end.work(seq_rev, seqlen, len1);
	int ans = INF;
	for (int i = 0; i < seqlen; i ++)
		ans = min(ans, calc_min_diff(i, seqlen - 1 - i, seq[i] * (nchosen - 1)));
	return double(ans) / nchosen;
}

int Solve::calc_min_diff(int len_front, int len_end, int tgt)
{
	Knapsack::Iterator i(npsk_front.cap[len_front - 1]);
	Knapsack::Reverse_iterator j(npsk_end.cap[len_end - 1]);
	if (!i.is_valid() || !j.is_valid())
		return INF;
	int ans = INF;
	while (i.is_valid())
	{
		while (j.is_valid() && i.val + j.val > tgt)
			j.move_prev();
		if (j.is_valid())
			ans = min(ans, tgt - (i.val + j.val));
		j.move_next();
		if (j.is_valid())
			ans = min(ans, i.val + j.val - tgt);
		else j.move_prev();
		i.move_next();
	}
	return ans;
}

void Solve::Knapsack::work(const int *seq, int seqlen, int nchosen)
{
	typedef uint32_t Mask_t;
	assert(nchosen < 32);
	struct Dp_node
	{
		int sum;
		Mask_t mask;
		// mask[i]: whether the sum can be achieved by choosing i numbers
	};
	memset(cap, 0, sizeof(cap));
	static Dp_node f[2][SUM_MAX];
	int nf[2];
	nf[0] = 1;
	f[0][0].sum = 0;
	f[0][0].mask = 1;
	for (int cur = 0, i = 0; i < seqlen; i ++)
	{
		assert(seq[i] >= 0);
		int prev = cur;
		cur ^= 1;
		int nfp = nf[prev];
		Dp_node *p1 = f[prev], *p2 = p1,
				*p2_end = p2 + nfp,
				*pt = f[cur];
		p1[nfp].sum = SUM_MAX + 1;
		int s_prev = -2, s_start = -2;
		while (p2 != p2_end)
		{
			int s = min(p1->sum, p2->sum + seq[i]);
			pt->sum = s;
			Mask_t m = 0;
			if (p1->sum == s)
				m |= (p1 ++)->mask;
			if (p2->sum + seq[i] == s)
				m |= (p2 ++)->mask << 1;
			pt->mask = m;
			if ((m >> nchosen) & 1)
			{
				if  (s != s_prev + 1)
				{
					if (s_prev != -2)
						cap[i].add(s_start, s_prev);
					s_start = s;
				}
				s_prev = s;
			}
			pt ++;
		}
		if (s_prev != -2)
			cap[i].add(s_start, s_prev);
		nf[cur] = pt - f[cur];
	}
}

void Solve::Knapsack::Node::add(int l, int h)
{
	static const int MEMSIZE_MAX = SEQLEN_MAX * SUM_MAX;
	static Seg mem[MEMSIZE_MAX];
	static int memsize = 0;
	Seg *ptr = mem + (memsize ++);
	assert(memsize <= MEMSIZE_MAX);
	ptr->low = l;
	ptr->high = h;
	nseg ++;
	if (nseg == 1)
		seg = ptr;
}

Solve::Knapsack::Iterator::Iterator(const Node &n) :
	cur(n.seg), begin(n.seg), end(n.seg + n.nseg)
{
	if (is_valid())
		val = cur->low;
}

Solve::Knapsack::Reverse_iterator::Reverse_iterator(const Node &n) :
	Iterator(n)
{
	cur = n.seg + n.nseg - 1;
	if (is_valid())
		val = cur->high;
}

bool Solve::Knapsack::Iterator::is_valid() const
{
	return cur >= begin && cur < end;
}

void Solve::Knapsack::Iterator::move_next()
{
	if (cur == begin - 1)
	{
		cur = begin;
		assert(is_valid());
		val = cur->low;
		return;
	}
	assert(is_valid());
	if (val == cur->high)
	{
		cur ++;
		if (is_valid())
			val = cur->low;
	} else val ++;
}

void Solve::Knapsack::Iterator::move_prev()
{
	if (cur == end)
	{
		cur = end - 1;
		assert(is_valid());
		val = cur->high;
		return;
	}
	assert(is_valid());
	if (val == cur->low)
	{
		cur --;
		if (is_valid())
			val = cur->high;
	} else val --;
}

// f{{{ main
int main()
{
#if defined(INPUT) && defined(OUTPUT) && !defined(STDIO) && !defined(ONLINE_JUDGE)
	FILE *fin = fopen(INPUT, "r"),
		 *fout = fopen(OUTPUT, "w");
	Solve::solve(fin, fout);
	fclose(fin);
	fclose(fout);
#else
	Solve::solve(stdin, stdout);
#endif
}
// f}}}
// vim: filetype=cpp foldmethod=marker foldmarker=f{{{,f}}}
