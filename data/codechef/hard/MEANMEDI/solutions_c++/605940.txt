#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <utility>
#include <string>
#include <fstream>
#include <map>
#include <set>
#include <queue>
#include <memory.h>

using namespace std;

typedef vector<int> VI;
typedef pair<int, int> PI;
typedef vector<PI> VPI;

#define FOR(i,a,n) for (int i = (a); i < (n); ++i)
#define FORE(i,a,n) for (int i = (a); i <= (n); ++i)
#define FORD(i,a,b) for (int i = (a); i >= (b); --i)
#define REP(i,n) FOR(i,0,n)
#define REPE(i,n) FORE(i,0,n)
#define LL long long
#define FIR(n) REP(i,n)
#define FJR(n) REP(j,n)
#define ALL(v) v.begin(), v.end()

#define FI FIR(n)
#define FJ FJR(n)
#define FR(i,a) FOR(i,a,n)
#define REPN(i) REP(i,n)

#define GI(n) scanf("%d", &n)
#define GI2(n,m) scanf("%d %d", &n, &m)

#define BOUND 72010

char fq[33][BOUND];
char f1[63][BOUND];
char f2[63][BOUND];

int n, K;
int z[70];

void fill_mask(VI s, int K, char cp[][BOUND] ) {
	int upp[50] = {};
	memset(fq, 0, sizeof fq);
	fq[0][0] = 1;
	FIR(s.size()) {
		int add = s[i];
		FORD(cnt, min(i, K-1), 0) {

			char* cur = fq[cnt], *next = fq[cnt+1];
			FORE(sum, 0, upp[cnt]) if (cur[sum])
				next[sum + add ] =1;

			upp[cnt+1] = max(upp[cnt+1], add + upp[cnt]);
		}

		memcpy(cp[i], fq[K], sizeof fq[0]);
	}
}

int closest(VI& l, VI& r, int want) {
	if (l.empty() || r.empty()) return 1000000000;
	int rp = r.size() - 1, lp = 0;
	r.push_back(1000000);
	l.push_back(1000000);
	while (rp > 0 && r[rp] + l[0] > want) --rp;
	int best = min(abs(r[rp] + l[0] - want), abs(r[rp+1]+l[0] - want));
	
	lp = 1;
	for (; rp>=0; --rp) {
		while(r[rp] + l[lp] < want) ++lp;
		best = min(best, abs((r[rp] + l[lp] - want)));
		best = min(best, abs((r[rp] + l[lp-1] - want)));
	}

	return best;

}

double solve() {
	GI2(n, K); FI GI(z[i]);
	sort(z, z+n);

	if (K == 1) return 0;
	
	int lefter = (K-1)/2, righter = K/2;

	VI v;
	for(int i = 0;i + K/2 < n; ++i) v.push_back(z[i]);
	fill_mask(v, lefter, f1);
	v.clear();
	for(int i = n-1 ;i >= K/2; --i)
		v.push_back(z[i]);
	fill_mask(v, righter, f2);

	
	VI vleft, vright;


	int res = 1000000000;

	for(int x= lefter; x + righter < n; ++x) {
		vleft.clear(); vright.clear();
		if(lefter == 0) {
			vleft.push_back(z[x]);
		} else {
			FIR(BOUND) if (f1[x-1][i])
				vleft.push_back(i+z[x]);
		}

		FIR(BOUND) if (f2[n-2-x][i])
			vright.push_back(i);

		res = 
			min(res, closest(vleft, vright, K*z[x]));
	}


	return res / (double)K;
}


int main() {
#ifndef ONLINE_JUDGE
freopen("input.txt", "rt", stdin);
#endif

	int tc; GI(tc);
	while (tc--) {
		double res = solve();
		printf("%.3lf\n", res);
	}

}

