#include <algorithm>
#include <bitset>
#include <cassert>
#include <climits>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <iterator>
#include <limits>
#include <map>
#include <numeric>
#include <queue>
#include <set>
#include <sstream>
#include <stack>
#include <string>
#include <utility>
#include <vector>
using namespace std;


/* Prewritten code begins */
#define REP(i,n)    for(int i=0; i<(n); ++i)
#define SCI(x)      scanf("%d",&x)
#define FILL(a,v)   memset(a,v,sizeof(a))
#define FORD(i,a,b) for(int i=(a); i>=(b); --i)
#define FOR(i,a,b)  for(int i=(a); i<=(b); ++i)
/* Prewritten code ends */

const int maxN = 61;
int sums[2][maxN*1201], p[32];
int mx[2];
int a[maxN];
#define F(x,y) y |= (x)<<1
int main() {
	REP(i,32) p[i] = 1<<i;
	int T, N, K;
	SCI(T);
	while(T--) {
		SCI(N); SCI(K);
		REP(i,N) SCI(a[i]);
		sort(a,a+N);
		if(K == 1) {
			printf("0.000\n");
			continue;
		} else if(K == 2) {
			double mn = numeric_limits<double>::max();
			REP(i,N-1) mn = min(mn, fabs(a[i]-(a[i]+a[i+1])/2.));
			printf("%.3lf\n", mn);
			continue;
		}
		int left = (K-1)/2, right = K-1-left, res = INT_MAX, lim;
	   	REP(i,N) if(i >= left && N-1-i >= right) {
			FILL(mx,0); 
			
			lim = accumulate(a+i-left,a+i,0);
			memset(sums[0],0,(lim+1)*sizeof(int)); sums[0][0] = p[0];

			REP(j,i) {
				FORD(k,mx[0],0) if(sums[0][k]) {
					F(sums[0][k],sums[0][k+a[j]]);
				}
				mx[0] = min(lim, mx[0]+a[j]);
			}

			lim = accumulate(a+N-right,a+N,0);
			memset(sums[1],0,(lim+1)*sizeof(int)); sums[1][0] = p[0];
			FOR(j,i+1,N-1) {
				FORD(k,mx[1],0) if(sums[1][k]) {
					F(sums[1][k],sums[1][k+a[j]]);
				}
				mx[1] = min(lim, mx[1]+a[j]);
			}

			int it1 = 0, it2 = mx[1];
			while(it1 <= mx[0] && it2 >= 0) {
				if(!(sums[0][it1] & p[left]) ) it1++;
				else if(!(sums[1][it2] & p[right])) it2--;
				else {
					int t = abs(K*a[i]-(it1+it2+a[i]));
					if(t < res) res = t;
					if((K-1)*a[i] < it1+it2) it2--; else it1++;
				}
			}
		}	
		printf("%.3lf\n", 1.*res/K);

	}
	return 0;
}
