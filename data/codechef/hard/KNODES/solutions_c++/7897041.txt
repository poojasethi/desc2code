#include<bits/stdc++.h>
using namespace std;
#define MAXN 100006
#define MAXLOG 30
vector < vector < int > > Edges(MAXN);
pair <int, int> dfstime[MAXN];
int LCA[MAXN][MAXLOG];
int Parent[MAXN];
int Level[MAXN];
bool vis[MAXN];
int Time, LG;
void dfs(int node, int level)
{
    vis[node] = true;
    Level[node] = level;
    int i, now, s = Time++;
    for (i=0; i<Edges[node].size(); ++i)
    {
        now = Edges[node][i];
        if (!vis[now])
        {
            Parent[now] = node;
            dfs(now, level+1);
        }
    }
    dfstime[node] = make_pair(s,Time++);
}
int calc(int l)
{
    int i;
    for (i=0; (1<<i)<=l; ++i); --i;
    return i;
}
void printLCA(int N)
{
    int i,j;
    for (i=1; i<=N; ++i)
    {
        for (j=0; j<=LG; ++j) printf("(%d) ",LCA[i][j]);
        puts("");
    }
}
void buildLCA(int N)
{
    int i,j;
    for (i=1; i<=N; ++i)
    {
        for (j=0; j<=LG; ++j) LCA[i][j] = -1;
    }
    for (i=1; i<=N; ++i) LCA[i][0] = Parent[i];
    for (j=1; j<=LG; ++j)
    {
        for (i=1; i<=N; ++i)
        {
            if (LCA[i][j-1] != -1) LCA[i][j] = LCA[LCA[i][j-1]][j-1];
        }
    }
}
int findLCA(int u, int v)
{
    if (u==v) return u;
    if (Level[u]<Level[v]) swap(u,v);
    int i,j;
    for (j=LG; j>=0; --j)
    {
        if (LCA[u][j] == -1) continue;
        if (Level[LCA[u][j]] >= Level[v]) u = LCA[u][j];
    }
    if (u==v) return u;
    for (j=LG; j>=0; --j)
    {
        if (LCA[u][j] != -1 && LCA[u][j] != LCA[v][j]) u = LCA[u][j], v = LCA[v][j];
    }
    return LCA[u][0];
}
void prepare(int N)
{
    memset(vis, false, sizeof(vis));
    Time = 1;
    dfs(1,1);
    int i, maxlevel=-1;
    Parent[1] = -1;
    for (i=1; i<=N; ++i)
    {
        if (Level[i] > maxlevel) maxlevel = Level[i];
    }
    LG = calc(maxlevel);
}
bool cmp(int a, int b)
{
    return Level[a] > Level[b];
}
bool ancestor(int u, int v)
{
    return (dfstime[u].first <= dfstime[v].first && dfstime[v].second <= dfstime[u].second);
}
void run(int N)
{
    int T, u,v,l, i,x;
    vector < int > V;
    scanf("%d", &T);
    while (T--)
    {
        scanf("%d", &v);
        V.push_back(v);
    }
    sort (V.begin(), V.end(), cmp);
    u = V[0], v = -1;
    for (i=1; i<V.size(); ++i)
    {
        x = V[i];
        if (ancestor(x,u))
        {
            if (v != -1)
            {
                l = findLCA(u,v);
                if (Level[l] > Level[x]) break;
            }
            u = x;
        }
        else if (v == -1) v = x;
        else
        {
            if (ancestor(x,v))
            {
                l = findLCA(u,v);
                if (Level[l] <= Level[x]) v = x;
                else break;
            }
            else break;
            v = x;
        }
        if (v != -1 && Level[u] > Level[v]) swap(u,v);
    }
    if (i == V.size()) puts("Yes");
    else puts("No");
}
int main()
{
    int T,N,Q,i;
    int ans;
    int x,y,c=1;
    scanf("%d", &T);
    while(T--)
    {
        scanf("%d", &N);
        for (i=1; i<=N; ++i) Edges[i].clear();
        for (i=1; i<N; ++i)
        {
            //scanf("%d %d %d", &x, &y, &c);
            scanf("%d %d", &x, &y);
            Edges[x].push_back(y);
            Edges[y].push_back(x);
        }
        prepare(N);
        buildLCA(N);
        scanf("%d", &Q);
        while (Q--) run(N);
    }
    return 0;
}
