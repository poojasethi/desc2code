#include <bits/stdc++.h>

using namespace std;

const int maxn = 100100;

vector<int> graph[maxn], euler;
int start_time[maxn], end_time[maxn], depth[maxn], order[maxn], segtree[maxn*10], nodes[maxn], cur_time;

void init(int s, int e, int node)
{
	if(s==e){
		segtree[node] = euler[s];
		return;
	}
	int mid, lc, rc;
	mid = (s+e)>>1;
	lc = 2*node+1;
	rc = lc+1;
	init(s, mid, lc);
	init(mid+1, e, rc);
	if(depth[segtree[lc]]<depth[segtree[rc]])
		segtree[node] = segtree[lc];
	else
		segtree[node] = segtree[rc];	
}

int rmq(int ss, int se, int qs, int qe, int node_num)
{
	if(ss>se || ss>qe || qs>se)
        return -1;
    if(ss>=qs && qe>=se)
        return segtree[node_num];
    int mid=(ss+se)>>1, lc=2*node_num+1, rc=lc+1, ret1, ret2;
    ret1 = rmq(ss, mid, qs, qe, lc);
    ret2 = rmq(mid+1, se, qs, qe, rc);
    if(ret1==-1)
        return ret2;
    else if(ret2==-1)
        return ret1;
    else{
        if(depth[ret1]<depth[ret2])
            return ret1;
        else
            return ret2;
    }
}

int lca(int u, int v)
{
	if(order[u]>order[v])
		swap(u, v);
	return rmq(0, euler.size()-1, order[u], order[v], 0);
}

bool is_anc(int n1, int n2)
{
	return (start_time[n1]<=start_time[n2] & end_time[n1]>=end_time[n2]);
}

bool in_path(int c_node, int p1, int p2)
{
	return (is_anc(p1, c_node) & is_anc(c_node, p2));
}

void dfs(int cur, int parent, int d)
{
	order[cur] = euler.size();
	euler.push_back(cur);
	start_time[cur] = ++cur_time;
	depth[cur] = d;
	int i;
	for(i=0; i<graph[cur].size(); i++){
		if(graph[cur][i]!=parent){
			dfs(graph[cur][i], cur, d+1);
			euler.push_back(cur);
		}
	}
	end_time[cur] = cur_time;
}

int main()
{
	//freopen("i.txt", "r", stdin);
	int t, n, i, j, u, v, q, k, lnode, rnode, ld, rd, l;
	scanf("%d", &t);
	while(t--){
		scanf("%d", &n);
		for(i=1; i<=n; i++)
			graph[i].clear();
		euler.clear();
		for(i=0; i<n-1; i++){
			scanf("%d%d", &u, &v);
			graph[u].push_back(v);
			graph[v].push_back(u);
		}
		cur_time = 0;
		dfs(1, 0, 0);
		init(0, euler.size()-1, 0);
		scanf("%d", &q);
		//for(i=1; i<=n; i++)
		//	cout << start_time[i] << " " << end_time[i] << "\n";
		while(q--){
			scanf("%d", &k);
			for(i=0; i<k; i++)
				scanf("%d", &nodes[i]);
			lnode = nodes[0];
			rnode = nodes[0];
			for(i=1; i<k; i++){
				//cout << start_time[nodes[i]] << " " << end_time[nodes[i]] << "\n";
				if(start_time[nodes[i]]>start_time[rnode])
					rnode = nodes[i];
				if(is_anc(nodes[i], lnode) || is_anc(lnode, nodes[i])){
					//cout << "b " << nodes[i] << " " << lnode << "\n";
					if(is_anc(lnode, nodes[i]))
						lnode = nodes[i];
				}
				else{
					if(start_time[lnode]>start_time[nodes[i]])
						lnode = nodes[i];
				}
			}
			//cout << "\n";
			l = lca(lnode, rnode);
			//cout << "Q " << q << " " << lnode << " " << rnode << " " << l  << "\n";
			bool pos = true;
			for(i=0; i<k; i++){
				if(lnode==rnode){
					pos = pos&is_anc(nodes[i], lnode);
				}
				else{
					pos = pos&(in_path(nodes[i], l, lnode) | in_path(nodes[i], l, rnode));
				}
				/*if(in_path(nodes[i], l, lnode) | in_path(nodes[i], l, rnode))
					continue;
				else{
					pos = false;
					break;
				}*/
			}
			if(pos)
				printf("Yes\n");
			else
				printf("No\n");
		}
	}
	return 0;
}