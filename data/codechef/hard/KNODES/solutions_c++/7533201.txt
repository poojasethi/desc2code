# include<bits/stdc++.h>
using namespace std ;
typedef long long ll ;
typedef unsigned long long ull;
ll INF = 1e9 ;
typedef pair < int , int > pii ;
typedef  vector < int > vi ;
typedef vector < pii > vpi ;
typedef vector < ll > vl ;
typedef pair < int , pii > tri ;
typedef vector < string > vs ;
typedef vector < vi > mat ;
#define all(a) a.begin(),a.end()
#define si(n) scanf("%d",&n)
#define ss(n) scanf("%s" , n)
#define sl(n) scanf("%lld" , &n)
#define pi(n) printf("%d" , n)
#define ps(n) printf("%s" , n)
#define pl(n) printf("%lld" , n)
#define pnl() printf("\n")
#define fors( i , a , b ) for ( int i = a ; i < b ; i++ )
#define pb push_back
#define ff first
#define mp make_pair
#define sz(a) a.size()
#define fill(a,v)  memset(a,v,sizeof(a))
#define index(arr,ind) (lower_bound(all(arr),ind)-arr.begin())

// It is  a tree
// Assuming nodes numbered from 1 to n and let us assume root is Node 1.

const int maxn = 1000005 ;
int n  , vis[maxn] , t ;
vi g[maxn] ;
int trsz[maxn] , pa[maxn][18] , par[maxn] ,depth[maxn];

int tim = 0 ;

int start[maxn] , end[maxn] ;


/************************************************************

DFS

*************************************************************/

// Finding the parent , depth ,  start , end time of every node //
void dfs(int root)
{
	vis[root] = 1;
	tim++;
	for(int i=0;i< g[root].size();i++)
	{
		int v = g[root][i];
		if( vis[v] )
		continue;

			depth[v] = depth[root] + 1;
			par[v] = root;
			start[v] = tim;
			dfs(v);

	}
	end[root] = tim;
}

// Finding the parent at the jth level of a node //
void callca()
{

    for( int i = 0 ; i <= n ; i++ )
        for ( int j = 0 ; j < 18 ; j++)
        pa[i][j] = -1 ;


    for ( int i = 1 ; i <= n ; i++)
        pa[i][0] = par[i] ;

    for ( int j = 1 ; j < 18 ; j++)
    {
        for ( int i = 1 ; i <= n ; i++)
        {
            if ( pa[i][j-1] != -1)
            pa[i][j] = pa[pa[i][j-1]][j-1] ;
        }
    }
}


int  lca ( int u , int v  )
{

    if ( depth[u] < depth[v] )
    swap ( u , v ) ;

   int diff = depth[u] - depth[v] ;

   for ( int i = 17 ; i > -1 ; i--)
     {
         if ( ( 1 << i ) <= ( depth[u] - depth[v] ) )
         u = pa[u][i] ;
     }
     if ( u == v )
            return u ;

     for ( int i = 17 ; i > -1 ; i--)
     {
         if( pa[u][i] != pa[v][i] )
         {
             u = pa[u][i] ;
             v = pa[v][i] ;
         }
     }

     if ( u == v )
        return u ;
     return pa[u][0] ;

}




int main()
{
   si(t) ;
   while(t--)
   {

   int fr , to ;
   si(n) ;

   fors ( i , 0 , n + 1 )
   {
       g[i].clear() ;
       vis[i] = 0 ;
   }

   fors ( i , 0 , n - 1 )
   {
       si(fr) , si(to) ;
       g[fr].pb(to) ;
       g[to].pb(fr) ;
   }

   // used for calculating parent of each node and depth , start , end time of each node
   depth[1] = 1 ;
   par[1] = -1 ;

   dfs( 1 ) ;

   callca() ;

   int Q,k,max_depth_node,max_d,smallest_depth_node,small_d;
   scanf("%d",&Q);

  fors ( i , 0 , Q )
  {
		max_d = 0;
		small_d = 1e9;
		vector<int> nodes;
		scanf("%d",&k);

		fors ( j , 0 , k )
		{
			int x;
			scanf("%d",&x);
			if( depth[x] > max_d )
			{
				max_d = depth[x];
				max_depth_node = x;
			}
			if( depth[x] < small_d )
			{
				small_d = depth[x];
				smallest_depth_node = x;
			}
			nodes.pb(x);
		}

		int diff = -1,flag=1,remaining_maximum_depth_node,rem_max_d=0;

		for(int j=0;j<k;j++)
		{
			int u = nodes[j];
			if( start[u]<=start[max_depth_node] && end[u]>=end[max_depth_node] )
			{
				continue;
			}
			else
			{
				flag = 0;
				if( depth[u] > rem_max_d){
					rem_max_d = depth[u];
					remaining_maximum_depth_node = u;
				}
			}
		}

		if( flag ){
			printf("Yes\n");
			continue;
		}

		int print = 0;
		for(int j=0;j<k;j++){
			int u = nodes[j];
			if( start[u]<=start[max_depth_node] && end[u]>=end[max_depth_node] ){
				continue;
			}
			else if( !(start[u]<=start[remaining_maximum_depth_node] && end[u]>=end[remaining_maximum_depth_node]) ){
				printf("No\n");
				print = 1;
				break;
			}
		}
		if( print == 0 )
		{
			int x = lca(max_depth_node ,remaining_maximum_depth_node);
			if( start[smallest_depth_node] >= start[x] && end[smallest_depth_node] <= end[x] ){
				printf("Yes\n");
			}
			else{
				printf("No\n");
			}
		}
	}


   }

   return 0 ;
}
