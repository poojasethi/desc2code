#include<bits/stdc++.h>
#define mod 1000000007
#define len(a) strlen(a)
#define ll long long
#define nl printf("\n")

#define db printf("debug")
#define yes printf("YES\n")
#define no printf("NO\n")
#define pb(a) push_back(a)
#define po(a) pop_back()
#define mp(a,b) make_pair(a,b)
#define set(a,v) memset(a,v,sizeof(a))
#define sz(v) v.size()
#define gc getchar//_unlocked

#define pcase(i) printf("Case %d:\n",i)
using namespace std;


vector<int> parent(200005);
vector<int>depth(200005);
vector<vector<int> >tree(200005);
vector<bool>vis(200005,false);
vector<int>start(200005,0);
vector<int>finish(200005,0);
int tme=0;
inline void ip( int &x) {
	    register  int c = gc();
	    x = 0;
	    for(; ((c<48 || c>57) ); c = gc());
	    for(; c>47 && c<58 ; c = gc()) {
	        x = (x<<1) + (x<<3) + c - 48;
	    }

	}
void pnt(int n)
{
    int i;
    for(i=0;i<=n;i++)
    {
        printf("%d->",i);
        for(int j=0;j<tree[i].size();j++)
            printf("%d ",tree[i][j]);
        nl;
    }
}

/*---------------------------------------------------------------------------------------------------------------------------------------------------*/

void dfs(int root,int cnt)
{
    vis[root]=true;
    depth[root]=cnt;

    int x=tree[root].size();
    for(int i=0;i<x;i++)
    {
        if( !vis[tree[root][i] ] )
            {
                parent[ tree[root][i] ] = root;
                start[ tree[root][i] ]= ++tme;
                dfs(tree[root][i],cnt+1);
            }
    }
    finish[root]= ++tme;
}

int up(int node, int dif)
{
    for(int i=1; i<=dif;i++)
    {
        node=parent[node];
    }
    return node;
}

int LCA(int u,int v)
{
    int h1 = depth[u];
    int h2 = depth[v];
    //cout<<h1<<" "<<h2;nl;
    if(h1!= h2)
    {
        int dif = abs(h1-h2);
        if(h1<h2)
        {
            v = up(v,dif);
        }
        else
        {
            u = up(u,dif);
        }
    }

    if(u==v)
        return u;

    while(parent[u]!= parent[v])
    {
        u= parent[u];
        v= parent[v];
    }
    return parent[u];    // or u  may return parent[v] also
}

void init()
{
    parent.clear();
    depth.clear();
    start.clear();
    finish.clear();
    for(int i=0;i<200005;i++)
    {
        tree[i].clear();
        vis[i]= false;
    }
}
int main()
{
        int t;
        ip(t);
        while(t--)
    {
        init();
        int n,op,b,m,root,i,j,q;
        cin>>n;

        for(i=1;i<=n-1;i++)
        {
            int x,y;
            ip(x);ip(y);
            tree[x].pb(y);
            tree[y].pb(x);
        }

       //pnt(n);
       parent[1]=1;
        dfs(1,0);
       // for(i=1;i<=n;i++)
         //   printf("i=%d d=%d s=%d e=%d\n",i,depth[i],start[i], finish[i]);nl;




        ip(q);
        while(q--)
        {
            vector<int>A;
            A.clear();

            int k, x, D, S, RD, mx_depth=-1, mn_depth=INT_MAX;
            ip(k);
            for(i=0;i<k;i++)
            {
                ip(x);
                if(depth[x] > mx_depth)               // calculating deepest node
                {
                    mx_depth=depth[x];
                    D=x;
                }

                if(depth[x] < mn_depth)             // calculating node closest to root
                {
                    mn_depth= depth[x];
                    S=x;
                }

                A.pb(x);                        // saving all k nodes

            }
                                                    /*for(int j=0;j<A.size();j++)
                                                       cout<<A[j]<<" ";nl;

                                                    cout<<"n/d="<<S<<" "<<D;nl;*/
                for(i=0;i<A.size();i++)         // getting set B
                {
                    x= A[i];
                    if(start[x]<=start[D] and finish[x]>=finish[D])
                    {
                        A.erase(A.begin()+i);
                        i--;
                    }
                }
                /*cout<<"set b=";
                for(int j=0;j<A.size();j++)
                    cout<<A[j]<<" ";nl;*/

                if(A.size()==0)         // checking size of set B
                {
                    printf("Yes\n");
                    continue;
                }

                mx_depth=-1;
                for(i=0;i<A.size();i++)         // getting deepest node from set B
                {
                    x= A[i];
                   if(depth[x]>mx_depth)
                   {
                       mx_depth= depth[x];
                       RD= x;
                   }
                }
                 for(i=0;i<A.size();i++)         // getting set E
                {
                    x=A[i];
                    if(start[x]<=start[RD] and finish[x]>=finish[RD])
                    {
                        A.erase(A.begin()+i);
                        i--;
                    }
                }

                if(!A.empty())                  // checking set E is empty or not
                {
                    printf("No\n");
                    continue;
                }

                int L= LCA(D, RD);

                if(start[L]<=start[S] and finish[L]>= finish[S])
                    printf("Yes\n");
                else
                    printf("No\n");


            }
        }
}

