/*Path containing K Nodes*/

#include<cstdio>
#include<cstring>
#include<vector>

#define MAXN 100000
#define LOGMAXN 17

using namespace std;

bool visited[MAXN + 1];
int parent_dp[LOGMAXN + 1][MAXN + 1];
int depth[MAXN + 1], disc[MAXN + 1], finish[MAXN + 1], log_2[MAXN + 1], nodes[MAXN], parent[MAXN + 1];
vector< vector<int> > adj_list;
int counter;

void initialize(void);
void dfs(int, int, int);
void preprocess_lca(int);
int lca(int, int);

int main()
{
	bool on_path;
	int i, K, l, largest_depth, largest_depth_node, N, Q, remaining_largest_depth, remaining_largest_depth_node, smallest_depth, smallest_depth_node, T, u, v;
	initialize();
	scanf("%d", &T);
	while (T--)
	{
		adj_list.clear();
		scanf("%d", &N);
		adj_list.resize(N + 1);
		for (i = 1; i < N; i++)
		{
			scanf("%d %d", &u, &v);
			adj_list[u].push_back(v);
			adj_list[v].push_back(u);
		}
		memset(visited, 0, sizeof(visited));
		counter = 0;
		dfs(1, -1, 1);
		preprocess_lca(N);
		scanf("%d", &Q);
		while (Q--)
		{
			scanf("%d", &K);
			for (i = 0; i < K; i++)
				scanf("%d", &nodes[i]);
			smallest_depth = 1000000000;
			largest_depth = -1;
			for (i = 0; i < K; i++)
			{
				if (smallest_depth > depth[nodes[i]])
				{
					smallest_depth = depth[nodes[i]];
					smallest_depth_node = nodes[i];
				}
				if (largest_depth < depth[nodes[i]])
				{
					largest_depth = depth[nodes[i]];
					largest_depth_node = nodes[i];
				}
			}
			on_path = true;
			remaining_largest_depth = 0;
			for (i = 0; i < K; i++)
			{
				u = nodes[i];
				if ((disc[u] <= disc[largest_depth_node]) && (finish[u] >= finish[largest_depth_node]))
					continue;
				on_path = false;
				if (remaining_largest_depth < depth[u])
				{
					remaining_largest_depth = depth[u];
					remaining_largest_depth_node = u;
				}
			}
			if (on_path)
			{
				puts("Yes");
				continue;
			}
			on_path = true;
			for (i = 0; i < K; i++)
			{
				u = nodes[i];
				if ((disc[u] <= disc[largest_depth_node]) && (finish[u] >= finish[largest_depth_node]))
					continue;
				if ((disc[u] <= disc[remaining_largest_depth_node]) && (finish[u] >= finish[remaining_largest_depth_node]))
					continue;
				on_path = false;
				puts("No");
				break;
			}
			if (on_path)
			{
				l = lca(largest_depth_node, remaining_largest_depth_node);
				if ((disc[l] <= disc[smallest_depth_node]) && (finish[l] >= finish[smallest_depth_node]))
					puts("Yes");
				else
					puts("No");
			}
		}
	}
	return 0;
}

void initialize(void)
{
	int i, next_pow_2;
	log_2[1] = 0;
	log_2[2] = 1;
	next_pow_2 = 4;
	for (i = 3; i <= MAXN; i++)
	{
		if (i == next_pow_2)
		{
			log_2[i] = log_2[i - 1] + 1;
			next_pow_2 <<= 1;
		}
		else
			log_2[i] = log_2[i - 1];
	}
}

void dfs(int u, int prev, int height)
{
	int i, length, v;
	disc[u] = ++counter;
	parent[u] = prev;
	depth[u] = height;
	visited[u] = true;
	length = adj_list[u].size();
	for (i = 0; i < length; i++)
	{
		v = adj_list[u][i];
		if (!visited[v])
			dfs(v, u, height + 1);
	}
	finish[u] = ++counter;
}

void preprocess_lca(int N)
{
	int i, j;
	memset(parent_dp, -1, sizeof(parent_dp));
	for (i = 1; i <= N; i++)
		parent_dp[0][i] = parent[i];
	for (i = 1; (1 << i) <= N; i++)
		for (j = 1; j <= N; j++)
			if (parent_dp[i - 1][j] != -1)
				parent_dp[i][j] = parent_dp[i - 1][parent_dp[i - 1][j]];
}

int lca(int u, int v)
{
	int i, logval;
	if (depth[u] > depth[v])
		swap(u, v);
	logval = log_2[depth[v]];
	for (i = logval; i >= 0; i--)
		if ((depth[v] - (1 << i)) >= depth[u])
			v = parent_dp[i][v];
	if (u == v)
		return u;
	for (i = logval; i >= 0; i--)
	{
		if ((parent_dp[i][u] != -1) && (parent_dp[i][u] != parent_dp[i][v]))
		{
			u = parent_dp[i][u];
			v = parent_dp[i][v];
		}
	}
	return parent[u];
}