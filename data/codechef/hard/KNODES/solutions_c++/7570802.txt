#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
using namespace std;

#define MaxN 100009

vector<int> graph[100005];

int Root[MaxN][18], log2[MaxN], depth[MaxN], start[MaxN], end[MaxN], parent[MaxN], counter, visited[MaxN];

void init(){
	log2[0]= 0, log2[1]= 0, log2[2]= 1;
	int cmp= 4;
	
	for(int i=3;i<=100000;i++){
		if(cmp>i){
			log2[i]= log2[i-1];
		}else{
			log2[i]= log2[i-1]+1;
			cmp<<=1;
		}
	}
}

void get2p(int N){
	
	memset(Root, -1, sizeof(int)*18*(N+1));
	for(int i=1;i<=N;i++){
		Root[i][0]= parent[i];
	}
	
	for(int i=1;(1<<i)<=N;i++){
		for(int j=1;j<=N;j++){
			if(Root[j][i-1]!=-1){
				Root[j][i]= Root[Root[j][i-1]][i-1];
			}
		}
	}
	
}

int lca(int p, int q){
	
	if(depth[p]>depth[q]){
		swap(p, q);
	}
	
	int steps = log2[depth[q]];
	
	for(int i=steps;i>=0;i--){
		if((depth[q]-(1<<i)) >= depth[p])
			q= Root[q][i];
	}
	
	if(p==q) return p;
	
	for(int i=steps;i>=0;i--){
		if(Root[p][i]!=Root[q][i])
			p= Root[p][i], q= Root[q][i];
	}
	
	return parent[p];
}

void LCA(int N){
	get2p(N);
}

void dfs(int root){
	visited[root] = 1;
	counter++;
	
	for(int i=0;i<(int)graph[root].size();i++){
		int v= graph[root][i];
		if(visited[v]) continue;
		else{
			depth[v]= depth[root]+1;
			parent[v] = root;
			start[v]= counter;
			dfs(v);
		}
	}
	end[root] = counter;
}

int main(){
	int tc, N, q, a, x, y;
	init();
	cin>> tc;
	
	while(tc--){
		
		cin>> N;
		
		for(int i=1;i<=N;i++) graph[i].clear(), visited[i]= 0;
		
		for(int i=1;i< N;i++){
			cin>> x >> y;
			graph[x].push_back(y);
			graph[y].push_back(x);
		}
		
		counter= 0;
		depth[1]= 1;
		parent[1]= -1;
		dfs(1);
		LCA(N);
		cin>> q;
		
		int k, max_depth_node, max_d, smallest_depth_node, small_d;
		
		for(int i=0;i<q;i++){
			max_d = 0;
			small_d = 1e9;
			vector<int> nodes;
			cin>> k;
			for(int j=0;j<k;j++){
				cin>> a;
				if(depth[a] > max_d){
					max_d = depth[a];
					max_depth_node = a;  
				}
				if(depth[a] < small_d){
					small_d = depth[a];
					smallest_depth_node = a;
				}
				nodes.push_back(a);
			}
		
		
			int flag = 1, remaining_maximum_depth_node, rem_max_d = 0;
			
			for(int j=0;j<k;j++){
				int u = nodes[j];
			
				if(start[u]<=start[max_depth_node]&&end[u]>=end[max_depth_node]){
					continue;
				}else{
					flag = 0;
					if(depth[u]>rem_max_d){
						rem_max_d = depth[u];
						remaining_maximum_depth_node = u;
					}
				}
			}
			
			if(flag){
				printf("Yes\n");
				continue;
			}
			
			int print = 0;
			for(int j=0;j<k;j++){
				int u = nodes[j];
				if(start[u]<=start[max_depth_node]&&end[u]>=end[max_depth_node]){
					continue;
				}else{
					if(!(start[u]<=start[remaining_maximum_depth_node]&&end[u]>=end[remaining_maximum_depth_node])){
						printf("No\n");
						print = 1;
						break;
					}
				}
			}
			
			if(print == 0){
				int x = lca(max_depth_node, remaining_maximum_depth_node);
				if(start[smallest_depth_node] >= start[x] && end[smallest_depth_node]<=end[x]){
					printf("Yes\n");
				}else{
					printf("No\n");
				}
			}
		
		}
		
	}
}
