#include <bits/stdc++.h>
#define MAX 100005
#define MAXVL 19

using namespace std;

vector <int> v[MAX];
int par[MAXVL][MAX];
int in[MAX];
int out[MAX];
int A[MAX];
int depth[MAX];
int tym;

bool chk(int a, int b)
{
	return (in[b] >= in[a] && out[b] <= out[a]);
}


void dfs(int curr, int prev)
{
	in[curr] = tym++;
	par[0][curr] = prev;
	for ( int i = 1; i < MAXVL; i++ ) par[i][curr] = -1;
	for ( int i = 0; i < v[curr].size(); i++ ) {
		if ( v[curr][i] == prev ) continue;
		depth[v[curr][i]] = depth[curr] + 1;
		dfs(v[curr][i], curr);
	}
	out[curr] = tym;
}

bool lies_in_path(int node_1, int node_2, int node_3) {
  return chk(node_1, node_3) and chk(node_3, node_2);
}

void pre(int n)
{
	for ( int i = 1; i < MAXVL; i++ ) {
		for ( int j = 0; j < n; j++ ) {
			if ( par[i-1][j] == -1 ) continue;
			par[i][j] = par[i-1][par[i-1][j]];
		}
	}
	return;
}

int LCA(int x, int y)
{
	if ( depth[x] < depth[y] ) swap(x,y);
	int diff_dep = depth[x] - depth[y];
	for ( int i = 0; i < MAXVL; i++ ) {
		if ( diff_dep & (1<<i) ) x = par[i][x];
	}
	if ( x == y ) return x;
	for ( int i = MAXVL-1; i >= 0; i-- ) {
		if ( par[i][x] != par[i][y] ) {
			x = par[i][x];
			y = par[i][y];
		}
	}
	return par[0][x];
}

int dist(int x, int y)
{
	return depth[x] + depth[y] - 2*depth[LCA(x,y)];
}

int main()
{
	int t,n,x,y,k,q;
	cin >> t;
	while ( t-- ) {
		tym = 0;
		cin >> n;
		for ( int i = 0; i < n; i++ ) v[i].clear(), depth[i] = 0;
		for ( int i = 0; i < n-1; i++ ) {
			cin >> x >> y;
			x--, y--;
			v[x].push_back(y);
			v[y].push_back(x);
		}
		tym = 0;
		dfs(0,-1);
		pre(n);
		cin >> q;
		while ( q-- ) {
			cin >> k;
			for ( int i = 0; i < k; i++ ) cin >> A[i], A[i]--;
			int left_node = A[0], left_val = in[A[0]], right_node, right_val = -1;
			for ( int i = 0; i < k; i++ ) {
				if ( right_val < in[A[i]] ) {
					right_val = in[A[i]];
					right_node = A[i];
				}
				if ( 1 ) {
					if ( chk(left_node, A[i]) ) {
						left_node = A[i];
						left_val = in[A[i]];
					}
					else if ( chk(A[i], left_node) ) {
					}
					else {
						if ( left_val > in[A[i]] ) {
							left_val = in[A[i]];
							left_node = A[i];
						}
					}
				}
			}
/*			int flag = 1;
			for ( int i = 0; i < k; i++ ) flag &= (dist(left_node,A[i]) + dist(A[i],right_node) == dist(left_node, right_node)); 
			if ( flag ) puts("Yes");
			else puts("No"); */
			int lca_node = LCA(left_node, right_node);
	      // cout << l_node << ", " << r_node << "," << lca_node << "\n";
	      bool yes = true;
	      for (int i = 0; i < k; ++i) {
	        if (left_node == right_node) {
	          yes &= chk(A[i], left_node);
	        } else {
	          yes &= lies_in_path(lca_node, left_node, A[i]) or lies_in_path(lca_node, right_node, A[i]);
	        }
	      }
	      cout << (yes?"Yes\n":"No\n");
		}
	}
	return 0;
}